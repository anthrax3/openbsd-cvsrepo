head	1.12;
access;
symbols
	OPENBSD_6_2:1.12.0.10
	OPENBSD_6_2_BASE:1.12
	OPENBSD_6_1:1.12.0.8
	OPENBSD_6_1_BASE:1.12
	OPENBSD_6_0:1.12.0.4
	OPENBSD_6_0_BASE:1.12
	OPENBSD_5_9:1.12.0.2
	OPENBSD_5_9_BASE:1.12
	OPENBSD_5_8:1.10.0.8
	OPENBSD_5_8_BASE:1.10
	OPENBSD_5_7:1.10.0.2
	OPENBSD_5_7_BASE:1.10
	OPENBSD_5_6:1.10.0.4
	OPENBSD_5_6_BASE:1.10
	OPENBSD_5_5:1.9.0.4
	OPENBSD_5_5_BASE:1.9
	OPENBSD_5_4:1.8.0.42
	OPENBSD_5_4_BASE:1.8
	OPENBSD_5_3:1.8.0.40
	OPENBSD_5_3_BASE:1.8
	OPENBSD_5_2:1.8.0.38
	OPENBSD_5_2_BASE:1.8
	OPENBSD_5_1_BASE:1.8
	OPENBSD_5_1:1.8.0.36
	OPENBSD_5_0:1.8.0.34
	OPENBSD_5_0_BASE:1.8
	OPENBSD_4_9:1.8.0.32
	OPENBSD_4_9_BASE:1.8
	OPENBSD_4_8:1.8.0.30
	OPENBSD_4_8_BASE:1.8
	OPENBSD_4_7:1.8.0.26
	OPENBSD_4_7_BASE:1.8
	OPENBSD_4_6:1.8.0.28
	OPENBSD_4_6_BASE:1.8
	OPENBSD_4_5:1.8.0.24
	OPENBSD_4_5_BASE:1.8
	OPENBSD_4_4:1.8.0.22
	OPENBSD_4_4_BASE:1.8
	OPENBSD_4_3:1.8.0.20
	OPENBSD_4_3_BASE:1.8
	OPENBSD_4_2:1.8.0.18
	OPENBSD_4_2_BASE:1.8
	OPENBSD_4_1:1.8.0.16
	OPENBSD_4_1_BASE:1.8
	OPENBSD_4_0:1.8.0.14
	OPENBSD_4_0_BASE:1.8
	OPENBSD_3_9:1.8.0.12
	OPENBSD_3_9_BASE:1.8
	OPENBSD_3_8:1.8.0.10
	OPENBSD_3_8_BASE:1.8
	OPENBSD_3_7:1.8.0.8
	OPENBSD_3_7_BASE:1.8
	OPENBSD_3_6:1.8.0.6
	OPENBSD_3_6_BASE:1.8
	OPENBSD_3_5:1.8.0.4
	OPENBSD_3_5_BASE:1.8
	OPENBSD_3_4:1.8.0.2
	OPENBSD_3_4_BASE:1.8
	OPENBSD_3_3:1.6.0.6
	OPENBSD_3_3_BASE:1.6
	OPENBSD_3_2:1.6.0.4
	OPENBSD_3_2_BASE:1.6
	OPENBSD_3_1:1.6.0.2
	OPENBSD_3_1_BASE:1.6
	OPENBSD_3_0:1.3.0.8
	OPENBSD_3_0_BASE:1.3
	OPENBSD_2_9:1.3.0.6
	OPENBSD_2_9_BASE:1.3
	OPENBSD_2_8:1.3.0.4
	OPENBSD_2_8_BASE:1.3
	OPENBSD_2_7:1.3.0.2
	OPENBSD_2_7_BASE:1.3
	OPENBSD_2_6:1.2.0.4
	OPENBSD_2_6_BASE:1.2
	OPENBSD_2_5:1.2.0.2
	OPENBSD_2_5_BASE:1.2;
locks; strict;
comment	@ * @;


1.12
date	2015.12.31.16.44.22;	author mestre;	state Exp;
branches;
next	1.11;
commitid	2lAH78sqshL9k4xy;

1.11
date	2015.12.26.00.26.40;	author mestre;	state Exp;
branches;
next	1.10;
commitid	NcBz9zfScw6TwPoT;

1.10
date	2014.03.11.07.42.55;	author guenther;	state Exp;
branches;
next	1.9;

1.9
date	2013.08.29.20.22.19;	author naddy;	state Exp;
branches;
next	1.8;

1.8
date	2003.06.03.03.01.41;	author millert;	state Exp;
branches;
next	1.7;

1.7
date	2003.04.06.18.50.38;	author deraadt;	state Exp;
branches;
next	1.6;

1.6
date	2002.02.17.19.42.21;	author millert;	state Exp;
branches;
next	1.5;

1.5
date	2002.02.16.22.33.16;	author millert;	state Exp;
branches;
next	1.4;

1.4
date	2002.02.16.21.27.11;	author millert;	state Exp;
branches;
next	1.3;

1.3
date	2000.01.03.23.22.41;	author pjanzen;	state Exp;
branches;
next	1.2;

1.2
date	99.01.18.21.53.22;	author pjanzen;	state Exp;
branches;
next	1.1;

1.1
date	99.01.18.21.14.15;	author pjanzen;	state Exp;
branches;
next	;


desc
@@


1.12
log
@Include only needed header files per each source file

OK tb@@
@
text
@/*	$OpenBSD: extern.h,v 1.11 2015/12/26 00:26:40 mestre Exp $	*/
/*	$NetBSD: extern.h,v 1.8 1998/09/13 15:27:30 hubertf Exp $ */

/*
 * Copyright (c) 1983, 1993
 *	The Regents of the University of California.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 *	@@(#)externs.h	8.1 (Berkeley) 5/31/93
 */

#include <sys/types.h>

#include <setjmp.h>

#ifndef __GNUC__
#define __attribute__(x)
#endif

	/* program mode */
extern int mode;
extern jmp_buf restart;
#define MODE_PLAYER	1
#define MODE_DRIVER	2
#define MODE_LOGGER	3

	/* command line flags */
extern char debug;			/* -D */
extern char randomize;			/* -x, give first available ship */
extern char longfmt;			/* -l, print score in long format */
extern char nobells;			/* -b, don't ring bell before Signal */

	/* other initial modes */
extern gid_t gid;
extern gid_t egid;

#define die()		(arc4random_uniform(6) + 1)
#define sqr(a)		((a) * (a))
#define min(a,b)	((a) < (b) ? (a) : (b))

#define grappled(a)	((a)->file->ngrap)
#define fouled(a)	((a)->file->nfoul)
#define snagged(a)	(grappled(a) + fouled(a))

#define grappled2(a, b)	((a)->file->grap[(b)->file->index].sn_count)
#define fouled2(a, b)	((a)->file->foul[(b)->file->index].sn_count)
#define snagged2(a, b)	(grappled2(a, b) + fouled2(a, b))

#define Xgrappled2(a, b) ((a)->file->grap[(b)->file->index].sn_turn < turn-1 ? grappled2(a, b) : 0)
#define Xfouled2(a, b)	((a)->file->foul[(b)->file->index].sn_turn < turn-1 ? fouled2(a, b) : 0)
#define Xsnagged2(a, b)	(Xgrappled2(a, b) + Xfouled2(a, b))

#define cleangrapple(a, b, c)	Cleansnag(a, b, c, 1)
#define cleanfoul(a, b, c)	Cleansnag(a, b, c, 2)
#define cleansnag(a, b, c)	Cleansnag(a, b, c, 3)

#define sterncolour(sp)	((sp)->file->stern+'0'-((sp)->file->captured?10:0))
#define sternrow(sp)	((sp)->file->row + dr[(sp)->file->dir])
#define sterncol(sp)	((sp)->file->col + dc[(sp)->file->dir])

#define capship(sp)	((sp)->file->captured?(sp)->file->captured:(sp))

#define readyname(r)	((r) & R_LOADING ? '*' : ((r) & R_INITIAL ? '!' : ' '))

/* loadL and loadR, should match loadname[] */
#define L_EMPTY		0		/* should be 0, don't change */
#define L_GRAPE		1
#define L_CHAIN		2
#define L_ROUND		3
#define L_DOUBLE	4
#define L_EXPLODE	5

/*
 * readyL and readyR, these are bits, except R_EMPTY
 */
#define R_EMPTY		0		/* not loaded and not loading */
#define R_LOADING	1		/* loading */
#define R_DOUBLE	2		/* loading double */
#define R_LOADED	4		/* loaded */
#define R_INITIAL	8		/* loaded initial */

#define HULL		0
#define RIGGING		1

#define W_CAPTAIN	1
#define W_CAPTURED	2
#define W_CLASS		3
#define W_CREW		4
#define W_DBP		5
#define W_DRIFT		6
#define W_EXPLODE	7
#define W_FILE		8
#define W_FOUL		9
#define W_GUNL		10
#define W_GUNR		11
#define W_HULL		12
#define W_MOVE		13
#define W_OBP		14
#define W_PCREW		15
#define W_UNFOUL	16
#define W_POINTS	17
#define W_QUAL		18
#define W_UNGRAP	19
#define W_RIGG		20
#define W_COL		21
#define W_DIR		22
#define W_ROW		23
#define W_SIGNAL	24
#define W_SINK		25
#define W_STRUCK	26
#define W_TA		27
#define W_ALIVE		28
#define W_TURN		29
#define W_WIND		30
#define W_FS		31
#define W_GRAP		32
#define W_RIG1		33
#define W_RIG2		34
#define W_RIG3		35
#define W_RIG4		36
#define W_BEGIN		37
#define W_END		38
#define W_DDEAD		39

#define NLOG 10
struct logs {
	char l_name[20];
	uid_t l_uid;
	int l_shipnum;
	int l_gamenum;
	int l_netpoints;
};

struct BP {
	short turnsent;
	struct ship *toship;
	short mensent;
};

struct snag {
	short sn_count;
	short sn_turn;
};

#define NSCENE	nscene
#define NSHIP	10
#define NBP	3

#define NNATION	8
#define N_A	0
#define N_B	1
#define N_S	2
#define N_F	3
#define N_J	4
#define N_D	5
#define N_K	6
#define N_O	7

struct File {
	int index;
	char captain[20];		/* 0 */
	short points;			/* 20 */
	unsigned char loadL;		/* 22 */
	unsigned char loadR;		/* 24 */
	unsigned char readyL;		/* 26 */
	unsigned char readyR;		/* 28 */
	struct BP OBP[NBP];		/* 30 */
	struct BP DBP[NBP];		/* 48 */
	char struck;			/* 66 */
	struct ship *captured;		/* 68 */
	short pcrew;			/* 70 */
	char movebuf[10];		/* 72 */
	char drift;			/* 82 */
	short nfoul;
	short ngrap;
	struct snag foul[NSHIP];	/* 84 */
	struct snag grap[NSHIP];	/* 124 */
	char RH;			/* 224 */
	char RG;			/* 226 */
	char RR;			/* 228 */
	char FS;			/* 230 */
	char explode;			/* 232 */
	char sink;			/* 234 */
	unsigned char dir;
	short col;
	short row;
	char loadwith;
	char stern;
};

struct ship {
	const char *shipname;		/* 0 */
	struct shipspecs *specs;	/* 2 */
	unsigned char nationality;	/* 4 */
	short shiprow;			/* 6 */
	short shipcol;			/* 8 */
	char shipdir;			/* 10 */
	struct File *file;		/* 12 */
};

struct scenario {
	char winddir;			/* 0 */
	char windspeed;			/* 2 */
	char windchange;		/* 4 */
	unsigned char vessels;		/* 12 */
	const char *name;		/* 14 */
	struct ship ship[NSHIP];	/* 16 */
};
extern struct scenario scene[];
extern int nscene;

struct shipspecs {
	char bs;
	char fs;
	char ta;
	short guns;
	unsigned char class;
	char hull;
	unsigned char qual;
	char crew1;
	char crew2;
	char crew3;
	char gunL;
	char gunR;
	char carL;
	char carR;
	int rig1;
	int rig2;
	int rig3;
	int rig4;
	short pts;
};
extern struct shipspecs specs[];

extern struct scenario *cc;		/* the current scenario */
extern struct ship *ls;		/* &cc->ship[cc->vessels] */

#define SHIP(s)		(&cc->ship[s])
#define foreachship(sp)	for ((sp) = cc->ship; (sp) < ls; (sp)++)

struct windeffects {
	char A, B, C, D;
};
extern const struct windeffects WET[7][6];

struct Tables {
	char H, G, C, R;
};
extern const struct Tables RigTable[11][6];
extern const struct Tables HullTable[11][6];

extern const char AMMO[9][4];
extern const char HDT[9][10];
extern const char HDTrake[9][10];
extern const char QUAL[9][5];
extern const char MT[9][3];

extern const char *const countryname[];
extern const char *const classname[];
extern const char *const directionname[];
extern const char *const qualname[];
extern const char loadname[];

extern const char rangeofshot[];

extern const char dr[], dc[];

extern int winddir;
extern int windspeed;
extern int turn;
extern int game;
extern int alive;
extern int people;
extern char hasdriver;

/* assorted.c */
void table(int, int, int, struct ship *, struct ship *, int);
void Cleansnag(struct ship *, struct ship *, int, int);

/* dr_1.c */
void unfoul(void);
void boardcomp(void);
int fightitout(struct ship *, struct ship *, int);
void resolve(void);
void compcombat(void);
int next(void);

/* dr_2.c */
void thinkofgrapples(void);
void checkup(void);
void prizecheck(void);
int str_end(const char *);
void closeon(struct ship *, struct ship *, char[], size_t, int, int, int);
int score(char[], size_t, struct ship *, struct ship *, int);
void move_ship(const char *, struct ship *, unsigned char *, short *, short *, char *);
void try(char[], size_t, char [], size_t, int, int, int, int, int, struct ship *,
    struct ship *, int *, int);
void rmend(char *);

/* dr_3.c */
void moveall(void);
int stillmoving(int);
int is_isolated(struct ship *);
int push(struct ship *, struct ship *);
void step(int, struct ship *, char *);
void sendbp(struct ship *, struct ship *, int, int);
int is_toughmelee(struct ship *, struct ship *, int, int);
void reload(void);
void checksails(void);

/* dr_4.c */
void ungrap(struct ship *, struct ship *);
void grap(struct ship *, struct ship *);

/* dr_5.c */
void subtract(struct ship *, int, int [3], struct ship *, int);
int mensent(struct ship *, struct ship *, int[3], struct ship **, int *, int);

/* dr_main.c */
int dr_main(void);

/* game.c */
int maxturns(struct ship *, char *);
int maxmove(struct ship *, int, int);

/* lo_main.c */
int lo_main(void);

/* misc.c */
int range(struct ship *, struct ship *);
struct ship *closestenemy(struct ship *, int, int);
int angle(int, int);
int gunsbear(struct ship *, struct ship *);
int portside(struct ship *, struct ship *, int);
int colours(struct ship *);
void logger(struct ship *);

/* parties.c */
int meleeing(struct ship *, struct ship *);
int boarding(struct ship *, int);
void unboard(struct ship *, struct ship *, int);

/* pl_1.c */
void child(int);
__dead void choke(int);
__dead void leave(int);

/* pl_2.c */
__dead void play(void);

/* pl_3.c */
void acceptcombat(void);
void grapungrap(void);
void unfoulplayer(void);

/* pl_4.c */
void changesail(void);
void acceptsignal(void);
void lookout(void);
const char *saywhat(struct ship *, int);
void eyeball(struct ship *);

/* pl_5.c */
void acceptmove(void);
void acceptboard(void);
void parties(int[3], struct ship *, int, int);

/* pl_6.c */
void repair(void);
int turned(void);
void loadplayer(void);

/* pl_7.c */
void initscreen(void);
void cleanupscreen(void);
void newturn(int);
void Signal(char *, struct ship *, ...)
	 __attribute__((__format__(__printf__,1,3)));
void Msg(char *, ...)
	 __attribute__((__format__(__printf__,1,2)));
void Scroll(void);
void prompt(const char *, struct ship *);
void endprompt(int);
int sgetch(const char *, struct ship *, int);
void sgetstr(const char *, char *, int);
void draw_screen(void);
void draw_view(void);
void draw_turn(void);
void draw_stat(void);
void draw_slot(void);
void draw_board(void);
void centerview(void);
void upview(void);
void downview(void);
void leftview(void);
void rightview(void);
void adjustview(void);

/* pl_main.c */
__dead void pl_main(void);
void initialize(void);

/* sync.c */
void fmtship(char *, size_t, const char *, struct ship *);
void makesignal(struct ship *, const char *, struct ship *, ...)
	 __attribute__((__format__(__printf__,2,4)));
void makemsg(struct ship *, const char *, ...)
	 __attribute__((__format__(__printf__,2,3)));
int sync_exists(int);
int sync_open(void);
void sync_close(int);
void Write(int, struct ship *, long, long, long, long);
void Writestr(int, struct ship *, const char *);
int Sync(void);
int sync_update(int, struct ship *, const char *, long, long, long, long);
@


1.11
log
@Set as __dead a few more functions, that don't return, on games/

With precious tip, help and also OK from tb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: extern.h,v 1.10 2014/03/11 07:42:55 guenther Exp $	*/
d35 2
a36 4
#include <stdio.h>
#include <signal.h>
#include <string.h>
#include <ctype.h>
a37 2
#include <sys/types.h>
#include "machdep.h"
@


1.10
log
@lint is dead (long live the lint!)
Declare play() and pl_main() as __dead, to solve the original problem
@
text
@d1 1
a1 1
/*	$OpenBSD: extern.h,v 1.9 2013/08/29 20:22:19 naddy Exp $	*/
a370 2
void leave(int) __attribute__((__noreturn__));
void choke(int) __attribute__((__noreturn__));
d372 2
@


1.9
log
@replace srandomdev()+random() with the arc4random*() family
tweaks and ok millert@@, ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: extern.h,v 1.8 2003/06/03 03:01:41 millert Exp $	*/
d376 1
a376 1
void play(void);
d427 1
a427 1
int pl_main(void);
@


1.8
log
@Remove the advertising clause in the UCB license which Berkeley
rescinded 22 July 1999.  Proofed by myself and Theo.
@
text
@d1 1
a1 1
/*	$OpenBSD: extern.h,v 1.7 2003/04/06 18:50:38 deraadt Exp $	*/
d64 1
a64 1
#define die()		((random() >> 3) % 6 + 1)
@


1.7
log
@2451 lines of strdup/sprintf/strcpy whacking.  mostly ok'd by pjanzen
already, but he may have later changes to make still.
@
text
@d1 1
a1 1
/*	$OpenBSD: extern.h,v 1.6 2002/02/17 19:42:21 millert Exp $	*/
d16 1
a16 5
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
@


1.6
log
@Manual cleanup of remaining userland __P use (excluding packages maintained outside the tree)
@
text
@d1 1
a1 1
/*	$OpenBSD: extern.h,v 1.5 2002/02/16 22:33:16 millert Exp $	*/
d324 2
a325 2
void closeon(struct ship *, struct ship *, char[], int, int, int);
int score(char[], struct ship *, struct ship *, int);
d327 1
a327 1
void try(char[], char [], int, int, int, int, int, struct ship *,
@


1.5
log
@abs() is defined by ANSI C -- don't use a macro for it
@
text
@d1 1
a1 1
/*	$OpenBSD: extern.h,v 1.4 2002/02/16 21:27:11 millert Exp $	*/
d327 2
a328 2
void try __P((char[], char [], int, int, int, int, int, struct ship *,
    struct ship *, int *, int));
d348 1
a348 2
int mensent __P((struct ship *, struct ship *, int[3], struct ship **, int *,
    int));
@


1.4
log
@Part one of userland __P removal.  Done with a simple regexp with some minor hand editing to make comments line up correctly.  Another pass is forthcoming that handles the cases that could not be done automatically.
@
text
@d1 1
a1 1
/*	$OpenBSD: extern.h,v 1.3 2000/01/03 23:22:41 pjanzen Exp $	*/
a69 1
#define abs(a)		((a) > 0 ? (a) : -(a))
@


1.3
log
@extern rather than linker commons; jsm@@netbsd.org
@
text
@d1 1
a1 1
/*	$OpenBSD: extern.h,v 1.2 1999/01/18 21:53:22 pjanzen Exp $	*/
d309 2
a310 2
void table __P((int, int, int, struct ship *, struct ship *, int));
void Cleansnag __P((struct ship *, struct ship *, int, int));
d313 6
a318 6
void unfoul __P((void));
void boardcomp __P((void));
int fightitout __P((struct ship *, struct ship *, int));
void resolve __P((void));
void compcombat __P((void));
int next __P((void));
d321 7
a327 7
void thinkofgrapples __P((void));
void checkup __P((void));
void prizecheck __P((void));
int str_end __P((const char *));
void closeon __P((struct ship *, struct ship *, char[], int, int, int));
int score __P((char[], struct ship *, struct ship *, int));
void move_ship __P((const char *, struct ship *, unsigned char *, short *, short *, char *));
d330 1
a330 1
void rmend __P((char *));
d333 9
a341 9
void moveall __P((void));
int stillmoving __P((int));
int is_isolated __P((struct ship *));
int push __P((struct ship *, struct ship *));
void step __P((int, struct ship *, char *));
void sendbp __P((struct ship *, struct ship *, int, int));
int is_toughmelee __P((struct ship *, struct ship *, int, int));
void reload __P((void));
void checksails __P((void));
d344 2
a345 2
void ungrap __P((struct ship *, struct ship *));
void grap __P((struct ship *, struct ship *));
d348 1
a348 1
void subtract __P((struct ship *, int, int [3], struct ship *, int));
d353 1
a353 1
int dr_main __P((void));
d356 2
a357 2
int maxturns __P((struct ship *, char *));
int maxmove __P((struct ship *, int, int));
d360 1
a360 1
int lo_main __P((void));
d363 7
a369 7
int range __P((struct ship *, struct ship *));
struct ship *closestenemy __P((struct ship *, int, int));
int angle __P((int, int));
int gunsbear __P((struct ship *, struct ship *));
int portside __P((struct ship *, struct ship *, int));
int colours __P((struct ship *));
void logger __P((struct ship *));
d372 3
a374 3
int meleeing __P((struct ship *, struct ship *));
int boarding __P((struct ship *, int));
void unboard __P((struct ship *, struct ship *, int));
d377 3
a379 3
void leave __P((int)) __attribute__((__noreturn__));
void choke __P((int)) __attribute__((__noreturn__));
void child __P((int));
d382 1
a382 1
void play __P((void));
d385 3
a387 3
void acceptcombat __P((void));
void grapungrap __P((void));
void unfoulplayer __P((void));
d390 5
a394 5
void changesail __P((void));
void acceptsignal __P((void));
void lookout __P((void));
const char *saywhat __P((struct ship *, int));
void eyeball __P((struct ship *));
d397 3
a399 3
void acceptmove __P((void));
void acceptboard __P((void));
void parties __P((int[3], struct ship *, int, int));
d402 3
a404 3
void repair __P((void));
int turned __P((void));
void loadplayer __P((void));
d407 4
a410 4
void initscreen __P((void));
void cleanupscreen __P((void));
void newturn __P((int));
void Signal __P((char *, struct ship *, ...))
d412 1
a412 1
void Msg __P((char *, ...))
d414 17
a430 17
void Scroll __P((void));
void prompt __P((const char *, struct ship *));
void endprompt __P((int));
int sgetch __P((const char *, struct ship *, int));
void sgetstr __P((const char *, char *, int));
void draw_screen __P((void));
void draw_view __P((void));
void draw_turn __P((void));
void draw_stat __P((void));
void draw_slot __P((void));
void draw_board __P((void));
void centerview __P((void));
void upview __P((void));
void downview __P((void));
void leftview __P((void));
void rightview __P((void));
void adjustview __P((void));
d433 2
a434 2
int pl_main __P((void));
void initialize __P((void));
d437 2
a438 2
void fmtship __P((char *, size_t, const char *, struct ship *));
void makesignal __P((struct ship *, const char *, struct ship *, ...))
d440 1
a440 1
void makemsg __P((struct ship *, const char *, ...))
d442 7
a448 7
int sync_exists __P((int));
int sync_open __P((void));
void sync_close __P((int));
void Write __P((int, struct ship *, long, long, long, long));
void Writestr __P((int, struct ship *, const char *));
int Sync __P((void));
int sync_update __P((int, struct ship *, const char *, long, long, long, long));
@


1.2
log
@Only use __attribute__ if __GNUC__ is defined
@
text
@d1 1
a1 1
/*	$OpenBSD: extern.h,v 1.1 1999/01/18 21:14:15 pjanzen Exp $	*/
d52 2
a53 2
int mode;
jmp_buf restart;
d59 4
a62 4
char debug;				/* -D */
char randomize;				/* -x, give first available ship */
char longfmt;				/* -l, print score in long format */
char nobells;				/* -b, don't ring bell before Signal */
d65 2
a66 2
gid_t gid;
gid_t egid;
d267 2
a268 2
struct scenario *cc;		/* the current scenario */
struct ship *ls;		/* &cc->ship[cc->vessels] */
d300 7
a306 7
int winddir;
int windspeed;
int turn;
int game;
int alive;
int people;
char hasdriver;
@


1.1
log
@Whoops, this should be in there too
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d46 4
@

