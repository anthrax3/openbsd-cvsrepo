head	1.32;
access;
symbols
	OPENBSD_6_1_BASE:1.32
	OPENBSD_6_0:1.31.0.2
	OPENBSD_6_0_BASE:1.31
	OPENBSD_5_9:1.29.0.2
	OPENBSD_5_9_BASE:1.29
	OPENBSD_5_8:1.26.0.6
	OPENBSD_5_8_BASE:1.26
	OPENBSD_5_7:1.26.0.2
	OPENBSD_5_7_BASE:1.26
	OPENBSD_5_6:1.25.0.22
	OPENBSD_5_6_BASE:1.25
	OPENBSD_5_5:1.25.0.20
	OPENBSD_5_5_BASE:1.25
	OPENBSD_5_4:1.25.0.16
	OPENBSD_5_4_BASE:1.25
	OPENBSD_5_3:1.25.0.14
	OPENBSD_5_3_BASE:1.25
	OPENBSD_5_2:1.25.0.12
	OPENBSD_5_2_BASE:1.25
	OPENBSD_5_1_BASE:1.25
	OPENBSD_5_1:1.25.0.10
	OPENBSD_5_0:1.25.0.8
	OPENBSD_5_0_BASE:1.25
	OPENBSD_4_9:1.25.0.6
	OPENBSD_4_9_BASE:1.25
	OPENBSD_4_8:1.25.0.4
	OPENBSD_4_8_BASE:1.25
	OPENBSD_4_7:1.25.0.2
	OPENBSD_4_7_BASE:1.25
	OPENBSD_4_6:1.22.0.26
	OPENBSD_4_6_BASE:1.22
	OPENBSD_4_5:1.22.0.22
	OPENBSD_4_5_BASE:1.22
	OPENBSD_4_4:1.22.0.20
	OPENBSD_4_4_BASE:1.22
	OPENBSD_4_3:1.22.0.18
	OPENBSD_4_3_BASE:1.22
	OPENBSD_4_2:1.22.0.16
	OPENBSD_4_2_BASE:1.22
	OPENBSD_4_1:1.22.0.14
	OPENBSD_4_1_BASE:1.22
	OPENBSD_4_0:1.22.0.12
	OPENBSD_4_0_BASE:1.22
	OPENBSD_3_9:1.22.0.10
	OPENBSD_3_9_BASE:1.22
	OPENBSD_3_8:1.22.0.8
	OPENBSD_3_8_BASE:1.22
	OPENBSD_3_7:1.22.0.6
	OPENBSD_3_7_BASE:1.22
	OPENBSD_3_6:1.22.0.4
	OPENBSD_3_6_BASE:1.22
	OPENBSD_3_5:1.22.0.2
	OPENBSD_3_5_BASE:1.22
	OPENBSD_3_4:1.20.0.2
	OPENBSD_3_4_BASE:1.20
	OPENBSD_3_3:1.17.0.6
	OPENBSD_3_3_BASE:1.17
	OPENBSD_3_2:1.17.0.4
	OPENBSD_3_2_BASE:1.17
	OPENBSD_3_1:1.17.0.2
	OPENBSD_3_1_BASE:1.17
	OPENBSD_3_0:1.16.0.2
	OPENBSD_3_0_BASE:1.16
	OPENBSD_2_9_BASE:1.14
	OPENBSD_2_9:1.14.0.2
	OPENBSD_2_8:1.13.0.2
	OPENBSD_2_8_BASE:1.13
	OPENBSD_2_7:1.12.0.4
	OPENBSD_2_7_BASE:1.12
	OPENBSD_2_6:1.12.0.2
	OPENBSD_2_6_BASE:1.12
	OPENBSD_2_5:1.10.0.2
	OPENBSD_2_5_BASE:1.10
	OPENBSD_2_4:1.8.0.8
	OPENBSD_2_4_BASE:1.8
	OPENBSD_2_3:1.8.0.6
	OPENBSD_2_3_BASE:1.8
	OPENBSD_2_2:1.8.0.4
	OPENBSD_2_2_BASE:1.8
	OPENBSD_2_1:1.8.0.2
	OPENBSD_2_1_BASE:1.8
	OPENBSD_2_0:1.7.0.2
	OPENBSD_2_0_BASE:1.7
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.32
date	2016.08.01.20.30.25;	author martijn;	state Exp;
branches;
next	1.31;
commitid	iRcKLRuM56PDhxPq;

1.31
date	2016.05.08.17.09.42;	author schwarze;	state Exp;
branches;
next	1.30;
commitid	WEjJ9OIyjElPOJEF;

1.30
date	2016.05.08.16.19.35;	author martijn;	state Exp;
branches;
next	1.29;
commitid	peeDMwnJFZ4vhePB;

1.29
date	2015.11.05.22.20.11;	author benno;	state Exp;
branches;
next	1.28;
commitid	j1r9yJwQqEqQV7lo;

1.28
date	2015.09.29.03.19.24;	author guenther;	state Exp;
branches;
next	1.27;
commitid	yKdJafwKaYfM4gkS;

1.27
date	2015.08.20.22.32.42;	author deraadt;	state Exp;
branches;
next	1.26;
commitid	0Dp7Dy9FuNZesYo2;

1.26
date	2015.01.16.06.40.14;	author deraadt;	state Exp;
branches;
next	1.25;
commitid	Uu5nFG3wCl0LACBb;

1.25
date	2009.10.27.23.59.49;	author deraadt;	state Exp;
branches;
next	1.24;

1.24
date	2009.08.03.20.30.03;	author bluhm;	state Exp;
branches;
next	1.23;

1.23
date	2009.08.03.20.22.39;	author bluhm;	state Exp;
branches;
next	1.22;

1.22
date	2004.02.21.00.45.34;	author tom;	state Exp;
branches;
next	1.21;

1.21
date	2004.02.20.12.49.34;	author henning;	state Exp;
branches;
next	1.20;

1.20
date	2003.07.02.00.21.17;	author avsm;	state Exp;
branches;
next	1.19;

1.19
date	2003.06.25.21.09.53;	author deraadt;	state Exp;
branches;
next	1.18;

1.18
date	2003.06.03.02.56.22;	author millert;	state Exp;
branches;
next	1.17;

1.17
date	2001.11.05.13.11.07;	author deraadt;	state Exp;
branches;
next	1.16;

1.16
date	2001.09.06.14.21.47;	author deraadt;	state Exp;
branches;
next	1.15;

1.15
date	2001.09.04.23.25.56;	author millert;	state Exp;
branches;
next	1.14;

1.14
date	2001.02.13.09.16.04;	author deraadt;	state Exp;
branches;
next	1.13;

1.13
date	2000.09.07.17.23.26;	author deraadt;	state Exp;
branches;
next	1.12;

1.12
date	99.05.30.08.21.15;	author deraadt;	state Exp;
branches;
next	1.11;

1.11
date	99.05.24.22.35.49;	author d;	state Exp;
branches;
next	1.10;

1.10
date	98.12.16.01.20.14;	author deraadt;	state Exp;
branches;
next	1.9;

1.9
date	98.11.19.03.09.16;	author form;	state Exp;
branches;
next	1.8;

1.8
date	97.01.15.23.43.36;	author millert;	state Exp;
branches;
next	1.7;

1.7
date	96.09.16.02.26.18;	author deraadt;	state Exp;
branches;
next	1.6;

1.6
date	96.09.02.09.07.35;	author deraadt;	state Exp;
branches;
next	1.5;

1.5
date	96.08.26.10.28.22;	author deraadt;	state Exp;
branches;
next	1.4;

1.4
date	96.08.26.10.21.48;	author deraadt;	state Exp;
branches;
next	1.3;

1.3
date	96.08.06.19.25.35;	author deraadt;	state Exp;
branches;
next	1.2;

1.2
date	96.06.26.05.42.48;	author deraadt;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.46.51;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.46.51;	author deraadt;	state Exp;
branches;
next	;


desc
@@


1.32
log
@Allow a bel character in wall. This was missed when migrating away from
vis(3). This brings the allowed characters on par with write(1).

Noticed by consus <at> gmx <dot> com
OK millert@@
@
text
@/*	$OpenBSD: wall.c,v 1.31 2016/05/08 17:09:42 schwarze Exp $	*/
/*	$NetBSD: wall.c,v 1.6 1994/11/17 07:17:58 jtc Exp $	*/

/*
 * Copyright (c) 1988, 1990, 1993
 *	The Regents of the University of California.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */

/*
 * This program is not related to David Wall, whose Stanford Ph.D. thesis
 * is entitled "Mechanisms for Broadcast and Selective Broadcast".
 */

#include <sys/queue.h>
#include <sys/stat.h>
#include <sys/time.h>
#include <sys/uio.h>

#include <ctype.h>
#include <err.h>
#include <grp.h>
#include <limits.h>
#include <paths.h>
#include <pwd.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <utmp.h>

struct wallgroup {
	gid_t	gid;
	char	*name;
	char	**mem;
	struct wallgroup *next;
} *grouplist;

struct utmptty {
	char	*tty;
	SLIST_ENTRY(utmptty) next;
};

void	makemsg(char *);
void	addgroup(struct group *, char *);
char   *ttymsg(struct iovec *, int, char *, int);
__dead	void usage(void);
static int isu8cont(unsigned char);

int nobanner;
int mbufsize;
char *mbuf;

/* ARGSUSED */
int
main(int argc, char **argv)
{
	FILE *fp;
	int ch, ingroup;
	struct iovec iov;
	struct utmp utmp;
	char *p, **mem;
	char line[sizeof(utmp.ut_line) + 1];
	char username[sizeof(utmp.ut_name) + 1];
	struct passwd *pw;
	struct group *grp;
	struct wallgroup *g;
	struct utmptty *un;
	SLIST_HEAD(,utmptty) utmphead;
	SLIST_INIT(&utmphead);

	while ((ch = getopt(argc, argv, "ng:")) != -1)
		switch (ch) {
		case 'n':
			/* undoc option for shutdown: suppress banner */
			pw = getpwnam("nobody");
			if (geteuid() == 0 || (pw && getuid() == pw->pw_uid))
				nobanner = 1;
			break;
		case 'g':
			if ((grp = getgrnam(optarg)) == NULL)
				errx(1, "unknown group `%s'", optarg);
			addgroup(grp, optarg);
			break;
		default:
			usage();
		}
	argc -= optind;
	argv += optind;
	if (argc > 1)
		usage();

	makemsg(*argv);

	if (pledge("stdio rpath wpath getpw proc", NULL) == -1)
		err(1, "pledge");

	if (!(fp = fopen(_PATH_UTMP, "r")))
		err(1, "cannot read %s", _PATH_UTMP);
	iov.iov_base = mbuf;
	iov.iov_len = mbufsize;

	while (fread(&utmp, sizeof(utmp), 1, fp) == 1) {
		if (!utmp.ut_name[0])
			continue;
		if (grouplist) {
			ingroup = 0;
			strncpy(username, utmp.ut_name, sizeof(utmp.ut_name));
			username[sizeof(utmp.ut_name)] = '\0';
			pw = getpwnam(username);
			if (!pw)
				continue;
			for (g = grouplist; g && ingroup == 0; g = g->next) {
				if (g->gid == pw->pw_gid)
					ingroup = 1;
				for (mem = g->mem; *mem && ingroup == 0; mem++)
					if (strcmp(username, *mem) == 0)
						ingroup = 1;
			}
			if (ingroup == 0)
				continue;
		}
		strncpy(line, utmp.ut_line, sizeof(utmp.ut_line));
		line[sizeof(utmp.ut_line)] = '\0';
		un = malloc(sizeof(struct utmptty));
		if (un == NULL)
			err(1, "malloc");
		un->tty = strndup(line, sizeof(utmp.ut_line));
		if (un->tty == NULL)
			err(1, "strndup");
		SLIST_INSERT_HEAD(&utmphead, un, next);
	}
	fclose(fp);

	if (pledge("stdio rpath wpath proc", NULL) == -1)
		err(1, "pledge");

	SLIST_FOREACH(un, &utmphead, next) {
		if ((p = ttymsg(&iov, 1, un->tty, 60*5)) != NULL)
			warnx("%s", p);
	}

	exit(0);
}

void
makemsg(char *fname)
{
	int cnt;
	struct tm *lt;
	struct passwd *pw;
	struct stat sbuf;
	time_t now;
	FILE *fp;
	int fd;
	char *p, *whom, hostname[HOST_NAME_MAX+1], lbuf[100], tmpname[PATH_MAX];
	char *ttynam;
	unsigned char ch;

	snprintf(tmpname, sizeof(tmpname), "%s/wall.XXXXXXXXXX", _PATH_TMP);
	if ((fd = mkstemp(tmpname)) >= 0) {
		(void)unlink(tmpname);
		fp = fdopen(fd, "r+");
	}
	if (fd == -1 || fp == NULL)
		err(1, "can't open temporary file");

	if (!nobanner) {
		if (!(whom = getlogin()))
			whom = (pw = getpwuid(getuid())) ? pw->pw_name : "???";
		(void)gethostname(hostname, sizeof(hostname));
		(void)time(&now);
		lt = localtime(&now);
		if ((ttynam = ttyname(STDERR_FILENO)) == NULL)
			ttynam = "(not a tty)";

		/*
		 * all this stuff is to blank out a square for the message;
		 * we wrap message lines at column 79, not 80, because some
		 * terminals wrap after 79, some do not, and we can't tell.
		 * Which means that we may leave a non-blank character
		 * in column 80, but that can't be helped.
		 */
		(void)fprintf(fp, "\r%79s\r\n", " ");
		(void)snprintf(lbuf, sizeof lbuf,
		    "Broadcast Message from %s@@%s", whom, hostname);
		(void)fprintf(fp, "%-79.79s\007\007\r\n", lbuf);
		(void)snprintf(lbuf, sizeof lbuf,
		    "        (%s) at %d:%02d ...", ttynam,
		    lt->tm_hour, lt->tm_min);
		(void)fprintf(fp, "%-79.79s\r\n", lbuf);
	}
	(void)fprintf(fp, "%79s\r\n", " ");

	if (fname) {
		gid_t egid = getegid();

		setegid(getgid());
		if (freopen(fname, "r", stdin) == NULL)
			err(1, "can't read %s", fname);
		setegid(egid);
	}
	while (fgets(lbuf, sizeof(lbuf), stdin))
		for (cnt = 0, p = lbuf; (ch = *p) != '\0'; ++p, ++cnt) {
			if (cnt == 79 || ch == '\n') {
				for (; cnt < 79; ++cnt)
					putc(' ', fp);
				putc('\r', fp);
				putc('\n', fp);
				cnt = -1;
			} else if (!isu8cont(ch))
				putc(isprint(ch) || isspace(ch) || ch == '\a' ?
				    ch : '?', fp);
		}
	(void)fprintf(fp, "%79s\r\n", " ");
	rewind(fp);

	if (fstat(fd, &sbuf))
		err(1, "can't stat temporary file");
	mbufsize = sbuf.st_size;
	mbuf = malloc((u_int)mbufsize);
	if (mbuf == NULL)
		err(1, NULL);
	if (fread(mbuf, sizeof(*mbuf), mbufsize, fp) != mbufsize)
		err(1, "can't read temporary file");
	(void)close(fd);
}

void
addgroup(struct group *grp, char *name)
{
	int i;
	struct wallgroup *g;

	for (i = 0; grp->gr_mem[i]; i++)
		;

	g = malloc(sizeof *g);
	if (g == NULL)
		err(1, NULL);
	g->gid = grp->gr_gid;
	g->name = name;
	g->mem = calloc(i + 1, sizeof(char *));
	if (g->mem == NULL)
		err(1, NULL);
	for (i = 0; grp->gr_mem[i] != NULL; i++) {
		g->mem[i] = strdup(grp->gr_mem[i]);
		if (g->mem[i] == NULL)
			err(1, NULL);
	}
	g->mem[i] = NULL;
	g->next = grouplist;
	grouplist = g;
}

void
usage(void)
{
	extern char *__progname;

	(void)fprintf(stderr, "usage: %s [-g group] [file]\n", __progname);
	exit(1);
}

static int
isu8cont(unsigned char c)
{
	return (c & (0x80 | 0x40)) == 0x80;
}
@


1.31
log
@The header <vis.h> is no longer needed; ok martijn@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: wall.c,v 1.30 2016/05/08 16:19:35 martijn Exp $	*/
d235 1
a235 1
				putc(isprint(ch) || isspace(ch) ?
@


1.30
log
@Enable UTF-8 detection in wall(1). This deliberately ignores UTF-8 characters
and replaces them with a single question mark. Similar to write(1).

code OK and tweaks schwarze@@
man page adjustment by schwarze@@ and OK jmc@@
@
text
@d1 1
a1 1
/*	$OpenBSD: wall.c,v 1.29 2015/11/05 22:20:11 benno Exp $	*/
a53 1
#include <vis.h>
@


1.29
log
@pledge wall(1)
based on an idea from deraadt@@,
tested on YP by miod, ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: wall.c,v 1.28 2015/09/29 03:19:24 guenther Exp $	*/
d43 4
a48 1
#include <grp.h>
a52 1
#include <limits.h>
a54 1
#include <err.h>
d72 1
d173 1
a173 1
	int ch, cnt;
a180 1
	char tmpbuf[5];
d182 1
d229 2
a230 3
			vis(tmpbuf, ch, VIS_SAFE|VIS_NOSLASH, p[1]);
			if (cnt == 79+1-strlen(tmpbuf) || ch == '\n') {
				for (; cnt < 79+1-strlen(tmpbuf); ++cnt)
d235 3
a237 7
			}
			if (ch != '\n') {
				int xx;

				for (xx = 0; tmpbuf[xx]; xx++)
					putc(tmpbuf[xx], fp);
			}
d287 6
@


1.28
log
@Delete the final, inscrutable NOSTRICT and VARARGS lint comments

ok millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: wall.c,v 1.27 2015/08/20 22:32:42 deraadt Exp $	*/
d38 1
d62 5
d90 3
d117 3
d124 1
d147 15
a161 1
		if ((p = ttymsg(&iov, 1, line, 60*5)) != NULL)
d164 1
@


1.27
log
@Do not cast result of malloc/calloc/realloc* if stdlib.h is in scope
ok krw millert
@
text
@d1 1
a1 1
/*	$OpenBSD: wall.c,v 1.26 2015/01/16 06:40:14 deraadt Exp $	*/
a111 1
	/* NOSTRICT */
@


1.26
log
@Replace <sys/param.h> with <limits.h> and other less dirty headers where
possible.  Annotate <sys/param.h> lines with their current reasons.  Switch
to PATH_MAX, NGROUPS_MAX, HOST_NAME_MAX+1, LOGIN_NAME_MAX, etc.  Change
MIN() and MAX() to local definitions of MINIMUM() and MAXIMUM() where
sensible to avoid pulling in the pollution.  These are the files confirmed
through binary verification.
ok guenther, millert, doug (helped with the verification protocol)
@
text
@d1 1
a1 1
/*	$OpenBSD: wall.c,v 1.25 2009/10/27 23:59:49 deraadt Exp $	*/
d238 1
a238 1
	g = (struct wallgroup *)malloc(sizeof *g);
d243 1
a243 1
	g->mem = (char **)calloc(i + 1, sizeof(char *));
@


1.25
log
@rcsid[] and sccsid[] and copyright[] are essentially unmaintained (and
unmaintainable).  these days, people use source.  these id's do not provide
any benefit, and do hurt the small install media
(the 33,000 line diff is essentially mechanical)
ok with the idea millert, ok dms
@
text
@d1 1
a1 1
/*	$OpenBSD: wall.c,v 1.24 2009/08/03 20:30:03 bluhm Exp $	*/
a37 1
#include <sys/param.h>
d49 1
d151 1
a151 1
	char *p, *whom, hostname[MAXHOSTNAMELEN], lbuf[100], tmpname[MAXPATHLEN];
@


1.24
log
@It is sufficient to call getgrnam(3) once.  Remove the first call.
ok millert
@
text
@d1 1
a1 1
/*	$OpenBSD: wall.c,v 1.23 2009/08/03 20:22:39 bluhm Exp $	*/
a31 13

#ifndef lint
static const char copyright[] =
"@@(#) Copyright (c) 1988, 1990, 1993\n\
	The Regents of the University of California.  All rights reserved.\n";
#endif /* not lint */

#ifndef lint
#if 0
static const char sccsid[] = "@@(#)wall.c	8.2 (Berkeley) 11/16/93";
#endif
static const char rcsid[] = "$OpenBSD: wall.c,v 1.23 2009/08/03 20:22:39 bluhm Exp $";
#endif /* not lint */
@


1.23
log
@In addgroup() malloc(3) does not allocate enough memory as it only
counts the number of elements but not their size.  This can crash
"wall -g group" if many users are in the group.
ok millert
@
text
@d1 1
a1 1
/*	$OpenBSD: wall.c,v 1.22 2004/02/21 00:45:34 tom Exp $	*/
d43 1
a43 1
static const char rcsid[] = "$OpenBSD: wall.c,v 1.22 2004/02/21 00:45:34 tom Exp $";
a106 1
			grp = getgrnam(optarg);
@


1.22
log
@Correctness is also not using err(1, "out of memory") if malloc()
fails (per err(3)).  Ditto for strdup().

ok henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: wall.c,v 1.21 2004/02/20 12:49:34 henning Exp $	*/
d43 1
a43 1
static const char rcsid[] = "$OpenBSD: wall.c,v 1.21 2004/02/20 12:49:34 henning Exp $";
d257 1
a257 1
	g->mem = (char **)malloc(i + 1);
@


1.21
log
@correctness is err vs. errx use
From: Pedro Martelletto <pbastos@@rdc.puc-rio.br>
@
text
@d1 1
a1 1
/*	$OpenBSD: wall.c,v 1.20 2003/07/02 00:21:17 avsm Exp $	*/
d43 1
a43 1
static const char rcsid[] = "$OpenBSD: wall.c,v 1.20 2003/07/02 00:21:17 avsm Exp $";
d235 3
a237 2
	if (!(mbuf = malloc((u_int)mbufsize)))
		err(1, "out of memory");
d254 1
a254 1
		err(1, "out of memory");
d259 1
a259 1
		err(1, "out of memory");
d263 1
a263 1
			err(1, "out of memory");
@


1.20
log
@bump randomness of mktemp to from 6 to 10 X's, as recommended by mktemp(3)
@
text
@d1 1
a1 1
/*	$OpenBSD: wall.c,v 1.19 2003/06/25 21:09:53 deraadt Exp $	*/
d43 1
a43 1
static const char rcsid[] = "$OpenBSD: wall.c,v 1.19 2003/06/25 21:09:53 deraadt Exp $";
d123 1
a123 1
		errx(1, "cannot read %s.", _PATH_UTMP);
d175 1
a175 1
		errx(1, "can't open temporary file.");
d209 1
a209 1
			errx(1, "can't read %s.", fname);
d233 1
a233 1
		errx(1, "can't stat temporary file.");
d236 1
a236 1
		errx(1, "out of memory.");
d238 1
a238 1
		errx(1, "can't read temporary file.");
d253 1
a253 1
		errx(1, "out of memory.");
d258 1
a258 1
		errx(1, "out of memory.");
d262 1
a262 1
			errx(1, "out of memory.");
@


1.19
log
@delete junk protos
@
text
@d1 1
a1 1
/*	$OpenBSD: wall.c,v 1.18 2003/06/03 02:56:22 millert Exp $	*/
d43 1
a43 1
static const char rcsid[] = "$OpenBSD: wall.c,v 1.18 2003/06/03 02:56:22 millert Exp $";
d169 1
a169 1
	snprintf(tmpname, sizeof(tmpname), "%s/wall.XXXXXX", _PATH_TMP);
@


1.18
log
@Remove the advertising clause in the UCB license which Berkeley
rescinded 22 July 1999.  Proofed by myself and Theo.
@
text
@d1 1
a1 1
/*	$OpenBSD: wall.c,v 1.17 2001/11/05 13:11:07 deraadt Exp $	*/
d43 1
a43 1
static const char rcsid[] = "$OpenBSD: wall.c,v 1.17 2001/11/05 13:11:07 deraadt Exp $";
d162 1
a162 1
	time_t now, time();
@


1.17
log
@make sure files are MAXPATHLEN sized; ianm@@cit.uws.edu.au
@
text
@d1 1
a1 1
/*	$OpenBSD: wall.c,v 1.16 2001/09/06 14:21:47 deraadt Exp $	*/
d16 1
a16 5
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
d43 1
a43 1
static const char rcsid[] = "$OpenBSD: wall.c,v 1.16 2001/09/06 14:21:47 deraadt Exp $";
@


1.16
log
@bye bye sleeper
@
text
@d1 1
a1 1
/*	$OpenBSD: wall.c,v 1.15 2001/09/04 23:25:56 millert Exp $	*/
d47 1
a47 1
static const char rcsid[] = "$OpenBSD: wall.c,v 1.15 2001/09/04 23:25:56 millert Exp $";
d169 1
a169 1
	char *p, *whom, hostname[MAXHOSTNAMELEN], lbuf[100], tmpname[64];
@


1.15
log
@Wall's -g flag has been broken since it was added.  We fix it by
looking up each group specified via -g and stashing the members
so we can compare them against users listed in utmp later on.
Inspired by a patch from Ruslan Ermilov <ru@@FreeBSD.org>.
@
text
@d1 1
a1 1
/*	$OpenBSD: wall.c,v 1.14 2001/02/13 09:16:04 deraadt Exp $	*/
d47 1
a47 1
static const char rcsid[] = "$OpenBSD: wall.c,v 1.14 2001/02/13 09:16:04 deraadt Exp $";
a82 2
#define	IGNOREUSER	"sleeper"

d132 1
a132 2
		if (!utmp.ut_name[0] ||
		    !strncmp(utmp.ut_name, IGNOREUSER, sizeof(utmp.ut_name)))
@


1.14
log
@fat utmp fix; ianm@@cit.uws.edu.au
@
text
@d1 1
a1 1
/*	$OpenBSD: wall.c,v 1.13 2000/09/07 17:23:26 deraadt Exp $	*/
d38 1
a38 1
static char copyright[] =
d45 1
a45 1
static char sccsid[] = "@@(#)wall.c	8.2 (Berkeley) 11/16/93";
d47 1
a47 1
static char rcsid[] = "$OpenBSD: wall.c,v 1.13 2000/09/07 17:23:26 deraadt Exp $";
d72 3
a75 2
	char	*name;
	gid_t	gid;
d78 4
a81 1
void	makemsg __P((char *));
d91 1
a91 3
main(argc, argv)
	int argc;
	char **argv;
d93 2
a94 2
	extern int optind;
	int ch;
d97 1
a97 3
	FILE *fp;
	char *p, *ttymsg();
	struct passwd *pep = getpwnam("nobody");
d99 3
d108 2
a109 1
			if (geteuid() == 0 || (pep && getuid() == pep->pw_uid))
d113 4
a116 5
			g = (struct wallgroup *)malloc(sizeof *g);
			g->next = grouplist;
			g->name = optarg;
			g->gid = -1;
			grouplist = g;
a117 1
		case '?':
d119 1
a119 3
usage:
			(void)fprintf(stderr, "usage: wall [-g group] [file]\n");
			exit(1);
d124 1
a124 9
		goto usage;

	for (g = grouplist; g; g = g->next) {
		struct group *grp;

		grp = getgrnam(g->name);
		if (grp)
			g->gid = grp->gr_gid;
	}
d133 1
a133 1
	while (fread((char *)&utmp, sizeof(utmp), 1, fp) == 1) {
d138 3
a140 7
			int ingroup = 0, ngrps, i;
			char username[MAXLOGNAME];
			struct passwd *pw;
			gid_t grps[NGROUPS_MAX];

			bzero(username, sizeof username);
			strncpy(username, utmp.ut_name, sizeof utmp.ut_name);
a143 1
			ngrps = getgroups(pw->pw_gid, grps);
a144 2
				if (g->gid == -1)
					continue;
d147 2
a148 2
				for (i = 0; i < ngrps && ingroup == 0; i++)
					if (g->gid == grps[i])
d163 1
a163 2
makemsg(fname)
	char *fname;
d165 1
a165 1
	register int ch, cnt;
d177 5
a181 1
	if ((fd = mkstemp(tmpname)) == -1 || !(fp = fdopen(fd, "r+")))
a182 1
	(void)unlink(tmpname);
d247 36
@


1.13
log
@use err*() correct, and open file with egid; fyre@@users.sourceforge.net
@
text
@d1 1
a1 1
/*	$OpenBSD: wall.c,v 1.12 1999/05/30 08:21:15 deraadt Exp $	*/
d47 1
a47 1
static char rcsid[] = "$OpenBSD: wall.c,v 1.12 1999/05/30 08:21:15 deraadt Exp $";
d147 1
a147 1
			char username[16];
@


1.12
log
@correct mkstemp() failure checking
@
text
@d1 1
a1 1
/*	$OpenBSD: wall.c,v 1.11 1999/05/24 22:35:49 d Exp $	*/
d47 1
a47 1
static char rcsid[] = "$OpenBSD: wall.c,v 1.11 1999/05/24 22:35:49 d Exp $";
d137 1
a137 1
		errx(1, "cannot read %s.\n", _PATH_UTMP);
d172 1
a172 1
			warnx("%s\n", p);
d194 1
a194 1
		errx(1, "can't open temporary file.\n");
d224 8
a231 2
	if (fname && !(freopen(fname, "r", stdin)))
		errx(1, "can't read %s.\n", fname);
d253 1
a253 1
		errx(1, "can't stat temporary file.\n");
d256 1
a256 1
		errx(1, "out of memory.\n");
d258 1
a258 1
		errx(1, "can't read temporary file.\n");
@


1.11
log
@show '(not a tty)' instead of '(null)' when wall is run with stderr not a tty. (e.g. when run from cron)
@
text
@d1 1
a1 1
/*	$OpenBSD: wall.c,v 1.10 1998/12/16 01:20:14 deraadt Exp $	*/
d47 1
a47 1
static char rcsid[] = "$OpenBSD: wall.c,v 1.10 1998/12/16 01:20:14 deraadt Exp $";
d193 1
a193 1
	if (!(fd = mkstemp(tmpname)) || !(fp = fdopen(fd, "r+")))
@


1.10
log
@snprintf; dillon
@
text
@d1 1
a1 1
/*	$OpenBSD: wall.c,v 1.9 1998/11/19 03:09:16 form Exp $	*/
d47 1
a47 1
static char rcsid[] = "$OpenBSD: wall.c,v 1.9 1998/11/19 03:09:16 form Exp $";
d190 1
d203 2
d218 1
a218 1
		    "        (%s) at %d:%02d ...", ttyname(2),
@


1.9
log
@fprintf(stderr, "wall: ..."); exit(1) -> errx(1, "...")
@
text
@d1 1
a1 1
/*	$OpenBSD: wall.c,v 1.8 1997/01/15 23:43:36 millert Exp $	*/
d47 1
a47 1
static char rcsid[] = "$OpenBSD: wall.c,v 1.8 1997/01/15 23:43:36 millert Exp $";
d188 1
a188 1
	char *p, *whom, hostname[MAXHOSTNAMELEN], lbuf[100], tmpname[15];
d191 1
a191 2
	(void)strcpy(tmpname, _PATH_TMP);
	(void)strcat(tmpname, "wall.XXXXXX");
@


1.8
log
@getopt(3) returns -1 when out of args, not EOF, whee!
@
text
@d1 1
a1 1
/*	$OpenBSD: wall.c,v 1.7 1996/09/16 02:26:18 deraadt Exp $	*/
d47 1
a47 1
static char rcsid[] = "$OpenBSD: wall.c,v 1.7 1996/09/16 02:26:18 deraadt Exp $";
d69 1
d136 2
a137 4
	if (!(fp = fopen(_PATH_UTMP, "r"))) {
		(void)fprintf(stderr, "wall: cannot read %s.\n", _PATH_UTMP);
		exit(1);
	}
d172 1
a172 1
			(void)fprintf(stderr, "wall: %s\n", p);
d193 2
a194 4
	if (!(fd = mkstemp(tmpname)) || !(fp = fdopen(fd, "r+"))) {
		(void)fprintf(stderr, "wall: can't open temporary file.\n");
		exit(1);
	}
d222 2
a223 4
	if (fname && !(freopen(fname, "r", stdin))) {
		(void)fprintf(stderr, "wall: can't read %s.\n", fname);
		exit(1);
	}
d244 2
a245 4
	if (fstat(fd, &sbuf)) {
		(void)fprintf(stderr, "wall: can't stat temporary file.\n");
		exit(1);
	}
d247 4
a250 8
	if (!(mbuf = malloc((u_int)mbufsize))) {
		(void)fprintf(stderr, "wall: out of memory.\n");
		exit(1);
	}
	if (fread(mbuf, sizeof(*mbuf), mbufsize, fp) != mbufsize) {
		(void)fprintf(stderr, "wall: can't read temporary file.\n");
		exit(1);
	}
@


1.7
log
@_PATH_TMP -> _PATH_TMPFILE; avoid /tmp//fooXXXX where possible too
@
text
@d1 1
a1 1
/*	$OpenBSD: wall.c,v 1.6 1996/09/02 09:07:35 deraadt Exp $	*/
d47 1
a47 1
static char rcsid[] = "$OpenBSD: wall.c,v 1.6 1996/09/02 09:07:35 deraadt Exp $";
d100 1
a100 1
	while ((ch = getopt(argc, argv, "ng:")) != EOF)
@


1.6
log
@add -g group delivery option
@
text
@d1 1
a1 1
/*	$OpenBSD: wall.c,v 1.5 1996/08/26 10:28:22 deraadt Exp $	*/
d47 1
a47 1
static char rcsid[] = "$OpenBSD: wall.c,v 1.5 1996/08/26 10:28:22 deraadt Exp $";
d193 1
a193 1
	(void)strcat(tmpname, "/wall.XXXXXX");
@


1.5
log
@VIS_NOSLASH
@
text
@d1 1
a1 1
/*	$OpenBSD: wall.c,v 1.4 1996/08/26 10:21:48 deraadt Exp $	*/
d47 1
a47 1
static char rcsid[] = "$OpenBSD: wall.c,v 1.4 1996/08/26 10:21:48 deraadt Exp $";
d62 1
d70 6
d98 1
d100 1
a100 1
	while ((ch = getopt(argc, argv, "n")) != EOF)
d107 7
d117 1
a117 1
			(void)fprintf(stderr, "usage: wall [file]\n");
d125 8
d146 24
@


1.4
log
@vis this baby
@
text
@d1 1
a1 1
/*	$OpenBSD: wall.c,v 1.3 1996/08/06 19:25:35 deraadt Exp $	*/
d47 1
a47 1
static char rcsid[] = "$OpenBSD: wall.c,v 1.3 1996/08/06 19:25:35 deraadt Exp $";
d184 1
a184 1
			vis(tmpbuf, ch, VIS_SAFE, p[1]);
@


1.3
log
@avoid buf oflow
@
text
@d1 1
a1 1
/*	$OpenBSD: wall.c,v 1.2 1996/06/26 05:42:48 deraadt Exp $	*/
d47 1
a47 1
static char rcsid[] = "$OpenBSD: wall.c,v 1.2 1996/06/26 05:42:48 deraadt Exp $";
d67 1
d143 1
d184 3
a186 2
			if (cnt == 79 || ch == '\n') {
				for (; cnt < 79; ++cnt)
d192 6
a197 2
			if (ch != '\n')
				putc(ch, fp);
@


1.2
log
@rcsid
@
text
@d1 1
a1 1
/*	$OpenBSD: wall.c,v 1.6 1994/11/17 07:17:58 jtc Exp $	*/
d47 1
a47 1
static char rcsid[] = "$OpenBSD: wall.c,v 1.6 1994/11/17 07:17:58 jtc Exp $";
d166 2
a167 2
		(void)sprintf(lbuf, "Broadcast Message from %s@@%s",
		    whom, hostname);
d169 2
a170 1
		(void)sprintf(lbuf, "        (%s) at %d:%02d ...", ttyname(2),
@


1.1
log
@Initial revision
@
text
@d1 1
d47 1
a47 1
static char rcsid[] = "$NetBSD: wall.c,v 1.6 1994/11/17 07:17:58 jtc Exp $";
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@
