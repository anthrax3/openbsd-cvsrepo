head	1.23;
access;
symbols
	OPENBSD_6_2:1.23.0.4
	OPENBSD_6_2_BASE:1.23
	OPENBSD_6_1:1.22.0.12
	OPENBSD_6_1_BASE:1.22
	OPENBSD_6_0:1.22.0.8
	OPENBSD_6_0_BASE:1.22
	OPENBSD_5_9:1.22.0.4
	OPENBSD_5_9_BASE:1.22
	OPENBSD_5_8:1.22.0.6
	OPENBSD_5_8_BASE:1.22
	OPENBSD_5_7:1.22.0.2
	OPENBSD_5_7_BASE:1.22
	OPENBSD_5_6:1.20.0.28
	OPENBSD_5_6_BASE:1.20
	OPENBSD_5_5:1.20.0.26
	OPENBSD_5_5_BASE:1.20
	OPENBSD_5_4:1.20.0.22
	OPENBSD_5_4_BASE:1.20
	OPENBSD_5_3:1.20.0.20
	OPENBSD_5_3_BASE:1.20
	OPENBSD_5_2:1.20.0.18
	OPENBSD_5_2_BASE:1.20
	OPENBSD_5_1_BASE:1.20
	OPENBSD_5_1:1.20.0.16
	OPENBSD_5_0:1.20.0.14
	OPENBSD_5_0_BASE:1.20
	OPENBSD_4_9:1.20.0.12
	OPENBSD_4_9_BASE:1.20
	OPENBSD_4_8:1.20.0.10
	OPENBSD_4_8_BASE:1.20
	OPENBSD_4_7:1.20.0.6
	OPENBSD_4_7_BASE:1.20
	OPENBSD_4_6:1.20.0.8
	OPENBSD_4_6_BASE:1.20
	OPENBSD_4_5:1.20.0.4
	OPENBSD_4_5_BASE:1.20
	OPENBSD_4_4:1.20.0.2
	OPENBSD_4_4_BASE:1.20
	OPENBSD_4_3:1.19.0.2
	OPENBSD_4_3_BASE:1.19
	OPENBSD_4_2:1.12.0.12
	OPENBSD_4_2_BASE:1.12
	OPENBSD_4_1:1.12.0.10
	OPENBSD_4_1_BASE:1.12
	OPENBSD_4_0:1.12.0.8
	OPENBSD_4_0_BASE:1.12
	OPENBSD_3_9:1.12.0.6
	OPENBSD_3_9_BASE:1.12
	OPENBSD_3_8:1.12.0.4
	OPENBSD_3_8_BASE:1.12
	OPENBSD_3_7:1.12.0.2
	OPENBSD_3_7_BASE:1.12
	OPENBSD_3_6:1.11.0.6
	OPENBSD_3_6_BASE:1.11
	OPENBSD_3_5:1.11.0.4
	OPENBSD_3_5_BASE:1.11
	OPENBSD_3_4:1.11.0.2
	OPENBSD_3_4_BASE:1.11
	OPENBSD_3_3:1.9.0.2
	OPENBSD_3_3_BASE:1.9
	OPENBSD_3_2:1.8.0.2
	OPENBSD_3_2_BASE:1.8
	OPENBSD_3_1:1.7.0.4
	OPENBSD_3_1_BASE:1.7
	OPENBSD_3_0:1.7.0.2
	OPENBSD_3_0_BASE:1.7
	OPENBSD_2_9_BASE:1.4
	OPENBSD_2_9:1.4.0.12
	OPENBSD_2_8:1.4.0.10
	OPENBSD_2_8_BASE:1.4
	OPENBSD_2_7:1.4.0.8
	OPENBSD_2_7_BASE:1.4
	OPENBSD_2_6:1.4.0.6
	OPENBSD_2_6_BASE:1.4
	OPENBSD_2_5:1.4.0.4
	OPENBSD_2_5_BASE:1.4
	OPENBSD_2_4:1.4.0.2
	OPENBSD_2_4_BASE:1.4
	OPENBSD_2_3:1.2.0.8
	OPENBSD_2_3_BASE:1.2
	OPENBSD_2_2:1.2.0.6
	OPENBSD_2_2_BASE:1.2
	OPENBSD_2_1:1.2.0.4
	OPENBSD_2_1_BASE:1.2
	OPENBSD_2_0:1.2.0.2
	OPENBSD_2_0_BASE:1.2;
locks; strict;
comment	@ * @;


1.23
date	2017.09.10.11.30.43;	author tom;	state Exp;
branches;
next	1.22;
commitid	ZMWu4z0KCqNLf07Q;

1.22
date	2015.02.08.23.40.34;	author deraadt;	state Exp;
branches;
next	1.21;
commitid	yGZX28AeTChVE8eY;

1.21
date	2015.01.16.06.40.10;	author deraadt;	state Exp;
branches;
next	1.20;
commitid	Uu5nFG3wCl0LACBb;

1.20
date	2008.07.08.21.39.52;	author sobrado;	state Exp;
branches;
next	1.19;

1.19
date	2007.11.16.16.34.33;	author deraadt;	state Exp;
branches;
next	1.18;

1.18
date	2007.11.16.15.03.31;	author mikeb;	state Exp;
branches;
next	1.17;

1.17
date	2007.10.25.16.38.06;	author mikeb;	state Exp;
branches;
next	1.16;

1.16
date	2007.10.24.17.57.01;	author mikeb;	state Exp;
branches;
next	1.15;

1.15
date	2007.10.17.14.54.30;	author deraadt;	state Exp;
branches;
next	1.14;

1.14
date	2007.10.17.11.33.55;	author deraadt;	state Exp;
branches;
next	1.13;

1.13
date	2007.10.17.02.30.23;	author deraadt;	state Exp;
branches;
next	1.12;

1.12
date	2004.12.19.13.26.48;	author deraadt;	state Exp;
branches;
next	1.11;

1.11
date	2003.08.04.17.06.44;	author deraadt;	state Exp;
branches;
next	1.10;

1.10
date	2003.06.10.22.20.49;	author deraadt;	state Exp;
branches;
next	1.9;

1.9
date	2002.12.15.13.16.12;	author henning;	state Exp;
branches;
next	1.8;

1.8
date	2002.05.29.09.23.25;	author deraadt;	state Exp;
branches;
next	1.7;

1.7
date	2001.08.19.19.26.03;	author mickey;	state Exp;
branches;
next	1.6;

1.6
date	2001.07.18.17.17.39;	author pvalchev;	state Exp;
branches;
next	1.5;

1.5
date	2001.06.05.05.05.39;	author pvalchev;	state Exp;
branches;
next	1.4;

1.4
date	98.08.30.22.35.37;	author downsj;	state Exp;
branches;
next	1.3;

1.3
date	98.05.27.02.26.07;	author downsj;	state Exp;
branches;
next	1.2;

1.2
date	96.08.16.00.02.35;	author dm;	state Exp;
branches;
next	1.1;

1.1
date	96.08.14.22.31.48;	author dm;	state Exp;
branches;
next	;


desc
@@


1.23
log
@sysctl strings include the termingating NUL character in both in and out lengths

Prompted by Nan Xiao noticing the redundancy of bzero+termination - thanks.

ok deraadt@@
@
text
@/*	$OpenBSD: pctr.c,v 1.22 2015/02/08 23:40:34 deraadt Exp $	*/

/*
 * Copyright (c) 2007 Mike Belopuhov, Aleksey Lomovtsev
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */

/*
 * Pentium performance counter control program for OpenBSD.
 * Copyright 1996 David Mazieres <dm@@lcs.mit.edu>.
 *
 * Modification and redistribution in source and binary forms is
 * permitted provided that due credit is given to the author and the
 * OpenBSD project by leaving this copyright notice intact.
 */

#include <sys/types.h>
#include <sys/stat.h>
#include <sys/sysctl.h>
#include <sys/ioctl.h>

#include <machine/cpu.h>
#include <machine/pctr.h>
#include <machine/specialreg.h>

#include <errno.h>
#include <err.h>
#include <fcntl.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>

#include "pctrvar.h"

static int	 cpu_type;
static int	 tsc_avail;

static int	 ctr, func, masku, thold;
static int	 cflag, eflag, iflag, kflag, uflag;
static int	 Mflag, Eflag, Sflag, Iflag, Aflag;

static void	 pctr_cpu_creds(void);
static char	*pctr_fn2str(u_int32_t);
static void	 pctr_printvals(struct pctrst *);
static int	 pctr_read(struct pctrst *);
static int	 pctr_write(int, u_int32_t);
static void	 pctr_list_fnct(void);
static int	 pctr_set_cntr(void);
static void	 usage(void);

int
main(int argc, char **argv)
{
	const char *errstr;
	struct pctrst st;
	int ch = -1;
	int list_mode = 0, set_mode = 0;

	pctr_cpu_creds();

	while ((ch = getopt(argc, argv, "AcEef:IiklMm:Ss:t:u")) != -1)
		switch (ch) {
		case 'A':
			Aflag = 1;
			break;
		case 'c':
			cflag = 1;
			break;
		case 'E':
			Eflag = 1;
			break;
		case 'e':
			eflag = 1;
			break;
		case 'f':
			if (sscanf(optarg, "%x", &func) <= 0 || func < 0 ||
			    func > PCTR_MAX_FUNCT)
				errx(1, "invalid function number");
			break;
		case 'I':
			Iflag = 1;
			break;
		case 'i':
			iflag = 1;
			break;
		case 'k':
			kflag = 1;
			break;
		case 'l':
			list_mode = 1;
			break;
		case 'M':
			Mflag = 1;
			break;
		case 'm':
			if (sscanf(optarg, "%x", &masku) <= 0 || masku < 0 ||
			    masku > PCTR_MAX_UMASK)
				errx(1, "invalid unit mask number");
			break;
		case 'S':
			Sflag = 1;
			break;
		case 's':
			set_mode = 1;
			ctr = strtonum(optarg, 0, PCTR_NUM-1, &errstr);
			if (errstr)
				errx(1, "counter number is %s: %s", errstr,
				    optarg);
			break;
		case 't':
			thold = strtonum(optarg, 0, 0xff, &errstr);
			if (errstr)
				errx(1, "threshold is %s: %s", errstr, optarg);
			break;
		case 'u':
			uflag = 1;
			break;
		default:
			usage();
			/* NOTREACHED */
		}
	argc -= optind;
	argv += optind;

	if (argc)
		usage();

	if (Aflag && (Mflag || Eflag || Sflag || Iflag))
		usage();

	if (list_mode)
		pctr_list_fnct();
	else if (set_mode) {
		if (pctr_set_cntr() < 0)
			err(1, "pctr_set_cntr");
	} else {
		bzero(&st, sizeof(st));
		if (pctr_read(&st) < 0)
			err(1, "pctr_read");
		pctr_printvals(&st);
	}
	return (0);
}

static void
pctr_cpu_creds(void)
{
	int atype;
	char arch[16], vendor[64];
	int mib[2], cpu_id, cpu_feature;
	size_t len;

	/* Get the architecture */
	mib[0] = CTL_HW;
	mib[1] = HW_MACHINE;
	len = sizeof(arch);
	if (sysctl(mib, 2, arch, &len, NULL, 0) == -1)
		err(1, "HW_MACHINE");

	if (strcmp(arch, "i386") == 0)
		atype = ARCH_I386;
	else if (strcmp(arch, "amd64") == 0)
		atype = ARCH_AMD64;
	else
		errx(1, "architecture %s is not supported", arch);

	/* Get the CPU id */
	mib[0] = CTL_MACHDEP;
	mib[1] = CPU_CPUID;
	len = sizeof(cpu_id);
	if (sysctl(mib, 2, &cpu_id, &len, NULL, 0) == -1)
		err(1, "CPU_CPUID");

	/* Get the CPU features */
	mib[1] = CPU_CPUFEATURE;
	len = sizeof(cpu_feature);
	if (sysctl(mib, 2, &cpu_feature, &len, NULL, 0) == -1)
		err(1, "CPU_CPUFEATURE");

	/* Get the processor vendor */
	mib[0] = CTL_MACHDEP;
	mib[1] = CPU_CPUVENDOR;
	len = sizeof(vendor);
	if (sysctl(mib, 2, vendor, &len, NULL, 0) == -1)
		err(1, "CPU_CPUVENDOR");

	switch (atype) {
	case ARCH_I386:
		if (strcmp(vendor, "AuthenticAMD") == 0) {
			if (((cpu_id >> 8) & 15) >= 6)
				cpu_type = CPU_AMD;
			else
				cpu_type = CPU_UNDEF;	/* old AMD cpu */

		} else if (strcmp(vendor, "GenuineIntel") == 0) {
			if (((cpu_id >> 8) & 15) == 6 &&
			    ((cpu_id >> 4) & 15) > 14)
				cpu_type = CPU_CORE;
			else if (((cpu_id >> 8) & 15) >= 6)
				cpu_type = CPU_P6;
			else if (((cpu_id >> 4) & 15) > 0)
				cpu_type = CPU_P5;
			else
				cpu_type = CPU_UNDEF;	/* old Intel cpu */
		}
		if (cpu_feature & CPUID_TSC)
			tsc_avail = 1;
		break;
	case ARCH_AMD64:
		if (strcmp(vendor, "AuthenticAMD") == 0)
			cpu_type = CPU_AMD;
		else if (strcmp(vendor, "GenuineIntel") == 0)
			cpu_type = CPU_CORE;
		if (cpu_feature & CPUID_TSC)
			tsc_avail = 1;
		break;
	}
}

static __inline int
pctr_ctrfn_index(struct ctrfn *cfnp, u_int32_t func)
{
	int i;

	for (i = 0; cfnp[i].name != NULL; i++)
		if (cfnp[i].fn == func)
			return (i);
	return (-1);
}

static char *
pctr_fn2str(u_int32_t sel)
{
	static char buf[128];
	struct ctrfn *cfnp = NULL;
	char th[6], um[5], *msg;
	u_int32_t fn;
	int ind;

	bzero(buf, sizeof(buf));
	bzero(th, sizeof(th));
	bzero(um, sizeof(um));
	switch (cpu_type) {
	case CPU_P5:
		fn = sel & 0x3f;
		if ((ind = pctr_ctrfn_index(p5fn, fn)) < 0)
			msg = "unknown function";
		else
			msg = p5fn[ind].name;
		snprintf(buf, sizeof(buf), "%c%c%c %02x %s",
		    sel & P5CTR_C ? 'c' : '-',
		    sel & P5CTR_U ? 'u' : '-',
		    sel & P5CTR_K ? 'k' : '-',
		    fn, msg);
		break;
	case CPU_P6:
		cfnp = p6fn;
	case CPU_CORE:
		if (cpu_type == CPU_CORE)
			cfnp = corefn;
		fn = sel & 0xff;
		if ((ind = pctr_ctrfn_index(cfnp, fn)) < 0)
			msg = "unknown function";
		else
			msg = cfnp[ind].name;
		if (cfnp[ind].name && cfnp[ind].flags & CFL_MESI)
			snprintf(um, sizeof (um), "%c%c%c%c",
			    sel & PCTR_UM_M ? 'M' : '-',
			    sel & PCTR_UM_E ? 'E' : '-',
			    sel & PCTR_UM_S ? 'S' : '-',
			    sel & PCTR_UM_I ? 'I' : '-');
		else if (cfnp[ind].name && cfnp[ind].flags & CFL_SA)
			snprintf(um, sizeof(um), "%c",
			    sel & PCTR_UM_A ? 'A' : '-');
		if (sel >> PCTR_CM_SHIFT)
			snprintf(th, sizeof(th), "+%d",
			    sel >> PCTR_CM_SHIFT);
		snprintf(buf, sizeof(buf), "%c%c%c%c %02x %02x %s %s %s",
		    sel & PCTR_I ? 'i' : '-',
		    sel & PCTR_E ? 'e' : '-',
		    sel & PCTR_K ? 'k' : '-',
		    sel & PCTR_U ? 'u' : '-',
		    fn, (sel >> PCTR_UM_SHIFT) & 0xff, th, um, msg);
		break;
	case CPU_AMD:
		fn = sel & 0xff;
		if (sel >> PCTR_CM_SHIFT)
			snprintf(th, sizeof(th), "+%d",
			    sel >> PCTR_CM_SHIFT);
		snprintf(buf, sizeof(buf), "%c%c%c%c %02x %02x %s",
		    sel & PCTR_I ? 'i' : '-',
		    sel & PCTR_E ? 'e' : '-',
		    sel & PCTR_K ? 'k' : '-',
		    sel & PCTR_U ? 'u' : '-',
		    fn, (sel >> PCTR_UM_SHIFT) & 0xff, th);
		break;
	}
	return (buf);
}

static void
pctr_printvals(struct pctrst *st)
{
	int i, n;

	switch (cpu_type) {
	case CPU_P5:
	case CPU_P6:
	case CPU_CORE:
		n = PCTR_INTEL_NUM;
	case CPU_AMD:
		if (cpu_type == CPU_AMD)
			n = PCTR_AMD_NUM;
		for (i = 0; i < n; i++)
			printf(" ctr%d = %16llu  [%s]\n", i, st->pctr_hwc[i],
			    pctr_fn2str(st->pctr_fn[i]));
		if (tsc_avail)
			printf("  tsc = %16llu\n", st->pctr_tsc);
		break;
	}
}

static int
pctr_read(struct pctrst *st)
{
	int fd, se;

	fd = open(_PATH_PCTR, O_RDONLY);
	if (fd < 0)
		return (-1);
	if (ioctl(fd, PCIOCRD, st) < 0) {
		se = errno;
		close(fd);
		errno = se;
		return (-1);
	}
	return (close(fd));
}

static int
pctr_write(int ctr, u_int32_t val)
{
	int fd, se;

	fd = open(_PATH_PCTR, O_WRONLY);
	if (fd < 0)
		return (-1);
	if (ioctl(fd, PCIOCS0 + ctr, &val) < 0) {
		se = errno;
		close(fd);
		errno = se;
		return (-1);
	}
	return (close(fd));
}

static __inline void
pctr_printdesc(char *desc)
{
	char *p;

	for (;;) {
		while (*desc == ' ')
			desc++;
		if (strlen(desc) < 70) {
			if (*desc)
				printf("      %s\n", desc);
			return;
		}
		p = desc + 72;
		while (*--p != ' ')
			;
		while (*--p == ' ')
			;
		p++;
		printf("      %.*s\n", (int)(p-desc), desc);
		desc = p;
	}
}

static void
pctr_list_fnct(void)
{
	struct ctrfn *cfnp = NULL;

	if (cpu_type == CPU_P5)
		cfnp = p5fn;
	else if (cpu_type == CPU_P6)
		cfnp = p6fn;
	else if (cpu_type == CPU_CORE)
		cfnp = corefn;
	else if (cpu_type == CPU_AMD)
		cfnp = amdfn;
	else
		return;

	for (; cfnp->name; cfnp++) {
		printf("%02x  %s", cfnp->fn, cfnp->name);
		if (cfnp->flags & CFL_MESI)
			printf("  (MESI)");
		else if (cfnp->flags & CFL_SA)
			printf("  (A)");
		if (cfnp->flags & CFL_C0)
			printf("  (ctr0 only)");
		else if (cfnp->flags & CFL_C1)
			printf("  (ctr1 only)");
		if (cfnp->flags & CFL_UM)
			printf("  (needs unit mask)");
		printf("\n");
		if (cfnp->desc)
			pctr_printdesc(cfnp->desc);
	}
}

static int
pctr_set_cntr(void)
{
	struct ctrfn *cfnp = NULL;
	u_int32_t val = func;
	int ind = 0;

	switch (cpu_type) {
	case CPU_P5:
		if (ctr >= PCTR_INTEL_NUM)
			errx(1, "only %d counters are supported",
			    PCTR_INTEL_NUM);
		if (cflag)
			val |= P5CTR_C;
		if (kflag)
			val |= P5CTR_K;
		if (uflag)
			val |= P5CTR_U;
		if (func && (!kflag && !uflag))
			val |= P5CTR_K | P5CTR_U;
		break;
	case CPU_P6:
		cfnp = p6fn;
	case CPU_CORE:
		if (cpu_type == CPU_CORE)
			cfnp = corefn;
		if (ctr >= PCTR_INTEL_NUM)
			errx(1, "only %d counters are supported",
			    PCTR_INTEL_NUM);
		if (func && (ind = pctr_ctrfn_index(cfnp, func)) < 0)
			errx(1, "function %02x is not supported", func);
		if (func && (cfnp[ind].flags & CFL_SA))
			val |= PCTR_UM_A;
		if (func && (cfnp[ind].flags & CFL_MESI)) {
			if (Mflag)
				val |= PCTR_UM_M;
			if (Eflag)
				val |= PCTR_UM_E;
			if (Sflag)
				val |= PCTR_UM_S;
			if (Iflag)
				val |= PCTR_UM_I;
			if (!Mflag || !Eflag || !Sflag || !Iflag)
				val |= PCTR_UM_MESI;
		}
		if (func && (cfnp[ind].flags & CFL_ED))
			val |= PCTR_E;
		if (func && (cfnp[ind].flags & CFL_UM) && !masku)
			errx(1, "function %02x needs unit mask specification",
			    func);
	case CPU_AMD:
		if (cpu_type == CPU_AMD && func &&
		    ((ind = pctr_ctrfn_index(amdfn, func)) < 0))
			errx(1, "function %02x is not supported", func);
		if (ctr >= PCTR_AMD_NUM)
			errx(1, "only %d counters are supported",
			    PCTR_AMD_NUM);
		if (eflag)
			val |= PCTR_E;
		if (iflag)
			val |= PCTR_I;
		if (kflag)
			val |= PCTR_K;
		if (uflag)
			val |= PCTR_U;
		if (func && (!kflag && !uflag))
			val |= PCTR_K | PCTR_U;
		val |= masku << PCTR_UM_SHIFT;
		val |= thold << PCTR_CM_SHIFT;
		if (func)
			val |= PCTR_EN;
		break;
	}

	return (pctr_write(ctr, val));
}

static void
usage(void)
{
	extern char *__progname;
	char *usg = NULL;

	switch (cpu_type) {
	case CPU_P5:
		usg = "[-cklu] [-f funct] [-s ctr]";
		break;
	case CPU_P6:
	case CPU_CORE:
		usg = "[-AEeIiklMSu] [-f funct] [-m umask] [-s ctr] "
		    "[-t thold]";
		break;
	case CPU_AMD:
		usg = "[-eilku] [-f funct] [-m umask] [-s ctr] "
		    "[-t thold]";
		break;
	}

	fprintf(stderr, "usage: %s %s\n", __progname, usg);
	exit(1);
}
@


1.22
log
@in getopt() blocks, stop incrementing flag variable which are supposed
to just be 0/1
ok miod florian
@
text
@d1 1
a1 1
/*	$OpenBSD: pctr.c,v 1.21 2015/01/16 06:40:10 deraadt Exp $	*/
d168 1
a168 2
	len = sizeof(arch) - 1;
	bzero(arch, sizeof(arch));
a170 1
	arch[len] = '\0';
d195 1
a195 2
	len = sizeof(vendor) - 1;
	bzero(vendor, sizeof(vendor));
a197 1
	vendor[len] = '\0';
@


1.21
log
@Replace <sys/param.h> with <limits.h> and other less dirty headers where
possible.  Annotate <sys/param.h> lines with their current reasons.  Switch
to PATH_MAX, NGROUPS_MAX, HOST_NAME_MAX+1, LOGIN_NAME_MAX, etc.  Change
MIN() and MAX() to local definitions of MINIMUM() and MAXIMUM() where
sensible to avoid pulling in the pollution.  These are the files confirmed
through binary verification.
ok guenther, millert, doug (helped with the verification protocol)
@
text
@d1 1
a1 1
/*	$OpenBSD: pctr.c,v 1.20 2008/07/08 21:39:52 sobrado Exp $	*/
d76 1
a76 1
			Aflag++;
d79 1
a79 1
			cflag++;
d82 1
a82 1
			Eflag++;
d85 1
a85 1
			eflag++;
d93 1
a93 1
			Iflag++;
d96 1
a96 1
			iflag++;
d99 1
a99 1
			kflag++;
d102 1
a102 1
			list_mode++;
d105 1
a105 1
			Mflag++;
d113 1
a113 1
			Sflag++;
d116 1
a116 1
			set_mode++;
d128 1
a128 1
			uflag++;
@


1.20
log
@sort options in manual page; display a better usage.
@
text
@d1 1
a1 1
/*	$OpenBSD: pctr.c,v 1.19 2007/11/16 16:34:33 deraadt Exp $	*/
a27 1
#include <sys/param.h>
@


1.19
log
@spacing
@
text
@d1 1
a1 1
/*	$OpenBSD: pctr.c,v 1.18 2007/11/16 15:03:31 mikeb Exp $	*/
d530 1
a530 1
	fprintf(stderr, "%s: %s\n", __progname, usg);
@


1.18
log
@- Fix error handling code.
- Change some function names to conform with Core Duo names.
- Correct hadnling of the functions that need non-zero Unit Mast specification.
- Some other random cleanup.
@
text
@d1 1
a1 1
/*	$OpenBSD: pctr.c,v 1.17 2007/10/25 16:38:06 mikeb Exp $	*/
d58 2
a59 2
static int 	 pctr_read(struct pctrst *);
static int 	 pctr_write(int, u_int32_t);
@


1.17
log
@Cleanup pctr code: sort options, remove nasty return.

ok deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: pctr.c,v 1.16 2007/10/24 17:57:01 mikeb Exp $	*/
a43 1
#include <sysexits.h>
d55 1
a55 1
static int	 pctr_cpu_creds(void);
d72 1
a72 3
	if (pctr_cpu_creds())
		errx(1, "pctr is supported on i386 and amd64 "
		    "architectures only");
d74 1
a74 1
	while ((ch = getopt(argc, argv, "cef:iklm:s:t:uMESIA")) != -1)
a76 3
			if (Mflag || Eflag || Sflag || Iflag)
				errx(1, "M, E, S, I and A are mutually "
				    "exclusive");
d83 2
a84 20
		case 'I':
		case 'M':
		case 'S':
			if (Aflag)
				errx(1, "M, E, S, I and A are mutually "
				    "exclusive");
			switch (ch) {
			case 'E':
				Eflag++;
				break;
			case 'I':
				Iflag++;
				break;
			case 'M':
				Mflag++;
				break;
			case 'S':
				Sflag++;
				break;
			}
d93 3
d105 3
d113 3
d138 6
d158 1
a158 1
static int
d180 1
a180 1
		return (EX_UNAVAILABLE);	/* unsupported arch */
a234 1
	return (0);
d424 2
d442 2
a443 1
			return (EX_DATAERR);
d459 2
a460 1
			return (EX_DATAERR);
d462 2
a463 2
			return (EX_DATAERR);
		if (func && cfnp[ind].flags & CFL_SA)
d465 12
a476 11
		if (Mflag && cfnp[ind].flags & CFL_MESI)
			val |= PCTR_UM_M;
		if (Eflag && cfnp[ind].flags & CFL_MESI)
			val |= PCTR_UM_E;
		if (Sflag && cfnp[ind].flags & CFL_MESI)
			val |= PCTR_UM_S;
		if (Iflag && cfnp[ind].flags & CFL_MESI)
			val |= PCTR_UM_I;
		if (func && (cfnp[ind].flags & CFL_MESI) &&
		    (!Mflag || !Eflag || !Sflag || !Iflag))
			val |= PCTR_UM_MESI;
d479 3
d485 1
a485 1
			return (EX_DATAERR);
d487 2
a488 1
			return (EX_DATAERR);
d531 1
a531 1
	exit(EX_USAGE);
@


1.16
log
@Remove idle loop counter.

ok art deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: pctr.c,v 1.15 2007/10/17 14:54:30 deraadt Exp $	*/
d74 2
a75 2
		errx(1, "pctr is only supported on i386 and amd64 "
		    "architectures by now");
d79 8
a86 2
		case 'l':
			list_mode++;
d88 23
a110 6
		case 's':
			set_mode++;
			ctr = strtonum(optarg, 0, PCTR_NUM-1, &errstr);
			if (errstr)
				errx(1, "counter number is %s: %s", errstr,
				    optarg);
d117 9
d131 7
a142 13
		/* flags */
		case 'c':
			cflag++;
			break;
		case 'e':
			eflag++;
			break;
		case 'i':
			iflag++;
			break;
		case 'k':
			kflag++;
			break;
a145 31
		/* MESI/A flags */
		case 'M':
			if (Aflag)
				errx(1, "M, E, S, I and A are mutually "
				    "exclusive");
			Mflag++;
			break;
		case 'E':
			if (Aflag)
				errx(1, "M, E, S, I and A are mutually "
				    "exclusive");
			Eflag++;
			break;
		case 'S':
			if (Aflag)
				errx(1, "M, E, S, I and A are mutually "
				    "exclusive");
			Sflag++;
			break;
		case 'I':
			if (Aflag)
				errx(1, "M, E, S, I and A are mutually "
				    "exclusive");
			Iflag++;
			break;
		case 'A':
			if (Mflag || Eflag || Sflag || Iflag)
				errx(1, "M, E, S, I and A are mutually "
				    "exclusive");
			Aflag++;
			break;
a504 2
	default:
		return (EX_UNAVAILABLE);
d518 1
a518 1
		usg = "[-l] [-s ctr] [-cuk] [-f funct]";
d522 1
a522 1
		usg = "[-l] [-s ctr] [-eikuMESIA] [-f funct] [-m umask] "
d526 1
a526 1
		usg = "[-l] [-s ctr] [-eiku] [-f funct] [-m umask] "
@


1.15
log
@more unification between amd64 and i386 (API changes, but we think
noone else uses this acpi except the command); from Mike Belopuhov
@
text
@d1 1
a1 1
/*	$OpenBSD: pctr.c,v 1.14 2007/10/17 11:33:55 deraadt Exp $	*/
a350 1
		printf("  idl = %16llu\n", st->pctr_idl);
@


1.14
log
@- fix several switch statements regarding falling through the case statement;
- remove double break;
from Mike Belopuhov
@
text
@d1 1
a1 1
/*	$OpenBSD: pctr.c,v 1.13 2007/10/17 02:30:23 deraadt Exp $	*/
d283 3
a285 3
		    sel & PCTR_P5_C ? 'c' : '-',
		    sel & PCTR_P5_U ? 'u' : '-',
		    sel & PCTR_P5_K ? 'k' : '-',
d300 4
a303 4
			    sel & PCTR_X86_UM_M ? 'M' : '-',
			    sel & PCTR_X86_UM_E ? 'E' : '-',
			    sel & PCTR_X86_UM_S ? 'S' : '-',
			    sel & PCTR_X86_UM_I ? 'I' : '-');
d306 2
a307 2
			    sel & PCTR_X86_UM_A ? 'A' : '-');
		if (sel >> PCTR_X86_CM_SHIFT)
d309 1
a309 1
			    sel >> PCTR_X86_CM_SHIFT);
d311 5
a315 5
		    sel & PCTR_X86_I ? 'i' : '-',
		    sel & PCTR_X86_E ? 'e' : '-',
		    sel & PCTR_X86_K ? 'k' : '-',
		    sel & PCTR_X86_U ? 'u' : '-',
		    fn, (sel >> PCTR_X86_UM_SHIFT) & 0xff, th, um, msg);
d319 1
a319 1
		if (sel >> PCTR_X86_CM_SHIFT)
d321 1
a321 1
			    sel >> PCTR_X86_CM_SHIFT);
d323 5
a327 5
		    sel & PCTR_X86_I ? 'i' : '-',
		    sel & PCTR_X86_E ? 'e' : '-',
		    sel & PCTR_X86_K ? 'k' : '-',
		    sel & PCTR_X86_U ? 'u' : '-',
		    fn, (sel >> PCTR_X86_UM_SHIFT) & 0xff, th);
d458 1
a458 1
			val |= PCTR_P5_C;
d460 1
a460 1
			val |= PCTR_P5_K;
d462 1
a462 1
			val |= PCTR_P5_U;
d464 1
a464 1
			val |= PCTR_P5_K | PCTR_P5_U;
d476 1
a476 1
			val |= PCTR_X86_UM_A;
d478 1
a478 1
			val |= PCTR_X86_UM_M;
d480 1
a480 1
			val |= PCTR_X86_UM_E;
d482 1
a482 1
			val |= PCTR_X86_UM_S;
d484 1
a484 1
			val |= PCTR_X86_UM_I;
d487 1
a487 1
			val |= PCTR_X86_UM_MESI;
d489 1
a489 1
			val |= PCTR_X86_E;
d497 1
a497 1
			val |= PCTR_X86_E;
d499 1
a499 1
			val |= PCTR_X86_I;
d501 1
a501 1
			val |= PCTR_X86_K;
d503 1
a503 1
			val |= PCTR_X86_U;
d505 3
a507 3
			val |= PCTR_X86_K | PCTR_X86_U;
		val |= masku << PCTR_X86_UM_SHIFT;
		val |= thold << PCTR_X86_CM_SHIFT;
d509 1
a509 1
			val |= PCTR_X86_EN;
@


1.13
log
@replacement for the pctr codebase that can handle amd64 processors as
well (in fact, all 4 combinations of codebase and processor) written by
Mike Belopuhov and Aleksey Lomovtsev
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d291 2
a292 1
		cfnp = corefn;
a316 2

		break;
d469 2
a470 1
		cfnp = corefn;
@


1.12
log
@spacing
@
text
@d1 17
a17 1
/*	$OpenBSD: pctr.c,v 1.11 2003/08/04 17:06:44 deraadt Exp $	*/
a27 4
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
d33 1
a33 2
#include <err.h>
#include <fcntl.h>
d38 295
a332 216
#define CFL_MESI 0x1   /* Unit mask accepts MESI encoding */
#define CFL_SA   0x2   /* Unit mask accepts Self/Any bit */
#define CFL_C0   0x4   /* Counter 0 only */
#define CFL_C1   0x8   /* Counter 1 only */

/* Kernel cpuid values. */
int cpu_id, cpu_feature;
char cpu_vendor[16];

int pctr_isintel;

#define usetsc		(cpu_feature & CPUID_TSC)
#define usep5ctr	(pctr_isintel && (((cpu_id >> 8) & 15) == 5) && \
				(((cpu_id >> 4) & 15) > 0))
#define usep6ctr	(pctr_isintel && ((cpu_id >> 8) & 15) == 6)
#define cpufamily	((cpu_id >> 8) & 15)

extern char *__progname;

struct ctrfn {
	u_int fn;
	int flags;
	char *name;
	char *desc;
};

struct ctrfn p5fn[] = {
	{0x00, 0, "Data read", NULL},
	{0x01, 0, "Data write", NULL},
	{0x02, 0, "Data TLB miss", NULL},
	{0x03, 0, "Data read miss", NULL},
	{0x04, 0, "Data write miss", NULL},
	{0x05, 0, "Write (hit) to M or E state lines", NULL},
	{0x06, 0, "Data cache lines written back", NULL},
	{0x07, 0, "Data cache snoops", NULL},
	{0x08, 0, "Data cache snoop hits", NULL},
	{0x09, 0, "Memory accesses in both pipes", NULL},
	{0x0a, 0, "Bank conflicts", NULL},
	{0x0b, 0, "Misaligned data memory references", NULL},
	{0x0c, 0, "Code read", NULL},
	{0x0d, 0, "Code TLB miss", NULL},
	{0x0e, 0, "Code cache miss", NULL},
	{0x0f, 0, "Any segment register load", NULL},
	{0x12, 0, "Branches", NULL},
	{0x13, 0, "BTB hits", NULL},
	{0x14, 0, "Taken branch or BTB hit", NULL},
	{0x15, 0, "Pipeline flushes", NULL},
	{0x16, 0, "Instructions executed", NULL},
	{0x17, 0, "Instructions executed in the V-pipe", NULL},
	{0x18, 0, "Bus utilization (clocks)", NULL},
	{0x19, 0, "Pipeline stalled by write backup", NULL},
	{0x1a, 0, "Pipeline stalled by data memory read", NULL},
	{0x1b, 0, "Pipeline stalled by write to E or M line", NULL},
	{0x1c, 0, "Locked bus cycle", NULL},
	{0x1d, 0, "I/O read or write cycle", NULL},
	{0x1e, 0, "Noncacheable memory references", NULL},
	{0x1f, 0, "AGI (Address Generation Interlock)", NULL},
	{0x22, 0, "Floating-point operations", NULL},
	{0x23, 0, "Breakpoint 0 match", NULL},
	{0x24, 0, "Breakpoint 1 match", NULL},
	{0x25, 0, "Breakpoint 2 match", NULL},
	{0x26, 0, "Breakpoint 3 match", NULL},
	{0x27, 0, "Hardware interrupts", NULL},
	{0x28, 0, "Data read or data write", NULL},
	{0x29, 0, "Data read miss or data write miss", NULL},
	{0x0, 0, NULL, NULL},
};

struct ctrfn p6fn[] = {
	{0x03, 0, "LD_BLOCKS",
	 "Number of store buffer blocks."},
	{0x04, 0, "SB_DRAINS",
	 "Number of store buffer drain cycles."},
	{0x05, 0, "MISALIGN_MEM_REF",
	 "Number of misaligned data memory references."},
	{0x06, 0, "SEGMENT_REG_LOADS",
	 "Number of segment register loads."},
	{0x10, CFL_C0, "FP_COMP_OPS_EXE",
	 "Number of computational floating-point operations executed."},
	{0x11, CFL_C1, "FP_ASSIST",
	 "Number of floating-point exception cases handled by microcode."},
	{0x12, CFL_C1, "MUL",
	 "Number of multiplies."},
	{0x13, CFL_C1, "DIV",
	 "Number of divides."},
	{0x14, CFL_C0, "CYCLES_DIV_BUSY",
	 "Number of cycles during which the divider is busy."},
	{0x21, 0, "L2_ADS",
	 "Number of L2 address strobes."},
	{0x22, 0, "L2_DBUS_BUSY",
	 "Number of cycles durring which the data bus was busy."},
	{0x23, 0, "L2_DBUS_BUSY_RD",
	 "Number of cycles during which the data bus was busy transferring "
	 "data from L2 to the processor."},
	{0x24, 0, "L2_LINES_IN",
	 "Number of lines allocated in the L2."},
	{0x25, 0, "L2_M_LINES_INM",
	 "Number of modified lines allocated in the L2."},
	{0x26, 0, "L2_LINES_OUT",
	 "Number of lines removed from the L2 for any reason."},
	{0x27, 0, "L2_M_LINES_OUTM",
	 "Number of modified lines removed from the L2 for any reason."},
	{0x28, CFL_MESI, "L2_IFETCH",
	 "Number of L2 instruction fetches."},
	{0x29, CFL_MESI, "L2_LD",
	 "Number of L2 data loads."},
	{0x2a, CFL_MESI, "L2_ST",
	 "Number of L2 data stores."},
	{0x2e, CFL_MESI, "L2_RQSTS",
	 "Number of L2 requests."},
	{0x43, 0, "DATA_MEM_REFS",
	 "All memory references, both cacheable and non-cacheable."},
	{0x45, 0, "DCU_LINES_IN",
	 "Total lines allocated in the DCU."},
	{0x46, 0, "DCU_M_LINES_IN",
	 "Number of M state lines allocated in the DCU."},
	{0x47, 0, "DCU_M_LINES_OUT",
	 "Number of M state lines evicted from the DCU.  "
	 "This includes evictions via snoop HITM, intervention or replacement"},
	{0x48, 0, "DCU_MISS_OUTSTANDING",
	 "Weighted number of cycles while a DCU miss is outstanding."},
	{0x60, 0, "BUS_REQ_OUTSTANDING",
	 "Number of bus requests outstanding."},
	{0x61, 0, "BUS_BNR_DRV",
	 "Number of bus clock cycles during which the processor is "
	 "driving the BNR pin."},
	{0x62, CFL_SA, "BUS_DRDY_CLOCKS",
	 "Number of clocks during which DRDY is asserted."},
	{0x63, CFL_SA, "BUS_LOCK_CLOCKS",
	 "Number of clocks during which LOCK is asserted."},
	{0x64, 0, "BUS_DATA_RCV",
	 "Number of bus clock cycles during which the processor is "
	 "receiving data."},
	{0x65, CFL_SA, "BUS_TRAN_BRD",
	 "Number of burst read transactions."},
	{0x66, CFL_SA, "BUS_TRAN_RFO",
	 "Number of read for ownership transactions."},
	{0x67, CFL_SA, "BUS_TRANS_WB",
	 "Number of write back transactions."},
	{0x68, CFL_SA, "BUS_TRAN_IFETCH",
	 "Number of instruction fetch transactions."},
	{0x69, CFL_SA, "BUS_TRAN_INVAL",
	 "Number of invalidate transactions."},
	{0x6a, CFL_SA, "BUS_TRAN_PWR",
	 "Number of partial write transactions."},
	{0x6b, CFL_SA, "BUS_TRANS_P",
	 "Number of partial transactions."},
	{0x6c, CFL_SA, "BUS_TRANS_IO",
	 "Number of I/O transactions."},
	{0x6d, CFL_SA, "BUS_TRAN_DEF",
	 "Number of deferred transactions."},
	{0x6e, CFL_SA, "BUS_TRAN_BURST",
	 "Number of burst transactions."},
	{0x6f, CFL_SA, "BUS_TRAN_MEM",
	 "Number of memory transactions."},
	{0x70, CFL_SA, "BUS_TRAN_ANY",
	 "Number of all transactions."},
	{0x79, 0, "CPU_CLK_UNHALTED",
	 "Number of cycles during which the processor is not halted."},
	{0x7a, 0, "BUS_HIT_DRV",
	 "Number of bus clock cycles during which the processor is "
	 "driving the HIT pin."},
	{0x7b, 0, "BUS_HITM_DRV",
	 "Number of bus clock cycles during which the processor is "
	 "driving the HITM pin."},
	{0x7e, 0, "BUS_SNOOP_STALL",
	 "Number of clock cycles during which the bus is snoop stalled."},
	{0x80, 0, "IFU_IFETCH",
	 "Number of instruction fetches, both cacheable and non-cacheable."},
	{0x81, 0, "IFU_IFETCH_MISS",
	 "Number of instruction fetch misses."},
	{0x85, 0, "ITLB_MISS",
	 "Number of ITLB misses."},
	{0x86, 0, "IFU_MEM_STALL",
	 "Number of cycles that the instruction fetch pipe stage is stalled, "
	 "including cache mises, ITLB misses, ITLB faults, "
	 "and victim cache evictions"},
	{0x87, 0, "ILD_STALL",
	 "Number of cycles that the instruction length decoder is stalled"},
	{0xa2, 0, "RESOURCE_STALLS",
	 "Number of cycles during which there are resource-related stalls."},
	{0xc0, 0, "INST_RETIRED",
	 "Number of instructions retired."},
	{0xc1, CFL_C0, "FLOPS",
	 "Number of computational floating-point operations retired."},
	{0xc2, 0, "UOPS_RETIRED",
	 "Number of UOPs retired."},
	{0xc4, 0, "BR_INST_RETIRED",
	 "Number of branch instructions retired."},
	{0xc5, 0, "BR_MISS_PRED_RETIRED",
	 "Number of mispredicted branches retired."},
	{0xc6, 0, "CYCLES_INT_MASKED",
	 "Number of processor cycles for which interrupts are disabled."},
	{0xc7, 0, "CYCLES_INT_PENDING_AND_MASKED",
	 "Number of processor cycles for which interrupts are disabled "
	 "and interrupts are pending."},
	{0xc8, 0, "HW_INT_RX",
	 "Number of hardware interrupts received."},
	{0xc9, 0, "BR_TAKEN_RETIRED",
	 "Number of taken branches retired."},
	{0xca, 0, "BR_MISS_PRED_TAKEN_RET",
	 "Number of taken mispredictioned branches retired."},
	{0xd0, 0, "INST_DECODER",
	 "Number of instructions decoded."},
	{0xd2, 0, "PARTIAL_RAT_STALLS",
	 "Number of cycles or events for partial stalls."},
	{0xe0, 0, "BR_INST_DECODED",
	 "Number of branch instructions decoded."},
	{0xe2, 0, "BTB_MISSES",
	 "Number of branches that miss the BTB."},
	{0xe4, 0, "BR_BOGUS",
	 "Number of bogus branches."},
	{0xe6, 0, "BACLEARS",
	 "Number of times BACLEAR is asserted."},
	{0x0, 0, NULL, NULL},
};
d335 58
a392 1
printdesc(char *desc)
d410 1
a410 1
		printf("      %.*s\n", p - desc, desc);
a414 1
/* Print all possible counter functions */
d416 1
a416 1
list(int fam)
d418 1
a418 1
	struct ctrfn *cfnp;
d420 1
a420 1
	if (fam == 5)
d422 1
a422 1
	else if (fam == 6)
d424 7
a430 6
	else {
		fprintf(stderr, "Unknown CPU family %d\n", fam);
		exit(1);
	}
	printf("Hardware counter functions for the %s:\n\n",
	fam == 5 ? "Pentium" : "Pentium Pro");
d434 1
a434 1
			printf("/mesi");
d436 1
a436 1
			printf("/a");
d439 1
a439 1
		if (cfnp->flags & CFL_C1)
d443 1
a443 1
			printdesc(cfnp->desc);
d447 2
a448 2
static struct ctrfn *
fn2cfnp(u_int family, u_int sel)
d450 18
a467 3
	struct ctrfn *cfnp;

	if (family == 6) {
d469 44
a512 4
		sel &= 0xff;
	} else {
		cfnp = p5fn;
		sel &= 0x3f;
a513 14
	for (; cfnp->name; cfnp++)
		if (cfnp->fn == sel)
			return (cfnp);
	return (NULL);
}

static char *
fn2str(int family, u_int sel)
{
	static char buf[128];
	char um[9] = "";
	char cm[6] = "";
	struct ctrfn *cfnp;
	u_int fn;
d515 1
a515 32
	if (family == 5) {
		fn = sel & 0x3f;
		cfnp = fn2cfnp(family, fn);
		snprintf(buf, sizeof buf, "%c%c%c %02x %s",
		    sel & P5CTR_C ? 'c' : '-',
		    sel & P5CTR_U ? 'u' : '-',
		    sel & P5CTR_K ? 'k' : '-',
		    fn, cfnp ? cfnp->name : "unknown function");
	} else if (family == 6) {
		fn = sel & 0xff;
		cfnp = fn2cfnp(family, fn);
		if (cfnp && cfnp->flags & CFL_MESI)
			snprintf(um, sizeof um, "/%c%c%c%c",
			    sel & P6CTR_UM_M ? 'm' : '-',
			    sel & P6CTR_UM_E ? 'e' : '-',
			    sel & P6CTR_UM_S ? 's' : '-',
			    sel & P6CTR_UM_I ? 'i' : '-');
		else if (cfnp && cfnp->flags & CFL_SA)
			snprintf(um, sizeof um, "/%c",
			    sel & P6CTR_UM_A ? 'a' : '-');
		if (sel >> 24)
			snprintf(cm, sizeof cm, "+%d", sel >> 24);
		snprintf(buf, sizeof buf, "%c%c%c%c %02x%s%s%*s %s",
		    sel & P6CTR_I ? 'i' : '-',
		    sel & P6CTR_E ? 'e' : '-',
		    sel & P6CTR_K ? 'k' : '-',
		    sel & P6CTR_U ? 'u' : '-',
		    fn, cm, um, 7 - (strlen(cm) + strlen(um)), "",
		    cfnp ? cfnp->name : "unknown function");
	} else
		return (NULL);
	return (buf);
a517 1
/* Print status of counters */
d519 1
a519 1
readst(void)
d521 2
a522 2
	int fd, i;
	struct pctrst st;
d524 13
a536 11
	fd = open(_PATH_PCTR, O_RDONLY);
	if (fd < 0)
		err(1, _PATH_PCTR);
	if (ioctl(fd, PCIOCRD, &st) < 0)
		err(1, "PCIOCRD");
	close(fd);

	if (usep5ctr || usep6ctr) {
		for (i = 0; i < PCTR_NUM; i++)
			printf(" ctr%d = %16qd  [%s]\n", i, st.pctr_hwc[i],
			    fn2str(cpufamily, st.pctr_fn[i]));
a537 200
	printf("  tsc = %16qd\n  idl = %16qd\n", st.pctr_tsc, st.pctr_idl);
}

static void
setctr(int ctr, u_int val)
{
	int fd;

	fd = open(_PATH_PCTR, O_WRONLY);
	if (fd < 0)
		err(1, _PATH_PCTR);
	if (ioctl(fd, PCIOCS0 + ctr, &val) < 0)
		err(1, "PCIOCSn");
	close(fd);
}

static void
usage(void)
{
	fprintf(stderr,
	    "usage:\n"
	    "  %s\n"
	    "    Read the counters.\n"
	    "  %s -l [5|6]\n"
	    "    List all possible counter functions for P5/P6.\n",
	    __progname, __progname);
	if (usep5ctr)
		fprintf(stderr,
		    "  %s -s {0|1} [-[c][u][k]] function\n"
		    "    Configure counter.\n"
		    "      0/1 - counter to configure\n"
		    "        c - count cycles not events\n"
		    "        u - count events in user mode (ring 3)\n"
		    "        k - count events in kernel mode (rings 0-2)\n",
		    __progname);
	else if (usep6ctr)
		fprintf(stderr,
		    "  %s -s {0|1} [-[i][e][k][u]] "
		    "function[+cm][/{[m][e][s][i]|[a]}]\n"
		    "    Configure counter.\n"
		    "       0/1 - counter number to configure\n"
		    "         i - invert cm\n"
		    "         e - edge detect\n"
		    "         k - count events in kernel mode (rings 0-2)\n"
		    "         u - count events in user mode (ring 3)\n"
		    "        cm - # events/cycle required to bump ctr\n"
		    "      mesi - Modified/Exclusive/Shared/Invalid in cache\n"
		    "       s/a - self generated/all events\n", __progname);
	exit(1);
}

int
main(int argc, char **argv)
{
	char *cp, **ap;
	u_int ctr, fn, fl = 0;
	struct ctrfn *cfnp;
	int mib[2], ac;
	size_t len;

	/* Get the kernel cpuid return values. */
	mib[0] = CTL_MACHDEP;
	mib[1] = CPU_CPUVENDOR;
	if (sysctl(mib, 2, NULL, &len, NULL, 0) == -1)
		err(1, "sysctl CPU_CPUVENDOR");
	if (len > sizeof(cpu_vendor))		/* Shouldn't ever happen. */
		err(1, "sysctl CPU_CPUVENDOR too big");
	if (sysctl(mib, 2, cpu_vendor, &len, NULL, 0) == -1)
		err(1, "sysctl CPU_CPUVENDOR");

	mib[1] = CPU_CPUID;
	len = sizeof(cpu_id);
	if (sysctl(mib, 2, &cpu_id, &len, NULL, 0) == -1)
		err(1, "sysctl CPU_CPUID");

	mib[1] = CPU_CPUFEATURE;
	len = sizeof(cpu_feature);
	if (sysctl(mib, 2, &cpu_feature, &len, NULL, 0) == -1)
		err(1, "sysctl CPU_CPUFEATURE");

	pctr_isintel = (strcmp(cpu_vendor, "GenuineIntel") == 0);

	if (argc <= 1)
		readst();
	else if (argc == 2 && !strcmp(argv[1], "-l"))
		list(cpufamily);
	else if (argc == 3 && !strcmp(argv[1], "-l"))
		list(atoi(argv[2]));
	else if (!strcmp(argv[1], "-s") && argc >= 4) {
		ctr = atoi(argv[2]);
		if (ctr >= PCTR_NUM)
			usage();
		ap = &argv[3];
		ac = argc - 3;

		if (usep6ctr)
			fl |= P6CTR_EN;
		if (**ap == '-') {
			cp = *ap;
			if (usep6ctr) {
				while (*++cp)
					switch (*cp) {
					case 'i':
						fl |= P6CTR_I;
						break;
					case 'e':
						fl |= P6CTR_E;
						break;
					case 'k':
						fl |= P6CTR_K;
						break;
					case 'u':
						fl |= P6CTR_U;
						break;
					default:
						usage();
					}
			} else if (usep5ctr) {
				while (*++cp)
					switch (*cp) {
					case 'c':
						fl |= P5CTR_C;
						break;
					case 'k':
						fl |= P5CTR_K;
						break;
					case 'u':
						fl |= P5CTR_U;
						break;
					default:
						usage();
					}
			}
			ap++;
			ac--;
		} else {
			if (usep6ctr)
				fl |= P6CTR_U|P6CTR_K;
			else if (usep5ctr)
				fl |= P5CTR_U|P5CTR_K;
		}

		if (!ac)
			usage();

		fn = strtoul(*ap, NULL, 16);
		if ((usep6ctr && (fn & ~0xff)) || (!usep6ctr && (fn & ~0x3f)))
			usage();
		fl |= fn;
		if (usep6ctr && (cp = strchr(*ap, '+'))) {
			cp++;
			fn = strtol(cp, NULL, 0);
			if (fn & ~0xff)
				usage();
			fl |= (fn << 24);
		}
		cfnp = fn2cfnp(6, fl);
		if (usep6ctr && cfnp && (cp = strchr(*ap, '/'))) {
			if (cfnp->flags & CFL_MESI) {
				while (*++cp)
					switch (*cp) {
					case 'm':
						fl |= P6CTR_UM_M;
						break;
					case 'e':
						fl |= P6CTR_UM_E;
						break;
					case 's':
						fl |= P6CTR_UM_S;
						break;
					case 'i':
						fl |= P6CTR_UM_I;
						break;
					default:
						usage();
					}
			} else if (cfnp->flags & CFL_SA) {
				while (*++cp)
					switch (*cp) {
					case 'a':
						fl |= P6CTR_UM_A;
						break;
					default:
						usage();
					}
			} else
				usage();
		} else if (cfnp && (cfnp->flags & CFL_MESI))
			fl |= P6CTR_UM_MESI;
		ap++;
		ac--;

		if (ac)
			usage();

		if (usep6ctr && ! (fl & 0xff))
			fl = 0;
		setctr(ctr, fl);
	} else
		usage();
d539 2
a540 1
	return 0;
@


1.11
log
@protos
@
text
@d1 1
a1 1
/*	$OpenBSD: pctr.c,v 1.10 2003/06/10 22:20:49 deraadt Exp $	*/
d131 1
a131 1
	{0x29, CFL_MESI, "L2_LD", 
d164 1
a164 1
	{0x67, CFL_SA, "BUS_TRANS_WB", 
d280 1
a280 1
		exit (1);
d329 1
a329 1
		cfnp = fn2cfnp (family, fn);
d337 1
a337 1
		cfnp = fn2cfnp (family, fn);
d354 1
a354 1
		    fn, cm, um, 7 - (strlen (cm) + strlen (um)), "",
d368 1
a368 1
	fd = open (_PATH_PCTR, O_RDONLY);
d370 4
a373 4
		err (1, _PATH_PCTR);
	if (ioctl (fd, PCIOCRD, &st) < 0)
		err (1, "PCIOCRD");
	close (fd);
d378 1
a378 1
			    fn2str (cpufamily, st.pctr_fn[i]));
d388 1
a388 1
	fd = open (_PATH_PCTR, O_WRONLY);
d390 4
a393 4
		err (1, _PATH_PCTR);
	if (ioctl (fd, PCIOCS0 + ctr, &val) < 0)
		err (1, "PCIOCSn");
	close (fd);
d400 6
a405 6
	   "usage:\n"
	   "  %s\n"
	   "    Read the counters.\n"
	   "  %s -l [5|6]\n"
	   "    List all possible counter functions for P5/P6.\n",
	   __progname, __progname);
d408 7
a414 7
	     "  %s -s {0|1} [-[c][u][k]] function\n"
	     "    Configure counter.\n"
	     "      0/1 - counter to configure\n"
	     "        c - count cycles not events\n"
	     "        u - count events in user mode (ring 3)\n"
	     "        k - count events in kernel mode (rings 0-2)\n",
	     __progname);
d417 12
a428 12
	     "  %s -s {0|1} [-[i][e][k][u]] "
	     "function[+cm][/{[m][e][s][i]|[a]}]\n"
	     "    Configure counter.\n"
	     "       0/1 - counter number to configure\n"
	     "         i - invert cm\n"
	     "         e - edge detect\n"
	     "         k - count events in kernel mode (rings 0-2)\n"
	     "         u - count events in user mode (ring 3)\n"
	     "        cm - # events/cycle required to bump ctr\n"
	     "      mesi - Modified/Exclusive/Shared/Invalid in cache\n"
	     "       s/a - self generated/all events\n", __progname);
	exit (1);
d434 2
a435 5
	u_int ctr;
	char *cp;
	u_int fn, fl = 0;
	char **ap;
	int ac;
d437 1
a437 1
	int mib[2];
d463 7
a469 7
		readst ();
	else if (argc == 2 && !strcmp (argv[1], "-l"))
		list (cpufamily);
	else if (argc == 3 && !strcmp (argv[1], "-l"))
		list (atoi (argv[2]));
	else if (!strcmp (argv[1], "-s") && argc >= 4) {
		ctr = atoi (argv[2]);
d471 1
a471 1
			usage ();
d476 1
a476 1
		fl |= P6CTR_EN;
d495 1
a495 1
						usage ();
d497 1
a497 1
			} else if(usep5ctr) {
d510 1
a510 1
						usage ();
d523 1
a523 1
			usage ();
d525 1
a525 1
		fn = strtoul (*ap, NULL, 16);
d527 1
a527 1
			usage ();
d529 1
a529 1
		if (usep6ctr && (cp = strchr (*ap, '+'))) {
d531 1
a531 1
			fn = strtol (cp, NULL, 0);
d533 1
a533 1
				usage ();
d536 2
a537 2
		cfnp = fn2cfnp (6, fl);
		if (usep6ctr && cfnp && (cp = strchr (*ap, '/'))) {
d554 1
a554 1
						usage ();
d563 1
a563 1
						usage ();
d566 1
a566 1
				usage ();
d573 1
a573 1
			usage ();
d577 1
a577 1
		setctr (ctr, fl);
d579 1
a579 1
		usage ();
@


1.10
log
@mostly ansi cleanup; pval ok
@
text
@d1 1
a1 1
/*	$OpenBSD: pctr.c,v 1.9 2002/12/15 13:16:12 henning Exp $	*/
d300 1
a300 1
struct ctrfn *
@


1.9
log
@typo; torh at bogus.net
@
text
@d1 1
a1 1
/*	$OpenBSD: pctr.c,v 1.8 2002/05/29 09:23:25 deraadt Exp $	*/
d245 1
a245 1
printdesc (char *desc)
d270 1
a270 1
list (int fam)
d301 1
a301 1
fn2cfnp (u_int family, u_int sel)
d319 1
a319 1
fn2str (int family, u_int sel)
d335 1
a335 2
	}
	else if (family == 6) {
d356 1
a356 2
	}
	else
d363 1
a363 1
readst (void)
d384 1
a384 1
setctr (int ctr, u_int val)
d397 1
a397 1
usage (void)
d432 1
a432 1
main (int argc, char **argv)
d482 1
a482 1
			if (usep6ctr)
d500 1
a500 1
			else if(usep5ctr)
d515 1
d518 1
a518 2
		}
		else {
d541 1
a541 1
			if (cfnp->flags & CFL_MESI)
d559 1
a559 1
			else if (cfnp->flags & CFL_SA)
d568 1
a568 1
			else
d570 1
a570 2
		}
		else if (cfnp && (cfnp->flags & CFL_MESI))
d581 1
a581 2
	}
	else
@


1.8
log
@more snprintf
@
text
@d1 1
a1 1
/*	$OpenBSD: pctr.c,v 1.7 2001/08/19 19:26:03 mickey Exp $	*/
d89 1
a89 1
	{0x27, 0, "Hardware interupts", NULL},
@


1.7
log
@err/warn and knf
@
text
@d1 1
a1 1
/*	$OpenBSD: pctr.c,v 1.6 2001/07/18 17:17:39 pvalchev Exp $	*/
d330 1
a330 1
		sprintf(buf, "%c%c%c %02x %s",
d340 1
a340 1
			sprintf(um, "/%c%c%c%c",
d346 2
a347 1
			sprintf(um, "/%c", sel & P6CTR_UM_A ? 'a' : '-');
d349 2
a350 2
			sprintf(cm, "+%d", sel >> 24);
		sprintf(buf, "%c%c%c%c %02x%s%s%*s %s",
@


1.6
log
@-Wall cleanup
@
text
@d1 1
a1 1
/*	$OpenBSD: pctr.c,v 1.5 2001/06/05 05:05:39 pvalchev Exp $	*/
d47 4
a50 4
  u_int fn;
  int flags;
  char *name;
  char *desc;
d54 39
a92 39
  {0x00, 0, "Data read", NULL},
  {0x01, 0, "Data write", NULL},
  {0x02, 0, "Data TLB miss", NULL},
  {0x03, 0, "Data read miss", NULL},
  {0x04, 0, "Data write miss", NULL},
  {0x05, 0, "Write (hit) to M or E state lines", NULL},
  {0x06, 0, "Data cache lines written back", NULL},
  {0x07, 0, "Data cache snoops", NULL},
  {0x08, 0, "Data cache snoop hits", NULL},
  {0x09, 0, "Memory accesses in both pipes", NULL},
  {0x0a, 0, "Bank conflicts", NULL},
  {0x0b, 0, "Misaligned data memory references", NULL},
  {0x0c, 0, "Code read", NULL},
  {0x0d, 0, "Code TLB miss", NULL},
  {0x0e, 0, "Code cache miss", NULL},
  {0x0f, 0, "Any segment register load", NULL},
  {0x12, 0, "Branches", NULL},
  {0x13, 0, "BTB hits", NULL},
  {0x14, 0, "Taken branch or BTB hit", NULL},
  {0x15, 0, "Pipeline flushes", NULL},
  {0x16, 0, "Instructions executed", NULL},
  {0x17, 0, "Instructions executed in the V-pipe", NULL},
  {0x18, 0, "Bus utilization (clocks)", NULL},
  {0x19, 0, "Pipeline stalled by write backup", NULL},
  {0x1a, 0, "Pipeline stalled by data memory read", NULL},
  {0x1b, 0, "Pipeline stalled by write to E or M line", NULL},
  {0x1c, 0, "Locked bus cycle", NULL},
  {0x1d, 0, "I/O read or write cycle", NULL},
  {0x1e, 0, "Noncacheable memory references", NULL},
  {0x1f, 0, "AGI (Address Generation Interlock)", NULL},
  {0x22, 0, "Floating-point operations", NULL},
  {0x23, 0, "Breakpoint 0 match", NULL},
  {0x24, 0, "Breakpoint 1 match", NULL},
  {0x25, 0, "Breakpoint 2 match", NULL},
  {0x26, 0, "Breakpoint 3 match", NULL},
  {0x27, 0, "Hardware interupts", NULL},
  {0x28, 0, "Data read or data write", NULL},
  {0x29, 0, "Data read miss or data write miss", NULL},
  {0x0, 0, NULL, NULL},
d96 146
a241 146
  {0x03, 0, "LD_BLOCKS",
   "Number of store buffer blocks."},
  {0x04, 0, "SB_DRAINS",
   "Number of store buffer drain cycles."},
  {0x05, 0, "MISALIGN_MEM_REF",
   "Number of misaligned data memory references."},
  {0x06, 0, "SEGMENT_REG_LOADS",
   "Number of segment register loads."},
  {0x10, CFL_C0, "FP_COMP_OPS_EXE",
   "Number of computational floating-point operations executed."},
  {0x11, CFL_C1, "FP_ASSIST",
   "Number of floating-point exception cases handled by microcode."},
  {0x12, CFL_C1, "MUL",
   "Number of multiplies."},
  {0x13, CFL_C1, "DIV",
   "Number of divides."},
  {0x14, CFL_C0, "CYCLES_DIV_BUSY",
   "Number of cycles during which the divider is busy."},
  {0x21, 0, "L2_ADS",
   "Number of L2 address strobes."},
  {0x22, 0, "L2_DBUS_BUSY",
   "Number of cycles durring which the data bus was busy."},
  {0x23, 0, "L2_DBUS_BUSY_RD",
   "Number of cycles during which the data bus was busy transferring "
   "data from L2 to the processor."},
  {0x24, 0, "L2_LINES_IN",
   "Number of lines allocated in the L2."},
  {0x25, 0, "L2_M_LINES_INM",
   "Number of modified lines allocated in the L2."},
  {0x26, 0, "L2_LINES_OUT",
   "Number of lines removed from the L2 for any reason."},
  {0x27, 0, "L2_M_LINES_OUTM",
   "Number of modified lines removed from the L2 for any reason."},
  {0x28, CFL_MESI, "L2_IFETCH",
   "Number of L2 instruction fetches."},
  {0x29, CFL_MESI, "L2_LD", 
   "Number of L2 data loads."},
  {0x2a, CFL_MESI, "L2_ST",
   "Number of L2 data stores."},
  {0x2e, CFL_MESI, "L2_RQSTS",
   "Number of L2 requests."},
  {0x43, 0, "DATA_MEM_REFS",
   "All memory references, both cacheable and non-cacheable."},
  {0x45, 0, "DCU_LINES_IN",
   "Total lines allocated in the DCU."},
  {0x46, 0, "DCU_M_LINES_IN",
   "Number of M state lines allocated in the DCU."},
  {0x47, 0, "DCU_M_LINES_OUT",
   "Number of M state lines evicted from the DCU.  "
   "This includes evictions via snoop HITM, intervention or replacement"},
  {0x48, 0, "DCU_MISS_OUTSTANDING",
   "Weighted number of cycles while a DCU miss is outstanding."},
  {0x60, 0, "BUS_REQ_OUTSTANDING",
   "Number of bus requests outstanding."},
  {0x61, 0, "BUS_BNR_DRV",
   "Number of bus clock cycles during which the processor is "
   "driving the BNR pin."},
  {0x62, CFL_SA, "BUS_DRDY_CLOCKS",
   "Number of clocks during which DRDY is asserted."},
  {0x63, CFL_SA, "BUS_LOCK_CLOCKS",
   "Number of clocks during which LOCK is asserted."},
  {0x64, 0, "BUS_DATA_RCV",
   "Number of bus clock cycles during which the processor is "
   "receiving data."},
  {0x65, CFL_SA, "BUS_TRAN_BRD",
   "Number of burst read transactions."},
  {0x66, CFL_SA, "BUS_TRAN_RFO",
   "Number of read for ownership transactions."},
  {0x67, CFL_SA, "BUS_TRANS_WB", 
   "Number of write back transactions."},
  {0x68, CFL_SA, "BUS_TRAN_IFETCH",
   "Number of instruction fetch transactions."},
  {0x69, CFL_SA, "BUS_TRAN_INVAL",
   "Number of invalidate transactions."},
  {0x6a, CFL_SA, "BUS_TRAN_PWR",
   "Number of partial write transactions."},
  {0x6b, CFL_SA, "BUS_TRANS_P",
   "Number of partial transactions."},
  {0x6c, CFL_SA, "BUS_TRANS_IO",
   "Number of I/O transactions."},
  {0x6d, CFL_SA, "BUS_TRAN_DEF",
   "Number of deferred transactions."},
  {0x6e, CFL_SA, "BUS_TRAN_BURST",
   "Number of burst transactions."},
  {0x6f, CFL_SA, "BUS_TRAN_MEM",
   "Number of memory transactions."},
  {0x70, CFL_SA, "BUS_TRAN_ANY",
   "Number of all transactions."},
  {0x79, 0, "CPU_CLK_UNHALTED",
   "Number of cycles during which the processor is not halted."},
  {0x7a, 0, "BUS_HIT_DRV",
   "Number of bus clock cycles during which the processor is "
   "driving the HIT pin."},
  {0x7b, 0, "BUS_HITM_DRV",
   "Number of bus clock cycles during which the processor is "
   "driving the HITM pin."},
  {0x7e, 0, "BUS_SNOOP_STALL",
   "Number of clock cycles during which the bus is snoop stalled."},
  {0x80, 0, "IFU_IFETCH",
   "Number of instruction fetches, both cacheable and non-cacheable."},
  {0x81, 0, "IFU_IFETCH_MISS",
   "Number of instruction fetch misses."},
  {0x85, 0, "ITLB_MISS",
   "Number of ITLB misses."},
  {0x86, 0, "IFU_MEM_STALL",
   "Number of cycles that the instruction fetch pipe stage is stalled, "
   "including cache mises, ITLB misses, ITLB faults, "
   "and victim cache evictions"},
  {0x87, 0, "ILD_STALL",
   "Number of cycles that the instruction length decoder is stalled"},
  {0xa2, 0, "RESOURCE_STALLS",
   "Number of cycles during which there are resource-related stalls."},
  {0xc0, 0, "INST_RETIRED",
   "Number of instructions retired."},
  {0xc1, CFL_C0, "FLOPS",
   "Number of computational floating-point operations retired."},
  {0xc2, 0, "UOPS_RETIRED",
   "Number of UOPs retired."},
  {0xc4, 0, "BR_INST_RETIRED",
   "Number of branch instructions retired."},
  {0xc5, 0, "BR_MISS_PRED_RETIRED",
   "Number of mispredicted branches retired."},
  {0xc6, 0, "CYCLES_INT_MASKED",
   "Number of processor cycles for which interrupts are disabled."},
  {0xc7, 0, "CYCLES_INT_PENDING_AND_MASKED",
   "Number of processor cycles for which interrupts are disabled "
   "and interrupts are pending."},
  {0xc8, 0, "HW_INT_RX",
   "Number of hardware interrupts received."},
  {0xc9, 0, "BR_TAKEN_RETIRED",
   "Number of taken branches retired."},
  {0xca, 0, "BR_MISS_PRED_TAKEN_RET",
   "Number of taken mispredictioned branches retired."},
  {0xd0, 0, "INST_DECODER",
   "Number of instructions decoded."},
  {0xd2, 0, "PARTIAL_RAT_STALLS",
   "Number of cycles or events for partial stalls."},
  {0xe0, 0, "BR_INST_DECODED",
   "Number of branch instructions decoded."},
  {0xe2, 0, "BTB_MISSES",
   "Number of branches that miss the BTB."},
  {0xe4, 0, "BR_BOGUS",
   "Number of bogus branches."},
  {0xe6, 0, "BACLEARS",
   "Number of times BACLEAR is asserted."},
  {0x0, 0, NULL, NULL},
d247 1
a247 19
  char *p;

  for (;;) {
    while (*desc == ' ')
      desc++;
    if (strlen (desc) < 70) {
      if (*desc)
	printf ("      %s\n", desc);
      return;
    }
    p = desc + 72;
    while (*--p != ' ')
      ;
    while (*--p == ' ')
      ;
    p++;
    printf ("      %.*s\n", p - desc, desc);
    desc = p;
  }
d249 17
d272 1
a272 1
  struct ctrfn *cfnp;
d274 24
a297 24
  if (fam == 5)
    cfnp = p5fn;
  else if (fam == 6)
    cfnp = p6fn;
  else {
    fprintf (stderr, "Unknown CPU family %d\n", fam);
    exit (1);
  }
  printf ("Hardware counter functions for the %s:\n\n",
	  fam == 5 ? "Pentium" : "Pentium Pro");
  for (; cfnp->name; cfnp++) {
    printf ("%02x  %s", cfnp->fn, cfnp->name);
    if (cfnp->flags & CFL_MESI)
      printf ("/mesi");
    else if (cfnp->flags & CFL_SA)
      printf ("/a");
    if (cfnp->flags & CFL_C0)
      printf ("  (ctr0 only)");
    if (cfnp->flags & CFL_C1)
      printf ("  (ctr1 only)");
    printf ("\n");
    if (cfnp->desc)
      printdesc (cfnp->desc);
  }
d303 1
a303 1
  struct ctrfn *cfnp;
d305 11
a315 12
  if (family == 6) {
    cfnp = p6fn;
    sel &= 0xff;
  }
  else {
    cfnp = p5fn;
    sel &= 0x3f;
  }
  for (; cfnp->name; cfnp++)
    if (cfnp->fn == sel)
      return (cfnp);
  return (NULL);
d321 39
a359 39
  static char buf[128];
  char um[9] = "";
  char cm[6] = "";
  struct ctrfn *cfnp;
  u_int fn;

  if (family == 5) {
    fn = sel & 0x3f;
    cfnp = fn2cfnp (family, fn);
    sprintf (buf, "%c%c%c %02x %s",
	     sel & P5CTR_C ? 'c' : '-',
	     sel & P5CTR_U ? 'u' : '-',
	     sel & P5CTR_K ? 'k' : '-',
	     fn, cfnp ? cfnp->name : "unknown function");
  }
  else if (family == 6) {
    fn = sel & 0xff;
    cfnp = fn2cfnp (family, fn);
    if (cfnp && cfnp->flags & CFL_MESI)
      sprintf (um, "/%c%c%c%c",
	       sel & P6CTR_UM_M ? 'm' : '-',
	       sel & P6CTR_UM_E ? 'e' : '-',
	       sel & P6CTR_UM_S ? 's' : '-',
	       sel & P6CTR_UM_I ? 'i' : '-');
    else if (cfnp && cfnp->flags & CFL_SA)
      sprintf (um, "/%c", sel & P6CTR_UM_A ? 'a' : '-');
    if (sel >> 24)
      sprintf (cm, "+%d", sel >> 24);
    sprintf (buf, "%c%c%c%c %02x%s%s%*s %s",
	     sel & P6CTR_I ? 'i' : '-',
	     sel & P6CTR_E ? 'e' : '-',
	     sel & P6CTR_K ? 'k' : '-',
	     sel & P6CTR_U ? 'u' : '-',
	     fn, cm, um, 7 - (strlen (cm) + strlen (um)), "",
	     cfnp ? cfnp->name : "unknown function");
  }
  else
    return (NULL);
  return (buf);
d366 2
a367 2
  int fd, i;
  struct pctrst st;
d369 13
a381 17
  fd = open (_PATH_PCTR, O_RDONLY);
  if (fd < 0) {
    perror (_PATH_PCTR);
    exit (1);
  }
  if (ioctl (fd, PCIOCRD, &st) < 0) {
    perror ("PCIOCRD");
    exit (1);
  }
  close (fd);

  if (usep5ctr || usep6ctr) {
    for (i = 0; i < PCTR_NUM; i++)
      printf (" ctr%d = %16qd  [%s]\n", i, st.pctr_hwc[i],
	      fn2str (cpufamily, st.pctr_fn[i]));
  }
  printf ("  tsc = %16qd\n  idl = %16qd\n", st.pctr_tsc, st.pctr_idl);
d387 1
a387 1
  int fd;
d389 6
a394 10
  fd = open (_PATH_PCTR, O_WRONLY);
  if (fd < 0) {
    perror (_PATH_PCTR);
    exit (1);
  }
  if (ioctl (fd, PCIOCS0 + ctr, &val) < 0) {
    perror ("PCIOCSn");
    exit (1);
  }
  close (fd);
d400 1
a400 1
  fprintf (stderr,
d407 2
a408 2
  if (usep5ctr)
    fprintf (stderr,
d416 2
a417 2
  else if (usep6ctr)
    fprintf (stderr,
d429 1
a429 1
  exit (1);
a431 1

d435 151
a585 151
  u_int ctr;
  char *cp;
  u_int fn, fl = 0;
  char **ap;
  int ac;
  struct ctrfn *cfnp;
  int mib[2];
  size_t len;

  /* Get the kernel cpuid return values. */
  mib[0] = CTL_MACHDEP;
  mib[1] = CPU_CPUVENDOR;
  if (sysctl(mib, 2, NULL, &len, NULL, 0) == -1)
    err(1, "sysctl CPU_CPUVENDOR");
  if (len > sizeof(cpu_vendor))		/* Shouldn't ever happen. */
    err(1, "sysctl CPU_CPUVENDOR too big");
  if (sysctl(mib, 2, cpu_vendor, &len, NULL, 0) == -1)
    err(1, "sysctl CPU_CPUVENDOR");

  mib[1] = CPU_CPUID;
  len = sizeof(cpu_id);
  if (sysctl(mib, 2, &cpu_id, &len, NULL, 0) == -1)
    err(1, "sysctl CPU_CPUID");

  mib[1] = CPU_CPUFEATURE;
  len = sizeof(cpu_feature);
  if (sysctl(mib, 2, &cpu_feature, &len, NULL, 0) == -1)
    err(1, "sysctl CPU_CPUFEATURE");

  pctr_isintel = (strcmp(cpu_vendor, "GenuineIntel") == 0);

  if (argc <= 1)
    readst ();
  else if (argc == 2 && !strcmp (argv[1], "-l"))
    list (cpufamily);
  else if (argc == 3 && !strcmp (argv[1], "-l"))
    list (atoi (argv[2]));
  else if (!strcmp (argv[1], "-s") && argc >= 4) {
    ctr = atoi (argv[2]);
    if (ctr >= PCTR_NUM)
      usage ();
    ap = &argv[3];
    ac = argc - 3;

    if (usep6ctr)
      fl |= P6CTR_EN;
    if (**ap == '-') {
      cp = *ap;
      if (usep6ctr)
	while (*++cp)
	  switch (*cp) {
	  case 'i':
	    fl |= P6CTR_I;
	    break;
	  case 'e':
	    fl |= P6CTR_E;
	    break;
	  case 'k':
	    fl |= P6CTR_K;
	    break;
	  case 'u':
	    fl |= P6CTR_U;
	    break;
	  default:
	    usage ();
	  }
      else if(usep5ctr)
	while (*++cp)
	  switch (*cp) {
	  case 'c':
	    fl |= P5CTR_C;
	    break;
	  case 'k':
	    fl |= P5CTR_K;
	    break;
	  case 'u':
	    fl |= P5CTR_U;
	    break;
	  default:
	    usage ();
	  }
      ap++;
      ac--;
    }
    else {
      if (usep6ctr)
	fl |= P6CTR_U|P6CTR_K;
      else if (usep5ctr)
	fl |= P5CTR_U|P5CTR_K;
    }

    if (!ac)
      usage ();

    fn = strtoul (*ap, NULL, 16);
    if ((usep6ctr && (fn & ~0xff)) || (!usep6ctr && (fn & ~0x3f)))
      usage ();
    fl |= fn;
    if (usep6ctr && (cp = strchr (*ap, '+'))) {
      cp++;
      fn = strtol (cp, NULL, 0);
      if (fn & ~0xff)
	usage ();
      fl |= (fn << 24);
    }
    cfnp = fn2cfnp (6, fl);
    if (usep6ctr && cfnp && (cp = strchr (*ap, '/'))) {
      if (cfnp->flags & CFL_MESI)
	while (*++cp)
	  switch (*cp) {
	  case 'm':
	    fl |= P6CTR_UM_M;
	    break;
	  case 'e':
	    fl |= P6CTR_UM_E;
	    break;
	  case 's':
	    fl |= P6CTR_UM_S;
	    break;
	  case 'i':
	    fl |= P6CTR_UM_I;
	    break;
	  default:
	    usage ();
	  }
      else if (cfnp->flags & CFL_SA)
	while (*++cp)
	  switch (*cp) {
	  case 'a':
	    fl |= P6CTR_UM_A;
	    break;
	  default:
	    usage ();
	  }
      else
	usage ();
    }
    else if (cfnp && (cfnp->flags & CFL_MESI))
      fl |= P6CTR_UM_MESI;
    ap++;
    ac--;

    if (ac)
      usage ();

    if (usep6ctr && ! (fl & 0xff))
      fl = 0;
    setctr (ctr, fl);
  }
  else
    usage ();
d587 1
a587 1
  return 0;
@


1.5
log
@License clarification from David Mazieres, ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pctr.c,v 1.4 1998/08/30 22:35:37 downsj Exp $	*/
d15 1
a445 1
  int fd;
@


1.4
log
@Use the kernel's copy of the cpuid information.

This really ought to just be removed...
@
text
@d1 1
a1 1
/*	$OpenBSD: pctr.c,v 1.3 1998/05/27 02:26:07 downsj Exp $	*/
d9 1
a9 2
 * OpenBSD project (for instance by leaving this copyright notice
 * intact).
@


1.3
log
@compile; needs lots of work.
@
text
@d1 1
a1 1
/*	$OpenBSD: pctr.c,v 1.2 1996/08/16 00:02:35 dm Exp $	*/
d16 1
d19 1
d21 1
d25 1
a25 3

char *progname;
int cpufamily;
d32 14
a243 31
#define __cpuid()				\
({						\
  pctrval id;					\
  __asm __volatile ("pushfl\n"			\
		    "\tpopl %%eax\n"		\
		    "\tmovl %%eax,%%ecx\n"	\
		    "\txorl %1,%%eax\n"		\
		    "\tpushl %%eax\n"		\
		    "\tpopfl\n"			\
		    "\tpushfl\n"		\
		    "\tpopl %%eax\n"		\
		    "\tpushl %%ecx\n"		\
		    "\tpopfl\n"			\
		    "\tcmpl %%eax,%%ecx\n"	\
		    "\tmovl $0,%%eax\n"		\
		    "\tje 1f\n"			\
		    "\tcpuid\n"			\
		    "\ttestl %%eax,%%eax\n"	\
		    "\tje 1f\n"			\
		    "\tmovl $1,%%eax\n"		\
		    "\tcpuid\n"			\
		    "\tjmp 2f\n"		\
		    "1:\t"			\
		    "\txorl %%eax,%%eax\n"	\
		    "\txorl %%edx,%%edx\n"	\
		    "2:\t"			\
		    : "=A" (id) : "i" (PSL_ID)	\
		    : "edx", "ecx", "ebx");	\
  id;						\
})

d382 5
a386 3
  for (i = 0; i < PCTR_NUM; i++)
    printf (" ctr%d = %16qd  [%s]\n", i, st.pctr_hwc[i],
	    fn2str (cpufamily, st.pctr_fn[i]));
d416 2
a417 2
	   progname, progname);
  if (cpufamily == 5)
d425 2
a426 2
	     progname);
  else if (cpufamily == 6)
d438 1
a438 1
	     "       s/a - self generated/all events\n", progname);
a449 1
  pctrval id = __cpuid ();
d453 2
d456 19
a474 1
  cpufamily = (id >> 8) & 0xf;
d476 1
a476 4
  if (progname = strrchr (argv[0], '/'))
    progname++;
  else
    progname = argv[0];
d491 1
a491 1
    if (cpufamily == 6)
d495 1
a495 1
      if (cpufamily == 6)
d513 1
a513 1
      else
d532 1
a532 1
      if (cpufamily == 6)
d534 1
a534 1
      else
d542 1
a542 1
    if (cpufamily == 6 && (fn & ~0xff) || cpufamily != 6 && (fn & ~0x3f))
d545 1
a545 1
    if (cpufamily == 6 && (cp = strchr (*ap, '+'))) {
d553 1
a553 1
    if (cpufamily == 6 && cfnp && (cp = strchr (*ap, '/'))) {
d592 1
a592 1
    if (cpufamily == 6 && ! (fl & 0xff))
@


1.2
log
@Some mostly cosmetic bug fixes.
@
text
@d1 1
a1 1
/*	$OpenBSD: pctr.c,v 1.1 1996/08/14 22:31:48 dm Exp $	*/
d228 31
@


1.1
log
@7 consonants was just too many.  pctrctl -> pctr.
@
text
@d1 1
a1 1
/*	$OpenBSD: pctrctl.c,v 1.3 1996/08/14 22:03:17 dm Exp $	*/
d85 1
a85 1
  {0x04, 0, "MISALIGN_MEM_REF",
d130 1
a130 1
   "This includes evictions via snoop HITM, interfention or replacement"},
a366 4
  if (cpufamily == 6) {
    st.pctr_hwc[0] = rdpmc (0);
    st.pctr_hwc[1] = rdpmc (1);
  }
@
