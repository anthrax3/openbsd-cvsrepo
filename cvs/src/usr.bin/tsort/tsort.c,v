head	1.36;
access;
symbols
	OPENBSD_6_1:1.35.0.8
	OPENBSD_6_1_BASE:1.35
	OPENBSD_6_0:1.35.0.4
	OPENBSD_6_0_BASE:1.35
	OPENBSD_5_9:1.35.0.2
	OPENBSD_5_9_BASE:1.35
	OPENBSD_5_8:1.26.0.4
	OPENBSD_5_8_BASE:1.26
	OPENBSD_5_7:1.24.0.2
	OPENBSD_5_7_BASE:1.24
	OPENBSD_5_6:1.23.0.4
	OPENBSD_5_6_BASE:1.23
	OPENBSD_5_5:1.22.0.4
	OPENBSD_5_5_BASE:1.22
	OPENBSD_5_4:1.21.0.6
	OPENBSD_5_4_BASE:1.21
	OPENBSD_5_3:1.21.0.4
	OPENBSD_5_3_BASE:1.21
	OPENBSD_5_2:1.21.0.2
	OPENBSD_5_2_BASE:1.21
	OPENBSD_5_1_BASE:1.20
	OPENBSD_5_1:1.20.0.26
	OPENBSD_5_0:1.20.0.24
	OPENBSD_5_0_BASE:1.20
	OPENBSD_4_9:1.20.0.22
	OPENBSD_4_9_BASE:1.20
	OPENBSD_4_8:1.20.0.20
	OPENBSD_4_8_BASE:1.20
	OPENBSD_4_7:1.20.0.16
	OPENBSD_4_7_BASE:1.20
	OPENBSD_4_6:1.20.0.18
	OPENBSD_4_6_BASE:1.20
	OPENBSD_4_5:1.20.0.14
	OPENBSD_4_5_BASE:1.20
	OPENBSD_4_4:1.20.0.12
	OPENBSD_4_4_BASE:1.20
	OPENBSD_4_3:1.20.0.10
	OPENBSD_4_3_BASE:1.20
	OPENBSD_4_2:1.20.0.8
	OPENBSD_4_2_BASE:1.20
	OPENBSD_4_1:1.20.0.6
	OPENBSD_4_1_BASE:1.20
	OPENBSD_4_0:1.20.0.4
	OPENBSD_4_0_BASE:1.20
	OPENBSD_3_9:1.20.0.2
	OPENBSD_3_9_BASE:1.20
	OPENBSD_3_8:1.19.0.6
	OPENBSD_3_8_BASE:1.19
	OPENBSD_3_7:1.19.0.4
	OPENBSD_3_7_BASE:1.19
	OPENBSD_3_6:1.19.0.2
	OPENBSD_3_6_BASE:1.19
	OPENBSD_3_5:1.17.0.2
	OPENBSD_3_5_BASE:1.17
	OPENBSD_3_4:1.16.0.2
	OPENBSD_3_4_BASE:1.16
	OPENBSD_3_3:1.15.0.4
	OPENBSD_3_3_BASE:1.15
	OPENBSD_3_2:1.15.0.2
	OPENBSD_3_2_BASE:1.15
	OPENBSD_3_1:1.14.0.2
	OPENBSD_3_1_BASE:1.14
	OPENBSD_3_0:1.10.0.2
	OPENBSD_3_0_BASE:1.10
	OPENBSD_2_9_BASE:1.7
	OPENBSD_2_9:1.7.0.2
	OPENBSD_2_8:1.4.0.16
	OPENBSD_2_8_BASE:1.4
	OPENBSD_2_7:1.4.0.14
	OPENBSD_2_7_BASE:1.4
	OPENBSD_2_6:1.4.0.12
	OPENBSD_2_6_BASE:1.4
	OPENBSD_2_5:1.4.0.10
	OPENBSD_2_5_BASE:1.4
	OPENBSD_2_4:1.4.0.8
	OPENBSD_2_4_BASE:1.4
	OPENBSD_2_3:1.4.0.6
	OPENBSD_2_3_BASE:1.4
	OPENBSD_2_2:1.4.0.4
	OPENBSD_2_2_BASE:1.4
	OPENBSD_2_1:1.4.0.2
	OPENBSD_2_1_BASE:1.4
	OPENBSD_2_0:1.3.0.2
	OPENBSD_2_0_BASE:1.3
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.36
date	2017.05.20.09.31.19;	author espie;	state Exp;
branches;
next	1.35;
commitid	n489mEGsWvL1Sciy;

1.35
date	2016.01.05.16.10.57;	author espie;	state Exp;
branches;
next	1.34;
commitid	1g34MqcMsSNeu0G8;

1.34
date	2015.12.31.18.00.41;	author millert;	state Exp;
branches;
next	1.33;
commitid	2BXXAGEjdYhjTOAi;

1.33
date	2015.12.04.17.58.05;	author espie;	state Exp;
branches;
next	1.32;
commitid	l1M1YIbdY2r8FTLl;

1.32
date	2015.10.11.23.01.32;	author espie;	state Exp;
branches;
next	1.31;
commitid	xmiSIbsOFI1pUqjy;

1.31
date	2015.10.11.17.39.50;	author espie;	state Exp;
branches;
next	1.30;
commitid	l1YB3YBEayn9suxS;

1.30
date	2015.10.10.15.47.22;	author deraadt;	state Exp;
branches;
next	1.29;
commitid	IocfYrex5LGoEwmF;

1.29
date	2015.09.03.11.16.50;	author espie;	state Exp;
branches;
next	1.28;
commitid	WMrZMtfYwNhLQMj4;

1.28
date	2015.08.31.09.36.02;	author espie;	state Exp;
branches;
next	1.27;
commitid	CfRVBAfUeYbzY0xG;

1.27
date	2015.08.31.09.33.43;	author espie;	state Exp;
branches;
next	1.26;
commitid	b0nDGuVeIbNEX4HC;

1.26
date	2015.07.29.10.42.37;	author espie;	state Exp;
branches;
next	1.25;
commitid	EV0SZjBca0840DZM;

1.25
date	2015.07.21.07.13.59;	author jasper;	state Exp;
branches;
next	1.24;
commitid	HctRgvL25hJwwaUG;

1.24
date	2014.10.11.03.57.13;	author deraadt;	state Exp;
branches;
next	1.23;
commitid	xNYKxV5IWcymXmSK;

1.23
date	2014.05.12.19.11.20;	author espie;	state Exp;
branches;
next	1.22;

1.22
date	2013.11.27.00.13.24;	author deraadt;	state Exp;
branches;
next	1.21;

1.21
date	2012.03.29.22.04.28;	author jmc;	state Exp;
branches;
next	1.20;

1.20
date	2006.01.20.23.10.19;	author espie;	state Exp;
branches;
next	1.19;

1.19
date	2004.08.05.10.59.42;	author espie;	state Exp;
branches;
next	1.18;

1.18
date	2004.08.04.15.30.06;	author espie;	state Exp;
branches;
next	1.17;

1.17
date	2003.09.22.23.39.24;	author drahn;	state Exp;
branches;
next	1.16;

1.16
date	2003.06.10.22.20.53;	author deraadt;	state Exp;
branches;
next	1.15;

1.15
date	2002.07.17.11.21.43;	author espie;	state Exp;
branches;
next	1.14;

1.14
date	2002.02.27.20.26.37;	author espie;	state Exp;
branches;
next	1.13;

1.13
date	2002.02.17.19.42.33;	author millert;	state Exp;
branches;
next	1.12;

1.12
date	2002.02.16.21.27.55;	author millert;	state Exp;
branches;
next	1.11;

1.11
date	2002.02.14.12.11.49;	author espie;	state Exp;
branches;
next	1.10;

1.10
date	2001.07.14.14.18.50;	author espie;	state Exp;
branches;
next	1.9;

1.9
date	2001.05.01.20.36.57;	author espie;	state Exp;
branches;
next	1.8;

1.8
date	2001.04.30.21.03.55;	author espie;	state Exp;
branches;
next	1.7;

1.7
date	2001.04.18.17.57.28;	author espie;	state Exp;
branches;
next	1.6;

1.6
date	2001.04.07.14.17.38;	author espie;	state Exp;
branches;
next	1.5;

1.5
date	2001.03.26.22.53.33;	author espie;	state Exp;
branches;
next	1.4;

1.4
date	97.01.15.23.43.26;	author millert;	state Exp;
branches;
next	1.3;

1.3
date	96.06.26.05.42.00;	author deraadt;	state Exp;
branches;
next	1.2;

1.2
date	96.01.29.01.02.19;	author deraadt;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.46.27;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.46.27;	author deraadt;	state Exp;
branches;
next	;


desc
@@


1.36
log
@reorg node struct so it's packed tighter (found by clang actually)
mark usage __dead
okay millert@@
@
text
@/* $OpenBSD: tsort.c,v 1.35 2016/01/05 16:10:57 espie Exp $ */
/* ex:ts=8 sw=4:
 *
 * Copyright (c) 1999-2004 Marc Espie <espie@@openbsd.org>
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */

#include <assert.h>
#include <ctype.h>
#include <err.h>
#include <limits.h>
#include <stddef.h>
#include <stdio.h>
#include <stdint.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <ohash.h>

/* The complexity of topological sorting is O(e), where e is the
 * size of input.  While reading input, vertices have to be identified,
 * thus add the complexity of e keys retrieval among v keys using
 * an appropriate data structure.  This program uses open double hashing
 * for that purpose.  See Knuth for the expected complexity of double
 * hashing (Brent variation should probably be used if v << e, as a user
 * option).
 *
 * The algorithm used for longest cycle reporting is accurate, but somewhat
 * expensive.  It may need to build all free paths of the graph (a free
 * path is a path that never goes twice through the same node), whose
 * number can be as high as O(2^e).  Usually, the number of free paths is
 * much smaller though.  This program's author does not believe that a
 * significantly better worst-case complexity algorithm exists.
 *
 * In case of a hints file, the set of minimal nodes is maintained as a
 * heap.  The resulting complexity is O(e+v log v) for the worst case.
 * The average should actually be near O(e).
 *
 * If the hints file is incomplete, there is some extra complexity incurred
 * by make_transparent, which does propagate order values to unmarked
 * nodes. In the worst case, make_transparent is  O(e u),
 * where u is the number of originally unmarked nodes.
 * In practice, it is much faster.
 *
 * The simple topological sort algorithm detects cycles.  This program
 * goes further, breaking cycles through the use of simple heuristics.
 * Each cycle break checks the whole set of nodes, hence if c cycles break
 * are needed, this is an extra cost of O(c v).
 *
 * Possible heuristics are as follows:
 * - break cycle at node with lowest number of predecessors (default case),
 * - break longest cycle at node with lowest number of predecessors,
 * - break cycle at next node from the hints file.
 *
 * Except for the hints file case, which sets an explicit constraint on
 * which cycle to break, those heuristics locally result in the smallest
 * number of broken edges.
 *
 * Those are admittedly greedy strategies, as is the selection of the next
 * node from the hints file amongst equivalent candidates that is used for
 * `stable' topological sorting.
 */

#ifdef __GNUC__
#define UNUSED	__attribute__((unused))
#else
#define UNUSED
#endif

struct node;

/* The set of arcs from a given node is stored as a linked list.  */
struct link {
	struct link *next;
	struct node *node;
};

#define NO_ORDER	UINT_MAX

struct node {
	unsigned int refs;	/* Number of arcs left, coming into this node.
				 * Note that nodes with a null count can't
				 * be part of cycles.  */
	unsigned int order; 	/* Order of nodes according to a hint file.  */

	struct link  *arcs;	/* List of forward arcs.  */

	/* Cycle detection algorithms build a free path of nodes.  */
	struct node  *from; 	/* Previous node in the current path.  */
	struct link  *traverse;	/* Next link to traverse when backtracking.  */
	unsigned int mark;	/* Mark processed nodes in cycle discovery.  */

	char         k[1];	/* Name of this node.  */
};

#define HASH_START 9

struct array {
	unsigned int entries;
	struct node  **t;
};

static void nodes_init(struct ohash *);
static struct node *node_lookup(struct ohash *, const char *, const char *);
static __dead void usage(void);
static struct node *new_node(const char *, const char *);

static unsigned int read_pairs(FILE *, struct ohash *, int,
    const char *, unsigned int, int);
static void split_nodes(struct ohash *, struct array *, struct array *);
static void make_transparent(struct ohash *);
static void insert_arc(struct node *, struct node *);

#ifdef DEBUG
static void dump_node(struct node *);
static void dump_array(struct array *);
static void dump_hash(struct ohash *);
#endif
static unsigned int read_hints(FILE *, struct ohash *, int,
    const char *, unsigned int);
static struct node *find_smallest_node(struct array *);
static struct node *find_good_cycle_break(struct array *);
static void print_cycle(struct array *);
static struct node *find_cycle_from(struct node *, struct array *);
static struct node *find_predecessor(struct array *, struct node *);
static unsigned int traverse_node(struct node *, unsigned int, struct array *);
static struct node *find_longest_cycle(struct array *, struct array *);
static struct node *find_normal_cycle(struct array *, struct array *);

static void heap_down(struct array *, unsigned int);
static void heapify(struct array *, int);
static struct node *dequeue(struct array *);
static void enqueue(struct array *, struct node *);



static void *hash_calloc(size_t, size_t, void *);
static void hash_free(void *, void *);
static void* entry_alloc(size_t, void *);
static void *ereallocarray(void *, size_t, size_t);
static void *emem(void *);
#define DEBUG_TRAVERSE 0
static struct ohash_info node_info = {
	offsetof(struct node, k), NULL, hash_calloc, hash_free, entry_alloc };
static void parse_args(int, char *[], struct ohash *);
static int tsort(struct ohash *);

static int 		quiet_flag, long_flag,
			warn_flag, hints_flag, verbose_flag;


int main(int, char *[]);

/***
 *** Memory handling.
 ***/

static void *
emem(void *p)
{
	if (p)
		return p;
	else
		errx(1, "Memory exhausted");
}

static void *
hash_calloc(size_t n, size_t s, void *u UNUSED)
{
	return emem(calloc(n, s));
}

static void
hash_free(void *p, void *u UNUSED)
{
	free(p);
}

static void *
entry_alloc(size_t s, void *u UNUSED)
{
	return ereallocarray(NULL, 1, s);
}

static void *
ereallocarray(void *p, size_t n, size_t s)
{
	return emem(reallocarray(p, n, s));
}


/***
 *** Hash table.
 ***/

/* Inserting and finding nodes in the hash structure.
 * We handle interval strings for efficiency wrt fgetln.  */
static struct node *
new_node(const char *start, const char *end)
{
	struct node 	*n;

	n = ohash_create_entry(&node_info, start, &end);
	n->from = NULL;
	n->arcs = NULL;
	n->refs = 0;
	n->mark = 0;
	n->order = NO_ORDER;
	n->traverse = NULL;
	return n;
}


static void
nodes_init(struct ohash *h)
{
	ohash_init(h, HASH_START, &node_info);
}

static struct node *
node_lookup(struct ohash *h, const char *start, const char *end)
{
	unsigned int	i;
	struct node *	n;

	i = ohash_qlookupi(h, start, &end);

	n = ohash_find(h, i);
	if (n == NULL)
		n = ohash_insert(h, i, new_node(start, end));
	return n;
}

#ifdef DEBUG
static void
dump_node(struct node *n)
{
	struct link 	*l;

	if (n->refs == 0)
		return;
	printf("%s (%u/%u): ", n->k, n->order, n->refs);
	for (l = n->arcs; l != NULL; l = l->next)
		if (n->refs != 0)
		printf("%s(%u/%u) ", l->node->k, l->node->order, l->node->refs);
    	putchar('\n');
}

static void
dump_array(struct array *a)
{
	unsigned int 	i;

	for (i = 0; i < a->entries; i++)
		dump_node(a->t[i]);
}

static void
dump_hash(struct ohash *h)
{
	unsigned int 	i;
	struct node 	*n;

	for (n = ohash_first(h, &i); n != NULL; n = ohash_next(h, &i))
		dump_node(n);
}
#endif

/***
 *** Reading data.
 ***/

static void
insert_arc(struct node *a, struct node *b)
{
	struct link 	*l;

	/* Check that this arc is not already present.  */
	for (l = a->arcs; l != NULL; l = l->next) {
		if (l->node == b)
			return;
	}
	b->refs++;
	l = ereallocarray(NULL, 1, sizeof(struct link));
	l->node = b;
	l->next = a->arcs;
	a->arcs = l;
}

static unsigned int
read_pairs(FILE *f, struct ohash *h, int reverse, const char *name,
    unsigned int order, int hint)
{
	int 		toggle;
	struct node 	*a;
	size_t 		size;
	char 		*str;

	toggle = 1;
	a = NULL;

	while ((str = fgetln(f, &size)) != NULL) {
		char *sentinel;

		sentinel = str + size;
		for (;;) {
			char *e;

			while (str < sentinel &&
			    isspace((unsigned char)*str))
				str++;
			if (str == sentinel)
				break;
			for (e = str;
			    e < sentinel && !isspace((unsigned char)*e); e++)
				continue;
			if (toggle) {
				a = node_lookup(h, str, e);
				if (a->order == NO_ORDER && hint)
					a->order = order++;
			} else {
				struct node *b;

				b = node_lookup(h, str, e);
				assert(a != NULL);
				if (b != a) {
					if (reverse)
						insert_arc(b, a);
					else
						insert_arc(a, b);
				}
			}
			toggle = !toggle;
			str = e;
		}
	}
	if (toggle == 0)
		errx(1, "odd number of node names in %s", name);
    	if (!feof(f))
		err(1, "error reading %s", name);
	return order;
}

static unsigned int
read_hints(FILE *f, struct ohash *h, int quiet, const char *name,
    unsigned int order)
{
	char 		*str;
	size_t 		size;

	while ((str = fgetln(f, &size)) != NULL) {
		char *sentinel;

		sentinel = str + size;
		for (;;) {
			char *e;
			struct node *a;

			while (str < sentinel && isspace((unsigned char)*str))
				str++;
			if (str == sentinel)
				break;
			for (e = str;
			    e < sentinel && !isspace((unsigned char)*e); e++)
				continue;
			a = node_lookup(h, str, e);
			if (a->order != NO_ORDER) {
				if (!quiet)
				    warnx(
					"duplicate node %s in hints file %s",
					a->k, name);
			} else
				a->order = order++;
			str = e;
		}
	}
    	if (!feof(f))
		err(1, "error reading %s", name);
	return order;
}


/***
 *** Standard heap handling routines.
 ***/

static void
heap_down(struct array *h, unsigned int i)
{
	unsigned int 	j;
	struct node 	*swap;

	for (; (j=2*i+1) < h->entries; i = j) {
		if (j+1 < h->entries && h->t[j+1]->order < h->t[j]->order)
		    	j++;
		if (h->t[i]->order <= h->t[j]->order)
			break;
		swap = h->t[i];
		h->t[i] = h->t[j];
		h->t[j] = swap;
	}
}

static void
heapify(struct array *h, int verbose)
{
	unsigned int 	i;

	for (i = h->entries; i != 0;) {
		if (h->t[--i]->order == NO_ORDER && verbose)
			warnx("node %s absent from hints file", h->t[i]->k);
		heap_down(h, i);
	}
}

#define DEQUEUE(h) ( hints_flag ? dequeue(h) : (h)->t[--(h)->entries] )

static struct node *
dequeue(struct array *h)
{
	struct node 	*n;

	if (h->entries == 0)
		n = NULL;
	else {
		n = h->t[0];
		if (--h->entries != 0) {
		    h->t[0] = h->t[h->entries];
		    heap_down(h, 0);
		}
	}
	return n;
}

#define ENQUEUE(h, n) do {			\
	if (hints_flag)				\
		enqueue((h), (n));		\
	else					\
		(h)->t[(h)->entries++] = (n);	\
	} while(0);

static void
enqueue(struct array *h, struct node *n)
{
	unsigned int 	i, j;
	struct node 	*swap;

	h->t[h->entries++] = n;
	for (i = h->entries-1; i > 0; i = j) {
		j = (i-1)/2;
		if (h->t[j]->order < h->t[i]->order)
			break;
		swap = h->t[j];
		h->t[j] = h->t[i];
		h->t[i] = swap;
	}
}

/* Nodes without order should not hinder direct dependencies.
 * Iterate until no nodes are left.
 */
static void
make_transparent(struct ohash *hash)
{
	struct node 	*n;
	unsigned int 	i;
	struct link 	*l;
	int		adjusted;
	int		bad;
	unsigned int	min;

	/* first try to solve complete nodes */
	do {
		adjusted = 0;
		bad = 0;
		for (n = ohash_first(hash, &i); n != NULL;
		    n = ohash_next(hash, &i)) {
			if (n->order == NO_ORDER) {
				min = NO_ORDER;

				for (l = n->arcs; l != NULL; l = l->next) {
					/* unsolved node -> delay resolution */
					if (l->node->order == NO_ORDER) {
						bad = 1;
						break;
					} else if (l->node->order < min)
						min = l->node->order;
				}
				if (min < NO_ORDER && l == NULL) {
					n->order = min;
					adjusted = 1;
				}
			}
		}

	} while (adjusted);

	/* then, if incomplete nodes are left, do them */
	if (bad) do {
		adjusted = 0;
		for (n = ohash_first(hash, &i); n != NULL;
		    n = ohash_next(hash, &i))
			if (n->order == NO_ORDER)
				for (l = n->arcs; l != NULL; l = l->next)
					if (l->node->order < n->order) {
						n->order = l->node->order;
						adjusted = 1;
					}
	} while (adjusted);
}


/***
 *** Search through hash array for nodes.
 ***/

/* Split nodes into unrefed nodes/live nodes.  */
static void
split_nodes(struct ohash *hash, struct array *heap, struct array *remaining)
{

	struct node *n;
	unsigned int i;

	heap->t = ereallocarray(NULL, ohash_entries(hash),
	    sizeof(struct node *));
	remaining->t = ereallocarray(NULL, ohash_entries(hash),
	    sizeof(struct node *));
	heap->entries = 0;
	remaining->entries = 0;

	for (n = ohash_first(hash, &i); n != NULL; n = ohash_next(hash, &i)) {
		if (n->refs == 0)
			heap->t[heap->entries++] = n;
		else
			remaining->t[remaining->entries++] = n;
	}
}

/* Good point to break a cycle: live node with as few refs as possible. */
static struct node *
find_good_cycle_break(struct array *h)
{
	unsigned int 	i;
	unsigned int 	best;
	struct node 	*u;

	best = UINT_MAX;
	u = NULL;

	assert(h->entries != 0);
	for (i = 0; i < h->entries; i++) {
		struct node *n = h->t[i];
		/* No need to look further. */
		if (n->refs == 1)
			return n;
		if (n->refs != 0 && n->refs < best) {
			best = n->refs;
			u = n;
		}
	}
	assert(u != NULL);
	return u;
}

/*  Retrieve the node with the smallest order.  */
static struct node *
find_smallest_node(struct array *h)
{
	unsigned int 	i;
	unsigned int 	best;
	struct node 	*u;

	best = UINT_MAX;
	u = NULL;

	assert(h->entries != 0);
	for (i = 0; i < h->entries; i++) {
		struct node *n = h->t[i];
		if (n->refs != 0 && n->order < best) {
			best = n->order;
			u = n;
		}
	}
	assert(u != NULL);
	return u;
}


/***
 *** Graph algorithms.
 ***/

/* Explore the nodes reachable from i to find a cycle, store it in c.
 * This may fail.  */
static struct node *
find_cycle_from(struct node *i, struct array *c)
{
	struct node 	*n;

	n = i;
	/* XXX Previous cycle findings may have left this pointer non-null.  */
	i->from = NULL;

	for (;;) {
		/* Note that all marks are reversed before this code exits.  */
		n->mark = 1;
		if (n->traverse)
			n->traverse = n->traverse->next;
		else
			n->traverse = n->arcs;
		/* Skip over dead nodes.  */
		while (n->traverse && n->traverse->node->refs == 0)
			n->traverse = n->traverse->next;
		if (n->traverse) {
			struct node *go = n->traverse->node;

			if (go->mark) {
				c->entries = 0;
				for (; n != NULL && n != go; n = n->from) {
					c->t[c->entries++] = n;
					n->mark = 0;
				}
				for (; n != NULL; n = n->from)
					n->mark = 0;
				c->t[c->entries++] = go;
				return go;
			} else {
			    go->from = n;
			    n = go;
			}
		} else {
			n->mark = 0;
			n = n->from;
			if (n == NULL)
				return NULL;
		}
	}
}

/* Find a live predecessor of node n.  This is a slow routine, as it needs
 * to go through the whole array, but it is not needed often.
 */
static struct node *
find_predecessor(struct array *a, struct node *n)
{
	unsigned int i;

	for (i = 0; i < a->entries; i++) {
		struct node *m;

		m = a->t[i];
		if (m->refs != 0) {
			struct link *l;

			for (l = m->arcs; l != NULL; l = l->next)
				if (l->node == n)
					return m;
		}
	}
	assert(1 == 0);
	return NULL;
}

/* Traverse all strongly connected components reachable from node n.
   Start numbering them at o. Return the maximum order reached.
   Update the largest cycle found so far.
 */
static unsigned int
traverse_node(struct node *n, unsigned int o, struct array *c)
{
	unsigned int 	min, max;

	n->from = NULL;
	min = o;
	max = ++o;

	for (;;) {
		n->mark = o;
		if (DEBUG_TRAVERSE)
			printf("%s(%u) ", n->k, n->mark);
		/* Find next arc to explore.  */
		if (n->traverse)
			n->traverse = n->traverse->next;
		else
			n->traverse = n->arcs;
		/* Skip over dead nodes.  */
		while (n->traverse && n->traverse->node->refs == 0)
			n->traverse = n->traverse->next;
		/* If arc left.  */
		if (n->traverse) {
			struct node 	*go;

			go = n->traverse->node;
			/* Optimisation: if go->mark < min, we already
			 * visited this strongly-connected component in
			 * a previous pass.  Hence, this can yield no new
			 * cycle.  */

			/* Not part of the current path: go for it.  */
			if (go->mark == 0 || go->mark == min) {
				go->from = n;
				n = go;
				o++;
				if (o > max)
					max = o;
			/* Part of the current path: check cycle length.  */
			} else if (go->mark > min) {
				if (DEBUG_TRAVERSE)
					printf("%d\n", o - go->mark + 1);
				if (o - go->mark + 1 > c->entries) {
					struct node *t;
					unsigned int i;

					c->entries = o - go->mark + 1;
					i = 0;
					c->t[i++] = go;
					for (t = n; t != go; t = t->from)
						c->t[i++] = t;
				}
			}

		/* No arc left: backtrack.  */
		} else {
			n->mark = min;
			n = n->from;
			if (!n)
				return max;
			o--;
		}
	}
}

static void
print_cycle(struct array *c)
{
	unsigned int 	i;

	/* Printing in reverse order, since cycle discoveries finds reverse
	 * edges.  */
	for (i = c->entries; i != 0;) {
		i--;
		warnx("%s", c->t[i]->k);
	}
}

static struct node *
find_longest_cycle(struct array *h, struct array *c)
{
	unsigned int 	i;
	unsigned int 	o;
	unsigned int 	best;
	struct node 	*n;
	static int 	notfirst = 0;

	assert(h->entries != 0);

	/* No cycle found yet.  */
	c->entries = 0;

	/* Reset the set of marks, except the first time around.  */
	if (notfirst) {
		for (i = 0; i < h->entries; i++)
			h->t[i]->mark = 0;
	} else
		notfirst = 1;

	o = 0;

	/* Traverse the array.  Each unmarked, live node heralds a
	 * new set of strongly connected components.  */
	for (i = 0; i < h->entries; i++) {
		n = h->t[i];
		if (n->refs != 0 && n->mark == 0) {
			/* Each call to traverse_node uses a separate
			 * interval of numbers to mark nodes.  */
			o++;
			o = traverse_node(n, o, c);
		}
	}

	assert(c->entries != 0);
	n = c->t[0];
	best = n->refs;
	for (i = 0; i < c->entries; i++) {
		if (c->t[i]->refs < best) {
			n = c->t[i];
			best = n->refs;
		}
	}
	return n;
}

static struct node *
find_normal_cycle(struct array *h, struct array *c)
{
	struct node *b, *n;

	if (hints_flag)
		n = find_smallest_node(h);
	else
		n = find_good_cycle_break(h);
	while ((b = find_cycle_from(n, c)) == NULL)
		n = find_predecessor(h, n);
	return b;
}


#define plural(n) ((n) > 1 ? "s" : "")

static void 
parse_args(int argc, char *argv[], struct ohash *pairs)
{
	int c;
	unsigned int	order;
	int reverse_flag;
	const char **files;
	int i, j;

	i = 0;

	reverse_flag = quiet_flag = long_flag =
		warn_flag = hints_flag = verbose_flag = 0;
	/* argc is good enough, as we start at argv[1] */
	files = ereallocarray(NULL, argc, sizeof (char *));
	while ((c = getopt(argc, argv, "h:flqrvw")) != -1) {
		switch(c) {
		case 'h':
			files[i++] = optarg;
			hints_flag = 1;
			break;
			/*FALLTHRU*/
		case 'f':
			hints_flag = 2;
			break;
		case 'l':
			long_flag = 1;
			break;
		case 'q':
			quiet_flag = 1;
			break;
		case 'r':
			reverse_flag = 1;
			break;
		case 'v':
			verbose_flag = 1;
			break;
		case 'w':
			warn_flag = 1;
			break;
		default:
			usage();
		}
	}

	argc -= optind;
	argv += optind;

	switch(argc) {
	case 1:
		files[i++] = argv[0];
		break;
	case 0:
		break;
	default:
		usage();
	}

	files[i] = NULL;

/*	if (pledge("stdio rpath", files) == -1) */
	if (pledge("stdio rpath", NULL) == -1)
		err(1, "pledge");

	nodes_init(pairs);
	order = 0;
		
	for (j = 0; j != i-argc; j++) {
		FILE *f;

		f = fopen(files[j], "r");
		if (f == NULL)
			err(1, "Can't open hint file %s", files[i]);
		order = read_hints(f, pairs, quiet_flag, files[i], order);
		fclose(f);
    	}
	free(files);

	if (argc == 1) {
		FILE *f;

		f = fopen(argv[0], "r");
		if (f == NULL)
			err(1, "Can't open file %s", argv[0]);
		order = read_pairs(f, pairs, reverse_flag, argv[0], order,
		    hints_flag == 2);
		fclose(f);
	} else {
		order = read_pairs(stdin, pairs, reverse_flag, "stdin",
		    order, hints_flag == 2);
	}

	if (pledge("stdio", NULL) == -1)
		err(1, "pledge");
}

static int
tsort(struct ohash *pairs)
{
	    struct array 	aux;	/* Unrefed nodes/cycle reporting.  */
	    struct array	remaining;
	    unsigned int	broken_arcs, broken_cycles;
	    unsigned int	left;

	    broken_arcs = 0;
	    broken_cycles = 0;

	    if (hints_flag)
		    make_transparent(pairs);
	    split_nodes(pairs, &aux, &remaining);
	    ohash_delete(pairs);

	    if (hints_flag)
		    heapify(&aux, verbose_flag);

	    left = remaining.entries + aux.entries;
	    while (left != 0) {

		    /* Standard topological sort.  */
		    while (aux.entries) {
			    struct link *l;
			    struct node *n;

			    n = DEQUEUE(&aux);
			    printf("%s\n", n->k);
			    left--;
			    /* We can't free nodes, as we don't know which
			     * entry we can remove in the hash table.  We
			     * rely on refs == 0 to recognize live nodes.
			     * Decrease ref count of live nodes, enter new
			     * candidates into the unrefed list.  */
			    for (l = n->arcs; l != NULL; l = l->next)
				    if (l->node->refs != 0 &&
					--l->node->refs == 0) {
					    ENQUEUE(&aux, l->node);
				    }
		    }
		    /* There are still cycles to break.  */
		    if (left != 0) {
			    struct node *n;

			    broken_cycles++;
			    /* XXX Simple cycle detection and long cycle
			     * detection are mutually exclusive.  */

			    if (long_flag)
				    n = find_longest_cycle(&remaining, &aux);
			    else
				    n = find_normal_cycle(&remaining, &aux);

			    if (!quiet_flag) {
				    warnx("cycle in data");
				    print_cycle(&aux);
			    }

			    if (verbose_flag)
				    warnx("%u edge%s broken", n->refs,
					plural(n->refs));
			    broken_arcs += n->refs;
			    n->refs = 0;
			    /* Reinitialization, cycle reporting uses aux.  */
			    aux.t[0] = n;
			    aux.entries = 1;
		    }
	    }
	    if (verbose_flag && broken_cycles != 0)
		    warnx("%u cycle%s broken, for a total of %u edge%s",
			broken_cycles, plural(broken_cycles),
			broken_arcs, plural(broken_arcs));
	    if (warn_flag)
		    return (broken_cycles < 256 ? broken_cycles : 255);
	    else
		    return (0);
}

int
main(int argc, char *argv[])
{
	struct ohash 	pairs;

	if (pledge("stdio rpath", NULL) == -1)
		err(1, "pledge");

	parse_args(argc, argv, &pairs);
	return tsort(&pairs);
}


extern char *__progname;

static void
usage(void)
{
	fprintf(stderr, "Usage: %s [-flqrvw] [-h file] [file]\n", __progname);
	exit(1);
}
@


1.35
log
@stuff may still change, disable whitelist for now.
ok semarie@@
@
text
@d1 1
a1 1
/* $OpenBSD: tsort.c,v 1.34 2015/12/31 18:00:41 millert Exp $ */
d95 2
a98 2
	unsigned int order; 	/* Order of nodes according to a hint file.  */

d101 2
a103 2
	unsigned int mark;	/* Mark processed nodes in cycle discovery.  */
	struct link  *traverse;	/* Next link to traverse when backtracking.  */
d116 1
a116 1
static void usage(void);
@


1.34
log
@Remove use of sysexits.h; OK espie@@
@
text
@d1 1
a1 1
/* $OpenBSD: tsort.c,v 1.33 2015/12/04 17:58:05 espie Exp $ */
d882 2
a883 1
	if (pledge("stdio rpath", files) == -1)
@


1.33
log
@read_hints should also protect against ferror.
obvious commit
@
text
@d1 1
a1 1
/* $OpenBSD: tsort.c,v 1.32 2015/10/11 23:01:32 espie Exp $ */
a27 1
#include <sysexits.h>
d175 1
a175 1
		errx(EX_SOFTWARE, "Memory exhausted");
d349 1
a349 1
		errx(EX_DATAERR, "odd number of node names in %s", name);
d351 1
a351 1
		err(EX_IOERR, "error reading %s", name);
d389 1
a389 1
		err(EX_IOERR, "error reading %s", name);
d893 1
a893 1
			err(EX_NOINPUT, "Can't open hint file %s", files[i]);
d904 1
a904 1
			err(EX_NOINPUT, "Can't open file %s", argv[0]);
d993 1
a993 1
		    return (EX_OK);
d1015 1
a1015 1
	exit(EX_USAGE);
@


1.32
log
@now that tsort has a clean structure, do more specific pledge() calls.
okay deraadt@@
@
text
@d1 1
a1 1
/* $OpenBSD: tsort.c,v 1.31 2015/10/11 17:39:50 espie Exp $ */
d389 2
@


1.31
log
@reorg code to have an array with all the files used apparent.
okay millert@@
@
text
@d1 1
a1 1
/* $OpenBSD: tsort.c,v 1.30 2015/10/10 15:47:22 deraadt Exp $ */
d827 1
a827 1
	char **files;
d881 3
d911 3
@


1.30
log
@basic pledge "stdio rpath"
ok doug
@
text
@d1 1
a1 1
/* $OpenBSD: tsort.c,v 1.29 2015/09/03 11:16:50 espie Exp $ */
d827 2
d830 1
a830 1
	order = 0;
d834 2
a835 1
	nodes_init(pairs);
d838 2
a839 11
		case 'h': {
			FILE *f;

			f = fopen(optarg, "r");
			if (f == NULL)
				err(EX_NOINPUT, "Can't open hint file %s",
				    optarg);
			order = read_hints(f, pairs, quiet_flag,
			    optarg, order);
			fclose(f);
		}
d870 26
a895 1
	case 1: {
d904 1
a904 3
		break;
	}
	case 0:
a906 3
		break;
	default:
		usage();
@


1.29
log
@reorg code, preliminary step to more cleanup
- split the two blobs in main into separate functions
- use return instead of exit

okay millert@@
@
text
@d1 1
a1 1
/* $OpenBSD: tsort.c,v 1.28 2015/08/31 09:36:02 espie Exp $ */
d979 3
@


1.28
log
@indent is 8 not 4
@
text
@d1 1
a1 1
/* $OpenBSD: tsort.c,v 1.27 2015/08/31 09:33:43 espie Exp $ */
d140 1
d157 5
d804 14
d821 2
a822 2
int
main(int argc, char *argv[])
d824 1
a824 3
	struct ohash 	pairs;
	int 		reverse_flag, quiet_flag, long_flag,
			    warn_flag, hints_flag, verbose_flag;
d826 1
d832 39
a870 43
	nodes_init(&pairs);

	{
	    int c;

	    while ((c = getopt(argc, argv, "h:flqrvw")) != -1) {
		    switch(c) {
		    case 'h': {
			    FILE *f;

			    f = fopen(optarg, "r");
			    if (f == NULL)
				    err(EX_NOINPUT, "Can't open hint file %s",
					optarg);
			    order = read_hints(f, &pairs, quiet_flag,
				optarg, order);
			    fclose(f);
		    }
			    hints_flag = 1;
			    break;
			    /*FALLTHRU*/
		    case 'f':
			    hints_flag = 2;
			    break;
		    case 'l':
			    long_flag = 1;
			    break;
		    case 'q':
			    quiet_flag = 1;
			    break;
		    case 'r':
			    reverse_flag = 1;
			    break;
		    case 'v':
			    verbose_flag = 1;
			    break;
		    case 'w':
			    warn_flag = 1;
			    break;
		    default:
			    usage();
		    }
	    }
d872 2
a873 3
	    argc -= optind;
	    argv += optind;
	}
d882 1
a882 1
		order = read_pairs(f, &pairs, reverse_flag, argv[0], order,
d888 1
a888 1
		order = read_pairs(stdin, &pairs, reverse_flag, "stdin",
d894 1
d896 3
a898 1
	{
d908 3
a910 3
		    make_transparent(&pairs);
	    split_nodes(&pairs, &aux, &remaining);
	    ohash_delete(&pairs);
d945 1
a945 1
			    if (long_flag) {
d947 2
a948 11
			    } else {
				    struct node *b;

				    if (hints_flag)
					    n = find_smallest_node(&remaining);
				    else
					    n = find_good_cycle_break(&remaining);
				    while ((b = find_cycle_from(n, &aux)) == NULL)
					    n = find_predecessor(&remaining, n);
				    n = b;
			    }
d970 1
a970 1
		    exit(broken_cycles < 256 ? broken_cycles : 255);
d972 10
a981 2
		    exit(EX_OK);
	}
@


1.27
log
@wrong index in error message
@
text
@d1 1
a1 1
/* $OpenBSD: tsort.c,v 1.26 2015/07/29 10:42:37 espie Exp $ */
d891 1
a891 1
	    	make_transparent(&pairs);
@


1.26
log
@gc macro that's no longer used since the move to reallocarray
@
text
@d1 1
a1 1
/* $OpenBSD: tsort.c,v 1.25 2015/07/21 07:13:59 jasper Exp $ */
d867 2
a868 2
			err(EX_NOINPUT, "Can't open file %s", argv[1]);
		order = read_pairs(f, &pairs, reverse_flag, argv[1], order,
@


1.25
log
@whitespace cleanup
@
text
@d1 1
a1 1
/* $OpenBSD: tsort.c,v 1.24 2014/10/11 03:57:13 deraadt Exp $ */
a147 1
#define erealloc(n, s)	emem(realloc(n, s))
@


1.24
log
@convert to use of reallocarray()
ok doug
@
text
@d1 1
a1 1
/* $OpenBSD: tsort.c,v 1.23 2014/05/12 19:11:20 espie Exp $ */
a160 1

d240 1
a240 1
	
d264 1
a264 1
		
d275 1
a275 2
		

d308 1
a308 1
	
d439 1
a439 1
	
d559 1
a559 1
		/* No need to look further. */		
d570 1
a570 1
			
d734 1
a734 1
			o--;	
d786 1
a786 1
	
@


1.23
log
@adjust to ohash being in libutil now, and to the interface changes.
fix potential integer overflows in memory allocation (mostly for pedagogical
purposes, these are unlikely to overflow in practice)
move the rest of lst.lib stuff into its own directory.
@
text
@d1 1
a1 1
/* $OpenBSD: tsort.c,v 1.22 2013/11/27 00:13:24 deraadt Exp $ */
d152 1
a152 1
static void *emalloc(size_t);
d190 1
a190 1
	return emalloc(s);
d194 1
a194 1
emalloc(size_t s)
d196 1
a196 1
	return emem(malloc(s));
d293 1
a293 1
	l = emalloc(sizeof(struct link));
d532 4
a535 2
	heap->t = emalloc(sizeof(struct node *) * ohash_entries(hash));
	remaining->t = emalloc(sizeof(struct node *) * ohash_entries(hash));
@


1.22
log
@unsigned char for ctype
ok okan
@
text
@d1 1
a1 1
/* $OpenBSD: tsort.c,v 1.21 2012/03/29 22:04:28 jmc Exp $ */
d149 2
a150 2
static void *hash_alloc(size_t, void *);
static void hash_free(void *, size_t, void *);
d156 1
a156 1
	offsetof(struct node, k), NULL, hash_alloc, hash_free, entry_alloc };
d176 1
a176 1
hash_alloc(size_t s, void *u UNUSED)
d178 1
a178 1
	return emem(calloc(s, 1));
d182 1
a182 1
hash_free(void *p, size_t s UNUSED, void *u UNUSED)
@


1.21
log
@there must be an even number of node names, not pairs;
from Jan Stary
@
text
@d1 1
a1 1
/* $OpenBSD: tsort.c,v 1.20 2006/01/20 23:10:19 espie Exp $ */
d318 2
a319 1
			while (str < sentinel && isspace(*str))
d323 2
a324 1
			for (e = str; e < sentinel && !isspace(*e); e++)
d368 1
a368 1
			while (str < sentinel && isspace(*str))
d372 2
a373 1
			for (e = str; e < sentinel && !isspace(*e); e++)
@


1.20
log
@use stdint.h where appropriate. okay millert@@
@
text
@d1 1
a1 1
/* $OpenBSD: tsort.c,v 1.19 2004/08/05 10:59:42 espie Exp $ */
d345 1
a345 1
		errx(EX_DATAERR, "odd number of pairs in %s", name);
@


1.19
log
@simpler copyright, adjust date.
@
text
@d1 1
a1 1
/* $OpenBSD: tsort.c,v 1.18 2004/08/04 15:30:06 espie Exp $ */
a18 1
#include <sys/types.h>
a23 1
#include <ohash.h>
d25 1
d30 1
@


1.18
log
@sort SYNOPSIS and usage(), format tweaks, by jmc@@
@
text
@d1 1
a1 1
/* $OpenBSD: tsort.c,v 1.17 2003/09/22 23:39:24 drahn Exp $ */
a2 4
 */

/*
 * Copyright (c) 1999-2001 Marc Espie.
d4 1
a4 8
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
d6 11
a16 11
 * THIS SOFTWARE IS PROVIDED BY THE OPENBSD PROJECT AND CONTRIBUTORS
 * ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
 * A PARTICULAR PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE OPENBSD
 * PROJECT OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
@


1.17
log
@Fix read beyond end of buffer, found by mallocguard. ok deraadt@@ espie@@
@
text
@d1 1
a1 1
/* $OpenBSD: tsort.c,v 1.16 2003/06/10 22:20:53 deraadt Exp $ */
d983 1
a983 1
	fprintf(stderr, "Usage: %s [-h file] [-flqrvw] [file]\n", __progname);
@


1.16
log
@mostly ansi cleanup; pval ok
@
text
@d1 1
a1 1
/* $OpenBSD: tsort.c,v 1.15 2002/07/17 11:21:43 espie Exp $ */
d329 1
a329 1
			while (isspace(*str) && str < sentinel)
d333 1
a333 1
			for (e = str; !isspace(*e) && e < sentinel; e++)
d377 1
a377 1
			while (isspace(*str) && str < sentinel)
d381 1
a381 1
			for (e = str; !isspace(*e) && e < sentinel; e++)
@


1.15
log
@spring clean-up: remove extra spaces at end of line,
and rescind 3rd licence clause.
@
text
@d1 1
a1 1
/* $OpenBSD: tsort.c,v 1.14 2002/02/27 20:26:37 espie Exp $ */
d981 1
a981 1
usage()
@


1.14
log
@ANSI decls. okay millert@@
@
text
@d1 2
a2 2
/* $OpenBSD: tsort.c,v 1.13 2002/02/17 19:42:33 millert Exp $ */
/* ex:ts=8 sw=4: 
a15 4
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 * This product includes software developed by Marc Espie for the OpenBSD
 * Project.
d43 1
a43 1
/* The complexity of topological sorting is O(e), where e is the 
d46 2
a47 2
 * an appropriate data structure.  This program uses open double hashing 
 * for that purpose.  See Knuth for the expected complexity of double 
d54 1
a54 1
 * number can be as high as O(2^e).  Usually, the number of free paths is 
d69 2
a70 2
 * goes further, breaking cycles through the use of simple heuristics.  
 * Each cycle break checks the whole set of nodes, hence if c cycles break 
d79 1
a79 1
 * which cycle to break, those heuristics locally result in the smallest 
d104 2
a105 2
	unsigned int refs;	/* Number of arcs left, coming into this node . 
				 * Note that nodes with a null count can't 
d131 1
a131 1
static unsigned int read_pairs(FILE *, struct ohash *, int, 
d142 1
a142 1
static unsigned int read_hints(FILE *, struct ohash *, int, 
d166 1
a166 1
static struct ohash_info node_info = { 
d174 1
a174 1
 *** Memory handling. 
d211 1
a211 1
/*** 
d233 1
a233 1
static void 
d277 1
a277 1
static void 
d293 1
a293 1
static void 
d311 1
a311 1
read_pairs(FILE *f, struct ohash *h, int reverse, const char *name, 
d329 1
a329 1
			while (isspace(*str) && str < sentinel) 
d345 1
a345 1
					if (reverse) 
d347 1
a347 1
					else 
d363 1
a363 1
read_hints(FILE *f, struct ohash *h, int quiet, const char *name, 
d377 1
a377 1
			while (isspace(*str) && str < sentinel) 
d399 1
a399 1
 *** Standard heap handling routines.  
d402 1
a402 1
static void 
d419 1
a419 1
static void 
d457 1
a457 1
static void 
d475 1
a475 1
 * Iterate until no nodes are left. 
d491 1
a491 1
		for (n = ohash_first(hash, &i); n != NULL; 
d516 1
a516 1
		for (n = ohash_first(hash, &i); n != NULL; 
d546 1
a546 1
		if (n->refs == 0) 
d558 2
a559 2
	unsigned int 	best; 
	struct node 	*u; 
d580 1
a580 1
static struct node * 
d607 1
a607 1
/* Explore the nodes reachable from i to find a cycle, store it in c.  
d609 1
a609 1
static struct node * 
d621 1
a621 1
		if (n->traverse) 
d648 1
a648 1
			if (n == NULL) 
d682 1
a682 1
static unsigned int 
d696 1
a696 1
		if (n->traverse) 
d708 1
a708 1
			/* Optimisation: if go->mark < min, we already 
d776 1
a776 1
		for (i = 0; i < h->entries; i++) 
d810 1
a810 1
int 
d814 1
a814 1
	int 		reverse_flag, quiet_flag, long_flag, 
d820 1
a820 1
	reverse_flag = quiet_flag = long_flag = 
d920 1
a920 1
			     * rely on refs == 0 to recognize live nodes.  
d923 2
a924 2
			    for (l = n->arcs; l != NULL; l = l->next) 
				    if (l->node->refs != 0 && 
d942 1
a942 1
				    if (hints_flag) 
d944 1
a944 1
				    else 
d970 1
a970 1
	    if (warn_flag) 
@


1.13
log
@Manual cleanup of remaining userland __P use (excluding packages maintained outside the tree)
@
text
@d1 1
a1 1
/* $OpenBSD: tsort.c,v 1.12 2002/02/16 21:27:55 millert Exp $ */
d182 1
a182 2
emem(p)
	void 		*p;
d191 1
a191 3
hash_alloc(s, u)
	size_t s;
	void *u		UNUSED;
d197 1
a197 4
hash_free(p, s, u)
	void *p;
	size_t s	UNUSED;
	void *u		UNUSED;
d203 1
a203 3
entry_alloc(s, u)
	size_t s;
	void *u		UNUSED;
d209 1
a209 2
emalloc(s)
	size_t s;
d222 1
a222 3
new_node(start, end)
	const char 	*start;
	const char 	*end;
d238 1
a238 2
nodes_init(h)
	struct ohash 	*h;
d244 1
a244 4
node_lookup(h, start, end)
	struct ohash 	*h;
	const char 	*start;
	const char 	*end;
d259 1
a259 2
dump_node(n)
    struct node 	*n;
d273 1
a273 2
dump_array(a)
	struct array	*a;
d282 1
a282 2
dump_hash(h)
	struct ohash 	*h;
d298 1
a298 2
insert_arc(a, b)
	struct node 	*a, *b;
d315 2
a316 7
read_pairs(f, h, reverse, name, order, hint)
	FILE 		*f;
	struct ohash 	*h;
	int 		reverse;
	const char 	*name;
	unsigned int	order;
	int		hint;
d367 2
a368 6
read_hints(f, h, quiet, name, order)
	FILE 		*f;
	struct ohash 	*h;
	int 		quiet;
	const char 	*name;
	unsigned int	order;
d407 1
a407 3
heap_down(h, i)
	struct array 	*h;
	unsigned int 	i;
d424 1
a424 3
heapify(h, verbose)
	struct array 	*h;
	int		verbose;
d438 1
a438 2
dequeue(h)
	struct array 	*h;
d462 1
a462 3
enqueue(h, n)
	struct array 	*h;
	struct node 	*n;
d482 1
a482 2
make_transparent(hash)
	struct ohash	*hash;
d538 1
a538 4
split_nodes(hash, heap, remaining)
	struct ohash 	*hash;
	struct array 	*heap;
	struct array	*remaining;
d559 1
a559 2
find_good_cycle_break(h)
	struct array 	*h;
d585 1
a585 2
find_smallest_node(h)
	struct array 	*h;
d614 1
a614 3
find_cycle_from(i, c)
	struct node 	*i;
	struct array 	*c;
d662 1
a662 3
find_predecessor(a, n)
	struct array *a;
	struct node *n;
d687 1
a687 4
traverse_node(n, o, c)
	struct node 	*n;
	unsigned int 	o;
	struct array 	*c;
d752 1
a752 2
print_cycle(c)
	struct array 	*c;
d765 1
a765 3
find_longest_cycle(h, c)
	struct array 	*h;
	struct array 	*c;
d815 1
a815 3
main(argc, argv)
    int 		argc;
    char 		*argv[];
@


1.12
log
@Part one of userland __P removal.  Done with a simple regexp with some minor hand editing to make comments line up correctly.  Another pass is forthcoming that handles the cases that could not be done automatically.
@
text
@d1 1
a1 1
/* $OpenBSD: tsort.c,v 1.11 2002/02/14 12:11:49 espie Exp $ */
d135 2
a136 2
static unsigned int read_pairs __P((FILE *, struct ohash *, int, 
    const char *, unsigned int, int));
d146 2
a147 2
static unsigned int read_hints __P((FILE *, struct ohash *, int, 
    const char *, unsigned int));
@


1.11
log
@lclint says this is an unsigned variable... and it's right !
@
text
@d1 1
a1 1
/* $OpenBSD: tsort.c,v 1.10 2001/07/14 14:18:50 espie Exp $ */
d130 4
a133 4
static void nodes_init __P((struct ohash *));
static struct node *node_lookup __P((struct ohash *, const char *, const char *));
static void usage __P((void));
static struct node *new_node __P((const char *, const char *));
d137 3
a139 3
static void split_nodes __P((struct ohash *, struct array *, struct array *));
static void make_transparent __P((struct ohash *));
static void insert_arc __P((struct node *, struct node *));
d142 3
a144 3
static void dump_node __P((struct node *));
static void dump_array __P((struct array *));
static void dump_hash __P((struct ohash *));
d148 12
a159 12
static struct node *find_smallest_node __P((struct array *));
static struct node *find_good_cycle_break __P((struct array *));
static void print_cycle __P((struct array *));
static struct node *find_cycle_from __P((struct node *, struct array *));
static struct node *find_predecessor __P((struct array *, struct node *));
static unsigned int traverse_node __P((struct node *, unsigned int, struct array *));
static struct node *find_longest_cycle __P((struct array *, struct array *));

static void heap_down __P((struct array *, unsigned int));
static void heapify __P((struct array *, int));
static struct node *dequeue __P((struct array *));
static void enqueue __P((struct array *, struct node *));
d164 5
a168 5
static void *hash_alloc __P((size_t, void *));
static void hash_free __P((void *, size_t, void *));
static void* entry_alloc __P((size_t, void *));
static void *emalloc __P((size_t));
static void *emem __P((void *));
d174 1
a174 1
int main __P((int, char *[]));
@


1.10
log
@Fix cycle detection.
Under some circumstances, trying to find a cycle starting with a given
point can be very time-consuming (probably exponential, as an
implementation of an NP-complete problem), so we lower our expectations,
and just report the first cycle we find, irregardless of which point it
cuts, which is guaranteed to be much faster (quadratic behavior at the
worst--because we won't explore more than a tree out of the graph).

Always find that cycle, even if -q is specified, so that -q is only
`quiet', e.g., does not change the reported result.

Based on a testcase reported by Dragos Ruiu,  okay millert@@
@
text
@d1 1
a1 1
/* $OpenBSD: tsort.c,v 1.9 2001/05/01 20:36:57 espie Exp $ */
d746 1
a746 1
			printf("%s(%d) ", n->k, n->mark);
@


1.9
log
@Revert stupid buggy optimisation.
Another Murphy's law: complicated code always works right the first
time. Stupid dumb details, on the other hand.

Of course we can't share both arrays, as we don't know how they will
grow, duh !
@
text
@d1 1
a1 1
/* $OpenBSD: tsort.c,v 1.8 2001/04/30 21:03:55 espie Exp $ */
d151 1
a151 1
static int find_cycle_with __P((struct node *, struct array *));
d652 4
a655 4
/* Explore the nodes reachable from i to find a cycle containing it, store
 * it in c.  This may fail.  */
static int 
find_cycle_with(i, c)
d679 4
a682 5
				if (go == i) {
					c->entries = 0;
					for (; n != NULL; n = n->from) 
						c->t[c->entries++] = n;
					return 1;
d684 4
d696 1
a696 1
				return 0;
d997 2
d1003 3
a1005 4
				    if (!quiet_flag) {
					    while (!find_cycle_with(n, &aux))
						    n = find_predecessor(&remaining, n);
				    }
@


1.8
log
@Better hints handling (used for sorting package lists):

- nodes without a hint should be fully transparent.  The make_transparent
procedure is potentially slow, but in reality, it's very fast.
- don't automatically add an order to un-hinted nodes, so that they are
truely transparent.

Better memory allocation: split the hash of nodes into a single array
instead of duplicating the memory requirements.

Okay Todd.
@
text
@d1 1
a1 1
/* $OpenBSD: tsort.c,v 1.7 2001/04/18 17:57:28 espie Exp $ */
a581 1
	unsigned int total = ohash_entries(hash);
d584 1
d592 1
a592 1
			heap->t[total-1-remaining->entries++] = n;
a593 1
	remaining->t = heap->t + heap->entries;
@


1.7
log
@Fix `hinted' options: set initial order to maximal, so that any hint
will be first. Also, keep order around between hints file and reading
normal pairt, so that this option actually is useful.
@
text
@d1 1
a1 1
/* $OpenBSD: tsort.c,v 1.6 2001/04/07 14:17:38 espie Exp $ */
d66 6
d136 1
a136 1
    const char *, unsigned int));
d138 1
d281 1
a281 1
	printf("%s (%u): ", n->k, n->refs);
d284 1
a284 1
		printf("%s(%u) ", l->node->k, l->node->refs);
d300 1
a300 1
	struct hash 	*h;
d334 1
a334 1
read_pairs(f, h, reverse, name, order)
d340 1
d365 1
a365 1
				if (a->order == NO_ORDER)
d461 1
a461 1
		if (h->t[--i]->order == 0 && verbose)
d513 54
d582 1
a584 1
	remaining->t = emalloc(sizeof(struct node *) * ohash_entries(hash));
d592 1
a592 1
			remaining->t[remaining->entries++] = n;
d594 1
d873 1
a873 1
	order = 1;
d895 2
d899 1
a899 3
			    if (hints_flag == 1)
			    	usage();
			    hints_flag = 1;
d932 2
a933 1
		order = read_pairs(f, &pairs, reverse_flag, argv[1], order);
d938 2
a939 1
		order = read_pairs(stdin, &pairs, reverse_flag, "stdin", order);
d954 2
@


1.6
log
@Small changes, user-friendly:
- just warn if hints file holds duplicates. So what ? We sure can't use
uniq to remove those.
- on the other hand, warn in verbose mode if main file holds nodes that
are not in hints file.
Ok millert@@
@
text
@d1 1
a1 1
/* $OpenBSD: tsort.c,v 1.5 2001/03/26 22:53:33 espie Exp $ */
d99 2
d129 2
a130 1
static void read_pairs __P((FILE *, struct ohash *, int, const char *));
d139 2
a140 1
static void read_hints __P((FILE *, struct ohash *, int, const char *));
d235 1
a235 1
	n->order = 0;
d326 2
a327 2
static void
read_pairs(f, h, reverse, name)
d332 1
a337 1
	unsigned int	o;
a338 1
	o = 1;
d357 2
a358 2
				if (a->order == 0)
					a->order = o++;
d379 1
d382 2
a383 2
static void
read_hints(f, h, quiet, name)
d388 1
a391 3
	unsigned int 	i;

	i = 1;
d408 1
a408 1
			if (a->order != 0)
d413 2
a414 2
			else
				a->order = i++;
d418 1
d808 3
d828 2
a829 1
			    read_hints(f, &pairs, quiet_flag, optarg);
d869 1
a869 1
		read_pairs(f, &pairs, reverse_flag, argv[1]);
d874 1
a874 1
		read_pairs(stdin, &pairs, reverse_flag, "stdin");
@


1.5
log
@Replacement for original tsort.

The old code suffers from a few defects:
- it does not even implement the standard optimal topological sort
algorithm. It's much slower.
- its longest cycle computation is completely bogus.

This is clean-slate code, that does implement the actual standard optimal
topological sort, together with a correct graph traversal to find longest
cycles.

It does also feature a `stable tsort' mode, where it uses a heap to yield
the least disturbed permutation of input nodes that satisfies the ordering
constraints (in particular, try tsort -f).

Thanks to the nature of the problem, the actual output won't exactly match
the old one, but it does pass the regression suite (and it is a topological
sorter).

Ok millert@@
@
text
@d1 1
a1 1
/* $OpenBSD$ */
d136 1
a136 1
static void read_hints __P((FILE *, struct ohash *, const char *));
d146 1
a146 1
static void heapify __P((struct array *));
d379 1
a379 1
read_hints(f, h, name)
d382 1
d407 2
a408 1
				errx(EX_DATAERR, 
d443 1
a443 1
heapify(h)
d445 1
d449 5
a453 2
	for (i = h->entries; i != 0;)
		heap_down(h, --i);
d822 1
a822 1
			    read_hints(f, &pairs, optarg);
d886 1
a886 1
		    heapify(&aux);
@


1.4
log
@getopt(3) returns -1 when out of args, not EOF, whee!
@
text
@d1 3
a3 2
/*	$OpenBSD: tsort.c,v 1.3 1996/06/26 05:42:00 deraadt Exp $	*/
/*	$NetBSD: tsort.c,v 1.11 1996/01/17 20:37:53 mycroft Exp $	*/
d6 1
a6 5
 * Copyright (c) 1989, 1993, 1994
 *	The Regents of the University of California.  All rights reserved.
 *
 * This code is derived from software contributed to Berkeley by
 * Michael Rendell of Memorial University of Newfoundland.
d18 2
a19 5
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
d21 11
a31 11
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
a33 13
#ifndef lint
static char copyright[] =
"@@(#) Copyright (c) 1989, 1993, 1994\n\
	The Regents of the University of California.  All rights reserved.\n";
#endif /* not lint */

#ifndef lint
#if 0
static char sccsid[] = "@@(#)tsort.c	8.3 (Berkeley) 5/4/95";
#endif
static char rcsid[] = "$OpenBSD: tsort.c,v 1.3 1996/06/26 05:42:00 deraadt Exp $";
#endif /* not lint */

d35 1
a35 1

a36 1
#include <db.h>
d38 3
a40 2
#include <errno.h>
#include <fcntl.h>
d44 1
d47 23
a69 4
/*
 *  Topological sort.  Input is a list of pairs of strings separated by
 *  white space (spaces, tabs, and/or newlines); strings are written to
 *  standard output in sorted order, one per line.
d71 4
a74 3
 *  usage:
 *     tsort [-l] [inputfile]
 *  If no input file is specified, standard input is read.
d76 3
a78 5
 *  Should be compatable with AT&T tsort HOWEVER the output is not identical
 *  (i.e. for most graphs there is more than one sorted order, and this tsort
 *  usually generates a different one then the AT&T tsort).  Also, cycle
 *  reporting seems to be more accurate in this version (the AT&T tsort
 *  sometimes says a node is in a cycle when it isn't).
d80 3
a82 1
 *  Michael Rendell, michael@@stretch.cs.mun.ca - Feb 26, '90
d84 29
a112 16
#define	HASHSIZE	53		/* doesn't need to be big */
#define	NF_MARK		0x1		/* marker for cycle detection */
#define	NF_ACYCLIC	0x2		/* this node is cycle free */
#define	NF_NODEST	0x4		/* Unreachable */

typedef struct node_str NODE;

struct node_str {
	NODE **n_prevp;			/* pointer to previous node's n_next */
	NODE *n_next;			/* next node in graph */
	NODE **n_arcs;			/* array of arcs to other nodes */
	int n_narcs;			/* number of arcs in n_arcs[] */
	int n_arcsize;			/* size of n_arcs[] array */
	int n_refcnt;			/* # of arcs pointing to this node */
	int n_flags;			/* NF_* */
	char n_name[1];			/* name of this node */
d115 35
a149 16
typedef struct _buf {
	char *b_buf;
	int b_bsize;
} BUF;

DB *db;
NODE *graph, **cycle_buf, **longest_cycle;
int debug, longest, quiet;

void	 add_arc __P((char *, char *));
int	 find_cycle __P((NODE *, NODE *, int, int));
NODE	*get_node __P((char *));
void	*grow_buf __P((void *, int));
void	 remove_node __P((NODE *));
void	 tsort __P((void));
void	 usage __P((void));
d151 57
a207 4
int
main(argc, argv)
	int argc;
	char *argv[];
d209 2
a210 23
	register BUF *b;
	register int c, n;
	FILE *fp;
	int bsize, ch, nused;
	BUF bufs[2];

	while ((ch = getopt(argc, argv, "dlq")) != -1)
		switch (ch) {
		case 'd':
			debug = 1;
			break;
		case 'l':
			longest = 1;
			break;
		case 'q':
			quiet = 1;
			break;
		case '?':
		default:
			usage();
		}
	argc -= optind;
	argv += optind;
d212 13
a224 11
	switch (argc) {
	case 0:
		fp = stdin;
		break;
	case 1:
		if ((fp = fopen(*argv, "r")) == NULL)
			err(1, "%s", *argv);
		break;
	default:
		usage();
	}
d226 9
a234 2
	for (b = bufs, n = 2; --n >= 0; b++)
		b->b_buf = grow_buf(NULL, b->b_bsize = 1024);
a235 6
	/* parse input and build the graph */
	for (n = 0, c = getc(fp);;) {
		while (c != EOF && isspace(c))
			c = getc(fp);
		if (c == EOF)
			break;
d237 5
a241 34
		nused = 0;
		b = &bufs[n];
		bsize = b->b_bsize;
		do {
			b->b_buf[nused++] = c;
			if (nused == bsize)
				b->b_buf = grow_buf(b->b_buf, bsize *= 2);
			c = getc(fp);
		} while (c != EOF && !isspace(c));

		b->b_buf[nused] = '\0';
		b->b_bsize = bsize;
		if (n)
			add_arc(bufs[0].b_buf, bufs[1].b_buf);
		n = !n;
	}
	(void)fclose(fp);
	if (n)
		errx(1, "odd data count");

	/* do the sort */
	tsort();
	exit(0);
}

/* double the size of oldbuf and return a pointer to the new buffer. */
void *
grow_buf(bp, size)
	void *bp;
	int size;
{
	if ((bp = realloc(bp, (u_int)size)) == NULL)
		err(1, NULL);
	return (bp);
d244 5
a248 7
/*
 * add an arc from node s1 to node s2 in the graph.  If s1 or s2 are not in
 * the graph, then add them.
 */
void
add_arc(s1, s2)
	char *s1, *s2;
d250 2
a251 3
	register NODE *n1;
	NODE *n2;
	int bsize, i;
d253 1
a253 1
	n1 = get_node(s1);
d255 14
a268 1
	if (!strcmp(s1, s2))
d270 6
d277 5
a281 1
	n2 = get_node(s2);
d283 30
a312 5
	/*
	 * Check if this arc is already here.
	 */
	for (i = 0; i < n1->n_narcs; i++)
		if (n1->n_arcs[i] == n2)
d314 7
a320 25
	/*
	 * Add it.
	 */
	if (n1->n_narcs == n1->n_arcsize) {
		if (!n1->n_arcsize)
			n1->n_arcsize = 10;
		bsize = n1->n_arcsize * sizeof(*n1->n_arcs) * 2;
		n1->n_arcs = grow_buf(n1->n_arcs, bsize);
		n1->n_arcsize = bsize / sizeof(*n1->n_arcs);
	}
	n1->n_arcs[n1->n_narcs++] = n2;
	++n2->n_refcnt;
}

/* Find a node in the graph (insert if not found) and return a pointer to it. */
NODE *
get_node(name)
	char *name;
{
	DBT data, key;
	NODE *n;

	if (db == NULL &&
	    (db = dbopen(NULL, O_RDWR, 0, DB_HASH, NULL)) == NULL)
		err(1, "db: %s", name);
d322 55
a376 2
	key.data = name;
	key.size = strlen(name) + 1;
d378 59
a436 9
	switch ((*db->get)(db, &key, &data, 0)) {
	case 0:
		bcopy(data.data, &n, sizeof(n));
		return (n);
	case 1:
		break;
	default:
	case -1:
		err(1, "db: %s", name);
d438 7
d446 5
a450 2
	if ((n = malloc(sizeof(NODE) + key.size)) == NULL)
		err(1, NULL);
d452 16
a467 19
	n->n_narcs = 0;
	n->n_arcsize = 0;
	n->n_arcs = NULL;
	n->n_refcnt = 0;
	n->n_flags = 0;
	bcopy(name, n->n_name, key.size);

	/* Add to linked list. */
	if ((n->n_next = graph) != NULL)
		graph->n_prevp = &n->n_next;
	n->n_prevp = &graph;
	graph = n;

	/* Add to hash table. */
	data.data = &n;
	data.size = sizeof(n);
	if ((*db->put)(db, &key, &data, 0))
		err(1, "db: %s", name);
	return (n);
d469 15
d485 10
d496 11
a506 5
/*
 * Clear the NODEST flag from all nodes.
 */
void
clear_cycle()
a507 1
	NODE *n;
d509 14
a522 2
	for (n = graph; n != NULL; n = n->n_next)
		n->n_flags &= ~NF_NODEST;
d525 88
a612 19
/* do topological sort on graph */
void
tsort()
{
	register NODE *n, *next;
	register int cnt, i;

	while (graph != NULL) {
		/*
		 * Keep getting rid of simple cases until there are none left,
		 * if there are any nodes still in the graph, then there is
		 * a cycle in it.
		 */
		do {
			for (cnt = 0, n = graph; n != NULL; n = next) {
				next = n->n_next;
				if (n->n_refcnt == 0) {
					remove_node(n);
					++cnt;
d614 3
d618 8
a625 1
		} while (graph != NULL && cnt);
d627 12
a638 2
		if (graph == NULL)
			break;
d640 7
a646 12
		if (!cycle_buf) {
			/*
			 * Allocate space for two cycle logs - one to be used
			 * as scratch space, the other to save the longest
			 * cycle.
			 */
			for (cnt = 0, n = graph; n != NULL; n = n->n_next)
				++cnt;
			cycle_buf = malloc((u_int)sizeof(NODE *) * cnt);
			longest_cycle = malloc((u_int)sizeof(NODE *) * cnt);
			if (cycle_buf == NULL || longest_cycle == NULL)
				err(1, NULL);
d648 63
a710 16
		for (n = graph; n != NULL; n = n->n_next)
			if (!(n->n_flags & NF_ACYCLIC))
				if (cnt = find_cycle(n, n, 0, 0)) {
					if (!quiet) {
						warnx("cycle in data");
						for (i = 0; i < cnt; i++)
							warnx("%s", 
							    longest_cycle[i]->n_name);
					}
					remove_node(n);
					clear_cycle();
					break;
				} else {
					/* to avoid further checks */
					n->n_flags  |= NF_ACYCLIC;
					clear_cycle();
d712 1
d714 8
a721 2
		if (n == NULL)
			errx(1, "internal error -- could not find cycle");
d725 12
a736 15
/* print node and remove from graph (does not actually free node) */
void
remove_node(n)
	register NODE *n;
{
	register NODE **np;
	register int i;

	(void)printf("%s\n", n->n_name);
	for (np = n->n_arcs, i = n->n_narcs; --i >= 0; np++)
		--(*np)->n_refcnt;
	n->n_narcs = 0;
	*n->n_prevp = n->n_next;
	if (n->n_next)
		n->n_next->n_prevp = n->n_prevp;
d739 48
d788 2
a789 30
/* look for the longest? cycle from node from to node to. */
int
find_cycle(from, to, longest_len, depth)
	NODE *from, *to;
	int depth, longest_len;
{
	register NODE **np;
	register int i, len;

	/*
	 * avoid infinite loops and ignore portions of the graph known
	 * to be acyclic
	 */
	if (from->n_flags & (NF_NODEST|NF_MARK|NF_ACYCLIC))
		return (0);
	from->n_flags |= NF_MARK;

	for (np = from->n_arcs, i = from->n_narcs; --i >= 0; np++) {
		cycle_buf[depth] = *np;
		if (*np == to) {
			if (depth + 1 > longest_len) {
				longest_len = depth + 1;
				(void)memcpy((char *)longest_cycle,
				    (char *)cycle_buf,
				    longest_len * sizeof(NODE *));
			}
		} else {
			if ((*np)->n_flags & (NF_MARK|NF_ACYCLIC|NF_NODEST))
				continue;
			len = find_cycle(*np, to, longest_len, depth + 1);
d791 53
a843 3
			if (debug)
				(void)printf("%*s %s->%s %d\n", depth, "",
				    from->n_name, to->n_name, len);
d845 3
a847 2
			if (len == 0)
				(*np)->n_flags |= NF_NODEST;
d849 17
a865 2
			if (len > longest_len)
				longest_len = len;
d867 81
a947 3
			if (len > 0 && !longest)
				break;
		}
a948 2
	from->n_flags &= ~NF_MARK;
	return (longest_len);
d951 4
a954 1
void
d957 2
a958 2
	(void)fprintf(stderr, "usage: tsort [-lq] [file]\n");
	exit(1);
@


1.3
log
@rcsid
@
text
@d1 1
a1 1
/*	$OpenBSD: tsort.c,v 1.11 1996/01/17 20:37:53 mycroft Exp $	*/
d50 1
a50 1
static char rcsid[] = "$OpenBSD: tsort.c,v 1.11 1996/01/17 20:37:53 mycroft Exp $";
d128 1
a128 1
	while ((ch = getopt(argc, argv, "dlq")) != EOF)
@


1.2
log
@add -q option for silence; from mouse@@collatz.mcrcim.mcgill.edu;
netbsd pr#1204
@
text
@d1 1
d50 1
a50 1
static char rcsid[] = "$NetBSD: tsort.c,v 1.11 1996/01/17 20:37:53 mycroft Exp $";
@


1.1
log
@Initial revision
@
text
@d1 1
a1 1
/*	$NetBSD: tsort.c,v 1.10 1995/08/31 22:06:22 jtc Exp $	*/
d49 1
a49 1
static char rcsid[] = "$NetBSD: tsort.c,v 1.10 1995/08/31 22:06:22 jtc Exp $";
d106 1
a106 1
int debug, longest;
d127 1
a127 1
	while ((ch = getopt(argc, argv, "dl")) != EOF)
d135 3
d347 6
a352 4
					warnx("cycle in data");
					for (i = 0; i < cnt; i++)
						warnx("%s", 
						    longest_cycle[i]->n_name);
d437 1
a437 1
	(void)fprintf(stderr, "usage: tsort [-l] [file]\n");
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@
