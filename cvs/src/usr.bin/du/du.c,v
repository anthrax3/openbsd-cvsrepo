head	1.32;
access;
symbols
	OPENBSD_6_1:1.32.0.2
	OPENBSD_6_1_BASE:1.32
	OPENBSD_6_0:1.31.0.4
	OPENBSD_6_0_BASE:1.31
	OPENBSD_5_9:1.31.0.2
	OPENBSD_5_9_BASE:1.31
	OPENBSD_5_8:1.30.0.4
	OPENBSD_5_8_BASE:1.30
	OPENBSD_5_7:1.29.0.2
	OPENBSD_5_7_BASE:1.29
	OPENBSD_5_6:1.25.0.4
	OPENBSD_5_6_BASE:1.25
	OPENBSD_5_5:1.24.0.4
	OPENBSD_5_5_BASE:1.24
	OPENBSD_5_4:1.23.0.10
	OPENBSD_5_4_BASE:1.23
	OPENBSD_5_3:1.23.0.8
	OPENBSD_5_3_BASE:1.23
	OPENBSD_5_2:1.23.0.6
	OPENBSD_5_2_BASE:1.23
	OPENBSD_5_1_BASE:1.23
	OPENBSD_5_1:1.23.0.4
	OPENBSD_5_0:1.23.0.2
	OPENBSD_5_0_BASE:1.23
	OPENBSD_4_9:1.22.0.6
	OPENBSD_4_9_BASE:1.22
	OPENBSD_4_8:1.22.0.4
	OPENBSD_4_8_BASE:1.22
	OPENBSD_4_7:1.22.0.2
	OPENBSD_4_7_BASE:1.22
	OPENBSD_4_6:1.20.0.4
	OPENBSD_4_6_BASE:1.20
	OPENBSD_4_5:1.19.0.14
	OPENBSD_4_5_BASE:1.19
	OPENBSD_4_4:1.19.0.12
	OPENBSD_4_4_BASE:1.19
	OPENBSD_4_3:1.19.0.10
	OPENBSD_4_3_BASE:1.19
	OPENBSD_4_2:1.19.0.8
	OPENBSD_4_2_BASE:1.19
	OPENBSD_4_1:1.19.0.6
	OPENBSD_4_1_BASE:1.19
	OPENBSD_4_0:1.19.0.4
	OPENBSD_4_0_BASE:1.19
	OPENBSD_3_9:1.19.0.2
	OPENBSD_3_9_BASE:1.19
	OPENBSD_3_8:1.18.0.2
	OPENBSD_3_8_BASE:1.18
	OPENBSD_3_7:1.17.0.4
	OPENBSD_3_7_BASE:1.17
	OPENBSD_3_6:1.17.0.2
	OPENBSD_3_6_BASE:1.17
	OPENBSD_3_5:1.14.0.4
	OPENBSD_3_5_BASE:1.14
	OPENBSD_3_4:1.14.0.2
	OPENBSD_3_4_BASE:1.14
	OPENBSD_3_3:1.11.0.6
	OPENBSD_3_3_BASE:1.11
	OPENBSD_3_2:1.11.0.4
	OPENBSD_3_2_BASE:1.11
	OPENBSD_3_1:1.11.0.2
	OPENBSD_3_1_BASE:1.11
	OPENBSD_3_0:1.10.0.2
	OPENBSD_3_0_BASE:1.10
	OPENBSD_2_9_BASE:1.7
	OPENBSD_2_9:1.7.0.2
	OPENBSD_2_8:1.6.0.4
	OPENBSD_2_8_BASE:1.6
	OPENBSD_2_7:1.6.0.2
	OPENBSD_2_7_BASE:1.6
	OPENBSD_2_6:1.5.0.8
	OPENBSD_2_6_BASE:1.5
	OPENBSD_2_5:1.5.0.6
	OPENBSD_2_5_BASE:1.5
	OPENBSD_2_4:1.5.0.4
	OPENBSD_2_4_BASE:1.5
	OPENBSD_2_3:1.5.0.2
	OPENBSD_2_3_BASE:1.5
	OPENBSD_2_2:1.4.0.4
	OPENBSD_2_2_BASE:1.4
	OPENBSD_2_1:1.4.0.2
	OPENBSD_2_1_BASE:1.4
	OPENBSD_2_0:1.2.0.2
	OPENBSD_2_0_BASE:1.2
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.32
date	2016.08.24.03.13.45;	author guenther;	state Exp;
branches;
next	1.31;
commitid	AyeFIn869BnF7M99;

1.31
date	2015.10.10.05.32.52;	author deraadt;	state Exp;
branches;
next	1.30;
commitid	Qlsj5nAFJHY3kzFr;

1.30
date	2015.06.25.02.04.08;	author uebayasi;	state Exp;
branches;
next	1.29;
commitid	lJr85pywqGCq0vnE;

1.29
date	2014.10.20.22.13.11;	author schwarze;	state Exp;
branches;
next	1.28;
commitid	0sCzikjmQ4lzNoPJ;

1.28
date	2014.10.19.18.24.58;	author jmc;	state Exp;
branches;
next	1.27;
commitid	uYmUHA3yPKNPY2pV;

1.27
date	2014.10.19.14.27.41;	author schwarze;	state Exp;
branches;
next	1.26;
commitid	z1xbNh3mcDUc2zJd;

1.26
date	2014.10.17.14.46.54;	author schwarze;	state Exp;
branches;
next	1.25;
commitid	JG0qBc5JwEoGeCzW;

1.25
date	2014.05.20.01.25.23;	author guenther;	state Exp;
branches;
next	1.24;

1.24
date	2013.11.13.21.20.01;	author deraadt;	state Exp;
branches;
next	1.23;

1.23
date	2011.04.27.07.52.11;	author sobrado;	state Exp;
branches;
next	1.22;

1.22
date	2009.10.27.23.59.37;	author deraadt;	state Exp;
branches;
next	1.21;

1.21
date	2009.08.27.11.29.30;	author millert;	state Exp;
branches;
next	1.20;

1.20
date	2009.06.03.15.15.16;	author millert;	state Exp;
branches;
next	1.19;

1.19
date	2006.01.25.06.20.03;	author tedu;	state Exp;
branches;
next	1.18;

1.18
date	2005.04.17.12.27.23;	author jmc;	state Exp;
branches;
next	1.17;

1.17
date	2004.06.21.09.44.31;	author otto;	state Exp;
branches;
next	1.16;

1.16
date	2004.06.14.18.21.31;	author otto;	state Exp;
branches;
next	1.15;

1.15
date	2004.06.02.14.58.46;	author tom;	state Exp;
branches;
next	1.14;

1.14
date	2003.07.02.21.04.09;	author deraadt;	state Exp;
branches;
next	1.13;

1.13
date	2003.06.10.22.20.46;	author deraadt;	state Exp;
branches;
next	1.12;

1.12
date	2003.06.03.02.56.07;	author millert;	state Exp;
branches;
next	1.11;

1.11
date	2002.02.16.21.27.45;	author millert;	state Exp;
branches;
next	1.10;

1.10
date	2001.07.30.00.53.38;	author deraadt;	state Exp;
branches;
next	1.9;

1.9
date	2001.07.12.05.17.00;	author deraadt;	state Exp;
branches;
next	1.8;

1.8
date	2001.05.02.23.26.53;	author pjanzen;	state Exp;
branches;
next	1.7;

1.7
date	2001.02.23.19.14.21;	author pjanzen;	state Exp;
branches;
next	1.6;

1.6
date	2000.04.16.04.21.34;	author ericj;	state Exp;
branches;
next	1.5;

1.5
date	98.02.16.09.23.06;	author deraadt;	state Exp;
branches;
next	1.4;

1.4
date	97.01.15.23.42.25;	author millert;	state Exp;
branches;
next	1.3;

1.3
date	96.10.18.18.16.07;	author millert;	state Exp;
branches;
next	1.2;

1.2
date	96.06.26.05.32.38;	author deraadt;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.45.05;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.45.05;	author deraadt;	state Exp;
branches;
next	;


desc
@@


1.32
log
@Convert quad_t to int64_t and %q to %ll
Convert bzero() to memset() and bcopy() to memcpy()

ok natano@@ millert@@
@
text
@/*	$OpenBSD: du.c,v 1.31 2015/10/10 05:32:52 deraadt Exp $	*/
/*	$NetBSD: du.c,v 1.11 1996/10/18 07:20:35 thorpej Exp $	*/

/*
 * Copyright (c) 1989, 1993, 1994
 *	The Regents of the University of California.  All rights reserved.
 *
 * This code is derived from software contributed to Berkeley by
 * Chris Newcomb.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */

#include <sys/types.h>
#include <sys/stat.h>

#include <dirent.h>
#include <err.h>
#include <errno.h>
#include <fts.h>
#include <limits.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <sys/tree.h>
#include <unistd.h>
#include <util.h>


int	 linkchk(FTSENT *);
void	 prtout(int64_t, char *, int);
void	 usage(void);

int
main(int argc, char *argv[])
{
	FTS *fts;
	FTSENT *p;
	long blocksize;
	int64_t totalblocks;
	int ftsoptions, listfiles, maxdepth;
	int Hflag, Lflag, cflag, hflag, kflag;
	int ch, notused, rval;
	char **save;
	const char *errstr;

	if (pledge("stdio rpath", NULL) == -1)
		err(1, "pledge");

	save = argv;
	Hflag = Lflag = cflag = hflag = kflag = listfiles = 0;
	totalblocks = 0;
	ftsoptions = FTS_PHYSICAL;
	maxdepth = -1;
	while ((ch = getopt(argc, argv, "HLPacd:hkrsx")) != -1)
		switch (ch) {
		case 'H':
			Hflag = 1;
			Lflag = 0;
			break;
		case 'L':
			Lflag = 1;
			Hflag = 0;
			break;
		case 'P':
			Hflag = Lflag = 0;
			break;
		case 'a':
			listfiles = 1;
			break;
		case 'c':
			cflag = 1;
			break;
		case 'd':
			maxdepth = strtonum(optarg, 0, INT_MAX, &errstr);
			if (errstr) {
				warnx("max depth %s: %s", optarg, errstr);
				usage();
			}
			break;
		case 'h':
			hflag = 1;
			kflag = 0;
			break;
		case 'k':
			kflag = 1;
			hflag = 0;
			break;
		case 's':
			maxdepth = 0;
			break;
		case 'r':
			break;
		case 'x':
			ftsoptions |= FTS_XDEV;
			break;
		case '?':
		default:
			usage();
		}
	argc -= optind;
	argv += optind;

	/*
	 * XXX
	 * Because of the way that fts(3) works, logical walks will not count
	 * the blocks actually used by symbolic links.  We rationalize this by
	 * noting that users computing logical sizes are likely to do logical
	 * copies, so not counting the links is correct.  The real reason is
	 * that we'd have to re-implement the kernel's symbolic link traversing
	 * algorithm to get this right.  If, for example, you have relative
	 * symbolic links referencing other relative symbolic links, it gets
	 * very nasty, very fast.  The bottom line is that it's documented in
	 * the man page, so it's a feature.
	 */
	if (Hflag)
		ftsoptions |= FTS_COMFOLLOW;
	if (Lflag) {
		ftsoptions &= ~FTS_PHYSICAL;
		ftsoptions |= FTS_LOGICAL;
	}

	if (maxdepth == -1)
		maxdepth = INT_MAX;

	if (!*argv) {
		argv = save;
		argv[0] = ".";
		argv[1] = NULL;
	}

	if (hflag)
		blocksize = 512;
	else if (kflag)
		blocksize = 1024;
	else
		(void)getbsize(&notused, &blocksize);
	blocksize /= 512;

	if ((fts = fts_open(argv, ftsoptions, NULL)) == NULL)
		err(1, "fts_open");

	for (rval = 0; (p = fts_read(fts)) != NULL;)
		switch (p->fts_info) {
		case FTS_D:			/* Ignore. */
			break;
		case FTS_DP:
			p->fts_parent->fts_number += 
			    p->fts_number += p->fts_statp->st_blocks;
			if (cflag)
				totalblocks += p->fts_statp->st_blocks;
			/*
			 * If listing each directory, or not listing files
			 * or directories and this is post-order of the
			 * root of a traversal, display the total.
			 */
			if (p->fts_level <= maxdepth)
				prtout(howmany(p->fts_number,
				    (unsigned long)blocksize), p->fts_path,
				    hflag);
			break;
		case FTS_DC:			/* Ignore. */
			break;
		case FTS_DNR:			/* Warn, continue. */
		case FTS_ERR:
		case FTS_NS:
			warnc(p->fts_errno, "%s", p->fts_path);
			rval = 1;
			break;
		default:
			if (p->fts_statp->st_nlink > 1 && linkchk(p))
				break;
			/*
			 * If listing each file, or a non-directory file was
			 * the root of a traversal, display the total.
			 */
			if ((listfiles && p->fts_level <= maxdepth) ||
			    p->fts_level == FTS_ROOTLEVEL)
				prtout(howmany(p->fts_statp->st_blocks,
				    blocksize), p->fts_path, hflag);
			p->fts_parent->fts_number += p->fts_statp->st_blocks;
			if (cflag)
				totalblocks += p->fts_statp->st_blocks;
		}
	if (errno)
		err(1, "fts_read");
	if (cflag) {
		prtout(howmany(totalblocks, blocksize), "total", hflag);
	}
	fts_close(fts);
	exit(rval);
}


struct links_entry {
	RB_ENTRY(links_entry) entry;
	struct links_entry *fnext;
	int	 links;
	dev_t	 dev;
	ino_t	 ino;
};

static int
links_cmp(struct links_entry *e1, struct links_entry *e2)
{
	if (e1->dev == e2->dev) {
		if (e1->ino == e2->ino)
			return (0);
		else
			return (e1->ino < e2->ino ? -1 : 1);
	}
	else
		return (e1->dev < e2->dev ? -1 : 1);
}

RB_HEAD(ltree, links_entry) links = RB_INITIALIZER(&links);

RB_GENERATE_STATIC(ltree, links_entry, entry, links_cmp);


int
linkchk(FTSENT *p)
{
	static struct links_entry *free_list = NULL;
	static int stop_allocating = 0;
	struct links_entry ltmp, *le;
	struct stat *st;

	st = p->fts_statp;

	ltmp.ino = st->st_ino;
	ltmp.dev = st->st_dev;

	le = RB_FIND(ltree, &links, &ltmp);
	if (le != NULL) {
		/*
		 * Save memory by releasing an entry when we've seen
		 * all of it's links.
		 */
		if (--le->links <= 0) {
			RB_REMOVE(ltree, &links, le);
			/* Recycle this node through the free list */
			if (stop_allocating) {
				free(le);
			} else {
				le->fnext = free_list;
				free_list = le;
			}
		}
		return (1);
	}

	if (stop_allocating)
		return (0);

	/* Add this entry to the links cache. */
	if (free_list != NULL) {
		/* Pull a node from the free list if we can. */
		le = free_list;
		free_list = le->fnext;
	} else
		/* Malloc one if we have to. */
		le = malloc(sizeof(struct links_entry));

	if (le == NULL) {
		stop_allocating = 1;
		warnx("No more memory for tracking hard links");
		return (0);
	}

	le->dev = st->st_dev;
	le->ino = st->st_ino;
	le->links = st->st_nlink - 1;
	le->fnext = NULL;

	RB_INSERT(ltree, &links, le);

	return (0);
}

void
prtout(int64_t size, char *path, int hflag)
{
	if (!hflag)
		(void)printf("%lld\t%s\n", size, path);
	else {
		char buf[FMT_SCALED_STRSIZE];

		if (fmt_scaled(size * 512, buf) == 0)
			(void)printf("%s\t%s\n", buf, path);
		else
			(void)printf("%lld\t%s\n", size, path);
	}
}

void
usage(void)
{

	(void)fprintf(stderr,
	    "usage: du [-achkrsx] [-H | -L | -P] [-d depth] [file ...]\n");
	exit(1);
}
@


1.31
log
@pledge to only use "stdio rpath"; ok doug
@
text
@d1 1
a1 1
/*	$OpenBSD: du.c,v 1.30 2015/06/25 02:04:08 uebayasi Exp $	*/
d53 1
a53 1
void	 prtout(quad_t, char *, int);
d62 1
a62 1
	quad_t totalblocks;
d180 1
a180 1
				prtout((quad_t)howmany(p->fts_number,
d210 1
a210 1
		prtout((quad_t)howmany(totalblocks, blocksize), "total", hflag);
d304 1
a304 1
prtout(quad_t size, char *path, int hflag)
d307 1
a307 1
		(void)printf("%lld\t%s\n", (long long)size, path);
d314 1
a314 1
			(void)printf("%lld\t%s\n", (long long)size, path);
@


1.30
log
@Put fts_close() where missing.

Not bugs in short-lived commands that call exit() -> _exit() immediately,
but for idempotency.

Originally found in ls(1) by Valgrind.  Changes for other commands are
from deraadt@@.  Reviewed by me, tested in snapshots.

OK deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d68 3
@


1.29
log
@fix a regression that i caused in rev. 1.26: *do* report the size of
files listed on the command line, no matter what options are given;
issue reported by edd@@; ok millert@@ edd@@
@
text
@d1 1
a1 1
/*	$OpenBSD: du.c,v 1.28 2014/10/19 18:24:58 jmc Exp $	*/
d209 1
@


1.28
log
@rearrange -d, again, after giving ingo some dodgy advice;
ok ingo
@
text
@d1 1
a1 1
/*	$OpenBSD: du.c,v 1.27 2014/10/19 14:27:41 schwarze Exp $	*/
d196 2
a197 1
			if (listfiles && p->fts_level <= maxdepth)
@


1.27
log
@in usage() and SYNOPSIS, sort options as suggested by jmc@@
@
text
@d1 1
a1 1
/*	$OpenBSD: du.c,v 1.26 2014/10/17 14:46:54 schwarze Exp $	*/
d318 1
a318 1
	    "usage: du [-achkrsx] [-d depth] [-H | -L | -P] [file ...]\n");
@


1.26
log
@Add the -d flag (limit display depth) for compatibility with FreeBSD,
DragonFly, NetBSD and GNU coreutils, even though it's not POSIX.
Actually, this simplifies the code rather than complicating it.

Because -a and -d need not be mutually exclusive (as observed by
millert@@) and -s is identical to -d 0, -a and -s are no longer
mutually exclusive, but -as and -sa are now the same as -s.
That is explicitly allowed by POSIX.

Based on a patch from William Orr <will at worrbase dot com>,
but extensively massaged and HISTORY added by me.

feedback and ok millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: du.c,v 1.25 2014/05/20 01:25:23 guenther Exp $	*/
d318 1
a318 1
	    "usage: du [-d depth] [-achkrsx] [-H | -L | -P] [file ...]\n");
@


1.25
log
@Use errc/warnc to simplify code.
Also, in 'ftp', always put the error message last, after the hostname/ipaddr.

ok jsing@@ krw@@ millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: du.c,v 1.24 2013/11/13 21:20:01 deraadt Exp $	*/
d43 1
d63 2
a64 2
	int ftsoptions, listdirs, listfiles;
	int Hflag, Lflag, aflag, cflag, hflag, kflag, sflag;
d67 1
d70 1
a70 1
	Hflag = Lflag = aflag = cflag = hflag = kflag = sflag = 0;
d73 2
a74 1
	while ((ch = getopt(argc, argv, "HLPachksxr")) != -1)
d88 1
a88 1
			aflag = 1;
d93 7
d109 1
a109 1
			sflag = 1;
d142 2
a143 10
	if (aflag) {
		if (sflag)
			usage();
		listdirs = listfiles = 1;
	} else if (sflag)
		listdirs = listfiles = 0;
	else {
		listfiles = 0;
		listdirs = 1;
	}
d176 1
a176 2
			if (listdirs ||
			    (!listfiles && p->fts_level == FTS_ROOTLEVEL)) {
a179 1
			}
d196 1
a196 1
			if (listfiles || p->fts_level == FTS_ROOTLEVEL)
d318 1
a318 1
		"usage: du [-a | -s] [-chkrx] [-H | -L | -P] [file ...]\n");
@


1.24
log
@a few things can be static to avoid need for protos
@
text
@d1 1
a1 1
/*	$OpenBSD: du.c,v 1.23 2011/04/27 07:52:11 sobrado Exp $	*/
d186 1
a186 1
			warnx("%s: %s", p->fts_path, strerror(p->fts_errno));
@


1.23
log
@cast one blocksize occurrence to unsigned long, fixes du(1)'s output
for directories larger than one terabyte; while here, wrap a long line.

problem found by Chano Antuna and diff written with lots of good
advice from millert@@, thanks!

ok millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: du.c,v 1.22 2009/10/27 23:59:37 deraadt Exp $	*/
d220 1
a220 1
int
d235 1
a235 1
RB_GENERATE(ltree, links_entry, entry, links_cmp);
@


1.22
log
@rcsid[] and sccsid[] and copyright[] are essentially unmaintained (and
unmaintainable).  these days, people use source.  these id's do not provide
any benefit, and do hurt the small install media
(the 33,000 line diff is essentially mechanical)
ok with the idea millert, ok dms
@
text
@d1 1
a1 1
/*	$OpenBSD: du.c,v 1.21 2009/08/27 11:29:30 millert Exp $	*/
d176 3
a178 2
				prtout((quad_t)howmany(p->fts_number, blocksize),
				    p->fts_path, hflag);
d197 2
a198 2
				prtout(howmany(p->fts_statp->st_blocks, blocksize),
				    p->fts_path, hflag);
@


1.21
log
@Use FTS_ROOTLEVEL instead of 0 when checking fts_level.
@
text
@d1 1
a1 1
/*	$OpenBSD: du.c,v 1.20 2009/06/03 15:15:16 millert Exp $	*/
a34 14

#ifndef lint
static const char copyright[] =
"@@(#) Copyright (c) 1989, 1993, 1994\n\
	The Regents of the University of California.  All rights reserved.\n";
#endif /* not lint */

#ifndef lint
#if 0
static char sccsid[] = "@@(#)du.c	8.5 (Berkeley) 5/4/95";
#else
static const char rcsid[] = "$OpenBSD: du.c,v 1.20 2009/06/03 15:15:16 millert Exp $";
#endif
#endif /* not lint */
@


1.20
log
@If both -h and -k are specified, the latter takes precedence.
Prompted by jmc@@, OK otto@@
@
text
@d1 1
a1 1
/*	$OpenBSD: du.c,v 1.19 2006/01/25 06:20:03 tedu Exp $	*/
d46 1
a46 1
static const char rcsid[] = "$OpenBSD: du.c,v 1.19 2006/01/25 06:20:03 tedu Exp $";
d188 2
a189 1
			if (listdirs || (!listfiles && !p->fts_level))
d192 1
d209 1
a209 1
			if (listfiles || !p->fts_level)
@


1.19
log
@lint says Pflag isn't needed.  i concur
@
text
@d1 1
a1 1
/*	$OpenBSD: du.c,v 1.18 2005/04/17 12:27:23 jmc Exp $	*/
d46 1
a46 1
static const char rcsid[] = "$OpenBSD: du.c,v 1.18 2005/04/17 12:27:23 jmc Exp $";
d106 1
d110 1
@


1.18
log
@sort options + sync usage();
@
text
@d1 1
a1 1
/*	$OpenBSD: du.c,v 1.17 2004/06/21 09:44:31 otto Exp $	*/
d37 1
a37 1
static char copyright[] =
d46 1
a46 1
static char rcsid[] = "$OpenBSD: du.c,v 1.17 2004/06/21 09:44:31 otto Exp $";
d77 1
a77 1
	int Hflag, Lflag, Pflag, aflag, cflag, hflag, kflag, sflag;
d82 1
a82 1
	Hflag = Lflag = Pflag = aflag = cflag = hflag = kflag = sflag = 0;
d89 1
a89 1
			Lflag = Pflag = 0;
d93 1
a93 1
			Hflag = Pflag = 0;
a95 1
			Pflag = 1;
@


1.17
log
@Actually commit right (r&b tree) version, instead of hash table
one.  Previous commit from wrong tree. Spotted by Andre Lucas <andre
at ae-35 dot com> ok millert@@ canacar@@
@
text
@d1 1
a1 1
/*	$OpenBSD: du.c,v 1.16 2004/06/14 18:21:31 otto Exp $	*/
d46 1
a46 1
static char rcsid[] = "$OpenBSD: du.c,v 1.16 2004/06/14 18:21:31 otto Exp $";
d328 1
a328 1
		"usage: du [-H | -L | -P] [-a | -s] [-chkrx] [file ...]\n");
@


1.16
log
@- use fmt_scaled(3) instead of home grown function to print -h numbers
- do not use a linear list to keep track of inodes with link count > 2,
  use a red & black tree. Based on freebsd code that uses auto-sizing
  hash maps; this tree version by canacar@@.

ok millert@@ canacar@@
@
text
@d1 1
a1 1
/*	$OpenBSD: du.c,v 1.15 2004/06/02 14:58:46 tom Exp $	*/
d46 1
a46 1
static char rcsid[] = "$OpenBSD: du.c,v 1.15 2004/06/02 14:58:46 tom Exp $";
d60 1
d221 27
d251 3
a253 14
	struct links_entry {
		struct links_entry *next;
		struct links_entry *previous;
		int	 links;
		dev_t	 dev;
		ino_t	 ino;
	};
	static const size_t links_hash_initial_size = 8192;
	static struct links_entry **buckets;
	static struct links_entry *free_list;
	static size_t number_buckets;
	static unsigned long number_entries;
	static char stop_allocating;
	struct links_entry *le, **new_buckets;
a254 2
	size_t i, new_size;
	int count, hash;
d258 2
a259 9
	/* If necessary, initialize the hash table. */
	if (buckets == NULL) {
		number_buckets = links_hash_initial_size;
		buckets = malloc(number_buckets * sizeof(buckets[0]));
		if (buckets == NULL)
			errx(1, "No memory for hardlink detection");
		for (i = 0; i < number_buckets; i++)
			buckets[i] = NULL;
	}
d261 10
a270 11
	/* If the hash table is getting too full, enlarge it. */
	if (number_entries > number_buckets * 10 && !stop_allocating) {
		new_size = number_buckets * 2;
		new_buckets = malloc(new_size * sizeof(struct links_entry *));
		count = 0;

		/* Try releasing the free list to see if that helps. */
		if (new_buckets == NULL && free_list != NULL) {
			while (free_list != NULL) {
				le = free_list;
				free_list = le->next;
d272 3
a275 57
			new_buckets = malloc(new_size * sizeof(new_buckets[0]));
		}

		if (new_buckets == NULL) {
			stop_allocating = 1;
			warnx("No more memory for tracking hard links");
		} else {
			memset(new_buckets, 0,
			    new_size * sizeof(struct links_entry *));
			for (i = 0; i < number_buckets; i++) {
				while (buckets[i] != NULL) {
					/* Remove entry from old bucket. */
					le = buckets[i];
					buckets[i] = le->next;

					/* Add entry to new bucket. */
					hash = (le->dev ^ le->ino) % new_size;

					if (new_buckets[hash] != NULL)
						new_buckets[hash]->previous =
						    le;
					le->next = new_buckets[hash];
					le->previous = NULL;
					new_buckets[hash] = le;
				}
			}
			free(buckets);
			buckets = new_buckets;
			number_buckets = new_size;
		}
	}

	/* Try to locate this entry in the hash table. */
	hash = ( st->st_dev ^ st->st_ino ) % number_buckets;
	for (le = buckets[hash]; le != NULL; le = le->next) {
		if (le->dev == st->st_dev && le->ino == st->st_ino) {
			/*
			 * Save memory by releasing an entry when we've seen
			 * all of it's links.
			 */
			if (--le->links <= 0) {
				if (le->previous != NULL)
					le->previous->next = le->next;
				if (le->next != NULL)
					le->next->previous = le->previous;
				if (buckets[hash] == le)
					buckets[hash] = le->next;
				number_entries--;
				/* Recycle this node through the free list */
				if (stop_allocating) {
					free(le);
				} else {
					le->next = free_list;
					free_list = le;
				}
			}
			return (1);
d277 1
d287 1
a287 1
		free_list = le->next;
d291 1
d297 1
d301 4
a304 6
	number_entries++;
	le->next = buckets[hash];
	le->previous = NULL;
	if (buckets[hash] != NULL)
		buckets[hash]->previous = le;
	buckets[hash] = le;
@


1.15
log
@Don't want text in err() call following malloc failures.

ok henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: du.c,v 1.14 2003/07/02 21:04:09 deraadt Exp $	*/
d46 1
a46 1
static char rcsid[] = "$OpenBSD: du.c,v 1.14 2003/07/02 21:04:09 deraadt Exp $";
a56 1
#include <math.h>
d61 1
a62 1
typedef enum { NONE = 0, KILO, MEGA, GIGA, TERA, PETA /* , EXA */ } unit_t;
a66 1
unit_t	 unit_adjust(double *);
a219 5
typedef struct _ID {
	dev_t	dev;
	ino_t	inode;
} ID;

d223 74
a296 21
	static ID *files;
	static int maxfiles, nfiles;
	ID *fp, *start;
	ino_t ino;
	dev_t dev;

	ino = p->fts_statp->st_ino;
	dev = p->fts_statp->st_dev;
	if ((start = files) != NULL)
		for (fp = start + nfiles - 1; fp >= start; --fp)
			if (ino == fp->inode && dev == fp->dev)
				return (1);

	if (nfiles == maxfiles && (files = realloc((char *)files,
	    (u_int)(sizeof(ID) * (maxfiles += 128)))) == NULL)
		err(1, NULL);
	files[nfiles].inode = ino;
	files[nfiles].dev = dev;
	++nfiles;
	return (0);
}
d298 27
a324 4
/*
 * "human-readable" output: use 3 digits max.--put unit suffixes at
 * the end.  Makes output compact and easy-to-read. 
 */
d326 2
a327 5
unit_t
unit_adjust(double *val)
{
	double abval;
	unit_t unit;
d329 12
a340 18
	abval = fabs(*val);
	if (abval < 1024)
		unit = NONE;
	else if (abval < 1048576ULL) {
		unit = KILO;
		*val /= 1024;
	} else if (abval < 1073741824ULL) {
		unit = MEGA;
		*val /= 1048576;
	} else if (abval < 1099511627776ULL) {
		unit = GIGA;
		*val /= 1073741824ULL;
	} else if (abval < 1125899906842624ULL) {
		unit = TERA;
		*val /= 1099511627776ULL;
	} else /* if (abval < 1152921504606846976ULL) */ {
		unit = PETA;
		*val /= 1125899906842624ULL;
d342 10
a351 1
	return (unit);
a356 3
	unit_t unit;
	double bytes;

d360 1
a360 2
		bytes = (double)size * 512.0;
		unit = unit_adjust(&bytes);
d362 2
a363 4
		if (bytes == 0)
			(void)printf("0B\t%s\n", path);
		else if (bytes > 10)
			(void)printf("%.0f%c\t%s\n", bytes, "BKMGTPE"[unit], path);
d365 1
a365 1
			(void)printf("%.1f%c\t%s\n", bytes, "BKMGTPE"[unit], path);
@


1.14
log
@protos
@
text
@d1 1
a1 1
/*	$OpenBSD: du.c,v 1.13 2003/06/10 22:20:46 deraadt Exp $	*/
d46 1
a46 1
static char rcsid[] = "$OpenBSD: du.c,v 1.13 2003/06/10 22:20:46 deraadt Exp $";
d245 1
a245 1
		err(1, "can't allocate memory");
@


1.13
log
@mostly ansi cleanup; pval ok
@
text
@d1 1
a1 1
/*	$OpenBSD: du.c,v 1.12 2003/06/03 02:56:07 millert Exp $	*/
d46 1
a46 1
static char rcsid[] = "$OpenBSD: du.c,v 1.12 2003/06/03 02:56:07 millert Exp $";
d63 2
d68 1
a255 2

typedef enum { NONE = 0, KILO, MEGA, GIGA, TERA, PETA /* , EXA */ } unit_t;
@


1.12
log
@Remove the advertising clause in the UCB license which Berkeley
rescinded 22 July 1999.  Proofed by myself and Theo.
@
text
@d1 1
a1 1
/*	$OpenBSD: du.c,v 1.11 2002/02/16 21:27:45 millert Exp $	*/
d46 1
a46 1
static char rcsid[] = "$OpenBSD: du.c,v 1.11 2002/02/16 21:27:45 millert Exp $";
d68 1
a68 3
main(argc, argv)
	int argc;
	char *argv[];
d225 1
a225 2
linkchk(p)
	FTSENT *p;
d257 1
a257 2
unit_adjust(val)
	double *val;
d285 1
a285 4
prtout(size, path, hflag)
	quad_t size;
	char *path;
	int hflag;
d306 1
a306 1
usage()
@


1.11
log
@Part one of userland __P removal.  Done with a simple regexp with some minor hand editing to make comments line up correctly.  Another pass is forthcoming that handles the cases that could not be done automatically.
@
text
@d1 1
a1 1
/*	$OpenBSD: du.c,v 1.10 2001/07/30 00:53:38 deraadt Exp $	*/
d19 1
a19 5
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
d46 1
a46 1
static char rcsid[] = "$OpenBSD: du.c,v 1.10 2001/07/30 00:53:38 deraadt Exp $";
@


1.10
log
@fix 0B case; morten@@hotpost.dk
@
text
@d1 1
a1 1
/*	$OpenBSD: du.c,v 1.9 2001/07/12 05:17:00 deraadt Exp $	*/
d50 1
a50 1
static char rcsid[] = "$OpenBSD: du.c,v 1.9 2001/07/12 05:17:00 deraadt Exp $";
d67 3
a69 3
int	 linkchk __P((FTSENT *));
void	 prtout __P((quad_t, char *, int));
void	 usage __P((void));
@


1.9
log
@first pass at a -Wall cleanup
@
text
@d1 1
a1 1
/*	$OpenBSD: du.c,v 1.8 2001/05/02 23:26:53 pjanzen Exp $	*/
d50 1
a50 1
static char rcsid[] = "$OpenBSD: du.c,v 1.8 2001/05/02 23:26:53 pjanzen Exp $";
d308 1
a308 1
			(void)printf("     0B\t%s\n", path);
@


1.8
log
@-h overrides BLOCKSIZE; matt@@anzen.com
@
text
@d1 1
a1 1
/*	$OpenBSD: du.c,v 1.7 2001/02/23 19:14:21 pjanzen Exp $	*/
d50 1
a50 1
static char rcsid[] = "$OpenBSD: du.c,v 1.7 2001/02/23 19:14:21 pjanzen Exp $";
d302 1
a302 1
		(void)printf("%qd\t%s\n", size, path);
@


1.7
log
@Add -h option ("human-readable") as df.  Based on suggestions and code from
Matt Bing <matt@@anzen.com>.
@
text
@d1 1
a1 1
/*	$OpenBSD: du.c,v 1.6 2000/04/16 04:21:34 ericj Exp $	*/
d50 1
a50 1
static char rcsid[] = "$OpenBSD: du.c,v 1.6 2000/04/16 04:21:34 ericj Exp $";
a112 1
			blocksize = 1024;
d166 5
a170 1
	if (!kflag || hflag)
@


1.6
log
@correct return value; from FreeBSD
@
text
@d1 1
a1 1
/*	$OpenBSD: du.c,v 1.5 1998/02/16 09:23:06 deraadt Exp $	*/
d50 1
a50 1
static char rcsid[] = "$OpenBSD: du.c,v 1.5 1998/02/16 09:23:06 deraadt Exp $";
d61 1
d68 1
d78 2
a79 1
	long blocksize, totalblocks;
d81 2
a82 1
	int Hflag, Lflag, Pflag, aflag, ch, cflag, kflag, notused, rval, sflag;
d86 1
a86 1
	Hflag = Lflag = Pflag = aflag = cflag = kflag = sflag = 0;
d89 1
a89 1
	while ((ch = getopt(argc, argv, "HLPacksxr")) != -1)
d109 3
d167 1
a167 1
	if (!kflag)
d189 2
a190 3
				(void)printf("%ld\t%s\n",
				    howmany(p->fts_number, blocksize),
				    p->fts_path);
d208 2
a209 3
				(void)printf("%qd\t%s\n",
				    howmany(p->fts_statp->st_blocks, blocksize),
				    p->fts_path);
d216 3
a218 3
	if (cflag)
		(void)printf("%ld\ttotal\n",
		    howmany(totalblocks, blocksize));
d253 60
d318 1
a318 1
		"usage: du [-H | -L | -P] [-a | -s] [-ckrx] [file ...]\n");
@


1.5
log
@-r for xpg conformance
@
text
@d1 1
a1 1
/*	$OpenBSD: du.c,v 1.4 1997/01/15 23:42:25 millert Exp $	*/
d50 1
a50 1
static char rcsid[] = "$OpenBSD: du.c,v 1.4 1997/01/15 23:42:25 millert Exp $";
d214 1
a214 1
	exit(0);
@


1.4
log
@getopt(3) returns -1 when out of args, not EOF, whee!
@
text
@d1 1
a1 1
/*	$OpenBSD: du.c,v 1.3 1996/10/18 18:16:07 millert Exp $	*/
d50 1
a50 1
static char rcsid[] = "$OpenBSD: du.c,v 1.3 1996/10/18 18:16:07 millert Exp $";
d85 1
a85 1
	while ((ch = getopt(argc, argv, "HLPacksx")) != -1)
d112 2
d253 1
a253 1
		"usage: du [-H | -L | -P] [-a | -s] [-ckx] [file ...]\n");
@


1.3
log
@Implement a -c (Grand Total) option, a'la GNU du(1).
From Luke Mewburn <lukem@@telstra.com.au>, NetBSD PR #2805.
Also -Wall happiness.
@
text
@d1 1
a1 1
/*	$OpenBSD: du.c,v 1.11 1996/10/18 07:20:35 thorpej Exp $	*/
d50 1
a50 1
static char rcsid[] = "$OpenBSD: du.c,v 1.11 1996/10/18 07:20:35 thorpej Exp $";
d85 1
a85 1
	while ((ch = getopt(argc, argv, "HLPacksx")) != EOF)
@


1.2
log
@rcsid
@
text
@d1 2
a2 2
/*	$OpenBSD: du.c,v 1.10 1995/09/28 06:19:56 perry Exp $	*/
/*	$NetBSD: du.c,v 1.10 1995/09/28 06:19:56 perry Exp $	*/
d50 1
a50 1
static char rcsid[] = "$OpenBSD: du.c,v 1.10 1995/09/28 06:19:56 perry Exp $";
d76 1
a76 1
	long blocksize;
d78 1
a78 1
	int Hflag, Lflag, Pflag, aflag, ch, kflag, notused, rval, sflag;
d82 2
a83 1
	Hflag = Lflag = Pflag = aflag = kflag = sflag = 0;
d85 1
a85 1
	while ((ch = getopt(argc, argv, "HLPaksx")) != EOF)
d102 3
d163 1
a163 1
		err(1, NULL);
d172 2
d179 1
a179 1
			if (listdirs || !listfiles && !p->fts_level)
d204 2
d209 3
d239 1
a239 1
		err(1, "");
d251 1
a251 1
		"usage: du [-H | -L | -P] [-a | -s] [-kx] [file ...]\n");
@


1.1
log
@Initial revision
@
text
@d1 1
d50 1
a50 1
static char rcsid[] = "$NetBSD: du.c,v 1.10 1995/09/28 06:19:56 perry Exp $";
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@
