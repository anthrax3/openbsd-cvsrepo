head	1.34;
access;
symbols
	OPENBSD_6_0:1.33.0.2
	OPENBSD_6_0_BASE:1.33
	OPENBSD_5_9:1.30.0.2
	OPENBSD_5_9_BASE:1.30
	OPENBSD_5_8:1.29.0.4
	OPENBSD_5_8_BASE:1.29
	OPENBSD_5_7:1.25.0.2
	OPENBSD_5_7_BASE:1.25
	OPENBSD_5_6:1.23.0.6
	OPENBSD_5_6_BASE:1.23
	OPENBSD_5_5:1.23.0.4
	OPENBSD_5_5_BASE:1.23
	OPENBSD_5_4:1.22.0.4
	OPENBSD_5_4_BASE:1.22
	OPENBSD_5_3:1.22.0.2
	OPENBSD_5_3_BASE:1.22
	OPENBSD_5_2:1.21.0.10
	OPENBSD_5_2_BASE:1.21
	OPENBSD_5_1_BASE:1.21
	OPENBSD_5_1:1.21.0.8
	OPENBSD_5_0:1.21.0.6
	OPENBSD_5_0_BASE:1.21
	OPENBSD_4_9:1.21.0.4
	OPENBSD_4_9_BASE:1.21
	OPENBSD_4_8:1.21.0.2
	OPENBSD_4_8_BASE:1.21
	OPENBSD_4_7:1.20.0.2
	OPENBSD_4_7_BASE:1.20
	OPENBSD_4_6:1.19.0.8
	OPENBSD_4_6_BASE:1.19
	OPENBSD_4_5:1.19.0.4
	OPENBSD_4_5_BASE:1.19
	OPENBSD_4_4:1.19.0.2
	OPENBSD_4_4_BASE:1.19
	OPENBSD_4_3:1.16.0.2
	OPENBSD_4_3_BASE:1.16
	OPENBSD_4_2:1.13.0.2
	OPENBSD_4_2_BASE:1.13
	OPENBSD_4_1:1.12.0.4
	OPENBSD_4_1_BASE:1.12
	OPENBSD_4_0:1.12.0.2
	OPENBSD_4_0_BASE:1.12
	OPENBSD_3_9:1.11.0.8
	OPENBSD_3_9_BASE:1.11
	OPENBSD_3_8:1.11.0.6
	OPENBSD_3_8_BASE:1.11
	OPENBSD_3_7:1.11.0.4
	OPENBSD_3_7_BASE:1.11
	OPENBSD_3_6:1.11.0.2
	OPENBSD_3_6_BASE:1.11
	OPENBSD_3_5:1.10.0.4
	OPENBSD_3_5_BASE:1.10
	OPENBSD_3_4:1.10.0.2
	OPENBSD_3_4_BASE:1.10
	OPENBSD_3_3:1.8.0.2
	OPENBSD_3_3_BASE:1.8
	OPENBSD_3_2:1.6.0.4
	OPENBSD_3_2_BASE:1.6
	OPENBSD_3_1:1.6.0.2
	OPENBSD_3_1_BASE:1.6
	OPENBSD_3_0:1.5.0.4
	OPENBSD_3_0_BASE:1.5
	OPENBSD_2_9_BASE:1.5
	OPENBSD_2_9:1.5.0.2
	OPENBSD_2_8:1.4.0.10
	OPENBSD_2_8_BASE:1.4
	OPENBSD_2_7:1.4.0.8
	OPENBSD_2_7_BASE:1.4
	OPENBSD_2_6:1.4.0.6
	OPENBSD_2_6_BASE:1.4
	OPENBSD_2_5:1.4.0.4
	OPENBSD_2_5_BASE:1.4
	OPENBSD_2_4:1.4.0.2
	OPENBSD_2_4_BASE:1.4
	AUDIOCTL10:1.1.1.1
	AUDIOCTL:1.1.1;
locks; strict;
comment	@ * @;


1.34
date	2016.08.31.09.48.26;	author jsg;	state Exp;
branches;
next	1.33;
commitid	wwkIrIkUdWVrfeYJ;

1.33
date	2016.06.21.22.35.39;	author jmc;	state Exp;
branches;
next	1.32;
commitid	56R7JjyvEmHwHWti;

1.32
date	2016.06.21.21.16.42;	author ratchov;	state Exp;
branches;
next	1.31;
commitid	AmjnrewdFDuyQLwM;

1.31
date	2016.06.21.06.26.50;	author ratchov;	state Exp;
branches;
next	1.30;
commitid	PLROpFV3N3ml53cA;

1.30
date	2016.01.29.10.23.56;	author ratchov;	state Exp;
branches;
next	1.29;
commitid	5gloonghGbB1MJSL;

1.29
date	2015.07.28.20.51.10;	author ratchov;	state Exp;
branches;
next	1.28;
commitid	dr6iHYNzCzLMnX6x;

1.28
date	2015.05.26.18.17.12;	author ratchov;	state Exp;
branches;
next	1.27;
commitid	bTVcHP4sr906hLxV;

1.27
date	2015.05.16.12.51.24;	author ratchov;	state Exp;
branches;
next	1.26;
commitid	onZNzQBp6ZVFt4za;

1.26
date	2015.05.16.12.48.50;	author ratchov;	state Exp;
branches;
next	1.25;
commitid	tCNFVcRkq7SkcCeM;

1.25
date	2015.02.08.23.40.34;	author deraadt;	state Exp;
branches;
next	1.24;
commitid	yGZX28AeTChVE8eY;

1.24
date	2014.09.23.06.47.37;	author ratchov;	state Exp;
branches;
next	1.23;
commitid	RChJ4WgTKWig4QVz;

1.23
date	2013.11.13.18.50.05;	author deraadt;	state Exp;
branches;
next	1.22;

1.22
date	2012.07.27.00.21.17;	author krw;	state Exp;
branches;
next	1.21;

1.21
date	2010.07.15.03.43.12;	author jakemsr;	state Exp;
branches;
next	1.20;

1.20
date	2009.11.12.07.32.26;	author ratchov;	state Exp;
branches;
next	1.19;

1.19
date	2008.06.26.05.42.20;	author ray;	state Exp;
branches;
next	1.18;

1.18
date	2008.04.25.06.43.49;	author jakemsr;	state Exp;
branches;
next	1.17;

1.17
date	2008.03.22.11.05.31;	author ratchov;	state Exp;
branches;
next	1.16;

1.16
date	2007.11.26.13.36.34;	author deraadt;	state Exp;
branches;
next	1.15;

1.15
date	2007.09.27.21.55.54;	author sobrado;	state Exp;
branches;
next	1.14;

1.14
date	2007.09.17.13.46.11;	author jakemsr;	state Exp;
branches;
next	1.13;

1.13
date	2007.08.06.19.16.06;	author sobrado;	state Exp;
branches;
next	1.12;

1.12
date	2006.03.14.19.36.44;	author moritz;	state Exp;
branches;
next	1.11;

1.11
date	2004.07.06.02.46.06;	author vincent;	state Exp;
branches;
next	1.10;

1.10
date	2003.06.21.01.39.07;	author deraadt;	state Exp;
branches;
next	1.9;

1.9
date	2003.04.16.01.36.39;	author deraadt;	state Exp;
branches;
next	1.8;

1.8
date	2002.12.13.16.36.52;	author naddy;	state Exp;
branches;
next	1.7;

1.7
date	2002.12.10.09.03.37;	author pvalchev;	state Exp;
branches;
next	1.6;

1.6
date	2002.02.16.21.27.44;	author millert;	state Exp;
branches;
next	1.5;

1.5
date	2000.11.21.13.58.06;	author aaron;	state Exp;
branches;
next	1.4;

1.4
date	98.07.15.22.10.47;	author deraadt;	state Exp;
branches;
next	1.3;

1.3
date	98.04.30.13.46.18;	author provos;	state Exp;
branches;
next	1.2;

1.2
date	98.04.26.22.27.25;	author provos;	state Exp;
branches;
next	1.1;

1.1
date	98.04.26.21.44.40;	author provos;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	98.04.26.21.44.40;	author provos;	state Exp;
branches;
next	;


desc
@@


1.34
log
@close an opened fd before returning from main
ok guenther@@
@
text
@/*	$OpenBSD: audioctl.c,v 1.33 2016/06/21 22:35:39 jmc Exp $	*/
/*
 * Copyright (c) 2016 Alexandre Ratchov <alex@@caoua.org>
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */
#include <sys/types.h>
#include <sys/ioctl.h>
#include <sys/audioio.h>
#include <fcntl.h>
#include <limits.h>
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <string.h>
#include <err.h>

/*
 * Default bytes per sample for the given bits per sample.
 */
#define BPS(bits) (((bits) <= 8) ? 1 : (((bits) <= 16) ? 2 : 4))

struct audio_device rname;
struct audio_status rstatus;
struct audio_swpar rpar, wpar;
struct audio_pos rpos;

struct field {
	char *name;
	void *raddr, *waddr;
#define MODE	0
#define NUM	1
#define STR	2
#define ENC	3
	int type;
	int set;
} fields[] = {
	{"name",		&rname.name,		NULL,		STR},
	{"mode",		&rstatus.mode,		NULL,		MODE},
	{"pause",		&rstatus.pause,		NULL,		NUM},
	{"active",		&rstatus.active,	NULL,		NUM},
	{"nblks",		&rpar.nblks,		&wpar.nblks,	NUM},
	{"blksz",		&rpar.round,		&wpar.round,	NUM},
	{"rate",		&rpar.rate,		&wpar.rate,	NUM},
	{"encoding",		&rpar,			&wpar,		ENC},
	{"play.channels",	&rpar.pchan,		&wpar.pchan,	NUM},
	{"play.bytes",		&rpos.play_pos,		NULL,		NUM},
	{"play.errors",		&rpos.play_xrun,	NULL,		NUM},
	{"record.channels",	&rpar.rchan,		&wpar.rchan, 	NUM},
	{"record.bytes",	&rpos.rec_pos,		NULL,		NUM},
	{"record.errors",	&rpos.rec_xrun,		NULL,		NUM},
	{NULL,			NULL,			0}
};

const char usagestr[] =
	"usage: audioctl [-f file]\n"
	"       audioctl [-n] [-f file] name ...\n"
	"       audioctl [-nq] [-f file] name=value ...\n";

/*
 * parse encoding string (examples: s8, u8, s16, s16le, s24be ...)
 * and fill enconding fields of audio_swpar structure
 */
int
strtoenc(struct audio_swpar *ap, char *p)
{
	/* expect "s" or "u" (signedness) */
	if (*p == 's')
		ap->sig = 1;
	else if (*p == 'u')
		ap->sig = 0;
	else
		return 0;
	p++;

	/* expect 1-2 decimal digits (bits per sample) */
	ap->bits = 0;
	while (*p >= '0' && *p <= '9') {
		ap->bits = (ap->bits * 10) + *p++ - '0';
		if (ap->bits > 32)
			return 0;
	}
	if (ap->bits < 8)
		return 0;

	/* set defaults as next tokens are optional */
	ap->bps = BPS(ap->bits);
	ap->le = (BYTE_ORDER == LITTLE_ENDIAN);
	ap->msb = 1;
	if (*p == '\0')
		return 1;

	/* expect "le" or "be" (endianness) */
	if (p[0] == 'l' && p[1] == 'e')
		ap->le = 1;
	else if (p[0] == 'b' && p[1] == 'e')
		ap->le = 0;
	else
		return 0;
	p += 2;
	if (*p == '\0')
		return 1;

	/* expect 1 decimal digit (number of bytes) */
	if (*p < '0' || *p > '9')
		return 0;
	ap->bps = *p - '0';
	if (ap->bps < ((ap->bits + 7) >> 3) || ap->bps > 4)
		return 0;
	if (*++p == '\0')
		return 1;

	/* expect "msb" or "lsb" (alignment) */
	if (p[0] == 'm' && p[1] == 's' && p[2] == 'b')
		ap->msb = 1;
	else if (p[0] == 'l' && p[1] == 's' && p[2] == 'b')
		ap->msb = 0;
	else if (*p == '\0')
		return 1;
	p += 3;
	if (*p == '\0')
		return 1;

	/* must be no additional junk */
	return 0;
}

void
print_val(struct field *p, void *addr)
{
	int mode;
	struct audio_swpar *ap;

	switch (p->type) {
	case NUM:
		printf("%u", *(unsigned int *)addr);
		break;
	case STR:
		printf("%s", (char *)addr);
		break;
	case MODE:
		mode = *(unsigned int *)addr;
		if (mode & AUMODE_PLAY)
			printf("play");
		if (mode & AUMODE_RECORD) {
			if (mode & AUMODE_PLAY)
				printf(",");
			printf("record");
		}
		break;
	case ENC:
		ap = addr;
		printf("%s%u", ap->sig ? "s" : "u", ap->bits);
		if (ap->bps == 1)
			break;
		printf("%s", ap->le ? "le" : "be");
		if (ap->bps != BPS(ap->bits) || ap->bits < ap->bps * 8) {
			printf("%u", ap->bps);
			if (ap->bits < ap->bps * 8)
				printf("%s", ap->msb ? "msb" : "lsb");
		}
	}
}

void
parse_val(struct field *f, void *addr, char *p)
{
	const char *strerr;

	switch (f->type) {
	case NUM:
		*(unsigned int *)addr = strtonum(p, 0, UINT_MAX, &strerr);
		if (strerr)
			errx(1, "%s: %s", p, strerr);
		break;
	case ENC:
		if (!strtoenc((struct audio_swpar *)addr, p))
			errx(1, "%s: bad encoding", p);
	}
}

int
main(int argc, char **argv)
{
	struct field *f;
	char *lhs, *rhs, *path = "/dev/audioctl0";
	int fd, c, set = 0, print_names = 1, quiet = 0;

	while ((c = getopt(argc, argv, "anf:q")) != -1) {
		switch (c) {
		case 'a':	/* ignored, compat */
			break;
		case 'n':
			print_names = 0;
			break;
		case 'f':
			path = optarg;
			break;
		case 'q':
			quiet = 1;
			break;
		default:
			fputs(usagestr, stderr);
			return 1;
		}
	}
	argc -= optind;
	argv += optind;

	fd = open(path, O_RDWR);
	if (fd < 0)
		err(1, "%s", path);
	if (ioctl(fd, AUDIO_GETSTATUS, &rstatus) < 0)
		err(1, "AUDIO_GETSTATUS");
	if (ioctl(fd, AUDIO_GETDEV, &rname) < 0)
		err(1, "AUDIO_GETDEV");
	if (ioctl(fd, AUDIO_GETPAR, &rpar) < 0)
		err(1, "AUDIO_GETPAR");
	if (ioctl(fd, AUDIO_GETPOS, &rpos) < 0)
		err(1, "AUDIO_GETPOS");
	if (argc == 0) {
		for (f = fields; f->name != NULL; f++) {
			printf("%s=", f->name);
			print_val(f, f->raddr);
			printf("\n");
		}
	}
	AUDIO_INITPAR(&wpar);
	for (; argc > 0; argc--, argv++) {
		lhs = *argv;
		rhs = strchr(*argv, '=');
		if (rhs)
			*rhs++ = '\0';
		for (f = fields;; f++) {
			if (f->name == NULL)
				errx(1, "%s: unknown parameter", lhs);
			if (strcmp(f->name, lhs) == 0)
				break;
		}
		if (rhs) {
			if (f->waddr == NULL)
				errx(1, "%s: is read only", f->name);
			parse_val(f, f->waddr, rhs);
			f->set = 1;
			set = 1;
		} else {
			if (print_names)
				printf("%s=", f->name);
			print_val(f, f->raddr);
			printf("\n");
		}
	}
	if (!set)
		return 0;
	if (ioctl(fd, AUDIO_SETPAR, &wpar) < 0)
		err(1, "AUDIO_SETPAR");
	if (ioctl(fd, AUDIO_GETPAR, &wpar) < 0)
		err(1, "AUDIO_GETPAR");
	for (f = fields; f->name != NULL; f++) {
		if (!f->set || quiet)
			continue;
		if (print_names) {
			printf("%s: ", f->name);
			print_val(f, f->raddr);
			printf(" -> ");
		}
		print_val(f, f->waddr);
		printf("\n");
	}
	close(fd);
	return 0;	
}
@


1.33
log
@use the same argument name for -f in usage() as in SYNOPSIS;
@
text
@d1 1
a1 1
/*	$OpenBSD: audioctl.c,v 1.32 2016/06/21 21:16:42 ratchov Exp $	*/
d280 1
@


1.32
log
@Make usage string match the man page.

suggested by jmc@@
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d66 3
a68 3
	"usage: audioctl [-f path]\n"
	"       audioctl [-n] [-f path] name ...\n"
	"       audioctl [-nq] [-f path] name=value ...\n";
@


1.31
log
@Reimplement audioctl using new api in a simper way.

- group all encoding parameters in a signle string, ex.  "s16le",
  this way we use the same naming scheme as aucat, sndiod and many
  ports.
- remove "properties" as they are not used any longer
- remove the list of encodings as there's no benefit in having it.
  We don't have lists for other parameters (sample rates, channel
  numbers) either.
- add -q option, to look like sysctl
- remove unused -a option
- stop using symlinks in /dev, most other software doesn't use
  them.

ok semarie@@
@
text
@d65 4
a68 1
const char usagestr[] = "usage: audioctl [-nq] [-f path] [name=[value]] ...\n";
@


1.30
log
@Display play and record parameters that are not independent
as a single variable (this corresponds to the way the audio
driver handles them). As we're at it, drop unused/duplicate
parameters.

ok mpi
@
text
@d1 1
a1 3
/*	$OpenBSD: audioctl.c,v 1.28 2015/05/26 18:17:12 ratchov Exp $	*/
/*	$NetBSD: audioctl.c,v 1.14 1998/04/27 16:55:23 augustss Exp $	*/

d3 1
a3 4
 * Copyright (c) 1997 The NetBSD Foundation, Inc.
 * All rights reserved.
 *
 * Author: Lennart Augustsson
d5 3
a7 8
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
d9 7
a15 11
 * THIS SOFTWARE IS PROVIDED BY THE NETBSD FOUNDATION, INC. AND CONTRIBUTORS
 * ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
 * TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE FOUNDATION OR CONTRIBUTORS
 * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
d17 5
a21 5

/*
 * audioctl(1) - a program to control audio device.
 */

a23 2
#include <fcntl.h>
#include <err.h>
d26 1
a26 4
#include <sys/types.h>
#include <sys/stat.h>
#include <sys/ioctl.h>
#include <sys/audioio.h>
d28 4
a31 8
struct field *findfield(char *name);
void prfield(struct field *p, const char *sep);
void rdfield(struct field *p, char *q);
void getinfo(int fd);
void usage(void);
int main(int argc, char **argv);

FILE *out = stdout;
d33 4
a36 11
audio_device_t adev;

audio_info_t info;

char encbuf[1000];

int properties, fullduplex;

struct audio_pos getpos;

unsigned int block_size;
d39 8
a46 16
	const char *name;
	void *valp;
	int format;
#define STRING 1
#define INT 2
#define UINT 3
#define P_R 4
#define UCHAR 6
#define ENC 7
#define PROPS 8
#define XINT 9
	char flags;
#define READONLY 1
#define ALIAS 2
#define SET 4
	u_int oldval;
d48 15
a62 20
	{ "name", 		&adev.name, 		STRING, READONLY },
	{ "encodings",		encbuf,			STRING, READONLY },
	{ "properties",		&properties,		PROPS,	READONLY },
	{ "hiwat",		&info.hiwat,		UINT,	0 },
	{ "mode",		&info.mode,		P_R,	READONLY },
	{ "rate",		&info.play.sample_rate,	UINT,	0 },
	{ "precision",		&info.play.precision,	UINT,	0 },
	{ "bps",		&info.play.bps,		UINT,	0 },
	{ "msb",		&info.play.msb,		UINT,	0 },
	{ "encoding",		&info.play.encoding,	ENC,	0 },
	{ "pause",		&info.play.pause,	UCHAR,	0 },
	{ "active",		&info.play.active,	UCHAR,	READONLY },
	{ "block_size",		&block_size,		UINT,	0 },
	{ "play.channels",	&info.play.channels,	UINT,	0 },
	{ "play.bytes",		&getpos.play_pos,	UINT,	READONLY },
	{ "play.errors",	&getpos.play_xrun,	UINT,	READONLY },
	{ "record.channels",	&info.record.channels,	UINT,	0 },
	{ "record.bytes",	&getpos.rec_pos,	UINT,	READONLY },
	{ "record.errors",	&getpos.rec_xrun,	UINT,	READONLY },
	{ 0 }
d65 1
a65 18
struct {
	const char *ename;
	u_int eno;
} encs[] = {
	{ AudioEmulaw,		AUDIO_ENCODING_ULAW },
	{ "ulaw",		AUDIO_ENCODING_ULAW },
	{ AudioEalaw, 		AUDIO_ENCODING_ALAW },
	{ AudioEslinear,	AUDIO_ENCODING_SLINEAR },
	{ "linear",		AUDIO_ENCODING_SLINEAR },
	{ AudioEulinear,	AUDIO_ENCODING_ULINEAR },
	{ AudioEslinear_le,	AUDIO_ENCODING_SLINEAR_LE },
	{ "linear_le",		AUDIO_ENCODING_SLINEAR_LE },
	{ AudioEulinear_le,	AUDIO_ENCODING_ULINEAR_LE },
	{ AudioEslinear_be,	AUDIO_ENCODING_SLINEAR_BE },
	{ "linear_be",		AUDIO_ENCODING_SLINEAR_BE },
	{ AudioEulinear_be,	AUDIO_ENCODING_ULINEAR_BE },
	{ 0 }
};
d67 6
a72 12
static struct {
	const char *name;
	u_int prop;
} props[] = {
	{ "full_duplex",	AUDIO_PROP_FULLDUPLEX },
	{ "mmap",		AUDIO_PROP_MMAP },
	{ "independent",	AUDIO_PROP_INDEPENDENT },
	{ 0 }
};

struct field *
findfield(char *name)
d74 18
a91 6
	int i;
	for (i = 0; fields[i].name; i++)
		if (strcmp(fields[i].name, name) == 0)
			return &fields[i];
	return (0);
}
d93 37
a129 56
static void
prval(u_int format, void *valp)
{
	u_int v;
	const char *cm;
	int i;

	switch (format) {
	case STRING:
		fprintf(out, "%s", (char *)valp);
		break;
	case INT:
		fprintf(out, "%d", *(int *)valp);
		break;
	case UINT:
		fprintf(out, "%u", *(u_int *)valp);
		break;
	case XINT:
		fprintf(out, "0x%x", *(u_int *)valp);
		break;
	case UCHAR:
		fprintf(out, "%u", *(u_char *)valp);
		break;
	case P_R:
		v = *(u_int *)valp;
		cm = "";
		if (v & AUMODE_PLAY) {
			fprintf(out, "play");
			cm = ",";
		}
		if (v & AUMODE_RECORD)
			fprintf(out, "%srecord", cm);
		break;
	case ENC:
		v = *(u_int *)valp;
		for (i = 0; encs[i].ename; i++)
			if (encs[i].eno == v)
				break;
		if (encs[i].ename)
			fprintf(out, "%s", encs[i].ename);
		else
			fprintf(out, "%u", v);
		break;
	case PROPS:
		v = *(u_int *)valp;
		for (cm = "", i = 0; props[i].name; i++) {
			if (v & props[i].prop) {
				fprintf(out, "%s%s", cm, props[i].name);
				cm = ",";
			}
		}
		break;
	default:
		errx(1, "Invalid print format.");
	}
}
d131 2
a132 14
void
prfield(struct field *p, const char *sep)
{
	if (sep) {
		fprintf(out, "%s", p->name);
		if (p->flags & SET) {
			fprintf(out, "%s", ": ");
			prval(p->format, &p->oldval);
			fprintf(out, " -> ");
		} else
			fprintf(out, "%s", sep);
	}
	prval(p->format, p->valp);
	fprintf(out, "\n");
d136 1
a136 1
rdfield(struct field *p, char *q)
d138 2
a139 2
	int i;
	u_int u;
d141 15
a155 22
	switch (p->format) {
	case UINT:
		p->oldval = *(u_int *)p->valp;
		if (sscanf(q, "%u", (unsigned int *)p->valp) != 1) {
			warnx("Bad number %s", q);
			return;
		}
		break;
	case UCHAR:
		*(char *)&p->oldval = *(u_char *)p->valp;
		if (sscanf(q, "%u", &u) != 1) {
			warnx("Bad number %s", q);
			return;
		}
		*(u_char *)p->valp = u;
		break;
	case XINT:
		p->oldval = *(u_int *)p->valp;
		if (sscanf(q, "0x%x", (unsigned int *)p->valp) != 1 &&
		    sscanf(q, "%x", (unsigned int *)p->valp) != 1) {
			warnx("Bad number %s", q);
			return;
d159 9
a167 9
		p->oldval = *(u_int *)p->valp;
		for (i = 0; encs[i].ename; i++)
			if (strcmp(encs[i].ename, q) == 0)
				break;
		if (encs[i].ename)
			*(u_int*)p->valp = encs[i].eno;
		else {
			warnx("Unknown encoding: %s", q);
			return;
a168 3
		break;
	default:
		errx(1, "Invalid read format.");
a169 1
	p->flags |= SET;
d173 1
a173 1
getinfo(int fd)
d175 1
a175 1
	int pos = 0, i = 0;
d177 9
a185 13
	if (ioctl(fd, AUDIO_GETDEV, &adev) < 0)
		err(1, "AUDIO_GETDEV");
	for (;;) {
		audio_encoding_t enc;
		enc.index = i++;
		if (ioctl(fd, AUDIO_GETENC, &enc) < 0)
			break;
		if (pos)
			encbuf[pos++] = ',';
		snprintf(encbuf+pos, sizeof(encbuf)-pos, "%s:%d:%d:%d%s",
		    enc.name, enc.precision, enc.bps, enc.msb,
		    enc.flags & AUDIO_ENCODINGFLAG_EMULATED ? "*" : "");
		pos += strlen(encbuf+pos);
a186 26
	if (ioctl(fd, AUDIO_GETFD, &fullduplex) < 0)
		err(1, "AUDIO_GETFD");
	if (ioctl(fd, AUDIO_GETPROPS, &properties) < 0)
		err(1, "AUDIO_GETPROPS");
	if (ioctl(fd, AUDIO_GETPROPS, &properties) < 0)
		err(1, "AUDIO_GETPROPS");
	if (ioctl(fd, AUDIO_GETINFO, &info) < 0)
		err(1, "AUDIO_GETINFO");
	if (ioctl(fd, AUDIO_GETPOS, &getpos) < 0)
		err(1, "AUDIO_GETPOS");
	block_size = info.play.block_size /
	    (info.play.channels * info.play.bps);
}

void
usage(void)
{
	extern char *__progname;		/* from crt0.o */

	fprintf(stderr,
	    "usage: %s [-an] [-f file]\n"
	    "       %s [-n] [-f file] name ...\n"
	    "       %s [-n] [-f file] name=value ...\n",
	    __progname, __progname, __progname);

	exit(1);
d192 7
a198 17
	int fd, i, ch;
	int aflag = 0, canwrite, writeinfo = 0;
	struct stat dstat, ostat;
	struct field *p;
	const char *file;
	const char *sep = "=";
    
	if ((file = getenv("AUDIOCTLDEVICE")) == 0 || *file == '\0')
		file = "/dev/audioctl";
    
	while ((ch = getopt(argc, argv, "af:nw")) != -1) {
		switch (ch) {
		case 'a':
			aflag = 1;
			break;
		case 'w':
			/* backward compatibility */
d201 1
a201 1
			sep = 0;
d204 4
a207 1
			file = optarg;
d210 2
a211 1
			usage();
d217 16
a232 31
	if (argc == 0)
		aflag = 1;

	if ((fd = open(file, O_RDWR)) < 0) {
		if ((fd = open(file, O_RDONLY)) < 0)
			err(1, "%s", file);
		canwrite = 0;
	} else
		canwrite = 1;
    
	/* Check if stdout is the same device as the audio device. */
	if (fstat(fd, &dstat) < 0)
		err(1, "fstat au");
	if (fstat(STDOUT_FILENO, &ostat) < 0)
		err(1, "fstat stdout");
	if (S_ISCHR(dstat.st_mode) && S_ISCHR(ostat.st_mode) &&
	    major(dstat.st_dev) == major(ostat.st_dev) &&
	    minor(dstat.st_dev) == minor(ostat.st_dev))
		/* We can't write to stdout so use stderr */
		out = stderr;

	if (!argc && !aflag)
		usage();

	getinfo(fd);

	if (aflag) {
		for (i = 0; fields[i].name; i++) {
			if (!(fields[i].flags & ALIAS)) {
				prfield(&fields[i], sep);
			}
d234 12
a245 33
	} else {
		while (argc--) {
			char *q;
		
			if ((q = strchr(*argv, '=')) != NULL) {
				*q++ = 0;
				p = findfield(*argv);
				if (p == 0)
					warnx("field `%s' does not exist", *argv);
				else {
					if (!canwrite)
						errx(1, "%s: permission denied",
						    *argv);
					if (p->flags & READONLY)
						warnx("`%s' is read only", *argv);
					else {
						rdfield(p, q);
						if (p->valp == &fullduplex)
							if (ioctl(fd, AUDIO_SETFD,
							    &fullduplex) < 0)
								err(1, "set failed");
					}
					writeinfo = 1;
				}
			} else {
				p = findfield(*argv);
				if (p == 0)
					warnx("field %s does not exist", *argv);
				else {
					prfield(p, sep);
				}
			}
			argv++;
d247 11
a257 12
		if (writeinfo) {
			info.record.sample_rate = info.play.sample_rate;
			info.record.encoding = info.play.encoding;
			info.record.precision = info.play.precision;
			info.record.bps = info.play.bps;
			info.record.msb = info.play.msb;
			info.record.block_size = block_size *
				info.record.bps * info.record.channels;
			info.play.block_size = block_size *
				info.play.bps * info.play.channels;
			if (ioctl(fd, AUDIO_SETINFO, &info) < 0)
				err(1, "set failed");
d259 14
a272 5
		getinfo(fd);
		for (i = 0; fields[i].name; i++) {
			if (fields[i].flags & SET) {
				prfield(&fields[i], sep);
			}
d274 2
d277 1
a277 1
	exit(0);
@


1.29
log
@Use new AUDIO_GETPOS ioctl() to ensure "bytes" and "errors" counters
are consistent.
@
text
@d66 2
a89 1
	{ "lowat",		&info.lowat,		UINT,	0 },
d91 8
a98 2
	{ "play.rate",		&info.play.sample_rate,	UINT,	0 },
	{ "play.sample_rate",	&info.play.sample_rate,	UINT,	ALIAS },
a99 7
	{ "play.precision",	&info.play.precision,	UINT,	0 },
	{ "play.bps",		&info.play.bps,		UINT,	0 },
	{ "play.msb",		&info.play.msb,		UINT,	0 },
	{ "play.encoding",	&info.play.encoding,	ENC,	0 },
	{ "play.pause",		&info.play.pause,	UCHAR,	0 },
	{ "play.active",	&info.play.active,	UCHAR,	READONLY },
	{ "play.block_size",	&info.play.block_size,	UINT,	0 },
a101 2
	{ "record.rate",	&info.record.sample_rate,UINT,	0 },
	{ "record.sample_rate",	&info.record.sample_rate,UINT,	ALIAS },
a102 7
	{ "record.precision",	&info.record.precision,	UINT,	0 },
	{ "record.bps",		&info.record.bps,	UINT,	0 },
	{ "record.msb",		&info.record.msb,	UINT,	0 },
	{ "record.encoding",	&info.record.encoding,	ENC,	0 },
	{ "record.pause",	&info.record.pause,	UCHAR,	0 },
	{ "record.active",	&info.record.active,	UCHAR,	READONLY },
	{ "record.block_size",	&info.record.block_size,UINT,	0 },
d297 2
d415 13
a427 2
		if (writeinfo && ioctl(fd, AUDIO_SETINFO, &info) < 0)
			err(1, "set failed");
@


1.28
log
@Exposes number of bytes processed by the sound card (as returned
by AUDIO_GET{I,O}OFFS) instead of the number of bytes processed
minus the xruns (as returned by AUDIO_GETINFO).

ok armani
@
text
@d1 1
a1 1
/*	$OpenBSD: audioctl.c,v 1.27 2015/05/16 12:51:24 ratchov Exp $	*/
d62 1
a62 1
int properties, fullduplex, perrors, rerrors;
d64 1
a64 1
struct audio_offset poffs, roffs;
d100 2
a101 2
	{ "play.bytes",		&poffs.samples,		INT,	READONLY },
	{ "play.errors",	&perrors,		INT,	READONLY },
d112 2
a113 2
	{ "record.bytes",	&roffs.samples,		INT,	READONLY },
	{ "record.errors",	&rerrors,		INT,	READONLY },
d300 2
a301 8
	if (ioctl(fd, AUDIO_PERROR, &perrors) < 0)
		err(1, "AUDIO_PERROR");
	if (ioctl(fd, AUDIO_RERROR, &rerrors) < 0)
		err(1, "AUDIO_RERROR");
	if (ioctl(fd, AUDIO_GETOOFFS, &poffs) < 0)
		err(1, "AUDIO_GETOOFFS");
	if (ioctl(fd, AUDIO_GETIOFFS, &roffs) < 0)
		err(1, "AUDIO_GETOIFFS");
d304 2
@


1.27
log
@Display simply "play" when play mode is set (furthermore, "playsync",
aka PLAY_ALL mode is not used anymore)
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d64 2
a96 1
	{ "play.samples",	&info.play.samples,	UINT,	READONLY },
d100 1
a108 1
	{ "record.samples",	&info.record.samples,	UINT,	READONLY },
d112 1
d304 4
@


1.26
log
@remove reference to encodings the kernel doesn't expose anymore
@
text
@d181 1
a181 4
			if (v & AUMODE_PLAY_ALL)
				fprintf(out, "play");
			else
				fprintf(out, "playsync");
@


1.25
log
@in getopt() blocks, stop incrementing flag variable which are supposed
to just be 0/1
ok miod florian
@
text
@d1 1
a1 1
/*	$OpenBSD: audioctl.c,v 1.24 2014/09/23 06:47:37 ratchov Exp $	*/
a124 2
	{ AudioEadpcm,		AUDIO_ENCODING_ADPCM },
	{ "ADPCM",		AUDIO_ENCODING_ADPCM },
a130 6
	{ AudioEmpeg_l1_stream,	AUDIO_ENCODING_MPEG_L1_STREAM },
	{ AudioEmpeg_l1_packets,AUDIO_ENCODING_MPEG_L1_PACKETS },
	{ AudioEmpeg_l1_system,	AUDIO_ENCODING_MPEG_L1_SYSTEM },
	{ AudioEmpeg_l2_stream,	AUDIO_ENCODING_MPEG_L2_STREAM },
	{ AudioEmpeg_l2_packets,AUDIO_ENCODING_MPEG_L2_PACKETS },
	{ AudioEmpeg_l2_system,	AUDIO_ENCODING_MPEG_L2_SYSTEM },
@


1.24
log
@Hide unused, duplicate and/or misleading fields.

ok armani, shadchin, kspillner
@
text
@d1 1
a1 1
/*	$OpenBSD: audioctl.c,v 1.23 2013/11/13 18:50:05 deraadt Exp $	*/
d347 1
a347 1
			aflag++;
d366 1
a366 1
		aflag++;
@


1.23
log
@handle missing proto
@
text
@d1 1
a1 1
/*	$OpenBSD: audioctl.c,v 1.22 2012/07/27 00:21:17 krw Exp $	*/
a82 2
	{ "version",		&adev.version,		STRING, READONLY },
	{ "config",		&adev.config,		STRING, READONLY },
a84 3
	{ "full_duplex",	&fullduplex,		UINT,	0 },
	{ "fullduplex",		&fullduplex,		UINT,	0 },
	{ "blocksize",		&info.blocksize,	UINT,	0 },
a86 2
	{ "output_muted",	&info.output_muted,	UCHAR,	0 },
	{ "monitor_gain",	&info.monitor_gain,	UINT,	0 },
a94 5
	{ "play.gain",		&info.play.gain,	UINT,	0 },
	{ "play.balance",	&info.play.balance,	UCHAR,	0 },
	{ "play.port",		&info.play.port,	XINT,	0 },
	{ "play.avail_ports",	&info.play.avail_ports,	XINT,	0 },
	{ "play.seek",		&info.play.seek,	UINT,	READONLY },
a95 1
	{ "play.eof",		&info.play.eof,		UINT,	READONLY },
a96 3
	{ "play.error",		&info.play.error,	UCHAR,	READONLY },
	{ "play.waiting",	&info.play.waiting,	UCHAR,	READONLY },
	{ "play.open",		&info.play.open,	UCHAR,	READONLY },
a97 1
	{ "play.buffer_size",	&info.play.buffer_size,	UINT,	0 },
a106 5
	{ "record.gain",	&info.record.gain,	UINT,	0 },
	{ "record.balance",	&info.record.balance,	UCHAR,	0 },
	{ "record.port",	&info.record.port,	XINT,	0 },
	{ "record.avail_ports",	&info.record.avail_ports,XINT,	0 },
	{ "record.seek",	&info.record.seek,	UINT,	READONLY },
a107 1
	{ "record.eof",		&info.record.eof,	UINT,	READONLY },
a108 3
	{ "record.error",	&info.record.error,	UCHAR,	READONLY },
	{ "record.waiting",	&info.record.waiting,	UCHAR,	READONLY },
	{ "record.open",	&info.record.open,	UCHAR,	READONLY },
a109 1
	{ "record.buffer_size",	&info.record.buffer_size,UINT,	0 },
@


1.22
log
@Fix initializer botch introduced in r1.20 when 'oldval' field was
added into middle of struct field (sic), without adding appropriate
initializer values. Move field to end of struct and let 0 be it's
value.

Spotted and diff from David Julio.
@
text
@d1 1
a1 1
/*	$OpenBSD: audioctl.c,v 1.21 2010/07/15 03:43:12 jakemsr Exp $	*/
d189 1
a189 1
void
@


1.21
log
@add two new members to structs audio_encoding and audio_prinfo.
for both structs, the new members are 'bps' and 'msb', which
describe the number of bytes per sample and data alignment in the
sample, respectively.  drivers must properly set these fields in
the 'query_encoding', 'set_parameters' and 'get_default_params'
hardware interface methods.

discussed with ratchov, deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: audioctl.c,v 1.20 2009/11/12 07:32:26 ratchov Exp $	*/
a67 1
	u_int oldval;
d80 1
@


1.20
log
@When values are changed, log the change in the ``name: old -> new''
format, as mixerctl does. If -n is used log the new value only.
from Pawlowski Marcin Piotr <pmp.openbsd at gmail.com>, thanks.
ok jakemsr
@
text
@d1 1
a1 1
/*	$OpenBSD: audioctl.c,v 1.19 2008/06/26 05:42:20 ray Exp $	*/
d99 2
d121 2
d327 2
a328 2
		snprintf(encbuf+pos, sizeof(encbuf)-pos, "%s:%d%s",
		    enc.name, enc.precision,
@


1.19
log
@First pass at removing clauses 3 and 4 from NetBSD licenses.

Not sure what's more surprising: how long it took for NetBSD to
catch up to the rest of the BSDs (including UCB), or the amount of
code that NetBSD has claimed for itself without attributing to the
actual authors.

OK deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: audioctl.c,v 1.18 2008/04/25 06:43:49 jakemsr Exp $	*/
d68 1
a72 1
#define ULONG 5
d186 1
a186 1
prfield(struct field *p, const char *sep)
d192 1
a192 3
	if (sep)
		fprintf(out, "%s%s", p->name, sep);
	switch (p->format) {
d194 1
a194 1
		fprintf(out, "%s", (char*)p->valp);
d197 1
a197 1
		fprintf(out, "%d", *(int*)p->valp);
d200 1
a200 1
		fprintf(out, "%u", *(u_int*)p->valp);
d203 1
a203 1
		fprintf(out, "0x%x", *(u_int*)p->valp);
d206 1
a206 4
		fprintf(out, "%u", *(u_char*)p->valp);
		break;
	case ULONG:
		fprintf(out, "%lu", *(u_long*)p->valp);
d209 1
a209 1
		v = *(u_int*)p->valp;
d222 1
a222 1
		v = *(u_int*)p->valp;
d232 1
a232 1
		v = *(u_int*)p->valp;
d246 16
d269 2
a270 1
		if (sscanf(q, "%u", (unsigned int *)p->valp) != 1)
d272 2
d276 2
a277 1
		if (sscanf(q, "%u", &u) != 1)
d279 3
a281 2
		else
			*(u_char *)p->valp = u;
d284 1
d286 1
a286 1
		    sscanf(q, "%x", (unsigned int *)p->valp) != 1)
d288 2
d292 1
d298 1
a298 1
		else
d300 2
a417 1
				fprintf(out, "\n");
a449 1
					fprintf(out, "\n");
d456 4
a459 8
		if (sep) {
			getinfo(fd);
			for (i = 0; fields[i].name; i++) {
				if (fields[i].flags & SET) {
					fprintf(out, "%s: -> ", fields[i].name);
					prfield(&fields[i], 0);
					fprintf(out, "\n");
				}
@


1.18
log
@
display count of playback frame errors (underruns) in play.errors like we
do with record.errors for recording (overruns).

ok ratchov
@
text
@d1 1
a1 1
/*	$OpenBSD: audioctl.c,v 1.17 2008/03/22 11:05:31 ratchov Exp $	*/
a17 7
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *        This product includes software developed by the NetBSD
 *        Foundation, Inc. and its contributors.
 * 4. Neither the name of The NetBSD Foundation nor the names of its
 *    contributors may be used to endorse or promote products derived
 *    from this software without specific prior written permission.
@


1.17
log
@add audio(4) driver the ability to use different block sizes for play and
record modes. This makes possible to have blocks of the same duration if the
play and record formats are different. The API change is backward
compatible, so it shouldn't be noticed by current audio ports.

ok jakemsr
@
text
@d1 1
a1 1
/*	$OpenBSD: audioctl.c,v 1.16 2007/11/26 13:36:34 deraadt Exp $	*/
d69 1
a69 1
int properties, fullduplex, rerror;
d121 1
d141 1
a141 1
	{ "record.errors",	&rerror,		INT,	READONLY },
d317 3
a319 1
	if (ioctl(fd, AUDIO_RERROR, &rerror) < 0)
@


1.16
log
@if no arguments given, assume a nice default; ok miod jakemsr deanna
@
text
@d1 1
a1 1
/*	$OpenBSD: audioctl.c,v 1.15 2007/09/27 21:55:54 sobrado Exp $	*/
d120 1
d139 1
@


1.15
log
@style(9) fixes, optional flags without arguments come first;
while here, some spacing fixes

ok deanna@@, jakemsr@@
@
text
@d1 1
a1 1
/*	$OpenBSD: audioctl.c,v 1.14 2007/09/17 13:46:11 jakemsr Exp $	*/
d326 1
a326 1
	    "usage: %s [-n] [-f file] -a\n"
d367 3
@


1.14
log
@implement the output_muted member of audio_info_t as found in original
Sun audio.

input from and ok ratchov
@
text
@d1 1
a1 1
/*	$OpenBSD: audioctl.c,v 1.13 2007/08/06 19:16:06 sobrado Exp $	*/
d183 1
a183 1
	for(i = 0; fields[i].name; i++)
d198 1
a198 1
	switch(p->format) {
d232 1
a232 1
		for(i = 0; encs[i].ename; i++)
d260 1
a260 1
	switch(p->format) {
d277 1
a277 1
		for(i = 0; encs[i].ename; i++)
d298 1
a298 1
	for(;;) {
d326 4
a329 4
	    "usage: %s [-f file] [-n] -a\n"
	    "       %s [-f file] [-n] name ...\n"
	    "       %s [-f file] [-n] name=value ...\n", __progname,
		__progname, __progname);
d348 1
a348 1
		switch(ch) {
@


1.13
log
@the ellipsis is not an optional argument; while here, sync the usage
and synopsis of commands

lots of good ideas by jmc@@

ok jmc@@
@
text
@d1 1
a1 1
/*	$OpenBSD: audioctl.c,v 1.12 2006/03/14 19:36:44 moritz Exp $	*/
d99 1
@


1.12
log
@More use of const and fix a signed/unsigned comparison.
From David Hill. ok ray@@ jaredy@@
@
text
@d1 1
a1 1
/*	$OpenBSD: audioctl.c,v 1.11 2004/07/06 02:46:06 vincent Exp $	*/
d326 2
a327 2
	    "       %s [-f file] [-n] name [...]\n"
	    "       %s [-f file] [-n] name=value [...]\n", __progname,
@


1.11
log
@make -w optional to set options, so audioctl is consistent with
"new" sysctl/mixerctl

ok millert@@, "go for it" deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: audioctl.c,v 1.10 2003/06/21 01:39:07 deraadt Exp $	*/
d55 1
a55 1
void prfield(struct field *p, char *sep);
d72 1
a72 1
	char *name;
d142 2
a143 2
	char *ename;
	int eno;
d169 1
a169 1
	char *name;
d189 1
a189 1
prfield(struct field *p, char *sep)
d192 1
a192 1
	char *cm;
d340 2
a341 2
	char *file;
	char *sep = "=";
@


1.10
log
@()
@
text
@d1 1
a1 1
/*	$OpenBSD: audioctl.c,v 1.9 2003/04/16 01:36:39 deraadt Exp $	*/
d327 1
a327 1
	    "       %s [-f file] [-n] -w name=value [...]\n", __progname,
d337 1
a337 1
	int aflag = 0, wflag = 0;
d339 1
d352 1
a352 1
			wflag++;
a359 1
		case '?':
d366 7
a372 3
    
	if ((fd = open(file, wflag ? O_RDWR : O_RDONLY)) < 0)
		err(1, "%s", file);
d385 4
a388 2
	if (!wflag)
		getinfo(fd);
d390 2
a391 2
	if (!argc && aflag && !wflag) {
		for(i = 0; fields[i].name; i++) {
d397 3
a399 6
	} else if (argc > 0 && !aflag) {
		struct field *p;
		if (wflag) {
			AUDIO_INITINFO(&info);
			while(argc--) {
				char *q;
d401 11
a411 5
				if ((q = strchr(*argv, '='))) {
					*q++ = 0;
					p = findfield(*argv);
					if (p == 0)
						warnx("field `%s' does not exist", *argv);
d413 5
a417 22
						if (p->flags & READONLY)
							warnx("`%s' is read only", *argv);
						else {
							rdfield(p, q);
							if (p->valp == &fullduplex)
								if (ioctl(fd, AUDIO_SETFD, &fullduplex) < 0)
									err(1, "set failed");
						}
					}
				} else
					warnx("No `=' in %s", *argv);
				argv++;
			}
			if (ioctl(fd, AUDIO_SETINFO, &info) < 0)
				err(1, "set failed");
			if (sep) {
				getinfo(fd);
				for(i = 0; fields[i].name; i++) {
					if (fields[i].flags & SET) {
						fprintf(out, "%s: -> ", fields[i].name);
						prfield(&fields[i], 0);
						fprintf(out, "\n");
d419 1
d421 1
a421 3
			}
		} else {
			while(argc--) {
d423 3
a425 6
				if (p == 0) {
					if (strchr(*argv, '='))
						warnx("field %s does not exist (use -w to set a variable)", *argv);
					else
						warnx("field %s does not exist", *argv);
				} else {
d429 13
a441 1
				argv++;
d444 1
a444 2
	} else
		usage();
@


1.9
log
@kill += snprintf
@
text
@d1 1
a1 1
/*	$OpenBSD: audioctl.c,v 1.8 2002/12/13 16:36:52 naddy Exp $	*/
d398 1
a398 1
				if (q = strchr(*argv, '=')) {
@


1.8
log
@audio_prinfo.seek is int now; document and sync
ok miod@@ millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: audioctl.c,v 1.7 2002/12/10 09:03:37 pvalchev Exp $	*/
d298 10
a307 9
	       audio_encoding_t enc;
	       enc.index = i++;
	       if (ioctl(fd, AUDIO_GETENC, &enc) < 0)
		       break;
	       if (pos)
		       encbuf[pos++] = ',';
	       pos += snprintf(encbuf+pos, sizeof(encbuf)-pos, "%s:%d%s",
			       enc.name, enc.precision,
	            	       enc.flags & AUDIO_ENCODINGFLAG_EMULATED ? "*" : "");
@


1.7
log
@ansi, KNF, other style(9) improvements and logic simplification; andrushock@@korovino.net
@
text
@d1 1
a1 1
/*	$OpenBSD: audioctl.c,v 1.6 2002/02/16 21:27:44 millert Exp $	*/
d110 1
a110 1
	{ "play.seek",		&info.play.seek,	ULONG,	READONLY },
d128 1
a128 1
	{ "record.seek",	&info.record.seek,	ULONG,	READONLY },
@


1.6
log
@Part one of userland __P removal.  Done with a simple regexp with some minor hand editing to make comments line up correctly.  Another pass is forthcoming that handles the cases that could not be done automatically.
@
text
@d1 1
a1 1
/*	$OpenBSD: audioctl.c,v 1.5 2000/11/21 13:58:06 aaron Exp $	*/
d39 4
a62 2
char *prog;

d179 1
a179 2
findfield(name)
	char *name;
d185 1
a185 1
	return 0;
d189 1
a189 3
prfield(p, sep)
	struct field *p;
	char *sep;
d254 1
a254 3
rdfield(p, q)
	struct field *p;
	char *q;
d291 1
a291 2
getinfo(fd)
	int fd;
d293 1
a293 1
	int pos, i;
d297 10
a306 11
	for(pos = 0, i = 0; ; i++) {
		audio_encoding_t enc;
		enc.index = i;
		if (ioctl(fd, AUDIO_GETENC, &enc) < 0)
			break;
		if (pos)
			encbuf[pos++] = ',';
		sprintf(encbuf+pos, "%s:%d%s", enc.name, 
			enc.precision, 
			enc.flags & AUDIO_ENCODINGFLAG_EMULATED ? "*" : "");
		pos += strlen(encbuf+pos);
d319 1
a319 1
usage()
d321 8
a328 3
	fprintf(out, "%s [-n] [-f file] -a\n", prog);
	fprintf(out, "%s [-n] [-f file] name [...]\n", prog);
	fprintf(out, "%s [-n] [-f file] -w name=value [...]\n", prog);
d333 1
a333 3
main(argc, argv)
	int argc;
	char **argv;
d341 1
a341 2
	file = getenv("AUDIOCTLDEVICE");
	if (file == 0)
a342 2

	prog = *argv;
d366 1
a366 4
	fd = open(file, O_WRONLY);
	if (fd < 0)
		fd = open(file, O_RDONLY);
	if (fd < 0)
d383 1
a383 1
	if (argc == 0 && aflag && !wflag) {
d397 1
a397 2
				q = strchr(*argv, '=');
				if (q) {
@


1.5
log
@Sync usage() output and man page; mpech@@prosoft.org.lv
@
text
@d1 1
a1 1
/*	$OpenBSD: audioctl.c,v 1.4 1998/07/15 22:10:47 deraadt Exp $	*/
d50 6
a55 6
struct field *findfield __P((char *name));
void prfield __P((struct field *p, char *sep));
void rdfield __P((struct field *p, char *q));
void getinfo __P((int fd));
void usage __P((void));
int main __P((int argc, char **argv));
@


1.4
log
@fullduplex, and UINT
@
text
@d1 1
a1 1
/*	$OpenBSD: audioctl.c,v 1.3 1998/04/30 13:46:18 provos Exp $	*/
d326 3
a328 3
	fprintf(out, "%s [-f file] [-n] name ...\n", prog);
	fprintf(out, "%s [-f file] [-n] -w name=value ...\n", prog);
	fprintf(out, "%s [-f file] [-n] -a\n", prog);
@


1.3
log
@From NetBSD: Lennart Augustsson
environment variable for default audioctl device
@
text
@d1 1
a1 1
/*	$OpenBSD: audioctl.c,v 1.2 1998/04/26 22:27:25 provos Exp $	*/
d92 2
a93 1
	{ "full_duplex",	&fullduplex,		INT,    0 },
@


1.2
log
@$OpenBSD$
@
text
@d1 2
a2 2
/*	$OpenBSD$	*/
/*	$NetBSD: audioctl.c,v 1.12 1997/10/19 07:44:12 augustss Exp $	*/
d40 1
d339 1
a339 1
	char *file = "/dev/audioctl";
d342 4
@


1.1
log
@Initial revision
@
text
@d1 1
@


1.1.1.1
log
@audioctl from NetBSD, mostly by Lennart Augustsson <augustss@@cs.chalmers.se>
@
text
@@
