head	1.17;
access;
symbols
	OPENBSD_4_8:1.16.0.4
	OPENBSD_4_8_BASE:1.16
	OPENBSD_4_7:1.16.0.2
	OPENBSD_4_7_BASE:1.16
	OPENBSD_4_6:1.15.0.12
	OPENBSD_4_6_BASE:1.15
	OPENBSD_4_5:1.15.0.8
	OPENBSD_4_5_BASE:1.15
	OPENBSD_4_4:1.15.0.6
	OPENBSD_4_4_BASE:1.15
	OPENBSD_4_3:1.15.0.4
	OPENBSD_4_3_BASE:1.15
	OPENBSD_4_2:1.15.0.2
	OPENBSD_4_2_BASE:1.15
	OPENBSD_4_1:1.14.0.8
	OPENBSD_4_1_BASE:1.14
	OPENBSD_4_0:1.14.0.6
	OPENBSD_4_0_BASE:1.14
	OPENBSD_3_9:1.14.0.4
	OPENBSD_3_9_BASE:1.14
	OPENBSD_3_8:1.14.0.2
	OPENBSD_3_8_BASE:1.14
	OPENBSD_3_7:1.13.0.2
	OPENBSD_3_7_BASE:1.13
	OPENBSD_3_6:1.12.0.2
	OPENBSD_3_6_BASE:1.12
	OPENBSD_3_5:1.11.0.4
	OPENBSD_3_5_BASE:1.11
	OPENBSD_3_4:1.11.0.2
	OPENBSD_3_4_BASE:1.11
	OPENBSD_3_3:1.7.0.6
	OPENBSD_3_3_BASE:1.7
	OPENBSD_3_2:1.7.0.4
	OPENBSD_3_2_BASE:1.7
	OPENBSD_3_1:1.7.0.2
	OPENBSD_3_1_BASE:1.7
	OPENBSD_3_0:1.6.0.2
	OPENBSD_3_0_BASE:1.6
	OPENBSD_2_9_BASE:1.4
	OPENBSD_2_9:1.4.0.2
	OPENBSD_2_8:1.2.0.18
	OPENBSD_2_8_BASE:1.2
	OPENBSD_2_7:1.2.0.16
	OPENBSD_2_7_BASE:1.2
	OPENBSD_2_6:1.2.0.14
	OPENBSD_2_6_BASE:1.2
	OPENBSD_2_5:1.2.0.12
	OPENBSD_2_5_BASE:1.2
	OPENBSD_2_4:1.2.0.10
	OPENBSD_2_4_BASE:1.2
	OPENBSD_2_3:1.2.0.8
	OPENBSD_2_3_BASE:1.2
	OPENBSD_2_2:1.2.0.6
	OPENBSD_2_2_BASE:1.2
	OPENBSD_2_1:1.2.0.4
	OPENBSD_2_1_BASE:1.2
	OPENBSD_2_0:1.2.0.2
	OPENBSD_2_0_BASE:1.2
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.17
date	2010.10.29.14.47.15;	author millert;	state dead;
branches;
next	1.16;

1.16
date	2009.10.27.23.59.36;	author deraadt;	state Exp;
branches;
next	1.15;

1.15
date	2007.06.27.03.29.31;	author ray;	state Exp;
branches;
next	1.14;

1.14
date	2005.03.29.23.46.19;	author jaredy;	state Exp;
branches;
next	1.13;

1.13
date	2005.03.08.23.31.53;	author cloder;	state Exp;
branches;
next	1.12;

1.12
date	2004.07.01.19.20.23;	author mickey;	state Exp;
branches;
next	1.11;

1.11
date	2003.06.25.21.09.09;	author deraadt;	state Exp;
branches;
next	1.10;

1.10
date	2003.06.10.22.20.45;	author deraadt;	state Exp;
branches;
next	1.9;

1.9
date	2003.06.03.02.56.06;	author millert;	state Exp;
branches;
next	1.8;

1.8
date	2003.04.03.22.09.04;	author deraadt;	state Exp;
branches;
next	1.7;

1.7
date	2001.11.19.19.02.13;	author mpech;	state Exp;
branches;
next	1.6;

1.6
date	2001.08.12.12.03.03;	author heko;	state Exp;
branches;
next	1.5;

1.5
date	2001.07.12.05.16.56;	author deraadt;	state Exp;
branches;
next	1.4;

1.4
date	2000.11.21.13.43.52;	author aaron;	state Exp;
branches;
next	1.3;

1.3
date	2000.11.21.13.42.23;	author aaron;	state Exp;
branches;
next	1.2;

1.2
date	96.06.26.05.31.50;	author deraadt;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.44.58;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.44.58;	author deraadt;	state Exp;
branches;
next	;


desc
@@


1.17
log
@Remove colcrt and checknr.  colcrt is only useful on very old
terminals and checknr has been subsumed by "mandoc -Tlint".
OK deraadt@@ jmc@@ schwarze@@
@
text
@/*	$OpenBSD: checknr.c,v 1.16 2009/10/27 23:59:36 deraadt Exp $	*/
/*	$NetBSD: checknr.c,v 1.4 1995/03/26 04:10:19 glass Exp $	*/

/*
 * Copyright (c) 1980, 1993
 *	The Regents of the University of California.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */

/*
 * checknr: check an nroff/troff input file for matching macro calls.
 * we also attempt to match size and font changes, but only the embedded
 * kind.  These must end in \s0 and \fP resp.  Maybe more sophistication
 * later but for now think of these restrictions as contributions to
 * structured typesetting.
 */
#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <unistd.h>
#include <ctype.h>
#include <err.h>

#define MAXSTK	100	/* Stack size */
#define MAXBR	100	/* Max number of bracket pairs known */
#define MAXCMDS	500	/* Max number of commands known */

/*
 * The stack on which we remember what we've seen so far.
 */
struct stkstr {
	int opno;	/* number of opening bracket */
	int pl;		/* '+', '-', ' ' for \s, 1 for \f, 0 for .ft */
	int parm;	/* parm to size, font, etc */
	int lno;	/* line number the thing came in in */
} stk[MAXSTK];
int stktop;

void	usage(void);
void	addmac(char *);
void	process(FILE *);
void	pe(int);
int	eq(char *, char *);
void	complain(int);
void	prop(int);
void	chkcmd(char *, char *);
void	addcmd(char *);
void	nomatch(char *);
void	checkknown(char *);
int	binsrch(char *);

/*
 * The kinds of opening and closing brackets.
 */
struct brstr {
	char *opbr;
	char *clbr;
} br[MAXBR] = {
	/* A few bare bones troff commands */
#define SZ	0
	{ "sz",	"sz" },	/* also \s */
#define FT	1
	{ "ft",	"ft" },	/* also \f */
	/* the -mm package */
	{ "AL",	"LE" },
	{ "AS",	"AE" },
	{ "BL",	"LE" },
	{ "BS",	"BE" },
	{ "DF",	"DE" },
	{ "DL",	"LE" },
	{ "DS",	"DE" },
	{ "FS",	"FE" },
	{ "ML",	"LE" },
	{ "NS",	"NE" },
	{ "RL",	"LE" },
	{ "VL",	"LE" },
	/* the -ms package */
	{ "AB",	"AE" },
	{ "BD",	"DE" },
	{ "CD",	"DE" },
	{ "DS",	"DE" },
	{ "FS",	"FE" },
	{ "ID",	"DE" },
	{ "KF",	"KE" },
	{ "KS",	"KE" },
	{ "LD",	"DE" },
	{ "LG",	"NL" },
	{ "QS",	"QE" },
	{ "RS",	"RE" },
	{ "SM",	"NL" },
	{ "XA",	"XE" },
	{ "XS",	"XE" },
	/* The -me package */
	{ "(b",	")b" },
	{ "(c",	")c" },
	{ "(d",	")d" },
	{ "(f",	")f" },
	{ "(l",	")l" },
	{ "(q",	")q" },
	{ "(x",	")x" },
	{ "(z",	")z" },
	/* Things needed by preprocessors */
	{ "EQ",	"EN" },
	{ "TS",	"TE" },
	/* Refer */
	{ "[",	"]" },
	{ 0,	 }
};

/*
 * All commands known to nroff, plus macro packages.
 * Used so we can complain about unrecognized commands.
 */
char *knowncmds[MAXCMDS] = {
"$c", "$f", "$h", "$p", "$s", "(b", "(c", "(d", "(f", "(l", "(q", "(t",
"(x", "(z", ")b", ")c", ")d", ")f", ")l", ")q", ")t", ")x", ")z", "++",
"+c", "1C", "1c", "2C", "2c", "@@(", "@@)", "@@C", "@@D", "@@F", "@@I", "@@M",
"@@c", "@@e", "@@f", "@@h", "@@m", "@@n", "@@o", "@@p", "@@r", "@@t", "@@z", "AB",
"AE", "AF", "AI", "AL", "AM", "AS", "AT", "AU", "AX", "B",  "B1", "B2",
"BD", "BE", "BG", "BL", "BS", "BT", "BX", "C1", "C2", "CD", "CM", "CT",
"D",  "DA", "DE", "DF", "DL", "DS", "DT", "EC", "EF", "EG", "EH", "EM",
"EN", "EQ", "EX", "FA", "FD", "FE", "FG", "FJ", "FK", "FL", "FN", "FO",
"FQ", "FS", "FV", "FX", "H",  "HC", "HD", "HM", "HO", "HU", "I",  "ID",
"IE", "IH", "IM", "IP", "IX", "IZ", "KD", "KE", "KF", "KQ", "KS", "LB",
"LC", "LD", "LE", "LG", "LI", "LP", "MC", "ME", "MF", "MH", "ML", "MR",
"MT", "ND", "NE", "NH", "NL", "NP", "NS", "OF", "OH", "OK", "OP", "P",
"P1", "PF", "PH", "PP", "PT", "PX", "PY", "QE", "QP", "QS", "R",  "RA",
"RC", "RE", "RL", "RP", "RQ", "RS", "RT", "S",  "S0", "S2", "S3", "SA",
"SG", "SH", "SK", "SM", "SP", "SY", "T&", "TA", "TB", "TC", "TD", "TE",
"TH", "TL", "TM", "TP", "TQ", "TR", "TS", "TX", "UL", "US", "UX", "VL",
"WC", "WH", "XA", "XD", "XE", "XF", "XK", "XP", "XS", "[",  "[-", "[0",
"[1", "[2", "[3", "[4", "[5", "[<", "[>", "[]", "]",  "]-", "]<", "]>",
"][", "ab", "ac", "ad", "af", "am", "ar", "as", "b",  "ba", "bc", "bd",
"bi", "bl", "bp", "br", "bx", "c.", "c2", "cc", "ce", "cf", "ch", "cs",
"ct", "cu", "da", "de", "di", "dl", "dn", "ds", "dt", "dw", "dy", "ec",
"ef", "eh", "el", "em", "eo", "ep", "ev", "ex", "fc", "fi", "fl", "fo",
"fp", "ft", "fz", "hc", "he", "hl", "hp", "ht", "hw", "hx", "hy", "i",
"ie", "if", "ig", "in", "ip", "it", "ix", "lc", "lg", "li", "ll", "ln",
"lo", "lp", "ls", "lt", "m1", "m2", "m3", "m4", "mc", "mk", "mo", "n1",
"n2", "na", "ne", "nf", "nh", "nl", "nm", "nn", "np", "nr", "ns", "nx",
"of", "oh", "os", "pa", "pc", "pi", "pl", "pm", "pn", "po", "pp", "ps",
"q",  "r",  "rb", "rd", "re", "rm", "rn", "ro", "rr", "rs", "rt", "sb",
"sc", "sh", "sk", "so", "sp", "ss", "st", "sv", "sz", "ta", "tc", "th",
"ti", "tl", "tm", "tp", "tr", "u",  "uf", "uh", "ul", "vs", "wh", "xp",
"yr", 0
};

int	lineno;		/* current line number in input file */
char	line[256];	/* the current line */
char	*cfilename;	/* name of current file */
int	nfiles;		/* number of files to process */
int	fflag;		/* -f: ignore \f */
int	sflag;		/* -s: ignore \s */
int	ncmds;		/* size of knowncmds */
int	slot;		/* slot in knowncmds found by binsrch */

int
main(int argc, char *argv[])
{
	FILE *f;
	int i;
	char *cp;
	char b1[4];

	/* Figure out how many known commands there are */
	while (knowncmds[ncmds])
		ncmds++;
	while (argc > 1 && argv[1][0] == '-') {
		switch(argv[1][1]) {

		/* -a: add pairs of macros */
		case 'a':
			i = strlen(argv[1]) - 2;
			if (i == 0 || i % 6 != 0)
				usage();
			/* look for empty macro slots */
			for (i=0; br[i].opbr; i++)
				;
			for (cp=argv[1]+3; cp[-1]; cp += 6) {
				if (i >= MAXBR)
					errx(1, "too many pairs");
				if ((br[i].opbr = malloc(3)) == NULL)
					err(1, "malloc");
				strlcpy(br[i].opbr, cp, 3);
				if ((br[i].clbr = malloc(3)) == NULL)
					err(1, "malloc");
				strlcpy(br[i].clbr, cp+3, 3);
				addmac(br[i].opbr);	/* knows pairs are also known cmds */
				addmac(br[i].clbr);
				i++;
			}
			break;

		/* -c: add known commands */
		case 'c':
			i = strlen(argv[1]) - 2;
			if (i == 0 || i % 3 != 0)
				usage();
			for (cp=argv[1]+3; cp[-1]; cp += 3) {
				if (cp[2] && cp[2] != '.')
					usage();
				strncpy(b1, cp, 2);
				addmac(b1);
			}
			break;

		/* -f: ignore font changes */
		case 'f':
			fflag = 1;
			break;

		/* -s: ignore size changes */
		case 's':
			sflag = 1;
			break;
		default:
			usage();
		}
		argc--; argv++;
	}

	nfiles = argc - 1;

	if (nfiles > 0) {
		for (i=1; i<argc; i++) {
			cfilename = argv[i];
			f = fopen(cfilename, "r");
			if (f == NULL)
				warn("%s", cfilename);
			else {
				process(f);
				fclose(f);
			}
		}
	} else {
		cfilename = "stdin";
		process(stdin);
	}
	exit(0);
}

void
usage(void)
{
	extern char *__progname;
	(void)fprintf(stderr,
	    "usage: %s [-fs] [-a.x1.y1.x2.y2. ... .xn.yn] "
	    "[-c.x1.x2.x3. ... .xn] [file]\n", __progname);
	exit(1);
}

void
process(FILE *f)
{
	int i, n;
	char mac[5];	/* The current macro or nroff command */
	int pl;

	stktop = -1;
	for (lineno = 1; fgets(line, sizeof line, f); lineno++) {
		if (line[0] == '.') {
			/*
			 * find and isolate the macro/command name.
			 */
			strncpy(mac, line+1, 4);
			if (isspace(mac[0])) {
				pe(lineno);
				printf("Empty command\n");
			} else if (isspace(mac[1])) {
				mac[1] = 0;
			} else if (isspace(mac[2])) {
				mac[2] = 0;
			} else if (mac[0] != '\\' || mac[1] != '\"') {
				pe(lineno);
				printf("Command too long\n");
			}

			/*
			 * Is it a known command?
			 */
			checkknown(mac);

			/*
			 * Should we add it?
			 */
			if (eq(mac, "de"))
				addcmd(line);

			chkcmd(line, mac);
		}

		/*
		 * At this point we process the line looking
		 * for \s and \f.
		 */
		for (i=0; line[i]; i++)
			if (line[i]=='\\' && (i==0 || line[i-1]!='\\')) {
				if (!sflag && line[++i]=='s') {
					pl = line[++i];
					if (isdigit(pl)) {
						n = pl - '0';
						pl = ' ';
					} else
						n = 0;
					while (isdigit(line[++i]))
						n = 10 * n + line[i] - '0';
					i--;
					if (n == 0) {
						if (stk[stktop].opno == SZ) {
							stktop--;
						} else {
							pe(lineno);
							printf("unmatched \\s0\n");
						}
					} else {
						stk[++stktop].opno = SZ;
						stk[stktop].pl = pl;
						stk[stktop].parm = n;
						stk[stktop].lno = lineno;
					}
				} else if (!fflag && line[i]=='f') {
					n = line[++i];
					if (n == 'P') {
						if (stk[stktop].opno == FT) {
							stktop--;
						} else {
							pe(lineno);
							printf("unmatched \\fP\n");
						}
					} else {
						stk[++stktop].opno = FT;
						stk[stktop].pl = 1;
						stk[stktop].parm = n;
						stk[stktop].lno = lineno;
					}
				}
			}
	}
	/*
	 * We've hit the end and look at all this stuff that hasn't been
	 * matched yet!  Complain, complain.
	 */
	for (i=stktop; i>=0; i--) {
		complain(i);
	}
}

void
complain(int i)
{
	pe(stk[i].lno);
	printf("Unmatched ");
	prop(i);
	printf("\n");
}

void
prop(int i)
{
	if (stk[i].pl == 0)
		printf(".%s", br[stk[i].opno].opbr);
	else switch(stk[i].opno) {
	case SZ:
		printf("\\s%c%d", stk[i].pl, stk[i].parm);
		break;
	case FT:
		printf("\\f%c", stk[i].parm);
		break;
	default:
		printf("Bug: stk[%d].opno = %d = .%s, .%s",
			i, stk[i].opno, br[stk[i].opno].opbr, br[stk[i].opno].clbr);
	}
}

void
chkcmd(char *line, char *mac)
{
	int i;

	/*
	 * Check to see if it matches top of stack.
	 */
	if (stktop >= 0 && eq(mac, br[stk[stktop].opno].clbr))
		stktop--;	/* OK. Pop & forget */
	else {
		/* No. Maybe it's an opener */
		for (i=0; br[i].opbr; i++) {
			if (eq(mac, br[i].opbr)) {
				/* Found. Push it. */
				stktop++;
				stk[stktop].opno = i;
				stk[stktop].pl = 0;
				stk[stktop].parm = 0;
				stk[stktop].lno = lineno;
				break;
			}
			/*
			 * Maybe it's an unmatched closer.
			 * NOTE: this depends on the fact
			 * that none of the closers can be
			 * openers too.
			 */
			if (eq(mac, br[i].clbr)) {
				nomatch(mac);
				break;
			}
		}
	}
}

void
nomatch(char *mac)
{
	int i, j;

	/*
	 * Look for a match further down on stack
	 * If we find one, it suggests that the stuff in
	 * between is supposed to match itself.
	 */
	for (j=stktop; j>=0; j--)
		if (eq(mac,br[stk[j].opno].clbr)) {
			/* Found.  Make a good diagnostic. */
			if (j == stktop-2) {
				/*
				 * Check for special case \fx..\fR and don't
				 * complain.
				 */
				if (stk[j+1].opno==FT && stk[j+1].parm!='R'
				 && stk[j+2].opno==FT && stk[j+2].parm=='R') {
					stktop = j -1;
					return;
				}
				/*
				 * We have two unmatched frobs.  Chances are
				 * they were intended to match, so we mention
				 * them together.
				 */
				pe(stk[j+1].lno);
				prop(j+1);
				printf(" does not match %d: ", stk[j+2].lno);
				prop(j+2);
				printf("\n");
			} else for (i=j+1; i <= stktop; i++) {
				complain(i);
			}
			stktop = j-1;
			return;
		}
	/* Didn't find one.  Throw this away. */
	pe(lineno);
	printf("Unmatched .%s\n", mac);
}

/* eq: are two strings equal? */
int
eq(char *s1, char *s2)
{
	return (strcmp(s1, s2) == 0);
}

/* print the first part of an error message, given the line number */
void
pe(int lineno)
{
	if (nfiles > 1)
		printf("%s: ", cfilename);
	printf("%d: ", lineno);
}

void
checkknown(char *mac)
{

	if (eq(mac, "."))
		return;
	if (binsrch(mac) >= 0)
		return;
	if (mac[0] == '\\' && mac[1] == '"')	/* comments */
		return;

	pe(lineno);
	printf("Unknown command: .%s\n", mac);
}

/*
 * We have a .de xx line in "line".  Add xx to the list of known commands.
 */
void
addcmd(char *line)
{
	char *mac;

	/* grab the macro being defined */
	mac = line+4;
	while (isspace(*mac))
		mac++;
	if (*mac == 0) {
		pe(lineno);
		printf("illegal define: %s\n", line);
		return;
	}
	mac[2] = 0;
	if (isspace(mac[1]) || mac[1] == '\\')
		mac[1] = 0;
	if (ncmds >= MAXCMDS) {
		printf("Only %d known commands allowed\n", MAXCMDS);
		exit(1);
	}
	addmac(mac);
}

/*
 * Add mac to the list.  We should really have some kind of tree
 * structure here but this is a quick-and-dirty job and I just don't
 * have time to mess with it.  (I wonder if this will come back to haunt
 * me someday?)  Anyway, I claim that .de is fairly rare in user
 * nroff programs, and the register loop below is pretty fast.
 */
void
addmac(char *mac)
{
	char **src, **dest, **loc;

	if (binsrch(mac) >= 0){	/* it's OK to redefine something */
#ifdef DEBUG
		printf("binsrch(%s) -> already in table\n", mac);
#endif /* DEBUG */
		return;
	}
	/* binsrch sets slot as a side effect */
#ifdef DEBUG
printf("binsrch(%s) -> %d\n", mac, slot);
#endif
	loc = &knowncmds[slot];
	src = &knowncmds[ncmds-1];
	dest = src+1;
	while (dest > loc)
		*dest-- = *src--;
	if ((*loc = strdup(mac)) == NULL)
		err(1, "strdup");
	ncmds++;
#ifdef DEBUG
printf("after: %s %s %s %s %s, %d cmds\n", knowncmds[slot-2], knowncmds[slot-1], knowncmds[slot], knowncmds[slot+1], knowncmds[slot+2], ncmds);
#endif
}

/*
 * Do a binary search in knowncmds for mac.
 * If found, return the index.  If not, return -1.
 */
int
binsrch(char *mac)
{
	char *p;		/* pointer to current cmd in list */
	int d;			/* difference if any */
	int mid;		/* mid point in binary search */
	int top, bot;		/* boundaries of bin search, inclusive */

	top = ncmds-1;
	bot = 0;
	while (top >= bot) {
		mid = (top+bot)/2;
		p = knowncmds[mid];
		d = p[0] - mac[0];
		if (d == 0)
			d = p[1] - mac[1];
		if (d == 0)
			return mid;
		if (d < 0)
			bot = mid + 1;
		else
			top = mid - 1;
	}
	slot = bot;	/* place it would have gone */
	return -1;
}
@


1.16
log
@rcsid[] and sccsid[] and copyright[] are essentially unmaintained (and
unmaintainable).  these days, people use source.  these id's do not provide
any benefit, and do hurt the small install media
(the 33,000 line diff is essentially mechanical)
ok with the idea millert, ok dms
@
text
@d1 1
a1 1
/*	$OpenBSD: checknr.c,v 1.15 2007/06/27 03:29:31 ray Exp $	*/
@


1.15
log
@From Tobias Stoeckmann:
 - Fix a file descriptor leak.
 - Print usage if -a and -c flags are passed a zero-length string.

OK millert and moritz
@
text
@d1 1
a1 1
/*	$OpenBSD: checknr.c,v 1.14 2005/03/29 23:46:19 jaredy Exp $	*/
a31 14

#ifndef lint
static const char copyright[] =
"@@(#) Copyright (c) 1980, 1993\n\
	The Regents of the University of California.  All rights reserved.\n";
#endif /* not lint */

#ifndef lint
#if 0
static const char sccsid[] = "@@(#)checknr.c	8.1 (Berkeley) 6/6/93";
#else 
static const char rcsid[] = "$OpenBSD: checknr.c,v 1.14 2005/03/29 23:46:19 jaredy Exp $";
#endif
#endif /* not lint */
@


1.14
log
@- fix overflow when too many -a arguments are given
- properly NUL-terminate -a arguments when copying
- check strdup for error failure

ok deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: checknr.c,v 1.13 2005/03/08 23:31:53 cloder Exp $	*/
d43 1
a43 1
static const char rcsid[] = "$OpenBSD: checknr.c,v 1.13 2005/03/08 23:31:53 cloder Exp $";
d211 1
a211 1
			if (i % 6 != 0)
d234 1
a234 1
			if (i % 3 != 0)
d267 1
a267 1
			else
d269 2
@


1.13
log
@Sweeping the tree for printf(s) where printf("%s",s) should be used.
This is a regression introduced during conversion from perror(3) to err(3)
OK mickey@@
@
text
@d1 1
a1 1
/*	$OpenBSD: checknr.c,v 1.12 2004/07/01 19:20:23 mickey Exp $	*/
d43 1
a43 1
static const char rcsid[] = "$OpenBSD: checknr.c,v 1.12 2004/07/01 19:20:23 mickey Exp $";
d144 1
a144 1
	{ 0,	 },
d217 8
a224 4
				br[i].opbr = malloc(3);
				strncpy(br[i].opbr, cp, 2);
				br[i].clbr = malloc(3);
				strncpy(br[i].clbr, cp+3, 2);
d575 2
a576 1
	*loc = strdup(mac);
@


1.12
log
@warn vs perror; __progname; and wall
@
text
@d1 1
a1 1
/*	$OpenBSD: checknr.c,v 1.11 2003/06/25 21:09:09 deraadt Exp $	*/
d43 1
a43 1
static const char rcsid[] = "$OpenBSD: checknr.c,v 1.11 2003/06/25 21:09:09 deraadt Exp $";
d262 1
a262 1
				warn(cfilename);
@


1.11
log
@protos
@
text
@d1 1
a1 1
/*	$OpenBSD: checknr.c,v 1.10 2003/06/10 22:20:45 deraadt Exp $	*/
d34 1
a34 1
static char copyright[] =
d41 1
a41 1
static char sccsid[] = "@@(#)checknr.c	8.1 (Berkeley) 6/6/93";
d43 1
a43 1
static char rcsid[] = "$OpenBSD: checknr.c,v 1.10 2003/06/10 22:20:45 deraadt Exp $";
d59 1
d262 1
a262 1
				perror(cfilename);
d276 1
d278 2
a279 2
	    "usage: checknr [-fs] [-a.x1.y1.x2.y2. ... .xn.yn] "
	    "[-c.x1.x2.x3. ... .xn] [file]\n");
@


1.10
log
@mostly ansi cleanup; pval ok
@
text
@d1 1
a1 1
/*	$OpenBSD: checknr.c,v 1.9 2003/06/03 02:56:06 millert Exp $	*/
d43 1
a43 1
static char rcsid[] = "$OpenBSD: checknr.c,v 1.9 2003/06/03 02:56:06 millert Exp $";
d56 2
a191 2

char	*malloc();
@


1.9
log
@Remove the advertising clause in the UCB license which Berkeley
rescinded 22 July 1999.  Proofed by myself and Theo.
@
text
@d1 1
a1 1
/*	$OpenBSD: checknr.c,v 1.8 2003/04/03 22:09:04 deraadt Exp $	*/
d43 1
a43 1
static char rcsid[] = "$OpenBSD: checknr.c,v 1.8 2003/04/03 22:09:04 deraadt Exp $";
d194 1
a194 3
main(argc, argv)
int argc;
char **argv;
d273 1
a273 1
usage()
d282 1
a282 2
process(f)
FILE *f;
d378 1
a378 1
complain(i)
d387 1
a387 2
prop(i)
	int i;
d405 1
a405 3
chkcmd(line, mac)
char *line;
char *mac;
d441 1
a441 2
nomatch(mac)
char *mac;
d486 1
a486 2
eq(s1, s2)
char *s1, *s2;
d493 1
a493 2
pe(lineno)
int lineno;
d501 1
a501 2
checkknown(mac)
char *mac;
d519 1
a519 2
addcmd(line)
char *line;
d550 1
a550 2
addmac(mac)
char *mac;
d581 1
a581 2
binsrch(mac)
char *mac;
@


1.8
log
@kill strcpy; miod ok
@
text
@d1 1
a1 1
/*	$OpenBSD: checknr.c,v 1.7 2001/11/19 19:02:13 mpech Exp $	*/
d16 1
a16 5
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
d43 1
a43 1
static char rcsid[] = "$OpenBSD: checknr.c,v 1.7 2001/11/19 19:02:13 mpech Exp $";
@


1.7
log
@kill more registers

millert@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: checknr.c,v 1.6 2001/08/12 12:03:03 heko Exp $	*/
d47 1
a47 1
static char rcsid[] = "$OpenBSD: checknr.c,v 1.6 2001/08/12 12:03:03 heko Exp $";
d585 1
a585 2
	*loc = malloc(3);
	strcpy(*loc, mac);
@


1.6
log
@#(endif|else) foo is incorrect, make it #endif /* foo */
deraadt@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: checknr.c,v 1.5 2001/07/12 05:16:56 deraadt Exp $	*/
d47 1
a47 1
static char rcsid[] = "$OpenBSD: checknr.c,v 1.5 2001/07/12 05:16:56 deraadt Exp $";
d291 1
a291 1
	register int i, n;
d417 1
a417 1
	register int i;
d454 1
a454 1
	register int i, j;
d568 1
a568 1
	register char **src, **dest, **loc;
d601 4
a604 4
	register char *p;	/* pointer to current cmd in list */
	register int d;		/* difference if any */
	register int mid;	/* mid point in binary search */
	register int top, bot;	/* boundaries of bin search, inclusive */
@


1.5
log
@first pass at a -Wall cleanup
@
text
@d1 1
a1 1
/*	$OpenBSD: checknr.c,v 1.4 2000/11/21 13:43:52 aaron Exp $	*/
d47 1
a47 1
static char rcsid[] = "$OpenBSD: checknr.c,v 1.4 2000/11/21 13:43:52 aaron Exp $";
d573 1
a573 1
#endif DEBUG
@


1.4
log
@Oops... alphabetize.
@
text
@d1 1
a1 1
/*	$OpenBSD: checknr.c,v 1.3 2000/11/21 13:42:23 aaron Exp $	*/
d47 1
a47 1
static char rcsid[] = "$OpenBSD: checknr.c,v 1.3 2000/11/21 13:42:23 aaron Exp $";
d77 13
d99 1
a99 1
	"sz",	"sz",	/* also \s */
d101 1
a101 1
	"ft",	"ft",	/* also \f */
d103 12
a114 12
	"AL",	"LE",
	"AS",	"AE",
	"BL",	"LE",
	"BS",	"BE",
	"DF",	"DE",
	"DL",	"LE",
	"DS",	"DE",
	"FS",	"FE",
	"ML",	"LE",
	"NS",	"NE",
	"RL",	"LE",
	"VL",	"LE",
d116 15
a130 15
	"AB",	"AE",
	"BD",	"DE",
	"CD",	"DE",
	"DS",	"DE",
	"FS",	"FE",
	"ID",	"DE",
	"KF",	"KE",
	"KS",	"KE",
	"LD",	"DE",
	"LG",	"NL",
	"QS",	"QE",
	"RS",	"RE",
	"SM",	"NL",
	"XA",	"XE",
	"XS",	"XE",
d132 8
a139 8
	"(b",	")b",
	"(c",	")c",
	"(d",	")d",
	"(f",	")f",
	"(l",	")l",
	"(q",	")q",
	"(x",	")x",
	"(z",	")z",
d141 2
a142 2
	"EQ",	"EN",
	"TS",	"TE",
d144 2
a145 2
	"[",	"]",
	0,	0
d197 1
d278 1
d287 1
d384 1
d393 1
d395 1
d412 1
d417 1
a417 1
	register int i, n;
d450 1
d496 1
d504 1
d513 1
d532 1
d564 1
d597 1
@


1.3
log
@Sync usage() output with man page; mpech@@prosoft.org.lv
@
text
@d1 1
a1 1
/*	$OpenBSD: checknr.c,v 1.2 1996/06/26 05:31:50 deraadt Exp $	*/
d47 1
a47 1
static char rcsid[] = "$OpenBSD: checknr.c,v 1.2 1996/06/26 05:31:50 deraadt Exp $";
d267 1
a267 1
	    "usage: checknr [-sf] [-a.x1.y1.x2.y2. ... .xn.yn] "
@


1.2
log
@rcsid
@
text
@d1 1
a1 1
/*	$OpenBSD: checknr.c,v 1.4 1995/03/26 04:10:19 glass Exp $	*/
d47 1
a47 1
static char rcsid[] = "$OpenBSD: checknr.c,v 1.4 1995/03/26 04:10:19 glass Exp $";
d266 3
a268 1
	printf("Usage: checknr -s -f -a.xx.yy.xx.yy... -c.xx.xx.xx...\n");
@


1.1
log
@Initial revision
@
text
@d1 1
d47 1
a47 1
static char rcsid[] = "$NetBSD: checknr.c,v 1.4 1995/03/26 04:10:19 glass Exp $";
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@
