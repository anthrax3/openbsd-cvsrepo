head	1.26;
access;
symbols
	OPENBSD_6_2_BASE:1.26
	OPENBSD_6_1:1.26.0.8
	OPENBSD_6_1_BASE:1.26
	OPENBSD_6_0:1.26.0.4
	OPENBSD_6_0_BASE:1.26
	OPENBSD_5_9:1.26.0.2
	OPENBSD_5_9_BASE:1.26
	OPENBSD_5_8:1.22.0.4
	OPENBSD_5_8_BASE:1.22
	OPENBSD_5_7:1.20.0.2
	OPENBSD_5_7_BASE:1.20
	OPENBSD_5_6:1.20.0.6
	OPENBSD_5_6_BASE:1.20
	OPENBSD_5_5:1.20.0.4
	OPENBSD_5_5_BASE:1.20
	OPENBSD_5_4:1.18.0.14
	OPENBSD_5_4_BASE:1.18
	OPENBSD_5_3:1.18.0.12
	OPENBSD_5_3_BASE:1.18
	OPENBSD_5_2:1.18.0.10
	OPENBSD_5_2_BASE:1.18
	OPENBSD_5_1_BASE:1.18
	OPENBSD_5_1:1.18.0.8
	OPENBSD_5_0:1.18.0.6
	OPENBSD_5_0_BASE:1.18
	OPENBSD_4_9:1.18.0.4
	OPENBSD_4_9_BASE:1.18
	OPENBSD_4_8:1.18.0.2
	OPENBSD_4_8_BASE:1.18
	OPENBSD_4_7:1.17.0.2
	OPENBSD_4_7_BASE:1.17
	OPENBSD_4_6:1.16.0.12
	OPENBSD_4_6_BASE:1.16
	OPENBSD_4_5:1.16.0.8
	OPENBSD_4_5_BASE:1.16
	OPENBSD_4_4:1.16.0.6
	OPENBSD_4_4_BASE:1.16
	OPENBSD_4_3:1.16.0.4
	OPENBSD_4_3_BASE:1.16
	OPENBSD_4_2:1.16.0.2
	OPENBSD_4_2_BASE:1.16
	OPENBSD_4_1:1.15.0.4
	OPENBSD_4_1_BASE:1.15
	OPENBSD_4_0:1.15.0.2
	OPENBSD_4_0_BASE:1.15
	OPENBSD_3_9:1.14.0.8
	OPENBSD_3_9_BASE:1.14
	OPENBSD_3_8:1.14.0.6
	OPENBSD_3_8_BASE:1.14
	OPENBSD_3_7:1.14.0.4
	OPENBSD_3_7_BASE:1.14
	OPENBSD_3_6:1.14.0.2
	OPENBSD_3_6_BASE:1.14
	OPENBSD_3_5:1.13.0.6
	OPENBSD_3_5_BASE:1.13
	OPENBSD_3_4:1.13.0.4
	OPENBSD_3_4_BASE:1.13
	OPENBSD_3_3:1.13.0.2
	OPENBSD_3_3_BASE:1.13
	OPENBSD_3_2:1.12.0.2
	OPENBSD_3_2_BASE:1.12
	OPENBSD_3_1:1.9.0.10
	OPENBSD_3_1_BASE:1.9
	OPENBSD_3_0:1.9.0.8
	OPENBSD_3_0_BASE:1.9
	OPENBSD_2_9_BASE:1.9
	OPENBSD_2_9:1.9.0.6
	OPENBSD_2_8:1.9.0.4
	OPENBSD_2_8_BASE:1.9
	OPENBSD_2_7:1.9.0.2
	OPENBSD_2_7_BASE:1.9
	OPENBSD_2_6:1.8.0.4
	OPENBSD_2_6_BASE:1.8
	OPENBSD_2_5:1.8.0.2
	OPENBSD_2_5_BASE:1.8
	OPENBSD_2_4:1.7.0.2
	OPENBSD_2_4_BASE:1.7
	OPENBSD_2_3:1.4.0.6
	OPENBSD_2_3_BASE:1.4
	OPENBSD_2_2:1.4.0.4
	OPENBSD_2_2_BASE:1.4
	OPENBSD_2_1:1.4.0.2
	OPENBSD_2_1_BASE:1.4
	OPENBSD_2_0:1.3.0.2
	OPENBSD_2_0_BASE:1.3
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.26
date	2015.11.11.17.42.51;	author millert;	state Exp;
branches;
next	1.25;
commitid	SmfZfd3miFDVQqck;

1.25
date	2015.11.11.17.40.31;	author millert;	state Exp;
branches;
next	1.24;
commitid	4ZEw0pPUgpFYkVIe;

1.24
date	2015.11.06.23.47.42;	author millert;	state Exp;
branches;
next	1.23;
commitid	8eaJrEU7qiymGijK;

1.23
date	2015.08.20.22.32.41;	author deraadt;	state Exp;
branches;
next	1.22;
commitid	0Dp7Dy9FuNZesYo2;

1.22
date	2015.03.17.19.31.30;	author millert;	state Exp;
branches;
next	1.21;
commitid	0y5bUkEOUrNvvJEO;

1.21
date	2015.03.15.00.41.27;	author millert;	state Exp;
branches;
next	1.20;
commitid	IbVxlqGw2UipKdDr;

1.20
date	2014.01.13.23.18.57;	author millert;	state Exp;
branches;
next	1.19;

1.19
date	2013.11.25.18.02.50;	author deraadt;	state Exp;
branches;
next	1.18;

1.18
date	2010.07.02.23.40.09;	author krw;	state Exp;
branches;
next	1.17;

1.17
date	2009.10.27.23.59.35;	author deraadt;	state Exp;
branches;
next	1.16;

1.16
date	2007.05.23.19.50.28;	author millert;	state Exp;
branches;
next	1.15;

1.15
date	2006.04.26.03.01.48;	author cloder;	state Exp;
branches;
next	1.14;

1.14
date	2004.06.17.22.09.11;	author millert;	state Exp;
branches;
next	1.13;

1.13
date	2003.02.20.20.38.08;	author millert;	state Exp;
branches;
next	1.12;

1.12
date	2002.06.14.21.35.00;	author todd;	state Exp;
branches;
next	1.11;

1.11
date	2002.05.14.18.05.39;	author millert;	state Exp;
branches;
next	1.10;

1.10
date	2002.05.11.23.16.44;	author millert;	state Exp;
branches;
next	1.9;

1.9
date	2000.01.05.08.06.25;	author millert;	state Exp;
branches;
next	1.8;

1.8
date	99.03.21.04.04.42;	author alex;	state Exp;
branches;
next	1.7;

1.7
date	98.07.10.07.07.04;	author deraadt;	state Exp;
branches;
next	1.6;

1.6
date	98.07.09.20.40.59;	author mickey;	state Exp;
branches;
next	1.5;

1.5
date	98.06.26.03.20.11;	author millert;	state Exp;
branches;
next	1.4;

1.4
date	97.03.01.23.40.10;	author millert;	state Exp;
branches;
next	1.3;

1.3
date	96.06.26.05.31.29;	author deraadt;	state Exp;
branches;
next	1.2;

1.2
date	96.01.02.11.53.58;	author deraadt;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.44.54;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.44.54;	author deraadt;	state Exp;
branches;
next	;


desc
@@


1.26
log
@Use warn/warnx here too.
@
text
@/*	$OpenBSD: parsetime.c,v 1.25 2015/11/11 17:40:31 millert Exp $	*/

/*
 * parsetime.c - parse time for at(1)
 * Copyright (C) 1993, 1994  Thomas Koenig
 *
 * modifications for english-language times
 * Copyright (C) 1993  David Parsons
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. The name of the author(s) may not be used to endorse or promote
 *    products derived from this software without specific prior written
 *    permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR(S) ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 * IN NO EVENT SHALL THE AUTHOR(S) BE LIABLE FOR ANY DIRECT, INDIRECT,
 * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
 * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 *  at [NOW] PLUS NUMBER MINUTES|HOURS|DAYS|WEEKS|MONTHS|YEARS
 *     /NUMBER [DOT NUMBER] [AM|PM]\ /[MONTH NUMBER [NUMBER]]             \
 *     |NOON                       | |[TOMORROW]                          |
 *     |MIDNIGHT                   | |[DAY OF WEEK]                       |
 *     \TEATIME                    / |NUMBER [SLASH NUMBER [SLASH NUMBER]]|
 *                                   \PLUS NUMBER MINUTES|HOURS|DAYS|WEEKS|MONTHS|YEARS/
 */

#include <sys/types.h>

#include <err.h>
#include <errno.h>
#include <ctype.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <time.h>
#include <unistd.h>

#include "globals.h"
#include "at.h"

/* Structures and unions */

enum {	/* symbols */
	MIDNIGHT, NOON, TEATIME,
	PM, AM, TOMORROW, TODAY, NOW,
	MINUTES, HOURS, DAYS, WEEKS, MONTHS, YEARS,
	NUMBER, NEXT, PLUS, DOT, SLASH, ID, JUNK,
	JAN, FEB, MAR, APR, MAY, JUN,
	JUL, AUG, SEP, OCT, NOV, DEC,
	SUN, MON, TUE, WED, THU, FRI, SAT
};

/*
 * parse translation table - table driven parsers can be your FRIEND!
 */
struct {
	char *name;	/* token name */
	int value;	/* token id */
	int plural;	/* is this plural? */
} Specials[] = {
	{ "midnight", MIDNIGHT, 0 },	/* 00:00:00 of today or tomorrow */
	{ "noon", NOON, 0 },		/* 12:00:00 of today or tomorrow */
	{ "teatime", TEATIME, 0 },	/* 16:00:00 of today or tomorrow */
	{ "am", AM, 0 },		/* morning times for 0-12 clock */
	{ "pm", PM, 0 },		/* evening times for 0-12 clock */
	{ "tomorrow", TOMORROW, 0 },	/* execute 24 hours from time */
	{ "today", TODAY, 0 },		/* execute today - don't advance time */
	{ "now", NOW, 0 },		/* opt prefix for PLUS */
	{ "next", NEXT, 0 },		/* opt prefix for + 1 */

	{ "minute", MINUTES, 0 },	/* minutes multiplier */
	{ "min", MINUTES, 0 },
	{ "m", MINUTES, 0 },
	{ "minutes", MINUTES, 1 },	/* (pluralized) */
	{ "hour", HOURS, 0 },		/* hours ... */
	{ "hr", HOURS, 0 },		/* abbreviated */
	{ "h", HOURS, 0 },
	{ "hours", HOURS, 1 },		/* (pluralized) */
	{ "day", DAYS, 0 },		/* days ... */
	{ "d", DAYS, 0 },
	{ "days", DAYS, 1 },		/* (pluralized) */
	{ "week", WEEKS, 0 },		/* week ... */
	{ "w", WEEKS, 0 },
	{ "weeks", WEEKS, 1 },		/* (pluralized) */
	{ "month", MONTHS, 0 },		/* month ... */
	{ "mo", MONTHS, 0 },
	{ "mth", MONTHS, 0 },
	{ "months", MONTHS, 1 },	/* (pluralized) */
	{ "year", YEARS, 0 },		/* year ... */
	{ "y", YEARS, 0 },
	{ "years", YEARS, 1 },		/* (pluralized) */
	{ "jan", JAN, 0 },
	{ "feb", FEB, 0 },
	{ "mar", MAR, 0 },
	{ "apr", APR, 0 },
	{ "may", MAY, 0 },
	{ "jun", JUN, 0 },
	{ "jul", JUL, 0 },
	{ "aug", AUG, 0 },
	{ "sep", SEP, 0 },
	{ "oct", OCT, 0 },
	{ "nov", NOV, 0 },
	{ "dec", DEC, 0 },
	{ "january", JAN,0 },
	{ "february", FEB,0 },
	{ "march", MAR,0 },
	{ "april", APR,0 },
	{ "may", MAY,0 },
	{ "june", JUN,0 },
	{ "july", JUL,0 },
	{ "august", AUG,0 },
	{ "september", SEP,0 },
	{ "october", OCT,0 },
	{ "november", NOV,0 },
	{ "december", DEC,0 },
	{ "sunday", SUN, 0 },
	{ "sun", SUN, 0 },
	{ "monday", MON, 0 },
	{ "mon", MON, 0 },
	{ "tuesday", TUE, 0 },
	{ "tue", TUE, 0 },
	{ "wednesday", WED, 0 },
	{ "wed", WED, 0 },
	{ "thursday", THU, 0 },
	{ "thu", THU, 0 },
	{ "friday", FRI, 0 },
	{ "fri", FRI, 0 },
	{ "saturday", SAT, 0 },
	{ "sat", SAT, 0 },
};

static char **scp;	/* scanner - pointer at arglist */
static int scc;		/* scanner - count of remaining arguments */
static char *sct;	/* scanner - next char pointer in current argument */
static int need;	/* scanner - need to advance to next argument */
static char *sc_token;	/* scanner - token buffer */
static size_t sc_len;   /* scanner - length of token buffer */
static int sc_tokid;	/* scanner - token id */
static int sc_tokplur;	/* scanner - is token plural? */

/*
 * parse a token, checking if it's something special to us
 */
static int
parse_token(char *arg)
{
	int i;

	for (i=0; i < sizeof(Specials) / sizeof(Specials[0]); i++) {
		if (strcasecmp(Specials[i].name, arg) == 0) {
			sc_tokplur = Specials[i].plural;
		    	return (sc_tokid = Specials[i].value);
		}
	}

	/* not special - must be some random id */
	return (ID);
}


/*
 * init_scanner() sets up the scanner to eat arguments
 */
static int
init_scanner(int argc, char **argv)
{
	scp = argv;
	scc = argc;
	need = 1;
	sc_len = 1;
	while (argc-- > 0)
		sc_len += strlen(*argv++);

	if ((sc_token = malloc(sc_len)) == NULL) {
		warn(NULL);
		return (-1);
	}
	return (0);
}

/*
 * token() fetches a token from the input stream
 */
static int
token(void)
{
	int idx;

	for (;;) {
		bzero(sc_token, sc_len);
		sc_tokid = EOF;
		sc_tokplur = 0;
		idx = 0;

		/*
		 * if we need to read another argument, walk along the
		 * argument list; when we fall off the arglist, we'll
		 * just return EOF forever
		 */
		if (need) {
			if (scc < 1)
				return (sc_tokid);
			sct = *scp;
			scp++;
			scc--;
			need = 0;
		}
		/*
		 * eat whitespace now - if we walk off the end of the argument,
		 * we'll continue, which puts us up at the top of the while loop
		 * to fetch the next argument in
		 */
		while (isspace((unsigned char)*sct))
			++sct;
		if (!*sct) {
			need = 1;
			continue;
		}

		/*
		 * preserve the first character of the new token
		 */
		sc_token[0] = *sct++;

		/*
		 * then see what it is
		 */
		if (isdigit((unsigned char)sc_token[0])) {
			while (isdigit((unsigned char)*sct))
				sc_token[++idx] = *sct++;
			sc_token[++idx] = 0;
			return ((sc_tokid = NUMBER));
		} else if (isalpha((unsigned char)sc_token[0])) {
			while (isalpha((unsigned char)*sct))
				sc_token[++idx] = *sct++;
			sc_token[++idx] = 0;
			return (parse_token(sc_token));
		}
		else if (sc_token[0] == ':' || sc_token[0] == '.')
			return ((sc_tokid = DOT));
		else if (sc_token[0] == '+')
			return ((sc_tokid = PLUS));
		else if (sc_token[0] == '/')
			return ((sc_tokid = SLASH));
		else
			return ((sc_tokid = JUNK));
	}
}


/*
 * plonk() gives an appropriate error message if a token is incorrect
 */
static void
plonk(int tok)
{
	warnx("%s time", (tok == EOF) ? "incomplete" : "garbled");
}


/*
 * expect() gets a token and returns -1 if it's not the token we want
 */
static int
expect(int desired)
{
	if (token() != desired) {
		plonk(sc_tokid);
		return (-1);
	}
	return (0);
}


/*
 * dateadd() adds a number of minutes to a date.  It is extraordinarily
 * stupid regarding day-of-month overflow, and will most likely not
 * work properly
 */
static void
dateadd(int minutes, struct tm *tm)
{
	/* increment days */

	while (minutes > 24*60) {
		minutes -= 24*60;
		tm->tm_mday++;
	}

	/* increment hours */
	while (minutes > 60) {
		minutes -= 60;
		tm->tm_hour++;
		if (tm->tm_hour > 23) {
			tm->tm_mday++;
			tm->tm_hour = 0;
		}
	}

	/* increment minutes */
	tm->tm_min += minutes;

	if (tm->tm_min > 59) {
		tm->tm_hour++;
		tm->tm_min -= 60;

		if (tm->tm_hour > 23) {
			tm->tm_mday++;
			tm->tm_hour = 0;
		}
	}
}


/*
 * plus() parses a now + time
 *
 *  at [NOW] PLUS NUMBER [MINUTES|HOURS|DAYS|WEEKS|MONTHS|YEARS]
 *
 */
static int
plus(struct tm *tm)
{
	int increment;
	int expectplur;

	if (sc_tokid == NEXT) {
		increment = 1;
		expectplur = 0;
	} else {
		if (expect(NUMBER) != 0)
			return (-1);
		increment = atoi(sc_token);
		expectplur = (increment != 1) ? 1 : 0;
	}

	switch (token()) {
	case YEARS:
		tm->tm_year += increment;
		return (0);
	case MONTHS:
		tm->tm_mon += increment;
		while (tm->tm_mon >= 12) {
		    tm->tm_year++;
		    tm->tm_mon -= 12;
		}
		return (0);
	case WEEKS:
		increment *= 7;
		/* FALLTHROUGH */
	case DAYS:
		increment *= 24;
		/* FALLTHROUGH */
	case HOURS:
		increment *= 60;
		/* FALLTHROUGH */
	case MINUTES:
		if (expectplur != sc_tokplur)
			warnx("pluralization is wrong");
		dateadd(increment, tm);
		return (0);
	}

	plonk(sc_tokid);
	return (-1);
}


/*
 * tod() computes the time of day
 *     [NUMBER [DOT NUMBER] [AM|PM]]
 */
static int
tod(struct tm *tm)
{
	int hour, minute = 0;
	size_t tlen;

	hour = atoi(sc_token);
	tlen = strlen(sc_token);

	/*
	 * first pick out the time of day - if it's 4 digits, we assume
	 * a HHMM time, otherwise it's HH DOT MM time
	 */
	if (token() == DOT) {
		if (expect(NUMBER) != 0)
			return (-1);
		minute = atoi(sc_token);
		if (minute > 59)
			goto bad;
		token();
	} else if (tlen == 4) {
		minute = hour % 100;
		if (minute > 59)
			goto bad;
		hour = hour / 100;
	}

	/*
	 * check if an AM or PM specifier was given
	 */
	if (sc_tokid == AM || sc_tokid == PM) {
		if (hour > 12)
			goto bad;

		if (sc_tokid == PM) {
			if (hour != 12)	/* 12:xx PM is 12:xx, not 24:xx */
				hour += 12;
		} else {
			if (hour == 12)	/* 12:xx AM is 00:xx, not 12:xx */
				hour = 0;
		}
		token();
	} else if (hour > 23)
		goto bad;

	/*
	 * if we specify an absolute time, we don't want to bump the day even
	 * if we've gone past that time - but if we're specifying a time plus
	 * a relative offset, it's okay to bump things
	 */
	if ((sc_tokid == EOF || sc_tokid == PLUS || sc_tokid == NEXT) &&
	    tm->tm_hour > hour) {
		tm->tm_mday++;
		tm->tm_wday++;
	}

	tm->tm_hour = hour;
	tm->tm_min = minute;
	if (tm->tm_hour == 24) {
		tm->tm_hour = 0;
		tm->tm_mday++;
	}
	return (0);
bad:
	warnx("garbled time");
	return (-1);
}


/*
 * assign_date() assigns a date, wrapping to next year if needed
 */
static void
assign_date(struct tm *tm, int mday, int mon, int year)
{

	/*
	 * Convert year into tm_year format (year - 1900).
	 * We may be given the year in 2 digit, 4 digit, or tm_year format.
	 */
	if (year != -1) {
		if (year >= 1900)
			year -= 1900;	/* convert from 4 digit year */
		else if (year < 100) {
			/* Convert to tm_year assuming current century */
			year += (tm->tm_year / 100) * 100;

			if (year == tm->tm_year - 1)
				year++;		/* Common off by one error */
			else if (year < tm->tm_year)
				year += 100;	/* must be in next century */
		}
	}

	if (year < 0 &&
	    (tm->tm_mon > mon ||(tm->tm_mon == mon && tm->tm_mday > mday)))
		year = tm->tm_year + 1;

	tm->tm_mday = mday;
	tm->tm_mon = mon;

	if (year >= 0)
		tm->tm_year = year;
}


/*
 * month() picks apart a month specification
 *
 *  /[<month> NUMBER [NUMBER]]           \
 *  |[TOMORROW]                          |
 *  |[DAY OF WEEK]                       |
 *  |NUMBER [SLASH NUMBER [SLASH NUMBER]]|
 *  \PLUS NUMBER MINUTES|HOURS|DAYS|WEEKS|MONTHS|YEARS/
 */
static int
month(struct tm *tm)
{
	int year = (-1);
	int mday, wday, mon;
	size_t tlen;

	switch (sc_tokid) {
	case NEXT:
	case PLUS:
		if (plus(tm) != 0)
			return (-1);
		break;

	case TOMORROW:
		/* do something tomorrow */
		tm->tm_mday++;
		tm->tm_wday++;
	case TODAY:
		/* force ourselves to stay in today - no further processing */
		token();
		break;

	case JAN: case FEB: case MAR: case APR: case MAY: case JUN:
	case JUL: case AUG: case SEP: case OCT: case NOV: case DEC:
		/*
		 * do month mday [year]
		 */
		mon = sc_tokid - JAN;
		if (expect(NUMBER) != 0)
			return (-1);
		mday = atoi(sc_token);
		if (token() == NUMBER) {
			year = atoi(sc_token);
			token();
		}
		assign_date(tm, mday, mon, year);
		break;

	case SUN: case MON: case TUE:
	case WED: case THU: case FRI:
	case SAT:
		/* do a particular day of the week */
		wday = sc_tokid - SUN;

		mday = tm->tm_mday;

		/* if this day is < today, then roll to next week */
		if (wday < tm->tm_wday)
			mday += 7 - (tm->tm_wday - wday);
		else
			mday += (wday - tm->tm_wday);

		tm->tm_wday = wday;

		assign_date(tm, mday, tm->tm_mon, tm->tm_year);
		break;

	case NUMBER:
		/*
		 * get numeric MMDDYY, mm/dd/yy, or dd.mm.yy
		 */
		tlen = strlen(sc_token);
		mon = atoi(sc_token);
		token();

		if (sc_tokid == SLASH || sc_tokid == DOT) {
			int sep;

			sep = sc_tokid;
			if (expect(NUMBER) != 0)
				return (-1);
			mday = atoi(sc_token);
			if (token() == sep) {
				if (expect(NUMBER) != 0)
					return (-1);
				year = atoi(sc_token);
				token();
			}

			/*
			 * flip months and days for european timing
			 */
			if (sep == DOT) {
				int x = mday;
				mday = mon;
				mon = x;
			}
		} else if (tlen == 6 || tlen == 8) {
			if (tlen == 8) {
				year = (mon % 10000) - 1900;
				mon /= 10000;
			} else {
				year = mon % 100;
				mon /= 100;
			}
			mday = mon % 100;
			mon /= 100;
		} else
			goto bad;

		mon--;
		if (mon < 0 || mon > 11 || mday < 1 || mday > 31)
			goto bad;

		assign_date(tm, mday, mon, year);
		break;
	}
	return (0);
bad:
	warnx("garbled time");
	return (-1);
}


time_t
parsetime(int argc, char **argv)
{
	/*
	 * Do the argument parsing, die if necessary, and return the
	 * time the job should be run.
	 */
	time_t nowtimer, runtimer;
	struct tm nowtime, runtime;
	int hr = 0;
	/* this MUST be initialized to zero for midnight/noon/teatime */

	if (argc == 0)
		return (-1);

	nowtimer = time(NULL);
	nowtime = *localtime(&nowtimer);

	runtime = nowtime;
	runtime.tm_sec = 0;
	runtime.tm_isdst = 0;

	if (init_scanner(argc, argv) == -1)
		return (-1);

	switch (token()) {
	case NOW:	/* now is optional prefix for PLUS tree */
		token();
		if (sc_tokid == EOF) {
			runtime = nowtime;
			break;
		}
		else if (sc_tokid != PLUS && sc_tokid != NEXT)
			plonk(sc_tokid);
	case NEXT:
	case PLUS:
		if (plus(&runtime) != 0)
			return (-1);
		break;

	case NUMBER:
		if (tod(&runtime) != 0 || month(&runtime) != 0)
			return (-1);
		break;

		/*
		 * evil coding for TEATIME|NOON|MIDNIGHT - we've initialised
		 * hr to zero up above, then fall into this case in such a
		 * way so we add +12 +4 hours to it for teatime, +12 hours
		 * to it for noon, and nothing at all for midnight, then
		 * set our runtime to that hour before leaping into the
		 * month scanner
		 */
	case TEATIME:
		hr += 4;
		/* FALLTHROUGH */
	case NOON:
		hr += 12;
		/* FALLTHROUGH */
	case MIDNIGHT:
		if (runtime.tm_hour >= hr) {
			runtime.tm_mday++;
			runtime.tm_wday++;
		}
		runtime.tm_hour = hr;
		runtime.tm_min = 0;
		token();
		/* fall through to month setting */
		/* FALLTHROUGH */
	default:
		if (month(&runtime) != 0)
			return (-1);
		break;
	} /* ugly case statement */
	if (expect(EOF) != 0)
		return (-1);

	/*
	 * adjust for daylight savings time
	 */
	runtime.tm_isdst = -1;
	runtimer = mktime(&runtime);

	if (runtimer < 0) {
		warnx("garbled time");
		return (-1);
	}

	if (nowtimer > runtimer) {
		warnx("cannot schedule jobs in the past");
		return (-1);
	}

	return (runtimer);
}
@


1.25
log
@Remove bogus DST code.  mktime() handles DST automatically when
tm_isdst is set to -1.
@
text
@d1 1
a1 1
/*	$OpenBSD: parsetime.c,v 1.24 2015/11/06 23:47:42 millert Exp $	*/
d39 2
d186 1
a186 2
		fprintf(stderr, "%s: Insufficient virtual memory\n",
		    __progname);
d268 1
a268 2
	fprintf(stderr, "%s: %s time\n", __progname,
	    (tok == EOF) ? "incomplete" : "garbled");
d370 1
a370 2
			fprintf(stderr, "%s: pluralization is wrong\n",
			    __progname);
d448 1
a448 1
	fprintf(stderr, "%s: garbled time\n", __progname);
d609 1
a609 1
	fprintf(stderr, "%s: garbled time\n", __progname);
d698 1
a698 1
		fprintf(stderr, "%s: garbled time\n", __progname);
d703 1
a703 2
		fprintf(stderr, "%s: cannot schedule jobs in the past\n",
		    __progname);
@


1.24
log
@Use __progname instead of the homegrown ProgramName.
@
text
@d1 1
a1 1
/*	$OpenBSD: parsetime.c,v 1.23 2015/08/20 22:32:41 deraadt Exp $	*/
a696 4
	if (runtime.tm_isdst > 0) {
		runtimer -= 3600;
		runtimer = mktime(&runtime);
	}
@


1.23
log
@Do not cast result of malloc/calloc/realloc* if stdlib.h is in scope
ok krw millert
@
text
@d1 1
a1 1
/*	$OpenBSD: parsetime.c,v 1.22 2015/03/17 19:31:30 millert Exp $	*/
d185 1
a185 1
		    ProgramName);
d267 1
a267 1
	fprintf(stderr, "%s: %s time\n", ProgramName,
d371 1
a371 1
			    ProgramName);
d449 1
a449 1
	fprintf(stderr, "%s: garbled time\n", ProgramName);
d610 1
a610 1
	fprintf(stderr, "%s: garbled time\n", ProgramName);
d703 1
a703 1
		fprintf(stderr, "%s: garbled time\n", ProgramName);
d709 1
a709 1
		    ProgramName);
@


1.22
log
@Eliminate use of TM_YEAR_BASE.  OK guenther@@ deraadt@@ miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: parsetime.c,v 1.21 2015/03/15 00:41:27 millert Exp $	*/
d183 1
a183 1
	if ((sc_token = (char *) malloc(sc_len)) == NULL) {
@


1.21
log
@tzfile.h is an internal header that should never have been installed.
What's worse, the tzfile.h that gets installed is over 20 years old
and doesn't match the real tzfile.h in libc/time.  This makes the
tree safe for /usr/include/tzfile.h removal.  The TM_YEAR_BASE
define has been moved to time.h temporarily until its usage is
replaced by 1900 in the tree.  Actual removal of tzfile.h is pending
a ports build.  Based on a diff from deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: parsetime.c,v 1.20 2014/01/13 23:18:57 millert Exp $	*/
d466 2
a467 2
		if (year >= TM_YEAR_BASE)
			year -= TM_YEAR_BASE;	/* convert from 4 digit year */
d590 1
a590 1
				year = (mon % 10000) - TM_YEAR_BASE;
@


1.20
log
@Add the "next" keyword as an alias for "+ 1" for relative times.
Also support "months" and "years" keywords when specified as relative
time units.  All as per POSIX.  Man page changes OK jmc@@ sobrado@@
@
text
@d1 1
a1 1
/*	$OpenBSD: parsetime.c,v 1.19 2013/11/25 18:02:50 deraadt Exp $	*/
a44 1
#include <tzfile.h>
@


1.19
log
@variety of unsigned char casts (or conversions) for ctype
ok krw
@
text
@d1 1
a1 1
/*	$OpenBSD: parsetime.c,v 1.18 2010/07/02 23:40:09 krw Exp $	*/
d30 1
a30 1
 *  at [NOW] PLUS NUMBER MINUTES|HOURS|DAYS|WEEKS
d35 1
a35 1
 *                                   \PLUS NUMBER MINUTES|HOURS|DAYS|WEEKS/
d56 2
a57 2
	MINUTES, HOURS, DAYS, WEEKS,
	NUMBER, PLUS, DOT, SLASH, ID, JUNK,
d79 1
d95 7
d330 1
a330 1
 *  at [NOW] PLUS NUMBER [MINUTES|HOURS|DAYS|WEEKS]
d336 1
a336 1
	int delay;
d339 9
a347 5
	if (expect(NUMBER) != 0)
		return (-1);

	delay = atoi(sc_token);
	expectplur = (delay != 1) ? 1 : 0;
d350 10
d361 1
a361 1
		delay *= 7;
d364 1
a364 1
		delay *= 24;
d367 1
a367 1
		delay *= 60;
d373 1
a373 1
		dateadd(delay, tm);
d436 2
a437 1
	if ((sc_tokid == EOF || sc_tokid == PLUS) && tm->tm_hour > hour) {
d499 1
a499 1
 *  \PLUS NUMBER MINUTES|HOURS|DAYS|WEEKS/
d509 1
d648 1
a648 1
		else if (sc_tokid != PLUS)
d650 1
@


1.18
log
@'wether' -> 'whether' typo in license text.

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: parsetime.c,v 1.17 2009/10/27 23:59:35 deraadt Exp $	*/
d216 1
a216 1
		while (isspace(*sct))
d231 2
a232 2
		if (isdigit(sc_token[0])) {
			while (isdigit(*sct))
d236 2
a237 2
		} else if (isalpha(sc_token[0])) {
			while (isalpha(*sct))
@


1.17
log
@rcsid[] and sccsid[] and copyright[] are essentially unmaintained (and
unmaintainable).  these days, people use source.  these id's do not provide
any benefit, and do hurt the small install media
(the 33,000 line diff is essentially mechanical)
ok with the idea millert, ok dms
@
text
@d1 1
a1 1
/*	$OpenBSD: parsetime.c,v 1.16 2007/05/23 19:50:28 millert Exp $	*/
d26 1
a26 1
 * THEORY OF LIABILITY, WETHER IN CONTRACT, STRICT LIABILITY, OR TORT
@


1.16
log
@Sanity check the time argument specified by the -t argument.  Some
checks adapted from date(1).  Now prevents scheduling jobs in the
past just like the standard (ie: not -n) at(1) date parsing.
@
text
@d1 1
a1 1
/*	$OpenBSD: parsetime.c,v 1.15 2006/04/26 03:01:48 cloder Exp $	*/
a141 4

#ifndef lint
static const char rcsid[] = "$OpenBSD: parsetime.c,v 1.15 2006/04/26 03:01:48 cloder Exp $";
#endif
@


1.15
log
@Cleanup, remove an unused var, use an int to store argc instead of a char,
makes lint a bit happier. OK deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: parsetime.c,v 1.14 2004/06/17 22:09:11 millert Exp $	*/
d144 1
a144 1
static const char rcsid[] = "$OpenBSD: parsetime.c,v 1.14 2004/06/17 22:09:11 millert Exp $";
d688 1
a688 1
		fprintf(stderr, "%s: Trying to travel back in time\n",
@


1.14
log
@Remove trailing whitespace and, for printf, uid/gid are unsigned
@
text
@d1 1
a1 1
/*	$OpenBSD: parsetime.c,v 1.13 2003/02/20 20:38:08 millert Exp $	*/
d135 1
a135 1
static char scc;	/* scanner - count of remaining arguments */
d144 1
a144 1
static const char rcsid[] = "$OpenBSD: parsetime.c,v 1.13 2003/02/20 20:38:08 millert Exp $";
d344 1
d347 1
d350 1
d650 1
d653 1
d663 1
@


1.13
log
@Sync with ISC cron-current + my at(1) integration.
The at(1) code is now more tightly integrated into the cron codebase.
@
text
@d1 1
a1 1
/*	$OpenBSD: parsetime.c,v 1.12 2002/06/14 21:35:00 todd Exp $	*/
d3 1
a3 1
/* 
d144 1
a144 1
static const char rcsid[] = "$OpenBSD: parsetime.c,v 1.12 2002/06/14 21:35:00 todd Exp $";
d269 1
a269 1
/* 
d470 1
a470 1
/* 
@


1.12
log
@spelling; from Brian Poole <raj@@cerias.purdue.edu>
@
text
@d1 1
a1 2
/*	$OpenBSD: parsetime.c,v 1.11 2002/05/14 18:05:39 millert Exp $	*/
/*	$NetBSD: parsetime.c,v 1.3 1995/03/25 18:13:36 glass Exp $	*/
a38 1
#include <err.h>
d48 1
a49 2
#include "panic.h"

d144 1
a144 1
static const char rcsid[] = "$OpenBSD: parsetime.c,v 1.11 2002/05/14 18:05:39 millert Exp $";
d170 1
a170 1
static void
d180 6
a185 2
	if ((sc_token = (char *) malloc(sc_len)) == NULL)
		panic("Insufficient virtual memory");
d197 1
a197 1
		(void)memset(sc_token, 0, sc_len);
d264 2
a265 1
	panic((tok == EOF) ? "incomplete time" : "garbled time");
d270 1
a270 1
 * expect() gets a token and dies most horribly if it's not the token we want
d272 1
a272 1
static void
d275 5
a279 2
	if (token() != desired)
		plonk(sc_tokid);	/* and we die here... */
d329 1
a329 1
static void
d335 2
a336 1
	expect(NUMBER);
d350 2
a351 1
			warnx("pluralization is wrong");
d353 1
a353 1
		return;
d357 1
d365 1
a365 1
static void
d379 2
a380 1
		expect(NUMBER);
d383 1
a383 1
			panic("garbled time");
d388 1
a388 1
			panic("garbled time");
d397 1
a397 1
			panic("garbled time");
d408 1
a408 1
		panic("garbled time");
d426 4
d479 1
a479 1
static void
d488 2
a489 1
		plus(tm);
d507 2
a508 1
		expect(NUMBER);
d548 2
a549 1
			expect(NUMBER);
d552 2
a553 1
				expect(NUMBER);
d577 1
a577 1
			panic("garbled time");
d581 1
a581 1
			panic("garbled time");
d585 5
a589 1
	} /* case */
d605 3
d615 2
a616 4
	if (argc == 0)
		usage();

	init_scanner(argc, argv);
d628 2
a629 1
		plus(&runtime);
d633 2
a634 2
		tod(&runtime);
		month(&runtime);
d659 2
a660 1
		month(&runtime);
d663 2
a664 1
	expect(EOF);
d676 4
a679 2
	if (runtimer < 0)
		panic("garbled time");
d681 5
a685 2
	if (nowtimer > runtimer)
		panic("Trying to travel back in time");
@


1.11
log
@Major changes:

Job names are now "runtime.queue" where runtime is when the job will run
in Unix time format.  This is what SysV at does and allows us to nuke
the .SEQ file.

Historic BSD options for atq and atrm are now implemented;
atq and atrm get their own man pages.

At no longer does anything with the -v flag.  We print the execution
time when jobs are submitted so there is no need.

Most *scanf() usage is gone (one remains in atrun).

Better sanity checks in atrun.

Random style/cleanup.

With these changes we have the best of both worlds; POSIX compliance with
the traditional BSD features.
@
text
@d1 1
a1 1
/*	$OpenBSD: parsetime.c,v 1.10 2002/05/11 23:16:44 millert Exp $	*/
d142 1
a142 1
static size_t sc_len;   /* scanner - lenght of token buffer */
d147 1
a147 1
static const char rcsid[] = "$OpenBSD: parsetime.c,v 1.10 2002/05/11 23:16:44 millert Exp $";
@


1.10
log
@Pass -Wall and use ANSI function headers.
@
text
@d1 1
a1 1
/*	$OpenBSD: parsetime.c,v 1.9 2000/01/05 08:06:25 millert Exp $	*/
a38 2
/* System Headers */

d40 1
d42 1
a48 4
#include <ctype.h>
#include <err.h>

/* Local headers */
a136 2
/* File scope variables */

a140 1

d147 1
a147 1
static const char rcsid[] = "$OpenBSD: parsetime.c,v 1.9 2000/01/05 08:06:25 millert Exp $";
a149 2
/* Local functions */

d167 1
a167 1
} /* parse_token */
d185 1
a185 1
} /* init_scanner */
d253 2
a254 2
	} /* while (1) */
} /* token */
d264 1
a264 1
} /* plonk */
d275 1
a275 1
} /* expect */
d315 1
a315 1
} /* dateadd */
d350 1
a350 1
} /* plus */
d417 1
a417 1
} /* tod */
d454 1
a454 1
} /* assign_date */
d569 1
a569 2
} /* month */

a570 1
/* Global functions */
d591 1
a591 1
	if (argc <= optind)
d594 1
a594 1
	init_scanner(argc - optind, argv + optind);
d658 1
a658 1
} /* parsetime */
@


1.9
log
@Y2K fix.  at(1) would die with 'garbled time' when assign_date() was passed
a year > 99.  This change fixes the conversion of 2-digit years into
tm_year format.
@
text
@d1 1
a1 1
/*	$OpenBSD: parsetime.c,v 1.8 1999/03/21 04:04:42 alex Exp $	*/
d154 1
a154 1
static char rcsid[] = "$OpenBSD: parsetime.c,v 1.8 1999/03/21 04:04:42 alex Exp $";
d163 1
a163 2
parse_token(arg)
	char *arg;
d183 1
a183 3
init_scanner(argc, argv)
	int argc;
	char **argv;
d200 1
a200 1
token()
d204 1
a204 1
	while (1) {
d270 1
a270 2
plonk(tok)
	int tok;
d280 1
a280 2
expect(desired)
	int desired;
d293 1
a293 3
dateadd(minutes, tm)
	int minutes;
	struct tm *tm;
d334 1
a334 2
plus(tm)
	struct tm *tm;
d367 1
a367 2
tod(tm)
	struct tm *tm;
d433 1
a433 3
assign_date(tm, mday, mon, year)
	struct tm *tm;
	int mday, mon, year;
d476 1
a476 2
month(tm)
	struct tm *tm;
d584 1
a584 3
parsetime(argc, argv)
	int argc;
	char **argv;
@


1.8
log
@PR 778: Handle 2-digit year values post-Y2K.  Improvements to PR 778
provided by pjanzen.
@
text
@d1 1
a1 1
/*	$OpenBSD: parsetime.c,v 1.7 1998/07/10 07:07:04 deraadt Exp $	*/
d154 1
a154 1
static char rcsid[] = "$OpenBSD: parsetime.c,v 1.7 1998/07/10 07:07:04 deraadt Exp $";
d446 17
a462 15
	if (year > 99) {
	    if (year >= TM_YEAR_BASE)
		    year -= TM_YEAR_BASE;
	    else
		    panic("garbled time");
	} else if (year != -1) {
		/*
		 * check if the specified year is in the next century.
		 * allow for one year of user error as many people will
		 * enter n - 1 at the start of year n.
		 */
		if (year < tm->tm_year % 100 - 1)
			year += 100;
		/* adjust for the year 2000 and beyond */
		year += tm->tm_year - (tm->tm_year % 100);
@


1.7
log
@long month names; archie@@whistle.com
@
text
@d1 1
a1 1
/*	$OpenBSD: parsetime.c,v 1.6 1998/07/09 20:40:59 mickey Exp $	*/
d47 1
d154 1
a154 1
static char rcsid[] = "$OpenBSD: parsetime.c,v 1.6 1998/07/09 20:40:59 mickey Exp $";
d447 2
a448 2
	    if (year > 1899)
		    year -= 1900;
d451 10
d570 1
a570 1
				year = (mon % 10000) - 1900;
@


1.6
log
@user err/warn; some -Wall
@
text
@d1 1
a1 1
/*	$OpenBSD: parsetime.c,v 1.5 1998/06/26 03:20:11 millert Exp $	*/
d112 12
d153 1
a153 1
static char rcsid[] = "$OpenBSD: parsetime.c,v 1.5 1998/06/26 03:20:11 millert Exp $";
@


1.5
log
@make 'now' work as a timespec
@
text
@d1 1
a1 1
/*	$OpenBSD: parsetime.c,v 1.4 1997/03/01 23:40:10 millert Exp $	*/
d49 1
d141 1
a141 1
static char rcsid[] = "$OpenBSD: parsetime.c,v 1.4 1997/03/01 23:40:10 millert Exp $";
d348 1
a348 1
			(void)fprintf(stderr, "at: pluralization is wrong\n");
@


1.4
log
@Merge in changes from at 2.9
@
text
@d1 1
a1 1
/*	$OpenBSD: parsetime.c,v 1.3 1996/06/26 05:31:29 deraadt Exp $	*/
d140 1
a140 1
static char rcsid[] = "$OpenBSD: parsetime.c,v 1.3 1996/06/26 05:31:29 deraadt Exp $";
d597 7
a603 1
		expect(PLUS);
@


1.3
log
@rcsid
@
text
@d1 1
a1 1
/*	$OpenBSD: parsetime.c,v 1.3 1995/03/25 18:13:36 glass Exp $	*/
d6 1
a6 1
 * Copyright (C) 1993  Thomas Koenig
a9 1
 * All rights reserved.
d23 1
a23 1
 * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
d34 3
a36 2
 *     |MIDNIGHT                   | |NUMBER [SLASH NUMBER [SLASH NUMBER]]|
 *     \TEATIME                    / \PLUS NUMBER MINUTES|HOURS|DAYS|WEEKS/
d59 7
a65 6
    MIDNIGHT, NOON, TEATIME,
    PM, AM, TOMORROW, TODAY, NOW,
    MINUTES, HOURS, DAYS, WEEKS,
    NUMBER, PLUS, DOT, SLASH, ID, JUNK,
    JAN, FEB, MAR, APR, MAY, JUN,
    JUL, AUG, SEP, OCT, NOV, DEC
d72 3
a74 2
    char *name;	/* token name */
    int value;	/* token id */
d76 50
a125 36
    { "midnight", MIDNIGHT },	/* 00:00:00 of today or tomorrow */
    { "noon", NOON },		/* 12:00:00 of today or tomorrow */
    { "teatime", TEATIME },	/* 16:00:00 of today or tomorrow */
    { "am", AM },		/* morning times for 0-12 clock */
    { "pm", PM },		/* evening times for 0-12 clock */
    { "tomorrow", TOMORROW },	/* execute 24 hours from time */
    { "today", TODAY },		/* execute today - don't advance time */
    { "now", NOW },		/* opt prefix for PLUS */

    { "minute", MINUTES },	/* minutes multiplier */
    { "min", MINUTES },
    { "m", MINUTES },
    { "minutes", MINUTES },	/* (pluralized) */
    { "hour", HOURS },		/* hours ... */
    { "hr", HOURS },		/* abbreviated */
    { "h", HOURS },
    { "hours", HOURS },		/* (pluralized) */
    { "day", DAYS },		/* days ... */
    { "d", DAYS },
    { "days", DAYS },		/* (pluralized) */
    { "week", WEEKS },		/* week ... */
    { "w", WEEKS },
    { "weeks", WEEKS },		/* (pluralized) */
    { "jan", JAN },
    { "feb", FEB },
    { "mar", MAR },
    { "apr", APR },
    { "may", MAY },
    { "jun", JUN },
    { "jul", JUL },
    { "aug", AUG },
    { "sep", SEP },
    { "oct", OCT },
    { "nov", NOV },
    { "dec", DEC }
} ;
d137 1
d140 1
a140 1
static char rcsid[] = "$OpenBSD: parsetime.c,v 1.3 1995/03/25 18:13:36 glass Exp $";
d152 1
a152 1
    int i;
d154 5
a158 3
    for (i=0; i<(sizeof Specials/sizeof Specials[0]); i++)
	if (strcasecmp(Specials[i].name, arg) == 0) {
	    return sc_tokid = Specials[i].value;
d161 2
a162 2
    /* not special - must be some random id */
    return ID;
d174 9
a182 10
    scp = argv;
    scc = argc;
    need = 1;
    sc_len = 1;
    while (--argc > 0)
	sc_len += strlen(*++argv);

    sc_token = (char *) malloc(sc_len);
    if (sc_token == NULL)
	panic("Insufficient virtual memory");
d191 1
a191 1
    int idx;
d193 5
a197 4
    while (1) {
	memset(sc_token, 0, sc_len);
	sc_tokid = EOF;
	idx = 0;
d199 24
a222 23
	/*
	 * if we need to read another argument, walk along the argument list;
	 * when we fall off the arglist, we'll just return EOF forever
	 */
	if (need) {
	    if (scc < 1)
		return sc_tokid;
	    sct = *scp;
	    scp++;
	    scc--;
	    need = 0;
	}
	/*
	 * eat whitespace now - if we walk off the end of the argument,
	 * we'll continue, which puts us up at the top of the while loop
	 * to fetch the next argument in
	 */
	while (isspace(*sct))
	    ++sct;
	if (!*sct) {
	    need = 1;
	    continue;
	}
d224 4
a227 4
	/*
	 * preserve the first character of the new token
	 */
	sc_token[0] = *sct++;
d229 23
a251 23
	/*
	 * then see what it is
	 */
	if (isdigit(sc_token[0])) {
	    while (isdigit(*sct))
		sc_token[++idx] = *sct++;
	    sc_token[++idx] = 0;
	    return sc_tokid = NUMBER;
	} else if (isalpha(sc_token[0])) {
	    while (isalpha(*sct))
		sc_token[++idx] = *sct++;
	    sc_token[++idx] = 0;
	    return parse_token(sc_token);
	}
	else if (sc_token[0] == ':' || sc_token[0] == '.')
	    return sc_tokid = DOT;
	else if (sc_token[0] == '+')
	    return sc_tokid = PLUS;
	else if (sc_token[0] == '/')
	    return sc_tokid = SLASH;
	else
	    return sc_tokid = JUNK;
    } /* while (1) */
d262 1
a262 2
    panic((tok == EOF) ? "incomplete time"
		       : "garbled time");
d273 2
a274 2
    if (token() != desired)
	plonk(sc_tokid);	/* and we die here... */
d288 1
a288 1
    /* increment days */
d290 3
a292 12
    while (minutes > 24*60) {
	minutes -= 24*60;
	tm->tm_mday++;
    }

    /* increment hours */
    while (minutes > 60) {
	minutes -= 60;
	tm->tm_hour++;
	if (tm->tm_hour > 23) {
	    tm->tm_mday++;
	    tm->tm_hour = 0;
a293 1
    }
d295 12
a306 2
    /* increment minutes */
    tm->tm_min += minutes;
d308 8
a315 7
    if (tm->tm_min > 59) {
	tm->tm_hour++;
	tm->tm_min -= 60;

	if (tm->tm_hour > 23) {
	    tm->tm_mday++;
	    tm->tm_hour = 0;
a316 1
    }
d330 4
a333 1
    int delay;
d335 2
a336 1
    expect(NUMBER);
d338 13
a350 1
    delay = atoi(sc_token);
d352 1
a352 12
    switch (token()) {
    case WEEKS:
	    delay *= 7;
    case DAYS:
	    delay *= 24;
    case HOURS:
	    delay *= 60;
    case MINUTES:
	    dateadd(delay, tm);
	    return;
    }
    plonk(sc_tokid);
d364 22
a385 2
    int hour, minute = 0;
    int tlen;
d387 17
a403 2
    hour = atoi(sc_token);
    tlen = strlen(sc_token);
d405 9
a413 38
    /*
     * first pick out the time of day - if it's 4 digits, we assume
     * a HHMM time, otherwise it's HH DOT MM time
     */
    if (token() == DOT) {
	expect(NUMBER);
	minute = atoi(sc_token);
	token();
    } else if (tlen == 4) {
	minute = hour%100;
	hour = hour/100;
    }

    if (minute > 59)
	panic("garbled time");

    /*
     * check if an AM or PM specifier was given
     */
    if (sc_tokid == AM || sc_tokid == PM) {
	if (hour > 12)
	    panic("garbled time");
	else if (hour == 12)
	    hour = 0;

	if (sc_tokid == PM)
	    hour += 12;
	token();
    } else if (hour > 23)
	panic("garbled time");

    /*
     * if we specify an absolute time, we don't want to bump the day even
     * if we've gone past that time - but if we're specifying a time plus
     * a relative offset, it's okay to bump things
     */
    if ((sc_tokid == EOF || sc_tokid == PLUS) && tm->tm_hour > hour)
	tm->tm_mday++;
d415 6
a420 2
    tm->tm_hour = hour;
    tm->tm_min = minute;
d430 1
a430 1
	long mday, mon, year;
d432 10
a441 10
    if (year > 99) {
	if (year > 1899)
	    year -= 1900;
	else
	    panic("garbled time");
    }

    if (year < 0 &&
	(tm->tm_mon > mon ||(tm->tm_mon == mon && tm->tm_mday > mday)))
	year = tm->tm_year + 1;
d443 2
a444 2
    tm->tm_mday = mday;
    tm->tm_mon = mon;
d446 2
a447 2
    if (year >= 0)
	tm->tm_year = year;
d456 1
d464 15
a478 26
    long year= (-1);
    long mday, mon;
    int tlen;

    switch (sc_tokid) {
    case PLUS:
	    plus(tm);
	    break;

    case TOMORROW:
	    /* do something tomorrow */
	    tm->tm_mday ++;
    case TODAY:	/* force ourselves to stay in today - no further processing */
	    token();
	    break;

    case JAN: case FEB: case MAR: case APR: case MAY: case JUN:
    case JUL: case AUG: case SEP: case OCT: case NOV: case DEC:
	    /*
	     * do month mday [year]
	     */
	    mon = (sc_tokid-JAN);
	    expect(NUMBER);
	    mday = atol(sc_token);
	    if (token() == NUMBER) {
		year = atol(sc_token);
d480 1
a480 11
	    }
	    assign_date(tm, mday, mon, year);
	    break;

    case NUMBER:
	    /*
	     * get numeric MMDDYY, mm/dd/yy, or dd.mm.yy
	     */
	    tlen = strlen(sc_token);
	    mon = atol(sc_token);
	    token();
d482 6
a487 4
	    if (sc_tokid == SLASH || sc_tokid == DOT) {
		int sep;

		sep = sc_tokid;
d489 4
a492 5
		mday = atol(sc_token);
		if (token() == sep) {
		    expect(NUMBER);
		    year = atol(sc_token);
		    token();
d494 21
d516 1
d518 1
a518 1
		 * flip months and days for european timing
d520 3
a522 17
		if (sep == DOT) {
		    int x = mday;
		    mday = mon;
		    mon = x;
		}
	    } else if (tlen == 6 || tlen == 8) {
		if (tlen == 8) {
		    year = (mon % 10000) - 1900;
		    mon /= 10000;
		} else {
		    year = mon % 100;
		    mon /= 100;
		}
		mday = mon % 100;
		mon /= 100;
	    } else
		panic("garbled time");
d524 2
a525 3
	    mon--;
	    if (mon < 0 || mon > 11 || mday < 1 || mday > 31)
		panic("garbled time");
d527 37
a563 3
	    assign_date(tm, mday, mon, year);
	    break;
    } /* case */
d574 64
a637 65
/*
 * Do the argument parsing, die if necessary, and return the time the job
 * should be run.
 */
    time_t nowtimer, runtimer;
    struct tm nowtime, runtime;
    int hr = 0;
    /* this MUST be initialized to zero for midnight/noon/teatime */

    nowtimer = time(NULL);
    nowtime = *localtime(&nowtimer);

    runtime = nowtime;
    runtime.tm_sec = 0;
    runtime.tm_isdst = 0;

    if (argc <= optind)
	usage();

    init_scanner(argc-optind, argv+optind);

    switch (token()) {
    case NOW:	/* now is optional prefix for PLUS tree */
	    expect(PLUS);
    case PLUS:
	    plus(&runtime);
	    break;

    case NUMBER:
	    tod(&runtime);
	    month(&runtime);
	    break;

	    /*
	     * evil coding for TEATIME|NOON|MIDNIGHT - we've initialised
	     * hr to zero up above, then fall into this case in such a
	     * way so we add +12 +4 hours to it for teatime, +12 hours
	     * to it for noon, and nothing at all for midnight, then
	     * set our runtime to that hour before leaping into the
	     * month scanner
	     */
    case TEATIME:
	    hr += 4;
    case NOON:
	    hr += 12;
    case MIDNIGHT:
	    if (runtime.tm_hour >= hr)
		runtime.tm_mday++;
	    runtime.tm_hour = hr;
	    runtime.tm_min = 0;
	    token();
	    /* fall through to month setting */
    default:
	    month(&runtime);
	    break;
    } /* ugly case statement */
    expect(EOF);

    /*
     * adjust for daylight savings time
     */
    runtime.tm_isdst = -1;
    runtimer = mktime(&runtime);
    if (runtime.tm_isdst > 0) {
	runtimer -= 3600;
d639 4
a642 1
    }
d644 2
a645 2
    if (runtimer < 0)
	panic("garbled time");
d647 2
a648 2
    if (nowtimer > runtimer)
	panic("Trying to travel back in time");
d650 1
a650 1
    return runtimer;
@


1.2
log
@got am/pm reversed when hour is 12; from Mark_Weaver@@brown.edu; netbsd pr#1743
@
text
@d1 1
d123 1
a123 1
static char rcsid[] = "$NetBSD: parsetime.c,v 1.3 1995/03/25 18:13:36 glass Exp $";
@


1.1
log
@Initial revision
@
text
@a351 2
	if (minute > 59)
	    panic("garbled time");
a354 2
	if (minute > 59)
	    panic("garbeld time");
d358 3
d367 2
a385 4
    if (tm->tm_hour == 24) {
	tm->tm_hour = 0;
	tm->tm_mday++;
    }
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@
