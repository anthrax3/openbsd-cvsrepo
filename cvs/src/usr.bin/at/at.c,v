head	1.79;
access;
symbols
	OPENBSD_6_1:1.79.0.4
	OPENBSD_6_1_BASE:1.79
	OPENBSD_6_0:1.77.0.4
	OPENBSD_6_0_BASE:1.77
	OPENBSD_5_9:1.77.0.2
	OPENBSD_5_9_BASE:1.77
	OPENBSD_5_8:1.64.0.6
	OPENBSD_5_8_BASE:1.64
	OPENBSD_5_7:1.64.0.2
	OPENBSD_5_7_BASE:1.64
	OPENBSD_5_6:1.62.0.6
	OPENBSD_5_6_BASE:1.62
	OPENBSD_5_5:1.62.0.4
	OPENBSD_5_5_BASE:1.62
	OPENBSD_5_4:1.61.0.2
	OPENBSD_5_4_BASE:1.61
	OPENBSD_5_3:1.60.0.6
	OPENBSD_5_3_BASE:1.60
	OPENBSD_5_2:1.60.0.4
	OPENBSD_5_2_BASE:1.60
	OPENBSD_5_1_BASE:1.60
	OPENBSD_5_1:1.60.0.2
	OPENBSD_5_0:1.58.0.2
	OPENBSD_5_0_BASE:1.58
	OPENBSD_4_9:1.57.0.4
	OPENBSD_4_9_BASE:1.57
	OPENBSD_4_8:1.57.0.2
	OPENBSD_4_8_BASE:1.57
	OPENBSD_4_7:1.56.0.2
	OPENBSD_4_7_BASE:1.56
	OPENBSD_4_6:1.54.0.10
	OPENBSD_4_6_BASE:1.54
	OPENBSD_4_5:1.54.0.6
	OPENBSD_4_5_BASE:1.54
	OPENBSD_4_4:1.54.0.4
	OPENBSD_4_4_BASE:1.54
	OPENBSD_4_3:1.54.0.2
	OPENBSD_4_3_BASE:1.54
	OPENBSD_4_2:1.52.0.2
	OPENBSD_4_2_BASE:1.52
	OPENBSD_4_1:1.46.0.4
	OPENBSD_4_1_BASE:1.46
	OPENBSD_4_0:1.46.0.2
	OPENBSD_4_0_BASE:1.46
	OPENBSD_3_9:1.44.0.2
	OPENBSD_3_9_BASE:1.44
	OPENBSD_3_8:1.43.0.2
	OPENBSD_3_8_BASE:1.43
	OPENBSD_3_7:1.42.0.4
	OPENBSD_3_7_BASE:1.42
	OPENBSD_3_6:1.42.0.2
	OPENBSD_3_6_BASE:1.42
	OPENBSD_3_5:1.40.0.2
	OPENBSD_3_5_BASE:1.40
	OPENBSD_3_4:1.39.0.2
	OPENBSD_3_4_BASE:1.39
	OPENBSD_3_3:1.37.0.2
	OPENBSD_3_3_BASE:1.37
	OPENBSD_3_2:1.30.0.2
	OPENBSD_3_2_BASE:1.30
	OPENBSD_3_1:1.21.0.2
	OPENBSD_3_1_BASE:1.21
	OPENBSD_3_0:1.20.0.4
	OPENBSD_3_0_BASE:1.20
	OPENBSD_2_9_BASE:1.20
	OPENBSD_2_9:1.20.0.2
	OPENBSD_2_8:1.19.0.4
	OPENBSD_2_8_BASE:1.19
	OPENBSD_2_7:1.19.0.2
	OPENBSD_2_7_BASE:1.19
	OPENBSD_2_6:1.16.0.6
	OPENBSD_2_6_BASE:1.16
	OPENBSD_2_5:1.16.0.4
	OPENBSD_2_5_BASE:1.16
	OPENBSD_2_4:1.16.0.2
	OPENBSD_2_4_BASE:1.16
	OPENBSD_2_3:1.14.0.4
	OPENBSD_2_3_BASE:1.14
	OPENBSD_2_2:1.14.0.2
	OPENBSD_2_2_BASE:1.14
	OPENBSD_2_1:1.11.0.2
	OPENBSD_2_1_BASE:1.11
	OPENBSD_2_0:1.3.0.2
	OPENBSD_2_0_BASE:1.3
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.79
date	2017.03.18.02.58.54;	author deraadt;	state Exp;
branches;
next	1.78;
commitid	OG9plnN2d0OsRkFi;

1.78
date	2016.10.31.17.22.07;	author schwarze;	state Exp;
branches;
next	1.77;
commitid	Ws10o7uhYycWcIu3;

1.77
date	2015.11.16.16.43.06;	author millert;	state Exp;
branches;
next	1.76;
commitid	BeMjivqs84LhFBct;

1.76
date	2015.11.13.21.35.34;	author millert;	state Exp;
branches;
next	1.75;
commitid	RN5CqSoywjewMpfG;

1.75
date	2015.11.13.21.34.06;	author millert;	state Exp;
branches;
next	1.74;
commitid	vZNTC7bzkunUPuVe;

1.74
date	2015.11.12.21.12.05;	author millert;	state Exp;
branches;
next	1.73;
commitid	6PlWoK7FsQNDGZmn;

1.73
date	2015.11.11.21.53.51;	author millert;	state Exp;
branches;
next	1.72;
commitid	H333VmQKKjRMUHC3;

1.72
date	2015.11.11.17.17.56;	author millert;	state Exp;
branches;
next	1.71;
commitid	bkyqb7JXktKjflr1;

1.71
date	2015.11.11.15.23.06;	author millert;	state Exp;
branches;
next	1.70;
commitid	XHoDCQXe22HEKGnM;

1.70
date	2015.11.09.15.57.39;	author millert;	state Exp;
branches;
next	1.69;
commitid	JJzvBekc1nrVHuHQ;

1.69
date	2015.11.06.23.47.42;	author millert;	state Exp;
branches;
next	1.68;
commitid	8eaJrEU7qiymGijK;

1.68
date	2015.11.04.20.28.17;	author millert;	state Exp;
branches;
next	1.67;
commitid	6N0oXtYc5KM1a7DW;

1.67
date	2015.11.03.16.28.43;	author millert;	state Exp;
branches;
next	1.66;
commitid	z8wj3ewlVKG08mTz;

1.66
date	2015.10.28.20.17.31;	author deraadt;	state Exp;
branches;
next	1.65;
commitid	UvqbYTR2CmTeyJXL;

1.65
date	2015.08.20.22.32.41;	author deraadt;	state Exp;
branches;
next	1.64;
commitid	0Dp7Dy9FuNZesYo2;

1.64
date	2014.10.08.03.56.52;	author doug;	state Exp;
branches;
next	1.63;
commitid	tAMDPapgIPjKdUEv;

1.63
date	2014.09.29.18.44.49;	author millert;	state Exp;
branches;
next	1.62;
commitid	FIEil1JAUU0WU2o8;

1.62
date	2013.11.25.18.02.50;	author deraadt;	state Exp;
branches;
next	1.61;

1.61
date	2013.04.17.15.58.42;	author deraadt;	state Exp;
branches;
next	1.60;

1.60
date	2011.08.30.19.56.08;	author guenther;	state Exp;
branches;
next	1.59;

1.59
date	2011.08.23.15.06.37;	author millert;	state Exp;
branches;
next	1.58;

1.58
date	2011.03.03.15.06.43;	author millert;	state Exp;
branches;
next	1.57;

1.57
date	2010.07.02.23.40.09;	author krw;	state Exp;
branches;
next	1.56;

1.56
date	2009.10.27.23.59.35;	author deraadt;	state Exp;
branches;
next	1.55;

1.55
date	2009.10.05.20.47.19;	author deraadt;	state Exp;
branches;
next	1.54;

1.54
date	2007.09.05.08.02.21;	author moritz;	state Exp;
branches;
next	1.53;

1.53
date	2007.09.02.15.19.31;	author deraadt;	state Exp;
branches;
next	1.52;

1.52
date	2007.06.18.11.20.58;	author millert;	state Exp;
branches;
next	1.51;

1.51
date	2007.05.24.12.24.43;	author millert;	state Exp;
branches;
next	1.50;

1.50
date	2007.05.23.22.34.03;	author millert;	state Exp;
branches;
next	1.49;

1.49
date	2007.05.23.22.30.53;	author millert;	state Exp;
branches;
next	1.48;

1.48
date	2007.05.23.19.50.28;	author millert;	state Exp;
branches;
next	1.47;

1.47
date	2007.03.26.13.55.42;	author jmc;	state Exp;
branches;
next	1.46;

1.46
date	2006.04.26.03.01.48;	author cloder;	state Exp;
branches;
next	1.45;

1.45
date	2006.03.22.21.51.39;	author robert;	state Exp;
branches;
next	1.44;

1.44
date	2005.10.25.15.49.38;	author jmc;	state Exp;
branches;
next	1.43;

1.43
date	2005.06.23.14.39.35;	author jmc;	state Exp;
branches;
next	1.42;

1.42
date	2004.06.17.22.09.11;	author millert;	state Exp;
branches;
next	1.41;

1.41
date	2004.06.03.19.19.07;	author millert;	state Exp;
branches;
next	1.40;

1.40
date	2003.09.26.21.26.40;	author tedu;	state Exp;
branches;
next	1.39;

1.39
date	2003.07.23.16.53.33;	author mpech;	state Exp;
branches;
next	1.38;

1.38
date	2003.05.04.21.06.30;	author avsm;	state Exp;
branches;
next	1.37;

1.37
date	2003.03.13.21.28.30;	author millert;	state Exp;
branches;
next	1.36;

1.36
date	2003.03.03.18.23.13;	author millert;	state Exp;
branches;
next	1.35;

1.35
date	2003.02.20.20.38.08;	author millert;	state Exp;
branches;
next	1.34;

1.34
date	2003.02.18.02.25.39;	author millert;	state Exp;
branches;
next	1.33;

1.33
date	2003.02.17.21.47.19;	author millert;	state Exp;
branches;
next	1.32;

1.32
date	2003.01.02.15.48.40;	author mpech;	state Exp;
branches;
next	1.31;

1.31
date	2002.11.20.19.57.19;	author millert;	state Exp;
branches;
next	1.30;

1.30
date	2002.07.15.19.13.29;	author millert;	state Exp;
branches
	1.30.2.1;
next	1.29;

1.29
date	2002.05.14.18.05.39;	author millert;	state Exp;
branches;
next	1.28;

1.28
date	2002.05.13.18.43.53;	author millert;	state Exp;
branches;
next	1.27;

1.27
date	2002.05.13.16.12.07;	author millert;	state Exp;
branches;
next	1.26;

1.26
date	2002.05.11.23.16.44;	author millert;	state Exp;
branches;
next	1.25;

1.25
date	2002.05.11.23.02.33;	author millert;	state Exp;
branches;
next	1.24;

1.24
date	2002.05.11.21.56.54;	author millert;	state Exp;
branches;
next	1.23;

1.23
date	2002.05.11.21.37.13;	author millert;	state Exp;
branches;
next	1.22;

1.22
date	2002.05.11.18.41.20;	author millert;	state Exp;
branches;
next	1.21;

1.21
date	2002.02.16.21.27.44;	author millert;	state Exp;
branches;
next	1.20;

1.20
date	2001.01.17.19.29.06;	author deraadt;	state Exp;
branches;
next	1.19;

1.19
date	2000.04.23.16.32.07;	author millert;	state Exp;
branches;
next	1.18;

1.18
date	2000.01.21.04.22.54;	author millert;	state Exp;
branches;
next	1.17;

1.17
date	99.12.15.05.33.06;	author deraadt;	state Exp;
branches;
next	1.16;

1.16
date	98.07.09.20.40.58;	author mickey;	state Exp;
branches;
next	1.15;

1.15
date	98.06.03.16.20.26;	author deraadt;	state Exp;
branches;
next	1.14;

1.14
date	97.10.06.18.31.01;	author deraadt;	state Exp;
branches;
next	1.13;

1.13
date	97.06.17.20.48.04;	author kstailey;	state Exp;
branches;
next	1.12;

1.12
date	97.06.12.16.57.44;	author kstailey;	state Exp;
branches;
next	1.11;

1.11
date	97.03.03.03.34.34;	author millert;	state Exp;
branches;
next	1.10;

1.10
date	97.03.03.03.31.10;	author millert;	state Exp;
branches;
next	1.9;

1.9
date	97.03.03.00.30.02;	author millert;	state Exp;
branches;
next	1.8;

1.8
date	97.03.02.19.59.15;	author millert;	state Exp;
branches;
next	1.7;

1.7
date	97.03.01.23.40.09;	author millert;	state Exp;
branches;
next	1.6;

1.6
date	97.01.15.23.42.12;	author millert;	state Exp;
branches;
next	1.5;

1.5
date	96.10.26.20.06.50;	author millert;	state Exp;
branches;
next	1.4;

1.4
date	96.10.15.23.22.35;	author millert;	state Exp;
branches;
next	1.3;

1.3
date	96.08.03.20.16.52;	author millert;	state Exp;
branches;
next	1.2;

1.2
date	96.06.26.05.31.27;	author deraadt;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.44.54;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.44.54;	author deraadt;	state Exp;
branches;
next	;

1.30.2.1
date	2003.03.18.04.06.47;	author margarida;	state Exp;
branches;
next	;


desc
@@


1.79
log
@Use recallocarray for growth of the jobs, just because it is a little
beefier than pointers.
@
text
@/*	$OpenBSD: at.c,v 1.78 2016/10/31 17:22:07 schwarze Exp $	*/

/*
 *  at.c : Put file into atrun queue
 *  Copyright (C) 1993, 1994  Thomas Koenig
 *
 *  Atrun & Atq modifications
 *  Copyright (C) 1993  David Parsons
 *
 *  Traditional BSD behavior and other significant modifications
 *  Copyright (C) 2002-2003  Todd C. Miller
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. The name of the author(s) may not be used to endorse or promote
 *    products derived from this software without specific prior written
 *    permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR(S) ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 * IN NO EVENT SHALL THE AUTHOR(S) BE LIABLE FOR ANY DIRECT, INDIRECT,
 * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
 * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

#include <sys/types.h>
#include <sys/stat.h>

#include <bitstring.h>                  /* for structs.h */
#include <ctype.h>
#include <dirent.h>
#include <err.h>
#include <errno.h>
#include <fcntl.h>
#include <limits.h>
#include <pwd.h>
#include <signal.h>
#include <stdarg.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <syslog.h>
#include <time.h>
#include <unistd.h>

#include "pathnames.h"
#include "macros.h"
#include "structs.h"
#include "funcs.h"
#include "globals.h"

#include "at.h"

#define ALARMC 10		/* Number of seconds to wait for timeout */
#define TIMESIZE 50		/* Size of buffer passed to strftime() */

/* Variables to remove from the job's environment. */
char *no_export[] =
{
	"TERM", "TERMCAP", "DISPLAY", "_", "SHELLOPTS", "BASH_VERSINFO",
	"EUID", "GROUPS", "PPID", "UID", "SSH_AUTH_SOCK", "SSH_AGENT_PID",
};

static int program = AT;	/* default program mode */
static char atfile[PATH_MAX];	/* path to the at spool file */
static char user_name[MAX_UNAME];/* invoking user name */
static int fcreated;		/* whether or not we created the file yet */
static char atqueue = 0;	/* which queue to examine for jobs (atq) */
static char vflag = 0;		/* show completed but unremoved jobs (atq) */
static char force = 0;		/* suppress errors (atrm) */
static char interactive = 0;	/* interactive mode (atrm) */
static int send_mail = 0;	/* whether we are sending mail */
static uid_t user_uid;		/* user's real uid */
static gid_t user_gid;		/* user's real gid */
static gid_t spool_gid;		/* gid for writing to at spool */

static void sigc(int);
static void writefile(const char *, time_t, char);
static void list_jobs(int, char **, int, int);
static time_t ttime(char *);
static __dead void fatal(const char *, ...)
    __attribute__((__format__ (printf, 1, 2)));
static __dead void fatalx(const char *, ...)
    __attribute__((__format__ (printf, 1, 2)));
static __dead void usage(void);
static int rmok(long long);
time_t parsetime(int, char **);

/*
 * Something fatal has happened, print error message and exit.
 */
static __dead void
fatal(const char *fmt, ...)
{
	va_list ap;

	va_start(ap, fmt);
	vwarn(fmt, ap);
	va_end(ap);

	if (fcreated)
		unlink(atfile);

	exit(EXIT_FAILURE);
}

/*
 * Something fatal has happened, print error message and exit.
 */
static __dead void
fatalx(const char *fmt, ...)
{
	va_list ap;

	va_start(ap, fmt);
	vwarnx(fmt, ap);
	va_end(ap);

	if (fcreated)
		unlink(atfile);

	exit(EXIT_FAILURE);
}

/* ARGSUSED */
static void
sigc(int signo)
{
	/* If the user presses ^C, remove the spool file and exit. */
	if (fcreated)
		(void)unlink(atfile);

	_exit(EXIT_FAILURE);
}

static int
strtot(const char *nptr, char **endptr, time_t *tp)
{
	long long ll;

	errno = 0;
	ll = strtoll(nptr, endptr, 10);
	if (*endptr == nptr)
		return (-1);
	if (ll < 0 || (errno == ERANGE && ll == LLONG_MAX) || (time_t)ll != ll)
		return (-1);
	*tp = (time_t)ll;
	return (0);
}

static int
newjob(time_t runtimer, int queue)
{
	int fd, i;

	/*
	 * If we have a collision, try shifting the time by up to
	 * two minutes.  Perhaps it would be better to try different
	 * queues instead...
	 */
	for (i = 0; i < 120; i++) {
		snprintf(atfile, sizeof(atfile), "%s/%lld.%c", _PATH_AT_SPOOL,
		    (long long)runtimer, queue);
		fd = open(atfile, O_WRONLY | O_CREAT | O_EXCL, S_IRUSR);
		if (fd >= 0)
			return (fd);
		runtimer++;
	}
	return (-1);
}

/*
 * This does most of the work if at or batch are invoked for
 * writing a job.
 */
static void
writefile(const char *cwd, time_t runtimer, char queue)
{
	const char *ap;
	char *mailname, *shell;
	char timestr[TIMESIZE];
	struct passwd *pass_entry;
	struct tm runtime;
	int fd;
	FILE *fp;
	struct sigaction act;
	char **atenv;
	int ch;
	mode_t cmask;
	extern char **environ;

	/*
	 * Install the signal handler for SIGINT; terminate after removing the
	 * spool file if necessary
	 */
	bzero(&act, sizeof act);
	act.sa_handler = sigc;
	sigemptyset(&act.sa_mask);
	act.sa_flags = 0;
	sigaction(SIGINT, &act, NULL);

	/*
	 * Create the file. The x bit is only going to be set after it has
	 * been completely written out, to make sure it is not executed in
	 * the meantime.  To make sure they do not get deleted, turn off
	 * their r bit.  Yes, this is a kluge.
	 */
	cmask = umask(S_IRUSR | S_IWUSR | S_IXUSR);
	if ((fd = newjob(runtimer, queue)) == -1)
		fatal("unable to create atjob file");

	if (fchown(fd, -1, user_gid) != 0)
		fatal("fchown");

	/*
	 * We've successfully created the file; let's set the flag so it
	 * gets removed in case of an interrupt or error.
	 */
	fcreated = 1;

	if ((fp = fdopen(fd, "w")) == NULL)
		fatal("unable to reopen atjob file");

	/*
	 * Get the userid to mail to, first by trying getlogin(), which asks
	 * the kernel, then from $LOGNAME or $USER, finally from getpwuid().
	 */
	mailname = getlogin();
	if (mailname == NULL && (mailname = getenv("LOGNAME")) == NULL)
		mailname = getenv("USER");

	if ((mailname == NULL) || (mailname[0] == '\0') ||
	    (strlen(mailname) > MAX_UNAME) || (getpwnam(mailname) == NULL)) {
		mailname = user_name;
	}

	/*
	 * Get the shell to run the job under.  First check $SHELL, falling
	 * back to the user's shell in the password database or, failing
	 * that, /bin/sh.
	 */
	if ((shell = getenv("SHELL")) == NULL || *shell == '\0') {
		pass_entry = getpwuid(user_uid);
		if (pass_entry != NULL && *pass_entry->pw_shell != '\0')
			shell = pass_entry->pw_shell;
		else
			shell = _PATH_BSHELL;
	}

	(void)fprintf(fp, "#!/bin/sh\n# atrun uid=%lu gid=%lu\n# mail %*s %d\n",
	    (unsigned long)user_uid, (unsigned long)user_gid,
	    MAX_UNAME, mailname, send_mail);

	/* Write out the umask at the time of invocation */
	(void)fprintf(fp, "umask %o\n", cmask);

	/*
	 * Write out the environment. Anything that may look like a special
	 * character to the shell is quoted, except for \n, which is done
	 * with a pair of "'s.  Don't export the no_export list (such as
	 * TERM or DISPLAY) because we don't want these.
	 */
	for (atenv = environ; *atenv != NULL; atenv++) {
		int export = 1;
		char *eqp;

		eqp = strchr(*atenv, '=');
		if (eqp == NULL)
			eqp = *atenv;
		else {
			int i;

			for (i = 0;i < sizeof(no_export) /
			    sizeof(no_export[0]); i++) {
				export = export
				    && (strncmp(*atenv, no_export[i],
					(size_t) (eqp - *atenv)) != 0);
			}
			eqp++;
		}

		if (export) {
			(void)fputs("export ", fp);
			(void)fwrite(*atenv, sizeof(char), eqp - *atenv, fp);
			for (ap = eqp; *ap != '\0'; ap++) {
				if (*ap == '\n')
					(void)fprintf(fp, "\"\n\"");
				else {
					if (!isalnum((unsigned char)*ap)) {
						switch (*ap) {
						case '%': case '/': case '{':
						case '[': case ']': case '=':
						case '}': case '@@': case '+':
						case '#': case ',': case '.':
						case ':': case '-': case '_':
							break;
						default:
							(void)fputc('\\', fp);
							break;
						}
					}
					(void)fputc(*ap, fp);
				}
			}
			(void)fputc('\n', fp);
		}
	}
	/*
	 * Cd to the directory at the time and write out all the
	 * commands the user supplies from stdin.
	 */
	(void)fputs("cd ", fp);
	for (ap = cwd; *ap != '\0'; ap++) {
		if (*ap == '\n')
			fprintf(fp, "\"\n\"");
		else {
			if (*ap != '/' && !isalnum((unsigned char)*ap))
				(void)fputc('\\', fp);

			(void)fputc(*ap, fp);
		}
	}
	/*
	 * Test cd's exit status: die if the original directory has been
	 * removed, become unreadable or whatever.
	 */
	(void)fprintf(fp, " || {\n\t echo 'Execution directory inaccessible'"
	    " >&2\n\t exit 1\n}\n");

	if ((ch = getchar()) == EOF)
		fatalx("unexpected EOF");

	/* We want the job to run under the user's shell. */
	fprintf(fp, "%s << '_END_OF_AT_JOB'\n", shell);

	do {
		(void)fputc(ch, fp);
	} while ((ch = getchar()) != EOF);

	(void)fprintf(fp, "\n_END_OF_AT_JOB\n");
	(void)fflush(fp);
	if (ferror(fp))
		fatalx("write error");

	if (ferror(stdin))
		fatalx("read error");

	/*
	 * Set the x bit so that we're ready to start executing
	 */
	if (fchmod(fileno(fp), S_IRUSR | S_IWUSR | S_IXUSR) < 0)
		fatal("fchmod");

	(void)fclose(fp);

	/* Poke cron so it knows to reload the at spool. */
	poke_daemon(RELOAD_AT);

	runtime = *localtime(&runtimer);
	strftime(timestr, TIMESIZE, "%a %b %e %T %Y", &runtime);
	(void)fprintf(stderr, "commands will be executed using %s\n", shell);
	(void)fprintf(stderr, "job %s at %s\n", &atfile[sizeof(_PATH_AT_SPOOL)],
	    timestr);

	syslog(LOG_INFO, "(%s) CREATE (%s)", user_name,
	    &atfile[sizeof(_PATH_AT_SPOOL)]);
}

/* Sort by creation time. */
static int
byctime(const void *v1, const void *v2)
{
	const struct atjob *j1 = *(const struct atjob **)v1;
	const struct atjob *j2 = *(const struct atjob **)v2;

	return (j1->ctime - j2->ctime);
}

/* Sort by job number (and thus execution time). */
static int
byjobno(const void *v1, const void *v2)
{
	const struct atjob *j1 = *(struct atjob **)v1;
	const struct atjob *j2 = *(struct atjob **)v2;

	if (j1->runtimer == j2->runtimer)
		return (j1->queue - j2->queue);
	return (j1->runtimer - j2->runtimer);
}

static void
print_job(struct atjob *job, int n, int shortformat)
{
	struct passwd *pw;
	struct tm runtime;
	char timestr[TIMESIZE];
	static char *ranks[] = {
		"th", "st", "nd", "rd", "th", "th", "th", "th", "th", "th"
	};

	runtime = *localtime(&job->runtimer);
	if (shortformat) {
		strftime(timestr, TIMESIZE, "%a %b %e %T %Y", &runtime);
		(void)printf("%lld.%c\t%s\n", (long long)job->runtimer,
		    job->queue, timestr);
	} else {
		pw = getpwuid(job->uid);
		/* Rank hack shamelessly stolen from lpq */
		if (n / 10 == 1)
			printf("%3d%-5s", n,"th");
		else
			printf("%3d%-5s", n, ranks[n % 10]);
		strftime(timestr, TIMESIZE, "%b %e, %Y %R", &runtime);
		(void)printf("%-21.18s%-11.8s%10lld.%c   %c%s\n",
		    timestr, pw ? pw->pw_name : "???",
		    (long long)job->runtimer, job->queue, job->queue,
		    (S_IXUSR & job->mode) ? "" : " (done)");
	}
}

/*
 * List all of a user's jobs in the queue, by looping through
 * _PATH_AT_SPOOL, or all jobs if we are root.  If argc is > 0, argv
 * contains the list of users whose jobs shall be displayed. By
 * default, the list is sorted by execution date and queue.  If
 * csort is non-zero jobs will be sorted by creation/submission date.
 */
static void
list_jobs(int argc, char **argv, int count_only, int csort)
{
	struct passwd *pw;
	struct dirent *dirent;
	struct atjob **atjobs, **newatjobs, *job;
	struct stat stbuf;
	time_t runtimer;
	char **jobs;
	uid_t *uids;
	char queue, *ep;
	DIR *spool;
	int job_matches, jobs_len, uids_len;
	int dfd, i, shortformat;
	size_t numjobs, maxjobs;

	syslog(LOG_INFO, "(%s) LIST (%s)", user_name,
	    user_uid ? user_name : "ALL");

	/* Convert argv into a list of jobs and uids. */
	jobs = NULL;
	uids = NULL;
	jobs_len = uids_len = 0;

	if (argc) {
		if ((jobs = reallocarray(NULL, argc, sizeof(char *))) == NULL ||
		    (uids = reallocarray(NULL, argc, sizeof(uid_t))) == NULL)
			fatal(NULL);

		for (i = 0; i < argc; i++) {
			if (strtot(argv[i], &ep, &runtimer) == 0 &&
			    *ep == '.' && isalpha((unsigned char)*(ep + 1)) &&
			    *(ep + 2) == '\0')
				jobs[jobs_len++] = argv[i];
			else if ((pw = getpwnam(argv[i])) != NULL) {
				if (pw->pw_uid != user_uid && user_uid != 0)
					fatalx("only the superuser may "
					    "display other users' jobs");
				uids[uids_len++] = pw->pw_uid;
			} else
				fatalx("unknown user %s", argv[i]);
		}
	}

	shortformat = strcmp(__progname, "at") == 0;

	if ((dfd = open(_PATH_AT_SPOOL, O_RDONLY|O_DIRECTORY)) == -1 ||
	    (spool = fdopendir(dfd)) == NULL)
		fatal(_PATH_AT_SPOOL);

	if (fstat(dfd, &stbuf) != 0)
		fatal(_PATH_AT_SPOOL);

	/*
	 * The directory's link count should give us a good idea
	 * of how many files are in it.  Fudge things a little just
	 * in case someone adds a job or two.
	 */
	numjobs = 0;
	maxjobs = stbuf.st_nlink + 4;
	atjobs = reallocarray(NULL, maxjobs, sizeof(struct atjob *));
	if (atjobs == NULL)
		fatal(NULL);

	/* Loop over every file in the directory. */
	while ((dirent = readdir(spool)) != NULL) {
		if (fstatat(dfd, dirent->d_name, &stbuf, AT_SYMLINK_NOFOLLOW) != 0)
			fatal("%s", dirent->d_name);

		/*
		 * See it's a regular file and has its x bit turned on and
		 * is the user's
		 */
		if (!S_ISREG(stbuf.st_mode)
		    || ((stbuf.st_uid != user_uid) && !(user_uid == 0))
		    || !(S_IXUSR & stbuf.st_mode || vflag))
			continue;

		if (strtot(dirent->d_name, &ep, &runtimer) == -1)
			continue;
		if (*ep != '.' || !isalpha((unsigned char)*(ep + 1)) ||
		    *(ep + 2) != '\0')
			continue;
		queue = *(ep + 1);

		if (atqueue && (queue != atqueue))
			continue;

		/* Check against specified jobs and/or user(s). */
		job_matches = (argc == 0) ? 1 : 0;
		if (!job_matches) {
			for (i = 0; i < jobs_len; i++) {
				if (strcmp(dirent->d_name, jobs[i]) == 0) {
					job_matches = 1;
					break;
				}
			}
		}
		if (!job_matches) {
			for (i = 0; i < uids_len; i++) {
				if (uids[i] == stbuf.st_uid) {
					job_matches = 1;
					break;
				}
			}
		}
		if (!job_matches)
			continue;

		if (count_only) {
			numjobs++;
			continue;
		}

		job = malloc(sizeof(struct atjob));
		if (job == NULL)
			fatal(NULL);
		job->runtimer = runtimer;
		job->ctime = stbuf.st_ctime;
		job->uid = stbuf.st_uid;
		job->mode = stbuf.st_mode;
		job->queue = queue;
		if (numjobs == maxjobs) {
			size_t newjobs = maxjobs * 2;
			newatjobs = recallocarray(atjobs, maxjobs,
			    newjobs, sizeof(job));
			if (newatjobs == NULL)
				fatal(NULL);
			atjobs = newatjobs;
			maxjobs = newjobs;
		}
		atjobs[numjobs++] = job;
	}
	free(uids);
	closedir(spool);

	if (count_only || numjobs == 0) {
		if (numjobs == 0 && !shortformat)
			warnx("no files in queue");
		else if (count_only)
			printf("%zu\n", numjobs);
		free(atjobs);
		return;
	}

	/* Sort by job run time or by job creation time. */
	qsort(atjobs, numjobs, sizeof(struct atjob *),
	    csort ? byctime : byjobno);

	if (!shortformat)
		(void)puts(" Rank     Execution Date     Owner          "
		    "Job       Queue");

	for (i = 0; i < numjobs; i++) {
		print_job(atjobs[i], i + 1, shortformat);
		free(atjobs[i]);
	}
	free(atjobs);
}

static int
rmok(long long job)
{
	int ch, junk;

	printf("%lld: remove it? ", job);
	ch = getchar();
	while ((junk = getchar()) != EOF && junk != '\n')
		;
	return (ch == 'y' || ch == 'Y');
}

/*
 * Loop through all jobs in _PATH_AT_SPOOL and display or delete ones
 * that match argv (may be job or username), or all if argc == 0.
 * Only the superuser may display/delete other people's jobs.
 */
static int
process_jobs(int argc, char **argv, int what)
{
	struct stat stbuf;
	struct dirent *dirent;
	struct passwd *pw;
	time_t runtimer;
	uid_t *uids;
	char **jobs, *ep;
	FILE *fp;
	DIR *spool;
	int job_matches, jobs_len, uids_len;
	int error, i, ch, changed, dfd;

	if ((dfd = open(_PATH_AT_SPOOL, O_RDONLY|O_DIRECTORY)) == -1 ||
	    (spool = fdopendir(dfd)) == NULL)
		fatal(_PATH_AT_SPOOL);

	/* Convert argv into a list of jobs and uids. */
	jobs = NULL;
	uids = NULL;
	jobs_len = uids_len = 0;
	if (argc > 0) {
		if ((jobs = reallocarray(NULL, argc, sizeof(char *))) == NULL ||
		    (uids = reallocarray(NULL, argc, sizeof(uid_t))) == NULL)
			fatal(NULL);

		for (i = 0; i < argc; i++) {
			if (strtot(argv[i], &ep, &runtimer) == 0 &&
			    *ep == '.' && isalpha((unsigned char)*(ep + 1)) &&
			    *(ep + 2) == '\0')
				jobs[jobs_len++] = argv[i];
			else if ((pw = getpwnam(argv[i])) != NULL) {
				if (user_uid != pw->pw_uid && user_uid != 0) {
					fatalx("only the superuser may %s "
					    "other users' jobs",
					    what == ATRM ? "remove" : "view");
				}
				uids[uids_len++] = pw->pw_uid;
			} else
				fatalx("unknown user %s", argv[i]);
		}
	}

	/* Loop over every file in the directory */
	changed = 0;
	while ((dirent = readdir(spool)) != NULL) {
		if (fstatat(dfd, dirent->d_name, &stbuf, AT_SYMLINK_NOFOLLOW) != 0)
			fatal("%s", dirent->d_name);

		if (stbuf.st_uid != user_uid && user_uid != 0)
			continue;

		if (strtot(dirent->d_name, &ep, &runtimer) == -1)
			continue;
		if (*ep != '.' || !isalpha((unsigned char)*(ep + 1)) ||
		    *(ep + 2) != '\0')
			continue;

		/* Check runtimer against argv; argc==0 means do all. */
		job_matches = (argc == 0) ? 1 : 0;
		if (!job_matches) {
			for (i = 0; i < jobs_len; i++) {
				if (jobs[i] != NULL &&
				    strcmp(dirent->d_name, jobs[i]) == 0) {
					jobs[i] = NULL;
					job_matches = 1;
					break;
				}
			}
		}
		if (!job_matches) {
			for (i = 0; i < uids_len; i++) {
				if (uids[i] == stbuf.st_uid) {
					job_matches = 1;
					break;
				}
			}
		}

		if (job_matches) {
			switch (what) {
			case ATRM:
				if (!interactive ||
				    (interactive && rmok(runtimer))) {
					if (unlinkat(dfd, dirent->d_name, 0) == 0) {
						syslog(LOG_INFO,
						    "(%s) DELETE (%s)",
						    user_name, dirent->d_name);
						changed = 1;
					} else if (!force)
						fatal("%s", dirent->d_name);
					if (!force && !interactive)
						warnx("%s removed",
						    dirent->d_name);
				}
				break;

			case CAT:
				i = openat(dfd, dirent->d_name,
				    O_RDONLY|O_NOFOLLOW);
				if (i == -1 || (fp = fdopen(i, "r")) == NULL)
					fatal("%s", dirent->d_name);
				syslog(LOG_INFO, "(%s) CAT (%s)",
				    user_name, dirent->d_name);

				while ((ch = getc(fp)) != EOF)
					putchar(ch);

				fclose(fp);
				break;

			default:
				fatalx("internal error");
				break;
			}
		}
	}
	closedir(spool);

	for (error = 0, i = 0; i < jobs_len; i++) {
		if (jobs[i] != NULL) {
			if (!force)
				warnx("%s: no such job", jobs[i]);
			error++;
		}
	}
	free(jobs);
	free(uids);

	/* If we modied the spool, poke cron so it knows to reload. */
	if (changed)
		poke_daemon(RELOAD_AT);

	return (error);
}

#define	ATOI2(s)	((s) += 2, ((s)[-2] - '0') * 10 + ((s)[-1] - '0'))

/*
 * Adapted from date(1)
 */
static time_t
ttime(char *arg)
{
	time_t now, then;
	struct tm *lt;
	int yearset;
	char *dot, *p;

	if (time(&now) == (time_t)-1 || (lt = localtime(&now)) == NULL)
		fatal("unable to get current time");

	/* Valid date format is [[CC]YY]MMDDhhmm[.SS] */
	for (p = arg, dot = NULL; *p != '\0'; p++) {
		if (*p == '.' && dot == NULL)
			dot = p;
		else if (!isdigit((unsigned char)*p))
			goto terr;
	}
	if (dot == NULL)
		lt->tm_sec = 0;
	else {
		*dot++ = '\0';
		if (strlen(dot) != 2)
			goto terr;
		lt->tm_sec = ATOI2(dot);
		if (lt->tm_sec > 61)	/* could be leap second */
			goto terr;
	}

	yearset = 0;
	switch(strlen(arg)) {
	case 12:			/* CCYYMMDDhhmm */
		lt->tm_year = ATOI2(arg) * 100;
		lt->tm_year -= 1900;	/* Convert to Unix time */
		yearset = 1;
		/* FALLTHROUGH */
	case 10:			/* YYMMDDhhmm */
		if (yearset) {
			yearset = ATOI2(arg);
			lt->tm_year += yearset;
		} else {
			yearset = ATOI2(arg);
			/* POSIX logic: [00,68]=>20xx, [69,99]=>19xx */
			lt->tm_year = yearset;
			if (yearset < 69)
				lt->tm_year += 100;
		}
		/* FALLTHROUGH */
	case 8:				/* MMDDhhmm */
		lt->tm_mon = ATOI2(arg);
		if (lt->tm_mon > 12 || lt->tm_mon == 0)
			goto terr;
		--lt->tm_mon;		/* Convert from 01-12 to 00-11 */
		lt->tm_mday = ATOI2(arg);
		if (lt->tm_mday > 31 || lt->tm_mday == 0)
			goto terr;
		lt->tm_hour = ATOI2(arg);
		if (lt->tm_hour > 23)
			goto terr;
		lt->tm_min = ATOI2(arg);
		if (lt->tm_min > 59)
			goto terr;
		break;
	default:
		goto terr;
	}

	lt->tm_isdst = -1;		/* mktime will deduce DST. */
	then = mktime(lt);
	if (then == (time_t)-1) {
    terr:
		fatalx("illegal time specification: [[CC]YY]MMDDhhmm[.SS]");
	}
	if (then < now)
		fatalx("cannot schedule jobs in the past");
	return (then);
}

static __dead void
usage(void)
{
	/* Print usage and exit.  */
	switch (program) {
	case AT:
	case CAT:
		(void)fprintf(stderr,
		    "usage: at [-bm] [-f file] [-l [job ...]] [-q queue] "
		    "-t time_arg | timespec\n"
		    "       at -c | -r job ...\n");
		break;
	case ATQ:
		(void)fprintf(stderr,
		    "usage: atq [-cnv] [-q queue] [name ...]\n");
		break;
	case ATRM:
		(void)fprintf(stderr,
		    "usage: atrm [-afi] [[job] [name] ...]\n");
		break;
	case BATCH:
		(void)fprintf(stderr,
		    "usage: batch [-m] [-f file] [-q queue] [timespec]\n");
		break;
	}
	exit(EXIT_FAILURE);
}

int
main(int argc, char **argv)
{
	time_t timer = -1;
	char *atinput = NULL;			/* where to get input from */
	char queue = DEFAULT_AT_QUEUE;
	char queue_set = 0;
	char *options = "q:f:t:bcdlmrv";	/* default options for at */
	char cwd[PATH_MAX];
	struct passwd *pw;
	int ch;
	int aflag = 0;
	int cflag = 0;
	int nflag = 0;

	if (pledge("stdio rpath wpath cpath fattr getpw unix id", NULL) == -1)
		fatal("pledge");

	openlog(__progname, LOG_PID, LOG_CRON);

	if (argc < 1)
		usage();

	user_uid = getuid();
	user_gid = getgid();
	spool_gid = getegid();

	/* find out what this program is supposed to do */
	if (strcmp(__progname, "atq") == 0) {
		program = ATQ;
		options = "cnvq:";
	} else if (strcmp(__progname, "atrm") == 0) {
		program = ATRM;
		options = "afi";
	} else if (strcmp(__progname, "batch") == 0) {
		program = BATCH;
		options = "f:q:mv";
	}

	/* process whatever options we can process */
	while ((ch = getopt(argc, argv, options)) != -1) {
		switch (ch) {
		case 'a':
			aflag = 1;
			break;

		case 'i':
			interactive = 1;
			force = 0;
			break;

		case 'v':	/* show completed but unremoved jobs */
			/*
			 * This option is only useful when we are invoked
			 * as atq but we accept (and ignore) this flag in
			 * the other programs for backwards compatibility.
			 */
			vflag = 1;
			break;

		case 'm':	/* send mail when job is complete */
			send_mail = 1;
			break;

		case 'f':
			if (program == ATRM) {
				force = 1;
				interactive = 0;
			} else
				atinput = optarg;
			break;

		case 'q':	/* specify queue */
			if (strlen(optarg) > 1)
				usage();

			atqueue = queue = *optarg;
			if (!(islower((unsigned char)queue) ||
			    isupper((unsigned char)queue)))
				usage();

			queue_set = 1;
			break;

		case 'd':		/* for backwards compatibility */
		case 'r':
			program = ATRM;
			options = "";
			break;

		case 't':
			timer = ttime(optarg);
			break;

		case 'l':
			program = ATQ;
			options = "cnvq:";
			break;

		case 'b':
			program = BATCH;
			options = "f:q:mv";
			break;

		case 'c':
			if (program == ATQ) {
				cflag = 1;
			} else {
				program = CAT;
				options = "";
			}
			break;

		case 'n':
			nflag = 1;
			break;

		default:
			usage();
			break;
		}
	}
	argc -= optind;
	argv += optind;

	switch (program) {
	case AT:
	case BATCH:
		if (atinput != NULL) {
			if (setegid(user_gid) != 0)
				fatal("setegid(user_gid)");
			if (freopen(atinput, "r", stdin) == NULL)
				fatal("%s", atinput);
			if (setegid(spool_gid) != 0)
				fatal("setegid(spool_gid)");
		}
		break;
	default:
		;
	}

	if ((pw = getpwuid(user_uid)) == NULL)
	    fatalx("unknown uid %u", user_uid);
	if (strlcpy(user_name, pw->pw_name, sizeof(user_name)) >= sizeof(user_name))
	    fatalx("username too long");

	if (getcwd(cwd, sizeof(cwd)) == NULL)
		fatal("unable to get current working directory");

	if (!allowed(pw->pw_name, _PATH_AT_ALLOW, _PATH_AT_DENY)) {
		syslog(LOG_WARNING, "(%s) AUTH (at command not allowed)",
		    pw->pw_name);
		fatalx("you do not have permission to use at.");
	}

	/* select our program */
	switch (program) {
	case ATQ:
		list_jobs(argc, argv, nflag, cflag);
		break;

	case ATRM:
	case CAT:
		if ((aflag && argc) || (!aflag && !argc))
			usage();
		return process_jobs(argc, argv, program);
		break;

	case AT:
		/* Time may have been specified via the -t flag. */
		if (timer == -1) {
			if (argc == 0)
				usage();
			else if ((timer = parsetime(argc, argv)) == -1)
				return EXIT_FAILURE;
		}
		writefile(cwd, timer, queue);
		break;

	case BATCH:
		if (queue_set)
			queue = toupper((unsigned char)queue);
		else
			queue = DEFAULT_BATCH_QUEUE;

		if (argc == 0)
			timer = time(NULL);
		else if ((timer = parsetime(argc, argv)) == -1)
			return EXIT_FAILURE;

		writefile(cwd, timer, queue);
		break;

	default:
		fatalx("internal error");
		break;
	}
	return EXIT_SUCCESS;
}
@


1.78
log
@Delete setlocale(LC_TIME, "").
The only place where this could potentially get used was the
strftime(3) for fprintf(3) "job %s at %s\n" to stderr.  We don't
want base system utilities to talk to users in foreign languages.
No functional change on OpenBSD which doesn't provide any non-standard
LC_TIME locale anyway.
Patch from Jan Stary <hans at stare dot cz>.
In main(), exit -> return while here.
OK millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: at.c,v 1.77 2015/11/16 16:43:06 millert Exp $	*/
d560 2
a561 1
			newatjobs = reallocarray(atjobs, newjobs, sizeof(job));
@


1.77
log
@Make "at -l" comply with POSIX.  Our "at -l" currently acts like
the historic BSD atq which takes a list of users instead of a list
of jobs.  We now accept either a user or a job number for "at -l".
The "at -l user" syntax is still accepted but no longer documented.
This is similar to how we handle differences in "at -r" vs. atrm.
OK deraadt@@ jmc@@
@
text
@d1 1
a1 1
/*	$OpenBSD: at.c,v 1.76 2015/11/13 21:35:34 millert Exp $	*/
a43 1
#include <locale.h>
a199 2
	(void)setlocale(LC_TIME, "");

d1025 1
a1025 1
		exit(process_jobs(argc, argv, program));
d1034 1
a1034 1
				exit(EXIT_FAILURE);
d1048 1
a1048 1
			exit(EXIT_FAILURE);
d1057 1
a1057 1
	exit(EXIT_SUCCESS);
@


1.76
log
@Use crontab-style syslog calls in at.
Remove check_permission and just call allowed() directly.
@
text
@d1 1
a1 1
/*	$OpenBSD: at.c,v 1.74 2015/11/12 21:12:05 millert Exp $	*/
d447 1
d451 1
d458 5
d464 2
a465 1
		if ((uids = calloc(sizeof(uid_t), argc)) == NULL)
d469 10
a478 1
			if ((pw = getpwnam(argv[i])) == NULL)
a479 3
			if (pw->pw_uid != user_uid && user_uid != 0)
				fatalx("only the superuser may display other users' jobs");
			uids[i] = pw->pw_uid;
d481 1
a481 2
	} else
		uids = NULL;
d499 1
a499 1
	atjobs = calloc(maxjobs, sizeof(struct atjob *));
d527 14
a540 4
		/* Check against specified user(s). */
		if (argc) {
			for (i = 0; i < argc; i++) {
				if (uids[0] == stbuf.st_uid)
d542 1
a543 2
			if (i == argc)
				continue;	/* user doesn't match */
d545 2
a623 1
	long l;
d638 2
a639 2
		if ((jobs = calloc(sizeof(char *), argc)) == NULL ||
		    (uids = calloc(sizeof(uid_t), argc)) == NULL)
d643 3
a645 3
			l = strtol(argv[i], &ep, 10);
			if (*ep == '.' && isalpha((unsigned char)*(ep + 1)) &&
			    *(ep + 2) == '\0' && l > 0 && l < INT_MAX)
d843 1
a843 1
		    "usage: at [-bm] [-f file] [-l [user ...]] [-q queue] "
@


1.75
log
@There's no need for at.c globals to be extern.
@
text
@d51 1
d75 1
a89 1
static int check_permission(void);
d245 1
a245 3
		pass_entry = getpwuid(user_uid);
		if (pass_entry != NULL)
			mailname = pass_entry->pw_name;
d375 3
d453 3
d677 4
a680 1
					if (unlinkat(dfd, dirent->d_name, 0) == 0)
d682 1
a682 1
					else if (!force)
d695 2
a811 11
static int
check_permission(void)
{
	struct passwd *pw;

	if ((pw = getpwuid(user_uid)) == NULL)
		fatalx("unknown uid %u", user_uid);

	return (allowed(pw->pw_name, _PATH_AT_ALLOW, _PATH_AT_DENY));
}

d849 1
d858 2
d981 5
d989 3
a991 1
	if (!check_permission())
d993 1
@


1.74
log
@Use absolute paths in pathnames.h.  There is no longer a need to
chdir(2) to the cron dir and cron(8) now changes to / via daemon(3).
We no longer try to create/chmod the spool directories as they
should be set correctly at install time.  The setegid(crontab)
has been moved to open_socket() so it is closer to the chmod(2)
call that needs it.  OK deraadt@@ tedu@@
@
text
@d1 1
a1 1
/*	$OpenBSD: at.c,v 1.73 2015/11/11 21:53:51 millert Exp $	*/
d72 7
a78 7
int program = AT;		/* default program mode */
char atfile[PATH_MAX];		/* path to the at spool file */
int fcreated;			/* whether or not we created the file yet */
char atqueue = 0;		/* which queue to examine for jobs (atq) */
char vflag = 0;			/* show completed but unremoved jobs (atq) */
char force = 0;			/* suppress errors (atrm) */
char interactive = 0;		/* interactive mode (atrm) */
d80 3
a82 3
uid_t user_uid;			/* user's real uid */
gid_t user_gid;			/* user's real gid */
gid_t spool_gid;		/* gid for writing to at spool */
@


1.73
log
@at already uses O_EXCL when creating files so there's no need to
lock the spool dir.  OK jca@@
@
text
@d1 1
a1 1
/*	$OpenBSD: at.c,v 1.72 2015/11/11 17:17:56 millert Exp $	*/
d73 1
a73 1
char atfile[MAX_FNAME];		/* path to the at spool file */
d145 15
d170 1
a170 1
		snprintf(atfile, sizeof(atfile), "%s/%lld.%c", AT_SPOOL,
d369 1
a369 1
	poke_daemon(AT_SPOOL, RELOAD_AT);
d374 1
a374 1
	(void)fprintf(stderr, "job %s at %s\n", &atfile[sizeof(AT_SPOOL)],
d432 1
a432 1
 * AT_SPOOL, or all jobs if we are root.  If argc is > 0, argv
d467 1
a467 1
	if ((dfd = open(AT_SPOOL, O_RDONLY|O_DIRECTORY)) == -1 ||
d469 1
a469 1
		fatal(AT_SPOOL);
d472 1
a472 1
		fatal(AT_SPOOL);
d582 1
a582 1
 * Loop through all jobs in AT_SPOOL and display or delete ones
d601 1
a601 1
	if ((dfd = open(AT_SPOOL, O_RDONLY|O_DIRECTORY)) == -1 ||
d603 1
a603 1
		fatal(AT_SPOOL);
d714 1
a714 1
		poke_daemon(AT_SPOOL, RELOAD_AT);
d810 1
a810 1
	return (allowed(pw->pw_name, AT_ALLOW, AT_DENY));
a980 2

	set_cron_cwd();
@


1.72
log
@Use warn/warnx where sensible and add fatal/fatalx wrappers for
err/errx that unlink atfile as needed.  OK deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: at.c,v 1.71 2015/11/11 15:23:06 millert Exp $	*/
a84 1
static void alarmc(int);
a143 7
/* ARGSUSED */
static void
alarmc(int signo)
{
	/* just return */
}

d177 1
a177 1
	int fdes, lockdes, fd2;
a196 22
	if ((lockdes = open(AT_SPOOL, O_RDONLY|O_DIRECTORY, 0)) < 0)
		fatal(AT_SPOOL);

	/*
	 * Lock the jobs dir so we don't have to worry about someone
	 * else grabbing a file name out from under us.
	 * Set an alarm so we don't sleep forever waiting on the lock.
	 * If we don't succeed with ALARMC seconds, something is wrong...
	 */
	bzero(&act, sizeof act);
	act.sa_handler = alarmc;
	sigemptyset(&act.sa_mask);
#ifdef SA_INTERRUPT
	act.sa_flags = SA_INTERRUPT;
#endif
	sigaction(SIGALRM, &act, NULL);
	alarm(ALARMC);
	ch = flock(lockdes, LOCK_EX);
	alarm(0);
	if (ch != 0)
		fatal("unable to lock %s", AT_SPOOL);

d204 1
a204 1
	if ((fdes = newjob(runtimer, queue)) == -1)
d207 1
a207 4
	if ((fd2 = dup(fdes)) < 0)
		fatal("dup");

	if (fchown(fd2, -1, user_gid) != 0)
d216 1
a216 4
	/* Now we can release the lock, so other people can access it */
	(void)close(lockdes);

	if ((fp = fdopen(fdes, "w")) == NULL)
a344 2
	(void)fclose(fp);

d348 1
a348 1
	if (fchmod(fd2, S_IRUSR | S_IWUSR | S_IXUSR) < 0)
d351 1
a351 1
	(void)close(fd2);
d840 1
a840 2
	if (pledge("stdio rpath wpath cpath fattr getpw unix flock id",
	    NULL) == -1)
@


1.71
log
@Use fstatat(), openat() and unlinkat() when operating on files in
the at queue so we don't need to chdir to the queue dir.  OK guenther@@
@
text
@d1 1
a1 1
/*	$OpenBSD: at.c,v 1.70 2015/11/09 15:57:39 millert Exp $	*/
d40 1
d47 1
d90 4
a93 3
static __dead void panic(const char *);
static void perr(const char *);
static void perr2(const char *, const char *);
d102 1
a102 1
panic(const char *a)
d104 6
a109 1
	(void)fprintf(stderr, "%s: %s\n", __progname, a);
d117 1
a117 1
 * Two-parameter version of panic().
d120 1
a120 1
panic2(const char *a, const char *b)
d122 1
a122 3
	(void)fprintf(stderr, "%s: %s%s\n", __progname, a, b);
	if (fcreated)
		unlink(atfile);
d124 3
a126 2
	exit(EXIT_FAILURE);
}
a127 8
/*
 * Some operating system error; print error message and exit.
 */
static __dead void
perr(const char *a)
{
	if (!force)
		perror(a);
a133 11
/*
 * Two-parameter version of perr().
 */
static __dead void
perr2(const char *a, const char *b)
{
	if (!force)
		(void)fputs(a, stderr);
	perr(b);
}

d206 1
a206 1
		perr2("Cannot open ", AT_SPOOL);
d225 1
a225 1
		panic("Unable to lock jobs dir");
d235 1
a235 1
		perr("Cannot create atjob file");
d238 1
a238 1
		perr("Error in dup() of job file");
d240 2
a241 2
	if (fchown(fd2, user_uid, user_gid) != 0)
		perr("Cannot give away file");
d253 1
a253 1
		panic("Cannot reopen atjob file");
d364 1
a364 1
		panic("Input error");
d374 1
d376 1
a376 1
		panic("Output error");
d379 1
a379 1
		panic("Input error");
d387 1
a387 1
		perr("Cannot give away file");
d476 1
a476 1
			panic("Insufficient virtual memory");
d480 1
a480 1
				panic2(argv[i], ": invalid user name");
d482 1
a482 1
				panic("Only the superuser may display other users' jobs");
d492 1
a492 1
		perr2("Cannot open ", AT_SPOOL);
d495 1
a495 1
		perr2("Cannot stat ", AT_SPOOL);
d506 1
a506 1
		panic("Insufficient virtual memory");
d511 1
a511 1
			perr2("Cannot stat ", dirent->d_name);
d549 1
a549 1
			panic("Insufficient virtual memory");
d559 1
a559 1
				panic("Insufficient virtual memory");
d570 1
a570 1
			fprintf(stderr, "no files in queue.\n");
d626 1
a626 1
		perr2("Cannot open ", AT_SPOOL);
d635 1
a635 1
			panic("Insufficient virtual memory");
d644 3
a646 5
					fprintf(stderr, "%s: Only the superuser"
					    " may %s other users' jobs\n",
					    __progname, what == ATRM
					    ? "remove" : "view");
					exit(EXIT_FAILURE);
d650 1
a650 1
				panic2(argv[i], ": invalid user name");
d658 1
a658 1
			perr2("Cannot stat ", dirent->d_name);
d697 2
a698 2
					else
						perr(dirent->d_name);
d700 1
a700 2
						fprintf(stderr,
						    "%s removed\n",
d709 1
a709 1
					perr2("Cannot open ", dirent->d_name);
d718 1
a718 1
				panic("Internal error");
d728 1
a728 2
				fprintf(stderr, "%s: %s: no such job\n",
				    __progname, jobs[i]);
d756 1
a756 1
		panic("Cannot get current time");
d818 1
a818 1
		panic("illegal time specification: [[CC]YY]MMDDhhmm[.SS]");
d821 1
a821 1
		panic("cannot schedule jobs in the past");
d830 2
a831 4
	if ((pw = getpwuid(user_uid)) == NULL) {
		perror("Cannot access password database");
		exit(EXIT_FAILURE);
	}
d880 1
a880 1
		perr("pledge");
d992 1
a992 1
				perr("setegid(user_gid)");
d994 1
a994 1
				perr("Cannot open input file");
d996 1
a996 1
				perr("setegid(spool_gid)");
d1004 1
a1004 1
		perr("Cannot get current working directory");
d1009 1
a1009 1
		panic("You do not have permission to use at.");
d1050 1
a1050 1
		panic("Internal error");
@


1.70
log
@Rename AT_DIR -> AT_SPOOL and SPOOL_DIR -> CRON_SPOOL to improve
readability.
@
text
@d1 1
a1 1
/*	$OpenBSD: at.c,v 1.69 2015/11/06 23:47:42 millert Exp $	*/
d217 2
a218 2
	if ((lockdes = open(AT_SPOOL, O_RDONLY, 0)) < 0)
		perr("Cannot open jobs dir");
d482 1
a482 1
	int i, shortformat;
d501 2
a502 4
	if (chdir(AT_SPOOL) != 0)
		perr2("Cannot change to ", AT_SPOOL);

	if ((spool = opendir(".")) == NULL)
d505 1
a505 1
	if (fstat(dirfd(spool), &stbuf) != 0)
d521 2
a522 2
		if (stat(dirent->d_name, &stbuf) != 0)
			perr2("Cannot stat in ", AT_SPOOL);
d633 1
a633 4
	int error, i, ch, changed;

	if (chdir(AT_SPOOL) != 0)
		perr2("Cannot change to ", AT_SPOOL);
d635 2
a636 1
	if ((spool = opendir(".")) == NULL)
d670 2
a671 2
		if (stat(dirent->d_name, &stbuf) != 0)
			perr2("Cannot stat in ", AT_SPOOL);
d708 1
a708 1
					if (unlink(dirent->d_name) == 0)
d720 4
a723 3
				fp = fopen(dirent->d_name, "r");
				if (!fp)
					perr("Cannot open file");
d751 2
a752 6
	if (changed) {
		if (chdir(CRONDIR) != 0)
			perror(CRONDIR);
		else
			poke_daemon(AT_SPOOL, RELOAD_AT);
	}
@


1.69
log
@Use __progname instead of the homegrown ProgramName.
@
text
@d1 1
a1 1
/*	$OpenBSD: at.c,v 1.68 2015/11/04 20:28:17 millert Exp $	*/
d175 1
a175 1
		snprintf(atfile, sizeof(atfile), "%s/%lld.%c", AT_DIR,
d217 1
a217 1
	if ((lockdes = open(AT_DIR, O_RDONLY, 0)) < 0)
d403 1
a403 1
	poke_daemon(AT_DIR, RELOAD_AT);
d408 1
a408 1
	(void)fprintf(stderr, "job %s at %s\n", &atfile[sizeof(AT_DIR)],
d466 1
a466 1
 * AT_DIR, or all jobs if we are root.  If argc is > 0, argv
d501 2
a502 2
	if (chdir(AT_DIR) != 0)
		perr2("Cannot change to ", AT_DIR);
d505 1
a505 1
		perr2("Cannot open ", AT_DIR);
d508 1
a508 1
		perr2("Cannot stat ", AT_DIR);
d524 1
a524 1
			perr2("Cannot stat in ", AT_DIR);
d618 1
a618 1
 * Loop through all jobs in AT_DIR and display or delete ones
d637 2
a638 2
	if (chdir(AT_DIR) != 0)
		perr2("Cannot change to ", AT_DIR);
d641 1
a641 1
		perr2("Cannot open ", AT_DIR);
d675 1
a675 1
			perr2("Cannot stat in ", AT_DIR);
d758 1
a758 1
			poke_daemon(AT_DIR, RELOAD_AT);
@


1.68
log
@Change cron from including all headers in every file to only including
what each .c file needs.  I have not removed cron.h since it will
be used in a future clean up of the cron's .h files.  OK nicm@@
@
text
@d1 1
a1 1
/*	$OpenBSD: at.c,v 1.67 2015/11/03 16:28:43 millert Exp $	*/
a33 2
#define	MAIN_PROGRAM

d101 1
a101 1
	(void)fprintf(stderr, "%s: %s\n", ProgramName, a);
d114 1
a114 1
	(void)fprintf(stderr, "%s: %s%s\n", ProgramName, a, b);
d499 1
a499 1
	shortformat = strcmp(ProgramName, "at") == 0;
d661 1
a661 1
					    ProgramName, what == ATRM
d746 1
a746 1
				    ProgramName, jobs[i]);
a908 5
	if ((ProgramName = strrchr(argv[0], '/')) != NULL)
		ProgramName++;
	else
		ProgramName = argv[0];

d914 1
a914 1
	if (strcmp(ProgramName, "atq") == 0) {
d917 1
a917 1
	} else if (strcmp(ProgramName, "atrm") == 0) {
d920 1
a920 1
	} else if (strcmp(ProgramName, "batch") == 0) {
@


1.67
log
@It is only necessary to swap the effective gid when reading a file.
An attacker exploiting an overflow can change the egid themselves
so running with the egid of the user in other places just gives you
a false sense of security.  OK nicm@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: at.c,v 1.66 2015/10/28 20:17:31 deraadt Exp $	*/
d36 24
a59 1
#include "cron.h"
a60 1
#include <limits.h>
@


1.66
log
@pledge
ok millert
@
text
@d1 1
a1 1
/*	$OpenBSD: at.c,v 1.65 2015/08/20 22:32:41 deraadt Exp $	*/
a37 1
#include "privs.h"
d58 3
d82 1
a82 2
	if (fcreated) {
		PRIV_START;
a83 2
		PRIV_END;
	}
d95 1
a95 2
	if (fcreated) {
		PRIV_START;
a96 2
		PRIV_END;
	}
d109 1
a109 2
	if (fcreated) {
		PRIV_START;
a110 2
		PRIV_END;
	}
d131 1
a131 2
	if (fcreated) {
		PRIV_START;
a132 2
		PRIV_END;
	}
a196 2
	PRIV_START;

d232 1
a232 1
	if (fchown(fd2, real_uid, real_gid) != 0)
a234 2
	PRIV_END;

d257 1
a257 1
		pass_entry = getpwuid(real_uid);
d268 1
a268 1
		pass_entry = getpwuid(real_uid);
d276 1
a276 1
	    (unsigned long)real_uid, (unsigned long)real_gid,
a382 1
	PRIV_START;
a383 1
	PRIV_END;
d472 1
a472 1
			if (pw->pw_uid != real_uid && real_uid != 0)
a480 2
	PRIV_START;

a486 2
	PRIV_END;

a502 2
		PRIV_START;

a505 2
		PRIV_END;

d511 1
a511 1
		    || ((stbuf.st_uid != real_uid) && !(real_uid == 0))
a616 2
	PRIV_START;

a622 2
	PRIV_END;

d638 1
a638 1
				if (real_uid != pw->pw_uid && real_uid != 0) {
a653 2

		PRIV_START;
a655 1
		PRIV_END;
d657 1
a657 1
		if (stbuf.st_uid != real_uid && real_uid != 0)
a689 2
				PRIV_START;

a700 3

				PRIV_END;

a703 2
				PRIV_START;

a704 3

				PRIV_END;

a734 1
		PRIV_START;
a738 1
		PRIV_END;
a829 2
	int ok;
	uid_t uid = geteuid();
d832 1
a832 1
	if ((pw = getpwuid(uid)) == NULL) {
d837 1
a837 7
	PRIV_START;

	ok = allowed(pw->pw_name, AT_ALLOW, AT_DENY);

	PRIV_END;

	return (ok);
d894 3
a896 1
	RELINQUISH_PRIVS;
d1000 2
d1004 2
@


1.65
log
@Do not cast result of malloc/calloc/realloc* if stdlib.h is in scope
ok krw millert
@
text
@d1 1
a1 1
/*	$OpenBSD: at.c,v 1.64 2014/10/08 03:56:52 doug Exp $	*/
d932 4
@


1.64
log
@userland reallocarray audit.

Replace malloc() and realloc() calls that may have integer overflow in the
multiplication of the arguments with reallocarray().

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: at.c,v 1.63 2014/09/29 18:44:49 millert Exp $	*/
d517 1
a517 1
	atjobs = (struct atjob **)calloc(maxjobs, sizeof(struct atjob *));
d564 1
a564 1
		job = (struct atjob *)malloc(sizeof(struct atjob));
@


1.63
log
@When setting environment variables in the atrun script, use the
"export foo=bar" form instead of "foo=bar; export foo" since the
former allows the shell to catch variable names that are not valid
shell identifiers.  This will cause /bin/sh to exit with an error
(which gets mailed to the at user) and it will not run the script.
OK miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: at.c,v 1.62 2013/11/25 18:02:50 deraadt Exp $	*/
d574 1
a574 1
			newatjobs = realloc(atjobs, newjobs * sizeof(job));
@


1.62
log
@variety of unsigned char casts (or conversions) for ctype
ok krw
@
text
@d1 1
a1 1
/*	$OpenBSD: at.c,v 1.61 2013/04/17 15:58:42 deraadt Exp $	*/
d322 1
a343 2
			(void)fputs("; export ", fp);
			(void)fwrite(*atenv, sizeof(char), eqp - *atenv - 1, fp);
@


1.61
log
@Adapt cron and at for future large time_t and tv_sec types.  These were some
of the harder programs to adapt, so let me know if problems happen.
tested by guenther, gilles, chl, others
@
text
@d1 1
a1 1
/*	$OpenBSD: at.c,v 1.60 2011/08/30 19:56:08 guenther Exp $	*/
d327 1
a327 1
					if (!isalnum(*ap)) {
d357 1
a357 1
			if (*ap != '/' && !isalnum(*ap))
d542 2
a543 1
		if (*ep != '.' || !isalpha(*(ep + 1)) || *(ep + 2) != '\0')
d663 1
a663 1
			if (*ep == '.' && isalpha(*(ep + 1)) &&
d694 2
a695 1
		if (*ep != '.' || !isalpha(*(ep + 1)) || *(ep + 2) != '\0')
d994 2
a995 1
			if (!(islower(queue) || isupper(queue)))
d1088 1
a1088 1
			queue = toupper(queue);
@


1.60
log
@Same fix as 'touch': with the -t option, when the year is specified
but the century isn't, the century is 1900 if year >= 69; otherwise
it's 2000.  (With 32bit time_t, this does't affect any working usage.)

ok millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: at.c,v 1.59 2011/08/23 15:06:37 millert Exp $	*/
d70 1
d165 2
a166 2
		snprintf(atfile, sizeof(atfile), "%s/%ld.%c", AT_DIR,
		    (long)runtimer, queue);
d444 1
a444 1
		(void)printf("%ld.%c\t%s\n", (long)job->runtimer,
d454 1
a454 1
		(void)printf("%-21.18s%-11.8s%10ld.%c   %c%s\n",
d456 1
a456 1
		    (long)job->runtimer, job->queue, job->queue,
a476 1
	long l;
d540 3
a542 3
		l = strtol(dirent->d_name, &ep, 10);
		if (*ep != '.' || !isalpha(*(ep + 1)) || *(ep + 2) != '\0' ||
		    l < 0 || l >= INT_MAX)
a543 1
		runtimer = (time_t)l;
d610 1
a610 1
rmok(int job)
d614 1
a614 1
	printf("%d: remove it? ", job);
d691 3
a693 3
		l = strtol(dirent->d_name, &ep, 10);
		if (*ep != '.' || !isalpha(*(ep + 1)) || *(ep + 2) != '\0' ||
		    l < 0 || l >= INT_MAX)
a694 1
		runtimer = (time_t)l;
@


1.59
log
@Use standard EXIT_SUCCESS/EXIT_FAILURE and STD{IN,OUT,ERR}_FILENO
defines instead of using custom macros.  Missed in last commit.
@
text
@d1 1
a1 1
/*	$OpenBSD: at.c,v 1.58 2011/03/03 15:06:43 millert Exp $	*/
a833 1
			/* current century + specified year */
d835 4
a838 2
			lt->tm_year = ((lt->tm_year / 100) * 100);
			lt->tm_year += yearset;
@


1.58
log
@Use dirfd() instead of peeking into struct dirent for dd_fd, which is
non-standard.
@
text
@d1 1
a1 1
/*	$OpenBSD: at.c,v 1.57 2010/07/02 23:40:09 krw Exp $	*/
d85 1
a85 1
	exit(ERROR_EXIT);
d101 1
a101 1
	exit(ERROR_EXIT);
d118 1
a118 1
	exit(ERROR_EXIT);
d143 1
a143 1
	_exit(ERROR_EXIT);
d672 1
a672 1
					exit(ERROR_EXIT);
d879 1
a879 1
		exit(ERROR_EXIT);
d916 1
a916 1
	exit(ERROR_EXIT);
d1079 1
a1079 1
				exit(ERROR_EXIT);
d1093 1
a1093 1
			exit(ERROR_EXIT);
d1102 1
a1102 1
	exit(OK_EXIT);
@


1.57
log
@'wether' -> 'whether' typo in license text.

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: at.c,v 1.56 2009/10/27 23:59:35 deraadt Exp $	*/
d508 1
a508 1
	if (fstat(spool->dd_fd, &stbuf) != 0)
@


1.56
log
@rcsid[] and sccsid[] and copyright[] are essentially unmaintained (and
unmaintainable).  these days, people use source.  these id's do not provide
any benefit, and do hurt the small install media
(the 33,000 line diff is essentially mechanical)
ok with the idea millert, ok dms
@
text
@d1 1
a1 1
/*	$OpenBSD: at.c,v 1.55 2009/10/05 20:47:19 deraadt Exp $	*/
d29 1
a29 1
 * THEORY OF LIABILITY, WETHER IN CONTRACT, STRICT LIABILITY, OR TORT
@


1.55
log
@open the -f inputfile before letting lower-down functions call chdir()
and move us to where we cannot open it.  problem spotted by austin
ok millert
@
text
@d1 1
a1 1
/*	$OpenBSD: at.c,v 1.54 2007/09/05 08:02:21 moritz Exp $	*/
a42 4

#ifndef lint
static const char rcsid[] = "$OpenBSD: at.c,v 1.54 2007/09/05 08:02:21 moritz Exp $";
#endif
@


1.54
log
@Change some variables to their proper type size_t.

ok millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: at.c,v 1.53 2007/09/02 15:19:31 deraadt Exp $	*/
d45 1
a45 1
static const char rcsid[] = "$OpenBSD: at.c,v 1.53 2007/09/02 15:19:31 deraadt Exp $";
a57 1
char *atinput = NULL;		/* where to get input from */
d191 1
a191 1
	FILE *fp, *fpin;
a291 5
	if (atinput != NULL) {
		fpin = freopen(atinput, "r", stdin);
		if (fpin == NULL)
			perr("Cannot open input file");
	}
d927 1
d1043 12
@


1.53
log
@use calloc() to avoid malloc(n * m) overflows; checked by djm canacar jsg
@
text
@d1 1
a1 1
/*	$OpenBSD: at.c,v 1.52 2007/06/18 11:20:58 millert Exp $	*/
d45 1
a45 1
static const char rcsid[] = "$OpenBSD: at.c,v 1.52 2007/06/18 11:20:58 millert Exp $";
d489 2
a490 1
	int i, shortformat, numjobs, maxjobs;
d584 1
a584 1
			int newjobs = maxjobs * 2;
d600 1
a600 1
			printf("%d\n", numjobs);
@


1.52
log
@Fix typo introduced in seconds parsing.  From Tim van der Molen.
@
text
@d1 1
a1 1
/*	$OpenBSD: at.c,v 1.51 2007/05/24 12:24:43 millert Exp $	*/
d45 1
a45 1
static const char rcsid[] = "$OpenBSD: at.c,v 1.51 2007/05/24 12:24:43 millert Exp $";
d492 1
a492 1
		if ((uids = malloc(sizeof(uid_t) * argc)) == NULL)
d527 1
a527 1
	atjobs = (struct atjob **)malloc(maxjobs * sizeof(struct atjob *));
d666 2
a667 2
		if ((jobs = malloc(sizeof(char *) * argc)) == NULL ||
		    (uids = malloc(sizeof(uid_t) * argc)) == NULL)
@


1.51
log
@If century not specified used the current one instead of aassuming 2000.
@
text
@d1 1
a1 1
/*	$OpenBSD: at.c,v 1.50 2007/05/23 22:34:03 millert Exp $	*/
d45 1
a45 1
static const char rcsid[] = "$OpenBSD: at.c,v 1.50 2007/05/23 22:34:03 millert Exp $";
d815 1
a815 1
		if (*p == '.' && dot != NULL)
@


1.50
log
@Fix cut and pasto, seconds value is now stored in dot, not p.
@
text
@d1 1
a1 1
/*	$OpenBSD: at.c,v 1.48 2007/05/23 19:50:28 millert Exp $	*/
d45 1
a45 1
static const char rcsid[] = "$OpenBSD: at.c,v 1.48 2007/05/23 19:50:28 millert Exp $";
d834 2
a835 2
		lt->tm_year = ATOI2(arg);
		lt->tm_year *= 100;
d843 1
d845 2
a846 1
			lt->tm_year = yearset + 2000;
a847 1
		lt->tm_year -= 1900;	/* Convert to Unix time */
@


1.49
log
@Set tm_sec to 0 if no seconds were specified by the timespec (-t) arg.
@
text
@d826 1
a826 1
		lt->tm_sec = ATOI2(p);
@


1.48
log
@Sanity check the time argument specified by the -t argument.  Some
checks adapted from date(1).  Now prevents scheduling jobs in the
past just like the standard (ie: not -n) at(1) date parsing.
@
text
@d1 1
a1 1
/*	$OpenBSD: at.c,v 1.47 2007/03/26 13:55:42 jmc Exp $	*/
d45 1
a45 1
static const char rcsid[] = "$OpenBSD: at.c,v 1.47 2007/03/26 13:55:42 jmc Exp $";
d820 3
a822 1
	if (dot != NULL) {
@


1.47
log
@indicate that -l takes an optional argument;
whilst here, clean up the -cr descriptions, add some refs to
SEE ALSO, and merge the first two synopses into one

based on a diff from J.C. Roberts
help/ok millert
@
text
@d1 1
a1 1
/*	$OpenBSD: at.c,v 1.46 2006/04/26 03:01:48 cloder Exp $	*/
d45 1
a45 1
static const char rcsid[] = "$OpenBSD: at.c,v 1.46 2006/04/26 03:01:48 cloder Exp $";
d69 1
a69 1
static time_t ttime(const char *);
d800 1
a800 1
 * This is pretty much a copy of stime_arg1() from touch.c.
d803 1
a803 1
ttime(const char *arg)
d805 2
a806 3
	struct timeval tv[2];
	time_t now;
	struct tm *t;
d808 1
a808 1
	char *p;
d810 1
a810 1
	if (gettimeofday(&tv[0], NULL))
d813 13
a825 9
	/* Start with the current time. */
	now = tv[0].tv_sec;
	if ((t = localtime(&now)) == NULL)
		panic("localtime");
	/* [[CC]YY]MMDDhhmm[.SS] */
	if ((p = strchr(arg, '.')) == NULL)
		t->tm_sec = 0;		/* Seconds defaults to 0. */
	else {
		if (strlen(p + 1) != 2)
a826 2
		*p++ = '\0';
		t->tm_sec = ATOI2(p);
d832 2
a833 2
		t->tm_year = ATOI2(arg);
		t->tm_year *= 100;
d839 1
a839 1
			t->tm_year += yearset;
d842 1
a842 1
			t->tm_year = yearset + 2000;
d844 1
a844 1
		t->tm_year -= 1900;	/* Convert to UNIX time. */
d847 13
a859 5
		t->tm_mon = ATOI2(arg);
		--t->tm_mon;		/* Convert from 01-12 to 00-11 */
		t->tm_mday = ATOI2(arg);
		t->tm_hour = ATOI2(arg);
		t->tm_min = ATOI2(arg);
d865 3
a867 5
	t->tm_isdst = -1;		/* Figure out DST. */
	tv[0].tv_sec = tv[1].tv_sec = mktime(t);
	if (tv[0].tv_sec != -1)
		return (tv[0].tv_sec);
	else
d869 5
a873 2
		panic("out of range or illegal time specification: "
		    "[[CC]YY]MMDDhhmm[.SS]");
@


1.46
log
@Cleanup, remove an unused var, use an int to store argc instead of a char,
makes lint a bit happier. OK deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: at.c,v 1.45 2006/03/22 21:51:39 robert Exp $	*/
d45 1
a45 1
static const char rcsid[] = "$OpenBSD: at.c,v 1.45 2006/03/22 21:51:39 robert Exp $";
d895 3
a897 3
		    "usage: at [-blm] [-f file] [-q queue] -t time_arg\n"
		    "       at [-blm] [-f file] [-q queue] timespec\n"
		    "       at -c | -r job [job ...]\n");
@


1.45
log
@plug an fd leak and closedir() two directories;

ok otto@@
@
text
@d1 1
a1 1
/*	$OpenBSD: at.c,v 1.44 2005/10/25 15:49:38 jmc Exp $	*/
d45 1
a45 1
static const char rcsid[] = "$OpenBSD: at.c,v 1.44 2005/10/25 15:49:38 jmc Exp $";
d71 1
a71 1
static void panic(const char *);
d137 1
d151 1
d422 2
a423 2
	const struct atjob *j1 = *(struct atjob **)v1;
	const struct atjob *j2 = *(struct atjob **)v2;
d644 1
a644 1
	char **jobs, *ep, queue;
a705 1
		queue = *(ep + 1);
@


1.44
log
@dont' -> don't in comments;
from ray lai;
@
text
@d1 1
a1 1
/*	$OpenBSD: at.c,v 1.43 2005/06/23 14:39:35 jmc Exp $	*/
d45 1
a45 1
static const char rcsid[] = "$OpenBSD: at.c,v 1.43 2005/06/23 14:39:35 jmc Exp $";
d591 1
d761 1
d770 2
@


1.43
log
@- at(1) synopsis: -r expects a `job' arg, not a timespec
- remove description of -v: it is only for use with atq(1), and is
correctly documented there
- sync usage()
- correctly format synopis for atrm(1)
@
text
@d1 1
a1 1
/*	$OpenBSD: at.c,v 1.42 2004/06/17 22:09:11 millert Exp $	*/
d45 1
a45 1
static const char rcsid[] = "$OpenBSD: at.c,v 1.42 2004/06/17 22:09:11 millert Exp $";
d306 1
a306 1
	 * with a pair of "'s.  Dont't export the no_export list (such as
@


1.42
log
@Remove trailing whitespace and, for printf, uid/gid are unsigned
@
text
@d1 1
a1 1
/*	$OpenBSD: at.c,v 1.41 2004/06/03 19:19:07 millert Exp $	*/
d45 1
a45 1
static const char rcsid[] = "$OpenBSD: at.c,v 1.41 2004/06/03 19:19:07 millert Exp $";
d890 3
a892 5
		    "usage: at [-bm] [-f file] [-q queue] -t time_arg\n"
		    "       at [-bm] [-f file] [-q queue] timespec\n"
		    "       at -c job [job ...]\n"
		    "       at -l [-q queue] [job ...]\n"
		    "       at -r job [job ...]\n");
d896 1
a896 1
		    "usage: atq [-cnv] [-q queue] [name...]\n");
@


1.41
log
@Verify that argc > 0 before trying to use argv and mark usage as __dead.
from Dmitry V. Levin
@
text
@d1 1
a1 1
/*	$OpenBSD: at.c,v 1.40 2003/09/26 21:26:40 tedu Exp $	*/
d45 1
a45 1
static const char rcsid[] = "$OpenBSD: at.c,v 1.40 2003/09/26 21:26:40 tedu Exp $";
d96 1
a96 1
static __dead void 
d129 1
a129 1
static __dead void 
d137 1
a137 1
static void 
d150 1
a150 1
static void 
d296 3
a298 2
	(void)fprintf(fp, "#!/bin/sh\n# atrun uid=%ld gid=%ld\n# mail %*s %d\n",
	    (long)real_uid, (long)real_gid, MAX_UNAME, mailname, send_mail);
d805 1
a805 1
	
d808 1
a808 1
	
d822 1
a822 1
	
d850 1
a850 1
	
@


1.40
log
@better realloc.  ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: at.c,v 1.39 2003/07/23 16:53:33 mpech Exp $	*/
d45 1
a45 1
static const char rcsid[] = "$OpenBSD: at.c,v 1.39 2003/07/23 16:53:33 mpech Exp $";
d74 1
a74 1
static void usage(void);
d881 1
a881 1
static void
d923 3
@


1.39
log
@Add '\n' to error messages in "atrm" mode.

millert@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: at.c,v 1.38 2003/05/04 21:06:30 avsm Exp $	*/
d45 1
a45 1
static const char rcsid[] = "$OpenBSD: at.c,v 1.38 2003/05/04 21:06:30 avsm Exp $";
d479 1
a479 1
	struct atjob **atjobs, *job;
d580 3
a582 3
			maxjobs *= 2;
			atjobs = realloc(atjobs, maxjobs * sizeof(job));
			if (atjobs == NULL)
d584 2
@


1.38
log
@the buffer to getcwd(3) should be PATH_MAX in size, not MAX_FNAME
to avoid unnecessary truncation
millert@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: at.c,v 1.37 2003/03/13 21:28:30 millert Exp $	*/
d45 1
a45 1
static const char rcsid[] = "$OpenBSD: at.c,v 1.37 2003/03/13 21:28:30 millert Exp $";
d672 1
a672 1
					    " may %s other users' jobs",
d768 1
a768 1
				fprintf(stderr, "%s: %s: no such job",
@


1.37
log
@Stash uid and mode in struct at so we don't need to pass around a
struct statbuf *.  Fixes a bug where atq reports all jobs as being
owned by the owner of the last job in the queue.  This is fallout
from when I added sorting as per the historic BSD atq.
@
text
@d1 1
a1 1
/*	$OpenBSD: at.c,v 1.36 2003/03/03 18:23:13 millert Exp $	*/
d45 1
a45 1
static const char rcsid[] = "$OpenBSD: at.c,v 1.36 2003/03/03 18:23:13 millert Exp $";
d916 1
a916 1
	char cwd[MAX_FNAME];
@


1.36
log
@Add back fix from 1.32 that was lost in latest sync
@
text
@d1 1
a1 1
/*	$OpenBSD: at.c,v 1.35 2003/02/20 20:38:08 millert Exp $	*/
d45 1
a45 1
static const char rcsid[] = "$OpenBSD: at.c,v 1.35 2003/02/20 20:38:08 millert Exp $";
d438 1
a438 1
print_job(struct atjob *job, int n, struct stat *st, int shortformat)
d453 1
a453 1
		pw = getpwuid(st->st_uid);
d463 1
a463 1
		    (S_IXUSR & st->st_mode) ? "" : " (done)");
d576 2
d607 1
a607 1
		print_job(atjobs[i], i + 1, &stbuf, shortformat);
@


1.35
log
@Sync with ISC cron-current + my at(1) integration.
The at(1) code is now more tightly integrated into the cron codebase.
@
text
@d1 1
a1 1
/*	$OpenBSD: at.c,v 1.34 2003/02/18 02:25:39 millert Exp $	*/
d45 1
a45 1
static const char rcsid[] = "$OpenBSD: at.c,v 1.34 2003/02/18 02:25:39 millert Exp $";
d704 2
a705 1
				if (strcmp(dirent->d_name, jobs[i]) == 0) {
@


1.34
log
@Use the SUN_LEN macro to set sun_len correctly
@
text
@d1 1
a1 2
/*	$OpenBSD: at.c,v 1.33 2003/02/17 21:47:19 millert Exp $	*/
/*	$NetBSD: at.c,v 1.4 1995/03/25 18:13:31 glass Exp $	*/
d11 1
a11 1
 *  Copyright (C) 2002  Todd C. Miller
d34 1
a34 29
#include <sys/param.h>
#include <sys/socket.h>
#include <sys/stat.h>
#include <sys/time.h>
#include <sys/un.h>

#include <ctype.h>
#include <dirent.h>
#include <err.h>
#include <errno.h>
#include <fcntl.h>
#include <limits.h>
#include <locale.h>
#include <pwd.h>
#include <signal.h>
#include <stddef.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <time.h>
#include <unistd.h>
#include <utime.h>
#include <utmp.h>

#if (MAXLOGNAME-1) > UT_NAMESIZE
#define LOGNAMESIZE UT_NAMESIZE
#else
#define LOGNAMESIZE (MAXLOGNAME-1)
#endif
d36 1
a37 5
#include "panic.h"
#include "parsetime.h"
#include "perm.h"
#include "pathnames.h"
#define MAIN
d39 1
d45 1
a45 1
static const char rcsid[] = "$OpenBSD: at.c,v 1.33 2003/02/17 21:47:19 millert Exp $";
d56 1
a56 1
char atfile[PATH_MAX];		/* path to the at spool file */
d67 1
a67 1
static void writefile(time_t, char);
a68 1
static void poke_daemon(void);
d70 66
d147 1
a147 1
	_exit(EXIT_FAILURE);
d153 1
a153 12
	char buf[1024];

	/* Time out after some seconds. */
	strlcpy(buf, __progname, sizeof(buf));
	strlcat(buf, ": File locking timed out\n", sizeof(buf));
	write(STDERR_FILENO, buf, strlen(buf));
	if (fcreated) {
		PRIV_START;
		unlink(atfile);
		PRIV_END;
	}
	_exit(EXIT_FAILURE);
d167 2
a168 2
		snprintf(atfile, sizeof(atfile), "%s/%ld.%c",
		    _PATH_ATJOBS, (long)runtimer, queue);
d182 1
a182 1
writefile(time_t runtimer, char queue)
d184 2
a185 1
	char *ap, *mailname, *shell;
a186 1
	char path[PATH_MAX];
d203 1
a203 1
	memset(&act, 0, sizeof act);
d211 3
d220 1
a220 1
	memset(&act, 0, sizeof act);
d223 3
a225 1
	act.sa_flags = 0;
d228 1
a228 1
	lockdes = open(_PATH_ATJOBS, O_RDONLY|O_EXLOCK, 0);
d230 2
a231 3

	if (lockdes < 0)
		perr("Cannot lock jobs dir");
d272 1
a272 1
	    (strlen(mailname) > LOGNAMESIZE) || (getpwnam(mailname) == NULL)) {
d297 1
a297 1
	    (long)real_uid, (long)real_gid, LOGNAMESIZE, mailname, send_mail);
a357 2
	if ((ap = getcwd(path, sizeof(path))) == NULL)
		perr("Cannot get current working directory");
d359 1
a359 1
	for (; *ap != '\0'; ap++) {
d404 3
a406 1
	poke_daemon();
d411 1
a411 1
	(void)fprintf(stderr, "job %s at %s\n", &atfile[sizeof(_PATH_ATJOBS)],
d469 1
a469 1
 * _PATH_ATJOBS, or all jobs if we are root.  If argc is > 0, argv
d490 1
a490 1
			err(EXIT_FAILURE, "malloc");
d494 1
a494 2
				errx(EXIT_FAILURE,
				    "%s: invalid user name", argv[i]);
d496 1
a496 2
				errx(EXIT_FAILURE, "Only the superuser may "
				    "display other users' jobs");
d502 1
a502 1
	shortformat = strcmp(__progname, "at") == 0;
d506 2
a507 2
	if (chdir(_PATH_ATJOBS) != 0)
		perr2("Cannot change to ", _PATH_ATJOBS);
d510 1
a510 1
		perr2("Cannot open ", _PATH_ATJOBS);
d514 2
a515 2
	if (fstat(dirfd(spool), &stbuf) != 0)
		perr2("Cannot stat ", _PATH_ATJOBS);
d526 1
a526 1
		err(EXIT_FAILURE, "malloc");
d533 1
a533 1
			perr2("Cannot stat in ", _PATH_ATJOBS);
d573 1
a573 1
			err(EXIT_FAILURE, "malloc");
d578 4
a581 4
		    maxjobs *= 2;
		    atjobs = realloc(atjobs, maxjobs * sizeof(struct atjob *));
		    if (atjobs == NULL)
			err(EXIT_FAILURE, "realloc");
d624 1
a624 1
 * Loop through all jobs in _PATH_ATJOBS and display or delete ones
d645 2
a646 2
	if (chdir(_PATH_ATJOBS) != 0)
		perr2("Cannot change to ", _PATH_ATJOBS);
d649 1
a649 1
		perr2("Cannot open ", _PATH_ATJOBS);
d660 1
a660 1
			err(EXIT_FAILURE, "malloc");
d668 7
a674 5
				if (real_uid != pw->pw_uid && real_uid != 0)
					errx(EXIT_FAILURE,
					    "Only the superuser may %s"
					    " other users' jobs", what == ATRM
					    ? "remove" : "print");
d677 1
a677 2
				errx(EXIT_FAILURE,
				    "%s: invalid user name", argv[i]);
d687 1
a687 1
			perr2("Cannot stat in ", _PATH_ATJOBS);
d704 1
a704 2
				if (jobs[i] != NULL &&
				    strcmp(dirent->d_name, jobs[i]) == 0) {
d757 1
a757 3
				errx(EXIT_FAILURE,
				    "Internal error, process_jobs = %d",
				    what);
d765 2
a766 1
				warnx("%s: no such job", jobs[i]);
d774 8
a781 2
	if (changed)
		poke_daemon();
d855 6
a860 1
#define RELOAD_AT	0x4	/* XXX - from cron's macros.h */
d862 4
a865 6
/* XXX - share with crontab */
static void
poke_daemon() {
	int sock, flags;
	unsigned char poke;
	struct sockaddr_un sun;
d869 3
a871 5
	if (utime(_PATH_ATJOBS, NULL) < 0) {
		warn("can't update mtime on %s", _PATH_ATJOBS);
		PRIV_END;
		return;
	}
d873 2
a874 14
	/* Failure to poke the daemon socket is not a fatal error. */
	(void) signal(SIGPIPE, SIG_IGN);
	strlcpy(sun.sun_path, CRONDIR "/" SPOOL_DIR "/" CRONSOCK,
	    sizeof(sun.sun_path));
	sun.sun_family = AF_UNIX;
	sun.sun_len = SUN_LEN(&sun);
	if ((sock = socket(AF_UNIX, SOCK_STREAM, 0)) >= 0 &&
	    connect(sock, (struct sockaddr *)&sun, sizeof(sun)) == 0) {
		poke = RELOAD_AT;
		write(sock, &poke, 1);
		close(sock);
	} else
		fprintf(stderr, "Warning, cron does not appear to be running.\n");
	(void) signal(SIGPIPE, SIG_DFL);
d876 28
a903 1
	PRIV_END;
d913 1
d919 5
d927 1
a927 1
	if (strcmp(__progname, "atq") == 0) {
d930 1
a930 1
	} else if (strcmp(__progname, "atrm") == 0) {
d933 1
a933 1
	} else if (strcmp(__progname, "batch") == 0) {
d1023 5
d1029 1
a1029 2
		errx(EXIT_FAILURE, "You do not have permission to use %s.",
		     __progname);
d1046 7
a1052 3
		if (timer == -1)
			timer = parsetime(argc, argv);
		writefile(timer, queue);
d1061 1
a1061 3
		if (argc > 0)
			timer = parsetime(argc, argv);
		else
d1063 2
d1066 1
a1066 1
		writefile(timer, queue);
d1073 1
a1073 1
	exit(EXIT_SUCCESS);
@


1.33
log
@Missing #include <limits.h>
@
text
@d1 1
a1 1
/*	$OpenBSD: at.c,v 1.32 2003/01/02 15:48:40 mpech Exp $	*/
d77 1
a77 1
static const char rcsid[] = "$OpenBSD: at.c,v 1.32 2003/01/02 15:48:40 mpech Exp $";
d848 1
a848 1
	sun.sun_len = strlen(sun.sun_path);
@


1.32
log
@Fix 'at -r' crash.
While loop in process_job() jobs[i] will contain NULL.
Skip mess.

millert@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: at.c,v 1.31 2002/11/20 19:57:19 millert Exp $	*/
d46 1
d77 1
a77 1
static const char rcsid[] = "$OpenBSD: at.c,v 1.31 2002/11/20 19:57:19 millert Exp $";
@


1.31
log
@Add missing increment in newjob() when there is a time collision.
@
text
@d1 1
a1 1
/*	$OpenBSD: at.c,v 1.30 2002/07/15 19:13:29 millert Exp $	*/
d76 1
a76 1
static const char rcsid[] = "$OpenBSD: at.c,v 1.30 2002/07/15 19:13:29 millert Exp $";
d678 2
a679 1
				if (strcmp(dirent->d_name, jobs[i]) == 0) {
@


1.30
log
@Move atrun(8) functionality into cron(8) proper.  This fixes the
long-standing annoyance that atrun's granularity is 10 minutes.
Most at jobs run with a 1 minute granularity.  Jobs submitted via
"at now" or "batch" will run immediately.  Includes a rewritten
cron(8) man page.  at(1) will be integrated more closely into
cron at a future date.

Upgrading notes:
    the atrun job in root's crontab should be removed.
    the /var/at/spool directory is no longer used
@
text
@d1 1
a1 1
/*	$OpenBSD: at.c,v 1.29 2002/05/14 18:05:39 millert Exp $	*/
d76 1
a76 1
static const char rcsid[] = "$OpenBSD: at.c,v 1.29 2002/05/14 18:05:39 millert Exp $";
d149 1
@


1.30.2.1
log
@Pull patches from current:
Fixes by millert and mpech.

o Add missing increment in newjob() when there is a time collision.
o Fix 'at -r' crash. While loop in process_job() jobs[i] will
  contain NULL. Skip mess.
o Add missing  #include <limits.h>
o Stash uid and mode in struct at so we don't need to pass around a
  struct statbuf *.  Fixes a bug where atq reports all jobs as being
  owned by the owner of the last job in the queue.

millert@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: at.c,v 1.30 2002/07/15 19:13:29 millert Exp $	*/
a45 1
#include <limits.h>
d76 1
a76 1
static const char rcsid[] = "$OpenBSD: at.c,v 1.30 2002/07/15 19:13:29 millert Exp $";
a148 1
		runtimer++;
d410 1
a410 1
print_job(struct atjob *job, int n, int shortformat)
d425 1
a425 1
		pw = getpwuid(job->uid);
d435 1
a435 1
		    (S_IXUSR & job->mode) ? "" : " (done)");
a549 2
		job->uid = stbuf.st_uid;
		job->mode = stbuf.st_mode;
d579 1
a579 1
		print_job(atjobs[i], i + 1, shortformat);
d677 1
a677 2
				if (jobs[i] != NULL &&
				    strcmp(dirent->d_name, jobs[i]) == 0) {
@


1.29
log
@Major changes:

Job names are now "runtime.queue" where runtime is when the job will run
in Unix time format.  This is what SysV at does and allows us to nuke
the .SEQ file.

Historic BSD options for atq and atrm are now implemented;
atq and atrm get their own man pages.

At no longer does anything with the -v flag.  We print the execution
time when jobs are submitted so there is no need.

Most *scanf() usage is gone (one remains in atrun).

Better sanity checks in atrun.

Random style/cleanup.

With these changes we have the best of both worlds; POSIX compliance with
the traditional BSD features.
@
text
@d1 1
a1 1
/*	$OpenBSD: at.c,v 1.28 2002/05/13 18:43:53 millert Exp $	*/
d36 1
d39 2
d55 1
d76 1
a76 1
static const char rcsid[] = "$OpenBSD: at.c,v 1.28 2002/05/13 18:43:53 millert Exp $";
d100 1
d268 2
a269 2
	(void)fprintf(fp, "#!/bin/sh\n# atrun uid=%u gid=%u\n# mail %*s %d\n",
	    real_uid, real_gid, LOGNAMESIZE, mailname, send_mail);
d377 3
d615 1
a615 1
	int error, i, ch;
d655 1
d700 3
a702 1
					if (unlink(dirent->d_name) != 0)
d747 4
d821 35
@


1.28
log
@Execute job with user's shell, not /bin/sh as per POSIX and historic
BSD behavior.

Add some bash-specific and ssh agent variables to the no_export list.

Print the message after job submission the way POSIX wants.

When cat'ing or removing non-existent jobs, exit with an error if
the specified job does not exist.
@
text
@d1 1
a1 1
/*	$OpenBSD: at.c,v 1.27 2002/05/13 16:12:07 millert Exp $	*/
d11 3
a34 1
/* System Headers */
d40 1
d43 1
a52 2
#include <locale.h>
#include <err.h>
a59 1
/* Local headers */
a67 1
/* Macros */
d69 1
a70 3
#define TIMESIZE 50

/* File scope variables */
d72 1
a72 1
static const char rcsid[] = "$OpenBSD: at.c,v 1.27 2002/05/13 16:12:07 millert Exp $";
d75 1
a80 3
static int send_mail = 0;

/* External variables */
a81 2
extern char **environ;
int fcreated;
d83 3
a85 3
char atfile[FILENAME_MAX];

char *atinput = (char *)0;	/* where to get input from */
d87 4
a90 3
char atverify = 0;		/* verify time instead of queuing job */

/* Function declarations */
a93 1
static char *cwdname(void);
d95 1
a95 1
static void list_jobs(void);
a97 2
/* Signal catching functions */

d128 4
a131 1
/* Local functions */
a132 3
static char *
cwdname(void)
{
d134 3
a136 2
	 * Read in the current directory; the name will be overwritten on
	 * subsequent calls.
d138 8
a145 24
	static char path[MAXPATHLEN];

	return (getcwd(path, sizeof(path)));
}

static int
nextjob(void)
{
	int jobno;
	FILE *fid;

	/* We require that the sequence file already exist. */
	if ((fid = fopen(_PATH_SEQFILE, "r+")) == NULL)
		return (EOF);

	if (fscanf(fid, "%5x", &jobno) == 1)
		jobno = (jobno + 1) % 0xfffff;	/* 2^20 jobs enough? */
	else
		jobno = 1;
	(void)rewind(fid);
	(void)fprintf(fid, "%05x\n", jobno);
	(void)fclose(fid);

	return (jobno);
d148 4
d155 1
a155 6
	/*
	 * This does most of the work if at or batch are invoked for
	 * writing a job.
	 */
	int jobno;
	char *ap, *ppos, *mailname, *shell;
d157 1
a158 1
	struct stat statbuf;
d166 1
a166 1
	struct flock lock;
d176 1
a176 1
	sigemptyset(&(act.sa_mask));
a177 1

a179 10
	(void)strlcpy(atfile, _PATH_ATJOBS, sizeof atfile);
	ppos = atfile + strlen(atfile);

	/*
	 * Loop over all possible file names for running something at this
	 * particular time, see if a file is there; the first empty slot at
	 * any particular time is used.  Lock the jobs directory first
	 * to make sure we're alone when doing this.
	 */

d183 2
d188 1
d190 1
a190 1
	sigemptyset(&(act.sa_mask));
a199 14
	if ((jobno = nextjob()) == EOF)
		perr("Cannot generate job number");

	(void)snprintf(ppos, sizeof(atfile) - (ppos - atfile),
	    "%c%5x%8x", queue, jobno, (unsigned) (runtimer/60));

	for (ap = ppos; *ap != '\0'; ap++)
		if (*ap == ' ')
			*ap = '0';

	if (stat(atfile, &statbuf) != 0)
		if (errno != ENOENT)
			perr2("Cannot access ", _PATH_ATJOBS);

d207 1
a207 1
	if ((fdes = open(atfile, O_WRONLY | O_CREAT | O_EXCL, S_IRUSR)) == -1)
a224 5
	lock.l_type = F_UNLCK;
	lock.l_whence = SEEK_SET;
	lock.l_start = 0;
	lock.l_len = 0;
	(void)fcntl(lockdes, F_SETLKW, &lock);
d325 1
a325 1
	if ((ap = cwdname()) == NULL)
d342 2
a343 1
	(void)fprintf(fp, " || {\n\t echo 'Execution directory inaccessible' >&2\n\t exit 1\n}\n");
d375 54
a428 1
	(void)fprintf(stderr, "job %d at %s\n", jobno, timestr);
d431 7
d439 1
a439 1
list_jobs(void)
a440 4
	/*
	 * List all a user's jobs in the queue, by looping through
	 * _PATH_ATJOBS, or everybody's if we are root
	 */
a441 1
	DIR *spool;
d443 2
a444 5
	struct stat buf;
	struct tm runtime;
	unsigned long ctm;
	char queue;
	int jobno;
d446 23
a468 2
	char timestr[TIMESIZE];
	int first = 1;
d478 17
a494 1
	/* Loop over every file in the directory */
d496 3
a498 1
		if (stat(dirent->d_name, &buf) != 0)
d501 2
d507 3
a509 3
		if (!S_ISREG(buf.st_mode)
		    || ((buf.st_uid != real_uid) && !(real_uid == 0))
		    || !(S_IXUSR & buf.st_mode || atverify))
d512 3
a514 1
		if (sscanf(dirent->d_name, "%c%5x%8lx", &queue, &jobno, &ctm) != 3)
d516 2
d522 51
a572 15
		runtimer = 60 * (time_t) ctm;
		runtime = *localtime(&runtimer);
		strftime(timestr, TIMESIZE, "%a %b %e %T %Y", &runtime);
		if (first) {
			(void)printf("Date\t\t\t\tOwner\t\tQueue\tJob#\n");
			first = 0;
		}
		pw = getpwuid(buf.st_uid);

		(void)printf("%s\t%-16s%c%s\t%d\n",
		    timestr,
		    pw ? pw->pw_name : "???",
		    queue,
		    (S_IXUSR & buf.st_mode) ? "" : "(done)",
		    jobno);
d574 13
a586 1
	PRIV_END;
d589 5
d597 8
a604 2
	int i;
	struct stat buf;
d606 2
a607 5
	struct dirent *dirent;
	unsigned long ctm;
	char queue;
	int jobno;
	int error;
d619 27
d650 1
a650 1
		if (stat(dirent->d_name, &buf) != 0)
d654 1
a654 1
		if (sscanf(dirent->d_name, "%c%5x%8lx", &queue, &jobno, &ctm) !=3)
d657 6
a662 9
		for (i = optind; i < argc; i++) {
			if (argv[i] != NULL && atoi(argv[i]) == jobno) {
				/* Treat wrong owner like unknown job. */
				if ((buf.st_uid != real_uid) && !(real_uid == 0))
					continue;
				argv[i] = NULL;
				switch (what) {
				case ATRM:
					PRIV_START;
d664 27
d693 5
d699 1
a699 1
					PRIV_END;
d701 1
a701 1
					break;
d703 2
a704 4
				case CAT:
					{
						FILE *fp;
						int ch;
d706 1
a706 1
						PRIV_START;
d708 1
a708 1
						fp = fopen(dirent->d_name, "r");
d710 2
a711 1
						PRIV_END;
d713 2
a714 2
						if (!fp)
							perr("Cannot open file");
d716 1
a716 4
						while((ch = getc(fp)) != EOF)
							putchar(ch);
					}
					break;
d718 5
a722 6
				default:
					errx(EXIT_FAILURE,
					    "Internal error, process_jobs = %d",
					    what);
					break;
				}
d726 4
a729 3
	for (error = 0, i = optind; i < argc; i++) {
		if (argv[i] != NULL) {
			warnx("%s: no such job number", argv[i]);
d733 4
a736 1
	return(error);
d741 3
a746 5
	/*
	 * This is pretty much a copy of stime_arg1() from touch.c.  I changed
	 * the return value and the argument list because it's more convenient
	 * (IMO) to do everything in one place. - Joe Halpin
	 */
a807 2
/* Global functions */

d811 1
a811 1
	int c;
d815 4
a818 2
	time_t timer;
	int tflag = 0;
d825 1
a825 1
		options = "q:v";
d828 1
a828 1
		options = "";
d835 18
a852 5
	opterr = 1;
	while ((c = getopt(argc, argv, options)) != -1)
		switch (c) {
		case 'v':	/* verify time settings */
			atverify = 1;
d860 5
a864 1
			atinput = optarg;
a879 3
			if (program != AT)
				usage();

a884 3
			if (program != AT)
				usage();
			tflag++;
a888 3
			if (program != AT)
				usage();

d890 1
a890 1
			options = "q:v";
a893 3
			if (program != AT)
				usage();

d899 10
a908 2
			program = CAT;
			options = "";
d915 3
a917 1
	/* end of options eating */
d926 1
a926 3
		if (optind != argc)
			usage();
		list_jobs();
d931 1
a931 1
		if (optind == argc)
d938 1
a938 1
		if (!tflag)
a939 4
		if (atverify) {
			struct tm *tm = localtime(&timer);
			(void)fprintf(stderr, "%s\n", asctime(tm));
		}
d949 1
a949 1
		if (argc > optind)
a952 5

		if (atverify) {
			struct tm *tm = localtime(&timer);
			(void)fprintf(stderr, "%s\n", asctime(tm));
		}
@


1.27
log
@Only print usage for the command that was run (at, atq, atrm, batch), not
all four.  Also differentiate between the touch(1) style time as time_arg
and the at(1) style time as timespec (which is what SUS3 does).
Instead of referring to the touch time format as POSIX time, reference
touch.  This is what SUS3 does and it is what users will know.
@
text
@d1 1
a1 1
/*	$OpenBSD: at.c,v 1.26 2002/05/11 23:16:44 millert Exp $	*/
d74 1
a74 1
static const char rcsid[] = "$OpenBSD: at.c,v 1.26 2002/05/11 23:16:44 millert Exp $";
d79 2
a80 1
	"TERM", "TERMCAP", "DISPLAY", "_"
d179 2
a180 1
	char *ap, *ppos, *mailname;
d183 1
d296 13
d398 3
d405 1
a405 1
	(void)fprintf(fp, "\n");
d421 5
a425 1
	(void)fprintf(stderr, "Job %d will be executed using /bin/sh\n", jobno);
d494 1
a494 1
static void
a496 1
	/* Delete every argument (job - ID) given */
d504 1
d517 1
a517 1
	while((dirent = readdir(spool)) != NULL) {
d528 2
a529 1
			if (atoi(argv[i]) == jobno) {
d531 2
a532 2
					errx(EXIT_FAILURE,
					     "%s: Not owner\n", argv[i]);
d572 8
a579 1
}				/* delete_jobs */
d764 1
a764 1
		process_jobs(argc, argv, program);
@


1.26
log
@Pass -Wall and use ANSI function headers.
@
text
@d1 1
a1 1
/*	$OpenBSD: at.c,v 1.25 2002/05/11 23:02:33 millert Exp $	*/
a71 2
enum { ATQ, ATRM, AT, BATCH, CAT };	/* what program we want to run */

d74 1
a74 1
static const char rcsid[] = "$OpenBSD: at.c,v 1.25 2002/05/11 23:02:33 millert Exp $";
d87 1
d454 1
a454 1
		strftime(timestr, TIMESIZE, "%+", &runtime);
a628 1
	int program = AT;			/* default program mode */
@


1.25
log
@Add POSIX -r and -t flags from FreeBSD.  The old -d option is now
deprecated and no longer documented.
Also, use __progname instead of examining argv and clean up a few minor
warnings.
@
text
@d1 1
a1 1
/*	$OpenBSD: at.c,v 1.24 2002/05/11 21:56:54 millert Exp $	*/
d76 1
a76 1
static char rcsid[] = "$OpenBSD: at.c,v 1.24 2002/05/11 21:56:54 millert Exp $";
d107 1
a107 2
sigc(signo)
	int signo;
d111 1
a111 1
		PRIV_START
d113 1
a113 1
		PRIV_END
d120 1
a120 2
alarmc(signo)
	int signo;
d129 1
a129 1
		PRIV_START
d131 1
a131 1
		PRIV_END
d139 1
a139 1
cwdname()
d151 1
a151 1
nextjob()
d172 1
a172 3
writefile(runtimer, queue)
	time_t runtimer;
	char queue;
d213 1
a213 1
	PRIV_START
d260 1
a260 1
	PRIV_END
d407 1
a407 1
list_jobs()
d425 1
a425 1
	PRIV_START
d469 1
a469 1
	PRIV_END
d473 1
a473 4
process_jobs(argc, argv, what)
	int argc;
	char **argv;
	int what;
d484 1
a484 1
	PRIV_START
d492 1
a492 1
	PRIV_END
d497 1
a497 1
		PRIV_START
d500 1
a500 1
		PRIV_END
d512 1
a512 1
					PRIV_START
d517 1
a517 1
					PRIV_END
d526 1
a526 1
						PRIV_START
d530 1
a530 1
						PRIV_END
d625 1
a625 3
main(argc, argv)
	int argc;
	char **argv;
d635 1
a635 1
	RELINQUISH_PRIVS
@


1.24
log
@Kill -V (version) option since it has no relation to reality any more.
@
text
@d1 1
a1 1
/*	$OpenBSD: at.c,v 1.23 2002/05/11 21:37:13 millert Exp $	*/
a32 1
#include <sys/types.h>
d35 1
a35 1
#include <sys/wait.h>
d76 1
a76 1
static char rcsid[] = "$OpenBSD: at.c,v 1.23 2002/05/11 21:37:13 millert Exp $";
a88 1
char *namep;
d102 1
d127 1
a127 1
	strlcpy(buf, namep, sizeof(buf));
d459 1
a459 1
		strftime(timestr, TIMESIZE, "%X %x", &runtime);
d461 1
a461 1
			(void)printf("Date\t\t\tOwner\tQueue\tJob#\n");
d466 1
a466 1
		(void)printf("%s\t%s\t%c%s\t%d\n",
d558 71
d639 2
a640 7
	char *pgm;

	enum {
		ATQ, ATRM, AT, BATCH, CAT
	};				/* what program we want to run */
	int program = AT;		/* our default program */
	char *options = "q:f:mvldbc";	/* default options for at */
d642 1
a645 8
	/* Eat any leading paths */
	if ((pgm = strrchr(argv[0], '/')) == NULL)
		pgm = argv[0];
	else
		pgm++;

	namep = pgm;

d647 1
a647 1
	if (strcmp(pgm, "atq") == 0) {
d650 1
a650 1
	} else if (strcmp(pgm, "atrm") == 0) {
d653 1
a653 1
	} else if (strcmp(pgm, "batch") == 0) {
d685 2
a686 1
		case 'd':
d694 7
d730 1
a730 1
		     namep);
d748 3
a750 1
		timer = parsetime(argc, argv);
@


1.23
log
@Use O_EXCL (not O_TRUNC) when creating new job file.  If there is a
pre-existing file with the same name this is indicative of a problem
with the sequence file and so it makes sense to treat it as an
error.
@
text
@d1 1
a1 1
/*	$OpenBSD: at.c,v 1.22 2002/05/11 18:41:20 millert Exp $	*/
d77 1
a77 1
static char rcsid[] = "$OpenBSD: at.c,v 1.22 2002/05/11 18:41:20 millert Exp $";
d575 1
a575 2
	char *options = "q:f:mvldbVc";	/* default options for at */
	int disp_version = 0;
d591 1
a591 1
		options = "q:vV";
d594 1
a594 1
		options = "V";
d597 1
a597 1
		options = "f:q:mvV";
d632 1
a632 1
			options = "V";
d640 1
a640 1
			options = "q:vV";
d648 1
a648 5
			options = "f:q:mvV";
			break;

		case 'V':
			disp_version = 1;
a660 3

	if (disp_version)
		(void)fprintf(stderr, "%s version %.1f\n", namep, AT_VERSION);
@


1.22
log
@at(1) is no longer setuid root, it is setgid crontab.
This means that /var/at/at.{allow,deny} must be readable by group
crontab, /var/at/jobs is mode 01770, and /var/at/.SEQ is mode 0660.
@
text
@d1 1
a1 1
/*	$OpenBSD: at.c,v 1.21 2002/02/16 21:27:44 millert Exp $	*/
d77 1
a77 1
static char rcsid[] = "$OpenBSD: at.c,v 1.21 2002/02/16 21:27:44 millert Exp $";
d256 1
a256 2
	if ((fdes = open(atfile, O_WRONLY|O_CREAT|O_TRUNC|O_NONBLOCK|O_NOFOLLOW,
	    S_IRUSR)) == -1)
@


1.21
log
@Part one of userland __P removal.  Done with a simple regexp with some minor hand editing to make comments line up correctly.  Another pass is forthcoming that handles the cases that could not be done automatically.
@
text
@d1 1
a1 1
/*	$OpenBSD: at.c,v 1.20 2001/01/17 19:29:06 deraadt Exp $	*/
d77 1
a77 1
static char rcsid[] = "$OpenBSD: at.c,v 1.20 2001/01/17 19:29:06 deraadt Exp $";
d159 13
a171 15
	if ((fid = fopen(_PATH_SEQFILE, "r+")) != NULL) {
		if (fscanf(fid, "%5x", &jobno) == 1) {
			(void)rewind(fid);
			jobno = (1+jobno) % 0xfffff;	/* 2^20 jobs enough? */
			(void)fprintf(fid, "%05x\n", jobno);
		} else
			jobno = EOF;
		(void)fclose(fid);
		return (jobno);
	} else if ((fid = fopen(_PATH_SEQFILE, "w")) != NULL) {
		(void)fprintf(fid, "%05x\n", jobno = 1);
		(void)fclose(fid);
		return (1);
	}
	return (EOF);
d214 1
a214 1
	 * any particular time is used.  Lock the file _PATH_LOCKFILE first
d220 4
a223 8
	if ((lockdes = open(_PATH_LOCKFILE, O_WRONLY | O_CREAT, S_IWUSR | S_IRUSR)) < 0)
		perr2("Cannot open lockfile ", _PATH_LOCKFILE);

	lock.l_type = F_WRLCK;
	lock.l_whence = SEEK_SET;
	lock.l_start = 0;
	lock.l_len = 0;

a226 5

	/*
	 * Set an alarm so a timeout occurs after ALARMC seconds, in case
	 * something is seriously broken.
	 */
d229 1
a229 1
	fcntl(lockdes, F_SETLKW, &lock);
d232 3
d236 1
a236 1
	    perr("Cannot generate job number");
d256 2
a257 1
	if ((fdes = open(atfile, O_CREAT | O_TRUNC | O_WRONLY, S_IRUSR)) == -1)
@


1.20
log
@remove stdio code from handler, and _exit() at termination
@
text
@d1 1
a1 1
/*	$OpenBSD: at.c,v 1.19 2000/04/23 16:32:07 millert Exp $	*/
d77 1
a77 1
static char rcsid[] = "$OpenBSD: at.c,v 1.19 2000/04/23 16:32:07 millert Exp $";
d99 5
a103 5
static void sigc	__P((int));
static void alarmc	__P((int));
static char *cwdname	__P((void));
static void writefile	__P((time_t, char));
static void list_jobs	__P((void));
@


1.19
log
@Fix thinko, check eqp for NULL, not ap; ath@@algonet.se
@
text
@d1 1
a1 1
/*	$OpenBSD: at.c,v 1.18 2000/01/21 04:22:54 millert Exp $	*/
d77 1
a77 1
static char rcsid[] = "$OpenBSD: at.c,v 1.18 2000/01/21 04:22:54 millert Exp $";
d118 1
a118 1
	exit(EXIT_FAILURE);
d125 2
d128 9
a136 1
	panic("File locking timed out");
@


1.18
log
@Deal with getcwd() returning NULL.
Problem noted by Oleg Safiullin <form@@vell.nsc.ru>
@
text
@d1 1
a1 1
/*	$OpenBSD: at.c,v 1.17 1999/12/15 05:33:06 deraadt Exp $	*/
d77 1
a77 1
static char rcsid[] = "$OpenBSD: at.c,v 1.17 1999/12/15 05:33:06 deraadt Exp $";
d319 1
a319 1
		if (ap == NULL)
@


1.17
log
@does not overflow
@
text
@d1 1
a1 1
/*	$OpenBSD: at.c,v 1.16 1998/07/09 20:40:58 mickey Exp $	*/
d77 1
a77 1
static char rcsid[] = "$OpenBSD: at.c,v 1.16 1998/07/09 20:40:58 mickey Exp $";
d283 2
a284 2
	 * Get the userid to mail to, first by trying getlogin(), which reads
	 * /etc/utmp, then from $LOGNAME or $USER, finally from getpwuid().
d364 2
d367 1
a367 1
	for (ap = cwdname(); *ap != '\0'; ap++) {
@


1.16
log
@user err/warn; some -Wall
@
text
@d1 1
a1 1
/*	$OpenBSD: at.c,v 1.15 1998/06/03 16:20:26 deraadt Exp $	*/
d77 1
a77 1
static char rcsid[] = "$OpenBSD: at.c,v 1.15 1998/06/03 16:20:26 deraadt Exp $";
d200 1
a200 1
	(void)strcpy(atfile, _PATH_ATJOBS);
@


1.15
log
@zero sigaction before use
@
text
@d1 1
a1 1
/*	$OpenBSD: at.c,v 1.14 1997/10/06 18:31:01 deraadt Exp $	*/
d51 1
d77 1
a77 1
static char rcsid[] = "$OpenBSD: at.c,v 1.14 1997/10/06 18:31:01 deraadt Exp $";
d84 1
a84 1
static send_mail = 0;
d511 3
a513 5
				if ((buf.st_uid != real_uid) && !(real_uid == 0)) {
					(void)fprintf(stderr,
					    "%s: Not owner\n", argv[i]);
					exit(EXIT_FAILURE);
				}
d545 2
a546 2
					(void)fprintf(stderr,
					    "Internal error, process_jobs = %d\n",
a547 1
					exit(EXIT_FAILURE);
d666 3
a668 5
	if (!check_permission()) {
		(void)fprintf(stderr, "You do not have permission to use %s.\n",
		    namep);
		exit(EXIT_FAILURE);
	}
@


1.14
log
@bail if permission problem; ms@@xy.org
@
text
@d1 1
a1 1
/*	$OpenBSD: at.c,v 1.13 1997/06/17 20:48:04 kstailey Exp $	*/
d76 1
a76 1
static char rcsid[] = "$OpenBSD: at.c,v 1.13 1997/06/17 20:48:04 kstailey Exp $";
d192 1
@


1.13
log
@(foo *)NULL -> NULL
@
text
@d1 1
a1 1
/*	$OpenBSD: at.c,v 1.12 1997/06/12 16:57:44 kstailey Exp $	*/
d76 1
a76 1
static char rcsid[] = "$OpenBSD: at.c,v 1.12 1997/06/12 16:57:44 kstailey Exp $";
d670 1
@


1.12
log
@The NULL macro yields a null pointer constant that is usable as an address
constant expression.
@
text
@d1 1
a1 1
/*	$OpenBSD: at.c,v 1.11 1997/03/03 03:34:34 millert Exp $	*/
d76 1
a76 1
static char rcsid[] = "$OpenBSD: at.c,v 1.11 1997/03/03 03:34:34 millert Exp $";
d295 1
a295 1
	if (atinput != (char *) NULL) {
@


1.11
log
@cleanup
@
text
@d1 1
a1 1
/*	$OpenBSD: at.c,v 1.10 1997/03/03 03:31:10 millert Exp $	*/
d76 1
a76 1
static char rcsid[] = "$OpenBSD: at.c,v 1.10 1997/03/03 03:31:10 millert Exp $";
d148 1
a148 1
	if ((fid = fopen(_PATH_SEQFILE, "r+")) != (FILE*)0) {
d157 1
a157 1
	} else if ((fid = fopen(_PATH_SEQFILE, "w")) != (FILE*)0) {
@


1.10
log
@Give usage message when atq used incorrectly.
@
text
@d1 1
a1 1
/*	$OpenBSD: at.c,v 1.9 1997/03/03 00:30:02 millert Exp $	*/
d76 1
a76 1
static char rcsid[] = "$OpenBSD: at.c,v 1.9 1997/03/03 00:30:02 millert Exp $";
a680 5
		if (optind == argc)
			usage();
		process_jobs(argc, argv, ATRM);
		break;

d684 1
a684 1
		process_jobs(argc, argv, CAT);
@


1.9
log
@Complain if invoked in a form that requires an argument and we didn't
get one.
@
text
@d1 1
a1 1
/*	$OpenBSD: at.c,v 1.8 1997/03/02 19:59:15 millert Exp $	*/
d76 1
a76 1
static char rcsid[] = "$OpenBSD: at.c,v 1.8 1997/03/02 19:59:15 millert Exp $";
a485 3
	if (optind == argc && (what == ATRM || what == CAT))
		usage();

d675 2
d681 2
d687 2
@


1.8
log
@Fix up the XXX's I left (oops).
@
text
@d1 1
a1 1
/*	$OpenBSD: at.c,v 1.7 1997/03/01 23:40:09 millert Exp $	*/
d76 1
a76 1
static char rcsid[] = "$OpenBSD: at.c,v 1.7 1997/03/01 23:40:09 millert Exp $";
d485 3
@


1.7
log
@Merge in changes from at 2.9
@
text
@d1 1
a1 1
/*	$OpenBSD: at.c,v 1.6 1997/01/15 23:42:12 millert Exp $	*/
d76 1
a76 1
static char rcsid[] = "$OpenBSD: at.c,v 1.6 1997/01/15 23:42:12 millert Exp $";
a141 1
/* XXX - this code sucks! */
d234 2
a235 2
	/* XXX - use snprintf */
	(void)sprintf(ppos, "%c%5x%8x", queue, jobno, (unsigned) (runtimer/60));
d252 1
a252 2
	/* XXX - use open(2) not creat() */
	if ((fdes = creat(atfile, O_WRONLY)) == -1)
@


1.6
log
@getopt(3) returns -1 when out of args, not EOF, whee!
@
text
@d1 1
a1 1
/*	$OpenBSD: at.c,v 1.5 1996/10/26 20:06:50 millert Exp $	*/
d5 2
a6 2
 * at.c : Put file into atrun queue
 * Copyright (C) 1993  Thomas Koenig
d8 2
a9 3
 * Atrun & Atq modifications
 * Copyright (C) 1993  David Parsons
 * All rights reserved.
d23 1
a23 1
 * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
a31 2
#define _USE_BSD 1

d34 1
d49 8
d62 1
a69 1
#define SIZE 255
d72 2
d76 1
a76 1
static char rcsid[] = "$OpenBSD: at.c,v 1.5 1996/10/26 20:06:50 millert Exp $";
d86 1
d92 1
a92 1
char *atinput = (char *) 0;	/* where to get input from */
d97 3
a99 2
static void sigc	__P((int signo));
static void alarmc	__P((int signo));
d101 1
a101 1
static void writefile	__P((time_t runtimer, char queue));
d110 1
a110 2
/* If the user presses ^C, remove the spool file and exit
 */
d113 1
a113 1
		unlink(atfile);
d124 1
a124 2
/* Time out after some seconds
 */
d133 5
a137 5
/* Read in the current directory; the name will be overwritten on
 * subsequent calls.
 */
	static char *ptr = NULL;
	static size_t size = SIZE;
d139 2
a140 2
	if (ptr == NULL)
		ptr = (char *) malloc(size);
d142 6
a147 6
	while (1) {
		if (ptr == NULL)
			panic("Out of memory");

		if (getcwd(ptr, size - 1) != NULL)
			return ptr;
d149 13
a161 6
		if (errno != ERANGE)
			perr("Cannot get directory");

		free(ptr);
		size += SIZE;
		ptr = (char *) malloc(size);
d163 1
d175 1
a175 1
	int i;
d187 2
d199 2
a200 2
	strcpy(atfile, _PATH_ATJOBS);
	ppos = atfile + strlen(_PATH_ATJOBS);
d204 3
a206 3
	 *  particular time, see if a file is there; the first empty slot at
	 *  any particular time is used.  Lock the file _PATH_LOCKFILE first
	 *  to make sure we're alone when doing this.
d211 1
a211 1
	if ((lockdes = open(_PATH_LOCKFILE, O_WRONLY | O_CREAT, 0600)) < 0)
d232 5
a236 11
	for (i = 0; i < AT_MAXJOBS; i++) {
		sprintf(ppos, "%c%08lx.%03x", queue,
		    (unsigned long) (runtimer / 60), i);

		if (stat(atfile, &statbuf) != 0) {
			if (errno == ENOENT)
				break;
			else
				perr2("Cannot access ", _PATH_ATJOBS);
		}
	}			/* for */
d238 7
a244 2
	if (i >= AT_MAXJOBS)
		panic("Too many jobs already");
d253 1
d260 1
a260 1
	if (fchown(fd2, real_uid, -1) != 0)
d276 2
a277 2
	fcntl(lockdes, F_SETLKW, &lock);
	close(lockdes);
d290 3
a292 3
	if ((mailname == NULL) || (mailname[0] == '\0')
	    || (strlen(mailname) > 8)) {
		pass_entry = getpwuid(getuid());
d302 2
a303 1
	fprintf(fp, "#! /bin/sh\n# mail %8s %d\n", mailname, send_mail);
d306 1
a306 1
	fprintf(fp, "umask %lo\n", (unsigned long) cmask);
d334 1
a334 1
			fwrite(*atenv, sizeof(char), eqp - *atenv, fp);
d337 1
a337 1
					fprintf(fp, "\"\n\"");
d339 14
a352 4
					if (!isalnum(*ap))
						fputc('\\', fp);

					fputc(*ap, fp);
d355 16
a370 3
			fputs("; export ", fp);
			fwrite(*atenv, sizeof(char), eqp - *atenv - 1, fp);
			fputc('\n', fp);
d372 1
d376 2
a377 2
	 * Cd to the directory at the time and write out all the commands
	 * the user supplies from stdin.
d379 1
a379 1
	fprintf(fp, "cd %s\n", cwdname());
d385 1
a385 1
		fputc(ch, fp);
d388 1
a388 1
	fprintf(fp, "\n");
d395 1
a395 1
	fclose(fp);
d403 2
a404 2
	close(fd2);
	fprintf(stderr, "Job %s will be executed using /bin/sh\n", ppos);
d421 1
d428 1
a428 1
	    if (chdir(_PATH_ATJOBS) != 0)
d448 1
a448 1
		if (sscanf(dirent->d_name, "%c%8lx", &queue, &ctm) != 2)
d458 1
a458 1
			printf("Date\t\t\tOwner\tQueue\tJob#\n");
d463 1
a463 1
		printf("%s\t%s\t%c%s\t%s\n",
d468 1
a468 1
		    dirent->d_name);
d474 1
a474 1
delete_jobs(argc, argv)
d477 1
d482 5
d490 1
a490 1
	    if (chdir(_PATH_ATJOBS) != 0)
d493 61
a553 6
	for (i = optind; i < argc; i++) {
		if (stat(argv[i], &buf) != 0)
			perr(argv[i]);
		if ((buf.st_uid != real_uid) && !(real_uid == 0)) {
			fprintf(stderr, "%s: Not owner\n", argv[i]);
			exit(EXIT_FAILURE);
a554 2
		if (unlink(argv[i]) != 0)
			perr(argv[i]);
a555 1
	PRIV_END
d566 2
a567 1
	char queue = 'a';
d571 5
a575 4
		ATQ, ATRM, AT, BATCH
	};			/* what program we want to run */
	int program = AT;	/* our default program */
	char *options = "q:f:mv";	/* default options for at */
d591 1
a591 1
		options = "q:v";
d594 1
a594 1
		options = "";
d597 1
a597 1
		options = "f:mv";
d621 1
a621 1
			if ((!islower(queue)) || (queue > 'l'))
d623 35
d666 8
d681 5
a685 1
		delete_jobs(argc, argv);
d692 1
a692 2

			fprintf(stderr, "%s\n", asctime(tm));
d698 16
a713 1
		writefile(time(NULL), 'b');
@


1.5
log
@Fall back to $USER if getlogin() fails and $LOGNAME is not set.
@
text
@d1 1
a1 1
/*	$OpenBSD: at.c,v 1.4 1996/10/15 23:22:35 millert Exp $	*/
d68 1
a68 1
static char rcsid[] = "$OpenBSD: at.c,v 1.4 1996/10/15 23:22:35 millert Exp $";
d498 1
a498 1
	while ((c = getopt(argc, argv, options)) != EOF)
@


1.4
log
@Make sprintf work for you, not the other way around.
@
text
@d1 1
a1 1
/*	$OpenBSD: at.c,v 1.3 1996/08/03 20:16:52 millert Exp $	*/
d68 1
a68 1
static char rcsid[] = "$OpenBSD: at.c,v 1.3 1996/08/03 20:16:52 millert Exp $";
d265 2
a266 2
	 * Get the userid to mail to, first by trying getlogin(), which
	 * reads /etc/utmp, then from LOGNAME, finally from getpwuid().
d269 2
a270 2
	if (mailname == NULL)
		mailname = getenv("LOGNAME");
@


1.3
log
@Was runing most of the code with real and effective uid of 0, contrary
to the comments.  Fixed that and made sure unlink of job file is done
as root so it can succeed.  Also will now detect empty input.
@
text
@d1 1
a1 1
/*	$OpenBSD: at.c,v 1.2 1996/06/26 05:31:27 deraadt Exp $	*/
d68 1
a68 1
static char rcsid[] = "$OpenBSD: at.c,v 1.2 1996/06/26 05:31:27 deraadt Exp $";
d215 1
a215 1
		sprintf(ppos, "%c%8lx.%3x", queue,
a216 3
		for (ap = ppos; *ap != '\0'; ap++)
			if (*ap == ' ')
				*ap = '0';
@


1.2
log
@rcsid
@
text
@d1 1
a1 1
/*	$OpenBSD: at.c,v 1.4 1995/03/25 18:13:31 glass Exp $	*/
d68 1
a68 1
static char rcsid[] = "$OpenBSD: at.c,v 1.4 1995/03/25 18:13:31 glass Exp $";
a250 7
	 * We no longer need suid root; now we just need to be able to
	 * write to the directory, if necessary.
	 */

	    REDUCE_PRIV(effective_uid);

	/*
d341 4
a344 1
	while ((ch = getchar()) != EOF)
d346 1
@


1.1
log
@Initial revision
@
text
@d1 1
d68 1
a68 1
static char rcsid[] = "$NetBSD: at.c,v 1.4 1995/03/25 18:13:31 glass Exp $";
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@
