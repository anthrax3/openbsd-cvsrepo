head	1.52;
access;
symbols
	OPENBSD_6_2:1.52.0.6
	OPENBSD_6_2_BASE:1.52
	OPENBSD_6_1:1.52.0.4
	OPENBSD_6_1_BASE:1.52
	OPENBSD_6_0:1.51.0.2
	OPENBSD_6_0_BASE:1.51
	OPENBSD_5_9:1.47.0.2
	OPENBSD_5_9_BASE:1.47
	OPENBSD_5_8:1.46.0.6
	OPENBSD_5_8_BASE:1.46
	OPENBSD_5_7:1.46.0.2
	OPENBSD_5_7_BASE:1.46
	OPENBSD_5_6:1.41.0.6
	OPENBSD_5_6_BASE:1.41
	OPENBSD_5_5:1.41.0.4
	OPENBSD_5_5_BASE:1.41
	OPENBSD_5_4:1.38.0.2
	OPENBSD_5_4_BASE:1.38
	OPENBSD_5_3:1.37.0.2
	OPENBSD_5_3_BASE:1.37
	OPENBSD_5_2:1.36.0.2
	OPENBSD_5_2_BASE:1.36
	OPENBSD_5_1_BASE:1.32
	OPENBSD_5_1:1.32.0.2
	OPENBSD_5_0:1.22.0.2
	OPENBSD_5_0_BASE:1.22
	OPENBSD_4_9:1.19.0.2
	OPENBSD_4_9_BASE:1.19
	OPENBSD_4_8:1.17.0.2
	OPENBSD_4_8_BASE:1.17
	OPENBSD_4_7:1.16.0.2
	OPENBSD_4_7_BASE:1.16
	OPENBSD_4_6:1.8.0.6
	OPENBSD_4_6_BASE:1.8
	OPENBSD_4_5:1.8.0.2
	OPENBSD_4_5_BASE:1.8
	OPENBSD_4_4:1.6.0.2
	OPENBSD_4_4_BASE:1.6
	djm_20080509:1.1.1.1
	djm:1.1.1;
locks; strict;
comment	@ * @;


1.52
date	2016.09.19.18.58.39;	author bluhm;	state Exp;
branches;
next	1.51;
commitid	PZ5TWGF4tFDm7HZS;

1.51
date	2016.07.21.10.11.11;	author claudio;	state Exp;
branches;
next	1.50;
commitid	3t7BrHlxRXyQ7R8F;

1.50
date	2016.04.06.14.09.06;	author krw;	state Exp;
branches;
next	1.49;
commitid	y0HuzIP5EUY9ygFQ;

1.49
date	2016.03.28.11.48.38;	author chl;	state Exp;
branches;
next	1.48;
commitid	oDXSICoWTLnRE419;

1.48
date	2016.03.21.00.49.36;	author guenther;	state Exp;
branches;
next	1.47;
commitid	MSxcUg12B9iLaLLL;

1.47
date	2015.11.13.19.37.20;	author benno;	state Exp;
branches;
next	1.46;
commitid	V9AbNqYnBzVryyRf;

1.46
date	2015.02.09.23.46.23;	author deraadt;	state Exp;
branches;
next	1.45;
commitid	6cgRI1EPWQIJK3WC;

1.45
date	2014.11.26.18.34.51;	author millert;	state Exp;
branches;
next	1.44;
commitid	9QOFSShUOtA0kQLF;

1.44
date	2014.10.24.02.01.20;	author lteo;	state Exp;
branches;
next	1.43;
commitid	K0sGF4uE2LYJ8DMA;

1.43
date	2014.10.16.02.59.40;	author lteo;	state Exp;
branches;
next	1.42;
commitid	AqAJcIXWlVLb0P9l;

1.42
date	2014.08.19.03.28.53;	author dlg;	state Exp;
branches;
next	1.41;
commitid	SGI11URMmQGX99lo;

1.41
date	2013.12.25.01.46.00;	author tedu;	state Exp;
branches;
next	1.40;

1.40
date	2013.12.24.22.26.20;	author tedu;	state Exp;
branches;
next	1.39;

1.39
date	2013.12.20.02.04.09;	author krw;	state Exp;
branches;
next	1.38;

1.38
date	2013.03.11.17.40.11;	author deraadt;	state Exp;
branches;
next	1.37;

1.37
date	2012.10.02.08.50.15;	author haesbaert;	state Exp;
branches;
next	1.36;

1.36
date	2012.06.16.17.18.11;	author haesbaert;	state Exp;
branches;
next	1.35;

1.35
date	2012.05.08.01.39.58;	author haesbaert;	state Exp;
branches;
next	1.34;

1.34
date	2012.04.13.19.23.32;	author haesbaert;	state Exp;
branches;
next	1.33;

1.33
date	2012.04.07.21.52.03;	author haesbaert;	state Exp;
branches;
next	1.32;

1.32
date	2012.01.31.16.15.46;	author haesbaert;	state Exp;
branches;
next	1.31;

1.31
date	2012.01.29.17.58.10;	author haesbaert;	state Exp;
branches;
next	1.30;

1.30
date	2012.01.26.17.53.53;	author henning;	state Exp;
branches;
next	1.29;

1.29
date	2011.12.18.02.42.53;	author haesbaert;	state Exp;
branches;
next	1.28;

1.28
date	2011.12.04.06.37.51;	author haesbaert;	state Exp;
branches;
next	1.27;

1.27
date	2011.10.07.02.46.48;	author haesbaert;	state Exp;
branches;
next	1.26;

1.26
date	2011.10.01.06.23.53;	author haesbaert;	state Exp;
branches;
next	1.25;

1.25
date	2011.09.09.00.40.54;	author haesbaert;	state Exp;
branches;
next	1.24;

1.24
date	2011.08.23.04.13.38;	author haesbaert;	state Exp;
branches;
next	1.23;

1.23
date	2011.08.20.11.11.30;	author sthen;	state Exp;
branches;
next	1.22;

1.22
date	2011.06.21.17.31.07;	author mikeb;	state Exp;
branches;
next	1.21;

1.21
date	2011.03.16.08.06.10;	author jmc;	state Exp;
branches;
next	1.20;

1.20
date	2011.03.09.18.13.18;	author claudio;	state Exp;
branches;
next	1.19;

1.19
date	2010.10.19.10.03.23;	author claudio;	state Exp;
branches;
next	1.18;

1.18
date	2010.09.28.12.00.35;	author claudio;	state Exp;
branches;
next	1.17;

1.17
date	2010.07.03.04.44.51;	author guenther;	state Exp;
branches;
next	1.16;

1.16
date	2009.12.11.17.20.50;	author deraadt;	state Exp;
branches;
next	1.15;

1.15
date	2009.09.11.20.53.36;	author sthen;	state Exp;
branches;
next	1.14;

1.14
date	2009.09.08.12.53.52;	author claudio;	state Exp;
branches;
next	1.13;

1.13
date	2009.09.08.11.43.51;	author claudio;	state Exp;
branches;
next	1.12;

1.12
date	2009.08.29.04.10.49;	author deraadt;	state Exp;
branches;
next	1.11;

1.11
date	2009.08.28.11.59.12;	author claudio;	state Exp;
branches;
next	1.10;

1.10
date	2009.08.13.14.26.38;	author claudio;	state Exp;
branches;
next	1.9;

1.9
date	2009.08.13.14.19.43;	author claudio;	state Exp;
branches;
next	1.8;

1.8
date	2008.09.18.10.23.33;	author chl;	state Exp;
branches;
next	1.7;

1.7
date	2008.08.14.22.29.43;	author henning;	state Exp;
branches;
next	1.6;

1.6
date	2008.06.26.07.05.56;	author jmc;	state Exp;
branches;
next	1.5;

1.5
date	2008.06.15.01.38.26;	author henning;	state Exp;
branches;
next	1.4;

1.4
date	2008.06.12.20.34.47;	author henning;	state Exp;
branches;
next	1.3;

1.3
date	2008.05.15.19.00.02;	author djm;	state Exp;
branches;
next	1.2;

1.2
date	2008.05.09.06.45.49;	author djm;	state Exp;
branches;
next	1.1;

1.1
date	2008.05.09.00.54.07;	author djm;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2008.05.09.00.54.07;	author djm;	state Exp;
branches;
next	;


desc
@@


1.52
log
@Add OpenBSD RCS id.
@
text
@/*	$OpenBSD$	*/

/*
 * Copyright (c) 2008 Damien Miller <djm@@mindrot.org>
 * Copyright (c) 2011 Christiano F. Haesbaert <haesbaert@@haesbaert.org>
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */

#include <sys/types.h>
#include <sys/time.h>
#include <sys/socket.h>
#include <sys/socketvar.h>
#include <sys/resource.h>
#include <sys/queue.h>
#include <sys/un.h>

#include <net/route.h>

#include <netinet/in.h>
#include <netinet/ip.h>
#include <netinet/tcp.h>
#include <netinet/tcp_timer.h>
#include <netinet/tcp_fsm.h>
#include <netinet/in_pcb.h>
#include <netinet/tcp_var.h>

#include <arpa/inet.h>

#include <unistd.h>
#include <limits.h>
#include <stdlib.h>
#include <stdio.h>
#include <string.h>
#include <errno.h>
#include <event.h>
#include <netdb.h>
#include <signal.h>
#include <err.h>
#include <fcntl.h>
#include <poll.h>

#include <kvm.h>
#include <nlist.h>

#define DEFAULT_PORT "12345"
#define DEFAULT_STATS_INTERVAL 1000 /* ms */
#define DEFAULT_BUF (256 * 1024)
#define DEFAULT_UDP_PKT (1500 - 28) /* TODO don't hardcode this */
#define TCP_MODE !ptb->uflag
#define UDP_MODE ptb->uflag
#define MAX_FD 1024

/* Our tcpbench globals */
struct {
	int	  Sflag;	/* Socket buffer size (tcp mode) */
	u_int	  rflag;	/* Report rate (ms) */
	int	  sflag;	/* True if server */
	int	  Tflag;	/* ToS if != -1 */
	int	  vflag;	/* Verbose */
	int	  uflag;	/* UDP mode */
	int	  Uflag;	/* UNIX (AF_LOCAL) mode */
	int	  Rflag;	/* randomize client write size */
	kvm_t	 *kvmh;		/* Kvm handler */
	char	**kvars;	/* Kvm enabled vars */
	u_long	  ktcbtab;	/* Ktcb */
	char	 *dummybuf;	/* IO buffer */
	size_t	  dummybuf_len;	/* IO buffer len */
} tcpbench, *ptb;

struct tcpservsock {
	struct event ev;
	struct event evt;
	int fd;
};

/* stats for a single tcp connection, udp uses only one  */
struct statctx {
	TAILQ_ENTRY(statctx) entry;
	struct timeval t_start, t_last;
	unsigned long long bytes;
	int fd;
	char *buf;
	size_t buflen;
	struct event ev;
	/* TCP only */
	struct tcpservsock *tcp_ts;
	u_long tcp_tcbaddr;
	/* UDP only */
	u_long udp_slice_pkts;
};

static void	signal_handler(int, short, void *);
static void	saddr_ntop(const struct sockaddr *, socklen_t, char *, size_t);
static void	drop_gid(void);
static void	set_slice_timer(int);
static void 	print_tcp_header(void);
static void	kget(u_long, void *, size_t);
static u_long	kfind_tcb(int);
static void	kupdate_stats(u_long, struct inpcb *, struct tcpcb *,
    struct socket *);
static void	list_kvars(void);
static void	check_kvar(const char *);
static char **	check_prepare_kvars(char *);
static void	stats_prepare(struct statctx *);
static void	tcp_stats_display(unsigned long long, long double, float,
    struct statctx *, struct inpcb *, struct tcpcb *, struct socket *);
static void	tcp_process_slice(int, short, void *);
static void	tcp_server_handle_sc(int, short, void *);
static void	tcp_server_accept(int, short, void *);
static void	server_init(struct addrinfo *, struct statctx *);
static void	client_handle_sc(int, short, void *);
static void	client_init(struct addrinfo *, int, struct statctx *,
    struct addrinfo *);
static int	clock_gettime_tv(clockid_t, struct timeval *);
static void	udp_server_handle_sc(int, short, void *);
static void	udp_process_slice(int, short, void *);
static int	map_tos(char *, int *);
/*
 * We account the mainstats here, that is the stats
 * for all connections, all variables starting with slice
 * are used to account information for the timeslice
 * between each output. Peak variables record the highest
 * between all slices so far.
 */
static struct {
	unsigned long long slice_bytes; /* bytes for last slice */
	long double peak_mbps;		/* peak mbps so far */
	int nconns; 		        /* connected clients */
	struct event timer;		/* process timer */
} mainstats;

/* When adding variables, also add to tcp_stats_display() */
static const char *allowed_kvars[] = {
	"inpcb.inp_flags",
	"sockb.so_rcv.sb_cc",
	"sockb.so_rcv.sb_hiwat",
	"sockb.so_rcv.sb_wat",
	"sockb.so_snd.sb_cc",
	"sockb.so_snd.sb_hiwat",
	"sockb.so_snd.sb_wat",
	"tcpcb.last_ack_sent",
	"tcpcb.max_sndwnd",
	"tcpcb.rcv_adv",
	"tcpcb.rcv_nxt",
	"tcpcb.rcv_scale",
	"tcpcb.rcv_wnd",
	"tcpcb.rfbuf_cnt",
	"tcpcb.rfbuf_ts",
	"tcpcb.snd_cwnd",
	"tcpcb.snd_max",
	"tcpcb.snd_nxt",
	"tcpcb.snd_scale",
	"tcpcb.snd_ssthresh",
	"tcpcb.snd_una",
	"tcpcb.snd_wl1",
	"tcpcb.snd_wl2",
	"tcpcb.snd_wnd",
	"tcpcb.t_rcvtime",
	"tcpcb.t_rtseq",
	"tcpcb.t_rttmin",
	"tcpcb.t_rtttime",
	"tcpcb.t_rttvar",
	"tcpcb.t_srtt",
	"tcpcb.ts_recent",
	"tcpcb.ts_recent_age",
	NULL
};

TAILQ_HEAD(, statctx) sc_queue;

static void __dead
usage(void)
{
	fprintf(stderr,
	    "usage: tcpbench -l\n"
	    "       tcpbench [-46RUuv] [-B buf] [-b addr] [-k kvars] [-n connections]\n"
	    "                [-p port] [-r interval] [-S space] [-T toskeyword]\n"
	    "                [-t secs] [-V rtable] hostname\n"
	    "       tcpbench -s [-46Uuv] [-B buf] [-k kvars] [-p port] [-r interval]\n"
	    "                [-S space] [-T toskeyword] [-V rtable] [hostname]\n");
	exit(1);
}

static void
signal_handler(int sig, short event, void *bula)
{
	/*
	 * signal handler rules don't apply, libevent decouples for us
	 */
	switch (sig) {
	case SIGINT:
	case SIGTERM:
	case SIGHUP:
		warnx("Terminated by signal %d", sig);
		exit(0);
		break;		/* NOTREACHED */
	default:
		errx(1, "unexpected signal %d", sig);
		break;		/* NOTREACHED */
	}
}

static void
saddr_ntop(const struct sockaddr *addr, socklen_t alen, char *buf, size_t len)
{
	char hbuf[NI_MAXHOST], pbuf[NI_MAXSERV];
	int herr;

	if (addr->sa_family == AF_UNIX) {
		struct sockaddr_un *sun = (struct sockaddr_un *)addr;
		snprintf(buf, len, "%s", sun->sun_path);
		return;
	}
	if ((herr = getnameinfo(addr, alen, hbuf, sizeof(hbuf),
	    pbuf, sizeof(pbuf), NI_NUMERICHOST|NI_NUMERICSERV)) != 0) {
		if (herr == EAI_SYSTEM)
			err(1, "getnameinfo");
		else
			errx(1, "getnameinfo: %s", gai_strerror(herr));
	}
	snprintf(buf, len, "[%s]:%s", hbuf, pbuf);
}

static void
drop_gid(void)
{
	gid_t gid;

	gid = getgid();
	if (setresgid(gid, gid, gid) == -1)
		err(1, "setresgid");
}

static void
set_slice_timer(int on)
{
	struct timeval tv;

	if (ptb->rflag == 0)
		return;

	if (on) {
		if (evtimer_pending(&mainstats.timer, NULL))
			return;
		timerclear(&tv);
		/* XXX Is there a better way to do this ? */
		tv.tv_sec = ptb->rflag / 1000;
		tv.tv_usec = (ptb->rflag % 1000) * 1000;
		
		evtimer_add(&mainstats.timer, &tv);
	} else if (evtimer_pending(&mainstats.timer, NULL))
		evtimer_del(&mainstats.timer);
}
		
static int
clock_gettime_tv(clockid_t clock_id, struct timeval *tv)
{
	struct timespec ts;

	if (clock_gettime(clock_id, &ts) == -1)
		return (-1);
	
	TIMESPEC_TO_TIMEVAL(tv, &ts);
	
	return (0);
}

static void
print_tcp_header(void)
{
	char **kv;

	printf("%12s %14s %12s %8s ", "elapsed_ms", "bytes", "mbps",
	    "bwidth");
	for (kv = ptb->kvars;  ptb->kvars != NULL && *kv != NULL; kv++) 
		printf("%s%s", kv != ptb->kvars ? "," : "", *kv);
	printf("\n");
}

static void
kget(u_long addr, void *buf, size_t size)
{
	if (kvm_read(ptb->kvmh, addr, buf, size) != (ssize_t)size)
		errx(1, "kvm_read: %s", kvm_geterr(ptb->kvmh));
}

static u_long
kfind_tcb(int sock)
{
	struct inpcbtable tcbtab;
	struct inpcb *next, *prev;
	struct inpcb inpcb, prevpcb;
	struct tcpcb tcpcb;

	struct sockaddr_storage me, them;
	socklen_t melen, themlen;
	struct sockaddr_in *in4;
	struct sockaddr_in6 *in6;
	char tmp1[64], tmp2[64];
	int nretry;

	nretry = 10;
	melen = themlen = sizeof(struct sockaddr_storage);
	if (getsockname(sock, (struct sockaddr *)&me, &melen) == -1)
		err(1, "getsockname");
	if (getpeername(sock, (struct sockaddr *)&them, &themlen) == -1)
		err(1, "getpeername");
	if (me.ss_family != them.ss_family)
		errx(1, "%s: me.ss_family != them.ss_family", __func__);
	if (me.ss_family != AF_INET && me.ss_family != AF_INET6)
		errx(1, "%s: unknown socket family", __func__);
	if (ptb->vflag >= 2) {
		saddr_ntop((struct sockaddr *)&me, me.ss_len,
		    tmp1, sizeof(tmp1));
		saddr_ntop((struct sockaddr *)&them, them.ss_len,
		    tmp2, sizeof(tmp2));
		fprintf(stderr, "Our socket local %s remote %s\n", tmp1, tmp2);
	}
	if (ptb->vflag >= 2)
		fprintf(stderr, "Using PCB table at %lu\n", ptb->ktcbtab);
retry:
	kget(ptb->ktcbtab, &tcbtab, sizeof(tcbtab));
	prev = NULL;
	next = TAILQ_FIRST(&tcbtab.inpt_queue);

	if (ptb->vflag >= 2)
		fprintf(stderr, "PCB start at %p\n", next);
	while (next != NULL) {
		if (ptb->vflag >= 2)
			fprintf(stderr, "Checking PCB %p\n", next);
		kget((u_long)next, &inpcb, sizeof(inpcb));
		if (prev != NULL) {
			kget((u_long)prev, &prevpcb, sizeof(prevpcb));
			if (TAILQ_NEXT(&prevpcb, inp_queue) != next) {
				if (nretry--) {
					warnx("PCB prev pointer insane");
					goto retry;
				} else
					errx(1, "PCB prev pointer insane,"
					    " all attempts exhaused");
			}
		}
		prev = next;
		next = TAILQ_NEXT(&inpcb, inp_queue);

		if (me.ss_family == AF_INET) {
			if ((inpcb.inp_flags & INP_IPV6) != 0) {
				if (ptb->vflag >= 2)
					fprintf(stderr, "Skip: INP_IPV6");
				continue;
			}
			if (ptb->vflag >= 2) {
				inet_ntop(AF_INET, &inpcb.inp_laddr,
				    tmp1, sizeof(tmp1));
				inet_ntop(AF_INET, &inpcb.inp_faddr,
				    tmp2, sizeof(tmp2));
				fprintf(stderr, "PCB %p local: [%s]:%d "
				    "remote: [%s]:%d\n", prev,
				    tmp1, inpcb.inp_lport,
				    tmp2, inpcb.inp_fport);
			}
			in4 = (struct sockaddr_in *)&me;
			if (memcmp(&in4->sin_addr, &inpcb.inp_laddr,
			    sizeof(struct in_addr)) != 0 ||
			    in4->sin_port != inpcb.inp_lport)
				continue;
			in4 = (struct sockaddr_in *)&them;
			if (memcmp(&in4->sin_addr, &inpcb.inp_faddr,
			    sizeof(struct in_addr)) != 0 ||
			    in4->sin_port != inpcb.inp_fport)
				continue;
		} else {
			if ((inpcb.inp_flags & INP_IPV6) == 0)
				continue;
			if (ptb->vflag >= 2) {
				inet_ntop(AF_INET6, &inpcb.inp_laddr6,
				    tmp1, sizeof(tmp1));
				inet_ntop(AF_INET6, &inpcb.inp_faddr6,
				    tmp2, sizeof(tmp2));
				fprintf(stderr, "PCB %p local: [%s]:%d "
				    "remote: [%s]:%d\n", prev,
				    tmp1, inpcb.inp_lport,
				    tmp2, inpcb.inp_fport);
			}
			in6 = (struct sockaddr_in6 *)&me;
			if (memcmp(&in6->sin6_addr, &inpcb.inp_laddr6,
			    sizeof(struct in6_addr)) != 0 ||
			    in6->sin6_port != inpcb.inp_lport)
				continue;
			in6 = (struct sockaddr_in6 *)&them;
			if (memcmp(&in6->sin6_addr, &inpcb.inp_faddr6,
			    sizeof(struct in6_addr)) != 0 ||
			    in6->sin6_port != inpcb.inp_fport)
				continue;
		}
		kget((u_long)inpcb.inp_ppcb, &tcpcb, sizeof(tcpcb));
		if (tcpcb.t_state != TCPS_ESTABLISHED) {
			if (ptb->vflag >= 2)
				fprintf(stderr, "Not established\n");
			continue;
		}
		if (ptb->vflag >= 2)
			fprintf(stderr, "Found PCB at %p\n", prev);
		return ((u_long)prev);
	}

	errx(1, "No matching PCB found");
}

static void
kupdate_stats(u_long tcbaddr, struct inpcb *inpcb,
    struct tcpcb *tcpcb, struct socket *sockb)
{
	kget(tcbaddr, inpcb, sizeof(*inpcb));
	kget((u_long)inpcb->inp_ppcb, tcpcb, sizeof(*tcpcb));
	kget((u_long)inpcb->inp_socket, sockb, sizeof(*sockb));
}

static void
check_kvar(const char *var)
{
	u_int i;

	for (i = 0; allowed_kvars[i] != NULL; i++)
		if (strcmp(allowed_kvars[i], var) == 0)
			return;
	errx(1, "Unrecognised kvar: %s", var);
}

static void
list_kvars(void)
{
	u_int i;

	printf("Supported kernel variables:\n");
	for (i = 0; allowed_kvars[i] != NULL; i++)
		printf("\t%s\n", allowed_kvars[i]);
}

static char **
check_prepare_kvars(char *list)
{
	char *item, **ret = NULL;
	u_int n = 0;

	while ((item = strsep(&list, ", \t\n")) != NULL) {
		check_kvar(item);
		if ((ret = reallocarray(ret, (++n + 1), sizeof(*ret))) == NULL)
			errx(1, "reallocarray(kvars)");
		if ((ret[n - 1] = strdup(item)) == NULL)
			errx(1, "strdup");
		ret[n] = NULL;
	}
	return (ret);
}

static void
stats_prepare(struct statctx *sc)
{
	sc->buf = ptb->dummybuf;
	sc->buflen = ptb->dummybuf_len;

	if (ptb->kvars)
		sc->tcp_tcbaddr = kfind_tcb(sc->fd);
	if (clock_gettime_tv(CLOCK_MONOTONIC, &sc->t_start) == -1)
		err(1, "clock_gettime_tv");
	sc->t_last = sc->t_start;

}

static void
tcp_stats_display(unsigned long long total_elapsed, long double mbps,
    float bwperc, struct statctx *sc, struct inpcb *inpcb,
    struct tcpcb *tcpcb, struct socket *sockb)
{
	int j;
	
	printf("%12llu %14llu %12.3Lf %7.2f%% ", total_elapsed, sc->bytes,
	    mbps, bwperc);
	
	if (ptb->kvars != NULL) {
		kupdate_stats(sc->tcp_tcbaddr, inpcb, tcpcb,
		    sockb);

		for (j = 0; ptb->kvars[j] != NULL; j++) {
#define S(a) #a
#define P(b, v, f)							\
			if (strcmp(ptb->kvars[j], S(b.v)) == 0) {	\
				printf("%s"f, j > 0 ? "," : "", b->v);	\
				continue;				\
			}
			P(inpcb, inp_flags, "0x%08x")
			P(sockb, so_rcv.sb_cc, "%lu")
			P(sockb, so_rcv.sb_hiwat, "%lu")
			P(sockb, so_rcv.sb_wat, "%lu")
			P(sockb, so_snd.sb_cc, "%lu")
			P(sockb, so_snd.sb_hiwat, "%lu")
			P(sockb, so_snd.sb_wat, "%lu")
			P(tcpcb, last_ack_sent, "%u")
			P(tcpcb, max_sndwnd, "%lu")
			P(tcpcb, rcv_adv, "%u")
			P(tcpcb, rcv_nxt, "%u")
			P(tcpcb, rcv_scale, "%u")
			P(tcpcb, rcv_wnd, "%lu")
			P(tcpcb, rfbuf_cnt, "%u")
			P(tcpcb, rfbuf_ts, "%u")
			P(tcpcb, snd_cwnd, "%lu")
			P(tcpcb, snd_max, "%u")
			P(tcpcb, snd_nxt, "%u")
			P(tcpcb, snd_scale, "%u")
			P(tcpcb, snd_ssthresh, "%lu")
			P(tcpcb, snd_una, "%u")
			P(tcpcb, snd_wl1, "%u")
			P(tcpcb, snd_wl2, "%u")
			P(tcpcb, snd_wnd, "%lu")
			P(tcpcb, t_rcvtime, "%u")
			P(tcpcb, t_rtseq, "%u")
			P(tcpcb, t_rttmin, "%hu")
			P(tcpcb, t_rtttime, "%u")
			P(tcpcb, t_rttvar, "%hu")
			P(tcpcb, t_srtt, "%hu")
			P(tcpcb, ts_recent, "%u")
			P(tcpcb, ts_recent_age, "%u")
#undef S			    
#undef P
		}
	}
	printf("\n");
}

static void
tcp_process_slice(int fd, short event, void *bula)
{
	unsigned long long total_elapsed, since_last;
	long double mbps, slice_mbps = 0;
	float bwperc;
	struct statctx *sc;
	struct timeval t_cur, t_diff;
	struct inpcb inpcb;
	struct tcpcb tcpcb;
	struct socket sockb;
	
	TAILQ_FOREACH(sc, &sc_queue, entry) {
		if (clock_gettime_tv(CLOCK_MONOTONIC, &t_cur) == -1)
			err(1, "clock_gettime_tv");
		if (ptb->kvars != NULL) /* process kernel stats */
			kupdate_stats(sc->tcp_tcbaddr, &inpcb, &tcpcb,
			    &sockb);
		
		timersub(&t_cur, &sc->t_start, &t_diff);
		total_elapsed = t_diff.tv_sec * 1000 + t_diff.tv_usec / 1000;
		timersub(&t_cur, &sc->t_last, &t_diff);
		since_last = t_diff.tv_sec * 1000 + t_diff.tv_usec / 1000;
		bwperc = (sc->bytes * 100.0) / mainstats.slice_bytes;
		mbps = (sc->bytes * 8) / (since_last * 1000.0);
		slice_mbps += mbps;
		
		tcp_stats_display(total_elapsed, mbps, bwperc, sc,
		    &inpcb, &tcpcb, &sockb);
		
		sc->t_last = t_cur;
		sc->bytes = 0;
	}

	/* process stats for this slice */
	if (slice_mbps > mainstats.peak_mbps)
		mainstats.peak_mbps = slice_mbps;
	printf("Conn: %3d Mbps: %12.3Lf Peak Mbps: %12.3Lf Avg Mbps: %12.3Lf\n",
	    mainstats.nconns, slice_mbps, mainstats.peak_mbps,
	    mainstats.nconns ? slice_mbps / mainstats.nconns : 0); 
	mainstats.slice_bytes = 0;

	set_slice_timer(mainstats.nconns > 0);
}

static void
udp_process_slice(int fd, short event, void *v_sc)
{
	struct statctx *sc = v_sc;
	unsigned long long total_elapsed, since_last, pps;
	long double slice_mbps;
	struct timeval t_cur, t_diff;

	if (clock_gettime_tv(CLOCK_MONOTONIC, &t_cur) == -1)
		err(1, "clock_gettime_tv");
	/* Calculate pps */
	timersub(&t_cur, &sc->t_start, &t_diff);
	total_elapsed = t_diff.tv_sec * 1000 + t_diff.tv_usec / 1000;
	timersub(&t_cur, &sc->t_last, &t_diff);
	since_last = t_diff.tv_sec * 1000 + t_diff.tv_usec / 1000;
	slice_mbps = (sc->bytes * 8) / (since_last * 1000.0);
	pps = (sc->udp_slice_pkts * 1000) / since_last;
	if (slice_mbps > mainstats.peak_mbps)
		mainstats.peak_mbps = slice_mbps;
	printf("Elapsed: %11llu Mbps: %11.3Lf Peak Mbps: %11.3Lf %s PPS: %7llu\n",
	    total_elapsed, slice_mbps, mainstats.peak_mbps,
	    ptb->sflag ? "Rx" : "Tx", pps);

	/* Clean up this slice time */
	sc->t_last = t_cur;
	sc->bytes = 0;
	sc->udp_slice_pkts = 0;
	set_slice_timer(1);
}

static void
udp_server_handle_sc(int fd, short event, void *v_sc)
{
	ssize_t n;
	struct statctx *sc = v_sc;

	n = read(fd, ptb->dummybuf, ptb->dummybuf_len);
	if (n == 0)
		return;
	else if (n == -1) {
		if (errno != EINTR && errno != EWOULDBLOCK)
			warn("fd %d read error", fd);
		return;
	}
		
	if (ptb->vflag >= 3)
		fprintf(stderr, "read: %zd bytes\n", n);
	/* If this was our first packet, start slice timer */
	if (mainstats.peak_mbps == 0)
		set_slice_timer(1);
	/* Account packet */
	sc->udp_slice_pkts++;
	sc->bytes += n;
}

static void
tcp_server_handle_sc(int fd, short event, void *v_sc)
{
	struct statctx *sc = v_sc;
	ssize_t n;

	n = read(sc->fd, sc->buf, sc->buflen);
	if (n == -1) {
		if (errno != EINTR && errno != EWOULDBLOCK)
			warn("fd %d read error", sc->fd);
		return;
	} else if (n == 0) {
		if (ptb->vflag)
			fprintf(stderr, "%8d closed by remote end\n", sc->fd);

		TAILQ_REMOVE(&sc_queue, sc, entry);

		event_del(&sc->ev);
		close(sc->fd);

		/* Some file descriptors are available again. */
		if (evtimer_pending(&sc->tcp_ts->evt, NULL)) {
			evtimer_del(&sc->tcp_ts->evt);
			event_add(&sc->tcp_ts->ev, NULL);
		}

		free(sc);
		mainstats.nconns--;
		return;
	}
	if (ptb->vflag >= 3)
		fprintf(stderr, "read: %zd bytes\n", n);
	sc->bytes += n;
	mainstats.slice_bytes += n;
}
	
static void
tcp_server_accept(int fd, short event, void *arg)
{
	struct tcpservsock *ts = arg;
	int sock;
	struct statctx *sc;
	struct sockaddr_storage ss;
	socklen_t sslen;
	char tmp[128];
	
	sslen = sizeof(ss);

	event_add(&ts->ev, NULL);
	if (event & EV_TIMEOUT)
		return;
	if ((sock = accept4(fd, (struct sockaddr *)&ss, &sslen, SOCK_NONBLOCK))
	    == -1) {
		/*
		 * Pause accept if we are out of file descriptors, or
		 * libevent will haunt us here too.
		 */
		if (errno == ENFILE || errno == EMFILE) {
			struct timeval evtpause = { 1, 0 };

			event_del(&ts->ev);
			evtimer_add(&ts->evt, &evtpause);
		} else if (errno != EWOULDBLOCK && errno != EINTR &&
		    errno != ECONNABORTED)
			warn("accept");
		return;
	}
	saddr_ntop((struct sockaddr *)&ss, sslen,
	    tmp, sizeof(tmp));
	if (ptb->Tflag != -1 && ss.ss_family == AF_INET) {
		if (setsockopt(sock, IPPROTO_IP, IP_TOS,
		    &ptb->Tflag, sizeof(ptb->Tflag)))
			err(1, "setsockopt IP_TOS");
	}
	if (ptb->Tflag != -1 && ss.ss_family == AF_INET6) {
		if (setsockopt(sock, IPPROTO_IPV6, IPV6_TCLASS,
		    &ptb->Tflag, sizeof(ptb->Tflag)))
			err(1, "setsockopt IPV6_TCLASS");
	}
	/* Alloc client structure and register reading callback */
	if ((sc = calloc(1, sizeof(*sc))) == NULL)
		err(1, "calloc");
	sc->tcp_ts = ts;
	sc->fd = sock;
	stats_prepare(sc);
	event_set(&sc->ev, sc->fd, EV_READ | EV_PERSIST,
	    tcp_server_handle_sc, sc);
	event_add(&sc->ev, NULL);
	TAILQ_INSERT_TAIL(&sc_queue, sc, entry);
	mainstats.nconns++;
	if (mainstats.nconns == 1)
		set_slice_timer(1);
	if (ptb->vflag)
		fprintf(stderr, "Accepted connection from %s, fd = %d\n",
		    tmp, sc->fd);
}

static void
server_init(struct addrinfo *aitop, struct statctx *udp_sc)
{
	char tmp[128];
	int sock, on = 1;
	struct addrinfo *ai;
	struct event *ev;
	struct tcpservsock *ts;
	nfds_t lnfds;

	lnfds = 0;
	for (ai = aitop; ai != NULL; ai = ai->ai_next) {
		saddr_ntop(ai->ai_addr, ai->ai_addrlen, tmp, sizeof(tmp));
		if (ptb->vflag)
			fprintf(stderr, "Try to bind to %s\n", tmp);
		if ((sock = socket(ai->ai_family, ai->ai_socktype,
		    ai->ai_protocol)) == -1) {
			if (ai->ai_next == NULL)
				err(1, "socket");
			if (ptb->vflag)
				warn("socket");
			continue;
		}
		if (ptb->Tflag != -1 && ai->ai_family == AF_INET) {
			if (setsockopt(sock, IPPROTO_IP, IP_TOS,
			    &ptb->Tflag, sizeof(ptb->Tflag)))
				err(1, "setsockopt IP_TOS");
		}
		if (ptb->Tflag != -1 && ai->ai_family == AF_INET6) {
			if (setsockopt(sock, IPPROTO_IPV6, IPV6_TCLASS,
			    &ptb->Tflag, sizeof(ptb->Tflag)))
				err(1, "setsockopt IPV6_TCLASS");
		}
		if (setsockopt(sock, SOL_SOCKET, SO_REUSEADDR,
		    &on, sizeof(on)) == -1)
			warn("reuse port");
		if (bind(sock, ai->ai_addr, ai->ai_addrlen) != 0) {
			if (ai->ai_next == NULL)
				err(1, "bind");
			if (ptb->vflag)
				warn("bind");
			close(sock);
			continue;
		}
		if (ptb->Sflag) {
			if (setsockopt(sock, SOL_SOCKET, SO_RCVBUF,
			    &ptb->Sflag, sizeof(ptb->Sflag)) == -1)
				warn("set receive buffer size");
		}
		if (TCP_MODE) {
			if (listen(sock, 64) == -1) {
				if (ai->ai_next == NULL)
					err(1, "listen");
				if (ptb->vflag)
					warn("listen");
				close(sock);
				continue;
			}
		}
		if (UDP_MODE) {
			if ((ev = calloc(1, sizeof(*ev))) == NULL)
				err(1, "calloc");
			event_set(ev, sock, EV_READ | EV_PERSIST,
			    udp_server_handle_sc, udp_sc);
			event_add(ev, NULL);
		} else {
			if ((ts = calloc(1, sizeof(*ts))) == NULL)
				err(1, "calloc");

			ts->fd = sock;
			evtimer_set(&ts->evt, tcp_server_accept, ts);
			event_set(&ts->ev, ts->fd, EV_READ,
			    tcp_server_accept, ts);
			event_add(&ts->ev, NULL);
		}
		if (ptb->vflag >= 3)
			fprintf(stderr, "bound to fd %d\n", sock);
		lnfds++;
	}
	if (!ptb->Uflag)
		freeaddrinfo(aitop);
	if (lnfds == 0)
		errx(1, "No working listen addresses found");
}	

static void
client_handle_sc(int fd, short event, void *v_sc)
{
	struct statctx *sc = v_sc;
	ssize_t n;
	size_t blen = sc->buflen;

	if (ptb->Rflag)
		blen = arc4random_uniform(blen) + 1;
	if ((n = write(sc->fd, sc->buf, blen)) == -1) {
		if (errno == EINTR || errno == EWOULDBLOCK ||
		    (UDP_MODE && errno == ENOBUFS))
			return;
		err(1, "write");
	}
	if (TCP_MODE && n == 0) {	
		fprintf(stderr, "Remote end closed connection");
		exit(1);
	}
	if (ptb->vflag >= 3)
		fprintf(stderr, "write: %zd bytes\n", n);
	sc->bytes += n;
	mainstats.slice_bytes += n;
	if (UDP_MODE)
		sc->udp_slice_pkts++;
}

static void
client_init(struct addrinfo *aitop, int nconn, struct statctx *udp_sc,
    struct addrinfo *aib)
{
	struct statctx *sc;
	struct addrinfo *ai;
	char tmp[128];
	int i, r, sock;

	sc = udp_sc;
	for (i = 0; i < nconn; i++) {
		for (sock = -1, ai = aitop; ai != NULL; ai = ai->ai_next) {
			saddr_ntop(ai->ai_addr, ai->ai_addrlen, tmp,
			    sizeof(tmp));
			if (ptb->vflag && i == 0)
				fprintf(stderr, "Trying %s\n", tmp);
			if ((sock = socket(ai->ai_family, ai->ai_socktype,
			    ai->ai_protocol)) == -1) {
				if (ai->ai_next == NULL)
					err(1, "socket");
				if (ptb->vflag)
					warn("socket");
				continue;
			}
			if (aib != NULL) {
				saddr_ntop(aib->ai_addr, aib->ai_addrlen,
				    tmp, sizeof(tmp));
				if (ptb->vflag)
					fprintf(stderr,
					    "Try to bind to %s\n", tmp);
				if (bind(sock, (struct sockaddr *)aib->ai_addr,
				    aib->ai_addrlen) == -1)
					err(1, "bind");
			}
			if (ptb->Tflag != -1 && ai->ai_family == AF_INET) {
				if (setsockopt(sock, IPPROTO_IP, IP_TOS,
				    &ptb->Tflag, sizeof(ptb->Tflag)))
					err(1, "setsockopt IP_TOS");
			}
			if (ptb->Tflag != -1 && ai->ai_family == AF_INET6) {
				if (setsockopt(sock, IPPROTO_IPV6, IPV6_TCLASS,
				    &ptb->Tflag, sizeof(ptb->Tflag)))
					err(1, "setsockopt IPV6_TCLASS");
			}
			if (ptb->Sflag) {
				if (setsockopt(sock, SOL_SOCKET, SO_SNDBUF,
				    &ptb->Sflag, sizeof(ptb->Sflag)) == -1)
					warn("set TCP send buffer size");
			}
			if (connect(sock, ai->ai_addr, ai->ai_addrlen) != 0) {
				if (ai->ai_next == NULL)
					err(1, "connect");
				if (ptb->vflag)
					warn("connect");
				close(sock);
				sock = -1;
				continue;
			}
			break;
		}
		if (sock == -1)
			errx(1, "No host found");
		if ((r = fcntl(sock, F_GETFL)) == -1)
			err(1, "fcntl(F_GETFL)");
		r |= O_NONBLOCK;
		if (fcntl(sock, F_SETFL, r) == -1)
			err(1, "fcntl(F_SETFL, O_NONBLOCK)");
		/* Alloc and prepare stats */
		if (TCP_MODE) {
			if ((sc = calloc(1, sizeof(*sc))) == NULL)
				err(1, "calloc");
		}
		sc->fd = sock;
		stats_prepare(sc);
		event_set(&sc->ev, sc->fd, EV_WRITE | EV_PERSIST,
		    client_handle_sc, sc);
		event_add(&sc->ev, NULL);
		TAILQ_INSERT_TAIL(&sc_queue, sc, entry);
		mainstats.nconns++;
		if (mainstats.nconns == 1)
			set_slice_timer(1);
	}
	if (!ptb->Uflag)
		freeaddrinfo(aitop);
	if (aib != NULL)
		freeaddrinfo(aib);

	if (ptb->vflag && nconn > 1)
		fprintf(stderr, "%d connections established\n",
		    mainstats.nconns);
}

static int
map_tos(char *s, int *val)
{
	/* DiffServ Codepoints and other TOS mappings */
	const struct toskeywords {
		const char	*keyword;
		int		 val;
	} *t, toskeywords[] = {
		{ "af11",		IPTOS_DSCP_AF11 },
		{ "af12",		IPTOS_DSCP_AF12 },
		{ "af13",		IPTOS_DSCP_AF13 },
		{ "af21",		IPTOS_DSCP_AF21 },
		{ "af22",		IPTOS_DSCP_AF22 },
		{ "af23",		IPTOS_DSCP_AF23 },
		{ "af31",		IPTOS_DSCP_AF31 },
		{ "af32",		IPTOS_DSCP_AF32 },
		{ "af33",		IPTOS_DSCP_AF33 },
		{ "af41",		IPTOS_DSCP_AF41 },
		{ "af42",		IPTOS_DSCP_AF42 },
		{ "af43",		IPTOS_DSCP_AF43 },
		{ "critical",		IPTOS_PREC_CRITIC_ECP },
		{ "cs0",		IPTOS_DSCP_CS0 },
		{ "cs1",		IPTOS_DSCP_CS1 },
		{ "cs2",		IPTOS_DSCP_CS2 },
		{ "cs3",		IPTOS_DSCP_CS3 },
		{ "cs4",		IPTOS_DSCP_CS4 },
		{ "cs5",		IPTOS_DSCP_CS5 },
		{ "cs6",		IPTOS_DSCP_CS6 },
		{ "cs7",		IPTOS_DSCP_CS7 },
		{ "ef",			IPTOS_DSCP_EF },
		{ "inetcontrol",	IPTOS_PREC_INTERNETCONTROL },
		{ "lowdelay",		IPTOS_LOWDELAY },
		{ "netcontrol",		IPTOS_PREC_NETCONTROL },
		{ "reliability",	IPTOS_RELIABILITY },
		{ "throughput",		IPTOS_THROUGHPUT },
		{ NULL, 		-1 },
	};
	
	for (t = toskeywords; t->keyword != NULL; t++) {
		if (strcmp(s, t->keyword) == 0) {
			*val = t->val;
			return (1);
		}
	}
	
	return (0);
}

static void
quit(int sig, short event, void *arg)
{
	exit(0);
}

int
main(int argc, char **argv)
{
	struct timeval tv;
	unsigned int secs, rtable;

	char kerr[_POSIX2_LINE_MAX], *tmp;
	struct addrinfo *aitop, *aib, hints;
	const char *errstr;
	struct rlimit rl;
	int ch, herr, nconn;
	int family = PF_UNSPEC;
	struct nlist nl[] = { { "_tcbtable" }, { "" } };
	const char *host = NULL, *port = DEFAULT_PORT, *srcbind = NULL;
	struct event ev_sigint, ev_sigterm, ev_sighup, ev_progtimer;
	struct statctx *udp_sc = NULL;
	struct sockaddr_un sock_un;

	/* Init world */
	setvbuf(stdout, NULL, _IOLBF, 0);
	ptb = &tcpbench;
	ptb->dummybuf_len = 0;
	ptb->Sflag = ptb->sflag = ptb->vflag = ptb->Rflag = ptb->Uflag = 0;
	ptb->kvmh  = NULL;
	ptb->kvars = NULL;
	ptb->rflag = DEFAULT_STATS_INTERVAL;
	ptb->Tflag = -1;
	nconn = 1;
	aib = NULL;
	secs = 0;

	while ((ch = getopt(argc, argv, "46b:B:hlk:n:p:Rr:sS:t:T:uUvV:")) != -1) {
		switch (ch) {
		case '4':
			family = PF_INET;
			break;
		case '6':
			family = PF_INET6;
			break;
		case 'b':
			srcbind = optarg;
			break;
		case 'l':
			list_kvars();
			exit(0);
		case 'k':
			if ((tmp = strdup(optarg)) == NULL)
				errx(1, "strdup");
			ptb->kvars = check_prepare_kvars(tmp);
			free(tmp);
			break;
		case 'R':
			ptb->Rflag = 1;
			break;
		case 'r':
			ptb->rflag = strtonum(optarg, 0, 60 * 60 * 24 * 1000,
			    &errstr);
			if (errstr != NULL)
				errx(1, "statistics interval is %s: %s",
				    errstr, optarg);
			break;
		case 'p':
			port = optarg;
			break;
		case 's':
			ptb->sflag = 1;
			break;
		case 'S':
			ptb->Sflag = strtonum(optarg, 0, 1024*1024*1024,
			    &errstr);
			if (errstr != NULL)
				errx(1, "receive space interval is %s: %s",
				    errstr, optarg);
			break;
		case 'B':
			ptb->dummybuf_len = strtonum(optarg, 0, 1024*1024*1024,
			    &errstr);
			if (errstr != NULL)
				errx(1, "read/write buffer size is %s: %s",
				    errstr, optarg);
			break;
		case 'v':
			ptb->vflag++;
			break;
		case 'V':
			rtable = (unsigned int)strtonum(optarg, 0,
			    RT_TABLEID_MAX, &errstr);
			if (errstr)
				errx(1, "rtable value is %s: %s",
				    errstr, optarg);
			if (setrtable(rtable) == -1)
				err(1, "setrtable");
			break;
		case 'n':
			nconn = strtonum(optarg, 0, 65535, &errstr);
			if (errstr != NULL)
				errx(1, "number of connections is %s: %s",
				    errstr, optarg);
			break;
		case 'u':
			ptb->uflag = 1;
			break;
		case 'U':
			ptb->Uflag = 1;
			break;
		case 'T':
			if (map_tos(optarg, &ptb->Tflag))
				break;
			errstr = NULL;
			if (strlen(optarg) > 1 && optarg[0] == '0' &&
			    optarg[1] == 'x')
				ptb->Tflag = (int)strtol(optarg, NULL, 16);
			else
				ptb->Tflag = (int)strtonum(optarg, 0, 255,
				    &errstr);
			if (ptb->Tflag == -1 || ptb->Tflag > 255 || errstr)
				errx(1, "illegal tos value %s", optarg);
			break;
		case 't':
			secs = strtonum(optarg, 1, UINT_MAX, &errstr);
			if (errstr != NULL)
				errx(1, "secs is %s: %s",
				    errstr, optarg);
			break;
		case 'h':
		default:
			usage();
		}
	}

	if (pledge("stdio rpath dns inet unix id proc", NULL) == -1)
		err(1, "pledge");

	argv += optind;
	argc -= optind;
	if ((argc != (ptb->sflag && !ptb->Uflag ? 0 : 1)) ||
	    (UDP_MODE && (ptb->kvars || nconn != 1)))
		usage();

	if (ptb->kvars) {
		if ((ptb->kvmh = kvm_openfiles(NULL, NULL, NULL,
		    O_RDONLY, kerr)) == NULL)
			errx(1, "kvm_open: %s", kerr);
		drop_gid();
		if (kvm_nlist(ptb->kvmh, nl) < 0 || nl[0].n_type == 0)
			errx(1, "kvm: no namelist");
		ptb->ktcbtab = nl[0].n_value;
	} else
		drop_gid();

	if (pledge("stdio id dns inet unix", NULL) == -1)
		err(1, "pledge");

	if (!ptb->sflag || ptb->Uflag)
		host = argv[0];
	/*
	 * Rationale,
	 * If TCP, use a big buffer with big reads/writes.
	 * If UDP, use a big buffer in server and a buffer the size of a
	 * ethernet packet.
	 */
	if (!ptb->dummybuf_len) {
		if (ptb->sflag || TCP_MODE) 
			ptb->dummybuf_len = DEFAULT_BUF;
		else
			ptb->dummybuf_len = DEFAULT_UDP_PKT;
	}

	bzero(&hints, sizeof(hints));
	hints.ai_family = family;
	if (UDP_MODE) {
		hints.ai_socktype = SOCK_DGRAM;
		hints.ai_protocol = IPPROTO_UDP;
	} else {
		hints.ai_socktype = SOCK_STREAM;
		hints.ai_protocol = IPPROTO_TCP;
	}
	if (ptb->Uflag) {
		hints.ai_family = AF_UNIX;
		hints.ai_protocol = 0;
		sock_un.sun_family = AF_UNIX;
		if (strlcpy(sock_un.sun_path, host, sizeof(sock_un.sun_path)) >=
		    sizeof(sock_un.sun_path))
			errx(1, "socket name '%s' too long", host);
		hints.ai_addr = (struct sockaddr *)&sock_un;
		hints.ai_addrlen = sizeof(sock_un);
		aitop = &hints;
	} else {
		if (ptb->sflag)
			hints.ai_flags = AI_PASSIVE;
		if (srcbind != NULL) {
			hints.ai_flags |= AI_NUMERICHOST;
			herr = getaddrinfo(srcbind, NULL, &hints, &aib);
			hints.ai_flags &= ~AI_NUMERICHOST;
			if (herr != 0) {
				if (herr == EAI_SYSTEM)
					err(1, "getaddrinfo");
				else
					errx(1, "getaddrinfo: %s",
					    gai_strerror(herr));
			}
		}
		if ((herr = getaddrinfo(host, port, &hints, &aitop)) != 0) {
			if (herr == EAI_SYSTEM)
				err(1, "getaddrinfo");
			else
				errx(1, "getaddrinfo: %s", gai_strerror(herr));
		}
	}

	if (pledge("stdio id inet unix", NULL) == -1)
		err(1, "pledge");

	if (getrlimit(RLIMIT_NOFILE, &rl) == -1)
		err(1, "getrlimit");
	if (rl.rlim_cur < MAX_FD)
		rl.rlim_cur = MAX_FD;
	if (setrlimit(RLIMIT_NOFILE, &rl))
		err(1, "setrlimit");
	if (getrlimit(RLIMIT_NOFILE, &rl) == -1)
		err(1, "getrlimit");

	if (pledge("stdio inet unix", NULL) == -1)
		err(1, "pledge");

	/* Init world */
	TAILQ_INIT(&sc_queue);
	if ((ptb->dummybuf = malloc(ptb->dummybuf_len)) == NULL)
		err(1, "malloc");
	arc4random_buf(ptb->dummybuf, ptb->dummybuf_len);

	/* Setup libevent and signals */
	event_init();
	signal_set(&ev_sigterm, SIGTERM, signal_handler, NULL);
	signal_set(&ev_sighup, SIGHUP, signal_handler, NULL);
	signal_set(&ev_sigint, SIGINT, signal_handler, NULL);
	signal_add(&ev_sigint, NULL);
	signal_add(&ev_sigterm, NULL);
	signal_add(&ev_sighup, NULL);
	signal(SIGPIPE, SIG_IGN);
	
	if (UDP_MODE) {
		if ((udp_sc = calloc(1, sizeof(*udp_sc))) == NULL)
			err(1, "calloc");
		udp_sc->fd = -1;
		stats_prepare(udp_sc);
		evtimer_set(&mainstats.timer, udp_process_slice, udp_sc);
	} else {
		print_tcp_header();
		evtimer_set(&mainstats.timer, tcp_process_slice, NULL);
	}

	if (ptb->sflag)
		server_init(aitop, udp_sc);
	else {
		if (secs > 0) {
			timerclear(&tv);
			tv.tv_sec = secs + 1;
			evtimer_set(&ev_progtimer, quit, NULL);
			evtimer_add(&ev_progtimer, &tv);
		}
		client_init(aitop, nconn, udp_sc, aib);

		if (pledge("stdio", NULL) == -1)
			err(1, "pledge");
	}

	/* libevent main loop*/
	event_dispatch();

	return (0);
}
@


1.51
log
@Add AF_UNIX support to tcpbench and also make it possible to randomize the
write size in the client. pledge setup can be made tighter but that will be
done in a second step.
OK benno@@, henning@@, markus@@ and some man page input by jmc@@
@
text
@d1 2
@


1.50
log
@Lose the pointless third paramater to fcntl(F_GETFL). Using SOCK_NONBLOCK
instead of fcntl() dance would significantly change designed semantics.

ok djm@@
@
text
@d24 1
d70 2
d185 1
a185 1
	    "       tcpbench [-46uv] [-B buf] [-b addr] [-k kvars] [-n connections]\n"
d188 2
a189 2
	    "       tcpbench -s [-46uv] [-B buf] [-k kvars] [-p port]\n"
	    "                [-r interval] [-S space] [-T toskeyword] [-V rtable]\n");
d218 5
d816 2
a817 1
	freeaddrinfo(aitop);
d827 1
d829 3
a831 1
	if ((n = write(sc->fd, sc->buf, sc->buflen)) == -1) {
d931 2
a932 1
	freeaddrinfo(aitop);
d1011 1
d1017 1
a1017 1
	ptb->Sflag = ptb->sflag = ptb->vflag = 0;
d1026 1
a1026 1
	while ((ch = getopt(argc, argv, "46b:B:hlk:n:p:r:sS:t:T:uvV:")) != -1) {
d1046 3
d1097 3
d1125 1
a1125 1
	if (pledge("stdio rpath dns inet id proc", NULL) == -1)
d1130 1
a1130 1
	if ((argc != (ptb->sflag ? 0 : 1)) ||
d1145 1
a1145 1
	if (pledge("stdio id dns inet", NULL) == -1)
d1148 1
a1148 1
	if (!ptb->sflag)
d1172 26
a1197 7
	if (ptb->sflag)
		hints.ai_flags = AI_PASSIVE;
	if (srcbind != NULL) {
		hints.ai_flags |= AI_NUMERICHOST;
		herr = getaddrinfo(srcbind, NULL, &hints, &aib);
		hints.ai_flags &= ~AI_NUMERICHOST;
		if (herr != 0) {
a1203 6
	if ((herr = getaddrinfo(host, port, &hints, &aitop)) != 0) {
		if (herr == EAI_SYSTEM)
			err(1, "getaddrinfo");
		else
			errx(1, "getaddrinfo: %s", gai_strerror(herr));
	}
d1205 1
a1205 1
	if (pledge("stdio id inet", NULL) == -1)
d1217 1
a1217 1
	if (pledge("stdio inet", NULL) == -1)
@


1.49
log
@remove unused variable

ok millert@@
@
text
@d899 1
a899 1
		if ((r = fcntl(sock, F_GETFL, 0)) == -1)
@


1.48
log
@Instead of creating a socket with socket() or accept() and then
setting the O_NONBLOCK flag on it with fcntl(F_SETFL) afterwards,
just pass SOCK_NONBLOCK to socket() or accept4() and get it right
to begin with.

ok millert@@ krw@@ beck@@ deraadt@@ jca@@
@
text
@d672 1
a672 1
	int sock, r;
@


1.47
log
@pledge tcpbench, from David Hill, tweaked the -s case.
ok deraadt@@
@
text
@d683 2
a684 1
	if ((sock = accept(fd, (struct sockaddr *)&ss, &sslen)) == -1) {
a700 5
	if ((r = fcntl(sock, F_GETFL, 0)) == -1)
		err(1, "fcntl(F_GETFL)");
	r |= O_NONBLOCK;
	if (fcntl(sock, F_SETFL, r) == -1)
		err(1, "fcntl(F_SETFL, O_NONBLOCK)");
@


1.46
log
@If the kmem options are in use, drop the gid earlier.
ok djm
@
text
@a988 2
	extern int optind;
	extern char *optarg;
d1109 3
d1129 3
d1176 3
d1187 4
a1190 1
	
d1228 3
d1232 1
a1232 1
	
@


1.45
log
@Prefer setvbuf() to setlinebuf() for portability; ok deraadt@@
@
text
@d1117 11
a1170 10
	if (ptb->kvars) {
		if ((ptb->kvmh = kvm_openfiles(NULL, NULL, NULL,
		    O_RDONLY, kerr)) == NULL)
			errx(1, "kvm_open: %s", kerr);
		drop_gid();
		if (kvm_nlist(ptb->kvmh, nl) < 0 || nl[0].n_type == 0)
			errx(1, "kvm: no namelist");
		ptb->ktcbtab = nl[0].n_value;
	} else
		drop_gid();
@


1.44
log
@Remove unnecessary include: netinet/in_systm.h is not needed by these
programs.

ok deraadt@@ millert@@
@
text
@d1006 1
a1006 1
	setlinebuf(stdout);
@


1.43
log
@Use reallocarray() to get integer overflow detection.

ok deraadt@@ djm@@
@
text
@a27 1
#include <netinet/in_systm.h>
@


1.42
log
@add -4 and -6 flags for saying if you want to force ipv4 or ipv6
respectively.

tweaks from jmc@@
ok djm@@
@
text
@d450 2
a451 2
		if ((ret = realloc(ret, sizeof(*ret) * (++n + 1))) == NULL)
			errx(1, "realloc(kvars)");
@


1.41
log
@final circleq to tailq fix. restore the previous pointer check by reading
the previous value again and checking prev.next is still next.
maybe ok guenther
@
text
@d183 1
a183 1
	    "       tcpbench [-uv] [-B buf] [-b addr] [-k kvars] [-n connections]\n"
d186 1
a186 1
	    "       tcpbench -s [-uv] [-B buf] [-k kvars] [-p port]\n"
d1000 1
d1019 1
a1019 1
	while ((ch = getopt(argc, argv, "b:B:hlk:n:p:r:sS:t:T:uvV:")) != -1) {
d1021 6
d1134 1
@


1.40
log
@more fixing after circleq conversion. a better fix to check the prev
pointer is forthcoming.
@
text
@d294 1
a294 1
	struct inpcb inpcb;
d334 11
@


1.39
log
@Switch inpt_queue from CIRCLEQ to TAILQ. Thus ending use of CIRCLEQ
in the base. Ports fixes to follow shortly for the two ports (gkrellm
and net-snmp) affected.

ok zhuk@@ millert@@
@
text
@d293 1
a293 1
	struct inpcb *head, *next, *prev;
d325 1
a325 2
	prev = head = (struct inpcb *)&TAILQ_FIRST(
	    &((struct inpcbtable *)ptb->ktcbtab)->inpt_queue);
d329 2
a330 2
		fprintf(stderr, "PCB head at %p\n", head);
	while (next != head) {
a333 8
		if (TAILQ_PREV(&inpcb, inpthead, inp_queue) != prev) {
			if (nretry--) {
				warnx("pcb prev pointer insane");
				goto retry;
			} else
				errx(1, "pcb prev pointer insane,"
				     " all attempts exausted");
		}
@


1.38
log
@handle ECONNABORTED errors from accept().  In many code blocks they can be
ignored silently and without aborting, much like EINTR and EWOULDBLOCK are.
ok's from various maintainers of these directories...
@
text
@d325 1
a325 1
	prev = head = (struct inpcb *)&CIRCLEQ_FIRST(
d327 1
a327 1
	next = CIRCLEQ_FIRST(&tcbtab.inpt_queue);
d335 1
a335 1
		if (CIRCLEQ_PREV(&inpcb, inp_queue) != prev) {
d344 1
a344 1
		next = CIRCLEQ_NEXT(&inpcb, inp_queue);
@


1.37
log
@Simplify rtable assignment and cut some cruft
@
text
@d692 2
a693 1
		} else if (errno != EWOULDBLOCK && errno != EINTR)
@


1.36
log
@When the last user disconnects, make sure we display the status line
one more time.

ok sthen@@
@
text
@a63 1
	u_int	  Vflag;	/* rtableid */
a753 9
		if (ptb->Vflag) {
			if (setsockopt(sock, SOL_SOCKET, SO_RTABLE,
			    &ptb->Vflag, sizeof(ptb->Vflag)) == -1) {
				if (errno == ENOPROTOOPT)
					warn("set rtable");
				else
					err(1, "setsockopt SO_RTABLE");
			}
		}
a882 9
			if (ptb->Vflag) {
				if (setsockopt(sock, SOL_SOCKET, SO_RTABLE,
				    &ptb->Vflag, sizeof(ptb->Vflag)) == -1) {
					if (errno == ENOPROTOOPT)
						warn("set rtable");
					else
						err(1, "setsockopt SO_RTABLE");
				}
			}
d990 1
a990 1
	unsigned int secs;
d1006 1
a1006 1
	ptb->Sflag = ptb->sflag = ptb->vflag = ptb->Vflag = 0;
d1060 1
a1060 1
			ptb->Vflag = (unsigned int)strtonum(optarg, 0,
d1065 2
@


1.35
log
@Fix double-free when -n is used with -b.

From Erik Lax, also tested by lteo.
@
text
@d571 1
a571 1
	    slice_mbps / mainstats.nconns); 
a659 1
		set_slice_timer(mainstats.nconns > 0);
d725 2
a726 1
	set_slice_timer(mainstats.nconns > 0);
d937 2
a938 1
		set_slice_timer(mainstats.nconns > 0);
@


1.34
log
@Kill "goto again" uppon EINTR and check EWOULDBLOCK in accept(2).
Also make the code more similar to the other daemons.

"you can go ahead" deraadt@@.
@
text
@a881 1
				freeaddrinfo(aib);
d940 2
@


1.33
log
@Rate-limit accepting of new connections while we are experiencing fd
exaustion for tcpbench.

ok deraadt
@
text
@a612 1
again:
d617 2
a618 5
		if (errno == EINTR)
			goto again;
		else if (errno == EWOULDBLOCK) 
			return;
		warn("fd %d read error", fd);
a637 1
again:
d640 2
a641 5
		if (errno == EINTR)
			goto again;
		else if (errno == EWOULDBLOCK) 
			return;
		warn("fd %d read error", sc->fd);
a683 1
again:	
a684 2
		if (errno == EINTR)
			goto again;
d694 1
a694 1
		} else
a830 1
again:
d832 1
a832 1
		if (errno == EINTR || errno == EAGAIN ||
d834 1
a834 1
			goto again;
@


1.32
log
@Remove setpgid() call, this is a leftover from when we were forked.
From Erik Lax

"commit it" mikeb@@
@
text
@d78 6
d94 1
d654 3
d659 7
a665 1
		TAILQ_REMOVE(&sc_queue, sc, entry);
d678 1
a678 1
tcp_server_accept(int fd, short event, void *bula)
d680 1
d688 4
d696 11
a706 1
		warn("accept");
d729 1
d750 1
d811 3
a813 3
		if ((ev = calloc(1, sizeof(*ev))) == NULL)
			err(1, "calloc");
		if (UDP_MODE)
d816 11
a826 4
		else
			event_set(ev, sock, EV_READ | EV_PERSIST,
			    tcp_server_accept, NULL);
		event_add(ev, NULL);
@


1.31
log
@Don't use floating precision while printing PPS in UDP mode.

"go for it" mikeb@@
"looks good to me" henning@@
@
text
@a719 3
	if (setpgid(0, 0) == -1)
		err(1, "setpgid");

@


1.30
log
@add a timer to tcpbench as a command-line option (-t) so
that it is possible to stop the tcpbench client after a certain number
of seconds. This makes it easier to use tcpbench as part of a script.
From: Lawrence Teo <lteo at lteo.net>
ok phessler haesbaert and myself
@
text
@d574 2
a575 2
	unsigned long long total_elapsed, since_last;
	long double slice_mbps, pps;
d589 1
a589 1
	printf("Elapsed: %11llu Mbps: %11.3Lf Peak Mbps: %11.3Lf %s PPS: %10.3Lf\n",
@


1.29
log
@Don't lie the number of estabilished connections. nconns is the number
of requested, not estabilished connections, so use mainstats.nconns.
@
text
@d179 1
a179 1
	    "                [-V rtable] hostname\n"
d970 6
d981 2
d991 1
a991 1
	struct event ev_sigint, ev_sigterm, ev_sighup;
d1005 1
d1007 1
a1007 1
	while ((ch = getopt(argc, argv, "b:B:hlk:n:p:r:sS:T:uvV:")) != -1) {
d1080 6
d1189 7
a1195 1
	else
d1197 1
@


1.28
log
@Fix some warnx() calls which should be fprintf plus KNF.
@
text
@d918 2
a919 1
		fprintf(stderr, "%u connections established\n", nconn);
@


1.27
log
@Kill unecessary break in UDP_MODE, simplify code a bit by killing some
conditionals, KNF. No functional changes.

ok claudio@@
@
text
@d333 1
a333 2
			}
			else
d707 2
a708 1
		warnx("Accepted connection from %s, fd = %d\n", tmp, sc->fd);
d813 1
a813 1
		warnx("Remote end closed connection");
d817 1
a817 1
		warnx("write: %zd bytes\n", n);
@


1.26
log
@Sort the lines on -l output and match the order on the column output.
Also make the -l output go to stdout as it's easier to grep with it,
and set stdout to linebuf.

ok djm@@ "as long as you add a setlinebuf(stdout) :-)"
@
text
@a913 2
		if (UDP_MODE)
			break;
d1101 1
a1101 2
	}
	else {
a1149 7
	if (UDP_MODE) {
		if ((udp_sc = calloc(1, sizeof(*udp_sc))) == NULL)
			err(1, "calloc");
		udp_sc->fd = -1;
		stats_prepare(udp_sc);
	}

d1160 7
a1166 1
	if (TCP_MODE)
a1167 4
	
	if (UDP_MODE)
		evtimer_set(&mainstats.timer, udp_process_slice, udp_sc);
	else
d1169 1
d1171 1
a1171 1
	if (ptb->sflag) {
d1173 1
a1173 1
	} else
@


1.25
log
@Add -b option which allows the client side to bind the socket to a
numeric address.  Requested by mikeb@@ in order to test ipsec.

ok mcbride mikeb djm jmc
@
text
@d137 1
a138 1
	"sockb.so_rcv.sb_hiwat",
d140 1
d142 13
a154 1
	"sockb.so_snd.sb_hiwat",
a155 1
	"tcpcb.snd_nxt",
a158 6
	"tcpcb.rcv_wnd",
	"tcpcb.rcv_nxt",
	"tcpcb.rcv_adv",
	"tcpcb.snd_max",
	"tcpcb.snd_cwnd",
	"tcpcb.snd_ssthresh",
d160 2
d163 1
a163 1
	"tcpcb.t_rtseq",
d165 1
a165 8
	"tcpcb.t_rttvar",
	"tcpcb.t_rttmin",
	"tcpcb.max_sndwnd",
	"tcpcb.snd_scale",
	"tcpcb.rcv_scale",
	"tcpcb.last_ack_sent",
	"tcpcb.rfbuf_cnt",
	"tcpcb.rfbuf_ts",
a166 1
	"tcpcb.ts_recent",
d430 1
a430 1
	fprintf(stderr, "Supported kernel variables:\n");
d432 1
a432 1
		fprintf(stderr, "\t%s\n", allowed_kvars[i]);
d489 1
a490 1
			P(sockb, so_rcv.sb_hiwat, "%lu")
d492 1
d494 13
a506 1
			P(sockb, so_snd.sb_hiwat, "%lu")
a507 1
			P(tcpcb, snd_nxt, "%u")
a510 6
			P(tcpcb, rcv_wnd, "%lu")
			P(tcpcb, rcv_nxt, "%u")
			P(tcpcb, rcv_adv, "%u")
			P(tcpcb, snd_max, "%u")
			P(tcpcb, snd_cwnd, "%lu")
			P(tcpcb, snd_ssthresh, "%lu")
d512 2
d515 1
a515 1
			P(tcpcb, t_rtseq, "%u")
d517 1
a517 8
			P(tcpcb, t_rttvar, "%hu")
			P(tcpcb, t_rttmin, "%hu")
			P(tcpcb, max_sndwnd, "%lu")
			P(tcpcb, snd_scale, "%u")
			P(tcpcb, rcv_scale, "%u")
			P(tcpcb, last_ack_sent, "%u")
			P(tcpcb, rfbuf_cnt, "%u")
			P(tcpcb, rfbuf_ts, "%u")
a518 1
			P(tcpcb, ts_recent, "%u")
d988 1
@


1.24
log
@Allow TOS/TCLASS to be set with -T, accept the same keywords as in pf.conf.

ok mcbride@@ djm@@
'fine from me' jmc@@
@
text
@d113 2
a114 1
static void	client_init(struct addrinfo *, int, struct statctx *);
d177 3
a179 3
	    "       tcpbench [-uv] [-B buf] [-k kvars] [-n connections] [-p port]\n"
	    "                [-r interval] [-S space] [-T toskeyword] [-V rtable]\n"
	    "                hostname\n"
d825 2
a826 1
client_init(struct addrinfo *aitop, int nconn, struct statctx *udp_sc)
d848 11
d978 1
a978 1
	struct addrinfo *aitop, hints;
d983 1
a983 1
	const char *host = NULL, *port = DEFAULT_PORT;
d996 1
d998 1
a998 1
	while ((ch = getopt(argc, argv, "B:hlk:n:p:r:sS:T:uvV:")) != -1) {
d1000 3
d1099 1
a1099 1
	if (UDP_MODE)
d1101 3
a1103 1
	else
d1105 2
d1109 11
d1180 1
a1180 1
		client_init(aitop, nconn, udp_sc);
@


1.23
log
@event_del() a persistent event; fixes segfault seen on the server when the
remote end closes and reopens a connection.

From Christiano F. Haesbaert, ok claudio@@
@
text
@d68 1
d117 1
a117 1

d177 2
a178 1
	    "                [-r interval] [-S space] [-V rtable] hostname\n"
d180 1
a180 1
	    "                [-r interval] [-S space] [-V rtable]\n");
d685 10
d744 10
d846 10
d910 48
d981 1
d984 1
a984 1
	while ((ch = getopt(argc, argv, "B:hlk:n:p:r:sS:uvV:")) != -1) {
d1040 13
@


1.22
log
@Convert SO_RTABLE's protocol level to the SOL_SOCKET;  ok claudio
@
text
@d645 1
@


1.21
log
@various cleanup;
@
text
@d722 9
a730 6
		if (ptb->Vflag && ai->ai_family == AF_INET) {
			if (setsockopt(sock, IPPROTO_IP, SO_RTABLE,
			    &ptb->Vflag, sizeof(ptb->Vflag)) == -1)
				err(1, "setsockopt SO_RTABLE");
		} else if (ptb->Vflag)
			warnx("rtable only supported on AF_INET");
d823 9
a831 6
			if (ptb->Vflag && ai->ai_family == AF_INET) {
				if (setsockopt(sock, IPPROTO_IP, SO_RTABLE,
				    &ptb->Vflag, sizeof(ptb->Vflag)) == -1)
					err(1, "setsockopt SO_RTABLE");
			} else if (ptb->Vflag)
				warnx("rtable only supported on AF_INET");
@


1.20
log
@Implement UDP mode for tcpbench and switch tcpbench to use libevent.
In UDP mode the tcpbench client tries to flood the pipe to the maximum
and the server will busy read the packets. For TCP mode nothing has
changed.  All the work was done by Christiano F. Haesbaert
(haesbaert(at)haesbaert org).
OK myself and a lot of pushing from deraadt@@
@
text
@d175 4
a178 4
	    "       tcpbench [-v] [-u] [-B buf] [-k kvars] [-n connections]\n"
	    "                [-p port] [-q] [-r rate] [-S space] [-V rtable] hostname\n"
	    "       tcpbench -s [-v] [-u] [-B buf] [-k kvars] [-p port]\n"
	    "                [-q] [-r rate] [-S space] [-V rtable]\n");
@


1.19
log
@Add a few more tcpcb and sockbuffer variables that tcpbench can inspect.
@
text
@d3 1
d23 1
d44 1
d56 4
a59 1
#define DEFAULT_BUF 256 * 1024
d62 14
a75 2
sig_atomic_t done = 0;
sig_atomic_t proc_slice = 0;
d77 1
a77 9
static u_int  rtableid;
static char **kflag;
static size_t Bflag;
static int    Sflag;
static int    rflag;
static int    sflag;
static int    vflag;

/* stats for a single connection */
d79 1
d82 8
a89 3
	u_long tcbaddr;
	char **kvars;
	kvm_t *kh;
d92 25
a125 1
	struct timeval t_start;	        /* when we started counting */
d128 1
d131 1
a131 1
/* When adding variables, also add to stats_display() */
d168 1
a168 12
static void
exitsighand(int signo)
{
	done = signo;
}

static void
alarmhandler(int signo)
{
	proc_slice = 1;
	signal(signo, alarmhandler);
}
d175 4
a178 4
	    "       tcpbench [-v] [-B buf] [-k kvars] [-n connections] [-p port]\n"
	    "                [-r rate] [-S space] [-V rtable] hostname\n"
	    "       tcpbench -s [-v] [-B buf] [-k kvars] [-p port]\n"
	    "                [-r rate] [-S space] [-V rtable]\n");
d183 19
d218 11
a228 1
set_timer(int toggle)
d230 1
a230 1
	struct itimerval itv;
d232 1
a232 1
	if (rflag <= 0)
d235 12
a246 7
	if (toggle) {
		itv.it_interval.tv_sec = rflag / 1000;
		itv.it_interval.tv_usec = (rflag % 1000) * 1000;
		itv.it_value = itv.it_interval;
	}
	else
		bzero(&itv, sizeof(itv));
d248 11
a258 1
	setitimer(ITIMER_REAL, &itv, NULL);
d262 1
a262 1
print_header(void)
d265 1
a265 1
	
d268 2
a269 4
	
	for (kv = kflag;  kflag != NULL && *kv != NULL; kv++) 
		printf("%s%s", kv != kflag ? "," : "", *kv);
	
d274 1
a274 1
kget(kvm_t *kh, u_long addr, void *buf, size_t size)
d276 2
a277 2
	if (kvm_read(kh, addr, buf, size) != (ssize_t)size)
		errx(1, "kvm_read: %s", kvm_geterr(kh));
d281 1
a281 1
kfind_tcb(kvm_t *kh, u_long ktcbtab, int sock)
d305 1
a305 1
	if (vflag >= 2) {
d312 2
a313 2
	if (vflag >= 2)
		fprintf(stderr, "Using PCB table at %lu\n", ktcbtab);
d315 1
a315 1
	kget(kh, ktcbtab, &tcbtab, sizeof(tcbtab));
d317 1
a317 1
	    &((struct inpcbtable *)ktcbtab)->inpt_queue);
d320 1
a320 1
	if (vflag >= 2)
d323 1
a323 1
		if (vflag >= 2)
d325 1
a325 1
		kget(kh, (u_long)next, &inpcb, sizeof(inpcb));
d340 1
a340 1
				if (vflag >= 2)
d344 1
a344 1
			if (vflag >= 2) {
d367 1
a367 1
			if (vflag >= 2) {
d388 1
a388 1
		kget(kh, (u_long)inpcb.inp_ppcb, &tcpcb, sizeof(tcpcb));
d390 1
a390 1
			if (vflag >= 2)
d394 1
a394 1
		if (vflag >= 2)
d396 1
a396 1
		return (u_long)prev;
d403 2
a404 2
kupdate_stats(kvm_t *kh, u_long tcbaddr,
    struct inpcb *inpcb, struct tcpcb *tcpcb, struct socket *sockb)
d406 3
a408 3
	kget(kh, tcbaddr, inpcb, sizeof(*inpcb));
	kget(kh, (u_long)inpcb->inp_ppcb, tcpcb, sizeof(*tcpcb));
	kget(kh, (u_long)inpcb->inp_socket, sockb, sizeof(*sockb));
d446 1
a446 1
	return ret;
d450 1
a450 1
stats_prepare(struct statctx *sc, int fd, kvm_t *kh, u_long ktcbtab)
d452 7
a458 8
	if (rflag <= 0)
		return;
	sc->kh = kh;
	sc->kvars = kflag;
	if (kflag)
		sc->tcbaddr = kfind_tcb(kh, ktcbtab, fd);
	if (gettimeofday(&sc->t_start, NULL) == -1)
		err(1, "gettimeofday");
a459 2
	sc->bytes = 0;
}
a460 5
static void
stats_update(struct statctx *sc, ssize_t n)
{
	sc->bytes += n;
	mainstats.slice_bytes += n;
d464 1
a464 7
stats_cleanslice(void)
{
	mainstats.slice_bytes = 0;
}

static void
stats_display(unsigned long long total_elapsed, long double mbps,
d473 2
a474 2
	if (sc->kvars != NULL) {
		kupdate_stats(sc->kh, sc->tcbaddr, inpcb, tcpcb,
d477 1
a477 1
		for (j = 0; sc->kvars[j] != NULL; j++) {
d480 1
a480 1
			if (strcmp(sc->kvars[j], S(b.v)) == 0) {	\
d524 1
a524 8
mainstats_display(long double slice_mbps, long double avg_mbps)
{
	printf("Conn: %3d Mbps: %12.3Lf Peak Mbps: %12.3Lf Avg Mbps: %12.3Lf\n",
	    mainstats.nconns, slice_mbps, mainstats.peak_mbps, avg_mbps); 
}

static void
process_slice(struct statctx *sc, size_t nsc)
d529 1
a529 1
	nfds_t i;
d535 5
a539 5
	for (i = 0; i < nsc; i++, sc++) {
		if (gettimeofday(&t_cur, NULL) == -1)
			err(1, "gettimeofday");
		if (sc->kvars != NULL) /* process kernel stats */
			kupdate_stats(sc->kh, sc->tcbaddr, &inpcb, &tcpcb,
d541 1
d550 1
a550 1
		stats_display(total_elapsed, mbps, bwperc, sc,
a554 1

d560 36
a595 1
	mainstats_display(slice_mbps, slice_mbps / mainstats.nconns);
d598 2
a599 2
static int
handle_connection(struct statctx *sc, int fd, char *buf, size_t buflen)
d602 1
d605 4
a608 2
	n = read(fd, buf, buflen);
	if (n == -1) {
d612 1
a612 1
			return 0;
d614 2
d617 34
a650 1
		return -1;
d652 1
a652 7
	else if (n == 0) {
		if (vflag)
			fprintf(stderr, "%8d closed by remote end\n", fd);
		close(fd);
		return -1;
	}
	if (vflag >= 3)
d654 3
d658 37
a694 2
	stats_update(sc, n);
	return 0;
d697 2
a698 2
static nfds_t
serverbind(struct pollfd *pfd, nfds_t max_nfds, struct addrinfo *aitop)
d703 1
d706 3
a710 5
		if (lnfds == max_nfds) {
			fprintf(stderr,
			    "maximum number of listening fds reached\n");
			break;
		}
d712 2
a713 2
		if (vflag)
			fprintf(stderr, "Try to listen on %s\n", tmp);
d718 1
a718 1
			if (vflag)
d722 1
a722 1
		if (rtableid && ai->ai_family == AF_INET) {
d724 1
a724 1
			    &rtableid, sizeof(rtableid)) == -1)
d726 1
a726 1
		} else if (rtableid)
d734 1
a734 1
			if (vflag)
d739 1
a739 1
		if (Sflag) {
d741 2
a742 2
			    &Sflag, sizeof(Sflag)) == -1)
				warn("set TCP receive buffer size");
d744 9
a752 7
		if (listen(sock, 64) == -1) {
			if (ai->ai_next == NULL)
				err(1, "listen");
			if (vflag)
				warn("listen");
			close(sock);
			continue;
d754 11
a764 2
		if (vflag >= 3)
			fprintf(stderr, "listening on fd %d\n", sock);
a765 3
		pfd[lnfds - 1].fd = sock;
		pfd[lnfds - 1].events = POLLIN;

a769 2

	return lnfds;
d773 4
a776 2
set_listening(struct pollfd *pfd, nfds_t lfds, int toggle) {
	int i;
d778 6
a783 5
	for (i = 0; i < (int)lfds; i++) {
		if (toggle)
			pfd[i].events = POLLIN;
		else
			pfd[i].events = 0;
d785 3
a787 126
			
}
static void __dead
serverloop(kvm_t *kvmh, u_long ktcbtab, struct addrinfo *aitop)
{
	socklen_t sslen;
	struct pollfd *pfd;
	char tmp[128], *buf;
	struct statctx *psc;
	struct sockaddr_storage ss;
	nfds_t i, nfds, lfds;
	size_t nalloc;
	int r, sock, client_id;

	sslen = sizeof(ss);
	nalloc = 128;
	if ((pfd = calloc(sizeof(*pfd), nalloc)) == NULL)
		err(1, "calloc");
	if ((psc = calloc(sizeof(*psc), nalloc)) == NULL)
		err(1, "calloc");
	if ((buf = malloc(Bflag)) == NULL)
		err(1, "malloc");
	lfds = nfds = serverbind(pfd, nalloc - 1, aitop);
	if (vflag >= 3)
		fprintf(stderr, "listening on %d fds\n", lfds);
	if (setpgid(0, 0) == -1)
		err(1, "setpgid");
	
	print_header();
	
	client_id = 0;
	while (!done) {
		if (proc_slice) { 
			process_slice(psc + lfds, nfds - lfds);
			stats_cleanslice();
			proc_slice = 0;
		}
		if (vflag >= 3) 
			fprintf(stderr, "mainstats.nconns = %u\n",
			    mainstats.nconns);
		if ((r = poll(pfd, nfds, INFTIM)) == -1) {
			if (errno == EINTR)
				continue;
			warn("poll");
			break;
		}

		if (vflag >= 3)
			fprintf(stderr, "poll: %d\n", r);
		for (i = 0 ; r > 0 && i < nfds; i++) {
			if ((pfd[i].revents & POLLIN) == 0)
				continue;
			if (pfd[i].fd == -1)
				errx(1, "pfd insane");
			r--;
			if (vflag >= 3)
				fprintf(stderr, "fd %d active i = %d\n",
				    pfd[i].fd, i);
			/* new connection */
			if (i < lfds) {
				if ((sock = accept(pfd[i].fd,
				    (struct sockaddr *)&ss,
				    &sslen)) == -1) {
					if (errno == EINTR)
						continue;
					else if (errno == EMFILE ||
					    errno == ENFILE)
						set_listening(pfd, lfds, 0);
					warn("accept");
					continue;
				}
				if ((r = fcntl(sock, F_GETFL, 0)) == -1)
					err(1, "fcntl(F_GETFL)");
				r |= O_NONBLOCK;
				if (fcntl(sock, F_SETFL, r) == -1)
					err(1, "fcntl(F_SETFL, O_NONBLOCK)");
				saddr_ntop((struct sockaddr *)&ss, sslen,
				    tmp, sizeof(tmp));
				if (vflag)
					fprintf(stderr,
					    "Accepted connection %d from "
					    "%s, fd = %d\n", client_id++, tmp,
					     sock);
				/* alloc more space if we're full */
				if (nfds == nalloc) {
					nalloc *= 2;
					if ((pfd = realloc(pfd,
					    sizeof(*pfd) * nalloc)) == NULL)
						err(1, "realloc");
					if ((psc = realloc(psc,
					    sizeof(*psc) * nalloc)) == NULL)
						err(1, "realloc");
				}
				pfd[nfds].fd = sock;
				pfd[nfds].events = POLLIN;
				stats_prepare(&psc[nfds], sock, kvmh, ktcbtab);
				nfds++;
				if (!mainstats.nconns++)
					set_timer(1);
				continue;
			}
			/* event in fd */
			if (vflag >= 3)
				fprintf(stderr,
				    "fd %d active", pfd[i].fd);
			while (handle_connection(&psc[i], pfd[i].fd,
			    buf, Bflag) == -1) {
				pfd[i] = pfd[nfds - 1];
				pfd[nfds - 1].fd = -1;
				psc[i] = psc[nfds - 1];
				mainstats.nconns--;
				nfds--;
				/* stop display if no clients */
				if (!mainstats.nconns) {
					proc_slice = 1;
					set_timer(0);
				}
				/* if we were full */
				set_listening(pfd, lfds, 1);

				/* is there an event pending on the last fd? */
				if (pfd[i].fd == -1 ||
				    (pfd[i].revents & POLLIN) == 0)
					break;
			}
		}
d789 6
a794 1
	exit(1);
d797 2
a798 2
void
clientconnect(struct addrinfo *aitop, struct pollfd *pfd, int nconn)
d800 2
a802 1
	struct addrinfo *ai;
d805 1
d810 1
a810 1
			if (vflag && i == 0)
d816 1
a816 1
				if (vflag)
d820 1
a820 1
			if (rtableid && ai->ai_family == AF_INET) {
d822 1
a822 1
				    &rtableid, sizeof(rtableid)) == -1)
d824 1
a824 1
			} else if (rtableid)
d826 1
a826 1
			if (Sflag) {
d828 1
a828 1
				    &Sflag, sizeof(Sflag)) == -1)
d834 1
a834 1
				if (vflag)
a843 1

d849 15
a863 3

		pfd[i].fd = sock;
		pfd[i].events = POLLOUT;
d867 1
a867 1
	if (vflag && nconn > 1)
a870 76
static void __dead
clientloop(kvm_t *kvmh, u_long ktcbtab, struct addrinfo *aitop, int nconn)
{
	struct statctx *psc;
	struct pollfd *pfd;
	char *buf;
	int i;
	ssize_t n;

	if ((pfd = calloc(nconn, sizeof(*pfd))) == NULL)
		err(1, "clientloop pfd calloc");
	if ((psc = calloc(nconn, sizeof(*psc))) == NULL)
		err(1, "clientloop psc calloc");
	
	clientconnect(aitop, pfd, nconn);

	for (i = 0; i < nconn; i++) {
		stats_prepare(psc + i, pfd[i].fd, kvmh, ktcbtab);
		mainstats.nconns++;
	}

	if ((buf = malloc(Bflag)) == NULL)
		err(1, "malloc");
	arc4random_buf(buf, Bflag);

	print_header();
	set_timer(1);

	while (!done) {
		if (proc_slice) {
			process_slice(psc, nconn);
			stats_cleanslice();
			proc_slice = 0;
		}
		if (poll(pfd, nconn, INFTIM) == -1) {
			if (errno == EINTR)
				continue;
			err(1, "poll");
		}
		for (i = 0; i < nconn; i++) {
			if (pfd[i].revents & POLLOUT) {
				if ((n = write(pfd[i].fd, buf, Bflag)) == -1) {
					if (errno == EINTR || errno == EAGAIN)
						continue;
					err(1, "write");
				}
				if (n == 0) {
					warnx("Remote end closed connection");
					done = -1;
					break;
				}
				if (vflag >= 3)
					fprintf(stderr, "write: %zd bytes\n",
					    n);
				stats_update(psc + i, n);
			}
		}
	}
	
	if (done > 0)
		warnx("Terminated by signal %d", done);

	free(buf);
	exit(0);
}

static void
drop_gid(void)
{
	gid_t gid;

	gid = getgid();
	if (setresgid(gid, gid, gid) == -1)
		err(1, "setresgid");
}

a879 1
	kvm_t *kvmh = NULL;
d881 1
a881 1
	int ch, herr;
d884 2
a885 1
	int nconn = 1;
d887 8
a894 4
	Bflag = DEFAULT_BUF;
	Sflag = sflag = vflag = rtableid = 0;
	kflag = NULL;
	rflag = DEFAULT_STATS_INTERVAL;
d896 1
a896 1
	while ((ch = getopt(argc, argv, "B:hlk:n:p:r:sS:vV:")) != -1) {
d904 1
a904 1
			kflag = check_prepare_kvars(tmp);
d908 1
a908 1
			rflag = strtonum(optarg, 0, 60 * 60 * 24 * 1000,
d918 1
a918 1
			sflag = 1;
d921 1
a921 1
			Sflag = strtonum(optarg, 0, 1024*1024*1024,
d928 1
a928 1
			Bflag = strtonum(optarg, 0, 1024*1024*1024,
d935 1
a935 1
			vflag++;
d938 1
a938 1
			rtableid = (unsigned int)strtonum(optarg, 0,
d950 3
d961 2
a962 1
	if (argc != (sflag ? 0 : 1))
d965 1
a965 1
	if (!sflag)
d967 12
d981 5
a985 2
	hints.ai_socktype = SOCK_STREAM;
	if (sflag)
d993 2
a994 3

	if (kflag) {
		if ((kvmh = kvm_openfiles(NULL, NULL, NULL,
d998 1
a998 1
		if (kvm_nlist(kvmh, nl) < 0 || nl[0].n_type == 0)
d1000 1
a1003 6
	signal(SIGINT, exitsighand);
	signal(SIGTERM, exitsighand);
	signal(SIGHUP, exitsighand);
	signal(SIGPIPE, SIG_IGN);
	signal(SIGALRM, alarmhandler);

d1013 28
a1040 2
	if (sflag)
		serverloop(kvmh, nl[0].n_value, aitop);
d1042 9
a1050 1
		clientloop(kvmh, nl[0].n_value, aitop, nconn);
d1052 1
a1052 1
	return 0;
@


1.18
log
@Make -k work in clientmode by passing the right socket to the
stats_prepare() function.
@
text
@d94 1
d97 1
d120 4
d428 1
d431 1
d454 4
@


1.17
log
@Fix the naming of interfaces and variables for rdomains and rtables
and make it possible to bind sockets (including listening sockets!)
to rtables and not just rdomains.  This changes the name of the
system calls, socket option, and ioctl.  After building with this
you should remove the files /usr/share/man/cat2/[gs]etrdomain.0.

Since this removes the existing [gs]etrdomain() system calls, the
libc major is bumped.

Written by claudio@@, criticized^Wcritiqued by me
@
text
@d806 1
a806 1
	int i, sock = -1;
d817 1
a817 1
		stats_prepare(psc + i, sock, kvmh, ktcbtab);
a862 1
	close(sock);
@


1.16
log
@try not to use size_t in places it does not belong; ok djm
@
text
@d59 1
a59 1
static u_int  rdomain;
d140 1
a140 1
	    "                [-r rate] [-S space] [-V rdomain] hostname\n"
d142 1
a142 1
	    "                [-r rate] [-S space] [-V rdomain]\n");
d555 6
a560 6
		if (rdomain && ai->ai_family == AF_INET) {
			if (setsockopt(sock, IPPROTO_IP, SO_RDOMAIN,
			    &rdomain, sizeof(rdomain)) == -1)
				err(1, "setsockopt SO_RDOMAIN");
		} else if (rdomain)
			warnx("rdomain only supported on AF_INET");
d760 6
a765 6
			if (rdomain && ai->ai_family == AF_INET) {
				if (setsockopt(sock, IPPROTO_IP, SO_RDOMAIN,
				    &rdomain, sizeof(rdomain)) == -1)
					err(1, "setsockopt SO_RDOMAIN");
			} else if (rdomain)
				warnx("rdomain only supported on AF_INET");
d894 1
a894 1
	Sflag = sflag = vflag = rdomain = 0;
d940 1
a940 1
			rdomain = (unsigned int)strtonum(optarg, 0,
d943 1
a943 1
				errx(1, "rdomain value is %s: %s",
@


1.15
log
@- adjust usage() to fit in 80 columns

- re-order client options in usage() to match server options
and the manual, as suggested by jmc.

ok jmc@@
@
text
@d196 1
a196 1
kget(kvm_t *kh, u_long addr, void *buf, int size)
d198 1
a198 1
	if (kvm_read(kh, addr, buf, size) != size)
d336 1
a336 1
	size_t i;
d347 1
a347 1
	size_t i;
d358 1
a358 1
	size_t n = 0;
@


1.14
log
@Move connect code out ouf clientloop into own function. This code can be
reused by the upcomming UDP mode. OK henning
@
text
@d139 4
a142 5
	    "       tcpbench [-v] [-B buf] [-k kvars] [-n connections]"
	    " [-p port] [-r rate] [-V rdomain]\n"
	    "                [-S space] hostname\n"
	    "       tcpbench -s [-v] [-B buf] [-k kvars] [-p port] [-r rate]"
	    " [-S space] [-V rdomain]\n");
@


1.13
log
@There is no need for two getaddrinfo implementations for client and server.
Merge them and make the client code look more like the server one.
OK henning@@
@
text
@d740 2
a741 2
static void __dead
clientloop(kvm_t *kvmh, u_long ktcbtab, struct addrinfo *aitop, int nconn)
d743 1
d745 1
a745 6
	struct statctx *psc;
	struct pollfd *pfd;
	char tmp[128], *buf;
	int i, r, herr, sock = -1;
	u_int scnt = 0;
	ssize_t n;
a746 8
	if ((buf = malloc(Bflag)) == NULL)
		err(1, "malloc");

	if ((pfd = calloc(nconn, sizeof(*pfd))) == NULL)
		err(1, "clientloop pfd calloc");
	if ((psc = calloc(nconn, sizeof(*psc))) == NULL)
		err(1, "clientloop psc calloc");
	
d751 1
a751 1
			if (vflag && scnt == 0)
d794 24
a819 1
		scnt++;
a820 1
	freeaddrinfo(aitop);
d822 2
a823 2
	if (vflag && scnt > 1)
		fprintf(stderr, "%u connections established\n", scnt);
d831 1
a831 1
			process_slice(psc, scnt);
@


1.12
log
@gcc2 hates claudio
@
text
@d741 1
a741 1
clientloop(kvm_t *kvmh, u_long ktcbtab, const char *host, const char *port, int nconn)
d743 1
a743 1
	struct addrinfo *aitop, *ai, hints;
a759 10
		bzero(&hints, sizeof(hints));
		hints.ai_socktype = SOCK_STREAM;
		hints.ai_flags = 0;
		if ((herr = getaddrinfo(host, port, &hints, &aitop)) != 0) {
			if (herr == EAI_SYSTEM)
				err(1, "getaddrinfo");
			else
				errx(1, "c getaddrinfo: %s", gai_strerror(herr));
		}

a794 1
		freeaddrinfo(aitop);
d810 1
d957 3
a959 3
	if (sflag) {
		bzero(&hints, sizeof(hints));
		hints.ai_socktype = SOCK_STREAM;
d961 5
a965 6
		if ((herr = getaddrinfo(host, port, &hints, &aitop)) != 0) {
			if (herr == EAI_SYSTEM)
				err(1, "getaddrinfo");
			else
				errx(1, "s getaddrinfo: %s", gai_strerror(herr));
		}
d996 1
a996 1
		clientloop(kvmh, nl[0].n_value, host, port, nconn);
@


1.11
log
@Change the way how the server works. Instead of forking of a child per
connection do multiplexing via poll(2). This allows to use more concurrent
connections and to specify additional kvm data to fetch.
This was all done by Christiano Farina Haesbaert (christiano.fh gmail dot com)
plus some input by myself.
OK henning@@
@
text
@d890 1
a890 1

a897 2

	struct nlist nl[] = { { "_tcbtable" }, { "" } };
@


1.10
log
@Print a warning when rdomain is used on non-AF_INET sockets. Those are
currently not supported. Requested by djm sort of.
@
text
@d21 1
d51 4
a54 3
#define DEFAULT_PORT		"12345"
#define DEFAULT_STATS_INTERVAL	1000		/* ms */
#define DEFAULT_BUF 		256 * 1024
d57 1
a57 1
sig_atomic_t print_stats = 0;
d59 7
a65 1
u_int rdomain;
d67 1
d69 1
a69 1
	struct timeval t_start, t_last, t_cur;
a70 1
	pid_t pid;
d72 1
a73 1
	char **kvars;
d76 14
d130 1
a130 1
	print_stats = 1;
d164 33
d204 1
a204 1
kfind_tcb(kvm_t *kh, u_long ktcbtab, int sock, int vflag)
d216 1
d218 1
d237 1
a237 1

d249 9
a257 2
		if (CIRCLEQ_PREV(&inpcb, inp_queue) != prev)
			errx(1, "pcb prev pointer insane");
d373 1
a373 2
stats_prepare(struct statctx *sc, int fd, kvm_t *kh, u_long ktcbtab,
    int rflag, int vflag, char **kflag)
a374 3
	struct itimerval itv;
	int i;

d380 3
a382 2
		sc->tcbaddr = kfind_tcb(kh, ktcbtab, fd, vflag);
	gettimeofday(&sc->t_start, NULL);
a383 5
	signal(SIGALRM, alarmhandler);
	itv.it_interval.tv_sec = rflag / 1000;
	itv.it_interval.tv_usec = (rflag % 1000) * 1000;
	itv.it_value = itv.it_interval;
	setitimer(ITIMER_REAL, &itv, NULL);
a384 9
	sc->pid = getpid();

	printf("%8s %12s %14s %12s ", "pid", "elapsed_ms", "bytes", "Mbps");
	if (sc->kvars != NULL) {
		for (i = 0; sc->kvars[i] != NULL; i++)
			printf("%s%s", i > 0 ? "," : "", sc->kvars[i]);
	}
	printf("\n");
	fflush(stdout);
d391 1
d395 1
a395 1
stats_display(struct statctx *sc)
d397 2
a398 6
	struct timeval t_diff;
	unsigned long long total_elapsed, since_last;
	size_t i;
	struct inpcb inpcb;
	struct tcpcb tcpcb;
	struct socket sockb;
d400 13
a412 10
	gettimeofday(&sc->t_cur, NULL);
	timersub(&sc->t_cur, &sc->t_start, &t_diff);
	total_elapsed = t_diff.tv_sec * 1000 + t_diff.tv_usec / 1000;
	timersub(&sc->t_cur, &sc->t_last, &t_diff);
	since_last = t_diff.tv_sec * 1000 + t_diff.tv_usec / 1000;
	printf("%8ld %12llu %14llu %12.3Lf ", (long)sc->pid,
	    total_elapsed, sc->bytes,
	    (long double)(sc->bytes * 8) / (since_last * 1000.0));
	sc->t_last = sc->t_cur;
	sc->bytes = 0;
d414 34
a447 34
	if (sc->kvars != NULL) {
		kupdate_stats(sc->kh, sc->tcbaddr, &inpcb, &tcpcb, &sockb);
		for (i = 0; sc->kvars[i] != NULL; i++) {
#define P(v, f) \
	if (strcmp(sc->kvars[i], #v) == 0) { \
		printf("%s"f, i > 0 ? "," : "", v); \
		continue; \
	}
			P(inpcb.inp_flags, "0x%08x")
			P(sockb.so_rcv.sb_cc, "%lu")
			P(sockb.so_rcv.sb_hiwat, "%lu")
			P(sockb.so_snd.sb_cc, "%lu")
			P(sockb.so_snd.sb_hiwat, "%lu")
			P(tcpcb.snd_una, "%u")
			P(tcpcb.snd_nxt, "%u")
			P(tcpcb.snd_wl1, "%u")
			P(tcpcb.snd_wl2, "%u")
			P(tcpcb.snd_wnd, "%lu")
			P(tcpcb.rcv_wnd, "%lu")
			P(tcpcb.rcv_nxt, "%u")
			P(tcpcb.rcv_adv, "%u")
			P(tcpcb.snd_max, "%u")
			P(tcpcb.snd_cwnd, "%lu")
			P(tcpcb.snd_ssthresh, "%lu")
			P(tcpcb.t_rcvtime, "%u")
			P(tcpcb.t_rtttime, "%u")
			P(tcpcb.t_rtseq, "%u")
			P(tcpcb.t_srtt, "%hu")
			P(tcpcb.t_rttvar, "%hu")
			P(tcpcb.t_rttmin, "%hu")
			P(tcpcb.max_sndwnd, "%lu")
			P(tcpcb.snd_scale, "%u")
			P(tcpcb.rcv_scale, "%u")
			P(tcpcb.last_ack_sent, "%u")
a451 1
	fflush(stdout);
d455 1
a455 1
stats_finish(struct statctx *sc)
d457 2
a458 5
	struct itimerval itv;

	signal(SIGALRM, SIG_DFL);
	bzero(&itv, sizeof(itv));
	setitimer(ITIMER_REAL, &itv, NULL);
d461 2
a462 3
static void __dead
handle_connection(kvm_t *kvmh, u_long ktcbtab, int sock, int vflag,
    int rflag, char **kflag, int Bflag)
d464 28
a491 5
	char *buf;
	struct pollfd pfd;
	ssize_t n;
	int r;
	struct statctx sc;
d493 1
a493 7
	if ((buf = malloc(Bflag)) == NULL)
		err(1, "malloc");
	if ((r = fcntl(sock, F_GETFL, 0)) == -1)
		err(1, "fcntl(F_GETFL)");
	r |= O_NONBLOCK;
	if (fcntl(sock, F_SETFL, r) == -1)
		err(1, "fcntl(F_SETFL, O_NONBLOCK)");
d495 5
a499 4
	signal(SIGINT, exitsighand);
	signal(SIGTERM, exitsighand);
	signal(SIGHUP, exitsighand);
	signal(SIGPIPE, SIG_IGN);
d501 4
a504 5
	bzero(&pfd, sizeof(pfd));
	pfd.fd = sock;
	pfd.events = POLLIN;

	stats_prepare(&sc, sock, kvmh, ktcbtab, rflag, vflag, kflag);
d506 10
a515 24
	while (!done) {
		if (print_stats) {
			stats_display(&sc);
			print_stats = 0;
		}
		if (poll(&pfd, 1, INFTIM) == -1) {
			if (errno == EINTR)
				continue;
			err(1, "poll");
		}
		if ((n = read(pfd.fd, buf, Bflag)) == -1) {
			if (errno == EINTR || errno == EAGAIN)
				continue;
			err(1, "read");
		}
		if (n == 0) {
			fprintf(stderr, "%8ld closed by remote end\n",
			    (long)getpid());
			done = -1;
			break;
		}
		if (vflag >= 3)
			fprintf(stderr, "read: %zd bytes\n", n);
		stats_update(&sc, n);
d517 11
a527 5
	stats_finish(&sc);

	free(buf);
	close(sock);
	exit(1);
d530 2
a531 3
static void __dead
serverloop(kvm_t *kvmh, u_long ktcbtab, struct addrinfo *aitop,
    int vflag, int rflag, char **kflag, int Sflag, int Bflag)
d534 1
a534 1
	int r, sock, client_id, on = 1;
d536 1
a536 4
	struct pollfd *pfd;
	struct sockaddr_storage ss;
	socklen_t sslen;
	size_t nfds, i, j;
d538 1
a538 2
	pfd = NULL;
	nfds = 0;
d540 5
d547 1
a547 1
			fprintf(stderr, "Try listen on %s\n", tmp);
d586 6
a591 6
		if (nfds > 128)
			break;
		if ((pfd = realloc(pfd, ++nfds * sizeof(*pfd))) == NULL)
			errx(1, "realloc(pfd * %zu)", nfds);
		pfd[nfds - 1].fd = sock;
		pfd[nfds - 1].events = POLLIN;
d594 1
a594 1
	if (nfds == 0)
d597 6
a602 5
	signal(SIGINT, exitsighand);
	signal(SIGTERM, exitsighand);
	signal(SIGHUP, exitsighand);
	signal(SIGPIPE, SIG_IGN);
	signal(SIGCHLD, SIG_IGN);
d604 31
d637 3
a639 1

d641 9
a649 1
	while (!done) {		
d656 1
d662 3
d666 13
a678 6
				fprintf(stderr, "fd %d active\n", pfd[i].fd);
			r--;
			sslen = sizeof(ss);
			if ((sock = accept(pfd[i].fd, (struct sockaddr *)&ss,
			    &sslen)) == -1) {
				if (errno == EINTR)
d680 30
a709 2
				warn("accept");
				break;
d711 23
a733 21
			saddr_ntop((struct sockaddr *)&ss, sslen,
			    tmp, sizeof(tmp));
			if (vflag)
				fprintf(stderr, "Accepted connection %d from "
				    "%s, fd = %d\n", client_id++, tmp, sock);
			switch (fork()) {
			case -1:
				warn("fork");
				done = -1;
				break;
			case 0:
				for (j = 0; j < nfds; j++)
					if (j != i)
						close(pfd[j].fd);
				handle_connection(kvmh, ktcbtab, sock,
				    vflag, rflag, kflag, Bflag);
				/* NOTREACHED */
				_exit(1);
			default:
				close(sock);
				break;
a734 2
			if (done == -1)
				break;
a736 6
	for (i = 0; i < nfds; i++)
		close(pfd[i].fd);
	if (done > 0)
		warnx("Terminated by signal %d", done);
	signal(SIGTERM, SIG_IGN);
	killpg(0, SIGTERM);
d741 1
a741 2
clientloop(kvm_t *kvmh, u_long ktcbtab, const char *host, const char *port,
    int vflag, int rflag, char **kflag, int Sflag, int Bflag, int nconn)
a742 3
	char tmp[128];
	char *buf;
	int r, sock, herr;
d744 1
d746 3
a749 2
	struct statctx sc;
	u_int i, scnt = 0;
d754 1
a754 1
	if ((pfd = calloc(nconn, sizeof(struct pollfd))) == NULL)
d756 3
a758 1

d817 2
d826 2
a827 6
	signal(SIGINT, exitsighand);
	signal(SIGTERM, exitsighand);
	signal(SIGHUP, exitsighand);
	signal(SIGPIPE, SIG_IGN);

	stats_prepare(&sc, sock, kvmh, ktcbtab, rflag, vflag, kflag);
d830 4
a833 3
		if (print_stats) {
			stats_display(&sc);
			print_stats = 0;
d855 1
a855 1
				stats_update(&sc, n);
d859 1
a859 2
	stats_finish(&sc);

d885 1
d887 2
a889 2
	struct addrinfo *aitop, hints;
	kvm_t *kvmh = NULL;
a891 3
	char **kflag = NULL;
	int sflag = 0, vflag = 0, rflag = DEFAULT_STATS_INTERVAL, Sflag = 0;
	int Bflag = DEFAULT_BUF;
d894 5
a965 3
	if (kflag != NULL && nconn > 1)
		errx(1, "-k currently only works with a single tcp connection");

d991 15
d1007 1
a1007 2
		serverloop(kvmh, nl[0].n_value, aitop, vflag, rflag, kflag,
		    Sflag, Bflag);
d1009 1
a1009 2
		clientloop(kvmh, nl[0].n_value, host, port, vflag, rflag, kflag,
		    Sflag, Bflag, nconn);
@


1.9
log
@Allow tcpbench to bind to a different rdomain.
OK sthen, djm and maybe more
@
text
@d509 2
a510 1
		}
d661 2
a662 1
			}
@


1.8
log
@remove unused variable

sure henning@@
@
text
@d57 2
d118 1
a118 1
	    " [-p port] [-r rate]\n"
d121 1
a121 1
	    " [-S space]\n");
d505 5
d656 5
d772 1
a772 1
	while ((ch = getopt(argc, argv, "B:hlk:n:p:r:sS:v")) != -1) {
d812 7
@


1.7
log
@only update stats when we actually wrote sth, relevant for -n, ok djm
From: Pierre Riteau <pierre.riteau@@gmail.com>
@
text
@a617 1
	const char *errstr;
@


1.6
log
@some minor improvements from Pierre Riteau; ok djm
@
text
@d703 1
a703 1
			if (pfd[i].revents & POLLOUT)
d709 9
a717 4
			if (n == 0) {
				warnx("Remote end closed connection");
				done = -1;
				break;
a718 3
			if (vflag >= 3)
				fprintf(stderr, "write: %zd bytes\n", n);
			stats_update(&sc, n);
d800 1
a800 2
			if (vflag < 2)
				vflag++;
@


1.5
log
@turd polishing (useless chatter removed), ok djm
@
text
@d114 6
a119 19
"Usage:\n"
"    tcpbench -l\n"
"    tcpbench [-v] [-p port] [-r rate] [host]\n"
"    tcpbench [-v] [-p port] [-r rate] -s\n"
"Options:\n"
"    -B buf       Set read/write buffer space (default: %u)\n"
"    -h           Display this help\n"
"    -k var[,var] List of kernel PCB, TCB and socket variables to display\n"
"                 (requires read access to /dev/kmem)\n"
"    -l           List kernel vars and exit\n"
"    -n number    use given numer of tcp connections (default: 1)\n"
"    -p port      Specify port (default: %s)\n"
"    -s           Server mode - listen for connections\n"
"                 (default: client mode - initiate connection)\n"
"    -r rate      Statistics display interval in milliseconds, or 0 to\n"
"                 disable (default: %d)\n"
"    -S space     Set socket send/receive space (default: kernel default)\n"
"    -v           Increase verbosity\n",
	    DEFAULT_BUF, DEFAULT_PORT, DEFAULT_STATS_INTERVAL);
@


1.4
log
@allow the tcpbench client side to open more than one tcp connection
to the server and use them simultaniously. ok djm ryan
@
text
@d630 1
a630 1
	u_int i;
d653 1
a653 1
			if (vflag)
d691 1
d694 2
@


1.3
log
@fix uninitialised variable; from ray@@
@
text
@a120 1
"    -l           List kernel vars and exit\n"
d123 2
d620 2
a621 2
clientloop(kvm_t *kvmh, u_long ktcbtab, struct addrinfo *aitop,
    int vflag, int rflag, char **kflag, int Sflag, int Bflag)
d625 3
a627 3
	int r, sock;
	struct addrinfo *ai;
	struct pollfd pfd;
d630 2
d635 18
a652 8
	for (sock = -1, ai = aitop; ai != NULL; ai = ai->ai_next) {
		saddr_ntop(ai->ai_addr, ai->ai_addrlen, tmp, sizeof(tmp));
		if (vflag)
			fprintf(stderr, "Trying %s\n", tmp);
		if ((sock = socket(ai->ai_family, ai->ai_socktype,
		    ai->ai_protocol)) == -1) {
			if (ai->ai_next == NULL)
				err(1, "socket");
d654 24
a677 2
				warn("socket");
			continue;
d679 12
a690 15
		if (Sflag) {
			if (setsockopt(sock, SOL_SOCKET, SO_SNDBUF,
			    &Sflag, sizeof(Sflag)) == -1)
				warn("set TCP send buffer size");
		}
		if (connect(sock, ai->ai_addr, ai->ai_addrlen) != 0) {
			if (ai->ai_next == NULL)
				err(1, "connect");
			if (vflag)
				warn("connect");
			close(sock);
			sock = -1;
			continue;
		}
		break;
a691 3
	freeaddrinfo(aitop);
	if (sock == -1)
		errx(1, "No host found");
a694 6
	if ((r = fcntl(sock, F_GETFL, 0)) == -1)
		err(1, "fcntl(F_GETFL)");
	r |= O_NONBLOCK;
	if (fcntl(sock, F_SETFL, r) == -1)
		err(1, "fcntl(F_SETFL, O_NONBLOCK)");

a699 4
	bzero(&pfd, sizeof(pfd));
	pfd.fd = sock;
	pfd.events = POLLOUT;

d707 1
a707 1
		if (poll(&pfd, 1, INFTIM) == -1) {
d712 15
a726 9
		if ((n = write(pfd.fd, buf, Bflag)) == -1) {
			if (errno == EINTR || errno == EAGAIN)
				continue;
			err(1, "write");
		}
		if (n == 0) {
			warnx("Remote end closed connection");
			done = -1;
			break;
a727 3
		if (vflag >= 3)
			fprintf(stderr, "write: %zd bytes\n", n);
		stats_update(&sc, n);
d765 1
d769 1
a769 1
	while ((ch = getopt(argc, argv, "B:hlk:p:r:sS:v")) != -1) {
d811 6
d827 4
d834 10
a843 8
	bzero(&hints, sizeof(hints));
	hints.ai_socktype = SOCK_STREAM;
	hints.ai_flags = sflag ? AI_PASSIVE : 0;
	if ((herr = getaddrinfo(host, port, &hints, &aitop)) != 0) {
		if (herr == EAI_SYSTEM)
			err(1, "getaddrinfo");
		else
			errx(1, "getaddrinfo: %s", gai_strerror(herr));
d860 2
a861 2
		clientloop(kvmh, nl[0].n_value, aitop, vflag, rflag, kflag,
		    Sflag, Bflag);
@


1.2
log
@s/bench/tcpbench/ in usage(); spotted by schellekens.dries AT gmail.com
@
text
@d141 2
a142 2
	if (getnameinfo(addr, alen, hbuf, sizeof(hbuf), pbuf, sizeof(pbuf),
	    NI_NUMERICHOST|NI_NUMERICSERV) != 0) {
d737 1
a737 1
	kvm_t *kvmh;
@


1.1
log
@Initial revision
@
text
@d115 3
a117 3
"    bench -l\n"
"    bench [-v] [-p port] [-r rate] [host]\n"
"    bench [-v] [-p port] [-r rate] -s\n"
@


1.1.1.1
log
@import tcpbench, a small TCP benchmarking tool that can also sample
relevant kernel variables via kvm(3)

ok dlg@@ deraadt@@
@
text
@@
