head	1.13;
access;
symbols
	OPENBSD_6_0:1.13.0.4
	OPENBSD_6_0_BASE:1.13
	OPENBSD_5_9:1.13.0.2
	OPENBSD_5_9_BASE:1.13
	OPENBSD_5_8:1.11.0.6
	OPENBSD_5_8_BASE:1.11
	OPENBSD_5_7:1.11.0.2
	OPENBSD_5_7_BASE:1.11
	OPENBSD_5_6:1.10.0.22
	OPENBSD_5_6_BASE:1.10
	OPENBSD_5_5:1.10.0.20
	OPENBSD_5_5_BASE:1.10
	OPENBSD_5_4:1.10.0.16
	OPENBSD_5_4_BASE:1.10
	OPENBSD_5_3:1.10.0.14
	OPENBSD_5_3_BASE:1.10
	OPENBSD_5_2:1.10.0.12
	OPENBSD_5_2_BASE:1.10
	OPENBSD_5_1_BASE:1.10
	OPENBSD_5_1:1.10.0.10
	OPENBSD_5_0:1.10.0.8
	OPENBSD_5_0_BASE:1.10
	OPENBSD_4_9:1.10.0.6
	OPENBSD_4_9_BASE:1.10
	OPENBSD_4_8:1.10.0.4
	OPENBSD_4_8_BASE:1.10
	OPENBSD_4_7:1.10.0.2
	OPENBSD_4_7_BASE:1.10
	OPENBSD_4_6:1.9.0.8
	OPENBSD_4_6_BASE:1.9
	OPENBSD_4_5:1.9.0.4
	OPENBSD_4_5_BASE:1.9
	OPENBSD_4_4:1.9.0.2
	OPENBSD_4_4_BASE:1.9
	OPENBSD_4_3:1.7.0.16
	OPENBSD_4_3_BASE:1.7
	OPENBSD_4_2:1.7.0.14
	OPENBSD_4_2_BASE:1.7
	OPENBSD_4_1:1.7.0.12
	OPENBSD_4_1_BASE:1.7
	OPENBSD_4_0:1.7.0.10
	OPENBSD_4_0_BASE:1.7
	OPENBSD_3_9:1.7.0.8
	OPENBSD_3_9_BASE:1.7
	OPENBSD_3_8:1.7.0.6
	OPENBSD_3_8_BASE:1.7
	OPENBSD_3_7:1.7.0.4
	OPENBSD_3_7_BASE:1.7
	OPENBSD_3_6:1.7.0.2
	OPENBSD_3_6_BASE:1.7
	OPENBSD_3_5:1.6.0.4
	OPENBSD_3_5_BASE:1.6
	OPENBSD_3_4:1.6.0.2
	OPENBSD_3_4_BASE:1.6
	OPENBSD_3_3:1.4.0.6
	OPENBSD_3_3_BASE:1.4
	OPENBSD_3_2:1.4.0.4
	OPENBSD_3_2_BASE:1.4
	OPENBSD_3_1:1.4.0.2
	OPENBSD_3_1_BASE:1.4
	OPENBSD_3_0:1.3.0.2
	OPENBSD_3_0_BASE:1.3
	OPENBSD_2_9_BASE:1.2
	OPENBSD_2_9:1.2.0.20
	OPENBSD_2_8:1.2.0.18
	OPENBSD_2_8_BASE:1.2
	OPENBSD_2_7:1.2.0.16
	OPENBSD_2_7_BASE:1.2
	OPENBSD_2_6:1.2.0.14
	OPENBSD_2_6_BASE:1.2
	OPENBSD_2_5:1.2.0.12
	OPENBSD_2_5_BASE:1.2
	OPENBSD_2_4:1.2.0.10
	OPENBSD_2_4_BASE:1.2
	OPENBSD_2_3:1.2.0.8
	OPENBSD_2_3_BASE:1.2
	OPENBSD_2_2:1.2.0.6
	OPENBSD_2_2_BASE:1.2
	OPENBSD_2_1:1.2.0.4
	OPENBSD_2_1_BASE:1.2
	OPENBSD_2_0:1.2.0.2
	OPENBSD_2_0_BASE:1.2
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.13
date	2015.10.09.01.37.09;	author deraadt;	state Exp;
branches;
next	1.12;
commitid	sbrB3Q5CNxcwZpfU;

1.12
date	2015.10.07.06.00.33;	author deraadt;	state Exp;
branches;
next	1.11;
commitid	yGUKAoCI7GO4WvSe;

1.11
date	2015.01.16.06.40.13;	author deraadt;	state Exp;
branches;
next	1.10;
commitid	Uu5nFG3wCl0LACBb;

1.10
date	2009.10.27.23.59.46;	author deraadt;	state Exp;
branches;
next	1.9;

1.9
date	2008.07.29.18.25.28;	author sobrado;	state Exp;
branches;
next	1.8;

1.8
date	2008.07.05.20.59.42;	author sobrado;	state Exp;
branches;
next	1.7;

1.7
date	2004.04.09.22.54.02;	author millert;	state Exp;
branches;
next	1.6;

1.6
date	2003.06.10.22.20.53;	author deraadt;	state Exp;
branches;
next	1.5;

1.5
date	2003.06.03.02.56.21;	author millert;	state Exp;
branches;
next	1.4;

1.4
date	2001.11.19.19.02.17;	author mpech;	state Exp;
branches;
next	1.3;

1.3
date	2001.07.12.05.17.28;	author deraadt;	state Exp;
branches;
next	1.2;

1.2
date	96.06.26.05.42.24;	author deraadt;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.46.31;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.46.31;	author deraadt;	state Exp;
branches;
next	;


desc
@@


1.13
log
@Change all tame callers to namechange to pledge(2).
@
text
@/*	$OpenBSD: uuencode.c,v 1.12 2015/10/07 06:00:33 deraadt Exp $	*/
/*	$FreeBSD: uuencode.c,v 1.18 2004/01/22 07:23:35 grehan Exp $	*/

/*-
 * Copyright (c) 1983, 1993
 *	The Regents of the University of California.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */

/*
 * Encode a file so it can be mailed to a remote system.
 */

#include <sys/socket.h>
#include <sys/stat.h>

#include <netinet/in.h>

#include <err.h>
#include <locale.h>
#include <resolv.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>

void encode(void);
void base64_encode(void);
static void usage(void);

FILE *output;
int mode;
char **av;

enum program_mode {
	MODE_ENCODE,
	MODE_B64ENCODE
} pmode;

int
main(int argc, char *argv[])
{
	struct stat sb;
	int base64, ch;
	char *outfile;
	extern char *__progname;
	static const char *optstr[2] = {
		"mo:",
		"o:"
	};

	base64 = 0;
	outfile = NULL;

	pmode = MODE_ENCODE;
	if (strcmp(__progname, "b64encode") == 0) {
		base64 = 1;
		pmode = MODE_B64ENCODE;
	}

	setlocale(LC_ALL, "");
	while ((ch = getopt(argc, argv, optstr[pmode])) != -1) {
		switch (ch) {
		case 'm':
			base64 = 1;
			break;
		case 'o':
			outfile = optarg;
			break;
		case '?':
		default:
			usage();
		}
	}
	argv += optind;
	argc -= optind;

	if (argc == 2 || outfile) {
		if (pledge("stdio rpath wpath cpath", NULL) == -1)
			err(1, "pledge");
	} else {
		if (pledge("stdio", NULL) == -1)
			err(1, "pledge");
	}

	switch(argc) {
	case 2:			/* optional first argument is input file */
		if (!freopen(*argv, "r", stdin) || fstat(fileno(stdin), &sb))
			err(1, "%s", *argv);
#define	RWX	(S_IRWXU|S_IRWXG|S_IRWXO)
		mode = sb.st_mode & RWX;
		++argv;
		break;
	case 1:
#define	RW	(S_IRUSR|S_IWUSR|S_IRGRP|S_IWGRP|S_IROTH|S_IWOTH)
		mode = RW & ~umask(RW);
		break;
	case 0:
	default:
		usage();
	}

	av = argv;

	if (outfile != NULL) {
		output = fopen(outfile, "w+");
		if (output == NULL)
			err(1, "unable to open %s for output", outfile);
	} else
		output = stdout;
	if (base64)
		base64_encode();
	else
		encode();
	if (ferror(output))
		errx(1, "write error");
	exit(0);
}

/* ENC is the basic 1 character encoding function to make a char printing */
#define	ENC(c) ((c) ? ((c) & 077) + ' ': '`')

/*
 * Copy from in to out, encoding in base64 as you go along.
 */
void
base64_encode(void)
{
	/*
	 * Output must fit into 80 columns, chunks come in 4, leave 1.
	 */
#define	GROUPS	((80 / 4) - 1)
	unsigned char buf[3];
	char buf2[sizeof(buf) * 2 + 1];
	size_t n;
	int rv, sequence;

	sequence = 0;

	fprintf(output, "begin-base64 %o %s\n", mode, *av);
	while ((n = fread(buf, 1, sizeof(buf), stdin))) {
		++sequence;
		rv = b64_ntop(buf, n, buf2, (sizeof(buf2) / sizeof(buf2[0])));
		if (rv == -1)
			errx(1, "b64_ntop: error encoding base64");
		fprintf(output, "%s%s", buf2, (sequence % GROUPS) ? "" : "\n");
	}
	if (sequence % GROUPS)
		fprintf(output, "\n");
	fprintf(output, "====\n");
}

/*
 * Copy from in to out, encoding as you go along.
 */
void
encode(void)
{
	int ch, n;
	char *p;
	char buf[80];

	(void)fprintf(output, "begin %o %s\n", mode, *av);
	while ((n = fread(buf, 1, 45, stdin))) {
		ch = ENC(n);
		if (fputc(ch, output) == EOF)
			break;
		for (p = buf; n > 0; n -= 3, p += 3) {
			/* Pad with nulls if not a multiple of 3. */
			if (n < 3) {
				p[2] = '\0';
				if (n < 2)
					p[1] = '\0';
			}
			ch = *p >> 2;
			ch = ENC(ch);
			if (fputc(ch, output) == EOF)
				break;
			ch = ((*p << 4) & 060) | ((p[1] >> 4) & 017);
			ch = ENC(ch);
			if (fputc(ch, output) == EOF)
				break;
			ch = ((p[1] << 2) & 074) | ((p[2] >> 6) & 03);
			ch = ENC(ch);
			if (fputc(ch, output) == EOF)
				break;
			ch = p[2] & 077;
			ch = ENC(ch);
			if (fputc(ch, output) == EOF)
				break;
		}
		if (fputc('\n', output) == EOF)
			break;
	}
	if (ferror(stdin))
		errx(1, "read error");
	(void)fprintf(output, "%c\nend\n", ENC('\0'));
}

static void
usage(void)
{
	switch (pmode) {
	case MODE_ENCODE:
		(void)fprintf(stderr,
		    "usage: uuencode [-m] [-o output_file] [file] name\n");
		break;
	case MODE_B64ENCODE:
		(void)fprintf(stderr,
		    "usage: b64encode [-o output_file] [file] name\n");
		break;
	}
	exit(1);
}
@


1.12
log
@tame "stdio rpath wpath cpath" or a more mundane "stdio rpath", depending
on which arguments the programs are run under.
ok doug
@
text
@d1 1
a1 1
/*	$OpenBSD: uuencode.c,v 1.11 2015/01/16 06:40:13 deraadt Exp $	*/
d102 2
a103 2
		if (tame("stdio rpath wpath cpath", NULL) == -1)
			err(1, "tame");
d105 2
a106 2
		if (tame("stdio", NULL) == -1)
			err(1, "tame");
@


1.11
log
@Replace <sys/param.h> with <limits.h> and other less dirty headers where
possible.  Annotate <sys/param.h> lines with their current reasons.  Switch
to PATH_MAX, NGROUPS_MAX, HOST_NAME_MAX+1, LOGIN_NAME_MAX, etc.  Change
MIN() and MAX() to local definitions of MINIMUM() and MAXIMUM() where
sensible to avoid pulling in the pollution.  These are the files confirmed
through binary verification.
ok guenther, millert, doug (helped with the verification protocol)
@
text
@d1 1
a1 1
/*	$OpenBSD: uuencode.c,v 1.10 2009/10/27 23:59:46 deraadt Exp $	*/
d100 8
@


1.10
log
@rcsid[] and sccsid[] and copyright[] are essentially unmaintained (and
unmaintainable).  these days, people use source.  these id's do not provide
any benefit, and do hurt the small install media
(the 33,000 line diff is essentially mechanical)
ok with the idea millert, ok dms
@
text
@d1 1
a1 1
/*	$OpenBSD: uuencode.c,v 1.9 2008/07/29 18:25:28 sobrado Exp $	*/
a36 1
#include <sys/param.h>
@


1.9
log
@an enum specifier is more elegant than a set of #defines;
storing the program mode variable (pmode) as a global let us have
a more consistent prototype for usage().

changes suggested by pyr@@.

ok millert@@, pyr@@
@
text
@d1 1
a1 1
/*	$OpenBSD: uuencode.c,v 1.8 2008/07/05 20:59:42 sobrado Exp $	*/
a31 13

#ifndef lint
static const char copyright[] =
"@@(#) Copyright (c) 1983, 1993\n\
	The Regents of the University of California.  All rights reserved.\n";
#endif /* not lint */

#ifndef lint
#if 0
static const char sccsid[] = "@@(#)uuencode.c	8.2 (Berkeley) 4/2/94";
#endif
static const char rcsid[] = "$OpenBSD: uuencode.c,v 1.8 2008/07/05 20:59:42 sobrado Exp $";
#endif /* not lint */
@


1.8
log
@each utility must have its own usage and its own set of options;
b64encode and b64decode are equivalent to running uuencode and uudecode
respectively with the -m flag specified, so this flag should not be
available in these utilities; while here, fix synopsis.

based on millert's diff for compress/gzip.

ok millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: uuencode.c,v 1.7 2004/04/09 22:54:02 millert Exp $	*/
d43 1
a43 1
static const char rcsid[] = "$OpenBSD: uuencode.c,v 1.7 2004/04/09 22:54:02 millert Exp $";
d66 1
a66 1
static void usage(int);
d72 4
a75 5
/*
 * program modes
 */
#define MODE_ENCODE	0
#define MODE_B64ENCODE	1
d81 1
a81 1
	int base64, ch, mode;
d89 1
a89 1
	base64 = mode = 0;
d92 1
d95 1
a95 1
		mode = MODE_B64ENCODE;
d99 1
a99 1
	while ((ch = getopt(argc, argv, optstr[mode])) != -1) {
d109 1
a109 1
			usage(mode);
d129 1
a129 1
		usage(mode);
d230 1
a230 1
usage(int mode)
d232 1
a232 1
	switch (mode) {
@


1.7
log
@Sync with FreeBSD; adds base64 support and other options.
OK deraadt@@, some man page tweaks from jmc@@
@
text
@d1 1
a1 1
/*	$OpenBSD: uuencode.c,v 1.6 2003/06/10 22:20:53 deraadt Exp $	*/
d43 1
a43 1
static const char rcsid[] = "$OpenBSD: uuencode.c,v 1.6 2003/06/10 22:20:53 deraadt Exp $";
d66 1
a66 1
static void usage(void);
d72 6
d82 1
a82 2
	int base64;
	int ch;
d85 4
d90 1
a90 1
	base64 = 0;
d93 1
a93 1
	if (strcmp(__progname, "b64encode") == 0)
d95 2
d99 1
a99 1
	while ((ch = getopt(argc, argv, "mo:")) != -1) {
d109 1
a109 1
			usage();
d129 1
a129 1
		usage();
d230 1
a230 1
usage(void)
d232 10
a241 3
	(void)fprintf(stderr,
	    "usage: uuencode [-m] [-o outfile] [infile] remotefile\n"
	    "       b64encode [-o outfile] [infile] remotefile\n");
@


1.6
log
@mostly ansi cleanup; pval ok
@
text
@d1 2
a2 2
/*	$OpenBSD: uuencode.c,v 1.5 2003/06/03 02:56:21 millert Exp $	*/
/*	$NetBSD: uuencode.c,v 1.7 1994/11/17 07:41:15 jtc Exp $	*/
d33 2
a34 1
char copyright[] =
d37 1
d41 1
a41 1
static char sccsid[] = "@@(#)uuencode.c	8.2 (Berkeley) 4/2/94";
d43 1
a43 1
static char rcsid[] = "$OpenBSD: uuencode.c,v 1.5 2003/06/03 02:56:21 millert Exp $";
a46 2
 * uuencode [input] output
 *
d49 10
a61 4
#include <locale.h>
#include <errno.h>
#include <sys/types.h>
#include <sys/stat.h>
d64 7
a70 2
static void encode(void);
static __dead void usage(void);
d76 10
a85 1
	int mode;
d88 13
a100 3

	while (getopt(argc, argv, "") != -1)
		usage();
d106 2
a107 5
		if (!freopen(*argv, "r", stdin) || fstat(fileno(stdin), &sb)) {
			(void)fprintf(stderr, "uuencode: %s: %s.\n",
			    *argv, strerror(errno));
			exit(1);
		}
d121 14
a134 7
	(void)printf("begin %o %s\n", mode, *argv);
	encode();
	(void)printf("end\n");
	if (ferror(stdout)) {
		(void)fprintf(stderr, "uuencode: write error.\n");
		exit(1);
	}
d142 31
a172 1
 * copy from in to out, encoding as you go along.
d174 1
a174 1
static void
d181 1
d184 1
a184 1
		if (putchar(ch) == EOF)
d187 6
d195 1
a195 1
			if (putchar(ch) == EOF)
d197 1
a197 1
			ch = (*p << 4) & 060 | (p[1] >> 4) & 017;
d199 1
a199 1
			if (putchar(ch) == EOF)
d201 1
a201 1
			ch = (p[1] << 2) & 074 | (p[2] >> 6) & 03;
d203 1
a203 1
			if (putchar(ch) == EOF)
d207 1
a207 1
			if (putchar(ch) == EOF)
d210 1
a210 1
		if (putchar('\n') == EOF)
d213 3
a215 7
	if (ferror(stdin)) {
		(void)fprintf(stderr, "uuencode: read error.\n");
		exit(1);
	}
	ch = ENC('\0');
	(void)putchar(ch);
	(void)putchar('\n');
d221 3
a223 1
	(void)fprintf(stderr,"usage: uuencode [infile] remotefile\n");
@


1.5
log
@Remove the advertising clause in the UCB license which Berkeley
rescinded 22 July 1999.  Proofed by myself and Theo.
@
text
@d1 1
a1 1
/*	$OpenBSD: uuencode.c,v 1.4 2001/11/19 19:02:17 mpech Exp $	*/
d41 1
a41 1
static char rcsid[] = "$OpenBSD: uuencode.c,v 1.4 2001/11/19 19:02:17 mpech Exp $";
d58 2
a59 2
static void encode();
static __dead void usage();
d62 1
a62 3
main(argc, argv)
	int argc;
	char *argv[];
d111 1
a111 1
encode()
d152 1
a152 1
usage()
@


1.4
log
@kill more registers

millert@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: uuencode.c,v 1.3 2001/07/12 05:17:28 deraadt Exp $	*/
d16 1
a16 5
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
d41 1
a41 1
static char rcsid[] = "$OpenBSD: uuencode.c,v 1.3 2001/07/12 05:17:28 deraadt Exp $";
@


1.3
log
@first pass at a -Wall cleanup
@
text
@d1 1
a1 1
/*	$OpenBSD: uuencode.c,v 1.2 1996/06/26 05:42:24 deraadt Exp $	*/
d45 1
a45 1
static char rcsid[] = "$OpenBSD: uuencode.c,v 1.2 1996/06/26 05:42:24 deraadt Exp $";
d119 2
a120 2
	register int ch, n;
	register char *p;
@


1.2
log
@rcsid
@
text
@d1 1
a1 1
/*	$OpenBSD: uuencode.c,v 1.7 1994/11/17 07:41:15 jtc Exp $	*/
d45 1
a45 1
static char rcsid[] = "$OpenBSD: uuencode.c,v 1.7 1994/11/17 07:41:15 jtc Exp $";
d123 1
a123 1
	while (n = fread(buf, 1, 45, stdin)) {
@


1.1
log
@Initial revision
@
text
@d1 1
d45 1
a45 1
static char rcsid[] = "$NetBSD: uuencode.c,v 1.7 1994/11/17 07:41:15 jtc Exp $";
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@
