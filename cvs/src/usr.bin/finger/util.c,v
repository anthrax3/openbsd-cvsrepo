head	1.32;
access;
symbols
	OPENBSD_6_0:1.32.0.4
	OPENBSD_6_0_BASE:1.32
	OPENBSD_5_9:1.32.0.2
	OPENBSD_5_9_BASE:1.32
	OPENBSD_5_8:1.30.0.6
	OPENBSD_5_8_BASE:1.30
	OPENBSD_5_7:1.30.0.2
	OPENBSD_5_7_BASE:1.30
	OPENBSD_5_6:1.24.0.6
	OPENBSD_5_6_BASE:1.24
	OPENBSD_5_5:1.24.0.4
	OPENBSD_5_5_BASE:1.24
	OPENBSD_5_4:1.23.0.16
	OPENBSD_5_4_BASE:1.23
	OPENBSD_5_3:1.23.0.14
	OPENBSD_5_3_BASE:1.23
	OPENBSD_5_2:1.23.0.12
	OPENBSD_5_2_BASE:1.23
	OPENBSD_5_1_BASE:1.23
	OPENBSD_5_1:1.23.0.10
	OPENBSD_5_0:1.23.0.8
	OPENBSD_5_0_BASE:1.23
	OPENBSD_4_9:1.23.0.6
	OPENBSD_4_9_BASE:1.23
	OPENBSD_4_8:1.23.0.4
	OPENBSD_4_8_BASE:1.23
	OPENBSD_4_7:1.23.0.2
	OPENBSD_4_7_BASE:1.23
	OPENBSD_4_6:1.22.0.20
	OPENBSD_4_6_BASE:1.22
	OPENBSD_4_5:1.22.0.16
	OPENBSD_4_5_BASE:1.22
	OPENBSD_4_4:1.22.0.14
	OPENBSD_4_4_BASE:1.22
	OPENBSD_4_3:1.22.0.12
	OPENBSD_4_3_BASE:1.22
	OPENBSD_4_2:1.22.0.10
	OPENBSD_4_2_BASE:1.22
	OPENBSD_4_1:1.22.0.8
	OPENBSD_4_1_BASE:1.22
	OPENBSD_4_0:1.22.0.6
	OPENBSD_4_0_BASE:1.22
	OPENBSD_3_9:1.22.0.4
	OPENBSD_3_9_BASE:1.22
	OPENBSD_3_8:1.22.0.2
	OPENBSD_3_8_BASE:1.22
	OPENBSD_3_7:1.21.0.2
	OPENBSD_3_7_BASE:1.21
	OPENBSD_3_6:1.20.0.4
	OPENBSD_3_6_BASE:1.20
	OPENBSD_3_5:1.20.0.2
	OPENBSD_3_5_BASE:1.20
	OPENBSD_3_4:1.19.0.2
	OPENBSD_3_4_BASE:1.19
	OPENBSD_3_3:1.15.0.10
	OPENBSD_3_3_BASE:1.15
	OPENBSD_3_2:1.15.0.8
	OPENBSD_3_2_BASE:1.15
	OPENBSD_3_1:1.15.0.6
	OPENBSD_3_1_BASE:1.15
	OPENBSD_3_0:1.15.0.4
	OPENBSD_3_0_BASE:1.15
	OPENBSD_2_9_BASE:1.15
	OPENBSD_2_9:1.15.0.2
	OPENBSD_2_8:1.12.0.2
	OPENBSD_2_8_BASE:1.12
	OPENBSD_2_7:1.11.0.4
	OPENBSD_2_7_BASE:1.11
	OPENBSD_2_6:1.11.0.2
	OPENBSD_2_6_BASE:1.11
	OPENBSD_2_5:1.10.0.4
	OPENBSD_2_5_BASE:1.10
	OPENBSD_2_4:1.10.0.2
	OPENBSD_2_4_BASE:1.10
	OPENBSD_2_3:1.9.0.2
	OPENBSD_2_3_BASE:1.9
	OPENBSD_2_2:1.8.0.2
	OPENBSD_2_2_BASE:1.8
	OPENBSD_2_1:1.4.0.4
	OPENBSD_2_1_BASE:1.4
	OPENBSD_2_0:1.4.0.2
	OPENBSD_2_0_BASE:1.4
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.32
date	2015.12.26.20.51.35;	author guenther;	state Exp;
branches;
next	1.31;
commitid	ixyMcIFPirO2EXOW;

1.31
date	2015.08.20.22.32.41;	author deraadt;	state Exp;
branches;
next	1.30;
commitid	0Dp7Dy9FuNZesYo2;

1.30
date	2015.01.16.06.40.07;	author deraadt;	state Exp;
branches;
next	1.29;
commitid	Uu5nFG3wCl0LACBb;

1.29
date	2014.11.19.22.07.13;	author millert;	state Exp;
branches;
next	1.28;
commitid	2UwuX6bArZADBnOl;

1.28
date	2014.11.18.20.54.28;	author krw;	state Exp;
branches;
next	1.27;
commitid	yCis8OrOsfixbKpI;

1.27
date	2014.10.17.20.19.15;	author millert;	state Exp;
branches;
next	1.26;
commitid	dqUOeTefOdI0Aqwp;

1.26
date	2014.10.17.20.16.13;	author millert;	state Exp;
branches;
next	1.25;
commitid	6Q7RRKvgIx9l18Ln;

1.25
date	2014.10.17.08.03.04;	author doug;	state Exp;
branches;
next	1.24;
commitid	CqffT2vMWIuNXDTR;

1.24
date	2013.11.26.13.18.55;	author deraadt;	state Exp;
branches;
next	1.23;

1.23
date	2009.10.27.23.59.38;	author deraadt;	state Exp;
branches;
next	1.22;

1.22
date	2005.08.23.13.43.53;	author espie;	state Exp;
branches;
next	1.21;

1.21
date	2005.03.15.12.28.48;	author niallo;	state Exp;
branches;
next	1.20;

1.20
date	2004.03.15.02.50.29;	author tedu;	state Exp;
branches;
next	1.19;

1.19
date	2003.07.02.21.04.10;	author deraadt;	state Exp;
branches;
next	1.18;

1.18
date	2003.06.25.21.10.55;	author deraadt;	state Exp;
branches;
next	1.17;

1.17
date	2003.06.10.22.20.46;	author deraadt;	state Exp;
branches;
next	1.16;

1.16
date	2003.06.03.02.56.08;	author millert;	state Exp;
branches;
next	1.15;

1.15
date	2001.01.15.18.16.06;	author deraadt;	state Exp;
branches;
next	1.14;

1.14
date	2001.01.15.16.48.07;	author deraadt;	state Exp;
branches;
next	1.13;

1.13
date	2001.01.10.20.10.36;	author deraadt;	state Exp;
branches;
next	1.12;

1.12
date	2000.06.30.16.00.13;	author millert;	state Exp;
branches;
next	1.11;

1.11
date	99.08.17.09.13.15;	author millert;	state Exp;
branches
	1.11.4.1;
next	1.10;

1.10
date	98.07.10.15.45.19;	author mickey;	state Exp;
branches;
next	1.9;

1.9
date	98.01.09.17.17.39;	author millert;	state Exp;
branches;
next	1.8;

1.8
date	97.06.30.06.24.47;	author deraadt;	state Exp;
branches;
next	1.7;

1.7
date	97.06.17.21.00.01;	author kstailey;	state Exp;
branches;
next	1.6;

1.6
date	97.06.02.21.33.28;	author kstailey;	state Exp;
branches;
next	1.5;

1.5
date	97.05.30.23.35.53;	author kstailey;	state Exp;
branches;
next	1.4;

1.4
date	96.08.30.11.39.36;	author deraadt;	state Exp;
branches;
next	1.3;

1.3
date	96.08.07.17.49.49;	author downsj;	state Exp;
branches;
next	1.2;

1.2
date	96.06.26.05.33.19;	author deraadt;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.45.14;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.45.14;	author deraadt;	state Exp;
branches;
next	;

1.11.4.1
date	2000.10.06.21.16.12;	author jason;	state Exp;
branches;
next	;


desc
@@


1.32
log
@Use pread/pwrite instead separate lseek+read/write for lastlog.
Cast to off_t before multiplication to avoid truncation on ILP32

ok kettenis@@ mmcc@@
@
text
@/*	$OpenBSD: util.c,v 1.31 2015/08/20 22:32:41 deraadt Exp $	*/

/*
 * Copyright (c) 1989 The Regents of the University of California.
 * All rights reserved.
 * Portions Copyright (c) 1983, 1995, 1996 Eric P. Allman (woof!)
 *
 * This code is derived from software contributed to Berkeley by
 * Tony Nardo of the Johns Hopkins University/Applied Physics Lab.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */

#include <sys/types.h>
#include <sys/uio.h>
#include <sys/stat.h>
#include <err.h>
#include <stdio.h>
#include <stdlib.h>
#include <ctype.h>
#include <string.h>
#include <paths.h>
#include <errno.h>
#include <fcntl.h>
#include <unistd.h>
#include <vis.h>
#include "finger.h"
#include "extern.h"

char	*estrdup(char *);
WHERE	*walloc(PERSON *pn);
void	find_idle_and_ttywrite(WHERE *);
void	userinfo(PERSON *, struct passwd *);

void
find_idle_and_ttywrite(WHERE *w)
{
	struct stat sb;

	(void)snprintf(tbuf, sizeof(tbuf), "%s%s", _PATH_DEV, w->tty);
	if (stat(tbuf, &sb) < 0) {
		/* Don't bitch about it, just handle it... */
		w->idletime = 0;
		w->writable = 0;

		return;
	}
	w->idletime = now < sb.st_atime ? 0 : now - sb.st_atime;

#define	TALKABLE	0220		/* tty is writable if 220 mode */
	w->writable = ((sb.st_mode & TALKABLE) == TALKABLE);
}

char *
estrdup(char *s)
{
	char *p = strdup(s);
	if (!p)
		err(1, "strdup");
	return (p);
}

void
userinfo(PERSON *pn, struct passwd *pw)
{
	char *p;
	char *bp, name[1024];
	struct stat sb;
	int len;

	pn->realname = pn->office = pn->officephone = pn->homephone = NULL;
	pn->mailrecv = -1;		/* -1 == not_valid */

	pn->uid = pw->pw_uid;
	pn->name = estrdup(pw->pw_name);
	pn->dir = estrdup(pw->pw_dir);
	pn->shell = estrdup(pw->pw_shell);

	(void)strlcpy(bp = tbuf, pw->pw_gecos, sizeof(tbuf));

	/* ampersands get replaced by the login name */
	if (!(p = strsep(&bp, ",")))
		return;
	expandusername(p, pw->pw_name, name, sizeof(name));
	if (stravis(&pn->realname, p, VIS_SAFE|VIS_NOSLASH) == -1)
		err(1, "stravis");
	if ((p = strsep(&bp, ",")) && *p) {
		if (stravis(&pn->office, p, VIS_SAFE|VIS_NOSLASH) == -1)
			err(1, "stravis");
	}
	if ((p = strsep(&bp, ",")) && *p) {
		if (stravis(&pn->officephone, p, VIS_SAFE|VIS_NOSLASH) == -1)
			err(1, "stravis");
	}
	if ((p = strsep(&bp, ",")) && *p) {
		if (stravis(&pn->homephone, p, VIS_SAFE|VIS_NOSLASH) == -1)
			err(1, "stravis");
	}
	len = snprintf(tbuf, sizeof(tbuf), "%s/%s", _PATH_MAILSPOOL,
	    pw->pw_name);
	if (len != -1 && len < sizeof(tbuf)) {
		if (stat(tbuf, &sb) < 0) {
			if (errno != ENOENT) {
				warn("%s", tbuf);
				return;
			}
		} else if (sb.st_size != 0) {
			pn->mailrecv = sb.st_mtime;
			pn->mailread = sb.st_atime;
		}
	}
}

int
match(struct passwd *pw, char *user)
{
	char *p, *t;
	char name[1024];

	(void)strlcpy(p = tbuf, pw->pw_gecos, sizeof(tbuf));

	/* ampersands get replaced by the login name */
	if (!(p = strtok(p, ",")))
		return (0);
	expandusername(p, pw->pw_name, name, sizeof(name));
	for (t = name; (p = strtok(t, "\t ")) != NULL; t = NULL)
		if (!strcasecmp(p, user))
			return (1);
	return (0);
}

/* inspired by usr.sbin/sendmail/util.c::buildfname */
void
expandusername(char *gecos, char *login, char *buf, int buflen)
{
	char *p, *bp;

	/* why do we skip asterisks!?!? */
	if (*gecos == '*')
		gecos++;
	bp = buf;

	/* copy gecos, interpolating & to be full name */
	for (p = gecos; *p != '\0'; p++) {
		if (bp >= &buf[buflen - 1]) {
			/* buffer overflow - just use login name */
			strlcpy(buf, login, buflen);
			buf[buflen - 1] = '\0';
			return;
		}
		if (*p == '&') {
			/* interpolate full name */
			strlcpy(bp, login, buflen - (bp - buf));
			*bp = toupper((unsigned char)*bp);
			bp += strlen(bp);
		}
		else
			*bp++ = *p;
	}
	*bp = '\0';
}

void
enter_lastlog(PERSON *pn)
{
	WHERE *w;
	static int opened, fd;
	struct lastlog ll;
	char doit = 0;

	/* some systems may not maintain lastlog, don't report errors. */
	if (!opened) {
		fd = open(_PATH_LASTLOG, O_RDONLY);
		opened = 1;
	}
	if (fd == -1 ||
	    pread(fd, &ll, sizeof(ll), (off_t)pn->uid * sizeof(ll)) !=
	    sizeof(ll)) {
		/* as if never logged in */
		ll.ll_line[0] = ll.ll_host[0] = '\0';
		ll.ll_time = 0;
	}
	if ((w = pn->whead) == NULL)
		doit = 1;
	else if (ll.ll_time != 0) {
		/* if last login is earlier than some current login */
		for (; !doit && w != NULL; w = w->next)
			if (w->info == LOGGEDIN && w->loginat < ll.ll_time)
				doit = 1;
		/*
		 * and if it's not any of the current logins
		 * can't use time comparison because there may be a small
		 * discrepency since login calls time() twice
		 */
		for (w = pn->whead; doit && w != NULL; w = w->next)
			if (w->info == LOGGEDIN &&
			    strncmp(w->tty, ll.ll_line, UT_LINESIZE) == 0)
				doit = 0;
	}
	if (doit) {
		w = walloc(pn);
		w->info = LASTLOG;
		bcopy(ll.ll_line, w->tty, UT_LINESIZE);
		w->tty[UT_LINESIZE] = 0;
		bcopy(ll.ll_host, w->host, UT_HOSTSIZE);
		w->host[UT_HOSTSIZE] = 0;
		w->loginat = ll.ll_time;
	}
}

void
enter_where(struct utmp *ut, PERSON *pn)
{
	WHERE *w = walloc(pn);

	w->info = LOGGEDIN;
	bcopy(ut->ut_line, w->tty, UT_LINESIZE);
	w->tty[UT_LINESIZE] = 0;
	bcopy(ut->ut_host, w->host, UT_HOSTSIZE);
	w->host[UT_HOSTSIZE] = 0;
	w->loginat = (time_t)ut->ut_time;
	find_idle_and_ttywrite(w);
}

PERSON *
enter_person(struct passwd *pw)
{
	PERSON *pn, **pp;

	for (pp = htab + hash(pw->pw_name);
	    *pp != NULL && strcmp((*pp)->name, pw->pw_name) != 0;
	    pp = &(*pp)->hlink)
		;
	if ((pn = *pp) == NULL) {
		pn = palloc();
		entries++;
		if (phead == NULL)
			phead = ptail = pn;
		else {
			ptail->next = pn;
			ptail = pn;
		}
		pn->next = NULL;
		pn->hlink = NULL;
		*pp = pn;
		userinfo(pn, pw);
		pn->whead = NULL;
	}
	return (pn);
}

PERSON *
find_person(char *name)
{
	PERSON *pn;

	/* name may be only UT_NAMESIZE long and not terminated */
	for (pn = htab[hash(name)];
	    pn != NULL && strncmp(pn->name, name, UT_NAMESIZE) != 0;
	    pn = pn->hlink)
		;
	return (pn);
}

int
hash(char *name)
{
	int h, i;

	h = 0;
	/* name may be only UT_NAMESIZE long and not terminated */
	for (i = UT_NAMESIZE; --i >= 0 && *name;)
		h = ((h << 2 | h >> (HBITS - 2)) ^ *name++) & HMASK;
	return (h);
}

PERSON *
palloc(void)
{
	PERSON *p;

	if ((p = malloc((u_int) sizeof(PERSON))) == NULL)
		err(1, "malloc");
	return (p);
}

WHERE *
walloc(PERSON *pn)
{
	WHERE *w;

	if ((w = malloc((u_int) sizeof(WHERE))) == NULL)
		err(1, "malloc");
	if (pn->whead == NULL)
		pn->whead = pn->wtail = w;
	else {
		pn->wtail->next = w;
		pn->wtail = w;
	}
	w->next = NULL;
	return (w);
}

char *
prphone(char *num)
{
	char *p;
	int len;
	static char pbuf[15];

	/* don't touch anything if the user has their own formatting */
	for (p = num; *p; ++p)
		if (!isdigit((unsigned char)*p))
			return (num);
	len = p - num;
	p = pbuf;
	switch (len) {
	case 11:			/* +0-123-456-7890 */
		*p++ = '+';
		*p++ = *num++;
		*p++ = '-';
		/* FALLTHROUGH */
	case 10:			/* 012-345-6789 */
		*p++ = *num++;
		*p++ = *num++;
		*p++ = *num++;
		*p++ = '-';
		/* FALLTHROUGH */
	case 7:				/* 012-3456 */
		*p++ = *num++;
		*p++ = *num++;
		*p++ = *num++;
		break;
	case 5:				/* x0-1234 */
	case 4:				/* x1234 */
		*p++ = 'x';
		*p++ = *num++;
		break;
	default:
		return (num);
	}
	if (len != 4) {
		*p++ = '-';
		*p++ = *num++;
	}
	*p++ = *num++;
	*p++ = *num++;
	*p++ = *num++;
	*p = '\0';
	return (pbuf);
}
@


1.31
log
@Do not cast result of malloc/calloc/realloc* if stdlib.h is in scope
ok krw millert
@
text
@d1 1
a1 1
/*	$OpenBSD: util.c,v 1.30 2015/01/16 06:40:07 deraadt Exp $	*/
d199 6
a204 7
	    lseek(fd, (off_t)(pn->uid * sizeof(ll)), SEEK_SET) !=
	    (long)(pn->uid * sizeof(ll)) ||
	    read(fd, (char *)&ll, sizeof(ll)) != sizeof(ll)) {
			/* as if never logged in */
			ll.ll_line[0] = ll.ll_host[0] = '\0';
			ll.ll_time = 0;
		}
@


1.30
log
@Replace <sys/param.h> with <limits.h> and other less dirty headers where
possible.  Annotate <sys/param.h> lines with their current reasons.  Switch
to PATH_MAX, NGROUPS_MAX, HOST_NAME_MAX+1, LOGIN_NAME_MAX, etc.  Change
MIN() and MAX() to local definitions of MINIMUM() and MAXIMUM() where
sensible to avoid pulling in the pollution.  These are the files confirmed
through binary verification.
ok guenther, millert, doug (helped with the verification protocol)
@
text
@d1 1
a1 1
/*	$OpenBSD: util.c,v 1.29 2014/11/19 22:07:13 millert Exp $	*/
d305 1
a305 1
	if ((p = (PERSON *)malloc((u_int) sizeof(PERSON))) == NULL)
d315 1
a315 1
	if ((w = (WHERE *)malloc((u_int) sizeof(WHERE))) == NULL)
@


1.29
log
@Use stravis() instead of a custom() strvis + mallocarray wrapper.
OK tedu@@ tobias@@
@
text
@d1 1
a1 1
/*	$OpenBSD: util.c,v 1.28 2014/11/18 20:54:28 krw Exp $	*/
a37 1
#include <sys/param.h>
@


1.28
log
@Nuke more obvious #include duplications.

ok deraadt@@ millert@@ tedu@@
@
text
@d1 1
a1 1
/*	$OpenBSD: util.c,v 1.27 2014/10/17 20:19:15 millert Exp $	*/
d92 1
d95 1
d108 15
a122 8
	pn->realname = vs(name);
	pn->office = ((p = strsep(&bp, ",")) && *p) ?
	    vs(p) : NULL;
	pn->officephone = ((p = strsep(&bp, ",")) && *p) ?
	    vs(p) : NULL;
	pn->homephone = ((p = strsep(&bp, ",")) && *p) ?
	    vs(p) : NULL;
	(void)snprintf(tbuf, sizeof(tbuf), "%s/%s", _PATH_MAILSPOOL,
d124 9
a132 5
	pn->mailrecv = -1;		/* -1 == not_valid */
	if (stat(tbuf, &sb) < 0) {
		if (errno != ENOENT) {
			warn("%s", tbuf);
			return;
a133 3
	} else if (sb.st_size != 0) {
		pn->mailrecv = sb.st_mtime;
		pn->mailread = sb.st_atime;
a374 19
}

/*
 * Like strvis(), but use malloc() to get the space and returns a pointer
 * to the destination string.
 *
 * The caller is responsible for free()'ing the returned string.
 */
char *
vs(const char *src)
{
	char *dst;

	/* This will allocate 3 extra bytes but gives overflow protection. */
	dst = reallocarray(NULL, 4, strlen(src) + 1);
	if (dst == NULL)
		err(1, "reallocarray");
	strvis(dst, src, VIS_SAFE|VIS_NOSLASH);
	return (dst);
@


1.27
log
@Instead of doing strvis() of gecos string on output, do it when
storing them in struct person since they are only used for output.
Uses reallocarray() for overflow detection. OK deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: util.c,v 1.26 2014/10/17 20:16:13 millert Exp $	*/
a49 1
#include <err.h>
@


1.26
log
@Use strlcpy() instead of strncpy() when making a copy of pw_gecos.
@
text
@d1 1
a1 1
/*	$OpenBSD: util.c,v 1.25 2014/10/17 08:03:04 doug Exp $	*/
a58 17
struct storage {
	struct storage *next;
	char a[1];
};

void
free_storage(struct storage *st)
{
	struct storage *nx;

	while (st != NULL) {
		nx = st->next;
		free(st);
		st = nx;
	}
}

d107 1
a107 1
	pn->realname = estrdup(name);
d109 1
a109 1
	    estrdup(p) : NULL;
d111 1
a111 1
	    estrdup(p) : NULL;
d113 1
a113 1
	    estrdup(p) : NULL;
d368 3
a370 2
/* Like strvis(), but use malloc() to get the space and return a pointer
 * to the beginning of the converted string, not the end.
d375 1
a375 1
vs(struct storage **exist, char *src)
a377 8
	struct storage *n;

	if ((n = malloc(sizeof(struct storage) + 4 * strlen(src) + 1)) == NULL)
		err(1, "malloc failed");
	n->next = *exist;
	*exist = n;

	dst = n->a;
d379 4
@


1.25
log
@strvis() requires that the buffer is at least 4 * srclen + 1.

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: util.c,v 1.24 2013/11/26 13:18:55 deraadt Exp $	*/
d118 1
a118 1
	(void)strncpy(bp = tbuf, pw->pw_gecos, sizeof(tbuf));
d151 1
a151 1
	(void)strncpy(p = tbuf, pw->pw_gecos, sizeof(tbuf));
@


1.24
log
@unsigned char casts for ctype
ok krw
@
text
@d1 1
a1 1
/*	$OpenBSD: util.c,v 1.23 2009/10/27 23:59:38 deraadt Exp $	*/
d396 1
a396 1
	if ((n = malloc(sizeof(struct storage) + 4 * strlen(src))) == NULL)
@


1.23
log
@rcsid[] and sccsid[] and copyright[] are essentially unmaintained (and
unmaintainable).  these days, people use source.  these id's do not provide
any benefit, and do hurt the small install media
(the 33,000 line diff is essentially mechanical)
ok with the idea millert, ok dms
@
text
@d1 1
a1 1
/*	$OpenBSD: util.c,v 1.22 2005/08/23 13:43:53 espie Exp $	*/
d185 1
a185 1
			*bp = toupper(*bp);
d345 1
a345 1
		if (!isdigit(*p))
@


1.22
log
@use vis() consistently in field printing.

Replace vs() with a version that logs its memory usage, so that it
can be cleaned up after each entry.

okay millert@@, delegated by deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: util.c,v 1.21 2005/03/15 12:28:48 niallo Exp $	*/
a34 5

#ifndef lint
/*static char sccsid[] = "from: @@(#)util.c	5.14 (Berkeley) 1/17/91";*/
static const char rcsid[] = "$OpenBSD: util.c,v 1.21 2005/03/15 12:28:48 niallo Exp $";
#endif /* not lint */
@


1.21
log
@change some silly snprintf(buf, buflen, "%s", login) calls to just use
strlcpy(buf, login, buflen)

ok otto@@ henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: util.c,v 1.20 2004/03/15 02:50:29 tedu Exp $	*/
d38 1
a38 1
static const char rcsid[] = "$OpenBSD: util.c,v 1.20 2004/03/15 02:50:29 tedu Exp $";
d64 17
d396 1
a396 1
vs(char *src)
d399 1
d401 1
a401 1
	if ((dst = malloc((4 * strlen(src)) + 1)) == NULL)
d403 4
@


1.20
log
@Wall, commons, little knf
@
text
@d1 1
a1 1
/*	$OpenBSD: util.c,v 1.19 2003/07/02 21:04:10 deraadt Exp $	*/
d38 1
a38 1
static const char rcsid[] = "$OpenBSD: util.c,v 1.19 2003/07/02 21:04:10 deraadt Exp $";
d166 1
a166 1
			snprintf(buf, buflen, "%s", login);
d172 1
a172 1
			snprintf(bp, buflen - (bp - buf), "%s", login);
@


1.19
log
@protos
@
text
@d1 1
a1 1
/*	$OpenBSD: util.c,v 1.18 2003/06/25 21:10:55 deraadt Exp $	*/
d38 1
a38 1
static char rcsid[] = "$OpenBSD: util.c,v 1.18 2003/06/25 21:10:55 deraadt Exp $";
d143 1
a143 1
		return(0);
d147 2
a148 2
			return(1);
	return(0);
d251 2
a252 2
	     *pp != NULL && strcmp((*pp)->name, pw->pw_name) != 0;
	     pp = &(*pp)->hlink)
d269 1
a269 1
	return(pn);
d279 2
a280 2
	     pn != NULL && strncmp(pn->name, name, UT_NAMESIZE) != 0;
	     pn = pn->hlink)
d282 1
a282 1
	return(pn);
d294 1
a294 1
	return(h);
d304 1
a304 1
	return(p);
d321 1
a321 1
	return(w);
d334 1
a334 1
			return(num);
d337 1
a337 1
	switch(len) {
d360 1
a360 1
		return(num);
d370 1
a370 1
	return(pbuf);
d387 1
a387 1
	return(dst);
@


1.18
log
@delete junk protos
@
text
@d1 1
a1 1
/*	$OpenBSD: util.c,v 1.17 2003/06/10 22:20:46 deraadt Exp $	*/
d38 1
a38 1
static char rcsid[] = "$OpenBSD: util.c,v 1.17 2003/06/10 22:20:46 deraadt Exp $";
d59 4
a62 2
char *estrdup(char *);
WHERE *walloc(PERSON *pn);
@


1.17
log
@mostly ansi cleanup; pval ok
@
text
@d1 1
a1 1
/*	$OpenBSD: util.c,v 1.16 2003/06/03 02:56:08 millert Exp $	*/
d38 1
a38 1
static char rcsid[] = "$OpenBSD: util.c,v 1.16 2003/06/03 02:56:08 millert Exp $";
d60 1
@


1.16
log
@Remove the advertising clause in the UCB license which Berkeley
rescinded 22 July 1999.  Proofed by myself and Theo.
@
text
@d1 1
a1 1
/*	$OpenBSD: util.c,v 1.15 2001/01/15 18:16:06 deraadt Exp $	*/
d38 1
a38 1
static char rcsid[] = "$OpenBSD: util.c,v 1.15 2001/01/15 18:16:06 deraadt Exp $";
d62 1
a62 2
find_idle_and_ttywrite(w)
	WHERE *w;
d90 1
a90 3
userinfo(pn, pw)
	PERSON *pn;
	struct passwd *pw;
d131 1
a131 3
match(pw, user)
	struct passwd *pw;
	char *user;
d150 1
a150 5
expandusername(gecos, login, buf, buflen)
	char *gecos;
	char *login;
	char *buf;
	int buflen;
d180 1
a180 2
enter_lastlog(pn)
	PERSON *pn;
d229 1
a229 3
enter_where(ut, pn)
	struct utmp *ut;
	PERSON *pn;
d243 1
a243 2
enter_person(pw)
	struct passwd *pw;
d270 1
a270 2
find_person(name)
	char *name;
d283 1
a283 2
hash(name)
	char *name;
d295 1
a295 1
palloc()
d305 1
a305 2
walloc(pn)
	PERSON *pn;
d322 1
a322 2
prphone(num)
	char *num;
d376 1
a376 2
vs(src)
	char *src;
@


1.15
log
@typo
@
text
@d1 1
a1 1
/*	$OpenBSD: util.c,v 1.14 2001/01/15 16:48:07 deraadt Exp $	*/
d19 1
a19 5
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
d38 1
a38 1
static char rcsid[] = "$OpenBSD: util.c,v 1.14 2001/01/15 16:48:07 deraadt Exp $";
@


1.14
log
@oops
@
text
@d1 1
a1 1
/*	$OpenBSD: util.c,v 1.13 2001/01/10 20:10:36 deraadt Exp $	*/
d42 1
a42 1
static char rcsid[] = "$OpenBSD: util.c,v 1.13 2001/01/10 20:10:36 deraadt Exp $";
d90 1
a90 1
		err(1, "stdup");
@


1.13
log
@error out for strdup() failures
@
text
@d1 1
a1 1
/*	$OpenBSD: util.c,v 1.12 2000/06/30 16:00:13 millert Exp $	*/
d42 1
a42 1
static char rcsid[] = "$OpenBSD: util.c,v 1.12 2000/06/30 16:00:13 millert Exp $";
d89 1
a89 1
	if (p)
@


1.12
log
@warnx?/errx? paranoia (use "%s" not a bare string unless it is a
constant).  These are not security holes but it is worth fixing
them anyway both for robustness and so folks looking for examples
in the tree are not misled into doing something potentially dangerous.
Furthermore, it is a bad idea to assume that pathnames will not
include '%' in them and that error routines don't return strings
with '%' in them (especially in light of the possibility of locales).
@
text
@d1 1
a1 1
/*	$OpenBSD: util.c,v 1.11 1999/08/17 09:13:15 millert Exp $	*/
d42 1
a42 1
static char rcsid[] = "$OpenBSD: util.c,v 1.11 1999/08/17 09:13:15 millert Exp $";
d63 2
d85 9
d106 3
a108 3
	pn->name = strdup(pw->pw_name);
	pn->dir = strdup(pw->pw_dir);
	pn->shell = strdup(pw->pw_shell);
d116 1
a116 1
	pn->realname = strdup(name);
d118 1
a118 1
	    strdup(p) : NULL;
d120 1
a120 1
	    strdup(p) : NULL;
d122 1
a122 1
	    strdup(p) : NULL;
@


1.11
log
@More <sys/file.h> vs. <fcntl.h> and open() flags fixes.
@
text
@d1 1
a1 1
/*	$OpenBSD: util.c,v 1.10 1998/07/10 15:45:19 mickey Exp $	*/
d42 1
a42 1
static char rcsid[] = "$OpenBSD: util.c,v 1.10 1998/07/10 15:45:19 mickey Exp $";
d117 1
a117 1
			warn(tbuf);
@


1.11.4.1
log
@Pull in patch from current (even more to come):
Fix (millert):
warnx?/errx? paranoia (use "%s" not a bare string unless it is a
constant).  These are not security holes but it is worth fixing
them anyway both for robustness and so folks looking for examples
in the tree are not misled into doing something potentially dangerous.
Furthermore, it is a bad idea to assume that pathnames will not
include '%' in them and that error routines don't return strings
with '%' in them (especially in light of the possibility of locales).
@
text
@d1 1
a1 1
/*	$OpenBSD: util.c,v 1.12 2000/06/30 16:00:13 millert Exp $	*/
d42 1
a42 1
static char rcsid[] = "$OpenBSD: util.c,v 1.12 2000/06/30 16:00:13 millert Exp $";
d117 1
a117 1
			warn("%s", tbuf);
@


1.10
log
@err/warn
@
text
@d1 1
a1 1
/*	$OpenBSD: util.c,v 1.9 1998/01/09 17:17:39 millert Exp $	*/
d42 1
a42 1
static char rcsid[] = "$OpenBSD: util.c,v 1.9 1998/01/09 17:17:39 millert Exp $";
a48 1
#include <sys/file.h>
d56 1
d192 1
a192 1
		fd = open(_PATH_LASTLOG, O_RDONLY, 0);
@


1.9
log
@Fix PR 379.  Don't recycle the malloc'd space in vs().
@
text
@d1 1
a1 1
/*	$OpenBSD: util.c,v 1.8 1997/06/30 06:24:47 deraadt Exp $	*/
d42 1
a42 1
static char rcsid[] = "$OpenBSD: util.c,v 1.8 1997/06/30 06:24:47 deraadt Exp $";
d59 1
d117 1
a117 2
			(void)fprintf(stderr,
			    "finger: %s: %s\n", tbuf, strerror(errno));
d307 2
a308 4
	if ((p = (PERSON *)malloc((u_int) sizeof(PERSON))) == NULL) {
		(void)fprintf(stderr, "finger: out of space.\n");
		exit(1);
	}
d318 2
a319 4
	if ((w = (WHERE *)malloc((u_int) sizeof(WHERE))) == NULL) {
		(void)fprintf(stderr, "finger: out of space.\n");
		exit(1);
	}
@


1.8
log
@clarify why the long typecast is there
@
text
@d1 1
a1 1
/*	$OpenBSD: util.c,v 1.7 1997/06/17 21:00:01 kstailey Exp $	*/
d42 1
a42 1
static char rcsid[] = "$OpenBSD: util.c,v 1.7 1997/06/17 21:00:01 kstailey Exp $";
d387 1
a387 2
 * Recycle the malloc()ed area on each call.  This leads to a leak which
 * does not grow.
d393 1
a393 1
	static char *dst = NULL;
a394 2
	if (dst != NULL)
		free(dst);
@


1.7
log
@(foo *)NULL -> NULL
@
text
@d1 1
a1 1
/*	$OpenBSD: util.c,v 1.6 1997/06/02 21:33:28 kstailey Exp $	*/
d42 1
a42 1
static char rcsid[] = "$OpenBSD: util.c,v 1.6 1997/06/02 21:33:28 kstailey Exp $";
d197 1
a197 1
	    (long)pn->uid * sizeof(ll) ||
@


1.6
log
@do strvis()ing in sprint.c
@
text
@d1 1
a1 1
/*	$OpenBSD: util.c,v 1.5 1997/05/30 23:35:53 kstailey Exp $	*/
d42 1
a42 1
static char rcsid[] = "$OpenBSD: util.c,v 1.5 1997/05/30 23:35:53 kstailey Exp $";
d140 1
a140 1
	for (t = name; (p = strtok(t, "\t ")) != NULL; t = (char *)NULL)
@


1.5
log
@Integrate changed from NetBSD being careful not to step on our important
stuff (like the -M flag and things.)
@
text
@d1 1
a1 1
/*	$OpenBSD: util.c,v 1.4 1996/08/30 11:39:36 deraadt Exp $	*/
d42 1
a42 1
static char rcsid[] = "$OpenBSD: util.c,v 1.4 1996/08/30 11:39:36 deraadt Exp $";
d50 1
d58 1
d382 21
@


1.4
log
@buf oflow; found by das33@@cornell.edu and us crazy calgary night owls
@
text
@d1 1
a1 1
/*	$OpenBSD: util.c,v 1.3 1996/08/07 17:49:49 downsj Exp $	*/
d6 1
d42 1
a42 1
static char rcsid[] = "$OpenBSD: util.c,v 1.3 1996/08/07 17:49:49 downsj Exp $";
d45 2
d56 1
d58 1
d60 1
d62 1
a62 1
	register WHERE *w;
a63 2
	extern time_t now;
	extern int errno;
d66 1
a66 1
	(void)sprintf(tbuf, "%s%s", _PATH_DEV, w->tty);
d80 1
d82 2
a83 2
	register PERSON *pn;
	register struct passwd *pw;
d85 2
a86 2
	extern time_t now;
	register char *p, *t;
a87 3
	extern int errno;
	char *mbp, *bp, *name;
	int len;
d96 1
a96 5
	/* why do we skip asterisks!?!? */
	mbp = bp = (char *)malloc(strlen(pw->pw_gecos)+1);
	strcpy(bp, pw->pw_gecos);
	if (*bp == '*')
		++bp;
d99 1
a99 2
	if (!(p = strsep(&bp, ","))) {
		free(mbp);
d101 1
a101 16
	}
	for (len = 0, t = p; *p; ++p) {
		len++;
		if (*p == '&')
			len += strlen(pw->pw_name);
	}
	name = (char *)malloc(len + 1);
	for (p = t, t = name; *t = *p; ++p)
		if (*t == '&') {
			(void)strcpy(t, pw->pw_name);
			if (islower(*t))
				*t = toupper(*t);
			while (*++t);
		} else
			++t;
	*t = '\0';
d109 2
a110 1
	(void)sprintf(tbuf, "%s/%s", _PATH_MAILSPOOL, pw->pw_name);
a115 2
			free(name);
			free(mbp);
a121 2
	free(name);
	free(mbp);
d124 1
d129 1
a129 1
	register char *p, *t;
d132 1
a132 4
	/* why do we skip asterisks!?!? */
	(void)strcpy(p = tbuf, pw->pw_gecos);
	if (*p == '*')
		++p;
d137 2
a138 8
	for (t = name; *t = *p; ++p)
		if (*t == '&') {
			(void)strcpy(t, pw->pw_name);
			while (*++t);
		}
		else
			++t;
	for (t = name; p = strtok(t, "\t "); t = (char *)NULL)
d144 36
d181 1
a181 1
	register PERSON *pn;
d183 1
a183 1
	register WHERE *w;
d198 1
a198 1
			ll.ll_line[0] = ll.ll_host[0] = NULL;
d229 1
d234 1
a234 1
	register WHERE *w = walloc(pn);
d247 1
a247 1
	register struct passwd *pw;
d249 1
a249 1
	register PERSON *pn, **pp;
d277 1
a277 1
	register PERSON *pn;
d287 1
d289 1
a289 1
	register char *name;
d291 1
a291 1
	register int h, i;
d296 1
a296 1
		h = ((h << 2 | h >> HBITS - 2) ^ *name++) & HMASK;
d314 1
a314 1
	register PERSON *pn;
d316 1
a316 1
	register WHERE *w;
d336 1
a336 1
	register char *p;
@


1.3
log
@People can be 'logged in' from non-existant devices.
@
text
@d1 1
a1 1
/*	$OpenBSD: util.c,v 1.2 1996/06/26 05:33:19 deraadt Exp $	*/
d41 1
a41 1
static char rcsid[] = "$OpenBSD: util.c,v 1.2 1996/06/26 05:33:19 deraadt Exp $";
d84 2
a85 1
	char *bp, name[1024];
d95 2
a96 1
	(void)strcpy(bp = tbuf, pw->pw_gecos);
d101 2
a102 1
	if (!(p = strsep(&bp, ",")))
d104 8
a111 1
	for (t = name; *t = *p; ++p)
d117 1
a117 2
		}
		else
d119 1
d133 2
d141 2
@


1.2
log
@rcsid
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d41 1
a41 1
static char rcsid[] = "$OpenBSD: util.c,v 1.1.1.1 1995/10/18 08:45:14 deraadt Exp $";
a60 1
	char *strerror();
d62 1
a62 1
	(void)sprintf(tbuf, "%s/%s", _PATH_DEV, w->tty);
d64 4
a67 2
		(void)fprintf(stderr,
		    "finger: %s: %s\n", tbuf, strerror(errno));
@


1.1
log
@Initial revision
@
text
@d1 2
d41 1
a41 1
static char rcsid[] = "$Id: util.c,v 1.6 1995/09/27 01:10:48 jtc Exp $";
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@
