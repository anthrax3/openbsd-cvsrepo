head	1.26;
access;
symbols
	OPENBSD_6_1:1.26.0.6
	OPENBSD_6_1_BASE:1.26
	OPENBSD_6_0:1.26.0.4
	OPENBSD_6_0_BASE:1.26
	OPENBSD_5_9:1.26.0.2
	OPENBSD_5_9_BASE:1.26
	OPENBSD_5_8:1.19.0.6
	OPENBSD_5_8_BASE:1.19
	OPENBSD_5_7:1.19.0.2
	OPENBSD_5_7_BASE:1.19
	OPENBSD_5_6:1.18.0.22
	OPENBSD_5_6_BASE:1.18
	OPENBSD_5_5:1.18.0.20
	OPENBSD_5_5_BASE:1.18
	OPENBSD_5_4:1.18.0.16
	OPENBSD_5_4_BASE:1.18
	OPENBSD_5_3:1.18.0.14
	OPENBSD_5_3_BASE:1.18
	OPENBSD_5_2:1.18.0.12
	OPENBSD_5_2_BASE:1.18
	OPENBSD_5_1_BASE:1.18
	OPENBSD_5_1:1.18.0.10
	OPENBSD_5_0:1.18.0.8
	OPENBSD_5_0_BASE:1.18
	OPENBSD_4_9:1.18.0.6
	OPENBSD_4_9_BASE:1.18
	OPENBSD_4_8:1.18.0.4
	OPENBSD_4_8_BASE:1.18
	OPENBSD_4_7:1.18.0.2
	OPENBSD_4_7_BASE:1.18
	OPENBSD_4_6:1.16.0.26
	OPENBSD_4_6_BASE:1.16
	OPENBSD_4_5:1.16.0.22
	OPENBSD_4_5_BASE:1.16
	OPENBSD_4_4:1.16.0.20
	OPENBSD_4_4_BASE:1.16
	OPENBSD_4_3:1.16.0.18
	OPENBSD_4_3_BASE:1.16
	OPENBSD_4_2:1.16.0.16
	OPENBSD_4_2_BASE:1.16
	OPENBSD_4_1:1.16.0.14
	OPENBSD_4_1_BASE:1.16
	OPENBSD_4_0:1.16.0.12
	OPENBSD_4_0_BASE:1.16
	OPENBSD_3_9:1.16.0.10
	OPENBSD_3_9_BASE:1.16
	OPENBSD_3_8:1.16.0.8
	OPENBSD_3_8_BASE:1.16
	OPENBSD_3_7:1.16.0.6
	OPENBSD_3_7_BASE:1.16
	OPENBSD_3_6:1.16.0.4
	OPENBSD_3_6_BASE:1.16
	OPENBSD_3_5:1.16.0.2
	OPENBSD_3_5_BASE:1.16
	OPENBSD_3_4:1.14.0.2
	OPENBSD_3_4_BASE:1.14
	OPENBSD_3_3:1.12.0.6
	OPENBSD_3_3_BASE:1.12
	OPENBSD_3_2:1.12.0.4
	OPENBSD_3_2_BASE:1.12
	OPENBSD_3_1:1.12.0.2
	OPENBSD_3_1_BASE:1.12
	OPENBSD_3_0:1.11.0.2
	OPENBSD_3_0_BASE:1.11
	OPENBSD_2_9_BASE:1.10
	OPENBSD_2_9:1.10.0.6
	OPENBSD_2_8:1.10.0.4
	OPENBSD_2_8_BASE:1.10
	OPENBSD_2_7:1.10.0.2
	OPENBSD_2_7_BASE:1.10
	OPENBSD_2_6:1.8.0.6
	OPENBSD_2_6_BASE:1.8
	OPENBSD_2_5:1.8.0.4
	OPENBSD_2_5_BASE:1.8
	OPENBSD_2_4:1.8.0.2
	OPENBSD_2_4_BASE:1.8
	OPENBSD_2_3:1.7.0.4
	OPENBSD_2_3_BASE:1.7
	OPENBSD_2_2:1.7.0.2
	OPENBSD_2_2_BASE:1.7
	OPENBSD_2_1:1.6.0.2
	OPENBSD_2_1_BASE:1.6
	OPENBSD_2_0:1.3.0.2
	OPENBSD_2_0_BASE:1.3
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.26
date	2015.11.03.05.13.35;	author mmcc;	state Exp;
branches;
next	1.25;
commitid	5PoiLQasnlqRR1lF;

1.25
date	2015.10.26.16.57.13;	author deraadt;	state Exp;
branches;
next	1.24;
commitid	LA2BNoMQRMGT0dLx;

1.24
date	2015.10.18.03.54.22;	author deraadt;	state Exp;
branches;
next	1.23;
commitid	rQB89Wup6ZhbwGpK;

1.23
date	2015.10.10.20.35.00;	author deraadt;	state Exp;
branches;
next	1.22;
commitid	m38BXhkh3XknrpM6;

1.22
date	2015.10.09.01.37.07;	author deraadt;	state Exp;
branches;
next	1.21;
commitid	sbrB3Q5CNxcwZpfU;

1.21
date	2015.10.03.02.09.33;	author deraadt;	state Exp;
branches;
next	1.20;
commitid	V4Im11Kz2Kapmy5W;

1.20
date	2015.08.20.22.32.41;	author deraadt;	state Exp;
branches;
next	1.19;
commitid	0Dp7Dy9FuNZesYo2;

1.19
date	2015.01.16.06.40.07;	author deraadt;	state Exp;
branches;
next	1.18;
commitid	Uu5nFG3wCl0LACBb;

1.18
date	2009.11.12.15.33.21;	author nicm;	state Exp;
branches;
next	1.17;

1.17
date	2009.10.27.23.59.38;	author deraadt;	state Exp;
branches;
next	1.16;

1.16
date	2004.03.15.02.50.29;	author tedu;	state Exp;
branches;
next	1.15;

1.15
date	2003.10.17.10.56.09;	author jmc;	state Exp;
branches;
next	1.14;

1.14
date	2003.06.10.22.20.46;	author deraadt;	state Exp;
branches;
next	1.13;

1.13
date	2003.06.03.02.56.08;	author millert;	state Exp;
branches;
next	1.12;

1.12
date	2001.11.19.19.02.13;	author mpech;	state Exp;
branches;
next	1.11;

1.11
date	2001.07.04.06.30.44;	author deraadt;	state Exp;
branches;
next	1.10;

1.10
date	2000.01.12.11.08.05;	author aaron;	state Exp;
branches;
next	1.9;

1.9
date	99.12.22.22.30.20;	author downsj;	state Exp;
branches;
next	1.8;

1.8
date	98.07.10.15.45.15;	author mickey;	state Exp;
branches;
next	1.7;

1.7
date	97.05.30.23.35.51;	author kstailey;	state Exp;
branches;
next	1.6;

1.6
date	97.01.17.07.12.31;	author millert;	state Exp;
branches;
next	1.5;

1.5
date	97.01.15.23.42.28;	author millert;	state Exp;
branches;
next	1.4;

1.4
date	96.12.08.13.29.19;	author downsj;	state Exp;
branches;
next	1.3;

1.3
date	96.08.30.11.39.36;	author deraadt;	state Exp;
branches;
next	1.2;

1.2
date	96.06.26.05.33.16;	author deraadt;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.45.14;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.45.14;	author deraadt;	state Exp;
branches;
next	;


desc
@@


1.26
log
@Blank line after pledge call.
@
text
@/*	$OpenBSD: finger.c,v 1.25 2015/10/26 16:57:13 deraadt Exp $	*/

/*
 * Copyright (c) 1989 The Regents of the University of California.
 * All rights reserved.
 *
 * This code is derived from software contributed to Berkeley by
 * Tony Nardo of the Johns Hopkins University/Applied Physics Lab.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */

/*
 * Luke Mewburn <lukem@@netbsd.org> added the following on 961121:
 *    - mail status ("No Mail", "Mail read:...", or "New Mail ...,
 *	Unread since ...".)
 *    - 4 digit phone extensions (3210 is printed as x3210.)
 *    - host/office toggling in short format with -h & -o.
 *    - short day names (`Tue' printed instead of `Jun 21' if the
 *	login time is < 6 days.
 */

/*
 * Finger prints out information about users.  It is not portable since
 * certain fields (e.g. the full user name, office, and phone numbers) are
 * extracted from the gecos field of the passwd file which other UNIXes
 * may not have or may use for other things.
 *
 * There are currently two output formats; the short format is one line
 * per user and displays login name, tty, login time, real name, idle time,
 * and either remote host information (default) or office location/phone
 * number, depending on if -h or -o is used respectively.
 * The long format gives the same information (in a more legible format) as
 * well as home directory, shell, mail info, and .plan/.project files.
 */

#include <sys/file.h>
#include <sys/stat.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <time.h>
#include <unistd.h>
#include <limits.h>
#include <err.h>
#include "finger.h"
#include "extern.h"

time_t now;
int entries, lflag, sflag, mflag, oflag, pplan, Mflag;
char tbuf[1024];
PERSON *htab[HSIZE];
PERSON *phead, *ptail;

int
main(int argc, char *argv[])
{
	extern int optind;
	extern char *__progname;
	int ch;
	char domain[HOST_NAME_MAX+1];
	struct stat sb;

	oflag = 1;		/* default to old "office" behavior */

	while ((ch = getopt(argc, argv, "lmMpsho")) != -1)
		switch(ch) {
		case 'l':
			lflag = 1;		/* long format */
			break;
		case 'm':
			mflag = 1;		/* force exact match of names */
			break;
		case 'M':
			Mflag = 1;		/* allow name matching */
			break;
		case 'p':
			pplan = 1;		/* don't show .plan/.project */
			break;
		case 's':
			sflag = 1;		/* short format */
			break;
		case 'h':
			oflag = 0;		/* remote host info */
			break;
		case 'o':
			oflag = 1;		/* office info */
			break;
		case '?':
		default:
			(void)fprintf(stderr,
			    "usage: %s [-hlMmops] [login ...]\n", __progname);
			exit(1);
		}
	argc -= optind;
	argv += optind;

	/* If a domainname is set, increment mflag. */
	if ((getdomainname(domain, sizeof(domain)) == 0) && domain[0])
		mflag++;
	/* If _PATH_MP_DB is larger than 1MB, increment mflag. */
	if (stat(_PATH_MP_DB, &sb) == 0) {
		if (sb.st_size > 1048576)
			mflag++;
	}

	if (pledge("stdio rpath getpw dns inet", NULL) == -1)
		err(1, "pledge");

	(void)time(&now);
	if (!*argv) {
		/*
		 * Assign explicit "small" format if no names given and -l
		 * not selected.  Force the -s BEFORE we get names so proper
		 * screening will be done.
		 */
		if (pledge("stdio rpath getpw", NULL) == -1)
			err(1, "pledge");

		if (!lflag)
			sflag = 1;	/* if -l not explicit, force -s */
		loginlist();
		if (entries == 0)
			(void)printf("No one logged on.\n");
	} else {
		userlist(argc, argv);
		/*
		 * Assign explicit "large" format if names given and -s not
		 * explicitly stated.  Force the -l AFTER we get names so any
		 * remote finger attempts specified won't be mishandled.
		 */
		if (!sflag)
			lflag = 1;	/* if -s not explicit, force -l */
	}
	if (entries != 0) {
		if (lflag)
			lflag_print();
		else
			sflag_print();
	}
	exit(0);
}

void
loginlist(void)
{
	PERSON *pn;
	struct passwd *pw;
	struct utmp user;
	char name[UT_NAMESIZE + 1];

	if (!freopen(_PATH_UTMP, "r", stdin))
		err(2, _PATH_UTMP);
	name[UT_NAMESIZE] = '\0';
	setpassent(1);
	while (fread((char *)&user, sizeof(user), 1, stdin) == 1) {
		if (!user.ut_name[0])
			continue;
		if ((pn = find_person(user.ut_name)) == NULL) {
			bcopy(user.ut_name, name, UT_NAMESIZE);
			if ((pw = getpwnam(name)) == NULL)
				continue;
			pn = enter_person(pw);
		}
		enter_where(&user, pn);
	}
	endpwent();
	for (pn = phead; lflag && pn != NULL; pn = pn->next)
		enter_lastlog(pn);
}

void
userlist(int argc, char **argv)
{
	int i;
	PERSON *pn;
	PERSON *nethead, **nettail;
	struct utmp user;
	struct passwd *pw;
	int dolocal, *used;

	if (!(used = calloc((u_int)argc, (u_int)sizeof(int))))
		err(2, "malloc");

	/* pull out all network requests */
	for (i = 0, dolocal = 0, nettail = &nethead; i < argc; i++) {
		if (!strchr(argv[i], '@@')) {
			dolocal = 1;
			continue;
		}
		pn = palloc();
		*nettail = pn;
		nettail = &pn->next;
		pn->name = argv[i];
		used[i] = -1;
	}
	*nettail = NULL;

	if (!dolocal)
		goto net;

	if (nettail == &nethead)
		if (pledge("stdio rpath getpw", NULL) == -1)
			err(1, "pledge");

	/*
	 * traverse the list of possible login names and check the login name
	 * and real name against the name specified by the user.
	 */
	setpassent(1);
	if ((mflag - Mflag) > 0) {
		for (i = 0; i < argc; i++)
			if (used[i] >= 0 && (pw = getpwnam(argv[i]))) {
				enter_person(pw);
				used[i] = 1;
			}
	} else while ((pw = getpwent()) != NULL)
		for (i = 0; i < argc; i++)
			if (used[i] >= 0 &&
			    (!strcasecmp(pw->pw_name, argv[i]) ||
			    match(pw, argv[i]))) {
				enter_person(pw);
				used[i] = 1;
			}
	endpwent();

	/* list errors */
	for (i = 0; i < argc; i++)
		if (!used[i])
			warnx("%s: no such user.", argv[i]);

	/* handle network requests */
net:	for (pn = nethead; pn; pn = pn->next) {
		netfinger(pn->name);
		if (pn->next || entries)
			putchar('\n');
	}

	free(used);
	if (entries == 0)
		return;

	/*
	 * Scan thru the list of users currently logged in, saving
	 * appropriate data whenever a match occurs.
	 */
	if (!freopen(_PATH_UTMP, "r", stdin))
		err(1, _PATH_UTMP);
	while (fread((char *)&user, sizeof(user), 1, stdin) == 1) {
		if (!user.ut_name[0])
			continue;
		if ((pn = find_person(user.ut_name)) == NULL)
			continue;
		enter_where(&user, pn);
	}
	for (pn = phead; pn != NULL; pn = pn->next)
		enter_lastlog(pn);
}
@


1.25
log
@Rather than setpassent(1) for the lifetime of the program, use two smaller
windows of setpassent(1) + entpwent()
ok tedu millert
@
text
@d1 1
a1 1
/*	$OpenBSD: finger.c,v 1.24 2015/10/18 03:54:22 deraadt Exp $	*/
d141 1
@


1.24
log
@Add "dns" to the pledges.  Previously these worked because of "inet",
alas "dns" is now a mandatory statement if you want to do dns!
@
text
@d1 1
a1 1
/*	$OpenBSD: finger.c,v 1.23 2015/10/10 20:35:00 deraadt Exp $	*/
a132 1
	setpassent(1);
d176 1
d188 1
d231 1
d246 1
@


1.23
log
@normalize a few more tame request orderings, to help review
@
text
@d1 1
a1 1
/*	$OpenBSD: finger.c,v 1.22 2015/10/09 01:37:07 deraadt Exp $	*/
d129 1
a129 1
	if (pledge("stdio rpath getpw inet", NULL) == -1)
@


1.22
log
@Change all tame callers to namechange to pledge(2).
@
text
@d1 1
a1 1
/*	$OpenBSD: finger.c,v 1.21 2015/10/03 02:09:33 deraadt Exp $	*/
d129 1
a129 1
	if (pledge("stdio getpw rpath inet", NULL) == -1)
d140 1
a140 1
		if (pledge("stdio getpw rpath", NULL) == -1)
d223 1
a223 1
		if (pledge("stdio getpw rpath", NULL) == -1)
@


1.21
log
@finger can either do local users only, or in in remote users.  (who
still runs fingerd?  not many places, it took a while to find a server)
tame "stdio getpw rpath inet" is possible early on, then later when
the network lookups list is consumed, tame "stddio getpw rpath"
@
text
@d1 1
a1 1
/*	$OpenBSD: finger.c,v 1.20 2015/08/20 22:32:41 deraadt Exp $	*/
d129 2
a130 2
	if (tame("stdio getpw rpath inet", NULL) == -1)
		err(1, "tame");
d140 2
a141 2
		if (tame("stdio getpw rpath", NULL) == -1)
			err(1, "tame");
d223 2
a224 2
		if (tame("stdio getpw rpath", NULL) == -1)
			err(1, "tame");
@


1.20
log
@Do not cast result of malloc/calloc/realloc* if stdlib.h is in scope
ok krw millert
@
text
@d1 1
a1 1
/*	$OpenBSD: finger.c,v 1.19 2015/01/16 06:40:07 deraadt Exp $	*/
d129 3
d140 2
d221 4
@


1.19
log
@Replace <sys/param.h> with <limits.h> and other less dirty headers where
possible.  Annotate <sys/param.h> lines with their current reasons.  Switch
to PATH_MAX, NGROUPS_MAX, HOST_NAME_MAX+1, LOGIN_NAME_MAX, etc.  Change
MIN() and MAX() to local definitions of MINIMUM() and MAXIMUM() where
sensible to avoid pulling in the pollution.  These are the files confirmed
through binary verification.
ok guenther, millert, doug (helped with the verification protocol)
@
text
@d1 1
a1 1
/*	$OpenBSD: finger.c,v 1.18 2009/11/12 15:33:21 nicm Exp $	*/
d197 1
a197 1
	if (!(used = (int *)calloc((u_int)argc, (u_int)sizeof(int))))
@


1.18
log
@Fix memory leak found by parfait.

ok deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: finger.c,v 1.17 2009/10/27 23:59:38 deraadt Exp $	*/
a58 1
#include <sys/param.h>
d66 1
d83 1
a83 1
	char domain[MAXHOSTNAMELEN];
@


1.17
log
@rcsid[] and sccsid[] and copyright[] are essentially unmaintained (and
unmaintainable).  these days, people use source.  these id's do not provide
any benefit, and do hurt the small install media
(the 33,000 line diff is essentially mechanical)
ok with the idea millert, ok dms
@
text
@d1 1
a1 1
/*	$OpenBSD: finger.c,v 1.16 2004/03/15 02:50:29 tedu Exp $	*/
d248 1
@


1.16
log
@Wall, commons, little knf
@
text
@d1 1
a1 1
/*	$OpenBSD: finger.c,v 1.15 2003/10/17 10:56:09 jmc Exp $	*/
a43 11

#ifndef lint
static const char copyright[] =
"@@(#) Copyright (c) 1989 The Regents of the University of California.\n\
 All rights reserved.\n";
#endif /* not lint */

#ifndef lint
/*static char sccsid[] = "from: @@(#)finger.c	5.22 (Berkeley) 6/29/90";*/
static const char rcsid[] = "$OpenBSD: finger.c,v 1.15 2003/10/17 10:56:09 jmc Exp $";
#endif /* not lint */
@


1.15
log
@slight update for finger; sort options
@
text
@d1 1
a1 1
/*	$OpenBSD: finger.c,v 1.14 2003/06/10 22:20:46 deraadt Exp $	*/
d46 1
a46 1
char copyright[] =
d53 1
a53 1
static char rcsid[] = "$OpenBSD: finger.c,v 1.14 2003/06/10 22:20:46 deraadt Exp $";
d85 2
@


1.14
log
@mostly ansi cleanup; pval ok
@
text
@d1 1
a1 1
/*	$OpenBSD: finger.c,v 1.13 2003/06/03 02:56:08 millert Exp $	*/
d53 1
a53 1
static char rcsid[] = "$OpenBSD: finger.c,v 1.13 2003/06/03 02:56:08 millert Exp $";
d123 1
a123 1
			    "usage: %s [-lmMpsho] [login ...]\n", __progname);
@


1.13
log
@Remove the advertising clause in the UCB license which Berkeley
rescinded 22 July 1999.  Proofed by myself and Theo.
@
text
@d1 1
a1 1
/*	$OpenBSD: finger.c,v 1.12 2001/11/19 19:02:13 mpech Exp $	*/
d53 1
a53 1
static char rcsid[] = "$OpenBSD: finger.c,v 1.12 2001/11/19 19:02:13 mpech Exp $";
d87 1
a87 3
main(argc, argv)
	int argc;
	char **argv;
d171 1
a171 1
loginlist()
d197 1
a197 3
userlist(argc, argv)
	int argc;
	char **argv;
@


1.12
log
@kill more registers

millert@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: finger.c,v 1.11 2001/07/04 06:30:44 deraadt Exp $	*/
d18 1
a18 5
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
d53 1
a53 1
static char rcsid[] = "$OpenBSD: finger.c,v 1.11 2001/07/04 06:30:44 deraadt Exp $";
@


1.11
log
@ugly bug that lived; santana@@openbsd.org.mx
@
text
@d1 1
a1 1
/*	$OpenBSD: finger.c,v 1.10 2000/01/12 11:08:05 aaron Exp $	*/
d57 1
a57 1
static char rcsid[] = "$OpenBSD: finger.c,v 1.10 2000/01/12 11:08:05 aaron Exp $";
d207 2
a208 2
	register int i;
	register PERSON *pn;
@


1.10
log
@Use MAXHOSTNAMELEN; millert@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: finger.c,v 1.9 1999/12/22 22:30:20 downsj Exp $	*/
d57 1
a57 1
static char rcsid[] = "$OpenBSD: finger.c,v 1.9 1999/12/22 22:30:20 downsj Exp $";
d81 1
d136 1
a136 1
	if ((getdomainname(&domain, sizeof(domain)) == 0) && domain[0])
@


1.9
log
@Add yet another case when user matching is disabled.
@
text
@d1 1
a1 1
/*	$OpenBSD: finger.c,v 1.8 1998/07/10 15:45:15 mickey Exp $	*/
d57 1
a57 1
static char rcsid[] = "$OpenBSD: finger.c,v 1.8 1998/07/10 15:45:15 mickey Exp $";
d97 1
a97 1
	char domain[256];
@


1.8
log
@err/warn
@
text
@d1 1
a1 1
/*	$OpenBSD: finger.c,v 1.7 1997/05/30 23:35:51 kstailey Exp $	*/
d57 1
a57 1
static char rcsid[] = "$OpenBSD: finger.c,v 1.7 1997/05/30 23:35:51 kstailey Exp $";
d76 1
d98 1
d134 1
a134 1
	/* if a domainname is set, increment mflag. */
d137 5
@


1.7
log
@Integrate changed from NetBSD being careful not to step on our important
stuff (like the -M flag and things.)
@
text
@d1 1
a1 1
/*	$OpenBSD: finger.c,v 1.6 1997/01/17 07:12:31 millert Exp $	*/
d57 1
a57 1
static char rcsid[] = "$OpenBSD: finger.c,v 1.6 1997/01/17 07:12:31 millert Exp $";
d80 1
d94 1
d126 1
a126 1
			    "usage: finger [-lmMpsho] [login ...]\n");
d176 2
a177 4
	if (!freopen(_PATH_UTMP, "r", stdin)) {
		(void)fprintf(stderr, "finger: can't read %s.\n", _PATH_UTMP);
		exit(2);
	}
d206 2
a207 4
	if (!(used = (int *)calloc((u_int)argc, (u_int)sizeof(int)))) {
		(void)fprintf(stderr, "finger: out of space.\n");
		exit(1);
	}
d248 1
a248 2
			(void)fprintf(stderr,
			    "finger: %s: no such user.\n", argv[i]);
d264 2
a265 4
	if (!freopen(_PATH_UTMP, "r", stdin)) {
		(void)fprintf( stderr, "finger: can't read %s.\n", _PATH_UTMP);
		exit(1);
	}
@


1.6
log
@r?index -> strr?chr
@
text
@d1 1
a1 1
/*	$OpenBSD: finger.c,v 1.5 1997/01/15 23:42:28 millert Exp $	*/
d40 7
a46 1
 * Mail status reporting added 931007 by Luke Mewburn, <zak@@rmit.edu.au>.
d57 1
a57 1
static char rcsid[] = "$OpenBSD: finger.c,v 1.5 1997/01/15 23:42:28 millert Exp $";
d68 4
a71 3
 * and office location/phone number.  The long format gives the same
 * information (in a more legible format) as well as home directory, shell,
 * mail info, and .plan/.project files.
d78 2
d81 1
d84 1
a84 1
int lflag, sflag, mflag, pplan, Mflag;
a86 3
int	loginlist __P((void));
void	userlist __P((int, char **));

a94 1
	time_t time();
d96 3
a98 1
	while ((ch = getopt(argc, argv, "lmMps")) != -1)
d115 6
d124 1
a124 1
			    "usage: finger [-lmMps] [login ...]\n");
d166 1
a166 1
int
d169 1
a169 1
	register PERSON *pn;
d178 1
a178 1
	name[UT_NAMESIZE] = NULL;
d196 2
a197 2
	register argc;
	register char **argv;
d199 1
a199 1
	register i;
d238 1
a238 1
	} else while (pw = getpwent())
@


1.5
log
@getopt(3) returns -1 when out of args, not EOF, whee!
@
text
@d1 1
a1 1
/*	$OpenBSD: finger.c,v 1.4 1996/12/08 13:29:19 downsj Exp $	*/
d51 1
a51 1
static char rcsid[] = "$OpenBSD: finger.c,v 1.4 1996/12/08 13:29:19 downsj Exp $";
a190 1
	char *index();
d199 1
a199 1
		if (!index(argv[i], '@@')) {
@


1.4
log
@Disable matching by default if a domainname is set, adding -M to reenable it.
@
text
@d1 1
a1 1
/*	$OpenBSD: finger.c,v 1.3 1996/08/30 11:39:36 deraadt Exp $	*/
d51 1
a51 1
static char rcsid[] = "$OpenBSD: finger.c,v 1.3 1996/08/30 11:39:36 deraadt Exp $";
d90 1
a90 1
	while ((ch = getopt(argc, argv, "lmMps")) != EOF)
@


1.3
log
@buf oflow; found by das33@@cornell.edu and us crazy calgary night owls
@
text
@d1 1
a1 1
/*	$OpenBSD: finger.c,v 1.2 1996/06/26 05:33:16 deraadt Exp $	*/
d51 1
a51 1
static char rcsid[] = "$OpenBSD: finger.c,v 1.2 1996/06/26 05:33:16 deraadt Exp $";
d74 1
a74 1
int lflag, sflag, mflag, pplan;
d87 1
d90 1
a90 1
	while ((ch = getopt(argc, argv, "lmps")) != EOF)
d98 3
d110 1
a110 1
			    "usage: finger [-lmps] [login ...]\n");
d116 4
d219 1
a219 1
	if (mflag) {
@


1.2
log
@rcsid
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d51 1
a51 1
static char rcsid[] = "$OpenBSD: finger.c,v 1.1.1.1 1995/10/18 08:45:14 deraadt Exp $";
d77 4
d144 1
d172 1
@


1.1
log
@Initial revision
@
text
@d1 2
d51 1
a51 1
static char rcsid[] = "$Id: finger.c,v 1.4 1994/12/24 16:33:46 cgd Exp $";
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@
