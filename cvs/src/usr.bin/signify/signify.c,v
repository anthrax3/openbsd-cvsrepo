head	1.126;
access;
symbols
	OPENBSD_6_1:1.126.0.2
	OPENBSD_6_1_BASE:1.126
	OPENBSD_6_0:1.106.0.2
	OPENBSD_6_0_BASE:1.106
	OPENBSD_5_9:1.105.0.2
	OPENBSD_5_9_BASE:1.105
	OPENBSD_5_8:1.100.0.6
	OPENBSD_5_8_BASE:1.100
	OPENBSD_5_7:1.100.0.2
	OPENBSD_5_7_BASE:1.100
	OPENBSD_5_6:1.91.0.4
	OPENBSD_5_6_BASE:1.91
	OPENBSD_5_5:1.42.0.2
	OPENBSD_5_5_BASE:1.42;
locks; strict;
comment	@ * @;


1.126
date	2016.10.06.22.38.25;	author espie;	state Exp;
branches;
next	1.125;
commitid	OzAmI9tcYmBSYg9q;

1.125
date	2016.10.05.15.58.50;	author tedu;	state Exp;
branches;
next	1.124;
commitid	NBn9PBBr7LKVXtoD;

1.124
date	2016.10.05.15.48.39;	author tedu;	state Exp;
branches;
next	1.123;
commitid	g6N2of1KhruKVjME;

1.123
date	2016.10.05.14.48.58;	author tedu;	state Exp;
branches;
next	1.122;
commitid	9HX3TFaxOYEkpbMm;

1.122
date	2016.09.27.02.13.27;	author tedu;	state Exp;
branches;
next	1.121;
commitid	ntaFWpreFxnV0rds;

1.121
date	2016.09.27.02.02.47;	author tedu;	state Exp;
branches;
next	1.120;
commitid	flL8cKpIEXpM8UlC;

1.120
date	2016.09.26.21.47.54;	author tedu;	state Exp;
branches;
next	1.119;
commitid	W5xeL7dAFZ1xwGHC;

1.119
date	2016.09.26.17.49.52;	author tedu;	state Exp;
branches;
next	1.118;
commitid	E0L8cupPyFiXmjwC;

1.118
date	2016.09.10.12.23.16;	author deraadt;	state Exp;
branches;
next	1.117;
commitid	AnGIDBkKk8Nr0Dv1;

1.117
date	2016.09.03.12.21.38;	author espie;	state Exp;
branches;
next	1.116;
commitid	vb1NniJQWqXOmFEp;

1.116
date	2016.09.02.21.45.37;	author tedu;	state Exp;
branches;
next	1.115;
commitid	RogToyBPZHbkP7Fw;

1.115
date	2016.09.02.21.31.22;	author tedu;	state Exp;
branches;
next	1.114;
commitid	gF4Pw7QrHW8eyRbJ;

1.114
date	2016.09.02.21.18.50;	author tedu;	state Exp;
branches;
next	1.113;
commitid	I33pKB8CnPERwqlx;

1.113
date	2016.09.02.21.12.03;	author tedu;	state Exp;
branches;
next	1.112;
commitid	UlM0646IluIPxQlz;

1.112
date	2016.09.02.17.27.31;	author espie;	state Exp;
branches;
next	1.111;
commitid	Sgr63kgwjnv5lC5z;

1.111
date	2016.09.02.16.10.56;	author espie;	state Exp;
branches;
next	1.110;
commitid	VZHUiAwayWbKaIVw;

1.110
date	2016.09.02.15.08.48;	author tedu;	state Exp;
branches;
next	1.109;
commitid	DLaGf0MlSc9DHmal;

1.109
date	2016.09.02.14.50.39;	author tedu;	state Exp;
branches;
next	1.108;
commitid	4su9MsSPwA784xOK;

1.108
date	2016.09.01.17.35.23;	author tedu;	state Exp;
branches;
next	1.107;
commitid	jfPkQDe3ZU9ZdFKq;

1.107
date	2016.09.01.17.30.04;	author espie;	state Exp;
branches;
next	1.106;
commitid	bLavMtMHxT0Rt8on;

1.106
date	2016.06.08.04.16.06;	author tedu;	state Exp;
branches;
next	1.105;
commitid	ZuI2SIzODwF7HI0Z;

1.105
date	2015.12.04.11.05.22;	author tedu;	state Exp;
branches;
next	1.104;
commitid	PTvCCdJkb6i5w1jz;

1.104
date	2015.11.02.22.01.10;	author bluhm;	state Exp;
branches;
next	1.103;
commitid	86lhFsLgwjZtLwK6;

1.103
date	2015.10.30.01.57.43;	author tedu;	state Exp;
branches;
next	1.102;
commitid	2aweLGfcap313g3G;

1.102
date	2015.10.09.01.37.08;	author deraadt;	state Exp;
branches;
next	1.101;
commitid	sbrB3Q5CNxcwZpfU;

1.101
date	2015.10.08.16.45.50;	author tedu;	state Exp;
branches;
next	1.100;
commitid	phvN6Jr8GnGvCACY;

1.100
date	2015.01.16.06.16.12;	author tedu;	state Exp;
branches;
next	1.99;
commitid	Um3hDsd8x0WhJxyY;

1.99
date	2015.01.16.06.00.39;	author tedu;	state Exp;
branches;
next	1.98;
commitid	dEagBoWCPIfBvFpW;

1.98
date	2015.01.15.22.21.01;	author tedu;	state Exp;
branches;
next	1.97;
commitid	h1MgwsPD3kMFawyr;

1.97
date	2015.01.09.21.49.59;	author tedu;	state Exp;
branches;
next	1.96;
commitid	dFkwqu6aCmLvAQOB;

1.96
date	2015.01.07.19.53.34;	author tedu;	state Exp;
branches;
next	1.95;
commitid	dfMEu8LuNu6SY2ls;

1.95
date	2014.12.29.14.35.04;	author tedu;	state Exp;
branches;
next	1.94;
commitid	5HmDvCrRXJDr5gjS;

1.94
date	2014.12.29.14.23.17;	author tedu;	state Exp;
branches;
next	1.93;
commitid	ezPbxjJYQmuzBPb6;

1.93
date	2014.12.29.14.16.04;	author tedu;	state Exp;
branches;
next	1.92;
commitid	jplj3CSwYvgHGq6f;

1.92
date	2014.11.20.14.51.42;	author krw;	state Exp;
branches;
next	1.91;
commitid	dOUqRDzYiPQXkCLL;

1.91
date	2014.07.13.18.59.40;	author tedu;	state Exp;
branches;
next	1.90;
commitid	yFom52xqbtXF2Uax;

1.90
date	2014.05.30.21.20.49;	author tedu;	state Exp;
branches;
next	1.89;

1.89
date	2014.05.30.21.17.42;	author tedu;	state Exp;
branches;
next	1.88;

1.88
date	2014.05.16.18.35.01;	author tedu;	state Exp;
branches;
next	1.87;

1.87
date	2014.05.16.17.46.07;	author tedu;	state Exp;
branches;
next	1.86;

1.86
date	2014.05.16.17.42.24;	author tedu;	state Exp;
branches;
next	1.85;

1.85
date	2014.05.16.16.18.33;	author espie;	state Exp;
branches;
next	1.84;

1.84
date	2014.05.15.13.14.15;	author espie;	state Exp;
branches;
next	1.83;

1.83
date	2014.05.14.16.02.34;	author tedu;	state Exp;
branches;
next	1.82;

1.82
date	2014.05.14.15.56.41;	author tedu;	state Exp;
branches;
next	1.81;

1.81
date	2014.05.14.15.55.11;	author tedu;	state Exp;
branches;
next	1.80;

1.80
date	2014.05.14.15.52.24;	author tedu;	state Exp;
branches;
next	1.79;

1.79
date	2014.05.14.15.33.41;	author tedu;	state Exp;
branches;
next	1.78;

1.78
date	2014.05.06.23.50.53;	author tedu;	state Exp;
branches;
next	1.77;

1.77
date	2014.05.06.23.33.04;	author tedu;	state Exp;
branches;
next	1.76;

1.76
date	2014.05.06.23.27.50;	author tedu;	state Exp;
branches;
next	1.75;

1.75
date	2014.05.06.23.24.19;	author tedu;	state Exp;
branches;
next	1.74;

1.74
date	2014.05.06.23.19.46;	author tedu;	state Exp;
branches;
next	1.73;

1.73
date	2014.05.06.23.17.13;	author tedu;	state Exp;
branches;
next	1.72;

1.72
date	2014.04.22.21.24.20;	author tedu;	state Exp;
branches;
next	1.71;

1.71
date	2014.04.22.05.44.40;	author tedu;	state Exp;
branches;
next	1.70;

1.70
date	2014.04.14.00.35.32;	author tedu;	state Exp;
branches;
next	1.69;

1.69
date	2014.03.17.15.19.06;	author tedu;	state Exp;
branches;
next	1.68;

1.68
date	2014.03.17.11.47.06;	author espie;	state Exp;
branches;
next	1.67;

1.67
date	2014.03.17.04.09.39;	author tedu;	state Exp;
branches;
next	1.66;

1.66
date	2014.03.17.03.33.57;	author tedu;	state Exp;
branches;
next	1.65;

1.65
date	2014.03.17.03.10.26;	author tedu;	state Exp;
branches;
next	1.64;

1.64
date	2014.03.17.03.07.10;	author tedu;	state Exp;
branches;
next	1.63;

1.63
date	2014.03.17.02.54.54;	author tedu;	state Exp;
branches;
next	1.62;

1.62
date	2014.03.17.02.10.54;	author tedu;	state Exp;
branches;
next	1.61;

1.61
date	2014.03.17.01.23.58;	author deraadt;	state Exp;
branches;
next	1.60;

1.60
date	2014.03.17.00.01.58;	author tedu;	state Exp;
branches;
next	1.59;

1.59
date	2014.03.16.23.39.42;	author tedu;	state Exp;
branches;
next	1.58;

1.58
date	2014.03.16.23.29.41;	author tedu;	state Exp;
branches;
next	1.57;

1.57
date	2014.03.16.22.43.13;	author tedu;	state Exp;
branches;
next	1.56;

1.56
date	2014.03.16.22.01.35;	author tedu;	state Exp;
branches;
next	1.55;

1.55
date	2014.03.16.20.17.10;	author tedu;	state Exp;
branches;
next	1.54;

1.54
date	2014.03.16.18.12.08;	author tedu;	state Exp;
branches;
next	1.53;

1.53
date	2014.03.16.18.09.49;	author tedu;	state Exp;
branches;
next	1.52;

1.52
date	2014.03.16.18.03.19;	author tedu;	state Exp;
branches;
next	1.51;

1.51
date	2014.03.16.17.58.28;	author tedu;	state Exp;
branches;
next	1.50;

1.50
date	2014.03.07.19.53.33;	author tedu;	state Exp;
branches;
next	1.49;

1.49
date	2014.03.07.19.49.44;	author tedu;	state Exp;
branches;
next	1.48;

1.48
date	2014.03.06.20.04.45;	author tedu;	state Exp;
branches;
next	1.47;

1.47
date	2014.03.06.15.01.58;	author naddy;	state Exp;
branches;
next	1.46;

1.46
date	2014.03.05.23.11.18;	author tedu;	state Exp;
branches;
next	1.45;

1.45
date	2014.03.05.23.03.19;	author tedu;	state Exp;
branches;
next	1.44;

1.44
date	2014.03.05.22.55.07;	author tedu;	state Exp;
branches;
next	1.43;

1.43
date	2014.03.05.22.53.36;	author tedu;	state Exp;
branches;
next	1.42;

1.42
date	2014.03.04.16.44.07;	author tedu;	state Exp;
branches;
next	1.41;

1.41
date	2014.01.22.21.11.03;	author tedu;	state Exp;
branches;
next	1.40;

1.40
date	2014.01.19.23.20.30;	author deraadt;	state Exp;
branches;
next	1.39;

1.39
date	2014.01.19.18.39.34;	author tedu;	state Exp;
branches;
next	1.38;

1.38
date	2014.01.15.00.31.34;	author espie;	state Exp;
branches;
next	1.37;

1.37
date	2014.01.14.21.34.30;	author tedu;	state Exp;
branches;
next	1.36;

1.36
date	2014.01.14.21.33.10;	author tedu;	state Exp;
branches;
next	1.35;

1.35
date	2014.01.14.17.25.06;	author tedu;	state Exp;
branches;
next	1.34;

1.34
date	2014.01.14.17.15.12;	author tedu;	state Exp;
branches;
next	1.33;

1.33
date	2014.01.13.09.42.53;	author espie;	state Exp;
branches;
next	1.32;

1.32
date	2014.01.13.09.41.16;	author espie;	state Exp;
branches;
next	1.31;

1.31
date	2014.01.13.01.40.43;	author tedu;	state Exp;
branches;
next	1.30;

1.30
date	2014.01.12.21.18.52;	author tedu;	state Exp;
branches;
next	1.29;

1.29
date	2014.01.11.04.29.07;	author lteo;	state Exp;
branches;
next	1.28;

1.28
date	2014.01.10.17.52.50;	author deraadt;	state Exp;
branches;
next	1.27;

1.27
date	2014.01.10.17.38.24;	author tedu;	state Exp;
branches;
next	1.26;

1.26
date	2014.01.10.04.49.35;	author tedu;	state Exp;
branches;
next	1.25;

1.25
date	2014.01.10.04.36.58;	author tedu;	state Exp;
branches;
next	1.24;

1.24
date	2014.01.10.04.34.24;	author tedu;	state Exp;
branches;
next	1.23;

1.23
date	2014.01.10.04.23.37;	author deraadt;	state Exp;
branches;
next	1.22;

1.22
date	2014.01.10.04.15.38;	author tedu;	state Exp;
branches;
next	1.21;

1.21
date	2014.01.09.21.19.38;	author jmc;	state Exp;
branches;
next	1.20;

1.20
date	2014.01.09.20.37.25;	author espie;	state Exp;
branches;
next	1.19;

1.19
date	2014.01.09.19.05.21;	author tedu;	state Exp;
branches;
next	1.18;

1.18
date	2014.01.09.18.59.35;	author tedu;	state Exp;
branches;
next	1.17;

1.17
date	2014.01.09.17.13.36;	author deraadt;	state Exp;
branches;
next	1.16;

1.16
date	2014.01.09.15.36.40;	author tedu;	state Exp;
branches;
next	1.15;

1.15
date	2014.01.08.07.04.29;	author espie;	state Exp;
branches;
next	1.14;

1.14
date	2014.01.08.05.00.01;	author tedu;	state Exp;
branches;
next	1.13;

1.13
date	2014.01.08.03.57.57;	author tedu;	state Exp;
branches;
next	1.12;

1.12
date	2014.01.06.01.50.54;	author espie;	state Exp;
branches;
next	1.11;

1.11
date	2014.01.03.17.14.47;	author tedu;	state Exp;
branches;
next	1.10;

1.10
date	2014.01.03.17.13.42;	author tedu;	state Exp;
branches;
next	1.9;

1.9
date	2014.01.03.17.10.27;	author espie;	state Exp;
branches;
next	1.8;

1.8
date	2014.01.03.15.42.22;	author espie;	state Exp;
branches;
next	1.7;

1.7
date	2014.01.02.16.34.02;	author espie;	state Exp;
branches;
next	1.6;

1.6
date	2014.01.01.17.50.33;	author tedu;	state Exp;
branches;
next	1.5;

1.5
date	2013.12.31.17.33.17;	author jmc;	state Exp;
branches;
next	1.4;

1.4
date	2013.12.31.03.54.05;	author tedu;	state Exp;
branches;
next	1.3;

1.3
date	2013.12.31.03.23.41;	author tedu;	state Exp;
branches;
next	1.2;

1.2
date	2013.12.31.03.08.48;	author tedu;	state Exp;
branches;
next	1.1;

1.1
date	2013.12.31.03.03.32;	author tedu;	state Exp;
branches;
next	;


desc
@@


1.126
log
@- better check for seckeyname/pubkeyname "equality", remove the path
(you could legitimately store secret keys on a temporary mount
- error out if seckeyname does not follow the *.sec pattern for signing,
augment the check to deal with that.
- special case: seckeyfile can come from a pipe, and then, well, there's no
way to store *.pub in the comment.

okay tedu@@
@
text
@/* $OpenBSD: signify.c,v 1.125 2016/10/05 15:58:50 tedu Exp $ */
/*
 * Copyright (c) 2013 Ted Unangst <tedu@@openbsd.org>
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */
#include <sys/stat.h>

#include <netinet/in.h>
#include <resolv.h>

#include <limits.h>
#include <stdint.h>
#include <fcntl.h>
#include <string.h>
#include <stdio.h>
#include <stdlib.h>
#include <stddef.h>
#include <ohash.h>
#include <err.h>
#include <unistd.h>
#include <readpassphrase.h>
#include <util.h>
#include <sha2.h>

#include "crypto_api.h"
#include "signify.h"

#define SIGBYTES crypto_sign_ed25519_BYTES
#define SECRETBYTES crypto_sign_ed25519_SECRETKEYBYTES
#define PUBLICBYTES crypto_sign_ed25519_PUBLICKEYBYTES

#define PKALG "Ed"
#define KDFALG "BK"
#define KEYNUMLEN 8

#define COMMENTHDR "untrusted comment: "
#define COMMENTHDRLEN 19
#define COMMENTMAXLEN 1024
#define VERIFYWITH "verify with "

struct enckey {
	uint8_t pkalg[2];
	uint8_t kdfalg[2];
	uint32_t kdfrounds;
	uint8_t salt[16];
	uint8_t checksum[8];
	uint8_t keynum[KEYNUMLEN];
	uint8_t seckey[SECRETBYTES];
};

struct pubkey {
	uint8_t pkalg[2];
	uint8_t keynum[KEYNUMLEN];
	uint8_t pubkey[PUBLICBYTES];
};

struct sig {
	uint8_t pkalg[2];
	uint8_t keynum[KEYNUMLEN];
	uint8_t sig[SIGBYTES];
};

static void __dead
usage(const char *error)
{
	if (error)
		fprintf(stderr, "%s\n", error);
	fprintf(stderr, "usage:"
#ifndef VERIFYONLY
	    "\t%1$s -C [-q] -p pubkey -x sigfile [file ...]\n"
	    "\t%1$s -G [-n] [-c comment] -p pubkey -s seckey\n"
	    "\t%1$s -S [-ez] [-x sigfile] -s seckey -m message\n"
#endif
	    "\t%1$s -V [-eqz] [-p pubkey] [-t keytype] [-x sigfile] -m message\n",
	    getprogname());
	exit(1);
}

int
xopen(const char *fname, int oflags, mode_t mode)
{
	struct stat sb;
	int fd;

	if (strcmp(fname, "-") == 0) {
		if ((oflags & O_WRONLY))
			fd = dup(STDOUT_FILENO);
		else
			fd = dup(STDIN_FILENO);
		if (fd == -1)
			err(1, "dup failed");
	} else {
		fd = open(fname, oflags, mode);
		if (fd == -1)
			err(1, "can't open %s for %s", fname,
			    (oflags & O_WRONLY) ? "writing" : "reading");
	}
	if (fstat(fd, &sb) == -1 || S_ISDIR(sb.st_mode))
		errx(1, "not a valid file: %s", fname);
	return fd;
}

void *
xmalloc(size_t len)
{
	void *p;

	if (!(p = malloc(len)))
		err(1, "malloc %zu", len);
	return p;
}

static size_t
parseb64file(const char *filename, char *b64, void *buf, size_t buflen,
    char *comment)
{
	char *commentend, *b64end;

	commentend = strchr(b64, '\n');
	if (!commentend || commentend - b64 <= COMMENTHDRLEN ||
	    memcmp(b64, COMMENTHDR, COMMENTHDRLEN) != 0)
		errx(1, "invalid comment in %s; must start with '%s'",
		    filename, COMMENTHDR);
	*commentend = '\0';
	if (comment) {
		if (strlcpy(comment, b64 + COMMENTHDRLEN,
		    COMMENTMAXLEN) >= COMMENTMAXLEN)
			errx(1, "comment too long");
	}
	if (!(b64end = strchr(commentend + 1, '\n')))
		errx(1, "missing new line after base64 in %s", filename);
	*b64end = '\0';
	if (b64_pton(commentend + 1, buf, buflen) != buflen)
		errx(1, "invalid base64 encoding in %s", filename);
	if (memcmp(buf, PKALG, 2) != 0)
		errx(1, "unsupported file %s", filename);
	return b64end - b64 + 1;
}

static void
readb64file(const char *filename, void *buf, size_t buflen, char *comment)
{
	char b64[2048];
	int rv, fd;

	fd = xopen(filename, O_RDONLY | O_NOFOLLOW, 0);
	if ((rv = read(fd, b64, sizeof(b64) - 1)) == -1)
		err(1, "read from %s", filename);
	b64[rv] = '\0';
	parseb64file(filename, b64, buf, buflen, comment);
	explicit_bzero(b64, sizeof(b64));
	close(fd);
}

static uint8_t *
readmsg(const char *filename, unsigned long long *msglenp)
{
	unsigned long long msglen = 0;
	uint8_t *msg = NULL;
	struct stat sb;
	ssize_t x, space;
	int fd;
	const unsigned long long maxmsgsize = 1UL << 30;

	fd = xopen(filename, O_RDONLY | O_NOFOLLOW, 0);
	if (fstat(fd, &sb) == 0 && S_ISREG(sb.st_mode)) {
		if (sb.st_size > maxmsgsize)
			errx(1, "msg too large in %s", filename);
		space = sb.st_size + 1;
	} else {
		space = 64 * 1024 - 1;
	}

	msg = xmalloc(space + 1);
	while (1) {
		if (space == 0) {
			if (msglen * 2 > maxmsgsize)
				errx(1, "msg too large in %s", filename);
			space = msglen;
			if (!(msg = realloc(msg, msglen + space + 1)))
				err(1, "realloc");
		}
		if ((x = read(fd, msg + msglen, space)) == -1)
			err(1, "read from %s", filename);
		if (x == 0)
			break;
		space -= x;
		msglen += x;
	}

	msg[msglen] = '\0';
	close(fd);

	*msglenp = msglen;
	return msg;
}

void
writeall(int fd, const void *buf, size_t buflen, const char *filename)
{
	ssize_t x;

	while (buflen != 0) {
		if ((x = write(fd, buf, buflen)) == -1)
			err(1, "write to %s", filename);
		buflen -= x;
		buf = (char *)buf + x;
	}
}

#ifndef VERIFYONLY
static char *
createheader(const char *comment, const void *buf, size_t buflen)
{
	char *header;
	char b64[1024];

	if (b64_ntop(buf, buflen, b64, sizeof(b64)) == -1)
		errx(1, "base64 encode failed");
	if (asprintf(&header, "%s%s\n%s\n", COMMENTHDR, comment, b64) == -1)
		err(1, "asprintf failed");
	explicit_bzero(b64, sizeof(b64));
	return header;
}

static void
writekeyfile(const char *filename, const char *comment, const void *buf,
    size_t buflen, int oflags, mode_t mode)
{
	char *header;
	int fd;

	fd = xopen(filename, O_CREAT|oflags|O_NOFOLLOW|O_WRONLY, mode);
	header = createheader(comment, buf, buflen);
	writeall(fd, header, strlen(header), filename);
	explicit_bzero(header, strlen(header));
	free(header);
	close(fd);
}

static void
kdf(uint8_t *salt, size_t saltlen, int rounds, int allowstdin, int confirm,
    uint8_t *key, size_t keylen)
{
	char pass[1024];
	int rppflags = RPP_ECHO_OFF;

	if (rounds == 0) {
		memset(key, 0, keylen);
		return;
	}

	if (allowstdin && !isatty(STDIN_FILENO))
		rppflags |= RPP_STDIN;
	if (!readpassphrase("passphrase: ", pass, sizeof(pass), rppflags))
		errx(1, "unable to read passphrase");
	if (strlen(pass) == 0)
		errx(1, "please provide a password");
	if (confirm && !(rppflags & RPP_STDIN)) {
		char pass2[1024];
		if (!readpassphrase("confirm passphrase: ", pass2,
		    sizeof(pass2), rppflags))
			errx(1, "unable to read passphrase");
		if (strcmp(pass, pass2) != 0)
			errx(1, "passwords don't match");
		explicit_bzero(pass2, sizeof(pass2));
	}
	if (bcrypt_pbkdf(pass, strlen(pass), salt, saltlen, key,
	    keylen, rounds) == -1)
		errx(1, "bcrypt pbkdf");
	explicit_bzero(pass, sizeof(pass));
}

static void
signmsg(uint8_t *seckey, uint8_t *msg, unsigned long long msglen,
    uint8_t *sig)
{
	unsigned long long siglen;
	uint8_t *sigbuf;

	sigbuf = xmalloc(msglen + SIGBYTES);
	crypto_sign_ed25519(sigbuf, &siglen, msg, msglen, seckey);
	memcpy(sig, sigbuf, SIGBYTES);
	free(sigbuf);
}

static void
generate(const char *pubkeyfile, const char *seckeyfile, int rounds,
    const char *comment)
{
	uint8_t digest[SHA512_DIGEST_LENGTH];
	struct pubkey pubkey;
	struct enckey enckey;
	uint8_t xorkey[sizeof(enckey.seckey)];
	uint8_t keynum[KEYNUMLEN];
	char commentbuf[COMMENTMAXLEN];
	SHA2_CTX ctx;
	int i, nr;

	crypto_sign_ed25519_keypair(pubkey.pubkey, enckey.seckey);
	arc4random_buf(keynum, sizeof(keynum));

	SHA512Init(&ctx);
	SHA512Update(&ctx, enckey.seckey, sizeof(enckey.seckey));
	SHA512Final(digest, &ctx);

	memcpy(enckey.pkalg, PKALG, 2);
	memcpy(enckey.kdfalg, KDFALG, 2);
	enckey.kdfrounds = htonl(rounds);
	memcpy(enckey.keynum, keynum, KEYNUMLEN);
	arc4random_buf(enckey.salt, sizeof(enckey.salt));
	kdf(enckey.salt, sizeof(enckey.salt), rounds, 1, 1, xorkey, sizeof(xorkey));
	memcpy(enckey.checksum, digest, sizeof(enckey.checksum));
	for (i = 0; i < sizeof(enckey.seckey); i++)
		enckey.seckey[i] ^= xorkey[i];
	explicit_bzero(digest, sizeof(digest));
	explicit_bzero(xorkey, sizeof(xorkey));

	nr = snprintf(commentbuf, sizeof(commentbuf), "%s secret key", comment);
	if (nr == -1 || nr >= sizeof(commentbuf))
		errx(1, "comment too long");
	writekeyfile(seckeyfile, commentbuf, &enckey,
	    sizeof(enckey), O_EXCL, 0600);
	explicit_bzero(&enckey, sizeof(enckey));

	memcpy(pubkey.pkalg, PKALG, 2);
	memcpy(pubkey.keynum, keynum, KEYNUMLEN);
	nr = snprintf(commentbuf, sizeof(commentbuf), "%s public key", comment);
	if (nr == -1 || nr >= sizeof(commentbuf))
		errx(1, "comment too long");
	writekeyfile(pubkeyfile, commentbuf, &pubkey,
	    sizeof(pubkey), O_EXCL, 0666);
}

static const char *
check_keyname_compliance(const char *pubkeyfile, const char *seckeyfile)
{
	const char *pos;

	/* basename may or may not modify input */
	pos = strrchr(seckeyfile, '/');
	if (pos != NULL)
		seckeyfile = pos+1;

	size_t len;
	len = strlen(seckeyfile);
	if (len < 5) /* ?.key */
		goto bad;
	if (strcmp(seckeyfile + len - 4, ".sec") != 0)
		goto bad;
	if (pubkeyfile != NULL) {
		pos = strrchr(pubkeyfile, '/');
		if (pos != NULL)
			pubkeyfile = pos+1;

		if (strlen(pubkeyfile) != len)
			goto bad;
		if (strcmp(pubkeyfile + len - 4, ".pub") != 0)
			goto bad;
		if (strncmp(pubkeyfile, seckeyfile, len - 4) != 0)
			goto bad;
	}

	return seckeyfile;
bad:
	errx(1, "please use naming scheme of keyname.pub and keyname.sec");
}

uint8_t *
createsig(const char *seckeyfile, const char *msgfile, uint8_t *msg,
    unsigned long long msglen)
{
	struct enckey enckey;
	uint8_t xorkey[sizeof(enckey.seckey)];
	struct sig sig;
	char *sighdr;
	uint8_t digest[SHA512_DIGEST_LENGTH];
	int i, nr, rounds;
	SHA2_CTX ctx;
	char comment[COMMENTMAXLEN], sigcomment[COMMENTMAXLEN];

	readb64file(seckeyfile, &enckey, sizeof(enckey), comment);

	if (strcmp(seckeyfile, "-") == 0) {
 		nr = snprintf(sigcomment, sizeof(sigcomment),
		    "signature from %s", comment);
	} else {
		const char *keyname = check_keyname_compliance(NULL, 
		    seckeyfile);
		nr = snprintf(sigcomment, sizeof(sigcomment),
		    VERIFYWITH "%.*s.pub", (int)strlen(keyname) - 4, keyname);
	}
	if (nr == -1 || nr >= sizeof(sigcomment))
		errx(1, "comment too long");

	if (memcmp(enckey.kdfalg, KDFALG, 2) != 0)
		errx(1, "unsupported KDF");
	rounds = ntohl(enckey.kdfrounds);
	kdf(enckey.salt, sizeof(enckey.salt), rounds, strcmp(msgfile, "-") != 0,
	    0, xorkey, sizeof(xorkey));
	for (i = 0; i < sizeof(enckey.seckey); i++)
		enckey.seckey[i] ^= xorkey[i];
	explicit_bzero(xorkey, sizeof(xorkey));
	SHA512Init(&ctx);
	SHA512Update(&ctx, enckey.seckey, sizeof(enckey.seckey));
	SHA512Final(digest, &ctx);
	if (memcmp(enckey.checksum, digest, sizeof(enckey.checksum)) != 0)
		errx(1, "incorrect passphrase");
	explicit_bzero(digest, sizeof(digest));

	signmsg(enckey.seckey, msg, msglen, sig.sig);
	memcpy(sig.keynum, enckey.keynum, KEYNUMLEN);
	explicit_bzero(&enckey, sizeof(enckey));

	memcpy(sig.pkalg, PKALG, 2);

	sighdr = createheader(sigcomment, &sig, sizeof(sig));
	return sighdr;
}

static void
sign(const char *seckeyfile, const char *msgfile, const char *sigfile,
    int embedded)
{
	uint8_t *msg;
	char *sighdr;
	int fd;
	unsigned long long msglen;

	msg = readmsg(msgfile, &msglen);

	sighdr = createsig(seckeyfile, msgfile, msg, msglen);

	fd = xopen(sigfile, O_CREAT|O_TRUNC|O_NOFOLLOW|O_WRONLY, 0666);
	writeall(fd, sighdr, strlen(sighdr), sigfile);
	free(sighdr);
	if (embedded)
		writeall(fd, msg, msglen, sigfile);
	close(fd);

	free(msg);
}
#endif

static void
verifymsg(struct pubkey *pubkey, uint8_t *msg, unsigned long long msglen,
    struct sig *sig, int quiet)
{
	uint8_t *sigbuf, *dummybuf;
	unsigned long long siglen, dummylen;

	if (memcmp(pubkey->keynum, sig->keynum, KEYNUMLEN) != 0)
		errx(1, "verification failed: checked against wrong key");

	siglen = SIGBYTES + msglen;
	sigbuf = xmalloc(siglen);
	dummybuf = xmalloc(siglen);
	memcpy(sigbuf, sig->sig, SIGBYTES);
	memcpy(sigbuf + SIGBYTES, msg, msglen);
	if (crypto_sign_ed25519_open(dummybuf, &dummylen, sigbuf, siglen,
	    pubkey->pubkey) == -1)
		errx(1, "signature verification failed");
	if (!quiet)
		printf("Signature Verified\n");
	free(sigbuf);
	free(dummybuf);
}

static void
check_keytype(const char *pubkeyfile, const char *keytype)
{
	const char *p;
	size_t typelen;

	if (!(p = strrchr(pubkeyfile, '-')))
		goto bad;
	p++;
	typelen = strlen(keytype);
	if (strncmp(p, keytype, typelen) != 0)
		goto bad;
	if (strcmp(p + typelen, ".pub") != 0)
		goto bad;
	return;

bad:
	errx(1, "incorrect keytype: %s is not %s", pubkeyfile, keytype);
}

static void
readpubkey(const char *pubkeyfile, struct pubkey *pubkey,
    const char *sigcomment, const char *keytype)
{
	const char *safepath = "/etc/signify";
	char keypath[1024];

	if (!pubkeyfile) {
		pubkeyfile = strstr(sigcomment, VERIFYWITH);
		if (pubkeyfile && strchr(pubkeyfile, '/') == NULL) {
			pubkeyfile += strlen(VERIFYWITH);
			if (keytype)
				check_keytype(pubkeyfile, keytype);
			if (snprintf(keypath, sizeof(keypath), "%s/%s",
			    safepath, pubkeyfile) >= sizeof(keypath))
				errx(1, "name too long %s", pubkeyfile);
			pubkeyfile = keypath;
		} else
			usage("must specify pubkey");
	}
	readb64file(pubkeyfile, pubkey, sizeof(*pubkey), NULL);
}

static void
verifysimple(const char *pubkeyfile, const char *msgfile, const char *sigfile,
    int quiet, const char *keytype)
{
	char sigcomment[COMMENTMAXLEN];
	struct sig sig;
	struct pubkey pubkey;
	unsigned long long msglen;
	uint8_t *msg;

	msg = readmsg(msgfile, &msglen);

	readb64file(sigfile, &sig, sizeof(sig), sigcomment);
	readpubkey(pubkeyfile, &pubkey, sigcomment, keytype);

	verifymsg(&pubkey, msg, msglen, &sig, quiet);

	free(msg);
}

static uint8_t *
verifyembedded(const char *pubkeyfile, const char *sigfile,
    int quiet, unsigned long long *msglenp, const char *keytype)
{
	char sigcomment[COMMENTMAXLEN];
	struct sig sig;
	struct pubkey pubkey;
	unsigned long long msglen, siglen;
	uint8_t *msg;

	msg = readmsg(sigfile, &msglen);

	siglen = parseb64file(sigfile, msg, &sig, sizeof(sig), sigcomment);
	readpubkey(pubkeyfile, &pubkey, sigcomment, keytype);

	msglen -= siglen;
	memmove(msg, msg + siglen, msglen);
	msg[msglen] = 0;

	verifymsg(&pubkey, msg, msglen, &sig, quiet);

	*msglenp = msglen;
	return msg;
}

static void
verify(const char *pubkeyfile, const char *msgfile, const char *sigfile,
    int embedded, int quiet, const char *keytype)
{
	unsigned long long msglen;
	uint8_t *msg;
	int fd;

	if (embedded) {
		msg = verifyembedded(pubkeyfile, sigfile, quiet, &msglen,
		    keytype);
		fd = xopen(msgfile, O_CREAT|O_TRUNC|O_NOFOLLOW|O_WRONLY, 0666);
		writeall(fd, msg, msglen, msgfile);
		free(msg);
		close(fd);
	} else {
		verifysimple(pubkeyfile, msgfile, sigfile, quiet, keytype);
	}
}

#ifndef VERIFYONLY
#define HASHBUFSIZE 224
struct checksum {
	char file[PATH_MAX];
	char hash[HASHBUFSIZE];
	char algo[32];
};

static void *
ecalloc(size_t s1, size_t s2, void *data)
{
	void *p;

	if (!(p = calloc(s1, s2)))
		err(1, "calloc");
	return p;
}

static void
efree(void *p, void *data)
{
	free(p);
}

static void
recodehash(char *hash, size_t len)
{
	uint8_t data[HASHBUFSIZE / 2];
	int i, rv;

	if (strlen(hash) == len)
		return;
	if ((rv = b64_pton(hash, data, sizeof(data))) == -1)
		errx(1, "invalid base64 encoding");
	for (i = 0; i < rv; i++)
		snprintf(hash + i * 2, HASHBUFSIZE - i * 2, "%2.2x", data[i]);
}

static int
verifychecksum(struct checksum *c, int quiet)
{
	char buf[HASHBUFSIZE];

	if (strcmp(c->algo, "SHA256") == 0) {
		recodehash(c->hash, SHA256_DIGEST_STRING_LENGTH-1);
		if (!SHA256File(c->file, buf))
			return 0;
	} else if (strcmp(c->algo, "SHA512") == 0) {
		recodehash(c->hash, SHA512_DIGEST_STRING_LENGTH-1);
		if (!SHA512File(c->file, buf))
			return 0;
	} else {
		errx(1, "can't handle algorithm %s", c->algo);
	}
	if (strcmp(c->hash, buf) != 0)
		return 0;
	if (!quiet)
		printf("%s: OK\n", c->file);
	return 1;
}

static void
verifychecksums(char *msg, int argc, char **argv, int quiet)
{
	struct ohash_info info = { 0, NULL, ecalloc, efree, NULL };
	struct ohash myh;
	struct checksum c;
	char *e, *line, *endline;
	int hasfailed = 0;
	int i, rv;
	unsigned int slot;

	ohash_init(&myh, 6, &info);
	if (argc) {
		for (i = 0; i < argc; i++) {
			slot = ohash_qlookup(&myh, argv[i]);
			e = ohash_find(&myh, slot);
			if (e == NULL)
				ohash_insert(&myh, slot, argv[i]);
		}
	}

	line = msg;
	while (line && *line) {
		if ((endline = strchr(line, '\n')))
			*endline++ = '\0';
#if PATH_MAX < 1024 || HASHBUFSIZE < 224
#error sizes are wrong
#endif
		rv = sscanf(line, "%31s (%1023[^)]) = %223s",
		    c.algo, c.file, c.hash);
		if (rv != 3)
			errx(1, "unable to parse checksum line %s", line);
		line = endline;
		if (argc) {
			slot = ohash_qlookup(&myh, c.file);
			e = ohash_find(&myh, slot);
			if (e != NULL) {
				if (verifychecksum(&c, quiet) != 0)
					ohash_remove(&myh, slot);
			}
		} else {
			if (verifychecksum(&c, quiet) == 0) {
				slot = ohash_qlookup(&myh, c.file);
				e = ohash_find(&myh, slot);
				if (e == NULL) {
					if (!(e = strdup(c.file)))
						err(1, "strdup");
					ohash_insert(&myh, slot, e);
				}
			}
		}
	}

	for (e = ohash_first(&myh, &slot); e != NULL; e = ohash_next(&myh, &slot)) {
		fprintf(stderr, "%s: FAIL\n", e);
		hasfailed = 1;
		if (argc == 0)
			free(e);
	}
	ohash_delete(&myh);
	if (hasfailed)
		exit(1);
}

static void
check(const char *pubkeyfile, const char *sigfile, int quiet, int argc,
    char **argv)
{
	unsigned long long msglen;
	uint8_t *msg;

	msg = verifyembedded(pubkeyfile, sigfile, quiet, &msglen, NULL);
	verifychecksums((char *)msg, argc, argv, quiet);

	free(msg);
}

void *
verifyzdata(uint8_t *zdata, unsigned long long zdatalen,
    const char *filename, const char *pubkeyfile, const char *keytype)
{
	struct sig sig;
	char sigcomment[COMMENTMAXLEN];
	unsigned long long siglen;
	struct pubkey pubkey;

	if (zdatalen < sizeof(sig))
		errx(1, "signature too short in %s", filename);
	siglen = parseb64file(filename, zdata, &sig, sizeof(sig),
	    sigcomment);
	readpubkey(pubkeyfile, &pubkey, sigcomment, keytype);
	zdata += siglen;
	zdatalen -= siglen;
	verifymsg(&pubkey, zdata, zdatalen, &sig, 1);
	return zdata;
}
#endif

int
main(int argc, char **argv)
{
	const char *pubkeyfile = NULL, *seckeyfile = NULL, *msgfile = NULL,
	    *sigfile = NULL;
	char sigfilebuf[PATH_MAX];
	const char *comment = "signify";
	char *keytype = NULL;
	int ch, rounds;
	int embedded = 0;
	int quiet = 0;
	int gzip = 0;
	enum {
		NONE,
		CHECK,
		GENERATE,
		SIGN,
		VERIFY
	} verb = NONE;

	if (pledge("stdio rpath wpath cpath tty", NULL) == -1)
		err(1, "pledge");

	rounds = 42;

	while ((ch = getopt(argc, argv, "CGSVzc:em:np:qs:t:x:")) != -1) {
		switch (ch) {
#ifndef VERIFYONLY
		case 'C':
			if (verb)
				usage(NULL);
			verb = CHECK;
			break;
		case 'G':
			if (verb)
				usage(NULL);
			verb = GENERATE;
			break;
		case 'S':
			if (verb)
				usage(NULL);
			verb = SIGN;
			break;
		case 'z':
			gzip = 1;
			break;
#endif
		case 'V':
			if (verb)
				usage(NULL);
			verb = VERIFY;
			break;
		case 'c':
			comment = optarg;
			break;
		case 'e':
			embedded = 1;
			break;
		case 'm':
			msgfile = optarg;
			break;
		case 'n':
			rounds = 0;
			break;
		case 'p':
			pubkeyfile = optarg;
			break;
		case 'q':
			quiet = 1;
			break;
		case 's':
			seckeyfile = optarg;
			break;
		case 't':
			keytype = optarg;
			break;
		case 'x':
			sigfile = optarg;
			break;
		default:
			usage(NULL);
			break;
		}
	}
	argc -= optind;
	argv += optind;

	if (embedded && gzip)
		errx(1, "can't combine -e and -z options");

	if (setvbuf(stdout, NULL, _IOLBF, 0) != 0)
		err(1, "setvbuf");

#ifndef VERIFYONLY
	if (verb == CHECK) {
		if (pledge("stdio rpath", NULL) == -1)
			err(1, "pledge");
		if (!sigfile)
			usage("must specify sigfile");
		check(pubkeyfile, sigfile, quiet, argc, argv);
		return 0;
	}
#endif

	if (argc != 0)
		usage(NULL);

	if (!sigfile && msgfile) {
		int nr;
		if (strcmp(msgfile, "-") == 0)
			usage("must specify sigfile with - message");
		nr = snprintf(sigfilebuf, sizeof(sigfilebuf),
		    "%s.sig", msgfile);
		if (nr == -1 || nr >= sizeof(sigfilebuf))
			errx(1, "path too long");
		sigfile = sigfilebuf;
	}

	switch (verb) {
#ifndef VERIFYONLY
	case GENERATE:
		/* no pledge */
		if (!pubkeyfile || !seckeyfile)
			usage("must specify pubkey and seckey");
		check_keyname_compliance(pubkeyfile, seckeyfile);
		generate(pubkeyfile, seckeyfile, rounds, comment);
		break;
	case SIGN:
		/* no pledge */
		if (gzip) {
			if (!msgfile || !seckeyfile || !sigfile)
				usage("must specify message sigfile seckey");
			zsign(seckeyfile, msgfile, sigfile);
		} else {
			if (!msgfile || !seckeyfile)
				usage("must specify message and seckey");
			sign(seckeyfile, msgfile, sigfile, embedded);
		}
		break;
#endif
	case VERIFY:
		if ((embedded || gzip) &&
		    (msgfile && strcmp(msgfile, "-") != 0)) {
			/* will need to create output file */
			if (pledge("stdio rpath wpath cpath", NULL) == -1)
				err(1, "pledge");
		} else {
			if (pledge("stdio rpath", NULL) == -1)
				err(1, "pledge");
		}
		if (gzip) {
			zverify(pubkeyfile, msgfile, sigfile, keytype);
		} else {
			if (!msgfile)
				usage("must specify message");
			verify(pubkeyfile, msgfile, sigfile, embedded,
			    quiet, keytype);
		}
		break;
	default:
		if (pledge("stdio", NULL) == -1)
			err(1, "pledge");
		usage(NULL);
		break;
	}

	return 0;
}
@


1.125
log
@when generating keys, make sure the names specified adhere to all
department of keyname compliance regulations. see if anybody complains...
@
text
@d1 1
a1 1
/* $OpenBSD: signify.c,v 1.124 2016/10/05 15:48:39 tedu Exp $ */
d346 1
a346 1
static void
d349 7
d357 1
a357 4

	len = strlen(pubkeyfile);
	if (strlen(seckeyfile) != len)
		goto bad;
d360 1
a360 4
	if (strcmp(pubkeyfile + len - 4, ".pub") != 0 ||
	    strcmp(seckeyfile + len - 4, ".sec") != 0)
		goto bad;
	if (strncmp(pubkeyfile, seckeyfile, len - 4) != 0)
d362 12
d375 1
a375 1
	return;
a387 1
	char *extname;
d395 6
a400 8
	extname = strrchr(seckeyfile, '.');
	if (extname && strcmp(extname, ".sec") == 0) {
		const char *keyname;
		/* basename may or may not modify input */
		if (!(keyname = strrchr(seckeyfile, '/')))
			keyname = seckeyfile;
		else
			keyname++;
a402 7
		if (nr == -1 || nr >= sizeof(sigcomment))
			errx(1, "comment too long");
	} else {
		nr = snprintf(sigcomment, sizeof(sigcomment),
		    "signature from %s", comment);
		if (nr == -1 || nr >= sizeof(sigcomment))
			errx(1, "comment too long");
d404 2
@


1.124
log
@more properly check the secret key extension. from espie
@
text
@d1 1
a1 1
/* $OpenBSD: signify.c,v 1.123 2016/10/05 14:48:58 tedu Exp $ */
d346 21
d866 1
@


1.123
log
@combining an assignment and *two* tests in one conditional is a bit much.
pull things apart.
reported by espie in a separate complaint. :)
@
text
@d1 1
a1 1
/* $OpenBSD: signify.c,v 1.122 2016/09/27 02:13:27 tedu Exp $ */
d354 1
a354 1
	char *secname;
d362 2
a363 2
	secname = strstr(seckeyfile, ".sec");
	if (secname && strlen(secname) == 4) {
@


1.122
log
@the keytype checking is logically part of verify, and it's small, so
always include it. but it can be made a bit simpler with zero malloc.
@
text
@d1 1
a1 1
/* $OpenBSD: signify.c,v 1.121 2016/09/27 02:02:47 tedu Exp $ */
d330 2
a331 2
	if ((nr = snprintf(commentbuf, sizeof(commentbuf), "%s secret key",
	    comment)) == -1 || nr >= sizeof(commentbuf))
d339 2
a340 2
	if ((nr = snprintf(commentbuf, sizeof(commentbuf), "%s public key",
	    comment)) == -1 || nr >= sizeof(commentbuf))
d370 3
a372 2
		if ((nr = snprintf(sigcomment, sizeof(sigcomment), VERIFYWITH "%.*s.pub",
		    (int)strlen(keyname) - 4, keyname)) == -1 || nr >= sizeof(sigcomment))
d375 3
a377 2
		if ((nr = snprintf(sigcomment, sizeof(sigcomment), "signature from %s",
		    comment)) == -1 || nr >= sizeof(sigcomment))
d832 3
a834 2
		if ((nr = snprintf(sigfilebuf, sizeof(sigfilebuf), "%s.sig",
		    msgfile)) == -1 || nr >= sizeof(sigfilebuf))
@


1.121
log
@no need to copy keypath if we already have one
@
text
@d1 1
a1 1
/* $OpenBSD: signify.c,v 1.120 2016/09/26 21:47:54 tedu Exp $ */
a451 1
#ifndef VERIFYONLY
d455 15
a469 14
	size_t len;
	char *cmp;
	int slen;

	len = strlen(pubkeyfile);
	slen = asprintf(&cmp, "-%s.pub", keytype);
	if (slen < 0)
		err(1, "asprintf error");
	if (len < slen)
		errx(1, "too short");

	if (strcmp(pubkeyfile + len - slen, cmp) != 0)
		errx(1, "wrong keytype");
	free(cmp);
a470 1
#endif
a482 1
#ifndef VERIFYONLY
a484 1
#endif
@


1.120
log
@have to advance pointer past the / to get basename.
noticed by naddy
@
text
@d1 1
a1 1
/* $OpenBSD: signify.c,v 1.119 2016/09/26 17:49:52 tedu Exp $ */
d491 1
a493 4
	} else {
		if (strlcpy(keypath, pubkeyfile, sizeof(keypath)) >=
		    sizeof(keypath))
			errx(1, "name too long %s", pubkeyfile);
d495 1
a495 1
	readb64file(keypath, pubkey, sizeof(*pubkey), NULL);
@


1.119
log
@there's a hidden feature to infer the public key from the signature
comment, but it doesn't work well because it encodes the full path.
signature creaters don't usually keep the secret keys in /etc/signify,
but that's where we look for public keys.
switch to saving only the basename, and have the verifier add the path.
should make it easier to start using this feature.
anybody depending on the current behavior may have to adjust, but
there's a reason this was never officially documented.
@
text
@d1 1
a1 1
/* $OpenBSD: signify.c,v 1.118 2016/09/10 12:23:16 deraadt Exp $ */
d368 2
@


1.118
log
@spaces found during re-read
@
text
@d1 1
a1 1
/* $OpenBSD: signify.c,v 1.117 2016/09/03 12:21:38 espie Exp $ */
d364 4
d369 1
a369 1
		    (int)strlen(seckeyfile) - 4, seckeyfile)) == -1 || nr >= sizeof(sigcomment))
d475 2
a476 1
	const char *safepath = "/etc/signify/";
d480 1
a480 1
		if (pubkeyfile) {
a481 3
			if (strncmp(pubkeyfile, safepath, strlen(safepath)) != 0 ||
			    strstr(pubkeyfile, "/../") != NULL)
				errx(1, "untrusted path %s", pubkeyfile);
d486 3
d491 4
d496 1
a496 1
	readb64file(pubkeyfile, pubkey, sizeof(*pubkey), NULL);
@


1.117
log
@fix parameters checking
@
text
@d1 1
a1 1
/* $OpenBSD: signify.c,v 1.116 2016/09/02 21:45:37 tedu Exp $ */
d453 1
a453 1
	
d563 1
a563 1
static void * 
d694 1
a694 1
verifyzdata(uint8_t *zdata, unsigned long long zdatalen, 
d704 1
a704 1
	siglen = parseb64file(filename, zdata, &sig, sizeof(sig), 
d867 1
a867 1
			verify(pubkeyfile, msgfile, sigfile, embedded, 
@


1.116
log
@use err() instead of errx when an errno is set
@
text
@d1 1
a1 1
/* $OpenBSD: signify.c,v 1.115 2016/09/02 21:31:22 tedu Exp $ */
d842 2
@


1.115
log
@the old check for when verify needed to create files (affecting pledge)
was slightly wrong, but it didn't matter. new gzip mode however falls
into the gap. the zsig code will default to stdout, therefore it needs
much fewer privileges if msgfile is not specified.
@
text
@d1 1
a1 1
/* $OpenBSD: signify.c,v 1.114 2016/09/02 21:18:50 tedu Exp $ */
d192 1
a192 1
				errx(1, "realloc");
d457 1
a457 1
		errx(1, "asprintf error");
@


1.114
log
@combine the pledge switch with the execution switch. no changes yet,
but we can do a little better in some cases.
@
text
@d1 1
a1 1
/* $OpenBSD: signify.c,v 1.113 2016/09/02 21:12:03 tedu Exp $ */
d841 1
a841 1
		if (gzip)
d843 1
a843 1
		else {
d851 3
a853 2
		if ((embedded || gzip)
		    && (!msgfile || strcmp(msgfile, "-") != 0)) {
d860 1
a860 1
		if (gzip)
d862 1
a862 1
		else {
@


1.113
log
@-e and -z cannot be combined
@
text
@d1 1
a1 1
/* $OpenBSD: signify.c,v 1.112 2016/09/02 17:27:31 espie Exp $ */
d807 2
a808 6
	switch (verb) {
	case GENERATE:
	case SIGN:
		/* keep it all */
		break;
	case CHECK:
a810 19
		break;
	case VERIFY:
		if ((embedded || gzip)
		    && (!msgfile || strcmp(msgfile, "-") != 0)) {
			if (pledge("stdio rpath wpath cpath", NULL) == -1)
				err(1, "pledge");
		} else {
			if (pledge("stdio rpath", NULL) == -1)
				err(1, "pledge");
		}
		break;
	default:
		if (pledge("stdio", NULL) == -1)
			err(1, "pledge");
		break;
	}

#ifndef VERIFYONLY
	if (verb == CHECK) {
d834 1
d840 1
d851 8
d869 2
@


1.112
log
@document the new stuff, usage nits.
some input by jmc@@, to be polished later
"get it in now" tedu@@ deraadt@@
@
text
@d1 1
a1 1
/* $OpenBSD: signify.c,v 1.111 2016/09/02 16:10:56 espie Exp $ */
d800 3
@


1.111
log
@add a new option (-z) for signing gzip archives.
- simple barebones gzip header parsing
- signature is outside of the archive
- checksums for blocks of 64K
- verify stuff then pass it to the pipeline
lots of inputs by tedu@@ and deraadt@@
okay tedu@@
@
text
@d1 1
a1 1
/* $OpenBSD: signify.c,v 1.110 2016/09/02 15:08:48 tedu Exp $ */
d85 1
a85 1
	    "\t%1$s -V [-ezq] [-x sigfile] -p pubkey -m message\n",
@


1.110
log
@move more code into createsig. callers just pass seckey filename.
@
text
@d1 1
a1 1
/* $OpenBSD: signify.c,v 1.109 2016/09/02 14:50:39 tedu Exp $ */
d37 1
d83 1
a83 1
	    "\t%1$s -S [-e] [-x sigfile] -s seckey -m message\n"
d85 1
a85 1
	    "\t%1$s -V [-eq] [-x sigfile] -p pubkey -m message\n",
d90 1
a90 1
static int
d114 1
a114 1
static void *
d209 1
a209 1
static void
d346 1
a346 1
static uint8_t *
d692 20
d725 1
d739 1
a739 1
	while ((ch = getopt(argc, argv, "CGSVc:em:np:qs:t:x:")) != -1) {
d757 3
d814 2
a815 1
		if (embedded && (!msgfile || strcmp(msgfile, "-") != 0)) {
d859 7
a865 3
		if (!msgfile || !seckeyfile)
			usage("must specify message and seckey");
		sign(seckeyfile, msgfile, sigfile, embedded);
d869 8
a876 3
		if (!msgfile)
			usage("must specify message");
		verify(pubkeyfile, msgfile, sigfile, embedded, quiet, keytype);
@


1.109
log
@split the sign() function into two, with a pure memory core made
available as a separate function to make it easier to reuse in other code.
@
text
@d1 1
a1 1
/* $OpenBSD: signify.c,v 1.108 2016/09/01 17:35:23 tedu Exp $ */
d346 2
a347 2
createsig(struct enckey *enckey, const char *msgfile, uint8_t *msg,
    unsigned long long msglen, const char *sigcomment)
d349 2
a350 1
	uint8_t xorkey[sizeof(enckey->seckey)];
d353 1
d355 1
a355 1
	int i, rounds;
d357 3
d361 12
a372 1
	if (memcmp(enckey->kdfalg, KDFALG, 2) != 0)
d374 2
a375 2
	rounds = ntohl(enckey->kdfrounds);
	kdf(enckey->salt, sizeof(enckey->salt), rounds, strcmp(msgfile, "-") != 0,
d377 2
a378 2
	for (i = 0; i < sizeof(enckey->seckey); i++)
		enckey->seckey[i] ^= xorkey[i];
d381 1
a381 1
	SHA512Update(&ctx, enckey->seckey, sizeof(enckey->seckey));
d383 1
a383 1
	if (memcmp(enckey->checksum, digest, sizeof(enckey->checksum)) != 0)
d387 3
a389 3
	signmsg(enckey->seckey, msg, msglen, sig.sig);
	memcpy(sig.keynum, enckey->keynum, KEYNUMLEN);
	explicit_bzero(enckey, sizeof(*enckey));
a400 1
	struct enckey enckey;
d403 1
a403 2
	char *secname;
	int fd, nr;
a404 14
	char comment[COMMENTMAXLEN], sigcomment[COMMENTMAXLEN];

	readb64file(seckeyfile, &enckey, sizeof(enckey), comment);

	secname = strstr(seckeyfile, ".sec");
	if (secname && strlen(secname) == 4) {
		if ((nr = snprintf(sigcomment, sizeof(sigcomment), VERIFYWITH "%.*s.pub",
		    (int)strlen(seckeyfile) - 4, seckeyfile)) == -1 || nr >= sizeof(sigcomment))
			errx(1, "comment too long");
	} else {
		if ((nr = snprintf(sigcomment, sizeof(sigcomment), "signature from %s",
		    comment)) == -1 || nr >= sizeof(sigcomment))
			errx(1, "comment too long");
	}
d408 1
a408 1
	sighdr = createsig(&enckey, msgfile, msg, msglen, sigcomment);
@


1.108
log
@don't initialize variables with functions
@
text
@d1 1
a1 1
/* $OpenBSD: signify.c,v 1.107 2016/09/01 17:30:04 espie Exp $ */
d222 14
d237 2
a238 2
writeb64file(const char *filename, const char *comment, const void *buf,
    size_t buflen, const void *msg, size_t msglen, int oflags, mode_t mode)
d240 2
a241 3
	char header[1024];
	char b64[1024];
	int fd, rv, nr;
d244 1
a244 3
	if ((nr = snprintf(header, sizeof(header), "%s%s\n",
	    COMMENTHDR, comment)) == -1 || nr >= sizeof(header))
		errx(1, "comment too long");
d246 2
a247 7
	if ((rv = b64_ntop(buf, buflen, b64, sizeof(b64))) == -1)
		errx(1, "base64 encode failed");
	b64[rv++] = '\n';
	writeall(fd, b64, rv, filename);
	explicit_bzero(b64, sizeof(b64));
	if (msg)
		writeall(fd, msg, msglen, filename);
d332 2
a333 2
	writeb64file(seckeyfile, commentbuf, &enckey,
	    sizeof(enckey), NULL, 0, O_EXCL, 0600);
d341 2
a342 2
	writeb64file(pubkeyfile, commentbuf, &pubkey,
	    sizeof(pubkey), NULL, 0, O_EXCL, 0666);
d345 3
a347 3
static void
sign(const char *seckeyfile, const char *msgfile, const char *sigfile,
    int embedded)
d349 1
d351 1
d353 1
a353 7
	struct enckey enckey;
	uint8_t xorkey[sizeof(enckey.seckey)];
	uint8_t *msg;
	char comment[COMMENTMAXLEN], sigcomment[COMMENTMAXLEN];
	char *secname;
	unsigned long long msglen;
	int i, rounds, nr;
d356 1
a356 3
	readb64file(seckeyfile, &enckey, sizeof(enckey), comment);

	if (memcmp(enckey.kdfalg, KDFALG, 2) != 0)
d358 2
a359 2
	rounds = ntohl(enckey.kdfrounds);
	kdf(enckey.salt, sizeof(enckey.salt), rounds, strcmp(msgfile, "-") != 0,
d361 2
a362 2
	for (i = 0; i < sizeof(enckey.seckey); i++)
		enckey.seckey[i] ^= xorkey[i];
d365 1
a365 1
	SHA512Update(&ctx, enckey.seckey, sizeof(enckey.seckey));
d367 1
a367 1
	if (memcmp(enckey.checksum, digest, sizeof(enckey.checksum)) != 0)
d371 21
a391 1
	msg = readmsg(msgfile, &msglen);
d393 1
a393 3
	signmsg(enckey.seckey, msg, msglen, sig.sig);
	memcpy(sig.keynum, enckey.keynum, KEYNUMLEN);
	explicit_bzero(&enckey, sizeof(enckey));
a394 1
	memcpy(sig.pkalg, PKALG, 2);
d405 8
d414 2
a415 5
		writeb64file(sigfile, sigcomment, &sig, sizeof(sig), msg,
		    msglen, O_TRUNC, 0666);
	else
		writeb64file(sigfile, sigcomment, &sig, sizeof(sig), NULL,
		    0, O_TRUNC, 0666);
@


1.107
log
@add a -t keytype option for untrusted comment automatic key extraction
(not in VERIFYONLY mode) to be documented and used shortly
okay tedu@@
@
text
@d1 1
a1 1
/* $OpenBSD: signify.c,v 1.106 2016/06/08 04:16:06 tedu Exp $ */
d427 1
a427 1
	size_t len = strlen(pubkeyfile);
d429 4
a432 1
	int slen = asprintf(&cmp, "-%s.pub", keytype);
@


1.106
log
@use getprogname
@
text
@d1 1
a1 1
/* $OpenBSD: signify.c,v 1.105 2015/12/04 11:05:22 tedu Exp $ */
d423 18
d443 1
a443 1
    const char *sigcomment)
d454 4
d466 1
a466 1
    int quiet)
d477 1
a477 1
	readpubkey(pubkeyfile, &pubkey, sigcomment);
d486 1
a486 1
    int quiet, unsigned long long *msglenp)
d497 1
a497 1
	readpubkey(pubkeyfile, &pubkey, sigcomment);
d511 1
a511 1
    int embedded, int quiet)
d518 2
a519 1
		msg = verifyembedded(pubkeyfile, sigfile, quiet, &msglen);
d525 1
a525 1
		verifysimple(pubkeyfile, msgfile, sigfile, quiet);
d661 1
a661 1
	msg = verifyembedded(pubkeyfile, sigfile, quiet, &msglen);
d675 1
d692 1
a692 1
	while ((ch = getopt(argc, argv, "CGSVc:em:np:qs:x:")) != -1) {
d737 3
d816 1
a816 1
		verify(pubkeyfile, msgfile, sigfile, embedded, quiet);
@


1.105
log
@polishing
@
text
@d1 1
a1 1
/* $OpenBSD: signify.c,v 1.104 2015/11/02 22:01:10 bluhm Exp $ */
a72 2
extern char *__progname;

d85 1
a85 1
	    __progname);
@


1.104
log
@Make signify's stdout line buffered.  This allows to run the verbose
output through a pipe and still see the progress immediately.
OK tedu@@
@
text
@d1 1
a1 1
/* $OpenBSD: signify.c,v 1.103 2015/10/30 01:57:43 tedu Exp $ */
d370 1
a370 1
	    errx(1, "incorrect passphrase");
d562 1
a562 1
	if (strcmp(c->hash, buf) != 0) {
a563 1
	}
@


1.103
log
@mark usage __dead
@
text
@d1 1
a1 1
/* $OpenBSD: signify.c,v 1.102 2015/10/09 01:37:08 deraadt Exp $ */
d726 3
@


1.102
log
@Change all tame callers to namechange to pledge(2).
@
text
@d1 1
a1 1
/* $OpenBSD: signify.c,v 1.101 2015/10/08 16:45:50 tedu Exp $ */
d75 1
a75 1
static void
@


1.101
log
@add some tame calls. we may need a bunch of permissions to create files
and manipulate the tty for readpassphrase, but once we've parsed options
and have some idea of what's going to happen next, we can reduce down
quite a bit more. particular use case of "signify | patch" is limited to
feeding garbage to patch.
@
text
@d1 1
a1 1
/* $OpenBSD: signify.c,v 1.100 2015/01/16 06:16:12 tedu Exp $ */
d666 2
a667 2
	if (tame("stdio rpath wpath cpath tty", NULL) == -1)
		err(1, "tame");
d733 2
a734 2
		if (tame("stdio rpath", NULL) == -1)
			err(1, "tame");
d738 2
a739 2
			if (tame("stdio rpath wpath cpath", NULL) == -1)
				err(1, "tame");
d741 2
a742 2
			if (tame("stdio rpath", NULL) == -1)
				err(1, "tame");
d746 2
a747 2
		if (tame("stdio", NULL) == -1)
			err(1, "tame");
@


1.100
log
@improve checksum parsing slightly. now handles filenames with spaces.
(though not names with ')'; sorry.)
@
text
@d1 1
a1 1
/* $OpenBSD: signify.c,v 1.99 2015/01/16 06:00:39 tedu Exp $ */
d666 2
d726 24
@


1.99
log
@just to be careful, add a cpp guard that the sscanf sizes are ok
@
text
@d1 1
a1 1
/* $OpenBSD: signify.c,v 1.98 2015/01/15 22:21:01 tedu Exp $ */
d598 1
a598 1
		rv = sscanf(line, "%31s (%1023s = %223s",
d600 1
a600 1
		if (rv != 3 || c.file[0] == 0 || c.file[strlen(c.file)-1] != ')')
a601 1
		c.file[strlen(c.file) - 1] = '\0';
@


1.98
log
@use PATH_MAX for path buffers. in case, you know...
@
text
@d1 1
a1 1
/* $OpenBSD: signify.c,v 1.97 2015/01/09 21:49:59 tedu Exp $ */
d595 3
@


1.97
log
@absurd optimization. reduce initial space by one to avoid leaving one byte
hanging off on a page by itself.
@
text
@d1 1
a1 1
/* $OpenBSD: signify.c,v 1.96 2015/01/07 19:53:34 tedu Exp $ */
d22 1
d511 1
a511 1
	char file[1024];
d651 1
a651 1
	char sigfilebuf[1024];
@


1.96
log
@bcallah noticed the ifndef guard for headers was wrong. don't fix, just
remove it, and put these includes up with their friends.
@
text
@d1 1
a1 1
/* $OpenBSD: signify.c,v 1.95 2014/12/29 14:35:04 tedu Exp $ */
d182 1
a182 1
		space = 64 * 1024;
@


1.95
log
@useless change. overwriting the nul byte with a newline means b64_ntop
can use the whole buffer, even the last byte.
@
text
@d1 1
a1 1
/* $OpenBSD: signify.c,v 1.94 2014/12/29 14:23:17 tedu Exp $ */
d27 2
a35 4
#ifndef VERIFY_ONLY
#include <stddef.h>
#include <ohash.h>
#endif
@


1.94
log
@rename fingerprint struct field. no longer exposed to users, but since it's
not technically a fingerprint as others understand the term, pick another.
now it's a keynum!
after an email from Florian Weimer
@
text
@d1 1
a1 1
/* $OpenBSD: signify.c,v 1.93 2014/12/29 14:16:04 tedu Exp $ */
d238 1
a238 1
	if ((rv = b64_ntop(buf, buflen, b64, sizeof(b64)-1)) == -1)
@


1.93
log
@remove the inspect debug command. should not be used by users, who are not
supposed to know what fingerprints are or that they exist.
@
text
@d1 1
a1 1
/* $OpenBSD: signify.c,v 1.92 2014/11/20 14:51:42 krw Exp $ */
d45 1
a45 1
#define FPLEN 8
d58 1
a58 1
	uint8_t fingerprint[FPLEN];
d64 1
a64 1
	uint8_t fingerprint[FPLEN];
d70 1
a70 1
	uint8_t fingerprint[FPLEN];
d302 1
a302 1
	uint8_t fingerprint[FPLEN];
d308 1
a308 1
	arc4random_buf(fingerprint, sizeof(fingerprint));
d317 1
a317 1
	memcpy(enckey.fingerprint, fingerprint, FPLEN);
d334 1
a334 1
	memcpy(pubkey.fingerprint, fingerprint, FPLEN);
d377 1
a377 1
	memcpy(sig.fingerprint, enckey.fingerprint, FPLEN);
d409 1
a409 1
	if (memcmp(pubkey->fingerprint, sig->fingerprint, FPLEN) != 0)
@


1.92
log
@Yet more #include de-duplication.

ok deraadt@@ tedu@@
@
text
@d1 1
a1 1
/* $OpenBSD: signify.c,v 1.91 2014/07/13 18:59:40 tedu Exp $ */
a84 1
	    "\t%1$s -I [-p pubkey] [-s seckey] [-x sigfile]\n"
a399 25

static void
inspect(const char *seckeyfile, const char *pubkeyfile, const char *sigfile)
{
	struct sig sig;
	struct enckey enckey;
	struct pubkey pubkey;
	char fp[(FPLEN + 2) / 3 * 4 + 1];

	if (seckeyfile) {
		readb64file(seckeyfile, &enckey, sizeof(enckey), NULL);
		b64_ntop(enckey.fingerprint, FPLEN, fp, sizeof(fp));
		printf("sec fp: %s\n", fp);
	}
	if (pubkeyfile) {
		readb64file(pubkeyfile, &pubkey, sizeof(pubkey), NULL);
		b64_ntop(pubkey.fingerprint, FPLEN, fp, sizeof(fp));
		printf("pub fp: %s\n", fp);
	}
	if (sigfile) {
		readb64file(sigfile, &sig, sizeof(sig), NULL);
		b64_ntop(sig.fingerprint, FPLEN, fp, sizeof(fp));
		printf("sig fp: %s\n", fp);
	}
}
a660 1
		INSPECT,
d668 1
a668 1
	while ((ch = getopt(argc, argv, "CGISVc:em:np:qs:x:")) != -1) {
a680 5
		case 'I':
			if (verb)
				usage(NULL);
			verb = INSPECT;
			break;
a751 3
		break;
	case INSPECT:
		inspect(seckeyfile, pubkeyfile, sigfile);
@


1.91
log
@compare snprintf return value with -1. this isn't really necessary because
int promotion rules guarantee the correct result when compared with sizeof,
but it is perhaps easier for some people to understand it this way.
from Doug Hogan.
@
text
@d1 1
a1 1
/* $OpenBSD: signify.c,v 1.90 2014/05/30 21:20:49 tedu Exp $ */
a34 1
#include <stdint.h>
@


1.90
log
@don't assign variables in if() that's not error checking
@
text
@d1 1
a1 1
/* $OpenBSD: signify.c,v 1.89 2014/05/30 21:17:42 tedu Exp $ */
d233 1
a233 1
	int fd, rv;
d236 2
a237 2
	if (snprintf(header, sizeof(header), "%s%s\n",
	    COMMENTHDR, comment) >= sizeof(header))
d307 1
a307 1
	int i;
d328 2
a329 2
	if (snprintf(commentbuf, sizeof(commentbuf), "%s secret key",
	    comment) >= sizeof(commentbuf))
d337 2
a338 2
	if (snprintf(commentbuf, sizeof(commentbuf), "%s public key",
	    comment) >= sizeof(commentbuf))
d356 1
a356 1
	int i, rounds;
d385 2
a386 2
		if (snprintf(sigcomment, sizeof(sigcomment), VERIFYWITH "%.*s.pub",
		    (int)strlen(seckeyfile) - 4, seckeyfile) >= sizeof(sigcomment))
d389 2
a390 2
		if (snprintf(sigcomment, sizeof(sigcomment), "signature from %s",
		    comment) >= sizeof(sigcomment))
d770 1
d773 2
a774 2
		if (snprintf(sigfilebuf, sizeof(sigfilebuf), "%s.sig",
		    msgfile) >= sizeof(sigfilebuf))
@


1.89
log
@a little style consistency with error checking
@
text
@d1 1
a1 1
/* $OpenBSD: signify.c,v 1.88 2014/05/16 18:35:01 tedu Exp $ */
d383 2
a384 1
	if ((secname = strstr(seckeyfile, ".sec")) && strlen(secname) == 4) {
d460 2
a461 1
		if ((pubkeyfile = strstr(sigcomment, VERIFYWITH))) {
@


1.88
log
@save up the failures for the end in the argc == 0.
help ok espie
@
text
@d1 1
a1 1
/* $OpenBSD: signify.c,v 1.87 2014/05/16 17:46:07 tedu Exp $ */
d123 1
a123 2
	p = malloc(len);
	if (!p)
d145 1
a145 2
	b64end = strchr(commentend + 1, '\n');
	if (!b64end)
d162 1
a162 2
	rv = read(fd, b64, sizeof(b64) - 1);
	if (rv == -1)
d219 1
a219 2
		x = write(fd, buf, buflen);
		if (x == -1)
d547 1
a547 2
	p = calloc(s1, s2);
	if (!p)
@


1.87
log
@a few changes for new code to match local style
@
text
@d1 1
a1 1
/* $OpenBSD: signify.c,v 1.86 2014/05/16 17:42:24 tedu Exp $ */
d607 1
a607 2
	char *line, *endline;
	const char *e;
d612 1
a613 1
		ohash_init(&myh, 6, &info);
d641 7
a647 2
				fprintf(stderr, "%s: FAIL\n", c.file);
				hasfailed = 1;
d652 5
a656 10
	if (argc) {
		for (i = 0; i < argc; i++) {
			slot = ohash_qlookup(&myh, argv[i]);
			e = ohash_find(&myh, slot);
			if (e != NULL) {
				fprintf(stderr, "%s: FAIL\n", argv[i]);
				hasfailed = 1;
			}
	    	}
		ohash_delete(&myh);
d658 1
@


1.86
log
@checksum mode can use magic pubkey finder too
@
text
@d1 1
a1 1
/* $OpenBSD: signify.c,v 1.85 2014/05/16 16:18:33 espie Exp $ */
d549 3
a551 1
	void *p = calloc(s1, s2);
d581 1
d604 1
a604 2

	struct ohash_info info = {  0, NULL, ecalloc, efree, NULL };
a605 1
	unsigned int i;
d608 1
d610 1
a610 2
	int rv;
	const char *e;
a612 1

d631 1
a631 1
		c.file[strlen(c.file) - 1] = 0;
d637 1
a637 1
				if (verifychecksum(&c, quiet))
d641 1
a641 1
			if (!verifychecksum(&c, quiet)) {
@


1.85
log
@rework -C (perfect candidate for using hash tables, really):

insert files we want to check into a hash,
parse SHA256 message on the fly, delete entries whose checksum match,
then display entries that failed.

This completely avoids allocating temporary storage for file names and checksums
and removes the quadratic match (argv[i] vs line[n]).

okay tedu@@
@
text
@d1 1
a1 1
/* $OpenBSD: signify.c,v 1.83 2014/05/14 16:02:34 tedu Exp $ */
d762 2
a763 2
		if (!pubkeyfile || !sigfile)
			usage("must specify pubkey and sigfile");
@


1.84
log
@fix the band-aid error.
tedu was bitten by the RETARDED interface in sha2.h (who names string LENGTH
things that are actually buffer SIZES) ?
make -C mode work again.

okay beck@@
@
text
@d34 5
d546 15
d562 1
a562 1
recodehash(char *hash)
d567 1
a567 2
	if (strlen(hash)+1 == SHA256_DIGEST_STRING_LENGTH ||
	    strlen(hash)+1 == SHA512_DIGEST_STRING_LENGTH)
d575 23
d601 5
a605 1
	char buf[1024];
d607 15
a621 4
	struct checksum *checksums = NULL, *c = NULL;
	int nchecksums = 0, checksumspace = 0;
	int i, j, rv, uselist, count, hasfailed;
	int *failures;
a624 7
		if (nchecksums == checksumspace) {
			checksumspace = 2 * (nchecksums + 1);
			if (!(checksums = reallocarray(checksums,
			    checksumspace, sizeof(*checksums))))
				err(1, "realloc");
		}
		c = &checksums[nchecksums++];
d627 3
a629 3
		rv = sscanf(line, "%31s %1023s = %223s",
		    c->algo, buf, c->hash);
		if (rv != 3 || buf[0] != '(' || buf[strlen(buf) - 1] != ')')
d631 1
a631 3
		recodehash(c->hash);
		buf[strlen(buf) - 1] = 0;
		strlcpy(c->file, buf + 1, sizeof(c->file));
d633 7
a639 14
	}

	if (argc) {
		uselist = 0;
		count = argc;
	} else {
		uselist = 1;
		count = nchecksums;
	}
	if (!(failures = calloc(count, sizeof(*failures))))
		err(1, "calloc");
	for (i = 0; i < count; i++) {
		if (uselist) {
			c = &checksums[i];
d641 3
a643 8
			for (j = 0; j < nchecksums; j++) {
				c = &checksums[j];
				if (strcmp(c->file, argv[i]) == 0)
					break;
			}
			if (j == nchecksums) {
				failures[i] = 1;
				continue;
d646 1
d648 7
a654 9
		if (strcmp(c->algo, "SHA256") == 0) {
			if (!SHA256File(c->file, buf)) {
				failures[i] = 1;
				continue;
			}
		} else if (strcmp(c->algo, "SHA512") == 0) {
			if (!SHA512File(c->file, buf)) {
				failures[i] = 1;
				continue;
d656 2
a657 17
		} else {
			errx(1, "can't handle algorithm %s", c->algo);
		}
		if (strcmp(c->hash, buf) != 0) {
			failures[i] = 1;
			continue;
		}
		if (!quiet)
			printf("%s: OK\n", c->file);
	}
	hasfailed = 0;
	for (i = 0; i < count; i++) {
		if (failures[i]) {
			fprintf(stderr, "%s: FAIL\n",
			    uselist ? checksums[i].file : argv[i]);
			hasfailed = 1;
		}
a660 2
	free(checksums);
	free(failures);
@


1.83
log
@let cpp do some of the work
@
text
@d1 1
a1 1
/* $OpenBSD: signify.c,v 1.82 2014/05/14 15:56:41 tedu Exp $ */
d547 2
a548 2
	if (strlen(hash) == SHA256_DIGEST_STRING_LENGTH ||
	    strlen(hash) == SHA512_DIGEST_STRING_LENGTH)
@


1.82
log
@spell out base64 in error messages
@
text
@d1 1
a1 1
/* $OpenBSD: signify.c,v 1.81 2014/05/14 15:55:11 tedu Exp $ */
d534 1
d537 1
a537 1
	char hash[224];
d544 1
a544 1
	uint8_t data[112];
d553 1
a553 1
		snprintf(hash + i * 2, 1024 - i * 2, "%2.2x", data[i]);
@


1.81
log
@save some memory by reducing buffer sizes
@
text
@d1 1
a1 1
/* $OpenBSD: signify.c,v 1.80 2014/05/14 15:52:24 tedu Exp $ */
d143 1
a143 1
		errx(1, "missing new line after b64 in %s", filename);
d146 1
a146 1
		errx(1, "invalid b64 encoding in %s", filename);
d240 1
a240 1
		errx(1, "b64 encode failed");
@


1.80
log
@recode base64 hashes if necessary
@
text
@d1 1
a1 1
/* $OpenBSD: signify.c,v 1.79 2014/05/14 15:33:41 tedu Exp $ */
d536 2
a537 2
	char hash[1024];
	char algo[256];
d543 1
a543 1
	uint8_t data[512];
d576 1
a576 1
		rv = sscanf(line, "%255s %1023s = %1023s",
@


1.79
log
@realloc like a boss, so checksum verification doesn't take minutes.
@
text
@d1 1
a1 1
/* $OpenBSD: signify.c,v 1.78 2014/05/06 23:50:53 tedu Exp $ */
d541 15
d580 1
@


1.78
log
@temp variable for a bit of clarity
@
text
@d1 1
a1 1
/* $OpenBSD: signify.c,v 1.77 2014/05/06 23:33:04 tedu Exp $ */
d546 1
a546 1
	int nchecksums = 0;
d552 6
a557 3
		if (!(checksums = reallocarray(checksums,
		    nchecksums + 1, sizeof(*checksums))))
			err(1, "realloc");
@


1.77
log
@remove unneeded variable
@
text
@d1 1
a1 1
/* $OpenBSD: signify.c,v 1.76 2014/05/06 23:27:50 tedu Exp $ */
d547 1
a547 1
	int i, j, uselist, count, hasfailed;
d557 4
a560 4
			*endline++ = 0;
		if (sscanf(line, "%255s %1023s = %1023s",
		    c->algo, buf, c->hash) != 3 ||
		    buf[0] != '(' || buf[strlen(buf) - 1] != ')')
@


1.76
log
@factor out the safepath
@
text
@d1 1
a1 1
/* $OpenBSD: signify.c,v 1.75 2014/05/06 23:24:19 tedu Exp $ */
a127 1
	int rv;
d145 1
a145 2
	rv = b64_pton(commentend + 1, buf, buflen);
	if (rv != buflen)
@


1.75
log
@be more explicit about what's a string
@
text
@d1 1
a1 1
/* $OpenBSD: signify.c,v 1.74 2014/05/06 23:19:46 tedu Exp $ */
d457 1
d462 1
a462 1
			if (strncmp(pubkeyfile, "/etc/signify/", 13) != 0 ||
@


1.74
log
@better alloc idiom
@
text
@d1 1
a1 1
/* $OpenBSD: signify.c,v 1.73 2014/05/06 23:17:13 tedu Exp $ */
d136 1
a136 1
	*commentend = 0;
d145 1
a145 1
	*b64end = 0;
a160 1
	memset(b64, 0, sizeof(b64));
d164 1
d206 1
a206 1
	msg[msglen] = 0;
@


1.73
log
@factor max message size
@
text
@d1 1
a1 1
/* $OpenBSD: signify.c,v 1.72 2014/04/22 21:24:20 tedu Exp $ */
d575 1
a575 1
	if (!(failures = calloc(count, sizeof(int))))
@


1.72
log
@use reallocarray
@
text
@d1 1
a1 1
/* $OpenBSD: signify.c,v 1.71 2014/04/22 05:44:40 tedu Exp $ */
d178 1
d182 1
a182 1
		if (sb.st_size > (1UL << 30))
d192 1
a192 1
			if (msglen * 2 > (1UL << 30))
@


1.71
log
@errx when errno won't be set.
@
text
@d1 1
a1 1
/* $OpenBSD: signify.c,v 1.70 2014/04/14 00:35:32 tedu Exp $ */
d552 2
a553 2
		if (!(checksums = realloc(checksums,
		    sizeof(*c) * (nchecksums + 1))))
@


1.70
log
@confirm passwords when generating keys
@
text
@d1 1
a1 1
/* $OpenBSD: signify.c,v 1.69 2014/03/17 15:19:06 tedu Exp $ */
d140 1
a140 1
			err(1, "comment too long");
d238 1
a238 1
		err(1, "comment too long");
d330 1
a330 1
		err(1, "comment too long");
d339 1
a339 1
		err(1, "comment too long");
d386 1
a386 1
			err(1, "comment too long");
d390 1
a390 1
			err(1, "comment too long");
@


1.69
log
@quiet time is over
@
text
@d1 1
a1 1
/* $OpenBSD: signify.c,v 1.68 2014/03/17 11:47:06 espie Exp $ */
d251 1
a251 1
kdf(uint8_t *salt, size_t saltlen, int rounds, int allowstdin,
d268 9
d321 1
a321 1
	kdf(enckey.salt, sizeof(enckey.salt), rounds, 1, xorkey, sizeof(xorkey));
d365 1
a365 1
	    xorkey, sizeof(xorkey));
@


1.68
log
@clean up after ourselves.
okay tedu@@
@
text
@d1 1
a1 1
/* $OpenBSD: signify.c,v 1.67 2014/03/17 04:09:39 tedu Exp $ */
a720 2

	quiet = 1; /* retain quiet default for 5.5 release */
@


1.67
log
@simplify readmsg loop
@
text
@d1 1
a1 1
/* $OpenBSD: signify.c,v 1.66 2014/03/17 03:33:57 tedu Exp $ */
d517 1
@


1.66
log
@tweak a few messages
@
text
@d1 1
a1 1
/* $OpenBSD: signify.c,v 1.65 2014/03/17 03:10:26 tedu Exp $ */
a177 1
	const size_t chunklen = 64 * 1024;
a183 1
		msg = xmalloc(space + 1);
d185 1
a185 1
		space = 0;
d188 1
d191 3
a193 1
			space = msglen + chunklen;
a202 2
		if (msglen > (1UL << 30))
			errx(1, "msg too large in %s", filename);
@


1.65
log
@check memcmp return explicitly
@
text
@d1 1
a1 1
/* $OpenBSD: signify.c,v 1.64 2014/03/17 03:07:10 tedu Exp $ */
d109 1
a109 1
		errx(1, "can't use directory as file: %s", fname);
d456 1
a456 1
			usage("need pubkey");
d716 1
a716 1
			usage("need pubkey and sigfile");
d729 1
a729 1
			errx(1, "must specify sigfile with - message");
d740 1
a740 1
			usage("need pubkey and seckey");
d748 1
a748 1
			usage("need message and seckey");
d754 1
a754 1
			usage("need message");
@


1.64
log
@pull out the pubkey reading bits
@
text
@d1 1
a1 1
/* $OpenBSD: signify.c,v 1.63 2014/03/17 02:54:54 tedu Exp $ */
d133 1
a133 1
	    memcmp(b64, COMMENTHDR, COMMENTHDRLEN))
d149 1
a149 1
	if (memcmp(buf, PKALG, 2))
d353 1
a353 1
	if (memcmp(enckey.kdfalg, KDFALG, 2))
d364 1
a364 1
	if (memcmp(enckey.checksum, digest, sizeof(enckey.checksum)))
d427 1
a427 1
	if (memcmp(pubkey->fingerprint, sig->fingerprint, FPLEN))
@


1.63
log
@refactor and recombine verify functions.
@
text
@d1 1
a1 1
/* $OpenBSD: signify.c,v 1.60 2014/03/17 00:01:58 tedu Exp $ */
d444 16
d465 1
a465 1
	char comment[COMMENTMAXLEN];
d473 2
a474 11
	readb64file(sigfile, &sig, sizeof(sig), comment);
	if (!pubkeyfile) {
		if ((pubkeyfile = strstr(comment, VERIFYWITH))) {
			pubkeyfile += strlen(VERIFYWITH);
			if (strncmp(pubkeyfile, "/etc/signify/", 13) != 0 ||
			    strstr(pubkeyfile, "/../") != NULL)
				errx(1, "untrusted path %s", pubkeyfile);
		} else
			usage("need pubkey");
	}
	readb64file(pubkeyfile, &pubkey, sizeof(pubkey), NULL);
d485 1
a485 1
	char comment[COMMENTMAXLEN];
d493 3
a495 1
	siglen = parseb64file(sigfile, msg, &sig, sizeof(sig), comment);
a498 10
	if (!pubkeyfile) {
		if ((pubkeyfile = strstr(comment, VERIFYWITH))) {
			pubkeyfile += strlen(VERIFYWITH);
			if (strncmp(pubkeyfile, "/etc/signify/", 13) != 0 ||
			    strstr(pubkeyfile, "/../") != NULL)
				errx(1, "untrusted path %s", pubkeyfile);
		} else
			usage("need pubkey");
	}
	readb64file(pubkeyfile, &pubkey, sizeof(pubkey), NULL);
@


1.62
log
@move fingerprint check into verifymsg
(stop printing fingerprints here; probably not that helpful)
@
text
@d1 1
a1 1
/* $OpenBSD: signify.c,v 1.61 2014/03/17 01:23:58 deraadt Exp $ */
d446 2
a447 2
verify(const char *pubkeyfile, const char *msgfile, const char *sigfile,
    int embedded, int quiet)
d452 1
a452 1
	unsigned long long msglen, siglen = 0;
a453 1
	int fd;
d455 1
a455 1
	msg = readmsg(embedded ? sigfile : msgfile, &msglen);
d457 9
a465 6
	if (embedded) {
		siglen = parseb64file(sigfile, msg, &sig, sizeof(sig), comment);
		msg += siglen;
		msglen -= siglen;
	} else {
		readb64file(sigfile, &sig, sizeof(sig), comment);
d467 23
d502 13
d516 1
d520 2
a522 2

	free(msg - siglen);
d621 1
a621 4
	char comment[COMMENTMAXLEN];
	struct sig sig;
	struct pubkey pubkey;
	unsigned long long msglen, siglen;
d624 1
a624 17
	msg = readmsg(sigfile, &msglen);

	siglen = parseb64file(sigfile, msg, &sig, sizeof(sig), comment);
	if (!pubkeyfile) {
		if ((pubkeyfile = strstr(comment, VERIFYWITH)))
			pubkeyfile += strlen(VERIFYWITH);
			if (strncmp(pubkeyfile, "/etc/signify/", 13) != 0 ||
			    strstr(pubkeyfile, "/../") != NULL)
				errx(1, "untrusted path %s", pubkeyfile);
		else
			usage("need pubkey");
	}
	readb64file(pubkeyfile, &pubkey, sizeof(pubkey), NULL);
	msg += siglen;
	msglen -= siglen;

	verifymsg(&pubkey, msg, msglen, &sig, quiet);
d627 1
a627 1
	free(msg - siglen);
@


1.61
log
@clarify a variable or two; ok tedu
@
text
@d1 1
a1 1
/* $OpenBSD: signify.c,v 1.60 2014/03/17 00:01:58 tedu Exp $ */
d421 2
a422 2
verifymsg(uint8_t *pubkey, uint8_t *msg, unsigned long long msglen,
    uint8_t *sig, int quiet)
d427 3
d433 1
a433 1
	memcpy(sigbuf, sig, SIGBYTES);
d436 1
a436 1
	    pubkey) == -1)
d476 1
a476 8
	if (memcmp(pubkey.fingerprint, sig.fingerprint, FPLEN)) {
#ifndef VERIFYONLY
		inspect(NULL, pubkeyfile, sigfile);
#endif
		errx(1, "verification failed: checked against wrong key");
	}

	verifymsg(pubkey.pubkey, msg, msglen, sig.sig, quiet);
d604 1
a604 8
	if (memcmp(pubkey.fingerprint, sig.fingerprint, FPLEN)) {
#ifndef VERIFYONLY
		inspect(NULL, pubkeyfile, sigfile);
#endif
		errx(1, "verification failed: checked against wrong key");
	}

	verifymsg(pubkey.pubkey, msg, msglen, sig.sig, quiet);
@


1.60
log
@have to fill in comment before we can use it.
@
text
@d1 1
a1 1
/* $OpenBSD: signify.c,v 1.59 2014/03/16 23:39:42 tedu Exp $ */
d90 1
a90 1
xopen(const char *fname, int flags, mode_t mode)
d96 1
a96 1
		if ((flags & O_WRONLY))
d103 1
a103 1
		fd = open(fname, flags, mode);
d106 1
a106 1
			    (flags & O_WRONLY) ? "writing" : "reading");
d223 1
a223 1
		buf = (char*)buf + x;
d230 1
a230 1
    size_t buflen, const void *msg, size_t msglen, int flags, mode_t mode)
d236 1
a236 1
	fd = xopen(filename, O_CREAT|flags|O_NOFOLLOW|O_WRONLY, mode);
@


1.59
log
@do filename check in the other place too. needs a refactor
@
text
@d1 1
a1 1
/* $OpenBSD: signify.c,v 1.58 2014/03/16 23:29:41 tedu Exp $ */
d594 1
a594 1
	siglen = parseb64file(sigfile, msg, &sig, sizeof(sig), NULL);
@


1.58
log
@resolve espie's complaints about appendall (maybe) by folding it into
writeb64file. idea from deraadt
@
text
@d1 1
a1 1
/* $OpenBSD: signify.c,v 1.57 2014/03/16 22:43:13 tedu Exp $ */
d598 3
@


1.57
log
@oops, forgot the err function here. noticed by Henri Kemppainen
@
text
@d1 1
a1 1
/* $OpenBSD: signify.c,v 1.56 2014/03/16 22:01:35 tedu Exp $ */
a228 10
appendall(const char *filename, const void *buf, size_t buflen)
{
	int fd;

	fd = xopen(filename, O_NOFOLLOW | O_WRONLY | O_APPEND, 0);
	writeall(fd, buf, buflen, filename);
	close(fd);
}

static void
d230 1
a230 1
    size_t buflen, int flags, mode_t mode)
d246 2
d324 1
a324 1
	    sizeof(enckey), O_EXCL, 0600);
d333 1
a333 1
	    sizeof(pubkey), O_EXCL, 0666);
a383 1
	writeb64file(sigfile, sigcomment, &sig, sizeof(sig), O_TRUNC, 0666);
d385 5
a389 1
		appendall(sigfile, msg, msglen);
@


1.56
log
@we want strncmp here to be safer. spotted by halex.
@
text
@d1 1
a1 1
/* $OpenBSD: signify.c,v 1.55 2014/03/16 20:17:10 tedu Exp $ */
d385 2
a386 1
		    (int)strlen(seckeyfile) - 4, seckeyfile) >= sizeof(sigcomment));
@


1.55
log
@grow buffer faster
@
text
@d1 1
a1 1
/* $OpenBSD: signify.c,v 1.54 2014/03/16 18:12:08 tedu Exp $ */
d469 1
a469 1
			if (strstr(pubkeyfile, "/etc/signify/") == NULL ||
@


1.54
log
@tweak path checks. now you can create keys named ......pub
by deraadt
@
text
@d1 1
a1 1
/* $OpenBSD: signify.c,v 1.53 2014/03/16 18:09:49 tedu Exp $ */
d192 1
a192 1
			space = chunklen;
@


1.53
log
@prevent common(?) mistake. can't use a directory as a file
@
text
@d1 1
a1 1
/* $OpenBSD: signify.c,v 1.52 2014/03/16 18:03:19 tedu Exp $ */
d469 2
a470 2
			if (strstr(pubkeyfile, "/etc/signify") == NULL ||
			    strstr(pubkeyfile, "..") != NULL)
@


1.52
log
@check the inferred path is in /etc/signify
@
text
@d1 1
a1 1
/* $OpenBSD: signify.c,v 1.51 2014/03/16 17:58:28 tedu Exp $ */
d92 1
d108 2
@


1.51
log
@start trusting the untrusted comment. (a little)
embed the name of the verification key to save some typing
@
text
@d1 1
a1 1
/* $OpenBSD: signify.c,v 1.50 2014/03/07 19:53:33 tedu Exp $ */
d464 1
a464 1
		if ((pubkeyfile = strstr(comment, VERIFYWITH)))
d466 4
a469 1
		else
@


1.50
log
@if message file is stdin, don't read passphrase from stdin, it won't work.
too many features; this circus needs a lion tamer
@
text
@d1 1
a1 1
/* $OpenBSD: signify.c,v 1.49 2014/03/07 19:49:44 tedu Exp $ */
d46 1
d350 2
a351 1
	char comment[COMMENTMAXLEN], sigcomment[1024];
d380 8
a387 3
	if (snprintf(sigcomment, sizeof(sigcomment), "signature from %s",
	    comment) >= sizeof(sigcomment))
		err(1, "comment too long");
d447 1
a455 1
	readb64file(pubkeyfile, &pubkey, sizeof(pubkey), NULL);
d457 1
a457 1
		siglen = parseb64file(sigfile, msg, &sig, sizeof(sig), NULL);
d461 7
a467 1
		readb64file(sigfile, &sig, sizeof(sig), NULL);
d469 1
d584 1
d592 7
a599 1
	siglen = parseb64file(sigfile, msg, &sig, sizeof(sig), NULL);
d740 2
a741 2
		if (!msgfile || !pubkeyfile)
			usage("need message and pubkey");
@


1.49
log
@allow reading input messages on a pipe. use at your own peril.
@
text
@d1 1
a1 1
/* $OpenBSD: signify.c,v 1.48 2014/03/06 20:04:45 tedu Exp $ */
d256 2
a257 1
kdf(uint8_t *salt, size_t saltlen, int rounds, uint8_t *key, size_t keylen)
d267 1
a267 1
	if (!isatty(STDIN_FILENO))
d317 1
a317 1
	kdf(enckey.salt, sizeof(enckey.salt), rounds, xorkey, sizeof(xorkey));
d359 2
a360 1
	kdf(enckey.salt, sizeof(enckey.salt), rounds, xorkey, sizeof(xorkey));
@


1.48
log
@allow password on stdin if it's not a tty. commonly requested.
@
text
@d1 1
a1 1
/* $OpenBSD: signify.c,v 1.47 2014/03/06 15:01:58 naddy Exp $ */
a119 14
static void
readall(int fd, void *buf, size_t buflen, const char *filename)
{
	ssize_t x;

	while (buflen != 0) {
		x = read(fd, buf, buflen);
		if (x == -1)
			err(1, "read from %s", filename);
		buflen -= x;
		buf = (char*)buf + x;
	}
}

d169 2
a170 2
	unsigned long long msglen;
	uint8_t *msg;
d172 1
d174 1
d177 25
a201 9
	if (fstat(fd, &sb) == -1)
		err(1, "fstat on %s", filename);
	if (!S_ISREG(sb.st_mode))
		errx(1, "%s must be a regular file", filename);
	msglen = sb.st_size;
	if (msglen > (1UL << 30))
		errx(1, "msg too large in %s", filename);
	msg = xmalloc(msglen + 1);
	readall(fd, msg, msglen, filename);
@


1.47
log
@tweak; from jmc@@ and yours truly
ok jmc@@ tedu@@
@
text
@d1 1
a1 1
/* $OpenBSD: signify.c,v 1.46 2014/03/05 23:11:18 tedu Exp $ */
d255 1
d262 3
a264 1
	if (!readpassphrase("passphrase: ", pass, sizeof(pass), RPP_ECHO_OFF))
@


1.46
log
@consistently say buflen so i know what length it is
@
text
@d1 1
a1 1
/* $OpenBSD: signify.c,v 1.45 2014/03/05 23:03:19 tedu Exp $ */
d78 1
a78 1
	    "\t%1$s -C [-q] -p pubkey -x sigfile [files...]\n"
@


1.45
log
@when reading a message, add one byte so we can nul terminuate.
simplify verifychecksums with the knowledge that input is a proper string.
@
text
@d1 1
a1 1
/* $OpenBSD: signify.c,v 1.44 2014/03/05 22:55:07 tedu Exp $ */
d121 1
a121 1
readall(int fd, void *buf, size_t len, const char *filename)
d125 2
a126 2
	while (len != 0) {
		x = read(fd, buf, len);
d129 1
a129 1
		len -= x;
d135 1
a135 1
parseb64file(const char *filename, char *b64, void *buf, size_t len,
d156 2
a157 2
	rv = b64_pton(commentend + 1, buf, len);
	if (rv != len)
d165 1
a165 1
readb64file(const char *filename, void *buf, size_t len, char *comment)
d175 1
a175 1
	parseb64file(filename, b64, buf, len, comment);
d206 1
a206 1
writeall(int fd, const void *buf, size_t len, const char *filename)
d210 2
a211 2
	while (len != 0) {
		x = write(fd, buf, len);
d214 1
a214 1
		len -= x;
d221 1
a221 1
appendall(const char *filename, const void *buf, size_t len)
d226 1
a226 1
	writeall(fd, buf, len, filename);
d232 1
a232 1
    size_t len, int flags, mode_t mode)
d243 1
a243 1
	if ((rv = b64_ntop(buf, len, b64, sizeof(b64)-1)) == -1)
@


1.44
log
@tighten up code a little
@
text
@d1 1
a1 1
/* $OpenBSD: signify.c,v 1.43 2014/03/05 22:53:36 tedu Exp $ */
d196 1
a196 1
	msg = xmalloc(msglen);
d198 1
d473 1
a473 2
verifychecksums(const char *msg, unsigned long long msglen, int argc,
    char **argv, int quiet)
d476 1
a476 1
	char *input, *line, *endline;
d482 1
a482 3
	if (!(input = strndup(msg, msglen)))
		err(1, "strndup");
	line = input;
a497 1
	free(input);
d581 1
a581 1
	verifychecksums(msg, msglen, argc, argv, quiet);
@


1.43
log
@check calloc and free memory. noticed by jsg and lteo.
tweak failure tracking
@
text
@d1 1
a1 1
/* $OpenBSD: signify.c,v 1.42 2014/03/04 16:44:07 tedu Exp $ */
d129 2
a130 4
		else {
			len -= x;
			buf = (char*)buf + x;
		}
d213 2
a214 4
		else {
			len -= x;
			buf = (char*)buf + x;
		}
@


1.42
log
@add -C checksum mode, which works with sha256 files in safe easy fashion.
ok deraadt
@
text
@d1 1
a1 1
/* $OpenBSD: signify.c,v 1.41 2014/01/22 21:11:03 tedu Exp $ */
d483 1
a483 1
	int i, j, uselist, count, failcount;
d513 2
a514 1
	failures = calloc(count, sizeof(int));
d550 1
a550 1
	failcount = 0;
d555 1
a555 1
			failcount++;
d558 1
a558 1
	if (failcount)
d561 1
@


1.41
log
@replace sensitive memsets with explicit_bzero
@
text
@d1 1
a1 1
/* $OpenBSD: signify.c,v 1.40 2014/01/19 23:20:30 deraadt Exp $ */
d78 1
d83 1
a83 1
	    "\t%1$s -V [-e] [-x sigfile] -p pubkey -m message\n",
d410 1
a410 1
    uint8_t *sig)
d423 2
d432 1
a432 1
    int embedded)
d458 1
a458 1
	verifymsg(pubkey.pubkey, msg, msglen, sig.sig);
d468 124
d601 1
d604 1
d614 1
a614 1
	while ((ch = getopt(argc, argv, "GISVc:em:np:s:x:")) != -1) {
d617 5
d658 3
d675 11
d717 1
a717 1
		verify(pubkeyfile, msgfile, sigfile, embedded);
@


1.40
log
@do not truncate strlcpy/snprintf, fail hard and proper
ok tedu
@
text
@d1 1
a1 1
/* $OpenBSD: signify.c,v 1.39 2014/01/19 18:39:34 tedu Exp $ */
d177 1
a177 1
	memset(b64, 0, sizeof(b64));
d249 1
a249 1
	memset(b64, 0, sizeof(b64));
d270 1
a270 1
	memset(pass, 0, sizeof(pass));
d315 2
a316 2
	memset(digest, 0, sizeof(digest));
	memset(xorkey, 0, sizeof(xorkey));
d323 1
a323 1
	memset(&enckey, 0, sizeof(enckey));
d356 1
a356 1
	memset(xorkey, 0, sizeof(xorkey));
d362 1
a362 1
	memset(digest, 0, sizeof(digest));
d368 1
a368 1
	memset(&enckey, 0, sizeof(enckey));
@


1.39
log
@better error message for readpassphrase. from fritjof. ok deraadt
@
text
@d1 1
a1 1
/* $OpenBSD: signify.c,v 1.38 2014/01/15 00:31:34 espie Exp $ */
d148 5
a152 2
	if (comment)
		strlcpy(comment, b64 + COMMENTHDRLEN, COMMENTMAXLEN);
d241 3
a243 1
	snprintf(header, sizeof(header), "%s%s\n", COMMENTHDR, comment);
d318 3
a320 1
	snprintf(commentbuf, sizeof(commentbuf), "%s secret key", comment);
d327 3
a329 1
	snprintf(commentbuf, sizeof(commentbuf), "%s public key", comment);
d371 3
a373 1
	snprintf(sigcomment, sizeof(sigcomment), "signature from %s", comment);
@


1.38
log
@pipes mean read/write may short out.

okay tedu@@
@
text
@d1 1
a1 1
/* $OpenBSD: signify.c,v 1.32 2014/01/13 09:41:16 espie Exp $ */
d258 2
a259 2
	if (!readpassphrase("passphrase: ", pass, sizeof(pass), 0))
		errx(1, "readpassphrase");
@


1.37
log
@most common pbkdf failure is no password, so check that first.
prompted by fritjof
@
text
@d1 1
a1 1
/* $OpenBSD: signify.c,v 1.36 2014/01/14 21:33:10 tedu Exp $ */
d123 9
a131 6
	
	x = read(fd, buf, len);
	if (x == -1) {
		err(1, "read from %s", filename);
	} else if (x != len) {
		errx(1, "short read from %s", filename);
d206 9
a214 6
	
	x = write(fd, buf, len);
	if (x == -1) {
		err(1, "write to %s", filename);
	} else if (x != len) {
		errx(1, "short write to %s", filename);
@


1.36
log
@rearrange the bottom of main so it is less of a "zoo". ok deraadt
@
text
@d1 1
a1 1
/* $OpenBSD: signify.c,v 1.35 2014/01/14 17:25:06 tedu Exp $ */
d254 2
@


1.35
log
@this can be static
@
text
@d1 1
a1 1
/* $OpenBSD: signify.c,v 1.34 2014/01/14 17:15:12 tedu Exp $ */
d522 8
a529 2
	if (verb == NONE)
		usage(NULL);
d531 1
d533 1
a533 1
	if (verb == GENERATE) {
d537 2
a538 1
	} else if (verb == INSPECT) {
d540 6
a545 1
	} else
d547 8
a554 24
	{
		if (!msgfile)
			usage("need message");

		if (!sigfile) {
			if (strcmp(msgfile, "-") == 0)
				errx(1, "must specify sigfile with - message");
			if (snprintf(sigfilebuf, sizeof(sigfilebuf), "%s.sig",
			    msgfile) >= sizeof(sigfilebuf))
				errx(1, "path too long");
			sigfile = sigfilebuf;
		}
#ifndef VERIFYONLY
		if (verb == SIGN) {
			if (!seckeyfile)
				usage("need seckey");
			sign(seckeyfile, msgfile, sigfile, embedded);
		} else
#endif
		if (verb == VERIFY) {
			if (!pubkeyfile)
				usage("need pubkey");
			verify(pubkeyfile, msgfile, sigfile, embedded);
		}
@


1.34
log
@stdlib.h for malloc. from Fritjof
@
text
@d1 1
a1 1
/* $OpenBSD: signify.c,v 1.33 2014/01/13 09:42:53 espie Exp $ */
d175 1
a175 1
uint8_t *
@


1.33
log
@premature, only wanted to commit n: -> n
@
text
@d1 1
a1 1
/* $OpenBSD: signify.c,v 1.31 2014/01/13 01:40:43 tedu Exp $ */
d26 1
@


1.32
log
@duh, -n does not take args
@
text
@d122 6
a127 9

	while (len != 0) {
		x = read(fd, buf, len);
		if (x == -1)
			err(1, "read from %s", filename);
		else {
			len -= x;
			buf += x;
		}
d202 6
a207 9

	while (len != 0) {
		x = write(fd, buf, len);
		if (x == -1)
			err(1, "write to %s", filename);
		else {
			len -= x;
			buf += x;
		}
@


1.31
log
@new day, new options. -m message and -x signature.
this should be less confusing and more consistent in various modes.
also support stdin/stdout where feasible. touch up usage to be helpful.
ok deraadt
@
text
@d1 1
a1 1
/* $OpenBSD: signify.c,v 1.27 2014/01/10 17:38:24 tedu Exp $ */
d122 9
a130 6
	
	x = read(fd, buf, len);
	if (x == -1) {
		err(1, "read from %s", filename);
	} else if (x != len) {
		errx(1, "short read from %s", filename);
d205 9
a213 6
	
	x = write(fd, buf, len);
	if (x == -1) {
		err(1, "write to %s", filename);
	} else if (x != len) {
		errx(1, "short write to %s", filename);
d471 1
a471 1
	while ((ch = getopt(argc, argv, "GISVc:em:n:p:s:x:")) != -1) {
@


1.30
log
@we only write to writable files, so use O_WRONLY.
st_size is only meaningful for regular files, so check S_ISREG
@
text
@d1 1
a1 1
/* $OpenBSD: signify.c,v 1.29 2014/01/11 04:29:07 lteo Exp $ */
d71 1
a71 1
usage(void)
d73 2
d77 3
a79 3
	    "\t%1$s -G [-c comment] [-n] -p pubkey -s seckey\n"
	    "\t%1$s -I [-o sigfile] [-p pubkey] [-s seckey]\n"
	    "\t%1$s -S [-e] [-o sigfile] -s seckey message\n"
d81 1
a81 1
	    "\t%1$s -V [-e] [-o sigfile] -p pubkey message\n",
d91 13
a103 3
	fd = open(fname, flags, mode);
	if (fd == -1)
		err(1, "open %s", fname);
d231 1
a231 2
	snprintf(header, sizeof(header), "%s%s\n", COMMENTHDR,
	    comment);
d465 1
a465 1
	while ((ch = getopt(argc, argv, "GISVc:eno:p:s:")) != -1) {
d470 1
a470 1
				usage();
d475 1
a475 1
				usage();
d480 1
a480 1
				usage();
d486 1
a486 1
				usage();
d495 3
a500 3
		case 'o':
			sigfile = optarg;
			break;
d507 3
d511 1
a511 1
			usage();
d518 3
a520 3
#ifdef VERIFYONLY
	if (verb != VERIFY)
#else
d522 1
a522 2
#endif
		usage();
d526 2
a527 2
		if (!pubkeyfile || !seckeyfile || argc != 0)
			usage();
a529 2
		if (argc != 0)
			usage();
d534 2
a535 4
		if (argc != 1)
			usage();

		msgfile = argv[0];
d538 2
d548 1
a548 1
				usage();
d554 1
a554 1
				usage();
@


1.29
log
@Check the return value of fstat() in readmsg().

OK deraadt@@ tedu@@
@
text
@d1 1
a1 1
/* $OpenBSD: signify.c,v 1.28 2014/01/10 17:52:50 deraadt Exp $ */
d173 2
d205 1
a205 1
	fd = xopen(filename, O_NOFOLLOW | O_RDWR | O_APPEND, 0);
d218 1
a218 1
	fd = xopen(filename, O_CREAT|flags|O_NOFOLLOW|O_RDWR, mode);
d426 1
a426 1
		fd = xopen(msgfile, O_CREAT|O_TRUNC|O_NOFOLLOW|O_RDWR, 0666);
@


1.28
log
@sort options
@
text
@d1 1
a1 1
/* $OpenBSD: signify.c,v 1.27 2014/01/10 17:38:24 tedu Exp $ */
d171 2
a172 1
	fstat(fd, &sb);
@


1.27
log
@-c comment, for people who don't like the default. ok deraadt
@
text
@d1 1
a1 1
/* $OpenBSD: signify.c,v 1.26 2014/01/10 04:49:35 tedu Exp $ */
d75 1
a75 1
	    "\t%1$s -G [-n] [-c comment] -p pubkey -s seckey\n"
@


1.26
log
@quiet time. printing verified was an artifact of development, to be sure
we didn't accidentally fall through main without doing anything, but tools
should be quiet unless there's an error.
@
text
@d1 1
a1 1
/* $OpenBSD: signify.c,v 1.25 2014/01/10 04:36:58 tedu Exp $ */
d75 1
a75 1
	    "\t%1$s -G [-n] -p pubkey -s seckey\n"
d216 1
a216 1
	snprintf(header, sizeof(header), "%ssignify %s\n", COMMENTHDR,
d259 2
a260 1
generate(const char *pubkeyfile, const char *seckeyfile, int rounds)
d267 1
d290 2
a291 1
	writeb64file(seckeyfile, "secret key", &enckey,
d297 2
a298 1
	writeb64file(pubkeyfile, "public key", &pubkey,
d437 1
d451 1
a451 1
	while ((ch = getopt(argc, argv, "GISVeno:p:s:")) != -1) {
d475 3
d512 1
a512 1
		generate(pubkeyfile, seckeyfile, rounds);
@


1.25
log
@use a single positional argument instead of a creeping list of __progname
@
text
@d1 1
a1 1
/* $OpenBSD: signify.c,v 1.24 2014/01/10 04:34:24 tedu Exp $ */
a422 2

	printf("verified\n");
@


1.24
log
@a little more consistent with names, notably call signature files sigfiles
for short, instead of output.
@
text
@d1 1
a1 1
/* $OpenBSD: signify.c,v 1.23 2014/01/10 04:23:37 deraadt Exp $ */
d75 3
a77 7
	    "\t%s -G [-n] -p pubkey -s seckey\n"
	    "\t%s -I [-o sigfile] [-p pubkey] [-s seckey]\n"
	    "\t%s -S [-e] [-o sigfile] -s seckey message\n"
#endif
	    "\t%s -V [-e] [-o sigfile] -p pubkey message\n",
#ifndef VERIFYONLY
	    __progname, __progname, __progname,
d79 1
@


1.23
log
@change the listing of the options, because there is way too much
befuddlement.
sorry jmc
ok tedu
@
text
@d1 1
a1 1
/* $OpenBSD: signify.c,v 1.22 2014/01/10 04:15:38 tedu Exp $ */
d76 2
a77 2
	    "\t%s -I [-o sig] [-p pubkey] [-s seckey]\n"
	    "\t%s -S [-e] [-o output] -s seckey message\n"
d79 1
a79 1
	    "\t%s -V [-e] [-o output] -p pubkey message\n",
@


1.22
log
@at least for now, we're going to need some -Inspector magic
@
text
@d1 1
a1 1
/* $OpenBSD: signify.c,v 1.21 2014/01/09 21:19:38 jmc Exp $ */
d75 3
a77 3
	    "\t%s [-n] -p pubkey -s seckey -G\n"
	    "\t%s [-o sig] [-p pubkey] [-s seckey] -I\n"
	    "\t%s [-e] [-o output] -s seckey -S message\n"
d79 1
a79 1
	    "\t%s [-e] [-o output] -p pubkey -V message\n",
@


1.21
log
@sync usage();
@
text
@d1 1
a1 1
/* $OpenBSD: signify.c,v 1.20 2014/01/09 20:37:25 espie Exp $ */
d76 1
d81 1
a81 1
	    __progname, __progname, 
d345 25
d413 4
a416 1
	if (memcmp(pubkey.fingerprint, sig.fingerprint, FPLEN))
d418 1
d443 1
d451 1
a451 1
	while ((ch = getopt(argc, argv, "GSVeno:p:s:")) != -1) {
d459 5
d510 4
@


1.20
log
@revert to O_EXCL for generating keys, so we don't erase them by accident.
internal code a bit yucky, can be fixed some more later.
okay tedu@@
@
text
@d1 1
a1 1
/* $OpenBSD: signify.c,v 1.19 2014/01/09 19:05:21 tedu Exp $ */
d76 1
a76 1
	    "\t%s [-e] [-o output] -s seckey -S input\n"
d78 1
a78 1
	    "\t%s [-e] [-o output] -p pubkey -V input\n",
@


1.19
log
@change O_EXCL to O_TRUNC before deraadt kills me.
@
text
@d1 1
a1 1
/* $OpenBSD: signify.c,v 1.18 2014/01/09 18:59:35 tedu Exp $ */
d211 1
a211 1
    size_t len, mode_t mode)
d217 1
a217 1
	fd = xopen(filename, O_CREAT|O_TRUNC|O_NOFOLLOW|O_RDWR, mode);
d291 1
a291 1
	    sizeof(enckey), 0600);
d297 1
a297 1
	    sizeof(pubkey), 0666);
d338 1
a338 1
	writeb64file(sigfile, sigcomment, &sig, sizeof(sig), 0666);
@


1.18
log
@copy secret key comment into signature. requested by deraadt
@
text
@d1 1
a1 1
/* $OpenBSD: signify.c,v 1.17 2014/01/09 17:13:36 deraadt Exp $ */
d217 1
a217 1
	fd = xopen(filename, O_CREAT|O_EXCL|O_NOFOLLOW|O_RDWR, mode);
d392 1
a392 1
		fd = xopen(msgfile, O_CREAT|O_EXCL|O_NOFOLLOW|O_RDWR, 0666);
@


1.17
log
@oops, re-adapt for the install media
@
text
@d1 1
a1 1
/* $OpenBSD: signify.c,v 1.16 2014/01/09 15:36:40 tedu Exp $ */
d42 3
a44 2
#define COMMENTHDR "untrusted comment:"
#define COMMENTHDRLEN 18
d122 2
a123 1
parseb64file(const char *filename, char *b64, void *buf, size_t len)
d133 3
d149 1
a149 1
readb64file(const char *filename, void *buf, size_t len)
d159 1
a159 1
	parseb64file(filename, b64, buf, len);
d218 1
a218 1
	snprintf(header, sizeof(header), "%s signify %s\n", COMMENTHDR,
d309 1
d314 1
a314 1
	readb64file(seckeyfile, &enckey, sizeof(enckey));
d337 2
a338 1
	writeb64file(sigfile, "signature", &sig, sizeof(sig), 0666);
d378 1
a378 1
	readb64file(pubkeyfile, &pubkey, sizeof(pubkey));
d380 1
a380 1
		siglen = parseb64file(sigfile, msg, &sig, sizeof(sig));
d384 1
a384 1
		readb64file(sigfile, &sig, sizeof(sig));
@


1.16
log
@-e embedded signatures. ok deraadt
@
text
@d1 1
a1 1
/* $OpenBSD: signify.c,v 1.15 2014/01/08 07:04:29 espie Exp $ */
a179 1
#ifndef VERIFYONLY
d193 1
@


1.15
log
@fix logic/usage in VERIFYONLY case
okay deraadt@@
@
text
@d1 1
a1 1
/* $OpenBSD: signify.c,v 1.14 2014/01/08 05:00:01 tedu Exp $ */
d75 1
a75 1
	    "\t%s [-o output] -s seckey -S input\n"
d77 1
a77 1
	    "\t%s [-o output] -p pubkey -V input\n",
d120 23
a147 1
	char *commentend;
d154 1
a154 8
	commentend = strchr(b64, '\n');
	if (!commentend || commentend - b64 <= COMMENTHDRLEN ||
	    memcmp(b64, COMMENTHDR, COMMENTHDRLEN))
		errx(1, "invalid comment in %s; must start with '%s'",
		    filename, COMMENTHDR);
	rv = b64_pton(commentend + 1, buf, len);
	if (rv != len)
		errx(1, "invalid b64 encoding in %s", filename);
a156 2
	if (memcmp(buf, PKALG, 2))
		errx(1, "unsupported file %s", filename);
d195 10
d296 2
a297 1
sign(const char *seckeyfile, const char *inputfile, const char *sigfile)
d324 1
a324 1
	msg = readmsg(inputfile, &msglen);
d332 2
d360 2
a361 1
verify(const char *pubkeyfile, const char *inputfile, const char *sigfile)
d365 1
a365 1
	unsigned long long msglen;
d367 3
d372 7
a378 1
	readb64file(sigfile, &sig, sizeof(sig));
d383 6
a388 1
	msg = readmsg(inputfile, &msglen);
a389 1
	verifymsg(pubkey.pubkey, msg, msglen, sig.sig);
d392 1
a392 1
	free(msg);
d398 1
a398 1
	const char *pubkeyfile = NULL, *seckeyfile = NULL, *inputfile = NULL,
d402 1
d413 1
a413 1
	while ((ch = getopt(argc, argv, "GSVno:p:s:")) != -1) {
d432 3
d473 1
a473 1
		inputfile = argv[0];
d477 1
a477 1
			    inputfile) >= sizeof(sigfilebuf))
d485 1
a485 1
			sign(seckeyfile, inputfile, sigfile);
d491 1
a491 1
			verify(pubkeyfile, inputfile, sigfile);
@


1.14
log
@allow building a VERIFYONLY version that's considerably smaller.
most of the savings comes from eliminating the large constant table
in ge25519.c. ok deraadt
@
text
@d1 1
a1 1
/* $OpenBSD: signify.c,v 1.13 2014/01/08 03:57:57 tedu Exp $ */
d73 1
d76 1
d78 4
a81 1
	    __progname, __progname, __progname);
d411 3
d415 1
@


1.13
log
@no tomfoolery: mark the comment as untrusted, and enforce it.
usability: add random key fingerprints to detect sig/pubkey mismatch
feedback espie naddy
@
text
@d1 1
a1 1
/* $OpenBSD: signify.c,v 1.12 2014/01/06 01:50:54 espie Exp $ */
d162 1
d306 1
d369 1
d380 1
d409 1
d414 3
a416 1
	} else {
d428 1
a428 1

d433 3
a435 1
		} else if (verb == VERIFY) {
@


1.12
log
@tedu unused macro.
okay tedu@@
@
text
@d1 1
a1 1
/* $OpenBSD: signify.c,v 1.11 2014/01/03 17:14:47 tedu Exp $ */
d40 4
d51 1
d57 1
d63 1
d128 4
a131 2
	if (!commentend)
		errx(1, "no newline in %s", filename);
d184 2
a185 1
	snprintf(header, sizeof(header), "signify -- %s\n", comment);
a226 19
verifymsg(uint8_t *pubkey, uint8_t *msg, unsigned long long msglen,
    uint8_t *sig)
{
	uint8_t *sigbuf, *dummybuf;
	unsigned long long siglen, dummylen;

	siglen = SIGBYTES + msglen;
	sigbuf = xmalloc(siglen);
	dummybuf = xmalloc(siglen);
	memcpy(sigbuf, sig, SIGBYTES);
	memcpy(sigbuf + SIGBYTES, msg, msglen);
	if (crypto_sign_ed25519_open(dummybuf, &dummylen, sigbuf, siglen,
	    pubkey) == -1)
		errx(1, "signature failed");
	free(sigbuf);
	free(dummybuf);
}

static void
d233 1
d238 1
d247 1
d261 1
d297 1
d307 20
d336 3
@


1.11
log
@don't initialize declared variable with a function call
@
text
@d1 1
a1 1
/* $OpenBSD: signify.c,v 1.10 2014/01/03 17:13:42 tedu Exp $ */
a32 2

#define streq(a, b) (strcmp(a, b) == 0)
@


1.10
log
@replace hand rolled strchr with strchr
@
text
@d1 1
a1 1
/* $OpenBSD: signify.c,v 1.9 2014/01/03 17:10:27 espie Exp $ */
d100 3
a102 1
	ssize_t x = read(fd, buf, len);
d158 3
a160 1
	ssize_t x = write(fd, buf, len);
@


1.9
log
@let signify have an actual parameters: the file to sign/verify
clarify SYNOPSIS, as options are highly dependent on the mode.
okay tedu@@,
usage suggestion by jmc@@
@
text
@d1 1
a1 1
/* $OpenBSD: signify.c,v 1.8 2014/01/03 15:42:22 espie Exp $ */
d112 2
a113 1
	int i, rv, fd;
d120 2
a121 4
	for (i = 0; i < rv; i++)
		if (b64[i] == '\n')
			break;
	if (i == rv)
d123 1
a123 1
	rv = b64_pton(b64 + i, buf, len);
@


1.8
log
@terminate b64 encoded lines. decoding happily skips \n.
okay tedu@@
@
text
@d1 1
a1 1
/* $OpenBSD: signify.c,v 1.7 2014/01/02 16:34:02 espie Exp $ */
d67 5
a71 2
	fprintf(stderr, "usage: %s [-n] [-i input] [-o output] [-p pubkey] [-s seckey] "
	    "-G | -S | -V\n", __progname);
d345 1
a345 1
	while ((ch = getopt(argc, argv, "GSVi:no:p:s:")) != -1) {
a361 3
		case 'i':
			inputfile = optarg;
			break;
d380 3
a382 1
	if (argc != 0)
a384 7
	if (inputfile && !sigfile) {
		if (snprintf(sigfilebuf, sizeof(sigfilebuf), "%s.sig",
		    inputfile) >= sizeof(sigfilebuf))
			errx(1, "path too long");
		sigfile = sigfilebuf;
	}

d386 1
a386 1
		if (!pubkeyfile || !seckeyfile)
d389 2
a390 2
	} else if (verb == SIGN) {
		if (!seckeyfile || !inputfile)
d392 19
a410 7
		sign(seckeyfile, inputfile, sigfile);
	} else if (verb == VERIFY) {
		if (!pubkeyfile || !inputfile)
			usage();
		verify(pubkeyfile, inputfile, sigfile);
	} else {
		usage();
d412 1
@


1.7
log
@display proper error messages for read/write.
after a lot of bickering with tedu...

"fine, fix it" tedu@@
@
text
@d1 1
a1 1
/* $OpenBSD: signify.c,v 1.6 2014/01/01 17:50:33 tedu Exp $ */
d173 1
a173 1
	if ((rv = b64_ntop(buf, len, b64, sizeof(b64))) == -1)
d175 1
@


1.6
log
@revert to mostly lowercase options, with uppercase for actions.
ok deraadt espie naddy. wth man tweaks from jmc
@
text
@d1 1
a1 1
/* $OpenBSD: signify.c,v 1.5 2013/12/31 17:33:17 jmc Exp $ */
d95 1
a95 1
readall(int fd, void *buf, size_t len)
d97 6
a102 2
	if (read(fd, buf, len) != len)
		err(1, "read");
d115 1
a115 1
		err(1, "read in %s", filename);
d144 1
a144 1
	readall(fd, msg, msglen);
d152 1
a152 1
writeall(int fd, const void *buf, size_t len)
d154 6
a159 2
	if (write(fd, buf, len) != len)
		err(1, "write");
d172 1
a172 1
	writeall(fd, header, strlen(header));
d175 1
a175 1
	writeall(fd, b64, rv);
@


1.5
log
@various tweaks; ok tedu
@
text
@d1 1
a1 1
/* $OpenBSD: signify.c,v 1.4 2013/12/31 03:54:05 tedu Exp $ */
d67 2
a68 2
	fprintf(stderr, "usage: %s [-N] [-I input] [-O output] [-P pubkey] [-S seckey] "
	    "-V generate | sign | verify\n", __progname);
a318 1
	const char *verb = NULL;
d323 7
d333 1
a333 1
	while ((ch = getopt(argc, argv, "I:NO:P:S:V:")) != -1) {
d335 16
a350 1
		case 'I':
d353 1
a353 1
		case 'N':
d356 1
a356 1
		case 'O':
d359 1
a359 1
		case 'P':
d362 1
a362 1
		case 'S':
a364 3
		case 'V':
			verb = optarg;
			break;
d371 1
a371 1
	if (argc != 0 || verb == NULL)
d381 1
a381 1
	if (streq(verb, "generate")) {
d385 1
a385 1
	} else if (streq(verb, "sign")) {
d389 1
a389 1
	} else if (streq(verb, "verify")) {
@


1.4
log
@another last minute bug i introduced. found by jturner
@
text
@d1 1
a1 1
/* $OpenBSD: signify.c,v 1.3 2013/12/31 03:23:41 tedu Exp $ */
d67 2
a68 2
	fprintf(stderr, "usage: %s [-N] [-I input] [-P pubkey] [-S seckey] "
	    "-V generate|sign|verify\n", __progname);
@


1.3
log
@update usage
@
text
@d1 1
a1 1
/* $OpenBSD: signify.c,v 1.2 2013/12/31 03:08:48 tedu Exp $ */
d353 1
a353 1
	if (argc != 0)
@


1.2
log
@wha! commit a working version
@
text
@d1 1
a1 1
/* $OpenBSD: signify.c,v 1.1 2013/12/31 03:03:32 tedu Exp $ */
d67 2
a68 2
	fprintf(stderr, "usage: %s [-P] [-i input] [-p pubkey] [-s seckey] "
	    "generate|sign|verify\n", __progname);
@


1.1
log
@add signify, a tool to sign and verify signatures.
man page and error message help from espie
other feedback from deraadt djm mikeb
@
text
@d1 1
a1 1
/* $OpenBSD$ */
d68 1
a68 1
	    "generate|sign|verify", __progname);
d327 1
a327 1
	while ((ch = getopt(argc, argv, "I:NO:P:S:")) != -1) {
d352 1
d358 1
a358 1
		    inputfile) >= sizeof(sigfile))
@

