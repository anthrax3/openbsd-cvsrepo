head	1.28;
access;
symbols
	OPENBSD_6_2:1.28.0.4
	OPENBSD_6_2_BASE:1.28
	OPENBSD_6_1:1.26.0.8
	OPENBSD_6_1_BASE:1.26
	OPENBSD_6_0:1.26.0.4
	OPENBSD_6_0_BASE:1.26
	OPENBSD_5_9:1.26.0.2
	OPENBSD_5_9_BASE:1.26
	OPENBSD_5_8:1.23.0.4
	OPENBSD_5_8_BASE:1.23
	OPENBSD_5_7:1.22.0.2
	OPENBSD_5_7_BASE:1.22
	OPENBSD_5_6:1.21.0.4
	OPENBSD_5_6_BASE:1.21
	OPENBSD_5_5:1.20.0.4
	OPENBSD_5_5_BASE:1.20
	OPENBSD_5_4:1.19.0.16
	OPENBSD_5_4_BASE:1.19
	OPENBSD_5_3:1.19.0.14
	OPENBSD_5_3_BASE:1.19
	OPENBSD_5_2:1.19.0.12
	OPENBSD_5_2_BASE:1.19
	OPENBSD_5_1_BASE:1.19
	OPENBSD_5_1:1.19.0.10
	OPENBSD_5_0:1.19.0.8
	OPENBSD_5_0_BASE:1.19
	OPENBSD_4_9:1.19.0.6
	OPENBSD_4_9_BASE:1.19
	OPENBSD_4_8:1.19.0.4
	OPENBSD_4_8_BASE:1.19
	OPENBSD_4_7:1.19.0.2
	OPENBSD_4_7_BASE:1.19
	OPENBSD_4_6:1.17.0.22
	OPENBSD_4_6_BASE:1.17
	OPENBSD_4_5:1.17.0.18
	OPENBSD_4_5_BASE:1.17
	OPENBSD_4_4:1.17.0.16
	OPENBSD_4_4_BASE:1.17
	OPENBSD_4_3:1.17.0.14
	OPENBSD_4_3_BASE:1.17
	OPENBSD_4_2:1.17.0.12
	OPENBSD_4_2_BASE:1.17
	OPENBSD_4_1:1.17.0.10
	OPENBSD_4_1_BASE:1.17
	OPENBSD_4_0:1.17.0.8
	OPENBSD_4_0_BASE:1.17
	OPENBSD_3_9:1.17.0.6
	OPENBSD_3_9_BASE:1.17
	OPENBSD_3_8:1.17.0.4
	OPENBSD_3_8_BASE:1.17
	OPENBSD_3_7:1.17.0.2
	OPENBSD_3_7_BASE:1.17
	OPENBSD_3_6:1.16.0.2
	OPENBSD_3_6_BASE:1.16
	OPENBSD_3_5:1.14.0.2
	OPENBSD_3_5_BASE:1.14
	OPENBSD_3_4:1.13.0.2
	OPENBSD_3_4_BASE:1.13
	OPENBSD_3_3:1.11.0.6
	OPENBSD_3_3_BASE:1.11
	OPENBSD_3_2:1.11.0.4
	OPENBSD_3_2_BASE:1.11
	OPENBSD_3_1:1.11.0.2
	OPENBSD_3_1_BASE:1.11
	OPENBSD_3_0:1.9.0.2
	OPENBSD_3_0_BASE:1.9
	OPENBSD_2_9_BASE:1.8
	OPENBSD_2_9:1.8.0.8
	OPENBSD_2_8:1.8.0.6
	OPENBSD_2_8_BASE:1.8
	OPENBSD_2_7:1.8.0.4
	OPENBSD_2_7_BASE:1.8
	OPENBSD_2_6:1.8.0.2
	OPENBSD_2_6_BASE:1.8
	OPENBSD_2_5:1.6.0.8
	OPENBSD_2_5_BASE:1.6
	OPENBSD_2_4:1.6.0.6
	OPENBSD_2_4_BASE:1.6
	OPENBSD_2_3:1.6.0.4
	OPENBSD_2_3_BASE:1.6
	OPENBSD_2_2:1.6.0.2
	OPENBSD_2_2_BASE:1.6
	OPENBSD_2_1:1.3.0.2
	OPENBSD_2_1_BASE:1.3
	OPENBSD_2_0:1.2.0.2
	OPENBSD_2_0_BASE:1.2
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.28
date	2017.05.30.15.29.53;	author tedu;	state Exp;
branches;
next	1.27;
commitid	WNNMF689Dw68ks5Y;

1.27
date	2017.05.30.15.07.01;	author tedu;	state Exp;
branches;
next	1.26;
commitid	PafdjmsnviaNIOYZ;

1.26
date	2015.10.09.01.37.07;	author deraadt;	state Exp;
branches;
next	1.25;
commitid	sbrB3Q5CNxcwZpfU;

1.25
date	2015.10.05.06.43.31;	author deraadt;	state Exp;
branches;
next	1.24;
commitid	Xa0cnxyIljofJXtY;

1.24
date	2015.10.05.06.30.37;	author deraadt;	state Exp;
branches;
next	1.23;
commitid	ZTTCsUBdXIskoNio;

1.23
date	2015.05.19.16.03.19;	author millert;	state Exp;
branches;
next	1.22;
commitid	qIH4PWYMzOy7m0HS;

1.22
date	2015.01.16.06.40.08;	author deraadt;	state Exp;
branches;
next	1.21;
commitid	Uu5nFG3wCl0LACBb;

1.21
date	2014.07.14.05.41.00;	author guenther;	state Exp;
branches;
next	1.20;
commitid	hckpsLxluX4MyPuF;

1.20
date	2013.09.06.19.48.46;	author okan;	state Exp;
branches;
next	1.19;

1.19
date	2009.10.27.23.59.39;	author deraadt;	state Exp;
branches;
next	1.18;

1.18
date	2009.10.12.17.39.26;	author sobrado;	state Exp;
branches;
next	1.17;

1.17
date	2004.11.16.13.51.35;	author jmc;	state Exp;
branches;
next	1.16;

1.16
date	2004.07.19.09.22.17;	author pvalchev;	state Exp;
branches;
next	1.15;

1.15
date	2004.05.31.15.48.26;	author pedro;	state Exp;
branches;
next	1.14;

1.14
date	2004.01.07.22.18.14;	author tdeval;	state Exp;
branches;
next	1.13;

1.13
date	2003.06.10.22.20.47;	author deraadt;	state Exp;
branches;
next	1.12;

1.12
date	2003.06.03.02.56.09;	author millert;	state Exp;
branches;
next	1.11;

1.11
date	2002.02.16.21.27.47;	author millert;	state Exp;
branches;
next	1.10;

1.10
date	2001.11.19.19.02.14;	author mpech;	state Exp;
branches;
next	1.9;

1.9
date	2001.07.12.05.17.11;	author deraadt;	state Exp;
branches;
next	1.8;

1.8
date	99.08.18.12.23.01;	author aaron;	state Exp;
branches;
next	1.7;

1.7
date	99.07.23.19.24.33;	author aaron;	state Exp;
branches;
next	1.6;

1.6
date	97.07.25.21.33.39;	author mickey;	state Exp;
branches;
next	1.5;

1.5
date	97.07.25.21.05.27;	author mickey;	state Exp;
branches;
next	1.4;

1.4
date	97.06.30.06.22.18;	author deraadt;	state Exp;
branches;
next	1.3;

1.3
date	97.01.15.23.42.35;	author millert;	state Exp;
branches;
next	1.2;

1.2
date	96.06.26.05.34.24;	author deraadt;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.45.24;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.45.24;	author deraadt;	state Exp;
branches;
next	;


desc
@@


1.28
log
@usage and order tweaks from jmc
@
text
@/*	$OpenBSD: id.c,v 1.27 2017/05/30 15:07:01 tedu Exp $	*/

/*-
 * Copyright (c) 1991, 1993
 *	The Regents of the University of California.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */

#include <sys/types.h>
#include <sys/socket.h> /* getrtable() lives here */

#include <err.h>
#include <errno.h>
#include <grp.h>
#include <pwd.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <limits.h>
#include <login_cap.h>

void	current(void);
void	pretty(struct passwd *);
void	group(struct passwd *, int);
void	usage(void);
void	user(struct passwd *);
struct passwd *
	who(char *);

int
main(int argc, char *argv[])
{
	struct group *gr;
	struct passwd *pw;
	int ch, cflag, Gflag, gflag, nflag, pflag, Rflag, rflag, uflag;
	uid_t uid;
	gid_t gid;
	const char *opts;

	if (pledge("stdio getpw", NULL) == -1)
		err(1, "pledge");

	cflag = Gflag = gflag = nflag = pflag = Rflag = rflag = uflag = 0;

	if (strcmp(getprogname(), "groups") == 0) {
		Gflag = 1;
		nflag = 1;
		opts = "";
		if (argc > 2)
			usage();
	} else if (strcmp(getprogname(), "whoami") == 0) {
		uflag = 1;
		nflag = 1;
		opts = "";
		if (argc > 1)
			usage();
	} else
		opts = "cGgnpRru";

	while ((ch = getopt(argc, argv, opts)) != -1)
		switch(ch) {
		case 'c':
			cflag = 1;
			break;
		case 'G':
			Gflag = 1;
			break;
		case 'g':
			gflag = 1;
			break;
		case 'n':
			nflag = 1;
			break;
		case 'p':
			pflag = 1;
			break;
		case 'R':
			Rflag = 1;
			break;
		case 'r':
			rflag = 1;
			break;
		case 'u':
			uflag = 1;
			break;
		case '?':
		default:
			usage();
		}
	argc -= optind;
	argv += optind;

	switch (cflag + Gflag + gflag + pflag + Rflag + uflag) {
	case 1:
		break;
	case 0:
		if (!nflag && !rflag)
			break;
		/* FALLTHROUGH */
	default:
		usage();
	}

	if (strcmp(opts, "") != 0 && argc > 1)
		usage();

	if (Rflag) {
		printf("%d\n", getrtable());
		exit(0);
	}

	pw = *argv ? who(*argv) : NULL;

	if (cflag) {
		if (pw == NULL)
			pw = getpwuid(getuid());
		if (pw != NULL && pw->pw_class != NULL && *pw->pw_class != '\0')
			(void)printf("%s\n", pw->pw_class);
		else
			(void)printf("%s\n", LOGIN_DEFCLASS);
		exit(0);
	}

	if (gflag) {
		gid = pw ? pw->pw_gid : rflag ? getgid() : getegid();
		if (nflag && (gr = getgrgid(gid)))
			(void)printf("%s\n", gr->gr_name);
		else
			(void)printf("%u\n", gid);
		exit(0);
	}

	if (uflag) {
		uid = pw ? pw->pw_uid : rflag ? getuid() : geteuid();
		if (nflag && (pw = getpwuid(uid)))
			(void)printf("%s\n", pw->pw_name);
		else
			(void)printf("%u\n", uid);
		exit(0);
	}

	if (Gflag) {
		group(pw, nflag);
		exit(0);
	}

	if (pflag) {
		pretty(pw);
		exit(0);
	}

	if (pw)
		user(pw);
	else
		current();
	exit(0);
}

void
pretty(struct passwd *pw)
{
	struct group *gr;
	uid_t eid, rid;
	char *login;

	if (pw) {
		(void)printf("uid\t%s\n", pw->pw_name);
		(void)printf("groups\t");
		group(pw, 1);
	} else {
		if ((login = getlogin()) == NULL)
			err(1, "getlogin");

		pw = getpwuid(rid = getuid());
		if (pw == NULL || strcmp(login, pw->pw_name))
			(void)printf("login\t%s\n", login);
		if (pw)
			(void)printf("uid\t%s\n", pw->pw_name);
		else
			(void)printf("uid\t%u\n", rid);

		if ((eid = geteuid()) != rid) {
			if ((pw = getpwuid(eid)))
				(void)printf("euid\t%s\n", pw->pw_name);
			else
				(void)printf("euid\t%u\n", eid);
		}
		if ((rid = getgid()) != (eid = getegid())) {
			if ((gr = getgrgid(rid)))
				(void)printf("rgid\t%s\n", gr->gr_name);
			else
				(void)printf("rgid\t%u\n", rid);
		}
		(void)printf("groups\t");
		group(NULL, 1);
	}
	if (pw != NULL && pw->pw_class != NULL && *pw->pw_class != '\0')
		(void)printf("class\t%s\n", pw->pw_class);
}

void
current(void)
{
	struct group *gr;
	struct passwd *pw;
	int cnt, ngroups;
	uid_t uid, euid;
	gid_t groups[NGROUPS_MAX], gid, egid, lastgid;
	char *prefix;

	uid = getuid();
	(void)printf("uid=%u", uid);
	if ((pw = getpwuid(uid)))
		(void)printf("(%s)", pw->pw_name);
	if ((euid = geteuid()) != uid) {
		(void)printf(" euid=%u", euid);
		if ((pw = getpwuid(euid)))
			(void)printf("(%s)", pw->pw_name);
	}
	gid = getgid();
	(void)printf(" gid=%u", gid);
	if ((gr = getgrgid(gid)))
		(void)printf("(%s)", gr->gr_name);
	if ((egid = getegid()) != gid) {
		(void)printf(" egid=%u", egid);
		if ((gr = getgrgid(egid)))
			(void)printf("(%s)", gr->gr_name);
	}
	if ((ngroups = getgroups(NGROUPS_MAX, groups))) {
		for (prefix = " groups=", lastgid = (gid_t)-1, cnt = 0;
		    cnt < ngroups; prefix = ", ", lastgid = gid) {
			gid = groups[cnt++];
			if (lastgid == gid)
				continue;
			(void)printf("%s%u", prefix, gid);
			if ((gr = getgrgid(gid)))
				(void)printf("(%s)", gr->gr_name);
		}
	}
	(void)printf("\n");
}

void
user(struct passwd *pw)
{
	gid_t gid, groups[NGROUPS_MAX + 1];
	int cnt, ngroups;
	uid_t uid;
	struct group *gr;
	char *prefix;

	uid = pw->pw_uid;
	(void)printf("uid=%u(%s)", uid, pw->pw_name);
	(void)printf(" gid=%u", pw->pw_gid);
	if ((gr = getgrgid(pw->pw_gid)))
		(void)printf("(%s)", gr->gr_name);
	ngroups = NGROUPS_MAX + 1;
	(void) getgrouplist(pw->pw_name, pw->pw_gid, groups, &ngroups);
	prefix = " groups=";
	for (cnt = 0; cnt < ngroups;) {
		gid = groups[cnt];
		(void)printf("%s%u", prefix, gid);
		prefix = ", ";
		if ((gr = getgrgid(gid)))
			(void)printf("(%s)", gr->gr_name);
		/* Skip same gid entries. */
		while (++cnt < ngroups && gid == groups[cnt])
			;
	}
	(void)printf("\n");
}

void
group(struct passwd *pw, int nflag)
{
	int cnt, ngroups;
	gid_t gid, groups[NGROUPS_MAX + 1];
	struct group *gr;
	char *prefix;

	if (pw) {
		ngroups = NGROUPS_MAX + 1;
		(void) getgrouplist(pw->pw_name, pw->pw_gid, groups, &ngroups);
	} else {
		groups[0] = getgid();
		ngroups = getgroups(NGROUPS_MAX, groups + 1) + 1;
	}
	prefix = "";
	for (cnt = 0; cnt < ngroups;) {
		gid = groups[cnt];
		if (nflag) {
			if ((gr = getgrgid(gid)))
				(void)printf("%s%s", prefix, gr->gr_name);
			else
				(void)printf("%s%u", prefix, gid);
		} else {
			(void)printf("%s%u", prefix, gid);
		}
		prefix = " ";
		/* Skip same gid entries. */
		while (++cnt < ngroups && gid == groups[cnt])
			;
	}
	(void)printf("\n");
}

struct passwd *
who(char *u)
{
	struct passwd *pw;
	uid_t uid;
	const char *errstr;

	/*
	 * Translate user argument into a pw pointer.  First, try to
	 * get it as specified.  If that fails, try it as a number.
	 */
	if ((pw = getpwnam(u)))
		return(pw);
	uid = strtonum(u, 0, UID_MAX, &errstr);
	if (!errstr && (pw = getpwuid(uid)))
		return(pw);
	errx(1, "%s: No such user", u);
	/* NOTREACHED */
}

void
usage(void)
{
	if (strcmp(getprogname(), "groups") == 0) {
		(void)fprintf(stderr, "usage: groups [user]\n");
	} else if (strcmp(getprogname(), "whoami") == 0) {
		(void)fprintf(stderr, "usage: whoami\n");
	} else {
		(void)fprintf(stderr, "usage: id [user]\n");
		(void)fprintf(stderr, "       id -c [user]\n");
		(void)fprintf(stderr, "       id -G [-n] [user]\n");
		(void)fprintf(stderr, "       id -g [-nr] [user]\n");
		(void)fprintf(stderr, "       id -p [user]\n");
		(void)fprintf(stderr, "       id -R\n");
		(void)fprintf(stderr, "       id -u [-nr] [user]\n");
	}
	exit(1);
}
@


1.27
log
@id -R: make current rdomain more easily accessible to the shell
ok benno deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: id.c,v 1.26 2015/10/09 01:37:07 deraadt Exp $	*/
d364 1
@


1.26
log
@Change all tame callers to namechange to pledge(2).
@
text
@d1 1
a1 1
/*	$OpenBSD: id.c,v 1.25 2015/10/05 06:43:31 deraadt Exp $	*/
d32 3
d59 1
a59 1
	int ch, cflag, Gflag, gflag, nflag, pflag, rflag, uflag;
d67 1
a67 1
	cflag = Gflag = gflag = nflag = pflag = rflag = uflag = 0;
d82 1
a82 1
		opts = "cGgnpru";
d101 3
d117 1
a117 1
	switch (cflag + Gflag + gflag + pflag + uflag) {
d130 5
@


1.25
log
@tame "stdio getpw" right at the top; this runs the whole gamut of
getpw/gr type functions allowed in that set.
ok doug
@
text
@d1 1
a1 1
/*	$OpenBSD: id.c,v 1.24 2015/10/05 06:30:37 deraadt Exp $	*/
d61 2
a62 2
	if (tame("stdio getpw", NULL) == -1)
		err(1, "tame");
@


1.24
log
@small KNF
@
text
@d1 1
a1 1
/*	$OpenBSD: id.c,v 1.23 2015/05/19 16:03:19 millert Exp $	*/
d60 3
@


1.23
log
@Add -c flag to display the user's login class.  OK espie@@
@
text
@d1 1
a1 1
/*	$OpenBSD: id.c,v 1.22 2015/01/16 06:40:08 deraadt Exp $	*/
d277 2
a278 1
		while (++cnt < ngroups && gid == groups[cnt]);
d311 2
a312 1
		while (++cnt < ngroups && gid == groups[cnt]);
@


1.22
log
@Replace <sys/param.h> with <limits.h> and other less dirty headers where
possible.  Annotate <sys/param.h> lines with their current reasons.  Switch
to PATH_MAX, NGROUPS_MAX, HOST_NAME_MAX+1, LOGIN_NAME_MAX, etc.  Change
MIN() and MAX() to local definitions of MINIMUM() and MAXIMUM() where
sensible to avoid pulling in the pollution.  These are the files confirmed
through binary verification.
ok guenther, millert, doug (helped with the verification protocol)
@
text
@d1 1
a1 1
/*	$OpenBSD: id.c,v 1.21 2014/07/14 05:41:00 guenther Exp $	*/
d41 1
d56 1
a56 1
	int Gflag, ch, gflag, nflag, pflag, rflag, uflag;
d61 1
a61 1
	Gflag = gflag = nflag = pflag = rflag = uflag = 0;
d76 1
a76 1
		opts = "Ggnpru";
d80 3
d108 1
a108 1
	switch (Gflag + gflag + pflag + uflag) {
d124 10
d207 2
d344 1
@


1.21
log
@Eliminate a warning from -Wformat=2 by using an additional 'prefix'
variable instead of using a variable format string for printf
@
text
@d1 1
a1 1
/*	$OpenBSD: id.c,v 1.20 2013/09/06 19:48:46 okan Exp $	*/
a31 2
#include <sys/param.h>

d40 1
d202 1
a202 1
	gid_t groups[NGROUPS], gid, egid, lastgid;
d223 1
a223 1
	if ((ngroups = getgroups(NGROUPS, groups))) {
d240 1
a240 1
	gid_t gid, groups[NGROUPS + 1];
d251 1
a251 1
	ngroups = NGROUPS + 1;
d270 1
a270 1
	gid_t gid, groups[NGROUPS + 1];
d275 1
a275 1
		ngroups = NGROUPS + 1;
d279 1
a279 1
		ngroups = getgroups(NGROUPS, groups + 1) + 1;
@


1.20
log
@teach id(1) about whoami(1) and groups(1) run modes; removes shell wrappers

OK millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: id.c,v 1.19 2009/10/27 23:59:39 deraadt Exp $	*/
d204 1
a204 1
	char *fmt;
d225 2
a226 2
		for (fmt = " groups=%u", lastgid = (gid_t)-1, cnt = 0;
		    cnt < ngroups; fmt = ", %u", lastgid = gid) {
d230 1
a230 1
			(void)printf(fmt, gid);
d245 1
a245 1
	char *fmt;
d254 1
a254 1
	fmt = " groups=%u";
d257 2
a258 2
		(void)printf(fmt, gid);
		fmt = ", %u";
d273 1
a273 1
	char *fmt;
d282 1
a282 1
	fmt = nflag ? "%s" : "%u";
d287 1
a287 1
				(void)printf(fmt, gr->gr_name);
d289 1
a289 3
				(void)printf(*fmt == ' ' ? " %u" : "%u",
				    gid);
			fmt = " %s";
d291 1
a291 2
			(void)printf(fmt, gid);
			fmt = " %u";
d293 1
@


1.19
log
@rcsid[] and sccsid[] and copyright[] are essentially unmaintained (and
unmaintainable).  these days, people use source.  these id's do not provide
any benefit, and do hurt the small install media
(the 33,000 line diff is essentially mechanical)
ok with the idea millert, ok dms
@
text
@d1 1
a1 1
/*	$OpenBSD: id.c,v 1.18 2009/10/12 17:39:26 sobrado Exp $	*/
d34 1
a41 1
#include <err.h>
d59 1
d62 17
a78 1
	while ((ch = getopt(argc, argv, "Ggnpru")) != -1)
d105 1
a105 1
	switch(Gflag + gflag + pflag + uflag) {
d116 3
d178 1
a178 1
		
d325 11
a335 5
	(void)fprintf(stderr, "usage: id [user]\n"
			      "       id -G [-n] [user]\n"
			      "       id -g [-nr] [user]\n"
			      "       id -p [user]\n"
			      "       id -u [-nr] [user]\n");
@


1.18
log
@source code can fit on a 80-column display, no binary change.
@
text
@d1 1
a1 1
/*	$OpenBSD: id.c,v 1.17 2004/11/16 13:51:35 jmc Exp $	*/
a30 11

#ifndef lint
static char copyright[] =
"@@(#) Copyright (c) 1991, 1993\n\
	The Regents of the University of California.  All rights reserved.\n";
#endif /* not lint */

#ifndef lint
/*static char sccsid[] = "@@(#)id.c	8.3 (Berkeley) 4/28/95";*/
static char rcsid[] = "$OpenBSD: id.c,v 1.17 2004/11/16 13:51:35 jmc Exp $";
#endif /* not lint */
@


1.17
log
@-p supports optional [user] arg;
from matthew clarke;
@
text
@d1 1
a1 1
/*	$OpenBSD: id.c,v 1.16 2004/07/19 09:22:17 pvalchev Exp $	*/
d40 1
a40 1
static char rcsid[] = "$OpenBSD: id.c,v 1.16 2004/07/19 09:22:17 pvalchev Exp $";
d216 2
a217 2
		for (fmt = " groups=%u", lastgid = (gid_t)-1, cnt = 0; cnt < ngroups;
		    fmt = ", %u", lastgid = gid) {
@


1.16
log
@use strtonum with proper bounds instead of abusing strtoul; ok millert
@
text
@d1 1
a1 1
/*	$OpenBSD: id.c,v 1.15 2004/05/31 15:48:26 pedro Exp $	*/
d40 1
a40 1
static char rcsid[] = "$OpenBSD: id.c,v 1.15 2004/05/31 15:48:26 pedro Exp $";
d319 1
a319 1
			      "       id -p\n"
@


1.15
log
@zap unused variables, ok beck@@
@
text
@d1 1
a1 1
/*	$OpenBSD: id.c,v 1.14 2004/01/07 22:18:14 tdeval Exp $	*/
d40 1
a40 1
static char rcsid[] = "$OpenBSD: id.c,v 1.14 2004/01/07 22:18:14 tdeval Exp $";
d298 1
a298 1
	char *ep;
d306 2
a307 2
	uid = strtoul(u, &ep, 10);
	if (*u && !*ep && (pw = getpwuid(uid)))
@


1.14
log
@Proper use of uid_t and did_t types instead of a generic int.
Lovingly baited by deraadt@@. Ok himself, otto@@
@
text
@d1 1
a1 1
/*	$OpenBSD: id.c,v 1.13 2003/06/10 22:20:47 deraadt Exp $	*/
d40 1
a40 1
static char rcsid[] = "$OpenBSD: id.c,v 1.13 2003/06/10 22:20:47 deraadt Exp $";
a262 1
	uid_t uid;
@


1.13
log
@mostly ansi cleanup; pval ok
@
text
@d1 1
a1 1
/*	$OpenBSD: id.c,v 1.12 2003/06/03 02:56:09 millert Exp $	*/
d40 1
a40 1
static char rcsid[] = "$OpenBSD: id.c,v 1.12 2003/06/03 02:56:09 millert Exp $";
d67 3
a69 1
	int Gflag, ch, gflag, id, nflag, pflag, rflag, uflag;
d113 2
a114 2
		id = pw ? pw->pw_gid : rflag ? getgid() : getegid();
		if (nflag && (gr = getgrgid(id)))
d117 1
a117 1
			(void)printf("%u\n", id);
d122 2
a123 2
		id = pw ? pw->pw_uid : rflag ? getuid() : geteuid();
		if (nflag && (pw = getpwuid(id)))
d126 1
a126 1
			(void)printf("%u\n", id);
d193 2
a194 2
	uid_t id, eid;
	gid_t groups[NGROUPS], gid, lastgid;
d197 3
a199 3
	id = getuid();
	(void)printf("uid=%u", id);
	if ((pw = getpwuid(id)))
d201 3
a203 3
	if ((eid = geteuid()) != id) {
		(void)printf(" euid=%u", eid);
		if ((pw = getpwuid(eid)))
d206 3
a208 3
	id = getgid();
	(void)printf(" gid=%u", id);
	if ((gr = getgrgid(id)))
d210 3
a212 3
	if ((eid = getegid()) != id) {
		(void)printf(" egid=%u", eid);
		if ((gr = getgrgid(eid)))
d232 3
a236 1
	int cnt, id, lastid, ngroups, groups[NGROUPS + 1];
d238 2
a239 2
	id = pw->pw_uid;
	(void)printf("uid=%u(%s)", id, pw->pw_name);
d246 3
a248 4
	for (lastid = -1, cnt = 0; cnt < ngroups; ++cnt) {
		if (lastid == (id = groups[cnt]))
			continue;
		(void)printf(fmt, id);
d250 1
a250 1
		if ((gr = getgrgid(id)))
d252 2
a253 1
		lastid = id;
d261 3
a264 2
	int cnt, id, lastid, ngroups;
	gid_t groups[NGROUPS + 1];
d275 2
a276 3
	for (lastid = -1, cnt = 0; cnt < ngroups; ++cnt) {
		if (lastid == (id = groups[cnt]))
			continue;
d278 1
a278 1
			if ((gr = getgrgid(id)))
d282 1
a282 1
				    id);
d285 1
a285 1
			(void)printf(fmt, id);
d288 2
a289 1
		lastid = id;
d298 1
a298 1
	uid_t id;
d307 2
a308 2
	id = strtoul(u, &ep, 10);
	if (*u && !*ep && (pw = getpwuid(id)))
@


1.12
log
@Remove the advertising clause in the UCB license which Berkeley
rescinded 22 July 1999.  Proofed by myself and Theo.
@
text
@d1 1
a1 1
/*	$OpenBSD: id.c,v 1.11 2002/02/16 21:27:47 millert Exp $	*/
d40 1
a40 1
static char rcsid[] = "$OpenBSD: id.c,v 1.11 2002/02/16 21:27:47 millert Exp $";
d63 1
a63 3
main(argc, argv)
	int argc;
	char *argv[];
d146 1
a146 2
pretty(pw)
	struct passwd *pw;
d186 1
a186 1
current()
d228 1
a228 2
user(pw)
	struct passwd *pw;
d255 1
a255 3
group(pw, nflag)
	struct passwd *pw;
	int nflag;
d290 1
a290 2
who(u)
	char *u;
d310 1
a310 1
usage()
@


1.11
log
@Part one of userland __P removal.  Done with a simple regexp with some minor hand editing to make comments line up correctly.  Another pass is forthcoming that handles the cases that could not be done automatically.
@
text
@d1 1
a1 1
/*	$OpenBSD: id.c,v 1.10 2001/11/19 19:02:14 mpech Exp $	*/
d15 1
a15 5
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
d40 1
a40 1
static char rcsid[] = "$OpenBSD: id.c,v 1.10 2001/11/19 19:02:14 mpech Exp $";
@


1.10
log
@kill more registers

millert@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: id.c,v 1.9 2001/07/12 05:17:11 deraadt Exp $	*/
d44 1
a44 1
static char rcsid[] = "$OpenBSD: id.c,v 1.9 2001/07/12 05:17:11 deraadt Exp $";
d58 5
a62 5
void	current __P((void));
void	pretty __P((struct passwd *));
void	group __P((struct passwd *, int));
void	usage __P((void));
void	user __P((struct passwd *));
d64 1
a64 1
	who __P((char *));
@


1.9
log
@first pass at a -Wall cleanup
@
text
@d1 1
a1 1
/*	$OpenBSD: id.c,v 1.8 1999/08/18 12:23:01 aaron Exp $	*/
d44 1
a44 1
static char rcsid[] = "$OpenBSD: id.c,v 1.8 1999/08/18 12:23:01 aaron Exp $";
d236 1
a236 1
	register struct passwd *pw;
d238 2
a239 2
	register struct group *gr;
	register char *fmt;
@


1.8
log
@Fix a printf() so `id' and `id username' produce similar output; inspired by
NetBSD, millert@@ok.
@
text
@d1 1
a1 1
/*	$OpenBSD: id.c,v 1.7 1999/07/23 19:24:33 aaron Exp $	*/
d44 1
a44 1
static char rcsid[] = "$OpenBSD: id.c,v 1.7 1999/07/23 19:24:33 aaron Exp $";
d175 1
a175 1
		if ((eid = geteuid()) != rid)
d180 2
a181 1
		if ((rid = getgid()) != (eid = getegid()))
d186 1
@


1.7
log
@- Missing newline when euid != ruid; from FreeBSD
- Also, sync the usage() to the man page (add -p syntax).
@
text
@d1 1
a1 1
/*	$OpenBSD: id.c,v 1.6 1997/07/25 21:33:39 mickey Exp $	*/
d44 1
a44 1
static char rcsid[] = "$OpenBSD: id.c,v 1.6 1997/07/25 21:33:39 mickey Exp $";
d252 1
a252 1
		fmt = " %u";
@


1.6
log
@use err(3)
@
text
@d1 1
a1 1
/*	$OpenBSD: id.c,v 1.5 1997/07/25 21:05:27 mickey Exp $	*/
d44 1
a44 1
static char rcsid[] = "$OpenBSD: id.c,v 1.5 1997/07/25 21:05:27 mickey Exp $";
d177 1
a177 1
				(void)printf("euid\t%s", pw->pw_name);
d179 1
a179 1
				(void)printf("euid\t%u", eid);
d324 1
@


1.5
log
@#if __STDC__ --> #ifdef __STDC__
@
text
@d1 1
a1 1
/*	$OpenBSD: id.c,v 1.4 1997/06/30 06:22:18 deraadt Exp $	*/
d44 1
a44 1
static char rcsid[] = "$OpenBSD: id.c,v 1.4 1997/06/30 06:22:18 deraadt Exp $";
d56 1
a58 1
void	err __P((const char *, ...));
d165 1
a165 1
			err("getlogin: %s", strerror(errno));
d314 1
a314 30
	err("%s: No such user", u);
	/* NOTREACHED */
}

#ifdef __STDC__
#include <stdarg.h>
#else
#include <varargs.h>
#endif

void
#ifdef __STDC__
err(const char *fmt, ...)
#else
err(fmt, va_alist)
	char *fmt;
        va_dcl
#endif
{
	va_list ap;
#ifdef __STDC__
	va_start(ap, fmt);
#else
	va_start(ap);
#endif
	(void)fprintf(stderr, "id: ");
	(void)vfprintf(stderr, fmt, ap);
	va_end(ap);
	(void)fprintf(stderr, "\n");
	exit(1);
d321 4
a324 4
	(void)fprintf(stderr, "usage: id [user]\n");
	(void)fprintf(stderr, "       id -G [-n] [user]\n");
	(void)fprintf(stderr, "       id -g [-nr] [user]\n");
	(void)fprintf(stderr, "       id -u [-nr] [user]\n");
@


1.4
log
@Wall, and seperate uid and gid types
@
text
@d1 1
a1 1
/*	$OpenBSD: id.c,v 1.3 1997/01/15 23:42:35 millert Exp $	*/
d44 1
a44 1
static char rcsid[] = "$OpenBSD: id.c,v 1.3 1997/01/15 23:42:35 millert Exp $";
d318 1
a318 1
#if __STDC__
d325 1
a325 1
#if __STDC__
d334 1
a334 1
#if __STDC__
@


1.3
log
@getopt(3) returns -1 when out of args, not EOF, whee!
@
text
@d1 1
a1 1
/*	$OpenBSD: id.c,v 1.2 1996/06/26 05:34:24 deraadt Exp $	*/
d44 1
a44 1
static char rcsid[] = "$OpenBSD: id.c,v 1.2 1996/06/26 05:34:24 deraadt Exp $";
d156 1
a156 1
	u_int eid, rid;
d176 1
a176 1
			if (pw = getpwuid(eid))
d181 1
a181 1
			if (gr = getgrgid(rid))
d195 3
a197 2
	int cnt, id, eid, lastid, ngroups;
	gid_t groups[NGROUPS];
d202 1
a202 1
	if (pw = getpwuid(id))
d206 1
a206 1
		if (pw = getpwuid(eid))
d211 1
a211 1
	if (gr = getgrgid(id))
d215 1
a215 1
		if (gr = getgrgid(eid))
d218 5
a222 5
	if (ngroups = getgroups(NGROUPS, groups)) {
		for (fmt = " groups=%u", lastid = -1, cnt = 0; cnt < ngroups;
		    fmt = ", %u", lastid = id) {
			id = groups[cnt++];
			if (lastid == id)
d224 2
a225 2
			(void)printf(fmt, id);
			if (gr = getgrgid(id))
d237 1
a237 1
	register char *fmt, **p;
d243 1
a243 1
	if (gr = getgrgid(pw->pw_gid))
d253 1
a253 1
		if (gr = getgrgid(id))
d282 1
a282 1
			if (gr = getgrgid(id))
d302 1
a302 1
	long id;
d309 1
a309 1
	if (pw = getpwnam(u))
d311 1
a311 1
	id = strtol(u, &ep, 10);
@


1.2
log
@rcsid
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d44 1
a44 1
static char rcsid[] = "$OpenBSD: id.c,v 1.7 1995/09/28 08:05:42 perry Exp $";
d76 1
a76 1
	while ((ch = getopt(argc, argv, "Ggnpru")) != EOF)
@


1.1
log
@Initial revision
@
text
@d1 2
d44 1
a44 1
static char rcsid[] = "$NetBSD: id.c,v 1.7 1995/09/28 08:05:42 perry Exp $";
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@
