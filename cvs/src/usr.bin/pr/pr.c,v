head	1.39;
access;
symbols
	OPENBSD_6_1:1.39.0.6
	OPENBSD_6_1_BASE:1.39
	OPENBSD_6_0:1.39.0.4
	OPENBSD_6_0_BASE:1.39
	OPENBSD_5_9:1.39.0.2
	OPENBSD_5_9_BASE:1.39
	OPENBSD_5_8:1.35.0.6
	OPENBSD_5_8_BASE:1.35
	OPENBSD_5_7:1.35.0.2
	OPENBSD_5_7_BASE:1.35
	OPENBSD_5_6:1.34.0.4
	OPENBSD_5_6_BASE:1.34
	OPENBSD_5_5:1.33.0.4
	OPENBSD_5_5_BASE:1.33
	OPENBSD_5_4:1.31.0.2
	OPENBSD_5_4_BASE:1.31
	OPENBSD_5_3:1.30.0.10
	OPENBSD_5_3_BASE:1.30
	OPENBSD_5_2:1.30.0.8
	OPENBSD_5_2_BASE:1.30
	OPENBSD_5_1_BASE:1.30
	OPENBSD_5_1:1.30.0.6
	OPENBSD_5_0:1.30.0.4
	OPENBSD_5_0_BASE:1.30
	OPENBSD_4_9:1.30.0.2
	OPENBSD_4_9_BASE:1.30
	OPENBSD_4_8:1.28.0.4
	OPENBSD_4_8_BASE:1.28
	OPENBSD_4_7:1.28.0.2
	OPENBSD_4_7_BASE:1.28
	OPENBSD_4_6:1.27.0.6
	OPENBSD_4_6_BASE:1.27
	OPENBSD_4_5:1.27.0.2
	OPENBSD_4_5_BASE:1.27
	OPENBSD_4_4:1.26.0.2
	OPENBSD_4_4_BASE:1.26
	OPENBSD_4_3:1.25.0.2
	OPENBSD_4_3_BASE:1.25
	OPENBSD_4_2:1.23.0.4
	OPENBSD_4_2_BASE:1.23
	OPENBSD_4_1:1.23.0.2
	OPENBSD_4_1_BASE:1.23
	OPENBSD_4_0:1.21.0.10
	OPENBSD_4_0_BASE:1.21
	OPENBSD_3_9:1.21.0.8
	OPENBSD_3_9_BASE:1.21
	OPENBSD_3_8:1.21.0.6
	OPENBSD_3_8_BASE:1.21
	OPENBSD_3_7:1.21.0.4
	OPENBSD_3_7_BASE:1.21
	OPENBSD_3_6:1.21.0.2
	OPENBSD_3_6_BASE:1.21
	OPENBSD_3_5:1.20.0.2
	OPENBSD_3_5_BASE:1.20
	OPENBSD_3_4:1.19.0.2
	OPENBSD_3_4_BASE:1.19
	OPENBSD_3_3:1.15.0.4
	OPENBSD_3_3_BASE:1.15
	OPENBSD_3_2:1.15.0.2
	OPENBSD_3_2_BASE:1.15
	OPENBSD_3_1:1.14.0.2
	OPENBSD_3_1_BASE:1.14
	OPENBSD_3_0:1.10.0.2
	OPENBSD_3_0_BASE:1.10
	OPENBSD_2_9_BASE:1.9
	OPENBSD_2_9:1.9.0.2
	OPENBSD_2_8:1.7.0.4
	OPENBSD_2_8_BASE:1.7
	OPENBSD_2_7:1.7.0.2
	OPENBSD_2_7_BASE:1.7
	OPENBSD_2_6:1.6.0.2
	OPENBSD_2_6_BASE:1.6
	OPENBSD_2_5:1.5.0.10
	OPENBSD_2_5_BASE:1.5
	OPENBSD_2_4:1.5.0.8
	OPENBSD_2_4_BASE:1.5
	OPENBSD_2_3:1.5.0.6
	OPENBSD_2_3_BASE:1.5
	OPENBSD_2_2:1.5.0.4
	OPENBSD_2_2_BASE:1.5
	OPENBSD_2_1:1.5.0.2
	OPENBSD_2_1_BASE:1.5
	OPENBSD_2_0:1.3.0.2
	OPENBSD_2_0_BASE:1.3
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.39
date	2015.11.11.02.52.46;	author deraadt;	state Exp;
branches;
next	1.38;
commitid	6fvHpVQjE6wYuHzb;

1.38
date	2015.10.09.01.37.08;	author deraadt;	state Exp;
branches;
next	1.37;
commitid	sbrB3Q5CNxcwZpfU;

1.37
date	2015.10.07.06.15.51;	author deraadt;	state Exp;
branches;
next	1.36;
commitid	AOsKRv4JYJC0Ky5y;

1.36
date	2015.08.20.22.32.41;	author deraadt;	state Exp;
branches;
next	1.35;
commitid	0Dp7Dy9FuNZesYo2;

1.35
date	2015.02.08.23.40.34;	author deraadt;	state Exp;
branches;
next	1.34;
commitid	yGZX28AeTChVE8eY;

1.34
date	2014.04.15.17.27.37;	author jmc;	state Exp;
branches;
next	1.33;

1.33
date	2013.11.26.13.19.07;	author deraadt;	state Exp;
branches;
next	1.32;

1.32
date	2013.08.22.04.43.40;	author guenther;	state Exp;
branches;
next	1.31;

1.31
date	2013.04.18.02.28.48;	author deraadt;	state Exp;
branches;
next	1.30;

1.30
date	2010.08.25.18.20.11;	author chl;	state Exp;
branches;
next	1.29;

1.29
date	2010.08.17.21.37.11;	author jasper;	state Exp;
branches;
next	1.28;

1.28
date	2009.10.27.23.59.41;	author deraadt;	state Exp;
branches;
next	1.27;

1.27
date	2009.02.07.17.51.22;	author chl;	state Exp;
branches;
next	1.26;

1.26
date	2008.04.18.20.18.21;	author tobias;	state Exp;
branches;
next	1.25;

1.25
date	2007.09.03.12.36.09;	author moritz;	state Exp;
branches;
next	1.24;

1.24
date	2007.09.03.05.40.00;	author deraadt;	state Exp;
branches;
next	1.23;

1.23
date	2007.03.03.23.16.02;	author jmc;	state Exp;
branches;
next	1.22;

1.22
date	2007.02.20.16.55.37;	author moritz;	state Exp;
branches;
next	1.21;

1.21
date	2004.06.21.15.27.19;	author avsm;	state Exp;
branches;
next	1.20;

1.20
date	2003.11.09.20.13.57;	author otto;	state Exp;
branches;
next	1.19;

1.19
date	2003.08.04.17.06.45;	author deraadt;	state Exp;
branches;
next	1.18;

1.18
date	2003.06.12.20.58.10;	author deraadt;	state Exp;
branches;
next	1.17;

1.17
date	2003.06.10.22.20.49;	author deraadt;	state Exp;
branches;
next	1.16;

1.16
date	2003.06.03.02.56.14;	author millert;	state Exp;
branches;
next	1.15;

1.15
date	2002.04.30.01.59.47;	author deraadt;	state Exp;
branches;
next	1.14;

1.14
date	2001.11.29.18.21.23;	author mpech;	state Exp;
branches;
next	1.13;

1.13
date	2001.11.19.19.02.15;	author mpech;	state Exp;
branches;
next	1.12;

1.12
date	2001.11.19.03.37.33;	author deraadt;	state Exp;
branches;
next	1.11;

1.11
date	2001.11.02.16.25.02;	author deraadt;	state Exp;
branches;
next	1.10;

1.10
date	2001.05.24.02.58.50;	author pvalchev;	state Exp;
branches;
next	1.9;

1.9
date	2001.02.05.01.57.12;	author deraadt;	state Exp;
branches;
next	1.8;

1.8
date	2000.11.10.15.33.12;	author provos;	state Exp;
branches;
next	1.7;

1.7
date	99.12.03.23.43.02;	author deraadt;	state Exp;
branches;
next	1.6;

1.6
date	99.05.23.17.37.41;	author millert;	state Exp;
branches;
next	1.5;

1.5
date	97.04.23.08.08.28;	author grr;	state Exp;
branches;
next	1.4;

1.4
date	97.01.15.23.43.00;	author millert;	state Exp;
branches;
next	1.3;

1.3
date	96.08.10.04.41.00;	author imp;	state Exp;
branches;
next	1.2;

1.2
date	96.06.26.05.37.54;	author deraadt;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.45.56;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.45.56;	author deraadt;	state Exp;
branches;
next	;


desc
@@


1.39
log
@exit() after perror() for pledge failure.  Perhaps this got introduced
as a test idiom, either when pledge was young or during the transition
to strings.... dunno
@
text
@/*	$OpenBSD: pr.c,v 1.38 2015/10/09 01:37:08 deraadt Exp $	*/

/*-
 * Copyright (c) 1991 Keith Muller.
 * Copyright (c) 1993
 *	The Regents of the University of California.  All rights reserved.
 *
 * This code is derived from software contributed to Berkeley by
 * Keith Muller of the University of California, San Diego.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */

#include <sys/types.h>
#include <sys/time.h>
#include <sys/stat.h>

#include <ctype.h>
#include <errno.h>
#include <limits.h>
#include <signal.h>
#include <stdio.h>
#include <stdarg.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>

#include "pr.h"
#include "extern.h"

/*
 * pr:	a printing and pagination filter. If multiple input files
 *	are specified, each is read, formatted, and written to standard
 *	output. By default, input is separated into 66-line pages, each
 *	with a header that includes the page number, date, time and the
 *	files pathname.
 *
 *	Complies with posix P1003.2/D11
 */

/*
 * pr: more boundary conditions than a four-legged porcupine
 *
 * the original version didn't support form-feeds, while many of the ad-hoc
 * pr implementations out there do.  Addding this and making it work reasonably
 * in all four output modes required quite a bit of hacking and a few minor
 * bugs were noted and fixed in the process.  Some implementations have this
 * as the as -f, some as -F so we accept either.
 *
 * The implementation of form feeds on top of the existing I/O structure is
 * a bit idiosyncratic.  Basically they are treated as temporary end-of-file
 * conditions and an additional level of "loop on form feed" is added to each
 * of the output modes to continue after such a transient end-of-file's. This
 * has the general benefit of making the existing header/trailer logic work
 * and provides a usable framework for rational behavior in multi-column modes.
 *
 * The original "efficient" implementation of the "skip to page N" option was
 * bogus and I substituted the basic inhibit printing until page N approach.
 * This is still fairly bogus vis-a-vis numbering pages on multiple files
 * restarting at one, but at least lets you consistently reprint some large
 * document starting in the middle, in any of the output modes.
 *
 * Additional support for overprinting via <back-space> or <return> would
 * be nice, but is not trivial across tab interpretation, output formatting
 * and the different operating modes.  Support for line-wrapping, either
 * strict or word-wrapped would be really useful and not all that hard to
 * kludge into the inln() implementation.  The general notion is that -wc n
 * would specify width and wrapping with a marker character c and -Wc n
 * would add word wrapping with a minimum width n and delimiters c, defaulting
 * to tab, blank, and -, and column width.  Word wrapping always involves
 * painful policy questions which are difficult to specify unless you just
 * hardwire in some fixed rules. Think quotes, punctuation and white-space
 * elimination and whether you'd do the same thing with a C program and
 * something like columninated newspaper text.
 *
 *				George Robbins <grr@@tharsis.com> 4/22/97.
 */

/*
 * parameter variables
 */
int	pgnm;		/* starting page number */
int	skipping;	/* we're skipping to page pgnum */
int	clcnt;		/* number of columns */
int	colwd;		/* column data width - multiple columns */
int	across;		/* mult col flag; write across page */
int	dspace;		/* double space flag */
char	inchar;		/* expand input char */
int	ingap;		/* expand input gap */
int	formfeed;	/* use formfeed as trailer */
int	inform;		/* grok formfeeds in input */
char	*header;	/* header name instead of file name */
char	ochar;		/* contract output char */
int	ogap;		/* contract output gap */
int	lines;		/* number of lines per page */
int	merge;		/* merge multiple files in output */
char	nmchar;		/* line numbering append char */
int	nmwd;		/* width of line number field */
int	offst;		/* number of page offset spaces */
int	nodiag;		/* do not report file open errors */
char	schar;		/* text column separation character */
int	sflag;		/* -s option for multiple columns */
int	nohead;		/* do not write head and trailer */
int	pgwd;		/* page width with multiple col output */
char	*timefrmt;	/* time conversion string */

/*
 * misc globals
 */
volatile sig_atomic_t	ferr;	/* error message delayed */
int	addone = 0;	/* page length is odd with double space */
int	errcnt = 0;	/* error count on file processing */
int	beheaded = 0;	/* header / trailer link */
char	digs[] = "0123456789";	/* page number translation map */

int
main(int argc, char *argv[])
{
    int ret_val;

    if (pledge("stdio rpath", NULL) == -1) {
	perror("pledge");
	exit(1);
    }

    if (signal(SIGINT, SIG_IGN) != SIG_IGN)
	(void)signal(SIGINT, terminate);
    ret_val = setup(argc, argv);
    if (!ret_val) {
	/*
	 * select the output format based on options
	 */
	if (merge)
	    ret_val = mulfile(argc, argv);
	else if (clcnt == 1)
	    ret_val = onecol(argc, argv);
	else if (across)
	    ret_val = horzcol(argc, argv);
	else
	    ret_val = vertcol(argc, argv);
    } else
	usage();
    flsh_errs();
    if (errcnt || ret_val)
	exit(1);
    return(0);
}

/*
 * onecol:    print files with only one column of output.
 *        Line length is unlimited.
 */
int
onecol(int argc, char *argv[])
{
    int off;
    int lrgln;
    int linecnt;
    int num;
    int cnt;
    int rc;
    int lncnt;
    int pagecnt;
    int ips;
    int ops;
    int cps;
    char *obuf = NULL;
    char *lbuf;
    char *nbuf;
    char *hbuf = NULL;
    char *ohbuf;
    FILE *inf = NULL;
    char *fname;
    int mor;
    int error = 1;

    if (nmwd)
	num = nmwd + 1;
    else
	num = 0;
    off = num + offst;

    /*
     * allocate line buffer
     */
    if ((obuf = malloc((unsigned)(LBUF + off)*sizeof(char))) == NULL)
	goto oomem;

    /*
     * allocate header buffer
     */
    if ((hbuf = malloc((unsigned)(HDBUF + offst)*sizeof(char))) == NULL)
	goto oomem;

    ohbuf = hbuf + offst;
    nbuf = obuf + offst;
    lbuf = nbuf + num;

    if (num)
	nbuf[--num] = nmchar;

    if (offst) {
	(void)memset(obuf, (int)' ', offst);
	(void)memset(hbuf, (int)' ', offst);
    }

    /*
     * loop by file
     */
    while ((inf = nxtfile(argc, argv, &fname, ohbuf, 0)) != NULL) {
	pagecnt = 0;
	lncnt = 0;

	/*
	 * loop by "form"
	 */
	for(;;) {

	    /*
	     * loop by page
	     */
	    for(;;) {
		linecnt = 0;
		lrgln = 0;
		ops = 0;
		ips = 0;
		cps = 0;

		/*
		 * loop by line
		 */
		while (linecnt < lines) {

		    /*
		     * input next line
		     */
		    rc = inln(inf,lbuf,LBUF,&cnt,&cps,0,&mor);
		    if (cnt >= 0) {
			if (!lrgln)
			    if (!linecnt && prhead(hbuf, fname, ++pagecnt))
			         goto out;

			/*
			 * start new line or continue a long one
			 */
			if (!lrgln) {
			    if (num)
				addnum(nbuf, num, ++lncnt);
			    if (otln(obuf,cnt+off, &ips, &ops, mor))
				goto out;
			} else
			    if (otln(lbuf, cnt, &ips, &ops, mor))
				goto out;

			/*
			 * if line bigger than buffer, get more
			 */
			if (mor) {
			    lrgln = 1;
			} else {
			    /*
			     * whole line rcvd. reset tab proc. state
			     */
			    ++linecnt;
			    lrgln = 0;
			    ops = 0;
			    ips = 0;
			}
		    }

		    if (rc != NORMAL)
			break;
		}

		/*
		 * fill to end of page
		 */
		if (prtail(lines - linecnt, lrgln))
		    goto out;

		/*
		 * unless END continue
		 */
		if (rc == END)
		    break;
	    }

	    /*
	     * On EOF go to next file
	     */
	    if (rc == END)
	    break;
	}

	if (inf != stdin)
	    (void)fclose(inf);
    }
    /*
     * If we didn't process all the files, return error
     */
    if (eoptind < argc) {
	goto out;
    } else {
	error = 0;
	goto out;
    }

oomem:
    mfail();
out:
    free(obuf);
    free(hbuf);
    if (inf != NULL && inf != stdin)
	(void)fclose(inf);
    return error;
}

/*
 * vertcol:	print files with more than one column of output down a page
 *		the general approach is to buffer a page of data, then print
 */
int
vertcol(int argc, char *argv[])
{
    char *ptbf;
    char **lstdat = NULL;
    int i;
    int j;
    int pln;
    int *indy = NULL;
    int cnt;
    int rc;
    int cvc;
    int *lindy = NULL;
    int lncnt;
    int stp;
    int pagecnt;
    int col = colwd + 1;
    int mxlen = pgwd + offst + 1;
    int mclcnt = clcnt - 1;
    struct vcol *vc = NULL;
    int mvc;
    int tvc;
    int cw = nmwd + 1;
    int fullcol;
    char *buf = NULL;
    char *hbuf = NULL;
    char *ohbuf;
    char *fname;
    FILE *inf = NULL;
    int ips = 0;
    int cps = 0;
    int ops = 0;
    int mor = 0;
    int error = 1;

    /*
     * allocate page buffer
     */
    if ((buf = calloc((unsigned)lines, mxlen)) == NULL)
	goto oomem;

    /*
     * allocate page header
     */
    if ((hbuf = malloc((unsigned)HDBUF + offst)) == NULL)
	goto oomem;

    ohbuf = hbuf + offst;
    if (offst)
	(void)memset(hbuf, (int)' ', offst);

    /*
     * col pointers when no headers
     */
    mvc = lines * clcnt;
    if ((vc = calloc((unsigned)mvc, sizeof(struct vcol))) == NULL)
	goto oomem;

    /*
     * pointer into page where last data per line is located
     */
    if ((lstdat = calloc((unsigned)lines, sizeof(char *))) == NULL)
	goto oomem;

    /*
     * fast index lookups to locate start of lines
     */
    if ((indy = calloc((unsigned)lines, sizeof(int))) == NULL)
	goto oomem;
    if ((lindy = calloc((unsigned)lines, sizeof(int))) == NULL)
	goto oomem;

    if (nmwd)
	fullcol = col + cw;
    else
	fullcol = col;

    /*
     * initialize buffer lookup indexes and offset area
     */
    for (j = 0; j < lines; ++j) {
	lindy[j] = j * mxlen;
	indy[j] = lindy[j] + offst;
	if (offst) {
	    ptbf = buf + lindy[j];
	    (void)memset(ptbf, (int)' ', offst);
	    ptbf += offst;
	} else
	    ptbf = buf + indy[j];
	lstdat[j] = ptbf;
    }

    /*
     * loop by file
     */
    while ((inf = nxtfile(argc, argv, &fname, ohbuf, 0)) != NULL) {
	pagecnt = 0;
	lncnt = 0;

	/*
	 * loop by "form"
	 */
	 for (;;) {

	    /*
	     * loop by page
	     */
	    for(;;) {

		/*
		 * loop by column
		 */
		cvc = 0;
		for (i = 0; i < clcnt; ++i) {
		    j = 0;
		    /*
		     * if last column, do not pad
		     */
		    if (i == mclcnt)
			stp = 1;
		    else
			stp = 0;

		    /*
		     * loop by line
		     */
		    for(;;) {
			/*
			 * is this first column
			 */
			if (!i) {
			    ptbf = buf + indy[j];
			    lstdat[j] = ptbf;
			} else 
			    ptbf = lstdat[j];
			vc[cvc].pt = ptbf;

			/*
			 * add number
			 */
			if (nmwd) {
			    addnum(ptbf, nmwd, ++lncnt);
			    ptbf += nmwd;
			    *ptbf++ = nmchar;
			}

			/*
			 * input next line
			 */
			rc = inln(inf,ptbf,colwd,&cnt,&cps,1,&mor);
			vc[cvc++].cnt = cnt;
			if (cnt >= 0) {
			    ptbf += cnt;

			    /*
			     * pad all but last column on page
			     */
			    if (!stp) {
				/*
				 * pad to end of column
				 */
				if (sflag)
				    *ptbf++ = schar;
				else if ((pln = col-cnt) > 0) {
				    (void)memset(ptbf,
					(int)' ',pln);
				    ptbf += pln;
				}
			    }

			    /*
			     * remember last char in line
			     */
			    lstdat[j] = ptbf;
			    if (++j >= lines)
				break;
			} /* end of if cnt >= 0 */

			if (rc != NORMAL)
			    break;
		    } /* end of for line */

		    if (rc != NORMAL)
			break;
		} /* end of for column */

		/*
		 * when -t (no header) is specified the spec requires
		 * the min number of lines. The last page may not have
		 * balanced length columns. To fix this we must reorder
		 * the columns. This is a very slow technique so it is
		 * only used under limited conditions. Without -t, the
		 * balancing of text columns is unspecified. To NOT
		 * balance the last page, add the global variable
		 * nohead to the if statement below e.g.
		 */

		/*
		 * print header iff we got anything on the first read
		 */
		if (vc[0].cnt >= 0) {
		    if (prhead(hbuf, fname, ++pagecnt))
		    	goto out;

		    /*
		     * check to see if "last" page needs to be reordered
		     */
		    --cvc;
		    if ((rc != NORMAL) && cvc && ((mvc-cvc) >= clcnt)){
			pln = cvc/clcnt;
			if (cvc % clcnt)
			    ++pln;

			for (i = 0; i < pln; ++i) {
			    ips = 0;
			    ops = 0;
			    if (offst && otln(buf,offst,&ips,&ops,1))
				goto out;
			    tvc = i;

			    for (j = 0; j < clcnt; ++j) {
				/*
				 * determine column length
				 */
				if (j == mclcnt) {
				    /*
				     * last column
				     */
				    cnt = vc[tvc].cnt;
				    if (nmwd)
					cnt += cw;
				} else if (sflag) {
				    /*
				     * single ch between
				     */
				    cnt = vc[tvc].cnt + 1;
				    if (nmwd)
					cnt += cw;
				} else
				    cnt = fullcol;

				if (otln(vc[tvc].pt, cnt, &ips, &ops, 1))
				    goto out;
				tvc += pln;
				if (tvc > cvc)
				    break;
			    }
			    /*
			     * terminate line
			     */
			    if (otln(buf, 0, &ips, &ops, 0))
				goto out;
			}

		    } else {

			/*
			 * just a normal page...
			 * determine how many lines to output
			 */
			if (i > 0)
			    pln = lines;
			else
			    pln = j;

			/*
			 * output each line
			 */
			for (i = 0; i < pln; ++i) {
			    ptbf = buf + lindy[i];
			    if ((j = lstdat[i] - ptbf) <= offst)
				break;
			    else {
				ips = 0;
				ops = 0;
				if (otln(ptbf, j, &ips, &ops, 0))
				    goto out;
			    }
			}
		    }
		}

		/*
		 * pad to end of page
		 */
		if (prtail((lines - pln), 0))
		    goto out;

		/*
		 * if FORM continue
		 */
		if (rc != NORMAL)
		    break;
	    }

	    /*
	     * if EOF go to next file
	     */
	    if (rc == END)
		break;
	}

	if (inf != stdin)
	    (void)fclose(inf);
    }

    if (eoptind < argc){
	goto out;
    } else {
	error = 0;
	goto out;
    }

oomem:
    mfail();
out:
    free(buf);
    free(hbuf);
    free(vc);
    free(lstdat);
    free(lindy);
    if (inf != NULL && inf != stdin)
	(void)fclose(inf);
    return error;

}

/*
 * horzcol:    print files with more than one column of output across a page
 */
int
horzcol(int argc, char *argv[])
{
    char *ptbf;
    int pln;
    char *lstdat;
    int col = colwd + 1;
    int j;
    int i;
    int cnt;
    int rc;
    int lncnt;
    int pagecnt;
    char *buf = NULL;
    char *hbuf = NULL;
    char *ohbuf;
    char *fname;
    FILE *inf = NULL;
    int cps = 0;
    int mor = 0;
    int ips = 0;
    int ops = 0;
    int error = 1;

    if ((buf = malloc((unsigned)pgwd + offst + 1)) == NULL)
	goto oomem;

    /*
     * page header
     */
    if ((hbuf = malloc((unsigned)HDBUF + offst)) == NULL)
	goto oomem;

    ohbuf = hbuf + offst;
    if (offst) {
	(void)memset(buf, (int)' ', offst);
	(void)memset(hbuf, (int)' ', offst);
    }

    /*
     * loop by file
     */
    while ((inf = nxtfile(argc, argv, &fname, ohbuf, 0)) != NULL) {
	pagecnt = 0;
	lncnt = 0;

	/*
	 * loop by form
	 */
	for (;;) {

	    /*
	     * loop by page
	     */
	    for(;;) {

		/*
		 * loop by line
		 */
		for (i = 0; i < lines; ++i) {
		    ptbf = buf + offst;
		    lstdat = ptbf;
		    j = 0;

		    /*
		     * loop by col
		     */
		    for(;;) {
			if (nmwd) {
			    /*
			     * add number to column
			     */
			    addnum(ptbf, nmwd, ++lncnt);
			    ptbf += nmwd;
			    *ptbf++ = nmchar;
			}
			/*
			 * input line
			 */
			rc = inln(inf,ptbf,colwd,&cnt,&cps,1, &mor);
			if (cnt >= 0) {
			    if (!i && !j && prhead(hbuf, fname, ++pagecnt))
			        goto out;

			    ptbf += cnt;
			    lstdat = ptbf;

			    /*
			     * if last line skip padding
			     */
			    if (++j >= clcnt)
				break;

			    /*
			     * pad to end of column
			     */
			    if (sflag)
				*ptbf++ = schar;
			    else if ((pln = col - cnt) > 0) {
				(void)memset(ptbf,(int)' ',pln);
				ptbf += pln;
			    }
			}
			if (rc != NORMAL)
			    break;
		    }

		    /*
		     * output line if any columns on it
		     */
		    if (j) {
			if (otln(buf, lstdat-buf, &ips, &ops, 0))
			    goto out;
		    }

		    if (rc != NORMAL)
			break;
		}

		/*
		 * pad to end of page
		 */
		if (prtail(lines - i, 0))
		    return(1);

		/*
		 * if FORM continue
		 */
		if (rc == END)
		    break;
	    }
	    /*
	     * if EOF go to next file
	     */
	    if (rc == END)
		break;
	}
	if (inf != stdin)
	    (void)fclose(inf);
    }
    if (eoptind < argc){
	goto out;
    } else {
	error = 0;
	goto out;
    }

oomem:
    mfail();
out:
    free(buf);
    free(hbuf);
    if (inf != NULL && inf != stdin)
	(void)fclose(inf);
    return error;
}

struct ferrlist {
	struct ferrlist *next;
	char *buf;
};
struct ferrlist *ferrhead, *ferrtail;

/*
 * flsh_errs():    output saved up diagnostic messages after all normal
 *        processing has completed
 */
void
flsh_errs(void)
{
    struct ferrlist *f;

    if (ferr) {
	for (f = ferrhead; f; f = f->next)
	    (void)write(STDERR_FILENO, f->buf, strlen(f->buf));
    }
}

static void ferrout(char *fmt, ...) __attribute__((format (printf, 1, 2)));
static void
ferrout(char *fmt, ...)
{
    sigset_t block, oblock;
    struct ferrlist *f;
    va_list ap;
    char *p;

    va_start(ap, fmt);
    if (ferr == 0)
        vfprintf(stderr, fmt, ap);
    else {
	sigemptyset(&block);
	sigaddset(&block, SIGINT);
	sigprocmask(SIG_BLOCK, &block, &oblock);

	if (vasprintf(&p, fmt, ap) == -1 || (f = malloc(sizeof(*f))) == NULL) {
		va_end(ap);
		va_start(ap, fmt);
		flsh_errs();
		vfprintf(stderr, fmt, ap);
		fputs("pr: memory allocation failed\n", stderr);
		exit(1);
	}

	f->next = NULL;
	f->buf = p;
	if (ferrhead == NULL)
	    ferrhead = f;
	if (ferrtail)
		ferrtail->next = f;
	ferrtail = f;
	sigprocmask(SIG_SETMASK, &oblock, NULL);
    }
    va_end(ap);
}

/*
 * mulfile:    print files with more than one column of output and
 *        more than one file concurrently
 */
int
mulfile(int argc, char *argv[])
{
    char *ptbf;
    int j;
    int pln;
    int *rc;
    int cnt;
    char *lstdat;
    int i;
    FILE **fbuf = NULL;
    int actf;
    int lncnt;
    int col;
    int pagecnt;
    int fproc;
    char *buf = NULL;
    char *hbuf = NULL;
    char *ohbuf;
    char *fname;
    int ips = 0;
    int cps = 0;
    int ops = 0;
    int mor = 0;
    int error = 1;

    /*
     * array of FILE *, one for each operand
     */
    if ((fbuf = calloc((unsigned)clcnt, sizeof(FILE *))) == NULL)
	goto oomem;

    /*
     * array of int *, one for each operand
     */
    if ((rc = calloc((unsigned)clcnt, sizeof(int))) == NULL)
	goto oomem;

    /*
     * page header
     */
    if ((hbuf = malloc((unsigned)HDBUF + offst)) == NULL)
	goto oomem;

    ohbuf = hbuf + offst;

    /*
     * do not know how many columns yet. The number of operands provide an
     * upper bound on the number of columns. We use the number of files
     * we can open successfully to set the number of columns. The operation
     * of the merge operation (-m) in relation to unsuccessful file opens
     * is unspecified by posix.
     *
     * XXX - this seems moderately bogus, you'd think that specifying
     * "pr -2 a b c d" would run though all the files in pairs, but
     * the existing code says up two files, or fewer if one is bogus.
     * fixing it would require modifying the looping structure, so be it.
     */
    j = 0;
    while (j < clcnt) {
	if ((fbuf[j] = nxtfile(argc, argv, &fname, ohbuf, 1)) != NULL) {
	    rc[j] = NORMAL;
	    j++;
	}
    }

    /*
     * if no files, exit
     */
    if (j)
	clcnt = j;
    else
	goto out;

    /*
     * calculate page boundaries based on open file count
     */
    if (nmwd) {
	colwd = (pgwd - clcnt - nmwd)/clcnt;
	pgwd = ((colwd + 1) * clcnt) - nmwd - 2;
    } else {
	colwd = (pgwd + 1 - clcnt)/clcnt;
	pgwd = ((colwd + 1) * clcnt) - 1;
    }
    if (colwd < 1) {
	ferrout("pr: page width too small for %d columns\n", clcnt);
	goto out;
    }
    col = colwd + 1;

    /*
     * line buffer
     */
    if ((buf = malloc((unsigned)pgwd + offst + 1)) == NULL)
	goto oomem;

    if (offst) {
	(void)memset(buf, (int)' ', offst);
	(void)memset(hbuf, (int)' ', offst);
    }

    pagecnt = 0;
    lncnt = 0;
    actf = clcnt;

    /*
     * continue to loop while any file still has data
     */
    while (actf > 0) {

	/*
	 * loop on "form"
	 */
	for (;;) {

	    /*
	     * loop by line
	     */
	    for (i = 0; i < lines; ++i) {
		ptbf = buf + offst;
		lstdat = ptbf;
		if (nmwd) {
		    /*
		     * add line number to line
		     */
		    addnum(ptbf, nmwd, ++lncnt);
		    ptbf += nmwd;
		    *ptbf++ = nmchar;
		}

		fproc = 0;
		/*
		 * loop by column
		 */
		for (j = 0; j < clcnt; ++j) {
		    if (rc[j] == NORMAL ) {
			rc[j] = inln(fbuf[j], ptbf, colwd, &cnt, &cps, 1, &mor);
			if (cnt >= 0) {
			    /*
			     * process file data
			     */
			    ptbf += cnt;
			    lstdat = ptbf;
			    fproc++;
			} else
			    cnt = 0;
			
			if (rc[j] == END) {
			    /*
			     * EOF close file
			     */
			    if (fbuf[j] != stdin)
				(void)fclose(fbuf[j]);
			    --actf;
			}
		    } else
			cnt = 0;

		    /*
		     * if last ACTIVE column, done with line
		     */
		    if (fproc >= actf)
			break;

		    /*
		     * pad to end of column
		     */
		    if (sflag) {
			*ptbf++ = schar;
		    } else {
			if (cnt >= 0)
			    pln = col - cnt;
			else
			    pln = col;
			if (pln > 0) {
			    (void)memset(ptbf, (int)' ', pln);
			    ptbf += pln;
			}
		    }
		}

		/*
		 * if there was anything to do, print it
		 */
		if (fproc != 0) {
		    if (!i && prhead(hbuf, fname, ++pagecnt))
			goto out;

		    /*
		     * output line
		     */
		    if (otln(buf, lstdat-buf, &ips, &ops, 0))
			goto out;
		} else
		    break;
	    }

	    /*
	     * pad to end of page
	     */
	    if (prtail(lines - i, 0))
		return(1);

	    for (j = 0; j < clcnt; ++j)
		if (rc[j] != END)
		    rc[j] = NORMAL;

	    if (actf <= 0)
		break;
	}
	if (actf <= 0)
	break;
    }
    if (eoptind < argc){
	goto out;
    } else {
	error = 0;
	goto out;
    }

oomem:
	mfail();
out:
    if (fbuf) {
	for (j = 0; j < clcnt; j++) {
	    if (fbuf[j] && fbuf[j] != stdin)
		(void)fclose(fbuf[j]);
	}
	free(fbuf);
    }
    free(hbuf);
    free(buf);
    return error;
}

/*
 * inln():    input a line of data (unlimited length lines supported)
 *        Input is optionally expanded to spaces
 *        Returns 0 if normal LF, FORM on Formfeed, and END on EOF
 *
 *    inf:    file
 *    buf:    buffer
 *    lim:    buffer length
 *    cnt:    line length or -1 if no line (EOF for example)
 *    cps:    column position 1st char in buffer (large line support)
 *    trnc:    throw away data more than lim up to \n 
 *    mor:    set if more data in line (not truncated)
 */
int
inln(FILE *inf, char *buf, int lim, int *cnt, int *cps, int trnc, int *mor)
{
    int col;
    int gap = ingap;
    int ch = -1;
    char *ptbuf;
    int chk = (int)inchar;

    ptbuf = buf;

    if (gap) {
	/*
	 * expanding input option
	 */
	while ((--lim >= 0) && ((ch = getc(inf)) != EOF)) {
	    /*
	     * is this the input "tab" char
	     */
	    if (ch == chk) {
		/*
		 * expand to number of spaces
		 */
		col = (ptbuf - buf) + *cps;
		col = gap - (col % gap);

		/*
		 * if more than this line, push back
		 */
		if ((col > lim) && (ungetc(ch, inf) == EOF)) {
		    *cnt = -1;
		    return(END);    /* shouldn't happen */
		}

		/*
		 * expand to spaces
		 */
		while ((--col >= 0) && (--lim >= 0))
		    *ptbuf++ = ' ';
		continue;
	    }
	    if (ch == '\n' || (inform && ch == INFF))
		break;
	    *ptbuf++ = ch;
	}
    } else {
	/*
	 * no expansion
	 */
	while ((--lim >= 0) && ((ch = getc(inf)) != EOF)) {
	    if (ch == '\n' || (inform && ch == INFF))
		break;
	    *ptbuf++ = ch;
	}
    }
    col = ptbuf - buf;
    if (ch == EOF) {
	*mor = 0;
	*cps = 0;
	*cnt = col ? col : -1;
	return(END);
    }
    if (inform && ch == INFF) {
	*mor = 0;
	*cps = 0;
	*cnt = col;
	return(FORM);
    }
    if (ch == '\n') {
	/*
	 * entire line processed
	 */
	*mor = 0;
	*cps = 0;
	*cnt = col;
	return(NORMAL);
    }

    /*
     * line was larger than limit
     */
    if (trnc) {
	/*
	 * throw away rest of line
	 */
	while ((ch = getc(inf)) != EOF) {
	    if (ch == '\n')
		break;
	}
	*cps = 0;
	*mor = 0;
    } else {
	/*
	 * save column offset if not truncated
	 */
	*cps += col;
	*mor = 1;
    }

    *cnt = col;
    return(NORMAL);
}

/*
 * otln():    output a line of data. (Supports unlimited length lines)
 *        output is optionally contracted to tabs
 *
 *    buf:    output buffer with data
 *    cnt:    number of chars of valid data in buf
 *    svips:    buffer input column position (for large lines)
 *    svops:    buffer output column position (for large lines)
 *    mor:    output line not complete in this buf; more data to come.    
 *        1 is more, 0 is complete, -1 is no \n's
 */
int
otln(char *buf, int cnt, int *svips, int *svops, int mor)
{
    int ops;        /* last col output */
    int ips;        /* last col in buf examined */
    int gap = ogap;
    int tbps;
    char *endbuf;

    /* skipping is only changed at header time not mid-line! */
    if (skipping)
	return (0);

    if (ogap) {
	/*
	 * contracting on output
	 */
	endbuf = buf + cnt;
	ops = *svops;
	ips = *svips;
	while (buf < endbuf) {
	    /*
	     * count number of spaces and ochar in buffer
	     */
	    if (*buf == ' ') {
		++ips;
		++buf;
		continue;
	    }

	    /*
	     * simulate ochar processing
	     */
	    if (*buf == ochar) {
		ips += gap - (ips % gap);
		++buf;
		continue;
	    }

	    /*
	     * got a non space char; contract out spaces
	     */
	    while (ops < ips) {
		/*
		 * use one space if necessary
		 */
		if (ips - ops == 1) {
			putchar(' ');
			break;
		}
		/*
		 * use as many ochar as will fit
		 */
		if ((tbps = ops + gap - (ops % gap)) > ips)
		    break;
		if (putchar(ochar) == EOF) {
		    pfail();
		    return(1);
		}
		ops = tbps;
	    }

	    while (ops < ips) {
		/*
		 * finish off with spaces
		 */
		if (putchar(' ') == EOF) {
		    pfail();
		    return(1);
		}
		++ops;
	    }

	    /*
	     * output non space char
	     */
	    if (putchar(*buf++) == EOF) {
		pfail();
		return(1);
	    }
	    ++ips;
	    ++ops;
	}

	if (mor > 0) {
	    /*
	     * if incomplete line, save position counts
	     */
	    *svops = ops;
	    *svips = ips;
	    return(0);
	}

	if (mor < 0) {
	    while (ops < ips) {
		/*
		 * use one space if necessary
		 */
		if (ips - ops == 1) {
			putchar(' ');
			break;
		}
		/*
		 * use as many ochar as will fit
		 */
		if ((tbps = ops + gap - (ops % gap)) > ips)
		    break;
		if (putchar(ochar) == EOF) {
		    pfail();
		    return(1);
		}
		ops = tbps;
	    }

	    while (ops < ips) {
		/*
		 * finish off with spaces
		 */
		if (putchar(' ') == EOF) {
		    pfail();
		    return(1);
		}
		++ops;
	    }
	    return(0);
	}
    } else {
	/*
	 * output is not contracted
	 */
	if (cnt && (fwrite(buf, sizeof(char), cnt, stdout) < cnt)) {
	    pfail();
	    return(1);
	}
	if (mor != 0)
	    return(0);
    }

    /*
     * process line end and double space as required
     */
    if ((putchar('\n') == EOF) || (dspace && (putchar('\n') == EOF))) {
	pfail();
	return(1);
    }
    return(0);
}

#ifdef notused
/*
 * inskip():    skip over pgcnt pages with lncnt lines per page
 *        file is closed at EOF (if not stdin).
 *
 *    inf    FILE * to read from
 *    pgcnt    number of pages to skip
 *    lncnt    number of lines per page
 */
int
inskip(FILE *inf, int pgcnt, int lncnt)
{
    int c;
    int cnt;

    while(--pgcnt > 0) {
	cnt = lncnt;
	while ((c = getc(inf)) != EOF) {
	    if ((c == '\n') && (--cnt == 0))
		break;
	}
	if (c == EOF) {
	    if (inf != stdin)
		(void)fclose(inf);
	    return(1);
	}
    }
    return(0);
}
#endif

/*
 * nxtfile:    returns a FILE * to next file in arg list and sets the
 *        time field for this file (or current date).
 *
 *    buf    array to store proper date for the header.
 *    dt    if set skips the date processing (used with -m)
 */
FILE *
nxtfile(int argc, char *argv[], char **fname, char *buf, int dt)
{
    FILE *inf = NULL;
    struct timeval tv;
    struct tm *timeptr = NULL;
    struct stat statbuf;
    time_t curtime;
    static int twice = -1;

    ++twice;
    if (eoptind >= argc) {
	/*
	 * no file listed; default, use standard input
	 */
	if (twice)
	    return(NULL);
	clearerr(stdin);
	inf = stdin;
	if (header != NULL)
	    *fname = header;
	else
	    *fname = FNAME;
	if (nohead)
	    return(inf);
	if (gettimeofday(&tv, NULL) < 0) {
	    ++errcnt;
	    ferrout("pr: cannot get time of day, %s\n",
		strerror(errno));
	    eoptind = argc - 1;
	    return(NULL);
	}
	curtime = tv.tv_sec;
	timeptr = localtime(&curtime);
    }
    for (; eoptind < argc; ++eoptind) {
	if (strcmp(argv[eoptind], "-") == 0) {
	    /*
	     * process a "-" for filename
	     */
	    clearerr(stdin);
	    inf = stdin;
	    if (header != NULL)
		*fname = header;
	    else
		*fname = FNAME;
	    ++eoptind;
	    if (nohead || (dt && twice))
		return(inf);
	    if (gettimeofday(&tv, NULL) < 0) {
		++errcnt;
		ferrout("pr: cannot get time of day, %s\n",
		    strerror(errno));
		return(NULL);
	    }
	    curtime = tv.tv_sec;
	    timeptr = localtime(&curtime);
	} else {
	    /*
	     * normal file processing
	     */
	    if ((inf = fopen(argv[eoptind], "r")) == NULL) {
		++errcnt;
		if (nodiag)
		    continue;
		ferrout("pr: Cannot open %s, %s\n",
		    argv[eoptind], strerror(errno));
		continue;
	    }
	    if (header != NULL)
		*fname = header;
	    else if (dt)
		*fname = FNAME;
	    else
		*fname = argv[eoptind];
	    ++eoptind;
	    if (nohead || (dt && twice))
		return(inf);

	    if (dt) {
		if (gettimeofday(&tv, NULL) < 0) {
		    ++errcnt;
		    ferrout("pr: cannot get time of day, %s\n",
			 strerror(errno));
		    return(NULL);
		}
		curtime = tv.tv_sec;
		timeptr = localtime(&curtime);
	    } else {
		if (fstat(fileno(inf), &statbuf) < 0) {
		    ++errcnt;
		    (void)fclose(inf);
		    ferrout("pr: Cannot stat %s, %s\n",
			argv[eoptind], strerror(errno));
		    return(NULL);
		}
		timeptr = localtime(&(statbuf.st_mtime));
	    }
	}
	break;
    }
    if (inf == NULL)
	return(NULL);

    /*
     * set up time field used in header
     */
    if (strftime(buf, HDBUF, timefrmt, timeptr) == 0) {
	++errcnt;
	if (inf != stdin)
	    (void)fclose(inf);
	ferrout("pr: time conversion failed\n");
	return(NULL);
    }
    return(inf);
}

/*
 * addnum():    adds the line number to the column
 *        Truncates from the front or pads with spaces as required.
 *        Numbers are right justified.
 *
 *    buf    buffer to store the number
 *    wdth    width of buffer to fill
 *    line    line number
 *
 *        NOTE: numbers occupy part of the column. The posix
 *        spec does not specify if -i processing should or should not
 *        occur on number padding. The spec does say it occupies
 *        part of the column. The usage of addnum    currently treats
 *        numbers as part of the column so spaces may be replaced.
 */
void
addnum(char *buf, int wdth, int line)
{
    char *pt = buf + wdth;

    do {
	*--pt = digs[line % 10];
	line /= 10;
    } while (line && (pt > buf));

    /*
     * pad with space as required
     */
    while (pt > buf)
	*--pt = ' ';
}

/*
 * prhead():    prints the top of page header
 *
 *    buf    buffer with time field (and offset)
 *    cnt    number of chars in buf
 *    fname    fname field for header
 *    pagcnt    page number
 *
 * prhead() should be used carefully, we don't want to print out headers
 * for null input files or orphan headers at the end of files, and also
 * trailer processing is typically conditional on whether you've called
 * prhead() at least once for a file and incremented pagecnt.  Exactly
 * how to determine whether to print a header is a little different in
 * the context each output mode, but we let the caller figure that out.
 */
int
prhead(char *buf, char *fname, int pagcnt)
{
    int ips = 0;
    int ops = 0;

    beheaded = 1;

    if (skipping && pagcnt >= pgnm)
	skipping = 0;

    if (nohead || skipping)
	return (0);

    if ((putchar('\n') == EOF) || (putchar('\n') == EOF)) {
	pfail();
	return(1);
    }
    /*
     * posix is not clear if the header is subject to line length
     * restrictions. The specification for header line format
     * in the spec clearly does not limit length. No pr currently
     * restricts header length. However if we need to truncate in
     * an reasonable way, adjust the length of the printf by
     * changing HDFMT to allow a length max as an argument printf.
     * buf (which contains the offset spaces and time field could
     * also be trimmed
     *
     * note only the offset (if any) is processed for tab expansion
     */
    if (offst && otln(buf, offst, &ips, &ops, -1))
	return(1);
    (void)printf(HDFMT,buf+offst, fname, pagcnt);
    return(0);
}

/*
 * prtail():    pad page with empty lines (if required) and print page trailer
 *        if requested
 *
 *    cnt    	number of lines of padding needed
 *    incomp    was a '\n' missing from last line output
 *
 * prtail() can now be invoked unconditionally, with the notion that if
 * we haven't printed a header, there is no need for a trailer
 */
int
prtail(int cnt, int incomp)
{
    /*
     * if were's skipping to page N or haven't put out anything yet just exit
     */
    if (skipping || beheaded == 0)
	return (0);
    beheaded = 0;

    /*
     * if noheaders, only terminate an incomplete last line
     */
    if (nohead) {

	if (incomp) {
	    if (dspace)
		if (putchar('\n') == EOF) {
		    pfail();
		    return(1);
		}
	    if (putchar('\n') == EOF) {
		pfail();
		return(1);
	     }
	}
	/*
	 * but honor the formfeed request
	 */
	if (formfeed)
	    if (putchar(OUTFF) == EOF) {
		pfail();
		return(1);
	    }

    } else {

	/*
	 * if double space output two \n
	 *
  	 * XXX this all seems bogus, why are we doing it here???
	 * page length is in terms of output lines and only the input is
	 * supposed to be double spaced...  otln() users should be doing
	 * something like linect+=(dspace ? 2:1).
	 */
	if (dspace)
	    cnt *= 2;

	/*
	 * if an odd number of lines per page, add an extra \n
	 */
	if (addone)
	    ++cnt;

	/*
	 * either put out a form-feed or pad page with blanks
	 */
	if (formfeed) {
	    if (incomp)
		if (putchar('\n') == EOF) {
		    pfail();
		    return(1);
		}
	    if (putchar(OUTFF) == EOF) {
		    pfail();
		    return(1);
	    }

	} else {

	    if (incomp)
		cnt++;

	    cnt += TAILLEN;
	    while (--cnt >= 0) {
		if (putchar('\n') == EOF) {
		    pfail();
		    return(1);
		}
	    }
	}
    }

    return(0);
}

/*
 * terminate():    when a SIGINT is recvd
 */
/*ARGSUSED*/
void
terminate(int which_sig)
{
    flsh_errs();
    _exit(1);
}

void
mfail(void)
{
    ferrout("pr: memory allocation failed\n");
}

void
pfail(void)
{
    ferrout("pr: write failure, %s\n", strerror(errno));
}

void
usage(void)
{
    ferrout(
     "usage: pr [+page] [-column] [-adFfmrt] [-e[char][gap]] [-h header]\n");
    ferrout(
     "\t[-i[char][gap]] [-l lines] [-n[char][width]] [-o offset] [-s[char]]\n");
    ferrout(
     "\t[-w width] [file ...]\n");
}

/*
 * setup:    Validate command args, initialize and perform sanity 
 *        checks on options
 */
int
setup(int argc, char *argv[])
{
    int c;
    int eflag = 0;
    int iflag = 0;
    int wflag = 0;
    int cflag = 0;
    const char *errstr;

    if (isatty(fileno(stdout)))
	ferr = 1;

    while ((c = egetopt(argc, argv, "#adfFmrte?h:i?l:n?o:s?w:")) != -1) {
	switch (c) {
	case '+':
	    pgnm = strtonum(eoptarg, 1, INT_MAX, &errstr);
	    if (errstr) {
		ferrout("pr: +page number is %s: %s\n", errstr, eoptarg);
		return(1);
	    }
	    skipping = 1;
	    break;
	case '-':
	    clcnt = strtonum(eoptarg, 1, INT_MAX, &errstr);
	    if (errstr) {
		ferrout("pr: -columns number is %s: %s\n", errstr, eoptarg);
		return(1);
	    }
	    if (clcnt > 1)
		cflag = 1;
	    break;
	case 'a':
	    across = 1;
	    break;
	case 'd':
	    dspace = 1;
	    break;
	case 'e':
	    eflag = 1;
	    if ((eoptarg != NULL) && !isdigit((unsigned char)*eoptarg))
		inchar = *eoptarg++;
	    else
		inchar = INCHAR;
	    if ((eoptarg != NULL) && isdigit((unsigned char)*eoptarg)) {
		ingap = strtonum(eoptarg, 0, INT_MAX, &errstr);
		if (errstr) {
		    ferrout("pr: -e gap is %s: %s\n", errstr, eoptarg);
		    return(1);
		}
		if (ingap == 0)
		    ingap = INGAP;
	    } else if ((eoptarg != NULL) && (*eoptarg != '\0')) {
		ferrout("pr: invalid value for -e %s\n", eoptarg);
		return(1);
	    } else
		ingap = INGAP;
	    break;
	case 'f':
	case 'F':
	    formfeed = 1;
	    break;
	case 'h':
	    header = eoptarg;
	    break;
	case 'i':
	    iflag = 1;
	    if ((eoptarg != NULL) && !isdigit((unsigned char)*eoptarg))
		ochar = *eoptarg++;
	    else
		ochar = OCHAR;
	    if ((eoptarg != NULL) && isdigit((unsigned char)*eoptarg)) {
		ogap = strtonum(eoptarg, 0, INT_MAX, &errstr);
		if (errstr) {
		    ferrout("pr: -i gap is %s: %s\n", errstr, eoptarg);
		    return(1);
		}
		if (ogap == 0)
		    ogap = OGAP;
	    } else if ((eoptarg != NULL) && (*eoptarg != '\0')) {
		ferrout("pr: invalid value for -i %s\n", eoptarg);
		return(1);
	    } else
		ogap = OGAP;
	    break;
	case 'l':
	    lines = strtonum(eoptarg, 1, INT_MAX, &errstr);
	    if (errstr) {
		ferrout("pr: number of lines is %s: %s\n", errstr, eoptarg);
		return(1);
	    }
	    break;
	case 'm':
	    merge = 1;
	    break;
	case 'n':
	    if ((eoptarg != NULL) && !isdigit((unsigned char)*eoptarg))
		nmchar = *eoptarg++;
	    else
		nmchar = NMCHAR;
	    if ((eoptarg != NULL) && isdigit((unsigned char)*eoptarg)) {
		nmwd = strtonum(eoptarg, 1, INT_MAX, &errstr);
		if (errstr) {
		    ferrout("pr: -n width is %s: %s\n", errstr, eoptarg);
		    return(1);
		}
	    } else if ((eoptarg != NULL) && (*eoptarg != '\0')) {
		ferrout("pr: invalid value for -n %s\n", eoptarg);
		return(1);
	    } else
		nmwd = NMWD;
	    break;
	case 'o':
	    offst = strtonum(eoptarg, 1, INT_MAX, &errstr);
	    if (errstr) {
		ferrout("pr: -o offset is %s: %s\n", errstr, eoptarg);
		return(1);
	    }
	    break;
	case 'r':
	    nodiag = 1;
	    break;
	case 's':
	    sflag = 1;
	    if (eoptarg == NULL)
		schar = SCHAR;
	    else {
		schar = *eoptarg++;
		if (*eoptarg != '\0') {
		    ferrout("pr: invalid value for -s %s\n", eoptarg);
		    return(1);
		}
	    }
	    break;
	case 't':
	    nohead = 1;
	    break;
	case 'w':
	    wflag = 1;
	    pgwd = strtonum(eoptarg, 1, INT_MAX, &errstr);
	    if (errstr) {
		ferrout("pr: -w width is %s: %s\n", errstr, eoptarg);
		return(1);
	    }
	    break;
	default:
	    return(1);
	}
    }

    /*
     * default and sanity checks
     */
    inform++;

    if (!clcnt) {
	if (merge) {
	    if ((clcnt = argc - eoptind) <= 1) {
		clcnt = CLCNT;
#ifdef stupid
		merge = 0;
#endif
	    }
	} else
	    clcnt = CLCNT;
    }
    if (across) {
	if (clcnt == 1) {
	    ferrout("pr: -a flag requires multiple columns\n");
	    return(1);
	}
	if (merge) {
	    ferrout("pr: -m cannot be used with -a\n");
	    return(1);
	}
    }
    if (!wflag) {
	if (sflag)
	    pgwd = SPGWD;
	else
	    pgwd = PGWD;
    }
    if (cflag || merge) {
	if (!eflag) {
	    inchar = INCHAR;
	    ingap = INGAP;
	}
	if (!iflag) {
	    ochar = OCHAR;
	    ogap = OGAP;
	}
    }
    if (cflag) {
	if (merge) {
	    ferrout("pr: -m cannot be used with multiple columns\n");
	    return(1);
	}
	if (nmwd) {
	    colwd = (pgwd + 1 - (clcnt * (nmwd + 2)))/clcnt;
	    pgwd = ((colwd + nmwd + 2) * clcnt) - 1;
	} else {
	    colwd = (pgwd + 1 - clcnt)/clcnt;
	    pgwd = ((colwd + 1) * clcnt) - 1;
	}
	if (colwd < 1) {
	    ferrout("pr: page width is too small for %d columns\n",clcnt);
	    return(1);
	}
    }
    if (!lines)
	lines = LINES;

    /*
     * make sure long enough for headers. if not disable
     */
    if (lines <= HEADLEN + TAILLEN)
	nohead = 1;
    else if (!nohead)
	lines -= HEADLEN + TAILLEN;

    /*
     * adjust for double space on odd length pages
     */
    if (dspace) {
	if (lines == 1)
	    dspace = 0;
	else {
	    if (lines & 1)
		++addone;
	    lines /= 2;
	}
    }

    if ((timefrmt = getenv("LC_TIME")) == NULL)
	timefrmt = TIMEFMT;
    return(0);
}
@


1.38
log
@Change all tame callers to namechange to pledge(2).
@
text
@d1 1
a1 1
/*	$OpenBSD: pr.c,v 1.37 2015/10/07 06:15:51 deraadt Exp $	*/
d143 1
a143 1
    if (pledge("stdio rpath", NULL) == -1)
d145 2
@


1.37
log
@tame "stdio rpath"
@
text
@d1 1
a1 1
/*	$OpenBSD: pr.c,v 1.36 2015/08/20 22:32:41 deraadt Exp $	*/
d143 2
a144 2
    if (tame("stdio rpath", NULL) == -1)
	perror("tame");
@


1.36
log
@Do not cast result of malloc/calloc/realloc* if stdlib.h is in scope
ok krw millert
@
text
@d1 1
a1 1
/*	$OpenBSD: pr.c,v 1.35 2015/02/08 23:40:34 deraadt Exp $	*/
d142 3
@


1.35
log
@in getopt() blocks, stop incrementing flag variable which are supposed
to just be 0/1
ok miod florian
@
text
@d1 1
a1 1
/*	$OpenBSD: pr.c,v 1.34 2014/04/15 17:27:37 jmc Exp $	*/
d394 1
a394 1
    if ((vc=(struct vcol *)calloc((unsigned)mvc, sizeof(struct vcol))) == NULL)
d400 1
a400 1
    if ((lstdat = (char **)calloc((unsigned)lines, sizeof(char *))) == NULL)
d406 1
a406 1
    if ((indy = (int *)calloc((unsigned)lines, sizeof(int))) == NULL)
d408 1
a408 1
    if ((lindy = (int *)calloc((unsigned)lines, sizeof(int))) == NULL)
d918 1
a918 1
    if ((fbuf = (FILE **)calloc((unsigned)clcnt, sizeof(FILE *))) == NULL)
d924 1
a924 1
    if ((rc = (int *)calloc((unsigned)clcnt, sizeof(int))) == NULL)
@


1.34
log
@- get the spacing right for -e, -i, -n, and -s
- macro cleanup

ok millert sobrado
@
text
@d1 1
a1 1
/*	$OpenBSD: pr.c,v 1.33 2013/11/26 13:19:07 deraadt Exp $	*/
d1792 1
a1792 1
	    ++skipping;
d1801 1
a1801 1
		++cflag;
d1804 1
a1804 1
	    ++across;
d1807 1
a1807 1
	    ++dspace;
d1810 1
a1810 1
	    ++eflag;
d1831 1
a1831 1
	    ++formfeed;
d1837 1
a1837 1
	    ++iflag;
d1864 1
a1864 1
	    ++merge;
d1891 1
a1891 1
	    ++nodiag;
d1894 1
a1894 1
	    ++sflag;
d1906 1
a1906 1
	    ++nohead;
d1909 1
a1909 1
	    ++wflag;
d1987 1
a1987 1
	++nohead;    
@


1.33
log
@unsigned char casts for ctype
ok krw
@
text
@d1 1
a1 1
/*	$OpenBSD: pr.c,v 1.32 2013/08/22 04:43:40 guenther Exp $	*/
d1760 1
a1760 1
     "usage: pr [+page] [-column] [-adFfmrt] [-e [char] [gap]] [-h header]\n");
d1762 1
a1762 1
     "\t[-i [char] [gap]] [-l lines] [-n [char] [width]] [-o offset]\n");
d1764 1
a1764 1
     "\t[-s [char]] [-w width] [-] [file ...]\n");
@


1.32
log
@Correct format string mismatches turned up by -Wformat=2

suggestions and ok millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pr.c,v 1.31 2013/04/18 02:28:48 deraadt Exp $	*/
d1811 1
a1811 1
	    if ((eoptarg != NULL) && !isdigit(*eoptarg))
d1815 1
a1815 1
	    if ((eoptarg != NULL) && isdigit(*eoptarg)) {
d1838 1
a1838 1
	    if ((eoptarg != NULL) && !isdigit(*eoptarg))
d1842 1
a1842 1
	    if ((eoptarg != NULL) && isdigit(*eoptarg)) {
d1867 1
a1867 1
	    if ((eoptarg != NULL) && !isdigit(*eoptarg))
d1871 1
a1871 1
	    if ((eoptarg != NULL) && isdigit(*eoptarg)) {
@


1.31
log
@struct timezone is so 1980
@
text
@d1 1
a1 1
/*	$OpenBSD: pr.c,v 1.30 2010/08/25 18:20:11 chl Exp $	*/
d847 1
d865 2
d868 1
a868 1
		fprintf(stderr, fmt, ap);
@


1.30
log
@fix potential use of uninitialized variable.

reported by gcc.

ok jasper@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pr.c,v 1.29 2010/08/17 21:37:11 jasper Exp $	*/
a1438 1
    struct timezone tz;
d1459 1
a1459 1
	if (gettimeofday(&tv, &tz) < 0) {
d1483 1
a1483 1
	    if (gettimeofday(&tv, &tz) < 0) {
d1514 1
a1514 1
		if (gettimeofday(&tv, &tz) < 0) {
@


1.29
log
@several fixes from netbsd:
Coverity CID 1660: Plug memory leaks.
Coverity CID 2989: Use the error path to return.
Coverity CID 3212: Don't return, goto out in all cases so that cleanup happens.

ok otto@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pr.c,v 1.28 2009/10/27 23:59:41 deraadt Exp $	*/
d189 1
a189 1
    FILE *inf;
@


1.28
log
@rcsid[] and sccsid[] and copyright[] are essentially unmaintained (and
unmaintainable).  these days, people use source.  these id's do not provide
any benefit, and do hurt the small install media
(the 33,000 line diff is essentially mechanical)
ok with the idea millert, ok dms
@
text
@d1 1
a1 1
/*	$OpenBSD: pr.c,v 1.27 2009/02/07 17:51:22 chl Exp $	*/
d184 1
a184 1
    char *obuf;
d187 1
a187 1
    char *hbuf;
d192 1
d203 2
a204 4
    if ((obuf = malloc((unsigned)LBUF + off)) == NULL) {
	mfail();
	return(1);
    }
d209 2
a210 4
    if ((hbuf = malloc((unsigned)HDBUF + offst)) == NULL) {
	mfail();
	return(1);
    }
d258 1
a258 1
			         return(1);
d267 1
a267 1
				return(1);
d270 1
a270 1
				return(1);
d296 1
a296 1
		    return(1);
d318 15
a332 4
    if (eoptind < argc)
	return(1);
    else
	return(0);
d343 1
a343 1
    char **lstdat;
d347 1
a347 1
    int *indy;
d351 1
a351 1
    int *lindy;
d358 1
a358 1
    struct vcol *vc;
d363 2
a364 2
    char *buf;
    char *hbuf;
d367 1
a367 1
    FILE *inf;
d372 1
d377 2
a378 4
    if ((buf = calloc((unsigned)lines, mxlen)) == NULL) {
	mfail();
	return(1);
    }
d383 2
a384 4
    if ((hbuf = malloc((unsigned)HDBUF + offst)) == NULL) {
	mfail();
	return(1);
    }
d394 2
a395 4
    if ((vc=(struct vcol *)calloc((unsigned)mvc, sizeof(struct vcol))) == NULL) {
	mfail();
	return(1);
    }
d400 2
a401 4
    if ((lstdat = (char **)calloc((unsigned)lines, sizeof(char *))) == NULL){
	mfail();
	return(1);
    }
d406 4
a409 8
    if ((indy = (int *)calloc((unsigned)lines, sizeof(int))) == NULL) {
	mfail();
	return(1);
    }
    if ((lindy = (int *)calloc((unsigned)lines, sizeof(int))) == NULL) {
	mfail();
	return(1);
    }
d541 1
a541 1
		    	return(1);
d556 1
a556 1
				return(1);
d581 1
a581 1
				    return(1);
d590 1
a590 1
				return(1);
d615 1
a615 1
				    return(1);
d625 1
a625 1
		    return(1);
d645 19
a663 4
    if (eoptind < argc)
	return(1);
    else
	return(0);
d682 2
a683 2
    char *buf;
    char *hbuf;
d686 1
a686 1
    FILE *inf;
d691 1
d693 2
a694 4
    if ((buf = malloc((unsigned)pgwd + offst + 1)) == NULL) {
	mfail();
	return(1);
    }
d699 2
a700 4
    if ((hbuf = malloc((unsigned)HDBUF + offst)) == NULL) {
	mfail();
	return(1);
    }
d751 1
a751 1
			        return(1);
d781 1
a781 1
			    return(1);
d809 15
a823 3
    if (eoptind < argc)
	return(1);
    return(0);
d896 1
a896 1
    FILE **fbuf;
d902 2
a903 2
    char *buf;
    char *hbuf;
d910 1
d915 2
a916 4
    if ((fbuf = (FILE **)calloc((unsigned)clcnt, sizeof(FILE *))) == NULL) {
	mfail();
	return(1);
    }
d921 2
a922 4
    if ((rc = (int *)calloc((unsigned)clcnt, sizeof(int))) == NULL) {
	mfail();
	return(1);
    }
d927 3
a929 4
    if ((hbuf = malloc((unsigned)HDBUF + offst)) == NULL) {
	mfail();
	return(1);
    }
d958 1
a958 1
	return(1);
d972 1
a972 1
	return(1);
d979 3
a981 4
    if ((buf = malloc((unsigned)pgwd + offst + 1)) == NULL) {
	mfail();
	return(1);
    }
d1072 1
a1072 1
			return(1);
d1078 1
a1078 1
			return(1);
d1099 20
a1118 3
    if (eoptind < argc)
	return(1);
    return(0);
@


1.27
log
@malloc(n * m) -> calloc(n, m);

ok ray@@ moritz@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pr.c,v 1.26 2008/04/18 20:18:21 tobias Exp $	*/
a34 11

#ifndef lint
static char copyright[] =
"@@(#) Copyright (c) 1993\n\
	The Regents of the University of California.  All rights reserved.\n";
#endif /* not lint */

#ifndef lint
/* from: static char sccsid[] = "@@(#)pr.c	8.1 (Berkeley) 6/6/93"; */
static char *rcsid = "$OpenBSD: pr.c,v 1.26 2008/04/18 20:18:21 tobias Exp $";
#endif /* not lint */
@


1.26
log
@If memory allocation fails during error message buffering, print all hold
back messages and exit.

ok millert
@
text
@d1 1
a1 1
/*	$OpenBSD: pr.c,v 1.25 2007/09/03 12:36:09 moritz Exp $	*/
d44 1
a44 1
static char *rcsid = "$OpenBSD: pr.c,v 1.25 2007/09/03 12:36:09 moritz Exp $";
d379 1
a379 1
    if ((buf = malloc((unsigned)lines*mxlen)) == NULL) {
@


1.25
log
@last commit broke the tree because of missing parentheses.

ok henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pr.c,v 1.24 2007/09/03 05:40:00 deraadt Exp $	*/
d44 1
a44 1
static char *rcsid = "$OpenBSD: pr.c,v 1.24 2007/09/03 05:40:00 deraadt Exp $";
d853 7
a859 2
        vasprintf(&p, fmt, ap);
	f = (struct ferrlist *)malloc(sizeof(*f));
@


1.24
log
@sizeof char is 1; ok djm
@
text
@d1 1
a1 1
/*	$OpenBSD: pr.c,v 1.23 2007/03/03 23:16:02 jmc Exp $	*/
d44 1
a44 1
static char *rcsid = "$OpenBSD: pr.c,v 1.23 2007/03/03 23:16:02 jmc Exp $";
d379 1
a379 1
    if ((buf = malloc(unsigned)lines*mxlen)) == NULL) {
@


1.23
log
@- make synopsis and usage() match the order of the options list
- kill a raft of unneeded .Bk/.Ek

mostly from Igor Sobrado
@
text
@d1 1
a1 1
/*	$OpenBSD: pr.c,v 1.22 2007/02/20 16:55:37 moritz Exp $	*/
d44 1
a44 1
static char *rcsid = "$OpenBSD: pr.c,v 1.22 2007/02/20 16:55:37 moritz Exp $";
d213 1
a213 1
    if ((obuf = malloc((unsigned)(LBUF + off)*sizeof(char))) == NULL) {
d221 1
a221 1
    if ((hbuf = malloc((unsigned)(HDBUF + offst)*sizeof(char))) == NULL) {
d379 1
a379 1
    if ((buf = malloc((unsigned)lines*mxlen*sizeof(char))) == NULL) {
d387 1
a387 1
    if ((hbuf = malloc((unsigned)(HDBUF + offst)*sizeof(char))) == NULL) {
d400 1
a400 1
    if ((vc=(struct vcol *)malloc((unsigned)mvc*sizeof(struct vcol))) == NULL) {
d408 1
a408 1
    if ((lstdat = (char **)malloc((unsigned)lines*sizeof(char *))) == NULL){
d416 1
a416 1
    if ((indy = (int *)malloc((unsigned)lines*sizeof(int))) == NULL) {
d420 1
a420 1
    if ((lindy = (int *)malloc((unsigned)lines*sizeof(int))) == NULL) {
d691 1
a691 1
    if ((buf = malloc((unsigned)(pgwd+offst+1)*sizeof(char))) == NULL) {
d699 1
a699 1
    if ((hbuf = malloc((unsigned)(HDBUF + offst)*sizeof(char))) == NULL) {
d899 1
a899 1
    if ((fbuf = (FILE **)malloc((unsigned)clcnt*sizeof(FILE *))) == NULL) {
d907 1
a907 1
    if ((rc = (int *)malloc((unsigned)clcnt*sizeof(int))) == NULL) {
d915 1
a915 1
    if ((hbuf = malloc((unsigned)(HDBUF + offst)*sizeof(char))) == NULL) {
d968 1
a968 1
    if ((buf = malloc((unsigned)(pgwd+offst+1)*sizeof(char))) == NULL) {
@


1.22
log
@Some cleanup including:

- use sig_atomic_t signal handler flag
- atoi() -> strtonum() conversion
- remove vararg without matching fmt string
- some more lint/gcc silencing

ok millert@@ ray@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pr.c,v 1.21 2004/06/21 15:27:19 avsm Exp $	*/
d44 1
a44 1
static char *rcsid = "$OpenBSD: pr.c,v 1.21 2004/06/21 15:27:19 avsm Exp $";
d1731 1
a1731 1
     "usage: pr [+page] [-col] [-adfFmrt] [-e[ch][gap]] [-h header]\n");
d1733 1
a1733 1
     "          [-i[ch][gap]] [-l line] [-n[ch][width]] [-o offset]\n");
d1735 1
a1735 1
     "          [-s[ch]] [-w width] [-] [file ...]\n");
@


1.21
log
@dont compare int with NULL, compare to 0 instead, otto@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: pr.c,v 1.20 2003/11/09 20:13:57 otto Exp $	*/
d44 1
a44 1
static char *rcsid = "$OpenBSD: pr.c,v 1.20 2003/11/09 20:13:57 otto Exp $";
d53 1
d143 1
a143 1
int	ferr;		/* error message delayed */
d1148 1
a1148 1
	    if (ch == '\n' || inform && ch == INFF)
d1157 1
a1157 1
	    if (ch == '\n' || inform && ch == INFF)
d1351 1
a1351 1
	if (cnt && (fwrite(buf, sizeof(char), cnt, stdout) <= 0)) {
d1515 1
a1515 1
    if (strftime(buf, HDBUF, timefrmt, timeptr) <= 0) {
d1707 1
d1735 1
a1735 1
     "          [-s[ch]] [-w width] [-] [file ...]\n", ferr);
d1750 1
d1758 3
a1760 2
	    if ((pgnm = atoi(eoptarg)) < 1) {
		ferrout("pr: +page number must be 1 or more\n");
d1766 3
a1768 2
	    if ((clcnt = atoi(eoptarg)) < 1) {
		ferrout("pr: -columns must be 1 or more\n");
d1787 3
a1789 2
		if ((ingap = atoi(eoptarg)) < 0) {
		    ferrout("pr: -e gap must be 0 or more\n");
d1814 3
a1816 2
		if ((ogap = atoi(eoptarg)) < 0) {
		    ferrout("pr: -i gap must be 0 or more\n");
d1828 3
a1830 2
	    if (!isdigit(*eoptarg) || ((lines=atoi(eoptarg)) < 1)) {
		ferrout("pr: Number of lines must be 1 or more\n");
d1843 3
a1845 2
		if ((nmwd = atoi(eoptarg)) < 1) {
		    ferrout("pr: -n width must be 1 or more\n");
d1855 3
a1857 2
	    if (!isdigit(*eoptarg) || ((offst = atoi(eoptarg))< 1)){
		ferrout("pr: -o offset must be 1 or more\n");
d1881 3
a1883 2
	    if (!isdigit(*eoptarg) || ((pgwd = atoi(eoptarg)) < 1)){
		ferrout("pr: -w width must be 1 or more \n");
a1886 1
	case '?':
@


1.20
log
@Typos in comments from Jared Yanovich <jjy2+ at pitt dot edu>
@
text
@d1 1
a1 1
/*	$OpenBSD: pr.c,v 1.19 2003/08/04 17:06:45 deraadt Exp $	*/
d44 1
a44 1
static char *rcsid = "$OpenBSD: pr.c,v 1.19 2003/08/04 17:06:45 deraadt Exp $";
d845 1
a845 1
    if (ferr == NULL)
@


1.19
log
@protos
@
text
@d1 1
a1 1
/*	$OpenBSD: pr.c,v 1.18 2003/06/12 20:58:10 deraadt Exp $	*/
d44 1
a44 1
static char *rcsid = "$OpenBSD: pr.c,v 1.18 2003/06/12 20:58:10 deraadt Exp $";
d79 1
a79 1
 * bugs were noted and fixed in the processs.  Some implementations have this
d83 1
a83 1
 * a bit ideosyncratic.  Basically they are treated as temporary end-of-file
d89 1
a89 1
 * The orginal "efficient" implementation of the "skip to page N" option was
d92 1
a92 1
 * restarting at one, but at least lets you consistantly reprint some large
d924 1
a924 1
     * of the merge operation (-m) in relation to unsuccesful file opens
d949 1
a949 1
     * calculate page boundries based on open file count
d1102 1
a1102 1
 *    cps:    column positon 1st char in buffer (large line support)
d1567 1
a1567 1
 * prhead() at least once for a file and incremented pagecnt..  Exactly
d1615 1
a1615 1
 * we haven't printed a hearder, these no need for a trailer
@


1.18
log
@de-register and ansification; millert ok
@
text
@d1 1
a1 1
/*	$OpenBSD: pr.c,v 1.17 2003/06/10 22:20:49 deraadt Exp $	*/
d44 1
a44 1
static char *rcsid = "$OpenBSD: pr.c,v 1.17 2003/06/10 22:20:49 deraadt Exp $";
d836 1
a836 1
void
@


1.17
log
@mostly ansi cleanup; pval ok
@
text
@d1 1
a1 1
/*	$OpenBSD: pr.c,v 1.16 2003/06/03 02:56:14 millert Exp $	*/
d44 1
a44 1
static char *rcsid = "$OpenBSD: pr.c,v 1.16 2003/06/03 02:56:14 millert Exp $";
d181 1
a181 3
onecol(argc, argv)
    int argc;
    char *argv[];
d342 1
a342 3
vertcol(argc, argv)
	int argc;
	char *argv[];
d668 1
a668 3
horzcol(argc, argv)
	int argc;
	char *argv[];
d826 1
a826 1
flsh_errs()
d871 1
a871 3
mulfile(argc, argv)
    int argc;
    char *argv[];
d1107 1
a1107 8
inln(inf, buf, lim, cnt, cps, trnc, mor)
    FILE *inf;
    char *buf;
    int lim;
    int *cnt;
    int *cps;
    int trnc;
    int *mor;
d1221 1
a1221 6
otln(buf, cnt, svips, svops, mor)
    char *buf;
    int cnt;
    int *svops;
    int *svips;
    int mor;
d1378 1
a1378 4
inskip(inf, pgcnt, lncnt)
    FILE *inf;
    int pgcnt;
    int lncnt;
d1407 1
a1407 6
nxtfile(argc, argv, fname, buf, dt)
    int argc;
    char **argv;
    char **fname;
    char *buf;
    int dt;
d1540 1
a1540 4
addnum(buf, wdth, line)
    char *buf;
    int wdth;
    int line;
d1572 1
a1572 4
prhead(buf, fname, pagcnt)
    char *buf;
    char *fname;
    int pagcnt;
d1618 1
a1618 3
prtail(cnt, incomp)
    int cnt;
    int incomp;
d1707 1
a1707 2
terminate(which_sig)
    int which_sig;
d1714 1
a1714 1
mfail()
d1720 1
a1720 1
pfail()
d1726 1
a1726 1
usage()
d1741 1
a1741 3
setup(argc, argv)
    int argc;
    char **argv;
@


1.16
log
@Remove the advertising clause in the UCB license which Berkeley
rescinded 22 July 1999.  Proofed by myself and Theo.
@
text
@d1 1
a1 1
/*	$OpenBSD: pr.c,v 1.15 2002/04/30 01:59:47 deraadt Exp $	*/
d44 1
a44 1
static char *rcsid = "$OpenBSD: pr.c,v 1.15 2002/04/30 01:59:47 deraadt Exp $";
d149 1
a149 3
main(argc, argv)
	int argc;
	char *argv[];
@


1.15
log
@arguement -> argument
@
text
@d1 1
a1 1
/*	$OpenBSD: pr.c,v 1.14 2001/11/29 18:21:23 mpech Exp $	*/
d19 1
a19 5
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
d44 1
a44 1
static char *rcsid = "$OpenBSD: pr.c,v 1.14 2001/11/29 18:21:23 mpech Exp $";
@


1.14
log
@make sure that va_start() has matching va_end()

millert@@ help&ok
@
text
@d1 1
a1 1
/*	$OpenBSD: pr.c,v 1.13 2001/11/19 19:02:15 mpech Exp $	*/
d48 1
a48 1
static char *rcsid = "$OpenBSD: pr.c,v 1.13 2001/11/19 19:02:15 mpech Exp $";
d1635 1
a1635 1
     * changing HDFMT to allow a length max as an arguement printf.
@


1.13
log
@kill more registers

millert@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: pr.c,v 1.12 2001/11/19 03:37:33 deraadt Exp $	*/
d48 1
a48 1
static char *rcsid = "$OpenBSD: pr.c,v 1.12 2001/11/19 03:37:33 deraadt Exp $";
d875 1
@


1.12
log
@guess what!  more signal race fixes...
@
text
@d1 1
a1 1
/*	$OpenBSD: pr.c,v 1.11 2001/11/02 16:25:02 deraadt Exp $	*/
d48 1
a48 1
static char *rcsid = "$OpenBSD: pr.c,v 1.11 2001/11/02 16:25:02 deraadt Exp $";
d191 4
a194 4
    register int off;
    register int lrgln;
    register int linecnt;
    register int num;
d354 6
a359 6
    register char *ptbf;
    register char **lstdat;
    register int i;
    register int j;
    register int pln;
    register int *indy;
d682 6
a687 6
    register char *ptbf;
    register int pln;
    register char *lstdat;
    register int col = colwd + 1;
    register int j;
    register int i;
d886 3
a888 3
    register char *ptbf;
    register int j;
    register int pln;
d891 2
a892 2
    register char *lstdat;
    register int i;
d1123 1
a1123 1
    register int lim;
d1129 5
a1133 5
    register int col;
    register int gap = ingap;
    register int ch = -1;
    register char *ptbuf;
    register int chk = (int)inchar;
d1242 1
a1242 1
    register char *buf;
d1248 5
a1252 5
    register int ops;        /* last col output */
    register int ips;        /* last col in buf examined */
    register int gap = ogap;
    register int tbps;
    register char *endbuf;
d1405 2
a1406 2
    register int pgcnt;
    register int lncnt;
d1408 2
a1409 2
    register int c;
    register int cnt;
d1574 3
a1576 3
    register char *buf;
    register int wdth;
    register int line;
d1578 1
a1578 1
    register char *pt = buf + wdth;
d1658 1
a1658 1
    register int cnt;
d1784 2
a1785 2
    register int argc;
    register char **argv;
d1787 1
a1787 1
    register int c;
@


1.11
log
@use _exit() in signal handler
@
text
@d1 1
a1 1
/*	$OpenBSD: pr.c,v 1.10 2001/05/24 02:58:50 pvalchev Exp $	*/
d48 1
a48 1
static char *rcsid = "$OpenBSD: pr.c,v 1.10 2001/05/24 02:58:50 pvalchev Exp $";
d59 1
d86 1
a86 1
 * The impelmentation of form feeds on top of the existing I/O structure is
d146 1
a146 1
FILE	*ferr;		/* error message file pointer */
d827 50
d972 1
a972 2
	(void)fprintf(ferr,
	  "pr: page width too small for %d columns\n", clcnt);
d1467 1
a1467 1
	    (void)fprintf(ferr, "pr: cannot get time of day, %s\n",
d1491 1
a1491 2
		(void)fprintf(ferr,
		    "pr: cannot get time of day, %s\n",
d1505 1
a1505 1
		(void)fprintf(ferr, "pr: Cannot open %s, %s\n",
d1522 1
a1522 2
		    (void)fprintf(ferr,
			 "pr: cannot get time of day, %s\n",
d1532 1
a1532 2
		    (void)fprintf(ferr, 
			"pr: Cannot stat %s, %s\n",
d1551 1
a1551 1
	(void)fputs("pr: time conversion failed\n", ferr);
d1751 1
a1751 1
    flsh_errs();	/* XXX signal race */
a1754 19

/*
 * flsh_errs():    output saved up diagnostic messages after all normal
 *        processing has completed
 */
void
flsh_errs()
{
    char buf[BUFSIZ];

    (void)fflush(stdout);
    (void)fflush(ferr);
    if (ferr == stderr)
	return;
    rewind(ferr);
    while (fgets(buf, BUFSIZ, ferr) != NULL)
	(void)fputs(buf, stderr);
}

d1758 1
a1758 1
    (void)fputs("pr: memory allocation failed\n", ferr);
d1764 1
a1764 1
    (void)fprintf(ferr, "pr: write failure, %s\n", strerror(errno));
d1770 5
a1774 5
    (void)fputs(
     "usage: pr [+page] [-col] [-adfFmrt] [-e[ch][gap]] [-h header]\n", ferr);
    (void)fputs(
     "          [-i[ch][gap]] [-l line] [-n[ch][width]] [-o offset]\n", ferr);
    (void)fputs(
d1793 3
a1795 10
    if (isatty(fileno(stdout))) {
	/*
	 * defer diagnostics until processing is done
	 */
	if ((ferr = tmpfile()) == NULL) {
	       (void)fputs("Cannot defer diagnostic messages\n",stderr);
	       return(1);
	}
    } else
	ferr = stderr;
d1800 1
a1800 2
		(void)fputs("pr: +page number must be 1 or more\n",
		    ferr);
d1807 1
a1807 1
		(void)fputs("pr: -columns must be 1 or more\n",ferr);
d1827 1
a1827 2
		    (void)fputs(
		    "pr: -e gap must be 0 or more\n", ferr);
d1833 1
a1833 2
		(void)fprintf(ferr,
		      "pr: invalid value for -e %s\n", eoptarg);
d1853 1
a1853 2
		    (void)fputs(
		    "pr: -i gap must be 0 or more\n", ferr);
d1859 1
a1859 2
		(void)fprintf(ferr,
		      "pr: invalid value for -i %s\n", eoptarg);
d1866 1
a1866 2
		(void)fputs(
		 "pr: Number of lines must be 1 or more\n",ferr);
d1880 1
a1880 2
		    (void)fputs(
		    "pr: -n width must be 1 or more\n",ferr);
d1884 1
a1884 2
		(void)fprintf(ferr,
		      "pr: invalid value for -n %s\n", eoptarg);
d1891 1
a1891 2
		(void)fputs("pr: -o offset must be 1 or more\n",
		    ferr);
d1905 1
a1905 2
		    (void)fprintf(ferr,
		        "pr: invalid value for -s %s\n", eoptarg);
d1916 1
a1916 2
		(void)fputs(
		   "pr: -w width must be 1 or more \n",ferr);
d1944 1
a1944 2
	    (void)fputs("pr: -a flag requires multiple columns\n",
		ferr);
d1948 1
a1948 1
	    (void)fputs("pr: -m cannot be used with -a\n", ferr);
d1970 1
a1970 2
	    (void)fputs(
	      "pr: -m cannot be used with multiple columns\n", ferr);
d1981 1
a1981 2
	    (void)fprintf(ferr,
	      "pr: page width is too small for %d columns\n",clcnt);
@


1.10
log
@Don't convert a single space before a tab stop into a tab when the -i
option is passed, as stated in the manual page.
From NetBSD PR 5797 fix.
millert@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: pr.c,v 1.9 2001/02/05 01:57:12 deraadt Exp $	*/
d48 1
a48 1
static char *rcsid = "$OpenBSD: pr.c,v 1.9 2001/02/05 01:57:12 deraadt Exp $";
d1704 2
a1705 2
    flsh_errs();
    exit(1);
@


1.9
log
@please binutils in the absence of perfect weak symbols
@
text
@d1 1
a1 1
/*	$OpenBSD: pr.c,v 1.8 2000/11/10 15:33:12 provos Exp $	*/
d48 1
a48 1
static char *rcsid = "$OpenBSD: pr.c,v 1.8 2000/11/10 15:33:12 provos Exp $";
d1239 7
d1291 7
d1308 1
@


1.8
log
@seperate -> separate, okay aaron@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pr.c,v 1.7 1999/12/03 23:43:02 deraadt Exp $	*/
d48 1
a48 1
static char *rcsid = "$OpenBSD: pr.c,v 1.7 1999/12/03 23:43:02 deraadt Exp $";
d145 1
a145 1
FILE	*err;		/* error message file pointer */
d921 1
a921 1
	(void)fprintf(err,
d1402 1
a1402 1
	    (void)fprintf(err, "pr: cannot get time of day, %s\n",
d1426 1
a1426 1
		(void)fprintf(err,
d1441 1
a1441 1
		(void)fprintf(err, "pr: Cannot open %s, %s\n",
d1458 1
a1458 1
		    (void)fprintf(err,
d1469 1
a1469 1
		    (void)fprintf(err, 
d1489 1
a1489 1
	(void)fputs("pr: time conversion failed\n", err);
d1704 2
a1705 2
    (void)fflush(err);
    if (err == stderr)
d1707 2
a1708 2
    rewind(err);
    while (fgets(buf, BUFSIZ, err) != NULL)
d1715 1
a1715 1
    (void)fputs("pr: memory allocation failed\n", err);
d1721 1
a1721 1
    (void)fprintf(err, "pr: write failure, %s\n", strerror(errno));
d1728 1
a1728 1
     "usage: pr [+page] [-col] [-adfFmrt] [-e[ch][gap]] [-h header]\n",err);
d1730 1
a1730 1
     "          [-i[ch][gap]] [-l line] [-n[ch][width]] [-o offset]\n",err);
d1732 1
a1732 1
     "          [-s[ch]] [-w width] [-] [file ...]\n", err);
d1754 1
a1754 1
	if ((err = tmpfile()) == NULL) {
d1759 1
a1759 1
	err = stderr;
d1765 1
a1765 1
		err);
d1772 1
a1772 1
		(void)fputs("pr: -columns must be 1 or more\n",err);
d1793 1
a1793 1
		    "pr: -e gap must be 0 or more\n", err);
d1799 1
a1799 1
		(void)fprintf(err,
d1821 1
a1821 1
		    "pr: -i gap must be 0 or more\n", err);
d1827 1
a1827 1
		(void)fprintf(err,
d1836 1
a1836 1
		 "pr: Number of lines must be 1 or more\n",err);
d1851 1
a1851 1
		    "pr: -n width must be 1 or more\n",err);
d1855 1
a1855 1
		(void)fprintf(err,
d1864 1
a1864 1
		    err);
d1878 1
a1878 1
		    (void)fprintf(err,
d1891 1
a1891 1
		   "pr: -w width must be 1 or more \n",err);
d1920 1
a1920 1
		err);
d1924 1
a1924 1
	    (void)fputs("pr: -m cannot be used with -a\n", err);
d1947 1
a1947 1
	      "pr: -m cannot be used with multiple columns\n", err);
d1958 1
a1958 1
	    (void)fprintf(err,
@


1.7
log
@the -s option was broken; spotted by tstromberg@@rtci.com on freebsd-audit, but i have not seen them fix any of the bugs
@
text
@d1 1
a1 1
/*	$OpenBSD: pr.c,v 1.6 1999/05/23 17:37:41 millert Exp $	*/
d48 1
a48 1
static char *rcsid = "$OpenBSD: pr.c,v 1.6 1999/05/23 17:37:41 millert Exp $";
d69 1
a69 1
 *	output. By default, input is seperated into 66-line pages, each
@


1.6
log
@make private version of getopt() return -1, not EOF
@
text
@d1 1
a1 1
/*	$OpenBSD: pr.c,v 1.5 1997/04/23 08:08:28 grr Exp $	*/
d48 1
a48 1
static char *rcsid = "$OpenBSD: pr.c,v 1.5 1997/04/23 08:08:28 grr Exp $";
d1875 1
a1875 1
	    else
d1877 5
a1881 4
	    if (*eoptarg != '\0') {
		(void)fprintf(err,
		      "pr: invalid value for -s %s\n", eoptarg);
		return(1);
@


1.5
log
@revised to handle form feeds, bugs fixed etc
@
text
@d1 1
a1 1
/*	$OpenBSD: pr.c,v 1.2 1996/06/26 05:37:54 deraadt Exp $	*/
d48 1
a48 1
static char *rcsid = "$OpenBSD: pr.c,v 1.2 1996/06/26 05:37:54 deraadt Exp $";
d1081 1
a1081 1
    register int ch = EOF;
d1760 1
a1760 1
    while ((c = egetopt(argc, argv, "#adfFmrte?h:i?l:n?o:s?w:")) != EOF) {
@


1.4
log
@getopt(3) returns -1 when out of args, not EOF, whee!
@
text
@d1 1
a1 1
/*	$OpenBSD: pr.c,v 1.3 1996/08/10 04:41:00 imp Exp $	*/
d48 1
a48 1
static char *rcsid = "$OpenBSD: pr.c,v 1.3 1996/08/10 04:41:00 imp Exp $";
d77 38
d117 24
a140 22
int	pgnm;			/* starting page number */
int	clcnt;			/* number of columns */
int	colwd;			/* column data width - multiple columns */
int	across;			/* mult col flag; write across page */
int	dspace;			/* double space flag */
char	inchar;			/* expand input char */
int	ingap;			/* expand input gap */
int	formfeed;		/* use formfeed as trailer */
char	*header;		/* header name instead of file name */
char	ochar;			/* contract output char */
int	ogap;			/* contract output gap */
int	lines;			/* number of lines per page */
int	merge;			/* merge multiple files in output */
char	nmchar;			/* line numbering append char */
int	nmwd;			/* width of line number field */
int	offst;			/* number of page offset spaces */
int	nodiag;			/* do not report file open errors */
char	schar;			/* text column separation character */
int	sflag;			/* -s option for multiple columns */
int	nohead;			/* do not write head and trailer */
int	pgwd;			/* page width with multiple col output */
char	*timefrmt;		/* time conversion string */
d145 4
a148 3
FILE	*err;			/* error message file pointer */
int	addone;			/* page length is odd with double space */
int	errcnt;			/* error count on file processing */
d153 2
a154 2
        int argc;
        char *argv[];
d156 1
a156 1
	int ret_val;
d158 21
a178 21
	if (signal(SIGINT, SIG_IGN) != SIG_IGN)
		(void)signal(SIGINT, terminate);
	ret_val = setup(argc, argv);
	if (!ret_val) {
		/*
		 * select the output format based on options
		 */
		if (merge)
			ret_val = mulfile(argc, argv);
		else if (clcnt == 1)
			ret_val = onecol(argc, argv);
		else if (across)
			ret_val = horzcol(argc, argv);
		else
			ret_val = vertcol(argc, argv);
	} else
		usage();
	flsh_errs();
	if (errcnt || ret_val)
		exit(1);
	return(0);
d182 2
a183 2
 * onecol:	print files with only one column of output.
 *		Line length is unlimited.
d187 2
a188 2
        int argc;
        char *argv[];
d190 60
a249 24
	register int cnt = -1;
	register int off;
	register int lrgln;
	register int linecnt;
	register int num;
	int lncnt;
	int pagecnt;
	int ips;
	int ops;
	int cps;
	char *obuf;
	char *lbuf;
	char *nbuf;
	char *hbuf;
	char *ohbuf;
	FILE *inf;
	char *fname;
	int mor;

	if (nmwd)
		num = nmwd + 1;
	else
		num = 0;
	off = num + offst;
d252 1
a252 1
	 * allocate line buffer
d254 1
a254 11
	if ((obuf = malloc((unsigned)(LBUF + off)*sizeof(char))) == NULL) {
		mfail();
		return(1);
	}
	/*
	 * allocate header buffer
	 */
	if ((hbuf = malloc((unsigned)(HDBUF + offst)*sizeof(char))) == NULL) {
		mfail();
		return(1);
	}
d256 9
a264 24
	ohbuf = hbuf + offst;
	nbuf = obuf + offst;
	lbuf = nbuf + num;
	if (num)
		nbuf[--num] = nmchar;
	if (offst) {
		(void)memset(obuf, (int)' ', offst);
		(void)memset(hbuf, (int)' ', offst);
	}

	/*
	 * loop by file
	 */
	while ((inf = nxtfile(argc, argv, &fname, ohbuf, 0)) != NULL) {
		if (pgnm) {
			/*
			 * skip to specified page
			 */
			if (inskip(inf, pgnm, lines))
				continue;
			pagecnt = pgnm;
		} else
			pagecnt = 1;
		lncnt = 0;
d267 1
a267 1
		 * loop by page
d269 22
a290 6
		for(;;) {
			linecnt = 0;
			lrgln = 0;
			ops = 0;
			ips = 0;
			cps = 0;
d293 1
a293 1
			 * loop by line
d295 12
a306 9
			while (linecnt < lines) {
				/*
				 * input next line
				 */
				if ((cnt = inln(inf,lbuf,LBUF,&cps,0,&mor)) < 0)
					break;
				if (!linecnt && !nohead &&
					prhead(hbuf, fname, pagecnt))
					return(1);
d308 3
a310 10
				/*
				 * start of new line.
				 */
				if (!lrgln) {
					if (num)
						addnum(nbuf, num, ++lncnt);
					if (otln(obuf,cnt+off, &ips, &ops, mor))
						return(1);
				} else if (otln(lbuf, cnt, &ips, &ops, mor))
					return(1);
d312 5
a316 7
				/*
				 * if line bigger than buffer, get more
				 */
				if (mor) {
					lrgln = 1;
					continue;
				}
d318 23
a340 27
				/*
				 * whole line rcvd. reset tab proc. state
				 */
				++linecnt;
				lrgln = 0;
				ops = 0;
				ips = 0;
			}

			/*
			 * fill to end of page
			 */
			if (linecnt && prtail(lines-linecnt-lrgln, lrgln))
				return(1);

			/*
			 * On EOF go to next file
			 */
			if (cnt < 0)
				break;
			++pagecnt;
		}
		if (inf != stdin)
			(void)fclose(inf);
	}
	if (eoptind < argc)
		return(1);
d346 1
d350 2
a351 2
        int argc;
        char *argv[];
d353 106
a458 37
	register char *ptbf;
	register char **lstdat;
	register int i;
	register int j;
	register int cnt = -1;
	register int pln;
	register int *indy;
	int cvc;
	int *lindy;
	int lncnt;
	int stp;
	int pagecnt;
	int col = colwd + 1;
	int mxlen = pgwd + offst + 1;
	int mclcnt = clcnt - 1;
	struct vcol *vc;
	int mvc;
	int tvc;
	int cw = nmwd + 1;
	int fullcol;
	char *buf;
	char *hbuf;
	char *ohbuf;
	char *fname;
	FILE *inf;
	int ips = 0;
	int cps = 0;
	int ops = 0;
	int mor = 0;

	/*
	 * allocate page buffer
	 */
	if ((buf = malloc((unsigned)lines*mxlen*sizeof(char))) == NULL) {
		mfail();
		return(1);
	}
d461 1
a461 1
	 * allocate page header
d463 1
a463 7
	if ((hbuf = malloc((unsigned)(HDBUF + offst)*sizeof(char))) == NULL) {
		mfail();
		return(1);
	}
	ohbuf = hbuf + offst;
	if (offst)
		(void)memset(hbuf, (int)' ', offst);
d465 4
a468 9
	/*
	 * col pointers when no headers
	 */
	mvc = lines * clcnt;
	if ((vc =
	    (struct vcol *)malloc((unsigned)mvc*sizeof(struct vcol))) == NULL) {
		mfail();
		return(1);
	}
d470 27
a496 7
	/*
	 * pointer into page where last data per line is located
	 */
	if ((lstdat = (char **)malloc((unsigned)lines*sizeof(char *))) == NULL){
		mfail();
		return(1);
	}
a497 37
	/*
	 * fast index lookups to locate start of lines
	 */
	if ((indy = (int *)malloc((unsigned)lines*sizeof(int))) == NULL) {
		mfail();
		return(1);
	}
	if ((lindy = (int *)malloc((unsigned)lines*sizeof(int))) == NULL) {
		mfail();
		return(1);
	}

	if (nmwd)
		fullcol = col + cw;
	else
		fullcol = col;

	/*
	 * initialize buffer lookup indexes and offset area
	 */
	for (j = 0; j < lines; ++j) {
		lindy[j] = j * mxlen;
		indy[j] = lindy[j] + offst;
		if (offst) {
			ptbf = buf + lindy[j];
			(void)memset(ptbf, (int)' ', offst);
			ptbf += offst;
		} else
			ptbf = buf + indy[j];
		lstdat[j] = ptbf;
	}

	/*
	 * loop by file
	 */
	while ((inf = nxtfile(argc, argv, &fname, ohbuf, 0)) != NULL) {
		if (pgnm) {
d499 1
a499 1
			 * skip to requested page
d501 5
a505 6
			if (inskip(inf, pgnm, lines))
				continue;
			pagecnt = pgnm;
		} else
			pagecnt = 1;
		lncnt = 0;
a506 4
		/*
		 * loop by page
		 */
		for(;;) {
d508 1
a508 1
			 * loop by column
d510 9
a518 3
			cvc = 0;
			for (i = 0; i < clcnt; ++i) {
				j = 0;
d520 1
a520 1
				 * if last column, do not pad
d522 6
a527 57
				if (i == mclcnt)
					stp = 1;
				else
					stp = 0;
				/*
				 * loop by line
				 */
				for(;;) {
					/*
					 * is this first column
					 */
					if (!i) {
						ptbf = buf + indy[j];
						lstdat[j] = ptbf;
					} else 
						ptbf = lstdat[j];
					vc[cvc].pt = ptbf;

					/*
					 * add number
					 */
					if (nmwd) {
						addnum(ptbf, nmwd, ++lncnt);
						ptbf += nmwd;
						*ptbf++ = nmchar;
					}

					/*
					 * input next line
					 */
					cnt = inln(inf,ptbf,colwd,&cps,1,&mor);
					vc[cvc++].cnt = cnt;
					if (cnt < 0)
						break;
					ptbf += cnt;

					/*
					 * pad all but last column on page
					 */
					if (!stp) {
						/*
						 * pad to end of column
						 */
						if (sflag)
							*ptbf++ = schar;
						else if ((pln = col-cnt) > 0) {
							(void)memset(ptbf,
								(int)' ',pln);
							ptbf += pln;
						}
					}
					/*
					 * remember last char in line
					 */
					lstdat[j] = ptbf;
					if (++j >= lines)
						break;
d529 28
a556 3
				if (cnt < 0)
					break;
			}
d558 15
a572 13
			/*
			 * when -t (no header) is specified the spec requires
			 * the min number of lines. The last page may not have
			 * balanced length columns. To fix this we must reorder
			 * the columns. This is a very slow technique so it is
			 * only used under limited conditions. Without -t, the
			 * balancing of text columns is unspecified. To NOT
			 * balance the last page, add the global variable
			 * nohead to the if statement below e.g.
			 *
			 * if ((cnt < 0) && nohead && cvc ......
			 */
			--cvc;
d574 6
a579 7
			/*
			 * check to see if last page needs to be reordered
			 */
			if ((cnt < 0) && cvc && ((mvc-cvc) >= clcnt)){
				pln = cvc/clcnt;
				if (cvc % clcnt)
					++pln;
d581 1
d583 1
a583 1
				 * print header
d585 28
a612 51
				if (!nohead && prhead(hbuf, fname, pagecnt))
					return(1);
				for (i = 0; i < pln; ++i) {
					ips = 0;
					ops = 0;
					if (offst&& otln(buf,offst,&ips,&ops,1))
						return(1);
					tvc = i;

					for (j = 0; j < clcnt; ++j) {
						/*
						 * determine column length
						 */
						if (j == mclcnt) {
							/*
							 * last column
							 */
							cnt = vc[tvc].cnt;
							if (nmwd)
								cnt += cw;
						} else if (sflag) {
							/*
							 * single ch between
							 */
							cnt = vc[tvc].cnt + 1;
							if (nmwd)
								cnt += cw;
						} else
							cnt = fullcol;
						if (otln(vc[tvc].pt, cnt, &ips,
								&ops, 1))
							return(1);
						tvc += pln;
						if (tvc >= cvc)
							break;
					}
					/*
					 * terminate line
					 */
					if (otln(buf, 0, &ips, &ops, 0))
						return(1);
				}
				/*
				 * pad to end of page
				 */
				if (prtail((lines - pln), 0))
					return(1);
				/*
				 * done with output, go to next file
				 */
				break;
d615 2
d618 1
d622 1
a622 1
				pln = lines;
d624 1
a624 7
				pln = j;

			/*
			 * print header
			 */
			if (pln && !nohead && prhead(hbuf, fname, pagecnt))
				return(1);
d630 6
a635 3
				ptbf = buf + lindy[i];
				if ((j = lstdat[i] - ptbf) <= offst)
					break;
d637 2
a638 1
					return(1);
d640 2
d643 5
a647 5
			/*
			 * pad to end of page
			 */
			if (pln && prtail((lines - pln), 0))
				return(1);
d649 12
a660 9
			/*
			 * if EOF go to next file
			 */
			if (cnt < 0)
				break;
			++pagecnt;
		}
		if (inf != stdin)
			(void)fclose(inf);
d662 8
a669 2
	if (eoptind < argc)
		return(1);
d674 1
a674 1
 * horzcol:	print files with more than one column of output across a page
d678 2
a679 2
        int argc;
        char *argv[];
d681 45
a725 23
	register char *ptbf;
	register int pln;
	register int cnt = -1;
	register char *lstdat;
	register int col = colwd + 1;
	register int j;
	register int i;
	int lncnt;
	int pagecnt;
	char *buf;
	char *hbuf;
	char *ohbuf;
	char *fname;
	FILE *inf;
	int ips = 0;
	int cps = 0;
	int ops = 0;
	int mor = 0;

	if ((buf = malloc((unsigned)(pgwd+offst+1)*sizeof(char))) == NULL) {
		mfail();
		return(1);
	}
d728 1
a728 1
	 * page header
d730 1
a730 9
	if ((hbuf = malloc((unsigned)(HDBUF + offst)*sizeof(char))) == NULL) {
		mfail();
		return(1);
	}
	ohbuf = hbuf + offst;
	if (offst) {
		(void)memset(buf, (int)' ', offst);
		(void)memset(hbuf, (int)' ', offst);
	}
d732 4
a735 11
	/*
	 * loop by file
	 */
	while ((inf = nxtfile(argc, argv, &fname, ohbuf, 0)) != NULL) {
		if (pgnm) {
			if (inskip(inf, pgnm, lines))
				continue;
			pagecnt = pgnm;
		} else
			pagecnt = 1;
		lncnt = 0;
d738 1
a738 1
		 * loop by page
d740 55
a794 45
		for(;;) {
			/*
			 * loop by line
			 */
			for (i = 0; i < lines; ++i) {
				ptbf = buf + offst;
				lstdat = ptbf;
				j = 0;
				/*
				 * loop by col
				 */
				for(;;) {
					if (nmwd) {
						/*
						 * add number to column
						 */
						addnum(ptbf, nmwd, ++lncnt);
						ptbf += nmwd;
						*ptbf++ = nmchar;
					}
					/*
					 * input line
					 */
					if ((cnt = inln(inf,ptbf,colwd,&cps,1,
							&mor)) < 0)
						break;
					ptbf += cnt;
					lstdat = ptbf;

					/*
					 * if last line skip padding
					 */
					if (++j >= clcnt)
						break;

					/*
					 * pad to end of column
					 */
					if (sflag)
						*ptbf++ = schar;
					else if ((pln = col - cnt) > 0) {
						(void)memset(ptbf,(int)' ',pln);
						ptbf += pln;
					}
				}
d796 3
a798 14
				/*
				 * determine line length
				 */
				if ((j = lstdat - buf) <= offst)
					break;
				if (!i && !nohead &&
					prhead(hbuf, fname, pagecnt))
					return(1);
				/*
				 * output line
				 */
				if (otln(buf, j, &ips, &ops, 0))
					return(1);
			}
d800 5
a804 5
			/*
			 * pad to end of page
			 */
			if (i && prtail(lines-i, 0))
				return(1);
d806 11
a816 9
			/*
			 * if EOF go to next file
			 */
			if (cnt < 0)
				break;
			++pagecnt;
		}
		if (inf != stdin)
			(void)fclose(inf);
d818 6
a823 3
	if (eoptind < argc)
		return(1);
	return(0);
d827 2
a828 2
 * mulfile:	print files with more than one column of output and
 *		more than one file concurrently
d832 2
a833 2
        int argc;
        char *argv[];
d835 71
a905 63
	register char *ptbf;
	register int j;
	register int pln;
	register int cnt;
	register char *lstdat;
	register int i;
	FILE **fbuf;
	int actf;
	int lncnt;
	int col;
	int pagecnt;
	int fproc;
	char *buf;
	char *hbuf;
	char *ohbuf;
	char *fname;
	int ips = 0;
	int cps = 0;
	int ops = 0;
	int mor = 0;

	/*
	 * array of FILE *, one for each operand
	 */
	if ((fbuf = (FILE **)malloc((unsigned)clcnt*sizeof(FILE *))) == NULL) {
		mfail();
		return(1);
	}

	/*
	 * page header
	 */
	if ((hbuf = malloc((unsigned)(HDBUF + offst)*sizeof(char))) == NULL) {
		mfail();
		return(1);
	}
	ohbuf = hbuf + offst;

	/*
	 * do not know how many columns yet. The number of operands provide an
	 * upper bound on the number of columns. We use the number of files
	 * we can open successfully to set the number of columns. The operation
	 * of the merge operation (-m) in relation to unsuccesful file opens
	 * is unspecified by posix.
	 */
	j = 0;
	while (j < clcnt) {
		if ((fbuf[j] = nxtfile(argc, argv, &fname, ohbuf, 1)) == NULL)
			break;
		if (pgnm && (inskip(fbuf[j], pgnm, lines)))
			fbuf[j] = NULL;
		++j;
	}

	/*
	 * if no files, exit
	 */
	if (!j)
		return(1);

	/*
	 * calculate page boundries based on open file count
	 */
d907 2
a908 14
	if (nmwd) {
		colwd = (pgwd - clcnt - nmwd)/clcnt;
		pgwd = ((colwd + 1) * clcnt) - nmwd - 2;
	} else {
		colwd = (pgwd + 1 - clcnt)/clcnt;
		pgwd = ((colwd + 1) * clcnt) - 1;
	}
	if (colwd < 1) {
		(void)fprintf(err,
		  "pr: page width too small for %d columns\n", clcnt);
		return(1);
	}
	actf = clcnt;
	col = colwd + 1;
d910 57
a966 16
	/*
	 * line buffer
	 */
	if ((buf = malloc((unsigned)(pgwd+offst+1)*sizeof(char))) == NULL) {
		mfail();
		return(1);
	}
	if (offst) {
		(void)memset(buf, (int)' ', offst);
		(void)memset(hbuf, (int)' ', offst);
	}
	if (pgnm)
		pagecnt = pgnm;
	else
		pagecnt = 1;
	lncnt = 0;
d968 1
a968 4
	/*
	 * continue to loop while any file still has data
	 */
	while (actf > 0) {
d970 1
a970 1
		 * loop by line
d972 29
a1000 13
		for (i = 0; i < lines; ++i) {
			ptbf = buf + offst;
			lstdat = ptbf;
			if (nmwd) {
				/*
				 * add line number to line
				 */
				addnum(ptbf, nmwd, ++lncnt);
				ptbf += nmwd;
				*ptbf++ = nmchar;
			}
			j = 0;
			fproc = 0;
d1002 13
a1014 43
			/*
			 * loop by column
			 */
			for (j = 0; j < clcnt; ++j) {
				if (fbuf[j] == NULL) {
					/*
					 * empty column; EOF
					 */
					cnt = 0;
				} else if ((cnt = inln(fbuf[j], ptbf, colwd,
							&cps, 1, &mor)) < 0) {
					/*
					 * EOF hit; no data
					 */
					if (fbuf[j] != stdin)
						(void)fclose(fbuf[j]);
					fbuf[j] = NULL;
					--actf;
					cnt = 0;
				} else {
					/*
					 * process file data
					 */
					ptbf += cnt;
					lstdat = ptbf;
					fproc++;
				}

				/*
				 * if last ACTIVE column, done with line
				 */
				if (fproc >= actf)
					break;

				/*
				 * pad to end of column
				 */
				if (sflag) {
					*ptbf++ = schar;
				} else if ((pln = col - cnt) > 0) {
					(void)memset(ptbf, (int)' ', pln);
					ptbf += pln;
				}
d1016 2
d1019 6
a1024 5
			/*
			 * calculate data in line
			 */
			if ((j = lstdat - buf) <= offst)
				break;
d1026 8
a1033 2
			if (!i && !nohead && prhead(hbuf, fname, pagecnt))
				return(1);
d1035 5
a1039 5
			/*
			 * output line
			 */
			if (otln(buf, j, &ips, &ops, 0))
				return(1);
d1041 3
a1043 8
			/*
			 * if no more active files, done
			 */
			if (actf <= 0) {
				++i;
				break;
			}
		}
d1045 2
a1046 6
		/*
		 * pad to end of page
		 */
		if (i && prtail(lines-i, 0))
			return(1);
		++pagecnt;
d1048 6
a1053 3
	if (eoptind < argc)
		return(1);
	return(0);
d1057 3
a1059 2
 * inln():	input a line of data (unlimited length lines supported)
 *		Input is optionally expanded to spaces
d1061 7
a1067 6
 *	inf:	file
 *	buf:	buffer
 *	lim:	buffer length
 *	cps:	column positon 1st char in buffer (large line support)
 *	trnc:	throw away data more than lim up to \n 
 *	mor:	set if more data in line (not truncated)
d1070 8
a1077 7
inln(inf, buf, lim, cps, trnc, mor)
	FILE *inf;
	char *buf;
	register int lim;
	int *cps;
	int trnc;
	int *mor;
d1079 17
a1095 9
	register int col;
	register int gap = ingap;
	register int ch = EOF;
	register char *ptbuf;
	register int chk = (int)inchar;

	ptbuf = buf;

	if (gap) {
d1097 1
a1097 1
		 * expanding input option
d1099 2
a1100 10
		while ((--lim >= 0) && ((ch = getc(inf)) != EOF)) {
			/*
			 * is this the input "tab" char
			 */
			if (ch == chk) {
				/*
				 * expand to number of spaces
				 */
				col = (ptbuf - buf) + *cps;
				col = gap - (col % gap);
a1101 18
				/*
				 * if more than this line, push back
				 */
				if ((col > lim) && (ungetc(ch, inf) == EOF))
					return(1);

				/*
				 * expand to spaces
				 */
				while ((--col >= 0) && (--lim >= 0))
					*ptbuf++ = ' ';
				continue;
			}
			if (ch == '\n')
				break;
			*ptbuf++ = ch;
		}
	} else {
d1103 1
a1103 1
		 * no expansion
d1105 3
a1107 4
		while ((--lim >= 0) && ((ch = getc(inf)) != EOF)) {
			if (ch == '\n')
				break;
			*ptbuf++ = ch;
d1109 1
a1109 10
	}
	col = ptbuf - buf;
	if (ch == EOF) {
		*mor = 0;
		*cps = 0;
		if (!col)
			return(-1);
		return(col);
	}
	if (ch == '\n') {
d1111 1
a1111 1
		 * entire line processed
d1113 16
a1128 3
		*mor = 0;
		*cps = 0;
		return(col);
d1130 28
a1157 1

d1159 1
a1159 1
	 * line was larger than limit
d1161 3
a1163 16
	if (trnc) {
		/*
		 * throw away rest of line
		 */
		while ((ch = getc(inf)) != EOF) {
			if (ch == '\n')
				break;
		}
		*cps = 0;
		*mor = 0;
	} else {
		/*
		 * save column offset if not truncated
		 */
		*cps += col;
		*mor = 1;
d1165 9
d1175 2
a1176 1
	return(col);
d1180 2
a1181 2
 * otln():	output a line of data. (Supports unlimited length lines)
 *		output is optionally contracted to tabs
d1183 6
a1188 6
 *	buf:	output buffer with data
 *	cnt:	number of chars of valid data in buf
 *	svips:	buffer input column position (for large lines)
 *	svops:	buffer output column position (for large lines)
 *	mor:	output line not complete in this buf; more data to come.	
 *		1 is more, 0 is complete, -1 is no \n's
d1192 5
a1196 5
	register char *buf;
	int cnt;
	int *svops;
	int *svips;
	int mor;
d1198 40
a1237 7
	register int ops;		/* last col output */
	register int ips;		/* last col in buf examined */
	register int gap = ogap;
	register int tbps;
	register char *endbuf;

	if (ogap) {
d1239 1
a1239 1
		 * contracting on output
d1241 5
a1245 67
		endbuf = buf + cnt;
		ops = *svops;
		ips = *svips;
		while (buf < endbuf) {
			/*
			 * count number of spaces and ochar in buffer
			 */
			if (*buf == ' ') {
				++ips;
				++buf;
				continue;
			}

			/*
			 * simulate ochar processing
			 */
			if (*buf == ochar) {
				ips += gap - (ips % gap);
				++buf;
				continue;
			}

			/*
			 * got a non space char; contract out spaces
			 */
			while (ops < ips) {
				/*
				 * use as many ochar as will fit
				 */
				if ((tbps = ops + gap - (ops % gap)) > ips)
					break;
				if (putchar(ochar) == EOF) {
					pfail();
					return(1);
				}
				ops = tbps;
			}

			while (ops < ips) {
				/*
				 * finish off with spaces
				 */
				if (putchar(' ') == EOF) {
					pfail();
					return(1);
				}
				++ops;
			}

			/*
			 * output non space char
			 */
			if (putchar(*buf++) == EOF) {
				pfail();
				return(1);
			}
			++ips;
			++ops;
		}

		if (mor > 0) {
			/*
			 * if incomplete line, save position counts
			 */
			*svops = ops;
			*svips = ips;
			return(0);
d1247 2
d1250 1
a1250 26
		if (mor < 0) {
			while (ops < ips) {
				/*
				 * use as many ochar as will fit
				 */
				if ((tbps = ops + gap - (ops % gap)) > ips)
					break;
				if (putchar(ochar) == EOF) {
					pfail();
					return(1);
				}
				ops = tbps;
			}
			while (ops < ips) {
				/*
				 * finish off with spaces
				 */
				if (putchar(' ') == EOF) {
					pfail();
					return(1);
				}
				++ops;
			}
			return(0);
		}
	} else {
d1252 1
a1252 1
		 * output is not contracted
d1254 11
a1264 12
		if (cnt && (fwrite(buf, sizeof(char), cnt, stdout) <= 0)) {
			pfail();
			return(1);
		}
		if (mor != 0)
			return(0);
	}

	/*
	 * process line end and double space as required
	 */
	if ((putchar('\n') == EOF) || (dspace && (putchar('\n') == EOF))) {
d1267 12
d1280 46
a1325 1
	return(0);
d1328 1
d1330 2
a1331 2
 * inskip():	skip over pgcnt pages with lncnt lines per page
 *		file is closed at EOF (if not stdin).
d1333 3
a1335 3
 *	inf	FILE * to read from
 *	pgcnt	number of pages to skip
 *	lncnt	number of lines per page
d1339 3
a1341 3
	FILE *inf;
	register int pgcnt;
	register int lncnt;
d1343 2
a1344 2
	register int c;
	register int cnt;
d1346 10
a1355 11
	while(--pgcnt > 0) {
		cnt = lncnt;
		while ((c = getc(inf)) != EOF) {
			if ((c == '\n') && (--cnt == 0))
				break;
		}
		if (c == EOF) {
			if (inf != stdin)
				(void)fclose(inf);
			return(1);
		}
d1357 2
a1358 1
	return(0);
d1360 1
d1363 2
a1364 2
 * nxtfile:	returns a FILE * to next file in arg list and sets the
 *		time field for this file (or current date).
d1366 2
a1367 2
 *	buf	array to store proper date for the header.
 *	dt	if set skips the date processing (used with -m)
d1371 5
a1375 5
	int argc;
	char **argv;
	char **fname;
	char *buf;
	int dt;
d1377 77
a1453 7
	FILE *inf = NULL;
	struct timeval tv;
	struct timezone tz;
	struct tm *timeptr = NULL;
	struct stat statbuf;
	time_t curtime;
	static int twice = -1;
d1455 1
a1455 15
	++twice;
	if (eoptind >= argc) {
		/*
		 * no file listed; default, use standard input
		 */
		if (twice)
			return(NULL);
		clearerr(stdin);
		inf = stdin;
		if (header != NULL)
			*fname = header;
		else
			*fname = FNAME;
		if (nohead)
			return(inf);
d1457 5
a1461 5
			++errcnt;
			(void)fprintf(err, "pr: cannot get time of day, %s\n",
				strerror(errno));
			eoptind = argc - 1;
			return(NULL);
d1465 28
a1492 84
	}
	for (; eoptind < argc; ++eoptind) {
		if (strcmp(argv[eoptind], "-") == 0) {
			/*
			 * process a "-" for filename
			 */
			clearerr(stdin);
			inf = stdin;
			if (header != NULL)
				*fname = header;
			else
				*fname = FNAME;
			++eoptind;
			if (nohead || (dt && twice))
				return(inf);
			if (gettimeofday(&tv, &tz) < 0) {
				++errcnt;
				(void)fprintf(err,
					"pr: cannot get time of day, %s\n",
					strerror(errno));
				return(NULL);
			}
			curtime = tv.tv_sec;
			timeptr = localtime(&curtime);
		} else {
			/*
			 * normal file processing
			 */
			if ((inf = fopen(argv[eoptind], "r")) == NULL) {
				++errcnt;
				if (nodiag)
					continue;
				(void)fprintf(err, "pr: Cannot open %s, %s\n",
					argv[eoptind], strerror(errno));
				continue;
			}
			if (header != NULL)
				*fname = header;
			else if (dt)
				*fname = FNAME;
			else
				*fname = argv[eoptind];
			++eoptind;
			if (nohead || (dt && twice))
				return(inf);

			if (dt) {
				if (gettimeofday(&tv, &tz) < 0) {
					++errcnt;
					(void)fprintf(err,
					     "pr: cannot get time of day, %s\n",
					     strerror(errno));
					return(NULL);
				}
				curtime = tv.tv_sec;
				timeptr = localtime(&curtime);
			} else {
				if (fstat(fileno(inf), &statbuf) < 0) {
					++errcnt;
					(void)fclose(inf);
					(void)fprintf(err, 
						"pr: Cannot stat %s, %s\n",
						argv[eoptind], strerror(errno));
					return(NULL);
				}
				timeptr = localtime(&(statbuf.st_mtime));
			}
		}
		break;
	}
	if (inf == NULL)
		return(NULL);

	/*
	 * set up time field used in header
	 */
	if (strftime(buf, HDBUF, timefrmt, timeptr) <= 0) {
		++errcnt;
		if (inf != stdin)
			(void)fclose(inf);
		(void)fputs("pr: time conversion failed\n", err);
		return(NULL);
	}
	return(inf);
d1496 3
a1498 3
 * addnum():	adds the line number to the column
 *		Truncates from the front or pads with spaces as required.
 *		Numbers are right justified.
d1500 3
a1502 3
 *	buf	buffer to store the number
 *	wdth	width of buffer to fill
 *	line	line number
d1504 5
a1508 5
 *		NOTE: numbers occupy part of the column. The posix
 *		spec does not specify if -i processing should or should not
 *		occur on number padding. The spec does say it occupies
 *		part of the column. The usage of addnum	currently treats
 *		numbers as part of the column so spaces may be replaced.
d1512 3
a1514 3
	register char *buf;
	register int wdth;
	register int line;
d1516 1
a1516 6
	register char *pt = buf + wdth;

	do {
		*--pt = digs[line % 10];
		line /= 10;
	} while (line && (pt > buf));
d1518 10
a1527 5
	/*
	 * pad with space as required
	 */
	while (pt > buf)
		*--pt = ' ';
d1531 1
a1531 1
 * prhead():	prints the top of page header
d1533 11
a1543 4
 *	buf	buffer with time field (and offset)
 *	cnt	number of chars in buf
 *	fname	fname field for header
 *	pagcnt	page number
d1547 3
a1549 3
	char *buf;
	char *fname;
	int pagcnt;
d1551 4
a1554 2
	int ips = 0;
	int ops = 0;
d1556 26
a1581 20
	if ((putchar('\n') == EOF) || (putchar('\n') == EOF)) {
		pfail();
		return(1);
	}
	/*
	 * posix is not clear if the header is subject to line length
	 * restrictions. The specification for header line format
	 * in the spec clearly does not limit length. No pr currently
	 * restricts header length. However if we need to truncate in
	 * an reasonable way, adjust the length of the printf by
	 * changing HDFMT to allow a length max as an arguement printf.
	 * buf (which contains the offset spaces and time field could
	 * also be trimmed
	 *
	 * note only the offset (if any) is processed for tab expansion
	 */
	if (offst && otln(buf, offst, &ips, &ops, -1))
		return(1);
	(void)printf(HDFMT,buf+offst, fname, pagcnt);
	return(0);
d1585 5
a1589 2
 * prtail():	pad page with empty lines (if required) and print page trailer
 *		if requested
d1591 2
a1592 2
 *	cnt	number of lines of padding needed
 *	incomp	was a '\n' missing from last line output
d1596 2
a1597 2
	register int cnt;
	int incomp;
d1599 17
a1615 9
	if (nohead) {
		/*
		 * only pad with no headers when incomplete last line
		 */
		if (incomp &&
		    ((dspace && (putchar('\n') == EOF)) ||
		     (putchar('\n') == EOF))) {
			pfail();
			return(1);
d1617 4
a1620 10
		/*
		 * but honor the formfeed request
		 */
		if (formfeed) {
			if (putchar('\f') == EOF) {
				pfail();
				return(1);
			}
		}
		return(0);
d1622 10
d1635 5
d1642 1
a1642 1
		cnt *= 2;
d1648 1
a1648 1
		++cnt;
d1651 1
a1651 1
	 * pad page
d1654 4
a1657 4
		if ((incomp && (putchar('\n') == EOF)) || 
		    (putchar('\f') == EOF)) {
			pfail();
			return(1);
d1659 12
a1670 4
		return(0);
	} 
	cnt += TAILLEN;
	while (--cnt >= 0) {
d1672 2
a1673 2
			pfail();
			return(1);
d1675 1
d1677 3
a1679 1
	return(0);
d1683 1
a1683 1
 * terminate():	when a SIGINT is recvd
d1687 1
a1687 1
	int which_sig;
d1689 2
a1690 2
	flsh_errs();
	exit(1);
d1695 2
a1696 2
 * flsh_errs():	output saved up diagnostic messages after all normal
 *		processing has completed
d1701 1
a1701 1
	char buf[BUFSIZ];
d1703 7
a1709 7
	(void)fflush(stdout);
	(void)fflush(err);
	if (err == stderr)
		return;
	rewind(err);
	while (fgets(buf, BUFSIZ, err) != NULL)
		(void)fputs(buf, stderr);
d1715 1
a1715 1
	(void)fputs("pr: memory allocation failed\n", err);
d1721 1
a1721 1
	(void)fprintf(err, "pr: write failure, %s\n", strerror(errno));
d1727 6
a1732 6
	(void)fputs(
	 "usage: pr [+page] [-col] [-adFmrt] [-e[ch][gap]] [-h header]\n",err);
	(void)fputs(
	 "          [-i[ch][gap]] [-l line] [-n[ch][width]] [-o offset]\n",err);
	(void)fputs(
	 "          [-s[ch]] [-w width] [-] [file ...]\n", err);
d1736 2
a1737 2
 * setup:	Validate command args, initialize and perform sanity 
 *		checks on options
d1741 2
a1742 2
	register int argc;
	register char **argv;
d1744 109
a1852 13
	register int c;
	int eflag = 0;
	int iflag = 0;
	int wflag = 0;
	int cflag = 0;

	if (isatty(fileno(stdout))) {
		/*
		 * defer diagnostics until processing is done
		 */
		if ((err = tmpfile()) == NULL) {
		       (void)fputs("Cannot defer diagnostic messages\n",stderr);
		       return(1);
d1854 59
d1914 34
a1947 137
		err = stderr;
	while ((c = egetopt(argc, argv, "#adFmrte?h:i?l:n?o:s?w:")) != -1) {
		switch (c) {
		case '+':
			if ((pgnm = atoi(eoptarg)) < 1) {
			    (void)fputs("pr: +page number must be 1 or more\n",
				err);
			    return(1);
			}
			break;
		case '-':
			if ((clcnt = atoi(eoptarg)) < 1) {
			    (void)fputs("pr: -columns must be 1 or more\n",err);
			    return(1);
			}
			if (clcnt > 1)
				++cflag;
			break;
		case 'a':
			++across;
			break;
		case 'd':
			++dspace;
			break;
		case 'e':
			++eflag;
			if ((eoptarg != NULL) && !isdigit(*eoptarg))
				inchar = *eoptarg++;
			else
				inchar = INCHAR;
			if ((eoptarg != NULL) && isdigit(*eoptarg)) {
				if ((ingap = atoi(eoptarg)) < 0) {
					(void)fputs(
					"pr: -e gap must be 0 or more\n", err);
					return(1);
				}
				if (ingap == 0)
					ingap = INGAP;
			} else if ((eoptarg != NULL) && (*eoptarg != '\0')) {
				(void)fprintf(err,
				      "pr: invalid value for -e %s\n", eoptarg);
				return(1);
			} else
				ingap = INGAP;
			break;
		case 'F':
			++formfeed;
			break;
		case 'h':
			header = eoptarg;
			break;
		case 'i':
			++iflag;
			if ((eoptarg != NULL) && !isdigit(*eoptarg))
				ochar = *eoptarg++;
			else
				ochar = OCHAR;
			if ((eoptarg != NULL) && isdigit(*eoptarg)) {
				if ((ogap = atoi(eoptarg)) < 0) {
					(void)fputs(
					"pr: -i gap must be 0 or more\n", err);
					return(1);
				}
				if (ogap == 0)
					ogap = OGAP;
			} else if ((eoptarg != NULL) && (*eoptarg != '\0')) {
				(void)fprintf(err,
				      "pr: invalid value for -i %s\n", eoptarg);
				return(1);
			} else
				ogap = OGAP;
			break;
		case 'l':
			if (!isdigit(*eoptarg) || ((lines=atoi(eoptarg)) < 1)) {
				(void)fputs(
				 "pr: Number of lines must be 1 or more\n",err);
				return(1);
			}
			break;
		case 'm':
			++merge;
			break;
		case 'n':
			if ((eoptarg != NULL) && !isdigit(*eoptarg))
				nmchar = *eoptarg++;
			else
				nmchar = NMCHAR;
			if ((eoptarg != NULL) && isdigit(*eoptarg)) {
				if ((nmwd = atoi(eoptarg)) < 1) {
					(void)fputs(
					"pr: -n width must be 1 or more\n",err);
					return(1);
				}
			} else if ((eoptarg != NULL) && (*eoptarg != '\0')) {
				(void)fprintf(err,
				      "pr: invalid value for -n %s\n", eoptarg);
				return(1);
			} else
				nmwd = NMWD;
			break;
		case 'o':
			if (!isdigit(*eoptarg) || ((offst = atoi(eoptarg))< 1)){
				(void)fputs("pr: -o offset must be 1 or more\n",
					err);
				return(1);
			}
			break;
		case 'r':
			++nodiag;
			break;
		case 's':
			++sflag;
			if (eoptarg == NULL)
				schar = SCHAR;
			else
				schar = *eoptarg++;
			if (*eoptarg != '\0') {
				(void)fprintf(err,
				      "pr: invalid value for -s %s\n", eoptarg);
				return(1);
			}
			break;
		case 't':
			++nohead;
			break;
		case 'w':
			++wflag;
			if (!isdigit(*eoptarg) || ((pgwd = atoi(eoptarg)) < 1)){
				(void)fputs(
				   "pr: -w width must be 1 or more \n",err);
				return(1);
			}
			break;
		case '?':
		default:
			return(1);
		}
d1949 6
a1954 12

	/*
	 * default and sanity checks
	 */
	if (!clcnt) {
		if (merge) {
			if ((clcnt = argc - eoptind) <= 1) {
				clcnt = CLCNT;
				merge = 0;
			}
		} else
			clcnt = CLCNT;
d1956 33
a1988 73
	if (across) {
		if (clcnt == 1) {
			(void)fputs("pr: -a flag requires multiple columns\n",
				err);
			return(1);
		}
		if (merge) {
			(void)fputs("pr: -m cannot be used with -a\n", err);
			return(1);
		}
	}
	if (!wflag) {
		if (sflag)
			pgwd = SPGWD;
		else
			pgwd = PGWD;
	}
	if (cflag || merge) {
		if (!eflag) {
			inchar = INCHAR;
			ingap = INGAP;
		}
		if (!iflag) {
			ochar = OCHAR;
			ogap = OGAP;
		}
	}
	if (cflag) {
		if (merge) {
			(void)fputs(
			  "pr: -m cannot be used with multiple columns\n", err);
			return(1);
		}
		if (nmwd) {
			colwd = (pgwd + 1 - (clcnt * (nmwd + 2)))/clcnt;
			pgwd = ((colwd + nmwd + 2) * clcnt) - 1;
		} else {
			colwd = (pgwd + 1 - clcnt)/clcnt;
			pgwd = ((colwd + 1) * clcnt) - 1;
		}
		if (colwd < 1) {
			(void)fprintf(err,
			  "pr: page width is too small for %d columns\n",clcnt);
			return(1);
		}
	}
	if (!lines)
		lines = LINES;

	/*
	 * make sure long enough for headers. if not disable
	 */
	if (lines <= HEADLEN + TAILLEN)
		++nohead;	
	else if (!nohead)
		lines -= HEADLEN + TAILLEN;

	/*
	 * adjust for double space on odd length pages
	 */
	if (dspace) {
		if (lines == 1)
			dspace = 0;
		else {
			if (lines & 1)
				++addone;
			lines /= 2;
		}
	}

	if ((timefrmt = getenv("LC_TIME")) == NULL)
		timefrmt = TIMEFMT;
	return(0);
@


1.3
log
@pr -F would sometimes fail to properly use formfeeds.
@
text
@d1 1
a1 1
/*	$OpenBSD: pr.c,v 1.2 1996/06/26 05:37:54 deraadt Exp $	*/
d48 1
a48 1
static char *rcsid = "$OpenBSD: pr.c,v 1.2 1996/06/26 05:37:54 deraadt Exp $";
d1596 1
a1596 1
	while ((c = egetopt(argc, argv, "#adFmrte?h:i?l:n?o:s?w:")) != EOF) {
@


1.2
log
@rcsid
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d48 1
a48 1
static char *rcsid = "$OpenBSD: pr.c,v 1.1.1.1 1995/10/18 08:45:56 deraadt Exp $";
d1467 3
a1469 4
		if (!incomp)
			return(0);
		if ((dspace && (putchar('\n') == EOF)) ||
		    (putchar('\n') == EOF)) {
d1472 9
@


1.1
log
@Initial revision
@
text
@d1 2
d48 1
a48 1
static char *rcsid = "$Id: pr.c,v 1.3 1995/06/07 16:10:11 cgd Exp $";
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@
