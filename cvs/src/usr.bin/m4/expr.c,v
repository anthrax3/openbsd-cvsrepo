head	1.18;
access;
symbols
	OPENBSD_6_2:1.18.0.30
	OPENBSD_6_2_BASE:1.18
	OPENBSD_6_1:1.18.0.28
	OPENBSD_6_1_BASE:1.18
	OPENBSD_6_0:1.18.0.24
	OPENBSD_6_0_BASE:1.18
	OPENBSD_5_9:1.18.0.20
	OPENBSD_5_9_BASE:1.18
	OPENBSD_5_8:1.18.0.22
	OPENBSD_5_8_BASE:1.18
	OPENBSD_5_7:1.18.0.14
	OPENBSD_5_7_BASE:1.18
	OPENBSD_5_6:1.18.0.18
	OPENBSD_5_6_BASE:1.18
	OPENBSD_5_5:1.18.0.16
	OPENBSD_5_5_BASE:1.18
	OPENBSD_5_4:1.18.0.12
	OPENBSD_5_4_BASE:1.18
	OPENBSD_5_3:1.18.0.10
	OPENBSD_5_3_BASE:1.18
	OPENBSD_5_2:1.18.0.8
	OPENBSD_5_2_BASE:1.18
	OPENBSD_5_1_BASE:1.18
	OPENBSD_5_1:1.18.0.6
	OPENBSD_5_0:1.18.0.4
	OPENBSD_5_0_BASE:1.18
	OPENBSD_4_9:1.18.0.2
	OPENBSD_4_9_BASE:1.18
	OPENBSD_4_8:1.17.0.20
	OPENBSD_4_8_BASE:1.17
	OPENBSD_4_7:1.17.0.16
	OPENBSD_4_7_BASE:1.17
	OPENBSD_4_6:1.17.0.18
	OPENBSD_4_6_BASE:1.17
	OPENBSD_4_5:1.17.0.14
	OPENBSD_4_5_BASE:1.17
	OPENBSD_4_4:1.17.0.12
	OPENBSD_4_4_BASE:1.17
	OPENBSD_4_3:1.17.0.10
	OPENBSD_4_3_BASE:1.17
	OPENBSD_4_2:1.17.0.8
	OPENBSD_4_2_BASE:1.17
	OPENBSD_4_1:1.17.0.6
	OPENBSD_4_1_BASE:1.17
	OPENBSD_4_0:1.17.0.4
	OPENBSD_4_0_BASE:1.17
	OPENBSD_3_9:1.17.0.2
	OPENBSD_3_9_BASE:1.17
	OPENBSD_3_8:1.16.0.6
	OPENBSD_3_8_BASE:1.16
	OPENBSD_3_7:1.16.0.4
	OPENBSD_3_7_BASE:1.16
	OPENBSD_3_6:1.16.0.2
	OPENBSD_3_6_BASE:1.16
	OPENBSD_3_5:1.15.0.4
	OPENBSD_3_5_BASE:1.15
	OPENBSD_3_4:1.15.0.2
	OPENBSD_3_4_BASE:1.15
	OPENBSD_3_3:1.14.0.4
	OPENBSD_3_3_BASE:1.14
	OPENBSD_3_2:1.14.0.2
	OPENBSD_3_2_BASE:1.14
	OPENBSD_3_1:1.12.0.2
	OPENBSD_3_1_BASE:1.12
	OPENBSD_3_0:1.11.0.8
	OPENBSD_3_0_BASE:1.11
	OPENBSD_2_9_BASE:1.11
	OPENBSD_2_9:1.11.0.6
	OPENBSD_2_8:1.11.0.4
	OPENBSD_2_8_BASE:1.11
	OPENBSD_2_7:1.11.0.2
	OPENBSD_2_7_BASE:1.11
	OPENBSD_2_6:1.8.0.2
	OPENBSD_2_6_BASE:1.8
	OPENBSD_2_5:1.4.0.4
	OPENBSD_2_5_BASE:1.4
	OPENBSD_2_4:1.4.0.2
	OPENBSD_2_4_BASE:1.4
	OPENBSD_2_3:1.3.0.4
	OPENBSD_2_3_BASE:1.3
	OPENBSD_2_2:1.3.0.2
	OPENBSD_2_2_BASE:1.3
	OPENBSD_2_1:1.2.0.4
	OPENBSD_2_1_BASE:1.2
	OPENBSD_2_0:1.2.0.2
	OPENBSD_2_0_BASE:1.2
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.18
date	2010.09.07.19.58.09;	author marco;	state Exp;
branches;
next	1.17;

1.17
date	2006.01.20.23.10.19;	author espie;	state Exp;
branches;
next	1.16;

1.16
date	2004.05.12.21.17.03;	author espie;	state Exp;
branches;
next	1.15;

1.15
date	2003.06.03.02.56.10;	author millert;	state Exp;
branches;
next	1.14;

1.14
date	2002.04.26.16.15.16;	author espie;	state Exp;
branches;
next	1.13;

1.13
date	2002.04.26.12.55.01;	author espie;	state Exp;
branches;
next	1.12;

1.12
date	2002.02.16.21.27.48;	author millert;	state Exp;
branches;
next	1.11;

1.11
date	2000.01.11.14.00.57;	author espie;	state Exp;
branches;
next	1.10;

1.10
date	99.11.17.15.34.13;	author espie;	state Exp;
branches;
next	1.9;

1.9
date	99.11.15.22.12.00;	author espie;	state Exp;
branches;
next	1.8;

1.8
date	99.09.16.20.19.34;	author espie;	state Exp;
branches;
next	1.7;

1.7
date	99.09.14.08.35.16;	author espie;	state Exp;
branches;
next	1.6;

1.6
date	99.09.14.08.30.20;	author espie;	state Exp;
branches;
next	1.5;

1.5
date	99.09.14.08.26.10;	author espie;	state Exp;
branches;
next	1.4;

1.4
date	98.04.25.18.47.19;	author millert;	state Exp;
branches;
next	1.3;

1.3
date	97.10.24.00.56.53;	author millert;	state Exp;
branches;
next	1.2;

1.2
date	96.06.26.05.36.11;	author deraadt;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.45.35;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.45.35;	author deraadt;	state Exp;
branches;
next	;


desc
@@


1.18
log
@Remove stray spaces.  No code change.
@
text
@/* $OpenBSD: expr.c,v 1.17 2006/01/20 23:10:19 espie Exp $ */
/*
 * Copyright (c) 2004 Marc Espie <espie@@cvs.openbsd.org>
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */
#include <stdint.h>
#include <stdio.h>
#include <stddef.h>
#include "mdef.h"
#include "extern.h"

int32_t end_result;
const char *copy_toeval;

extern void yy_scan_string(const char *);
extern int yyparse(void);

int
yyerror(const char *msg)
{
	fprintf(stderr, "m4: %s in expr %s\n", msg, copy_toeval);
	return(0);
}

int
expr(const char *toeval)
{
	copy_toeval = toeval;
	yy_scan_string(toeval);
	yyparse();
	return end_result;
}
@


1.17
log
@use stdint.h where appropriate. okay millert@@
@
text
@d1 1
a1 1
/* $OpenBSD: expr.c,v 1.16 2004/05/12 21:17:03 espie Exp $ */
d36 1
a36 1
int 
@


1.16
log
@replace hand-made expr() parser with a lex/yacc affair that is shorter,
easier to understand and extend, and better conformant to Single Unix 3
(especially doing all arithmetic as int32_t).

Comments and approval millert@@, otto@@, fries@@
@
text
@d1 1
a1 1
/* $OpenBSD$ */
d17 1
a17 1
#include <sys/types.h>
@


1.15
log
@Remove the advertising clause in the UCB license which Berkeley
rescinded 22 July 1999.  Proofed by myself and Theo.
@
text
@d1 1
a1 3
/*	$OpenBSD: expr.c,v 1.14 2002/04/26 16:15:16 espie Exp $	*/
/*	$NetBSD: expr.c,v 1.7 1995/09/28 05:37:31 tls Exp $	*/

d3 1
a3 17
 * Copyright (c) 1989, 1993
 *	The Regents of the University of California.  All rights reserved.
 *
 * This code is derived from software contributed to Berkeley by
 * Ozan Yigit at York University.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
d5 11
a15 11
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
d17 2
a18 12

#ifndef lint
#if 0
static char sccsid[] = "@@(#)expr.c	8.2 (Berkeley) 4/29/95";
#else
static char rcsid[] = "$OpenBSD: expr.c,v 1.14 2002/04/26 16:15:16 espie Exp $";
#endif
#endif /* not lint */

#include <sys/cdefs.h>
#include <ctype.h>
#include <err.h>
a19 1
#include <stdio.h>
d23 2
a24 79
/*
 *      expression evaluator: performs a standard recursive
 *      descent parse to evaluate any expression permissible
 *      within the following grammar:
 *
 *      expr    :       query EOS
 *      query   :       lor
 *              |       lor "?" query ":" query
 *      lor     :       land { "||" land }
 *      land    :       not { "&&" not }
 *	not	:	eqrel
 *		|	'!' not
 *      eqrel   :       shift { eqrelop shift }
 *      shift   :       primary { shop primary }
 *      primary :       term { addop term }
 *      term    :       exp { mulop exp }
 *	exp	:	unary { expop unary }
 *      unary   :       factor
 *              |       unop unary
 *      factor  :       constant
 *              |       "(" query ")"
 *      constant:       num
 *              |       "'" CHAR "'"
 *      num     :       DIGIT
 *              |       DIGIT num
 *      shop    :       "<<"
 *              |       ">>"
 *      eqrel   :       "="
 *              |       "=="
 *              |       "!="
 *      	|       "<"
 *              |       ">"
 *              |       "<="
 *              |       ">="
 *
 *
 *      This expression evaluator is lifted from a public-domain
 *      C Pre-Processor included with the DECUS C Compiler distribution.
 *      It is hacked somewhat to be suitable for m4.
 *
 *      Originally by:  Mike Lutz
 *                      Bob Harper
 */

#define EQL     0
#define NEQ     1
#define LSS     2
#define LEQ     3
#define GTR     4
#define GEQ     5
#define OCTAL   8
#define DECIMAL 10
#define HEX	16

static const char *nxtch;		       /* Parser scan pointer */
static const char *where;

static int query(void);
static int lor(void);
static int land(void);
static int not(void);
static int eqrel(void);
static int shift(void);
static int primary(void);
static int term(void);
static int exp(void);
static int unary(void);
static int factor(void);
static int constant(void);
static int num(void);
static int geteqrel(void);
static int skipws(void);
static void experr(const char *);

/*
 * For longjmp
 */
#include <setjmp.h>
static jmp_buf expjump;
d26 2
a27 7
/*
 * macros:
 *      ungetch - Put back the last character examined.
 *      getch   - return the next character from expr string.
 */
#define ungetch()       nxtch--
#define getch()         *nxtch++
d30 1
a30 22
expr(const char *expbuf)
{
	int rval;

	nxtch = expbuf;
	where = expbuf;
	if (setjmp(expjump) != 0)
		return FALSE;

	rval = query();
	if (skipws() == EOS)
		return rval;

	printf("m4: ill-formed expression.\n");
	return FALSE;
}

/*
 * query : lor | lor '?' query ':' query
 */
static int
query()
d32 2
a33 14
	int result, true_val, false_val;

	result = lor();
	if (skipws() != '?') {
		ungetch();
		return result;
	}

	true_val = query();
	if (skipws() != ':')
		experr("bad query");

	false_val = query();
	return result ? true_val : false_val;
d36 2
a37 434
/*
 * lor : land { '||' land }
 */
static int
lor()
{
	int c, vl, vr;

	vl = land();
	while ((c = skipws()) == '|') {
		if (getch() != '|')
			ungetch();
		vr = land();
		vl = vl || vr;
	}

	ungetch();
	return vl;
}

/*
 * land : not { '&&' not }
 */
static int
land()
{
	int c, vl, vr;

	vl = not();
	while ((c = skipws()) == '&') {
		if (getch() != '&')
			ungetch();
		vr = not();
		vl = vl && vr;
	}

	ungetch();
	return vl;
}

/*
 * not : eqrel | '!' not
 */
static int
not()
{
	int val, c;

	if ((c = skipws()) == '!' && getch() != '=') {
		ungetch();
		val = not();
		return !val;
	}

	if (c == '!')
		ungetch();
	ungetch();
	return eqrel();
}

/*
 * eqrel : shift { eqrelop shift }
 */
static int
eqrel()
{
	int vl, vr, eqrel;

	vl = shift();
	while ((eqrel = geteqrel()) != -1) {
		vr = shift();

		switch (eqrel) {

		case EQL:
			vl = (vl == vr);
			break;
		case NEQ:
			vl = (vl != vr);
			break;

		case LEQ:
			vl = (vl <= vr);
			break;
		case LSS:
			vl = (vl < vr);
			break;
		case GTR:
			vl = (vl > vr);
			break;
		case GEQ:
			vl = (vl >= vr);
			break;
		}
	}
	return vl;
}

/*
 * shift : primary { shop primary }
 */
static int
shift()
{
	int vl, vr, c;

	vl = primary();
	while (((c = skipws()) == '<' || c == '>') && getch() == c) {
		vr = primary();

		if (c == '<')
			vl <<= vr;
		else
			vl >>= vr;
	}

	if (c == '<' || c == '>')
		ungetch();
	ungetch();
	return vl;
}

/*
 * primary : term { addop term }
 */
static int
primary()
{
	int c, vl, vr;

	vl = term();
	while ((c = skipws()) == '+' || c == '-') {
		vr = term();

		if (c == '+')
			vl += vr;
		else
			vl -= vr;
	}

	ungetch();
	return vl;
}

/*
 * <term> := <exp> { <mulop> <exp> }
 */
static int
term()
{
	int c, vl, vr;

	vl = exp();
	while ((c = skipws()) == '*' || c == '/' || c == '%') {
		vr = exp();

		switch (c) {
		case '*':
			vl *= vr;
			break;
		case '/':
			if (vr == 0)
				errx(1, "division by zero in eval.");
			else
				vl /= vr;
			break;
		case '%':
			if (vr == 0)
				errx(1, "modulo zero in eval.");
			else
				vl %= vr;
			break;
		}
	}
	ungetch();
	return vl;
}

/*
 * <term> := <unary> { <expop> <unary> }
 */
static int
exp()
{
	int c, vl, vr, n;

	vl = unary();
	switch (c = skipws()) {

	case '*':
		if (getch() != '*') {
			ungetch();
			break;
		}

	case '^':
		vr = exp();
		n = 1;
		while (vr-- > 0)
			n *= vl;
		return n;
	}

	ungetch();
	return vl;
}

/*
 * unary : factor | unop unary
 */
static int
unary()
{
	int val, c;

	if ((c = skipws()) == '+' || c == '-' || c == '~') {
		val = unary();

		switch (c) {
		case '+':
			return val;
		case '-':
			return -val;
		case '~':
			return ~val;
		}
	}

	ungetch();
	return factor();
}

/*
 * factor : constant | '(' query ')'
 */
static int
factor()
{
	int val;

	if (skipws() == '(') {
		val = query();
		if (skipws() != ')')
			experr("bad factor");
		return val;
	}

	ungetch();
	return constant();
}

/*
 * constant: num | 'char'
 * Note: constant() handles multi-byte constants
 */
static int
constant()
{
	int i;
	int value;
	int c;
	int v[sizeof(int)];

	if (skipws() != '\'') {
		ungetch();
		return num();
	}
	for (i = 0; i < sizeof(int); i++) {
		if ((c = getch()) == '\'') {
			ungetch();
			break;
		}
		if (c == '\\') {
			switch (c = getch()) {
			case '0':
			case '1':
			case '2':
			case '3':
			case '4':
			case '5':
			case '6':
			case '7':
				ungetch();
				c = num();
				break;
			case 'n':
				c = 012;
				break;
			case 'r':
				c = 015;
				break;
			case 't':
				c = 011;
				break;
			case 'b':
				c = 010;
				break;
			case 'f':
				c = 014;
				break;
			}
		}
		v[i] = c;
	}
	if (i == 0 || getch() != '\'')
		experr("illegal character constant");
	for (value = 0; --i >= 0;) {
		value <<= 8;
		value += v[i];
	}
	return value;
}

/*
 * num : digit | num digit
 */
static int
num()
{
	int rval, c, base;
	int ndig;

	rval = 0;
	ndig = 0;
	c = skipws();
	if (c == '0') {
		c = skipws();
		if (c == 'x' || c == 'X') {
			base = HEX;
			c = skipws();
		} else {
			base = OCTAL;
			ndig++;
		}
	} else
		base = DECIMAL;
	for(;;) {
		switch(c) {
			case '8': case '9':
				if (base == OCTAL) 
					goto bad_digit;
				/*FALLTHRU*/
			case '0': case '1': case '2': case '3': 
			case '4': case '5': case '6': case '7':
				rval *= base;
				rval += c - '0';
				break;
			case 'A': case 'B': case 'C': case 'D': case 'E': case 'F':
				c = tolower(c);
			case 'a': case 'b': case 'c': case 'd': case 'e': case 'f':
				if (base == HEX) {
					rval *= base;
					rval += c - 'a' + 10;
					break;
				}
				/*FALLTHRU*/
			default:
				goto bad_digit;
		}
		c = getch();
		ndig++;
	}
bad_digit:
	ungetch();
	
	if (ndig == 0)
		experr("bad constant");
	
	return rval;
}

/*
 * eqrel : '=' | '==' | '!=' | '<' | '>' | '<=' | '>='
 */
static int
geteqrel()
{
	int c1, c2;

	c1 = skipws();
	c2 = getch();

	switch (c1) {

	case '=':
		if (c2 != '=')
			ungetch();
		return EQL;

	case '!':
		if (c2 == '=')
			return NEQ;
		ungetch();
		ungetch();
		return -1;

	case '<':
		if (c2 == '=')
			return LEQ;
		ungetch();
		return LSS;

	case '>':
		if (c2 == '=')
			return GEQ;
		ungetch();
		return GTR;

	default:
		ungetch();
		ungetch();
		return -1;
	}
}

/*
 * Skip over any white space and return terminating char.
 */
static int
skipws()
{
	int c;

	while ((c = getch()) <= ' ' && c > EOS)
		;
	return c;
}

/*
 * resets environment to eval(), prints an error 
 * and forces eval to return FALSE.
 */
static void
experr(const char *msg)
d39 4
a42 2
	printf("m4: %s in expr %s.\n", msg, where);
	longjmp(expjump, -1);
@


1.14
log
@use ansi function declarations. ok millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: expr.c,v 1.13 2002/04/26 12:55:01 espie Exp $	*/
d19 1
a19 5
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
d40 1
a40 1
static char rcsid[] = "$OpenBSD: expr.c,v 1.13 2002/04/26 12:55:01 espie Exp $";
@


1.13
log
@rename `bool' to something else, to avoid C99 surprises.
@
text
@d1 1
a1 1
/*	$OpenBSD: expr.c,v 1.12 2002/02/16 21:27:48 millert Exp $	*/
d44 1
a44 1
static char rcsid[] = "$OpenBSD: expr.c,v 1.12 2002/02/16 21:27:48 millert Exp $";
d145 1
a145 2
expr(expbuf)
	const char *expbuf;
d617 1
a617 2
experr(msg)
	const char *msg;
@


1.12
log
@Part one of userland __P removal.  Done with a simple regexp with some minor hand editing to make comments line up correctly.  Another pass is forthcoming that handles the cases that could not be done automatically.
@
text
@d1 1
a1 1
/*	$OpenBSD: expr.c,v 1.11 2000/01/11 14:00:57 espie Exp $	*/
d44 1
a44 1
static char rcsid[] = "$OpenBSD: expr.c,v 1.11 2000/01/11 14:00:57 espie Exp $";
d169 1
a169 1
	int bool, true_val, false_val;
d171 1
a171 1
	bool = lor();
d174 1
a174 1
		return bool;
d182 1
a182 1
	return bool ? true_val : false_val;
@


1.11
log
@Show problematic evaluated expression in error messages.
@
text
@d1 1
a1 1
/*	$OpenBSD: expr.c,v 1.10 1999/11/17 15:34:13 espie Exp $	*/
d44 1
a44 1
static char rcsid[] = "$OpenBSD: expr.c,v 1.10 1999/11/17 15:34:13 espie Exp $";
d113 16
a128 16
static int query __P((void));
static int lor __P((void));
static int land __P((void));
static int not __P((void));
static int eqrel __P((void));
static int shift __P((void));
static int primary __P((void));
static int term __P((void));
static int exp __P((void));
static int unary __P((void));
static int factor __P((void));
static int constant __P((void));
static int num __P((void));
static int geteqrel __P((void));
static int skipws __P((void));
static void experr __P((const char *));
@


1.10
log
@Turn warnings on,
Add missing prototypes,
Make local functions static,
Sort extern.h by file,
Constify all char * that can be,
Copy temp file name so that eval does not modify its arguments.
@
text
@d1 1
a1 1
/*	$OpenBSD: expr.c,v 1.9 1999/11/15 22:12:00 espie Exp $	*/
d44 1
a44 1
static char rcsid[] = "$OpenBSD: expr.c,v 1.9 1999/11/15 22:12:00 espie Exp $";
d111 1
d151 1
d621 1
a621 1
	printf("m4: %s in expr.\n", msg);
@


1.9
log
@I'm a moron...
Bug found by dugsong@@. I can't believe it wasn't found before.
@
text
@d1 1
a1 1
/*	$OpenBSD: expr.c,v 1.8 1999/09/16 20:19:34 espie Exp $	*/
d44 1
a44 1
static char rcsid[] = "$OpenBSD: expr.c,v 1.8 1999/09/16 20:19:34 espie Exp $";
d49 3
a52 1
#include <ctype.h>
d54 1
d110 1
a110 1
static char *nxtch;		       /* Parser scan pointer */
d127 1
a127 1
static void experr __P((char *));
d145 1
a145 1
	char *expbuf;
d617 1
a617 1
	char *msg;
@


1.8
log
@Do something sensible with division by 0 in expr.
Noticed by aaron@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: expr.c,v 1.7 1999/09/14 08:35:16 espie Exp $	*/
d44 1
a44 1
static char rcsid[] = "$OpenBSD: expr.c,v 1.7 1999/09/14 08:35:16 espie Exp $";
d519 1
a519 1
				if (base != OCTAL) 
@


1.7
log
@Style: kill register and indent properly.
Let indx match netbsd flavor, to simplify diffs.
Show how many quotes were not closed.
Increase stack slightly, now that we're no longer bound by argspace.
@
text
@d1 1
a1 1
/*	$OpenBSD: expr.c,v 1.4 1998/04/25 18:47:19 millert Exp $	*/
d44 1
a44 1
static char rcsid[] = "$OpenBSD: expr.c,v 1.4 1998/04/25 18:47:19 millert Exp $";
d341 4
a344 1
			vl /= vr;
d347 4
a350 1
			vl %= vr;
@


1.6
log
@-I works better when activated...

Fuss with prototypes.
@
text
@d1 1
a1 1
/*	$OpenBSD: expr.c,v 1.5 1999/09/14 08:26:10 espie Exp $	*/
d44 1
a44 1
static char rcsid[] = "$OpenBSD: expr.c,v 1.5 1999/09/14 08:26:10 espie Exp $";
d142 1
a142 1
char *expbuf;
d144 1
a144 1
	register int rval;
d164 1
a164 1
	register int bool, true_val, false_val;
d186 1
a186 1
	register int c, vl, vr;
d206 1
a206 1
	register int c, vl, vr;
d226 1
a226 1
	register int val, c;
d246 1
a246 1
	register int vl, vr, eqrel;
d284 1
a284 1
	register int vl, vr, c;
d308 1
a308 1
	register int c, vl, vr;
d330 1
a330 1
	register int c, vl, vr;
d358 1
a358 1
	register int c, vl, vr, n;
d387 1
a387 1
	register int val, c;
d412 1
a412 1
	register int val;
d432 3
a434 3
	register int i;
	register int value;
	register int c;
d493 1
a493 1
	register int rval, c, base;
a542 1

d551 1
a551 1
	register int c1, c2;
d595 1
a595 1
	register int c;
d608 1
a608 1
char *msg;
@


1.5
log
@Add support for hex constants.
Not the same code as NetBSD.
@
text
@d1 1
a1 1
/*	$OpenBSD: expr.c,v 1.4 1998/04/25 18:47:19 millert Exp $	*/
d44 1
a44 1
static char rcsid[] = "$OpenBSD: expr.c,v 1.4 1998/04/25 18:47:19 millert Exp $";
d50 1
@


1.4
log
@-Wall
@
text
@d1 1
a1 1
/*	$OpenBSD: expr.c,v 1.3 1997/10/24 00:56:53 millert Exp $	*/
d44 1
a44 1
static char rcsid[] = "$OpenBSD: expr.c,v 1.3 1997/10/24 00:56:53 millert Exp $";
d50 1
a95 3
#define TRUE    1
#define FALSE   0
#define EOS     (char) 0
d104 1
a494 1
	base = ((c = skipws()) == '0') ? OCTAL : DECIMAL;
d497 35
a531 3
	while (c >= '0' && c <= (base == OCTAL ? '7' : '9')) {
		rval *= base;
		rval += (c - '0');
d535 1
@


1.3
log
@Use int not char in two places.  Noted by Dale.
@
text
@d1 1
a1 1
/*	$OpenBSD: expr.c,v 1.2 1996/06/26 05:36:11 deraadt Exp $	*/
d44 1
a44 1
static char rcsid[] = "$OpenBSD: expr.c,v 1.2 1996/06/26 05:36:11 deraadt Exp $";
d358 1
a358 1
	register c, vl, vr, n;
@


1.2
log
@rcsid
@
text
@d1 1
a1 1
/*	$OpenBSD: expr.c,v 1.7 1995/09/28 05:37:31 tls Exp $	*/
d44 1
a44 1
static char rcsid[] = "$OpenBSD: expr.c,v 1.7 1995/09/28 05:37:31 tls Exp $";
d434 1
a434 1
	register char c;
d564 1
a564 1
	register char c;
@


1.1
log
@Initial revision
@
text
@d1 1
d44 1
a44 1
static char rcsid[] = "$NetBSD: expr.c,v 1.7 1995/09/28 05:37:31 tls Exp $";
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@
