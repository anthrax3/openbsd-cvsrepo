head	1.47;
access;
symbols
	OPENBSD_6_2:1.47.0.4
	OPENBSD_6_2_BASE:1.47
	OPENBSD_6_1:1.46.0.8
	OPENBSD_6_1_BASE:1.46
	OPENBSD_6_0:1.46.0.4
	OPENBSD_6_0_BASE:1.46
	OPENBSD_5_9:1.46.0.2
	OPENBSD_5_9_BASE:1.46
	OPENBSD_5_8:1.45.0.6
	OPENBSD_5_8_BASE:1.45
	OPENBSD_5_7:1.45.0.2
	OPENBSD_5_7_BASE:1.45
	OPENBSD_5_6:1.44.0.4
	OPENBSD_5_6_BASE:1.44
	OPENBSD_5_5:1.42.0.16
	OPENBSD_5_5_BASE:1.42
	OPENBSD_5_4:1.42.0.12
	OPENBSD_5_4_BASE:1.42
	OPENBSD_5_3:1.42.0.10
	OPENBSD_5_3_BASE:1.42
	OPENBSD_5_2:1.42.0.8
	OPENBSD_5_2_BASE:1.42
	OPENBSD_5_1_BASE:1.42
	OPENBSD_5_1:1.42.0.6
	OPENBSD_5_0:1.42.0.4
	OPENBSD_5_0_BASE:1.42
	OPENBSD_4_9:1.42.0.2
	OPENBSD_4_9_BASE:1.42
	OPENBSD_4_8:1.41.0.4
	OPENBSD_4_8_BASE:1.41
	OPENBSD_4_7:1.41.0.2
	OPENBSD_4_7_BASE:1.41
	OPENBSD_4_6:1.40.0.6
	OPENBSD_4_6_BASE:1.40
	OPENBSD_4_5:1.40.0.2
	OPENBSD_4_5_BASE:1.40
	OPENBSD_4_4:1.37.0.6
	OPENBSD_4_4_BASE:1.37
	OPENBSD_4_3:1.37.0.4
	OPENBSD_4_3_BASE:1.37
	OPENBSD_4_2:1.37.0.2
	OPENBSD_4_2_BASE:1.37
	OPENBSD_4_1:1.36.0.2
	OPENBSD_4_1_BASE:1.36
	OPENBSD_4_0:1.35.0.2
	OPENBSD_4_0_BASE:1.35
	OPENBSD_3_9:1.34.0.2
	OPENBSD_3_9_BASE:1.34
	OPENBSD_3_8:1.32.0.2
	OPENBSD_3_8_BASE:1.32
	OPENBSD_3_7:1.30.0.6
	OPENBSD_3_7_BASE:1.30
	OPENBSD_3_6:1.30.0.4
	OPENBSD_3_6_BASE:1.30
	OPENBSD_3_5:1.30.0.2
	OPENBSD_3_5_BASE:1.30
	OPENBSD_3_4:1.29.0.2
	OPENBSD_3_4_BASE:1.29
	OPENBSD_3_3:1.28.0.4
	OPENBSD_3_3_BASE:1.28
	OPENBSD_3_2:1.28.0.2
	OPENBSD_3_2_BASE:1.28
	OPENBSD_3_1:1.26.0.2
	OPENBSD_3_1_BASE:1.26
	OPENBSD_3_0:1.25.0.2
	OPENBSD_3_0_BASE:1.25
	OPENBSD_2_9_BASE:1.20
	OPENBSD_2_9:1.20.0.4
	OPENBSD_2_8:1.20.0.2
	OPENBSD_2_8_BASE:1.20
	OPENBSD_2_7:1.18.0.2
	OPENBSD_2_7_BASE:1.18
	OPENBSD_2_6:1.12.0.2
	OPENBSD_2_6_BASE:1.12
	OPENBSD_2_5:1.6.0.6
	OPENBSD_2_5_BASE:1.6
	OPENBSD_2_4:1.6.0.4
	OPENBSD_2_4_BASE:1.6
	OPENBSD_2_3:1.6.0.2
	OPENBSD_2_3_BASE:1.6
	OPENBSD_2_2:1.5.0.2
	OPENBSD_2_2_BASE:1.5
	OPENBSD_2_1:1.4.0.4
	OPENBSD_2_1_BASE:1.4
	OPENBSD_2_0:1.4.0.2
	OPENBSD_2_0_BASE:1.4
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.47
date	2017.06.15.13.48.42;	author bcallah;	state Exp;
branches;
next	1.46;
commitid	cJah5U98w19KunxL;

1.46
date	2015.12.07.14.12.46;	author espie;	state Exp;
branches;
next	1.45;
commitid	ULpALTuvn5Njx3Br;

1.45
date	2014.12.21.09.33.12;	author espie;	state Exp;
branches;
next	1.44;
commitid	cEHdgjDE2j8bVm3K;

1.44
date	2014.05.12.19.11.19;	author espie;	state Exp;
branches;
next	1.43;

1.43
date	2014.04.28.12.34.11;	author espie;	state Exp;
branches;
next	1.42;

1.42
date	2010.09.07.19.58.09;	author marco;	state Exp;
branches;
next	1.41;

1.41
date	2009.10.14.17.19.47;	author sthen;	state Exp;
branches;
next	1.40;

1.40
date	2008.08.21.20.59.14;	author espie;	state Exp;
branches;
next	1.39;

1.39
date	2008.08.16.12.23.50;	author espie;	state Exp;
branches;
next	1.38;

1.38
date	2008.08.16.12.21.46;	author espie;	state Exp;
branches;
next	1.37;

1.37
date	2007.05.05.03.42.49;	author ray;	state Exp;
branches;
next	1.36;

1.36
date	2006.12.12.21.16.18;	author jmc;	state Exp;
branches;
next	1.35;

1.35
date	2006.03.20.10.55.19;	author espie;	state Exp;
branches;
next	1.34;

1.34
date	2005.09.07.13.22.24;	author jmc;	state Exp;
branches;
next	1.33;

1.33
date	2005.09.06.15.33.21;	author espie;	state Exp;
branches;
next	1.32;

1.32
date	2005.08.06.16.22.26;	author espie;	state Exp;
branches;
next	1.31;

1.31
date	2005.05.29.18.44.36;	author espie;	state Exp;
branches;
next	1.30;

1.30
date	2003.11.17.17.12.10;	author espie;	state Exp;
branches;
next	1.29;

1.29
date	2003.06.03.02.56.10;	author millert;	state Exp;
branches;
next	1.28;

1.28
date	2002.04.28.14.37.12;	author espie;	state Exp;
branches;
next	1.27;

1.27
date	2002.04.26.16.15.16;	author espie;	state Exp;
branches;
next	1.26;

1.26
date	2001.11.16.23.50.40;	author deraadt;	state Exp;
branches;
next	1.25;

1.25
date	2001.10.10.11.17.37;	author espie;	state Exp;
branches;
next	1.24;

1.24
date	2001.09.19.13.14.18;	author espie;	state Exp;
branches;
next	1.23;

1.23
date	2001.09.18.15.46.39;	author espie;	state Exp;
branches;
next	1.22;

1.22
date	2001.09.18.14.43.23;	author espie;	state Exp;
branches;
next	1.21;

1.21
date	2001.07.18.16.18.17;	author espie;	state Exp;
branches;
next	1.20;

1.20
date	2000.07.27.17.44.33;	author espie;	state Exp;
branches;
next	1.19;

1.19
date	2000.07.02.01.17.00;	author espie;	state Exp;
branches;
next	1.18;

1.18
date	2000.03.11.15.54.44;	author espie;	state Exp;
branches;
next	1.17;

1.17
date	2000.01.15.14.26.00;	author espie;	state Exp;
branches;
next	1.16;

1.16
date	2000.01.13.17.35.10;	author espie;	state Exp;
branches;
next	1.15;

1.15
date	2000.01.12.17.49.53;	author espie;	state Exp;
branches;
next	1.14;

1.14
date	99.11.17.15.34.13;	author espie;	state Exp;
branches;
next	1.13;

1.13
date	99.11.17.14.51.05;	author espie;	state Exp;
branches;
next	1.12;

1.12
date	99.09.14.08.35.17;	author espie;	state Exp;
branches;
next	1.11;

1.11
date	99.09.14.08.21.37;	author espie;	state Exp;
branches;
next	1.10;

1.10
date	99.09.09.22.18.19;	author espie;	state Exp;
branches;
next	1.9;

1.9
date	99.09.06.13.29.32;	author espie;	state Exp;
branches;
next	1.8;

1.8
date	99.09.06.13.20.40;	author espie;	state Exp;
branches;
next	1.7;

1.7
date	99.09.06.13.10.49;	author espie;	state Exp;
branches;
next	1.6;

1.6
date	97.12.10.20.24.17;	author deraadt;	state Exp;
branches;
next	1.5;

1.5
date	97.07.25.21.05.32;	author mickey;	state Exp;
branches;
next	1.4;

1.4
date	96.07.01.20.40.28;	author deraadt;	state Exp;
branches;
next	1.3;

1.3
date	96.06.26.05.36.15;	author deraadt;	state Exp;
branches;
next	1.2;

1.2
date	96.06.25.20.50.08;	author deraadt;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.45.36;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.45.36;	author deraadt;	state Exp;
branches;
next	;


desc
@@


1.47
log
@Add -E flag (make warnings fatal), following the behavior of GNU m4 1.4.9+
Help and direction millert@@ espie@@ anton@@ deraadt@@

ok espie@@
@
text
@/*	$OpenBSD: misc.c,v 1.46 2015/12/07 14:12:46 espie Exp $	*/
/*	$NetBSD: misc.c,v 1.6 1995/09/28 05:37:41 tls Exp $	*/

/*
 * Copyright (c) 1989, 1993
 *	The Regents of the University of California.  All rights reserved.
 *
 * This code is derived from software contributed to Berkeley by
 * Ozan Yigit at York University.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */

#include <sys/types.h>
#include <errno.h>
#include <unistd.h>
#include <stdarg.h>
#include <stdio.h>
#include <stdint.h>
#include <stdlib.h>
#include <stddef.h>
#include <string.h>
#include <err.h>
#include "mdef.h"
#include "stdd.h"
#include "extern.h"
#include "pathnames.h"


char *ep;		/* first free char in strspace */
static char *strspace;	/* string space for evaluation */
char *endest;		/* end of string space	       */
static size_t strsize = STRSPMAX;
static size_t bufsize = BUFSIZE;

unsigned char *buf;			/* push-back buffer	       */
unsigned char *bufbase;			/* the base for current ilevel */
unsigned char *bbase[MAXINP];		/* the base for each ilevel    */
unsigned char *bp;			/* first available character   */
unsigned char *endpbb;			/* end of push-back buffer     */


/*
 * find the index of second str in the first str.
 */
ptrdiff_t
indx(const char *s1, const char *s2)
{
	char *t;

	t = strstr(s1, s2);
	if (t == NULL)
		return (-1);
	else
		return (t - s1);
}
/*
 *  pushback - push character back onto input
 */
void
pushback(int c)
{
	if (c == EOF)
		return;
	if (bp >= endpbb)
		enlarge_bufspace();
	*bp++ = c;
}

/*
 *  pbstr - push string back onto input
 *          pushback is replicated to improve
 *          performance.
 */
void
pbstr(const char *s)
{
	size_t n;

	n = strlen(s);
	while (endpbb - bp <= n)
		enlarge_bufspace();
	while (n > 0)
		*bp++ = s[--n];
}

/*
 *  pbnum - convert number to string, push back on input.
 */
void
pbnum(int n)
{
	pbnumbase(n, 10, 0);
}

void
pbnumbase(int n, int base, int d)
{
	static char digits[36] = "0123456789abcdefghijklmnopqrstuvwxyz";
	int num;
	int printed = 0;

	if (base > 36)
		m4errx(1, "base %d > 36: not supported.", base);

	if (base < 2)
		m4errx(1, "bad base %d for conversion.", base);

	num = (n < 0) ? -n : n;
	do {
		pushback(digits[num % base]);
		printed++;
	}
	while ((num /= base) > 0);

	if (n < 0)
		printed++;
	while (printed++ < d)
		pushback('0');

	if (n < 0)
		pushback('-');
}

/*
 *  pbunsigned - convert unsigned long to string, push back on input.
 */
void
pbunsigned(unsigned long n)
{
	do {
		pushback(n % 10 + '0');
	}
	while ((n /= 10) > 0);
}

void
initspaces()
{
	int i;

	strspace = xalloc(strsize+1, NULL);
	ep = strspace;
	endest = strspace+strsize;
	buf = xalloc(bufsize, NULL);
	bufbase = buf;
	bp = buf;
	endpbb = buf + bufsize;
	for (i = 0; i < MAXINP; i++)
		bbase[i] = buf;
}

void
enlarge_strspace()
{
	char *newstrspace;
	int i;

	strsize *= 2;
	newstrspace = malloc(strsize + 1);
	if (!newstrspace)
		errx(1, "string space overflow");
	memcpy(newstrspace, strspace, strsize/2);
	for (i = 0; i <= sp; i++)
		if (sstack[i] == STORAGE_STRSPACE)
			mstack[i].sstr = (mstack[i].sstr - strspace)
			    + newstrspace;
	ep = (ep-strspace) + newstrspace;
	free(strspace);
	strspace = newstrspace;
	endest = strspace + strsize;
}

void
enlarge_bufspace()
{
	unsigned char *newbuf;
	int i;

	bufsize += bufsize/2;
	newbuf = xrealloc(buf, bufsize, "too many characters pushed back");
	for (i = 0; i < MAXINP; i++)
		bbase[i] = (bbase[i]-buf)+newbuf;
	bp = (bp-buf)+newbuf;
	bufbase = (bufbase-buf)+newbuf;
	buf = newbuf;
	endpbb = buf+bufsize;
}

/*
 *  chrsave - put single char on string space
 */
void
chrsave(int c)
{
	if (ep >= endest)
		enlarge_strspace();
	*ep++ = c;
}

/*
 * read in a diversion file, and dispose it.
 */
void
getdiv(int n)
{
	int c;

	if (active == outfile[n])
		m4errx(1, "undivert: diversion still active.");
	rewind(outfile[n]);
	while ((c = getc(outfile[n])) != EOF)
		putc(c, active);
	(void) fclose(outfile[n]);
	outfile[n] = NULL;
}

void
onintr(int signo)
{
#define intrmessage	"m4: interrupted.\n"
	write(STDERR_FILENO, intrmessage, sizeof(intrmessage)-1);
	_exit(1);
}

/*
 * killdiv - get rid of the diversion files
 */
void
killdiv()
{
	int n;

	for (n = 0; n < maxout; n++)
		if (outfile[n] != NULL) {
			(void) fclose(outfile[n]);
		}
}

extern char *__progname;

void
m4errx(int eval, const char *fmt, ...)
{
	fprintf(stderr, "%s: ", __progname);
	fprintf(stderr, "%s at line %lu: ", CURRENT_NAME, CURRENT_LINE);
	if (fmt != NULL) {
		va_list ap;

		va_start(ap, fmt);
		vfprintf(stderr, fmt, ap);
		va_end(ap);
	}
	fprintf(stderr, "\n");
	exit(eval);
}

/*
 * resizedivs: allocate more diversion files */
void
resizedivs(int n)
{
	int i;

	outfile = xreallocarray(outfile, n, sizeof(FILE *),
	    "too many diverts %d", n);
	for (i = maxout; i < n; i++)
		outfile[i] = NULL;
	maxout = n;
}

void *
xalloc(size_t n, const char *fmt, ...)
{
	void *p = malloc(n);

	if (p == NULL) {
		if (fmt == NULL)
			err(1, "malloc");
		else {
			va_list va;

			va_start(va, fmt);
			verr(1, fmt, va);
			va_end(va);
		}
	}
	return p;
}

void *
xcalloc(size_t n, size_t s, const char *fmt, ...)
{
	void *p = calloc(n, s);

	if (p == NULL) {
		if (fmt == NULL)
			err(1, "calloc");
		else {
			va_list va;

			va_start(va, fmt);
			verr(1, fmt, va);
			va_end(va);
		}
	}
	return p;
}

void *
xrealloc(void *old, size_t n, const char *fmt, ...)
{
	char *p = realloc(old, n);

	if (p == NULL) {
		free(old);
		if (fmt == NULL)
			err(1, "realloc");
		else {
			va_list va;

			va_start(va, fmt);
			verr(1, fmt, va);
			va_end(va);
		}
	}
	return p;
}

void *
xreallocarray(void *old, size_t s1, size_t s2, const char *fmt, ...)
{
	void *p = reallocarray(old, s1, s2);

	if (p == NULL) {
		free(old);
		if (fmt == NULL)
			err(1, "reallocarray");
		else {
			va_list va;

			va_start(va, fmt);
			verr(1, fmt, va);
			va_end(va);
		}
	}
	return p;
}

char *
xstrdup(const char *s)
{
	char *p = strdup(s);
	if (p == NULL)
		err(1, "strdup");
	return p;
}

void
usage(void)
{
	fprintf(stderr, "usage: m4 [-EgPs] [-Dname[=value]] [-d flags] "
			"[-I dirname] [-o filename]\n"
			"\t[-t macro] [-Uname] [file ...]\n");
	exit(1);
}

int
obtain_char(struct input_file *f)
{
	if (f->c == EOF)
		return EOF;

	f->c = fgetc(f->file);
	if (f->c == '\n')
		f->lineno++;

	return f->c;
}

void
set_input(struct input_file *f, FILE *real, const char *name)
{
	f->file = real;
	f->lineno = 1;
	f->c = 0;
	f->name = xstrdup(name);
	emit_synchline();
}

void
do_emit_synchline()
{
	fprintf(active, "#line %lu \"%s\"\n",
	    infile[ilevel].lineno, infile[ilevel].name);
	infile[ilevel].synch_lineno = infile[ilevel].lineno;
}

void
release_input(struct input_file *f)
{
	if (ferror(f->file))
		errx(1, "Fatal error reading from %s\n", f->name);
	if (f->file != stdin)
	    fclose(f->file);
	f->c = EOF;
	/*
	 * XXX can't free filename, as there might still be
	 * error information pointing to it.
	 */
}

void
doprintlineno(struct input_file *f)
{
	pbunsigned(f->lineno);
}

void
doprintfilename(struct input_file *f)
{
	pbstr(rquote);
	pbstr(f->name);
	pbstr(lquote);
}

/*
 * buffer_mark/dump_buffer: allows one to save a mark in a buffer,
 * and later dump everything that was added since then to a file.
 */
size_t
buffer_mark()
{
	return bp - buf;
}


void
dump_buffer(FILE *f, size_t m)
{
	unsigned char *s;

	for (s = bp; s-buf > m;)
		fputc(*--s, f);
}
@


1.46
log
@Yet another missed ferror call
@
text
@d1 1
a1 1
/*	$OpenBSD: misc.c,v 1.45 2014/12/21 09:33:12 espie Exp $	*/
d382 1
a382 1
usage()
d384 1
a384 1
	fprintf(stderr, "usage: m4 [-gPs] [-Dname[=value]] [-d flags] "
@


1.45
log
@fix test-redef2:
- introduce explicit STORAGE classes for the shadow stack entries
- delay freeing definitions if they're in-use, keep them in a simple array.

okay millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: misc.c,v 1.44 2014/05/12 19:11:19 espie Exp $	*/
d424 2
@


1.44
log
@adjust to ohash being in libutil now, and to the interface changes.
fix potential integer overflows in memory allocation (mostly for pedagogical
purposes, these are unlikely to overflow in practice)
move the rest of lst.lib stuff into its own directory.
@
text
@d1 1
a1 1
/*	$OpenBSD: misc.c,v 1.43 2014/04/28 12:34:11 espie Exp $	*/
d187 1
a187 1
		if (sstack[i])
@


1.43
log
@check for integer overflows in custom allocs, okay jca@@
@
text
@d1 1
a1 1
/*	$OpenBSD: misc.c,v 1.42 2010/09/07 19:58:09 marco Exp $	*/
d314 1
a314 1
xallocarray(size_t s1, size_t s2, const char *fmt, ...)
d316 1
a316 8
	void *p;

	if (s1 && SIZE_MAX / s1 < s2) {
		errno = ENOMEM;
		p = NULL;
	} else {
		p = malloc(s1 * s2);
	}
d320 1
a320 1
			err(1, "malloc");
d355 1
a355 8
	void *p;

	if (s1 && SIZE_MAX / s1 < s2) {
		errno = ENOMEM;
		p = NULL;
	} else {
		p = realloc(old, s1 * s2);
	}
d360 1
a360 1
			err(1, "realloc");
@


1.42
log
@Remove stray spaces.  No code change.
@
text
@d1 1
a1 1
/*	$OpenBSD: misc.c,v 1.41 2009/10/14 17:19:47 sthen Exp $	*/
d41 1
d167 1
a167 1
	buf = (unsigned char *)xalloc(bufsize, NULL);
d287 1
a287 1
	outfile = (FILE **)xrealloc(outfile, sizeof(FILE *) * n,
d314 26
d343 27
@


1.41
log
@Support the -P option from gnu m4, which prefixes builtins with the
string m4_. Feedback from jmc@@, Tobias Ulmer, Matthew Dempsky - thanks!
ok espie@@
@
text
@d1 1
a1 1
/*	$OpenBSD: misc.c,v 1.40 2008/08/21 20:59:14 espie Exp $	*/
d60 1
a60 1
unsigned char *bp; 			/* first available character   */
d158 1
a158 1
void 
d174 1
a174 1
void 
d185 1
a185 1
	for (i = 0; i <= sp; i++) 
d187 1
a187 1
			mstack[i].sstr = (mstack[i].sstr - strspace) 
d217 1
a217 1
	if (ep >= endest) 
d286 1
a286 1
	outfile = (FILE **)xrealloc(outfile, sizeof(FILE *) * n, 
d303 1
a303 1
			
d327 1
a327 1
	    	}
d350 1
a350 1
int 
d363 1
a363 1
void 
d381 1
a381 1
void 
d388 1
a388 1
	 * XXX can't free filename, as there might still be 
d407 1
a407 1
/* 
@


1.40
log
@use unsigned char for buffers, allow differentiating between EOF and y".

okay otto@@
@
text
@d1 1
a1 1
/*	$OpenBSD: misc.c,v 1.39 2008/08/16 12:23:50 espie Exp $	*/
d344 1
a344 1
	fprintf(stderr, "usage: m4 [-gs] [-Dname[=value]] [-d flags] "
@


1.39
log
@not yet, committed too much
@
text
@d1 1
a1 1
/*	$OpenBSD: misc.c,v 1.37 2007/05/05 03:42:49 ray Exp $	*/
d57 5
a61 5
char *buf;			/* push-back buffer	       */
char *bufbase;			/* the base for current ilevel */
char *bbase[MAXINP];		/* the base for each ilevel    */
char *bp; 			/* first available character   */
char *endpbb;			/* end of push-back buffer     */
d166 1
a166 1
	buf = (char *)xalloc(bufsize, NULL);
d198 1
a198 1
	char *newbuf;
d421 1
a421 1
	char *s;
@


1.38
log
@argument parsing should only skip spaces outside of parenthesis.
Inside matching parenthesis, keep spaces as is (use chrsave instead of
pbstr, since there's no way it can be a further macro expansion).
Fixes a long-standing issue with autoconf (   --option -> --option),
matches other m4 than gnum4

okay millert@@, fries@@
@
text
@d57 5
a61 5
unsigned char *buf;			/* push-back buffer	       */
unsigned char *bufbase;			/* the base for current ilevel */
unsigned char *bbase[MAXINP];		/* the base for each ilevel    */
unsigned char *bp; 			/* first available character   */
unsigned char *endpbb;			/* end of push-back buffer     */
d166 1
a166 1
	buf = (unsigned char *)xalloc(bufsize, NULL);
d198 1
a198 1
	unsigned char *newbuf;
d421 1
a421 1
	unsigned char *s;
@


1.37
log
@Localize variables and don't do anything after exit().

OK espie@@, moritz@@, and jaredy@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: misc.c,v 1.36 2006/12/12 21:16:18 jmc Exp $	*/
d57 5
a61 5
char *buf;			/* push-back buffer	       */
char *bufbase;			/* the base for current ilevel */
char *bbase[MAXINP];		/* the base for each ilevel    */
char *bp; 			/* first available character   */
char *endpbb;			/* end of push-back buffer     */
d166 1
a166 1
	buf = (char *)xalloc(bufsize, NULL);
d198 1
a198 1
	char *newbuf;
d421 1
a421 1
	char *s;
@


1.36
log
@tweak previous, and update usage(); ok grunk
@
text
@d1 1
a1 1
/*	$OpenBSD: misc.c,v 1.35 2006/03/20 10:55:19 espie Exp $	*/
a265 3
	va_list ap;

	va_start(ap, fmt);
d268 4
a271 1
	if (fmt != NULL)
d273 2
a276 1
	va_end(ap);
@


1.35
log
@report function m4errx, that shows app-specific data (filename/linenumber)
before the error message. Use it to simplify code.

okay miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: misc.c,v 1.34 2005/09/07 13:22:24 jmc Exp $	*/
d343 3
a345 1
	fprintf(stderr, "usage: m4 [-gs] [-Dname[=value]] [-d flags] [-I dirname] [-o filename] [-t macro] [-Uname]\n");
@


1.34
log
@sort options and sync usage()
@
text
@d1 1
a1 1
/*	$OpenBSD: misc.c,v 1.33 2005/09/06 15:33:21 espie Exp $	*/
d125 1
a125 1
		errx(1, "base %d > 36: not supported", base);
d128 1
a128 1
		errx(1, "bad base %d for conversion", base);
d231 1
a231 1
		errx(1, "undivert: diversion still active");
d259 17
@


1.33
log
@finally make our m4 SusV3-compliant.

- changecom and changequote have a simple definition (that matches gnu-m4,
coincidentally, so we no longer need two distinct modes for these)

- off-by-one bug in -s, this finally works.

- reorder main parser loop, so that we can use alphabetic constructs in
quotes/comments.

- rename putback to pushback, this matches comments, and makes more sense.

- more uniform (and updated) description of changequote/changecom.

- new, systematic regression tests of comments/quotes.

- framework to test -s: one perl script to reconstitute `full' files with
all line numbers, so that we can verify the output without needing a
complete match.

okay otto@@, fries@@
@
text
@d1 1
a1 1
/*	$OpenBSD: misc.c,v 1.32 2005/08/06 16:22:26 espie Exp $	*/
d326 1
a326 1
	fprintf(stderr, "usage: m4 [-gs] [-d flags] [-t macro] [-o file] [-Dname[=val]] [-Uname] [-I dirname...]\n");
@


1.32
log
@zap rcsid. It's not ramdisk, but they still take space.
@
text
@d1 1
a1 1
/*	$OpenBSD: misc.c,v 1.31 2005/05/29 18:44:36 espie Exp $	*/
d79 1
a79 1
 *  putback - push character back onto input
d82 1
a82 1
putback(int c)
d93 1
a93 1
 *          putback is replicated to improve
d132 1
a132 1
		putback(digits[num % base]);
d140 1
a140 1
		putback('0');
d143 1
a143 1
		putback('-');
d153 1
a153 1
		putback(n % 10 + '0');
d335 3
a337 1
	else if (f->c == '\n')
a339 1
	f->c = fgetc(f->file);
@


1.31
log
@fix a few minor compatibility issues.
- let eval() handle a base and number of digits, like it's advertized to.
- in gnu-mode, undivert can take file names as arguments.
- in gnu-mode, map can handle reversed charsets.

Suggestions and okay otto@@, mostly prompted by looking at the regress
tests in newer gnu-m4.
@
text
@d1 1
a1 1
/*	$OpenBSD: misc.c,v 1.30 2003/11/17 17:12:10 espie Exp $	*/
a34 8

#ifndef lint
#if 0
static char sccsid[] = "@@(#)misc.c	8.1 (Berkeley) 6/6/93";
#else
static char rcsid[] = "$OpenBSD: misc.c,v 1.30 2003/11/17 17:12:10 espie Exp $";
#endif
#endif /* not lint */
@


1.30
log
@Modify xalloc so that it also takes err(3)-like arguments.
Write an xrealloc wrapper that works the same way, and use it as well.

People who feel like it may want to add more explicit error messages to
all the places m4 can fail allocating memory...

okay tedu@@
@
text
@d1 1
a1 1
/*	$OpenBSD: misc.c,v 1.29 2003/06/03 02:56:10 millert Exp $	*/
d40 1
a40 1
static char rcsid[] = "$OpenBSD: misc.c,v 1.29 2003/06/03 02:56:10 millert Exp $";
d122 7
d130 7
d140 2
a141 1
		putback(num % 10 + '0');
d143 6
a148 1
	while ((num /= 10) > 0);
@


1.29
log
@Remove the advertising clause in the UCB license which Berkeley
rescinded 22 July 1999.  Proofed by myself and Theo.
@
text
@d1 1
a1 1
/*	$OpenBSD: misc.c,v 1.28 2002/04/28 14:37:12 espie Exp $	*/
d40 1
a40 1
static char rcsid[] = "$OpenBSD: misc.c,v 1.28 2002/04/28 14:37:12 espie Exp $";
d47 1
d151 1
a151 1
	strspace = xalloc(strsize+1);
d154 1
a154 1
	buf = (char *)xalloc(bufsize);
d189 2
a190 4
	bufsize *= 2;
	newbuf = realloc(buf, bufsize);
	if (!newbuf)
		errx(1, "too many characters pushed back");
d256 2
a257 3
	outfile = (FILE **)realloc(outfile, sizeof(FILE *) * n);
	if (outfile == NULL)
		    errx(1, "too many diverts %d", n);
d264 1
a264 1
xalloc(size_t n)
d266 1
a266 1
	char *p = malloc(n);
d268 31
a298 2
	if (p == NULL)
		err(1, "malloc");
@


1.28
log
@Implement -s.
Triggered by recent FreeBSD changes.

- emits #line directives at every file change (like FreeBSD)
- maintains a synch_lineno variable to verify when the output gets out
of synch with the input, so that it can emit #line to re-synch as well
(unlike FreeBSD)

To do: either handle \end-of-line, or recognize when a macro expansion
is in progress, so that line synch don't perturb cpp on multi-line
expansions.

With this, we should have a fully POSIX-compliant m4.

ok miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: misc.c,v 1.27 2002/04/26 16:15:16 espie Exp $	*/
d19 1
a19 5
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
d40 1
a40 1
static char rcsid[] = "$OpenBSD: misc.c,v 1.27 2002/04/26 16:15:16 espie Exp $";
@


1.27
log
@use ansi function declarations. ok millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: misc.c,v 1.26 2001/11/16 23:50:40 deraadt Exp $	*/
d44 1
a44 1
static char rcsid[] = "$OpenBSD: misc.c,v 1.26 2001/11/16 23:50:40 deraadt Exp $";
d291 1
a291 1
	fprintf(stderr, "usage: m4 [-Dname[=val]] [-Uname] [-I dirname...]\n");
d314 9
@


1.26
log
@incorrect write
@
text
@d1 1
a1 1
/*	$OpenBSD: misc.c,v 1.25 2001/10/10 11:17:37 espie Exp $	*/
d44 1
a44 1
static char rcsid[] = "$OpenBSD: misc.c,v 1.25 2001/10/10 11:17:37 espie Exp $";
d79 1
a79 3
indx(s1, s2)
	const char *s1;
	const char *s2;
d93 1
a93 2
putback(c)
	int c;
d108 1
a108 2
pbstr(s)
	const char *s;
d123 1
a123 2
pbnum(n)
	int n;
d141 1
a141 2
pbunsigned(n)
	unsigned long n;
d208 1
a208 2
chrsave(c)
	int c;
d219 1
a219 2
getdiv(n)
	int n;
d233 1
a233 2
onintr(signo)
	int signo;
d257 1
a257 2
resizedivs(n)
	int n;
d270 1
a270 2
xalloc(n)
	size_t n;
d280 1
a280 2
xstrdup(s)
	const char *s;
d296 1
a296 2
obtain_char(f)
	struct input_file *f;
d308 1
a308 4
set_input(f, real, name)
	struct input_file *f;
	FILE *real;
	const char *name;
d317 1
a317 2
release_input(f)
	struct input_file *f;
d329 1
a329 2
doprintlineno(f)
	struct input_file *f;
d335 1
a335 2
doprintfilename(f)
	struct input_file *f;
d354 1
a354 3
dump_buffer(f, m)
	FILE *f;
	size_t m;
@


1.25
log
@Quote filename properly.
@
text
@d1 1
a1 1
/*	$OpenBSD: misc.c,v 1.24 2001/09/19 13:14:18 espie Exp $	*/
d44 1
a44 1
static char rcsid[] = "$OpenBSD: misc.c,v 1.24 2001/09/19 13:14:18 espie Exp $";
d245 1
a245 1
	write(STDERR_FILENO, intrmessage, sizeof(intrmessage));
@


1.24
log
@inline some very common putback/chrsave. Worth roughly 10%
@
text
@d1 1
a1 1
/*	$OpenBSD: misc.c,v 1.23 2001/09/18 15:46:39 espie Exp $	*/
d44 1
a44 1
static char rcsid[] = "$OpenBSD: misc.c,v 1.23 2001/09/18 15:46:39 espie Exp $";
d356 1
d358 1
@


1.23
log
@better end-condition, fix tracing of dnl.
@
text
@d1 1
a1 1
/*	$OpenBSD: misc.c,v 1.22 2001/09/18 14:43:23 espie Exp $	*/
d44 1
a44 1
static char rcsid[] = "$OpenBSD: misc.c,v 1.22 2001/09/18 14:43:23 espie Exp $";
d64 1
a64 1
static char *endest;	/* end of string space	       */
d72 1
a72 1
static char *endpbb;			/* end of push-back buffer     */
a74 2
static void enlarge_bufspace __P((void));
static void enlarge_strspace __P((void));
d171 1
a171 1
static void 
d192 1
a192 1
static void
@


1.22
log
@instrumentation for tracing mode: macro expansion
@
text
@d1 1
a1 1
/*	$OpenBSD: misc.c,v 1.21 2001/07/18 16:18:17 espie Exp $	*/
d44 1
a44 1
static char rcsid[] = "$OpenBSD: misc.c,v 1.21 2001/07/18 16:18:17 espie Exp $";
d379 1
a379 1
	for (s = bp; s != buf + m;)
@


1.21
log
@Kill signal race. Reviewed by jjbg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: misc.c,v 1.20 2000/07/27 17:44:33 espie Exp $	*/
d44 1
a44 1
static char rcsid[] = "$OpenBSD: misc.c,v 1.20 2000/07/27 17:44:33 espie Exp $";
d359 22
@


1.20
log
@Handle unlimited diverts for m4 -g.

Problem with autoconf noticed by d@@
@
text
@d1 1
a1 1
/*	$OpenBSD: misc.c,v 1.19 2000/07/02 01:17:00 espie Exp $	*/
d44 1
a44 1
static char rcsid[] = "$OpenBSD: misc.c,v 1.19 2000/07/02 01:17:00 espie Exp $";
d246 3
a248 1
	errx(1, "interrupted.");
@


1.19
log
@Make the m4 machine stack dynamically sized.

Fix strspace automatic extension.
The assumption that simply updating the current pointer works is false,
there are cases where previous entries on the stack would absorp vast
amounts of string space, and overload the non-updated entries.

To fix it, we use a shadow copy of the stack, which only records which
entries are pointers within strspace, so that a resize can adjust all
those pointers at once.

Reviewed by millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: misc.c,v 1.18 2000/03/11 15:54:44 espie Exp $	*/
d44 1
a44 1
static char rcsid[] = "$OpenBSD: misc.c,v 1.18 2000/03/11 15:54:44 espie Exp $";
d257 1
a257 1
	for (n = 0; n < MAXOUT; n++)
d261 16
@


1.18
log
@Add a few builtins for greater compatibility with gnu-m4, and extended
functionality.
* regular expressions,
* line-number reporting
* `meta'-macros, builtin and indir.

Reviewed by pjanzen@@, tested by fries@@ and a few others.
@
text
@d1 1
a1 1
/*	$OpenBSD: misc.c,v 1.17 2000/01/15 14:26:00 espie Exp $	*/
d44 1
a44 1
static char rcsid[] = "$OpenBSD: misc.c,v 1.17 2000/01/15 14:26:00 espie Exp $";
a66 1
static int low_sp = 0;
a172 5
/* XXX when chrsave is called, the current argument is
 * always topmost on the stack.  We make use of this to
 * duplicate it transparently, and to reclaim the correct
 * space when the stack is unwound.
 */
d177 1
a178 1
	low_sp = sp;
d184 4
a187 4
		/* reclaim memory in the easy, common case. */
	if (ep == strspace)
		free(strspace);
	mstack[sp].sstr = (mstack[sp].sstr-strspace) + newstrspace;
d189 1
d194 1
a194 1
static void 
a221 16
}

/* 
 * so we reclaim what string space we can
 */
char * 
compute_prevep()
{
	if (fp+3 <= low_sp)
		{
		return strspace;
		}
	else
		{
		return mstack[fp+3].sstr;
		}
@


1.17
log
@There is no need to waste short for holding EOF in the pushback buffer.
Now that the input_file structure is sufficiently fleshed out, just stop
EOF at the putback level, and make sure files at EOF STAY at EOF.
@
text
@d1 1
a1 1
/*	$OpenBSD: misc.c,v 1.16 2000/01/13 17:35:10 espie Exp $	*/
d44 1
a44 1
static char rcsid[] = "$OpenBSD: misc.c,v 1.16 2000/01/13 17:35:10 espie Exp $";
d145 12
d284 1
a284 1
char *
d348 14
@


1.16
log
@Record 50 levels of open parenthesis, open quotes, to give a post-mortem.
- no need to record more, as this is just for diagnosis purpose. This
doesn't affect m4's main engine.
- don't free file names as a compromise: the only other options would be
to ref count them (not worth the complexity) or dup them systematically (ick).
@
text
@d1 1
a1 1
/*	$OpenBSD: misc.c,v 1.15 2000/01/12 17:49:53 espie Exp $	*/
d44 1
a44 1
static char rcsid[] = "$OpenBSD: misc.c,v 1.15 2000/01/12 17:49:53 espie Exp $";
d69 5
a73 5
pbent *buf;			/* push-back buffer	       */
pbent *bufbase;			/* the base for current ilevel */
pbent *bbase[MAXINP];		/* the base for each ilevel    */
pbent *bp; 			/* first available character   */
static pbent *endpbb;			/* end of push-back buffer     */
d99 1
a99 1
	pbent c;
d101 2
d154 1
a154 1
	buf = (pbent *)xalloc(bufsize * sizeof(pbent));
d167 2
a168 2
static
void enlarge_strspace()
d187 2
a188 2
static
void enlarge_bufspace()
d190 1
a190 1
	pbent *newbuf;
d194 1
a194 1
	newbuf = realloc(buf, bufsize*sizeof(pbent));
d304 3
a306 1
	if (f->c == '\n')
d331 1
@


1.15
log
@Use a proper abstract interface for file accesses, so that we can record
the file name and line number.

This yields more meaningful error messages, and the possibility for yet
more.
@
text
@d1 1
a1 1
/*	$OpenBSD: misc.c,v 1.14 1999/11/17 15:34:13 espie Exp $	*/
d44 1
a44 1
static char rcsid[] = "$OpenBSD: misc.c,v 1.14 1999/11/17 15:34:13 espie Exp $";
d327 4
a330 1
	free(f->name);
@


1.14
log
@Turn warnings on,
Add missing prototypes,
Make local functions static,
Sort extern.h by file,
Constify all char * that can be,
Copy temp file name so that eval does not modify its arguments.
@
text
@d1 1
a1 1
/*	$OpenBSD: misc.c,v 1.13 1999/11/17 14:51:05 espie Exp $	*/
d44 1
a44 1
static char rcsid[] = "$OpenBSD: misc.c,v 1.13 1999/11/17 14:51:05 espie Exp $";
d298 31
@


1.13
log
@Night of the moronic coder, part 2.

repairs patterns such as
divert(6)
divert(7)
undivert(6)
divert(6)

which are not that frequent, but were *quite* thoroughly broken...
@
text
@d1 1
a1 1
/*	$OpenBSD: misc.c,v 1.12 1999/09/14 08:35:17 espie Exp $	*/
d44 1
a44 1
static char rcsid[] = "$OpenBSD: misc.c,v 1.12 1999/09/14 08:35:17 espie Exp $";
d76 2
a77 2
static void enlarge_bufspace();
static void enlarge_strspace();
d113 1
a113 1
	char *s;
d208 1
a208 1
	char c;
d272 1
a272 1
	unsigned long n;
@


1.12
log
@Style: kill register and indent properly.
Let indx match netbsd flavor, to simplify diffs.
Show how many quotes were not closed.
Increase stack slightly, now that we're no longer bound by argspace.
@
text
@d1 1
a1 1
/*	$OpenBSD: misc.c,v 1.10 1999/09/09 22:18:19 espie Exp $	*/
d44 1
a44 1
static char rcsid[] = "$OpenBSD: misc.c,v 1.10 1999/09/09 22:18:19 espie Exp $";
d246 1
@


1.11
log
@Implement -I option and M4PATH environment variable
@
text
@d83 2
a84 2
const char *s1;
const char *s2;
d86 1
a86 1
	char *r;
d88 3
a90 3
	r = strstr(s1, s2);
	if (r)
		return (r - s1);
d92 1
a92 1
		return (-1);
d99 1
a99 1
pbent c;
d113 1
a113 1
register char *s;
d118 1
a118 1
	while (endpbb - bp < n)
d129 1
a129 1
int n;
d131 1
a131 1
	register int num;
d208 1
a208 1
char c;
d236 1
a236 1
int n;
d238 1
a238 1
	register int c;
d261 1
a261 1
	register int n;
d271 1
a271 1
unsigned long n;
d273 1
a273 1
	register char *p = malloc(n);
d282 1
a282 1
const char *s;
d284 1
a284 1
	register char *p = strdup(s);
@


1.10
log
@Bug-fix: thinko
@
text
@d1 1
a1 1
/*	$OpenBSD: misc.c,v 1.9 1999/09/06 13:29:32 espie Exp $	*/
d44 1
a44 1
static char rcsid[] = "$OpenBSD: misc.c,v 1.9 1999/09/06 13:29:32 espie Exp $";
d293 1
a293 1
	fprintf(stderr, "usage: m4 [-Dname[=val]] [-Uname]\n");
@


1.9
log
@Remove STRSPACE limitations.
A bit wasteful, but not too intrusive.

Also remove pushback buffer limitations, as this would be mostly useless
otherwise.

Incidentally, pushback buffer overflow detection in pbstr was wrong.
@
text
@d1 1
a1 1
/*	$OpenBSD: misc.c,v 1.6 1997/12/10 20:24:17 deraadt Exp $	*/
d44 1
a44 1
static char rcsid[] = "$OpenBSD: misc.c,v 1.6 1997/12/10 20:24:17 deraadt Exp $";
d200 1
a200 1
	endpbb = buf+strsize;
@


1.8
log
@Get rid of mktemp in the handling of diversion.

Simply put, mkstemp/unlink/rewind has the proper semantics under Unix,
and so we don't have to keep track about temp file names and remove them.
@
text
@d61 17
d101 3
a103 4
	if (bp < endpbb)
		*bp++ = c;
	else
		errx(1, "too many characters pushed back");
d115 1
a115 5
	register char *es;
	pbent *zp;

	es = s;
	zp = bp;
d117 5
a121 8
	while (*es)
		es++;
	es--;
	while (es >= s)
		if (zp < endpbb)
			*zp++ = *es--;
	if ((bp = zp) == endpbb)
		errx(1, "too many characters pushed back");
d143 60
d210 15
a224 2
	if (ep < endest)
		*ep++ = c;
d226 3
a228 1
		errx(1, "string space overflow");
@


1.7
log
@Misc minor changes:
- use err.h and kill oops,
- use __progname and kill basename,
- let indx use strstr
- proper EOS decl
@
text
@a154 1
	register FILE *dfil;
d158 3
a161 15
	outfile[n] = NULL;
	m4temp[UNIQUE] = n + '0';
	if ((dfil = fopen(m4temp, "r")) == NULL)
		err(1, "%s: cannot undivert", m4temp);
	else
		while ((c = getc(dfil)) != EOF)
			putc(c, active);
	(void) fclose(dfil);

#ifdef vms
	if (remove(m4temp))
#else
	if (unlink(m4temp) == -1)
#endif
		err(1, "%s: cannot unlink", m4temp);
a181 6
			m4temp[UNIQUE] = n + '0';
#ifdef vms
			(void) remove(m4temp);
#else
			(void) unlink(m4temp);
#endif
@


1.6
log
@cgd: add a typedef which describes elements in the push-back buffer.  Make
that typedef 'short'.  'char' (which was previously used) because char
may be unsigned and ((char)EOF) != EOF if that is the case.  That was
causing the (char)EOF (0xff) pushed back in main to be interepreted as
a character, and, in some cases, to be written to the output.  'short'
was used rather than 'signed char' because if the latter is used,
0xff characters in the input would confuse m4.  (No point in introducing
(more?) 8-bit lossage.)
@
text
@d1 1
a1 1
/*	$OpenBSD: misc.c,v 1.5 1997/07/25 21:05:32 mickey Exp $	*/
d44 1
a44 1
static char rcsid[] = "$OpenBSD: misc.c,v 1.5 1997/07/25 21:05:32 mickey Exp $";
d53 1
d55 1
d64 1
a64 1
int
d66 2
a67 2
char *s1;
char *s2;
d69 7
a75 10
	register char *t;
	register char *p;
	register char *m;

	for (p = s1; *p; p++) {
		for (t = p, m = s2; *m && *m == *t; m++, t++);
		if (!*m)
			return (p - s1);
	}
	return (-1);
d87 1
a87 1
		oops("too many characters pushed back");
d112 1
a112 1
		oops("too many characters pushed back");
d144 1
a144 1
		oops("string space overflow");
d158 1
a158 1
		oops("%s: diversion still active.", "undivert");
d163 1
a163 1
		oops("%s: cannot undivert.", m4temp);
d174 1
a174 1
		oops("%s: cannot unlink.", m4temp);
d181 1
a181 1
	oops("interrupted.");
d211 1
a211 1
		oops("malloc: %s", strerror(errno));
d221 1
a221 1
		oops("strdup: %s", strerror(errno));
a224 13
char *
basename(s)
register char *s;
{
	register char *p;
	extern char *strrchr();

	if ((p = strrchr(s, '/')) == NULL)
		return s;

	return ++p;
}

a231 28
#ifdef __STDC__
#include <stdarg.h>
#else
#include <varargs.h>
#endif

void
#ifdef __STDC__
oops(const char *fmt, ...)
#else
oops(fmt, va_alist)
	char *fmt;
	va_dcl
#endif
{
	va_list ap;
#ifdef __STDC__
	va_start(ap, fmt);
#else
	va_start(ap);
#endif
	(void)fprintf(stderr, "%s: ", progname);
	(void)vfprintf(stderr, fmt, ap);
	va_end(ap);
	(void)fprintf(stderr, "\n");
	exit(1);
	/* NOTREACHED */
}
@


1.5
log
@#if __STDC__ --> #ifdef __STDC__
@
text
@d1 1
a1 1
/*	$OpenBSD: misc.c,v 1.4 1996/07/01 20:40:28 deraadt Exp $	*/
d44 1
a44 1
static char rcsid[] = "$OpenBSD: misc.c,v 1.4 1996/07/01 20:40:28 deraadt Exp $";
d83 1
a83 1
char c;
d101 1
a101 1
	register char *zp;
@


1.4
log
@undo mktemp cleanup until i get it right
@
text
@d1 1
a1 1
/*	$OpenBSD: misc.c,v 1.3 1996/06/26 05:36:15 deraadt Exp $	*/
d44 1
a44 1
static char rcsid[] = "$OpenBSD: misc.c,v 1.3 1996/06/26 05:36:15 deraadt Exp $";
d246 1
a246 1
#if __STDC__
d253 1
a253 1
#if __STDC__
d262 1
a262 1
#if __STDC__
@


1.3
log
@rcsid
@
text
@d1 1
a1 1
/*	$OpenBSD: misc.c,v 1.6 1995/09/28 05:37:41 tls Exp $	*/
d44 1
a44 1
static char rcsid[] = "$OpenBSD: misc.c,v 1.6 1995/09/28 05:37:41 tls Exp $";
a48 1
#include <sys/file.h>
a156 1
	int fd;
d163 1
a163 5

	if ((fd = open(m4temp, O_RDWR|O_EXCL|O_CREAT, 0666)) == -1 ||
	    (dfil = fdopen(fd, "r")) == NULL) {
		if (fd != -1)
			close(fd);
d165 1
a165 1
	} else
@


1.2
log
@mktemp open + fdopen
@
text
@d1 1
d44 1
a44 1
static char rcsid[] = "$NetBSD: misc.c,v 1.6 1995/09/28 05:37:41 tls Exp $";
@


1.1
log
@Initial revision
@
text
@d48 1
d157 1
d164 5
a168 1
	if ((dfil = fopen(m4temp, "r")) == NULL)
d170 1
a170 1
	else
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@
