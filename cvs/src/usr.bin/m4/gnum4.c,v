head	1.52;
access;
symbols
	OPENBSD_6_2:1.52.0.2
	OPENBSD_6_2_BASE:1.52
	OPENBSD_6_1:1.50.0.10
	OPENBSD_6_1_BASE:1.50
	OPENBSD_6_0:1.50.0.6
	OPENBSD_6_0_BASE:1.50
	OPENBSD_5_9:1.50.0.2
	OPENBSD_5_9_BASE:1.50
	OPENBSD_5_8:1.50.0.4
	OPENBSD_5_8_BASE:1.50
	OPENBSD_5_7:1.47.0.2
	OPENBSD_5_7_BASE:1.47
	OPENBSD_5_6:1.46.0.4
	OPENBSD_5_6_BASE:1.46
	OPENBSD_5_5:1.43.0.4
	OPENBSD_5_5_BASE:1.43
	OPENBSD_5_4:1.42.0.8
	OPENBSD_5_4_BASE:1.42
	OPENBSD_5_3:1.42.0.6
	OPENBSD_5_3_BASE:1.42
	OPENBSD_5_2:1.42.0.4
	OPENBSD_5_2_BASE:1.42
	OPENBSD_5_1_BASE:1.42
	OPENBSD_5_1:1.42.0.2
	OPENBSD_5_0:1.41.0.4
	OPENBSD_5_0_BASE:1.41
	OPENBSD_4_9:1.41.0.2
	OPENBSD_4_9_BASE:1.41
	OPENBSD_4_8:1.40.0.2
	OPENBSD_4_8_BASE:1.40
	OPENBSD_4_7:1.39.0.4
	OPENBSD_4_7_BASE:1.39
	OPENBSD_4_6:1.39.0.6
	OPENBSD_4_6_BASE:1.39
	OPENBSD_4_5:1.39.0.2
	OPENBSD_4_5_BASE:1.39
	OPENBSD_4_4:1.36.0.10
	OPENBSD_4_4_BASE:1.36
	OPENBSD_4_3:1.36.0.8
	OPENBSD_4_3_BASE:1.36
	OPENBSD_4_2:1.36.0.6
	OPENBSD_4_2_BASE:1.36
	OPENBSD_4_1:1.36.0.4
	OPENBSD_4_1_BASE:1.36
	OPENBSD_4_0:1.36.0.2
	OPENBSD_4_0_BASE:1.36
	OPENBSD_3_9:1.31.0.4
	OPENBSD_3_9_BASE:1.31
	OPENBSD_3_8:1.31.0.2
	OPENBSD_3_8_BASE:1.31
	OPENBSD_3_7:1.28.0.2
	OPENBSD_3_7_BASE:1.28
	OPENBSD_3_6:1.27.0.4
	OPENBSD_3_6_BASE:1.27
	OPENBSD_3_5:1.27.0.2
	OPENBSD_3_5_BASE:1.27
	OPENBSD_3_4:1.25.0.2
	OPENBSD_3_4_BASE:1.25
	OPENBSD_3_3:1.18.0.4
	OPENBSD_3_3_BASE:1.18
	OPENBSD_3_2:1.18.0.2
	OPENBSD_3_2_BASE:1.18
	OPENBSD_3_1:1.16.0.2
	OPENBSD_3_1_BASE:1.16
	OPENBSD_3_0:1.15.0.2
	OPENBSD_3_0_BASE:1.15
	OPENBSD_2_9_BASE:1.8
	OPENBSD_2_9:1.8.0.4
	OPENBSD_2_8:1.8.0.2
	OPENBSD_2_8_BASE:1.8
	OPENBSD_2_7:1.6.0.2
	OPENBSD_2_7_BASE:1.6
	OPENBSD_2_6:1.2.0.2
	OPENBSD_2_6_BASE:1.2;
locks; strict;
comment	@ * @;


1.52
date	2017.08.21.21.41.13;	author deraadt;	state Exp;
branches;
next	1.51;
commitid	GetnLYY8Up3nxFbI;

1.51
date	2017.06.15.13.48.42;	author bcallah;	state Exp;
branches;
next	1.50;
commitid	cJah5U98w19KunxL;

1.50
date	2015.04.29.00.13.26;	author millert;	state Exp;
branches;
next	1.49;
commitid	qWalYly9hKZjgvhU;

1.49
date	2015.04.25.15.33.47;	author espie;	state Exp;
branches;
next	1.48;
commitid	oV5HQakan0ERHahj;

1.48
date	2015.03.14.23.00.43;	author millert;	state Exp;
branches;
next	1.47;
commitid	HfdMs2SUqfqbScN5;

1.47
date	2015.01.16.06.40.09;	author deraadt;	state Exp;
branches;
next	1.46;
commitid	Uu5nFG3wCl0LACBb;

1.46
date	2014.07.10.14.12.31;	author espie;	state Exp;
branches;
next	1.45;
commitid	aPZh2NEQFKIK9I0B;

1.45
date	2014.05.12.19.11.19;	author espie;	state Exp;
branches;
next	1.44;

1.44
date	2014.04.28.12.34.11;	author espie;	state Exp;
branches;
next	1.43;

1.43
date	2013.11.20.16.44.27;	author deraadt;	state Exp;
branches;
next	1.42;

1.42
date	2011.11.06.12.25.43;	author espie;	state Exp;
branches;
next	1.41;

1.41
date	2010.09.07.19.58.09;	author marco;	state Exp;
branches;
next	1.40;

1.40
date	2010.03.22.20.40.43;	author espie;	state Exp;
branches;
next	1.39;

1.39
date	2008.08.21.21.01.04;	author espie;	state Exp;
branches;
next	1.38;

1.38
date	2008.08.16.12.23.50;	author espie;	state Exp;
branches;
next	1.37;

1.37
date	2008.08.16.12.21.46;	author espie;	state Exp;
branches;
next	1.36;

1.36
date	2006.03.24.08.03.44;	author espie;	state Exp;
branches;
next	1.35;

1.35
date	2006.03.23.08.04.54;	author espie;	state Exp;
branches;
next	1.34;

1.34
date	2006.03.23.07.57.33;	author espie;	state Exp;
branches;
next	1.33;

1.33
date	2006.03.20.20.27.45;	author espie;	state Exp;
branches;
next	1.32;

1.32
date	2006.03.20.10.55.19;	author espie;	state Exp;
branches;
next	1.31;

1.31
date	2005.05.29.18.44.36;	author espie;	state Exp;
branches;
next	1.30;

1.30
date	2005.05.21.10.33.48;	author espie;	state Exp;
branches;
next	1.29;

1.29
date	2005.05.17.20.33.26;	author espie;	state Exp;
branches;
next	1.28;

1.28
date	2004.11.07.10.26.18;	author espie;	state Exp;
branches;
next	1.27;

1.27
date	2003.11.22.11.51.52;	author espie;	state Exp;
branches;
next	1.26;

1.26
date	2003.11.17.17.12.10;	author espie;	state Exp;
branches;
next	1.25;

1.25
date	2003.06.30.22.13.32;	author espie;	state Exp;
branches;
next	1.24;

1.24
date	2003.06.30.22.11.38;	author espie;	state Exp;
branches;
next	1.23;

1.23
date	2003.06.30.21.47.21;	author espie;	state Exp;
branches;
next	1.22;

1.22
date	2003.06.30.21.42.50;	author espie;	state Exp;
branches;
next	1.21;

1.21
date	2003.06.08.22.42.27;	author espie;	state Exp;
branches;
next	1.20;

1.20
date	2003.06.08.20.11.45;	author espie;	state Exp;
branches;
next	1.19;

1.19
date	2003.06.07.12.02.35;	author espie;	state Exp;
branches;
next	1.18;

1.18
date	2002.04.26.16.15.16;	author espie;	state Exp;
branches;
next	1.17;

1.17
date	2002.04.26.13.13.41;	author espie;	state Exp;
branches;
next	1.16;

1.16
date	2002.02.16.21.27.48;	author millert;	state Exp;
branches;
next	1.15;

1.15
date	2001.10.13.20.18.48;	author espie;	state Exp;
branches;
next	1.14;

1.14
date	2001.09.28.00.46.02;	author espie;	state Exp;
branches;
next	1.13;

1.13
date	2001.09.27.12.35.20;	author espie;	state Exp;
branches;
next	1.12;

1.12
date	2001.09.18.13.52.58;	author espie;	state Exp;
branches;
next	1.11;

1.11
date	2001.09.18.13.42.37;	author espie;	state Exp;
branches;
next	1.10;

1.10
date	2001.09.16.21.08.55;	author espie;	state Exp;
branches;
next	1.9;

1.9
date	2001.07.28.05.36.18;	author pvalchev;	state Exp;
branches;
next	1.8;

1.8
date	2000.07.24.23.08.25;	author espie;	state Exp;
branches;
next	1.7;

1.7
date	2000.06.28.10.01.27;	author espie;	state Exp;
branches;
next	1.6;

1.6
date	2000.04.10.17.16.30;	author espie;	state Exp;
branches
	1.6.2.1;
next	1.5;

1.5
date	2000.03.11.15.54.44;	author espie;	state Exp;
branches;
next	1.4;

1.4
date	2000.01.12.17.49.53;	author espie;	state Exp;
branches;
next	1.3;

1.3
date	99.11.17.15.34.13;	author espie;	state Exp;
branches;
next	1.2;

1.2
date	99.09.14.08.35.16;	author espie;	state Exp;
branches;
next	1.1;

1.1
date	99.09.14.08.21.36;	author espie;	state Exp;
branches;
next	;

1.6.2.1
date	2000.06.28.16.51.24;	author jason;	state Exp;
branches;
next	;


desc
@@


1.52
log
@Use waitpid()/EINTR idiom for the specific pid, rather than generic wait(),
in case the parent process was started with a dangling child.  This style
ensures any potential parent:child interlock isn't disrupted due to the
"wrong" child being waited on first.  Then the other other childs can safely
zombie.
ok millert jca brynet
@
text
@/* $OpenBSD: gnum4.c,v 1.51 2017/06/15 13:48:42 bcallah Exp $ */

/*
 * Copyright (c) 1999 Marc Espie
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */

/*
 * functions needed to support gnu-m4 extensions, including a fake freezing
 */

#include <sys/types.h>
#include <sys/wait.h>
#include <ctype.h>
#include <err.h>
#include <paths.h>
#include <regex.h>
#include <stdarg.h>
#include <stddef.h>
#include <stdlib.h>
#include <stdint.h>
#include <stdio.h>
#include <string.h>
#include <errno.h>
#include <unistd.h>
#include <limits.h>
#include "mdef.h"
#include "stdd.h"
#include "extern.h"


int mimic_gnu = 0;

/*
 * Support for include path search
 * First search in the current directory.
 * If not found, and the path is not absolute, include path kicks in.
 * First, -I options, in the order found on the command line.
 * Then M4PATH env variable
 */

struct path_entry {
	char *name;
	struct path_entry *next;
} *first, *last;

static struct path_entry *new_path_entry(const char *);
static void ensure_m4path(void);
static struct input_file *dopath(struct input_file *, const char *);

static struct path_entry *
new_path_entry(const char *dirname)
{
	struct path_entry *n;

	n = malloc(sizeof(struct path_entry));
	if (!n)
		errx(1, "out of memory");
	n->name = xstrdup(dirname);
	n->next = 0;
	return n;
}

void
addtoincludepath(const char *dirname)
{
	struct path_entry *n;

	n = new_path_entry(dirname);

	if (last) {
		last->next = n;
		last = n;
	}
	else
		last = first = n;
}

static void
ensure_m4path()
{
	static int envpathdone = 0;
	char *envpath;
	char *sweep;
	char *path;

	if (envpathdone)
		return;
	envpathdone = TRUE;
	envpath = getenv("M4PATH");
	if (!envpath)
		return;
	/* for portability: getenv result is read-only */
	envpath = xstrdup(envpath);
	for (sweep = envpath;
	    (path = strsep(&sweep, ":")) != NULL;)
	    addtoincludepath(path);
	free(envpath);
}

static
struct input_file *
dopath(struct input_file *i, const char *filename)
{
	char path[PATH_MAX];
	struct path_entry *pe;
	FILE *f;

	for (pe = first; pe; pe = pe->next) {
		snprintf(path, sizeof(path), "%s/%s", pe->name, filename);
		if ((f = fopen(path, "r")) != 0) {
			set_input(i, f, path);
			return i;
		}
	}
	return NULL;
}

struct input_file *
fopen_trypath(struct input_file *i, const char *filename)
{
	FILE *f;

	f = fopen(filename, "r");
	if (f != NULL) {
		set_input(i, f, filename);
		return i;
	}
	if (filename[0] == '/')
		return NULL;

	ensure_m4path();

	return dopath(i, filename);
}

void
doindir(const char *argv[], int argc)
{
	ndptr n;
	struct macro_definition *p;

	n = lookup(argv[2]);
	if (n == NULL || (p = macro_getdef(n)) == NULL)
		m4errx(1, "indir: undefined macro %s.", argv[2]);
	argv[1] = p->defn;

	eval(argv+1, argc-1, p->type, is_traced(n));
}

void
dobuiltin(const char *argv[], int argc)
{
	ndptr p;

	argv[1] = NULL;
	p = macro_getbuiltin(argv[2]);
	if (p != NULL)
		eval(argv+1, argc-1, macro_builtin_type(p), is_traced(p));
	else
		m4errx(1, "unknown builtin %s.", argv[2]);
}


/* We need some temporary buffer space, as pb pushes BACK and substitution
 * proceeds forward... */
static char *buffer;
static size_t bufsize = 0;
static size_t current = 0;

static void addchars(const char *, size_t);
static void addchar(int);
static char *twiddle(const char *);
static char *getstring(void);
static void exit_regerror(int, regex_t *, const char *);
static void do_subst(const char *, regex_t *, const char *, const char *, 
    regmatch_t *);
static void do_regexpindex(const char *, regex_t *, const char *, regmatch_t *);
static void do_regexp(const char *, regex_t *, const char *, const char *, 
    regmatch_t *);
static void add_sub(int, const char *, regex_t *, regmatch_t *);
static void add_replace(const char *, regex_t *, const char *, regmatch_t *);
#define addconstantstring(s) addchars((s), sizeof(s)-1)

static void
addchars(const char *c, size_t n)
{
	if (n == 0)
		return;
	while (current + n > bufsize) {
		if (bufsize == 0)
			bufsize = 1024;
		else if (bufsize <= SIZE_MAX/2) {
			bufsize *= 2;
		} else {
			errx(1, "size overflow");
		}
		buffer = xrealloc(buffer, bufsize, NULL);
	}
	memcpy(buffer+current, c, n);
	current += n;
}

static void
addchar(int c)
{
	if (current +1 > bufsize) {
		if (bufsize == 0)
			bufsize = 1024;
		else
			bufsize *= 2;
		buffer = xrealloc(buffer, bufsize, NULL);
	}
	buffer[current++] = c;
}

static char *
getstring(void)
{
	addchar('\0');
	current = 0;
	return buffer;
}


static void
exit_regerror(int er, regex_t *re, const char *source)
{
	size_t	errlen;
	char	*errbuf;

	errlen = regerror(er, re, NULL, 0);
	errbuf = xalloc(errlen,
	    "malloc in regerror: %lu", (unsigned long)errlen);
	regerror(er, re, errbuf, errlen);
	m4errx(1, "regular expression error in %s: %s.", source, errbuf);
}

/* warnx() plus check to see if we need to change exit code or exit.
 * -E flag functionality.
 */
void
m4_warnx(const char *fmt, ...)
{
	va_list ap;

	va_start(ap, fmt);
	vwarnx(fmt, ap);
	va_end(ap);

	if (fatal_warns)
		exit(1);
	if (error_warns)
		exit_code = 1;
}

static void
add_sub(int n, const char *string, regex_t *re, regmatch_t *pm)
{
	if (n > re->re_nsub)
		m4_warnx("No subexpression %d", n);
	/* Subexpressions that did not match are
	 * not an error.  */
	else if (pm[n].rm_so != -1 &&
	    pm[n].rm_eo != -1) {
		addchars(string + pm[n].rm_so,
			pm[n].rm_eo - pm[n].rm_so);
	}
}

/* Add replacement string to the output buffer, recognizing special
 * constructs and replacing them with substrings of the original string.
 */
static void
add_replace(const char *string, regex_t *re, const char *replace, regmatch_t *pm)
{
	const char *p;

	for (p = replace; *p != '\0'; p++) {
		if (*p == '&' && !mimic_gnu) {
			add_sub(0, string, re, pm);
			continue;
		}
		if (*p == '\\') {
			if (p[1] == '\\') {
				addchar(p[1]);
				p++;
				continue;
			}
			if (p[1] == '&') {
				if (mimic_gnu)
					add_sub(0, string, re, pm);
				else
					addchar(p[1]);
				p++;
				continue;
			}
			if (isdigit((unsigned char)p[1])) {
				add_sub(*(++p) - '0', string, re, pm);
				continue;
			}
		}
		addchar(*p);
	}
}

static void
do_subst(const char *string, regex_t *re, const char *source, 
    const char *replace, regmatch_t *pm)
{
	int error;
	int flags = 0;
	const char *last_match = NULL;

	while ((error = regexec(re, string, re->re_nsub+1, pm, flags)) == 0) {
		if (pm[0].rm_eo != 0) {
			if (string[pm[0].rm_eo-1] == '\n')
				flags = 0;
			else
				flags = REG_NOTBOL;
		}

		/* NULL length matches are special... We use the `vi-mode'
		 * rule: don't allow a NULL-match at the last match
		 * position.
		 */
		if (pm[0].rm_so == pm[0].rm_eo &&
		    string + pm[0].rm_so == last_match) {
			if (*string == '\0')
				return;
			addchar(*string);
			if (*string++ == '\n')
				flags = 0;
			else
				flags = REG_NOTBOL;
			continue;
		}
		last_match = string + pm[0].rm_so;
		addchars(string, pm[0].rm_so);
		add_replace(string, re, replace, pm);
		string += pm[0].rm_eo;
	}
	if (error != REG_NOMATCH)
		exit_regerror(error, re, source);
	pbstr(string);
}

static void
do_regexp(const char *string, regex_t *re, const char *source, 
    const char *replace, regmatch_t *pm)
{
	int error;

	switch(error = regexec(re, string, re->re_nsub+1, pm, 0)) {
	case 0:
		add_replace(string, re, replace, pm);
		pbstr(getstring());
		break;
	case REG_NOMATCH:
		break;
	default:
		exit_regerror(error, re, source);
	}
}

static void
do_regexpindex(const char *string, regex_t *re, const char *source, 
    regmatch_t *pm)
{
	int error;

	switch(error = regexec(re, string, re->re_nsub+1, pm, 0)) {
	case 0:
		pbunsigned(pm[0].rm_so);
		break;
	case REG_NOMATCH:
		pbnum(-1);
		break;
	default:
		exit_regerror(error, re, source);
	}
}

/* In Gnu m4 mode, parentheses for backmatch don't work like POSIX 1003.2
 * says. So we twiddle with the regexp before passing it to regcomp.
 */
static char *
twiddle(const char *p)
{
	/* + at start of regexp is a normal character for Gnu m4 */
	if (*p == '^') {
		addchar(*p);
		p++;
	}
	if (*p == '+') {
		addchar('\\');
	}
	/* This could use strcspn for speed... */
	while (*p != '\0') {
		if (*p == '\\') {
			switch(p[1]) {
			case '(':
			case ')':
			case '|':
				addchar(p[1]);
				break;
			case 'w':
				addconstantstring("[_a-zA-Z0-9]");
				break;
			case 'W':
				addconstantstring("[^_a-zA-Z0-9]");
				break;
			case '<':
				addconstantstring("[[:<:]]");
				break;
			case '>':
				addconstantstring("[[:>:]]");
				break;
			default:
				addchars(p, 2);
				break;
			}
			p+=2;
			continue;
		}
		if (*p == '(' || *p == ')' || *p == '|')
			addchar('\\');

		addchar(*p);
		p++;
	}
	return getstring();
}

/* patsubst(string, regexp, opt replacement) */
/* argv[2]: string
 * argv[3]: regexp
 * argv[4]: opt rep
 */
void
dopatsubst(const char *argv[], int argc)
{
	if (argc <= 3) {
		m4_warnx("Too few arguments to patsubst");
		return;
	}
	/* special case: empty regexp */
	if (argv[3][0] == '\0') {
		const char *s;
		size_t len;
		if (argc > 4 && argv[4])
			len = strlen(argv[4]);
		else
			len = 0;
		for (s = argv[2]; *s != '\0'; s++) {
			addchars(argv[4], len);
			addchar(*s);
		}
	} else {
		int error;
		regex_t re;
		regmatch_t *pmatch;
		int mode = REG_EXTENDED;
		const char *source;
		size_t l = strlen(argv[3]);

		if (!mimic_gnu ||
		    (argv[3][0] == '^') ||
		    (l > 0 && argv[3][l-1] == '$'))
			mode |= REG_NEWLINE;

		source = mimic_gnu ? twiddle(argv[3]) : argv[3];
		error = regcomp(&re, source, mode);
		if (error != 0)
			exit_regerror(error, &re, source);

		pmatch = xreallocarray(NULL, re.re_nsub+1, sizeof(regmatch_t), 
		    NULL);
		do_subst(argv[2], &re, source,
		    argc > 4 && argv[4] != NULL ? argv[4] : "", pmatch);
		free(pmatch);
		regfree(&re);
	}
	pbstr(getstring());
}

void
doregexp(const char *argv[], int argc)
{
	int error;
	regex_t re;
	regmatch_t *pmatch;
	const char *source;

	if (argc <= 3) {
		m4_warnx("Too few arguments to regexp");
		return;
	}
	/* special gnu case */
	if (argv[3][0] == '\0' && mimic_gnu) {
		if (argc == 4 || argv[4] == NULL)
			return;
		else
			pbstr(argv[4]);
	}
	source = mimic_gnu ? twiddle(argv[3]) : argv[3];
	error = regcomp(&re, source, REG_EXTENDED|REG_NEWLINE);
	if (error != 0)
		exit_regerror(error, &re, source);

	pmatch = xreallocarray(NULL, re.re_nsub+1, sizeof(regmatch_t), NULL);
	if (argc == 4 || argv[4] == NULL)
		do_regexpindex(argv[2], &re, source, pmatch);
	else
		do_regexp(argv[2], &re, source, argv[4], pmatch);
	free(pmatch);
	regfree(&re);
}

void
doformat(const char *argv[], int argc)
{
	const char *format = argv[2];
	int pos = 3;
	int left_padded;
	long width;
	size_t l;
	const char *thisarg;
	char temp[2];
	long extra;

	while (*format != 0) {
		if (*format != '%') {
			addchar(*format++);
			continue;
		}

		format++;
		if (*format == '%') {
			addchar(*format++);
			continue;
		}
		if (*format == 0) {
			addchar('%');
			break;
		}

		if (*format == '*') {
			format++;
			if (pos >= argc)
				m4errx(1,
				    "Format with too many format specifiers.");
			width = strtol(argv[pos++], NULL, 10);
		} else {
			width = strtol(format, (char **)&format, 10);
		}
		if (width < 0) {
			left_padded = 1;
			width = -width;
		} else {
			left_padded = 0;
		}
		if (*format == '.') {
			format++;
			if (*format == '*') {
				format++;
				if (pos >= argc)
					m4errx(1,
					    "Format with too many format specifiers.");
				extra = strtol(argv[pos++], NULL, 10);
			} else {
				extra = strtol(format, (char **)&format, 10);
			}
		} else {
			extra = LONG_MAX;
		}
		if (pos >= argc)
			m4errx(1, "Format with too many format specifiers.");
		switch(*format) {
		case 's':
			thisarg = argv[pos++];
			break;
		case 'c':
			temp[0] = strtoul(argv[pos++], NULL, 10);
			temp[1] = 0;
			thisarg = temp;
			break;
		default:
			m4errx(1, "Unsupported format specification: %s.",
			    argv[2]);
		}
		format++;
		l = strlen(thisarg);
		if (l > extra)
			l = extra;
		if (!left_padded) {
			while (l < width--)
				addchar(' ');
		}
		addchars(thisarg, l);
		if (left_padded) {
			while (l < width--)
				addchar(' ');
		}
	}
	pbstr(getstring());
}

void
doesyscmd(const char *cmd)
{
	int p[2];
	pid_t cpid;
	char *argv[4];
	int cc;
	int status;

	/* Follow gnu m4 documentation: first flush buffers. */
	fflush(NULL);

	argv[0] = "sh";
	argv[1] = "-c";
	argv[2] = (char *)cmd;
	argv[3] = NULL;

	/* Just set up standard output, share stderr and stdin with m4 */
	if (pipe(p) == -1)
		err(1, "bad pipe");
	switch(cpid = fork()) {
	case -1:
		err(1, "bad fork");
		/* NOTREACHED */
	case 0:
		(void) close(p[0]);
		(void) dup2(p[1], 1);
		(void) close(p[1]);
		execv(_PATH_BSHELL, argv);
		exit(1);
	default:
		/* Read result in two stages, since m4's buffer is
		 * pushback-only. */
		(void) close(p[1]);
		do {
			char result[BUFSIZE];
			cc = read(p[0], result, sizeof result);
			if (cc > 0)
				addchars(result, cc);
		} while (cc > 0 || (cc == -1 && errno == EINTR));

		(void) close(p[0]);
		while (waitpid(cpid, &status, 0) == -1) {
			if (errno != EINTR)
				break;
		}
		pbstr(getstring());
	}
}

void
getdivfile(const char *name)
{
	FILE *f;
	int c;

	f = fopen(name, "r");
	if (!f)
		return;

	while ((c = getc(f))!= EOF)
		putc(c, active);
	(void) fclose(f);
}
@


1.51
log
@Add -E flag (make warnings fatal), following the behavior of GNU m4 1.4.9+
Help and direction millert@@ espie@@ anton@@ deraadt@@

ok espie@@
@
text
@d1 1
a1 1
/* $OpenBSD: gnum4.c,v 1.50 2015/04/29 00:13:26 millert Exp $ */
d633 1
a633 1
	pid_t pid, cpid;
d671 4
a674 2
		while ((pid = wait(&status)) != cpid && pid >= 0)
			continue;
@


1.50
log
@Add missing #include <stdint.h> for SIZE_MAX
@
text
@d1 1
a1 1
/* $OpenBSD: gnum4.c,v 1.49 2015/04/25 15:33:47 espie Exp $ */
d38 1
d238 1
a238 1
getstring()
d259 18
d281 1
a281 1
		warnx("No subexpression %d", n);
d464 1
a464 1
		warnx("Too few arguments to patsubst");
d516 1
a516 1
		warnx("Too few arguments to regexp");
@


1.49
log
@add check for overflow while doubling (very unlikely in practice, but still
better style code). Problem noticed by deraadt@@ in m4.

okay doug@@ deraadt@@
@
text
@d1 1
a1 1
/* $OpenBSD: gnum4.c,v 1.48 2015/03/14 23:00:43 millert Exp $ */
d40 1
@


1.48
log
@Use xstrdup(), from Michael W. Bombardieri
OK espie@@
@
text
@d1 1
a1 1
/* $OpenBSD: gnum4.c,v 1.47 2015/01/16 06:40:09 deraadt Exp $ */
d211 1
a211 1
		else
d213 3
@


1.47
log
@Replace <sys/param.h> with <limits.h> and other less dirty headers where
possible.  Annotate <sys/param.h> lines with their current reasons.  Switch
to PATH_MAX, NGROUPS_MAX, HOST_NAME_MAX+1, LOGIN_NAME_MAX, etc.  Change
MIN() and MAX() to local definitions of MINIMUM() and MAXIMUM() where
sensible to avoid pulling in the pollution.  These are the files confirmed
through binary verification.
ok guenther, millert, doug (helped with the verification protocol)
@
text
@d1 1
a1 1
/* $OpenBSD: gnum4.c,v 1.46 2014/07/10 14:12:31 espie Exp $ */
d77 1
a77 3
	n->name = strdup(dirname);
	if (!n->name)
		errx(1, "out of memory");
d112 1
a112 3
	envpath = strdup(envpath);
	if (!envpath)
		errx(1, "out of memory");
@


1.46
log
@annotate regexp error messages with source string.
okay miod@@
@
text
@d1 1
a1 1
/* $OpenBSD: gnum4.c,v 1.45 2014/05/12 19:11:19 espie Exp $ */
a31 1
#include <sys/param.h>
d44 1
d127 1
a127 1
	char path[MAXPATHLEN];
@


1.45
log
@adjust to ohash being in libutil now, and to the interface changes.
fix potential integer overflows in memory allocation (mostly for pedagogical
purposes, these are unlikely to overflow in practice)
move the rest of lst.lib stuff into its own directory.
@
text
@d1 1
a1 1
/* $OpenBSD: gnum4.c,v 1.44 2014/04/28 12:34:11 espie Exp $ */
d197 6
a202 4
static void exit_regerror(int, regex_t *);
static void do_subst(const char *, regex_t *, const char *, regmatch_t *);
static void do_regexpindex(const char *, regex_t *, regmatch_t *);
static void do_regexp(const char *, regex_t *, const char *, regmatch_t *);
d246 1
a246 1
exit_regerror(int er, regex_t *re)
d255 1
a255 1
	m4errx(1, "regular expression error: %s.", errbuf);
d309 2
a310 1
do_subst(const char *string, regex_t *re, const char *replace, regmatch_t *pm)
d345 1
a345 1
		exit_regerror(error, re);
d350 2
a351 1
do_regexp(const char *string, regex_t *re, const char *replace, regmatch_t *pm)
d363 1
a363 1
		exit_regerror(error, re);
d368 2
a369 1
do_regexpindex(const char *string, regex_t *re, regmatch_t *pm)
d381 1
a381 1
		exit_regerror(error, re);
d465 1
d473 2
a474 2
		error = regcomp(&re, mimic_gnu ? twiddle(argv[3]) : argv[3],
		    mode);
d476 1
a476 1
			exit_regerror(error, &re);
d480 1
a480 1
		do_subst(argv[2], &re,
d494 1
d507 2
a508 2
	error = regcomp(&re, mimic_gnu ? twiddle(argv[3]) : argv[3],
	    REG_EXTENDED|REG_NEWLINE);
d510 1
a510 1
		exit_regerror(error, &re);
d514 1
a514 1
		do_regexpindex(argv[2], &re, pmatch);
d516 1
a516 1
		do_regexp(argv[2], &re, argv[4], pmatch);
@


1.44
log
@check for integer overflows in custom allocs, okay jca@@
@
text
@d1 1
a1 1
/* $OpenBSD: gnum4.c,v 1.43 2013/11/20 16:44:27 deraadt Exp $ */
d472 2
a473 1
		pmatch = xallocarray(re.re_nsub+1, sizeof(regmatch_t), NULL);
d505 1
a505 1
	pmatch = xallocarray(re.re_nsub+1, sizeof(regmatch_t), NULL);
@


1.43
log
@repair signed char vs isdigit
ok espie
@
text
@d1 1
a1 1
/* $OpenBSD: gnum4.c,v 1.42 2011/11/06 12:25:43 espie Exp $ */
d472 1
a472 1
		pmatch = xalloc(sizeof(regmatch_t) * (re.re_nsub+1), NULL);
d504 1
a504 1
	pmatch = xalloc(sizeof(regmatch_t) * (re.re_nsub+1), NULL);
@


1.42
log
@improve gm4 compatibility, from Robert Young, thanks !
note that patsubst is non-standard.
okay miod@@, deraadt@@
@
text
@d1 1
a1 1
/* $OpenBSD: gnum4.c,v 1.41 2010/09/07 19:58:09 marco Exp $ */
d297 1
a297 1
			if (isdigit(p[1])) {
@


1.41
log
@Remove stray spaces.  No code change.
@
text
@d1 1
a1 1
/* $OpenBSD: gnum4.c,v 1.40 2010/03/22 20:40:43 espie Exp $ */
d500 1
a500 1
	    REG_EXTENDED);
@


1.40
log
@add more gnum4 support: regexps do weird things with empty patterns (this
is required for newer autoconf).
fix the tokenizer for gnu extensions, allowing digits out of range is
ridiculous.
add POSIX2008 mkstemp and document it (also documenting that mktemp is
safe, not posix...)
tidy the manpage, do extra .Nm m4 -> .Nm.
okay otto@@, miod@@, jmc@@
@
text
@d1 1
a1 1
/* $OpenBSD: gnum4.c,v 1.39 2008/08/21 21:01:04 espie Exp $ */
d28 1
a28 1
/* 
d83 2
a84 2
	
void 
d111 1
a111 1
	if (!envpath) 
d117 1
a117 1
	for (sweep = envpath; 
d159 1
a159 1
void 
d169 1
a169 1
	
d173 1
a173 1
void 
d184 1
a184 1
} 
d205 1
a205 1
static void 
d221 1
a221 1
static void 
d243 1
a243 1
static void 
d246 2
a247 2
	size_t 	errlen;
	char 	*errbuf;
d250 1
a250 1
	errbuf = xalloc(errlen, 
d273 1
a273 1
static void 
d302 1
a302 1
	    	addchar(*p);
d306 1
a306 1
static void 
d321 1
a321 1
		/* NULL length matches are special... We use the `vi-mode' 
d323 1
a323 1
		 * position. 
d325 1
a325 1
		if (pm[0].rm_so == pm[0].rm_eo && 
d346 1
a346 1
static void 
d352 1
a352 1
	case 0: 
d363 1
a363 1
static void 
d447 1
a447 1
		if (argc > 4 && argv[4]) 
d463 1
a463 1
		    (argv[3][0] == '^') || 
d467 1
a467 1
		error = regcomp(&re, mimic_gnu ? twiddle(argv[3]) : argv[3], 
d471 1
a471 1
		
d473 1
a473 1
		do_subst(argv[2], &re, 
d496 1
a496 1
		else 
d499 1
a499 1
	error = regcomp(&re, mimic_gnu ? twiddle(argv[3]) : argv[3], 
d503 1
a503 1
	
d544 1
a544 1
				m4errx(1, 
d561 1
a561 1
					m4errx(1, 
d582 1
a582 1
			m4errx(1, "Unsupported format specification: %s.", 
@


1.39
log
@extend format support to cater to recent GNU autoconf

okay otto@@, some useful ideas from miod@@
@
text
@d1 1
a1 1
/* $OpenBSD: gnum4.c,v 1.38 2008/08/16 12:23:50 espie Exp $ */
d447 1
a447 1
		if (argv[4] && argc > 4) 
d492 7
d505 1
a505 1
	if (argv[4] == NULL || argc == 4)
@


1.38
log
@not yet, committed too much
@
text
@d1 1
a1 1
/* $OpenBSD: gnum4.c,v 1.36 2006/03/24 08:03:44 espie Exp $ */
d511 6
d521 25
d547 3
d551 6
a556 4
			if (*format == '%' || *format == 0) {
				addchar('%');
				if (*format == '%')
					format++;
d558 1
a558 25
			    int left_padded = 0;
			    unsigned long width;
			    size_t l;

			    if (*format == '-') {
				    left_padded = 1;
				    format++;
			    }
			    width = strtoul(format, (char **)&format, 10);
			    if (*format != 's') {
				    m4errx(1, "Unsupported format specification: %s.", argv[2]);
			    }
			    format++;
			    if (pos >= argc)
				    m4errx(1, "Format with too many values.");
			    l = strlen(argv[pos]);
			    if (!left_padded) {
				    while (l < width--)
					    addchar(' ');
			    }
			    addchars(argv[pos++], l);
			    if (left_padded) {
				    while (l < width--)
					    addchar(' ');
			    }
d560 30
@


1.37
log
@argument parsing should only skip spaces outside of parenthesis.
Inside matching parenthesis, keep spaces as is (use chrsave instead of
pbstr, since there's no way it can be a further macro expansion).
Fixes a long-standing issue with autoconf (   --option -> --option),
matches other m4 than gnum4

okay millert@@, fries@@
@
text
@a510 6
	int left_padded;
	long width;
	size_t l;
	const char *thisarg;
	char temp[2];
	long extra;
a514 19
			continue;
		}

		format++;
		if (*format == '%') {
			addchar(*format++);
			continue;
		}
		if (*format == 0) {
			addchar('%');
			break;
		}

		if (*format == '*') {
			format++;
			if (pos >= argc)
				m4errx(1, 
				    "Format with too many format specifiers.");
			width = strtol(argv[pos++], NULL, 10);
a515 9
			width = strtol(format, (char **)&format, 10);
		}
		if (width < 0) {
			left_padded = 1;
			width = -width;
		} else {
			left_padded = 0;
		}
		if (*format == '.') {
d517 4
a520 6
			if (*format == '*') {
				format++;
				if (pos >= argc)
					m4errx(1, 
					    "Format with too many format specifiers.");
				extra = strtol(argv[pos++], NULL, 10);
d522 25
a546 1
				extra = strtol(format, (char **)&format, 10);
a547 30
		} else {
			extra = LONG_MAX;
		}
		if (pos >= argc)
			m4errx(1, "Format with too many format specifiers.");
		switch(*format) {
		case 's':
			thisarg = argv[pos++];
			break;
		case 'c':
			temp[0] = strtoul(argv[pos++], NULL, 10);
			temp[1] = 0;
			thisarg = temp;
			break;
		default:
			m4errx(1, "Unsupported format specification: %s.", 
			    argv[2]);
		}
		format++;
		l = strlen(thisarg);
		if (l > extra)
			l = extra;
		if (!left_padded) {
			while (l < width--)
				addchar(' ');
		}
		addchars(thisarg, l);
		if (left_padded) {
			while (l < width--)
				addchar(' ');
@


1.36
log
@oops, noticed by David Hill.
@
text
@d1 1
a1 1
/* $OpenBSD: gnum4.c,v 1.35 2006/03/23 08:04:54 espie Exp $ */
d511 6
d521 25
d547 3
d551 6
a556 4
			if (*format == '%' || *format == 0) {
				addchar('%');
				if (*format == '%')
					format++;
d558 1
a558 25
			    int left_padded = 0;
			    unsigned long width;
			    size_t l;

			    if (*format == '-') {
				    left_padded = 1;
				    format++;
			    }
			    width = strtoul(format, (char **)&format, 10);
			    if (*format != 's') {
				    m4errx(1, "Unsupported format specification: %s.", argv[2]);
			    }
			    format++;
			    if (pos >= argc)
				    m4errx(1, "Format with too many values.");
			    l = strlen(argv[pos]);
			    if (!left_padded) {
				    while (l < width--)
					    addchar(' ');
			    }
			    addchars(argv[pos++], l);
			    if (left_padded) {
				    while (l < width--)
					    addchar(' ');
			    }
d560 30
@


1.35
log
@formatting fixes
@
text
@d1 1
a1 1
/* $OpenBSD: gnum4.c,v 1.34 2006/03/23 07:57:33 espie Exp $ */
d36 1
@


1.34
log
@explicit cast on strtoul, classical const gotcha.
@
text
@d1 1
a1 1
/* $OpenBSD: gnum4.c,v 1.33 2006/03/20 20:27:45 espie Exp $ */
d510 1
d526 2
a527 2
			    	left_padded = 1;
				format++;
d531 1
a531 1
			    	m4errx(1, "Unsupported format specification: %s.", argv[2]);
d535 1
a535 1
			    	m4errx(1, "Format with too many values.");
d543 2
a544 2
			    	while (l < width--)
					addchar(' ');
@


1.33
log
@add limited support for format builtin in gnu-m4 mode, because I'm fed
up of patching it away in various autoconf derivatives.

okay miod@@
@
text
@d1 1
a1 1
/* $OpenBSD: gnum4.c,v 1.32 2006/03/20 10:55:19 espie Exp $ */
d528 1
a528 1
			    width = strtoul(format, &format, 10);
@


1.32
log
@report function m4errx, that shows app-specific data (filename/linenumber)
before the error message. Use it to simplify code.

okay miod@@
@
text
@d1 1
a1 1
/* $OpenBSD: gnum4.c,v 1.31 2005/05/29 18:44:36 espie Exp $ */
d503 46
@


1.31
log
@fix a few minor compatibility issues.
- let eval() handle a base and number of digits, like it's advertized to.
- in gnu-mode, undivert can take file names as arguments.
- in gnu-mode, map can handle reversed charsets.

Suggestions and okay otto@@, mostly prompted by looking at the regress
tests in newer gnu-m4.
@
text
@d1 1
a1 1
/* $OpenBSD: gnum4.c,v 1.30 2005/05/21 10:33:48 espie Exp $ */
a41 1
#include <err.h>
d166 1
a166 1
		errx(1, "undefined macro %s", argv[2]);
d182 1
a182 1
		errx(1, "unknown builtin %s", argv[2]);
d252 1
a252 2
	errx(1, "%s at line %lu: regular expression error: %s", 
	    CURRENT_NAME, CURRENT_LINE, errbuf);
@


1.30
log
@more heuristics to coerce gnu-m4 mode to work like we wish: if a ^ or $
is seen in the regexp, this means we need to take new lines into account.
Otherwise, we don't.
@
text
@d1 1
a1 1
/* $OpenBSD: gnum4.c,v 1.29 2005/05/17 20:33:26 espie Exp $ */
d553 15
@


1.29
log
@gnu m4 mode does not heed end of lines.
@
text
@d1 1
a1 1
/* $OpenBSD: gnum4.c,v 1.28 2004/11/07 10:26:18 espie Exp $ */
d460 7
d469 1
a469 1
		    mimic_gnu ? REG_EXTENDED : REG_NEWLINE | REG_EXTENDED);
@


1.28
log
@twiddle + at start of regexp.
@
text
@d1 1
a1 1
/* $OpenBSD: gnum4.c,v 1.27 2003/11/22 11:51:52 espie Exp $ */
d462 1
a462 1
		    REG_NEWLINE | REG_EXTENDED);
@


1.27
log
@the the typo. from rohee@@
@
text
@d1 1
a1 1
/* $OpenBSD: gnum4.c,v 1.26 2003/11/17 17:12:10 espie Exp $ */
d387 8
@


1.26
log
@Modify xalloc so that it also takes err(3)-like arguments.
Write an xrealloc wrapper that works the same way, and use it as well.

People who feel like it may want to add more explicit error messages to
all the places m4 can fail allocating memory...

okay tedu@@
@
text
@d1 1
a1 1
/* $OpenBSD: gnum4.c,v 1.25 2003/06/30 22:13:32 espie Exp $ */
d54 1
a54 1
 * First search in the the current directory.
@


1.25
log
@Fold trace status into the single hash table that's left.
Inline some macros/functions for speed.
So, this achieves the goal of one single lookup for macro/trace status,
which does speed up m4 in partial tracing situations somewhat.
This does also speed up m4 in large pushdef situations, since it no longer
has to lookup large chains of macros.

okay millert@@
@
text
@d1 1
a1 1
/* $OpenBSD: gnum4.c,v 1.24 2003/06/30 22:11:38 espie Exp $ */
d215 1
a215 3
		buffer = realloc(buffer, bufsize);
		if (buffer == NULL)
			errx(1, "out of memory");
d229 1
a229 3
		buffer = realloc(buffer, bufsize);
		if (buffer == NULL)
			errx(1, "out of memory");
d250 2
a251 1
	errbuf = xalloc(errlen);
d458 1
a458 1
		pmatch = xalloc(sizeof(regmatch_t) * (re.re_nsub+1));
d483 1
a483 1
	pmatch = xalloc(sizeof(regmatch_t) * (re.re_nsub+1));
@


1.24
log
@add a flag for each macro name that records built-in status.
Fold built-in lookup into normal lookup.
okay millert@@
@
text
@d1 1
a1 1
/* $OpenBSD: gnum4.c,v 1.23 2003/06/30 21:47:21 espie Exp $ */
d162 1
d165 2
a166 2
	p = lookup_macro_definition(argv[2]);
	if (p == NULL)
d170 1
a170 1
	eval(argv+1, argc-1, p->type, traced_macros && is_traced(argv[2]));
d177 1
d181 1
a181 1
		eval(argv+1, argc-1, macro_builtin_type(p), traced_macros && is_traced(argv[2]));
@


1.23
log
@Make the trace status of a macro an actual argument that gets pushed
in the frame for the macro expansion.

(This will allow one single lookup to grab the macro definition and
the trace status)

okay millert@@
@
text
@d1 1
a1 1
/* $OpenBSD: gnum4.c,v 1.22 2003/06/30 21:42:50 espie Exp $ */
d175 1
a175 1
	int n;
d177 3
a179 3
	n = builtin_type(argv[2]);
	if (n != -1)
		eval(argv+1, argc-1, n, traced_macros && is_traced(argv[2]));
@


1.22
log
@clean up internal lookup interface:
define an interface with explicit define/pushdef/popdef... and use it.
That way, most details of the hashtable are no longer visible.

okay millert@@
@
text
@d1 1
a1 1
/* $OpenBSD: gnum4.c,v 1.21 2003/06/08 22:42:27 espie Exp $ */
d168 2
a169 1
	eval(argv+1, argc-1, p->type);
d179 1
a179 1
		eval(argv+1, argc-1, n);
@


1.21
log
@Better argv tests, enough to fix autoconf 2.57, apparently.
okay millert@@
@
text
@d1 1
a1 1
/* $OpenBSD: gnum4.c,v 1.20 2003/06/08 20:11:45 espie Exp $ */
d162 1
a162 1
	ndptr p;
d164 1
a164 1
	p = lookup(argv[2]);
@


1.20
log
@Let patsubst handle empty patterns: those match anywhere, and don't
replace any character.
Like gnu-m4 does, and other regexp languages do.

okay fries@@
@
text
@d1 1
a1 1
/* $OpenBSD: gnum4.c,v 1.19 2003/06/07 12:02:35 espie Exp $ */
d439 5
a443 1
		size_t len = strlen(argv[4]);
d460 1
a460 1
		    argc != 4 && argv[4] != NULL ? argv[4] : "", pmatch);
@


1.19
log
@Show filename and line number in regexp error.
Okay fries@@
@
text
@d1 1
a1 1
/* $OpenBSD: gnum4.c,v 1.18 2002/04/26 16:15:16 espie Exp $ */
a431 4
	int error;
	regex_t re;
	regmatch_t *pmatch;

d436 24
a459 8
	error = regcomp(&re, mimic_gnu ? twiddle(argv[3]) : argv[3], 
	    REG_NEWLINE | REG_EXTENDED);
	if (error != 0)
		exit_regerror(error, &re);
	
	pmatch = xalloc(sizeof(regmatch_t) * (re.re_nsub+1));
	do_subst(argv[2], &re, 
	    argc != 4 && argv[4] != NULL ? argv[4] : "", pmatch);
a460 2
	free(pmatch);
	regfree(&re);
@


1.18
log
@use ansi function declarations. ok millert@@
@
text
@d1 1
a1 1
/* $OpenBSD: gnum4.c,v 1.17 2002/04/26 13:13:41 espie Exp $ */
d253 2
a254 1
	errx(1, "regular expression error: %s", errbuf);
@


1.17
log
@prototype mismatch, ansi conversion rules...
add -pedantic to flags.
@
text
@d1 1
a1 1
/* $OpenBSD: gnum4.c,v 1.16 2002/02/16 21:27:48 millert Exp $ */
d70 1
a70 2
new_path_entry(dirname)
	const char *dirname;
d85 1
a85 2
addtoincludepath(dirname)
	const char *dirname;
d125 1
a125 3
dopath(i, filename)
	struct input_file *i;
	const char *filename;
d142 1
a142 3
fopen_trypath(i, filename)
	struct input_file *i;
	const char *filename;
d160 1
a160 3
doindir(argv, argc)
	const char *argv[];
	int argc;
d172 1
a172 3
dobuiltin(argv, argc)
	const char *argv[];
	int argc;
d203 1
a203 3
addchars(c, n)
	const char *c;
	size_t n;
d221 1
a221 2
addchar(c)
	int c;
d245 1
a245 3
exit_regerror(er, re)
	int er;
	regex_t *re;
d257 1
a257 5
add_sub(n, string, re, pm)
	int n;
	const char *string;
	regex_t *re;
	regmatch_t *pm;
d274 1
a274 5
add_replace(string, re, replace, pm)
	const char *string;
	regex_t *re;
	const char *replace;
	regmatch_t *pm;
d307 1
a307 5
do_subst(string, re, replace, pm)
	const char *string;
	regex_t *re;
	const char *replace;
	regmatch_t *pm;
d347 1
a347 5
do_regexp(string, re, replace, pm)
	const char *string;
	regex_t *re;
	const char *replace;
	regmatch_t *pm;
d364 1
a364 4
do_regexpindex(string, re, pm)
	const char *string;
	regex_t *re;
	regmatch_t *pm;
d384 1
a384 2
twiddle(p)
	const char *p;
d429 1
a429 3
dopatsubst(argv, argc)
	const char *argv[];
	int argc;
d453 1
a453 3
doregexp(argv, argc)
	const char *argv[];
	int argc;
d478 1
a478 2
doesyscmd(cmd)
	const char *cmd;
@


1.16
log
@Part one of userland __P removal.  Done with a simple regexp with some minor hand editing to make comments line up correctly.  Another pass is forthcoming that handles the cases that could not be done automatically.
@
text
@d1 1
a1 1
/* $OpenBSD: gnum4.c,v 1.15 2001/10/13 20:18:48 espie Exp $ */
d201 1
a201 1
static void addchar(char);
d234 1
a234 1
	char c;
@


1.15
log
@Resize buffer correctly, I'm an idiot.
Found by fries@@, ok deraadt@@
@
text
@d1 1
a1 1
/* $OpenBSD: gnum4.c,v 1.14 2001/09/28 00:46:02 espie Exp $ */
d65 3
a67 3
static struct path_entry *new_path_entry __P((const char *));
static void ensure_m4path __P((void));
static struct input_file *dopath __P((struct input_file *, const char *));
d200 10
a209 10
static void addchars __P((const char *, size_t));
static void addchar __P((char));
static char *twiddle __P((const char *));
static char *getstring __P((void));
static void exit_regerror __P((int, regex_t *));
static void do_subst __P((const char *, regex_t *, const char *, regmatch_t *));
static void do_regexpindex __P((const char *, regex_t *, regmatch_t *));
static void do_regexp __P((const char *, regex_t *, const char *, regmatch_t *));
static void add_sub __P((int, const char *, regex_t *, regmatch_t *));
static void add_replace __P((const char *, regex_t *, const char *, regmatch_t *));
@


1.14
log
@more emacs regexps  in -g mode. Ok millert@@

With this, some autoconf 2.52 scripts are now working completely.
@
text
@d1 1
a1 1
/* $OpenBSD: gnum4.c,v 1.13 2001/09/27 12:35:20 espie Exp $ */
d219 1
a219 1
	if (current + n > bufsize) {
@


1.13
log
@Needed logic to handle newlines correctly.
@
text
@d1 1
a1 1
/* $OpenBSD: gnum4.c,v 1.12 2001/09/18 13:52:58 espie Exp $ */
d210 1
d423 23
a445 2
		if (*p == '\\' && (p[1] == '(' || p[1] == ')')) {
			addchar(p[1]);
d449 1
a449 1
		if (*p == '(' || *p == ')')
@


1.12
log
@One single point for all macros/builtin expansion.
@
text
@d1 1
a1 1
/* $OpenBSD: gnum4.c,v 1.11 2001/09/18 13:42:37 espie Exp $ */
d340 6
a345 1
		flags = REG_NOTBOL;
d356 4
a359 1
			string++;
@


1.11
log
@Fix regexp substitution.
- `vi rule' needs a pointer, because we must distinguish matches as the
string position changes.
- ^ should match only at beginning of line.
- ^ should match at all beginnings of line.
@
text
@d1 1
a1 1
/* $OpenBSD: gnum4.c,v 1.10 2001/09/16 21:08:55 espie Exp $ */
d176 1
a176 4
	if (p->type == MACRTYPE)
		expand(argv+1, argc-1);
	else
		eval(argv+1, argc-1, p->type);
@


1.10
log
@Fix \\ in recognition in patsubst: must advance beyond it as well.
@
text
@d1 1
a1 1
/* $OpenBSD: gnum4.c,v 1.9 2001/07/28 05:36:18 pvalchev Exp $ */
d339 2
a340 1
	regoff_t last_match = -1;
d342 2
a343 1
	while ((error = regexec(re, string, re->re_nsub+1, pm, 0)) == 0) {
d349 2
a350 1
		if (pm[0].rm_so == pm[0].rm_eo && pm[0].rm_so == last_match) {
d357 2
a358 2
		last_match = pm[0].rm_so;
		addchars(string, last_match);
d450 1
a450 1
	    REG_EXTENDED);
@


1.9
log
@Wall cleanup
@
text
@d1 1
a1 1
/* $OpenBSD: gnum4.c,v 1.8 2000/07/24 23:08:25 espie Exp $ */
d311 1
@


1.8
log
@Implement esyscmd
@
text
@d1 1
a1 1
/* $OpenBSD: gnum4.c,v 1.7 2000/06/28 10:01:27 espie Exp $ */
a370 1
	const char *p;
@


1.7
log
@Fix stupid bug in argument handling. Problem found by fries@@
Jason, that's a candidate for stable...
@
text
@d1 1
a1 1
/* $OpenBSD: gnum4.c,v 1.6 2000/04/10 17:16:30 espie Exp $ */
d34 1
d36 1
d43 2
d484 49
@


1.6
log
@Thinko in dobuiltin. Reported by turan@@
@
text
@d1 1
a1 1
/* $OpenBSD: gnum4.c,v 1.5 2000/03/11 15:54:44 espie Exp $ */
d448 2
a449 1
	do_subst(argv[2], &re, argv[4] != NULL ? argv[4] : "", pmatch);
d465 1
a465 1
		warnx("Too few arguments to patsubst");
d474 1
a474 1
	if (argv[4] == NULL)
@


1.6.2.1
log
@Pull in patch from current:
Fix (espie):
Fix stupid bug in argument handling. Problem found by fries@@
Jason, that's a candidate for stable...
@
text
@d1 1
a1 1
/* $OpenBSD: gnum4.c,v 1.7 2000/06/28 10:01:27 espie Exp $ */
d448 1
a448 2
	do_subst(argv[2], &re, 
	    argc != 4 && argv[4] != NULL ? argv[4] : "", pmatch);
d464 1
a464 1
		warnx("Too few arguments to regexp");
d473 1
a473 1
	if (argv[4] == NULL || argc == 4)
@


1.5
log
@Add a few builtins for greater compatibility with gnu-m4, and extended
functionality.
* regular expressions,
* line-number reporting
* `meta'-macros, builtin and indir.

Reviewed by pjanzen@@, tested by fries@@ and a few others.
@
text
@d1 1
a1 1
/* $OpenBSD: gnum4.c,v 1.4 2000/01/12 17:49:53 espie Exp $ */
d187 1
a187 1
		eval(argv+1, argc, n);
@


1.4
log
@Use a proper abstract interface for file accesses, so that we can record
the file name and line number.

This yields more meaningful error messages, and the possibility for yet
more.
@
text
@d1 1
a1 1
/* $OpenBSD: gnum4.c,v 1.3 1999/11/17 15:34:13 espie Exp $ */
d33 3
d45 3
d161 319
@


1.3
log
@Turn warnings on,
Add missing prototypes,
Make local functions static,
Sort extern.h by file,
Constify all char * that can be,
Copy temp file name so that eval does not modify its arguments.
@
text
@d1 1
a1 1
/* $OpenBSD: gnum4.c,v 1.2 1999/09/14 08:35:16 espie Exp $ */
d57 1
a57 1
static FILE *dopath __P((const char *));
d116 3
a118 2
FILE *
dopath(filename)
d123 1
a123 1
	FILE *file;
d127 4
a130 2
		if ((file = fopen(path, "r")) != 0)
			return file;
d135 3
a137 2
FILE *
fopen_trypath(filename)
d143 4
a146 2
	if (f)
		return f;
d152 1
a152 1
	return dopath(filename);
a153 2


@


1.2
log
@Style: kill register and indent properly.
Let indx match netbsd flavor, to simplify diffs.
Show how many quotes were not closed.
Increase stack slightly, now that we're no longer bound by argspace.
@
text
@d1 1
a1 1
/* $OpenBSD$ */
d55 4
d61 1
a61 1
	char *dirname;
d117 2
a118 1
dopath(const char *filename)
@


1.1
log
@Implement -I option and M4PATH environment variable
@
text
@@

