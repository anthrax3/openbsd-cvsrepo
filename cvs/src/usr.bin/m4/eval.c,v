head	1.74;
access;
symbols
	OPENBSD_6_0:1.74.0.8
	OPENBSD_6_0_BASE:1.74
	OPENBSD_5_9:1.74.0.4
	OPENBSD_5_9_BASE:1.74
	OPENBSD_5_8:1.74.0.6
	OPENBSD_5_8_BASE:1.74
	OPENBSD_5_7:1.74.0.2
	OPENBSD_5_7_BASE:1.74
	OPENBSD_5_6:1.73.0.4
	OPENBSD_5_6_BASE:1.73
	OPENBSD_5_5:1.71.0.4
	OPENBSD_5_5_BASE:1.71
	OPENBSD_5_4:1.70.0.6
	OPENBSD_5_4_BASE:1.70
	OPENBSD_5_3:1.70.0.4
	OPENBSD_5_3_BASE:1.70
	OPENBSD_5_2:1.70.0.2
	OPENBSD_5_2_BASE:1.70
	OPENBSD_5_1_BASE:1.69
	OPENBSD_5_1:1.69.0.4
	OPENBSD_5_0:1.69.0.2
	OPENBSD_5_0_BASE:1.69
	OPENBSD_4_9:1.68.0.2
	OPENBSD_4_9_BASE:1.68
	OPENBSD_4_8:1.67.0.2
	OPENBSD_4_8_BASE:1.67
	OPENBSD_4_7:1.66.0.4
	OPENBSD_4_7_BASE:1.66
	OPENBSD_4_6:1.66.0.6
	OPENBSD_4_6_BASE:1.66
	OPENBSD_4_5:1.66.0.2
	OPENBSD_4_5_BASE:1.66
	OPENBSD_4_4:1.63.0.10
	OPENBSD_4_4_BASE:1.63
	OPENBSD_4_3:1.63.0.8
	OPENBSD_4_3_BASE:1.63
	OPENBSD_4_2:1.63.0.6
	OPENBSD_4_2_BASE:1.63
	OPENBSD_4_1:1.63.0.4
	OPENBSD_4_1_BASE:1.63
	OPENBSD_4_0:1.63.0.2
	OPENBSD_4_0_BASE:1.63
	OPENBSD_3_9:1.59.0.2
	OPENBSD_3_9_BASE:1.59
	OPENBSD_3_8:1.57.0.2
	OPENBSD_3_8_BASE:1.57
	OPENBSD_3_7:1.55.0.2
	OPENBSD_3_7_BASE:1.55
	OPENBSD_3_6:1.51.0.4
	OPENBSD_3_6_BASE:1.51
	OPENBSD_3_5:1.51.0.2
	OPENBSD_3_5_BASE:1.51
	OPENBSD_3_4:1.50.0.2
	OPENBSD_3_4_BASE:1.50
	OPENBSD_3_3:1.45.0.4
	OPENBSD_3_3_BASE:1.45
	OPENBSD_3_2:1.45.0.2
	OPENBSD_3_2_BASE:1.45
	OPENBSD_3_1:1.43.0.2
	OPENBSD_3_1_BASE:1.43
	OPENBSD_3_0:1.41.0.2
	OPENBSD_3_0_BASE:1.41
	OPENBSD_2_9_BASE:1.28
	OPENBSD_2_9:1.28.0.4
	OPENBSD_2_8:1.28.0.2
	OPENBSD_2_8_BASE:1.28
	OPENBSD_2_7:1.26.0.2
	OPENBSD_2_7_BASE:1.26
	OPENBSD_2_6:1.17.0.2
	OPENBSD_2_6_BASE:1.17
	OPENBSD_2_5:1.11.0.4
	OPENBSD_2_5_BASE:1.11
	OPENBSD_2_4:1.11.0.2
	OPENBSD_2_4_BASE:1.11
	OPENBSD_2_3:1.10.0.2
	OPENBSD_2_3_BASE:1.10
	OPENBSD_2_2:1.9.0.2
	OPENBSD_2_2_BASE:1.9
	OPENBSD_2_1:1.7.0.2
	OPENBSD_2_1_BASE:1.7
	OPENBSD_2_0:1.6.0.2
	OPENBSD_2_0_BASE:1.6
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.74
date	2015.02.05.12.59.57;	author millert;	state Exp;
branches;
next	1.73;
commitid	DTQbfd4poqBW8iSJ;

1.73
date	2014.07.11.21.04.17;	author espie;	state Exp;
branches;
next	1.72;
commitid	6KeMvmAx3sl5ppfj;

1.72
date	2014.04.28.12.34.11;	author espie;	state Exp;
branches;
next	1.71;

1.71
date	2013.11.14.15.56.50;	author deraadt;	state Exp;
branches;
next	1.70;

1.70
date	2012.04.12.17.00.11;	author espie;	state Exp;
branches;
next	1.69;

1.69
date	2011.03.24.11.23.08;	author espie;	state Exp;
branches;
next	1.68;

1.68
date	2010.09.07.19.58.09;	author marco;	state Exp;
branches;
next	1.67;

1.67
date	2010.03.25.18.52.29;	author espie;	state Exp;
branches;
next	1.66;

1.66
date	2008.08.21.21.01.47;	author espie;	state Exp;
branches;
next	1.65;

1.65
date	2008.08.16.12.25.21;	author espie;	state Exp;
branches;
next	1.64;

1.64
date	2008.08.16.12.21.46;	author espie;	state Exp;
branches;
next	1.63;

1.63
date	2006.03.24.08.03.44;	author espie;	state Exp;
branches;
next	1.62;

1.62
date	2006.03.23.08.03.25;	author espie;	state Exp;
branches;
next	1.61;

1.61
date	2006.03.20.20.27.45;	author espie;	state Exp;
branches;
next	1.60;

1.60
date	2006.03.20.10.55.19;	author espie;	state Exp;
branches;
next	1.59;

1.59
date	2006.01.20.23.10.19;	author espie;	state Exp;
branches;
next	1.58;

1.58
date	2005.09.06.15.33.21;	author espie;	state Exp;
branches;
next	1.57;

1.57
date	2005.08.06.16.22.26;	author espie;	state Exp;
branches;
next	1.56;

1.56
date	2005.05.29.18.44.36;	author espie;	state Exp;
branches;
next	1.55;

1.55
date	2005.03.02.10.12.15;	author espie;	state Exp;
branches;
next	1.54;

1.54
date	2005.01.31.16.06.54;	author robert;	state Exp;
branches;
next	1.53;

1.53
date	2005.01.21.19.11.02;	author espie;	state Exp;
branches;
next	1.52;

1.52
date	2005.01.20.23.47.04;	author espie;	state Exp;
branches;
next	1.51;

1.51
date	2003.11.17.17.12.10;	author espie;	state Exp;
branches;
next	1.50;

1.50
date	2003.06.30.21.47.21;	author espie;	state Exp;
branches;
next	1.49;

1.49
date	2003.06.30.21.42.50;	author espie;	state Exp;
branches;
next	1.48;

1.48
date	2003.06.18.21.08.07;	author espie;	state Exp;
branches;
next	1.47;

1.47
date	2003.06.03.02.56.10;	author millert;	state Exp;
branches;
next	1.46;

1.46
date	2003.04.05.14.42.11;	author espie;	state Exp;
branches;
next	1.45;

1.45
date	2002.04.28.14.37.12;	author espie;	state Exp;
branches;
next	1.44;

1.44
date	2002.04.26.16.15.16;	author espie;	state Exp;
branches;
next	1.43;

1.43
date	2002.02.16.21.27.48;	author millert;	state Exp;
branches;
next	1.42;

1.42
date	2001.12.28.13.03.05;	author espie;	state Exp;
branches;
next	1.41;

1.41
date	2001.10.10.23.25.31;	author espie;	state Exp;
branches;
next	1.40;

1.40
date	2001.10.10.11.17.10;	author espie;	state Exp;
branches;
next	1.39;

1.39
date	2001.09.29.15.43.48;	author espie;	state Exp;
branches;
next	1.38;

1.38
date	2001.09.27.22.38.28;	author espie;	state Exp;
branches;
next	1.37;

1.37
date	2001.09.27.11.40.33;	author espie;	state Exp;
branches;
next	1.36;

1.36
date	2001.09.19.13.14.18;	author espie;	state Exp;
branches;
next	1.35;

1.35
date	2001.09.18.14.55.52;	author espie;	state Exp;
branches;
next	1.34;

1.34
date	2001.09.18.14.43.22;	author espie;	state Exp;
branches;
next	1.33;

1.33
date	2001.09.18.14.17.38;	author espie;	state Exp;
branches;
next	1.32;

1.32
date	2001.09.18.14.10.55;	author espie;	state Exp;
branches;
next	1.31;

1.31
date	2001.09.18.14.05.14;	author espie;	state Exp;
branches;
next	1.30;

1.30
date	2001.09.18.13.52.58;	author espie;	state Exp;
branches;
next	1.29;

1.29
date	2001.06.13.12.20.43;	author espie;	state Exp;
branches;
next	1.28;

1.28
date	2000.07.27.17.44.32;	author espie;	state Exp;
branches;
next	1.27;

1.27
date	2000.07.24.23.08.24;	author espie;	state Exp;
branches;
next	1.26;

1.26
date	2000.03.18.01.06.55;	author espie;	state Exp;
branches;
next	1.25;

1.25
date	2000.03.11.15.54.43;	author espie;	state Exp;
branches;
next	1.24;

1.24
date	2000.01.12.17.49.53;	author espie;	state Exp;
branches;
next	1.23;

1.23
date	2000.01.05.16.06.14;	author espie;	state Exp;
branches;
next	1.22;

1.22
date	99.12.21.22.30.47;	author espie;	state Exp;
branches;
next	1.21;

1.21
date	99.11.30.22.19.50;	author espie;	state Exp;
branches;
next	1.20;

1.20
date	99.11.17.15.34.13;	author espie;	state Exp;
branches;
next	1.19;

1.19
date	99.11.17.14.57.21;	author espie;	state Exp;
branches;
next	1.18;

1.18
date	99.11.16.17.06.11;	author espie;	state Exp;
branches;
next	1.17;

1.17
date	99.09.14.08.35.16;	author espie;	state Exp;
branches;
next	1.16;

1.16
date	99.09.14.08.23.09;	author espie;	state Exp;
branches;
next	1.15;

1.15
date	99.09.14.08.21.36;	author espie;	state Exp;
branches;
next	1.14;

1.14
date	99.09.06.13.24.59;	author espie;	state Exp;
branches;
next	1.13;

1.13
date	99.09.06.13.20.40;	author espie;	state Exp;
branches;
next	1.12;

1.12
date	99.09.06.13.10.48;	author espie;	state Exp;
branches;
next	1.11;

1.11
date	98.04.25.18.47.18;	author millert;	state Exp;
branches;
next	1.10;

1.10
date	97.12.20.15.39.13;	author deraadt;	state Exp;
branches;
next	1.9;

1.9
date	97.08.31.21.34.18;	author deraadt;	state Exp;
branches;
next	1.8;

1.8
date	97.08.31.21.33.26;	author deraadt;	state Exp;
branches;
next	1.7;

1.7
date	96.11.25.00.19.27;	author millert;	state Exp;
branches;
next	1.6;

1.6
date	96.09.15.18.59.07;	author millert;	state Exp;
branches;
next	1.5;

1.5
date	96.07.01.20.40.27;	author deraadt;	state Exp;
branches;
next	1.4;

1.4
date	96.06.26.05.36.11;	author deraadt;	state Exp;
branches;
next	1.3;

1.3
date	96.06.25.20.50.07;	author deraadt;	state Exp;
branches;
next	1.2;

1.2
date	96.01.15.01.12.11;	author deraadt;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.45.35;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.45.35;	author deraadt;	state Exp;
branches;
next	;


desc
@@


1.74
log
@Include stdint.h, not limits.h to get SIZE_MAX.  OK guenther@@
@
text
@/*	$OpenBSD: eval.c,v 1.73 2014/07/11 21:04:17 espie Exp $	*/
/*	$NetBSD: eval.c,v 1.7 1996/11/10 21:21:29 pk Exp $	*/

/*
 * Copyright (c) 1989, 1993
 *	The Regents of the University of California.  All rights reserved.
 *
 * This code is derived from software contributed to Berkeley by
 * Ozan Yigit at York University.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */

/*
 * eval.c
 * Facility: m4 macro processor
 * by: oz
 */

#include <sys/types.h>
#include <err.h>
#include <errno.h>
#include <limits.h>
#include <unistd.h>
#include <stdio.h>
#include <stdint.h>
#include <stdlib.h>
#include <stddef.h>
#include <string.h>
#include <fcntl.h>
#include "mdef.h"
#include "stdd.h"
#include "extern.h"
#include "pathnames.h"

static void	dodefn(const char *);
static void	dopushdef(const char *, const char *);
static void	dodump(const char *[], int);
static void	dotrace(const char *[], int, int);
static void	doifelse(const char *[], int);
static int	doincl(const char *);
static int	dopaste(const char *);
static void	dochq(const char *[], int);
static void	dochc(const char *[], int);
static void	dom4wrap(const char *);
static void	dodiv(int);
static void	doundiv(const char *[], int);
static void	dosub(const char *[], int);
static void	map(char *, const char *, const char *, const char *);
static const char *handledash(char *, char *, const char *);
static void	expand_builtin(const char *[], int, int);
static void	expand_macro(const char *[], int);
static void	dump_one_def(const char *, struct macro_definition *);

unsigned long	expansion_id;

/*
 * eval - eval all macros and builtins calls
 *	  argc - number of elements in argv.
 *	  argv - element vector :
 *			argv[0] = definition of a user
 *				  macro or NULL if built-in.
 *			argv[1] = name of the macro or
 *				  built-in.
 *			argv[2] = parameters to user-defined
 *			   .	  macro or built-in.
 *			   .
 *
 * A call in the form of macro-or-builtin() will result in:
 *			argv[0] = nullstr
 *			argv[1] = macro-or-builtin
 *			argv[2] = nullstr
 *
 * argc is 3 for macro-or-builtin() and 2 for macro-or-builtin
 */
void
eval(const char *argv[], int argc, int td, int is_traced)
{
	size_t mark = SIZE_MAX;

	expansion_id++;
	if (td & RECDEF)
		m4errx(1, "expanding recursive definition for %s.", argv[1]);
	if (is_traced)
		mark = trace(argv, argc, infile+ilevel);
	if (td == MACRTYPE)
		expand_macro(argv, argc);
	else
		expand_builtin(argv, argc, td);
	if (mark != SIZE_MAX)
		finish_trace(mark);
}

/*
 * expand_builtin - evaluate built-in macros.
 */
void
expand_builtin(const char *argv[], int argc, int td)
{
	int c, n;
	int ac;
	static int sysval = 0;

#ifdef DEBUG
	printf("argc = %d\n", argc);
	for (n = 0; n < argc; n++)
		printf("argv[%d] = %s\n", n, argv[n]);
	fflush(stdout);
#endif

 /*
  * if argc == 3 and argv[2] is null, then we
  * have macro-or-builtin() type call. We adjust
  * argc to avoid further checking..
  */
 /* we keep the initial value for those built-ins that differentiate
  * between builtin() and builtin.
  */
	ac = argc;

	if (argc == 3 && !*(argv[2]) && !mimic_gnu)
		argc--;

	switch (td & TYPEMASK) {

	case DEFITYPE:
		if (argc > 2)
			dodefine(argv[2], (argc > 3) ? argv[3] : null);
		break;

	case PUSDTYPE:
		if (argc > 2)
			dopushdef(argv[2], (argc > 3) ? argv[3] : null);
		break;

	case DUMPTYPE:
		dodump(argv, argc);
		break;

	case TRACEONTYPE:
		dotrace(argv, argc, 1);
		break;

	case TRACEOFFTYPE:
		dotrace(argv, argc, 0);
		break;

	case EXPRTYPE:
	/*
	 * doexpr - evaluate arithmetic
	 * expression
	 */
	{
		int base = 10;
		int maxdigits = 0;
		const char *errstr;

		if (argc > 3) {
			base = strtonum(argv[3], 2, 36, &errstr);
			if (errstr) {
				m4errx(1, "expr: base %s invalid.", argv[3]);
			}
		}
		if (argc > 4) {
			maxdigits = strtonum(argv[4], 0, INT_MAX, &errstr);
			if (errstr) {
				m4errx(1, "expr: maxdigits %s invalid.", argv[4]);
			}
		}
		if (argc > 2)
			pbnumbase(expr(argv[2]), base, maxdigits);
		break;
	}

	case IFELTYPE:
		if (argc > 4)
			doifelse(argv, argc);
		break;

	case IFDFTYPE:
	/*
	 * doifdef - select one of two
	 * alternatives based on the existence of
	 * another definition
	 */
		if (argc > 3) {
			if (lookup_macro_definition(argv[2]) != NULL)
				pbstr(argv[3]);
			else if (argc > 4)
				pbstr(argv[4]);
		}
		break;

	case LENGTYPE:
	/*
	 * dolen - find the length of the
	 * argument
	 */
		pbnum((argc > 2) ? strlen(argv[2]) : 0);
		break;

	case INCRTYPE:
	/*
	 * doincr - increment the value of the
	 * argument
	 */
		if (argc > 2)
			pbnum(atoi(argv[2]) + 1);
		break;

	case DECRTYPE:
	/*
	 * dodecr - decrement the value of the
	 * argument
	 */
		if (argc > 2)
			pbnum(atoi(argv[2]) - 1);
		break;

	case SYSCTYPE:
	/*
	 * dosys - execute system command
	 */
		if (argc > 2) {
			fflush(stdout);
			sysval = system(argv[2]);
		}
		break;

	case SYSVTYPE:
	/*
	 * dosysval - return value of the last
	 * system call.
	 *
	 */
		pbnum(sysval);
		break;

	case ESYSCMDTYPE:
		if (argc > 2)
			doesyscmd(argv[2]);
		break;
	case INCLTYPE:
		if (argc > 2) {
			if (!doincl(argv[2])) {
				if (mimic_gnu) {
					warn("%s at line %lu: include(%s)",
					    CURRENT_NAME, CURRENT_LINE, argv[2]);
					exit_code = 1;
				} else
					err(1, "%s at line %lu: include(%s)",
					    CURRENT_NAME, CURRENT_LINE, argv[2]);
			}
		}
		break;

	case SINCTYPE:
		if (argc > 2)
			(void) doincl(argv[2]);
		break;
#ifdef EXTENDED
	case PASTTYPE:
		if (argc > 2)
			if (!dopaste(argv[2]))
				err(1, "%s at line %lu: paste(%s)", 
				    CURRENT_NAME, CURRENT_LINE, argv[2]);
		break;

	case SPASTYPE:
		if (argc > 2)
			(void) dopaste(argv[2]);
		break;
	case FORMATTYPE:
		doformat(argv, argc);
		break;
#endif
	case CHNQTYPE:
		dochq(argv, ac);
		break;

	case CHNCTYPE:
		dochc(argv, argc);
		break;

	case SUBSTYPE:
	/*
	 * dosub - select substring
	 *
	 */
		if (argc > 3)
			dosub(argv, argc);
		break;

	case SHIFTYPE:
	/*
	 * doshift - push back all arguments
	 * except the first one (i.e. skip
	 * argv[2])
	 */
		if (argc > 3) {
			for (n = argc - 1; n > 3; n--) {
				pbstr(rquote);
				pbstr(argv[n]);
				pbstr(lquote);
				pushback(COMMA);
			}
			pbstr(rquote);
			pbstr(argv[3]);
			pbstr(lquote);
		}
		break;

	case DIVRTYPE:
		if (argc > 2 && (n = atoi(argv[2])) != 0)
			dodiv(n);
		else {
			active = stdout;
			oindex = 0;
		}
		break;

	case UNDVTYPE:
		doundiv(argv, argc);
		break;

	case DIVNTYPE:
	/*
	 * dodivnum - return the number of
	 * current output diversion
	 */
		pbnum(oindex);
		break;

	case UNDFTYPE:
	/*
	 * doundefine - undefine a previously
	 * defined macro(s) or m4 keyword(s).
	 */
		if (argc > 2)
			for (n = 2; n < argc; n++)
				macro_undefine(argv[n]);
		break;

	case POPDTYPE:
	/*
	 * dopopdef - remove the topmost
	 * definitions of macro(s) or m4
	 * keyword(s).
	 */
		if (argc > 2)
			for (n = 2; n < argc; n++)
				macro_popdef(argv[n]);
		break;

	case MKTMTYPE:
	/*
	 * dotemp - create a temporary file
	 */
		if (argc > 2) {
			int fd;
			char *temp;

			temp = xstrdup(argv[2]);

			fd = mkstemp(temp);
			if (fd == -1)
				err(1,
	    "%s at line %lu: couldn't make temp file %s",
	    CURRENT_NAME, CURRENT_LINE, argv[2]);
			close(fd);
			pbstr(temp);
			free(temp);
		}
		break;

	case TRNLTYPE:
	/*
	 * dotranslit - replace all characters in
	 * the source string that appears in the
	 * "from" string with the corresponding
	 * characters in the "to" string.
	 */
		if (argc > 3) {
			char *temp;

			temp = xalloc(strlen(argv[2])+1, NULL);
			if (argc > 4)
				map(temp, argv[2], argv[3], argv[4]);
			else
				map(temp, argv[2], argv[3], null);
			pbstr(temp);
			free(temp);
		} else if (argc > 2)
			pbstr(argv[2]);
		break;

	case INDXTYPE:
	/*
	 * doindex - find the index of the second
	 * argument string in the first argument
	 * string. -1 if not present.
	 */
		pbnum((argc > 3) ? indx(argv[2], argv[3]) : -1);
		break;

	case ERRPTYPE:
	/*
	 * doerrp - print the arguments to stderr
	 * file
	 */
		if (argc > 2) {
			for (n = 2; n < argc; n++)
				fprintf(stderr, "%s ", argv[n]);
			fprintf(stderr, "\n");
		}
		break;

	case DNLNTYPE:
	/*
	 * dodnl - eat-up-to and including
	 * newline
	 */
		while ((c = gpbc()) != '\n' && c != EOF)
			;
		break;

	case M4WRTYPE:
	/*
	 * dom4wrap - set up for
	 * wrap-up/wind-down activity
	 */
		if (argc > 2)
			dom4wrap(argv[2]);
		break;

	case EXITTYPE:
	/*
	 * doexit - immediate exit from m4.
	 */
		killdiv();
		exit((argc > 2) ? atoi(argv[2]) : 0);
		break;

	case DEFNTYPE:
		if (argc > 2)
			for (n = 2; n < argc; n++)
				dodefn(argv[n]);
		break;

	case INDIRTYPE:	/* Indirect call */
		if (argc > 2)
			doindir(argv, argc);
		break;

	case BUILTINTYPE: /* Builtins only */
		if (argc > 2)
			dobuiltin(argv, argc);
		break;

	case PATSTYPE:
		if (argc > 2)
			dopatsubst(argv, argc);
		break;
	case REGEXPTYPE:
		if (argc > 2)
			doregexp(argv, argc);
		break;
	case LINETYPE:
		doprintlineno(infile+ilevel);
		break;
	case FILENAMETYPE:
		doprintfilename(infile+ilevel);
		break;
	case SELFTYPE:
		pbstr(rquote);
		pbstr(argv[1]);
		pbstr(lquote);
		break;
	default:
		m4errx(1, "eval: major botch.");
		break;
	}
}

/*
 * expand_macro - user-defined macro expansion
 */
void
expand_macro(const char *argv[], int argc)
{
	const char *t;
	const char *p;
	int n;
	int argno;

	t = argv[0];		       /* defn string as a whole */
	p = t;
	while (*p)
		p++;
	p--;			       /* last character of defn */
	while (p > t) {
		if (*(p - 1) != ARGFLAG)
			PUSHBACK(*p);
		else {
			switch (*p) {

			case '#':
				pbnum(argc - 2);
				break;
			case '0':
			case '1':
			case '2':
			case '3':
			case '4':
			case '5':
			case '6':
			case '7':
			case '8':
			case '9':
				if ((argno = *p - '0') < argc - 1)
					pbstr(argv[argno + 1]);
				break;
			case '*':
				if (argc > 2) {
					for (n = argc - 1; n > 2; n--) {
						pbstr(argv[n]);
						pushback(COMMA);
					}
					pbstr(argv[2]);
				}
				break;
                        case '@@':
				if (argc > 2) {
					for (n = argc - 1; n > 2; n--) {
						pbstr(rquote);
						pbstr(argv[n]);
						pbstr(lquote);
						pushback(COMMA);
					}
					pbstr(rquote);
					pbstr(argv[2]);
					pbstr(lquote);
				}
                                break;
			default:
				PUSHBACK(*p);
				PUSHBACK('$');
				break;
			}
			p--;
		}
		p--;
	}
	if (p == t)		       /* do last character */
		PUSHBACK(*p);
}


/*
 * dodefine - install definition in the table
 */
void
dodefine(const char *name, const char *defn)
{
	if (!*name && !mimic_gnu)
		m4errx(1, "null definition.");
	else
		macro_define(name, defn);
}

/*
 * dodefn - push back a quoted definition of
 *      the given name.
 */
static void
dodefn(const char *name)
{
	struct macro_definition *p;

	if ((p = lookup_macro_definition(name)) != NULL) {
		if ((p->type & TYPEMASK) == MACRTYPE) {
			pbstr(rquote);
			pbstr(p->defn);
			pbstr(lquote);
		} else {
			pbstr(p->defn);
			pbstr(BUILTIN_MARKER);
		}
	}
}

/*
 * dopushdef - install a definition in the hash table
 *      without removing a previous definition. Since
 *      each new entry is entered in *front* of the
 *      hash bucket, it hides a previous definition from
 *      lookup.
 */
static void
dopushdef(const char *name, const char *defn)
{
	if (!*name && !mimic_gnu)
		m4errx(1, "null definition.");
	else
		macro_pushdef(name, defn);
}

/*
 * dump_one_def - dump the specified definition.
 */
static void
dump_one_def(const char *name, struct macro_definition *p)
{
	if (!traceout)
		traceout = stderr;
	if (mimic_gnu) {
		if ((p->type & TYPEMASK) == MACRTYPE)
			fprintf(traceout, "%s:\t%s\n", name, p->defn);
		else {
			fprintf(traceout, "%s:\t<%s>\n", name, p->defn);
		}
	} else
		fprintf(traceout, "`%s'\t`%s'\n", name, p->defn);
}

/*
 * dodumpdef - dump the specified definitions in the hash
 *      table to stderr. If nothing is specified, the entire
 *      hash table is dumped.
 */
static void
dodump(const char *argv[], int argc)
{
	int n;
	struct macro_definition *p;

	if (argc > 2) {
		for (n = 2; n < argc; n++)
			if ((p = lookup_macro_definition(argv[n])) != NULL)
				dump_one_def(argv[n], p);
	} else
		macro_for_all(dump_one_def);
}

/*
 * dotrace - mark some macros as traced/untraced depending upon on.
 */
static void
dotrace(const char *argv[], int argc, int on)
{
	int n;

	if (argc > 2) {
		for (n = 2; n < argc; n++)
			mark_traced(argv[n], on);
	} else
		mark_traced(NULL, on);
}

/*
 * doifelse - select one of two alternatives - loop.
 */
static void
doifelse(const char *argv[], int argc)
{
	cycle {
		if (STREQ(argv[2], argv[3]))
			pbstr(argv[4]);
		else if (argc == 6)
			pbstr(argv[5]);
		else if (argc > 6) {
			argv += 3;
			argc -= 3;
			continue;
		}
		break;
	}
}

/*
 * doinclude - include a given file.
 */
static int
doincl(const char *ifile)
{
	if (ilevel + 1 == MAXINP)
		m4errx(1, "too many include files.");
	if (fopen_trypath(infile+ilevel+1, ifile) != NULL) {
		ilevel++;
		bbase[ilevel] = bufbase = bp;
		return (1);
	} else
		return (0);
}

#ifdef EXTENDED
/*
 * dopaste - include a given file without any
 *           macro processing.
 */
static int
dopaste(const char *pfile)
{
	FILE *pf;
	int c;

	if ((pf = fopen(pfile, "r")) != NULL) {
		if (synch_lines)
		    fprintf(active, "#line 1 \"%s\"\n", pfile);
		while ((c = getc(pf)) != EOF)
			putc(c, active);
		(void) fclose(pf);
		emit_synchline();
		return (1);
	} else
		return (0);
}
#endif

/*
 * dochq - change quote characters
 */
static void
dochq(const char *argv[], int ac)
{
	if (ac == 2) {
		lquote[0] = LQUOTE; lquote[1] = EOS;
		rquote[0] = RQUOTE; rquote[1] = EOS;
	} else {
		strlcpy(lquote, argv[2], sizeof(lquote));
		if (ac > 3) {
			strlcpy(rquote, argv[3], sizeof(rquote));
		} else {
			rquote[0] = ECOMMT; rquote[1] = EOS;
		}
	}
}

/*
 * dochc - change comment characters
 */
static void
dochc(const char *argv[], int argc)
{
/* XXX Note that there is no difference between no argument and a single
 * empty argument.
 */
	if (argc == 2) {
		scommt[0] = EOS;
		ecommt[0] = EOS;
	} else {
		strlcpy(scommt, argv[2], sizeof(scommt));
		if (argc == 3) {
			ecommt[0] = ECOMMT; ecommt[1] = EOS;
		} else {
			strlcpy(ecommt, argv[3], sizeof(ecommt));
		}
	}
}

/*
 * dom4wrap - expand text at EOF
 */
static void
dom4wrap(const char *text)
{
	if (wrapindex >= maxwraps) {
		if (maxwraps == 0)
			maxwraps = 16;
		else
			maxwraps *= 2;
		m4wraps = xreallocarray(m4wraps, maxwraps, sizeof(*m4wraps),
		   "too many m4wraps");
	}
	m4wraps[wrapindex++] = xstrdup(text);
}

/*
 * dodivert - divert the output to a temporary file
 */
static void
dodiv(int n)
{
	int fd;

	oindex = n;
	if (n >= maxout) {
		if (mimic_gnu)
			resizedivs(n + 10);
		else
			n = 0;		/* bitbucket */
	}

	if (n < 0)
		n = 0;		       /* bitbucket */
	if (outfile[n] == NULL) {
		char fname[] = _PATH_DIVNAME;

		if ((fd = mkstemp(fname)) < 0 ||
		    unlink(fname) == -1 ||
		    (outfile[n] = fdopen(fd, "w+")) == NULL)
			err(1, "%s: cannot divert", fname);
	}
	active = outfile[n];
}

/*
 * doundivert - undivert a specified output, or all
 *              other outputs, in numerical order.
 */
static void
doundiv(const char *argv[], int argc)
{
	int ind;
	int n;

	if (argc > 2) {
		for (ind = 2; ind < argc; ind++) {
			const char *errstr;
			n = strtonum(argv[ind], 1, INT_MAX, &errstr);
			if (errstr) {
				if (errno == EINVAL && mimic_gnu)
					getdivfile(argv[ind]);
			} else {
				if (n < maxout && outfile[n] != NULL)
					getdiv(n);
			}
		}
	}
	else
		for (n = 1; n < maxout; n++)
			if (outfile[n] != NULL)
				getdiv(n);
}

/*
 * dosub - select substring
 */
static void
dosub(const char *argv[], int argc)
{
	const char *ap, *fc, *k;
	int nc;

	ap = argv[2];		       /* target string */
#ifdef EXPR
	fc = ap + expr(argv[3]);       /* first char */
#else
	fc = ap + atoi(argv[3]);       /* first char */
#endif
	nc = strlen(fc);
	if (argc >= 5)
#ifdef EXPR
		nc = min(nc, expr(argv[4]));
#else
		nc = min(nc, atoi(argv[4]));
#endif
	if (fc >= ap && fc < ap + strlen(ap))
		for (k = fc + nc - 1; k >= fc; k--)
			pushback(*k);
}

/*
 * map:
 * map every character of s1 that is specified in from
 * into s3 and replace in s. (source s1 remains untouched)
 *
 * This is derived from the a standard implementation of map(s,from,to) 
 * function of ICON language. Within mapvec, we replace every character 
 * of "from" with the corresponding character in "to". 
 * If "to" is shorter than "from", than the corresponding entries are null, 
 * which means that those characters dissapear altogether. 
 */
static void
map(char *dest, const char *src, const char *from, const char *to)
{
	const char *tmp;
	unsigned char sch, dch;
	static char frombis[257];
	static char tobis[257];
	int i;
	char seen[256];
	static unsigned char mapvec[256] = {
	    0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18,
	    19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35,
	    36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52,
	    53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69,
	    70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86,
	    87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99, 100, 101, 102,
	    103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115,
	    116, 117, 118, 119, 120, 121, 122, 123, 124, 125, 126, 127, 128,
	    129, 130, 131, 132, 133, 134, 135, 136, 137, 138, 139, 140, 141,
	    142, 143, 144, 145, 146, 147, 148, 149, 150, 151, 152, 153, 154,
	    155, 156, 157, 158, 159, 160, 161, 162, 163, 164, 165, 166, 167,
	    168, 169, 170, 171, 172, 173, 174, 175, 176, 177, 178, 179, 180,
	    181, 182, 183, 184, 185, 186, 187, 188, 189, 190, 191, 192, 193,
	    194, 195, 196, 197, 198, 199, 200, 201, 202, 203, 204, 205, 206,
	    207, 208, 209, 210, 211, 212, 213, 214, 215, 216, 217, 218, 219,
	    220, 221, 222, 223, 224, 225, 226, 227, 228, 229, 230, 231, 232,
	    233, 234, 235, 236, 237, 238, 239, 240, 241, 242, 243, 244, 245,
	    246, 247, 248, 249, 250, 251, 252, 253, 254, 255
	};

	if (*src) {
		if (mimic_gnu) {
			/*
			 * expand character ranges on the fly
			 */
			from = handledash(frombis, frombis + 256, from);
			to = handledash(tobis, tobis + 256, to);
		}
		tmp = from;
	/*
	 * create a mapping between "from" and
	 * "to"
	 */
		for (i = 0; i < 256; i++)
			seen[i] = 0;
		while (*from) {
			if (!seen[(unsigned char)(*from)]) {
				mapvec[(unsigned char)(*from)] = (unsigned char)(*to);
				seen[(unsigned char)(*from)] = 1;
			}
			from++;
			if (*to)
				to++;
		}

		while (*src) {
			sch = (unsigned char)(*src++);
			dch = mapvec[sch];
			if ((*dest = (char)dch))
				dest++;
		}
	/*
	 * restore all the changed characters
	 */
		while (*tmp) {
			mapvec[(unsigned char)(*tmp)] = (unsigned char)(*tmp);
			tmp++;
		}
	}
	*dest = '\0';
}


/*
 * handledash:
 *  use buffer to copy the src string, expanding character ranges
 * on the way.
 */
static const char *
handledash(char *buffer, char *end, const char *src)
{
	char *p;

	p = buffer;
	while(*src) {
		if (src[1] == '-' && src[2]) {
			unsigned char i;
			if ((unsigned char)src[0] <= (unsigned char)src[2]) {
				for (i = (unsigned char)src[0]; 
				    i <= (unsigned char)src[2]; i++) {
					*p++ = i;
					if (p == end) {
						*p = '\0';
						return buffer;
					}
				}
			} else {
				for (i = (unsigned char)src[0]; 
				    i >= (unsigned char)src[2]; i--) {
					*p++ = i;
					if (p == end) {
						*p = '\0';
						return buffer;
					}
				}
			}
			src += 3;
		} else
			*p++ = *src++;
		if (p == end)
			break;
	}
	*p = '\0';
	return buffer;
}
@


1.73
log
@better error handling in mkstemp/unlink/fdopen logic.
from Doug Hogan <doug@@acyclic.org>
okay miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: eval.c,v 1.72 2014/04/28 12:34:11 espie Exp $	*/
d48 1
@


1.72
log
@check for integer overflows in custom allocs, okay jca@@
@
text
@d1 1
a1 1
/*	$OpenBSD: eval.c,v 1.71 2013/11/14 15:56:50 deraadt Exp $	*/
d820 4
a823 5
		if ((fd = mkstemp(fname)) < 0 || 
			(outfile[n] = fdopen(fd, "w+")) == NULL)
				err(1, "%s: cannot divert", fname);
		if (unlink(fname) == -1)
			err(1, "%s: cannot unlink", fname);
@


1.71
log
@cleanup up a nest of if/if/else
@
text
@d1 1
a1 1
/*	$OpenBSD: eval.c,v 1.70 2012/04/12 17:00:11 espie Exp $	*/
d793 1
a793 1
		m4wraps = xrealloc(m4wraps, maxwraps * sizeof(*m4wraps),
@


1.70
log
@new m4 -g stuff:
- expr(`4**3')
- include(`hey I am not there') keeps going.

work with Baptiste Daroussin, who had the idea but didn't nail all details
right.

okay otto@@, miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: eval.c,v 1.69 2011/03/24 11:23:08 espie Exp $	*/
d265 2
a266 2
		if (argc > 2)
			if (!doincl(argv[2]))
d274 2
@


1.69
log
@fix translit() behavior to not be recursive. Fixes autoconf 2.65, matches
behavior of solaris m4 (e.g., posix).

Bug-fix by Nigel Taylor

Okay sthen@@, todd@@.

Comment amended per sthen@@' suggestion.
@
text
@d1 1
a1 1
/*	$OpenBSD: eval.c,v 1.68 2010/09/07 19:58:09 marco Exp $	*/
d267 7
a273 2
				err(1, "%s at line %lu: include(%s)",
				    CURRENT_NAME, CURRENT_LINE, argv[2]);
@


1.68
log
@Remove stray spaces.  No code change.
@
text
@d1 1
a1 1
/*	$OpenBSD: eval.c,v 1.67 2010/03/25 18:52:29 espie Exp $	*/
d883 5
a887 19
 * This is a standard implementation of map(s,from,to) function of ICON
 * language. Within mapvec, we replace every character of "from" with
 * the corresponding character in "to". If "to" is shorter than "from",
 * than the corresponding entries are null, which means that those
 * characters dissapear altogether. Furthermore, imagine
 * map(dest, "sourcestring", "srtin", "rn..*") type call. In this case,
 * `s' maps to `r', `r' maps to `n' and `n' maps to `*'. Thus, `s'
 * ultimately maps to `*'. In order to achieve this effect in an efficient
 * manner (i.e. without multiple passes over the destination string), we
 * loop over mapvec, starting with the initial source character. if the
 * character value (dch) in this location is different than the source
 * character (sch), sch becomes dch, once again to index into mapvec, until
 * the character value stabilizes (i.e. sch = dch, in other words
 * mapvec[n] == n). Even if the entry in the mapvec is null for an ordinary
 * character, it will stabilize, since mapvec[0] == 0 at all times. At the
 * end, we restore mapvec* back to normal where mapvec[n] == n for
 * 0 <= n <= 127. This strategy, along with the restoration of mapvec, is
 * about 5 times faster than any algorithm that makes multiple passes over
 * destination string.
a946 4
			while (dch != sch) {
				sch = dch;
				dch = mapvec[sch];
			}
@


1.67
log
@conform to gnum4 AND traditional m4 (solaris) behavior, namely,
translit(`ab',`aa',`cd') -> `cb'
(first occurrence matches)

okay miod@@, sthen@@
fixes minor autoconf issues, like HAVE_VOID__ instead of HAVE_VOID_P
@
text
@d1 1
a1 1
/*	$OpenBSD: eval.c,v 1.66 2008/08/21 21:01:47 espie Exp $	*/
d103 1
a103 1
	if (td & RECDEF) 
d111 1
a111 1
    	if (mark != SIZE_MAX)
d140 1
a140 1
  	ac = argc;
d255 1
a255 1
	 * 
d263 1
a263 1
	    	break;
d302 1
a302 1
	 * 
d378 1
a378 1
			
d381 2
a382 2
				err(1, 
	    "%s at line %lu: couldn't make temp file %s", 
d468 1
a468 1
	
d544 1
a544 1
			    	}
d581 1
a581 1
	else 
d635 1
a635 1
	    	}
d806 1
a806 1
    	}
d989 1
a989 1
	
@


1.66
log
@in gnu-m4 mode, allow definition of the empty macro (yes, autoconf 2.62
actually uses this, bleh)

okay otto@@
@
text
@d1 1
a1 1
/*	$OpenBSD: eval.c,v 1.65 2008/08/16 12:25:21 espie Exp $	*/
d910 2
d946 11
a956 3
		while (*from)
			mapvec[(unsigned char)(*from++)] = (*to) ? 
				(unsigned char)(*to++) : 0;
@


1.65
log
@revert eval.c
@
text
@d1 1
a1 1
/*	$OpenBSD: eval.c,v 1.63 2006/03/24 08:03:44 espie Exp $	*/
d142 1
a142 1
	if (argc == 3 && !*(argv[2]))
d579 1
a579 1
	if (!*name)
d581 2
a582 1
	macro_define(name, defn);
d616 1
a616 1
	if (!*name)
d618 2
a619 1
	macro_pushdef(name, defn);
@


1.64
log
@argument parsing should only skip spaces outside of parenthesis.
Inside matching parenthesis, keep spaces as is (use chrsave instead of
pbstr, since there's no way it can be a further macro expansion).
Fixes a long-standing issue with autoconf (   --option -> --option),
matches other m4 than gnum4

okay millert@@, fries@@
@
text
@d142 1
a142 1
	if (argc == 3 && !*(argv[2]) && !mimic_gnu)
d579 1
a579 1
	if (!*name && !mimic_gnu)
d581 1
a581 2
	else 
		macro_define(name, defn);
d615 1
a615 1
	if (!*name && !mimic_gnu)
d617 1
a617 2
	else
		macro_pushdef(name, defn);
@


1.63
log
@oops, noticed by David Hill.
@
text
@d1 1
a1 1
/*	$OpenBSD: eval.c,v 1.62 2006/03/23 08:03:25 espie Exp $	*/
d142 1
a142 1
	if (argc == 3 && !*(argv[2]))
d579 1
a579 1
	if (!*name)
d581 2
a582 1
	macro_define(name, defn);
d616 1
a616 1
	if (!*name)
d618 2
a619 1
	macro_pushdef(name, defn);
@


1.62
log
@... and remove extra test that is no longer needed.
@
text
@d1 1
a1 1
/*	$OpenBSD: eval.c,v 1.61 2006/03/20 20:27:45 espie Exp $	*/
d43 1
@


1.61
log
@add limited support for format builtin in gnu-m4 mode, because I'm fed
up of patching it away in various autoconf derivatives.

okay miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: eval.c,v 1.60 2006/03/20 10:55:19 espie Exp $	*/
d287 1
a287 4
		if (mimic_gnu)
			doformat(argv, argc);
		else
			m4errx(1, "format builtin is only available in gnu-m4 mode.");
@


1.60
log
@report function m4errx, that shows app-specific data (filename/linenumber)
before the error message. Use it to simplify code.

okay miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: eval.c,v 1.59 2006/01/20 23:10:19 espie Exp $	*/
d285 6
@


1.59
log
@use stdint.h where appropriate. okay millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: eval.c,v 1.58 2005/09/06 15:33:21 espie Exp $	*/
a50 1
#include <err.h>
d103 1
a103 2
		errx(1, "%s at line %lu: expanding recursive definition for %s",
			CURRENT_NAME, CURRENT_LINE, argv[1]);
d181 1
a181 1
				errx(1, "base %s invalid", argv[3]);
d187 1
a187 1
				errx(1, "maxdigits %s invalid", argv[4]);
d490 1
a490 2
		errx(1, "%s at line %lu: eval: major botch.",
			CURRENT_NAME, CURRENT_LINE);
d576 1
a576 2
		errx(1, "%s at line %lu: null definition.", CURRENT_NAME,
		    CURRENT_LINE);
d612 1
a612 2
		errx(1, "%s at line %lu: null definition", CURRENT_NAME,
		    CURRENT_LINE);
d695 1
a695 2
		errx(1, "%s at line %lu: too many include files.",
		    CURRENT_NAME, CURRENT_LINE);
@


1.58
log
@finally make our m4 SusV3-compliant.

- changecom and changequote have a simple definition (that matches gnu-m4,
coincidentally, so we no longer need two distinct modes for these)

- off-by-one bug in -s, this finally works.

- reorder main parser loop, so that we can use alphabetic constructs in
quotes/comments.

- rename putback to pushback, this matches comments, and makes more sense.

- more uniform (and updated) description of changequote/changecom.

- new, systematic regression tests of comments/quotes.

- framework to test -s: one perl script to reconstitute `full' files with
all line numbers, so that we can verify the output without needing a
complete match.

okay otto@@, fries@@
@
text
@d1 1
a1 1
/*	$OpenBSD: eval.c,v 1.57 2005/08/06 16:22:26 espie Exp $	*/
d100 1
a100 1
	ssize_t mark = -1;
d112 1
a112 1
    	if (mark != -1)
@


1.57
log
@zap rcsid. It's not ramdisk, but they still take space.
@
text
@d1 1
a1 1
/*	$OpenBSD: eval.c,v 1.56 2005/05/29 18:44:36 espie Exp $	*/
a63 1
static void	gnu_dochq(const char *[], int);
a64 1
static void	gnu_dochc(const char *[], int);
d138 3
d290 1
a290 4
		if (mimic_gnu)
			gnu_dochq(argv, ac);
		else
			dochq(argv, argc);
d294 1
a294 4
		if (mimic_gnu)
			gnu_dochc(argv, ac);
		else
			dochc(argv, argc);
d317 1
a317 1
				putback(COMMA);
d516 1
a516 1
			PUTBACK(*p);
d540 1
a540 1
						putback(COMMA);
d551 1
a551 1
						putback(COMMA);
d559 2
a560 2
				PUTBACK(*p);
				PUTBACK('$');
d568 1
a568 1
		PUTBACK(*p);
d734 3
d738 1
a738 1
gnu_dochq(const char *argv[], int ac)
a739 2
	/* In gnu-m4 mode, the only way to restore quotes is to have no
	 * arguments at all. */
d741 2
a742 2
		lquote[0] = LQUOTE, lquote[1] = EOS;
		rquote[0] = RQUOTE, rquote[1] = EOS;
d745 1
a745 1
		if(ac > 3)
d747 3
a749 2
		else
			rquote[0] = EOS;
d754 1
a754 1
 * dochq - change quote characters
d757 1
a757 1
dochq(const char *argv[], int argc)
d759 4
a762 24
	if (argc > 2) {
		if (*argv[2])
			strlcpy(lquote, argv[2], sizeof(lquote));
		else {
			lquote[0] = LQUOTE;
			lquote[1] = EOS;
		}
		if (argc > 3) {
			if (*argv[3])
				strlcpy(rquote, argv[3], sizeof(rquote));
		} else
			strlcpy(rquote, lquote, sizeof(rquote));
	} else {
		lquote[0] = LQUOTE, lquote[1] = EOS;
		rquote[0] = RQUOTE, rquote[1] = EOS;
	}
}

static void
gnu_dochc(const char *argv[], int ac)
{
	/* In gnu-m4 mode, no arguments mean no comment
	 * arguments at all. */
	if (ac == 2) {
d766 4
a769 5
		if (*argv[2])
			strlcpy(scommt, argv[2], sizeof(scommt));
		else
			scommt[0] = SCOMMT, scommt[1] = EOS;
		if(ac > 3 && *argv[3])
a770 16
		else
			ecommt[0] = ECOMMT, ecommt[1] = EOS;
	}
}
/*
 * dochc - change comment characters
 */
static void
dochc(const char *argv[], int argc)
{
	if (argc > 2) {
		if (*argv[2])
			strlcpy(scommt, argv[2], sizeof(scommt));
		if (argc > 3) {
			if (*argv[3])
				strlcpy(ecommt, argv[3], sizeof(ecommt));
a771 6
		else
			ecommt[0] = ECOMMT, ecommt[1] = EOS;
	}
	else {
		scommt[0] = SCOMMT, scommt[1] = EOS;
		ecommt[0] = ECOMMT, ecommt[1] = EOS;
d875 1
a875 1
			putback(*k);
@


1.56
log
@fix a few minor compatibility issues.
- let eval() handle a base and number of digits, like it's advertized to.
- in gnu-mode, undivert can take file names as arguments.
- in gnu-mode, map can handle reversed charsets.

Suggestions and okay otto@@, mostly prompted by looking at the regress
tests in newer gnu-m4.
@
text
@d1 1
a1 1
/*	$OpenBSD: eval.c,v 1.55 2005/03/02 10:12:15 espie Exp $	*/
a34 8

#ifndef lint
#if 0
static char sccsid[] = "@@(#)eval.c	8.2 (Berkeley) 4/27/95";
#else
static char rcsid[] = "$OpenBSD: eval.c,v 1.55 2005/03/02 10:12:15 espie Exp $";
#endif
#endif /* not lint */
@


1.55
log
@let m4wrap handle multiple wraps, both in normal and gnu-mode.
based on Noah Misch's bug report.
okay otto, jmc.
@
text
@d1 1
a1 1
/*	$OpenBSD: eval.c,v 1.54 2005/01/31 16:06:54 robert Exp $	*/
d40 1
a40 1
static char rcsid[] = "$OpenBSD: eval.c,v 1.54 2005/01/31 16:06:54 robert Exp $";
d52 1
d182 17
d200 1
a200 1
			pbnum(expr(argv[2]));
d202 1
d888 9
a896 4
			n = atoi(argv[ind]);
			if (n > 0 && n < maxout && outfile[n] != NULL)
				getdiv(n);

d1038 17
a1054 6
			for (i = (unsigned char)src[0]; 
			    i <= (unsigned char)src[2]; i++) {
				*p++ = i;
				if (p == end) {
					*p = '\0';
					return buffer;
@


1.54
log
@use fflush(stdout) before system() so we won't miss any
wanted output; from Andreas Burmester <buster_hh@@gmx.net>

ok espie@@
@
text
@d1 1
a1 1
/*	$OpenBSD: eval.c,v 1.53 2005/01/21 19:11:02 espie Exp $	*/
d40 1
a40 1
static char rcsid[] = "$OpenBSD: eval.c,v 1.53 2005/01/21 19:11:02 espie Exp $";
d75 1
d438 2
a439 1
		m4wraps = (argc > 2) ? xstrdup(argv[2]) : null;
d808 17
@


1.53
log
@more portable code, stderr is not necessarily a constant.
@
text
@d1 1
a1 1
/*	$OpenBSD: eval.c,v 1.52 2005/01/20 23:47:04 espie Exp $	*/
d40 1
a40 1
static char rcsid[] = "$OpenBSD: eval.c,v 1.52 2005/01/20 23:47:04 espie Exp $";
d233 2
a234 1
		if (argc > 2)
d236 1
@


1.52
log
@remove unused variables, extra declarations.
@
text
@d1 1
a1 1
/*	$OpenBSD: eval.c,v 1.51 2003/11/17 17:12:10 espie Exp $	*/
d40 1
a40 1
static char rcsid[] = "$OpenBSD: eval.c,v 1.51 2003/11/17 17:12:10 espie Exp $";
d617 2
@


1.51
log
@Modify xalloc so that it also takes err(3)-like arguments.
Write an xrealloc wrapper that works the same way, and use it as well.

People who feel like it may want to add more explicit error messages to
all the places m4 can fail allocating memory...

okay tedu@@
@
text
@d1 1
a1 1
/*	$OpenBSD: eval.c,v 1.50 2003/06/30 21:47:21 espie Exp $	*/
d40 1
a40 1
static char rcsid[] = "$OpenBSD: eval.c,v 1.50 2003/06/30 21:47:21 espie Exp $";
a581 1
	char *real;
@


1.50
log
@Make the trace status of a macro an actual argument that gets pushed
in the frame for the macro expansion.

(This will allow one single lookup to grab the macro definition and
the trace status)

okay millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: eval.c,v 1.49 2003/06/30 21:42:50 espie Exp $	*/
d40 1
a40 1
static char rcsid[] = "$OpenBSD: eval.c,v 1.49 2003/06/30 21:42:50 espie Exp $";
d389 1
a389 1
			temp = xalloc(strlen(argv[2])+1);
@


1.49
log
@clean up internal lookup interface:
define an interface with explicit define/pushdef/popdef... and use it.
That way, most details of the hashtable are no longer visible.

okay millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: eval.c,v 1.48 2003/06/18 21:08:07 espie Exp $	*/
d40 1
a40 1
static char rcsid[] = "$OpenBSD: eval.c,v 1.48 2003/06/18 21:08:07 espie Exp $";
d106 1
a106 1
eval(const char *argv[], int argc, int td)
d114 1
a114 1
	if (traced_macros && is_traced(argv[1]))
@


1.48
log
@- store builtin name as definition for builtin macros.
this removes the need for code->name conversion, in exchange for
systematically testing the definition type, since we can no longer
rely on the defn being NULL.

- commonnalize the builtin-detection code, so that we can use it for pushdef
as well with define, so that pushdef handles builtins correctly as well.

okay fries@@, millert@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: eval.c,v 1.47 2003/06/03 02:56:10 millert Exp $	*/
d40 1
a40 1
static char rcsid[] = "$OpenBSD: eval.c,v 1.47 2003/06/03 02:56:10 millert Exp $";
a63 3
#define BUILTIN_MARKER	"__builtin_"

static void 	setup_definition(ndptr, const char *);
d82 1
a82 1
static void	dump_one_def(ndptr);
d91 1
a91 1
 *				  macro or nil if built-in.
d196 1
a196 1
			if (lookup(argv[2]) != nil)
d344 1
a344 1
				remhash(argv[n], ALL);
d355 1
a355 1
				remhash(argv[n], TOP);
a562 25
 * common part to dodefine and dopushdef
 */
static void 
setup_definition(ndptr p, const char *defn)
{
	int n;

	if (strncmp(defn, BUILTIN_MARKER, sizeof(BUILTIN_MARKER)-1) == 0) {
		n = builtin_type(defn+sizeof(BUILTIN_MARKER)-1);
		if (n != -1) {
			p->type = n & TYPEMASK;
			if ((n & NOARGS) == 0)
				p->type |= NEEDARGS;
			p->defn = xstrdup(defn+sizeof(BUILTIN_MARKER)-1);
			return;
		}
	}
	if (!*defn)
		p->defn = null;
	else
		p->defn = xstrdup(defn);
	p->type = MACRTYPE;
}

/*
a567 2
	ndptr p;

d571 1
a571 7
	if ((p = lookup(name)) == nil)
		p = addent(name);
	else if (p->defn != null)
		free((char *) p->defn);
	setup_definition(p, defn);
	if (STREQ(name, defn))
		p->type |= RECDEF;
d581 1
a581 1
	ndptr p;
d584 1
a584 1
	if ((p = lookup(name)) != nil) {
a605 2
	ndptr p;

d609 1
a609 4
	p = addent(name);
	setup_definition(p, defn);
	if (STREQ(name, defn))
		p->type |= RECDEF;
d616 1
a616 1
dump_one_def(ndptr p)
d620 1
a620 1
			fprintf(traceout, "%s:\t%s\n", p->name, p->defn);
d622 1
a622 1
			fprintf(traceout, "%s:\t<%s>\n", p->name, p->defn);
d625 1
a625 1
		fprintf(traceout, "`%s'\t`%s'\n", p->name, p->defn);
d637 1
a637 1
	ndptr p;
d641 4
a644 7
			if ((p = lookup(argv[n])) != nil)
				dump_one_def(p);
	} else {
		for (n = 0; n < HASHSIZE; n++)
			for (p = hashtab[n]; p != nil; p = p->nxtptr)
				dump_one_def(p);
	}
@


1.47
log
@Remove the advertising clause in the UCB license which Berkeley
rescinded 22 July 1999.  Proofed by myself and Theo.
@
text
@d1 1
a1 1
/*	$OpenBSD: eval.c,v 1.46 2003/04/05 14:42:11 espie Exp $	*/
d40 1
a40 1
static char rcsid[] = "$OpenBSD: eval.c,v 1.46 2003/04/05 14:42:11 espie Exp $";
d66 1
d564 1
d566 1
a566 1
 * dodefine - install definition in the table
d568 2
a569 2
void
dodefine(const char *name, const char *defn)
a570 1
	ndptr p;
a572 7
	if (!*name)
		errx(1, "%s at line %lu: null definition.", CURRENT_NAME,
		    CURRENT_LINE);
	if ((p = lookup(name)) == nil)
		p = addent(name);
	else if (p->defn != null)
		free((char *) p->defn);
d579 1
a579 1
			p->defn = null;
d588 18
d621 1
a621 1
		if (p->defn != null) {
d625 2
a626 2
		} else if ((real = builtin_realname(p->type)) != NULL) {
			pbstr(real);
d648 1
a648 5
	if (!*defn)
		p->defn = null;
	else
		p->defn = xstrdup(defn);
	p->type = MACRTYPE;
a658 2
	char *real;

d663 1
a663 4
			real = builtin_realname(p->type);
			if (real == NULL)
				real = null;
			fprintf(traceout, "%s:\t<%s>\n", p->name, real);
@


1.46
log
@say goodbye to strcpy, okay deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: eval.c,v 1.45 2002/04/28 14:37:12 espie Exp $	*/
d19 1
a19 5
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
d40 1
a40 1
static char rcsid[] = "$OpenBSD: eval.c,v 1.45 2002/04/28 14:37:12 espie Exp $";
@


1.45
log
@Implement -s.
Triggered by recent FreeBSD changes.

- emits #line directives at every file change (like FreeBSD)
- maintains a synch_lineno variable to verify when the output gets out
of synch with the input, so that it can emit #line to re-synch as well
(unlike FreeBSD)

To do: either handle \end-of-line, or recognize when a macro expansion
is in progress, so that line synch don't perturb cpp on multi-line
expansions.

With this, we should have a fully POSIX-compliant m4.

ok miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: eval.c,v 1.44 2002/04/26 16:15:16 espie Exp $	*/
d44 1
a44 1
static char rcsid[] = "$OpenBSD: eval.c,v 1.44 2002/04/26 16:15:16 espie Exp $";
d802 1
a802 1
			strcpy(rquote, lquote);
@


1.44
log
@use ansi function declarations. ok millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: eval.c,v 1.43 2002/02/16 21:27:48 millert Exp $	*/
d44 1
a44 1
static char rcsid[] = "$OpenBSD: eval.c,v 1.43 2002/02/16 21:27:48 millert Exp $";
d756 2
d761 1
@


1.43
log
@Part one of userland __P removal.  Done with a simple regexp with some minor hand editing to make comments line up correctly.  Another pass is forthcoming that handles the cases that could not be done automatically.
@
text
@d1 1
a1 1
/*	$OpenBSD: eval.c,v 1.42 2001/12/28 13:03:05 espie Exp $	*/
d44 1
a44 1
static char rcsid[] = "$OpenBSD: eval.c,v 1.42 2001/12/28 13:03:05 espie Exp $";
d112 1
a112 4
eval(argv, argc, td)
	const char *argv[];
	int argc;
	int td;
d134 1
a134 4
expand_builtin(argv, argc, td)
	const char *argv[];
	int argc;
	int td;
d498 1
a498 3
expand_macro(argv, argc)
	const char *argv[];
	int argc;
d571 1
a571 3
dodefine(name, defn)
	const char *name;
	const char *defn;
d607 1
a607 2
dodefn(name)
	const char *name;
d632 1
a632 3
dopushdef(name, defn)
	const char *name;
	const char *defn;
d653 1
a653 2
dump_one_def(p)
	ndptr p;
d676 1
a676 3
dodump(argv, argc)
	const char *argv[];
	int argc;
d696 1
a696 4
dotrace(argv, argc, on)
	const char *argv[];
	int argc;
	int on;
d711 1
a711 3
doifelse(argv, argc)
	const char *argv[];
	int argc;
d731 1
a731 2
doincl(ifile)
	const char *ifile;
d750 1
a750 2
dopaste(pfile)
	const char *pfile;
d766 1
a766 3
gnu_dochq(argv, ac)
	const char *argv[];
	int ac;
d786 1
a786 3
dochq(argv, argc)
	const char *argv[];
	int argc;
d807 1
a807 3
gnu_dochc(argv, ac)
	const char *argv[];
	int ac;
d829 1
a829 3
dochc(argv, argc)
	const char *argv[];
	int argc;
d851 1
a851 2
dodiv(n)
	int n;
d882 1
a882 3
doundiv(argv, argc)
	const char *argv[];
	int argc;
d905 1
a905 3
dosub(argv, argc)
	const char *argv[];
	int argc;
d954 1
a954 5
map(dest, src, from, to)
	char *dest;
	const char *src;
	const char *from;
	const char *to;
d1026 1
a1026 4
handledash(buffer, end, src)
	char *buffer;
	char *end;
	const char *src;
a1050 1
			    
@


1.42
log
@Kill yet another hardcoded size. Ok fries@@
and flush(stdout) on debugging mode, as a vicious coredump can leave you
without info otherwise.
@
text
@d1 1
a1 1
/*	$OpenBSD: eval.c,v 1.41 2001/10/10 23:25:31 espie Exp $	*/
d44 1
a44 1
static char rcsid[] = "$OpenBSD: eval.c,v 1.41 2001/10/10 23:25:31 espie Exp $";
d70 19
a88 19
static void	dodefn __P((const char *));
static void	dopushdef __P((const char *, const char *));
static void	dodump __P((const char *[], int));
static void	dotrace __P((const char *[], int, int));
static void	doifelse __P((const char *[], int));
static int	doincl __P((const char *));
static int	dopaste __P((const char *));
static void	gnu_dochq __P((const char *[], int));
static void	dochq __P((const char *[], int));
static void	gnu_dochc __P((const char *[], int));
static void	dochc __P((const char *[], int));
static void	dodiv __P((int));
static void	doundiv __P((const char *[], int));
static void	dosub __P((const char *[], int));
static void	map __P((char *, const char *, const char *, const char *));
static const char *handledash __P((char *, char *, const char *));
static void	expand_builtin __P((const char *[], int, int));
static void	expand_macro __P((const char *[], int));
static void	dump_one_def __P((ndptr));
@


1.41
log
@Handle macro expansion even if argc==2, which can happen in indir() calls.
Problem encountered by obecian@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: eval.c,v 1.40 2001/10/10 11:17:10 espie Exp $	*/
d44 1
a44 1
static char rcsid[] = "$OpenBSD: eval.c,v 1.40 2001/10/10 11:17:10 espie Exp $";
d150 1
d399 3
a401 1
			char temp[STRSPMAX+1];
d407 1
@


1.40
log
@Fix indent
@
text
@d1 1
a1 1
/*	$OpenBSD: eval.c,v 1.39 2001/09/29 15:43:48 espie Exp $	*/
d44 1
a44 1
static char rcsid[] = "$OpenBSD: eval.c,v 1.39 2001/09/29 15:43:48 espie Exp $";
d537 7
a543 5
				for (n = argc - 1; n > 2; n--) {
					pbstr(argv[n]);
					putback(COMMA);
				}
				pbstr(argv[2]);
d546 11
a556 9
                                for (n = argc - 1; n > 2; n--) {
                                        pbstr(rquote);
                                        pbstr(argv[n]);
                                        pbstr(lquote);
					putback(COMMA);
                                }
				pbstr(rquote);
                                pbstr(argv[2]);
				pbstr(lquote);
@


1.39
log
@Synchronize comment with reality.
In gnu-m4 mode, pass the real number of arguments to changequote/changecom,
since those distinguish changequote() from changequote.
@
text
@d1 1
a1 1
/*	$OpenBSD: eval.c,v 1.38 2001/09/27 22:38:28 espie Exp $	*/
d44 1
a44 1
static char rcsid[] = "$OpenBSD: eval.c,v 1.38 2001/09/27 22:38:28 espie Exp $";
d617 3
a619 3
		pbstr(rquote);
		pbstr(p->defn);
		pbstr(lquote);
@


1.38
log
@pass all properties of builtins when defn...
@
text
@d1 1
a1 1
/*	$OpenBSD: eval.c,v 1.37 2001/09/27 11:40:33 espie Exp $	*/
d44 1
a44 1
static char rcsid[] = "$OpenBSD: eval.c,v 1.37 2001/09/27 11:40:33 espie Exp $";
d77 1
d79 1
d94 16
a134 15
 *	  argc - number of elements in argv.
 *	  argv - element vector :
 *			argv[0] = definition of a user
 *				  macro or nil if built-in.
 *			argv[1] = name of the macro or
 *				  built-in.
 *			argv[2] = parameters to user-defined
 *			   .	  macro or built-in.
 *			   .
 *
 * Note that the minimum value for argc is 3. A call in the form
 * of macro-or-builtin() will result in:
 *			argv[0] = nullstr
 *			argv[1] = macro-or-builtin
 *			argv[2] = nullstr
a135 1

d143 1
d157 2
d286 4
a289 1
		dochq(argv, argc);
d293 4
a296 1
		dochc(argv, argc);
d780 19
a806 9
	/* In gnu-m4 mode, having two empty arguments means no quotes at
	 * all.  */
	if (mimic_gnu) {
		if (argc > 3 && !*argv[2] && !*argv[3]) {
			lquote[0] = EOS;
			rquote[0] = EOS;
			return;
		}
	}
d825 21
@


1.37
log
@traceon/traceoff built-ins.
@
text
@d1 1
a1 1
/*	$OpenBSD: eval.c,v 1.36 2001/09/19 13:14:18 espie Exp $	*/
d44 1
a44 1
static char rcsid[] = "$OpenBSD: eval.c,v 1.36 2001/09/19 13:14:18 espie Exp $";
d577 3
a579 1
			p->type = n;
@


1.36
log
@inline some very common putback/chrsave. Worth roughly 10%
@
text
@d1 1
a1 1
/*	$OpenBSD: eval.c,v 1.35 2001/09/18 14:55:52 espie Exp $	*/
d44 1
a44 1
static char rcsid[] = "$OpenBSD: eval.c,v 1.35 2001/09/18 14:55:52 espie Exp $";
d73 1
d173 8
d685 18
@


1.35
log
@Tracing facilities. Same style as gnu-m4, because it's mostly used for
autoconf right now.
@
text
@d1 1
a1 1
/*	$OpenBSD: eval.c,v 1.34 2001/09/18 14:43:22 espie Exp $	*/
d44 1
a44 1
static char rcsid[] = "$OpenBSD: eval.c,v 1.34 2001/09/18 14:43:22 espie Exp $";
d496 1
a496 1
			putback(*p);
d535 2
a536 2
				putback(*p);
				putback('$');
d544 1
a544 1
		putback(*p);
@


1.34
log
@instrumentation for tracing mode: macro expansion
@
text
@d1 1
a1 1
/*	$OpenBSD: eval.c,v 1.33 2001/09/18 14:17:38 espie Exp $	*/
d44 1
a44 1
static char rcsid[] = "$OpenBSD: eval.c,v 1.33 2001/09/18 14:17:38 espie Exp $";
d98 2
d104 2
d110 2
d643 1
a643 1
			fprintf(stderr, "%s:\t%s\n", p->name, p->defn);
d648 1
a648 1
			fprintf(stderr, "%s:\t<%s>\n", p->name, real);
d651 1
a651 1
		fprintf(stderr, "`%s'\t`%s'\n", p->name, p->defn);
@


1.33
log
@better gnu m4 emulation for dumpdef
@
text
@d1 1
a1 1
/*	$OpenBSD: eval.c,v 1.32 2001/09/18 14:10:55 espie Exp $	*/
d44 1
a44 1
static char rcsid[] = "$OpenBSD: eval.c,v 1.32 2001/09/18 14:10:55 espie Exp $";
d87 1
d98 1
@


1.32
log
@let dumpdef go thru dump_one_def for each def.
@
text
@d1 1
a1 1
/*	$OpenBSD: eval.c,v 1.31 2001/09/18 14:05:14 espie Exp $	*/
d44 1
a44 1
static char rcsid[] = "$OpenBSD: eval.c,v 1.31 2001/09/18 14:05:14 espie Exp $";
d631 13
a643 1
	fprintf(stderr, "`%s'\t`%s'\n", p->name, p->defn);
@


1.31
log
@let defn(builtin) work enough so that
define(`newmacro', defn(builtin))
will work, as it should.
@
text
@d1 1
a1 1
/*	$OpenBSD: eval.c,v 1.30 2001/09/18 13:52:58 espie Exp $	*/
d44 1
a44 1
static char rcsid[] = "$OpenBSD: eval.c,v 1.30 2001/09/18 13:52:58 espie Exp $";
d85 1
a467 2
char *dumpfmt = "`%s'\t`%s'\n";	       /* format string for dumpdef   */

d625 10
d650 1
a650 2
				fprintf(stderr, dumpfmt, p->name,
					p->defn);
d654 1
a654 2
				fprintf(stderr, dumpfmt, p->name,
					p->defn);
@


1.30
log
@One single point for all macros/builtin expansion.
@
text
@d1 1
a1 1
/*	$OpenBSD: eval.c,v 1.29 2001/06/13 12:20:43 espie Exp $	*/
d44 1
a44 1
static char rcsid[] = "$OpenBSD: eval.c,v 1.29 2001/06/13 12:20:43 espie Exp $";
d68 2
d549 1
d558 8
d584 1
d586 2
a587 1
	if ((p = lookup(name)) != nil && p->defn != null) {
d591 4
@


1.29
log
@Fix PR 1868. MAXSTR has no place there.
MAXSTR is still a hard limit, but only for token length, where 512
characters seems reasonable.
Ok millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: eval.c,v 1.28 2000/07/27 17:44:32 espie Exp $	*/
d44 1
a44 1
static char rcsid[] = "$OpenBSD: eval.c,v 1.28 2000/07/27 17:44:32 espie Exp $";
d81 4
d86 19
a104 1
 * eval - evaluate built-in macros.
d123 1
a123 1
eval(argv, argc, td)
a136 3
	if (td & RECDEF) 
		errx(1, "%s at line %lu: expanding recursive definition for %s",
			CURRENT_NAME, CURRENT_LINE, argv[1]);
d468 1
a468 1
 * expand - user-defined macro expansion
d471 1
a471 1
expand(argv, argc)
@


1.28
log
@Handle unlimited diverts for m4 -g.

Problem with autoconf noticed by d@@
@
text
@d1 1
a1 1
/*	$OpenBSD: eval.c,v 1.27 2000/07/24 23:08:24 espie Exp $	*/
d44 1
a44 1
static char rcsid[] = "$OpenBSD: eval.c,v 1.27 2000/07/24 23:08:24 espie Exp $";
d804 1
a804 3
	if (argc < 5)
		nc = MAXTOK;
	else
d806 1
a806 1
		nc = expr(argv[4]);
d808 1
a808 1
		nc = atoi(argv[4]);
d810 2
a811 1
	ap = argv[2];		       /* target string */
d813 1
a813 1
	fc = ap + expr(argv[3]);       /* first char */
d815 1
a815 1
	fc = ap + atoi(argv[3]);       /* first char */
d818 1
a818 1
		for (k = fc + min(nc, strlen(fc)) - 1; k >= fc; k--)
@


1.27
log
@Implement esyscmd
@
text
@d1 1
a1 1
/*	$OpenBSD: eval.c,v 1.26 2000/03/18 01:06:55 espie Exp $	*/
d44 1
a44 1
static char rcsid[] = "$OpenBSD: eval.c,v 1.26 2000/03/18 01:06:55 espie Exp $";
d746 8
a753 1
	if (n < 0 || n >= MAXOUT)
d782 1
a782 1
			if (n > 0 && n < MAXOUT && outfile[n] != NULL)
d788 1
a788 1
		for (n = 1; n < MAXOUT; n++)
@


1.26
log
@Last needed m4 changes to bootstrap autoconf without gnu-m4.
@
text
@d1 1
a1 1
/*	$OpenBSD: eval.c,v 1.25 2000/03/11 15:54:43 espie Exp $	*/
d44 1
a44 1
static char rcsid[] = "$OpenBSD: eval.c,v 1.25 2000/03/11 15:54:43 espie Exp $";
d213 4
@


1.25
log
@Add a few builtins for greater compatibility with gnu-m4, and extended
functionality.
* regular expressions,
* line-number reporting
* `meta'-macros, builtin and indir.

Reviewed by pjanzen@@, tested by fries@@ and a few others.
@
text
@d1 1
a1 1
/*	$OpenBSD: eval.c,v 1.24 2000/01/12 17:49:53 espie Exp $	*/
d44 1
a44 1
static char rcsid[] = "$OpenBSD: eval.c,v 1.24 2000/01/12 17:49:53 espie Exp $";
d80 1
d681 9
d846 2
d870 7
d906 37
@


1.24
log
@Use a proper abstract interface for file accesses, so that we can record
the file name and line number.

This yields more meaningful error messages, and the possibility for yet
more.
@
text
@d1 1
a1 1
/*	$OpenBSD: eval.c,v 1.23 2000/01/05 16:06:14 espie Exp $	*/
d44 1
a44 1
static char rcsid[] = "$OpenBSD: eval.c,v 1.23 2000/01/05 16:06:14 espie Exp $";
d405 24
@


1.23
log
@Close PR-1021. make unix or vms `special' macros that expand to
themselves, with the proper quotes added.

Matches gnu-m4, not Solaris nor FreeBSD... better for robustness, as
it makes for more transparent expansions.
@
text
@d1 1
a1 1
/*	$OpenBSD: eval.c,v 1.22 1999/12/21 22:30:47 espie Exp $	*/
d44 1
a44 1
static char rcsid[] = "$OpenBSD: eval.c,v 1.22 1999/12/21 22:30:47 espie Exp $";
d115 2
a116 1
		errx(1, "expanding recursive definition for %s", argv[1]);
d215 2
a216 1
				err(1, "%s", argv[2]);
d227 2
a228 1
				err(1, "%s", argv[2]);
d326 3
a328 1
				err(1, "couldn't make temp file %s", argv[2]);
d411 2
a412 1
		errx(1, "eval: major botch.");
d501 2
a502 1
		errx(1, "null definition.");
d548 2
a549 1
		errx(1, "null definition");
d616 3
a618 2
		errx(1, "too many include files.");
	if ((infile[ilevel + 1] = fopen_trypath(ifile)) != NULL) {
@


1.22
log
@Recursive definitions are not the real problem.
Trying to expand them is.

So flag obvious recursive definitions for later, and give an error
only if we expand them.

(Some gnu-m4 files, including autoconf, do define some macros with
themselves as the replacement text, for use in test-if-set patterns)

Since type is no longer MACRTYPE, those macros end up in builtins...
but this is not a problem, since expanding them is an error.
@
text
@d1 1
a1 1
/*	$OpenBSD: eval.c,v 1.21 1999/11/30 22:19:50 espie Exp $	*/
d44 1
a44 1
static char rcsid[] = "$OpenBSD: eval.c,v 1.21 1999/11/30 22:19:50 espie Exp $";
d400 5
@


1.21
log
@Clean up comment/quote recognition a little bit:
- use strlcpy to make clear that the strings are line terminated,
- remove the number of magic constants,
- use assert() for preconditions,
- use puts instead of looping over array of chars...
@
text
@d1 1
a1 1
/*	$OpenBSD: eval.c,v 1.20 1999/11/17 15:34:13 espie Exp $	*/
d44 1
a44 1
static char rcsid[] = "$OpenBSD: eval.c,v 1.20 1999/11/17 15:34:13 espie Exp $";
d113 3
d124 1
a124 1
	switch (td & ~STATIC) {
a490 2
	if (STREQ(name, defn))
		errx(1, "%s: recursive definition.", name);
d500 2
a536 2
	if (STREQ(name, defn))
		errx(1, "%s: recursive definition.", name);
d543 2
@


1.20
log
@Turn warnings on,
Add missing prototypes,
Make local functions static,
Sort extern.h by file,
Constify all char * that can be,
Copy temp file name so that eval does not modify its arguments.
@
text
@d1 1
a1 1
/*	$OpenBSD: eval.c,v 1.19 1999/11/17 14:57:21 espie Exp $	*/
d44 1
a44 1
static char rcsid[] = "$OpenBSD: eval.c,v 1.19 1999/11/17 14:57:21 espie Exp $";
d641 1
a641 1
			strncpy(lquote, argv[2], MAXCCHARS);
d648 1
a648 1
				strncpy(rquote, argv[3], MAXCCHARS);
d667 1
a667 1
			strncpy(scommt, argv[2], MAXCCHARS);
d670 1
a670 1
				strncpy(ecommt, argv[3], MAXCCHARS);
@


1.19
log
@Ensure translit works with accented characters.
@
text
@d1 1
a1 1
/*	$OpenBSD: eval.c,v 1.18 1999/11/16 17:06:11 espie Exp $	*/
d44 1
a44 1
static char rcsid[] = "$OpenBSD: eval.c,v 1.18 1999/11/16 17:06:11 espie Exp $";
d68 12
d101 1
a101 1
	char *argv[];
d314 3
d318 1
a318 1
			fd = mkstemp(argv[2]);
d322 2
a323 1
			pbstr(argv[2]);
d410 1
a410 1
	char *argv[];
d413 2
a414 2
	char *t;
	char *p;
d481 2
a482 2
	char *name;
	char *defn;
d505 1
a505 1
void
d507 1
a507 1
	char *name;
d525 1
a525 1
void
d527 2
a528 2
	char *name;
	char *defn;
d549 1
a549 1
void
d551 1
a551 1
	char *argv[];
d573 1
a573 1
void
d575 1
a575 1
	char *argv[];
d595 1
a595 1
int
d597 1
a597 1
	char *ifile;
d614 1
a614 1
int
d616 1
a616 1
	char *pfile;
d634 1
a634 1
void
d636 1
a636 1
	char *argv[];
d660 1
a660 1
void
d662 1
a662 1
	char *argv[];
d684 1
a684 1
void
d709 1
a709 1
void
d711 1
a711 1
	char *argv[];
d734 1
a734 1
void
d736 1
a736 1
	char *argv[];
d739 1
a739 1
	char *ap, *fc, *k;
d786 1
a786 1
void
d789 3
a791 3
	char *src;
	char *from;
	char *to;
d793 1
a793 1
	char *tmp;
@


1.18
log
@Close PR 961, approved by millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: eval.c,v 1.17 1999/09/14 08:35:16 espie Exp $	*/
d44 1
a44 1
static char rcsid[] = "$OpenBSD: eval.c,v 1.17 1999/09/14 08:35:16 espie Exp $";
d778 20
a797 13
	char sch, dch;
	static char mapvec[128] = {
		0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11,
		12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23,
		24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35,
		36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47,
		48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59,
		60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71,
		72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83,
		84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95,
		96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107,
		108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119,
		120, 121, 122, 123, 124, 125, 126, 127
d807 2
a808 1
			mapvec[*from++] = (*to) ? *to++ : (char) 0;
d811 1
a811 1
			sch = *src++;
d817 1
a817 1
			if ((*dest = dch))
d824 1
a824 1
			mapvec[*tmp] = *tmp;
d828 1
a828 1
	*dest = (char) 0;
@


1.17
log
@Style: kill register and indent properly.
Let indx match netbsd flavor, to simplify diffs.
Show how many quotes were not closed.
Increase stack slightly, now that we're no longer bound by argspace.
@
text
@d1 1
a1 1
/*	$OpenBSD: eval.c,v 1.14 1999/09/06 13:24:59 espie Exp $	*/
d44 1
a44 1
static char rcsid[] = "$OpenBSD: eval.c,v 1.14 1999/09/06 13:24:59 espie Exp $";
d158 1
a158 2
		if (argc > 2)
			pbnum((argc > 2) ? strlen(argv[2]) : 0);
@


1.16
log
@mktemp -> mkstemp
@
text
@d1 1
a1 1
/*	$OpenBSD: eval.c,v 1.15 1999/09/14 08:21:36 espie Exp $	*/
d44 1
a44 1
static char rcsid[] = "$OpenBSD: eval.c,v 1.15 1999/09/14 08:21:36 espie Exp $";
d89 3
a91 3
register char *argv[];
register int argc;
register int td;
d93 1
a93 1
	register int c, n;
d395 2
a396 2
register char *argv[];
register int argc;
d398 4
a401 4
	register char *t;
	register char *p;
	register int n;
	register int argno;
d466 2
a467 2
register char *name;
register char *defn;
d469 1
a469 1
	register ndptr p;
d492 1
a492 1
char *name;
d494 1
a494 1
	register ndptr p;
d512 2
a513 2
register char *name;
register char *defn;
d515 1
a515 1
	register ndptr p;
d536 2
a537 2
register char *argv[];
register int argc;
d539 1
a539 1
	register int n;
d560 2
a561 2
register char *argv[];
register int argc;
d582 1
a582 1
char *ifile;
d601 1
a601 1
char *pfile;
d604 1
a604 1
	register int c;
d621 2
a622 2
register char *argv[];
register int argc;
d647 2
a648 2
register char *argv[];
register int argc;
d671 1
a671 1
register int n;
d696 2
a697 2
register char *argv[];
register int argc;
d699 2
a700 2
	register int ind;
	register int n;
d721 2
a722 2
register char *argv[];
register int argc;
d724 2
a725 2
	register char *ap, *fc, *k;
	register int nc;
d773 4
a776 4
register char *dest;
register char *src;
register char *from;
register char *to;
d778 2
a779 2
	register char *tmp;
	register char sch, dch;
@


1.15
log
@Implement -I option and M4PATH environment variable
@
text
@d1 1
a1 1
/*	$OpenBSD: eval.c,v 1.14 1999/09/06 13:24:59 espie Exp $	*/
d44 1
a44 1
static char rcsid[] = "$OpenBSD: eval.c,v 1.14 1999/09/06 13:24:59 espie Exp $";
d301 9
a309 2
		if (argc > 2)
			pbstr(mktemp(argv[2]));
@


1.14
log
@Use EOS pervasively.
@
text
@d1 1
a1 1
/*	$OpenBSD: eval.c,v 1.11 1998/04/25 18:47:18 millert Exp $	*/
d44 1
a44 1
static char rcsid[] = "$OpenBSD: eval.c,v 1.11 1998/04/25 18:47:18 millert Exp $";
d579 1
a579 1
	if ((infile[ilevel + 1] = fopen(ifile, "r")) != NULL) {
@


1.13
log
@Get rid of mktemp in the handling of diversion.

Simply put, mkstemp/unlink/rewind has the proper semantics under Unix,
and so we don't have to keep track about temp file names and remove them.
@
text
@d622 1
a622 1
			lquote[1] = '\0';
d630 2
a631 2
		lquote[0] = LQUOTE, lquote[1] = '\0';
		rquote[0] = RQUOTE, rquote[1] = '\0';
d651 1
a651 1
			ecommt[0] = ECOMMT, ecommt[1] = '\0';
d654 2
a655 2
		scommt[0] = SCOMMT, scommt[1] = '\0';
		ecommt[0] = ECOMMT, ecommt[1] = '\0';
@


1.12
log
@Misc minor changes:
- use err.h and kill oops,
- use __progname and kill basename,
- let indx use strstr
- proper EOS decl
@
text
@d59 1
d672 7
a678 4
		m4temp[UNIQUE] = n + '0';
		if ((fd = open(m4temp, O_CREAT|O_EXCL|O_WRONLY, 0600)) < 0 ||
		    (outfile[n] = fdopen(fd, "w")) == NULL)
			err(1, "%s: cannot divert", m4temp);
@


1.11
log
@-Wall
@
text
@d1 1
a1 1
/*	$OpenBSD: eval.c,v 1.10 1997/12/20 15:39:13 deraadt Exp $	*/
d44 1
a44 1
static char rcsid[] = "$OpenBSD: eval.c,v 1.10 1997/12/20 15:39:13 deraadt Exp $";
d61 1
d199 1
a199 1
				oops("%s: %s", argv[2], strerror(errno));
d210 1
a210 1
				oops("%s: %s", argv[2], strerror(errno));
d375 1
a375 1
		oops("%s: major botch.", "eval");
d464 1
a464 1
		oops("null definition.");
d466 1
a466 1
		oops("%s: recursive definition.", name);
d510 1
a510 1
		oops("null definition");
d512 1
a512 1
		oops("%s: recursive definition.", name);
d577 1
a577 1
		oops("too many include files.");
d674 1
a674 1
			oops("%s: cannot divert.", m4temp);
@


1.10
log
@Simplify some push-back code (e.g. for left and right quotes) so that
it uses pbstr() instead of doing the characters individually (in
reverse order) with putback(); cgd
@
text
@d1 1
a1 1
/*	$OpenBSD: eval.c,v 1.9 1997/08/31 21:34:18 deraadt Exp $	*/
d44 1
a44 1
static char rcsid[] = "$OpenBSD: eval.c,v 1.9 1997/08/31 21:34:18 deraadt Exp $";
a240 1
			int k;
d798 1
a798 1
			if (*dest = dch)
@


1.9
log
@wish i had tested
@
text
@d1 1
a1 1
/*	$OpenBSD: eval.c,v 1.8 1997/08/31 21:33:26 deraadt Exp $	*/
d44 1
a44 1
static char rcsid[] = "$OpenBSD: eval.c,v 1.8 1997/08/31 21:33:26 deraadt Exp $";
d243 1
a243 3
				k = strlen(rquote);
				while (k--)
					putback(rquote[k]);
d245 1
a245 3
				k = strlen(lquote);
				while (k--)
					putback(lquote[k]);
d248 1
a248 3
			k = strlen(rquote);
			while (k--)
				putback(rquote[k]);
d250 1
a250 3
			k = strlen(lquote);
			while (k--)
				putback(lquote[k]);
d489 1
a489 3
		int n = strlen(rquote);
		while (n--)
			putback(rquote[n]);
d491 1
a491 3
		n = strlen(lquote);
		while (n--)
			putback(lquote[n]);
@


1.8
log
@from jlemon@@freebsd; divnum is no longer silently restricted to the
range 0..9, changequote(,) is now a synonym for changequote, buffer
size for translit() enlarged to handle a full string
@
text
@d1 1
a1 1
/*	$OpenBSD: eval.c,v 1.7 1996/11/25 00:19:27 millert Exp $	*/
d44 1
a44 1
static char rcsid[] = "$OpenBSD: eval.c,v 1.7 1996/11/25 00:19:27 millert Exp $";
d629 1
a629 1
		if (*argv[2]) {
d631 4
a634 2
		else
			strncpy(lquote, LQUOTE, MAXCCHARS);
@


1.7
log
@Sync with NetBSD.
Implement `$@@' macro, as promised by the manual page (NetBSD PR#2914).
@
text
@d1 1
a1 1
/*	$OpenBSD: eval.c,v 1.6 1996/09/15 18:59:07 millert Exp $	*/
d44 1
a44 1
static char rcsid[] = "$OpenBSD: eval.c,v 1.6 1996/09/15 18:59:07 millert Exp $";
d320 1
a320 1
			char temp[MAXTOK];
d326 1
a326 2
		}
		else if (argc > 2)
d551 1
a551 2
	}
	else {
d594 1
a594 2
	}
	else
d615 1
a615 2
	}
	else
d629 1
a629 1
		if (*argv[2])
d631 2
d636 1
a636 2
		}
		else
d638 1
a638 2
	}
	else {
d677 1
a685 1
	oindex = n;
@


1.6
log
@Slightly safer temp file open.
@
text
@d1 2
a2 2
/*      $OpenBSD: eval.c,v 1.5 1996/07/01 20:40:27 deraadt Exp $      */
/*      $NetBSD: eval.c,v 1.5 1996/01/13 23:25:23 pk Exp $      */
d44 1
a44 1
static char rcsid[] = "$OpenBSD: eval.c,v 1.5 1996/07/01 20:40:27 deraadt Exp $";
d250 1
a250 1
				putback(',');
d434 1
a434 1
					putback(',');
d438 11
@


1.5
log
@undo mktemp cleanup until i get it right
@
text
@d1 1
a1 1
/*      $OpenBSD: eval.c,v 1.4 1996/06/26 05:36:11 deraadt Exp $      */
d44 1
a44 1
static char rcsid[] = "$OpenBSD: eval.c,v 1.4 1996/06/26 05:36:11 deraadt Exp $";
d60 1
d668 2
d674 2
a675 1
		if ((outfile[n] = fopen(m4temp, "w")) == NULL)
@


1.4
log
@rcsid
@
text
@d1 1
a1 1
/*      $OpenBSD: eval.c,v 1.5 1996/01/13 23:25:23 pk Exp $      */
d44 1
a44 1
static char rcsid[] = "$OpenBSD: eval.c,v 1.5 1996/01/13 23:25:23 pk Exp $";
a54 1
#include <sys/file.h>
a666 2
	int fd;

d671 1
a671 4
		if ((fd = open(m4temp, O_RDWR|O_EXCL|O_CREAT, 0666)) == -1 ||
		    (outfile[n] = fdopen(fd, "w")) == NULL) {
			if (fd != -1)
				close(fd);
a672 1
		}
@


1.3
log
@mktemp open + fdopen
@
text
@d1 1
d44 1
a44 1
static char rcsid[] = "$NetBSD: eval.c,v 1.5 1996/01/13 23:25:23 pk Exp $";
@


1.2
log
@from netbsd:
Handle multichar comment and quote delimiters (up to 5 characters, per the
manual page). Takes care of PR#485.
@
text
@d54 1
d667 2
d673 4
a676 1
		if ((outfile[n] = fopen(m4temp, "w")) == NULL)
d678 1
@


1.1
log
@Initial revision
@
text
@d1 1
a1 1
/*      $NetBSD: eval.c,v 1.4 1995/09/28 05:37:28 tls Exp $      */
d43 1
a43 1
static char rcsid[] = "$NetBSD: eval.c,v 1.4 1995/09/28 05:37:28 tls Exp $";
d239 1
d241 3
a243 1
				putback(rquote);
d245 3
a247 1
				putback(lquote);
d250 3
a252 1
			putback(rquote);
d254 3
a256 1
			putback(lquote);
d485 3
a487 1
		putback(rquote);
d489 3
a491 1
		putback(lquote);
d621 1
a621 1
			lquote = *argv[2];
d624 1
a624 1
				rquote = *argv[3];
d627 1
a627 1
			rquote = lquote;
d630 2
a631 2
		lquote = LQUOTE;
		rquote = RQUOTE;
d645 1
a645 1
			scommt = *argv[2];
d648 1
a648 1
				ecommt = *argv[3];
d651 1
a651 1
			ecommt = ECOMMT;
d654 2
a655 2
		scommt = SCOMMT;
		ecommt = ECOMMT;
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@
