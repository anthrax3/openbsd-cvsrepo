head	1.16;
access;
symbols
	OPENBSD_6_1:1.16.0.28
	OPENBSD_6_1_BASE:1.16
	OPENBSD_6_0:1.16.0.24
	OPENBSD_6_0_BASE:1.16
	OPENBSD_5_9:1.16.0.20
	OPENBSD_5_9_BASE:1.16
	OPENBSD_5_8:1.16.0.22
	OPENBSD_5_8_BASE:1.16
	OPENBSD_5_7:1.16.0.14
	OPENBSD_5_7_BASE:1.16
	OPENBSD_5_6:1.16.0.18
	OPENBSD_5_6_BASE:1.16
	OPENBSD_5_5:1.16.0.16
	OPENBSD_5_5_BASE:1.16
	OPENBSD_5_4:1.16.0.12
	OPENBSD_5_4_BASE:1.16
	OPENBSD_5_3:1.16.0.10
	OPENBSD_5_3_BASE:1.16
	OPENBSD_5_2:1.16.0.8
	OPENBSD_5_2_BASE:1.16
	OPENBSD_5_1_BASE:1.16
	OPENBSD_5_1:1.16.0.6
	OPENBSD_5_0:1.16.0.4
	OPENBSD_5_0_BASE:1.16
	OPENBSD_4_9:1.16.0.2
	OPENBSD_4_9_BASE:1.16
	OPENBSD_4_8:1.15.0.18
	OPENBSD_4_8_BASE:1.15
	OPENBSD_4_7:1.15.0.14
	OPENBSD_4_7_BASE:1.15
	OPENBSD_4_6:1.15.0.16
	OPENBSD_4_6_BASE:1.15
	OPENBSD_4_5:1.15.0.12
	OPENBSD_4_5_BASE:1.15
	OPENBSD_4_4:1.15.0.10
	OPENBSD_4_4_BASE:1.15
	OPENBSD_4_3:1.15.0.8
	OPENBSD_4_3_BASE:1.15
	OPENBSD_4_2:1.15.0.6
	OPENBSD_4_2_BASE:1.15
	OPENBSD_4_1:1.15.0.4
	OPENBSD_4_1_BASE:1.15
	OPENBSD_4_0:1.15.0.2
	OPENBSD_4_0_BASE:1.15
	OPENBSD_3_9:1.13.0.2
	OPENBSD_3_9_BASE:1.13
	OPENBSD_3_8:1.12.0.4
	OPENBSD_3_8_BASE:1.12
	OPENBSD_3_7:1.12.0.2
	OPENBSD_3_7_BASE:1.12
	OPENBSD_3_6:1.10.0.6
	OPENBSD_3_6_BASE:1.10
	OPENBSD_3_5:1.10.0.4
	OPENBSD_3_5_BASE:1.10
	OPENBSD_3_4:1.10.0.2
	OPENBSD_3_4_BASE:1.10
	OPENBSD_3_3:1.6.0.4
	OPENBSD_3_3_BASE:1.6
	OPENBSD_3_2:1.6.0.2
	OPENBSD_3_2_BASE:1.6
	OPENBSD_3_1:1.4.0.2
	OPENBSD_3_1_BASE:1.4
	OPENBSD_3_0:1.3.0.2
	OPENBSD_3_0_BASE:1.3;
locks; strict;
comment	@ * @;


1.16
date	2010.09.07.19.58.09;	author marco;	state Exp;
branches;
next	1.15;

1.15
date	2006.03.24.08.03.44;	author espie;	state Exp;
branches;
next	1.14;

1.14
date	2006.03.20.10.55.19;	author espie;	state Exp;
branches;
next	1.13;

1.13
date	2006.01.20.23.10.19;	author espie;	state Exp;
branches;
next	1.12;

1.12
date	2005.01.21.19.11.02;	author espie;	state Exp;
branches;
next	1.11;

1.11
date	2005.01.20.23.47.04;	author espie;	state Exp;
branches;
next	1.10;

1.10
date	2003.06.30.22.13.33;	author espie;	state Exp;
branches;
next	1.9;

1.9
date	2003.06.30.22.10.21;	author espie;	state Exp;
branches;
next	1.8;

1.8
date	2003.06.30.21.47.21;	author espie;	state Exp;
branches;
next	1.7;

1.7
date	2003.06.12.14.36.43;	author espie;	state Exp;
branches;
next	1.6;

1.6
date	2002.04.26.16.15.16;	author espie;	state Exp;
branches;
next	1.5;

1.5
date	2002.04.26.13.12.33;	author espie;	state Exp;
branches;
next	1.4;

1.4
date	2002.02.16.21.27.48;	author millert;	state Exp;
branches;
next	1.3;

1.3
date	2001.09.29.15.47.18;	author espie;	state Exp;
branches;
next	1.2;

1.2
date	2001.09.27.11.40.33;	author espie;	state Exp;
branches;
next	1.1;

1.1
date	2001.09.18.14.55.52;	author espie;	state Exp;
branches;
next	;


desc
@@


1.16
log
@Remove stray spaces.  No code change.
@
text
@/* $OpenBSD: trace.c,v 1.15 2006/03/24 08:03:44 espie Exp $ */
/*
 * Copyright (c) 2001 Marc Espie.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE OPENBSD PROJECT AND CONTRIBUTORS
 * ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
 * A PARTICULAR PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE OPENBSD
 * PROJECT OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

#include <err.h>
#include <stddef.h>
#include <stdint.h>
#include <stdio.h>
#include <stdlib.h>
#include "mdef.h"
#include "stdd.h"
#include "extern.h"

FILE *traceout;

#define TRACE_ARGS	1
#define TRACE_EXPANSION 2
#define TRACE_QUOTE	4
#define TRACE_FILENAME	8
#define TRACE_LINENO	16
#define TRACE_CONT	32
#define TRACE_ID	64
#define TRACE_NEWFILE	128	/* not implemented yet */
#define TRACE_INPUT	256	/* not implemented yet */

static unsigned int letter_to_flag(int);
static void print_header(struct input_file *);
static int frame_level(void);


unsigned int trace_flags = TRACE_QUOTE | TRACE_EXPANSION;

void
trace_file(const char *name)
{

	if (traceout && traceout != stderr)
		fclose(traceout);
	traceout = fopen(name, "w");
	if (!traceout)
		err(1, "can't open %s", name);
}

static unsigned int
letter_to_flag(int c)
{
	switch(c) {
	case 'a':
		return TRACE_ARGS;
	case 'e':
		return TRACE_EXPANSION;
	case 'q':
		return TRACE_QUOTE;
	case 'c':
		return TRACE_CONT;
	case 'x':
		return TRACE_ID;
	case 'f':
		return TRACE_FILENAME;
	case 'l':
		return TRACE_LINENO;
	case 'p':
		return TRACE_NEWFILE;
	case 'i':
		return TRACE_INPUT;
	case 't':
		return TRACE_ALL;
	case 'V':
		return ~0;
	default:
		return 0;
	}
}

void
set_trace_flags(const char *s)
{
	char mode = 0;
	unsigned int f = 0;

	if (*s == '+' || *s == '-')
		mode = *s++;
	while (*s)
		f |= letter_to_flag(*s++);
	switch(mode) {
	case 0:
		trace_flags = f;
		break;
	case '+':
		trace_flags |= f;
		break;
	case '-':
		trace_flags &= ~f;
		break;
	}
}

static int
frame_level()
{
	int level;
	int framep;

	for (framep = fp, level = 0; framep != 0;
		level++,framep = mstack[framep-3].sfra)
		;
	return level;
}

static void
print_header(struct input_file *inp)
{
	fprintf(traceout, "m4trace:");
	if (trace_flags & TRACE_FILENAME)
		fprintf(traceout, "%s:", inp->name);
	if (trace_flags & TRACE_LINENO)
		fprintf(traceout, "%lu:", inp->lineno);
	fprintf(traceout, " -%d- ", frame_level());
	if (trace_flags & TRACE_ID)
		fprintf(traceout, "id %lu: ", expansion_id);
}

size_t
trace(const char *argv[], int argc, struct input_file *inp)
{
	if (!traceout)
		traceout = stderr;
	print_header(inp);
	if (trace_flags & TRACE_CONT) {
		fprintf(traceout, "%s ...\n", argv[1]);
		print_header(inp);
	}
	fprintf(traceout, "%s", argv[1]);
	if ((trace_flags & TRACE_ARGS) && argc > 2) {
		char delim[3];
		int i;

		delim[0] = LPAREN;
		delim[1] = EOS;
		for (i = 2; i < argc; i++) {
			fprintf(traceout, "%s%s%s%s", delim,
			    (trace_flags & TRACE_QUOTE) ? lquote : "",
			    argv[i],
			    (trace_flags & TRACE_QUOTE) ? rquote : "");
			delim[0] = COMMA;
			delim[1] = ' ';
			delim[2] = EOS;
		}
		fprintf(traceout, "%c", RPAREN);
	}
	if (trace_flags & TRACE_CONT) {
		fprintf(traceout, " -> ???\n");
		print_header(inp);
		fprintf(traceout, argc > 2 ? "%s(...)" : "%s", argv[1]);
	}
	if (trace_flags & TRACE_EXPANSION)
		return buffer_mark();
	else {
		fprintf(traceout, "\n");
		return SIZE_MAX;
	}
}

void
finish_trace(size_t mark)
{
	fprintf(traceout, " -> ");
	if (trace_flags & TRACE_QUOTE)
		fprintf(traceout, "%s", lquote);
	dump_buffer(traceout, mark);
	if (trace_flags & TRACE_QUOTE)
		fprintf(traceout, "%s", rquote);
	fprintf(traceout, "\n");
}
@


1.15
log
@oops, noticed by David Hill.
@
text
@d1 1
a1 1
/* $OpenBSD: trace.c,v 1.14 2006/03/20 10:55:19 espie Exp $ */
d38 1
a38 1
#define TRACE_ARGS 	1
d126 1
a126 1
	for (framep = fp, level = 0; framep != 0; 
d145 1
a145 1
size_t 
d163 3
a165 3
			fprintf(traceout, "%s%s%s%s", delim, 
			    (trace_flags & TRACE_QUOTE) ? lquote : "", 
			    argv[i], 
d186 1
a186 1
void 
@


1.14
log
@report function m4errx, that shows app-specific data (filename/linenumber)
before the error message. Use it to simplify code.

okay miod@@
@
text
@d1 1
a1 1
/* $OpenBSD: trace.c,v 1.13 2006/01/20 23:10:19 espie Exp $ */
d27 1
@


1.13
log
@use stdint.h where appropriate. okay millert@@
@
text
@d1 1
a1 1
/* $OpenBSD: trace.c,v 1.12 2005/01/21 19:11:02 espie Exp $ */
a30 1
#include <err.h>
@


1.12
log
@more portable code, stderr is not necessarily a constant.
@
text
@d1 1
a1 1
/* $OpenBSD: trace.c,v 1.11 2005/01/20 23:47:04 espie Exp $ */
a26 1
#include <sys/types.h>
d28 1
d30 1
a31 1
#include <stdlib.h>
d145 1
a145 1
ssize_t 
d182 1
a182 1
		return -1;
@


1.11
log
@remove unused variables, extra declarations.
@
text
@d1 1
a1 1
/* $OpenBSD: trace.c,v 1.10 2003/06/30 22:13:33 espie Exp $ */
d36 1
a36 1
FILE *traceout = stderr;
d59 1
a59 1
	if (traceout != stderr)
d148 2
@


1.10
log
@Fold trace status into the single hash table that's left.
Inline some macros/functions for speed.
So, this achieves the goal of one single lookup for macro/trace status,
which does speed up m4 in partial tracing situations somewhat.
This does also speed up m4 in large pushdef situations, since it no longer
has to lookup large chains of macros.

okay millert@@
@
text
@d1 1
a1 1
/* $OpenBSD: trace.c,v 1.9 2003/06/30 22:10:21 espie Exp $ */
a49 1
static struct t *find_trace_entry(const char *);
@


1.9
log
@replace old hash structure with open hashing.
make the stack structure of macro definitions explicit.
okay millert@@
@
text
@d1 1
a1 1
/* $OpenBSD: trace.c,v 1.8 2003/06/30 21:47:21 espie Exp $ */
a31 1
#include <ohash.h>
a37 2
int traced_macros = 0;

a46 7
#define TRACE_ALL	512

struct t {
	int	  on;
	char 	 name[1];
};

a51 41
void *hash_alloc(size_t, void *);
void hash_free(void *, size_t, void *);
void *element_alloc(size_t, void *);

static unsigned int flags = TRACE_QUOTE | TRACE_EXPANSION;

static struct ohash_info trace_info = {
	offsetof(struct t, name),
	NULL, hash_alloc, hash_free, element_alloc };

static struct ohash trace_hash;

/* Support routines for hash tables.  */
void *
hash_alloc(s, u)
	size_t s;
	void *u 	UNUSED;
{
	void *storage = xalloc(s);
	if (storage)
		memset(storage, 0, s);
	return storage;
}

void
hash_free(p, s, u)
	void *p;
	size_t s	UNUSED;
	void *u 	UNUSED;
{
	free(p);
}

void *
element_alloc(s, u)
	size_t s;
	void *u 	UNUSED;
{
	return xalloc(s);
}

a52 5
void
init_trace()
{
	ohash_init(&trace_hash, 5, &trace_info);
}
d54 1
a54 41
void
mark_traced(const char *name, int on)
{
	struct t *n;
	unsigned int i;
	const char *end = NULL;

	traced_macros = 1;

	if (name == NULL) {
		if (on)
			flags |= TRACE_ALL;
		else {
			flags &= ~TRACE_ALL;
			traced_macros = 0;
		}
		for (n = ohash_first(&trace_hash, &i); n != NULL; 
		    n = ohash_next(&trace_hash, &i))
			free(n);
	} else {
	    i = ohash_qlookupi(&trace_hash, name, &end);
	    n = ohash_find(&trace_hash, i);
	    if (n == NULL) {
		    n = ohash_create_entry(&trace_info, name, &end);
		    ohash_insert(&trace_hash, i, n);
	    }
	    n->on = on;
	}
}

int 
is_traced(const char *name)
{
	struct t *n;

	n = ohash_find(&trace_hash, ohash_qlookup(&trace_hash, name));
	if (n)
		return n->on;
	else
		return (flags & TRACE_ALL) ? 1 : 0;
}
a103 2
	traced_macros = 1;

d110 1
a110 1
		flags = f;
d113 1
a113 1
		flags |= f;
d116 1
a116 1
		flags &= ~f;
d137 1
a137 1
	if (flags & TRACE_FILENAME)
d139 1
a139 1
	if (flags & TRACE_LINENO)
d142 1
a142 1
	if (flags & TRACE_ID)
d150 1
a150 1
	if (flags & TRACE_CONT) {
d155 1
a155 1
	if ((flags & TRACE_ARGS) && argc > 2) {
d163 1
a163 1
			    (flags & TRACE_QUOTE) ? lquote : "", 
d165 1
a165 1
			    (flags & TRACE_QUOTE) ? rquote : "");
d172 1
a172 1
	if (flags & TRACE_CONT) {
d177 1
a177 1
	if (flags & TRACE_EXPANSION)
d189 1
a189 1
	if (flags & TRACE_QUOTE)
d192 1
a192 1
	if (flags & TRACE_QUOTE)
@


1.8
log
@Make the trace status of a macro an actual argument that gets pushed
in the frame for the macro expansion.

(This will allow one single lookup to grab the macro definition and
the trace status)

okay millert@@
@
text
@d1 1
a1 1
/* $OpenBSD: trace.c,v 1.7 2003/06/12 14:36:43 espie Exp $ */
d62 3
a64 3
static void *hash_alloc(size_t, void *);
static void hash_free(void *, size_t, void *);
static void *element_alloc(size_t, void *);
@


1.7
log
@switch from linked list to hash table for traced macros.
speeds up recent autoconf somewhat, since it traces a large set
of individual macro.

(more rework of m4 internal interfaces to unify lookup tables in order)

okay fries@@
@
text
@d1 1
a1 1
/* $OpenBSD: trace.c,v 1.6 2002/04/26 16:15:16 espie Exp $ */
d226 1
a226 1
		level++,framep = mstack[framep-2].sfra)
@


1.6
log
@use ansi function declarations. ok millert@@
@
text
@d1 1
a1 1
/* $OpenBSD: trace.c,v 1.5 2002/04/26 13:12:33 espie Exp $ */
d32 1
d52 1
a52 3
static struct t {
	struct t *next;
	char 	 *name;
d54 3
a56 1
} *l;
d62 3
d68 11
a78 2
static struct t *
find_trace_entry(const char *name)
d80 14
a93 1
	struct t *n;
d95 6
a100 4
	for (n = l; n != NULL; n = n->next)
		if (STREQ(n->name, name))
			return n;
	return NULL;
d105 6
d113 3
a115 1
	struct t *n, *n2;
d126 2
a127 3
		for (n = l; n != NULL; n = n2) {
			n2 = n->next;
			free(n->name);
a128 2
		}
		l = NULL;
d130 2
a131 1
	    n = find_trace_entry(name);
d133 2
a134 4
		    n = xalloc(sizeof(struct t));
		    n->name = xstrdup(name);
		    n->next = l;
		    l = n;
d145 5
a149 4
	for (n = l; n != NULL; n = n->next)
		if (STREQ(n->name, name))
			return n->on;
	return (flags & TRACE_ALL) ? 1 : 0;
@


1.5
log
@fix indentation error
@
text
@d1 1
a1 1
/* $OpenBSD: trace.c,v 1.4 2002/02/16 21:27:48 millert Exp $ */
d65 1
a65 2
find_trace_entry(name)
	const char *name;
d77 1
a77 3
mark_traced(name, on)
	const char *name;
	int on;
d109 1
a109 2
is_traced(name)
	const char *name;
d120 1
a120 2
trace_file(name)
	const char *name;
d131 1
a131 2
letter_to_flag(c)
	int c;
d162 1
a162 2
set_trace_flags(s)
	const char *s;
d199 1
a199 2
print_header(inp)
	struct input_file *inp;
d212 1
a212 4
trace(argv, argc, inp)
	const char **argv;
	int argc;
	struct input_file *inp;
d251 1
a251 2
finish_trace(mark)
size_t mark;
@


1.4
log
@Part one of userland __P removal.  Done with a simple regexp with some minor hand editing to make comments line up correctly.  Another pass is forthcoming that handles the cases that could not be done automatically.
@
text
@d1 1
a1 1
/* $OpenBSD: trace.c,v 1.3 2001/09/29 15:47:18 espie Exp $ */
d102 4
a105 4
	n = xalloc(sizeof(struct t));
	n->name = xstrdup(name);
	n->next = l;
	l = n;
@


1.3
log
@show level of macro expansion, not dummy 1 (finally found some gnu-m4
scripts where that level != 1, hard to test otherwise...)

Put a space after comma.

Both these make trace output much closer to gnu-m4 output for debugging
purposes.
@
text
@d1 1
a1 1
/* $OpenBSD: trace.c,v 1.2 2001/09/27 11:40:33 espie Exp $ */
d57 4
a60 4
static unsigned int letter_to_flag __P((int));
static void print_header __P((struct input_file *));
static struct t *find_trace_entry __P((const char *));
static int frame_level __P((void));
@


1.2
log
@traceon/traceoff built-ins.
@
text
@d1 1
a1 1
/* $OpenBSD: trace.c,v 1.1 2001/09/18 14:55:52 espie Exp $ */
d60 1
d193 12
d214 1
a214 1
	fprintf(traceout, " -1- ");
d232 1
a232 1
		char delim = LPAREN;
d235 2
d238 1
a238 1
			fprintf(traceout, "%c%s%s%s", delim, 
d242 3
a244 1
			delim = COMMA;
@


1.1
log
@Tracing facilities. Same style as gnu-m4, because it's mostly used for
autoconf right now.
@
text
@d1 1
a1 1
/* $OpenBSD$ */
d31 1
d51 5
d59 1
d63 12
a74 4
static struct t {
	struct t *next;
	char 	 *name;
} *l;
d77 1
a77 1
mark_traced(name)
d79 1
d81 1
a81 1
	struct t *n;
d84 17
d105 3
a109 1

a115 2
	if (flags & TRACE_ALL)
		return 1;
d118 2
a119 2
			return 1;
	return 0;
@

