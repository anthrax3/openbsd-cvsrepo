head	1.24;
access;
symbols
	OPENBSD_6_1:1.24.0.10
	OPENBSD_6_1_BASE:1.24
	OPENBSD_6_0:1.24.0.8
	OPENBSD_6_0_BASE:1.24
	OPENBSD_5_9:1.24.0.4
	OPENBSD_5_9_BASE:1.24
	OPENBSD_5_8:1.24.0.6
	OPENBSD_5_8_BASE:1.24
	OPENBSD_5_7:1.24.0.2
	OPENBSD_5_7_BASE:1.24
	OPENBSD_5_6:1.23.0.4
	OPENBSD_5_6_BASE:1.23
	OPENBSD_5_5:1.22.0.16
	OPENBSD_5_5_BASE:1.22
	OPENBSD_5_4:1.22.0.12
	OPENBSD_5_4_BASE:1.22
	OPENBSD_5_3:1.22.0.10
	OPENBSD_5_3_BASE:1.22
	OPENBSD_5_2:1.22.0.8
	OPENBSD_5_2_BASE:1.22
	OPENBSD_5_1_BASE:1.22
	OPENBSD_5_1:1.22.0.6
	OPENBSD_5_0:1.22.0.4
	OPENBSD_5_0_BASE:1.22
	OPENBSD_4_9:1.22.0.2
	OPENBSD_4_9_BASE:1.22
	OPENBSD_4_8:1.21.0.4
	OPENBSD_4_8_BASE:1.21
	OPENBSD_4_7:1.21.0.2
	OPENBSD_4_7_BASE:1.21
	OPENBSD_4_6:1.19.0.4
	OPENBSD_4_6_BASE:1.19
	OPENBSD_4_5:1.18.0.14
	OPENBSD_4_5_BASE:1.18
	OPENBSD_4_4:1.18.0.12
	OPENBSD_4_4_BASE:1.18
	OPENBSD_4_3:1.18.0.10
	OPENBSD_4_3_BASE:1.18
	OPENBSD_4_2:1.18.0.8
	OPENBSD_4_2_BASE:1.18
	OPENBSD_4_1:1.18.0.6
	OPENBSD_4_1_BASE:1.18
	OPENBSD_4_0:1.18.0.4
	OPENBSD_4_0_BASE:1.18
	OPENBSD_3_9:1.18.0.2
	OPENBSD_3_9_BASE:1.18
	OPENBSD_3_8:1.17.0.2
	OPENBSD_3_8_BASE:1.17
	OPENBSD_3_7:1.16.0.6
	OPENBSD_3_7_BASE:1.16
	OPENBSD_3_6:1.16.0.4
	OPENBSD_3_6_BASE:1.16
	OPENBSD_3_5:1.16.0.2
	OPENBSD_3_5_BASE:1.16
	OPENBSD_3_4:1.15.0.2
	OPENBSD_3_4_BASE:1.15
	OPENBSD_3_3:1.10.0.4
	OPENBSD_3_3_BASE:1.10
	OPENBSD_3_2:1.10.0.2
	OPENBSD_3_2_BASE:1.10
	OPENBSD_3_1:1.9.0.2
	OPENBSD_3_1_BASE:1.9
	OPENBSD_3_0:1.8.0.2
	OPENBSD_3_0_BASE:1.8
	OPENBSD_2_9_BASE:1.7
	OPENBSD_2_9:1.7.0.6
	OPENBSD_2_8:1.7.0.4
	OPENBSD_2_8_BASE:1.7
	OPENBSD_2_7:1.7.0.2
	OPENBSD_2_7_BASE:1.7
	OPENBSD_2_6:1.4.0.2
	OPENBSD_2_6_BASE:1.4
	OPENBSD_2_5:1.2.0.12
	OPENBSD_2_5_BASE:1.2
	OPENBSD_2_4:1.2.0.10
	OPENBSD_2_4_BASE:1.2
	OPENBSD_2_3:1.2.0.8
	OPENBSD_2_3_BASE:1.2
	OPENBSD_2_2:1.2.0.6
	OPENBSD_2_2_BASE:1.2
	OPENBSD_2_1:1.2.0.4
	OPENBSD_2_1_BASE:1.2
	OPENBSD_2_0:1.2.0.2
	OPENBSD_2_0_BASE:1.2
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.24
date	2014.12.21.09.33.12;	author espie;	state Exp;
branches;
next	1.23;
commitid	cEHdgjDE2j8bVm3K;

1.23
date	2014.05.12.19.11.19;	author espie;	state Exp;
branches;
next	1.22;

1.22
date	2010.09.07.19.58.09;	author marco;	state Exp;
branches;
next	1.21;

1.21
date	2009.10.14.17.23.17;	author sthen;	state Exp;
branches;
next	1.20;

1.20
date	2009.10.14.17.19.47;	author sthen;	state Exp;
branches;
next	1.19;

1.19
date	2009.06.26.22.03.17;	author guenther;	state Exp;
branches;
next	1.18;

1.18
date	2006.01.20.23.10.19;	author espie;	state Exp;
branches;
next	1.17;

1.17
date	2005.08.06.16.22.26;	author espie;	state Exp;
branches;
next	1.16;

1.16
date	2003.11.17.17.12.10;	author espie;	state Exp;
branches;
next	1.15;

1.15
date	2003.06.30.22.13.32;	author espie;	state Exp;
branches;
next	1.14;

1.14
date	2003.06.30.22.11.38;	author espie;	state Exp;
branches;
next	1.13;

1.13
date	2003.06.30.22.10.21;	author espie;	state Exp;
branches;
next	1.12;

1.12
date	2003.06.30.21.42.50;	author espie;	state Exp;
branches;
next	1.11;

1.11
date	2003.06.03.02.56.10;	author millert;	state Exp;
branches;
next	1.10;

1.10
date	2002.04.26.16.15.16;	author espie;	state Exp;
branches;
next	1.9;

1.9
date	2002.02.16.21.27.48;	author millert;	state Exp;
branches;
next	1.8;

1.8
date	2001.09.17.08.11.13;	author espie;	state Exp;
branches;
next	1.7;

1.7
date	99.11.25.00.54.22;	author millert;	state Exp;
branches;
next	1.6;

1.6
date	99.11.20.17.48.59;	author espie;	state Exp;
branches;
next	1.5;

1.5
date	99.11.17.15.34.13;	author espie;	state Exp;
branches;
next	1.4;

1.4
date	99.09.14.08.35.16;	author espie;	state Exp;
branches;
next	1.3;

1.3
date	99.09.06.13.10.48;	author espie;	state Exp;
branches;
next	1.2;

1.2
date	96.06.26.05.36.12;	author deraadt;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.45.35;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.45.35;	author deraadt;	state Exp;
branches;
next	;


desc
@@


1.24
log
@fix test-redef2:
- introduce explicit STORAGE classes for the shadow stack entries
- delay freeing definitions if they're in-use, keep them in a simple array.

okay millert@@
@
text
@/*	$OpenBSD: look.c,v 1.23 2014/05/12 19:11:19 espie Exp $	*/

/*
 * Copyright (c) 1989, 1993
 *	The Regents of the University of California.  All rights reserved.
 *
 * This code is derived from software contributed to Berkeley by
 * Ozan Yigit at York University.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */

/*
 * look.c
 * Facility: m4 macro processor
 * by: oz
 */

#include <stdio.h>
#include <stdlib.h>
#include <stdint.h>
#include <stddef.h>
#include <string.h>
#include <ohash.h>
#include "mdef.h"
#include "stdd.h"
#include "extern.h"

static void *hash_calloc(size_t, size_t, void *);
static void hash_free(void *, void *);
static void *element_alloc(size_t, void *);
static void setup_definition(struct macro_definition *, const char *,
    const char *);
static void free_definition(char *);
static void keep(char *);
static int string_in_use(const char *);

static struct ohash_info macro_info = {
	offsetof(struct ndblock, name),
	NULL, hash_calloc, hash_free, element_alloc };

struct ohash macros;

/* Support routines for hash tables.  */
void *
hash_calloc(size_t n, size_t s, void *u UNUSED)
{
	void *storage = xcalloc(n, s, "hash alloc");
	return storage;
}

void
hash_free(void *p, void *u UNUSED)
{
	free(p);
}

void *
element_alloc(size_t s, void *u UNUSED)
{
	return xalloc(s, "element alloc");
}

void
init_macros()
{
	ohash_init(&macros, 10, &macro_info);
}

/*
 * find name in the hash table
 */
ndptr
lookup(const char *name)
{
	return ohash_find(&macros, ohash_qlookup(&macros, name));
}

struct macro_definition *
lookup_macro_definition(const char *name)
{
	ndptr p;

	p = ohash_find(&macros, ohash_qlookup(&macros, name));
	if (p)
		return p->d;
	else
		return NULL;
}

static void
setup_definition(struct macro_definition *d, const char *defn, const char *name)
{
	ndptr p;

	if (strncmp(defn, BUILTIN_MARKER, sizeof(BUILTIN_MARKER)-1) == 0 &&
	    (p = macro_getbuiltin(defn+sizeof(BUILTIN_MARKER)-1)) != NULL) {
		d->type = macro_builtin_type(p);
		d->defn = xstrdup(defn+sizeof(BUILTIN_MARKER)-1);
	} else {
		if (!*defn)
			d->defn = null;
		else
			d->defn = xstrdup(defn);
		d->type = MACRTYPE;
	}
	if (STREQ(name, defn))
		d->type |= RECDEF;
}

static ndptr
create_entry(const char *name)
{
	const char *end = NULL;
	unsigned int i;
	ndptr n;

	i = ohash_qlookupi(&macros, name, &end);
	n = ohash_find(&macros, i);
	if (n == NULL) {
		n = ohash_create_entry(&macro_info, name, &end);
		ohash_insert(&macros, i, n);
		n->trace_flags = FLAG_NO_TRACE;
		n->builtin_type = MACRTYPE;
		n->d = NULL;
	}
	return n;
}

void
macro_define(const char *name, const char *defn)
{
	ndptr n = create_entry(name);
	if (n->d != NULL) {
		if (n->d->defn != null)
			free_definition(n->d->defn);
	} else {
		n->d = xalloc(sizeof(struct macro_definition), NULL);
		n->d->next = NULL;
	}
	setup_definition(n->d, defn, name);
}

void
macro_pushdef(const char *name, const char *defn)
{
	ndptr n;
	struct macro_definition *d;

	n = create_entry(name);
	d = xalloc(sizeof(struct macro_definition), NULL);
	d->next = n->d;
	n->d = d;
	setup_definition(n->d, defn, name);
}

void
macro_undefine(const char *name)
{
	ndptr n = lookup(name);
	if (n != NULL) {
		struct macro_definition *r, *r2;

		for (r = n->d; r != NULL; r = r2) {
			r2 = r->next;
			if (r->defn != null)
				free(r->defn);
			free(r);
		}
		n->d = NULL;
	}
}

void
macro_popdef(const char *name)
{
	ndptr n = lookup(name);

	if (n != NULL) {
		struct macro_definition *r = n->d;
		if (r != NULL) {
			n->d = r->next;
			if (r->defn != null)
				free(r->defn);
			free(r);
		}
	}
}

void
macro_for_all(void (*f)(const char *, struct macro_definition *))
{
	ndptr n;
	unsigned int i;

	for (n = ohash_first(&macros, &i); n != NULL;
	    n = ohash_next(&macros, &i))
		if (n->d != NULL)
			f(n->name, n->d);
}

void
setup_builtin(const char *name, unsigned int type)
{
	ndptr n;
	char *name2;

	if (prefix_builtins) {
		name2 = xalloc(strlen(name)+3+1, NULL);
		memcpy(name2, "m4_", 3);
		memcpy(name2 + 3, name, strlen(name)+1);
	} else
		name2 = xstrdup(name);

	n = create_entry(name2);
	n->builtin_type = type;
	n->d = xalloc(sizeof(struct macro_definition), NULL);
	n->d->defn = name2;
	n->d->type = type;
	n->d->next = NULL;
}

void
mark_traced(const char *name, int on)
{
	ndptr p;
	unsigned int i;

	if (name == NULL) {
		if (on)
			trace_flags |= TRACE_ALL;
		else
			trace_flags &= ~TRACE_ALL;
		for (p = ohash_first(&macros, &i); p != NULL;
		    p = ohash_next(&macros, &i))
			p->trace_flags = FLAG_NO_TRACE;
	} else {
		p = create_entry(name);
		p->trace_flags = on;
	}
}

ndptr
macro_getbuiltin(const char *name)
{
	ndptr p;

	p = lookup(name);
	if (p == NULL || p->builtin_type == MACRTYPE)
		return NULL;
	else
		return p;
}

/* XXX things are slightly more complicated than they seem.
 * a macro may actually be "live" (in the middle of an expansion
 * on the stack.
 * So we actually may need to place it in an array for later...
 */

static int kept_capacity = 0;
static int kept_size = 0;
static char **kept = NULL;

static void
keep(char *ptr)
{
	if (kept_capacity <= kept_size) {
		if (kept_capacity)
			kept_capacity *= 2;
		else
			kept_capacity = 50;
		kept = xreallocarray(kept, kept_capacity, 
		    sizeof(char *), "Out of memory while saving %d strings\n", 
		    kept_capacity);
	}
	kept[kept_size++] = ptr;
}

static int
string_in_use(const char *ptr) 
{
	int i;
	for (i = 0; i <= sp; i++) {
		if (sstack[i] == STORAGE_MACRO && mstack[i].sstr == ptr)
			return 1;
		}
	return 0;
}


static void
free_definition(char *ptr)
{
	int i;

	/* first try to free old strings */
	for (i = 0; i < kept_size; i++) {
		if (!string_in_use(kept[i])) {
			kept_size--;
			free(kept[i]);
			if (i != kept_size) 
				kept[i] = kept[kept_size];
			i--;
		}
	}

	/* then deal with us */
	if (string_in_use(ptr))
		keep(ptr);
	else
		free(ptr);
}

@


1.23
log
@adjust to ohash being in libutil now, and to the interface changes.
fix potential integer overflows in memory allocation (mostly for pedagogical
purposes, these are unlikely to overflow in practice)
move the rest of lst.lib stuff into its own directory.
@
text
@d1 1
a1 1
/*	$OpenBSD: look.c,v 1.22 2010/09/07 19:58:09 marco Exp $	*/
d56 3
d158 1
a158 1
			free(n->d->defn);
d276 61
@


1.22
log
@Remove stray spaces.  No code change.
@
text
@d1 1
a1 1
/*	$OpenBSD: look.c,v 1.21 2009/10/14 17:23:17 sthen Exp $	*/
d51 2
a52 2
static void *hash_alloc(size_t, void *);
static void hash_free(void *, size_t, void *);
d59 1
a59 1
	NULL, hash_alloc, hash_free, element_alloc };
d65 1
a65 3
hash_alloc(s, u)
	size_t s;
	void *u		UNUSED;
d67 1
a67 3
	void *storage = xalloc(s, "hash alloc");
	if (storage)
		memset(storage, 0, s);
d72 1
a72 4
hash_free(p, s, u)
	void *p;
	size_t s	UNUSED;
	void *u		UNUSED;
d78 1
a78 3
element_alloc(s, u)
	size_t s;
	void *u		UNUSED;
@


1.21
log
@whitespace; from deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: look.c,v 1.20 2009/10/14 17:19:47 sthen Exp $	*/
d54 1
a54 1
static void setup_definition(struct macro_definition *, const char *, 
d67 1
a67 1
	void *u 	UNUSED;
d79 1
a79 1
	void *u 	UNUSED;
d87 1
a87 1
	void *u 	UNUSED;
d101 1
a101 1
ndptr 
d119 1
a119 1
static void 
d177 1
a177 1
	
d224 1
a224 1
	for (n = ohash_first(&macros, &i); n != NULL; 
d230 1
a230 1
void 
d262 1
a262 1
		for (p = ohash_first(&macros, &i); p != NULL; 
d264 1
a264 1
		    	p->trace_flags = FLAG_NO_TRACE;
d271 1
a271 1
ndptr 
a281 1

@


1.20
log
@Support the -P option from gnu m4, which prefixes builtins with the
string m4_. Feedback from jmc@@, Tobias Ulmer, Matthew Dempsky - thanks!
ok espie@@
@
text
@d1 1
a1 1
/*	$OpenBSD: look.c,v 1.19 2009/06/26 22:03:17 guenther Exp $	*/
d236 1
a236 1
	if(prefix_builtins) {
@


1.19
log
@undefine() leaves the hash entry for the macro (for use by builtin()) and
only deletes the definition; macro_for_all needs to skip those to keep
dumpdef() from segving

ok and regress test by espie (thanks!)
@
text
@d1 1
a1 1
/*	$OpenBSD: look.c,v 1.18 2006/01/20 23:10:19 espie Exp $	*/
d234 1
d236 8
a243 1
	n = create_entry(name);
d246 1
a246 1
	n->d->defn = xstrdup(name);
@


1.18
log
@use stdint.h where appropriate. okay millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: look.c,v 1.17 2005/08/06 16:22:26 espie Exp $	*/
d226 2
a227 1
		f(n->name, n->d);
@


1.17
log
@zap rcsid. It's not ramdisk, but they still take space.
@
text
@d1 1
a1 1
/*	$OpenBSD: look.c,v 1.16 2003/11/17 17:12:10 espie Exp $	*/
a40 1
#include <sys/types.h>
d43 1
@


1.16
log
@Modify xalloc so that it also takes err(3)-like arguments.
Write an xrealloc wrapper that works the same way, and use it as well.

People who feel like it may want to add more explicit error messages to
all the places m4 can fail allocating memory...

okay tedu@@
@
text
@d1 1
a1 1
/*	$OpenBSD: look.c,v 1.15 2003/06/30 22:13:32 espie Exp $	*/
a33 4

#ifndef lint
static char sccsid[] = "@@(#)look.c	8.1 (Berkeley) 6/6/93";
#endif /* not lint */
@


1.15
log
@Fold trace status into the single hash table that's left.
Inline some macros/functions for speed.
So, this achieves the goal of one single lookup for macro/trace status,
which does speed up m4 in partial tracing situations somewhat.
This does also speed up m4 in large pushdef situations, since it no longer
has to lookup large chains of macros.

okay millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: look.c,v 1.14 2003/06/30 22:11:38 espie Exp $	*/
d73 1
a73 1
	void *storage = xalloc(s);
d93 1
a93 1
	return xalloc(s);
d170 1
a170 1
		n->d = xalloc(sizeof(struct macro_definition));
d183 1
a183 1
	d = xalloc(sizeof(struct macro_definition));
d240 1
a240 1
	n->d = xalloc(sizeof(struct macro_definition));
@


1.14
log
@add a flag for each macro name that records built-in status.
Fold built-in lookup into normal lookup.
okay millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: look.c,v 1.13 2003/06/30 22:10:21 espie Exp $	*/
d55 3
a57 9
struct ndblock {			/* hashtable structure         */
	unsigned int 		builtin_type;
	struct macro_definition *d;
	char		name[1];	/* entry name..               */
};
 
extern void *hash_alloc(size_t, void *);
extern void hash_free(void *, size_t, void *);
extern void *element_alloc(size_t, void *);
d65 30
a94 1
static struct ohash macros;
d99 1
a99 1
	ohash_init(&macros, 7, &macro_info);
d116 1
a116 1
	p = lookup(name);
d155 1
d246 2
a247 2
const char *
macro_name(ndptr p)
d249 2
a250 2
	return p->name;
}
d252 12
a263 4
struct macro_definition *
macro_getdef(ndptr p)
{
	return p->d;
a275 6
}

int
macro_builtin_type(ndptr p)
{
	return p->builtin_type;
@


1.13
log
@replace old hash structure with open hashing.
make the stack structure of macro definitions explicit.
okay millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: look.c,v 1.12 2003/06/30 21:42:50 espie Exp $	*/
d56 1
d103 1
a103 1
	int n;
d106 2
a107 4
	    (n = builtin_type(defn+sizeof(BUILTIN_MARKER)-1)) != -1) {
		d->type = n & TYPEMASK;
		if ((n & NOARGS) == 0)
			d->type |= NEEDARGS;
d132 1
d215 1
d233 19
@


1.12
log
@clean up internal lookup interface:
define an interface with explicit define/pushdef/popdef... and use it.
That way, most details of the hashtable are no longer visible.

okay millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: look.c,v 1.11 2003/06/03 02:56:10 millert Exp $	*/
d50 1
d55 3
a57 5
struct ndblock {		/* hastable structure         */
	char		*name;	/* entry name..               */
	struct macro_definition d;
	unsigned int 	hv;	/* hash function value..      */
	ndptr		nxtptr;	/* link to next entry..       */
d60 16
a75 12
static void freent(ndptr);
static void	remhash(const char *, int);
static unsigned	hash(const char *);
static ndptr	addent(const char *);

static unsigned int
hash(const char *name)
{
	unsigned int h = 0;
	while (*name)
		h = (h << 5) + h + *name++;
	return (h);
d84 1
a84 70
	ndptr p;
	unsigned int h;

	h = hash(name);
	for (p = hashtab[h % HASHSIZE]; p != NULL; p = p->nxtptr)
		if (h == p->hv && STREQ(name, p->name))
			break;
	return (p);
}

/*
 * hash and create an entry in the hash table.
 * The new entry is added in front of a hash bucket.
 */
static ndptr 
addent(const char *name)
{
	unsigned int h;
	ndptr p;

	h = hash(name);
	p = (ndptr) xalloc(sizeof(struct ndblock));
	p->nxtptr = hashtab[h % HASHSIZE];
	hashtab[h % HASHSIZE] = p;
	p->name = xstrdup(name);
	p->hv = h;
	return p;
}

static void
freent(ndptr p)
{
	free((char *) p->name);
	if (p->d.defn != null)
		free((char *) p->d.defn);
	free((char *) p);
}

/*
 * remove an entry from the hashtable
 */
static void
remhash(const char *name, int all)
{
	unsigned int h;
	ndptr xp, tp, mp;

	h = hash(name);
	mp = hashtab[h % HASHSIZE];
	tp = NULL;
	while (mp != NULL) {
		if (mp->hv == h && STREQ(mp->name, name)) {
			mp = mp->nxtptr;
			if (tp == NULL) {
				freent(hashtab[h % HASHSIZE]);
				hashtab[h % HASHSIZE] = mp;
			}
			else {
				xp = tp->nxtptr;
				tp->nxtptr = mp;
				freent(xp);
			}
			if (!all)
				break;
		}
		else {
			tp = mp;
			mp = mp->nxtptr;
		}
	}
d94 1
a94 1
		return &(p->d);
d100 1
a100 1
setup_definition(struct macro_definition *d, const char *defn)
d104 30
a133 9
	if (strncmp(defn, BUILTIN_MARKER, sizeof(BUILTIN_MARKER)-1) == 0) {
		n = builtin_type(defn+sizeof(BUILTIN_MARKER)-1);
		if (n != -1) {
			d->type = n & TYPEMASK;
			if ((n & NOARGS) == 0)
				d->type |= NEEDARGS;
			d->defn = xstrdup(defn+sizeof(BUILTIN_MARKER)-1);
			return;
		}
d135 1
a135 5
	if (!*defn)
		d->defn = null;
	else
		d->defn = xstrdup(defn);
	d->type = MACRTYPE;
d141 9
a149 9
	ndptr p;

	if ((p = lookup(name)) == NULL)
		p = addent(name);
	else if (p->d.defn != null)
		free((char *) p->d.defn);
	setup_definition(&(p->d), defn);
	if (STREQ(name, defn))
		p->d.type |= RECDEF;
d155 8
a162 6
	ndptr p;

	p = addent(name);
	setup_definition(&(p->d), defn);
	if (STREQ(name, defn))
		p->d.type |= RECDEF;
d168 12
a179 1
	remhash(name, ALL);
d185 11
a195 1
	remhash(name, TOP);
d201 2
a202 2
	int n;
	ndptr p;
d204 3
a206 3
	for (n = 0; n < HASHSIZE; n++)
		for (p = hashtab[n]; p != NULL; p = p->nxtptr)
			f(p->name, &(p->d));
d212 1
a212 2
	unsigned int h;
	ndptr p;
d214 5
a218 8
	h = hash(name);
	p = (ndptr) xalloc(sizeof(struct ndblock));
	p->nxtptr = hashtab[h % HASHSIZE];
	hashtab[h % HASHSIZE] = p;
	p->name = xstrdup(name);
	p->d.defn = xstrdup(name);
	p->hv = h;
	p->d.type = type;
d230 1
a230 1
	return &(p->d);
@


1.11
log
@Remove the advertising clause in the UCB license which Berkeley
rescinded 22 July 1999.  Proofed by myself and Theo.
@
text
@d1 1
a1 1
/*	$OpenBSD: look.c,v 1.10 2002/04/26 16:15:16 espie Exp $	*/
d54 7
d62 3
d66 1
a66 1
unsigned int
d85 1
a85 1
	for (p = hashtab[h % HASHSIZE]; p != nil; p = p->nxtptr)
d95 1
a95 1
ndptr 
d114 2
a115 2
	if (p->defn != null)
		free((char *) p->defn);
d122 1
a122 1
void
d130 2
a131 2
	tp = nil;
	while (mp != nil) {
d134 1
a134 1
			if (tp == nil) {
d151 110
@


1.10
log
@use ansi function declarations. ok millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: look.c,v 1.9 2002/02/16 21:27:48 millert Exp $	*/
d18 1
a18 5
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
@


1.9
log
@Part one of userland __P removal.  Done with a simple regexp with some minor hand editing to make comments line up correctly.  Another pass is forthcoming that handles the cases that could not be done automatically.
@
text
@d1 1
a1 1
/*	$OpenBSD: look.c,v 1.8 2001/09/17 08:11:13 espie Exp $	*/
d60 2
a61 3
unsigned
hash(name)
	const char *name;
d73 1
a73 2
lookup(name)
	const char *name;
d90 1
a90 2
addent(name)
	const char *name;
d105 1
a105 2
freent(p)
	ndptr p;
d117 1
a117 3
remhash(name, all)
	const char *name;
	int all;
@


1.8
log
@Remove STATIC memory optimization. It's buggy (see regression test trip)
@
text
@d1 1
a1 1
/*	$OpenBSD: look.c,v 1.7 1999/11/25 00:54:22 millert Exp $	*/
d58 1
a58 1
static void freent __P((ndptr));
@


1.7
log
@From espie@@openbsd.org:
 o Add a missing 'unsigned' to 'h' in remhash()
 o Say 'unsigned int' not just 'unsigned'
@
text
@d1 1
a1 1
/*	$OpenBSD: look.c,v 1.6 1999/11/20 17:48:59 espie Exp $	*/
d111 3
a113 5
	if (!(p->type & STATIC)) {
		free((char *) p->name);
		if (p->defn != null)
			free((char *) p->defn);
	}
@


1.6
log
@Optimization: cache the hashed value to avoid negative comparisons.
With 2^32 possible hash values, this means that collisions no longer
incur supplementary string compares, which was most of the reason for
STREQ in the first place...
@
text
@d1 1
a1 1
/*	$OpenBSD: look.c,v 1.5 1999/11/17 15:34:13 espie Exp $	*/
d64 1
a64 1
	unsigned h = 0;
d78 1
a78 1
	unsigned h;
d95 1
a95 1
	unsigned h;
d127 1
a127 1
	int h;
@


1.5
log
@Turn warnings on,
Add missing prototypes,
Make local functions static,
Sort extern.h by file,
Constify all char * that can be,
Copy temp file name so that eval does not modify its arguments.
@
text
@d1 1
a1 1
/*	$OpenBSD: look.c,v 1.4 1999/09/14 08:35:16 espie Exp $	*/
d60 1
a60 1
int
d64 1
a64 1
	unsigned long h = 0;
d67 1
a67 1
	return (h % HASHSIZE);
d78 1
d80 3
a82 2
	for (p = hashtab[hash(name)]; p != nil; p = p->nxtptr)
		if (STREQ(name, p->name))
d95 1
a95 1
	int h;
d100 2
a101 2
	p->nxtptr = hashtab[h];
	hashtab[h] = p;
d103 1
d131 1
a131 1
	mp = hashtab[h];
d134 1
a134 1
		if (STREQ(mp->name, name)) {
d137 2
a138 2
				freent(hashtab[h]);
				hashtab[h] = mp;
@


1.4
log
@Style: kill register and indent properly.
Let indx match netbsd flavor, to simplify diffs.
Show how many quotes were not closed.
Increase stack slightly, now that we're no longer bound by argspace.
@
text
@d1 1
a1 1
/*	$OpenBSD: look.c,v 1.3 1999/09/06 13:10:48 espie Exp $	*/
d58 2
d62 1
a62 1
	char *name;
d75 1
a75 1
	char *name;
d91 1
a91 1
	char *name;
d121 1
a121 1
	char *name;
@


1.3
log
@Misc minor changes:
- use err.h and kill oops,
- use __progname and kill basename,
- let indx use strstr
- proper EOS decl
@
text
@d1 1
a1 1
/*	$OpenBSD: look.c,v 1.2 1996/06/26 05:36:12 deraadt Exp $	*/
d60 1
a60 1
register char *name;
d62 1
a62 1
	register unsigned long h = 0;
d73 1
a73 1
char *name;
d75 1
a75 1
	register ndptr p;
d89 1
a89 1
char *name;
d91 1
a91 1
	register int h;
d104 1
a104 1
ndptr p;
d119 2
a120 2
char *name;
int all;
d122 2
a123 2
	register int h;
	register ndptr xp, tp, mp;
@


1.2
log
@rcsid
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d52 1
@


1.1
log
@Initial revision
@
text
@d1 2
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@
