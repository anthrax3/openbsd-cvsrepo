head	1.86;
access;
symbols
	OPENBSD_6_1:1.86.0.8
	OPENBSD_6_1_BASE:1.86
	OPENBSD_6_0:1.86.0.4
	OPENBSD_6_0_BASE:1.86
	OPENBSD_5_9:1.86.0.2
	OPENBSD_5_9_BASE:1.86
	OPENBSD_5_8:1.84.0.6
	OPENBSD_5_8_BASE:1.84
	OPENBSD_5_7:1.84.0.2
	OPENBSD_5_7_BASE:1.84
	OPENBSD_5_6:1.83.0.4
	OPENBSD_5_6_BASE:1.83
	OPENBSD_5_5:1.81.0.10
	OPENBSD_5_5_BASE:1.81
	OPENBSD_5_4:1.81.0.6
	OPENBSD_5_4_BASE:1.81
	OPENBSD_5_3:1.81.0.4
	OPENBSD_5_3_BASE:1.81
	OPENBSD_5_2:1.81.0.2
	OPENBSD_5_2_BASE:1.81
	OPENBSD_5_1_BASE:1.80
	OPENBSD_5_1:1.80.0.2
	OPENBSD_5_0:1.79.0.4
	OPENBSD_5_0_BASE:1.79
	OPENBSD_4_9:1.79.0.2
	OPENBSD_4_9_BASE:1.79
	OPENBSD_4_8:1.78.0.2
	OPENBSD_4_8_BASE:1.78
	OPENBSD_4_7:1.77.0.2
	OPENBSD_4_7_BASE:1.77
	OPENBSD_4_6:1.76.0.6
	OPENBSD_4_6_BASE:1.76
	OPENBSD_4_5:1.76.0.2
	OPENBSD_4_5_BASE:1.76
	OPENBSD_4_4:1.74.0.10
	OPENBSD_4_4_BASE:1.74
	OPENBSD_4_3:1.74.0.8
	OPENBSD_4_3_BASE:1.74
	OPENBSD_4_2:1.74.0.6
	OPENBSD_4_2_BASE:1.74
	OPENBSD_4_1:1.74.0.4
	OPENBSD_4_1_BASE:1.74
	OPENBSD_4_0:1.74.0.2
	OPENBSD_4_0_BASE:1.74
	OPENBSD_3_9:1.69.0.2
	OPENBSD_3_9_BASE:1.69
	OPENBSD_3_8:1.67.0.2
	OPENBSD_3_8_BASE:1.67
	OPENBSD_3_7:1.66.0.2
	OPENBSD_3_7_BASE:1.66
	OPENBSD_3_6:1.64.0.4
	OPENBSD_3_6_BASE:1.64
	OPENBSD_3_5:1.64.0.2
	OPENBSD_3_5_BASE:1.64
	OPENBSD_3_4:1.63.0.2
	OPENBSD_3_4_BASE:1.63
	OPENBSD_3_3:1.54.0.4
	OPENBSD_3_3_BASE:1.54
	OPENBSD_3_2:1.54.0.2
	OPENBSD_3_2_BASE:1.54
	OPENBSD_3_1:1.52.0.2
	OPENBSD_3_1_BASE:1.52
	OPENBSD_3_0:1.51.0.2
	OPENBSD_3_0_BASE:1.51
	OPENBSD_2_9_BASE:1.39
	OPENBSD_2_9:1.39.0.2
	OPENBSD_2_8:1.36.0.2
	OPENBSD_2_8_BASE:1.36
	OPENBSD_2_7:1.32.0.2
	OPENBSD_2_7_BASE:1.32
	OPENBSD_2_6:1.17.0.2
	OPENBSD_2_6_BASE:1.17
	OPENBSD_2_5:1.10.0.4
	OPENBSD_2_5_BASE:1.10
	OPENBSD_2_4:1.10.0.2
	OPENBSD_2_4_BASE:1.10
	OPENBSD_2_3:1.7.0.2
	OPENBSD_2_3_BASE:1.7
	OPENBSD_2_2:1.5.0.4
	OPENBSD_2_2_BASE:1.5
	OPENBSD_2_1:1.5.0.2
	OPENBSD_2_1_BASE:1.5
	OPENBSD_2_0:1.4.0.2
	OPENBSD_2_0_BASE:1.4
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.86
date	2015.11.03.16.21.47;	author deraadt;	state Exp;
branches;
next	1.85;
commitid	UG385lvsmK16SP43;

1.85
date	2015.11.01.18.17.59;	author espie;	state Exp;
branches;
next	1.84;
commitid	6cjE15pO2P3D9J5P;

1.84
date	2014.12.21.09.33.12;	author espie;	state Exp;
branches;
next	1.83;
commitid	cEHdgjDE2j8bVm3K;

1.83
date	2014.05.12.19.11.19;	author espie;	state Exp;
branches;
next	1.82;

1.82
date	2014.04.28.12.34.11;	author espie;	state Exp;
branches;
next	1.81;

1.81
date	2012.04.12.17.00.11;	author espie;	state Exp;
branches;
next	1.80;

1.80
date	2011.09.27.07.24.02;	author espie;	state Exp;
branches;
next	1.79;

1.79
date	2010.09.07.19.58.09;	author marco;	state Exp;
branches;
next	1.78;

1.78
date	2010.03.22.20.40.44;	author espie;	state Exp;
branches;
next	1.77;

1.77
date	2009.10.14.17.19.47;	author sthen;	state Exp;
branches;
next	1.76;

1.76
date	2008.08.16.12.21.46;	author espie;	state Exp;
branches;
next	1.75;

1.75
date	2008.08.16.12.19.49;	author espie;	state Exp;
branches;
next	1.74;

1.74
date	2006.03.24.08.03.44;	author espie;	state Exp;
branches;
next	1.73;

1.73
date	2006.03.23.08.01.02;	author espie;	state Exp;
branches;
next	1.72;

1.72
date	2006.03.23.07.57.05;	author espie;	state Exp;
branches;
next	1.71;

1.71
date	2006.03.20.20.27.45;	author espie;	state Exp;
branches;
next	1.70;

1.70
date	2006.03.20.10.55.19;	author espie;	state Exp;
branches;
next	1.69;

1.69
date	2006.01.20.23.10.19;	author espie;	state Exp;
branches;
next	1.68;

1.68
date	2005.09.06.15.33.21;	author espie;	state Exp;
branches;
next	1.67;

1.67
date	2005.08.06.16.22.26;	author espie;	state Exp;
branches;
next	1.66;

1.66
date	2005.03.02.10.12.15;	author espie;	state Exp;
branches;
next	1.65;

1.65
date	2005.01.20.23.47.04;	author espie;	state Exp;
branches;
next	1.64;

1.64
date	2003.11.17.17.12.10;	author espie;	state Exp;
branches;
next	1.63;

1.63
date	2003.06.30.22.13.32;	author espie;	state Exp;
branches;
next	1.62;

1.62
date	2003.06.30.22.11.38;	author espie;	state Exp;
branches;
next	1.61;

1.61
date	2003.06.30.22.10.21;	author espie;	state Exp;
branches;
next	1.60;

1.60
date	2003.06.30.21.47.21;	author espie;	state Exp;
branches;
next	1.59;

1.59
date	2003.06.30.21.42.50;	author espie;	state Exp;
branches;
next	1.58;

1.58
date	2003.06.18.21.08.07;	author espie;	state Exp;
branches;
next	1.57;

1.57
date	2003.06.12.14.36.43;	author espie;	state Exp;
branches;
next	1.56;

1.56
date	2003.06.10.22.20.48;	author deraadt;	state Exp;
branches;
next	1.55;

1.55
date	2003.06.03.02.56.10;	author millert;	state Exp;
branches;
next	1.54;

1.54
date	2002.04.28.14.37.12;	author espie;	state Exp;
branches;
next	1.53;

1.53
date	2002.04.26.16.15.16;	author espie;	state Exp;
branches;
next	1.52;

1.52
date	2002.02.16.21.27.48;	author millert;	state Exp;
branches;
next	1.51;

1.51
date	2001.10.06.10.52.25;	author espie;	state Exp;
branches;
next	1.50;

1.50
date	2001.09.28.12.05.38;	author espie;	state Exp;
branches;
next	1.49;

1.49
date	2001.09.27.11.40.33;	author espie;	state Exp;
branches;
next	1.48;

1.48
date	2001.09.19.13.14.18;	author espie;	state Exp;
branches;
next	1.47;

1.47
date	2001.09.18.20.59.32;	author espie;	state Exp;
branches;
next	1.46;

1.46
date	2001.09.18.14.55.52;	author espie;	state Exp;
branches;
next	1.45;

1.45
date	2001.09.18.14.05.14;	author espie;	state Exp;
branches;
next	1.44;

1.44
date	2001.09.18.13.52.58;	author espie;	state Exp;
branches;
next	1.43;

1.43
date	2001.09.18.13.44.51;	author espie;	state Exp;
branches;
next	1.42;

1.42
date	2001.09.17.08.11.13;	author espie;	state Exp;
branches;
next	1.41;

1.41
date	2001.09.16.21.12.08;	author espie;	state Exp;
branches;
next	1.40;

1.40
date	2001.07.28.05.36.18;	author pvalchev;	state Exp;
branches;
next	1.39;

1.39
date	2001.03.05.15.09.20;	author espie;	state Exp;
branches;
next	1.38;

1.38
date	2001.03.02.00.25.24;	author aaron;	state Exp;
branches;
next	1.37;

1.37
date	2001.02.05.01.57.27;	author deraadt;	state Exp;
branches;
next	1.36;

1.36
date	2000.07.27.17.44.33;	author espie;	state Exp;
branches;
next	1.35;

1.35
date	2000.07.24.23.08.25;	author espie;	state Exp;
branches;
next	1.34;

1.34
date	2000.07.02.01.17.00;	author espie;	state Exp;
branches;
next	1.33;

1.33
date	2000.07.02.01.13.07;	author espie;	state Exp;
branches;
next	1.32;

1.32
date	2000.03.18.01.06.56;	author espie;	state Exp;
branches;
next	1.31;

1.31
date	2000.03.11.15.54.44;	author espie;	state Exp;
branches;
next	1.30;

1.30
date	2000.02.02.14.05.22;	author espie;	state Exp;
branches;
next	1.29;

1.29
date	2000.02.02.14.00.12;	author espie;	state Exp;
branches;
next	1.28;

1.28
date	2000.01.15.14.26.00;	author espie;	state Exp;
branches;
next	1.27;

1.27
date	2000.01.13.17.35.09;	author espie;	state Exp;
branches;
next	1.26;

1.26
date	2000.01.12.17.49.53;	author espie;	state Exp;
branches;
next	1.25;

1.25
date	2000.01.11.14.10.01;	author espie;	state Exp;
branches;
next	1.24;

1.24
date	2000.01.11.14.06.11;	author espie;	state Exp;
branches;
next	1.23;

1.23
date	2000.01.05.16.06.14;	author espie;	state Exp;
branches;
next	1.22;

1.22
date	99.11.30.22.24.20;	author espie;	state Exp;
branches;
next	1.21;

1.21
date	99.11.30.22.19.50;	author espie;	state Exp;
branches;
next	1.20;

1.20
date	99.11.25.00.54.22;	author millert;	state Exp;
branches;
next	1.19;

1.19
date	99.11.20.17.48.59;	author espie;	state Exp;
branches;
next	1.18;

1.18
date	99.11.17.15.34.13;	author espie;	state Exp;
branches;
next	1.17;

1.17
date	99.09.14.08.35.16;	author espie;	state Exp;
branches;
next	1.16;

1.16
date	99.09.14.08.30.20;	author espie;	state Exp;
branches;
next	1.15;

1.15
date	99.09.14.08.21.37;	author espie;	state Exp;
branches;
next	1.14;

1.14
date	99.09.06.13.29.32;	author espie;	state Exp;
branches;
next	1.13;

1.13
date	99.09.06.13.24.59;	author espie;	state Exp;
branches;
next	1.12;

1.12
date	99.09.06.13.20.40;	author espie;	state Exp;
branches;
next	1.11;

1.11
date	99.09.06.13.10.48;	author espie;	state Exp;
branches;
next	1.10;

1.10
date	98.06.02.20.46.40;	author deraadt;	state Exp;
branches;
next	1.9;

1.9
date	98.06.02.15.05.02;	author mickey;	state Exp;
branches;
next	1.8;

1.8
date	98.04.25.18.47.20;	author millert;	state Exp;
branches;
next	1.7;

1.7
date	97.12.20.15.39.14;	author deraadt;	state Exp;
branches;
next	1.6;

1.6
date	97.12.10.20.24.15;	author deraadt;	state Exp;
branches;
next	1.5;

1.5
date	97.01.15.23.42.49;	author millert;	state Exp;
branches;
next	1.4;

1.4
date	96.08.22.00.35.01;	author deraadt;	state Exp;
branches;
next	1.3;

1.3
date	96.06.26.05.36.14;	author deraadt;	state Exp;
branches;
next	1.2;

1.2
date	96.01.15.01.12.18;	author deraadt;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.45.35;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.45.35;	author deraadt;	state Exp;
branches;
next	;


desc
@@


1.86
log
@There really is no double standard. Treat m4 just like openssl, by
removing VMS and MSDOS support.
ok espie
@
text
@/*	$OpenBSD: main.c,v 1.85 2015/11/01 18:17:59 espie Exp $	*/
/*	$NetBSD: main.c,v 1.12 1997/02/08 23:54:49 cgd Exp $	*/

/*-
 * Copyright (c) 1989, 1993
 *	The Regents of the University of California.  All rights reserved.
 *
 * This code is derived from software contributed to Berkeley by
 * Ozan Yigit at York University.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */

/*
 * main.c
 * Facility: m4 macro processor
 * by: oz
 */

#include <assert.h>
#include <signal.h>
#include <err.h>
#include <errno.h>
#include <unistd.h>
#include <stdio.h>
#include <ctype.h>
#include <string.h>
#include <stddef.h>
#include <stdint.h>
#include <stdlib.h>
#include <ohash.h>
#include "mdef.h"
#include "stdd.h"
#include "extern.h"
#include "pathnames.h"

stae *mstack;			/* stack of m4 machine         */
char *sstack;			/* shadow stack, for string space extension */
static size_t STACKMAX;		/* current maximum size of stack */
int sp;				/* current m4  stack pointer   */
int fp;				/* m4 call frame pointer       */
struct input_file infile[MAXINP];/* input file stack (0=stdin)  */
FILE **outfile;			/* diversion array(0=bitbucket)*/
int maxout;
FILE *active;			/* active output file pointer  */
int ilevel = 0;			/* input file stack pointer    */
int oindex = 0;			/* diversion index..	       */
char *null = "";                /* as it says.. just a null..  */
char **m4wraps = NULL;		/* m4wraps array.	       */
int maxwraps = 0;		/* size of m4wraps array       */
int wrapindex = 0;		/* current offset in m4wraps   */
char lquote[MAXCCHARS+1] = {LQUOTE};	/* left quote character  (`)   */
char rquote[MAXCCHARS+1] = {RQUOTE};	/* right quote character (')   */
char scommt[MAXCCHARS+1] = {SCOMMT};	/* start character for comment */
char ecommt[MAXCCHARS+1] = {ECOMMT};	/* end character for comment   */
int  synch_lines = 0;		/* line synchronisation for C preprocessor */
int  prefix_builtins = 0;	/* -P option to prefix builtin keywords */

struct keyblk {
        char    *knam;          /* keyword name */
        int     ktyp;           /* keyword type */
};

struct keyblk keywrds[] = {	/* m4 keywords to be installed */
	{ "include",      INCLTYPE },
	{ "sinclude",     SINCTYPE },
	{ "define",       DEFITYPE },
	{ "defn",         DEFNTYPE },
	{ "divert",       DIVRTYPE | NOARGS },
	{ "expr",         EXPRTYPE },
	{ "eval",         EXPRTYPE },
	{ "substr",       SUBSTYPE },
	{ "ifelse",       IFELTYPE },
	{ "ifdef",        IFDFTYPE },
	{ "len",          LENGTYPE },
	{ "incr",         INCRTYPE },
	{ "decr",         DECRTYPE },
	{ "dnl",          DNLNTYPE | NOARGS },
	{ "changequote",  CHNQTYPE | NOARGS },
	{ "changecom",    CHNCTYPE | NOARGS },
	{ "index",        INDXTYPE },
#ifdef EXTENDED
	{ "paste",        PASTTYPE },
	{ "spaste",       SPASTYPE },
	/* Newer extensions, needed to handle gnu-m4 scripts */
	{ "indir",        INDIRTYPE},
	{ "builtin",      BUILTINTYPE},
	{ "patsubst",	  PATSTYPE},
	{ "regexp",	  REGEXPTYPE},
	{ "esyscmd",	  ESYSCMDTYPE},
	{ "__file__",	  FILENAMETYPE | NOARGS},
	{ "__line__",	  LINETYPE | NOARGS},
#endif
	{ "popdef",       POPDTYPE },
	{ "pushdef",      PUSDTYPE },
	{ "dumpdef",      DUMPTYPE | NOARGS },
	{ "shift",        SHIFTYPE | NOARGS },
	{ "translit",     TRNLTYPE },
	{ "undefine",     UNDFTYPE },
	{ "undivert",     UNDVTYPE | NOARGS },
	{ "divnum",       DIVNTYPE | NOARGS },
	{ "maketemp",     MKTMTYPE },
	{ "mkstemp",      MKTMTYPE },
	{ "errprint",     ERRPTYPE | NOARGS },
	{ "m4wrap",       M4WRTYPE | NOARGS },
	{ "m4exit",       EXITTYPE | NOARGS },
	{ "syscmd",       SYSCTYPE },
	{ "sysval",       SYSVTYPE | NOARGS },
	{ "traceon",	  TRACEONTYPE | NOARGS },
	{ "traceoff",	  TRACEOFFTYPE | NOARGS },

	{ "unix",         SELFTYPE | NOARGS },
};

#define MAXKEYS	(sizeof(keywrds)/sizeof(struct keyblk))

extern int optind;
extern char *optarg;

#define MAXRECORD 50
static struct position {
	char *name;
	unsigned long line;
} quotes[MAXRECORD], paren[MAXRECORD];

static void record(struct position *, int);
static void dump_stack(struct position *, int);

static void macro(void);
static void initkwds(void);
static ndptr inspect(int, char *);
static int do_look_ahead(int, const char *);
static void reallyoutputstr(const char *);
static void reallyputchar(int);

static void enlarge_stack(void);

int main(int, char *[]);

int exit_code = 0;

int
main(int argc, char *argv[])
{
	int c;
	int n;
	char *p;

	if (pledge("stdio rpath wpath cpath tmppath proc exec", NULL) == -1)
		err(1, "pledge");

	if (signal(SIGINT, SIG_IGN) != SIG_IGN)
		signal(SIGINT, onintr);

	init_macros();
	initspaces();
	STACKMAX = INITSTACKMAX;

	mstack = xreallocarray(NULL, STACKMAX, sizeof(stae), NULL);
	sstack = xalloc(STACKMAX, NULL);

	maxout = 0;
	outfile = NULL;
	resizedivs(MAXOUT);

	while ((c = getopt(argc, argv, "gst:d:D:U:o:I:P")) != -1)
		switch(c) {

		case 'D':               /* define something..*/
			for (p = optarg; *p; p++)
				if (*p == '=')
					break;
			if (*p)
				*p++ = EOS;
			dodefine(optarg, p);
			break;
		case 'I':
			addtoincludepath(optarg);
			break;
		case 'P':
			prefix_builtins = 1;
			break;
		case 'U':               /* undefine...       */
			macro_popdef(optarg);
			break;
		case 'g':
			mimic_gnu = 1;
			break;
		case 'd':
			set_trace_flags(optarg);
			break;
		case 's':
			synch_lines = 1;
			break;
		case 't':
			mark_traced(optarg, 1);
			break;
		case 'o':
			trace_file(optarg);
                        break;
		case '?':
			usage();
		}

        argc -= optind;
        argv += optind;

	initkwds();
	if (mimic_gnu)
		setup_builtin("format", FORMATTYPE);

	active = stdout;		/* default active output     */
	bbase[0] = bufbase;
        if (!argc) {
		sp = -1;		/* stack pointer initialized */
		fp = 0;			/* frame pointer initialized */
		set_input(infile+0, stdin, "stdin");
					/* default input (naturally) */
		macro();
	} else
		for (; argc--; ++argv) {
			p = *argv;
			if (p[0] == '-' && p[1] == EOS)
				set_input(infile, stdin, "stdin");
			else if (fopen_trypath(infile, p) == NULL)
				err(1, "%s", p);
			sp = -1;
			fp = 0;
			macro();
			release_input(infile);
		}

	if (wrapindex) {
		int i;

		ilevel = 0;		/* in case m4wrap includes.. */
		bufbase = bp = buf;	/* use the entire buffer   */
		if (mimic_gnu) {
			while (wrapindex != 0) {
				for (i = 0; i < wrapindex; i++)
					pbstr(m4wraps[i]);
				wrapindex =0;
				macro();
			}
		} else {
			for (i = 0; i < wrapindex; i++) {
				pbstr(m4wraps[i]);
				macro();
			}
		}
	}

	if (active != stdout)
		active = stdout;	/* reset output just in case */
	for (n = 1; n < maxout; n++)	/* default wrap-up: undivert */
		if (outfile[n] != NULL)
			getdiv(n);
					/* remove bitbucket if used  */
	if (outfile[0] != NULL) {
		(void) fclose(outfile[0]);
	}

	return exit_code;
}

/*
 * Look ahead for `token'.
 * (on input `t == token[0]')
 * Used for comment and quoting delimiters.
 * Returns 1 if `token' present; copied to output.
 *         0 if `token' not found; all characters pushed back
 */
static int
do_look_ahead(int t, const char *token)
{
	int i;

	assert((unsigned char)t == (unsigned char)token[0]);

	for (i = 1; *++token; i++) {
		t = gpbc();
		if (t == EOF || (unsigned char)t != (unsigned char)*token) {
			pushback(t);
			while (--i)
				pushback(*--token);
			return 0;
		}
	}
	return 1;
}

#define LOOK_AHEAD(t, token) (t != EOF &&		\
    (unsigned char)(t)==(unsigned char)(token)[0] &&	\
    do_look_ahead(t,token))

/*
 * macro - the work horse..
 */
static void
macro(void)
{
	char token[MAXTOK+1];
	int t, l;
	ndptr p;
	int  nlpar;

	cycle {
		t = gpbc();

		if (LOOK_AHEAD(t,lquote)) {	/* strip quotes */
			nlpar = 0;
			record(quotes, nlpar++);
			/*
			 * Opening quote: scan forward until matching
			 * closing quote has been found.
			 */
			do {

				l = gpbc();
				if (LOOK_AHEAD(l,rquote)) {
					if (--nlpar > 0)
						outputstr(rquote);
				} else if (LOOK_AHEAD(l,lquote)) {
					record(quotes, nlpar++);
					outputstr(lquote);
				} else if (l == EOF) {
					if (nlpar == 1)
						warnx("unclosed quote:");
					else
						warnx("%d unclosed quotes:", nlpar);
					dump_stack(quotes, nlpar);
					exit(1);
				} else {
					if (nlpar > 0) {
						if (sp < 0)
							reallyputchar(l);
						else
							CHRSAVE(l);
					}
				}
			}
			while (nlpar != 0);
		} else if (sp < 0 && LOOK_AHEAD(t, scommt)) {
			reallyoutputstr(scommt);

			for(;;) {
				t = gpbc();
				if (LOOK_AHEAD(t, ecommt)) {
					reallyoutputstr(ecommt);
					break;
				}
				if (t == EOF)
					break;
				reallyputchar(t);
			}
		} else if (t == '_' || isalpha(t)) {
			p = inspect(t, token);
			if (p != NULL)
				pushback(l = gpbc());
			if (p == NULL || (l != LPAREN &&
			    (macro_getdef(p)->type & NEEDARGS) != 0))
				outputstr(token);
			else {
		/*
		 * real thing.. First build a call frame:
		 */
				pushf(fp);	/* previous call frm */
				pushf(macro_getdef(p)->type); /* type of the call  */
				pushf(is_traced(p));
				pushf(0);	/* parenthesis level */
				fp = sp;	/* new frame pointer */
		/*
		 * now push the string arguments:
		 */
				pushdef(p);			/* defn string */
				pushs1((char *)macro_name(p));	/* macro name  */
				pushs(ep);			/* start next..*/

				if (l != LPAREN && PARLEV == 0) {
				    /* no bracks  */
					chrsave(EOS);

					if (sp == STACKMAX)
						errx(1, "internal stack overflow");
					eval((const char **) mstack+fp+1, 2,
					    CALTYP, TRACESTATUS);

					ep = PREVEP;	/* flush strspace */
					sp = PREVSP;	/* previous sp..  */
					fp = PREVFP;	/* rewind stack...*/
				}
			}
		} else if (t == EOF) {
			if (!mimic_gnu /* you can puke right there */
			    && sp > -1 && ilevel <= 0) {
				warnx( "unexpected end of input, unclosed parenthesis:");
				dump_stack(paren, PARLEV);
				exit(1);
			}
			if (ilevel <= 0)
				break;			/* all done thanks.. */
			release_input(infile+ilevel--);
			emit_synchline();
			bufbase = bbase[ilevel];
			continue;
		} else if (sp < 0) {		/* not in a macro at all */
			reallyputchar(t);	/* output directly..	 */
		}

		else switch(t) {

		case LPAREN:
			if (PARLEV > 0)
				chrsave(t);
			while (isspace(l = gpbc())) /* skip blank, tab, nl.. */
				if (PARLEV > 0)
					chrsave(l);
			pushback(l);
			record(paren, PARLEV++);
			break;

		case RPAREN:
			if (--PARLEV > 0)
				chrsave(t);
			else {			/* end of argument list */
				chrsave(EOS);

				if (sp == STACKMAX)
					errx(1, "internal stack overflow");

				eval((const char **) mstack+fp+1, sp-fp,
				    CALTYP, TRACESTATUS);

				ep = PREVEP;	/* flush strspace */
				sp = PREVSP;	/* previous sp..  */
				fp = PREVFP;	/* rewind stack...*/
			}
			break;

		case COMMA:
			if (PARLEV == 1) {
				chrsave(EOS);		/* new argument   */
				while (isspace(l = gpbc()))
					;
				pushback(l);
				pushs(ep);
			} else
				chrsave(t);
			break;

		default:
			if (LOOK_AHEAD(t, scommt)) {
				char *p;
				for (p = scommt; *p; p++)
					chrsave(*p);
				for(;;) {
					t = gpbc();
					if (LOOK_AHEAD(t, ecommt)) {
						for (p = ecommt; *p; p++)
							chrsave(*p);
						break;
					}
					if (t == EOF)
					    break;
					CHRSAVE(t);
				}
			} else
				CHRSAVE(t);		/* stack the char */
			break;
		}
	}
}

/*
 * output string directly, without pushing it for reparses.
 */
void
outputstr(const char *s)
{
	if (sp < 0)
		reallyoutputstr(s);
	else
		while (*s)
			CHRSAVE(*s++);
}

void
reallyoutputstr(const char *s)
{
	if (synch_lines) {
		while (*s) {
			fputc(*s, active);
			if (*s++ == '\n') {
				infile[ilevel].synch_lineno++;
				if (infile[ilevel].synch_lineno !=
				    infile[ilevel].lineno)
					do_emit_synchline();
			}
		}
	} else
		fputs(s, active);
}

void
reallyputchar(int c)
{
	putc(c, active);
	if (synch_lines && c == '\n') {
		infile[ilevel].synch_lineno++;
		if (infile[ilevel].synch_lineno != infile[ilevel].lineno)
			do_emit_synchline();
	}
}

/*
 * build an input token..
 * consider only those starting with _ or A-Za-z.
 */
static ndptr
inspect(int c, char *tp)
{
	char *name = tp;
	char *etp = tp+MAXTOK;
	ndptr p;

	*tp++ = c;

	while ((isalnum(c = gpbc()) || c == '_') && tp < etp)
		*tp++ = c;
	if (c != EOF)
		PUSHBACK(c);
	*tp = EOS;
	/* token is too long, it won't match anything, but it can still
	 * be output. */
	if (tp == ep) {
		outputstr(name);
		while (isalnum(c = gpbc()) || c == '_') {
			if (sp < 0)
				reallyputchar(c);
			else
				CHRSAVE(c);
		}
		*name = EOS;
		return NULL;
	}

	p = ohash_find(&macros, ohash_qlookupi(&macros, name, (const char **)&tp));
	if (p == NULL)
		return NULL;
	if (macro_getdef(p) == NULL)
		return NULL;
	return p;
}

/*
 * initkwds - initialise m4 keywords as fast as possible.
 * This very similar to install, but without certain overheads,
 * such as calling lookup. Malloc is not used for storing the
 * keyword strings, since we simply use the static pointers
 * within keywrds block.
 */
static void
initkwds(void)
{
	unsigned int type;
	int i;

	for (i = 0; i < MAXKEYS; i++) {
		type = keywrds[i].ktyp & TYPEMASK;
		if ((keywrds[i].ktyp & NOARGS) == 0)
			type |= NEEDARGS;
		setup_builtin(keywrds[i].knam, type);
	}
}

static void
record(struct position *t, int lev)
{
	if (lev < MAXRECORD) {
		t[lev].name = CURRENT_NAME;
		t[lev].line = CURRENT_LINE;
	}
}

static void
dump_stack(struct position *t, int lev)
{
	int i;

	for (i = 0; i < lev; i++) {
		if (i == MAXRECORD) {
			fprintf(stderr, "   ...\n");
			break;
		}
		fprintf(stderr, "   %s at line %lu\n",
			t[i].name, t[i].line);
	}
}


static void
enlarge_stack(void)
{
	STACKMAX += STACKMAX/2;
	mstack = xreallocarray(mstack, STACKMAX, sizeof(stae),
	    "Evaluation stack overflow (%lu)",
	    (unsigned long)STACKMAX);
	sstack = xrealloc(sstack, STACKMAX,
	    "Evaluation stack overflow (%lu)",
	    (unsigned long)STACKMAX);
}
@


1.85
log
@pledge m4. tested by me.
reordered to match the manpage, and added tmppath as an annotation

prompted by deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.84 2014/12/21 09:33:12 espie Exp $	*/
a133 1
#if defined(unix) || defined(__unix__)
a134 5
#else
#ifdef vms
	{ "vms",          SELFTYPE | NOARGS },
#endif
#endif
@


1.84
log
@fix test-redef2:
- introduce explicit STORAGE classes for the shadow stack entries
- delay freeing definitions if they're in-use, keep them in a simple array.

okay millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.83 2014/05/12 19:11:19 espie Exp $	*/
d176 3
@


1.83
log
@adjust to ohash being in libutil now, and to the interface changes.
fix potential integer overflows in memory allocation (mostly for pedagogical
purposes, these are unlikely to overflow in practice)
move the rest of lst.lib stuff into its own directory.
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.82 2014/04/28 12:34:11 espie Exp $	*/
d400 1
a400 1
				pushs1(macro_getdef(p)->defn);	/* defn string */
@


1.82
log
@check for integer overflows in custom allocs, okay jca@@
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.81 2012/04/12 17:00:11 espie Exp $	*/
d184 1
a184 1
	mstack = xallocarray(STACKMAX, sizeof(stae), NULL);
d419 2
a420 1
			if (sp > -1 && ilevel <= 0) {
@


1.81
log
@new m4 -g stuff:
- expr(`4**3')
- include(`hey I am not there') keeps going.

work with Baptiste Daroussin, who had the idea but didn't nail all details
right.

okay otto@@, miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.80 2011/09/27 07:24:02 espie Exp $	*/
d184 2
a185 2
	mstack = (stae *)xalloc(sizeof(stae) * STACKMAX, NULL);
	sstack = (char *)xalloc(STACKMAX, NULL);
d629 1
a629 1
	mstack = xrealloc(mstack, sizeof(stae) * STACKMAX,
@


1.80
log
@zap dead stuff
from Michael W. Bombardieri
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.79 2010/09/07 19:58:09 marco Exp $	*/
d168 2
d288 1
a288 1
	return 0;
@


1.79
log
@Remove stray spaces.  No code change.
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.78 2010/03/22 20:40:44 espie Exp $	*/
a58 1
ndptr hashtab[HASHSIZE];	/* hash table for macros etc.  */
@


1.78
log
@add more gnum4 support: regexps do weird things with empty patterns (this
is required for newer autoconf).
fix the tokenizer for gnu extensions, allowing digits out of range is
ridiculous.
add POSIX2008 mkstemp and document it (also documenting that mktemp is
safe, not posix...)
tidy the manpage, do extra .Nm m4 -> .Nm.
okay otto@@, miod@@, jmc@@
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.77 2009/10/14 17:19:47 sthen Exp $	*/
d60 2
a61 2
stae *mstack;		 	/* stack of m4 machine         */
char *sstack;		 	/* shadow stack, for string space extension */
d63 2
a64 2
int sp; 			/* current m4  stack pointer   */
int fp; 			/* m4 call frame pointer       */
d69 2
a70 2
int ilevel = 0; 		/* input file stack pointer    */
int oindex = 0; 		/* diversion index..	       */
d72 1
a72 1
char **m4wraps = NULL;		/* m4wraps array.     	       */
d108 1
a108 1
    	/* Newer extensions, needed to handle gnu-m4 scripts */
d135 1
a135 1
#if defined(unix) || defined(__unix__) 
d239 2
a240 2
 		sp = -1;		/* stack pointer initialized */
		fp = 0; 		/* frame pointer initialized */
d252 1
a252 1
			fp = 0; 
d254 1
a254 1
		    	release_input(infile);
d273 1
a273 1
		    	}
d316 2
a317 2
#define LOOK_AHEAD(t, token) (t != EOF && 		\
    (unsigned char)(t)==(unsigned char)(token)[0] && 	\
d384 1
a384 1
			if (p == NULL || (l != LPAREN && 
d401 1
a401 1
				pushs(ep);	      	/* start next..*/
d403 1
a403 1
				if (l != LPAREN && PARLEV == 0)  {   
d409 1
a409 1
					eval((const char **) mstack+fp+1, 2, 
d454 1
a454 1
				eval((const char **) mstack+fp+1, sp-fp, 
d497 2
a498 2
/* 
 * output string directly, without pushing it for reparses. 
d518 1
a518 1
				if (infile[ilevel].synch_lineno != 
d540 1
a540 1
 * consider only those starting with _ or A-Za-z. 
d543 1
a543 1
inspect(int c, char *tp) 
d548 1
a548 1
	
d579 1
a579 1
 * initkwds - initialise m4 keywords as fast as possible. 
d581 1
a581 1
 * such as calling lookup. Malloc is not used for storing the 
d618 1
a618 1
		fprintf(stderr, "   %s at line %lu\n", 
d624 1
a624 1
static void 
d628 2
a629 2
	mstack = xrealloc(mstack, sizeof(stae) * STACKMAX, 
	    "Evaluation stack overflow (%lu)", 
d632 1
a632 1
	    "Evaluation stack overflow (%lu)", 
@


1.77
log
@Support the -P option from gnu m4, which prefixes builtins with the
string m4_. Feedback from jmc@@, Tobias Ulmer, Matthew Dempsky - thanks!
ok espie@@
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.76 2008/08/16 12:21:46 espie Exp $	*/
d126 1
@


1.76
log
@argument parsing should only skip spaces outside of parenthesis.
Inside matching parenthesis, keep spaces as is (use chrsave instead of
pbstr, since there's no way it can be a further macro expansion).
Fixes a long-standing issue with autoconf (   --option -> --option),
matches other m4 than gnum4

okay millert@@, fries@@
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.75 2008/08/16 12:19:49 espie Exp $	*/
d80 1
a178 1
	initkwds();
d189 1
a189 1
	while ((c = getopt(argc, argv, "gst:d:D:U:o:I:")) != -1)
d203 3
a210 1
			setup_builtin("format", FORMATTYPE);
d230 4
@


1.75
log
@be more liberal in include handling, namely we only error out if it's
the end of the last included file AND we still have a macro to expand.
autoconf uses this in wine, and it turns out other m4 also do things that
way (not only gnu m4).

okay fries@@, millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.74 2006/03/24 08:03:44 espie Exp $	*/
d431 3
a433 2
			while (isspace(l = gpbc()))
				;		/* skip blank, tab, nl.. */
@


1.74
log
@oops, noticed by David Hill.
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.73 2006/03/23 08:01:02 espie Exp $	*/
d411 1
a411 1
			if (sp > -1) {
@


1.73
log
@simply set up format only when we see -g.
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.72 2006/03/23 07:57:05 espie Exp $	*/
d44 1
@


1.72
log
@back-out format for now, need to be active ONLY in GNU-m4 mode.
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.71 2006/03/20 20:27:45 espie Exp $	*/
d207 1
@


1.71
log
@add limited support for format builtin in gnu-m4 mode, because I'm fed
up of patching it away in various autoconf derivatives.

okay miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.70 2006/03/20 10:55:19 espie Exp $	*/
a113 1
	{ "format",	  FORMATTYPE},
@


1.70
log
@report function m4errx, that shows app-specific data (filename/linenumber)
before the error message. Use it to simplify code.

okay miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.69 2006/01/20 23:10:19 espie Exp $	*/
d114 1
@


1.69
log
@use stdint.h where appropriate. okay millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.68 2005/09/06 15:33:21 espie Exp $	*/
a52 1
#include <err.h>
@


1.68
log
@finally make our m4 SusV3-compliant.

- changecom and changequote have a simple definition (that matches gnu-m4,
coincidentally, so we no longer need two distinct modes for these)

- off-by-one bug in -s, this finally works.

- reorder main parser loop, so that we can use alphabetic constructs in
quotes/comments.

- rename putback to pushback, this matches comments, and makes more sense.

- more uniform (and updated) description of changequote/changecom.

- new, systematic regression tests of comments/quotes.

- framework to test -s: one perl script to reconstitute `full' files with
all line numbers, so that we can verify the output without needing a
complete match.

okay otto@@, fries@@
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.67 2005/08/06 16:22:26 espie Exp $	*/
a41 1
#include <sys/types.h>
d50 1
@


1.67
log
@zap rcsid. It's not ramdisk, but they still take space.
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.66 2005/03/02 10:12:15 espie Exp $	*/
d299 1
a299 1
			putback(t);
d301 1
a301 1
				putback(*--token);
d325 48
a372 1
		if (t == '_' || isalpha(t)) {
d375 1
a375 1
				putback(l = gpbc());
d421 1
a421 56
		}
	/*
	 * non-alpha token possibly seen..
	 * [the order of else if .. stmts is important.]
	 */
		else if (LOOK_AHEAD(t,lquote)) {	/* strip quotes */
			nlpar = 0;
			record(quotes, nlpar++);
			/*
			 * Opening quote: scan forward until matching
			 * closing quote has been found.
			 */
			do {

				l = gpbc();
				if (LOOK_AHEAD(l,rquote)) {
					if (--nlpar > 0)
						outputstr(rquote);
				} else if (LOOK_AHEAD(l,lquote)) {
					record(quotes, nlpar++);
					outputstr(lquote);
				} else if (l == EOF) {
					if (nlpar == 1)
						warnx("unclosed quote:");
					else
						warnx("%d unclosed quotes:", nlpar);
					dump_stack(quotes, nlpar);
					exit(1);
				} else {
					if (nlpar > 0) {
						if (sp < 0)
							reallyputchar(l);
						else
							CHRSAVE(l);
					}
				}
			}
			while (nlpar != 0);
		}

		else if (sp < 0 && LOOK_AHEAD(t, scommt)) {
			reallyoutputstr(scommt);

			for(;;) {
				t = gpbc();
				if (LOOK_AHEAD(t, ecommt)) {
					reallyoutputstr(ecommt);
					break;
				}
				if (t == EOF)
					break;
				reallyputchar(t);
			}
		}

		else if (sp < 0) {		/* not in a macro at all */
d432 1
a432 1
			putback(l);
d459 1
a459 1
				putback(l);
d545 1
a545 1
		PUTBACK(c);
@


1.66
log
@let m4wrap handle multiple wraps, both in normal and gnu-mode.
based on Noah Misch's bug report.
okay otto, jmc.
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.65 2005/01/20 23:47:04 espie Exp $	*/
a34 14

#ifndef lint
static char copyright[] =
"@@(#) Copyright (c) 1989, 1993\n\
	The Regents of the University of California.  All rights reserved.\n";
#endif /* not lint */

#ifndef lint
#if 0
static char sccsid[] = "@@(#)main.c	8.1 (Berkeley) 6/6/93";
#else
static char rcsid[] = "$OpenBSD: main.c,v 1.65 2005/01/20 23:47:04 espie Exp $";
#endif
#endif /* not lint */
@


1.65
log
@remove unused variables, extra declarations.
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.64 2003/11/17 17:12:10 espie Exp $	*/
d46 1
a46 1
static char rcsid[] = "$OpenBSD: main.c,v 1.64 2003/11/17 17:12:10 espie Exp $";
d86 3
a88 1
char *m4wraps = "";             /* m4wrap string default..     */
d263 3
a265 1
	if (*m4wraps) { 		/* anything for rundown ??   */
d268 13
a280 2
		pbstr(m4wraps); 	/* user-defined wrapup act   */
		macro();		/* last will and testament   */
@


1.64
log
@Modify xalloc so that it also takes err(3)-like arguments.
Write an xrealloc wrapper that works the same way, and use it as well.

People who feel like it may want to add more explicit error messages to
all the places m4 can fail allocating memory...

okay tedu@@
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.63 2003/06/30 22:13:32 espie Exp $	*/
d46 1
a46 1
static char rcsid[] = "$OpenBSD: main.c,v 1.63 2003/06/30 22:13:32 espie Exp $";
a545 1
	unsigned int h;
@


1.63
log
@Fold trace status into the single hash table that's left.
Inline some macros/functions for speed.
So, this achieves the goal of one single lookup for macro/trace status,
which does speed up m4 in partial tracing situations somewhat.
This does also speed up m4 in large pushdef situations, since it no longer
has to lookup large chains of macros.

okay millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.62 2003/06/30 22:11:38 espie Exp $	*/
d46 1
a46 1
static char rcsid[] = "$OpenBSD: main.c,v 1.62 2003/06/30 22:11:38 espie Exp $";
d194 2
a195 2
	mstack = (stae *)xalloc(sizeof(stae) * STACKMAX);
	sstack = (char *)xalloc(STACKMAX);
d626 7
a632 6
	STACKMAX *= 2;
	mstack = realloc(mstack, sizeof(stae) * STACKMAX);
	sstack = realloc(sstack, STACKMAX);
	if (mstack == NULL || sstack == NULL)
		errx(1, "Evaluation stack overflow (%lu)", 
		    (unsigned long)STACKMAX);
@


1.62
log
@add a flag for each macro name that records built-in status.
Fold built-in lookup into normal lookup.
okay millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.61 2003/06/30 22:10:21 espie Exp $	*/
d46 1
a46 1
static char rcsid[] = "$OpenBSD: main.c,v 1.61 2003/06/30 22:10:21 espie Exp $";
d66 1
d93 5
a188 1
	init_trace();
d337 1
a337 4
				if (traced_macros && is_traced(macro_name(p)))
					pushf(1);
				else
					pushf(0);
d569 1
a569 1
	p = lookup(name);
@


1.61
log
@replace old hash structure with open hashing.
make the stack structure of macro definitions explicit.
okay millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.60 2003/06/30 21:47:21 espie Exp $	*/
d46 1
a46 1
static char rcsid[] = "$OpenBSD: main.c,v 1.60 2003/06/30 21:47:21 espie Exp $";
a593 12
}

/* Look up a builtin type, even if overridden by the user */
int 
builtin_type(const char *key)
{
	int i;

	for (i = 0; i != MAXKEYS; i++)
		if (STREQ(keywrds[i].knam, key))
			return keywrds[i].ktyp;
	return -1;
@


1.60
log
@Make the trace status of a macro an actual argument that gets pushed
in the frame for the macro expansion.

(This will allow one single lookup to grab the macro definition and
the trace status)

okay millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.59 2003/06/30 21:42:50 espie Exp $	*/
d46 1
a46 1
static char rcsid[] = "$OpenBSD: main.c,v 1.59 2003/06/30 21:42:50 espie Exp $";
d184 1
d567 6
a572 1
	return lookup(name);
@


1.59
log
@clean up internal lookup interface:
define an interface with explicit define/pushdef/popdef... and use it.
That way, most details of the hashtable are no longer visible.

okay millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.58 2003/06/18 21:08:07 espie Exp $	*/
d46 1
a46 1
static char rcsid[] = "$OpenBSD: main.c,v 1.58 2003/06/18 21:08:07 espie Exp $";
d331 4
d351 1
a351 1
					    CALTYP);
d450 1
a450 1
				    CALTYP);
@


1.58
log
@- store builtin name as definition for builtin macros.
this removes the need for code->name conversion, in exchange for
systematically testing the definition type, since we can no longer
rely on the defn being NULL.

- commonnalize the builtin-detection code, so that we can use it for pushdef
as well with define, so that pushdef handles builtins correctly as well.

okay fries@@, millert@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.57 2003/06/12 14:36:43 espie Exp $	*/
d46 1
a46 1
static char rcsid[] = "$OpenBSD: main.c,v 1.57 2003/06/12 14:36:43 espie Exp $";
d210 1
a210 1
			remhash(optarg, TOP);
d320 1
a320 1
			if (p != nil)
d322 2
a323 2
			if (p == nil || (l != LPAREN && 
			    (p->type & NEEDARGS) != 0))
d330 1
a330 1
				pushf(p->type); /* type of the call  */
d336 2
a337 2
				pushs1(p->defn);	/* defn string */
				pushs1(p->name);	/* macro name  */
d531 1
a531 2
 * consider only those starting with _ or A-Za-z. This is a
 * combo with lookup to speed things up.
d541 1
a541 1
	h = *tp++ = c;
d544 1
a544 1
		h = (h << 5) + h + (*tp++ = c);
d559 1
a559 1
		return nil;
d562 1
a562 4
	for (p = hashtab[h % HASHSIZE]; p != nil; p = p->nxtptr)
		if (h == p->hv && STREQ(name, p->name))
			break;
	return p;
d575 2
a576 3
	size_t i;
	unsigned int h;
	ndptr p;
d579 1
a579 8
		h = hash(keywrds[i].knam);
		p = (ndptr) xalloc(sizeof(struct ndblock));
		p->nxtptr = hashtab[h % HASHSIZE];
		hashtab[h % HASHSIZE] = p;
		p->name = xstrdup(keywrds[i].knam);
		p->defn = xstrdup(keywrds[i].knam);
		p->hv = h;
		p->type = keywrds[i].ktyp & TYPEMASK;
d581 2
a582 1
			p->type |= NEEDARGS;
@


1.57
log
@switch from linked list to hash table for traced macros.
speeds up recent autoconf somewhat, since it traces a large set
of individual macro.

(more rework of m4 internal interfaces to unify lookup tables in order)

okay fries@@
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.56 2003/06/10 22:20:48 deraadt Exp $	*/
d46 1
a46 1
static char rcsid[] = "$OpenBSD: main.c,v 1.56 2003/06/10 22:20:48 deraadt Exp $";
d589 1
a589 1
		p->defn = null;
a606 11
}

char *
builtin_realname(int n)
{
	int i;

	for (i = 0; i != MAXKEYS; i++)
		if (((keywrds[i].ktyp ^ n) & TYPEMASK) == 0)
			return keywrds[i].knam;
	return NULL;
@


1.56
log
@mostly ansi cleanup; pval ok
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.55 2003/06/03 02:56:10 millert Exp $	*/
d46 1
a46 1
static char rcsid[] = "$OpenBSD: main.c,v 1.55 2003/06/03 02:56:10 millert Exp $";
d183 1
@


1.55
log
@Remove the advertising clause in the UCB license which Berkeley
rescinded 22 July 1999.  Proofed by myself and Theo.
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.54 2002/04/28 14:37:12 espie Exp $	*/
d46 1
a46 1
static char rcsid[] = "$OpenBSD: main.c,v 1.54 2002/04/28 14:37:12 espie Exp $";
d308 1
a308 1
macro()
d576 1
a576 1
initkwds()
d645 1
a645 1
enlarge_stack()
@


1.54
log
@Implement -s.
Triggered by recent FreeBSD changes.

- emits #line directives at every file change (like FreeBSD)
- maintains a synch_lineno variable to verify when the output gets out
of synch with the input, so that it can emit #line to re-synch as well
(unlike FreeBSD)

To do: either handle \end-of-line, or recognize when a macro expansion
is in progress, so that line synch don't perturb cpp on multi-line
expansions.

With this, we should have a fully POSIX-compliant m4.

ok miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.53 2002/04/26 16:15:16 espie Exp $	*/
d19 1
a19 5
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
d46 1
a46 1
static char rcsid[] = "$OpenBSD: main.c,v 1.53 2002/04/26 16:15:16 espie Exp $";
@


1.53
log
@use ansi function declarations. ok millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.52 2002/02/16 21:27:48 millert Exp $	*/
d50 1
a50 1
static char rcsid[] = "$OpenBSD: main.c,v 1.52 2002/02/16 21:27:48 millert Exp $";
d94 1
d170 2
d198 1
a198 1
	while ((c = getopt(argc, argv, "gt:d:D:U:o:I:")) != -1)
d221 3
d366 1
d400 1
a400 1
							putc(l, active);
d410 1
a410 1
			fputs(scommt, active);
d415 1
a415 1
					fputs(ecommt, active);
d420 1
a420 1
				putc(t, active);
d425 1
a425 1
			putc(t, active);	/* output directly..	 */
d498 1
a498 2
		while (*s)
			putc(*s++, active);
d504 28
d558 1
a558 1
				putc(c, active);
@


1.52
log
@Part one of userland __P removal.  Done with a simple regexp with some minor hand editing to make comments line up correctly.  Another pass is forthcoming that handles the cases that could not be done automatically.
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.51 2001/10/06 10:52:25 espie Exp $	*/
d50 1
a50 1
static char rcsid[] = "$OpenBSD: main.c,v 1.51 2001/10/06 10:52:25 espie Exp $";
d175 1
a175 3
main(argc,argv)
	int argc;
	char *argv[];
d280 1
a280 3
do_look_ahead(t, token)
	int	t;
	const char	*token;
d488 1
a488 2
outputstr(s)
	const char *s;
d504 1
a504 3
inspect(c, tp) 
	int c;
	char *tp;
d568 1
a568 2
builtin_type(key)
	const char *key;
d579 1
a579 2
builtin_realname(n)
	int n;
d590 1
a590 3
record(t, lev)
	struct position *t;
	int lev;
d599 1
a599 3
dump_stack(t, lev)
	struct position *t;
	int lev;
@


1.51
log
@This PUTBACK must be protected against EOF. The others are fine.
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.50 2001/09/28 12:05:38 espie Exp $	*/
d50 1
a50 1
static char rcsid[] = "$OpenBSD: main.c,v 1.50 2001/09/28 12:05:38 espie Exp $";
d162 2
a163 2
static void record __P((struct position *, int));
static void dump_stack __P((struct position *, int));
d165 4
a168 4
static void macro __P((void));
static void initkwds __P((void));
static ndptr inspect __P((int, char *));
static int do_look_ahead __P((int, const char *));
d170 1
a170 1
static void enlarge_stack __P((void));
d172 1
a172 1
int main __P((int, char *[]));
@


1.50
log
@Remove debugging scaffolding
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.49 2001/09/27 11:40:33 espie Exp $	*/
d50 1
a50 1
static char rcsid[] = "$OpenBSD: main.c,v 1.49 2001/09/27 11:40:33 espie Exp $";
d522 2
a523 1
	PUTBACK(c);
@


1.49
log
@traceon/traceoff built-ins.
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.48 2001/09/19 13:14:18 espie Exp $	*/
d50 1
a50 1
static char rcsid[] = "$OpenBSD: main.c,v 1.48 2001/09/19 13:14:18 espie Exp $";
a629 1
	fprintf(stderr, "%lu\n", (unsigned long)STACKMAX);
@


1.48
log
@inline some very common putback/chrsave. Worth roughly 10%
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.47 2001/09/18 20:59:32 espie Exp $	*/
d50 1
a50 1
static char rcsid[] = "$OpenBSD: main.c,v 1.47 2001/09/18 20:59:32 espie Exp $";
d139 2
d221 1
a221 1
			mark_traced(optarg);
@


1.47
log
@forgot to add -t handling.
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.46 2001/09/18 14:55:52 espie Exp $	*/
d50 1
a50 1
static char rcsid[] = "$OpenBSD: main.c,v 1.46 2001/09/18 14:55:52 espie Exp $";
d397 1
a397 1
							chrsave(l);
d477 1
a477 1
					chrsave(t);
d480 1
a480 1
				chrsave(t);		/* stack the char */
d498 1
a498 1
			chrsave(*s++);
d520 1
a520 1
	putback(c);
d530 1
a530 1
				chrsave(c);
@


1.46
log
@Tracing facilities. Same style as gnu-m4, because it's mostly used for
autoconf right now.
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.45 2001/09/18 14:05:14 espie Exp $	*/
d50 1
a50 1
static char rcsid[] = "$OpenBSD: main.c,v 1.45 2001/09/18 14:05:14 espie Exp $";
d217 3
@


1.45
log
@let defn(builtin) work enough so that
define(`newmacro', defn(builtin))
will work, as it should.
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.44 2001/09/18 13:52:58 espie Exp $	*/
d50 1
a50 1
static char rcsid[] = "$OpenBSD: main.c,v 1.44 2001/09/18 13:52:58 espie Exp $";
d195 1
a195 1
	while ((c = getopt(argc, argv, "gtD:U:o:I:")) != -1)
d215 3
d219 1
a219 1
                        /* XXX accept -o for compatibility  */
@


1.44
log
@One single point for all macros/builtin expansion.
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.43 2001/09/18 13:44:51 espie Exp $	*/
d50 1
a50 1
static char rcsid[] = "$OpenBSD: main.c,v 1.43 2001/09/18 13:44:51 espie Exp $";
d577 11
@


1.43
log
@8 bit clean look-ahead.
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.42 2001/09/17 08:11:13 espie Exp $	*/
d50 1
a50 1
static char rcsid[] = "$OpenBSD: main.c,v 1.42 2001/09/17 08:11:13 espie Exp $";
d339 2
a340 4
					if (CALTYP == MACRTYPE)
						expand((const char **) mstack+fp+1, 2);
					else
						eval((const char **) mstack+fp+1, 2, CALTYP);
d437 2
a438 4
				if (CALTYP == MACRTYPE)
					expand((const char **) mstack+fp+1, sp-fp);
				else
					eval((const char **) mstack+fp+1, sp-fp, CALTYP);
@


1.42
log
@Remove STATIC memory optimization. It's buggy (see regression test trip)
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.41 2001/09/16 21:12:08 espie Exp $	*/
d50 1
a50 1
static char rcsid[] = "$OpenBSD: main.c,v 1.41 2001/09/16 21:12:08 espie Exp $";
d280 1
a280 1
	assert(t == token[0]);
d284 1
a284 1
		if (t == EOF || t != *token) {
d294 3
a296 1
#define LOOK_AHEAD(t, token) ((t)==(token)[0] && do_look_ahead(t,token))
@


1.41
log
@special-case MACRO  (without parens) recognition, so that $# is set to 0
as it should.
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.40 2001/07/28 05:36:18 pvalchev Exp $	*/
d50 1
a50 1
static char rcsid[] = "$OpenBSD: main.c,v 1.40 2001/07/28 05:36:18 pvalchev Exp $";
d557 1
a557 1
		p->name = keywrds[i].knam;
d560 1
a560 1
		p->type = (keywrds[i].ktyp & TYPEMASK) | STATIC;
@


1.40
log
@Wall cleanup
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.39 2001/03/05 15:09:20 espie Exp $	*/
d50 1
a50 1
static char rcsid[] = "$OpenBSD: main.c,v 1.39 2001/03/05 15:09:20 espie Exp $";
d331 14
a344 3
				if (l != LPAREN)  {   /* add bracks  */
					putback(RPAREN);
					putback(LPAREN);
d347 1
a347 2
		}
		else if (t == EOF) {
@


1.39
log
@inspect MUST take an int to handle EOF issues correctly on unsigned char
machines.

Problem reported by naddy.
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.38 2001/03/02 00:25:24 aaron Exp $	*/
d50 1
a50 1
static char rcsid[] = "$OpenBSD: main.c,v 1.38 2001/03/02 00:25:24 aaron Exp $";
a179 1
	FILE *ifp;
@


1.38
log
@Mark -o option with XXX (we may want to implement it someday, but currently it
exists only for compatibility reasons); espie@@ ok. This issue was brought to
my attention by mpech@@prosoft.org.lv
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.37 2001/02/05 01:57:27 deraadt Exp $	*/
d50 1
a50 1
static char rcsid[] = "$OpenBSD: main.c,v 1.37 2001/02/05 01:57:27 deraadt Exp $";
d165 1
a165 1
static ndptr inspect __P((char, char *));
d495 1
a495 1
	char c;
@


1.37
log
@please alpha gcc
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.36 2000/07/27 17:44:33 espie Exp $	*/
d50 1
a50 1
static char rcsid[] = "$OpenBSD: main.c,v 1.36 2000/07/27 17:44:33 espie Exp $";
d216 3
a218 1
		case 'o':		/* specific output   */
@


1.36
log
@Handle unlimited diverts for m4 -g.

Problem with autoconf noticed by d@@
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.35 2000/07/24 23:08:25 espie Exp $	*/
d50 1
a50 1
static char rcsid[] = "$OpenBSD: main.c,v 1.35 2000/07/24 23:08:25 espie Exp $";
d602 1
a602 1
	fprintf(stderr, "%u\n", STACKMAX);
@


1.35
log
@Implement esyscmd
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.34 2000/07/02 01:17:00 espie Exp $	*/
d50 1
a50 1
static char rcsid[] = "$OpenBSD: main.c,v 1.34 2000/07/02 01:17:00 espie Exp $";
d83 2
a84 1
FILE *outfile[MAXOUT];		/* diversion array(0=bitbucket)*/
d192 4
d254 1
a254 1
	for (n = 1; n < MAXOUT; n++)	/* default wrap-up: undivert */
@


1.34
log
@Make the m4 machine stack dynamically sized.

Fix strspace automatic extension.
The assumption that simply updating the current pointer works is false,
there are cases where previous entries on the stack would absorp vast
amounts of string space, and overload the non-updated entries.

To fix it, we use a shadow copy of the stack, which only records which
entries are pointers within strspace, so that a resize can adjust all
those pointers at once.

Reviewed by millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.33 2000/07/02 01:13:07 espie Exp $	*/
d50 1
a50 1
static char rcsid[] = "$OpenBSD: main.c,v 1.33 2000/07/02 01:13:07 espie Exp $";
d120 1
@


1.33
log
@Long tokens won't be defined macros, but they can still be output.
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.32 2000/03/18 01:06:56 espie Exp $	*/
d50 1
a50 1
static char rcsid[] = "$OpenBSD: main.c,v 1.32 2000/03/18 01:06:56 espie Exp $";
d69 1
d77 3
a79 1
stae mstack[STACKMAX+1]; 	/* stack of m4 machine         */
d166 2
d185 4
d295 1
a295 1
	char token[MAXTOK];
d320 3
a322 3
				pushs(p->defn);	      /* defn string */
				pushs(p->name);	      /* macro name  */
				pushs(ep);	      /* start next..*/
d589 13
@


1.32
log
@Last needed m4 changes to bootstrap autoconf without gnu-m4.
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.31 2000/03/11 15:54:44 espie Exp $	*/
d50 1
a50 1
static char rcsid[] = "$OpenBSD: main.c,v 1.31 2000/03/11 15:54:44 espie Exp $";
a490 3
	if (tp == etp)
		errx(1, "token too long");

d492 13
@


1.31
log
@Add a few builtins for greater compatibility with gnu-m4, and extended
functionality.
* regular expressions,
* line-number reporting
* `meta'-macros, builtin and indir.

Reviewed by pjanzen@@, tested by fries@@ and a few others.
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.30 2000/02/02 14:05:22 espie Exp $	*/
d50 1
a50 1
static char rcsid[] = "$OpenBSD: main.c,v 1.30 2000/02/02 14:05:22 espie Exp $";
d181 1
a181 1
	while ((c = getopt(argc, argv, "tD:U:o:I:")) != -1)
d197 3
@


1.30
log
@Comment slightly more.
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.29 2000/02/02 14:00:12 espie Exp $	*/
d50 1
a50 1
static char rcsid[] = "$OpenBSD: main.c,v 1.29 2000/02/02 14:00:12 espie Exp $";
d112 7
d526 14
@


1.29
log
@Optimize common case.

outputstr could be called for one character-long string.

Looking at profiling output, it WAS called for one-character long strings
most of the time, like 95% of calls...

Rework logic slightly to know about that case and output the character
directly.

Worth about 10%.

Reviewed by Paul Janzen.
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.28 2000/01/15 14:26:00 espie Exp $	*/
d50 1
a50 1
static char rcsid[] = "$OpenBSD: main.c,v 1.28 2000/01/15 14:26:00 espie Exp $";
d330 4
@


1.28
log
@There is no need to waste short for holding EOF in the pushback buffer.
Now that the input_file structure is sufficiently fleshed out, just stop
EOF at the putback level, and make sure files at EOF STAY at EOF.
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.27 2000/01/13 17:35:09 espie Exp $	*/
d50 1
a50 1
static char rcsid[] = "$OpenBSD: main.c,v 1.27 2000/01/13 17:35:09 espie Exp $";
d276 1
a276 2
	char token[MAXTOK], chars[2];
	char *s;
d284 1
a284 2
			s = token;
			p = inspect(t, s);
d289 1
a289 1
				outputstr(s);
d334 2
a335 2
					nlpar--;
					s = rquote;
d338 1
a338 1
					s = lquote;
d347 6
a352 3
					chars[0] = l;
					chars[1] = EOS;
					s = chars;
a353 2
				if (nlpar > 0)
					outputstr(s);
@


1.27
log
@Record 50 levels of open parenthesis, open quotes, to give a post-mortem.
- no need to record more, as this is just for diagnosis purpose. This
doesn't affect m4's main engine.
- don't free file names as a compromise: the only other options would be
to ref count them (not worth the complexity) or dup them systematically (ick).
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.26 2000/01/12 17:49:53 espie Exp $	*/
d50 1
a50 1
static char rcsid[] = "$OpenBSD: main.c,v 1.26 2000/01/12 17:49:53 espie Exp $";
a222 1
		putback(EOF);		/* eof is a must !!	     */
d259 1
a259 2
			if (t != EOF)
				putback(t);
@


1.26
log
@Use a proper abstract interface for file accesses, so that we can record
the file name and line number.

This yields more meaningful error messages, and the possibility for yet
more.
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.25 2000/01/11 14:10:01 espie Exp $	*/
d50 1
a50 1
static char rcsid[] = "$OpenBSD: main.c,v 1.25 2000/01/11 14:10:01 espie Exp $";
d142 9
d316 5
a320 2
			if (sp > -1)
				errx(1, "unexpected end of input");
d332 2
a333 1
			nlpar = 1;
d341 1
a341 1
					nlpar++;
d345 1
a345 1
						errx(1, "missing right quote.");
d347 3
a349 1
						errx(1, "missing %d right quotes.", nlpar);
d388 1
a388 1
			PARLEV++;
d519 27
@


1.25
log
@Use the same optimization as look_ahead for inspect (don't push back char
we're going to refetch and re-test right away).
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.24 2000/01/11 14:06:11 espie Exp $	*/
d50 1
a50 1
static char rcsid[] = "$OpenBSD: main.c,v 1.24 2000/01/11 14:06:11 espie Exp $";
d79 1
a79 1
FILE *infile[MAXINP];		/* input file stack (0=stdin)  */
d195 2
a196 1
		infile[0] = stdin;	/* default input (naturally) */
d202 2
a203 2
				ifp = stdin;
			else if ((ifp = fopen_trypath(p)) == NULL)
a206 1
			infile[0] = ifp;
d208 1
a208 2
			if (ifp != stdin)
				(void)fclose(ifp);
d311 1
a311 2
			--ilevel;
			(void) fclose(infile[ilevel+1]);
@


1.24
log
@Don't recognize built-ins in contexts where they don't make sense.
Namely, it doesn't help to try and expand include if it's not followed
by parenthesis and a filename.

This should make applications like sendmail m4 scripts more sturdy for
unquoted machine names that happen to collide with built-ins.

The only drawback is that our m4 may now do intelligent things with scripts
that don't work on other systems.
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.23 2000/01/05 16:06:14 espie Exp $	*/
d50 1
a50 1
static char rcsid[] = "$OpenBSD: main.c,v 1.23 2000/01/05 16:06:14 espie Exp $";
d144 1
a144 1
static ndptr inspect __P((char *));
a278 1
			putback(t);
d280 1
a280 1
			p = inspect(s);
d453 2
a454 1
inspect(tp) 
a456 1
	char c;
d460 3
a462 1
	unsigned int h = 0;
@


1.23
log
@Close PR-1021. make unix or vms `special' macros that expand to
themselves, with the proper quotes added.

Matches gnu-m4, not Solaris nor FreeBSD... better for robustness, as
it makes for more transparent expansions.
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.22 1999/11/30 22:24:20 espie Exp $	*/
d50 1
a50 1
static char rcsid[] = "$OpenBSD: main.c,v 1.22 1999/11/30 22:24:20 espie Exp $";
d96 1
a96 1
	{ "divert",       DIVRTYPE },
d105 3
a107 3
	{ "dnl",          DNLNTYPE },
	{ "changequote",  CHNQTYPE },
	{ "changecom",    CHNCTYPE },
d115 2
a116 2
	{ "dumpdef",      DUMPTYPE },
	{ "shift",        SHIFTYPE },
d119 2
a120 2
	{ "undivert",     UNDVTYPE },
	{ "divnum",       DIVNTYPE },
d122 3
a124 3
	{ "errprint",     ERRPTYPE },
	{ "m4wrap",       M4WRTYPE },
	{ "m4exit",       EXITTYPE },
d126 1
a126 1
	{ "sysval",       SYSVTYPE },
d128 2
a129 2
#if defined(unix) || defined(__unix__)
	{ "unix",         SELFTYPE },
d132 1
a132 1
	{ "vms",          SELFTYPE },
d281 6
a286 8
			if ((p = inspect(s)) == nil) {
				if (sp < 0)
					while (*s)
						putc(*s++, active);
				else
					while (*s)
						chrsave(*s++);
			}
a301 1
				putback(l = gpbc());
d343 2
a344 8
				if (nlpar > 0) {
					if (sp < 0)
						while (*s)
							putc(*s++, active);
					else
						while (*s)
							chrsave(*s++);
				}
d433 15
d499 3
a501 1
		p->type = keywrds[i].ktyp | STATIC;
@


1.22
log
@Recognizes comments while parsing macros arguments, as every other
m4 implementation does (including DEC/OSF, Solaris, HP/UX, Aix,
and gnu-m4).

Checked with millert@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.20 1999/11/25 00:54:22 millert Exp $	*/
d50 1
a50 1
static char rcsid[] = "$OpenBSD: main.c,v 1.20 1999/11/25 00:54:22 millert Exp $";
d128 2
a129 2
#if defined(unix) || defined(__NetBSD__) || defined(__OpenBSD__)
	{ "unix",         MACRTYPE },
d132 1
a132 1
	{ "vms",          MACRTYPE },
@


1.21
log
@Clean up comment/quote recognition a little bit:
- use strlcpy to make clear that the strings are line terminated,
- remove the number of magic constants,
- use assert() for preconditions,
- use puts instead of looping over array of chars...
@
text
@d420 17
a436 1
			chrsave(t);			/* stack the char */
@


1.20
log
@From espie@@openbsd.org:
 o Add a missing 'unsigned' to 'h' in remhash()
 o Say 'unsigned int' not just 'unsigned'
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.19 1999/11/20 17:48:59 espie Exp $	*/
d50 1
a50 1
static char rcsid[] = "$OpenBSD: main.c,v 1.19 1999/11/20 17:48:59 espie Exp $";
d61 1
d234 1
a234 1
 * Look ahead (at most MAXCCHARS characters) for `token'.
d247 1
a247 2
	if (t != token[0])
		errx(1, "internal error");
d359 1
a359 3
			int i;
			for (i = 0; i < MAXCCHARS && scommt[i]; i++)
				putc(scommt[i], active);
d364 1
a364 3
					for (i = 0; i < MAXCCHARS && ecommt[i];
					     i++)
						putc(ecommt[i], active);
@


1.19
log
@Optimization: cache the hashed value to avoid negative comparisons.
With 2^32 possible hash values, this means that collisions no longer
incur supplementary string compares, which was most of the reason for
STREQ in the first place...
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.18 1999/11/17 15:34:13 espie Exp $	*/
d50 1
a50 1
static char rcsid[] = "$OpenBSD: main.c,v 1.18 1999/11/17 15:34:13 espie Exp $";
d443 1
a443 1
	unsigned h = 0;
d470 1
a470 1
	unsigned h;
@


1.18
log
@Turn warnings on,
Add missing prototypes,
Make local functions static,
Sort extern.h by file,
Constify all char * that can be,
Copy temp file name so that eval does not modify its arguments.
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.17 1999/09/14 08:35:16 espie Exp $	*/
d50 1
a50 1
static char rcsid[] = "$OpenBSD: main.c,v 1.17 1999/09/14 08:35:16 espie Exp $";
d443 1
a443 1
	unsigned long h = 0;
d453 2
a454 2
	for (p = hashtab[h%HASHSIZE]; p != nil; p = p->nxtptr)
		if (STREQ(name, p->name))
d470 1
a470 1
	int h;
d476 2
a477 2
		p->nxtptr = hashtab[h];
		hashtab[h] = p;
d480 1
@


1.17
log
@Style: kill register and indent properly.
Let indx match netbsd flavor, to simplify diffs.
Show how many quotes were not closed.
Increase stack slightly, now that we're no longer bound by argspace.
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.14 1999/09/06 13:29:32 espie Exp $	*/
d50 1
a50 1
static char rcsid[] = "$OpenBSD: main.c,v 1.14 1999/09/06 13:29:32 espie Exp $";
d141 6
a146 2
void macro();
void initkwds();
a231 2
ndptr inspect();

d239 1
a239 1
int
d242 1
a242 1
	char	*token;
d267 1
a267 1
void
d402 1
a402 1
					expand((char **) mstack+fp+1, sp-fp);
d404 1
a404 1
					eval((char **) mstack+fp+1, sp-fp, CALTYP);
d435 1
a435 1
ndptr
d466 1
a466 1
void
@


1.16
log
@-I works better when activated...

Fuss with prototypes.
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.15 1999/09/14 08:21:37 espie Exp $	*/
d50 1
a50 1
static char rcsid[] = "$OpenBSD: main.c,v 1.15 1999/09/14 08:21:37 espie Exp $";
d149 2
a150 2
	register int c;
	register int n;
d152 1
a152 1
	register FILE *ifp;
d266 2
a267 1
macro() {
d269 4
a272 4
	register char *s;
	register int t, l;
	register ndptr p;
	register int  nlpar;
d334 6
a339 3
				} else if (l == EOF)
					errx(1, "missing right quote");
				else {
d435 1
a435 1
register char *tp;
d437 5
a441 5
	register char c;
	register char *name = tp;
	register char *etp = tp+MAXTOK;
	register ndptr p;
	register unsigned long h = 0;
d461 1
a461 1
 * keyword strings, since we simply use the static  pointers
d465 5
a469 4
initkwds() {
	register int i;
	register int h;
	register ndptr p;
d481 1
@


1.15
log
@Implement -I option and M4PATH environment variable
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.14 1999/09/06 13:29:32 espie Exp $	*/
d50 1
a50 1
static char rcsid[] = "$OpenBSD: main.c,v 1.14 1999/09/06 13:29:32 espie Exp $";
a142 1
extern int getopt();
d160 1
a160 1
	while ((c = getopt(argc, argv, "tD:U:o:")) != -1)
d170 3
@


1.14
log
@Remove STRSPACE limitations.
A bit wasteful, but not too intrusive.

Also remove pushback buffer limitations, as this would be mostly useless
otherwise.

Incidentally, pushback buffer overflow detection in pbstr was wrong.
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.10 1998/06/02 20:46:40 deraadt Exp $	*/
d50 1
a50 1
static char rcsid[] = "$OpenBSD: main.c,v 1.10 1998/06/02 20:46:40 deraadt Exp $";
d195 1
a195 1
			else if ((ifp = fopen(p, "r")) == NULL)
@


1.13
log
@Use EOS pervasively.
@
text
@a74 5
pbent buf[BUFSIZE];		/* push-back buffer	       */
pbent *bufbase = buf;		/* the base for current ilevel */
pbent *bbase[MAXINP];		/* the base for each ilevel    */
pbent *bp = buf; 		/* first available character   */
pbent *endpbb = buf+BUFSIZE;	/* end of push-back buffer     */
a75 3
char strspace[STRSPMAX+1];	/* string space for evaluation */
char *ep = strspace;		/* first free char in strspace */
char *endest= strspace+STRSPMAX;/* end of string space	       */
d159 1
@


1.12
log
@Get rid of mktemp in the handling of diversion.

Simply put, mkstemp/unlink/rewind has the proper semantics under Unix,
and so we don't have to keep track about temp file names and remove them.
@
text
@d67 1
d200 1
a200 1
			if (p[0] == '-' && p[1] == '\0')
d342 1
a342 1
					chars[1] = '\0';
@


1.11
log
@Misc minor changes:
- use err.h and kill oops,
- use __progname and kill basename,
- let indx use strstr
- proper EOS decl
@
text
@a87 1
char *m4temp;			/* filename for diversions     */
a189 3
					/* filename for diversions   */
	m4temp = mktemp(xstrdup(_PATH_DIVNAME));

a226 6
		m4temp[UNIQUE] = '0';
#ifdef vms
		(void) remove(m4temp);
#else
		(void) unlink(m4temp);
#endif
@


1.10
log
@no, the code is correct as it is, and you did the wrong thing based on a gcc warning
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.9 1998/06/02 15:05:02 mickey Exp $	*/
d50 1
a50 1
static char rcsid[] = "$OpenBSD: main.c,v 1.9 1998/06/02 15:05:02 mickey Exp $";
d67 1
a92 1
char *progname;			/* name of this program        */
a162 2
	progname = basename(argv[0]);

d206 1
a206 1
				oops("%s: %s", p, strerror(errno));
d259 1
a259 1
		oops("internal error", "");
d324 1
a324 1
				oops("unexpected end of input", "");
d348 1
a348 1
					oops("missing right quote", "");
d407 1
a407 1
					oops("internal stack overflow", "");
d457 1
a457 1
		oops("token too long", "");
@


1.9
log
@shut up -Wall
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.8 1998/04/25 18:47:20 millert Exp $	*/
d50 1
a50 1
static char rcsid[] = "$OpenBSD: main.c,v 1.8 1998/04/25 18:47:20 millert Exp $";
a290 1
		s = token;
d293 1
@


1.8
log
@-Wall
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.7 1997/12/20 15:39:14 deraadt Exp $	*/
d50 1
a50 1
static char rcsid[] = "$OpenBSD: main.c,v 1.7 1997/12/20 15:39:14 deraadt Exp $";
d291 1
d294 1
a294 1
			if ((p = inspect(s = token)) == nil) {
@


1.7
log
@Simplify some push-back code (e.g. for left and right quotes) so that
it uses pbstr() instead of doing the characters individually (in
reverse order) with putback(); cgd
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.6 1997/12/10 20:24:15 deraadt Exp $	*/
d50 1
a50 1
static char rcsid[] = "$OpenBSD: main.c,v 1.6 1997/12/10 20:24:15 deraadt Exp $";
d99 17
a115 17
	"include",      INCLTYPE,
	"sinclude",     SINCTYPE,
	"define",       DEFITYPE,
	"defn",         DEFNTYPE,
	"divert",       DIVRTYPE,
	"expr",         EXPRTYPE,
	"eval",         EXPRTYPE,
	"substr",       SUBSTYPE,
	"ifelse",       IFELTYPE,
	"ifdef",        IFDFTYPE,
	"len",          LENGTYPE,
	"incr",         INCRTYPE,
	"decr",         DECRTYPE,
	"dnl",          DNLNTYPE,
	"changequote",  CHNQTYPE,
	"changecom",    CHNCTYPE,
	"index",        INDXTYPE,
d117 2
a118 2
	"paste",        PASTTYPE,
	"spaste",       SPASTYPE,
d120 14
a133 14
	"popdef",       POPDTYPE,
	"pushdef",      PUSDTYPE,
	"dumpdef",      DUMPTYPE,
	"shift",        SHIFTYPE,
	"translit",     TRNLTYPE,
	"undefine",     UNDFTYPE,
	"undivert",     UNDVTYPE,
	"divnum",       DIVNTYPE,
	"maketemp",     MKTMTYPE,
	"errprint",     ERRPTYPE,
	"m4wrap",       M4WRTYPE,
	"m4exit",       EXITTYPE,
	"syscmd",       SYSCTYPE,
	"sysval",       SYSVTYPE,
d136 1
a136 1
	"unix",         MACRTYPE,
d139 1
a139 1
	"vms",          MACRTYPE,
@


1.6
log
@cgd: add a typedef which describes elements in the push-back buffer.  Make
that typedef 'short'.  'char' (which was previously used) because char
may be unsigned and ((char)EOF) != EOF if that is the case.  That was
causing the (char)EOF (0xff) pushed back in main to be interepreted as
a character, and, in some cases, to be written to the output.  'short'
was used rather than 'signed char' because if the latter is used,
0xff characters in the input would confuse m4.  (No point in introducing
(more?) 8-bit lossage.)
@
text
@d1 2
a2 2
/*	$OpenBSD: main.c,v 1.5 1997/01/15 23:42:49 millert Exp $	*/
/*	$NetBSD: main.c,v 1.11 1996/01/13 23:25:26 pk Exp $	*/
d50 1
a50 1
static char rcsid[] = "$OpenBSD: main.c,v 1.5 1997/01/15 23:42:49 millert Exp $";
d283 1
a283 1
	char token[MAXTOK];
d334 1
a334 1
	 * non-alpha single-char token seen..
d340 1
d342 1
a342 1
				if (LOOK_AHEAD(l,rquote))
d344 2
a345 1
				else if (LOOK_AHEAD(l,lquote))
d347 2
a348 1
				else if (l == EOF)
d350 5
d357 2
a358 1
						putc(l, active);
d360 2
a361 1
						chrsave(l);
@


1.5
log
@getopt(3) returns -1 when out of args, not EOF, whee!
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.4 1996/08/22 00:35:01 deraadt Exp $	*/
d50 1
a50 1
static char rcsid[] = "$OpenBSD: main.c,v 1.4 1996/08/22 00:35:01 deraadt Exp $";
d73 5
a77 5
char buf[BUFSIZE];		/* push-back buffer	       */
char *bufbase = buf;		/* the base for current ilevel */
char *bbase[MAXINP];		/* the base for each ilevel    */
char *bp = buf; 		/* first available character   */
char *endpbb = buf+BUFSIZE;	/* end of push-back buffer     */
@


1.4
log
@__OpenBSD__
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.3 1996/06/26 05:36:14 deraadt Exp $	*/
d50 1
a50 1
static char rcsid[] = "$OpenBSD: main.c,v 1.3 1996/06/26 05:36:14 deraadt Exp $";
d170 1
a170 1
	while ((c = getopt(argc, argv, "tD:U:o:")) != EOF)
@


1.3
log
@rcsid
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.11 1996/01/13 23:25:26 pk Exp $	*/
d50 1
a50 1
static char rcsid[] = "$OpenBSD: main.c,v 1.11 1996/01/13 23:25:26 pk Exp $";
d135 1
a135 1
#if defined(unix) || defined(__NetBSD__)
@


1.2
log
@from netbsd:
Handle multichar comment and quote delimiters (up to 5 characters, per the
manual page). Takes care of PR#485.
@
text
@d1 1
d50 1
a50 1
static char rcsid[] = "$NetBSD: main.c,v 1.11 1996/01/13 23:25:26 pk Exp $";
@


1.1
log
@Initial revision
@
text
@d1 1
a1 1
/*	$NetBSD: main.c,v 1.10 1995/09/29 00:27:51 cgd Exp $	*/
d49 1
a49 1
static char rcsid[] = "$NetBSD: main.c,v 1.10 1995/09/29 00:27:51 cgd Exp $";
d92 4
a95 4
char lquote = LQUOTE;		/* left quote character  (`)   */
char rquote = RQUOTE;		/* right quote character (')   */
char scommt = SCOMMT;		/* start character for comment */
char ecommt = ECOMMT;		/* end character for comment   */
d246 32
d289 2
a290 1
		if ((t = gpbc()) == '_' || isalpha(t)) {
d336 1
a336 1
		else if (t == lquote) { 		/* strip quotes */
d339 2
a340 1
				if ((l = gpbc()) == rquote)
d342 1
a342 1
				else if (l == lquote)
d356 15
a370 2
		else if (sp < 0) {		/* not in a macro at all */
			if (t == scommt) {	/* comment handling here */
a371 2
				while ((t = gpbc()) != ecommt)
					putc(t, active);
d373 3
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@
