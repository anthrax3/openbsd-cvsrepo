head	1.65;
access;
symbols
	OPENBSD_6_1_BASE:1.65
	OPENBSD_6_0:1.65.0.2
	OPENBSD_6_0_BASE:1.65
	OPENBSD_5_9:1.63.0.2
	OPENBSD_5_9_BASE:1.63
	OPENBSD_5_8:1.62.0.4
	OPENBSD_5_8_BASE:1.62
	OPENBSD_5_7:1.58.0.2
	OPENBSD_5_7_BASE:1.58
	OPENBSD_5_6:1.57.0.4
	OPENBSD_5_6_BASE:1.57
	OPENBSD_5_5:1.56.0.4
	OPENBSD_5_5_BASE:1.56
	OPENBSD_5_4:1.54.0.2
	OPENBSD_5_4_BASE:1.54
	OPENBSD_5_3:1.53.0.2
	OPENBSD_5_3_BASE:1.53
	OPENBSD_5_2:1.51.0.2
	OPENBSD_5_2_BASE:1.51
	OPENBSD_5_1_BASE:1.49
	OPENBSD_5_1:1.49.0.10
	OPENBSD_5_0:1.49.0.8
	OPENBSD_5_0_BASE:1.49
	OPENBSD_4_9:1.49.0.6
	OPENBSD_4_9_BASE:1.49
	OPENBSD_4_8:1.49.0.4
	OPENBSD_4_8_BASE:1.49
	OPENBSD_4_7:1.49.0.2
	OPENBSD_4_7_BASE:1.49
	OPENBSD_4_6:1.48.0.4
	OPENBSD_4_6_BASE:1.48
	OPENBSD_4_5:1.47.0.6
	OPENBSD_4_5_BASE:1.47
	OPENBSD_4_4:1.47.0.4
	OPENBSD_4_4_BASE:1.47
	OPENBSD_4_3:1.47.0.2
	OPENBSD_4_3_BASE:1.47
	OPENBSD_4_2:1.46.0.2
	OPENBSD_4_2_BASE:1.46
	OPENBSD_4_1:1.43.0.6
	OPENBSD_4_1_BASE:1.43
	OPENBSD_4_0:1.43.0.4
	OPENBSD_4_0_BASE:1.43
	OPENBSD_3_9:1.43.0.2
	OPENBSD_3_9_BASE:1.43
	OPENBSD_3_8:1.42.0.4
	OPENBSD_3_8_BASE:1.42
	OPENBSD_3_7:1.42.0.2
	OPENBSD_3_7_BASE:1.42
	OPENBSD_3_6:1.41.0.2
	OPENBSD_3_6_BASE:1.41
	OPENBSD_3_5:1.40.0.2
	OPENBSD_3_5_BASE:1.40
	OPENBSD_3_4:1.36.0.2
	OPENBSD_3_4_BASE:1.36
	OPENBSD_3_3:1.31.0.6
	OPENBSD_3_3_BASE:1.31
	OPENBSD_3_2:1.31.0.4
	OPENBSD_3_2_BASE:1.31
	OPENBSD_3_1:1.31.0.2
	OPENBSD_3_1_BASE:1.31
	OPENBSD_3_0:1.28.0.2
	OPENBSD_3_0_BASE:1.28
	OPENBSD_2_9_BASE:1.25
	OPENBSD_2_9:1.25.0.2
	OPENBSD_2_8:1.24.0.2
	OPENBSD_2_8_BASE:1.24
	OPENBSD_2_7:1.22.0.4
	OPENBSD_2_7_BASE:1.22
	OPENBSD_2_6:1.22.0.2
	OPENBSD_2_6_BASE:1.22
	OPENBSD_2_5:1.20.0.2
	OPENBSD_2_5_BASE:1.20
	OPENBSD_2_4:1.16.0.2
	OPENBSD_2_4_BASE:1.16
	OPENBSD_2_3:1.15.0.2
	OPENBSD_2_3_BASE:1.15
	OPENBSD_2_2:1.14.0.2
	OPENBSD_2_2_BASE:1.14
	OPENBSD_2_1:1.13.0.2
	OPENBSD_2_1_BASE:1.13
	OPENBSD_2_0:1.8.0.2
	OPENBSD_2_0_BASE:1.8
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.65
date	2016.05.13.17.51.15;	author jmc;	state Exp;
branches;
next	1.64;
commitid	3X1R1WazYXZC82XJ;

1.64
date	2016.05.12.21.43.27;	author millert;	state Exp;
branches;
next	1.63;
commitid	5e4gSGDGmRJFDxNb;

1.63
date	2015.12.31.16.16.54;	author millert;	state Exp;
branches;
next	1.62;
commitid	ANO84nmRwRUYPvOF;

1.62
date	2015.07.19.18.27.26;	author jasper;	state Exp;
branches;
next	1.61;
commitid	GWju3qKiix1Ns0H6;

1.61
date	2015.07.18.15.42.37;	author jasper;	state Exp;
branches;
next	1.60;
commitid	xNRagLTS7lfdjYuk;

1.60
date	2015.07.18.14.32.36;	author jasper;	state Exp;
branches;
next	1.59;
commitid	ACP5Xz7CSvljq6JZ;

1.59
date	2015.04.18.03.15.46;	author guenther;	state Exp;
branches;
next	1.58;
commitid	F8BnZzbIun3RubPZ;

1.58
date	2015.01.16.06.40.15;	author deraadt;	state Exp;
branches;
next	1.57;
commitid	Uu5nFG3wCl0LACBb;

1.57
date	2014.05.20.01.25.23;	author guenther;	state Exp;
branches;
next	1.56;

1.56
date	2013.11.27.13.32.02;	author okan;	state Exp;
branches;
next	1.55;

1.55
date	2013.11.26.21.08.10;	author deraadt;	state Exp;
branches;
next	1.54;

1.54
date	2013.06.02.01.41.23;	author naddy;	state Exp;
branches;
next	1.53;

1.53
date	2013.02.18.22.15.11;	author miod;	state Exp;
branches;
next	1.52;

1.52
date	2012.09.14.00.00.29;	author millert;	state Exp;
branches;
next	1.51;

1.51
date	2012.04.11.14.19.35;	author millert;	state Exp;
branches;
next	1.50;

1.50
date	2012.04.11.09.27.42;	author espie;	state Exp;
branches;
next	1.49;

1.49
date	2009.10.27.23.59.50;	author deraadt;	state Exp;
branches;
next	1.48;

1.48
date	2009.03.27.07.31.27;	author phessler;	state Exp;
branches;
next	1.47;

1.47
date	2007.09.05.08.58.34;	author jsg;	state Exp;
branches;
next	1.46;

1.46
date	2007.08.06.19.16.06;	author sobrado;	state Exp;
branches;
next	1.45;

1.45
date	2007.05.25.20.32.29;	author krw;	state Exp;
branches;
next	1.44;

1.44
date	2007.05.16.17.33.07;	author moritz;	state Exp;
branches;
next	1.43;

1.43
date	2006.01.10.00.30.08;	author millert;	state Exp;
branches;
next	1.42;

1.42
date	2004.10.04.05.21.27;	author jsg;	state Exp;
branches;
next	1.41;

1.41
date	2004.07.01.18.25.48;	author otto;	state Exp;
branches;
next	1.40;

1.40
date	2004.02.10.07.33.23;	author jmc;	state Exp;
branches;
next	1.39;

1.39
date	2003.11.22.14.17.32;	author mickey;	state Exp;
branches;
next	1.38;

1.38
date	2003.11.22.13.40.28;	author grange;	state Exp;
branches;
next	1.37;

1.37
date	2003.11.21.20.53.42;	author mickey;	state Exp;
branches;
next	1.36;

1.36
date	2003.07.02.00.21.17;	author avsm;	state Exp;
branches;
next	1.35;

1.35
date	2003.06.10.22.20.54;	author deraadt;	state Exp;
branches;
next	1.34;

1.34
date	2003.06.03.02.56.24;	author millert;	state Exp;
branches;
next	1.33;

1.33
date	2003.05.11.18.18.33;	author tedu;	state Exp;
branches;
next	1.32;

1.32
date	2003.05.07.22.38.06;	author millert;	state Exp;
branches;
next	1.31;

1.31
date	2002.02.16.21.27.59;	author millert;	state Exp;
branches;
next	1.30;

1.30
date	2002.01.24.23.01.19;	author millert;	state Exp;
branches;
next	1.29;

1.29
date	2001.11.19.19.02.18;	author mpech;	state Exp;
branches;
next	1.28;

1.28
date	2001.08.25.19.52.05;	author heko;	state Exp;
branches;
next	1.27;

1.27
date	2001.07.09.07.04.58;	author deraadt;	state Exp;
branches;
next	1.26;

1.26
date	2001.06.23.23.09.31;	author millert;	state Exp;
branches;
next	1.25;

1.25
date	2000.12.22.11.53.17;	author jj;	state Exp;
branches;
next	1.24;

1.24
date	2000.10.12.10.22.20;	author art;	state Exp;
branches;
next	1.23;

1.23
date	2000.07.19.19.29.16;	author mickey;	state Exp;
branches;
next	1.22;

1.22
date	99.08.04.18.24.09;	author mickey;	state Exp;
branches;
next	1.21;

1.21
date	99.05.29.20.17.35;	author millert;	state Exp;
branches;
next	1.20;

1.20
date	99.03.03.01.03.51;	author millert;	state Exp;
branches;
next	1.19;

1.19
date	99.01.26.04.09.35;	author millert;	state Exp;
branches;
next	1.18;

1.18
date	98.12.17.17.19.49;	author millert;	state Exp;
branches;
next	1.17;

1.17
date	98.12.16.19.55.57;	author millert;	state Exp;
branches;
next	1.16;

1.16
date	98.09.26.09.04.43;	author deraadt;	state Exp;
branches;
next	1.15;

1.15
date	97.12.01.21.17.28;	author chuck;	state Exp;
branches;
next	1.14;

1.14
date	97.06.04.05.56.26;	author millert;	state Exp;
branches;
next	1.13;

1.13
date	97.04.17.19.13.58;	author millert;	state Exp;
branches;
next	1.12;

1.12
date	97.03.07.01.57.08;	author millert;	state Exp;
branches;
next	1.11;

1.11
date	97.01.17.07.13.54;	author millert;	state Exp;
branches;
next	1.10;

1.10
date	97.01.15.23.43.41;	author millert;	state Exp;
branches;
next	1.9;

1.9
date	96.12.06.02.14.56;	author deraadt;	state Exp;
branches;
next	1.8;

1.8
date	96.09.22.20.17.54;	author imp;	state Exp;
branches;
next	1.7;

1.7
date	96.08.18.22.08.31;	author millert;	state Exp;
branches;
next	1.6;

1.6
date	96.08.14.16.23.55;	author millert;	state Exp;
branches;
next	1.5;

1.5
date	96.08.08.20.49.26;	author millert;	state Exp;
branches;
next	1.4;

1.4
date	96.08.05.01.18.42;	author millert;	state Exp;
branches;
next	1.3;

1.3
date	96.06.26.05.44.05;	author deraadt;	state Exp;
branches;
next	1.2;

1.2
date	95.12.21.14.47.09;	author deraadt;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.47.00;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.47.00;	author deraadt;	state Exp;
branches;
next	;


desc
@@


1.65
log
@spelling and usage() fixes;
@
text
@/*	$OpenBSD: xinstall.c,v 1.64 2016/05/12 21:43:27 millert Exp $	*/
/*	$NetBSD: xinstall.c,v 1.9 1995/12/20 10:25:17 jonathan Exp $	*/

/*
 * Copyright (c) 1987, 1993
 *	The Regents of the University of California.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */

#include <sys/param.h>	/* MAXBSIZE */
#include <sys/wait.h>
#include <sys/mman.h>
#include <sys/stat.h>

#include <ctype.h>
#include <err.h>
#include <errno.h>
#include <fcntl.h>
#include <grp.h>
#include <paths.h>
#include <pwd.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <limits.h>
#include <utime.h>
#include <libgen.h>

#include "pathnames.h"

#define MINIMUM(a, b)	(((a) < (b)) ? (a) : (b))

#define	DIRECTORY	0x01		/* Tell install it's a directory. */
#define	SETFLAGS	0x02		/* Tell install to set flags. */
#define	USEFSYNC	0x04		/* Tell install to use fsync(2). */
#define NOCHANGEBITS	(UF_IMMUTABLE | UF_APPEND | SF_IMMUTABLE | SF_APPEND)
#define BACKUP_SUFFIX	".old"

struct passwd *pp;
struct group *gp;
int dobackup, docompare, dodest, dodir, dopreserve, dostrip, safecopy;
int mode = S_IRWXU|S_IRGRP|S_IXGRP|S_IROTH|S_IXOTH;
char pathbuf[PATH_MAX], tempfile[PATH_MAX];
char *suffix = BACKUP_SUFFIX;
uid_t uid;
gid_t gid;

void	copy(int, char *, int, char *, off_t, int);
int	compare(int, const char *, off_t, int, const char *, off_t);
void	install(char *, char *, u_long, u_int);
void	install_dir(char *, int);
void	strip(char *);
void	usage(void);
int	create_newfile(char *, struct stat *);
int	create_tempfile(char *, char *, size_t);
int	file_write(int, char *, size_t, int *, int *, int);
void	file_flush(int, int);

int
main(int argc, char *argv[])
{
	struct stat from_sb, to_sb;
	void *set;
	u_int32_t fset;
	u_int iflags;
	int ch, no_target;
	char *flags, *to_name, *group = NULL, *owner = NULL;

	iflags = 0;
	while ((ch = getopt(argc, argv, "B:bCcDdFf:g:m:o:pSs")) != -1)
		switch(ch) {
		case 'C':
			docompare = 1;
			break;
		case 'B':
			suffix = optarg;
			/* fall through; -B implies -b */
		case 'b':
			dobackup = 1;
			break;
		case 'c':
			/* For backwards compatibility. */
			break;
		case 'F':
			iflags |= USEFSYNC;
			break;
		case 'f':
			flags = optarg;
			if (strtofflags(&flags, &fset, NULL))
				errx(1, "%s: invalid flag", flags);
			iflags |= SETFLAGS;
			break;
		case 'g':
			group = optarg;
			break;
		case 'm':
			if (!(set = setmode(optarg)))
				errx(1, "%s: invalid file mode", optarg);
			mode = getmode(set, 0);
			free(set);
			break;
		case 'o':
			owner = optarg;
			break;
		case 'p':
			docompare = dopreserve = 1;
			break;
		case 'S':
			safecopy = 1;
			break;
		case 's':
			dostrip = 1;
			break;
		case 'D':
			dodest = 1;
			break;
		case 'd':
			dodir = 1;
			break;
		case '?':
		default:
			usage();
		}
	argc -= optind;
	argv += optind;

	/* some options make no sense when creating directories */
	if ((safecopy || docompare || dostrip) && dodir)
		usage();

	/* must have at least two arguments, except when creating directories */
	if (argc < 2 && !dodir)
		usage();

	/* need to make a temp copy so we can compare stripped version */
	if (docompare && dostrip)
		safecopy = 1;

	/* get group and owner id's */
	if (group && !(gp = getgrnam(group)) && !isdigit((unsigned char)*group))
		errx(1, "unknown group %s", group);
	gid = (group) ? ((gp) ? gp->gr_gid : (gid_t)strtoul(group, NULL, 10)) : (gid_t)-1;
	if (owner && !(pp = getpwnam(owner)) && !isdigit((unsigned char)*owner))
		errx(1, "unknown user %s", owner);
	uid = (owner) ? ((pp) ? pp->pw_uid : (uid_t)strtoul(owner, NULL, 10)) : (uid_t)-1;

	if (dodir) {
		for (; *argv != NULL; ++argv)
			install_dir(*argv, mode);
		exit(0);
		/* NOTREACHED */
	}

	if (dodest) {
		char *dest = dirname(argv[argc - 1]);
		if (dest == NULL)
			errx(1, "cannot determine dirname");
		/*
		 * When -D is passed, do not chmod the directory with the mode set for
		 * the target file. If more restrictive permissions are required then
		 * '-d -m' ought to be used instead.
		 */
		install_dir(dest, 0755);
	}

	no_target = stat(to_name = argv[argc - 1], &to_sb);
	if (!no_target && S_ISDIR(to_sb.st_mode)) {
		for (; *argv != to_name; ++argv)
			install(*argv, to_name, fset, iflags | DIRECTORY);
		exit(0);
		/* NOTREACHED */
	}

	/* can't do file1 file2 directory/file */
	if (argc != 2)
		errx(1, "Target: %s", argv[argc-1]);

	if (!no_target) {
		if (stat(*argv, &from_sb))
			err(1, "%s", *argv);
		if (!S_ISREG(to_sb.st_mode))
			errc(1, EFTYPE, "%s", to_name);
		if (to_sb.st_dev == from_sb.st_dev &&
		    to_sb.st_ino == from_sb.st_ino)
			errx(1, "%s and %s are the same file", *argv, to_name);
	}
	install(*argv, to_name, fset, iflags);
	exit(0);
	/* NOTREACHED */
}

/*
 * install --
 *	build a path name and install the file
 */
void
install(char *from_name, char *to_name, u_long fset, u_int flags)
{
	struct stat from_sb, to_sb;
	struct timespec ts[2];
	int devnull, from_fd, to_fd, serrno, files_match = 0;
	char *p;

	(void)memset((void *)&from_sb, 0, sizeof(from_sb));
	(void)memset((void *)&to_sb, 0, sizeof(to_sb));

	/* If try to install NULL file to a directory, fails. */
	if (flags & DIRECTORY || strcmp(from_name, _PATH_DEVNULL)) {
		if (stat(from_name, &from_sb))
			err(1, "%s", from_name);
		if (!S_ISREG(from_sb.st_mode))
			errc(1, EFTYPE, "%s", from_name);
		/* Build the target path. */
		if (flags & DIRECTORY) {
			(void)snprintf(pathbuf, sizeof(pathbuf), "%s/%s",
			    to_name,
			    (p = strrchr(from_name, '/')) ? ++p : from_name);
			to_name = pathbuf;
		}
		devnull = 0;
	} else {
		devnull = 1;
	}

	if (stat(to_name, &to_sb) == 0) {
		/* Only compare against regular files. */
		if (docompare && !S_ISREG(to_sb.st_mode)) {
			docompare = 0;
			warnc(EFTYPE, "%s", to_name);
		}
	} else if (docompare) {
		/* File does not exist so silently ignore compare flag. */
		docompare = 0;
	}

	if (!devnull) {
		if ((from_fd = open(from_name, O_RDONLY, 0)) < 0)
			err(1, "%s", from_name);
	}

	if (safecopy) {
		to_fd = create_tempfile(to_name, tempfile, sizeof(tempfile));
		if (to_fd < 0)
			err(1, "%s", tempfile);
	} else if (docompare && !dostrip) {
		if ((to_fd = open(to_name, O_RDONLY, 0)) < 0)
			err(1, "%s", to_name);
	} else {
		if ((to_fd = create_newfile(to_name, &to_sb)) < 0)
			err(1, "%s", to_name);
	}

	if (!devnull) {
		if (docompare && !safecopy) {
			files_match = !(compare(from_fd, from_name,
					from_sb.st_size, to_fd,
					to_name, to_sb.st_size));

			/* Truncate "to" file for copy unless we match */
			if (!files_match) {
				(void)close(to_fd);
				if ((to_fd = create_newfile(to_name, &to_sb)) < 0)
					err(1, "%s", to_name);
			}
		}
		if (!files_match)
			copy(from_fd, from_name, to_fd,
			     safecopy ? tempfile : to_name, from_sb.st_size,
			     ((off_t)from_sb.st_blocks * S_BLKSIZE < from_sb.st_size));
	}

	if (dostrip) {
		strip(safecopy ? tempfile : to_name);

		/*
		 * Re-open our fd on the target, in case we used a strip
		 *  that does not work in-place -- like gnu binutils strip.
		 */
		close(to_fd);
		if ((to_fd = open(safecopy ? tempfile : to_name, O_RDONLY,
		     0)) < 0)
			err(1, "stripping %s", to_name);
	}

	/*
	 * Compare the (possibly stripped) temp file to the target.
	 */
	if (safecopy && docompare) {
		int temp_fd = to_fd;
		struct stat temp_sb;

		/* Re-open to_fd using the real target name. */
		if ((to_fd = open(to_name, O_RDONLY, 0)) < 0)
			err(1, "%s", to_name);

		if (fstat(temp_fd, &temp_sb)) {
			serrno = errno;
			(void)unlink(tempfile);
			errc(1, serrno, "%s", tempfile);
		}

		if (compare(temp_fd, tempfile, temp_sb.st_size, to_fd,
			    to_name, to_sb.st_size) == 0) {
			/*
			 * If target has more than one link we need to
			 * replace it in order to snap the extra links.
			 * Need to preserve target file times, though.
			 */
			if (to_sb.st_nlink != 1) {
				ts[0] = to_sb.st_atim;
				ts[1] = to_sb.st_mtim;
				futimens(temp_fd, ts);
			} else {
				files_match = 1;
				(void)unlink(tempfile);
			}
		}
		(void)close(to_fd);
		to_fd = temp_fd;
	}

	/*
	 * Preserve the timestamp of the source file if necessary.
	 */
	if (dopreserve && !files_match) {
		ts[0] = from_sb.st_atim;
		ts[1] = from_sb.st_mtim;
		futimens(to_fd, ts);
	}

	/*
	 * Set owner, group, mode for target; do the chown first,
	 * chown may lose the setuid bits.
	 */
	if ((gid != (gid_t)-1 || uid != (uid_t)-1) &&
	    fchown(to_fd, uid, gid)) {
		serrno = errno;
		(void)unlink(safecopy ? tempfile : to_name);
		errx(1, "%s: chown/chgrp: %s",
		    safecopy ? tempfile : to_name, strerror(serrno));
	}
	if (fchmod(to_fd, mode)) {
		serrno = errno;
		(void)unlink(safecopy ? tempfile : to_name);
		errx(1, "%s: chmod: %s", safecopy ? tempfile : to_name,
		    strerror(serrno));
	}

	/*
	 * If provided a set of flags, set them, otherwise, preserve the
	 * flags, except for the dump flag.
	 */
	if (fchflags(to_fd,
	    flags & SETFLAGS ? fset : from_sb.st_flags & ~UF_NODUMP)) {
		if (errno != EOPNOTSUPP || (from_sb.st_flags & ~UF_NODUMP) != 0)
			warnx("%s: chflags: %s",
			    safecopy ? tempfile :to_name, strerror(errno));
	}

	if (flags & USEFSYNC)
		fsync(to_fd);
	(void)close(to_fd);
	if (!devnull)
		(void)close(from_fd);

	/*
	 * Move the new file into place if doing a safe copy
	 * and the files are different (or just not compared).
	 */
	if (safecopy && !files_match) {
		/* Try to turn off the immutable bits. */
		if (to_sb.st_flags & (NOCHANGEBITS))
			(void)chflags(to_name, to_sb.st_flags & ~(NOCHANGEBITS));
		if (dobackup) {
			char backup[PATH_MAX];
			(void)snprintf(backup, PATH_MAX, "%s%s", to_name,
			    suffix);
			/* It is ok for the target file not to exist. */
			if (rename(to_name, backup) < 0 && errno != ENOENT) {
				serrno = errno;
				unlink(tempfile);
				errx(1, "rename: %s to %s: %s", to_name,
				     backup, strerror(serrno));
			}
		}
		if (rename(tempfile, to_name) < 0 ) {
			serrno = errno;
			unlink(tempfile);
			errx(1, "rename: %s to %s: %s", tempfile,
			     to_name, strerror(serrno));
		}
	}
}

/*
 * copy --
 *	copy from one file to another
 */
void
copy(int from_fd, char *from_name, int to_fd, char *to_name, off_t size,
    int sparse)
{
	ssize_t nr, nw;
	int serrno;
	char *p, buf[MAXBSIZE];

	if (size == 0)
		return;

	/* Rewind file descriptors. */
	if (lseek(from_fd, (off_t)0, SEEK_SET) == (off_t)-1)
		err(1, "lseek: %s", from_name);
	if (lseek(to_fd, (off_t)0, SEEK_SET) == (off_t)-1)
		err(1, "lseek: %s", to_name);

	/*
	 * Mmap and write if less than 8M (the limit is so we don't totally
	 * trash memory on big files.  This is really a minor hack, but it
	 * wins some CPU back.  Sparse files need special treatment.
	 */
	if (!sparse && size <= 8 * 1048576) {
		size_t siz;

		if ((p = mmap(NULL, (size_t)size, PROT_READ, MAP_PRIVATE,
		    from_fd, (off_t)0)) == MAP_FAILED) {
			serrno = errno;
			(void)unlink(to_name);
			errc(1, serrno, "%s", from_name);
		}
		madvise(p, size, MADV_SEQUENTIAL);
		siz = (size_t)size;
		if ((nw = write(to_fd, p, siz)) != siz) {
			serrno = errno;
			(void)unlink(to_name);
			errx(1, "%s: %s",
			    to_name, strerror(nw > 0 ? EIO : serrno));
		}
		(void) munmap(p, (size_t)size);
	} else {
		int sz, rem, isem = 1;
		struct stat sb;

		/*
		 * Pass the blocksize of the file being written to the write
		 * routine.  if the size is zero, use the default S_BLKSIZE.
		 */
		if (fstat(to_fd, &sb) != 0 || sb.st_blksize == 0)
			sz = S_BLKSIZE;
		else
			sz = sb.st_blksize;
		rem = sz;

		while ((nr = read(from_fd, buf, sizeof(buf))) > 0) {
			if (sparse)
				nw = file_write(to_fd, buf, nr, &rem, &isem, sz);
			else
				nw = write(to_fd, buf, nr);
			if (nw != nr) {
				serrno = errno;
				(void)unlink(to_name);
				errx(1, "%s: %s",
				    to_name, strerror(nw > 0 ? EIO : serrno));
			}
		}
		if (sparse)
			file_flush(to_fd, isem);
		if (nr != 0) {
			serrno = errno;
			(void)unlink(to_name);
			errc(1, serrno, "%s", from_name);
		}
	}
}

/*
 * compare --
 *	compare two files; non-zero means files differ
 */
int
compare(int from_fd, const char *from_name, off_t from_len, int to_fd,
    const char *to_name, off_t to_len)
{
	caddr_t p1, p2;
	size_t length;
	off_t from_off, to_off, remainder;
	int dfound;

	if (from_len == 0 && from_len == to_len)
		return (0);

	if (from_len != to_len)
		return (1);

	/*
	 * Compare the two files being careful not to mmap
	 * more than 8M at a time.
	 */
	from_off = to_off = (off_t)0;
	remainder = from_len;
	do {
		length = MINIMUM(remainder, 8 * 1048576);
		remainder -= length;

		if ((p1 = mmap(NULL, length, PROT_READ, MAP_PRIVATE,
		    from_fd, from_off)) == MAP_FAILED)
			err(1, "%s", from_name);
		if ((p2 = mmap(NULL, length, PROT_READ, MAP_PRIVATE,
		    to_fd, to_off)) == MAP_FAILED)
			err(1, "%s", to_name);
		if (length) {
			madvise(p1, length, MADV_SEQUENTIAL);
			madvise(p2, length, MADV_SEQUENTIAL);
		}

		dfound = memcmp(p1, p2, length);

		(void) munmap(p1, length);
		(void) munmap(p2, length);

		from_off += length;
		to_off += length;

	} while (!dfound && remainder > 0);

	return(dfound);
}

/*
 * strip --
 *	use strip(1) to strip the target file
 */
void
strip(char *to_name)
{
	int serrno, status;
	char * volatile path_strip;

	if (issetugid() || (path_strip = getenv("STRIP")) == NULL)
		path_strip = _PATH_STRIP;

	switch (vfork()) {
	case -1:
		serrno = errno;
		(void)unlink(to_name);
		errc(1, serrno, "forks");
	case 0:
		execl(path_strip, "strip", "--", to_name, (char *)NULL);
		warn("%s", path_strip);
		_exit(1);
	default:
		if (wait(&status) == -1 || !WIFEXITED(status))
			(void)unlink(to_name);
	}
}

/*
 * install_dir --
 *	build directory hierarchy
 */
void
install_dir(char *path, int mode)
{
	char *p;
	struct stat sb;
	int ch;

	for (p = path;; ++p)
		if (!*p || (p != path && *p  == '/')) {
			ch = *p;
			*p = '\0';
			if (mkdir(path, 0777)) {
				int mkdir_errno = errno;
				if (stat(path, &sb)) {
					/* Not there; use mkdir()s errno */
					errc(1, mkdir_errno, "%s",
					    path);
					/* NOTREACHED */
				}
				if (!S_ISDIR(sb.st_mode)) {
					/* Is there, but isn't a directory */
					errc(1, ENOTDIR, "%s", path);
					/* NOTREACHED */
				}
			}
			if (!(*p = ch))
				break;
 		}

	if (((gid != (gid_t)-1 || uid != (uid_t)-1) && chown(path, uid, gid)) ||
	    chmod(path, mode)) {
		warn("%s", path);
	}
}

/*
 * usage --
 *	print a usage message and die
 */
void
usage(void)
{
	(void)fprintf(stderr, "\
usage: install [-bCcDdFpSs] [-B suffix] [-f flags] [-g group] [-m mode] [-o owner]\n	       source ... target ...\n");
	exit(1);
	/* NOTREACHED */
}

/*
 * create_tempfile --
 *	create a temporary file based on path and open it
 */
int
create_tempfile(char *path, char *temp, size_t tsize)
{
	char *p;

	strlcpy(temp, path, tsize);
	if ((p = strrchr(temp, '/')) != NULL)
		p++;
	else
		p = temp;
	*p = '\0';
	strlcat(p, "INS@@XXXXXXXXXX", tsize);

	return(mkstemp(temp));
}

/*
 * create_newfile --
 *	create a new file, overwriting an existing one if necessary
 */
int
create_newfile(char *path, struct stat *sbp)
{
	char backup[PATH_MAX];

	/*
	 * Unlink now... avoid ETXTBSY errors later.  Try and turn
	 * off the append/immutable bits -- if we fail, go ahead,
	 * it might work.
	 */
	if (sbp->st_flags & (NOCHANGEBITS))
		(void)chflags(path, sbp->st_flags & ~(NOCHANGEBITS));

	if (dobackup) {
		(void)snprintf(backup, PATH_MAX, "%s%s", path, suffix);
		/* It is ok for the target file not to exist. */
		if (rename(path, backup) < 0 && errno != ENOENT)
			err(1, "rename: %s to %s (errno %d)", path, backup, errno);
	} else {
		if (unlink(path) < 0 && errno != ENOENT)
			err(1, "%s", path);
	}

	return(open(path, O_CREAT | O_RDWR | O_EXCL, S_IRUSR | S_IWUSR));
}

/*
 * file_write()
 *	Write/copy a file (during copy or archive extract). This routine knows
 *	how to copy files with lseek holes in it. (Which are read as file
 *	blocks containing all 0's but do not have any file blocks associated
 *	with the data). Typical examples of these are files created by dbm
 *	variants (.pag files). While the file size of these files are huge, the
 *	actual storage is quite small (the files are sparse). The problem is
 *	the holes read as all zeros so are probably stored on the archive that
 *	way (there is no way to determine if the file block is really a hole,
 *	we only know that a file block of all zero's can be a hole).
 *	At this writing, no major archive format knows how to archive files
 *	with holes. However, on extraction (or during copy, -rw) we have to
 *	deal with these files. Without detecting the holes, the files can
 *	consume a lot of file space if just written to disk. This replacement
 *	for write when passed the basic allocation size of a file system block,
 *	uses lseek whenever it detects the input data is all 0 within that
 *	file block. In more detail, the strategy is as follows:
 *	While the input is all zero keep doing an lseek. Keep track of when we
 *	pass over file block boundaries. Only write when we hit a non zero
 *	input. once we have written a file block, we continue to write it to
 *	the end (we stop looking at the input). When we reach the start of the
 *	next file block, start checking for zero blocks again. Working on file
 *	block boundaries significantly reduces the overhead when copying files
 *	that are NOT very sparse. This overhead (when compared to a write) is
 *	almost below the measurement resolution on many systems. Without it,
 *	files with holes cannot be safely copied. It does has a side effect as
 *	it can put holes into files that did not have them before, but that is
 *	not a problem since the file contents are unchanged (in fact it saves
 *	file space). (Except on paging files for diskless clients. But since we
 *	cannot determine one of those file from here, we ignore them). If this
 *	ever ends up on a system where CTG files are supported and the holes
 *	are not desired, just do a conditional test in those routines that
 *	call file_write() and have it call write() instead. BEFORE CLOSING THE
 *	FILE, make sure to call file_flush() when the last write finishes with
 *	an empty block. A lot of file systems will not create an lseek hole at
 *	the end. In this case we drop a single 0 at the end to force the
 *	trailing 0's in the file.
 *	---Parameters---
 *	rem: how many bytes left in this file system block
 *	isempt: have we written to the file block yet (is it empty)
 *	sz: basic file block allocation size
 *	cnt: number of bytes on this write
 *	str: buffer to write
 * Return:
 *	number of bytes written, -1 on write (or lseek) error.
 */

int
file_write(int fd, char *str, size_t cnt, int *rem, int *isempt, int sz)
{
	char *pt;
	char *end;
	size_t wcnt;
	char *st = str;

	/*
	 * while we have data to process
	 */
	while (cnt) {
		if (!*rem) {
			/*
			 * We are now at the start of file system block again
			 * (or what we think one is...). start looking for
			 * empty blocks again
			 */
			*isempt = 1;
			*rem = sz;
		}

		/*
		 * only examine up to the end of the current file block or
		 * remaining characters to write, whatever is smaller
		 */
		wcnt = MINIMUM(cnt, *rem);
		cnt -= wcnt;
		*rem -= wcnt;
		if (*isempt) {
			/*
			 * have not written to this block yet, so we keep
			 * looking for zero's
			 */
			pt = st;
			end = st + wcnt;

			/*
			 * look for a zero filled buffer
			 */
			while ((pt < end) && (*pt == '\0'))
				++pt;

			if (pt == end) {
				/*
				 * skip, buf is empty so far
				 */
				if (lseek(fd, (off_t)wcnt, SEEK_CUR) < 0) {
					warn("lseek");
					return(-1);
				}
				st = pt;
				continue;
			}
			/*
			 * drat, the buf is not zero filled
			 */
			*isempt = 0;
		}

		/*
		 * have non-zero data in this file system block, have to write
		 */
		if (write(fd, st, wcnt) != wcnt) {
			warn("write");
			return(-1);
		}
		st += wcnt;
	}
	return(st - str);
}

/*
 * file_flush()
 *	when the last file block in a file is zero, many file systems will not
 *	let us create a hole at the end. To get the last block with zeros, we
 *	write the last BYTE with a zero (back up one byte and write a zero).
 */
void
file_flush(int fd, int isempt)
{
	static char blnk[] = "\0";

	/*
	 * silly test, but make sure we are only called when the last block is
	 * filled with all zeros.
	 */
	if (!isempt)
		return;

	/*
	 * move back one byte and write a zero
	 */
	if (lseek(fd, (off_t)-1, SEEK_CUR) < 0) {
		warn("Failed seek on file");
		return;
	}

	if (write(fd, blnk, 1) < 0)
		warn("Failed write to file");
	return;
}
@


1.64
log
@Add -F option to install(1) that calls fsync(2) on the installed
file right before closing it.  OK tedu@@ phessler@@
@
text
@d1 1
a1 1
/*	$OpenBSD: xinstall.c,v 1.63 2015/12/31 16:16:54 millert Exp $	*/
d627 1
a627 1
usage: install [-bCcDdDpSs] [-B suffix] [-f flags] [-g group] [-m mode] [-o owner]\n	       source ... target ...\n");
@


1.63
log
@Remove use of sysexits.h.
@
text
@d1 1
a1 1
/*	$OpenBSD: xinstall.c,v 1.62 2015/07/19 18:27:26 jasper Exp $	*/
d59 1
d94 1
a94 1
	while ((ch = getopt(argc, argv, "B:bCcDdf:g:m:o:pSs")) != -1)
d108 3
d384 2
d627 1
a627 1
usage: install [-bCcDdpSs] [-B suffix] [-f flags] [-g group] [-m mode] [-o owner]\n	       source ... target ...\n");
@


1.62
log
@when using -D, do not use the mode set for the target file as the directory mode

ok millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: xinstall.c,v 1.61 2015/07/18 15:42:37 jasper Exp $	*/
a49 1
#include <sysexits.h>
d110 1
a110 1
				errx(EX_USAGE, "%s: invalid flag", flags);
d118 1
a118 1
				errx(EX_USAGE, "%s: invalid file mode", optarg);
d161 1
a161 1
		errx(EX_NOUSER, "unknown group %s", group);
d164 1
a164 1
		errx(EX_NOUSER, "unknown user %s", owner);
d170 1
a170 1
		exit(EX_OK);
d177 1
a177 1
			errx(EX_OSERR, "cannot determine dirname");
d190 1
a190 1
		exit(EX_OK);
d196 1
a196 1
		errx(EX_OSERR, "Target: %s", argv[argc-1]);
d200 1
a200 1
			err(EX_OSERR, "%s", *argv);
d202 1
a202 1
			errc(EX_OSERR, EFTYPE, "%s", to_name);
d205 1
a205 1
			errx(EX_USAGE, "%s and %s are the same file", *argv, to_name);
d208 1
a208 1
	exit(EX_OK);
d230 1
a230 1
			err(EX_OSERR, "%s", from_name);
d232 1
a232 1
			errc(EX_OSERR, EFTYPE, "%s", from_name);
d258 1
a258 1
			err(EX_OSERR, "%s", from_name);
d264 1
a264 1
			err(EX_OSERR, "%s", tempfile);
d267 1
a267 1
			err(EX_OSERR, "%s", to_name);
d270 1
a270 1
			err(EX_OSERR, "%s", to_name);
d283 1
a283 1
					err(EX_OSERR, "%s", to_name);
d302 1
a302 1
			err(EX_OSERR, "stripping %s", to_name);
d314 1
a314 1
			err(EX_OSERR, "%s", to_name);
d319 1
a319 1
			errc(EX_OSERR, serrno, "%s", tempfile);
d359 1
a359 1
		errx(EX_OSERR, "%s: chown/chgrp: %s",
d365 1
a365 1
		errx(EX_OSERR, "%s: chmod: %s", safecopy ? tempfile : to_name,
d400 1
a400 1
				errx(EX_OSERR, "rename: %s to %s: %s", to_name,
d407 1
a407 1
			errx(EX_OSERR, "rename: %s to %s: %s", tempfile,
d430 1
a430 1
		err(EX_OSERR, "lseek: %s", from_name);
d432 1
a432 1
		err(EX_OSERR, "lseek: %s", to_name);
d446 1
a446 1
			errc(EX_OSERR, serrno, "%s", from_name);
d453 1
a453 1
			errx(EX_OSERR, "%s: %s",
d479 1
a479 1
				errx(EX_OSERR, "%s: %s",
d488 1
a488 1
			errc(EX_OSERR, serrno, "%s", from_name);
d524 1
a524 1
			err(EX_OSERR, "%s", from_name);
d527 1
a527 1
			err(EX_OSERR, "%s", to_name);
d563 1
a563 1
		errc(EX_TEMPFAIL, serrno, "forks");
d567 1
a567 1
		_exit(EX_OSERR);
d593 1
a593 1
					errc(EX_OSERR, mkdir_errno, "%s",
d599 1
a599 1
					errc(EX_OSERR, ENOTDIR, "%s", path);
d622 1
a622 1
	exit(EX_USAGE);
d667 1
a667 1
			err(EX_OSERR, "rename: %s to %s (errno %d)", path, backup, errno);
d670 1
a670 1
			err(EX_OSERR, "%s", path);
@


1.61
log
@kill trailing whitespace
@
text
@d1 1
a1 1
/*	$OpenBSD: xinstall.c,v 1.60 2015/07/18 14:32:36 jasper Exp $	*/
d75 1
a75 1
void	install_dir(char *);
d170 1
a170 1
			install_dir(*argv);
d179 6
a184 1
		install_dir(dest);
d580 1
a580 1
install_dir(char *path)
@


1.60
log
@add -D to create the full destination path before installing the source into it

ok millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: xinstall.c,v 1.59 2015/04/18 03:15:46 guenther Exp $	*/
d355 1
a355 1
		errx(EX_OSERR, "%s: chown/chgrp: %s", 
d372 1
a372 1
			warnx("%s: chflags: %s", 
@


1.59
log
@Use futimens() to preserve timestamps with subsec precision.
Don't cast file sizes to size_t when comparing file contents for the -C option

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: xinstall.c,v 1.58 2015/01/16 06:40:15 deraadt Exp $	*/
d52 1
d65 1
a65 1
int dobackup, docompare, dodir, dopreserve, dostrip, safecopy;
d94 1
a94 1
	while ((ch = getopt(argc, argv, "B:bCcdf:g:m:o:pSs")) != -1)
d135 3
d175 7
d617 1
a617 1
usage: install [-bCcdpSs] [-B suffix] [-f flags] [-g group] [-m mode] [-o owner]\n	       source ... target ...\n");
@


1.58
log
@Replace <sys/param.h> with <limits.h> and other less dirty headers where
possible.  Annotate <sys/param.h> lines with their current reasons.  Switch
to PATH_MAX, NGROUPS_MAX, HOST_NAME_MAX+1, LOGIN_NAME_MAX, etc.  Change
MIN() and MAX() to local definitions of MINIMUM() and MAXIMUM() where
sensible to avoid pulling in the pollution.  These are the files confirmed
through binary verification.
ok guenther, millert, doug (helped with the verification protocol)
@
text
@d1 1
a1 1
/*	$OpenBSD: xinstall.c,v 1.57 2014/05/20 01:25:23 guenther Exp $	*/
d72 1
a72 1
int	compare(int, const char *, size_t, int, const char *, size_t);
d205 1
a205 1
	struct utimbuf utb;
d261 2
a262 2
					(size_t)from_sb.st_size, to_fd,
					to_name, (size_t)to_sb.st_size));
d307 2
a308 2
		if (compare(temp_fd, tempfile, (size_t)temp_sb.st_size, to_fd,
			    to_name, (size_t)to_sb.st_size) == 0) {
d315 3
a317 3
				utb.actime = to_sb.st_atime;
				utb.modtime = to_sb.st_mtime;
				(void)utime(tempfile, &utb);
d331 3
a333 3
		utb.actime = from_sb.st_atime;
		utb.modtime = from_sb.st_mtime;
		(void)utime(safecopy ? tempfile : to_name, &utb);
d483 2
a484 2
compare(int from_fd, const char *from_name, size_t from_len, int to_fd,
    const char *to_name, size_t to_len)
d487 2
a488 2
	size_t length, remainder;
	off_t from_off, to_off;
@


1.57
log
@Use errc/warnc to simplify code.
Also, in 'ftp', always put the error message last, after the hostname/ipaddr.

ok jsing@@ krw@@ millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: xinstall.c,v 1.56 2013/11/27 13:32:02 okan Exp $	*/
d33 1
a33 1
#include <sys/param.h>
d49 1
d55 2
d66 1
a66 1
char pathbuf[MAXPATHLEN], tempfile[MAXPATHLEN];
d378 2
a379 2
			char backup[MAXPATHLEN];
			(void)snprintf(backup, MAXPATHLEN, "%s%s", to_name,
d504 1
a504 1
		length = MIN(remainder, 8 * 1048576);
d638 1
a638 1
	char backup[MAXPATHLEN];
d649 1
a649 1
		(void)snprintf(backup, MAXPATHLEN, "%s%s", path, suffix);
d735 1
a735 1
		wcnt = MIN(cnt, *rem);
@


1.56
log
@remove erroneous char cast to switch expression processing getopt(3);
not used in any cases.

ok deraadt@@, guenther@@, millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: xinstall.c,v 1.55 2013/11/26 21:08:10 deraadt Exp $	*/
d184 1
a184 1
			errx(EX_OSERR, "%s: %s", to_name, strerror(EFTYPE));
d214 1
a214 1
			errx(EX_OSERR, "%s: %s", from_name, strerror(EFTYPE));
d231 1
a231 1
			warnx("%s: %s", to_name, strerror(EFTYPE));
d301 1
a301 1
			errx(EX_OSERR, "%s: %s", tempfile, strerror(serrno));
d428 1
a428 1
			errx(EX_OSERR, "%s: %s", from_name, strerror(serrno));
d470 1
a470 1
			errx(EX_OSERR, "%s: %s", from_name, strerror(serrno));
d545 1
a545 1
		errx(EX_TEMPFAIL, "forks: %s", strerror(serrno));
d575 2
a576 2
					errno = mkdir_errno;
					err(EX_OSERR, "%s", path);
d581 1
a581 2
					errno = ENOTDIR;
					err(EX_OSERR, "%s", path);
@


1.55
log
@unsigned char casts for ctype
ok okan
@
text
@d1 1
a1 1
/*	$OpenBSD: xinstall.c,v 1.54 2013/06/02 01:41:23 naddy Exp $	*/
d91 1
a91 1
		switch((char)ch) {
@


1.54
log
@Copy approach from mkdir to fix a race condition where multiple install -d's
trying to create overlapping paths in parallel could error out.  ok millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: xinstall.c,v 1.53 2013/02/18 22:15:11 miod Exp $	*/
d154 1
a154 1
	if (group && !(gp = getgrnam(group)) && !isdigit(*group))
d157 1
a157 1
	if (owner && !(pp = getpwnam(owner)) && !isdigit(*owner))
@


1.53
log
@Report unlink() errors unless ENOENT; especially useful in case of read-only
filesystems to get a useful error message than `File exists'.
ok guenther@@ todd@@ beck@@ phessler@@ mpi@@ gievanni@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: xinstall.c,v 1.52 2012/09/14 00:00:29 millert Exp $	*/
d571 11
a581 2
			if (stat(path, &sb)) {
				if (errno != ENOENT || mkdir(path, 0777) < 0) {
@


1.52
log
@There's no reason to unlink the destination if we can't even open
the source file.  This fixes a problem with the databases/ruby-ldap
port.  Note that I changed the O_TRUNC to O_EXCL to avoid the race
between unlink/rename and creat.  OK naddy@@ jeremy@@
@
text
@d1 1
a1 1
/*	$OpenBSD: xinstall.c,v 1.51 2012/04/11 14:19:35 millert Exp $	*/
d642 4
a645 2
	} else
		(void)unlink(path);
@


1.51
log
@Move size == 0 check to the beginnig of copy(); ok espie@@
@
text
@d1 1
a1 1
/*	$OpenBSD: xinstall.c,v 1.50 2012/04/11 09:27:42 espie Exp $	*/
d238 5
a255 6
		if ((from_fd = open(from_name, O_RDONLY, 0)) < 0) {
			serrno = errno;
			(void)unlink(safecopy ? tempfile : to_name);
			errx(EX_OSERR, "%s: %s", from_name, strerror(serrno));
		}

d645 1
a645 1
	return(open(path, O_CREAT | O_RDWR | O_TRUNC, S_IRUSR | S_IWUSR));
@


1.50
log
@fix install to cope with 0-sized mmap now returning EINVAL.
- no need to copy anything
- gc redundant size check
- short-cut for compare (theo's code)
- gc volatile ???
- style

"sure" theo
@
text
@d1 1
a1 1
/*	$OpenBSD: xinstall.c,v 1.49 2009/10/27 23:59:50 deraadt Exp $	*/
d408 3
d422 1
a422 3
	if (!size) {
		/* nothing to do */
	} else if (!sparse && size <= 8 * 1048576) {
@


1.49
log
@rcsid[] and sccsid[] and copyright[] are essentially unmaintained (and
unmaintainable).  these days, people use source.  these id's do not provide
any benefit, and do hurt the small install media
(the 33,000 line diff is essentially mechanical)
ok with the idea millert, ok dms
@
text
@d1 1
a1 1
/*	$OpenBSD: xinstall.c,v 1.48 2009/03/27 07:31:27 phessler Exp $	*/
d419 4
a422 2
	if (!sparse && size <= 8 * 1048576) {
		volatile size_t siz;
d430 1
a430 2
		if (size)
			madvise(p, size, MADV_SEQUENTIAL);
d488 3
d492 1
a492 1
		return(1);
@


1.48
log
@-S (safe mode) would copy the file over, rename it to the target, then
do the chown/chmod dance.  This created a race where the new file would
be in place, but with the incorrect permissions.  Fix so the rename is
the last thing, instead of a middle thing.

looks ok to krw@@, deraadt@@
OK beck@@
@
text
@d1 1
a1 1
/*	$OpenBSD: xinstall.c,v 1.47 2007/09/05 08:58:34 jsg Exp $	*/
a31 13

#ifndef lint
static char copyright[] =
"@@(#) Copyright (c) 1987, 1993\n\
	The Regents of the University of California.  All rights reserved.\n";
#endif /* not lint */

#ifndef lint
#if 0
static char sccsid[] = "@@(#)xinstall.c	8.1 (Berkeley) 7/21/93";
#endif
static char rcsid[] = "$OpenBSD: xinstall.c,v 1.47 2007/09/05 08:58:34 jsg Exp $";
#endif /* not lint */
@


1.47
log
@Missing colon in optsring for 'B'
From Jan Niemann <jan.niemann@@gns-systems.de>
@
text
@d1 1
a1 1
/*	$OpenBSD: xinstall.c,v 1.46 2007/08/06 19:16:06 sobrado Exp $	*/
d43 1
a43 1
static char rcsid[] = "$OpenBSD: xinstall.c,v 1.46 2007/08/06 19:16:06 sobrado Exp $";
a332 1
			(void) close(temp_fd);
d334 2
a335 33
	}

	/*
	 * Move the new file into place if doing a safe copy
	 * and the files are different (or just not compared).
	 */
	if (safecopy && !files_match) {
		/* Try to turn off the immutable bits. */
		if (to_sb.st_flags & (NOCHANGEBITS))
			(void)chflags(to_name, to_sb.st_flags & ~(NOCHANGEBITS));
		if (dobackup) {
			char backup[MAXPATHLEN];
			(void)snprintf(backup, MAXPATHLEN, "%s%s", to_name,
			    suffix);
			/* It is ok for the target file not to exist. */
			if (rename(to_name, backup) < 0 && errno != ENOENT) {
				serrno = errno;
				unlink(tempfile);
				errx(EX_OSERR, "rename: %s to %s: %s", to_name,
				     backup, strerror(serrno));
			}
		}
		if (rename(tempfile, to_name) < 0 ) {
			serrno = errno;
			unlink(tempfile);
			errx(EX_OSERR, "rename: %s to %s: %s", tempfile,
			     to_name, strerror(serrno));
		}

		/* Re-open to_fd so we aren't hosed by the rename(2). */
		(void) close(to_fd);
		if ((to_fd = open(to_name, O_RDONLY, 0)) < 0)
			err(EX_OSERR, "%s", to_name);
d344 1
a344 1
		(void)utime(to_name, &utb);
d351 2
a352 1
	if ((gid != (gid_t)-1 || uid != (uid_t)-1) && fchown(to_fd, uid, gid)) {
d354 3
a356 2
		(void)unlink(to_name);
		errx(EX_OSERR, "%s: chown/chgrp: %s", to_name, strerror(serrno));
d360 3
a362 2
		(void)unlink(to_name);
		errx(EX_OSERR, "%s: chmod: %s", to_name, strerror(serrno));
d372 2
a373 1
			warnx("%s: chflags: %s", to_name, strerror(errno));
d379 28
@


1.46
log
@the ellipsis is not an optional argument; while here, sync the usage
and synopsis of commands

lots of good ideas by jmc@@

ok jmc@@
@
text
@d1 1
a1 1
/*	$OpenBSD: xinstall.c,v 1.45 2007/05/25 20:32:29 krw Exp $	*/
d43 1
a43 1
static char rcsid[] = "$OpenBSD: xinstall.c,v 1.45 2007/05/25 20:32:29 krw Exp $";
d103 1
a103 1
	while ((ch = getopt(argc, argv, "BbCcdf:g:m:o:pSs")) != -1)
@


1.45
log
@"boundries" -> "boundaries" in various comments. Started by Diego Casati.
@
text
@d1 1
a1 1
/*	$OpenBSD: xinstall.c,v 1.44 2007/05/16 17:33:07 moritz Exp $	*/
d43 1
a43 1
static char rcsid[] = "$OpenBSD: xinstall.c,v 1.44 2007/05/16 17:33:07 moritz Exp $";
d604 1
a604 1
usage: install [-bCcdpSs] [-B suffix] [-f flags] [-g group] [-m mode] [-o owner]\n	       source [...] target [...]\n");
@


1.44
log
@Allow stripping of files, even if the destination filename
starts with a dash.

ok millert@@ jaredy@@ ray@@
@
text
@d1 1
a1 1
/*	$OpenBSD: xinstall.c,v 1.43 2006/01/10 00:30:08 millert Exp $	*/
d43 1
a43 1
static char rcsid[] = "$OpenBSD: xinstall.c,v 1.43 2006/01/10 00:30:08 millert Exp $";
d676 1
a676 1
 *	pass over file block boundries. Only write when we hit a non zero
d680 1
a680 1
 *	block boundries significantly reduces the overhead when copying files
@


1.43
log
@Use strlcpy(), not strncpy(); OK deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: xinstall.c,v 1.42 2004/10/04 05:21:27 jsg Exp $	*/
d43 1
a43 1
static char rcsid[] = "$OpenBSD: xinstall.c,v 1.42 2004/10/04 05:21:27 jsg Exp $";
d556 1
a556 1
		execl(path_strip, "strip", to_name, (char *)NULL);
@


1.42
log
@hierarchy is spelt hierarchy, ok djm@@
@
text
@d1 1
a1 1
/*	$OpenBSD: xinstall.c,v 1.41 2004/07/01 18:25:48 otto Exp $	*/
d43 1
a43 1
static char rcsid[] = "$OpenBSD: xinstall.c,v 1.41 2004/07/01 18:25:48 otto Exp $";
d618 2
a619 3
	(void)strncpy(temp, path, tsize);
	temp[tsize - 1] = '\0';
	if ((p = strrchr(temp, '/')))
d623 2
a624 2
	(void)strncpy(p, "INS@@XXXXXXXXXX", &temp[tsize - 1] - p);
	temp[tsize - 1] = '\0';
@


1.41
log
@setmode(3) returns void *, not mode_t *.  ok millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: xinstall.c,v 1.40 2004/02/10 07:33:23 jmc Exp $	*/
d43 1
a43 1
static char rcsid[] = "$OpenBSD: xinstall.c,v 1.40 2004/02/10 07:33:23 jmc Exp $";
d567 1
a567 1
 *	build directory heirarchy
@


1.40
log
@- sort options
- simplify SYNOPSIS
- note that files are copied, not moved (from couderc@@)
@
text
@d1 1
a1 1
/*	$OpenBSD: xinstall.c,v 1.39 2003/11/22 14:17:32 mickey Exp $	*/
d43 1
a43 1
static char rcsid[] = "$OpenBSD: xinstall.c,v 1.39 2003/11/22 14:17:32 mickey Exp $";
d96 1
a96 1
	mode_t *set;
@


1.39
log
@madvise() -- take two
@
text
@d1 1
a1 1
/*	$OpenBSD: xinstall.c,v 1.38 2003/11/22 13:40:28 grange Exp $	*/
d43 1
a43 1
static char rcsid[] = "$OpenBSD: xinstall.c,v 1.38 2003/11/22 13:40:28 grange Exp $";
d604 1
a604 3
usage: install [-bCcpSs] [-B suffix] [-f flags] [-g group] [-m mode] [-o owner] file1 file2\n\
       install [-bCcpSs] [-B suffix] [-f flags] [-g group] [-m mode] [-o owner] file1 ... fileN directory\n\
       install  -d   [-g group] [-m mode] [-o owner] directory ...\n");
@


1.38
log
@Revert the last change since it's broke make release.
@
text
@d1 1
a1 1
/*	$OpenBSD: xinstall.c,v 1.36 2003/07/02 00:21:17 avsm Exp $	*/
d43 1
a43 1
static char rcsid[] = "$OpenBSD: xinstall.c,v 1.36 2003/07/02 00:21:17 avsm Exp $";
d441 2
d519 4
@


1.37
log
@madvise() mmaped memory as sequentially accessed cutting user time almost in half; millert@@ ok
@
text
@d436 1
a436 2
		    from_fd, (off_t)0)) == MAP_FAILED ||
		    madvise(p, size, MADV_SEQUENTIAL)) {
d512 1
a512 2
		    from_fd, from_off)) == MAP_FAILED ||
		    madvise(p1, length, MADV_SEQUENTIAL))
d515 1
a515 2
		    to_fd, to_off)) == MAP_FAILED ||
		    madvise(p2, length, MADV_SEQUENTIAL))
@


1.36
log
@bump randomness of mktemp to from 6 to 10 X's, as recommended by mktemp(3)
@
text
@d1 1
a1 1
/*	$OpenBSD: xinstall.c,v 1.35 2003/06/10 22:20:54 deraadt Exp $	*/
d43 1
a43 1
static char rcsid[] = "$OpenBSD: xinstall.c,v 1.35 2003/06/10 22:20:54 deraadt Exp $";
d436 2
a437 1
		    from_fd, (off_t)0)) == MAP_FAILED) {
d513 2
a514 1
		    from_fd, from_off)) == MAP_FAILED)
d517 2
a518 1
		    to_fd, to_off)) == MAP_FAILED)
@


1.35
log
@mostly ansi cleanup; pval ok
@
text
@d1 1
a1 1
/*	$OpenBSD: xinstall.c,v 1.34 2003/06/03 02:56:24 millert Exp $	*/
d43 1
a43 1
static char rcsid[] = "$OpenBSD: xinstall.c,v 1.34 2003/06/03 02:56:24 millert Exp $";
d620 1
a620 1
	(void)strncpy(p, "INS@@XXXXXX", &temp[tsize - 1] - p);
@


1.34
log
@Remove the advertising clause in the UCB license which Berkeley
rescinded 22 July 1999.  Proofed by myself and Theo.
@
text
@d1 1
a1 1
/*	$OpenBSD: xinstall.c,v 1.33 2003/05/11 18:18:33 tedu Exp $	*/
d43 1
a43 1
static char rcsid[] = "$OpenBSD: xinstall.c,v 1.33 2003/05/11 18:18:33 tedu Exp $";
d93 1
a93 3
main(argc, argv)
	int argc;
	char *argv[];
d212 1
a212 4
install(from_name, to_name, fset, flags)
	char *from_name, *to_name;
	u_long fset;
	u_int flags;
d414 2
a415 5
copy(from_fd, from_name, to_fd, to_name, size, sparse)
	int from_fd, to_fd;
	char *from_name, *to_name;
	off_t size;
	int sparse;
d490 2
a491 7
compare(from_fd, from_name, from_len, to_fd, to_name, to_len)
	int from_fd;
	const char *from_name;
	size_t from_len;
	int to_fd;
	const char *to_name;
	size_t to_len;
d536 1
a536 2
strip(to_name)
	char *to_name;
d564 1
a564 2
install_dir(path)
        char *path;
d595 1
a595 1
usage()
d610 1
a610 4
create_tempfile(path, temp, tsize)
        char *path;
        char *temp;
	size_t tsize;
d631 1
a631 3
create_newfile(path, sbp)
        char *path;
	struct stat *sbp;
d703 1
a703 7
file_write(fd, str, cnt, rem, isempt, sz)
	int fd;
	char *str;
	size_t cnt;
	int *rem;
	int *isempt;
	int sz;
a779 1

@


1.33
log
@when doing sparse writes, we must write the last byte or the file will
be shortened.  problem found by wcobb and naddy.  ok millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: xinstall.c,v 1.32 2003/05/07 22:38:06 millert Exp $	*/
d16 1
a16 5
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
d43 1
a43 1
static char rcsid[] = "$OpenBSD: xinstall.c,v 1.32 2003/05/07 22:38:06 millert Exp $";
@


1.32
log
@fix an err() that should be errx()
@
text
@d1 1
a1 1
/*	$OpenBSD: xinstall.c,v 1.31 2002/02/16 21:27:59 millert Exp $	*/
d47 1
a47 1
static char rcsid[] = "$OpenBSD: xinstall.c,v 1.31 2002/02/16 21:27:59 millert Exp $";
d94 1
d487 2
d802 32
@


1.31
log
@Part one of userland __P removal.  Done with a simple regexp with some minor hand editing to make comments line up correctly.  Another pass is forthcoming that handles the cases that could not be done automatically.
@
text
@d1 1
a1 1
/*	$OpenBSD: xinstall.c,v 1.30 2002/01/24 23:01:19 millert Exp $	*/
d47 1
a47 1
static char rcsid[] = "$OpenBSD: xinstall.c,v 1.30 2002/01/24 23:01:19 millert Exp $";
d196 1
a196 1
		err(EX_OSERR, "Target: %s", argv[argc-1]);
@


1.30
log
@Fix `necesary' typos; Alexander Yurchenko

Alas many of these were introduced by yours truly as necessary
just doesn't look right to me for some reason ;-)
@
text
@d1 1
a1 1
/*	$OpenBSD: xinstall.c,v 1.29 2001/11/19 19:02:18 mpech Exp $	*/
d47 1
a47 1
static char rcsid[] = "$OpenBSD: xinstall.c,v 1.29 2001/11/19 19:02:18 mpech Exp $";
d85 9
a93 9
void	copy __P((int, char *, int, char *, off_t, int));
int	compare __P((int, const char *, size_t, int, const char *, size_t));
void	install __P((char *, char *, u_long, u_int));
void	install_dir __P((char *));
void	strip __P((char *));
void	usage __P((void));
int	create_newfile __P((char *, struct stat *));
int	create_tempfile __P((char *, char *, size_t));
int	file_write __P((int, char *, size_t, int *, int *, int));
@


1.29
log
@kill more registers

millert@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: xinstall.c,v 1.28 2001/08/25 19:52:05 heko Exp $	*/
d47 1
a47 1
static char rcsid[] = "$OpenBSD: xinstall.c,v 1.28 2001/08/25 19:52:05 heko Exp $";
d379 1
a379 1
	 * Preserve the timestamp of the source file if necesary.
d647 1
a647 1
 *	create a new file, overwriting an existing one if necesary
@


1.28
log
@It is ok for the target file not to exist even if -b was specified
to install(1), so silently ignore rename(2) ENOENT.
Closes PR 2028.
ok millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: xinstall.c,v 1.26 2001/06/23 23:09:31 millert Exp $	*/
d47 1
a47 1
static char rcsid[] = "$OpenBSD: xinstall.c,v 1.26 2001/06/23 23:09:31 millert Exp $";
d93 1
a93 1
int	file_write __P((int, char *, register size_t, int *, int *, int));
d423 1
a423 1
	register int from_fd, to_fd;
d428 1
a428 1
	register ssize_t nr, nw;
d582 1
a582 1
	register char *p;
d727 1
a727 1
	register size_t cnt;
d732 4
a735 4
	register char *pt;
	register char *end;
	register size_t wcnt;
	register char *st = str;
@


1.27
log
@correct type on last arg to execl(); nordin@@cse.ogi.edu
@
text
@d357 2
a358 1
			if (rename(to_name, backup) < 0) {
d666 3
a668 2
		if (rename(path, backup) < 0)
			err(EX_OSERR, "rename: %s to %s", path, backup);
@


1.26
log
@Remove evil #ifdef __GNUC__ garbage to avoid longjmp clobbering and
use volatile instead.
@
text
@d1 1
a1 1
/*	$OpenBSD: xinstall.c,v 1.25 2000/12/22 11:53:17 jj Exp $	*/
d47 1
a47 1
static char rcsid[] = "$OpenBSD: xinstall.c,v 1.25 2000/12/22 11:53:17 jj Exp $";
d564 1
a564 1
		execl(path_strip, "strip", to_name, NULL);
@


1.25
log
@Complain about, and name the missing directory when trying to install
multiple files into a non-existing directory. art@@ and hin@@ ok.
@
text
@d1 1
a1 1
/*	$OpenBSD: xinstall.c,v 1.24 2000/10/12 10:22:20 art Exp $	*/
d47 1
a47 1
static char rcsid[] = "$OpenBSD: xinstall.c,v 1.24 2000/10/12 10:22:20 art Exp $";
d553 1
a553 5
	char *path_strip;

#ifdef __GNUC__				/* XXX: to shut up gcc warnings */
        (void)&path_strip;
#endif
@


1.24
log
@MAP_FAILED, not -1.
(this file actually contained two correct MAP_FAILED).
@
text
@d1 1
a1 1
/*	$OpenBSD: xinstall.c,v 1.23 2000/07/19 19:29:16 mickey Exp $	*/
d47 1
a47 1
static char rcsid[] = "$OpenBSD: xinstall.c,v 1.23 2000/07/19 19:29:16 mickey Exp $";
d196 1
a196 1
		usage();
@


1.23
log
@new strtofflags/fflagstostr
@
text
@d1 1
a1 1
/*	$OpenBSD: xinstall.c,v 1.22 1999/08/04 18:24:09 mickey Exp $	*/
d47 1
a47 1
static char rcsid[] = "$OpenBSD: xinstall.c,v 1.22 1999/08/04 18:24:09 mickey Exp $";
d446 1
a446 1
		    from_fd, (off_t)0)) == (char *)-1) {
@


1.22
log
@supply particular mapping type to the mmap(2) instead of bogus 0
@
text
@d1 1
a1 1
/*	$OpenBSD: xinstall.c,v 1.21 1999/05/29 20:17:35 millert Exp $	*/
d47 1
a47 1
static char rcsid[] = "$OpenBSD: xinstall.c,v 1.21 1999/05/29 20:17:35 millert Exp $";
a88 1
u_long	string_to_flags __P((char **, u_long *, u_long *));
d102 1
a102 1
	u_long fset;
d124 1
a124 1
			if (string_to_flags(&flags, &fset, NULL))
@


1.21
log
@compare was broken for files > 8gig
@
text
@d1 1
a1 1
/*	$OpenBSD: xinstall.c,v 1.20 1999/03/03 01:03:51 millert Exp $	*/
d47 1
a47 1
static char rcsid[] = "$OpenBSD: xinstall.c,v 1.20 1999/03/03 01:03:51 millert Exp $";
d525 2
a526 2
		if ((p1 = mmap(NULL, length, PROT_READ, 0, from_fd, from_off))
		     == MAP_FAILED)
d528 2
a529 2
		if ((p2 = mmap(NULL, length, PROT_READ, 0, to_fd, to_off))
		     == MAP_FAILED)
@


1.20
log
@fix uninitialized variable; this could have caused problems when installing sparse files
@
text
@d1 1
a1 1
/*	$OpenBSD: xinstall.c,v 1.19 1999/01/26 04:09:35 millert Exp $	*/
d47 1
a47 1
static char rcsid[] = "$OpenBSD: xinstall.c,v 1.19 1999/01/26 04:09:35 millert Exp $";
d508 2
a509 1
	register size_t length, remainder;
a514 6
	/* Rewind file descriptors. */
	if (lseek(from_fd, (off_t)0, SEEK_SET) == (off_t)-1)
		err(EX_OSERR, "lseek: %s", from_name);
	if (lseek(to_fd, (off_t)0, SEEK_SET) == (off_t)-1)
		err(EX_OSERR, "lseek: %s", to_name);

d519 1
d525 2
a526 2
		if ((p1 = mmap(NULL, length, PROT_READ, 0, from_fd, (off_t)0))
		     == (caddr_t)-1)
d528 2
a529 2
		if ((p2 = mmap(NULL, length, PROT_READ, 0, to_fd, (off_t)0))
		     == (caddr_t)-1)
d536 3
@


1.19
log
@Add a -b(ackup) flag to move any existing file(s) aside by renaming
them to file.old instead of simply deleting them. A different backup
suffix may be chosen with the -B option's argument.  hubertf@@netbsd.org
@
text
@d1 1
a1 1
/*	$OpenBSD: xinstall.c,v 1.18 1998/12/17 17:19:49 millert Exp $	*/
d47 1
a47 1
static char rcsid[] = "$OpenBSD: xinstall.c,v 1.18 1998/12/17 17:19:49 millert Exp $";
d472 1
@


1.18
log
@Some -Wall
Don't try to close a descriptor if it was never opened.
@
text
@d1 1
a1 1
/*	$OpenBSD: xinstall.c,v 1.17 1998/12/16 19:55:57 millert Exp $	*/
d47 1
a47 1
static char rcsid[] = "$OpenBSD: xinstall.c,v 1.17 1998/12/16 19:55:57 millert Exp $";
d71 5
d78 1
a78 1
int docompare, dodir, dopreserve, dostrip, safecopy;
d81 1
a84 4
#define	DIRECTORY	0x01		/* Tell install it's a directory. */
#define	SETFLAGS	0x02		/* Tell install to set flags. */
#define NOCHANGEBITS	(UF_IMMUTABLE | UF_APPEND | SF_IMMUTABLE | SF_APPEND)

d109 1
a109 1
	while ((ch = getopt(argc, argv, "Ccdf:g:m:o:pSs")) != -1)
d114 6
d354 11
d446 2
a447 2
		if ((p = mmap(NULL, (size_t)size, PROT_READ,
		    MAP_PRIVATE, from_fd, (off_t)0)) == (char *)-1) {
d618 2
a619 2
usage: install [-CcpSs] [-f flags] [-g group] [-m mode] [-o owner] file1 file2\n\
       install [-CcpSs] [-f flags] [-g group] [-m mode] [-o owner] file1 ... fileN directory\n\
d658 2
d668 6
a673 1
	(void)unlink(path);
@


1.17
log
@sparse file support, ripped out of pax
@
text
@d1 1
a1 1
/*	$OpenBSD: xinstall.c,v 1.16 1998/09/26 09:04:43 deraadt Exp $	*/
d47 1
a47 1
static char rcsid[] = "$OpenBSD: xinstall.c,v 1.16 1998/09/26 09:04:43 deraadt Exp $";
d92 1
a92 1
int	file_write __P((int, char *, register int, int *, int *, int));
d394 2
a395 1
	(void)close(from_fd);
d409 1
a409 1
	register int nr, nw;
d537 4
d704 1
a704 1
	register int cnt;
d711 1
a711 1
	register int wcnt;
@


1.16
log
@more setmode() leaks -- kill 'em all
@
text
@d1 1
a1 1
/*	$OpenBSD: xinstall.c,v 1.15 1997/12/01 21:17:28 chuck Exp $	*/
d47 1
a47 1
static char rcsid[] = "$OpenBSD: xinstall.c,v 1.15 1997/12/01 21:17:28 chuck Exp $";
d83 1
a83 1
void	copy __P((int, char *, int, char *, off_t));
d92 1
d285 2
a286 1
			     safecopy ? tempfile : to_name, from_sb.st_size);
d402 1
a402 1
copy(from_fd, from_name, to_fd, to_name, size)
d406 1
a410 1
	volatile size_t siz;
d421 1
a421 1
	 * wins some CPU back.
d423 3
a425 1
	if (size <= 8 * 1048576) {
d441 18
a458 2
		while ((nr = read(from_fd, buf, sizeof(buf))) > 0)
			if ((nw = write(to_fd, buf, nr)) != nr) {
d464 1
d645 126
@


1.15
log
@use MAP_PRIVATE for mmap flags, not the non-standard MAP_FILE (aka 0)
@
text
@d1 1
a1 1
/*	$OpenBSD: xinstall.c,v 1.14 1997/06/04 05:56:26 millert Exp $	*/
d47 1
a47 1
static char rcsid[] = "$OpenBSD: xinstall.c,v 1.14 1997/06/04 05:56:26 millert Exp $";
d127 1
@


1.14
log
@If strip(1) fails it should not be a fatal error.
@
text
@d1 1
a1 1
/*	$OpenBSD: xinstall.c,v 1.13 1997/04/17 19:13:58 millert Exp $	*/
d47 1
a47 1
static char rcsid[] = "$OpenBSD: xinstall.c,v 1.13 1997/04/17 19:13:58 millert Exp $";
d422 1
a422 1
		    0, from_fd, (off_t)0)) == (char *)-1) {
@


1.13
log
@Add support for STRIP environment variable to specify where strip(1)
lives.  Idea from NetBSD.
@
text
@d1 1
a1 1
/*	$OpenBSD: xinstall.c,v 1.12 1997/03/07 01:57:08 millert Exp $	*/
d47 1
a47 1
static char rcsid[] = "$OpenBSD: xinstall.c,v 1.12 1997/03/07 01:57:08 millert Exp $";
d527 1
a527 1
		if (wait(&status) == -1 || status)
@


1.12
log
@Don't error out when chflags(2) fails if the target filesystem doesn't
support file flags.  Fix from NetBSD (minus the typo).
@
text
@d1 1
a1 1
/*	$OpenBSD: xinstall.c,v 1.11 1997/01/17 07:13:54 millert Exp $	*/
d47 1
a47 1
static char rcsid[] = "$OpenBSD: xinstall.c,v 1.11 1997/01/17 07:13:54 millert Exp $";
d512 4
d523 2
a524 2
		execl(_PATH_STRIP, "strip", to_name, NULL);
		warn("%s", _PATH_STRIP);
@


1.11
log
@r?index -> strr?chr
@
text
@d1 1
a1 1
/*	$OpenBSD: xinstall.c,v 1.10 1997/01/15 23:43:41 millert Exp $	*/
d47 1
a47 1
static char rcsid[] = "$OpenBSD: xinstall.c,v 1.10 1997/01/15 23:43:41 millert Exp $";
d386 2
a387 3
		serrno = errno;
		(void)unlink(to_name);
		errx(EX_OSERR, "%s: chflags: %s", to_name, strerror(serrno));
@


1.10
log
@getopt(3) returns -1 when out of args, not EOF, whee!
@
text
@d1 1
a1 1
/*	$OpenBSD: xinstall.c,v 1.9 1996/12/06 02:14:56 deraadt Exp $	*/
d47 1
a47 1
static char rcsid[] = "$OpenBSD: xinstall.c,v 1.9 1996/12/06 02:14:56 deraadt Exp $";
d231 1
a231 1
			    (p = rindex(from_name, '/')) ? ++p : from_name);
@


1.9
log
@warn and _exit
@
text
@d1 1
a1 1
/*	$OpenBSD: xinstall.c,v 1.8 1996/09/22 20:17:54 imp Exp $	*/
d47 1
a47 1
static char rcsid[] = "$OpenBSD: xinstall.c,v 1.8 1996/09/22 20:17:54 imp Exp $";
d106 1
a106 1
	while ((ch = getopt(argc, argv, "Ccdf:g:m:o:pSs")) != EOF)
@


1.8
log
@Pedanitic indentation: spaces -> tabs
@
text
@d1 1
a1 1
/*	$OpenBSD: xinstall.c,v 1.7 1996/08/18 22:08:31 millert Exp $	*/
d47 1
a47 1
static char rcsid[] = "$OpenBSD: xinstall.c,v 1.7 1996/08/18 22:08:31 millert Exp $";
d521 2
a522 1
		err(EX_OSERR, "%s", _PATH_STRIP);
@


1.7
log
@Rewind fd's in copy() since we may have already done a compare().
@
text
@d1 1
a1 1
/*	$OpenBSD: xinstall.c,v 1.6 1996/08/14 16:23:55 millert Exp $	*/
d47 1
a47 1
static char rcsid[] = "$OpenBSD: xinstall.c,v 1.6 1996/08/14 16:23:55 millert Exp $";
d536 10
a545 10
        register char *p;
        struct stat sb;
        int ch;

        for (p = path;; ++p)
                if (!*p || (p != path && *p  == '/')) {
                        ch = *p;
                        *p = '\0';
                        if (stat(path, &sb)) {
                                if (errno != ENOENT || mkdir(path, 0777) < 0) {
d548 3
a550 3
                                }
                        }
                        if (!(*p = ch))
d552 1
a552 1
                }
d555 3
a557 3
            chmod(path, mode)) {
                warn("%s", path);
        }
@


1.6
log
@Clean up target/tempfile if mmap or write fails (like non-mmap version)
@
text
@d1 1
a1 1
/*	$OpenBSD: xinstall.c,v 1.4 1996/08/05 01:18:42 millert Exp $	*/
d47 1
a47 1
static char rcsid[] = "$OpenBSD: xinstall.c,v 1.4 1996/08/05 01:18:42 millert Exp $";
d410 6
d499 1
a499 4
		if (dfound)
			break;

	} while (remainder > 0);
@


1.5
log
@Fixed usage sumary and order of args in man page to be consistent.
@
text
@d417 5
a421 2
		    0, from_fd, (off_t)0)) == (char *)-1)
			err(EX_OSERR, "%s", from_name);
d423 6
a428 2
		if (write(to_fd, p, siz) != siz)
			err(EX_OSERR, "%s", to_name);
@


1.4
log
@Adds -C, -p, and -S flags.  Based on FreeBSD changes but heavily
modified.
@
text
@d1 1
a1 1
/*	$OpenBSD: xinstall.c,v 1.3 1996/06/26 05:44:05 deraadt Exp $	*/
d47 1
a47 1
static char rcsid[] = "$OpenBSD: xinstall.c,v 1.3 1996/06/26 05:44:05 deraadt Exp $";
d558 2
a559 2
usage: install [-cs] [-f flags] [-g group] [-m mode] [-o owner] file1 file2\n\
       install [-cs] [-f flags] [-g group] [-m mode] [-o owner] file1 ... fileN directory\n\
@


1.3
log
@rcsid
@
text
@d1 1
a1 1
/*	$OpenBSD: xinstall.c,v 1.9 1995/12/20 10:25:17 jonathan Exp $	*/
d47 1
a47 1
static char rcsid[] = "$OpenBSD: xinstall.c,v 1.9 1995/12/20 10:25:17 jonathan Exp $";
d56 1
d66 2
a67 1
#include <err.h>
d73 1
a73 1
int docopy, dodir, dostrip;
d75 1
a75 1
char pathbuf[MAXPATHLEN];
d81 1
d84 1
d90 2
d106 1
a106 1
	while ((ch = getopt(argc, argv, "cf:g:m:o:sd")) != EOF)
d108 3
d112 1
a112 1
			docopy = 1;
d117 1
a117 1
				errx(1, "%s: invalid flag", flags);
d125 1
a125 1
				errx(1, "%s: invalid file mode", optarg);
d131 6
d150 2
a151 2
	/* copy and strip options make no sense when creating directories */
	if ((docopy || dostrip) && dodir)
d158 4
d164 2
a165 2
		errx(1, "unknown group %s", group);
	gid = (group) ? ((gp) ? gp->gr_gid : atoi(group)) : -1;
d167 2
a168 2
		errx(1, "unknown user %s", owner);
	uid = (owner) ? ((pp) ? pp->pw_uid : atoi(owner)) : -1;
d173 1
a173 1
		exit (0);
d181 2
a182 1
		exit(0);
d191 1
a191 1
			err(1, "%s", *argv);
d193 1
a193 1
			errx(1, "%s: %s", to_name, strerror(EFTYPE));
d196 1
a196 11
			errx(1, "%s and %s are the same file", *argv, to_name);
		/*
		 * Unlink now... avoid ETXTBSY errors later.  Try and turn
		 * off the append/immutable bits -- if we fail, go ahead,
		 * it might work.
		 */
#define	NOCHANGEBITS	(UF_IMMUTABLE | UF_APPEND | SF_IMMUTABLE | SF_APPEND)
		if (to_sb.st_flags & NOCHANGEBITS)
			(void)chflags(to_name,
			    to_sb.st_flags & ~(NOCHANGEBITS));
		(void)unlink(to_name);
d199 2
a200 1
	exit(0);
d214 2
a215 1
	int devnull, from_fd, to_fd, serrno;
d218 3
d224 1
a224 1
			err(1, "%s", from_name);
d226 1
a226 1
			errx(1, "%s: %s", from_name, strerror(EFTYPE));
a235 1
		from_sb.st_flags = 0;	/* XXX */
d239 23
a261 14
	/*
	 * Unlink now... avoid ETXTBSY errors later.  Try and turn
	 * off the append/immutable bits -- if we fail, go ahead,
	 * it might work.
	 */
	if (stat(to_name, &to_sb) == 0 &&
	    to_sb.st_flags & (NOCHANGEBITS))
		(void)chflags(to_name, to_sb.st_flags & ~(NOCHANGEBITS));
	(void)unlink(to_name);

	/* Create target. */
	if ((to_fd = open(to_name,
	    O_CREAT | O_WRONLY | O_TRUNC, S_IRUSR | S_IWUSR)) < 0)
		err(1, "%s", to_name);
d264 16
a279 2
			(void)unlink(to_name);
			err(1, "%s", from_name);
d281 3
a283 2
		copy(from_fd, from_name, to_fd, to_name, from_sb.st_size);
		(void)close(from_fd);
d287 1
a287 1
		strip(to_name);
d294 69
a362 2
		if ((to_fd = open(to_name, O_RDONLY, S_IRUSR | S_IWUSR)) < 0)
		  err(1, "stripping %s", to_name);
d369 1
a369 1
	if ((gid != -1 || uid != -1) && fchown(to_fd, uid, gid)) {
d372 1
a372 1
		errx(1, "%s: chown/chgrp: %s", to_name, strerror(serrno));
d377 1
a377 1
		errx(1, "%s: chmod: %s", to_name, strerror(serrno));
d388 1
a388 1
		errx(1, "%s: chflags: %s", to_name, strerror(serrno));
d392 1
a392 2
	if (!docopy && !devnull && unlink(from_name))
		err(1, "%s", from_name);
d418 1
a418 1
			err(1, "%s", from_name);
d421 2
a422 1
			err(1, "%s", to_name);
d428 1
a428 1
				errx(1, "%s: %s",
d434 1
a434 1
			errx(1, "%s: %s", from_name, strerror(serrno));
d440 55
d508 1
a508 1
		errx(1, "forks: %s", strerror(errno));
d511 1
a511 1
		err(1, "%s", _PATH_STRIP);
d536 1
a536 1
					err(1, "%s", path);
d544 1
a544 1
	if (((gid != -1 || uid != -1) && chown(path, uid, gid)) ||
d561 48
a608 1
	exit(1);
@


1.2
log
@from netbsd: some versions of strip generate a new file; thus we should
re-open the file before doing chown/chmod operations on it.
@
text
@d1 1
d47 1
a47 1
static char rcsid[] = "$NetBSD: xinstall.c,v 1.9 1995/12/20 10:25:17 jonathan Exp $";
d304 1
d315 2
a316 1
		if (write(to_fd, p, size) != size)
@


1.1
log
@Initial revision
@
text
@d1 1
a1 1
/*	$NetBSD: xinstall.c,v 1.8 1995/08/10 04:20:57 ghudson Exp $	*/
d46 1
a46 1
static char rcsid[] = "$NetBSD: xinstall.c,v 1.8 1995/08/10 04:20:57 ghudson Exp $";
d246 2
a247 1
	if (dostrip)
d249 10
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@
