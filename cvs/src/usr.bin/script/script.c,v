head	1.33;
access;
symbols
	OPENBSD_6_2:1.33.0.4
	OPENBSD_6_2_BASE:1.33
	OPENBSD_6_1:1.32.0.8
	OPENBSD_6_1_BASE:1.32
	OPENBSD_6_0:1.32.0.4
	OPENBSD_6_0_BASE:1.32
	OPENBSD_5_9:1.32.0.2
	OPENBSD_5_9_BASE:1.32
	OPENBSD_5_8:1.27.0.4
	OPENBSD_5_8_BASE:1.27
	OPENBSD_5_7:1.25.0.18
	OPENBSD_5_7_BASE:1.25
	OPENBSD_5_6:1.25.0.22
	OPENBSD_5_6_BASE:1.25
	OPENBSD_5_5:1.25.0.20
	OPENBSD_5_5_BASE:1.25
	OPENBSD_5_4:1.25.0.16
	OPENBSD_5_4_BASE:1.25
	OPENBSD_5_3:1.25.0.14
	OPENBSD_5_3_BASE:1.25
	OPENBSD_5_2:1.25.0.12
	OPENBSD_5_2_BASE:1.25
	OPENBSD_5_1_BASE:1.25
	OPENBSD_5_1:1.25.0.10
	OPENBSD_5_0:1.25.0.8
	OPENBSD_5_0_BASE:1.25
	OPENBSD_4_9:1.25.0.6
	OPENBSD_4_9_BASE:1.25
	OPENBSD_4_8:1.25.0.4
	OPENBSD_4_8_BASE:1.25
	OPENBSD_4_7:1.25.0.2
	OPENBSD_4_7_BASE:1.25
	OPENBSD_4_6:1.24.0.18
	OPENBSD_4_6_BASE:1.24
	OPENBSD_4_5:1.24.0.14
	OPENBSD_4_5_BASE:1.24
	OPENBSD_4_4:1.24.0.12
	OPENBSD_4_4_BASE:1.24
	OPENBSD_4_3:1.24.0.10
	OPENBSD_4_3_BASE:1.24
	OPENBSD_4_2:1.24.0.8
	OPENBSD_4_2_BASE:1.24
	OPENBSD_4_1:1.24.0.6
	OPENBSD_4_1_BASE:1.24
	OPENBSD_4_0:1.24.0.4
	OPENBSD_4_0_BASE:1.24
	OPENBSD_3_9:1.24.0.2
	OPENBSD_3_9_BASE:1.24
	OPENBSD_3_8:1.23.0.2
	OPENBSD_3_8_BASE:1.23
	OPENBSD_3_7:1.22.0.2
	OPENBSD_3_7_BASE:1.22
	OPENBSD_3_6:1.19.0.6
	OPENBSD_3_6_BASE:1.19
	OPENBSD_3_5:1.19.0.4
	OPENBSD_3_5_BASE:1.19
	OPENBSD_3_4:1.19.0.2
	OPENBSD_3_4_BASE:1.19
	OPENBSD_3_3:1.17.0.6
	OPENBSD_3_3_BASE:1.17
	OPENBSD_3_2:1.17.0.4
	OPENBSD_3_2_BASE:1.17
	OPENBSD_3_1:1.17.0.2
	OPENBSD_3_1_BASE:1.17
	OPENBSD_3_0:1.15.0.2
	OPENBSD_3_0_BASE:1.15
	OPENBSD_2_9_BASE:1.14
	OPENBSD_2_9:1.14.0.2
	OPENBSD_2_8:1.13.0.2
	OPENBSD_2_8_BASE:1.13
	OPENBSD_2_7:1.12.0.2
	OPENBSD_2_7_BASE:1.12
	OPENBSD_2_6:1.10.0.4
	OPENBSD_2_6_BASE:1.10
	OPENBSD_2_5:1.10.0.2
	OPENBSD_2_5_BASE:1.10
	OPENBSD_2_4:1.9.0.6
	OPENBSD_2_4_BASE:1.9
	OPENBSD_2_3:1.9.0.4
	OPENBSD_2_3_BASE:1.9
	OPENBSD_2_2:1.9.0.2
	OPENBSD_2_2_BASE:1.9
	OPENBSD_2_1:1.4.0.2
	OPENBSD_2_1_BASE:1.4
	OPENBSD_2_0:1.2.0.2
	OPENBSD_2_0_BASE:1.2
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.33
date	2017.04.12.14.49.05;	author deraadt;	state Exp;
branches;
next	1.32;
commitid	6o73BIgrp7KSeQMy;

1.32
date	2015.10.20.14.55.21;	author semarie;	state Exp;
branches;
next	1.31;
commitid	uVaNigRIdHtiSzar;

1.31
date	2015.10.09.01.37.08;	author deraadt;	state Exp;
branches;
next	1.30;
commitid	sbrB3Q5CNxcwZpfU;

1.30
date	2015.10.07.05.08.27;	author deraadt;	state Exp;
branches;
next	1.29;
commitid	gJPBv9nF2FZB1nTr;

1.29
date	2015.10.04.04.56.50;	author deraadt;	state Exp;
branches;
next	1.28;
commitid	eqnuRUvFqXxvWybg;

1.28
date	2015.10.03.02.14.51;	author deraadt;	state Exp;
branches;
next	1.27;
commitid	zwOtWLg1Hu6XqXyj;

1.27
date	2015.07.19.06.12.06;	author deraadt;	state Exp;
branches;
next	1.26;
commitid	DwLgesoTqi1eg8QF;

1.26
date	2015.03.15.00.41.28;	author millert;	state Exp;
branches;
next	1.25;
commitid	IbVxlqGw2UipKdDr;

1.25
date	2009.10.27.23.59.43;	author deraadt;	state Exp;
branches;
next	1.24;

1.24
date	2005.12.12.20.10.53;	author deraadt;	state Exp;
branches;
next	1.23;

1.23
date	2005.04.11.19.59.07;	author deraadt;	state Exp;
branches;
next	1.22;

1.22
date	2004.12.19.14.15.19;	author millert;	state Exp;
branches;
next	1.21;

1.21
date	2004.10.10.03.59.04;	author mickey;	state Exp;
branches;
next	1.20;

1.20
date	2004.09.14.23.53.07;	author deraadt;	state Exp;
branches;
next	1.19;

1.19
date	2003.06.10.22.20.50;	author deraadt;	state Exp;
branches;
next	1.18;

1.18
date	2003.06.03.02.56.15;	author millert;	state Exp;
branches;
next	1.17;

1.17
date	2002.02.16.21.27.52;	author millert;	state Exp;
branches;
next	1.16;

1.16
date	2001.11.18.23.51.57;	author deraadt;	state Exp;
branches;
next	1.15;

1.15
date	2001.07.09.07.04.52;	author deraadt;	state Exp;
branches;
next	1.14;

1.14
date	2001.01.11.19.26.01;	author deraadt;	state Exp;
branches;
next	1.13;

1.13
date	2000.06.30.16.00.20;	author millert;	state Exp;
branches;
next	1.12;

1.12
date	2000.04.16.20.28.54;	author espie;	state Exp;
branches
	1.12.2.1;
next	1.11;

1.11
date	2000.03.22.20.25.19;	author ericj;	state Exp;
branches;
next	1.10;

1.10
date	98.12.19.23.52.03;	author deraadt;	state Exp;
branches;
next	1.9;

1.9
date	97.08.06.06.43.43;	author deraadt;	state Exp;
branches;
next	1.8;

1.8
date	97.08.04.19.25.56;	author deraadt;	state Exp;
branches;
next	1.7;

1.7
date	97.07.25.22.03.08;	author mickey;	state Exp;
branches;
next	1.6;

1.6
date	97.07.25.21.05.40;	author mickey;	state Exp;
branches;
next	1.5;

1.5
date	97.06.20.09.58.03;	author deraadt;	state Exp;
branches;
next	1.4;

1.4
date	97.03.25.21.58.09;	author deraadt;	state Exp;
branches;
next	1.3;

1.3
date	97.01.15.23.43.11;	author millert;	state Exp;
branches;
next	1.2;

1.2
date	96.06.26.05.39.02;	author deraadt;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.46.05;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.46.05;	author deraadt;	state Exp;
branches;
next	;

1.12.2.1
date	2000.10.06.21.16.16;	author jason;	state Exp;
branches;
next	;


desc
@@


1.33
log
@bluhm discovered "script < /dev/null" attempts tty operations in violation
of pledge.  We can wrap isatty() around those codepaths.
ok bluhm beck
@
text
@/*	$OpenBSD: script.c,v 1.32 2015/10/20 14:55:21 semarie Exp $	*/
/*	$NetBSD: script.c,v 1.3 1994/12/21 08:55:43 jtc Exp $	*/

/*
 * Copyright (c) 2001 Theo de Raadt
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
 * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
 * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

/*
 * Copyright (c) 1980, 1992, 1993
 *	The Regents of the University of California.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */

#include <sys/types.h>
#include <sys/wait.h>
#include <sys/stat.h>
#include <sys/ioctl.h>
#include <sys/time.h>

#include <errno.h>
#include <fcntl.h>
#include <paths.h>
#include <signal.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <termios.h>
#include <unistd.h>

#include <util.h>
#include <err.h>

FILE	*fscript;
int	master, slave;
volatile sig_atomic_t child;
pid_t	subchild;
char	*fname;

volatile sig_atomic_t dead;
volatile sig_atomic_t sigdeadstatus;
volatile sig_atomic_t flush;

struct	termios tt;
int		istty;

__dead void done(int);
void dooutput(void);
void doshell(void);
void fail(void);
void finish(int);
void scriptflush(int);
void handlesigwinch(int);

int
main(int argc, char *argv[])
{
	extern char *__progname;
	struct sigaction sa;
	struct winsize win;
	char ibuf[BUFSIZ];
	ssize_t cc, off;
	int aflg, ch;

	aflg = 0;
	while ((ch = getopt(argc, argv, "a")) != -1)
		switch(ch) {
		case 'a':
			aflg = 1;
			break;
		default:
			fprintf(stderr, "usage: %s [-a] [file]\n", __progname);
			exit(1);
		}
	argc -= optind;
	argv += optind;

	if (argc > 0)
		fname = argv[0];
	else
		fname = "typescript";

	if ((fscript = fopen(fname, aflg ? "a" : "w")) == NULL)
		err(1, "%s", fname);

	if (isatty(0)) {
		if (tcgetattr(STDIN_FILENO, &tt) == 0 &&
		    ioctl(STDIN_FILENO, TIOCGWINSZ, &win) == 0)
			istty = 1;
	}
	if (openpty(&master, &slave, NULL, &tt, &win) == -1)
		err(1, "openpty");

	(void)printf("Script started, output file is %s\n", fname);
	if (istty) {
		struct termios rtt = tt;

		cfmakeraw(&rtt);
		rtt.c_lflag &= ~ECHO;
		(void)tcsetattr(STDIN_FILENO, TCSAFLUSH, &rtt);
	}

	bzero(&sa, sizeof sa);
	sigemptyset(&sa.sa_mask);
	sa.sa_handler = handlesigwinch;
	sa.sa_flags = SA_RESTART;
	(void)sigaction(SIGWINCH, &sa, NULL);

	child = fork();
	if (child < 0) {
		warn("fork");
		fail();
	}
	if (child == 0) {
		subchild = child = fork();
		if (child < 0) {
			warn("fork");
			fail();
		}
		if (child)
			dooutput();
		else
			doshell();
	}

	bzero(&sa, sizeof sa);
	sigemptyset(&sa.sa_mask);
	sa.sa_handler = finish;
	(void)sigaction(SIGCHLD, &sa, NULL);

	if (pledge("stdio proc tty", NULL) == -1)
		err(1, "pledge");

	(void)fclose(fscript);
	while (1) {
		if (dead)
			break;
		cc = read(STDIN_FILENO, ibuf, BUFSIZ);
		if (cc == -1 && errno == EINTR)
			continue;
		if (cc <= 0)
			break;
		for (off = 0; off < cc; ) {
			ssize_t n = write(master, ibuf + off, cc - off);
			if (n == -1 && errno != EAGAIN)
				break;
			if (n == 0)
				break;	/* skip writing */
			if (n > 0)
				off += n;
		}
	}
	done(sigdeadstatus);
}

/* ARGSUSED */
void
finish(int signo)
{
	int save_errno = errno;
	int status, e = 1;
	pid_t pid;

	while ((pid = wait3(&status, WNOHANG, 0)) > 0) {
		if (pid == (pid_t)child) {
			if (WIFEXITED(status))
				e = WEXITSTATUS(status);
		}
	}
	dead = 1;
	sigdeadstatus = e;
	errno = save_errno;
}

/* ARGSUSED */
void
handlesigwinch(int signo)
{
	int save_errno = errno;
	struct winsize win;
	pid_t pgrp;

	if (ioctl(STDIN_FILENO, TIOCGWINSZ, &win) != -1) {
		ioctl(slave, TIOCSWINSZ, &win);
		if (ioctl(slave, TIOCGPGRP, &pgrp) != -1)
			killpg(pgrp, SIGWINCH);
	}
	errno = save_errno;
}

void
dooutput(void)
{
	struct sigaction sa;
	struct itimerval value;
	sigset_t blkalrm;
	char obuf[BUFSIZ];
	time_t tvec;
	ssize_t outcc = 0, cc, off;

	(void)close(STDIN_FILENO);
	tvec = time(NULL);
	(void)fprintf(fscript, "Script started on %s", ctime(&tvec));

	sigemptyset(&blkalrm);
	sigaddset(&blkalrm, SIGALRM);
	bzero(&sa, sizeof sa);
	sigemptyset(&sa.sa_mask);
	sa.sa_handler = scriptflush;
	(void)sigaction(SIGALRM, &sa, NULL);

	bzero(&sa, sizeof sa);
	sigemptyset(&sa.sa_mask);
	sa.sa_handler = SIG_IGN;
	(void)sigaction(SIGCHLD, &sa, NULL);

	if (pledge("stdio proc", NULL) == -1)
		err(1, "pledge");

	value.it_interval.tv_sec = 30;
	value.it_interval.tv_usec = 0;
	value.it_value = value.it_interval;
	(void)setitimer(ITIMER_REAL, &value, NULL);
	for (;;) {
		if (flush) {
			if (outcc) {
				(void)fflush(fscript);
				outcc = 0;
			}
			flush = 0;
		}
		cc = read(master, obuf, sizeof (obuf));
		if (cc == -1 && errno == EINTR)
			continue;
		if (cc <= 0)
			break;
		sigprocmask(SIG_BLOCK, &blkalrm, NULL);
		for (off = 0; off < cc; ) {
			ssize_t n = write(STDOUT_FILENO, obuf + off, cc - off);
			if (n == -1 && errno != EAGAIN)
				break;
			if (n == 0)
				break;	/* skip writing */
			if (n > 0)
				off += n;
		}
		(void)fwrite(obuf, 1, cc, fscript);
		outcc += cc;
		sigprocmask(SIG_UNBLOCK, &blkalrm, NULL);
	}
	done(0);
}

/* ARGSUSED */
void
scriptflush(int signo)
{
	flush = 1;
}

void
doshell(void)
{
	char *shell;

	shell = getenv("SHELL");
	if (shell == NULL)
		shell = _PATH_BSHELL;

	(void)close(master);
	(void)fclose(fscript);
	login_tty(slave);
	execl(shell, shell, "-i", (char *)NULL);
	warn("%s", shell);
	fail();
}

void
fail(void)
{

	(void)kill(0, SIGTERM);
	done(1);
}

void
done(int eval)
{
	time_t tvec;

	if (subchild) {
		tvec = time(NULL);
		(void)fprintf(fscript,"\nScript done on %s", ctime(&tvec));
		(void)fclose(fscript);
		(void)close(master);
	} else {
		if (istty)
			(void)tcsetattr(STDIN_FILENO, TCSAFLUSH, &tt);
		(void)printf("Script done, output file is %s\n", fname);
	}
	exit(eval);
}
@


1.32
log
@add "proc" to pledge for script(1)

it needs to "forward" SIGWINCH to subprocesses.

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: script.c,v 1.31 2015/10/09 01:37:08 deraadt Exp $	*/
d88 1
a102 1
	struct termios rtt;
d129 5
a133 2
	(void)tcgetattr(STDIN_FILENO, &tt);
	(void)ioctl(STDIN_FILENO, TIOCGWINSZ, &win);
d138 7
a144 4
	rtt = tt;
	cfmakeraw(&rtt);
	rtt.c_lflag &= ~ECHO;
	(void)tcsetattr(STDIN_FILENO, TCSAFLUSH, &rtt);
d340 2
a341 1
		(void)tcsetattr(STDIN_FILENO, TCSAFLUSH, &tt);
@


1.31
log
@Change all tame callers to namechange to pledge(2).
@
text
@d1 1
a1 1
/*	$OpenBSD: script.c,v 1.30 2015/10/07 05:08:27 deraadt Exp $	*/
d168 1
a168 1
	if (pledge("stdio tty", NULL) == -1)
d254 1
a254 1
	if (pledge("stdio", NULL) == -1)
@


1.30
log
@move from tame "ioctl" to tame "tty", which provides a better fit for
this program which uses tcgetattr().  the tcsetattr() calls are outside
the tame regions.
@
text
@d1 1
a1 1
/*	$OpenBSD: script.c,v 1.29 2015/10/04 04:56:50 deraadt Exp $	*/
d168 2
a169 2
	if (tame("stdio tty", NULL) == -1)
		err(1, "tame");
d254 2
a255 2
	if (tame("stdio", NULL) == -1)
		err(1, "tame");
@


1.29
log
@Repair tame() error check to be == -1
@
text
@d1 1
a1 1
/*	$OpenBSD: script.c,v 1.28 2015/10/03 02:14:51 deraadt Exp $	*/
d168 1
a168 1
	if (tame("stdio ioctl", NULL) == -1)
@


1.28
log
@script is two processes.  the main io-loop process can be locked down with
tame "stdio" since all it does is move data back and forth, while the master
process needs "stdio ioctl" to use TCSAFLUSH at the very end.  TCSAFLUSH is
included in the kernel's rather restrictive ioctl feature lists made
available with the "ioctl" ability.
@
text
@d1 1
a1 1
/*	$OpenBSD: script.c,v 1.27 2015/07/19 06:12:06 deraadt Exp $	*/
d254 1
a254 1
	if (tame("stdio", NULL) != 0)
@


1.27
log
@SIGCHLD handler was established before forking into two processes.
As a result it also ran in the child (incorrect).
ok miod
@
text
@d1 1
a1 1
/*	$OpenBSD: script.c,v 1.26 2015/03/15 00:41:28 millert Exp $	*/
d168 3
d253 3
@


1.26
log
@tzfile.h is an internal header that should never have been installed.
What's worse, the tzfile.h that gets installed is over 20 years old
and doesn't match the real tzfile.h in libc/time.  This makes the
tree safe for /usr/include/tzfile.h removal.  The TM_YEAR_BASE
define has been moved to time.h temporarily until its usage is
replaced by 1900 in the tree.  Actual removal of tzfile.h is pending
a ports build.  Based on a diff from deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: script.c,v 1.25 2009/10/27 23:59:43 deraadt Exp $	*/
a141 3
	sa.sa_handler = finish;
	(void)sigaction(SIGCHLD, &sa, NULL);

d163 5
d245 5
@


1.25
log
@rcsid[] and sccsid[] and copyright[] are essentially unmaintained (and
unmaintainable).  these days, people use source.  these id's do not provide
any benefit, and do hurt the small install media
(the 33,000 line diff is essentially mechanical)
ok with the idea millert, ok dms
@
text
@d1 1
a1 1
/*	$OpenBSD: script.c,v 1.24 2005/12/12 20:10:53 deraadt Exp $	*/
a71 1
#include <tzfile.h>
d244 1
a244 1
	value.it_interval.tv_sec = SECSPERMIN / 2;
@


1.24
log
@in the write codepaths, errors other than EAGAIN are fatal to the loop; ok otto
@
text
@d1 1
a1 1
/*	$OpenBSD: script.c,v 1.23 2005/04/11 19:59:07 deraadt Exp $	*/
a56 13

#ifndef lint
static const char copyright[] =
"@@(#) Copyright (c) 1980, 1992, 1993\n\
	The Regents of the University of California.  All rights reserved.\n";
#endif /* not lint */

#ifndef lint
#if 0
static const char sccsid[] = "@@(#)script.c	8.1 (Berkeley) 6/6/93";
#endif
static const char rcsid[] = "$OpenBSD: script.c,v 1.23 2005/04/11 19:59:07 deraadt Exp $";
#endif /* not lint */
@


1.23
log
@use STDERR_FILENO; ok cloder
@
text
@d1 1
a1 1
/*	$OpenBSD: script.c,v 1.22 2004/12/19 14:15:19 millert Exp $	*/
d68 1
a68 1
static const char rcsid[] = "$OpenBSD: script.c,v 1.22 2004/12/19 14:15:19 millert Exp $";
d191 2
d278 2
@


1.22
log
@Block SIGALRM during write--we only want it to interrupt read().
OK deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: script.c,v 1.21 2004/10/10 03:59:04 mickey Exp $	*/
d68 1
a68 1
static const char rcsid[] = "$OpenBSD: script.c,v 1.21 2004/10/10 03:59:04 mickey Exp $";
d275 1
a275 1
			ssize_t n = write(1, obuf + off, cc - off);
@


1.21
log
@use err/warn and __progname
@
text
@d1 1
a1 1
/*	$OpenBSD: script.c,v 1.20 2004/09/14 23:53:07 deraadt Exp $	*/
d68 1
a68 1
static const char rcsid[] = "$OpenBSD: script.c,v 1.20 2004/09/14 23:53:07 deraadt Exp $";
d240 1
d249 2
d273 1
d283 1
@


1.20
log
@ARGSUSED before signal handler with unused signo
@
text
@d1 1
a1 1
/*	$OpenBSD: script.c,v 1.19 2003/06/10 22:20:50 deraadt Exp $	*/
d59 1
a59 1
static char copyright[] =
d66 1
a66 1
static char sccsid[] = "@@(#)script.c	8.1 (Berkeley) 6/6/93";
d68 1
a68 1
static char rcsid[] = "$OpenBSD: script.c,v 1.19 2003/06/10 22:20:50 deraadt Exp $";
d114 1
d129 1
a129 1
			(void)fprintf(stderr, "usage: script [-a] [file]\n");
d165 1
a165 1
		perror("fork");
d171 1
a171 1
			perror("fork");
d303 1
a303 1
	perror(shell);
@


1.19
log
@mostly ansi cleanup; pval ok
@
text
@d1 1
a1 1
/*	$OpenBSD: script.c,v 1.18 2003/06/03 02:56:15 millert Exp $	*/
d68 1
a68 1
static char rcsid[] = "$OpenBSD: script.c,v 1.18 2003/06/03 02:56:15 millert Exp $";
d93 2
a94 1
pid_t	child, subchild;
d199 1
d208 1
a208 1
		if (pid == child) {
d218 1
d282 1
@


1.18
log
@Remove the advertising clause in the UCB license which Berkeley
rescinded 22 July 1999.  Proofed by myself and Theo.
@
text
@d1 1
a1 1
/*	$OpenBSD: script.c,v 1.17 2002/02/16 21:27:52 millert Exp $	*/
d68 1
a68 1
static char rcsid[] = "$OpenBSD: script.c,v 1.17 2002/02/16 21:27:52 millert Exp $";
d111 1
a111 3
main(argc, argv)
	int argc;
	char *argv[];
d199 1
a199 2
finish(signo)
	int signo;
d217 1
a217 2
handlesigwinch(signo)
	int signo;
d232 1
a232 1
dooutput()
d280 1
a280 2
scriptflush(signo)
	int signo;
d286 1
a286 1
doshell()
d303 1
a303 1
fail()
d311 1
a311 2
done(eval)
	int eval;
@


1.17
log
@Part one of userland __P removal.  Done with a simple regexp with some minor hand editing to make comments line up correctly.  Another pass is forthcoming that handles the cases that could not be done automatically.
@
text
@d1 1
a1 1
/*	$OpenBSD: script.c,v 1.16 2001/11/18 23:51:57 deraadt Exp $	*/
d41 1
a41 5
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
d68 1
a68 1
static char rcsid[] = "$OpenBSD: script.c,v 1.16 2001/11/18 23:51:57 deraadt Exp $";
@


1.16
log
@After a simplistic rewrite, signal flags were not being noticed until a
succesfull read operation.  To avoid this, we must use SA_RESTART, and
rewrite most of the guts to handle interrupted read, write, etc, even being
careful to check what library routines are called.... input from millert,
markus, and espie
@
text
@d1 1
a1 1
/*	$OpenBSD: script.c,v 1.15 2001/07/09 07:04:52 deraadt Exp $	*/
d72 1
a72 1
static char rcsid[] = "$OpenBSD: script.c,v 1.15 2001/07/09 07:04:52 deraadt Exp $";
d106 7
a112 7
__dead void done __P((int));
void dooutput __P((void));
void doshell __P((void));
void fail __P((void));
void finish __P((int));
void scriptflush __P((int));
void handlesigwinch __P((int));
@


1.15
log
@correct type on last arg to execl(); nordin@@cse.ogi.edu
@
text
@d1 1
a1 1
/*	$OpenBSD: script.c,v 1.14 2001/01/11 19:26:01 deraadt Exp $	*/
d5 25
d72 1
a72 1
static char rcsid[] = "$OpenBSD: script.c,v 1.14 2001/01/11 19:26:01 deraadt Exp $";
d97 1
a97 2
int	child, subchild;
int	outcc;
d100 4
d106 7
a112 8
__dead	void done __P((int));
	void dooutput __P((void));
	void doshell __P((void));
	void fail __P((void));
	void finish __P((int));
	void scriptflush __P((int));
	void handlesigwinch __P((int));

d119 1
a119 1
	register int cc;
d122 2
a124 1
	char ibuf[BUFSIZ];
a131 1
		case '?':
d158 9
a166 2
	(void)signal(SIGWINCH, handlesigwinch);
	(void)signal(SIGCHLD, finish);
d185 17
a201 3
	while ((cc = read(STDIN_FILENO, ibuf, BUFSIZ)) > 0)
		(void)write(master, ibuf, cc);
	done(0);
a207 1
	register int die, pid;
d209 2
a210 1
	int status, e;
d212 1
a212 2
	die = e = 0;
	while ((pid = wait3(&status, WNOHANG, 0)) > 0)
a213 1
			die = 1;
d215 1
a215 3
                                e = WEXITSTATUS(status);
                        else
                                e = 1;
d217 3
a219 3

	if (die)
		done(e);
d227 1
a229 1
	int save_errno = errno;
d232 3
a234 3
	    ioctl(slave, TIOCSWINSZ, &win);
	    if (ioctl(slave, TIOCGPGRP, &pgrp) != -1)
	    	killpg(pgrp, SIGWINCH);
d242 1
d244 1
a244 1
	register int cc;
d246 1
a246 1
	char obuf[BUFSIZ];
d252 5
a256 1
	(void)signal(SIGALRM, scriptflush);
d262 7
d270 2
d274 7
a280 1
		(void)write(1, obuf, cc);
a286 1
/* XXX totally illegal race */
d291 1
a291 7
	int save_errno = errno;

	if (outcc) {
		(void)fflush(fscript);
		outcc = 0;
	}
	errno = save_errno;
a335 1

@


1.14
log
@comment on a real nasty race
@
text
@d1 1
a1 1
/*	$OpenBSD: script.c,v 1.13 2000/06/30 16:00:20 millert Exp $	*/
d47 1
a47 1
static char rcsid[] = "$OpenBSD: script.c,v 1.13 2000/06/30 16:00:20 millert Exp $";
d249 1
a249 1
	execl(shell, shell, "-i", NULL);
@


1.13
log
@warnx?/errx? paranoia (use "%s" not a bare string unless it is a
constant).  These are not security holes but it is worth fixing
them anyway both for robustness and so folks looking for examples
in the tree are not misled into doing something potentially dangerous.
Furthermore, it is a bad idea to assume that pathnames will not
include '%' in them and that error routines don't return strings
with '%' in them (especially in light of the possibility of locales).
@
text
@d1 1
a1 1
/*	$OpenBSD: script.c,v 1.12 2000/04/16 20:28:54 espie Exp $	*/
d47 1
a47 1
static char rcsid[] = "$OpenBSD: script.c,v 1.12 2000/04/16 20:28:54 espie Exp $";
d223 1
@


1.12
log
@Propagate window size changes to slave.
@
text
@d1 1
a1 1
/*	$OpenBSD: script.c,v 1.11 2000/03/22 20:25:19 ericj Exp $	*/
d47 1
a47 1
static char rcsid[] = "$OpenBSD: script.c,v 1.11 2000/03/22 20:25:19 ericj Exp $";
d118 1
a118 1
		err(1, fname);
@


1.12.2.1
log
@Pull in patch from current (even more to come):
Fix (millert):
warnx?/errx? paranoia (use "%s" not a bare string unless it is a
constant).  These are not security holes but it is worth fixing
them anyway both for robustness and so folks looking for examples
in the tree are not misled into doing something potentially dangerous.
Furthermore, it is a bad idea to assume that pathnames will not
include '%' in them and that error routines don't return strings
with '%' in them (especially in light of the possibility of locales).
@
text
@d1 1
a1 1
/*	$OpenBSD: script.c,v 1.13 2000/06/30 16:00:20 millert Exp $	*/
d47 1
a47 1
static char rcsid[] = "$OpenBSD: script.c,v 1.13 2000/06/30 16:00:20 millert Exp $";
d118 1
a118 1
		err(1, "%s", fname);
@


1.11
log
@Make script give correct return values; adapted from FreeBSD
@
text
@d1 1
a1 1
/*	$OpenBSD: script.c,v 1.10 1998/12/19 23:52:03 deraadt Exp $	*/
d47 1
a47 1
static char rcsid[] = "$OpenBSD: script.c,v 1.10 1998/12/19 23:52:03 deraadt Exp $";
d84 2
d131 1
d176 16
@


1.10
log
@union wait is wrong; christos
@
text
@d1 1
a1 1
/*	$OpenBSD: script.c,v 1.9 1997/08/06 06:43:43 deraadt Exp $	*/
d47 1
a47 1
static char rcsid[] = "$OpenBSD: script.c,v 1.9 1997/08/06 06:43:43 deraadt Exp $";
d78 1
a78 1
__dead	void done __P((void));
d150 1
a150 2
	done();
	exit(0);
d159 1
a159 1
	int status;
d161 1
a161 1
	die = 0;
d163 1
a163 1
		if (pid == child)
d165 5
d172 1
a172 1
		done();
d201 1
a201 1
	done();
d239 1
a239 1
	done();
d243 2
a244 1
done()
d257 1
a257 1
	exit(0);
@


1.9
log
@save errno in mangly handlers
@
text
@d1 1
a1 1
/*	$OpenBSD: script.c,v 1.8 1997/08/04 19:25:56 deraadt Exp $	*/
d47 1
a47 1
static char rcsid[] = "$OpenBSD: script.c,v 1.8 1997/08/04 19:25:56 deraadt Exp $";
d160 1
a160 1
	union wait status;
d163 1
a163 1
	while ((pid = wait3((int *)&status, WNOHANG, 0)) > 0)
@


1.8
log
@save errno in sigchld handlers
@
text
@d1 1
a1 1
/*	$OpenBSD: script.c,v 1.7 1997/07/25 22:03:08 mickey Exp $	*/
d47 1
a47 1
static char rcsid[] = "$OpenBSD: script.c,v 1.7 1997/07/25 22:03:08 mickey Exp $";
d204 2
d210 1
@


1.7
log
@user err(3)
@
text
@d1 1
a1 1
/*	$OpenBSD: script.c,v 1.6 1997/07/25 21:05:40 mickey Exp $	*/
d47 1
a47 1
static char rcsid[] = "$OpenBSD: script.c,v 1.6 1997/07/25 21:05:40 mickey Exp $";
d159 1
d169 1
@


1.6
log
@#if __STDC__ --> #ifdef __STDC__
@
text
@d1 1
a1 1
/*	$OpenBSD: script.c,v 1.5 1997/06/20 09:58:03 deraadt Exp $	*/
d47 1
a47 1
static char rcsid[] = "$OpenBSD: script.c,v 1.5 1997/06/20 09:58:03 deraadt Exp $";
d68 1
a80 1
	void err __P((const char *, ...));
d116 1
a116 1
		err("%s: %s", fname, strerror(errno));
d121 1
a121 1
		err("openpty: %s", strerror(errno));
a249 28
#ifdef __STDC__
#include <stdarg.h>
#else
#include <varargs.h>
#endif

void
#ifdef __STDC__
err(const char *fmt, ...)
#else
err(fmt, va_alist)
	char *fmt;
	va_dcl
#endif
{
	va_list ap;
#ifdef __STDC__
	va_start(ap, fmt);
#else
	va_start(ap);
#endif
	(void)fprintf(stderr, "script: ");
	(void)vfprintf(stderr, fmt, ap);
	va_end(ap);
	(void)fprintf(stderr, "\n");
	exit(1);
	/* NOTREACHED */
}
@


1.5
log
@Wall
@
text
@d1 1
a1 1
/*	$OpenBSD: script.c,v 1.4 1997/03/25 21:58:09 deraadt Exp $	*/
d47 1
a47 1
static char rcsid[] = "$OpenBSD: script.c,v 1.4 1997/03/25 21:58:09 deraadt Exp $";
d250 1
a250 1
#if __STDC__
d257 1
a257 1
#if __STDC__
d266 1
a266 1
#if __STDC__
@


1.4
log
@exec with argv[0] as shell, not "sh"; era@@iki.fi
@
text
@d1 1
a1 1
/*	$OpenBSD: script.c,v 1.3 1997/01/15 23:43:11 millert Exp $	*/
d47 1
a47 1
static char rcsid[] = "$OpenBSD: script.c,v 1.3 1997/01/15 23:43:11 millert Exp $";
d67 2
d151 1
@


1.3
log
@getopt(3) returns -1 when out of args, not EOF, whee!
@
text
@d1 1
a1 1
/*	$OpenBSD: script.c,v 1.2 1996/06/26 05:39:02 deraadt Exp $	*/
d47 1
a47 1
static char rcsid[] = "$OpenBSD: script.c,v 1.2 1996/06/26 05:39:02 deraadt Exp $";
d217 1
a217 1
	execl(shell, "sh", "-i", NULL);
@


1.2
log
@rcsid
@
text
@d1 1
a1 1
/*	$OpenBSD: script.c,v 1.3 1994/12/21 08:55:43 jtc Exp $	*/
d47 1
a47 1
static char rcsid[] = "$OpenBSD: script.c,v 1.3 1994/12/21 08:55:43 jtc Exp $";
d95 1
a95 1
	while ((ch = getopt(argc, argv, "a")) != EOF)
@


1.1
log
@Initial revision
@
text
@d1 1
d47 1
a47 1
static char rcsid[] = "$NetBSD: script.c,v 1.3 1994/12/21 08:55:43 jtc Exp $";
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@
