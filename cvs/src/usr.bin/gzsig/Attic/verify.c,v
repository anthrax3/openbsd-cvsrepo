head	1.11;
access;
symbols
	OPENBSD_5_6:1.10.0.8
	OPENBSD_5_6_BASE:1.10
	OPENBSD_5_5:1.10.0.6
	OPENBSD_5_5_BASE:1.10
	OPENBSD_5_4:1.10.0.2
	OPENBSD_5_4_BASE:1.10
	OPENBSD_5_3:1.7.0.22
	OPENBSD_5_3_BASE:1.7
	OPENBSD_5_2:1.7.0.20
	OPENBSD_5_2_BASE:1.7
	OPENBSD_5_1_BASE:1.7
	OPENBSD_5_1:1.7.0.18
	OPENBSD_5_0:1.7.0.16
	OPENBSD_5_0_BASE:1.7
	OPENBSD_4_9:1.7.0.14
	OPENBSD_4_9_BASE:1.7
	OPENBSD_4_8:1.7.0.12
	OPENBSD_4_8_BASE:1.7
	OPENBSD_4_7:1.7.0.8
	OPENBSD_4_7_BASE:1.7
	OPENBSD_4_6:1.7.0.10
	OPENBSD_4_6_BASE:1.7
	OPENBSD_4_5:1.7.0.6
	OPENBSD_4_5_BASE:1.7
	OPENBSD_4_4:1.7.0.4
	OPENBSD_4_4_BASE:1.7
	OPENBSD_4_3:1.7.0.2
	OPENBSD_4_3_BASE:1.7
	OPENBSD_4_2:1.6.0.6
	OPENBSD_4_2_BASE:1.6
	OPENBSD_4_1:1.6.0.4
	OPENBSD_4_1_BASE:1.6
	OPENBSD_4_0:1.6.0.2
	OPENBSD_4_0_BASE:1.6
	OPENBSD_3_9:1.5.0.4
	OPENBSD_3_9_BASE:1.5
	OPENBSD_3_8:1.5.0.2
	OPENBSD_3_8_BASE:1.5
	marius_20050527:1.1.1.1
	marius:1.1.1;
locks; strict;
comment	@ * @;


1.11
date	2014.10.07.19.37.05;	author tedu;	state dead;
branches;
next	1.10;
commitid	MetHYPACdgkY3VHt;

1.10
date	2013.03.10.10.36.57;	author tobias;	state Exp;
branches;
next	1.9;

1.9
date	2013.03.09.22.36.44;	author jmc;	state Exp;
branches;
next	1.8;

1.8
date	2013.03.09.21.08.37;	author tobias;	state Exp;
branches;
next	1.7;

1.7
date	2007.10.12.19.52.06;	author jasper;	state Exp;
branches;
next	1.6;

1.6
date	2006.04.17.09.36.56;	author moritz;	state Exp;
branches;
next	1.5;

1.5
date	2005.08.05.14.17.55;	author jmc;	state Exp;
branches;
next	1.4;

1.4
date	2005.05.29.08.37.52;	author djm;	state Exp;
branches;
next	1.3;

1.3
date	2005.05.29.07.34.34;	author djm;	state Exp;
branches;
next	1.2;

1.2
date	2005.05.28.08.07.45;	author marius;	state Exp;
branches;
next	1.1;

1.1
date	2005.05.28.01.57.30;	author marius;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2005.05.28.01.57.30;	author marius;	state Exp;
branches;
next	;


desc
@@


1.11
log
@remove gzsig. we have no use for this now.
@
text
@/* $OpenBSD: verify.c,v 1.10 2013/03/10 10:36:57 tobias Exp $ */

/*
 * verify.c
 *
 * Copyright (c) 2001 Dug Song <dugsong@@arbor.net>
 * Copyright (c) 2001 Arbor Networks, Inc.
 *
 *   Redistribution and use in source and binary forms, with or without
 *   modification, are permitted provided that the following conditions
 *   are met:
 * 
 *   1. Redistributions of source code must retain the above copyright
 *      notice, this list of conditions and the following disclaimer.
 *   2. Redistributions in binary form must reproduce the above copyright
 *      notice, this list of conditions and the following disclaimer in the
 *      documentation and/or other materials provided with the distribution.
 *   3. The names of the copyright holders may not be used to endorse or
 *      promote products derived from this software without specific
 *      prior written permission.
 * 
 *   THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES,
 *   INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY
 *   AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL
 *   THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 *   EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 *   PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;
 *   OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
 *   WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
 *   OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF
 *   ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 * $Vendor: verify.c,v 1.3 2005/04/07 23:19:35 dugsong Exp $
 */

#include <sys/types.h>

#include <openssl/ssl.h>
#include <openssl/evp.h>
#include <openssl/sha.h>

#include <errno.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>

#include "extern.h"
#include "gzip.h"
#include "key.h"
#include "util.h"

static int
verify_signature(struct key *key, FILE *fin)
{
	struct gzip_header gh;
	struct gzip_xfield *gx;
	struct gzsig_data *gd;
	u_char *sig, digest[20], buf[8192], sbuf[4096];
	SHA_CTX ctx;
	int i, siglen;

	/* Read gzip header. */
	if ((i = fread((u_char *)&gh, 1, sizeof(gh), fin)) != sizeof(gh)) {
		fprintf(stderr, "Error reading gzip header: %s\n",
		    strerror(errno));
		return (-1);
	}
	/* Verify gzip header. */
	if (memcmp(gh.magic, GZIP_MAGIC, sizeof(gh.magic)) != 0) {
		fprintf(stderr, "Invalid gzip file\n");
		return (-1);
	} else if (gh.flags & GZIP_FCONT){
		fprintf(stderr, "Multi-part gzip files not supported\n");
		return (-1);
	} else if ((gh.flags & GZIP_FEXTRA) == 0) {
		fprintf(stderr, "No gzip signature found\n");
		return (-1);
	}
	/* Read signature. */
	gx = (struct gzip_xfield *)buf;
	
	if ((i = fread((u_char *)gx, 1, sizeof(*gx), fin)) != sizeof(*gx)) {
		fprintf(stderr, "Error reading extra field: %s\n",
		    strerror(errno));
		return (-1);
	}
	if (memcmp(gx->subfield.id, GZSIG_ID, sizeof(gx->subfield.id)) != 0) {
		fprintf(stderr, "Unknown extra field\n");
		return (-1);
	}
	gx->subfield.len = letoh16(gx->subfield.len);

	if (gx->subfield.len <= 0 || gx->subfield.len > sizeof(sbuf)) {
		fprintf(stderr, "Invalid signature length\n");
		return (-1);
	}
	gd = (struct gzsig_data *)sbuf;
	
	if ((i = fread((u_char *)gd, 1, gx->subfield.len, fin)) !=
	    gx->subfield.len) {
		fprintf(stderr, "Error reading signature: %s\n",
		    strerror(errno));
		return (-1);
	}
	/* Skip over any options. */
	if (gh.flags & GZIP_FNAME) {
		if (skip_string(fin))
			return (-1);
	}
	if (gh.flags & GZIP_FCOMMENT) {
		if (skip_string(fin))
			return (-1);
	}
	if (gh.flags & GZIP_FENCRYPT &&
	    fread(buf, 1, GZIP_FENCRYPT_LEN, fin) != GZIP_FENCRYPT_LEN)
		return (-1);
	
	/* Check signature version. */
	if (gd->version != GZSIG_VERSION) {
		fprintf(stderr, "Unknown signature version: %d\n",
		    gd->version);
		return (-1);
	}
	/* Compute SHA1 checksum over compressed data and trailer. */
	sig = (u_char *)(gd + 1);
	siglen = gx->subfield.len - sizeof(*gd);

	SHA1_Init(&ctx);
	
	while ((i = fread(buf, 1, sizeof(buf), fin)) > 0) {
		SHA1_Update(&ctx, buf, i);
	}
	SHA1_Final(digest, &ctx);
	
	/* Verify signature. */
	if (key_verify(key, digest, sizeof(digest), sig, siglen) < 0) {
		fprintf(stderr, "Error verifying signature\n");
		return (-1);
	}
	return (0);
}

void
verify_usage(void)
{
	fprintf(stderr, "usage: %s verify [-q | -v] [-f secret_file] pubkey "
	    "[file ...]\n", __progname);
}

void
verify(int argc, char *argv[])
{
	struct key *key;
	char *gzipfile;
	FILE *fin;
	int i, error, qflag;

	qflag = 0;
	
	while ((i = getopt(argc, argv, "qv")) != -1) {
		switch (i) {
		case 'q':
			qflag = 1;
			break;
		case 'v':
			qflag = 0;
			break;
		default:
			verify_usage();
			exit(1);
		}
	}
	argc -= optind;
	argv += optind;

	if (argc < 1) {
		verify_usage();
		exit(1);
	}
	OpenSSL_add_all_algorithms();
	
	if ((key = key_new()) == NULL)
		fatal(1, "Can't initialize public key");
	
	if (key_load_public(key, argv[0]) < 0)
		fatal(1, "Can't load public key");

	if (argc == 1 || *argv[1] == '-') {
		argc = 0;
		
		if (verify_signature(key, stdin) == 0) {
			if (!qflag)
				fprintf(stderr, "Verified input\n");
		} else
			fatal(1, "Couldn't verify input");
	}
	for (i = 1; i < argc; i++) {
		gzipfile = argv[i];

		if ((fin = fopen(gzipfile, "r")) == NULL) {
			fprintf(stderr,  "Couldn't open %s: %s\n",
			    gzipfile, strerror(errno));
			continue;
		}
		error = verify_signature(key, fin);
		fclose(fin);

		if (!error) {
			if (!qflag)
				fprintf(stderr, "Verified %s\n", gzipfile);
		} else
			fatal(1, "Couldn't verify %s", gzipfile);
	}
	key_free(key);
}
@


1.10
log
@Prevent endless loop on input error.
@
text
@d1 1
a1 1
/* $OpenBSD: verify.c,v 1.9 2013/03/09 22:36:44 jmc Exp $ */
@


1.9
log
@Usage -> usage;
@
text
@d1 1
a1 1
/* $OpenBSD: verify.c,v 1.8 2013/03/09 21:08:37 tobias Exp $ */
d108 2
a109 2
		while (getc(fin) != '\0')
			;
d112 2
a113 2
		while (getc(fin) != '\0')
			;
@


1.8
log
@Mention -v in manpage and usage.
With input from jmc.

ok jmc
@
text
@d1 1
a1 1
/* $OpenBSD: verify.c,v 1.7 2007/10/12 19:52:06 jasper Exp $ */
d147 1
a147 1
	fprintf(stderr, "Usage: %s verify [-q | -v] [-f secret_file] pubkey "
@


1.7
log
@use __progname where needed

ok otto@@
@
text
@d1 1
a1 1
/* $OpenBSD: verify.c,v 1.6 2006/04/17 09:36:56 moritz Exp $ */
d147 2
a148 2
	fprintf(stderr, "Usage: %s verify [-q] [-f secret_file] pubkey [file ...]\n",
	    __progname);
@


1.6
log
@Remove useless "h" and "?" from getopt(3) string.
From Steffen Wendzel. ok marius@@
@
text
@d1 1
a1 1
/* $OpenBSD: verify.c,v 1.5 2005/08/05 14:17:55 jmc Exp $ */
d147 2
a148 1
	fprintf(stderr, "Usage: gzsig verify [-q] [-f secret_file] pubkey [file ...]\n");
@


1.5
log
@- -f valid for gzsig sign too
- tidy up SYNOPSIS and AUTHORS
- sort options
- sync usage()
@
text
@d1 1
a1 1
/* $OpenBSD: verify.c,v 1.4 2005/05/29 08:37:52 djm Exp $ */
d160 1
a160 1
	while ((i = getopt(argc, argv, "qvh?")) != -1) {
@


1.4
log
@fix NULL ptr deref on open fail; ok marius@@
@
text
@d1 1
a1 1
/* $OpenBSD: verify.c,v 1.3 2005/05/29 07:34:34 djm Exp $ */
d147 1
a147 1
	fprintf(stderr, "Usage: gzsig verify [-q] pubkey [file ...]\n");
@


1.3
log
@provide feedback on success; ok marius@@
@
text
@d1 1
a1 1
/* $OpenBSD: verify.c,v 1.2 2005/05/28 08:07:45 marius Exp $ */
d200 1
a200 1
		if ((fin = fopen(gzipfile, "r")) < 0) {
@


1.2
log
@whoops.  the import killed the $Id$ tags; rectify.
@
text
@d1 1
a1 1
/* $OpenBSD: verify.c,v 1.1.1.1 2005/05/28 01:57:30 marius Exp $ */
d147 1
a147 1
	fprintf(stderr, "Usage: gzsig verify [-v] pubkey [file ...]\n");
d156 1
a156 1
	int i, error, vflag;
d158 1
a158 1
	vflag = 0;
d160 1
a160 1
	while ((i = getopt(argc, argv, "vh?")) != -1) {
d162 3
d166 1
a166 1
			vflag = 1;
d192 1
a192 1
			if (vflag)
d209 1
a209 1
			if (vflag)
@


1.1
log
@Initial revision
@
text
@d1 1
a1 1
/* $OpenBSD$ */
d33 1
a33 1
 * $Id: verify.c,v 1.3 2005/04/07 23:19:35 dugsong Exp $
@


1.1.1.1
log
@import gzsig by Dug Song.  

a bunch of lumberjack work, zapped support for keynote 
and SSH1 and added support for SSH2 keys.

ok millert@@ deraadt@@
@
text
@@
