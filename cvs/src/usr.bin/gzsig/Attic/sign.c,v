head	1.15;
access;
symbols
	OPENBSD_5_6:1.13.0.8
	OPENBSD_5_6_BASE:1.13
	OPENBSD_5_5:1.13.0.6
	OPENBSD_5_5_BASE:1.13
	OPENBSD_5_4:1.13.0.2
	OPENBSD_5_4_BASE:1.13
	OPENBSD_5_3:1.9.0.22
	OPENBSD_5_3_BASE:1.9
	OPENBSD_5_2:1.9.0.20
	OPENBSD_5_2_BASE:1.9
	OPENBSD_5_1_BASE:1.9
	OPENBSD_5_1:1.9.0.18
	OPENBSD_5_0:1.9.0.16
	OPENBSD_5_0_BASE:1.9
	OPENBSD_4_9:1.9.0.14
	OPENBSD_4_9_BASE:1.9
	OPENBSD_4_8:1.9.0.12
	OPENBSD_4_8_BASE:1.9
	OPENBSD_4_7:1.9.0.8
	OPENBSD_4_7_BASE:1.9
	OPENBSD_4_6:1.9.0.10
	OPENBSD_4_6_BASE:1.9
	OPENBSD_4_5:1.9.0.6
	OPENBSD_4_5_BASE:1.9
	OPENBSD_4_4:1.9.0.4
	OPENBSD_4_4_BASE:1.9
	OPENBSD_4_3:1.9.0.2
	OPENBSD_4_3_BASE:1.9
	OPENBSD_4_2:1.7.0.6
	OPENBSD_4_2_BASE:1.7
	OPENBSD_4_1:1.7.0.4
	OPENBSD_4_1_BASE:1.7
	OPENBSD_4_0:1.7.0.2
	OPENBSD_4_0_BASE:1.7
	OPENBSD_3_9:1.6.0.4
	OPENBSD_3_9_BASE:1.6
	OPENBSD_3_8:1.6.0.2
	OPENBSD_3_8_BASE:1.6
	marius_20050527:1.1.1.1
	marius:1.1.1;
locks; strict;
comment	@ * @;


1.15
date	2014.10.07.19.37.05;	author tedu;	state dead;
branches;
next	1.14;
commitid	MetHYPACdgkY3VHt;

1.14
date	2014.08.25.07.50.26;	author doug;	state Exp;
branches;
next	1.13;
commitid	vcwz0sp1JH7QzUmA;

1.13
date	2013.03.10.10.36.57;	author tobias;	state Exp;
branches;
next	1.12;

1.12
date	2013.03.10.10.34.33;	author tobias;	state Exp;
branches;
next	1.11;

1.11
date	2013.03.09.22.36.44;	author jmc;	state Exp;
branches;
next	1.10;

1.10
date	2013.03.09.21.08.37;	author tobias;	state Exp;
branches;
next	1.9;

1.9
date	2007.10.12.19.52.06;	author jasper;	state Exp;
branches;
next	1.8;

1.8
date	2007.09.11.15.47.17;	author gilles;	state Exp;
branches;
next	1.7;

1.7
date	2006.04.17.09.36.56;	author moritz;	state Exp;
branches;
next	1.6;

1.6
date	2005.08.05.14.17.55;	author jmc;	state Exp;
branches;
next	1.5;

1.5
date	2005.05.29.09.10.23;	author djm;	state Exp;
branches;
next	1.4;

1.4
date	2005.05.29.08.54.13;	author djm;	state Exp;
branches;
next	1.3;

1.3
date	2005.05.29.07.34.34;	author djm;	state Exp;
branches;
next	1.2;

1.2
date	2005.05.28.08.07.45;	author marius;	state Exp;
branches;
next	1.1;

1.1
date	2005.05.28.01.57.30;	author marius;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2005.05.28.01.57.30;	author marius;	state Exp;
branches;
next	;


desc
@@


1.15
log
@remove gzsig. we have no use for this now.
@
text
@/* $OpenBSD: sign.c,v 1.14 2014/08/25 07:50:26 doug Exp $ */

/*
 * sign.c
 *
 * Copyright (c) 2001 Dug Song <dugsong@@arbor.net>
 * Copyright (c) 2001 Arbor Networks, Inc.
 *
 *   Redistribution and use in source and binary forms, with or without
 *   modification, are permitted provided that the following conditions
 *   are met:
 * 
 *   1. Redistributions of source code must retain the above copyright
 *      notice, this list of conditions and the following disclaimer.
 *   2. Redistributions in binary form must reproduce the above copyright
 *      notice, this list of conditions and the following disclaimer in the
 *      documentation and/or other materials provided with the distribution.
 *   3. The names of the copyright holders may not be used to endorse or
 *      promote products derived from this software without specific
 *      prior written permission.
 * 
 *   THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES,
 *   INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY
 *   AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL
 *   THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 *   EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 *   PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;
 *   OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
 *   WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
 *   OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF
 *   ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 * $Vendor: sign.c,v 1.2 2005/04/01 16:47:31 dugsong Exp $
 */

#include <sys/param.h>
#include <sys/types.h>
#include <sys/stat.h>

#include <openssl/ssl.h>
#include <openssl/evp.h>
#include <openssl/sha.h>

#include <errno.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <err.h>

#include "extern.h"
#include "gzip.h"
#include "key.h"
#include "util.h"

static char *passphrase_file = NULL;

static int
embed_signature(struct key *key, FILE *fin, FILE *fout)
{
	struct gzip_header gh;
	struct gzip_xfield *gx;
	struct gzsig_data *gd;
	u_char *sig, digest[20], buf[8192];
	SHA_CTX ctx;
	int i, siglen;
	long offset;

	/* Read gzip header. */
	if (fread((u_char *)&gh, 1, sizeof(gh), fin) != sizeof(gh)) {
		fprintf(stderr, "Error reading gzip header: %s\n",
		    strerror(errno));
		return (-1);
	}
	/* Verify gzip header. */
	if (memcmp(gh.magic, GZIP_MAGIC, sizeof(gh.magic)) != 0) {
		fprintf(stderr, "Invalid gzip file\n");
		return (-1);
	}
	if (gh.flags & GZIP_FCONT) {
		fprintf(stderr, "Multi-part gzip files not supported\n");
		return (-1);
	}
	/* Skip over any existing signature. */
	if (gh.flags & GZIP_FEXTRA) {
		gx = (struct gzip_xfield *)buf;
		gd = (struct gzsig_data *)(gx + 1);

		if (fread((u_char *)gx, 1, sizeof(*gx), fin) != sizeof(*gx)) {
			fprintf(stderr, "Error reading extra field: %s\n",
			    strerror(errno));
			return (-1);
		}
		if (memcmp(gx->subfield.id, GZSIG_ID, 2) != 0) {
			fprintf(stderr, "Unknown extra field\n");
			return (-1);
		}
		gx->subfield.len = letoh16(gx->subfield.len);
		
		if (gx->subfield.len < sizeof(*gd) ||
		    gx->subfield.len > sizeof(buf) - sizeof(*gx)) {
			fprintf(stderr, "Invalid signature length\n");
			return (-1);
		}
		if (fread((u_char *)gd, 1, gx->subfield.len, fin) !=
		    gx->subfield.len) {
			fprintf(stderr, "Error reading signature: %s\n",
			    strerror(errno));
			return (-1);
		}
		fprintf(stderr, "Overwriting existing signature\n");
	}
	/* Skip over any options. */
	offset = ftell(fin);

	if (gh.flags & GZIP_FNAME) {
		if (skip_string(fin))
			return (-1);
	}
	if (gh.flags & GZIP_FCOMMENT) {
		if (skip_string(fin))
			return (-1);
	}
	if (gh.flags & GZIP_FENCRYPT) {
		if (fread(buf, 1, GZIP_FENCRYPT_LEN, fin) != GZIP_FENCRYPT_LEN)
			return (-1);
	}
	/* Compute checksum over compressed data and trailer. */
	SHA1_Init(&ctx);
	
	while ((i = fread(buf, 1, sizeof(buf), fin)) > 0) {
		SHA1_Update(&ctx, buf, i);
	}
	SHA1_Final(digest, &ctx);
	
	/* Generate signature. */
	gx = (struct gzip_xfield *)buf;
	gd = (struct gzsig_data *)(gx + 1);
	sig = (u_char *)(gd + 1);
	
	siglen = key_sign(key, digest, sizeof(digest), sig,
	    sizeof(buf) - (sig - buf));
	
	if (siglen < 0) {
		fprintf(stderr, "Error signing checksum\n");
		return (-1);
	}
	i = sizeof(*gd) + siglen;
	gx->subfield.len = htole16(i);
	gx->len = htole16(sizeof(gx->subfield) + i);
	memcpy(gx->subfield.id, GZSIG_ID, sizeof(gx->subfield.id));
	gd->version = GZSIG_VERSION;
	
	/* Write out gzip header. */
	gh.flags |= GZIP_FEXTRA;

	if (fwrite((u_char *)&gh, 1, sizeof(gh), fout) != sizeof(gh)) {
		fprintf(stderr, "Error writing output: %s\n", strerror(errno));
		return (-1);
	}
	/* Write out signature. */
	if (fwrite(buf, 1, sizeof(*gx) + i, fout) != sizeof(*gx) + i) {
		fprintf(stderr, "Error writing output: %s\n", strerror(errno));
		return (-1);
	}
	/* Write out options, compressed data, and trailer. */
	if (fseek(fin, offset, SEEK_SET) < 0) {
		fprintf(stderr, "Error writing output: %s\n", strerror(errno));
		return (-1);
	}
	while ((i = fread(buf, 1, sizeof(buf), fin)) > 0) {		
		if (fwrite(buf, 1, i, fout) != i) {
			fprintf(stderr, "Error writing output: %s\n",
			    strerror(errno));
			return (-1);
		}
	}
	if (ferror(fin)) {
		fprintf(stderr, "Error reading input: %s\n", strerror(errno));
		return (-1);
	}
	return (0);
}

void
sign_usage(void)
{
	fprintf(stderr, "usage: %s sign [-q | -v] [-f secret_file] privkey "
	    "[file ...]\n", __progname);
}

int
sign_passwd_cb(char *buf, int size, int rwflag, void *u)
{
	char *p;
	FILE *f;

	if (passphrase_file != NULL) {
		if ((f = fopen(passphrase_file, "r")) == NULL)
			err(1, "fopen(%.64s)", passphrase_file);
		if (fgets(buf, size, f) == NULL)
			err(1, "fgets(%.64s)", passphrase_file);
		fclose(f);
		buf[strcspn(buf, "\n")] = '\0';
	} else {
		p = getpass("Enter passphrase: ");
		if (strlcpy(buf, p, size) >= size)
			errx(1, "Passphrase too long");
		explicit_bzero(p, strlen(p));
	}

	return (strlen(buf));
}

void
sign(int argc, char *argv[])
{
	struct key *key;
	char *gzipfile, tmppath[MAXPATHLEN];
	FILE *fin, *fout;
	int i, fd, error, qflag;

	qflag = 0;
	
	while ((i = getopt(argc, argv, "qvf:")) != -1) {
		switch (i) {
		case 'q':
			qflag = 1;
			break;
		case 'v':
			qflag = 0;
			break;
		case 'f':
			passphrase_file = optarg;
			break;
		default:
			sign_usage();
			exit(1);
		}
	}
	argc -= optind;
	argv += optind;

	if (argc < 1) {
		sign_usage();
		exit(1);
	}
	OpenSSL_add_all_algorithms();
	
	if ((key = key_new()) == NULL)
		fatal(1, "Couldn't initialize private key");
	
	if (key_load_private(key, argv[0]) < 0)
		fatal(1, "Couldn't load private key");
	
	if (argc == 1 || *argv[1] == '-') {
		argc = 0;
		
		if (embed_signature(key, stdin, stdout) == 0) {
			if (!qflag)
				fprintf(stderr, "Signed input\n");
		} else
			fatal(1, "Couldn't sign input");
	}
	for (i = 1; i < argc; i++) {
		gzipfile = argv[i];

		if ((fin = fopen(gzipfile, "r+")) == NULL) {
			fprintf(stderr,  "Error opening %s: %s\n",
			    gzipfile, strerror(errno));
			continue;
		}
		snprintf(tmppath, sizeof(tmppath), "%s.XXXXXX", gzipfile);
		
		if ((fd = mkstemp(tmppath)) < 0) {
			fprintf(stderr, "Error creating %s: %s\n",
			    tmppath, strerror(errno));
			fclose(fin);
			continue;
		}
		if ((fout = fdopen(fd, "w")) == NULL) {
			fprintf(stderr, "Error opening %s: %s\n",
			    tmppath, strerror(errno));
			fclose(fin);
			close(fd);
			continue;
		}
		if (copy_permissions(fileno(fin), fd) < 0) {
			fprintf(stderr, "Error initializing %s: %s\n",
			    tmppath, strerror(errno));
			fclose(fin);
			fclose(fout);
			continue;
		}
		error = embed_signature(key, fin, fout);
		
		fclose(fin);
		fclose(fout);

		if (!error) {
			if (rename(tmppath, gzipfile) < 0) {
				unlink(tmppath);
				fatal(1, "Couldn't sign %s", gzipfile);
			}
			if (!qflag)
				fprintf(stderr, "Signed %s\n", gzipfile);
		} else {
			unlink(tmppath);
			fatal(1, "Couldn't sign %s", gzipfile);
		}
	}
	key_free(key);
}
@


1.14
log
@Delete secret or secret-derived data with explicit_bzero.

concept ok deraadt@@
diff looks ok tedu@@
@
text
@d1 1
a1 1
/* $OpenBSD: sign.c,v 1.13 2013/03/10 10:36:57 tobias Exp $ */
@


1.13
log
@Prevent endless loop on input error.
@
text
@d1 1
a1 1
/* $OpenBSD: sign.c,v 1.12 2013/03/10 10:34:33 tobias Exp $ */
d209 1
a209 1
		memset(p, 0, strlen(p));
@


1.12
log
@Prevent race condition by using already opened file descriptors.
Properly presume owner/mode of gzip file.

with input by and ok deraadt
@
text
@d1 1
a1 1
/* $OpenBSD: sign.c,v 1.11 2013/03/09 22:36:44 jmc Exp $ */
d117 2
a118 2
		while (getc(fin) != '\0')
			;
d121 2
a122 2
		while (getc(fin) != '\0')
			;
@


1.11
log
@Usage -> usage;
@
text
@d1 1
a1 1
/* $OpenBSD: sign.c,v 1.10 2013/03/09 21:08:37 tobias Exp $ */
d288 1
a288 1
		if (copy_permissions(gzipfile, tmppath) < 0) {
@


1.10
log
@Mention -v in manpage and usage.
With input from jmc.

ok jmc
@
text
@d1 1
a1 1
/* $OpenBSD: sign.c,v 1.9 2007/10/12 19:52:06 jasper Exp $ */
d188 1
a188 1
	fprintf(stderr, "Usage: %s sign [-q | -v] [-f secret_file] privkey "
@


1.9
log
@use __progname where needed

ok otto@@
@
text
@d1 1
a1 1
/* $OpenBSD: sign.c,v 1.8 2007/09/11 15:47:17 gilles Exp $ */
d188 2
a189 2
	fprintf(stderr, "Usage: %s sign [-q] [-f secret_file] privkey [file ...]\n",
	    __progname);
@


1.8
log
@use strcspn to properly overwrite '\n' in fgets returned buffer

ok pyr@@, ray@@, millert@@, moritz@@, chl@@
@
text
@d1 1
a1 1
/* $OpenBSD: sign.c,v 1.7 2006/04/17 09:36:56 moritz Exp $ */
d188 2
a189 1
	fprintf(stderr, "Usage: gzsig sign [-q] [-f secret_file] privkey [file ...]\n");
@


1.7
log
@Remove useless "h" and "?" from getopt(3) string.
From Steffen Wendzel. ok marius@@
@
text
@d1 1
a1 1
/* $OpenBSD: sign.c,v 1.6 2005/08/05 14:17:55 jmc Exp $ */
d203 1
a203 2
		if ((p = strchr(buf, '\n')) != NULL)
			*p = '\0';
@


1.6
log
@- -f valid for gzsig sign too
- tidy up SYNOPSIS and AUTHORS
- sort options
- sync usage()
@
text
@d1 1
a1 1
/* $OpenBSD: sign.c,v 1.5 2005/05/29 09:10:23 djm Exp $ */
d225 1
a225 1
	while ((i = getopt(argc, argv, "qvh?f:")) != -1) {
@


1.5
log
@-Wall; feedback & ok marius@@
@
text
@d1 1
a1 1
/* $OpenBSD: sign.c,v 1.4 2005/05/29 08:54:13 djm Exp $ */
d188 1
a188 1
	fprintf(stderr, "Usage: gzsig sign [-q] privkey [file ...]\n");
@


1.4
log
@replace the morally-hazardous -p option (passphrase on commandline) with a
safer, more gentle -f (passphrase in file) option; ok marius@@
@
text
@d1 1
a1 1
/* $OpenBSD: sign.c,v 1.3 2005/05/29 07:34:34 djm Exp $ */
d219 1
a219 1
	char *gzipfile, tmpfile[MAXPATHLEN];
d273 1
a273 1
		snprintf(tmpfile, sizeof(tmpfile), "%s.XXXXXX", gzipfile);
d275 1
a275 1
		if ((fd = mkstemp(tmpfile)) < 0) {
d277 1
a277 1
			    tmpfile, strerror(errno));
d283 1
a283 1
			    tmpfile, strerror(errno));
d288 1
a288 1
		if (copy_permissions(gzipfile, tmpfile) < 0) {
d290 1
a290 1
			    tmpfile, strerror(errno));
d301 2
a302 2
			if (rename(tmpfile, gzipfile) < 0) {
				unlink(tmpfile);
d308 1
a308 1
			unlink(tmpfile);
@


1.3
log
@provide feedback on success; ok marius@@
@
text
@d1 1
a1 1
/* $OpenBSD: sign.c,v 1.2 2005/05/28 08:07:45 marius Exp $ */
d49 1
d56 1
a56 1
static char *passphrase = NULL;
d195 1
d197 8
a204 3
	if (passphrase != NULL) {
		if (strlcpy(buf, passphrase, size) >= size)
			errx(1, "Passphrase too long");
d225 1
a225 1
	while ((i = getopt(argc, argv, "qvh?p:")) != -1) {
d233 2
a234 2
		case 'p':
			passphrase = optarg;
a312 3

	if (passphrase != NULL)
		memset(passphrase, 0, strlen(passphrase));
@


1.2
log
@whoops.  the import killed the $Id$ tags; rectify.
@
text
@d1 1
a1 1
/* $OpenBSD: sign.c,v 1.1.1.1 2005/05/28 01:57:30 marius Exp $ */
d187 1
a187 1
	fprintf(stderr, "Usage: gzsig sign [-v] privkey [file ...]\n");
d214 1
a214 1
	int i, fd, error, vflag;
d216 1
a216 1
	vflag = 0;
d218 1
a218 1
	while ((i = getopt(argc, argv, "vh?p:")) != -1) {
d220 3
d224 1
a224 1
			vflag = 1;
d253 1
a253 1
			if (vflag)
d298 1
a298 1
			if (vflag)
@


1.1
log
@Initial revision
@
text
@d1 1
a1 1
/* $OpenBSD$ */
d33 1
a33 1
 * $Id: sign.c,v 1.2 2005/04/01 16:47:31 dugsong Exp $
@


1.1.1.1
log
@import gzsig by Dug Song.  

a bunch of lumberjack work, zapped support for keynote 
and SSH1 and added support for SSH2 keys.

ok millert@@ deraadt@@
@
text
@@
