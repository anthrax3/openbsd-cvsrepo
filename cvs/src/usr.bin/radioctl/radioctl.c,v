head	1.19;
access;
symbols
	OPENBSD_6_1:1.19.0.14
	OPENBSD_6_1_BASE:1.19
	OPENBSD_6_0:1.19.0.12
	OPENBSD_6_0_BASE:1.19
	OPENBSD_5_9:1.19.0.8
	OPENBSD_5_9_BASE:1.19
	OPENBSD_5_8:1.19.0.10
	OPENBSD_5_8_BASE:1.19
	OPENBSD_5_7:1.19.0.2
	OPENBSD_5_7_BASE:1.19
	OPENBSD_5_6:1.19.0.6
	OPENBSD_5_6_BASE:1.19
	OPENBSD_5_5:1.19.0.4
	OPENBSD_5_5_BASE:1.19
	OPENBSD_5_4:1.17.0.14
	OPENBSD_5_4_BASE:1.17
	OPENBSD_5_3:1.17.0.12
	OPENBSD_5_3_BASE:1.17
	OPENBSD_5_2:1.17.0.10
	OPENBSD_5_2_BASE:1.17
	OPENBSD_5_1_BASE:1.17
	OPENBSD_5_1:1.17.0.8
	OPENBSD_5_0:1.17.0.6
	OPENBSD_5_0_BASE:1.17
	OPENBSD_4_9:1.17.0.4
	OPENBSD_4_9_BASE:1.17
	OPENBSD_4_8:1.17.0.2
	OPENBSD_4_8_BASE:1.17
	OPENBSD_4_7:1.16.0.4
	OPENBSD_4_7_BASE:1.16
	OPENBSD_4_6:1.16.0.6
	OPENBSD_4_6_BASE:1.16
	OPENBSD_4_5:1.16.0.2
	OPENBSD_4_5_BASE:1.16
	OPENBSD_4_4:1.14.0.4
	OPENBSD_4_4_BASE:1.14
	OPENBSD_4_3:1.14.0.2
	OPENBSD_4_3_BASE:1.14
	OPENBSD_4_2:1.13.0.8
	OPENBSD_4_2_BASE:1.13
	OPENBSD_4_1:1.13.0.6
	OPENBSD_4_1_BASE:1.13
	OPENBSD_4_0:1.13.0.4
	OPENBSD_4_0_BASE:1.13
	OPENBSD_3_9:1.13.0.2
	OPENBSD_3_9_BASE:1.13
	OPENBSD_3_8:1.11.0.2
	OPENBSD_3_8_BASE:1.11
	OPENBSD_3_7:1.10.0.4
	OPENBSD_3_7_BASE:1.10
	OPENBSD_3_6:1.10.0.2
	OPENBSD_3_6_BASE:1.10
	OPENBSD_3_5:1.8.0.10
	OPENBSD_3_5_BASE:1.8
	OPENBSD_3_4:1.8.0.8
	OPENBSD_3_4_BASE:1.8
	OPENBSD_3_3:1.8.0.6
	OPENBSD_3_3_BASE:1.8
	OPENBSD_3_2:1.8.0.4
	OPENBSD_3_2_BASE:1.8
	OPENBSD_3_1:1.8.0.2
	OPENBSD_3_1_BASE:1.8
	OPENBSD_3_0:1.2.0.2
	OPENBSD_3_0_BASE:1.2;
locks; strict;
comment	@ * @;


1.19
date	2013.12.21.06.54.53;	author guenther;	state Exp;
branches;
next	1.18;

1.18
date	2013.11.26.19.25.38;	author deraadt;	state Exp;
branches;
next	1.17;

1.17
date	2010.06.29.05.00.05;	author tedu;	state Exp;
branches;
next	1.16;

1.16
date	2008.10.16.14.32.57;	author jmc;	state Exp;
branches;
next	1.15;

1.15
date	2008.10.16.02.21.26;	author jakemsr;	state Exp;
branches;
next	1.14;

1.14
date	2007.09.27.21.55.54;	author sobrado;	state Exp;
branches;
next	1.13;

1.13
date	2006.02.05.23.52.58;	author jakemsr;	state Exp;
branches;
next	1.12;

1.12
date	2005.12.05.16.30.24;	author robert;	state Exp;
branches;
next	1.11;

1.11
date	2005.07.28.17.15.11;	author robert;	state Exp;
branches;
next	1.10;

1.10
date	2004.08.08.00.23.15;	author deraadt;	state Exp;
branches;
next	1.9;

1.9
date	2004.08.08.00.21.55;	author jaredy;	state Exp;
branches;
next	1.8;

1.8
date	2002.01.22.22.09.28;	author mickey;	state Exp;
branches;
next	1.7;

1.7
date	2002.01.02.19.18.55;	author mickey;	state Exp;
branches;
next	1.6;

1.6
date	2002.01.01.22.03.49;	author deraadt;	state Exp;
branches;
next	1.5;

1.5
date	2001.12.18.18.42.19;	author mickey;	state Exp;
branches;
next	1.4;

1.4
date	2001.12.06.10.04.11;	author mickey;	state Exp;
branches;
next	1.3;

1.3
date	2001.12.05.19.40.46;	author mickey;	state Exp;
branches;
next	1.2;

1.2
date	2001.10.04.22.43.45;	author gluk;	state Exp;
branches;
next	1.1;

1.1
date	2001.10.04.22.22.11;	author gluk;	state Exp;
branches;
next	;


desc
@@


1.19
log
@Don't use a non-constant format string with printf() that gcc can't
figure out how to trust.  Shuts up gcc -Wformat=2

ok deraadt@@
@
text
@/* $OpenBSD: radioctl.c,v 1.18 2013/11/26 19:25:38 deraadt Exp $ */
/* $RuOBSD: radioctl.c,v 1.4 2001/10/20 18:09:10 pva Exp $ */

/*
 * Copyright (c) 2001 Vladimir Popov <jumbo@@narod.ru>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;
 * OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
 * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
 * OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF
 * ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

#include <sys/ioctl.h>
#include <sys/radioio.h>

#include <dev/ic/bt8xx.h>

#include <err.h>
#include <fcntl.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <ctype.h>

#define RADIO_ENV	"RADIODEVICE"
#define RADIODEVICE	"/dev/radio"

const char *varname[] = {
	"search",
#define OPTION_SEARCH		0x00
	"volume",
#define OPTION_VOLUME		0x01
	"frequency",
#define OPTION_FREQUENCY	0x02
	"mute",
#define OPTION_MUTE		0x03
	"reference",
#define OPTION_REFERENCE	0x04
	"mono",
#define OPTION_MONO		0x05
	"stereo",
#define	OPTION_STEREO		0x06
	"sensitivity",
#define	OPTION_SENSITIVITY	0x07
	"channel",
#define OPTION_CHANNEL		0x08
	"chnlset"
#define OPTION_CHNLSET		0x09
};

#define OPTION_NONE		~0u
#define VALUE_NONE		~0u

struct opt_t {
	char *string;
	int option;
	int sign;
#define SIGN_NONE	0
#define SIGN_PLUS	1
#define SIGN_MINUS	-1
	u_int32_t value;
};

struct chansets {
	int value;
	char *name;
} chansets[] = {
{ CHNLSET_NABCST,	"nabcst",	},
{ CHNLSET_CABLEIRC,	"cableirc",	},
{ CHNLSET_CABLEHRC,	"cablehrc",	},
{ CHNLSET_WEUROPE,	"weurope",	},
{ CHNLSET_JPNBCST,	"jpnbcst",	},
{ CHNLSET_JPNCABLE,	"jpncable",	},
{ CHNLSET_XUSSR,	"xussr",	},
{ CHNLSET_AUSTRALIA,	"australia",	},
{ CHNLSET_FRANCE,	"france",	},
{ 0, NULL }
};

extern char *__progname;
const char *onchar = "on";
#define ONCHAR_LEN	2
const char *offchar = "off";
#define OFFCHAR_LEN	3

struct radio_info ri;
unsigned int i = 0;

int	parse_opt(char *, struct opt_t *);

void	print_vars(int, int);
void	do_ioctls(int, struct opt_t *, int);

void	print_value(int, int);
void	change_value(const struct opt_t);
void	update_value(int, int *, int);

void	warn_unsupported(int);
void	usage(void);

void	show_verbose(const char *, int);
void	show_int_val(int, const char *, char *, int);
void	show_float_val(float, const char *, char *, int);
void	show_char_val(const char *, const char *, int);
int	str_to_opt(const char *);
u_int	str_to_int(char *, int);

/*
 * Control behavior of a FM tuner - set frequency, volume etc
 */
int
main(int argc, char **argv)
{
	struct opt_t opt;
	char **avp;

	char *radiodev = NULL;
	int rd = -1;
	int optchar;
	int show_vars = 0;
	int show_choices = 0;
	int silent = 0;
	int mode = O_RDONLY;

	radiodev = getenv(RADIO_ENV);
	if (radiodev == NULL)
		radiodev = RADIODEVICE;

	while ((optchar = getopt(argc, argv, "af:nvw")) != -1) {
		switch (optchar) {
		case 'a':
			show_vars = 1;
			break;
		case 'f':
			radiodev = optarg;
			break;
		case 'n':
			silent = 1;
			break;
		case 'v':
			show_choices = 1;
			break;
		case 'w':
			/* backwards compatibility */
			break;
		default:
			usage();
			/* NOTREACHED */
		}
	}

	argc -= optind;
	argv += optind;

	if (argc == 0)
		show_vars = 1;

	/*
	 * Scan the options for `name=value` so the
	 * device can be opened in the proper mode.
	 */
	for (avp = argv; *avp != NULL; avp++)
		if (strchr(*avp, '=') != NULL) {
			mode = O_RDWR;
			break;
		}

	rd = open(radiodev, mode);
	if (rd < 0)
		err(1, "%s open error", radiodev);

	if (ioctl(rd, RIOCGINFO, &ri) < 0)
		err(1, "RIOCGINFO");

	if (!argc && show_vars)
		print_vars(silent, show_choices);
	else if (argc > 0 && !show_vars) {
		if (mode == O_RDWR) {
			for (; argc--; argv++)
				if (parse_opt(*argv, &opt))
					do_ioctls(rd, &opt, silent);
		} else {
			for (; argc--; argv++)
				if (parse_opt(*argv, &opt)) {
					show_verbose(varname[opt.option],
					    silent);
					print_value(opt.option, show_choices);
					free(opt.string);
					putchar('\n');
				}
		}
	}

	if (close(rd) < 0)
		warn("%s close error", radiodev);

	return 0;
}

void
usage(void)
{
	fprintf(stderr,
	    "usage: %s [-anv] [-f file]\n"
	    "       %s [-nv] [-f file] name\n"
	    "       %s [-n] [-f file] name=value\n",
	    __progname, __progname, __progname);
	exit(1);
}

void
show_verbose(const char *nick, int silent)
{
	if (!silent)
		printf("%s=", nick);
}

void
warn_unsupported(int optval)
{
	warnx("driver does not support `%s'", varname[optval]);
}

void
do_ioctls(int fd, struct opt_t *o, int silent)
{
	int oval;

	if (fd < 0 || o == NULL)
		return;

	if (o->option == OPTION_SEARCH && !(ri.caps & RADIO_CAPS_HW_SEARCH)) {
		warn_unsupported(o->option);
		return;
	}

	oval = o->option == OPTION_SEARCH ? OPTION_FREQUENCY : o->option;
	if (!silent)
		printf("%s: ", varname[oval]);

	print_value(o->option, 0);
	printf(" -> ");

	if (o->option == OPTION_SEARCH) {

		if (ioctl(fd, RIOCSSRCH, &o->value) < 0) {
			warn("RIOCSSRCH");
			return;
		}

	} else {

		change_value(*o);
		if (ioctl(fd, RIOCSINFO, &ri) < 0) {
			warn("RIOCSINFO");
			return;
		}

	}

	if (ioctl(fd, RIOCGINFO, &ri) < 0) {
		warn("RIOCGINFO");
		return;
	}

	print_value(o->option, 0);
	putchar('\n');
}

void
change_value(const struct opt_t o)
{
	int unsupported = 0;

	if (o.value == VALUE_NONE)
		return;

	switch (o.option) {
	case OPTION_VOLUME:
		update_value(o.sign, &ri.volume, o.value);
		break;
	case OPTION_FREQUENCY:
		ri.tuner_mode = RADIO_TUNER_MODE_RADIO;
		update_value(o.sign, &ri.freq, o.value);
		break;
	case OPTION_REFERENCE:
		if (ri.caps & RADIO_CAPS_REFERENCE_FREQ)
			update_value(o.sign, &ri.rfreq, o.value);
		else
			unsupported++;
		break;
	case OPTION_MONO:
		/* FALLTHROUGH */
	case OPTION_STEREO:
		if (ri.caps & RADIO_CAPS_SET_MONO)
			ri.stereo = o.option == OPTION_MONO ? !o.value : o.value;
		else
			unsupported++;
		break;
	case OPTION_SENSITIVITY:
		if (ri.caps & RADIO_CAPS_LOCK_SENSITIVITY)
			update_value(o.sign, &ri.lock, o.value);
		else
			unsupported++;
		break;
	case OPTION_MUTE:
		ri.mute = o.value;
		break;
	case OPTION_CHANNEL:
		ri.tuner_mode = RADIO_TUNER_MODE_TV;
		update_value(o.sign, &ri.chan, o.value);
		break;
	case OPTION_CHNLSET:
		ri.chnlset = o.value;
		break;
	}

	if (unsupported)
		warn_unsupported(o.option);
}

/*
 * Convert string to integer representation of a parameter
 */
int
str_to_opt(const char *topt)
{
	int res, toptlen, varlen, len, varsize;

	if (topt == NULL || *topt == '\0')
		return OPTION_NONE;

	varsize = sizeof(varname) / sizeof(varname[0]);
	toptlen = strlen(topt);

	for (res = 0; res < varsize; res++) {
		varlen = strlen(varname[res]);
		len = toptlen > varlen ? toptlen : varlen;
		if (strncmp(topt, varname[res], len) == 0)
			return res;
	}

	warnx("bad name `%s'", topt);
	return OPTION_NONE;
}

void
update_value(int sign, int *value, int update)
{
	switch (sign) {
	case SIGN_NONE:
		*value  = update;
		break;
	case SIGN_PLUS:
		*value += update;
		break;
	case SIGN_MINUS:
		*value -= update;
		break;
	}
}

/*
 * Convert string to unsigned integer
 */
u_int
str_to_int(char *str, int optval)
{
	int val;

	if (str == NULL || *str == '\0')
		return VALUE_NONE;

	if (optval == OPTION_FREQUENCY)
		val = (int)(1000 * atof(str));
	else
		val = (int)strtol(str, (char **)NULL, 10);

	return val;
}

/*
 * parse string s into struct opt_t
 * return true on success, false on failure
 */
int
parse_opt(char *s, struct opt_t *o) {
	static const char badvalue[] = "bad value `%s'";
	char *topt = NULL;
	int slen, optlen;
	
	if (s == NULL || *s == '\0' || o == NULL)
		return 0;

	o->string = NULL;
	o->option = OPTION_NONE;
	o->value = VALUE_NONE;
	o->sign = SIGN_NONE;

	slen = strlen(s);
	optlen = strcspn(s, "=");

	/* Set only o->optval, the rest is missing */
	if (slen == optlen) {
		o->option = str_to_opt(s);
		return o->option == OPTION_NONE ? 0 : 1;
	}

	if (optlen > slen - 2) {
		warnx(badvalue, s);
		return 0;
	}

	slen -= ++optlen;

	if ((topt = malloc(optlen)) == NULL) {
		warn("memory allocation error");
		return 0;
	}
	strlcpy(topt, s, optlen);

	if ((o->option = str_to_opt(topt)) == OPTION_NONE) {
		free(topt);
		return 0;
	}
	o->string = topt;

	topt = &s[optlen];
	
	if (strcmp(o->string, "chnlset") == 0) {
		for (i = 0; chansets[i].name; i++)
			if (strncmp(chansets[i].name, topt,
				strlen(chansets[i].name)) == 0)
					break;
		if (chansets[i].name != NULL) {
			o->value = chansets[i].value;
			return 1;
		} else {
			warnx(badvalue, topt);
			return 0;
		}
	}

	switch (*topt) {
	case '+':
	case '-':
		o->sign = (*topt == '+') ? SIGN_PLUS : SIGN_MINUS;
		o->value = str_to_int(&topt[1], o->option);
		break;
	case 'o':
		if (strncmp(topt, offchar,
		    slen > OFFCHAR_LEN ? slen : OFFCHAR_LEN) == 0)
			o->value = 0;
		else if (strncmp(topt, onchar,
		    slen > ONCHAR_LEN ? slen : ONCHAR_LEN) == 0)
			o->value = 1;
		break;
	case 'u':
		if (strncmp(topt, "up", slen > 2 ? slen : 2) == 0)
			o->value = 1;
		break;
	case 'd':
		if (strncmp(topt, "down", slen > 4 ? slen : 4) == 0)
			o->value = 0;
		break;
	default:
		if (isdigit((unsigned char)*topt))
			o->value = str_to_int(topt, o->option);
		break;
	}

	if (o->value == VALUE_NONE) {
		warnx(badvalue, topt);
		return 0;
	}

	return 1;
}

/*
 * Print current value of the parameter.
 */
void
print_value(int optval, int show_choices)
{
	if (optval == OPTION_NONE)
		return;

	switch (optval) {
	case OPTION_SEARCH:
		/* FALLTHROUGH */
	case OPTION_FREQUENCY:
		printf("%.2fMHz", (float)ri.freq / 1000.);
		break;
	case OPTION_REFERENCE:
		printf("%ukHz", ri.rfreq);
		break;
	case OPTION_SENSITIVITY:
		printf("%umkV", ri.lock);
		break;
	case OPTION_MUTE:
		printf("%s", ri.mute ? onchar : offchar);
		break;
	case OPTION_MONO:
		printf("%s", ri.stereo ? offchar : onchar);
		break;
	case OPTION_STEREO:
		printf("%s", ri.stereo ? onchar : offchar);
		break;
	case OPTION_CHANNEL:
		printf("%u", ri.chan);
		break;
	case OPTION_CHNLSET:
		for (i = 0; chansets[i].name; i++) {
			if (chansets[i].value == ri.chnlset)
				printf("%s", chansets[i].name);
		}
		if (show_choices) {
			printf("\n\t[");
			for (i = 0; chansets[i].name; i++)
				printf("%s ", chansets[i].name);
			printf("]");
		}
		break;
	case OPTION_VOLUME:
	default:
		printf("%u", ri.volume);
		break;
	}
}

void
show_int_val(int val, const char *nick, char *append, int silent)
{
	show_verbose(nick, silent);
	printf("%u%s\n", val, append);
}

void
show_float_val(float val, const char *nick, char *append, int silent)
{
	show_verbose(nick, silent);
	printf("%.2f%s\n", val, append);
}

void
show_char_val(const char *val, const char *nick, int silent)
{
	show_verbose(nick, silent);
	printf("%s\n", val);
}

/*
 * Print all available parameters
 */
void
print_vars(int silent, int show_choices)
{
	show_int_val(ri.volume, varname[OPTION_VOLUME], "", silent);
	show_int_val(ri.chan, varname[OPTION_CHANNEL], "", silent);
	for (i = 0; chansets[i].name; i++) {
		if (chansets[i].value == ri.chnlset)
			show_char_val(chansets[i].name, varname[OPTION_CHNLSET], silent);
	}
	if (show_choices) {
		printf("\t[ ");
		for (i = 0; chansets[i].name; i++)
			printf("%s ", chansets[i].name);
		printf("]\n");
	}
	show_float_val((float)ri.freq / 1000., varname[OPTION_FREQUENCY],
	    "MHz", silent);
	show_char_val(ri.mute ? onchar : offchar, varname[OPTION_MUTE], silent);

	if (ri.caps & RADIO_CAPS_REFERENCE_FREQ)
		show_int_val(ri.rfreq, varname[OPTION_REFERENCE], "kHz", silent);
	if (ri.caps & RADIO_CAPS_LOCK_SENSITIVITY)
		show_int_val(ri.lock, varname[OPTION_SENSITIVITY], "mkV", silent);

	if (ri.caps & RADIO_CAPS_DETECT_SIGNAL) {
		show_verbose("signal", silent);
		printf("%s\n", ri.info & RADIO_INFO_SIGNAL ? onchar : offchar);
	}
	if (ri.caps & RADIO_CAPS_DETECT_STEREO) {
		show_verbose(varname[OPTION_STEREO], silent);
		printf("%s\n", ri.info & RADIO_INFO_STEREO ? onchar : offchar);
	}

	if (!silent) {
		printf("mode: %s\n",
		    ri.tuner_mode == RADIO_TUNER_MODE_TV ? "TV" : "radio");

		puts("card capabilities:");
	}

	if (ri.caps & RADIO_CAPS_SET_MONO)
		puts("\tmanageable mono/stereo");
	if (ri.caps & RADIO_CAPS_HW_SEARCH)
		puts("\thardware search");
	if (ri.caps & RADIO_CAPS_HW_AFC)
		puts("\thardware AFC");
}
@


1.18
log
@unsigned char casts for ctype
ok okan
@
text
@d1 1
a1 1
/* $OpenBSD: radioctl.c,v 1.17 2010/06/29 05:00:05 tedu Exp $ */
d405 1
a405 1
	const char *badvalue = "bad value `%s'";
d519 1
a519 1
		printf(ri.mute ? onchar : offchar);
d522 1
a522 1
		printf(ri.stereo ? offchar : onchar);
d525 1
a525 1
		printf(ri.stereo ? onchar : offchar);
@


1.17
log
@isdigit() is more readable than comparing ascii codes
@
text
@d1 1
a1 1
/* $OpenBSD: radioctl.c,v 1.16 2008/10/16 14:32:57 jmc Exp $ */
d484 1
a484 1
		if (isdigit(*topt))
@


1.16
log
@sync with previous, which made -a optional: update synopsis/usage()
@
text
@d1 1
a1 1
/* $OpenBSD: radioctl.c,v 1.15 2008/10/16 02:21:26 jakemsr Exp $ */
d40 1
d433 1
a433 1
	if ((topt = (char *)malloc(optlen)) == NULL) {
d469 1
a469 1
			slen > OFFCHAR_LEN ? slen : OFFCHAR_LEN) == 0)
d472 2
a473 2
				slen > ONCHAR_LEN ? slen : ONCHAR_LEN) == 0)
				o->value = 1;
d484 1
a484 1
		if (*topt > 47 && *topt < 58)
@


1.15
log
@
make -a the default, for consistency with other *ctl programs ...

ok sthen@@, looks good to oga@@
@
text
@d1 1
a1 1
/* $OpenBSD: radioctl.c,v 1.14 2007/09/27 21:55:54 sobrado Exp $ */
d220 1
a220 1
	    "usage: %s [-nv] [-f file] -a\n"
@


1.14
log
@style(9) fixes, optional flags without arguments come first;
while here, some spacing fixes

ok deanna@@, jakemsr@@
@
text
@d1 1
a1 1
/* $OpenBSD: radioctl.c,v 1.13 2006/02/05 23:52:58 jakemsr Exp $ */
a140 3
	if (argc < 2)
		usage();

d170 3
@


1.13
log
@improve support for TV tuning via radio(4) by:
- adding a TV or radio mode flag to struct radio_info for radio(4)
  and a similar flag to struct TUNER for bktr(4) to make tuning
  mode explicit
- reporting the proper frequency when in TV mode
- documenting the mode flag and cleaning up some grammar

OK mickey@@, robert@@
@
text
@d1 1
a1 1
/* $OpenBSD: radioctl.c,v 1.12 2005/12/05 16:30:24 robert Exp $ */
d195 1
a195 1
			for(; argc--; argv++)
d199 1
a199 1
			for(; argc--; argv++)
d220 3
a222 3
	    "usage: %s [-f file] [-nv] variable ...\n"
	    "       %s [-f file] [-n] variable=value ...\n"
	    "       %s [-f file] [-nv] -a\n",
@


1.12
log
@Add support for tuning channel and channel set. This allows
the user to tune his bktr(4) card with radioctl(4).
Also add a -v option prints out the available choices of channel
sets.

ok mickey@@
@
text
@d1 1
a1 1
/* $OpenBSD: radioctl.c,v 1.11 2005/07/28 17:15:11 robert Exp $ */
d299 1
d326 1
d605 4
a608 1
	if (!silent)
d610 2
@


1.11
log
@Use proper type for 32 bit entity. s/long/int
This is needed for radioctl(1) to work on sparc64.

ok mickey@@
@
text
@d1 1
a1 1
/* $OpenBSD: radioctl.c,v 1.10 2004/08/08 00:23:15 deraadt Exp $ */
d32 2
d59 1
a59 1
	"sensitivity"
d61 4
d80 16
d103 1
d107 1
a107 1
void	print_vars(int);
d110 1
a110 1
void	print_value(int);
d137 1
d148 1
a148 1
	while ((optchar = getopt(argc, argv, "af:nw")) != -1) {
d159 3
d192 1
a192 1
		print_vars(silent);
d203 1
a203 1
					print_value(opt.option);
d220 1
a220 1
	    "usage: %s [-f file] [-n] variable ...\n"
d222 1
a222 1
	    "       %s [-f file] [-n] -a\n",
d257 1
a257 1
	print_value(o->option);
d282 1
a282 1
	print_value(o->option);
d324 6
d405 1
a405 1

d443 15
d498 1
a498 1
print_value(int optval)
d524 15
d571 1
a571 1
print_vars(int silent)
d574 11
@


1.10
log
@spacing
@
text
@d1 1
a1 1
/* $OpenBSD: radioctl.c,v 1.9 2004/08/08 00:21:55 jaredy Exp $ */
d89 1
a89 1
void	update_value(int, u_long *, u_long);
d95 1
a95 1
void	show_int_val(u_long, const char *, char *, int);
d99 1
a99 1
u_long	str_to_long(char *, int);
d269 1
a269 1
		update_value(o.sign, (u_long *)&ri.volume, o.value);
d272 1
a272 1
		update_value(o.sign, (u_long *)&ri.freq, o.value);
d276 1
a276 1
			update_value(o.sign, (u_long *)&ri.rfreq, o.value);
d290 1
a290 1
			update_value(o.sign, (u_long *)&ri.lock, o.value);
d329 1
a329 1
update_value(int sign, u_long *value, u_long update)
d347 2
a348 2
u_long
str_to_long(char *str, int optval)
d350 1
a350 1
	u_long val;
d356 1
a356 1
		val = (u_long)1000 * atof(str);
d358 1
a358 1
		val = (u_long)strtol(str, (char **)NULL, 10);
d414 1
a414 1
		o->value = str_to_long(&topt[1], o->option);
d434 1
a434 1
			o->value = str_to_long(topt, o->option);
d484 1
a484 1
show_int_val(u_long val, const char *nick, char *append, int silent)
d487 1
a487 1
	printf("%lu%s\n", val, append);
@


1.9
log
@deprecate the need of specifying -w for setting variables.
setting variables can be done with just name=value now,
like other ctl programs.
update manual, sort options, and fix a few mdoc macros

"go for it" deraadt
@
text
@d1 1
a1 1
/* $OpenBSD: radioctl.c,v 1.8 2002/01/22 22:09:28 mickey Exp $ */
d91 1
a91 1
void     warn_unsupported(int);
d155 1
a155 1
		}	
d193 3
a195 3
	    "usage:  %s [-f file] [-n] variable ...\n"
	    "        %s [-f file] [-n] variable=value ...\n"
	    "        %s [-f file] [-n] -a\n",
@


1.8
log
@open for writing only if needed so, accept multiple var assignments for -w; from meself and Vladimir Popov <jumbo@@narod.ru>
@
text
@d1 1
a1 1
/* $OpenBSD: radioctl.c,v 1.7 2002/01/02 19:18:55 mickey Exp $ */
d108 1
a113 1
	int set_param = 0;
d136 1
a136 2
			set_param = 1;
			mode = O_RDWR;
d147 10
d164 1
a164 1
	if (!argc && show_vars && !set_param)
d167 1
a167 1
		if (set_param) {
d192 3
a194 2
	fprintf(stderr, "usage:  %s [-f file] [-n] variable ...\n"
	    "        %s [-f file] [-n] -w variable=value ...\n"
@


1.7
log
@make usage() exit(1) and look like sysctl(8), getopt returns int
@
text
@d1 1
a1 1
/* $OpenBSD: radioctl.c,v 1.6 2002/01/01 22:03:49 deraadt Exp $ */
d80 1
a80 1
static struct radio_info ri;
d82 1
a82 1
static int	parse_opt(char *, struct opt_t *);
d84 2
a85 2
static void	print_vars(int);
static void	do_ioctls(int, struct opt_t *, int);
d87 13
a99 13
static void	print_value(int);
static void	change_value(const struct opt_t);
static void	update_value(int, u_long *, u_long);

static void     warn_unsupported(int);
static void	usage(void);

static void	show_verbose(const char *, int);
static void	show_int_val(u_long, const char *, char *, int);
static void	show_float_val(float, const char *, char *, int);
static void	show_char_val(const char *, const char *, int);
static int	str_to_opt(const char *);
static u_long	str_to_long(char *, int);
a110 1

a111 2
	char *param = NULL;

d115 1
a115 2

	int optv = 0;
d124 1
a124 1
	while ((optchar = getopt(argc, argv, "af:nw:")) != -1) {
a127 1
			optv = 1;
a130 1
			optv = 2;
a133 1
			optv = 1;
d137 1
a137 2
			param = optarg;
			optv = 2;
d143 1
d145 2
a146 3
		argc -= optv;
		argv += optv;
	}
d148 1
a148 1
	rd = open(radiodev, O_RDONLY);
d155 16
a170 6
	if (argc > 1)
		if (parse_opt(*(argv + 1), &opt)) {
			show_verbose(varname[opt.option], silent);
			print_value(opt.option);
			free(opt.string);
			putchar('\n');
d172 1
a172 7

	if (set_param)
		if (parse_opt(param, &opt))
			do_ioctls(rd, &opt, silent);

	if (show_vars)
		print_vars(silent);
d180 1
a180 1
static void
d190 1
a190 1
static void
d197 1
a197 1
static void
d203 1
a203 1
static void
d249 1
a249 1
static void
d296 1
a296 1
static int
d318 1
a318 1
static void
d337 1
a337 1
static u_long
d357 1
a357 1
static int
d439 1
a439 1
static void
d473 1
a473 1
static void
d480 1
a480 1
static void
d487 1
a487 1
static void
d497 1
a497 1
static void
@


1.6
log
@KNF
@
text
@d1 1
a1 1
/* $OpenBSD: radioctl.c,v 1.5 2001/12/18 18:42:19 mickey Exp $ */
d112 1
a112 1
	char optchar;
d121 1
a121 1
	if (argc < 2) {
a122 2
		exit(1);
	}
d187 5
a191 2
	printf("Usage: %s [-f file] [-a] [-n] [-w name=value] [name]\n",
	    __progname);
@


1.5
log
@fix an #include path, from Peter Valchev <pvalchev@@sightly.net>
@
text
@d1 1
a1 1
/* $OpenBSD: radioctl.c,v 1.4 2001/12/06 10:04:11 mickey Exp $ */
d190 1
a190 1
		__progname);
d292 1
a292 1
	if ( unsupported )
d505 1
a505 1
			"MHz", silent);
@


1.4
log
@long leftovers
@
text
@d1 1
a1 1
/* $OpenBSD$ */
a29 2
#include "/sys/sys/radioio.h"
#if 0
a30 1
#endif
@


1.3
log
@update from Nsk dudes
@
text
@d1 1
d65 1
a65 1
#define VALUE_NONE		~0ul
@


1.2
log
@$OpenBSD$ tag.
@
text
@d1 1
a1 2
/*	$OpenBSD$	*/
/* $RuOBSD: radioctl.c,v 1.1 2001/10/03 05:53:35 gluk Exp $ */
d29 2
d32 1
d66 10
d82 6
a87 1
u_long caps;
d89 13
a101 10
static void     usage(void);
static void     print_vars(int, int);
static void     write_param(int, char *, int);
static u_int    parse_option(const char *);
static u_long   get_value(int, u_int);
static void     set_value(int, u_int, u_long);
static u_long   read_value(char *, u_int);
static void     print_value(int, u_int);
static void     warn_unsupported(u_int);
static void     ext_print(int, u_int, int);
d109 2
d112 2
d116 1
a116 1
	int rd = -1;
d121 2
d136 1
a136 1
			optind = 1;
d140 1
a140 1
			optind = 2;
d144 1
a144 1
			optind = 1;
d149 1
a149 1
			optind = 2;
d156 2
a157 2
		argc -= optind;
		argv += optind;
d164 2
a165 2
	if (ioctl(rd, RIOCGCAPS, &caps) < 0)
		err(1, "RIOCGCAPS");
d168 6
a173 1
		ext_print(rd, parse_option(*(argv + 1)), silent);
d176 2
a177 1
		write_param(rd, param, silent);
d180 1
a180 1
		print_vars(rd, silent);
a194 3
/*
 * Print all available parameters
 */
d196 1
a196 1
print_vars(int fd, int silent)
d198 3
a200 1
	u_long var;
d202 4
a205 29
	ext_print(fd, OPTION_VOLUME, silent);
	ext_print(fd, OPTION_FREQUENCY, silent);
	ext_print(fd, OPTION_MUTE, silent);

	if (caps & RADIO_CAPS_REFERENCE_FREQ)
		ext_print(fd, OPTION_REFERENCE, silent);
	if (caps & RADIO_CAPS_LOCK_SENSITIVITY)
		ext_print(fd, OPTION_SENSITIVITY, silent);

	if (ioctl(fd, RIOCGINFO, &var) < 0)
		warn("RIOCGINFO");
	if (caps & RADIO_CAPS_DETECT_SIGNAL)
		if (!silent)
			printf("%s=", "signal");
		printf("%s\n", var & RADIO_INFO_SIGNAL ? onchar : offchar);
	if (caps & RADIO_CAPS_DETECT_STEREO) {
		if (!silent)
			printf("%s=", varname[OPTION_STEREO]);
		printf("%s\n", var & RADIO_INFO_STEREO ? onchar : offchar);
	}

	if (!silent)
		puts("card capabilities:");
	if (caps & RADIO_CAPS_SET_MONO)
		puts("\tmanageable mono/stereo");
	if (caps & RADIO_CAPS_HW_SEARCH)
		puts("\thardware search");
	if (caps & RADIO_CAPS_HW_AFC)
		puts("\thardware AFC");
a207 3
/*
 * Set new value of a parameter
 */
d209 1
a209 1
write_param(int fd, char *param, int silent)
d211 1
a211 8
	int paramlen = 0;
	int namelen = 0;
	char *topt = NULL;
	const char *badvalue = "bad value `%s'";
	u_int optval = OPTION_NONE;
	u_long var = VALUE_NONE;
	u_long addvar = VALUE_NONE;
	u_char sign = 0;
d213 1
a213 1
	if (param == NULL || *param == '\0')
d216 2
a217 4
	paramlen = strlen(param);
	namelen = strcspn(param, "=");
	if (namelen > paramlen - 2) {
		warnx(badvalue, param);
d221 21
a241 1
	paramlen -= ++namelen;
a242 3
	if ((topt = (char *)malloc(namelen)) == NULL) {
		warn("memory allocation error");
		return;
a243 2
	strlcpy(topt, param, namelen);
	optval = parse_option(topt);
d245 2
a246 2
	if (optval == OPTION_NONE) {
		free(topt);
d250 8
a257 2
	if (!silent)
		printf("%s: ", topt);
d259 2
a260 1
	free(topt);
d262 10
a271 11
	topt = &param[namelen];
	switch (*topt) {
	case '+':
	case '-':
		if ((addvar = read_value(topt + 1, optval)) == VALUE_NONE)
			break;
		if ((var = get_value(fd, optval)) == VALUE_NONE)
			break;
		sign++;
		if (*topt == '+')
			var += addvar;
d273 1
a273 1
			var -= addvar;
d275 5
a279 4
	case 'o':
		if (strncmp(topt, offchar,
			paramlen > OFFCHAR_LEN ? paramlen : OFFCHAR_LEN) == 0)
			var = 0;
d281 1
a281 3
			if (strncmp(topt, onchar,
				paramlen > ONCHAR_LEN ? paramlen : ONCHAR_LEN) == 0)
				var = 1;
d283 5
a287 3
	case 'u':
		if (strncmp(topt, "up", paramlen > 2 ? paramlen : 2) == 0)
			var = 1;
d289 2
a290 7
	case 'd':
		if (strncmp(topt, "down", paramlen > 4 ? paramlen : 4) == 0)
			var = 0;
		break;
	default:
		if (*topt > 47 && *topt < 58)
			var = read_value(topt, optval);
d294 2
a295 12
	if (var == VALUE_NONE || (sign && addvar == VALUE_NONE)) {
		warnx(badvalue, topt);
		return;
	}

	print_value(fd, optval);
	printf(" -> ");

	set_value(fd, optval, var);

	print_value(fd, optval);
	putchar('\n');
d301 2
a302 2
static u_int
parse_option(const char *topt)
d304 1
a304 2
	u_int res;
	int toptlen, varlen, len, varsize;
a322 49
/*
 * Returns current value of parameter optval
 */
static u_long
get_value(int fd, u_int optval)
{
	u_long var = VALUE_NONE;

	switch (optval) {
	case OPTION_VOLUME:
		if (ioctl(fd, RIOCGVOLU, &var) < 0)
			warn("RIOCGVOLU");
		break;
	case OPTION_FREQUENCY:
		if (ioctl(fd, RIOCGFREQ, &var) < 0)
			warn("RIOCGFREQ");
		break;
	case OPTION_REFERENCE:
		if (caps & RADIO_CAPS_REFERENCE_FREQ)
			if (ioctl(fd, RIOCGREFF, &var) < 0)
				warn("RIOCGREFF");
		break;
	case OPTION_MONO:
		/* FALLTHROUGH */
	case OPTION_STEREO:
		if (caps & RADIO_CAPS_SET_MONO)
			if (ioctl(fd, RIOCGMONO, &var) < 0)
				warn("RIOCGMONO");
		break;
	case OPTION_SENSITIVITY:
		if (caps & RADIO_CAPS_LOCK_SENSITIVITY)
			if (ioctl(fd, RIOCGLOCK, &var) < 0)
				warn("RIOCGLOCK");
		break;
	case OPTION_MUTE:
		if (ioctl(fd, RIOCGMUTE, &var) < 0)
			warn("RIOCGMUTE");
		break;
	}

	if (var == VALUE_NONE)
		warn_unsupported(optval);

	return var;
}

/*
 * Set card parameter optval to value var
 */
d324 1
a324 1
set_value(int fd, u_int optval, u_long var)
d326 3
a328 28
	int unsupported = 0;

	if (var == VALUE_NONE)
		return;

	switch (optval) {
	case OPTION_VOLUME:
		if (ioctl(fd, RIOCSVOLU, &var) < 0)
			warn("RIOCSVOLU");
		break;
	case OPTION_FREQUENCY:
		if (ioctl(fd, RIOCSFREQ, &var) < 0)
			warn("RIOCSFREQ");
		break;
	case OPTION_REFERENCE:
		if (caps & RADIO_CAPS_REFERENCE_FREQ) {
			if (ioctl(fd, RIOCSREFF, &var) < 0)
				warn("RIOCSREFF");
		} else unsupported++;
		break;
	case OPTION_STEREO:
		var = !var;
		/* FALLTHROUGH */
	case OPTION_MONO:
		if (caps & RADIO_CAPS_SET_MONO) {
			if (ioctl(fd, RIOCSMONO, &var) < 0)
				warn("RIOCSMONO");
		} else unsupported++;
d330 2
a331 5
	case OPTION_SENSITIVITY:
		if (caps & RADIO_CAPS_LOCK_SENSITIVITY) {
			if (ioctl(fd, RIOCSLOCK, &var) < 0)
				warn("RIOCSLOCK");
		} else unsupported++;
d333 2
a334 9
	case OPTION_SEARCH:
		if (caps & RADIO_CAPS_HW_SEARCH) {
			if (ioctl(fd, RIOCSSRCH, &var) < 0)
				warn("RIOCSSRCH");
		} else unsupported++;
		break;
	case OPTION_MUTE:
		if (ioctl(fd, RIOCSMUTE, &var) < 0)
			warn("RIOCSMUTE");
a336 3

	if ( unsupported )
		warn_unsupported(optval);
d340 1
a340 1
 * Convert string to float or unsigned integer
d343 1
a343 1
read_value(char *str, u_int optval)
d359 83
d445 1
a445 1
print_value(int fd, u_int optval)
a446 2
	u_long var, mhz;

a449 8
	if ( optval == OPTION_SEARCH)
		var = get_value(fd, OPTION_FREQUENCY);
	else
		var = get_value(fd, optval);

	if (var == VALUE_NONE)
		return;

d454 1
a454 3
		mhz = var / 1000;
		printf("%u.%uMHz", (u_int)mhz,
			(u_int)var / 10 - (u_int)mhz * 100);
d457 1
a457 1
		printf("%ukHz", (u_int)var);
d460 1
a460 1
		printf("%umkV", (u_int)var);
d463 2
a464 1
		/* FALLTHROUGH */
d466 1
a466 1
		printf("%s", var ? onchar : offchar);
d469 1
a469 1
		printf("%s", var ? offchar : onchar);
d471 1
d473 1
a473 1
		printf("%u", (u_int)var);
d479 15
a493 1
warn_unsupported(u_int optval)
d495 2
a496 1
	warnx("driver does not support `%s'", varname[optval]);
d499 3
d503 1
a503 1
ext_print(int fd, u_int optval, int silent)
d505 18
a522 2
	if (optval == OPTION_NONE)
		return;
d525 7
a531 3
		printf("%s=", varname[optval]);
	print_value(fd, optval);
	putchar('\n');
@


1.1
log
@Configuration utility for radio devices.

Work by Vladimir Popov <jumbo@@narod.ru>
@
text
@d1 1
@

