head	1.56;
access;
symbols
	OPENBSD_6_0:1.54.0.4
	OPENBSD_6_0_BASE:1.54
	OPENBSD_5_9:1.54.0.2
	OPENBSD_5_9_BASE:1.54
	OPENBSD_5_8:1.53.0.4
	OPENBSD_5_8_BASE:1.53
	OPENBSD_5_7:1.51.0.2
	OPENBSD_5_7_BASE:1.51
	OPENBSD_5_6:1.41.0.6
	OPENBSD_5_6_BASE:1.41
	OPENBSD_5_5:1.41.0.4
	OPENBSD_5_5_BASE:1.41
	OPENBSD_5_4:1.40.0.2
	OPENBSD_5_4_BASE:1.40
	OPENBSD_5_3:1.39.0.4
	OPENBSD_5_3_BASE:1.39
	OPENBSD_5_2:1.39.0.2
	OPENBSD_5_2_BASE:1.39
	OPENBSD_5_1_BASE:1.38
	OPENBSD_5_1:1.38.0.10
	OPENBSD_5_0:1.38.0.8
	OPENBSD_5_0_BASE:1.38
	OPENBSD_4_9:1.38.0.6
	OPENBSD_4_9_BASE:1.38
	OPENBSD_4_8:1.38.0.4
	OPENBSD_4_8_BASE:1.38
	OPENBSD_4_7:1.38.0.2
	OPENBSD_4_7_BASE:1.38
	OPENBSD_4_6:1.37.0.10
	OPENBSD_4_6_BASE:1.37
	OPENBSD_4_5:1.37.0.6
	OPENBSD_4_5_BASE:1.37
	OPENBSD_4_4:1.37.0.4
	OPENBSD_4_4_BASE:1.37
	OPENBSD_4_3:1.37.0.2
	OPENBSD_4_3_BASE:1.37
	OPENBSD_4_2:1.36.0.6
	OPENBSD_4_2_BASE:1.36
	OPENBSD_4_1:1.36.0.4
	OPENBSD_4_1_BASE:1.36
	OPENBSD_4_0:1.36.0.2
	OPENBSD_4_0_BASE:1.36
	OPENBSD_3_9:1.35.0.8
	OPENBSD_3_9_BASE:1.35
	OPENBSD_3_8:1.35.0.6
	OPENBSD_3_8_BASE:1.35
	OPENBSD_3_7:1.35.0.4
	OPENBSD_3_7_BASE:1.35
	OPENBSD_3_6:1.35.0.2
	OPENBSD_3_6_BASE:1.35
	OPENBSD_3_5:1.33.0.2
	OPENBSD_3_5_BASE:1.33
	OPENBSD_3_4:1.30.0.2
	OPENBSD_3_4_BASE:1.30
	OPENBSD_3_3:1.11.0.10
	OPENBSD_3_3_BASE:1.11
	OPENBSD_3_2:1.11.0.8
	OPENBSD_3_2_BASE:1.11
	OPENBSD_3_1:1.11.0.6
	OPENBSD_3_1_BASE:1.11
	OPENBSD_3_0:1.11.0.4
	OPENBSD_3_0_BASE:1.11
	OPENBSD_2_9_BASE:1.11
	OPENBSD_2_9:1.11.0.2
	OPENBSD_2_8:1.10.0.4
	OPENBSD_2_8_BASE:1.10
	OPENBSD_2_7:1.10.0.2
	OPENBSD_2_7_BASE:1.10
	OPENBSD_2_6:1.9.0.4
	OPENBSD_2_6_BASE:1.9
	OPENBSD_2_5:1.9.0.2
	OPENBSD_2_5_BASE:1.9
	OPENBSD_2_4:1.8.0.8
	OPENBSD_2_4_BASE:1.8
	OPENBSD_2_3:1.8.0.6
	OPENBSD_2_3_BASE:1.8
	OPENBSD_2_2:1.8.0.4
	OPENBSD_2_2_BASE:1.8
	OPENBSD_2_1:1.8.0.2
	OPENBSD_2_1_BASE:1.8
	OPENBSD_2_0:1.7.0.2
	OPENBSD_2_0_BASE:1.7
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.56
date	2017.03.26.15.28.12;	author deraadt;	state Exp;
branches;
next	1.55;
commitid	7D6hNCzcWAJ0ot4u;

1.55
date	2016.09.02.09.48.03;	author otto;	state Exp;
branches;
next	1.54;
commitid	NfcUvYsg1oeemXbi;

1.54
date	2015.10.16.07.33.47;	author tobias;	state Exp;
branches;
next	1.53;
commitid	ROuDUViZDwLMOe8F;

1.53
date	2015.07.31.00.24.14;	author millert;	state Exp;
branches;
next	1.52;
commitid	tzPoMBaFc57nGuL6;

1.52
date	2015.07.26.14.32.19;	author millert;	state Exp;
branches;
next	1.51;
commitid	09nDnpMEB9OxbzYE;

1.51
date	2015.02.05.12.59.57;	author millert;	state Exp;
branches
	1.51.2.1;
next	1.50;
commitid	DTQbfd4poqBW8iSJ;

1.50
date	2014.12.14.09.12.59;	author tobias;	state Exp;
branches;
next	1.49;
commitid	oUXVVq2RAktWaY56;

1.49
date	2014.12.13.10.31.07;	author tobias;	state Exp;
branches;
next	1.48;
commitid	KFnMndwf456Gm1bQ;

1.48
date	2014.12.08.21.59.36;	author deraadt;	state Exp;
branches;
next	1.47;
commitid	yrJaJtlCm5yG3lJK;

1.47
date	2014.12.01.06.38.04;	author deraadt;	state Exp;
branches;
next	1.46;
commitid	RIBL6GRcRDE9ySF7;

1.46
date	2014.11.26.10.11.21;	author tobias;	state Exp;
branches;
next	1.45;
commitid	On8ganhmePJgqhPL;

1.45
date	2014.11.25.10.26.07;	author tobias;	state Exp;
branches;
next	1.44;
commitid	mZfOdiB135CQCOKt;

1.44
date	2014.11.22.15.49.28;	author tobias;	state Exp;
branches;
next	1.43;
commitid	vyatgew5pmIq3geU;

1.43
date	2014.11.18.17.03.35;	author tobias;	state Exp;
branches;
next	1.42;
commitid	EfFgb4KqqewMYzJV;

1.42
date	2014.11.17.10.58.09;	author tobias;	state Exp;
branches;
next	1.41;
commitid	SHTsJdktfUwK4o1P;

1.41
date	2013.11.26.13.19.07;	author deraadt;	state Exp;
branches
	1.41.6.1;
next	1.40;

1.40
date	2013.07.11.12.39.31;	author otto;	state Exp;
branches;
next	1.39;

1.39
date	2012.04.11.08.07.13;	author ajacoutot;	state Exp;
branches;
next	1.38;

1.38
date	2009.10.27.23.59.41;	author deraadt;	state Exp;
branches;
next	1.37;

1.37
date	2007.09.02.15.19.33;	author deraadt;	state Exp;
branches;
next	1.36;

1.36
date	2006.03.11.19.41.30;	author otto;	state Exp;
branches;
next	1.35;

1.35
date	2004.08.05.21.47.24;	author deraadt;	state Exp;
branches;
next	1.34;

1.34
date	2004.07.09.19.13.46;	author otto;	state Exp;
branches;
next	1.33;

1.33
date	2004.01.28.08.31.07;	author otto;	state Exp;
branches;
next	1.32;

1.32
date	2003.10.31.20.20.45;	author millert;	state Exp;
branches;
next	1.31;

1.31
date	2003.09.28.07.55.19;	author otto;	state Exp;
branches;
next	1.30;

1.30
date	2003.08.15.08.00.51;	author otto;	state Exp;
branches;
next	1.29;

1.29
date	2003.08.05.18.20.33;	author deraadt;	state Exp;
branches;
next	1.28;

1.28
date	2003.08.01.20.30.48;	author otto;	state Exp;
branches;
next	1.27;

1.27
date	2003.07.29.20.10.17;	author millert;	state Exp;
branches;
next	1.26;

1.26
date	2003.07.28.19.15.34;	author deraadt;	state Exp;
branches;
next	1.25;

1.25
date	2003.07.28.18.35.36;	author otto;	state Exp;
branches;
next	1.24;

1.24
date	2003.07.25.02.12.45;	author millert;	state Exp;
branches;
next	1.23;

1.23
date	2003.07.22.17.52.20;	author deraadt;	state Exp;
branches;
next	1.22;

1.22
date	2003.07.22.17.20.53;	author millert;	state Exp;
branches;
next	1.21;

1.21
date	2003.07.22.17.18.49;	author otto;	state Exp;
branches;
next	1.20;

1.20
date	2003.07.21.14.32.21;	author deraadt;	state Exp;
branches;
next	1.19;

1.19
date	2003.07.21.14.30.31;	author deraadt;	state Exp;
branches;
next	1.18;

1.18
date	2003.07.21.14.27.35;	author deraadt;	state Exp;
branches;
next	1.17;

1.17
date	2003.07.21.14.00.41;	author deraadt;	state Exp;
branches;
next	1.16;

1.16
date	2003.07.18.02.00.09;	author deraadt;	state Exp;
branches;
next	1.15;

1.15
date	2003.07.17.19.16.31;	author otto;	state Exp;
branches;
next	1.14;

1.14
date	2003.07.16.18.09.20;	author otto;	state Exp;
branches;
next	1.13;

1.13
date	2003.04.08.00.18.31;	author deraadt;	state Exp;
branches;
next	1.12;

1.12
date	2003.04.05.17.17.53;	author deraadt;	state Exp;
branches;
next	1.11;

1.11
date	2000.12.14.00.02.19;	author beck;	state Exp;
branches;
next	1.10;

1.10
date	99.12.04.01.01.07;	author provos;	state Exp;
branches;
next	1.9;

1.9
date	98.11.25.00.30.26;	author espie;	state Exp;
branches;
next	1.8;

1.8
date	97.04.03.07.07.36;	author imp;	state Exp;
branches;
next	1.7;

1.7
date	96.09.24.04.19.29;	author millert;	state Exp;
branches;
next	1.6;

1.6
date	96.09.23.10.54.22;	author deraadt;	state Exp;
branches;
next	1.5;

1.5
date	96.09.15.19.19.52;	author millert;	state Exp;
branches;
next	1.4;

1.4
date	96.07.01.20.40.10;	author deraadt;	state Exp;
branches;
next	1.3;

1.3
date	96.06.25.23.06.41;	author deraadt;	state Exp;
branches;
next	1.2;

1.2
date	96.06.10.11.21.33;	author niklas;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.45.56;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.45.56;	author deraadt;	state Exp;
branches;
next	;

1.41.6.1
date	2015.07.27.16.08.18;	author guenther;	state Exp;
branches;
next	1.41.6.2;
commitid	ltV6h69MuIPDoBUT;

1.41.6.2
date	2015.07.31.18.21.58;	author krw;	state Exp;
branches;
next	;
commitid	77ByRhftWt8EOKeT;

1.51.2.1
date	2015.07.27.16.10.54;	author krw;	state Exp;
branches;
next	1.51.2.2;
commitid	7qowXgsHJsgQ1um1;

1.51.2.2
date	2015.07.31.18.34.30;	author krw;	state Exp;
branches;
next	;
commitid	ODwFmjskSseYGsQF;


desc
@@


1.56
log
@One string buffer can use recallocarray() to ensure that the address space
doesn't get dribbled with known contents.
ok otto millert tobias
@
text
@/*	$OpenBSD: pch.c,v 1.55 2016/09/02 09:48:03 otto Exp $	*/

/*
 * patch - a program to apply diffs to original files
 * 
 * Copyright 1986, Larry Wall
 * 
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following condition is met:
 * 1. Redistributions of source code must retain the above copyright notice,
 * this condition and the following disclaimer.
 * 
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND ANY
 * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
 * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 * 
 * -C option added in 1998, original code by Marc Espie, based on FreeBSD
 * behaviour
 */

#include <sys/types.h>
#include <sys/stat.h>

#include <ctype.h>
#include <libgen.h>
#include <limits.h>
#include <stdint.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>

#include "common.h"
#include "util.h"
#include "pch.h"
#include "pathnames.h"

/* Patch (diff listing) abstract type. */

FILE	*pfp = NULL;		/* patch file pointer */
LINENUM	 p_input_line = 0;	/* current line # from patch file */

static off_t	p_filesize;	/* size of the patch file */
static LINENUM	p_first;	/* 1st line number */
static LINENUM	p_newfirst;	/* 1st line number of replacement */
static LINENUM	p_ptrn_lines;	/* # lines in pattern */
static LINENUM	p_repl_lines;	/* # lines in replacement text */
static LINENUM	p_end = -1;	/* last line in hunk */
static LINENUM	p_max;		/* max allowed value of p_end */
static LINENUM	p_context = 3;	/* # of context lines */
static char	**p_line = NULL;/* the text of the hunk */
static short	*p_len = NULL;	/* length of each line */
static char	*p_char = NULL;	/* +, -, and ! */
static int	hunkmax = INITHUNKMAX;	/* size of above arrays to begin with */
static int	p_indent;	/* indent to patch */
static off_t	p_base;		/* where to intuit this time */
static LINENUM	p_bline;	/* line # of p_base */
static off_t	p_start;	/* where intuit found a patch */
static LINENUM	p_sline;	/* and the line number for it */
static LINENUM	p_hunk_beg;	/* line number of current hunk */
static LINENUM	p_efake = -1;	/* end of faked up lines--don't free */
static LINENUM	p_bfake = -1;	/* beg of faked up lines */
static char	*bestguess = NULL;	/* guess at correct filename */

static void	grow_hunkmax(void);
static int	intuit_diff_type(void);
static void	skip_to(off_t, LINENUM);
static char	*best_name(const struct file_name *, bool);
static char	*posix_name(const struct file_name *, bool);
static size_t	num_components(const char *);

/*
 * Prepare to look for the next patch in the patch file.
 */
void
re_patch(void)
{
	p_first = 0;
	p_newfirst = 0;
	p_ptrn_lines = 0;
	p_repl_lines = 0;
	p_end = (LINENUM) - 1;
	p_max = 0;
	p_indent = 0;
}

/*
 * Open the patch file at the beginning of time.
 */
void
open_patch_file(const char *filename)
{
	struct stat filestat;

	if (filename == NULL || *filename == '\0' || strEQ(filename, "-")) {
		pfp = fopen(TMPPATNAME, "w");
		if (pfp == NULL)
			pfatal("can't create %s", TMPPATNAME);
		while (fgets(buf, sizeof buf, stdin) != NULL)
			fputs(buf, pfp);
		fclose(pfp);
		filename = TMPPATNAME;
	}
	pfp = fopen(filename, "r");
	if (pfp == NULL)
		pfatal("patch file %s not found", filename);
	if (fstat(fileno(pfp), &filestat))
		pfatal("can't stat %s", filename);
	p_filesize = filestat.st_size;
	next_intuit_at(0, 1L);	/* start at the beginning */
	set_hunkmax();
}

/*
 * Make sure our dynamically realloced tables are malloced to begin with.
 */
void
set_hunkmax(void)
{
	if (p_line == NULL)
		p_line = calloc((size_t) hunkmax, sizeof(char *));
	if (p_len == NULL)
		p_len = calloc((size_t) hunkmax, sizeof(short));
	if (p_char == NULL)
		p_char = calloc((size_t) hunkmax, sizeof(char));
}

/*
 * Enlarge the arrays containing the current hunk of patch.
 */
static void
grow_hunkmax(void)
{
	int		new_hunkmax;
	char		**new_p_line;
	short		*new_p_len;
	char		*new_p_char;

	new_hunkmax = hunkmax * 2;

	if (p_line == NULL || p_len == NULL || p_char == NULL)
		fatal("Internal memory allocation error\n");

	new_p_line = reallocarray(p_line, new_hunkmax, sizeof(char *));
	if (new_p_line == NULL)
		free(p_line);

	new_p_len = reallocarray(p_len, new_hunkmax, sizeof(short));
	if (new_p_len == NULL)
		free(p_len);

	new_p_char = recallocarray(p_char, hunkmax, new_hunkmax, sizeof(char));
	if (new_p_char == NULL)
		free(p_char);

	p_char = new_p_char;
	p_len = new_p_len;
	p_line = new_p_line;

	if (p_line != NULL && p_len != NULL && p_char != NULL) {
		hunkmax = new_hunkmax;
		return;
	}

	if (!using_plan_a)
		fatal("out of memory\n");
	out_of_mem = true;	/* whatever is null will be allocated again */
				/* from within plan_a(), of all places */
}

/* True if the remainder of the patch file contains a diff of some sort. */

bool
there_is_another_patch(void)
{
	bool exists = false;

	if (p_base != 0 && p_base >= p_filesize) {
		if (verbose)
			say("done\n");
		return false;
	}
	if (verbose)
		say("Hmm...");
	diff_type = intuit_diff_type();
	if (!diff_type) {
		if (p_base != 0) {
			if (verbose)
				say("  Ignoring the trailing garbage.\ndone\n");
		} else
			say("  I can't seem to find a patch in there anywhere.\n");
		return false;
	}
	if (verbose)
		say("  %sooks like %s to me...\n",
		    (p_base == 0 ? "L" : "The next patch l"),
		    diff_type == UNI_DIFF ? "a unified diff" :
		    diff_type == CONTEXT_DIFF ? "a context diff" :
		diff_type == NEW_CONTEXT_DIFF ? "a new-style context diff" :
		    diff_type == NORMAL_DIFF ? "a normal diff" :
		    "an ed script");
	if (p_indent && verbose)
		say("(Patch is indented %d space%s.)\n", p_indent,
		    p_indent == 1 ? "" : "s");
	skip_to(p_start, p_sline);
	while (filearg[0] == NULL) {
		if (force || batch) {
			say("No file to patch.  Skipping...\n");
			filearg[0] = xstrdup(bestguess);
			skip_rest_of_patch = true;
			return true;
		}
		ask("File to patch: ");
		if (*buf != '\n') {
			free(bestguess);
			bestguess = xstrdup(buf);
			filearg[0] = fetchname(buf, &exists, 0);
		}
		if (!exists) {
			int def_skip = *bestguess == '\0';
			ask("No file found--skip this patch? [%c] ",
			    def_skip  ? 'y' : 'n');
			if (*buf == 'n' || (!def_skip && *buf != 'y'))
				continue;
			if (verbose)
				say("Skipping patch...\n");
			free(filearg[0]);
			filearg[0] = fetchname(bestguess, &exists, 0);
			skip_rest_of_patch = true;
			return true;
		}
	}
	return true;
}

/* Determine what kind of diff is in the remaining part of the patch file. */

static int
intuit_diff_type(void)
{
	off_t	this_line = 0, previous_line;
	off_t	first_command_line = -1;
	LINENUM	fcl_line = -1;
	bool	last_line_was_command = false, this_is_a_command = false;
	bool	stars_last_line = false, stars_this_line = false;
	char	*s, *t;
	int	indent, retval;
	struct file_name names[MAX_FILE];

	memset(names, 0, sizeof(names));
	ok_to_create_file = false;
	fseeko(pfp, p_base, SEEK_SET);
	p_input_line = p_bline - 1;
	for (;;) {
		previous_line = this_line;
		last_line_was_command = this_is_a_command;
		stars_last_line = stars_this_line;
		this_line = ftello(pfp);
		indent = 0;
		p_input_line++;
		if (fgets(buf, sizeof buf, pfp) == NULL) {
			if (first_command_line >= 0) {
				/* nothing but deletes!? */
				p_start = first_command_line;
				p_sline = fcl_line;
				retval = ED_DIFF;
				goto scan_exit;
			} else {
				p_start = this_line;
				p_sline = p_input_line;
				retval = 0;
				goto scan_exit;
			}
		}
		for (s = buf; *s == ' ' || *s == '\t' || *s == 'X'; s++) {
			if (*s == '\t')
				indent += 8 - (indent % 8);
			else
				indent++;
		}
		for (t = s; isdigit((unsigned char)*t) || *t == ','; t++)
			;
		this_is_a_command = (isdigit((unsigned char)*s) &&
		    (*t == 'd' || *t == 'c' || *t == 'a'));
		if (first_command_line < 0 && this_is_a_command) {
			first_command_line = this_line;
			fcl_line = p_input_line;
			p_indent = indent;	/* assume this for now */
		}
		if (!stars_last_line && strnEQ(s, "*** ", 4))
			names[OLD_FILE].path = fetchname(s + 4,
			    &names[OLD_FILE].exists, strippath);
		else if (strnEQ(s, "--- ", 4))
			names[NEW_FILE].path = fetchname(s + 4,
			    &names[NEW_FILE].exists, strippath);
		else if (strnEQ(s, "+++ ", 4))
			/* pretend it is the old name */
			names[OLD_FILE].path = fetchname(s + 4,
			    &names[OLD_FILE].exists, strippath);
		else if (strnEQ(s, "Index:", 6))
			names[INDEX_FILE].path = fetchname(s + 6,
			    &names[INDEX_FILE].exists, strippath);
		else if (strnEQ(s, "Prereq:", 7)) {
			for (t = s + 7; isspace((unsigned char)*t); t++)
				;
			revision = xstrdup(t);
			for (t = revision;
			    *t && !isspace((unsigned char)*t); t++)
				;
			*t = '\0';
			if (*revision == '\0') {
				free(revision);
				revision = NULL;
			}
		}
		if ((!diff_type || diff_type == ED_DIFF) &&
		    first_command_line >= 0 &&
		    strEQ(s, ".\n")) {
			p_indent = indent;
			p_start = first_command_line;
			p_sline = fcl_line;
			retval = ED_DIFF;
			goto scan_exit;
		}
		if ((!diff_type || diff_type == UNI_DIFF) && strnEQ(s, "@@@@ -", 4)) {
			if (strnEQ(s + 4, "0,0", 3))
				ok_to_create_file = true;
			p_indent = indent;
			p_start = this_line;
			p_sline = p_input_line;
			retval = UNI_DIFF;
			goto scan_exit;
		}
		stars_this_line = strnEQ(s, "********", 8);
		if ((!diff_type || diff_type == CONTEXT_DIFF) && stars_last_line &&
		    strnEQ(s, "*** ", 4)) {
			if (strtolinenum(s + 4, &s) == 0)
				ok_to_create_file = true;
			/*
			 * If this is a new context diff the character just
			 * at the end of the line is a '*'.
			 */
			while (*s && *s != '\n')
				s++;
			p_indent = indent;
			p_start = previous_line;
			p_sline = p_input_line - 1;
			retval = (*(s - 1) == '*' ? NEW_CONTEXT_DIFF : CONTEXT_DIFF);
			goto scan_exit;
		}
		if ((!diff_type || diff_type == NORMAL_DIFF) &&
		    last_line_was_command &&
		    (strnEQ(s, "< ", 2) || strnEQ(s, "> ", 2))) {
			p_start = previous_line;
			p_sline = p_input_line - 1;
			p_indent = indent;
			retval = NORMAL_DIFF;
			goto scan_exit;
		}
	}
scan_exit:
	if (retval == UNI_DIFF) {
		/* unswap old and new */
		struct file_name tmp = names[OLD_FILE];
		names[OLD_FILE] = names[NEW_FILE];
		names[NEW_FILE] = tmp;
	}
	if (filearg[0] == NULL) {
		if (posix)
			filearg[0] = posix_name(names, ok_to_create_file);
		else {
			/* Ignore the Index: name for context diffs, like GNU */
			if (names[OLD_FILE].path != NULL ||
			    names[NEW_FILE].path != NULL) {
				free(names[INDEX_FILE].path);
				names[INDEX_FILE].path = NULL;
			}
			filearg[0] = best_name(names, ok_to_create_file);
		}
	}

	free(bestguess);
	bestguess = NULL;
	if (filearg[0] != NULL)
		bestguess = xstrdup(filearg[0]);
	else if (!ok_to_create_file) {
		/*
		 * We don't want to create a new file but we need a
		 * filename to set bestguess.  Avoid setting filearg[0]
		 * so the file is not created automatically.
		 */
		if (posix)
			bestguess = posix_name(names, true);
		else
			bestguess = best_name(names, true);
	}
	free(names[OLD_FILE].path);
	free(names[NEW_FILE].path);
	free(names[INDEX_FILE].path);
	return retval;
}

/*
 * Remember where this patch ends so we know where to start up again.
 */
void
next_intuit_at(off_t file_pos, LINENUM file_line)
{
	p_base = file_pos;
	p_bline = file_line;
}

/*
 * Basically a verbose fseeko() to the actual diff listing.
 */
static void
skip_to(off_t file_pos, LINENUM file_line)
{
	char	*ret;

	if (p_base > file_pos)
		fatal("Internal error: seek %lld>%lld\n",
		    (long long)p_base, (long long)file_pos);
	if (verbose && p_base < file_pos) {
		fseeko(pfp, p_base, SEEK_SET);
		say("The text leading up to this was:\n--------------------------\n");
		while (ftello(pfp) < file_pos) {
			ret = fgets(buf, sizeof buf, pfp);
			if (ret == NULL)
				fatal("Unexpected end of file\n");
			say("|%s", buf);
		}
		say("--------------------------\n");
	} else
		fseeko(pfp, file_pos, SEEK_SET);
	p_input_line = file_line - 1;
}

/* Make this a function for better debugging.  */
static void
malformed(void)
{
	fatal("malformed patch at line %ld: %s", p_input_line, buf);
	/* about as informative as "Syntax error" in C */
}

/*
 * True if the line has been discarded (i.e. it is a line saying
 *  "\ No newline at end of file".)
 */
static bool
remove_special_line(void)
{
	int	c;

	c = fgetc(pfp);
	if (c == '\\') {
		do {
			c = fgetc(pfp);
		} while (c != EOF && c != '\n');

		return true;
	}
	if (c != EOF)
		fseeko(pfp, -1, SEEK_CUR);

	return false;
}

/*
 * True if there is more of the current diff listing to process.
 */
bool
another_hunk(void)
{
	off_t	line_beginning;			/* file pos of the current line */
	LINENUM	repl_beginning;			/* index of --- line */
	LINENUM	fillcnt;			/* #lines of missing ptrn or repl */
	LINENUM	fillsrc;			/* index of first line to copy */
	LINENUM	filldst;			/* index of first missing line */
	bool	ptrn_spaces_eaten;		/* ptrn was slightly misformed */
	bool	repl_could_be_missing;		/* no + or ! lines in this hunk */
	bool	repl_missing;			/* we are now backtracking */
	off_t	repl_backtrack_position;	/* file pos of first repl line */
	LINENUM	repl_patch_line;		/* input line number for same */
	LINENUM	ptrn_copiable;			/* # of copiable lines in ptrn */
	char	*s, *ret;
	int	context = 0;

	while (p_end >= 0) {
		if (p_end == p_efake)
			p_end = p_bfake;	/* don't free twice */
		else
			free(p_line[p_end]);
		p_end--;
	}
	p_efake = -1;

	p_max = hunkmax;	/* gets reduced when --- found */
	if (diff_type == CONTEXT_DIFF || diff_type == NEW_CONTEXT_DIFF) {
		line_beginning = ftello(pfp);
		repl_beginning = 0;
		fillcnt = 0;
		fillsrc = 0;
		ptrn_spaces_eaten = false;
		repl_could_be_missing = true;
		repl_missing = false;
		repl_backtrack_position = 0;
		repl_patch_line = 0;
		ptrn_copiable = 0;

		ret = pgets(buf, sizeof buf, pfp);
		p_input_line++;
		if (ret == NULL || strnNE(buf, "********", 8)) {
			next_intuit_at(line_beginning, p_input_line);
			return false;
		}
		p_context = 100;
		p_hunk_beg = p_input_line + 1;
		while (p_end < p_max) {
			line_beginning = ftello(pfp);
			ret = pgets(buf, sizeof buf, pfp);
			p_input_line++;
			if (ret == NULL) {
				if (p_max - p_end < 4) {
					/* assume blank lines got chopped */
					strlcpy(buf, "  \n", sizeof buf);
				} else {
					if (repl_beginning && repl_could_be_missing) {
						repl_missing = true;
						goto hunk_done;
					}
					fatal("unexpected end of file in patch\n");
				}
			}
			p_end++;
			if (p_end >= hunkmax)
				fatal("Internal error: hunk larger than hunk "
				    "buffer size");
			p_char[p_end] = *buf;
			p_line[p_end] = NULL;
			switch (*buf) {
			case '*':
				if (strnEQ(buf, "********", 8)) {
					if (repl_beginning && repl_could_be_missing) {
						repl_missing = true;
						goto hunk_done;
					} else
						fatal("unexpected end of hunk "
						    "at line %ld\n",
						    p_input_line);
				}
				if (p_end != 0) {
					if (repl_beginning && repl_could_be_missing) {
						repl_missing = true;
						goto hunk_done;
					}
					fatal("unexpected *** at line %ld: %s",
					    p_input_line, buf);
				}
				context = 0;
				p_line[p_end] = savestr(buf);
				if (out_of_mem) {
					p_end--;
					return false;
				}
				for (s = buf;
				    *s && !isdigit((unsigned char)*s); s++)
					;
				if (!*s)
					malformed();
				if (strnEQ(s, "0,0", 3))
					memmove(s, s + 2, strlen(s + 2) + 1);
				p_first = strtolinenum(s, &s);
				if (*s == ',') {
					for (; *s && !isdigit((unsigned char)*s); s++)
						;
					if (!*s)
						malformed();
					p_ptrn_lines = strtolinenum(s, &s) - p_first + 1;
					if (p_ptrn_lines < 0)
						malformed();
				} else if (p_first)
					p_ptrn_lines = 1;
				else {
					p_ptrn_lines = 0;
					p_first = 1;
				}
				if (p_first >= LINENUM_MAX - p_ptrn_lines ||
				    p_ptrn_lines >= LINENUM_MAX - 6)
					malformed();

				/* we need this much at least */
				p_max = p_ptrn_lines + 6;
				while (p_max >= hunkmax)
					grow_hunkmax();
				p_max = hunkmax;
				break;
			case '-':
				if (buf[1] == '-') {
					if (repl_beginning ||
					    (p_end != p_ptrn_lines + 1 +
					    (p_char[p_end - 1] == '\n'))) {
						if (p_end == 1) {
							/*
							 * `old' lines were omitted;
							 * set up to fill them in
							 * from 'new' context lines.
							 */
							p_end = p_ptrn_lines + 1;
							fillsrc = p_end + 1;
							filldst = 1;
							fillcnt = p_ptrn_lines;
						} else {
							if (repl_beginning) {
								if (repl_could_be_missing) {
									repl_missing = true;
									goto hunk_done;
								}
								fatal("duplicate \"---\" at line %ld--check line numbers at line %ld\n",
								    p_input_line, p_hunk_beg + repl_beginning);
							} else {
								fatal("%s \"---\" at line %ld--check line numbers at line %ld\n",
								    (p_end <= p_ptrn_lines
								    ? "Premature"
								    : "Overdue"),
								    p_input_line, p_hunk_beg);
							}
						}
					}
					repl_beginning = p_end;
					repl_backtrack_position = ftello(pfp);
					repl_patch_line = p_input_line;
					p_line[p_end] = savestr(buf);
					if (out_of_mem) {
						p_end--;
						return false;
					}
					p_char[p_end] = '=';
					for (s = buf;
					    *s && !isdigit((unsigned char)*s); s++)
						;
					if (!*s)
						malformed();
					p_newfirst = strtolinenum(s, &s);
					if (*s == ',') {
						for (; *s && !isdigit((unsigned char)*s); s++)
							;
						if (!*s)
							malformed();
						p_repl_lines = strtolinenum(s, &s) -
						    p_newfirst + 1;
						if (p_repl_lines < 0)
							malformed();
					} else if (p_newfirst)
						p_repl_lines = 1;
					else {
						p_repl_lines = 0;
						p_newfirst = 1;
					}
					if (p_newfirst >= LINENUM_MAX - p_repl_lines ||
					    p_repl_lines >= LINENUM_MAX - p_end)
						malformed();
					p_max = p_repl_lines + p_end;
					if (p_max > MAXHUNKSIZE)
						fatal("hunk too large (%ld lines) at line %ld: %s",
						    p_max, p_input_line, buf);
					while (p_max >= hunkmax)
						grow_hunkmax();
					if (p_repl_lines != ptrn_copiable &&
					    (p_context != 0 || p_repl_lines != 1))
						repl_could_be_missing = false;
					break;
				}
				goto change_line;
			case '+':
			case '!':
				repl_could_be_missing = false;
		change_line:
				if (buf[1] == '\n' && canonicalize)
					strlcpy(buf + 1, " \n", sizeof buf - 1);
				if (!isspace((unsigned char)buf[1]) &&
				    buf[1] != '>' && buf[1] != '<' &&
				    repl_beginning && repl_could_be_missing) {
					repl_missing = true;
					goto hunk_done;
				}
				if (context >= 0) {
					if (context < p_context)
						p_context = context;
					context = -1000;
				}
				p_line[p_end] = savestr(buf + 2);
				if (out_of_mem) {
					p_end--;
					return false;
				}
				if (p_end == p_ptrn_lines) {
					if (remove_special_line()) {
						int	len;

						len = strlen(p_line[p_end]) - 1;
						(p_line[p_end])[len] = 0;
					}
				}
				break;
			case '\t':
			case '\n':	/* assume the 2 spaces got eaten */
				if (repl_beginning && repl_could_be_missing &&
				    (!ptrn_spaces_eaten ||
				    diff_type == NEW_CONTEXT_DIFF)) {
					repl_missing = true;
					goto hunk_done;
				}
				p_line[p_end] = savestr(buf);
				if (out_of_mem) {
					p_end--;
					return false;
				}
				if (p_end != p_ptrn_lines + 1) {
					ptrn_spaces_eaten |= (repl_beginning != 0);
					context++;
					if (!repl_beginning)
						ptrn_copiable++;
					p_char[p_end] = ' ';
				}
				break;
			case ' ':
				if (!isspace((unsigned char)buf[1]) &&
				    repl_beginning && repl_could_be_missing) {
					repl_missing = true;
					goto hunk_done;
				}
				context++;
				if (!repl_beginning)
					ptrn_copiable++;
				p_line[p_end] = savestr(buf + 2);
				if (out_of_mem) {
					p_end--;
					return false;
				}
				break;
			default:
				if (repl_beginning && repl_could_be_missing) {
					repl_missing = true;
					goto hunk_done;
				}
				malformed();
			}
			/* set up p_len for strncmp() so we don't have to */
			/* assume null termination */
			if (p_line[p_end])
				p_len[p_end] = strlen(p_line[p_end]);
			else
				p_len[p_end] = 0;
		}

hunk_done:
		if (p_end >= 0 && !repl_beginning)
			fatal("no --- found in patch at line %ld\n", pch_hunk_beg());

		if (repl_missing) {

			/* reset state back to just after --- */
			p_input_line = repl_patch_line;
			for (p_end--; p_end > repl_beginning; p_end--)
				free(p_line[p_end]);
			fseeko(pfp, repl_backtrack_position, SEEK_SET);

			/* redundant 'new' context lines were omitted - set */
			/* up to fill them in from the old file context */
			if (!p_context && p_repl_lines == 1) {
				p_repl_lines = 0;
				p_max--;
			}
			fillsrc = 1;
			filldst = repl_beginning + 1;
			fillcnt = p_repl_lines;
			p_end = p_max;
		} else if (!p_context && fillcnt == 1) {
			/* the first hunk was a null hunk with no context */
			/* and we were expecting one line -- fix it up. */
			while (filldst < p_end) {
				p_line[filldst] = p_line[filldst + 1];
				p_char[filldst] = p_char[filldst + 1];
				p_len[filldst] = p_len[filldst + 1];
				filldst++;
			}
#if 0
			repl_beginning--;	/* this doesn't need to be fixed */
#endif
			p_end--;
			p_first++;	/* do append rather than insert */
			fillcnt = 0;
			p_ptrn_lines = 0;
		}
		if (diff_type == CONTEXT_DIFF &&
		    (fillcnt || (p_first > 1 && ptrn_copiable > 2 * p_context))) {
			if (verbose)
				say("%s\n%s\n%s\n",
				    "(Fascinating--this is really a new-style context diff but without",
				    "the telltale extra asterisks on the *** line that usually indicate",
				    "the new style...)");
			diff_type = NEW_CONTEXT_DIFF;
		}
		/* if there were omitted context lines, fill them in now */
		if (fillcnt) {
			p_bfake = filldst;	/* remember where not to free() */
			p_efake = filldst + fillcnt - 1;
			while (fillcnt-- > 0) {
				while (fillsrc <= p_end && p_char[fillsrc] != ' ')
					fillsrc++;
				if (fillsrc > p_end)
					fatal("replacement text or line numbers mangled in hunk at line %ld\n",
					    p_hunk_beg);
				p_line[filldst] = p_line[fillsrc];
				p_char[filldst] = p_char[fillsrc];
				p_len[filldst] = p_len[fillsrc];
				fillsrc++;
				filldst++;
			}
			while (fillsrc <= p_end && fillsrc != repl_beginning &&
			    p_char[fillsrc] != ' ')
				fillsrc++;
#ifdef DEBUGGING
			if (debug & 64)
				printf("fillsrc %ld, filldst %ld, rb %ld, e+1 %ld\n",
				fillsrc, filldst, repl_beginning, p_end + 1);
#endif
			if (fillsrc != p_end + 1 && fillsrc != repl_beginning)
				malformed();
			if (filldst != p_end + 1 && filldst != repl_beginning)
				malformed();
		}
		if (p_line[p_end] != NULL) {
			if (remove_special_line()) {
				p_len[p_end] -= 1;
				(p_line[p_end])[p_len[p_end]] = 0;
			}
		}
	} else if (diff_type == UNI_DIFF) {
		off_t	line_beginning = ftello(pfp); /* file pos of the current line */
		LINENUM	fillsrc;	/* index of old lines */
		LINENUM	filldst;	/* index of new lines */
		char	ch;

		ret = pgets(buf, sizeof buf, pfp);
		p_input_line++;
		if (ret == NULL || strnNE(buf, "@@@@ -", 4)) {
			next_intuit_at(line_beginning, p_input_line);
			return false;
		}
		s = buf + 4;
		if (!*s)
			malformed();
		p_first = strtolinenum(s, &s);
		if (*s == ',') {
			p_ptrn_lines = strtolinenum(s + 1, &s);
		} else
			p_ptrn_lines = 1;
		if (*s == ' ')
			s++;
		if (*s != '+' || !*++s)
			malformed();
		p_newfirst = strtolinenum(s, &s);
		if (*s == ',') {
			p_repl_lines = strtolinenum(s + 1, &s);
		} else
			p_repl_lines = 1;
		if (*s == ' ')
			s++;
		if (*s != '@@')
			malformed();
		if (p_first >= LINENUM_MAX - p_ptrn_lines ||
		    p_newfirst > LINENUM_MAX - p_repl_lines ||
		    p_ptrn_lines >= LINENUM_MAX - p_repl_lines - 1)
			malformed();
		if (!p_ptrn_lines)
			p_first++;	/* do append rather than insert */
		p_max = p_ptrn_lines + p_repl_lines + 1;
		while (p_max >= hunkmax)
			grow_hunkmax();
		fillsrc = 1;
		filldst = fillsrc + p_ptrn_lines;
		p_end = filldst + p_repl_lines;
		snprintf(buf, sizeof buf, "*** %ld,%ld ****\n", p_first,
		    p_first + p_ptrn_lines - 1);
		p_line[0] = savestr(buf);
		if (out_of_mem) {
			p_end = -1;
			return false;
		}
		p_char[0] = '*';
		snprintf(buf, sizeof buf, "--- %ld,%ld ----\n", p_newfirst,
		    p_newfirst + p_repl_lines - 1);
		p_line[filldst] = savestr(buf);
		if (out_of_mem) {
			p_end = 0;
			return false;
		}
		p_char[filldst++] = '=';
		p_context = 100;
		context = 0;
		p_hunk_beg = p_input_line + 1;
		while (fillsrc <= p_ptrn_lines || filldst <= p_end) {
			line_beginning = ftello(pfp);
			ret = pgets(buf, sizeof buf, pfp);
			p_input_line++;
			if (ret == NULL) {
				if (p_max - filldst < 3) {
					/* assume blank lines got chopped */
					strlcpy(buf, " \n", sizeof buf);
				} else {
					fatal("unexpected end of file in patch\n");
				}
			}
			if (*buf == '\t' || *buf == '\n') {
				ch = ' ';	/* assume the space got eaten */
				s = savestr(buf);
			} else {
				ch = *buf;
				s = savestr(buf + 1);
			}
			if (out_of_mem) {
				while (--filldst > p_ptrn_lines)
					free(p_line[filldst]);
				p_end = fillsrc - 1;
				return false;
			}
			switch (ch) {
			case '-':
				if (fillsrc > p_ptrn_lines) {
					free(s);
					p_end = filldst - 1;
					malformed();
				}
				p_char[fillsrc] = ch;
				p_line[fillsrc] = s;
				p_len[fillsrc++] = strlen(s);
				if (fillsrc > p_ptrn_lines) {
					if (remove_special_line()) {
						p_len[fillsrc - 1] -= 1;
						s[p_len[fillsrc - 1]] = 0;
					}
				}
				break;
			case '=':
				ch = ' ';
				/* FALL THROUGH */
			case ' ':
				if (fillsrc > p_ptrn_lines) {
					free(s);
					while (--filldst > p_ptrn_lines)
						free(p_line[filldst]);
					p_end = fillsrc - 1;
					malformed();
				}
				context++;
				p_char[fillsrc] = ch;
				p_line[fillsrc] = s;
				p_len[fillsrc++] = strlen(s);
				s = savestr(s);
				if (out_of_mem) {
					while (--filldst > p_ptrn_lines)
						free(p_line[filldst]);
					p_end = fillsrc - 1;
					return false;
				}
				if (fillsrc > p_ptrn_lines) {
					if (remove_special_line()) {
						p_len[fillsrc - 1] -= 1;
						s[p_len[fillsrc - 1]] = 0;
					}
				}
				/* FALL THROUGH */
			case '+':
				if (filldst > p_end) {
					free(s);
					while (--filldst > p_ptrn_lines)
						free(p_line[filldst]);
					p_end = fillsrc - 1;
					malformed();
				}
				p_char[filldst] = ch;
				p_line[filldst] = s;
				p_len[filldst++] = strlen(s);
				if (fillsrc > p_ptrn_lines) {
					if (remove_special_line()) {
						p_len[filldst - 1] -= 1;
						s[p_len[filldst - 1]] = 0;
					}
				}
				break;
			default:
				p_end = filldst;
				malformed();
			}
			if (ch != ' ' && context > 0) {
				if (context < p_context)
					p_context = context;
				context = -1000;
			}
		}		/* while */
	} else {		/* normal diff--fake it up */
		char	hunk_type;
		int	i;
		LINENUM	min, max;
		off_t	line_beginning = ftello(pfp);

		p_context = 0;
		ret = pgets(buf, sizeof buf, pfp);
		p_input_line++;
		if (ret == NULL || !isdigit((unsigned char)*buf)) {
			next_intuit_at(line_beginning, p_input_line);
			return false;
		}
		p_first = strtolinenum(buf, &s);
		if (*s == ',') {
			p_ptrn_lines = strtolinenum(s + 1, &s) - p_first + 1;
			if (p_ptrn_lines < 0)
				malformed();
		} else
			p_ptrn_lines = (*s != 'a');
		if (p_first >= LINENUM_MAX - p_ptrn_lines)
			malformed();
		hunk_type = *s;
		if (hunk_type == 'a')
			p_first++;	/* do append rather than insert */
		min = strtolinenum(s + 1, &s);
		if (*s == ',')
			max = strtolinenum(s + 1, &s);
		else
			max = min;
		if (min < 0 || min > max || max - min == LINENUM_MAX)
			malformed();
		if (hunk_type == 'd')
			min++;
		p_newfirst = min;
		p_repl_lines = max - min + 1;
		if (p_newfirst > LINENUM_MAX - p_repl_lines ||
		    p_ptrn_lines >= LINENUM_MAX - p_repl_lines - 1)
			malformed();
		p_end = p_ptrn_lines + p_repl_lines + 1;
		if (p_end > MAXHUNKSIZE)
			fatal("hunk too large (%ld lines) at line %ld: %s",
			    p_end, p_input_line, buf);
		while (p_end >= hunkmax)
			grow_hunkmax();
		snprintf(buf, sizeof buf, "*** %ld,%ld\n", p_first,
		    p_first + p_ptrn_lines - 1);
		p_line[0] = savestr(buf);
		if (out_of_mem) {
			p_end = -1;
			return false;
		}
		p_char[0] = '*';
		for (i = 1; i <= p_ptrn_lines; i++) {
			ret = pgets(buf, sizeof buf, pfp);
			p_input_line++;
			if (ret == NULL)
				fatal("unexpected end of file in patch at line %ld\n",
				    p_input_line);
			if (*buf != '<')
				fatal("< expected at line %ld of patch\n",
				    p_input_line);
			p_line[i] = savestr(buf + 2);
			if (out_of_mem) {
				p_end = i - 1;
				return false;
			}
			p_len[i] = strlen(p_line[i]);
			p_char[i] = '-';
		}

		if (remove_special_line()) {
			p_len[i - 1] -= 1;
			(p_line[i - 1])[p_len[i - 1]] = 0;
		}
		if (hunk_type == 'c') {
			ret = pgets(buf, sizeof buf, pfp);
			p_input_line++;
			if (ret == NULL)
				fatal("unexpected end of file in patch at line %ld\n",
				    p_input_line);
			if (*buf != '-')
				fatal("--- expected at line %ld of patch\n",
				    p_input_line);
		}
		snprintf(buf, sizeof(buf), "--- %ld,%ld\n", min, max);
		p_line[i] = savestr(buf);
		if (out_of_mem) {
			p_end = i - 1;
			return false;
		}
		p_char[i] = '=';
		for (i++; i <= p_end; i++) {
			ret = pgets(buf, sizeof buf, pfp);
			p_input_line++;
			if (ret == NULL)
				fatal("unexpected end of file in patch at line %ld\n",
				    p_input_line);
			if (*buf != '>')
				fatal("> expected at line %ld of patch\n",
				    p_input_line);
			p_line[i] = savestr(buf + 2);
			if (out_of_mem) {
				p_end = i - 1;
				return false;
			}
			p_len[i] = strlen(p_line[i]);
			p_char[i] = '+';
		}

		if (remove_special_line()) {
			p_len[i - 1] -= 1;
			(p_line[i - 1])[p_len[i - 1]] = 0;
		}
	}
	if (reverse)		/* backwards patch? */
		if (!pch_swap())
			say("Not enough memory to swap next hunk!\n");
#ifdef DEBUGGING
	if (debug & 2) {
		int	i;
		char	special;

		for (i = 0; i <= p_end; i++) {
			if (i == p_ptrn_lines)
				special = '^';
			else
				special = ' ';
			fprintf(stderr, "%3d %c %c %s", i, p_char[i],
			    special, p_line[i]);
			fflush(stderr);
		}
	}
#endif
	if (p_end + 1 < hunkmax)/* paranoia reigns supreme... */
		p_char[p_end + 1] = '^';	/* add a stopper for apply_hunk */
	return true;
}

/*
 * Input a line from the patch file, worrying about indentation.
 */
char *
pgets(char *bf, int sz, FILE *fp)
{
	char	*s, *ret = fgets(bf, sz, fp);
	int	indent = 0;

	if (p_indent && ret != NULL) {
		for (s = buf;
		    indent < p_indent && (*s == ' ' || *s == '\t' || *s == 'X');
		    s++) {
			if (*s == '\t')
				indent += 8 - (indent % 7);
			else
				indent++;
		}
		if (buf != s && strlcpy(buf, s, sizeof(buf)) >= sizeof(buf))
			fatal("buffer too small in pgets()\n");
	}
	return ret;
}

/*
 * Reverse the old and new portions of the current hunk.
 */
bool
pch_swap(void)
{
	char	**tp_line;	/* the text of the hunk */
	short	*tp_len;	/* length of each line */
	char	*tp_char;	/* +, -, and ! */
	LINENUM	i;
	LINENUM	n;
	bool	blankline = false;
	char	*s;

	i = p_first;
	p_first = p_newfirst;
	p_newfirst = i;

	/* make a scratch copy */

	tp_line = p_line;
	tp_len = p_len;
	tp_char = p_char;
	p_line = NULL;	/* force set_hunkmax to allocate again */
	p_len = NULL;
	p_char = NULL;
	set_hunkmax();
	if (p_line == NULL || p_len == NULL || p_char == NULL) {

		free(p_line);
		p_line = tp_line;
		free(p_len);
		p_len = tp_len;
		free(p_char);
		p_char = tp_char;
		return false;	/* not enough memory to swap hunk! */
	}
	/* now turn the new into the old */

	i = p_ptrn_lines + 1;
	if (tp_char[i] == '\n') {	/* account for possible blank line */
		blankline = true;
		i++;
	}
	if (p_efake >= 0) {	/* fix non-freeable ptr range */
		if (p_efake <= i)
			n = p_end - i + 1;
		else
			n = -i;
		p_efake += n;
		p_bfake += n;
	}
	for (n = 0; i <= p_end; i++, n++) {
		p_line[n] = tp_line[i];
		p_char[n] = tp_char[i];
		if (p_char[n] == '+')
			p_char[n] = '-';
		p_len[n] = tp_len[i];
	}
	if (blankline) {
		i = p_ptrn_lines + 1;
		p_line[n] = tp_line[i];
		p_char[n] = tp_char[i];
		p_len[n] = tp_len[i];
		n++;
	}
	if (p_char[0] != '=')
		fatal("Malformed patch at line %ld: expected '=' found '%c'\n",
		    p_input_line, p_char[0]);
	p_char[0] = '*';
	for (s = p_line[0]; *s; s++)
		if (*s == '-')
			*s = '*';

	/* now turn the old into the new */

	if (p_char[0] != '*')
		fatal("Malformed patch at line %ld: expected '*' found '%c'\n",
		    p_input_line, p_char[0]);
	tp_char[0] = '=';
	for (s = tp_line[0]; *s; s++)
		if (*s == '*')
			*s = '-';
	for (i = 0; n <= p_end; i++, n++) {
		p_line[n] = tp_line[i];
		p_char[n] = tp_char[i];
		if (p_char[n] == '-')
			p_char[n] = '+';
		p_len[n] = tp_len[i];
	}

	if (i != p_ptrn_lines + 1)
		fatal("Malformed patch at line %ld: expected %ld lines, "
		    "got %ld\n",
		    p_input_line, p_ptrn_lines + 1, i);

	i = p_ptrn_lines;
	p_ptrn_lines = p_repl_lines;
	p_repl_lines = i;

	free(tp_line);
	free(tp_len);
	free(tp_char);

	return true;
}

/*
 * Return the specified line position in the old file of the old context.
 */
LINENUM
pch_first(void)
{
	return p_first;
}

/*
 * Return the number of lines of old context.
 */
LINENUM
pch_ptrn_lines(void)
{
	return p_ptrn_lines;
}

/*
 * Return the probable line position in the new file of the first line.
 */
LINENUM
pch_newfirst(void)
{
	return p_newfirst;
}

/*
 * Return the number of lines in the replacement text including context.
 */
LINENUM
pch_repl_lines(void)
{
	return p_repl_lines;
}

/*
 * Return the number of lines in the whole hunk.
 */
LINENUM
pch_end(void)
{
	return p_end;
}

/*
 * Return the number of context lines before the first changed line.
 */
LINENUM
pch_context(void)
{
	return p_context;
}

/*
 * Return the length of a particular patch line.
 */
short
pch_line_len(LINENUM line)
{
	return p_len[line];
}

/*
 * Return the control character (+, -, *, !, etc) for a patch line.
 */
char
pch_char(LINENUM line)
{
	return p_char[line];
}

/*
 * Return a pointer to a particular patch line.
 */
char *
pfetch(LINENUM line)
{
	return p_line[line];
}

/*
 * Return where in the patch file this hunk began, for error messages.
 */
LINENUM
pch_hunk_beg(void)
{
	return p_hunk_beg;
}

/*
 * Choose the name of the file to be patched based on POSIX rules.
 * NOTE: the POSIX rules are amazingly stupid and we only follow them
 *       if the user specified --posix or set POSIXLY_CORRECT.
 */
static char *
posix_name(const struct file_name *names, bool assume_exists)
{
	char *path = NULL;
	int i;

	/*
	 * POSIX states that the filename will be chosen from one
	 * of the old, new and index names (in that order) if
	 * the file exists relative to CWD after -p stripping.
	 */
	for (i = 0; i < MAX_FILE; i++) {
		if (names[i].path != NULL && names[i].exists) {
			path = names[i].path;
			break;
		}
	}
	if (path == NULL && !assume_exists) {
		/*
		 * No files found, check to see if the diff could be
		 * creating a new file.
		 */
		if (path == NULL && ok_to_create_file &&
		    names[NEW_FILE].path != NULL)
			path = names[NEW_FILE].path;
	}

	return path ? xstrdup(path) : NULL;
}

static char *
compare_names(const struct file_name *names, bool assume_exists)
{
	size_t min_components, min_baselen, min_len, tmp;
	char *best = NULL;
	char *path;
	int i;

	/*
	 * The "best" name is the one with the fewest number of path
	 * components, the shortest basename length, and the shortest
	 * overall length (in that order).  We only use the Index: file
	 * if neither of the old or new files could be intuited from
	 * the diff header.
	 */
	min_components = min_baselen = min_len = SIZE_MAX;
	for (i = INDEX_FILE; i >= OLD_FILE; i--) {
		path = names[i].path;
		if (path == NULL || (!names[i].exists && !assume_exists))
			continue;
		if ((tmp = num_components(path)) > min_components)
			continue;
		if (tmp < min_components) {
			min_components = tmp;
			best = path;
		}
		if ((tmp = strlen(basename(path))) > min_baselen)
			continue;
		if (tmp < min_baselen) {
			min_baselen = tmp;
			best = path;
		}
		if ((tmp = strlen(path)) > min_len)
			continue;
		min_len = tmp;
		best = path;
	}
	return best;
}

/*
 * Choose the name of the file to be patched based the "best" one
 * available.
 */
static char *
best_name(const struct file_name *names, bool assume_exists)
{
	char *best;

	best = compare_names(names, assume_exists);

	/* No match?  Check to see if the diff could be creating a new file. */
	if (best == NULL && ok_to_create_file)
		best = names[NEW_FILE].path;

	return best ? xstrdup(best) : NULL;
}

static size_t
num_components(const char *path)
{
	size_t n;
	const char *cp;

	for (n = 0, cp = path; (cp = strchr(cp, '/')) != NULL; n++, cp++) {
		while (*cp == '/')
			cp++;		/* skip consecutive slashes */
	}
	return n;
}

/*
 * Convert number at NPTR into LINENUM and save address of first
 * character that is not a digit in ENDPTR.  If conversion is not
 * possible, call fatal.
 */
LINENUM
strtolinenum(char *nptr, char **endptr)
{
	LINENUM rv;
	char c;
	char *p;
	const char *errstr;

	for (p = nptr; isdigit((unsigned char)*p); p++)
		;

	if (p == nptr)
		malformed();

	c = *p;
	*p = '\0';

	rv = strtonum(nptr, 0, LINENUM_MAX, &errstr);
	if (errstr != NULL)
		fatal("invalid line number at line %ld: `%s' is %s\n",
		    p_input_line, nptr, errstr);

	*p = c;
	*endptr = p;

	return rv;
}
@


1.55
log
@If reading fails, do not go into infinite loop asking for a filename
Happens in bulf build where no tty is available.
ok sthen@@ naddy@@ $(jot -b yes 1000) landry@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pch.c,v 1.54 2015/10/16 07:33:47 tobias Exp $	*/
d160 1
a160 1
	new_p_char = reallocarray(p_char, new_hunkmax, sizeof(char));
@


1.54
log
@Add native support for ed-style diffs. No need to pledge "proc exec" anymore.

ok deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: pch.c,v 1.53 2015/07/31 00:24:14 millert Exp $	*/
d228 4
a231 2
			ask("No file found--skip this patch? [n] ");
			if (*buf != 'y')
@


1.53
log
@Account for newlines in substitution (s///) commands.  Substitution
commands might contain a newline in the replacement pattern (escaped
with a backslash before it), causing patch's understanding of the
state the ed child process is in to diverge from reality. This can
lead to patch unwillingly feeding '!' (execute shell command) lines
to ed.  From Martin Natano.  OK deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pch.c,v 1.52 2015/07/26 14:32:19 millert Exp $	*/
d48 3
a58 1
static LINENUM	p_input_line = 0;	/* current line # from patch file */
a70 1
static FILE	*pfp = NULL;	/* patch file pointer */
a74 1
static void	next_intuit_at(off_t, LINENUM);
a75 1
static char	*pgets(char *, int, FILE *);
a78 1
static LINENUM	strtolinenum(char *, char **);
d412 1
a412 1
static void
d1152 1
a1152 1
static char *
a1370 76
 * Apply an ed script by feeding ed itself.
 */
void
do_ed_script(void)
{
	char	*t;
	off_t	beginning_of_this_line;
	FILE	*pipefp = NULL;

	if (!skip_rest_of_patch) {
		if (copy_file(filearg[0], TMPOUTNAME) < 0) {
			unlink(TMPOUTNAME);
			fatal("can't create temp file %s", TMPOUTNAME);
		}
		snprintf(buf, sizeof buf, "%s%s%s", _PATH_ED,
		    verbose ? " " : " -s ", TMPOUTNAME);
		pipefp = popen(buf, "w");
	}
	for (;;) {
		beginning_of_this_line = ftello(pfp);
		if (pgets(buf, sizeof buf, pfp) == NULL) {
			next_intuit_at(beginning_of_this_line, p_input_line);
			break;
		}
		p_input_line++;
		for (t = buf; isdigit((unsigned char)*t) || *t == ','; t++)
			;
		/* POSIX defines allowed commands as {a,c,d,i,s} */
		if (isdigit((unsigned char)*buf) &&
		    *t != '\0' && strchr("acdis", *t) != NULL) {
			if (pipefp != NULL)
				fputs(buf, pipefp);
			if (*t == 's') {
				for (;;) {
					bool continued = false;
					t = buf + strlen(buf) - 1;
					while (--t >= buf && *t == '\\')
						continued = !continued;
					if (!continued ||
					    pgets(buf, sizeof buf, pfp) == NULL)
						break;
					if (pipefp != NULL)
						fputs(buf, pipefp);
				}
			} else if (*t != 'd') {
				while (pgets(buf, sizeof buf, pfp) != NULL) {
					p_input_line++;
					if (pipefp != NULL)
						fputs(buf, pipefp);
					if (strEQ(buf, ".\n"))
						break;
				}
			}
		} else {
			next_intuit_at(beginning_of_this_line, p_input_line);
			break;
		}
	}
	if (pipefp == NULL)
		return;
	fprintf(pipefp, "w\n");
	fprintf(pipefp, "q\n");
	fflush(pipefp);
	pclose(pipefp);
	ignore_signals();
	if (!check_only) {
		if (move_file(TMPOUTNAME, outname) < 0) {
			toutkeep = true;
			chmod(TMPOUTNAME, filemode);
		} else
			chmod(outname, filemode);
	}
	set_signals(1);
}

/*
d1481 1
a1481 1
static LINENUM
@


1.52
log
@Remove support for automatically checking files out of RCS.  The
behavior is confusing to users and even GNU patch no longer does
it by default.  OK krw@@ guenther@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pch.c,v 1.51 2015/02/05 12:59:57 millert Exp $	*/
d1405 13
a1417 1
			if (*t != 'd' && *t != 's') {
@


1.51
log
@Include stdint.h, not limits.h to get SIZE_MAX.  OK guenther@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pch.c,v 1.50 2014/12/14 09:12:59 tobias Exp $	*/
d1460 2
a1461 11
		 * No files found, look for something we can checkout from
		 * RCS dirs.  Same order as above.
		 */
		for (i = 0; i < MAX_FILE; i++) {
			if (names[i].path != NULL &&
			    (path = checked_in(names[i].path)) != NULL)
				break;
		}
		/*
		 * Still no match?  Check to see if the diff could be creating
		 * a new file.
d1472 1
a1472 1
compare_names(const struct file_name *names, bool assume_exists, int phase)
d1489 1
a1489 3
		if (path == NULL ||
		    (phase == 1 && !names[i].exists && !assume_exists) ||
		    (phase == 2 && checked_in(path) == NULL))
d1520 6
a1525 11
	best = compare_names(names, assume_exists, 1);
	if (best == NULL) {
		best = compare_names(names, assume_exists, 2);
		/*
		 * Still no match?  Check to see if the diff could be creating
		 * a new file.
		 */
		if (best == NULL && ok_to_create_file &&
		    names[NEW_FILE].path != NULL)
			best = names[NEW_FILE].path;
	}
@


1.51.2.1
log
@Backport commit of 2015-07-26 14:32 by millert

Remove support for automatically checking files out of RCS.  The
behavior is confusing to users and even GNU patch no longer does
it by default.  OK krw@@ guenther@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pch.c,v 1.51 2015/02/05 12:59:57 millert Exp $	*/
d1460 11
a1470 2
		 * No files found, check to see if the diff could be
		 * creating a new file.
d1481 1
a1481 1
compare_names(const struct file_name *names, bool assume_exists)
d1498 3
a1500 1
		if (path == NULL || (!names[i].exists && !assume_exists))
d1531 11
a1541 6
	best = compare_names(names, assume_exists);

	/* No match?  Check to see if the diff could be creating a new file. */
	if (best == NULL && ok_to_create_file)
		best = names[NEW_FILE].path;

@


1.51.2.2
log
@Backport rev 1.53 by millert:
Account for newlines in substitution (s///) commands.  Substitution
commands might contain a newline in the replacement pattern (escaped
with a backslash before it), causing patch's understanding of the
state the ed child process is in to diverge from reality. This can
lead to patch unwillingly feeding '!' (execute shell command) lines
to ed.  From Martin Natano.  OK deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pch.c,v 1.51.2.1 2015/07/27 16:10:54 krw Exp $	*/
d1405 1
a1405 13
			if (*t == 's') {
				for (;;) {
					bool continued = false;
					t = buf + strlen(buf) - 1;
					while (--t >= buf && *t == '\\')
						continued = !continued;
					if (!continued ||
					    pgets(buf, sizeof buf, pfp) == NULL)
						break;
					if (pipefp != NULL)
						fputs(buf, pipefp);
				}
			} else if (*t != 'd') {
@


1.50
log
@Handle ed command "s" as a one line command, which it is.
Prevents arbitrary ed command executions in following lines.

ok millert
@
text
@d1 1
a1 1
/*	$OpenBSD: pch.c,v 1.49 2014/12/13 10:31:07 tobias Exp $	*/
d35 1
@


1.49
log
@The function savestr allows NULL return values during Plan A patching so in
case of out of memory conditions, Plan B can step in.  In many cases, NULL
value is not properly handled, so use xstrdup here (it's outside Plan A/B
patching, which means that even Plan B relies on successful operations).
@
text
@d1 1
a1 1
/*	$OpenBSD: pch.c,v 1.48 2014/12/08 21:59:36 deraadt Exp $	*/
d1401 1
a1401 1
		    (*t == 'a' || *t == 'c' || *t == 'd' || *t == 'i' || *t == 's')) {
d1404 1
a1404 1
			if (*t != 'd') {
@


1.48
log
@spaces
@
text
@d1 1
a1 1
/*	$OpenBSD: pch.c,v 1.47 2014/12/01 06:38:04 deraadt Exp $	*/
d218 1
a218 1
			filearg[0] = savestr(bestguess);
d225 1
a225 1
			bestguess = savestr(buf);
d313 1
a313 1
			revision = savestr(t);
d392 1
a392 1
		bestguess = savestr(filearg[0]);
d1476 1
a1476 1
	return path ? savestr(path) : NULL;
d1541 1
a1541 1
	return best ? savestr(best) : NULL;
@


1.47
log
@three trivial reallocarray() uses
@
text
@d1 1
a1 1
/*	$OpenBSD: pch.c,v 1.46 2014/11/26 10:11:21 tobias Exp $	*/
d1583 1
a1583 1
 
@


1.46
log
@Properly validate line ranges supplied in diff file to prevent overflows.
Also fixes an out of boundary memory access because the resulting values
are used as array indices.

ok millert
@
text
@d1 1
a1 1
/*	$OpenBSD: pch.c,v 1.45 2014/11/25 10:26:07 tobias Exp $	*/
d153 1
a153 1
	new_p_line = realloc(p_line, new_hunkmax * sizeof(char *));
d157 1
a157 1
	new_p_len = realloc(p_len, new_hunkmax * sizeof(short));
d161 1
a161 1
	new_p_char = realloc(p_char, new_hunkmax * sizeof(char));
@


1.45
log
@Introduce strtolinenum to properly check line numbers while parsing:
no signs, no spaces, just digits, 0 <= x <= LONG_MAX

ok millert, otto
@
text
@d1 1
a1 1
/*	$OpenBSD: pch.c,v 1.44 2014/11/22 15:49:28 tobias Exp $	*/
d588 2
d596 3
d660 2
d668 3
d881 4
d1027 2
d1031 2
d1041 2
d1045 6
a1050 1
		p_end = p_ptrn_lines + 1 + max - min + 1;
a1055 2
		p_newfirst = min;
		p_repl_lines = max - min + 1;
@


1.44
log
@Remove SCCS support.  For this to work, we would need "get", which we don't
even have in ports.  XSI functionality of POSIX, therefore optional.

ok deraadt, schwarze, tedu
@
text
@d1 1
a1 1
/*	$OpenBSD: pch.c,v 1.43 2014/11/18 17:03:35 tobias Exp $	*/
d79 1
d344 1
a344 1
			if (atol(s + 4) == 0)
d581 1
a581 3
				p_first = (LINENUM) atol(s);
				while (isdigit((unsigned char)*s))
					s++;
d587 1
a587 1
					p_ptrn_lines = ((LINENUM) atol(s)) - p_first + 1;
d647 1
a647 3
					p_newfirst = (LINENUM) atol(s);
					while (isdigit((unsigned char)*s))
						s++;
d653 1
a653 1
						p_repl_lines = ((LINENUM) atol(s)) -
d853 1
a853 3
		p_first = (LINENUM) atol(s);
		while (isdigit((unsigned char)*s))
			s++;
d855 1
a855 3
			p_ptrn_lines = (LINENUM) atol(++s);
			while (isdigit((unsigned char)*s))
				s++;
d862 1
a862 3
		p_newfirst = (LINENUM) atol(s);
		while (isdigit((unsigned char)*s))
			s++;
d864 1
a864 3
			p_repl_lines = (LINENUM) atol(++s);
			while (isdigit((unsigned char)*s))
				s++;
d1010 1
a1010 3
		p_first = (LINENUM) atol(buf);
		for (s = buf; isdigit((unsigned char)*s); s++)
			;
d1012 1
a1012 3
			p_ptrn_lines = (LINENUM) atol(++s) - p_first + 1;
			while (isdigit((unsigned char)*s))
				s++;
d1018 1
a1018 3
		min = (LINENUM) atol(++s);
		for (; isdigit((unsigned char)*s); s++)
			;
d1020 1
a1020 1
			max = (LINENUM) atol(++s);
d1532 33
@


1.43
log
@Avoid iterating over end of string.

ok millert, otto
@
text
@d1 1
a1 1
/*	$OpenBSD: pch.c,v 1.42 2014/11/17 10:58:09 tobias Exp $	*/
d1454 1
a1454 1
		 * RCS/SCCS dirs.  Same order as above.
@


1.42
log
@Check fstat return value.  Also, use off_t for file size and offsets as
suggested by bluhm@@.

ok schwarze@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pch.c,v 1.41 2013/11/26 13:19:07 deraadt Exp $	*/
d347 1
a347 1
			 * before the newline is a '*'.
d349 1
a349 1
			while (*s != '\n')
@


1.41
log
@unsigned char casts for ctype
ok krw
@
text
@d1 1
a1 1
/*	$OpenBSD: pch.c,v 1.40 2013/07/11 12:39:31 otto Exp $	*/
d47 1
a47 1
static long	p_filesize;	/* size of the patch file */
d61 1
a61 1
static LINENUM	p_base;		/* where to intuit this time */
d63 1
a63 1
static LINENUM	p_start;	/* where intuit found a patch */
d73 2
a74 2
static void	next_intuit_at(LINENUM, LINENUM);
static void	skip_to(LINENUM, LINENUM);
d115 2
a116 1
	fstat(fileno(pfp), &filestat);
d118 1
a118 1
	next_intuit_at(0L, 1L);	/* start at the beginning */
d186 1
a186 1
	if (p_base != 0L && p_base >= p_filesize) {
d195 1
a195 1
		if (p_base != 0L) {
d204 1
a204 1
		    (p_base == 0L ? "L" : "The next patch l"),
d247 2
a248 2
	long	this_line = 0, previous_line;
	long	first_command_line = -1;
d258 1
a258 1
	fseek(pfp, p_base, SEEK_SET);
d264 1
a264 1
		this_line = ftell(pfp);
d268 1
a268 1
			if (first_command_line >= 0L) {
d291 1
a291 1
		if (first_command_line < 0L && this_is_a_command) {
d323 1
a323 1
		    first_command_line >= 0L &&
d413 1
a413 1
next_intuit_at(LINENUM file_pos, LINENUM file_line)
d420 1
a420 1
 * Basically a verbose fseek() to the actual diff listing.
d423 1
a423 1
skip_to(LINENUM file_pos, LINENUM file_line)
d428 2
a429 1
		fatal("Internal error: seek %ld>%ld\n", p_base, file_pos);
d431 1
a431 1
		fseek(pfp, p_base, SEEK_SET);
d433 1
a433 1
		while (ftell(pfp) < file_pos) {
d441 1
a441 1
		fseek(pfp, file_pos, SEEK_SET);
d471 1
a471 1
		fseek(pfp, -1L, SEEK_CUR);
d482 1
a482 1
	long	line_beginning;			/* file pos of the current line */
d490 1
a490 1
	long	repl_backtrack_position;	/* file pos of first repl line */
d507 1
a507 1
		line_beginning = ftell(pfp);
d527 1
a527 1
			line_beginning = ftell(pfp);
d635 1
a635 1
					repl_backtrack_position = ftell(pfp);
d768 1
a768 1
			fseek(pfp, repl_backtrack_position, SEEK_SET);
d842 1
a842 1
		long	line_beginning = ftell(pfp); /* file pos of the current line */
d910 1
a910 1
			line_beginning = ftell(pfp);
d1012 1
a1012 1
		long	line_beginning = ftell(pfp);
d1372 1
a1372 1
	long	beginning_of_this_line;
d1385 1
a1385 1
		beginning_of_this_line = ftell(pfp);
@


1.41.6.1
log
@Backport commit of 2014-11-22 15:49 by tobias:
Remove SCCS support.  For this to work, we would need "get", which we don't     even have in ports.  XSI functionality of POSIX, therefore optional.

ok deraadt, schwarze, tedu
----------------------------
Backport commit of 2015-07-26 14:32 by millert
Remove support for automatically checking files out of RCS.  The                behavior is confusing to users and even GNU patch no longer does
it by default.  OK krw@@ guenther@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pch.c,v 1.41 2013/11/26 13:19:07 deraadt Exp $	*/
d1451 11
a1461 2
		 * No files found, check to see if the diff could be
		 * creating a new file.
d1472 1
a1472 1
compare_names(const struct file_name *names, bool assume_exists)
d1489 3
a1491 1
		if (path == NULL || (!names[i].exists && !assume_exists))
d1522 11
a1532 6
	best = compare_names(names, assume_exists);

	/* No match?  Check to see if the diff could be creating a new file. */
	if (best == NULL && ok_to_create_file)
		best = names[NEW_FILE].path;

@


1.41.6.2
log
@Backport rev 1.53 by millert:
Account for newlines in substitution (s///) commands.  Substitution
commands might contain a newline in the replacement pattern (escaped
with a backslash before it), causing patch's understanding of the
state the ed child process is in to diverge from reality. This can
lead to patch unwillingly feeding '!' (execute shell command) lines
to ed.  From Martin Natano.  OK deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pch.c,v 1.41.6.1 2015/07/27 16:08:18 guenther Exp $	*/
d1396 1
a1396 13
			if (*t == 's') {
				for (;;) {
					bool continued = false;
					t = buf + strlen(buf) - 1;
					while (--t >= buf && *t == '\\')
						continued = !continued;
					if (!continued ||
					    pgets(buf, sizeof buf, pfp) == NULL)
						break;
					if (pipefp != NULL)
						fputs(buf, pipefp);
				}
			} else if (*t != 'd') {
@


1.40
log
@Bring file selection in accordance with the man page; from Stefan Esser
ok millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pch.c,v 1.39 2012/04/11 08:07:13 ajacoutot Exp $	*/
d286 1
a286 1
		for (t = s; isdigit(*t) || *t == ','; t++)
d288 1
a288 1
		this_is_a_command = (isdigit(*s) &&
d309 1
a309 1
			for (t = s + 7; isspace(*t); t++)
d312 2
a313 1
			for (t = revision; *t && !isspace(*t); t++)
d571 2
a572 1
				for (s = buf; *s && !isdigit(*s); s++)
d579 1
a579 1
				while (isdigit(*s))
d582 1
a582 1
					for (; *s && !isdigit(*s); s++)
d641 2
a642 1
					for (s = buf; *s && !isdigit(*s); s++)
d647 1
a647 1
					while (isdigit(*s))
d650 1
a650 1
						for (; *s && !isdigit(*s); s++)
d680 2
a681 2
				if (!isspace(buf[1]) && buf[1] != '>' &&
				    buf[1] != '<' &&
d727 1
a727 1
				if (!isspace(buf[1]) &&
d855 1
a855 1
		while (isdigit(*s))
d859 1
a859 1
			while (isdigit(*s))
d868 1
a868 1
		while (isdigit(*s))
d872 1
a872 1
			while (isdigit(*s))
d1015 1
a1015 1
		if (ret == NULL || !isdigit(*buf)) {
d1020 1
a1020 1
		for (s = buf; isdigit(*s); s++)
d1024 1
a1024 1
			while (isdigit(*s))
d1032 1
a1032 1
		for (; isdigit(*s); s++)
d1389 1
a1389 1
		for (t = buf; isdigit(*t) || *t == ','; t++)
d1392 2
a1393 2
		if (isdigit(*buf) && (*t == 'a' || *t == 'c' || *t == 'd' ||
		    *t == 'i' || *t == 's')) {
@


1.39
log
@Silence gcc warnings.

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pch.c,v 1.38 2009/10/27 23:59:41 deraadt Exp $	*/
a1467 4
/*
 * Choose the name of the file to be patched based the "best" one
 * available.
 */
d1469 1
a1469 1
best_name(const struct file_name *names, bool assume_exists)
d1473 1
d1485 4
a1488 2
		if (names[i].path == NULL ||
		    (!names[i].exists && !assume_exists))
d1490 1
a1490 1
		if ((tmp = num_components(names[i].path)) > min_components)
d1492 5
a1496 2
		min_components = tmp;
		if ((tmp = strlen(basename(names[i].path))) > min_baselen)
d1498 5
a1502 2
		min_baselen = tmp;
		if ((tmp = strlen(names[i].path)) > min_len)
d1505 1
a1505 1
		best = names[i].path;
d1507 13
d1521 1
a1521 20
		/*
		 * No files found, look for something we can checkout from
		 * RCS/SCCS dirs.  Logic is identical to that above...
		 */
		min_components = min_baselen = min_len = SIZE_MAX;
		for (i = INDEX_FILE; i >= OLD_FILE; i--) {
			if (names[i].path == NULL ||
			    checked_in(names[i].path) == NULL)
				continue;
			if ((tmp = num_components(names[i].path)) > min_components)
				continue;
			min_components = tmp;
			if ((tmp = strlen(basename(names[i].path))) > min_baselen)
				continue;
			min_baselen = tmp;
			if ((tmp = strlen(names[i].path)) > min_len)
				continue;
			min_len = tmp;
			best = names[i].path;
		}
a1529 1

@


1.38
log
@rcsid[] and sccsid[] and copyright[] are essentially unmaintained (and
unmaintainable).  these days, people use source.  these id's do not provide
any benefit, and do hurt the small install media
(the 33,000 line diff is essentially mechanical)
ok with the idea millert, ok dms
@
text
@d1 1
a1 1
/*	$OpenBSD: pch.c,v 1.37 2007/09/02 15:19:33 deraadt Exp $	*/
d507 1
d512 1
@


1.37
log
@use calloc() to avoid malloc(n * m) overflows; checked by djm canacar jsg
@
text
@d1 1
a1 1
/*	$OpenBSD: pch.c,v 1.36 2006/03/11 19:41:30 otto Exp $	*/
a27 4

#ifndef lint
static const char rcsid[] = "$OpenBSD: pch.c,v 1.36 2006/03/11 19:41:30 otto Exp $";
#endif /* not lint */
@


1.36
log
@type police and assorted cleanup. From Lionel Fourquaux; ok ray@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pch.c,v 1.35 2004/08/05 21:47:24 deraadt Exp $	*/
d30 1
a30 1
static const char rcsid[] = "$OpenBSD: pch.c,v 1.35 2004/08/05 21:47:24 deraadt Exp $";
d132 1
a132 1
		p_line = malloc((size_t) hunkmax * sizeof(char *));
d134 1
a134 1
		p_len = malloc((size_t) hunkmax * sizeof(short));
d136 1
a136 1
		p_char = malloc((size_t) hunkmax * sizeof(char));
@


1.35
log
@spacing
@
text
@d1 1
a1 1
/*	$OpenBSD: pch.c,v 1.34 2004/07/09 19:13:46 otto Exp $	*/
d30 1
a30 1
static const char rcsid[] = "$OpenBSD: pch.c,v 1.34 2004/07/09 19:13:46 otto Exp $";
d1370 1
a1370 1
	FILE	*pipefp;
a1371 1
	pipefp = NULL;
@


1.34
log
@Properly detect if a patch already has been applied, even if there
are no eols at eofs involved. Tested by quite some people.

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pch.c,v 1.33 2004/01/28 08:31:07 otto Exp $	*/
d30 1
a30 1
static const char rcsid[] = "$OpenBSD: pch.c,v 1.33 2004/01/28 08:31:07 otto Exp $";
d146 1
a146 1
	char 		**new_p_line;
@


1.33
log
@Fix a segv when patch cannot find a file and the user indicates
to use the file anyway. Problem found by david@@

ok david@@ millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pch.c,v 1.32 2003/10/31 20:20:45 millert Exp $	*/
d30 1
a30 1
static const char rcsid[] = "$OpenBSD: pch.c,v 1.32 2003/10/31 20:20:45 millert Exp $";
d969 6
@


1.32
log
@o fairly major man page reorganization
o add --posix option for strict POSIX conformance
o change filename determination to match GNU patch
Tested by various people, including a full ports build by naddy@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pch.c,v 1.31 2003/09/28 07:55:19 otto Exp $	*/
d30 1
a30 1
static const char rcsid[] = "$OpenBSD: pch.c,v 1.31 2003/09/28 07:55:19 otto Exp $";
a230 1
			free(filearg[0]);
d236 1
@


1.31
log
@realloc(3) cleanup.

ok cloder@@ tedu@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pch.c,v 1.30 2003/08/15 08:00:51 otto Exp $	*/
d30 1
a30 1
static const char rcsid[] = "$OpenBSD: pch.c,v 1.30 2003/08/15 08:00:51 otto Exp $";
d37 2
d80 3
a82 1

d187 2
d228 1
a228 1
			filearg[0] = fetchname(buf, 0, false);
d230 2
a231 1
		if (filearg[0] == NULL) {
d237 1
a237 1
			filearg[0] = fetchname(bestguess, 0, true);
a255 6
	char	*indtmp = NULL;
	char	*oldtmp = NULL;
	char	*newtmp = NULL;
	char	*indname = NULL;
	char	*oldname = NULL;
	char	*newname = NULL;
d257 1
a257 1
	bool	no_filearg = (filearg[0] == NULL);
d259 1
d300 2
a301 1
			oldtmp = savestr(s + 4);
d303 2
a304 1
			newtmp = savestr(s + 4);
d306 3
a308 1
			oldtmp = savestr(s + 4); /* pretend it is the old name */
d310 2
a311 1
			indtmp = savestr(s + 6);
d334 1
a334 1
			if (!atol(s + 3))
d345 1
a345 1
			if (!atol(s + 4))
d348 2
a349 2
			 * if this is a new context diff the character just
			 * before
a350 1
			/* the newline is a '*'. */
d370 18
a387 18
	if (no_filearg) {
		if (indtmp != NULL)
			indname = fetchname(indtmp, strippath, ok_to_create_file);
		if (oldtmp != NULL)
			oldname = fetchname(oldtmp, strippath, ok_to_create_file);
		if (newtmp != NULL)
			newname = fetchname(newtmp, strippath, ok_to_create_file);
		if (indname)
			filearg[0] = savestr(indname);
		else if (oldname && newname) {
			if (strlen(oldname) < strlen(newname))
				filearg[0] = savestr(oldname);
			else
				filearg[0] = savestr(newname);
		} else if (oldname)
			filearg[0] = savestr(oldname);
		else if (newname)
			filearg[0] = savestr(newname);
a391 1

d394 14
a407 23
	else if (indtmp != NULL)
		bestguess = fetchname(indtmp, strippath, true);
	else {
		if (oldtmp != NULL)
			oldname = fetchname(oldtmp, strippath, true);
		if (newtmp != NULL)
			newname = fetchname(newtmp, strippath, true);
		if (oldname && newname) {
			if (strlen(oldname) < strlen(newname))
				bestguess = savestr(oldname);
			else
				bestguess = savestr(newname);
		} else if (oldname)
			bestguess = savestr(oldname);
		else if (newname)
			bestguess = savestr(newname);
	}
	free(indtmp);
	free(oldtmp);
	free(newtmp);
	free(indname);
	free(oldname);
	free(newname);
d1419 124
@


1.30
log
@Add license from patch.c to original source files missing a license.

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pch.c,v 1.29 2003/08/05 18:20:33 deraadt Exp $	*/
d30 1
a30 1
static const char rcsid[] = "$OpenBSD: pch.c,v 1.29 2003/08/05 18:20:33 deraadt Exp $";
d141 6
a146 1
	hunkmax *= 2;
d151 15
a165 3
	p_line = realloc(p_line, hunkmax * sizeof(char *));
	p_len = realloc(p_len, hunkmax * sizeof(short));
	p_char = realloc(p_char, hunkmax * sizeof(char));
d167 2
a168 1
	if (p_line != NULL && p_len != NULL && p_char != NULL)
d170 2
@


1.29
log
@spacing
@
text
@d1 27
a27 1
/*	$OpenBSD: pch.c,v 1.28 2003/08/01 20:30:48 otto Exp $	*/
d30 1
a30 1
static const char rcsid[] = "$OpenBSD: pch.c,v 1.28 2003/08/01 20:30:48 otto Exp $";
@


1.28
log
@- use stdbool.h instead of roll-your-own booleans
- fix some -Wall warnings
- fix asserts: in some cases remove them, in other cases they have
become Internal errors or detection of malformed patch files.
- fix some free() related code

ok millert@@ tedu@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pch.c,v 1.27 2003/07/29 20:10:17 millert Exp $	*/
d4 1
a4 1
static const char rcsid[] = "$OpenBSD: pch.c,v 1.27 2003/07/29 20:10:17 millert Exp $";
d502 1
a502 1
				      "buffer size");
d1184 1
a1184 1
		fatal("Malformed patch at line %ld: expected '=' found '%c'\n", 
d1194 2
a1195 2
		fatal("Malformed patch at line %ld: expected '*' found '%c'\n", 
		      p_input_line, p_char[0]);
d1210 2
a1211 2
		      "got %ld\n",
		      p_input_line, p_ptrn_lines + 1, i);
@


1.27
log
@o add pathnames.h
o ignore empty TMPDIR environment variable
o strip any trailing slashes from TMPDIR
otto@@ OK
@
text
@d1 1
a1 1
/*	$OpenBSD: pch.c,v 1.26 2003/07/28 19:15:34 deraadt Exp $	*/
d4 1
a4 1
static const char rcsid[] = "$OpenBSD: pch.c,v 1.26 2003/07/28 19:15:34 deraadt Exp $";
a9 1
#include <assert.h>
d117 2
a118 6
	/*
	 * Note that on most systems, only the p_line array ever gets fresh memory
	 * since p_len can move into p_line's old space, and p_char can move into
	 * p_len's old space.  Not on PDP-11's however.  But it doesn't matter.
	 */
	assert(p_line != NULL && p_len != NULL && p_char != NULL);
d128 2
a129 2
	out_of_mem = TRUE;	/* whatever is null will be allocated again */
	/* from within plan_a(), of all places */
d140 1
a140 1
		return FALSE;
d151 1
a151 1
		return FALSE;
d169 2
a170 2
			skip_rest_of_patch = TRUE;
			return TRUE;
d176 1
a176 1
			filearg[0] = fetchname(buf, 0, FALSE);
d184 3
a186 3
			filearg[0] = fetchname(bestguess, 0, TRUE);
			skip_rest_of_patch = TRUE;
			return TRUE;
d189 1
a189 1
	return TRUE;
d198 4
a201 3
	long	first_command_line = -1, fcl_line;
	bool	last_line_was_command = FALSE, this_is_a_command = FALSE;
	bool	stars_last_line = FALSE, stars_this_line = FALSE;
d212 1
a212 1
	ok_to_create_file = FALSE;
d282 1
a282 1
				ok_to_create_file = TRUE;
d293 1
a293 1
				ok_to_create_file = TRUE;
d344 1
a344 1
		bestguess = fetchname(indtmp, strippath, TRUE);
d347 1
a347 1
			oldname = fetchname(oldtmp, strippath, TRUE);
d349 1
a349 1
			newname = fetchname(newtmp, strippath, TRUE);
d387 2
a388 1
	assert(p_base <= file_pos);
d394 2
a395 1
			assert(ret != NULL);
d427 1
a427 1
		return TRUE;
d432 1
a432 1
	return FALSE;
a461 1
	assert(p_end == -1);
d469 3
a471 3
		ptrn_spaces_eaten = FALSE;
		repl_could_be_missing = TRUE;
		repl_missing = FALSE;
d479 1
a479 1
			return FALSE;
d493 1
a493 1
						repl_missing = TRUE;
d500 3
a502 1
			assert(p_end < hunkmax);
d509 1
a509 1
						repl_missing = TRUE;
d518 1
a518 1
						repl_missing = TRUE;
d528 1
a528 1
					return FALSE;
d576 1
a576 1
									repl_missing = TRUE;
d596 1
a596 1
						return FALSE;
d627 1
a627 1
						repl_could_be_missing = FALSE;
d633 1
a633 1
				repl_could_be_missing = FALSE;
d640 1
a640 1
					repl_missing = TRUE;
d651 1
a651 1
					return FALSE;
d667 1
a667 1
					repl_missing = TRUE;
d673 1
a673 1
					return FALSE;
d686 1
a686 1
					repl_missing = TRUE;
d695 1
a695 1
					return FALSE;
d700 1
a700 1
					repl_missing = TRUE;
d785 4
a788 2
			assert(fillsrc == p_end + 1 || fillsrc == repl_beginning);
			assert(filldst == p_end + 1 || filldst == repl_beginning);
d806 1
a806 1
			return FALSE;
d850 1
a850 1
			return FALSE;
d858 1
a858 1
			return FALSE;
d887 1
a887 1
				return FALSE;
d926 1
a926 1
					return FALSE;
d968 1
a968 1
			return FALSE;
d1004 1
a1004 1
			return FALSE;
d1019 1
a1019 1
				return FALSE;
d1043 1
a1043 1
			return FALSE;
d1058 1
a1058 1
				return FALSE;
d1090 1
a1090 1
	return TRUE;
d1128 1
a1128 1
	bool	blankline = FALSE;
d1144 1
a1144 1
	if (p_line == NULL ||p_len == NULL ||p_char == NULL) {
d1146 1
a1146 2
		if (p_line == NULL) /* XXX */
			free(p_line);
d1148 1
a1148 2
		if (p_len == NULL) /* XXX */
			free(p_len);
d1150 1
a1150 2
		if (p_char == NULL) /* XXX */
			free(p_char);
d1152 1
a1152 1
		return FALSE;	/* not enough memory to swap hunk! */
d1158 1
a1158 1
		blankline = TRUE;
d1183 3
a1185 1
	assert(p_char[0] == '=');
d1193 3
a1195 1
	assert(tp_char[0] == '*');
d1207 6
a1212 1
	assert(i == p_ptrn_lines + 1);
d1217 5
a1221 7
	if (tp_line == NULL) /* XXX */
		free(tp_line);
	if (tp_len == NULL) /* XXX */
		free(tp_len);
	if (tp_char == NULL) /* XXX */
		free(tp_char);
	return TRUE;
d1324 1
d1346 1
a1346 1
			if (!skip_rest_of_patch)
d1351 1
a1351 1
					if (!skip_rest_of_patch)
d1362 1
a1362 1
	if (skip_rest_of_patch)
d1371 1
a1371 1
			toutkeep = TRUE;
@


1.26
log
@minor knf and cleanups; otto ok
@
text
@d1 1
a1 1
/*	$OpenBSD: pch.c,v 1.25 2003/07/28 18:35:36 otto Exp $	*/
d4 1
a4 1
static const char rcsid[] = "$OpenBSD: pch.c,v 1.25 2003/07/28 18:35:36 otto Exp $";
d20 1
d1324 2
a1325 4
		if (verbose)
			snprintf(buf, sizeof buf, "/bin/ed %s", TMPOUTNAME);
		else
			snprintf(buf, sizeof buf, "/bin/ed - %s", TMPOUTNAME);
@


1.25
log
@More cleanup: sprinkled some const, removed ugly EXTERN/INTERN.h,
some rewriting of code to make it more readable and more KNF.

ok millert@@ tedu@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pch.c,v 1.24 2003/07/25 02:12:45 millert Exp $	*/
d4 1
a4 1
static const char rcsid[] = "$OpenBSD: pch.c,v 1.24 2003/07/25 02:12:45 millert Exp $";
d259 1
a259 2
			oldtmp = savestr(s + 4);	/* pretend it is the old
							 * name */
d551 3
a553 2
				p_max = p_ptrn_lines + 6;	/* we need this much at
								 * least */
d745 1
a745 2
			repl_beginning--;	/* this doesn't need to be
						 * fixed */
d763 1
a763 2
			p_bfake = filldst;	/* remember where not to
						 * free() */
d844 1
a844 1
			 p_first + p_ptrn_lines - 1);
d852 1
a852 1
			 p_newfirst + p_repl_lines - 1);
d998 1
a998 1
			 p_first + p_ptrn_lines - 1);
@


1.24
log
@Add POSIX -b option but don't change the default beahvior wrt backups
yet.  The old -b option is now -z (matches GNU patch).
@
text
@d1 1
a1 1
/*	$OpenBSD: pch.c,v 1.23 2003/07/22 17:52:20 deraadt Exp $	*/
d4 1
a4 1
static const char rcsid[] = "$OpenBSD: pch.c,v 1.23 2003/07/22 17:52:20 deraadt Exp $";
d12 1
a16 1
#include "EXTERN.h"
a18 1
#include "INTERN.h"
d32 1
a32 1
static char	**p_line = NULL;	/* the text of the hunk */
d34 1
a34 1
static char	*p_char = NULL;/* +, -, and ! */
d44 2
d49 2
a50 2
static void	next_intuit_at(long, long);
static void	skip_to(long, long);
d53 1
d60 4
a63 4
	p_first = NULL;
	p_newfirst = NULL;
	p_ptrn_lines = NULL;
	p_repl_lines = NULL;
d65 1
a65 1
	p_max = NULL;
d73 1
a73 1
open_patch_file(char *filename)
d75 3
a77 1
	if (filename == NULL || !*filename || strEQ(filename, "-")) {
d122 1
a122 1
	assert(p_line != NULL &&p_len != NULL &&p_char != NULL);
d128 1
a128 1
	if (p_line != NULL &&p_len != NULL &&p_char != NULL)
d178 1
a178 2
			if (bestguess)
				free(bestguess);
d270 1
a270 1
			if (!*revision) {
d341 4
a344 4
	if (bestguess) {
		free(bestguess);
		bestguess = NULL;
	}
d377 1
a377 1
next_intuit_at(long file_pos, long file_line)
d387 1
a387 1
skip_to(long file_pos, long file_line)
@


1.23
log
@just about nothing
@
text
@d1 1
a1 1
/*	$OpenBSD: pch.c,v 1.22 2003/07/22 17:20:53 millert Exp $	*/
d4 1
a4 1
static const char rcsid[] = "$OpenBSD: pch.c,v 1.22 2003/07/22 17:20:53 millert Exp $";
d1318 4
a1321 2
		unlink(TMPOUTNAME);
		copy_file(filearg[0], TMPOUTNAME);
@


1.22
log
@POSIX defines allowed commands as {a,c,d,i,s} but patch was only
recognizing {a,c,d}.  We need to recognize 's' (substitute) for the
"dot alone on a line" bug fix in diff(1).
@
text
@d1 1
a1 1
/*	$OpenBSD: pch.c,v 1.21 2003/07/22 17:18:49 otto Exp $	*/
d4 1
a4 1
static const char rcsid[] = "$OpenBSD: pch.c,v 1.21 2003/07/22 17:18:49 otto Exp $";
d50 1
a50 1
static char 	*pgets(char *, int, FILE *);
d682 1
a682 1
				  repl_beginning && repl_could_be_missing) {
@


1.21
log
@More cleanup.
ok millert@@ tedu@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pch.c,v 1.20 2003/07/21 14:32:21 deraadt Exp $	*/
d4 1
a4 1
static const char rcsid[] = "$OpenBSD: pch.c,v 1.20 2003/07/21 14:32:21 deraadt Exp $";
a1314 1
	bool	this_line_is_command = FALSE;
d1335 3
a1337 3
		this_line_is_command = (isdigit(*buf) &&
		    (*t == 'd' || *t == 'c' || *t == 'a'));
		if (this_line_is_command) {
@


1.20
log
@fix header
@
text
@d1 1
a1 1
/*	$OpenBSD: pch.c,v 1.19 2003/07/21 14:30:31 deraadt Exp $	*/
d4 1
a4 1
static char rcsid[] = "$OpenBSD: pch.c,v 1.19 2003/07/21 14:30:31 deraadt Exp $";
d7 9
a21 1
extern bool	check_only;
d33 3
a35 3
static char	**p_line = Null(char **);	/* the text of the hunk */
static short	*p_len = Null(short *);	/* length of each line */
static char	*p_char = Nullch;/* +, -, and ! */
d46 6
d58 4
a61 4
	p_first = Nulline;
	p_newfirst = Nulline;
	p_ptrn_lines = Nulline;
	p_repl_lines = Nulline;
d63 1
a63 1
	p_max = Nulline;
d73 1
a73 1
	if (filename == Nullch || !*filename || strEQ(filename, "-")) {
d75 1
a75 1
		if (pfp == Nullfp)
d77 1
a77 1
		while (fgets(buf, sizeof buf, stdin) != Nullch)
d83 1
a83 1
	if (pfp == Nullfp)
d97 6
a102 8
#ifndef lint
	if (p_line == Null(char **))
		p_line = (char **) malloc((size_t) hunkmax * sizeof(char *));
	if (p_len == Null(short *))
		p_len = (short *) malloc((size_t) hunkmax * sizeof(short));
#endif
	if (p_char == Nullch)
		p_char = (char *) malloc((size_t) hunkmax * sizeof(char));
d108 1
a108 1
void
d118 7
a124 7
	assert(p_line != Null(char **) &&p_len != Null(short *) &&p_char != Nullch);
#ifndef lint
	p_line = (char **) realloc((char *) p_line, hunkmax * sizeof(char *));
	p_len = (short *) realloc((char *) p_len, hunkmax * sizeof(short));
	p_char = (char *) realloc((char *) p_char, hunkmax * sizeof(char));
#endif
	if (p_line != Null(char **) &&p_len != Null(short *) &&p_char != Nullch)
d165 1
a165 1
	while (filearg[0] == Nullch) {
d179 1
a179 1
		if (filearg[0] == Nullch) {
d195 1
a195 1
int
d203 6
a208 6
	char	*indtmp = Nullch;
	char	*oldtmp = Nullch;
	char	*newtmp = Nullch;
	char	*indname = Nullch;
	char	*oldname = Nullch;
	char	*newname = Nullch;
d210 1
a210 1
	bool	no_filearg = (filearg[0] == Nullch);
d213 1
a213 1
	fseek(pfp, p_base, 0);
d222 1
a222 1
		if (fgets(buf, sizeof buf, pfp) == Nullch) {
d269 1
a269 1
				revision = Nullch;
d320 1
a320 1
		if (indtmp != Nullch)
d322 1
a322 1
		if (oldtmp != Nullch)
d324 1
a324 1
		if (newtmp != Nullch)
d340 1
a340 1
		bestguess = Nullch;
d342 1
a342 1
	if (filearg[0] != Nullch)
d344 1
a344 1
	else if (indtmp != Nullch)
d347 1
a347 1
		if (oldtmp != Nullch)
d349 1
a349 1
		if (newtmp != Nullch)
d361 6
a366 12
	if (indtmp != Nullch)
		free(indtmp);
	if (oldtmp != Nullch)
		free(oldtmp);
	if (newtmp != Nullch)
		free(newtmp);
	if (indname != Nullch)
		free(indname);
	if (oldname != Nullch)
		free(oldname);
	if (newname != Nullch)
		free(newname);
d373 1
a373 1
void
d383 1
a383 1
void
d390 1
a390 1
		fseek(pfp, p_base, 0);
d394 1
a394 1
			assert(ret != Nullch);
d399 1
a399 1
		fseek(pfp, file_pos, 0);
d477 1
a477 1
		if (ret == Nullch || strnNE(buf, "********", 8)) {
d487 1
a487 1
			if (ret == Nullch) {
d502 1
a502 1
			p_line[p_end] = Nullch;
d720 1
a720 1
			fseek(pfp, repl_backtrack_position, 0);
d801 1
a801 1
		if (ret == Nullch || strnNE(buf, "@@@@ -", 4)) {
d865 1
a865 1
			if (ret == Nullch) {
d963 1
a963 1
		if (ret == Nullch || !isdigit(*buf)) {
d1007 1
a1007 1
			if (ret == Nullch)
d1029 1
a1029 1
			if (ret == Nullch)
d1046 1
a1046 1
			if (ret == Nullch)
d1093 1
a1093 1
char *
d1099 1
a1099 1
	if (p_indent && ret != Nullch) {
d1137 3
a1139 3
	p_line = Null(char **);	/* force set_hunkmax to allocate again */
	p_len = Null(short *);
	p_char = Nullch;
d1141 4
a1144 4
	if (p_line == Null(char **) ||p_len == Null(short *) ||p_char == Nullch) {
#ifndef lint
		if (p_line == Null(char **))
			free((char *) p_line);
d1146 2
a1147 2
		if (p_len == Null(short *))
			free((char *) p_len);
d1149 2
a1150 3
#endif
		if (p_char == Nullch)
			free((char *) p_char);
d1207 7
a1213 8
#ifndef lint
	if (tp_line == Null(char **))
		free((char *) tp_line);
	if (tp_len == Null(short *))
		free((char *) tp_len);
#endif
	if (tp_char == Nullch)
		free((char *) tp_char);
d1329 1
a1329 1
		if (pgets(buf, sizeof buf, pfp) == Nullch) {
d1342 1
a1342 1
				while (pgets(buf, sizeof buf, pfp) != Nullch) {
@


1.19
log
@remove a bit more junk
@
text
@d1 1
a1 1
/* $OpenBSD: pch.c,v 1.18 2003/07/21 14:27:35 deraadt Exp $	 */
d4 1
a4 1
static char rcsid[] = "$OpenBSD: pch.c,v 1.18 2003/07/21 14:27:35 deraadt Exp $";
@


1.18
log
@knf
@
text
@d1 1
a1 1
/* $OpenBSD: pch.c,v 1.17 2003/07/21 14:00:41 deraadt Exp $	 */
d4 1
a4 1
static char rcsid[] = "$OpenBSD: pch.c,v 1.17 2003/07/21 14:00:41 deraadt Exp $";
d85 1
a85 1
		p_line = (char **) malloc((MEM) hunkmax * sizeof(char *));
d87 1
a87 1
		p_len = (short *) malloc((MEM) hunkmax * sizeof(short));
d90 1
a90 1
		p_char = (char *) malloc((MEM) hunkmax * sizeof(char));
d108 3
a110 3
	p_line = (char **) realloc((char *) p_line, (MEM) hunkmax * sizeof(char *));
	p_len = (short *) realloc((char *) p_len, (MEM) hunkmax * sizeof(short));
	p_char = (char *) realloc((char *) p_char, (MEM) hunkmax * sizeof(char));
@


1.17
log
@knf and other cleanup; ok otto
@
text
@d1 1
a1 1
/* $OpenBSD: pch.c,v 1.16 2003/07/18 02:00:09 deraadt Exp $	 */
d4 1
a4 1
static char rcsid[] = "$OpenBSD: pch.c,v 1.16 2003/07/18 02:00:09 deraadt Exp $";
d249 2
a250 1
			for (t = s + 7; isspace(*t); t++);
d252 2
a253 1
			for (t = revision; *t && !isspace(*t); t++);
d532 2
a533 1
					for (; *s && !isdigit(*s); s++);
d962 2
a963 1
		for (s = buf; isdigit(*s); s++);
d974 2
a975 1
		for (; isdigit(*s); s++);
d1330 2
a1331 1
		for (t = buf; isdigit(*t) || *t == ','; t++);
@


1.16
log
@remove junk; ok otto tedu
@
text
@d1 1
a1 1
/*	$OpenBSD: pch.c,v 1.15 2003/07/17 19:16:31 otto Exp $	*/
d4 1
a4 1
static char rcsid[] = "$OpenBSD: pch.c,v 1.15 2003/07/17 19:16:31 otto Exp $";
d13 1
a13 1
extern bool check_only;
d16 21
a36 23
static long p_filesize;			/* size of the patch file */
static LINENUM p_first;			/* 1st line number */
static LINENUM p_newfirst;		/* 1st line number of replacement */
static LINENUM p_ptrn_lines;		/* # lines in pattern */
static LINENUM p_repl_lines;		/* # lines in replacement text */
static LINENUM p_end = -1;		/* last line in hunk */
static LINENUM p_max;			/* max allowed value of p_end */
static LINENUM p_context = 3;		/* # of context lines */
static LINENUM p_input_line = 0;	/* current line # from patch file */
static char **p_line = Null(char**);	/* the text of the hunk */
static short *p_len = Null(short*);	/* length of each line */
static char *p_char = Nullch;		/* +, -, and ! */
static int hunkmax = INITHUNKMAX;	/* size of above arrays to begin with */
static int p_indent;			/* indent to patch */
static LINENUM p_base;			/* where to intuit this time */
static LINENUM p_bline;			/* line # of p_base */
static LINENUM p_start;			/* where intuit found a patch */
static LINENUM p_sline;			/* and the line number for it */
static LINENUM p_hunk_beg;		/* line number of current hunk */
static LINENUM p_efake = -1;		/* end of faked up lines--don't free */
static LINENUM p_bfake = -1;		/* beg of faked up lines */

/* Prepare to look for the next patch in the patch file. */
d38 3
d42 1
a42 1
re_patch()
d44 7
a50 7
    p_first = Nulline;
    p_newfirst = Nulline;
    p_ptrn_lines = Nulline;
    p_repl_lines = Nulline;
    p_end = (LINENUM)-1;
    p_max = Nulline;
    p_indent = 0;
d53 3
a55 2
/* Open the patch file at the beginning of time. */

d57 1
a57 2
open_patch_file(filename)
char *filename;
d59 10
a68 2
    if (filename == Nullch || !*filename || strEQ(filename, "-")) {
	pfp = fopen(TMPPATNAME, "w");
d70 5
a74 13
	    pfatal("can't create %s", TMPPATNAME);
	while (fgets(buf, sizeof buf, stdin) != Nullch)
	    fputs(buf, pfp);
	fclose(pfp);
	filename = TMPPATNAME;
    }
    pfp = fopen(filename, "r");
    if (pfp == Nullfp)
	pfatal("patch file %s not found", filename);
    fstat(fileno(pfp), &filestat);
    p_filesize = filestat.st_size;
    next_intuit_at(0L,1L);			/* start at the beginning */
    set_hunkmax();
d77 3
a79 2
/* Make sure our dynamically realloced tables are malloced to begin with. */

d81 1
a81 1
set_hunkmax()
d84 4
a87 4
    if (p_line == Null(char**))
	p_line = (char**) malloc((MEM)hunkmax * sizeof(char *));
    if (p_len == Null(short*))
	p_len  = (short*) malloc((MEM)hunkmax * sizeof(short));
d89 2
a90 2
    if (p_char == Nullch)
	p_char = (char*)  malloc((MEM)hunkmax * sizeof(char));
d93 3
a95 2
/* Enlarge the arrays containing the current hunk of patch. */

d97 1
a97 1
grow_hunkmax()
d99 8
a106 7
    hunkmax *= 2;
    /*
     * Note that on most systems, only the p_line array ever gets fresh memory
     * since p_len can move into p_line's old space, and p_char can move into
     * p_len's old space.  Not on PDP-11's however.  But it doesn't matter.
     */
    assert(p_line != Null(char**) && p_len != Null(short*) && p_char != Nullch);
d108 3
a110 3
    p_line = (char**) realloc((char*)p_line, (MEM)hunkmax * sizeof(char *));
    p_len  = (short*) realloc((char*)p_len,  (MEM)hunkmax * sizeof(short));
    p_char = (char*)  realloc((char*)p_char, (MEM)hunkmax * sizeof(char));
d112 6
a117 6
    if (p_line != Null(char**) && p_len != Null(short*) && p_char != Nullch)
	return;
    if (!using_plan_a)
	fatal("out of memory\n");
    out_of_mem = TRUE;		/* whatever is null will be allocated again */
				/* from within plan_a(), of all places */
d123 1
a123 1
there_is_another_patch()
d125 5
a129 1
    if (p_base != 0L && p_base >= p_filesize) {
d131 9
a139 10
	    say("done\n");
	return FALSE;
    }
    if (verbose)
	say("Hmm...");
    diff_type = intuit_diff_type();
    if (!diff_type) {
	if (p_base != 0L) {
	    if (verbose)
		say("  Ignoring the trailing garbage.\ndone\n");
d141 36
a176 39
	else
	    say("  I can't seem to find a patch in there anywhere.\n");
	return FALSE;
    }
    if (verbose)
	say("  %sooks like %s to me...\n",
	    (p_base == 0L ? "L" : "The next patch l"),
	    diff_type == UNI_DIFF ? "a unified diff" :
	    diff_type == CONTEXT_DIFF ? "a context diff" :
	    diff_type == NEW_CONTEXT_DIFF ? "a new-style context diff" :
	    diff_type == NORMAL_DIFF ? "a normal diff" :
	    "an ed script" );
    if (p_indent && verbose)
	say("(Patch is indented %d space%s.)\n", p_indent, p_indent==1?"":"s");
    skip_to(p_start,p_sline);
    while (filearg[0] == Nullch) {
	if (force || batch) {
	    say("No file to patch.  Skipping...\n");
	    filearg[0] = savestr(bestguess);
	    skip_rest_of_patch = TRUE;
	    return TRUE;
	}
	ask("File to patch: ");
	if (*buf != '\n') {
	    if (bestguess)
		free(bestguess);
	    bestguess = savestr(buf);
	    filearg[0] = fetchname(buf, 0, FALSE);
	}
	if (filearg[0] == Nullch) {
	    ask("No file found--skip this patch? [n] ");
	    if (*buf != 'y') {
		continue;
	    }
	    if (verbose)
		say("Skipping patch...\n");
	    filearg[0] = fetchname(bestguess, 0, TRUE);
	    skip_rest_of_patch = TRUE;
	    return TRUE;
d178 1
a178 2
    }
    return TRUE;
d184 1
a184 1
intuit_diff_type()
d186 161
a346 122
    long this_line = 0;
    long previous_line;
    long first_command_line = -1;
    long fcl_line;
    bool last_line_was_command = FALSE;
    bool this_is_a_command = FALSE;
    bool stars_last_line = FALSE;
    bool stars_this_line = FALSE;
    int indent;
    char *s;
    char *t;
    char *indtmp = Nullch;
    char *oldtmp = Nullch;
    char *newtmp = Nullch;
    char *indname = Nullch;
    char *oldname = Nullch;
    char *newname = Nullch;
    int retval;
    bool no_filearg = (filearg[0] == Nullch);

    ok_to_create_file = FALSE;
    fseek(pfp, p_base, 0);
    p_input_line = p_bline - 1;
    for (;;) {
	previous_line = this_line;
	last_line_was_command = this_is_a_command;
	stars_last_line = stars_this_line;
	this_line = ftell(pfp);
	indent = 0;
	p_input_line++;
	if (fgets(buf, sizeof buf, pfp) == Nullch) {
	    if (first_command_line >= 0L) {
					/* nothing but deletes!? */
		p_start = first_command_line;
		p_sline = fcl_line;
		retval = ED_DIFF;
		goto scan_exit;
	    }
	    else {
		p_start = this_line;
		p_sline = p_input_line;
		retval = 0;
		goto scan_exit;
	    }
	}
	for (s = buf; *s == ' ' || *s == '\t' || *s == 'X'; s++) {
	    if (*s == '\t')
		indent += 8 - (indent % 8);
	    else
		indent++;
	}
	for (t=s; isdigit(*t) || *t == ','; t++) ;
	this_is_a_command = (isdigit(*s) &&
	  (*t == 'd' || *t == 'c' || *t == 'a') );
	if (first_command_line < 0L && this_is_a_command) {
	    first_command_line = this_line;
	    fcl_line = p_input_line;
	    p_indent = indent;		/* assume this for now */
	}
	if (!stars_last_line && strnEQ(s, "*** ", 4))
	    oldtmp = savestr(s+4);
	else if (strnEQ(s, "--- ", 4))
	    newtmp = savestr(s+4);
	else if (strnEQ(s, "+++ ", 4))
	    oldtmp = savestr(s+4);	/* pretend it is the old name */
	else if (strnEQ(s, "Index:", 6))
	    indtmp = savestr(s+6);
	else if (strnEQ(s, "Prereq:", 7)) {
	    for (t=s+7; isspace(*t); t++) ;
	    revision = savestr(t);
	    for (t=revision; *t && !isspace(*t); t++) ;
	    *t = '\0';
	    if (!*revision) {
		free(revision);
		revision = Nullch;
	    }
	}
	if ((!diff_type || diff_type == ED_DIFF) &&
	  first_command_line >= 0L &&
	  strEQ(s, ".\n") ) {
	    p_indent = indent;
	    p_start = first_command_line;
	    p_sline = fcl_line;
	    retval = ED_DIFF;
	    goto scan_exit;
	}
	if ((!diff_type || diff_type == UNI_DIFF) && strnEQ(s, "@@@@ -", 4)) {
	    if (!atol(s+3))
		ok_to_create_file = TRUE;
	    p_indent = indent;
	    p_start = this_line;
	    p_sline = p_input_line;
	    retval = UNI_DIFF;
	    goto scan_exit;
	}
	stars_this_line = strnEQ(s, "********", 8);
	if ((!diff_type || diff_type == CONTEXT_DIFF) && stars_last_line &&
		 strnEQ(s, "*** ", 4)) {
	    if (!atol(s+4))
		ok_to_create_file = TRUE;
	    /* if this is a new context diff the character just before */
	    /* the newline is a '*'. */
	    while (*s != '\n')
		s++;
	    p_indent = indent;
	    p_start = previous_line;
	    p_sline = p_input_line - 1;
	    retval = (*(s-1) == '*' ? NEW_CONTEXT_DIFF : CONTEXT_DIFF);
	    goto scan_exit;
	}
	if ((!diff_type || diff_type == NORMAL_DIFF) &&
	  last_line_was_command &&
	  (strnEQ(s, "< ", 2) || strnEQ(s, "> ", 2)) ) {
	    p_start = previous_line;
	    p_sline = p_input_line - 1;
	    p_indent = indent;
	    retval = NORMAL_DIFF;
	    goto scan_exit;
	}
    }
  scan_exit:
    if (no_filearg) {
d348 1
a348 1
	    indname = fetchname(indtmp, strippath, ok_to_create_file);
d350 1
a350 1
	    oldname = fetchname(oldtmp, strippath, ok_to_create_file);
d352 8
a359 51
	    newname = fetchname(newtmp, strippath, ok_to_create_file);
	if (indname)
	    filearg[0] = savestr(indname);
	else if (oldname && newname) {
	    if (strlen(oldname) < strlen(newname))
		filearg[0] = savestr(oldname);
	    else
		filearg[0] = savestr(newname);
	}
	else if (oldname)
	    filearg[0] = savestr(oldname);
	else if (newname)
	    filearg[0] = savestr(newname);
    }
    if (bestguess) {
	free(bestguess);
	bestguess = Nullch;
    }
    if (filearg[0] != Nullch)
	bestguess = savestr(filearg[0]);
    else if (indtmp != Nullch)
	bestguess = fetchname(indtmp, strippath, TRUE);
    else {
	if (oldtmp != Nullch)
	    oldname = fetchname(oldtmp, strippath, TRUE);
	if (newtmp != Nullch)
	    newname = fetchname(newtmp, strippath, TRUE);
	if (oldname && newname) {
	    if (strlen(oldname) < strlen(newname))
		bestguess = savestr(oldname);
	    else
		bestguess = savestr(newname);
	}
	else if (oldname)
	    bestguess = savestr(oldname);
	else if (newname)
	    bestguess = savestr(newname);
    }
    if (indtmp != Nullch)
	free(indtmp);
    if (oldtmp != Nullch)
	free(oldtmp);
    if (newtmp != Nullch)
	free(newtmp);
    if (indname != Nullch)
	free(indname);
    if (oldname != Nullch)
	free(oldname);
    if (newname != Nullch)
	free(newname);
    return retval;
d362 3
a364 2
/* Remember where this patch ends so we know where to start up again. */

d366 1
a366 3
next_intuit_at(file_pos,file_line)
long file_pos;
long file_line;
d368 2
a369 2
    p_base = file_pos;
    p_bline = file_line;
d372 3
a374 2
/* Basically a verbose fseek() to the actual diff listing. */

d376 1
a376 3
skip_to(file_pos,file_line)
long file_pos;
long file_line;
d378 1
a378 1
    char *ret;
d380 13
a392 14
    assert(p_base <= file_pos);
    if (verbose && p_base < file_pos) {
	fseek(pfp, p_base, 0);
	say("The text leading up to this was:\n--------------------------\n");
	while (ftell(pfp) < file_pos) {
	    ret = fgets(buf, sizeof buf, pfp);
	    assert(ret != Nullch);
	    say("|%s", buf);
	}
	say("--------------------------\n");
    }
    else
	fseek(pfp, file_pos, 0);
    p_input_line = file_line - 1;
d399 2
a400 2
    fatal("malformed patch at line %ld: %s", p_input_line, buf);
		/* about as informative as "Syntax error" in C */
d410 1
a410 1
	int c;
a419 1

d426 3
a428 2
/* True if there is more of the current diff listing to process. */

d430 1
a430 1
another_hunk()
d432 342
a773 63
    char *s;
    char *ret;
    int context = 0;

    while (p_end >= 0) {
	if (p_end == p_efake)
	    p_end = p_bfake;		/* don't free twice */
	else
	    free(p_line[p_end]);
	p_end--;
    }
    assert(p_end == -1);
    p_efake = -1;

    p_max = hunkmax;			/* gets reduced when --- found */
    if (diff_type == CONTEXT_DIFF || diff_type == NEW_CONTEXT_DIFF) {
	long line_beginning = ftell(pfp);
					/* file pos of the current line */
	LINENUM repl_beginning = 0;	/* index of --- line */
	LINENUM fillcnt = 0;	/* #lines of missing ptrn or repl */
	LINENUM fillsrc;		/* index of first line to copy */
	LINENUM filldst;		/* index of first missing line */
	bool ptrn_spaces_eaten = FALSE;	/* ptrn was slightly misformed */
	bool repl_could_be_missing = TRUE;
					/* no + or ! lines in this hunk */
	bool repl_missing = FALSE;	/* we are now backtracking */
	long repl_backtrack_position = 0;
					/* file pos of first repl line */
	LINENUM repl_patch_line;	/* input line number for same */
	LINENUM ptrn_copiable = 0;
					/* # of copiable lines in ptrn */

	ret = pgets(buf, sizeof buf, pfp);
	p_input_line++;
	if (ret == Nullch || strnNE(buf, "********", 8)) {
	    next_intuit_at(line_beginning,p_input_line);
	    return FALSE;
	}
	p_context = 100;
	p_hunk_beg = p_input_line + 1;
	while (p_end < p_max) {
	    line_beginning = ftell(pfp);
	    ret = pgets(buf, sizeof buf, pfp);
	    p_input_line++;
	    if (ret == Nullch) {
		if (p_max - p_end < 4) {
		    /* assume blank lines got chopped */
		    strlcpy(buf, "  \n", sizeof buf);
		} else {
		    if (repl_beginning && repl_could_be_missing) {
			repl_missing = TRUE;
			goto hunk_done;
		    }
		    fatal("unexpected end of file in patch\n");
		}
	    }
	    p_end++;
	    assert(p_end < hunkmax);
	    p_char[p_end] = *buf;
#ifdef zilog
	    p_line[(short)p_end] = Nullch;
#else
	    p_line[p_end] = Nullch;
d775 2
a776 17
	    switch (*buf) {
	    case '*':
		if (strnEQ(buf, "********", 8)) {
		    if (repl_beginning && repl_could_be_missing) {
			repl_missing = TRUE;
			goto hunk_done;
		    }
		    else
			fatal("unexpected end of hunk at line %ld\n",
			    p_input_line);
		}
		if (p_end != 0) {
		    if (repl_beginning && repl_could_be_missing) {
			repl_missing = TRUE;
			goto hunk_done;
		    }
		    fatal("unexpected *** at line %ld: %s", p_input_line, buf);
d778 17
a794 5
		context = 0;
		p_line[p_end] = savestr(buf);
		if (out_of_mem) {
		    p_end--;
		    return FALSE;
d796 1
a796 1
		for (s=buf; *s && !isdigit(*s); s++) ;
d798 1
a798 3
		    malformed ();
		if (strnEQ(s,"0,0",3))
		    memmove(s, s+2, strlen(s+2)+1);
d800 15
a814 1
		while (isdigit(*s)) s++;
d816 31
a846 10
		    for (; *s && !isdigit(*s); s++) ;
		    if (!*s)
			malformed ();
		    p_ptrn_lines = ((LINENUM)atol(s)) - p_first + 1;
		}
		else if (p_first)
		    p_ptrn_lines = 1;
		else {
		    p_ptrn_lines = 0;
		    p_first = 1;
d848 90
a937 17
		p_max = p_ptrn_lines + 6;	/* we need this much at least */
		while (p_max >= hunkmax)
		    grow_hunkmax();
		p_max = hunkmax;
		break;
	    case '-':
		if (buf[1] == '-') {
		    if (repl_beginning ||
			(p_end != p_ptrn_lines + 1 + (p_char[p_end-1] == '\n')))
		    {
			if (p_end == 1) {
			    /* `old' lines were omitted - set up to fill */
			    /* them in from 'new' context lines. */
			    p_end = p_ptrn_lines + 1;
			    fillsrc = p_end + 1;
			    filldst = 1;
			    fillcnt = p_ptrn_lines;
d939 4
a942 18
			else {
			    if (repl_beginning) {
				if (repl_could_be_missing){
				    repl_missing = TRUE;
				    goto hunk_done;
				}
				fatal(
"duplicate \"---\" at line %ld--check line numbers at line %ld\n",
				    p_input_line, p_hunk_beg + repl_beginning);
			    }
			    else {
				fatal(
"%s \"---\" at line %ld--check line numbers at line %ld\n",
				    (p_end <= p_ptrn_lines
					? "Premature"
					: "Overdue" ),
				    p_input_line, p_hunk_beg);
			    }
d944 12
a955 7
		    }
		    repl_beginning = p_end;
		    repl_backtrack_position = ftell(pfp);
		    repl_patch_line = p_input_line;
		    p_line[p_end] = savestr(buf);
		    if (out_of_mem) {
			p_end--;
d957 22
a978 21
		    }
		    p_char[p_end] = '=';
		    for (s=buf; *s && !isdigit(*s); s++) ;
		    if (!*s)
			malformed ();
		    p_newfirst = (LINENUM) atol(s);
		    while (isdigit(*s)) s++;
		    if (*s == ',') {
			for (; *s && !isdigit(*s); s++) ;
			if (!*s)
			    malformed ();
			p_repl_lines = ((LINENUM)atol(s)) - p_newfirst + 1;
		    }
		    else if (p_newfirst)
			p_repl_lines = 1;
		    else {
			p_repl_lines = 0;
			p_newfirst = 1;
		    }
		    p_max = p_repl_lines + p_end;
		    if (p_max > MAXHUNKSIZE)
d980 2
a981 2
			      p_max, p_input_line, buf);
		    while (p_max >= hunkmax)
d983 5
a987 22
		    if (p_repl_lines != ptrn_copiable
		     && (p_context != 0 || p_repl_lines != 1))
			repl_could_be_missing = FALSE;
		    break;
		}
		goto change_line;
	    case '+':  case '!':
		repl_could_be_missing = FALSE;
	      change_line:
		if (buf[1] == '\n' && canonicalize)
		    strlcpy(buf+1," \n", sizeof buf -1);
		if (!isspace(buf[1]) && buf[1] != '>' && buf[1] != '<' &&
		  repl_beginning && repl_could_be_missing) {
		    repl_missing = TRUE;
		    goto hunk_done;
		}
		if (context >= 0) {
		    if (context < p_context)
			p_context = context;
		    context = -1000;
		}
		p_line[p_end] = savestr(buf+2);
d989 2
a990 2
		    p_end--;
		    return FALSE;
d992 14
a1005 6
		if (p_end == p_ptrn_lines) {
			if (remove_special_line()) {
				int len;

				len = strlen(p_line[p_end]) - 1;
				(p_line[p_end])[len] = 0;
d1007 2
d1010 4
a1013 6
		break;
	    case '\t': case '\n':	/* assume the 2 spaces got eaten */
		if (repl_beginning && repl_could_be_missing &&
		  (!ptrn_spaces_eaten || diff_type == NEW_CONTEXT_DIFF) ) {
		    repl_missing = TRUE;
		    goto hunk_done;
d1015 9
a1023 4
		p_line[p_end] = savestr(buf);
		if (out_of_mem) {
		    p_end--;
		    return FALSE;
d1025 2
a1026 18
		if (p_end != p_ptrn_lines + 1) {
		    ptrn_spaces_eaten |= (repl_beginning != 0);
		    context++;
		    if (!repl_beginning)
			ptrn_copiable++;
		    p_char[p_end] = ' ';
		}
		break;
	    case ' ':
		if (!isspace(buf[1]) &&
		  repl_beginning && repl_could_be_missing) {
		    repl_missing = TRUE;
		    goto hunk_done;
		}
		context++;
		if (!repl_beginning)
		    ptrn_copiable++;
		p_line[p_end] = savestr(buf+2);
d1028 2
a1029 176
		    p_end--;
		    return FALSE;
		}
		break;
	    default:
		if (repl_beginning && repl_could_be_missing) {
		    repl_missing = TRUE;
		    goto hunk_done;
		}
		malformed ();
	    }
	    /* set up p_len for strncmp() so we don't have to */
	    /* assume null termination */
	    if (p_line[p_end])
		p_len[p_end] = strlen(p_line[p_end]);
	    else
		p_len[p_end] = 0;
	}

    hunk_done:
	if (p_end >=0 && !repl_beginning)
	    fatal("no --- found in patch at line %ld\n", pch_hunk_beg());

	if (repl_missing) {

	    /* reset state back to just after --- */
	    p_input_line = repl_patch_line;
	    for (p_end--; p_end > repl_beginning; p_end--)
		free(p_line[p_end]);
	    fseek(pfp, repl_backtrack_position, 0);

	    /* redundant 'new' context lines were omitted - set */
	    /* up to fill them in from the old file context */
	    if (!p_context && p_repl_lines == 1) {
		p_repl_lines = 0;
		p_max--;
	    }
	    fillsrc = 1;
	    filldst = repl_beginning+1;
	    fillcnt = p_repl_lines;
	    p_end = p_max;
	}
	else if (!p_context && fillcnt == 1) {
	    /* the first hunk was a null hunk with no context */
	    /* and we were expecting one line -- fix it up. */
	    while (filldst < p_end) {
		p_line[filldst] = p_line[filldst+1];
		p_char[filldst] = p_char[filldst+1];
		p_len[filldst] = p_len[filldst+1];
		filldst++;
	    }
#if 0
	    repl_beginning--;		/* this doesn't need to be fixed */
#endif
	    p_end--;
	    p_first++;			/* do append rather than insert */
	    fillcnt = 0;
	    p_ptrn_lines = 0;
	}

	if (diff_type == CONTEXT_DIFF &&
	  (fillcnt || (p_first > 1 && ptrn_copiable > 2*p_context)) ) {
	    if (verbose)
		say("%s\n%s\n%s\n",
"(Fascinating--this is really a new-style context diff but without",
"the telltale extra asterisks on the *** line that usually indicate",
"the new style...)");
	    diff_type = NEW_CONTEXT_DIFF;
	}

	/* if there were omitted context lines, fill them in now */
	if (fillcnt) {
	    p_bfake = filldst;		/* remember where not to free() */
	    p_efake = filldst + fillcnt - 1;
	    while (fillcnt-- > 0) {
		while (fillsrc <= p_end && p_char[fillsrc] != ' ')
		    fillsrc++;
		if (fillsrc > p_end)
		    fatal("replacement text or line numbers mangled in hunk at line %ld\n",
			p_hunk_beg);
		p_line[filldst] = p_line[fillsrc];
		p_char[filldst] = p_char[fillsrc];
		p_len[filldst] = p_len[fillsrc];
		fillsrc++; filldst++;
	    }
	    while (fillsrc <= p_end && fillsrc != repl_beginning &&
	      p_char[fillsrc] != ' ')
		fillsrc++;
#ifdef DEBUGGING
	    if (debug & 64)
		printf("fillsrc %ld, filldst %ld, rb %ld, e+1 %ld\n",
		    fillsrc,filldst,repl_beginning,p_end+1);
#endif
	    assert(fillsrc==p_end+1 || fillsrc==repl_beginning);
	    assert(filldst==p_end+1 || filldst==repl_beginning);
	}
	if (p_line[p_end] != NULL) {
		if (remove_special_line()) {
			p_len[p_end] -= 1;
			(p_line[p_end])[p_len[p_end]] = 0;
		}
	}
    }
    else if (diff_type == UNI_DIFF) {
	long line_beginning = ftell(pfp);
					/* file pos of the current line */
	LINENUM fillsrc;		/* index of old lines */
	LINENUM filldst;		/* index of new lines */
	char ch;

	ret = pgets(buf, sizeof buf, pfp);
	p_input_line++;
	if (ret == Nullch || strnNE(buf, "@@@@ -", 4)) {
	    next_intuit_at(line_beginning,p_input_line);
	    return FALSE;
	}
	s = buf+4;
	if (!*s)
	    malformed ();
	p_first = (LINENUM) atol(s);
	while (isdigit(*s)) s++;
	if (*s == ',') {
	    p_ptrn_lines = (LINENUM) atol(++s);
	    while (isdigit(*s)) s++;
	} else
	    p_ptrn_lines = 1;
	if (*s == ' ') s++;
	if (*s != '+' || !*++s)
	    malformed ();
	p_newfirst = (LINENUM) atol(s);
	while (isdigit(*s)) s++;
	if (*s == ',') {
	    p_repl_lines = (LINENUM) atol(++s);
	    while (isdigit(*s)) s++;
	} else
	    p_repl_lines = 1;
	if (*s == ' ') s++;
	if (*s != '@@')
	    malformed ();
	if (!p_ptrn_lines)
	    p_first++;			/* do append rather than insert */
	p_max = p_ptrn_lines + p_repl_lines + 1;
	while (p_max >= hunkmax)
	    grow_hunkmax();
	fillsrc = 1;
	filldst = fillsrc + p_ptrn_lines;
	p_end = filldst + p_repl_lines;
	snprintf(buf, sizeof buf, "*** %ld,%ld ****\n", p_first,
	    p_first + p_ptrn_lines - 1);
	p_line[0] = savestr(buf);
	if (out_of_mem) {
	    p_end = -1;
	    return FALSE;
	}
	p_char[0] = '*';
        snprintf(buf, sizeof buf, "--- %ld,%ld ----\n", p_newfirst,
	    p_newfirst + p_repl_lines - 1);
	p_line[filldst] = savestr(buf);
	if (out_of_mem) {
	    p_end = 0;
	    return FALSE;
	}
	p_char[filldst++] = '=';
	p_context = 100;
	context = 0;
	p_hunk_beg = p_input_line + 1;
	while (fillsrc <= p_ptrn_lines || filldst <= p_end) {
	    line_beginning = ftell(pfp);
	    ret = pgets(buf, sizeof buf, pfp);
	    p_input_line++;
	    if (ret == Nullch) {
		if (p_max - filldst < 3) {
		    /* assume blank lines got chopped */
		    strlcpy(buf, " \n", sizeof buf);
		} else {
		    fatal("unexpected end of file in patch\n");
d1031 14
a1044 29
	    }
	    if (*buf == '\t' || *buf == '\n') {
		ch = ' ';		/* assume the space got eaten */
		s = savestr(buf);
	    }
	    else {
		ch = *buf;
		s = savestr(buf+1);
	    }
	    if (out_of_mem) {
		while (--filldst > p_ptrn_lines)
		    free(p_line[filldst]);
		p_end = fillsrc-1;
		return FALSE;
	    }
	    switch (ch) {
	    case '-':
		if (fillsrc > p_ptrn_lines) {
		    free(s);
		    p_end = filldst-1;
		    malformed ();
		}
		p_char[fillsrc] = ch;
		p_line[fillsrc] = s;
		p_len[fillsrc++] = strlen(s);
		if (fillsrc > p_ptrn_lines) {
			if (remove_special_line()) {
				p_len[fillsrc - 1] -= 1;
				s[p_len[fillsrc - 1]] = 0;
d1046 2
d1049 4
a1052 40
		break;
	    case '=':
		ch = ' ';
		/* FALL THROUGH */
	    case ' ':
		if (fillsrc > p_ptrn_lines) {
		    free(s);
		    while (--filldst > p_ptrn_lines)
			free(p_line[filldst]);
		    p_end = fillsrc-1;
		    malformed ();
		}
		context++;
		p_char[fillsrc] = ch;
		p_line[fillsrc] = s;
		p_len[fillsrc++] = strlen(s);
		s = savestr(s);
		if (out_of_mem) {
		    while (--filldst > p_ptrn_lines)
			free(p_line[filldst]);
		    p_end = fillsrc-1;
		    return FALSE;
		}
		/* FALL THROUGH */
	    case '+':
		if (filldst > p_end) {
		    free(s);
		    while (--filldst > p_ptrn_lines)
			free(p_line[filldst]);
		    p_end = fillsrc-1;
		    malformed ();
		}
		p_char[filldst] = ch;
		p_line[filldst] = s;
		p_len[filldst++] = strlen(s);
		if (fillsrc > p_ptrn_lines) {
			if (remove_special_line()) {
				p_len[filldst - 1] -= 1;
				s[p_len[filldst - 1]] = 0;
			}
a1053 58
		break;
	    default:
		p_end = filldst;
		malformed ();
	    }
	    if (ch != ' ' && context > 0) {
		if (context < p_context)
		    p_context = context;
		context = -1000;
	    }
	}/* while */
    }
    else {				/* normal diff--fake it up */
	char hunk_type;
	int i;
	LINENUM min, max;
	long line_beginning = ftell(pfp);

	p_context = 0;
	ret = pgets(buf, sizeof buf, pfp);
	p_input_line++;
	if (ret == Nullch || !isdigit(*buf)) {
	    next_intuit_at(line_beginning,p_input_line);
	    return FALSE;
	}
	p_first = (LINENUM)atol(buf);
	for (s=buf; isdigit(*s); s++) ;
	if (*s == ',') {
	    p_ptrn_lines = (LINENUM)atol(++s) - p_first + 1;
	    while (isdigit(*s)) s++;
	}
	else
	    p_ptrn_lines = (*s != 'a');
	hunk_type = *s;
	if (hunk_type == 'a')
	    p_first++;			/* do append rather than insert */
	min = (LINENUM)atol(++s);
	for (; isdigit(*s); s++) ;
	if (*s == ',')
	    max = (LINENUM)atol(++s);
	else
	    max = min;
	if (hunk_type == 'd')
	    min++;
	p_end = p_ptrn_lines + 1 + max - min + 1;
	if (p_end > MAXHUNKSIZE)
	    fatal("hunk too large (%ld lines) at line %ld: %s",
		  p_end, p_input_line, buf);
	while (p_end >= hunkmax)
	    grow_hunkmax();
	p_newfirst = min;
	p_repl_lines = max - min + 1;
	snprintf(buf, sizeof buf, "*** %ld,%ld\n", p_first,
	    p_first + p_ptrn_lines - 1);
	p_line[0] = savestr(buf);
	if (out_of_mem) {
	    p_end = -1;
	    return FALSE;
d1055 3
a1057 64
	p_char[0] = '*';
	for (i=1; i<=p_ptrn_lines; i++) {
	    ret = pgets(buf, sizeof buf, pfp);
	    p_input_line++;
	    if (ret == Nullch)
		fatal("unexpected end of file in patch at line %ld\n",
		  p_input_line);
	    if (*buf != '<')
		fatal("< expected at line %ld of patch\n", p_input_line);
	    p_line[i] = savestr(buf+2);
	    if (out_of_mem) {
		p_end = i-1;
		return FALSE;
	    }
	    p_len[i] = strlen(p_line[i]);
	    p_char[i] = '-';
	}

	if (remove_special_line()) {
		p_len[i - 1] -= 1;
		(p_line[i - 1])[p_len[i - 1]] = 0;
	}

	if (hunk_type == 'c') {
	    ret = pgets(buf, sizeof buf, pfp);
	    p_input_line++;
	    if (ret == Nullch)
		fatal("unexpected end of file in patch at line %ld\n",
		    p_input_line);
	    if (*buf != '-')
		fatal("--- expected at line %ld of patch\n", p_input_line);
	}
	snprintf(buf, sizeof(buf), "--- %ld,%ld\n", min, max);
	p_line[i] = savestr(buf);
	if (out_of_mem) {
	    p_end = i-1;
	    return FALSE;
	}
	p_char[i] = '=';
	for (i++; i<=p_end; i++) {
	    ret = pgets(buf, sizeof buf, pfp);
	    p_input_line++;
	    if (ret == Nullch)
		fatal("unexpected end of file in patch at line %ld\n",
		    p_input_line);
	    if (*buf != '>')
		fatal("> expected at line %ld of patch\n", p_input_line);
	    p_line[i] = savestr(buf+2);
	    if (out_of_mem) {
		p_end = i-1;
		return FALSE;
	    }
	    p_len[i] = strlen(p_line[i]);
	    p_char[i] = '+';
	}

	if (remove_special_line()) {
		p_len[i - 1] -= 1;
		(p_line[i - 1])[p_len[i - 1]] = 0;
	}
    }
    if (reverse)			/* backwards patch? */
	if (!pch_swap())
	    say("Not enough memory to swap next hunk!\n");
d1059 13
a1071 11
    if (debug & 2) {
	int i;
	char special;

	for (i=0; i <= p_end; i++) {
	    if (i == p_ptrn_lines)
		special = '^';
	    else
		special = ' ';
	    fprintf(stderr, "%3d %c %c %s", i, p_char[i], special, p_line[i]);
	    fflush(stderr);
a1072 1
    }
d1074 3
a1076 3
    if (p_end+1 < hunkmax)	/* paranoia reigns supreme... */
	p_char[p_end+1] = '^';  /* add a stopper for apply_hunk */
    return TRUE;
d1079 8
a1086 1
/* Input a line from the patch file, worrying about indentation. */
d1088 13
a1100 22
char *
pgets(bf,sz,fp)
char *bf;
int sz;
FILE *fp;
{
    char *ret = fgets(bf, sz, fp);
    char *s;
    int indent = 0;

    if (p_indent && ret != Nullch) {
	for (s=buf;
	  indent < p_indent && (*s == ' ' || *s == '\t' || *s == 'X'); s++) {
	    if (*s == '\t')
		indent += 8 - (indent % 7);
	    else
		indent++;
	}
	if (buf != s && strlcpy(buf, s, sizeof(buf)) >= sizeof(buf))
	    fatal("buffer too small in pgets()\n");
    }
    return ret;
d1103 3
a1105 2
/* Reverse the old and new portions of the current hunk. */

d1107 1
a1107 1
pch_swap()
d1109 22
a1130 22
    char **tp_line;		/* the text of the hunk */
    short *tp_len;		/* length of each line */
    char *tp_char;		/* +, -, and ! */
    LINENUM i;
    LINENUM n;
    bool blankline = FALSE;
    char *s;

    i = p_first;
    p_first = p_newfirst;
    p_newfirst = i;

    /* make a scratch copy */

    tp_line = p_line;
    tp_len = p_len;
    tp_char = p_char;
    p_line = Null(char**);	/* force set_hunkmax to allocate again */
    p_len = Null(short*);
    p_char = Nullch;
    set_hunkmax();
    if (p_line == Null(char**) || p_len == Null(short*) || p_char == Nullch) {
d1132 6
a1137 6
	if (p_line == Null(char**))
	    free((char*)p_line);
	p_line = tp_line;
	if (p_len == Null(short*))
	    free((char*)p_len);
	p_len = tp_len;
d1139 7
a1145 29
	if (p_char == Nullch)
	    free((char*)p_char);
	p_char = tp_char;
	return FALSE;		/* not enough memory to swap hunk! */
    }

    /* now turn the new into the old */

    i = p_ptrn_lines + 1;
    if (tp_char[i] == '\n') {		/* account for possible blank line */
	blankline = TRUE;
	i++;
    }
    if (p_efake >= 0) {			/* fix non-freeable ptr range */
	if (p_efake <= i)
	    n = p_end - i + 1;
	else
	    n = -i;
	p_efake += n;
	p_bfake += n;
    }
    for (n=0; i <= p_end; i++,n++) {
	p_line[n] = tp_line[i];
	p_char[n] = tp_char[i];
	if (p_char[n] == '+')
	    p_char[n] = '-';
	p_len[n] = tp_len[i];
    }
    if (blankline) {
d1147 50
a1196 29
	p_line[n] = tp_line[i];
	p_char[n] = tp_char[i];
	p_len[n] = tp_len[i];
	n++;
    }
    assert(p_char[0] == '=');
    p_char[0] = '*';
    for (s=p_line[0]; *s; s++)
	if (*s == '-')
	    *s = '*';

    /* now turn the old into the new */

    assert(tp_char[0] == '*');
    tp_char[0] = '=';
    for (s=tp_line[0]; *s; s++)
	if (*s == '*')
	    *s = '-';
    for (i=0; n <= p_end; i++,n++) {
	p_line[n] = tp_line[i];
	p_char[n] = tp_char[i];
	if (p_char[n] == '-')
	    p_char[n] = '+';
	p_len[n] = tp_len[i];
    }
    assert(i == p_ptrn_lines + 1);
    i = p_ptrn_lines;
    p_ptrn_lines = p_repl_lines;
    p_repl_lines = i;
d1198 4
a1201 4
    if (tp_line == Null(char**))
	free((char*)tp_line);
    if (tp_len == Null(short*))
	free((char*)tp_len);
d1203 3
a1205 3
    if (tp_char == Nullch)
	free((char*)tp_char);
    return TRUE;
d1208 3
a1210 2
/* Return the specified line position in the old file of the old context. */

d1212 1
a1212 1
pch_first()
d1214 1
a1214 1
    return p_first;
d1217 3
a1219 2
/* Return the number of lines of old context. */

d1221 1
a1221 1
pch_ptrn_lines()
d1223 1
a1223 1
    return p_ptrn_lines;
d1226 3
a1228 2
/* Return the probable line position in the new file of the first line. */

d1230 1
a1230 1
pch_newfirst()
d1232 1
a1232 1
    return p_newfirst;
d1235 3
a1237 2
/* Return the number of lines in the replacement text including context. */

d1239 1
a1239 1
pch_repl_lines()
d1241 1
a1241 1
    return p_repl_lines;
d1244 3
a1246 2
/* Return the number of lines in the whole hunk. */

d1248 1
a1248 1
pch_end()
d1250 1
a1250 1
    return p_end;
d1253 3
a1255 2
/* Return the number of context lines before the first changed line. */

d1257 1
a1257 1
pch_context()
d1259 1
a1259 1
    return p_context;
d1262 3
a1264 2
/* Return the length of a particular patch line. */

d1266 1
a1266 2
pch_line_len(line)
LINENUM line;
d1268 1
a1268 1
    return p_len[line];
d1271 3
a1273 2
/* Return the control character (+, -, *, !, etc) for a patch line. */

d1275 1
a1275 2
pch_char(line)
LINENUM line;
d1277 1
a1277 1
    return p_char[line];
d1280 3
a1282 2
/* Return a pointer to a particular patch line. */

d1284 1
a1284 2
pfetch(line)
LINENUM line;
d1286 1
a1286 1
    return p_line[line];
d1289 3
a1291 2
/* Return where in the patch file this hunk began, for error messages. */

d1293 1
a1293 1
pch_hunk_beg()
d1295 1
a1295 1
    return p_hunk_beg;
d1298 3
a1300 2
/* Apply an ed script by feeding ed itself. */

d1302 1
a1302 1
do_ed_script()
d1304 38
a1341 33
    char *t;
    long beginning_of_this_line;
    bool this_line_is_command = FALSE;
    FILE *pipefp;

    if (!skip_rest_of_patch) {
	unlink(TMPOUTNAME);
	copy_file(filearg[0], TMPOUTNAME);
	if (verbose)
	    snprintf(buf, sizeof buf, "/bin/ed %s", TMPOUTNAME);
	else
	    snprintf(buf, sizeof buf, "/bin/ed - %s", TMPOUTNAME);
	pipefp = popen(buf, "w");
    }
    for (;;) {
	beginning_of_this_line = ftell(pfp);
	if (pgets(buf, sizeof buf, pfp) == Nullch) {
	    next_intuit_at(beginning_of_this_line,p_input_line);
	    break;
	}
	p_input_line++;
	for (t=buf; isdigit(*t) || *t == ','; t++) ;
	this_line_is_command = (isdigit(*buf) &&
	  (*t == 'd' || *t == 'c' || *t == 'a') );
	if (this_line_is_command) {
	    if (!skip_rest_of_patch)
		fputs(buf, pipefp);
	    if (*t != 'd') {
		while (pgets(buf, sizeof buf, pfp) != Nullch) {
		    p_input_line++;
		    if (!skip_rest_of_patch)
			fputs(buf, pipefp);
		    if (strEQ(buf, ".\n"))
a1343 1
	    }
d1345 13
a1357 3
	else {
	    next_intuit_at(beginning_of_this_line,p_input_line);
	    break;
d1359 1
a1359 17
    }
    if (skip_rest_of_patch)
	return;
    fprintf(pipefp, "w\n");
    fprintf(pipefp, "q\n");
    fflush(pipefp);
    pclose(pipefp);
    ignore_signals();
    if (!check_only) {
	if (move_file(TMPOUTNAME, outname) < 0) {
	    toutkeep = TRUE;
	    chmod(TMPOUTNAME, filemode);
	}
	else
	    chmod(outname, filemode);
    }
    set_signals(1);
@


1.15
log
@Fix merge error.
ok millert@@ tedu@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pch.c,v 1.14 2003/07/16 18:09:20 otto Exp $	*/
d4 1
a4 1
static char rcsid[] = "$OpenBSD: pch.c,v 1.14 2003/07/16 18:09:20 otto Exp $";
d61 1
a61 1
	    pfatal2("can't create %s", TMPPATNAME);
d64 1
a64 1
	Fclose(pfp);
d69 2
a70 2
	pfatal2("patch file %s not found", filename);
    Fstat(fileno(pfp), &filestat);
d97 1
a97 1
    /* 
d111 1
a111 1
	fatal1("out of memory\n");
d123 1
a123 1
	    say1("done\n");
d127 1
a127 1
	say1("Hmm...");
d132 1
a132 1
		say1("  Ignoring the trailing garbage.\ndone\n");
d135 1
a135 1
	    say1("  I can't seem to find a patch in there anywhere.\n");
d139 1
a139 1
	say3("  %sooks like %s to me...\n",
d147 1
a147 1
	say3("(Patch is indented %d space%s.)\n", p_indent, p_indent==1?"":"s");
d151 1
a151 1
	    say1("No file to patch.  Skipping...\n");
d156 1
a156 1
	ask1("File to patch: ");
d164 1
a164 1
	    ask1("No file found--skip this patch? [n] ");
d169 1
a169 1
		say1("Skipping patch...\n");
d183 3
a185 3
    Reg4 long this_line = 0;
    Reg5 long previous_line;
    Reg6 long first_command_line = -1;
d187 7
a193 7
    Reg7 bool last_line_was_command = FALSE;
    Reg8 bool this_is_a_command = FALSE;
    Reg9 bool stars_last_line = FALSE;
    Reg10 bool stars_this_line = FALSE;
    Reg3 int indent;
    Reg1 char *s;
    Reg2 char *t;
d200 1
a200 1
    Reg11 int retval;
d204 1
a204 1
    Fseek(pfp, p_base, 0);
d234 1
a234 1
	for (t=s; isdigit(*t) || *t == ','; t++) ; 
d237 1
a237 1
	if (first_command_line < 0L && this_is_a_command) { 
d293 1
a293 1
	if ((!diff_type || diff_type == NORMAL_DIFF) && 
d385 2
a386 2
	Fseek(pfp, p_base, 0);
	say1("The text leading up to this was:\n--------------------------\n");
d390 1
a390 1
	    say2("|%s", buf);
d392 1
a392 1
	say1("--------------------------\n");
d395 1
a395 1
	Fseek(pfp, file_pos, 0);
d401 1
a401 1
malformed ()
d403 1
a403 1
    fatal3("malformed patch at line %ld: %s", p_input_line, buf);
d436 3
a438 3
    Reg1 char *s;
    Reg8 char *ret;
    Reg2 int context = 0;
d455 3
a457 3
	Reg4 LINENUM fillcnt = 0;	/* #lines of missing ptrn or repl */
	Reg5 LINENUM fillsrc;		/* index of first line to copy */
	Reg6 LINENUM filldst;		/* index of first missing line */
d459 1
a459 1
	Reg9 bool repl_could_be_missing = TRUE;
d465 1
a465 1
	Reg7 LINENUM ptrn_copiable = 0;
d489 1
a489 1
		    fatal1("unexpected end of file in patch\n");
d508 1
a508 1
			fatal2("unexpected end of hunk at line %ld\n",
d516 1
a516 1
		    fatal3("unexpected *** at line %ld: %s", p_input_line, buf);
d567 1
a567 1
				fatal3(
d572 1
a572 1
				fatal4(
d609 1
a609 1
			fatal4("hunk too large (%ld lines) at line %ld: %s",
d696 1
a696 1
	
d699 1
a699 1
	    fatal2("no --- found in patch at line %ld\n", pch_hunk_beg());
d702 1
a702 1
	    
d707 2
a708 2
	    Fseek(pfp, repl_backtrack_position, 0);
	    
d741 1
a741 1
		say4("%s\n%s\n%s\n",
d747 1
a747 1
	
d756 1
a756 1
		    fatal2("replacement text or line numbers mangled in hunk at line %ld\n",
d784 2
a785 2
	Reg4 LINENUM fillsrc;		/* index of old lines */
	Reg5 LINENUM filldst;		/* index of new lines */
d825 1
a825 1
	Snprintf(buf, sizeof buf, "*** %ld,%ld ****\n", p_first,
d833 1
a833 1
        Snprintf(buf, sizeof buf, "--- %ld,%ld ----\n", p_newfirst,
d853 1
a853 1
		    fatal1("unexpected end of file in patch\n");
d941 1
a941 1
	Reg3 int i;
d973 1
a973 1
	    fatal4("hunk too large (%ld lines) at line %ld: %s",
d979 1
a979 1
	Snprintf(buf, sizeof buf, "*** %ld,%ld\n", p_first,
d991 1
a991 1
		fatal2("unexpected end of file in patch at line %ld\n",
d994 1
a994 1
		fatal2("< expected at line %ld of patch\n", p_input_line);
d1013 1
a1013 1
		fatal2("unexpected end of file in patch at line %ld\n",
d1016 1
a1016 1
		fatal2("--- expected at line %ld of patch\n", p_input_line);
d1018 1
a1018 1
	Snprintf(buf, sizeof(buf), "--- %ld,%ld\n", min, max);
d1029 1
a1029 1
		fatal2("unexpected end of file in patch at line %ld\n",
d1032 1
a1032 1
		fatal2("> expected at line %ld of patch\n", p_input_line);
d1049 1
a1049 1
	    say1("Not enough memory to swap next hunk!\n");
d1061 1
a1061 1
	    Fflush(stderr);
d1079 2
a1080 2
    Reg1 char *s;
    Reg2 int indent = 0;
d1091 1
a1091 1
	    fatal1("buffer too small in pgets()\n");
d1104 2
a1105 2
    Reg1 LINENUM i;
    Reg2 LINENUM n;
d1107 1
a1107 1
    Reg3 char *s;
d1112 1
a1112 1
    
d1289 4
a1292 4
    Reg1 char *t;
    Reg2 long beginning_of_this_line;
    Reg3 bool this_line_is_command = FALSE;
    Reg4 FILE *pipefp;
d1295 1
a1295 1
	Unlink(TMPOUTNAME);
d1298 1
a1298 1
	    Snprintf(buf, sizeof buf, "/bin/ed %s", TMPOUTNAME);
d1300 1
a1300 1
	    Snprintf(buf, sizeof buf, "/bin/ed - %s", TMPOUTNAME);
d1335 2
a1336 2
    Fflush(pipefp);
    Pclose(pipefp);
@


1.14
log
@Teach patch how to deal with \ No newline at end of file.
From NetBSD.
ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pch.c,v 1.13 2003/04/08 00:18:31 deraadt Exp $	*/
d4 1
a4 1
static char rcsid[] = "$OpenBSD: pch.c,v 1.13 2003/04/08 00:18:31 deraadt Exp $";
d923 2
a924 2
				p_len[fillsrc - 1] -= 1;
				s[p_len[fillsrc - 1]] = 0;
@


1.13
log
@strcpy trashing, help from tedu; ok tedu
@
text
@d1 1
a1 1
/*	$OpenBSD: pch.c,v 1.12 2003/04/05 17:17:53 deraadt Exp $	*/
d4 1
a4 1
static char rcsid[] = "$OpenBSD: pch.c,v 1.12 2003/04/05 17:17:53 deraadt Exp $";
d407 24
d639 8
d774 6
d880 6
d921 6
d1003 6
d1040 5
@


1.12
log
@string fixes; ok miod henning
@
text
@d1 1
a1 1
/*	$OpenBSD: pch.c,v 1.11 2000/12/14 00:02:19 beck Exp $	*/
d4 1
a4 1
static char rcsid[] = "$OpenBSD: pch.c,v 1.11 2000/12/14 00:02:19 beck Exp $";
d504 1
a504 1
		    strcpy(s, s+2);
@


1.11
log
@make patch -f and -b actually skip patches for which the file can't be
found, instead of claiming it will and erroring out anyway.
@
text
@d1 1
a1 1
/*	$OpenBSD: pch.c,v 1.10 1999/12/04 01:01:07 provos Exp $	*/
d4 1
a4 1
static char rcsid[] = "$OpenBSD: pch.c,v 1.10 1999/12/04 01:01:07 provos Exp $";
d457 4
a460 3
		if (p_max - p_end < 4)
		    strcpy(buf, "  \n");  /* assume blank lines got chopped */
		else {
d599 1
a599 1
		    strcpy(buf+1," \n");
d811 4
a814 3
		if (p_max - filldst < 3)
		    strcpy(buf, " \n");  /* assume blank lines got chopped */
		else {
@


1.10
log
@avoid overflows
@
text
@d1 1
a1 1
/*	$OpenBSD: pch.c,v 1.9 1998/11/25 00:30:26 espie Exp $	*/
d4 1
a4 1
static char rcsid[] = "$OpenBSD: pch.c,v 1.9 1998/11/25 00:30:26 espie Exp $";
d153 1
@


1.9
log
@add -C
@
text
@d1 1
a1 1
/*	$OpenBSD: pch.c,v 1.8 1997/04/03 07:07:36 imp Exp $	*/
d4 1
a4 1
static char rcsid[] = "$OpenBSD: pch.c,v 1.8 1997/04/03 07:07:36 imp Exp $";
d457 1
a457 1
		    Strcpy(buf, "  \n");  /* assume blank lines got chopped */
d502 1
a502 1
		    strcpy(s,s+2);
d810 1
a810 1
		    Strcpy(buf, " \n");  /* assume blank lines got chopped */
d1026 2
a1027 2
	if (buf != s)
	    Strcpy(buf, s);
@


1.8
log
@From FreeBSD 1.7 by markm.  The log message:
Priorities were broken. If there was an Index: line and ***/--- lines
with valid names, the ***/---names were taken first.
this broke eg:
Index: foo/Makefile
==========
RCS <blah>
Retrieving <blah>
diff <blah>
*** Makefile <blah>
--- Makefile <blah>

By trying to patch the Makefile in the _curent_ directory, rather than
the one in the foo/ directory.
@
text
@d1 1
a1 1
/*	$OpenBSD: pch.c,v 1.7 1996/09/24 04:19:29 millert Exp $	*/
d4 1
a4 1
static char rcsid[] = "$OpenBSD: pch.c,v 1.7 1996/09/24 04:19:29 millert Exp $";
d13 1
d1274 7
a1280 3
    if (move_file(TMPOUTNAME, outname) < 0) {
	toutkeep = TRUE;
	chmod(TMPOUTNAME, filemode);
a1281 2
    else
	chmod(outname, filemode);
@


1.7
log
@sprintf -> snprintf except where guaranteed safe.
@
text
@d1 1
a1 1
/*	$OpenBSD: pch.c,v 1.6 1996/09/23 10:54:22 deraadt Exp $	*/
d4 1
a4 1
static char rcsid[] = "$OpenBSD: pch.c,v 1.6 1996/09/23 10:54:22 deraadt Exp $";
d309 3
a311 1
	if (oldname && newname) {
a320 2
	else if (indname)
	    filearg[0] = savestr(indname);
@


1.6
log
@undo last; mkstemp is *hard* to do in here
@
text
@d1 1
a1 1
/*	$OpenBSD: pch.c,v 1.4 1996/07/01 20:40:10 deraadt Exp $	*/
d4 1
a4 1
static char rcsid[] = "$OpenBSD: pch.c,v 1.4 1996/07/01 20:40:10 deraadt Exp $";
d784 2
a785 1
	Sprintf(buf,"*** %ld,%ld ****\n",p_first,p_first + p_ptrn_lines - 1);
d792 2
a793 1
        Sprintf(buf,"--- %ld,%ld ----\n",p_newfirst,p_newfirst+p_repl_lines-1);
d925 2
a926 1
	Sprintf(buf, "*** %ld,%ld\n", p_first, p_first + p_ptrn_lines - 1);
d958 1
a958 1
	Sprintf(buf, "--- %ld,%ld\n", min, max);
d1233 1
a1233 1
	    Sprintf(buf, "/bin/ed %s", TMPOUTNAME);
d1235 1
a1235 1
	    Sprintf(buf, "/bin/ed - %s", TMPOUTNAME);
@


1.5
log
@Be slightly safer opening temp files.
@
text
@d58 2
a59 4
	int pfd;

	if ((pfd = open(TMPPATNAME, O_CREAT|O_EXCL|O_WRONLY, 0600)) < 0 ||
	    (pfp = fdopen(pfd, "w")) == Nullfp)
@


1.4
log
@undo mktemp cleanup until i get it right
@
text
@d1 1
a1 1
/*	$OpenBSD: pch.c,v 1.2 1996/06/10 11:21:33 niklas Exp $	*/
d4 1
a4 1
static char rcsid[] = "$OpenBSD: pch.c,v 1.2 1996/06/10 11:21:33 niklas Exp $";
d58 4
a61 2
	pfp = fopen(TMPPATNAME, "w");
	if (pfp == Nullfp)
@


1.3
log
@mktemp w/ open & fdopen
@
text
@a56 2
    int fd;

d58 2
a59 4
	if ((fd = open(TMPPATNAME, O_EXCL|O_CREAT|O_RDWR, 0666)) == -1 ||
	    (pfp = fdopen(fd, "w")) == NULL) {
	    if (fd != -1)
		close(fd);
a60 1
	}
@


1.2
log
@Support the long options that FSF's patch version has.  $OpenBSD$ added
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d4 1
a4 1
static char rcsid[] = "$OpenBSD: pch.c,v 1.1.1.1 1995/10/18 08:45:56 deraadt Exp $";
d57 2
d60 4
a63 2
	pfp = fopen(TMPPATNAME, "w");
	if (pfp == Nullfp)
d65 1
@


1.1
log
@Initial revision
@
text
@d1 2
d4 1
a4 1
static char rcsid[] = "$Id: pch.c,v 1.2 1993/08/02 17:55:21 mycroft Exp $";
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@
