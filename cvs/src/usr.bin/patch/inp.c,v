head	1.47;
access;
symbols
	OPENBSD_6_1:1.47.0.2
	OPENBSD_6_1_BASE:1.47
	OPENBSD_6_0:1.46.0.2
	OPENBSD_6_0_BASE:1.46
	OPENBSD_5_9:1.45.0.2
	OPENBSD_5_9_BASE:1.45
	OPENBSD_5_8:1.44.0.4
	OPENBSD_5_8_BASE:1.44
	OPENBSD_5_7:1.43.0.2
	OPENBSD_5_7_BASE:1.43
	OPENBSD_5_6:1.37.0.6
	OPENBSD_5_6_BASE:1.37
	OPENBSD_5_5:1.37.0.4
	OPENBSD_5_5_BASE:1.37
	OPENBSD_5_4:1.36.0.6
	OPENBSD_5_4_BASE:1.36
	OPENBSD_5_3:1.36.0.4
	OPENBSD_5_3_BASE:1.36
	OPENBSD_5_2:1.36.0.2
	OPENBSD_5_2_BASE:1.36
	OPENBSD_5_1_BASE:1.35
	OPENBSD_5_1:1.35.0.10
	OPENBSD_5_0:1.35.0.8
	OPENBSD_5_0_BASE:1.35
	OPENBSD_4_9:1.35.0.6
	OPENBSD_4_9_BASE:1.35
	OPENBSD_4_8:1.35.0.4
	OPENBSD_4_8_BASE:1.35
	OPENBSD_4_7:1.35.0.2
	OPENBSD_4_7_BASE:1.35
	OPENBSD_4_6:1.34.0.16
	OPENBSD_4_6_BASE:1.34
	OPENBSD_4_5:1.34.0.12
	OPENBSD_4_5_BASE:1.34
	OPENBSD_4_4:1.34.0.10
	OPENBSD_4_4_BASE:1.34
	OPENBSD_4_3:1.34.0.8
	OPENBSD_4_3_BASE:1.34
	OPENBSD_4_2:1.34.0.6
	OPENBSD_4_2_BASE:1.34
	OPENBSD_4_1:1.34.0.4
	OPENBSD_4_1_BASE:1.34
	OPENBSD_4_0:1.34.0.2
	OPENBSD_4_0_BASE:1.34
	OPENBSD_3_9:1.33.0.2
	OPENBSD_3_9_BASE:1.33
	OPENBSD_3_8:1.32.0.6
	OPENBSD_3_8_BASE:1.32
	OPENBSD_3_7:1.32.0.4
	OPENBSD_3_7_BASE:1.32
	OPENBSD_3_6:1.32.0.2
	OPENBSD_3_6_BASE:1.32
	OPENBSD_3_5:1.31.0.2
	OPENBSD_3_5_BASE:1.31
	OPENBSD_3_4:1.28.0.2
	OPENBSD_3_4_BASE:1.28
	OPENBSD_3_3:1.9.0.4
	OPENBSD_3_3_BASE:1.9
	OPENBSD_3_2:1.9.0.2
	OPENBSD_3_2_BASE:1.9
	OPENBSD_3_1:1.8.0.14
	OPENBSD_3_1_BASE:1.8
	OPENBSD_3_0:1.8.0.12
	OPENBSD_3_0_BASE:1.8
	OPENBSD_2_9_BASE:1.8
	OPENBSD_2_9:1.8.0.10
	OPENBSD_2_8:1.8.0.8
	OPENBSD_2_8_BASE:1.8
	OPENBSD_2_7:1.8.0.6
	OPENBSD_2_7_BASE:1.8
	OPENBSD_2_6:1.8.0.4
	OPENBSD_2_6_BASE:1.8
	OPENBSD_2_5:1.8.0.2
	OPENBSD_2_5_BASE:1.8
	OPENBSD_2_4:1.6.0.6
	OPENBSD_2_4_BASE:1.6
	OPENBSD_2_3:1.6.0.4
	OPENBSD_2_3_BASE:1.6
	OPENBSD_2_2:1.6.0.2
	OPENBSD_2_2_BASE:1.6
	OPENBSD_2_1:1.5.0.4
	OPENBSD_2_1_BASE:1.5
	OPENBSD_2_0:1.5.0.2
	OPENBSD_2_0_BASE:1.5
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.47
date	2017.03.25.23.13.45;	author deraadt;	state Exp;
branches;
next	1.46;
commitid	mF6ZydOo0Kq604Ly;

1.46
date	2016.07.19.06.43.27;	author deraadt;	state Exp;
branches;
next	1.45;
commitid	B2XC0go4gk9SNttR;

1.45
date	2015.11.11.01.12.10;	author deraadt;	state Exp;
branches;
next	1.44;
commitid	nVtGolYSsQ6VkRrW;

1.44
date	2015.07.26.14.32.19;	author millert;	state Exp;
branches;
next	1.43;
commitid	09nDnpMEB9OxbzYE;

1.43
date	2015.02.05.12.59.57;	author millert;	state Exp;
branches
	1.43.2.1;
next	1.42;
commitid	DTQbfd4poqBW8iSJ;

1.42
date	2014.12.09.20.28.43;	author tobias;	state Exp;
branches;
next	1.41;
commitid	Qno7LGw6tkvX5SWJ;

1.41
date	2014.11.25.10.22.08;	author tobias;	state Exp;
branches;
next	1.40;
commitid	y7wiOI6DK4Ms8aWf;

1.40
date	2014.11.22.15.49.28;	author tobias;	state Exp;
branches;
next	1.39;
commitid	vyatgew5pmIq3geU;

1.39
date	2014.11.15.16.35.47;	author tobias;	state Exp;
branches;
next	1.38;
commitid	1DDzrDSrhWHErGCa;

1.38
date	2014.10.08.04.06.23;	author doug;	state Exp;
branches;
next	1.37;
commitid	oSx8EZJY4AgZHtQV;

1.37
date	2013.11.26.13.19.07;	author deraadt;	state Exp;
branches
	1.37.6.1;
next	1.36;

1.36
date	2012.04.10.14.46.34;	author ajacoutot;	state Exp;
branches;
next	1.35;

1.35
date	2009.10.27.23.59.41;	author deraadt;	state Exp;
branches;
next	1.34;

1.34
date	2006.03.11.19.41.30;	author otto;	state Exp;
branches;
next	1.33;

1.33
date	2005.11.14.19.54.10;	author miod;	state Exp;
branches;
next	1.32;

1.32
date	2004.08.05.21.47.24;	author deraadt;	state Exp;
branches;
next	1.31;

1.31
date	2003.12.08.22.44.18;	author mickey;	state Exp;
branches;
next	1.30;

1.30
date	2003.11.21.21.25.59;	author mickey;	state Exp;
branches;
next	1.29;

1.29
date	2003.09.28.07.55.19;	author otto;	state Exp;
branches;
next	1.28;

1.28
date	2003.08.15.08.00.51;	author otto;	state Exp;
branches;
next	1.27;

1.27
date	2003.08.12.21.13.10;	author otto;	state Exp;
branches;
next	1.26;

1.26
date	2003.08.10.21.28.48;	author otto;	state Exp;
branches;
next	1.25;

1.25
date	2003.08.08.07.53.19;	author otto;	state Exp;
branches;
next	1.24;

1.24
date	2003.08.05.18.20.33;	author deraadt;	state Exp;
branches;
next	1.23;

1.23
date	2003.08.05.18.13.43;	author otto;	state Exp;
branches;
next	1.22;

1.22
date	2003.08.01.20.30.48;	author otto;	state Exp;
branches;
next	1.21;

1.21
date	2003.07.31.14.10.21;	author otto;	state Exp;
branches;
next	1.20;

1.20
date	2003.07.28.19.15.34;	author deraadt;	state Exp;
branches;
next	1.19;

1.19
date	2003.07.28.18.35.36;	author otto;	state Exp;
branches;
next	1.18;

1.18
date	2003.07.23.07.31.21;	author otto;	state Exp;
branches;
next	1.17;

1.17
date	2003.07.22.17.52.20;	author deraadt;	state Exp;
branches;
next	1.16;

1.16
date	2003.07.22.17.18.49;	author otto;	state Exp;
branches;
next	1.15;

1.15
date	2003.07.21.21.01.45;	author otto;	state Exp;
branches;
next	1.14;

1.14
date	2003.07.21.14.32.21;	author deraadt;	state Exp;
branches;
next	1.13;

1.13
date	2003.07.21.14.30.31;	author deraadt;	state Exp;
branches;
next	1.12;

1.12
date	2003.07.21.14.00.41;	author deraadt;	state Exp;
branches;
next	1.11;

1.11
date	2003.07.18.02.00.09;	author deraadt;	state Exp;
branches;
next	1.10;

1.10
date	2003.07.16.16.06.53;	author otto;	state Exp;
branches;
next	1.9;

1.9
date	2002.07.04.04.22.48;	author deraadt;	state Exp;
branches;
next	1.8;

1.8
date	99.01.03.05.33.48;	author millert;	state Exp;
branches;
next	1.7;

1.7
date	98.11.25.00.30.25;	author espie;	state Exp;
branches;
next	1.6;

1.6
date	97.09.22.05.45.26;	author millert;	state Exp;
branches;
next	1.5;

1.5
date	96.09.24.04.19.26;	author millert;	state Exp;
branches;
next	1.4;

1.4
date	96.07.01.20.40.07;	author deraadt;	state Exp;
branches;
next	1.3;

1.3
date	96.06.25.23.06.38;	author deraadt;	state Exp;
branches;
next	1.2;

1.2
date	96.06.10.11.21.28;	author niklas;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.45.55;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.45.55;	author deraadt;	state Exp;
branches;
next	;

1.37.6.1
date	2015.07.27.16.08.18;	author guenther;	state Exp;
branches;
next	;
commitid	ltV6h69MuIPDoBUT;

1.43.2.1
date	2015.07.27.16.10.54;	author krw;	state Exp;
branches;
next	;
commitid	7qowXgsHJsgQ1um1;


desc
@@


1.47
log
@parameter "lines_allocated" is a local pointer and should not be confused
with the global by the same name, so rename it "lines_allocatedp".
@
text
@/*	$OpenBSD: inp.c,v 1.46 2016/07/19 06:43:27 deraadt Exp $	*/

/*
 * patch - a program to apply diffs to original files
 * 
 * Copyright 1986, Larry Wall
 * 
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following condition is met:
 * 1. Redistributions of source code must retain the above copyright notice,
 * this condition and the following disclaimer.
 * 
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND ANY
 * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
 * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 * 
 * -C option added in 1998, original code by Marc Espie, based on FreeBSD
 * behaviour
 */

#include <sys/types.h>
#include <sys/file.h>
#include <sys/stat.h>
#include <sys/mman.h>

#include <ctype.h>
#include <libgen.h>
#include <stddef.h>
#include <stdint.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>

#include "common.h"
#include "util.h"
#include "pch.h"
#include "inp.h"


/* Input-file-with-indexable-lines abstract type */

static off_t	i_size;		/* size of the input file */
static char	*i_womp;	/* plan a buffer for entire file */
static char	**i_ptr;	/* pointers to lines in i_womp */

static int	tifd = -1;	/* plan b virtual string array */
static char	*tibuf[2];	/* plan b buffers */
static LINENUM	tiline[2] = {-1, -1};	/* 1st line in each buffer */
static size_t	lines_per_buf;	/* how many lines per buffer */
static size_t	tibuflen;	/* plan b buffer length */
static size_t	tireclen;	/* length of records in tmp file */

static bool	rev_in_string(const char *);
static bool	reallocate_lines(size_t *);

/* returns false if insufficient memory */
static bool	plan_a(const char *);

static void	plan_b(const char *);

/* New patch--prepare to edit another file. */

void
re_input(void)
{
	if (using_plan_a) {
		free(i_ptr);
		i_ptr = NULL;
		if (i_womp != NULL) {
			munmap(i_womp, i_size);
			i_womp = NULL;
		}
		i_size = 0;
	} else {
		using_plan_a = true;	/* maybe the next one is smaller */
		close(tifd);
		tifd = -1;
		free(tibuf[0]);
		free(tibuf[1]);
		tibuf[0] = tibuf[1] = NULL;
		tiline[0] = tiline[1] = -1;
		tireclen = 0;
	}
}

/* Construct the line index, somehow or other. */

void
scan_input(const char *filename)
{
	if (!plan_a(filename))
		plan_b(filename);
	if (verbose) {
		say("Patching file %s using Plan %s...\n", filename,
		    (using_plan_a ? "A" : "B"));
	}
}

static bool
reallocate_lines(size_t *lines_allocatedp)
{
	char	**p;
	size_t	new_size;

	new_size = *lines_allocatedp * 3 / 2;
	p = reallocarray(i_ptr, new_size + 2, sizeof(char *));
	if (p == NULL) {	/* shucks, it was a near thing */
		munmap(i_womp, i_size);
		i_womp = NULL;
		free(i_ptr);
		i_ptr = NULL;
		*lines_allocatedp = 0;
		return false;
	}
	*lines_allocatedp = new_size;
	i_ptr = p;
	return true;
}

/* Try keeping everything in memory. */

static bool
plan_a(const char *filename)
{
	int		ifd, statfailed;
	char		*p, *s;
	struct stat	filestat;
	off_t		i;
	ptrdiff_t	sz;
	size_t		iline, lines_allocated;

#ifdef DEBUGGING
	if (debug & 8)
		return false;
#endif

	if (filename == NULL || *filename == '\0')
		return false;

	statfailed = stat(filename, &filestat);
	if (statfailed && ok_to_create_file) {
		int fd;

		if (verbose)
			say("(Creating file %s...)\n", filename);

		/*
		 * in check_patch case, we still display `Creating file' even
		 * though we're not. The rule is that -C should be as similar
		 * to normal patch behavior as possible
		 */
		if (check_only)
			return true;
		makedirs(filename, true);
		if ((fd = open(filename, O_CREAT | O_TRUNC | O_WRONLY, 0666)) != -1)
			close(fd);

		statfailed = stat(filename, &filestat);
	}
	if (statfailed)
		fatal("can't find %s\n", filename);
	filemode = filestat.st_mode;
	if (!S_ISREG(filemode))
		fatal("%s is not a normal file--can't patch\n", filename);
	i_size = filestat.st_size;
	if (out_of_mem) {
		set_hunkmax();	/* make sure dynamic arrays are allocated */
		out_of_mem = false;
		return false;	/* force plan b because plan a bombed */
	}
	if (i_size > SIZE_MAX) {
		say("block too large to mmap\n");
		return false;
	}
	if ((ifd = open(filename, O_RDONLY)) < 0)
		pfatal("can't open file %s", filename);

	if (i_size) {
		i_womp = mmap(NULL, i_size, PROT_READ, MAP_PRIVATE, ifd, 0);
		if (i_womp == MAP_FAILED) {
			perror("mmap failed");
			i_womp = NULL;
			close(ifd);
			return false;
		}
	} else {
		i_womp = NULL;
	}

	close(ifd);
	if (i_size)
		madvise(i_womp, i_size, MADV_SEQUENTIAL);

	/* estimate the number of lines */
	lines_allocated = i_size / 25;
	if (lines_allocated < 100)
		lines_allocated = 100;

	if (!reallocate_lines(&lines_allocated))
		return false;

	/* now scan the buffer and build pointer array */
	iline = 1;
	i_ptr[iline] = i_womp;
	/* test for NUL too, to maintain the behavior of the original code */
	for (s = i_womp, i = 0; i < i_size && *s != '\0'; s++, i++) {
		if (*s == '\n') {
			if (iline == lines_allocated) {
				if (!reallocate_lines(&lines_allocated))
					return false;
			}
			/* these are NOT NUL terminated */
			i_ptr[++iline] = s + 1;
		}
	}
	/* if the last line contains no EOL, append one */
	if (i_size > 0 && i_womp[i_size - 1] != '\n') {
		last_line_missing_eol = true;
		/* fix last line */
		sz = s - i_ptr[iline];
		p = malloc(sz + 1);
		if (p == NULL) {
			free(i_ptr);
			i_ptr = NULL;
			munmap(i_womp, i_size);
			i_womp = NULL;
			return false;
		}

		memcpy(p, i_ptr[iline], sz);
		p[sz] = '\n';
		i_ptr[iline] = p;
		/* count the extra line and make it point to some valid mem */
		i_ptr[++iline] = "";
	} else
		last_line_missing_eol = false;

	input_lines = iline - 1;

	/* now check for revision, if any */

	if (revision != NULL) {
		if (i_womp == NULL || !rev_in_string(i_womp)) {
			if (force) {
				if (verbose)
					say("Warning: this file doesn't appear "
					    "to be the %s version--patching anyway.\n",
					    revision);
			} else if (batch) {
				fatal("this file doesn't appear to be the "
				    "%s version--aborting.\n",
				    revision);
			} else {
				ask("This file doesn't appear to be the "
				    "%s version--patch anyway? [n] ",
				    revision);
				if (*buf != 'y')
					fatal("aborted\n");
			}
		} else if (verbose)
			say("Good.  This file appears to be the %s version.\n",
			    revision);
	}
	return true;		/* plan a will work */
}

/* Keep (virtually) nothing in memory. */

static void
plan_b(const char *filename)
{
	FILE	*ifp;
	size_t	i = 0, j, len, maxlen = 1;
	char	*lbuf = NULL, *p;
	bool	found_revision = (revision == NULL);

	using_plan_a = false;
	if ((ifp = fopen(filename, "r")) == NULL)
		pfatal("can't open file %s", filename);
	(void) unlink(TMPINNAME);
	if ((tifd = open(TMPINNAME, O_EXCL | O_CREAT | O_WRONLY, 0666)) < 0)
		pfatal("can't open file %s", TMPINNAME);
	while ((p = fgetln(ifp, &len)) != NULL) {
		if (p[len - 1] == '\n')
			p[len - 1] = '\0';
		else {
			/* EOF without EOL, copy and add the NUL */
			if ((lbuf = malloc(len + 1)) == NULL)
				fatal("out of memory\n");
			memcpy(lbuf, p, len);
			lbuf[len] = '\0';
			p = lbuf;

			last_line_missing_eol = true;
			len++;
		}
		if (revision != NULL && !found_revision && rev_in_string(p))
			found_revision = true;
		if (len > maxlen)
			maxlen = len;	/* find longest line */
	}
	free(lbuf);
	if (ferror(ifp))
		pfatal("can't read file %s", filename);

	if (revision != NULL) {
		if (!found_revision) {
			if (force) {
				if (verbose)
					say("Warning: this file doesn't appear "
					    "to be the %s version--patching anyway.\n",
					    revision);
			} else if (batch) {
				fatal("this file doesn't appear to be the "
				    "%s version--aborting.\n",
				    revision);
			} else {
				ask("This file doesn't appear to be the %s "
				    "version--patch anyway? [n] ",
				    revision);
				if (*buf != 'y')
					fatal("aborted\n");
			}
		} else if (verbose)
			say("Good.  This file appears to be the %s version.\n",
			    revision);
	}
	fseek(ifp, 0L, SEEK_SET);	/* rewind file */
	tireclen = maxlen;
	tibuflen = maxlen > BUFFERSIZE ? maxlen : BUFFERSIZE;
	lines_per_buf = tibuflen / maxlen;
	tibuf[0] = malloc(tibuflen + 1);
	if (tibuf[0] == NULL)
		fatal("out of memory\n");
	tibuf[1] = malloc(tibuflen + 1);
	if (tibuf[1] == NULL)
		fatal("out of memory\n");
	for (i = 1;; i++) {
		p = tibuf[0] + maxlen * (i % lines_per_buf);
		if (i % lines_per_buf == 0)	/* new block */
			if (write(tifd, tibuf[0], tibuflen) !=
			    (ssize_t) tibuflen)
				pfatal("can't write temp file");
		if (fgets(p, maxlen + 1, ifp) == NULL) {
			input_lines = i - 1;
			if (i % lines_per_buf != 0)
				if (write(tifd, tibuf[0], tibuflen) !=
				    (ssize_t) tibuflen)
					pfatal("can't write temp file");
			break;
		}
		j = strlen(p);
		/* These are '\n' terminated strings, so no need to add a NUL */
		if (j == 0 || p[j - 1] != '\n')
			p[j] = '\n';
	}
	fclose(ifp);
	close(tifd);
	if ((tifd = open(TMPINNAME, O_RDONLY)) < 0)
		pfatal("can't reopen file %s", TMPINNAME);
}

/*
 * Fetch a line from the input file, \n terminated, not necessarily \0.
 */
char *
ifetch(LINENUM line, int whichbuf)
{
	if (line < 1 || line > input_lines) {
		if (warn_on_invalid_line) {
			say("No such line %ld in input file, ignoring\n", line);
			warn_on_invalid_line = false;
		}
		return NULL;
	}
	if (using_plan_a)
		return i_ptr[line];
	else {
		LINENUM	offline = line % lines_per_buf;
		LINENUM	baseline = line - offline;

		if (tiline[0] == baseline)
			whichbuf = 0;
		else if (tiline[1] == baseline)
			whichbuf = 1;
		else {
			tiline[whichbuf] = baseline;

			if (lseek(tifd, (off_t) (baseline / lines_per_buf *
			    tibuflen), SEEK_SET) < 0)
				pfatal("cannot seek in the temporary input file");

			if (read(tifd, tibuf[whichbuf], tibuflen)
			    != (ssize_t) tibuflen)
				pfatal("error reading tmp file %s", TMPINNAME);
		}
		return tibuf[whichbuf] + (tireclen * offline);
	}
}

/*
 * True if the string argument contains the revision number we want.
 */
static bool
rev_in_string(const char *string)
{
	const char	*s;
	size_t		patlen;

	if (revision == NULL)
		return true;
	patlen = strlen(revision);
	if (strnEQ(string, revision, patlen) &&
	    isspace((unsigned char)string[patlen]))
		return true;
	for (s = string; *s; s++) {
		if (isspace((unsigned char)*s) && strnEQ(s + 1, revision, patlen) &&
		    isspace((unsigned char)s[patlen + 1])) {
			return true;
		}
	}
	return false;
}
@


1.46
log
@Cleanup close(open idioms.
ok krw
@
text
@d1 1
a1 1
/*	$OpenBSD: inp.c,v 1.45 2015/11/11 01:12:10 deraadt Exp $	*/
d109 1
a109 1
reallocate_lines(size_t *lines_allocated)
d114 1
a114 1
	new_size = *lines_allocated * 3 / 2;
d121 1
a121 1
		*lines_allocated = 0;
d124 1
a124 1
	*lines_allocated = new_size;
@


1.45
log
@creat() -> open equiv; from Frederic Nowak
@
text
@d1 1
a1 1
/*	$OpenBSD: inp.c,v 1.44 2015/07/26 14:32:19 millert Exp $	*/
d151 2
d164 3
a166 1
		close(open(filename, O_CREAT | O_TRUNC | O_WRONLY, 0666));
@


1.44
log
@Remove support for automatically checking files out of RCS.  The
behavior is confusing to users and even GNU patch no longer does
it by default.  OK krw@@ guenther@@
@
text
@d1 1
a1 1
/*	$OpenBSD: inp.c,v 1.43 2015/02/05 12:59:57 millert Exp $	*/
d162 1
a162 1
		close(creat(filename, 0666));
@


1.43
log
@Include stdint.h, not limits.h to get SIZE_MAX.  OK guenther@@
@
text
@d1 1
a1 1
/*	$OpenBSD: inp.c,v 1.42 2014/12/09 20:28:43 tobias Exp $	*/
d135 1
a135 1
	char		*p, *s, lbuf[MAXLINELEN];
d165 2
a166 61
	if (statfailed && check_only)
		fatal("%s not found, -C mode, can't probe further\n", filename);
	/* For nonexistent or read-only files, look for RCS versions.  */
	if (statfailed ||
	    /* No one can write to it.  */
	    (filestat.st_mode & 0222) == 0 ||
	    /* I can't write to it.  */
	    ((filestat.st_mode & 0022) == 0 && filestat.st_uid != getuid())) {
		char	*cs = NULL, *filebase, *filedir;
		struct stat	cstat;

		filebase = basename(filename);
		filedir = dirname(filename);

		/* Leave room in lbuf for the diff command.  */
		s = lbuf + 20;

#define try(f, a1, a2, a3) \
	(snprintf(s, sizeof lbuf - 20, f, a1, a2, a3), stat(s, &cstat) == 0)

		if (try("%s/RCS/%s%s", filedir, filebase, RCSSUFFIX) ||
		    try("%s/RCS/%s%s", filedir, filebase, "") ||
		    try("%s/%s%s", filedir, filebase, RCSSUFFIX)) {
			snprintf(buf, sizeof buf, CHECKOUT, filename);
			snprintf(lbuf, sizeof lbuf, RCSDIFF, filename);
			cs = "RCS";
		} else if (statfailed)
			fatal("can't find %s\n", filename);
		/*
		 * else we can't write to it but it's not under a version
		 * control system, so just proceed.
		 */
		if (cs) {
			if (!statfailed) {
				if ((filestat.st_mode & 0222) != 0)
					/* The owner can write to it.  */
					fatal("file %s seems to be locked "
					    "by somebody else under %s\n",
					    filename, cs);
				/*
				 * It might be checked out unlocked.  See if
				 * it's safe to check out the default version
				 * locked.
				 */
				if (verbose)
					say("Comparing file %s to default "
					    "%s version...\n",
					    filename, cs);
				if (system(lbuf))
					fatal("can't check out file %s: "
					    "differs from default %s version\n",
					    filename, cs);
			}
			if (verbose)
				say("Checking out file %s from %s...\n",
				    filename, cs);
			if (system(buf) || stat(filename, &filestat))
				fatal("can't check out file %s from %s\n",
				    filename, cs);
		}
	}
@


1.43.2.1
log
@Backport commit of 2015-07-26 14:32 by millert

Remove support for automatically checking files out of RCS.  The
behavior is confusing to users and even GNU patch no longer does
it by default.  OK krw@@ guenther@@
@
text
@d1 1
a1 1
/*	$OpenBSD: inp.c,v 1.43 2015/02/05 12:59:57 millert Exp $	*/
d135 1
a135 1
	char		*p, *s;
d165 61
a225 2
	if (statfailed)
		fatal("can't find %s\n", filename);
@


1.42
log
@Fix division by zero for files with long lines (> 1024) in Plan B mode
by supporting arbitrarily long lines just like Plan A does.

ok tedu
@
text
@d1 1
a1 1
/*	$OpenBSD: inp.c,v 1.41 2014/11/25 10:22:08 tobias Exp $	*/
a35 1
#include <limits.h>
d37 1
@


1.41
log
@Prevent null pointer dereference on empty input files when diff requires
a specific version.

ok millert
@
text
@d1 1
a1 1
/*	$OpenBSD: inp.c,v 1.40 2014/11/22 15:49:28 tobias Exp $	*/
d58 3
a60 2
static LINENUM	lines_per_buf;	/* how many lines per buffer */
static int	tireclen;	/* length of records in tmp file */
d337 2
a338 2
	size_t	i = 0, j, maxlen = 1;
	char	*p;
d347 15
a361 2
	while (fgets(buf, sizeof buf, ifp) != NULL) {
		if (revision != NULL && !found_revision && rev_in_string(buf))
d363 2
a364 2
		if ((i = strlen(buf)) > maxlen)
			maxlen = i;	/* find longest line */
d366 3
a368 3
	last_line_missing_eol = i > 0 && buf[i - 1] != '\n';
	if (last_line_missing_eol && maxlen == i)
		maxlen++;
a392 1
	lines_per_buf = BUFFERSIZE / maxlen;
d394 3
a396 1
	tibuf[0] = malloc(BUFFERSIZE + 1);
d399 1
a399 1
	tibuf[1] = malloc(BUFFERSIZE + 1);
d405 2
a406 1
			if (write(tifd, tibuf[0], BUFFERSIZE) < BUFFERSIZE)
d411 2
a412 1
				if (write(tifd, tibuf[0], BUFFERSIZE) < BUFFERSIZE)
d454 1
a454 1
			    BUFFERSIZE), SEEK_SET) < 0)
d457 2
a458 1
			if (read(tifd, tibuf[whichbuf], BUFFERSIZE) < 0)
@


1.40
log
@Remove SCCS support.  For this to work, we would need "get", which we don't
even have in ports.  XSI functionality of POSIX, therefore optional.

ok deraadt, schwarze, tedu
@
text
@d1 1
a1 1
/*	$OpenBSD: inp.c,v 1.39 2014/11/15 16:35:47 tobias Exp $	*/
d306 1
a306 1
		if (!rev_in_string(i_womp)) {
@


1.39
log
@Call munmap with the same size argument as mmap.

ok millert, otto
@
text
@d1 1
a1 1
/*	$OpenBSD: inp.c,v 1.38 2014/10/08 04:06:23 doug Exp $	*/
d166 1
a166 1
	/* For nonexistent or read-only files, look for RCS or SCCS versions.  */
a189 5
		} else if (try("%s/SCCS/%s%s", filedir, SCCSPREFIX, filebase) ||
		    try("%s/%s%s", filedir, SCCSPREFIX, filebase)) {
			snprintf(buf, sizeof buf, GET, s);
			snprintf(lbuf, sizeof lbuf, SCCSDIFF, s, filename);
			cs = "SCCS";
@


1.38
log
@userland reallocarray audit.

Replace malloc() and realloc() calls that may have integer overflow in the
multiplication of the size argument with reallocarray().

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: inp.c,v 1.37 2013/11/26 13:19:07 deraadt Exp $	*/
a74 1
		i_size = 0;
d81 1
@


1.37
log
@unsigned char casts for ctype
ok krw
@
text
@d1 1
a1 1
/*	$OpenBSD: inp.c,v 1.36 2012/04/10 14:46:34 ajacoutot Exp $	*/
d114 1
a114 1
	p = realloc(i_ptr, (new_size + 2) * sizeof(char *));
@


1.37.6.1
log
@Backport commit of 2014-11-22 15:49 by tobias:
Remove SCCS support.  For this to work, we would need "get", which we don't     even have in ports.  XSI functionality of POSIX, therefore optional.

ok deraadt, schwarze, tedu
----------------------------
Backport commit of 2015-07-26 14:32 by millert
Remove support for automatically checking files out of RCS.  The                behavior is confusing to users and even GNU patch no longer does
it by default.  OK krw@@ guenther@@
@
text
@d1 1
a1 1
/*	$OpenBSD: inp.c,v 1.37 2013/11/26 13:19:07 deraadt Exp $	*/
d134 1
a134 1
	char		*p, *s;
d164 66
a229 2
	if (statfailed)
		fatal("can't find %s\n", filename);
@


1.36
log
@Don't try to mmap a zero length file, from NetBSD.
Needed after the recent mmap(2) change.

ok ariane@@
@
text
@d1 1
a1 1
/*	$OpenBSD: inp.c,v 1.35 2009/10/27 23:59:41 deraadt Exp $	*/
d464 2
a465 1
	if (strnEQ(string, revision, patlen) && isspace(string[patlen]))
d468 2
a469 2
		if (isspace(*s) && strnEQ(s + 1, revision, patlen) &&
		    isspace(s[patlen + 1])) {
@


1.35
log
@rcsid[] and sccsid[] and copyright[] are essentially unmaintained (and
unmaintainable).  these days, people use source.  these id's do not provide
any benefit, and do hurt the small install media
(the 33,000 line diff is essentially mechanical)
ok with the idea millert, ok dms
@
text
@d1 1
a1 1
/*	$OpenBSD: inp.c,v 1.34 2006/03/11 19:41:30 otto Exp $	*/
d246 9
a254 3
	i_womp = mmap(NULL, i_size, PROT_READ, MAP_PRIVATE, ifd, 0);
	if (i_womp == MAP_FAILED) {
		perror("mmap failed");
a255 2
		close(ifd);
		return false;
@


1.34
log
@type police and assorted cleanup. From Lionel Fourquaux; ok ray@@
@
text
@d1 1
a1 1
/*	$OpenBSD: inp.c,v 1.33 2005/11/14 19:54:10 miod Exp $	*/
a27 4

#ifndef lint
static const char rcsid[] = "$OpenBSD: inp.c,v 1.33 2005/11/14 19:54:10 miod Exp $";
#endif /* not lint */
@


1.33
log
@constuct -> construct
@
text
@d1 1
a1 1
/*	$OpenBSD: inp.c,v 1.32 2004/08/05 21:47:24 deraadt Exp $	*/
d30 1
a30 1
static const char rcsid[] = "$OpenBSD: inp.c,v 1.32 2004/08/05 21:47:24 deraadt Exp $";
a138 1
	LINENUM		iline;
d142 1
a142 1
	size_t		lines_allocated;
d341 1
a341 1
	int	i = 0, j, maxlen = 1;
d441 3
a443 2
			lseek(tifd, (off_t) (baseline / lines_per_buf *
			    BUFFERSIZE), SEEK_SET);
d459 1
a459 1
	int		patlen;
@


1.32
log
@spacing
@
text
@d1 1
a1 1
/*	$OpenBSD: inp.c,v 1.31 2003/12/08 22:44:18 mickey Exp $	*/
d30 1
a30 1
static const char rcsid[] = "$OpenBSD: inp.c,v 1.31 2003/12/08 22:44:18 mickey Exp $";
d98 1
a98 1
/* Constuct the line index, somehow or other. */
@


1.31
log
@MAP_FILE is the default and MAP_PRIVATE has to be given or produces evil warnings in debug kernel
@
text
@d1 1
a1 1
/*	$OpenBSD: inp.c,v 1.30 2003/11/21 21:25:59 mickey Exp $	*/
d30 1
a30 1
static const char     rcsid[] = "$OpenBSD: inp.c,v 1.30 2003/11/21 21:25:59 mickey Exp $";
d268 1
a268 1
	if (!reallocate_lines(&lines_allocated)) 
d361 1
a361 1
		
@


1.30
log
@madvise(sequential) the mmap()ed file and plug an fd leak on mmap() failure; millert@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: inp.c,v 1.29 2003/09/28 07:55:19 otto Exp $	*/
d30 1
a30 1
static const char     rcsid[] = "$OpenBSD: inp.c,v 1.29 2003/09/28 07:55:19 otto Exp $";
d251 1
a251 1
	i_womp = mmap(NULL, i_size, PROT_READ, MAP_FILE, ifd, 0);
@


1.29
log
@realloc(3) cleanup.

ok cloder@@ tedu@@
@
text
@d1 1
a1 1
/*	$OpenBSD: inp.c,v 1.28 2003/08/15 08:00:51 otto Exp $	*/
d30 1
a30 1
static const char     rcsid[] = "$OpenBSD: inp.c,v 1.28 2003/08/15 08:00:51 otto Exp $";
d255 1
d260 2
@


1.28
log
@Add license from patch.c to original source files missing a license.

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: inp.c,v 1.27 2003/08/12 21:13:10 otto Exp $	*/
d30 1
a30 1
static const char     rcsid[] = "$OpenBSD: inp.c,v 1.27 2003/08/12 21:13:10 otto Exp $";
d114 2
a115 1
	char **p;
d117 2
a118 2
	*lines_allocated = *lines_allocated * 3 / 2;
	p = realloc(i_ptr, (*lines_allocated + 2) * sizeof(char *));
d124 1
d127 1
@


1.27
log
@Fix no newline at end of file case for Plan B.

ok millert@@ tedu@@
@
text
@d1 27
a27 1
/*	$OpenBSD: inp.c,v 1.26 2003/08/10 21:28:48 otto Exp $	*/
d30 1
a30 1
static const char     rcsid[] = "$OpenBSD: inp.c,v 1.26 2003/08/10 21:28:48 otto Exp $";
@


1.26
log
@Do not add an extra newline at the end if the last line of the input
file contains no newline and the diff does not touch the last line.
Contributions from millert@@.

ok millert@@ tedu@@
@
text
@d1 1
a1 1
/*	$OpenBSD: inp.c,v 1.25 2003/08/08 07:53:19 otto Exp $	*/
d4 1
a4 1
static const char     rcsid[] = "$OpenBSD: inp.c,v 1.25 2003/08/08 07:53:19 otto Exp $";
d310 2
a311 1
	int	i = 0, maxlen = 1;
d326 4
d362 2
a363 1
		if (!(i % lines_per_buf))	/* new block */
d366 1
a366 2
		if (fgets(tibuf[0] + maxlen * (i % lines_per_buf),
		    maxlen + 1, ifp) == NULL) {
d368 1
a368 1
			if (i % lines_per_buf)
d373 4
@


1.25
log
@Avoid scanning the input file twice.

ok millert@@ tedu@@
@
text
@d1 1
a1 1
/*	$OpenBSD: inp.c,v 1.24 2003/08/05 18:20:33 deraadt Exp $	*/
d4 1
a4 1
static const char     rcsid[] = "$OpenBSD: inp.c,v 1.24 2003/08/05 18:20:33 deraadt Exp $";
d255 1
d272 2
a273 1
	}
@


1.24
log
@spacing
@
text
@d1 1
a1 1
/*	$OpenBSD: inp.c,v 1.23 2003/08/05 18:13:43 otto Exp $	*/
d4 1
a4 1
static const char     rcsid[] = "$OpenBSD: inp.c,v 1.23 2003/08/05 18:13:43 otto Exp $";
d40 1
d85 18
d114 1
d231 4
a234 2
	/* count the lines in the buffer so we know how many pointers we need */
	iline = 0;
d236 1
a236 14
	/* test for NUL too, to maintain the behavior of the original code */
	for (i = 0; i < i_size && i_womp[i] != '\0'; i++) {
		if (i_womp[i] == '\n')
			iline++;
	}
	if (i_size > 0 && i_womp[i_size - 1] != '\n')
		iline++;


	i_ptr = (char **) malloc((iline + 2) * sizeof(char *));

	if (i_ptr == NULL) {	/* shucks, it was a near thing */
		munmap(i_womp, i_size);
		i_womp = NULL;
a237 1
	}
d244 8
a251 2
		if (*s == '\n')
			i_ptr[++iline] = s + 1;	/* these are NOT NUL terminated */
@


1.23
log
@- Use mmap(2) instead of malloc(3) and read(2) to get an image of the input
file into memory. Some suggestions by tedu@@.
- Add a debug option to force using Plan B.

ok millert@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: inp.c,v 1.22 2003/08/01 20:30:48 otto Exp $	*/
d4 1
a4 1
static const char     rcsid[] = "$OpenBSD: inp.c,v 1.22 2003/08/01 20:30:48 otto Exp $";
d197 1
a197 1
 		return false;
d217 1
a217 1
 			iline++;
d225 1
a225 1
 	if (i_ptr == NULL) {	/* shucks, it was a near thing */
d228 2
a229 2
 		return false;
 	}
d251 1
a251 1
	
@


1.22
log
@- use stdbool.h instead of roll-your-own booleans
- fix some -Wall warnings
- fix asserts: in some cases remove them, in other cases they have
become Internal errors or detection of malformed patch files.
- fix some free() related code

ok millert@@ tedu@@
@
text
@d1 1
a1 1
/*	$OpenBSD: inp.c,v 1.21 2003/07/31 14:10:21 otto Exp $	*/
d4 1
a4 1
static const char     rcsid[] = "$OpenBSD: inp.c,v 1.21 2003/07/31 14:10:21 otto Exp $";
d10 1
d15 1
a53 2
		free(i_womp);
		i_womp = NULL;
d55 4
d90 1
a90 1
	char		*s, lbuf[MAXLINELEN];
d93 7
d195 4
a198 5
	if (i_size > SIZE_MAX - 2)
		fatal("block too large to allocate");
	i_womp = malloc((size_t)(i_size + 2));
	if (i_womp == NULL)
		return false;
d202 5
a206 4
	if (read(ifd, i_womp, (size_t) i_size) != i_size) {
		close(ifd);	/* probably means i_size > 15 or 16 bits worth */
		free(i_womp);	/* at this point it doesn't matter if i_womp was */
		return false;	/* undersized. */
a209 3
	if (i_size && i_womp[i_size - 1] != '\n')
		i_womp[i_size++] = '\n';
	i_womp[i_size] = '\0';
d212 1
d214 4
a217 4
	iline = 0;
	for (s = i_womp; *s; s++) {
		if (*s == '\n')
			iline++;
d219 3
d225 6
a230 4
	if (i_ptr == NULL) {	/* shucks, it was a near thing */
		free(i_womp);
		return false;
	}
a231 1

d234 2
a235 1
	for (s = i_womp; *s; s++) {
d239 20
@


1.21
log
@Print a maximum of one invalid line number warning per patch in a patch file.
Thanks to espie@@ for spotting the problem.

ok millert@@ henning@@ espie@@
@
text
@d1 1
a1 1
/*	$OpenBSD: inp.c,v 1.20 2003/07/28 19:15:34 deraadt Exp $	*/
d4 1
a4 1
static const char     rcsid[] = "$OpenBSD: inp.c,v 1.20 2003/07/28 19:15:34 deraadt Exp $";
d56 1
a56 1
		using_plan_a = TRUE;	/* maybe the next one is smaller */
d91 1
a91 1
		return FALSE;
d104 2
a105 2
			return TRUE;
		makedirs(filename, TRUE);
d181 2
a182 2
		out_of_mem = FALSE;
		return FALSE;	/* force plan b because plan a bombed */
d188 1
a188 1
		return FALSE;
d195 1
a195 1
		return FALSE;	/* undersized. */
d215 1
a215 1
		return FALSE;
d251 1
a251 1
	return TRUE;		/* plan a will work */
d263 1
a263 1
	using_plan_a = FALSE;
d271 1
a271 1
			found_revision = TRUE;
d334 1
a334 1
			warn_on_invalid_line = FALSE;
d371 1
a371 1
		return TRUE;
d374 1
a374 1
		return TRUE;
d378 1
a378 1
			return TRUE;
d381 1
a381 1
	return FALSE;
@


1.20
log
@minor knf and cleanups; otto ok
@
text
@d1 1
a1 1
/*	$OpenBSD: inp.c,v 1.19 2003/07/28 18:35:36 otto Exp $	*/
d4 1
a4 1
static const char     rcsid[] = "$OpenBSD: inp.c,v 1.19 2003/07/28 18:35:36 otto Exp $";
d332 4
a335 1
		say("No such line %ld in input file, ignoring\n", line);
@


1.19
log
@More cleanup: sprinkled some const, removed ugly EXTERN/INTERN.h,
some rewriting of code to make it more readable and more KNF.

ok millert@@ tedu@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: inp.c,v 1.18 2003/07/23 07:31:21 otto Exp $	*/
d4 1
a4 1
static const char     rcsid[] = "$OpenBSD: inp.c,v 1.18 2003/07/23 07:31:21 otto Exp $";
d88 1
a88 1
	struct stat 	filestat;
d223 1
a223 2
			i_ptr[++iline] = s + 1;	/* these are NOT null
						 * terminated */
@


1.18
log
@New version of invalid line number fix. Passes patch(1) regressions.

ok millert@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: inp.c,v 1.17 2003/07/22 17:52:20 deraadt Exp $	*/
d4 1
a4 1
static const char     rcsid[] = "$OpenBSD: inp.c,v 1.17 2003/07/22 17:52:20 deraadt Exp $";
d14 1
a18 1
#include "EXTERN.h"
a21 1
#include "INTERN.h"
d37 6
a42 3
static bool	rev_in_string(char *);
static bool	plan_a(char *);	/* returns false if insufficient memory */
static void	plan_b(char *);
d70 1
a70 1
scan_input(char *filename)
d83 1
a83 1
plan_a(char *filename)
d85 4
a88 3
	int	ifd, statfailed;
	char	*s, lbuf[MAXLINELEN];
	LINENUM	iline;
d90 1
a90 1
	if (!filename || *filename == '\0')
d116 1
a116 1
	    ((filestat.st_mode & 0022) == 0 && filestat.st_uid != myuid)) {
d214 1
a214 1
		free((char *) i_womp);
d258 1
a258 1
plan_b(char *filename)
d363 1
a363 1
rev_in_string(char *string)
d365 2
a366 2
	char	*s;
	int	patlen;
@


1.17
log
@just about nothing
@
text
@d1 1
a1 1
/*	$OpenBSD: inp.c,v 1.16 2003/07/22 17:18:49 otto Exp $	*/
d4 1
a4 1
static const char     rcsid[] = "$OpenBSD: inp.c,v 1.16 2003/07/22 17:18:49 otto Exp $";
d331 1
a331 1
		return "";
@


1.16
log
@More cleanup.
ok millert@@ tedu@@
@
text
@d1 1
a1 1
/*	$OpenBSD: inp.c,v 1.15 2003/07/21 21:01:45 otto Exp $	*/
d4 2
a5 2
static const char     rcsid[] = "$OpenBSD: inp.c,v 1.15 2003/07/21 21:01:45 otto Exp $";
#endif				/* not lint */
@


1.15
log
@Back out invalid line number fix. It core dumps in some cases. Problem found by
marc@@.
ok henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: inp.c,v 1.14 2003/07/21 14:32:21 deraadt Exp $	*/
d4 1
a4 1
static char     rcsid[] = "$OpenBSD: inp.c,v 1.14 2003/07/21 14:32:21 deraadt Exp $";
d7 11
a24 1
extern bool     check_only;
d38 3
a40 1
void		re_input(void);
d49 4
a52 8
#ifndef lint
		if (i_ptr != Null(char **))
			free((char *) i_ptr);
#endif
		if (i_womp != Nullch)
			free(i_womp);
		i_womp = Nullch;
		i_ptr = Null(char **);
d59 1
a59 1
		tibuf[0] = tibuf[1] = Nullch;
d80 1
a80 1
bool
d114 1
a114 1
		char	*cs = Nullch, *filebase, *filedir;
d181 4
a184 2
	i_womp = malloc(i_size + 2);
	if (i_womp == Nullch)
d188 1
a188 1
#ifndef lint
d194 1
a194 1
#endif
d207 1
a207 3
#ifdef lint
	i_ptr = Null(char **);
#else
d209 2
a210 2
#endif
	if (i_ptr == Null(char **)) {	/* shucks, it was a near thing */
d227 1
a227 1
	if (revision != Nullch) {
d254 1
a254 1
void
d259 1
a259 1
	bool	found_revision = (revision == Nullch);
d262 1
a262 1
	if ((ifp = fopen(filename, "r")) == Nullfp)
d267 2
a268 2
	while (fgets(buf, sizeof buf, ifp) != Nullch) {
		if (revision != Nullch && !found_revision && rev_in_string(buf))
d273 1
a273 1
	if (revision != Nullch) {
d295 1
a295 1
	fseek(ifp, 0L, 0);	/* rewind file */
d299 1
a299 1
	if (tibuf[0] == Nullch)
d302 1
a302 1
	if (tibuf[1] == Nullch)
d309 1
a309 1
		    maxlen + 1, ifp) == Nullch) {
d345 1
a345 1
#ifndef lint			/* complains of long accuracy */
d347 2
a348 2
			    BUFFERSIZE), 0);
#endif
d359 1
a359 1
bool
d365 1
a365 1
	if (revision == Nullch)
@


1.14
log
@fix header
@
text
@d1 1
a1 1
/*	$OpenBSD: inp.c,v 1.13 2003/07/21 14:30:31 deraadt Exp $	*/
d4 1
a4 1
static char     rcsid[] = "$OpenBSD: inp.c,v 1.13 2003/07/21 14:30:31 deraadt Exp $";
d323 1
a323 1
		return NULL;
@


1.13
log
@remove a bit more junk
@
text
@d1 1
a1 1
/* $OpenBSD: inp.c,v 1.12 2003/07/21 14:00:41 deraadt Exp $	 */
d4 1
a4 1
static char     rcsid[] = "$OpenBSD: inp.c,v 1.12 2003/07/21 14:00:41 deraadt Exp $";
@


1.12
log
@knf and other cleanup; ok otto
@
text
@d1 1
a1 1
/* $OpenBSD: inp.c,v 1.11 2003/07/18 02:00:09 deraadt Exp $	 */
d4 1
a4 1
static char     rcsid[] = "$OpenBSD: inp.c,v 1.11 2003/07/18 02:00:09 deraadt Exp $";
d173 1
a173 7
#ifdef lint
	i_womp = Nullch;
#else
	i_womp = malloc((MEM) (i_size + 2));	/* lint says this may alloc
						 * less than */
	/* i_size, but that's okay, I think. */
#endif
d200 1
a200 1
	i_ptr = (char **) malloc((MEM) ((iline + 2) * sizeof(char *)));
d290 1
a290 1
	tibuf[0] = malloc((MEM) (BUFFERSIZE + 1));
d293 1
a293 1
	tibuf[1] = malloc((MEM) (BUFFERSIZE + 1));
@


1.11
log
@remove junk; ok otto tedu
@
text
@d1 1
a1 1
/*	$OpenBSD: inp.c,v 1.10 2003/07/16 16:06:53 otto Exp $	*/
d4 2
a5 2
static char rcsid[] = "$OpenBSD: inp.c,v 1.10 2003/07/16 16:06:53 otto Exp $";
#endif /* not lint */
d14 1
a14 1
extern bool check_only;
d18 9
a26 9
static off_t i_size;			/* size of the input file */
static char *i_womp;			/* plan a buffer for entire file */
static char **i_ptr;			/* pointers to lines in i_womp */

static int tifd = -1;			/* plan b virtual string array */
static char *tibuf[2];			/* plan b buffers */
static LINENUM tiline[2] = {-1, -1};	/* 1st line in each buffer */
static LINENUM lines_per_buf;		/* how many lines per buffer */
static int tireclen;			/* length of records in tmp file */
d28 1
a28 1
void re_input(void);
d35 2
a36 2
    if (using_plan_a) {
	i_size = 0;
d38 2
a39 2
	if (i_ptr != Null(char**))
	    free((char *)i_ptr);
d41 14
a54 15
	if (i_womp != Nullch)
	    free(i_womp);
	i_womp = Nullch;
	i_ptr = Null(char **);
    }
    else {
	using_plan_a = TRUE;		/* maybe the next one is smaller */
	close(tifd);
	tifd = -1;
	free(tibuf[0]);
	free(tibuf[1]);
	tibuf[0] = tibuf[1] = Nullch;
	tiline[0] = tiline[1] = -1;
	tireclen = 0;
    }
d60 1
a60 2
scan_input(filename)
char *filename;
d62 6
a67 6
    if (!plan_a(filename))
	plan_b(filename);
    if (verbose) {
	say("Patching file %s using Plan %s...\n", filename,
	  (using_plan_a ? "A" : "B") );
    }
d73 1
a73 2
plan_a(filename)
char *filename;
d75 3
a77 4
    int ifd, statfailed;
    char *s;
    LINENUM iline;
    char lbuf[MAXLINELEN];
d79 2
a80 2
    if (!filename || *filename == '\0')
	return FALSE;
a81 12
    statfailed = stat(filename, &filestat);
    if (statfailed && ok_to_create_file) {
	if (verbose)
	    say("(Creating file %s...)\n",filename);
	    /* in check_patch case, we still display `Creating file' even
	       though we're not. The rule is that -C should be as similar
	       to normal patch behavior as possible
	     */
	if (check_only)
	    return TRUE;
	makedirs(filename, TRUE);
	close(creat(filename, 0666));
d83 1
a83 43
    }
    if (statfailed && check_only)
        fatal("%s not found, -C mode, can't probe further\n", filename);
    /* For nonexistent or read-only files, look for RCS or SCCS versions.  */
    if (statfailed
	/* No one can write to it.  */
	|| (filestat.st_mode & 0222) == 0
	/* I can't write to it.  */
	|| ((filestat.st_mode & 0022) == 0 && filestat.st_uid != myuid)) {
	struct stat cstat;
	char *cs = Nullch;
	char *filebase, *filedir;

	filebase = basename(filename);
	filedir = dirname(filename);

	/* Leave room in lbuf for the diff command.  */
	s = lbuf + 20;

#define try(f, a1, a2, a3) (snprintf(s, sizeof lbuf - 20, f, a1, a2, a3), stat(s, &cstat) == 0)
	if (   try("%s/RCS/%s%s", filedir, filebase, RCSSUFFIX)
	    || try("%s/RCS/%s%s", filedir, filebase,         "")
	    || try(    "%s/%s%s", filedir, filebase, RCSSUFFIX)) {
	    snprintf(buf, sizeof buf, CHECKOUT, filename);
	    snprintf(lbuf, sizeof lbuf, RCSDIFF, filename);
	    cs = "RCS";
	} else if (   try("%s/SCCS/%s%s", filedir, SCCSPREFIX, filebase)
		   || try(     "%s/%s%s", filedir, SCCSPREFIX, filebase)) {
	    snprintf(buf, sizeof buf, GET, s);
	    snprintf(lbuf, sizeof lbuf, SCCSDIFF, s, filename);
	    cs = "SCCS";
	} else if (statfailed)
	    fatal("can't find %s\n", filename);
	/* else we can't write to it but it's not under a version
	   control system, so just proceed.  */
	if (cs) {
	    if (!statfailed) {
		if ((filestat.st_mode & 0222) != 0)
		    /* The owner can write to it.  */
		    fatal("file %s seems to be locked by somebody else under %s\n",
			   filename, cs);
		/* It might be checked out unlocked.  See if it's safe to
		   check out the default version locked.  */
d85 88
a172 21
		    say("Comparing file %s to default %s version...\n",
			 filename, cs);
		if (system(lbuf))
		    fatal("can't check out file %s: differs from default %s version\n",
			   filename, cs);
	    }
	    if (verbose)
		say("Checking out file %s from %s...\n", filename, cs);
	    if (system(buf) || stat(filename, &filestat))
		fatal("can't check out file %s from %s\n", filename, cs);
	}
    }
    filemode = filestat.st_mode;
    if (!S_ISREG(filemode))
	fatal("%s is not a normal file--can't patch\n", filename);
    i_size = filestat.st_size;
    if (out_of_mem) {
	set_hunkmax();		/* make sure dynamic arrays are allocated */
	out_of_mem = FALSE;
	return FALSE;			/* force plan b because plan a bombed */
    }
d174 1
a174 1
    i_womp = Nullch;
d176 3
a178 2
    i_womp = malloc((MEM)(i_size+2));	/* lint says this may alloc less than */
					/* i_size, but that's okay, I think. */
d180 4
a183 4
    if (i_womp == Nullch)
	return FALSE;
    if ((ifd = open(filename, O_RDONLY)) < 0)
	pfatal("can't open file %s", filename);
d185 5
a189 5
    if (read(ifd, i_womp, (size_t)i_size) != i_size) {
	close(ifd);	/* probably means i_size > 15 or 16 bits worth */
	free(i_womp);	/* at this point it doesn't matter if i_womp was */
	return FALSE;	/*   undersized. */
    }
d191 12
a202 12
    close(ifd);
    if (i_size && i_womp[i_size-1] != '\n')
	i_womp[i_size++] = '\n';
    i_womp[i_size] = '\0';

    /* count the lines in the buffer so we know how many pointers we need */

    iline = 0;
    for (s=i_womp; *s; s++) {
	if (*s == '\n')
	    iline++;
    }
d204 1
a204 1
    i_ptr = Null(char**);
d206 1
a206 1
    i_ptr = (char **)malloc((MEM)((iline + 2) * sizeof(char *)));
d208 14
a221 4
    if (i_ptr == Null(char **)) {	/* shucks, it was a near thing */
	free((char *)i_womp);
	return FALSE;
    }
d223 1
a223 1
    /* now scan the buffer and build pointer array */
d225 23
a247 35
    iline = 1;
    i_ptr[iline] = i_womp;
    for (s=i_womp; *s; s++) {
	if (*s == '\n')
	    i_ptr[++iline] = s+1;	/* these are NOT null terminated */
    }
    input_lines = iline - 1;

    /* now check for revision, if any */

    if (revision != Nullch) {
	if (!rev_in_string(i_womp)) {
	    if (force) {
		if (verbose)
		    say(
"Warning: this file doesn't appear to be the %s version--patching anyway.\n",
			revision);
	    }
	    else if (batch) {
		fatal(
"this file doesn't appear to be the %s version--aborting.\n", revision);
	    }
	    else {
		ask(
"This file doesn't appear to be the %s version--patch anyway? [n] ",
		    revision);
	    if (*buf != 'y')
		fatal("aborted\n");
	    }
	}
	else if (verbose)
	    say("Good.  This file appears to be the %s version.\n",
		revision);
    }
    return TRUE;			/* plan a will work */
d253 1
a253 2
plan_b(filename)
char *filename;
d255 64
a318 68
    FILE *ifp;
    int i = 0;
    int maxlen = 1;
    bool found_revision = (revision == Nullch);

    using_plan_a = FALSE;
    if ((ifp = fopen(filename, "r")) == Nullfp)
	pfatal("can't open file %s", filename);
    (void) unlink(TMPINNAME);
    if ((tifd = open(TMPINNAME, O_EXCL|O_CREAT|O_WRONLY, 0666)) < 0)
	pfatal("can't open file %s", TMPINNAME);
    while (fgets(buf, sizeof buf, ifp) != Nullch) {
	if (revision != Nullch && !found_revision && rev_in_string(buf))
	    found_revision = TRUE;
	if ((i = strlen(buf)) > maxlen)
	    maxlen = i;			/* find longest line */
    }
    if (revision != Nullch) {
	if (!found_revision) {
	    if (force) {
		if (verbose)
		    say(
"Warning: this file doesn't appear to be the %s version--patching anyway.\n",
			revision);
	    }
	    else if (batch) {
		fatal(
"this file doesn't appear to be the %s version--aborting.\n", revision);
	    }
	    else {
		ask(
"This file doesn't appear to be the %s version--patch anyway? [n] ",
		    revision);
		if (*buf != 'y')
		    fatal("aborted\n");
	    }
	}
	else if (verbose)
	    say("Good.  This file appears to be the %s version.\n",
		revision);
    }
    fseek(ifp, 0L, 0);		/* rewind file */
    lines_per_buf = BUFFERSIZE / maxlen;
    tireclen = maxlen;
    tibuf[0] = malloc((MEM)(BUFFERSIZE + 1));
    if (tibuf[0] == Nullch)
	fatal("out of memory\n");
    tibuf[1] = malloc((MEM)(BUFFERSIZE + 1));
    if (tibuf[1] == Nullch)
	fatal("out of memory\n");
    for (i=1; ; i++) {
	if (! (i % lines_per_buf))	/* new block */
	    if (write(tifd, tibuf[0], BUFFERSIZE) < BUFFERSIZE)
		pfatal("can't write temp file");
	if (fgets(tibuf[0] + maxlen * (i%lines_per_buf), maxlen + 1, ifp)
	  == Nullch) {
	    input_lines = i - 1;
	    if (i % lines_per_buf)
		if (write(tifd, tibuf[0], BUFFERSIZE) < BUFFERSIZE)
		    pfatal("can't write temp file");
	    break;
	}
    }
    fclose(ifp);
    close(tifd);
    if ((tifd = open(TMPINNAME, O_RDONLY)) < 0) {
	pfatal("can't reopen file %s", TMPINNAME);
    }
d321 3
a323 2
/* Fetch a line from the input file, \n terminated, not necessarily \0. */

d325 1
a325 3
ifetch(line,whichbuf)
LINENUM line;
int whichbuf;				/* ignored when file in memory */
d327 6
a332 14
    if (line < 1 || line > input_lines) {
	say("No such line %ld in input file, ignoring\n", line);
	return NULL;
    }
    if (using_plan_a)
	return i_ptr[line];
    else {
	LINENUM offline = line % lines_per_buf;
	LINENUM baseline = line - offline;

	if (tiline[0] == baseline)
	    whichbuf = 0;
	else if (tiline[1] == baseline)
	    whichbuf = 1;
d334 12
a345 3
	    tiline[whichbuf] = baseline;
#ifndef lint		/* complains of long accuracy */
	    lseek(tifd, (off_t)(baseline / lines_per_buf * BUFFERSIZE), 0);
d347 4
a350 2
	    if (read(tifd, tibuf[whichbuf], BUFFERSIZE) < 0)
		pfatal("error reading tmp file %s", TMPINNAME);
a351 2
	return tibuf[whichbuf] + (tireclen*offline);
    }
d354 3
a356 2
/* True if the string argument contains the revision number we want. */

d358 1
a358 2
rev_in_string(string)
char *string;
d360 2
a361 2
    char *s;
    int patlen;
d363 10
a372 9
    if (revision == Nullch)
	return TRUE;
    patlen = strlen(revision);
    if (strnEQ(string,revision,patlen) && isspace(string[patlen]))
	return TRUE;
    for (s = string; *s; s++) {
	if (isspace(*s) && strnEQ(s+1, revision, patlen) &&
		isspace(s[patlen+1] )) {
	    return TRUE;
d374 1
a374 2
    }
    return FALSE;
@


1.10
log
@Do not produce garbage if the patch file contains invalid line numbers.
ok millert@@ tedu@@
@
text
@d1 1
a1 1
/*	$OpenBSD: inp.c,v 1.9 2002/07/04 04:22:48 deraadt Exp $	*/
d4 1
a4 1
static char rcsid[] = "$OpenBSD: inp.c,v 1.9 2002/07/04 04:22:48 deraadt Exp $";
d28 2
d33 1
a33 1
re_input()
d48 1
a48 1
	Close(tifd);
d67 1
a67 1
	say3("Patching file %s using Plan %s...\n", filename,
d79 2
a80 2
    Reg1 char *s;
    Reg2 LINENUM iline;
d89 1
a89 1
	    say2("(Creating file %s...)\n",filename);
d94 1
a94 1
	if (check_only) 
d101 1
a101 1
        fatal2("%s not found, -C mode, can't probe further\n", filename);
d118 1
a118 1
#define try(f, a1, a2, a3) (Snprintf(s, sizeof lbuf - 20, f, a1, a2, a3), stat(s, &cstat) == 0)
d122 2
a123 2
	    Snprintf(buf, sizeof buf, CHECKOUT, filename);
	    Snprintf(lbuf, sizeof lbuf, RCSDIFF, filename);
d127 2
a128 2
	    Snprintf(buf, sizeof buf, GET, s);
	    Snprintf(lbuf, sizeof lbuf, SCCSDIFF, s, filename);
d131 1
a131 1
	    fatal2("can't find %s\n", filename);
d138 1
a138 1
		    fatal3("file %s seems to be locked by somebody else under %s\n",
d143 1
a143 1
		    say3("Comparing file %s to default %s version...\n",
d146 1
a146 1
		    fatal3("can't check out file %s: differs from default %s version\n",
d150 1
a150 1
		say3("Checking out file %s from %s...\n", filename, cs);
d152 1
a152 1
		fatal3("can't check out file %s from %s\n", filename, cs);
d157 1
a157 1
	fatal2("%s is not a normal file--can't patch\n", filename);
d173 1
a173 1
	pfatal2("can't open file %s", filename);
d176 1
a176 1
	Close(ifd);	/* probably means i_size > 15 or 16 bits worth */
d181 1
a181 1
    Close(ifd);
d202 1
a202 1
    
d215 1
a215 1
    if (revision != Nullch) { 
d219 1
a219 1
		    say2(
d224 1
a224 1
		fatal2(
d228 1
a228 1
		ask2(
d232 1
a232 1
		fatal1("aborted\n");
d236 1
a236 1
	    say2("Good.  This file appears to be the %s version.\n",
d248 4
a251 4
    Reg3 FILE *ifp;
    Reg1 int i = 0;
    Reg2 int maxlen = 1;
    Reg4 bool found_revision = (revision == Nullch);
d255 1
a255 1
	pfatal2("can't open file %s", filename);
d258 1
a258 1
	pfatal2("can't open file %s", TMPINNAME);
d269 1
a269 1
		    say2(
d274 1
a274 1
		fatal2(
d278 1
a278 1
		ask2(
d282 1
a282 1
		    fatal1("aborted\n");
d286 1
a286 1
	    say2("Good.  This file appears to be the %s version.\n",
d289 1
a289 1
    Fseek(ifp, 0L, 0);		/* rewind file */
d294 1
a294 1
	fatal1("out of memory\n");
d297 1
a297 1
	fatal1("out of memory\n");
d301 1
a301 1
		pfatal1("can't write temp file");
d307 1
a307 1
		    pfatal1("can't write temp file");
d311 2
a312 2
    Fclose(ifp);
    Close(tifd);
d314 1
a314 1
	pfatal2("can't reopen file %s", TMPINNAME);
d322 1
a322 1
Reg1 LINENUM line;
d326 1
a326 1
	say2("No such line %ld in input file, ignoring\n", line);
d342 1
a342 1
	    Lseek(tifd, (off_t)(baseline / lines_per_buf * BUFFERSIZE), 0);
d345 1
a345 1
		pfatal2("error reading tmp file %s", TMPINNAME);
d357 2
a358 2
    Reg1 char *s;
    Reg2 int patlen;
d366 1
a366 1
	if (isspace(*s) && strnEQ(s+1, revision, patlen) && 
@


1.9
log
@4 unchecked mallocs; cloder@@acm.org
@
text
@d1 1
a1 1
/*	$OpenBSD: inp.c,v 1.8 1999/01/03 05:33:48 millert Exp $	*/
d4 1
a4 1
static char rcsid[] = "$OpenBSD: inp.c,v 1.8 1999/01/03 05:33:48 millert Exp $";
d323 4
a326 2
    if (line < 1 || line > input_lines)
	return "";
@


1.8
log
@Use libc basename(3) and dirname(3) instead of defining our own.  Also clean up some nasty assumptions that basename() returns a pointer that lies within its argument
@
text
@d1 1
a1 1
/*	$OpenBSD: inp.c,v 1.7 1998/11/25 00:30:25 espie Exp $	*/
d4 1
a4 1
static char rcsid[] = "$OpenBSD: inp.c,v 1.7 1998/11/25 00:30:25 espie Exp $";
d291 2
@


1.7
log
@add -C
@
text
@d1 1
a1 1
/*	$OpenBSD: inp.c,v 1.6 1997/09/22 05:45:26 millert Exp $	*/
d4 1
a4 1
static char rcsid[] = "$OpenBSD: inp.c,v 1.6 1997/09/22 05:45:26 millert Exp $";
d81 3
d108 1
a108 2
	char *filebase;
	int pathlen;
d111 1
a111 1
	pathlen = filebase - filename;
d113 1
a113 2
	/* Put any leading path into `s'.
	   Leave room in lbuf for the diff command.  */
a114 1
	strncpy(s, filename, pathlen);
d116 4
a119 4
#define try(f, a1, a2) (Snprintf(s + pathlen, sizeof lbuf - (s + pathlen - lbuf), f, a1, a2), stat(s, &cstat) == 0)
	if (   try("RCS/%s%s", filebase, RCSSUFFIX)
	    || try("RCS/%s"  , filebase,         0)
	    || try(    "%s%s", filebase, RCSSUFFIX)) {
d123 2
a124 2
	} else if (   try("SCCS/%s%s", SCCSPREFIX, filebase)
		   || try(     "%s%s", SCCSPREFIX, filebase)) {
@


1.6
log
@Start of -Wall and cleaning up icky bits.
@
text
@d1 1
a1 1
/*	$OpenBSD: inp.c,v 1.5 1996/09/24 04:19:26 millert Exp $	*/
d4 1
a4 1
static char rcsid[] = "$OpenBSD: inp.c,v 1.5 1996/09/24 04:19:26 millert Exp $";
d14 2
d85 6
d95 2
@


1.5
log
@sprintf -> snprintf except where guaranteed safe.
@
text
@d1 1
a1 1
/*	$OpenBSD: inp.c,v 1.4 1996/07/01 20:40:07 deraadt Exp $	*/
d4 1
a4 1
static char rcsid[] = "$OpenBSD: inp.c,v 1.4 1996/07/01 20:40:07 deraadt Exp $";
d16 1
a16 1
static long i_size;			/* size of the input file */
d160 1
a160 1
    if ((ifd = open(filename, 0)) < 0)
d163 1
a163 1
    if (read(ifd, i_womp, (int)i_size) != i_size) {
d299 1
a299 1
    if ((tifd = open(TMPINNAME, 0)) < 0) {
d326 1
a326 1
	    Lseek(tifd, (long)baseline / lines_per_buf * BUFFERSIZE, 0);
@


1.4
log
@undo mktemp cleanup until i get it right
@
text
@d1 1
a1 1
/*	$OpenBSD: inp.c,v 1.2 1996/06/10 11:21:28 niklas Exp $	*/
d4 1
a4 1
static char rcsid[] = "$OpenBSD: inp.c,v 1.2 1996/06/10 11:21:28 niklas Exp $";
d106 1
a106 1
#define try(f, a1, a2) (Sprintf(s + pathlen, f, a1, a2), stat(s, &cstat) == 0)
d110 2
a111 2
	    Sprintf(buf, CHECKOUT, filename);
	    Sprintf(lbuf, RCSDIFF, filename);
d115 2
a116 2
	    Sprintf(buf, GET, s);
	    Sprintf(lbuf, SCCSDIFF, s, filename);
@


1.3
log
@mktemp w/ open & fdopen
@
text
@d244 1
@


1.2
log
@Support the long options that FSF's patch version has.  $OpenBSD$ added
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d4 1
a4 1
static char rcsid[] = "$OpenBSD: inp.c,v 1.1.1.1 1995/10/18 08:45:55 deraadt Exp $";
d244 1
a244 1
    if ((tifd = creat(TMPINNAME, 0666)) < 0)
@


1.1
log
@Initial revision
@
text
@d1 2
d4 1
a4 1
static char rcsid[] = "$Id: inp.c,v 1.2 1993/08/02 17:55:16 mycroft Exp $";
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@
