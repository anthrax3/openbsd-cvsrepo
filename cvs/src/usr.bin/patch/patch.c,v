head	1.63;
access;
symbols
	OPENBSD_6_1:1.63.0.8
	OPENBSD_6_1_BASE:1.63
	OPENBSD_6_0:1.63.0.4
	OPENBSD_6_0_BASE:1.63
	OPENBSD_5_9:1.63.0.2
	OPENBSD_5_9_BASE:1.63
	OPENBSD_5_8:1.54.0.6
	OPENBSD_5_8_BASE:1.54
	OPENBSD_5_7:1.54.0.2
	OPENBSD_5_7_BASE:1.54
	OPENBSD_5_6:1.51.0.6
	OPENBSD_5_6_BASE:1.51
	OPENBSD_5_5:1.51.0.4
	OPENBSD_5_5_BASE:1.51
	OPENBSD_5_4:1.50.0.6
	OPENBSD_5_4_BASE:1.50
	OPENBSD_5_3:1.50.0.4
	OPENBSD_5_3_BASE:1.50
	OPENBSD_5_2:1.50.0.2
	OPENBSD_5_2_BASE:1.50
	OPENBSD_5_1_BASE:1.49
	OPENBSD_5_1:1.49.0.8
	OPENBSD_5_0:1.49.0.6
	OPENBSD_5_0_BASE:1.49
	OPENBSD_4_9:1.49.0.4
	OPENBSD_4_9_BASE:1.49
	OPENBSD_4_8:1.49.0.2
	OPENBSD_4_8_BASE:1.49
	OPENBSD_4_7:1.48.0.2
	OPENBSD_4_7_BASE:1.48
	OPENBSD_4_6:1.47.0.4
	OPENBSD_4_6_BASE:1.47
	OPENBSD_4_5:1.46.0.2
	OPENBSD_4_5_BASE:1.46
	OPENBSD_4_4:1.45.0.6
	OPENBSD_4_4_BASE:1.45
	OPENBSD_4_3:1.45.0.4
	OPENBSD_4_3_BASE:1.45
	OPENBSD_4_2:1.45.0.2
	OPENBSD_4_2_BASE:1.45
	OPENBSD_4_1:1.44.0.4
	OPENBSD_4_1_BASE:1.44
	OPENBSD_4_0:1.44.0.2
	OPENBSD_4_0_BASE:1.44
	OPENBSD_3_9:1.43.0.6
	OPENBSD_3_9_BASE:1.43
	OPENBSD_3_8:1.43.0.4
	OPENBSD_3_8_BASE:1.43
	OPENBSD_3_7:1.43.0.2
	OPENBSD_3_7_BASE:1.43
	OPENBSD_3_6:1.41.0.2
	OPENBSD_3_6_BASE:1.41
	OPENBSD_3_5:1.38.0.2
	OPENBSD_3_5_BASE:1.38
	OPENBSD_3_4:1.37.0.2
	OPENBSD_3_4_BASE:1.37
	OPENBSD_3_3:1.15.0.4
	OPENBSD_3_3_BASE:1.15
	OPENBSD_3_2:1.15.0.2
	OPENBSD_3_2_BASE:1.15
	OPENBSD_3_1:1.14.0.2
	OPENBSD_3_1_BASE:1.14
	OPENBSD_3_0:1.13.0.8
	OPENBSD_3_0_BASE:1.13
	OPENBSD_2_9_BASE:1.13
	OPENBSD_2_9:1.13.0.6
	OPENBSD_2_8:1.13.0.4
	OPENBSD_2_8_BASE:1.13
	OPENBSD_2_7:1.13.0.2
	OPENBSD_2_7_BASE:1.13
	OPENBSD_2_6:1.12.0.2
	OPENBSD_2_6_BASE:1.12
	OPENBSD_2_5:1.11.0.2
	OPENBSD_2_5_BASE:1.11
	OPENBSD_2_4:1.10.0.6
	OPENBSD_2_4_BASE:1.10
	OPENBSD_2_3:1.10.0.4
	OPENBSD_2_3_BASE:1.10
	OPENBSD_2_2:1.10.0.2
	OPENBSD_2_2_BASE:1.10
	OPENBSD_2_1:1.9.0.2
	OPENBSD_2_1_BASE:1.9
	OPENBSD_2_0:1.8.0.2
	OPENBSD_2_0_BASE:1.8
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.63
date	2016.01.04.14.09.46;	author gsoares;	state Exp;
branches;
next	1.62;
commitid	1a8XGB6MOklyIyED;

1.62
date	2015.12.29.19.04.46;	author gsoares;	state Exp;
branches;
next	1.61;
commitid	k2UzU75zoPNqkN7K;

1.61
date	2015.11.11.02.52.46;	author deraadt;	state Exp;
branches;
next	1.60;
commitid	6fvHpVQjE6wYuHzb;

1.60
date	2015.10.16.07.33.47;	author tobias;	state Exp;
branches;
next	1.59;
commitid	ROuDUViZDwLMOe8F;

1.59
date	2015.10.09.01.37.08;	author deraadt;	state Exp;
branches;
next	1.58;
commitid	sbrB3Q5CNxcwZpfU;

1.58
date	2015.10.07.06.29.26;	author deraadt;	state Exp;
branches;
next	1.57;
commitid	d9rHN7bJP3oVyuAJ;

1.57
date	2015.10.04.18.11.22;	author deraadt;	state Exp;
branches;
next	1.56;
commitid	uhjGaGR5gqAlfmV5;

1.56
date	2015.10.03.13.49.51;	author deraadt;	state Exp;
branches;
next	1.55;
commitid	JKdLhIiwGHoelUIX;

1.55
date	2015.10.03.02.35.56;	author deraadt;	state Exp;
branches;
next	1.54;
commitid	sh1Cg4SKeHED9Bl0;

1.54
date	2014.12.13.10.31.07;	author tobias;	state Exp;
branches;
next	1.53;
commitid	KFnMndwf456Gm1bQ;

1.53
date	2014.12.08.21.59.36;	author deraadt;	state Exp;
branches;
next	1.52;
commitid	yrJaJtlCm5yG3lJK;

1.52
date	2014.11.26.18.34.51;	author millert;	state Exp;
branches;
next	1.51;
commitid	9QOFSShUOtA0kQLF;

1.51
date	2013.11.26.13.19.07;	author deraadt;	state Exp;
branches;
next	1.50;

1.50
date	2012.05.15.19.32.02;	author millert;	state Exp;
branches;
next	1.49;

1.49
date	2010.07.24.01.10.12;	author ray;	state Exp;
branches;
next	1.48;

1.48
date	2009.10.27.23.59.41;	author deraadt;	state Exp;
branches;
next	1.47;

1.47
date	2009.04.05.13.36.00;	author stsp;	state Exp;
branches;
next	1.46;

1.46
date	2008.08.20.18.28.46;	author otto;	state Exp;
branches;
next	1.45;

1.45
date	2007.04.18.21.52.24;	author sobrado;	state Exp;
branches;
next	1.44;

1.44
date	2006.03.11.19.41.30;	author otto;	state Exp;
branches;
next	1.43;

1.43
date	2004.11.19.20.08.11;	author otto;	state Exp;
branches;
next	1.42;

1.42
date	2004.09.14.23.54.21;	author deraadt;	state Exp;
branches;
next	1.41;

1.41
date	2004.07.09.19.13.46;	author otto;	state Exp;
branches;
next	1.40;

1.40
date	2004.06.18.17.52.25;	author otto;	state Exp;
branches;
next	1.39;

1.39
date	2004.06.14.18.26.33;	author otto;	state Exp;
branches;
next	1.38;

1.38
date	2003.10.31.20.20.45;	author millert;	state Exp;
branches;
next	1.37;

1.37
date	2003.08.10.21.28.48;	author otto;	state Exp;
branches;
next	1.36;

1.36
date	2003.08.10.18.39.43;	author otto;	state Exp;
branches;
next	1.35;

1.35
date	2003.08.01.20.30.48;	author otto;	state Exp;
branches;
next	1.34;

1.34
date	2003.07.31.21.07.35;	author millert;	state Exp;
branches;
next	1.33;

1.33
date	2003.07.31.14.10.21;	author otto;	state Exp;
branches;
next	1.32;

1.32
date	2003.07.30.16.45.44;	author millert;	state Exp;
branches;
next	1.31;

1.31
date	2003.07.29.20.10.17;	author millert;	state Exp;
branches;
next	1.30;

1.30
date	2003.07.28.19.15.34;	author deraadt;	state Exp;
branches;
next	1.29;

1.29
date	2003.07.28.18.28.52;	author otto;	state Exp;
branches;
next	1.28;

1.28
date	2003.07.28.16.13.53;	author millert;	state Exp;
branches;
next	1.27;

1.27
date	2003.07.25.02.12.45;	author millert;	state Exp;
branches;
next	1.26;

1.26
date	2003.07.23.07.31.21;	author otto;	state Exp;
branches;
next	1.25;

1.25
date	2003.07.22.20.48.58;	author millert;	state Exp;
branches;
next	1.24;

1.24
date	2003.07.22.20.17.06;	author millert;	state Exp;
branches;
next	1.23;

1.23
date	2003.07.22.17.18.49;	author otto;	state Exp;
branches;
next	1.22;

1.22
date	2003.07.21.21.01.45;	author otto;	state Exp;
branches;
next	1.21;

1.21
date	2003.07.21.14.32.21;	author deraadt;	state Exp;
branches;
next	1.20;

1.20
date	2003.07.21.14.00.41;	author deraadt;	state Exp;
branches;
next	1.19;

1.19
date	2003.07.18.02.00.09;	author deraadt;	state Exp;
branches;
next	1.18;

1.18
date	2003.07.16.16.06.53;	author otto;	state Exp;
branches;
next	1.17;

1.17
date	2003.07.02.00.21.16;	author avsm;	state Exp;
branches;
next	1.16;

1.16
date	2003.04.05.17.17.53;	author deraadt;	state Exp;
branches;
next	1.15;

1.15
date	2002.07.04.04.22.48;	author deraadt;	state Exp;
branches;
next	1.14;

1.14
date	2002.03.05.08.56.55;	author niklas;	state Exp;
branches;
next	1.13;

1.13
date	99.12.04.01.01.06;	author provos;	state Exp;
branches;
next	1.12;

1.12
date	99.08.31.21.29.19;	author espie;	state Exp;
branches;
next	1.11;

1.11
date	98.11.25.00.30.26;	author espie;	state Exp;
branches;
next	1.10;

1.10
date	97.09.22.05.45.27;	author millert;	state Exp;
branches;
next	1.9;

1.9
date	97.01.17.07.13.04;	author millert;	state Exp;
branches;
next	1.8;

1.8
date	96.09.24.04.19.28;	author millert;	state Exp;
branches;
next	1.7;

1.7
date	96.09.24.02.58.52;	author millert;	state Exp;
branches;
next	1.6;

1.6
date	96.09.23.10.54.21;	author deraadt;	state Exp;
branches;
next	1.5;

1.5
date	96.09.15.19.19.54;	author millert;	state Exp;
branches;
next	1.4;

1.4
date	96.07.01.20.40.09;	author deraadt;	state Exp;
branches;
next	1.3;

1.3
date	96.06.25.23.06.39;	author deraadt;	state Exp;
branches;
next	1.2;

1.2
date	96.06.10.11.21.31;	author niklas;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.45.55;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.45.55;	author deraadt;	state Exp;
branches;
next	;


desc
@@


1.63
log
@usage() should exit 2 here, not EXIT_SUCCESS
ok tb@@
@
text
@/*	$OpenBSD: patch.c,v 1.62 2015/12/29 19:04:46 gsoares Exp $	*/

/*
 * patch - a program to apply diffs to original files
 * 
 * Copyright 1986, Larry Wall
 * 
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following condition is met:
 * 1. Redistributions of source code must retain the above copyright notice,
 * this condition and the following disclaimer.
 * 
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND ANY
 * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
 * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 * 
 * -C option added in 1998, original code by Marc Espie, based on FreeBSD
 * behaviour
 */

#include <sys/types.h>
#include <sys/stat.h>
#include <unistd.h>

#include <ctype.h>
#include <getopt.h>
#include <limits.h>
#include <stdio.h>
#include <string.h>
#include <stdlib.h>

#include "common.h"
#include "util.h"
#include "pch.h"
#include "inp.h"
#include "backupfile.h"
#include "pathnames.h"
#include "ed.h"

mode_t		filemode = 0644;

char		buf[MAXLINELEN];	/* general purpose buffer */

bool		using_plan_a = true;	/* try to keep everything in memory */
bool		out_of_mem = false;	/* ran out of memory in plan a */

#define MAXFILEC 2

char		*filearg[MAXFILEC];
bool		ok_to_create_file = false;
char		*outname = NULL;
char		*origprae = NULL;
char		*TMPOUTNAME;
char		*TMPINNAME;
char		*TMPREJNAME;
char		*TMPPATNAME;
bool		toutkeep = false;
bool		trejkeep = false;
bool		warn_on_invalid_line;
bool		last_line_missing_eol;

#ifdef DEBUGGING
int		debug = 0;
#endif

bool		force = false;
bool		batch = false;
bool		verbose = true;
bool		reverse = false;
bool		noreverse = false;
bool		skip_rest_of_patch = false;
int		strippath = 957;
bool		canonicalize = false;
bool		check_only = false;
int		diff_type = 0;
char		*revision = NULL;	/* prerequisite revision, if any */
LINENUM		input_lines = 0;	/* how long is input file in lines */
int		posix = 0;		/* strict POSIX mode? */

static void	reinitialize_almost_everything(void);
static void	get_some_switches(void);
static LINENUM	locate_hunk(LINENUM);
static void	abort_context_hunk(void);
static void	rej_line(int, LINENUM);
static void	abort_hunk(void);
static void	apply_hunk(LINENUM);
static void	init_output(const char *);
static void	init_reject(const char *);
static void	copy_till(LINENUM, bool);
static void	spew_output(void);
static void	dump_line(LINENUM, bool);
static bool	patch_match(LINENUM, LINENUM, LINENUM);
static bool	similar(const char *, const char *, int);
static __dead void usage(void);

/* true if -E was specified on command line.  */
static bool	remove_empty_files = false;

/* true if -R was specified on command line.  */
static bool	reverse_flag_specified = false;

/* buffer holding the name of the rejected patch file. */
static char	rejname[NAME_MAX + 1];

/* how many input lines have been irretractibly output */
static LINENUM	last_frozen_line = 0;

static int	Argc;		/* guess */
static char	**Argv;
static int	Argc_last;	/* for restarting plan_b */
static char	**Argv_last;

static FILE	*ofp = NULL;	/* output file pointer */
static FILE	*rejfp = NULL;	/* reject file pointer */

static int	filec = 0;	/* how many file arguments? */
static LINENUM	last_offset = 0;
static LINENUM	maxfuzz = 2;

/* patch using ifdef, ifndef, etc. */
static bool		do_defines = false;
/* #ifdef xyzzy */
static char		if_defined[128];
/* #ifndef xyzzy */
static char		not_defined[128];
/* #else */
static const char	else_defined[] = "#else\n";
/* #endif xyzzy */
static char		end_defined[128];


/* Apply a set of diffs as appropriate. */

int
main(int argc, char *argv[])
{
	int	error = 0, hunk, failed, i, fd;
	bool	patch_seen;
	LINENUM	where = 0, newwhere, fuzz, mymaxfuzz;
	const	char *tmpdir;
	char	*v;

	if (pledge("stdio rpath wpath cpath tmppath fattr", NULL) == -1) {
		perror("pledge");
		my_exit(2);
	}

	setvbuf(stdout, NULL, _IOLBF, 0);
	setvbuf(stderr, NULL, _IOLBF, 0);
	for (i = 0; i < MAXFILEC; i++)
		filearg[i] = NULL;

	/* Cons up the names of the temporary files.  */
	if ((tmpdir = getenv("TMPDIR")) == NULL || *tmpdir == '\0')
		tmpdir = _PATH_TMP;
	for (i = strlen(tmpdir) - 1; i > 0 && tmpdir[i] == '/'; i--)
		;
	i++;
	if (asprintf(&TMPOUTNAME, "%.*s/patchoXXXXXXXXXX", i, tmpdir) == -1)
		fatal("cannot allocate memory");
	if ((fd = mkstemp(TMPOUTNAME)) < 0)
		pfatal("can't create %s", TMPOUTNAME);
	close(fd);

	if (asprintf(&TMPINNAME, "%.*s/patchiXXXXXXXXXX", i, tmpdir) == -1)
		fatal("cannot allocate memory");
	if ((fd = mkstemp(TMPINNAME)) < 0)
		pfatal("can't create %s", TMPINNAME);
	close(fd);

	if (asprintf(&TMPREJNAME, "%.*s/patchrXXXXXXXXXX", i, tmpdir) == -1)
		fatal("cannot allocate memory");
	if ((fd = mkstemp(TMPREJNAME)) < 0)
		pfatal("can't create %s", TMPREJNAME);
	close(fd);

	if (asprintf(&TMPPATNAME, "%.*s/patchpXXXXXXXXXX", i, tmpdir) == -1)
		fatal("cannot allocate memory");
	if ((fd = mkstemp(TMPPATNAME)) < 0)
		pfatal("can't create %s", TMPPATNAME);
	close(fd);

	v = getenv("SIMPLE_BACKUP_SUFFIX");
	if (v)
		simple_backup_suffix = v;
	else
		simple_backup_suffix = ORIGEXT;

	/* parse switches */
	Argc = argc;
	Argv = argv;
	get_some_switches();

	if (backup_type == none) {
		if ((v = getenv("PATCH_VERSION_CONTROL")) == NULL)
			v = getenv("VERSION_CONTROL");
		if (v != NULL || !posix)
			backup_type = get_version(v);	/* OK to pass NULL. */
	}

	/* make sure we clean up /tmp in case of disaster */
	set_signals(0);

	patch_seen = false;
	for (open_patch_file(filearg[1]); there_is_another_patch();
	    reinitialize_almost_everything()) {
		/* for each patch in patch file */

		patch_seen = true;

		warn_on_invalid_line = true;

		if (outname == NULL)
			outname = xstrdup(filearg[0]);

		/* initialize the patched file */
		if (!skip_rest_of_patch)
			init_output(TMPOUTNAME);

		/* initialize reject file */
		init_reject(TMPREJNAME);

		/* find out where all the lines are */
		if (!skip_rest_of_patch)
			scan_input(filearg[0]);

		/* for ed script just up and do it and exit */
		if (diff_type == ED_DIFF) {
			do_ed_script();
			continue;
		}

		/* from here on, open no standard i/o files, because malloc */
		/* might misfire and we can't catch it easily */

		/* apply each hunk of patch */
		hunk = 0;
		failed = 0;
		out_of_mem = false;
		while (another_hunk()) {
			hunk++;
			fuzz = 0;
			mymaxfuzz = pch_context();
			if (maxfuzz < mymaxfuzz)
				mymaxfuzz = maxfuzz;
			if (!skip_rest_of_patch) {
				do {
					where = locate_hunk(fuzz);
					if (hunk == 1 && where == 0 && !force) {
						/* dwim for reversed patch? */
						if (!pch_swap()) {
							if (fuzz == 0)
								say("Not enough memory to try swapped hunk!  Assuming unswapped.\n");
							continue;
						}
						reverse = !reverse;
						/* try again */
						where = locate_hunk(fuzz);
						if (where == 0) {
							/* didn't find it swapped */
							if (!pch_swap())
								/* put it back to normal */
								fatal("lost hunk on alloc error!\n");
							reverse = !reverse;
						} else if (noreverse) {
							if (!pch_swap())
								/* put it back to normal */
								fatal("lost hunk on alloc error!\n");
							reverse = !reverse;
							say("Ignoring previously applied (or reversed) patch.\n");
							skip_rest_of_patch = true;
						} else if (batch) {
							if (verbose)
								say("%seversed (or previously applied) patch detected!  %s -R.",
								    reverse ? "R" : "Unr",
								    reverse ? "Assuming" : "Ignoring");
						} else {
							ask("%seversed (or previously applied) patch detected!  %s -R? [y] ",
							    reverse ? "R" : "Unr",
							    reverse ? "Assume" : "Ignore");
							if (*buf == 'n') {
								ask("Apply anyway? [n] ");
								if (*buf != 'y')
									skip_rest_of_patch = true;
								where = 0;
								reverse = !reverse;
								if (!pch_swap())
									/* put it back to normal */
									fatal("lost hunk on alloc error!\n");
							}
						}
					}
				} while (!skip_rest_of_patch && where == 0 &&
				    ++fuzz <= mymaxfuzz);

				if (skip_rest_of_patch) {	/* just got decided */
					fclose(ofp);
					ofp = NULL;
				}
			}
			newwhere = pch_newfirst() + last_offset;
			if (skip_rest_of_patch) {
				abort_hunk();
				failed++;
				if (verbose)
					say("Hunk #%d ignored at %ld.\n",
					    hunk, newwhere);
			} else if (where == 0) {
				abort_hunk();
				failed++;
				if (verbose)
					say("Hunk #%d failed at %ld.\n",
					    hunk, newwhere);
			} else {
				apply_hunk(where);
				if (verbose) {
					say("Hunk #%d succeeded at %ld",
					    hunk, newwhere);
					if (fuzz != 0)
						say(" with fuzz %ld", fuzz);
					if (last_offset)
						say(" (offset %ld line%s)",
						    last_offset,
						    last_offset == 1L ? "" : "s");
					say(".\n");
				}
			}
		}

		if (out_of_mem && using_plan_a) {
			Argc = Argc_last;
			Argv = Argv_last;
			say("\n\nRan out of memory using Plan A--trying again...\n\n");
			if (ofp)
				fclose(ofp);
			ofp = NULL;
			if (rejfp)
				fclose(rejfp);
			rejfp = NULL;
			continue;
		}
		if (hunk == 0)
			fatal("Internal error: hunk should not be 0\n");

		/* finish spewing out the new file */
		if (!skip_rest_of_patch)
			spew_output();

		/* and put the output where desired */
		ignore_signals();
		if (!skip_rest_of_patch) {
			struct stat	statbuf;
			char	*realout = outname;

			if (!check_only) {
				if (move_file(TMPOUTNAME, outname) < 0) {
					toutkeep = true;
					realout = TMPOUTNAME;
					chmod(TMPOUTNAME, filemode);
				} else
					chmod(outname, filemode);

				if (remove_empty_files &&
				    stat(realout, &statbuf) == 0 &&
				    statbuf.st_size == 0) {
					if (verbose)
						say("Removing %s (empty after patching).\n",
						    realout);
					unlink(realout);
				}
			}
		}
		fclose(rejfp);
		rejfp = NULL;
		if (failed) {
			error = 1;
			if (*rejname == '\0') {
				if (strlcpy(rejname, outname,
				    sizeof(rejname)) >= sizeof(rejname))
					fatal("filename %s is too long\n", outname);
				if (strlcat(rejname, REJEXT,
				    sizeof(rejname)) >= sizeof(rejname))
					fatal("filename %s is too long\n", outname);
			}
			if (!check_only)
				say("%d out of %d hunks %s--saving rejects to %s\n",
				    failed, hunk, skip_rest_of_patch ? "ignored" : "failed", rejname);
			else
				say("%d out of %d hunks %s\n",
				    failed, hunk, skip_rest_of_patch ? "ignored" : "failed");
			if (!check_only && move_file(TMPREJNAME, rejname) < 0)
				trejkeep = true;
		}
		set_signals(1);
	}

	if (!patch_seen)
		error = 2;

	my_exit(error);
	/* NOTREACHED */
}

/* Prepare to find the next patch to do in the patch file. */

static void
reinitialize_almost_everything(void)
{
	re_patch();
	re_input();

	input_lines = 0;
	last_frozen_line = 0;

	filec = 0;
	if (!out_of_mem) {
		free(filearg[0]);
		filearg[0] = NULL;
	}

	free(outname);
	outname = NULL;

	last_offset = 0;
	diff_type = 0;

	free(revision);
	revision = NULL;

	reverse = reverse_flag_specified;
	skip_rest_of_patch = false;

	get_some_switches();
}

/* Process switches and filenames. */

static void
get_some_switches(void)
{
	const char *options = "b::B:cCd:D:eEfF:i:lnNo:p:r:RstuvV:x:z:";
	static struct option longopts[] = {
		{"backup",		no_argument,		0,	'b'},
		{"batch",		no_argument,		0,	't'},
		{"check",		no_argument,		0,	'C'},
		{"context",		no_argument,		0,	'c'},
		{"debug",		required_argument,	0,	'x'},
		{"directory",		required_argument,	0,	'd'},
		{"ed",			no_argument,		0,	'e'},
		{"force",		no_argument,		0,	'f'},
		{"forward",		no_argument,		0,	'N'},
		{"fuzz",		required_argument,	0,	'F'},
		{"ifdef",		required_argument,	0,	'D'},
		{"input",		required_argument,	0,	'i'},
		{"ignore-whitespace",	no_argument,		0,	'l'},
		{"normal",		no_argument,		0,	'n'},
		{"output",		required_argument,	0,	'o'},
		{"prefix",		required_argument,	0,	'B'},
		{"quiet",		no_argument,		0,	's'},
		{"reject-file",		required_argument,	0,	'r'},
		{"remove-empty-files",	no_argument,		0,	'E'},
		{"reverse",		no_argument,		0,	'R'},
		{"silent",		no_argument,		0,	's'},
		{"strip",		required_argument,	0,	'p'},
		{"suffix",		required_argument,	0,	'z'},
		{"unified",		no_argument,		0,	'u'},
		{"version",		no_argument,		0,	'v'},
		{"version-control",	required_argument,	0,	'V'},
		{"posix",		no_argument,		&posix,	1},
		{NULL,			0,			0,	0}
	};
	int ch;

	rejname[0] = '\0';
	Argc_last = Argc;
	Argv_last = Argv;
	if (!Argc)
		return;
	optreset = optind = 1;
	while ((ch = getopt_long(Argc, Argv, options, longopts, NULL)) != -1) {
		switch (ch) {
		case 'b':
			if (backup_type == none)
				backup_type = numbered_existing;
			if (optarg == NULL)
				break;
			if (verbose)
				say("Warning, the ``-b suffix'' option has been"
				    " obsoleted by the -z option.\n");
			/* FALLTHROUGH */
		case 'z':
			/* must directly follow 'b' case for backwards compat */
			simple_backup_suffix = xstrdup(optarg);
			break;
		case 'B':
			origprae = xstrdup(optarg);
			break;
		case 'c':
			diff_type = CONTEXT_DIFF;
			break;
		case 'C':
			check_only = true;
			break;
		case 'd':
			if (chdir(optarg) < 0)
				pfatal("can't cd to %s", optarg);
			break;
		case 'D':
			do_defines = true;
			if (!isalpha((unsigned char)*optarg) && *optarg != '_')
				fatal("argument to -D is not an identifier\n");
			snprintf(if_defined, sizeof if_defined,
			    "#ifdef %s\n", optarg);
			snprintf(not_defined, sizeof not_defined,
			    "#ifndef %s\n", optarg);
			snprintf(end_defined, sizeof end_defined,
			    "#endif /* %s */\n", optarg);
			break;
		case 'e':
			diff_type = ED_DIFF;
			break;
		case 'E':
			remove_empty_files = true;
			break;
		case 'f':
			force = true;
			break;
		case 'F':
			maxfuzz = atoi(optarg);
			break;
		case 'i':
			if (++filec == MAXFILEC)
				fatal("too many file arguments\n");
			filearg[filec] = xstrdup(optarg);
			break;
		case 'l':
			canonicalize = true;
			break;
		case 'n':
			diff_type = NORMAL_DIFF;
			break;
		case 'N':
			noreverse = true;
			break;
		case 'o':
			outname = xstrdup(optarg);
			break;
		case 'p':
			strippath = atoi(optarg);
			break;
		case 'r':
			if (strlcpy(rejname, optarg,
			    sizeof(rejname)) >= sizeof(rejname))
				fatal("argument for -r is too long\n");
			break;
		case 'R':
			reverse = true;
			reverse_flag_specified = true;
			break;
		case 's':
			verbose = false;
			break;
		case 't':
			batch = true;
			break;
		case 'u':
			diff_type = UNI_DIFF;
			break;
		case 'v':
			version();
			break;
		case 'V':
			backup_type = get_version(optarg);
			break;
#ifdef DEBUGGING
		case 'x':
			debug = atoi(optarg);
			break;
#endif
		default:
			if (ch != '\0')
				usage();
			break;
		}
	}
	Argc -= optind;
	Argv += optind;

	if (Argc > 0) {
		filearg[0] = xstrdup(*Argv++);
		Argc--;
		while (Argc > 0) {
			if (++filec == MAXFILEC)
				fatal("too many file arguments\n");
			filearg[filec] = xstrdup(*Argv++);
			Argc--;
		}
	}

	if (getenv("POSIXLY_CORRECT") != NULL)
		posix = 1;
}

static __dead void
usage(void)
{
	fprintf(stderr,
"usage: patch [-bCcEeflNnRstuv] [-B backup-prefix] [-D symbol] [-d directory]\n"
"             [-F max-fuzz] [-i patchfile] [-o out-file] [-p strip-count]\n"
"             [-r rej-name] [-V t | nil | never] [-x number] [-z backup-ext]\n"
"             [--posix] [origfile [patchfile]]\n"
"       patch <patchfile\n");
	my_exit(2);
}

/*
 * Attempt to find the right place to apply this hunk of patch.
 */
static LINENUM
locate_hunk(LINENUM fuzz)
{
	LINENUM	first_guess = pch_first() + last_offset;
	LINENUM	offset;
	LINENUM	pat_lines = pch_ptrn_lines();
	LINENUM	max_pos_offset = input_lines - first_guess - pat_lines + 1;
	LINENUM	max_neg_offset = first_guess - last_frozen_line - 1 + pch_context();

	if (pat_lines == 0) {		/* null range matches always */
		if (verbose && fuzz == 0 && (diff_type == CONTEXT_DIFF
		    || diff_type == NEW_CONTEXT_DIFF
		    || diff_type == UNI_DIFF)) {
			say("Empty context always matches.\n");
		}
		return (first_guess);
	}
	if (max_neg_offset >= first_guess)	/* do not try lines < 0 */
		max_neg_offset = first_guess - 1;
	if (first_guess <= input_lines && patch_match(first_guess, 0, fuzz))
		return first_guess;
	for (offset = 1; ; offset++) {
		bool	check_after = (offset <= max_pos_offset);
		bool	check_before = (offset <= max_neg_offset);

		if (check_after && patch_match(first_guess, offset, fuzz)) {
#ifdef DEBUGGING
			if (debug & 1)
				say("Offset changing from %ld to %ld\n",
				    last_offset, offset);
#endif
			last_offset = offset;
			return first_guess + offset;
		} else if (check_before && patch_match(first_guess, -offset, fuzz)) {
#ifdef DEBUGGING
			if (debug & 1)
				say("Offset changing from %ld to %ld\n",
				    last_offset, -offset);
#endif
			last_offset = -offset;
			return first_guess - offset;
		} else if (!check_before && !check_after)
			return 0;
	}
}

/* We did not find the pattern, dump out the hunk so they can handle it. */

static void
abort_context_hunk(void)
{
	LINENUM	i;
	const LINENUM	pat_end = pch_end();
	/*
	 * add in last_offset to guess the same as the previous successful
	 * hunk
	 */
	const LINENUM	oldfirst = pch_first() + last_offset;
	const LINENUM	newfirst = pch_newfirst() + last_offset;
	const LINENUM	oldlast = oldfirst + pch_ptrn_lines() - 1;
	const LINENUM	newlast = newfirst + pch_repl_lines() - 1;
	const char	*stars = (diff_type >= NEW_CONTEXT_DIFF ? " ****" : "");
	const char	*minuses = (diff_type >= NEW_CONTEXT_DIFF ? " ----" : " -----");

	fprintf(rejfp, "***************\n");
	for (i = 0; i <= pat_end; i++) {
		switch (pch_char(i)) {
		case '*':
			if (oldlast < oldfirst)
				fprintf(rejfp, "*** 0%s\n", stars);
			else if (oldlast == oldfirst)
				fprintf(rejfp, "*** %ld%s\n", oldfirst, stars);
			else
				fprintf(rejfp, "*** %ld,%ld%s\n", oldfirst,
				    oldlast, stars);
			break;
		case '=':
			if (newlast < newfirst)
				fprintf(rejfp, "--- 0%s\n", minuses);
			else if (newlast == newfirst)
				fprintf(rejfp, "--- %ld%s\n", newfirst, minuses);
			else
				fprintf(rejfp, "--- %ld,%ld%s\n", newfirst,
				    newlast, minuses);
			break;
		case '\n':
			fprintf(rejfp, "%s", pfetch(i));
			break;
		case ' ':
		case '-':
		case '+':
		case '!':
			fprintf(rejfp, "%c %s", pch_char(i), pfetch(i));
			break;
		default:
			fatal("fatal internal error in abort_context_hunk\n");
		}
	}
}

static void
rej_line(int ch, LINENUM i)
{
	size_t len;
	const char *line = pfetch(i);

	len = strlen(line);

	fprintf(rejfp, "%c%s", ch, line);
	if (len == 0 || line[len-1] != '\n')
		fprintf(rejfp, "\n\\ No newline at end of file\n");
}

static void
abort_hunk(void)
{
	LINENUM		i, j, split;
	int		ch1, ch2;
	const LINENUM	pat_end = pch_end();
	const LINENUM	oldfirst = pch_first() + last_offset;
	const LINENUM	newfirst = pch_newfirst() + last_offset;

	if (diff_type != UNI_DIFF) {
		abort_context_hunk();
		return;
	}
	split = -1;
	for (i = 0; i <= pat_end; i++) {
		if (pch_char(i) == '=') {
			split = i;
			break;
		}
	}
	if (split == -1) {
		fprintf(rejfp, "malformed hunk: no split found\n");
		return;
	}
	i = 0;
	j = split + 1;
	fprintf(rejfp, "@@@@ -%ld,%ld +%ld,%ld @@@@\n",
	    pch_ptrn_lines() ? oldfirst : 0,
	    pch_ptrn_lines(), newfirst, pch_repl_lines());
	while (i < split || j <= pat_end) {
		ch1 = i < split ? pch_char(i) : -1;
		ch2 = j <= pat_end ? pch_char(j) : -1;
		if (ch1 == '-') {
			rej_line('-', i);
			i++;
		} else if (ch1 == ' ' && ch2 == ' ') {
			rej_line(' ', i);
			i++;
			j++;
		} else if (ch1 == '!' && ch2 == '!') {
			while (i < split && ch1 == '!') {
				rej_line('-', i);
				i++;
				ch1 = i < split ? pch_char(i) : -1;
			}
			while (j <= pat_end && ch2 == '!') {
				rej_line('+', j);
				j++;
				ch2 = j <= pat_end ? pch_char(j) : -1;
			}
		} else if (ch1 == '*') {
			i++;
		} else if (ch2 == '+' || ch2 == ' ') {
			rej_line(ch2, j);
			j++;
		} else {
			fprintf(rejfp, "internal error on (%ld %ld %ld)\n",
			    i, split, j);
			rej_line(ch1, i);
			rej_line(ch2, j);
			return;
		}
	}
}

/* We found where to apply it (we hope), so do it. */

static void
apply_hunk(LINENUM where)
{
	LINENUM		old = 1;
	const LINENUM	lastline = pch_ptrn_lines();
	LINENUM		new = lastline + 1;
#define OUTSIDE 0
#define IN_IFNDEF 1
#define IN_IFDEF 2
#define IN_ELSE 3
	int		def_state = OUTSIDE;
	const LINENUM	pat_end = pch_end();

	where--;
	while (pch_char(new) == '=' || pch_char(new) == '\n')
		new++;

	while (old <= lastline) {
		if (pch_char(old) == '-') {
			copy_till(where + old - 1, false);
			if (do_defines) {
				if (def_state == OUTSIDE) {
					fputs(not_defined, ofp);
					def_state = IN_IFNDEF;
				} else if (def_state == IN_IFDEF) {
					fputs(else_defined, ofp);
					def_state = IN_ELSE;
				}
				fputs(pfetch(old), ofp);
			}
			last_frozen_line++;
			old++;
		} else if (new > pat_end) {
			break;
		} else if (pch_char(new) == '+') {
			copy_till(where + old - 1, false);
			if (do_defines) {
				if (def_state == IN_IFNDEF) {
					fputs(else_defined, ofp);
					def_state = IN_ELSE;
				} else if (def_state == OUTSIDE) {
					fputs(if_defined, ofp);
					def_state = IN_IFDEF;
				}
			}
			fputs(pfetch(new), ofp);
			new++;
		} else if (pch_char(new) != pch_char(old)) {
			say("Out-of-sync patch, lines %ld,%ld--mangled text or line numbers, maybe?\n",
			    pch_hunk_beg() + old,
			    pch_hunk_beg() + new);
#ifdef DEBUGGING
			say("oldchar = '%c', newchar = '%c'\n",
			    pch_char(old), pch_char(new));
#endif
			my_exit(2);
		} else if (pch_char(new) == '!') {
			copy_till(where + old - 1, false);
			if (do_defines) {
				fputs(not_defined, ofp);
				def_state = IN_IFNDEF;
			}
			while (pch_char(old) == '!') {
				if (do_defines) {
					fputs(pfetch(old), ofp);
				}
				last_frozen_line++;
				old++;
			}
			if (do_defines) {
				fputs(else_defined, ofp);
				def_state = IN_ELSE;
			}
			while (pch_char(new) == '!') {
				fputs(pfetch(new), ofp);
				new++;
			}
		} else {
			if (pch_char(new) != ' ')
				fatal("Internal error: expected ' '\n");
			old++;
			new++;
			if (do_defines && def_state != OUTSIDE) {
				fputs(end_defined, ofp);
				def_state = OUTSIDE;
			}
		}
	}
	if (new <= pat_end && pch_char(new) == '+') {
		copy_till(where + old - 1, false);
		if (do_defines) {
			if (def_state == OUTSIDE) {
				fputs(if_defined, ofp);
				def_state = IN_IFDEF;
			} else if (def_state == IN_IFNDEF) {
				fputs(else_defined, ofp);
				def_state = IN_ELSE;
			}
		}
		while (new <= pat_end && pch_char(new) == '+') {
			fputs(pfetch(new), ofp);
			new++;
		}
	}
	if (do_defines && def_state != OUTSIDE) {
		fputs(end_defined, ofp);
	}
}

/*
 * Open the new file.
 */
static void
init_output(const char *name)
{
	ofp = fopen(name, "w");
	if (ofp == NULL)
		pfatal("can't create %s", name);
}

/*
 * Open a file to put hunks we can't locate.
 */
static void
init_reject(const char *name)
{
	rejfp = fopen(name, "w");
	if (rejfp == NULL)
		pfatal("can't create %s", name);
}

/*
 * Copy input file to output, up to wherever hunk is to be applied.
 * If endoffile is true, treat the last line specially since it may
 * lack a newline.
 */
static void
copy_till(LINENUM lastline, bool endoffile)
{
	if (last_frozen_line > lastline)
		fatal("misordered hunks! output would be garbled\n");
	while (last_frozen_line < lastline) {
		if (++last_frozen_line == lastline && endoffile)
			dump_line(last_frozen_line, !last_line_missing_eol);
		else
			dump_line(last_frozen_line, true);
	}
}

/*
 * Finish copying the input file to the output file.
 */
static void
spew_output(void)
{
#ifdef DEBUGGING
	if (debug & 256)
		say("il=%ld lfl=%ld\n", input_lines, last_frozen_line);
#endif
	if (input_lines)
		copy_till(input_lines, true);	/* dump remainder of file */
	fclose(ofp);
	ofp = NULL;
}

/*
 * Copy one line from input to output.
 */
static void
dump_line(LINENUM line, bool write_newline)
{
	char	*s;

	s = ifetch(line, 0);
	if (s == NULL)
		return;
	/* Note: string is not NUL terminated. */
	for (; *s != '\n'; s++)
		putc(*s, ofp);
	if (write_newline)
		putc('\n', ofp);
}

/*
 * Does the patch pattern match at line base+offset?
 */
static bool
patch_match(LINENUM base, LINENUM offset, LINENUM fuzz)
{
	LINENUM		pline = 1 + fuzz;
	LINENUM		iline;
	LINENUM		pat_lines = pch_ptrn_lines() - fuzz;
	const char	*ilineptr;
	const char	*plineptr;
	short		plinelen;

	for (iline = base + offset + fuzz; pline <= pat_lines; pline++, iline++) {
		ilineptr = ifetch(iline, offset >= 0);
		if (ilineptr == NULL)
			return false;
		plineptr = pfetch(pline);
		plinelen = pch_line_len(pline);
		if (canonicalize) {
			if (!similar(ilineptr, plineptr, plinelen))
				return false;
		} else if (strnNE(ilineptr, plineptr, plinelen))
			return false;
		if (iline == input_lines) {
			/*
			 * We are looking at the last line of the file.
			 * If the file has no eol, the patch line should
			 * not have one either and vice-versa. Note that
			 * plinelen > 0.
			 */
			if (last_line_missing_eol) {
				if (plineptr[plinelen - 1] == '\n')
					return false;
			} else {
				if (plineptr[plinelen - 1] != '\n')
					return false;
			}
		}
	}
	return true;
}

/*
 * Do two lines match with canonicalized white space?
 */
static bool
similar(const char *a, const char *b, int len)
{
	while (len) {
		if (isspace((unsigned char)*b)) { /* whitespace (or \n) to match? */
			if (!isspace((unsigned char)*a))
				return false;	/* no corresponding whitespace */
			while (len && isspace((unsigned char)*b) && *b != '\n')
				b++, len--;	/* skip pattern whitespace */
			while (isspace((unsigned char)*a) && *a != '\n')
				a++;	/* skip target whitespace */
			if (*a == '\n' || *b == '\n')
				return (*a == *b);	/* should end in sync */
		} else if (*a++ != *b++)	/* match non-whitespace chars */
			return false;
		else
			len--;	/* probably not necessary */
	}
	return true;		/* actually, this is not reached */
	/* since there is always a \n */
}
@


1.62
log
@fix exit status on pledge(2) failure.

OK tb@@ jsg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: patch.c,v 1.61 2015/11/11 02:52:46 deraadt Exp $	*/
d621 1
a621 1
	my_exit(EXIT_SUCCESS);
@


1.61
log
@exit() after perror() for pledge failure.  Perhaps this got introduced
as a test idiom, either when pledge was young or during the transition
to strings.... dunno
@
text
@d1 1
a1 1
/*	$OpenBSD: patch.c,v 1.60 2015/10/16 07:33:47 tobias Exp $	*/
d153 1
a153 1
		exit(1);
@


1.60
log
@Add native support for ed-style diffs. No need to pledge "proc exec" anymore.

ok deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: patch.c,v 1.59 2015/10/09 01:37:08 deraadt Exp $	*/
d151 1
a151 1
	if (pledge("stdio rpath wpath cpath tmppath fattr", NULL) == -1)
d153 2
@


1.59
log
@Change all tame callers to namechange to pledge(2).
@
text
@d1 1
a1 1
/*	$OpenBSD: patch.c,v 1.58 2015/10/07 06:29:26 deraadt Exp $	*/
d46 1
d151 1
a151 1
	if (pledge("stdio rpath wpath cpath tmppath fattr proc exec", NULL) == -1)
a221 5
		/* for ed script just up and do it and exit */
		if (diff_type == ED_DIFF) {
			do_ed_script();
			continue;
		}
d232 6
@


1.58
log
@patch(1) can move to "stdio rpath wpath cpath tmppath fattr proc exec"
(adding proc exec), now that "exec" has arrived in the kernel.  This
permits the dangerous game of feeding ed-style diffs with popen() via
/bin/ed.  Shocked yet?  Your mission, should you choose to accept it,
is to replace this code with an builtin ed-style patcher, maybe cribbing
code from ed itself.

I'm sorry, but we can't fix the entire world all at once.  Noone loves
deprecating standarized features as much as we do, but there are some
lines.  Maybe if people become aware of how crappy the implimentations
of some standard features are, they could help decide the path.
@
text
@d1 1
a1 1
/*	$OpenBSD: patch.c,v 1.57 2015/10/04 18:11:22 deraadt Exp $	*/
d150 2
a151 2
	if (tame("stdio rpath wpath cpath tmppath fattr proc exec", NULL) == -1)
		perror("tame");
@


1.57
log
@remove tame "proc".  it is not useful, because the "ed" diffs require
fork+execve, and execve is not going to become available in this fashion.
ed diffs should be handled using a built-in handler, and various folks
have been discussing this behind the scenes.
@
text
@d1 1
a1 1
/*	$OpenBSD: patch.c,v 1.56 2015/10/03 13:49:51 deraadt Exp $	*/
d150 1
a150 1
	if (tame("stdio rpath wpath cpath tmppath fattr", NULL) == -1)
@


1.56
log
@As pointed out by tobiasu, ed-style patches still use popen() and execute
/bin/ed.  This is RETARDED.  Nothing learned from the last year?

Add tame "proc" until that is fixed, to allow fork+exec.

I beg for someone to cross-link the guts of ed directly into patch, or
write a ed-subset which can do the job.
@
text
@d1 1
a1 1
/*	$OpenBSD: patch.c,v 1.55 2015/10/03 02:35:56 deraadt Exp $	*/
d150 1
a150 1
	if (tame("stdio rpath wpath cpath tmppath fattr proc", NULL) == -1)
@


1.55
log
@patch appears to work fully with tame "stdio rpath wpath cpath tmppath fattr".
in case of exploitation, no more network access, fork, execve, etc.
I wonder if we could use whitepath lists here - if it is reasonable to
limit operation in directories known early on?
@
text
@d1 1
a1 1
/*	$OpenBSD: patch.c,v 1.54 2014/12/13 10:31:07 tobias Exp $	*/
d150 1
a150 1
	if (tame("stdio rpath wpath cpath tmppath fattr", NULL) == -1)
@


1.54
log
@The function savestr allows NULL return values during Plan A patching so in
case of out of memory conditions, Plan B can step in.  In many cases, NULL
value is not properly handled, so use xstrdup here (it's outside Plan A/B
patching, which means that even Plan B relies on successful operations).
@
text
@d1 1
a1 1
/*	$OpenBSD: patch.c,v 1.53 2014/12/08 21:59:36 deraadt Exp $	*/
d149 3
@


1.53
log
@spaces
@
text
@d1 1
a1 1
/*	$OpenBSD: patch.c,v 1.52 2014/11/26 18:34:51 millert Exp $	*/
d216 1
a216 1
			outname = savestr(filearg[0]);
d494 1
a494 1
			simple_backup_suffix = savestr(optarg);
d497 1
a497 1
			origprae = savestr(optarg);
d535 1
a535 1
			filearg[filec] = savestr(optarg);
d547 1
a547 1
			outname = savestr(optarg);
d591 1
a591 1
		filearg[0] = savestr(*Argv++);
d596 1
a596 1
			filearg[filec] = savestr(*Argv++);
@


1.52
log
@Prefer setvbuf() to setlinebuf() for portability; ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: patch.c,v 1.51 2013/11/26 13:19:07 deraadt Exp $	*/
d210 1
a210 1
		
d397 1
a397 1
	
@


1.51
log
@unsigned char casts for ctype
ok krw
@
text
@d1 1
a1 1
/*	$OpenBSD: patch.c,v 1.50 2012/05/15 19:32:02 millert Exp $	*/
d150 2
a151 2
	setlinebuf(stdout);
	setlinebuf(stderr);
@


1.50
log
@Fix confusing patch(1) output on failure when using -C.  From
dragonflybsd via Loganaden Velvindron.  OK mikeb@@ and deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: patch.c,v 1.49 2010/07/24 01:10:12 ray Exp $	*/
d511 1
a511 1
			if (!isalpha(*optarg) && *optarg != '_')
d1033 4
a1036 4
		if (isspace(*b)) {	/* whitespace (or \n) to match? */
			if (!isspace(*a))	/* no corresponding whitespace? */
				return false;
			while (len && isspace(*b) && *b != '\n')
d1038 1
a1038 1
			while (isspace(*a) && *a != '\n')
@


1.49
log
@Send normal output to stdout instead of everything to stderr. This
is currently done in the latest versions of GNU patch.

Please watch out for output appearing out-of-order.

Discussed with millert and deraadt.

OK deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: patch.c,v 1.48 2009/10/27 23:59:41 deraadt Exp $	*/
d386 6
a391 7
			if (skip_rest_of_patch) {
				say("%d out of %d hunks ignored--saving rejects to %s\n",
				    failed, hunk, rejname);
			} else {
				say("%d out of %d hunks failed--saving rejects to %s\n",
				    failed, hunk, rejname);
			}
@


1.48
log
@rcsid[] and sccsid[] and copyright[] are essentially unmaintained (and
unmaintainable).  these days, people use source.  these id's do not provide
any benefit, and do hurt the small install media
(the 33,000 line diff is essentially mechanical)
ok with the idea millert, ok dms
@
text
@d1 1
a1 1
/*	$OpenBSD: patch.c,v 1.47 2009/04/05 13:36:00 stsp Exp $	*/
a111 3
/* buffer for stderr */
static char	serrbuf[BUFSIZ];

d150 2
a151 1
	setbuf(stderr, serrbuf);
@


1.47
log
@If no patch can be found in input, in addition to complaining on stderr,
have the exit code indicate failure, not success.

Discrepancy with GNU patch pointed out by Arfrever Frehtes Taifersar Arahesis.

Help from and ok djm@@, "sounds good to me" millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: patch.c,v 1.46 2008/08/20 18:28:46 otto Exp $	*/
a27 4

#ifndef lint
static const char rcsid[] = "$OpenBSD: patch.c,v 1.46 2008/08/20 18:28:46 otto Exp $";
#endif /* not lint */
@


1.46
log
@The code to detect multiple applied diffs to empty files I introduced 4
years ago is not correct if the diff has an empty context for other
reasons, so revert that change. Problem found by Joerg Sonnenberger;
ok tedu@@ millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: patch.c,v 1.45 2007/04/18 21:52:24 sobrado Exp $	*/
d30 1
a30 1
static const char rcsid[] = "$OpenBSD: patch.c,v 1.45 2007/04/18 21:52:24 sobrado Exp $";
d152 1
d212 1
d216 2
d404 4
@


1.45
log
@adds a detailed synopsis to the man page; sorts options in
the description list and adds missing arguments; syncs usage()

written with a lot of useful advice by jmc@@

ok by jmc@@
@
text
@d1 1
a1 1
/*	$OpenBSD: patch.c,v 1.44 2006/03/11 19:41:30 otto Exp $	*/
d30 1
a30 1
static const char rcsid[] = "$OpenBSD: patch.c,v 1.44 2006/03/11 19:41:30 otto Exp $";
d634 1
a634 7
		if (diff_type == CONTEXT_DIFF
		    || diff_type == NEW_CONTEXT_DIFF
		    || diff_type == UNI_DIFF) {
			if (fuzz == 0)
				return (input_lines == 0 ? first_guess : 0);
		} else
			return (first_guess);
@


1.44
log
@type police and assorted cleanup. From Lionel Fourquaux; ok ray@@
@
text
@d1 1
a1 1
/*	$OpenBSD: patch.c,v 1.43 2004/11/19 20:08:11 otto Exp $	*/
d30 1
a30 1
static const char rcsid[] = "$OpenBSD: patch.c,v 1.43 2004/11/19 20:08:11 otto Exp $";
d608 1
a608 1
"usage: patch [-bcCeEflnNRstuv] [-B backup-prefix] [-d directory] [-D symbol]\n"
d610 3
a612 2
"             [-r rej-name] [-V {numbered,existing,simple}] [-z backup-ext]\n"
"             [origfile [patchfile]]\n");
@


1.43
log
@Write reject file in unified format if the original diff was in
unified format.
ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: patch.c,v 1.42 2004/09/14 23:54:21 deraadt Exp $	*/
d30 1
a30 1
static const char rcsid[] = "$OpenBSD: patch.c,v 1.42 2004/09/14 23:54:21 deraadt Exp $";
d51 1
a51 1
int		filemode = 0644;
@


1.42
log
@remove unused variable
@
text
@d1 1
a1 1
/*	$OpenBSD: patch.c,v 1.41 2004/07/09 19:13:46 otto Exp $	*/
d30 1
a30 1
static const char rcsid[] = "$OpenBSD: patch.c,v 1.41 2004/07/09 19:13:46 otto Exp $";
d94 2
d673 1
a673 1
abort_hunk(void)
d719 79
a797 1
			fatal("fatal internal error in abort_hunk\n");
@


1.41
log
@Properly detect if a patch already has been applied, even if there
are no eols at eofs involved. Tested by quite some people.

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: patch.c,v 1.40 2004/06/18 17:52:25 otto Exp $	*/
d30 1
a30 1
static const char rcsid[] = "$OpenBSD: patch.c,v 1.40 2004/06/18 17:52:25 otto Exp $";
d149 1
a149 1
	int	error = 0, hunk, failed, patch_seen = 0, i, fd;
a212 1
		patch_seen = true;
@


1.40
log
@Unbreak handling of standard diffs (which have an empty context).

ok @@millert
@
text
@d1 1
a1 1
/*	$OpenBSD: patch.c,v 1.39 2004/06/14 18:26:33 otto Exp $	*/
d30 1
a30 1
static const char rcsid[] = "$OpenBSD: patch.c,v 1.39 2004/06/14 18:26:33 otto Exp $";
d932 15
@


1.39
log
@Teach patch(1) to detect if a diff creating a file (or one adding
lines to an empty file) already has been applied; be a bit less
chatty about empty contexts. Testing hshoexer@@ ok millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: patch.c,v 1.38 2003/10/31 20:20:45 millert Exp $	*/
d30 1
a30 1
static const char rcsid[] = "$OpenBSD: patch.c,v 1.38 2003/10/31 20:20:45 millert Exp $";
d632 7
a638 2
		if (fuzz == 0)
			return (input_lines == 0 ? first_guess : 0);
@


1.38
log
@o fairly major man page reorganization
o add --posix option for strict POSIX conformance
o change filename determination to match GNU patch
Tested by various people, including a full ports build by naddy@@
@
text
@d1 1
a1 1
/*	$OpenBSD: patch.c,v 1.37 2003/08/10 21:28:48 otto Exp $	*/
d30 1
a30 1
static const char rcsid[] = "$OpenBSD: patch.c,v 1.37 2003/08/10 21:28:48 otto Exp $";
d627 1
a627 1
		if (verbose && (diff_type == CONTEXT_DIFF
a630 1
			say("Detection of previously applied patch not possible.\n");
d632 2
a633 1
		return first_guess;
@


1.37
log
@Do not add an extra newline at the end if the last line of the input
file contains no newline and the diff does not touch the last line.
Contributions from millert@@.

ok millert@@ tedu@@
@
text
@d1 1
a1 1
/*	$OpenBSD: patch.c,v 1.36 2003/08/10 18:39:43 otto Exp $	*/
d30 1
a30 1
static const char rcsid[] = "$OpenBSD: patch.c,v 1.36 2003/08/10 18:39:43 otto Exp $";
d89 1
d200 3
a202 4
		v = getenv("VERSION_CONTROL");
#ifdef notyet
		if (v != NULL)
#endif
d468 1
a481 1
#ifdef notyet
a483 1
#endif
d580 2
a581 1
			usage();
d598 3
@


1.36
log
@Warn if the diff is a context or unified diff and the context
is empty. In this case, a previously applied patch cannot be detected.

ok millert@@ tedu@@
@
text
@d1 1
a1 1
/*	$OpenBSD: patch.c,v 1.35 2003/08/01 20:30:48 otto Exp $	*/
d30 1
a30 1
static const char rcsid[] = "$OpenBSD: patch.c,v 1.35 2003/08/01 20:30:48 otto Exp $";
d71 1
d97 1
a97 1
static void	copy_till(LINENUM);
d99 1
a99 1
static void	dump_line(LINENUM);
d736 1
a736 1
			copy_till(where + old - 1);
d752 1
a752 1
			copy_till(where + old - 1);
d774 1
a774 1
			copy_till(where + old - 1);
d806 1
a806 1
		copy_till(where + old - 1);
d850 2
d854 1
a854 1
copy_till(LINENUM lastline)
d858 6
a863 2
	while (last_frozen_line < lastline)
		dump_line(++last_frozen_line);
d877 1
a877 1
		copy_till(input_lines);	/* dump remainder of file */
d886 1
a886 1
dump_line(LINENUM line)
d894 4
a897 2
	for (; putc(*s, ofp) != '\n'; s++)
		;
@


1.35
log
@- use stdbool.h instead of roll-your-own booleans
- fix some -Wall warnings
- fix asserts: in some cases remove them, in other cases they have
become Internal errors or detection of malformed patch files.
- fix some free() related code

ok millert@@ tedu@@
@
text
@d1 1
a1 1
/*	$OpenBSD: patch.c,v 1.34 2003/07/31 21:07:35 millert Exp $	*/
d30 1
a30 1
static const char rcsid[] = "$OpenBSD: patch.c,v 1.34 2003/07/31 21:07:35 millert Exp $";
d622 7
a628 1
	if (pat_lines == 0)		/* null range matches always */
d630 1
@


1.34
log
@Historically, patch would treat a bare -p as -p0.  This contradicts
POSIX and GNU patch has also removed this, so we will too.  No
objections on icb (no one even seemed to know about this "feature").
@
text
@d1 1
a1 1
/*	$OpenBSD: patch.c,v 1.33 2003/07/31 14:10:21 otto Exp $	*/
d30 1
a30 1
static const char rcsid[] = "$OpenBSD: patch.c,v 1.33 2003/07/31 14:10:21 otto Exp $";
a36 1
#include <assert.h>
d55 2
a56 2
bool		using_plan_a = TRUE;	/* try to keep everything in memory */
bool		out_of_mem = FALSE;	/* ran out of memory in plan a */
d61 1
a61 1
bool		ok_to_create_file = FALSE;
d68 2
a69 2
bool		toutkeep = FALSE;
bool		trejkeep = FALSE;
d76 6
a81 6
bool		force = FALSE;
bool		batch = FALSE;
bool		verbose = TRUE;
bool		reverse = FALSE;
bool		noreverse = FALSE;
bool		skip_rest_of_patch = FALSE;
d83 2
a84 2
bool		canonicalize = FALSE;
bool		check_only = FALSE;
d103 2
a104 2
/* TRUE if -E was specified on command line.  */
static int	remove_empty_files = FALSE;
d106 2
a107 2
/* TRUE if -R was specified on command line.  */
static int	reverse_flag_specified = FALSE;
d131 1
a131 1
static bool		do_defines = FALSE;
d148 1
a148 1
	LINENUM	where, newwhere, fuzz, mymaxfuzz;
d212 2
a213 2
		patch_seen = TRUE;
		warn_on_invalid_line = TRUE;
d240 1
a240 1
		out_of_mem = FALSE;
d272 1
a272 1
							skip_rest_of_patch = TRUE;
d285 1
a285 1
									skip_rest_of_patch = TRUE;
d343 2
a344 1
		assert(hunk);
d358 1
a358 1
					toutkeep = TRUE;
d394 1
a394 1
				trejkeep = TRUE;
d414 1
a414 1
	if (filearg[0] != NULL && !out_of_mem) {
d418 4
a421 4
	if (outname != NULL) {
		free(outname);
		outname = NULL;
	}
d423 1
d425 2
a426 1
	diff_type = 0;
a427 4
	if (revision != NULL) {
		free(revision);
		revision = NULL;
	}
d429 1
a429 1
	skip_rest_of_patch = FALSE;
d501 1
a501 1
			check_only = TRUE;
d508 1
a508 1
			do_defines = TRUE;
d522 1
a522 1
			remove_empty_files = TRUE;
d525 1
a525 1
			force = TRUE;
d536 1
a536 1
			canonicalize = TRUE;
d542 1
a542 1
			noreverse = TRUE;
d556 2
a557 2
			reverse = TRUE;
			reverse_flag_specified = TRUE;
d560 1
a560 1
			verbose = FALSE;
d563 1
a563 1
			batch = TRUE;
d787 2
a788 1
			assert(pch_char(new) == ' ');
d900 1
a900 1
			return FALSE;
d905 1
a905 1
				return FALSE;
d907 1
a907 1
			return FALSE;
d909 1
a909 1
	return TRUE;
d921 1
a921 1
				return FALSE;
d929 1
a929 1
			return FALSE;
d933 1
a933 1
	return TRUE;		/* actually, this is not reached */
@


1.33
log
@Print a maximum of one invalid line number warning per patch in a patch file.
Thanks to espie@@ for spotting the problem.

ok millert@@ henning@@ espie@@
@
text
@d1 1
a1 1
/*	$OpenBSD: patch.c,v 1.32 2003/07/30 16:45:44 millert Exp $	*/
d30 1
a30 1
static const char rcsid[] = "$OpenBSD: patch.c,v 1.32 2003/07/30 16:45:44 millert Exp $";
d441 1
a441 1
	const char *options = "b::B:cCd:D:eEfF:i:lnNo:p::r:RstuvV:x:z:";
d464 1
a464 1
		{"strip",		optional_argument,	0,	'p'},
d550 1
a550 1
			strippath = optarg ? atoi(optarg) : 0;
d606 1
a606 1
"             [-Fmax-fuzz] [-i patchfile] [-o out-file] [-p[strip-count]]\n"
@


1.32
log
@Add POSIX -i option; tedu@@ OK
@
text
@d1 1
a1 1
/*	$OpenBSD: patch.c,v 1.31 2003/07/29 20:10:17 millert Exp $	*/
d30 1
a30 1
static const char rcsid[] = "$OpenBSD: patch.c,v 1.31 2003/07/29 20:10:17 millert Exp $";
d71 1
d214 1
@


1.31
log
@o add pathnames.h
o ignore empty TMPDIR environment variable
o strip any trailing slashes from TMPDIR
otto@@ OK
@
text
@d1 1
a1 1
/*	$OpenBSD: patch.c,v 1.30 2003/07/28 19:15:34 deraadt Exp $	*/
d30 1
a30 1
static const char rcsid[] = "$OpenBSD: patch.c,v 1.30 2003/07/28 19:15:34 deraadt Exp $";
d439 1
a439 1
	const char *options = "b::B:cCd:D:eEfF:lnNo:p::r:RstuvV:x:z:";
d452 1
d530 5
d587 2
a588 4
	while (Argc > 0) {
		if (filec == MAXFILEC)
			fatal("too many file arguments\n");
		filearg[filec++] = savestr(*Argv++);
d590 6
d604 2
a605 2
"             [-Fmax-fuzz] [-o out-file] [-p[strip-count]] [-r rej-name]\n"
"             [-V {numbered,existing,simple}] [-z backup-ext]\n"
@


1.30
log
@minor knf and cleanups; otto ok
@
text
@d1 1
a1 1
/*	$OpenBSD: patch.c,v 1.29 2003/07/28 18:28:52 otto Exp $	*/
d30 1
a30 1
static const char rcsid[] = "$OpenBSD: patch.c,v 1.29 2003/07/28 18:28:52 otto Exp $";
d50 1
d147 1
a147 1
	int	error = 0, hunk, failed, patch_seen = 0, i;
d149 2
a150 1
	char	*tmpdir, *v;
d157 6
a162 5
	tmpdir = getenv("TMPDIR");
	if (tmpdir == NULL) {
		tmpdir = "/tmp";
	}
	if (asprintf(&TMPOUTNAME, "%s/patchoXXXXXXXXXX", tmpdir) == -1)
d164 1
a164 1
	if ((i = mkstemp(TMPOUTNAME)) < 0)
d166 1
a166 1
	close(i);
d168 1
a168 1
	if (asprintf(&TMPINNAME, "%s/patchiXXXXXXXXXX", tmpdir) == -1)
d170 1
a170 1
	if ((i = mkstemp(TMPINNAME)) < 0)
d172 1
a172 1
	close(i);
d174 1
a174 1
	if (asprintf(&TMPREJNAME, "%s/patchrXXXXXXXXXX", tmpdir) == -1)
d176 1
a176 1
	if ((i = mkstemp(TMPREJNAME)) < 0)
d178 1
a178 1
	close(i);
d180 1
a180 1
	if (asprintf(&TMPPATNAME, "%s/patchpXXXXXXXXXX", tmpdir) == -1)
d182 1
a182 1
	if ((i = mkstemp(TMPPATNAME)) < 0)
d184 1
a184 1
	close(i);
@


1.29
log
@Be more exact on how backup files are handled.
ok millert@@ tedu@@
@
text
@d1 1
a1 1
/*	$OpenBSD: patch.c,v 1.28 2003/07/28 16:13:53 millert Exp $	*/
d30 1
a30 1
static const char rcsid[] = "$OpenBSD: patch.c,v 1.28 2003/07/28 16:13:53 millert Exp $";
d51 1
a51 1
int 		filemode = 0644;
d72 1
a72 1
int 		debug = 0;
d291 1
a291 1
					 ++fuzz <= mymaxfuzz);
d865 1
a865 1
	/* Note: string is not null terminated. */
d880 2
a881 2
	const char 	*plineptr;
	short 		plinelen;
@


1.28
log
@Make patch(1) exit value match POSIX and be consistent with diff.
Comments and OK from otto@@
@
text
@d1 1
a1 1
/*	$OpenBSD: patch.c,v 1.27 2003/07/25 02:12:45 millert Exp $	*/
d30 1
a30 1
static const char rcsid[] = "$OpenBSD: patch.c,v 1.27 2003/07/25 02:12:45 millert Exp $";
d41 1
a44 1
#include "INTERN.h"
a45 1
#include "EXTERN.h"
d51 36
d93 2
a94 2
static void	init_output(char *);
static void	init_reject(char *);
d99 1
a99 1
static bool	similar(char *, char *, int);
d114 26
a153 2
	myuid = getuid();

d239 1
a239 1
			fuzz = NULL;
d246 1
a246 1
					if (hunk == 1 && where == NULL && !force) {
d249 1
a249 1
							if (fuzz == NULL)
d256 1
a256 1
						if (where == NULL) {
d282 1
a282 1
								where = NULL;
d290 1
a290 1
				} while (!skip_rest_of_patch && where == NULL &&
d305 1
a305 1
			} else if (where == NULL) {
d316 1
a316 1
					if (fuzz)
d373 1
a373 1
			if (!*rejname) {
d609 1
a609 1
	if (!pat_lines)		/* null range matches always */
d613 1
a613 1
	if (first_guess <= input_lines && patch_match(first_guess, NULL, fuzz))
d636 1
a636 1
			return NULL;
d646 1
a646 1
	LINENUM	pat_end = pch_end();
d651 6
a656 6
	LINENUM	oldfirst = pch_first() + last_offset;
	LINENUM	newfirst = pch_newfirst() + last_offset;
	LINENUM	oldlast = oldfirst + pch_ptrn_lines() - 1;
	LINENUM	newlast = newfirst + pch_repl_lines() - 1;
	char	*stars = (diff_type >= NEW_CONTEXT_DIFF ? " ****" : "");
	char	*minuses = (diff_type >= NEW_CONTEXT_DIFF ? " ----" : " -----");
d699 3
a701 3
	LINENUM	old = 1;
	LINENUM	lastline = pch_ptrn_lines();
	LINENUM	new = lastline + 1;
d706 2
a707 3
	int	def_state = OUTSIDE;
	bool	R_do_defines = do_defines;
	LINENUM	pat_end = pch_end();
d716 1
a716 1
			if (R_do_defines) {
d732 1
a732 1
			if (R_do_defines) {
d754 1
a754 1
			if (R_do_defines) {
d759 1
a759 1
				if (R_do_defines) {
d765 1
a765 1
			if (R_do_defines) {
d777 1
a777 1
			if (R_do_defines && def_state != OUTSIDE) {
d785 1
a785 1
		if (R_do_defines) {
d799 1
a799 1
	if (R_do_defines && def_state != OUTSIDE) {
d808 1
a808 1
init_output(char *name)
d819 1
a819 1
init_reject(char *name)
d832 1
a832 3
	LINENUM	R_last_frozen_line = last_frozen_line;

	if (R_last_frozen_line > lastline)
d834 2
a835 3
	while (R_last_frozen_line < lastline)
		dump_line(++R_last_frozen_line);
	last_frozen_line = R_last_frozen_line;
d860 1
a860 1
	char	*s, R_newline = '\n';
d866 1
a866 1
	for (; putc(*s, ofp) != R_newline; s++)
d876 6
a881 6
	LINENUM	pline = 1 + fuzz;
	LINENUM	iline;
	LINENUM	pat_lines = pch_ptrn_lines() - fuzz;
	char *ilineptr;
	char *plineptr;
	short plinelen;
d902 1
a902 1
similar(char *a, char *b, int len)
@


1.27
log
@Add POSIX -b option but don't change the default beahvior wrt backups
yet.  The old -b option is now -z (matches GNU patch).
@
text
@d1 1
a1 1
/*	$OpenBSD: patch.c,v 1.26 2003/07/23 07:31:21 otto Exp $	*/
d30 1
a30 1
static const char rcsid[] = "$OpenBSD: patch.c,v 1.26 2003/07/23 07:31:21 otto Exp $";
d85 1
a85 1
	int	hunk = 0, failed = 0, failtotal = 0, patch_seen = 0, i;
d313 1
a313 1
			failtotal += failed;
d334 1
a334 3
	if (!patch_seen)
		failtotal++;
	my_exit(failtotal);
d535 1
a535 1
	my_exit(1);
d693 1
a693 1
			my_exit(1);
@


1.26
log
@New version of invalid line number fix. Passes patch(1) regressions.

ok millert@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: patch.c,v 1.25 2003/07/22 20:48:58 millert Exp $	*/
d30 1
a30 1
static const char rcsid[] = "$OpenBSD: patch.c,v 1.25 2003/07/22 20:48:58 millert Exp $";
a129 3
	v = getenv("VERSION_CONTROL");
	backup_type = get_version(v);	/* OK to pass NULL. */

d135 8
d379 1
a379 1
	const char *options = "b:B:cCd:D:eEfF:lnNo:p::r:RstuvV:x:";
d381 1
d402 1
a402 1
		{"suffix",		required_argument,	0,	'b'},
d419 12
d533 3
a535 3
"usage: patch [-cCeEflnNRstuv] [-b backup-ext] [-B backup-prefix] [-d directory]\n"
"             [-D symbol] [-Fmax-fuzz] [-o out-file] [-p[strip-count]]\n"
"             [-r rej-name] [-V {numbered,existing,simple}]\n"
@


1.25
log
@Make rejname[] static to patch.c and crank its size to NAME_MAX+1
@
text
@d1 1
a1 1
/*	$OpenBSD: patch.c,v 1.24 2003/07/22 20:17:06 millert Exp $	*/
d30 1
a30 1
static const char rcsid[] = "$OpenBSD: patch.c,v 1.24 2003/07/22 20:17:06 millert Exp $";
d791 3
d795 1
a795 1
	for (s=ifetch(line, 0); putc(*s, ofp) != R_newline; s++)
d808 3
d813 5
d819 1
a819 2
			if (!similar(ifetch(iline, (offset >= 0)),
			    pfetch(pline), pch_line_len(pline)))
d821 1
a821 2
		} else if (strnNE(ifetch(iline, (offset >= 0)),
		    pfetch(pline), pch_line_len(pline)))
@


1.24
log
@Use getopt_long() to parse options instead of rolling our own.
OK deraadt@@ and otto@@
@
text
@d1 1
a1 1
/*	$OpenBSD: patch.c,v 1.23 2003/07/22 17:18:49 otto Exp $	*/
d30 1
a30 1
static const char rcsid[] = "$OpenBSD: patch.c,v 1.23 2003/07/22 17:18:49 otto Exp $";
d40 1
d73 4
a76 1
 /* buffer for stderr */
d78 1
@


1.23
log
@More cleanup.
ok millert@@ tedu@@
@
text
@d1 1
a1 1
/*	$OpenBSD: patch.c,v 1.22 2003/07/21 21:01:45 otto Exp $	*/
d30 1
a30 1
static const char rcsid[] = "$OpenBSD: patch.c,v 1.22 2003/07/21 21:01:45 otto Exp $";
d39 1
d64 1
a64 2
static int	optcmp(const void *, const void *);
static char	decode_long_option(char *);
a361 11

	if (filec >= 2)
		fatal("you may not change to a different patch file\n");
}

static char *
nextarg(void)
{
	if (!--Argc)
		fatal("missing argument after `%s'\n", *Argv);
	return *++Argv;
d364 1
a364 61
/* Module for handling of long options.  */

struct option {
	char	*long_opt;
	char	short_opt;
};

static int
optcmp(const void *v1, const void *v2)
{
	const struct option *a = v1, *b = v2;

	return strcmp(a->long_opt, b->long_opt);
}

/* Decode Long options beginning with "--" to their short equivalents.  */

static char
decode_long_option(char *opt)
{
	/*
	 * This table must be sorted on the first field.  We also decode
	 * unimplemented options as those will be handled later anyway.
	 */
	static struct option options[] = {
		{"batch", 't'},
		{"check", 'C'},
		{"context", 'c'},
		{"debug", 'x'},
		{"directory", 'd'},
		{"ed", 'e'},
		{"force", 'f'},
		{"forward", 'N'},
		{"fuzz", 'F'},
		{"ifdef", 'D'},
		{"ignore-whitespace", 'l'},
		{"normal", 'n'},
		{"output", 'o'},
		{"prefix", 'B'},
		{"quiet", 's'},
		{"reject-file", 'r'},
		{"remove-empty-files", 'E'},
		{"reverse", 'R'},
		{"silent", 's'},
		{"skip", 'S'},
		{"strip", 'p'},
		{"suffix", 'b'},
		{"unified", 'u'},
		{"version", 'v'},
		{"version-control", 'V'},
	};
	struct option   key, *found;

	key.long_opt = opt;
	found = (struct option *) bsearch(&key, options,
	    sizeof(options) / sizeof(options[0]),
	    sizeof(options[0]), optcmp);
	return found ? found->short_opt : '\0';
}

/* Process switches and filenames up to next '+' or end of list. */
d369 29
a397 1
	char	*s;
d404 81
a484 111
	for (Argc--, Argv++; Argc; Argc--, Argv++) {
		s = Argv[0];
		if (strEQ(s, "+")) {
			return;	/* + will be skipped by for loop */
		}
		if (*s != '-' || !s[1]) {
			if (filec == MAXFILEC)
				fatal("too many file arguments\n");
			filearg[filec++] = savestr(s);
		} else {
			char	opt;

			if (*(s + 1) == '-') {
				opt = decode_long_option(s + 2);
				s += strlen(s) - 1;
			} else
				opt = *++s;
			switch (opt) {
			case 'b':
				simple_backup_suffix = savestr(nextarg());
				break;
			case 'B':
				origprae = savestr(nextarg());
				break;
			case 'c':
				diff_type = CONTEXT_DIFF;
				break;
			case 'C':
				check_only = TRUE;
				break;
			case 'd':
				if (!*++s)
					s = nextarg();
				if (chdir(s) < 0)
					pfatal("can't cd to %s", s);
				break;
			case 'D':
				do_defines = TRUE;
				if (!*++s)
					s = nextarg();
				if (!isalpha(*s) && '_' != *s)
					fatal("argument to -D is not an identifier\n");
				snprintf(if_defined, sizeof if_defined,
				    "#ifdef %s\n", s);
				snprintf(not_defined, sizeof not_defined,
				    "#ifndef %s\n", s);
				snprintf(end_defined, sizeof end_defined,
				    "#endif /* %s */\n", s);
				break;
			case 'e':
				diff_type = ED_DIFF;
				break;
			case 'E':
				remove_empty_files = TRUE;
				break;
			case 'f':
				force = TRUE;
				break;
			case 'F':
				if (!*++s)
					s = nextarg();
				else if (*s == '=')
					s++;
				maxfuzz = atoi(s);
				break;
			case 'l':
				canonicalize = TRUE;
				break;
			case 'n':
				diff_type = NORMAL_DIFF;
				break;
			case 'N':
				noreverse = TRUE;
				break;
			case 'o':
				outname = savestr(nextarg());
				break;
			case 'p':
				if (!*++s)
					s = nextarg();
				else if (*s == '=')
					s++;
				strippath = atoi(s);
				break;
			case 'r':
				if (strlcpy(rejname, nextarg(),
				    sizeof(rejname)) >= sizeof(rejname))
					fatal("argument for -r is too long\n");
				break;
			case 'R':
				reverse = TRUE;
				reverse_flag_specified = TRUE;
				break;
			case 's':
				verbose = FALSE;
				break;
			case 'S':
				skip_rest_of_patch = TRUE;
				break;
			case 't':
				batch = TRUE;
				break;
			case 'u':
				diff_type = UNI_DIFF;
				break;
			case 'v':
				version();
				break;
			case 'V':
				backup_type = get_version(nextarg());
				break;
d486 3
a488 5
			case 'x':
				if (!*++s)
					s = nextarg();
				debug = atoi(s);
				break;
d490 3
a492 11
			default:
				fprintf(stderr, "patch: unrecognized option `%s'\n",
				    Argv[0]);
				fprintf(stderr, "\
Usage: patch [options] [origfile [patchfile]] [+ [options] [origfile]]...\n\
Options:\n\
       [-cCeEflnNRsStuv] [-b backup-ext] [-B backup-prefix] [-d directory]\n\
       [-D symbol] [-Fmax-fuzz] [-o out-file] [-p[strip-count]]\n\
       [-r rej-name] [-V {numbered,existing,simple}]\n");
				my_exit(1);
			}
d495 20
@


1.22
log
@Back out invalid line number fix. It core dumps in some cases. Problem found by
marc@@.
ok henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: patch.c,v 1.21 2003/07/21 14:32:21 deraadt Exp $	*/
d30 1
a30 1
static char rcsid[] = "$OpenBSD: patch.c,v 1.21 2003/07/21 14:32:21 deraadt Exp $";
d33 9
d50 15
a64 16
void	reinitialize_almost_everything(void);
void	get_some_switches(void);
LINENUM	locate_hunk(LINENUM);
void	abort_hunk(void);
void	apply_hunk(LINENUM);
void	init_output(char *);
void	init_reject(char *);
void	copy_till(LINENUM);
void	spew_output(void);
void	dump_line(LINENUM);
bool	patch_match(LINENUM, LINENUM, LINENUM);
bool	similar(char *, char *, int);
void	re_input(void);
void	my_exit(int) __attribute__((noreturn));
int	optcmp(const void *, const void *);
char	decode_long_option(char *);
d72 2
a73 2
/* TRUE if -C was specified on command line.  */
bool	check_only = FALSE;
d86 1
a86 1
		filearg[i] = Nullch;
d142 1
a142 1
		if (outname == Nullch)
d170 1
a170 1
			fuzz = Nulline;
d177 1
a177 1
					if (hunk == 1 && where == Nulline && !force) {
d180 1
a180 1
							if (fuzz == Nulline)
d187 1
a187 1
						if (where == Nulline) {
d213 1
a213 1
								where = Nulline;
d221 1
a221 1
				} while (!skip_rest_of_patch && where == Nulline &&
d226 1
a226 1
					ofp = Nullfp;
d236 1
a236 1
			} else if (where == Nulline) {
d264 1
a264 1
			ofp = Nullfp;
d267 1
a267 1
			rejfp = Nullfp;
d301 1
a301 1
		rejfp = Nullfp;
d332 1
a332 1
void
d342 1
a342 1
	if (filearg[0] != Nullch && !out_of_mem) {
d344 1
a344 1
		filearg[0] = Nullch;
d346 1
a346 1
	if (outname != Nullch) {
d348 1
a348 1
		outname = Nullch;
d354 1
a354 1
	if (revision != Nullch) {
d356 1
a356 1
		revision = Nullch;
d382 1
a382 1
int
d392 1
a392 1
char
d437 1
a437 1
void
d583 1
a583 1
LINENUM
d596 1
a596 1
	if (first_guess <= input_lines && patch_match(first_guess, Nulline, fuzz))
d619 1
a619 1
			return Nulline;
d625 1
a625 1
void
d679 1
a679 1
void
d791 1
a791 1
void
d795 1
a795 1
	if (ofp == Nullfp)
d802 1
a802 1
void
d806 1
a806 1
	if (rejfp == Nullfp)
d813 1
a813 1
void
d828 1
a828 1
void
d838 1
a838 1
	ofp = Nullfp;
d844 1
a844 1
void
d857 1
a857 1
bool
d879 1
a879 1
bool
a898 15
}

/*
 * Exit with cleanup.
 */
void
my_exit(int status)
{
	unlink(TMPINNAME);
	if (!toutkeep)
		unlink(TMPOUTNAME);
	if (!trejkeep)
		unlink(TMPREJNAME);
	unlink(TMPPATNAME);
	exit(status);
@


1.21
log
@fix header
@
text
@d1 1
a1 1
/*	$OpenBSD: patch.c,v 1.20 2003/07/21 14:00:41 deraadt Exp $	*/
d30 1
a30 1
static char rcsid[] = "$OpenBSD: patch.c,v 1.20 2003/07/21 14:00:41 deraadt Exp $";
a840 3
	s = ifetch(line, 0);
	if (s == NULL)
		return;
d842 1
a842 1
	for (; putc(*s, ofp) != R_newline; s++)
a873 2
	if (a == NULL || b == NULL)
		return FALSE;
@


1.20
log
@knf and other cleanup; ok otto
@
text
@d1 1
a1 1
/* $OpenBSD: patch.c,v 1.19 2003/07/18 02:00:09 deraadt Exp $	 */
d30 1
a30 1
static char rcsid[] = "$OpenBSD: patch.c,v 1.19 2003/07/18 02:00:09 deraadt Exp $";
@


1.19
log
@remove junk; ok otto tedu
@
text
@d1 1
a1 1
/*	$OpenBSD: patch.c,v 1.18 2003/07/16 16:06:53 otto Exp $	*/
d3 3
a5 2
/* patch - a program to apply diffs to original files
 *
d7 1
a7 1
 *
d9 12
a20 13
 * modification, are permitted provided that the following condition
 * is met:
 *  1. Redistributions of source code must retain the above copyright
 *     notice, this condition and the following disclaimer.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
d24 3
a26 3
 *
 * -C option added in 1998, original code by Marc Espie,
 * based on FreeBSD behaviour
d30 1
a30 1
static char rcsid[] = "$OpenBSD: patch.c,v 1.18 2003/07/16 16:06:53 otto Exp $";
d41 16
a56 18
/* procedures */

void reinitialize_almost_everything(void);
void get_some_switches(void);
LINENUM locate_hunk(LINENUM);
void abort_hunk(void);
void apply_hunk(LINENUM);
void init_output(char *);
void init_reject(char *);
void copy_till(LINENUM);
void spew_output(void);
void dump_line(LINENUM);
bool patch_match(LINENUM, LINENUM, LINENUM);
bool similar(char *, char *, int);
void re_input(void);
void my_exit(int) __attribute__((noreturn));
int optcmp(const void *, const void *);
char decode_long_option(char *);
d59 1
a59 1
static int remove_empty_files = FALSE;
d62 1
a62 1
static int reverse_flag_specified = FALSE;
d65 1
a65 1
bool check_only = FALSE;
d72 64
a135 64
    LINENUM where;
    LINENUM newwhere;
    LINENUM fuzz;
    LINENUM mymaxfuzz;
    int hunk = 0;
    int failed = 0;
    int failtotal = 0;
    int patch_seen = 0;
    int i;

    setbuf(stderr, serrbuf);
    for (i = 0; i<MAXFILEC; i++)
	filearg[i] = Nullch;

    myuid = getuid();

    /* Cons up the names of the temporary files.  */
    {
      /* Directory for temporary files.  */
      char *tmpdir;

      tmpdir = getenv ("TMPDIR");
      if (tmpdir == NULL) {
	tmpdir = "/tmp";
      }

      if (asprintf(&TMPOUTNAME, "%s/patchoXXXXXXXXXX", tmpdir) == -1)
	fatal("cannot allocate memory");
      if ((i = mkstemp(TMPOUTNAME)) < 0)
	pfatal("can't create %s", TMPOUTNAME);
      close(i);

      if (asprintf(&TMPINNAME, "%s/patchiXXXXXXXXXX", tmpdir) == -1)
	fatal("cannot allocate memory");
      if ((i = mkstemp(TMPINNAME)) < 0)
	pfatal("can't create %s", TMPINNAME);
      close(i);

      if (asprintf(&TMPREJNAME, "%s/patchrXXXXXXXXXX", tmpdir) == -1)
	fatal("cannot allocate memory");
      if ((i = mkstemp(TMPREJNAME)) < 0)
	pfatal("can't create %s", TMPREJNAME);
      close(i);

      if (asprintf(&TMPPATNAME, "%s/patchpXXXXXXXXXX", tmpdir) == -1)
	fatal("cannot allocate memory");
      if ((i = mkstemp(TMPPATNAME)) < 0)
	pfatal("can't create %s", TMPPATNAME);
      close(i);
    }

    {
      char *v;

      v = getenv ("SIMPLE_BACKUP_SUFFIX");
      if (v)
	simple_backup_suffix = v;
      else
	simple_backup_suffix = ORIGEXT;
#ifndef NODIR
      v = getenv ("VERSION_CONTROL");
      backup_type = get_version (v); /* OK to pass NULL. */
#endif
    }
d137 33
a169 52
    /* parse switches */
    Argc = argc;
    Argv = argv;
    get_some_switches();

    /* make sure we clean up /tmp in case of disaster */
    set_signals(0);

    for (
	open_patch_file(filearg[1]);
	there_is_another_patch();
	reinitialize_almost_everything()
    ) {					/* for each patch in patch file */
	patch_seen = TRUE;

	if (outname == Nullch)
	    outname = savestr(filearg[0]);

	/* for ed script just up and do it and exit */
	if (diff_type == ED_DIFF) {
	    do_ed_script();
	    continue;
	}

	/* initialize the patched file */
	if (!skip_rest_of_patch)
	    init_output(TMPOUTNAME);

	/* initialize reject file */
	init_reject(TMPREJNAME);

	/* find out where all the lines are */
	if (!skip_rest_of_patch)
	    scan_input(filearg[0]);

	/* from here on, open no standard i/o files, because malloc */
	/* might misfire and we can't catch it easily */

	/* apply each hunk of patch */
	hunk = 0;
	failed = 0;
	out_of_mem = FALSE;
	while (another_hunk()) {
	    hunk++;
	    fuzz = Nulline;
	    mymaxfuzz = pch_context();
	    if (maxfuzz < mymaxfuzz)
		mymaxfuzz = maxfuzz;
	    if (!skip_rest_of_patch) {
		do {
		    where = locate_hunk(fuzz);
		    if (hunk == 1 && where == Nulline && !force) {
d171 90
a260 110
			if (!pch_swap()) {
			    if (fuzz == Nulline)
				say(
"Not enough memory to try swapped hunk!  Assuming unswapped.\n");
			    continue;
			}
			reverse = !reverse;
			where = locate_hunk(fuzz);  /* try again */
			if (where == Nulline) {	    /* didn't find it swapped */
			    if (!pch_swap())         /* put it back to normal */
				fatal("lost hunk on alloc error!\n");
			    reverse = !reverse;
			}
			else if (noreverse) {
			    if (!pch_swap())         /* put it back to normal */
				fatal("lost hunk on alloc error!\n");
			    reverse = !reverse;
			    say(
"Ignoring previously applied (or reversed) patch.\n");
			    skip_rest_of_patch = TRUE;
			}
			else if (batch) {
			    if (verbose)
				say(
"%seversed (or previously applied) patch detected!  %s -R.",
				reverse ? "R" : "Unr",
				reverse ? "Assuming" : "Ignoring");
			}
			else {
			    ask(
"%seversed (or previously applied) patch detected!  %s -R? [y] ",
				reverse ? "R" : "Unr",
				reverse ? "Assume" : "Ignore");
			    if (*buf == 'n') {
				ask("Apply anyway? [n] ");
				if (*buf != 'y')
				    skip_rest_of_patch = TRUE;
				where = Nulline;
				reverse = !reverse;
				if (!pch_swap())  /* put it back to normal */
				    fatal("lost hunk on alloc error!\n");
			    }
			}
		    }
		} while (!skip_rest_of_patch && where == Nulline &&
		    ++fuzz <= mymaxfuzz);

		if (skip_rest_of_patch) {		/* just got decided */
		    fclose(ofp);
		    ofp = Nullfp;
		}
	    }

	    newwhere = pch_newfirst() + last_offset;
	    if (skip_rest_of_patch) {
		abort_hunk();
		failed++;
		if (verbose)
		    say("Hunk #%d ignored at %ld.\n", hunk, newwhere);
	    }
	    else if (where == Nulline) {
		abort_hunk();
		failed++;
		if (verbose)
		    say("Hunk #%d failed at %ld.\n", hunk, newwhere);
	    }
	    else {
		apply_hunk(where);
		if (verbose) {
		    say("Hunk #%d succeeded at %ld", hunk, newwhere);
		    if (fuzz)
			say(" with fuzz %ld", fuzz);
		    if (last_offset)
			say(" (offset %ld line%s)",
			    last_offset, last_offset==1L?"":"s");
		    say(".\n");
		}
	    }
	}

	if (out_of_mem && using_plan_a) {
	    Argc = Argc_last;
	    Argv = Argv_last;
	    say("\n\nRan out of memory using Plan A--trying again...\n\n");
	    if (ofp)
	        fclose(ofp);
	    ofp = Nullfp;
	    if (rejfp)
	        fclose(rejfp);
	    rejfp = Nullfp;
	    continue;
	}

	assert(hunk);

	/* finish spewing out the new file */
	if (!skip_rest_of_patch)
	    spew_output();

	/* and put the output where desired */
	ignore_signals();
	if (!skip_rest_of_patch) {
	    struct stat statbuf;
	    char *realout = outname;

	    if (!check_only) {
		if (move_file(TMPOUTNAME, outname) < 0) {
		    toutkeep = TRUE;
		    realout = TMPOUTNAME;
		    chmod(TMPOUTNAME, filemode);
d262 1
a262 2
		else
		    chmod(outname, filemode);
d264 56
a319 35
		if (remove_empty_files && stat(realout, &statbuf) == 0
		    && statbuf.st_size == 0) {
		    if (verbose)
			say("Removing %s (empty after patching).\n", realout);
		    while (unlink(realout) >= 0) ; /* while is for Eunice.  */
		}
	    }
	}
	fclose(rejfp);
	rejfp = Nullfp;
	if (failed) {
	    failtotal += failed;
	    if (!*rejname) {
		if (strlcpy(rejname, outname, sizeof(rejname)) >= sizeof(rejname))
		    fatal("filename %s is too long\n", outname);
		if (strlcat(rejname, REJEXT, sizeof(rejname)) >= sizeof(rejname))
		    fatal("filename %s is too long\n", outname);
	    }
	    if (skip_rest_of_patch) {
		say("%d out of %d hunks ignored--saving rejects to %s\n",
		    failed, hunk, rejname);
	    }
	    else {
		say("%d out of %d hunks failed--saving rejects to %s\n",
		    failed, hunk, rejname);
	    }
	    if (!check_only && move_file(TMPREJNAME, rejname) < 0)
		trejkeep = TRUE;
	}
	set_signals(1);
    }
    if (!patch_seen)
	failtotal++;
    my_exit(failtotal);
    /* NOTREACHED */
d325 1
a325 1
reinitialize_almost_everything()
d327 2
a328 2
    re_patch();
    re_input();
d330 2
a331 2
    input_lines = 0;
    last_frozen_line = 0;
d333 10
a342 5
    filec = 0;
    if (filearg[0] != Nullch && !out_of_mem) {
	free(filearg[0]);
	filearg[0] = Nullch;
    }
d344 1
a344 4
    if (outname != Nullch) {
	free(outname);
	outname = Nullch;
    }
d346 6
a351 11
    last_offset = 0;

    diff_type = 0;

    if (revision != Nullch) {
	free(revision);
	revision = Nullch;
    }

    reverse = reverse_flag_specified;
    skip_rest_of_patch = FALSE;
d353 1
a353 1
    get_some_switches();
d355 2
a356 2
    if (filec >= 2)
	fatal("you may not change to a different patch file\n");
d362 3
a364 3
    if (!--Argc)
	fatal("missing argument after `%s'\n", *Argv);
    return *++Argv;
d370 2
a371 2
    char *long_opt;
    char short_opt;
d377 1
a377 1
    const struct option *a = v1, *b = v2;
d379 1
a379 1
    return strcmp (a->long_opt, b->long_opt);
d387 38
a424 36
    /* This table must be sorted on the first field.  We also decode
       unimplemented options as those will be handled later anyway.  */
    static struct option options[] = {
      { "batch",		't' },
      { "check",		'C' },
      { "context",		'c' },
      { "debug",		'x' },
      { "directory",		'd' },
      { "ed",			'e' },
      { "force",		'f' },
      { "forward",		'N' },
      { "fuzz",			'F' },
      { "ifdef",		'D' },
      { "ignore-whitespace",	'l' },
      { "normal",		'n' },
      { "output",		'o' },
      { "prefix",		'B' },
      { "quiet",		's' },
      { "reject-file",		'r' },
      { "remove-empty-files",	'E' },
      { "reverse",		'R' },
      { "silent",		's' },
      { "skip",			'S' },
      { "strip",		'p' },
      { "suffix",		'b' },
      { "unified",		'u' },
      { "version",		'v' },
      { "version-control",	'V' },
    };
    struct option key, *found;

    key.long_opt = opt;
    found = (struct option *)bsearch(&key, options,
				     sizeof(options) / sizeof(options[0]),
				     sizeof(options[0]), optcmp);
    return found ? found->short_opt : '\0';
d430 1
a430 1
get_some_switches()
d432 1
a432 1
    char *s;
d434 116
a549 116
    rejname[0] = '\0';
    Argc_last = Argc;
    Argv_last = Argv;
    if (!Argc)
	return;
    for (Argc--,Argv++; Argc; Argc--,Argv++) {
	s = Argv[0];
	if (strEQ(s, "+")) {
	    return;			/* + will be skipped by for loop */
	}
	if (*s != '-' || !s[1]) {
	    if (filec == MAXFILEC)
		fatal("too many file arguments\n");
	    filearg[filec++] = savestr(s);
	}
	else {
	    char opt;

	    if (*(s + 1) == '-') {
	        opt = decode_long_option(s + 2);
		s += strlen(s) - 1;
	    }
	    else
	        opt = *++s;
	    switch (opt) {
	    case 'b':
		simple_backup_suffix = savestr(nextarg());
		break;
	    case 'B':
		origprae = savestr(nextarg());
		break;
	    case 'c':
		diff_type = CONTEXT_DIFF;
		break;
	    case 'C':
		check_only = TRUE;
		break;
	    case 'd':
		if (!*++s)
		    s = nextarg();
		if (chdir(s) < 0)
		    pfatal("can't cd to %s", s);
		break;
	    case 'D':
		do_defines = TRUE;
		if (!*++s)
		    s = nextarg();
		if (!isalpha(*s) && '_' != *s)
		    fatal("argument to -D is not an identifier\n");
		snprintf(if_defined, sizeof if_defined, "#ifdef %s\n", s);
		snprintf(not_defined, sizeof not_defined, "#ifndef %s\n", s);
		snprintf(end_defined, sizeof end_defined, "#endif /* %s */\n", s);
		break;
	    case 'e':
		diff_type = ED_DIFF;
		break;
	    case 'E':
		remove_empty_files = TRUE;
		break;
	    case 'f':
		force = TRUE;
		break;
	    case 'F':
		if (!*++s)
		    s = nextarg();
		else if (*s == '=')
		    s++;
		maxfuzz = atoi(s);
		break;
	    case 'l':
		canonicalize = TRUE;
		break;
	    case 'n':
		diff_type = NORMAL_DIFF;
		break;
	    case 'N':
		noreverse = TRUE;
		break;
	    case 'o':
		outname = savestr(nextarg());
		break;
	    case 'p':
		if (!*++s)
		    s = nextarg();
		else if (*s == '=')
		    s++;
		strippath = atoi(s);
		break;
	    case 'r':
		if (strlcpy(rejname, nextarg(), sizeof(rejname)) >= sizeof(rejname))
		    fatal("argument for -r is too long\n");
		break;
	    case 'R':
		reverse = TRUE;
		reverse_flag_specified = TRUE;
		break;
	    case 's':
		verbose = FALSE;
		break;
	    case 'S':
		skip_rest_of_patch = TRUE;
		break;
	    case 't':
		batch = TRUE;
		break;
	    case 'u':
		diff_type = UNI_DIFF;
		break;
	    case 'v':
		version();
		break;
	    case 'V':
#ifndef NODIR
		backup_type = get_version (nextarg ());
#endif
		break;
d551 5
a555 5
	    case 'x':
		if (!*++s)
		    s = nextarg();
		debug = atoi(s);
		break;
d557 4
a560 3
	    default:
		fprintf(stderr, "patch: unrecognized option `%s'\n", Argv[0]);
		fprintf(stderr, "\
d566 3
a568 2
		my_exit(1);
	    }
a569 1
    }
d572 3
a574 2
/* Attempt to find the right place to apply this hunk of patch. */

d576 1
a576 2
locate_hunk(fuzz)
LINENUM fuzz;
d578 15
a592 17
    LINENUM first_guess = pch_first() + last_offset;
    LINENUM offset;
    LINENUM pat_lines = pch_ptrn_lines();
    LINENUM max_pos_offset = input_lines - first_guess
				- pat_lines + 1;
    LINENUM max_neg_offset = first_guess - last_frozen_line - 1
				+ pch_context();

    if (!pat_lines)			/* null range matches always */
	return first_guess;
    if (max_neg_offset >= first_guess)	/* do not try lines < 0 */
	max_neg_offset = first_guess - 1;
    if (first_guess <= input_lines && patch_match(first_guess, Nulline, fuzz))
	return first_guess;
    for (offset = 1; ; offset++) {
	bool check_after = (offset <= max_pos_offset);
	bool check_before = (offset <= max_neg_offset);
d594 1
a594 1
	if (check_after && patch_match(first_guess, offset, fuzz)) {
d596 3
a598 2
	    if (debug & 1)
		say("Offset changing from %ld to %ld\n", last_offset, offset);
d600 3
a602 4
	    last_offset = offset;
	    return first_guess+offset;
	}
	else if (check_before && patch_match(first_guess, -offset, fuzz)) {
d604 3
a606 2
	    if (debug & 1)
		say("Offset changing from %ld to %ld\n", last_offset, -offset);
d608 4
a611 2
	    last_offset = -offset;
	    return first_guess-offset;
a612 3
	else if (!check_before && !check_after)
	    return Nulline;
    }
d618 1
a618 1
abort_hunk()
d620 46
a665 37
    LINENUM i;
    LINENUM pat_end = pch_end();
    /* add in last_offset to guess the same as the previous successful hunk */
    LINENUM oldfirst = pch_first() + last_offset;
    LINENUM newfirst = pch_newfirst() + last_offset;
    LINENUM oldlast = oldfirst + pch_ptrn_lines() - 1;
    LINENUM newlast = newfirst + pch_repl_lines() - 1;
    char *stars = (diff_type >= NEW_CONTEXT_DIFF ? " ****" : "");
    char *minuses = (diff_type >= NEW_CONTEXT_DIFF ? " ----" : " -----");

    fprintf(rejfp, "***************\n");
    for (i=0; i<=pat_end; i++) {
	switch (pch_char(i)) {
	case '*':
	    if (oldlast < oldfirst)
		fprintf(rejfp, "*** 0%s\n", stars);
	    else if (oldlast == oldfirst)
		fprintf(rejfp, "*** %ld%s\n", oldfirst, stars);
	    else
		fprintf(rejfp, "*** %ld,%ld%s\n", oldfirst, oldlast, stars);
	    break;
	case '=':
	    if (newlast < newfirst)
		fprintf(rejfp, "--- 0%s\n", minuses);
	    else if (newlast == newfirst)
		fprintf(rejfp, "--- %ld%s\n", newfirst, minuses);
	    else
		fprintf(rejfp, "--- %ld,%ld%s\n", newfirst, newlast, minuses);
	    break;
	case '\n':
	    fprintf(rejfp, "%s", pfetch(i));
	    break;
	case ' ': case '-': case '+': case '!':
	    fprintf(rejfp, "%c %s", pch_char(i), pfetch(i));
	    break;
	default:
	    fatal("fatal internal error in abort_hunk\n");
a666 1
    }
d672 1
a672 2
apply_hunk(where)
LINENUM where;
d674 3
a676 3
    LINENUM old = 1;
    LINENUM lastline = pch_ptrn_lines();
    LINENUM new = lastline+1;
d681 42
a722 47
    int def_state = OUTSIDE;
    bool R_do_defines = do_defines;
    LINENUM pat_end = pch_end();

    where--;
    while (pch_char(new) == '=' || pch_char(new) == '\n')
	new++;

    while (old <= lastline) {
	if (pch_char(old) == '-') {
	    copy_till(where + old - 1);
	    if (R_do_defines) {
		if (def_state == OUTSIDE) {
		    fputs(not_defined, ofp);
		    def_state = IN_IFNDEF;
		}
		else if (def_state == IN_IFDEF) {
		    fputs(else_defined, ofp);
		    def_state = IN_ELSE;
		}
		fputs(pfetch(old), ofp);
	    }
	    last_frozen_line++;
	    old++;
	}
	else if (new > pat_end) {
	    break;
	}
	else if (pch_char(new) == '+') {
	    copy_till(where + old - 1);
	    if (R_do_defines) {
		if (def_state == IN_IFNDEF) {
		    fputs(else_defined, ofp);
		    def_state = IN_ELSE;
		}
		else if (def_state == OUTSIDE) {
		    fputs(if_defined, ofp);
		    def_state = IN_IFDEF;
		}
	    }
	    fputs(pfetch(new), ofp);
	    new++;
	}
	else if (pch_char(new) != pch_char(old)) {
	    say("Out-of-sync patch, lines %ld,%ld--mangled text or line numbers, maybe?\n",
		pch_hunk_beg() + old,
		pch_hunk_beg() + new);
d724 2
a725 2
	    say("oldchar = '%c', newchar = '%c'\n",
		pch_char(old), pch_char(new));
d727 31
a757 1
	    my_exit(1);
d759 2
a760 7
	else if (pch_char(new) == '!') {
	    copy_till(where + old - 1);
	    if (R_do_defines) {
	       fputs(not_defined, ofp);
	       def_state = IN_IFNDEF;
	    }
	    while (pch_char(old) == '!') {
d762 11
a772 1
		    fputs(pfetch(old), ofp);
a773 11
		last_frozen_line++;
		old++;
	    }
	    if (R_do_defines) {
		fputs(else_defined, ofp);
		def_state = IN_ELSE;
	    }
	    while (pch_char(new) == '!') {
		fputs(pfetch(new), ofp);
		new++;
	    }
d775 1
a775 5
	else {
	    assert(pch_char(new) == ' ');
	    old++;
	    new++;
	    if (R_do_defines && def_state != OUTSIDE) {
a776 2
		def_state = OUTSIDE;
	    }
a777 21
    }
    if (new <= pat_end && pch_char(new) == '+') {
	copy_till(where + old - 1);
	if (R_do_defines) {
	    if (def_state == OUTSIDE) {
		fputs(if_defined, ofp);
		def_state = IN_IFDEF;
	    }
	    else if (def_state == IN_IFNDEF) {
		fputs(else_defined, ofp);
		def_state = IN_ELSE;
	    }
	}
	while (new <= pat_end && pch_char(new) == '+') {
	    fputs(pfetch(new), ofp);
	    new++;
	}
    }
    if (R_do_defines && def_state != OUTSIDE) {
	fputs(end_defined, ofp);
    }
d780 3
a782 2
/* Open the new file. */

d784 1
a784 2
init_output(name)
char *name;
d786 3
a788 3
    ofp = fopen(name, "w");
    if (ofp == Nullfp)
	pfatal("can't create %s", name);
d791 3
a793 2
/* Open a file to put hunks we can't locate. */

d795 1
a795 2
init_reject(name)
char *name;
d797 3
a799 3
    rejfp = fopen(name, "w");
    if (rejfp == Nullfp)
	pfatal("can't create %s", name);
d802 3
a804 2
/* Copy input file to output, up to wherever hunk is to be applied. */

d806 1
a806 2
copy_till(lastline)
LINENUM lastline;
d808 1
a808 1
    LINENUM R_last_frozen_line = last_frozen_line;
d810 5
a814 6
    if (R_last_frozen_line > lastline)
	fatal("misordered hunks! output would be garbled\n");
    while (R_last_frozen_line < lastline) {
	dump_line(++R_last_frozen_line);
    }
    last_frozen_line = R_last_frozen_line;
d817 3
a819 2
/* Finish copying the input file to the output file. */

d821 1
a821 1
spew_output()
d824 2
a825 2
    if (debug & 256)
	say("il=%ld lfl=%ld\n",input_lines,last_frozen_line);
d827 4
a830 4
    if (input_lines)
	copy_till(input_lines);		/* dump remainder of file */
    fclose(ofp);
    ofp = Nullfp;
d833 3
a835 2
/* Copy one line from input to output. */

d837 1
a837 2
dump_line(line)
LINENUM line;
d839 1
a839 2
    char *s;
    char R_newline = '\n';
d841 6
a846 5
    s = ifetch(line, 0);
    if (s == NULL)
	return;
    /* Note: string is not null terminated. */
    for (; putc(*s, ofp) != R_newline; s++) ;
d849 3
a851 2
/* Does the patch pattern match at line base+offset? */

d853 14
a866 15
patch_match(base, offset, fuzz)
LINENUM base;
LINENUM offset;
LINENUM fuzz;
{
    LINENUM pline = 1 + fuzz;
    LINENUM iline;
    LINENUM pat_lines = pch_ptrn_lines() - fuzz;

    for (iline=base+offset+fuzz; pline <= pat_lines; pline++,iline++) {
	if (canonicalize) {
	    if (!similar(ifetch(iline, (offset >= 0)),
			 pfetch(pline),
			 pch_line_len(pline) ))
		return FALSE;
d868 1
a868 6
	else if (strnNE(ifetch(iline, (offset >= 0)),
		   pfetch(pline),
		   pch_line_len(pline) ))
	    return FALSE;
    }
    return TRUE;
d871 3
a873 2
/* Do two lines match with canonicalized white space? */

d875 3
a877 10
similar(a,b,len)
char *a;
char *b;
int len;
{
    if (a == NULL || b == NULL)
	return FALSE;
    while (len) {
	if (isspace(*b)) {		/* whitespace (or \n) to match? */
	    if (!isspace(*a))		/* no corresponding whitespace? */
d879 14
a892 6
	    while (len && isspace(*b) && *b != '\n')
		b++,len--;		/* skip pattern whitespace */
	    while (isspace(*a) && *a != '\n')
		a++;			/* skip target whitespace */
	    if (*a == '\n' || *b == '\n')
		return (*a == *b);	/* should end in sync */
d894 2
a895 7
	else if (*a++ != *b++)		/* match non-whitespace chars */
	    return FALSE;
	else
	    len--;			/* probably not necessary */
    }
    return TRUE;			/* actually, this is not reached */
					/* since there is always a \n */
d898 3
a900 2
/* Exit with cleanup. */

d902 1
a902 2
my_exit(status)
int status;
d904 7
a910 9
    unlink(TMPINNAME);
    if (!toutkeep) {
	unlink(TMPOUTNAME);
    }
    if (!trejkeep) {
	unlink(TMPREJNAME);
    }
    unlink(TMPPATNAME);
    exit(status);
@


1.18
log
@Do not produce garbage if the patch file contains invalid line numbers.
ok millert@@ tedu@@
@
text
@d1 1
a1 1
/*	$OpenBSD: patch.c,v 1.17 2003/07/02 00:21:16 avsm Exp $	*/
d12 1
a12 1
 * 
d30 1
a30 1
static char rcsid[] = "$OpenBSD: patch.c,v 1.17 2003/07/02 00:21:16 avsm Exp $";
a35 1
#include "version.h"
d43 16
a58 18
void reinitialize_almost_everything();
void get_some_switches();
LINENUM locate_hunk();
void abort_hunk();
void apply_hunk();
void init_output();
void init_reject();
void copy_till();
void spew_output();
void dump_line();
bool patch_match();
bool similar();
void re_input();
#ifdef __GNUC__
void my_exit() __attribute__((noreturn));
#else
void my_exit();
#endif
d72 1
a72 3
main(argc,argv)
int argc;
char **argv;
d101 1
a101 1
	fatal1("cannot allocate memory");
d103 2
a104 2
	pfatal2("can't create %s", TMPOUTNAME);
      Close(i);
d107 1
a107 1
	fatal1("cannot allocate memory");
d109 2
a110 2
	pfatal2("can't create %s", TMPINNAME);
      Close(i);
d113 1
a113 1
	fatal1("cannot allocate memory");
d115 2
a116 2
	pfatal2("can't create %s", TMPREJNAME);
      Close(i);
d119 1
a119 1
	fatal1("cannot allocate memory");
d121 2
a122 2
	pfatal2("can't create %s", TMPPATNAME);
      Close(i);
d143 1
a143 1
    
d156 1
a156 1
    
d162 1
a162 1
    
d166 1
a166 1
    
d169 1
a169 1
    
d173 1
a173 1
    
d176 1
a176 1
    
d194 1
a194 1
				say1(
d202 1
a202 1
				fatal1("lost hunk on alloc error!\n");
d207 1
a207 1
				fatal1("lost hunk on alloc error!\n");
d209 1
a209 1
			    say1(
d215 1
a215 1
				say3(
d221 1
a221 1
			    ask3(
d226 1
a226 1
				ask1("Apply anyway? [n] ");
d232 1
a232 1
				    fatal1("lost hunk on alloc error!\n");
d240 1
a240 1
		    Fclose(ofp);
d250 1
a250 1
		    say3("Hunk #%d ignored at %ld.\n", hunk, newwhere);
d256 1
a256 1
		    say3("Hunk #%d failed at %ld.\n", hunk, newwhere);
d261 1
a261 1
		    say3("Hunk #%d succeeded at %ld", hunk, newwhere);
d263 1
a263 1
			say2(" with fuzz %ld", fuzz);
d265 1
a265 1
			say3(" (offset %ld line%s)",
d267 1
a267 1
		    say1(".\n");
d275 1
a275 1
	    say1("\n\nRan out of memory using Plan A--trying again...\n\n");
d277 1
a277 1
	        Fclose(ofp);
d280 1
a280 1
	        Fclose(rejfp);
d284 1
a284 1
    
d286 1
a286 1
    
d290 1
a290 1
	
d297 1
a297 1
	    if (!check_only) {	
d309 1
a309 1
			say2("Removing %s (empty after patching).\n", realout);
d314 1
a314 1
	Fclose(rejfp);
d320 1
a320 14
		    fatal2("filename %s is too long\n", outname);
		    
#ifndef FLEXFILENAMES
		{
		    char *s = strrchr(rejname,'/');

		    if (!s)
			s = rejname;
		    if (strlen(s) > 13)
			if (s[12] == '.')	/* try to preserve difference */
			    s[12] = s[13];	/* between .h, .c, .y, etc. */
			s[13] = '\0';
		}
#endif
d322 1
a322 1
		    fatal2("filename %s is too long\n", outname);
d325 1
a325 1
		say4("%d out of %d hunks ignored--saving rejects to %s\n",
d329 1
a329 1
		say4("%d out of %d hunks failed--saving rejects to %s\n",
d338 1
a338 1
    	failtotal++;
d380 1
a380 1
	fatal1("you may not change to a different patch file\n");
d384 1
a384 1
nextarg()
d387 1
a387 1
	fatal2("missing argument after `%s'\n", *Argv);
d399 1
a399 2
optcmp(a, b)
    struct option *a, *b;
d401 2
d409 1
a409 2
decode_long_option(opt)
    char *opt;
d454 1
a454 1
    Reg1 char *s;
d468 1
a468 1
		fatal1("too many file arguments\n");
d491 1
a491 1
	    	check_only = TRUE;
d497 1
a497 1
		    pfatal2("can't cd to %s", s);
d500 1
a500 1
	    	do_defines = TRUE;
d504 4
a507 4
		    fatal1("argument to -D is not an identifier\n");
		Snprintf(if_defined, sizeof if_defined, "#ifdef %s\n", s);
		Snprintf(not_defined, sizeof not_defined, "#ifndef %s\n", s);
		Snprintf(end_defined, sizeof end_defined, "#endif /* %s */\n", s);
d546 1
a546 1
		    fatal1("argument for -r is too long\n");
d599 2
a600 2
    Reg1 LINENUM first_guess = pch_first() + last_offset;
    Reg2 LINENUM offset;
d602 3
a604 3
    Reg3 LINENUM max_pos_offset = input_lines - first_guess
				- pat_lines + 1; 
    Reg4 LINENUM max_neg_offset = first_guess - last_frozen_line - 1
d614 2
a615 2
	Reg5 bool check_after = (offset <= max_pos_offset);
	Reg6 bool check_before = (offset <= max_neg_offset);
d620 1
a620 1
		say3("Offset changing from %ld to %ld\n", last_offset, offset);
d628 1
a628 1
		say3("Offset changing from %ld to %ld\n", last_offset, -offset);
d643 2
a644 2
    Reg1 LINENUM i;
    Reg2 LINENUM pat_end = pch_end();
d679 1
a679 1
	    fatal1("fatal internal error in abort_hunk\n"); 
d690 3
a692 3
    Reg1 LINENUM old = 1;
    Reg2 LINENUM lastline = pch_ptrn_lines();
    Reg3 LINENUM new = lastline+1;
d697 3
a699 3
    Reg4 int def_state = OUTSIDE;
    Reg5 bool R_do_defines = do_defines;
    Reg6 LINENUM pat_end = pch_end();
d704 1
a704 1
    
d741 1
a741 1
	    say3("Out-of-sync patch, lines %ld,%ld--mangled text or line numbers, maybe?\n",
d745 1
a745 1
	    say3("oldchar = '%c', newchar = '%c'\n",
d786 1
a786 1
	    	fputs(if_defined, ofp);
d812 1
a812 1
	pfatal2("can't create %s", name);
d823 1
a823 1
	pfatal2("can't create %s", name);
d830 1
a830 1
Reg1 LINENUM lastline;
d832 1
a832 1
    Reg2 LINENUM R_last_frozen_line = last_frozen_line;
d835 1
a835 1
	fatal1("misordered hunks! output would be garbled\n");
d849 1
a849 1
	say3("il=%ld lfl=%ld\n",input_lines,last_frozen_line);
d853 1
a853 1
    Fclose(ofp);
d863 2
a864 2
    Reg1 char *s;
    Reg2 char R_newline = '\n';
d881 3
a883 3
    Reg1 LINENUM pline = 1 + fuzz;
    Reg2 LINENUM iline;
    Reg3 LINENUM pat_lines = pch_ptrn_lines() - fuzz;
d904 3
a906 3
Reg1 char *a;
Reg2 char *b;
Reg3 int len;
d936 1
a936 1
    Unlink(TMPINNAME);
d938 1
a938 1
	Unlink(TMPOUTNAME);
d941 1
a941 1
	Unlink(TMPREJNAME);
d943 1
a943 1
    Unlink(TMPPATNAME);
@


1.17
log
@bump randomness of mktemp to from 6 to 10 X's, as recommended by mktemp(3)
@
text
@d1 1
a1 1
/*	$OpenBSD: patch.c,v 1.16 2003/04/05 17:17:53 deraadt Exp $	*/
d30 1
a30 1
static char rcsid[] = "$OpenBSD: patch.c,v 1.16 2003/04/05 17:17:53 deraadt Exp $";
d884 3
d888 1
a888 1
    for (s=ifetch(line, 0); putc(*s, ofp) != R_newline; s++) ;
d926 2
@


1.16
log
@string fixes; ok miod henning
@
text
@d1 1
a1 1
/*	$OpenBSD: patch.c,v 1.15 2002/07/04 04:22:48 deraadt Exp $	*/
d30 1
a30 1
static char rcsid[] = "$OpenBSD: patch.c,v 1.15 2002/07/04 04:22:48 deraadt Exp $";
d105 1
a105 1
      if (asprintf(&TMPOUTNAME, "%s/patchoXXXXXX", tmpdir) == -1)
d111 1
a111 1
      if (asprintf(&TMPINNAME, "%s/patchiXXXXXX", tmpdir) == -1)
d117 1
a117 1
      if (asprintf(&TMPREJNAME, "%s/patchrXXXXXX", tmpdir) == -1)
d123 1
a123 1
      if (asprintf(&TMPPATNAME, "%s/patchpXXXXXX", tmpdir) == -1)
@


1.15
log
@4 unchecked mallocs; cloder@@acm.org
@
text
@d1 1
a1 1
/*	$OpenBSD: patch.c,v 1.14 2002/03/05 08:56:55 niklas Exp $	*/
d30 1
a30 1
static char rcsid[] = "$OpenBSD: patch.c,v 1.14 2002/03/05 08:56:55 niklas Exp $";
a98 1
      int tmpname_len;
a103 1
      tmpname_len = strlen (tmpdir) + 20;
d105 1
a105 2
      TMPOUTNAME = (char *) malloc (tmpname_len);
      if (TMPOUTNAME == NULL)
a106 2
      strcpy (TMPOUTNAME, tmpdir);
      strcat (TMPOUTNAME, "/patchoXXXXXX");
d111 1
a111 2
      TMPINNAME = (char *) malloc (tmpname_len);
      if (TMPINNAME == NULL)
a112 2
      strcpy (TMPINNAME, tmpdir);
      strcat (TMPINNAME, "/patchiXXXXXX");
d117 1
a117 2
      TMPREJNAME = (char *) malloc (tmpname_len);
      if (TMPREJNAME == NULL)
a118 2
      strcpy (TMPREJNAME, tmpdir);
      strcat (TMPREJNAME, "/patchrXXXXXX");
d123 1
a123 2
      TMPPATNAME = (char *) malloc (tmpname_len);
      if (TMPPATNAME == NULL)
a124 2
      strcpy (TMPPATNAME, tmpdir);
      strcat (TMPPATNAME, "/patchpXXXXXX");
@


1.14
log
@patch(1) is now free, thanks Larry!
@
text
@d1 1
a1 1
/*	$OpenBSD: patch.c,v 1.13 1999/12/04 01:01:06 provos Exp $	*/
d30 1
a30 1
static char rcsid[] = "$OpenBSD: patch.c,v 1.13 1999/12/04 01:01:06 provos Exp $";
d108 2
d117 2
d126 2
d135 2
@


1.13
log
@avoid overflows
@
text
@d1 1
a1 1
/*	$OpenBSD: patch.c,v 1.12 1999/08/31 21:29:19 espie Exp $	*/
d7 17
a23 2
 * This program may be copied as long as you don't try to make any
 * money off of it, or pretend that you wrote it.
d30 1
a30 1
static char rcsid[] = "$OpenBSD: patch.c,v 1.12 1999/08/31 21:29:19 espie Exp $";
@


1.12
log
@patch file should hold at least one patch, otherwise we're entitled to
a diagnostic.
@
text
@d1 1
a1 1
/*	$OpenBSD: patch.c,v 1.11 1998/11/25 00:30:26 espie Exp $	*/
d15 1
a15 1
static char rcsid[] = "$OpenBSD: patch.c,v 1.11 1998/11/25 00:30:26 espie Exp $";
d315 3
a317 1
		Strcpy(rejname, outname);
d330 2
a331 1
		Strcat(rejname, REJEXT);
d554 2
a555 1
		Strcpy(rejname, nextarg());
@


1.11
log
@add -C
@
text
@d1 1
a1 1
/*	$OpenBSD: patch.c,v 1.10 1997/09/22 05:45:27 millert Exp $	*/
d15 1
a15 1
static char rcsid[] = "$OpenBSD: patch.c,v 1.10 1997/09/22 05:45:27 millert Exp $";
d71 1
d148 1
d343 2
@


1.10
log
@Start of -Wall and cleaning up icky bits.
@
text
@d1 1
a1 1
/*	$OpenBSD: patch.c,v 1.9 1997/01/17 07:13:04 millert Exp $	*/
d9 3
d15 1
a15 1
static char rcsid[] = "$OpenBSD: patch.c,v 1.9 1997/01/17 07:13:04 millert Exp $";
d54 3
d291 8
a298 7
	    if (move_file(TMPOUTNAME, outname) < 0) {
		toutkeep = TRUE;
		realout = TMPOUTNAME;
		chmod(TMPOUTNAME, filemode);
	    }
	    else
		chmod(outname, filemode);
d300 6
a305 5
	    if (remove_empty_files && stat(realout, &statbuf) == 0
		&& statbuf.st_size == 0) {
		if (verbose)
		    say2("Removing %s (empty after patching).\n", realout);
	        while (unlink(realout) >= 0) ; /* while is for Eunice.  */
d336 1
a336 1
	    if (move_file(TMPREJNAME, rejname) < 0)
d492 3
d585 1
a585 1
       [-ceEflnNRsStuv] [-b backup-ext] [-B backup-prefix] [-d directory]\n\
@


1.9
log
@r?index -> strr?chr
@
text
@d1 1
a1 1
/*	$OpenBSD: patch.c,v 1.8 1996/09/24 04:19:28 millert Exp $	*/
d12 1
a12 1
static char rcsid[] = "$OpenBSD: patch.c,v 1.8 1996/09/24 04:19:28 millert Exp $";
d39 3
d43 1
d334 1
@


1.8
log
@sprintf -> snprintf except where guaranteed safe.
@
text
@d1 1
a1 1
/*	$OpenBSD: patch.c,v 1.7 1996/09/24 02:58:52 millert Exp $	*/
d12 1
a12 1
static char rcsid[] = "$OpenBSD: patch.c,v 1.7 1996/09/24 02:58:52 millert Exp $";
d304 1
a304 1
		    char *s = rindex(rejname,'/');
@


1.7
log
@Use mkstemp().  Since temp files get re-used we use mkstemp() to make
us a "place holder" (and discard the fd) to protect from DOS attacks
and then just re-use that.
@
text
@d1 1
a1 1
/*	$OpenBSD: patch.c,v 1.6 1996/09/23 10:54:21 deraadt Exp $	*/
d12 1
a12 1
static char rcsid[] = "$OpenBSD: patch.c,v 1.6 1996/09/23 10:54:21 deraadt Exp $";
d84 1
a84 1
      if ((i = Mkstemp(TMPOUTNAME)) < 0)
d91 1
a91 1
      if ((i = Mkstemp(TMPINNAME)) < 0)
d98 1
a98 1
      if ((i = Mkstemp(TMPREJNAME)) < 0)
d105 1
a105 1
      if ((i = Mkstemp(TMPPATNAME)) < 0)
d491 3
a493 3
		Sprintf(if_defined, "#ifdef %s\n", s);
		Sprintf(not_defined, "#ifndef %s\n", s);
		Sprintf(end_defined, "#endif /* %s */\n", s);
@


1.6
log
@undo last; mkstemp is *hard* to do in here
@
text
@d1 1
a1 1
/*	$OpenBSD: patch.c,v 1.4 1996/07/01 20:40:09 deraadt Exp $	*/
d12 1
a12 1
static char rcsid[] = "$OpenBSD: patch.c,v 1.4 1996/07/01 20:40:09 deraadt Exp $";
d84 3
a86 1
      Mktemp(TMPOUTNAME);
d91 3
a93 1
      Mktemp(TMPINNAME);
d98 3
a100 1
      Mktemp(TMPREJNAME);
d105 3
a107 1
      Mktemp(TMPPATNAME);
@


1.5
log
@Be slightly safer opening temp files.
@
text
@d787 2
a788 4
    int ofd;

    if ((ofd = open(name, O_CREAT|O_EXCL|O_WRONLY, 0600)) < 0 ||
	(ofp = fdopen(ofd, "w")) == Nullfp)
d798 2
a799 4
    int rejfd;

    if ((rejfd = open(name, O_CREAT|O_EXCL|O_WRONLY, 0600)) < 0 ||
	(rejfp = fdopen(rejfd, "w")) == Nullfp)
@


1.4
log
@undo mktemp cleanup until i get it right
@
text
@d1 1
a1 1
/*	$OpenBSD: patch.c,v 1.2 1996/06/10 11:21:31 niklas Exp $	*/
d12 1
a12 1
static char rcsid[] = "$OpenBSD: patch.c,v 1.2 1996/06/10 11:21:31 niklas Exp $";
d787 4
a790 2
    ofp = fopen(name, "w");
    if (ofp == Nullfp)
d800 4
a803 2
    rejfp = fopen(name, "w");
    if (rejfp == Nullfp)
@


1.3
log
@mktemp w/ open & fdopen
@
text
@d787 2
a788 6
    int fd;

    if ((fd = open(name, O_EXCL|O_CREAT|O_RDWR, 0666)) == -1 ||
	(ofp = fdopen(fd, "w")) == NULL) {
	if (fd != -1)
		close(fd);
a789 1
    }
d798 2
a799 6
    int fd;

    if ((fd = open(name, O_EXCL|O_CREAT|O_RDWR, 0666)) == -1 ||
	(rejfp = fdopen(fd, "w")) == NULL) {
	if (fd != -1)
		close(fd);
a800 1
    }
@


1.2
log
@Support the long options that FSF's patch version has.  $OpenBSD$ added
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d12 1
a12 1
static char rcsid[] = "$OpenBSD: patch.c,v 1.1.1.1 1995/10/18 08:45:55 deraadt Exp $";
d787 6
a792 2
    ofp = fopen(name, "w");
    if (ofp == Nullfp)
d794 1
d803 6
a808 2
    rejfp = fopen(name, "w");
    if (rejfp == Nullfp)
d810 1
@


1.1
log
@Initial revision
@
text
@d1 2
d12 1
a12 1
static char rcsid[] = "$Id: patch.c,v 1.2 1993/08/02 17:55:19 mycroft Exp $";
d372 58
d453 9
a461 1
	    switch (*++s) {
d497 3
a499 1
		if (*++s == '=')
d516 3
a518 1
		if (*++s == '=')
d551 3
a553 1
		debug = atoi(s+1);
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@
