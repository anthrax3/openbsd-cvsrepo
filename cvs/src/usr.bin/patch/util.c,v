head	1.40;
access;
symbols
	OPENBSD_6_2_BASE:1.40
	OPENBSD_6_1:1.40.0.10
	OPENBSD_6_1_BASE:1.40
	OPENBSD_6_0:1.40.0.6
	OPENBSD_6_0_BASE:1.40
	OPENBSD_5_9:1.40.0.2
	OPENBSD_5_9_BASE:1.40
	OPENBSD_5_8:1.40.0.4
	OPENBSD_5_8_BASE:1.40
	OPENBSD_5_7:1.39.0.2
	OPENBSD_5_7_BASE:1.39
	OPENBSD_5_6:1.36.0.6
	OPENBSD_5_6_BASE:1.36
	OPENBSD_5_5:1.36.0.4
	OPENBSD_5_5_BASE:1.36
	OPENBSD_5_4:1.35.0.14
	OPENBSD_5_4_BASE:1.35
	OPENBSD_5_3:1.35.0.12
	OPENBSD_5_3_BASE:1.35
	OPENBSD_5_2:1.35.0.10
	OPENBSD_5_2_BASE:1.35
	OPENBSD_5_1_BASE:1.35
	OPENBSD_5_1:1.35.0.8
	OPENBSD_5_0:1.35.0.6
	OPENBSD_5_0_BASE:1.35
	OPENBSD_4_9:1.35.0.4
	OPENBSD_4_9_BASE:1.35
	OPENBSD_4_8:1.35.0.2
	OPENBSD_4_8_BASE:1.35
	OPENBSD_4_7:1.34.0.2
	OPENBSD_4_7_BASE:1.34
	OPENBSD_4_6:1.32.0.16
	OPENBSD_4_6_BASE:1.32
	OPENBSD_4_5:1.32.0.12
	OPENBSD_4_5_BASE:1.32
	OPENBSD_4_4:1.32.0.10
	OPENBSD_4_4_BASE:1.32
	OPENBSD_4_3:1.32.0.8
	OPENBSD_4_3_BASE:1.32
	OPENBSD_4_2:1.32.0.6
	OPENBSD_4_2_BASE:1.32
	OPENBSD_4_1:1.32.0.4
	OPENBSD_4_1_BASE:1.32
	OPENBSD_4_0:1.32.0.2
	OPENBSD_4_0_BASE:1.32
	OPENBSD_3_9:1.31.0.4
	OPENBSD_3_9_BASE:1.31
	OPENBSD_3_8:1.31.0.2
	OPENBSD_3_8_BASE:1.31
	OPENBSD_3_7:1.29.0.2
	OPENBSD_3_7_BASE:1.29
	OPENBSD_3_6:1.28.0.2
	OPENBSD_3_6_BASE:1.28
	OPENBSD_3_5:1.27.0.2
	OPENBSD_3_5_BASE:1.27
	OPENBSD_3_4:1.26.0.2
	OPENBSD_3_4_BASE:1.26
	OPENBSD_3_3:1.9.0.14
	OPENBSD_3_3_BASE:1.9
	OPENBSD_3_2:1.9.0.12
	OPENBSD_3_2_BASE:1.9
	OPENBSD_3_1:1.9.0.10
	OPENBSD_3_1_BASE:1.9
	OPENBSD_3_0:1.9.0.8
	OPENBSD_3_0_BASE:1.9
	OPENBSD_2_9_BASE:1.9
	OPENBSD_2_9:1.9.0.6
	OPENBSD_2_8:1.9.0.4
	OPENBSD_2_8_BASE:1.9
	OPENBSD_2_7:1.9.0.2
	OPENBSD_2_7_BASE:1.9
	OPENBSD_2_6:1.6.0.4
	OPENBSD_2_6_BASE:1.6
	OPENBSD_2_5:1.6.0.2
	OPENBSD_2_5_BASE:1.6
	OPENBSD_2_4:1.4.0.6
	OPENBSD_2_4_BASE:1.4
	OPENBSD_2_3:1.4.0.4
	OPENBSD_2_3_BASE:1.4
	OPENBSD_2_2:1.4.0.2
	OPENBSD_2_2_BASE:1.4
	OPENBSD_2_1:1.3.0.4
	OPENBSD_2_1_BASE:1.3
	OPENBSD_2_0:1.3.0.2
	OPENBSD_2_0_BASE:1.3
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.40
date	2015.07.26.14.32.19;	author millert;	state Exp;
branches;
next	1.39;
commitid	09nDnpMEB9OxbzYE;

1.39
date	2015.01.16.06.40.10;	author deraadt;	state Exp;
branches
	1.39.2.1;
next	1.38;
commitid	Uu5nFG3wCl0LACBb;

1.38
date	2014.12.13.10.31.07;	author tobias;	state Exp;
branches;
next	1.37;
commitid	KFnMndwf456Gm1bQ;

1.37
date	2014.11.22.15.49.28;	author tobias;	state Exp;
branches;
next	1.36;
commitid	vyatgew5pmIq3geU;

1.36
date	2013.11.26.13.19.07;	author deraadt;	state Exp;
branches
	1.36.6.1;
next	1.35;

1.35
date	2010.07.24.01.10.12;	author ray;	state Exp;
branches;
next	1.34;

1.34
date	2010.01.08.13.27.59;	author oga;	state Exp;
branches;
next	1.33;

1.33
date	2009.10.27.23.59.41;	author deraadt;	state Exp;
branches;
next	1.32;

1.32
date	2006.03.11.19.41.30;	author otto;	state Exp;
branches;
next	1.31;

1.31
date	2005.06.20.07.14.06;	author otto;	state Exp;
branches;
next	1.30;

1.30
date	2005.05.16.15.22.46;	author espie;	state Exp;
branches;
next	1.29;

1.29
date	2004.11.19.20.00.57;	author otto;	state Exp;
branches;
next	1.28;

1.28
date	2004.08.05.21.47.24;	author deraadt;	state Exp;
branches;
next	1.27;

1.27
date	2003.10.31.20.20.45;	author millert;	state Exp;
branches;
next	1.26;

1.26
date	2003.08.15.08.00.51;	author otto;	state Exp;
branches;
next	1.25;

1.25
date	2003.08.01.20.30.49;	author otto;	state Exp;
branches;
next	1.24;

1.24
date	2003.07.31.20.51.43;	author otto;	state Exp;
branches;
next	1.23;

1.23
date	2003.07.30.15.47.54;	author millert;	state Exp;
branches;
next	1.22;

1.22
date	2003.07.29.20.10.17;	author millert;	state Exp;
branches;
next	1.21;

1.21
date	2003.07.28.19.05.26;	author millert;	state Exp;
branches;
next	1.20;

1.20
date	2003.07.28.18.35.36;	author otto;	state Exp;
branches;
next	1.19;

1.19
date	2003.07.28.16.13.53;	author millert;	state Exp;
branches;
next	1.18;

1.18
date	2003.07.25.02.12.45;	author millert;	state Exp;
branches;
next	1.17;

1.17
date	2003.07.22.17.52.20;	author deraadt;	state Exp;
branches;
next	1.16;

1.16
date	2003.07.22.17.18.49;	author otto;	state Exp;
branches;
next	1.15;

1.15
date	2003.07.21.14.32.21;	author deraadt;	state Exp;
branches;
next	1.14;

1.14
date	2003.07.21.14.30.31;	author deraadt;	state Exp;
branches;
next	1.13;

1.13
date	2003.07.21.14.00.41;	author deraadt;	state Exp;
branches;
next	1.12;

1.12
date	2003.07.18.02.00.09;	author deraadt;	state Exp;
branches;
next	1.11;

1.11
date	2003.04.08.00.18.31;	author deraadt;	state Exp;
branches;
next	1.10;

1.10
date	2003.04.05.17.17.53;	author deraadt;	state Exp;
branches;
next	1.9;

1.9
date	99.12.04.21.00.03;	author provos;	state Exp;
branches;
next	1.8;

1.8
date	99.12.04.01.04.14;	author provos;	state Exp;
branches;
next	1.7;

1.7
date	99.12.04.01.01.07;	author provos;	state Exp;
branches;
next	1.6;

1.6
date	99.01.11.00.16.32;	author marc;	state Exp;
branches;
next	1.5;

1.5
date	99.01.03.05.33.48;	author millert;	state Exp;
branches;
next	1.4;

1.4
date	97.09.22.05.45.27;	author millert;	state Exp;
branches;
next	1.3;

1.3
date	96.09.24.04.19.30;	author millert;	state Exp;
branches;
next	1.2;

1.2
date	96.06.10.11.21.34;	author niklas;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.45.56;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.45.56;	author deraadt;	state Exp;
branches;
next	;

1.36.6.1
date	2015.07.27.16.08.18;	author guenther;	state Exp;
branches;
next	;
commitid	ltV6h69MuIPDoBUT;

1.39.2.1
date	2015.07.27.16.10.54;	author krw;	state Exp;
branches;
next	;
commitid	7qowXgsHJsgQ1um1;


desc
@@


1.40
log
@Remove support for automatically checking files out of RCS.  The
behavior is confusing to users and even GNU patch no longer does
it by default.  OK krw@@ guenther@@
@
text
@/*	$OpenBSD: util.c,v 1.39 2015/01/16 06:40:10 deraadt Exp $	*/

/*
 * patch - a program to apply diffs to original files
 * 
 * Copyright 1986, Larry Wall
 * 
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following condition is met:
 * 1. Redistributions of source code must retain the above copyright notice,
 * this condition and the following disclaimer.
 * 
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND ANY
 * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
 * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 * 
 * -C option added in 1998, original code by Marc Espie, based on FreeBSD
 * behaviour
 */

#include <sys/stat.h>

#include <ctype.h>
#include <errno.h>
#include <fcntl.h>
#include <libgen.h>
#include <paths.h>
#include <signal.h>
#include <stdarg.h>
#include <stdlib.h>
#include <stdio.h>
#include <string.h>
#include <unistd.h>

#include "common.h"
#include "util.h"
#include "backupfile.h"
#include "pathnames.h"

/* Rename a file, copying it if necessary. */

int
move_file(const char *from, const char *to)
{
	int	fromfd;
	ssize_t	i;

	/* to stdout? */

	if (strEQ(to, "-")) {
#ifdef DEBUGGING
		if (debug & 4)
			say("Moving %s to stdout.\n", from);
#endif
		fromfd = open(from, O_RDONLY);
		if (fromfd < 0)
			pfatal("internal error, can't reopen %s", from);
		while ((i = read(fromfd, buf, sizeof buf)) > 0)
			if (write(STDOUT_FILENO, buf, i) != i)
				pfatal("write failed");
		close(fromfd);
		return 0;
	}
	if (backup_file(to) < 0) {
		say("Can't backup %s, output is in %s: %s\n", to, from,
		    strerror(errno));
		return -1;
	}
#ifdef DEBUGGING
	if (debug & 4)
		say("Moving %s to %s.\n", from, to);
#endif
	if (rename(from, to) < 0) {
		if (errno != EXDEV || copy_file(from, to) < 0) {
			say("Can't create %s, output is in %s: %s\n",
			    to, from, strerror(errno));
			return -1;
		}
	}
	return 0;
}

/* Backup the original file.  */

int
backup_file(const char *orig)
{
	struct stat	filestat;
	char		bakname[PATH_MAX], *s, *simplename;
	dev_t		orig_device;
	ino_t		orig_inode;

	if (backup_type == none || stat(orig, &filestat) != 0)
		return 0;			/* nothing to do */
	orig_device = filestat.st_dev;
	orig_inode = filestat.st_ino;

	if (origprae) {
		if (strlcpy(bakname, origprae, sizeof(bakname)) >= sizeof(bakname) ||
		    strlcat(bakname, orig, sizeof(bakname)) >= sizeof(bakname))
			fatal("filename %s too long for buffer\n", origprae);
	} else {
		if ((s = find_backup_file_name(orig)) == NULL)
			fatal("out of memory\n");
		if (strlcpy(bakname, s, sizeof(bakname)) >= sizeof(bakname))
			fatal("filename %s too long for buffer\n", s);
		free(s);
	}

	if ((simplename = strrchr(bakname, '/')) != NULL)
		simplename = simplename + 1;
	else
		simplename = bakname;

	/*
	 * Find a backup name that is not the same file. Change the
	 * first lowercase char into uppercase; if that isn't
	 * sufficient, chop off the first char and try again.
	 */
	while (stat(bakname, &filestat) == 0 &&
	    orig_device == filestat.st_dev && orig_inode == filestat.st_ino) {
		/* Skip initial non-lowercase chars.  */
		for (s = simplename; *s && !islower((unsigned char)*s); s++)
			;
		if (*s)
			*s = toupper((unsigned char)*s);
		else
			memmove(simplename, simplename + 1,
			    strlen(simplename + 1) + 1);
	}
#ifdef DEBUGGING
	if (debug & 4)
		say("Moving %s to %s.\n", orig, bakname);
#endif
	if (rename(orig, bakname) < 0) {
		if (errno != EXDEV || copy_file(orig, bakname) < 0)
			return -1;
	}
	return 0;
}

/*
 * Copy a file.
 */
int
copy_file(const char *from, const char *to)
{
	int	tofd, fromfd;
	ssize_t	i;

	tofd = open(to, O_CREAT|O_TRUNC|O_WRONLY, 0666);
	if (tofd < 0)
		return -1;
	fromfd = open(from, O_RDONLY, 0);
	if (fromfd < 0)
		pfatal("internal error, can't reopen %s", from);
	while ((i = read(fromfd, buf, sizeof buf)) > 0)
		if (write(tofd, buf, i) != i)
			pfatal("write to %s failed", to);
	close(fromfd);
	close(tofd);
	return 0;
}

/*
 * Allocate a unique area for a string.
 */
char *
savestr(const char *s)
{
	char	*rv;

	if (!s)
		s = "Oops";
	rv = strdup(s);
	if (rv == NULL) {
		if (using_plan_a)
			out_of_mem = true;
		else
			fatal("out of memory\n");
	}
	return rv;
}

/*
 * Allocate a unique area for a string.  Call fatal if out of memory.
 */
char *
xstrdup(const char *s)
{
	char	*rv;

	if (!s)
		s = "Oops";
	rv = strdup(s);
	if (rv == NULL)
		fatal("out of memory\n");
	return rv;
}

/*
 * Vanilla terminal output (buffered).
 */
void
say(const char *fmt, ...)
{
	va_list	ap;

	va_start(ap, fmt);
	vfprintf(stdout, fmt, ap);
	va_end(ap);
	fflush(stdout);
}

/*
 * Terminal output, pun intended.
 */
void
fatal(const char *fmt, ...)
{
	va_list	ap;

	va_start(ap, fmt);
	fprintf(stderr, "patch: **** ");
	vfprintf(stderr, fmt, ap);
	va_end(ap);
	my_exit(2);
}

/*
 * Say something from patch, something from the system, then silence . . .
 */
void
pfatal(const char *fmt, ...)
{
	va_list	ap;
	int	errnum = errno;

	fprintf(stderr, "patch: **** ");
	va_start(ap, fmt);
	vfprintf(stderr, fmt, ap);
	va_end(ap);
	fprintf(stderr, ": %s\n", strerror(errnum));
	my_exit(2);
}

/*
 * Get a response from the user via /dev/tty
 */
void
ask(const char *fmt, ...)
{
	va_list	ap;
	ssize_t	nr;
	static	int ttyfd = -1;

	va_start(ap, fmt);
	vfprintf(stdout, fmt, ap);
	va_end(ap);
	fflush(stdout);
	if (ttyfd < 0)
		ttyfd = open(_PATH_TTY, O_RDONLY);
	if (ttyfd >= 0) {
		if ((nr = read(ttyfd, buf, sizeof(buf))) > 0 &&
		    buf[nr - 1] == '\n')
			buf[nr - 1] = '\0';
	}
	if (ttyfd < 0 || nr <= 0) {
		/* no tty or error reading, pretend user entered 'return' */
		putchar('\n');
		buf[0] = '\0';
	}
}

/*
 * How to handle certain events when not in a critical region.
 */
void
set_signals(int reset)
{
	static sig_t	hupval, intval;

	if (!reset) {
		hupval = signal(SIGHUP, SIG_IGN);
		if (hupval != SIG_IGN)
			hupval = (sig_t) my_exit;
		intval = signal(SIGINT, SIG_IGN);
		if (intval != SIG_IGN)
			intval = (sig_t) my_exit;
	}
	signal(SIGHUP, hupval);
	signal(SIGINT, intval);
}

/*
 * How to handle certain events when in a critical region.
 */
void
ignore_signals(void)
{
	signal(SIGHUP, SIG_IGN);
	signal(SIGINT, SIG_IGN);
}

/*
 * Make sure we'll have the directories to create a file. If `striplast' is
 * true, ignore the last element of `filename'.
 */

void
makedirs(const char *filename, bool striplast)
{
	char	*tmpbuf;

	if ((tmpbuf = strdup(filename)) == NULL)
		fatal("out of memory\n");

	if (striplast) {
		char	*s = strrchr(tmpbuf, '/');
		if (s == NULL) {
			free(tmpbuf);
			return;	/* nothing to be done */
		}
		*s = '\0';
	}
	if (mkpath(tmpbuf) != 0)
		pfatal("creation of %s failed", tmpbuf);
	free(tmpbuf);
}

/*
 * Make filenames more reasonable.
 */
char *
fetchname(const char *at, bool *exists, int strip_leading)
{
	char		*fullname, *name, *t;
	int		sleading, tab;
	struct stat	filestat;

	if (at == NULL || *at == '\0')
		return NULL;
	while (isspace((unsigned char)*at))
		at++;
#ifdef DEBUGGING
	if (debug & 128)
		say("fetchname %s %d\n", at, strip_leading);
#endif
	/* So files can be created by diffing against /dev/null.  */
	if (strnEQ(at, _PATH_DEVNULL, sizeof(_PATH_DEVNULL) - 1))
		return NULL;
	name = fullname = t = savestr(at);

	tab = strchr(t, '\t') != NULL;
	/* Strip off up to `strip_leading' path components and NUL terminate. */
	for (sleading = strip_leading; *t != '\0' && ((tab && *t != '\t') ||
	    !isspace((unsigned char)*t)); t++) {
		if (t[0] == '/' && t[1] != '/' && t[1] != '\0')
			if (--sleading >= 0)
				name = t + 1;
	}
	*t = '\0';

	/*
	 * If no -p option was given (957 is the default value!), we were
	 * given a relative pathname, and the leading directories that we
	 * just stripped off all exist, put them back on.
	 */
	if (strip_leading == 957 && name != fullname && *fullname != '/') {
		name[-1] = '\0';
		if (stat(fullname, &filestat) == 0 && S_ISDIR(filestat.st_mode)) {
			name[-1] = '/';
			name = fullname;
		}
	}
	name = savestr(name);
	free(fullname);

	*exists = stat(name, &filestat) == 0;
	return name;
}

void
version(void)
{
	fprintf(stderr, "Patch version 2.0-12u8-OpenBSD\n");
	my_exit(EXIT_SUCCESS);
}

/*
 * Exit with cleanup.
 */
void
my_exit(int status)
{
	unlink(TMPINNAME);
	if (!toutkeep)
		unlink(TMPOUTNAME);
	if (!trejkeep)
		unlink(TMPREJNAME);
	unlink(TMPPATNAME);
	exit(status);
}
@


1.39
log
@Replace <sys/param.h> with <limits.h> and other less dirty headers where
possible.  Annotate <sys/param.h> lines with their current reasons.  Switch
to PATH_MAX, NGROUPS_MAX, HOST_NAME_MAX+1, LOGIN_NAME_MAX, etc.  Change
MIN() and MAX() to local definitions of MINIMUM() and MAXIMUM() where
sensible to avoid pulling in the pollution.  These are the files confirmed
through binary verification.
ok guenther, millert, doug (helped with the verification protocol)
@
text
@d1 1
a1 1
/*	$OpenBSD: util.c,v 1.38 2014/12/13 10:31:07 tobias Exp $	*/
a388 24
}

/*
 * Takes the name returned by fetchname and looks in RCS directory
 * for a checked in version.
 */
char *
checked_in(char *file)
{
	char		*filebase, *filedir, tmpbuf[PATH_MAX];
	struct stat	filestat;

	filebase = basename(file);
	filedir = dirname(file);

#define try(f, a1, a2, a3) \
(snprintf(tmpbuf, sizeof tmpbuf, f, a1, a2, a3), stat(tmpbuf, &filestat) == 0)

	if (try("%s/RCS/%s%s", filedir, filebase, RCSSUFFIX) ||
	    try("%s/RCS/%s%s", filedir, filebase, "") ||
	    try("%s/%s%s", filedir, filebase, RCSSUFFIX))
		return file;

	return NULL;
@


1.39.2.1
log
@Backport commit of 2015-07-26 14:32 by millert

Remove support for automatically checking files out of RCS.  The
behavior is confusing to users and even GNU patch no longer does
it by default.  OK krw@@ guenther@@
@
text
@d1 1
a1 1
/*	$OpenBSD: util.c,v 1.39 2015/01/16 06:40:10 deraadt Exp $	*/
d389 24
@


1.38
log
@The function savestr allows NULL return values during Plan A patching so in
case of out of memory conditions, Plan B can step in.  In many cases, NULL
value is not properly handled, so use xstrdup here (it's outside Plan A/B
patching, which means that even Plan B relies on successful operations).
@
text
@d1 1
a1 1
/*	$OpenBSD: util.c,v 1.37 2014/11/22 15:49:28 tobias Exp $	*/
a28 1
#include <sys/param.h>
d97 1
a97 1
	char		bakname[MAXPATHLEN], *s, *simplename;
d398 1
a398 1
	char		*filebase, *filedir, tmpbuf[MAXPATHLEN];
@


1.37
log
@Remove SCCS support.  For this to work, we would need "get", which we don't
even have in ports.  XSI functionality of POSIX, therefore optional.

ok deraadt, schwarze, tedu
@
text
@d1 1
a1 1
/*	$OpenBSD: util.c,v 1.36 2013/11/26 13:19:07 deraadt Exp $	*/
d191 16
@


1.36
log
@unsigned char casts for ctype
ok krw
@
text
@d1 1
a1 1
/*	$OpenBSD: util.c,v 1.35 2010/07/24 01:10:12 ray Exp $	*/
d377 1
a377 1
 * Takes the name returned by fetchname and looks in RCS/SCCS directories
d394 1
a394 3
	    try("%s/%s%s", filedir, filebase, RCSSUFFIX) ||
	    try("%s/SCCS/%s%s", filedir, SCCSPREFIX, filebase) ||
	    try("%s/%s%s", filedir, SCCSPREFIX, filebase))
@


1.36.6.1
log
@Backport commit of 2014-11-22 15:49 by tobias:
Remove SCCS support.  For this to work, we would need "get", which we don't     even have in ports.  XSI functionality of POSIX, therefore optional.

ok deraadt, schwarze, tedu
----------------------------
Backport commit of 2015-07-26 14:32 by millert
Remove support for automatically checking files out of RCS.  The                behavior is confusing to users and even GNU patch no longer does
it by default.  OK krw@@ guenther@@
@
text
@d1 1
a1 1
/*	$OpenBSD: util.c,v 1.36 2013/11/26 13:19:07 deraadt Exp $	*/
d374 26
@


1.35
log
@Send normal output to stdout instead of everything to stderr. This
is currently done in the latest versions of GNU patch.

Please watch out for output appearing out-of-order.

Discussed with millert and deraadt.

OK deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: util.c,v 1.34 2010/01/08 13:27:59 oga Exp $	*/
d132 1
a132 1
		for (s = simplename; *s && !islower(*s); s++)
d135 1
a135 1
			*s = toupper(*s);
d336 1
a336 1
	while (isspace(*at))
d350 1
a350 1
	    !isspace(*t)); t++) {
@


1.34
log
@Don't leak memory after strdup() in makedirs().

From Igor Zinovik; thanks!

ok stsp@@, millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: util.c,v 1.33 2009/10/27 23:59:41 deraadt Exp $	*/
d203 1
a203 1
	vfprintf(stderr, fmt, ap);
d205 1
a205 1
	fflush(stderr);
@


1.33
log
@rcsid[] and sccsid[] and copyright[] are essentially unmaintained (and
unmaintainable).  these days, people use source.  these id's do not provide
any benefit, and do hurt the small install media
(the 33,000 line diff is essentially mechanical)
ok with the idea millert, ok dms
@
text
@d1 1
a1 1
/*	$OpenBSD: util.c,v 1.32 2006/03/11 19:41:30 otto Exp $	*/
d313 2
a314 1
		if (s == NULL)
d316 1
@


1.32
log
@type police and assorted cleanup. From Lionel Fourquaux; ok ray@@
@
text
@d1 1
a1 1
/*	$OpenBSD: util.c,v 1.31 2005/06/20 07:14:06 otto Exp $	*/
a27 4

#ifndef lint
static const char rcsid[] = "$OpenBSD: util.c,v 1.31 2005/06/20 07:14:06 otto Exp $";
#endif /* not lint */
@


1.31
log
@umask juggling not needed; with Lionel Fourquaux.
ok millert@@ espie@@
@
text
@d1 1
a1 1
/*	$OpenBSD: util.c,v 1.30 2005/05/16 15:22:46 espie Exp $	*/
d30 1
a30 1
static const char rcsid[] = "$OpenBSD: util.c,v 1.30 2005/05/16 15:22:46 espie Exp $";
d41 1
@


1.30
log
@Do not call out mkdir -p, but reuse the code from mkdir(1).

Removes the possibility of nasty stuff happening thanks to unquoted
arguments in system(1).

Also plug a small memory leak.

Problems noticed by Lionel Fourquaud.

okay millert@@, deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: util.c,v 1.29 2004/11/19 20:00:57 otto Exp $	*/
d30 1
a30 1
static const char rcsid[] = "$OpenBSD: util.c,v 1.29 2004/11/19 20:00:57 otto Exp $";
a309 1
	mode_t mode, dir_mode;
d320 1
a320 3
	mode = 0777 & ~umask(0);
	dir_mode = mode | S_IWUSR | S_IXUSR;
	if (mkpath(tmpbuf, mode, dir_mode) != 0)
@


1.29
log
@Allow for path names containing spaces and other funny chars (except
tab) by scanning for the tab that separates the date from the
pathname.  If no tab is found, revert back to the old behaviour.
Posix says there should be a space between the pathname and the
date, but all known implementations of diff(1) use a tab.
ok kurt@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: util.c,v 1.28 2004/08/05 21:47:24 deraadt Exp $	*/
d30 1
a30 1
static const char rcsid[] = "$OpenBSD: util.c,v 1.28 2004/08/05 21:47:24 deraadt Exp $";
a51 1

d310 1
d321 5
a325 6
	if (snprintf(buf, sizeof(buf), "%s -p %s", _PATH_MKDIR, tmpbuf)
	    >= sizeof(buf))
		fatal("buffer too small to hold %.20s...\n", tmpbuf);

	if (system(buf))
		pfatal("%.40s failed", buf);
@


1.28
log
@spacing
@
text
@d1 1
a1 1
/*	$OpenBSD: util.c,v 1.27 2003/10/31 20:20:45 millert Exp $	*/
d30 1
a30 1
static const char rcsid[] = "$OpenBSD: util.c,v 1.27 2003/10/31 20:20:45 millert Exp $";
d336 1
a336 1
	int		sleading;
d352 1
d354 2
a355 1
	for (sleading = strip_leading; *t != '\0' && !isspace(*t); t++) {
@


1.27
log
@o fairly major man page reorganization
o add --posix option for strict POSIX conformance
o change filename determination to match GNU patch
Tested by various people, including a full ports build by naddy@@
@
text
@d1 1
a1 1
/*	$OpenBSD: util.c,v 1.26 2003/08/15 08:00:51 otto Exp $	*/
d30 1
a30 1
static const char     rcsid[] = "$OpenBSD: util.c,v 1.26 2003/08/15 08:00:51 otto Exp $";
@


1.26
log
@Add license from patch.c to original source files missing a license.

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: util.c,v 1.25 2003/08/01 20:30:49 otto Exp $	*/
d30 1
a30 1
static const char     rcsid[] = "$OpenBSD: util.c,v 1.25 2003/08/01 20:30:49 otto Exp $";
d333 1
a333 1
fetchname(const char *at, int strip_leading, int assume_exists)
d335 1
a335 1
	char		*fullname, *name, *t, tmpbuf[200];
d345 1
a345 1
		say("fetchname %s %d %d\n", at, strip_leading, assume_exists);
d375 16
a390 3
	if (stat(name, &filestat) && !assume_exists) {
		char	*filebase = basename(name);
		char	*filedir = dirname(name);
d393 1
a393 1
	(snprintf(tmpbuf, sizeof tmpbuf, f, a1, a2, a3), stat(tmpbuf, &filestat) == 0)
d395 8
a402 10
		if (try("%s/RCS/%s%s", filedir, filebase, RCSSUFFIX) ||
		    try("%s/RCS/%s%s", filedir, filebase, "") ||
		    try("%s/%s%s", filedir, filebase, RCSSUFFIX) ||
		    try("%s/SCCS/%s%s", filedir, SCCSPREFIX, filebase) ||
		    try("%s/%s%s", filedir, SCCSPREFIX, filebase))
			return name;
		free(name);
		name = NULL;
	}
	return name;
@


1.25
log
@- use stdbool.h instead of roll-your-own booleans
- fix some -Wall warnings
- fix asserts: in some cases remove them, in other cases they have
become Internal errors or detection of malformed patch files.
- fix some free() related code

ok millert@@ tedu@@
@
text
@d1 27
a27 1
/*	$OpenBSD: util.c,v 1.24 2003/07/31 20:51:43 otto Exp $	*/
d30 1
a30 1
static const char     rcsid[] = "$OpenBSD: util.c,v 1.24 2003/07/31 20:51:43 otto Exp $";
@


1.24
log
@Unbreak relative directory handling. Tweak from millert@@

ok millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: util.c,v 1.23 2003/07/30 15:47:54 millert Exp $	*/
d4 1
a4 1
static const char     rcsid[] = "$OpenBSD: util.c,v 1.23 2003/07/30 15:47:54 millert Exp $";
d165 1
a165 1
			out_of_mem = TRUE;
d278 1
a278 1
 * TRUE, ignore the last element of `filename'.
@


1.23
log
@Make prompting POSIX-compliant.  POSIX states "The patch utility
shall write a prompt to standard output and request a filename
interactively from the controlling terminal (for example, /dev/tty)."
OK deraadt@@ and otto@@
@
text
@d1 1
a1 1
/*	$OpenBSD: util.c,v 1.22 2003/07/29 20:10:17 millert Exp $	*/
d4 1
a4 1
static const char     rcsid[] = "$OpenBSD: util.c,v 1.22 2003/07/29 20:10:17 millert Exp $";
d310 1
d327 1
a327 1
	for (; *t != '\0' && !isspace(*t); t++) {
d329 1
a329 1
			if (--strip_leading >= 0)
@


1.22
log
@o add pathnames.h
o ignore empty TMPDIR environment variable
o strip any trailing slashes from TMPDIR
otto@@ OK
@
text
@d1 1
a1 1
/*	$OpenBSD: util.c,v 1.21 2003/07/28 19:05:26 millert Exp $	*/
d4 1
a4 1
static const char     rcsid[] = "$OpenBSD: util.c,v 1.21 2003/07/28 19:05:26 millert Exp $";
d219 1
a219 1
 * Get a response from the user, somehow or other.
d225 2
a226 3
	int	ttyfd;
	ssize_t	r;
	bool	tty2 = isatty(2);
d229 1
a229 1
	vsnprintf(buf, sizeof buf, fmt, ap);
d231 12
a242 21
	fflush(stderr);
	write(2, buf, strlen(buf));
	if (tty2) {
		/* might be redirected to a file */
		r = read(2, buf, sizeof buf);
	} else if (isatty(1)) {	/* this may be new file output */
		fflush(stdout);
		write(1, buf, strlen(buf));
		r = read(1, buf, sizeof buf);
	} else if ((ttyfd = open(_PATH_TTY, O_RDWR)) >= 0 && isatty(ttyfd)) {
		/* might be deleted or unwriteable */
		write(ttyfd, buf, strlen(buf));
		r = read(ttyfd, buf, sizeof buf);
		close(ttyfd);
	} else if (isatty(0)) {	/* this is probably patch input */
		fflush(stdin);
		write(0, buf, strlen(buf));
		r = read(0, buf, sizeof buf);
	} else {		/* no terminal at all--default it */
		buf[0] = '\n';
		r = 1;
a243 6
	if (r <= 0)
		buf[0] = 0;
	else
		buf[r] = '\0';
	if (!tty2)
		say(buf);
@


1.21
log
@Don't treat consecutive slashes as path components; matches POSIX
OK otto@@ and deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: util.c,v 1.20 2003/07/28 18:35:36 otto Exp $	*/
d4 1
a4 1
static const char     rcsid[] = "$OpenBSD: util.c,v 1.20 2003/07/28 18:35:36 otto Exp $";
d24 1
d311 2
a312 2
	strlcpy(buf, "/bin/mkdir -p ", sizeof buf);
	if (strlcat(buf, tmpbuf, sizeof(buf)) >= sizeof(buf))
d336 3
a338 2
	if (strnEQ(at, "/dev/null", 9))	/* so files can be created by diffing */
		return NULL;	/* against /dev/null. */
@


1.20
log
@More cleanup: sprinkled some const, removed ugly EXTERN/INTERN.h,
some rewriting of code to make it more readable and more KNF.

ok millert@@ tedu@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: util.c,v 1.19 2003/07/28 16:13:53 millert Exp $	*/
d4 1
a4 1
static const char     rcsid[] = "$OpenBSD: util.c,v 1.19 2003/07/28 16:13:53 millert Exp $";
a324 1
	int		sleading = strip_leading;
d339 4
a342 4
	/* Strip off up to `sleading' leading slashes and null terminate.  */
	for (; *t && !isspace(*t); t++)
		if (*t == '/')
			if (--sleading >= 0)
d344 1
@


1.19
log
@Make patch(1) exit value match POSIX and be consistent with diff.
Comments and OK from otto@@
@
text
@d1 1
a1 1
/*	$OpenBSD: util.c,v 1.18 2003/07/25 02:12:45 millert Exp $	*/
d4 1
a4 1
static const char     rcsid[] = "$OpenBSD: util.c,v 1.18 2003/07/25 02:12:45 millert Exp $";
d17 1
a20 1
#include "EXTERN.h"
a21 1
#include "INTERN.h"
d29 1
a29 1
move_file(char *from, char *to)
d31 2
a32 1
	int	i, fromfd;
d72 1
a72 1
backup_file(char *orig)
d74 4
a77 3
	char	bakname[MAXPATHLEN], *s, *simplename;
	dev_t	orig_device;
	ino_t	orig_inode;
d132 1
a132 1
copy_file(char *from, char *to)
d134 2
a135 1
	int	tofd, fromfd, i;
d155 1
a155 1
savestr(char *s)
d157 1
a157 1
	char	*rv, *t;
d161 1
a161 4
	t = s;
	while (*t++)
		;
	rv = malloc((size_t) (t - s));
a166 4
	} else {
		t = rv;
		while ((*t++ = *s++))
			;
d175 1
a175 1
say(char *fmt, ...)
d189 1
a189 1
fatal(char *fmt, ...)
d204 1
a204 1
pfatal(char *fmt, ...)
d221 1
a221 1
ask(char *fmt, ...)
d224 2
a225 1
	int	ttyfd, r;
d297 1
a297 1
makedirs(char *filename, bool striplast)
d322 1
a322 1
fetchname(char *at, int strip_leading, int assume_exists)
d324 3
a326 2
	char	*fullname, *name, *t, tmpbuf[200];
	int	sleading = strip_leading;
d328 1
a328 1
	if (!at || *at == '\0')
@


1.18
log
@Add POSIX -b option but don't change the default beahvior wrt backups
yet.  The old -b option is now -z (matches GNU patch).
@
text
@d1 1
a1 1
/*	$OpenBSD: util.c,v 1.17 2003/07/22 17:52:20 deraadt Exp $	*/
d4 1
a4 1
static const char     rcsid[] = "$OpenBSD: util.c,v 1.17 2003/07/22 17:52:20 deraadt Exp $";
d202 1
a202 1
	my_exit(1);
d219 1
a219 1
	my_exit(1);
d388 1
a388 1
	my_exit(0);
@


1.17
log
@just about nothing
@
text
@d1 1
a1 1
/*	$OpenBSD: util.c,v 1.16 2003/07/22 17:18:49 otto Exp $	*/
d4 1
a4 1
static const char     rcsid[] = "$OpenBSD: util.c,v 1.16 2003/07/22 17:18:49 otto Exp $";
a31 1
	char	bakname[MAXPATHLEN], *s;
d50 33
d85 1
a85 1
		    strlcat(bakname, to, sizeof(bakname)) >= sizeof(bakname))
d88 1
a88 2
		char	*backupname = find_backup_file_name(to);
		if (backupname == (char *) 0)
d90 3
a92 3
		if (strlcpy(bakname, backupname, sizeof(bakname)) >= sizeof(bakname))
			fatal("filename %s too long for buffer\n", backupname);
		free(backupname);
d95 20
a114 56
	if (stat(to, &filestat) == 0) {	/* output file exists */
		dev_t	to_device = filestat.st_dev;
		ino_t	to_inode = filestat.st_ino;
		char	*simplename = bakname;

		for (s = bakname; *s; s++) {
			if (*s == '/')
				simplename = s + 1;
		}

		/*
		 * Find a backup name that is not the same file. Change the
		 * first lowercase char into uppercase; if that isn't
		 * sufficient, chop off the first char and try again.
		 */
		while (stat(bakname, &filestat) == 0 &&
		    to_device == filestat.st_dev && to_inode == filestat.st_ino) {
			/* Skip initial non-lowercase chars.  */
			for (s = simplename; *s && !islower(*s); s++)
				;
			if (*s)
				*s = toupper(*s);
			else
				memmove(simplename, simplename + 1,
				    strlen(simplename + 1) + 1);
		}
		unlink(bakname);

#ifdef DEBUGGING
		if (debug & 4)
			say("Moving %s to %s.\n", to, bakname);
#endif
		if (link(to, bakname) < 0) {
			/*
			 * Maybe `to' is a symlink into a different file
			 * system. Copying replaces the symlink with a file;
			 * using rename would be better.
			 */
			int	tofd, bakfd;

			bakfd = creat(bakname, 0666);
			if (bakfd < 0) {
				say("Can't backup %s, output is in %s: %s\n",
				    to, from, strerror(errno));
				return -1;
			}
			tofd = open(to, O_RDONLY);
			if (tofd < 0)
				pfatal("internal error, can't open %s", to);
			while ((i = read(tofd, buf, sizeof buf)) > 0)
				if (write(bakfd, buf, i) != i)
					pfatal("write failed");
			close(tofd);
			close(bakfd);
		}
		unlink(to);
d118 1
a118 1
		say("Moving %s to %s.\n", from, to);
d120 2
a121 7
	if (link(from, to) < 0) {	/* different file system? */
		int	tofd;

		tofd = creat(to, 0666);
		if (tofd < 0) {
			say("Can't create %s, output is in %s: %s\n",
			    to, from, strerror(errno));
a122 9
		}
		fromfd = open(from, O_RDONLY);
		if (fromfd < 0)
			pfatal("internal error, can't reopen %s", from);
		while ((i = read(fromfd, buf, sizeof buf)) > 0)
			if (write(tofd, buf, i) != i)
				pfatal("write failed");
		close(fromfd);
		close(tofd);
a123 1
	unlink(from);
d130 1
a130 1
void
d135 1
a135 1
	tofd = creat(to, 0666);
d137 2
a138 2
		pfatal("can't create %s", to);
	fromfd = open(from, O_RDONLY);
d146 1
@


1.16
log
@More cleanup.
ok millert@@ tedu@@
@
text
@d1 1
a1 1
/*	$OpenBSD: util.c,v 1.15 2003/07/21 14:32:21 deraadt Exp $	*/
d4 2
a5 2
static const char     rcsid[] = "$OpenBSD: util.c,v 1.15 2003/07/21 14:32:21 deraadt Exp $";
#endif				/* not lint */
@


1.15
log
@fix header
@
text
@d1 1
a1 1
/*	$OpenBSD: util.c,v 1.14 2003/07/21 14:30:31 deraadt Exp $	*/
d4 1
a4 1
static char     rcsid[] = "$OpenBSD: util.c,v 1.14 2003/07/21 14:30:31 deraadt Exp $";
d7 13
a25 1
void            my_exit(int) __attribute__((noreturn));
d46 1
a46 1
			if (write(1, buf, i) != 1)
d182 1
a182 1
	if (rv == Nullch) {
a289 1
#ifndef lint
a301 1
#endif
a309 1
#ifndef lint
a311 1
#endif
d351 1
a351 1
		return Nullch;
d359 1
a359 1
		return Nullch;	/* against /dev/null. */
d398 1
a398 1
		name = Nullch;
d408 15
@


1.14
log
@remove a bit more junk
@
text
@d1 1
a1 1
/* $OpenBSD: util.c,v 1.13 2003/07/21 14:00:41 deraadt Exp $	 */
d4 1
a4 1
static char     rcsid[] = "$OpenBSD: util.c,v 1.13 2003/07/21 14:00:41 deraadt Exp $";
@


1.13
log
@knf and other cleanup; ok otto
@
text
@d1 1
a1 1
/* $OpenBSD: util.c,v 1.12 2003/07/18 02:00:09 deraadt Exp $	 */
d4 1
a4 1
static char     rcsid[] = "$OpenBSD: util.c,v 1.12 2003/07/18 02:00:09 deraadt Exp $";
d169 1
a169 1
	rv = malloc((MEM) (t - s));
@


1.12
log
@remove junk; ok otto tedu
@
text
@d1 1
a1 1
/*	$OpenBSD: util.c,v 1.11 2003/04/08 00:18:31 deraadt Exp $	*/
d4 2
a5 2
static char rcsid[] = "$OpenBSD: util.c,v 1.11 2003/04/08 00:18:31 deraadt Exp $";
#endif /* not lint */
d13 1
a13 1
void my_exit(int) __attribute__((noreturn));
d18 1
a18 2
move_file(from,to)
char *from, *to;
d20 2
a21 4
    char bakname[MAXPATHLEN];
    char *s;
    int i;
    int fromfd;
d23 1
a23 1
    /* to stdout? */
d25 1
a25 1
    if (strEQ(to, "-")) {
d27 2
a28 2
	if (debug & 4)
	    say("Moving %s to stdout.\n", from);
d30 8
a37 37
	fromfd = open(from, O_RDONLY);
	if (fromfd < 0)
	    pfatal("internal error, can't reopen %s", from);
	while ((i=read(fromfd, buf, sizeof buf)) > 0)
	    if (write(1, buf, i) != 1)
		pfatal("write failed");
	close(fromfd);
	return 0;
    }

    if (origprae) {
	if (strlcpy(bakname, origprae, sizeof(bakname)) >= sizeof(bakname) ||
	    strlcat(bakname, to, sizeof(bakname)) >= sizeof(bakname))
	    fatal("filename %s too long for buffer\n", origprae);
    } else {
#ifndef NODIR
	char *backupname = find_backup_file_name(to);
	if (backupname == (char *) 0)
	    fatal("out of memory\n");
	if (strlcpy(bakname, backupname, sizeof(bakname)) >= sizeof(bakname))
	    fatal("filename %s too long for buffer\n", backupname);
	free(backupname);
#else /* NODIR */
	if (strlcpy(bakname, to, sizeof(bakname)) >= sizeof(bakname) ||
	    strlcat(bakname, simple_backup_suffix, sizeof(bakname)) >= sizeof(bakname))
	    fatal("filename %s too long for buffer\n", to);
#endif /* NODIR */
    }

    if (stat(to, &filestat) == 0) {	/* output file exists */
	dev_t to_device = filestat.st_dev;
	ino_t to_inode  = filestat.st_ino;
	char *simplename = bakname;

	for (s=bakname; *s; s++) {
	    if (*s == '/')
		simplename = s+1;
d39 11
a49 11
	/* Find a backup name that is not the same file.
	   Change the first lowercase char into uppercase;
	   if that isn't sufficient, chop off the first char and try again.  */
	while (stat(bakname, &filestat) == 0 &&
		to_device == filestat.st_dev && to_inode == filestat.st_ino) {
	    /* Skip initial non-lowercase chars.  */
	    for (s=simplename; *s && !islower(*s); s++) ;
	    if (*s)
		*s = toupper(*s);
	    else
		memmove(simplename, simplename+1, strlen(simplename+1)+1);
d51 29
a79 1
	while (unlink(bakname) >= 0) ;	/* while() is for benefit of Eunice */
d81 2
a82 2
	if (debug & 4)
	    say("Moving %s to %s.\n", to, bakname);
d84 24
a107 21
	if (link(to, bakname) < 0) {
	    /* Maybe `to' is a symlink into a different file system.
	       Copying replaces the symlink with a file; using rename
	       would be better.  */
	    int tofd;
	    int bakfd;

	    bakfd = creat(bakname, 0666);
	    if (bakfd < 0) {
		say("Can't backup %s, output is in %s: %s\n", to, from,
		     strerror(errno));
		return -1;
	    }
	    tofd = open(to, O_RDONLY);
	    if (tofd < 0)
		pfatal("internal error, can't open %s", to);
	    while ((i=read(tofd, buf, sizeof buf)) > 0)
		if (write(bakfd, buf, i) != i)
		    pfatal("write failed");
	    close(tofd);
	    close(bakfd);
a108 2
	while (unlink(to) >= 0) ;
    }
d110 2
a111 2
    if (debug & 4)
	say("Moving %s to %s.\n", from, to);
d113 29
a141 2
    if (link(from, to) < 0) {		/* different file system? */
	int tofd;
d144 2
a145 5
	if (tofd < 0) {
	    say("Can't create %s, output is in %s: %s\n",
	      to, from, strerror(errno));
	    return -1;
	}
d148 4
a151 4
	    pfatal("internal error, can't reopen %s", from);
	while ((i=read(fromfd, buf, sizeof buf)) > 0)
	    if (write(tofd, buf, i) != i)
		pfatal("write failed");
a153 3
    }
    unlink(from);
    return 0;
d156 3
a158 25
/* Copy a file. */

void
copy_file(from,to)
char *from, *to;
{
    int tofd;
    int fromfd;
    int i;

    tofd = creat(to, 0666);
    if (tofd < 0)
	pfatal("can't create %s", to);
    fromfd = open(from, O_RDONLY);
    if (fromfd < 0)
	pfatal("internal error, can't reopen %s", from);
    while ((i=read(fromfd, buf, sizeof buf)) > 0)
	if (write(tofd, buf, i) != i)
	    pfatal("write to %s failed", to);
    close(fromfd);
    close(tofd);
}

/* Allocate a unique area for a string. */

d160 1
a160 2
savestr(s)
char *s;
d162 1
a162 2
    char *rv;
    char *t;
d164 17
a180 17
    if (!s)
	s = "Oops";
    t = s;
    while (*t++);
    rv = malloc((MEM) (t - s));
    if (rv == Nullch) {
	if (using_plan_a)
	    out_of_mem = TRUE;
	else
	    fatal("out of memory\n");
    }
    else {
	t = rv;
	while ((*t++ = *s++))
	    ;
    }
    return rv;
d183 3
a185 2
/* Vanilla terminal output (buffered). */

d189 1
a189 1
    va_list ap;
d191 4
a194 4
    va_start(ap, fmt);
    vfprintf(stderr, fmt, ap);
    va_end(ap);
    fflush(stderr);
d197 3
a199 2
/* Terminal output, pun intended. */

d203 1
a203 1
    va_list ap;
d205 5
a209 5
    va_start(ap, fmt);
    fprintf(stderr, "patch: **** ");
    vfprintf(stderr, fmt, ap);
    va_end(ap);
    my_exit(1);
d212 3
a214 2
/* Say something from patch, something from the system, then silence . . . */

d218 2
a219 2
    va_list ap;
    int errnum = errno;
d221 6
a226 6
    fprintf(stderr, "patch: **** ");
    va_start(ap, fmt);
    vfprintf(stderr, fmt, ap);
    va_end(ap);
    fprintf(stderr, ": %s\n", strerror(errnum));
    my_exit(1);
d229 3
a231 2
/* Get a response from the user, somehow or other. */

d235 35
a269 35
    va_list ap;
    int ttyfd;
    int r;
    bool tty2 = isatty(2);

    va_start(ap, fmt);
    vsnprintf(buf, sizeof buf, fmt, ap);
    va_end(ap);
    fflush(stderr);
    write(2, buf, strlen(buf));
    if (tty2) {				/* might be redirected to a file */
	r = read(2, buf, sizeof buf);
    } else if (isatty(1)) {		/* this may be new file output */
	fflush(stdout);
	write(1, buf, strlen(buf));
	r = read(1, buf, sizeof buf);
    } else if ((ttyfd = open(_PATH_TTY, O_RDWR)) >= 0 && isatty(ttyfd)) {
	/* might be deleted or unwriteable */
	write(ttyfd, buf, strlen(buf));
	r = read(ttyfd, buf, sizeof buf);
	close(ttyfd);
    } else if (isatty(0)) {		/* this is probably patch input */
	fflush(stdin);
	write(0, buf, strlen(buf));
	r = read(0, buf, sizeof buf);
    } else {				/* no terminal at all--default it */
	buf[0] = '\n';
	r = 1;
    }
    if (r <= 0)
	buf[0] = 0;
    else
	buf[r] = '\0';
    if (!tty2)
	say(buf);
d272 3
a274 2
/* How to handle certain events when not in a critical region. */

d276 1
a276 2
set_signals(reset)
int reset;
d279 1
a279 1
    static sig_t hupval, intval;
d281 10
a290 10
    if (!reset) {
	hupval = signal(SIGHUP, SIG_IGN);
	if (hupval != SIG_IGN)
	    hupval = (sig_t)my_exit;
	intval = signal(SIGINT, SIG_IGN);
	if (intval != SIG_IGN)
	    intval = (sig_t)my_exit;
    }
    signal(SIGHUP, hupval);
    signal(SIGINT, intval);
d294 3
a296 2
/* How to handle certain events when in a critical region. */

d298 1
a298 1
ignore_signals()
d301 2
a302 2
    signal(SIGHUP, SIG_IGN);
    signal(SIGINT, SIG_IGN);
d306 4
a309 2
/* Make sure we'll have the directories to create a file.
   If `striplast' is TRUE, ignore the last element of `filename'.  */
d312 1
a312 3
makedirs(filename,striplast)
char *filename;
bool striplast;
d314 1
a314 1
    char *tmpbuf;
d316 2
a317 2
    if ((tmpbuf = strdup(filename)) == NULL)
        fatal("out of memory\n");
d319 9
a327 6
    if (striplast) {
        char *s = strrchr(tmpbuf, '/');
	if (s == NULL)
	  return; /* nothing to be done */
	*s = '\0';
    }
d329 2
a330 6
    strlcpy(buf, "/bin/mkdir -p ", sizeof buf);
    if (strlcat(buf, tmpbuf, sizeof(buf)) >= sizeof(buf))
      fatal("buffer too small to hold %.20s...\n", tmpbuf);

    if (system(buf))
      pfatal("%.40s failed", buf);
d333 8
a340 1
/* Make filenames more reasonable. */
d342 4
a345 16
char *
fetchname(at,strip_leading,assume_exists)
char *at;
int strip_leading;
int assume_exists;
{
    char *fullname;
    char *name;
    char *t;
    char tmpbuf[200];
    int sleading = strip_leading;

    if (!at || *at == '\0')
	return Nullch;
    while (isspace(*at))
	at++;
d347 2
a348 2
    if (debug & 128)
	say("fetchname %s %d %d\n",at,strip_leading,assume_exists);
d350 22
a371 20
    if (strnEQ(at, "/dev/null", 9))	/* so files can be created by diffing */
	return Nullch;			/*   against /dev/null. */
    name = fullname = t = savestr(at);

    /* Strip off up to `sleading' leading slashes and null terminate.  */
    for (; *t && !isspace(*t); t++)
	if (*t == '/')
	    if (--sleading >= 0)
		name = t+1;
    *t = '\0';

    /* If no -p option was given (957 is the default value!),
       we were given a relative pathname,
       and the leading directories that we just stripped off all exist,
       put them back on.  */
    if (strip_leading == 957 && name != fullname && *fullname != '/') {
	name[-1] = '\0';
	if (stat(fullname, &filestat) == 0 && S_ISDIR (filestat.st_mode)) {
	    name[-1] = '/';
	    name=fullname;
d373 2
a374 1
    }
d376 17
a392 19
    name = savestr(name);
    free(fullname);

    if (stat(name, &filestat) && !assume_exists) {
	char *filebase = basename(name);
	char *filedir = dirname(name);

#define try(f, a1, a2, a3) (snprintf(tmpbuf, sizeof tmpbuf, f, a1, a2, a3), stat(tmpbuf, &filestat) == 0)
	if (   try("%s/RCS/%s%s", filedir, filebase, RCSSUFFIX)
	    || try("%s/RCS/%s%s", filedir, filebase,        "")
	    || try(    "%s/%s%s", filedir, filebase, RCSSUFFIX)
	    || try("%s/SCCS/%s%s", filedir, SCCSPREFIX, filebase)
	    || try(     "%s/%s%s", filedir, SCCSPREFIX, filebase))
	  return name;
	free(name);
	name = Nullch;
    }

    return name;
d396 1
a396 1
version()
d398 2
a399 2
    fprintf(stderr, "Patch version 2.0-12u8-OpenBSD\n");
    my_exit(0);
@


1.11
log
@strcpy trashing, help from tedu; ok tedu
@
text
@d1 1
a1 1
/*	$OpenBSD: util.c,v 1.10 2003/04/05 17:17:53 deraadt Exp $	*/
d4 1
a4 1
static char rcsid[] = "$OpenBSD: util.c,v 1.10 2003/04/05 17:17:53 deraadt Exp $";
d13 1
a13 5
#ifdef __GNUC__
void my_exit() __attribute__((noreturn));
#else
void my_exit();
#endif
d22 3
a24 3
    Reg1 char *s;
    Reg2 int i;
    Reg3 int fromfd;
d31 1
a31 1
	    say2("Moving %s to stdout.\n", from);
d35 1
a35 1
	    pfatal2("internal error, can't reopen %s", from);
d38 2
a39 2
		pfatal1("write failed");
	Close(fromfd);
d46 1
a46 1
	    fatal2("filename %s too long for buffer\n", origprae);
d51 1
a51 1
	    fatal1("out of memory\n");
d53 1
a53 1
	    fatal2("filename %s too long for buffer\n", backupname);
d58 1
a58 1
	    fatal2("filename %s too long for buffer\n", to);
d66 1
a66 1
	
d86 1
a86 1
	    say3("Moving %s to %s.\n", to, bakname);
d92 2
a93 2
	    Reg4 int tofd;
	    Reg5 int bakfd;
d97 1
a97 1
		say4("Can't backup %s, output is in %s: %s\n", to, from,
d103 1
a103 1
		pfatal2("internal error, can't open %s", to);
d106 3
a108 3
		    pfatal1("write failed");
	    Close(tofd);
	    Close(bakfd);
d114 1
a114 1
	say3("Moving %s to %s.\n", from, to);
d117 2
a118 2
	Reg4 int tofd;
	
d121 1
a121 1
	    say4("Can't create %s, output is in %s: %s\n",
d127 1
a127 1
	    pfatal2("internal error, can't reopen %s", from);
d130 3
a132 3
		pfatal1("write failed");
	Close(fromfd);
	Close(tofd);
d134 1
a134 1
    Unlink(from);
d144 4
a147 4
    Reg3 int tofd;
    Reg2 int fromfd;
    Reg1 int i;
    
d150 1
a150 1
	pfatal2("can't create %s", to);
d153 1
a153 1
	pfatal2("internal error, can't reopen %s", from);
d156 3
a158 3
	    pfatal2("write to %s failed", to);
    Close(fromfd);
    Close(tofd);
d165 1
a165 1
Reg1 char *s;
d167 2
a168 2
    Reg3 char *rv;
    Reg2 char *t;
d179 1
a179 1
	    fatal1("out of memory\n");
a188 13
#if defined(lint) && defined(CANVARARG)

/*VARARGS ARGSUSED*/
say(pat) char *pat; { ; }
/*VARARGS ARGSUSED*/
fatal(pat) char *pat; { ; }
/*VARARGS ARGSUSED*/
pfatal(pat) char *pat; { ; }
/*VARARGS ARGSUSED*/
ask(pat) char *pat; { ; }

#else

d192 1
a192 3
say(pat,arg1,arg2,arg3)
char *pat;
long arg1,arg2,arg3;
d194 6
a199 2
    fprintf(stderr, pat, arg1, arg2, arg3);
    Fflush(stderr);
d204 2
a205 4
void				/* very void */
fatal(pat,arg1,arg2,arg3)
char *pat;
long arg1,arg2,arg3;
d207 3
d211 2
a212 1
    fprintf(stderr, pat, arg1, arg2, arg3);
d218 2
a219 4
void				/* very void */
pfatal(pat,arg1,arg2,arg3)
char *pat;
long arg1,arg2,arg3;
d221 1
d225 3
a227 1
    fprintf(stderr, pat, arg1, arg2, arg3);
d235 1
a235 3
ask(pat,arg1,arg2,arg3)
char *pat;
long arg1,arg2,arg3;
d237 1
d242 4
a245 2
    Snprintf(buf, sizeof buf, pat, arg1, arg2, arg3);
    Fflush(stderr);
d249 2
a250 3
    }
    else if (isatty(1)) {		/* this may be new file output */
	Fflush(stdout);
d253 2
a254 3
    }
    else if ((ttyfd = open(_PATH_TTY, O_RDWR)) >= 0 && isatty(ttyfd)) {
					/* might be deleted or unwriteable */
d257 3
a259 4
	Close(ttyfd);
    }
    else if (isatty(0)) {		/* this is probably patch input */
	Fflush(stdin);
d262 1
a262 2
    }
    else {				/* no terminal at all--default it */
d271 1
a271 1
	say1(buf);
a272 1
#endif /* lint */
d291 2
a292 2
    Signal(SIGHUP, hupval);
    Signal(SIGINT, intval);
d302 2
a303 2
    Signal(SIGHUP, SIG_IGN);
    Signal(SIGINT, SIG_IGN);
d312 1
a312 1
Reg1 char *filename;
d318 1
a318 1
        fatal1("out of memory\n");
d329 1
a329 1
      fatal2("buffer too small to hold %.20s...\n", tmpbuf);
d332 1
a332 1
      pfatal2("%.40s failed", buf);
d345 1
a345 1
    Reg1 char *t;
d355 1
a355 1
	say4("fetchname %s %d %d\n",at,strip_leading,assume_exists);
d387 1
a387 1
#define try(f, a1, a2, a3) (Snprintf(tmpbuf, sizeof tmpbuf, f, a1, a2, a3), stat(tmpbuf, &filestat) == 0)
d399 7
@


1.10
log
@string fixes; ok miod henning
@
text
@d1 1
a1 1
/*	$OpenBSD: util.c,v 1.9 1999/12/04 21:00:03 provos Exp $	*/
d4 1
a4 1
static char rcsid[] = "$OpenBSD: util.c,v 1.9 1999/12/04 21:00:03 provos Exp $";
d85 1
a85 1
		strcpy(simplename, simplename+1);
@


1.9
log
@a few more overflows gone
@
text
@d1 1
a1 1
/*	$OpenBSD: util.c,v 1.8 1999/12/04 01:04:14 provos Exp $	*/
d4 1
a4 1
static char rcsid[] = "$OpenBSD: util.c,v 1.8 1999/12/04 01:04:14 provos Exp $";
d343 1
a343 1
    strcpy(buf, "/bin/mkdir -p ");
@


1.8
log
@revert strlcpy to strcpy for one case.
@
text
@d1 1
a1 1
/*	$OpenBSD: util.c,v 1.7 1999/12/04 01:01:07 provos Exp $	*/
d4 1
a4 1
static char rcsid[] = "$OpenBSD: util.c,v 1.7 1999/12/04 01:01:07 provos Exp $";
d331 10
a340 17
    char tmpbuf[256];
    Reg2 char *s = tmpbuf;
    char *dirv[20];		/* Point to the NULs between elements.  */
    Reg3 int i;
    Reg4 int dirvp = 0;		/* Number of finished entries in dirv. */

    /* Copy `filename' into `tmpbuf' with a NUL instead of a slash
       between the directories.  */
    while (*filename) {
	if (*filename == '/') {
	    filename++;
	    dirv[dirvp++] = s;
	    *s++ = '\0';
	}
	else {
	    *s++ = *filename++;
	}
d342 7
a348 21
    *s = '\0';
    dirv[dirvp] = s;
    if (striplast)
	dirvp--;
    if (dirvp < 0)
	return;

    strcpy(buf, "mkdir");
    s = buf;
    for (i=0; i<=dirvp; i++) {
	struct stat sbuf;

	if (stat(tmpbuf, &sbuf) && errno == ENOENT) {
	    while (*s) s++;
	    *s++ = ' ';
	    strcpy(s, tmpbuf);
	}
	*dirv[i] = '/';
    }
    if (s != buf)
	system(buf);
@


1.7
log
@avoid overflows
@
text
@d1 1
a1 1
/*	$OpenBSD: util.c,v 1.6 1999/01/11 00:16:32 marc Exp $	*/
d4 1
a4 1
static char rcsid[] = "$OpenBSD: util.c,v 1.6 1999/01/11 00:16:32 marc Exp $";
d364 1
a364 1
	    strlcpy(s, tmpbuf, strlen(s) + 1);
@


1.6
log
@fix seg fault on sparc
@
text
@d1 1
a1 1
/*	$OpenBSD: util.c,v 1.5 1999/01/03 05:33:48 millert Exp $	*/
d4 1
a4 1
static char rcsid[] = "$OpenBSD: util.c,v 1.5 1999/01/03 05:33:48 millert Exp $";
d48 3
a50 2
	Strcpy(bakname, origprae);
	Strcat(bakname, to);
d56 2
a57 1
	Strcpy(bakname, backupname);
d60 3
a62 2
	Strcpy(bakname, to);
    	Strcat(bakname, simple_backup_suffix);
d85 1
a85 1
		Strcpy(simplename, simplename+1);
d364 1
a364 1
	    strcpy(s, tmpbuf);
@


1.5
log
@Use libc basename(3) and dirname(3) instead of defining our own.  Also clean up some nasty assumptions that basename() returns a pointer that lies within its argument
@
text
@d1 1
a1 1
/*	$OpenBSD: util.c,v 1.4 1997/09/22 05:45:27 millert Exp $	*/
d4 1
a4 1
static char rcsid[] = "$OpenBSD: util.c,v 1.4 1997/09/22 05:45:27 millert Exp $";
d421 1
a421 1
#define try(f, a1, a2, a3) (Snprintf(tmpbuf, sizeof tmpbuf, f, a1, a2), stat(tmpbuf, &filestat) == 0)
@


1.4
log
@Start of -Wall and cleaning up icky bits.
@
text
@d1 1
a1 1
/*	$OpenBSD: util.c,v 1.3 1996/09/24 04:19:30 millert Exp $	*/
d4 1
a4 1
static char rcsid[] = "$OpenBSD: util.c,v 1.3 1996/09/24 04:19:30 millert Exp $";
d383 1
a383 1
    if (!at)
d419 1
a419 1
	int pathlen = filebase - name;
d421 6
a426 9
	/* Put any leading path into `tmpbuf'.  */
	strncpy(tmpbuf, name, pathlen);

#define try(f, a1, a2) (Snprintf(tmpbuf + pathlen, sizeof tmpbuf - pathlen, f, a1, a2), stat(tmpbuf, &filestat) == 0)
	if (   try("RCS/%s%s", filebase, RCSSUFFIX)
	    || try("RCS/%s%s", filebase,        "")
	    || try(    "%s%s", filebase, RCSSUFFIX)
	    || try("SCCS/%s%s", SCCSPREFIX, filebase)
	    || try(     "%s%s", SCCSPREFIX, filebase))
@


1.3
log
@sprintf -> snprintf except where guaranteed safe.
@
text
@d1 1
a1 1
/*	$OpenBSD: util.c,v 1.2 1996/06/10 11:21:34 niklas Exp $	*/
d4 1
a4 1
static char rcsid[] = "$OpenBSD: util.c,v 1.2 1996/06/10 11:21:34 niklas Exp $";
d13 3
d17 1
d25 1
a25 1
    char bakname[512];
d37 1
a37 1
	fromfd = open(from, 0);
d102 1
a102 1
	    tofd = open(to, 0);
d126 1
a126 1
	fromfd = open(from, 0);
d152 1
a152 1
    fromfd = open(from, 0);
d184 2
a185 1
	while (*t++ = *s++);
d263 1
a263 1
    else if ((ttyfd = open("/dev/tty", 2)) >= 0 && isatty(ttyfd)) {
d294 1
a294 5
#ifdef VOIDSIG
    static void (*hupval)(),(*intval)();
#else
    static int (*hupval)(),(*intval)();
#endif
d299 1
a299 5
#ifdef VOIDSIG
	    hupval = my_exit;
#else
	    hupval = (int(*)())my_exit;
#endif
d302 1
a302 5
#ifdef VOIDSIG
	    intval = my_exit;
#else
	    intval = (int(*)())my_exit;
#endif
d426 1
a426 1
	    || try("RCS/%s"  , filebase,         0)
@


1.2
log
@Support the long options that FSF's patch version has.  $OpenBSD$ added
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d4 1
a4 1
static char rcsid[] = "$OpenBSD: util.c,v 1.1.1.1 1995/10/18 08:45:56 deraadt Exp $";
d247 1
a247 1
    Sprintf(buf, pat, arg1, arg2, arg3);
d431 1
a431 1
#define try(f, a1, a2) (Sprintf(tmpbuf + pathlen, f, a1, a2), stat(tmpbuf, &filestat) == 0)
@


1.1
log
@Initial revision
@
text
@d1 2
d4 1
a4 1
static char rcsid[] = "$Id: util.c,v 1.3 1993/12/07 10:36:16 mycroft Exp $";
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@
