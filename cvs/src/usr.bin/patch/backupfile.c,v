head	1.21;
access;
symbols
	OPENBSD_6_2:1.21.0.18
	OPENBSD_6_2_BASE:1.21
	OPENBSD_6_1:1.21.0.16
	OPENBSD_6_1_BASE:1.21
	OPENBSD_6_0:1.21.0.12
	OPENBSD_6_0_BASE:1.21
	OPENBSD_5_9:1.21.0.8
	OPENBSD_5_9_BASE:1.21
	OPENBSD_5_8:1.21.0.10
	OPENBSD_5_8_BASE:1.21
	OPENBSD_5_7:1.21.0.2
	OPENBSD_5_7_BASE:1.21
	OPENBSD_5_6:1.21.0.6
	OPENBSD_5_6_BASE:1.21
	OPENBSD_5_5:1.21.0.4
	OPENBSD_5_5_BASE:1.21
	OPENBSD_5_4:1.20.0.16
	OPENBSD_5_4_BASE:1.20
	OPENBSD_5_3:1.20.0.14
	OPENBSD_5_3_BASE:1.20
	OPENBSD_5_2:1.20.0.12
	OPENBSD_5_2_BASE:1.20
	OPENBSD_5_1_BASE:1.20
	OPENBSD_5_1:1.20.0.10
	OPENBSD_5_0:1.20.0.8
	OPENBSD_5_0_BASE:1.20
	OPENBSD_4_9:1.20.0.6
	OPENBSD_4_9_BASE:1.20
	OPENBSD_4_8:1.20.0.4
	OPENBSD_4_8_BASE:1.20
	OPENBSD_4_7:1.20.0.2
	OPENBSD_4_7_BASE:1.20
	OPENBSD_4_6:1.19.0.16
	OPENBSD_4_6_BASE:1.19
	OPENBSD_4_5:1.19.0.12
	OPENBSD_4_5_BASE:1.19
	OPENBSD_4_4:1.19.0.10
	OPENBSD_4_4_BASE:1.19
	OPENBSD_4_3:1.19.0.8
	OPENBSD_4_3_BASE:1.19
	OPENBSD_4_2:1.19.0.6
	OPENBSD_4_2_BASE:1.19
	OPENBSD_4_1:1.19.0.4
	OPENBSD_4_1_BASE:1.19
	OPENBSD_4_0:1.19.0.2
	OPENBSD_4_0_BASE:1.19
	OPENBSD_3_9:1.18.0.8
	OPENBSD_3_9_BASE:1.18
	OPENBSD_3_8:1.18.0.6
	OPENBSD_3_8_BASE:1.18
	OPENBSD_3_7:1.18.0.4
	OPENBSD_3_7_BASE:1.18
	OPENBSD_3_6:1.18.0.2
	OPENBSD_3_6_BASE:1.18
	OPENBSD_3_5:1.17.0.4
	OPENBSD_3_5_BASE:1.17
	OPENBSD_3_4:1.17.0.2
	OPENBSD_3_4_BASE:1.17
	OPENBSD_3_3:1.7.0.14
	OPENBSD_3_3_BASE:1.7
	OPENBSD_3_2:1.7.0.12
	OPENBSD_3_2_BASE:1.7
	OPENBSD_3_1:1.7.0.10
	OPENBSD_3_1_BASE:1.7
	OPENBSD_3_0:1.7.0.8
	OPENBSD_3_0_BASE:1.7
	OPENBSD_2_9_BASE:1.7
	OPENBSD_2_9:1.7.0.6
	OPENBSD_2_8:1.7.0.4
	OPENBSD_2_8_BASE:1.7
	OPENBSD_2_7:1.7.0.2
	OPENBSD_2_7_BASE:1.7
	OPENBSD_2_6:1.6.0.4
	OPENBSD_2_6_BASE:1.6
	OPENBSD_2_5:1.6.0.2
	OPENBSD_2_5_BASE:1.6
	OPENBSD_2_4:1.3.0.8
	OPENBSD_2_4_BASE:1.3
	OPENBSD_2_3:1.3.0.6
	OPENBSD_2_3_BASE:1.3
	OPENBSD_2_2:1.3.0.4
	OPENBSD_2_2_BASE:1.3
	OPENBSD_2_1:1.3.0.2
	OPENBSD_2_1_BASE:1.3
	OPENBSD_2_0:1.2.0.2
	OPENBSD_2_0_BASE:1.2
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.21
date	2013.11.26.13.19.07;	author deraadt;	state Exp;
branches;
next	1.20;

1.20
date	2009.10.27.23.59.41;	author deraadt;	state Exp;
branches;
next	1.19;

1.19
date	2006.03.11.19.41.30;	author otto;	state Exp;
branches;
next	1.18;

1.18
date	2004.08.05.21.47.24;	author deraadt;	state Exp;
branches;
next	1.17;

1.17
date	2003.08.01.20.30.48;	author otto;	state Exp;
branches;
next	1.16;

1.16
date	2003.07.28.18.35.36;	author otto;	state Exp;
branches;
next	1.15;

1.15
date	2003.07.28.16.13.53;	author millert;	state Exp;
branches;
next	1.14;

1.14
date	2003.07.22.17.52.20;	author deraadt;	state Exp;
branches;
next	1.13;

1.13
date	2003.07.22.17.18.49;	author otto;	state Exp;
branches;
next	1.12;

1.12
date	2003.07.21.14.32.21;	author deraadt;	state Exp;
branches;
next	1.11;

1.11
date	2003.07.21.14.00.41;	author deraadt;	state Exp;
branches;
next	1.10;

1.10
date	2003.07.18.02.00.09;	author deraadt;	state Exp;
branches;
next	1.9;

1.9
date	2003.04.06.04.14.09;	author millert;	state Exp;
branches;
next	1.8;

1.8
date	2003.04.05.17.17.53;	author deraadt;	state Exp;
branches;
next	1.7;

1.7
date	99.12.04.21.00.03;	author provos;	state Exp;
branches;
next	1.6;

1.6
date	99.01.03.05.33.48;	author millert;	state Exp;
branches;
next	1.5;

1.5
date	99.01.03.04.49.28;	author millert;	state Exp;
branches;
next	1.4;

1.4
date	99.01.03.04.20.07;	author millert;	state Exp;
branches;
next	1.3;

1.3
date	97.01.17.07.18.02;	author millert;	state Exp;
branches;
next	1.2;

1.2
date	96.06.10.11.21.25;	author niklas;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.45.55;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.45.55;	author deraadt;	state Exp;
branches;
next	;


desc
@@


1.21
log
@unsigned char casts for ctype
ok krw
@
text
@/*	$OpenBSD: backupfile.c,v 1.20 2009/10/27 23:59:41 deraadt Exp $	*/

/*
 * backupfile.c -- make Emacs style backup file names Copyright (C) 1990 Free
 * Software Foundation, Inc.
 * 
 * This program is free software; you can redistribute it and/or modify it
 * without restriction.
 * 
 * This program is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.
 */

/*
 * David MacKenzie <djm@@ai.mit.edu>. Some algorithms adapted from GNU Emacs.
 */

#include <ctype.h>
#include <dirent.h>
#include <libgen.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>

#include "backupfile.h"


#define ISDIGIT(c) (isascii (c) && isdigit (c))

/* Which type of backup file names are generated. */
enum backup_type backup_type = none;

/*
 * The extension added to file names to produce a simple (as opposed to
 * numbered) backup file name.
 */
char		*simple_backup_suffix = "~";

static char	*concat(const char *, const char *);
static char	*make_version_name(const char *, int);
static int	max_backup_version(const char *, const char *);
static int	version_number(const char *, const char *, size_t);
static int	argmatch(const char *, const char **);
static void	invalid_arg(const char *, const char *, int);

/*
 * Return the name of the new backup file for file FILE, allocated with
 * malloc.  Return 0 if out of memory. FILE must not end with a '/' unless it
 * is the root directory. Do not call this function if backup_type == none.
 */
char *
find_backup_file_name(const char *file)
{
	char	*dir, *base_versions;
	int	highest_backup;

	if (backup_type == simple)
		return concat(file, simple_backup_suffix);
	base_versions = concat(basename(file), ".~");
	if (base_versions == NULL)
		return NULL;
	dir = dirname(file);
	if (dir == NULL) {
		free(base_versions);
		return NULL;
	}
	highest_backup = max_backup_version(base_versions, dir);
	free(base_versions);
	if (backup_type == numbered_existing && highest_backup == 0)
		return concat(file, simple_backup_suffix);
	return make_version_name(file, highest_backup + 1);
}

/*
 * Return the number of the highest-numbered backup file for file FILE in
 * directory DIR.  If there are no numbered backups of FILE in DIR, or an
 * error occurs reading DIR, return 0. FILE should already have ".~" appended
 * to it.
 */
static int
max_backup_version(const char *file, const char *dir)
{
	DIR	*dirp;
	struct dirent	*dp;
	int	highest_version, this_version;
	size_t	file_name_length;

	dirp = opendir(dir);
	if (dirp == NULL)
		return 0;

	highest_version = 0;
	file_name_length = strlen(file);

	while ((dp = readdir(dirp)) != NULL) {
		if (dp->d_namlen <= file_name_length)
			continue;

		this_version = version_number(file, dp->d_name, file_name_length);
		if (this_version > highest_version)
			highest_version = this_version;
	}
	closedir(dirp);
	return highest_version;
}

/*
 * Return a string, allocated with malloc, containing "FILE.~VERSION~".
 * Return 0 if out of memory.
 */
static char *
make_version_name(const char *file, int version)
{
	char	*backup_name;

	if (asprintf(&backup_name, "%s.~%d~", file, version) == -1)
		return NULL;
	return backup_name;
}

/*
 * If BACKUP is a numbered backup of BASE, return its version number;
 * otherwise return 0.  BASE_LENGTH is the length of BASE. BASE should
 * already have ".~" appended to it.
 */
static int
version_number(const char *base, const char *backup, size_t base_length)
{
	int		version;
	const char	*p;

	version = 0;
	if (!strncmp(base, backup, base_length) &&
	    ISDIGIT((unsigned char)backup[base_length])) {
		for (p = &backup[base_length]; ISDIGIT((unsigned char)*p); ++p)
			version = version * 10 + *p - '0';
		if (p[0] != '~' || p[1])
			version = 0;
	}
	return version;
}

/*
 * Return the newly-allocated concatenation of STR1 and STR2. If out of
 * memory, return 0.
 */
static char  *
concat(const char *str1, const char *str2)
{
	char	*newstr;

	if (asprintf(&newstr, "%s%s", str1, str2) == -1)
		return NULL;
	return newstr;
}

/*
 * If ARG is an unambiguous match for an element of the null-terminated array
 * OPTLIST, return the index in OPTLIST of the matched element, else -1 if it
 * does not match any element or -2 if it is ambiguous (is a prefix of more
 * than one element).
 */
static int
argmatch(const char *arg, const char **optlist)
{
	int	i;	/* Temporary index in OPTLIST. */
	size_t	arglen;	/* Length of ARG. */
	int	matchind = -1;	/* Index of first nonexact match. */
	int	ambiguous = 0;	/* If nonzero, multiple nonexact match(es). */

	arglen = strlen(arg);

	/* Test all elements for either exact match or abbreviated matches.  */
	for (i = 0; optlist[i]; i++) {
		if (!strncmp(optlist[i], arg, arglen)) {
			if (strlen(optlist[i]) == arglen)
				/* Exact match found.  */
				return i;
			else if (matchind == -1)
				/* First nonexact match found.  */
				matchind = i;
			else
				/* Second nonexact match found.  */
				ambiguous = 1;
		}
	}
	if (ambiguous)
		return -2;
	else
		return matchind;
}

/*
 * Error reporting for argmatch. KIND is a description of the type of entity
 * that was being matched. VALUE is the invalid value that was given. PROBLEM
 * is the return value from argmatch.
 */
static void
invalid_arg(const char *kind, const char *value, int problem)
{
	fprintf(stderr, "patch: ");
	if (problem == -1)
		fprintf(stderr, "invalid");
	else			/* Assume -2. */
		fprintf(stderr, "ambiguous");
	fprintf(stderr, " %s `%s'\n", kind, value);
}

static const char *backup_args[] = {
	"never", "simple", "nil", "existing", "t", "numbered", 0
};

static enum backup_type backup_types[] = {
	simple, simple, numbered_existing,
	numbered_existing, numbered, numbered
};

/*
 * Return the type of backup indicated by VERSION. Unique abbreviations are
 * accepted.
 */
enum backup_type
get_version(const char *version)
{
	int	i;

	if (version == NULL || *version == '\0')
		return numbered_existing;
	i = argmatch(version, backup_args);
	if (i >= 0)
		return backup_types[i];
	invalid_arg("version control type", version, i);
	exit(2);
}
@


1.20
log
@rcsid[] and sccsid[] and copyright[] are essentially unmaintained (and
unmaintainable).  these days, people use source.  these id's do not provide
any benefit, and do hurt the small install media
(the 33,000 line diff is essentially mechanical)
ok with the idea millert, ok dms
@
text
@d1 1
a1 1
/*	$OpenBSD: backupfile.c,v 1.19 2006/03/11 19:41:30 otto Exp $	*/
d135 3
a137 2
	if (!strncmp(base, backup, base_length) && ISDIGIT(backup[base_length])) {
		for (p = &backup[base_length]; ISDIGIT(*p); ++p)
@


1.19
log
@type police and assorted cleanup. From Lionel Fourquaux; ok ray@@
@
text
@d1 1
a1 1
/*	$OpenBSD: backupfile.c,v 1.18 2004/08/05 21:47:24 deraadt Exp $	*/
a17 4

#ifndef lint
static const char rcsid[] = "$OpenBSD: backupfile.c,v 1.18 2004/08/05 21:47:24 deraadt Exp $";
#endif /* not lint */
@


1.18
log
@spacing
@
text
@d1 1
a1 1
/*	$OpenBSD: backupfile.c,v 1.17 2003/08/01 20:30:48 otto Exp $	*/
d20 1
a20 1
static const char rcsid[] = "$OpenBSD: backupfile.c,v 1.17 2003/08/01 20:30:48 otto Exp $";
d48 1
a48 1
static int	version_number(const char *, const char *, int);
d91 2
a92 1
	int	highest_version, this_version, file_name_length;
d133 1
a133 1
version_number(const char *base, const char *backup, int base_length)
@


1.17
log
@- use stdbool.h instead of roll-your-own booleans
- fix some -Wall warnings
- fix asserts: in some cases remove them, in other cases they have
become Internal errors or detection of malformed patch files.
- fix some free() related code

ok millert@@ tedu@@
@
text
@d1 1
a1 1
/*	$OpenBSD: backupfile.c,v 1.16 2003/07/28 18:35:36 otto Exp $	*/
d20 1
a20 1
static const char rcsid[] = "$OpenBSD: backupfile.c,v 1.16 2003/07/28 18:35:36 otto Exp $";
d43 1
a43 1
char           *simple_backup_suffix = "~";
d45 6
a50 6
static char    *concat(const char *, const char *);
static char    *make_version_name(const char *, int);
static int      max_backup_version(const char *, const char *);
static int      version_number(const char *, const char *, int);
static int      argmatch(const char *, const char **);
static void     invalid_arg(const char *, const char *, int);
@


1.16
log
@More cleanup: sprinkled some const, removed ugly EXTERN/INTERN.h,
some rewriting of code to make it more readable and more KNF.

ok millert@@ tedu@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: backupfile.c,v 1.15 2003/07/28 16:13:53 millert Exp $	*/
d20 1
a20 1
static const char rcsid[] = "$OpenBSD: backupfile.c,v 1.15 2003/07/28 16:13:53 millert Exp $";
d171 1
a171 1
	int	arglen;	/* Length of ARG. */
@


1.15
log
@Make patch(1) exit value match POSIX and be consistent with diff.
Comments and OK from otto@@
@
text
@d1 1
a1 1
/*	$OpenBSD: backupfile.c,v 1.14 2003/07/22 17:52:20 deraadt Exp $	*/
d20 1
a20 1
static const char rcsid[] = "$OpenBSD: backupfile.c,v 1.14 2003/07/22 17:52:20 deraadt Exp $";
d24 1
d29 1
a32 16
/*
 * DIRHEADER: This definition indicates which directory library header to
 * use.
 */
#define DIRENT

#ifdef DIRENT
#include <dirent.h>
#ifdef direct
#undef direct
#endif
#define direct dirent
#define NLENGTH(direct) (strlen((direct)->d_name))
#else				/* !DIRENT */
#define NLENGTH(direct) ((direct)->d_namlen)
#endif				/* !DIRENT */
a35 12
#include <unistd.h>

#if defined (_POSIX_VERSION)
/*
 * POSIX does not require that the d_ino field be present, and some systems
 * do not provide it.
 */
#define REAL_DIR_ENTRY(dp) 1
#else
#define REAL_DIR_ENTRY(dp) ((dp)->d_ino != 0)
#endif

d45 6
a50 6
static char    *concat(char *, char *);
static char    *make_version_name(char *, int);
static int      max_backup_version(char *, char *);
static int      version_number(char *, char *, int);
static int      argmatch(char *, char **);
static void     invalid_arg(char *, char *, int);
d58 1
a58 1
find_backup_file_name(char *file)
d66 1
a66 1
	if (base_versions == 0)
d69 1
a69 1
	if (dir == 0) {
d87 1
a87 1
max_backup_version(char *file, char *dir)
d90 1
a90 1
	struct direct	*dp;
d94 1
a94 1
	if (!dirp)
d100 2
a101 2
	while ((dp = readdir(dirp)) != 0) {
		if (!REAL_DIR_ENTRY(dp) || NLENGTH(dp) <= file_name_length)
d117 1
a117 1
make_version_name(char *file, int version)
d132 1
a132 1
version_number(char *base, char *backup, int base_length)
d134 2
a135 2
	int	version;
	char	*p;
d152 1
a152 1
concat(char *str1, char *str2)
d168 1
a168 1
argmatch(char *arg, char **optlist)
d203 1
a203 1
invalid_arg(char *kind, char *value, int problem)
d213 1
a213 1
static char *backup_args[] = {
d227 1
a227 1
get_version(char *version)
d231 1
a231 1
	if (version == 0 || *version == 0)
@


1.14
log
@just about nothing
@
text
@d1 1
a1 1
/*	$OpenBSD: backupfile.c,v 1.13 2003/07/22 17:18:49 otto Exp $	*/
d20 1
a20 1
static const char rcsid[] = "$OpenBSD: backupfile.c,v 1.13 2003/07/22 17:18:49 otto Exp $";
d263 1
a263 1
	exit(1);
@


1.13
log
@More cleanup.
ok millert@@ tedu@@
@
text
@d1 1
a1 1
/*	$OpenBSD: backupfile.c,v 1.12 2003/07/21 14:32:21 deraadt Exp $	*/
d20 2
a21 2
static const char     rcsid[] = "$OpenBSD: backupfile.c,v 1.12 2003/07/21 14:32:21 deraadt Exp $";
#endif				/* not lint */
@


1.12
log
@fix header
@
text
@d1 1
a1 1
/*	$OpenBSD: backupfile.c,v 1.11 2003/07/21 14:00:41 deraadt Exp $	*/
d20 1
a20 1
static char     rcsid[] = "$OpenBSD: backupfile.c,v 1.11 2003/07/21 14:00:41 deraadt Exp $";
d23 2
d28 1
a28 3
#include <ctype.h>
#include <libgen.h>
#include <sys/types.h>
d30 6
a35 1
#include "config.h"
a71 1
char           *find_backup_file_name(char *);
d93 1
a93 1
		return 0;
d97 1
a97 1
		return 0;
d148 1
a148 1
		return 0;
d183 1
a183 1
		return 0;
d193 1
a193 1
int
d228 1
a228 1
void
@


1.11
log
@knf and other cleanup; ok otto
@
text
@d1 1
a1 1
/* $OpenBSD: backupfile.c,v 1.10 2003/07/18 02:00:09 deraadt Exp $	 */
d20 1
a20 1
static char     rcsid[] = "$OpenBSD: backupfile.c,v 1.10 2003/07/18 02:00:09 deraadt Exp $";
@


1.10
log
@remove junk; ok otto tedu
@
text
@d1 1
a1 1
/*	$OpenBSD: backupfile.c,v 1.9 2003/04/06 04:14:09 millert Exp $	*/
d3 15
a17 12
/* backupfile.c -- make Emacs style backup file names
   Copyright (C) 1990 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it without restriction.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  */

/* David MacKenzie <djm@@ai.mit.edu>.
   Some algorithms adapted from GNU Emacs. */
d20 2
a21 2
static char rcsid[] = "$OpenBSD: backupfile.c,v 1.9 2003/04/06 04:14:09 millert Exp $";
#endif /* not lint */
d39 1
a39 1
#else /* !DIRENT */
d41 1
a41 12
#ifdef USG
#ifdef SYSNDIR
#include <sys/ndir.h>
#else /* !SYSNDIR */
#include <ndir.h>
#endif /* !SYSNDIR */
#else /* !USG */
#ifdef SYSDIR
#include <sys/dir.h>
#endif /* SYSDIR */
#endif /* !USG */
#endif /* !DIRENT */
a42 3
#ifndef isascii
#define ISDIGIT(c) (isdigit ((unsigned char) (c)))
#else
a43 1
#endif
d48 4
a51 2
/* POSIX does not require that the d_ino field be present, and some
   systems do not provide it. */
d60 19
a78 18
/* The extension added to file names to produce a simple (as opposed
   to numbered) backup file name. */
char *simple_backup_suffix = "~";

static char *concat(char *, char *);
char *find_backup_file_name(char *);
static char *make_version_name(char *, int);
static int max_backup_version(char *, char *);
static int version_number(char *, char *, int);
static int argmatch(char *, char **);
static void invalid_arg(char *, char *, int);

#ifndef NODIR
/* Return the name of the new backup file for file FILE,
   allocated with malloc.  Return 0 if out of memory.
   FILE must not end with a '/' unless it is the root directory.
   Do not call this function if backup_type == none. */

d80 1
a80 2
find_backup_file_name (file)
     char *file;
d82 18
a99 20
  char *dir;
  char *base_versions;
  int highest_backup;

  if (backup_type == simple)
    return concat (file, simple_backup_suffix);
  base_versions = concat (basename (file), ".~");
  if (base_versions == 0)
    return 0;
  dir = dirname (file);
  if (dir == 0)
    {
      free (base_versions);
      return 0;
    }
  highest_backup = max_backup_version (base_versions, dir);
  free (base_versions);
  if (backup_type == numbered_existing && highest_backup == 0)
    return concat (file, simple_backup_suffix);
  return make_version_name (file, highest_backup + 1);
d102 6
a107 5
/* Return the number of the highest-numbered backup file for file
   FILE in directory DIR.  If there are no numbered backups
   of FILE in DIR, or an error occurs reading DIR, return 0.
   FILE should already have ".~" appended to it. */

d109 1
a109 2
max_backup_version (file, dir)
     char *file, *dir;
d111 21
a131 24
  DIR *dirp;
  struct direct *dp;
  int highest_version;
  int this_version;
  int file_name_length;

  dirp = opendir (dir);
  if (!dirp)
    return 0;

  highest_version = 0;
  file_name_length = strlen (file);

  while ((dp = readdir (dirp)) != 0)
    {
      if (!REAL_DIR_ENTRY (dp) || NLENGTH (dp) <= file_name_length)
	continue;

      this_version = version_number (file, dp->d_name, file_name_length);
      if (this_version > highest_version)
	highest_version = this_version;
    }
  closedir (dirp);
  return highest_version;
d134 4
a137 3
/* Return a string, allocated with malloc, containing
   "FILE.~VERSION~".  Return 0 if out of memory. */

d139 1
a139 3
make_version_name (file, version)
     char *file;
     int version;
d141 1
a141 1
  char *backup_name;
d143 3
a145 3
  if (asprintf (&backup_name, "%s.~%d~", file, version) == -1)
    return 0;
  return backup_name;
d148 5
a152 4
/* If BACKUP is a numbered backup of BASE, return its version number;
   otherwise return 0.  BASE_LENGTH is the length of BASE.
   BASE should already have ".~" appended to it. */

d154 1
a154 4
version_number (base, backup, base_length)
     char *base;
     char *backup;
     int base_length;
d156 2
a157 2
  int version;
  char *p;
a158 6
  version = 0;
  if (!strncmp (base, backup, base_length) && ISDIGIT (backup[base_length]))
    {
      for (p = &backup[base_length]; ISDIGIT (*p); ++p)
	version = version * 10 + *p - '0';
      if (p[0] != '~' || p[1])
d160 7
a166 2
    }
  return version;
d169 6
a174 6
/* Return the newly-allocated concatenation of STR1 and STR2.
   If out of memory, return 0. */

static char *
concat (str1, str2)
     char *str1, *str2;
d176 1
a176 1
  char *newstr;
d178 3
a180 3
  if (asprintf(&newstr, "%s%s", str1, str2) == -1)
    return 0;
  return newstr;
d183 6
a188 5
/* If ARG is an unambiguous match for an element of the
   null-terminated array OPTLIST, return the index in OPTLIST
   of the matched element, else -1 if it does not match any element
   or -2 if it is ambiguous (is a prefix of more than one element). */

d190 1
a190 3
argmatch (arg, optlist)
     char *arg;
     char **optlist;
d192 20
a211 21
  int i;			/* Temporary index in OPTLIST. */
  int arglen;			/* Length of ARG. */
  int matchind = -1;		/* Index of first nonexact match. */
  int ambiguous = 0;		/* If nonzero, multiple nonexact match(es). */

  arglen = strlen (arg);

  /* Test all elements for either exact match or abbreviated matches.  */
  for (i = 0; optlist[i]; i++)
    {
      if (!strncmp (optlist[i], arg, arglen))
	{
	  if (strlen (optlist[i]) == arglen)
	    /* Exact match found.  */
	    return i;
	  else if (matchind == -1)
	    /* First nonexact match found.  */
	    matchind = i;
	  else
	    /* Second nonexact match found.  */
	    ambiguous = 1;
d213 4
a216 5
    }
  if (ambiguous)
    return -2;
  else
    return matchind;
d219 5
a223 5
/* Error reporting for argmatch.
   KIND is a description of the type of entity that was being matched.
   VALUE is the invalid value that was given.
   PROBLEM is the return value from argmatch. */

d225 1
a225 4
invalid_arg (kind, value, problem)
     char *kind;
     char *value;
     int problem;
d227 6
a232 6
  fprintf (stderr, "patch: ");
  if (problem == -1)
    fprintf (stderr, "invalid");
  else				/* Assume -2. */
    fprintf (stderr, "ambiguous");
  fprintf (stderr, " %s `%s'\n", kind, value);
d235 2
a236 3
static char *backup_args[] =
{
  "never", "simple", "nil", "existing", "t", "numbered", 0
d239 3
a241 3
static enum backup_type backup_types[] =
{
  simple, simple, numbered_existing, numbered_existing, numbered, numbered
d244 4
a247 3
/* Return the type of backup indicated by VERSION.
   Unique abbreviations are accepted. */

d249 1
a249 2
get_version (version)
     char *version;
d251 1
a251 1
  int i;
d253 7
a259 7
  if (version == 0 || *version == 0)
    return numbered_existing;
  i = argmatch (version, backup_args);
  if (i >= 0)
    return backup_types[i];
  invalid_arg ("version control type", version, i);
  exit (1);
a260 1
#endif /* NODIR */
@


1.9
log
@another asprintf() simplifies things further
@
text
@d1 1
a1 1
/*	$OpenBSD: backupfile.c,v 1.8 2003/04/05 17:17:53 deraadt Exp $	*/
d17 1
a17 1
static char rcsid[] = "$OpenBSD: backupfile.c,v 1.8 2003/04/05 17:17:53 deraadt Exp $";
a56 1
#if defined (HAVE_UNISTD_H)
a57 1
#endif
d74 7
a80 5
static char *concat ();
char *find_backup_file_name ();
static char *make_version_name ();
static int max_backup_version ();
static int version_number ();
d128 1
a128 1
  
d132 1
a132 1
  
d140 1
a140 1
      
d176 1
a176 1
  
d216 1
a216 1
  
d218 1
a218 1
  
@


1.8
log
@string fixes; ok miod henning
@
text
@d1 1
a1 1
/*	$OpenBSD: backupfile.c,v 1.7 1999/12/04 21:00:03 provos Exp $	*/
d17 1
a17 1
static char rcsid[] = "$OpenBSD: backupfile.c,v 1.7 1999/12/04 21:00:03 provos Exp $";
a157 1
  size_t len;
d159 1
a159 3
  len = strlen (file) + 16;
  backup_name = malloc (len);
  if (backup_name == 0)
a160 1
  snprintf (backup_name, len, "%s.~%d~", file, version);
@


1.7
log
@a few more overflows gone
@
text
@d1 1
a1 1
/*	$OpenBSD: backupfile.c,v 1.6 1999/01/03 05:33:48 millert Exp $	*/
d17 1
a17 1
static char rcsid[] = "$OpenBSD: backupfile.c,v 1.6 1999/01/03 05:33:48 millert Exp $";
d158 1
d160 2
a161 1
  backup_name = malloc (strlen (file) + 16);
d164 1
a164 1
  sprintf (backup_name, "%s.~%d~", file, version);
a199 1
  int str1_length = strlen (str1);
d201 1
a201 2
  newstr = malloc (str1_length + strlen (str2) + 1);
  if (newstr == 0)
a202 2
  strcpy (newstr, str1);
  strcpy (newstr + str1_length, str2);
@


1.6
log
@Use libc basename(3) and dirname(3) instead of defining our own.  Also clean up some nasty assumptions that basename() returns a pointer that lies within its argument
@
text
@d1 1
a1 1
/*	$OpenBSD: backupfile.c,v 1.4 1999/01/03 04:20:07 millert Exp $	*/
d17 1
a17 1
static char rcsid[] = "$OpenBSD: backupfile.c,v 1.4 1999/01/03 04:20:07 millert Exp $";
d198 1
a198 1
  char str1_length = strlen (str1);
@


1.5
log
@back out last change, other parts of patch rely on basename() returning a ptr to a part of name, not a new string
@
text
@d1 1
a1 1
/*	$OpenBSD: backupfile.c,v 1.3 1997/01/17 07:18:02 millert Exp $	*/
d17 1
a17 1
static char rcsid[] = "$OpenBSD: backupfile.c,v 1.3 1997/01/17 07:18:02 millert Exp $";
d24 1
a75 2
char *basename ();
char *dirname ();
a108 1
  free (dir);
a205 48
}

/* Return NAME with any leading path stripped off.  */

char *
basename (name)
     char *name;
{
  char *base;

  base = strrchr (name, '/');
  return base ? base + 1 : name;
}

/* Return the leading directories part of PATH,
   allocated with malloc.  If out of memory, return 0.
   Assumes that trailing slashes have already been
   removed.  */

char *
dirname (path)
     char *path;
{
  char *newpath;
  char *slash;
  int length;    /* Length of result, not including NUL. */

  slash = strrchr (path, '/');
  if (slash == 0)
	{
	  /* File is in the current directory.  */
	  path = ".";
	  length = 1;
	}
  else
	{
	  /* Remove any trailing slashes from result. */
	  while (slash > path && *slash == '/')
		--slash;

	  length = slash - path + 1;
	}
  newpath = malloc (length + 1);
  if (newpath == 0)
    return 0;
  strncpy (newpath, path, length);
  newpath[length] = 0;
  return newpath;
@


1.4
log
@we have basename(3) and dirname(3) in libc (albeit with slightly different semantics
@
text
@a23 1
#include <libgen.h>
d75 2
d110 1
d208 48
@


1.3
log
@more r?index -> strr?chr
@
text
@d1 1
a1 1
/*	$OpenBSD: backupfile.c,v 1.2 1996/06/10 11:21:25 niklas Exp $	*/
d17 1
a17 1
static char rcsid[] = "$OpenBSD: backupfile.c,v 1.2 1996/06/10 11:21:25 niklas Exp $";
d24 1
a75 2
char *basename ();
char *dirname ();
a108 1
  free (dir);
a205 48
}

/* Return NAME with any leading path stripped off.  */

char *
basename (name)
     char *name;
{
  char *base;

  base = strrchr (name, '/');
  return base ? base + 1 : name;
}

/* Return the leading directories part of PATH,
   allocated with malloc.  If out of memory, return 0.
   Assumes that trailing slashes have already been
   removed.  */

char *
dirname (path)
     char *path;
{
  char *newpath;
  char *slash;
  int length;    /* Length of result, not including NUL. */

  slash = strrchr (path, '/');
  if (slash == 0)
	{
	  /* File is in the current directory.  */
	  path = ".";
	  length = 1;
	}
  else
	{
	  /* Remove any trailing slashes from result. */
	  while (slash > path && *slash == '/')
		--slash;

	  length = slash - path + 1;
	}
  newpath = malloc (length + 1);
  if (newpath == 0)
    return 0;
  strncpy (newpath, path, length);
  newpath[length] = 0;
  return newpath;
@


1.2
log
@Support the long options that FSF's patch version has.  $OpenBSD$ added
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d17 1
a17 1
static char rcsid[] = "$OpenBSD: backupfile.c,v 1.1.1.1 1995/10/18 08:45:55 deraadt Exp $";
d218 1
a218 1
  base = rindex (name, '/');
d235 1
a235 1
  slash = rindex (path, '/');
@


1.1
log
@Initial revision
@
text
@d1 2
d17 1
a17 1
static char rcsid[] = "$Id: backupfile.c,v 1.3 1994/12/24 17:30:13 cgd Exp $";
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@
