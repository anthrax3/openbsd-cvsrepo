head	1.36;
access;
symbols
	OPENBSD_6_1_BASE:1.36
	OPENBSD_6_0:1.36.0.4
	OPENBSD_6_0_BASE:1.36
	OPENBSD_5_9:1.36.0.2
	OPENBSD_5_9_BASE:1.36
	OPENBSD_5_8:1.32.0.6
	OPENBSD_5_8_BASE:1.32
	OPENBSD_5_7:1.32.0.2
	OPENBSD_5_7_BASE:1.32
	OPENBSD_5_6:1.30.0.6
	OPENBSD_5_6_BASE:1.30
	OPENBSD_5_5:1.30.0.4
	OPENBSD_5_5_BASE:1.30
	OPENBSD_5_4:1.29.0.2
	OPENBSD_5_4_BASE:1.29
	OPENBSD_5_3:1.28.0.16
	OPENBSD_5_3_BASE:1.28
	OPENBSD_5_2:1.28.0.14
	OPENBSD_5_2_BASE:1.28
	OPENBSD_5_1_BASE:1.28
	OPENBSD_5_1:1.28.0.12
	OPENBSD_5_0:1.28.0.10
	OPENBSD_5_0_BASE:1.28
	OPENBSD_4_9:1.28.0.8
	OPENBSD_4_9_BASE:1.28
	OPENBSD_4_8:1.28.0.6
	OPENBSD_4_8_BASE:1.28
	OPENBSD_4_7:1.28.0.2
	OPENBSD_4_7_BASE:1.28
	OPENBSD_4_6:1.28.0.4
	OPENBSD_4_6_BASE:1.28
	OPENBSD_4_5:1.23.0.6
	OPENBSD_4_5_BASE:1.23
	OPENBSD_4_4:1.23.0.4
	OPENBSD_4_4_BASE:1.23
	OPENBSD_4_3:1.23.0.2
	OPENBSD_4_3_BASE:1.23
	OPENBSD_4_2:1.22.0.2
	OPENBSD_4_2_BASE:1.22
	OPENBSD_4_1:1.20.0.2
	OPENBSD_4_1_BASE:1.20
	OPENBSD_4_0:1.19.0.2
	OPENBSD_4_0_BASE:1.19
	OPENBSD_3_9:1.16.0.2
	OPENBSD_3_9_BASE:1.16;
locks; strict;
comment	@ * @;


1.36
date	2015.12.29.19.04.46;	author gsoares;	state Exp;
branches;
next	1.35;
commitid	k2UzU75zoPNqkN7K;

1.35
date	2015.10.18.04.18.41;	author deraadt;	state Exp;
branches;
next	1.34;
commitid	Vt7fJF5KAUTjdJsQ;

1.34
date	2015.10.15.23.06.46;	author deraadt;	state Exp;
branches;
next	1.33;
commitid	qQgExhGZXP9zhpD8;

1.33
date	2015.10.10.19.03.08;	author deraadt;	state Exp;
branches;
next	1.32;
commitid	F0H7pWVCZ1z4P0cP;

1.32
date	2015.02.05.12.59.58;	author millert;	state Exp;
branches;
next	1.31;
commitid	DTQbfd4poqBW8iSJ;

1.31
date	2015.01.16.06.40.11;	author deraadt;	state Exp;
branches;
next	1.30;
commitid	Uu5nFG3wCl0LACBb;

1.30
date	2013.11.26.21.08.12;	author deraadt;	state Exp;
branches;
next	1.29;

1.29
date	2013.04.01.16.08.00;	author tobias;	state Exp;
branches;
next	1.28;

1.28
date	2009.06.07.13.29.50;	author ray;	state Exp;
branches;
next	1.27;

1.27
date	2009.06.07.13.15.13;	author ray;	state Exp;
branches;
next	1.26;

1.26
date	2009.06.07.13.09.24;	author ray;	state Exp;
branches;
next	1.25;

1.25
date	2009.06.07.13.06.02;	author ray;	state Exp;
branches;
next	1.24;

1.24
date	2009.06.07.12.39.40;	author ray;	state Exp;
branches;
next	1.23;

1.23
date	2007.09.02.15.19.34;	author deraadt;	state Exp;
branches;
next	1.22;

1.22
date	2007.06.28.02.14.41;	author ray;	state Exp;
branches;
next	1.21;

1.21
date	2007.06.27.04.29.40;	author ray;	state Exp;
branches;
next	1.20;

1.20
date	2006.09.19.05.52.23;	author otto;	state Exp;
branches;
next	1.19;

1.19
date	2006.05.25.03.20.32;	author ray;	state Exp;
branches;
next	1.18;

1.18
date	2006.05.10.14.32.51;	author ray;	state Exp;
branches;
next	1.17;

1.17
date	2006.03.05.07.12.26;	author otto;	state Exp;
branches;
next	1.16;

1.16
date	2006.02.20.08.29.44;	author otto;	state Exp;
branches;
next	1.15;

1.15
date	2006.02.15.15.27.38;	author otto;	state Exp;
branches;
next	1.14;

1.14
date	2006.02.15.06.58.06;	author otto;	state Exp;
branches;
next	1.13;

1.13
date	2006.02.14.08.26.20;	author otto;	state Exp;
branches;
next	1.12;

1.12
date	2005.12.28.05.57.46;	author deraadt;	state Exp;
branches;
next	1.11;

1.11
date	2005.12.27.05.13.14;	author tedu;	state Exp;
branches;
next	1.10;

1.10
date	2005.12.27.05.04.27;	author deraadt;	state Exp;
branches;
next	1.9;

1.9
date	2005.12.27.04.46.32;	author tedu;	state Exp;
branches;
next	1.8;

1.8
date	2005.12.27.04.43.01;	author tedu;	state Exp;
branches;
next	1.7;

1.7
date	2005.12.27.04.35.22;	author tedu;	state Exp;
branches;
next	1.6;

1.6
date	2005.12.27.04.33.31;	author tedu;	state Exp;
branches;
next	1.5;

1.5
date	2005.12.27.04.31.06;	author tedu;	state Exp;
branches;
next	1.4;

1.4
date	2005.12.27.04.28.08;	author tedu;	state Exp;
branches;
next	1.3;

1.3
date	2005.12.27.04.18.07;	author tedu;	state Exp;
branches;
next	1.2;

1.2
date	2005.12.27.04.06.16;	author tedu;	state Exp;
branches;
next	1.1;

1.1
date	2005.12.27.04.04.56;	author tedu;	state Exp;
branches;
next	;


desc
@@


1.36
log
@fix exit status on pledge(2) failure.

OK tb@@ jsg@@
@
text
@/*	$OpenBSD: sdiff.c,v 1.35 2015/10/18 04:18:41 deraadt Exp $ */

/*
 * Written by Raymond Lai <ray@@cyth.net>.
 * Public domain.
 */

#include <sys/queue.h>
#include <sys/stat.h>
#include <sys/types.h>
#include <sys/wait.h>

#include <ctype.h>
#include <err.h>
#include <errno.h>
#include <fcntl.h>
#include <getopt.h>
#include <limits.h>
#include <paths.h>
#include <stdint.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <util.h>

#include "common.h"
#include "extern.h"

#define WIDTH 130
/*
 * Each column must be at least one character wide, plus three
 * characters between the columns (space, [<|>], space).
 */
#define WIDTH_MIN 5

/* A single diff line. */
struct diffline {
	SIMPLEQ_ENTRY(diffline) diffentries;
	char	*left;
	char	 div;
	char	*right;
};

static void astrcat(char **, const char *);
static void enqueue(char *, char, char *);
static char *mktmpcpy(const char *);
static void freediff(struct diffline *);
static void int_usage(void);
static int parsecmd(FILE *, FILE *, FILE *);
static void printa(FILE *, size_t);
static void printc(FILE *, size_t, FILE *, size_t);
static void printcol(const char *, size_t *, const size_t);
static void printd(FILE *, size_t);
static void println(const char *, const char, const char *);
static void processq(void);
static void prompt(const char *, const char *);
__dead static void usage(void);
static char *xfgets(FILE *);

SIMPLEQ_HEAD(, diffline) diffhead = SIMPLEQ_HEAD_INITIALIZER(diffhead);
size_t	 line_width;	/* width of a line (two columns and divider) */
size_t	 width;		/* width of each column */
size_t	 file1ln, file2ln;	/* line number of file1 and file2 */
int	 Iflag = 0;	/* ignore sets matching regexp */
int	 lflag;		/* print only left column for identical lines */
int	 sflag;		/* skip identical lines */
FILE	*outfp;		/* file to save changes to */
const char *tmpdir;	/* TMPDIR or /tmp */

static struct option longopts[] = {
	{ "text",			no_argument,		NULL,	'a' },
	{ "ignore-blank-lines",		no_argument,		NULL,	'B' },
	{ "ignore-space-change",	no_argument,		NULL,	'b' },
	{ "minimal",			no_argument,		NULL,	'd' },
	{ "ignore-tab-expansion",	no_argument,		NULL,	'E' },
	{ "diff-program",		required_argument,	NULL,	'F' },
	{ "speed-large-files",		no_argument,		NULL,	'H' },
	{ "ignore-matching-lines",	required_argument,	NULL,	'I' },
	{ "ignore-case",		no_argument,		NULL,	'i' },
	{ "left-column",		no_argument,		NULL,	'l' },
	{ "output",			required_argument,	NULL,	'o' },
	{ "strip-trailing-cr",		no_argument,		NULL,	'S' },
	{ "suppress-common-lines",	no_argument,		NULL,	's' },
	{ "expand-tabs",		no_argument,		NULL,	't' },
	{ "ignore-all-space",		no_argument,		NULL,	'W' },
	{ "width",			required_argument,	NULL,	'w' },
	{ NULL,				0,			NULL,	 0  }
};

/*
 * Create temporary file if source_file is not a regular file.
 * Returns temporary file name if one was malloced, NULL if unnecessary.
 */
static char *
mktmpcpy(const char *source_file)
{
	struct stat sb;
	ssize_t rcount;
	int ifd, ofd;
	u_char buf[BUFSIZ];
	char *target_file;

	/* Open input and output. */
	ifd = open(source_file, O_RDONLY, 0);
	/* File was opened successfully. */
	if (ifd != -1) {
		if (fstat(ifd, &sb) == -1)
			err(2, "error getting file status from %s", source_file);

		/* Regular file. */
		if (S_ISREG(sb.st_mode)) {
			close(ifd);
			return (NULL);
		}
	} else {
		/* If ``-'' does not exist the user meant stdin. */
		if (errno == ENOENT && strcmp(source_file, "-") == 0)
			ifd = STDIN_FILENO;
		else
			err(2, "error opening %s", source_file);
	}

	/* Not a regular file, so copy input into temporary file. */
	if (asprintf(&target_file, "%s/sdiff.XXXXXXXXXX", tmpdir) == -1)
		err(2, "asprintf");
	if ((ofd = mkstemp(target_file)) == -1) {
		warn("error opening %s", target_file);
		goto FAIL;
	}
	while ((rcount = read(ifd, buf, sizeof(buf))) != -1 &&
	    rcount != 0) {
		ssize_t wcount;

		wcount = write(ofd, buf, (size_t)rcount);
		if (-1 == wcount || rcount != wcount) {
			warn("error writing to %s", target_file);
			goto FAIL;
		}
	}
	if (rcount == -1) {
		warn("error reading from %s", source_file);
		goto FAIL;
	}

	close(ifd);
	close(ofd);

	return (target_file);

FAIL:
	unlink(target_file);
	exit(2);
}

int
main(int argc, char **argv)
{
	FILE *diffpipe, *file1, *file2;
	size_t diffargc = 0, wflag = WIDTH;
	int ch, fd[2], status;
	pid_t pid;
	const char *outfile = NULL;
	char **diffargv, *diffprog = "diff", *filename1, *filename2,
	    *tmp1, *tmp2, *s1, *s2;

	if (pledge("stdio rpath wpath cpath proc exec", NULL) == -1)
		err(2, "pledge");

	/*
	 * Process diff flags.
	 */
	/*
	 * Allocate memory for diff arguments and NULL.
	 * Each flag has at most one argument, so doubling argc gives an
	 * upper limit of how many diff args can be passed.  argv[0],
	 * file1, and file2 won't have arguments so doubling them will
	 * waste some memory; however we need an extra space for the
	 * NULL at the end, so it sort of works out.
	 */
	if (!(diffargv = calloc(argc, sizeof(char **) * 2)))
		err(2, "main");

	/* Add first argument, the program name. */
	diffargv[diffargc++] = diffprog;

	while ((ch = getopt_long(argc, argv, "aBbdEHI:ilo:stWw:",
	    longopts, NULL)) != -1) {
		const char *errstr;

		switch (ch) {
		case 'a':
			diffargv[diffargc++] = "-a";
			break;
		case 'B':
			diffargv[diffargc++] = "-B";
			break;
		case 'b':
			diffargv[diffargc++] = "-b";
			break;
		case 'd':
			diffargv[diffargc++] = "-d";
			break;
		case 'E':
			diffargv[diffargc++] = "-E";
			break;
		case 'F':
			diffargv[0] = diffprog = optarg;
			break;
		case 'H':
			diffargv[diffargc++] = "-H";
			break;
		case 'I':
			Iflag = 1;
			diffargv[diffargc++] = "-I";
			diffargv[diffargc++] = optarg;
			break;
		case 'i':
			diffargv[diffargc++] = "-i";
			break;
		case 'l':
			lflag = 1;
			break;
		case 'o':
			outfile = optarg;
			break;
		case 'S':
			diffargv[diffargc++] = "--strip-trailing-cr";
			break;
		case 's':
			sflag = 1;
			break;
		case 't':
			diffargv[diffargc++] = "-t";
			break;
		case 'W':
			diffargv[diffargc++] = "-w";
			break;
		case 'w':
			wflag = strtonum(optarg, WIDTH_MIN,
			    INT_MAX, &errstr);
			if (errstr)
				errx(2, "width is %s: %s", errstr, optarg);
			break;
		default:
			usage();
		}

	}
	argc -= optind;
	argv += optind;

	if (argc != 2)
		usage();

	if (outfile && (outfp = fopen(outfile, "w")) == NULL)
		err(2, "could not open: %s", optarg);

	if ((tmpdir = getenv("TMPDIR")) == NULL || *tmpdir == '\0')                       
		tmpdir = _PATH_TMP;

	filename1 = argv[0];
	filename2 = argv[1];

	/*
	 * Create temporary files for diff and sdiff to share if file1
	 * or file2 are not regular files.  This allows sdiff and diff
	 * to read the same inputs if one or both inputs are stdin.
	 *
	 * If any temporary files were created, their names would be
	 * saved in tmp1 or tmp2.  tmp1 should never equal tmp2.
	 */
	tmp1 = tmp2 = NULL;
	/* file1 and file2 are the same, so copy to same temp file. */
	if (strcmp(filename1, filename2) == 0) {
		if ((tmp1 = mktmpcpy(filename1)))
			filename1 = filename2 = tmp1;
	/* Copy file1 and file2 into separate temp files. */
	} else {
		if ((tmp1 = mktmpcpy(filename1)))
			filename1 = tmp1;
		if ((tmp2 = mktmpcpy(filename2)))
			filename2 = tmp2;
	}

	diffargv[diffargc++] = filename1;
	diffargv[diffargc++] = filename2;
	/* Add NULL to end of array to indicate end of array. */
	diffargv[diffargc++] = NULL;

	/* Subtract column divider and divide by two. */
	width = (wflag - 3) / 2;
	/* Make sure line_width can fit in size_t. */
	if (width > (SIZE_MAX - 3) / 2)
		errx(2, "width is too large: %zu", width);
	line_width = width * 2 + 3;

	if (pipe(fd))
		err(2, "pipe");

	switch(pid = fork()) {
	case 0:
		/* child */
		/* We don't read from the pipe. */
		close(fd[0]);
		if (dup2(fd[1], STDOUT_FILENO) == -1)
			err(2, "child could not duplicate descriptor");
		/* Free unused descriptor. */
		close(fd[1]);

		execvp(diffprog, diffargv);
		err(2, "could not execute diff: %s", diffprog);
	case -1:
		err(2, "could not fork");
	}

	/* parent */
	/* We don't write to the pipe. */
	close(fd[1]);

	/* Open pipe to diff command. */
	if ((diffpipe = fdopen(fd[0], "r")) == NULL)
		err(2, "could not open diff pipe");
	if ((file1 = fopen(filename1, "r")) == NULL)
		err(2, "could not open %s", filename1);
	if ((file2 = fopen(filename2, "r")) == NULL)
		err(2, "could not open %s", filename2);

	/* Line numbers start at one. */
	file1ln = file2ln = 1;

	/* Read and parse diff output. */
	while (parsecmd(diffpipe, file1, file2) != EOF)
		;
	fclose(diffpipe);

	/* Wait for diff to exit. */
	if (waitpid(pid, &status, 0) == -1 || !WIFEXITED(status) ||
	    WEXITSTATUS(status) >= 2)
		err(2, "diff exited abnormally");

	/* Delete and free unneeded temporary files. */
	if (tmp1)
		if (unlink(tmp1))
			warn("error deleting %s", tmp1);
	if (tmp2)
		if (unlink(tmp2))
			warn("error deleting %s", tmp2);
	free(tmp1);
	free(tmp2);
	filename1 = filename2 = tmp1 = tmp2 = NULL;

	/* No more diffs, so print common lines. */
	if (lflag)
		while ((s1 = xfgets(file1)))
			enqueue(s1, ' ', NULL);
	else
		for (;;) {
			s1 = xfgets(file1);
			s2 = xfgets(file2);
			if (s1 || s2)
				enqueue(s1, ' ', s2);
			else
				break;
		}
	fclose(file1);
	fclose(file2);
	/* Process unmodified lines. */
	processq();

	/* Return diff exit status. */
	return (WEXITSTATUS(status));
}

/*
 * Prints an individual column (left or right), taking into account
 * that tabs are variable-width.  Takes a string, the current column
 * the cursor is on the screen, and the maximum value of the column.
 * The column value is updated as we go along.
 */
static void
printcol(const char *s, size_t *col, const size_t col_max)
{
	for (; *s && *col < col_max; ++s) {
		size_t new_col;

		switch (*s) {
		case '\t':
			/*
			 * If rounding to next multiple of eight causes
			 * an integer overflow, just return.
			 */
			if (*col > SIZE_MAX - 8)
				return;

			/* Round to next multiple of eight. */
			new_col = (*col / 8 + 1) * 8;

			/*
			 * If printing the tab goes past the column
			 * width, don't print it and just quit.
			 */
			if (new_col > col_max)
				return;
			*col = new_col;
			break;

		default:
			++(*col);
		}

		putchar(*s);
	}
}

/*
 * Prompts user to either choose between two strings or edit one, both,
 * or neither.
 */
static void
prompt(const char *s1, const char *s2)
{
	char *cmd;

	/* Print command prompt. */
	putchar('%');

	/* Get user input. */
	for (; (cmd = xfgets(stdin)); free(cmd)) {
		const char *p;

		/* Skip leading whitespace. */
		for (p = cmd; isspace((unsigned char)*p); ++p)
			;

		switch (*p) {
		case 'e':
			/* Skip `e'. */
			++p;

			if (eparse(p, s1, s2) == -1)
				goto USAGE;
			break;

		case 'l':
		case '1':
			/* Choose left column as-is. */
			if (s1 != NULL)
				fprintf(outfp, "%s\n", s1);

			/* End of command parsing. */
			break;

		case 'q':
			goto QUIT;

		case 'r':
		case '2':
			/* Choose right column as-is. */
			if (s2 != NULL)
				fprintf(outfp, "%s\n", s2);

			/* End of command parsing. */
			break;

		case 's':
			sflag = 1;
			goto PROMPT;

		case 'v':
			sflag = 0;
			/* FALLTHROUGH */

		default:
			/* Interactive usage help. */
USAGE:
			int_usage();
PROMPT:
			putchar('%');

			/* Prompt user again. */
			continue;
		}

		free(cmd);
		return;
	}

	/*
	 * If there was no error, we received an EOF from stdin, so we
	 * should quit.
	 */
QUIT:
	fclose(outfp);
	exit(0);
}

/*
 * Takes two strings, separated by a column divider.  NULL strings are
 * treated as empty columns.  If the divider is the ` ' character, the
 * second column is not printed (-l flag).  In this case, the second
 * string must be NULL.  When the second column is NULL, the divider
 * does not print the trailing space following the divider character.
 *
 * Takes into account that tabs can take multiple columns.
 */
static void
println(const char *s1, const char div, const char *s2)
{
	size_t col;

	/* Print first column.  Skips if s1 == NULL. */
	col = 0;
	if (s1) {
		/* Skip angle bracket and space. */
		printcol(s1, &col, width);

	}

	/* Only print left column. */
	if (div == ' ' && !s2) {
		putchar('\n');
		return;
	}

	/* Otherwise, we pad this column up to width. */
	for (; col < width; ++col)
		putchar(' ');

	/*
	 * Print column divider.  If there is no second column, we don't
	 * need to add the space for padding.
	 */
	if (!s2) {
		printf(" %c\n", div);
		return;
	}
	printf(" %c ", div);
	col += 3;

	/* Skip angle bracket and space. */
	printcol(s2, &col, line_width);

	putchar('\n');
}

/*
 * Reads a line from file and returns as a string.  If EOF is reached,
 * NULL is returned.  The returned string must be freed afterwards.
 */
static char *
xfgets(FILE *file)
{
	const char delim[3] = {'\0', '\0', '\0'};
	char *s;

	/* XXX - Is this necessary? */
	clearerr(file);

	if (!(s = fparseln(file, NULL, NULL, delim, 0)) &&
	    ferror(file))
		err(2, "error reading file");

	if (!s) {
		return (NULL);
	}

	return (s);
}

/*
 * Parse ed commands from diffpipe and print lines from file1 (lines
 * to change or delete) or file2 (lines to add or change).
 * Returns EOF or 0.
 */
static int
parsecmd(FILE *diffpipe, FILE *file1, FILE *file2)
{
	size_t file1start, file1end, file2start, file2end, n;
	/* ed command line and pointer to characters in line */
	char *line, *p, *q;
	const char *errstr;
	char c, cmd;

	/* Read ed command. */
	if (!(line = xfgets(diffpipe)))
		return (EOF);

	p = line;
	/* Go to character after line number. */
	while (isdigit((unsigned char)*p))
		++p;
	c = *p;
	*p++ = 0;
	file1start = strtonum(line, 0, INT_MAX, &errstr);
	if (errstr)
		errx(2, "file1 start is %s: %s", errstr, line);

	/* A range is specified for file1. */
	if (c == ',') {

		q = p;
		/* Go to character after file2end. */
		while (isdigit((unsigned char)*p))
			++p;
		c = *p;
		*p++ = 0;
		file1end = strtonum(q, 0, INT_MAX, &errstr);
		if (errstr)
			errx(2, "file1 end is %s: %s", errstr, line);
		if (file1start > file1end)
			errx(2, "invalid line range in file1: %s", line);

	} else
		file1end = file1start;

	cmd = c;
	/* Check that cmd is valid. */
	if (!(cmd == 'a' || cmd == 'c' || cmd == 'd'))
		errx(2, "ed command not recognized: %c: %s", cmd, line);

	q = p;
	/* Go to character after line number. */
	while (isdigit((unsigned char)*p))
		++p;
	c = *p;
	*p++ = 0;
	file2start = strtonum(q, 0, INT_MAX, &errstr);
	if (errstr)
		errx(2, "file2 start is %s: %s", errstr, line);

	/*
	 * There should either be a comma signifying a second line
	 * number or the line should just end here.
	 */
	if (c != ',' && c != '\0')
		errx(2, "invalid line range in file2: %c: %s", c, line);

	if (c == ',') {

		file2end = strtonum(p, 0, INT_MAX, &errstr);
		if (errstr)
			errx(2, "file2 end is %s: %s", errstr, line);
		if (file2start >= file2end)
			errx(2, "invalid line range in file2: %s", line);
	} else
		file2end = file2start;

	/* Appends happen _after_ stated line. */
	if (cmd == 'a') {
		if (file1start != file1end)
			errx(2, "append cannot have a file1 range: %s",
			    line);
		if (file1start == SIZE_MAX)
			errx(2, "file1 line range too high: %s", line);
		file1start = ++file1end;
	}
	/*
	 * I'm not sure what the deal is with the line numbers for
	 * deletes, though.
	 */
	else if (cmd == 'd') {
		if (file2start != file2end)
			errx(2, "delete cannot have a file2 range: %s",
			    line);
		if (file2start == SIZE_MAX)
			errx(2, "file2 line range too high: %s", line);
		file2start = ++file2end;
	}

	/*
	 * Continue reading file1 and file2 until we reach line numbers
	 * specified by diff.  Should only happen with -I flag.
	 */
	for (; file1ln < file1start && file2ln < file2start;
	    ++file1ln, ++file2ln) {
		char *s1, *s2;

		if (!(s1 = xfgets(file1)))
			errx(2, "file1 shorter than expected");
		if (!(s2 = xfgets(file2)))
			errx(2, "file2 shorter than expected");

		/* If the -l flag was specified, print only left column. */
		if (lflag) {
			free(s2);
			/*
			 * XXX - If -l and -I are both specified, all
			 * unchanged or ignored lines are shown with a
			 * `(' divider.  This matches GNU sdiff, but I
			 * believe it is a bug.  Just check out:
			 * gsdiff -l -I '^$' samefile samefile.
			 */
			if (Iflag)
				enqueue(s1, '(', NULL);
			else
				enqueue(s1, ' ', NULL);
		} else
			enqueue(s1, ' ', s2);
	}
	/* Ignore deleted lines. */
	for (; file1ln < file1start; ++file1ln) {
		char *s;

		if (!(s = xfgets(file1)))
			errx(2, "file1 shorter than expected");

		enqueue(s, '(', NULL);
	}
	/* Ignore added lines. */
	for (; file2ln < file2start; ++file2ln) {
		char *s;

		if (!(s = xfgets(file2)))
			errx(2, "file2 shorter than expected");

		/* If -l flag was given, don't print right column. */
		if (lflag)
			free(s);
		else
			enqueue(NULL, ')', s);
	}

	/* Process unmodified or skipped lines. */
	processq();

	switch (cmd) {
	case 'a':
		printa(file2, file2end);
		n = file2end - file2start + 1;
		break;

	case 'c':
		printc(file1, file1end, file2, file2end);
		n = file1end - file1start + 1 + 1 + file2end - file2start + 1;
		break;

	case 'd':
		printd(file1, file1end);
		n = file1end - file1start + 1;
		break;

	default:
		errx(2, "invalid diff command: %c: %s", cmd, line);
	}
	free(line);

	/* Skip to next ed line. */
	while (n--) {
		if (!(line = xfgets(diffpipe)))
			errx(2, "diff ended early");
		free(line);
	}

	return (0);
}

/*
 * Queues up a diff line.
 */
static void
enqueue(char *left, char div, char *right)
{
	struct diffline *diffp;

	if (!(diffp = malloc(sizeof(struct diffline))))
		err(2, "enqueue");
	diffp->left = left;
	diffp->div = div;
	diffp->right = right;
	SIMPLEQ_INSERT_TAIL(&diffhead, diffp, diffentries);
}

/*
 * Free a diffline structure and its elements.
 */
static void
freediff(struct diffline *diffp)
{
	free(diffp->left);
	free(diffp->right);
	free(diffp);
}

/*
 * Append second string into first.  Repeated appends to the same string
 * are cached, making this an O(n) function, where n = strlen(append).
 */
static void
astrcat(char **s, const char *append)
{
	/* Length of string in previous run. */
	static size_t offset = 0;
	size_t newsiz;
	/*
	 * String from previous run.  Compared to *s to see if we are
	 * dealing with the same string.  If so, we can use offset.
	 */
	static const char *oldstr = NULL;
	char *newstr;


	/*
	 * First string is NULL, so just copy append.
	 */
	if (!*s) {
		if (!(*s = strdup(append)))
			err(2, "astrcat");

		/* Keep track of string. */
		offset = strlen(*s);
		oldstr = *s;

		return;
	}

	/*
	 * *s is a string so concatenate.
	 */

	/* Did we process the same string in the last run? */
	/*
	 * If this is a different string from the one we just processed
	 * cache new string.
	 */
	if (oldstr != *s) {
		offset = strlen(*s);
		oldstr = *s;
	}

	/* Size = strlen(*s) + \n + strlen(append) + '\0'. */
	newsiz = offset + 1 + strlen(append) + 1;

	/* Resize *s to fit new string. */
	newstr = realloc(*s, newsiz);
	if (newstr == NULL)
		err(2, "astrcat");
	*s = newstr;

	/* *s + offset should be end of string. */
	/* Concatenate. */
	strlcpy(*s + offset, "\n", newsiz - offset);
	strlcat(*s + offset, append, newsiz - offset);

	/* New string length should be exactly newsiz - 1 characters. */
	/* Store generated string's values. */
	offset = newsiz - 1;
	oldstr = *s;
}

/*
 * Process diff set queue, printing, prompting, and saving each diff
 * line stored in queue.
 */
static void
processq(void)
{
	struct diffline *diffp;
	char divc, *left, *right;

	/* Don't process empty queue. */
	if (SIMPLEQ_EMPTY(&diffhead))
		return;

	/* Remember the divider. */
	divc = SIMPLEQ_FIRST(&diffhead)->div;

	left = NULL;
	right = NULL;
	/*
	 * Go through set of diffs, concatenating each line in left or
	 * right column into two long strings, `left' and `right'.
	 */
	SIMPLEQ_FOREACH(diffp, &diffhead, diffentries) {
		/*
		 * Print changed lines if -s was given,
		 * print all lines if -s was not given.
		 */
		if (!sflag || diffp->div == '|' || diffp->div == '<' ||
		    diffp->div == '>')
			println(diffp->left, diffp->div, diffp->right);

		/* Append new lines to diff set. */
		if (diffp->left)
			astrcat(&left, diffp->left);
		if (diffp->right)
			astrcat(&right, diffp->right);
	}

	/* Empty queue and free each diff line and its elements. */
	while (!SIMPLEQ_EMPTY(&diffhead)) {
		diffp = SIMPLEQ_FIRST(&diffhead);
		SIMPLEQ_REMOVE_HEAD(&diffhead, diffentries);
		freediff(diffp);
	}

	/* Write to outfp, prompting user if lines are different. */
	if (outfp)
		switch (divc) {
		case ' ': case '(': case ')':
			fprintf(outfp, "%s\n", left);
			break;
		case '|': case '<': case '>':
			prompt(left, right);
			break;
		default:
			errx(2, "invalid divider: %c", divc);
		}

	/* Free left and right. */
	free(left);
	free(right);
}

/*
 * Print lines following an (a)ppend command.
 */
static void
printa(FILE *file, size_t line2)
{
	char *line;

	for (; file2ln <= line2; ++file2ln) {
		if (!(line = xfgets(file)))
			errx(2, "append ended early");
		enqueue(NULL, '>', line);
	}

	processq();
}

/*
 * Print lines following a (c)hange command, from file1ln to file1end
 * and from file2ln to file2end.
 */
static void
printc(FILE *file1, size_t file1end, FILE *file2, size_t file2end)
{
	struct fileline {
		SIMPLEQ_ENTRY(fileline)	 fileentries;
		char			*line;
	};
	SIMPLEQ_HEAD(, fileline) delqhead = SIMPLEQ_HEAD_INITIALIZER(delqhead);

	/* Read lines to be deleted. */
	for (; file1ln <= file1end; ++file1ln) {
		struct fileline *linep;
		char *line1;

		/* Read lines from both. */
		if (!(line1 = xfgets(file1)))
			errx(2, "error reading file1 in delete in change");

		/* Add to delete queue. */
		if (!(linep = malloc(sizeof(struct fileline))))
			err(2, "printc");
		linep->line = line1;
		SIMPLEQ_INSERT_TAIL(&delqhead, linep, fileentries);
	}

	/* Process changed lines.. */
	for (; !SIMPLEQ_EMPTY(&delqhead) && file2ln <= file2end;
	    ++file2ln) {
		struct fileline *del;
		char *add;

		/* Get add line. */
		if (!(add = xfgets(file2)))
			errx(2, "error reading add in change");

		del = SIMPLEQ_FIRST(&delqhead);
		enqueue(del->line, '|', add);
		SIMPLEQ_REMOVE_HEAD(&delqhead, fileentries);
		/*
		 * Free fileline structure but not its elements since
		 * they are queued up.
		 */
		free(del);
	}
	processq();

	/* Process remaining lines to add. */
	for (; file2ln <= file2end; ++file2ln) {
		char *add;

		/* Get add line. */
		if (!(add = xfgets(file2)))
			errx(2, "error reading add in change");

		enqueue(NULL, '>', add);
	}
	processq();

	/* Process remaining lines to delete. */
	while (!SIMPLEQ_EMPTY(&delqhead)) {
		struct fileline *filep;

		filep = SIMPLEQ_FIRST(&delqhead);
		enqueue(filep->line, '<', NULL);
		SIMPLEQ_REMOVE_HEAD(&delqhead, fileentries);
		free(filep);
	}
	processq();
}

/*
 * Print deleted lines from file, from file1ln to file1end.
 */
static void
printd(FILE *file1, size_t file1end)
{
	char *line1;

	/* Print out lines file1ln to line2. */
	for (; file1ln <= file1end; ++file1ln) {
		if (!(line1 = xfgets(file1)))
			errx(2, "file1 ended early in delete");
		enqueue(line1, '<', NULL);
	}
	processq();
}

/*
 * Interactive mode usage.
 */
static void
int_usage(void)
{
	puts("e:\tedit blank diff\n"
	    "eb:\tedit both diffs concatenated\n"
	    "el:\tedit left diff\n"
	    "er:\tedit right diff\n"
	    "l | 1:\tchoose left diff\n"
	    "r | 2:\tchoose right diff\n"
	    "s:\tsilent mode--don't print identical lines\n"
	    "v:\tverbose mode--print identical lines\n"
	    "q:\tquit");
}

static void
usage(void)
{
	extern char *__progname;

	fprintf(stderr,
	    "usage: %s [-abdilstW] [-I regexp] [-o outfile] [-w width] file1 file2\n",
	    __progname);
	exit(2);
}
@


1.35
log
@sorry, sdiff -o interactive mode does another spawn
@
text
@d1 1
a1 1
/*	$OpenBSD: sdiff.c,v 1.34 2015/10/15 23:06:46 deraadt Exp $ */
d168 1
a168 1
		err(1, "pledge");
@


1.34
log
@After spawning, the parent can pledge "stdio rpath wpath cpath"
from rob pierce
@
text
@d1 1
a1 1
/*	$OpenBSD: sdiff.c,v 1.33 2015/10/10 19:03:08 deraadt Exp $ */
a315 3

	if (pledge("stdio rpath wpath cpath", NULL) == -1)
		err(1, "pledge");
@


1.33
log
@pledge "stdio rpath wpath cpath proc exec". there is some potential
for dropping some path attributes in between, but i will let someone
else do that.
ok doug
@
text
@d1 1
a1 1
/*	$OpenBSD: sdiff.c,v 1.32 2015/02/05 12:59:58 millert Exp $ */
d316 3
@


1.32
log
@Include stdint.h, not limits.h to get SIZE_MAX.  OK guenther@@
@
text
@d1 1
a1 1
/*	$OpenBSD: sdiff.c,v 1.31 2015/01/16 06:40:11 deraadt Exp $ */
d166 3
@


1.31
log
@Replace <sys/param.h> with <limits.h> and other less dirty headers where
possible.  Annotate <sys/param.h> lines with their current reasons.  Switch
to PATH_MAX, NGROUPS_MAX, HOST_NAME_MAX+1, LOGIN_NAME_MAX, etc.  Change
MIN() and MAX() to local definitions of MINIMUM() and MAXIMUM() where
sensible to avoid pulling in the pollution.  These are the files confirmed
through binary verification.
ok guenther, millert, doug (helped with the verification protocol)
@
text
@d1 1
a1 1
/*	$OpenBSD: sdiff.c,v 1.30 2013/11/26 21:08:12 deraadt Exp $ */
d20 1
@


1.30
log
@unsigned char casts for ctype
ok okan
@
text
@d1 1
a1 1
/*	$OpenBSD: sdiff.c,v 1.29 2013/04/01 16:08:00 tobias Exp $ */
a7 1
#include <sys/param.h>
@


1.29
log
@Avoid memory leak while parsing diff's output.

ok lteo
@
text
@d1 1
a1 1
/*	$OpenBSD: sdiff.c,v 1.28 2009/06/07 13:29:50 ray Exp $ */
d430 1
a430 1
		for (p = cmd; isspace(*p); ++p)
d588 1
a588 1
	while (isdigit(*p))
d601 1
a601 1
		while (isdigit(*p))
d621 1
a621 1
	while (isdigit(*p))
@


1.28
log
@Don't leak FILE * if multiple -o flags are given.
@
text
@d1 1
a1 1
/*	$OpenBSD: sdiff.c,v 1.27 2009/06/07 13:15:13 ray Exp $ */
d743 1
d746 2
a747 2
	while (n--)
		if (!xfgets(diffpipe))
d749 2
@


1.27
log
@Use SIZE_MAX, not SIZE_T_MAX.
@
text
@d1 1
a1 1
/*	$OpenBSD: sdiff.c,v 1.26 2009/06/07 13:09:24 ray Exp $ */
d68 1
a68 1
FILE	*outfile;	/* file to save changes to */
d163 1
d222 1
a222 2
			if ((outfile = fopen(optarg, "w")) == NULL)
				err(2, "could not open: %s", optarg);
d253 3
a380 1

d446 1
a446 1
				fprintf(outfile, "%s\n", s1);
d458 1
a458 1
				fprintf(outfile, "%s\n", s2);
d491 1
a491 1
	fclose(outfile);
d891 2
a892 2
	/* Write to outfile, prompting user if lines are different. */
	if (outfile)
d895 1
a895 1
			fprintf(outfile, "%s\n", left);
@


1.26
log
@Don't use $TMPDIR if it is empty.
@
text
@d1 1
a1 1
/*	$OpenBSD: sdiff.c,v 1.25 2009/06/07 13:06:02 ray Exp $ */
d288 1
a288 1
	if (width > (SIZE_T_MAX - 3) / 2)
d388 1
a388 1
			if (*col > SIZE_T_MAX - 8)
d649 1
a649 1
		if (file1start == SIZE_T_MAX)
d661 1
a661 1
		if (file2start == SIZE_T_MAX)
@


1.25
log
@Plug file descriptor leak when diffing regular files.
@
text
@d1 1
a1 1
/*	$OpenBSD: sdiff.c,v 1.24 2009/06/07 12:39:40 ray Exp $ */
d253 1
a253 1
	if ((tmpdir = getenv("TMPDIR")) == NULL)                       
@


1.24
log
@Remove outdated comment.
@
text
@d1 1
a1 1
/*	$OpenBSD: sdiff.c,v 1.23 2007/09/02 15:19:34 deraadt Exp $ */
d112 2
a113 1
		if (S_ISREG(sb.st_mode))
d115 1
@


1.23
log
@use calloc() to avoid malloc(n * m) overflows; checked by djm canacar jsg
@
text
@d1 1
a1 1
/*	$OpenBSD: sdiff.c,v 1.22 2007/06/28 02:14:41 ray Exp $ */
a1005 1
		/* XXX - Why can't this handle stdin? */
@


1.22
log
@Alias `1' and `2' to `l' and `r', making interactive merges easier
on the fingers.  This was recently added to GNU sdiff:

	http://www.nabble.com/sdiff-UI-enhancement-t3877253.html

Initial diff from Steven Kreuzer <skreuzer (at) exit2shell dot com>.

OK jmc, millert, sobrado, deraadt.
@
text
@d1 1
a1 1
/*	$OpenBSD: sdiff.c,v 1.21 2007/06/27 04:29:40 ray Exp $ */
d175 1
a175 1
	if (!(diffargv = malloc(sizeof(char **) * argc * 2)))
@


1.21
log
@Add missing undocumented --ignore-case flag, to improve compatibility
with GNU sdiff.

From Steven Kreuzer <skreuzer () exit2shell ! com>
@
text
@d1 1
a1 1
/*	$OpenBSD: sdiff.c,v 1.20 2006/09/19 05:52:23 otto Exp $ */
d439 1
d451 1
d1024 2
a1025 2
	    "l:\tchoose left diff\n"
	    "r:\tchoose right diff\n"
@


1.20
log
@Use S_IS* macros insted of masking with S_IF* flags. The latter may
have multiple bits set, which lead to surprising results. Spotted by
Paul Stoeber, more to come. ok millert@@ pedro@@ jaredy@@ djm@@
@
text
@d1 1
a1 1
/*	$OpenBSD: sdiff.c,v 1.19 2006/05/25 03:20:32 ray Exp $ */
d80 1
@


1.19
log
@Remove xmktemp() and uses plain old mkstemp(3), avoiding race
conditions.

OK moritz@@, otto@@
@
text
@d1 1
a1 1
/*	$OpenBSD: sdiff.c,v 1.18 2006/05/10 14:32:51 ray Exp $ */
d111 1
a111 1
		if (sb.st_mode & S_IFREG)
@


1.18
log
@Now that lint is smarter, remove /* NOTREACHED */ comments.

OK jaredy@@
@
text
@d1 1
a1 1
/*	$OpenBSD: sdiff.c,v 1.17 2006/03/05 07:12:26 otto Exp $ */
d20 1
d69 1
d122 3
a124 2
	target_file = xmktemp(NULL);
	if ((ofd = open(target_file, O_WRONLY, 0)) == -1) {
d249 3
@


1.17
log
@Handle stdin as arg; from Ray Lai; ok jaredy@@
@
text
@d1 1
a1 1
/*	$OpenBSD: sdiff.c,v 1.16 2006/02/20 08:29:44 otto Exp $ */
a237 1
			/* NOTREACHED */
d244 1
a244 1
	if (argc != 2) {
a245 2
		/* NOTREACHED */
	}
@


1.16
log
@refactor processq() loop. From Rai Lay; ok jaredy@@
@
text
@d1 1
a1 1
/*	$OpenBSD: sdiff.c,v 1.15 2006/02/15 15:27:38 otto Exp $ */
d10 1
d16 2
d26 1
d46 1
d88 62
d157 2
a158 1
	char **diffargv, *diffprog = "diff", *s1, *s2;
d250 26
a275 4
	/* file1 */
	diffargv[diffargc++] = argv[0];
	/* file2 */
	diffargv[diffargc++] = argv[1];
d312 5
a316 13
	/* If file1 or file2 were given as `-', open stdin. */
	/* XXX - Does not work. */
	if (strcmp(argv[0], "-") == 0)
		file1 = stdin;
	/* Otherwise, open as normal file. */
	else if ((file1 = fopen(argv[0], "r")) == NULL)
		err(2, "could not open file1: %s", argv[0]);
	/* XXX - Handle (file1 == file2 == stdin) case. */
	if (strcmp(argv[1], "-") == 0)
		file2 = stdin;
	/* Otherwise, open as normal file. */
	else if ((file2 = fopen(argv[1], "r")) == NULL)
		err(2, "could not open file2: %s", argv[1]);
d329 11
@


1.15
log
@Fix bug introduced by previous delint and rename a var. From Ray.
@
text
@d1 1
a1 1
/*	$OpenBSD: sdiff.c,v 1.14 2006/02/15 06:58:06 otto Exp $ */
d756 3
a758 1
	divc = '\0';
a766 9
		 * Make sure that divc is consistent throughout set.
		 * If divc is set, compare to next entry's divc.  They
		 * should be the same.  If divc is not set, then store
		 * this as this set's divc.
		 */
		if (divc == '\0')
			divc = diffp->div;

		/*
d770 2
a771 1
		if (!sflag || divc == '|' || divc == '<' || divc == '>')
@


1.14
log
@delint; from Ray with input from me and jaredy@@; ok jaredy@@
@
text
@d1 1
a1 1
/*	$OpenBSD: sdiff.c,v 1.13 2006/02/14 08:26:20 otto Exp $ */
d685 1
a685 1
	size_t newlen;
d722 2
a723 2
	/* Length = strlen(*s) + \n + strlen(append) + '\0'. */
	newlen = offset + 1 + strlen(append) + 1;
d726 1
a726 1
	newstr = realloc(*s, newlen);
d731 1
d733 2
a734 1
	strlcpy(*s + offset, "\n", newlen - offset);
d736 1
d738 1
a738 1
	offset = newlen - 1;
@


1.13
log
@Fix -I and some cleanup, from Ray Lai in PR 5002; ok jaredy@@
@
text
@d1 1
a1 1
/*	$OpenBSD: sdiff.c,v 1.12 2005/12/28 05:57:46 deraadt Exp $ */
d35 3
a37 3
	const char	*left;
	char		 div;
	const char	*right;
d41 2
a42 2
static void enqueue(const char *, const char, const char *);
static void freediff(const struct diffline *);
d90 1
a90 1
	const char **diffargv, *diffprog = "diff", *s1, *s2;
d209 1
a209 1
		execvp(diffprog, (char *const *)diffargv);
d319 1
a319 1
	const char *cmd;
d325 1
a325 1
	for (; (cmd = xfgets(stdin)); free((void *)cmd)) {
d379 1
a379 1
		free((void *)cmd);
d571 1
a571 1
		const char *s1, *s2;
d580 1
a580 1
			free((void *)s2);
d597 1
a597 1
		const char *s;
d606 1
a606 1
		const char *s;
d613 1
a613 1
			free((void *)s);
d653 1
a653 1
enqueue(const char *left, const char div, const char *right)
d669 1
a669 1
freediff(const struct diffline *diffp)
d671 3
a673 5
	if (diffp->left)
		free((void *)diffp->left);
	if (diffp->right)
		free((void *)diffp->right);
	free((void *)diffp);
d685 1
a685 1
	size_t copied, newlen;
d690 1
a690 1
	const static char *oldstr = NULL;
a732 1
	copied = strlcat(*s + offset, append, newlen - offset);
d747 1
a747 1
	char div, *left, *right;
d753 1
a753 1
	div = '\0';
d762 4
a765 4
		 * Make sure that div is consistent throughout set.
		 * If div is set, compare to next entry's div.  They
		 * should be the same.  If div is not set, then store
		 * this as this set's div.
d767 2
a768 2
		if (!div)
			div = diffp->div;
d774 1
a774 1
		if (!sflag || div == '|' || div == '<' || div == '>')
d793 1
a793 1
		switch (div) {
d801 1
a801 1
			errx(2, "invalid divider: %c", div);
d805 2
a806 4
	if (left)
		free(left);
	if (right)
		free(right);
d834 2
a835 2
		SIMPLEQ_ENTRY(fileline) fileentries;
		const char	*line;
d842 1
a842 1
		const char *line1;
a886 1
#undef getaddln
d906 1
a906 1
	const char *line1;
@


1.12
log
@spacing
@
text
@d1 1
a1 1
/*	$OpenBSD: sdiff.c,v 1.11 2005/12/27 05:13:14 tedu Exp $ */
d44 1
a44 1
static int parsecmd(FILE *, FILE *);
d48 1
a48 1
static void printd(FILE *, FILE *, size_t);
a51 1
static void undiff(char *);
d59 1
d86 1
a86 1
	FILE *difffile, *origfile;
d90 1
a90 1
	const char *cmd, **diffargv, *diffprog = "diff";
d136 1
d220 1
a220 1
	if ((difffile = fdopen(fd[0], "r")) == NULL)
d222 1
a222 1
	/* If file1 was given as `-', open stdin. */
d225 1
a225 1
		origfile = stdin;
d227 1
a227 1
	else if ((origfile = fopen(argv[0], "r")) == NULL)
d229 6
d239 1
a239 1
	while (parsecmd(difffile, origfile) != EOF)
d241 1
a241 1
	fclose(difffile);
d249 14
a262 3
	while ((cmd = xfgets(origfile)))
		enqueue(cmd, ' ', lflag ? NULL : cmd);
	fclose(origfile);
d466 3
a468 3
 * Parse ed commands from diff and print lines from difffile
 * (lines to add or change) or origfile (lines to change or delete).
 * Returns EOF or not.
d471 1
a471 1
parsecmd(FILE *difffile, FILE *origfile)
d473 1
a473 1
	size_t file1start, file1end, file2start, file2end;
d480 1
a480 1
	if (!(line = xfgets(difffile)))
d565 7
a571 3
	/* Skip unmodified lines. */
	for (; file1ln < file1start; ++file1ln, ++file2ln) {
		const char *line;
d573 1
a573 1
		if (!(line = xfgets(origfile)))
d575 2
d579 24
a602 1
		enqueue(line, ' ', lflag ? NULL : line);
d604 15
a618 1
	/* Process unmodified lines. */
d623 2
a624 1
		printa(difffile, file2end);
d628 2
a629 1
		printc(origfile, file1end, difffile, file2end);
d633 2
a634 1
		printd(origfile, difffile, file1end);
d641 5
a670 1

d673 1
a673 5
	/*
	 * Free right string only if it is different than left.
	 * The strings are the same when the lines are identical.
	 */
	if (diffp->right && diffp->right != diffp->left)
d675 1
d774 2
a775 2
		 * If the -s flag was not given or the lines are not
		 * identical then print columns.
d777 1
a777 1
		if (!sflag || diffp->div != ' ')
d790 1
a791 2
		SIMPLEQ_REMOVE_HEAD(&diffhead, diffentries);
		free(diffp);
d795 3
a797 2
	if (outfile) {
		if (div == ' ')
d799 2
a800 1
		else
d802 4
a805 1
	}
a814 14
 * Remove angle bracket in front of diff line.
 */
static void
undiff(char *s)
{
	size_t len;

	/* Remove angle bracket and space but keep the NUL. */
	len = strlen(s) - 2 + 1;
	/* Move everything two characters over. */
	memmove(s, s + 2, len);
}

/*
a824 1
		undiff(line);
a842 1
	char *line;
d847 1
a847 1
		const char *line1, *line2;
a851 5
		if (!(line2 = xfgets(file2)))
			errx(2, "error reading diff in delete in change");

		/* Unused now. */
		free((void *)line2);
a859 12
	/* There should be a divider here. */
	if (!(line = xfgets(file2)))
		errx(2, "error reading diff in change: expected divider");
	free(line);

#define getaddln(add) do {					\
	/* Read diff for line. */				\
	if (!((add) = xfgets(file2)))				\
		errx(2, "error reading add in change");		\
	/* Remove ``> ''. */					\
	undiff(add);						\
} while (0)
d867 2
a868 1
		getaddln(add);
d886 2
a887 1
		getaddln(add);
d910 1
a910 1
printd(FILE *file1, FILE *file2, size_t file1end)
d912 1
a912 1
	const char *line1, *line2;
a918 3
		if (!(line2 = xfgets(file2)))
			errx(2, "diff ended early in delete");
		free((void *)line2);
@


1.11
log
@remove xstrtonum
@
text
@d1 1
a1 1
/*	$OpenBSD: sdiff.c,v 1.10 2005/12/27 05:04:27 deraadt Exp $ */
d255 1
a255 1
 * the cursor is on the screen, and the maximum value of the column.  
@


1.10
log
@shorten main initialization
@
text
@d1 1
a1 1
/*	$OpenBSD: sdiff.c,v 1.9 2005/12/27 04:46:32 tedu Exp $ */
a54 1
static size_t xstrtonum(const char *);
a252 35
 * Takes a string nptr and returns a numeric value.  The first character
 * must be a digit.  Parsing ends when a non-numerical character is
 * reached.
 */
static size_t
xstrtonum(const char *nptr)
{
	size_t n;
	const char *errstr;
	char *copy, *ptr;

	/* Make copy of numeric string. */
	if ((copy = strdup(nptr)) == NULL)
		err(2, "out of memory");

	/* Look for first non-digit. */
	for (ptr = copy; isdigit(*ptr); ++ptr)
		;

	/* End string at first non-digit. */
	if (*ptr != '\0')
		*ptr = '\0';

	/* Parse number. */
	n = strtonum(copy, 0, INT_MAX, &errstr);
	if (errstr)
		errx(2, "line number in diff is %s: %s", errstr, nptr);

	/* Free copy of numeric string. */
	free(copy);

	return (n);
}

/*
d457 3
a459 2
	const char *line, *p;
	char cmd;
a464 1
	file1start = xstrtonum(line);
d469 5
d476 1
a476 3
	if (*p == ',') {
		/* Go to range end. */
		++p;
d478 9
a486 1
		file1end = xstrtonum(p);
a489 3
		/* Go to character after file2end. */
		while (isdigit(*p))
			++p;
d493 1
a493 3
	/* This character should be the ed command now. */
	cmd = *p;

d498 1
a498 4
	/* Go to file2 line range. */
	++p;

	file2start = xstrtonum(p);
d502 5
d512 2
a513 2
	if (!(*p == ',' || *p == '\0'))
		errx(2, "invalid line range in file2: %c: %s", *p, line);
d515 1
a515 2
	if (*p == ',') {
		++p;
d517 3
a519 1
		file2end = xstrtonum(p);
@


1.9
log
@INT_MAX should be big enough for a width
@
text
@d1 1
a1 1
/*	$OpenBSD: sdiff.c,v 1.8 2005/12/27 04:43:01 tedu Exp $ */
d88 1
a88 1
	size_t argc_max, diffargc, wflag;
d91 1
a91 7
	const char *cmd, **diffargv, *diffprog;

	/* Initialize variables. */
	diffargc = 0;
	diffprog = "diff";
	outfile = NULL;
	wflag = WIDTH;
d104 1
a104 2
	argc_max = argc * 2;
	if (!(diffargv = malloc(sizeof(char **) * argc_max)))
@


1.8
log
@remove debug mode
@
text
@d1 1
a1 1
/*	$OpenBSD: sdiff.c,v 1.7 2005/12/27 04:35:22 tedu Exp $ */
d171 1
a171 1
			    (MIN(SIZE_T_MAX, LLONG_MAX)), &errstr);
d285 1
a285 2
	/* XXX - Is it safe to compare SIZE_T_MAX and LLONG_MAX? */
	n = strtonum(copy, 0, MIN(SIZE_T_MAX, LLONG_MAX), &errstr);
@


1.7
log
@sizeof char is always 1
@
text
@d1 1
a1 1
/*	$OpenBSD: sdiff.c,v 1.6 2005/12/27 04:33:31 tedu Exp $ */
a12 1
#include <assert.h>
a60 1
int	 Dflag;		/* debug - verify lots of things */
d117 1
a117 1
	while ((ch = getopt_long(argc, argv, "aBbDdEHI:ilo:stWw:",
a130 3
		case 'D':
			Dflag = 1;
			break;
a197 2
	if (Dflag)
		assert(width > 0);
a304 4
	if (Dflag) {
		assert(s);
		assert(*col <= col_max);
	}
a308 3
		if (Dflag)
			assert(*s != '\n');

a431 12
	if (Dflag) {
		/* These are the only legal column dividers. */
		assert(div == '<' || div == '|' || div == '>' || div == ' ');
		/* These are the only valid combinations. */
		assert((s1 != NULL && div == '<' && s2 == NULL) || div != '<');
		assert((s1 == NULL && div == '>' && s2 != NULL) || div != '>');
		assert((s1 != NULL && div == '|' && s2 != NULL && s2 != s1) ||
		    div != '|');
		assert((s1 != NULL && div == ' ' && (s2 == s1 || s2 == NULL)) ||
		    div != ' ');
	}

a437 3
		/* We should never exceed the width. */
		if (Dflag)
			assert(col <= width);
a463 4
	/* We should never exceed the line width. */
	if (Dflag)
		assert(col <= line_width);

a476 3
	if (Dflag)
		assert(file);

a484 4
		/* NULL from fparseln() should mean EOF. */
		if (Dflag)
			assert(feof(file));

a594 10
	if (Dflag) {
		/*
		 * We are now at the line where adds, changes,
		 * or deletions occur.
		 */
		assert(file1start == file1ln);
		assert(file2start == file2ln);
		assert(file1start <= file1end);
		assert(file2start <= file2end);
	}
a596 4
		/* A range cannot be specified for file1. */
		if (Dflag)
			assert(file1start == file1end);

a604 4
		/* A range cannot be specified for file2. */
		if (Dflag)
			assert(file2start == file2end);

a636 2
	if (Dflag)
		assert(diffp);
a664 2
	if (Dflag)
		assert(append);
a692 5
	/* This should always be the end of the string. */
	if (Dflag) {
		assert(*(*s + offset) == '\0');
		assert(strlen(*s) == offset);
	}
a706 7
	/*
	 * We should have copied exactly newlen characters, including
	 * the terminating NUL.  `copied' includes the \n character.
	 */
	if (Dflag)
		assert(offset + copied + 1 == newlen);

a739 2
		if (Dflag)
			assert(div == diffp->div || !div);
a756 4
	/* div should no longer be NUL. */
	if (Dflag)
		assert(div);

a787 6
	if (Dflag) {
		assert(s);
		assert(*s == '<' || *s == '>');
		assert(*(s + 1) == ' ');
	}

a789 3
	/* Copy at least the NUL. */
	if (Dflag)
		assert(len > 0);
a801 5
	if (Dflag) {
		assert(file);
		assert(file2ln <= line2);
	}

a825 9
	if (Dflag) {
		assert(file1);
		assert(file2);
		assert(file1ln <= file1end);
		assert(file2ln <= file2end);
		/* Change diff sets always start out with an empty queue. */
		assert(SIMPLEQ_EMPTY(&diffhead));
	}

a836 7
		/* Verify lines. */
		if (Dflag && strncmp("< ", line2, 2) != 0)
			errx(2, "invalid del/change diff: %s", line2);
		if (Dflag && strcmp(line1, line2 + 2))
			warnx("diff differs from file1:\ndiff:\n%s\nfile:\n%s",
			    line2, line1);

a849 2
	if (Dflag && strcmp("---", line))
		errx(2, "divider expected: %s", line);
a855 3
	/* Verify line. */					\
	if (Dflag && strncmp("> ", (add), 2))			\
		errx(2, "invalid add/change diff: %s", (add));	\
a910 8
	if (Dflag) {
		assert(file1);
		assert(file2);
		assert(file1ln <= file1end);
		/* Delete diff sets always start with an empty queue. */
		assert(SIMPLEQ_EMPTY(&diffhead));
	}

a917 4
		/* Compare delete line from diff to file1. */
		if (Dflag && strcmp(line1, line2 + 2) != 0)
			warnx("diff differs from file1:\ndiff:\n%s\nfile:\n%s",
			    line2, line1);
d947 1
a947 1
	    "usage: %s [-abDdilstW] [-I regexp] [-o outfile] [-w width] file1 file2\n",
@


1.6
log
@if an allocation function fails, err will print "cannot allocate memory"
for us, just add the name of the function
@
text
@d1 1
a1 1
/*	$OpenBSD: sdiff.c,v 1.5 2005/12/27 04:31:06 tedu Exp $ */
d779 1
a779 1
		assert(offset + copied + sizeof((char)'\0') == newlen);
d782 1
a782 1
	offset = newlen - sizeof((char)'\0');
@


1.5
log
@close can't really fail, don't bother checking
@
text
@d1 1
a1 1
/*	$OpenBSD: sdiff.c,v 1.4 2005/12/27 04:28:08 tedu Exp $ */
d114 1
a114 1
		err(2, "out of memory");
d682 1
a682 1
		err(2, "could not allocate memory");
d733 1
a733 1
			err(2, "could not allocate memory");
d767 1
a767 1
		err(2, "could not allocate memory");
d952 1
a952 1
			err(2, "could not allocate memory");
@


1.4
log
@remove broken assert on argc, and put argc check in right place
@
text
@d1 1
a1 1
/*	$OpenBSD: sdiff.c,v 1.3 2005/12/27 04:18:07 tedu Exp $ */
d217 1
a217 2
		if (close(fd[0]))
			err(2, "child could not close pipe input");
d221 1
a221 2
		if (close(fd[1]))
			err(2, "child could not close pipe output");
d231 1
a231 2
	if (close(fd[1]))
		err(2, "could not close pipe output");
d249 1
a249 2
	if (fclose(difffile))
		err(2, "could not close diff pipe");
d259 1
a259 2
	if (fclose(origfile))
		err(2, "could not close file1: %s", argv[0]);
d428 1
a428 2
	if (fclose(outfile))
		err(2, "could not close output file");
@


1.3
log
@variables in header should be extern, defined in a c file.
if cast for free is needed because of const nastiness, at least cast to void *
@
text
@d1 1
a1 1
/*	$OpenBSD: sdiff.c,v 1.2 2005/12/27 04:06:16 tedu Exp $ */
a95 1
	Dflag = lflag = sflag = 0;
d143 1
a143 1
			diffprog = optarg;
a184 2
		/* Don't exceed buffer after adding file1, file2, and NULL. */
		assert(diffargc + 3 <= argc_max);
d189 5
a208 5

	if (argc != 2) {
		usage();
		/* NOTREACHED */
	}
@


1.2
log
@OpenBSD tags
@
text
@d1 1
a1 1
/*	$OpenBSD$ */
d65 1
d373 1
a373 1
	for (; (cmd = xfgets(stdin)); free((char *)cmd)) {
d427 1
a427 1
		free((char *)cmd);
d679 1
a679 1
	return (!EOF);
d708 1
a708 1
		free((char *)diffp->left);
d714 1
a714 1
		free((char *)diffp->right);
d957 1
a957 1
		free((char *)line2);
d1054 1
a1054 1
		free((char *)line2);
@


1.1
log
@add a public domain sdiff implementation contributed by ray lai
@
text
@d1 1
a1 1
/*	$Id: sdiff.c,v 1.106 2005/12/16 20:31:25 ray Exp $	*/
@

