head	1.94;
access;
symbols
	OPENBSD_6_2:1.94.0.6
	OPENBSD_6_2_BASE:1.94
	OPENBSD_6_1:1.94.0.4
	OPENBSD_6_1_BASE:1.94
	OPENBSD_6_0:1.91.0.2
	OPENBSD_6_0_BASE:1.91
	OPENBSD_5_9:1.90.0.2
	OPENBSD_5_9_BASE:1.90
	OPENBSD_5_8:1.85.0.4
	OPENBSD_5_8_BASE:1.85
	OPENBSD_5_7:1.83.0.2
	OPENBSD_5_7_BASE:1.83
	OPENBSD_5_6:1.81.0.6
	OPENBSD_5_6_BASE:1.81
	OPENBSD_5_5:1.81.0.4
	OPENBSD_5_5_BASE:1.81
	OPENBSD_5_4:1.80.0.2
	OPENBSD_5_4_BASE:1.80
	OPENBSD_5_3:1.79.0.2
	OPENBSD_5_3_BASE:1.79
	OPENBSD_5_2:1.78.0.4
	OPENBSD_5_2_BASE:1.78
	OPENBSD_5_1_BASE:1.78
	OPENBSD_5_1:1.78.0.2
	OPENBSD_5_0:1.77.0.2
	OPENBSD_5_0_BASE:1.77
	OPENBSD_4_9:1.76.0.4
	OPENBSD_4_9_BASE:1.76
	OPENBSD_4_8:1.76.0.2
	OPENBSD_4_8_BASE:1.76
	OPENBSD_4_7:1.75.0.2
	OPENBSD_4_7_BASE:1.75
	OPENBSD_4_6:1.75.0.4
	OPENBSD_4_6_BASE:1.75
	OPENBSD_4_5:1.74.0.2
	OPENBSD_4_5_BASE:1.74
	OPENBSD_4_4:1.73.0.2
	OPENBSD_4_4_BASE:1.73
	OPENBSD_4_3:1.71.0.2
	OPENBSD_4_3_BASE:1.71
	OPENBSD_4_2:1.70.0.2
	OPENBSD_4_2_BASE:1.70
	OPENBSD_4_1:1.68.0.2
	OPENBSD_4_1_BASE:1.68
	OPENBSD_4_0:1.66.0.2
	OPENBSD_4_0_BASE:1.66
	OPENBSD_3_9:1.65.0.4
	OPENBSD_3_9_BASE:1.65
	OPENBSD_3_8:1.65.0.2
	OPENBSD_3_8_BASE:1.65
	OPENBSD_3_7:1.59.0.2
	OPENBSD_3_7_BASE:1.59
	OPENBSD_3_6:1.55.0.2
	OPENBSD_3_6_BASE:1.55
	OPENBSD_3_5:1.54.0.2
	OPENBSD_3_5_BASE:1.54
	OPENBSD_3_4:1.47.0.2
	OPENBSD_3_4_BASE:1.47
	OPENBSD_3_3:1.21.0.2
	OPENBSD_3_3_BASE:1.21
	OPENBSD_3_2:1.17.0.4
	OPENBSD_3_2_BASE:1.17
	OPENBSD_3_1:1.17.0.2
	OPENBSD_3_1_BASE:1.17
	OPENBSD_3_0:1.15.0.4
	OPENBSD_3_0_BASE:1.15
	OPENBSD_2_9_BASE:1.15
	OPENBSD_2_9:1.15.0.2
	OPENBSD_2_8:1.14.0.2
	OPENBSD_2_8_BASE:1.14
	OPENBSD_2_7:1.13.0.2
	OPENBSD_2_7_BASE:1.13
	OPENBSD_2_6:1.12.0.2
	OPENBSD_2_6_BASE:1.12
	OPENBSD_2_5:1.10.0.4
	OPENBSD_2_5_BASE:1.10
	OPENBSD_2_4:1.10.0.2
	OPENBSD_2_4_BASE:1.10
	OPENBSD_2_3:1.9.0.2
	OPENBSD_2_3_BASE:1.9
	OPENBSD_2_2:1.7.0.2
	OPENBSD_2_2_BASE:1.7;
locks; strict;
comment	@ * @;


1.94
date	2016.09.03.13.26.50;	author tedu;	state Exp;
branches;
next	1.93;
commitid	wQwNauUPGSabJzA7;

1.93
date	2016.09.03.12.29.30;	author tedu;	state Exp;
branches;
next	1.92;
commitid	yxeZjOLfvUjJbqiu;

1.92
date	2016.09.03.11.41.10;	author tedu;	state Exp;
branches;
next	1.91;
commitid	NacWFWgKwtkfLhFL;

1.91
date	2016.07.14.08.31.18;	author semarie;	state Exp;
branches;
next	1.90;
commitid	X351wak6SvhlNPZD;

1.90
date	2015.10.17.21.34.07;	author naddy;	state Exp;
branches;
next	1.89;
commitid	ePNjqcwltlOgTM3M;

1.89
date	2015.10.09.01.37.07;	author deraadt;	state Exp;
branches;
next	1.88;
commitid	sbrB3Q5CNxcwZpfU;

1.88
date	2015.10.04.16.50.29;	author deraadt;	state Exp;
branches;
next	1.87;
commitid	XSPwqcxQ5YF9mWM4;

1.87
date	2015.10.03.04.19.14;	author deraadt;	state Exp;
branches;
next	1.86;
commitid	P85uu4SNHSQDO6SV;

1.86
date	2015.08.30.21.06.24;	author deraadt;	state Exp;
branches;
next	1.85;
commitid	AnfyfI9ElqTcHho3;

1.85
date	2015.06.25.02.04.08;	author uebayasi;	state Exp;
branches;
next	1.84;
commitid	lJr85pywqGCq0vnE;

1.84
date	2015.05.03.19.44.59;	author guenther;	state Exp;
branches;
next	1.83;
commitid	EhByHUPhmNVyA3OR;

1.83
date	2015.01.16.06.40.06;	author deraadt;	state Exp;
branches;
next	1.82;
commitid	Uu5nFG3wCl0LACBb;

1.82
date	2014.10.08.03.59.11;	author doug;	state Exp;
branches;
next	1.81;
commitid	fgGniaQu17TQWYWZ;

1.81
date	2014.01.27.17.13.10;	author millert;	state Exp;
branches;
next	1.80;

1.80
date	2013.04.17.17.43.55;	author deraadt;	state Exp;
branches;
next	1.79;

1.79
date	2012.09.30.14.50.38;	author millert;	state Exp;
branches;
next	1.78;

1.78
date	2011.09.22.10.41.04;	author deraadt;	state Exp;
branches;
next	1.77;

1.77
date	2011.03.05.20.12.42;	author millert;	state Exp;
branches;
next	1.76;

1.76
date	2010.07.28.23.52.01;	author millert;	state Exp;
branches;
next	1.75;

1.75
date	2009.04.18.18.21.54;	author naddy;	state Exp;
branches;
next	1.74;

1.74
date	2008.10.08.17.06.30;	author millert;	state Exp;
branches;
next	1.73;

1.73
date	2008.07.27.13.15.31;	author sobrado;	state Exp;
branches;
next	1.72;

1.72
date	2008.07.05.21.00.38;	author sobrado;	state Exp;
branches;
next	1.71;

1.71
date	2008.02.25.16.53.55;	author millert;	state Exp;
branches;
next	1.70;

1.70
date	2007.04.04.13.29.45;	author millert;	state Exp;
branches;
next	1.69;

1.69
date	2007.04.03.20.25.35;	author millert;	state Exp;
branches;
next	1.68;

1.68
date	2007.01.18.20.53.36;	author millert;	state Exp;
branches;
next	1.67;

1.67
date	2006.12.01.08.14.53;	author otto;	state Exp;
branches;
next	1.66;

1.66
date	2006.03.13.14.49.59;	author millert;	state Exp;
branches;
next	1.65;

1.65
date	2005.07.22.08.38.46;	author jmc;	state Exp;
branches;
next	1.64;

1.64
date	2005.07.11.14.16.47;	author millert;	state Exp;
branches;
next	1.63;

1.63
date	2005.06.26.18.20.26;	author otto;	state Exp;
branches;
next	1.62;

1.62
date	2005.04.17.16.17.39;	author deraadt;	state Exp;
branches;
next	1.61;

1.61
date	2005.04.17.16.07.16;	author hshoexer;	state Exp;
branches;
next	1.60;

1.60
date	2005.04.14.18.28.27;	author deraadt;	state Exp;
branches;
next	1.59;

1.59
date	2005.02.24.09.44.36;	author moritz;	state Exp;
branches;
next	1.58;

1.58
date	2005.02.07.08.37.28;	author otto;	state Exp;
branches;
next	1.57;

1.57
date	2005.01.27.12.58.22;	author otto;	state Exp;
branches;
next	1.56;

1.56
date	2004.09.20.18.53.20;	author millert;	state Exp;
branches;
next	1.55;

1.55
date	2004.07.29.04.07.44;	author millert;	state Exp;
branches;
next	1.54;

1.54
date	2004.02.29.13.59.15;	author markus;	state Exp;
branches;
next	1.53;

1.53
date	2004.01.22.18.50.39;	author millert;	state Exp;
branches;
next	1.52;

1.52
date	2003.12.16.23.32.24;	author henning;	state Exp;
branches;
next	1.51;

1.51
date	2003.12.16.23.23.50;	author henning;	state Exp;
branches;
next	1.50;

1.50
date	2003.12.16.22.46.26;	author henning;	state Exp;
branches;
next	1.49;

1.49
date	2003.12.16.18.38.01;	author henning;	state Exp;
branches;
next	1.48;

1.48
date	2003.12.09.07.34.55;	author millert;	state Exp;
branches;
next	1.47;

1.47
date	2003.09.05.21.03.36;	author henning;	state Exp;
branches
	1.47.2.1;
next	1.46;

1.46
date	2003.09.05.20.41.48;	author henning;	state Exp;
branches;
next	1.45;

1.45
date	2003.09.05.04.46.35;	author tedu;	state Exp;
branches;
next	1.44;

1.44
date	2003.08.05.18.22.17;	author deraadt;	state Exp;
branches;
next	1.43;

1.43
date	2003.07.29.18.33.11;	author millert;	state Exp;
branches;
next	1.42;

1.42
date	2003.07.29.07.09.07;	author millert;	state Exp;
branches;
next	1.41;

1.41
date	2003.07.27.19.04.22;	author millert;	state Exp;
branches;
next	1.40;

1.40
date	2003.07.25.20.10.53;	author millert;	state Exp;
branches;
next	1.39;

1.39
date	2003.07.18.20.46.42;	author millert;	state Exp;
branches;
next	1.38;

1.38
date	2003.07.18.20.43.18;	author millert;	state Exp;
branches;
next	1.37;

1.37
date	2003.07.17.20.06.01;	author millert;	state Exp;
branches;
next	1.36;

1.36
date	2003.07.15.19.01.46;	author millert;	state Exp;
branches;
next	1.35;

1.35
date	2003.07.14.18.57.31;	author millert;	state Exp;
branches;
next	1.34;

1.34
date	2003.07.14.18.42.20;	author mickey;	state Exp;
branches;
next	1.33;

1.33
date	2003.07.11.02.31.18;	author millert;	state Exp;
branches;
next	1.32;

1.32
date	2003.07.08.00.30.12;	author mickey;	state Exp;
branches;
next	1.31;

1.31
date	2003.06.30.03.42.05;	author millert;	state Exp;
branches;
next	1.30;

1.30
date	2003.06.29.21.14.37;	author millert;	state Exp;
branches;
next	1.29;

1.29
date	2003.06.27.17.33.26;	author millert;	state Exp;
branches;
next	1.28;

1.28
date	2003.06.23.19.35.31;	author millert;	state Exp;
branches;
next	1.27;

1.27
date	2003.06.23.16.19.25;	author millert;	state Exp;
branches;
next	1.26;

1.26
date	2003.06.22.22.17.46;	author deraadt;	state Exp;
branches;
next	1.25;

1.25
date	2003.06.22.15.22.43;	author deraadt;	state Exp;
branches;
next	1.24;

1.24
date	2003.06.10.22.20.45;	author deraadt;	state Exp;
branches;
next	1.23;

1.23
date	2003.06.04.04.55.58;	author deraadt;	state Exp;
branches;
next	1.22;

1.22
date	2003.04.07.20.55.33;	author deraadt;	state Exp;
branches;
next	1.21;

1.21
date	2003.01.07.18.48.06;	author millert;	state Exp;
branches;
next	1.20;

1.20
date	2003.01.06.18.09.22;	author mickey;	state Exp;
branches;
next	1.19;

1.19
date	2002.12.17.16.16.08;	author millert;	state Exp;
branches;
next	1.18;

1.18
date	2002.12.08.16.07.54;	author mickey;	state Exp;
branches;
next	1.17;

1.17
date	2002.02.16.21.27.45;	author millert;	state Exp;
branches;
next	1.16;

1.16
date	2001.11.19.19.02.13;	author mpech;	state Exp;
branches;
next	1.15;

1.15
date	2000.12.12.16.23.27;	author millert;	state Exp;
branches;
next	1.14;

1.14
date	2000.06.30.16.00.12;	author millert;	state Exp;
branches;
next	1.13;

1.13
date	2000.03.10.06.53.51;	author d;	state Exp;
branches
	1.13.2.1;
next	1.12;

1.12
date	99.09.26.17.35.49;	author mickey;	state Exp;
branches;
next	1.11;

1.11
date	99.09.26.14.04.58;	author espie;	state Exp;
branches;
next	1.10;

1.10
date	98.09.10.06.44.41;	author deraadt;	state Exp;
branches;
next	1.9;

1.9
date	98.03.10.16.34.03;	author mickey;	state Exp;
branches;
next	1.8;

1.8
date	98.02.13.16.36.24;	author millert;	state Exp;
branches;
next	1.7;

1.7
date	97.08.19.06.32.36;	author denny;	state Exp;
branches;
next	1.6;

1.6
date	97.07.19.19.08.28;	author mickey;	state Exp;
branches;
next	1.5;

1.5
date	97.07.08.10.06.31;	author mickey;	state Exp;
branches;
next	1.4;

1.4
date	97.07.08.03.13.19;	author mickey;	state Exp;
branches;
next	1.3;

1.3
date	97.07.06.22.03.34;	author mickey;	state Exp;
branches;
next	1.2;

1.2
date	97.07.06.20.47.32;	author mickey;	state Exp;
branches;
next	1.1;

1.1
date	97.07.06.20.22.58;	author mickey;	state Exp;
branches;
next	;

1.13.2.1
date	2000.10.06.21.16.11;	author jason;	state Exp;
branches;
next	;

1.47.2.1
date	2004.01.31.04.17.53;	author brad;	state Exp;
branches;
next	;


desc
@@


1.94
log
@remove parens from method calls
@
text
@/*	$OpenBSD: main.c,v 1.93 2016/09/03 12:29:30 tedu Exp $	*/

/*
 * Copyright (c) 1992, 1993
 *	The Regents of the University of California.  All rights reserved.
 * Copyright (c) 1997-2002 Michael Shalayeff
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 * IN NO EVENT SHALL THE AUTHOR OR HIS RELATIVES BE LIABLE FOR ANY DIRECT,
 * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF MIND, USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
 * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
 * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
 * THE POSSIBILITY OF SUCH DAMAGE.
 */

#include <sys/time.h>
#include <sys/stat.h>

#include <getopt.h>
#include <err.h>
#include <errno.h>
#include <fts.h>
#include <libgen.h>
#include <stdio.h>
#include <stdlib.h>
#include <stdbool.h>
#include <string.h>
#include <unistd.h>
#include <limits.h>
#include <fcntl.h>
#include <paths.h>
#include "compress.h"

#define min(a,b) ((a) < (b)? (a) : (b))

int cat, decomp, pipin, force, verbose, testmode, list, recurse, storename;
extern char *__progname;

const struct compressor {
	const char *name;
	const char *suffix;
	const u_char *magic;
	const char *comp_opts;
	const char *decomp_opts;
	const char *cat_opts;
	void *(*ropen)(int, char *, int);
	int (*read)(void *, char *, int);
#ifndef SMALL
	void *(*wopen)(int, char *, int, u_int32_t);
	int (*write)(void *, const char *, int);
#endif
	int (*close)(void *, struct z_info *, const char *, struct stat *);
} c_table[] = {
#define M_DEFLATE (&c_table[0])
	{
		"deflate",
		".gz",
		"\037\213",
		"123456789ab:cdfhLlNnOo:qrS:tVv",
		"cfhLlNno:qrtVv",
		"fhqr",
		gz_ropen,
		gz_read,
#ifndef SMALL
		gz_wopen,
		gz_write,
#endif
		gz_close
	},
#define M_COMPRESS (&c_table[1])
#ifndef SMALL
	{
		"compress",
		".Z",
		"\037\235",
		"123456789ab:cdfghlNnOo:qrS:tv",
		"cfhlNno:qrtv",
		"fghqr",
		z_ropen,
		zread,
		z_wopen,
		zwrite,
		z_close
	},
#endif /* SMALL */
  { NULL }
};

#ifndef SMALL
const struct compressor null_method = {
	"null",
	".nul",
	"XX",
	"123456789ab:cdfghlNnOo:qrS:tv",
	"cfhlNno:qrtv",
	"fghqr",
	null_ropen,
	null_read,
	null_wopen,
	null_write,
	null_close
};
#endif /* SMALL */

int permission(const char *);
__dead void usage(int);
int docompress(const char *, char *, const struct compressor *,
    int, struct stat *);
int dodecompress(const char *, char *, struct stat *);
const struct compressor *check_method(int);
const char *check_suffix(const char *);
char *set_outfile(const char *, char *, size_t);
void list_stats(const char *, const struct compressor *, struct z_info *);
void verbose_info(const char *, off_t, off_t, u_int32_t);

const struct option longopts[] = {
#ifndef SMALL
	{ "ascii",	no_argument,		0, 'a' },
	{ "stdout",	no_argument,		0, 'c' },
	{ "to-stdout",	no_argument,		0, 'c' },
	{ "decompress",	no_argument,		0, 'd' },
	{ "uncompress",	no_argument,		0, 'd' },
	{ "force",	no_argument,		0, 'f' },
	{ "help",	no_argument,		0, 'h' },
	{ "list",	no_argument,		0, 'l' },
	{ "license",	no_argument,		0, 'L' },
	{ "no-name",	no_argument,		0, 'n' },
	{ "name",	no_argument,		0, 'N' },
	{ "quiet",	no_argument,		0, 'q' },
	{ "recursive",	no_argument,		0, 'r' },
	{ "suffix",	required_argument,	0, 'S' },
	{ "test",	no_argument,		0, 't' },
	{ "verbose",	no_argument,		0, 'v' },
	{ "version",	no_argument,		0, 'V' },
	{ "fast",	no_argument,		0, '1' },
	{ "best",	no_argument,		0, '9' },
#endif /* SMALL */
	{ NULL }
};

int
main(int argc, char *argv[])
{
	FTS *ftsp;
	FTSENT *entry;
	const struct compressor *method;
	const char *optstr, *s;
	char *p, *infile;
	char outfile[PATH_MAX], _infile[PATH_MAX], suffix[16];
	int bits, ch, error, rc, cflag, oflag;

	if (pledge("stdio rpath wpath cpath fattr chown", NULL) == -1)
		err(1, "pledge");

	bits = cflag = oflag = 0;
	storename = -1;
	p = __progname;
	if (p[0] == 'g') {
		method = M_DEFLATE;
		bits = 6;
		p++;
	} else {
#ifdef SMALL
		method = M_DEFLATE;
#else
		method = M_COMPRESS;
#endif /* SMALL */
	}
	optstr = method->comp_opts;

	decomp = 0;
	pmode = MODE_COMP;
	if (!strcmp(p, "zcat")) {
		decomp++;
		cflag = 1;
		pmode = MODE_CAT;
	} else {
		if (p[0] == 'u' && p[1] == 'n') {
			p += 2;
			decomp++;
			pmode = MODE_DECOMP;
		}

		if (strcmp(p, "zip") &&
		    strcmp(p, "compress"))
			errx(1, "unknown program name");
	}

	strlcpy(suffix, method->suffix, sizeof(suffix));

	if (method == M_DEFLATE && (p = getenv("GZIP")) != NULL) {
		char *evbuf, *last, **nargv = NULL;
		int argc_extra = 0, nargc = 0;

		if ((evbuf = strdup(p)) == NULL)
			err(1, NULL);
		for ((p = strtok_r(evbuf, " ", &last)); p != NULL;
		    (p = strtok_r(NULL, " ", &last))) {
			if (nargc + 1 >= argc_extra) {
				argc_extra += 1024;
				nargv = reallocarray(nargv,
				    argc + argc_extra + 1, sizeof(char *));
				if (nargv == NULL)
					err(1, NULL);
			}
			nargv[++nargc] = p;
		}
		if (nargv != NULL) {
			nargv[0] = *argv++;
			while ((nargv[++nargc] = *argv++))
				;
			argv = nargv;
			argc = nargc;
		}
	}

	optstr += pmode;
	while ((ch = getopt_long(argc, argv, optstr, longopts, NULL)) != -1)
		switch (ch) {
		case '1':
		case '2':
		case '3':
		case '4':
		case '5':
		case '6':
		case '7':
		case '8':
		case '9':
			method = M_DEFLATE;
			strlcpy(suffix, method->suffix, sizeof(suffix));
			bits = ch - '0';
			break;
		case 'a':
			warnx("option -a is ignored on this system");
			break;
		case 'b':
			bits = strtol(optarg, &p, 10);
			/*
			 * POSIX 1002.3 says 9 <= bits <= 14 for portable
			 * apps, but says the implementation may allow
			 * greater.
			 */
			if (*p)
				errx(1, "illegal bit count -- %s", optarg);
			break;
		case 'c':
			cflag = 1;
			break;
		case 'd':		/* Backward compatible. */
			decomp++;
			break;
		case 'f':
			force++;
			break;
		case 'g':
			method = M_DEFLATE;
			strlcpy(suffix, method->suffix, sizeof(suffix));
			bits = 6;
			break;
		case 'l':
			list++;
			testmode = 1;
			decomp++;
			break;
		case 'n':
			storename = 0;
			break;
		case 'N':
			storename = 1;
			break;
#ifndef SMALL
		case 'O':
			method = M_COMPRESS;
			strlcpy(suffix, method->suffix, sizeof(suffix));
			break;
#endif /* SMALL */
		case 'o':
			if (strlcpy(outfile, optarg,
			    sizeof(outfile)) >= sizeof(outfile))
				errx(1, "-o argument is too long");
			oflag = 1;
			break;
		case 'q':
			verbose = -1;
			break;
		case 'S':
			p = suffix;
			if (optarg[0] != '.')
				*p++ = '.';
			strlcpy(p, optarg, sizeof(suffix) - (p - suffix));
			p = optarg;
			break;
		case 't':
			testmode = 1;
			decomp++;
			break;
		case 'V':
			exit (0);
		case 'v':
			verbose++;
			break;
		case 'L':
			exit (0);
		case 'r':
			recurse++;
			break;

		case 'h':
			usage(0);
			break;
		default:
			usage(1);
		}
	argc -= optind;
	argv += optind;

	if (cflag || testmode || (!oflag && argc == 0))
		if (pledge("stdio rpath", NULL) == -1)
			err(1, "pledge");

	if (argc == 0) {
		argv = calloc(2, sizeof(char *));
		if (argv == NULL)
			err(1, NULL);
		argv[0] = "-";
		argc = 1;
	}
	if (oflag && (recurse || argc > 1))
		errx(1, "-o option may only be used with a single input file");

	if ((cat && argc) + testmode + oflag > 1)
		errx(1, "may not mix -o, -c, or -t options");
	/*
	 * By default, when compressing store the original name and timestamp
	 * in the header.  Do not restore these when decompressing unless
	 * the -N option is given.
	 */
	if (storename == -1)
		storename = !decomp;

	if ((ftsp = fts_open(argv, FTS_PHYSICAL|FTS_NOCHDIR, 0)) == NULL)
		err(1, NULL);
	for (rc = SUCCESS; (entry = fts_read(ftsp)) != NULL;) {
		cat = cflag;
		pipin = 0;
		infile = entry->fts_path;
		if (infile[0] == '-' && infile[1] == '\0') {
			infile = "stdin";
			pipin++;
			if (!oflag)
				cat = 1;
		}
		else
			switch (entry->fts_info) {
			case FTS_D:
				if (!recurse) {
					warnx("%s is a directory: ignored",
					    infile);
					fts_set(ftsp, entry, FTS_SKIP);
				}
				continue;
			case FTS_DP:
				continue;
			case FTS_NS:
				/*
				 * If file does not exist and has no suffix,
				 * tack on the default suffix and try that.
				 */
				if (entry->fts_errno == ENOENT) {
					p = strrchr(entry->fts_accpath, '.');
					if ((p == NULL ||
					    strcmp(p, suffix) != 0) &&
					    snprintf(_infile, sizeof(_infile),
					    "%s%s", infile, suffix) <
					    sizeof(_infile) &&
					    stat(_infile, entry->fts_statp) ==
					    0 &&
					    S_ISREG(entry->fts_statp->st_mode)) {
						infile = _infile;
						break;
					}
				}
			case FTS_ERR:
			case FTS_DNR:
				warnx("%s: %s", infile,
				    strerror(entry->fts_errno));
				rc = rc ? rc : WARNING;
				continue;
			default:
				if (!S_ISREG(entry->fts_statp->st_mode) &&
				    !(S_ISLNK(entry->fts_statp->st_mode) &&
				    cat)) {
					warnx("%s not a regular file%s",
					    infile, cat ? "" : ": unchanged");
					rc = rc ? rc : WARNING;
					continue;
				}
				break;
			}

		if (!decomp && !pipin && (s = check_suffix(infile)) != NULL) {
			warnx("%s already has %s suffix -- unchanged",
			    infile, s);
			rc = rc ? rc : WARNING;
			continue;
		}

		if (!oflag) {
			if (cat)
				strlcpy(outfile, "stdout", sizeof(outfile));
			else if (decomp) {
				if (set_outfile(infile, outfile,
				    sizeof outfile) == NULL) {
					if (!recurse) {
						warnx("%s: unknown suffix: "
						    "ignored", infile);
						rc = rc ? rc : WARNING;
					}
					continue;
				}
			} else {
				if (snprintf(outfile, sizeof(outfile),
				    "%s%s", infile, suffix) >= sizeof(outfile)) {
					warnx("%s%s: name too long",
					    infile, suffix);
					rc = rc ? rc : WARNING;
					continue;
				}
			}
		}

		if (verbose > 0 && !pipin && !list)
			fprintf(stderr, "%s:\t", infile);

		if (decomp)
			error = dodecompress(infile, outfile, entry->fts_statp);
		else
			error = docompress(infile, outfile, method, bits, entry->fts_statp);

		switch (error) {
		case SUCCESS:
			if (!cat && !testmode) {
				if (!pipin && unlink(infile) && verbose >= 0)
					warn("input: %s", infile);
			}
			break;
		case WARNING:
			rc = rc ? rc : WARNING;
			break;
		default:
			rc = FAILURE;
			break;
		}
	}
	if (list)
		list_stats(NULL, NULL, NULL);
	fts_close(ftsp);
	exit(rc);
}

int
docompress(const char *in, char *out, const struct compressor *method,
    int bits, struct stat *sb)
{
#ifndef SMALL
	u_char buf[Z_BUFSIZE];
	char *name;
	int error, ifd, ofd, oreg;
	void *cookie;
	ssize_t nr;
	u_int32_t mtime;
	struct z_info info;
	struct stat osb;

	mtime = 0;
	oreg = 0;
	error = SUCCESS;
	name = NULL;
	cookie  = NULL;

	if (pipin)
		ifd = dup(STDIN_FILENO);
	else
		ifd = open(in, O_RDONLY);
	if (ifd < 0) {
		if (verbose >= 0)
			warn("%s", in);
		return (FAILURE);
	}

	if (cat)
		ofd = dup(STDOUT_FILENO);
	else {
		if (stat(out, &osb) == 0) {
			oreg = S_ISREG(osb.st_mode);
			if (!force && oreg && !permission(out)) {
				(void) close(ifd);
				return (WARNING);
			}
		}
		ofd = open(out, O_WRONLY|O_CREAT|O_TRUNC, S_IWUSR);
	}
	if (ofd < 0) {
		if (verbose >= 0)
			warn("%s", out);
		(void) close(ifd);
		return (FAILURE);
	}

	if (method != M_COMPRESS && !force && isatty(ofd)) {
		if (verbose >= 0)
			warnx("%s: won't write compressed data to terminal",
			    out);
		(void) close(ofd);
		(void) close(ifd);
		return (FAILURE);
	}

	if (!pipin && storename) {
		name = basename(in);
		mtime = (u_int32_t)sb->st_mtime;
	}
	if ((cookie = method->wopen(ofd, name, bits, mtime)) == NULL) {
		if (verbose >= 0)
			warn("%s", out);
		if (oreg)
			(void) unlink(out);
		(void) close(ofd);
		(void) close(ifd);
		return (FAILURE);
	}

	while ((nr = read(ifd, buf, sizeof(buf))) > 0)
		if (method->write(cookie, buf, nr) != nr) {
			if (verbose >= 0)
				warn("%s", out);
			error = FAILURE;
			break;
		}

	if (!error && nr < 0) {
		if (verbose >= 0)
			warn("%s", in);
		error = FAILURE;
	}

	if (method->close(cookie, &info, out, sb)) {
		if (!error && verbose >= 0)
			warn("%s", out);
		error = FAILURE;
	}

	if (close(ifd)) {
		if (!error && verbose >= 0)
			warn("%s", in);
		error = FAILURE;
	}

	if (!force && !cat && info.total_out >= info.total_in) {
		if (verbose > 0)
			fprintf(stderr, "file would grow; left unmodified\n");
		(void) unlink(out);
		error = WARNING;
	}

	if (error) {
		if (oreg)
			(void) unlink(out);
	} else if (verbose > 0)
		verbose_info(out, info.total_out, info.total_in, info.hlen);

	return (error);
#else
	warnx("compression not supported");
	return (FAILURE);
#endif
}

const struct compressor *
check_method(int fd)
{
	const struct compressor *method;
	u_char magic[2];

	if (read(fd, magic, sizeof(magic)) != 2)
		return (NULL);
	for (method = &c_table[0]; method->name != NULL; method++) {
		if (magic[0] == method->magic[0] &&
		    magic[1] == method->magic[1])
			return (method);
	}
#ifndef SMALL
	if (force && cat) {
		null_magic[0] = magic[0];
		null_magic[1] = magic[1];
		return (&null_method);
	}
#endif /* SMALL */
	return (NULL);
}

int
dodecompress(const char *in, char *out, struct stat *sb)
{
	const struct compressor *method;
	u_char buf[Z_BUFSIZE];
	char oldname[PATH_MAX];
	int error, oreg, ifd, ofd;
	void *cookie;
	ssize_t nr;
	struct z_info info;
	struct stat osb;

	oreg = 0;
	error = SUCCESS;
	cookie = NULL;

	if (pipin)
		ifd = dup(STDIN_FILENO);
	else
		ifd = open(in, O_RDONLY);
	if (ifd < 0) {
		if (verbose >= 0)
			warn("%s", in);
		return -1;
	}

	if (!force && isatty(ifd)) {
		if (verbose >= 0)
			warnx("%s: won't read compressed data from terminal",
			    in);
		close (ifd);
		return -1;
	}

	if ((method = check_method(ifd)) == NULL) {
		if (verbose >= 0)
			warnx("%s: unrecognized file format", in);
		close (ifd);
		return -1;
	}

	/* XXX - open constrains outfile to MAXPATHLEN so this is safe */
	oldname[0] = '\0';
	if ((cookie = method->ropen(ifd, oldname, 1)) == NULL) {
		if (verbose >= 0)
			warn("%s", in);
		close (ifd);
		return (FAILURE);
	}
	if (storename && oldname[0] != '\0') {
		char *cp = strrchr(out, '/');
		if (cp != NULL) {
			*(cp + 1) = '\0';
			strlcat(out, oldname, PATH_MAX);
		} else
			strlcpy(out, oldname, PATH_MAX);
		cat = 0;			/* XXX should -c override? */
	}

	if (testmode)
		ofd = -1;
	else {
		if (cat)
			ofd = dup(STDOUT_FILENO);
		else {
			if (stat(out, &osb) == 0) {
				oreg = S_ISREG(osb.st_mode);
				if (!force && oreg && !permission(out)) {
					(void) close(ifd);
					return (WARNING);
				}
			}
			ofd = open(out, O_WRONLY|O_CREAT|O_TRUNC, S_IWUSR);
		}
		if (ofd < 0) {
			if (verbose >= 0)
				warn("%s", in);
			method->close(cookie, NULL, NULL, NULL);
			return (FAILURE);
		}
	}

	while ((nr = method->read(cookie, buf, sizeof(buf))) > 0) {
		if (ofd != -1 && write(ofd, buf, nr) != nr) {
			if (verbose >= 0)
				warn("%s", out);
			error = FAILURE;
			break;
		}
	}

	if (!error && nr < 0) {
		if (verbose >= 0)
			warnx("%s: %s", in,
			    errno == EINVAL ? "crc error" : strerror(errno));
		error = errno == EINVAL ? WARNING : FAILURE;
	}

	if (method->close(cookie, &info, NULL, NULL)) {
		if (!error && verbose >= 0)
			warnx("%s", in);
		error = FAILURE;
	}
	if (storename && !cat) {
		if (info.mtime != 0) {
			sb->st_mtimespec.tv_sec =
			    sb->st_atimespec.tv_sec = info.mtime;
			sb->st_mtimespec.tv_nsec =
			    sb->st_atimespec.tv_nsec = 0;
		} else
			storename = 0;		/* no timestamp to restore */
	}
	if (error == SUCCESS)
		setfile(out, ofd, sb);

	if (ofd != -1 && close(ofd)) {
		if (!error && verbose >= 0)
			warn("%s", out);
		error = FAILURE;
	}

	if (!error) {
		if (list) {
			if (info.mtime == 0)
				info.mtime = (u_int32_t)sb->st_mtime;
			list_stats(out, method, &info);
		} else if (verbose > 0) {
			verbose_info(out, info.total_in, info.total_out,
			    info.hlen);
		}
	}

	/* On error, clean up the file we created but preserve errno. */
	if (error && oreg)
		unlink(out);

	return (error);
}

void
setfile(const char *name, int fd, struct stat *fs)
{
	struct timespec ts[2];

	if (name == NULL || cat || testmode)
		return;

	/*
	 * If input was a pipe we don't have any info to restore but we
	 * must set the mode since the current mode on the file is 0200.
	 */
	if (pipin) {
		mode_t mask = umask(022);
		fchmod(fd, DEFFILEMODE & ~mask);
		umask(mask);
		return;
	}

	/*
	 * Changing the ownership probably won't succeed, unless we're root
	 * or POSIX_CHOWN_RESTRICTED is not set.  Set uid/gid bits are not
	 * allowed.
	 */
	fs->st_mode &= ACCESSPERMS;
	if (fchown(fd, fs->st_uid, fs->st_gid)) {
		if (errno != EPERM)
			warn("fchown: %s", name);
		fs->st_mode &= ~(S_ISUID|S_ISGID);
	}
	if (fchmod(fd, fs->st_mode))
		warn("fchmod: %s", name);

	if (fs->st_flags && fchflags(fd, fs->st_flags))
		warn("fchflags: %s", name);

	ts[0] = fs->st_atim;
	ts[1] = fs->st_mtim;
	if (futimens(fd, ts))
		warn("futimens: %s", name);
}

int
permission(const char *fname)
{
	int ch, first;

	if (!isatty(fileno(stderr)))
		return (0);
	(void)fprintf(stderr, "overwrite %s? ", fname);
	first = ch = getchar();
	while (ch != '\n' && ch != EOF)
		ch = getchar();
	return (first == 'y');
}

/*
 * Check infile for a known suffix and return the suffix portion or NULL.
 */
const char *
check_suffix(const char *infile)
{
	int i;
	char *suf, *sep, *separators = ".-_";
	static char *suffixes[] = { "Z", "gz", "z", "tgz", "taz", NULL };

	for (sep = separators; *sep != '\0'; sep++) {
		if ((suf = strrchr(infile, *sep)) == NULL)
			continue;
		suf++;

		for (i = 0; suffixes[i] != NULL; i++) {
			if (strcmp(suf, suffixes[i]) == 0)
				return (suf - 1);
		}
	}
	return (NULL);
}

/*
 * Set outfile based on the suffix.  In most cases we just strip
 * off the suffix but things like .tgz and .taz are special.
 */
char *
set_outfile(const char *infile, char *outfile, size_t osize)
{
	const char *s;
	char *cp;

	if ((s = check_suffix(infile)) == NULL)
		return (NULL);

	(void)strlcpy(outfile, infile, osize);
	cp = outfile + (s - infile) + 1;
	/*
	 * Convert tgz and taz -> tar, else drop the suffix.
	 */
	if (strcmp(cp, "tgz") == 0) {
		cp[1] = 'a';
		cp[2] = 'r';
	} else if (strcmp(cp, "taz") == 0)
		cp[2] = 'r';
	else
		cp[-1] = '\0';
	return (outfile);
}

/*
 * Print output for the -l option.
 */
void
list_stats(const char *name, const struct compressor *method,
    struct z_info *info)
{
	static off_t compressed_total, uncompressed_total, header_total;
	static u_int nruns;
	char *timestr;

	if (nruns == 0) {
		if (verbose >= 0) {
			if (verbose > 0)
				fputs("method  crc      date   time  ", stdout);
			puts("compressed  uncompressed  ratio  uncompressed_name");
		}
	}
	nruns++;

	if (name != NULL) {
		if (verbose > 0) {
			time_t t = info->mtime;		/* XXX 32 bit mtime */

			timestr = ctime(&t) + 4;
			timestr[12] = '\0';
			if (timestr[4] == ' ')
				timestr[4] = '0';
			printf("%-7.7s %08x %s ", method->name, info->crc,
			    timestr);
		}
		printf("%10lld    %10lld  %4.1f%%  %s\n",
		    (long long)(info->total_in + info->hlen),
		    (long long)info->total_out,
		    ((long long)info->total_out - (long long)info->total_in) *
		    100.0 / info->total_out, name);
		compressed_total += info->total_in;
		uncompressed_total += info->total_out;
		header_total += info->hlen;
	} else if (verbose >= 0) {
		if (nruns < 3)		/* only do totals for > 1 files */
			return;
		if (verbose > 0)
			fputs("                              ", stdout);
		printf("%10lld    %10lld  %4.1f%%  (totals)\n",
		    (long long)(compressed_total + header_total),
		    (long long)uncompressed_total,
		    (uncompressed_total - compressed_total) *
		    100.0 / uncompressed_total);
	}
}

void
verbose_info(const char *file, off_t compressed, off_t uncompressed,
    u_int32_t hlen)
{
	if (testmode) {
		fputs("OK\n", stderr);
		return;
	}
	if (!pipin) {
		fprintf(stderr, "\t%4.1f%% -- replaced with %s\n",
		    (uncompressed - compressed) * 100.0 / uncompressed, file);
	}
	compressed += hlen;
	fprintf(stderr, "%lld bytes in, %lld bytes out\n",
	    (long long)(decomp ? compressed : uncompressed),
	    (long long)(decomp ? uncompressed : compressed));
}

__dead void
usage(int status)
{
	const bool gzip = (__progname[0] == 'g');

	switch (pmode) {
	case MODE_COMP:
		fprintf(stderr, "usage: %s [-123456789cdf%sh%slNnOqrt%sv] "
		    "[-b bits] [-o filename] [-S suffix]\n"
		    "       %*s [file ...]\n", __progname,
		    !gzip ? "g" : "", gzip ? "L" : "", gzip ? "V" : "",
		    (int)strlen(__progname), "");
		break;
	case MODE_DECOMP:
		fprintf(stderr, "usage: %s [-cfh%slNnqrt%sv] [-o filename] "
		    "[file ...]\n", __progname,
		    gzip ? "L" : "", gzip ? "V" : "");
		break;
	case MODE_CAT:
		fprintf(stderr, "usage: %s [-f%shqr] [file ...]\n",
		    __progname, gzip ? "" : "g");
		break;
	}
	exit(status);
}
@


1.93
log
@the SMALL code made a half hearted effort to exclude compression code
but some of the write code remained. shuffle things around a bit to make
the exclusion more complete.
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.92 2016/09/03 11:41:10 tedu Exp $	*/
d551 1
a551 1
		if ((method->write)(cookie, buf, nr) != nr) {
d564 1
a564 1
	if ((method->close)(cookie, &info, out, sb)) {
d696 1
a696 1
			(method->close)(cookie, NULL, NULL, NULL);
d701 1
a701 1
	while ((nr = (method->read)(cookie, buf, sizeof(buf))) > 0) {
d717 1
a717 1
	if ((method->close)(cookie, &info, NULL, NULL)) {
@


1.92
log
@start pulling apart some function pointers that take too many parameters
because of excessive code sharing. compression and decompression are not
entirely similar, they should share less.
ok joerg millert
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.91 2016/07/14 08:31:18 semarie Exp $	*/
d64 2
a66 1
	int (*read)(void *, char *, int);
d68 1
d80 2
a82 1
		gz_read,
d84 1
d97 1
a98 1
		zread,
d115 1
a116 1
	null_read,
@


1.91
log
@make several program to use "chown" promise.

it allows chown(2) call to change the user or group on a file.

- usr.bin/compress : aka gzip
- usr.bin/mg : open a file for writing
- usr.bin/sed : inplace editing
- usr.bin/sort : if outfile equals one of the input files

ok deraadt@@ tb@@

(and a reminder from Remi Locherer)

warning: in order to use it, you must have a recent kernel with the new
promise.
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.90 2015/10/17 21:34:07 naddy Exp $	*/
d63 2
a64 1
	void *(*open)(int, const char *, char *, int, u_int32_t, int);
d77 2
a78 1
		gz_open,
d92 2
a93 1
		z_open,
a98 8
#if 0
#define M_LZH (&c_table[2])
  { "lzh", ".lzh", "\037\240", lzh_open, lzh_read, lzh_write, lzh_close },
#define M_ZIP (&c_table[3])
  { "zip", ".zip", "PK", zip_open, zip_read, zip_write, zip_close },
#define M_PACK (&c_table[4])
  { "pack", ".pak", "\037\036", pak_open, pak_read, pak_write, pak_close },
#endif
d110 2
a111 1
	null_open,
d122 1
a122 2
int dodecompress(const char *, char *, const struct compressor *,
    int, struct stat *);
d448 4
a451 2
		error = (decomp ? dodecompress : docompress)
		    (infile, outfile, method, bits, entry->fts_statp);
d481 1
a481 1
	int error, ifd, ofd, flags, oreg;
d489 1
a489 1
	flags = oreg = 0;
d536 1
a536 1
	if ((cookie = (*method->open)(ofd, "w", name, bits, mtime, flags)) == NULL) {
d616 1
a616 2
dodecompress(const char *in, char *out, const struct compressor *method,
    int bits, struct stat *sb)
d618 1
d658 1
a658 1
	if ((cookie = (*method->open)(ifd, "r", oldname, bits, 0, 1)) == NULL) {
@


1.90
log
@Tighten pledge: We only write to stdio and never to any files if
in cat mode (-c, zcat), or in test mode (-t), or if there are no
file arguments and there is no -o outfile.  Due to fts(3) we require
rpath even for compress <in >out.

"seems sound" deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.89 2015/10/09 01:37:07 deraadt Exp $	*/
d170 1
a170 1
	if (pledge("stdio rpath wpath cpath fattr", NULL) == -1)
@


1.89
log
@Change all tame callers to namechange to pledge(2).
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.88 2015/10/04 16:50:29 deraadt Exp $	*/
d334 4
@


1.88
log
@Also needs "rpath" for some circumstances.
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.87 2015/10/03 04:19:14 deraadt Exp $	*/
d170 2
a171 2
	if (tame("stdio rpath wpath cpath fattr", NULL) == -1)
		err(1, "tame");
@


1.87
log
@gzip can use tame "stdio wpath cpath fattr".  this blocks a lot of
system behaviours such as forking, execve, sockets, etc.

in theory this extended by parsing the arguments first, and creating
the whitepathlist. the pathlist probably needs to be directory-oriented,
rather than exact path of files, because a gzip file may specify the
filename it wants (and that won't be available until it is opened, and
partially parsed).  anyone want to give this a try?

gzip was an early goal for capsicum.  who is running a capsicum gzip?
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.86 2015/08/30 21:06:24 deraadt Exp $	*/
d170 1
a170 1
	if (tame("stdio wpath cpath fattr", NULL) == -1)
@


1.86
log
@Ignore setuid/setgid settings from a compress/gzip file; original CSRG
code.  Found by trondd exercising coverage of tame in gzip.
ok guenther millert kettenis
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.85 2015/06/25 02:04:08 uebayasi Exp $	*/
d169 3
@


1.85
log
@Put fts_close() where missing.

Not bugs in short-lived commands that call exit() -> _exit() immediately,
but for idempotency.

Originally found in ls(1) by Valgrind.  Changes for other commands are
from deraadt@@.  Reviewed by me, tested in snapshots.

OK deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d771 2
a772 3
	 * or POSIX_CHOWN_RESTRICTED is not set.  Set uid/gid before setting
	 * the mode; current BSD behavior is to remove all setuid bits on
	 * chown.  If chown fails, lose setuid/setgid bits.
d774 1
a774 1
	fs->st_mode &= S_ISUID|S_ISGID|S_IRWXU|S_IRWXG|S_IRWXO;
@


1.84
log
@Preserve times to nanosecond precision instead of just microsecond.
Prefer to set attributes by fd for regular files, and not follwing
symlinks for others.

ok brynet@@ millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.83 2015/01/16 06:40:06 deraadt Exp $	*/
d466 1
a466 1

@


1.83
log
@Replace <sys/param.h> with <limits.h> and other less dirty headers where
possible.  Annotate <sys/param.h> lines with their current reasons.  Switch
to PATH_MAX, NGROUPS_MAX, HOST_NAME_MAX+1, LOGIN_NAME_MAX, etc.  Change
MIN() and MAX() to local definitions of MINIMUM() and MAXIMUM() where
sensible to avoid pulling in the pollution.  These are the files confirmed
through binary verification.
ok guenther, millert, doug (helped with the verification protocol)
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.82 2014/10/08 03:59:11 doug Exp $	*/
d753 1
a753 1
	struct timeval tv[2];
d787 4
a790 4
	TIMESPEC_TO_TIMEVAL(&tv[0], &fs->st_atimespec);
	TIMESPEC_TO_TIMEVAL(&tv[1], &fs->st_mtimespec);
	if (futimes(fd, tv))
		warn("futimes: %s", name);
@


1.82
log
@userland reallocarray audit.

Replace malloc() and realloc() calls that may have integer overflow in the
multiplication of the arguments with reallocarray().

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.81 2014/01/27 17:13:10 millert Exp $	*/
a32 1
#include <sys/param.h>
d46 1
d167 1
a167 1
	char outfile[MAXPATHLEN], _infile[MAXPATHLEN], suffix[16];
d616 1
a616 1
	char oldname[MAXPATHLEN];
d664 1
a664 1
			strlcat(out, oldname, MAXPATHLEN);
d666 1
a666 1
			strlcpy(out, oldname, MAXPATHLEN);
@


1.81
log
@Remove the no-op flags -L and -V from compress(1), these options
come from GNU zip and they were never in compress(1) until we added
gzip(1) support to it.  Also remove -g flag from gzip(1) as it is
non-standard and only makes sense in compress(1).
Joint work with jmc@@ and sobrado@@.  OK jmc@@, sobrado@@
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.80 2013/04/17 17:43:55 deraadt Exp $	*/
d216 2
a217 2
				nargv = realloc(nargv,
				    (argc + argc_extra + 1) * sizeof(char *));
@


1.80
log
@zlib info header is 32-bit; handle for localtime() call; ok millert
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.79 2012/09/30 14:50:38 millert Exp $	*/
d44 1
d57 6
a62 3
	char *name;
	char *suffix;
	u_char *magic;
d69 12
a80 1
  { "deflate", ".gz", "\037\213", gz_open, gz_read, gz_write, gz_close },
d83 12
a94 1
  { "compress", ".Z", "\037\235", z_open,  zread,   zwrite,   z_close },
d108 12
a119 2
const struct compressor null_method =
{ "null", ".nul", "XX", null_open, null_read, null_write, null_close };
d165 1
a165 1
	const char *s;
a168 5
	static const char *optstr[3] = {
		"123456789ab:cdfghLlNnOo:qrS:tVv",
		"cfhlNno:qrtVv",
		"fghqr"
	};
d177 1
a177 1
	} else
d183 2
d232 2
a233 1
	while ((ch = getopt_long(argc, argv, optstr[pmode], longopts, NULL)) != -1)
d931 2
d935 1
a935 1
		fprintf(stderr, "usage: %s [-123456789cdfghLlNnOqrtVv] "
d937 3
a939 2
		    "       %*s [file ...]\n",
		    __progname, (int)strlen(__progname), "");
d942 3
a944 2
		fprintf(stderr, "usage: %s [-cfhlNnqrtVv] [-o filename] "
		    "[file ...]\n", __progname);
d947 2
a948 1
		fprintf(stderr, "usage: %s [-fghqr] [file ...]\n", __progname);
@


1.79
log
@When outputting to stdout and compressing would grow the file, exit
normally instead of with a value of 2.  Also avoids unlinking the
file "stdout" in the current directory in this case.
OK miod@@ sthen@@ henning@@ beck@@
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.78 2011/09/22 10:41:04 deraadt Exp $	*/
d846 3
a848 1
			timestr = ctime(&info->mtime) + 4;
@


1.78
log
@Remove the rcsid which were intentionally skipped in the "purge of 2009"
because the -V command printed them... gut the -V (and -L, while there)
to be silent.
ok miod jsg
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.77 2011/03/05 20:12:42 millert Exp $	*/
d534 1
a534 1
	if (!force && info.total_out >= info.total_in) {
@


1.77
log
@Fix potential crash when GZIP variable set and more than 512 command
line args specified.  Closes PR 6573.  OK deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.76 2010/07/28 23:52:01 millert Exp $	*/
d3 29
a31 38
#ifndef SMALL
static const char copyright[] =
"@@(#) Copyright (c) 1992, 1993\n\
	The Regents of the University of California.  All rights reserved.\n"
"Copyright (c) 1997-2002 Michael Shalayeff\n";
#endif

#ifndef SMALL
static const char license[] =
"\n"
" Redistribution and use in source and binary forms, with or without\n"
" modification, are permitted provided that the following conditions\n"
" are met:\n"
" 1. Redistributions of source code must retain the above copyright\n"
"    notice, this list of conditions and the following disclaimer.\n"
" 2. Redistributions in binary form must reproduce the above copyright\n"
"    notice, this list of conditions and the following disclaimer in the\n"
"    documentation and/or other materials provided with the distribution.\n"
" 3. Neither the name of the University nor the names of its contributors\n"
"    may be used to endorse or promote products derived from this software\n"
"    without specific prior written permission.\n"
"\n"
" THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR\n"
" IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n"
" OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.\n"
" IN NO EVENT SHALL THE AUTHOR OR HIS RELATIVES BE LIABLE FOR ANY DIRECT,\n"
" INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n"
" (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR\n"
" SERVICES; LOSS OF MIND, USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)\n"
" HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,\n"
" STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING\n"
" IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF\n"
" THE POSSIBILITY OF SUCH DAMAGE.\n";
#endif /* SMALL */

#ifndef SMALL
static const char main_rcsid[] = "$OpenBSD: main.c,v 1.76 2010/07/28 23:52:01 millert Exp $";
#endif
d200 1
a200 1
		switch(ch) {
a277 1
#ifndef SMALL
a278 3
			printf("%s\n%s\n", main_rcsid, gz_rcsid);
			printf("%s\n%s\n", z_rcsid, null_rcsid);
#endif
a282 1
#ifndef SMALL
a283 3
			fputs(copyright, stderr);
			fputs(license, stderr);
#endif
@


1.76
log
@Truncate output file when compressing.  OK deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.75 2009/04/18 18:21:54 naddy Exp $	*/
d39 1
a39 1
static const char main_rcsid[] = "$OpenBSD: main.c,v 1.75 2009/04/18 18:21:54 naddy Exp $";
d141 1
a141 2
	char *nargv[512];	/* some estimate based on ARG_MAX */
	int bits, ch, error, i, rc, cflag, oflag;
a181 1
	nargv[0] = NULL;
d183 2
a184 1
		char *last;
d186 20
a205 11
		nargv[0] = *argv++;
		for (i = 1, (p = strtok_r(p, " ", &last)); p != NULL;
		    (p = strtok_r(NULL, " ", &last)), i++)
			if (i < sizeof(nargv)/sizeof(nargv[1]) - argc - 1)
				nargv[i] = p;
			else
				errx(1, "GZIP is too long");
		argc += i - 1;
		while ((nargv[i++] = *argv++))
			;
		argv = nargv;
d316 3
a318 3
		if (nargv[0] == NULL)
			argv = nargv;
		/* XXX - make sure we don't oflow nargv in $GZIP case (millert) */
d320 1
a320 1
		argv[1] = NULL;
@


1.75
log
@allow -V (show version) in decompression mode; ok millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.74 2008/10/08 17:06:30 millert Exp $	*/
d39 1
a39 1
static const char main_rcsid[] = "$OpenBSD: main.c,v 1.74 2008/10/08 17:06:30 millert Exp $";
d485 1
a485 1
		ofd = open(out, O_WRONLY|O_CREAT, S_IWUSR);
@


1.74
log
@For "gunzip -N", the name stored in the gzip header has no directory,
so write the uncompressed file in the same directory we would use
were the -N option not specified.  Closes PR 5224
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.73 2008/07/27 13:15:31 sobrado Exp $	*/
d39 1
a39 1
static const char main_rcsid[] = "$OpenBSD: main.c,v 1.73 2008/07/27 13:15:31 sobrado Exp $";
d144 2
a145 2
		"123456789ab:cdfghlLnNOo:qrS:tvV",
		"cfhlNno:qrtv",
d912 1
a912 1
		fprintf(stderr, "usage: %s [-cfhlNnqrtv] [-o filename] "
@


1.73
log
@an enum specifier is more elegant than a set of #defines;
storing the program mode variable (pmode) as a global let us have
a more consistent prototype for usage().

changes suggested by pyr@@.

ok pyr@@
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.72 2008/07/05 21:00:38 sobrado Exp $	*/
d39 1
a39 1
static const char main_rcsid[] = "$OpenBSD: main.c,v 1.72 2008/07/05 21:00:38 sobrado Exp $";
d636 6
a641 1
		strlcpy(out, oldname, MAXPATHLEN);
@


1.72
log
@each utility must have its own usage and an unique set of options.

diff written by millert based on a previous one by me;
millert's diff has a much better style and adds support for different
sets of options for each utility.

ok millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.71 2008/02/25 16:53:55 millert Exp $	*/
d39 1
a39 1
static const char main_rcsid[] = "$OpenBSD: main.c,v 1.71 2008/02/25 16:53:55 millert Exp $";
d96 1
a96 1
__dead void usage(int, int);
d142 1
a142 1
	int bits, ch, error, i, rc, cflag, oflag, mode;
d149 1
a149 1
	bits = cflag = oflag = mode = 0;
d164 1
d168 1
a168 1
		mode = MODE_CAT;
d173 1
a173 1
			mode = MODE_DECOMP;
d200 1
a200 1
	while ((ch = getopt_long(argc, argv, optstr[mode], longopts, NULL)) != -1)
d299 1
a299 1
			usage(0, mode);
d302 1
a302 1
			usage(1, mode);
d897 1
a897 1
usage(int status, int mode)
d899 1
a899 1
	switch (mode) {
@


1.71
log
@For the -l flag, set testmode to 1 instead of incrementing it.  Fixes
a bogus error message problem when the -t and -l flags are used together.
OK miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.70 2007/04/04 13:29:45 millert Exp $	*/
d39 1
a39 1
static const char main_rcsid[] = "$OpenBSD: main.c,v 1.70 2007/04/04 13:29:45 millert Exp $";
d96 1
a96 1
__dead void usage(int);
a106 1
#define	OPTSTRING	"123456789ab:cdfghlLnNOo:qrS:tvV"
d142 6
a147 1
	int bits, ch, error, i, rc, cflag, oflag;
d149 1
a149 1
	bits = cflag = oflag = 0;
d167 1
d172 1
d199 1
a199 1
	while ((ch = getopt_long(argc, argv, OPTSTRING, longopts, NULL)) != -1)
d298 1
a298 1
			usage(0);
d301 1
a301 1
			usage(1);
d896 1
a896 1
usage(int status)
d898 15
a912 4
	fprintf(stderr,
	    "usage: %s [-123456789cdfghLlNnOqrtVv] [-b bits] [-o filename]\n"
	    "\t[-S suffix] [file ...]\n",
	    __progname);
@


1.70
log
@Rename "nosave" variable to "storename" in hopes of clarifying
the code a bit.  OK otto@@
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.69 2007/04/03 20:25:35 millert Exp $	*/
d39 1
a39 1
static const char main_rcsid[] = "$OpenBSD: main.c,v 1.69 2007/04/03 20:25:35 millert Exp $";
d237 1
a237 1
			testmode++;
@


1.69
log
@Fix PR 5417; gunzip should set the timestamp based on the
compressed file by default.  OK otto@@
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.68 2007/01/18 20:53:36 millert Exp $	*/
d39 1
a39 1
static const char main_rcsid[] = "$OpenBSD: main.c,v 1.68 2007/01/18 20:53:36 millert Exp $";
d61 1
a61 3
int pipin, force, verbose, testmode, list, nosave;
int savename, recurse;
int cat, decomp;
d146 1
a146 1
	nosave = -1;
d241 1
a241 1
			nosave = 1;
d244 1
a244 1
			nosave = 0;
d312 7
a318 2
	if (nosave == -1)
		nosave = decomp;
d496 1
a496 1
	if (!pipin && !nosave) {
d628 1
a628 1
	if (!nosave && oldname[0] != '\0') {
d677 1
a677 1
	if (!nosave && !cat) {
d684 1
a684 1
			nosave = 1;		/* no timestamp to restore */
@


1.68
log
@We don't want to use GZIP for compress.  Only examine GZIP environment
variable when invoked as gzip, gunzip, gzcat, etc.  OK otto@@
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.67 2006/12/01 08:14:53 otto Exp $	*/
d39 1
a39 1
static const char main_rcsid[] = "$OpenBSD: main.c,v 1.67 2006/12/01 08:14:53 otto Exp $";
d747 4
a750 6
	if (!nosave) {
		TIMESPEC_TO_TIMEVAL(&tv[0], &fs->st_atimespec);
		TIMESPEC_TO_TIMEVAL(&tv[1], &fs->st_mtimespec);
		if (futimes(fd, tv))
			warn("futimes: %s", name);
	}
@


1.67
log
@Fix two bugs: stdin is processed and the current working dir is not
readable and having a file named '-'. PR 5301 and 5302. Diff from Vadim
Vygonets, with some changes from me. ok millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.66 2006/03/13 14:49:59 millert Exp $	*/
d39 1
a39 1
static const char main_rcsid[] = "$OpenBSD: main.c,v 1.66 2006/03/13 14:49:59 millert Exp $";
d179 1
a179 1
	if ((p = getenv("GZIP")) != NULL) {
@


1.66
log
@Remove dependence on /dev/stdin and /dev/stdout
Deal correctly with compressing both stdin and regular files
OK jaredy@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.65 2005/07/22 08:38:46 jmc Exp $	*/
d39 1
a39 1
static const char main_rcsid[] = "$OpenBSD: main.c,v 1.65 2005/07/22 08:38:46 jmc Exp $";
d323 13
a335 22
		switch (entry->fts_info) {
		case FTS_D:
			if (!recurse) {
				warnx("%s is a directory: ignored",
				    infile);
				fts_set(ftsp, entry, FTS_SKIP);
			}
			continue;
		case FTS_DP:
			continue;
		case FTS_NS:
			/*
			 * If file does not exist and has no suffix,
			 * tack on the default suffix and try that.
			 */
			if (entry->fts_errno == ENOENT) {
				if (infile[0] == '-' && infile[1] == '\0') {
					infile = "stdin";
					pipin++;
					if (!oflag)
						cat = 1;
					break;
d337 21
a357 8
				p = strrchr(entry->fts_accpath, '.');
				if ((p == NULL || strcmp(p, suffix) != 0) &&
				    snprintf(_infile, sizeof(_infile), "%s%s",
				    infile, suffix) < sizeof(_infile) &&
				    stat(_infile, entry->fts_statp) == 0 &&
				    S_ISREG(entry->fts_statp->st_mode)) {
					infile = _infile;
					break;
d359 4
a362 11
			}
		case FTS_ERR:
		case FTS_DNR:
			warnx("%s: %s", infile, strerror(entry->fts_errno));
			rc = rc ? rc : WARNING;
			continue;
		default:
			if (!S_ISREG(entry->fts_statp->st_mode) &&
			    !(S_ISLNK(entry->fts_statp->st_mode) && cat)) {
				warnx("%s not a regular file%s",
				    infile, cat ? "" : ": unchanged");
d365 10
a375 2
			break;
		}
@


1.65
log
@sort synopsis and options list; sync usage() (as best we can);
help + ok jaredy@@
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.64 2005/07/11 14:16:47 millert Exp $	*/
d39 1
a39 1
static const char main_rcsid[] = "$OpenBSD: main.c,v 1.64 2005/07/11 14:16:47 millert Exp $";
a139 1
	struct stat osb;
d145 1
a145 1
	int bits, exists, oreg, ch, error, i, rc, oflag;
d147 1
a147 1
	oreg = exists = bits = oflag = 0;
d164 1
a164 1
		cat = 1;
d224 1
a224 1
			cat = 1;
d306 1
a306 1
		argv[0] = "/dev/stdin";
a307 11
		pipin++;
		if (!oflag)
			cat = 1;
	} else {
		for (i = 0; i < argc; i++) {
			if (argv[i][0] == '-' && argv[i][1] == '\0') {
				argv[i] = "/dev/stdin";
				pipin++;
				cat = 1;
			}
		}
d320 2
d338 17
a354 10
			/* XXX - is overwriting fts_statp legal? (millert) */
			if (entry->fts_errno == ENOENT &&
			    ((p = strrchr(entry->fts_accpath, '.')) == NULL ||
			    strcmp(p, suffix) != 0) &&
			    snprintf(_infile, sizeof(_infile), "%s%s", infile,
			    suffix) < sizeof(_infile) &&
			    stat(_infile, entry->fts_statp) == 0 &&
			    S_ISREG(entry->fts_statp->st_mode)) {
				infile = _infile;
				break;
d362 1
a362 1
			if (!S_ISREG(entry->fts_statp->st_mode) && !pipin &&
d379 4
a382 4
		if (cat)
			strlcpy(outfile, "/dev/stdout", sizeof outfile);
		else if (!oflag) {
			if (decomp) {
a402 10
		if (!testmode) {
			exists = !stat(outfile, &osb);
			if (!force && exists && S_ISREG(osb.st_mode) &&
			    !permission(outfile)) {
				rc = rc ? rc : WARNING;
				continue;
			}
			oreg = !exists || S_ISREG(osb.st_mode);
		}

a420 7
			if (oreg && unlink(outfile) && errno != ENOENT &&
			    verbose >= 0) {
				if (force)
					warn("output: %s", outfile);
				else
					err(1, "output: %s", outfile);
			}
d437 1
a437 1
	int error, ifd, ofd, flags;
d442 1
d445 1
a445 1
	flags = 0;
d450 5
a454 1
	if ((ifd = open(in, O_RDONLY)) < 0) {
d460 13
a472 1
	if ((ofd = open(out, O_WRONLY|O_CREAT, S_IWUSR)) < 0) {
d494 3
a496 1
			warn("%s", in);
d531 2
a532 1
		error = FAILURE;
d535 4
a538 1
	if (!error && verbose > 0)
d576 2
a577 1
	int error, ifd, ofd;
d581 1
d583 1
d587 5
a591 1
	if ((ifd = open(in, O_RDONLY)) < 0) {
d613 2
a614 2
	if ((cookie = (*method->open)(ifd, "r", nosave ? NULL : out,
	    bits, 0, 1)) == NULL) {
d620 4
d627 19
a645 5
	else if ((ofd = open(out, O_WRONLY|O_CREAT|O_TRUNC, S_IWUSR)) < 0) {
		if (verbose >= 0)
			warn("%s", in);
		(method->close)(cookie, NULL, NULL, NULL);
		return (FAILURE);
d669 1
a669 1
	if (!nosave) {
a676 3

		if (cat && strcmp(out, "/dev/stdout") != 0)
			cat = 0;		/* have a real output name */
d698 4
a835 2
		if (strcmp(name, "/dev/stdout") == 0)
			name += 5;
@


1.64
log
@Don't set timestamps created from stack garbage when compressing
from stdin.  Based on a patch from marc@@
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.63 2005/06/26 18:20:26 otto Exp $	*/
d39 1
a39 1
static const char main_rcsid[] = "$OpenBSD: main.c,v 1.63 2005/06/26 18:20:26 otto Exp $";
d860 2
a861 1
	    "usage: %s [-cdfghOqrtvV] [-b bits] [-S suffix] [-[1-9]] [file ...]\n",
@


1.63
log
@be a bit more carefull not writing to the stream after the timestamps
have been set. ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.62 2005/04/17 16:17:39 deraadt Exp $	*/
d39 1
a39 1
static const char main_rcsid[] = "$OpenBSD: main.c,v 1.62 2005/04/17 16:17:39 deraadt Exp $";
d471 1
a471 1
			warn("%s", out);
a683 7
	if (!pipin || !nosave) {
		TIMESPEC_TO_TIMEVAL(&tv[0], &fs->st_atimespec);
		TIMESPEC_TO_TIMEVAL(&tv[1], &fs->st_mtimespec);
		if (futimes(fd, tv))
			warn("futimes: %s", name);
	}

d712 7
@


1.62
log
@spacing
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.61 2005/04/17 16:07:16 hshoexer Exp $	*/
d39 1
a39 1
static const char main_rcsid[] = "$OpenBSD: main.c,v 1.61 2005/04/17 16:07:16 hshoexer Exp $";
d73 1
a73 1
	int (*close)(void *, struct z_info *);
a97 1
void setfile(const char *, int, struct stat *);
d517 1
a517 4
	if (error == SUCCESS)
		setfile(out, ofd, sb);

	if ((method->close)(cookie, &info)) {
d616 1
a616 1
		(method->close)(cookie, NULL);
d636 1
a636 4
	if (error == SUCCESS)
		setfile(out, ofd, sb);

	if ((method->close)(cookie, &info)) {
a640 1

d653 2
d681 1
a681 1
	if (cat || testmode)
@


1.61
log
@use correct functions names in warn()

ok deraadt millert
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.60 2005/04/14 18:28:27 deraadt Exp $	*/
d39 1
a39 1
static const char main_rcsid[] = "$OpenBSD: main.c,v 1.60 2005/04/14 18:28:27 deraadt Exp $";
d189 1
a189 1
			else {
a190 1
			}
d821 1
a821 1
				timestr);
@


1.60
log
@use f{chown,chmod,utimes,chflags} instead; done with hshoexer, ok otto mickey
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.59 2005/02/24 09:44:36 moritz Exp $	*/
d39 1
a39 1
static const char main_rcsid[] = "$OpenBSD: main.c,v 1.59 2005/02/24 09:44:36 moritz Exp $";
d695 1
a695 1
			warn("utimes: %s", name);
d718 1
a718 1
			warn("chown: %s", name);
d722 1
a722 1
		warn("chown: %s", name);
d725 1
a725 1
		warn("chflags: %s", name);
@


1.59
log
@remove docompress() completely in case of -DSMALL and
replace it with a better error message.

ok millert@@ henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.58 2005/02/07 08:37:28 otto Exp $	*/
d39 1
a39 1
static const char main_rcsid[] = "$OpenBSD: main.c,v 1.58 2005/02/07 08:37:28 otto Exp $";
d98 1
a98 1
void setfile(const char *, struct stat *);
d422 1
a422 1
			(infile, outfile, method, bits, entry->fts_statp);
a426 1
				setfile(outfile, entry->fts_statp);
d519 3
d641 3
d684 1
a684 1
setfile(const char *name, struct stat *fs)
d688 3
d694 1
a694 1
		if (utimes(name, tv))
d704 1
a704 1
		chmod(name, DEFFILEMODE & ~mask);
d716 1
a716 1
	if (chown(name, fs->st_uid, fs->st_gid)) {
d721 1
a721 1
	if (chmod(name, fs->st_mode))
d724 1
a724 1
	if (fs->st_flags && chflags(name, fs->st_flags))
@


1.58
log
@In list mode (which implies test mode), do not forget to initialize
uncompressed_name. Spotted by markus@@; ok hshoexer@@ millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.57 2005/01/27 12:58:22 otto Exp $	*/
d39 1
a39 1
static const char main_rcsid[] = "$OpenBSD: main.c,v 1.57 2005/01/27 12:58:22 otto Exp $";
d457 1
d542 4
@


1.57
log
@Compute compression ratio using signed arithmetic, since the compressed size
might be larger than the original, yielding negative percentages. Spotted by
markus@@

ok henning@@ hshoexer@@
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.56 2004/09/20 18:53:20 millert Exp $	*/
d39 1
a39 1
static const char main_rcsid[] = "$OpenBSD: main.c,v 1.56 2004/09/20 18:53:20 millert Exp $";
d386 1
a386 1
		else if (!oflag && !testmode) {
@


1.56
log
@Make "gunzip foo.bar" work when there is a foo.bar.gz file.
OK otto@@
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.55 2004/07/29 04:07:44 millert Exp $	*/
d39 1
a39 1
static const char main_rcsid[] = "$OpenBSD: main.c,v 1.55 2004/07/29 04:07:44 millert Exp $";
d814 1
a814 1
		    (info->total_out - info->total_in) *
@


1.55
log
@Don't set the output filename when in -t mode.  Avoids an error when
the input filename lacks a .gz.  OK mickey@@
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.54 2004/02/29 13:59:15 markus Exp $	*/
d39 1
a39 1
static const char main_rcsid[] = "$OpenBSD: main.c,v 1.54 2004/02/29 13:59:15 markus Exp $";
d352 2
a353 1
			    strchr(entry->fts_accpath, '.') == NULL &&
@


1.54
log
@don't stat(2) outfile in testmode; ok millert@@, miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.53 2004/01/22 18:50:39 millert Exp $	*/
d39 1
a39 1
static const char main_rcsid[] = "$OpenBSD: main.c,v 1.53 2004/01/22 18:50:39 millert Exp $";
d149 1
a149 2
	exists = 0;
	bits = oflag = 0;
d385 1
a385 1
		else if (!oflag) {
d407 1
a407 1
		if (!testmode)
d409 6
a414 4
		if (!force && exists && S_ISREG(osb.st_mode) &&
		    !permission(outfile)) {
			rc = rc ? rc : WARNING;
			continue;
a415 2

		oreg = !exists || S_ISREG(osb.st_mode);
@


1.53
log
@Make exit code for "unknown suffix" and "name too long" match GNU gzip.
Fixes an interaction with the perl CPAN module which checks the exit value.
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.52 2003/12/16 23:32:24 henning Exp $	*/
d39 1
a39 1
static const char main_rcsid[] = "$OpenBSD: main.c,v 1.52 2003/12/16 23:32:24 henning Exp $";
d149 1
d408 2
a409 1
		exists = !stat(outfile, &osb);
@


1.52
log
@do not implement -L (print copyright) with SMALL
186 bytes more bytes we can waste elsewhere
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.51 2003/12/16 23:23:50 henning Exp $	*/
d39 1
a39 1
static const char main_rcsid[] = "$OpenBSD: main.c,v 1.51 2003/12/16 23:23:50 henning Exp $";
d389 1
a389 1
					if (!recurse)
d392 2
d401 1
@


1.51
log
@really don't do -V #ifdef SMALL
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.50 2003/12/16 22:46:26 henning Exp $	*/
d3 1
d8 1
d39 1
a39 1
static const char main_rcsid[] = "$OpenBSD: main.c,v 1.50 2003/12/16 22:46:26 henning Exp $";
d286 1
a288 1
#ifndef SMALL
@


1.50
log
@do not include rcsids with -DSMALL and as it is meaningless then do not
implement -V then. following a discussion with millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.49 2003/12/16 18:38:01 henning Exp $	*/
d37 1
a37 1
static const char main_rcsid[] = "$OpenBSD: main.c,v 1.49 2003/12/16 18:38:01 henning Exp $";
d275 1
a277 1
#ifndef SMALL
@


1.49
log
@avoid name clash with newer libz; breaks on static archs
ok millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.48 2003/12/09 07:34:55 millert Exp $	*/
d36 2
a37 5
#ifndef lint
#if 0
static char sccsid[] = "@@(#)compress.c	8.2 (Berkeley) 1/7/94";
#else
static const char main_rcsid[] = "$OpenBSD: main.c,v 1.48 2003/12/09 07:34:55 millert Exp $";
a38 1
#endif /* not lint */
@


1.48
log
@Fixes based on a patch from Moritz Jodeit; mickey@@ OK
o break out of inflate() when we hit an error
o fix printf format #ifdef SMALL
o add version string of nullopen.c to -V output
o remove unnecessary initializations to 0 for variables cat and decomp
o beautify -l output to make it line up with the heading
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.47 2003/09/05 21:03:36 henning Exp $	*/
d40 1
a40 1
static const char main_rcsid[] = "$OpenBSD: main.c,v 1.47 2003/09/05 21:03:36 henning Exp $";
d102 1
a102 1
int compress(const char *, char *, const struct compressor *,
d104 1
a104 1
int decompress(const char *, char *, const struct compressor *,
d418 1
a418 1
		error = (decomp ? decompress : compress)
d451 1
a451 1
compress(const char *in, char *out, const struct compressor *method,
d564 1
a564 1
decompress(const char *in, char *out, const struct compressor *method,
@


1.47
log
@KNF nit pointed out by theo
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.46 2003/09/05 20:41:48 henning Exp $	*/
d40 1
a40 1
static const char main_rcsid[] = "$OpenBSD: main.c,v 1.46 2003/09/05 20:41:48 henning Exp $";
d151 1
a151 1
	bits = cat = oflag = decomp = 0;
d280 1
a280 1
			printf("%s\n%s\n%s\n", main_rcsid,
d282 1
a282 1
			    z_rcsid,
a283 1
			    gz_rcsid);
a787 3
	if (name != NULL && strcmp(name, "/dev/stdout") == 0)
		name += 5;

d791 2
a792 2
				fputs("method  crc     date  time  ", stdout);
			puts("compressed  uncompr. ratio uncompressed_name");
d798 2
d803 4
a806 1
			printf("%.5s %08x %s ", method->name, info->crc, timestr);
d808 1
a808 1
		printf("%9lld %9lld  %4.1f%% %s\n",
d820 2
a821 2
			fputs("                            ", stdout);
		printf("%9lld %9lld  %4.1f%% (totals)\n",
@


1.47.2.1
log
@MFC:
Fix by millert@@

Make exit code for "unknown suffix" and "name too long" match GNU gzip.
Fixes an interaction with the perl CPAN module which checks the exit value.

ok deraadt@@ millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.47 2003/09/05 21:03:36 henning Exp $	*/
d40 1
a40 1
static const char main_rcsid[] = "$OpenBSD: main.c,v 1.47 2003/09/05 21:03:36 henning Exp $";
d392 1
a392 1
					if (!recurse) {
a394 2
						rc = rc ? rc : WARNING;
					}
a401 1
					rc = rc ? rc : WARNING;
@


1.46
log
@dont error out when the input file is a symlink AND output goes to stdout
inspired by PR3409, ckuethe@@ualberta.ca, tho fixed differently
matches gnu gzip behaviour

ok millert@@ tedu@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.45 2003/09/05 04:46:35 tedu Exp $	*/
d40 1
a40 1
static const char main_rcsid[] = "$OpenBSD: main.c,v 1.45 2003/09/05 04:46:35 tedu Exp $";
d369 2
a370 2
			if (!S_ISREG(entry->fts_statp->st_mode) && !pipin
			    && !(S_ISLNK(entry->fts_statp->st_mode) && cat)) {
@


1.45
log
@add a null compressor from canacar@@ that lets gzcat work with uncompressed
files.
also introduce SMALLness that removes null and Z compressors to save floppy
space.
ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.44 2003/08/05 18:22:17 deraadt Exp $	*/
d40 1
a40 1
static const char main_rcsid[] = "$OpenBSD: main.c,v 1.44 2003/08/05 18:22:17 deraadt Exp $";
d369 2
a370 1
			if (!S_ISREG(entry->fts_statp->st_mode) && !pipin) {
@


1.44
log
@spacing
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.43 2003/07/29 18:33:11 millert Exp $	*/
d8 1
d34 1
d40 1
a40 1
static const char main_rcsid[] = "$OpenBSD: main.c,v 1.43 2003/07/29 18:33:11 millert Exp $";
d77 4
a80 1
#define M_COMPRESS (&c_table[0])
d82 1
a82 2
#define M_DEFLATE (&c_table[1])
  { "deflate", ".gz", "\037\213", gz_open, gz_read, gz_write, gz_close },
d94 5
d114 1
d134 1
d159 3
d163 1
d253 1
d258 1
d281 4
a284 1
			    z_rcsid, gz_rcsid);
d291 1
d293 1
d553 7
@


1.43
log
@Instead of checking for "stdout" in decompress(), just do the check
in list_stats().  Looks cleaner and we don't have to rely on any
special flags being set.
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.42 2003/07/29 07:09:07 millert Exp $	*/
d38 1
a38 1
static const char main_rcsid[] = "$OpenBSD: main.c,v 1.42 2003/07/29 07:09:07 millert Exp $";
d514 1
a514 1
	
d811 1
a811 1
	fprintf(stderr, "%lld bytes in, %lld bytes out\n", 
@


1.42
log
@Check cat, not pipin when deciding whether or not to make use
"stdout" as the filename in -l mode.  Fixes "gzip -lN < foo.gz"
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.41 2003/07/27 19:04:22 millert Exp $	*/
d38 1
a38 1
static const char main_rcsid[] = "$OpenBSD: main.c,v 1.41 2003/07/27 19:04:22 millert Exp $";
d631 1
a631 1
			list_stats(cat ? "stdout" : out, method, &info);
d758 3
@


1.41
log
@Return FAILURE for "file would grow" case so the .gz file gets removed.
Problem noticed by otto@@
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.40 2003/07/25 20:10:53 millert Exp $	*/
d38 1
a38 1
static const char main_rcsid[] = "$OpenBSD: main.c,v 1.40 2003/07/25 20:10:53 millert Exp $";
d631 1
a631 1
			list_stats(pipin ? "stdout" : out, method, &info);
@


1.40
log
@o deal with the case where -N was specified but no saved mtime in the gz file
o a filename in the header should turn off cat mode if -N
o make setmode() be smart about pipin and not set outfile based on /dev/stdin.
mickey@@ OK
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.37 2003/07/17 20:06:01 millert Exp $	*/
d38 1
a38 1
static const char main_rcsid[] = "$OpenBSD: main.c,v 1.37 2003/07/17 20:06:01 millert Exp $";
d509 1
a509 1
		error = WARNING;
@


1.39
log
@Previously, "cat" mode (ie: zcat) was set if no input file was specified,
and input was read from the standard input.  However, if the -o option
is specified, we don't need (or want) cat mode since the user has told
us where the output should go.
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.38 2003/07/18 20:43:18 millert Exp $	*/
d38 1
a38 1
static const char main_rcsid[] = "$OpenBSD: main.c,v 1.38 2003/07/18 20:43:18 millert Exp $";
d609 10
a618 2
		sb->st_mtimespec.tv_sec = info.mtime;
		sb->st_mtimespec.tv_nsec = 0;
d646 6
a651 1
	fs->st_mode &= S_ISUID|S_ISGID|S_IRWXU|S_IRWXG|S_IRWXO;
d653 10
a662 4
	TIMESPEC_TO_TIMEVAL(&tv[0], &fs->st_atimespec);
	TIMESPEC_TO_TIMEVAL(&tv[1], &fs->st_mtimespec);
	if (utimes(name, tv))
		warn("utimes: %s", name);
d670 1
@


1.38
log
@Change "nosave" back into a boolean for improved grokability.
It is now initialized to -1 and, if the user did not specify
the -n or -N flags, is set equal to "decomp".  In other words,
unless overridden via -n/-N, it is false when compressing, and
true when decompressing (which is what we want).
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.37 2003/07/17 20:06:01 millert Exp $	*/
d38 1
a38 1
static const char main_rcsid[] = "$OpenBSD: main.c,v 1.37 2003/07/17 20:06:01 millert Exp $";
d293 2
a294 1
		cat = 1;
@


1.37
log
@o implement -l, -n and -N (including setting outfile + mtime)
o make -v behave like GNU gzip for compress/decompress stats
o write a full gzip header w/ mtime and file name
o for -t/-l just don't write data instead of writing to /dev/null
o exit code is now more consistent with GNU gzip
o a crc error on decompress no longer causes unlink(outfile)
mickey@@ OK
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.36 2003/07/15 19:01:46 millert Exp $	*/
d38 1
a38 1
static const char main_rcsid[] = "$OpenBSD: main.c,v 1.36 2003/07/15 19:01:46 millert Exp $";
d141 1
d236 1
a236 1
			nosave = -1;
d308 2
d467 1
a467 1
	if (!pipin && nosave <= 0) {
d568 1
a568 1
	if ((cookie = (*method->open)(ifd, "r", nosave < 0 ? out : NULL,
d607 1
a607 1
	if (nosave < 0) {
@


1.36
log
@Don't compress a file that already has a known compression prefix.
This matches GNU gzip behavior.
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.35 2003/07/14 18:57:31 millert Exp $	*/
d38 1
a38 1
static const char main_rcsid[] = "$OpenBSD: main.c,v 1.35 2003/07/14 18:57:31 millert Exp $";
d50 1
d63 1
a63 1
int bits, cat, decomp;
d70 1
a70 1
	void *(*open)(int, const char *, int, int);
d73 1
a73 1
	int (*close)(void *);
d76 1
a76 1
  { "compress", ".Z", "\037\235", z_open,  zread,   zwrite,   zclose },
d93 1
a93 1
int compress(const char *, const char *, const struct compressor *,
d95 1
a95 1
int decompress(const char *, const char *, const struct compressor *,
d97 1
a97 1
const struct compressor *check_method(int, struct stat *, const char *);
d100 2
d138 1
a138 1
	int exists, oreg, ch, error, i, rc, oflag;
d228 2
d232 1
a232 1
			nosave++;
d235 1
a235 1
			nosave = 0;	/* XXX not yet */
d310 1
a310 2
	/* XXX - set rc in cases where we "continue" below? */
	for (rc = 0; (entry = fts_read(ftsp)) != NULL;) {
d340 1
a340 1
			error = 1;
d346 1
d355 1
d359 1
a359 3
		if (testmode)
			strlcpy(outfile, _PATH_DEVNULL, sizeof outfile);
		else if (cat)
d382 2
a383 1
		    !permission(outfile))
d385 1
d389 1
a389 1
		if (verbose > 0)
d395 3
a397 9
		if (!error && !cat && !testmode && stat(outfile, &osb) == 0) {
			if (!force && !decomp &&
			    osb.st_size >= entry->fts_statp->st_size) {
				if (verbose > 0)
					fprintf(stderr, "file would grow; "
					    "left unmodified\n");
				error = 1;
				rc = rc ? rc : 2;
			} else {
d399 1
a399 2

				if (unlink(infile) && verbose >= 0)
a400 12

				if (verbose > 0) {
					u_int ratio;
					ratio = (1000 * osb.st_size)
					    / entry->fts_statp->st_size;
					fprintf(stderr, "%u", ratio / 10);
					if (ratio % 10)
						fprintf(stderr, ".%u",
						    ratio % 10);
					fputc('%', stderr);
					fputc(' ', stderr);
				}
d402 14
a416 10

		if (error > 0 && oreg && unlink(outfile) && errno != ENOENT &&
		    verbose >= 0) {
			if (force) {
				warn("output: %s", outfile);
				rc = 1;
			} else
				err(1, "output: %s", outfile);
		} else if (!error && verbose > 0)
			fputs("OK\n", stderr);
d418 2
d425 1
a425 1
compress(const char *in, const char *out, const struct compressor *method,
d429 2
a430 1
	int error, ifd, ofd;
d433 2
d436 4
a439 1
	error = 0;
d445 1
a445 1
		return (-1);
d452 1
a452 1
		return (-1);
d461 1
a461 1
		return (-1);
d464 5
a468 1
	if ((cookie = (*method->open)(ofd, "w", bits, 0)) == NULL) {
d473 1
a473 1
		return (-1);
d480 1
a480 1
			error++;
d487 1
a487 1
		error++;
d490 1
a490 1
	if ((method->close)(cookie)) {
d493 1
a493 1
		error++;
d499 1
a499 1
		error++;
d501 9
d515 1
a515 1
check_method(int fd, struct stat *sb, const char *out)
d531 1
a531 1
decompress(const char *in, const char *out, const struct compressor *method,
d538 1
d540 1
a540 1
	error = 0;
d557 1
a557 1
	if ((method = check_method(ifd, sb, out)) == NULL) {
d564 3
a566 1
	if ((cookie = (*method->open)(ifd, "r", bits, 1)) == NULL) {
a568 1
		error++;
d570 1
a570 1
		return -1;
d573 3
a575 1
	if ((ofd = open(out, O_WRONLY|O_CREAT|O_TRUNC, S_IWUSR)) < 0) {
d578 2
a579 2
		(method->close)(cookie);
		return -1;
d582 2
a583 2
	while ((nr = (method->read)(cookie, buf, sizeof(buf))) > 0)
		if (write(ofd, buf, nr) != nr) {
d586 1
a586 1
			error++;
d589 1
d595 1
a595 1
		error++;
d598 1
a598 1
	if ((method->close)(cookie)) {
d601 6
a606 1
		error++;
d609 1
a609 1
	if (close(ofd)) {
d612 12
a623 1
		error++;
d722 65
@


1.35
log
@Improved (and cleaner) suffix handling code.  Now "gunzip foo.tgz"
works as expected.  mickey@@ OK
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.34 2003/07/14 18:42:20 mickey Exp $	*/
d38 1
a38 1
static const char main_rcsid[] = "$OpenBSD: main.c,v 1.34 2003/07/14 18:42:20 mickey Exp $";
d97 2
a98 1
char *set_outfile(char *, char *, size_t);
d131 2
a132 1
	char *p, *s, *infile;
d164 1
a164 1
	if ((s = getenv("GZIP")) != NULL) {
d168 1
a168 1
		for (i = 1, (p = strtok_r(s, " ", &last)); p;
d347 6
d641 23
d668 1
a668 1
set_outfile(char *infile, char *outfile, size_t osize)
d670 4
a673 9
	int i;
	char *s;
	static char *suffixes[] = { ".Z", ".gz", ".z", ".tgz", ".taz",
				    "-Z", "-gz", "-z", "_Z", "_gz", "_z",
				    NULL };

	if ((s = strrchr(infile, '.')) == NULL &&
	    (s = strrchr(infile, '-')) == NULL &&
	    (s = strrchr(infile, '_')) == NULL)
d676 13
a688 19
	for (i = 0; suffixes[i] != NULL; i++) {
		if (strcmp(s, suffixes[i]) == 0) {
			(void)strlcpy(outfile, infile, osize);
			s = outfile + (s - infile);
			/*
			 * Convert .tgz and .taz -> .tar,
			 * else drop the suffix.
			 */
			if (strcmp(s, ".tgz") == 0) {
				s[2] = 'a';
				s[3] = 'r';
			} else if (strcmp(s, ".taz") == 0)
				s[3] = 'r';
			else
				s[0] = '\0';
			return (outfile);
		}
	}
	return (NULL);
@


1.34
log
@-t and implied -c due to piped in input is a legal combination of flags
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.33 2003/07/11 02:31:18 millert Exp $	*/
d38 1
a38 1
static const char main_rcsid[] = "$OpenBSD: main.c,v 1.33 2003/07/11 02:31:18 millert Exp $";
d97 1
d351 2
a352 10
				const struct compressor *m = method;

				if ((s = strrchr(infile, '.')) != NULL &&
				    strcmp(s, suffix) != 0) {
					for (m = &c_table[0];
					    m->name && strcmp(s, m->suffix);
					    m++)
						;
				}
				if (s == NULL || m->name == NULL) {
a357 3
				method = m;
				strlcpy(outfile, infile,
				    min(sizeof(outfile), (s - infile) + 1));
d630 39
@


1.33
log
@Move magic number checking into main.c and make it work when
decompressing from a pipe.  Currently assumes that magic numbers
are 2 bytes but this is relatively easy to change as needed in the
future.  Discussed w/ mickey@@
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.32 2003/07/08 00:30:12 mickey Exp $	*/
d38 1
a38 1
static const char main_rcsid[] = "$OpenBSD: main.c,v 1.32 2003/07/08 00:30:12 mickey Exp $";
d297 1
a297 1
	if (cat + testmode + oflag > 1)
@


1.32
log
@fix fd closing logicand close in gzopen(); found by wilfried@@ and millert@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.31 2003/06/30 03:42:05 millert Exp $	*/
d38 1
a38 1
static const char main_rcsid[] = "$OpenBSD: main.c,v 1.31 2003/06/30 03:42:05 millert Exp $";
d68 2
a69 2
	int (*check_header)(int, struct stat *, const char *);
	void *(*open)(int, const char *, int);
d75 1
a75 1
  { "compress", ".Z", z_check_header,  z_open,  zread,   zwrite,   zclose },
d77 1
a77 1
  { "deflate", ".gz", gz_check_header, gz_open, gz_read, gz_write, gz_close },
d80 1
a80 1
  { "lzh", ".lzh", lzh_check_header, lzh_open, lzh_read, lzh_write, lzh_close },
d82 1
a82 1
  { "zip", ".zip", zip_check_header, zip_open, zip_read, zip_write, zip_close },
d84 1
a84 1
  { "pack", ".pak",pak_check_header, pak_open, pak_read, pak_write, pak_close },
d467 1
a467 1
	if ((cookie = (*method->open)(ofd, "w", bits)) == NULL) {
d508 1
d510 8
a517 9
	for (method = &c_table[0];
	    method->name != NULL && !(*method->check_header)(fd, sb, out);
	    method++)
		;

	if (method->name == NULL)
		method = NULL;

	return (method);
d546 1
a546 1
	if (!pipin && (method = check_method(ifd, sb, out)) == NULL) {
d553 1
a553 1
	if ((cookie = (*method->open)(ifd, "r", bits)) == NULL) {
@


1.31
log
@Make usage() take the exit val are an argument and have the -h flag
use this to exit(0), not exit(1).  Some configure/install sqcripts
check for the existence of gzip by running "gzip -h" and checking
the subshell's exit value.  Noticed by naddy@@
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.30 2003/06/29 21:14:37 millert Exp $	*/
d38 1
a38 1
static const char main_rcsid[] = "$OpenBSD: main.c,v 1.30 2003/06/29 21:14:37 millert Exp $";
d454 1
d462 2
d467 7
a473 1
	if ((cookie = (*method->open)(ofd, "w", bits)) != NULL) {
d475 7
a481 8
		while ((nr = read(ifd, buf, sizeof(buf))) > 0)
			if ((method->write)(cookie, buf, nr) != nr) {
				if (verbose >= 0)
					warn("%s", out);
				error++;
				break;
			}
	}
d483 2
a484 2
	if (cookie == NULL || nr < 0) {
		if (!error && verbose >= 0)
d489 1
a489 1
	if (cookie == NULL || (method->close)(cookie)) {
a492 1
		(void) close(ofd);
d497 1
a497 1
			warn("%s", out);
d500 1
a500 1

d553 17
a569 2
	if ((cookie = (*method->open)(ifd, "r", bits)) != NULL) {
		if ((ofd = open(out, O_WRONLY|O_CREAT|O_TRUNC, S_IWUSR)) < 0) {
d571 3
a573 3
				warn("%s", in);
			(method->close)(cookie);
			return -1;
d576 5
a580 7
		while ((nr = (method->read)(cookie, buf, sizeof(buf))) > 0)
			if (write(ofd, buf, nr) != nr) {
				if (verbose >= 0)
					warn("%s", out);
				error++;
				break;
			}
d583 1
a583 1
	if (cookie == NULL || (method->close)(cookie) || nr < 0) {
d585 1
a585 2
			warnx("%s: %s", in,
			    errno == EINVAL ? "crc error" : strerror(errno));
a586 1
		close (ifd);
@


1.30
log
@Return EINVAL on crc failure for gzip and make the driver program
interpret this correctly.  Makes "gzip -t" more useful.  Discussed
with deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.29 2003/06/27 17:33:26 millert Exp $	*/
d38 1
a38 1
static const char main_rcsid[] = "$OpenBSD: main.c,v 1.29 2003/06/27 17:33:26 millert Exp $";
d91 1
a91 1
void usage(void);
d269 2
a270 1
		case '?':
d272 1
a272 1
			usage();
d624 2
a625 2
void
usage(void)
d628 1
a628 1
	    "usage: %s [-cdfgOqrtvV] [-b bits] [-S suffix] [-[1-9]] [file ...]\n",
d630 1
a630 1
	exit(1);
@


1.29
log
@Fix -t mode; it needs to set decomp=1 too
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.28 2003/06/23 19:35:31 millert Exp $	*/
d38 1
a38 1
static const char main_rcsid[] = "$OpenBSD: main.c,v 1.28 2003/06/23 19:35:31 millert Exp $";
d564 2
a565 1
			warn("%s", in);
@


1.28
log
@Fix a typo in my last commit and convert file "-" to /dev/stdin like
GNU gzip does.
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.27 2003/06/23 16:19:25 millert Exp $	*/
d38 1
a38 1
static const char main_rcsid[] = "$OpenBSD: main.c,v 1.27 2003/06/23 16:19:25 millert Exp $";
d251 1
@


1.27
log
@When trying to cat a non-file, say "foo not a regular file" instead of
"foo not a regular file: unchanged" since we never change the file
in cat mode.
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.26 2003/06/22 22:17:46 deraadt Exp $	*/
d38 1
a38 1
static const char main_rcsid[] = "$OpenBSD: main.c,v 1.26 2003/06/22 22:17:46 deraadt Exp $";
d283 8
d336 1
a336 1
				    cat ? "" : ": unchanged", infile);
@


1.26
log
@man page changes from jmc: use this as gzip too
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.25 2003/06/22 15:22:43 deraadt Exp $	*/
d38 1
a38 1
static const char main_rcsid[] = "$OpenBSD: main.c,v 1.25 2003/06/22 15:22:43 deraadt Exp $";
d327 2
a328 2
				warnx("%s not a regular file: unchanged",
				    infile);
@


1.25
log
@knf and ansi
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.24 2003/06/10 22:20:45 deraadt Exp $	*/
d38 1
a38 1
static const char main_rcsid[] = "$OpenBSD: main.c,v 1.24 2003/06/10 22:20:45 deraadt Exp $";
d617 1
a617 1
	    "usage: %s [-cdfghlnLOqrStvV] [-b <bits>] [-[0-9]] [file ...]\n",
@


1.24
log
@mostly ansi cleanup; pval ok
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.23 2003/06/04 04:55:58 deraadt Exp $	*/
d38 1
a38 1
static const char main_rcsid[] = "$OpenBSD: main.c,v 1.23 2003/06/04 04:55:58 deraadt Exp $";
d92 4
a95 2
int compress(const char *, const char *, const struct compressor *, int, struct stat *);
int decompress(const char *, const char *, const struct compressor *, int, struct stat *);
d386 1
a386 1
						     "left unmodified\n");
d402 1
a402 1
						        ratio % 10);
d450 1
a450 1
			      out);
d493 2
a494 2
	     method->name != NULL && !(*method->check_header)(fd, sb, out);
	     method++)
d524 1
a524 1
			      in);
@


1.23
log
@4 was deleted, should be 3
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.22 2003/04/07 20:55:33 deraadt Exp $	*/
d38 1
a38 1
static const char main_rcsid[] = "$OpenBSD: main.c,v 1.22 2003/04/07 20:55:33 deraadt Exp $";
d121 1
a121 3
main(argc, argv)
	int argc;
	char *argv[];
d422 2
a423 6
compress(in, out, method, bits, sb)
	const char *in;
	const char *out;
	const struct compressor *method;
	int bits;
	struct stat *sb;
d486 1
a486 4
check_method(fd, sb, out)
	int fd;
	struct stat *sb;
	const char *out;
d502 2
a503 6
decompress(in, out, method, bits, sb)
	const char *in;
	const char *out;
	const struct compressor *method;
	int bits;
	struct stat *sb;
d568 1
a568 3
setfile(name, fs)
	const char *name;
	struct stat *fs;
d598 1
a598 2
permission(fname)
	const char *fname;
d612 1
a612 1
usage()
@


1.22
log
@strlcpy; from Hans-Joerg.Hoexer@@yerbouti.franken.de
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.21 2003/01/07 18:48:06 millert Exp $	*/
d18 3
a20 4
" 3. All advertising materials mentioning features or use of this software\n"
"    must display the following acknowledgement:\n"
"      This product includes software developed by the University of\n"
"      California, Berkeley and its contributors.\n"
d38 1
a38 1
static const char main_rcsid[] = "$OpenBSD: main.c,v 1.21 2003/01/07 18:48:06 millert Exp $";
@


1.21
log
@Avoid trashing an existing output file when the input cannot be read.
Changes open order slightly and makes a distiction between errors
< 0 and > 0.  Prompted by a discussion on the freebsd-audit list.
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.20 2003/01/06 18:09:22 mickey Exp $	*/
d39 1
a39 1
static const char main_rcsid[] = "$OpenBSD: main.c,v 1.20 2003/01/06 18:09:22 mickey Exp $";
d336 1
a336 1
			strcpy(outfile, _PATH_DEVNULL);
d338 1
a338 1
			strcpy(outfile, "/dev/stdout");
@


1.20
log
@fix aproblem w/ -oct mix check and compressing /dev/stdin; millert@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.19 2002/12/17 16:16:08 millert Exp $	*/
d39 1
a39 1
static const char main_rcsid[] = "$OpenBSD: main.c,v 1.19 2002/12/17 16:16:08 millert Exp $";
d410 1
a410 1
		if (error && oreg && unlink(outfile) && errno != ENOENT &&
d440 6
a458 6
	if ((ifd = open(in, O_RDONLY)) < 0) {
		if (verbose >= 0)
			warn("%s", out);
		return (-1);
	}

d489 1
a489 1
	return (error ? -1 : 0);
a547 6
	if ((ofd = open(out, O_WRONLY|O_CREAT|O_TRUNC, S_IWUSR)) < 0) {
		if (verbose >= 0)
			warn("%s", in);
		return -1;
	}

d549 6
d578 1
a578 1
	return error;
@


1.19
log
@o Implement -r (recursive) option
o add missing options to OPTSTRING
o add some option mixing sanity checks
o truncate existing files when uncompressing
o fixed some problems with suffix handling
This brings us closer to being able to replace GNU gzip; mickey@@ OK
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.18 2002/12/08 16:07:54 mickey Exp $	*/
d39 1
a39 1
static const char main_rcsid[] = "$OpenBSD: main.c,v 1.18 2002/12/08 16:07:54 mickey Exp $";
d147 1
a147 1
		cat++;
d208 1
a208 1
			cat++;
d238 1
a238 1
			oflag++;
d251 1
a251 1
			testmode++;
d283 1
a283 1
		cat++;
d287 1
d327 1
a327 1
			if (!S_ISREG(entry->fts_statp->st_mode)) {
@


1.18
log
@grop long option names, like gzip.
add most of the gzip's options (a few unimplemented yet).
some cleaning, etc.
millert@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.17 2002/02/16 21:27:45 millert Exp $	*/
d39 1
a39 1
static const char main_rcsid[] = "$OpenBSD: main.c,v 1.17 2002/02/16 21:27:45 millert Exp $";
d50 1
d97 1
a97 1
#define	OPTSTRING	"123456789ab:cdfhlLnNqrS:tvV"
d126 3
a128 1
	struct stat sb, osb;
d130 2
a131 1
	char *p, *s, *infile, outfile[MAXPATHLEN], suffix[16];
d133 1
a133 1
	int exists, isreg, oreg, ch, error, i, rc = 0;
d135 1
a135 1
	bits = cat = decomp = 0;
a159 1
	outfile[0] = '\0';
d161 1
d238 1
d256 1
a256 1
			return (0);
d263 1
a263 1
			return (0);
d265 1
a265 1
			recurse++; /* XXX not yet */
d276 54
a329 32
	do {
		if (*argv != NULL) {
			infile = *argv;
			if (outfile[0] == '\0') {
				if (!decomp && !cat) {
					int len;
					char *p;

					if (snprintf(outfile, sizeof(outfile),
					    "%s%s", infile, suffix) >= sizeof(outfile))
						errx(1, "out file name is too long");

					p = strrchr(outfile, '/');
					if (p == NULL) p = outfile;
					len = strlen(p);
					if (len > NAME_MAX) {
						errx(1, "filename%s too long",
							suffix);
					}
				} else if (decomp && !cat) {
					char *p = strrchr(infile, '.');
					if (p != NULL)
						for (method = &c_table[0];
						     method->name != NULL &&
							!strcmp(p, method->suffix);
						     method++)
							;
					if (method->name != NULL)
						strlcpy(outfile, infile,
						    min(sizeof(outfile),
							(p - infile) + 1));
				}
d331 1
a331 3
		} else {
			infile = "/dev/stdin";
			pipin++;
d336 1
a336 1
		else if (cat || outfile[0] == '\0') {
d338 28
a365 1
			cat++;
d368 3
a370 4
		exists = !stat(outfile, &sb);
		if (!force && exists && S_ISREG(sb.st_mode) &&
		    !permission(outfile)) {
			argv++;
a371 2
		}
		isreg = oreg = !exists || S_ISREG(sb.st_mode);
d373 1
a373 5
		if (stat(infile, &sb) != 0 && verbose >= 0)
			err(1, "input: %s", infile);

		if (!S_ISREG(sb.st_mode))
			isreg = 0;
d378 2
a379 4
		error = (decomp? decompress: compress)
			(infile, outfile, method, bits, &sb);

		if (!error && isreg && stat(outfile, &osb) == 0) {
d381 3
a383 1
			if (!force && !decomp && osb.st_size >= sb.st_size) {
d388 1
a388 1
				rc = rc? rc : 2;
d390 1
a390 2

				setfile(outfile, &sb);
d397 2
a398 1
					ratio = (1000*osb.st_size)/sb.st_size;
d418 1
a418 6

		outfile[0] = '\0';
		if (*argv != NULL)
			argv++;

	} while (*argv != NULL);
d442 1
a442 1
		return -1;
d449 1
a449 1
		return -1;
d455 1
a455 1
		return -1;
d488 1
a488 1
	return error? -1 : 0;
d507 1
a507 1
	return method;
d547 1
a547 1
	if ((ofd = open(out, O_WRONLY|O_CREAT, S_IWUSR)) < 0) {
a634 1

@


1.17
log
@Part one of userland __P removal.  Done with a simple regexp with some minor hand editing to make comments line up correctly.  Another pass is forthcoming that handles the cases that could not be done automatically.
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.16 2001/11/19 19:02:13 mpech Exp $	*/
d3 4
a6 32
/*-
 * Copyright (c) 1992, 1993
 *	The Regents of the University of California.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */
d8 26
a33 3
static char copyright[] =
"@@(#) Copyright (c) 1992, 1993\n\
	The Regents of the University of California.  All rights reserved.\n";
d39 1
a39 1
static char rcsid[] = "$OpenBSD: main.c,v 1.16 2001/11/19 19:02:13 mpech Exp $";
d47 1
d60 3
a62 1
int pipin = 0, force = 0, verbose = 0, testmode = 0, list = 0, nosave = 0;
d65 1
a65 1
struct compressor {
d78 8
d89 2
a90 2
int permission(char *);
void setfile(char *, struct stat *);
d92 27
a118 7
int compress
(const char *, const char *, struct compressor *, int);
int decompress
(const char *, const char *, struct compressor *, int);
struct compressor *check_method(int, const char *);

struct stat sb, osb;
d125 5
a129 6
	int ch, bits, cat, decomp, error;
	struct compressor *method;
	int exists, isreg, oreg;
	char *infile, outfile[MAXPATHLEN+4], suffix[16];
	char *p;
	int rc = 0;
d135 1
d155 1
d157 19
a175 1
	while ((ch = getopt(argc, argv, "0123456789b:cdfghlnOo:qS:tv")) != -1)
a176 1
		case '0':
d187 1
d190 3
d214 2
a219 2
		case 'L':
			fputs(copyright, stderr);
d224 1
a224 1
			nosave = 0;
d228 1
d231 3
a233 2
			strncpy(outfile, optarg, sizeof(outfile)-1);
			outfile[sizeof(outfile)-1] = '\0';
d242 2
a243 1
			strncpy(p, optarg, sizeof(suffix) - (p - suffix) - 1);
d248 4
d255 8
d275 1
a275 1
				if (!decomp && !cat && outfile[0] == '\0') {
d279 4
a282 10
					snprintf(outfile, sizeof(outfile),
						"%s%s", infile,
						method->suffix);

					len = strlen(outfile);
					if (len > MAXPATHLEN) {
						errx(1, "pathname%s too long",
							method->suffix);
					}
					
d288 1
a288 1
							method->suffix);
d298 4
a301 6
					if (method->name != NULL) {
						int l =	min(sizeof(outfile),
							    (p - infile));
						strncpy(outfile, infile, l);
						outfile[l] = '\0';
					}
d303 1
a303 1
			}			
d319 1
a319 1
		    	argv++;
d325 1
a325 1
			err(1, "%s", infile);
d334 1
a334 1
			(infile, outfile, method, bits);
d343 1
a343 1
				rc = 2;
d349 1
a349 1
					warn("%s", infile);
d365 7
a371 3
		    verbose >= 0)
			warn("%s", outfile);
		else if (!error && verbose > 0)
d380 1
a380 1
	return (rc);
d384 1
a384 1
compress(in, out, method, bits)
d387 1
a387 1
	struct compressor *method;
d389 1
d391 2
a392 2
	int ifd;
	int ofd;
a394 2
	u_char buf[Z_BUFSIZE];
	int error;
d412 7
a418 2
	if ((ifd = open(in, O_RDONLY)) >= 0 &&
	    (cookie = (*method->open)(ofd, "w", bits)) != NULL) {
d429 1
a429 1
	if (ifd < 0 || close(ifd) || nr < 0) {
d442 6
d451 2
a452 2
struct compressor *
check_method(fd, out)
d454 1
d457 1
a457 1
	struct compressor *method;
d460 1
a460 2
	     method->name != NULL &&
		     !(*method->check_header)(fd, &sb, out);
d471 1
a471 1
decompress(in, out, method, bits)
d474 1
a474 1
	struct compressor *method;
d476 1
d478 2
a479 2
	int ifd;
	int ofd;
a481 2
	u_char buf[Z_BUFSIZE];
	int error;
d500 1
a500 1
	if (!pipin && (method = check_method(ifd, out)) == NULL) {
d507 7
a513 2
	if ((ofd = open(out, O_WRONLY|O_CREAT, S_IWUSR)) >= 0 &&
	    (cookie = (*method->open)(ifd, "r", bits)) != NULL) {
d524 1
a524 1
	if (ofd < 0 || close(ofd)) {
d526 1
a526 1
			warn("%s", out);
d528 1
d531 1
a531 1
	if (cookie == NULL || (method->close)(cookie) || nr < 0) {
d533 1
a533 1
			warn("%s", in);
a534 1
		(void) close (ifd);
d542 1
a542 1
	char *name;
d545 1
a545 1
	static struct timeval tv[2];
d574 1
a574 1
	char *fname;
d591 2
a592 2
		"usage: %s [-cdfghlnOtqv] [-b <bits>] [-[0-9]] [file ...]\n",
		__progname);
@


1.16
log
@kill more registers

millert@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.15 2000/12/12 16:23:27 millert Exp $	*/
d44 1
a44 1
static char rcsid[] = "$OpenBSD: main.c,v 1.15 2000/12/12 16:23:27 millert Exp $";
d70 5
a74 5
	int (*check_header) __P((int, struct stat *, const char *));
	void *(*open) __P((int, const char *, int));
	int (*read) __P((void *, char *, int));
	int (*write) __P((void *, const char *, int));
	int (*close) __P((void *));
d83 3
a85 3
int permission __P((char *));
void setfile __P((char *, struct stat *));
void usage __P((void));
d87 1
a87 1
	__P((const char *, const char *, struct compressor *, int));
d89 2
a90 2
	__P((const char *, const char *, struct compressor *, int));
struct compressor *check_method __P((int, const char *));
@


1.15
log
@Fix call to getopt(3) -- -S takes an argument; mpech@@prosoft.org.lv
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.14 2000/06/30 16:00:12 millert Exp $	*/
d44 1
a44 1
static char rcsid[] = "$OpenBSD: main.c,v 1.14 2000/06/30 16:00:12 millert Exp $";
d87 1
a87 1
	__P((const char *, const char *, register struct compressor *, int));
d89 1
a89 1
	__P((const char *, const char *, register struct compressor *, int));
d328 1
a328 1
	register struct compressor *method;
d331 1
a331 1
	register int ifd;
d333 2
a334 2
	register void *cookie;
	register ssize_t nr;
d387 1
a387 1
	register struct compressor *method;
d405 1
a405 1
	register struct compressor *method;
d409 3
a411 3
	register int ofd;
	register void *cookie;
	register ssize_t nr;
d470 1
a470 1
	register struct stat *fs;
@


1.14
log
@warnx?/errx? paranoia (use "%s" not a bare string unless it is a
constant).  These are not security holes but it is worth fixing
them anyway both for robustness and so folks looking for examples
in the tree are not misled into doing something potentially dangerous.
Furthermore, it is a bad idea to assume that pathnames will not
include '%' in them and that error routines don't return strings
with '%' in them (especially in light of the possibility of locales).
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.13 2000/03/10 06:53:51 d Exp $	*/
d44 1
a44 1
static char rcsid[] = "$OpenBSD: main.c,v 1.13 2000/03/10 06:53:51 d Exp $";
d130 1
a130 1
	while ((ch = getopt(argc, argv, "0123456789b:cdfghlnOo:qStv")) != -1)
@


1.13
log
@plug leak
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.12 1999/09/26 17:35:49 mickey Exp $	*/
d44 1
a44 1
static char rcsid[] = "$OpenBSD: main.c,v 1.12 1999/09/26 17:35:49 mickey Exp $";
d270 1
a270 1
			err(1, infile);
@


1.13.2.1
log
@Pull in patch from current (even more to come):
Fix (millert):
warnx?/errx? paranoia (use "%s" not a bare string unless it is a
constant).  These are not security holes but it is worth fixing
them anyway both for robustness and so folks looking for examples
in the tree are not misled into doing something potentially dangerous.
Furthermore, it is a bad idea to assume that pathnames will not
include '%' in them and that error routines don't return strings
with '%' in them (especially in light of the possibility of locales).
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.14 2000/06/30 16:00:12 millert Exp $	*/
d44 1
a44 1
static char rcsid[] = "$OpenBSD: main.c,v 1.14 2000/06/30 16:00:12 millert Exp $";
d270 1
a270 1
			err(1, "%s", infile);
@


1.12
log
@remove unneeded changes
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.11 1999/09/26 14:04:58 espie Exp $	*/
d44 1
a44 1
static char rcsid[] = "$OpenBSD: main.c,v 1.11 1999/09/26 14:04:58 espie Exp $";
d435 1
@


1.11
log
@read/write, and compressor->read/write results are signed values.
Adjust types and error checks, so that error checking actually occurs.

[This lets cat garbage|zcat   correctly detect bad headers instead of
dumping core]
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.10 1998/09/10 06:44:41 deraadt Exp $	*/
d44 1
a44 1
static char rcsid[] = "$OpenBSD: main.c,v 1.10 1998/09/10 06:44:41 deraadt Exp $";
d357 1
a357 1
		while ((nr = read(ifd, buf, sizeof(buf))) != -1 && nr != 0)
d366 1
a366 1
	if (ifd < 0 || close(ifd) || nr == -1) {
d441 1
a441 1
		while ((nr = (method->read)(cookie, buf, sizeof(buf))) != -1 && nr != 0)
d456 1
a456 1
	if (cookie == NULL || (method->close)(cookie) || nr == -1) {
@


1.10
log
@proper strncpy
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.9 1998/03/10 16:34:03 mickey Exp $	*/
d44 1
a44 1
static char rcsid[] = "$OpenBSD: main.c,v 1.9 1998/03/10 16:34:03 mickey Exp $";
d334 1
a334 1
	register size_t nr;
d357 1
a357 1
		while ((nr = read(ifd, buf, sizeof(buf))) > 0)
d366 1
a366 1
	if (ifd < 0 || close(ifd) || nr < 0) {
d411 1
a411 1
	register size_t nr;
d441 1
a441 1
		while ((nr = (method->read)(cookie, buf, sizeof(buf))) > 0)
d456 1
a456 1
	if (cookie == NULL || (method->close)(cookie) || nr < 0) {
@


1.9
log
@fix coredump on pipe to uncompress
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.8 1998/02/13 16:36:24 millert Exp $	*/
d44 1
a44 1
static char rcsid[] = "$OpenBSD: main.c,v 1.8 1998/02/13 16:36:24 millert Exp $";
d183 1
@


1.8
log
@Don't do chflags() if st_flags is zero.  Fixes bogus error when
uncompressing on an NFS filesystem.  Noted by hubertf@@channel.regensburg.org
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.7 1997/08/19 06:32:36 denny Exp $	*/
d44 1
a44 1
static char rcsid[] = "$OpenBSD: main.c,v 1.7 1997/08/19 06:32:36 denny Exp $";
d64 1
a64 1
int force = 0, verbose = 0, testmode = 0, list = 0, nosave = 0;
d248 1
a248 1
		} else
d250 2
a414 1
	method = NULL;
d431 1
a431 1
	if ((method = check_method(ifd, out)) == NULL) {
@


1.7
log
@Check length of filename.Z against PATH_MAX and NAME_MAX (POSIX 1003.2 spec)
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.6 1997/07/19 19:08:28 mickey Exp $	*/
d44 1
a44 1
static char rcsid[] = "$OpenBSD: main.c,v 1.6 1997/07/19 19:08:28 mickey Exp $";
d492 1
a492 1
	if (chflags(name, fs->st_flags))
@


1.6
log
@initialization overwrites program name parsing
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.5 1997/07/08 10:06:31 mickey Exp $	*/
d44 1
a44 1
static char rcsid[] = "$OpenBSD: main.c,v 1.5 1997/07/08 10:06:31 mickey Exp $";
d102 1
a102 1
	char *infile, outfile[MAXPATHLEN], suffix[16];
d104 1
d147 5
d211 22
a232 4
				if (!decomp && !cat && outfile[0] == '\0')
					snprintf(outfile, sizeof(outfile), "%s%s",
						 infile, method->suffix);
				else if (decomp && !cat) {
d285 1
d318 1
a318 1
	return (0);
@


1.5
log
@one tiny change
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.4 1997/07/08 03:13:19 mickey Exp $	*/
d44 1
a44 1
static char rcsid[] = "$OpenBSD: main.c,v 1.4 1997/07/08 03:13:19 mickey Exp $";
d105 1
a127 1
	bits = cat = decomp = 0;
@


1.4
log
@restore compress to terminal
fix faild outfile unlink
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.3 1997/07/06 22:03:34 mickey Exp $	*/
d44 1
a44 1
static char rcsid[] = "$OpenBSD: main.c,v 1.3 1997/07/06 22:03:34 mickey Exp $";
d281 2
a282 1
		if (error && oreg && unlink(outfile) && verbose >= 0)
@


1.3
log
@fix error handling
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.2 1997/07/06 20:47:32 mickey Exp $	*/
d44 1
a44 1
static char rcsid[] = "$OpenBSD: main.c,v 1.2 1997/07/06 20:47:32 mickey Exp $";
d281 1
a281 1
		if (error && isreg && unlink(outfile) && verbose >= 0)
d318 1
a318 1
	if (!force && isatty(ofd)) {
@


1.2
log
@correct program name decoding
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.1 1997/07/06 20:22:58 mickey Exp $	*/
d44 1
a44 1
static char rcsid[] = "$OpenBSD: main.c,v 1.1 1997/07/06 20:22:58 mickey Exp $";
a278 3
		} else {
			if (isreg >= 0)
				warn("%s", outfile);
d281 1
a281 1
		if (error && unlink(outfile) && verbose >= 0)
d311 13
a323 1
	ifd = ofd = -1;
a325 1
	    (ofd = open(out, O_WRONLY|O_CREAT, S_IWUSR)) >= 0 &&
d343 1
a343 1
	if (ofd < 0 || cookie == NULL || (method->close)(cookie)) {
a385 1
	ifd = ofd = -1;
d390 20
a410 2
	    (ifd = open(in, O_RDONLY)) >= 0 &&
	    (method = check_method(ifd, out)) != NULL &&
d428 1
a428 2
	if (ifd < 0 || cookie == NULL || method == NULL ||
	    (method->close)(cookie) || nr < 0) {
d430 1
a430 4
			if (method == NULL)
				warnx("%s: unrecognized file format", in);
			else
				warn("%s", in);
d432 1
@


1.1
log
@do gzip
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d44 1
a44 1
static char rcsid[] = "$OpenBSD: compress.c,v 1.5 1997/01/19 17:25:11 millert Exp $";
d122 2
a123 2
		if (strcmp(__progname, "zip") &&
		    strcmp(__progname, "compress"))
@

