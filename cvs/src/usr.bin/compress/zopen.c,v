head	1.22;
access;
symbols
	OPENBSD_6_2:1.22.0.4
	OPENBSD_6_2_BASE:1.22
	OPENBSD_6_1:1.21.0.4
	OPENBSD_6_1_BASE:1.21
	OPENBSD_6_0:1.20.0.8
	OPENBSD_6_0_BASE:1.20
	OPENBSD_5_9:1.20.0.4
	OPENBSD_5_9_BASE:1.20
	OPENBSD_5_8:1.20.0.6
	OPENBSD_5_8_BASE:1.20
	OPENBSD_5_7:1.20.0.2
	OPENBSD_5_7_BASE:1.20
	OPENBSD_5_6:1.18.0.14
	OPENBSD_5_6_BASE:1.18
	OPENBSD_5_5:1.18.0.12
	OPENBSD_5_5_BASE:1.18
	OPENBSD_5_4:1.18.0.8
	OPENBSD_5_4_BASE:1.18
	OPENBSD_5_3:1.18.0.6
	OPENBSD_5_3_BASE:1.18
	OPENBSD_5_2:1.18.0.4
	OPENBSD_5_2_BASE:1.18
	OPENBSD_5_1_BASE:1.18
	OPENBSD_5_1:1.18.0.2
	OPENBSD_5_0:1.17.0.26
	OPENBSD_5_0_BASE:1.17
	OPENBSD_4_9:1.17.0.24
	OPENBSD_4_9_BASE:1.17
	OPENBSD_4_8:1.17.0.22
	OPENBSD_4_8_BASE:1.17
	OPENBSD_4_7:1.17.0.18
	OPENBSD_4_7_BASE:1.17
	OPENBSD_4_6:1.17.0.20
	OPENBSD_4_6_BASE:1.17
	OPENBSD_4_5:1.17.0.16
	OPENBSD_4_5_BASE:1.17
	OPENBSD_4_4:1.17.0.14
	OPENBSD_4_4_BASE:1.17
	OPENBSD_4_3:1.17.0.12
	OPENBSD_4_3_BASE:1.17
	OPENBSD_4_2:1.17.0.10
	OPENBSD_4_2_BASE:1.17
	OPENBSD_4_1:1.17.0.8
	OPENBSD_4_1_BASE:1.17
	OPENBSD_4_0:1.17.0.6
	OPENBSD_4_0_BASE:1.17
	OPENBSD_3_9:1.17.0.4
	OPENBSD_3_9_BASE:1.17
	OPENBSD_3_8:1.17.0.2
	OPENBSD_3_8_BASE:1.17
	OPENBSD_3_7:1.14.0.8
	OPENBSD_3_7_BASE:1.14
	OPENBSD_3_6:1.14.0.6
	OPENBSD_3_6_BASE:1.14
	OPENBSD_3_5:1.14.0.4
	OPENBSD_3_5_BASE:1.14
	OPENBSD_3_4:1.14.0.2
	OPENBSD_3_4_BASE:1.14
	OPENBSD_3_3:1.9.0.2
	OPENBSD_3_3_BASE:1.9
	OPENBSD_3_2:1.8.0.4
	OPENBSD_3_2_BASE:1.8
	OPENBSD_3_1:1.8.0.2
	OPENBSD_3_1_BASE:1.8
	OPENBSD_3_0:1.6.0.12
	OPENBSD_3_0_BASE:1.6
	OPENBSD_2_9_BASE:1.6
	OPENBSD_2_9:1.6.0.10
	OPENBSD_2_8:1.6.0.8
	OPENBSD_2_8_BASE:1.6
	OPENBSD_2_7:1.6.0.6
	OPENBSD_2_7_BASE:1.6
	OPENBSD_2_6:1.6.0.4
	OPENBSD_2_6_BASE:1.6
	OPENBSD_2_5:1.6.0.2
	OPENBSD_2_5_BASE:1.6
	OPENBSD_2_4:1.5.0.6
	OPENBSD_2_4_BASE:1.5
	OPENBSD_2_3:1.5.0.4
	OPENBSD_2_3_BASE:1.5
	OPENBSD_2_2:1.5.0.2
	OPENBSD_2_2_BASE:1.5
	OPENBSD_2_1:1.4.0.2
	OPENBSD_2_1_BASE:1.4
	OPENBSD_2_0:1.3.0.2
	OPENBSD_2_0_BASE:1.3
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.22
date	2017.05.29.14.41.16;	author fcambus;	state Exp;
branches;
next	1.21;
commitid	pOBr3oxCQxS1OgKd;

1.21
date	2016.09.03.11.41.10;	author tedu;	state Exp;
branches;
next	1.20;
commitid	NacWFWgKwtkfLhFL;

1.20
date	2015.02.01.11.50.23;	author tobias;	state Exp;
branches;
next	1.19;
commitid	4gwiCBmdfWIZlUA8;

1.19
date	2015.01.16.06.40.06;	author deraadt;	state Exp;
branches;
next	1.18;
commitid	Uu5nFG3wCl0LACBb;

1.18
date	2011.09.22.10.41.04;	author deraadt;	state Exp;
branches;
next	1.17;

1.17
date	2005.08.25.17.07.56;	author millert;	state Exp;
branches;
next	1.16;

1.16
date	2005.06.26.18.20.26;	author otto;	state Exp;
branches;
next	1.15;

1.15
date	2005.04.17.16.17.39;	author deraadt;	state Exp;
branches;
next	1.14;

1.14
date	2003.08.03.01.26.46;	author deraadt;	state Exp;
branches;
next	1.13;

1.13
date	2003.07.17.20.06.01;	author millert;	state Exp;
branches;
next	1.12;

1.12
date	2003.07.11.02.31.18;	author millert;	state Exp;
branches;
next	1.11;

1.11
date	2003.06.22.15.22.43;	author deraadt;	state Exp;
branches;
next	1.10;

1.10
date	2003.06.03.02.56.07;	author millert;	state Exp;
branches;
next	1.9;

1.9
date	2002.12.08.16.07.54;	author mickey;	state Exp;
branches;
next	1.8;

1.8
date	2002.02.16.21.27.45;	author millert;	state Exp;
branches;
next	1.7;

1.7
date	2001.11.19.19.02.13;	author mpech;	state Exp;
branches;
next	1.6;

1.6
date	99.03.04.15.04.45;	author mickey;	state Exp;
branches;
next	1.5;

1.5
date	97.07.06.20.23.00;	author mickey;	state Exp;
branches;
next	1.4;

1.4
date	97.01.19.17.25.14;	author millert;	state Exp;
branches;
next	1.3;

1.3
date	96.09.22.20.05.19;	author tholo;	state Exp;
branches;
next	1.2;

1.2
date	96.06.26.05.32.22;	author deraadt;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.45.03;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.45.03;	author deraadt;	state Exp;
branches;
next	;


desc
@@


1.22
log
@Remove unused zclose function.

From Brian Callahan, thanks!

OK tb@@
@
text
@/*	$OpenBSD: zopen.c,v 1.21 2016/09/03 11:41:10 tedu Exp $	*/
/*	$NetBSD: zopen.c,v 1.5 1995/03/26 09:44:53 glass Exp $	*/

/*-
 * Copyright (c) 1985, 1986, 1992, 1993
 *	The Regents of the University of California.  All rights reserved.
 *
 * This code is derived from software contributed to Berkeley by
 * Diomidis Spinellis and James A. Woods, derived from original
 * work by Spencer Thomas and Joseph Orost.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 *	From: @@(#)zopen.c	8.1 (Berkeley) 6/27/93
 */

/*-
 * fcompress.c - File compression ala IEEE Computer, June 1984.
 *
 * Compress authors:
 *		Spencer W. Thomas	(decvax!utah-cs!thomas)
 *		Jim McKie		(decvax!mcvax!jim)
 *		Steve Davies		(decvax!vax135!petsd!peora!srd)
 *		Ken Turkowski		(decvax!decwrl!turtlevax!ken)
 *		James A. Woods		(decvax!ihnp4!ames!jaw)
 *		Joe Orost		(decvax!vax135!petsd!joe)
 *
 * Cleaned up and converted to library returning I/O streams by
 * Diomidis Spinellis <dds@@doc.ic.ac.uk>.
 *
 * zopen(filename, mode, bits)
 *	Returns a FILE * that can be used for read or write.  The modes
 *	supported are only "r" and "w".  Seeking is not allowed.  On
 *	reading the file is decompressed, on writing it is compressed.
 *	The output is compatible with compress(1) with 16 bit tables.
 *	Any file produced by compress(1) can be read.
 */

#include <sys/stat.h>

#include <ctype.h>
#include <errno.h>
#include <signal.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <fcntl.h>
#include "compress.h"

#define MINIMUM(a, b)	(((a) < (b)) ? (a) : (b))

#define	BITS		16		/* Default bits. */
#define	HSIZE		69001		/* 95% occupancy */
#define	ZBUFSIZ		8192		/* I/O buffer size */

/* A code_int must be able to hold 2**BITS values of type int, and also -1. */
typedef long code_int;
typedef long count_int;

static const u_char z_magic[] =
	{'\037', '\235'};		/* 1F 9D */

#define	BIT_MASK	0x1f		/* Defines for third byte of header. */
#define	BLOCK_MASK	0x80

/*
 * Masks 0x40 and 0x20 are free.  I think 0x20 should mean that there is
 * a fourth header byte (for expansion).
 */
#define	INIT_BITS 9			/* Initial number of bits/code. */

#define	MAXCODE(n_bits)	((1 << (n_bits)) - 1)

struct s_zstate {
	int zs_fd;			/* File stream for I/O */
	char zs_mode;			/* r or w */
	enum {
		S_START, S_MAGIC, S_MIDDLE, S_EOF
	} zs_state;			/* State of computation */
	int zs_n_bits;			/* Number of bits/code. */
	int zs_maxbits;			/* User settable max # bits/code. */
	code_int zs_maxcode;		/* Maximum code, given n_bits. */
	code_int zs_maxmaxcode;		/* Should NEVER generate this code. */
	count_int zs_htab[HSIZE];
	u_short zs_codetab[HSIZE];
	code_int zs_hsize;		/* For dynamic table sizing. */
	code_int zs_free_ent;		/* First unused entry. */
	/*
	 * Block compression parameters -- after all codes are used up,
	 * and compression rate changes, start over.
	 */
	int zs_block_compress;
	int zs_clear_flg;
	long zs_ratio;
	count_int zs_checkpoint;
	long zs_in_count;		/* Length of input. */
	long zs_bytes_out;		/* Length of output. */
	long zs_out_count;		/* # of codes output (for debugging).*/
	u_char zs_buf[ZBUFSIZ];		/* I/O buffer */
	u_char *zs_bp;			/* Current I/O window in the zs_buf */
	int zs_offset;			/* Number of bits in the zs_buf */
	union {
		struct {
			long zs_fcode;
			code_int zs_ent;
			code_int zs_hsize_reg;
			int zs_hshift;
		} w;			/* Write parameters */
		struct {
			u_char *zs_stackp, *zs_ebp;
			int zs_finchar;
			code_int zs_code, zs_oldcode, zs_incode;
			int zs_size;
		} r;			/* Read parameters */
	} u;
};

/* Definitions to retain old variable names */
#define zs_fcode	u.w.zs_fcode
#define zs_ent		u.w.zs_ent
#define zs_hsize_reg	u.w.zs_hsize_reg
#define zs_hshift	u.w.zs_hshift
#define zs_stackp	u.r.zs_stackp
#define zs_finchar	u.r.zs_finchar
#define zs_code		u.r.zs_code
#define zs_oldcode	u.r.zs_oldcode
#define zs_incode	u.r.zs_incode
#define zs_size		u.r.zs_size
#define zs_ebp		u.r.zs_ebp

/*
 * To save much memory, we overlay the table used by compress() with those
 * used by decompress().  The tab_prefix table is the same size and type as
 * the codetab.  The tab_suffix table needs 2**BITS characters.  We get this
 * from the beginning of htab.  The output stack uses the rest of htab, and
 * contains characters.  There is plenty of room for any possible stack
 * (stack used to be 8000 characters).
 */

#define	htabof(i)	zs->zs_htab[i]
#define	codetabof(i)	zs->zs_codetab[i]

#define	tab_prefixof(i)	codetabof(i)
#define	tab_suffixof(i)	((u_char *)(zs->zs_htab))[i]
#define	de_stack	((u_char *)&tab_suffixof(1 << BITS))

#define	CHECK_GAP 10000		/* Ratio check interval. */

/*
 * the next two codes should not be changed lightly, as they must not
 * lie within the contiguous general code space.
 */
#define	FIRST	257		/* First free entry. */
#define	CLEAR	256		/* Table clear output code. */

static int	cl_block(struct s_zstate *);
static void	cl_hash(struct s_zstate *, count_int);
static code_int	getcode(struct s_zstate *);
static int	output(struct s_zstate *, code_int);

/*-
 * Algorithm from "A Technique for High Performance Data Compression",
 * Terry A. Welch, IEEE Computer Vol 17, No 6 (June 1984), pp 8-19.
 *
 * Algorithm:
 *	Modified Lempel-Ziv method (LZW).  Basically finds common
 * substrings and replaces them with a variable size code.  This is
 * deterministic, and can be done on the fly.  Thus, the decompression
 * procedure needs no input table, but tracks the way the table was built.
 */

/*-
 * compress write
 *
 * Algorithm:  use open addressing double hashing (no chaining) on the
 * prefix code / next character combination.  We do a variant of Knuth's
 * algorithm D (vol. 3, sec. 6.4) along with G. Knott's relatively-prime
 * secondary probe.  Here, the modular division first probe is gives way
 * to a faster exclusive-or manipulation.  Also do block compression with
 * an adaptive reset, whereby the code table is cleared when the compression
 * ratio decreases, but after the table fills.  The variable-length output
 * codes are re-sized at this point, and a special CLEAR code is generated
 * for the decompressor.  Late addition:  construct the table according to
 * file size for noticeable speed improvement on small files.  Please direct
 * questions about this implementation to ames!jaw.
 */
int
zwrite(void *cookie, const char *wbp, int num)
{
	code_int i;
	int c, disp;
	struct s_zstate *zs;
	const u_char *bp;
	u_char tmp;
	int count;

	zs = cookie;
	count = num;
	bp = (u_char *)wbp;
	switch (zs->zs_state) {
	case S_MAGIC:
		return -1;
	case S_EOF:
		return 0;
	case S_START:
		zs->zs_state = S_MIDDLE;

		zs->zs_maxmaxcode = 1L << zs->zs_maxbits;
		if (write(zs->zs_fd, z_magic, sizeof(z_magic)) !=
		    sizeof(z_magic))
			return (-1);
		tmp = (u_char)(zs->zs_maxbits | zs->zs_block_compress);
		if (write(zs->zs_fd, &tmp, sizeof(tmp)) != sizeof(tmp))
			return (-1);

		zs->zs_bp = zs->zs_buf;
		zs->zs_offset = 0;
		zs->zs_bytes_out = 3;	/* Includes 3-byte header mojo. */
		zs->zs_out_count = 0;
		zs->zs_clear_flg = 0;
		zs->zs_ratio = 0;
		zs->zs_in_count = 1;
		zs->zs_checkpoint = CHECK_GAP;
		zs->zs_maxcode = MAXCODE(zs->zs_n_bits = INIT_BITS);
		zs->zs_free_ent = ((zs->zs_block_compress) ? FIRST : 256);

		zs->zs_ent = *bp++;
		--count;

		zs->zs_hshift = 0;
		for (zs->zs_fcode = (long)zs->zs_hsize; zs->zs_fcode < 65536L;
		    zs->zs_fcode *= 2L)
			zs->zs_hshift++;
		/* Set hash code range bound. */
		zs->zs_hshift = 8 - zs->zs_hshift;

		zs->zs_hsize_reg = zs->zs_hsize;
		/* Clear hash table. */
		cl_hash(zs, (count_int)zs->zs_hsize_reg);

	case S_MIDDLE:
		for (i = 0; count-- > 0;) {
			c = *bp++;
			zs->zs_in_count++;
			zs->zs_fcode = (long)(((long)c << zs->zs_maxbits) +
			    zs->zs_ent);
			/* Xor hashing. */
			i = ((c << zs->zs_hshift) ^ zs->zs_ent);

			if (htabof(i) == zs->zs_fcode) {
				zs->zs_ent = codetabof(i);
				continue;
			} else if ((long)htabof(i) < 0)	/* Empty slot. */
				goto nomatch;
			/* Secondary hash (after G. Knott). */
			disp = zs->zs_hsize_reg - i;
			if (i == 0)
				disp = 1;
probe:			if ((i -= disp) < 0)
				i += zs->zs_hsize_reg;

			if (htabof(i) == zs->zs_fcode) {
				zs->zs_ent = codetabof(i);
				continue;
			}
			if ((long)htabof(i) >= 0)
				goto probe;
nomatch:		if (output(zs, (code_int) zs->zs_ent) == -1)
				return (-1);
			zs->zs_out_count++;
			zs->zs_ent = c;
			if (zs->zs_free_ent < zs->zs_maxmaxcode) {
				/* code -> hashtable */
				codetabof(i) = zs->zs_free_ent++;
				htabof(i) = zs->zs_fcode;
			} else if ((count_int)zs->zs_in_count >=
			    zs->zs_checkpoint && zs->zs_block_compress) {
				if (cl_block(zs) == -1)
					return (-1);
			}
		}
	}
	return (num);
}

int
z_close(void *cookie, struct z_info *info, const char *name, struct stat *sb)
{
	struct s_zstate *zs;
	int rval;

	zs = cookie;
	if (zs->zs_mode == 'w') {		/* Put out the final code. */
		if (output(zs, (code_int) zs->zs_ent) == -1) {
			(void)close(zs->zs_fd);
			free(zs);
			return (-1);
		}
		zs->zs_out_count++;
		if (output(zs, (code_int) - 1) == -1) {
			(void)close(zs->zs_fd);
			free(zs);
			return (-1);
		}
	}

	if (info != NULL) {
		info->mtime = 0;
		info->crc = (u_int32_t)-1;
		info->hlen = 0;
		info->total_in = (off_t)zs->zs_in_count;
		info->total_out = (off_t)zs->zs_bytes_out;
	}

#ifndef SAVECORE
	setfile(name, zs->zs_fd, sb);
#endif
	rval = close(zs->zs_fd);
	free(zs);
	return (rval);
}

/*-
 * Output the given code.
 * Inputs:
 *	code:	A n_bits-bit integer.  If == -1, then EOF.  This assumes
 *		that n_bits =< (long)wordsize - 1.
 * Outputs:
 *	Outputs code to the file.
 * Assumptions:
 *	Chars are 8 bits long.
 * Algorithm:
 *	Maintain a BITS character long buffer (so that 8 codes will
 * fit in it exactly).  Use the VAX insv instruction to insert each
 * code in turn.  When the buffer fills up empty it and start over.
 */

static const u_char lmask[9] =
	{0xff, 0xfe, 0xfc, 0xf8, 0xf0, 0xe0, 0xc0, 0x80, 0x00};
static const u_char rmask[9] =
	{0x00, 0x01, 0x03, 0x07, 0x0f, 0x1f, 0x3f, 0x7f, 0xff};

static int
output(struct s_zstate *zs, code_int ocode)
{
	int bits;

	if (ocode >= 0) {
		int r_off;
		u_char *bp;

		/* Get to the first byte. */
		bp = zs->zs_bp + (zs->zs_offset >> 3);
		r_off = zs->zs_offset & 7;
		bits = zs->zs_n_bits;

		/*
		 * Since ocode is always >= 8 bits, only need to mask the first
		 * hunk on the left.
		 */
		*bp = (*bp & rmask[r_off]) | ((ocode << r_off) & lmask[r_off]);
		bp++;
		bits -= (8 - r_off);
		ocode >>= 8 - r_off;
		/* Get any 8 bit parts in the middle (<=1 for up to 16 bits) */
		if (bits >= 8) {
			*bp++ = ocode;
			ocode >>= 8;
			bits -= 8;
		}
		/* Last bits. */
		if (bits)
			*bp = ocode;
		zs->zs_offset += zs->zs_n_bits;
		if (zs->zs_offset == (zs->zs_n_bits << 3)) {
			zs->zs_bp += zs->zs_n_bits;
			zs->zs_offset = 0;
		}
		/*
		 * If the next entry is going to be too big for the ocode size,
		 * then increase it, if possible.
		 */
		if (zs->zs_free_ent > zs->zs_maxcode ||
		    (zs->zs_clear_flg > 0)) {
			/*
			 * Write the whole buffer, because the input side won't
			 * discover the size increase until after it has read it
			 */
			if (zs->zs_offset > 0) {
				zs->zs_bp += zs->zs_n_bits;
				zs->zs_offset = 0;
			}

			if (zs->zs_clear_flg) {
				zs->zs_maxcode =
					MAXCODE(zs->zs_n_bits = INIT_BITS);
				zs->zs_clear_flg = 0;
			} else {
				zs->zs_n_bits++;
				if (zs->zs_n_bits == zs->zs_maxbits)
					zs->zs_maxcode = zs->zs_maxmaxcode;
				else
					zs->zs_maxcode =
					    MAXCODE(zs->zs_n_bits);
			}
		}

		if (zs->zs_bp + zs->zs_n_bits > &zs->zs_buf[ZBUFSIZ]) {
			bits = zs->zs_bp - zs->zs_buf;
			if (write(zs->zs_fd, zs->zs_buf, bits) != bits)
				return (-1);
			zs->zs_bytes_out += bits;
			if (zs->zs_offset > 0)
				fprintf (stderr, "zs_offset != 0\n");
			zs->zs_bp = zs->zs_buf;
		}
	} else {
		/* At EOF, write the rest of the buffer. */
		if (zs->zs_offset > 0)
			zs->zs_bp += (zs->zs_offset + 7) / 8;
		if (zs->zs_bp > zs->zs_buf) {
			bits = zs->zs_bp - zs->zs_buf;
			if (write(zs->zs_fd, zs->zs_buf, bits) != bits)
				return (-1);
			zs->zs_bytes_out += bits;
		}
		zs->zs_offset = 0;
		zs->zs_bp = zs->zs_buf;
	}
	return (0);
}

/*
 * Decompress read.  This routine adapts to the codes in the file building
 * the "string" table on-the-fly; requiring no table to be stored in the
 * compressed file.  The tables used herein are shared with those of the
 * compress() routine.  See the definitions above.
 */
int
zread(void *cookie, char *rbp, int num)
{
	u_int count;
	struct s_zstate *zs;
	u_char *bp, header[3];

	if (num == 0)
		return (0);

	zs = cookie;
	count = num;
	bp = (u_char *)rbp;
	switch (zs->zs_state) {
	case S_START:
		zs->zs_state = S_MIDDLE;
		zs->zs_bp = zs->zs_buf;
		header[0] = header[1] = header[2] = '\0';
		read(zs->zs_fd, header, sizeof(header));
		break;
	case S_MAGIC:
		zs->zs_state = S_MIDDLE;
		zs->zs_bp = zs->zs_buf;
		header[0] = z_magic[0];
		header[1] = z_magic[1];
		header[2] = '\0';
		read(zs->zs_fd, &header[2], 1);
		break;
	case S_MIDDLE:
		goto middle;
	case S_EOF:
		goto eof;
	}

	/* Check the magic number */
	if (header[0] != z_magic[0] || header[1] != z_magic[1]) {
		errno = EFTYPE;
		return (-1);
	}
	zs->zs_maxbits = header[2];	/* Set -b from file. */
	zs->zs_in_count += sizeof(header);
	zs->zs_block_compress = zs->zs_maxbits & BLOCK_MASK;
	zs->zs_maxbits &= BIT_MASK;
	zs->zs_maxmaxcode = 1L << zs->zs_maxbits;
	if (zs->zs_maxbits > BITS) {
		errno = EFTYPE;
		return (-1);
	}
	/* As above, initialize the first 256 entries in the table. */
	zs->zs_maxcode = MAXCODE(zs->zs_n_bits = INIT_BITS);
	for (zs->zs_code = 255; zs->zs_code >= 0; zs->zs_code--) {
		tab_prefixof(zs->zs_code) = 0;
		tab_suffixof(zs->zs_code) = (u_char) zs->zs_code;
	}
	zs->zs_free_ent = zs->zs_block_compress ? FIRST : 256;

	zs->zs_finchar = zs->zs_oldcode = getcode(zs);
	if (zs->zs_oldcode == -1)	/* EOF already? */
		return (0);	/* Get out of here */

	/* First code must be 8 bits = char. */
	*bp++ = (u_char)zs->zs_finchar;
	count--;
	zs->zs_stackp = de_stack;

	while ((zs->zs_code = getcode(zs)) > -1) {

		if ((zs->zs_code == CLEAR) && zs->zs_block_compress) {
			for (zs->zs_code = 255; zs->zs_code >= 0;
			    zs->zs_code--)
				tab_prefixof(zs->zs_code) = 0;
			zs->zs_clear_flg = 1;
			zs->zs_free_ent = FIRST - 1;
			if ((zs->zs_code = getcode(zs)) == -1)	/* O, untimely death! */
				break;
		}
		zs->zs_incode = zs->zs_code;

		/* Special case for KwKwK string. */
		if (zs->zs_code >= zs->zs_free_ent) {
			*zs->zs_stackp++ = zs->zs_finchar;
			zs->zs_code = zs->zs_oldcode;
		}

		/* Generate output characters in reverse order. */
		while (zs->zs_code >= 256) {
			/*
			 * Bad input file may cause zs_stackp to overflow
			 * zs_htab; check here and abort decompression,
			 * that's better than dumping core.
			 */
			if (zs->zs_stackp >= (u_char *)&zs->zs_htab[HSIZE]) {
				errno = EINVAL;
				return (-1);
			}
			*zs->zs_stackp++ = tab_suffixof(zs->zs_code);
			zs->zs_code = tab_prefixof(zs->zs_code);
		}
		*zs->zs_stackp++ = zs->zs_finchar = tab_suffixof(zs->zs_code);

		/* And put them out in forward order.  */
middle:		do {
			if (count-- == 0) {
				zs->zs_bytes_out += num;
				return (num);
			}
			*bp++ = *--zs->zs_stackp;
		} while (zs->zs_stackp > de_stack);

		/* Generate the new entry. */
		if ((zs->zs_code = zs->zs_free_ent) < zs->zs_maxmaxcode) {
			tab_prefixof(zs->zs_code) = (u_short) zs->zs_oldcode;
			tab_suffixof(zs->zs_code) = zs->zs_finchar;
			zs->zs_free_ent = zs->zs_code + 1;
		}

		/* Remember previous code. */
		zs->zs_oldcode = zs->zs_incode;
	}
	zs->zs_state = S_EOF;
	zs->zs_bytes_out += num - count;
eof:	return (num - count);
}

/*-
 * Read one code from the standard input.  If EOF, return -1.
 * Inputs:
 *	stdin
 * Outputs:
 *	code or -1 is returned.
 */
static code_int
getcode(struct s_zstate *zs)
{
	code_int gcode;
	int r_off, bits;
	u_char *bp;

	if (zs->zs_clear_flg > 0 || zs->zs_offset >= zs->zs_size ||
	    zs->zs_free_ent > zs->zs_maxcode) {

		zs->zs_bp += zs->zs_n_bits;
		/*
		 * If the next entry will be too big for the current gcode
		 * size, then we must increase the size.  This implies reading
		 * a new buffer full, too.
		 */
		if (zs->zs_free_ent > zs->zs_maxcode) {
			zs->zs_n_bits++;
			if (zs->zs_n_bits == zs->zs_maxbits) {
				/* Won't get any bigger now. */
				zs->zs_maxcode = zs->zs_maxmaxcode;
			} else
				zs->zs_maxcode = MAXCODE(zs->zs_n_bits);
		}
		if (zs->zs_clear_flg > 0) {
			zs->zs_maxcode = MAXCODE(zs->zs_n_bits = INIT_BITS);
			zs->zs_clear_flg = 0;
		}

		/* fill the buffer up to the neck */
		if (zs->zs_bp + zs->zs_n_bits > zs->zs_ebp) {
			for (bp = zs->zs_buf; zs->zs_bp < zs->zs_ebp;
				*bp++ = *zs->zs_bp++);
			if ((bits = read(zs->zs_fd, bp, ZBUFSIZ -
			    (bp - zs->zs_buf))) < 0)
				return -1;
			zs->zs_in_count += bits;
			zs->zs_bp = zs->zs_buf;
			zs->zs_ebp = bp + bits;
		}
		zs->zs_offset = 0;
		zs->zs_size = MINIMUM(zs->zs_n_bits, zs->zs_ebp - zs->zs_bp);
		if (zs->zs_size == 0)
			return -1;
		/* Round size down to integral number of codes. */
		zs->zs_size = (zs->zs_size << 3) - (zs->zs_n_bits - 1);
	}

	bp = zs->zs_bp;
	r_off = zs->zs_offset;
	bits = zs->zs_n_bits;

	/* Get to the first byte. */
	bp += (r_off >> 3);
	r_off &= 7;

	/* Get first part (low order bits). */
	gcode = (*bp++ >> r_off);
	bits -= (8 - r_off);
	r_off = 8 - r_off;	/* Now, roffset into gcode word. */

	/* Get any 8 bit parts in the middle (<=1 for up to 16 bits). */
	if (bits >= 8) {
		gcode |= *bp++ << r_off;
		r_off += 8;
		bits -= 8;
	}

	/* High order bits. */
	gcode |= (*bp & rmask[bits]) << r_off;
	zs->zs_offset += zs->zs_n_bits;

	return (gcode);
}

/* Table clear for block compress. */
static int
cl_block(struct s_zstate *zs)
{
	long rat;

	zs->zs_checkpoint = zs->zs_in_count + CHECK_GAP;

	if (zs->zs_in_count > 0x007fffff) {	/* Shift will overflow. */
		rat = zs->zs_bytes_out >> 8;
		if (rat == 0)		/* Don't divide by zero. */
			rat = 0x7fffffff;
		else
			rat = zs->zs_in_count / rat;
	} else {
		/* 8 fractional bits. */
		rat = (zs->zs_in_count << 8) / zs->zs_bytes_out;
	}
	if (rat > zs->zs_ratio)
		zs->zs_ratio = rat;
	else {
		zs->zs_ratio = 0;
		cl_hash(zs, (count_int) zs->zs_hsize);
		zs->zs_free_ent = FIRST;
		zs->zs_clear_flg = 1;
		if (output(zs, (code_int) CLEAR) == -1)
			return (-1);
	}
	return (0);
}

/* Reset code table. */
static void
cl_hash(struct s_zstate *zs, count_int cl_hsize)
{
	count_int *htab_p;
	long i, m1;

	m1 = -1;
	htab_p = zs->zs_htab + cl_hsize;
	i = cl_hsize - 16;
	do {			/* Might use Sys V memset(3) here. */
		*(htab_p - 16) = m1;
		*(htab_p - 15) = m1;
		*(htab_p - 14) = m1;
		*(htab_p - 13) = m1;
		*(htab_p - 12) = m1;
		*(htab_p - 11) = m1;
		*(htab_p - 10) = m1;
		*(htab_p - 9) = m1;
		*(htab_p - 8) = m1;
		*(htab_p - 7) = m1;
		*(htab_p - 6) = m1;
		*(htab_p - 5) = m1;
		*(htab_p - 4) = m1;
		*(htab_p - 3) = m1;
		*(htab_p - 2) = m1;
		*(htab_p - 1) = m1;
		htab_p -= 16;
	} while ((i -= 16) >= 0);
	for (i += 16; i > 0; i--)
		*--htab_p = m1;
}

void *
z_wopen(int fd, char *name, int bits, u_int32_t mtime)
{
	struct s_zstate *zs;

	if (bits < 0 || bits > BITS) {
		errno = EINVAL;
		return (NULL);
	}

	if ((zs = calloc(1, sizeof(struct s_zstate))) == NULL)
		return (NULL);

	/* User settable max # bits/code. */
	zs->zs_maxbits = bits ? bits : BITS;
	/* Should NEVER generate this code. */
	zs->zs_maxmaxcode = 1 << zs->zs_maxbits;
	zs->zs_hsize = HSIZE;		/* For dynamic table sizing. */
	zs->zs_free_ent = 0;		/* First unused entry. */
	zs->zs_block_compress = BLOCK_MASK;
	zs->zs_clear_flg = 0;
	zs->zs_ratio = 0;
	zs->zs_checkpoint = CHECK_GAP;
	zs->zs_in_count = 0;		/* Length of input. */
	zs->zs_out_count = 0;		/* # of codes output (for debugging).*/
	zs->zs_state = S_START;
	zs->zs_offset = 0;
	zs->zs_size = 0;
	zs->zs_mode = 'w';
	zs->zs_bp = zs->zs_ebp = zs->zs_buf;

	zs->zs_fd = fd;
	return zs;
}

void *
z_ropen(int fd, char *name, int gotmagic)
{
	struct s_zstate *zs;

	if ((zs = calloc(1, sizeof(struct s_zstate))) == NULL)
		return (NULL);

	/* User settable max # bits/code. */
	zs->zs_maxbits = BITS;
	/* Should NEVER generate this code. */
	zs->zs_maxmaxcode = 1 << zs->zs_maxbits;
	zs->zs_hsize = HSIZE;		/* For dynamic table sizing. */
	zs->zs_free_ent = 0;		/* First unused entry. */
	zs->zs_block_compress = BLOCK_MASK;
	zs->zs_clear_flg = 0;
	zs->zs_ratio = 0;
	zs->zs_checkpoint = CHECK_GAP;
	zs->zs_in_count = 0;		/* Length of input. */
	zs->zs_out_count = 0;		/* # of codes output (for debugging).*/
	zs->zs_state = gotmagic ? S_MAGIC : S_START;
	zs->zs_offset = 0;
	zs->zs_size = 0;
	zs->zs_mode = 'r';
	zs->zs_bp = zs->zs_ebp = zs->zs_buf;

	zs->zs_fd = fd;
	return zs;
}
@


1.21
log
@start pulling apart some function pointers that take too many parameters
because of excessive code sharing. compression and decompression are not
entirely similar, they should share less.
ok joerg millert
@
text
@d1 1
a1 1
/*	$OpenBSD: zopen.c,v 1.20 2015/02/01 11:50:23 tobias Exp $	*/
a343 6
}

static int
zclose(void *cookie)
{
	return z_close(cookie, NULL, NULL, NULL);
@


1.20
log
@KNF whitespace fix and handle funopen error case.

ok millert
@
text
@d1 1
a1 1
/*	$OpenBSD: zopen.c,v 1.19 2015/01/16 06:40:06 deraadt Exp $	*/
a737 22
FILE *
zopen(const char *name, const char *mode, int bits)
{
	FILE *fp;
	int fd;
	void *cookie;
	if ((fd = open(name, (*mode=='r'? O_RDONLY:O_WRONLY|O_CREAT),
	    S_IRUSR|S_IWUSR|S_IRGRP|S_IROTH)) == -1)
		return NULL;
	if ((cookie = z_open(fd, mode, NULL, bits, 0, 0)) == NULL) {
		close(fd);
		return NULL;
	}
	if ((fp = funopen(cookie, (*mode == 'r'?zread:NULL),
	    (*mode == 'w'?zwrite:NULL), NULL, zclose)) == NULL) {
		close(fd);
		free(cookie);
		return NULL;
	}
	return fp;
}

d739 1
a739 2
z_open(int fd, const char *mode, char *name, int bits,
    u_int32_t mtime, int gotmagic)
d743 1
a743 2
	if ((mode[0] != 'r' && mode[0] != 'w') || mode[1] != '\0' ||
	    bits < 0 || bits > BITS) {
d763 30
d796 1
a796 1
	zs->zs_mode = mode[0];
@


1.19
log
@Replace <sys/param.h> with <limits.h> and other less dirty headers where
possible.  Annotate <sys/param.h> lines with their current reasons.  Switch
to PATH_MAX, NGROUPS_MAX, HOST_NAME_MAX+1, LOGIN_NAME_MAX, etc.  Change
MIN() and MAX() to local definitions of MINIMUM() and MAXIMUM() where
sensible to avoid pulling in the pollution.  These are the files confirmed
through binary verification.
ok guenther, millert, doug (helped with the verification protocol)
@
text
@d1 1
a1 1
/*	$OpenBSD: zopen.c,v 1.18 2011/09/22 10:41:04 deraadt Exp $	*/
d281 1
a281 1
			disp = 1;
d741 1
d751 7
a757 2
	return funopen(cookie, (*mode == 'r'?zread:NULL),
	    (*mode == 'w'?zwrite:NULL), NULL, zclose);
@


1.18
log
@Remove the rcsid which were intentionally skipped in the "purge of 2009"
because the -V command printed them... gut the -V (and -L, while there)
to be silent.
ok miod jsg
@
text
@d1 1
a1 1
/*	$OpenBSD: zopen.c,v 1.17 2005/08/25 17:07:56 millert Exp $	*/
a60 1
#include <sys/param.h>
d73 2
d640 1
a640 1
		zs->zs_size = MIN(zs->zs_n_bits, zs->zs_ebp - zs->zs_bp);
@


1.17
log
@Prevent zs_stackp from going past the end of zs_htab.  May happen
for corrupted files.  Based on a diff from miod@@;  OK mickey@@
@
text
@d1 1
a1 1
/*	$OpenBSD: zopen.c,v 1.16 2005/06/26 18:20:26 otto Exp $	*/
a37 7

#if 0
static char sccsid[] = "@@(#)zopen.c	8.1 (Berkeley) 6/27/93";
#else
const char z_rcsid[] =
	"$OpenBSD: zopen.c,v 1.16 2005/06/26 18:20:26 otto Exp $";
#endif
@


1.16
log
@be a bit more carefull not writing to the stream after the timestamps
have been set. ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: zopen.c,v 1.15 2005/04/17 16:17:39 deraadt Exp $	*/
d43 1
a43 1
	"$OpenBSD: zopen.c,v 1.15 2005/04/17 16:17:39 deraadt Exp $";
d113 2
a114 2
	count_int zs_htab [HSIZE];
	u_short zs_codetab [HSIZE];
d137 1
a137 1
		} w;			/* Write paramenters */
d560 9
@


1.15
log
@spacing
@
text
@d1 1
a1 1
/*	$OpenBSD: zopen.c,v 1.14 2003/08/03 01:26:46 deraadt Exp $	*/
d43 1
a43 1
	"$OpenBSD: zopen.c,v 1.14 2003/08/03 01:26:46 deraadt Exp $";
d316 1
a316 1
z_close(void *cookie, struct z_info *info)
d344 3
d355 1
a355 1
	return z_close(cookie, NULL);
@


1.14
log
@protos
@
text
@d1 1
a1 1
/*	$OpenBSD: zopen.c,v 1.13 2003/07/17 20:06:01 millert Exp $	*/
d43 1
a43 1
	"$OpenBSD: zopen.c,v 1.13 2003/07/17 20:06:01 millert Exp $";
d436 1
a436 1
						MAXCODE(zs->zs_n_bits);
d627 1
a627 1
					 (bp - zs->zs_buf))) < 0)
@


1.13
log
@o implement -l, -n and -N (including setting outfile + mtime)
o make -v behave like GNU gzip for compress/decompress stats
o write a full gzip header w/ mtime and file name
o for -t/-l just don't write data instead of writing to /dev/null
o exit code is now more consistent with GNU gzip
o a crc error on decompress no longer causes unlink(outfile)
mickey@@ OK
@
text
@d1 1
a1 1
/*	$OpenBSD: zopen.c,v 1.12 2003/07/11 02:31:18 millert Exp $	*/
d43 1
a43 1
	"$OpenBSD: zopen.c,v 1.12 2003/07/11 02:31:18 millert Exp $";
d349 1
a349 1
int
@


1.12
log
@Move magic number checking into main.c and make it work when
decompressing from a pipe.  Currently assumes that magic numbers
are 2 bytes but this is relatively easy to change as needed in the
future.  Discussed w/ mickey@@
@
text
@d1 1
a1 1
/*	$OpenBSD: zopen.c,v 1.11 2003/06/22 15:22:43 deraadt Exp $	*/
d43 1
a43 1
	"$OpenBSD: zopen.c,v 1.11 2003/06/22 15:22:43 deraadt Exp $";
d126 1
a126 1
	long zs_bytes_out;		/* Length of compressed output. */
d316 1
a316 1
zclose(void *cookie)
d335 9
d349 6
d511 1
d564 2
a565 1
			if (count-- == 0)
d567 1
d582 1
d629 1
d740 1
a740 1
	if ((cookie = z_open(fd, mode, bits, 0)) == NULL) {
d749 2
a750 1
z_open(int fd, const char *mode, int bits, int gotmagic)
d773 1
a773 1
	zs->zs_in_count = 1;		/* Length of input. */
@


1.11
log
@knf and ansi
@
text
@d1 1
a1 1
/*	$OpenBSD: zopen.c,v 1.10 2003/06/03 02:56:07 millert Exp $	*/
d43 1
a43 1
	"$OpenBSD: zopen.c,v 1.10 2003/06/03 02:56:07 millert Exp $";
d107 1
a107 1
		S_START, S_MIDDLE, S_EOF
d230 2
d473 10
d491 1
a491 2
	if (read(zs->zs_fd, header, sizeof(header)) != sizeof(header) ||
	    memcmp(header, z_magic, sizeof(z_magic)) != 0) {
d720 1
a720 1
	if ((cookie = z_open(fd, mode, bits)) == NULL) {
d729 1
a729 1
z_open(int fd, const char *mode, int bits)
d754 1
a754 1
	zs->zs_state = S_START;
a761 15
}

int
z_check_header(int fd, struct stat *sb, const char *ofn)
{
	int f;
	u_char buf[sizeof(z_magic)];
	off_t off = lseek(fd, 0, SEEK_CUR);

	f = (read(fd, buf, sizeof(buf)) == sizeof(buf) &&
	    !memcmp(buf, z_magic, sizeof(buf)));

	lseek (fd, off, SEEK_SET);

	return f;
@


1.10
log
@Remove the advertising clause in the UCB license which Berkeley
rescinded 22 July 1999.  Proofed by myself and Theo.
@
text
@d1 1
a1 1
/*	$OpenBSD: zopen.c,v 1.9 2002/12/08 16:07:54 mickey Exp $	*/
d43 1
a43 1
	"$OpenBSD: zopen.c,v 1.9 2002/12/08 16:07:54 mickey Exp $";
d217 1
a217 4
zwrite(cookie, wbp, num)
	void *cookie;
	const char *wbp;
	int num;
d259 1
a259 1
		     zs->zs_fcode *= 2L)
d273 1
a273 1
					      zs->zs_ent);
d314 1
a314 2
zclose(cookie)
	void *cookie;
d359 1
a359 3
output(zs, ocode)
	struct s_zstate *zs;
	code_int ocode;
d400 4
a403 4
		       /*
			* Write the whole buffer, because the input side won't
			* discover the size increase until after it has read it
			*/
d455 1
a455 4
zread(cookie, rbp, num)
	void *cookie;
	char *rbp;
	int num;
d513 1
a513 1
			     zs->zs_code--)
d564 1
a564 2
getcode(zs)
	struct s_zstate *zs;
d581 2
a582 1
			if (zs->zs_n_bits == zs->zs_maxbits)	/* Won't get any bigger now. */
d584 1
a584 1
			else
d637 1
d639 1
a639 2
cl_block(zs)			/* Table clear for block compress. */
	struct s_zstate *zs;
d651 4
a654 2
	} else
		rat = (zs->zs_in_count << 8) / zs->zs_bytes_out;	/* 8 fractional bits. */
d668 1
d670 1
a670 3
cl_hash(zs, cl_hsize)			/* Reset code table. */
	struct s_zstate *zs;
	count_int cl_hsize;
d702 1
a702 4
zopen(name, mode, bits)
	const char *name;
	const char *mode;
	int bits;
d707 1
a707 1
		       S_IRUSR|S_IWUSR|S_IRGRP|S_IROTH)) == -1)
d714 1
a714 1
		       (*mode == 'w'?zwrite:NULL), NULL, zclose);
d718 1
a718 4
z_open(fd, mode, bits)
	int fd;
	const char *mode;
	int bits;
d754 1
a754 4
z_check_header(fd, sb, ofn)
	int fd;
	struct stat *sb;
	const char *ofn;
d761 1
a761 1
	     !memcmp(buf, z_magic, sizeof(buf)));
@


1.9
log
@grop long option names, like gzip.
add most of the gzip's options (a few unimplemented yet).
some cleaning, etc.
millert@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: zopen.c,v 1.8 2002/02/16 21:27:45 millert Exp $	*/
d20 1
a20 5
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
d43 1
a43 1
	"$OpenBSD: zopen.c,v 1.8 2002/02/16 21:27:45 millert Exp $";
@


1.8
log
@Part one of userland __P removal.  Done with a simple regexp with some minor hand editing to make comments line up correctly.  Another pass is forthcoming that handles the cases that could not be done automatically.
@
text
@d1 1
a1 1
/*	$OpenBSD: zopen.c,v 1.7 2001/11/19 19:02:13 mpech Exp $	*/
d39 2
a42 1
#if defined(LIBC_SCCS) && !defined(lint)
d46 2
a47 1
static char rcsid[] = "$OpenBSD: zopen.c,v 1.7 2001/11/19 19:02:13 mpech Exp $";
a48 1
#endif /* LIBC_SCCS and not lint */
d93 1
a93 1
static u_char z_magic[] =
d190 1
a190 1
static void	cl_hash(struct s_zstate *, register count_int);
d199 1
a199 1
 * 	Modified Lempel-Ziv method (LZW).  Basically finds common
d283 1
a283 1
	
d349 1
a349 1
 * 	code:	A n_bits-bit integer.  If == -1, then EOF.  This assumes
d352 1
a352 1
 * 	Outputs code to the file.
d356 1
a356 1
 * 	Maintain a BITS character long buffer (so that 8 codes will
d572 1
a572 1
 * 	stdin
d574 1
a574 1
 * 	code or -1 is returned.
@


1.7
log
@kill more registers

millert@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: zopen.c,v 1.6 1999/03/04 15:04:45 mickey Exp $	*/
d45 1
a45 1
static char rcsid[] = "$OpenBSD: zopen.c,v 1.6 1999/03/04 15:04:45 mickey Exp $";
d188 4
a191 4
static int	cl_block __P((struct s_zstate *));
static void	cl_hash __P((struct s_zstate *, register count_int));
static code_int	getcode __P((struct s_zstate *));
static int	output __P((struct s_zstate *, code_int));
@


1.6
log
@improve i/o handling use 8192 bytes buffer (16384 does not help much)
this makes it faster than gzip in uncompress mode.
@
text
@d1 1
a1 1
/*	$OpenBSD: zopen.c,v 1.5 1997/07/06 20:23:00 mickey Exp $	*/
d45 1
a45 1
static char rcsid[] = "$OpenBSD: zopen.c,v 1.5 1997/07/06 20:23:00 mickey Exp $";
d188 4
a191 4
static int	cl_block __P((register struct s_zstate *));
static void	cl_hash __P((register struct s_zstate *, register count_int));
static code_int	getcode __P((register struct s_zstate *));
static int	output __P((register struct s_zstate *, code_int));
d225 2
a226 2
	register code_int i;
	register int c, disp;
d367 1
a367 1
	register struct s_zstate *zs;
d370 1
a370 1
	register int bits;
d373 2
a374 2
		register int r_off;
		register u_char *bp;
d469 1
a469 1
	register u_int count;
d577 1
a577 1
	register struct s_zstate *zs;
d579 3
a581 3
	register code_int gcode;
	register int r_off, bits;
	register u_char *bp;
d651 1
a651 1
	register struct s_zstate *zs;
d653 1
a653 1
	register long rat;
d680 2
a681 2
	register struct s_zstate *zs;
	register count_int cl_hsize;
d683 2
a684 2
	register count_int *htab_p;
	register long i, m1;
d737 1
a737 1
	register struct s_zstate *zs;
@


1.5
log
@do gzip
@
text
@d1 1
a1 1
/*	$OpenBSD: zopen.c,v 1.4 1997/01/19 17:25:14 millert Exp $	*/
d45 1
a45 1
static char rcsid[] = "$OpenBSD: zopen.c,v 1.4 1997/01/19 17:25:14 millert Exp $";
d86 1
a127 1
	int zs_offset;
d131 3
a133 1
	u_char zs_buf[BITS];
d142 1
a142 1
			u_char *zs_stackp;
d145 1
a145 1
			int zs_roffset, zs_size;
a159 1
#define zs_roffset	u.r.zs_roffset
d161 1
a231 3
	if (num == 0)
		return (0);

d235 5
a239 3
	if (zs->zs_state == S_MIDDLE)
		goto middle;
	zs->zs_state = S_MIDDLE;
d241 7
a247 6
	zs->zs_maxmaxcode = 1L << zs->zs_maxbits;
	if (write(zs->zs_fd, z_magic, sizeof(z_magic)) != sizeof(z_magic))
		return (-1);
	tmp = (u_char)(zs->zs_maxbits | zs->zs_block_compress);
	if (write(zs->zs_fd, &tmp, sizeof(tmp)) != sizeof(tmp))
		return (-1);
d249 24
a272 9
	zs->zs_offset = 0;
	zs->zs_bytes_out = 3;		/* Includes 3-byte header mojo. */
	zs->zs_out_count = 0;
	zs->zs_clear_flg = 0;
	zs->zs_ratio = 0;
	zs->zs_in_count = 1;
	zs->zs_checkpoint = CHECK_GAP;
	zs->zs_maxcode = MAXCODE(zs->zs_n_bits = INIT_BITS);
	zs->zs_free_ent = ((zs->zs_block_compress) ? FIRST : 256);
d274 17
a290 27
	zs->zs_ent = *bp++;
	--count;

	zs->zs_hshift = 0;
	for (zs->zs_fcode = (long)zs->zs_hsize; zs->zs_fcode < 65536L;
	     zs->zs_fcode *= 2L)
		zs->zs_hshift++;
	zs->zs_hshift = 8 - zs->zs_hshift; /* Set hash code range bound. */

	zs->zs_hsize_reg = zs->zs_hsize;
	cl_hash(zs, (count_int)zs->zs_hsize_reg);	/* Clear hash table. */

middle:	for (i = 0; count--;) {
		c = *bp++;
		zs->zs_in_count++;
		zs->zs_fcode = (long)(((long)c << zs->zs_maxbits) +
				      zs->zs_ent);
		i = ((c << zs->zs_hshift) ^ zs->zs_ent); /* Xor hashing. */

		if (htabof(i) == zs->zs_fcode) {
			zs->zs_ent = codetabof(i);
			continue;
		} else if ((long)htabof(i) < 0)	/* Empty slot. */
			goto nomatch;
		/* Secondary hash (after G. Knott). */
		disp = zs->zs_hsize_reg - i;
		if (i == 0)
d292 2
a293 2
probe:		if ((i -= disp) < 0)
			i += zs->zs_hsize_reg;
d295 7
a301 17
		if (htabof(i) == zs->zs_fcode) {
			zs->zs_ent = codetabof(i);
			continue;
		}
		if ((long)htabof(i) >= 0)
			goto probe;
nomatch:	if (output(zs, (code_int) zs->zs_ent) == -1)
			return (-1);
		zs->zs_out_count++;
		zs->zs_ent = c;
		if (zs->zs_free_ent < zs->zs_maxmaxcode) {
			/* code -> hashtable */
			codetabof(i) = zs->zs_free_ent++;
			htabof(i) = zs->zs_fcode;
		} else if ((count_int)zs->zs_in_count >=
		    zs->zs_checkpoint && zs->zs_block_compress) {
			if (cl_block(zs) == -1)
d303 11
d360 1
a360 1
static u_char lmask[9] =
d362 1
a362 1
static u_char rmask[9] =
d370 1
a370 2
	register int bits, r_off;
	register u_char *bp;
a371 3
	r_off = zs->zs_offset;
	bits = zs->zs_n_bits;
	bp = zs->zs_buf;
d373 3
d377 4
a380 2
		bp += (r_off >> 3);
		r_off &= 7;
d400 1
a400 7
			bp = zs->zs_buf;
			bits = zs->zs_n_bits;
			zs->zs_bytes_out += bits;
			if (write(zs->zs_fd, bp, bits) != bits)
				return (-1);
			bp += bits;
			bits = 0;
d414 2
a415 4
				if (write(zs->zs_fd, zs->zs_buf, zs->zs_n_bits)
				    != zs->zs_n_bits)
					return (-1);
				zs->zs_bytes_out += zs->zs_n_bits;
a416 1
			zs->zs_offset = 0;
d431 10
d443 5
a447 4
		if (zs->zs_offset > 0) {
			zs->zs_offset = (zs->zs_offset + 7) / 8;
			if (write(zs->zs_fd, zs->zs_buf, zs->zs_offset)
			    != zs->zs_offset)
d449 1
a449 1
			zs->zs_bytes_out += zs->zs_offset;
d452 1
d482 1
d583 1
a583 2
	bp = zs->zs_buf;
	if (zs->zs_clear_flg > 0 || zs->zs_roffset >= zs->zs_size ||
d585 2
d603 15
a617 4
		zs->zs_size = read(zs->zs_fd, zs->zs_buf, zs->zs_n_bits);
		if (zs->zs_size <= 0)			/* End of file. */
			return (-1);
		zs->zs_roffset = 0;
d621 3
a623 1
	r_off = zs->zs_roffset;
d644 1
a644 1
	zs->zs_roffset += zs->zs_n_bits;
d761 1
a761 1
	zs->zs_roffset = 0;
d764 1
@


1.4
log
@Minor cleanups to make gcc -Wall happier.
@
text
@d1 1
a1 1
/*	$OpenBSD: zopen.c,v 1.3 1996/09/22 20:05:19 tholo Exp $	*/
d45 1
a45 1
static char rcsid[] = "$OpenBSD: zopen.c,v 1.3 1996/09/22 20:05:19 tholo Exp $";
d81 2
d91 1
a91 2
typedef u_char char_type;
static char_type magic_header[] =
d106 1
a106 1
	FILE *zs_fp;			/* File stream for I/O */
d130 2
a131 2
	long zs_out_count;		/* # of codes output (for debugging). */
	char_type zs_buf[BITS];
d140 1
a140 1
			char_type *zs_stackp;
a143 1
			char_type zs_gbuf[BITS];
d149 11
a159 32
#define	fp		zs->zs_fp
#define	zmode		zs->zs_mode
#define	state		zs->zs_state
#define	n_bits		zs->zs_n_bits
#define	maxbits		zs->zs_maxbits
#define	maxcode		zs->zs_maxcode
#define	maxmaxcode	zs->zs_maxmaxcode
#define	htab		zs->zs_htab
#define	codetab		zs->zs_codetab
#define	hsize		zs->zs_hsize
#define	free_ent	zs->zs_free_ent
#define	block_compress	zs->zs_block_compress
#define	clear_flg	zs->zs_clear_flg
#define	ratio		zs->zs_ratio
#define	checkpoint	zs->zs_checkpoint
#define	offset		zs->zs_offset
#define	in_count	zs->zs_in_count
#define	bytes_out	zs->zs_bytes_out
#define	out_count	zs->zs_out_count
#define	buf		zs->zs_buf
#define	fcode		zs->u.w.zs_fcode
#define	hsize_reg	zs->u.w.zs_hsize_reg
#define	ent		zs->u.w.zs_ent
#define	hshift		zs->u.w.zs_hshift
#define	stackp		zs->u.r.zs_stackp
#define	finchar		zs->u.r.zs_finchar
#define	code		zs->u.r.zs_code
#define	oldcode		zs->u.r.zs_oldcode
#define	incode		zs->u.r.zs_incode
#define	roffset		zs->u.r.zs_roffset
#define	size		zs->u.r.zs_size
#define	gbuf		zs->u.r.zs_gbuf
d170 2
a171 2
#define	htabof(i)	htab[i]
#define	codetabof(i)	codetab[i]
d174 2
a175 2
#define	tab_suffixof(i)	((char_type *)(htab))[i]
#define	de_stack	((char_type *)&tab_suffixof(1 << BITS))
d186 4
a189 7
static int	cl_block __P((struct s_zstate *));
static void	cl_hash __P((struct s_zstate *, count_int));
static code_int	getcode __P((struct s_zstate *));
static int	output __P((struct s_zstate *, code_int));
static int	zclose __P((void *));
static int	zread __P((void *, char *, int));
static int	zwrite __P((void *, const char *, int));
d217 1
a217 1
static int
d236 1
a236 1
	if (state == S_MIDDLE)
d238 1
a238 1
	state = S_MIDDLE;
d240 2
a241 3
	maxmaxcode = 1L << maxbits;
	if (fwrite(magic_header,
	    sizeof(char), sizeof(magic_header), fp) != sizeof(magic_header))
d243 2
a244 2
	tmp = (u_char)(maxbits | block_compress);
	if (fwrite(&tmp, sizeof(char), sizeof(tmp), fp) != sizeof(tmp))
d247 9
a255 9
	offset = 0;
	bytes_out = 3;		/* Includes 3-byte header mojo. */
	out_count = 0;
	clear_flg = 0;
	ratio = 0;
	in_count = 1;
	checkpoint = CHECK_GAP;
	maxcode = MAXCODE(n_bits = INIT_BITS);
	free_ent = ((block_compress) ? FIRST : 256);
d257 1
a257 1
	ent = *bp++;
d260 5
a264 4
	hshift = 0;
	for (fcode = (long)hsize; fcode < 65536L; fcode *= 2L)
		hshift++;
	hshift = 8 - hshift;	/* Set hash code range bound. */
d266 2
a267 2
	hsize_reg = hsize;
	cl_hash(zs, (count_int)hsize_reg);	/* Clear hash table. */
d271 4
a274 3
		in_count++;
		fcode = (long)(((long)c << maxbits) + ent);
		i = ((c << hshift) ^ ent);	/* Xor hashing. */
d276 2
a277 2
		if (htabof(i) == fcode) {
			ent = codetabof(i);
d281 2
a282 1
		disp = hsize_reg - i;	/* Secondary hash (after G. Knott). */
d286 1
a286 1
			i += hsize_reg;
d288 2
a289 2
		if (htabof(i) == fcode) {
			ent = codetabof(i);
d294 1
a294 1
nomatch:	if (output(zs, (code_int) ent) == -1)
d296 8
a303 7
		out_count++;
		ent = c;
		if (free_ent < maxmaxcode) {
			codetabof(i) = free_ent++;	/* code -> hashtable */
			htabof(i) = fcode;
		} else if ((count_int)in_count >=
		    checkpoint && block_compress) {
d311 1
a311 1
static int
d319 3
a321 3
	if (zmode == 'w') {		/* Put out the final code. */
		if (output(zs, (code_int) ent) == -1) {
			(void)fclose(fp);
d325 1
a325 1
		out_count++;
d327 1
a327 1
			(void)fclose(fp);
d332 1
a332 1
	rval = fclose(fp) == EOF ? -1 : 0;
d352 1
a352 1
static char_type lmask[9] =
d354 1
a354 1
static char_type rmask[9] =
d359 1
a359 1
	struct s_zstate *zs;
d363 1
a363 1
	register char_type *bp;
d365 3
a367 3
	r_off = offset;
	bits = n_bits;
	bp = buf;
d380 1
a380 1
		/* Get any 8 bit parts in the middle (<=1 for up to 16 bits). */
d389 6
a394 6
		offset += n_bits;
		if (offset == (n_bits << 3)) {
			bp = buf;
			bits = n_bits;
			bytes_out += bits;
			if (fwrite(bp, sizeof(char), bits, fp) != bits)
d398 1
a398 1
			offset = 0;
d404 2
a405 1
		if (free_ent > maxcode || (clear_flg > 0)) {
d408 1
a408 1
			* discover the size increase until after it has read it.
d410 3
a412 2
			if (offset > 0) {
				if (fwrite(buf, 1, n_bits, fp) != n_bits)
d414 1
a414 1
				bytes_out += n_bits;
d416 1
a416 1
			offset = 0;
d418 4
a421 3
			if (clear_flg) {
				maxcode = MAXCODE(n_bits = INIT_BITS);
				clear_flg = 0;
d423 3
a425 3
				n_bits++;
				if (n_bits == maxbits)
					maxcode = maxmaxcode;
d427 2
a428 1
					maxcode = MAXCODE(n_bits);
d433 4
a436 3
		if (offset > 0) {
			offset = (offset + 7) / 8;
			if (fwrite(buf, 1, offset, fp) != offset)
d438 1
a438 1
			bytes_out += offset;
d440 1
a440 1
		offset = 0;
d451 1
a451 1
static int
d467 1
a467 1
	switch (state) {
d469 1
a469 1
		state = S_MIDDLE;
d478 2
a479 3
	if (fread(header,
	    sizeof(char), sizeof(header), fp) != sizeof(header) ||
	    memcmp(header, magic_header, sizeof(magic_header)) != 0) {
d483 5
a487 5
	maxbits = header[2];	/* Set -b from file. */
	block_compress = maxbits & BLOCK_MASK;
	maxbits &= BIT_MASK;
	maxmaxcode = 1L << maxbits;
	if (maxbits > BITS) {
d492 4
a495 4
	maxcode = MAXCODE(n_bits = INIT_BITS);
	for (code = 255; code >= 0; code--) {
		tab_prefixof(code) = 0;
		tab_suffixof(code) = (char_type) code;
d497 1
a497 1
	free_ent = block_compress ? FIRST : 256;
d499 2
a500 2
	finchar = oldcode = getcode(zs);
	if (oldcode == -1)	/* EOF already? */
d504 1
a504 1
	*bp++ = (u_char)finchar;
d506 1
a506 1
	stackp = de_stack;
d508 1
a508 1
	while ((code = getcode(zs)) > -1) {
d510 7
a516 6
		if ((code == CLEAR) && block_compress) {
			for (code = 255; code >= 0; code--)
				tab_prefixof(code) = 0;
			clear_flg = 1;
			free_ent = FIRST - 1;
			if ((code = getcode(zs)) == -1)	/* O, untimely death! */
d519 1
a519 1
		incode = code;
d522 3
a524 3
		if (code >= free_ent) {
			*stackp++ = finchar;
			code = oldcode;
d528 3
a530 3
		while (code >= 256) {
			*stackp++ = tab_suffixof(code);
			code = tab_prefixof(code);
d532 1
a532 1
		*stackp++ = finchar = tab_suffixof(code);
d538 2
a539 2
			*bp++ = *--stackp;
		} while (stackp > de_stack);
d542 4
a545 4
		if ((code = free_ent) < maxmaxcode) {
			tab_prefixof(code) = (u_short) oldcode;
			tab_suffixof(code) = finchar;
			free_ent = code + 1;
d549 1
a549 1
		oldcode = incode;
d551 1
a551 1
	state = S_EOF;
d564 1
a564 1
	struct s_zstate *zs;
d568 1
a568 1
	register char_type *bp;
d570 3
a572 2
	bp = gbuf;
	if (clear_flg > 0 || roffset >= size || free_ent > maxcode) {
d578 4
a581 4
		if (free_ent > maxcode) {
			n_bits++;
			if (n_bits == maxbits)	/* Won't get any bigger now. */
				maxcode = maxmaxcode;
d583 1
a583 1
				maxcode = MAXCODE(n_bits);
d585 3
a587 3
		if (clear_flg > 0) {
			maxcode = MAXCODE(n_bits = INIT_BITS);
			clear_flg = 0;
d589 2
a590 2
		size = fread(gbuf, 1, n_bits, fp);
		if (size <= 0)			/* End of file. */
d592 1
a592 1
		roffset = 0;
d594 1
a594 1
		size = (size << 3) - (n_bits - 1);
d596 2
a597 2
	r_off = roffset;
	bits = n_bits;
d617 1
a617 1
	roffset += n_bits;
d624 1
a624 1
	struct s_zstate *zs;
d628 1
a628 1
	checkpoint = in_count + CHECK_GAP;
d630 2
a631 2
	if (in_count > 0x007fffff) {	/* Shift will overflow. */
		rat = bytes_out >> 8;
d635 1
a635 1
			rat = in_count / rat;
d637 3
a639 3
		rat = (in_count << 8) / bytes_out;	/* 8 fractional bits. */
	if (rat > ratio)
		ratio = rat;
d641 4
a644 4
		ratio = 0;
		cl_hash(zs, (count_int) hsize);
		free_ent = FIRST;
		clear_flg = 1;
d653 1
a653 1
	struct s_zstate *zs;
d660 1
a660 1
	htab_p = htab + cl_hsize;
d686 20
a705 1
zdopen(fd, mode, bits)
d710 1
a710 1
	struct s_zstate *zs;
d721 16
a736 13
	maxbits = bits ? bits : BITS;	/* User settable max # bits/code. */
	maxmaxcode = 1 << maxbits;	/* Should NEVER generate this code. */
	hsize = HSIZE;			/* For dynamic table sizing. */
	free_ent = 0;			/* First unused entry. */
	block_compress = BLOCK_MASK;
	clear_flg = 0;
	ratio = 0;
	checkpoint = CHECK_GAP;
	in_count = 1;			/* Length of input. */
	out_count = 0;			/* # of codes output (for debugging). */
	state = S_START;
	roffset = 0;
	size = 0;
d738 2
a739 17
	/*
	 * Layering compress on top of stdio in order to provide buffering,
	 * and ensure that reads and write work with the data specified.
	 */
	if ((fp = fdopen(fd, mode)) == NULL) {
		free(zs);
		return (NULL);
	}
	switch (*mode) {
	case 'r':
		zmode = 'r';
		return (funopen(zs, zread, NULL, NULL, zclose));
	case 'w':
		zmode = 'w';
		return (funopen(zs, NULL, zwrite, NULL, zclose));
	}
	/* NOTREACHED */
d742 5
a746 4
FILE *
zopen(fname, mode, bits)
	const char *fname, *mode;
	int bits;
d748 3
a750 1
	struct s_zstate *zs;
d752 2
a753 5
	if ((mode[0] != 'r' && mode[0] != 'w') || mode[1] != '\0' ||
	    bits < 0 || bits > BITS) {
		errno = EINVAL;
		return (NULL);
	}
d755 1
a755 2
	if ((zs = calloc(1, sizeof(struct s_zstate))) == NULL)
		return (NULL);
d757 1
a757 31
	maxbits = bits ? bits : BITS;	/* User settable max # bits/code. */
	maxmaxcode = 1 << maxbits;	/* Should NEVER generate this code. */
	hsize = HSIZE;			/* For dynamic table sizing. */
	free_ent = 0;			/* First unused entry. */
	block_compress = BLOCK_MASK;
	clear_flg = 0;
	ratio = 0;
	checkpoint = CHECK_GAP;
	in_count = 1;			/* Length of input. */
	out_count = 0;			/* # of codes output (for debugging). */
	state = S_START;
	roffset = 0;
	size = 0;

	/*
	 * Layering compress on top of stdio in order to provide buffering,
	 * and ensure that reads and write work with the data specified.
	 */
	if ((fp = fopen(fname, mode)) == NULL) {
		free(zs);
		return (NULL);
	}
	switch (*mode) {
	case 'r':
		zmode = 'r';
		return (funopen(zs, zread, NULL, NULL, zclose));
	case 'w':
		zmode = 'w';
		return (funopen(zs, NULL, zwrite, NULL, zclose));
	}
	/* NOTREACHED */
@


1.3
log
@Add zdopen(); open a file descriptor
@
text
@d1 1
a1 1
/*	$OpenBSD: zopen.c,v 1.2 1996/06/26 05:32:22 deraadt Exp $	*/
d45 1
a45 1
static char rcsid[] = "$OpenBSD: zopen.c,v 1.2 1996/06/26 05:32:22 deraadt Exp $";
d397 1
a397 1
		*bp = (*bp & rmask[r_off]) | (ocode << r_off) & lmask[r_off];
d708 1
a708 1
	if (mode[0] != 'r' && mode[0] != 'w' || mode[1] != '\0' ||
d757 1
a757 1
	if (mode[0] != 'r' && mode[0] != 'w' || mode[1] != '\0' ||
@


1.2
log
@rcsid
@
text
@d1 1
a1 1
/*	$OpenBSD: zopen.c,v 1.5 1995/03/26 09:44:53 glass Exp $	*/
d45 1
a45 1
static char rcsid[] = "$OpenBSD: zopen.c,v 1.5 1995/03/26 09:44:53 glass Exp $";
d698 50
@


1.1
log
@Initial revision
@
text
@d1 1
d45 1
a45 1
static char rcsid[] = "$NetBSD: zopen.c,v 1.5 1995/03/26 09:44:53 glass Exp $";
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@
