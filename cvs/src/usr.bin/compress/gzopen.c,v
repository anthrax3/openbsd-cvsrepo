head	1.34;
access;
symbols
	OPENBSD_6_2:1.34.0.6
	OPENBSD_6_2_BASE:1.34
	OPENBSD_6_1:1.34.0.4
	OPENBSD_6_1_BASE:1.34
	OPENBSD_6_0:1.31.0.2
	OPENBSD_6_0_BASE:1.31
	OPENBSD_5_9:1.29.0.2
	OPENBSD_5_9_BASE:1.29
	OPENBSD_5_8:1.28.0.6
	OPENBSD_5_8_BASE:1.28
	OPENBSD_5_7:1.28.0.2
	OPENBSD_5_7_BASE:1.28
	OPENBSD_5_6:1.27.0.14
	OPENBSD_5_6_BASE:1.27
	OPENBSD_5_5:1.27.0.12
	OPENBSD_5_5_BASE:1.27
	OPENBSD_5_4:1.27.0.8
	OPENBSD_5_4_BASE:1.27
	OPENBSD_5_3:1.27.0.6
	OPENBSD_5_3_BASE:1.27
	OPENBSD_5_2:1.27.0.4
	OPENBSD_5_2_BASE:1.27
	OPENBSD_5_1_BASE:1.27
	OPENBSD_5_1:1.27.0.2
	OPENBSD_5_0:1.26.0.8
	OPENBSD_5_0_BASE:1.26
	OPENBSD_4_9:1.26.0.6
	OPENBSD_4_9_BASE:1.26
	OPENBSD_4_8:1.26.0.4
	OPENBSD_4_8_BASE:1.26
	OPENBSD_4_7:1.26.0.2
	OPENBSD_4_7_BASE:1.26
	OPENBSD_4_6:1.25.0.6
	OPENBSD_4_6_BASE:1.25
	OPENBSD_4_5:1.25.0.2
	OPENBSD_4_5_BASE:1.25
	OPENBSD_4_4:1.24.0.6
	OPENBSD_4_4_BASE:1.24
	OPENBSD_4_3:1.24.0.4
	OPENBSD_4_3_BASE:1.24
	OPENBSD_4_2:1.24.0.2
	OPENBSD_4_2_BASE:1.24
	OPENBSD_4_1:1.23.0.8
	OPENBSD_4_1_BASE:1.23
	OPENBSD_4_0:1.23.0.6
	OPENBSD_4_0_BASE:1.23
	OPENBSD_3_9:1.23.0.4
	OPENBSD_3_9_BASE:1.23
	OPENBSD_3_8:1.23.0.2
	OPENBSD_3_8_BASE:1.23
	OPENBSD_3_7:1.22.0.4
	OPENBSD_3_7_BASE:1.22
	OPENBSD_3_6:1.22.0.2
	OPENBSD_3_6_BASE:1.22
	OPENBSD_3_5:1.21.0.2
	OPENBSD_3_5_BASE:1.21
	OPENBSD_3_4:1.14.0.2
	OPENBSD_3_4_BASE:1.14
	OPENBSD_3_3:1.5.0.2
	OPENBSD_3_3_BASE:1.5
	OPENBSD_3_2:1.4.0.2
	OPENBSD_3_2_BASE:1.4
	OPENBSD_3_1:1.3.0.2
	OPENBSD_3_1_BASE:1.3
	OPENBSD_3_0:1.1.0.18
	OPENBSD_3_0_BASE:1.1
	OPENBSD_2_9_BASE:1.1
	OPENBSD_2_9:1.1.0.16
	OPENBSD_2_8:1.1.0.14
	OPENBSD_2_8_BASE:1.1
	OPENBSD_2_7:1.1.0.12
	OPENBSD_2_7_BASE:1.1
	OPENBSD_2_6:1.1.0.10
	OPENBSD_2_6_BASE:1.1
	OPENBSD_2_5:1.1.0.8
	OPENBSD_2_5_BASE:1.1
	OPENBSD_2_4:1.1.0.6
	OPENBSD_2_4_BASE:1.1
	OPENBSD_2_3:1.1.0.4
	OPENBSD_2_3_BASE:1.1
	OPENBSD_2_2:1.1.0.2
	OPENBSD_2_2_BASE:1.1;
locks; strict;
comment	@ * @;


1.34
date	2016.09.03.12.29.30;	author tedu;	state Exp;
branches;
next	1.33;
commitid	yxeZjOLfvUjJbqiu;

1.33
date	2016.09.03.11.41.10;	author tedu;	state Exp;
branches;
next	1.32;
commitid	NacWFWgKwtkfLhFL;

1.32
date	2016.08.17.12.02.38;	author millert;	state Exp;
branches;
next	1.31;
commitid	WEVVaDgv9UQRzGgw;

1.31
date	2016.04.29.13.50.35;	author millert;	state Exp;
branches;
next	1.30;
commitid	iBOfIXGlGHnsCOp5;

1.30
date	2016.04.28.14.21.24;	author millert;	state Exp;
branches;
next	1.29;
commitid	HpJb7nKzgEhvuY6D;

1.29
date	2015.08.20.22.32.41;	author deraadt;	state Exp;
branches;
next	1.28;
commitid	0Dp7Dy9FuNZesYo2;

1.28
date	2015.01.16.06.40.06;	author deraadt;	state Exp;
branches;
next	1.27;
commitid	Uu5nFG3wCl0LACBb;

1.27
date	2011.09.22.10.41.04;	author deraadt;	state Exp;
branches;
next	1.26;

1.26
date	2009.11.11.18.04.35;	author deraadt;	state Exp;
branches;
next	1.25;

1.25
date	2008.08.20.09.22.02;	author mpf;	state Exp;
branches;
next	1.24;

1.24
date	2007.03.19.13.02.18;	author pedro;	state Exp;
branches;
next	1.23;

1.23
date	2005.06.26.18.20.26;	author otto;	state Exp;
branches;
next	1.22;

1.22
date	2004.09.06.21.24.11;	author mickey;	state Exp;
branches;
next	1.21;

1.21
date	2004.02.23.21.07.30;	author deraadt;	state Exp;
branches;
next	1.20;

1.20
date	2003.12.16.23.25.02;	author henning;	state Exp;
branches;
next	1.19;

1.19
date	2003.12.16.22.46.25;	author henning;	state Exp;
branches;
next	1.18;

1.18
date	2003.12.16.22.38.40;	author henning;	state Exp;
branches;
next	1.17;

1.17
date	2003.12.09.07.34.55;	author millert;	state Exp;
branches;
next	1.16;

1.16
date	2003.11.21.21.54.46;	author millert;	state Exp;
branches;
next	1.15;

1.15
date	2003.11.14.22.29.53;	author millert;	state Exp;
branches;
next	1.14;

1.14
date	2003.07.17.20.17.02;	author mickey;	state Exp;
branches;
next	1.13;

1.13
date	2003.07.17.20.06.01;	author millert;	state Exp;
branches;
next	1.12;

1.12
date	2003.07.11.02.31.18;	author millert;	state Exp;
branches;
next	1.11;

1.11
date	2003.07.10.00.06.50;	author david;	state Exp;
branches;
next	1.10;

1.10
date	2003.07.08.00.30.12;	author mickey;	state Exp;
branches;
next	1.9;

1.9
date	2003.06.29.21.14.37;	author millert;	state Exp;
branches;
next	1.8;

1.8
date	2003.06.27.19.29.45;	author millert;	state Exp;
branches;
next	1.7;

1.7
date	2003.06.22.15.22.43;	author deraadt;	state Exp;
branches;
next	1.6;

1.6
date	2003.06.03.21.08.36;	author mickey;	state Exp;
branches;
next	1.5;

1.5
date	2002.12.08.16.07.54;	author mickey;	state Exp;
branches;
next	1.4;

1.4
date	2002.08.12.00.42.56;	author aaron;	state Exp;
branches;
next	1.3;

1.3
date	2002.02.16.21.27.45;	author millert;	state Exp;
branches;
next	1.2;

1.2
date	2001.11.19.19.02.13;	author mpech;	state Exp;
branches;
next	1.1;

1.1
date	97.07.06.20.22.57;	author mickey;	state Exp;
branches;
next	;


desc
@@


1.34
log
@the SMALL code made a half hearted effort to exclude compression code
but some of the write code remained. shuffle things around a bit to make
the exclusion more complete.
@
text
@/*	$OpenBSD: gzopen.c,v 1.33 2016/09/03 11:41:10 tedu Exp $	*/

/*
 * Copyright (c) 1997 Michael Shalayeff
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 */
/* this is partially derived from the zlib's gzio.c file, so the notice: */
/*
  zlib.h -- interface of the 'zlib' general purpose compression library
  version 1.0.4, Jul 24th, 1996.

  Copyright (C) 1995-1996 Jean-loup Gailly and Mark Adler

  This software is provided 'as-is', without any express or implied
  warranty.  In no event will the authors be held liable for any damages
  arising from the use of this software.

  Permission is granted to anyone to use this software for any purpose,
  including commercial applications, and to alter it and redistribute it
  freely, subject to the following restrictions:

  1. The origin of this software must not be misrepresented; you must not
     claim that you wrote the original software. If you use this software
     in a product, an acknowledgment in the product documentation would be
     appreciated but is not required.
  2. Altered source versions must be plainly marked as such, and must not be
     misrepresented as being the original software.
  3. This notice may not be removed or altered from any source distribution.

  Jean-loup Gailly        Mark Adler
  gzip@@prep.ai.mit.edu    madler@@alumni.caltech.edu


  The data format used by the zlib library is described by RFCs (Request for
  Comments) 1950 to 1952 in the files ftp://ds.internic.net/rfc/rfc1950.txt
  (zlib format), rfc1951.txt (deflate format) and rfc1952.txt (gzip format).
*/

#include <sys/stat.h>
#include <sys/uio.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <errno.h>
#include <unistd.h>
#include <limits.h>
#include <zlib.h>
#include "compress.h"

/* gzip flag byte */
#define ASCII_FLAG   0x01 /* bit 0 set: file probably ascii text */
#define HEAD_CRC     0x02 /* bit 1 set: header CRC present */
#define EXTRA_FIELD  0x04 /* bit 2 set: extra field present */
#define ORIG_NAME    0x08 /* bit 3 set: original file name present */
#define COMMENT      0x10 /* bit 4 set: file comment present */
#define RESERVED     0xE0 /* bits 5..7: reserved */

#define DEF_MEM_LEVEL 8
#define OS_CODE 0x03 /* unix */

typedef
struct gz_stream {
	int	z_fd;		/* .gz file */
	int	z_eof;		/* set if end of input file */
	z_stream z_stream;	/* libz stream */
	u_char	z_buf[Z_BUFSIZE]; /* i/o buffer */
	char	z_mode;		/* 'w' or 'r' */
	u_int32_t z_time;	/* timestamp (mtime) */
	u_int32_t z_crc;	/* crc32 of uncompressed data */
	u_int32_t z_hlen;	/* length of the gz header */
	u_int64_t z_total_in;	/* # bytes in */
	u_int64_t z_total_out;	/* # bytes out */
} gz_stream;

static const u_char gz_magic[2] = {0x1f, 0x8b}; /* gzip magic header */

static u_int32_t get_int32(gz_stream *);
static int get_header(gz_stream *, char *, int);
static int get_byte(gz_stream *);

void *
gz_ropen(int fd, char *name, int gotmagic)
{
	gz_stream *s;

	if (fd < 0)
		return NULL;

	if ((s = calloc(1, sizeof(gz_stream))) == NULL)
		return NULL;

	s->z_stream.zalloc = (alloc_func)0;
	s->z_stream.zfree = (free_func)0;
	s->z_stream.opaque = (voidpf)0;
	s->z_stream.next_in = Z_NULL;
	s->z_stream.next_out = Z_NULL;
	s->z_stream.avail_in = s->z_stream.avail_out = 0;
	s->z_fd = 0;
	s->z_eof = 0;
	s->z_time = 0;
	s->z_hlen = 0;
	s->z_total_in = 0;
	s->z_total_out = 0;
	s->z_crc = crc32(0L, Z_NULL, 0);
	s->z_mode = 'r';

	if (inflateInit2(&(s->z_stream), -MAX_WBITS) != Z_OK) {
		free (s);
		return NULL;
	}
	s->z_stream.next_in = s->z_buf;
	s->z_stream.avail_out = Z_BUFSIZE;

	errno = 0;
	s->z_fd = fd;

	/* read the .gz header */
	if (get_header(s, name, gotmagic) != 0) {
		gz_close(s, NULL, NULL, NULL);
		s = NULL;
	}

	return s;
}

static int
get_byte(gz_stream *s)
{
	if (s->z_eof)
		return EOF;

	if (s->z_stream.avail_in == 0) {
		errno = 0;
		s->z_stream.avail_in = read(s->z_fd, s->z_buf, Z_BUFSIZE);
		if ((int)s->z_stream.avail_in <= 0) {
			s->z_eof = 1;
			return EOF;
		}
		s->z_stream.next_in = s->z_buf;
	}
	s->z_stream.avail_in--;
	return *s->z_stream.next_in++;
}

static u_int32_t
get_int32(gz_stream *s)
{
	u_int32_t x;

	x  = ((u_int32_t)(get_byte(s) & 0xff));
	x |= ((u_int32_t)(get_byte(s) & 0xff))<<8;
	x |= ((u_int32_t)(get_byte(s) & 0xff))<<16;
	x |= ((u_int32_t)(get_byte(s) & 0xff))<<24;
	return x;
}

static int
get_header(gz_stream *s, char *name, int gotmagic)
{
	int method; /* method byte */
	int flags;  /* flags byte */
	char *ep;
	uInt len;
	int c;

	/* Check the gzip magic header */
	if (!gotmagic) {
		for (len = 0; len < 2; len++) {
			c = get_byte(s);
			if (c != gz_magic[len]) {
				errno = EFTYPE;
				return -1;
			}
		}
	}

	method = get_byte(s);
	flags = get_byte(s);
	if (method != Z_DEFLATED || (flags & RESERVED) != 0) {
		errno = EFTYPE;
		return -1;
	}

	/* Stash timestamp (mtime) */
	s->z_time = get_int32(s);

	/* Discard xflags and OS code */
	(void)get_byte(s);
	(void)get_byte(s);

	s->z_hlen += 10; /* magic, method, flags, time, xflags, OS code */
	if ((flags & EXTRA_FIELD) != 0) { /* skip the extra field */
		len  =  (uInt)get_byte(s);
		len += ((uInt)get_byte(s))<<8;
		s->z_hlen += 2;
		/* len is garbage if EOF but the loop below will quit anyway */
		while (len-- != 0 && get_byte(s) != EOF)
			s->z_hlen++;
	}

	if ((flags & ORIG_NAME) != 0) { /* read/save the original file name */
		if ((ep = name) != NULL)
			ep += PATH_MAX - 1;
		while ((c = get_byte(s)) != EOF) {
			s->z_hlen++;
			if (c == '\0')
				break;
			if (name < ep)
				*name++ = c;
		}
		if (name != NULL)
			*name = '\0';
	}

	if ((flags & COMMENT) != 0) {   /* skip the .gz file comment */
		while ((c = get_byte(s)) != EOF) {
			s->z_hlen++;
			if (c == '\0')
				break;
		}
	}

	if ((flags & HEAD_CRC) != 0) {  /* skip the header crc */
		(void)get_byte(s);
		(void)get_byte(s);
		s->z_hlen += 2;
	}

	if (s->z_eof) {
		errno = EFTYPE;
		return -1;
	}

	return 0;
}

int
gz_read(void *cookie, char *buf, int len)
{
	gz_stream *s = (gz_stream*)cookie;
	u_char *start = buf; /* starting point for crc computation */
	int error = Z_OK;

	s->z_stream.next_out = buf;
	s->z_stream.avail_out = len;

	while (error == Z_OK && !s->z_eof && s->z_stream.avail_out != 0) {

		if (s->z_stream.avail_in == 0) {

			errno = 0;
			s->z_stream.avail_in = read(s->z_fd, s->z_buf,
			    Z_BUFSIZE);
			if ((int)s->z_stream.avail_in <= 0)
				s->z_eof = 1;
			s->z_stream.next_in = s->z_buf;
		}

		error = inflate(&(s->z_stream), Z_NO_FLUSH);

		if (error == Z_DATA_ERROR) {
			errno = EINVAL;
			goto bad;
		}
		if (error == Z_BUF_ERROR) {
			errno = EIO;
			goto bad;
		}
		if (error == Z_STREAM_END) {
			/* Check CRC and original size */
			s->z_crc = crc32(s->z_crc, start,
			    (uInt)(s->z_stream.next_out - start));
			start = s->z_stream.next_out;

			if (get_int32(s) != s->z_crc) {
				errno = EINVAL;
				goto bad;
			}
			if (get_int32(s) != (u_int32_t)s->z_stream.total_out) {
				errno = EIO;
				return -1;
			}
			s->z_hlen += 2 * sizeof(int32_t);

			/* Add byte counts from the finished stream. */
			s->z_total_in += s->z_stream.total_in;
			s->z_total_out += s->z_stream.total_out;

			/* Check for the existence of an appended file. */
			if (get_header(s, NULL, 0) != 0) {
				s->z_eof = 1;
				break;
			}
			inflateReset(&(s->z_stream));
			s->z_crc = crc32(0L, Z_NULL, 0);
			error = Z_OK;
		}
	}
	s->z_crc = crc32(s->z_crc, start,
	    (uInt)(s->z_stream.next_out - start));
	len -= s->z_stream.avail_out;

	return (len);
bad:
	/* Add byte counts from the finished stream. */
	s->z_total_in += s->z_stream.total_in;
	s->z_total_out += s->z_stream.total_out;
	return (-1);
}

#ifndef SMALL
static int
put_int32(gz_stream *s, u_int32_t x)
{
	u_int32_t y = htole32(x);

	if (write(s->z_fd, &y, sizeof(y)) != sizeof(y))
		return Z_ERRNO;
	return 0;
}

static int
put_header(gz_stream *s, char *name, u_int32_t mtime, int bits)
{
	struct iovec iov[2];
	u_char buf[10];

	buf[0] = gz_magic[0];
	buf[1] = gz_magic[1];
	buf[2] = Z_DEFLATED;
	buf[3] = name ? ORIG_NAME : 0;
	buf[4] = mtime & 0xff;
	buf[5] = (mtime >> 8) & 0xff;
	buf[6] = (mtime >> 16) & 0xff;
	buf[7] = (mtime >> 24) & 0xff;
	buf[8] = bits == 1 ? 4 : bits == 9 ? 2 : 0;	/* xflags */
	buf[9] = OS_CODE;
	iov[0].iov_base = buf;
	iov[0].iov_len = sizeof(buf);
	s->z_hlen = sizeof(buf);

	if (name != NULL) {
		iov[1].iov_base = name;
		iov[1].iov_len = strlen(name) + 1;
		s->z_hlen += iov[1].iov_len;
	}
	if (writev(s->z_fd, iov, name ? 2 : 1) == -1)
		return (-1);
	return (0);
}

void *
gz_wopen(int fd, char *name, int bits, u_int32_t mtime)
{
	gz_stream *s;

	if (fd < 0)
		return NULL;

	if (bits < 0 || bits > Z_BEST_COMPRESSION) {
		errno = EINVAL;
		return NULL;
	}
	if ((s = calloc(1, sizeof(gz_stream))) == NULL)
		return NULL;

	s->z_stream.zalloc = (alloc_func)0;
	s->z_stream.zfree = (free_func)0;
	s->z_stream.opaque = (voidpf)0;
	s->z_stream.next_in = Z_NULL;
	s->z_stream.next_out = Z_NULL;
	s->z_stream.avail_in = s->z_stream.avail_out = 0;
	s->z_fd = 0;
	s->z_eof = 0;
	s->z_time = 0;
	s->z_hlen = 0;
	s->z_total_in = 0;
	s->z_total_out = 0;
	s->z_crc = crc32(0L, Z_NULL, 0);
	s->z_mode = 'w';

	/* windowBits is passed < 0 to suppress zlib header */
	if (deflateInit2(&(s->z_stream), bits, Z_DEFLATED,
			 -MAX_WBITS, DEF_MEM_LEVEL, 0) != Z_OK) {
		free (s);
		return NULL;
	}
	s->z_stream.next_out = s->z_buf;
	s->z_stream.avail_out = Z_BUFSIZE;

	errno = 0;
	s->z_fd = fd;

	/* write the .gz header */
	if (put_header(s, name, mtime, bits) != 0) {
		gz_close(s, NULL, NULL, NULL);
		s = NULL;
	}

	return s;
}
int
gz_write(void *cookie, const char *buf, int len)
{
	gz_stream *s = (gz_stream*)cookie;

	s->z_stream.next_in = (char *)buf;
	s->z_stream.avail_in = len;

	while (s->z_stream.avail_in != 0) {
		if (s->z_stream.avail_out == 0) {
			if (write(s->z_fd, s->z_buf, Z_BUFSIZE) != Z_BUFSIZE)
				break;
			s->z_stream.next_out = s->z_buf;
			s->z_stream.avail_out = Z_BUFSIZE;
		}
		if (deflate(&(s->z_stream), Z_NO_FLUSH) != Z_OK)
			break;
	}
	s->z_crc = crc32(s->z_crc, buf, len);

	return (int)(len - s->z_stream.avail_in);
}

int
gz_flush(void *cookie, int flush)
{
	gz_stream *s = (gz_stream*)cookie;
	size_t len;
	int done = 0;
	int err;

	if (s == NULL || s->z_mode != 'w') {
		errno = EBADF;
		return Z_ERRNO;
	}

	s->z_stream.avail_in = 0; /* should be zero already anyway */

	for (;;) {
		len = Z_BUFSIZE - s->z_stream.avail_out;

		if (len != 0) {
			if (write(s->z_fd, s->z_buf, len) != len)
				return Z_ERRNO;
			s->z_stream.next_out = s->z_buf;
			s->z_stream.avail_out = Z_BUFSIZE;
		}
		if (done)
			break;
		if ((err = deflate(&(s->z_stream), flush)) != Z_OK &&
		    err != Z_STREAM_END)
			return err;

		/* deflate has finished flushing only when it hasn't
		 * used up all the available space in the output buffer
		 */
		done = (s->z_stream.avail_out != 0 || err == Z_STREAM_END);
	}
	return 0;
}
#endif

int
gz_close(void *cookie, struct z_info *info, const char *name, struct stat *sb)
{
	gz_stream *s = (gz_stream*)cookie;
	int err = 0;

	if (s == NULL)
		return -1;

#ifndef SMALL
	if (s->z_mode == 'w' && (err = gz_flush (s, Z_FINISH)) == Z_OK) {
		if ((err = put_int32 (s, s->z_crc)) == Z_OK) {
			s->z_hlen += sizeof(int32_t);
			if ((err = put_int32 (s, s->z_stream.total_in)) == Z_OK)
				s->z_hlen += sizeof(int32_t);
		}
	}
#endif
	if (!err && s->z_stream.state != NULL) {
		if (s->z_mode == 'w')
#ifndef SMALL
			err = deflateEnd(&s->z_stream);
#else
			err = -1;
#endif
		else if (s->z_mode == 'r')
			err = inflateEnd(&s->z_stream);
	}

	if (info != NULL) {
		info->mtime = s->z_time;
		info->crc = s->z_crc;
		info->hlen = s->z_hlen;
		if (s->z_mode == 'r') {
			info->total_in = s->z_total_in;
			info->total_out = s->z_total_out;
		} else {
			info->total_in = s->z_stream.total_in;
			info->total_out = s->z_stream.total_out;
		}

	}

	setfile(name, s->z_fd, sb);
	if (!err)
		err = close(s->z_fd);
	else
		(void)close(s->z_fd);

	free(s);

	return err;
}

@


1.33
log
@start pulling apart some function pointers that take too many parameters
because of excessive code sharing. compression and decompression are not
entirely similar, they should share less.
ok joerg millert
@
text
@d1 1
a1 1
/*	$OpenBSD: gzopen.c,v 1.32 2016/08/17 12:02:38 millert Exp $	*/
a98 1
static int put_int32(gz_stream *, u_int32_t);
a100 1
static int put_header(gz_stream *, char *, u_int32_t, int);
a103 56
gz_wopen(int fd, char *name, int bits, u_int32_t mtime)
{
	gz_stream *s;

	if (fd < 0)
		return NULL;

	if (bits < 0 || bits > Z_BEST_COMPRESSION) {
		errno = EINVAL;
		return NULL;
	}
	if ((s = calloc(1, sizeof(gz_stream))) == NULL)
		return NULL;

	s->z_stream.zalloc = (alloc_func)0;
	s->z_stream.zfree = (free_func)0;
	s->z_stream.opaque = (voidpf)0;
	s->z_stream.next_in = Z_NULL;
	s->z_stream.next_out = Z_NULL;
	s->z_stream.avail_in = s->z_stream.avail_out = 0;
	s->z_fd = 0;
	s->z_eof = 0;
	s->z_time = 0;
	s->z_hlen = 0;
	s->z_total_in = 0;
	s->z_total_out = 0;
	s->z_crc = crc32(0L, Z_NULL, 0);
	s->z_mode = 'w';

#ifndef SMALL
	/* windowBits is passed < 0 to suppress zlib header */
	if (deflateInit2(&(s->z_stream), bits, Z_DEFLATED,
			 -MAX_WBITS, DEF_MEM_LEVEL, 0) != Z_OK) {
		free (s);
		return NULL;
	}
	s->z_stream.next_out = s->z_buf;
#else
	free(s);
	return (NULL);
#endif
	s->z_stream.avail_out = Z_BUFSIZE;

	errno = 0;
	s->z_fd = fd;

	/* write the .gz header */
	if (put_header(s, name, mtime, bits) != 0) {
		gz_close(s, NULL, NULL, NULL);
		s = NULL;
	}

	return s;
}

void *
a147 104
int
gz_close(void *cookie, struct z_info *info, const char *name, struct stat *sb)
{
	gz_stream *s = (gz_stream*)cookie;
	int err = 0;

	if (s == NULL)
		return -1;

#ifndef SMALL
	if (s->z_mode == 'w' && (err = gz_flush (s, Z_FINISH)) == Z_OK) {
		if ((err = put_int32 (s, s->z_crc)) == Z_OK) {
			s->z_hlen += sizeof(int32_t);
			if ((err = put_int32 (s, s->z_stream.total_in)) == Z_OK)
				s->z_hlen += sizeof(int32_t);
		}
	}
#endif
	if (!err && s->z_stream.state != NULL) {
		if (s->z_mode == 'w')
#ifndef SMALL
			err = deflateEnd(&s->z_stream);
#else
			err = -1;
#endif
		else if (s->z_mode == 'r')
			err = inflateEnd(&s->z_stream);
	}

	if (info != NULL) {
		info->mtime = s->z_time;
		info->crc = s->z_crc;
		info->hlen = s->z_hlen;
		if (s->z_mode == 'r') {
			info->total_in = s->z_total_in;
			info->total_out = s->z_total_out;
		} else {
			info->total_in = s->z_stream.total_in;
			info->total_out = s->z_stream.total_out;
		}

	}

	setfile(name, s->z_fd, sb);
	if (!err)
		err = close(s->z_fd);
	else
		(void)close(s->z_fd);

	free(s);

	return err;
}

#ifndef SMALL
int
gz_flush(void *cookie, int flush)
{
	gz_stream *s = (gz_stream*)cookie;
	size_t len;
	int done = 0;
	int err;

	if (s == NULL || s->z_mode != 'w') {
		errno = EBADF;
		return Z_ERRNO;
	}

	s->z_stream.avail_in = 0; /* should be zero already anyway */

	for (;;) {
		len = Z_BUFSIZE - s->z_stream.avail_out;

		if (len != 0) {
			if (write(s->z_fd, s->z_buf, len) != len)
				return Z_ERRNO;
			s->z_stream.next_out = s->z_buf;
			s->z_stream.avail_out = Z_BUFSIZE;
		}
		if (done)
			break;
		if ((err = deflate(&(s->z_stream), flush)) != Z_OK &&
		    err != Z_STREAM_END)
			return err;

		/* deflate has finished flushing only when it hasn't
		 * used up all the available space in the output buffer
		 */
		done = (s->z_stream.avail_out != 0 || err == Z_STREAM_END);
	}
	return 0;
}
#endif

static int
put_int32(gz_stream *s, u_int32_t x)
{
	u_int32_t y = htole32(x);

	if (write(s->z_fd, &y, sizeof(y)) != sizeof(y))
		return Z_ERRNO;
	return 0;
}

a258 30
static int
put_header(gz_stream *s, char *name, u_int32_t mtime, int bits)
{
	struct iovec iov[2];
	u_char buf[10];

	buf[0] = gz_magic[0];
	buf[1] = gz_magic[1];
	buf[2] = Z_DEFLATED;
	buf[3] = name ? ORIG_NAME : 0;
	buf[4] = mtime & 0xff;
	buf[5] = (mtime >> 8) & 0xff;
	buf[6] = (mtime >> 16) & 0xff;
	buf[7] = (mtime >> 24) & 0xff;
	buf[8] = bits == 1 ? 4 : bits == 9 ? 2 : 0;	/* xflags */
	buf[9] = OS_CODE;
	iov[0].iov_base = buf;
	iov[0].iov_len = sizeof(buf);
	s->z_hlen = sizeof(buf);

	if (name != NULL) {
		iov[1].iov_base = name;
		iov[1].iov_len = strlen(name) + 1;
		s->z_hlen += iov[1].iov_len;
	}
	if (writev(s->z_fd, iov, name ? 2 : 1) == -1)
		return (-1);
	return (0);
}

d333 91
a426 1
#ifndef SMALL
d445 39
d485 53
d539 1
@


1.32
log
@When returning the file size info, only use z_total_in/z_total_out
for the read (inflate) case where there might be multiple streams.
For the write (deflate) case there can only be a single stream so
just use the per-stream total_in/total_out.  Fixes "gzip -v" byte
counts.  OK henning@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: gzopen.c,v 1.31 2016/04/29 13:50:35 millert Exp $	*/
d106 1
a106 2
gz_open(int fd, const char *mode, char *name, int bits,
    u_int32_t mtime, int gotmagic)
d110 1
a110 1
	if (fd < 0 || !mode)
d113 1
a113 2
	if ((mode[0] != 'r' && mode[0] != 'w') || mode[1] != '\0' ||
	    bits < 0 || bits > Z_BEST_COMPRESSION) {
d133 1
a133 1
	s->z_mode = mode[0];
a134 1
	if (s->z_mode == 'w') {
d136 7
a142 7
		/* windowBits is passed < 0 to suppress zlib header */
		if (deflateInit2(&(s->z_stream), bits, Z_DEFLATED,
				 -MAX_WBITS, DEF_MEM_LEVEL, 0) != Z_OK) {
			free (s);
			return NULL;
		}
		s->z_stream.next_out = s->z_buf;
d144 2
a145 2
		free(s);
		return (NULL);
d147 43
a189 6
	} else {
		if (inflateInit2(&(s->z_stream), -MAX_WBITS) != Z_OK) {
			free (s);
			return NULL;
		}
		s->z_stream.next_in = s->z_buf;
d191 1
d197 4
a200 12
	if (s->z_mode == 'w') {
		/* write the .gz header */
		if (put_header(s, name, mtime, bits) != 0) {
			gz_close(s, NULL, NULL, NULL);
			s = NULL;
		}
	} else {
		/* read the .gz header */
		if (get_header(s, name, gotmagic) != 0) {
			gz_close(s, NULL, NULL, NULL);
			s = NULL;
		}
@


1.31
log
@Need to set in/out bytes count for gz_write too.  Otherwise gzip
will think the resulting file was got larger during compression.
@
text
@d1 1
a1 1
/*	$OpenBSD: gzopen.c,v 1.30 2016/04/28 14:21:24 millert Exp $	*/
d212 8
a219 2
		info->total_in = s->z_total_in;
		info->total_out = s->z_total_out;
a517 2
	s->z_total_in += s->z_stream.total_in;
	s->z_total_out += s->z_stream.total_out;
@


1.30
log
@Account for multiple streams in "gzip -l" output.  This fixes "gzip
-l" output when used on package files.  OK espie@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: gzopen.c,v 1.29 2015/08/20 22:32:41 deraadt Exp $	*/
d512 2
@


1.29
log
@Do not cast result of malloc/calloc/realloc* if stdlib.h is in scope
ok krw millert
@
text
@d1 1
a1 1
/*	$OpenBSD: gzopen.c,v 1.28 2015/01/16 06:40:06 deraadt Exp $	*/
d86 1
a87 1
	int	z_eof;		/* set if end of input file */
d89 1
d91 1
d93 2
a94 3
	u_int32_t z_crc;	/* crc32 of uncompressed data */
	char	z_mode;		/* 'w' or 'r' */

d132 2
d212 2
a213 2
		info->total_in = (off_t)s->z_stream.total_in;
		info->total_out = (off_t)s->z_stream.total_out;
d342 1
a342 1
	s->z_hlen = 10; /* magic, method, flags, time, xflags, OS code */
d444 1
a444 1
			return -1;
d448 1
a448 1
			return -1;
d458 1
a458 1
				return -1;
d465 5
d485 5
@


1.28
log
@Replace <sys/param.h> with <limits.h> and other less dirty headers where
possible.  Annotate <sys/param.h> lines with their current reasons.  Switch
to PATH_MAX, NGROUPS_MAX, HOST_NAME_MAX+1, LOGIN_NAME_MAX, etc.  Change
MIN() and MAX() to local definitions of MINIMUM() and MAXIMUM() where
sensible to avoid pulling in the pollution.  These are the files confirmed
through binary verification.
ok guenther, millert, doug (helped with the verification protocol)
@
text
@d1 1
a1 1
/*	$OpenBSD: gzopen.c,v 1.27 2011/09/22 10:41:04 deraadt Exp $	*/
d118 1
a118 1
	if ((s = (gz_stream *)calloc(1, sizeof(gz_stream))) == NULL)
@


1.27
log
@Remove the rcsid which were intentionally skipped in the "purge of 2009"
because the -V command printed them... gut the -V (and -L, while there)
to be silent.
ok miod jsg
@
text
@d1 1
a1 1
/*	$OpenBSD: gzopen.c,v 1.26 2009/11/11 18:04:35 deraadt Exp $	*/
a60 1
#include <sys/param.h>
d68 1
d351 1
a351 1
			ep += MAXPATHLEN - 1;
@


1.26
log
@memory leak with #ifdef SMALL, found by parfait
ok jsg
@
text
@d1 1
a1 1
/*	$OpenBSD: gzopen.c,v 1.25 2008/08/20 09:22:02 mpf Exp $	*/
a59 5

#ifndef SMALL
const char gz_rcsid[] =
    "$OpenBSD: gzopen.c,v 1.25 2008/08/20 09:22:02 mpf Exp $";
#endif
@


1.25
log
@Use and report errors that inflate(3) can return, instead of
aborting silently, and pretending everything went alright.
This lets gzip(1) (especially gzip -t) detect truncated archives
and curruptions that violate the structure of the zlib format.
Unquiet compress(1) in zless/zmore, so the user has a chance
to see errors on corrupted archives.
OK millert@@, markus@@
@
text
@d1 1
a1 1
/*	$OpenBSD: gzopen.c,v 1.24 2007/03/19 13:02:18 pedro Exp $	*/
d63 1
a63 1
    "$OpenBSD: gzopen.c,v 1.24 2007/03/19 13:02:18 pedro Exp $";
d149 1
@


1.24
log
@Fix check for failed read, and add another one; okay millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: gzopen.c,v 1.23 2005/06/26 18:20:26 otto Exp $	*/
d63 1
a63 1
    "$OpenBSD: gzopen.c,v 1.23 2005/06/26 18:20:26 otto Exp $";
d442 9
@


1.23
log
@be a bit more carefull not writing to the stream after the timestamps
have been set. ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: gzopen.c,v 1.22 2004/09/06 21:24:11 mickey Exp $	*/
d63 1
a63 1
    "$OpenBSD: gzopen.c,v 1.22 2004/09/06 21:24:11 mickey Exp $";
d287 1
a287 1
		if (s->z_stream.avail_in <= 0) {
d434 3
a436 2
			if ((s->z_stream.avail_in =
			    read(s->z_fd, s->z_buf, Z_BUFSIZE)) == 0)
@


1.22
log
@set the xflags; form netbsd; millert@@ deraadt@@ otto@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: gzopen.c,v 1.21 2004/02/23 21:07:30 deraadt Exp $	*/
d63 1
a63 1
    "$OpenBSD: gzopen.c,v 1.21 2004/02/23 21:07:30 deraadt Exp $";
d166 1
a166 1
			gz_close(s, NULL);
d172 1
a172 1
			gz_close(s, NULL);
d181 1
a181 1
gz_close(void *cookie, struct z_info *info)
d217 1
@


1.21
log
@knf
@
text
@d1 1
a1 1
/*	$OpenBSD: gzopen.c,v 1.20 2003/12/16 23:25:02 henning Exp $	*/
d63 1
a63 1
    "$OpenBSD: gzopen.c,v 1.20 2003/12/16 23:25:02 henning Exp $";
d106 1
a106 1
static int put_header(gz_stream *, char *, u_int32_t);
d165 1
a165 1
		if (put_header(s, name, mtime) != 0) {
d389 1
a389 1
put_header(gz_stream *s, char *name, u_int32_t mtime)
d402 1
a402 1
	buf[8] = 0 /* xflags */;
@


1.20
log
@really don't implement unzip #ifdef SMALL
this was in the tested diffs but slipped through when committing unfortunately,
sorry
@
text
@d1 1
a1 1
/*	$OpenBSD: gzopen.c,v 1.19 2003/12/16 22:46:25 henning Exp $	*/
d63 1
a63 1
    "$OpenBSD: gzopen.c,v 1.19 2003/12/16 22:46:25 henning Exp $";
d204 1
a204 1
#endif;
@


1.19
log
@do not include rcsids with -DSMALL and as it is meaningless then do not
implement -V then. following a discussion with millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: gzopen.c,v 1.18 2003/12/16 22:38:40 henning Exp $	*/
d63 1
a63 1
    "$OpenBSD: gzopen.c,v 1.18 2003/12/16 22:38:40 henning Exp $";
d140 1
d148 3
d189 1
d197 1
a197 1

d200 1
d202 3
d227 1
d265 1
d475 1
d494 1
@


1.18
log
@when we read the original file size from the gzp header in uncompress mode
and compare it to total_out to detect I/O errors we need to cast total_out
to u_int32_t as the gzip header file is limited to that and total_out is now
64 bits.
ok millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: gzopen.c,v 1.17 2003/12/09 07:34:55 millert Exp $	*/
d61 1
d63 2
a64 1
    "$OpenBSD: gzopen.c,v 1.17 2003/12/09 07:34:55 millert Exp $";
@


1.17
log
@Fixes based on a patch from Moritz Jodeit; mickey@@ OK
o break out of inflate() when we hit an error
o fix printf format #ifdef SMALL
o add version string of nullopen.c to -V output
o remove unnecessary initializations to 0 for variables cat and decomp
o beautify -l output to make it line up with the heading
@
text
@d1 1
a1 1
/*	$OpenBSD: gzopen.c,v 1.16 2003/11/21 21:54:46 millert Exp $	*/
d62 1
a62 1
    "$OpenBSD: gzopen.c,v 1.16 2003/11/21 21:54:46 millert Exp $";
d437 1
a437 1
			if (get_int32(s) != s->z_stream.total_out) {
@


1.16
log
@Simplified support for concatenated files; similar to what zlib does.
mickey@@ OK
@
text
@d1 1
a1 1
/*	$OpenBSD: gzopen.c,v 1.15 2003/11/14 22:29:53 millert Exp $	*/
d62 1
a62 1
    "$OpenBSD: gzopen.c,v 1.15 2003/11/14 22:29:53 millert Exp $";
d410 1
d415 1
a415 1
	while (s->z_stream.avail_out != 0 && !s->z_eof) {
d426 2
a427 1
		if (inflate(&(s->z_stream), Z_NO_FLUSH) == Z_STREAM_END) {
d449 1
@


1.15
log
@Add support for inflating multiple concatenated file like GNU gzip does.
Problem noticed by lebel@@, OK mickey@@
@
text
@d1 1
a1 1
/*	$OpenBSD: gzopen.c,v 1.14 2003/07/17 20:17:02 mickey Exp $	*/
d62 1
a62 1
    "$OpenBSD: gzopen.c,v 1.14 2003/07/17 20:17:02 mickey Exp $";
d440 7
a446 2
			s->z_eof = 1;
			break;
a451 13

	/* If at EOF, check for another appended file. */
	if (s->z_eof) {
		int ocrc = s->z_crc;
		s->z_crc = crc32(0L, Z_NULL, 0);
		s->z_eof = 0;
		if (get_header(s, NULL, 0) != 0 ||
		    inflateEnd(&s->z_stream) != Z_OK ||
		    inflateInit2(&s->z_stream, -MAX_WBITS) != Z_OK) {
			s->z_eof = 1;
			s->z_crc = ocrc;
		}
	}
@


1.14
log
@two calls is less than a loop for two; millert@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: gzopen.c,v 1.13 2003/07/17 20:06:01 millert Exp $	*/
d62 1
a62 1
    "$OpenBSD: gzopen.c,v 1.13 2003/07/17 20:06:01 millert Exp $";
d446 1
d448 14
a461 1
	return (int)(len - s->z_stream.avail_out);
@


1.13
log
@o implement -l, -n and -N (including setting outfile + mtime)
o make -v behave like GNU gzip for compress/decompress stats
o write a full gzip header w/ mtime and file name
o for -t/-l just don't write data instead of writing to /dev/null
o exit code is now more consistent with GNU gzip
o a crc error on decompress no longer causes unlink(outfile)
mickey@@ OK
@
text
@d1 1
a1 1
/*	$OpenBSD: gzopen.c,v 1.12 2003/07/11 02:31:18 millert Exp $	*/
d62 1
a62 1
    "$OpenBSD: gzopen.c,v 1.12 2003/07/11 02:31:18 millert Exp $";
d362 2
a363 2
		for (len = 0; len < 2; len++)
			(void)get_byte(s);
@


1.12
log
@Move magic number checking into main.c and make it work when
decompressing from a pipe.  Currently assumes that magic numbers
are 2 bytes but this is relatively easy to change as needed in the
future.  Discussed w/ mickey@@
@
text
@d1 1
a1 1
/*	$OpenBSD: gzopen.c,v 1.11 2003/07/10 00:06:50 david Exp $	*/
d62 1
a62 1
    "$OpenBSD: gzopen.c,v 1.11 2003/07/10 00:06:50 david Exp $";
d64 1
a64 1
#include <sys/types.h>
d66 1
d92 2
d103 2
a104 1
static int get_header(gz_stream *, int);
d108 2
a109 1
gz_open(int fd, const char *mode, int bits, int gotmagic)
d132 2
d158 3
a160 11
		u_char buf[10];
		/* Write a very simple .gz header: */
		buf[0] = gz_magic[0];
		buf[1] = gz_magic[1];
		buf[2] = Z_DEFLATED;
		buf[3] = 0 /*flags*/;
		buf[4] = buf[5] = buf[6] = buf[7] = 0 /*time*/;
		buf[8] = 0 /*xflags*/;
		buf[9] = OS_CODE;
		if (write(fd, buf, sizeof(buf)) != sizeof(buf)) {
			gz_close(s);
d164 3
a166 2
		if (get_header(s, gotmagic) != 0) { /* skip the .gz header */
			gz_close (s);
d175 1
a175 1
gz_close(void *cookie)
d184 5
a188 2
		if ((err = put_int32 (s, s->z_crc)) == Z_OK)
			err = put_int32 (s, s->z_stream.total_in);
d198 8
d296 1
a296 1
get_header(gz_stream *s, int gotmagic)
d300 1
d322 6
a327 3
	/* Discard time, xflags and OS code: */
	for (len = 0; len < 6; len++)
		(void)get_byte(s);
d329 1
d333 1
d336 1
a336 1
			;
d339 12
a350 2
	if ((flags & ORIG_NAME) != 0) { /* skip the original file name */
		while ((c = get_byte(s)) != 0 && c != EOF) ;
d354 5
a358 1
		while ((c = get_byte(s)) != 0 && c != EOF) ;
d362 3
a364 1
		for (len = 0; len < 2; len++) (void)get_byte(s);
d375 30
d439 1
a471 1

@


1.11
log
@add missing includes
ok deraadt@@ tedu@@
@
text
@d1 1
a1 1
/*	$OpenBSD: gzopen.c,v 1.10 2003/07/08 00:30:12 mickey Exp $	*/
d62 1
a62 1
    "$OpenBSD: gzopen.c,v 1.10 2003/07/08 00:30:12 mickey Exp $";
d100 1
a100 1
static int get_header(gz_stream *);
a102 15
int
gz_check_header(int fd, struct stat *sb, const char *ofn)
{
	int f;
	u_char buf[sizeof(gz_magic)];
	off_t off = lseek(fd, 0, SEEK_CUR);

	f = (read(fd, buf, sizeof(buf)) == sizeof(buf) &&
	    !memcmp(buf, gz_magic, sizeof(buf)));

	lseek (fd, off, SEEK_SET);

	return f;
}

d104 1
a104 1
gz_open(int fd, const char *mode, int bits)
d165 1
a165 1
		if (get_header(s) != 0) { /* skip the .gz header */
d285 1
a285 1
get_header(gz_stream *s)
d293 7
a299 5
	for (len = 0; len < 2; len++) {
		c = get_byte(s);
		if (c != gz_magic[len]) {
			errno = EFTYPE;
			return -1;
@


1.10
log
@fix fd closing logicand close in gzopen(); found by wilfried@@ and millert@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: gzopen.c,v 1.9 2003/06/29 21:14:37 millert Exp $	*/
d62 1
a62 1
    "$OpenBSD: gzopen.c,v 1.9 2003/06/29 21:14:37 millert Exp $";
d68 1
@


1.9
log
@Return EINVAL on crc failure for gzip and make the driver program
interpret this correctly.  Makes "gzip -t" more useful.  Discussed
with deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: gzopen.c,v 1.8 2003/06/27 19:29:45 millert Exp $	*/
d62 1
a62 1
    "$OpenBSD: gzopen.c,v 1.8 2003/06/27 19:29:45 millert Exp $";
d208 5
@


1.8
log
@Fix bug in put_int32() on big endian cpus; deraadt@@ OK
@
text
@d1 1
a1 1
/*	$OpenBSD: gzopen.c,v 1.7 2003/06/22 15:22:43 deraadt Exp $	*/
d62 1
a62 1
    "$OpenBSD: gzopen.c,v 1.7 2003/06/22 15:22:43 deraadt Exp $";
d375 5
a379 2
			if (get_int32(s) != s->z_crc ||
			    get_int32(s) != s->z_stream.total_out) {
@


1.7
log
@knf and ansi
@
text
@d1 1
a1 1
/*	$OpenBSD: gzopen.c,v 1.6 2003/06/03 21:08:36 mickey Exp $	*/
d62 1
a62 1
    "$OpenBSD: gzopen.c,v 1.6 2003/06/03 21:08:36 mickey Exp $";
d255 3
a257 10
	if (write(s->z_fd, &x, 1) != 1)
		return Z_ERRNO;
	x >>= 8;
	if (write(s->z_fd, &x, 1) != 1)
		return Z_ERRNO;
	x >>= 8;
	if (write(s->z_fd, &x, 1) != 1)
		return Z_ERRNO;
	x >>= 8;
	if (write(s->z_fd, &x, 1) != 1)
@


1.6
log
@three four kills
@
text
@d1 1
a1 1
/*	$OpenBSD: gzopen.c,v 1.5 2002/12/08 16:07:54 mickey Exp $	*/
d62 1
a62 1
    "$OpenBSD: gzopen.c,v 1.5 2002/12/08 16:07:54 mickey Exp $";
d103 1
a103 4
gz_check_header(fd, sb, ofn)
	int fd;
	struct stat *sb;
	const char *ofn;
d110 1
a110 1
	     !memcmp(buf, gz_magic, sizeof(buf)));
d118 1
a118 4
gz_open (fd, mode, bits)
	int fd;
	const char *mode;
	int  bits;
d189 1
a189 2
gz_close (cookie)
	void *cookie;
d215 1
a215 3
gz_flush (cookie, flush)
    void *cookie;
    int flush;
d253 1
a253 3
put_int32 (s, x)
	gz_stream *s;
	u_int32_t x;
d270 1
a270 2
get_byte(s)
	gz_stream *s;
d289 1
a289 2
get_int32 (s)
	gz_stream *s;
d301 1
a301 2
get_header(s)
	gz_stream *s;
d357 1
a357 4
gz_read(cookie, buf, len)
	void *cookie;
	char *buf;
	int len;
d371 1
a371 1
			     read(s->z_fd, s->z_buf, Z_BUFSIZE)) == 0)
d379 1
a379 1
				       (uInt)(s->z_stream.next_out - start));
d384 1
a384 1
			        errno = EIO;
d392 1
a392 1
			 (uInt)(s->z_stream.next_out - start));
d398 1
a398 4
gz_write(cookie, buf, len)
	void *cookie;
	const char *buf;
	int len;
a405 1

a406 1

@


1.5
log
@grop long option names, like gzip.
add most of the gzip's options (a few unimplemented yet).
some cleaning, etc.
millert@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: gzopen.c,v 1.4 2002/08/12 00:42:56 aaron Exp $	*/
a14 5
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by Michael Shalayeff.
 * 4. The name of the author may not be used to endorse or promote products
 *    derived from this software without specific prior written permission.
d62 1
a62 1
    "$OpenBSD: gzopen.c,v 1.1 1997/07/06 20:22:57 mickey Exp $";
@


1.4
log
@Swap args to calloc(3) so they are in the correct order; art@@ ok.
@
text
@d1 1
a1 1
/*	$OpenBSD: gzopen.c,v 1.3 2002/02/16 21:27:45 millert Exp $	*/
d21 2
a22 2
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR 
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED 
d66 3
d100 1
a100 1
static u_char gz_magic[2] = {0x1f, 0x8b}; /* gzip magic header */
d291 1
a291 1
	
d305 1
a305 1
static u_int32_t 
@


1.3
log
@Part one of userland __P removal.  Done with a simple regexp with some minor hand editing to make comments line up correctly.  Another pass is forthcoming that handles the cases that could not be done automatically.
@
text
@d1 1
a1 1
/*	$OpenBSD: gzopen.c,v 1.2 2001/11/19 19:02:13 mpech Exp $	*/
d138 1
a138 1
	if ((s = (gz_stream *)calloc(sizeof(gz_stream), 1)) == NULL)
@


1.2
log
@kill more registers

millert@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: gzopen.c,v 1.1 1997/07/06 20:22:57 mickey Exp $	*/
d99 4
a102 4
static int put_int32 __P((gz_stream *, u_int32_t));
static u_int32_t get_int32 __P((gz_stream *));
static int get_header __P((gz_stream *));
static int get_byte __P((gz_stream *));
@


1.1
log
@do gzip
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d99 4
a102 4
static int put_int32 __P((register gz_stream *, u_int32_t));
static u_int32_t get_int32 __P((register gz_stream *));
static int get_header __P((register gz_stream *));
static int get_byte __P((register gz_stream *));
d200 1
a200 1
	register gz_stream *s = (gz_stream*)cookie;
d228 1
a228 1
	register gz_stream *s = (gz_stream*)cookie;
d265 1
a265 1
	register gz_stream *s;
d284 1
a284 1
	register gz_stream *s;
d304 1
a304 1
	register gz_stream *s;
d306 1
a306 1
	register u_int32_t x;
d317 1
a317 1
	register gz_stream *s;
d378 1
a378 1
	register gz_stream *s = (gz_stream*)cookie;
d422 1
a422 1
	register gz_stream *s = (gz_stream*)cookie;
@

