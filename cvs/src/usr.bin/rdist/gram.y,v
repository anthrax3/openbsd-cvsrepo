head	1.12;
access;
symbols
	OPENBSD_6_2:1.12.0.14
	OPENBSD_6_2_BASE:1.12
	OPENBSD_6_1:1.12.0.12
	OPENBSD_6_1_BASE:1.12
	OPENBSD_6_0:1.12.0.8
	OPENBSD_6_0_BASE:1.12
	OPENBSD_5_9:1.12.0.4
	OPENBSD_5_9_BASE:1.12
	OPENBSD_5_8:1.12.0.6
	OPENBSD_5_8_BASE:1.12
	OPENBSD_5_7:1.12.0.2
	OPENBSD_5_7_BASE:1.12
	OPENBSD_5_6:1.11.0.4
	OPENBSD_5_6_BASE:1.11
	OPENBSD_5_5:1.10.0.8
	OPENBSD_5_5_BASE:1.10
	OPENBSD_5_4:1.10.0.4
	OPENBSD_5_4_BASE:1.10
	OPENBSD_5_3:1.10.0.2
	OPENBSD_5_3_BASE:1.10
	OPENBSD_5_2:1.9.0.12
	OPENBSD_5_2_BASE:1.9
	OPENBSD_5_1_BASE:1.9
	OPENBSD_5_1:1.9.0.10
	OPENBSD_5_0:1.9.0.8
	OPENBSD_5_0_BASE:1.9
	OPENBSD_4_9:1.9.0.6
	OPENBSD_4_9_BASE:1.9
	OPENBSD_4_8:1.9.0.4
	OPENBSD_4_8_BASE:1.9
	OPENBSD_4_7:1.9.0.2
	OPENBSD_4_7_BASE:1.9
	OPENBSD_4_6:1.8.0.28
	OPENBSD_4_6_BASE:1.8
	OPENBSD_4_5:1.8.0.24
	OPENBSD_4_5_BASE:1.8
	OPENBSD_4_4:1.8.0.22
	OPENBSD_4_4_BASE:1.8
	OPENBSD_4_3:1.8.0.20
	OPENBSD_4_3_BASE:1.8
	OPENBSD_4_2:1.8.0.18
	OPENBSD_4_2_BASE:1.8
	OPENBSD_4_1:1.8.0.16
	OPENBSD_4_1_BASE:1.8
	OPENBSD_4_0:1.8.0.14
	OPENBSD_4_0_BASE:1.8
	OPENBSD_3_9:1.8.0.12
	OPENBSD_3_9_BASE:1.8
	OPENBSD_3_8:1.8.0.10
	OPENBSD_3_8_BASE:1.8
	OPENBSD_3_7:1.8.0.8
	OPENBSD_3_7_BASE:1.8
	OPENBSD_3_6:1.8.0.6
	OPENBSD_3_6_BASE:1.8
	OPENBSD_3_5:1.8.0.4
	OPENBSD_3_5_BASE:1.8
	OPENBSD_3_4:1.8.0.2
	OPENBSD_3_4_BASE:1.8
	OPENBSD_3_3:1.5.0.4
	OPENBSD_3_3_BASE:1.5
	OPENBSD_3_2:1.5.0.2
	OPENBSD_3_2_BASE:1.5
	OPENBSD_3_1:1.4.0.16
	OPENBSD_3_1_BASE:1.4
	OPENBSD_3_0:1.4.0.14
	OPENBSD_3_0_BASE:1.4
	OPENBSD_2_9_BASE:1.4
	OPENBSD_2_9:1.4.0.12
	OPENBSD_2_8:1.4.0.10
	OPENBSD_2_8_BASE:1.4
	OPENBSD_2_7:1.4.0.8
	OPENBSD_2_7_BASE:1.4
	OPENBSD_2_6:1.4.0.6
	OPENBSD_2_6_BASE:1.4
	OPENBSD_2_5:1.4.0.4
	OPENBSD_2_5_BASE:1.4
	OPENBSD_2_4:1.4.0.2
	OPENBSD_2_4_BASE:1.4
	OPENBSD_2_3:1.3.0.8
	OPENBSD_2_3_BASE:1.3
	OPENBSD_2_2:1.3.0.6
	OPENBSD_2_2_BASE:1.3
	OPENBSD_2_1:1.3.0.4
	OPENBSD_2_1_BASE:1.3
	OPENBSD_2_0:1.3.0.2
	OPENBSD_2_0_BASE:1.3
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.12
date	2015.01.20.09.00.16;	author guenther;	state Exp;
branches;
next	1.11;
commitid	0Y0sKBv6c3xIKoav;

1.11
date	2014.06.07.15.28.21;	author deraadt;	state Exp;
branches;
next	1.10;
commitid	XIEOO52crMNWEnEb;

1.10
date	2012.11.12.01.14.41;	author guenther;	state Exp;
branches;
next	1.9;

1.9
date	2009.10.27.23.59.42;	author deraadt;	state Exp;
branches;
next	1.8;

1.8
date	2003.06.03.02.56.14;	author millert;	state Exp;
branches;
next	1.7;

1.7
date	2003.05.14.01.34.35;	author millert;	state Exp;
branches;
next	1.6;

1.6
date	2003.05.06.22.10.11;	author millert;	state Exp;
branches;
next	1.5;

1.5
date	2002.05.30.07.36.44;	author deraadt;	state Exp;
branches;
next	1.4;

1.4
date	98.06.26.21.21.11;	author millert;	state Exp;
branches;
next	1.3;

1.3
date	96.03.05.03.16.05;	author dm;	state Exp;
branches;
next	1.2;

1.2
date	96.02.03.12.12.26;	author dm;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.45.59;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.45.59;	author deraadt;	state Exp;
branches;
next	;


desc
@@


1.12
log
@Split out from rdist/defs.h the client-only and server-only bits into
 rdist/client.h and rdistd/server.h
Only put #includes in .h files that are necessary for the .h to be used;
 all other #includes go in the .c files
Move all extern variable declarations to the .h files, renaming local
 variables to avoid shadowing
Replace me_type member of mntent_t with an "is NFS?" flag bit
@
text
@%{
/*	$OpenBSD: gram.y,v 1.11 2014/06/07 15:28:21 deraadt Exp $	*/

/*
 * Copyright (c) 1993 Michael A. Cooper
 * Copyright (c) 1993 Regents of the University of California.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */

#include "client.h"

static struct namelist *addnl(struct namelist *, struct namelist *);
static struct namelist *subnl(struct namelist *, struct namelist *);
static struct namelist *andnl(struct namelist *, struct namelist *);
static int innl(struct namelist *nl, char *p);

struct	cmd *cmds = NULL;
struct	cmd *last_cmd;
struct	namelist *last_n;
struct	subcmd *last_sc;
int	parendepth = 0;

%}

%term ARROW		1
%term COLON		2
%term DCOLON		3
%term NAME		4
%term STRING		5
%term INSTALL		6
%term NOTIFY		7
%term EXCEPT		8
%term PATTERN		9
%term SPECIAL		10
%term CMDSPECIAL	11
%term OPTION		12

%union {
	opt_t 			optval;
	char 		       *string;
	struct subcmd 	       *subcmd;
	struct namelist        *namel;
}

%type <optval> OPTION, options
%type <string> NAME, STRING
%type <subcmd> INSTALL, NOTIFY, EXCEPT, PATTERN, SPECIAL, CMDSPECIAL, cmdlist, cmd
%type <namel> namelist, names, opt_namelist nlist

%%

file:		  /* VOID */
		| file command
		;

command:	  NAME '=' namelist = {
			(void) lookup($1, INSERT, $3);
		}
		| namelist ARROW namelist cmdlist = {
			insert((char *)NULL, $1, $3, $4);
		}
		| NAME COLON namelist ARROW namelist cmdlist = {
			insert($1, $3, $5, $6);
		}
		| namelist DCOLON NAME cmdlist = {
			append((char *)NULL, $1, $3, $4);
		}
		| NAME COLON namelist DCOLON NAME cmdlist = {
			append($1, $3, $5, $6);
		}
		| error
		;

namelist: 	nlist { 
			$$ = $1; 
		}
		| nlist '-' nlist { 
			$$ = subnl($1, $3); 
		}
		| nlist '+' nlist { 
			$$ = addnl($1, $3); 
		}
		| nlist '&' nlist { 
			$$ = andnl($1, $3); 
		}
		;

nlist:	  NAME = {
			$$ = makenl($1);
		}
		| '(' names ')' = {
			$$ = $2;
		}
		;

names:		  /* VOID */ {
			$$ = last_n = NULL;
		}
		| names NAME = {
			if (last_n == NULL)
				$$ = last_n = makenl($2);
			else {
				last_n->n_next = makenl($2);
				last_n = last_n->n_next;
				$$ = $1;
			}
		}
		;

cmdlist:	  /* VOID */ {
			$$ = last_sc = NULL;
		}
		| cmdlist cmd = {
			if (last_sc == NULL)
				$$ = last_sc = $2;
			else {
				last_sc->sc_next = $2;
				last_sc = $2;
				$$ = $1;
			}
		}
		;

cmd:		  INSTALL options opt_namelist ';' = {
			struct namelist *nl;

			$1->sc_options = $2 | options;
			if ($3 != NULL) {
				nl = expand($3, E_VARS);
				if (nl) {
					if (nl->n_next != NULL)
					    yyerror("only one name allowed\n");
					$1->sc_name = nl->n_name;
					free(nl);
				} else
					$1->sc_name = NULL;
			}
			$$ = $1;
		}
		| NOTIFY namelist ';' = {
			if ($2 != NULL)
				$1->sc_args = expand($2, E_VARS);
			$$ = $1;
		}
		| EXCEPT namelist ';' = {
			if ($2 != NULL)
				$1->sc_args = expand($2, E_ALL);
			$$ = $1;
		}
		| PATTERN namelist ';' = {
			struct namelist *nl;
			char ebuf[BUFSIZ];
			regex_t reg;
			int ecode;

			for (nl = $2; nl != NULL; nl = nl->n_next) {
				/* check for a valid regex */
				ecode = regcomp(&reg, nl->n_name, REG_NOSUB);
				if (ecode) {
					regerror(ecode, &reg, ebuf,
					    sizeof(ebuf));
					yyerror(ebuf);
				}
				regfree(&reg);
			}
			$1->sc_args = expand($2, E_VARS);
			$$ = $1;
		}
		| SPECIAL opt_namelist STRING ';' = {
			if ($2 != NULL)
				$1->sc_args = expand($2, E_ALL);
			$1->sc_name = $3;
			$$ = $1;
		}
		| CMDSPECIAL opt_namelist STRING ';' = {
			if ($2 != NULL)
				$1->sc_args = expand($2, E_ALL);
			$1->sc_name = $3;
			$$ = $1;
		}
		;

options:	  /* VOID */ = {
			$$ = 0;
		}
		| options OPTION = {
			$$ |= $2;
		}
		;

opt_namelist:	  /* VOID */ = {
			$$ = NULL;
		}
		| namelist = {
			$$ = $1;
		}
		;

%%

int	yylineno = 1;
extern	FILE *fin;

int
yylex(void)
{
	static char yytext[INMAX];
	int c;
	char *cp1, *cp2;
	static char quotechars[] = "[]{}*?$";
	
again:
	switch (c = getc(fin)) {
	case EOF:  /* end of file */
		return(0);

	case '#':  /* start of comment */
		while ((c = getc(fin)) != EOF && c != '\n')
			;
		if (c == EOF)
			return(0);
	case '\n':
		yylineno++;
	case ' ':
	case '\t':  /* skip blanks */
		goto again;

	case '=':  /* EQUAL */
	case ';':  /* SM */
	case '+': 
	case '&': 
		return(c);

	case '(':  /* LP */
		++parendepth;
		return(c);

	case ')':  /* RP */
		--parendepth;
		return(c);

	case '-':  /* -> */
		if ((c = getc(fin)) == '>')
			return(ARROW);
		(void) ungetc(c, fin);
		c = '-';
		break;

	case '"':  /* STRING */
		cp1 = yytext;
		cp2 = &yytext[INMAX - 1];
		for (;;) {
			if (cp1 >= cp2) {
				yyerror("command string too long\n");
				break;
			}
			c = getc(fin);
			if (c == EOF || c == '"')
				break;
			if (c == '\\') {
				if ((c = getc(fin)) == EOF) {
					*cp1++ = '\\';
					break;
				}
			}
			if (c == '\n') {
				yylineno++;
				c = ' '; /* can't send '\n' */
			}
			*cp1++ = c;
		}
		if (c != '"')
			yyerror("missing closing '\"'\n");
		*cp1 = '\0';
		yylval.string = xstrdup(yytext);
		return(STRING);

	case ':':  /* : or :: */
		if ((c = getc(fin)) == ':')
			return(DCOLON);
		(void) ungetc(c, fin);
		return(COLON);
	}
	cp1 = yytext;
	cp2 = &yytext[INMAX - 1];
	for (;;) {
		if (cp1 >= cp2) {
			yyerror("input line too long\n");
			break;
		}
		if (c == '\\') {
			if ((c = getc(fin)) != EOF) {
				if (any(c, quotechars))
					*cp1++ = QUOTECHAR;
			} else {
				*cp1++ = '\\';
				break;
			}
		}
		*cp1++ = c;
		c = getc(fin);
		if (c == EOF || any(c, " \"'\t()=;:\n")) {
			(void) ungetc(c, fin);
			break;
		}
	}
	*cp1 = '\0';
	if (yytext[0] == '-' && yytext[1] == CNULL) 
		return '-';
	if (yytext[0] == '-' && parendepth <= 0) {
		opt_t opt = 0;
		static char ebuf[BUFSIZ];

		switch (yytext[1]) {
		case 'o':
			if (parsedistopts(&yytext[2], &opt, TRUE)) {
				(void) snprintf(ebuf, sizeof(ebuf),
					        "Bad distfile options \"%s\".", 
					        &yytext[2]);
				yyerror(ebuf);
			}
			break;

			/*
			 * These options are obsoleted by -o.
			 */
		case 'b':	opt = DO_COMPARE;		break;
		case 'R':	opt = DO_REMOVE;		break;
		case 'v':	opt = DO_VERIFY;		break;
		case 'w':	opt = DO_WHOLE;			break;
		case 'y':	opt = DO_YOUNGER;		break;
		case 'h':	opt = DO_FOLLOW;		break;
		case 'i':	opt = DO_IGNLNKS;		break;
		case 'q':	opt = DO_QUIET;			break;
		case 'x':	opt = DO_NOEXEC;		break;
		case 'N':	opt = DO_CHKNFS;		break;
		case 'O':	opt = DO_CHKREADONLY;		break;
		case 's':	opt = DO_SAVETARGETS;		break;
		case 'r':	opt = DO_NODESCEND;		break;

		default:
			(void) snprintf(ebuf, sizeof(ebuf),
					"Unknown option \"%s\".", yytext);
			yyerror(ebuf);
		}

		yylval.optval = opt;
		return(OPTION);
	}
	if (!strcmp(yytext, "install"))
		c = INSTALL;
	else if (!strcmp(yytext, "notify"))
		c = NOTIFY;
	else if (!strcmp(yytext, "except"))
		c = EXCEPT;
	else if (!strcmp(yytext, "except_pat"))
		c = PATTERN;
	else if (!strcmp(yytext, "special"))
		c = SPECIAL;
	else if (!strcmp(yytext, "cmdspecial"))
		c = CMDSPECIAL;
	else {
		yylval.string = xstrdup(yytext);
		return(NAME);
	}
	yylval.subcmd = makesubcmd(c);
	return(c);
}

/*
 * XXX We should use strchr(), but most versions can't handle
 * some of the characters we use.
 */
int any(int c, char *str)
{
	while (*str)
		if (c == *str++)
			return(1);
	return(0);
}

/*
 * Insert or append ARROW command to list of hosts to be updated.
 */
void
insert(char *label, struct namelist *files, struct namelist *hosts,
    struct subcmd *scmds)
{
	struct cmd *c, *prev, *nc;
	struct namelist *h, *lasth;

	debugmsg(DM_CALL, "insert(%s, %p, %p, %p) start, files = %s", 
		 label == NULL ? "(null)" : label,
		 files, hosts, scmds, getnlstr(files));

	files = expand(files, E_VARS|E_SHELL);
	hosts = expand(hosts, E_ALL);
	for (h = hosts; h != NULL; lasth = h, h = h->n_next, 
	     free((char *)lasth)) {
		/*
		 * Search command list for an update to the same host.
		 */
		for (prev = NULL, c = cmds; c!=NULL; prev = c, c = c->c_next) {
			if (strcmp(c->c_name, h->n_name) == 0) {
				do {
					prev = c;
					c = c->c_next;
				} while (c != NULL &&
					strcmp(c->c_name, h->n_name) == 0);
				break;
			}
		}
		/*
		 * Insert new command to update host.
		 */
		nc = ALLOC(cmd);
		nc->c_type = ARROW;
		nc->c_name = h->n_name;
		nc->c_label = label;
		nc->c_files = files;
		nc->c_cmds = scmds;
		nc->c_flags = 0;
		nc->c_next = c;
		if (prev == NULL)
			cmds = nc;
		else
			prev->c_next = nc;
		/* update last_cmd if appending nc to cmds */
		if (c == NULL)
			last_cmd = nc;
	}
}

/*
 * Append DCOLON command to the end of the command list since these are always
 * executed in the order they appear in the distfile.
 */
void
append(char *label, struct namelist *files, char *stamp, struct subcmd *scmds)
{
	struct cmd *c;

	c = ALLOC(cmd);
	c->c_type = DCOLON;
	c->c_name = stamp;
	c->c_label = label;
	c->c_files = expand(files, E_ALL);
	c->c_cmds = scmds;
	c->c_next = NULL;
	if (cmds == NULL)
		cmds = last_cmd = c;
	else {
		last_cmd->c_next = c;
		last_cmd = c;
	}
}

/*
 * Error printing routine in parser.
 */
void
yyerror(char *s)
{
	error("Error in distfile: line %d: %s", yylineno, s);
}

/*
 * Allocate a namelist structure.
 */
struct namelist *
makenl(char *name)
{
	struct namelist *nl;

	debugmsg(DM_CALL, "makenl(%s)", name == NULL ? "null" : name);

	nl = ALLOC(namelist);
	nl->n_name = name;
	nl->n_regex = NULL;
	nl->n_next = NULL;

	return(nl);
}


/*
 * Is the name p in the namelist nl?
 */
static int
innl(struct namelist *nl, char *p)
{
	for ( ; nl; nl = nl->n_next)
		if (!strcmp(p, nl->n_name))
			return(1);
	return(0);
}

/*
 * Join two namelists.
 */
static struct namelist *
addnl(struct namelist *n1, struct namelist *n2)
{
	struct namelist *nl, *prev;

	n1 = expand(n1, E_VARS);
	n2 = expand(n2, E_VARS);
	for (prev = NULL, nl = NULL; n1; n1 = n1->n_next, prev = nl) {
		nl = makenl(n1->n_name);
		nl->n_next = prev;
	}
	for (; n2; n2 = n2->n_next)
		if (!innl(nl, n2->n_name)) {
			nl = makenl(n2->n_name);
			nl->n_next = prev;
			prev = nl;
		}
	return(prev);
}

/*
 * Copy n1 except for elements that are in n2.
 */
static struct namelist *
subnl(struct namelist *n1, struct namelist *n2)
{
	struct namelist *nl, *prev;

	n1 = expand(n1, E_VARS);
	n2 = expand(n2, E_VARS);
	for (prev = NULL; n1; n1 = n1->n_next)
		if (!innl(n2, n1->n_name)) {
			nl = makenl(n1->n_name);
			nl->n_next = prev;
			prev = nl;
		}
	return(prev);
}

/*
 * Copy all items of n1 that are also in n2.
 */
static struct namelist *
andnl(struct namelist *n1, struct namelist *n2)
{
	struct namelist *nl, *prev;

	n1 = expand(n1, E_VARS);
	n2 = expand(n2, E_VARS);
	for (prev = NULL; n1; n1 = n1->n_next)
		if (innl(n2, n1->n_name)) {
			nl = makenl(n1->n_name);
			nl->n_next = prev;
			prev = nl;
		}
	return(prev);
}

/*
 * Make a sub command for lists of variables, commands, etc.
 */
struct subcmd *
makesubcmd(int type)
{
	struct subcmd *sc;

	sc = ALLOC(subcmd);
	sc->sc_type = type;
	sc->sc_args = NULL;
	sc->sc_next = NULL;
	sc->sc_name = NULL;

	return(sc);
}
@


1.11
log
@remove last few uses of __P
@
text
@d2 1
a2 1
/*	$OpenBSD: gram.y,v 1.10 2012/11/12 01:14:41 guenther Exp $	*/
d34 1
a34 1
#include "defs.h"
d411 1
a411 1
    struct subcmd *subcmds)
d418 1
a418 1
		 files, hosts, subcmds, getnlstr(files));
d445 1
a445 1
		nc->c_cmds = subcmds;
d463 1
a463 1
append(char *label, struct namelist *files, char *stamp, struct subcmd *subcmds)
d472 1
a472 1
	c->c_cmds = subcmds;
@


1.10
log
@Fix various format string issues.  Stop assuming time_t is long or smaller.
Enable warnings.

ok krw@@, ian@@
@
text
@d2 1
a2 1
/*	$OpenBSD: gram.y,v 1.9 2009/10/27 23:59:42 deraadt Exp $	*/
d36 4
a39 4
static struct namelist *addnl __P((struct namelist *, struct namelist *));
static struct namelist *subnl __P((struct namelist *, struct namelist *));
static struct namelist *andnl __P((struct namelist *, struct namelist *));
static int innl __P((struct namelist *nl, char *p));
@


1.9
log
@rcsid[] and sccsid[] and copyright[] are essentially unmaintained (and
unmaintainable).  these days, people use source.  these id's do not provide
any benefit, and do hurt the small install media
(the 33,000 line diff is essentially mechanical)
ok with the idea millert, ok dms
@
text
@d2 1
a2 1
/*	$OpenBSD: gram.y,v 1.8 2003/06/03 02:56:14 millert Exp $	*/
d416 1
a416 1
	debugmsg(DM_CALL, "insert(%s, %x, %x, %x) start, files = %s", 
@


1.8
log
@Remove the advertising clause in the UCB license which Berkeley
rescinded 22 July 1999.  Proofed by myself and Theo.
@
text
@d2 1
a2 1
/*	$OpenBSD: gram.y,v 1.7 2003/05/14 01:34:35 millert Exp $	*/
a34 18

#ifndef lint
#if 0
static char RCSid[] __attribute__((__unused__)) = 
"$From: gram.y,v 1.3 1999/08/04 15:57:33 christos Exp $";
#else
static char RCSid[] __attribute__((__unused__)) = 
"$OpenBSD: gram.y,v 1.7 2003/05/14 01:34:35 millert Exp $";
#endif

static	char *sccsid __attribute__((__unused__)) =
"@@(#)gram.y	5.2 (Berkeley) 85/06/21";

static char copyright[] __attribute__((__unused__)) =
"@@(#) Copyright (c) 1983 Regents of the University of California.\n\
 All rights reserved.\n";
#endif /* not lint */

@


1.7
log
@ o Sync w/ freerdist 0.92 minus the compress option
 o KNF and ANSIfy the function headers

Sparse file support is currently a no-op since it didn't work.
Proper sparse file support will be added later.
@
text
@d2 1
a2 1
/*	$OpenBSD: gram.y,v 1.6 2003/05/06 22:10:11 millert Exp $	*/
d17 1
a17 5
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
d42 1
a42 1
"$OpenBSD: gram.y,v 1.6 2003/05/06 22:10:11 millert Exp $";
@


1.6
log
@use POSIX regex
@
text
@d2 1
a2 1
/*	$OpenBSD: gram.y,v 1.5 2002/05/30 07:36:44 deraadt Exp $	*/
d38 2
d42 2
a43 2
static char RCSid[] = 
"$From: gram.y,v 6.29 1994/04/11 23:59:15 mcooper Exp mcooper $";
d45 2
a46 2
static char RCSid[] = 
"$OpenBSD: gram.y,v 1.5 2002/05/30 07:36:44 deraadt Exp $";
d49 2
a50 1
static	char *sccsid = "@@(#)gram.y	5.2 (Berkeley) 85/06/21";
d52 1
a52 1
static char copyright[] =
a56 6
/*
 * Tell defs.h not to include y.tab.h
 */
#ifndef yacc
#define yacc
#endif
d58 4
a61 1
#include "defs.h"
a62 1
static struct namelist *addnl(), *subnl(), *andnl();
d171 1
a171 1
			register struct namelist *nl;
d250 2
a251 1
yylex()
d254 2
a255 2
	register int c;
	register char *cp1, *cp2;
d321 1
a321 1
		yylval.string = makestr(yytext);
d363 3
a365 3
				(void) snprintf(ebuf, sizeof ebuf,
					       "Bad distfile options \"%s\".", 
					       &yytext[2]);
d388 2
a389 2
			(void) snprintf(ebuf, sizeof ebuf,
				"Unknown option \"%s\".", yytext);
d409 1
a409 1
		yylval.string = makestr(yytext);
d420 1
a420 3
extern int any(c, str)
	register int c;
	register char *str;
d432 2
a433 4
insert(label, files, hosts, subcmds)
	char *label;
	struct namelist *files, *hosts;
	struct subcmd *subcmds;
d435 2
a436 2
	register struct cmd *c, *prev, *nc;
	register struct namelist *h, *lasth;
d485 1
a485 5
append(label, files, stamp, subcmds)
	char *label;
	struct namelist *files;
	char *stamp;
	struct subcmd *subcmds;
d487 1
a487 1
	register struct cmd *c;
d508 1
a508 2
yyerror(s)
	char *s;
a513 16
 * Return a copy of the string.
 */
char *
makestr(str)
	char *str;
{
	char *cp;

	cp = strdup(str);
	if (cp == NULL)
		fatalerr("ran out of memory");

	return(cp);
}

/*
d517 1
a517 2
makenl(name)
	char *name;
d519 1
a519 1
	register struct namelist *nl;
d536 1
a536 3
innl(nl, p)
	struct namelist *nl;
	char *p;
d548 1
a548 2
addnl(n1, n2)
	struct namelist *n1, *n2;
d571 1
a571 2
subnl(n1, n2)
	struct namelist *n1, *n2;
d590 1
a590 2
andnl(n1, n2)
	struct namelist *n1, *n2;
d608 2
a609 3
extern struct subcmd *
makesubcmd(type)
	int type;
d611 1
a611 1
	register struct subcmd *sc;
@


1.5
log
@snprintf in .y files
@
text
@d2 1
a2 1
/*	$OpenBSD: gram.y,v 1.4 1998/06/26 21:21:11 millert Exp $	*/
d44 1
a44 1
"$OpenBSD: gram.y,v 1.4 1998/06/26 21:21:11 millert Exp $";
d199 14
a212 5
			char *cp, *re_comp();

			for (nl = $2; nl != NULL; nl = nl->n_next)
				if ((cp = re_comp(nl->n_name)) != NULL)
					yyerror(cp);
d551 1
@


1.4
log
@rdist 6.1.4 + OpenBSD patches + some -Wall
@
text
@d2 1
a2 1
/*	$OpenBSD$	*/
d44 1
a44 1
"$OpenBSD$";
d354 1
a354 1
				(void) sprintf(ebuf, 
d379 2
a380 1
			(void) sprintf(ebuf, "Unknown option \"%s\".", yytext);
@


1.3
log
@rdist 6.1.2
@
text
@d2 2
d39 4
d44 2
a45 1
"$Id: gram.y,v 6.29 1994/04/11 23:59:15 mcooper Exp mcooper $";
d423 1
d478 1
d505 1
@


1.2
log
@rdist 6.1.1
@
text
@@


1.1
log
@Initial revision
@
text
@d3 3
a5 2
 * Copyright (c) 1983, 1993
 *	The Regents of the University of California.  All rights reserved.
d37 8
a44 2
/* from: static char sccsid[] = "@@(#)gram.y	8.1 (Berkeley) 6/9/93"; */
static char *rcsid = "$Id: gram.y,v 1.3 1994/03/07 05:05:30 cgd Exp $";
d47 7
d56 1
d61 1
a61 2

static char  *makestr __P((char *));
d65 12
a76 15
%term EQUAL	1
%term LP	2
%term RP	3
%term SM	4
%term ARROW	5
%term COLON	6
%term DCOLON	7
%term NAME	8
%term STRING	9
%term INSTALL	10
%term NOTIFY	11
%term EXCEPT	12
%term PATTERN	13
%term SPECIAL	14
%term OPTION	15
d79 4
a82 4
	int intval;
	char *string;
	struct subcmd *subcmd;
	struct namelist *namel;
d85 1
a85 1
%type <intval> OPTION, options
d87 2
a88 2
%type <subcmd> INSTALL, NOTIFY, EXCEPT, PATTERN, SPECIAL, cmdlist, cmd
%type <namel> namelist, names, opt_namelist
d96 1
a96 1
command:	  NAME EQUAL namelist = {
d100 1
a100 1
			insert(NULL, $1, $3, $4);
d106 1
a106 1
			append(NULL, $1, $3, $4);
d114 15
a128 1
namelist:	  NAME = {
d131 1
a131 1
		| LP names RP = {
d164 1
a164 1
cmd:		  INSTALL options opt_namelist SM = {
d180 1
a180 1
		| NOTIFY namelist SM = {
d185 1
a185 1
		| EXCEPT namelist SM = {
d190 1
a190 1
		| PATTERN namelist SM = {
d200 7
a206 1
		| SPECIAL opt_namelist STRING SM = {
a234 1
int
d259 4
a262 1
		return(EQUAL);
d265 2
a266 1
		return(LP);
d269 2
a270 4
		return(RP);

	case ';':  /* SM */
		return(SM);
d275 1
a275 1
		ungetc(c, fin);
d311 1
a311 1
		ungetc(c, fin);
d324 1
a324 1
					c |= QUOTE;
d333 1
a333 1
			ungetc(c, fin);
d338 6
a343 1
	if (yytext[0] == '-' && yytext[2] == '\0') {
d345 29
a373 27
		case 'b':
			yylval.intval = COMPARE;
			return(OPTION);

		case 'R':
			yylval.intval = REMOVE;
			return(OPTION);

		case 'v':
			yylval.intval = VERIFY;
			return(OPTION);

		case 'w':
			yylval.intval = WHOLE;
			return(OPTION);

		case 'y':
			yylval.intval = YOUNGER;
			return(OPTION);

		case 'h':
			yylval.intval = FOLLOW;
			return(OPTION);

		case 'i':
			yylval.intval = IGNLNKS;
			return(OPTION);
d375 3
d389 2
d399 5
a403 2
int
any(c, str)
a415 1
void
d422 5
a426 1
	register struct namelist *h;
d430 2
a431 1
	for (h = hosts; h != NULL; free(h), h = h->n_next) {
a448 2
		if (nc == NULL)
			fatal("ran out of memory\n");
d454 1
a469 1
void
a478 2
	if (c == NULL)
		fatal("ran out of memory\n");
a495 1
void
d499 1
a499 3
	++nerrs;
	fflush(stdout);
	fprintf(stderr, "rdist: line %d: %s\n", yylineno, s);
d505 1
a505 1
static char *
d509 1
a509 1
	register char *cp, *s;
d511 1
a511 1
	str = cp = malloc(strlen(s = str) + 1);
d513 3
a515 4
		fatal("ran out of memory\n");
	while (*cp++ = *s++)
		;
	return(str);
d527 2
a529 2
	if (nl == NULL)
		fatal("ran out of memory\n");
d532 1
d536 79
d618 1
a618 1
struct subcmd *
a624 2
	if (sc == NULL)
		fatal("ran out of memory\n");
d629 1
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@
