head	1.37;
access;
symbols
	OPENBSD_6_0:1.37.0.4
	OPENBSD_6_0_BASE:1.37
	OPENBSD_5_9:1.37.0.2
	OPENBSD_5_9_BASE:1.37
	OPENBSD_5_8:1.36.0.6
	OPENBSD_5_8_BASE:1.36
	OPENBSD_5_7:1.36.0.2
	OPENBSD_5_7_BASE:1.36
	OPENBSD_5_6:1.33.0.4
	OPENBSD_5_6_BASE:1.33
	OPENBSD_5_5:1.26.0.14
	OPENBSD_5_5_BASE:1.26
	OPENBSD_5_4:1.26.0.10
	OPENBSD_5_4_BASE:1.26
	OPENBSD_5_3:1.26.0.8
	OPENBSD_5_3_BASE:1.26
	OPENBSD_5_2:1.26.0.6
	OPENBSD_5_2_BASE:1.26
	OPENBSD_5_1_BASE:1.26
	OPENBSD_5_1:1.26.0.4
	OPENBSD_5_0:1.26.0.2
	OPENBSD_5_0_BASE:1.26
	OPENBSD_4_9:1.23.0.6
	OPENBSD_4_9_BASE:1.23
	OPENBSD_4_8:1.23.0.4
	OPENBSD_4_8_BASE:1.23
	OPENBSD_4_7:1.23.0.2
	OPENBSD_4_7_BASE:1.23
	OPENBSD_4_6:1.22.0.10
	OPENBSD_4_6_BASE:1.22
	OPENBSD_4_5:1.22.0.6
	OPENBSD_4_5_BASE:1.22
	OPENBSD_4_4:1.22.0.4
	OPENBSD_4_4_BASE:1.22
	OPENBSD_4_3:1.22.0.2
	OPENBSD_4_3_BASE:1.22
	OPENBSD_4_2:1.21.0.18
	OPENBSD_4_2_BASE:1.21
	OPENBSD_4_1:1.21.0.16
	OPENBSD_4_1_BASE:1.21
	OPENBSD_4_0:1.21.0.14
	OPENBSD_4_0_BASE:1.21
	OPENBSD_3_9:1.21.0.12
	OPENBSD_3_9_BASE:1.21
	OPENBSD_3_8:1.21.0.10
	OPENBSD_3_8_BASE:1.21
	OPENBSD_3_7:1.21.0.8
	OPENBSD_3_7_BASE:1.21
	OPENBSD_3_6:1.21.0.6
	OPENBSD_3_6_BASE:1.21
	OPENBSD_3_5:1.21.0.4
	OPENBSD_3_5_BASE:1.21
	OPENBSD_3_4:1.21.0.2
	OPENBSD_3_4_BASE:1.21
	OPENBSD_3_3:1.16.0.4
	OPENBSD_3_3_BASE:1.16
	OPENBSD_3_2:1.16.0.2
	OPENBSD_3_2_BASE:1.16
	OPENBSD_3_1:1.12.0.2
	OPENBSD_3_1_BASE:1.12
	OPENBSD_3_0:1.11.0.2
	OPENBSD_3_0_BASE:1.11
	OPENBSD_2_9_BASE:1.10
	OPENBSD_2_9:1.10.0.2
	OPENBSD_2_8:1.9.0.6
	OPENBSD_2_8_BASE:1.9
	OPENBSD_2_7:1.9.0.4
	OPENBSD_2_7_BASE:1.9
	OPENBSD_2_6:1.9.0.2
	OPENBSD_2_6_BASE:1.9
	OPENBSD_2_5:1.8.0.2
	OPENBSD_2_5_BASE:1.8
	OPENBSD_2_4:1.7.0.2
	OPENBSD_2_4_BASE:1.7
	OPENBSD_2_3:1.5.0.4
	OPENBSD_2_3_BASE:1.5
	OPENBSD_2_2:1.5.0.2
	OPENBSD_2_2_BASE:1.5
	OPENBSD_2_1:1.4.0.2
	OPENBSD_2_1_BASE:1.4
	OPENBSD_2_0:1.3.0.2
	OPENBSD_2_0_BASE:1.3;
locks; strict;
comment	@ * @;


1.37
date	2015.12.22.08.48.39;	author mmcc;	state Exp;
branches;
next	1.36;
commitid	W22M9q9LQKpNifAI;

1.36
date	2015.01.20.09.00.16;	author guenther;	state Exp;
branches;
next	1.35;
commitid	0Y0sKBv6c3xIKoav;

1.35
date	2015.01.20.04.45.43;	author guenther;	state Exp;
branches;
next	1.34;
commitid	A0W6b8s5qO90pGA0;

1.34
date	2015.01.16.06.40.11;	author deraadt;	state Exp;
branches;
next	1.33;
commitid	Uu5nFG3wCl0LACBb;

1.33
date	2014.07.12.03.32.00;	author guenther;	state Exp;
branches;
next	1.32;
commitid	uegd2I1KLsYIWNNt;

1.32
date	2014.07.12.03.25.03;	author guenther;	state Exp;
branches;
next	1.31;
commitid	he5XECSR36QOlwTC;

1.31
date	2014.07.10.14.29.03;	author guenther;	state Exp;
branches;
next	1.30;
commitid	FDFYVq3johWYidQo;

1.30
date	2014.07.05.07.22.18;	author guenther;	state Exp;
branches;
next	1.29;
commitid	yx9CbZuQ0BTvpYrS;

1.29
date	2014.07.05.06.55.29;	author guenther;	state Exp;
branches;
next	1.28;
commitid	v5AUs0w5PR8DHpj3;

1.28
date	2014.07.05.06.18.58;	author guenther;	state Exp;
branches;
next	1.27;
commitid	hGNsy3LdPkedy89e;

1.27
date	2014.07.05.05.05.51;	author guenther;	state Exp;
branches;
next	1.26;
commitid	U6Y6NKOm7JX1MOTg;

1.26
date	2011.04.24.02.23.57;	author deraadt;	state Exp;
branches;
next	1.25;

1.25
date	2011.04.18.12.29.59;	author krw;	state Exp;
branches;
next	1.24;

1.24
date	2011.04.10.15.47.28;	author krw;	state Exp;
branches;
next	1.23;

1.23
date	2009.10.27.23.59.42;	author deraadt;	state Exp;
branches;
next	1.22;

1.22
date	2008.01.02.17.44.11;	author chl;	state Exp;
branches;
next	1.21;

1.21
date	2003.06.03.02.56.14;	author millert;	state Exp;
branches;
next	1.20;

1.20
date	2003.05.14.01.34.35;	author millert;	state Exp;
branches;
next	1.19;

1.19
date	2003.05.06.21.52.25;	author millert;	state Exp;
branches;
next	1.18;

1.18
date	2003.04.19.17.22.29;	author millert;	state Exp;
branches;
next	1.17;

1.17
date	2003.04.05.20.31.58;	author deraadt;	state Exp;
branches;
next	1.16;

1.16
date	2002.06.23.03.07.22;	author deraadt;	state Exp;
branches;
next	1.15;

1.15
date	2002.06.12.06.07.16;	author mpech;	state Exp;
branches;
next	1.14;

1.14
date	2002.05.27.03.14.22;	author deraadt;	state Exp;
branches;
next	1.13;

1.13
date	2002.05.06.19.48.14;	author millert;	state Exp;
branches;
next	1.12;

1.12
date	2001.11.19.19.02.15;	author mpech;	state Exp;
branches;
next	1.11;

1.11
date	2001.07.09.07.04.51;	author deraadt;	state Exp;
branches;
next	1.10;

1.10
date	2000.11.10.15.33.12;	author provos;	state Exp;
branches;
next	1.9;

1.9
date	99.05.14.20.19.11;	author aaron;	state Exp;
branches;
next	1.8;

1.8
date	99.02.04.23.18.57;	author millert;	state Exp;
branches;
next	1.7;

1.7
date	98.06.26.21.29.13;	author millert;	state Exp;
branches;
next	1.6;

1.6
date	98.06.26.21.21.01;	author millert;	state Exp;
branches;
next	1.5;

1.5
date	97.10.07.23.39.34;	author millert;	state Exp;
branches;
next	1.4;

1.4
date	97.04.27.13.01.28;	author downsj;	state Exp;
branches;
next	1.3;

1.3
date	96.06.26.05.38.09;	author deraadt;	state Exp;
branches;
next	1.2;

1.2
date	96.03.05.03.15.58;	author dm;	state Exp;
branches;
next	1.1;

1.1
date	96.02.03.12.12.12;	author dm;	state Exp;
branches;
next	;


desc
@@


1.37
log
@remove needless allocation casts
@
text
@/*	$OpenBSD: common.c,v 1.36 2015/01/20 09:00:16 guenther Exp $	*/

/*
 * Copyright (c) 1983 Regents of the University of California.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */

#include <sys/stat.h>
#include <sys/time.h>
#include <sys/wait.h>

#include <errno.h>
#include <fcntl.h>
#include <grp.h>
#include <limits.h>
#include <paths.h>
#include <stdarg.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>

#include "defs.h"

/*
 * Things common to both the client and server.
 */

/*
 * Variables common to both client and server
 */
char			host[HOST_NAME_MAX+1];	/* Name of this host */
uid_t			userid = (uid_t)-1;	/* User's UID */
gid_t			groupid = (gid_t)-1;	/* User's GID */
char		       *homedir = NULL;		/* User's $HOME */
char		       *locuser = NULL;		/* Local User's name */
int			isserver = FALSE;	/* We're the server */
int     		amchild = 0;		/* This PID is a child */
int			do_fork = 1;		/* Fork child process */
char		       *currenthost = NULL;	/* Current client hostname */
char		       *progname = NULL;	/* Name of this program */
int			rem_r = -1;		/* Client file descriptor */
int			rem_w = -1;		/* Client file descriptor */
struct passwd	       *pw = NULL;		/* Local user's pwd entry */
volatile sig_atomic_t 	contimedout = FALSE;	/* Connection timed out */
int			rtimeout = RTIMEOUT;	/* Response time out */
jmp_buf			finish_jmpbuf;		/* Finish() jmp buffer */
int			setjmp_ok = FALSE;	/* setjmp()/longjmp() status */
char		      **realargv;		/* Real main() argv */
int			realargc;		/* Real main() argc */
opt_t			options = 0;		/* Global install options */
char			defowner[64] = "bin";	/* Default owner */
char			defgroup[64] = "bin";	/* Default group */

static int sendcmdmsg(int, char *, size_t);
static ssize_t remread(int, u_char *, size_t);
static int remmore(void);

/* 
 * Front end to write() that handles partial write() requests.
 */
ssize_t
xwrite(int fd, void *buf, size_t len)
{
    	size_t nleft = len;
	ssize_t nwritten;
	char *ptr = buf;
         
	while (nleft > 0) {
	    	if ((nwritten = write(fd, ptr, nleft)) <= 0) {
			return nwritten;
	    	}
	    	nleft -= nwritten;
	    	ptr += nwritten;
	}

	return len;
}

/*
 * Do run-time initialization
 */
int
init(int argc, char **argv, char **envp)
{
	int i;

	/*
	 * Save a copy of our argc and argv before setargs() overwrites them
	 */
	realargc = argc;
	realargv = xmalloc(sizeof(char *) * (argc+1));
	for (i = 0; i < argc; i++)
		realargv[i] = xstrdup(argv[i]);

	pw = getpwuid(userid = getuid());
	if (pw == NULL) {
		error("Your user id (%u) is not known to this system.",
		      getuid());
		return(-1);
	}

	debugmsg(DM_MISC, "UserID = %u pwname = '%s' home = '%s'\n",
		 userid, pw->pw_name, pw->pw_dir);
	homedir = xstrdup(pw->pw_dir);
	locuser = xstrdup(pw->pw_name);
	groupid = pw->pw_gid;
	gethostname(host, sizeof(host));
#if 0
	if ((cp = strchr(host, '.')) != NULL)
	    	*cp = CNULL;
#endif

	/*
	 * If we're not root, disable paranoid ownership checks
	 * since normal users cannot chown() files.
	 */
	if (!isserver && userid != 0) {
		FLAG_ON(options, DO_NOCHKOWNER);
		FLAG_ON(options, DO_NOCHKGROUP);
	}

	return(0);
}

/*
 * Finish things up before ending.
 */
void
finish(void)
{
	debugmsg(DM_CALL, 
		 "finish() called: do_fork = %d amchild = %d isserver = %d",
		 do_fork, amchild, isserver);
	cleanup(0);

	/*
	 * There's no valid finish_jmpbuf for the rdist master parent.
	 */
	if (!do_fork || amchild || isserver) {

		if (!setjmp_ok) {
#ifdef DEBUG_SETJMP
			error("attemping longjmp() without target");
			abort();
#else
			exit(1);
#endif
		}

		longjmp(finish_jmpbuf, 1);
		/*NOTREACHED*/
		error("Unexpected failure of longjmp() in finish()");
		exit(2);
	} else
		exit(1);
}

/*
 * Handle lost connections
 */
void
lostconn(void)
{
	/* Prevent looping */
	(void) signal(SIGPIPE, SIG_IGN);

	rem_r = rem_w = -1;	/* Ensure we don't try to send to server */
	checkhostname();
	error("Lost connection to %s", 
	      (currenthost) ? currenthost : "(unknown)");

	finish();
}

/*
 * General signal handler
 */
void
sighandler(int sig)
{
	int save_errno = errno;

	/* XXX signal race */
	debugmsg(DM_CALL, "sighandler() received signal %d\n", sig);

	switch (sig) {
	case SIGALRM:
		contimedout = TRUE;
		/* XXX signal race */
		checkhostname();
		error("Response time out");
		finish();
		break;

	case SIGPIPE:
		/* XXX signal race */
		lostconn();
		break;

	case SIGFPE:
		debug = !debug;
		break;

	case SIGHUP:
	case SIGINT:
	case SIGQUIT:
	case SIGTERM:
		/* XXX signal race */
		finish();
		break;

	default:
		/* XXX signal race */
		fatalerr("No signal handler defined for signal %d.", sig);
	}
	errno = save_errno;
}

/*
 * Function to actually send the command char and message to the
 * remote host.
 */
static int
sendcmdmsg(int cmd, char *msg, size_t msgsize)
{
	int len;

	if (rem_w < 0)
		return(-1);

	/*
	 * All commands except C_NONE should have a newline
	 */
	if (cmd != C_NONE && !strchr(msg + 1, '\n'))
		(void) strlcat(msg + 1, "\n", msgsize - 1);

	if (cmd == C_NONE)
		len = strlen(msg);
	else {
		len = strlen(msg + 1) + 1;
		msg[0] = cmd;
	}

	debugmsg(DM_PROTO, ">>> Cmd = %c (\\%3.3o) Msg = \"%.*s\"",
		 cmd, cmd, 
		 (cmd == C_NONE) ? len-1 : len-2,
		 (cmd == C_NONE) ? msg : msg + 1);

	return(!(xwrite(rem_w, msg, len) == len));
}

/*
 * Send a command message to the remote host.
 * Called as sendcmd(char cmdchar, char *fmt, arg1, arg2, ...)
 * The fmt may be NULL, in which case there are no args.
 */
int
sendcmd(char cmd, const char *fmt, ...)
{
	static char buf[BUFSIZ];
	va_list args;

	va_start(args, fmt);
	if (fmt)
		(void) vsnprintf(buf + (cmd != C_NONE),
				 sizeof(buf) - (cmd != C_NONE), fmt, args);
	else
		buf[1] = CNULL;
	va_end(args);

	return(sendcmdmsg(cmd, buf, sizeof(buf)));
}

/*
 * Internal variables and routines for reading lines from the remote.
 */
static u_char rembuf[BUFSIZ];
static u_char *remptr;
static ssize_t remleft;

#define remc() (--remleft < 0 ? remmore() : *remptr++)

/*
 * Back end to remote read()
 */
static ssize_t 
remread(int fd, u_char *buf, size_t bufsiz)
{
	return(read(fd, (char *)buf, bufsiz));
}

static int
remmore(void)
{
	(void) signal(SIGALRM, sighandler);
	(void) alarm(rtimeout);

	remleft = remread(rem_r, rembuf, sizeof(rembuf));

	(void) alarm(0);

	if (remleft < 0)
		return (-2);	/* error */
	if (remleft == 0)
		return (-1);	/* EOF */
	remptr = rembuf;
	remleft--;
	return (*remptr++);
}
	
/*
 * Read an input line from the remote.  Return the number of bytes
 * stored (equivalent to strlen(p)).  If `cleanup' is set, EOF at
 * the beginning of a line is returned as EOF (-1); other EOFs, or
 * errors, call cleanup() or lostconn().  In other words, unless
 * the third argument is nonzero, this routine never returns failure.
 */
int
remline(u_char *buffer, int space, int doclean)
{
	int c, left = space;
	u_char *p = buffer;

	if (rem_r < 0) {
		error("Cannot read remote input: Remote descriptor not open.");
		return(-1);
	}

	while (left > 0) {
		if ((c = remc()) < -1) {	/* error */
			if (doclean) {
				finish();
				/*NOTREACHED*/
			}
			lostconn();
			/*NOTREACHED*/
		}
		if (c == -1) {			/* got EOF */
			if (doclean) {
				if (left == space)
					return (-1);/* signal proper EOF */
				finish();	/* improper EOF */
				/*NOTREACHED*/
			}
			lostconn();
			/*NOTREACHED*/
		}
		if (c == '\n') {
			*p = CNULL;

			if (debug) {
				static char mbuf[BUFSIZ];

				(void) snprintf(mbuf, sizeof(mbuf),
					"<<< Cmd = %c (\\%3.3o) Msg = \"%s\"", 
					       buffer[0], buffer[0], 
					       buffer + 1);

				debugmsg(DM_PROTO, "%s", mbuf);
			}

			return (space - left);
		}
		*p++ = c;
		left--;
	}

	/* this will probably blow the entire session */
	error("remote input line too long");
	p[-1] = CNULL;		/* truncate */
	return (space);
}

/*
 * Non-line-oriented remote read.
 */
ssize_t
readrem(char *p, ssize_t space)
{
	if (remleft <= 0) {
		/*
		 * Set remote time out alarm.
		 */
		(void) signal(SIGALRM, sighandler);
		(void) alarm(rtimeout);

		remleft = remread(rem_r, rembuf, sizeof(rembuf));

		(void) alarm(0);
		remptr = rembuf;
	}

	if (remleft <= 0)
		return (remleft);
	if (remleft < space)
		space = remleft;

	memcpy(p, remptr, space);

	remptr += space;
	remleft -= space;

	return (space);
}

/*
 * Get the user name for the uid.
 */
char *
getusername(uid_t uid, char *file, opt_t opts)
{
	static char buf[100];
	static uid_t lastuid = (uid_t)-1;
	struct passwd *pwd = NULL;

	/*
	 * The value of opts may have changed so we always
	 * do the opts check.
	 */
  	if (IS_ON(opts, DO_NUMCHKOWNER)) { 
		(void) snprintf(buf, sizeof(buf), ":%u", uid);
		return(buf);
  	}

	/*
	 * Try to avoid getpwuid() call.
	 */
	if (lastuid == uid && buf[0] != '\0' && buf[0] != ':')
		return(buf);

	lastuid = uid;

	if ((pwd = getpwuid(uid)) == NULL) {
		if (IS_ON(opts, DO_DEFOWNER) && !isserver) 
			(void) strlcpy(buf, defowner, sizeof(buf));
		else {
			message(MT_WARNING,
				"%s: No password entry for uid %u", file, uid);
			(void) snprintf(buf, sizeof(buf), ":%u", uid);
		}
	} else {
		(void) strlcpy(buf, pwd->pw_name, sizeof(buf));
	}

	return(buf);
}

/*
 * Get the group name for the gid.
 */
char *
getgroupname(gid_t gid, char *file, opt_t opts)
{
	static char buf[100];
	static gid_t lastgid = (gid_t)-1;
	struct group *grp = NULL;

	/*
	 * The value of opts may have changed so we always
	 * do the opts check.
	 */
  	if (IS_ON(opts, DO_NUMCHKGROUP)) { 
		(void) snprintf(buf, sizeof(buf), ":%u", gid);
		return(buf);
  	}

	/*
	 * Try to avoid getgrgid() call.
	 */
	if (lastgid == gid && buf[0] != '\0' && buf[0] != ':')
		return(buf);

	lastgid = gid;

	if ((grp = (struct group *)getgrgid(gid)) == NULL) {
		if (IS_ON(opts, DO_DEFGROUP) && !isserver) 
			(void) strlcpy(buf, defgroup, sizeof(buf));
		else {
			message(MT_WARNING, "%s: No name for group %u",
				file, gid);
			(void) snprintf(buf, sizeof(buf), ":%u", gid);
		}
	} else
		(void) strlcpy(buf, grp->gr_name, sizeof(buf));

	return(buf);
}

/*
 * Read a response from the remote host.
 */
int
response(void)
{
	static u_char resp[BUFSIZ];
	u_char *s;
	int n;

	debugmsg(DM_CALL, "response() start\n");

	n = remline(s = resp, sizeof(resp), 0);

	n--;
	switch (*s++) {
        case C_ACK:
		debugmsg(DM_PROTO, "received ACK\n");
		return(0);
	case C_LOGMSG:
		if (n > 0) {
			message(MT_CHANGE, "%s", s);
			return(1);
		}
		debugmsg(DM_PROTO, "received EMPTY logmsg\n");
		return(0);
	case C_NOTEMSG:
		if (s)
			message(MT_NOTICE, "%s", s);
		return(response());

	default:
		s--;
		n++;
		/* fall into... */

	case C_ERRMSG:	/* Normal error message */
		if (s)
			message(MT_NERROR, "%s", s);
		return(-1);

	case C_FERRMSG:	/* Fatal error message */
		if (s)
			message(MT_FERROR, "%s", s);
		finish();
		return(-1);
	}
	/*NOTREACHED*/
}

/*
 * This should be in expand.c but the other routines call other modules
 * that we don't want to load in.
 *
 * Expand file names beginning with `~' into the
 * user's home directory path name. Return a pointer in buf to the
 * part corresponding to `file'.
 */
char *
exptilde(char *ebuf, char *file, size_t ebufsize)
{
	char *pw_dir, *rest;
	size_t len;

	if (*file != '~') {
notilde:
		(void) strlcpy(ebuf, file, ebufsize);
		return(ebuf);
	}
	if (*++file == CNULL) {
		pw_dir = homedir;
		rest = NULL;
	} else if (*file == '/') {
		pw_dir = homedir;
		rest = file;
	} else {
		rest = file;
		while (*rest && *rest != '/')
			rest++;
		if (*rest == '/')
			*rest = CNULL;
		else
			rest = NULL;
		if (pw == NULL || strcmp(pw->pw_name, file) != 0) {
			if ((pw = getpwnam(file)) == NULL) {
				error("%s: unknown user name", file);
				if (rest != NULL)
					*rest = '/';
				return(NULL);
			}
		}
		if (rest != NULL)
			*rest = '/';
		pw_dir = pw->pw_dir;
	}
	if ((len = strlcpy(ebuf, pw_dir, ebufsize)) >= ebufsize)
		goto notilde;
	pw_dir = ebuf + len;
	if (rest != NULL) {
		pw_dir++;
		if ((len = strlcat(ebuf, rest, ebufsize)) >= ebufsize)
			goto notilde;
	}
	return(pw_dir);
}



/*
 * Set access and modify times of a given file
 */
int
setfiletime(char *file, time_t atime, time_t mtime)
{
	struct timeval tv[2];

	if (atime != 0 && mtime != 0) {
		tv[0].tv_sec = atime;
		tv[1].tv_sec = mtime;
		tv[0].tv_usec = tv[1].tv_usec = 0;
		return (utimes(file, tv));
	} else	/* Set to current time */
		return (utimes(file, NULL));
}

/*
 * Get version info
 */
char *
getversion(void)
{
	static char buff[BUFSIZ];

	(void) snprintf(buff, sizeof(buff), 
	"Version %s.%d (%s) - Protocol Version %d, Release %s, Patch level %d",
		       DISTVERSION, PATCHLEVEL, DISTSTATUS,
		       VERSION, DISTVERSION, PATCHLEVEL);

	return(buff);
}

/*
 * Execute a shell command to handle special cases.
 * This is now common to both server and client
 */
void
runcommand(char *cmd)
{
	ssize_t nread;
	pid_t pid, wpid;
	char *cp, *s;
	char sbuf[BUFSIZ], buf[BUFSIZ];
	int fd[2], status;

	if (pipe(fd) < 0) {
		error("pipe of %s failed: %s", cmd, SYSERR);
		return;
	}

	if ((pid = fork()) == 0) {
		/*
		 * Return everything the shell commands print.
		 */
		(void) close(0);
		(void) close(1);
		(void) close(2);
		(void) open(_PATH_DEVNULL, O_RDONLY);
		(void) dup(fd[PIPE_WRITE]);
		(void) dup(fd[PIPE_WRITE]);
		(void) close(fd[PIPE_READ]);
		(void) close(fd[PIPE_WRITE]);
		(void) execl(_PATH_BSHELL, "sh", "-c", cmd, (char *)NULL);
		_exit(127);
	}
	(void) close(fd[PIPE_WRITE]);
	s = sbuf;
	*s++ = C_LOGMSG;
	while ((nread = read(fd[PIPE_READ], buf, sizeof(buf))) > 0) {
		cp = buf;
		do {
			*s++ = *cp++;
			if (cp[-1] != '\n') {
				if (s < (char *) &sbuf[sizeof(sbuf)-1])
					continue;
				*s++ = '\n';
			}
			/*
			 * Throw away blank lines.
			 */
			if (s == &sbuf[2]) {
				s--;
				continue;
			}
			if (isserver)
				(void) xwrite(rem_w, sbuf, s - sbuf);
			else {
				*s = CNULL;
				message(MT_INFO, "%s", sbuf+1);
			}
			s = &sbuf[1];
		} while (--nread);
	}
	if (s > (char *) &sbuf[1]) {
		*s++ = '\n';
		if (isserver)
			(void) xwrite(rem_w, sbuf, s - sbuf);
		else {
			*s = CNULL;
			message(MT_INFO, "%s", sbuf+1);
		}
	}
	while ((wpid = wait(&status)) != pid && wpid != -1)
		;
	if (wpid == -1)
		status = -1;
	(void) close(fd[PIPE_READ]);
	if (status)
		error("shell returned %d", status);
	else if (isserver)
		ack();
}

/*
 * Malloc with error checking
 */
void *
xmalloc(size_t amt)
{
	void *ptr;

	if ((ptr = malloc(amt)) == NULL)
		fatalerr("Cannot malloc %zu bytes of memory.", amt);

	return (ptr);
}

/*
 * realloc with error checking
 */
void *
xrealloc(void *baseptr, size_t amt)
{
	void *new;

	if ((new = realloc(baseptr, amt)) == NULL)
		fatalerr("Cannot realloc %zu bytes of memory.", amt);

	return (new);
}

/*
 * calloc with error checking
 */
void *
xcalloc(size_t num, size_t esize)
{
	void *ptr;

	if ((ptr = calloc(num, esize)) == NULL)
		fatalerr("Cannot calloc %zu * %zu = %zu bytes of memory.",
		      num, esize, num * esize);

	return (ptr);
}

/*
 * Strdup with error checking
 */
char *
xstrdup(const char *str)
{
	size_t len = strlen(str) + 1;
	char *nstr = xmalloc(len);

	return (memcpy(nstr, str, len));
}

/*
 * Private version of basename()
 */
char *
xbasename(char *path)
{
	char *cp;
 
	if ((cp = strrchr(path, '/')) != NULL)
		return(cp+1);
	else
		return(path);
}

/*
 * Take a colon (':') separated path to a file and
 * search until a component of that path is found and
 * return the found file name.
 */
char *
searchpath(char *path)
{
	char *file;
	char *space;
	int found;
	struct stat statbuf;

	for (found = 0; !found && (file = strsep(&path, ":")) != NULL; ) {
		if ((space = strchr(file, ' ')) != NULL)
			*space = CNULL;
		found = stat(file, &statbuf) == 0;
		if (space)
			*space = ' ';		/* Put back what we zapped */
	}
	return (file);
}
@


1.36
log
@Split out from rdist/defs.h the client-only and server-only bits into
 rdist/client.h and rdistd/server.h
Only put #includes in .h files that are necessary for the .h to be used;
 all other #includes go in the .c files
Move all extern variable declarations to the .h files, renaming local
 variables to avoid shadowing
Replace me_type member of mntent_t with an "is NFS?" flag bit
@
text
@d1 1
a1 1
/*	$OpenBSD: common.c,v 1.35 2015/01/20 04:45:43 guenther Exp $	*/
d116 1
a116 1
	realargv = (char **) xmalloc(sizeof(char *) * (argc+1));
@


1.35
log
@Don't use utime(), so don't need <utime.h>
@
text
@d1 1
a1 1
/*	$OpenBSD: common.c,v 1.34 2015/01/16 06:40:11 deraadt Exp $	*/
d32 15
a52 3
#include <sys/wait.h>
#include <sys/socket.h>

a69 1
int			proto_version = -1;	/* Protocol version */
a155 2
	extern jmp_buf finish_jmpbuf;

a576 1
	extern char *homedir;
@


1.34
log
@Replace <sys/param.h> with <limits.h> and other less dirty headers where
possible.  Annotate <sys/param.h> lines with their current reasons.  Switch
to PATH_MAX, NGROUPS_MAX, HOST_NAME_MAX+1, LOGIN_NAME_MAX, etc.  Change
MIN() and MAX() to local definitions of MINIMUM() and MAXIMUM() where
sensible to avoid pulling in the pollution.  These are the files confirmed
through binary verification.
ok guenther, millert, doug (helped with the verification protocol)
@
text
@d1 1
a1 1
/*	$OpenBSD: common.c,v 1.33 2014/07/12 03:32:00 guenther Exp $	*/
a37 3
#if	defined(NEED_UTIME_H)
#include <utime.h>
#endif	/* defined(NEED_UTIME_H) */
@


1.33
log
@Kill os-openbsd.h: we have <paths.h>, _PATH_RSH, and utimes()
@
text
@d1 1
a1 1
/*	$OpenBSD: common.c,v 1.32 2014/07/12 03:25:03 guenther Exp $	*/
d47 1
a47 1
char			host[MAXHOSTNAMELEN];	/* Name of this host */
@


1.32
log
@SETARGS and NEED_HASMNTOPT paths are dead; rshrcmd() and libz stuff are
no longer (were never?) used
@
text
@d1 1
a1 1
/*	$OpenBSD: common.c,v 1.31 2014/07/10 14:29:03 guenther Exp $	*/
a622 1
#if	SETFTIME_TYPE == SETFTIME_UTIMES
d628 2
a629 2
		tv[0].tv_usec = tv[1].tv_usec = (time_t) 0;
		return(utimes(file, tv));
d631 1
a631 18
		return(utimes(file, NULL));

#endif	/* SETFTIME_UTIMES */

#if	SETFTIME_TYPE == SETFTIME_UTIME
	struct utimbuf utbuf;

	if (atime != 0 && mtime != 0) {
		utbuf.actime = atime;
		utbuf.modtime = mtime;
		return(utime(file, &utbuf));
	} else	/* Set to current time */
		return(utime(file, NULL));
#endif	/* SETFTIME_UTIME */

#if	!defined(SETFTIME_TYPE)
	There is no "SETFTIME_TYPE" defined!
#endif	/* SETFTIME_TYPE */
@


1.31
log
@Assume POSIX: write() takes size_t and returns ssize_t
@
text
@d1 1
a1 1
/*	$OpenBSD: common.c,v 1.30 2014/07/05 07:22:18 guenther Exp $	*/
a110 4

#if	defined(SETARGS)
	setargs_settup(argc, argv, envp);
#endif	/* SETARGS */
@


1.30
log
@Assume POSIX: lchown(), fchown(), fchmod(), fchmodat()
Assume we have rcmdsh()
@
text
@d1 1
a1 1
/*	$OpenBSD: common.c,v 1.29 2014/07/05 06:55:29 guenther Exp $	*/
d78 2
a79 2
WRITE_RETURN_T
xwrite(int fd, void *buf, WRITE_AMT_T len)
d81 2
a82 2
    	WRITE_AMT_T nleft = len;
	WRITE_RETURN_T nwritten;
@


1.29
log
@Assume POSIX: uid_t and gid_t
@
text
@d1 1
a1 1
/*	$OpenBSD: common.c,v 1.28 2014/07/05 06:18:58 guenther Exp $	*/
a618 23
#if	defined(DIRECT_RCMD)
/*
 * Set our effective user id to the user running us.
 * This should be the uid we do most of our work as.
 */
int
becomeuser(void)
{
	int r = 0;

#if	defined(HAVE_SAVED_IDS)
	r = seteuid(userid);
#else
	r = setreuid(0, userid);
#endif	/* HAVE_SAVED_IDS */

	if (r < 0)
		error("becomeuser %u failed: %s (ruid = %u euid = %u)",
		      userid, SYSERR, getuid(), geteuid());

	return(r);
}
#endif	/* DIRECT_RCMD */
a619 22
#if	defined(DIRECT_RCMD)
/*
 * Set our effective user id to "root" (uid = 0)
 */
int
becomeroot(void)
{
	int r = 0;

#if	defined(HAVE_SAVED_IDS)
	r = seteuid(0);
#else
	r = setreuid(userid, 0);
#endif	/* HAVE_SAVED_IDS */

	if (r < 0)
		error("becomeroot failed: %s (ruid = %u euid = %u)",
		      SYSERR, getuid(), geteuid());

	return(r);
}
#endif	/* DIRECT_RCMD */
@


1.28
log
@Assume C89: stdargs, const, and setvbuf()
Assume POSIX: O_NONBLOCK and S_IS{DIR,REG,LNK}
@
text
@d1 1
a1 1
/*	$OpenBSD: common.c,v 1.27 2014/07/05 05:05:51 guenther Exp $	*/
d48 2
a49 2
UID_T			userid = (UID_T)-1;	/* User's UID */
GID_T			groupid = (GID_T)-1;	/* User's GID */
d433 1
a433 1
getusername(UID_T uid, char *file, opt_t opts)
d436 1
a436 1
	static UID_T lastuid = (UID_T)-1;
d475 1
a475 1
getgroupname(GID_T gid, char *file, opt_t opts)
d478 1
a478 1
	static GID_T lastgid = (GID_T)-1;
@


1.27
log
@Use void* in malloc/realloc/calloc wrappers
@
text
@d1 1
a1 1
/*	$OpenBSD: common.c,v 1.26 2011/04/24 02:23:57 deraadt Exp $	*/
d278 1
a278 5
 * The fmt and arg? arguments are optional.
 */
#if	defined(ARG_TYPE) && ARG_TYPE == ARG_STDARG
/*
 * Stdarg frontend to sendcmdmsg()
d281 1
a281 1
sendcmd(char cmd, char *fmt, ...)
a295 29
#endif	/* ARG_TYPE == ARG_STDARG */

#if	defined(ARG_TYPE) && ARG_TYPE == ARG_VARARGS
/*
 * Varargs frontend to sendcmdmsg()
 */
int
sendcmd(va_alist)
	va_dcl
{
	static char buf[BUFSIZ];
	va_list args;
	char cmd;
	char *fmt;

	va_start(args);
	/* XXX The "int" is necessary as a workaround for broken varargs */
	cmd = (char) va_arg(args, int);
	fmt = va_arg(args, char *);
	if (fmt)
		(void) vsnprintf(buf + (cmd != C_NONE),
				 sizeof(buf) - (cmd != C_NONE), fmt, args);
	else
		buf[1] = CNULL;
	va_end(args);

	return(sendcmdmsg(cmd, buf, sizeof(buf)));
}
#endif	/* ARG_TYPE == ARG_VARARGS */
a887 17
}

/*
 * Set line buffering.
 */
int
mysetlinebuf(FILE *fp)
{
#if	SETBUF_TYPE == SETBUF_SETLINEBUF
	return(setlinebuf(fp));
#endif	/* SETBUF_SETLINEBUF */
#if	SETBUF_TYPE == SETBUF_SETVBUF
	return(setvbuf(stdout, NULL, _IOLBF, BUFSIZ));
#endif	/* SETBUF_SETVBUF */
#if	!defined(SETBUF_TYPE)
	No SETBUF_TYPE is defined!
#endif	/* SETBUF_TYPE */
@


1.26
log
@delete a stupid SIGSEGV handler (not used)
@
text
@d1 1
a1 1
/*	$OpenBSD: common.c,v 1.25 2011/04/18 12:29:59 krw Exp $	*/
d834 1
a834 1
char *
d837 1
a837 1
	char *ptr;
d839 1
a839 1
	if ((ptr = (char *)malloc(amt)) == NULL)
d842 1
a842 1
	return(ptr);
d848 2
a849 2
char *
xrealloc(char *baseptr, size_t amt)
d851 1
a851 1
	char *new;
d853 1
a853 1
	if ((new = (char *)realloc(baseptr, amt)) == NULL)
d856 1
a856 1
	return(new);
d862 1
a862 1
char *
d865 1
a865 1
	char *ptr;
d867 1
a867 1
	if ((ptr = (char *)calloc(num, esize)) == NULL)
d871 1
a871 1
	return(ptr);
d881 1
a881 4
	char *nstr = (char *) malloc(len);

	if (nstr == NULL)
		fatalerr("Cannot malloc %zu bytes of memory.", len);
d883 1
a883 1
	return(memcpy(nstr, str, len));
@


1.25
log
@Print size_t with %zu and ssize_t with %zd in error/debug output.
Not %d or %u. May help some of the issues reported by Richard Toohey.
Tested by Steven R. Gerber.
@
text
@d1 1
a1 1
/*	$OpenBSD: common.c,v 1.24 2011/04/10 15:47:28 krw Exp $	*/
a103 5
#ifdef SIGSEGV_CHECK
	if (!isserver)
		(void) signal(SIGSEGV, sighandler);
#endif

a197 16
#ifdef SIGSEGV_CHECK
/*
 * Do a core dump
 */
void
coredump(void)
{
	error("Segmentation violation - dumping core [PID = %d, %s]",
	      getpid(), 
	      (isserver) ? "isserver" : ((amchild) ? "amchild" : "parent"));
	abort();
	/*NOTREACHED*/
	fatalerr("Abort failed - no core dump.  Exiting...");
}
#endif

d206 1
d212 1
d219 1
a226 6
#ifdef SIGSEGV_CHECK
	case SIGSEGV:
		coredump();
		break;
#endif

d231 1
d236 1
@


1.24
log
@Apply some tough type-love and give rdist a chance to handle files
larger than 2GB. Diff from Stephan R. Gerber via PR#6586, tweaks
by me.

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: common.c,v 1.23 2009/10/27 23:59:42 deraadt Exp $	*/
d862 1
a862 1
		fatalerr("Cannot malloc %d bytes of memory.", amt);
d876 1
a876 1
		fatalerr("Cannot realloc %d bytes of memory.", amt);
d890 1
a890 1
		fatalerr("Cannot calloc %d * %d = %d bytes of memory.",
d906 1
a906 1
		fatalerr("Cannot malloc %u bytes of memory.", len);
@


1.23
log
@rcsid[] and sccsid[] and copyright[] are essentially unmaintained (and
unmaintainable).  these days, people use source.  these id's do not provide
any benefit, and do hurt the small install media
(the 33,000 line diff is essentially mechanical)
ok with the idea millert, ok dms
@
text
@d1 1
a1 1
/*	$OpenBSD: common.c,v 1.22 2008/01/02 17:44:11 chl Exp $	*/
d72 1
a72 1
static int remread(int, u_char *, int);
d357 1
a357 1
static int remleft;
d364 2
a365 2
static int
remread(int fd, u_char *buf, int bufsiz)
d455 2
a456 2
int
readrem(char *p, int space)
@


1.22
log
@remove unused function

from tobias@@

ok millert@@ tobias@@
@
text
@d1 1
a1 1
/*	$OpenBSD: common.c,v 1.21 2003/06/03 02:56:14 millert Exp $	*/
a32 16
#ifndef lint
#if 0
static char RCSid[] __attribute__((__unused__)) = 
"$From: common.c,v 1.8 2001/03/12 18:16:36 kim Exp $";
#else
static char RCSid[] __attribute__((__unused__)) = 
"$OpenBSD: common.c,v 1.21 2003/06/03 02:56:14 millert Exp $";
#endif

static char sccsid[] __attribute__((__unused__)) =
"@@(#)common.c";

static char copyright[] __attribute__((__unused__)) =
"@@(#) Copyright (c) 1983 Regents of the University of California.\n\
 All rights reserved.\n";
#endif /* !lint */
@


1.21
log
@Remove the advertising clause in the UCB license which Berkeley
rescinded 22 July 1999.  Proofed by myself and Theo.
@
text
@d1 1
a1 1
/*	$OpenBSD: common.c,v 1.20 2003/05/14 01:34:35 millert Exp $	*/
d39 1
a39 1
"$OpenBSD: common.c,v 1.20 2003/05/14 01:34:35 millert Exp $";
a978 17
}

/*
 * Our interface to system call to get a socket pair.
 */
int
getsocketpair(int domain, int type, int protocol, int sv[])
{
#if	SOCKPAIR_TYPE == SOCKPAIR_SOCKETPAIR
	return(socketpair(domain, type, protocol, sv));
#endif	/* SOCKPAIR_SOCKETPAIR */
#if	SOCKPAIR_TYPE == SOCKPAIR_SPIPE
	return(spipe(sv));
#endif	/* SOCKPAIR_SPIPE */
#if	!defined(SOCKPAIR_TYPE)
	No SOCKPAIR_TYPE is defined!
#endif	/* SOCKPAIR_TYPE */
@


1.20
log
@ o Sync w/ freerdist 0.92 minus the compress option
 o KNF and ANSIfy the function headers

Sparse file support is currently a no-op since it didn't work.
Proper sparse file support will be added later.
@
text
@d1 1
a1 1
/*	$OpenBSD: common.c,v 1.19 2003/05/06 21:52:25 millert Exp $	*/
d15 1
a15 5
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
d39 1
a39 1
"$OpenBSD: common.c,v 1.19 2003/05/06 21:52:25 millert Exp $";
@


1.19
log
@Now that rcmdsh(3) can deal with an rsh command w/ args, deal with
-P path elements that have spaces.
@
text
@d1 1
a1 1
/*	$OpenBSD: common.c,v 1.18 2003/04/19 17:22:29 millert Exp $	*/
d36 1
d39 2
a40 2
static char RCSid[] = 
"$From: common.c,v 6.82 1998/03/23 23:27:33 michaelc Exp $";
d42 2
a43 2
static char RCSid[] = 
"$OpenBSD: common.c,v 1.18 2003/04/19 17:22:29 millert Exp $";
d46 2
a47 1
static char sccsid[] = "@@(#)common.c";
d49 1
a49 1
static char copyright[] =
a57 1
#include "defs.h"
d61 1
a62 1
#include <sys/wait.h>
d80 1
a80 1
int 			contimedout = FALSE;	/* Connection timed out */
d88 6
d98 2
a99 4
extern WRITE_RETURN_T xwrite(fd, buf, len)
	int fd;
	void *buf;
	WRITE_AMT_T len;
a116 15
 * Set program name
 */
extern void setprogname(argv)
	char **argv;
{
	char *cp;

	if (!progname) {
		progname = xstrdup(argv[0]);
		if ((cp = strrchr(progname, '/')))
			progname = cp + 1;
	}
}

/*
d119 2
a120 5
extern int init(argc, argv, envp)
	/*ARGSUSED*/
	int argc;
	char **argv;
	char **envp;
a122 1
	char *cp;
a128 2
	setprogname(argv);

d148 1
a148 1
	debugmsg(DM_MISC, "UserID = %d pwname = '%s' home = '%s'\n",
d154 1
d157 1
d174 2
a175 1
extern void finish()
d182 1
a182 1
	cleanup();
d209 2
a210 1
extern void lostconn()
d227 2
a228 1
extern void coredump()
d230 2
a231 2
	error("Segmentation violation - dumping core [PID = %ld, %s]",
	      (long)getpid(), 
d242 2
a243 2
extern void sighandler(sig)
	int sig;
d288 2
a289 4
static int sendcmdmsg(cmd, msg, msgsize)
	char cmd;
	char *msg;
	size_t msgsize;
d326 2
a327 1
extern int sendcmd(char cmd, char *fmt, ...)
d335 1
a335 1
		    sizeof(buf) - (cmd != C_NONE), fmt, args);
d348 2
a349 1
extern int sendcmd(va_alist)
d363 1
a363 1
		    sizeof(buf) - (cmd != C_NONE), fmt, args);
a371 22
#if	!defined(ARG_TYPE)
/*
 * Stupid frontend to sendcmdmsg()
 */
/*VARARGS2*/
extern int sendcmd(cmd, fmt, a1, a2, a3, a4, a5, a6, a7, a8)
	char cmd;
	char *fmt;
{
	static char buf[BUFSIZ];

	if (fmt)
		(void) snprintf(buf + (cmd != C_NONE),
		    sizeof(buf) - (cmd != C_NONE),
		    fmt, a1, a2, a3, a4, a5, a6, a7, a8);
	else
		buf[1] = CNULL;

	return(sendcmdmsg(cmd, buf, sizeof(buf)));
}
#endif	/* !ARG_TYPE */

d384 2
a385 4
static int remread(fd, buf, bufsiz)
	int fd;
	u_char *buf;
	int bufsiz;
d390 2
a391 1
static int remmore()
d416 2
a417 4
extern int remline(buffer, space, doclean)
	u_char *buffer;
	int space;
	int doclean;
d452 1
a452 1
				(void) snprintf(mbuf, sizeof mbuf,
d476 1
a476 3
readrem(p, space)
	char *p;
	int space;
d496 1
a496 1
	bcopy((char *) remptr, p, space);
d507 2
a508 4
extern char *getusername(uid, file, opts)
	UID_T uid;
	char *file;
	opt_t opts;
d519 1
a519 1
		(void) snprintf(buf, sizeof buf, ":%u", uid);
d532 10
a541 5
		message(MT_WARNING,
			"%s: No password entry for uid %u", file, uid);
		(void) snprintf(buf, sizeof buf, ":%u", uid);
	} else
		(void) strlcpy(buf, pwd->pw_name, sizeof buf);
d549 2
a550 4
extern char *getgroupname(gid, file, opts)
	GID_T gid;
	char *file;
	opt_t opts;
d561 1
a561 1
		(void) snprintf(buf, sizeof buf, ":%u", gid);
d574 7
a580 2
		message(MT_WARNING, "%s: No name for group %u", file, gid);
		(void) snprintf(buf, sizeof buf, ":%u", gid);
d582 1
a582 1
		(void) strlcpy(buf, grp->gr_name, sizeof buf);
d590 2
a591 1
extern int response()
d632 1
d645 2
a646 4
extern char *exptilde(ebuf, file, ebufsize)
	char *ebuf;
	size_t ebufsize;
	char *file;
d699 2
a700 1
extern int becomeuser()
d711 1
a711 1
		error("becomeuser %d failed: %s (ruid = %u euid = %u)",
d722 2
a723 1
extern int becomeroot()
d744 2
a745 4
extern int setfiletime(file, atime, mtime)
	char *file;
	time_t atime;
	time_t mtime;
d779 2
a780 1
extern char *getversion()
d784 1
a784 1
	(void) snprintf(buff, sizeof buff,
d796 2
a797 2
void runcommand(cmd)
	char *cmd;
d799 2
a800 2
	int fd[2];
	int status;
d803 2
a804 2
	pid_t pid, i;
	
d828 1
a828 1
	while ((i = read(fd[PIPE_READ], buf, sizeof(buf))) > 0) {
d851 1
a851 1
		} while (--i);
d862 1
a862 1
	while ((i = wait(&status)) != pid && i != -1)
d864 1
a864 1
	if (i == -1)
d876 2
a877 2
char *xmalloc(amt)
	int amt;
a879 1
	extern POINTER *malloc();
d890 2
a891 3
char *xrealloc(baseptr, amt)
	char *baseptr;
	unsigned int amt;
a893 1
	extern POINTER *realloc();
d904 2
a905 3
char *xcalloc(num, esize)
	unsigned int num;
	unsigned int esize;
a907 1
	extern POINTER *calloc();
d919 2
a920 2
char *xstrdup(str)
	char *str;
d922 2
a923 1
	char *nstr;
d925 2
a926 2
	if ((nstr = strdup(str)) == NULL)
		fatalerr("Cannot malloc %d bytes of memory.", strlen(str) + 1);
d928 1
a928 1
	return(nstr);
d934 2
a935 2
extern char *xbasename(path)
	char *path;
d939 1
a939 1
	if ((cp = strrchr(path, '/')))
d950 2
a951 2
extern char *searchpath(path)
	char *path;
d971 2
a972 3
extern void
mysetlinebuf(fp)
	FILE *fp;
d975 1
a975 1
	setlinebuf(fp);
d978 1
a978 1
	setvbuf(stdout, NULL, _IOLBF, BUFSIZ);
d989 1
a989 5
getsocketpair(domain, type, protocol, sv)
	int domain;
	int type;
	int protocol;
	int sv[];
@


1.18
log
@strcpy/strcat/sprintf removal; krw@@ OK
@
text
@d1 1
a1 1
/*	$OpenBSD: common.c,v 1.17 2003/04/05 20:31:58 deraadt Exp $	*/
d42 1
a42 1
"$OpenBSD: common.c,v 1.17 2003/04/05 20:31:58 deraadt Exp $";
a987 1
	char *cp;
d989 2
d993 6
a998 15
	for (; ;) {
		if (!path)
			return(NULL);
		file = path;
		cp = strchr(path, ':');
		if (cp) {
			path = cp + 1;
			*cp = CNULL;
		} else
			path = NULL;
		if (stat(file, &statbuf) == 0)
			return(file);
		/* Put back what we zapped */
		if (path)
			*cp = ':';
d1000 1
@


1.17
log
@strings; ok miod ho krw
@
text
@d1 1
a1 1
/*	$OpenBSD: common.c,v 1.16 2002/06/23 03:07:22 deraadt Exp $	*/
d42 1
a42 1
"$OpenBSD: common.c,v 1.16 2002/06/23 03:07:22 deraadt Exp $";
d299 1
a299 1
static int sendcmdmsg(cmd, msg)
d302 1
d313 1
a313 1
		(void) strcat(msg + 1, "\n");
d346 2
a347 1
		(void) vsprintf((cmd == C_NONE) ? buf : buf + 1, fmt, args);
d352 1
a352 1
	return(sendcmdmsg(cmd, buf));
d373 2
a374 1
		(void) vsprintf((cmd == C_NONE) ? buf : buf + 1, fmt, args);
d379 1
a379 1
	return(sendcmdmsg(cmd, buf));
d395 3
a397 2
		(void) sprintf((cmd == C_NONE) ? buf : buf + 1, 
			       fmt, a1, a2, a3, a4, a5, a6, a7, a8);
d401 1
a401 1
	return(sendcmdmsg(cmd, buf));
d675 1
a675 1
extern char *exptilde(ebuf, file)
d677 1
d680 2
a681 1
	char *s1, *s2, *s3;
d685 2
a686 1
		(void) strcpy(ebuf, file);
d690 2
a691 2
		s2 = homedir;
		s3 = NULL;
d693 2
a694 2
		s2 = homedir;
		s3 = file;
d696 5
a700 5
		s3 = file;
		while (*s3 && *s3 != '/')
			s3++;
		if (*s3 == '/')
			*s3 = CNULL;
d702 1
a702 1
			s3 = NULL;
d706 2
a707 2
				if (s3 != NULL)
					*s3 = '/';
d711 11
a721 11
		if (s3 != NULL)
			*s3 = '/';
		s2 = pw->pw_dir;
	}
	for (s1 = ebuf; (*s1++ = *s2++); )
		;
	s2 = --s1;
	if (s3 != NULL) {
		s2++;
		while ((*s1++ = *s3++))
			;
d723 1
a723 1
	return(s2);
@


1.16
log
@uid_t and gid_t are unsigned
@
text
@d1 1
a1 1
/*	$OpenBSD: common.c,v 1.15 2002/06/12 06:07:16 mpech Exp $	*/
d42 1
a42 1
"$OpenBSD: common.c,v 1.15 2002/06/12 06:07:16 mpech Exp $";
d484 1
a484 1
				(void) sprintf(mbuf, 
d555 1
a555 1
		(void) sprintf(buf, ":%u", uid);
d570 1
a570 1
		(void) sprintf(buf, ":%u", uid);
d572 1
a572 1
		(void) strcpy(buf, pwd->pw_name);
d594 1
a594 1
		(void) sprintf(buf, ":%u", gid);
d608 1
a608 1
		(void) sprintf(buf, ":%u", gid);
d610 1
a610 1
		(void) strcpy(buf, grp->gr_name);
d808 1
a808 1
	(void) sprintf(buff,
@


1.15
log
@a real pid_t cleanup.

espie@@ ok for make/,
deraadt@@ one extra eye,
millert@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: common.c,v 1.14 2002/05/27 03:14:22 deraadt Exp $	*/
d42 1
a42 1
"$OpenBSD: common.c,v 1.14 2002/05/27 03:14:22 deraadt Exp $";
d159 1
a159 1
		error("Your user id (%d) is not known to this system.",
d555 1
a555 1
		(void) sprintf(buf, ":%d", uid);
d569 2
a570 2
			"%s: No password entry for uid %d", file, uid);
		(void) sprintf(buf, ":%d", uid);
d594 1
a594 1
		(void) sprintf(buf, ":%d", gid);
d607 2
a608 2
		message(MT_WARNING, "%s: No name for group %d", file, gid);
		(void) sprintf(buf, ":%d", gid);
d735 1
a735 1
		error("becomeuser %d failed: %s (ruid = %d euid = %d)",
d757 1
a757 1
		error("becomeroot failed: %s (ruid = %d euid = %d)",
@


1.14
log
@unsigned vs unsigned int
@
text
@d1 1
a1 1
/*	$OpenBSD: common.c,v 1.13 2002/05/06 19:48:14 millert Exp $	*/
d42 1
a42 1
"$OpenBSD: common.c,v 1.13 2002/05/06 19:48:14 millert Exp $";
d241 2
a242 2
	error("Segmentation violation - dumping core [PID = %d, %s]",
	      getpid(), 
d823 1
a823 1
	int fd[2], pid, i;
d827 2
a828 1

@


1.13
log
@do not install a SIGSEGV handler
@
text
@d1 1
a1 1
/*	$OpenBSD: common.c,v 1.12 2001/11/19 19:02:15 mpech Exp $	*/
d42 1
a42 1
"$OpenBSD: common.c,v 1.12 2001/11/19 19:02:15 mpech Exp $";
d931 2
a932 2
	unsigned num;
	unsigned esize;
@


1.12
log
@kill more registers

millert@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: common.c,v 1.11 2001/07/09 07:04:51 deraadt Exp $	*/
d42 1
a42 1
"$OpenBSD: common.c,v 1.11 2001/07/09 07:04:51 deraadt Exp $";
d138 1
d141 1
d235 1
d248 1
d276 1
d280 1
@


1.11
log
@correct type on last arg to execl(); nordin@@cse.ogi.edu
@
text
@d1 1
a1 1
/*	$OpenBSD: common.c,v 1.10 2000/11/10 15:33:12 provos Exp $	*/
d42 1
a42 1
"$OpenBSD: common.c,v 1.10 2000/11/10 15:33:12 provos Exp $";
d98 1
a98 1
	register char *ptr = buf;
d117 1
a117 1
	register char *cp;
d135 2
a136 2
	register int i;
	register char *cp;
d441 1
a441 1
	register u_char *buffer;
d445 2
a446 2
	register int c, left = space;
	register u_char *p = buffer;
d504 1
a504 1
	register int space;
d667 1
a667 1
	register char *file;
d669 1
a669 1
	register char *s1, *s2, *s3;
d819 1
a819 1
	register char *cp, *s;
d958 1
a958 1
	register char *cp;
d974 2
a975 2
	register char *cp;
	register char *file;
@


1.10
log
@seperate -> separate, okay aaron@@
@
text
@d1 1
a1 1
/*	$OpenBSD: common.c,v 1.9 1999/05/14 20:19:11 aaron Exp $	*/
d42 1
a42 1
"$OpenBSD: common.c,v 1.9 1999/05/14 20:19:11 aaron Exp $";
d839 1
a839 1
		(void) execl(_PATH_BSHELL, "sh", "-c", cmd, 0);
@


1.9
log
@correct error msg so it considers the terminating null byte
@
text
@d1 1
a1 1
/*	$OpenBSD: common.c,v 1.8 1999/02/04 23:18:57 millert Exp $	*/
d42 1
a42 1
"$OpenBSD: common.c,v 1.8 1999/02/04 23:18:57 millert Exp $";
d967 1
a967 1
 * Take a colon (':') seperated path to a file and
@


1.8
log
@Fix a serious memory consumption problem when running over directories
that contain many hard-linked files; johnh@@isi.edu
Also add an xstrdup() that behaves like xmalloc() on failure.
@
text
@d1 1
a1 1
/*	$OpenBSD: common.c,v 1.7 1998/06/26 21:29:13 millert Exp $	*/
d42 1
a42 1
"$OpenBSD: common.c,v 1.7 1998/06/26 21:29:13 millert Exp $";
d947 1
a947 1
		fatalerr("Cannot malloc %d bytes of memory.", strlen(str));
@


1.7
log
@save_errno
@
text
@d1 1
a1 1
/*	$OpenBSD: common.c,v 1.6 1998/06/26 21:21:01 millert Exp $	*/
d42 1
a42 1
"$OpenBSD: common.c,v 1.6 1998/06/26 21:21:01 millert Exp $";
d120 1
a120 1
		progname = strdup(argv[0]);
d149 1
a149 1
		realargv[i] = strdup(argv[i]);
d164 2
a165 2
	homedir = strdup(pw->pw_dir);
	locuser = strdup(pw->pw_name);
d936 14
@


1.6
log
@rdist 6.1.4 + OpenBSD patches + some -Wall
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d42 1
a42 1
"$OpenBSD$";
d252 2
d286 1
@


1.5
log
@Don't use cached name value for uid/gid if last lookup was by id (and not name).
Fix also sent to rdist-bugs@@usc.edu
@
text
@d1 1
a1 1
/*	$OpenBSD: common.c,v 1.4 1997/04/27 13:01:28 downsj Exp $	*/
d37 1
d39 5
a43 1
"$OpenBSD: common.c,v 1.4 1997/04/27 13:01:28 downsj Exp $";
d60 2
d121 1
a121 1
		if (cp = strrchr(progname, '/'))
d151 1
a151 1
#if	defined(SETARGS) && !defined(__OpenBSD__)
d498 1
d553 1
a553 1
	if (lastuid == uid && buf[0] && buf[0] != ':')
d592 1
a592 1
	if (lastgid == gid && buf[0] && buf[0] != ':')
d699 1
a699 1
	for (s1 = ebuf; *s1++ = *s2++; )
d704 1
a704 1
		while (*s1++ = *s3++)
d772 1
a772 1
		return(utimes(file, (struct timeval *) NULL));
d784 1
a784 1
		return(utime(file, (struct utimbuf *)NULL));
d943 1
a943 1
	if (cp = strrchr(path, '/'))
d963 1
a963 1
			return((char *) NULL);
d982 1
a982 1
extern int
d987 1
a987 1
	return(setlinebuf(fp));
d990 1
a990 1
	return(setvbuf(stdout, NULL, _IOLBF, BUFSIZ));
@


1.4
log
@Pull in more includes to properly prototype library functions, kill local
decls of library functions, kill local implementation of setproctitle().

This of course points out how utterly bad this code is and that someone needs
to come in here with a chainsaw sometime.
@
text
@d1 1
a1 1
/*	$OpenBSD: common.c,v 1.3 1996/06/26 05:38:09 deraadt Exp $	*/
d38 1
a38 1
"$OpenBSD: common.c,v 1.3 1996/06/26 05:38:09 deraadt Exp $";
d545 1
a545 1
	if (lastuid == uid && buf[0])
d584 1
a584 1
	if (lastgid == gid && buf[0])
@


1.3
log
@rcsid
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d38 1
a38 1
"$OpenBSD: common.c,v 1.2 1996/03/05 03:15:58 dm Exp $";
d144 1
a144 1
#if	defined(SETARGS)
@


1.2
log
@rdist 6.1.2
@
text
@d1 2
d38 1
a38 1
"$Id: common.c,v 6.81 1996/01/30 02:29:43 mcooper Exp $";
@


1.1
log
@rdist 6.1.1
@
text
@d36 1
a36 1
"$Id: common.c,v 6.80 1995/12/13 01:59:45 mcooper Exp $";
d74 1
d190 10
@
