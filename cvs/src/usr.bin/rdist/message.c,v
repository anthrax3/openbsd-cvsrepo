head	1.28;
access;
symbols
	OPENBSD_6_1_BASE:1.28
	OPENBSD_6_0:1.28.0.2
	OPENBSD_6_0_BASE:1.28
	OPENBSD_5_9:1.27.0.4
	OPENBSD_5_9_BASE:1.27
	OPENBSD_5_8:1.27.0.6
	OPENBSD_5_8_BASE:1.27
	OPENBSD_5_7:1.27.0.2
	OPENBSD_5_7_BASE:1.27
	OPENBSD_5_6:1.21.0.4
	OPENBSD_5_6_BASE:1.21
	OPENBSD_5_5:1.19.0.4
	OPENBSD_5_5_BASE:1.19
	OPENBSD_5_4:1.18.0.16
	OPENBSD_5_4_BASE:1.18
	OPENBSD_5_3:1.18.0.14
	OPENBSD_5_3_BASE:1.18
	OPENBSD_5_2:1.18.0.12
	OPENBSD_5_2_BASE:1.18
	OPENBSD_5_1_BASE:1.18
	OPENBSD_5_1:1.18.0.10
	OPENBSD_5_0:1.18.0.8
	OPENBSD_5_0_BASE:1.18
	OPENBSD_4_9:1.18.0.6
	OPENBSD_4_9_BASE:1.18
	OPENBSD_4_8:1.18.0.4
	OPENBSD_4_8_BASE:1.18
	OPENBSD_4_7:1.18.0.2
	OPENBSD_4_7_BASE:1.18
	OPENBSD_4_6:1.17.0.10
	OPENBSD_4_6_BASE:1.17
	OPENBSD_4_5:1.17.0.6
	OPENBSD_4_5_BASE:1.17
	OPENBSD_4_4:1.17.0.4
	OPENBSD_4_4_BASE:1.17
	OPENBSD_4_3:1.17.0.2
	OPENBSD_4_3_BASE:1.17
	OPENBSD_4_2:1.15.0.18
	OPENBSD_4_2_BASE:1.15
	OPENBSD_4_1:1.15.0.16
	OPENBSD_4_1_BASE:1.15
	OPENBSD_4_0:1.15.0.14
	OPENBSD_4_0_BASE:1.15
	OPENBSD_3_9:1.15.0.12
	OPENBSD_3_9_BASE:1.15
	OPENBSD_3_8:1.15.0.10
	OPENBSD_3_8_BASE:1.15
	OPENBSD_3_7:1.15.0.8
	OPENBSD_3_7_BASE:1.15
	OPENBSD_3_6:1.15.0.6
	OPENBSD_3_6_BASE:1.15
	OPENBSD_3_5:1.15.0.4
	OPENBSD_3_5_BASE:1.15
	OPENBSD_3_4:1.15.0.2
	OPENBSD_3_4_BASE:1.15
	OPENBSD_3_3:1.10.0.6
	OPENBSD_3_3_BASE:1.10
	OPENBSD_3_2:1.10.0.4
	OPENBSD_3_2_BASE:1.10
	OPENBSD_3_1:1.10.0.2
	OPENBSD_3_1_BASE:1.10
	OPENBSD_3_0:1.9.0.4
	OPENBSD_3_0_BASE:1.9
	OPENBSD_2_9_BASE:1.9
	OPENBSD_2_9:1.9.0.2
	OPENBSD_2_8:1.8.0.8
	OPENBSD_2_8_BASE:1.8
	OPENBSD_2_7:1.8.0.6
	OPENBSD_2_7_BASE:1.8
	OPENBSD_2_6:1.8.0.4
	OPENBSD_2_6_BASE:1.8
	OPENBSD_2_5:1.8.0.2
	OPENBSD_2_5_BASE:1.8
	OPENBSD_2_4:1.7.0.2
	OPENBSD_2_4_BASE:1.7
	OPENBSD_2_3:1.6.0.8
	OPENBSD_2_3_BASE:1.6
	OPENBSD_2_2:1.6.0.6
	OPENBSD_2_2_BASE:1.6
	OPENBSD_2_1:1.6.0.4
	OPENBSD_2_1_BASE:1.6
	OPENBSD_2_0:1.6.0.2
	OPENBSD_2_0_BASE:1.6;
locks; strict;
comment	@ * @;


1.28
date	2016.03.30.20.51.59;	author millert;	state Exp;
branches;
next	1.27;
commitid	ume5fmOSwt4fBXqE;

1.27
date	2015.01.20.09.00.16;	author guenther;	state Exp;
branches;
next	1.26;
commitid	0Y0sKBv6c3xIKoav;

1.26
date	2015.01.20.07.03.21;	author guenther;	state Exp;
branches;
next	1.25;
commitid	WEK7TCmrh6ZlxJE2;

1.25
date	2015.01.20.06.08.08;	author guenther;	state Exp;
branches;
next	1.24;
commitid	AVTNuIUitBjmdvEO;

1.24
date	2015.01.20.06.02.30;	author guenther;	state Exp;
branches;
next	1.23;
commitid	Cuzt8eaYzxw7KVzW;

1.23
date	2015.01.20.03.14.52;	author guenther;	state Exp;
branches;
next	1.22;
commitid	YWmenI3gU9wLAZQo;

1.22
date	2015.01.16.06.40.11;	author deraadt;	state Exp;
branches;
next	1.21;
commitid	Uu5nFG3wCl0LACBb;

1.21
date	2014.07.05.06.18.58;	author guenther;	state Exp;
branches;
next	1.20;
commitid	hGNsy3LdPkedy89e;

1.20
date	2014.07.05.05.05.51;	author guenther;	state Exp;
branches;
next	1.19;
commitid	U6Y6NKOm7JX1MOTg;

1.19
date	2013.12.21.06.29.17;	author guenther;	state Exp;
branches;
next	1.18;

1.18
date	2009.10.27.23.59.42;	author deraadt;	state Exp;
branches;
next	1.17;

1.17
date	2007.09.14.14.29.20;	author chl;	state Exp;
branches;
next	1.16;

1.16
date	2007.09.11.15.47.17;	author gilles;	state Exp;
branches;
next	1.15;

1.15
date	2003.06.03.02.56.14;	author millert;	state Exp;
branches;
next	1.14;

1.14
date	2003.05.14.01.34.35;	author millert;	state Exp;
branches;
next	1.13;

1.13
date	2003.04.19.17.22.29;	author millert;	state Exp;
branches;
next	1.12;

1.12
date	2003.04.06.18.57.44;	author deraadt;	state Exp;
branches;
next	1.11;

1.11
date	2003.04.05.20.31.58;	author deraadt;	state Exp;
branches;
next	1.10;

1.10
date	2001.11.19.19.02.15;	author mpech;	state Exp;
branches;
next	1.9;

1.9
date	2000.11.10.15.33.12;	author provos;	state Exp;
branches;
next	1.8;

1.8
date	99.02.04.23.18.57;	author millert;	state Exp;
branches;
next	1.7;

1.7
date	98.06.26.21.21.15;	author millert;	state Exp;
branches;
next	1.6;

1.6
date	96.07.29.17.50.09;	author millert;	state Exp;
branches;
next	1.5;

1.5
date	96.07.25.05.31.02;	author millert;	state Exp;
branches;
next	1.4;

1.4
date	96.06.26.05.38.14;	author deraadt;	state Exp;
branches;
next	1.3;

1.3
date	96.06.25.22.23.18;	author deraadt;	state Exp;
branches;
next	1.2;

1.2
date	96.03.05.03.16.08;	author dm;	state Exp;
branches;
next	1.1;

1.1
date	96.02.03.12.12.32;	author dm;	state Exp;
branches;
next	;


desc
@@


1.28
log
@Avoid compiler warning about zero-length printf format strings.
Allow a NULL format in message() and switch the two calls to
error() and message() with an empty format string to using NULL.
OK deraadt@@
@
text
@/*	$OpenBSD: message.c,v 1.27 2015/01/20 09:00:16 guenther Exp $	*/

/*
 * Copyright (c) 1983 Regents of the University of California.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */

#include <errno.h>
#include <limits.h>
#include <paths.h>
#include <stdarg.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <syslog.h>
#include <unistd.h>

#include "defs.h"

/*
 * Message handling functions for both rdist and rdistd.
 */


#define MSGBUFSIZ	32*1024

int			debug = 0;		/* Debugging level */
int			nerrs = 0;		/* Number of errors */

/*
 * Message Types
 */
struct msgtype {
	int		mt_type;		/* Type (bit) */
	char	       *mt_name;		/* Name of message type */
} msgtypes[] = {
	{ MT_CHANGE,	"change" },
	{ MT_INFO,	"info" },
	{ MT_NOTICE,	"notice" },
	{ MT_NERROR,	"nerror" },
	{ MT_FERROR,	"ferror" },
	{ MT_WARNING,	"warning" },
	{ MT_VERBOSE,	"verbose" },
	{ MT_ALL,	"all" },
	{ MT_DEBUG,	"debug" },
	{ 0 },
};

/*
 * Description of message facilities
 */
struct msgfacility {
	/* compile time initialized data */
	int		mf_msgfac;		/* One of MF_* from below */
	char	       *mf_name;		/* Name of this facility */
	void	      (*mf_sendfunc)		/* Function to send msg */
			(struct msgfacility *, int, int, char *);
	/* run time initialized data */
	int		mf_msgtypes;		/* Bitmask of MT_* from above*/
	char	       *mf_filename;		/* Name of file */
	FILE	       *mf_fptr;		/* File pointer to output to */
};

/*
 * Message Facilities
 */
#define MF_STDOUT	1			/* Standard Output */
#define MF_NOTIFY	2			/* Notify mail service */
#define MF_FILE		3			/* A normal file */
#define MF_SYSLOG	4			/* syslog() */

static void msgsendstdout(struct msgfacility *, int, int, char *);
static void msgsendsyslog(struct msgfacility *, int, int, char *);
static void msgsendfile(struct msgfacility *, int, int, char *);
static void msgsendnotify(struct msgfacility *, int, int, char *);

/*
 * Message Facilities
 */
struct msgfacility msgfacility[] = {
	{ MF_STDOUT,	"stdout",	msgsendstdout },
	{ MF_FILE,	"file",		msgsendfile },
	{ MF_SYSLOG,	"syslog",	msgsendsyslog },
	{ MF_NOTIFY,	"notify",	msgsendnotify },
	{ 0 },
};

static struct msgfacility *getmsgfac(char *);
static struct msgtype *getmsgtype(char *);
static char *setmsgtypes(struct msgfacility *, char *);
static void _message(int, char *);
static void _debugmsg(int, char *);
static void _error(const char *);
static void _fatalerr(const char *);

/*
 * Print message logging usage message
 */
void
msgprusage(void)
{
	int i, x;

	(void) fprintf(stderr, "\nWhere <msgopt> is of form\n");
	(void) fprintf(stderr, 
       "\t<facility1>=<type1>,<type2>,...:<facility2>=<type1>,<type2>...\n");

	(void) fprintf(stderr, "Valid <facility> names:");

	for (i = 0; msgfacility[i].mf_name; ++i)
		(void) fprintf(stderr, " %s", msgfacility[i].mf_name);

	(void) fprintf(stderr, "\nValid <type> names:");
	for (x = 0; msgtypes[x].mt_name; ++x)
		(void) fprintf(stderr, " %s", msgtypes[x].mt_name);

	(void) fprintf(stderr, "\n");
}

/*
 * Print enabled message logging info
 */
void
msgprconfig(void)
{
	int i, x;
	static char buf[MSGBUFSIZ];

	debugmsg(DM_MISC, "Current message logging config:");
	for (i = 0; msgfacility[i].mf_name; ++i) {
		(void) snprintf(buf, sizeof(buf), "    %.*s=", 
			       (int)(sizeof(buf) - 7), msgfacility[i].mf_name);
		for (x = 0; msgtypes[x].mt_name; ++x)
			if (IS_ON(msgfacility[i].mf_msgtypes, 
				  msgtypes[x].mt_type)) {
				if (x > 0)
					(void) strlcat(buf, ",", sizeof(buf));
				(void) strlcat(buf, msgtypes[x].mt_name,
				    sizeof(buf));
			}
		debugmsg(DM_MISC, "%s", buf);
	}

}

/*
 * Get the Message Facility entry "name"
 */
static struct msgfacility *
getmsgfac(char *name)
{
	int i;

	for (i = 0; msgfacility[i].mf_name; ++i)
		if (strcasecmp(name, msgfacility[i].mf_name) == 0)
			return(&msgfacility[i]);

	return(NULL);
}

/*
 * Get the Message Type entry named "name"
 */
static struct msgtype *
getmsgtype(char *name)
{
	int i;

	for (i = 0; msgtypes[i].mt_name; ++i)
		if (strcasecmp(name, msgtypes[i].mt_name) == 0)
			return(&msgtypes[i]);

	return(NULL);
}

/*
 * Set Message Type information for Message Facility "msgfac" as
 * indicated by string "str".
 */
static char *
setmsgtypes(struct msgfacility *msgfac, char *str)
{
	static char ebuf[BUFSIZ];
	char *cp;
	char *strptr, *word;
	struct msgtype *mtp;

	/*
	 * MF_SYSLOG is the only supported message facility for the server
	 */
	if (isserver && (msgfac->mf_msgfac != MF_SYSLOG && 
			 msgfac->mf_msgfac != MF_FILE)) {
		(void) snprintf(ebuf, sizeof(ebuf),
		"The \"%.*s\" message facility cannot be used by the server.",
			        100, msgfac->mf_name);
		return(ebuf);
	}

	strptr = str;

	/*
	 * Do any necessary Message Facility preparation
	 */
	switch(msgfac->mf_msgfac) {
	case MF_FILE:
		/*
		 * The MF_FILE string should look like "<file>=<types>".
		 */
		if ((cp = strchr(strptr, '=')) == NULL)
			return(
			   "No file name found for \"file\" message facility");
		*cp++ = CNULL;

		if ((msgfac->mf_fptr = fopen(strptr, "w")) == NULL)
			fatalerr("Cannot open log file for writing: %s: %s.",
				 strptr, SYSERR);
		msgfac->mf_filename = xstrdup(strptr);

		strptr = cp;
		break;

	case MF_NOTIFY:
		break;

	case MF_STDOUT:
		msgfac->mf_fptr = stdout;
		break;

	case MF_SYSLOG:
		openlog(progname, LOG_PID, LOG_DAEMON);
		break;
	}

	/*
	 * Parse each type word
	 */
	msgfac->mf_msgtypes = 0;	/* Start from scratch */
	while (strptr) {
		word = strptr;
		if ((cp = strchr(strptr, ',')) != NULL)
			*cp++ = CNULL;
		strptr = cp;

		if ((mtp = getmsgtype(word)) != NULL) {
			msgfac->mf_msgtypes |= mtp->mt_type;
			/*
			 * XXX This is really a kludge until we add real
			 * control over debugging.
			 */
			if (!debug && isserver && 
			    strcasecmp(word, "debug") == 0)
				debug = DM_ALL;
		} else {
			(void) snprintf(ebuf, sizeof(ebuf),
				        "Message type \"%.*s\" is invalid.",
				        100, word);
			return(ebuf);
		}
	}

	return(NULL);
}

/*
 * Parse a message logging option string
 */
char *
msgparseopts(char *msgstr, int doset)
{
	static char ebuf[BUFSIZ], msgbuf[MSGBUFSIZ];
	char *cp, *optstr;
	char *word;
	struct msgfacility *msgfac;

	if (msgstr == NULL)
		return("NULL message string");

	/* strtok() is harmful */
	(void) strlcpy(msgbuf, msgstr, sizeof(msgbuf));

	/*
	 * Each <facility>=<types> list is separated by ":".
	 */
	for (optstr = strtok(msgbuf, ":"); optstr;
	     optstr = strtok(NULL, ":")) {

		if ((cp = strchr(optstr, '=')) == NULL)
			return("No '=' found");

		*cp++ = CNULL;
		word = optstr;
		if ((int)strlen(word) <= 0)
			return("No message facility specified");
		if ((int)strlen(cp) <= 0)
			return("No message type specified");

		if ((msgfac = getmsgfac(word)) == NULL) {
			(void) snprintf(ebuf, sizeof(ebuf),
				        "%.*s is not a valid message facility", 
				        100, word);
			return(ebuf);
		}
		
		if (doset) {
			char *mcp;

			if ((mcp = setmsgtypes(msgfac, cp)) != NULL)
				return(mcp);
		}
	}

	if (isserver && debug) {
		debugmsg(DM_MISC, "%s", getversion());
		msgprconfig();
	}

	return(NULL);
}

/*
 * Send a message to facility "stdout".
 * For rdistd, this is really the rdist client.
 */
static void
msgsendstdout(struct msgfacility *msgfac, int mtype, int flags, char *msgbuf)
{
	char cmd;

	if (isserver) {
		if (rem_w < 0 || IS_ON(flags, MT_NOREMOTE))
			return;

		cmd = CNULL;

		switch(mtype) {
		case MT_NERROR:		cmd = C_ERRMSG;		break;
		case MT_FERROR:		cmd = C_FERRMSG;	break;
		case MT_NOTICE:		cmd = C_NOTEMSG;	break;
		case MT_REMOTE:		cmd = C_LOGMSG;		break;
		}

		if (cmd != CNULL)
			(void) sendcmd(cmd, "%s", msgbuf);
	} else {
		switch(mtype) {
		case MT_FERROR:
		case MT_NERROR:
			if (msgbuf && *msgbuf) {
				(void) fprintf(stderr, "%s\n", msgbuf);
				(void) fflush(stderr);
			}
			break;

		case MT_DEBUG:
			/* 
			 * Only things that are strictly MT_DEBUG should
			 * be shown.
			 */
			if (flags != MT_DEBUG)
				return;
		case MT_NOTICE:
		case MT_CHANGE:
		case MT_INFO:
		case MT_VERBOSE:
		case MT_WARNING:
			if (msgbuf && *msgbuf) {
				(void) printf("%s\n", msgbuf);
				(void) fflush(stdout);
			}
			break;
		}
	}
}

/*
 * Send a message to facility "syslog"
 */
static void
msgsendsyslog(struct msgfacility *msgfac, int mtype, int flags, char *msgbuf)
{
	int syslvl = 0;

	if (!msgbuf || !*msgbuf)
		return;

	switch(mtype) {
#if	defined(SL_NERROR)
	case MT_NERROR:		syslvl = SL_NERROR;	break;
#endif
#if	defined(SL_FERROR)
	case MT_FERROR:		syslvl = SL_FERROR;	break;
#endif
#if	defined(SL_WARNING)
	case MT_WARNING:	syslvl = SL_WARNING;	break;
#endif
#if	defined(SL_CHANGE)
	case MT_CHANGE:		syslvl = SL_CHANGE;	break;
#endif
#if	defined(SL_INFO)
	case MT_SYSLOG:
	case MT_VERBOSE:
	case MT_INFO:		syslvl = SL_INFO;	break;
#endif
#if	defined(SL_NOTICE)
	case MT_NOTICE:		syslvl = SL_NOTICE;	break;
#endif
#if	defined(SL_DEBUG)
	case MT_DEBUG:		syslvl = SL_DEBUG;	break;
#endif
	}

	if (syslvl)
		syslog(syslvl, "%s", msgbuf);
}

/*
 * Send a message to a "file" facility.
 */
static void
msgsendfile(struct msgfacility *msgfac, int mtype, int flags, char *msgbuf)
{
	if (msgfac->mf_fptr == NULL)
		return;

	if (!msgbuf || !*msgbuf)
		return;

	(void) fprintf(msgfac->mf_fptr, "%s\n", msgbuf);
	(void) fflush(msgfac->mf_fptr);
}

/*
 * Same method as msgsendfile()
 */
static void
msgsendnotify(struct msgfacility *msgfac, int mtype, int flags, char *msgbuf)
{
	char *tempfile;

	if (IS_ON(flags, MT_DEBUG))
		return;

	if (!msgbuf || !*msgbuf)
		return;

	if (!msgfac->mf_fptr) {
		char *cp;
		int fd;
		size_t len;

		/*
		 * Create and open a new temporary file
		 */
		if ((cp = getenv("TMPDIR")) == NULL || *cp == '\0')
			cp = _PATH_TMP;
		len = strlen(cp) + 1 + sizeof(_RDIST_TMP);
		tempfile = xmalloc(len);
		(void) snprintf(tempfile, len, "%s/%s", cp, _RDIST_TMP);

		msgfac->mf_filename = tempfile;
		if ((fd = mkstemp(msgfac->mf_filename)) < 0 ||
		    (msgfac->mf_fptr = fdopen(fd, "w")) == NULL)
		    fatalerr("Cannot open notify file for writing: %s: %s.",
			msgfac->mf_filename, SYSERR);
		debugmsg(DM_MISC, "Created notify temp file '%s'",
			 msgfac->mf_filename);
	}

	if (msgfac->mf_fptr == NULL)
		return;

	(void) fprintf(msgfac->mf_fptr, "%s\n", msgbuf);
	(void) fflush(msgfac->mf_fptr);
}

/*
 * Insure currenthost is set to something reasonable.
 */
void
checkhostname(void)
{
	static char mbuf[HOST_NAME_MAX+1];
	char *cp;

	if (!currenthost) {
		if (gethostname(mbuf, sizeof(mbuf)) == 0) {
			if ((cp = strchr(mbuf, '.')) != NULL)
				*cp = CNULL;
			currenthost = xstrdup(mbuf);
		} else
			currenthost = "(unknown)";
	}
}

/*
 * Print a message contained in "msgbuf" if a level "lvl" is set.
 */
static void
_message(int flags, char *msgbuf)
{
	int i, x;
	static char mbuf[2048];

	if (msgbuf && *msgbuf) {
		/*
		 * Ensure no stray newlines are present
		 */
		msgbuf[strcspn(msgbuf, "\n")] = CNULL;

		checkhostname();
		if (strncmp(currenthost, msgbuf, strlen(currenthost)) == 0)
			(void) strlcpy(mbuf, msgbuf, sizeof(mbuf));
		else
			(void) snprintf(mbuf, sizeof(mbuf), 
					"%s: %s", currenthost, msgbuf);
	} else
		mbuf[0] = '\0';

	/*
	 * Special case for messages that only get
	 * logged to the system log facility
	 */
	if (IS_ON(flags, MT_SYSLOG)) {
		msgsendsyslog(NULL, MT_SYSLOG, flags, mbuf);
		return;
	}

	/*
	 * Special cases
	 */
	if (isserver && IS_ON(flags, MT_NOTICE)) {
		msgsendstdout(NULL, MT_NOTICE, flags, mbuf);
		return;
	} else if (isserver && IS_ON(flags, MT_REMOTE))
		msgsendstdout(NULL, MT_REMOTE, flags, mbuf);
	else if (isserver && IS_ON(flags, MT_NERROR))
		msgsendstdout(NULL, MT_NERROR, flags, mbuf);
	else if (isserver && IS_ON(flags, MT_FERROR))
		msgsendstdout(NULL, MT_FERROR, flags, mbuf);

	/*
	 * For each Message Facility, check each Message Type to see
	 * if the bits in "flags" are set.  If so, call the appropriate
	 * Message Facility to dispatch the message.
	 */
	for (i = 0; msgfacility[i].mf_name; ++i)
		for (x = 0; msgtypes[x].mt_name; ++x)
			/* 
			 * XXX MT_ALL should not be used directly 
			 */
			if (msgtypes[x].mt_type != MT_ALL &&
			    IS_ON(flags, msgtypes[x].mt_type) &&
			    IS_ON(msgfacility[i].mf_msgtypes,
				  msgtypes[x].mt_type))
				(*msgfacility[i].mf_sendfunc)(&msgfacility[i],
							   msgtypes[x].mt_type,
							      flags,
							      mbuf);
}

/*
 * Front-end to _message()
 */
void
message(int lvl, const char *fmt, ...)
{
	static char buf[MSGBUFSIZ];
	va_list args;

	if (fmt != NULL) {
		va_start(args, fmt);
		(void) vsnprintf(buf, sizeof(buf), fmt, args);
		va_end(args);
	}

	_message(lvl, fmt ? buf : NULL);
}

/*
 * Display a debugging message
 */
static void
_debugmsg(int lvl, char *buf)
{
	if (IS_ON(debug, lvl))
		_message(MT_DEBUG, buf);
}

/*
 * Front-end to _debugmsg()
 */
void
debugmsg(int lvl, const char *fmt, ...)
{
	static char buf[MSGBUFSIZ];
	va_list args;

	va_start(args, fmt);
	(void) vsnprintf(buf, sizeof(buf), fmt, args);
	va_end(args);

	_debugmsg(lvl, buf);
}

/*
 * Print an error message
 */
static void
_error(const char *msg)
{
	static char buf[MSGBUFSIZ];

	nerrs++;
	buf[0] = CNULL;

	if (msg) {
		if (isserver)
			(void) snprintf(buf, sizeof(buf),
					"REMOTE ERROR: %s", msg);
		else
			(void) snprintf(buf, sizeof(buf),
					"LOCAL ERROR: %s", msg);
	}

	_message(MT_NERROR, (buf[0]) ? buf : NULL);
}

/*
 * Frontend to _error()
 */
void
error(const char *fmt, ...)
{
	static char buf[MSGBUFSIZ];
	va_list args;

	buf[0] = CNULL;
	va_start(args, fmt);
	if (fmt)
		(void) vsnprintf(buf, sizeof(buf), fmt, args);
	va_end(args);

	_error((buf[0]) ? buf : NULL);
}

/*
 * Display a fatal message
 */
static void
_fatalerr(const char *msg)
{
	static char buf[MSGBUFSIZ];

	++nerrs;

	if (isserver)
		(void) snprintf(buf, sizeof(buf), "REMOTE ERROR: %s", msg);
	else
		(void) snprintf(buf, sizeof(buf), "LOCAL ERROR: %s", msg);

	_message(MT_FERROR, buf);

	exit(nerrs);
}

/*
 * Front-end to _fatalerr()
 */
void
fatalerr(const char *fmt, ...)
{
	static char buf[MSGBUFSIZ];
	va_list args;

	va_start(args, fmt);
	(void) vsnprintf(buf, sizeof(buf), fmt, args);
	va_end(args);

	_fatalerr(buf);
}

/*
 * Get the name of the file used for notify.
 * A side effect is that the file pointer to the file
 * is closed.  We assume this function is only called when
 * we are ready to read the file.
 */
char *
getnotifyfile(void)
{
	int i;

	for (i = 0; msgfacility[i].mf_name; i++)
		if (msgfacility[i].mf_msgfac == MF_NOTIFY &&
		    msgfacility[i].mf_fptr) {
			(void) fclose(msgfacility[i].mf_fptr);
			msgfacility[i].mf_fptr = NULL;
			return(msgfacility[i].mf_filename);
		}

	return(NULL);
}
@


1.27
log
@Split out from rdist/defs.h the client-only and server-only bits into
 rdist/client.h and rdistd/server.h
Only put #includes in .h files that are necessary for the .h to be used;
 all other #includes go in the .c files
Move all extern variable declarations to the .h files, renaming local
 variables to avoid shadowing
Replace me_type member of mntent_t with an "is NFS?" flag bit
@
text
@d1 1
a1 1
/*	$OpenBSD: message.c,v 1.26 2015/01/20 07:03:21 guenther Exp $	*/
d594 5
a598 3
	va_start(args, fmt);
	(void) vsnprintf(buf, sizeof(buf), fmt, args);
	va_end(args);
d600 1
a600 1
	_message(lvl, buf);
@


1.26
log
@We all have syslog() now; assume LOG_PID and LOG_DAEMON
@
text
@d1 1
a1 1
/*	$OpenBSD: message.c,v 1.25 2015/01/20 06:08:08 guenther Exp $	*/
d32 7
d40 2
@


1.25
log
@Move MF_* to message.c too
@
text
@d1 1
a1 1
/*	$OpenBSD: message.c,v 1.24 2015/01/20 06:02:30 guenther Exp $	*/
d245 1
a245 7
#if defined(LOG_OPTS)
#if	defined(LOG_FACILITY)
		openlog(progname, LOG_OPTS, LOG_FACILITY);
#else
		openlog(progname, LOG_OPTS);
#endif	/* LOG_FACILITY */
#endif	/* LOG_OPTS */
@


1.24
log
@Move struct distoptinfo into distopt.c, killing the DISTOPTINFO typedef
Move struct msgtype and msgfacility into message.c, killing the MSGTYPE and
 MSGFACILITY typedefs
Make getdistopt() static to distopt.c
@
text
@d1 1
a1 1
/*	$OpenBSD: message.c,v 1.23 2015/01/20 03:14:52 guenther Exp $	*/
d78 8
@


1.23
log
@Move #include <syslog.h> to the one file that needs it
@
text
@d1 1
a1 1
/*	$OpenBSD: message.c,v 1.22 2015/01/16 06:40:11 deraadt Exp $	*/
d48 4
a51 1
MSGTYPE msgtypes[] = {
d64 19
a82 4
static void msgsendstdout(MSGFACILITY *, int, int, char *);
static void msgsendsyslog(MSGFACILITY *, int, int, char *);
static void msgsendfile(MSGFACILITY *, int, int, char *);
static void msgsendnotify(MSGFACILITY *, int, int, char *);
d87 1
a87 1
MSGFACILITY msgfacility[] = {
d95 3
a97 3
static MSGFACILITY *getmsgfac(char *);
static MSGTYPE *getmsgtype(char *);
static char *setmsgtypes(MSGFACILITY *, char *);
d156 1
a156 1
static MSGFACILITY *
d171 1
a171 1
static MSGTYPE *
d188 1
a188 1
setmsgtypes(MSGFACILITY *msgfac, char *str)
d193 1
a193 1
	MSGTYPE *mtp;
d286 1
a286 1
	MSGFACILITY *msgfac;
d338 1
a338 1
msgsendstdout(MSGFACILITY *msgfac, int mtype, int flags, char *msgbuf)
d392 1
a392 1
msgsendsyslog(MSGFACILITY *msgfac, int mtype, int flags, char *msgbuf)
d433 1
a433 1
msgsendfile(MSGFACILITY *msgfac, int mtype, int flags, char *msgbuf)
d449 1
a449 1
msgsendnotify(MSGFACILITY *msgfac, int mtype, int flags, char *msgbuf)
@


1.22
log
@Replace <sys/param.h> with <limits.h> and other less dirty headers where
possible.  Annotate <sys/param.h> lines with their current reasons.  Switch
to PATH_MAX, NGROUPS_MAX, HOST_NAME_MAX+1, LOGIN_NAME_MAX, etc.  Change
MIN() and MAX() to local definitions of MINIMUM() and MAXIMUM() where
sensible to avoid pulling in the pollution.  These are the files confirmed
through binary verification.
ok guenther, millert, doug (helped with the verification protocol)
@
text
@d1 1
a1 1
/*	$OpenBSD: message.c,v 1.21 2014/07/05 06:18:58 guenther Exp $	*/
d32 1
@


1.21
log
@Assume C89: stdargs, const, and setvbuf()
Assume POSIX: O_NONBLOCK and S_IS{DIR,REG,LNK}
@
text
@d1 1
a1 1
/*	$OpenBSD: message.c,v 1.20 2014/07/05 05:05:51 guenther Exp $	*/
d476 1
a476 1
	static char mbuf[MAXHOSTNAMELEN];
@


1.20
log
@Use void* in malloc/realloc/calloc wrappers
@
text
@d1 1
a1 1
/*	$OpenBSD: message.c,v 1.19 2013/12/21 06:29:17 guenther Exp $	*/
a554 1
#if	defined(ARG_TYPE) && ARG_TYPE == ARG_VARARGS
d556 1
a556 25
 * Varargs front-end to _message()
 */
void
message(va_alist)
	va_dcl
{
	static char buf[MSGBUFSIZ];
	va_list args;
	char *fmt;
	int lvl;

	va_start(args);
	lvl = (int) va_arg(args, int);
	fmt = (char *) va_arg(args, char *);
	va_end(args);

	(void) vsnprintf(buf, sizeof(buf), fmt, args);

	_message(lvl, buf);
}
#endif	/* ARG_VARARGS */

#if	defined(ARG_TYPE) && ARG_TYPE == ARG_STDARG
/*
 * Stdarg front-end to _message()
a569 1
#endif	/* ARG_STDARG */
a580 25
#if	defined(ARG_TYPE) && ARG_TYPE == ARG_VARARGS
/*
 * Varargs front-end to _debugmsg()
 */
void
debugmsg(va_alist)
	va_dcl
{
	static char buf[MSGBUFSIZ];
	va_list args;
	char *fmt;
	int lvl;

	va_start(args);
	lvl = (int) va_arg(args, int);
	fmt = (char *) va_arg(args, char *);
	va_end(args);

	(void) vsnprintf(buf, sizeof(buf), fmt, args);

	_debugmsg(lvl, buf);
}
#endif	/* ARG_VARARGS */

#if	defined(ARG_TYPE) && ARG_TYPE == ARG_STDARG
d582 1
a582 1
 * Stdarg front-end to _debugmsg()
a595 1
#endif	/* ARG_STDARG */
a619 1
#if	defined(ARG_TYPE) && ARG_TYPE == ARG_VARARGS
d621 1
a621 24
 * Varargs frontend to _error()
 */
void
error(va_alist)
	va_dcl
{
	static char buf[MSGBUFSIZ];
	va_list args;
	char *fmt;

	buf[0] = CNULL;
	va_start(args);
	fmt = (char *) va_arg(args, char *);
	if (fmt)
		(void) vsnprintf(buf, sizeof(buf), fmt, args);
	va_end(args);

	_error((buf[0]) ? buf : NULL);
}
#endif	/* ARG_VARARGS */

#if	defined(ARG_TYPE) && ARG_TYPE == ARG_STDARG
/*
 * Stdarg frontend to _error()
a636 1
#endif	/* ARG_STDARG */
a657 22
#if	defined(ARG_TYPE) && ARG_TYPE == ARG_VARARGS
/*
 * Varargs front-end to _fatalerr()
 */
void
fatalerr(va_alist)
	va_dcl
{
	static char buf[MSGBUFSIZ];
	va_list args;
	char *fmt;

	va_start(args);
	fmt = (char *) va_arg(args, char *);
	(void) vsnprintf(buf, sizeof(buf), fmt, args);
	va_end(args);

	_fatalerr(buf);
}
#endif	/* ARG_VARARGS */

#if	defined(ARG_TYPE) && ARG_TYPE == ARG_STDARG
d659 1
a659 1
 * Stdarg front-end to _fatalerr()
a672 1
#endif	/* ARG_STDARG */
@


1.19
log
@Constipate some functions
@
text
@d1 1
a1 1
/*	$OpenBSD: message.c,v 1.18 2009/10/27 23:59:42 deraadt Exp $	*/
d451 1
a451 1
		tempfile = (char *) xmalloc(len);
@


1.18
log
@rcsid[] and sccsid[] and copyright[] are essentially unmaintained (and
unmaintainable).  these days, people use source.  these id's do not provide
any benefit, and do hurt the small install media
(the 33,000 line diff is essentially mechanical)
ok with the idea millert, ok dms
@
text
@d1 1
a1 1
/*	$OpenBSD: message.c,v 1.17 2007/09/14 14:29:20 chl Exp $	*/
d81 2
a82 2
static void _error(char *);
static void _fatalerr(char *);
d584 1
a584 1
message(int lvl, char *fmt, ...)
d636 1
a636 1
debugmsg(int lvl, char *fmt, ...)
d653 1
a653 1
_error(char *msg)
d700 1
a700 1
error(char *fmt, ...)
d719 1
a719 1
_fatalerr(char *msg)
d761 1
a761 1
fatalerr(char *fmt, ...)
@


1.17
log
@remove some warnings:
unused variable `variable'
`variable' might be used uninitialized in this function

ok gilles@@ ray@@
@
text
@d1 1
a1 1
/*	$OpenBSD: message.c,v 1.16 2007/09/11 15:47:17 gilles Exp $	*/
a32 17

#ifndef lint
#if 0
static char RCSid[] __attribute__((__unused__)) =
"$From: message.c,v 1.5 1999/11/01 00:21:39 christos Exp $";
#else
static char RCSid[] __attribute__((__unused__)) =
"$OpenBSD: message.c,v 1.16 2007/09/11 15:47:17 gilles Exp $";
#endif

static char sccsid[] __attribute__((__unused__)) =
"@@(#)common.c";

static char copyright[] __attribute__((__unused__)) =
"@@(#) Copyright (c) 1983 Regents of the University of California.\n\
 All rights reserved.\n";
#endif /* !lint */
@


1.16
log
@use strcspn to properly overwrite '\n' in fgets returned buffer

ok pyr@@, ray@@, millert@@, moritz@@, chl@@
@
text
@d1 1
a1 1
/*	$OpenBSD: message.c,v 1.15 2003/06/03 02:56:14 millert Exp $	*/
d40 1
a40 1
"$OpenBSD: message.c,v 1.15 2003/06/03 02:56:14 millert Exp $";
a512 1
	char *cp;
@


1.15
log
@Remove the advertising clause in the UCB license which Berkeley
rescinded 22 July 1999.  Proofed by myself and Theo.
@
text
@d1 1
a1 1
/*	$OpenBSD: message.c,v 1.14 2003/05/14 01:34:35 millert Exp $	*/
d40 1
a40 1
"$OpenBSD: message.c,v 1.14 2003/05/14 01:34:35 millert Exp $";
d520 1
a520 2
		if ((cp = strchr(msgbuf, '\n')) != NULL)
			*cp = CNULL;
@


1.14
log
@ o Sync w/ freerdist 0.92 minus the compress option
 o KNF and ANSIfy the function headers

Sparse file support is currently a no-op since it didn't work.
Proper sparse file support will be added later.
@
text
@d1 1
a1 1
/*	$OpenBSD: message.c,v 1.13 2003/04/19 17:22:29 millert Exp $	*/
d15 1
a15 5
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
d40 1
a40 1
"$OpenBSD: message.c,v 1.13 2003/04/19 17:22:29 millert Exp $";
@


1.13
log
@strcpy/strcat/sprintf removal; krw@@ OK
@
text
@d1 1
a1 1
/*	$OpenBSD: message.c,v 1.12 2003/04/06 18:57:44 deraadt Exp $	*/
d36 2
d40 2
a41 2
static char RCSid[] = 
"$From: message.c,v 6.24 1996/07/19 17:00:35 michaelc Exp $";
d43 2
a44 2
static char RCSid[] = 
"$OpenBSD: message.c,v 1.12 2003/04/06 18:57:44 deraadt Exp $";
d47 2
a48 1
static char sccsid[] = "@@(#)common.c";
d50 1
a50 1
static char copyright[] =
a58 1
#include "defs.h"
d81 4
a84 2
static void msgsendstdout(), msgsendfile(), msgsendsyslog(), 
	msgsendnotify();
d97 8
d108 2
a109 1
extern void msgprusage()
d132 2
a133 1
extern void msgprconfig()
d140 2
a141 2
		(void) snprintf(buf, sizeof(buf),
				"    %s=", msgfacility[i].mf_name);
d146 1
a146 1
					(void) strlcat(buf, ",", sizeof buf);
d148 1
a148 1
				    sizeof buf);
d158 2
a159 2
static MSGFACILITY *getmsgfac(name)
	char *name;
d173 2
a174 2
static MSGTYPE *getmsgtype(name)
	char *name;
d189 2
a190 3
static char *setmsgtypes(msgfac, str)
	MSGFACILITY *msgfac;
	char *str;
d203 2
a204 2
		"The \"%s\" message facility cannot be used by the server.",
				msgfac->mf_name);
d255 1
a255 1
		if ((cp = strchr(strptr, ',')))
d259 1
a259 1
		if ((mtp = getmsgtype(word))) {
d270 2
a271 2
					"Message type \"%s\" is invalid.",
					word);
d282 2
a283 3
extern char *msgparseopts(msgstr, doset)
	char *msgstr;
	int doset;
d294 1
a294 1
	(void) strlcpy(msgbuf, msgstr, sizeof msgbuf);
d314 2
a315 2
					"%s is not a valid message facility", 
					word);
d322 1
a322 1
			if ((mcp = setmsgtypes(msgfac, cp)))
d339 2
a340 6
static void msgsendstdout(msgfac, mtype, flags, msgbuf)
	/*ARGSUSED*/
	MSGFACILITY *msgfac;
	int mtype;
	int flags;
	char *msgbuf;
d393 2
a394 6
static void msgsendsyslog(msgfac, mtype, flags, msgbuf)
	/*ARGSUSED*/
	MSGFACILITY *msgfac;
	int mtype;
	int flags;
	char *msgbuf;
d434 2
a435 6
static void msgsendfile(msgfac, mtype, flags, msgbuf)
	/*ARGSUSED*/
	MSGFACILITY *msgfac;
	int mtype;
	int flags;
	char *msgbuf;
d450 2
a451 6
static void msgsendnotify(msgfac, mtype, flags, msgbuf)
	/*ARGSUSED*/
	MSGFACILITY *msgfac;
	int mtype;
	int flags;
	char *msgbuf;
a463 1
		char *getenv();
d469 1
a469 1
		if ((cp = getenv("TMPDIR")) == NULL)
d476 4
a479 7
		if ((fd = mkstemp(msgfac->mf_filename)) == -1 ||
		    (msgfac->mf_fptr = fdopen(fd, "w")) == NULL) {
			if (fd != -1)
				close(fd);
			fatalerr("Cannot open notify file for writing: %s: %s.",
			      msgfac->mf_filename, SYSERR);
		}
d494 2
a495 1
extern void checkhostname()
d513 2
a514 3
static void _message(flags, msgbuf)
	int flags;
	char *msgbuf;
d524 1
a524 1
		if ((cp = strchr(msgbuf, '\n')))
d529 1
a529 1
			(void) strlcpy(mbuf, msgbuf, sizeof mbuf);
d531 2
a532 2
			(void) snprintf(mbuf, sizeof mbuf,
			    "%s: %s", currenthost, msgbuf);
d534 1
a534 1
		(void) strlcpy(mbuf, "", sizeof mbuf);
d582 2
a583 1
extern void message(va_alist)
d596 1
a596 1
	(void) vsnprintf(buf, sizeof buf, fmt, args);
d606 2
a607 1
extern void message(int lvl, char *fmt, ...)
d613 1
a613 1
	(void) vsnprintf(buf, sizeof buf, fmt, args);
a619 18

#if	!defined(ARG_TYPE)
/*
 * Simple front-end to _message()
 */
/*VARARGS2*/
extern void message(lvl, fmt, a1, a2, a3, a4, a5)
	int lvl;
	char *fmt;
{
	static char buf[MSGBUFSIZ];

	(void) snprintf(buf, sizeof buf, fmt, a1, a2, a3, a4, a5);

	_message(lvl, buf);
}
#endif	/* !ARG_TYPE */

d623 2
a624 3
static void _debugmsg(lvl, buf)
	int lvl;
	char *buf;
d634 2
a635 1
extern void debugmsg(va_alist)
d648 1
a648 1
	(void) vsnprintf(buf, sizeof buf, fmt, args);
d658 2
a659 1
extern void debugmsg(int lvl, char *fmt, ...)
d665 1
a665 1
	(void) vsnprintf(buf, sizeof buf, fmt, args);
a671 17
#if	!defined(ARG_TYPE)
/*
 * Simple front-end to _debugmsg()
 */
/*VARARGS2*/
extern void debugmsg(lvl, fmt, a1, a2, a3, a4, a5)
	int lvl;
	char *fmt;
{
	static char buf[MSGBUFSIZ];

	(void) snprintf(buf, sizeof buf, fmt, a1, a2, a3, a4, a5);

	_debugmsg(lvl, buf);
}
#endif	/* ARG_TYPE */

d675 2
a676 2
static void _error(msg)
	char *msg;
d685 2
a686 1
			(void) snprintf(buf, sizeof buf, "REMOTE ERROR: %s", msg);
d688 2
a689 1
			(void) snprintf(buf, sizeof buf, "LOCAL ERROR: %s", msg);
d699 2
a700 1
extern void error(va_alist)
d711 1
a711 1
		(void) vsnprintf(buf, sizeof buf, fmt, args);
d722 2
a723 1
extern void error(char *fmt, ...)
d731 1
a731 1
		(void) vsnprintf(buf, sizeof buf, fmt, args);
a737 18
#if	!defined(ARG_TYPE)
/*
 * Simple frontend to _error()
 */
/*VARARGS1*/
extern void error(fmt, a1, a2, a3, a4, a5, a6)
	char *fmt;
{
	static char buf[MSGBUFSIZ];

	buf[0] = CNULL;
	if (fmt)
		(void) snprintf(buf, sizeof buf, fmt, a1, a2, a3, a4, a5, a6);

	_error((buf[0]) ? buf : NULL);
}
#endif /* ARG_TYPE */

d741 2
a742 2
static void _fatalerr(msg)
	char *msg;
d749 1
a749 1
		(void) snprintf(buf, sizeof buf, "REMOTE ERROR: %s", msg);
d751 1
a751 1
		(void) snprintf(buf, sizeof buf, "LOCAL ERROR: %s", msg);
d762 2
a763 1
extern void fatalerr(va_alist)
d772 1
a772 1
	(void) vsnprintf(buf, sizeof buf, fmt, args);
d783 2
a784 1
extern void fatalerr(char *fmt, ...)
d790 1
a790 1
	(void) vsnprintf(buf, sizeof buf, fmt, args);
a796 16
#if	!defined(ARG_TYPE)
/*
 * Simple front-end to _fatalerr()
 */
/*VARARGS1*/
extern void fatalerr(fmt, a1, a2, a3, a4, a5)
	char *fmt;
{
	static char buf[MSGBUFSIZ];

	(void) snprintf(buf, sizeof buf, fmt, a1, a2, a3, a4, a5);

	_fatalerr(buf);
}
#endif	/* !ARG_TYPE */

d803 2
a804 1
extern char *getnotifyfile()
@


1.12
log
@kill another strcat; ok krw
@
text
@d1 1
a1 1
/*	$OpenBSD: message.c,v 1.11 2003/04/05 20:31:58 deraadt Exp $	*/
d42 1
a42 1
"$OpenBSD: message.c,v 1.11 2003/04/05 20:31:58 deraadt Exp $";
a61 1
char		       *tempfile = NULL;	/* Name of temporary file */
d457 2
d476 1
a476 1
		len = strlen(cp) + 1 + strlen(_RDIST_TMP) + 2;
@


1.11
log
@strings; ok miod ho krw
@
text
@d1 1
a1 1
/*	$OpenBSD: message.c,v 1.10 2001/11/19 19:02:15 mpech Exp $	*/
d42 1
a42 1
"$OpenBSD: message.c,v 1.10 2001/11/19 19:02:15 mpech Exp $";
d133 3
a135 2
					(void) strcat(buf, ",");
				(void) strcat(buf, msgtypes[x].mt_name);
@


1.10
log
@kill more registers

millert@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: message.c,v 1.9 2000/11/10 15:33:12 provos Exp $	*/
d42 1
a42 1
"$OpenBSD: message.c,v 1.9 2000/11/10 15:33:12 provos Exp $";
d282 1
a282 1
	(void) strcpy(msgbuf, msgstr);
d467 1
d474 3
a476 3
		tempfile = (char *) xmalloc(strlen(cp) + 1 + 
					    strlen(_RDIST_TMP) + 2);
		(void) sprintf(tempfile, "%s/%s", cp, _RDIST_TMP);
d535 1
a535 1
			(void) strcpy(mbuf, msgbuf);
d537 2
a538 1
			(void) sprintf(mbuf, "%s: %s", currenthost, msgbuf);
d540 1
a540 1
		(void) strcpy(mbuf, "");
d601 1
a601 1
	(void) vsprintf(buf, fmt, args);
d617 1
a617 1
	(void) vsprintf(buf, fmt, args);
d636 1
a636 1
	(void) sprintf(buf, fmt, a1, a2, a3, a4, a5);
d670 1
a670 1
	(void) vsprintf(buf, fmt, args);
d686 1
a686 1
	(void) vsprintf(buf, fmt, args);
d704 1
a704 1
	(void) sprintf(buf, fmt, a1, a2, a3, a4, a5);
d723 1
a723 1
			(void) sprintf(buf, "REMOTE ERROR: %s", msg);
d725 1
a725 1
			(void) sprintf(buf, "LOCAL ERROR: %s", msg);
d746 1
a746 1
		(void) vsprintf(buf, fmt, args);
d765 1
a765 1
		(void) vsprintf(buf, fmt, args);
d784 1
a784 1
		(void) sprintf(buf, fmt, a1, a2, a3, a4, a5, a6);
d801 1
a801 1
		(void) sprintf(buf, "REMOTE ERROR: %s", msg);
d803 1
a803 1
		(void) sprintf(buf, "LOCAL ERROR: %s", msg);
d823 1
a823 1
	(void) vsprintf(buf, fmt, args);
d840 1
a840 1
	(void) vsprintf(buf, fmt, args);
d857 1
a857 1
	(void) sprintf(buf, fmt, a1, a2, a3, a4, a5);
@


1.9
log
@seperate -> separate, okay aaron@@
@
text
@d1 1
a1 1
/*	$OpenBSD: message.c,v 1.8 1999/02/04 23:18:57 millert Exp $	*/
d42 1
a42 1
"$OpenBSD: message.c,v 1.8 1999/02/04 23:18:57 millert Exp $";
d99 1
a99 1
	register int i, x;
d122 1
a122 1
	register int i, x;
d147 1
a147 1
	register int i;
d162 1
a162 1
	register int i;
d180 3
a182 3
	register char *cp;
	register char *strptr, *word;
	register MSGTYPE *mtp;
d274 2
a275 2
	register char *cp, *optstr;
	register char *word;
d464 1
a464 1
		register char *cp;
d521 2
a522 2
	register int i, x;
	register char *cp;
d869 1
a869 1
	register int i;
@


1.8
log
@Fix a serious memory consumption problem when running over directories
that contain many hard-linked files; johnh@@isi.edu
Also add an xstrdup() that behaves like xmalloc() on failure.
@
text
@d1 1
a1 1
/*	$OpenBSD: message.c,v 1.7 1998/06/26 21:21:15 millert Exp $	*/
d42 1
a42 1
"$OpenBSD: message.c,v 1.7 1998/06/26 21:21:15 millert Exp $";
d285 1
a285 1
	 * Each <facility>=<types> list is seperated by ":".
@


1.7
log
@rdist 6.1.4 + OpenBSD patches + some -Wall
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d42 1
a42 1
"$OpenBSD$";
d213 1
a213 1
		msgfac->mf_filename = strdup(strptr);
d508 1
a508 1
			currenthost = strdup(mbuf);
@


1.6
log
@Now have a common message.c instead of two copies.
@
text
@d1 1
a1 1
/*	$OpenBSD: message.c,v 1.5 1996/07/25 05:31:02 millert Exp $	*/
d37 1
d39 5
a43 1
"$OpenBSD: message.c,v 1.5 1996/07/25 05:31:02 millert Exp $";
d153 1
a153 1
	return((MSGFACILITY *) NULL);
d168 1
a168 1
	return((MSGTYPE *) NULL);
d191 1
a191 1
			       msgfac->mf_name);
d242 1
a242 1
		if (cp = strchr(strptr, ','))
d246 1
a246 1
		if (mtp = getmsgtype(word)) {
d263 1
a263 1
	return((char *) NULL);
d288 1
a288 1
	     optstr = strtok((char *)NULL, ":")) {
d310 1
a310 1
			if (mcp = setmsgtypes(msgfac, cp))
d320 1
a320 1
	return((char *) NULL);
d465 1
a466 1
		int fd;
d471 1
a471 1
		if ((cp = getenv("TMPDIR")) == (char *) NULL)
d529 1
a529 1
		if (cp = strchr(msgbuf, '\n'))
d545 1
a545 1
		msgsendsyslog((MSGFACILITY *)NULL, MT_SYSLOG, flags, mbuf);
d553 1
a553 1
		msgsendstdout((MSGFACILITY *)NULL, MT_NOTICE, flags, mbuf);
d556 1
a556 1
		msgsendstdout((MSGFACILITY *)NULL, MT_REMOTE, flags, mbuf);
d558 1
a558 1
		msgsendstdout((MSGFACILITY *)NULL, MT_NERROR, flags, mbuf);
d560 1
a560 1
		msgsendstdout((MSGFACILITY *)NULL, MT_FERROR, flags, mbuf);
d879 1
a879 1
	return((char *) NULL);
@


1.5
log
@Updated to rdist 6.1.3.  Used real snprintf() (instead of string length
in the format) since we have it.
@
text
@d1 1
a1 1
/*	$OpenBSD: message.c,v 1.4 1996/06/26 05:38:14 deraadt Exp $	*/
d38 1
a38 1
"$OpenBSD: message.c,v 1.4 1996/06/26 05:38:14 deraadt Exp $";
a451 2
	int fd;

d461 1
d474 1
a474 1
		    (msgfac->mf_fptr = fdopen(fd, "w"))==NULL) {
@


1.4
log
@rcsid
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d38 1
a38 1
"$OpenBSD: message.c,v 1.3 1996/06/25 22:23:18 deraadt Exp $";
d122 2
a123 1
		(void) sprintf(buf, "    %s=", msgfacility[i].mf_name);
d184 1
a184 1
		(void) sprintf(ebuf,
d251 3
a253 2
			(void) sprintf(ebuf, "Message type \"%s\" is invalid.",
				       word);
d296 3
a298 3
			(void) sprintf(ebuf, 
				       "%s is not a valid message facility", 
				       word);
d548 4
a551 1
	if (isserver && IS_ON(flags, MT_REMOTE))
a556 4
	else if (isserver && IS_ON(flags, MT_NOTICE)) {
		msgsendstdout((MSGFACILITY *)NULL, MT_NOTICE, flags, mbuf);
		return;
	}
@


1.3
log
@mkstemp & fdopen
@
text
@d1 2
d38 1
a38 1
"$Id: message.c,v 1.2 1996/03/05 03:16:08 dm Exp $";
@


1.2
log
@rdist 6.1.2
@
text
@d36 1
a36 1
"$Id: message.c,v 6.22 1995/12/11 23:37:35 mcooper Exp $";
d448 2
d470 4
a473 2
		(void) mktemp(msgfac->mf_filename);
		if ((msgfac->mf_fptr = fopen(msgfac->mf_filename, "w"))==NULL)
d476 1
@


1.1
log
@rdist 6.1.1
@
text
@@
