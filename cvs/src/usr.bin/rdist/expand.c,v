head	1.15;
access;
symbols
	OPENBSD_6_2:1.15.0.14
	OPENBSD_6_2_BASE:1.15
	OPENBSD_6_1:1.15.0.12
	OPENBSD_6_1_BASE:1.15
	OPENBSD_6_0:1.15.0.8
	OPENBSD_6_0_BASE:1.15
	OPENBSD_5_9:1.15.0.4
	OPENBSD_5_9_BASE:1.15
	OPENBSD_5_8:1.15.0.6
	OPENBSD_5_8_BASE:1.15
	OPENBSD_5_7:1.15.0.2
	OPENBSD_5_7_BASE:1.15
	OPENBSD_5_6:1.14.0.4
	OPENBSD_5_6_BASE:1.14
	OPENBSD_5_5:1.13.0.8
	OPENBSD_5_5_BASE:1.13
	OPENBSD_5_4:1.13.0.4
	OPENBSD_5_4_BASE:1.13
	OPENBSD_5_3:1.13.0.2
	OPENBSD_5_3_BASE:1.13
	OPENBSD_5_2:1.12.0.12
	OPENBSD_5_2_BASE:1.12
	OPENBSD_5_1_BASE:1.12
	OPENBSD_5_1:1.12.0.10
	OPENBSD_5_0:1.12.0.8
	OPENBSD_5_0_BASE:1.12
	OPENBSD_4_9:1.12.0.6
	OPENBSD_4_9_BASE:1.12
	OPENBSD_4_8:1.12.0.4
	OPENBSD_4_8_BASE:1.12
	OPENBSD_4_7:1.12.0.2
	OPENBSD_4_7_BASE:1.12
	OPENBSD_4_6:1.11.0.28
	OPENBSD_4_6_BASE:1.11
	OPENBSD_4_5:1.11.0.24
	OPENBSD_4_5_BASE:1.11
	OPENBSD_4_4:1.11.0.22
	OPENBSD_4_4_BASE:1.11
	OPENBSD_4_3:1.11.0.20
	OPENBSD_4_3_BASE:1.11
	OPENBSD_4_2:1.11.0.18
	OPENBSD_4_2_BASE:1.11
	OPENBSD_4_1:1.11.0.16
	OPENBSD_4_1_BASE:1.11
	OPENBSD_4_0:1.11.0.14
	OPENBSD_4_0_BASE:1.11
	OPENBSD_3_9:1.11.0.12
	OPENBSD_3_9_BASE:1.11
	OPENBSD_3_8:1.11.0.10
	OPENBSD_3_8_BASE:1.11
	OPENBSD_3_7:1.11.0.8
	OPENBSD_3_7_BASE:1.11
	OPENBSD_3_6:1.11.0.6
	OPENBSD_3_6_BASE:1.11
	OPENBSD_3_5:1.11.0.4
	OPENBSD_3_5_BASE:1.11
	OPENBSD_3_4:1.11.0.2
	OPENBSD_3_4_BASE:1.11
	OPENBSD_3_3:1.7.0.6
	OPENBSD_3_3_BASE:1.7
	OPENBSD_3_2:1.7.0.4
	OPENBSD_3_2_BASE:1.7
	OPENBSD_3_1:1.7.0.2
	OPENBSD_3_1_BASE:1.7
	OPENBSD_3_0:1.6.0.14
	OPENBSD_3_0_BASE:1.6
	OPENBSD_2_9_BASE:1.6
	OPENBSD_2_9:1.6.0.12
	OPENBSD_2_8:1.6.0.10
	OPENBSD_2_8_BASE:1.6
	OPENBSD_2_7:1.6.0.8
	OPENBSD_2_7_BASE:1.6
	OPENBSD_2_6:1.6.0.6
	OPENBSD_2_6_BASE:1.6
	OPENBSD_2_5:1.6.0.4
	OPENBSD_2_5_BASE:1.6
	OPENBSD_2_4:1.6.0.2
	OPENBSD_2_4_BASE:1.6
	OPENBSD_2_3:1.4.0.8
	OPENBSD_2_3_BASE:1.4
	OPENBSD_2_2:1.4.0.6
	OPENBSD_2_2_BASE:1.4
	OPENBSD_2_1:1.4.0.4
	OPENBSD_2_1_BASE:1.4
	OPENBSD_2_0:1.4.0.2
	OPENBSD_2_0_BASE:1.4
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.15
date	2015.01.20.09.00.16;	author guenther;	state Exp;
branches;
next	1.14;
commitid	0Y0sKBv6c3xIKoav;

1.14
date	2014.07.05.06.45.00;	author guenther;	state Exp;
branches;
next	1.13;
commitid	zoLIfEXn2KDMNucz;

1.13
date	2012.11.12.01.14.41;	author guenther;	state Exp;
branches;
next	1.12;

1.12
date	2009.10.27.23.59.42;	author deraadt;	state Exp;
branches;
next	1.11;

1.11
date	2003.06.03.02.56.14;	author millert;	state Exp;
branches;
next	1.10;

1.10
date	2003.05.14.01.34.35;	author millert;	state Exp;
branches;
next	1.9;

1.9
date	2003.04.19.17.22.29;	author millert;	state Exp;
branches;
next	1.8;

1.8
date	2003.04.05.20.31.58;	author deraadt;	state Exp;
branches;
next	1.7;

1.7
date	2001.11.19.19.02.15;	author mpech;	state Exp;
branches;
next	1.6;

1.6
date	98.08.13.03.29.09;	author deraadt;	state Exp;
branches;
next	1.5;

1.5
date	98.06.26.21.21.10;	author millert;	state Exp;
branches;
next	1.4;

1.4
date	96.06.26.05.38.12;	author deraadt;	state Exp;
branches;
next	1.3;

1.3
date	96.03.05.03.16.04;	author dm;	state Exp;
branches;
next	1.2;

1.2
date	96.02.03.12.12.23;	author dm;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.45.59;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.45.59;	author deraadt;	state Exp;
branches;
next	;


desc
@@


1.15
log
@Split out from rdist/defs.h the client-only and server-only bits into
 rdist/client.h and rdistd/server.h
Only put #includes in .h files that are necessary for the .h to be used;
 all other #includes go in the .c files
Move all extern variable declarations to the .h files, renaming local
 variables to avoid shadowing
Replace me_type member of mntent_t with an "is NFS?" flag bit
@
text
@/*	$OpenBSD: expand.c,v 1.14 2014/07/05 06:45:00 guenther Exp $	*/

/*
 * Copyright (c) 1983 Regents of the University of California.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */

#include <dirent.h>
#include <errno.h>
#include <fcntl.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>

#include "client.h"

#define	MAXEARGS	2048
#define LC 		'{'
#define RC 		'}'

static char	shchars[] = "${[*?";

int		which;		/* bit mask of types to expand */
int		eargc;		/* expanded arg count */
char	      **eargv;		/* expanded arg vectors */
char	       *path;
char	       *pathp;
char	       *lastpathp;
char	       *tilde;		/* "~user" if not expanding tilde, else "" */
char	       *tpathp;

int		expany;		/* any expansions done? */
char	       *entp;
char	      **sortbase;
char 	       *argvbuf[MAXEARGS];

#define sort()	qsort((char *)sortbase, &eargv[eargc] - sortbase, \
		      sizeof(*sortbase), argcmp), sortbase = &eargv[eargc]

static void Cat(u_char *, u_char *);
static void addpath(int);
static int argcmp(const void *, const void *);

static void
Cat(u_char *s1, u_char *s2)		/* quote in s1 and s2 */
{
	char *cp;
	int len = strlen((char *)s1) + strlen((char *)s2) + 2;

	if ((eargc + 1) >= MAXEARGS) {
		yyerror("Too many names");
		return;
	}

	eargv[++eargc] = NULL;
	eargv[eargc - 1] = cp = xmalloc(len);

	do { 
		if (*s1 == QUOTECHAR) 
			s1++; 
	} while ((*cp++ = *s1++) != '\0');
	cp--;
	do { 
		if (*s2 == QUOTECHAR) 
			s2++; 
	} while ((*cp++ = *s2++) != '\0');
}

static void
addpath(int c)
{
	if (pathp >= lastpathp) {
		yyerror("Pathname too long");
		return;
	} else {
		*pathp++ = c;
		*pathp = CNULL;
	}
}

/*
 * Take a list of names and expand any macros, etc.
 * wh = E_VARS if expanding variables.
 * wh = E_SHELL if expanding shell characters.
 * wh = E_TILDE if expanding `~'.
 * or any of these or'ed together.
 *
 * Major portions of this were snarfed from csh/sh.glob.c.
 */
struct namelist *
expand(struct namelist *list, int wh)		/* quote in list->n_name */
{
	struct namelist *nl, *prev;
	int n;
	char pathbuf[BUFSIZ];

	if (debug)
		debugmsg(DM_CALL, "expand(%p, %d) start, list = %s", 
			 list, wh, getnlstr(list));

	if (wh == 0)
		fatalerr("expand() contains invalid 'wh' argument.");

	which = wh;
	path = tpathp = pathp = pathbuf;
	*pathp = CNULL;
	lastpathp = &pathbuf[sizeof pathbuf - 2];
	tilde = "";
	eargc = 0;
	eargv = sortbase = argvbuf;
	*eargv = NULL;

	/*
	 * Walk the name list and expand names into eargv[];
	 */
	for (nl = list; nl != NULL; nl = nl->n_next)
		expstr((u_char *)nl->n_name);
	/*
	 * Take expanded list of names from eargv[] and build a new list.
	 */
	list = prev = NULL;
	for (n = 0; n < eargc; n++) {
		nl = makenl(NULL);
		nl->n_name = eargv[n];
		if (prev == NULL)
			list = prev = nl;
		else {
			prev->n_next = nl;
			prev = nl;
		}
	}

	return(list);
}

/*
 * xstrchr() is a version of strchr() that
 * handles u_char buffers.
 */
u_char *
xstrchr(u_char *str, int ch)
{
	u_char *cp;

	for (cp = str; cp && *cp != CNULL; ++cp)
		if (ch == *cp)
			return(cp);

	return(NULL);
}

void
expstr(u_char *s)
{
	u_char *cp, *cp1;
	struct namelist *tp;
	u_char *tail;
	u_char ebuf[BUFSIZ];
	u_char varbuff[BUFSIZ];
	int savec, oeargc;

	if (s == NULL || *s == CNULL)
		return;

	/*
	 * Remove quoted characters
	 */
	if (IS_ON(which, E_VARS)) {
		if (strlen((char *)s) > sizeof(varbuff)) {
			yyerror("Variable is too large.");
			return;
		}
		for (cp = s, cp1 = varbuff; cp && *cp; ++cp) {
			/* 
			 * remove quoted character if the next
			 * character is not $
			 */
			if (*cp == QUOTECHAR && *(cp+1) != '$')
				++cp;
			else
				*cp1++ = *cp;
		}
		*cp1 = CNULL;
		s = varbuff;
	}

	/*
	 * Consider string 's' a variable that should be expanded if
	 * there is a '$' in 's' that is not quoted.
	 */
	if (IS_ON(which, E_VARS) && 
	    ((cp = xstrchr(s, '$')) && !(cp > s && *(cp-1) == QUOTECHAR))) {
		*cp++ = CNULL;
		if (*cp == CNULL) {
			yyerror("no variable name after '$'");
			return;
		}
		if (*cp == LC) {
			cp++;
			for (cp1 = cp; ; cp1 = tail + 1) {
				if ((tail = xstrchr(cp1, RC)) == NULL) {
					yyerror("unmatched '{'");
					return;
				}
				if (tail[-1] != QUOTECHAR) break;
			}
			*tail++ = savec = CNULL;
			if (*cp == CNULL) {
				yyerror("no variable name after '$'");
				return;
			}
		} else {
			tail = cp + 1;
			savec = *tail;
			*tail = CNULL;
		}
		tp = lookup((char *)cp, LOOKUP, NULL);
		if (savec != CNULL)
			*tail = savec;
		if (tp != NULL) {
			for (; tp != NULL; tp = tp->n_next) {
				(void) snprintf((char *)ebuf, sizeof(ebuf),
					        "%s%s%s", s, tp->n_name, tail);
				expstr(ebuf);
			}
			return;
		}
		(void) snprintf((char *)ebuf, sizeof(ebuf), "%s%s", s, tail);
		expstr(ebuf);
		return;
	}
	if ((which & ~E_VARS) == 0 || !strcmp((char *)s, "{") || 
	    !strcmp((char *)s, "{}")) {
		Cat(s, (u_char *)"");
		sort();
		return;
	}
	if (*s == '~') {
		cp = ++s;
		if (*cp == CNULL || *cp == '/') {
			tilde = "~";
			cp1 = (u_char *)homedir;
		} else {
			tilde = (char *)(cp1 = ebuf);
			*cp1++ = '~';
			do
				*cp1++ = *cp++;
			while (*cp && *cp != '/');
			*cp1 = CNULL;
			if (pw == NULL || strcmp(pw->pw_name, 
						 (char *)ebuf+1) != 0) {
				if ((pw = getpwnam((char *)ebuf+1)) == NULL) {
					strlcat((char *)ebuf, 
					        ": unknown user name",
					        sizeof(ebuf));
					yyerror((char *)ebuf+1);
					return;
				}
			}
			cp1 = (u_char *)pw->pw_dir;
			s = cp;
		}
		for (cp = (u_char *)path; (*cp++ = *cp1++) != '\0'; )
			continue;
		tpathp = pathp = (char *)cp - 1;
	} else {
		tpathp = pathp = path;
		tilde = "";
	}
	*pathp = CNULL;
	if (!(which & E_SHELL)) {
		if (which & E_TILDE)
			Cat((u_char *)path, s);
		else
			Cat((u_char *)tilde, s);
		sort();
		return;
	}
	oeargc = eargc;
	expany = 0;
	expsh(s);
	if (eargc == oeargc)
		Cat(s, (u_char *)"");		/* "nonomatch" is set */
	sort();
}

static int
argcmp(const void *v1, const void *v2)
{
	const char *const *a1 = v1, *const *a2 = v2;

	return (strcmp(*a1, *a2));
}

/*
 * If there are any Shell meta characters in the name,
 * expand into a list, after searching directory
 */
void
expsh(u_char *s)			/* quote in s */
{
	u_char *cp, *oldcp;
	char *spathp;
	struct stat stb;

	spathp = pathp;
	cp = s;
	while (!any(*cp, shchars)) {
		if (*cp == CNULL) {
			if (!expany || stat(path, &stb) >= 0) {
				if (which & E_TILDE)
					Cat((u_char *)path, (u_char *)"");
				else
					Cat((u_char *)tilde, (u_char *)tpathp);
			}
			goto endit;
		}
		if (*cp == QUOTECHAR) cp++;
		addpath(*cp++);
	}
	oldcp = cp;
	while (cp > s && *cp != '/')
		cp--, pathp--;
	if (*cp == '/')
		cp++, pathp++;
	*pathp = CNULL;
	if (*oldcp == '{') {
		(void) execbrc(cp, NULL);
		return;
	}
	matchdir((char *)cp);
endit:
	pathp = spathp;
	*pathp = CNULL;
}

void
matchdir(char *pattern)			/* quote in pattern */
{
	struct stat stb;
	struct dirent *dp;
	DIR *dirp;

	dirp = opendir(path);
	if (dirp == NULL) {
		if (expany)
			return;
		goto patherr2;
	}
	if (fstat(dirfd(dirp), &stb) < 0)
		goto patherr1;
	if (!S_ISDIR(stb.st_mode)) {
		errno = ENOTDIR;
		goto patherr1;
	}
	while ((dp = readdir(dirp)) != NULL)
		if (match(dp->d_name, pattern)) {
			if (which & E_TILDE)
				Cat((u_char *)path, (u_char *)dp->d_name);
			else {
				(void) strlcpy(pathp, dp->d_name,
				    lastpathp - pathp + 2);
				Cat((u_char *)tilde, (u_char *)tpathp);
				*pathp = CNULL;
			}
		}
	closedir(dirp);
	return;

patherr1:
	closedir(dirp);
patherr2:
	(void) strlcat(path, ": ", lastpathp - path + 2);
	(void) strlcat(path, SYSERR, lastpathp - path + 2);
	yyerror(path);
}

int
execbrc(u_char *p, u_char *s)		/* quote in p */
{
	u_char restbuf[BUFSIZ + 2];
	u_char *pe, *pm, *pl;
	int brclev = 0;
	u_char *lm, savec;
	char *spathp;

	for (lm = restbuf; *p != '{'; *lm++ = *p++)
		if (*p == QUOTECHAR) *lm++ = *p++;

	for (pe = ++p; *pe; pe++)
		switch (*pe) {

		case '{':
			brclev++;
			continue;

		case '}':
			if (brclev == 0)
				goto pend;
			brclev--;
			continue;

		case '[':
			for (pe++; *pe && *pe != ']'; pe++)
				if (*p == QUOTECHAR) pe++;
			if (!*pe)
				yyerror("Missing ']'");
			continue;

		case QUOTECHAR:		/* skip this character */
			pe++;
			continue;
		}
pend:
	if (brclev || !*pe) {
		yyerror("Missing '}'");
		return (0);
	}
	for (pl = pm = p; pm <= pe; pm++)
		/* the strip code was a noop */
		switch (*pm) {

		case '{':
			brclev++;
			continue;

		case '}':
			if (brclev) {
				brclev--;
				continue;
			}
			goto doit;

		case ',':
			if (brclev)
				continue;
doit:
			savec = *pm;
			*pm = 0;
			*lm = 0;
			(void) strlcat((char *)restbuf, (char *)pl,
			    sizeof(restbuf));
			(void) strlcat((char *)restbuf, (char *)pe + 1,
			    sizeof(restbuf));
			*pm = savec;
			if (s == 0) {
				spathp = pathp;
				expsh(restbuf);
				pathp = spathp;
				*pathp = 0;
			} else if (amatch((char *)s, restbuf))
				return (1);
			sort();
			pl = pm + 1;
			continue;

		case '[':
			for (pm++; *pm && *pm != ']'; pm++)
				if (*pm == QUOTECHAR) pm++;
			if (!*pm)
				yyerror("Missing ']'");
			continue;

		case QUOTECHAR:			/* skip one character */
			pm++;
			continue;
		}
	return (0);
}

int
match(char *s, char *p)				/* quote in p */
{
	int c;
	char *sentp;
	char sexpany = expany;

	if (*s == '.' && *p != '.')
		return (0);
	sentp = entp;
	entp = s;
	c = amatch(s, p);
	entp = sentp;
	expany = sexpany;
	return (c);
}

int
amatch(char *s, u_char *p)			/* quote in p */
{
	int scc;
	int ok, lc;
	char *spathp;
	struct stat stb;
	int c, cc;

	expany = 1;
	for (;;) {
		scc = *s++;
		switch (c = *p++) {

		case '{':
			return (execbrc((u_char *)p - 1, (u_char *)s - 1));

		case '[':
			ok = 0;
			lc = 077777;
			while ((cc = *p++) != '\0') {
				if (cc == ']') {
					if (ok)
						break;
					return (0);
				}
				if (cc == QUOTECHAR) cc = *p++;
				if (cc == '-') {
					if (lc <= scc && scc <= (int)*p++)
						ok++;
				} else
					if (scc == (lc = cc))
						ok++;
			}
			if (cc == 0) {
				yyerror("Missing ']'");
				return (0);
			}
			continue;

		case '*':
			if (!*p)
				return (1);
			if (*p == '/') {
				p++;
				goto slash;
			}
			for (s--; *s; s++)
				if (amatch(s, p))
					return (1);
			return (0);

		case CNULL:
			return (scc == CNULL);

		default:
			if (c != scc)
				return (0);
			continue;

		case '?':
			if (scc == CNULL)
				return (0);
			continue;

		case '/':
			if (scc)
				return (0);
slash:
			s = entp;
			spathp = pathp;
			while (*s)
				addpath(*s++);
			addpath('/');
			if (stat(path, &stb) == 0 && S_ISDIR(stb.st_mode)) {
				if (*p == CNULL) {
					if (which & E_TILDE) {
						Cat((u_char *)path, 
						    (u_char *)"");
					} else {
						Cat((u_char *)tilde, 
						    (u_char *)tpathp);
					}
				} else
					expsh(p);
			}
			pathp = spathp;
			*pathp = CNULL;
			return (0);
		}
	}
}
@


1.14
log
@Assume POSIX: <dirent.h>, struct dirent
@
text
@d1 1
a1 1
/*	$OpenBSD: expand.c,v 1.13 2012/11/12 01:14:41 guenther Exp $	*/
d33 5
d39 1
a39 1
#include "defs.h"
a184 1
	extern char *homedir;
@


1.13
log
@Fix various format string issues.  Stop assuming time_t is long or smaller.
Enable warnings.

ok krw@@, ian@@
@
text
@d1 1
a1 1
/*	$OpenBSD: expand.c,v 1.12 2009/10/27 23:59:42 deraadt Exp $	*/
d32 2
d361 1
a361 1
	DIRENTRY *dp;
@


1.12
log
@rcsid[] and sccsid[] and copyright[] are essentially unmaintained (and
unmaintainable).  these days, people use source.  these id's do not provide
any benefit, and do hurt the small install media
(the 33,000 line diff is essentially mechanical)
ok with the idea millert, ok dms
@
text
@d1 1
a1 1
/*	$OpenBSD: expand.c,v 1.11 2003/06/03 02:56:14 millert Exp $	*/
d115 1
a115 1
		debugmsg(DM_CALL, "expand(%x, %d) start, list = %s", 
@


1.11
log
@Remove the advertising clause in the UCB license which Berkeley
rescinded 22 July 1999.  Proofed by myself and Theo.
@
text
@d1 1
a1 1
/*	$OpenBSD: expand.c,v 1.10 2003/05/14 01:34:35 millert Exp $	*/
a32 17
#ifndef lint
#if 0
static char RCSid[] __attribute__((__unused__)) = 
"$From: expand.c,v 1.4 1999/08/04 15:57:33 christos Exp $";
#else
static char RCSid[] __attribute__((__unused__)) = 
"$OpenBSD: expand.c,v 1.10 2003/05/14 01:34:35 millert Exp $";
#endif

static char sccsid[] __attribute__((__unused__)) =
"@@(#)expand.c	5.2 (Berkeley) 3/28/86";

char copyright[] __attribute__((__unused__)) =
"@@(#) Copyright (c) 1983 Regents of the University of California.\n\
 All rights reserved.\n";
#endif /* not lint */

@


1.10
log
@ o Sync w/ freerdist 0.92 minus the compress option
 o KNF and ANSIfy the function headers

Sparse file support is currently a no-op since it didn't work.
Proper sparse file support will be added later.
@
text
@d1 1
a1 1
/*	$OpenBSD: expand.c,v 1.9 2003/04/19 17:22:29 millert Exp $	*/
d15 1
a15 5
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
d39 1
a39 1
"$OpenBSD: expand.c,v 1.9 2003/04/19 17:22:29 millert Exp $";
@


1.9
log
@strcpy/strcat/sprintf removal; krw@@ OK
@
text
@d1 1
a1 1
/*	$OpenBSD: expand.c,v 1.8 2003/04/05 20:31:58 deraadt Exp $	*/
d36 1
d39 2
a40 2
static char RCSid[] = 
"$From: expand.c,v 6.18 1998/03/24 00:37:10 michaelc Exp $";
d42 2
a43 2
static char RCSid[] = 
"$OpenBSD: expand.c,v 1.8 2003/04/05 20:31:58 deraadt Exp $";
d46 2
a47 1
static char sccsid[] = "@@(#)expand.c	5.2 (Berkeley) 3/28/86";
d49 1
a49 1
char copyright[] =
a53 1
#include "defs.h"
a74 5
static int	argcmp();
void    	expstr();
void    	expsh();
void    	matchdir();

d78 6
a83 2
static void Cat(s1, s2)				/* quote in s1 and s2 */
	u_char *s1, *s2;
d99 1
a99 1
	} while ((*cp++ = *s1++));
d104 1
a104 1
	} while ((*cp++ = *s2++));
d107 2
a108 2
static void addpath(c)
	char c;
d129 1
a129 3
expand(list, wh)				/* quote in list->n_name */
	struct namelist *list;
	int wh;
d178 2
a179 3
u_char *xstrchr(str, ch)
	u_char *str;
	int ch;
d190 2
a191 2
void expstr(s)
	u_char *s;
d208 1
a208 1
		if ((int)strlen((char *)s) > sizeof(varbuff)) {
d261 2
a262 2
				(void) snprintf((char *)ebuf, sizeof ebuf,
				    "%s%s%s", s, tp->n_name, tail);
d267 1
a267 1
		(void) snprintf((char *)ebuf, sizeof ebuf, "%s%s", s, tail);
d292 3
a294 3
					strlcat((char *)ebuf,
					    ": unknown user name",
					    sizeof(ebuf));
d302 2
a303 2
		for (cp = (u_char *)path; (*cp++ = *cp1++); )
			;
d327 1
a327 2
argcmp(a1, a2)
	char **a1, **a2;
d329 1
d338 2
a339 2
void expsh(s)				/* quote in s */
	u_char *s;
d376 2
a377 2
void matchdir(pattern)				/* quote in pattern */
	char *pattern;
d389 1
a389 1
	if (fstat(dirp->dd_fd, &stb) < 0)
d418 1
a418 2
execbrc(p, s)				/* quote in p */
	u_char *p, *s;
d481 1
a481 1
			    sizeof restbuf);
d483 1
a483 1
			    sizeof restbuf);
d511 1
a511 2
match(s, p)					/* quote in p */
	char *s, *p;
d528 1
a528 3
amatch(s, p)					/* quote in p */
	char *s;
	u_char *p;
d547 1
a547 1
			while ((cc = *p++)) {
d601 1
a601 1
			if (stat(path, &stb) == 0 && S_ISDIR(stb.st_mode))
d603 1
a603 1
					if (which & E_TILDE)
d606 1
a606 1
					else
d609 2
a610 1
				} else {
d612 1
a612 1
				}
@


1.8
log
@strings; ok miod ho krw
@
text
@d1 1
a1 1
/*	$OpenBSD: expand.c,v 1.7 2001/11/19 19:02:15 mpech Exp $	*/
d42 1
a42 1
"$OpenBSD: expand.c,v 1.7 2001/11/19 19:02:15 mpech Exp $";
d147 1
a147 1
	lastpathp = &path[sizeof pathbuf - 2];
d295 3
a297 2
					strcat((char *)ebuf, 
					       ": unknown user name");
d403 2
a404 1
				(void) strcpy(pathp, dp->d_name);
d415 2
a416 2
	(void) strcat(path, ": ");
	(void) strcat(path, SYSERR);
d483 3
a485 1
			(void) strcpy((char *)lm, (char *)pl);
@


1.7
log
@kill more registers

millert@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: expand.c,v 1.6 1998/08/13 03:29:09 deraadt Exp $	*/
d42 1
a42 1
"$OpenBSD: expand.c,v 1.6 1998/08/13 03:29:09 deraadt Exp $";
d482 2
a483 1
			(void) strcat((char *)restbuf, (char *)pe + 1);
@


1.6
log
@buf oflow; spotted by jmcdonal@@UNF.EDU
@
text
@d1 1
a1 1
/*	$OpenBSD: expand.c,v 1.5 1998/06/26 21:21:10 millert Exp $	*/
d42 1
a42 1
"$OpenBSD: expand.c,v 1.5 1998/06/26 21:21:10 millert Exp $";
d83 1
a83 1
	register u_char *s1, *s2;
d85 1
a85 1
	register char *cp;
d133 2
a134 2
	register struct namelist *nl, *prev;
	register int n;
d184 1
a184 1
	register u_char *cp;
d196 2
a197 2
	register u_char *cp, *cp1;
	register struct namelist *tp;
d343 2
a344 2
	register u_char *cp, *oldcp;
	register char *spathp;
d382 1
a382 1
	register DIRENTRY *dp;
d423 1
a423 1
	register u_char *pe, *pm, *pl;
d513 2
a514 2
	register int c;
	register char *sentp;
d529 2
a530 2
	register char *s;
	register u_char *p;
d532 1
a532 1
	register int scc;
@


1.5
log
@rdist 6.1.4 + OpenBSD patches + some -Wall
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d42 1
a42 1
"$OpenBSD$";
d264 2
a265 2
				(void) sprintf((char *)ebuf, 
					       "%s%s%s", s, tp->n_name, tail);
d270 1
a270 1
		(void) sprintf((char *)ebuf, "%s%s", s, tail);
@


1.4
log
@rcsid
@
text
@d37 1
d39 5
a43 1
"$OpenBSD: expand.c,v 1.3 1996/03/05 03:16:04 dm Exp $";
d93 1
a93 1
	eargv[++eargc] = (char *) NULL;
d99 1
a99 1
	} while (*cp++ = *s1++);
d104 1
a104 1
	} while (*cp++ = *s2++);
d151 1
a151 1
	*eargv = (char *) NULL;
d163 1
a163 1
		nl = makenl((char *)NULL);
d190 1
a190 1
	return((u_char *)NULL);
d259 1
a259 1
		tp = lookup((char *)cp, LOOKUP, (struct namelist *)NULL);
d304 1
a304 1
		for (cp = (u_char *)path; *cp++ = *cp1++; )
d328 1
a328 1
static
d369 1
a369 1
		(void) execbrc(cp, (u_char *)NULL);
d418 1
d509 1
d527 1
d549 1
a549 1
			while (cc = *p++) {
d611 1
a611 1
				} else
d613 1
@


1.3
log
@rdist 6.1.2
@
text
@d1 2
d38 1
a38 1
"$Id: expand.c,v 6.17 1994/03/14 23:25:24 mcooper Exp $";
@


1.2
log
@rdist 6.1.1
@
text
@@


1.1
log
@Initial revision
@
text
@d2 2
a3 2
 * Copyright (c) 1983, 1993
 *	The Regents of the University of California.  All rights reserved.
d35 8
a42 2
/* from: static char sccsid[] = "@@(#)expand.c	8.1 (Berkeley) 6/9/93"; */
static char *rcsid = "$Id: expand.c,v 1.5 1994/03/07 05:05:28 cgd Exp $";
d47 3
a49 3
#define	GAVSIZ	NCARGS / 6
#define LC '{'
#define RC '}'
d53 18
a70 13
int	which;		/* bit mask of types to expand */
int	eargc;		/* expanded arg count */
char	**eargv;	/* expanded arg vectors */
char	*path;
char	*pathp;
char	*lastpathp;
char	*tilde;		/* "~user" if not expanding tilde, else "" */
char	*tpathp;
int	nleft;

int	expany;		/* any expansions done? */
char	*entp;
char	**sortbase;
d75 36
a110 10
static void	Cat __P((char *, char *));
static void	addpath __P((int));
static int	amatch __P((char *, char *));
static int	argcmp __P((const void *, const void *));
static int	execbrc __P((char *, char *));
static void	expsh __P((char *));
static void	expstr __P((char *));
static int	match __P((char *, char *));
static void	matchdir __P((char *));
static int	smatch __P((char *, char *));
d122 1
a122 1
expand(list, wh)
a128 6
	char *argvbuf[GAVSIZ];

	if (debug) {
		printf("expand(%x, %d)\nlist = ", list, wh);
		prnames(list);
	}
d130 3
a132 2
	if (wh == 0) {
		register char *cp;
d134 2
a135 5
		for (nl = list; nl != NULL; nl = nl->n_next)
			for (cp = nl->n_name; *cp; cp++)
				*cp = *cp & TRIM;
		return(list);
	}
d139 1
a139 1
	*pathp = '\0';
d144 2
a145 2
	*eargv = 0;
	nleft = NCARGS - 4;
d150 1
a150 1
		expstr(nl->n_name);
d156 1
a156 1
		nl = makenl(NULL);
d165 1
a165 4
	if (debug) {
		printf("expanded list = ");
		prnames(list);
	}
d169 7
a175 3
static void
expstr(s)
	char *s;
d177 13
a189 1
	register char *cp, *cp1;
d191 3
a193 2
	char *tail;
	char buf[BUFSIZ];
d195 1
a195 1
	extern char homedir[];
d197 1
a197 1
	if (s == NULL || *s == '\0')
d200 30
a229 3
	if ((which & E_VARS) && (cp = index(s, '$')) != NULL) {
		*cp++ = '\0';
		if (*cp == '\0') {
d235 6
a240 3
			if ((tail = index(cp, RC)) == NULL) {
				yyerror("unmatched '{'");
				return;
d242 2
a243 2
			*tail++ = savec = '\0';
			if (*cp == '\0') {
d250 1
a250 1
			*tail = '\0';
d252 2
a253 2
		tp = lookup(cp, NULL, 0);
		if (savec != '\0')
d257 3
a259 2
				sprintf(buf, "%s%s%s", s, tp->n_name, tail);
				expstr(buf);
d263 2
a264 2
		sprintf(buf, "%s%s", s, tail);
		expstr(buf);
d267 3
a269 2
	if ((which & ~E_VARS) == 0 || !strcmp(s, "{") || !strcmp(s, "{}")) {
		Cat(s, "");
d275 1
a275 1
		if (*cp == '\0' || *cp == '/') {
d277 1
a277 1
			cp1 = homedir;
d279 1
a279 1
			tilde = cp1 = buf;
d284 7
a290 5
			*cp1 = '\0';
			if (pw == NULL || strcmp(pw->pw_name, buf+1) != 0) {
				if ((pw = getpwnam(buf+1)) == NULL) {
					strcat(buf, ": unknown user name");
					yyerror(buf+1);
d294 1
a294 1
			cp1 = pw->pw_dir;
d297 1
a297 1
		for (cp = path; *cp++ = *cp1++; )
d299 1
a299 1
		tpathp = pathp = cp - 1;
d304 1
a304 1
	*pathp = '\0';
d307 1
a307 1
			Cat(path, s);
d309 1
a309 1
			Cat(tilde, s);
d317 1
a317 1
		Cat(s, "");		/* "nonomatch" is set */
d321 1
a321 1
static int
d323 1
a323 1
	const void *a1, *a2;
d326 1
a326 1
	return (strcmp(*(char **)a1, *(char **)a2));
d333 2
a334 3
static void
expsh(s)
	char *s;
d336 2
a337 2
	register char *cp;
	register char *spathp, *oldcp;
d343 1
a343 1
		if (*cp == '\0') {
d346 1
a346 1
					Cat(path, "");
d348 1
a348 1
					Cat(tilde, tpathp);
d352 1
d360 1
a360 1
	*pathp = '\0';
d362 1
a362 1
		execbrc(cp, NULL);
d365 1
a365 1
	matchdir(cp);
d368 1
a368 1
	*pathp = '\0';
d371 1
a371 2
static void
matchdir(pattern)
d375 1
a375 1
	register struct direct *dp;
d386 1
a386 1
	if (!ISDIR(stb.st_mode)) {
d393 1
a393 1
				Cat(path, dp->d_name);
d395 3
a397 3
				strcpy(pathp, dp->d_name);
				Cat(tilde, tpathp);
				*pathp = '\0';
d406 2
a407 2
	strcat(path, ": ");
	strcat(path, strerror(errno));
d411 2
a412 3
static int
execbrc(p, s)
	char *p, *s;
d414 2
a415 2
	char restbuf[BUFSIZ + 2];
	register char *pe, *pm, *pl;
d417 2
a418 1
	char *lm, savec, *spathp;
d421 2
a422 1
		continue;
d438 1
a438 1
				continue;
d442 4
d453 2
a454 1
		switch (*pm & (QUOTE|TRIM)) {
d473 2
a474 2
			strcpy(lm, pl);
			strcat(restbuf, pe + 1);
d481 1
a481 1
			} else if (amatch(s, restbuf))
d489 1
a489 1
				continue;
d493 4
d501 1
a501 2
static int
match(s, p)
d518 3
a520 3
static int
amatch(s, p)
	register char *s, *p;
d530 1
a530 1
		scc = *s++ & TRIM;
d534 1
a534 1
			return (execbrc(p - 1, s - 1));
d545 1
d547 1
a547 1
					if (lc <= scc && scc <= *p++)
d571 2
a572 2
		case '\0':
			return (scc == '\0');
d575 1
a575 1
			if ((c & TRIM) != scc)
d580 1
a580 1
			if (scc == '\0')
d593 2
a594 2
			if (stat(path, &stb) == 0 && ISDIR(stb.st_mode))
				if (*p == '\0') {
d596 2
a597 1
						Cat(path, "");
d599 2
a600 1
						Cat(tilde, tpathp);
d604 1
a604 46
			*pathp = '\0';
			return (0);
		}
	}
}

static int
smatch(s, p)
	register char *s, *p;
{
	register int scc;
	int ok, lc;
	int c, cc;

	for (;;) {
		scc = *s++ & TRIM;
		switch (c = *p++) {

		case '[':
			ok = 0;
			lc = 077777;
			while (cc = *p++) {
				if (cc == ']') {
					if (ok)
						break;
					return (0);
				}
				if (cc == '-') {
					if (lc <= scc && scc <= *p++)
						ok++;
				} else
					if (scc == (lc = cc))
						ok++;
			}
			if (cc == 0) {
				yyerror("Missing ']'");
				return (0);
			}
			continue;

		case '*':
			if (!*p)
				return (1);
			for (s--; *s; s++)
				if (smatch(s, p))
					return (1);
a605 90

		case '\0':
			return (scc == '\0');

		default:
			if ((c & TRIM) != scc)
				return (0);
			continue;

		case '?':
			if (scc == 0)
				return (0);
			continue;

		}
	}
}

static void
Cat(s1, s2)
	register char *s1, *s2;
{
	int len = strlen(s1) + strlen(s2) + 1;
	register char *s;

	nleft -= len;
	if (nleft <= 0 || ++eargc >= GAVSIZ)
		yyerror("Arguments too long");
	eargv[eargc] = 0;
	eargv[eargc - 1] = s = malloc(len);
	if (s == NULL)
		fatal("ran out of memory\n");
	while (*s++ = *s1++ & TRIM)
		;
	s--;
	while (*s++ = *s2++ & TRIM)
		;
}

static void
addpath(c)
	int c;
{

	if (pathp >= lastpathp)
		yyerror("Pathname too long");
	else {
		*pathp++ = c & TRIM;
		*pathp = '\0';
	}
}

/*
 * Expand file names beginning with `~' into the
 * user's home directory path name. Return a pointer in buf to the
 * part corresponding to `file'.
 */
char *
exptilde(buf, file)
	char buf[];
	register char *file;
{
	register char *s1, *s2, *s3;
	extern char homedir[];

	if (*file != '~') {
		strcpy(buf, file);
		return(buf);
	}
	if (*++file == '\0') {
		s2 = homedir;
		s3 = NULL;
	} else if (*file == '/') {
		s2 = homedir;
		s3 = file;
	} else {
		s3 = file;
		while (*s3 && *s3 != '/')
			s3++;
		if (*s3 == '/')
			*s3 = '\0';
		else
			s3 = NULL;
		if (pw == NULL || strcmp(pw->pw_name, file) != 0) {
			if ((pw = getpwnam(file)) == NULL) {
				error("%s: unknown user name\n", file);
				if (s3 != NULL)
					*s3 = '/';
				return(NULL);
			}
a606 11
		if (s3 != NULL)
			*s3 = '/';
		s2 = pw->pw_dir;
	}
	for (s1 = buf; *s1++ = *s2++; )
		;
	s2 = --s1;
	if (s3 != NULL) {
		s2++;
		while (*s1++ = *s3++)
			;
a607 1
	return(s2);
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@
