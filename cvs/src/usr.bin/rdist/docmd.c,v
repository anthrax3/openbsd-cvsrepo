head	1.32;
access;
symbols
	OPENBSD_6_0:1.32.0.8
	OPENBSD_6_0_BASE:1.32
	OPENBSD_5_9:1.32.0.4
	OPENBSD_5_9_BASE:1.32
	OPENBSD_5_8:1.32.0.6
	OPENBSD_5_8_BASE:1.32
	OPENBSD_5_7:1.32.0.2
	OPENBSD_5_7_BASE:1.32
	OPENBSD_5_6:1.31.0.4
	OPENBSD_5_6_BASE:1.31
	OPENBSD_5_5:1.25.0.8
	OPENBSD_5_5_BASE:1.25
	OPENBSD_5_4:1.25.0.4
	OPENBSD_5_4_BASE:1.25
	OPENBSD_5_3:1.25.0.2
	OPENBSD_5_3_BASE:1.25
	OPENBSD_5_2:1.24.0.6
	OPENBSD_5_2_BASE:1.24
	OPENBSD_5_1_BASE:1.24
	OPENBSD_5_1:1.24.0.4
	OPENBSD_5_0:1.24.0.2
	OPENBSD_5_0_BASE:1.24
	OPENBSD_4_9:1.21.0.6
	OPENBSD_4_9_BASE:1.21
	OPENBSD_4_8:1.21.0.4
	OPENBSD_4_8_BASE:1.21
	OPENBSD_4_7:1.21.0.2
	OPENBSD_4_7_BASE:1.21
	OPENBSD_4_6:1.20.0.6
	OPENBSD_4_6_BASE:1.20
	OPENBSD_4_5:1.20.0.2
	OPENBSD_4_5_BASE:1.20
	OPENBSD_4_4:1.19.0.8
	OPENBSD_4_4_BASE:1.19
	OPENBSD_4_3:1.19.0.6
	OPENBSD_4_3_BASE:1.19
	OPENBSD_4_2:1.19.0.4
	OPENBSD_4_2_BASE:1.19
	OPENBSD_4_1:1.19.0.2
	OPENBSD_4_1_BASE:1.19
	OPENBSD_4_0:1.18.0.4
	OPENBSD_4_0_BASE:1.18
	OPENBSD_3_9:1.18.0.2
	OPENBSD_3_9_BASE:1.18
	OPENBSD_3_8:1.17.0.10
	OPENBSD_3_8_BASE:1.17
	OPENBSD_3_7:1.17.0.8
	OPENBSD_3_7_BASE:1.17
	OPENBSD_3_6:1.17.0.6
	OPENBSD_3_6_BASE:1.17
	OPENBSD_3_5:1.17.0.4
	OPENBSD_3_5_BASE:1.17
	OPENBSD_3_4:1.17.0.2
	OPENBSD_3_4_BASE:1.17
	OPENBSD_3_3:1.11.0.4
	OPENBSD_3_3_BASE:1.11
	OPENBSD_3_2:1.11.0.2
	OPENBSD_3_2_BASE:1.11
	OPENBSD_3_1:1.10.0.2
	OPENBSD_3_1_BASE:1.10
	OPENBSD_3_0:1.9.0.2
	OPENBSD_3_0_BASE:1.9
	OPENBSD_2_9_BASE:1.8
	OPENBSD_2_9:1.8.0.10
	OPENBSD_2_8:1.8.0.8
	OPENBSD_2_8_BASE:1.8
	OPENBSD_2_7:1.8.0.6
	OPENBSD_2_7_BASE:1.8
	OPENBSD_2_6:1.8.0.4
	OPENBSD_2_6_BASE:1.8
	OPENBSD_2_5:1.8.0.2
	OPENBSD_2_5_BASE:1.8
	OPENBSD_2_4:1.7.0.2
	OPENBSD_2_4_BASE:1.7
	OPENBSD_2_3:1.6.0.4
	OPENBSD_2_3_BASE:1.6
	OPENBSD_2_2:1.6.0.2
	OPENBSD_2_2_BASE:1.6
	OPENBSD_2_1:1.5.0.2
	OPENBSD_2_1_BASE:1.5
	OPENBSD_2_0:1.4.0.2
	OPENBSD_2_0_BASE:1.4
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.32
date	2015.01.20.09.00.16;	author guenther;	state Exp;
branches;
next	1.31;
commitid	0Y0sKBv6c3xIKoav;

1.31
date	2014.07.12.03.48.04;	author guenther;	state Exp;
branches;
next	1.30;
commitid	p9pOV7jMl4hhcolh;

1.30
date	2014.07.12.03.02.27;	author guenther;	state Exp;
branches;
next	1.29;
commitid	k3YJzgYkWouFBDB9;

1.29
date	2014.07.05.07.22.18;	author guenther;	state Exp;
branches;
next	1.28;
commitid	yx9CbZuQ0BTvpYrS;

1.28
date	2014.07.05.06.45.00;	author guenther;	state Exp;
branches;
next	1.27;
commitid	zoLIfEXn2KDMNucz;

1.27
date	2014.07.05.06.18.58;	author guenther;	state Exp;
branches;
next	1.26;
commitid	hGNsy3LdPkedy89e;

1.26
date	2014.07.05.05.05.51;	author guenther;	state Exp;
branches;
next	1.25;
commitid	U6Y6NKOm7JX1MOTg;

1.25
date	2012.11.12.01.14.41;	author guenther;	state Exp;
branches;
next	1.24;

1.24
date	2011.04.21.02.44.15;	author krw;	state Exp;
branches;
next	1.23;

1.23
date	2011.04.18.22.18.30;	author krw;	state Exp;
branches;
next	1.22;

1.22
date	2011.04.10.15.47.28;	author krw;	state Exp;
branches;
next	1.21;

1.21
date	2009.10.27.23.59.42;	author deraadt;	state Exp;
branches;
next	1.20;

1.20
date	2008.08.10.13.39.09;	author sobrado;	state Exp;
branches;
next	1.19;

1.19
date	2006.12.11.20.50.54;	author deraadt;	state Exp;
branches;
next	1.18;

1.18
date	2006.02.12.15.51.36;	author moritz;	state Exp;
branches;
next	1.17;

1.17
date	2003.06.03.02.56.14;	author millert;	state Exp;
branches;
next	1.16;

1.16
date	2003.05.14.01.34.35;	author millert;	state Exp;
branches;
next	1.15;

1.15
date	2003.05.06.22.13.22;	author millert;	state Exp;
branches;
next	1.14;

1.14
date	2003.05.06.22.10.11;	author millert;	state Exp;
branches;
next	1.13;

1.13
date	2003.04.19.17.22.29;	author millert;	state Exp;
branches;
next	1.12;

1.12
date	2003.04.05.20.31.58;	author deraadt;	state Exp;
branches;
next	1.11;

1.11
date	2002.06.12.06.07.16;	author mpech;	state Exp;
branches;
next	1.10;

1.10
date	2001.11.19.19.02.15;	author mpech;	state Exp;
branches;
next	1.9;

1.9
date	2001.06.23.23.08.16;	author millert;	state Exp;
branches;
next	1.8;

1.8
date	99.02.04.23.18.57;	author millert;	state Exp;
branches;
next	1.7;

1.7
date	98.06.26.21.21.09;	author millert;	state Exp;
branches;
next	1.6;

1.6
date	97.07.22.06.59.38;	author millert;	state Exp;
branches;
next	1.5;

1.5
date	97.02.12.19.48.24;	author dm;	state Exp;
branches;
next	1.4;

1.4
date	96.06.26.05.38.12;	author deraadt;	state Exp;
branches;
next	1.3;

1.3
date	96.03.05.03.16.03;	author dm;	state Exp;
branches;
next	1.2;

1.2
date	96.02.03.12.12.22;	author dm;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.45.58;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.45.58;	author deraadt;	state Exp;
branches;
next	;


desc
@@


1.32
log
@Split out from rdist/defs.h the client-only and server-only bits into
 rdist/client.h and rdistd/server.h
Only put #includes in .h files that are necessary for the .h to be used;
 all other #includes go in the .c files
Move all extern variable declarations to the .h files, renaming local
 variables to avoid shadowing
Replace me_type member of mntent_t with an "is NFS?" flag bit
@
text
@/*	$OpenBSD: docmd.c,v 1.31 2014/07/12 03:48:04 guenther Exp $	*/

/*
 * Copyright (c) 1983 Regents of the University of California.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */

#include <ctype.h>
#include <dirent.h>
#include <errno.h>
#include <fcntl.h>
#include <paths.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>

#include "client.h"
#include "y.tab.h"

/*
 * Functions for rdist that do command (cmd) related activities.
 */

struct subcmd	       *subcmds;		/* list of sub-commands for 
						   current cmd */
struct namelist	       *filelist;		/* list of source files */
time_t			lastmod;		/* Last modify time */

static void closeconn(void);
static void notify(char *, struct namelist *, time_t);
static void checkcmd(struct cmd *);
static void markfailed(struct cmd *, struct cmd *);
static int remotecmd(char *, char *, char *, char *);
static int makeconn(char *);
static void doarrow(struct cmd *, char **);
static void rcmptime(struct stat *, struct subcmd *, char **);
static void cmptime(char *, struct subcmd *, char **);
static void dodcolon(struct cmd *, char **);
static void docmdhost(struct cmd *, char **);
static void docmd(struct cmd *, int, char **);

/*
 * Signal end of connection.
 */
static void
closeconn(void)
{
	debugmsg(DM_CALL, "closeconn() called\n");

	if (rem_w >= 0) {
		/* We don't care if the connection is still good or not */
		signal(SIGPIPE, SIG_IGN);	

		(void) sendcmd(C_FERRMSG, NULL);
		(void) close(rem_w);
		(void) close(rem_r); /* This can't hurt */
		rem_w = -1;
		rem_r = -1;
	}
}

/*
 * Notify the list of people the changes that were made.
 * rhost == NULL if we are mailing a list of changes compared to at time
 * stamp file.
 */
static void
notify(char *rhost, struct namelist *to, time_t lmod)
{
	int fd;
	ssize_t len;
	FILE *pf;
	struct stat stb;
	static char buf[BUFSIZ];
	char *file, *user;

	if (IS_ON(options, DO_VERIFY) || to == NULL)
		return;

	if ((file = getnotifyfile()) == NULL)
		return;

	if (!IS_ON(options, DO_QUIET)) {
		message(MT_INFO, "notify %s%s %s", 
			(rhost) ? "@@" : "",
			(rhost) ? rhost : "", getnlstr(to));
	}

	if (nflag)
		return;

	debugmsg(DM_MISC, "notify() temp file = '%s'", file);

	if ((fd = open(file, O_RDONLY)) < 0) {
		error("%s: open for reading failed: %s", file, SYSERR);
		return;
	}
	if (fstat(fd, &stb) < 0) {
		error("%s: fstat failed: %s", file, SYSERR);
		(void) close(fd);
		return;
	}
	if (stb.st_size == 0) {
		(void) close(fd);
		return;
	}
	/*
	 * Create a pipe to mailing program.
	 * Set IFS to avoid possible security problem with users
	 * setting "IFS=/".
	 */
	(void) snprintf(buf, sizeof(buf), "IFS=\" \t\"; export IFS; %s -oi -t", 
		       _PATH_SENDMAIL);
	pf = popen(buf, "w");
	if (pf == NULL) {
		error("notify: \"%s\" failed\n", _PATH_SENDMAIL);
		(void) unlink(file);
		(void) close(fd);
		return;
	}
	/*
	 * Output the proper header information.
	 */
	(void) fprintf(pf, "Auto-Submitted: auto-generated\n");
	(void) fprintf(pf, "From: rdist (Remote distribution program)\n");
	(void) fprintf(pf, "To:");
	if (!any('@@', to->n_name) && rhost != NULL)
		(void) fprintf(pf, " %s@@%s", to->n_name, rhost);
	else
		(void) fprintf(pf, " %s", to->n_name);
	to = to->n_next;
	while (to != NULL) {
		if (!any('@@', to->n_name) && rhost != NULL)
			(void) fprintf(pf, ", %s@@%s", to->n_name, rhost);
		else
			(void) fprintf(pf, ", %s", to->n_name);
		to = to->n_next;
	}
	(void) putc('\n', pf);

	if ((user = getlogin()) == NULL)
		user = locuser;

	if (rhost != NULL)
		(void) fprintf(pf, 
			 "Subject: files updated by %s from %s to %s\n",
			 locuser, host, rhost);
	else
		(void) fprintf(pf, "Subject: files updated after %s\n", 
			       ctime(&lmod));
	(void) putc('\n', pf);
	(void) putc('\n', pf);
	(void) fprintf(pf, "Options: %s\n\n", getondistoptlist(options));

	while ((len = read(fd, buf, sizeof(buf))) > 0)
		(void) fwrite(buf, 1, len, pf);

	(void) pclose(pf);
	(void) close(fd);
	(void) unlink(file);
}

/* 
 * XXX Hack for NFS.  If a hostname from the distfile
 * ends with a '+', then the normal restriction of
 * skipping files that are on an NFS filesystem is
 * bypassed.  We always strip '+' to be consistent.
 */
static void
checkcmd(struct cmd *cmd)
{
	int l;

	if (!cmd || !(cmd->c_name)) {
		debugmsg(DM_MISC, "checkcmd() NULL cmd parameter");
		return;
	}

	l = strlen(cmd->c_name);
	if (l <= 0)
		return;
	if (cmd->c_name[l-1] == '+') {
		cmd->c_flags |= CMD_NOCHKNFS;
		cmd->c_name[l-1] = CNULL;
	}
}

/*
 * Mark all other entries for this command (cmd)
 * as assigned.
 */
void
markassigned(struct cmd *cmd, struct cmd *cmdlist)
{
	struct cmd *pcmd;
	
	for (pcmd = cmdlist; pcmd; pcmd = pcmd->c_next) {
		checkcmd(pcmd);
		if (pcmd->c_type == cmd->c_type &&
		    strcmp(pcmd->c_name, cmd->c_name)==0)
			pcmd->c_flags |= CMD_ASSIGNED;
	}
}

/*
 * Mark the command "cmd" as failed for all commands in list cmdlist.
 */
static void
markfailed(struct cmd *cmd, struct cmd *cmdlist)
{
	struct cmd *pc;

	if (!cmd) {
		debugmsg(DM_MISC, "markfailed() NULL cmd parameter");
		return;
	}

	checkcmd(cmd);
	cmd->c_flags |= CMD_CONNFAILED;
	for (pc = cmdlist; pc; pc = pc->c_next) {
		checkcmd(pc);
		if (pc->c_type == cmd->c_type &&
		    strcmp(pc->c_name, cmd->c_name)==0)
			pc->c_flags |= CMD_CONNFAILED;
	}
}

static int
remotecmd(char *rhost, char *luser, char *ruser, char *cmd)
{
	int desc;

	debugmsg(DM_MISC, "local user = %s remote user = %s\n", luser, ruser);
	debugmsg(DM_MISC, "Remote command = '%s'\n", cmd);

	(void) fflush(stdout);
	(void) fflush(stderr);
	(void) signal(SIGALRM, sighandler);
	(void) alarm(RTIMEOUT);

	debugmsg(DM_MISC, "Remote shell command = '%s'\n",
	    path_remsh ? path_remsh : "default");
	(void) signal(SIGPIPE, SIG_IGN);
	desc = rcmdsh(&rhost, -1, luser, ruser, cmd, path_remsh);
	if (desc > 0)
		(void) signal(SIGPIPE, sighandler);

	(void) alarm(0);

	return(desc);
}

/*
 * Create a connection to the rdist server on the machine rhost.
 * Return 0 if the connection fails or 1 if it succeeds.
 */
static int
makeconn(char *rhost)
{
	char *ruser, *cp;
	static char *cur_host = NULL;
	char tuser[BUFSIZ], buf[BUFSIZ];
	u_char respbuff[BUFSIZ];
	int n;

	debugmsg(DM_CALL, "makeconn(%s)", rhost);

	/*
	 * See if we're already connected to this host
	 */
	if (cur_host != NULL && rem_w >= 0) {
		if (strcmp(cur_host, rhost) == 0)
			return(1);
		closeconn();
	}

	/*
	 * Determine remote user and current host names
	 */
	cur_host = rhost;
	cp = strchr(rhost, '@@');

	if (cp != NULL) {
		char c = *cp;

		*cp = CNULL;
		(void) strlcpy((char *)tuser, rhost, sizeof(tuser));
		*cp = c;
		rhost = cp + 1;
		ruser = tuser;
		if (*ruser == CNULL)
			ruser = locuser;
		else if (!okname(ruser))
			return(0);
	} else
		ruser = locuser;

	if (!IS_ON(options, DO_QUIET))
		message(MT_VERBOSE, "updating host %s", rhost);

	(void) snprintf(buf, sizeof(buf), "%.*s -S",
			(int)(sizeof(buf)-5), path_rdistd);
		
	if ((rem_r = rem_w = remotecmd(rhost, locuser, ruser, buf)) < 0)
		return(0);

	/*
	 * First thing received should be S_VERSION
	 */
	respbuff[0] = '\0';
	n = remline(respbuff, sizeof(respbuff), TRUE);
	if (n <= 0 || respbuff[0] != S_VERSION) {
		if (n > 0)
		    error("Unexpected input from server: \"%s\".", respbuff);
		else
		    error("No input from server.");
		closeconn();
		return(0);
	}

	/*
	 * For future compatibility we check to see if the server
	 * sent it's version number to us.  If it did, we use it,
	 * otherwise, we send our version number to the server and let
	 * it decide if it can handle our protocol version.
	 */
	if (respbuff[1] == CNULL) {
		/*
		 * The server wants us to send it our version number
		 */
		(void) sendcmd(S_VERSION, "%d", VERSION);
		if (response() < 0) 
			return(0);
	} else {
		/*
		 * The server sent it's version number to us
		 */
		int proto_version = atoi(&respbuff[1]);
		if (proto_version != VERSION) {
			fatalerr(
		  "Server version (%d) is not the same as local version (%d).",
			      proto_version, VERSION);
			return(0);
		}
	}

	/*
	 * Send config commands
	 */
	if (host[0]) {
		(void) sendcmd(C_SETCONFIG, "%c%s", SC_HOSTNAME, host);
		if (response() < 0)
			return(0);
	}
	if (min_freespace) {
		(void) sendcmd(C_SETCONFIG, "%c%lld", SC_FREESPACE, 
			       min_freespace);
		if (response() < 0)
			return(0);
	}
	if (min_freefiles) {
		(void) sendcmd(C_SETCONFIG, "%c%lld", SC_FREEFILES, 
			       min_freefiles);
		if (response() < 0)
			return(0);
	}
	if (remotemsglist) {
		(void) sendcmd(C_SETCONFIG, "%c%s", SC_LOGGING, remotemsglist);
		if (response() < 0)
			return(0);
	}
	if (strcmp(defowner, "bin") != 0) {
		(void) sendcmd(C_SETCONFIG, "%c%s", SC_DEFOWNER, defowner);
		if (response() < 0)
			return(0);
	}
	if (strcmp(defgroup, "bin") != 0) {
		(void) sendcmd(C_SETCONFIG, "%c%s", SC_DEFGROUP, defgroup);
		if (response() < 0)
			return(0);
	}

	return(1);
}

/*
 * Process commands for sending files to other machines.
 */
static void
doarrow(struct cmd *cmd, char **filev)
{
	struct namelist *f;
	struct subcmd *sc;
	char **cpp;
	int n, ddir, destdir;
	volatile opt_t opts = options;
	struct namelist *files;
	struct subcmd *sbcmds;
	char *rhost;
	volatile int didupdate = 0;

        if (setjmp_ok) {
		error("reentrant call to doarrow");
		abort();
	}

	if (!cmd) {
		debugmsg(DM_MISC, "doarrow() NULL cmd parameter");
		return;
	}

	files = cmd->c_files;
	sbcmds = cmd->c_cmds;
	rhost = cmd->c_name;

	if (files == NULL) {
		error("No files to be updated on %s for target \"%s\"", 
		      rhost, cmd->c_label);
		return;
	}

	debugmsg(DM_CALL, "doarrow(%p, %s, %p) start", 
		 files, A(rhost), sbcmds);

	if (nflag)
		(void) printf("updating host %s\n", rhost);
	else {
		if (cmd->c_flags & CMD_CONNFAILED) {
			debugmsg(DM_MISC,
				 "makeconn %s failed before; skipping\n",
				 rhost);
			return;
		}

		if (setjmp(finish_jmpbuf)) {
			setjmp_ok = FALSE;
			debugmsg(DM_MISC, "setjmp to finish_jmpbuf");
			markfailed(cmd, cmds);
			return;
		}
		setjmp_ok = TRUE;

		if (!makeconn(rhost)) {
			setjmp_ok = FALSE;
			markfailed(cmd, cmds);
			return;
		}
	}

	subcmds = sbcmds;
	filelist = files;

	n = 0;
	for (sc = sbcmds; sc != NULL; sc = sc->sc_next) {
		if (sc->sc_type != INSTALL)
			continue;
		n++;
	/*
	 * destination is a directory if one of the following is true:
	 * a) more than one name specified on left side of -> directive
	 * b) basename of destination in "install" directive is "."
	 *    (e.g. install /tmp/.;)
	 * c) name on left side of -> directive is a directory on local system.
 	 *
 	 * We need 2 destdir flags (destdir and ddir) because single directory
 	 * source is handled differently.  In this case, ddir is 0 (which
 	 * tells install() not to send DIRTARGET directive to remote rdistd)
 	 * and destdir is 1 (which tells remfilename() how to build the FILE
 	 * variables correctly).  In every other case, destdir and ddir will
 	 * have the same value.
	 */
  	ddir = files->n_next != NULL;	/* destination is a directory */
	if (!ddir) {
		struct stat s;
 		int isadir = 0;

		if (lstat(files->n_name, &s) == 0)
 			isadir = S_ISDIR(s.st_mode);
 		if (!isadir && sc->sc_name && *sc->sc_name)
 			ddir = !strcmp(xbasename(sc->sc_name),".");
 		destdir = isadir | ddir;
 	} else
 		destdir = ddir;

	debugmsg(DM_MISC,
		 "Debug files->n_next= %p, destdir=%d, ddir=%d",
		 files->n_next, destdir, ddir);
 
	if (!sc->sc_name || !*sc->sc_name) {
		destdir = 0;
		ddir = 0;
	}

	debugmsg(DM_MISC,
		 "Debug sc->sc_name=%p, destdir=%d, ddir=%d",
		 sc->sc_name, destdir, ddir);

	for (f = files; f != NULL; f = f->n_next) {
		if (filev) {
			for (cpp = filev; *cpp; cpp++)
				if (strcmp(f->n_name, *cpp) == 0)
					goto found;
			continue;
		}
	found:
		if (install(f->n_name, sc->sc_name, ddir, destdir,
				sc->sc_options) > 0)
			++didupdate;
		opts = sc->sc_options;
	}

	} /* end loop for each INSTALL command */

	/* if no INSTALL commands present, do default install */
	if (!n) {
		for (f = files; f != NULL; f = f->n_next) {
			if (filev) {
				for (cpp = filev; *cpp; cpp++)
					if (strcmp(f->n_name, *cpp) == 0)
						goto found2;
				continue;
			}
		found2:
			/* ddir & destdir set to zero for default install */
			if (install(f->n_name, NULL, 0, 0, options) > 0)
				++didupdate;
		}
	}

	/*
	 * Run any commands for the entire cmd
	 */
	if (didupdate > 0) {
		runcmdspecial(cmd, opts);
		didupdate = 0;
	}

	if (!nflag)
		(void) signal(SIGPIPE, cleanup);

	for (sc = sbcmds; sc != NULL; sc = sc->sc_next)
		if (sc->sc_type == NOTIFY)
			notify(rhost, sc->sc_args, (time_t) 0);

	if (!nflag) {
		struct linkbuf *nextl, *l;

		for (l = ihead; l != NULL; freelinkinfo(l), l = nextl) {
			nextl = l->nextp;
			if (contimedout || IS_ON(opts, DO_IGNLNKS) || 
			    l->count == 0)
				continue;
			message(MT_WARNING, "%s: Warning: %d %s link%s",
				l->pathname, abs(l->count),	
				(l->count > 0) ? "missing" : "extra",
				(l->count == 1) ? "" : "s");
		}
		ihead = NULL;
	}
	setjmp_ok = FALSE;
}

int
okname(char *name)
{
	char *cp = name;
	int c, isbad;

	for (isbad = FALSE; *cp && !isbad; ++cp) {
		c = *cp;
		if (c & 0200)
			isbad = TRUE;
		if (!isalpha(c) && !isdigit(c) && c != '_' && c != '-')
			isbad = TRUE;
	}

	if (isbad) {
		error("Invalid user name \"%s\"\n", name);
		return(0);
	}
	return(1);
}

static void
rcmptime(struct stat *st, struct subcmd *sbcmds, char **env)
{
	DIR *d;
	struct dirent *dp;
	char *cp;
	char *optarget;
	int len;

	debugmsg(DM_CALL, "rcmptime(%p) start", st);

	if ((d = opendir((char *) target)) == NULL) {
		error("%s: open directory failed: %s", target, SYSERR);
		return;
	}
	optarget = ptarget;
	len = ptarget - target;
	while ((dp = readdir(d)) != NULL) {
		if (!strcmp(dp->d_name, ".") || !strcmp(dp->d_name, ".."))
			continue;
		if (len + 1 + (int)strlen(dp->d_name) >= BUFSIZ - 1) {
			error("%s/%s: Name too long\n", target, dp->d_name);
			continue;
		}
		ptarget = optarget;
		*ptarget++ = '/';
		cp = dp->d_name;
		while ((*ptarget++ = *cp++) != '\0')
			;
		ptarget--;
		cmptime(target, sbcmds, env);
	}
	(void) closedir((DIR *) d);
	ptarget = optarget;
	*ptarget = '\0';
}

/*
 * Compare the mtime of file to the list of time stamps.
 */
static void
cmptime(char *name, struct subcmd *sbcmds, char **env)
{
	struct subcmd *sc;
	struct stat stb;

	debugmsg(DM_CALL, "cmptime(%s)", name);

	if (except(name))
		return;

	if (nflag) {
		(void) printf("comparing dates: %s\n", name);
		return;
	}

	/*
	 * first time cmptime() is called?
	 */
	if (ptarget == NULL) {
		if (exptilde(target, name, sizeof(target)) == NULL)
			return;
		ptarget = name = target;
		while (*ptarget)
			ptarget++;
	}
	if (access(name, R_OK) < 0 || stat(name, &stb) < 0) {
		error("%s: cannot access file: %s", name, SYSERR);
		return;
	}

	if (S_ISDIR(stb.st_mode)) {
		rcmptime(&stb, sbcmds, env);
		return;
	} else if (!S_ISREG(stb.st_mode)) {
		error("%s: not a plain file", name);
		return;
	}

	if (stb.st_mtime > lastmod) {
		message(MT_INFO, "%s: file is newer", name);
		for (sc = sbcmds; sc != NULL; sc = sc->sc_next) {
			char buf[BUFSIZ];
			if (sc->sc_type != SPECIAL)
				continue;
			if (sc->sc_args != NULL && !inlist(sc->sc_args, name))
				continue;
			(void) snprintf(buf, sizeof(buf), "%s=%s;%s", 
				        E_LOCFILE, name, sc->sc_name);
			message(MT_CHANGE, "special \"%s\"", buf);
			if (*env) {
				size_t len = strlen(*env) + strlen(name) + 2;
				*env = xrealloc(*env, len);
				(void) strlcat(*env, name, len);
				(void) strlcat(*env, ":", len);
			}
			if (IS_ON(options, DO_VERIFY))
				continue;

			runcommand(buf);
		}
	}
}

/*
 * Process commands for comparing files to time stamp files.
 */
static void
dodcolon(struct cmd *cmd, char **filev)
{
	struct subcmd *sc;
	struct namelist *f;
	char *cp, **cpp;
	struct stat stb;
	struct namelist *files = cmd->c_files;
	struct subcmd *sbcmds = cmd->c_cmds;
	char *env, *stamp = cmd->c_name;

	debugmsg(DM_CALL, "dodcolon()");

	if (files == NULL) {
		error("No files to be updated for target \"%s\"", 
		      cmd->c_label);
		return;
	}
	if (stat(stamp, &stb) < 0) {
		error("%s: stat failed: %s", stamp, SYSERR);
		return;
	}

	debugmsg(DM_MISC, "%s: mtime %lld\n", stamp, (long long)stb.st_mtime);

	env = NULL;
	for (sc = sbcmds; sc != NULL; sc = sc->sc_next) {
		if (sc->sc_type == CMDSPECIAL) {
			env = xmalloc(sizeof(E_FILES) + 3);
			(void) snprintf(env, sizeof(E_FILES) + 3,
					"%s='", E_FILES);
			break;
		}
	}

	subcmds = sbcmds;
	filelist = files;

	lastmod = stb.st_mtime;
	if (!nflag && !IS_ON(options, DO_VERIFY))
		/*
		 * Set atime and mtime to current time
		 */
		(void) setfiletime(stamp, (time_t) 0, (time_t) 0);

	for (f = files; f != NULL; f = f->n_next) {
		if (filev) {
			for (cpp = filev; *cpp; cpp++)
				if (strcmp(f->n_name, *cpp) == 0)
					goto found;
			continue;
		}
	found:
		ptarget = NULL;
		cmptime(f->n_name, sbcmds, &env);
	}

	for (sc = sbcmds; sc != NULL; sc = sc->sc_next) {
		if (sc->sc_type == NOTIFY)
			notify(NULL, sc->sc_args, (time_t)lastmod);
		else if (sc->sc_type == CMDSPECIAL && env) {
			size_t len = strlen(env);
			if (env[len - 1] == ':')
				env[--len] = CNULL;
			len += 2 + strlen(sc->sc_name) + 1;
			env = xrealloc(env, len);
			(void) strlcat(env, "';", len);
			(void) strlcat(env, sc->sc_name, len);
			message(MT_CHANGE, "cmdspecial \"%s\"", env);
			if (!nflag && IS_OFF(options, DO_VERIFY))
				runcommand(env);
			(void) free(env);
			env = NULL;	/* so cmdspecial is only called once */
		}
	}
	if (!nflag && !IS_ON(options, DO_VERIFY) && (cp = getnotifyfile()))
		(void) unlink(cp);
}

/*
 * Return TRUE if file is in the exception list.
 */
int
except(char *file)
{
	struct	subcmd *sc;
	struct	namelist *nl;

	debugmsg(DM_CALL, "except(%s)", file);

	for (sc = subcmds; sc != NULL; sc = sc->sc_next) {
		if (sc->sc_type == EXCEPT) {
			for (nl = sc->sc_args; nl != NULL; nl = nl->n_next)
				if (strcmp(file, nl->n_name) == 0)
					return(1);
  			continue;
		}
		if (sc->sc_type == PATTERN) {
			for (nl = sc->sc_args; nl != NULL; nl = nl->n_next) {
				char ebuf[BUFSIZ];
				int ecode = 0;

				/* allocate and compile n_regex as needed */
				if (nl->n_regex == NULL) {
					nl->n_regex = xmalloc(sizeof(regex_t));
					ecode = regcomp(nl->n_regex, nl->n_name,
							REG_NOSUB);
				}
				if (ecode == 0) {
					ecode = regexec(nl->n_regex, file, 0,
					    NULL, 0);
				}
				switch (ecode) {
				case REG_NOMATCH:
					break;
				case 0:
					return(1);	/* match! */
				default:
					regerror(ecode, nl->n_regex, ebuf,
						 sizeof(ebuf));
					error("Regex error \"%s\" for \"%s\".",
					      ebuf, nl->n_name);
					return(0);
				}
			}
		}
	}
	return(0);
}

/*
 * Do a specific command for a specific host
 */
static void
docmdhost(struct cmd *cmd, char **filev)
{
	checkcmd(cmd);

	/*
	 * If we're multi-threaded and we're the parent, spawn a 
	 * new child process.
	 */
	if (do_fork && !amchild) {
		pid_t pid;

		/*
		 * If we're at maxchildren, wait for number of active
		 * children to fall below max number of children.
		 */
		while (activechildren >= maxchildren)
			waitup();

		pid = spawn(cmd, cmds);
		if (pid == 0)
			/* Child */
			amchild = 1;
		else
			/* Parent */
			return;
	}

	/*
	 * Disable NFS checks
	 */
	if (cmd->c_flags & CMD_NOCHKNFS)
		FLAG_OFF(options, DO_CHKNFS);

	if (!nflag) {
		currenthost = (cmd->c_name) ? cmd->c_name : "<unknown>";
		setproctitle("update %s", currenthost);
	}

	switch (cmd->c_type) {
	case ARROW:
		doarrow(cmd, filev);
		break;
	case DCOLON:
		dodcolon(cmd, filev);
		break;
	default:
		fatalerr("illegal command type %d", cmd->c_type);
	}
}

/*
 * Do a specific command (cmd)
 */
static void
docmd(struct cmd *cmd, int argc, char **argv)
{
	struct namelist *f;
	int i;

	if (argc) {
		for (i = 0; i < argc; i++) {
			if (cmd->c_label != NULL &&
			    strcmp(cmd->c_label, argv[i]) == 0) {
				docmdhost(cmd, NULL);
				return;
			}
			for (f = cmd->c_files; f != NULL; f = f->n_next)
				if (strcmp(f->n_name, argv[i]) == 0) {
					docmdhost(cmd, &argv[i]);
					return;
				}
		}
	} else
		docmdhost(cmd, NULL);
}

/*
 *
 * Multiple hosts are updated at once via a "ring" of at most
 * maxchildren rdist processes.  The parent rdist fork()'s a child
 * for a given host.  That child will update the given target files
 * and then continue scanning through the remaining targets looking
 * for more work for a given host.  Meanwhile, the parent gets the
 * next target command and makes sure that it hasn't encountered
 * that host yet since the children are responsible for everything
 * for that host.  If no children have done this host, then check
 * to see if the number of active proc's is less than maxchildren.
 * If so, then spawn a new child for that host.  Otherwise, wait
 * for a child to finish.
 *
 */

/*
 * Do the commands in cmds (initialized by yyparse).
 */
void
docmds(struct namelist *hostlist, int argc, char **argv)
{
	struct cmd *c;
	char *cp;
	int i;

	(void) signal(SIGHUP, sighandler);
	(void) signal(SIGINT, sighandler);
	(void) signal(SIGQUIT, sighandler);
	(void) signal(SIGTERM, sighandler);

	if (!nflag)
		setvbuf(stdout, NULL, _IOLBF, 0);

	/*
	 * Print errors for any command line targets we didn't find.
	 * If any errors are found, return to main() which will then exit.
	 */
	for (i = 0; i < argc; i++) {
		int found;

		for (found = FALSE, c = cmds; c != NULL; c = c->c_next) {
			if (c->c_label && argv[i] && 
			    strcmp(c->c_label, argv[i]) == 0) {
				found = TRUE;
				break;
			}
		}
		if (!found)
			error("Label \"%s\" is not defined in the distfile.", 
			      argv[i]);
	}
	if (nerrs)
		return;

	/*
	 * Main command loop.  Loop through all the commands.
	 */
	for (c = cmds; c != NULL; c = c->c_next) {
		checkcmd(c);
		if (do_fork) {
			/*
			 * Let the children take care of their assigned host
			 */
			if (amchild) {
				if (strcmp(c->c_name, currenthost) != 0)
					continue;
			} else if (c->c_flags & CMD_ASSIGNED) {
				/* This cmd has been previously assigned */
				debugmsg(DM_MISC, "prev assigned: %s\n",
					 c->c_name);
				continue;
			}
		}

		if (hostlist) {
			/* Do specific hosts as specified on command line */
			struct namelist *nlptr;

			for (nlptr = hostlist; nlptr; nlptr = nlptr->n_next)
				/*
				 * Try an exact match and then a match
				 * without '@@' (if present).
				 */
				if ((strcmp(c->c_name, nlptr->n_name) == 0) ||
				    ((cp = strchr(c->c_name, '@@')) &&
				     strcmp(++cp, nlptr->n_name) == 0))
					docmd(c, argc, argv);
			continue;
		} else
			/* Do all of the command */
			docmd(c, argc, argv);
	}

	if (do_fork) {
		/*
		 * We're multi-threaded, so do appropriate shutdown
		 * actions based on whether we're the parent or a child.
		 */
		if (amchild) {
			if (!IS_ON(options, DO_QUIET))
				message(MT_VERBOSE, "updating of %s finished", 
					currenthost);
			closeconn();
			cleanup(0);
			exit(nerrs);
		}

		/*
		 * Wait for all remaining active children to finish
		 */
		while (activechildren > 0) {
			debugmsg(DM_MISC, 
				 "Waiting for %d children to finish.\n",
				 activechildren);
			waitup();
		}
	} else if (!nflag) {
		/*
		 * We're single-threaded so close down current connection
		 */
		closeconn();
		cleanup(0);
	}
}
@


1.31
log
@The statdb code has never been complete here
@
text
@d1 1
a1 1
/*	$OpenBSD: docmd.c,v 1.30 2014/07/12 03:02:27 guenther Exp $	*/
d32 1
a32 1
#include <sys/socket.h>
d34 6
a39 1
#include <netdb.h>
d41 1
a41 1
#include "defs.h"
a50 1
extern struct cmd      *cmds;			/* Initialized by yyparse() */
a52 7
extern char 		target[BUFSIZ];
extern char 	       *ptarget;
extern int		activechildren;
extern int		maxchildren;
extern int		amchild;
extern char	       *path_rdistd;

a98 1
	extern char *locuser;
a285 3
	extern char *locuser;
	extern int64_t min_freefiles, min_freespace;
	extern char *remotemsglist;
d362 1
a362 1
		proto_version = atoi(&respbuff[1]);
@


1.30
log
@Yes, we have setproctitle().  Delete that and several unused HAVE_* #defines
@
text
@d1 1
a1 1
/*	$OpenBSD: docmd.c,v 1.29 2014/07/05 07:22:18 guenther Exp $	*/
a964 15

#if	defined(USE_STATDB)
	if (!nflag && (dostatdb || juststatdb)) {
		extern long reccount;
		message(MT_INFO, "Making stat database [%s] ... \n", 
			       gettimestr());
		if (mkstatdb() < 0)
			error("Warning: Make stat database failed.");
		message(MT_INFO,
			      "Stat database created: %d files stored [%s].\n",
			       reccount, gettimestr());
		if (juststatdb)
			return;
	}
#endif	/* USE_STATDB */
@


1.29
log
@Assume POSIX: lchown(), fchown(), fchmod(), fchmodat()
Assume we have rcmdsh()
@
text
@d1 1
a1 1
/*	$OpenBSD: docmd.c,v 1.28 2014/07/05 06:45:00 guenther Exp $	*/
a890 1
#if	defined(SETARGS) || defined(HAVE_SETPROCTITLE)
a891 1
#endif 	/* SETARGS || HAVE_SETPROCTITLE */
@


1.28
log
@Assume POSIX: <dirent.h>, struct dirent
@
text
@d1 1
a1 1
/*	$OpenBSD: docmd.c,v 1.27 2014/07/05 06:18:58 guenther Exp $	*/
a259 3
#if	defined(DIRECT_RCMD)
	static int port = -1;
#endif	/* DIRECT_RCMD */
a268 17
#if	defined(DIRECT_RCMD)
	(void) signal(SIGPIPE, sighandler);

	if (port < 0) {
		struct servent *sp;
		
		if ((sp = getservbyname("shell", "tcp")) == NULL)
				fatalerr("shell/tcp: unknown service");
		port = sp->s_port;
	}

	if (becomeroot() != 0)
		exit(1);
	desc = rcmd(&rhost, port, luser, ruser, cmd, 0);
	if (becomeuser() != 0)
		exit(1);
#else	/* !DIRECT_RCMD */
a274 1
#endif	/* DIRECT_RCMD */
@


1.27
log
@Assume C89: stdargs, const, and setvbuf()
Assume POSIX: O_NONBLOCK and S_IS{DIR,REG,LNK}
@
text
@d1 1
a1 1
/*	$OpenBSD: docmd.c,v 1.26 2014/07/05 05:05:51 guenther Exp $	*/
d32 4
a42 3
#include <sys/socket.h>
#include <netdb.h>

d640 1
a640 1
	DIRENTRY *dp;
@


1.26
log
@Use void* in malloc/realloc/calloc wrappers
@
text
@d1 1
a1 1
/*	$OpenBSD: docmd.c,v 1.25 2012/11/12 01:14:41 guenther Exp $	*/
d986 1
a986 1
		mysetlinebuf(stdout);	/* Make output (mostly) clean */
@


1.25
log
@Fix various format string issues.  Stop assuming time_t is long or smaller.
Enable warnings.

ok krw@@, ian@@
@
text
@d1 1
a1 1
/*	$OpenBSD: docmd.c,v 1.24 2011/04/21 02:44:15 krw Exp $	*/
d727 1
a727 1
				*env = (char *) xrealloc(*env, len);
d770 1
a770 1
			env = (char *) xmalloc(sizeof(E_FILES) + 3);
d846 1
a846 2
					nl->n_regex = (regex_t *)
					    xmalloc(sizeof(regex_t));
@


1.24
log
@Fix more long vs 64bit type mismatches. Now 4GB i386 <-> macppc
transfers work for Richard Toohey.
@
text
@d1 1
a1 1
/*	$OpenBSD: docmd.c,v 1.23 2011/04/18 22:18:30 krw Exp $	*/
d473 1
a473 1
	debugmsg(DM_CALL, "doarrow(%x, %s, %x) start", 
d537 1
a537 1
		 "Debug files->n_next= %d, destdir=%d, ddir=%d",
d546 1
a546 1
		 "Debug sc->sc_name=%x, destdir=%d, ddir=%d",
d644 1
a644 1
	debugmsg(DM_CALL, "rcmptime(%x) start", st);
d765 1
a765 1
	debugmsg(DM_MISC, "%s: mtime %d\n", stamp, stb.st_mtime);
@


1.23
log
@read(2) returns ssize_t. So use a ssize_t to store and test the
return value, not a size_t which does not grok -1.

ok matthew@@
@
text
@d1 1
a1 1
/*	$OpenBSD: docmd.c,v 1.22 2011/04/10 15:47:28 krw Exp $	*/
d407 1
a407 1
		(void) sendcmd(C_SETCONFIG, "%c%d", SC_FREESPACE, 
d413 1
a413 1
		(void) sendcmd(C_SETCONFIG, "%c%d", SC_FREEFILES, 
@


1.22
log
@Apply some tough type-love and give rdist a chance to handle files
larger than 2GB. Diff from Stephan R. Gerber via PR#6586, tweaks
by me.

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: docmd.c,v 1.21 2009/10/27 23:59:42 deraadt Exp $	*/
d97 1
a97 1
	size_t len;
@


1.21
log
@rcsid[] and sccsid[] and copyright[] are essentially unmaintained (and
unmaintainable).  these days, people use source.  these id's do not provide
any benefit, and do hurt the small install media
(the 33,000 line diff is essentially mechanical)
ok with the idea millert, ok dms
@
text
@d1 1
a1 1
/*	$OpenBSD: docmd.c,v 1.20 2008/08/10 13:39:09 sobrado Exp $	*/
d311 1
a311 1
	extern long min_freefiles, min_freespace;
@


1.20
log
@typo.
@
text
@d1 1
a1 1
/*	$OpenBSD: docmd.c,v 1.19 2006/12/11 20:50:54 deraadt Exp $	*/
a33 16
#ifndef lint
#if 0
static char RCSid[] __attribute__((__unused__)) = 
"$From: docmd.c,v 1.8 2001/03/12 18:42:23 kim Exp $";
#else
static char RCSid[] __attribute__((__unused__)) = 
"$OpenBSD: docmd.c,v 1.19 2006/12/11 20:50:54 deraadt Exp $";
#endif

static char sccsid[] __attribute__((__unused__)) =
"@@(#)docmd.c	5.1 (Berkeley) 6/6/85";

static char copyright[] __attribute__((__unused__)) =
"@@(#) Copyright (c) 1983 Regents of the University of California.\n\
 All rights reserved.\n";
#endif /* not lint */
@


1.19
log
@rfc 3834 support: Auto-Submitted: auto-generated on lots of things; from Tamas TEVESZ; ok millert
@
text
@d1 1
a1 1
/*	$OpenBSD: docmd.c,v 1.18 2006/02/12 15:51:36 moritz Exp $	*/
d40 1
a40 1
"$OpenBSD: docmd.c,v 1.18 2006/02/12 15:51:36 moritz Exp $";
d151 1
a151 1
	 * Create a pipe to mailling program.
@


1.18
log
@Fix mail notification for rdist(1) as reported in user/5009. ok otto@@
@
text
@d1 1
a1 1
/*	$OpenBSD: docmd.c,v 1.17 2003/06/03 02:56:14 millert Exp $	*/
d40 1
a40 1
"$OpenBSD: docmd.c,v 1.17 2003/06/03 02:56:14 millert Exp $";
d167 1
@


1.17
log
@Remove the advertising clause in the UCB license which Berkeley
rescinded 22 July 1999.  Proofed by myself and Theo.
@
text
@d1 1
a1 1
/*	$OpenBSD: docmd.c,v 1.16 2003/05/14 01:34:35 millert Exp $	*/
d40 1
a40 1
"$OpenBSD: docmd.c,v 1.16 2003/05/14 01:34:35 millert Exp $";
d197 1
a197 1
	while ((len = read(fd, buf, sizeof(buf))) != (size_t)-1)
@


1.16
log
@ o Sync w/ freerdist 0.92 minus the compress option
 o KNF and ANSIfy the function headers

Sparse file support is currently a no-op since it didn't work.
Proper sparse file support will be added later.
@
text
@d1 1
a1 1
/*	$OpenBSD: docmd.c,v 1.15 2003/05/06 22:13:22 millert Exp $	*/
d15 1
a15 5
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
d40 1
a40 1
"$OpenBSD: docmd.c,v 1.15 2003/05/06 22:13:22 millert Exp $";
@


1.15
log
@Whoops, forgot a return statement in last commit
@
text
@d1 1
a1 1
/*	$OpenBSD: docmd.c,v 1.14 2003/05/06 22:10:11 millert Exp $	*/
d36 2
d40 2
a41 2
static char RCSid[] = 
"$From: docmd.c,v 6.86 1996/01/30 02:29:43 mcooper Exp $";
d43 2
a44 2
static char RCSid[] = 
"$OpenBSD: docmd.c,v 1.14 2003/05/06 22:10:11 millert Exp $";
d47 2
a48 1
static char sccsid[] = "@@(#)docmd.c	5.1 (Berkeley) 6/6/85";
d50 1
a50 1
static char copyright[] =
a58 2
#include "defs.h"
#include "y.tab.h"
d75 12
a86 1
static void cmptime();
d91 2
a92 1
static void closeconn()
d113 2
a114 4
static void notify(rhost, to, lmod)
	char *rhost;
	struct namelist *to;
	time_t lmod;
d116 3
a118 2
	int fd, len;
	FILE *pf, *popen();
d121 2
a122 1
	char *file;
d159 1
a159 1
	(void) snprintf(buf, sizeof buf, "IFS=\" \t\"; export IFS; %s -oi -t", 
d186 4
d192 2
a193 2
			     "Subject: files updated by rdist from %s to %s\n",
			       host, rhost);
d199 1
d201 1
a201 1
	while ((len = read(fd, buf, sizeof(buf))) > 0)
d215 2
a216 2
static void checkcmd(cmd)
	struct cmd *cmd;
d238 2
a239 3
extern void markassigned(cmd, cmdlist)
	struct cmd *cmd;
	struct cmd *cmdlist;
d254 2
a255 3
static void markfailed(cmd, cmdlist)
	struct cmd *cmd;
	struct cmd *cmdlist;
d274 2
a275 4
static int remotecmd(rhost, luser, ruser, cmd)
	char *rhost;
	char *luser, *ruser;
	char *cmd;
d324 2
a325 2
static int makeconn(rhost)
	char *rhost;
d333 1
a333 1
	u_char respbuff[BUFSIZ] = "";
d357 1
a357 1
		(void) strncpy((char *)tuser, rhost, sizeof(tuser)-1);
d371 2
a372 1
	(void) snprintf(buf, sizeof buf, "%.*s -S", sizeof(buf)-5, path_rdistd);
d380 1
d383 4
a386 1
		error("Unexpected input from server: \"%s\".", respbuff);
d442 10
d459 2
a460 3
static void doarrow(cmd, filev)
	struct cmd *cmd;
	char **filev;
d466 1
a469 1
	volatile int opts = options;
a599 1
done:
d604 1
a604 1
		runcmdspecial(cmd, filev, opts);
d634 1
a634 2
okname(name)
	char *name;
d654 2
a655 4
static void rcmptime(st, sbcmds, env)
	struct stat *st;
	struct subcmd *sbcmds;
	char **env;
d671 1
a671 1
	while ((dp = readdir(d))) {
d681 1
a681 1
		while ((*ptarget++ = *cp++))
d694 2
a695 4
static void cmptime(name, sbcmds, env)
	char *name;
	struct subcmd *sbcmds;
	char **env;
a698 1
	int inlist();
d741 2
a742 2
			(void) snprintf(buf, sizeof buf, "%s=%s;%s", 
				       E_LOCFILE, name, sc->sc_name);
d761 2
a762 3
static void dodcolon(cmd, filev)
	struct cmd *cmd;
	char **filev;
d790 2
a791 1
			(void) snprintf(env, sizeof(E_FILES) + 3, "%s='", E_FILES);
d843 2
a844 2
extern int except(file)
	char *file;
d895 2
a896 3
static void docmdhost(cmd, filev)
	struct cmd *cmd;
	char **filev;
d951 2
a952 4
static void docmd(cmd, argc, argv)
	struct cmd *cmd;
	int argc;
	char **argv;
d993 2
a994 4
extern void docmds(hostlist, argc, argv)
	struct namelist *hostlist;
	int argc;
	char **argv;
d1093 1
a1093 1
			cleanup();
d1111 1
a1111 1
		cleanup();
@


1.14
log
@use POSIX regex
@
text
@d1 1
a1 1
/*	$OpenBSD: docmd.c,v 1.13 2003/04/19 17:22:29 millert Exp $	*/
d42 1
a42 1
"$OpenBSD: docmd.c,v 1.13 2003/04/19 17:22:29 millert Exp $";
d863 1
@


1.13
log
@strcpy/strcat/sprintf removal; krw@@ OK
@
text
@d1 1
a1 1
/*	$OpenBSD: docmd.c,v 1.12 2003/04/05 20:31:58 deraadt Exp $	*/
d42 1
a42 1
"$OpenBSD: docmd.c,v 1.12 2003/04/05 20:31:58 deraadt Exp $";
d839 2
a840 1
				char *cp, *re_comp();
d842 19
a860 1
				if ((cp = re_comp(nl->n_name)) != NULL) {
d862 1
a862 2
					      cp, nl->n_name);
					return(0);
a863 2
				if (re_exec(file) > 0)
  					return(1);
@


1.12
log
@strings; ok miod ho krw
@
text
@d1 1
a1 1
/*	$OpenBSD: docmd.c,v 1.11 2002/06/12 06:07:16 mpech Exp $	*/
d42 1
a42 1
"$OpenBSD: docmd.c,v 1.11 2002/06/12 06:07:16 mpech Exp $";
d67 1
a67 1
extern char 		target[];
d693 1
a693 1
		if (exptilde(target, name) == NULL)
d724 4
a727 6
				int len = strlen(*env);
				*env = (char *) xrealloc(*env, len +
							 strlen(name) + 2);
				*env[len] = CNULL;
				(void) strcat(*env, name);
				(void) strcat(*env, ":");
d801 7
a807 10
			char *p;
			int len = strlen(env);

			env = xrealloc(env, 
				       len + strlen(sc->sc_name) + 2);
			env[len] = CNULL;
			if (*(p = &env[len - 1]) == ':')
				*p = CNULL;
			(void) strcat(env, "';");
			(void) strcat(env, sc->sc_name);
@


1.11
log
@a real pid_t cleanup.

espie@@ ok for make/,
deraadt@@ one extra eye,
millert@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: docmd.c,v 1.10 2001/11/19 19:02:15 mpech Exp $	*/
d42 1
a42 1
"$OpenBSD: docmd.c,v 1.10 2001/11/19 19:02:15 mpech Exp $";
d146 1
a146 1
	(void) sprintf(buf, "IFS=\" \t\"; export IFS; %s -oi -t", 
d357 1
a357 1
	(void) sprintf(buf, "%.*s -S", sizeof(buf)-5, path_rdistd);
d720 1
a720 1
			(void) sprintf(buf, "%s=%s;%s", 
d772 1
a772 1
			(void) sprintf(env, "%s='", E_FILES);
@


1.10
log
@kill more registers

millert@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: docmd.c,v 1.9 2001/06/23 23:08:16 millert Exp $	*/
d42 1
a42 1
"$OpenBSD: docmd.c,v 1.9 2001/06/23 23:08:16 millert Exp $";
d873 1
a873 1
		int pid;
@


1.9
log
@Remove evil #ifdef __GNUC__ garbage to avoid longjmp clobbering and
use volatile instead.
@
text
@d1 1
a1 1
/*	$OpenBSD: docmd.c,v 1.8 1999/02/04 23:18:57 millert Exp $	*/
d42 1
a42 1
"$OpenBSD: docmd.c,v 1.8 1999/02/04 23:18:57 millert Exp $";
d102 1
a102 1
	register struct namelist *to;
d105 1
a105 1
	register int fd, len;
d224 1
a224 1
	register struct cmd *pcmd;
d241 1
a241 1
	register struct cmd *pc;
d313 1
a313 1
	register char *ruser, *cp;
d434 3
a436 3
	register struct namelist *f;
	register struct subcmd *sc;
	register char **cpp;
d589 1
a589 1
		register struct linkbuf *nextl, *l;
d608 1
a608 1
	register char *name;
d610 2
a611 2
	register char *cp = name;
	register int c, isbad;
d633 3
a635 3
	register DIR *d;
	register DIRENTRY *dp;
	register char *cp;
d746 3
a748 3
	register struct subcmd *sc;
	register struct namelist *f;
	register char *cp, **cpp;
d830 2
a831 2
	register struct	subcmd *sc;
	register struct	namelist *nl;
d924 2
a925 2
	register struct namelist *f;
	register int i;
d968 3
a970 3
	register struct cmd *c;
	register char *cp;
	register int i;
d1038 1
a1038 1
			register struct namelist *nlptr;
@


1.8
log
@Fix a serious memory consumption problem when running over directories
that contain many hard-linked files; johnh@@isi.edu
Also add an xstrdup() that behaves like xmalloc() on failure.
@
text
@d1 1
a1 1
/*	$OpenBSD: docmd.c,v 1.7 1998/06/26 21:21:09 millert Exp $	*/
d42 1
a42 1
"$OpenBSD: docmd.c,v 1.7 1998/06/26 21:21:09 millert Exp $";
d437 1
a437 1
	int n, ddir, destdir, opts = options;
d441 2
a442 6
	int didupdate = 0;

#ifdef __GNUC__
	(void)&didupdate;
	(void)&opts;
#endif
@


1.7
log
@rdist 6.1.4 + OpenBSD patches + some -Wall
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d42 1
a42 1
"$OpenBSD$";
d595 1
a595 1
		for (l = ihead; l != NULL; free((char *)l), l = nextl) {
@


1.6
log
@Use our rcmdsh(3) and support $RSH.
@
text
@d1 1
a1 1
/*	$OpenBSD: docmd.c,v 1.5 1997/02/12 19:48:24 dm Exp $	*/
d37 1
d39 5
a43 1
"$OpenBSD: docmd.c,v 1.5 1997/02/12 19:48:24 dm Exp $";
d443 5
d610 1
d651 1
a651 1
	while (dp = readdir(d)) {
d661 1
a661 1
		while (*ptarget++ = *cp++)
d805 1
a805 1
			notify((char *)NULL, sc->sc_args, (time_t)lastmod);
d903 1
a903 1
#if	defined(SETARGS)
d905 1
a905 1
#endif 	/* SETARGS */
d935 1
a935 1
				docmdhost(cmd, (char **) NULL);
d945 1
a945 1
		docmdhost(cmd, (char **) NULL);
@


1.5
log
@Don't print garbage on EOF.
@
text
@d1 1
a1 1
/*	$OpenBSD: docmd.c,v 1.4 1996/06/26 05:38:12 deraadt Exp $	*/
d38 1
a38 1
"$OpenBSD: docmd.c,v 1.4 1996/06/26 05:38:12 deraadt Exp $";
d288 2
a289 1
	debugmsg(DM_MISC, "Remote shell command = '%s'\n", path_remsh);
d291 1
a291 1
	desc = rshrcmd(&rhost, -1, luser, ruser, cmd, 0);
@


1.4
log
@rcsid
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d38 1
a38 1
"$OpenBSD: docmd.c,v 1.3 1996/03/05 03:16:03 dm Exp $";
d313 1
a313 1
	u_char respbuff[BUFSIZ];
@


1.3
log
@rdist 6.1.2
@
text
@d1 2
d38 1
a38 1
"$Id: docmd.c,v 6.86 1996/01/30 02:29:43 mcooper Exp $";
@


1.2
log
@rdist 6.1.1
@
text
@d36 1
a36 1
"$Id: docmd.c,v 6.85 1995/12/12 00:20:24 mcooper Exp $";
d435 5
d469 1
d474 1
d477 1
d594 1
@


1.1
log
@Initial revision
@
text
@d2 2
a3 2
 * Copyright (c) 1983, 1993
 *	The Regents of the University of California.  All rights reserved.
d35 8
a42 2
/* from: static char sccsid[] = "@@(#)docmd.c	8.1 (Berkeley) 6/9/93"; */
static char *rcsid = "$Id: docmd.c,v 1.6 1994/03/07 05:05:26 cgd Exp $";
d45 4
d50 2
a51 1
#include <setjmp.h>
d54 14
a67 14
FILE	*lfp;			/* log file for recording files updated */
struct	subcmd *subcmds;	/* list of sub-commands for current cmd */
jmp_buf	env;

static int	 makeconn __P((char *));
static int	 okname __P((char *));
static void	 closeconn __P((void));
static void	 cmptime __P((char *));
static void	 doarrow __P((char **,
		    struct namelist *, char *, struct subcmd *));
static void	 dodcolon __P((char **,
		    struct namelist *, char *, struct subcmd *));
static void	 notify __P((char *, char *, struct namelist *, time_t));
static void	 rcmptime __P((struct stat *));
d70 1
a70 1
 * Do the commands in cmds (initialized by yyparse).
d72 1
a72 5
void
docmds(dhosts, argc, argv)
	char **dhosts;
	int argc;
	char **argv;
d74 1
a74 9
	register struct cmd *c;
	register struct namelist *f;
	register char **cpp;
	extern struct cmd *cmds;

	signal(SIGHUP, cleanup);
	signal(SIGINT, cleanup);
	signal(SIGQUIT, cleanup);
	signal(SIGTERM, cleanup);
d76 9
a84 33
	for (c = cmds; c != NULL; c = c->c_next) {
		if (dhosts != NULL && *dhosts != NULL) {
			for (cpp = dhosts; *cpp; cpp++)
				if (strcmp(c->c_name, *cpp) == 0)
					goto fndhost;
			continue;
		}
	fndhost:
		if (argc) {
			for (cpp = argv; *cpp; cpp++) {
				if (c->c_label != NULL &&
				    strcmp(c->c_label, *cpp) == 0) {
					cpp = NULL;
					goto found;
				}
				for (f = c->c_files; f != NULL; f = f->n_next)
					if (strcmp(f->n_name, *cpp) == 0)
						goto found;
			}
			continue;
		} else
			cpp = NULL;
	found:
		switch (c->c_type) {
		case ARROW:
			doarrow(cpp, c->c_files, c->c_name, c->c_cmds);
			break;
		case DCOLON:
			dodcolon(cpp, c->c_files, c->c_name, c->c_cmds);
			break;
		default:
			fatal("illegal command type %d\n", c->c_type);
		}
a85 1
	closeconn();
d89 3
a91 1
 * Process commands for sending files to other machines.
d93 1
a93 4
static void
doarrow(filev, files, rhost, cmds)
	char **filev;
	struct namelist *files;
d95 2
a96 1
	struct subcmd *cmds;
d98 5
a102 4
	register struct namelist *f;
	register struct subcmd *sc;
	register char **cpp;
	int n, ddir, opts = options;
d104 2
a105 2
	if (debug)
		printf("doarrow(%x, %s, %x)\n", files, rhost, cmds);
d107 1
a107 2
	if (files == NULL) {
		error("no files to be updated\n");
d109 5
a115 2
	subcmds = cmds;
	ddir = files->n_next != NULL;	/* destination is a directory */
d117 107
a223 11
		printf("updating host %s\n", rhost);
	else {
		if (setjmp(env))
			goto done;
		signal(SIGPIPE, lostconn);
		if (!makeconn(rhost))
			return;
		if ((lfp = fopen(tempfile, "w")) == NULL) {
			fatal("cannot open %s\n", tempfile);
			exit(1);
		}
d225 14
a238 21
	for (f = files; f != NULL; f = f->n_next) {
		if (filev) {
			for (cpp = filev; *cpp; cpp++)
				if (strcmp(f->n_name, *cpp) == 0)
					goto found;
			if (!nflag)
				(void) fclose(lfp);
			continue;
		}
	found:
		n = 0;
		for (sc = cmds; sc != NULL; sc = sc->sc_next) {
			if (sc->sc_type != INSTALL)
				continue;
			n++;
			install(f->n_name, sc->sc_name,
				sc->sc_name == NULL ? 0 : ddir, sc->sc_options);
			opts = sc->sc_options;
		}
		if (n == 0)
			install(f->n_name, NULL, 0, options);
d240 8
a247 5
done:
	if (!nflag) {
		(void) signal(SIGPIPE, cleanup);
		(void) fclose(lfp);
		lfp = NULL;
d249 29
a277 12
	for (sc = cmds; sc != NULL; sc = sc->sc_next)
		if (sc->sc_type == NOTIFY)
			notify(tempfile, rhost, sc->sc_args, 0);
	if (!nflag) {
		(void) unlink(tempfile);
		for (; ihead != NULL; ihead = ihead->nextp) {
			free(ihead);
			if ((opts & IGNLNKS) || ihead->count == 0)
				continue;
			log(lfp, "%s: Warning: missing links\n",
				ihead->pathname);
		}
d279 17
d300 1
d302 1
a302 2
static int
makeconn(rhost)
d307 5
a311 2
	static int port = -1;
	char tuser[20];
a312 2
	extern char user[];
	extern int userid;
d314 1
a314 2
	if (debug)
		printf("makeconn(%s)\n", rhost);
d316 4
a319 1
	if (cur_host != NULL && rem >= 0) {
d324 4
d329 2
a330 1
	cp = index(rhost, '@@');
d334 2
a335 2
		*cp = '\0';
		strncpy(tuser, rhost, sizeof(tuser)-1);
d339 2
a340 2
		if (*ruser == '\0')
			ruser = user;
d344 4
a347 6
		ruser = user;
	if (!qflag)
		printf("updating host %s\n", rhost);
	(void) sprintf(buf, "%s -Server%s", _PATH_RDIST, qflag ? " -q" : "");
	if (port < 0) {
		struct servent *sp;
d349 4
a352 4
		if ((sp = getservbyname("shell", "tcp")) == NULL)
			fatal("shell/tcp: unknown service");
		port = sp->s_port;
	}
d354 8
a361 3
	if (debug) {
		printf("port = %d, luser = %s, ruser = %s\n", ntohs(port), user, ruser);
		printf("buf = %s\n", buf);
d364 13
a376 22
	fflush(stdout);
	seteuid(0);
	rem = rcmd(&rhost, port, user, ruser, buf, 0);
	seteuid(userid);
	if (rem < 0)
		return(0);
	cp = buf;
	if (read(rem, cp, 1) != 1)
		lostconn(0);
	if (*cp == 'V') {
		do {
			if (read(rem, cp, 1) != 1)
				lostconn(0);
		} while (*cp++ != '\n' && cp < &buf[BUFSIZ]);
		*--cp = '\0';
		cp = buf;
		n = 0;
		while (*cp >= '0' && *cp <= '9')
			n = (n * 10) + (*cp++ - '0');
		if (*cp == '\0' && n == VERSION)
			return(1);
		error("connection failed: version numbers don't match (local %d, remote %d)\n", VERSION, n);
d378 10
a387 5
		error("connection failed: version numbers don't match\n");
		error("got unexpected input:");
		do {
			error("%c", *cp);
		} while (*cp != '\n' && read(rem, cp, 1) == 1);
a388 3
	closeconn();
	return(0);
}
d390 24
a413 13
/*
 * Signal end of previous connection.
 */
static void
closeconn()
{
	if (debug)
		printf("closeconn()\n");

	if (rem >= 0) {
		(void) write(rem, "\2\n", 2);
		(void) close(rem);
		rem = -1;
a414 18
}

void
lostconn(signo)
	int signo;
{
	if (iamremote)
		cleanup(0);
	log(lfp, "rdist: lost connection\n");
	longjmp(env, 1);
}

static int
okname(name)
	register char *name;
{
	register char *cp = name;
	register int c;
a415 8
	do {
		c = *cp;
		if (c & 0200)
			goto bad;
		if (!isalpha(c) && !isdigit(c) && c != '_' && c != '-')
			goto bad;
		cp++;
	} while (*cp);
a416 3
bad:
	error("invalid user name %s\n", name);
	return(0);
a418 4
time_t	lastmod;
FILE	*tfp;
extern	char target[], *tp;

d420 1
a420 1
 * Process commands for comparing files to time stamp files.
d422 2
a423 2
static void
dodcolon(filev, files, stamp, cmds)
a424 3
	struct namelist *files;
	char *stamp;
	struct subcmd *cmds;
d426 1
a427 1
	register struct namelist *f;
d429 10
a438 3
	struct timeval tv[2];
	struct timezone tz;
	struct stat stb;
d440 3
a442 2
	if (debug)
		printf("dodcolon()\n");
d445 2
a446 1
		error("no files to be updated\n");
a448 6
	if (stat(stamp, &stb) < 0) {
		error("%s: %s\n", stamp, strerror(errno));
		return;
	}
	if (debug)
		printf("%s: %ld\n", stamp, stb.st_mtime);
d450 5
a454 4
	subcmds = cmds;
	lastmod = stb.st_mtime;
	if (nflag || (options & VERIFY))
		tfp = NULL;
d456 15
a470 2
		if ((tfp = fopen(tempfile, "w")) == NULL) {
			error("%s: %s\n", stamp, strerror(errno));
a472 3
		(void) gettimeofday(&tv[0], &tz);
		tv[1] = tv[0];
		(void) utimes(stamp, tv);
d475 48
d531 4
a534 2
		tp = NULL;
		cmptime(f->n_name);
d537 31
a567 3
	if (tfp != NULL)
		(void) fclose(tfp);
	for (sc = cmds; sc != NULL; sc = sc->sc_next)
d569 77
a645 3
			notify(tempfile, NULL, sc->sc_args, lastmod);
	if (!nflag && !(options & VERIFY))
		(void) unlink(tempfile);
d651 1
a651 2
static void
cmptime(name)
d653 2
d656 1
d658 1
d660 1
a660 2
	if (debug)
		printf("cmptime(%s)\n", name);
d666 1
a666 1
		printf("comparing dates: %s\n", name);
d673 1
a673 1
	if (tp == NULL) {
d676 3
a678 3
		tp = name = target;
		while (*tp)
			tp++;
d680 2
a681 2
	if (access(name, 4) < 0 || stat(name, &stb) < 0) {
		error("%s: %s\n", name, strerror(errno));
d685 2
a686 6
	switch (stb.st_mode & S_IFMT) {
	case S_IFREG:
		break;

	case S_IFDIR:
		rcmptime(&stb);
d688 2
a689 3

	default:
		error("%s: not a plain file\n", name);
d693 25
a717 2
	if (stb.st_mtime > lastmod)
		log(tfp, "new: %s\n", name);
d720 6
a725 3
static void
rcmptime(st)
	struct stat *st;
d727 7
a733 5
	register DIR *d;
	register struct direct *dp;
	register char *cp;
	char *otp;
	int len;
d735 1
a735 2
	if (debug)
		printf("rcmptime(%x)\n", st);
d737 3
a739 2
	if ((d = opendir(target)) == NULL) {
		error("%s: %s\n", target, strerror(errno));
d742 31
a772 7
	otp = tp;
	len = tp - target;
	while (dp = readdir(d)) {
		if (!strcmp(dp->d_name, ".") || !strcmp(dp->d_name, ".."))
			continue;
		if (len + 1 + strlen(dp->d_name) >= BUFSIZ - 1) {
			error("%s/%s: Name too long\n", target, dp->d_name);
d775 25
a799 7
		tp = otp;
		*tp++ = '/';
		cp = dp->d_name;
		while (*tp++ = *cp++)
			;
		tp--;
		cmptime(target);
d801 2
a802 3
	closedir(d);
	tp = otp;
	*tp = '\0';
d806 1
a806 3
 * Notify the list of people the changes that were made.
 * rhost == NULL if we are mailing a list of changes compared to at time
 * stamp file.
d808 2
a809 5
static void
notify(file, rhost, to, lmod)
	char *file, *rhost;
	register struct namelist *to;
	time_t lmod;
d811 4
a814 3
	register int fd, len;
	struct stat stb;
	FILE *pf;
d816 20
a835 7
	if ((options & VERIFY) || to == NULL)
		return;
	if (!qflag) {
		printf("notify ");
		if (rhost)
			printf("@@%s ", rhost);
		prnames(to);
d837 11
a847 2
	if (nflag)
		return;
a848 13
	if ((fd = open(file, 0)) < 0) {
		error("%s: %s\n", file, strerror(errno));
		return;
	}
	if (fstat(fd, &stb) < 0) {
		error("%s: %s\n", file, strerror(errno));
		(void) close(fd);
		return;
	}
	if (stb.st_size == 0) {
		(void) close(fd);
		return;
	}
d850 2
a851 1
	 * Create a pipe to mailling program.
d853 17
a869 6
	(void)sprintf(buf, "%s -oi -t", _PATH_SENDMAIL);
	pf = popen(buf, "w");
	if (pf == NULL) {
		error("notify: \"%s\" failed\n", _PATH_SENDMAIL);
		(void) close(fd);
		return;
d871 1
d873 1
a873 1
	 * Output the proper header information.
d875 8
a882 13
	fprintf(pf, "From: rdist (Remote distribution program)\n");
	fprintf(pf, "To:");
	if (!any('@@', to->n_name) && rhost != NULL)
		fprintf(pf, " %s@@%s", to->n_name, rhost);
	else
		fprintf(pf, " %s", to->n_name);
	to = to->n_next;
	while (to != NULL) {
		if (!any('@@', to->n_name) && rhost != NULL)
			fprintf(pf, ", %s@@%s", to->n_name, rhost);
		else
			fprintf(pf, ", %s", to->n_name);
		to = to->n_next;
a883 7
	putc('\n', pf);
	if (rhost != NULL)
		fprintf(pf, "Subject: files updated by rdist from %s to %s\n",
			host, rhost);
	else
		fprintf(pf, "Subject: files updated after %s\n", ctime(&lmod));
	putc('\n', pf);
d885 10
a894 4
	while ((len = read(fd, buf, BUFSIZ)) > 0)
		(void) fwrite(buf, 1, len, pf);
	(void) close(fd);
	(void) pclose(pf);
d898 1
a898 1
 * Return true if name is in the list.
d900 4
a903 4
int
inlist(list, file)
	struct namelist *list;
	char *file;
d905 2
a906 1
	register struct namelist *nl;
d908 15
a922 4
	for (nl = list; nl != NULL; nl = nl->n_next)
		if (!strcmp(file, nl->n_name))
			return(1);
	return(0);
d926 17
a942 1
 * Return TRUE if file is in the exception list.
d944 4
a947 3
int
except(file)
	char *file;
d949 33
a981 2
	register struct	subcmd *sc;
	register struct	namelist *nl;
d983 13
a995 2
	if (debug)
		printf("except(%s)\n", file);
d997 16
a1012 7
	for (sc = subcmds; sc != NULL; sc = sc->sc_next) {
		if (sc->sc_type != EXCEPT && sc->sc_type != PATTERN)
			continue;
		for (nl = sc->sc_args; nl != NULL; nl = nl->n_next) {
			if (sc->sc_type == EXCEPT) {
				if (!strcmp(file, nl->n_name))
					return(1);
a1014 3
			re_comp(nl->n_name);
			if (re_exec(file) > 0)
				return(1);
d1016 18
a1034 2
	return(0);
}
d1036 13
a1048 4
char *
colon(cp)
	register char *cp;
{
d1050 15
a1064 6
	while (*cp) {
		if (*cp == ':')
			return(cp);
		if (*cp == '/')
			return(0);
		cp++;
a1065 1
	return(0);
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@
