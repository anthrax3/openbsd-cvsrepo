head	1.35;
access;
symbols
	OPENBSD_6_1:1.35.0.6
	OPENBSD_6_1_BASE:1.35
	OPENBSD_6_0:1.35.0.4
	OPENBSD_6_0_BASE:1.35
	OPENBSD_5_9:1.35.0.2
	OPENBSD_5_9_BASE:1.35
	OPENBSD_5_8:1.34.0.6
	OPENBSD_5_8_BASE:1.34
	OPENBSD_5_7:1.34.0.2
	OPENBSD_5_7_BASE:1.34
	OPENBSD_5_6:1.31.0.4
	OPENBSD_5_6_BASE:1.31
	OPENBSD_5_5:1.26.0.4
	OPENBSD_5_5_BASE:1.26
	OPENBSD_5_4:1.25.0.4
	OPENBSD_5_4_BASE:1.25
	OPENBSD_5_3:1.25.0.2
	OPENBSD_5_3_BASE:1.25
	OPENBSD_5_2:1.23.0.6
	OPENBSD_5_2_BASE:1.23
	OPENBSD_5_1_BASE:1.23
	OPENBSD_5_1:1.23.0.4
	OPENBSD_5_0:1.23.0.2
	OPENBSD_5_0_BASE:1.23
	OPENBSD_4_9:1.22.0.6
	OPENBSD_4_9_BASE:1.22
	OPENBSD_4_8:1.22.0.4
	OPENBSD_4_8_BASE:1.22
	OPENBSD_4_7:1.22.0.2
	OPENBSD_4_7_BASE:1.22
	OPENBSD_4_6:1.21.0.6
	OPENBSD_4_6_BASE:1.21
	OPENBSD_4_5:1.21.0.2
	OPENBSD_4_5_BASE:1.21
	OPENBSD_4_4:1.20.0.16
	OPENBSD_4_4_BASE:1.20
	OPENBSD_4_3:1.20.0.14
	OPENBSD_4_3_BASE:1.20
	OPENBSD_4_2:1.20.0.12
	OPENBSD_4_2_BASE:1.20
	OPENBSD_4_1:1.20.0.10
	OPENBSD_4_1_BASE:1.20
	OPENBSD_4_0:1.20.0.8
	OPENBSD_4_0_BASE:1.20
	OPENBSD_3_9:1.20.0.6
	OPENBSD_3_9_BASE:1.20
	OPENBSD_3_8:1.20.0.4
	OPENBSD_3_8_BASE:1.20
	OPENBSD_3_7:1.20.0.2
	OPENBSD_3_7_BASE:1.20
	OPENBSD_3_6:1.19.0.6
	OPENBSD_3_6_BASE:1.19
	OPENBSD_3_5:1.19.0.4
	OPENBSD_3_5_BASE:1.19
	OPENBSD_3_4:1.19.0.2
	OPENBSD_3_4_BASE:1.19
	OPENBSD_3_3:1.13.0.6
	OPENBSD_3_3_BASE:1.13
	OPENBSD_3_2:1.13.0.4
	OPENBSD_3_2_BASE:1.13
	OPENBSD_3_1:1.13.0.2
	OPENBSD_3_1_BASE:1.13
	OPENBSD_3_0:1.12.0.12
	OPENBSD_3_0_BASE:1.12
	OPENBSD_2_9_BASE:1.12
	OPENBSD_2_9:1.12.0.10
	OPENBSD_2_8:1.12.0.8
	OPENBSD_2_8_BASE:1.12
	OPENBSD_2_7:1.12.0.6
	OPENBSD_2_7_BASE:1.12
	OPENBSD_2_6:1.12.0.4
	OPENBSD_2_6_BASE:1.12
	OPENBSD_2_5:1.12.0.2
	OPENBSD_2_5_BASE:1.12
	OPENBSD_2_4:1.7.0.2
	OPENBSD_2_4_BASE:1.7
	OPENBSD_2_3:1.5.0.4
	OPENBSD_2_3_BASE:1.5
	OPENBSD_2_2:1.5.0.2
	OPENBSD_2_2_BASE:1.5
	OPENBSD_2_1:1.4.0.4
	OPENBSD_2_1_BASE:1.4
	OPENBSD_2_0:1.4.0.2
	OPENBSD_2_0_BASE:1.4;
locks; strict;
comment	@ * @;


1.35
date	2015.12.09.19.39.10;	author mmcc;	state Exp;
branches;
next	1.34;
commitid	vYfMHQk0uPOMI7wA;

1.34
date	2015.01.21.03.18.31;	author guenther;	state Exp;
branches;
next	1.33;
commitid	yj8bO7Z9PXVbwqj2;

1.33
date	2015.01.20.09.00.16;	author guenther;	state Exp;
branches;
next	1.32;
commitid	0Y0sKBv6c3xIKoav;

1.32
date	2015.01.16.06.40.11;	author deraadt;	state Exp;
branches;
next	1.31;
commitid	Uu5nFG3wCl0LACBb;

1.31
date	2014.07.12.03.48.04;	author guenther;	state Exp;
branches;
next	1.30;
commitid	p9pOV7jMl4hhcolh;

1.30
date	2014.07.12.03.07.22;	author guenther;	state Exp;
branches;
next	1.29;
commitid	pmRYQPtyCDHxXvuw;

1.29
date	2014.07.05.06.55.29;	author guenther;	state Exp;
branches;
next	1.28;
commitid	v5AUs0w5PR8DHpj3;

1.28
date	2014.07.05.06.45.00;	author guenther;	state Exp;
branches;
next	1.27;
commitid	zoLIfEXn2KDMNucz;

1.27
date	2014.07.05.05.05.51;	author guenther;	state Exp;
branches;
next	1.26;
commitid	U6Y6NKOm7JX1MOTg;

1.26
date	2013.08.18.16.32.24;	author guenther;	state Exp;
branches;
next	1.25;

1.25
date	2012.11.12.01.18.37;	author guenther;	state Exp;
branches;
next	1.24;

1.24
date	2012.11.12.01.14.41;	author guenther;	state Exp;
branches;
next	1.23;

1.23
date	2011.04.10.15.47.28;	author krw;	state Exp;
branches;
next	1.22;

1.22
date	2009.10.27.23.59.42;	author deraadt;	state Exp;
branches;
next	1.21;

1.21
date	2009.02.15.22.20.54;	author deraadt;	state Exp;
branches;
next	1.20;

1.20
date	2004.10.04.05.21.27;	author jsg;	state Exp;
branches;
next	1.19;

1.19
date	2003.06.03.02.56.14;	author millert;	state Exp;
branches;
next	1.18;

1.18
date	2003.05.14.01.34.35;	author millert;	state Exp;
branches;
next	1.17;

1.17
date	2003.05.06.22.10.11;	author millert;	state Exp;
branches;
next	1.16;

1.16
date	2003.04.19.17.22.29;	author millert;	state Exp;
branches;
next	1.15;

1.15
date	2003.04.07.21.13.52;	author deraadt;	state Exp;
branches;
next	1.14;

1.14
date	2003.04.05.20.31.58;	author deraadt;	state Exp;
branches;
next	1.13;

1.13
date	2001.11.19.19.02.15;	author mpech;	state Exp;
branches;
next	1.12;

1.12
date	99.03.05.01.36.12;	author millert;	state Exp;
branches;
next	1.11;

1.11
date	99.03.05.01.32.47;	author millert;	state Exp;
branches;
next	1.10;

1.10
date	99.02.23.21.27.15;	author millert;	state Exp;
branches;
next	1.9;

1.9
date	99.02.06.01.52.23;	author millert;	state Exp;
branches;
next	1.8;

1.8
date	99.02.04.23.18.57;	author millert;	state Exp;
branches;
next	1.7;

1.7
date	98.06.26.21.21.00;	author millert;	state Exp;
branches;
next	1.6;

1.6
date	98.05.18.19.12.29;	author deraadt;	state Exp;
branches;
next	1.5;

1.5
date	97.07.21.01.53.37;	author angelos;	state Exp;
branches;
next	1.4;

1.4
date	96.07.25.05.31.00;	author millert;	state Exp;
branches;
next	1.3;

1.3
date	96.06.26.05.38.08;	author deraadt;	state Exp;
branches;
next	1.2;

1.2
date	96.03.05.03.15.57;	author dm;	state Exp;
branches;
next	1.1;

1.1
date	96.02.03.12.12.11;	author dm;	state Exp;
branches;
next	;


desc
@@


1.35
log
@Remove NULL-checks before free(). ok tb@@
@
text
@/*	$OpenBSD: client.c,v 1.34 2015/01/21 03:18:31 guenther Exp $	*/

/*
 * Copyright (c) 1983 Regents of the University of California.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */

#include <ctype.h>
#include <dirent.h>
#include <errno.h>
#include <fcntl.h>
#include <limits.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>

#include "client.h"
#include "y.tab.h"

/*
 * Routines used in client mode to communicate with remove server.
 */


/*
 * Update status
 */
#define US_NOTHING 	0	/* No update needed */
#define US_NOENT	1	/* Entry does not exist */
#define US_OUTDATE	2	/* Entry is out of date */
#define US_DOCOMP	3	/* Do a binary comparison */
#define US_CHMOG	4	/* Modes or ownership of file differ */

struct	linkbuf *ihead = NULL;	/* list of files with more than one link */
char	buf[BUFSIZ];		/* general purpose buffer */
u_char	respbuff[BUFSIZ];	/* Response buffer */
char	target[BUFSIZ];		/* target/source directory name */
char	source[BUFSIZ];		/* source directory name */
char	*ptarget;		/* pointer to end of target name */
char	*Tdest;			/* pointer to last T dest*/
struct namelist	*updfilelist = NULL; /* List of updated files */

static void runspecial(char *, opt_t, char *, int);
static void addcmdspecialfile(char *, char *, int);
static void freecmdspecialfiles(void);
static struct linkbuf *linkinfo(struct stat *);
static int sendhardlink(opt_t, struct linkbuf *, char *, int);
static int sendfile(char *, opt_t, struct stat *, char *, char *, int);
static int rmchk(opt_t);
static int senddir(char *, opt_t, struct stat *, char *, char *, int);
static int sendlink(char *, opt_t, struct stat *, char *, char *, int);
static int update(char *, opt_t, struct stat *);
static int dostat(char *, struct stat *, opt_t);
static int statupdate(int, char *, opt_t, char *, int, struct stat *, char *, char *);
static int fullupdate(int, char *, opt_t, char *, int, struct stat *, char *, char *);
static int sendit(char *, opt_t, int);

/*
 * return remote file pathname (relative from target)
 */
char *
remfilename(char *src, char *dest, char *path, char *rname, int destdir)
{
	char *lname, *cp;
	static char buff[BUFSIZ];
	int srclen, pathlen;
	char *p;


	debugmsg(DM_MISC, 
		 "remfilename: src=%s dest=%s path=%s rname=%s destdir=%d\n",
		A(src), A(dest), A(path), A(rname), destdir);

	if (!dest) {
		debugmsg(DM_MISC, "remfilename: remote filename=%s\n", path);
		return(path);
	}

	if (!destdir) {
		debugmsg(DM_MISC, "remfilename: remote filename=%s\n", dest);
		return(dest);
	}

	buff[0] = CNULL;
	lname = buff;
	if (path && *path) {
		cp = strrchr(path, '/');
 		if (cp == NULL)
			(void) snprintf(buff, sizeof(buff), "%s/%s", dest, path);
		else {
			srclen = strlen(src);
			pathlen = strlen(path);
			if (srclen >= pathlen)
				cp++; /* xbasename(path) */
			else {
				if (filelist && filelist->n_next == NULL)
					/* path relative to src */
					cp = path + srclen;
				else {
					if ((p = strrchr(src, '/')))
						cp = path + srclen - strlen(p);
					else
						cp = path;
				}
			}
			if ((*cp != '/') && *cp)
				(void) snprintf(buff, sizeof(buff), "%s/%s",
						dest, cp);
			else
				(void) snprintf(buff, sizeof(buff), "%s%s",
						dest, cp);
		}
	} else
		(void) strlcpy(lname, dest, buf + sizeof buff - lname);

	debugmsg(DM_MISC, "remfilename: remote filename=%s\n", lname);

	return(lname);
}

/*
 * Return true if name is in the list.
 */
int
inlist(struct namelist *list, char *file)
{
	struct namelist *nl;

	for (nl = list; nl != NULL; nl = nl->n_next)
		if (strcmp(file, nl->n_name) == 0)
			return(1);
	return(0);
}

/*
 * Run any special commands for this file
 */
static void
runspecial(char *starget, opt_t opts, char *rname, int destdir)
{
	struct subcmd *sc;
	char *rfile;

 	rfile = remfilename(source, Tdest, target, rname, destdir);

	for (sc = subcmds; sc != NULL; sc = sc->sc_next) {
		if (sc->sc_type != SPECIAL)
			continue;
		if (sc->sc_args != NULL && !inlist(sc->sc_args, starget))
			continue;
		message(MT_CHANGE, "special \"%s\"", sc->sc_name);
		if (IS_ON(opts, DO_VERIFY))
			continue;
		(void) sendcmd(C_SPECIAL,
			"%s=%s;%s=%s;%s=%s;export %s %s %s;%s",
			E_LOCFILE, starget,
			E_REMFILE, rfile,
			E_BASEFILE, xbasename(rfile),
			E_LOCFILE, E_REMFILE, E_BASEFILE,
			sc->sc_name);
		while (response() > 0)
			;
	}
}

/*
 * If we're doing a target with a "cmdspecial" in it, then
 * save the name of the file being updated for use with "cmdspecial".
 */
static void
addcmdspecialfile(char *starget, char *rname, int destdir)
{
	char *rfile;
	struct namelist *new;
	struct subcmd *sc;
	int isokay = 0;

 	rfile = remfilename(source, Tdest, target, rname, destdir);

	for (sc = subcmds; sc != NULL && !isokay; sc = sc->sc_next) {
		if (sc->sc_type != CMDSPECIAL)
			continue;
		if (sc->sc_args != NULL && !inlist(sc->sc_args, starget))
			continue;
		isokay = TRUE;
	}

	if (isokay) {
		new = xmalloc(sizeof *new);
		new->n_name = xstrdup(rfile);
		new->n_regex = NULL;
		new->n_next = updfilelist;
		updfilelist = new;
	}
}

/*
 * Free the file list
 */
static void
freecmdspecialfiles(void)
{
	struct namelist *ptr, *save;

	for (ptr = updfilelist; ptr; ) {
		if (ptr->n_name) (void) free(ptr->n_name);
		save = ptr->n_next;
		(void) free(ptr);
		if (save)
			ptr = save->n_next;
		else
			ptr = NULL;
	}
	updfilelist = NULL;
}

/*
 * Run commands for an entire cmd
 */
void
runcmdspecial(struct cmd *cmd, opt_t opts)
{
	struct subcmd *sc;
	struct namelist *f;
	int first = TRUE;

	for (sc = cmd->c_cmds; sc != NULL; sc = sc->sc_next) {
		if (sc->sc_type != CMDSPECIAL)
			continue;
		message(MT_CHANGE, "cmdspecial \"%s\"", sc->sc_name);
		if (IS_ON(opts, DO_VERIFY))
			continue;
		/* Send all the file names */
		for (f = updfilelist; f != NULL; f = f->n_next) {
			if (first) {
				(void) sendcmd(C_CMDSPECIAL, NULL);
				if (response() < 0)
					return;
				first = FALSE;
			}
			(void) sendcmd(RC_FILE, "%s", f->n_name);
			if (response() < 0)
				return;
		}
		if (first) {
			(void) sendcmd(C_CMDSPECIAL, NULL);
			if (response() < 0)
				return;
			first = FALSE;
		}
		/* Send command to run and wait for it to complete */
		(void) sendcmd(RC_COMMAND, "%s", sc->sc_name);
		while (response() > 0)
			;
		first = TRUE;	/* Reset in case there are more CMDSPECIAL's */
	}
	freecmdspecialfiles();
}

/*
 * For security, reject filenames that contains a newline
 */
int
checkfilename(char *name)
{
	char *cp;

	if (strchr(name, '\n')) {
		for (cp = name; *cp; cp++)
			if (*cp == '\n')
				*cp = '?';
		message(MT_NERROR, 
			"Refuse to handle filename containing newline: %s",
			name);
		return(-1);
	}

	return(0);
}

void
freelinkinfo(struct linkbuf *lp)
{
	free(lp->pathname);
	free(lp->src);
	free(lp->target);
	free(lp);
}

/*
 * Save and retrieve hard link info
 */
static struct linkbuf *
linkinfo(struct stat *statp)
{
	struct linkbuf *lp;

	/* XXX - linear search doesn't scale with many links */
	for (lp = ihead; lp != NULL; lp = lp->nextp)
		if (lp->inum == statp->st_ino && lp->devnum == statp->st_dev) {
			lp->count--;
			return(lp);
		}

	lp = xmalloc(sizeof(*lp));
	lp->nextp = ihead;
	ihead = lp;
	lp->inum = statp->st_ino;
	lp->devnum = statp->st_dev;
	lp->count = statp->st_nlink - 1;
	lp->pathname = xstrdup(target);
	lp->src = xstrdup(source);
	if (Tdest)
		lp->target = xstrdup(Tdest);
	else
		lp->target = NULL;

	return(NULL);
}

/*
 * Send a hardlink
 */
static int
sendhardlink(opt_t opts, struct linkbuf *lp, char *rname, int destdir)
{
	static char buff[PATH_MAX];
	char *lname;	/* name of file to link to */
	char ername[PATH_MAX*4], elname[PATH_MAX*4];

	debugmsg(DM_MISC, 
	       "sendhardlink: rname='%s' pathname='%s' src='%s' target='%s'\n",
		rname, lp->pathname ? lp->pathname : "",
		lp->src ? lp->src : "", lp->target ? lp->target : "");
		 
	if (lp->target == NULL)
		lname = lp->pathname;
	else {
		lname = buff;
		strlcpy(lname, remfilename(lp->src, lp->target, 
					  lp->pathname, rname, 
					  destdir), sizeof(buff));
		debugmsg(DM_MISC, "sendhardlink: lname=%s\n", lname);
	}
	ENCODE(elname, lname);
	ENCODE(ername, rname);
	(void) sendcmd(C_RECVHARDLINK, "%o %s %s", opts, elname, ername);

	return(response());
}

/*
 * Send a file
 */
static int
sendfile(char *rname, opt_t opts, struct stat *stb, char *user,
	 char *group, int destdir)
{
	int goterr, f;
	off_t i;
	char ername[PATH_MAX*4];

	if (stb->st_nlink > 1) {
		struct linkbuf *lp;
		
		if ((lp = linkinfo(stb)) != NULL)
			return(sendhardlink(opts, lp, rname, destdir));
	}

	if ((f = open(target, O_RDONLY)) < 0) {
		error("%s: open for read failed: %s", target, SYSERR);
		return(-1);
	}

	/*
	 * Send file info
	 */
	ENCODE(ername, rname);

	(void) sendcmd(C_RECVREG, "%o %04o %lld %lld %lld %s %s %s", 
		       opts, stb->st_mode & 07777, (long long) stb->st_size, 
		       (long long)stb->st_mtime, (long long)stb->st_atime,
		       user, group, ername);
	if (response() < 0) {
		(void) close(f);
		return(-1);
	}


	debugmsg(DM_MISC, "Send file '%s' %lld bytes\n", rname,
		 (long long) stb->st_size);

	/*
	 * Set remote time out alarm handler.
	 */
	(void) signal(SIGALRM, sighandler);

	/*
	 * Actually transfer the file
	 */
	goterr = 0;
	for (i = 0; i < stb->st_size; i += BUFSIZ) {
		off_t amt = BUFSIZ;

		(void) alarm(rtimeout);
		if (i + amt > stb->st_size)
			amt = stb->st_size - i;
		if (read(f, buf, (size_t) amt) != (ssize_t) amt) {
			error("%s: File changed size", target);
			err();
			++goterr;
			/*
			 * XXX - We have to keep going because the
			 * server expects to receive a fixed number
			 * of bytes that we specified as the file size.
			 * We need Out Of Band communication to handle
			 * this situation gracefully.
			 */
		}
		if (xwrite(rem_w, buf, (size_t) amt) < 0) {
			error("%s: Error writing to client: %s", 
			      target, SYSERR);
			err();
			++goterr;
			break;
		}
		(void) alarm(0);
	}

	(void) alarm(0);	/* Insure alarm is off */
	(void) close(f);

	debugmsg(DM_MISC, "Send file '%s' %s.\n", 
		 (goterr) ? "failed" : "complete", rname);

	/*
	 * Check for errors and end send
	 */
	if (goterr)
		return(-1);
	else {
		ack();
		f = response();
		if (f < 0)
			return(-1);
		else if (f == 0 && IS_ON(opts, DO_COMPARE))
			return(0);

		runspecial(target, opts, rname, destdir);
		addcmdspecialfile(target, rname, destdir);

		return(0);
	}
}

/*
 * Check for files on the machine being updated that are not on the master
 * machine and remove them.
 *
 * Return < 0 on error.
 * Return 0 if nothing happened.
 * Return > 0 if anything is updated.
 */
static int
rmchk(opt_t opts)
{
	u_char *s;
	struct stat stb;
	int didupdate = 0;
	int n;
	char targ[PATH_MAX*4];

	debugmsg(DM_CALL, "rmchk()\n");

	/*
	 * Tell the remote to clean the files from the last directory sent.
	 */
	(void) sendcmd(C_CLEAN, "%o", IS_ON(opts, DO_VERIFY));
	if (response() < 0)
		return(-1);

	for ( ; ; ) {
		n = remline(s = respbuff, sizeof(respbuff), TRUE);
		if (n <= 0) {
			error("rmchk: unexpected control record");
			return(didupdate);
		}

		switch (*s++) {
		case CC_QUERY: /* Query if file should be removed */
			/*
			 * Return the following codes to remove query.
			 * CC_NO -- file exists - DON'T remove.
			 * CC_YES -- file doesn't exist - REMOVE.
			 */
			if (DECODE(targ, (char *) s) == -1) {
				error("rmchk: cannot decode file");
				return(-1);
			}
			(void) snprintf(ptarget,
					sizeof(target) - (ptarget - target),
					"%s%s", 
				        (ptarget[-1] == '/' ? "" : "/"),
				        targ);
			debugmsg(DM_MISC, "check %s\n", target);
			if (except(target))
				(void) sendcmd(CC_NO, NULL);
			else if (lstat(target, &stb) < 0) {
				if (sendcmd(CC_YES, NULL) == 0)
					didupdate = 1;
			} else
				(void) sendcmd(CC_NO, NULL);
			break;

		case CC_END:
			*ptarget = CNULL;
			ack();
			return(didupdate);

		case C_LOGMSG:
			if (n > 0)
				message(MT_INFO, "%s", s);
			break;

		case C_NOTEMSG:
			if (n > 0)
				message(MT_NOTICE, "%s", s);
			break;
			/* Goto top of loop */

		case C_ERRMSG:
			message(MT_NERROR, "%s", s);
			return(didupdate);

		case C_FERRMSG:
			message(MT_FERROR, "%s", s);
			finish();

		default:
			error("rmchk: unexpected response '%s'", respbuff);
			err();
		}
	}
	/*NOTREACHED*/
}

/*
 * Send a directory
 *
 * Return < 0 on error.
 * Return 0 if nothing happened.
 * Return > 0 if anything is updated.
 */
static int
senddir(char *rname, opt_t opts, struct stat *stb, char *user,
	char *group, int destdir)
{
	struct dirent *dp;
	DIR *d;
	char *optarget, *cp;
	int len;
	int didupdate = 0;
	char ername[PATH_MAX*4];

	/*
	 * Send recvdir command in recvit() format.
	 */
	ENCODE(ername, rname);
	(void) sendcmd(C_RECVDIR, "%o %04o 0 0 0 %s %s %s", 
		       opts, stb->st_mode & 07777, user, group, ername);
	if (response() < 0)
		return(-1);

	optarget = ptarget;

	/*
	 * Don't descend into directory
	 */
	if (IS_ON(opts, DO_NODESCEND)) {
		didupdate = 0;
		goto out;
	}

	if (IS_ON(opts, DO_REMOVE))
		if (rmchk(opts) > 0)
			++didupdate;
	
	if ((d = opendir(target)) == NULL) {
		error("%s: opendir failed: %s", target, SYSERR);
		didupdate = -1;
		goto out;
	}

	len = ptarget - target;
	while ((dp = readdir(d)) != NULL) {
		if (!strcmp(dp->d_name, ".") ||
		    !strcmp(dp->d_name, ".."))
			continue;
		if (len + 1 + (int) strlen(dp->d_name) >= PATH_MAX - 1) {
			error("%s/%s: Name too long", target,
			      dp->d_name);
			continue;
		}
		ptarget = optarget;
		if (ptarget[-1] != '/')
			*ptarget++ = '/';
		cp = dp->d_name;
		while ((*ptarget++ = *cp++) != '\0')
			continue;
		ptarget--;
		if (sendit(dp->d_name, opts, destdir) > 0)
			didupdate = 1;
	}
	(void) closedir(d);

out:
	(void) sendcmd(C_END, NULL);
	(void) response();

	ptarget = optarget;
	*ptarget = CNULL;

	return(didupdate);
}

/*
 * Send a link
 */
static int
sendlink(char *rname, opt_t opts, struct stat *stb, char *user,
	 char *group, int destdir)
{
	int f, n;
	static char tbuf[BUFSIZ];
	char lbuf[PATH_MAX];
	u_char *s;
	char ername[PATH_MAX*4];

	debugmsg(DM_CALL, "sendlink(%s, %#x, stb, %d)\n", rname, opts, destdir);

	if (stb->st_nlink > 1) {
		struct linkbuf *lp;
		
		if ((lp = linkinfo(stb)) != NULL)
			return(sendhardlink(opts, lp, rname, destdir));
	}

	/*
	 * Gather and send basic link info
	 */
	ENCODE(ername, rname);
	(void) sendcmd(C_RECVSYMLINK, "%o %04o %lld %lld %lld %s %s %s", 
		       opts, stb->st_mode & 07777, (long long) stb->st_size, 
		       (long long)stb->st_mtime, (long long)stb->st_atime,
		       user, group, ername);
	if (response() < 0)
		return(-1);

	/*
	 * Gather and send additional link info
	 */
	if ((n = readlink(target, lbuf, sizeof(lbuf)-1)) != -1)
		lbuf[n] = '\0';
	else {
		error("%s: readlink failed", target);
		err();
	}
	(void) snprintf(tbuf, sizeof(tbuf), "%.*s", (int) stb->st_size, lbuf);
	ENCODE(ername, tbuf);
	(void) sendcmd(C_NONE, "%s\n", ername);

	if (n != stb->st_size) {
		error("%s: file changed size", target);
		err();
	} else
		ack();

	/*
	 * Check response
	 */
	f = response();
	if (f < 0)
		return(-1);
	else if (f == 0 && IS_ON(opts, DO_COMPARE))
		return(0);

	/*
	 * Read and process responses from server.
	 * The server may send multiple messages regarding
	 * file deletes if the remote target is a directory.
	 */
	for (;;) {
		n = remline(s = respbuff, sizeof(respbuff), TRUE);
		if (n == -1)	/* normal EOF */
			return(0);
		if (n == 0) {
			error("expected control record");
			continue;
		}
		
		switch (*s++) {
		case C_END:	/* End of send operation */
			*ptarget = CNULL;
			ack();
			runspecial(target, opts, rname, destdir);
			addcmdspecialfile(target, rname, destdir);
			return(0);
			
		case C_LOGMSG:
			if (n > 0)
				message(MT_INFO, "%s", s);
			break;

		case C_NOTEMSG:
			if (n > 0)
				message(MT_NOTICE, "%s", s);
			break;
			/* Goto top of loop */

		case C_ERRMSG:
			message(MT_NERROR, "%s", s);
			return(-1);

		case C_FERRMSG:
			message(MT_FERROR, "%s", s);
			finish();

		default:
			error("install link: unexpected response '%s'", 
			      respbuff);
			err();
		}
	}
	/*NOTREACHED*/
}

/*
 * Check to see if file needs to be updated on the remote machine.
 * Returns:
 * 	US_NOTHING	- no update
 *	US_NOENT	- remote doesn't exist
 *	US_OUTDATE	- out of date
 *	US_DOCOMP	- comparing binaries to determine if out of date
 *	US_CHMOG	- File modes or ownership do not match
 */
static int
update(char *rname, opt_t opts, struct stat *statp)
{
	off_t size;
	time_t mtime;
	unsigned short lmode;
	unsigned short rmode;
	char *owner = NULL, *group = NULL;
	int done, n;
	u_char *cp;
	char ername[PATH_MAX*4];

	debugmsg(DM_CALL, "update(%s, %#x, %p)\n", rname, opts, statp);

	switch (statp->st_mode & S_IFMT) {
	case S_IFBLK:
		debugmsg(DM_MISC, "%s is a block special; skipping\n", target);
		return(US_NOTHING);
	case S_IFCHR:
		debugmsg(DM_MISC, "%s is a character special; skipping\n",
		    target);
		return(US_NOTHING);
	case S_IFIFO:
		debugmsg(DM_MISC, "%s is a fifo; skipping\n", target);
		return(US_NOTHING);
	case S_IFSOCK:
		debugmsg(DM_MISC, "%s is a socket; skipping\n", target);
		return(US_NOTHING);
	}

	if (IS_ON(opts, DO_NOEXEC))
		if (isexec(target, statp)) {
			debugmsg(DM_MISC, "%s is an executable\n", target);
			return(US_NOTHING);
		}

	/*
	 * Check to see if the file exists on the remote machine.
	 */
	ENCODE(ername, rname);
	(void) sendcmd(C_QUERY, "%s", ername);

	for (done = 0; !done;) {
		n = remline(cp = respbuff, sizeof(respbuff), TRUE);
		if (n <= 0) {
			error("update: unexpected control record in response to query");
			return(US_NOTHING);
		}

		switch (*cp++) {
		case QC_ONNFS:  /* Resides on a NFS */
			debugmsg(DM_MISC,
				 "update: %s is on a NFS.  Skipping...\n", 
				 rname);
			return(US_NOTHING);

		case QC_SYM:  /* Is a symbolic link */
			debugmsg(DM_MISC,
				 "update: %s is a symlink.  Skipping...\n", 
				 rname);
			return(US_NOTHING);

		case QC_ONRO:  /* Resides on a Read-Only fs */
			debugmsg(DM_MISC,
				 "update: %s is on a RO fs.  Skipping...\n", 
				 rname);
			return(US_NOTHING);
			
		case QC_YES:
			done = 1;
			break;

		case QC_NO:  /* file doesn't exist so install it */
			return(US_NOENT);

		case C_ERRMSG:
			if (cp)
				message(MT_NERROR, "%s", cp);
			return(US_NOTHING);

		case C_FERRMSG:
			if (cp)
				message(MT_FERROR, "%s", cp);
			finish();

		case C_NOTEMSG:
			if (cp)
				message(MT_NOTICE, "%s", cp);
			break;
			/* Goto top of loop */

		default:
			error("update: unexpected response to query '%s'", respbuff);
			return(US_NOTHING);
		}
	}

	/*
	 * Target exists, but no other info passed
	 */
	if (n <= 1 || !S_ISREG(statp->st_mode))
		return(US_OUTDATE);

	if (IS_ON(opts, DO_COMPARE))
		return(US_DOCOMP);

	/*
	 * Parse size
	 */
	size = (off_t) strtoll(cp, (char **)&cp, 10);
	if (*cp++ != ' ') {
		error("update: size not delimited");
		return(US_NOTHING);
	}

	/*
	 * Parse mtime
	 */
	mtime = strtol(cp, (char **)&cp, 10);
	if (*cp++ != ' ') {
		error("update: mtime not delimited");
		return(US_NOTHING);
	}

	/*
	 * Parse remote file mode
	 */
	rmode = strtol(cp, (char **)&cp, 8);
	if (cp && *cp)
		++cp;

	/*
	 * Be backwards compatible
	 */
	if (cp && *cp != CNULL) {
		/*
		 * Parse remote file owner
		 */
		owner = strtok((char *)cp, " ");
		if (owner == NULL) {
			error("update: owner not delimited");
			return(US_NOTHING);
		}

		/*
		 * Parse remote file group
		 */
		group = strtok(NULL, " ");
		if (group == NULL) {
			error("update: group not delimited");
			return(US_NOTHING);
		}
	}

	/*
	 * File needs to be updated?
	 */
	lmode = statp->st_mode & 07777;

	debugmsg(DM_MISC, "update(%s,) local mode %#04o remote mode %#04o\n", 
		 rname, lmode, rmode);
	debugmsg(DM_MISC, "update(%s,) size %lld mtime %lld owner '%s' grp '%s'"
		 "\n", rname, (long long) size, (long long)mtime, owner, group);

	if (statp->st_mtime != mtime) {
		if (statp->st_mtime < mtime && IS_ON(opts, DO_YOUNGER)) {
			message(MT_WARNING, 
				"%s: Warning: remote copy is newer",
				target);
			return(US_NOTHING);
		}
		return(US_OUTDATE);
	}

	if (statp->st_size != size) {
		debugmsg(DM_MISC, "size does not match (%lld != %lld).\n",
			 (long long) statp->st_size, (long long) size);
		return(US_OUTDATE);
	} 

	if (!IS_ON(opts, DO_NOCHKMODE) && lmode != rmode) {
		debugmsg(DM_MISC, "modes do not match (%#04o != %#04o).\n",
			 lmode, rmode);
		return(US_CHMOG);
	}


	/*
	 * Check ownership
	 */
	if (!IS_ON(opts, DO_NOCHKOWNER) && owner) {
		if (!IS_ON(opts, DO_NUMCHKOWNER)) {
			/* Check by string compare */
			if (strcmp(owner, getusername(statp->st_uid, 
						      target, opts)) != 0) {
				debugmsg(DM_MISC, 
					 "owner does not match (%s != %s).\n",
					 getusername(statp->st_uid, 
						     target, opts), owner);
				return(US_CHMOG);
			}
		} else {
			/* 
			 * Check numerically.
			 * Allow negative numbers.
			 */
			while (*owner && !isdigit((unsigned char)*owner) &&
			    (*owner != '-'))
				++owner;
			if (owner && (uid_t)atoi(owner) != statp->st_uid) {
				debugmsg(DM_MISC, 
					 "owner does not match (%d != %s).\n",
					 statp->st_uid, owner);
				return(US_CHMOG);
			}
		}
	} 

	if (!IS_ON(opts, DO_NOCHKGROUP) && group) {
		if (!IS_ON(opts, DO_NUMCHKGROUP)) {
			/* Check by string compare */
			if (strcmp(group, getgroupname(statp->st_gid, 
						       target, opts)) != 0) {
				debugmsg(DM_MISC, 
					 "group does not match (%s != %s).\n",
					 getgroupname(statp->st_gid, 
						      target, opts), group);
				return(US_CHMOG);
			}
		} else {	
			/* Check numerically */
			/* Allow negative gid */
			while (*group && !isdigit((unsigned char) *group) &&
			    (*group != '-'))
				++group;
			if (group && (gid_t)atoi(group) != statp->st_gid) {
				debugmsg(DM_MISC,
					 "group does not match (%d != %s).\n",
					 statp->st_gid, group);
				return(US_CHMOG);
			}
		}
	}

	return(US_NOTHING);
}

/*
 * Stat a file
 */
static int
dostat(char *file, struct stat *statbuf, opt_t opts)
{
	int s;

	if (IS_ON(opts, DO_FOLLOW))
		s = stat(file, statbuf);
	else
		s = lstat(file, statbuf);

	if (s < 0)
		error("%s: %s failed: %s", file,
		      IS_ON(opts, DO_FOLLOW) ? "stat" : "lstat", SYSERR);
	return(s);
}

/*
 * We need to just change file info.
 */
static int
statupdate(int u, char *starget, opt_t opts, char *rname, int destdir,
	   struct stat *st, char *user, char *group)
{
	int rv = 0;
	char ername[PATH_MAX*4];
	int lmode = st->st_mode & 07777;

	if (u == US_CHMOG) {
		if (IS_ON(opts, DO_VERIFY)) {
			message(MT_INFO,
				"%s: need to change to perm %#04o, owner %s, group %s",
				starget, lmode, user, group);
			runspecial(starget, opts, rname, destdir);
		}
		else {
			message(MT_CHANGE, "%s: change to perm %#04o, owner %s, group %s", 
				starget, lmode, user, group);
			ENCODE(ername, rname);
			(void) sendcmd(C_CHMOG, "%o %04o %s %s %s",
				       opts, lmode, user, group, ername);
			(void) response();
		}
		rv = 1;
	}
	return(rv);
}


/*
 * We need to install/update:
 */
static int
fullupdate(int u, char *starget, opt_t opts, char *rname, int destdir,
	   struct stat *st, char *user, char *group)
{
	/*
	 * No entry - need to install
	 */
	if (u == US_NOENT) {
		if (IS_ON(opts, DO_VERIFY)) {
			message(MT_INFO, "%s: need to install", starget);
			runspecial(starget, opts, rname, destdir);
			return(1);
		}
		if (!IS_ON(opts, DO_QUIET))
			message(MT_CHANGE, "%s: installing", starget);
		FLAG_OFF(opts, (DO_COMPARE|DO_REMOVE));
	}

	/*
	 * Handle special file types, including directories and symlinks
	 */
	if (S_ISDIR(st->st_mode)) {
		if (senddir(rname, opts, st, user, group, destdir) > 0)
			return(1);
		return(0);
	} else if (S_ISLNK(st->st_mode)) {
		if (u == US_NOENT)
			FLAG_ON(opts, DO_COMPARE);
		/*
		 * Since we always send link info to the server
		 * so the server can determine if the remote link
		 * is correct, we never get any acknowledgement
		 * from the server whether the link was really
		 * updated or not.
		 */
		(void) sendlink(rname, opts, st, user, group, destdir);
		return(0);
	} else if (S_ISREG(st->st_mode)) {		
		if (u == US_OUTDATE) {
			if (IS_ON(opts, DO_VERIFY)) {
				message(MT_INFO, "%s: need to update", starget);
				runspecial(starget, opts, rname, destdir);
				return(1);
			}
			if (!IS_ON(opts, DO_QUIET))
				message(MT_CHANGE, "%s: updating", starget);
		}
		return (sendfile(rname, opts, st, user, group, destdir) == 0);
	} else {
		message(MT_INFO, "%s: unknown file type %#o", starget,
			st->st_mode);
		return(0);
	}
}

/*
 * Transfer the file or directory in target[].
 * rname is the name of the file on the remote host.
 *
 * Return < 0 on error.
 * Return 0 if nothing happened.
 * Return > 0 if anything is updated.
 */
static int
sendit(char *rname, opt_t opts, int destdir)
{
	static struct stat stb;
	char *user, *group;
	int u, len;

	/*
	 * Remove possible accidental newline
	 */
	len = strlen(rname);
	if (len > 0 && rname[len-1] == '\n')
		rname[len-1] = CNULL;

	if (checkfilename(rname) != 0)
		return(-1);

	debugmsg(DM_CALL, "sendit(%s, %#x) called\n", rname, opts);

	if (except(target))
		return(0);

	if (dostat(target, &stb, opts) < 0)
		return(-1);

	/*
	 * Does rname need updating?
	 */
	u = update(rname, opts, &stb);
	debugmsg(DM_MISC, "sendit(%s, %#x): update status of %s is %d\n", 
		 rname, opts, target, u);

	/*
	 * Don't need to update the file, but we may need to save hardlink
	 * info.
	 */
	if (u == US_NOTHING) {
		if (S_ISREG(stb.st_mode) && stb.st_nlink > 1)
			(void) linkinfo(&stb);
		return(0);
	}

	user = getusername(stb.st_uid, target, opts);
	group = getgroupname(stb.st_gid, target, opts);

	if (u == US_CHMOG && IS_OFF(opts, DO_UPDATEPERM))
		u = US_OUTDATE;

	if (u == US_NOENT || u == US_OUTDATE || u == US_DOCOMP)
		return(fullupdate(u, target, opts, rname, destdir, &stb,
				  user, group));

	if (u == US_CHMOG)
		return(statupdate(u, target, opts, rname, destdir, &stb,
				  user, group));

	return(0);
}
	
/*
 * Remove temporary files and do any cleanup operations before exiting.
 */
void
cleanup(int dummy)
{
	char *file;

	if ((file = getnotifyfile()) != NULL)
		(void) unlink(file);
}

/*
 * Update the file(s) if they are different.
 * destdir = 1 if destination should be a directory
 * (i.e., more than one source is being copied to the same destination).
 *
 * Return < 0 on error.
 * Return 0 if nothing updated.
 * Return > 0 if something was updated.
 */
int
install(char *src, char *dest, int ddir, int destdir, opt_t opts)
{
	static char destcopy[PATH_MAX];
	char *rname;
	int didupdate = 0;
	char ername[PATH_MAX*4];

	debugmsg(DM_CALL,
		"install(src=%s,dest=%s,ddir=%d,destdir=%d,opts=%#x) start\n",
		(src?src:"NULL"), (dest?dest:"NULL"), ddir, destdir, opts);
	/*
	 * Save source name
	 */
	if (IS_ON(opts, DO_WHOLE))
		source[0] = CNULL;
	else
		(void) strlcpy(source, src, sizeof(source));

	if (dest == NULL) {
		FLAG_OFF(opts, DO_WHOLE); /* WHOLE only useful if renaming */
		dest = src;
	}

	if (checkfilename(dest) != 0)
		return(-1);

	if (nflag || debug) {
		static char buff[BUFSIZ];
		char *cp;

		cp = getondistoptlist(opts);
		(void) snprintf(buff, sizeof(buff), "%s%s%s %s %s", 
			       IS_ON(opts, DO_VERIFY) ? "verify" : "install",
			       (cp) ? " -o" : "", (cp) ? cp : "", 
			       src, dest);
		if (nflag) {
			printf("%s\n", buff);
			return(0);
		} else
			debugmsg(DM_MISC, "%s\n", buff);
	}

	rname = exptilde(target, src, sizeof(target));
	if (rname == NULL)
		return(-1);
	ptarget = target;
	while (*ptarget)
		ptarget++;
	/*
	 * If we are renaming a directory and we want to preserve
	 * the directory hierarchy (-w), we must strip off the leading
	 * directory name and preserve the rest.
	 */
	if (IS_ON(opts, DO_WHOLE)) {
		while (*rname == '/')
			rname++;
		ddir = 1;
		destdir = 1;
	} else {
		rname = strrchr(target, '/');
		/* Check if no '/' or target ends in '/' */
		if (rname == NULL || 
		    rname+1 == NULL || 
		    *(rname+1) == CNULL)
			rname = target;
		else
			rname++;
	}

	debugmsg(DM_MISC, 
 	"install: target=%s src=%s rname=%s dest='%s' destdir=%d, ddir=%d\n", 
 		 target, source, rname, dest, destdir, ddir);

	/*
	 * Pass the destination file/directory name to remote.
	 */
	ENCODE(ername, dest);
 	if (ddir)
		(void) sendcmd(C_DIRTARGET, "%o %s", opts, ername);
	else
		(void) sendcmd(C_TARGET, "%o %s", opts, ername);
	if (response() < 0)
		return(-1);

	/*
	 * Save the name of the remote target destination if we are
	 * in WHOLE mode (destdir > 0) or if the source and destination
	 * are not the same.  This info will be used later for maintaining
	 * hardlink info.
	 */
	if (destdir || (src && dest && strcmp(src, dest))) {
		(void) strlcpy(destcopy, dest, sizeof(destcopy));
		Tdest = destcopy;
	}

	didupdate = sendit(rname, opts, destdir);
	Tdest = 0;

	return(didupdate);
}
@


1.34
log
@Reduce opt_t from long to int.
Debug message consistency: format opts with %#x and modes with %#04o
@
text
@d1 1
a1 1
/*	$OpenBSD: client.c,v 1.33 2015/01/20 09:00:16 guenther Exp $	*/
d308 3
a310 6
	if (lp->pathname)
		free(lp->pathname);
	if (lp->src)
		free(lp->src);
	if (lp->target)
		free(lp->target);
@


1.33
log
@Split out from rdist/defs.h the client-only and server-only bits into
 rdist/client.h and rdistd/server.h
Only put #includes in .h files that are necessary for the .h to be used;
 all other #includes go in the .c files
Move all extern variable declarations to the .h files, renaming local
 variables to avoid shadowing
Replace me_type member of mntent_t with an "is NFS?" flag bit
@
text
@d1 1
a1 1
/*	$OpenBSD: client.c,v 1.32 2015/01/16 06:40:11 deraadt Exp $	*/
d374 1
a374 2
	(void) sendcmd(C_RECVHARDLINK, "%lo %s %s", 
		       opts, elname, ername);
d407 1
a407 1
	(void) sendcmd(C_RECVREG, "%lo %04o %lld %lld %lld %s %s %s", 
d596 1
a596 1
	(void) sendcmd(C_RECVDIR, "%lo %04o 0 0 0 %s %s %s", 
d666 1
a666 1
	debugmsg(DM_CALL, "sendlink(%s, %lx, stb, %d)\n", rname, opts, destdir);
d679 1
a679 1
	(void) sendcmd(C_RECVSYMLINK, "%lo %04o %lld %lld %lld %s %s %s", 
d785 1
a785 1
	debugmsg(DM_CALL, "update(%s, 0x%lx, %p)\n", rname, opts, statp);
d932 1
a932 1
	debugmsg(DM_MISC, "update(%s,) local mode %04o remote mode %04o\n", 
d954 1
a954 1
		debugmsg(DM_MISC, "modes do not match (%04o != %04o).\n",
d1053 1
a1053 1
				"%s: need to change to perm %04o, owner %s, group %s",
d1058 1
a1058 1
			message(MT_CHANGE, "%s: change to perm %04o, owner %s, group %s", 
d1061 1
a1061 1
			(void) sendcmd(C_CHMOG, "%lo %04o %s %s %s",
d1123 1
a1123 1
		message(MT_INFO, "%s: unknown file type 0%o", starget,
d1154 1
a1154 1
	debugmsg(DM_CALL, "sendit(%s, 0x%lx) called\n", rname, opts);
d1166 1
a1166 1
	debugmsg(DM_MISC, "sendit(%s, 0x%lx): update status of %s is %d\n", 
d1226 1
a1226 1
		"install(src=%s,dest=%s,ddir=%d,destdir=%d,opts=%ld) start\n",
d1296 1
a1296 1
		(void) sendcmd(C_DIRTARGET, "%lo %s", opts, ername);
d1298 1
a1298 1
		(void) sendcmd(C_TARGET, "%lo %s", opts, ername);
@


1.32
log
@Replace <sys/param.h> with <limits.h> and other less dirty headers where
possible.  Annotate <sys/param.h> lines with their current reasons.  Switch
to PATH_MAX, NGROUPS_MAX, HOST_NAME_MAX+1, LOGIN_NAME_MAX, etc.  Change
MIN() and MAX() to local definitions of MINIMUM() and MAXIMUM() where
sensible to avoid pulling in the pollution.  These are the files confirmed
through binary verification.
ok guenther, millert, doug (helped with the verification protocol)
@
text
@d1 1
a1 1
/*	$OpenBSD: client.c,v 1.31 2014/07/12 03:48:04 guenther Exp $	*/
d32 1
d34 6
d41 1
a41 1
#include "defs.h"
a87 1
	extern struct namelist *filelist;
a165 1
	extern struct subcmd *subcmds;
a199 1
	extern struct subcmd *subcmds;
@


1.31
log
@The statdb code has never been complete here
@
text
@d1 1
a1 1
/*	$OpenBSD: client.c,v 1.30 2014/07/12 03:07:22 guenther Exp $	*/
d350 1
a350 1
	static char buff[MAXPATHLEN];
d352 1
a352 1
	char ername[MAXPATHLEN*4], elname[MAXPATHLEN*4];
d385 1
a385 1
	char ername[MAXPATHLEN*4];
d495 1
a495 1
	char targ[MAXPATHLEN*4];
d587 1
a587 1
	char ername[MAXPATHLEN*4];
d623 1
a623 1
		if (len + 1 + (int) strlen(dp->d_name) >= MAXPATHLEN - 1) {
d659 1
a659 1
	char lbuf[MAXPATHLEN];
d661 1
a661 1
	char ername[MAXPATHLEN*4];
d780 1
a780 1
	char ername[MAXPATHLEN*4];
d1044 1
a1044 1
	char ername[MAXPATHLEN*4];
d1217 1
a1217 1
	static char destcopy[MAXPATHLEN];
d1220 1
a1220 1
	char ername[MAXPATHLEN*4];
@


1.30
log
@Eliminate some annoying variable shadowing
@
text
@d1 1
a1 1
/*	$OpenBSD: client.c,v 1.29 2014/07/05 06:55:29 guenther Exp $	*/
a1199 5
#ifdef USE_STATDB
	extern char statfile[];

	(void) unlink(statfile);
#endif
@


1.29
log
@Assume POSIX: uid_t and gid_t
@
text
@d1 1
a1 1
/*	$OpenBSD: client.c,v 1.28 2014/07/05 06:45:00 guenther Exp $	*/
d1040 1
a1040 1
statupdate(int u, char *target, opt_t opts, char *rname, int destdir,
d1051 2
a1052 2
				target, lmode, user, group);
			runspecial(target, opts, rname, destdir);
d1056 1
a1056 1
				target, lmode, user, group);
d1072 1
a1072 1
fullupdate(int u, char *target, opt_t opts, char *rname, int destdir,
d1080 2
a1081 2
			message(MT_INFO, "%s: need to install", target);
			runspecial(target, opts, rname, destdir);
d1085 1
a1085 1
			message(MT_CHANGE, "%s: installing", target);
d1111 2
a1112 2
				message(MT_INFO, "%s: need to update", target);
				runspecial(target, opts, rname, destdir);
d1116 1
a1116 1
				message(MT_CHANGE, "%s: updating", target);
d1120 1
a1120 1
		message(MT_INFO, "%s: unknown file type 0%o", target,
@


1.28
log
@Assume POSIX: <dirent.h>, struct dirent
@
text
@d1 1
a1 1
/*	$OpenBSD: client.c,v 1.27 2014/07/05 05:05:51 guenther Exp $	*/
d979 1
a979 1
			if (owner && (UID_T) atoi(owner) != statp->st_uid) {
d1005 1
a1005 1
			if (group && (UID_T) atoi(group) != statp->st_gid) {
@


1.27
log
@Use void* in malloc/realloc/calloc wrappers
@
text
@d1 1
a1 1
/*	$OpenBSD: client.c,v 1.26 2013/08/18 16:32:24 guenther Exp $	*/
d32 2
d582 1
a582 1
	DIRENTRY *dp;
@


1.26
log
@Fix calls to printf-like functions which passed a non-fixed string
as the format and no variable args.
Replace "%#0.*X" with "%#.*X": the zero-fill flag is ignored/implied
on numeric conversions when a precision is specified.

ok jung@@ millert@@ krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: client.c,v 1.25 2012/11/12 01:18:37 guenther Exp $	*/
d207 1
a207 1
		new = (struct namelist *) xmalloc(sizeof(struct namelist));
d326 1
a326 1
	lp = (struct linkbuf *) xmalloc(sizeof(*lp));
@


1.25
log
@Once a C_RECVDIR command is sent, a matching C_END command has to be
sent later, even if the opendir() fails or the nodescend option is set.

ok krw@@, ian@@
@
text
@d1 1
a1 1
/*	$OpenBSD: client.c,v 1.24 2012/11/12 01:14:41 guenther Exp $	*/
d259 1
a259 1
			(void) sendcmd(RC_FILE, f->n_name);
d270 1
a270 1
		(void) sendcmd(RC_COMMAND, sc->sc_name);
@


1.24
log
@Fix various format string issues.  Stop assuming time_t is long or smaller.
Enable warnings.

ok krw@@, ian@@
@
text
@d1 1
a1 1
/*	$OpenBSD: client.c,v 1.23 2011/04/10 15:47:28 krw Exp $	*/
d596 2
d601 2
a602 1
	if (IS_ON(opts, DO_NODESCEND))
d604 1
d612 2
a613 1
		return(-1);
a615 1
	optarget = ptarget;
d638 1
@


1.23
log
@Apply some tough type-love and give rdist a chance to handle files
larger than 2GB. Diff from Stephan R. Gerber via PR#6586, tweaks
by me.

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: client.c,v 1.22 2009/10/27 23:59:42 deraadt Exp $	*/
d368 1
a368 1
	(void) sendcmd(C_RECVHARDLINK, "%o %s %s", 
d402 1
a402 1
	(void) sendcmd(C_RECVREG, "%o %04o %lld %ld %ld %s %s %s", 
d404 1
a404 1
		       stb->st_mtime, stb->st_atime,
d591 1
a591 1
	(void) sendcmd(C_RECVDIR, "%o %04o 0 0 0 %s %s %s", 
d600 1
a600 1
		return(0);
d656 1
a656 1
	debugmsg(DM_CALL, "sendlink(%s, %x, stb, %d)\n", rname, opts, destdir);
d669 1
a669 1
	(void) sendcmd(C_RECVSYMLINK, "%o %04o %lld %ld %ld %s %s %s", 
d671 1
a671 1
		       stb->st_mtime, stb->st_atime,
d775 1
a775 1
	debugmsg(DM_CALL, "update(%s, 0x%x, 0x%x)\n", rname, opts, statp);
d924 2
a925 2
	debugmsg(DM_MISC, "update(%s,) size %lld mtime %d owner '%s' grp '%s'"
		 "\n", rname, (long long) size, mtime, owner, group);
d1051 1
a1051 1
			(void) sendcmd(C_CHMOG, "%o %04o %s %s %s",
d1144 1
a1144 1
	debugmsg(DM_CALL, "sendit(%s, 0x%x) called\n", rname, opts);
d1156 1
a1156 1
	debugmsg(DM_MISC, "sendit(%s, 0x%x): update status of %s is %d\n", 
d1221 1
a1221 1
		"install(src=%s,dest=%s,ddir=%d,destdir=%d,opts=%d) start\n",
d1291 1
a1291 1
		(void) sendcmd(C_DIRTARGET, "%o %s", opts, ername);
d1293 1
a1293 1
		(void) sendcmd(C_TARGET, "%o %s", opts, ername);
@


1.22
log
@rcsid[] and sccsid[] and copyright[] are essentially unmaintained (and
unmaintainable).  these days, people use source.  these id's do not provide
any benefit, and do hurt the small install media
(the 33,000 line diff is essentially mechanical)
ok with the idea millert, ok dms
@
text
@d1 1
a1 1
/*	$OpenBSD: client.c,v 1.21 2009/02/15 22:20:54 deraadt Exp $	*/
d402 2
a403 2
	(void) sendcmd(C_RECVREG, "%o %04o %ld %ld %ld %s %s %s", 
		       opts, stb->st_mode & 07777, (long) stb->st_size, 
d412 2
a413 2
	debugmsg(DM_MISC, "Send file '%s' %ld bytes\n", rname,
		 (long) stb->st_size);
d669 2
a670 2
	(void) sendcmd(C_RECVSYMLINK, "%o %04o %ld %ld %ld %s %s %s", 
		       opts, stb->st_mode & 07777, (long) stb->st_size, 
d872 1
a872 1
	size = (off_t) strtol(cp, (char **)&cp, 10);
d924 2
a925 2
	debugmsg(DM_MISC, "update(%s,) size %ld mtime %d owner '%s' grp '%s'\n",
		 rname, (long) size, mtime, owner, group);
d938 2
a939 2
		debugmsg(DM_MISC, "size does not match (%ld != %ld).\n",
			 (long) statp->st_size, (long) size);
@


1.21
log
@make rdist silently ignore special file types which cannot be moved
(well, if you turn on debug it will still tell you)
from Tim van der Molen <tbvdm@@xs4all.nl
@
text
@d1 1
a1 1
/*	$OpenBSD: client.c,v 1.20 2004/10/04 05:21:27 jsg Exp $	*/
a33 17

#ifndef lint
#if 0
static char RCSid[] __attribute__((__unused__)) = 
"$From: client.c,v 1.13 1999/11/01 00:22:14 christos Exp $";
#else
static char RCSid[] __attribute__((__unused__)) = 
"$OpenBSD: client.c,v 1.20 2004/10/04 05:21:27 jsg Exp $";
#endif

static char sccsid[] __attribute__((__unused__)) =
"@@(#)client.c";

static char copyright[] __attribute__((__unused__)) =
"@@(#) Copyright (c) 1983 Regents of the University of California.\n\
 All rights reserved.\n";
#endif /* not lint */
@


1.20
log
@hierarchy is spelt hierarchy, ok djm@@
@
text
@d1 1
a1 1
/*	$OpenBSD: client.c,v 1.19 2003/06/03 02:56:14 millert Exp $	*/
d41 1
a41 1
"$OpenBSD: client.c,v 1.19 2003/06/03 02:56:14 millert Exp $";
d794 16
d1112 1
a1112 1
		 * is correct, we never get any acknowledge meant
@


1.19
log
@Remove the advertising clause in the UCB license which Berkeley
rescinded 22 July 1999.  Proofed by myself and Theo.
@
text
@d1 1
a1 1
/*	$OpenBSD: client.c,v 1.18 2003/05/14 01:34:35 millert Exp $	*/
d41 1
a41 1
"$OpenBSD: client.c,v 1.18 2003/05/14 01:34:35 millert Exp $";
d1264 1
a1264 1
	 * the directory heirarchy (-w), we must strip off the leading
@


1.18
log
@ o Sync w/ freerdist 0.92 minus the compress option
 o KNF and ANSIfy the function headers

Sparse file support is currently a no-op since it didn't work.
Proper sparse file support will be added later.
@
text
@d1 1
a1 1
/*	$OpenBSD: client.c,v 1.17 2003/05/06 22:10:11 millert Exp $	*/
d15 1
a15 5
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
d41 1
a41 1
"$OpenBSD: client.c,v 1.17 2003/05/06 22:10:11 millert Exp $";
@


1.17
log
@use POSIX regex
@
text
@d1 1
a1 1
/*	$OpenBSD: client.c,v 1.16 2003/04/19 17:22:29 millert Exp $	*/
d36 3
d41 2
a42 2
static char RCSid[] = 
"$From: client.c,v 6.80 1996/02/28 20:34:27 mcooper Exp $";
d44 2
a45 2
static char RCSid[] = 
"$OpenBSD: client.c,v 1.16 2003/04/19 17:22:29 millert Exp $";
d48 2
a49 1
static char sccsid[] = "@@(#)client.c";
d51 1
a51 1
static char copyright[] =
a59 2
#include "defs.h"
#include "y.tab.h"
d68 1
a68 1
#define US_MODE		4	/* Modes of file differ */
d79 14
a92 1
static int sendit();
d97 2
a98 3
char *remfilename(src, dest, path, rname, destdir)
	char *src, *dest, *path, *rname;
	int destdir;
d126 1
a126 1
			(void) snprintf(buff, sizeof buff, "%s/%s", dest, path);
d144 2
a145 2
				(void) snprintf(buff, sizeof buff,
				    "%s/%s", dest, cp);
d147 2
a148 2
				(void) snprintf(buff, sizeof buff,
				    "%s%s", dest, cp);
d151 1
a151 1
		strlcpy(lname, dest, buf + sizeof buff - lname);
d161 2
a162 3
int inlist(list, file)
	struct namelist *list;
	char *file;
d175 2
a176 5
static void runspecial(starget, opts, rname, destdir)
	char *starget;
	opt_t opts;
	char *rname;
	int destdir;
d208 2
a209 4
static void addcmdspecialfile(starget, rname, destdir)
	char *starget;
	char *rname;
	int destdir;
d239 2
a240 1
static void freecmdspecialfiles()
d259 2
a260 4
extern void runcmdspecial(cmd, filev, opts)
	struct cmd *cmd;
	char **filev;
	opt_t opts;
d302 2
a303 2
int checkfilename(name)
	char *name;
d320 2
a321 2
void freelinkinfo(lp)
	struct linkbuf *lp;
d335 2
a336 2
static struct linkbuf *linkinfo(statp)
	struct stat *statp;
d366 2
a367 5
static int sendhardlink(opts, lp, rname, destdir)
	opt_t opts;
	struct linkbuf *lp;
	char *rname;
	int destdir;
d370 2
d375 2
a376 2
		 rname, lp->pathname ? lp->pathname : "(null)", lp->src
		 ? lp->src : "(null)", lp->target ? lp->target : "(null)");
d379 1
a379 2
		(void) sendcmd(C_RECVHARDLINK, "%o %s %s", 
			       opts, lp->pathname, rname);
d381 10
a390 6
		strlcpy(buff, remfilename(lp->src, lp->target, 
		    lp->pathname, rname, destdir), sizeof buff);
		debugmsg(DM_MISC, "sendhardlink: lname=%s\n", buff);
		(void) sendcmd(C_RECVHARDLINK, "%o %s %s", 
			       opts, buff, rname);
	}
d398 3
a400 6
static int sendfile(rname, opts, stb, user, group, destdir)
	char *rname;
	opt_t opts;
	struct stat *stb;
	char *user, *group;
	int destdir;
d404 1
d421 2
d424 1
a424 2
		       opts, stb->st_mode & 07777, 
		       (long) stb->st_size, 
d426 1
a426 1
		       user, group, rname);
d432 3
a434 2
	debugmsg(DM_MISC, "Send file '%s' %d bytes\n", 
		 rname, (long) stb->st_size);
d446 1
a446 1
		int amt = BUFSIZ;
d451 1
a451 1
		if (read(f, buf, amt) != amt) {
d463 2
a464 2
		if (xwrite(rem_w, buf, amt) < 0) {
		    	error("%s: Error writing to client: %s", 
d507 2
a508 2
static int rmchk(opts)
	opt_t opts;
d514 1
d539 9
a547 2
			snprintf(ptarget, target + sizeof(target) - ptarget,
			    "%s%s", (ptarget[-1] == '/' ? "" : "/"), s);
d597 3
a599 6
static int senddir(rname, opts, stb, user, group, destdir)
	char *rname;
	opt_t opts;
	struct stat *stb;
	char *user, *group;
	int destdir;
d606 10
d623 4
a631 12
	/*
	 * Send recvdir command in recvit() format.
	 */
	(void) sendcmd(C_RECVDIR, "%o %04o 0 0 0 %s %s %s", 
		       opts, stb->st_mode & 07777, user, group, rname);
	if (response() < 0)
		return(-1);

	if (IS_ON(opts, DO_REMOVE))
		if (rmchk(opts) > 0)
			++didupdate;
	
d634 1
a634 1
	while ((dp = readdir(d))) {
d647 2
a648 2
		while ((*ptarget++ = *cp++))
			;
d667 3
a669 7
static int sendlink(rname, opts, stb, user, group, destdir)
	char *rname;
	opt_t opts;
	struct stat *stb;
	char *user;
	char *group;
	int destdir;
d675 1
d689 1
d691 1
a691 2
		       opts, stb->st_mode & 07777, 
		       (long) stb->st_size, 
d693 1
a693 1
		       user, group, rname);
d706 3
a708 2
	(void) snprintf(tbuf, sizeof tbuf, "%.*s", (int) stb->st_size, lbuf);
	(void) sendcmd(C_NONE, "%s\n", tbuf);
d782 1
a782 1
 *	US_MODE		- File modes do not match
d784 2
a785 4
static int update(rname, opts, statp)
	char *rname;
	opt_t opts;
	struct stat *statp;
d794 1
d807 2
a808 1
	(void) sendcmd(C_QUERY, "%s", rname);
d860 1
a860 1
			error("update: unexpected response to query '%s'", cp);
d877 1
a877 1
	size = strtol(cp, (char **)&cp, 10);
d929 2
a930 2
	debugmsg(DM_MISC, "update(%s,) size %d mtime %d owner '%s' grp '%s'\n",
		 rname, (int) size, mtime, owner, group);
d942 6
a947 7
	/*
	 * If the mode of a file does not match the local mode, the
	 * whole file is updated.  This is done both to insure that
	 * a bogus version of the file has not been installed and to
	 * avoid having to handle weird cases of chmod'ing symlinks 
	 * and such.
	 */
d951 1
a951 1
		return(US_OUTDATE);
a953 5
	if (statp->st_size != size) {
		debugmsg(DM_MISC, "size does not match (%d != %d).\n",
			 (int) statp->st_size, size);
		return(US_OUTDATE);
	} 
d967 1
a967 1
				return(US_OUTDATE);
d974 2
a975 1
			while (*owner && !isdigit(*owner) && (*owner != '-'))
d977 1
a977 1
			if (owner && atoi(owner) != statp->st_uid) {
d981 1
a981 1
				return(US_OUTDATE);
d995 1
a995 1
				return(US_OUTDATE);
d1000 2
a1001 1
			while (*group && !isdigit(*group) && (*group != '-'))
d1003 1
a1003 1
			if (group && atoi(group) != statp->st_gid) {
d1007 1
a1007 1
				return(US_OUTDATE);
d1018 2
a1019 4
static int dostat(file, statbuf, opts)
	char *file;
	struct stat *statbuf;
	opt_t opts;
d1035 90
d1132 2
a1133 4
static int sendit(rname, opts, destdir)
	char *rname;
	opt_t opts;
	int destdir;
a1135 1
	extern struct subcmd *subcmds;
a1137 1
	int didupdate = 0;
a1173 18
	/*
	 * File mode needs changing
	 */
	if (u == US_MODE) {
		if (IS_ON(opts, DO_VERIFY)) {
			message(MT_INFO, "%s: need to chmod to %04o",
				target, stb.st_mode & 07777);
			runspecial(target, opts, rname, destdir);
			return(1);
		}
		message(MT_CHANGE, "%s: chmod to %04o", 
			target, stb.st_mode & 07777);
		(void) sendcmd(C_CHMOD, "%o %04o %s",
			       opts, stb.st_mode & 07777, rname);
		(void) response();
		return(1);
	}

d1177 2
a1178 13
	/*
	 * No entry - need to install
	 */
	if (u == US_NOENT) {
		if (IS_ON(opts, DO_VERIFY)) {
			message(MT_INFO, "%s: need to install", target);
			runspecial(target, opts, rname, destdir);
			return(1);
		}
		if (!IS_ON(opts, DO_QUIET))
			message(MT_CHANGE, "%s: installing", target);
		FLAG_OFF(opts, (DO_COMPARE|DO_REMOVE));
	}
d1180 7
a1186 31
	/*
	 * Handle special file types, including directories and symlinks
	 */
	if (S_ISDIR(stb.st_mode)) {
		if (senddir(rname, opts, &stb, user, group, destdir) > 0)
			didupdate = 1;
	} else if (S_ISLNK(stb.st_mode)) {
		if (u != US_NOENT)
			FLAG_ON(opts, DO_COMPARE);
		/*
		 * Since we always send link info to the server
		 * so the server can determine if the remote link
		 * is correct, we never get any acknowledge meant
		 * from the server whether the link was really
		 * updated or not.
		 */
		(void) sendlink(rname, opts, &stb, user, group, destdir);
	} else if (S_ISREG(stb.st_mode)) {		
		if (u == US_OUTDATE) {
			if (IS_ON(opts, DO_VERIFY)) {
				message(MT_INFO, "%s: need to update", target);
				runspecial(target, opts, rname, destdir);
				return(1);
			}
			if (!IS_ON(opts, DO_QUIET))
				message(MT_CHANGE, "%s: updating", target);
		}
		if (sendfile(rname, opts, &stb, user, group, destdir) == 0)
			didupdate = 1;
	} else
		error("%s: unknown file type", target);
d1188 1
a1188 1
	return(didupdate);
d1194 2
a1195 1
extern void cleanup()
d1204 1
a1204 1
	if ((file = getnotifyfile()))
d1217 2
a1218 4
extern int install(src, dest, ddir, destdir, opts)
	char *src, *dest;
 	int ddir, destdir;
	opt_t opts;
d1223 1
d1234 1
a1234 1
		(void) strlcpy(source, src, sizeof source);
d1249 1
a1249 1
		(void) snprintf(buff, sizeof buff, "%s%s%s %s %s", 
d1294 1
d1296 1
a1296 1
		(void) sendcmd(C_DIRTARGET, "%o %s", opts, dest);
d1298 1
a1298 1
		(void) sendcmd(C_TARGET, "%o %s", opts, dest);
d1309 1
a1309 1
		(void) strlcpy(destcopy, dest, sizeof destcopy);
@


1.16
log
@strcpy/strcat/sprintf removal; krw@@ OK
@
text
@d1 1
a1 1
/*	$OpenBSD: client.c,v 1.15 2003/04/07 21:13:52 deraadt Exp $	*/
d42 1
a42 1
"$OpenBSD: client.c,v 1.15 2003/04/07 21:13:52 deraadt Exp $";
d222 1
@


1.15
log
@replace strcpy calls that got inlined by gcc; Hans-Joerg.Hoexer@@yerbouti.franken.de
@
text
@d1 1
a1 1
/*	$OpenBSD: client.c,v 1.14 2003/04/05 20:31:58 deraadt Exp $	*/
d42 1
a42 1
"$OpenBSD: client.c,v 1.14 2003/04/05 20:31:58 deraadt Exp $";
d528 2
a529 2
			(void) sprintf(ptarget, "%s%s", 
				       (ptarget[-1] == '/' ? "" : "/"), s);
d1218 1
a1218 1
	rname = exptilde(target, src);
@


1.14
log
@strings; ok miod ho krw
@
text
@d1 1
a1 1
/*	$OpenBSD: client.c,v 1.13 2001/11/19 19:02:15 mpech Exp $	*/
d42 1
a42 1
"$OpenBSD: client.c,v 1.13 2001/11/19 19:02:15 mpech Exp $";
d137 1
a137 1
		strcpy(lname, dest);
a364 1
	char *lname;	/* name of file to link to */
d375 3
a377 5
		lname = buff;
		strcpy(lname, remfilename(lp->src, lp->target, 
					  lp->pathname, rname, 
					  destdir));
		debugmsg(DM_MISC, "sendhardlink: lname=%s\n", lname);
d379 1
a379 1
			       opts, lname, rname);
d1192 1
a1192 1
		(void) strcpy(source, src);
@


1.13
log
@kill more registers

millert@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: client.c,v 1.12 1999/03/05 01:36:12 millert Exp $	*/
d42 1
a42 1
"$OpenBSD: client.c,v 1.12 1999/03/05 01:36:12 millert Exp $";
d112 1
a112 1
			(void) sprintf(buff, "%s/%s", dest, path);
d130 2
a131 1
				(void) sprintf(buff, "%s/%s", dest, cp);
d133 2
a134 1
				(void) sprintf(buff, "%s%s", dest, cp);
d695 1
a695 1
	(void) sprintf(tbuf, "%.*s", (int) stb->st_size, lbuf);
d1210 1
a1210 1
		(void) sprintf(buff, "%s%s%s %s %s", 
d1269 1
a1269 1
		(void) strcpy(destcopy, dest);
@


1.12
log
@make output look more like what BSD pritnf does when it hits a NULL
@
text
@d1 1
a1 1
/*	$OpenBSD: client.c,v 1.11 1999/03/05 01:32:47 millert Exp $	*/
d42 1
a42 1
"$OpenBSD: client.c,v 1.11 1999/03/05 01:32:47 millert Exp $";
d87 1
a87 1
	register char *lname, *cp;
d149 1
a149 1
	register struct namelist *nl;
d166 1
a166 1
	register struct subcmd *sc;
d203 1
a203 1
	register struct subcmd *sc;
d230 1
a230 1
	register struct namelist *ptr, *save;
d252 2
a253 2
	register struct subcmd *sc;
	register struct namelist *f;
d295 1
a295 1
	register char *cp;
d501 1
a501 1
	register u_char *s;
d775 2
a776 2
	register off_t size;
	register time_t mtime;
@


1.11
log
@Don't assume printf will deal gracefully with NULL pointers for %s, BSD does but SysV does not
@
text
@d1 1
a1 1
/*	$OpenBSD: client.c,v 1.10 1999/02/23 21:27:15 millert Exp $	*/
d42 1
a42 1
"$OpenBSD: client.c,v 1.10 1999/02/23 21:27:15 millert Exp $";
d367 2
a368 2
		 rname, lp->pathname ? lp->pathname : "nil",
		 lp->src ? lp->src : "nil", lp->target ? lp->target : "nil");
@


1.10
log
@Check lp->target for NULL, not *lp->target as required by dynamic allocation introduce in rev 1.8
@
text
@d1 1
a1 1
/*	$OpenBSD: client.c,v 1.9 1999/02/06 01:52:23 millert Exp $	*/
d42 1
a42 1
"$OpenBSD: client.c,v 1.9 1999/02/06 01:52:23 millert Exp $";
d367 2
a368 1
		 rname, lp->pathname, lp->src, lp->target);
@


1.9
log
@kill redundant (and incorrect) check for mallco failure
@
text
@d1 1
a1 1
/*	$OpenBSD: client.c,v 1.8 1999/02/04 23:18:57 millert Exp $	*/
d42 1
a42 1
"$OpenBSD: client.c,v 1.8 1999/02/04 23:18:57 millert Exp $";
d369 1
a369 1
	if (*lp->target == CNULL)
@


1.8
log
@Fix a serious memory consumption problem when running over directories
that contain many hard-linked files; johnh@@isi.edu
Also add an xstrdup() that behaves like xmalloc() on failure.
@
text
@d1 1
a1 1
/*	$OpenBSD: client.c,v 1.7 1998/06/26 21:21:00 millert Exp $	*/
d42 1
a42 1
"$OpenBSD: client.c,v 1.7 1998/06/26 21:21:00 millert Exp $";
a348 2
	if (!lp->pathname || !lp->src || !(Tdest && lp->target))
		fatalerr("Cannot malloc memory in linkinfo.");
@


1.7
log
@rdist 6.1.4 + OpenBSD patches + some -Wall
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d42 1
a42 1
"$OpenBSD$";
d219 1
a219 1
		new->n_name = strdup(rfile);
d310 12
d330 1
d343 2
a344 2
	(void) strcpy(lp->pathname, target);
	(void) strcpy(lp->src, source);
d346 1
a346 1
		(void) strcpy(lp->target, Tdest);
d348 3
a350 1
		*lp->target = CNULL;
@


1.6
log
@readlink len-1
@
text
@d1 1
a1 1
/*	$OpenBSD: client.c,v 1.5 1997/07/21 01:53:37 angelos Exp $	*/
d37 1
d39 5
a43 1
"$OpenBSD: client.c,v 1.5 1997/07/21 01:53:37 angelos Exp $";
a253 2
	register char **cpp;
	char *file;
d337 1
a337 1
	return((struct linkbuf *) NULL);
d604 1
a604 1
	while (dp = readdir(d)) {
d617 1
a617 1
		while (*ptarget++ = *cp++)
d645 1
a645 1
	int sizerr, f, n;
d673 6
a678 1
	sizerr = (readlink(target, lbuf, sizeof(lbuf)-1) != stb->st_size);
d682 1
a682 1
	if (sizerr) {
d849 1
a849 1
	size = strtol(cp, (char **) &cp, 10);
d858 1
a858 1
	mtime = strtol(cp, (char **) &cp, 10);
d867 1
a867 1
	rmode = strtol(cp, (char **) &cp, 8);
d887 1
a887 1
		group = strtok((char *) NULL, " ");
d1148 1
a1148 1
	if (file = getnotifyfile())
@


1.5
log
@Fix compilation warning.
@
text
@d1 1
a1 1
/*	$OpenBSD: client.c,v 1.3 1996/06/26 05:38:08 deraadt Exp $	*/
d38 1
a38 1
"$OpenBSD: client.c,v 1.3 1996/06/26 05:38:08 deraadt Exp $";
d670 1
a670 1
	sizerr = (readlink(target, lbuf, sizeof(lbuf)) != stb->st_size);
@


1.4
log
@Updated to rdist 6.1.3.  Used real snprintf() (instead of string length
in the format) since we have it.
@
text
@d841 1
a841 1
	size = strtol(cp, &cp, 10);
d850 1
a850 1
	mtime = strtol(cp, &cp, 10);
d859 1
a859 1
	rmode = strtol(cp, &cp, 8);
@


1.3
log
@rcsid
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d38 1
a38 1
"$OpenBSD: client.c,v 1.2 1996/03/05 03:15:57 dm Exp $";
d534 6
d715 6
@


1.2
log
@rdist 6.1.2
@
text
@d1 2
d38 1
a38 1
"$Id: client.c,v 6.79 1996/01/29 22:02:24 mcooper Exp $";
@


1.1
log
@rdist 6.1.1
@
text
@d36 1
a36 1
"$Id: client.c,v 6.78 1995/12/13 00:54:18 mcooper Exp $";
d569 11
a586 6
	/*
	 * Don't descend into directory
	 */
	if (IS_ON(opts, DO_NODESCEND))
		return(0);

a590 5
	if ((d = opendir(target)) == NULL) {
		error("%s: opendir failed: %s", target, SYSERR);
		return(-1);
	}

@
