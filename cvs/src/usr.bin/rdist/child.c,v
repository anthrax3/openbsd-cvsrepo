head	1.26;
access;
symbols
	OPENBSD_6_2:1.26.0.4
	OPENBSD_6_2_BASE:1.26
	OPENBSD_6_1:1.26.0.6
	OPENBSD_6_1_BASE:1.26
	OPENBSD_6_0:1.26.0.2
	OPENBSD_6_0_BASE:1.26
	OPENBSD_5_9:1.25.0.4
	OPENBSD_5_9_BASE:1.25
	OPENBSD_5_8:1.25.0.6
	OPENBSD_5_8_BASE:1.25
	OPENBSD_5_7:1.25.0.2
	OPENBSD_5_7_BASE:1.25
	OPENBSD_5_6:1.23.0.4
	OPENBSD_5_6_BASE:1.23
	OPENBSD_5_5:1.16.0.14
	OPENBSD_5_5_BASE:1.16
	OPENBSD_5_4:1.16.0.10
	OPENBSD_5_4_BASE:1.16
	OPENBSD_5_3:1.16.0.8
	OPENBSD_5_3_BASE:1.16
	OPENBSD_5_2:1.16.0.6
	OPENBSD_5_2_BASE:1.16
	OPENBSD_5_1_BASE:1.16
	OPENBSD_5_1:1.16.0.4
	OPENBSD_5_0:1.16.0.2
	OPENBSD_5_0_BASE:1.16
	OPENBSD_4_9:1.14.0.6
	OPENBSD_4_9_BASE:1.14
	OPENBSD_4_8:1.14.0.4
	OPENBSD_4_8_BASE:1.14
	OPENBSD_4_7:1.14.0.2
	OPENBSD_4_7_BASE:1.14
	OPENBSD_4_6:1.13.0.28
	OPENBSD_4_6_BASE:1.13
	OPENBSD_4_5:1.13.0.24
	OPENBSD_4_5_BASE:1.13
	OPENBSD_4_4:1.13.0.22
	OPENBSD_4_4_BASE:1.13
	OPENBSD_4_3:1.13.0.20
	OPENBSD_4_3_BASE:1.13
	OPENBSD_4_2:1.13.0.18
	OPENBSD_4_2_BASE:1.13
	OPENBSD_4_1:1.13.0.16
	OPENBSD_4_1_BASE:1.13
	OPENBSD_4_0:1.13.0.14
	OPENBSD_4_0_BASE:1.13
	OPENBSD_3_9:1.13.0.12
	OPENBSD_3_9_BASE:1.13
	OPENBSD_3_8:1.13.0.10
	OPENBSD_3_8_BASE:1.13
	OPENBSD_3_7:1.13.0.8
	OPENBSD_3_7_BASE:1.13
	OPENBSD_3_6:1.13.0.6
	OPENBSD_3_6_BASE:1.13
	OPENBSD_3_5:1.13.0.4
	OPENBSD_3_5_BASE:1.13
	OPENBSD_3_4:1.13.0.2
	OPENBSD_3_4_BASE:1.13
	OPENBSD_3_3:1.11.0.4
	OPENBSD_3_3_BASE:1.11
	OPENBSD_3_2:1.11.0.2
	OPENBSD_3_2_BASE:1.11
	OPENBSD_3_1:1.10.0.2
	OPENBSD_3_1_BASE:1.10
	OPENBSD_3_0:1.9.0.12
	OPENBSD_3_0_BASE:1.9
	OPENBSD_2_9_BASE:1.9
	OPENBSD_2_9:1.9.0.10
	OPENBSD_2_8:1.9.0.8
	OPENBSD_2_8_BASE:1.9
	OPENBSD_2_7:1.9.0.6
	OPENBSD_2_7_BASE:1.9
	OPENBSD_2_6:1.9.0.4
	OPENBSD_2_6_BASE:1.9
	OPENBSD_2_5:1.9.0.2
	OPENBSD_2_5_BASE:1.9
	OPENBSD_2_4:1.7.0.2
	OPENBSD_2_4_BASE:1.7
	OPENBSD_2_3:1.6.0.2
	OPENBSD_2_3_BASE:1.6
	OPENBSD_2_2:1.5.0.2
	OPENBSD_2_2_BASE:1.5
	OPENBSD_2_1:1.4.0.4
	OPENBSD_2_1_BASE:1.4
	OPENBSD_2_0:1.4.0.2
	OPENBSD_2_0_BASE:1.4;
locks; strict;
comment	@ * @;


1.26
date	2016.03.30.20.12.18;	author millert;	state Exp;
branches;
next	1.25;
commitid	6hXlq345Lb1I2wDI;

1.25
date	2015.01.20.09.00.16;	author guenther;	state Exp;
branches;
next	1.24;
commitid	0Y0sKBv6c3xIKoav;

1.24
date	2015.01.20.03.55.18;	author guenther;	state Exp;
branches;
next	1.23;
commitid	ldCGAdVkQhZJwZkZ;

1.23
date	2014.07.05.07.57.43;	author guenther;	state Exp;
branches;
next	1.22;
commitid	qQl5AC5fTkfYfgJw;

1.22
date	2014.07.05.07.25.27;	author guenther;	state Exp;
branches;
next	1.21;
commitid	UOTeLaVIbUe0TbCR;

1.21
date	2014.07.05.06.35.03;	author guenther;	state Exp;
branches;
next	1.20;
commitid	qj3p16q4w4bl72Mo;

1.20
date	2014.07.05.06.18.58;	author guenther;	state Exp;
branches;
next	1.19;
commitid	hGNsy3LdPkedy89e;

1.19
date	2014.07.05.05.08.57;	author guenther;	state Exp;
branches;
next	1.18;
commitid	OJE37MGTwe2V3TjM;

1.18
date	2014.07.05.05.05.51;	author guenther;	state Exp;
branches;
next	1.17;
commitid	U6Y6NKOm7JX1MOTg;

1.17
date	2014.07.04.21.50.13;	author guenther;	state Exp;
branches;
next	1.16;
commitid	K3X7XO1VQnz9u9MA;

1.16
date	2011.04.18.12.29.59;	author krw;	state Exp;
branches;
next	1.15;

1.15
date	2011.04.10.15.47.28;	author krw;	state Exp;
branches;
next	1.14;

1.14
date	2009.10.27.23.59.42;	author deraadt;	state Exp;
branches;
next	1.13;

1.13
date	2003.06.03.02.56.14;	author millert;	state Exp;
branches;
next	1.12;

1.12
date	2003.05.14.01.34.35;	author millert;	state Exp;
branches;
next	1.11;

1.11
date	2002.06.12.06.07.16;	author mpech;	state Exp;
branches;
next	1.10;

1.10
date	2001.11.19.19.02.15;	author mpech;	state Exp;
branches;
next	1.9;

1.9
date	99.02.05.00.39.08;	author millert;	state Exp;
branches;
next	1.8;

1.8
date	99.02.04.23.18.56;	author millert;	state Exp;
branches;
next	1.7;

1.7
date	98.06.26.21.20.58;	author millert;	state Exp;
branches;
next	1.6;

1.6
date	97.12.16.22.15.36;	author deraadt;	state Exp;
branches;
next	1.5;

1.5
date	97.08.04.19.25.54;	author deraadt;	state Exp;
branches;
next	1.4;

1.4
date	96.07.25.05.30.59;	author millert;	state Exp;
branches;
next	1.3;

1.3
date	96.06.26.05.38.07;	author deraadt;	state Exp;
branches;
next	1.2;

1.2
date	96.03.05.03.15.56;	author dm;	state Exp;
branches;
next	1.1;

1.1
date	96.02.03.12.12.09;	author dm;	state Exp;
branches;
next	;


desc
@@


1.26
log
@In setnonblocking() rename "mode" variable to "flags".
@
text
@/*	$OpenBSD: child.c,v 1.25 2015/01/20 09:00:16 guenther Exp $	*/

/*
 * Copyright (c) 1983 Regents of the University of California.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */

/*
 * Functions for rdist related to children
 */

#include <sys/types.h>
#include <sys/select.h>
#include <sys/wait.h>

#include <errno.h>
#include <fcntl.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>

#include "client.h"

typedef enum _PROCSTATE {
    PSrunning,
    PSdead
} PROCSTATE;

/*
 * Structure for child rdist processes mainted by the parent
 */
struct _child {
	char	       *c_name;			/* Name of child */
	int		c_readfd;		/* Read file descriptor */
	pid_t		c_pid;			/* Process ID */
	PROCSTATE       c_state;		/* Running? */
	struct _child  *c_next;			/* Next entry */
};
typedef struct _child CHILD;

static CHILD	       *childlist = NULL;	/* List of children */
int     		activechildren = 0;	/* Number of active children */
static int 		needscan = FALSE;	/* Need to scan children */

static void removechild(CHILD *);
static CHILD *copychild(CHILD *);
static void addchild(CHILD *);
static void readchild(CHILD *);
static pid_t waitproc(int *, int);
static void reap(int);
static void childscan(void);

/*
 * Remove a child that has died (exited) 
 * from the list of active children
 */
static void
removechild(CHILD *child)
{
	CHILD *pc, *prevpc;

	debugmsg(DM_CALL, "removechild(%s, %d, %d) start",
		 child->c_name, child->c_pid, child->c_readfd);

	/*
	 * Find the child in the list
	 */
	for (pc = childlist, prevpc = NULL; pc != NULL; 
	     prevpc = pc, pc = pc->c_next)
		if (pc == child) 
			break;

	if (pc == NULL)
		error("RemoveChild called with bad child %s %d %d",
		      child->c_name, child->c_pid, child->c_readfd);
	else {
		/*
		 * Remove the child
		 */
		sigset_t set, oset;

		sigemptyset(&set);
		sigaddset(&set, SIGCHLD);
		sigprocmask(SIG_BLOCK, &set, &oset);

		if (prevpc != NULL)
			prevpc->c_next = pc->c_next;
		else
			childlist = pc->c_next;

		sigprocmask(SIG_SETMASK, &oset, NULL);

		(void) free(child->c_name);
		--activechildren;
		(void) close(child->c_readfd);
		(void) free(pc);
	}

	debugmsg(DM_CALL, "removechild() end");
}

/*
 * Create a totally new copy of a child.
 */
static CHILD *
copychild(CHILD *child)
{
	CHILD *newc;

	newc = xmalloc(sizeof *newc);

	newc->c_name = xstrdup(child->c_name);
	newc->c_readfd = child->c_readfd;
	newc->c_pid = child->c_pid;
	newc->c_state = child->c_state;
	newc->c_next = NULL;

	return(newc);
}

/*
 * Add a child to the list of children.
 */			
static void
addchild(CHILD *child)
{
	CHILD *pc;

	debugmsg(DM_CALL, "addchild() start\n");

	pc = copychild(child);
	pc->c_next = childlist;
	childlist = pc;

	++activechildren;

	debugmsg(DM_MISC,
		 "addchild() created '%s' pid %d fd %d (active=%d)\n",
		 child->c_name, child->c_pid, child->c_readfd, activechildren);
}

/*
 * Read input from a child process.
 */
static void
readchild(CHILD *child)
{
	char rbuf[BUFSIZ];
	ssize_t amt;

	debugmsg(DM_CALL, "[readchild(%s, %d, %d) start]", 
		 child->c_name, child->c_pid, child->c_readfd);

	/*
	 * Check that this is a valid child.
	 */
	if (child->c_name == NULL || child->c_readfd <= 0) {
		debugmsg(DM_MISC, "[readchild(%s, %d, %d) bad child]",
			 child->c_name, child->c_pid, child->c_readfd);
		return;
	}

	/*
	 * Read from child and display the result.
	 */
	while ((amt = read(child->c_readfd, rbuf, sizeof(rbuf))) > 0) {
		/* XXX remove these debug calls */
		debugmsg(DM_MISC, "[readchild(%s, %d, %d) got %zd bytes]", 
			 child->c_name, child->c_pid, child->c_readfd, amt);

		(void) xwrite(fileno(stdout), rbuf, amt);

		debugmsg(DM_MISC, "[readchild(%s, %d, %d) write done]",
			 child->c_name, child->c_pid, child->c_readfd);
	}

	debugmsg(DM_MISC, "readchild(%s, %d, %d) done: amt = %zd errno = %d\n",
		 child->c_name, child->c_pid, child->c_readfd, amt, errno);

	/* 
	 * See if we've reached EOF 
	 */
	if (amt == 0)
		debugmsg(DM_MISC, "readchild(%s, %d, %d) at EOF\n",
			 child->c_name, child->c_pid, child->c_readfd);
}

/*
 * Wait for processes to exit.  If "block" is true, then we block
 * until a process exits.  Otherwise, we return right away.  If
 * a process does exit, then the pointer "statval" is set to the
 * exit status of the exiting process, if statval is not NULL.
 */
static pid_t
waitproc(int *statval, int block)
{
	int status;
	pid_t pid;
	int exitval;

	debugmsg(DM_CALL, "waitproc() %s, active children = %d...\n", 
		 (block) ? "blocking" : "nonblocking", activechildren);

	pid = waitpid(-1, &status, (block) ? 0 : WNOHANG);

	exitval = WEXITSTATUS(status);

	if (pid > 0 && exitval != 0) {
		nerrs++;
		debugmsg(DM_MISC, 
			 "Child process %d exited with status %d.\n",
			 pid, exitval);
	}

	if (statval)
		*statval = exitval;

	debugmsg(DM_CALL, "waitproc() done (activechildren = %d)\n", 
		 activechildren);

	return(pid);
}

/*
 * Check to see if any children have exited, and if so, read any unread
 * input and then remove the child from the list of children.
 */
static void
reap(int dummy)
{
	CHILD *pc;
	int save_errno = errno;
	int status = 0;
	pid_t pid;

	debugmsg(DM_CALL, "reap() called\n");

	/*
	 * Reap every child that has exited.  Break out of the
	 * loop as soon as we run out of children that have
	 * exited so far.
	 */
	for ( ; ; ) {
		/*
		 * Do a non-blocking check for exiting processes
		 */
		pid = waitproc(&status, FALSE);
		debugmsg(DM_MISC, 
			 "reap() pid = %d status = %d activechildren=%d\n",
			 pid, status, activechildren);

		/*
		 * See if a child really exited
		 */
		if (pid == 0)
			break;
		if (pid < 0) {
			if (errno != ECHILD)
				error("Wait failed: %s", SYSERR);
			break;
		}

		/*
		 * Find the process (pid) and mark it as dead.
		 */
		for (pc = childlist; pc; pc = pc->c_next)
			if (pc->c_pid == pid) {
				needscan = TRUE;
				pc->c_state = PSdead;
			}

	}

	/*
	 * Reset signals
	 */
	(void) signal(SIGCHLD, reap);

	debugmsg(DM_CALL, "reap() done\n");
	errno = save_errno;
}

/*
 * Scan the children list to find the child that just exited, 
 * read any unread input, then remove it from the list of active children.
 */
static void
childscan(void)
{
	CHILD *pc, *nextpc;
	
	debugmsg(DM_CALL, "childscan() start");

	for (pc = childlist; pc; pc = nextpc) {
		nextpc = pc->c_next;
		if (pc->c_state == PSdead) {
			readchild(pc);
			removechild(pc);
		}
	}

	needscan = FALSE;
	debugmsg(DM_CALL, "childscan() end");
}

/*
 *
 * Wait for children to send output for us to read.
 *
 */
void
waitup(void)
{
	int count;
	CHILD *pc;
	fd_set *rchildfdsp = NULL;
	int rchildfdsn = 0;

	debugmsg(DM_CALL, "waitup() start\n");

	if (needscan)
		childscan();

	if (activechildren <= 0)
		return;

	/*
	 * Set up which children we want to select() on.
	 */
	for (pc = childlist; pc; pc = pc->c_next)
		if (pc->c_readfd > rchildfdsn)
			rchildfdsn = pc->c_readfd;
	rchildfdsp = xcalloc(howmany(rchildfdsn+1, NFDBITS), sizeof(fd_mask));

	for (pc = childlist; pc; pc = pc->c_next)
		if (pc->c_readfd > 0) {
			debugmsg(DM_MISC, "waitup() select on %d (%s)\n",
				 pc->c_readfd, pc->c_name);
			FD_SET(pc->c_readfd, rchildfdsp);
		}

	/*
	 * Actually call select()
	 */
	/* XXX remove debugmsg() calls */
	debugmsg(DM_MISC, "waitup() Call select(), activechildren=%d\n", 
		 activechildren);

	count = select(rchildfdsn+1, rchildfdsp, NULL, NULL, NULL);

	debugmsg(DM_MISC, "waitup() select returned %d activechildren = %d\n", 
		 count, activechildren);

	/*
	 * select() will return count < 0 and errno == EINTR when
	 * there are no active children left.
	 */
	if (count < 0) {
		if (errno != EINTR)
			error("Select failed reading children input: %s", 
			      SYSERR);
		free(rchildfdsp);
		return;
	}

	/*
	 * This should never happen.
	 */
	if (count == 0) {
		error("Select returned an unexpected count of 0.");
		free(rchildfdsp);
		return;
	}

	/*
	 * Go through the list of children and read from each child
	 * which select() detected as ready for reading.
	 */
	for (pc = childlist; pc && count > 0; pc = pc->c_next) {
		/* 
		 * Make sure child still exists 
		 */
		if (pc->c_name && kill(pc->c_pid, 0) < 0 && 
		    errno == ESRCH) {
			debugmsg(DM_MISC, 
				 "waitup() proc %d (%s) died unexpectedly!",
				 pc->c_pid, pc->c_name);
			pc->c_state = PSdead;
			needscan = TRUE;
		}

		if (pc->c_name == NULL ||
		    !FD_ISSET(pc->c_readfd, rchildfdsp))
			continue;

		readchild(pc);
		--count;
	}
	free(rchildfdsp);

	debugmsg(DM_CALL, "waitup() end\n");
}

/*
 * Enable non-blocking I/O.
 */
static int
setnonblocking(int fd)
{
	int	flags;

	if ((flags = fcntl(fd, F_GETFL)) < 0)
		return (-1);
	if (flags & O_NONBLOCK)
		return (0);
	return (fcntl(fd, F_SETFL, flags | O_NONBLOCK));
}

/*
 * Spawn (create) a new child process for "cmd".
 */
int
spawn(struct cmd *cmd, struct cmd *cmdlist)
{
	pid_t pid;
	int fildes[2];
	char *childname = cmd->c_name;

	if (pipe(fildes) < 0) {
		error("Cannot create pipe for %s: %s", childname, SYSERR);
		return(-1);
	}

	pid = fork();
	if (pid == (pid_t)-1) {
		error("Cannot spawn child for %s: fork failed: %s", 
		      childname, SYSERR);
		return(-1);
	} else if (pid > 0) {
		/*
		 * Parent
		 */
		static CHILD newchild;

		/* Receive notification when the child exits */
		(void) signal(SIGCHLD, reap);

		/* Settup the new child */
		newchild.c_next = NULL;
		newchild.c_name = childname;
		newchild.c_readfd = fildes[PIPE_READ];
		newchild.c_pid = pid;
		newchild.c_state = PSrunning;

		/* We're not going to write to the child */
		(void) close(fildes[PIPE_WRITE]);

		/* Set non-blocking I/O */
		if (setnonblocking(newchild.c_readfd) < 0) {
			error("Set nonblocking I/O failed: %s", SYSERR);
			return(-1);
		}

		/* Add new child to child list */
		addchild(&newchild);

		/* Mark all other entries for this host as assigned */
		markassigned(cmd, cmdlist);

		debugmsg(DM_CALL,
			 "spawn() Forked child %d for host %s active = %d\n",
			 pid, childname, activechildren);
		return(pid);
	} else {
		/* 
		 * Child 
		 */

		/* We're not going to read from our parent */
		(void) close(fildes[PIPE_READ]);

		/* Make stdout and stderr go to PIPE_WRITE (our parent) */
		if (dup2(fildes[PIPE_WRITE], (int)fileno(stdout)) < 0) {
			error("Cannot duplicate stdout file descriptor: %s", 
			      SYSERR);
			return(-1);
		}
		if (dup2(fildes[PIPE_WRITE], (int)fileno(stderr)) < 0) {
			error("Cannot duplicate stderr file descriptor: %s", 
			      SYSERR);
			return(-1);
		}

		return(0);
	}
}
@


1.25
log
@Split out from rdist/defs.h the client-only and server-only bits into
 rdist/client.h and rdistd/server.h
Only put #includes in .h files that are necessary for the .h to be used;
 all other #includes go in the .c files
Move all extern variable declarations to the .h files, renaming local
 variables to avoid shadowing
Replace me_type member of mntent_t with an "is NFS?" flag bit
@
text
@d1 1
a1 1
/*	$OpenBSD: child.c,v 1.24 2015/01/20 03:55:18 guenther Exp $	*/
d429 1
a429 1
 * Enable non-blocking I/O mode.
d434 1
a434 1
	int	mode;
d436 1
a436 1
	if ((mode = fcntl(fd, F_GETFL)) < 0)
d438 1
a438 1
	if (mode & O_NONBLOCK)
d440 1
a440 1
	return (fcntl(fd, F_SETFL, mode | O_NONBLOCK));
@


1.24
log
@SELECT_FD_TYPE is obsolete
@
text
@d1 1
a1 1
/*	$OpenBSD: child.c,v 1.23 2014/07/05 07:57:43 guenther Exp $	*/
a31 2
#include "defs.h"

d40 8
a66 1
extern int		maxchildren;		/* Max active children */
@


1.23
log
@Our fork() never misses
@
text
@d1 1
a1 1
/*	$OpenBSD: child.c,v 1.22 2014/07/05 07:25:27 guenther Exp $	*/
d368 1
a368 2
	count = select(rchildfdsn+1, (SELECT_FD_TYPE *) rchildfdsp, 
		       NULL, NULL, NULL);
@


1.22
log
@Assume POSIX: sigrocmask()
Properly use SIG_SIGMASK to restore previous mask
@
text
@d1 1
a1 1
/*	$OpenBSD: child.c,v 1.21 2014/07/05 06:35:03 guenther Exp $	*/
a463 9

#if	defined(FORK_MISSES)
		/*
		 * XXX Some OS's have a bug where fork does not
		 * always return properly to the parent
		 * when a number of forks are done very quicky.
		 */
		sleep(2);
#endif	/* FORK_MISSES */
@


1.21
log
@Assume POSIX: waitpid(), select(), and <sys/select.h>
@
text
@d1 1
a1 1
/*	$OpenBSD: child.c,v 1.20 2014/07/05 06:18:58 guenther Exp $	*/
d99 1
a99 2
#if	defined(POSIX_SIGNALS)
		sigset_t set;
d103 1
a103 6
		sigprocmask(SIG_BLOCK, &set, NULL);
#else	/* !POSIX_SIGNALS */
		int oldmask;

		oldmask = sigblock(sigmask(SIGCHLD));
#endif	/* POSIX_SIGNALS */
d110 1
a110 5
#if	defined(POSIX_SIGNALS)
		sigprocmask(SIG_UNBLOCK, &set, NULL);
#else
		sigsetmask(oldmask);
#endif	/* POSIX_SIGNALS */
@


1.20
log
@Assume C89: stdargs, const, and setvbuf()
Assume POSIX: O_NONBLOCK and S_IS{DIR,REG,LNK}
@
text
@d1 1
a1 1
/*	$OpenBSD: child.c,v 1.19 2014/07/05 05:08:57 guenther Exp $	*/
d39 1
a40 3
#if	defined(NEED_SYS_SELECT_H)
#include <sys/select.h>
#endif	/* NEED_SYS_SELECT_H */
d226 1
a226 1
	WAIT_ARG_TYPE status;
a232 1
#if	WAIT_TYPE == WAIT_WAITPID
a233 5
#else
#if	WAIT_TYPE == WAIT_WAIT3
	pid = wait3(&status, (block) ? 0 : WNOHANG, NULL);
#endif	/* WAIT_WAIT3 */
#endif	/* WAIT_WAITPID */
a234 1
#if	defined(WEXITSTATUS)
a235 3
#else
	exitval = status.w_retcode;
#endif	/* defined(WEXITSTATUS) */
a335 1
#if	defined HAVE_SELECT
a338 5
#else	!HAVE_SELECT
 *
 * Wait up for children to exit.
 *
#endif
a342 1
#if	defined(HAVE_SELECT)
a430 11
#else	/* !defined(HAVE_SELECT) */

	/*
	 * The non-select() version of waitproc()
	 */
	debugmsg(DM_CALL, "waitup() start\n");

	if (waitproc(NULL, TRUE) > 0)
		--activechildren;

#endif	/* defined(HAVE_SELECT) */
@


1.19
log
@Use xcalloc() in waitup(): the calloc fails, simply returning ain't gonna
help
@
text
@d1 1
a1 1
/*	$OpenBSD: child.c,v 1.18 2014/07/05 05:05:51 guenther Exp $	*/
d465 15
d528 1
a528 1
		if (setnonblocking(newchild.c_readfd, TRUE) < 0) {
a565 37


/*
 * Enable or disable non-blocking I/O mode.
 *
 * Code is from INN by Rich Salz.
 */
#if	NBIO_TYPE == NBIO_IOCTL
#include <sys/ioctl.h>

int
setnonblocking(int fd, int flag)
{
	int state;

	state = flag ? 1 : 0;
	return(ioctl(fd, FIONBIO, (char *)&state));
}

#endif	/* NBIO_IOCTL */


#if	NBIO_TYPE == NBIO_FCNTL
int
setnonblocking(int fd, int flag)
{
	int	mode;

	if ((mode = fcntl(fd, F_GETFL, 0)) < 0)
		return(-1);
	if (flag)
		mode |= FNDELAY;
	else
		mode &= ~FNDELAY;
	return(fcntl(fd, F_SETFL, mode));
}
#endif	/* NBIO_FCNTL */
@


1.18
log
@Use void* in malloc/realloc/calloc wrappers
@
text
@d1 1
a1 1
/*	$OpenBSD: child.c,v 1.17 2014/07/04 21:50:13 guenther Exp $	*/
d381 1
a381 3
	rchildfdsp = calloc(howmany(rchildfdsn+1, NFDBITS), sizeof(fd_mask));
	if (rchildfdsp == NULL)
		return;
@


1.17
log
@Convert a malloc+memset to a calloc

based on diff from Benjamin Baier (programmer (at) netzbasis.de)
@
text
@d1 1
a1 1
/*	$OpenBSD: child.c,v 1.16 2011/04/18 12:29:59 krw Exp $	*/
d141 1
a141 1
	newc = (CHILD *) xmalloc(sizeof(CHILD));
@


1.16
log
@Print size_t with %zu and ssize_t with %zd in error/debug output.
Not %d or %u. May help some of the issues reported by Richard Toohey.
Tested by Steven R. Gerber.
@
text
@d1 1
a1 1
/*	$OpenBSD: child.c,v 1.15 2011/04/10 15:47:28 krw Exp $	*/
a365 1
	size_t bytes;
d376 1
a376 1
	 * Settup which children we want to select() on.
d381 2
a382 2
	bytes = howmany(rchildfdsn+1, NFDBITS) * sizeof(fd_mask);
	if ((rchildfdsp = (fd_set *)malloc(bytes)) == NULL)
a384 1
	memset(rchildfdsp, 0, bytes);
@


1.15
log
@Apply some tough type-love and give rdist a chance to handle files
larger than 2GB. Diff from Stephan R. Gerber via PR#6586, tweaks
by me.

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: child.c,v 1.14 2009/10/27 23:59:42 deraadt Exp $	*/
d199 1
a199 1
		debugmsg(DM_MISC, "[readchild(%s, %d, %d) got %lld bytes]", 
d208 1
a208 1
	debugmsg(DM_MISC, "readchild(%s, %d, %d) done: amt = %lld errno = %d\n",
@


1.14
log
@rcsid[] and sccsid[] and copyright[] are essentially unmaintained (and
unmaintainable).  these days, people use source.  these id's do not provide
any benefit, and do hurt the small install media
(the 33,000 line diff is essentially mechanical)
ok with the idea millert, ok dms
@
text
@d1 1
a1 1
/*	$OpenBSD: child.c,v 1.13 2003/06/03 02:56:14 millert Exp $	*/
d180 1
a180 1
	int amt;
d199 1
a199 1
		debugmsg(DM_MISC, "[readchild(%s, %d, %d) got %d bytes]", 
d208 1
a208 1
	debugmsg(DM_MISC, "readchild(%s, %d, %d) done: amt = %d errno = %d\n",
@


1.13
log
@Remove the advertising clause in the UCB license which Berkeley
rescinded 22 July 1999.  Proofed by myself and Theo.
@
text
@d1 1
a1 1
/*	$OpenBSD: child.c,v 1.12 2003/05/14 01:34:35 millert Exp $	*/
a32 17

#ifndef lint
#if 0
static char RCSid[] __attribute__((__unused__)) = 
"$From: child.c,v 1.3 1999/11/01 00:20:55 christos Exp $";
#else
static char RCSid[] __attribute__((__unused__)) = 
"$OpenBSD: child.c,v 1.12 2003/05/14 01:34:35 millert Exp $";
#endif

static char sccsid[] __attribute__((__unused__)) =
"@@(#)docmd.c	5.1 (Berkeley) 6/6/85";

static char copyright[] __attribute__((__unused__)) =
"@@(#) Copyright (c) 1983 Regents of the University of California.\n\
 All rights reserved.\n";
#endif /* not lint */
@


1.12
log
@ o Sync w/ freerdist 0.92 minus the compress option
 o KNF and ANSIfy the function headers

Sparse file support is currently a no-op since it didn't work.
Proper sparse file support will be added later.
@
text
@d1 1
a1 1
/*	$OpenBSD: child.c,v 1.11 2002/06/12 06:07:16 mpech Exp $	*/
d15 1
a15 5
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
d40 1
a40 1
"$OpenBSD: child.c,v 1.11 2002/06/12 06:07:16 mpech Exp $";
@


1.11
log
@a real pid_t cleanup.

espie@@ ok for make/,
deraadt@@ one extra eye,
millert@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: child.c,v 1.10 2001/11/19 19:02:15 mpech Exp $	*/
d36 2
d40 2
a41 2
static char RCSid[] = 
"$From: child.c,v 6.28 1996/02/22 19:30:09 mcooper Exp $";
d43 2
a44 2
static char RCSid[] = 
"$OpenBSD: child.c,v 1.10 2001/11/19 19:02:15 mpech Exp $";
d47 2
a48 1
static char sccsid[] = "@@(#)docmd.c	5.1 (Berkeley) 6/6/85";
d50 1
a50 1
static char copyright[] =
a58 1
#include "defs.h"
d87 8
d99 2
a100 2
static void removechild(child)
	CHILD *child;
d104 2
a105 2
	debugmsg(DM_CALL, "removechild(%s, %ld, %d) start",
		 child->c_name, (long)child->c_pid, child->c_readfd);
d116 2
a117 2
		error("RemoveChild called with bad child %s %ld %d",
		      child->c_name, (long)child->c_pid, child->c_readfd);
d157 2
a158 2
static CHILD *copychild(child)
	CHILD *child;
d176 2
a177 2
static void addchild(child)
	CHILD *child;
d190 2
a191 3
		 "addchild() created '%s' pid %ld fd %d (active=%d)\n",
		 child->c_name, (long)child->c_pid, child->c_readfd,
		 activechildren);
d197 2
a198 2
static void readchild(child)
	CHILD *child;
d203 2
a204 2
	debugmsg(DM_CALL, "[readchild(%s, %ld, %d) start]", 
		 child->c_name, (long)child->c_pid, child->c_readfd);
d210 2
a211 2
		debugmsg(DM_MISC, "[readchild(%s, %ld, %d) bad child]",
			 child->c_name, (long)child->c_pid, child->c_readfd);
d220 2
a221 2
		debugmsg(DM_MISC, "[readchild(%s, %ld, %d) got %d bytes]", 
			 child->c_name, (long)child->c_pid, child->c_readfd, amt);
d225 2
a226 2
		debugmsg(DM_MISC, "[readchild(%s, %ld, %d) write done]",
			 child->c_name, (long)child->c_pid, child->c_readfd);
d229 2
a230 2
	debugmsg(DM_MISC, "readchild(%s, %ld, %d) done: amt = %d errno = %d\n",
		 child->c_name, (long)child->c_pid, child->c_readfd, amt, errno);
d236 2
a237 2
		debugmsg(DM_MISC, "readchild(%s, %ld, %d) at EOF\n",
			 child->c_name, (long)child->c_pid, child->c_readfd);
d246 2
a247 3
static pid_t waitproc(statval, block)
	int *statval;
	int block;
d250 1
a251 1
	pid_t pid;
d273 2
a274 2
			 "Child process %ld exited with status %d.\n",
			 (long)pid, exitval);
d290 2
a291 1
static void reap()
d311 2
a312 2
			 "reap() pid = %ld status = %d activechildren=%d\n",
			 (long)pid, status, activechildren);
d349 2
a350 1
static void childscan() 
d379 2
a380 1
extern void waitup()
d460 2
a461 2
				 "waitup() proc %ld (%s) died unexpectedly!",
				 (long)pc->c_pid, pc->c_name);
d492 2
a493 3
extern int spawn(cmd, cmdlist)
	struct cmd *cmd;
	struct cmd *cmdlist;
d586 2
a587 3
int setnonblocking(fd, flag)
	int fd;
	int flag;
d599 2
a600 3
int setnonblocking(fd, flag)
	int fd;
	int flag;
@


1.10
log
@kill more registers

millert@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: child.c,v 1.9 1999/02/05 00:39:08 millert Exp $	*/
d42 1
a42 1
"$OpenBSD: child.c,v 1.9 1999/02/05 00:39:08 millert Exp $";
d94 2
a95 2
	debugmsg(DM_CALL, "removechild(%s, %d, %d) start",
		 child->c_name, child->c_pid, child->c_readfd);
d106 2
a107 2
		error("RemoveChild called with bad child %s %d %d",
		      child->c_name, child->c_pid, child->c_readfd);
d180 3
a182 2
		 "addchild() created '%s' pid %d fd %d (active=%d)\n",
		 child->c_name, child->c_pid, child->c_readfd, activechildren);
d194 2
a195 2
	debugmsg(DM_CALL, "[readchild(%s, %d, %d) start]", 
		 child->c_name, child->c_pid, child->c_readfd);
d201 2
a202 2
		debugmsg(DM_MISC, "[readchild(%s, %d, %d) bad child]",
			 child->c_name, child->c_pid, child->c_readfd);
d211 2
a212 2
		debugmsg(DM_MISC, "[readchild(%s, %d, %d) got %d bytes]", 
			 child->c_name, child->c_pid, child->c_readfd, amt);
d216 2
a217 2
		debugmsg(DM_MISC, "[readchild(%s, %d, %d) write done]",
			 child->c_name, child->c_pid, child->c_readfd);
d220 2
a221 2
	debugmsg(DM_MISC, "readchild(%s, %d, %d) done: amt = %d errno = %d\n",
		 child->c_name, child->c_pid, child->c_readfd, amt, errno);
d227 2
a228 2
		debugmsg(DM_MISC, "readchild(%s, %d, %d) at EOF\n",
			 child->c_name, child->c_pid, child->c_readfd);
d237 1
a237 1
static int waitproc(statval, block)
d242 2
a243 1
	int pid, exitval;
d265 2
a266 2
			 "Child process %d exited with status %d.\n",
			 pid, exitval);
d302 2
a303 2
			 "reap() pid = %d status = %d activechildren=%d\n",
			 pid, status, activechildren);
d449 2
a450 2
				 "waitup() proc %d (%s) died unexpectedly!",
				 pc->c_pid, pc->c_name);
@


1.9
log
@Use rchildfdsn+1, not FD_SETSIZE for nfds in select()
@
text
@d1 1
a1 1
/*	$OpenBSD: child.c,v 1.8 1999/02/04 23:18:56 millert Exp $	*/
d42 1
a42 1
"$OpenBSD: child.c,v 1.8 1999/02/04 23:18:56 millert Exp $";
d92 1
a92 1
	register CHILD *pc, *prevpc;
d150 1
a150 1
	register CHILD *newc;
d169 1
a169 1
	register CHILD *pc;
d282 1
a282 1
	register CHILD *pc;
d340 1
a340 1
	register CHILD *pc, *nextpc;
d370 2
a371 2
	register int count;
	register CHILD *pc;
@


1.8
log
@Fix a serious memory consumption problem when running over directories
that contain many hard-linked files; johnh@@isi.edu
Also add an xstrdup() that behaves like xmalloc() on failure.
@
text
@d1 1
a1 1
/*	$OpenBSD: child.c,v 1.7 1998/06/26 21:20:58 millert Exp $	*/
d42 1
a42 1
"$OpenBSD: child.c,v 1.7 1998/06/26 21:20:58 millert Exp $";
d409 1
a409 1
	count = select(FD_SETSIZE, (SELECT_FD_TYPE *) rchildfdsp, 
@


1.7
log
@rdist 6.1.4 + OpenBSD patches + some -Wall
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d42 1
a42 1
"$OpenBSD$";
d154 1
a154 1
	newc->c_name = strdup(child->c_name);
@


1.6
log
@do not overflow fd_set
@
text
@d1 1
a1 1
/*	$OpenBSD: child.c,v 1.5 1997/08/04 19:25:54 deraadt Exp $	*/
d37 1
d39 5
a43 1
"$OpenBSD: child.c,v 1.5 1997/08/04 19:25:54 deraadt Exp $";
d117 1
a117 1
		sigprocmask(SIG_BLOCK, &set, (sigset_t *)NULL);
d130 1
a130 1
		sigprocmask(SIG_UNBLOCK, &set, (sigset_t *)NULL);
d374 1
a374 1
	int bytes;
d409 2
a410 3
	count = select(rchildfdsn+1, (SELECT_FD_TYPE *) rchildfdsp,
		       (SELECT_FD_TYPE *) NULL, (SELECT_FD_TYPE *) NULL,
		       (struct timeval *) NULL);
d460 1
d469 1
a469 1
	if (waitproc((int *) NULL, TRUE) > 0)
a473 1
	free(rchildfdsp);
@


1.5
log
@save errno in sigchld handlers
@
text
@d1 1
a1 1
/*	$OpenBSD: child.c,v 1.4 1996/07/25 05:30:59 millert Exp $	*/
d38 1
a38 1
"$OpenBSD: child.c,v 1.4 1996/07/25 05:30:59 millert Exp $";
d367 3
a369 1
	fd_set rchildfds;
d382 8
a389 1
	FD_ZERO(&rchildfds);
d394 1
a394 1
			FD_SET(pc->c_readfd, &rchildfds);
d404 1
a404 1
	count = select(FD_SETSIZE, (SELECT_FD_TYPE *) &rchildfds,
d419 1
d428 1
d450 1
a450 1
		    !FD_ISSET(pc->c_readfd, &rchildfds))
d469 1
@


1.4
log
@Updated to rdist 6.1.3.  Used real snprintf() (instead of string length
in the format) since we have it.
@
text
@d1 1
a1 1
/*	$OpenBSD: child.c,v 1.3 1996/06/26 05:38:07 deraadt Exp $	*/
d38 1
a38 1
"$OpenBSD: child.c,v 1.3 1996/06/26 05:38:07 deraadt Exp $";
d278 1
d326 1
@


1.3
log
@rcsid
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d38 1
a38 1
"$OpenBSD: child.c,v 1.2 1996/03/05 03:15:56 dm Exp $";
d393 3
a395 2
	count = select(FD_SETSIZE, &rchildfds, (fd_set *) NULL, 
		       (fd_set *) NULL, (struct timeval *) NULL);
@


1.2
log
@rdist 6.1.2
@
text
@d1 2
d38 1
a38 1
"$Id: child.c,v 6.27 1995/12/13 00:54:18 mcooper Exp $";
@


1.1
log
@rdist 6.1.1
@
text
@@
