head	1.22;
access;
symbols
	OPENBSD_6_0:1.20.0.2
	OPENBSD_6_0_BASE:1.20
	OPENBSD_5_9:1.19.0.2
	OPENBSD_5_9_BASE:1.19
	OPENBSD_5_8:1.17.0.26
	OPENBSD_5_8_BASE:1.17
	OPENBSD_5_7:1.17.0.18
	OPENBSD_5_7_BASE:1.17
	OPENBSD_5_6:1.17.0.22
	OPENBSD_5_6_BASE:1.17
	OPENBSD_5_5:1.17.0.20
	OPENBSD_5_5_BASE:1.17
	OPENBSD_5_4:1.17.0.16
	OPENBSD_5_4_BASE:1.17
	OPENBSD_5_3:1.17.0.14
	OPENBSD_5_3_BASE:1.17
	OPENBSD_5_2:1.17.0.12
	OPENBSD_5_2_BASE:1.17
	OPENBSD_5_1_BASE:1.17
	OPENBSD_5_1:1.17.0.10
	OPENBSD_5_0:1.17.0.8
	OPENBSD_5_0_BASE:1.17
	OPENBSD_4_9:1.17.0.6
	OPENBSD_4_9_BASE:1.17
	OPENBSD_4_8:1.17.0.4
	OPENBSD_4_8_BASE:1.17
	OPENBSD_4_7:1.17.0.2
	OPENBSD_4_7_BASE:1.17
	OPENBSD_4_6:1.16.0.12
	OPENBSD_4_6_BASE:1.16
	OPENBSD_4_5:1.16.0.8
	OPENBSD_4_5_BASE:1.16
	OPENBSD_4_4:1.16.0.6
	OPENBSD_4_4_BASE:1.16
	OPENBSD_4_3:1.16.0.4
	OPENBSD_4_3_BASE:1.16
	OPENBSD_4_2:1.16.0.2
	OPENBSD_4_2_BASE:1.16
	OPENBSD_4_1:1.15.0.4
	OPENBSD_4_1_BASE:1.15
	OPENBSD_4_0:1.15.0.2
	OPENBSD_4_0_BASE:1.15
	OPENBSD_3_9:1.14.0.6
	OPENBSD_3_9_BASE:1.14
	OPENBSD_3_8:1.14.0.4
	OPENBSD_3_8_BASE:1.14
	OPENBSD_3_7:1.14.0.2
	OPENBSD_3_7_BASE:1.14
	OPENBSD_3_6:1.13.0.6
	OPENBSD_3_6_BASE:1.13
	OPENBSD_3_5:1.13.0.4
	OPENBSD_3_5_BASE:1.13
	OPENBSD_3_4:1.13.0.2
	OPENBSD_3_4_BASE:1.13
	OPENBSD_3_3:1.10.0.6
	OPENBSD_3_3_BASE:1.10
	OPENBSD_3_2:1.10.0.4
	OPENBSD_3_2_BASE:1.10
	OPENBSD_3_1:1.10.0.2
	OPENBSD_3_1_BASE:1.10
	OPENBSD_3_0:1.6.0.2
	OPENBSD_3_0_BASE:1.6
	OPENBSD_2_9_BASE:1.5
	OPENBSD_2_9:1.5.0.10
	OPENBSD_2_8:1.5.0.8
	OPENBSD_2_8_BASE:1.5
	OPENBSD_2_7:1.5.0.6
	OPENBSD_2_7_BASE:1.5
	OPENBSD_2_6:1.5.0.4
	OPENBSD_2_6_BASE:1.5
	OPENBSD_2_5:1.5.0.2
	OPENBSD_2_5_BASE:1.5
	OPENBSD_2_4:1.4.0.2
	OPENBSD_2_4_BASE:1.4
	OPENBSD_2_3:1.3.0.6
	OPENBSD_2_3_BASE:1.3
	OPENBSD_2_2:1.3.0.4
	OPENBSD_2_2_BASE:1.3
	OPENBSD_2_1:1.3.0.2
	OPENBSD_2_1_BASE:1.3
	OPENBSD_2_0:1.2.0.2
	OPENBSD_2_0_BASE:1.2
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.22
date	2016.09.04.16.41.43;	author tb;	state Exp;
branches;
next	1.21;
commitid	6uIu9pC8bM2b7tLj;

1.21
date	2016.08.24.03.13.45;	author guenther;	state Exp;
branches;
next	1.20;
commitid	AyeFIn869BnF7M99;

1.20
date	2016.03.15.04.19.13;	author mmcc;	state Exp;
branches;
next	1.19;
commitid	joKelboeRMdP9MD6;

1.19
date	2016.02.09.02.13.12;	author mmcc;	state Exp;
branches;
next	1.18;
commitid	s5NxLyd3LGeF4Rzd;

1.18
date	2016.02.09.01.29.12;	author tb;	state Exp;
branches;
next	1.17;
commitid	O5foknAVRgIWY45X;

1.17
date	2009.10.27.23.59.39;	author deraadt;	state Exp;
branches;
next	1.16;

1.16
date	2007.03.20.03.50.39;	author tedu;	state Exp;
branches;
next	1.15;

1.15
date	2006.08.23.03.13.09;	author ray;	state Exp;
branches;
next	1.14;

1.14
date	2004.11.21.19.57.16;	author otto;	state Exp;
branches;
next	1.13;

1.13
date	2003.06.12.20.58.09;	author deraadt;	state Exp;
branches;
next	1.12;

1.12
date	2003.06.03.02.56.09;	author millert;	state Exp;
branches;
next	1.11;

1.11
date	2003.04.05.16.13.47;	author deraadt;	state Exp;
branches;
next	1.10;

1.10
date	2002.03.14.06.51.42;	author mpech;	state Exp;
branches;
next	1.9;

1.9
date	2001.12.30.08.17.32;	author pvalchev;	state Exp;
branches;
next	1.8;

1.8
date	2001.11.19.19.02.14;	author mpech;	state Exp;
branches;
next	1.7;

1.7
date	2001.11.02.19.41.06;	author mickey;	state Exp;
branches;
next	1.6;

1.6
date	2001.09.30.07.17.03;	author pvalchev;	state Exp;
branches;
next	1.5;

1.5
date	99.02.07.20.54.09;	author aaron;	state Exp;
branches;
next	1.4;

1.4
date	98.08.11.22.06.27;	author provos;	state Exp;
branches;
next	1.3;

1.3
date	97.01.17.07.12.39;	author millert;	state Exp;
branches;
next	1.2;

1.2
date	96.06.26.05.34.21;	author deraadt;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.45.23;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.45.23;	author deraadt;	state Exp;
branches;
next	;


desc
@@


1.22
log
@Replace strlen + calloc + snprintf with asprintf.

ok martijn, beck, deraadt, gsoares
@
text
@/*	$OpenBSD: parse.c,v 1.21 2016/08/24 03:13:45 guenther Exp $	*/
/*	$NetBSD: parse.c,v 1.12 2001/12/07 13:37:39 bjh21 Exp $	*/

/*
 * Copyright (c) 1989, 1993
 *	The Regents of the University of California.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */

#include <sys/types.h>
#include <sys/file.h>

#include <ctype.h>
#include <err.h>
#include <errno.h>
#include <fcntl.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#include "hexdump.h"

FU *endfu;					/* format at end-of-data */

static __dead void	 badcnt(char *);
static __dead void	 badconv(char *);
static __dead void	 badfmt(const char *);
static __dead void	 badsfmt(void);
static void		 escape(char *);

void
addfile(char *name)
{
	FILE *fp;
	size_t len;
	char *buf, *lbuf, *p;

	if ((fp = fopen(name, "r")) == NULL)
		err(1, "fopen %s", name);

	lbuf = NULL;
	while ((buf = fgetln(fp, &len))) {
		if (buf[len - 1] == '\n')
			buf[len - 1] = '\0';
		else {
			/* EOF without EOL, copy and add the NUL */
			if ((lbuf = malloc(len + 1)) == NULL)
				err(1, NULL);
			memcpy(lbuf, buf, len);
			lbuf[len] = '\0';
			buf = lbuf;
		}
		for (p = buf; isspace((unsigned char)*p); ++p);
		if (!*p || *p == '#')
			continue;
		add(p);
	}
	free(lbuf);
	(void)fclose(fp);
}

void
add(const char *fmt)
{
	const char *p;
	static FS **nextfs;
	FS *tfs;
	FU *tfu, **nextfu;
	const char *savep;

	/* start new linked list of format units */
	if ((tfs = calloc(1, sizeof(FS))) == NULL)
		err(1, NULL);
	if (!fshead)
		fshead = tfs;
	else
		*nextfs = tfs;
	nextfs = &tfs->nextfs;
	nextfu = &tfs->nextfu;

	/* take the format string and break it up into format units */
	for (p = fmt;;) {
		/* skip leading white space */
		for (; isspace((unsigned char)*p); ++p);
		if (!*p)
			break;

		/* allocate a new format unit and link it in */
		if ((tfu = calloc(1, sizeof(FU))) == NULL)
			err(1, NULL);
		*nextfu = tfu;
		nextfu = &tfu->nextfu;
		tfu->reps = 1;

		/* if leading digit, repetition count */
		if (isdigit((unsigned char)*p)) {
			for (savep = p; isdigit((unsigned char)*p); ++p);
			if (!isspace((unsigned char)*p) && *p != '/')
				badfmt(fmt);
			/* may overwrite either white space or slash */
			tfu->reps = atoi(savep);
			tfu->flags = F_SETREP;
			/* skip trailing white space */
			for (++p; isspace((unsigned char)*p); ++p);
		}

		/* skip slash and trailing white space */
		if (*p == '/')
			while (isspace((unsigned char)*++p));

		/* byte count */
		if (isdigit((unsigned char)*p)) {
			for (savep = p; isdigit((unsigned char)*p); ++p);
			if (!isspace((unsigned char)*p))
				badfmt(fmt);
			tfu->bcnt = atoi(savep);
			/* skip trailing white space */
			for (++p; isspace((unsigned char)*p); ++p);
		}

		/* format */
		if (*p != '"')
			badfmt(fmt);
		for (savep = ++p; *p != '"';)
			if (*p++ == 0)
				badfmt(fmt);
		if ((tfu->fmt = strndup(savep, p - savep)) == NULL)
			err(1, NULL);
		escape(tfu->fmt);
		p++;
	}
}

static const char *spec = ".#-+ 0123456789";

int
size(FS *fs)
{
	FU *fu;
	int bcnt, cursize;
	char *fmt;
	int prec;

	/* figure out the data block size needed for each format unit */
	for (cursize = 0, fu = fs->nextfu; fu; fu = fu->nextfu) {
		if (fu->bcnt) {
			cursize += fu->bcnt * fu->reps;
			continue;
		}
		for (bcnt = prec = 0, fmt = fu->fmt; *fmt; ++fmt) {
			if (*fmt != '%')
				continue;
			/*
			 * skip any special chars -- save precision in
			 * case it's a %s format.
			 */
			while (*++fmt && strchr(spec + 1, *fmt));
			if (*fmt == '.' && isdigit((unsigned char)*++fmt)) {
				prec = atoi(fmt);
				while (isdigit((unsigned char)*++fmt));
			}
			switch(*fmt) {
			case 'c':
				bcnt += 1;
				break;
			case 'd': case 'i': case 'o': case 'u':
			case 'x': case 'X':
				bcnt += 4;
				break;
			case 'e': case 'E': case 'f': case 'g': case 'G':
				bcnt += 8;
				break;
			case 's':
				bcnt += prec;
				break;
			case '_':
				switch(*++fmt) {
				case 'c': case 'p': case 'u':
					bcnt += 1;
					break;
				}
			}
		}
		cursize += bcnt * fu->reps;
	}
	return (cursize);
}

void
rewrite(FS *fs)
{
	enum { NOTOKAY, USEBCNT, USEPREC } sokay;
	PR *pr, **nextpr;
	FU *fu;
	char *p1, *p2;
	char savech, *fmtp, cs[4];
	int nconv, prec;

	nextpr = NULL;
	prec = 0;
	for (fu = fs->nextfu; fu; fu = fu->nextfu) {
		/*
		 * Break each format unit into print units; each conversion
		 * character gets its own.
		 */
		for (nconv = 0, fmtp = fu->fmt; *fmtp; nextpr = &pr->nextpr) {
			if ((pr = calloc(1, sizeof(PR))) == NULL)
				err(1, NULL);
			if (!fu->nextpr)
				fu->nextpr = pr;
			else
				*nextpr = pr;

			/* Skip preceding text and up to the next % sign. */
			for (p1 = fmtp; *p1 && *p1 != '%'; ++p1);

			/* Only text in the string. */
			if (!*p1) {
				pr->fmt = fmtp;
				pr->flags = F_TEXT;
				break;
			}

			/*
			 * Get precision for %s -- if have a byte count, don't
			 * need it.
			 */
			if (fu->bcnt) {
				sokay = USEBCNT;
				/* Skip to conversion character. */
				for (++p1; *p1 && strchr(spec, *p1); ++p1);
			} else {
				/* Skip any special chars, field width. */
				while (*++p1 && strchr(spec + 1, *p1));
				if (*p1 == '.' &&
				    isdigit((unsigned char)*++p1)) {
					sokay = USEPREC;
					prec = atoi(p1);
					while (isdigit((unsigned char)*++p1))
						continue;
				} else
					sokay = NOTOKAY;
			}

			p2 = *p1 ? p1 + 1 : p1;	/* Set end pointer. */
			cs[0] = *p1;		/* Set conversion string. */
			cs[1] = '\0';

			/*
			 * Figure out the byte count for each conversion;
			 * rewrite the format as necessary, set up blank-
			 * padding for end of data.
			 */
			switch(cs[0]) {
			case 'c':
				pr->flags = F_CHAR;
				switch(fu->bcnt) {
				case 0: case 1:
					pr->bcnt = 1;
					break;
				default:
					p1[1] = '\0';
					badcnt(p1);
				}
				break;
			case 'd': case 'i':
			case 'o': case 'u': case 'x': case 'X':
				if (cs[0] == 'd' || cs[0] == 'i')
					pr->flags = F_INT;
				else
					pr->flags = F_UINT;

				cs[3] = '\0';
				cs[2] = cs[0];
				cs[1] = 'l';
				cs[0] = 'l';
				switch(fu->bcnt) {
				case 0: case 4:
					pr->bcnt = 4;
					break;
				case 1:
					pr->bcnt = 1;
					break;
				case 2:
					pr->bcnt = 2;
					break;
				case 8:
					pr->bcnt = 8;
					break;
				default:
					p1[1] = '\0';
					badcnt(p1);
				}
				break;
			case 'e': case 'E': case 'f': case 'g': case 'G':
				pr->flags = F_DBL;
				switch(fu->bcnt) {
				case 0: case 8:
					pr->bcnt = 8;
					break;
				case 4:
					pr->bcnt = 4;
					break;
				default:
					p1[1] = '\0';
					badcnt(p1);
				}
				break;
			case 's':
				pr->flags = F_STR;
				switch(sokay) {
				case NOTOKAY:
					badsfmt();
				case USEBCNT:
					pr->bcnt = fu->bcnt;
					break;
				case USEPREC:
					pr->bcnt = prec;
					break;
				}
				break;
			case '_':
				++p2;
				switch(p1[1]) {
				case 'A':
					endfu = fu;
					fu->flags |= F_IGNORE;
					/* FALLTHROUGH */
				case 'a':
					pr->flags = F_ADDRESS;
					++p2;
					switch(p1[2]) {
					case 'd': case 'o': case'x':
						cs[0] = 'l';
						cs[1] = 'l';
						cs[2] = p1[2];
						cs[3] = '\0';
						break;
					default:
						if (p1[2])
							p1[3] = '\0';
						badconv(p1);
					}
					break;
				case 'c':
				case 'p':
				case 'u':
					if (p1[1] == 'c') {
						pr->flags = F_C;
						/* cs[0] = 'c';	set in conv_c */
					} else if (p1[1] == 'p') {
						pr->flags = F_P;
						cs[0] = 'c';
					} else {
						pr->flags = F_U;
						/* cs[0] = 'c';	set in conv_u */
					}

					switch(fu->bcnt) {
					case 0: case 1:
						pr->bcnt = 1;
						break;
					default:
						p1[2] = '\0';
						badcnt(p1);
					}
					break;
				default:
					if (p1[1])
						p1[2] = '\0';
					badconv(p1);
				}
				break;
			default:
				if (cs[0])
					p1[1] = '\0';
				badconv(p1);
			}

			/*
			 * Copy to PR format string, set conversion character
			 * pointer, update original.
			 */
			savech = *p2;
			p1[0] = '\0';
			if (asprintf(&pr->fmt, "%s%s", fmtp, cs) == -1)
				err(1, NULL);
			*p2 = savech;
			pr->cchar = pr->fmt + (p1 - fmtp);
			fmtp = p2;

			/* Only one conversion character if byte count. */
			if (!(pr->flags&F_ADDRESS) && fu->bcnt && nconv++)
				errx(1,
			    "byte count with multiple conversion characters");
		}
		/*
		 * If format unit byte count not specified, figure it out
		 * so can adjust rep count later.
		 */
		if (!fu->bcnt)
			for (pr = fu->nextpr; pr; pr = pr->nextpr)
				fu->bcnt += pr->bcnt;
	}
	/*
	 * If the format string interprets any data at all, and it's
	 * not the same as the blocksize, and its last format unit
	 * interprets any data at all, and has no iteration count,
	 * repeat it as necessary.
	 *
	 * If, rep count is greater than 1, no trailing whitespace
	 * gets output from the last iteration of the format unit.
	 */
	for (fu = fs->nextfu; fu; fu = fu->nextfu) {
		if (!fu->nextfu && fs->bcnt < blocksize &&
		    !(fu->flags&F_SETREP) && fu->bcnt)
			fu->reps += (blocksize - fs->bcnt) / fu->bcnt;
		if (fu->reps > 1) {
			if (!fu->nextpr)
				break;
			for (pr = fu->nextpr;; pr = pr->nextpr)
				if (!pr->nextpr)
					break;
			for (p1 = pr->fmt, p2 = NULL; *p1; ++p1)
				p2 = isspace((unsigned char)*p1) ? p1 : NULL;
			if (p2)
				pr->nospace = p2;
		}
	}
#ifdef DEBUG
	for (fu = fs->nextfu; fu; fu = fu->nextfu) {
		(void)printf("fmt:");
		for (pr = fu->nextpr; pr; pr = pr->nextpr)
			(void)printf(" {%s}", pr->fmt);
		(void)printf("\n");
	}
#endif
}

static void
escape(char *p1)
{
	char *p2;

	/* alphabetic escape sequences have to be done in place */
	for (p2 = p1;; ++p1, ++p2) {
		if (!*p1) {
			*p2 = *p1;
			break;
		}
		if (*p1 == '\\') {
			switch(*++p1) {
			case '\0':
				*p2++ = '\\';
				*p2 = '\0';
				return;	/* incomplete escape sequence */
			case 'a':
			     /* *p2 = '\a'; */
				*p2 = '\007';
				break;
			case 'b':
				*p2 = '\b';
				break;
			case 'f':
				*p2 = '\f';
				break;
			case 'n':
				*p2 = '\n';
				break;
			case 'r':
				*p2 = '\r';
				break;
			case 't':
				*p2 = '\t';
				break;
			case 'v':
				*p2 = '\v';
				break;
			default:
				*p2 = *p1;
				break;
			}
		} else
			*p2 = *p1;
	}
}

static __dead void
badcnt(char *s)
{
	errx(1, "%s: bad byte count", s);
}

static __dead void
badsfmt(void)
{
	errx(1, "%%s: requires a precision or a byte count");
}

static __dead void
badfmt(const char *fmt)
{
	errx(1, "\"%s\": bad format", fmt);
}

static __dead void
badconv(char *ch)
{
	errx(1, "%%%s: bad conversion character", ch);
}
@


1.21
log
@Convert quad_t to int64_t and %q to %ll
Convert bzero() to memset() and bcopy() to memcpy()

ok natano@@ millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.c,v 1.20 2016/03/15 04:19:13 mmcc Exp $	*/
d150 1
a150 2
		tfu->fmt = strndup(savep, p - savep);
		if (tfu->fmt == NULL)
a220 1
	size_t len;
d409 1
a409 2
			len = strlen(fmtp) + strlen(cs) + 1;
			if ((pr->fmt = calloc(1, len)) == NULL)
a410 1
			snprintf(pr->fmt, len, "%s%s", fmtp, cs);
@


1.20
log
@ o clean up a little whitespace and formatting
 o move some declarations out of hexdump.h
 o mark some declarations as __dead or static

from Michal Mazurek, with input from and ok tb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.c,v 1.19 2016/02/09 02:13:12 mmcc Exp $	*/
d220 1
a220 1
	char savech, *fmtp, cs[3];
d298 4
a301 3
				cs[2] = '\0';
				cs[1] = cs[0];
				cs[0] = 'q';
d359 4
a362 3
						cs[0] = 'q';
						cs[1] = p1[2];
						cs[2] = '\0';
@


1.19
log
@Replace a three step string duplication with strndup().

ok and with input from tb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.c,v 1.18 2016/02/09 01:29:12 tb Exp $	*/
d48 6
d465 1
a465 1
void
d513 1
a513 1
void
d519 1
a519 1
void
d525 1
a525 1
void
d531 1
a531 1
void
@


1.18
log
@For a long time, nomem() has been a wrapper for err(1, NULL) and
meanwhile emalloc() has turned into calloc() by doing malloc + memset.
Delete them and Use the libc functions directly instead. I've been
running with this diff for ages and was reminded of it by a similar
suggestion from mmcc@@ and by recent diffs from Michal Mazurek.

ok mmcc@@
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.c,v 1.17 2009/10/27 23:59:39 deraadt Exp $	*/
d144 2
a145 1
		if ((tfu->fmt = malloc(p - savep + 1)) == NULL)
a146 2
		(void) strncpy(tfu->fmt, savep, p - savep);
		tfu->fmt[p - savep] = '\0';
@


1.17
log
@rcsid[] and sccsid[] and copyright[] are essentially unmaintained (and
unmaintainable).  these days, people use source.  these id's do not provide
any benefit, and do hurt the small install media
(the 33,000 line diff is essentially mechanical)
ok with the idea millert, ok dms
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.c,v 1.16 2007/03/20 03:50:39 tedu Exp $	*/
d89 2
a90 1
	tfs = emalloc(sizeof(FS));
d106 2
a107 1
		tfu = emalloc(sizeof(FU));
d144 2
a145 2
		if (!(tfu->fmt = malloc(p - savep + 1)))
			nomem();
d227 2
a228 1
			pr = emalloc(sizeof(PR));
d405 2
a406 1
			pr->fmt = emalloc(len);
@


1.16
log
@remove some bogus *p tests from charles longeau
ok deraadt millert
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.c,v 1.15 2006/08/23 03:13:09 ray Exp $	*/
a31 5

#ifndef lint
/*static char sccsid[] = "from: @@(#)parse.c	5.6 (Berkeley) 3/9/91";*/
static char rcsid[] = "$OpenBSD: parse.c,v 1.15 2006/08/23 03:13:09 ray Exp $";
#endif /* not lint */
@


1.15
log
@Remove line length limit when reading format strings from a file.

Fixes PR 5208.  Problem reported and fix tested by
jared rr spiegel <jrrs at hklocal dot nodeless dot net>.

OK weingart@@ and millert@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.c,v 1.14 2004/11/21 19:57:16 otto Exp $	*/
d35 1
a35 1
static char rcsid[] = "$OpenBSD: parse.c,v 1.14 2004/11/21 19:57:16 otto Exp $";
d75 1
a75 1
		for (p = buf; *p && isspace((unsigned char)*p); ++p);
@


1.14
log
@Fix some core dumps on malformed format strings. From KAMADA Ken'ichi
in NetBSD PR 28157 with extras, joint work with pat@@. ok pat@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.c,v 1.13 2003/06/12 20:58:09 deraadt Exp $	*/
d35 1
a35 1
static char rcsid[] = "$OpenBSD: parse.c,v 1.13 2003/06/12 20:58:09 deraadt Exp $";
a55 1
	char *p;
d57 2
a58 2
	int ch;
	char buf[2048 + 1];
d62 12
a73 5
	while (fgets(buf, sizeof(buf), fp)) {
		if (!(p = strchr(buf, '\n'))) {
			warnx("line too long.");
			while ((ch = getchar()) != '\n' && ch != EOF);
			continue;
a74 1
		*p = '\0';
d80 1
@


1.13
log
@de-register and ansification; millert ok
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.c,v 1.12 2003/06/03 02:56:09 millert Exp $	*/
d35 1
a35 1
static char rcsid[] = "$OpenBSD: parse.c,v 1.12 2003/06/03 02:56:09 millert Exp $";
d173 1
a173 1
			while (strchr(spec + 1, *++fmt));
d247 1
a247 1
				for (++p1; strchr(spec, *p1); ++p1);
d250 1
a250 1
				while (strchr(spec + 1, *++p1));
d261 1
a261 1
			p2 = p1 + 1;		/* Set end pointer. */
a282 2
				pr->flags = F_INT;
				goto isint;
d284 6
a289 2
				pr->flags = F_UINT;
isint:				cs[2] = '\0';
d354 2
a355 1
						p1[3] = '\0';
a359 3
					pr->flags = F_C;
					/* cs[0] = 'c';	set in conv_c */
					goto isint2;
a360 3
					pr->flags = F_P;
					cs[0] = 'c';
					goto isint2;
d362 12
a373 3
					pr->flags = F_U;
					/* cs[0] = 'c';	set in conv_u */
isint2:					switch(fu->bcnt) {
d383 2
a384 1
					p1[2] = '\0';
d389 2
a390 1
				p1[1] = '\0';
d434 2
d466 1
a466 1
		if (*p1 == '\\')
d468 4
d498 2
@


1.12
log
@Remove the advertising clause in the UCB license which Berkeley
rescinded 22 July 1999.  Proofed by myself and Theo.
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.c,v 1.11 2003/04/05 16:13:47 deraadt Exp $	*/
d35 1
a35 1
static char rcsid[] = "$OpenBSD: parse.c,v 1.11 2003/04/05 16:13:47 deraadt Exp $";
d54 1
a54 2
addfile(name)
	char *name;
d79 1
a79 2
add(fmt)
	const char *fmt;
d153 1
a153 2
size(fs)
	FS *fs;
d206 1
a206 2
rewrite(fs)
	FS *fs;
d446 1
a446 2
escape(p1)
	char *p1;
d488 1
a488 2
badcnt(s)
	char *s;
d494 1
a494 1
badsfmt()
d500 1
a500 2
badfmt(fmt)
	const char *fmt;
d506 1
a506 2
badconv(ch)
	char *ch;
@


1.11
log
@simple strcpy replacement; miod ok
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.c,v 1.10 2002/03/14 06:51:42 mpech Exp $	*/
d16 1
a16 5
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
d35 1
a35 1
static char rcsid[] = "$OpenBSD: parse.c,v 1.10 2002/03/14 06:51:42 mpech Exp $";
@


1.10
log
@Remove \n from err/errx/warn/warnx().

millert@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.c,v 1.9 2001/12/30 08:17:32 pvalchev Exp $	*/
d39 1
a39 1
static char rcsid[] = "$OpenBSD: parse.c,v 1.9 2001/12/30 08:17:32 pvalchev Exp $";
d222 1
d400 3
a402 3
			pr->fmt = emalloc(strlen(fmtp) + strlen(cs) + 1);
			(void)strcpy(pr->fmt, fmtp);
			(void)strcat(pr->fmt, cs);
@


1.9
log
@Changes come from NetBSD, Lite-2 and me.  ok deraadt
od(1):
- Enable support for printing 8-byte integers.
- Added -C option for hexadecimal+ASCII display.
- Fix od so it displays short files containing nulls.
- POSIXification: The C, S, I and L modifiers now behave correctly,
specifying output in units of a char, short, int and long (as defined by
the host system) respectively.  Support -N, equivalent to hexdump's
-n (format only COUNT bytes of input).  Add -j option which does the
same thing as -s in hexdump (skipping some of the input).
hexdump(1):
- POSIX.2 doesn't specify hexdump so it can't be compatible with it...
- add missing trailing \n in usage() printf
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.c,v 1.8 2001/11/19 19:02:14 mpech Exp $	*/
d39 1
a39 1
static char rcsid[] = "$OpenBSD: parse.c,v 1.8 2001/11/19 19:02:14 mpech Exp $";
d505 1
a505 1
	errx(1, "%%s: requires a precision or a byte count\n");
d512 1
a512 1
	errx(1, "\"%s\": bad format\n", fmt);
d519 1
a519 1
	errx(1, "%%%s: bad conversion character\n", ch);
@


1.8
log
@kill more registers

millert@@ ok
@
text
@d1 2
a2 1
/*	$OpenBSD: parse.c,v 1.7 2001/11/02 19:41:06 mickey Exp $	*/
d5 2
a6 2
 * Copyright (c) 1989 The Regents of the University of California.
 * All rights reserved.
d39 1
a39 1
static char rcsid[] = "$OpenBSD: parse.c,v 1.7 2001/11/02 19:41:06 mickey Exp $";
d44 5
a50 1
#include <ctype.h>
d52 1
a52 1
#include <err.h>
a54 6
void addfile __P((char *));
void add __P((char *));
int size __P((FS *));
void rewrite __P((FS *));
void escape __P((char *));

d63 2
a64 1
	size_t len;
d66 6
a71 7
	if (!(fp = fopen(name, "r")))
		err(1, "%s", name);
	while ((p = fgetln(fp, &len))) {
		if (*(p + len - 1) == '\n')
			*(p + len - 1) = '\0';
		else {
			warnx("incomplete line");
d74 2
a75 1
		for (; *p && isspace(*p); ++p);
d85 1
a85 1
	char *fmt;
d87 1
a87 1
	char *p;
d91 1
a91 1
	char *savep, *emalloc();
d94 1
a94 2
	/* NOSTRICT */
	tfs = (FS *)emalloc(sizeof(FS));
d105 1
a105 1
		for (; isspace(*p); ++p);
d110 1
a110 2
		/* NOSTRICT */
		tfu = (FU *)emalloc(sizeof(FU));
d116 4
a119 4
		if (isdigit(*p)) {
			for (savep = p; isdigit(*p); ++p);
			if (!isspace(*p) && *p != '/')
				errx(1, "bad format {%s}", fmt);
d124 1
a124 1
			for (++p; isspace(*p); ++p);
d129 1
a129 1
			while (isspace(*++p));
d132 4
a135 4
		if (isdigit(*p)) {
			for (savep = p; isdigit(*p); ++p);
			if (!isspace(*p))
				errx(1, "bad format {%s}", fmt);
d138 1
a138 1
			for (++p; isspace(*p); ++p);
d143 1
a143 1
			errx(1, "bad format {%s}", fmt);
d146 1
a146 1
				errx(1, "bad format {%s}", fmt);
d148 1
a148 1
			err(1, "malloc");
a153 3
	/* no single fu in fmt */
	if (tfs->nextfu == NULL)
		errx(1, "bad format {%s}", fmt);
d157 1
d181 1
a181 1
			if (*fmt == '.' && isdigit(*++fmt)) {
d183 1
a183 1
				while (isdigit(*++fmt));
d209 1
a209 1
	return(cursize);
d220 1
a220 1
	char savech, *fmtp;
d223 2
d227 2
a228 2
		 * break each format unit into print units; each
		 * conversion character gets its own.
d231 1
a231 2
			/* NOSTRICT */
			pr = (PR *)emalloc(sizeof(PR));
d237 1
a237 1
			/* skip preceding text and up to the next % sign */
d240 1
a240 1
			/* only text in the string */
d248 1
a248 1
			 * get precision for %s -- if have a byte count, don't
d253 1
a253 1
				/* skip to conversion character */
d256 1
a256 1
				/* skip any special chars, field width */
d258 2
a259 1
				if (*p1 == '.' && isdigit(*++p1)) {
d262 3
a264 3
					while (isdigit(*++p1));
				}
				else
d268 3
a270 1
			p2 = p1 + 1;		/* set end pointer */
d273 1
a273 1
			 * figure out the byte count for each conversion;
d277 1
a277 1
			switch(*p1) {
d285 2
a286 1
					errx(1, "bad byte count for conversion character \'%c\'", *p1);
d291 1
a291 17
				goto sw1;
			case 'l':
				++p2;
				switch(p1[1]) {
				case 'd': case 'i':
					++p1;
					pr->flags = F_INT;
					goto sw1;
				case 'o': case 'u': case 'x': case 'X':
					++p1;
					pr->flags = F_UINT;
					goto sw1;
				default:
					p1[2] = '\0';
					errx(1, "bad conversion character %%%s", p1);
				}
				/* NOTREACHED */
d294 4
a297 1
sw1:				switch(fu->bcnt) {
d307 3
d311 2
a312 1
					errx(1, "bad byte count for conversion character \'%c\'", *p1);
d325 2
a326 1
					errx(1, "bad byte count for conversion character \'%c\'", *p1);
d333 1
a333 1
					errx(1, "%%s requires a precision or a byte count");
d354 3
a356 2
						*p1 = 'q';
						p1[1] = p1[2];
d360 1
a360 1
						errx(1, "bad conversion character %%%s", p1);
d365 2
a366 2
					/* *p1 = 'c';	set in conv_c */
					goto sw2;
d369 2
a370 2
					*p1 = 'c';
					goto sw2;
d373 2
a374 2
					/* *p1 = 'c';	set in conv_u */
sw2:					switch(fu->bcnt) {
d380 1
a380 1
						errx(1, "bad byte count for conversion character \'%s\'", p1);
d385 1
a385 1
					errx(1, "bad conversion character %%%s", p1);
d389 2
a390 1
				errx(1, "bad conversion character %%%c", *p1);
d394 1
a394 1
			 * copy to PR format string, set conversion character
d398 4
a401 3
			p1[(pr->flags&F_ADDRESS)?2:1] = '\0';
			if (!(pr->fmt = strdup(fmtp)))
				err(1, "malloc");
d406 1
a406 1
			/* only one conversion character if byte count */
d409 1
a409 1
				    "byte count with multiple conversion characters");
d412 1
a412 1
		 * if format unit byte count not specified, figure it out
d420 1
a420 1
	 * if the format string interprets any data at all, and it's
d425 1
a425 1
	 * if, rep count is greater than 1, no trailing whitespace
d428 1
a428 1
	for (fu = fs->nextfu;; fu = fu->nextfu) {
d437 1
a437 1
				p2 = isspace(*p1) ? p1 : NULL;
a440 2
		if (!fu->nextfu)
			break;
d442 8
d493 27
@


1.7
log
@replace fprintf(stderr)/exit w/ err/warn
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.c,v 1.6 2001/09/30 07:17:03 pvalchev Exp $	*/
d38 1
a38 1
static char rcsid[] = "$OpenBSD: parse.c,v 1.6 2001/09/30 07:17:03 pvalchev Exp $";
d62 1
a62 1
	register char *p;
d87 1
a87 1
	register char *p;
d166 3
a168 3
	register FU *fu;
	register int bcnt, cursize;
	register char *fmt;
d221 3
a223 3
	register PR *pr, **nextpr;
	register FU *fu;
	register char *p1, *p2;
d452 1
a452 1
	register char *p1;
d454 1
a454 1
	register char *p2;
@


1.6
log
@-Wall cleanup; ok deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.c,v 1.5 1999/02/07 20:54:09 aaron Exp $	*/
d38 1
a38 1
static char rcsid[] = "$OpenBSD: parse.c,v 1.5 1999/02/07 20:54:09 aaron Exp $";
d47 1
d50 6
d66 2
a67 4
	if (!(fp = fopen(name, "r"))) {
		(void)fprintf(stderr, "hexdump: can't read %s.\n", name);
		exit(1);
	}
d72 1
a72 1
			(void)fprintf(stderr, "hexdump: incomplete line.\n");
d121 1
a121 1
				badfmt(fmt);
d137 1
a137 1
				badfmt(fmt);
d145 1
a145 1
			badfmt(fmt);
d148 1
a148 1
				badfmt(fmt);
d150 1
a150 1
			nomem();
d158 1
a158 1
		badfmt(fmt);
d161 1
a161 1
static char *spec = ".#-+ 0123456789";
d285 1
a285 2
					p1[1] = '\0';
					badcnt(p1);
d304 1
a304 1
					badconv(p1);
d320 1
a320 2
					p1[1] = '\0';
					badcnt(p1);
d333 1
a333 2
					p1[1] = '\0';
					badcnt(p1);
d340 1
a340 1
					badsfmt();
d366 1
a366 1
						badconv(p1);
d386 1
a386 1
						badcnt(p1);
d391 1
a391 1
					badconv(p1);
d395 1
a395 2
				p1[1] = '\0';
				badconv(p1);
d405 1
a405 1
				nomem();
d411 3
a413 5
			if (!(pr->flags&F_ADDRESS) && fu->bcnt && nconv++) {
				(void)fprintf(stderr,
				    "hexdump: byte count with multiple conversion characters.\n");
				exit(1);
			}
a449 1

a490 33
}

void
badcnt(s)
	char *s;
{
	(void)fprintf(stderr,
	    "hexdump: bad byte count for conversion character %s.\n", s);
	exit(1);
}

void
badsfmt()
{
	(void)fprintf(stderr,
	    "hexdump: %%s requires a precision or a byte count.\n");
	exit(1);
}

void
badfmt(fmt)
	char *fmt;
{
	(void)fprintf(stderr, "hexdump: bad format {%s}\n", fmt);
	exit(1);
}

void
badconv(ch)
	char *ch;
{
	(void)fprintf(stderr, "hexdump: bad conversion character %%%s.\n", ch);
	exit(1);
@


1.5
log
@fgets -> fgetln, don't lie about lines being too long
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.c,v 1.4 1998/08/11 22:06:27 provos Exp $	*/
d38 1
a38 1
static char rcsid[] = "$OpenBSD: parse.c,v 1.4 1998/08/11 22:06:27 provos Exp $";
d51 1
d78 1
d157 1
d211 1
d452 1
d495 1
d504 1
d512 1
d520 1
@


1.4
log
@detect a format string of spaces only as bad format.
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.c,v 1.3 1997/01/17 07:12:39 millert Exp $	*/
d38 1
a38 1
static char rcsid[] = "$OpenBSD: parse.c,v 1.3 1997/01/17 07:12:39 millert Exp $";
d56 1
a56 2
	int ch;
	char buf[2048 + 1];
d62 5
a66 4
	while (fgets(buf, sizeof(buf), fp)) {
		if (!(p = strchr(buf, '\n'))) {
			(void)fprintf(stderr, "hexdump: line too long.\n");
			while ((ch = getchar()) != '\n' && ch != EOF);
d69 1
a69 2
		*p = '\0';
		for (p = buf; *p && isspace(*p); ++p);
@


1.3
log
@r?index -> strr?chr
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.c,v 1.2 1996/06/26 05:34:21 deraadt Exp $	*/
d38 1
a38 1
static char rcsid[] = "$OpenBSD: parse.c,v 1.2 1996/06/26 05:34:21 deraadt Exp $";
d150 3
@


1.2
log
@rcsid
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d38 1
a38 1
static char rcsid[] = "$OpenBSD: parse.c,v 1.1.1.1 1995/10/18 08:45:23 deraadt Exp $";
d64 1
a64 1
		if (!(p = index(buf, '\n'))) {
d174 1
a174 1
			while (index(spec + 1, *++fmt));
d246 1
a246 1
				for (++p1; index(spec, *p1); ++p1);
d249 1
a249 1
				while (index(spec + 1, *++p1));
@


1.1
log
@Initial revision
@
text
@d1 2
d38 1
a38 1
static char rcsid[] = "$Id: parse.c,v 1.3 1994/05/20 15:57:26 pk Exp $";
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@
