head	1.38;
access;
symbols
	OPENBSD_6_2_BASE:1.38
	OPENBSD_6_1:1.38.0.6
	OPENBSD_6_1_BASE:1.38
	OPENBSD_6_0:1.38.0.2
	OPENBSD_6_0_BASE:1.38
	OPENBSD_5_9:1.37.0.2
	OPENBSD_5_9_BASE:1.37
	OPENBSD_5_8:1.35.0.6
	OPENBSD_5_8_BASE:1.35
	OPENBSD_5_7:1.35.0.2
	OPENBSD_5_7_BASE:1.35
	OPENBSD_5_6:1.32.0.6
	OPENBSD_5_6_BASE:1.32
	OPENBSD_5_5:1.32.0.4
	OPENBSD_5_5_BASE:1.32
	OPENBSD_5_4:1.30.0.14
	OPENBSD_5_4_BASE:1.30
	OPENBSD_5_3:1.30.0.12
	OPENBSD_5_3_BASE:1.30
	OPENBSD_5_2:1.30.0.10
	OPENBSD_5_2_BASE:1.30
	OPENBSD_5_1_BASE:1.30
	OPENBSD_5_1:1.30.0.8
	OPENBSD_5_0:1.30.0.6
	OPENBSD_5_0_BASE:1.30
	OPENBSD_4_9:1.30.0.4
	OPENBSD_4_9_BASE:1.30
	OPENBSD_4_8:1.30.0.2
	OPENBSD_4_8_BASE:1.30
	OPENBSD_4_7:1.29.0.2
	OPENBSD_4_7_BASE:1.29
	OPENBSD_4_6:1.28.0.10
	OPENBSD_4_6_BASE:1.28
	OPENBSD_4_5:1.28.0.6
	OPENBSD_4_5_BASE:1.28
	OPENBSD_4_4:1.28.0.4
	OPENBSD_4_4_BASE:1.28
	OPENBSD_4_3:1.28.0.2
	OPENBSD_4_3_BASE:1.28
	OPENBSD_4_2:1.27.0.10
	OPENBSD_4_2_BASE:1.27
	OPENBSD_4_1:1.27.0.8
	OPENBSD_4_1_BASE:1.27
	OPENBSD_4_0:1.27.0.6
	OPENBSD_4_0_BASE:1.27
	OPENBSD_3_9:1.27.0.4
	OPENBSD_3_9_BASE:1.27
	OPENBSD_3_8:1.27.0.2
	OPENBSD_3_8_BASE:1.27
	OPENBSD_3_7:1.24.0.2
	OPENBSD_3_7_BASE:1.24
	OPENBSD_3_6:1.23.0.6
	OPENBSD_3_6_BASE:1.23
	OPENBSD_3_5:1.23.0.4
	OPENBSD_3_5_BASE:1.23
	OPENBSD_3_4:1.23.0.2
	OPENBSD_3_4_BASE:1.23
	OPENBSD_3_3:1.21.0.2
	OPENBSD_3_3_BASE:1.21
	OPENBSD_3_2:1.20.0.2
	OPENBSD_3_2_BASE:1.20
	OPENBSD_3_1:1.19.0.2
	OPENBSD_3_1_BASE:1.19
	OPENBSD_3_0:1.16.0.6
	OPENBSD_3_0_BASE:1.16
	OPENBSD_2_9_BASE:1.16
	OPENBSD_2_9:1.16.0.4
	OPENBSD_2_8:1.16.0.2
	OPENBSD_2_8_BASE:1.16
	OPENBSD_2_7:1.14.0.2
	OPENBSD_2_7_BASE:1.14
	OPENBSD_2_6:1.13.0.2
	OPENBSD_2_6_BASE:1.13
	OPENBSD_2_5:1.12.0.4
	OPENBSD_2_5_BASE:1.12
	OPENBSD_2_4:1.12.0.2
	OPENBSD_2_4_BASE:1.12
	OPENBSD_2_3:1.9.0.6
	OPENBSD_2_3_BASE:1.9
	OPENBSD_2_2:1.9.0.4
	OPENBSD_2_2_BASE:1.9
	OPENBSD_2_1:1.9.0.2
	OPENBSD_2_1_BASE:1.9
	OPENBSD_2_0:1.7.0.2
	OPENBSD_2_0_BASE:1.7
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.38
date	2016.03.16.15.41.11;	author krw;	state Exp;
branches;
next	1.37;
commitid	JEVxsRygqcjPtWTf;

1.37
date	2015.12.09.19.39.10;	author mmcc;	state Exp;
branches;
next	1.36;
commitid	vYfMHQk0uPOMI7wA;

1.36
date	2015.08.20.22.32.41;	author deraadt;	state Exp;
branches;
next	1.35;
commitid	0Dp7Dy9FuNZesYo2;

1.35
date	2015.02.08.23.40.34;	author deraadt;	state Exp;
branches;
next	1.34;
commitid	yGZX28AeTChVE8eY;

1.34
date	2015.01.17.17.22.07;	author deraadt;	state Exp;
branches;
next	1.33;
commitid	xBtcQpBJvH9Ql1dM;

1.33
date	2015.01.16.06.40.10;	author deraadt;	state Exp;
branches;
next	1.32;
commitid	Uu5nFG3wCl0LACBb;

1.32
date	2013.11.26.13.19.07;	author deraadt;	state Exp;
branches;
next	1.31;

1.31
date	2013.11.08.15.21.20;	author jsing;	state Exp;
branches;
next	1.30;

1.30
date	2010.04.08.02.43.57;	author william;	state Exp;
branches;
next	1.29;

1.29
date	2009.10.27.23.59.41;	author deraadt;	state Exp;
branches;
next	1.28;

1.28
date	2007.12.30.13.32.19;	author sobrado;	state Exp;
branches;
next	1.27;

1.27
date	2005.05.05.19.17.11;	author jmc;	state Exp;
branches;
next	1.26;

1.26
date	2005.04.03.19.02.30;	author otto;	state Exp;
branches;
next	1.25;

1.25
date	2005.04.01.04.31.09;	author deraadt;	state Exp;
branches;
next	1.24;

1.24
date	2004.10.10.03.31.20;	author mickey;	state Exp;
branches;
next	1.23;

1.23
date	2003.06.10.22.20.49;	author deraadt;	state Exp;
branches;
next	1.22;

1.22
date	2003.06.03.02.56.14;	author millert;	state Exp;
branches;
next	1.21;

1.21
date	2003.03.15.19.16.10;	author deraadt;	state Exp;
branches;
next	1.20;

1.20
date	2002.05.14.12.24.10;	author fgsch;	state Exp;
branches;
next	1.19;

1.19
date	2002.02.17.19.42.31;	author millert;	state Exp;
branches;
next	1.18;

1.18
date	2002.02.16.21.27.51;	author millert;	state Exp;
branches;
next	1.17;

1.17
date	2001.12.01.19.00.34;	author deraadt;	state Exp;
branches;
next	1.16;

1.16
date	2000.10.18.23.05.16;	author pjanzen;	state Exp;
branches;
next	1.15;

1.15
date	2000.10.18.22.15.29;	author pjanzen;	state Exp;
branches;
next	1.14;

1.14
date	2000.02.01.03.23.36;	author deraadt;	state Exp;
branches;
next	1.13;

1.13
date	99.08.06.20.41.07;	author deraadt;	state Exp;
branches;
next	1.12;

1.12
date	98.07.13.02.11.41;	author millert;	state Exp;
branches;
next	1.11;

1.11
date	98.07.10.08.50.35;	author deraadt;	state Exp;
branches;
next	1.10;

1.10
date	98.07.10.08.17.39;	author deraadt;	state Exp;
branches;
next	1.9;

1.9
date	97.01.17.07.13.08;	author millert;	state Exp;
branches;
next	1.8;

1.8
date	96.10.28.04.08.21;	author millert;	state Exp;
branches;
next	1.7;

1.7
date	96.08.07.14.08.52;	author etheisen;	state Exp;
branches;
next	1.6;

1.6
date	96.08.06.18.38.48;	author deraadt;	state Exp;
branches;
next	1.5;

1.5
date	96.06.26.05.38.01;	author deraadt;	state Exp;
branches;
next	1.4;

1.4
date	96.04.25.11.04.06;	author deraadt;	state Exp;
branches;
next	1.3;

1.3
date	96.04.21.23.43.38;	author deraadt;	state Exp;
branches;
next	1.2;

1.2
date	95.11.25.16.46.24;	author deraadt;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.45.58;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.45.58;	author deraadt;	state Exp;
branches;
next	;


desc
@@


1.38
log
@More "(<blah> *)0" -> NULL, avoiding any stdarg functions.

Feedback millert@@ kettenis@@
@
text
@/*	$OpenBSD: quota.c,v 1.37 2015/12/09 19:39:10 mmcc Exp $	*/

/*
 * Copyright (c) 1980, 1990, 1993
 *	The Regents of the University of California.  All rights reserved.
 *
 * This code is derived from software contributed to Berkeley by
 * Robert Elz at The University of Melbourne.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */

/*
 * Disk quota reporting program.
 */
#include <sys/param.h>	/* DEV_BSIZE dbtob */
#include <sys/types.h>
#include <sys/file.h>
#include <sys/stat.h>
#include <sys/mount.h>
#include <sys/socket.h>

#include <ufs/ufs/quota.h>
#include <ctype.h>
#include <err.h>
#include <errno.h>
#include <fstab.h>
#include <grp.h>
#include <netdb.h>
#include <pwd.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <time.h>
#include <unistd.h>

#include <rpc/rpc.h>
#include <rpc/pmap_prot.h>
#include <rpcsvc/rquota.h>

char *qfname = QUOTAFILENAME;
char *qfextension[] = INITQFNAMES;

struct quotause {
	struct	quotause *next;
	long	flags;
	struct	dqblk dqblk;
	char	fsname[PATH_MAX + 1];
};
#define	FOUND	0x01

int	alldigits(char *);
int	callaurpc(char *, int, int, int, xdrproc_t, void *, xdrproc_t, void *);
int	getnfsquota(struct statfs *, struct fstab *, struct quotause *,
	    long, int);
struct quotause
       *getprivs(long id, int quotatype);
int	getufsquota(struct statfs *, struct fstab *, struct quotause *,
	    long, int);
void	heading(int, u_long, const char *, const char *);
void	showgid(gid_t);
void	showgrpname(const char *);
void	showquotas(int, u_long, const char *);
void	showuid(uid_t);
void	showusrname(const char *);
char   *timeprt(time_t seconds);
int	ufshasquota(struct fstab *, int, char **);
void	usage(void);

int	qflag;
int	vflag;

int
main(int argc, char *argv[])
{
	int ngroups; 
	gid_t mygid, gidset[NGROUPS_MAX];
	int i, gflag = 0, uflag = 0;
	int ch;
	extern char *optarg;
	extern int optind;

	while ((ch = getopt(argc, argv, "ugvq")) != -1) {
		switch(ch) {
		case 'g':
			gflag = 1;
			break;
		case 'u':
			uflag = 1;
			break;
		case 'v':
			vflag = 1;
			break;
		case 'q':
			qflag = 1;
			break;
		default:
			usage();
		}
	}
	argc -= optind;
	argv += optind;
	if (!uflag && !gflag)
		uflag = 1;
	if (argc == 0) {
		if (uflag)
			showuid(getuid());
		if (gflag) {
			mygid = getgid();
			ngroups = getgroups(NGROUPS_MAX, gidset);
			if (ngroups < 0)
				err(1, "getgroups");
			showgid(mygid);
			for (i = 0; i < ngroups; i++)
				if (gidset[i] != mygid)
					showgid(gidset[i]);
		}
		exit(0);
	}
	if (uflag && gflag)
		usage();
	if (uflag) {
		for (; argc > 0; argc--, argv++) {
			if (alldigits(*argv))
				showuid(atoi(*argv));
			else
				showusrname(*argv);
		}
		exit(0);
	}
	if (gflag) {
		for (; argc > 0; argc--, argv++) {
			if (alldigits(*argv))
				showgid(atoi(*argv));
			else
				showgrpname(*argv);
		}
		exit(0);
	}
	/* NOTREACHED */

	exit(1);
}

void
usage(void)
{
	fprintf(stderr, "%s\n%s\n%s\n",
	    "usage: quota [-q | -v] [-gu]",
	    "       quota [-q | -v] -g group ...",
	    "       quota [-q | -v] -u user ...");
	exit(1);
}

/*
 * Print out quotas for a specified user identifier.
 */
void
showuid(uid_t uid)
{
	struct passwd *pwd = getpwuid(uid);
	uid_t myuid;
	const char *name;

	if (pwd == NULL)
		name = "(no account)";
	else
		name = pwd->pw_name;
	myuid = getuid();
	if (uid != myuid && myuid != 0) {
		warnx("%s (uid %u): permission denied", name, uid);
		return;
	}
	showquotas(USRQUOTA, uid, name);
}

/*
 * Print out quotas for a specified user name.
 */
void
showusrname(const char *name)
{
	struct passwd *pwd = getpwnam(name);
	uid_t myuid;

	if (pwd == NULL) {
		warnx("%s: unknown user", name);
		return;
	}
	myuid = getuid();
	if (pwd->pw_uid != myuid && myuid != 0) {
		warnx("%s (uid %u): permission denied", pwd->pw_name,
		    pwd->pw_uid);
		return;
	}
	showquotas(USRQUOTA, pwd->pw_uid, pwd->pw_name);
}

/*
 * Print out quotas for a specified group identifier.
 */
void
showgid(gid_t gid)
{
	struct group *grp = getgrgid(gid);
	int ngroups;
	gid_t mygid, gidset[NGROUPS_MAX];
	int i;
	const char *name;

	if (grp == NULL)
		name = "(no entry)";
	else
		name = grp->gr_name;
	mygid = getgid();
	ngroups = getgroups(NGROUPS_MAX, gidset);
	if (ngroups < 0) {
		warn("getgroups");
		return;
	}
	if (gid != mygid) {
		for (i = 0; i < ngroups; i++)
			if (gid == gidset[i])
				break;
		if (i >= ngroups && getuid() != 0) {
			warnx("%s (gid %u): permission denied", name, gid);
			return;
		}
	}
	showquotas(GRPQUOTA, gid, name);
}

/*
 * Print out quotas for a specified group name.
 */
void
showgrpname(const char *name)
{
	struct group *grp = getgrnam(name);
	int ngroups;
	gid_t mygid, gidset[NGROUPS_MAX];
	int i;

	if (grp == NULL) {
		warnx("%s: unknown group", name);
		return;
	}
	mygid = getgid();
	ngroups = getgroups(NGROUPS_MAX, gidset);
	if (ngroups < 0) {
		warn("getgroups");
		return;
	}
	if (grp->gr_gid != mygid) {
		for (i = 0; i < ngroups; i++)
			if (grp->gr_gid == gidset[i])
				break;
		if (i >= ngroups && getuid() != 0) {
			warnx("%s (gid %u): permission denied",
			    grp->gr_name, grp->gr_gid);
			return;
		}
	}
	showquotas(GRPQUOTA, grp->gr_gid, grp->gr_name);
}

void
showquotas(int type, u_long id, const char *name)
{
	struct quotause *qup;
	struct quotause *quplist;
	char *msgi, *msgb, *nam;
	uid_t lines = 0;
	static time_t now;

	if (now == 0)
		time(&now);
	quplist = getprivs(id, type);
	for (qup = quplist; qup; qup = qup->next) {
		if (!vflag &&
		    qup->dqblk.dqb_isoftlimit == 0 &&
		    qup->dqblk.dqb_ihardlimit == 0 &&
		    qup->dqblk.dqb_bsoftlimit == 0 &&
		    qup->dqblk.dqb_bhardlimit == 0)
			continue;
		msgi = NULL;
		if (qup->dqblk.dqb_ihardlimit &&
		    qup->dqblk.dqb_curinodes >= qup->dqblk.dqb_ihardlimit)
			msgi = "File limit reached on";
		else if (qup->dqblk.dqb_isoftlimit &&
		    qup->dqblk.dqb_curinodes >= qup->dqblk.dqb_isoftlimit) {
			if (qup->dqblk.dqb_itime > now)
				msgi = "In file grace period on";
			else
				msgi = "Over file quota on";
		}
		msgb = NULL;
		if (qup->dqblk.dqb_bhardlimit &&
		    qup->dqblk.dqb_curblocks >= qup->dqblk.dqb_bhardlimit)
			msgb = "Block limit reached on";
		else if (qup->dqblk.dqb_bsoftlimit &&
		    qup->dqblk.dqb_curblocks >= qup->dqblk.dqb_bsoftlimit) {
			if (qup->dqblk.dqb_btime > now)
				msgb = "In block grace period on";
			else
				msgb = "Over block quota on";
		}
		if (qflag) {
			if ((msgi != NULL || msgb != NULL) &&
			    lines++ == 0)
				heading(type, id, name, "");
			if (msgi != NULL)
				printf("\t%s %s\n", msgi, qup->fsname);
			if (msgb != NULL)
				printf("\t%s %s\n", msgb, qup->fsname);
			continue;
		}
		if (vflag ||
		    qup->dqblk.dqb_curblocks ||
		    qup->dqblk.dqb_curinodes) {
			if (lines++ == 0)
				heading(type, id, name, "");
			nam = qup->fsname;
			if (strlen(qup->fsname) > 15) {
				printf("%s\n", qup->fsname);
				nam = "";
			} 
			printf("%12s %7d%c %7d %7d %7s",
			    nam,
			    (int)(dbtob((u_quad_t)qup->dqblk.dqb_curblocks)
				/ 1024),
			    (msgb == NULL) ? ' ' : '*',
			    (int)(dbtob((u_quad_t)qup->dqblk.dqb_bsoftlimit)
				/ 1024),
			    (int)(dbtob((u_quad_t)qup->dqblk.dqb_bhardlimit)
				/ 1024),
			    (msgb == NULL) ? ""
			        : timeprt(qup->dqblk.dqb_btime));
			printf(" %7d%c %7d %7d %7s\n",
			    qup->dqblk.dqb_curinodes,
			    (msgi == NULL) ? ' ' : '*',
			    qup->dqblk.dqb_isoftlimit,
			    qup->dqblk.dqb_ihardlimit,
			    (msgi == NULL) ? ""
			        : timeprt(qup->dqblk.dqb_itime)
			);
			continue;
		}
	}
	if (!qflag && lines == 0)
		heading(type, id, name, "none");
}

void
heading(int type, u_long id, const char *name, const char *tag)
{

	printf("Disk quotas for %s %s (%cid %ld): %s\n", qfextension[type],
	    name, *qfextension[type], id, tag);
	if (!qflag && tag[0] == '\0') {
		printf("%12s%8s%9s%8s%8s%9s%8s%8s%8s\n",
		    "Filesystem",
		    "KBytes",
		    "quota",
		    "limit",
		    "grace",
		    "files",
		    "quota",
		    "limit",
		    "grace");
	}
}

/*
 * Calculate the grace period and return a printable string for it.
 */
char *
timeprt(time_t seconds)
{
	time_t hours, minutes;
	static char buf[20];
	static time_t now;

	if (now == 0)
		time(&now);
	if (now > seconds)
		return ("none");
	seconds -= now;
	minutes = (seconds + 30) / 60;
	hours = (minutes + 30) / 60;
	if (hours >= 36) {
		(void)snprintf(buf, sizeof buf, "%ddays",
		    (int)((hours + 12) / 24));
		return (buf);
	}
	if (minutes >= 60) {
		(void)snprintf(buf, sizeof buf, "%2d:%d",
		    (int)(minutes / 60), (int)(minutes % 60));
		return (buf);
	}
	(void)snprintf(buf, sizeof buf, "%2d", (int)minutes);
	return (buf);
}

/*
 * Collect the requested quota information.
 */
struct quotause *
getprivs(long id, int quotatype)
{
	struct quotause *qup, *quptail;
	struct fstab *fs;
	struct quotause *quphead;
	struct statfs *fst;
	int nfst, i;

	qup = quphead = NULL;

	nfst = getmntinfo(&fst, MNT_WAIT);
	if (nfst == 0)
		errx(2, "no filesystems mounted!");
	setfsent();
	for (i = 0; i < nfst; i++) {
		if (qup == NULL) {
			if ((qup = malloc(sizeof *qup)) == NULL)
				errx(2, "out of memory");
		}
		if (strncmp(fst[i].f_fstypename, "nfs", MFSNAMELEN) == 0) {
			if (getnfsquota(&fst[i], NULL, qup, id, quotatype) == 0)
				continue;
		} else if (!strncmp(fst[i].f_fstypename, "ffs", MFSNAMELEN) ||
		    !strncmp(fst[i].f_fstypename, "ufs", MFSNAMELEN) ||
		    !strncmp(fst[i].f_fstypename, "mfs", MFSNAMELEN)) {
			/*
			 * XXX
			 * UFS filesystems must be in /etc/fstab, and must
			 * indicate that they have quotas on (?!) This is quite
			 * unlike SunOS where quotas can be enabled/disabled
			 * on a filesystem independent of /etc/fstab, and it
			 * will still print quotas for them.
			 */
			if ((fs = getfsspec(fst[i].f_mntfromspec)) == NULL)
				continue;
			if (getufsquota(&fst[i], fs, qup, id, quotatype) == 0)
				continue;
		} else
			continue;
		strncpy(qup->fsname, fst[i].f_mntonname, sizeof qup->fsname-1);
		qup->fsname[sizeof qup->fsname-1] = '\0';
		if (quphead == NULL)
			quphead = qup;
		else
			quptail->next = qup;
		quptail = qup;
		quptail->next = 0;
		qup = NULL;
	}
	free(qup);
	endfsent();
	return (quphead);
}

/*
 * Check to see if a particular quota is to be enabled.
 */
int
ufshasquota(struct fstab *fs, int type, char **qfnamep)
{
	static char initname, usrname[100], grpname[100];
	static char buf[BUFSIZ];
	char *opt, *cp;

	cp = NULL;
	if (!initname) {
		(void)snprintf(usrname, sizeof usrname, "%s%s",
		    qfextension[USRQUOTA], qfname);
		(void)snprintf(grpname, sizeof grpname, "%s%s",
		    qfextension[GRPQUOTA], qfname);
		initname = 1;
	}
	strncpy(buf, fs->fs_mntops, sizeof buf);
	buf[sizeof(buf) - 1] = '\0';
	for (opt = strtok(buf, ","); opt; opt = strtok(NULL, ",")) {
		if ((cp = strchr(opt, '=')))
			*cp++ = '\0';
		if (type == USRQUOTA && strcmp(opt, usrname) == 0)
			break;
		if (type == GRPQUOTA && strcmp(opt, grpname) == 0)
			break;
	}
	if (!opt)
		return (0);
	if (cp) {
		*qfnamep = cp;
		return (1);
	}
	(void)snprintf(buf, sizeof buf, "%s/%s.%s",
	    fs->fs_file, qfname, qfextension[type]);
	*qfnamep = buf;
	return (1);
}

int
getufsquota(struct statfs *fst, struct fstab *fs, struct quotause *qup,
    long id, int quotatype)
{
	char *qfpathname;
	int fd, qcmd;

	qcmd = QCMD(Q_GETQUOTA, quotatype);
	if (!ufshasquota(fs, quotatype, &qfpathname))
		return (0);

	if (quotactl(fs->fs_file, qcmd, id, (char *)&qup->dqblk) != 0) {
		if ((fd = open(qfpathname, O_RDONLY)) < 0) {
			warn("%s", qfpathname);
			return (0);
		}
		(void)lseek(fd, (off_t)(id * sizeof(struct dqblk)), SEEK_SET);
		switch (read(fd, &qup->dqblk, sizeof(struct dqblk))) {
		case 0:				/* EOF */
			/*
			 * Convert implicit 0 quota (EOF)
			 * into an explicit one (zero'ed dqblk)
			 */
			memset((caddr_t)&qup->dqblk, 0, sizeof(struct dqblk));
			break;
		case sizeof(struct dqblk):	/* OK */
			break;
		default:		/* ERROR */
			warn("%s", qfpathname);
			close(fd);
			return (0);
		}
		close(fd);
	}
	return (1);
}

int
getnfsquota(struct statfs *fst, struct fstab *fs, struct quotause *qup,
    long id, int quotatype)
{
	struct getquota_args gq_args;
	struct getquota_rslt gq_rslt;
	struct dqblk *dqp = &qup->dqblk;
	struct timeval tv;
	char *cp;

	if (fst->f_flags & MNT_LOCAL)
		return (0);

	/*
	 * rpc.rquotad does not support group quotas
	 */
	if (quotatype != USRQUOTA)
		return (0);

	/*
	 * must be some form of "hostname:/path"
	 */
	cp = strchr(fst->f_mntfromname, ':');
	if (cp == NULL) {
		warnx("cannot find hostname for %s", fst->f_mntfromname);
		return (0);
	}
 
	*cp = '\0';
	if (cp[1] != '/') {
		*cp = ':';
		return (0);
	}

	gq_args.gqa_pathp = &cp[1];
	gq_args.gqa_uid = id;
	if (callaurpc(fst->f_mntfromname, RQUOTAPROG, RQUOTAVERS,
	    RQUOTAPROC_GETQUOTA, xdr_getquota_args, &gq_args,
	    xdr_getquota_rslt, &gq_rslt) != 0) {
		*cp = ':';
		return (0);
	}

	switch (gq_rslt.status) {
	case Q_NOQUOTA:
		break;
	case Q_EPERM:
		warnx("permission error, host: %s", fst->f_mntfromname);
		break;
	case Q_OK:
		gettimeofday(&tv, NULL);
			/* blocks*/
		dqp->dqb_bhardlimit =
		    gq_rslt.getquota_rslt_u.gqr_rquota.rq_bhardlimit *
		    (gq_rslt.getquota_rslt_u.gqr_rquota.rq_bsize / DEV_BSIZE);
		dqp->dqb_bsoftlimit =
		    gq_rslt.getquota_rslt_u.gqr_rquota.rq_bsoftlimit *
		    (gq_rslt.getquota_rslt_u.gqr_rquota.rq_bsize / DEV_BSIZE);
		dqp->dqb_curblocks =
		    gq_rslt.getquota_rslt_u.gqr_rquota.rq_curblocks *
		    (gq_rslt.getquota_rslt_u.gqr_rquota.rq_bsize / DEV_BSIZE);
			/* inodes */
		dqp->dqb_ihardlimit =
			gq_rslt.getquota_rslt_u.gqr_rquota.rq_fhardlimit;
		dqp->dqb_isoftlimit =
			gq_rslt.getquota_rslt_u.gqr_rquota.rq_fsoftlimit;
		dqp->dqb_curinodes =
			gq_rslt.getquota_rslt_u.gqr_rquota.rq_curfiles;
			/* grace times */
		dqp->dqb_btime =
		    tv.tv_sec + gq_rslt.getquota_rslt_u.gqr_rquota.rq_btimeleft;
		dqp->dqb_itime =
		    tv.tv_sec + gq_rslt.getquota_rslt_u.gqr_rquota.rq_ftimeleft;
		*cp = ':';
		return (1);
	default:
		warnx("bad rpc result, host: %s", fst->f_mntfromname);
		break;
	}
	*cp = ':';
	return (0);
}
 
int
callaurpc(char *host, int prognum, int versnum, int procnum,
    xdrproc_t inproc, void *in, xdrproc_t outproc, void *out)
{
	struct sockaddr_in server_addr;
	enum clnt_stat clnt_stat;
	struct hostent *hp;
	struct timeval timeout, tottimeout;
 
	CLIENT *client = NULL;
	int socket = RPC_ANYSOCK;
 
	if ((hp = gethostbyname(host)) == NULL)
		return ((int) RPC_UNKNOWNHOST);
	timeout.tv_usec = 0;
	timeout.tv_sec = 6;

	memset(&server_addr, 0, sizeof server_addr);
	memcpy(&server_addr.sin_addr, hp->h_addr, hp->h_length);
	server_addr.sin_family = AF_INET;
	server_addr.sin_port =  0;

	if ((client = clntudp_create(&server_addr, prognum,
	    versnum, timeout, &socket)) == NULL)
		return ((int) rpc_createerr.cf_stat);

	client->cl_auth = authunix_create_default();
	tottimeout.tv_sec = 25;
	tottimeout.tv_usec = 0;
	clnt_stat = clnt_call(client, procnum, inproc, in,
	    outproc, out, tottimeout);
 
	return ((int) clnt_stat);
}

int
alldigits(char *s)
{
	int c;

	c = (unsigned char)*s++;
	do {
		if (!isdigit(c))
			return (0);
	} while ((c = (unsigned char)*s++));
	return (1);
}
@


1.37
log
@Remove NULL-checks before free(). ok tb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: quota.c,v 1.36 2015/08/20 22:32:41 deraadt Exp $	*/
d308 1
a308 1
		msgi = (char *)0;
d319 1
a319 1
		msgb = (char *)0;
d331 1
a331 1
			if ((msgi != (char *)0 || msgb != (char *)0) &&
d334 1
a334 1
			if (msgi != (char *)0)
d336 1
a336 1
			if (msgb != (char *)0)
d354 1
a354 1
			    (msgb == (char *)0) ? ' ' : '*',
d359 1
a359 1
			    (msgb == (char *)0) ? ""
d363 1
a363 1
			    (msgi == (char *)0) ? ' ' : '*',
d366 1
a366 1
			    (msgi == (char *)0) ? ""
@


1.36
log
@Do not cast result of malloc/calloc/realloc* if stdlib.h is in scope
ok krw millert
@
text
@d1 1
a1 1
/*	$OpenBSD: quota.c,v 1.35 2015/02/08 23:40:34 deraadt Exp $	*/
d480 1
a480 2
	if (qup)
		free(qup);
@


1.35
log
@in getopt() blocks, stop incrementing flag variable which are supposed
to just be 0/1
ok miod florian
@
text
@d1 1
a1 1
/*	$OpenBSD: quota.c,v 1.34 2015/01/17 17:22:07 deraadt Exp $	*/
d447 1
a447 2
			if ((qup =
			    (struct quotause *)malloc(sizeof *qup)) == NULL)
@


1.34
log
@use NGROUPS_MAX instead of NGROUPS
@
text
@d1 1
a1 1
/*	$OpenBSD: quota.c,v 1.33 2015/01/16 06:40:10 deraadt Exp $	*/
d108 1
a108 1
			gflag++;
d111 1
a111 1
			uflag++;
d114 1
a114 1
			vflag++;
d117 1
a117 1
			qflag++;
d126 1
a126 1
		uflag++;
@


1.33
log
@Replace <sys/param.h> with <limits.h> and other less dirty headers where
possible.  Annotate <sys/param.h> lines with their current reasons.  Switch
to PATH_MAX, NGROUPS_MAX, HOST_NAME_MAX+1, LOGIN_NAME_MAX, etc.  Change
MIN() and MAX() to local definitions of MINIMUM() and MAXIMUM() where
sensible to avoid pulling in the pollution.  These are the files confirmed
through binary verification.
ok guenther, millert, doug (helped with the verification protocol)
@
text
@d1 1
a1 1
/*	$OpenBSD: quota.c,v 1.32 2013/11/26 13:19:07 deraadt Exp $	*/
d38 1
a38 1
#include <sys/param.h>	/* DEV_BSIZE */
d99 1
a99 1
	gid_t mygid, gidset[NGROUPS];
d132 1
a132 1
			ngroups = getgroups(NGROUPS, gidset);
d229 1
a229 1
	gid_t mygid, gidset[NGROUPS];
d238 1
a238 1
	ngroups = getgroups(NGROUPS, gidset);
d263 1
a263 1
	gid_t mygid, gidset[NGROUPS];
d271 1
a271 1
	ngroups = getgroups(NGROUPS, gidset);
@


1.32
log
@unsigned char casts for ctype
ok krw
@
text
@d1 1
a1 1
/*	$OpenBSD: quota.c,v 1.31 2013/11/08 15:21:20 jsing Exp $	*/
d38 1
a38 1
#include <sys/param.h>
d70 1
a70 1
	char	fsname[MAXPATHLEN + 1];
@


1.31
log
@Make quota(1) work with DUIDs.

ok krw@@ millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: quota.c,v 1.30 2010/04/08 02:43:57 william Exp $	*/
d687 1
a687 1
	c = *s++;
d691 1
a691 1
	} while ((c = *s++));
@


1.30
log
@Fix order of arithmetic operations so that large NFS file system quotas
display properly

same fix as in FreeBSD, NetBSD

ok deraadt@@ tedu@@ millert@@ guenther@@
@
text
@d1 1
a1 1
/*	$OpenBSD: quota.c,v 1.29 2009/10/27 23:59:41 deraadt Exp $	*/
d465 1
a465 1
			if ((fs = getfsspec(fst[i].f_mntfromname)) == NULL)
@


1.29
log
@rcsid[] and sccsid[] and copyright[] are essentially unmaintained (and
unmaintainable).  these days, people use source.  these id's do not provide
any benefit, and do hurt the small install media
(the 33,000 line diff is essentially mechanical)
ok with the idea millert, ok dms
@
text
@d1 1
a1 1
/*	$OpenBSD: quota.c,v 1.28 2007/12/30 13:32:19 sobrado Exp $	*/
d618 1
a618 1
		    gq_rslt.getquota_rslt_u.gqr_rquota.rq_bsize / DEV_BSIZE;
d621 1
a621 1
		    gq_rslt.getquota_rslt_u.gqr_rquota.rq_bsize / DEV_BSIZE;
d624 1
a624 1
		    gq_rslt.getquota_rslt_u.gqr_rquota.rq_bsize / DEV_BSIZE;
@


1.28
log
@lowercase "usage:"; align synopses

ok jmc@@
@
text
@d1 1
a1 1
/*	$OpenBSD: quota.c,v 1.27 2005/05/05 19:17:11 jmc Exp $	*/
a33 12

#ifndef lint
static const char copyright[] =
"@@(#) Copyright (c) 1980, 1990, 1993\n\
	The Regents of the University of California.  All rights reserved.\n";
#endif /* not lint */

#ifndef lint
/*static char sccsid[] = "from: @@(#)quota.c	8.1 (Berkeley) 6/6/93";*/
static const char rcsid[] =
"$OpenBSD: quota.c,v 1.27 2005/05/05 19:17:11 jmc Exp $";
#endif /* not lint */
@


1.27
log
@sort options + sync usage()
@
text
@d1 1
a1 1
/*	$OpenBSD: quota.c,v 1.26 2005/04/03 19:02:30 otto Exp $	*/
d44 1
a44 1
"$OpenBSD: quota.c,v 1.26 2005/04/03 19:02:30 otto Exp $";
a181 1

d183 3
a185 3
	    "Usage: quota [-q | -v] [-gu]",
	    "\tquota [-q | -v] -g group ...",
	    "\tquota [-q | -v] -u user ...");
@


1.26
log
@Report quotas > 10GB in a readable way. Diff based on PR 2836.
ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: quota.c,v 1.25 2005/04/01 04:31:09 deraadt Exp $	*/
d44 1
a44 1
"$OpenBSD: quota.c,v 1.25 2005/04/01 04:31:09 deraadt Exp $";
d184 3
a186 3
	    "Usage: quota [-guqv]",
	    "\tquota [-qv] -u username ...",
	    "\tquota [-qv] -g groupname ...");
@


1.25
log
@these commands said "blocks" when they meant "KBytes" (they even calculated
it so).  pointed out by janc@@cyberspace.org, pr 3956
@
text
@d1 1
a1 1
/*	$OpenBSD: quota.c,v 1.24 2004/10/10 03:31:20 mickey Exp $	*/
d44 1
a44 1
"$OpenBSD: quota.c,v 1.24 2004/10/10 03:31:20 mickey Exp $";
d363 1
a363 1
			printf("%15s%8d%c%7d%8d%8s",
d374 1
a374 1
			printf("%8d%c%7d%8d%8s\n",
d396 1
a396 1
		printf("%15s%8s %7s%8s%8s%8s %7s%8s%8s\n",
@


1.24
log
@make err msg more like the others
@
text
@d1 1
a1 1
/*	$OpenBSD: quota.c,v 1.23 2003/06/10 22:20:49 deraadt Exp $	*/
d44 1
a44 1
"$OpenBSD: quota.c,v 1.23 2003/06/10 22:20:49 deraadt Exp $";
d398 1
a398 1
		    "blocks",
@


1.23
log
@mostly ansi cleanup; pval ok
@
text
@d1 1
a1 1
/*	$OpenBSD: quota.c,v 1.22 2003/06/03 02:56:14 millert Exp $	*/
d44 1
a44 1
"$OpenBSD: quota.c,v 1.22 2003/06/03 02:56:14 millert Exp $";
d568 1
a568 1
			warn("read error `%s'", qfpathname);
@


1.22
log
@Remove the advertising clause in the UCB license which Berkeley
rescinded 22 July 1999.  Proofed by myself and Theo.
@
text
@d1 1
a1 1
/*	$OpenBSD: quota.c,v 1.21 2003/03/15 19:16:10 deraadt Exp $	*/
d44 1
a44 1
"$OpenBSD: quota.c,v 1.21 2003/03/15 19:16:10 deraadt Exp $";
d108 1
a108 3
main(argc, argv)
	int argc;
	char *argv[];
d180 1
a180 1
usage()
d194 1
a194 2
showuid(uid)
	uid_t uid;
d216 1
a216 2
showusrname(name)
	const char *name;
d238 1
a238 2
showgid(gid)
	gid_t gid;
d272 1
a272 2
showgrpname(name)
	const char *name;
d303 1
a303 4
showquotas(type, id, name)
	int type;
	u_long id;
	const char *name;
d390 1
a390 4
heading(type, id, name, tag)
	int type;
	u_long id;
	const char *name, *tag;
d413 1
a413 2
timeprt(seconds)
	time_t seconds;
d444 1
a444 3
getprivs(id, quotatype)
	long id;
	int quotatype;
d504 1
a504 4
ufshasquota(fs, type, qfnamep)
	struct fstab *fs;
	int type;
	char **qfnamep;
d541 2
a542 6
getufsquota(fst, fs, qup, id, quotatype)
	struct statfs *fst;
	struct fstab *fs;
	struct quotause *qup;
	long id;
	int quotatype;
d578 2
a579 6
getnfsquota(fst, fs, qup, id, quotatype)
	struct statfs *fst;
	struct fstab *fs; 
	struct quotause *qup;
	long id;
	int quotatype;
d661 2
a662 7
callaurpc(host, prognum, versnum, procnum, inproc, in, outproc, out)
	char *host;
	int prognum, versnum, procnum;
	xdrproc_t inproc;
	void *in;
	xdrproc_t outproc;
	void *out;
d696 1
a696 2
alldigits(s)
	char *s;
@


1.21
log
@specifed -> specified
@
text
@d1 1
a1 1
/*	$OpenBSD: quota.c,v 1.20 2002/05/14 12:24:10 fgsch Exp $	*/
d18 1
a18 5
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
d44 1
a44 1
"$OpenBSD: quota.c,v 1.20 2002/05/14 12:24:10 fgsch Exp $";
@


1.20
log
@some -Wall cleanup; closes pr/2649.
minor changes by me.
@
text
@d1 1
a1 1
/*	$OpenBSD: quota.c,v 1.19 2002/02/17 19:42:31 millert Exp $	*/
d48 1
a48 1
"$OpenBSD: quota.c,v 1.19 2002/02/17 19:42:31 millert Exp $";
d220 1
a220 1
 * Print out quotas for a specifed user name.
d278 1
a278 1
 * Print out quotas for a specifed group name.
@


1.19
log
@Manual cleanup of remaining userland __P use (excluding packages maintained outside the tree)
@
text
@d1 1
a1 1
/*	$OpenBSD: quota.c,v 1.18 2002/02/16 21:27:51 millert Exp $	*/
d40 1
a40 1
static char copyright[] =
d47 2
a48 1
static char rcsid[] = "$OpenBSD: quota.c,v 1.18 2002/02/16 21:27:51 millert Exp $";
a91 1
int	main(int, char **);
d94 2
a95 1
struct quotause	*getprivs(long id, int quotatype);
d181 2
d235 2
a236 1
		warnx("%s (uid %u): permission denied", pwd->pw_name, pwd->pw_uid);
d479 2
a480 1
			if ((qup = (struct quotause *)malloc(sizeof *qup)) == NULL)
@


1.18
log
@Part one of userland __P removal.  Done with a simple regexp with some minor hand editing to make comments line up correctly.  Another pass is forthcoming that handles the cases that could not be done automatically.
@
text
@d1 1
a1 1
/*	$OpenBSD: quota.c,v 1.17 2001/12/01 19:00:34 deraadt Exp $	*/
d47 1
a47 1
static char rcsid[] = "$OpenBSD: quota.c,v 1.17 2001/12/01 19:00:34 deraadt Exp $";
d90 1
a90 2
int	callaurpc __P((char *, int, int, int, xdrproc_t, void *,
	    xdrproc_t, void *));
d92 2
a93 2
int	getnfsquota __P((struct statfs *, struct fstab *, struct quotause *,
	    long, int));
d95 2
a96 2
int	getufsquota __P((struct statfs *, struct fstab *, struct quotause *,
	    long, int));
@


1.17
log
@KNF
@
text
@d1 1
a1 1
/*	$OpenBSD: quota.c,v 1.16 2000/10/18 23:05:16 pjanzen Exp $	*/
d47 1
a47 1
static char rcsid[] = "$OpenBSD: quota.c,v 1.16 2000/10/18 23:05:16 pjanzen Exp $";
d89 1
a89 1
int	alldigits __P((char *));
d92 1
a92 1
int	main __P((int, char **));
d95 1
a95 1
struct quotause	*getprivs __P((long id, int quotatype));
d98 9
a106 9
void	heading __P((int, u_long, const char *, const char *));
void	showgid __P((gid_t));
void	showgrpname __P((const char *));
void	showquotas __P((int, u_long, const char *));
void	showuid __P((uid_t));
void	showusrname __P((const char *));
char   *timeprt __P((time_t seconds));
int	ufshasquota __P((struct fstab *, int, char **));
void	usage __P((void));
@


1.16
log
@Quiet warning with cast
@
text
@d1 1
a1 1
/*	$OpenBSD: quota.c,v 1.15 2000/10/18 22:15:29 pjanzen Exp $	*/
d47 1
a47 1
static char rcsid[] = "$OpenBSD: quota.c,v 1.15 2000/10/18 22:15:29 pjanzen Exp $";
d373 10
a382 10
			printf("%15s%8d%c%7d%8d%8s"
			    , nam
			    , (int)(dbtob((u_quad_t)qup->dqblk.dqb_curblocks)
				/ 1024)
			    , (msgb == (char *)0) ? ' ' : '*'
			    , (int)(dbtob((u_quad_t)qup->dqblk.dqb_bsoftlimit)
				/ 1024)
			    , (int)(dbtob((u_quad_t)qup->dqblk.dqb_bhardlimit)
				/ 1024)
			    , (msgb == (char *)0) ? ""
d384 6
a389 6
			printf("%8d%c%7d%8d%8s\n"
			    , qup->dqblk.dqb_curinodes
			    , (msgi == (char *)0) ? ' ' : '*'
			    , qup->dqblk.dqb_isoftlimit
			    , qup->dqblk.dqb_ihardlimit
			    , (msgi == (char *)0) ? ""
d409 10
a418 11
		printf("%15s%8s %7s%8s%8s%8s %7s%8s%8s\n"
		    , "Filesystem"
		    , "blocks"
		    , "quota"
		    , "limit"
		    , "grace"
		    , "files"
		    , "quota"
		    , "limit"
		    , "grace"
		);
@


1.15
log
@Changes from NetBSD:  cleanups, use err/warn, reformat, and print large quotas
(>4G) correctly.
@
text
@d1 1
a1 1
/*	$OpenBSD: quota.c,v 1.14 2000/02/01 03:23:36 deraadt Exp $	*/
d47 1
a47 1
static char rcsid[] = "$OpenBSD: quota.c,v 1.14 2000/02/01 03:23:36 deraadt Exp $";
d574 1
a574 1
	if (quotactl(fs->fs_file, qcmd, id, &qup->dqblk) != 0) {
@


1.14
log
@no need to extern int errno if errno.h is included
@
text
@d1 1
a1 1
/*	$OpenBSD: quota.c,v 1.13 1999/08/06 20:41:07 deraadt Exp $	*/
d47 1
a47 1
static char rcsid[] = "$OpenBSD: quota.c,v 1.13 1999/08/06 20:41:07 deraadt Exp $";
d59 1
d61 7
a69 2
#include <fstab.h>
#include <ctype.h>
d71 2
a72 3
#include <pwd.h>
#include <grp.h>
#include <errno.h>
a73 1
#include <netdb.h>
d89 18
a106 2
char *timeprt	__P((time_t seconds));
struct quotause *getprivs __P((long id, int quotatype));
d111 1
d113 1
d151 2
a152 4
			if (ngroups < 0) {
				perror("quota: getgroups");
				exit(1);
			}
d180 1
d183 1
d188 3
a190 3
		"Usage: quota [-guqv]",
		"\tquota [-qv] -u username ...",
		"\tquota [-qv] -g groupname ...");
d197 1
d203 1
a203 1
	char *name;
d211 1
a211 1
		printf("quota: %s (uid %u): permission denied\n", name, uid);
d220 1
d222 1
a222 1
	char *name;
d228 1
a228 1
		fprintf(stderr, "quota: %s: unknown user\n", name);
d233 1
a233 2
		fprintf(stderr, "quota: %s (uid %u): permission denied\n",
		    pwd->pw_name, pwd->pw_uid);
d242 1
d249 2
a250 2
	register int i;
	char *name;
d259 1
a259 1
		perror("quota: getgroups");
d267 1
a267 3
			fprintf(stderr,
			    "quota: %s (gid %u): permission denied\n",
			    name, gid);
d277 1
d279 1
a279 1
	char *name;
d284 1
a284 1
	register int i;
d287 1
a287 1
		fprintf(stderr, "quota: %s: unknown group\n", name);
d293 1
a293 1
		perror("quota: getgroups");
d301 1
a301 2
			fprintf(stderr,
			    "quota: %s (gid %d): permission denied\n",
d309 1
d313 1
a313 1
	char *name;
d315 1
a315 1
	register struct quotause *qup;
d318 1
a318 2
	uid_t myuid, fd, lines = 0;
	static int first;
d336 1
a336 1
		    qup->dqblk.dqb_curinodes >= qup->dqblk.dqb_isoftlimit)
d341 1
d347 1
a347 1
		    qup->dqblk.dqb_curblocks >= qup->dqblk.dqb_bsoftlimit)
d352 1
d374 10
a383 7
				, nam
				, dbtob(qup->dqblk.dqb_curblocks) / 1024
				, (msgb == (char *)0) ? ' ' : '*'
				, dbtob(qup->dqblk.dqb_bsoftlimit) / 1024
				, dbtob(qup->dqblk.dqb_bhardlimit) / 1024
				, (msgb == (char *)0) ? ""
				    : timeprt(qup->dqblk.dqb_btime));
d385 6
a390 6
				, qup->dqblk.dqb_curinodes
				, (msgi == (char *)0) ? ' ' : '*'
				, qup->dqblk.dqb_isoftlimit
				, qup->dqblk.dqb_ihardlimit
				, (msgi == (char *)0) ? ""
				    : timeprt(qup->dqblk.dqb_itime)
d399 1
d403 1
a403 1
	char *name, *tag;
d406 1
a406 1
	printf("Disk quotas for %s %s (%cid %d): %s\n", qfextension[type],
d410 9
a418 9
			, "Filesystem"
			, "blocks"
			, "quota"
			, "limit"
			, "grace"
			, "files"
			, "quota"
			, "limit"
			, "grace"
d442 2
a443 1
		snprintf(buf, sizeof buf, "%ddays", (hours + 12) / 24);
d447 2
a448 1
		snprintf(buf, sizeof buf, "%2d:%d", minutes / 60, minutes % 60);
d451 1
a451 1
	snprintf(buf, sizeof buf, "%2d", minutes);
d460 1
a460 1
	register long id;
d463 2
a464 2
	register struct quotause *qup, *quptail;
	register struct fstab *fs;
d469 1
a469 1
	qup = quphead = (struct quotause *)0;
d472 2
a473 4
	if (nfst == 0) {
		fprintf(stderr, "quota: no filesystems mounted!\n");
		exit(2);
	}
d475 1
a475 1
	for (i=0; i<nfst; i++) {
d477 2
a478 4
			if ((qup = (struct quotause *)malloc(sizeof *qup)) == NULL) {
				fprintf(stderr, "quota: out of memory\n");
				exit(2);
			}
d519 1
d521 1
a521 1
	register struct fstab *fs;
d529 1
d531 1
a531 1
		snprintf(usrname, sizeof usrname, "%s%s",
d533 1
a533 1
		snprintf(grpname, sizeof grpname, "%s%s",
d538 1
d540 1
a540 1
		if (cp = strchr(opt, '='))
d553 1
a553 1
	(void) snprintf(buf, sizeof buf, "%s/%s.%s",
d576 1
a576 1
			perror(qfpathname);
d579 1
a579 1
		(void) lseek(fd, (off_t)(id * sizeof(struct dqblk)), SEEK_SET);
d591 1
a591 2
			fprintf(stderr, "quota: read error");
			perror(qfpathname);
d628 1
a628 2
		fprintf(stderr, "cannot find hostname for %s\n",
		    fst->f_mntfromname);
d651 1
a651 2
		fprintf(stderr, "quota permission error, host: %s\n",
			fst->f_mntfromname);
d680 1
a680 2
		fprintf(stderr, "bad rpc result, host: %s\n",
		    fst->f_mntfromname);
d690 5
a694 2
	xdrproc_t inproc, outproc;
	char *in, *out;
d727 1
d729 1
a729 1
	register char *s;
d731 1
a731 1
	register c;
d737 1
a737 1
	} while (c = *s++);
@


1.13
log
@uid_t and gid_t, and use %u
@
text
@d1 1
a1 1
/*	$OpenBSD: quota.c,v 1.12 1998/07/13 02:11:41 millert Exp $	*/
d47 1
a47 1
static char rcsid[] = "$OpenBSD: quota.c,v 1.12 1998/07/13 02:11:41 millert Exp $";
d99 1
a99 1
	extern int optind, errno;
@


1.12
log
@ftpd: sleep for an indeterminate amount for non-existant logins
      to simulate a crypt, like login does.
Use SEEK_* not L_* and kill some 0L's used in lseek while we're there.
@
text
@d1 1
a1 1
/*	$OpenBSD: quota.c,v 1.11 1998/07/10 08:50:35 deraadt Exp $	*/
d47 1
a47 1
static char rcsid[] = "$OpenBSD: quota.c,v 1.11 1998/07/10 08:50:35 deraadt Exp $";
d176 1
a176 1
	u_long uid;
d179 1
a179 1
	u_long myuid;
d188 1
a188 1
		printf("quota: %s (uid %d): permission denied\n", name, uid);
d201 1
a201 1
	u_long myuid;
d209 1
a209 1
		fprintf(stderr, "quota: %s (uid %d): permission denied\n",
d220 1
a220 1
	u_long gid;
d244 1
a244 1
			    "quota: %s (gid %d): permission denied\n",
d295 1
a295 1
	int myuid, fd, lines = 0;
@


1.11
log
@memset and friends
@
text
@d1 1
a1 1
/*	$OpenBSD: quota.c,v 1.10 1998/07/10 08:17:39 deraadt Exp $	*/
d47 1
a47 1
static char rcsid[] = "$OpenBSD: quota.c,v 1.10 1998/07/10 08:17:39 deraadt Exp $";
d550 1
a550 1
		(void) lseek(fd, (off_t)(id * sizeof(struct dqblk)), L_SET);
@


1.10
log
@avoid buf oflows
@
text
@d1 1
a1 1
/*	$OpenBSD: quota.c,v 1.9 1997/01/17 07:13:08 millert Exp $	*/
d47 1
a47 1
static char rcsid[] = "$OpenBSD: quota.c,v 1.9 1997/01/17 07:13:08 millert Exp $";
d557 1
a557 1
			bzero((caddr_t)&qup->dqblk, sizeof(struct dqblk));
d606 1
a606 1
	if (*(cp+1) != '/') {
d611 1
a611 1
	gq_args.gqa_pathp = cp + 1;
d680 3
a682 1
	bcopy(hp->h_addr, &server_addr.sin_addr, hp->h_length);
@


1.9
log
@r?index -> strr?chr
@
text
@d1 1
a1 1
/*	$OpenBSD: quota.c,v 1.8 1996/10/28 04:08:21 millert Exp $	*/
d47 1
a47 1
static char rcsid[] = "$OpenBSD: quota.c,v 1.8 1996/10/28 04:08:21 millert Exp $";
d414 1
a414 1
		sprintf(buf, "%ddays", (hours + 12) / 24);
d418 1
a418 1
		sprintf(buf, "%2d:%d", minutes / 60, minutes % 60);
d421 1
a421 1
	sprintf(buf, "%2d", minutes);
d474 2
a475 1
		strcpy(qup->fsname, fst[i].f_mntonname);
@


1.8
log
@Be more paranoid about passing around user/group name from argv.
@
text
@d1 1
a1 1
/*	$OpenBSD: quota.c,v 1.7 1996/08/07 14:08:52 etheisen Exp $	*/
d47 1
a47 1
static char rcsid[] = "$OpenBSD: quota.c,v 1.7 1996/08/07 14:08:52 etheisen Exp $";
d510 1
a510 1
		if (cp = index(opt, '='))
@


1.7
log
@strncpy() dyslexia on last commit.
@
text
@d1 1
a1 1
/*	$OpenBSD: quota.c,v 1.6 1996/08/06 18:38:48 deraadt Exp $	*/
d47 1
a47 1
static char rcsid[] = "$OpenBSD: quota.c,v 1.6 1996/08/06 18:38:48 deraadt Exp $";
d210 1
a210 1
		    name, pwd->pw_uid);
d213 1
a213 1
	showquotas(USRQUOTA, pwd->pw_uid, name);
d280 1
a280 1
			    name, grp->gr_gid);
d284 1
a284 1
	showquotas(GRPQUOTA, grp->gr_gid, name);
@


1.6
log
@buf oflow
@
text
@d1 1
a1 1
/*	$OpenBSD: quota.c,v 1.5 1996/06/26 05:38:01 deraadt Exp $	*/
d47 1
a47 1
static char rcsid[] = "$OpenBSD: quota.c,v 1.5 1996/06/26 05:38:01 deraadt Exp $";
d508 1
a508 1
	strncpy(buf, sizeof buf, fs->fs_mntops);
@


1.5
log
@rcsid
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d47 1
a47 1
static char rcsid[] = "$OpenBSD: quota.c,v 1.4 1996/04/25 11:04:06 deraadt Exp $";
d502 4
a505 2
		sprintf(usrname, "%s%s", qfextension[USRQUOTA], qfname);
		sprintf(grpname, "%s%s", qfextension[GRPQUOTA], qfname);
d508 1
a508 1
	strcpy(buf, fs->fs_mntops);
d523 2
a524 1
	(void) sprintf(buf, "%s/%s.%s", fs->fs_file, qfname, qfextension[type]);
@


1.4
log
@permit quotas to work on mfs; problem reported by rdante@@pnet.net
@
text
@d1 2
d47 1
a47 1
static char rcsid[] = "$Id: quota.c,v 1.3 1996/04/21 23:43:38 deraadt Exp $";
@


1.3
log
@sync to netbsd 960418
@
text
@d45 1
a45 1
static char rcsid[] = "$Id: quota.c,v 1.2 1995/11/25 16:46:24 deraadt Exp $";
d455 3
a457 3
		} else if ((strncmp(fst[i].f_fstypename, "ffs",
		    MFSNAMELEN) == 0) || (strncmp(fst[i].f_fstypename, "ufs",
			MFSNAMELEN) == 0)) {
@


1.2
log
@make quotas work on ffs; from andrew@@wipux2.wifo.uni-mannheim.de; netbsd pr #1790
@
text
@d45 1
a45 1
static char rcsid[] = "$Id: quota.c,v 1.1.1.1 1995/10/18 08:45:58 deraadt Exp $";
d95 1
a95 1
	char ch;
d99 1
a99 1
	while ((ch = getopt(argc, argv, "ugvq")) != EOF) {
@


1.1
log
@Initial revision
@
text
@d45 1
a45 1
static char rcsid[] = "$Id: quota.c,v 1.9 1995/06/18 11:00:49 cgd Exp $";
d455 3
a457 2
		} else if (strncmp(fst[i].f_fstypename, "ufs",
		    MFSNAMELEN) == 0) {
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@
