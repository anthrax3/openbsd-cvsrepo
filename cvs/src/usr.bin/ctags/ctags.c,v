head	1.18;
access;
symbols
	OPENBSD_6_2:1.18.0.10
	OPENBSD_6_2_BASE:1.18
	OPENBSD_6_1:1.18.0.8
	OPENBSD_6_1_BASE:1.18
	OPENBSD_6_0:1.18.0.4
	OPENBSD_6_0_BASE:1.18
	OPENBSD_5_9:1.18.0.2
	OPENBSD_5_9_BASE:1.18
	OPENBSD_5_8:1.15.0.6
	OPENBSD_5_8_BASE:1.15
	OPENBSD_5_7:1.15.0.2
	OPENBSD_5_7_BASE:1.15
	OPENBSD_5_6:1.13.0.18
	OPENBSD_5_6_BASE:1.13
	OPENBSD_5_5:1.13.0.16
	OPENBSD_5_5_BASE:1.13
	OPENBSD_5_4:1.13.0.12
	OPENBSD_5_4_BASE:1.13
	OPENBSD_5_3:1.13.0.10
	OPENBSD_5_3_BASE:1.13
	OPENBSD_5_2:1.13.0.8
	OPENBSD_5_2_BASE:1.13
	OPENBSD_5_1_BASE:1.13
	OPENBSD_5_1:1.13.0.6
	OPENBSD_5_0:1.13.0.4
	OPENBSD_5_0_BASE:1.13
	OPENBSD_4_9:1.13.0.2
	OPENBSD_4_9_BASE:1.13
	OPENBSD_4_8:1.12.0.4
	OPENBSD_4_8_BASE:1.12
	OPENBSD_4_7:1.12.0.2
	OPENBSD_4_7_BASE:1.12
	OPENBSD_4_6:1.11.0.12
	OPENBSD_4_6_BASE:1.11
	OPENBSD_4_5:1.11.0.8
	OPENBSD_4_5_BASE:1.11
	OPENBSD_4_4:1.11.0.6
	OPENBSD_4_4_BASE:1.11
	OPENBSD_4_3:1.11.0.4
	OPENBSD_4_3_BASE:1.11
	OPENBSD_4_2:1.11.0.2
	OPENBSD_4_2_BASE:1.11
	OPENBSD_4_1:1.10.0.16
	OPENBSD_4_1_BASE:1.10
	OPENBSD_4_0:1.10.0.14
	OPENBSD_4_0_BASE:1.10
	OPENBSD_3_9:1.10.0.12
	OPENBSD_3_9_BASE:1.10
	OPENBSD_3_8:1.10.0.10
	OPENBSD_3_8_BASE:1.10
	OPENBSD_3_7:1.10.0.8
	OPENBSD_3_7_BASE:1.10
	OPENBSD_3_6:1.10.0.6
	OPENBSD_3_6_BASE:1.10
	OPENBSD_3_5:1.10.0.4
	OPENBSD_3_5_BASE:1.10
	OPENBSD_3_4:1.10.0.2
	OPENBSD_3_4_BASE:1.10
	OPENBSD_3_3:1.6.0.6
	OPENBSD_3_3_BASE:1.6
	OPENBSD_3_2:1.6.0.4
	OPENBSD_3_2_BASE:1.6
	OPENBSD_3_1:1.6.0.2
	OPENBSD_3_1_BASE:1.6
	OPENBSD_3_0:1.5.0.6
	OPENBSD_3_0_BASE:1.5
	OPENBSD_2_9_BASE:1.5
	OPENBSD_2_9:1.5.0.4
	OPENBSD_2_8:1.5.0.2
	OPENBSD_2_8_BASE:1.5
	OPENBSD_2_7:1.4.0.4
	OPENBSD_2_7_BASE:1.4
	OPENBSD_2_6:1.4.0.2
	OPENBSD_2_6_BASE:1.4
	OPENBSD_2_5:1.3.0.10
	OPENBSD_2_5_BASE:1.3
	OPENBSD_2_4:1.3.0.8
	OPENBSD_2_4_BASE:1.3
	OPENBSD_2_3:1.3.0.6
	OPENBSD_2_3_BASE:1.3
	OPENBSD_2_2:1.3.0.4
	OPENBSD_2_2_BASE:1.3
	OPENBSD_2_1:1.3.0.2
	OPENBSD_2_1_BASE:1.3
	OPENBSD_2_0:1.2.0.2
	OPENBSD_2_0_BASE:1.2
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.18
date	2015.10.09.01.37.07;	author deraadt;	state Exp;
branches;
next	1.17;
commitid	sbrB3Q5CNxcwZpfU;

1.17
date	2015.10.07.06.33.31;	author deraadt;	state Exp;
branches;
next	1.16;
commitid	vAtJLZn7VK1m1E5H;

1.16
date	2015.08.22.04.23.07;	author semarie;	state Exp;
branches;
next	1.15;
commitid	nKkX9hiLkqgWZnkH;

1.15
date	2015.02.08.23.40.34;	author deraadt;	state Exp;
branches;
next	1.14;
commitid	yGZX28AeTChVE8eY;

1.14
date	2014.12.10.19.44.21;	author tobias;	state Exp;
branches;
next	1.13;
commitid	3zlvFckExZCPooMl;

1.13
date	2010.11.03.19.39.38;	author millert;	state Exp;
branches;
next	1.12;

1.12
date	2009.10.27.23.59.37;	author deraadt;	state Exp;
branches;
next	1.11;

1.11
date	2007.03.15.22.41.17;	author jmc;	state Exp;
branches;
next	1.10;

1.10
date	2003.06.10.22.20.45;	author deraadt;	state Exp;
branches;
next	1.9;

1.9
date	2003.06.03.02.56.07;	author millert;	state Exp;
branches;
next	1.8;

1.8
date	2003.04.25.20.07.09;	author pvalchev;	state Exp;
branches;
next	1.7;

1.7
date	2003.04.07.21.13.54;	author deraadt;	state Exp;
branches;
next	1.6;

1.6
date	2002.02.16.21.27.45;	author millert;	state Exp;
branches;
next	1.5;

1.5
date	2000.07.25.19.28.30;	author deraadt;	state Exp;
branches;
next	1.4;

1.4
date	99.07.02.18.37.11;	author deraadt;	state Exp;
branches;
next	1.3;

1.3
date	97.01.15.23.42.23;	author millert;	state Exp;
branches;
next	1.2;

1.2
date	96.06.26.05.32.28;	author deraadt;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.45.04;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.45.04;	author deraadt;	state Exp;
branches;
next	;


desc
@@


1.18
log
@Change all tame callers to namechange to pledge(2).
@
text
@/*	$OpenBSD: ctags.c,v 1.17 2015/10/07 06:33:31 deraadt Exp $	*/
/*	$NetBSD: ctags.c,v 1.4 1995/09/02 05:57:23 jtc Exp $	*/

/*
 * Copyright (c) 1987, 1993, 1994, 1995
 *	The Regents of the University of California.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */

#include <err.h>
#include <limits.h>
#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <unistd.h>

#include "ctags.h"

/*
 * ctags: create a tags file
 */

NODE	*head;			/* head of the sorted binary tree */

				/* boolean "func" (see init()) */
bool	_wht[256], _itk[256], _btk[256];

FILE	*inf;			/* ioptr for current input file */
FILE	*outf;			/* ioptr for tags file */

long	lineftell;		/* ftell after getc( inf ) == '\n' */

int	lineno;			/* line number of current line */
int	dflag;			/* -d: non-macro defines */
int	vflag;			/* -v: vgrind style index output */
int	wflag;			/* -w: suppress warnings */
int	xflag;			/* -x: cxref style output */

char	*curfile;		/* current input file name */
char	searchar = '/';		/* use /.../ searches by default */
char	lbuf[LINE_MAX];

void	init(void);
void	find_entries(char *);
void	preload_entries(char *, int, char *[]);

int
main(int argc, char *argv[])
{
	static char	*outfile = "tags";	/* output file */
	int	aflag;				/* -a: append to tags */
	int	uflag;				/* -u: update tags */
	int	exit_val;			/* exit value */
	int	step;				/* step through args */
	int	ch;				/* getopts char */

	if (pledge("stdio rpath wpath cpath", NULL) == -1)
		err(1, "pledge");

	aflag = uflag = NO;
	while ((ch = getopt(argc, argv, "BFadf:tuwvx")) != -1)
		switch(ch) {
		case 'B':
			searchar = '?';
			break;
		case 'F':
			searchar = '/';
			break;
		case 'a':
			aflag = 1;
			break;
		case 'd':
			dflag = 1;
			break;
		case 'f':
			outfile = optarg;
			break;
		case 't':
			/* backwards compatibility */
			break;
		case 'u':
			uflag = 1;
			break;
		case 'w':
			wflag = 1;
			break;
		case 'v':
			vflag = 1;
		case 'x':
			xflag = 1;
			break;
		case '?':
		default:
			goto usage;
		}
	argv += optind;
	argc -= optind;
	if (!argc) {
usage:		(void)fprintf(stderr,
			"usage: ctags [-aBdFuvwx] [-f tagsfile] file ...\n");
		exit(1);
	}

	init();
	if (uflag && !vflag && !xflag)
		preload_entries(outfile, argc, argv);

	for (exit_val = step = 0; step < argc; ++step)
		if (!(inf = fopen(argv[step], "r"))) {
			warn("%s", argv[step]);
			exit_val = 1;
		}
		else {
			curfile = argv[step];
			find_entries(argv[step]);
			(void)fclose(inf);
		}

	if (head) {
		if (xflag)
			put_entries(head);
		else {
			if (!(outf = fopen(outfile, aflag ? "a" : "w")))
				err(exit_val, "%s", outfile);
			put_entries(head);
			(void)fclose(outf);
		}
	}
	exit(exit_val);
}

/*
 * init --
 *	this routine sets up the boolean psuedo-functions which work by
 *	setting boolean flags dependent upon the corresponding character.
 *	Every char which is NOT in that string is false with respect to
 *	the pseudo-function.  Therefore, all of the array "_wht" is NO
 *	by default and then the elements subscripted by the chars in
 *	CWHITE are set to YES.  Thus, "_wht" of a char is YES if it is in
 *	the string CWHITE, else NO.
 */
void
init(void)
{
	int		i;
	unsigned char	*sp;

	for (i = 0; i < 256; i++)
		_wht[i] = _itk[i] = _btk[i] = NO;
#define	CWHITE	" \f\t\n"
	for (sp = CWHITE; *sp; sp++)	/* white space chars */
		_wht[*sp] = YES;
#define	CINTOK	"ABCDEFGHIJKLMNOPQRSTUVWXYZ_abcdefghijklmnopqrstuvwxyz0123456789"
	for (sp = CINTOK; *sp; sp++)	/* valid in-token chars */
		_itk[*sp] = YES;
#define	CBEGIN	"ABCDEFGHIJKLMNOPQRSTUVWXYZ_abcdefghijklmnopqrstuvwxyz"
	for (sp = CBEGIN; *sp; sp++)	/* token starting chars */
		_btk[*sp] = YES;
}

/*
 * find_entries --
 *	this routine opens the specified file and calls the function
 *	which searches the file.
 */
void
find_entries(char *file)
{
	char	*cp;

	lineno = 0;				/* should be 1 ?? KB */
	if ((cp = strrchr(file, '.'))) {
		if (cp[1] == 'l' && !cp[2]) {
			int	c;

			for (;;) {
				if (GETC(==, EOF))
					return;
				if (!iswhite(c)) {
					rewind(inf);
					break;
				}
			}
#define	LISPCHR	";(["
/* lisp */		if (strchr(LISPCHR, c)) {
				l_entries();
				return;
			}
/* lex */		else {
				/*
				 * we search all 3 parts of a lex file
				 * for C references.  This may be wrong.
				 */
				toss_yysec();
				(void)strlcpy(lbuf, "%%$", sizeof lbuf);
				pfnote("yylex", lineno);
				rewind(inf);
			}
		}
/* yacc */	else if (cp[1] == 'y' && !cp[2]) {
			/*
			 * we search only the 3rd part of a yacc file
			 * for C references.  This may be wrong.
			 */
			toss_yysec();
			(void)strlcpy(lbuf, "%%$", sizeof lbuf);
			pfnote("yyparse", lineno);
			y_entries();
		}
/* fortran */	else if ((cp[1] != 'c' && cp[1] != 'h') && !cp[2]) {
			if (PF_funcs())
				return;
			rewind(inf);
		}
	}
/* C */	c_entries();
}

void
preload_entries(char *tagsfile, int argc, char *argv[])
{
	FILE	*fp;
	char	 line[LINE_MAX];
	char	*entry = NULL;
	char	*file = NULL;
	char	*pattern = NULL;
	char	*eol;
	int	 i;

	in_preload = YES;

	if ((fp = fopen(tagsfile, "r")) == NULL)
		err(1, "preload_entries: %s", tagsfile);

	while (1) {
next:
		if (fgets(line, sizeof(line), fp) == NULL)
			break;

		if ((eol = strchr(line, '\n')) == NULL)
			errx(1, "preload_entries: line too long");
		*eol = '\0';

		/* extract entry */
		entry = line;
		if ((file = strchr(line, '\t')) == NULL)
			errx(1, "preload_entries: couldn't parse entry: %s",
			    tagsfile);
		*file = '\0';

		/* extract file */
		file++;
		if ((pattern = strchr(file, '\t')) == NULL)
			errx(1, "preload_entries: couldn't parse filename: %s",
			    tagsfile);
		*pattern = '\0';

		/* skip this file ? */
		for(i = 0; i < argc; i++)
			if (strcmp(file, argv[i]) == 0)
				goto next;

		/* rest of string is pattern */
		pattern++;

		/* grab searchar, and don't keep it around the pattern */
		if ((pattern[0] == '/' || pattern[0] == '?')
		    && pattern[1] == '^') {

			i = strlen(pattern);
			if (pattern[i-1] == pattern[0])
				/* remove searchar at end */
				pattern[i-1] = '\0';
			else
				errx(1, "preload_entries: couldn't parse "
				    "pattern: %s", tagsfile);

			/* remove searchar at begin */
			pattern += 2;
		}

		/* add entry */
		if ((curfile = strdup(file)) == NULL)
			err(1, "preload_entries: strdup");
		(void)strlcpy(lbuf, pattern, sizeof(lbuf));
		pfnote(entry, 0);
	}
	if (ferror(fp))
		err(1, "preload_entries: fgets");

	(void)fclose(fp);
	in_preload = NO;
}
@


1.17
log
@tame "stdio rpath wpath cpath" handles all the cases of opening files
@
text
@d1 1
a1 1
/*	$OpenBSD: ctags.c,v 1.16 2015/08/22 04:23:07 semarie Exp $	*/
d80 2
a81 2
	if (tame("stdio rpath wpath cpath", NULL) == -1)
		err(1, "tame");
@


1.16
log
@system(3) call remove for updating (ctags -u)

done by changing the logic behind updating, by parsing and preloading the tags
file at startup.

"looks good" deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ctags.c,v 1.15 2015/02/08 23:40:34 deraadt Exp $	*/
d79 3
@


1.15
log
@in getopt() blocks, stop incrementing flag variable which are supposed
to just be 0/1
ok miod florian
@
text
@d1 1
a1 1
/*	$OpenBSD: ctags.c,v 1.14 2014/12/10 19:44:21 tobias Exp $	*/
d68 1
a78 1
	char	*cmd;
d125 2
a142 12
			if (uflag) {
				for (step = 0; step < argc; step++) {
					if (asprintf(&cmd,
					    "mv %s OTAGS; fgrep -v '\t%s\t' OTAGS >%s; rm OTAGS",
					    outfile, argv[step], outfile) == -1)
						err(1, "out of space");
					system(cmd);
					free(cmd);
					cmd = NULL;
				}
				aflag = 1;
			}
a146 8
			if (uflag) {
				if (asprintf(&cmd, "sort -o %s %s",
				    outfile, outfile) == -1)
						err(1, "out of space");
				system(cmd);
				free(cmd);
				cmd = NULL;
			}
d237 76
@


1.14
log
@The macros endtoken and isgood aren't used anywhere... zap them and
their data structures.

ok jsg, millert
@
text
@d1 1
a1 1
/*	$OpenBSD: ctags.c,v 1.13 2010/11/03 19:39:38 millert Exp $	*/
d90 1
a90 1
			aflag++;
d93 1
a93 1
			dflag++;
d102 1
a102 1
			uflag++;
d105 1
a105 1
			wflag++;
d108 1
a108 1
			vflag++;
d110 1
a110 1
			xflag++;
d151 1
a151 1
				++aflag;
@


1.13
log
@POSIX specifies that ctags create tags for typedefs, structs, unions,
and enums by default.  The -t flag becomes a no-op for backwards
compat only.  OK deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ctags.c,v 1.12 2009/10/27 23:59:37 deraadt Exp $	*/
d49 1
a49 1
bool	_wht[256], _etk[256], _itk[256], _btk[256], _gd[256];
d186 2
a187 4
	for (i = 0; i < 256; i++) {
		_wht[i] = _etk[i] = _itk[i] = _btk[i] = NO;
		_gd[i] = YES;
	}
a190 3
#define	CTOKEN	" \t\n\"'#()[]{}=-+%*/&|^~!<>;,.:?"
	for (sp = CTOKEN; *sp; sp++)	/* token ending chars */
		_etk[*sp] = YES;
a196 3
#define	CNOTGD	",;"
	for (sp = CNOTGD; *sp; sp++)	/* invalid after-function chars */
		_gd[*sp] = NO;
@


1.12
log
@rcsid[] and sccsid[] and copyright[] are essentially unmaintained (and
unmaintainable).  these days, people use source.  these id's do not provide
any benefit, and do hurt the small install media
(the 33,000 line diff is essentially mechanical)
ok with the idea millert, ok dms
@
text
@d1 1
a1 1
/*	$OpenBSD: ctags.c,v 1.11 2007/03/15 22:41:17 jmc Exp $	*/
a57 1
int	tflag;			/* -t: create tags for typedefs */
d99 1
a99 1
			tflag++;
d120 1
a120 1
			"usage: ctags [-aBdFtuvwx] [-f tagsfile] file ...\n");
@


1.11
log
@simplify synopsis/usage() and sort options;
from Igor Sobrado
@
text
@d1 1
a1 1
/*	$OpenBSD: ctags.c,v 1.10 2003/06/10 22:20:45 deraadt Exp $	*/
a31 13

#ifndef lint
static char copyright[] =
"@@(#) Copyright (c) 1987, 1993, 1994, 1995\n\
	The Regents of the University of California.  All rights reserved.\n";
#endif /* not lint */

#ifndef lint
#if 0
static char sccsid[] = "@@(#)ctags.c	8.4 (Berkeley) 2/7/95";
#endif
static char rcsid[] = "$OpenBSD: ctags.c,v 1.10 2003/06/10 22:20:45 deraadt Exp $";
#endif /* not lint */
@


1.10
log
@mostly ansi cleanup; pval ok
@
text
@d1 1
a1 1
/*	$OpenBSD: ctags.c,v 1.9 2003/06/03 02:56:07 millert Exp $	*/
d43 1
a43 1
static char rcsid[] = "$OpenBSD: ctags.c,v 1.9 2003/06/03 02:56:07 millert Exp $";
d134 1
a134 1
			"usage: ctags [-BFadtuwvx] [-f tagsfile] file ...\n");
@


1.9
log
@Remove the advertising clause in the UCB license which Berkeley
rescinded 22 July 1999.  Proofed by myself and Theo.
@
text
@d1 1
a1 1
/*	$OpenBSD: ctags.c,v 1.8 2003/04/25 20:07:09 pvalchev Exp $	*/
d43 1
a43 1
static char rcsid[] = "$OpenBSD: ctags.c,v 1.8 2003/04/25 20:07:09 pvalchev Exp $";
d84 1
a84 3
main(argc, argv)
	int	argc;
	char	**argv;
d195 1
a195 1
init()
d227 1
a227 2
find_entries(file)
	char	*file;
@


1.8
log
@check asprintf return value for error, as the pointer is not guaranteed
to be NULL in such case; ok millert
@
text
@d1 1
a1 1
/*	$OpenBSD: ctags.c,v 1.7 2003/04/07 21:13:54 deraadt Exp $	*/
d16 1
a16 5
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
d43 1
a43 1
static char rcsid[] = "$OpenBSD: ctags.c,v 1.7 2003/04/07 21:13:54 deraadt Exp $";
@


1.7
log
@replace strcpy calls that got inlined by gcc; Hans-Joerg.Hoexer@@yerbouti.franken.de
@
text
@d1 1
a1 1
/*	$OpenBSD: ctags.c,v 1.6 2002/02/16 21:27:45 millert Exp $	*/
d47 1
a47 1
static char rcsid[] = "$OpenBSD: ctags.c,v 1.6 2002/02/16 21:27:45 millert Exp $";
d163 1
a163 1
					(void)asprintf(&cmd,
d165 1
a165 2
					    outfile, argv[step], outfile);
					if (cmd == NULL)
d178 2
a179 3
				(void)asprintf(&cmd, "sort -o %s %s",
				    outfile, outfile);
				if (cmd == NULL)
@


1.6
log
@Part one of userland __P removal.  Done with a simple regexp with some minor hand editing to make comments line up correctly.  Another pass is forthcoming that handles the cases that could not be done automatically.
@
text
@d1 1
a1 1
/*	$OpenBSD: ctags.c,v 1.5 2000/07/25 19:28:30 deraadt Exp $	*/
d47 1
a47 1
static char rcsid[] = "$OpenBSD: ctags.c,v 1.5 2000/07/25 19:28:30 deraadt Exp $";
d264 1
a264 1
				(void)strcpy(lbuf, "%%$");
d275 1
a275 1
			(void)strcpy(lbuf, "%%$");
@


1.5
log
@deal with a number of overflows pointed out by fuzz; in most cases, we truncate the symbol in question
@
text
@d1 1
a1 1
/*	$OpenBSD: ctags.c,v 1.4 1999/07/02 18:37:11 deraadt Exp $	*/
d47 1
a47 1
static char rcsid[] = "$OpenBSD: ctags.c,v 1.4 1999/07/02 18:37:11 deraadt Exp $";
d84 2
a85 2
void	init __P((void));
void	find_entries __P((char *));
@


1.4
log
@ambigious else
@
text
@d1 1
a1 1
/*	$OpenBSD: ctags.c,v 1.3 1997/01/15 23:42:23 millert Exp $	*/
d47 1
a47 1
static char rcsid[] = "$OpenBSD: ctags.c,v 1.3 1997/01/15 23:42:23 millert Exp $";
d98 1
a98 1
	char	cmd[100];			/* too ugly to explain */
d163 5
a167 4
					(void)sprintf(cmd,
						"mv %s OTAGS; fgrep -v '\t%s\t' OTAGS >%s; rm OTAGS",
							outfile, argv[step],
							outfile);
d169 2
d179 4
a182 2
				(void)sprintf(cmd, "sort -o %s %s",
						outfile, outfile);
d184 2
d241 1
a241 1
	if (cp = strrchr(file, '.')) {
@


1.3
log
@getopt(3) returns -1 when out of args, not EOF, whee!
@
text
@d1 1
a1 1
/*	$OpenBSD: ctags.c,v 1.2 1996/06/26 05:32:28 deraadt Exp $	*/
d47 1
a47 1
static char rcsid[] = "$OpenBSD: ctags.c,v 1.2 1996/06/26 05:32:28 deraadt Exp $";
d157 1
a157 1
	if (head)
d181 1
@


1.2
log
@rcsid
@
text
@d1 1
a1 1
/*	$OpenBSD: ctags.c,v 1.4 1995/09/02 05:57:23 jtc Exp $	*/
d47 1
a47 1
static char rcsid[] = "$OpenBSD: ctags.c,v 1.4 1995/09/02 05:57:23 jtc Exp $";
d101 1
a101 1
	while ((ch = getopt(argc, argv, "BFadf:tuwvx")) != EOF)
@


1.1
log
@Initial revision
@
text
@d1 1
d47 1
a47 1
static char rcsid[] = "$NetBSD: ctags.c,v 1.4 1995/09/02 05:57:23 jtc Exp $";
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@
