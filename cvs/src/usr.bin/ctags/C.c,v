head	1.15;
access;
symbols
	OPENBSD_6_1:1.15.0.12
	OPENBSD_6_1_BASE:1.15
	OPENBSD_6_0:1.15.0.8
	OPENBSD_6_0_BASE:1.15
	OPENBSD_5_9:1.15.0.4
	OPENBSD_5_9_BASE:1.15
	OPENBSD_5_8:1.15.0.6
	OPENBSD_5_8_BASE:1.15
	OPENBSD_5_7:1.15.0.2
	OPENBSD_5_7_BASE:1.15
	OPENBSD_5_6:1.14.0.12
	OPENBSD_5_6_BASE:1.14
	OPENBSD_5_5:1.14.0.10
	OPENBSD_5_5_BASE:1.14
	OPENBSD_5_4:1.14.0.6
	OPENBSD_5_4_BASE:1.14
	OPENBSD_5_3:1.14.0.4
	OPENBSD_5_3_BASE:1.14
	OPENBSD_5_2:1.14.0.2
	OPENBSD_5_2_BASE:1.14
	OPENBSD_5_1_BASE:1.13
	OPENBSD_5_1:1.13.0.6
	OPENBSD_5_0:1.13.0.4
	OPENBSD_5_0_BASE:1.13
	OPENBSD_4_9:1.13.0.2
	OPENBSD_4_9_BASE:1.13
	OPENBSD_4_8:1.12.0.4
	OPENBSD_4_8_BASE:1.12
	OPENBSD_4_7:1.12.0.2
	OPENBSD_4_7_BASE:1.12
	OPENBSD_4_6:1.11.0.26
	OPENBSD_4_6_BASE:1.11
	OPENBSD_4_5:1.11.0.22
	OPENBSD_4_5_BASE:1.11
	OPENBSD_4_4:1.11.0.20
	OPENBSD_4_4_BASE:1.11
	OPENBSD_4_3:1.11.0.18
	OPENBSD_4_3_BASE:1.11
	OPENBSD_4_2:1.11.0.16
	OPENBSD_4_2_BASE:1.11
	OPENBSD_4_1:1.11.0.14
	OPENBSD_4_1_BASE:1.11
	OPENBSD_4_0:1.11.0.12
	OPENBSD_4_0_BASE:1.11
	OPENBSD_3_9:1.11.0.10
	OPENBSD_3_9_BASE:1.11
	OPENBSD_3_8:1.11.0.8
	OPENBSD_3_8_BASE:1.11
	OPENBSD_3_7:1.11.0.6
	OPENBSD_3_7_BASE:1.11
	OPENBSD_3_6:1.11.0.4
	OPENBSD_3_6_BASE:1.11
	OPENBSD_3_5:1.11.0.2
	OPENBSD_3_5_BASE:1.11
	OPENBSD_3_4:1.10.0.2
	OPENBSD_3_4_BASE:1.10
	OPENBSD_3_3:1.7.0.6
	OPENBSD_3_3_BASE:1.7
	OPENBSD_3_2:1.7.0.4
	OPENBSD_3_2_BASE:1.7
	OPENBSD_3_1:1.7.0.2
	OPENBSD_3_1_BASE:1.7
	OPENBSD_3_0:1.6.0.6
	OPENBSD_3_0_BASE:1.6
	OPENBSD_2_9_BASE:1.6
	OPENBSD_2_9:1.6.0.4
	OPENBSD_2_8:1.6.0.2
	OPENBSD_2_8_BASE:1.6
	OPENBSD_2_7:1.4.0.12
	OPENBSD_2_7_BASE:1.4
	OPENBSD_2_6:1.4.0.10
	OPENBSD_2_6_BASE:1.4
	OPENBSD_2_5:1.4.0.8
	OPENBSD_2_5_BASE:1.4
	OPENBSD_2_4:1.4.0.6
	OPENBSD_2_4_BASE:1.4
	OPENBSD_2_3:1.4.0.4
	OPENBSD_2_3_BASE:1.4
	OPENBSD_2_2:1.4.0.2
	OPENBSD_2_2_BASE:1.4
	OPENBSD_2_1:1.2.0.4
	OPENBSD_2_1_BASE:1.2
	OPENBSD_2_0:1.2.0.2
	OPENBSD_2_0_BASE:1.2
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.15
date	2014.12.08.03.58.56;	author jsg;	state Exp;
branches;
next	1.14;
commitid	hzl3ngjIHChOhZzd;

1.14
date	2012.03.04.04.05.15;	author fgsch;	state Exp;
branches;
next	1.13;

1.13
date	2010.11.03.19.39.38;	author millert;	state Exp;
branches;
next	1.12;

1.12
date	2009.10.27.23.59.37;	author deraadt;	state Exp;
branches;
next	1.11;

1.11
date	2003.10.28.13.23.59;	author avsm;	state Exp;
branches;
next	1.10;

1.10
date	2003.06.12.20.58.09;	author deraadt;	state Exp;
branches;
next	1.9;

1.9
date	2003.06.03.02.56.07;	author millert;	state Exp;
branches;
next	1.8;

1.8
date	2003.05.12.20.41.39;	author pjanzen;	state Exp;
branches;
next	1.7;

1.7
date	2002.02.16.21.27.45;	author millert;	state Exp;
branches;
next	1.6;

1.6
date	2000.07.26.17.46.52;	author espie;	state Exp;
branches;
next	1.5;

1.5
date	2000.07.25.19.28.30;	author deraadt;	state Exp;
branches;
next	1.4;

1.4
date	97.07.21.23.18.45;	author deraadt;	state Exp;
branches;
next	1.3;

1.3
date	97.06.30.06.26.33;	author deraadt;	state Exp;
branches;
next	1.2;

1.2
date	96.06.26.05.32.26;	author deraadt;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.45.04;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.45.04;	author deraadt;	state Exp;
branches;
next	;


desc
@@


1.15
log
@fix a crash with '(' at EOF found with the afl fuzzer
ok deraadt@@ tobias@@
@
text
@/*	$OpenBSD: C.c,v 1.14 2012/03/04 04:05:15 fgsch Exp $	*/
/*	$NetBSD: C.c,v 1.3 1995/03/26 20:14:02 glass Exp $	*/

/*
 * Copyright (c) 1987, 1993, 1994
 *	The Regents of the University of California.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */

#include <limits.h>
#include <stdio.h>
#include <string.h>

#include "ctags.h"

static int	func_entry(void);
static void	hash_entry(void);
static void	skip_string(int);
static int	str_entry(int);

/*
 * c_entries --
 *	read .c and .h files and call appropriate routines
 */
void
c_entries(void)
{
	int	c;			/* current character */
	int	level;			/* brace level */
	int	token;			/* if reading a token */
	int	t_def;			/* if reading a typedef */
	int	t_level;		/* typedef's brace level */
	char	*sp;			/* buffer pointer */
	char	tok[MAXTOKEN];		/* token buffer */

	lineftell = ftell(inf);
	sp = tok; token = t_def = NO; t_level = -1; level = 0; lineno = 1;
	while (GETC(!=, EOF)) {
		switch (c) {
		/*
		 * Here's where it DOESN'T handle: {
		 *	foo(a)
		 *	{
		 *	#ifdef notdef
		 *		}
		 *	#endif
		 *		if (a)
		 *			puts("hello, world");
		 *	}
		 */
		case '{':
			++level;
			goto endtok;
		case '}':
			/*
			 * if level goes below zero, try and fix
			 * it, even though we've already messed up
			 */
			if (--level < 0)
				level = 0;
			goto endtok;

		case '\n':
			SETLINE;
			/*
			 * the above 3 cases are similar in that they
			 * are special characters that also end tokens.
			 */
endtok:			if (sp > tok) {
				*sp = EOS;
				token = YES;
				sp = tok;
			}
			else
				token = NO;
			continue;

		/*
		 * We ignore quoted strings and character constants
		 * completely.
		 */
		case '"':
		case '\'':
			(void)skip_string(c);
			break;

		/*
		 * comments can be fun; note the state is unchanged after
		 * return, in case we found:
		 *	"foo() XX comment XX { int bar; }"
		 */
		case '/':
			if (GETC(==, '*')) {
				skip_comment(c);
				continue;
			} else if (c == '/') {
				skip_comment(c);
				continue;
			}
			(void)ungetc(c, inf);
			c = '/';
			goto storec;

		/* hash marks flag #define's. */
		case '#':
			if (sp == tok) {
				hash_entry();
				break;
			}
			goto storec;

		/*
		 * if we have a current token, parenthesis on
		 * level zero indicates a function.
		 */
		case '(':
			do {
				if (GETC(==, EOF))
					return;
			} while (iswhite(c));
			if (c == '*')
				break;
			else
				ungetc(c, inf);
			if (!level && token) {
				int	curline;

				if (sp != tok)
					*sp = EOS;
				/*
				 * grab the line immediately, we may
				 * already be wrong, for example,
				 *	foo\n
				 *	(arg1,
				 */
				get_line();
				curline = lineno;
				if (func_entry()) {
					++level;
					pfnote(tok, curline);
				}
				break;
			}
			goto storec;

		/*
		 * semi-colons indicate the end of a typedef; if we find a
		 * typedef we search for the next semi-colon of the same
		 * level as the typedef.  Ignoring "structs", they are
		 * tricky, since you can find:
		 *
		 *	"typedef int time_t;"
		 *	"typedef unsigned int u_int;"
		 *	"typedef unsigned int u_int [10];"
		 *
		 * If looking at a typedef, we save a copy of the last token
		 * found.  Then, when we find the ';' we take the current
		 * token if it starts with a valid token name, else we take
		 * the one we saved.  There's probably some reasonable
		 * alternative to this...
		 */
		case ';':
			if (t_def && level == t_level) {
				t_def = NO;
				get_line();
				if (sp != tok)
					*sp = EOS;
				pfnote(tok, lineno);
				break;
			}
			goto storec;

		/*
		 * store characters until one that can't be part of a token
		 * comes along; check the current token against certain
		 * reserved words.
		 */
		default:
			/*
			 * to treat following function.
			 * func      (arg) {
			 * ....
			 * }
			 */
			if (c == ' ' || c == '\t') {
				int save = c;
				while (GETC(!=, EOF) && (c == ' ' || c == '\t'))
					;
				if (c == EOF)
					return;
				(void)ungetc(c, inf);
				c = save;
			}
	storec:		if (!intoken(c)) {
				if (sp == tok)
					break;
				*sp = EOS;
				/* no typedefs inside typedefs */
				if (!t_def &&
					   !memcmp(tok, "typedef",8)) {
					t_def = YES;
					t_level = level;
					break;
				}
				/* catch "typedef struct" */
				if ((!t_def || t_level < level)
				    && (!memcmp(tok, "struct", 7)
				    || !memcmp(tok, "union", 6)
				    || !memcmp(tok, "enum", 5))) {
					/*
					 * get line immediately;
					 * may change before '{'
					 */
					get_line();
					if (str_entry(c))
						++level;
					break;
					/* } */
				}
				sp = tok;
			}
			else if (sp != tok || begtoken(c)) {
				/* hell... truncate it */
				if (sp == tok + sizeof tok - 1)
					*sp = EOS;
				else 
					*sp++ = c;
				token = YES;
			}
			continue;
		}

		sp = tok;
		token = NO;
	}
}

/*
 * func_entry --
 *	handle a function reference
 */
static int
func_entry(void)
{
	int	c;			/* current character */
	int	level = 0;		/* for matching '()' */
	static char attribute[] = "__attribute__";
	char maybe_attribute[sizeof attribute + 1];
	char *anext;

	/*
	 * Find the end of the assumed function declaration.
	 * Note that ANSI C functions can have type definitions so keep
	 * track of the parentheses nesting level.
	 */
	while (GETC(!=, EOF)) {
		switch (c) {
		case '\'':
		case '"':
			/* skip strings and character constants */
			skip_string(c);
			break;
		case '/':
			/* skip comments */
			if (GETC(==, '*'))
				skip_comment(c);
			else if (c == '/')
				skip_comment(c);
			break;
		case '(':
			level++;
			break;
		case ')':
			if (level == 0)
				goto fnd;
			level--;
			break;
		case '\n':
			SETLINE;
		}
	}
	return (NO);
fnd:
	/*
	 * we assume that the character after a function's right paren
	 * is a token character if it's a function and a non-token
	 * character if it's a declaration.  Comments don't count...
	 */
	for (anext = maybe_attribute;;) {
		while (GETC(!=, EOF) && iswhite(c))
			if (c == '\n')
				SETLINE;
		if (c == EOF)
			return NO;
		/*
		 * Recognize the GNU __attribute__ extension, which would
		 * otherwise make the heuristic test DTWT
		 */
		if (anext == maybe_attribute) {
			if (intoken(c)) {
				*anext++ = c;
				continue;
			}
		} else {
			if (intoken(c)) {
				if (anext - maybe_attribute < (int)(sizeof attribute - 1))
					*anext++ = c;
				else
					break;
				continue;
			} else {
				*anext++ = '\0';
				if (strcmp(maybe_attribute, attribute) == 0) {
					(void)ungetc(c, inf);
					return NO;
				}
				break;
			}
		}
		if (intoken(c) || c == '{')
			break;
		if (c == '/' && GETC(==, '*'))
			skip_comment(c);
		else if (c == '/')
			skip_comment(c);
		else {				/* don't ever "read" '/' */
			(void)ungetc(c, inf);
			return (NO);
		}
	}
	if (c != '{')
		(void)skip_key('{');
	return (YES);
}

/*
 * hash_entry --
 *	handle a line starting with a '#'
 */
static void
hash_entry(void)
{
	int	c;			/* character read */
	int	curline;		/* line started on */
	char	*sp;			/* buffer pointer */
	char	tok[MAXTOKEN];		/* storage buffer */

	/*
	 * to treat following macro.
	 * #     macro(arg)        ....
	 */
	while (GETC(!=, EOF) && (c == ' ' || c == '\t'))
		;
	(void)ungetc(c, inf);

	curline = lineno;
	for (sp = tok;;) {		/* get next token */
		if (GETC(==, EOF))
			return;
		if (iswhite(c))
			break;
		/* hell... truncate it */
		if (sp == tok + sizeof tok - 1)
			*sp = EOS;
		else 
			*sp++ = c;
	}
	*sp = EOS;
	if (memcmp(tok, "define", 6))	/* only interested in #define's */
		goto skip;
	for (;;) {			/* this doesn't handle "#define \n" */
		if (GETC(==, EOF))
			return;
		if (!iswhite(c))
			break;
	}
	for (sp = tok;;) {		/* get next token */
		/* hell... truncate it */
		if (sp == tok + sizeof tok - 1)
			*sp = EOS;
		else 
			*sp++ = c;
		if (GETC(==, EOF))
			return;
		/*
		 * this is where it DOESN'T handle
		 * "#define \n"
		 */
		if (!intoken(c))
			break;
	}
	*sp = EOS;
	if (dflag || c == '(') {	/* only want macros */
		get_line();
		pfnote(tok, curline);
	}
skip:	if (c == '\n') {		/* get rid of rest of define */
		SETLINE
		if (*(sp - 1) != '\\')
			return;
	}
	(void)skip_key('\n');
}

/*
 * str_entry --
 *	handle a struct, union or enum entry
 */
static int
str_entry(int c)
{
	int	curline;		/* line started on */
	char	*sp;			/* buffer pointer */
	char	tok[LINE_MAX];		/* storage buffer */

	curline = lineno;
	while (iswhite(c))
		if (GETC(==, EOF))
			return (NO);
	if (c == '{')		/* it was "struct {" */
		return (YES);
	for (sp = tok;;) {		/* get next token */
		/* hell... truncate it */
		if (sp == tok + sizeof tok - 1)
			*sp = EOS;
		else 
			*sp++ = c;
		if (GETC(==, EOF))
			return (NO);
		if (!intoken(c))
			break;
	}
	switch (c) {
		case '{':		/* it was "struct foo{" */
			--sp;
			break;
		case '\n':		/* it was "struct foo\n" */
			SETLINE;
			/*FALLTHROUGH*/
		default:		/* probably "struct foo " */
			while (GETC(!=, EOF))
				if (!iswhite(c))
					break;
			if (c != '{') {
				(void)ungetc(c, inf);
				return (NO);
			}
	}
	*sp = EOS;
	pfnote(tok, curline);
	return (YES);
}

/*
 * skip_comment --
 *	skip over comment
 */
void
skip_comment(int commenttype)
{
	int	c;			/* character read */
	int	star;			/* '*' flag */

	for (star = 0; GETC(!=, EOF);)
		switch(c) {
		/* comments don't nest, nor can they be escaped. */
		case '*':
			star = YES;
			break;
		case '/':
			if (commenttype == '*' && star)
				return;
			break;
		case '\n':
			if (commenttype == '/') {
				/* We don't really parse C, so sometimes it
				 * is necessary to see the newline
				 */
				ungetc(c, inf);
				return;
			}
			SETLINE;
			/*FALLTHROUGH*/
		default:
			star = NO;
			break;
		}
}

/*
 * skip_string --
 *	skip to the end of a string or character constant.
 */
static void
skip_string(int key)
{
	int	c,
		skip;

	for (skip = NO; GETC(!=, EOF); )
		switch (c) {
		case '\\':		/* a backslash escapes anything */
			skip = !skip;	/* we toggle in case it's "\\" */
			break;
		case '\n':
			SETLINE;
			/*FALLTHROUGH*/
		default:
			if (c == key && !skip)
				return;
			skip = NO;
		}
}

/*
 * skip_key --
 *	skip to next char "key"
 */
int
skip_key(int key)
{
	int	c,
		skip,
		retval;

	for (skip = retval = NO; GETC(!=, EOF);)
		switch(c) {
		case '\\':		/* a backslash escapes anything */
			skip = !skip;	/* we toggle in case it's "\\" */
			break;
		case ';':		/* special case for yacc; if one */
		case '|':		/* of these chars occurs, we may */
			retval = YES;	/* have moved out of the rule */
			break;		/* not used by C */
		case '\'':
		case '"':
			/* skip strings and character constants */
			skip_string(c);
			break;
		case '/':
			/* skip comments */
			if (GETC(==, '*')) {
				skip_comment(c);
				break;
			} else if (c == '/') {
				skip_comment(c);
				break;
			}
			(void)ungetc(c, inf);
			c = '/';
			goto norm;
		case '\n':
			SETLINE;
			/*FALLTHROUGH*/
		default:
		norm:
			if (c == key && !skip)
				return (retval);
			skip = NO;
		}
	return (retval);
}
@


1.14
log
@In preparation for getline and getdelim additions to libc, rename getline()
occurrences to get_line().
Based on a diff from Jan Klemkow <j-dot-klemkow-at-wemelug-dot-de> to tech.
@
text
@d1 1
a1 1
/*	$OpenBSD: C.c,v 1.13 2010/11/03 19:39:38 millert Exp $	*/
d141 2
a142 1
				c = getc(inf);
@


1.13
log
@POSIX specifies that ctags create tags for typedefs, structs, unions,
and enums by default.  The -t flag becomes a no-op for backwards
compat only.  OK deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: C.c,v 1.12 2009/10/27 23:59:37 deraadt Exp $	*/
d158 1
a158 1
				getline();
d187 1
a187 1
				getline();
d236 1
a236 1
					getline();
d416 1
a416 1
		getline();
@


1.12
log
@rcsid[] and sccsid[] and copyright[] are essentially unmaintained (and
unmaintainable).  these days, people use source.  these id's do not provide
any benefit, and do hurt the small install media
(the 33,000 line diff is essentially mechanical)
ok with the idea millert, ok dms
@
text
@d1 1
a1 1
/*	$OpenBSD: C.c,v 1.11 2003/10/28 13:23:59 avsm Exp $	*/
d220 21
a240 23
				if (tflag) {
					/* no typedefs inside typedefs */
					if (!t_def &&
						   !memcmp(tok, "typedef",8)) {
						t_def = YES;
						t_level = level;
						break;
					}
					/* catch "typedef struct" */
					if ((!t_def || t_level < level)
					    && (!memcmp(tok, "struct", 7)
					    || !memcmp(tok, "union", 6)
					    || !memcmp(tok, "enum", 5))) {
						/*
						 * get line immediately;
						 * may change before '{'
						 */
						getline();
						if (str_entry(c))
							++level;
						break;
						/* } */
					}
@


1.11
log
@prototype declared static, but function was not. add static to function.
millert@@ otto@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: C.c,v 1.10 2003/06/12 20:58:09 deraadt Exp $	*/
a31 8

#ifndef lint
#if 0
static char sccsid[] = "@@(#)C.c	8.4 (Berkeley) 4/2/94";
#else
static char rcsid[] = "$OpenBSD: C.c,v 1.10 2003/06/12 20:58:09 deraadt Exp $";
#endif
#endif /* not lint */
@


1.10
log
@de-register and ansification; millert ok
@
text
@d1 1
a1 1
/*	$OpenBSD: C.c,v 1.9 2003/06/03 02:56:07 millert Exp $	*/
d37 1
a37 1
static char rcsid[] = "$OpenBSD: C.c,v 1.9 2003/06/03 02:56:07 millert Exp $";
d526 1
a526 1
void
@


1.9
log
@Remove the advertising clause in the UCB license which Berkeley
rescinded 22 July 1999.  Proofed by myself and Theo.
@
text
@d1 1
a1 1
/*	$OpenBSD: C.c,v 1.8 2003/05/12 20:41:39 pjanzen Exp $	*/
d37 1
a37 1
static char rcsid[] = "$OpenBSD: C.c,v 1.8 2003/05/12 20:41:39 pjanzen Exp $";
d57 1
a57 1
c_entries()
d275 1
a275 1
func_entry()
d373 1
a373 1
hash_entry()
d442 1
a442 2
str_entry(c)
	int	c;			/* current character */
d527 1
a527 2
skip_string(key)
	int	key;
d552 1
a552 2
skip_key(key)
	int	key;
@


1.8
log
@merge in NetBSD diffs:
 - understand // comments
 - ignore 'int (*f)();'
 - accept the GNU __attribute__ keyword.
deraadt@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: C.c,v 1.7 2002/02/16 21:27:45 millert Exp $	*/
d16 1
a16 5
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
d37 1
a37 1
static char rcsid[] = "$OpenBSD: C.c,v 1.7 2002/02/16 21:27:45 millert Exp $";
@


1.7
log
@Part one of userland __P removal.  Done with a simple regexp with some minor hand editing to make comments line up correctly.  Another pass is forthcoming that handles the cases that could not be done automatically.
@
text
@d1 1
a1 1
/*	$OpenBSD: C.c,v 1.6 2000/07/26 17:46:52 espie Exp $	*/
d41 1
a41 1
static char rcsid[] = "$OpenBSD: C.c,v 1.6 2000/07/26 17:46:52 espie Exp $";
d129 4
a132 1
				skip_comment();
d152 7
d283 3
d302 3
a304 1
				skip_comment();
d325 1
a325 1
	for (;;) {
d329 27
d359 3
a361 1
			skip_comment();
d496 1
a496 1
skip_comment()
d508 1
a508 1
			if (star)
d512 7
d582 4
a585 1
				skip_comment();
@


1.6
log
@Still truncate too long identifiers, but avoid writing all over the stack.
@
text
@d1 1
a1 1
/*	$OpenBSD: C.c,v 1.5 2000/07/25 19:28:30 deraadt Exp $	*/
d41 1
a41 1
static char rcsid[] = "$OpenBSD: C.c,v 1.5 2000/07/25 19:28:30 deraadt Exp $";
d51 4
a54 4
static int	func_entry __P((void));
static void	hash_entry __P((void));
static void	skip_string __P((int));
static int	str_entry __P((int));
@


1.5
log
@deal with a number of overflows pointed out by fuzz; in most cases, we truncate the symbol in question
@
text
@d1 1
a1 1
/*	$OpenBSD: C.c,v 1.4 1997/07/21 23:18:45 deraadt Exp $	*/
d41 1
a41 1
static char rcsid[] = "$OpenBSD: C.c,v 1.4 1997/07/21 23:18:45 deraadt Exp $";
d249 4
a252 6
				if (sp >= tok + sizeof tok) {
					/* hell... truncate it */
					if (sp == tok + sizeof(tok))
						*sp = '\0';
					sp++;
				} else
d354 4
a357 6
		if (sp >= tok + sizeof(tok)) {
			/* hell... truncate it */
			if (sp == tok + sizeof(tok))
				*sp = '\0';
			sp++;
		} else		
d370 4
a373 6
		if (sp >= tok + sizeof tok) {
			/* hell... truncate it */
			if (sp == tok + sizeof(tok))
				*sp = '\0';
			sp++;
		} else
d416 4
a419 6
		if (sp >= tok + sizeof tok) {
			/* hell... truncate it */
			if (sp == tok + sizeof(tok))
				*sp = '\0';
			sp++;
		} else
@


1.4
log
@make it less sensitive to incredibly bad indentation; shigio@@wafu.netgate.net
@
text
@d1 1
a1 1
/*	$OpenBSD: C.c,v 1.3 1997/06/30 06:26:33 deraadt Exp $	*/
d41 1
a41 1
static char rcsid[] = "$OpenBSD: C.c,v 1.3 1997/06/30 06:26:33 deraadt Exp $";
d104 1
a104 1
	endtok:			if (sp > tok) {
d249 7
a255 1
				*sp++ = c;
d356 7
a362 1
		*sp++ = c;
d374 7
a380 1
		*sp++ = c;
d422 7
a428 1
		*sp++ = c;
@


1.3
log
@time_t is not long; not even in a comment
@
text
@d1 1
a1 1
/*	$OpenBSD: C.c,v 1.2 1996/06/26 05:32:26 deraadt Exp $	*/
d41 1
a41 1
static char rcsid[] = "$OpenBSD: C.c,v 1.2 1996/06/26 05:32:26 deraadt Exp $";
d203 15
d335 8
@


1.2
log
@rcsid
@
text
@d1 1
a1 1
/*	$OpenBSD: C.c,v 1.3 1995/03/26 20:14:02 glass Exp $	*/
d41 1
a41 1
static char rcsid[] = "$OpenBSD: C.c,v 1.3 1995/03/26 20:14:02 glass Exp $";
d176 1
a176 1
		 *	"typedef long time_t;"
@


1.1
log
@Initial revision
@
text
@d1 1
d41 1
a41 1
static char rcsid[] = "$NetBSD: C.c,v 1.3 1995/03/26 20:14:02 glass Exp $";
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@
