head	1.29;
access;
symbols
	OPENBSD_6_1:1.28.0.4
	OPENBSD_6_1_BASE:1.28
	OPENBSD_6_0:1.22.0.4
	OPENBSD_6_0_BASE:1.22
	OPENBSD_5_9:1.22.0.2
	OPENBSD_5_9_BASE:1.22
	OPENBSD_5_8:1.20.0.6
	OPENBSD_5_8_BASE:1.20
	OPENBSD_5_7:1.20.0.2
	OPENBSD_5_7_BASE:1.20
	OPENBSD_5_6:1.19.0.6
	OPENBSD_5_6_BASE:1.19
	OPENBSD_5_5:1.19.0.4
	OPENBSD_5_5_BASE:1.19
	OPENBSD_5_4:1.18.0.2
	OPENBSD_5_4_BASE:1.18
	OPENBSD_5_3:1.17.0.2
	OPENBSD_5_3_BASE:1.17
	OPENBSD_5_2:1.16.0.2
	OPENBSD_5_2_BASE:1.16
	OPENBSD_5_1_BASE:1.15
	OPENBSD_5_1:1.15.0.6
	OPENBSD_5_0:1.15.0.4
	OPENBSD_5_0_BASE:1.15
	OPENBSD_4_9:1.15.0.2
	OPENBSD_4_9_BASE:1.15
	OPENBSD_4_8:1.14.0.4
	OPENBSD_4_8_BASE:1.14
	OPENBSD_4_7:1.14.0.2
	OPENBSD_4_7_BASE:1.14
	OPENBSD_4_6:1.2.0.4
	OPENBSD_4_6_BASE:1.2;
locks; strict;
comment	@ * @;


1.29
date	2017.06.14.07.42.41;	author nicm;	state Exp;
branches;
next	1.28;
commitid	tCNdorwrrKWv0zr4;

1.28
date	2017.01.24.19.53.37;	author nicm;	state Exp;
branches;
next	1.27;
commitid	APEyI6NiCN6S4KhZ;

1.27
date	2017.01.16.14.52.25;	author nicm;	state Exp;
branches;
next	1.26;
commitid	DhrjePH0tXykfoeE;

1.26
date	2017.01.16.14.49.14;	author nicm;	state Exp;
branches;
next	1.25;
commitid	4TgBXjnsq23XHMH4;

1.25
date	2017.01.15.22.00.56;	author nicm;	state Exp;
branches;
next	1.24;
commitid	P8Zuj7wnJMd8B8vz;

1.24
date	2016.10.14.22.14.22;	author nicm;	state Exp;
branches;
next	1.23;
commitid	S3IpyYTkmviA6lfM;

1.23
date	2016.10.10.21.51.39;	author nicm;	state Exp;
branches;
next	1.22;
commitid	TaZ3kOtGiWwKofka;

1.22
date	2016.01.19.15.59.12;	author nicm;	state Exp;
branches;
next	1.21;
commitid	P3qmSOx6KrDBsb0c;

1.21
date	2015.10.28.09.51.55;	author nicm;	state Exp;
branches;
next	1.20;
commitid	eGVGKzVVYKHFvkn4;

1.20
date	2014.10.08.17.35.58;	author nicm;	state Exp;
branches;
next	1.19;
commitid	mK8z9uVwDZMfiNoM;

1.19
date	2013.10.10.12.14.09;	author nicm;	state Exp;
branches;
next	1.18;

1.18
date	2013.03.24.09.54.10;	author nicm;	state Exp;
branches;
next	1.17;

1.17
date	2012.12.06.12.47.48;	author nicm;	state Exp;
branches;
next	1.16;

1.16
date	2012.07.10.11.53.01;	author nicm;	state Exp;
branches;
next	1.15;

1.15
date	2010.12.13.22.53.14;	author nicm;	state Exp;
branches;
next	1.14;

1.14
date	2010.02.19.17.14.23;	author nicm;	state Exp;
branches;
next	1.13;

1.13
date	2010.01.31.18.47.03;	author nicm;	state Exp;
branches;
next	1.12;

1.12
date	2009.12.03.22.50.10;	author nicm;	state Exp;
branches;
next	1.11;

1.11
date	2009.11.26.21.14.30;	author nicm;	state Exp;
branches;
next	1.10;

1.10
date	2009.11.21.17.52.18;	author nicm;	state Exp;
branches;
next	1.9;

1.9
date	2009.11.16.11.15.44;	author nicm;	state Exp;
branches;
next	1.8;

1.8
date	2009.11.11.18.56.07;	author nicm;	state Exp;
branches;
next	1.7;

1.7
date	2009.10.26.21.42.04;	author deraadt;	state Exp;
branches;
next	1.6;

1.6
date	2009.08.08.21.52.43;	author nicm;	state Exp;
branches;
next	1.5;

1.5
date	2009.08.03.14.10.54;	author nicm;	state Exp;
branches;
next	1.4;

1.4
date	2009.07.13.18.49.36;	author nicm;	state Exp;
branches;
next	1.3;

1.3
date	2009.07.08.16.04.56;	author nicm;	state Exp;
branches;
next	1.2;

1.2
date	2009.06.05.07.18.37;	author nicm;	state Exp;
branches;
next	1.1;

1.1
date	2009.06.01.22.58.49;	author nicm;	state Exp;
branches;
next	;


desc
@@


1.29
log
@Don't overwrite error message when it is available in
cmd_string_parse. Reported by Jimi Damon in GitHub issue 975.
@
text
@/* $OpenBSD: cmd-string.c,v 1.28 2017/01/24 19:53:37 nicm Exp $ */

/*
 * Copyright (c) 2008 Nicholas Marriott <nicholas.marriott@@gmail.com>
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF MIND, USE, DATA OR PROFITS, WHETHER
 * IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING
 * OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */

#include <sys/types.h>

#include <errno.h>
#include <pwd.h>
#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <unistd.h>

#include "tmux.h"

/*
 * Parse a command from a string.
 */

static int	 cmd_string_getc(const char *, size_t *);
static void	 cmd_string_ungetc(size_t *);
static void	 cmd_string_copy(char **, char *, size_t *);
static char	*cmd_string_string(const char *, size_t *, char, int);
static char	*cmd_string_variable(const char *, size_t *);
static char	*cmd_string_expand_tilde(const char *, size_t *);

static int
cmd_string_getc(const char *s, size_t *p)
{
	const u_char	*ucs = s;

	if (ucs[*p] == '\0')
		return (EOF);
	return (ucs[(*p)++]);
}

static void
cmd_string_ungetc(size_t *p)
{
	(*p)--;
}

int
cmd_string_split(const char *s, int *rargc, char ***rargv)
{
	size_t		p = 0;
	int		ch, argc = 0, append = 0;
	char	      **argv = NULL, *buf = NULL, *t;
	const char     *whitespace, *equals;
	size_t		len = 0;

	for (;;) {
		ch = cmd_string_getc(s, &p);
		switch (ch) {
		case '\'':
			if ((t = cmd_string_string(s, &p, '\'', 0)) == NULL)
				goto error;
			cmd_string_copy(&buf, t, &len);
			break;
		case '"':
			if ((t = cmd_string_string(s, &p, '"', 1)) == NULL)
				goto error;
			cmd_string_copy(&buf, t, &len);
			break;
		case '$':
			if ((t = cmd_string_variable(s, &p)) == NULL)
				goto error;
			cmd_string_copy(&buf, t, &len);
			break;
		case '#':
			/* Comment: discard rest of line. */
			while ((ch = cmd_string_getc(s, &p)) != EOF)
				;
			/* FALLTHROUGH */
		case EOF:
		case ' ':
		case '\t':
			if (buf != NULL) {
				buf = xrealloc(buf, len + 1);
				buf[len] = '\0';

				argv = xreallocarray(argv, argc + 1,
				    sizeof *argv);
				argv[argc++] = buf;

				buf = NULL;
				len = 0;
			}

			if (ch != EOF)
				break;

			while (argc != 0) {
				equals = strchr(argv[0], '=');
				whitespace = argv[0] + strcspn(argv[0], " \t");
				if (equals == NULL || equals > whitespace)
					break;
				environ_put(global_environ, argv[0]);
				argc--;
				memmove(argv, argv + 1, argc * (sizeof *argv));
			}
			goto done;
		case '~':
			if (buf != NULL) {
				append = 1;
				break;
			}
			t = cmd_string_expand_tilde(s, &p);
			if (t == NULL)
				goto error;
			cmd_string_copy(&buf, t, &len);
			break;
		default:
			append = 1;
			break;
		}
		if (append) {
			if (len >= SIZE_MAX - 2)
				goto error;
			buf = xrealloc(buf, len + 1);
			buf[len++] = ch;
		}
		append = 0;
	}

done:
	*rargc = argc;
	*rargv = argv;

	free(buf);
	return (0);

error:
	if (argv != NULL)
		cmd_free_argv(argc, argv);
	free(buf);
	return (-1);
}

struct cmd_list *
cmd_string_parse(const char *s, const char *file, u_int line, char **cause)
{
	struct cmd_list	 *cmdlist = NULL;
	int		  argc;
	char		**argv;

	*cause = NULL;
	if (cmd_string_split(s, &argc, &argv) != 0) {
		xasprintf(cause, "invalid or unknown command: %s", s);
		return (NULL);
	}
	if (argc != 0) {
		cmdlist = cmd_list_parse(argc, argv, file, line, cause);
		if (cmdlist == NULL) {
			cmd_free_argv(argc, argv);
			return (NULL);
		}
	}
	cmd_free_argv(argc, argv);
	return (cmdlist);
}

static void
cmd_string_copy(char **dst, char *src, size_t *len)
{
	size_t srclen;

	srclen = strlen(src);

	*dst = xrealloc(*dst, *len + srclen + 1);
	strlcpy(*dst + *len, src, srclen + 1);

	*len += srclen;
	free(src);
}

static char *
cmd_string_string(const char *s, size_t *p, char endch, int esc)
{
	int	ch;
	char   *buf, *t;
	size_t	len;

	buf = NULL;
	len = 0;

	while ((ch = cmd_string_getc(s, p)) != endch) {
		switch (ch) {
		case EOF:
			goto error;
		case '\\':
			if (!esc)
				break;
			switch (ch = cmd_string_getc(s, p)) {
			case EOF:
				goto error;
			case 'e':
				ch = '\033';
				break;
			case 'r':
				ch = '\r';
				break;
			case 'n':
				ch = '\n';
				break;
			case 't':
				ch = '\t';
				break;
			}
			break;
		case '$':
			if (!esc)
				break;
			if ((t = cmd_string_variable(s, p)) == NULL)
				goto error;
			cmd_string_copy(&buf, t, &len);
			continue;
		}

		if (len >= SIZE_MAX - 2)
			goto error;
		buf = xrealloc(buf, len + 1);
		buf[len++] = ch;
	}

	buf = xrealloc(buf, len + 1);
	buf[len] = '\0';
	return (buf);

error:
	free(buf);
	return (NULL);
}

static char *
cmd_string_variable(const char *s, size_t *p)
{
	int			ch, fch;
	char		       *buf, *t;
	size_t			len;
	struct environ_entry   *envent;

#define cmd_string_first(ch) ((ch) == '_' || \
	((ch) >= 'a' && (ch) <= 'z') || ((ch) >= 'A' && (ch) <= 'Z'))
#define cmd_string_other(ch) ((ch) == '_' || \
	((ch) >= 'a' && (ch) <= 'z') || ((ch) >= 'A' && (ch) <= 'Z') || \
	((ch) >= '0' && (ch) <= '9'))

	buf = NULL;
	len = 0;

	fch = EOF;
	switch (ch = cmd_string_getc(s, p)) {
	case EOF:
		goto error;
	case '{':
		fch = '{';

		ch = cmd_string_getc(s, p);
		if (!cmd_string_first(ch))
			goto error;
		/* FALLTHROUGH */
	default:
		if (!cmd_string_first(ch)) {
			xasprintf(&t, "$%c", ch);
			return (t);
		}

		buf = xrealloc(buf, len + 1);
		buf[len++] = ch;

		for (;;) {
			ch = cmd_string_getc(s, p);
			if (ch == EOF || !cmd_string_other(ch))
				break;
			else {
				if (len >= SIZE_MAX - 3)
					goto error;
				buf = xrealloc(buf, len + 1);
				buf[len++] = ch;
			}
		}
	}

	if (fch == '{' && ch != '}')
		goto error;
	if (ch != EOF && fch != '{')
		cmd_string_ungetc(p); /* ch */

	buf = xrealloc(buf, len + 1);
	buf[len] = '\0';

	envent = environ_find(global_environ, buf);
	free(buf);
	if (envent == NULL)
		return (xstrdup(""));
	return (xstrdup(envent->value));

error:
	free(buf);
	return (NULL);
}

static char *
cmd_string_expand_tilde(const char *s, size_t *p)
{
	struct passwd		*pw;
	struct environ_entry	*envent;
	char			*home, *path, *user, *cp;
	int			 last;

	home = NULL;

	last = cmd_string_getc(s, p);
	if (last == EOF || last == '/' || last == ' '|| last == '\t') {
		envent = environ_find(global_environ, "HOME");
		if (envent != NULL && *envent->value != '\0')
			home = envent->value;
		else if ((pw = getpwuid(getuid())) != NULL)
			home = pw->pw_dir;
	} else {
		cmd_string_ungetc(p);

		cp = user = xmalloc(strlen(s));
		for (;;) {
			last = cmd_string_getc(s, p);
			if (last == EOF ||
			    last == '/' ||
			    last == ' '||
			    last == '\t')
				break;
			*cp++ = last;
		}
		*cp = '\0';

		if ((pw = getpwnam(user)) != NULL)
			home = pw->pw_dir;
		free(user);
	}

	if (home == NULL)
		return (NULL);

	if (last != EOF)
		xasprintf(&path, "%s%c", home, last);
	else
		xasprintf(&path, "%s", home);
	return (path);
}
@


1.28
log
@Add support for custom command aliases, this is an array option which
contains items of the form "alias=command". This is consulted when an
unknown command is parsed.
@
text
@d1 1
a1 1
/* $OpenBSD: cmd-string.c,v 1.27 2017/01/16 14:52:25 nicm Exp $ */
d162 4
a165 2
	if (cmd_string_split(s, &argc, &argv) != 0)
		goto error;
d170 1
a170 1
			goto error;
a174 4

error:
	xasprintf(cause, "invalid or unknown command: %s", s);
	return (NULL);
@


1.27
log
@Revert WIP parts of previous I didn't mean to commit yet.
@
text
@d1 1
a1 1
/* $OpenBSD: cmd-string.c,v 1.25 2017/01/15 22:00:56 nicm Exp $ */
d57 2
a58 2
struct cmd_list *
cmd_string_parse(const char *s, const char *file, u_int line, char **cause)
d60 5
a64 6
	size_t		  p = 0;
	int		  ch, i, argc = 0;
	char		**argv = NULL, *buf = NULL, *t;
	const char	 *whitespace, *equals;
	size_t		  len = 0;
	struct cmd_list	 *cmdlist = NULL;
a65 1
	*cause = NULL;
d116 1
a116 5
			if (argc == 0)
				goto out;

			cmdlist = cmd_list_parse(argc, argv, file, line, cause);
			goto out;
d118 2
a119 5
			if (buf == NULL) {
				t = cmd_string_expand_tilde(s, &p);
				if (t == NULL)
					goto error;
				cmd_string_copy(&buf, t, &len);
d122 5
a126 1
			/* FALLTHROUGH */
d128 4
a133 1

a135 1
			break;
d137 1
d140 7
d148 5
a152 1
	xasprintf(cause, "invalid or unknown command: %s", s);
d154 6
a159 2
out:
	free(buf);
d161 9
a169 4
	if (argv != NULL) {
		for (i = 0; i < argc; i++)
			free(argv[i]);
		free(argv);
d171 2
d174 3
a176 1
	return (cmdlist);
@


1.26
log
@getopt() has a struct option so just return to using options_entry.
@
text
@d57 2
a58 2
int
cmd_string_split(const char *s, int *rargc, char ***rargv)
d60 6
a65 5
	size_t		p = 0;
	int		ch, argc = 0, append = 0;
	char	      **argv = NULL, *buf = NULL, *t;
	const char     *whitespace, *equals;
	size_t		len = 0;
d67 1
d118 5
a122 1
			goto done;
d124 5
a128 2
			if (buf != NULL) {
				append = 1;
d131 1
a131 5
			t = cmd_string_expand_tilde(s, &p);
			if (t == NULL)
				goto error;
			cmd_string_copy(&buf, t, &len);
			break;
a132 4
			append = 1;
			break;
		}
		if (append) {
d135 1
d138 1
a139 1
		append = 0;
d142 2
a143 3
done:
	*rargc = argc;
	*rargv = argv;
d145 1
a146 1
	return (0);
d148 5
a152 6
error:
	if (argv != NULL)
		cmd_free_argv(argc, argv);
	free(buf);
	return (-1);
}
a153 18
struct cmd_list *
cmd_string_parse(const char *s, const char *file, u_int line, char **cause)
{
	struct cmd_list	 *cmdlist = NULL;
	int		  argc;
	char		**argv;

	*cause = NULL;
	if (cmd_string_split(s, &argc, &argv) != 0)
		goto error;
	if (argc != 0) {
		cmdlist = cmd_list_parse(argc, argv, file, line, cause);
		if (cmdlist == NULL) {
			cmd_free_argv(argc, argv);
			goto error;
		}
	}
	cmd_free_argv(argc, argv);
a154 4

error:
	xasprintf(cause, "invalid or unknown command: %s", s);
	return (NULL);
@


1.25
log
@It is silly for cmd_list_parse to return an integer error when it could
just return NULL.
@
text
@d1 1
a1 1
/* $OpenBSD: cmd-string.c,v 1.24 2016/10/14 22:14:22 nicm Exp $ */
d57 2
a58 2
struct cmd_list *
cmd_string_parse(const char *s, const char *file, u_int line, char **cause)
d60 5
a64 6
	size_t		  p = 0;
	int		  ch, i, argc = 0;
	char		**argv = NULL, *buf = NULL, *t;
	const char	 *whitespace, *equals;
	size_t		  len = 0;
	struct cmd_list	 *cmdlist = NULL;
a65 1
	*cause = NULL;
d116 1
a116 5
			if (argc == 0)
				goto out;

			cmdlist = cmd_list_parse(argc, argv, file, line, cause);
			goto out;
d118 2
a119 5
			if (buf == NULL) {
				t = cmd_string_expand_tilde(s, &p);
				if (t == NULL)
					goto error;
				cmd_string_copy(&buf, t, &len);
d122 5
a126 1
			/* FALLTHROUGH */
d128 4
a133 1

a135 1
			break;
d137 1
d140 7
d148 5
a152 1
	xasprintf(cause, "invalid or unknown command: %s", s);
d154 6
a159 2
out:
	free(buf);
d161 9
a169 4
	if (argv != NULL) {
		for (i = 0; i < argc; i++)
			free(argv[i]);
		free(argv);
d171 2
d174 3
a176 1
	return (cmdlist);
@


1.24
log
@Add CMD_AFTERHOOK flag to the easy commands that don't need any special handling.
@
text
@d1 1
a1 1
/* $OpenBSD: cmd-string.c,v 1.23 2016/10/10 21:51:39 nicm Exp $ */
d57 2
a58 7
/*
 * Parse command string. Returns -1 on error. If returning -1, cause is error
 * string, or NULL for empty command.
 */
int
cmd_string_parse(const char *s, struct cmd_list **cmdlist, const char *file,
    u_int line, char **cause)
d60 6
a65 11
	size_t		p;
	int		ch, i, argc, rval;
	char	      **argv, *buf, *t;
	const char     *whitespace, *equals;
	size_t		len;

	argv = NULL;
	argc = 0;

	buf = NULL;
	len = 0;
a67 5

	*cmdlist = NULL;
	rval = -1;

	p = 0;
d121 1
a121 6
			*cmdlist = cmd_list_parse(argc, argv, file, line,
			    cause);
			if (*cmdlist == NULL)
				goto out;

			rval = 0;
d154 1
a154 1
	return (rval);
@


1.23
log
@Add static in cmd-* and fix a few other nits.
@
text
@d1 1
a1 1
/* $OpenBSD: cmd-string.c,v 1.22 2016/01/19 15:59:12 nicm Exp $ */
d136 2
a137 1
			*cmdlist = cmd_list_parse(argc, argv, file, line, cause);
@


1.22
log
@I no longer use my SourceForge address so replace it.
@
text
@d1 1
a1 1
/* $OpenBSD: cmd-string.c,v 1.21 2015/10/28 09:51:55 nicm Exp $ */
d34 6
a39 6
int	 cmd_string_getc(const char *, size_t *);
void	 cmd_string_ungetc(size_t *);
void	 cmd_string_copy(char **, char *, size_t *);
char	*cmd_string_string(const char *, size_t *, char, int);
char	*cmd_string_variable(const char *, size_t *);
char	*cmd_string_expand_tilde(const char *, size_t *);
d41 1
a41 1
int
d51 1
a51 1
void
d176 1
a176 1
void
d190 1
a190 1
char *
d248 1
a248 1
char *
d317 1
a317 1
char *
d340 4
a343 1
			if (last == EOF || last == '/' || last == ' '|| last == '\t')
@


1.21
log
@Like options, move the environ struct into environ.c.
@
text
@d1 1
a1 1
/* $OpenBSD: cmd-string.c,v 1.20 2014/10/08 17:35:58 nicm Exp $ */
d4 1
a4 1
 * Copyright (c) 2008 Nicholas Marriott <nicm@@users.sourceforge.net>
@


1.20
log
@Add xreallocarray and remove nmemb argument from xrealloc.
@
text
@d1 1
a1 1
/* $OpenBSD: cmd-string.c,v 1.19 2013/10/10 12:14:09 nicm Exp $ */
d129 1
a129 1
				environ_put(&global_environ, argv[0]);
d306 1
a306 1
	envent = environ_find(&global_environ, buf);
d329 1
a329 1
		envent = environ_find(&global_environ, "HOME");
@


1.19
log
@Make tilde expansion in command strings work even if it isn't terminated by /.
@
text
@d1 1
a1 1
/* $OpenBSD: cmd-string.c,v 1.18 2013/03/24 09:54:10 nicm Exp $ */
d110 1
a110 1
				buf = xrealloc(buf, 1, len + 1);
d113 2
a114 1
				argv = xrealloc(argv, argc + 1, sizeof *argv);
d155 1
a155 1
			buf = xrealloc(buf, 1, len + 1);
d183 1
a183 1
	*dst = xrealloc(*dst, 1, *len + srclen + 1);
d235 1
a235 1
		buf = xrealloc(buf, 1, len + 1);
d239 1
a239 1
	buf = xrealloc(buf, 1, len + 1);
d282 1
a282 1
		buf = xrealloc(buf, 1, len + 1);
d292 1
a292 1
				buf = xrealloc(buf, 1, len + 1);
d303 1
a303 1
	buf = xrealloc(buf, 1, len + 1);
@


1.18
log
@Add a command queue to standardize and simplify commands that call other
commands and allow a command to block execution of subsequent
commands. This allows run-shell and if-shell to be synchronous which has
been much requested.

Each client has a default command queue and commands are consumed one at
a time from it. A command may suspend execution from the queue by
returning CMD_RETURN_WAIT and then resume it by calling cmd_continue() -
for example run-shell does this from the callback that is fired after
the job is freed.

When the command queue becomes empty, command clients are automatically
exited (unless attaching). A callback is also fired - this is used for
nested commands in, for example, if-shell which can block execution of
the client's cmdq until a new cmdq becomes empty.

Also merge all the old error/info/print functions together and lose the
old curclient/cmdclient distinction - a cmdq is bound to one client (or
none if in the configuration file), this is a command client if
c->session is NULL otherwise an attached client.
@
text
@d1 1
a1 1
/* $OpenBSD: cmd-string.c,v 1.17 2012/12/06 12:47:48 nicm Exp $ */
d321 2
a322 1
	char			*home, *path, *username;
d325 3
a327 1
	if (cmd_string_getc(s, p) == '/') {
d335 11
a345 3
		if ((username = cmd_string_string(s, p, '/', 0)) == NULL)
			return (NULL);
		if ((pw = getpwnam(username)) != NULL)
d347 1
a347 1
		free(username);
d349 1
d353 4
a356 1
	xasprintf(&path, "%s/", home);
@


1.17
log
@Simplify command string parsing with a helper function from Tiago Cunha.
@
text
@d1 1
a1 1
/* $OpenBSD: cmd-string.c,v 1.16 2012/07/10 11:53:01 nicm Exp $ */
d62 2
a63 1
cmd_string_parse(const char *s, struct cmd_list **cmdlist, char **cause)
d135 1
a135 1
			*cmdlist = cmd_list_parse(argc, argv, cause);
@


1.16
log
@xfree is not particularly helpful, remove it. From Thomas Adam.
@
text
@d1 1
a1 1
/* $OpenBSD: cmd-string.c,v 1.15 2010/12/13 22:53:14 nicm Exp $ */
d34 6
a39 5
int	cmd_string_getc(const char *, size_t *);
void	cmd_string_ungetc(size_t *);
char   *cmd_string_string(const char *, size_t *, char, int);
char   *cmd_string_variable(const char *, size_t *);
char   *cmd_string_expand_tilde(const char *, size_t *);
d88 1
a88 4
			buf = xrealloc(buf, 1, len + strlen(t) + 1);
			strlcpy(buf + len, t, strlen(t) + 1);
			len += strlen(t);
			free(t);
d93 1
a93 4
			buf = xrealloc(buf, 1, len + strlen(t) + 1);
			strlcpy(buf + len, t, strlen(t) + 1);
			len += strlen(t);
			free(t);
d98 1
a98 4
			buf = xrealloc(buf, 1, len + strlen(t) + 1);
			strlcpy(buf + len, t, strlen(t) + 1);
			len += strlen(t);
			free(t);
d142 2
a143 1
				if ((t = cmd_string_expand_tilde(s, &p)) == NULL)
d145 1
a145 4
				buf = xrealloc(buf, 1, len + strlen(t) + 1);
				strlcpy(buf + len, t, strlen(t) + 1);
				len += strlen(t);
				free(t);
d174 14
d227 1
a227 4
			buf = xrealloc(buf, 1, len + strlen(t) + 1);
			strlcpy(buf + len, t, strlen(t) + 1);
			len += strlen(t);
			free(t);
@


1.15
log
@Read ${X} environment variables in strings and $HOME from the global
environment rather than getenv, this allows them to be updated during
the configuration file.
@
text
@d1 1
a1 1
/* $OpenBSD: cmd-string.c,v 1.14 2010/02/19 17:14:23 nicm Exp $ */
d90 1
a90 1
			xfree(t);
d98 1
a98 1
			xfree(t);
d106 1
a106 1
			xfree(t);
d155 1
a155 1
				xfree(t);
d173 1
a173 2
	if (buf != NULL)
		xfree(buf);
d177 2
a178 2
			xfree(argv[i]);
		xfree(argv);
d226 1
a226 1
			xfree(t);
d241 1
a241 2
	if (buf != NULL)
		xfree(buf);
d304 1
a304 1
	xfree(buf);
d310 1
a310 2
	if (buf != NULL)
		xfree(buf);
d334 1
a334 1
		xfree(username);
@


1.14
log
@have_arg matches buf so it is no longer necessary, spotted by Tim van der
Molen.
@
text
@d1 1
a1 1
/* $OpenBSD: cmd-string.c,v 1.13 2010/01/31 18:47:03 nicm Exp $ */
d250 4
a253 3
	int	ch, fch;
	char   *buf, *t;
	size_t	len;
d305 3
a307 2
	if ((t = getenv(buf)) == NULL) {
		xfree(buf);
d309 1
a309 3
	}
	xfree(buf);
	return (xstrdup(t));
d320 3
a322 2
	struct passwd	*pw;
	char		*home, *path, *username;
d326 5
a330 4
		if ((home = getenv("HOME")) == NULL || *home == '\0') {
			if ((pw = getpwuid(getuid())) != NULL)
				home = pw->pw_dir;
		}
@


1.13
log
@Remove unnecessary comparison, pointed out by Tiago Cunha.
@
text
@d1 1
a1 1
/* $OpenBSD: cmd-string.c,v 1.12 2009/12/03 22:50:10 nicm Exp $ */
d64 1
a64 1
	int		ch, i, argc, rval, have_arg;
a74 2
	have_arg = 0;

a90 2

			have_arg = 1;
a98 2

			have_arg = 1;
a106 2

			have_arg = 1;
d116 1
a116 1
			if (have_arg) {
a124 2

				have_arg = 0;
d149 1
a149 1
			if (have_arg == 0) {
a164 2

			have_arg = 1;
@


1.12
log
@Massive spaces->tabs and trailing whitespace cleanup, hopefully for the last
time now I've configured emacs to make them displayed in really annoying
colours...
@
text
@d1 1
a1 1
/* $OpenBSD: cmd-string.c,v 1.11 2009/11/26 21:14:30 nicm Exp $ */
d347 1
a347 2
		if (username != NULL)
			xfree(username);
@


1.11
log
@Get a u_char from the string, otherwise it isn't possible to enter \0377 as it
is mistaken for EOF (doh).

Also drop an unused argument.
@
text
@d1 1
a1 1
/* $OpenBSD: cmd-string.c,v 1.10 2009/11/21 17:52:18 nicm Exp $ */
d124 1
a124 1
 			if (have_arg) {
@


1.10
log
@Use home from struct passwd if HOME is empty as well as if it is NULL, and fix
a style nit. Both from Tiago Cunha.
@
text
@d1 1
a1 1
/* $OpenBSD: cmd-string.c,v 1.9 2009/11/16 11:15:44 nicm Exp $ */
d35 1
a35 1
void	cmd_string_ungetc(const char *, size_t *);
d43 3
a45 1
	if (s[*p] == '\0')
d47 1
a47 1
	return (s[(*p)++]);
d51 1
a51 1
cmd_string_ungetc(unused const char *s, size_t *p)
d311 1
a311 1
		cmd_string_ungetc(s, p); /* ch */
d342 1
a342 1
		cmd_string_ungetc(s, p);
@


1.9
log
@I made a complete horlicks of the last change, fix it so it doesn't either lead
to a double free or free the item after the end of the array.
@
text
@d1 1
a1 1
/* $OpenBSD: cmd-string.c,v 1.8 2009/11/11 18:56:07 nicm Exp $ */
d335 1
a335 1
		if ((home = getenv("HOME")) == NULL) {
@


1.8
log
@Rewrite a confusing loop when freeing the arg array on exit and move the check
for argv being NULL, prompted by parfait via deraadt.

Also fix some definite brokenness when assigning multiple environment variables
in arguments (such as "X=1 Y=2").
@
text
@d1 1
a1 1
/* $OpenBSD: cmd-string.c,v 1.7 2009/10/26 21:42:04 deraadt Exp $ */
a153 4
			do
				xfree(argv[argc - 1]);
			while (--argc > 0);

d188 1
a188 1
			xfree(argv[argc]);
@


1.7
log
@tabs are better; ok nicm
@
text
@d1 1
a1 1
/* $OpenBSD: cmd-string.c,v 1.6 2009/08/08 21:52:43 nicm Exp $ */
a136 2
			if (argc == 0)
				goto out;
d138 3
a140 3
			for (i = 0; i < argc; i++) {
				equals = strchr(argv[i], '=');
				whitespace = argv[i] + strcspn(argv[i], " \t");
d143 1
a143 2
				environ_put(&global_environ, argv[i]);
				memmove(&argv[i], &argv[i + 1], argc - i - 1);
d145 1
d190 3
a192 3
	while (--argc >= 0)
		xfree(argv[argc]);
	if (argv != NULL)
d194 1
@


1.6
log
@Infrastructure and commands to manage the environment for processes started
within tmux.

There is a global environment, copied from the external environment when the
server is started and each sesssion has an (initially empty) session
environment which overrides it.

New commands set-environment and show-environment manipulate or display the
environments.

A new session option, update-environment, is a space-separated list of
variables which are updated from the external environment into the session
environment every time a new session is created - the default is DISPLAY.
@
text
@d1 1
a1 1
/* $OpenBSD: cmd-string.c,v 1.5 2009/08/03 14:10:54 nicm Exp $ */
d207 1
a207 1
        buf = NULL;
d210 2
a211 2
        while ((ch = cmd_string_getc(s, p)) != endch) {
                switch (ch) {
d214 1
a214 1
                case '\\':
d217 1
a217 1
                        switch (ch = cmd_string_getc(s, p)) {
d223 11
a233 11
                        case 'r':
                                ch = '\r';
                                break;
                        case 'n':
                                ch = '\n';
                                break;
                        case 't':
                                ch = '\t';
                                break;
                        }
                        break;
d244 1
a244 1
                }
d249 2
a250 2
                buf[len++] = ch;
        }
d275 1
a275 1
        buf = NULL;
@


1.5
log
@Add a terminal-overrides session option allowing individual terminfo(5) entries
to be overridden. The 88col/256col checks are now moved into the default
setting and out of the code.

Also remove a couple of old workarounds for xterm and rxvt which are no longer
necessary (tmux can emulate them if missing).
@
text
@d1 1
a1 1
/* $OpenBSD: cmd-string.c,v 1.4 2009/07/13 18:49:36 nicm Exp $ */
d62 3
a64 2
	int		ch, argc, rval, have_arg;
	char	      **argv, *buf, *t, *u;
a66 11
	if ((t = strchr(s, ' ')) == NULL && (t = strchr(s, '\t')) == NULL)
		t = strchr(s, '\0');
	if ((u = strchr(s, '=')) != NULL && u < t) {
		if (putenv(xstrdup(s)) != 0) {
			xasprintf(cause, "assignment failed: %s", s);
			return (-1);
		}
		*cmdlist = NULL;
		return (0);
	}

d137 12
@


1.4
log
@Expand leading tildes in arguments, from Tiage Cunha.
@
text
@d1 1
a1 1
/* $OpenBSD: cmd-string.c,v 1.3 2009/07/08 16:04:56 nicm Exp $ */
d218 3
@


1.3
log
@Fix two memory leaks when assigning shell variables in configuration
file/command prompt. From Tiago Cunha.
@
text
@d1 1
a1 1
/* $OpenBSD: cmd-string.c,v 1.2 2009/06/05 07:18:37 nicm Exp $ */
d22 1
d26 1
d38 1
d160 11
d325 28
@


1.2
log
@strdup the input to putenv to avoid in one case passing a string that is later
freed and in the other const strings.

looks sane to millert, ok ray
@
text
@d1 1
a1 1
/* $OpenBSD: cmd-string.c,v 1.1 2009/06/01 22:58:49 nicm Exp $ */
d117 1
d223 1
@


1.1
log
@Import tmux, a terminal multiplexor allowing (among other things) a single
terminal to be switched between several different windows and programs
displayed on one terminal be detached from one terminal and moved to another.

ok deraadt pirofti
@
text
@d1 1
a1 1
/* $OpenBSD$ */
d66 1
a66 1
		if (putenv((char *) s) != 0) {
@

