head	1.75;
access;
symbols
	OPENBSD_6_1:1.68.0.4
	OPENBSD_6_1_BASE:1.68
	OPENBSD_6_0:1.54.0.2
	OPENBSD_6_0_BASE:1.54
	OPENBSD_5_9:1.52.0.2
	OPENBSD_5_9_BASE:1.52
	OPENBSD_5_8:1.43.0.4
	OPENBSD_5_8_BASE:1.43
	OPENBSD_5_7:1.41.0.2
	OPENBSD_5_7_BASE:1.41
	OPENBSD_5_6:1.37.0.4
	OPENBSD_5_6_BASE:1.37
	OPENBSD_5_5:1.35.0.4
	OPENBSD_5_5_BASE:1.35
	OPENBSD_5_4:1.29.0.2
	OPENBSD_5_4_BASE:1.29
	OPENBSD_5_3:1.22.0.2
	OPENBSD_5_3_BASE:1.22
	OPENBSD_5_2:1.20.0.2
	OPENBSD_5_2_BASE:1.20
	OPENBSD_5_1_BASE:1.18
	OPENBSD_5_1:1.18.0.8
	OPENBSD_5_0:1.18.0.6
	OPENBSD_5_0_BASE:1.18
	OPENBSD_4_9:1.18.0.4
	OPENBSD_4_9_BASE:1.18
	OPENBSD_4_8:1.18.0.2
	OPENBSD_4_8_BASE:1.18
	OPENBSD_4_7:1.17.0.2
	OPENBSD_4_7_BASE:1.17
	OPENBSD_4_6:1.5.0.4
	OPENBSD_4_6_BASE:1.5;
locks; strict;
comment	@ * @;


1.75
date	2017.08.30.18.13.47;	author nicm;	state Exp;
branches;
next	1.74;
commitid	BDHEBGnjuynLzhAk;

1.74
date	2017.05.16.12.57.26;	author nicm;	state Exp;
branches;
next	1.73;
commitid	KRbnr5FvEnUdlnqA;

1.73
date	2017.05.13.07.30.50;	author nicm;	state Exp;
branches;
next	1.72;
commitid	AuBB9447J4aDMWUd;

1.72
date	2017.05.12.15.18.13;	author nicm;	state Exp;
branches;
next	1.71;
commitid	wsnye5eqGf3HQr6L;

1.71
date	2017.05.12.13.00.56;	author nicm;	state Exp;
branches;
next	1.70;
commitid	1bIKLBYAOfKIM4e4;

1.70
date	2017.04.25.18.20.51;	author nicm;	state Exp;
branches;
next	1.69;
commitid	lD8ORtCous51aRLe;

1.69
date	2017.04.19.12.44.29;	author nicm;	state Exp;
branches;
next	1.68;
commitid	Ec8oUUgNbkWjai5b;

1.68
date	2017.03.22.07.16.54;	author nicm;	state Exp;
branches;
next	1.67;
commitid	YlKgZy2nlCejSvNQ;

1.67
date	2017.03.07.13.47.56;	author nicm;	state Exp;
branches;
next	1.66;
commitid	nwNGOkzkTmG4HRfM;

1.66
date	2017.02.22.09.01.32;	author nicm;	state Exp;
branches;
next	1.65;
commitid	SKmqCZ6GhGllt9ad;

1.65
date	2017.02.13.16.05.30;	author nicm;	state Exp;
branches;
next	1.64;
commitid	FHNuTDWN3rxyRj0w;

1.64
date	2017.02.08.16.45.18;	author nicm;	state Exp;
branches;
next	1.63;
commitid	ZNCPaF6tGzHeJGxd;

1.63
date	2017.02.08.15.41.41;	author nicm;	state Exp;
branches;
next	1.62;
commitid	0JCt4hH6x9rwToOE;

1.62
date	2017.02.08.08.26.35;	author nicm;	state Exp;
branches;
next	1.61;
commitid	la84MviIr320ysIz;

1.61
date	2017.02.03.20.53.03;	author nicm;	state Exp;
branches;
next	1.60;
commitid	pCObtuXMPTC7Kg6p;

1.60
date	2016.10.18.19.52.49;	author nicm;	state Exp;
branches;
next	1.59;
commitid	jqwYw2VTVzbcYkhB;

1.59
date	2016.10.18.14.56.17;	author nicm;	state Exp;
branches;
next	1.58;
commitid	TW6waE7nsdAaVCzx;

1.58
date	2016.10.13.20.27.27;	author nicm;	state Exp;
branches;
next	1.57;
commitid	txCyQ5BkKJtZRzfT;

1.57
date	2016.10.11.13.21.59;	author nicm;	state Exp;
branches;
next	1.56;
commitid	80rgEIPcNpyBnf95;

1.56
date	2016.10.10.21.29.23;	author nicm;	state Exp;
branches;
next	1.55;
commitid	z4Hr4PZF7Ev93uEJ;

1.55
date	2016.09.02.20.57.20;	author nicm;	state Exp;
branches;
next	1.54;
commitid	KNa3UznuiHkLoVpf;

1.54
date	2016.07.15.00.49.08;	author nicm;	state Exp;
branches;
next	1.53;
commitid	4uHSvNNDvwUmOB9Y;

1.53
date	2016.07.15.00.42.56;	author nicm;	state Exp;
branches;
next	1.52;
commitid	EramuEV0ciOaJqkF;

1.52
date	2016.01.31.09.57.09;	author nicm;	state Exp;
branches;
next	1.51;
commitid	8GhCx7u96kL7iEGB;

1.51
date	2016.01.29.11.13.56;	author nicm;	state Exp;
branches;
next	1.50;
commitid	Rew2ppunRTmAT23L;

1.50
date	2016.01.19.15.59.12;	author nicm;	state Exp;
branches;
next	1.49;
commitid	P3qmSOx6KrDBsb0c;

1.49
date	2015.11.22.19.42.57;	author nicm;	state Exp;
branches;
next	1.48;
commitid	rkgaH7TAUWaAvBva;

1.48
date	2015.11.13.08.09.28;	author nicm;	state Exp;
branches;
next	1.47;
commitid	3vFd8TIqn7NVGuk0;

1.47
date	2015.11.12.14.50.57;	author nicm;	state Exp;
branches;
next	1.46;
commitid	BqSdLOMRiVFFxPiz;

1.46
date	2015.09.25.15.53.07;	author nicm;	state Exp;
branches;
next	1.45;
commitid	lqg6HJokMJTX5DQE;

1.45
date	2015.09.02.17.12.07;	author nicm;	state Exp;
branches;
next	1.44;
commitid	QqWcSD7fSvscqSPZ;

1.44
date	2015.08.24.22.49.13;	author nicm;	state Exp;
branches;
next	1.43;
commitid	nWqikzaMNzQRgNUg;

1.43
date	2015.05.08.15.56.49;	author nicm;	state Exp;
branches;
next	1.42;
commitid	0BlK2lEeHj5kSq2J;

1.42
date	2015.04.23.07.45.50;	author deraadt;	state Exp;
branches;
next	1.41;
commitid	IStJENnDpesVr20a;

1.41
date	2014.10.08.17.35.58;	author nicm;	state Exp;
branches;
next	1.40;
commitid	mK8z9uVwDZMfiNoM;

1.40
date	2014.10.08.17.14.04;	author nicm;	state Exp;
branches;
next	1.39;
commitid	ulvK817LKj1J8ttJ;

1.39
date	2014.09.17.15.31.38;	author nicm;	state Exp;
branches;
next	1.38;
commitid	4w1oyJvWaocWkASG;

1.38
date	2014.09.01.21.50.18;	author nicm;	state Exp;
branches;
next	1.37;
commitid	yvK8NJvd2XzXhKku;

1.37
date	2014.04.16.23.05.38;	author nicm;	state Exp;
branches;
next	1.36;

1.36
date	2014.03.31.21.42.27;	author nicm;	state Exp;
branches;
next	1.35;

1.35
date	2014.02.14.13.59.01;	author nicm;	state Exp;
branches;
next	1.34;

1.34
date	2014.01.28.23.07.09;	author nicm;	state Exp;
branches;
next	1.33;

1.33
date	2014.01.15.11.44.18;	author nicm;	state Exp;
branches;
next	1.32;

1.32
date	2014.01.09.13.58.06;	author nicm;	state Exp;
branches;
next	1.31;

1.31
date	2013.10.10.12.01.14;	author nicm;	state Exp;
branches;
next	1.30;

1.30
date	2013.10.10.11.49.29;	author nicm;	state Exp;
branches;
next	1.29;

1.29
date	2013.03.25.10.07.40;	author nicm;	state Exp;
branches;
next	1.28;

1.28
date	2013.03.25.10.05.35;	author nicm;	state Exp;
branches;
next	1.27;

1.27
date	2013.03.25.10.01.43;	author nicm;	state Exp;
branches;
next	1.26;

1.26
date	2013.03.22.15.56.11;	author nicm;	state Exp;
branches;
next	1.25;

1.25
date	2013.03.22.15.53.58;	author nicm;	state Exp;
branches;
next	1.24;

1.24
date	2013.03.22.15.51.54;	author nicm;	state Exp;
branches;
next	1.23;

1.23
date	2013.03.21.16.12.10;	author nicm;	state Exp;
branches;
next	1.22;

1.22
date	2013.02.05.11.08.59;	author nicm;	state Exp;
branches;
next	1.21;

1.21
date	2013.01.18.02.16.21;	author nicm;	state Exp;
branches;
next	1.20;

1.20
date	2012.07.10.11.53.01;	author nicm;	state Exp;
branches;
next	1.19;

1.19
date	2012.05.23.19.19.40;	author nicm;	state Exp;
branches;
next	1.18;

1.18
date	2010.04.06.21.35.44;	author nicm;	state Exp;
branches;
next	1.17;

1.17
date	2009.12.03.22.50.10;	author nicm;	state Exp;
branches;
next	1.16;

1.16
date	2009.11.18.17.02.17;	author nicm;	state Exp;
branches;
next	1.15;

1.15
date	2009.10.13.15.38.37;	author nicm;	state Exp;
branches;
next	1.14;

1.14
date	2009.09.15.15.14.09;	author nicm;	state Exp;
branches;
next	1.13;

1.13
date	2009.08.21.07.29.37;	author nicm;	state Exp;
branches;
next	1.12;

1.12
date	2009.08.20.19.14.42;	author nicm;	state Exp;
branches;
next	1.11;

1.11
date	2009.08.10.17.59.59;	author nicm;	state Exp;
branches;
next	1.10;

1.10
date	2009.08.08.13.29.27;	author nicm;	state Exp;
branches;
next	1.9;

1.9
date	2009.07.21.18.40.30;	author nicm;	state Exp;
branches;
next	1.8;

1.8
date	2009.07.16.07.34.37;	author nicm;	state Exp;
branches;
next	1.7;

1.7
date	2009.07.13.10.43.52;	author nicm;	state Exp;
branches;
next	1.6;

1.6
date	2009.07.11.20.11.18;	author nicm;	state Exp;
branches;
next	1.5;

1.5
date	2009.06.25.06.15.04;	author nicm;	state Exp;
branches;
next	1.4;

1.4
date	2009.06.24.22.49.56;	author nicm;	state Exp;
branches;
next	1.3;

1.3
date	2009.06.24.22.04.18;	author nicm;	state Exp;
branches;
next	1.2;

1.2
date	2009.06.05.03.13.16;	author ray;	state Exp;
branches;
next	1.1;

1.1
date	2009.06.01.22.58.49;	author nicm;	state Exp;
branches;
next	;


desc
@@


1.75
log
@Instead of overloading the line clear function to mean free if
background is default (8), introduce an explicit free function and use
it where a free alone is needed. Likewise, use memmove directly rather
than grid_move_lines where it makes sense. Based on a memory leak fix by
Dan Aloni in GitHub issue 1051.
@
text
@/* $OpenBSD: grid.c,v 1.74 2017/05/16 12:57:26 nicm Exp $ */

/*
 * Copyright (c) 2008 Nicholas Marriott <nicholas.marriott@@gmail.com>
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF MIND, USE, DATA OR PROFITS, WHETHER
 * IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING
 * OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */

#include <sys/types.h>

#include <stdlib.h>
#include <string.h>

#include "tmux.h"

/*
 * Grid data. This is the basic data structure that represents what is shown on
 * screen.
 *
 * A grid is a grid of cells (struct grid_cell). Lines are not allocated until
 * cells in that line are written to. The grid is split into history and
 * viewable data with the history starting at row (line) 0 and extending to
 * (hsize - 1); from hsize to hsize + (sy - 1) is the viewable data. All
 * functions in this file work on absolute coordinates, grid-view.c has
 * functions which work on the screen data.
 */

/* Default grid cell data. */
const struct grid_cell grid_default_cell = {
	0, 0, 8, 8, { { ' ' }, 0, 1, 1 }
};
static const struct grid_cell_entry grid_default_entry = {
	0, { .data = { 0, 8, 8, ' ' } }
};

static void	grid_expand_line(struct grid *, u_int, u_int, u_int);
static void	grid_empty_line(struct grid *, u_int, u_int);

static void	grid_reflow_copy(struct grid_line *, u_int, struct grid_line *,
		    u_int, u_int);
static void	grid_reflow_join(struct grid *, u_int *, struct grid_line *,
		    u_int);
static void	grid_reflow_split(struct grid *, u_int *, struct grid_line *,
		    u_int, u_int);
static void	grid_reflow_move(struct grid *, u_int *, struct grid_line *);

static size_t	grid_string_cells_fg(const struct grid_cell *, int *);
static size_t	grid_string_cells_bg(const struct grid_cell *, int *);
static void	grid_string_cells_code(const struct grid_cell *,
		    const struct grid_cell *, char *, size_t, int);

/* Store cell in entry. */
static void
grid_store_cell(struct grid_cell_entry *gce, const struct grid_cell *gc,
    u_char c)
{
	gce->flags = gc->flags;

	gce->data.fg = gc->fg & 0xff;
	if (gc->fg & COLOUR_FLAG_256)
		gce->flags |= GRID_FLAG_FG256;

	gce->data.bg = gc->bg & 0xff;
	if (gc->bg & COLOUR_FLAG_256)
		gce->flags |= GRID_FLAG_BG256;

	gce->data.attr = gc->attr;
	gce->data.data = c;
}

/* Check if a cell should be extended. */
static int
grid_need_extended_cell(const struct grid_cell_entry *gce,
    const struct grid_cell *gc)
{
	if (gce->flags & GRID_FLAG_EXTENDED)
		return (1);
	if (gc->attr > 0xff)
		return (1);
	if (gc->data.size != 1 || gc->data.width != 1)
		return (1);
	if ((gc->fg & COLOUR_FLAG_RGB) || (gc->bg & COLOUR_FLAG_RGB))
		return (1);
	return (0);
}

/* Set cell as extended. */
static struct grid_cell *
grid_extended_cell(struct grid_line *gl, struct grid_cell_entry *gce,
    const struct grid_cell *gc)
{
	struct grid_cell	*gcp;

	gl->flags |= GRID_LINE_EXTENDED;

	if (~gce->flags & GRID_FLAG_EXTENDED) {
		gl->extddata = xreallocarray(gl->extddata, gl->extdsize + 1,
		    sizeof *gl->extddata);
		gce->offset = gl->extdsize++;
		gce->flags = gc->flags | GRID_FLAG_EXTENDED;
	}
	if (gce->offset >= gl->extdsize)
		fatalx("offset too big");

	gcp = &gl->extddata[gce->offset];
	memcpy(gcp, gc, sizeof *gcp);
	return (gcp);
}

/* Copy default into a cell. */
static void
grid_clear_cell(struct grid *gd, u_int px, u_int py, u_int bg)
{
	struct grid_line	*gl = &gd->linedata[py];
	struct grid_cell_entry	*gce = &gl->celldata[px];
	struct grid_cell	*gc;

	memcpy(gce, &grid_default_entry, sizeof *gce);
	if (bg & COLOUR_FLAG_RGB) {
		gc = grid_extended_cell(gl, gce, &grid_default_cell);
		gc->bg = bg;
	} else {
		if (bg & COLOUR_FLAG_256)
			gce->flags |= GRID_FLAG_BG256;
		gce->data.bg = bg;
	}
}

/* Check grid y position. */
static int
grid_check_y(struct grid *gd, u_int py)
{
	if ((py) >= (gd)->hsize + (gd)->sy) {
		log_debug("y out of range: %u", py);
		return (-1);
	}
	return (0);
}

/* Compare grid cells. Return 1 if equal, 0 if not. */
int
grid_cells_equal(const struct grid_cell *gca, const struct grid_cell *gcb)
{
	if (gca->fg != gcb->fg || gca->bg != gcb->bg)
		return (0);
	if (gca->attr != gcb->attr || gca->flags != gcb->flags)
		return (0);
	if (gca->data.width != gcb->data.width)
		return (0);
	if (gca->data.size != gcb->data.size)
		return (0);
	return (memcmp(gca->data.data, gcb->data.data, gca->data.size) == 0);
}

/* Free one line. */
static void
grid_free_line(struct grid *gd, u_int py)
{
	free(gd->linedata[py].celldata);
	gd->linedata[py].celldata = NULL;
	free(gd->linedata[py].extddata);
	gd->linedata[py].extddata = NULL;
}

/* Free several lines. */
static void
grid_free_lines(struct grid *gd, u_int py, u_int ny)
{
	u_int	yy;

	for (yy = py; yy < py + ny; yy++)
		grid_free_line(gd, yy);
}

/* Create a new grid. */
struct grid *
grid_create(u_int sx, u_int sy, u_int hlimit)
{
	struct grid	*gd;

	gd = xmalloc(sizeof *gd);
	gd->sx = sx;
	gd->sy = sy;

	gd->flags = GRID_HISTORY;

	gd->hscrolled = 0;
	gd->hsize = 0;
	gd->hlimit = hlimit;

	gd->linedata = xcalloc(gd->sy, sizeof *gd->linedata);

	return (gd);
}

/* Destroy grid. */
void
grid_destroy(struct grid *gd)
{
	grid_free_lines(gd, 0, gd->hsize + gd->sy);

	free(gd->linedata);

	free(gd);
}

/* Compare grids. */
int
grid_compare(struct grid *ga, struct grid *gb)
{
	struct grid_line	*gla, *glb;
	struct grid_cell	 gca, gcb;
	u_int			 xx, yy;

	if (ga->sx != gb->sx || ga->sy != gb->sy)
		return (1);

	for (yy = 0; yy < ga->sy; yy++) {
		gla = &ga->linedata[yy];
		glb = &gb->linedata[yy];
		if (gla->cellsize != glb->cellsize)
			return (1);
		for (xx = 0; xx < gla->cellsize; xx++) {
			grid_get_cell(ga, xx, yy, &gca);
			grid_get_cell(gb, xx, yy, &gcb);
			if (!grid_cells_equal(&gca, &gcb))
				return (1);
		}
	}

	return (0);
}

/*
 * Collect lines from the history if at the limit. Free the top (oldest) 10%
 * and shift up.
 */
void
grid_collect_history(struct grid *gd)
{
	u_int	ny;

	if (gd->hsize < gd->hlimit)
		return;

	ny = gd->hlimit / 10;
	if (ny < 1)
		ny = 1;

	/*
	 * Free the lines from 0 to ny then move the remaining lines over
	 * them.
	 */
	grid_free_lines(gd, 0, ny);
	memmove(&gd->linedata[0], &gd->linedata[ny],
	    (gd->hsize + gd->sy - ny) * (sizeof *gd->linedata));

	gd->hsize -= ny;
	if (gd->hscrolled > gd->hsize)
		gd->hscrolled = gd->hsize;
}

/*
 * Scroll the entire visible screen, moving one line into the history. Just
 * allocate a new line at the bottom and move the history size indicator.
 */
void
grid_scroll_history(struct grid *gd, u_int bg)
{
	u_int	yy;

	yy = gd->hsize + gd->sy;
	gd->linedata = xreallocarray(gd->linedata, yy + 1,
	    sizeof *gd->linedata);
	grid_empty_line(gd, yy, bg);

	gd->hscrolled++;
	gd->hsize++;
}

/* Clear the history. */
void
grid_clear_history(struct grid *gd)
{
	grid_free_lines(gd, 0, gd->hsize);
	memmove(&gd->linedata[0], &gd->linedata[gd->hsize],
	    gd->sy * (sizeof *gd->linedata));

	gd->hscrolled = 0;
	gd->hsize = 0;

	gd->linedata = xreallocarray(gd->linedata, gd->sy,
	    sizeof *gd->linedata);
}

/* Scroll a region up, moving the top line into the history. */
void
grid_scroll_history_region(struct grid *gd, u_int upper, u_int lower, u_int bg)
{
	struct grid_line	*gl_history, *gl_upper;
	u_int			 yy;

	/* Create a space for a new line. */
	yy = gd->hsize + gd->sy;
	gd->linedata = xreallocarray(gd->linedata, yy + 1,
	    sizeof *gd->linedata);

	/* Move the entire screen down to free a space for this line. */
	gl_history = &gd->linedata[gd->hsize];
	memmove(gl_history + 1, gl_history, gd->sy * sizeof *gl_history);

	/* Adjust the region and find its start and end. */
	upper++;
	gl_upper = &gd->linedata[upper];
	lower++;

	/* Move the line into the history. */
	memcpy(gl_history, gl_upper, sizeof *gl_history);

	/* Then move the region up and clear the bottom line. */
	memmove(gl_upper, gl_upper + 1, (lower - upper) * sizeof *gl_upper);
	grid_empty_line(gd, lower, bg);

	/* Move the history offset down over the line. */
	gd->hscrolled++;
	gd->hsize++;
}

/* Expand line to fit to cell. */
static void
grid_expand_line(struct grid *gd, u_int py, u_int sx, u_int bg)
{
	struct grid_line	*gl;
	u_int			 xx;

	gl = &gd->linedata[py];
	if (sx <= gl->cellsize)
		return;

	if (sx < gd->sx / 4)
		sx = gd->sx / 4;
	else if (sx < gd->sx / 2)
		sx = gd->sx / 2;
	else
		sx = gd->sx;

	gl->celldata = xreallocarray(gl->celldata, sx, sizeof *gl->celldata);
	for (xx = gl->cellsize; xx < sx; xx++)
		grid_clear_cell(gd, xx, py, bg);
	gl->cellsize = sx;
}

/* Empty a line and set background colour if needed. */
static void
grid_empty_line(struct grid *gd, u_int py, u_int bg)
{
	memset(&gd->linedata[py], 0, sizeof gd->linedata[py]);
	if (bg != 8)
		grid_expand_line(gd, py, gd->sx, bg);
}

/* Peek at grid line. */
const struct grid_line *
grid_peek_line(struct grid *gd, u_int py)
{
	if (grid_check_y(gd, py) != 0)
		return (NULL);
	return (&gd->linedata[py]);
}

/* Get cell for reading. */
void
grid_get_cell(struct grid *gd, u_int px, u_int py, struct grid_cell *gc)
{
	struct grid_line	*gl;
	struct grid_cell_entry	*gce;

	if (grid_check_y(gd, py) != 0 || px >= gd->linedata[py].cellsize) {
		memcpy(gc, &grid_default_cell, sizeof *gc);
		return;
	}

	gl = &gd->linedata[py];
	gce = &gl->celldata[px];

	if (gce->flags & GRID_FLAG_EXTENDED) {
		if (gce->offset >= gl->extdsize)
			memcpy(gc, &grid_default_cell, sizeof *gc);
		else
			memcpy(gc, &gl->extddata[gce->offset], sizeof *gc);
		return;
	}

	gc->flags = gce->flags & ~(GRID_FLAG_FG256|GRID_FLAG_BG256);
	gc->attr = gce->data.attr;
	gc->fg = gce->data.fg;
	if (gce->flags & GRID_FLAG_FG256)
		gc->fg |= COLOUR_FLAG_256;
	gc->bg = gce->data.bg;
	if (gce->flags & GRID_FLAG_BG256)
		gc->bg |= COLOUR_FLAG_256;
	utf8_set(&gc->data, gce->data.data);
}

/* Set cell at relative position. */
void
grid_set_cell(struct grid *gd, u_int px, u_int py, const struct grid_cell *gc)
{
	struct grid_line	*gl;
	struct grid_cell_entry	*gce;

	if (grid_check_y(gd, py) != 0)
		return;

	grid_expand_line(gd, py, px + 1, 8);

	gl = &gd->linedata[py];
	if (px + 1 > gl->cellused)
		gl->cellused = px + 1;

	gce = &gl->celldata[px];
	if (grid_need_extended_cell(gce, gc))
		grid_extended_cell(gl, gce, gc);
	else
		grid_store_cell(gce, gc, gc->data.data[0]);
}

/* Set cells at relative position. */
void
grid_set_cells(struct grid *gd, u_int px, u_int py, const struct grid_cell *gc,
    const char *s, size_t slen)
{
	struct grid_line	*gl;
	struct grid_cell_entry	*gce;
	struct grid_cell	*gcp;
	u_int			 i;

	if (grid_check_y(gd, py) != 0)
		return;

	grid_expand_line(gd, py, px + slen, 8);

	gl = &gd->linedata[py];
	if (px + slen > gl->cellused)
		gl->cellused = px + slen;

	for (i = 0; i < slen; i++) {
		gce = &gl->celldata[px + i];
		if (grid_need_extended_cell(gce, gc)) {
			gcp = grid_extended_cell(gl, gce, gc);
			utf8_set(&gcp->data, s[i]);
		} else
			grid_store_cell(gce, gc, s[i]);
	}
}

/* Clear area. */
void
grid_clear(struct grid *gd, u_int px, u_int py, u_int nx, u_int ny, u_int bg)
{
	u_int	xx, yy;

	if (nx == 0 || ny == 0)
		return;

	if (px == 0 && nx == gd->sx) {
		grid_clear_lines(gd, py, ny, bg);
		return;
	}

	if (grid_check_y(gd, py) != 0)
		return;
	if (grid_check_y(gd, py + ny - 1) != 0)
		return;

	for (yy = py; yy < py + ny; yy++) {
		if (px + nx >= gd->sx && px < gd->linedata[yy].cellused)
			gd->linedata[yy].cellused = px;
		if (px > gd->linedata[yy].cellsize && bg == 8)
			continue;
		if (px + nx >= gd->linedata[yy].cellsize && bg == 8) {
			gd->linedata[yy].cellsize = px;
			continue;
		}
		grid_expand_line(gd, yy, px + nx, 8); /* default bg first */
		for (xx = px; xx < px + nx; xx++)
			grid_clear_cell(gd, xx, yy, bg);
	}
}

/* Clear lines. This just frees and truncates the lines. */
void
grid_clear_lines(struct grid *gd, u_int py, u_int ny, u_int bg)
{
	u_int	yy;

	if (ny == 0)
		return;

	if (grid_check_y(gd, py) != 0)
		return;
	if (grid_check_y(gd, py + ny - 1) != 0)
		return;

	for (yy = py; yy < py + ny; yy++) {
		grid_free_line(gd, yy);
		grid_empty_line(gd, yy, bg);
	}
}

/* Move a group of lines. */
void
grid_move_lines(struct grid *gd, u_int dy, u_int py, u_int ny, u_int bg)
{
	u_int	yy;

	if (ny == 0 || py == dy)
		return;

	if (grid_check_y(gd, py) != 0)
		return;
	if (grid_check_y(gd, py + ny - 1) != 0)
		return;
	if (grid_check_y(gd, dy) != 0)
		return;
	if (grid_check_y(gd, dy + ny - 1) != 0)
		return;

	/* Free any lines which are being replaced. */
	for (yy = dy; yy < dy + ny; yy++) {
		if (yy >= py && yy < py + ny)
			continue;
		grid_free_line(gd, yy);
	}

	memmove(&gd->linedata[dy], &gd->linedata[py],
	    ny * (sizeof *gd->linedata));

	/*
	 * Wipe any lines that have been moved (without freeing them - they are
	 * still present).
	 */
	for (yy = py; yy < py + ny; yy++) {
		if (yy < dy || yy >= dy + ny)
			grid_empty_line(gd, yy, bg);
	}
}

/* Move a group of cells. */
void
grid_move_cells(struct grid *gd, u_int dx, u_int px, u_int py, u_int nx,
    u_int bg)
{
	struct grid_line	*gl;
	u_int			 xx;

	if (nx == 0 || px == dx)
		return;

	if (grid_check_y(gd, py) != 0)
		return;
	gl = &gd->linedata[py];

	grid_expand_line(gd, py, px + nx, 8);
	grid_expand_line(gd, py, dx + nx, 8);
	memmove(&gl->celldata[dx], &gl->celldata[px],
	    nx * sizeof *gl->celldata);
	if (dx + nx > gl->cellused)
		gl->cellused = dx + nx;

	/* Wipe any cells that have been moved. */
	for (xx = px; xx < px + nx; xx++) {
		if (xx >= dx && xx < dx + nx)
			continue;
		grid_clear_cell(gd, xx, py, bg);
	}
}

/* Get ANSI foreground sequence. */
static size_t
grid_string_cells_fg(const struct grid_cell *gc, int *values)
{
	size_t	n;
	u_char	r, g, b;

	n = 0;
	if (gc->fg & COLOUR_FLAG_256) {
		values[n++] = 38;
		values[n++] = 5;
		values[n++] = gc->fg & 0xff;
	} else if (gc->fg & COLOUR_FLAG_RGB) {
		values[n++] = 38;
		values[n++] = 2;
		colour_split_rgb(gc->fg, &r, &g, &b);
		values[n++] = r;
		values[n++] = g;
		values[n++] = b;
	} else {
		switch (gc->fg) {
		case 0:
		case 1:
		case 2:
		case 3:
		case 4:
		case 5:
		case 6:
		case 7:
			values[n++] = gc->fg + 30;
			break;
		case 8:
			values[n++] = 39;
			break;
		case 90:
		case 91:
		case 92:
		case 93:
		case 94:
		case 95:
		case 96:
		case 97:
			values[n++] = gc->fg;
			break;
		}
	}
	return (n);
}

/* Get ANSI background sequence. */
static size_t
grid_string_cells_bg(const struct grid_cell *gc, int *values)
{
	size_t	n;
	u_char	r, g, b;

	n = 0;
	if (gc->bg & COLOUR_FLAG_256) {
		values[n++] = 48;
		values[n++] = 5;
		values[n++] = gc->bg & 0xff;
	} else if (gc->bg & COLOUR_FLAG_RGB) {
		values[n++] = 48;
		values[n++] = 2;
		colour_split_rgb(gc->bg, &r, &g, &b);
		values[n++] = r;
		values[n++] = g;
		values[n++] = b;
	} else {
		switch (gc->bg) {
		case 0:
		case 1:
		case 2:
		case 3:
		case 4:
		case 5:
		case 6:
		case 7:
			values[n++] = gc->bg + 40;
			break;
		case 8:
			values[n++] = 49;
			break;
		case 100:
		case 101:
		case 102:
		case 103:
		case 104:
		case 105:
		case 106:
		case 107:
			values[n++] = gc->bg - 10;
			break;
		}
	}
	return (n);
}

/*
 * Returns ANSI code to set particular attributes (colour, bold and so on)
 * given a current state.
 */
static void
grid_string_cells_code(const struct grid_cell *lastgc,
    const struct grid_cell *gc, char *buf, size_t len, int escape_c0)
{
	int	oldc[64], newc[64], s[128];
	size_t	noldc, nnewc, n, i;
	u_int	attr = gc->attr, lastattr = lastgc->attr;
	char	tmp[64];

	struct {
		u_int	mask;
		u_int	code;
	} attrs[] = {
		{ GRID_ATTR_BRIGHT, 1 },
		{ GRID_ATTR_DIM, 2 },
		{ GRID_ATTR_ITALICS, 3 },
		{ GRID_ATTR_UNDERSCORE, 4 },
		{ GRID_ATTR_BLINK, 5 },
		{ GRID_ATTR_REVERSE, 7 },
		{ GRID_ATTR_HIDDEN, 8 },
		{ GRID_ATTR_STRIKETHROUGH, 9 }
	};
	n = 0;

	/* If any attribute is removed, begin with 0. */
	for (i = 0; i < nitems(attrs); i++) {
		if (!(attr & attrs[i].mask) && (lastattr & attrs[i].mask)) {
			s[n++] = 0;
			lastattr &= GRID_ATTR_CHARSET;
			break;
		}
	}
	/* For each attribute that is newly set, add its code. */
	for (i = 0; i < nitems(attrs); i++) {
		if ((attr & attrs[i].mask) && !(lastattr & attrs[i].mask))
			s[n++] = attrs[i].code;
	}

	/* Write the attributes. */
	*buf = '\0';
	if (n > 0) {
		if (escape_c0)
			strlcat(buf, "\\033[", len);
		else
			strlcat(buf, "\033[", len);
		for (i = 0; i < n; i++) {
			if (i + 1 < n)
				xsnprintf(tmp, sizeof tmp, "%d;", s[i]);
			else
				xsnprintf(tmp, sizeof tmp, "%d", s[i]);
			strlcat(buf, tmp, len);
		}
		strlcat(buf, "m", len);
	}

	/* If the foreground colour changed, write its parameters. */
	nnewc = grid_string_cells_fg(gc, newc);
	noldc = grid_string_cells_fg(lastgc, oldc);
	if (nnewc != noldc ||
	    memcmp(newc, oldc, nnewc * sizeof newc[0]) != 0 ||
	    (n != 0 && s[0] == 0)) {
		if (escape_c0)
			strlcat(buf, "\\033[", len);
		else
			strlcat(buf, "\033[", len);
		for (i = 0; i < nnewc; i++) {
			if (i + 1 < nnewc)
				xsnprintf(tmp, sizeof tmp, "%d;", newc[i]);
			else
				xsnprintf(tmp, sizeof tmp, "%d", newc[i]);
			strlcat(buf, tmp, len);
		}
		strlcat(buf, "m", len);
	}

	/* If the background colour changed, append its parameters. */
	nnewc = grid_string_cells_bg(gc, newc);
	noldc = grid_string_cells_bg(lastgc, oldc);
	if (nnewc != noldc ||
	    memcmp(newc, oldc, nnewc * sizeof newc[0]) != 0 ||
	    (n != 0 && s[0] == 0)) {
		if (escape_c0)
			strlcat(buf, "\\033[", len);
		else
			strlcat(buf, "\033[", len);
		for (i = 0; i < nnewc; i++) {
			if (i + 1 < nnewc)
				xsnprintf(tmp, sizeof tmp, "%d;", newc[i]);
			else
				xsnprintf(tmp, sizeof tmp, "%d", newc[i]);
			strlcat(buf, tmp, len);
		}
		strlcat(buf, "m", len);
	}

	/* Append shift in/shift out if needed. */
	if ((attr & GRID_ATTR_CHARSET) && !(lastattr & GRID_ATTR_CHARSET)) {
		if (escape_c0)
			strlcat(buf, "\\016", len); /* SO */
		else
			strlcat(buf, "\016", len);  /* SO */
	}
	if (!(attr & GRID_ATTR_CHARSET) && (lastattr & GRID_ATTR_CHARSET)) {
		if (escape_c0)
			strlcat(buf, "\\017", len); /* SI */
		else
			strlcat(buf, "\017", len);  /* SI */
	}
}

/* Convert cells into a string. */
char *
grid_string_cells(struct grid *gd, u_int px, u_int py, u_int nx,
    struct grid_cell **lastgc, int with_codes, int escape_c0, int trim)
{
	struct grid_cell	 gc;
	static struct grid_cell	 lastgc1;
	const char		*data;
	char			*buf, code[128];
	size_t			 len, off, size, codelen;
	u_int			 xx;
	const struct grid_line	*gl;

	if (lastgc != NULL && *lastgc == NULL) {
		memcpy(&lastgc1, &grid_default_cell, sizeof lastgc1);
		*lastgc = &lastgc1;
	}

	len = 128;
	buf = xmalloc(len);
	off = 0;

	gl = grid_peek_line(gd, py);
	for (xx = px; xx < px + nx; xx++) {
		if (gl == NULL || xx >= gl->cellsize)
			break;
		grid_get_cell(gd, xx, py, &gc);
		if (gc.flags & GRID_FLAG_PADDING)
			continue;

		if (with_codes) {
			grid_string_cells_code(*lastgc, &gc, code, sizeof code,
			    escape_c0);
			codelen = strlen(code);
			memcpy(*lastgc, &gc, sizeof **lastgc);
		} else
			codelen = 0;

		data = gc.data.data;
		size = gc.data.size;
		if (escape_c0 && size == 1 && *data == '\\') {
			data = "\\\\";
			size = 2;
		}

		while (len < off + size + codelen + 1) {
			buf = xreallocarray(buf, 2, len);
			len *= 2;
		}

		if (codelen != 0) {
			memcpy(buf + off, code, codelen);
			off += codelen;
		}
		memcpy(buf + off, data, size);
		off += size;
	}

	if (trim) {
		while (off > 0 && buf[off - 1] == ' ')
			off--;
	}
	buf[off] = '\0';

	return (buf);
}

/*
 * Duplicate a set of lines between two grids. Both source and destination
 * should be big enough.
 */
void
grid_duplicate_lines(struct grid *dst, u_int dy, struct grid *src, u_int sy,
    u_int ny)
{
	struct grid_line	*dstl, *srcl;
	u_int			 yy;

	if (dy + ny > dst->hsize + dst->sy)
		ny = dst->hsize + dst->sy - dy;
	if (sy + ny > src->hsize + src->sy)
		ny = src->hsize + src->sy - sy;
	grid_free_lines(dst, dy, ny);

	for (yy = 0; yy < ny; yy++) {
		srcl = &src->linedata[sy];
		dstl = &dst->linedata[dy];

		memcpy(dstl, srcl, sizeof *dstl);
		if (srcl->cellsize != 0) {
			dstl->celldata = xreallocarray(NULL,
			    srcl->cellsize, sizeof *dstl->celldata);
			memcpy(dstl->celldata, srcl->celldata,
			    srcl->cellsize * sizeof *dstl->celldata);
		} else
			dstl->celldata = NULL;

		if (srcl->extdsize != 0) {
			dstl->extdsize = srcl->extdsize;
			dstl->extddata = xreallocarray(NULL, dstl->extdsize,
			    sizeof *dstl->extddata);
			memcpy(dstl->extddata, srcl->extddata, dstl->extdsize *
			    sizeof *dstl->extddata);
		}

		sy++;
		dy++;
	}
}

/* Copy a section of a line. */
static void
grid_reflow_copy(struct grid_line *dst_gl, u_int to, struct grid_line *src_gl,
    u_int from, u_int to_copy)
{
	struct grid_cell_entry	*gce;
	u_int			 i, was;

	memcpy(&dst_gl->celldata[to], &src_gl->celldata[from],
	    to_copy * sizeof *dst_gl->celldata);

	for (i = to; i < to + to_copy; i++) {
		gce = &dst_gl->celldata[i];
		if (~gce->flags & GRID_FLAG_EXTENDED)
			continue;
		was = gce->offset;

		dst_gl->extddata = xreallocarray(dst_gl->extddata,
		    dst_gl->extdsize + 1, sizeof *dst_gl->extddata);
		gce->offset = dst_gl->extdsize++;
		memcpy(&dst_gl->extddata[gce->offset], &src_gl->extddata[was],
		    sizeof *dst_gl->extddata);
	}
}

/* Join line data. */
static void
grid_reflow_join(struct grid *dst, u_int *py, struct grid_line *src_gl,
    u_int new_x)
{
	struct grid_line	*dst_gl = &dst->linedata[(*py) - 1];
	u_int			 left, to_copy, ox, nx;

	/* How much is left on the old line? */
	left = new_x - dst_gl->cellused;

	/* Work out how much to append. */
	to_copy = src_gl->cellused;
	if (to_copy > left)
		to_copy = left;
	ox = dst_gl->cellused;
	nx = ox + to_copy;

	/* Resize the destination line. */
	dst_gl->celldata = xreallocarray(dst_gl->celldata, nx,
	    sizeof *dst_gl->celldata);
	dst_gl->cellsize = dst_gl->cellused = nx;

	/* Append as much as possible. */
	grid_reflow_copy(dst_gl, ox, src_gl, 0, to_copy);

	/* If there is any left in the source, split it. */
	if (src_gl->cellused > to_copy) {
		dst_gl->flags |= GRID_LINE_WRAPPED;

		src_gl->cellused -= to_copy;
		grid_reflow_split(dst, py, src_gl, new_x, to_copy);
	}
}

/* Split line data. */
static void
grid_reflow_split(struct grid *dst, u_int *py, struct grid_line *src_gl,
    u_int new_x, u_int offset)
{
	struct grid_line	*dst_gl = NULL;
	u_int			 to_copy;

	/* Loop and copy sections of the source line. */
	while (src_gl->cellused > 0) {
		/* Create new line. */
		if (*py >= dst->hsize + dst->sy)
			grid_scroll_history(dst, 8);
		dst_gl = &dst->linedata[*py];
		(*py)++;

		/* How much should we copy? */
		to_copy = new_x;
		if (to_copy > src_gl->cellused)
			to_copy = src_gl->cellused;

		/* Expand destination line. */
		dst_gl->celldata = xreallocarray(NULL, to_copy,
		    sizeof *dst_gl->celldata);
		dst_gl->cellsize = dst_gl->cellused = to_copy;
		dst_gl->flags |= GRID_LINE_WRAPPED;

		/* Copy the data. */
		grid_reflow_copy(dst_gl, 0, src_gl, offset, to_copy);

		/* Move offset and reduce old line size. */
		offset += to_copy;
		src_gl->cellused -= to_copy;
	}

	/* Last line is not wrapped. */
	if (dst_gl != NULL)
		dst_gl->flags &= ~GRID_LINE_WRAPPED;
}

/* Move line data. */
static void
grid_reflow_move(struct grid *dst, u_int *py, struct grid_line *src_gl)
{
	struct grid_line	*dst_gl;

	/* Create new line. */
	if (*py >= dst->hsize + dst->sy)
		grid_scroll_history(dst, 8);
	dst_gl = &dst->linedata[*py];
	(*py)++;

	/* Copy the old line. */
	memcpy(dst_gl, src_gl, sizeof *dst_gl);
	dst_gl->flags &= ~GRID_LINE_WRAPPED;

	/* Clear old line. */
	src_gl->celldata = NULL;
	src_gl->extddata = NULL;
}

/*
 * Reflow lines from src grid into dst grid of width new_x. Returns number of
 * lines fewer in the visible area. The source grid is destroyed.
 */
u_int
grid_reflow(struct grid *dst, struct grid *src, u_int new_x)
{
	u_int			 py, sy, line;
	int			 previous_wrapped;
	struct grid_line	*src_gl;

	py = 0;
	sy = src->sy;

	previous_wrapped = 0;
	for (line = 0; line < sy + src->hsize; line++) {
		src_gl = src->linedata + line;
		if (!previous_wrapped) {
			/* Wasn't wrapped. If smaller, move to destination. */
			if (src_gl->cellused <= new_x)
				grid_reflow_move(dst, &py, src_gl);
			else
				grid_reflow_split(dst, &py, src_gl, new_x, 0);
		} else {
			/* Previous was wrapped. Try to join. */
			grid_reflow_join(dst, &py, src_gl, new_x);
		}
		previous_wrapped = (src_gl->flags & GRID_LINE_WRAPPED);

		/* This is where we started scrolling. */
		if (line == sy + src->hsize - src->hscrolled - 1)
			dst->hscrolled = 0;
	}

	grid_destroy(src);

	if (py > sy)
		return (0);
	return (sy - py);
}
@


1.74
log
@Line length and spaces to tabs.
@
text
@d1 1
a1 1
/* $OpenBSD: grid.c,v 1.73 2017/05/13 07:30:50 nicm Exp $ */
d165 20
d210 1
a210 8
	struct grid_line	*gl;
	u_int			 yy;

	for (yy = 0; yy < gd->hsize + gd->sy; yy++) {
		gl = &gd->linedata[yy];
		free(gl->celldata);
		free(gl->extddata);
	}
d249 1
a249 1
grid_collect_history(struct grid *gd, u_int bg)
d251 1
a251 1
	u_int	yy;
d256 11
a266 3
	yy = gd->hlimit / 10;
	if (yy < 1)
		yy = 1;
d268 1
a268 2
	grid_move_lines(gd, 0, yy, gd->hsize + gd->sy - yy, bg);
	gd->hsize -= yy;
d295 3
a297 2
	grid_clear_lines(gd, 0, gd->hsize, 8);
	grid_move_lines(gd, 0, gd->hsize, gd->sy, 8);
d505 1
a505 2
	struct grid_line	*gl;
	u_int			 yy;
d516 1
a516 3
		gl = &gd->linedata[yy];
		free(gl->celldata);
		free(gl->extddata);
d543 1
a543 1
		grid_clear_lines(gd, yy, 1, bg);
d549 4
a552 1
	/* Wipe any lines that have been moved (without freeing them). */
d869 2
a870 3
 * Duplicate a set of lines between two grids. If there aren't enough lines in
 * either source or destination, the number of lines is limited to the number
 * available.
d883 1
a883 1
	grid_clear_lines(dst, dy, ny, 8);
@


1.73
log
@Some other unused variables.
@
text
@d1 1
a1 1
/* $OpenBSD: grid.c,v 1.72 2017/05/12 15:18:13 nicm Exp $ */
d668 1
a668 2
 * given a current state. The output buffer must be able to hold at least 57
 * bytes.
@


1.72
log
@When expanding a line in order to clear it, we need to use the default
background colour - there may be portions that we do not want to clear
with the new background colour.
@
text
@d1 1
a1 1
/* $OpenBSD: grid.c,v 1.71 2017/05/12 13:00:56 nicm Exp $ */
d289 1
a289 1
	struct grid_line	*gl_history, *gl_upper, *gl_lower;
a304 1
	gl_lower = &gd->linedata[lower];
@


1.71
log
@Scrolling needs to use background colour.
@
text
@d1 1
a1 1
/* $OpenBSD: grid.c,v 1.70 2017/04/25 18:20:51 nicm Exp $ */
d475 1
a475 1
		grid_expand_line(gd, yy, px + nx, bg);
@


1.70
log
@When we write out the grid including escape sequences, an SGR 0 needs to
cause the colours to be written again. Also treat colours separately
from attributes so that RGB colours will work.
@
text
@d1 1
a1 1
/* $OpenBSD: grid.c,v 1.69 2017/04/19 12:44:29 nicm Exp $ */
d287 1
a287 1
grid_scroll_history_region(struct grid *gd, u_int upper, u_int lower)
d312 1
a312 1
	memset(gl_lower, 0, sizeof *gl_lower);
@


1.69
log
@Style nits and a missing cast.
@
text
@d1 1
a1 1
/* $OpenBSD: grid.c,v 1.68 2017/03/22 07:16:54 nicm Exp $ */
d678 1
a678 2
	u_int	attr = gc->attr;
	u_int	lastattr = lastgc->attr;
d710 18
a727 1
	/* If the foreground colour changed, append its parameters. */
d730 15
a744 3
	if (nnewc != noldc || memcmp(newc, oldc, nnewc * sizeof newc[0]) != 0) {
		for (i = 0; i < nnewc; i++)
			s[n++] = newc[i];
d750 3
a752 8
	if (nnewc != noldc || memcmp(newc, oldc, nnewc * sizeof newc[0]) != 0) {
		for (i = 0; i < nnewc; i++)
			s[n++] = newc[i];
	}

	/* If there are any parameters, append an SGR code. */
	*buf = '\0';
	if (n > 0) {
d757 3
a759 3
		for (i = 0; i < n; i++) {
			if (i + 1 < n)
				xsnprintf(tmp, sizeof tmp, "%d;", s[i]);
d761 1
a761 1
				xsnprintf(tmp, sizeof tmp, "%d", s[i]);
d770 1
a770 1
			strlcat(buf, "\\016", len);  /* SO */
d776 1
a776 1
			strlcat(buf, "\\017", len);  /* SI */
@


1.68
log
@Add support for the strikethrough attribute (SGR 9), using the new smxx
terminfo capability. This means there are now nine attribute bits, so
anything above 0xff uses an extended cell.
@
text
@d1 1
a1 1
/* $OpenBSD: grid.c,v 1.67 2017/03/07 13:47:56 nicm Exp $ */
d92 1
a92 1
	if ((gc->fg & COLOUR_FLAG_RGB) ||(gc->bg & COLOUR_FLAG_RGB))
@


1.67
log
@If moving cells outside the current used count, update it.
@
text
@d1 1
a1 1
/* $OpenBSD: grid.c,v 1.66 2017/02/22 09:01:32 nicm Exp $ */
d88 2
d692 2
a693 1
		{ GRID_ATTR_HIDDEN, 8 }
@


1.66
log
@Minor bits: fix an array size, add comment, make grid_cell_entry static.
@
text
@d1 1
a1 1
/* $OpenBSD: grid.c,v 1.65 2017/02/13 16:05:30 nicm Exp $ */
d556 2
@


1.65
log
@Collected cells may still need to be extended for RGB colours.
@
text
@d1 1
a1 1
/* $OpenBSD: grid.c,v 1.64 2017/02/08 16:45:18 nicm Exp $ */
d42 1
a42 1
const struct grid_cell_entry grid_default_entry = {
@


1.64
log
@Collect sequences of printable ASCII characters and process them
together instead of handling them one by one. This is significantly
faster. Sequences are terminated when we reach the end of the line, fill
the internal buffer, or a different character is seen by the input
parser (an escape sequence, or UTF-8).

Rather than writing collected sequences out immediately, hold them until
it is necessary (another screen modification, or we consume all
available data). This means we can discard changes that would have no
effect (for example, lines that would just be scrolled off the screen or
cleared). This reduces the total amount of data we write out to the
terminal - not important for fast terminals, but a big help with slow
(like xterm).
@
text
@d1 1
a1 1
/* $OpenBSD: grid.c,v 1.63 2017/02/08 15:41:41 nicm Exp $ */
d81 14
a398 1
	int			 extended;
d410 1
a410 8
	extended = (gce->flags & GRID_FLAG_EXTENDED);
	if (!extended && (gc->data.size != 1 || gc->data.width != 1))
		extended = 1;
	if (!extended && (gc->fg & COLOUR_FLAG_RGB))
		extended = 1;
	if (!extended && (gc->bg & COLOUR_FLAG_RGB))
		extended = 1;
	if (extended)
d437 2
a438 3
		if (gce->flags & GRID_FLAG_EXTENDED) {
			gcp = &gl->extddata[gce->offset];
			memcpy(gcp, gc, sizeof *gcp);
@


1.63
log
@Add a helper to store a cell, and some tidying.
@
text
@d1 1
a1 1
/* $OpenBSD: grid.c,v 1.62 2017/02/08 08:26:35 nicm Exp $ */
d408 30
@


1.62
log
@Tweak how much we expand lines by.
@
text
@d1 1
a1 1
/* $OpenBSD: grid.c,v 1.61 2017/02/03 20:53:03 nicm Exp $ */
d62 19
a392 2
	gce = &gl->celldata[px];

d396 1
d404 1
a404 1
	if (extended) {
d406 2
a407 12
		return;
	}

	gce->flags = gc->flags;
	gce->data.attr = gc->attr;
	gce->data.fg = gc->fg & 0xff;
	if (gc->fg & COLOUR_FLAG_256)
		gce->flags |= GRID_FLAG_FG256;
	gce->data.bg = gc->bg & 0xff;
	if (gc->bg & COLOUR_FLAG_256)
		gce->flags |= GRID_FLAG_BG256;
	gce->data.data = gc->data.data[0];
@


1.61
log
@Expand lines more aggressively to reduce rate of allocations.
@
text
@d1 1
a1 1
/* $OpenBSD: grid.c,v 1.60 2016/10/18 19:52:49 nicm Exp $ */
d295 6
a300 5
	if (sx < gd->sx) {
		sx *= 2;
		if (sx > gd->sx)
			sx = gd->sx;
	}
@


1.60
log
@Clear cell entry with grid_default_entry not grid_default_cell.
@
text
@d1 1
a1 1
/* $OpenBSD: grid.c,v 1.59 2016/10/18 14:56:17 nicm Exp $ */
d294 6
@


1.59
log
@Make grid_clear_cell set up the entry properly for 256 and RGB cells.
@
text
@d1 1
a1 1
/* $OpenBSD: grid.c,v 1.58 2016/10/13 20:27:27 nicm Exp $ */
d93 1
a93 1
	memcpy(gce, &grid_default_cell, sizeof *gce);
@


1.58
log
@Add support for BCE (background colour erase). This makes various escape
sequences (notable EL and ED but also IL, DL, ICH, DCH) create blank
cells using the current background colour rather than the default
colour.

On modern systems BCE doesn't really have many benefits, but most other
terminals now support it, some (lazy) applications rely on it, and it is
not hard to include now that we have pane background colours anyway.

Mostly written by Sean Haugh.
@
text
@d1 1
a1 1
/* $OpenBSD: grid.c,v 1.57 2016/10/11 13:21:59 nicm Exp $ */
d62 23
d89 13
a101 2
	gd->linedata[py].celldata[px] = grid_default_entry;
	gd->linedata[py].celldata[px].data.bg = bg;
a358 1
	struct grid_cell 	*gcp;
d375 3
a377 2
	if (!extended && ((gc->fg & COLOUR_FLAG_RGB) ||
	    (gc->bg & COLOUR_FLAG_RGB)))
d380 1
a380 13
		gl->flags |= GRID_LINE_EXTENDED;

		if (~gce->flags & GRID_FLAG_EXTENDED) {
			gl->extddata = xreallocarray(gl->extddata,
			    gl->extdsize + 1, sizeof *gl->extddata);
			gce->offset = gl->extdsize++;
			gce->flags = gc->flags | GRID_FLAG_EXTENDED;
		}

		if (gce->offset >= gl->extdsize)
			fatalx("offset too big");
		gcp = &gl->extddata[gce->offset];
		memcpy(gcp, gc, sizeof *gcp);
@


1.57
log
@Add static in window-*.c and move some internal functions out of tmux.h.
@
text
@d1 1
a1 1
/* $OpenBSD: grid.c,v 1.56 2016/10/10 21:29:23 nicm Exp $ */
d46 2
a47 1
static void	grid_expand_line(struct grid *, u_int, u_int);
d64 1
a64 1
grid_clear_cell(struct grid *gd, u_int px, u_int py)
d67 1
d167 1
a167 1
grid_collect_history(struct grid *gd)
d178 1
a178 1
	grid_move_lines(gd, 0, yy, gd->hsize + gd->sy - yy);
d189 1
a189 1
grid_scroll_history(struct grid *gd)
d196 1
a196 1
	memset(&gd->linedata[yy], 0, sizeof gd->linedata[yy]);
d206 2
a207 2
	grid_clear_lines(gd, 0, gd->hsize);
	grid_move_lines(gd, 0, gd->hsize, gd->sy);
d252 1
a252 1
grid_expand_line(struct grid *gd, u_int py, u_int sx)
d263 1
a263 1
		grid_clear_cell(gd, xx, py);
d267 9
d331 1
a331 1
	grid_expand_line(gd, py, px + 1);
d336 3
d375 1
a375 1
grid_clear(struct grid *gd, u_int px, u_int py, u_int nx, u_int ny)
d383 1
a383 1
		grid_clear_lines(gd, py, ny);
d393 3
a395 1
		if (px >= gd->linedata[yy].cellsize)
d397 1
a397 1
		if (px + nx >= gd->linedata[yy].cellsize) {
d401 3
a403 5
		for (xx = px; xx < px + nx; xx++) {
			if (xx >= gd->linedata[yy].cellsize)
				break;
			grid_clear_cell(gd, xx, yy);
		}
d409 1
a409 1
grid_clear_lines(struct grid *gd, u_int py, u_int ny)
d426 1
a426 1
		memset(gl, 0, sizeof *gl);
d432 1
a432 1
grid_move_lines(struct grid *gd, u_int dy, u_int py, u_int ny)
d452 1
a452 1
		grid_clear_lines(gd, yy, 1);
d460 2
a461 3
		if (yy >= dy && yy < dy + ny)
			continue;
		memset(&gd->linedata[yy], 0, sizeof gd->linedata[yy]);
d467 2
a468 1
grid_move_cells(struct grid *gd, u_int dx, u_int px, u_int py, u_int nx)
d480 2
a481 2
	grid_expand_line(gd, py, px + nx);
	grid_expand_line(gd, py, dx + nx);
d489 1
a489 1
		grid_clear_cell(gd, xx, py);
d765 1
a765 1
	grid_clear_lines(dst, dy, ny);
d827 1
a827 1
	left = new_x - dst_gl->cellsize;
d830 1
a830 1
	to_copy = src_gl->cellsize;
d833 1
a833 1
	ox = dst_gl->cellsize;
d839 1
a839 1
	dst_gl->cellsize = nx;
d845 1
a845 1
	if (src_gl->cellsize > to_copy) {
d848 1
a848 1
		src_gl->cellsize -= to_copy;
d862 1
a862 1
	while (src_gl->cellsize > 0) {
d865 1
a865 1
			grid_scroll_history(dst);
d871 2
a872 2
		if (to_copy > src_gl->cellsize)
			to_copy = src_gl->cellsize;
d877 1
a877 1
		dst_gl->cellsize = to_copy;
d885 1
a885 1
		src_gl->cellsize -= to_copy;
d901 1
a901 1
		grid_scroll_history(dst);
d933 1
a933 1
			if (src_gl->cellsize <= new_x)
@


1.56
log
@Loads more static, except for cmd-*.c and window-*.c.
@
text
@d1 1
a1 1
/* $OpenBSD: grid.c,v 1.55 2016/09/02 20:57:20 nicm Exp $ */
d46 2
d55 1
d249 1
a249 1
void
@


1.55
log
@Remember the number of lines scrolled into the history (versus cleared
into the history) and when resizing only use scrolled lines and not
cleared lines (which are probably not intended to reappear). From
Chaoren Lin.
@
text
@d1 1
a1 1
/* $OpenBSD: grid.c,v 1.54 2016/07/15 00:49:08 nicm Exp $ */
d46 11
a56 10
void	grid_reflow_copy(struct grid_line *, u_int, struct grid_line *l,
	    u_int, u_int);
void	grid_reflow_join(struct grid *, u_int *, struct grid_line *, u_int);
void	grid_reflow_split(struct grid *, u_int *, struct grid_line *, u_int,
	    u_int);
void	grid_reflow_move(struct grid *, u_int *, struct grid_line *);
size_t	grid_string_cells_fg(const struct grid_cell *, int *);
size_t	grid_string_cells_bg(const struct grid_cell *, int *);
void	grid_string_cells_code(const struct grid_cell *,
	    const struct grid_cell *, char *, size_t, int);
d477 1
a477 1
size_t
d526 1
a526 1
size_t
d579 1
a579 1
void
d777 1
a777 1
void
d802 1
a802 1
void
d837 1
a837 1
void
d877 1
a877 1
void
@


1.54
log
@Don't update cells in each block of data read from a pane immediately,
instead track them as change (dirty) and update them once at the end,
saves much time if repeatedly writing the same cell. Also fix comparison
of cells being equal in a few places (memcmp is not enough).
@
text
@d1 1
a1 1
/* $OpenBSD: grid.c,v 1.53 2016/07/15 00:42:56 nicm Exp $ */
d102 1
d174 2
d192 1
d203 1
d205 1
d240 1
d924 4
@


1.53
log
@Instead of representing colours in several different forms with various
cell flags, convert to use an int with flags marking 256 or RGB colours
in the top byte (except in cells, which we don't want to make any
bigger). From Brad Town.
@
text
@d1 1
a1 1
/* $OpenBSD: grid.c,v 1.52 2016/01/31 09:57:09 nicm Exp $ */
a45 2
int	grid_check_y(struct grid *, u_int);

d65 1
a65 1
int
d75 15
d147 1
a147 1
			if (memcmp(&gca, &gcb, sizeof (struct grid_cell)) != 0)
d321 2
@


1.52
log
@Add RGB escape sequences for capture-pane -e.
@
text
@d1 1
a1 1
/* $OpenBSD: grid.c,v 1.51 2016/01/29 11:13:56 nicm Exp $ */
d40 1
a40 1
	0, 0, { .fg = 8 }, { .bg = 8 }, { { ' ' }, 0, 1, 1 }
d273 1
a273 1
	gc->flags = gce->flags & ~GRID_FLAG_EXTENDED;
d276 2
d279 2
d304 2
a305 1
	if (!extended && (gc->flags & (GRID_FLAG_FGRGB|GRID_FLAG_BGRGB)))
d322 1
a322 1
	gce->flags = gc->flags & ~GRID_FLAG_EXTENDED;
d324 6
a329 2
	gce->data.fg = gc->fg;
	gce->data.bg = gc->bg;
d458 1
d461 1
a461 1
	if (gc->flags & GRID_FLAG_FG256) {
d464 2
a465 2
		values[n++] = gc->fg;
	} else if (gc->flags & GRID_FLAG_FGRGB) {
d468 4
a471 3
		values[n++] = gc->fg_rgb.r;
		values[n++] = gc->fg_rgb.g;
		values[n++] = gc->fg_rgb.b;
d507 1
d510 1
a510 1
	if (gc->flags & GRID_FLAG_BG256) {
d513 2
a514 2
		values[n++] = gc->bg;
	} else if (gc->flags & GRID_FLAG_BGRGB) {
d517 4
a520 3
		values[n++] = gc->bg_rgb.r;
		values[n++] = gc->bg_rgb.g;
		values[n++] = gc->bg_rgb.b;
d541 1
a541 1
			case 105:
@


1.51
log
@Support for RGB colour, using the extended cell mechanism to avoid
wasting unnecessary space. The 'Tc' flag must be set in the external
TERM entry (using terminal-overrides or a custom terminfo entry), if not
tmux will map to the closest of the 256 or 16 colour palettes.

Mostly from Suraj N Kurapati, based on a diff originally by someone else.
@
text
@d1 1
a1 1
/* $OpenBSD: grid.c,v 1.50 2016/01/19 15:59:12 nicm Exp $ */
d455 6
d502 6
d547 1
a547 1
	int	oldc[16], newc[16], s[32];
@


1.50
log
@I no longer use my SourceForge address so replace it.
@
text
@d1 1
a1 1
/* $OpenBSD: grid.c,v 1.49 2015/11/22 19:42:57 nicm Exp $ */
d40 1
a40 1
	0, 0, 8, 8, { { ' ' }, 0, 1, 1 }
d287 1
d297 6
a302 2
	if ((gce->flags & GRID_FLAG_EXTENDED) || gc->data.size != 1 ||
	    gc->data.width != 1) {
@


1.49
log
@Don't leak extddata, memset after freeing it, not before. From Patrick
Palka.
@
text
@d1 1
a1 1
/* $OpenBSD: grid.c,v 1.48 2015/11/13 08:09:28 nicm Exp $ */
d4 1
a4 1
 * Copyright (c) 2008 Nicholas Marriott <nicm@@users.sourceforge.net>
@


1.48
log
@Long overdue change to the way we store cells in the grid: now, instead
of storing a full grid_cell with UTF-8 data and everything, store a new
type grid_cell_entry. This can either be the cell itself (for ASCII
cells), or an offset into an extended array (per line) for UTF-8
data.

This avoid a large (8 byte) overhead on non-UTF-8 cells (by far the
majority for most users) without the complexity of the shadow array we
had before. Grid memory without any UTF-8 is about half.

The disadvantage that cells can no longer be modified in place and need
to be copied out of the grid and back but it turned out to be lot less
complicated than I expected.
@
text
@d1 1
a1 1
/* $OpenBSD: grid.c,v 1.47 2015/11/12 14:50:57 nicm Exp $ */
d371 1
a372 4

		free(gl->extddata);
		gl->extddata = NULL;
		gl->extdsize = 0;
@


1.47
log
@grid_put_utf8 is unused, remove it.
@
text
@d1 1
a1 1
/* $OpenBSD: grid.c,v 1.46 2015/09/25 15:53:07 nicm Exp $ */
d39 6
a44 6
const struct grid_cell grid_default_cell = { 0, 0, 8, 8, (1 << 4) | 1, " " };

#define grid_put_cell(gd, px, py, gc) do {			\
	memcpy(&gd->linedata[py].celldata[px], 			\
	    gc, sizeof gd->linedata[py].celldata[px]);		\
} while (0)
d48 2
d59 7
d107 1
d120 1
a120 1
	struct grid_cell	*gca, *gcb;
d131 4
a134 4
		for (xx = 0; xx < ga->sx; xx++) {
			gca = &gla->celldata[xx];
			gcb = &glb->celldata[xx];
			if (memcmp(gca, gcb, sizeof (struct grid_cell)) != 0)
d237 1
a237 1
		grid_put_cell(gd, xx, py, &grid_default_cell);
d251 2
a252 2
const struct grid_cell *
grid_peek_cell(struct grid *gd, u_int px, u_int py)
d254 7
a260 2
	if (grid_check_y(gd, py) != 0)
		return (&grid_default_cell);
d262 2
a263 4
	if (px >= gd->linedata[py].cellsize)
		return (&grid_default_cell);
	return (&gd->linedata[py].celldata[px]);
}
d265 7
a271 6
/* Get cell at relative position (for writing). */
struct grid_cell *
grid_get_cell(struct grid *gd, u_int px, u_int py)
{
	if (grid_check_y(gd, py) != 0)
		return (NULL);
d273 5
a277 2
	grid_expand_line(gd, py, px + 1);
	return (&gd->linedata[py].celldata[px]);
d284 4
d292 25
a316 1
	grid_put_cell(gd, px, py, gc);
d348 1
a348 1
			grid_put_cell(gd, xx, yy, &grid_default_cell);
d372 4
d438 1
a438 1
		grid_put_cell(gd, xx, py, &grid_default_cell);
d620 1
a620 1
	const struct grid_cell	*gc;
a621 1
	struct utf8_data	 ud;
d641 2
a642 2
		gc = &gl->celldata[xx];
		if (gc->flags & GRID_FLAG_PADDING)
a643 1
		grid_cell_get(gc, &ud);
d646 1
a646 1
			grid_string_cells_code(*lastgc, gc, code, sizeof code,
d649 1
a649 1
			memcpy(*lastgc, gc, sizeof *gc);
d653 2
a654 2
		data = ud.data;
		size = ud.size;
d713 8
d726 25
d775 1
a775 2
	memcpy(&dst_gl->celldata[ox], &src_gl->celldata[0],
	    to_copy * sizeof src_gl->celldata[0]);
d814 1
a814 2
		memcpy(&dst_gl->celldata[0], &src_gl->celldata[offset],
		    to_copy * sizeof dst_gl->celldata[0]);
d844 1
d874 1
a874 1
		previous_wrapped = src_gl->flags & GRID_LINE_WRAPPED;
@


1.46
log
@Free the history when it is cleared, based on a diff from Carlo Cannas.
@
text
@d1 1
a1 1
/* $OpenBSD: grid.c,v 1.45 2015/09/02 17:12:07 nicm Exp $ */
a43 4
} while (0)
#define grid_put_utf8(gd, px, py, gc) do {			\
	memcpy(&gd->linedata[py].utf8data[px], 			\
	    gc, sizeof gd->linedata[py].utf8data[px]);		\
@


1.45
log
@Fix indentation of grid_string_cells_fg.
@
text
@d1 1
a1 1
/* $OpenBSD: grid.c,v 1.44 2015/08/24 22:49:13 nicm Exp $ */
d173 12
d359 2
a360 2
	memmove(
	    &gd->linedata[dy], &gd->linedata[py], ny * (sizeof *gd->linedata));
d386 2
a387 2
	memmove(
	    &gl->celldata[dx], &gl->celldata[px], nx * sizeof *gl->celldata);
@


1.44
log
@In grid_duplicate_lines, if the line is empty (cellsize == 0) then clear
the destination celldata pointer rather than leaving a stale copy of the
source pointer (which may later be freed). Fixes a crash found by
Kuang-che Wu.
@
text
@d1 1
a1 1
/* $OpenBSD: grid.c,v 1.43 2015/05/08 15:56:49 nicm Exp $ */
d398 23
a420 23
			case 0:
			case 1:
			case 2:
			case 3:
			case 4:
			case 5:
			case 6:
			case 7:
				values[n++] = gc->fg + 30;
				break;
			case 8:
				values[n++] = 39;
				break;
			case 90:
			case 91:
			case 92:
			case 93:
			case 94:
			case 95:
			case 96:
			case 97:
				values[n++] = gc->fg;
				break;
@


1.43
log
@Remove some stuff that accidentally ended up here from portable, and
remove a little-used debug function.
@
text
@d1 1
a1 1
/* $OpenBSD: grid.c,v 1.42 2015/04/23 07:45:50 deraadt Exp $ */
d655 2
a656 1
		}
@


1.42
log
@use reallocarray instead of calloc; avoid the zero before infill
ok nicm
@
text
@d1 1
a1 1
/* $OpenBSD: grid.c,v 1.41 2014/10/08 17:35:58 nicm Exp $ */
d52 10
a61 9
#ifdef DEBUG
int
grid_check_y(struct grid *gd, u_int py)
{
	if ((py) >= (gd)->hsize + (gd)->sy)
		log_fatalx("y out of range: %u", py);
	return (0);
}
#else
a70 10
#endif

void	grid_reflow_join(struct grid *, u_int *, struct grid_line *, u_int);
void	grid_reflow_split(struct grid *, u_int *, struct grid_line *, u_int,
	    u_int);
void	grid_reflow_move(struct grid *, u_int *, struct grid_line *);
size_t	grid_string_cells_fg(const struct grid_cell *, int *);
size_t	grid_string_cells_bg(const struct grid_cell *, int *);
void	grid_string_cells_code(const struct grid_cell *,
	    const struct grid_cell *, char *, size_t, int);
@


1.41
log
@Add xreallocarray and remove nmemb argument from xrealloc.
@
text
@d1 1
a1 1
/* $OpenBSD: grid.c,v 1.40 2014/10/08 17:14:04 nicm Exp $ */
d660 1
a660 1
			dstl->celldata = xcalloc(
@


1.40
log
@Use xrealloc(NULL, n, m) instead of xmalloc(n * m) to get overflow
check.
@
text
@d1 1
a1 1
/* $OpenBSD: grid.c,v 1.39 2014/09/17 15:31:38 nicm Exp $ */
d175 2
a176 1
	gd->linedata = xrealloc(gd->linedata, yy + 1, sizeof *gd->linedata);
d191 2
a192 1
	gd->linedata = xrealloc(gd->linedata, yy + 1, sizeof *gd->linedata);
d226 1
a226 1
	gl->celldata = xrealloc(gl->celldata, sx, sizeof *gl->celldata);
d615 1
a615 1
			buf = xrealloc(buf, 2, len);
d690 1
a690 1
	dst_gl->celldata = xrealloc(dst_gl->celldata, nx,
d729 1
a729 1
		dst_gl->celldata = xrealloc(NULL, to_copy,
@


1.39
log
@Fix some comments (c -> colour) and join unnecessary line splits.
@
text
@d1 1
a1 1
/* $OpenBSD: grid.c,v 1.38 2014/09/01 21:50:18 nicm Exp $ */
d727 2
a728 1
		dst_gl->celldata = xmalloc(to_copy * sizeof *dst_gl->celldata);
@


1.38
log
@Various minor style and spacing nits.
@
text
@d1 1
a1 1
/* $OpenBSD: grid.c,v 1.37 2014/04/16 23:05:38 nicm Exp $ */
d517 1
a517 1
	/* If the foreground c changed, append its parameters. */
d520 1
a520 2
	if (nnewc != noldc ||
	    memcmp(newc,oldc, nnewc * sizeof newc[0]) != 0) {
d525 1
a525 1
	/* If the background c changed, append its parameters. */
d528 1
a528 2
	if (nnewc != noldc ||
	    memcmp(newc, oldc, nnewc * sizeof newc[0]) != 0) {
@


1.37
log
@Memory leak in error path and unnecessary assignment, from clang.
@
text
@d1 1
a1 1
/* $OpenBSD: grid.c,v 1.36 2014/03/31 21:42:27 nicm Exp $ */
d575 1
a575 1
	const char*		 data;
@


1.36
log
@GRID_DEBUG is no longer needed.
@
text
@d1 1
a1 1
/* $OpenBSD: grid.c,v 1.35 2014/02/14 13:59:01 nicm Exp $ */
d627 1
a627 1
        if (trim) {
@


1.35
log
@Style nit - no space between function name and bracket.
@
text
@d1 1
a1 1
/* $OpenBSD: grid.c,v 1.34 2014/01/28 23:07:09 nicm Exp $ */
a153 2
	GRID_DEBUG(gd, "");

a173 2
	GRID_DEBUG(gd, "");

a187 2
	GRID_DEBUG(gd, "upper=%u, lower=%u", upper, lower);

a278 2
	GRID_DEBUG(gd, "px=%u, py=%u, nx=%u, ny=%u", px, py, nx, ny);

a313 2
	GRID_DEBUG(gd, "py=%u, ny=%u", py, ny);

a334 2
	GRID_DEBUG(gd, "dy=%u, py=%u, ny=%u", dy, py, ny);

a371 2
	GRID_DEBUG(gd, "dx=%u, px=%u, py=%u, nx=%u", dx, px, py, nx);

a580 2
	GRID_DEBUG(gd, "px=%u, py=%u, nx=%u", px, py, nx);

a646 2

	GRID_DEBUG(src, "dy=%u, sy=%u, ny=%u", dy, sy, ny);
@


1.34
log
@Allow replacing each of the many sets of separate foo-{fg,bg,attr}
options with a single foo-style option. For example:

    set -g status-fg yellow
    set -g status-bg red
    set -g status-attr blink

Becomes:

    set -g status-style fg=yellow,bg=red,blink

The -a flag to set can be used to add to rather than replace a style. So:

    set -g status-bg red

Becomes:

    set -ag status-style bg=red

Currently this is fully backwards compatible (all *-{fg,bg,attr} options
remain) but the plan is to deprecate them over time.

From Tiago Cunha.
@
text
@d1 1
a1 1
/* $OpenBSD: grid.c,v 1.33 2014/01/15 11:44:18 nicm Exp $ */
d752 1
a752 1
		memcpy (&dst_gl->celldata[0], &src_gl->celldata[offset],
@


1.33
log
@Couple of fixes from cppcheck via Tiago Cunha.
@
text
@d1 1
a1 1
/* $OpenBSD: grid.c,v 1.32 2014/01/09 13:58:06 nicm Exp $ */
a39 1
const struct grid_cell grid_marker_cell = { 0, 0, 8, 8, (1 << 4) | 1, "_" };
@


1.32
log
@Style and comment fixes from Tiago Cunha.
@
text
@d1 1
a1 1
/* $OpenBSD: grid.c,v 1.31 2013/10/10 12:01:14 nicm Exp $ */
d127 1
a127 1
	if (ga->sx != gb->sx || ga->sy != ga->sy)
@


1.31
log
@Trivial style and spacing nits.
@
text
@d1 1
a1 1
/* $OpenBSD: grid.c,v 1.30 2013/10/10 11:49:29 nicm Exp $ */
d647 1
a647 1
        }
@


1.30
log
@Only include actual trailing spaces not unused cells with capturep -J,
from George Nachman.
@
text
@d1 1
a1 1
/* $OpenBSD: grid.c,v 1.29 2013/03/25 10:07:40 nicm Exp $ */
d271 1
a271 2
grid_set_cell(
    struct grid *gd, u_int px, u_int py, const struct grid_cell *gc)
d659 2
a660 2
grid_duplicate_lines(
    struct grid *dst, u_int dy, struct grid *src, u_int sy, u_int ny)
@


1.29
log
@Allow lastgc to be NULL in grid_string_cells so find-window doesn't
crash, problem reported by eugene everson.
@
text
@d1 1
a1 1
/* $OpenBSD: grid.c,v 1.28 2013/03/25 10:05:35 nicm Exp $ */
d595 1
d608 1
d610 3
a612 1
		gc = grid_peek_cell(gd, xx, py);
@


1.28
log
@Preserve trailing spaces with capture-pane -J, from George Nachman.
@
text
@d1 1
a1 1
/* $OpenBSD: grid.c,v 1.27 2013/03/25 10:01:43 nicm Exp $ */
d598 1
a598 1
	if (*lastgc == NULL) {
@


1.27
log
@Use \\ not \ for escaping \.
@
text
@d1 1
a1 1
/* $OpenBSD: grid.c,v 1.26 2013/03/22 15:56:11 nicm Exp $ */
d586 1
a586 1
    struct grid_cell **lastgc, int with_codes, int escape_c0)
d641 4
a644 2
	while (off > 0 && buf[off - 1] == ' ')
		off--;
@


1.26
log
@Add -C and -J to capture pane to escape control sequences and to join
wrapped line, based on a diff from George Nachman.
@
text
@d1 1
a1 1
/* $OpenBSD: grid.c,v 1.25 2013/03/22 15:53:58 nicm Exp $ */
d624 1
a624 1
			data = "\\";
@


1.25
log
@Clear last attributes after reset in string_cells, from George Nachman.
@
text
@d1 1
a1 1
/* $OpenBSD: grid.c,v 1.24 2013/03/22 15:51:54 nicm Exp $ */
d80 1
a80 1
	    const struct grid_cell *, char *, size_t);
d237 9
d497 1
a497 1
    const struct grid_cell *gc, char *buf, size_t len)
d554 4
a557 1
		strlcat(buf, "\033[", len);
d569 12
a580 4
	if ((attr & GRID_ATTR_CHARSET) && !(lastattr & GRID_ATTR_CHARSET))
		strlcat(buf, "\016", len);  /* SO */
	if (!(attr & GRID_ATTR_CHARSET) && (lastattr & GRID_ATTR_CHARSET))
		strlcat(buf, "\017", len);  /* SI */
d586 1
a586 1
    struct grid_cell **lastgc, int with_codes)
d591 1
d593 1
a593 1
	size_t			 len, off, codelen;
d614 2
a615 1
			grid_string_cells_code(*lastgc, gc, code, sizeof code);
d621 8
a628 1
		while (len < off + ud.size + codelen + 1) {
d637 2
a638 2
		memcpy(buf + off, ud.data, ud.size);
		off += ud.size;
d644 1
@


1.24
log
@Add -e flag to capture-pane to include embedded ANSI SGR escape
sequences, from George Nachman.
@
text
@d1 1
a1 1
/* $OpenBSD: grid.c,v 1.23 2013/03/21 16:12:10 nicm Exp $ */
d514 1
d527 2
a528 1
	if (nnewc != noldc || memcmp(newc, oldc, nnewc * sizeof newc[0]) != 0) {
d536 2
a537 1
	if (nnewc != noldc || memcmp(newc, oldc, nnewc * sizeof newc[0]) != 0) {
@


1.23
log
@Rework reflow code so it does not do so much allocation which should be
faster with large histories.
@
text
@d1 1
a1 1
/* $OpenBSD: grid.c,v 1.22 2013/02/05 11:08:59 nicm Exp $ */
d77 4
d399 161
d562 2
a563 1
grid_string_cells(struct grid *gd, u_int px, u_int py, u_int nx)
d566 1
d568 2
a569 2
	char			*buf;
	size_t			 len, off;
d574 5
d589 8
a596 1
		while (len < off + ud.size + 1) {
d601 4
@


1.22
log
@Automatically reflow wrapped lines when a pane is resized, requested by
many over the years and finally implemented by Richard Woodbury.
@
text
@d1 1
a1 1
/* $OpenBSD: grid.c,v 1.21 2013/01/18 02:16:21 nicm Exp $ */
d73 5
d469 96
d566 2
a567 2
 * Reflow lines from src grid into dst grid based on width sx. Returns number
 * of lines fewer in the visible area, or zero.
d570 1
a570 1
grid_reflow(struct grid *dst, const struct grid *src, u_int sx)
d572 1
a572 1
	u_int			 px, py, line, cell;
d574 4
a577 1
	struct grid_line	*gl;
d579 3
a581 4
	px = py = 0;
	previous_wrapped = 1;
	for (line = 0; line < src->sy + src->hsize; line++) {
		gl = src->linedata + line;
d583 8
a590 4
			px = 0;
			py++;
			if (py >= dst->hsize + dst->sy)
				grid_scroll_history(dst);
d592 1
a592 12
		for (cell = 0; cell < gl->cellsize; cell++) {
			if (px == sx) {
				dst->linedata[py].flags |= GRID_LINE_WRAPPED;
				px = 0;
				py++;
				if (py >= dst->hsize + dst->sy)
					grid_scroll_history(dst);
			}
			grid_set_cell(dst, px, py, gl->celldata + cell);
			px++;
		}
		previous_wrapped = gl->flags & GRID_LINE_WRAPPED;
a593 1
	py++; /* account for final line, which never wraps */
d595 3
a597 1
	if (py > src->sy)
d599 1
a599 1
	return (src->sy - py);
@


1.21
log
@Rather than having two grids for each pane, one for ASCII and one for
UTF-8, collapse the two together. Simplifies the code at the expense of
more memory (which can probably be reduced again later).
@
text
@d1 1
a1 1
/* $OpenBSD: grid.c,v 1.20 2012/07/10 11:53:01 nicm Exp $ */
d462 41
@


1.20
log
@xfree is not particularly helpful, remove it. From Thomas Adam.
@
text
@d1 1
a1 1
/* $OpenBSD: grid.c,v 1.19 2012/05/23 19:19:40 nicm Exp $ */
d39 2
a40 2
const struct grid_cell grid_default_cell = { 0, 0, 8, 8, ' ' };
const struct grid_cell grid_marker_cell = { 0, 0, 8, 8, '_' };
a102 1
		free(gl->utf8data);
a115 1
	struct grid_utf8	*gua, *gub;
a130 6
			if (!(gca->flags & GRID_FLAG_UTF8))
				continue;
			gua = &gla->utf8data[xx];
			gub = &glb->utf8data[xx];
			if (memcmp(gua, gub, sizeof (struct grid_utf8)) != 0)
				return (1);
a227 14
/* Expand line to fit to cell for UTF-8. */
void
grid_expand_line_utf8(struct grid *gd, u_int py, u_int sx)
{
	struct grid_line	*gl;

	gl = &gd->linedata[py];
	if (sx <= gl->utf8size)
		return;

	gl->utf8data = xrealloc(gl->utf8data, sx, sizeof *gl->utf8data);
	gl->utf8size = sx;
}

a262 35
/* Get UTF-8 for reading. */
const struct grid_utf8 *
grid_peek_utf8(struct grid *gd, u_int px, u_int py)
{
	if (grid_check_y(gd, py) != 0)
		return (NULL);

	if (px >= gd->linedata[py].utf8size)
		return (NULL);
	return (&gd->linedata[py].utf8data[px]);
}

/* Get utf8 at relative position (for writing). */
struct grid_utf8 *
grid_get_utf8(struct grid *gd, u_int px, u_int py)
{
	if (grid_check_y(gd, py) != 0)
		return (NULL);

	grid_expand_line_utf8(gd, py, px + 1);
	return (&gd->linedata[py].utf8data[px]);
}

/* Set utf8 at relative position. */
void
grid_set_utf8(
    struct grid *gd, u_int px, u_int py, const struct grid_utf8 *gc)
{
	if (grid_check_y(gd, py) != 0)
		return;

	grid_expand_line_utf8(gd, py, px + 1);
	grid_put_utf8(gd, px, py, gc);
}

a318 1
		free(gl->utf8data);
a381 7
	if (gl->utf8data != NULL) {
		grid_expand_line_utf8(gd, py, px + nx);
		grid_expand_line_utf8(gd, py, dx + nx);
		memmove(&gl->utf8data[dx],
		    &gl->utf8data[px], nx * sizeof *gl->utf8data);
	}

d395 1
a395 1
	const struct grid_utf8	*gu;
d397 1
a397 1
	size_t			 len, off, size;
d410 1
d412 4
a415 15
		if (gc->flags & GRID_FLAG_UTF8) {
			gu = grid_peek_utf8(gd, xx, py);

			size = grid_utf8_size(gu);
			while (len < off + size + 1) {
				buf = xrealloc(buf, 2, len);
				len *= 2;
			}

			off += grid_utf8_copy(gu, buf + off, len - off);
		} else {
			while (len < off + 2) {
				buf = xrealloc(buf, 2, len);
				len *= 2;
			}
d417 2
a418 2
			buf[off++] = gc->data;
		}
a456 6
		}
		if (srcl->utf8size != 0) {
			dstl->utf8data = xcalloc(
			    srcl->utf8size, sizeof *dstl->utf8data);
			memcpy(dstl->utf8data, srcl->utf8data,
			    srcl->utf8size * sizeof *dstl->utf8data);
@


1.19
log
@Use a predefined structure for not-space cells used to set attributes.
@
text
@d1 1
a1 1
/* $OpenBSD: grid.c,v 1.18 2010/04/06 21:35:44 nicm Exp $ */
d21 1
d102 2
a103 4
		if (gl->celldata != NULL)
			xfree(gl->celldata);
		if (gl->utf8data != NULL)
			xfree(gl->utf8data);
d106 1
a106 1
	xfree(gd->linedata);
d108 1
a108 1
	xfree(gd);
d375 2
a376 4
		if (gl->celldata != NULL)
			xfree(gl->celldata);
		if (gl->utf8data != NULL)
			xfree(gl->utf8data);
@


1.18
log
@Merge copy mode and output mode, dropping the latter. Idea and code from
Micah Cowan.
@
text
@d1 1
a1 1
/* $OpenBSD: grid.c,v 1.17 2009/12/03 22:50:10 nicm Exp $ */
d39 1
@


1.17
log
@Massive spaces->tabs and trailing whitespace cleanup, hopefully for the last
time now I've configured emacs to make them displayed in really annoying
colours...
@
text
@d1 1
a1 1
/* $OpenBSD: grid.c,v 1.16 2009/11/18 17:02:17 nicm Exp $ */
a48 1
int	grid_check_x(struct grid *, u_int);
a52 8
grid_check_x(struct grid *gd, u_int px)
{
	if ((px) >= (gd)->sx)
		log_fatalx("x out of range: %u", px);
	return (0);
}

int
a60 10
grid_check_x(struct grid *gd, u_int px)
{
	if ((px) >= (gd)->sx) {
		log_debug("x out of range: %u", px);
		return (-1);
	}
	return (0);
}

int
a253 2
	if (grid_check_x(gd, px) != 0)
		return (&grid_default_cell);
a265 2
	if (grid_check_x(gd, px) != 0)
		return (NULL);
a277 2
	if (grid_check_x(gd, px) != 0)
		return;
a288 2
	if (grid_check_x(gd, px) != 0)
		return (NULL);
a300 2
	if (grid_check_x(gd, px) != 0)
		return (NULL);
a312 2
	if (grid_check_x(gd, px) != 0)
		return;
a335 4
	if (grid_check_x(gd, px) != 0)
		return;
	if (grid_check_x(gd, px + nx - 1) != 0)
		return;
a432 6
	if (grid_check_x(gd, px) != 0)
		return;
	if (grid_check_x(gd, px + nx - 1) != 0)
		return;
	if (grid_check_x(gd, dx + nx - 1) != 0)
		return;
@


1.16
log
@Cleanup by moving various (mostly horrible) little bits handling UTF-8 grid
data into functions in a new file, grid-utf8.c, and use sizeof intead of
UTF8_DATA.

Also nuke trailing whitespace from tmux.1, reminded by jmc.
@
text
@d1 1
a1 1
/* $OpenBSD: grid.c,v 1.15 2009/10/13 15:38:37 nicm Exp $ */
d173 1
a173 1
 	GRID_DEBUG(gd, "");
d186 1
a186 1
/* 
d195 1
a195 1
 	GRID_DEBUG(gd, "");
d200 1
a200 1
	
d211 1
a211 1
 	GRID_DEBUG(gd, "upper=%u, lower=%u", upper, lower);
d357 1
a357 1
 	GRID_DEBUG(gd, "px=%u, py=%u, nx=%u, ny=%u", px, py, nx, ny);
d398 1
a398 1
 	GRID_DEBUG(gd, "py=%u, ny=%u", py, ny);
d424 1
a424 1
 	GRID_DEBUG(gd, "dy=%u, py=%u, ny=%u", dy, py, ny);
d463 1
a463 1
 	GRID_DEBUG(gd, "dx=%u, px=%u, py=%u, nx=%u", dx, px, py, nx);
d502 2
a503 2
 	const struct grid_cell	*gc;
 	const struct grid_utf8	*gu;
d538 1
a538 1
	
d545 1
a545 1
/* 
@


1.15
log
@Move lines into the history when scrolling even if the scroll region is not
the entire screen.

Allows ircII users to see history, prompted by naddy.
@
text
@d1 1
a1 1
/* $OpenBSD: grid.c,v 1.14 2009/09/15 15:14:09 nicm Exp $ */
d505 2
a506 2
	size_t			 len, off;
	u_int			 xx, i;
d520 4
a523 1
			while (len < off + UTF8_SIZE + 1) {
d528 1
a528 6
			gu = grid_peek_utf8(gd, xx, py);
			for (i = 0; i < UTF8_SIZE; i++) {
				if (gu->data[i] == 0xff)
					break;
				buf[off++] = gu->data[i];
			}
@


1.14
log
@Stick line length to what is actually used (removing an optimization that
allowed it to be bigger), and use clear line/EOL sequences rather than spaces
in copy/scroll mode.

This fixes xterm copy/paste from tmux which treats trailing spaces differently
from clearing a line with the escape sequences. Reported by martynas@@.
@
text
@d1 1
a1 1
/* $OpenBSD: grid.c,v 1.13 2009/08/21 07:29:37 nicm Exp $ */
d164 4
a167 1
/* Scroll a line into the history. */
d169 1
a169 1
grid_scroll_line(struct grid *gd)
d175 19
a193 5
	if (gd->hsize >= gd->hlimit) {
		/* If the limit is hit, free the bottom 10% and shift up. */
		yy = gd->hlimit / 10;
		if (yy < 1)
			yy = 1;
d195 1
a195 3
		grid_move_lines(gd, 0, yy, gd->hsize + gd->sy - yy);
		gd->hsize -= yy;
	}
d198 5
d204 11
a215 1
	memset(&gd->linedata[yy], 0, sizeof gd->linedata[yy]);
d217 18
@


1.13
log
@Fix grid_expand_line so it actually works when the required size is bigger than
2 * the current size.
@
text
@d1 1
a1 1
/* $OpenBSD: grid.c,v 1.12 2009/08/20 19:14:42 nicm Exp $ */
d192 1
a192 1
grid_expand_line(struct grid *gd, u_int py, u_int wantx)
d195 1
a195 1
	u_int			 xx, sx;
d198 1
a198 1
	if (wantx <= gl->cellsize)
a200 7
	if (gl->cellsize > gd->sx / 2)
		sx = gd->sx;
	else {
		sx = gl->cellsize + 1;
		while (sx < wantx)
			sx *= 2;
	}
d303 1
a303 4
/*
 * Clear area. Note this is different from a fill as it just omits unallocated
 * cells.
 */
d329 6
@


1.12
log
@A few trivial optimisations: no need to check for zero size if calling
buffer_ensure in buffer.c; expand grid lines by a greater increase than one
each time; and don't read UTF-8 data unless it actually needs to be checked
when overwriting a cell.
@
text
@d1 1
a1 1
/* $OpenBSD: grid.c,v 1.11 2009/08/10 17:59:59 nicm Exp $ */
d192 1
a192 1
grid_expand_line(struct grid *gd, u_int py, u_int sx)
d195 1
a195 1
	u_int			 xx;
d198 1
a198 1
	if (sx <= gl->cellsize)
d203 5
a207 2
	else
		sx = 1 + gl->cellsize * 2;
@


1.11
log
@Use the right source and destination lines in grid_duplicate_lines.
@
text
@d1 1
a1 1
/* $OpenBSD: grid.c,v 1.10 2009/08/08 13:29:27 nicm Exp $ */
d201 4
@


1.10
log
@Change the way the grid is stored, previously it was:

- a two-dimensional array of cells;
- a two-dimensional array of utf8 data;
- an array of line lengths.

Now it is a single array of a new struct grid_line each of which represents a
line and containts the length and an array of cells and an array of utf8 data.

This will make it easier to add additional per-line members, such as flags.
@
text
@d1 1
a1 1
/* $OpenBSD: grid.c,v 1.9 2009/07/21 18:40:30 nicm Exp $ */
d517 2
a518 2
		srcl = &src->linedata[yy];
		dstl = &dst->linedata[yy];
@


1.9
log
@Remove a couple of unused functions and fix a type ("FALLTHOUGH"), found by
lint.
@
text
@d1 1
a1 1
/* $OpenBSD: grid.c,v 1.8 2009/07/16 07:34:37 nicm Exp $ */
d41 2
a42 1
	memcpy(&gd->data[py][px], gc, sizeof gd->data[py][px]);	\
d45 2
a46 1
	memcpy(&gd->udata[py][px], gc, sizeof gd->udata[py][px]); \
d105 1
a105 5
	gd->size = xcalloc(gd->sy, sizeof *gd->size);
	gd->data = xcalloc(gd->sy, sizeof *gd->data);

	gd->usize = xcalloc(gd->sy, sizeof *gd->usize);
	gd->udata = xcalloc(gd->sy, sizeof *gd->udata);
d114 2
a115 1
	u_int	yy;
d118 5
a122 4
		if (gd->udata[yy] != NULL)
			xfree(gd->udata[yy]);
		if (gd->data[yy] != NULL)
			xfree(gd->data[yy]);
d125 1
a125 9
	if (gd->udata != NULL)
		xfree(gd->udata);
	if (gd->usize != NULL)
		xfree(gd->usize);

	if (gd->data != NULL)
		xfree(gd->data);
	if (gd->size != NULL)
		xfree(gd->size);
d134 1
d143 3
a145 1
		if (ga->size[yy] != gb->size[yy])
d148 2
a149 2
			gca = &ga->data[yy][xx];
			gcb = &gb->data[yy][xx];
d154 2
a155 2
			gua = &ga->udata[yy][xx];
			gub = &gb->udata[yy][xx];
d184 2
a185 9
	gd->size = xrealloc(gd->size, yy + 1, sizeof *gd->size);
	gd->size[yy] = 0;
	gd->data = xrealloc(gd->data, yy + 1, sizeof *gd->data);
	gd->data[yy] = NULL;

	gd->usize = xrealloc(gd->usize, yy + 1, sizeof *gd->usize);
	gd->usize[yy] = 0;
	gd->udata = xrealloc(gd->udata, yy + 1, sizeof *gd->udata);
	gd->udata[yy] = NULL;
d194 2
a195 1
	u_int	xx;
d197 2
a198 1
	if (sx <= gd->size[py])
d201 2
a202 2
	gd->data[py] = xrealloc(gd->data[py], sx, sizeof **gd->data);
	for (xx = gd->size[py]; xx < sx; xx++)
d204 1
a204 1
	gd->size[py] = sx;
d211 4
a214 1
	if (sx <= gd->usize[py])
d217 2
a218 2
	gd->udata[py] = xrealloc(gd->udata[py], sx, sizeof **gd->udata);
	gd->usize[py] = sx;
d230 1
a230 1
	if (px >= gd->size[py])
d232 1
a232 1
	return (&gd->data[py][px]);
d245 1
a245 1
	return (&gd->data[py][px]);
d271 1
a271 1
	if (px >= gd->usize[py])
d273 1
a273 1
	return (&gd->udata[py][px]);
d286 1
a286 1
	return (&gd->udata[py][px]);
d333 1
a333 1
			if (xx >= gd->size[yy])
d344 2
a345 1
	u_int	yy;
d358 6
a363 10
		if (gd->data[yy] != NULL) {
			xfree(gd->data[yy]);
			gd->data[yy] = NULL;
			gd->size[yy] = 0;
		}
		if (gd->udata[yy] != NULL) {
			xfree(gd->udata[yy]);
			gd->udata[yy] = NULL;
			gd->usize[yy] = 0;
		}
d394 2
a395 5
	memmove(&gd->data[dy], &gd->data[py], ny * (sizeof *gd->data));
	memmove(&gd->size[dy], &gd->size[py], ny * (sizeof *gd->size));

	memmove(&gd->udata[dy], &gd->udata[py], ny * (sizeof *gd->udata));
	memmove(&gd->usize[dy], &gd->usize[py], ny * (sizeof *gd->usize));
d401 1
a401 4
		gd->data[yy] = NULL;
		gd->size[yy] = 0;
		gd->udata[yy] = NULL;
		gd->usize[yy] = 0;
d409 2
a410 1
	u_int	xx;
d425 1
d429 2
a430 1
	memmove(&gd->data[py][dx], &gd->data[py][px], nx * (sizeof **gd->data));
d432 1
a432 1
	if (gd->udata[py] != NULL) {
d435 2
a436 2
		memmove(&gd->udata[py][dx],
		    &gd->udata[py][px], nx * (sizeof **gd->udata));
d505 2
a506 1
	u_int	yy;
d517 9
a525 8
		dst->size[dy] = src->size[sy];
		if (src->size[sy] == 0)
			dst->data[dy] = NULL;
		else {
			dst->data[dy] = xcalloc(
			    src->size[sy], sizeof **dst->data);
			memcpy(dst->data[dy], src->data[sy],
			    src->size[sy] * (sizeof **dst->data));
d527 5
a531 9

		dst->usize[dy] = src->usize[sy];
		if (src->usize[sy] == 0)
			dst->udata[dy] = NULL;
		else {
			dst->udata[dy] = xcalloc(
			    src->usize[sy], sizeof **dst->udata);
			memcpy(dst->udata[dy], src->udata[sy],
			    src->usize[sy] * (sizeof **dst->udata));
d534 2
a535 1
		sy++; dy++;
@


1.8
log
@Typo in grid_duplicate_lines (sy for dy) causing it to write into the wrong
place when copying UTF-8 data. Found by Dan Colish.
@
text
@d1 1
a1 1
/* $OpenBSD: grid.c,v 1.7 2009/07/13 10:43:52 nicm Exp $ */
a199 14
}

/* Reduce line to fit to cell. */
void
grid_reduce_line(struct grid *gd, u_int py, u_int sx)
{
	if (sx < gd->size[py]) {
		gd->data[py] = xrealloc(gd->data[py], sx, sizeof **gd->data);
		gd->size[py] = sx;
	}
	if (sx < gd->usize[py]) {
		gd->udata[py] = xrealloc(gd->udata[py], sx, sizeof **gd->udata);
		gd->usize[py] = sx;
	}
@


1.7
log
@Support "alternate screen" mode (terminfo smcup/rmcup) typically used by full
screen interactive programs to preserve the screen contents. When activated, it
saves a copy of the visible grid and disables scrolling into and resizing out
of the history; when deactivated the visible data is restored and the history
reenabled.
@
text
@d1 1
a1 1
/* $OpenBSD: grid.c,v 1.6 2009/07/11 20:11:18 nicm Exp $ */
d557 1
a557 1
			dst->udata[sy] = xcalloc(
@


1.6
log
@Limit the history to hlimit not hlimit - 1. This makes a history-limit setting
of 0 work as expected.
@
text
@d1 1
a1 1
/* $OpenBSD: grid.c,v 1.5 2009/06/25 06:15:04 nicm Exp $ */
d98 2
d521 44
@


1.5
log
@Miscellaneous unused functions, including one which was basically a
duplicate. Found by lint.
@
text
@d1 1
a1 1
/* $OpenBSD: grid.c,v 1.4 2009/06/24 22:49:56 nicm Exp $ */
d175 1
a175 1
	if (gd->hsize >= gd->hlimit - 1) {
@


1.4
log
@Change find-window and monitor-content to use fnmatch(3). For convenience and
compatibility, *s are implicitly added at the start and end of the pattern.

Also display the line number and the entire line in the results, and lose the
nasty section_string function and the now empty util.c file.

Initially from Tiago Cunha.
@
text
@d1 1
a1 1
/* $OpenBSD: grid.c,v 1.3 2009/06/24 22:04:18 nicm Exp $ */
a429 25
	}
}

/* Clear a group of cells. */
void
grid_clear_cells(struct grid *gd, u_int px, u_int py, u_int nx)
{
	u_int	xx;

 	GRID_DEBUG(gd, "px=%u, py=%u, nx=%u", px, py, nx);

	if (nx == 0)
		return;

	if (grid_check_x(gd, px) != 0)
		return;
	if (grid_check_x(gd, px + nx - 1) != 0)
		return;
	if (grid_check_y(gd, py) != 0)
		return;

	for (xx = px; xx < px + nx; xx++) {
		if (xx >= gd->size[py])
			break;
		grid_put_cell(gd, xx, py, &grid_default_cell);
@


1.3
log
@Add a dedicated function to convert a line into a string and use it to simplify the search window function.
@
text
@d1 1
a1 1
/* $OpenBSD: grid.c,v 1.2 2009/06/05 03:13:16 ray Exp $ */
d505 1
a505 1
	u_int			 xx;
d525 5
a529 4
			memcpy(buf + off, gu->data, UTF8_SIZE);
			off += UTF8_SIZE;
			while (off > 0 && ((u_char) buf[off]) == 0xff)
				off--;
d539 3
a541 1

@


1.2
log
@Remove trailing newlines, spaces, and tabs.

No binary change.
@
text
@d1 1
a1 1
/* $OpenBSD: grid.c,v 1.1 2009/06/01 22:58:49 nicm Exp $ */
d495 46
@


1.1
log
@Import tmux, a terminal multiplexor allowing (among other things) a single
terminal to be switched between several different windows and programs
displayed on one terminal be detached from one terminal and moved to another.

ok deraadt pirofti
@
text
@d1 1
a1 1
/* $OpenBSD$ */
a495 2


@

