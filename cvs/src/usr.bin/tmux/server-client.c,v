head	1.221;
access;
symbols
	OPENBSD_6_1:1.215.0.4
	OPENBSD_6_1_BASE:1.215
	OPENBSD_6_0:1.187.0.2
	OPENBSD_6_0_BASE:1.187
	OPENBSD_5_9:1.181.0.2
	OPENBSD_5_9_BASE:1.181
	OPENBSD_5_8:1.147.0.4
	OPENBSD_5_8_BASE:1.147
	OPENBSD_5_7:1.128.0.2
	OPENBSD_5_7_BASE:1.128
	OPENBSD_5_6:1.122.0.4
	OPENBSD_5_6_BASE:1.122
	OPENBSD_5_5:1.119.0.4
	OPENBSD_5_5_BASE:1.119
	OPENBSD_5_4:1.103.0.2
	OPENBSD_5_4_BASE:1.103
	OPENBSD_5_3:1.84.0.2
	OPENBSD_5_3_BASE:1.84
	OPENBSD_5_2:1.78.0.2
	OPENBSD_5_2_BASE:1.78
	OPENBSD_5_1_BASE:1.67
	OPENBSD_5_1:1.67.0.2
	OPENBSD_5_0:1.60.0.2
	OPENBSD_5_0_BASE:1.60
	OPENBSD_4_9:1.51.0.2
	OPENBSD_4_9_BASE:1.51
	OPENBSD_4_8:1.37.0.2
	OPENBSD_4_8_BASE:1.37
	OPENBSD_4_7:1.30.0.2
	OPENBSD_4_7_BASE:1.30;
locks; strict;
comment	@ * @;


1.221
date	2017.04.20.15.16.20;	author nicm;	state Exp;
branches;
next	1.220;
commitid	c4UP7Nke7WAketpM;

1.220
date	2017.04.19.14.00.28;	author nicm;	state Exp;
branches;
next	1.219;
commitid	VxIcEJR3Nj27vycD;

1.219
date	2017.04.19.06.52.27;	author nicm;	state Exp;
branches;
next	1.218;
commitid	J75yaiuz8O54rLmn;

1.218
date	2017.04.18.20.37.49;	author nicm;	state Exp;
branches;
next	1.217;
commitid	H0hesL9ipbkTnKO8;

1.217
date	2017.04.17.06.40.32;	author nicm;	state Exp;
branches;
next	1.216;
commitid	VGpPUc11r7Q41gvd;

1.216
date	2017.04.05.10.49.46;	author nicm;	state Exp;
branches;
next	1.215;
commitid	1mjoRYvghWl25dW0;

1.215
date	2017.03.09.22.00.46;	author nicm;	state Exp;
branches;
next	1.214;
commitid	8mD8chzLt8C4BFSn;

1.214
date	2017.03.09.17.06.35;	author nicm;	state Exp;
branches;
next	1.213;
commitid	BJxoAdDkAuPxTBwC;

1.213
date	2017.02.14.18.13.05;	author nicm;	state Exp;
branches;
next	1.212;
commitid	xvcFJuJjtbCqRtLW;

1.212
date	2017.02.09.12.09.33;	author nicm;	state Exp;
branches;
next	1.211;
commitid	R14ylgibGw7VkoGU;

1.211
date	2017.02.08.15.49.29;	author nicm;	state Exp;
branches;
next	1.210;
commitid	9p1dhEKzsTLyX59I;

1.210
date	2017.02.03.11.57.27;	author nicm;	state Exp;
branches;
next	1.209;
commitid	BLRh0qXo7OVTPhiT;

1.209
date	2017.02.01.09.55.07;	author nicm;	state Exp;
branches;
next	1.208;
commitid	FpFenXzt7GohJ3lb;

1.208
date	2017.01.13.11.56.43;	author nicm;	state Exp;
branches;
next	1.207;
commitid	ue6KcgTetKiECTMk;

1.207
date	2017.01.13.10.12.12;	author nicm;	state Exp;
branches;
next	1.206;
commitid	bQ0icVBejLnBpF27;

1.206
date	2017.01.11.22.36.07;	author nicm;	state Exp;
branches;
next	1.205;
commitid	HtCLmxuVeKiLFIZu;

1.205
date	2016.12.07.09.16.13;	author nicm;	state Exp;
branches;
next	1.204;
commitid	0eoQrc7lxznhLrSz;

1.204
date	2016.11.24.18.45.45;	author nicm;	state Exp;
branches;
next	1.203;
commitid	hrLdEAZgp94v5471;

1.203
date	2016.11.24.14.38.55;	author nicm;	state Exp;
branches;
next	1.202;
commitid	HqRyVctu2nCnwXHJ;

1.202
date	2016.11.24.13.46.50;	author nicm;	state Exp;
branches;
next	1.201;
commitid	AE4rxCQLpL805vhq;

1.201
date	2016.11.23.17.01.24;	author nicm;	state Exp;
branches;
next	1.200;
commitid	MqQ1xWjJDuKsBsyT;

1.200
date	2016.11.16.11.37.16;	author nicm;	state Exp;
branches;
next	1.199;
commitid	AkKLGtZh82DJ1E5d;

1.199
date	2016.11.15.15.17.28;	author nicm;	state Exp;
branches;
next	1.198;
commitid	thg4UrdurnKYfFrH;

1.198
date	2016.11.15.14.02.32;	author nicm;	state Exp;
branches;
next	1.197;
commitid	DoED1csxpiOGsoJM;

1.197
date	2016.10.19.09.22.07;	author nicm;	state Exp;
branches;
next	1.196;
commitid	leRKiNVAXYb2Wrn1;

1.196
date	2016.10.16.22.06.40;	author nicm;	state Exp;
branches;
next	1.195;
commitid	j0FZs70gSPCmpqWI;

1.195
date	2016.10.16.19.04.05;	author nicm;	state Exp;
branches;
next	1.194;
commitid	pxm6osuE99zELpkU;

1.194
date	2016.10.16.17.55.14;	author nicm;	state Exp;
branches;
next	1.193;
commitid	1xIYFpLYkPIXNEvU;

1.193
date	2016.10.12.13.03.27;	author nicm;	state Exp;
branches;
next	1.192;
commitid	eul7q5vzLp6bFmDk;

1.192
date	2016.10.11.09.30.36;	author nicm;	state Exp;
branches;
next	1.191;
commitid	OThpNjT1frpnaa0G;

1.191
date	2016.10.11.07.23.34;	author nicm;	state Exp;
branches;
next	1.190;
commitid	leUN1UeapgUoieJj;

1.190
date	2016.10.10.21.29.23;	author nicm;	state Exp;
branches;
next	1.189;
commitid	z4Hr4PZF7Ev93uEJ;

1.189
date	2016.10.09.16.24.34;	author nicm;	state Exp;
branches;
next	1.188;
commitid	cy0Wx0yJbsZRARd0;

1.188
date	2016.09.28.08.30.44;	author nicm;	state Exp;
branches;
next	1.187;
commitid	l0DpFzkilFIpFuoD;

1.187
date	2016.06.16.10.55.47;	author nicm;	state Exp;
branches;
next	1.186;
commitid	iwpkepU9NO5jIk1m;

1.186
date	2016.04.30.18.59.02;	author nicm;	state Exp;
branches;
next	1.185;
commitid	WGzrFN9OgQx3k86Y;

1.185
date	2016.04.29.15.00.48;	author nicm;	state Exp;
branches;
next	1.184;
commitid	z5NrpOKjZoYhx6Qr;

1.184
date	2016.04.28.06.51.56;	author nicm;	state Exp;
branches;
next	1.183;
commitid	TUeKlomWXwmJ8SkW;

1.183
date	2016.03.18.07.28.27;	author nicm;	state Exp;
branches;
next	1.182;
commitid	XKqoAZz4Rl0wxJYw;

1.182
date	2016.03.01.12.04.43;	author nicm;	state Exp;
branches;
next	1.181;
commitid	8tE2MJr7RYWnQBde;

1.181
date	2016.01.19.15.59.12;	author nicm;	state Exp;
branches;
next	1.180;
commitid	P3qmSOx6KrDBsb0c;

1.180
date	2015.12.16.21.50.37;	author nicm;	state Exp;
branches;
next	1.179;
commitid	Bam1GajuDZzmKjyE;

1.179
date	2015.12.15.13.43.07;	author nicm;	state Exp;
branches;
next	1.178;
commitid	nxumQwtI4O73Gcjc;

1.178
date	2015.12.12.18.32.24;	author nicm;	state Exp;
branches;
next	1.177;
commitid	q7iDAcShsJWlLYhr;

1.177
date	2015.12.12.18.19.00;	author nicm;	state Exp;
branches;
next	1.176;
commitid	WD2k8ZkBSmp0TV5S;

1.176
date	2015.12.11.12.27.36;	author nicm;	state Exp;
branches;
next	1.175;
commitid	ns7JfXpW9TsHrnT3;

1.175
date	2015.12.08.08.34.18;	author nicm;	state Exp;
branches;
next	1.174;
commitid	MRfGAYPLeVqV46rT;

1.174
date	2015.12.08.01.10.31;	author nicm;	state Exp;
branches;
next	1.173;
commitid	Q7y3PTVPjE0eQDqD;

1.173
date	2015.12.01.09.41.03;	author nicm;	state Exp;
branches;
next	1.172;
commitid	IGwRs3QGOMqAPj6t;

1.172
date	2015.11.23.20.53.09;	author nicm;	state Exp;
branches;
next	1.171;
commitid	erDJx2JIDZWB55Vj;

1.171
date	2015.11.19.22.46.46;	author nicm;	state Exp;
branches;
next	1.170;
commitid	mCtl6P7knl540hRA;

1.170
date	2015.11.18.14.27.44;	author nicm;	state Exp;
branches;
next	1.169;
commitid	RjsAPRkWwvS79w40;

1.169
date	2015.11.14.09.41.06;	author nicm;	state Exp;
branches;
next	1.168;
commitid	FQoND7M2BC89FZoU;

1.168
date	2015.11.12.11.05.34;	author nicm;	state Exp;
branches;
next	1.167;
commitid	Ih1tdqtjpnEyfE8x;

1.167
date	2015.11.11.23.23.33;	author nicm;	state Exp;
branches;
next	1.166;
commitid	UDT9ROGWpISBYjbt;

1.166
date	2015.10.31.13.12.03;	author nicm;	state Exp;
branches;
next	1.165;
commitid	YMQrsd7hfJkvI0rw;

1.165
date	2015.10.31.08.13.58;	author nicm;	state Exp;
branches;
next	1.164;
commitid	B5GekkO0CdWpFMrz;

1.164
date	2015.10.28.09.51.55;	author nicm;	state Exp;
branches;
next	1.163;
commitid	eGVGKzVVYKHFvkn4;

1.163
date	2015.10.27.15.58.42;	author nicm;	state Exp;
branches;
next	1.162;
commitid	89xhQafU35Q5MQVC;

1.162
date	2015.10.27.13.23.24;	author nicm;	state Exp;
branches;
next	1.161;
commitid	g6GdEJXfBNprXHEK;

1.161
date	2015.10.26.23.16.18;	author nicm;	state Exp;
branches;
next	1.160;
commitid	5g48VFdsdgdHn7i6;

1.160
date	2015.10.26.17.17.06;	author nicm;	state Exp;
branches;
next	1.159;
commitid	Lk56WR8dOlvW1M6L;

1.159
date	2015.10.23.23.46.36;	author nicm;	state Exp;
branches;
next	1.158;
commitid	L1c6dIv9AFLcK3Oh;

1.158
date	2015.10.22.11.00.51;	author nicm;	state Exp;
branches;
next	1.157;
commitid	vRBISEJOqoUrYR7q;

1.157
date	2015.10.20.21.12.09;	author nicm;	state Exp;
branches;
next	1.156;
commitid	fVAT1gEydaesyRmS;

1.156
date	2015.10.20.14.19.27;	author nicm;	state Exp;
branches;
next	1.155;
commitid	epDkF9EDpjfzPPh6;

1.155
date	2015.10.18.20.42.43;	author nicm;	state Exp;
branches;
next	1.154;
commitid	nMwmdaY8loLzimxC;

1.154
date	2015.09.16.22.24.54;	author nicm;	state Exp;
branches;
next	1.153;
commitid	GbMuGsUSIjrHMl0R;

1.153
date	2015.09.14.10.25.52;	author nicm;	state Exp;
branches;
next	1.152;
commitid	UTR5DL8aBfSehB3O;

1.152
date	2015.09.01.19.50.09;	author nicm;	state Exp;
branches;
next	1.151;
commitid	qHFBNmcomtnWOK72;

1.151
date	2015.08.30.15.43.40;	author nicm;	state Exp;
branches;
next	1.150;
commitid	uXV0qaBWQpBShfys;

1.150
date	2015.08.29.08.54.41;	author nicm;	state Exp;
branches;
next	1.149;
commitid	aTZI9iHPczxhIdBt;

1.149
date	2015.08.28.13.01.03;	author nicm;	state Exp;
branches;
next	1.148;
commitid	fIVZtZS9F66XgvbR;

1.148
date	2015.08.28.12.16.28;	author nicm;	state Exp;
branches;
next	1.147;
commitid	LqkiQ6rY2EYTPxv3;

1.147
date	2015.07.29.11.56.02;	author nicm;	state Exp;
branches;
next	1.146;
commitid	47sVTxMc5nNTsinQ;

1.146
date	2015.07.17.06.53.47;	author nicm;	state Exp;
branches;
next	1.145;
commitid	hBi8jeen1nKGocNC;

1.145
date	2015.07.13.15.51.31;	author nicm;	state Exp;
branches;
next	1.144;
commitid	FFYcWp5eb58J4GT4;

1.144
date	2015.07.13.15.49.31;	author nicm;	state Exp;
branches;
next	1.143;
commitid	ECzzymgpZWtUKc3b;

1.143
date	2015.06.14.10.07.44;	author nicm;	state Exp;
branches;
next	1.142;
commitid	0pZ95JQFEhIowUtr;

1.142
date	2015.06.05.18.06.30;	author nicm;	state Exp;
branches;
next	1.141;
commitid	31HWw6xUnTEvtfY4;

1.141
date	2015.06.05.18.01.12;	author nicm;	state Exp;
branches;
next	1.140;
commitid	38CNdOauYnpJlZqC;

1.140
date	2015.06.04.23.27.51;	author nicm;	state Exp;
branches;
next	1.139;
commitid	xevJfLLQ14ORIsEv;

1.139
date	2015.05.27.13.28.04;	author nicm;	state Exp;
branches;
next	1.138;
commitid	jNiCCHdN1zYsiWiL;

1.138
date	2015.05.08.15.56.49;	author nicm;	state Exp;
branches;
next	1.137;
commitid	0BlK2lEeHj5kSq2J;

1.137
date	2015.05.06.07.52.06;	author nicm;	state Exp;
branches;
next	1.136;
commitid	QsYIHO7vmkeMFepO;

1.136
date	2015.04.25.18.33.59;	author nicm;	state Exp;
branches;
next	1.135;
commitid	R776bB84r7VPzyws;

1.135
date	2015.04.24.23.17.11;	author nicm;	state Exp;
branches;
next	1.134;
commitid	iy4fcaIoXzxOx84I;

1.134
date	2015.04.22.15.30.11;	author nicm;	state Exp;
branches;
next	1.133;
commitid	0bmlELm9krdoS6OB;

1.133
date	2015.04.21.15.21.41;	author nicm;	state Exp;
branches;
next	1.132;
commitid	cdlRUhzXG2wYIDxB;

1.132
date	2015.04.20.15.34.56;	author nicm;	state Exp;
branches;
next	1.131;
commitid	1fc4pMkRD7YjyQWP;

1.131
date	2015.04.19.21.34.21;	author nicm;	state Exp;
branches;
next	1.130;
commitid	wug6ctIOfhVMeWQp;

1.130
date	2015.04.19.21.05.27;	author nicm;	state Exp;
branches;
next	1.129;
commitid	ksfuI8mTVk7XPyr3;

1.129
date	2015.03.31.17.45.10;	author nicm;	state Exp;
branches;
next	1.128;
commitid	2uQloBaX92ri1PyE;

1.128
date	2015.02.06.17.17.12;	author nicm;	state Exp;
branches;
next	1.127;
commitid	FDGZsRpFLdjKzcJu;

1.127
date	2015.02.01.23.43.23;	author nicm;	state Exp;
branches;
next	1.126;
commitid	dy3XCJyolFNoNYim;

1.126
date	2014.10.22.23.18.53;	author nicm;	state Exp;
branches;
next	1.125;
commitid	eFDptKeckheZa4ap;

1.125
date	2014.10.02.09.31.30;	author nicm;	state Exp;
branches;
next	1.124;
commitid	P5YzAeVwYWH5oESm;

1.124
date	2014.09.01.21.50.18;	author nicm;	state Exp;
branches;
next	1.123;
commitid	yvK8NJvd2XzXhKku;

1.123
date	2014.08.09.07.33.37;	author nicm;	state Exp;
branches;
next	1.122;
commitid	EaH1ezsTMWHeIyGh;

1.122
date	2014.07.13.20.51.08;	author krw;	state Exp;
branches;
next	1.121;
commitid	w5uWmngrpmxyyxKN;

1.121
date	2014.07.13.20.23.10;	author nicm;	state Exp;
branches;
next	1.120;
commitid	gU0Apyo9TAs3ZY1M;

1.120
date	2014.04.16.08.02.31;	author nicm;	state Exp;
branches;
next	1.119;

1.119
date	2014.02.23.00.53.06;	author nicm;	state Exp;
branches;
next	1.118;

1.118
date	2014.02.17.22.42.20;	author nicm;	state Exp;
branches;
next	1.117;

1.117
date	2014.02.14.14.00.18;	author nicm;	state Exp;
branches;
next	1.116;

1.116
date	2014.02.14.13.59.01;	author nicm;	state Exp;
branches;
next	1.115;

1.115
date	2014.01.31.14.19.24;	author nicm;	state Exp;
branches;
next	1.114;

1.114
date	2013.11.13.20.43.37;	author benno;	state Exp;
branches;
next	1.113;

1.113
date	2013.10.20.17.28.43;	author nicm;	state Exp;
branches;
next	1.112;

1.112
date	2013.10.11.08.07.12;	author nicm;	state Exp;
branches;
next	1.111;

1.111
date	2013.10.10.12.29.35;	author nicm;	state Exp;
branches;
next	1.110;

1.110
date	2013.10.10.12.27.38;	author nicm;	state Exp;
branches;
next	1.109;

1.109
date	2013.10.10.12.26.36;	author nicm;	state Exp;
branches;
next	1.108;

1.108
date	2013.10.10.12.13.56;	author nicm;	state Exp;
branches;
next	1.107;

1.107
date	2013.10.10.12.13.29;	author nicm;	state Exp;
branches;
next	1.106;

1.106
date	2013.10.10.12.12.54;	author nicm;	state Exp;
branches;
next	1.105;

1.105
date	2013.10.10.12.12.08;	author nicm;	state Exp;
branches;
next	1.104;

1.104
date	2013.10.10.11.49.07;	author nicm;	state Exp;
branches;
next	1.103;

1.103
date	2013.06.23.13.10.46;	author nicm;	state Exp;
branches;
next	1.102;

1.102
date	2013.06.23.12.51.28;	author nicm;	state Exp;
branches;
next	1.101;

1.101
date	2013.04.21.21.32.00;	author nicm;	state Exp;
branches;
next	1.100;

1.100
date	2013.04.10.11.51.16;	author nicm;	state Exp;
branches;
next	1.99;

1.99
date	2013.03.27.11.17.12;	author nicm;	state Exp;
branches;
next	1.98;

1.98
date	2013.03.25.11.53.54;	author nicm;	state Exp;
branches;
next	1.97;

1.97
date	2013.03.25.11.36.59;	author nicm;	state Exp;
branches;
next	1.96;

1.96
date	2013.03.25.10.03.24;	author nicm;	state Exp;
branches;
next	1.95;

1.95
date	2013.03.24.09.57.59;	author nicm;	state Exp;
branches;
next	1.94;

1.94
date	2013.03.24.09.54.10;	author nicm;	state Exp;
branches;
next	1.93;

1.93
date	2013.03.24.09.28.59;	author nicm;	state Exp;
branches;
next	1.92;

1.92
date	2013.03.24.09.25.04;	author nicm;	state Exp;
branches;
next	1.91;

1.91
date	2013.03.24.09.18.16;	author nicm;	state Exp;
branches;
next	1.90;

1.90
date	2013.03.22.15.54.29;	author nicm;	state Exp;
branches;
next	1.89;

1.89
date	2013.03.22.15.50.42;	author nicm;	state Exp;
branches;
next	1.88;

1.88
date	2013.03.22.15.49.55;	author nicm;	state Exp;
branches;
next	1.87;

1.87
date	2013.03.22.10.31.22;	author nicm;	state Exp;
branches;
next	1.86;

1.86
date	2013.03.21.18.47.01;	author nicm;	state Exp;
branches;
next	1.85;

1.85
date	2013.03.21.16.14.09;	author nicm;	state Exp;
branches;
next	1.84;

1.84
date	2013.01.30.17.00.17;	author nicm;	state Exp;
branches;
next	1.83;

1.83
date	2013.01.18.02.10.29;	author nicm;	state Exp;
branches;
next	1.82;

1.82
date	2013.01.15.22.55.29;	author nicm;	state Exp;
branches;
next	1.81;

1.81
date	2012.10.26.14.35.42;	author nicm;	state Exp;
branches;
next	1.80;

1.80
date	2012.09.27.10.02.56;	author nicm;	state Exp;
branches;
next	1.79;

1.79
date	2012.09.03.09.32.38;	author nicm;	state Exp;
branches;
next	1.78;

1.78
date	2012.07.11.07.10.15;	author nicm;	state Exp;
branches;
next	1.77;

1.77
date	2012.07.10.11.53.01;	author nicm;	state Exp;
branches;
next	1.76;

1.76
date	2012.06.20.12.55.55;	author nicm;	state Exp;
branches;
next	1.75;

1.75
date	2012.06.18.13.16.42;	author nicm;	state Exp;
branches;
next	1.74;

1.74
date	2012.05.22.14.32.28;	author nicm;	state Exp;
branches;
next	1.73;

1.73
date	2012.05.21.18.27.42;	author nicm;	state Exp;
branches;
next	1.72;

1.72
date	2012.05.06.07.38.17;	author nicm;	state Exp;
branches;
next	1.71;

1.71
date	2012.04.11.06.16.14;	author nicm;	state Exp;
branches;
next	1.70;

1.70
date	2012.03.17.21.34.34;	author nicm;	state Exp;
branches;
next	1.69;

1.69
date	2012.03.17.18.24.07;	author nicm;	state Exp;
branches;
next	1.68;

1.68
date	2012.03.09.21.42.13;	author nicm;	state Exp;
branches;
next	1.67;

1.67
date	2012.02.02.00.04.54;	author nicm;	state Exp;
branches;
next	1.66;

1.66
date	2012.01.29.09.37.02;	author nicm;	state Exp;
branches;
next	1.65;

1.65
date	2012.01.29.02.22.11;	author nicm;	state Exp;
branches;
next	1.64;

1.64
date	2012.01.21.23.51.34;	author nicm;	state Exp;
branches;
next	1.63;

1.63
date	2012.01.21.08.40.09;	author nicm;	state Exp;
branches;
next	1.62;

1.62
date	2011.12.24.08.26.59;	author nicm;	state Exp;
branches;
next	1.61;

1.61
date	2011.08.20.20.37.30;	author nicm;	state Exp;
branches;
next	1.60;

1.60
date	2011.07.08.21.51.40;	author nicm;	state Exp;
branches;
next	1.59;

1.59
date	2011.05.20.19.03.58;	author nicm;	state Exp;
branches;
next	1.58;

1.58
date	2011.05.08.20.45.35;	author nicm;	state Exp;
branches;
next	1.57;

1.57
date	2011.05.08.20.34.12;	author nicm;	state Exp;
branches;
next	1.56;

1.56
date	2011.05.04.18.10.28;	author nicm;	state Exp;
branches;
next	1.55;

1.55
date	2011.05.04.17.40.32;	author nicm;	state Exp;
branches;
next	1.54;

1.54
date	2011.04.19.21.31.33;	author nicm;	state Exp;
branches;
next	1.53;

1.53
date	2011.04.18.19.49.05;	author nicm;	state Exp;
branches;
next	1.52;

1.52
date	2011.03.29.19.30.16;	author nicm;	state Exp;
branches;
next	1.51;

1.51
date	2011.01.26.01.54.56;	author nicm;	state Exp;
branches;
next	1.50;

1.50
date	2011.01.15.00.46.19;	author nicm;	state Exp;
branches;
next	1.49;

1.49
date	2011.01.08.01.52.36;	author nicm;	state Exp;
branches;
next	1.48;

1.48
date	2011.01.03.23.35.21;	author nicm;	state Exp;
branches;
next	1.47;

1.47
date	2011.01.01.01.12.09;	author nicm;	state Exp;
branches;
next	1.46;

1.46
date	2010.12.29.21.49.06;	author nicm;	state Exp;
branches;
next	1.45;

1.45
date	2010.12.20.00.17.22;	author nicm;	state Exp;
branches;
next	1.44;

1.44
date	2010.12.11.18.39.25;	author nicm;	state Exp;
branches;
next	1.43;

1.43
date	2010.12.11.16.05.57;	author nicm;	state Exp;
branches;
next	1.42;

1.42
date	2010.10.16.08.31.55;	author nicm;	state Exp;
branches;
next	1.41;

1.41
date	2010.09.26.20.43.30;	author nicm;	state Exp;
branches;
next	1.40;

1.40
date	2010.08.31.22.46.59;	author nicm;	state Exp;
branches;
next	1.39;

1.39
date	2010.08.19.17.20.26;	author nicm;	state Exp;
branches;
next	1.38;

1.38
date	2010.08.11.07.34.43;	author nicm;	state Exp;
branches;
next	1.37;

1.37
date	2010.07.28.22.15.15;	author nicm;	state Exp;
branches
	1.37.2.1;
next	1.36;

1.36
date	2010.07.24.20.11.59;	author nicm;	state Exp;
branches;
next	1.35;

1.35
date	2010.07.19.18.27.38;	author nicm;	state Exp;
branches;
next	1.34;

1.34
date	2010.07.11.17.06.45;	author nicm;	state Exp;
branches;
next	1.33;

1.33
date	2010.06.28.22.10.42;	author nicm;	state Exp;
branches;
next	1.32;

1.32
date	2010.06.05.16.47.11;	author nicm;	state Exp;
branches;
next	1.31;

1.31
date	2010.05.23.19.42.19;	author nicm;	state Exp;
branches;
next	1.30;

1.30
date	2010.02.06.22.55.31;	author nicm;	state Exp;
branches;
next	1.29;

1.29
date	2010.02.06.18.47.41;	author nicm;	state Exp;
branches;
next	1.28;

1.28
date	2010.01.08.09.14.15;	author nicm;	state Exp;
branches;
next	1.27;

1.27
date	2010.01.03.12.51.05;	author nicm;	state Exp;
branches;
next	1.26;

1.26
date	2009.12.10.09.16.52;	author nicm;	state Exp;
branches;
next	1.25;

1.25
date	2009.12.03.22.50.10;	author nicm;	state Exp;
branches;
next	1.24;

1.24
date	2009.11.26.21.37.13;	author nicm;	state Exp;
branches;
next	1.23;

1.23
date	2009.11.19.16.22.10;	author nicm;	state Exp;
branches;
next	1.22;

1.22
date	2009.11.19.10.22.06;	author nicm;	state Exp;
branches;
next	1.21;

1.21
date	2009.11.18.13.16.33;	author nicm;	state Exp;
branches;
next	1.20;

1.20
date	2009.11.13.18.13.18;	author nicm;	state Exp;
branches;
next	1.19;

1.19
date	2009.11.11.08.00.42;	author nicm;	state Exp;
branches;
next	1.18;

1.18
date	2009.11.05.08.45.08;	author nicm;	state Exp;
branches;
next	1.17;

1.17
date	2009.11.05.00.05.00;	author nicm;	state Exp;
branches;
next	1.16;

1.16
date	2009.11.04.23.42.51;	author nicm;	state Exp;
branches;
next	1.15;

1.15
date	2009.11.04.23.29.42;	author nicm;	state Exp;
branches;
next	1.14;

1.14
date	2009.11.04.23.12.43;	author nicm;	state Exp;
branches;
next	1.13;

1.13
date	2009.11.04.21.47.42;	author nicm;	state Exp;
branches;
next	1.12;

1.12
date	2009.11.04.20.50.11;	author nicm;	state Exp;
branches;
next	1.11;

1.11
date	2009.11.03.22.40.40;	author nicm;	state Exp;
branches;
next	1.10;

1.10
date	2009.11.03.20.29.47;	author nicm;	state Exp;
branches;
next	1.9;

1.9
date	2009.10.27.13.03.33;	author nicm;	state Exp;
branches;
next	1.8;

1.8
date	2009.10.26.21.42.04;	author deraadt;	state Exp;
branches;
next	1.7;

1.7
date	2009.10.26.20.47.00;	author nicm;	state Exp;
branches;
next	1.6;

1.6
date	2009.10.25.22.00.15;	author nicm;	state Exp;
branches;
next	1.5;

1.5
date	2009.10.25.21.11.21;	author nicm;	state Exp;
branches;
next	1.4;

1.4
date	2009.10.25.17.51.07;	author nicm;	state Exp;
branches;
next	1.3;

1.3
date	2009.10.22.21.01.52;	author nicm;	state Exp;
branches;
next	1.2;

1.2
date	2009.10.22.20.04.21;	author nicm;	state Exp;
branches;
next	1.1;

1.1
date	2009.10.22.19.41.51;	author nicm;	state Exp;
branches;
next	;

1.37.2.1
date	2010.10.02.03.06.00;	author william;	state Exp;
branches;
next	;


desc
@@


1.221
log
@Only set up a current target for mouse key bindings. Fixes:

	bind q select-pane -U \; resize-pane -Z

(There is still some possible weirdness with the way we do current
targets, it should probably be done in a different way at some point.)
@
text
@/* $OpenBSD: server-client.c,v 1.220 2017/04/19 14:00:28 nicm Exp $ */

/*
 * Copyright (c) 2009 Nicholas Marriott <nicholas.marriott@@gmail.com>
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF MIND, USE, DATA OR PROFITS, WHETHER
 * IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING
 * OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */

#include <sys/types.h>
#include <sys/ioctl.h>
#include <sys/uio.h>

#include <errno.h>
#include <event.h>
#include <fcntl.h>
#include <imsg.h>
#include <paths.h>
#include <stdlib.h>
#include <string.h>
#include <time.h>
#include <unistd.h>

#include "tmux.h"

static void	server_client_free(int, short, void *);
static void	server_client_check_focus(struct window_pane *);
static void	server_client_check_resize(struct window_pane *);
static key_code	server_client_check_mouse(struct client *);
static void	server_client_repeat_timer(int, short, void *);
static void	server_client_click_timer(int, short, void *);
static void	server_client_check_exit(struct client *);
static void	server_client_check_redraw(struct client *);
static void	server_client_set_title(struct client *);
static void	server_client_reset_state(struct client *);
static int	server_client_assume_paste(struct session *);

static void	server_client_dispatch(struct imsg *, void *);
static void	server_client_dispatch_command(struct client *, struct imsg *);
static void	server_client_dispatch_identify(struct client *, struct imsg *);
static void	server_client_dispatch_shell(struct client *);

/* Identify mode callback. */
static void
server_client_callback_identify(__unused int fd, __unused short events, void *data)
{
	server_client_clear_identify(data, NULL);
}

/* Set identify mode on client. */
void
server_client_set_identify(struct client *c)
{
	struct timeval	tv;
	int		delay;

	delay = options_get_number(c->session->options, "display-panes-time");
	tv.tv_sec = delay / 1000;
	tv.tv_usec = (delay % 1000) * 1000L;

	if (event_initialized(&c->identify_timer))
		evtimer_del(&c->identify_timer);
	evtimer_set(&c->identify_timer, server_client_callback_identify, c);
	evtimer_add(&c->identify_timer, &tv);

	c->flags |= CLIENT_IDENTIFY;
	c->tty.flags |= (TTY_FREEZE|TTY_NOCURSOR);
	server_redraw_client(c);
}

/* Clear identify mode on client. */
void
server_client_clear_identify(struct client *c, struct window_pane *wp)
{
	if (~c->flags & CLIENT_IDENTIFY)
		return;
	c->flags &= ~CLIENT_IDENTIFY;

	if (c->identify_callback != NULL)
		c->identify_callback(c, wp);

	c->tty.flags &= ~(TTY_FREEZE|TTY_NOCURSOR);
	server_redraw_client(c);
}

/* Check if this client is inside this server. */
int
server_client_check_nested(struct client *c)
{
	struct environ_entry	*envent;
	struct window_pane	*wp;

	envent = environ_find(c->environ, "TMUX");
	if (envent == NULL || *envent->value == '\0')
		return (0);

	RB_FOREACH(wp, window_pane_tree, &all_window_panes) {
		if (strcmp(wp->tty, c->ttyname) == 0)
			return (1);
	}
	return (0);
}

/* Set client key table. */
void
server_client_set_key_table(struct client *c, const char *name)
{
	if (name == NULL)
		name = server_client_get_key_table(c);

	key_bindings_unref_table(c->keytable);
	c->keytable = key_bindings_get_table(name, 1);
	c->keytable->references++;
}

/* Get default key table. */
const char *
server_client_get_key_table(struct client *c)
{
	struct session	*s = c->session;
	const char	*name;

	if (s == NULL)
		return ("root");

	name = options_get_string(s->options, "key-table");
	if (*name == '\0')
		return ("root");
	return (name);
}

/* Is this client using the default key table? */
int
server_client_is_default_key_table(struct client *c)
{
	return (strcmp(c->keytable->name, server_client_get_key_table(c)) == 0);
}

/* Create a new client. */
void
server_client_create(int fd)
{
	struct client	*c;

	setblocking(fd, 0);

	c = xcalloc(1, sizeof *c);
	c->references = 1;
	c->peer = proc_add_peer(server_proc, fd, server_client_dispatch, c);

	if (gettimeofday(&c->creation_time, NULL) != 0)
		fatal("gettimeofday failed");
	memcpy(&c->activity_time, &c->creation_time, sizeof c->activity_time);

	c->environ = environ_create();

	c->fd = -1;
	c->cwd = NULL;

	TAILQ_INIT(&c->queue);

	c->stdin_data = evbuffer_new();
	c->stdout_data = evbuffer_new();
	c->stderr_data = evbuffer_new();

	c->tty.fd = -1;
	c->title = NULL;

	c->session = NULL;
	c->last_session = NULL;
	c->tty.sx = 80;
	c->tty.sy = 24;

	screen_init(&c->status, c->tty.sx, 1, 0);

	c->message_string = NULL;
	TAILQ_INIT(&c->message_log);

	c->prompt_string = NULL;
	c->prompt_buffer = NULL;
	c->prompt_index = 0;

	c->flags |= CLIENT_FOCUSED;

	c->keytable = key_bindings_get_table("root", 1);
	c->keytable->references++;

	evtimer_set(&c->repeat_timer, server_client_repeat_timer, c);
	evtimer_set(&c->click_timer, server_client_click_timer, c);

	TAILQ_INSERT_TAIL(&clients, c, entry);
	log_debug("new client %p", c);
}

/* Open client terminal if needed. */
int
server_client_open(struct client *c, char **cause)
{
	if (c->flags & CLIENT_CONTROL)
		return (0);

	if (strcmp(c->ttyname, "/dev/tty") == 0) {
		*cause = xstrdup("can't use /dev/tty");
		return (-1);
	}

	if (!(c->flags & CLIENT_TERMINAL)) {
		*cause = xstrdup("not a terminal");
		return (-1);
	}

	if (tty_open(&c->tty, cause) != 0)
		return (-1);

	return (0);
}

/* Lost a client. */
void
server_client_lost(struct client *c)
{
	struct message_entry	*msg, *msg1;

	c->flags |= CLIENT_DEAD;

	server_client_clear_identify(c, NULL);
	status_prompt_clear(c);
	status_message_clear(c);

	if (c->stdin_callback != NULL)
		c->stdin_callback(c, 1, c->stdin_callback_data);

	TAILQ_REMOVE(&clients, c, entry);
	log_debug("lost client %p", c);

	/*
	 * If CLIENT_TERMINAL hasn't been set, then tty_init hasn't been called
	 * and tty_free might close an unrelated fd.
	 */
	if (c->flags & CLIENT_TERMINAL)
		tty_free(&c->tty);
	free(c->ttyname);
	free(c->term);

	evbuffer_free(c->stdin_data);
	evbuffer_free(c->stdout_data);
	if (c->stderr_data != c->stdout_data)
		evbuffer_free(c->stderr_data);

	if (event_initialized(&c->status_timer))
		evtimer_del(&c->status_timer);
	screen_free(&c->status);

	free(c->title);
	free((void *)c->cwd);

	evtimer_del(&c->repeat_timer);
	evtimer_del(&c->click_timer);

	key_bindings_unref_table(c->keytable);

	if (event_initialized(&c->identify_timer))
		evtimer_del(&c->identify_timer);

	free(c->message_string);
	if (event_initialized(&c->message_timer))
		evtimer_del(&c->message_timer);
	TAILQ_FOREACH_SAFE(msg, &c->message_log, entry, msg1) {
		free(msg->msg);
		TAILQ_REMOVE(&c->message_log, msg, entry);
		free(msg);
	}

	free(c->prompt_string);
	free(c->prompt_buffer);

	environ_free(c->environ);

	proc_remove_peer(c->peer);
	c->peer = NULL;

	server_client_unref(c);

	server_add_accept(0); /* may be more file descriptors now */

	recalculate_sizes();
	server_check_unattached();
	server_update_socket();
}

/* Remove reference from a client. */
void
server_client_unref(struct client *c)
{
	log_debug("unref client %p (%d references)", c, c->references);

	c->references--;
	if (c->references == 0)
		event_once(-1, EV_TIMEOUT, server_client_free, c, NULL);
}

/* Free dead client. */
static void
server_client_free(__unused int fd, __unused short events, void *arg)
{
	struct client	*c = arg;

	log_debug("free client %p (%d references)", c, c->references);

	if (!TAILQ_EMPTY(&c->queue))
		fatalx("queue not empty");

	if (c->references == 0) {
		free((void *)c->name);
		free(c);
	}
}

/* Suspend a client. */
void
server_client_suspend(struct client *c)
{
	struct session  *s = c->session;

	if (s == NULL || (c->flags & CLIENT_DETACHING))
		return;

	tty_stop_tty(&c->tty);
	c->flags |= CLIENT_SUSPENDED;
	proc_send(c->peer, MSG_SUSPEND, -1, NULL, 0);
}

/* Detach a client. */
void
server_client_detach(struct client *c, enum msgtype msgtype)
{
	struct session  *s = c->session;

	if (s == NULL || (c->flags & CLIENT_DETACHING))
		return;

	c->flags |= CLIENT_DETACHING;
	notify_client("client-detached", c);
	proc_send_s(c->peer, msgtype, s->name);
}

/* Execute command to replace a client. */
void
server_client_exec(struct client *c, const char *cmd)
{
	struct session	*s = c->session;
	char		*msg;
	const char	*shell;
	size_t		 cmdsize, shellsize;

	if (*cmd == '\0')
		return;
	cmdsize = strlen(cmd) + 1;

	if (s != NULL)
		shell = options_get_string(s->options, "default-shell");
	else
		shell = options_get_string(global_s_options, "default-shell");
	shellsize = strlen(shell) + 1;

	msg = xmalloc(cmdsize + shellsize);
	memcpy(msg, cmd, cmdsize);
	memcpy(msg + cmdsize, shell, shellsize);

	proc_send(c->peer, MSG_EXEC, -1, msg, cmdsize + shellsize);
	free(msg);
}

/* Check for mouse keys. */
static key_code
server_client_check_mouse(struct client *c)
{
	struct session		*s = c->session;
	struct mouse_event	*m = &c->tty.mouse;
	struct window		*w;
	struct window_pane	*wp;
	u_int			 x, y, b;
	int			 flag;
	key_code		 key;
	struct timeval		 tv;
	enum { NOTYPE, MOVE, DOWN, UP, DRAG, WHEEL, DOUBLE, TRIPLE } type;
	enum { NOWHERE, PANE, STATUS, BORDER } where;

	type = NOTYPE;
	where = NOWHERE;

	log_debug("mouse %02x at %u,%u (last %u,%u) (%d)", m->b, m->x, m->y,
	    m->lx, m->ly, c->tty.mouse_drag_flag);

	/* What type of event is this? */
	if ((m->sgr_type != ' ' &&
	    MOUSE_DRAG(m->sgr_b) &&
	    MOUSE_BUTTONS(m->sgr_b) == 3) ||
	    (m->sgr_type == ' ' &&
	    MOUSE_DRAG(m->b) &&
	    MOUSE_BUTTONS(m->b) == 3 &&
	    MOUSE_BUTTONS(m->lb) == 3)) {
		type = MOVE;
		x = m->x, y = m->y, b = 0;
		log_debug("move at %u,%u", x, y);
	} else if (MOUSE_DRAG(m->b)) {
		type = DRAG;
		if (c->tty.mouse_drag_flag) {
			x = m->x, y = m->y, b = m->b;
			log_debug("drag update at %u,%u", x, y);
		} else {
			x = m->lx, y = m->ly, b = m->lb;
			log_debug("drag start at %u,%u", x, y);
		}
	} else if (MOUSE_WHEEL(m->b)) {
		type = WHEEL;
		x = m->x, y = m->y, b = m->b;
		log_debug("wheel at %u,%u", x, y);
	} else if (MOUSE_RELEASE(m->b)) {
		type = UP;
		x = m->x, y = m->y, b = m->lb;
		log_debug("up at %u,%u", x, y);
	} else {
		if (c->flags & CLIENT_DOUBLECLICK) {
			evtimer_del(&c->click_timer);
			c->flags &= ~CLIENT_DOUBLECLICK;
			if (m->b == c->click_button) {
				type = DOUBLE;
				x = m->x, y = m->y, b = m->b;
				log_debug("double-click at %u,%u", x, y);
				flag = CLIENT_TRIPLECLICK;
				goto add_timer;
			}
		} else if (c->flags & CLIENT_TRIPLECLICK) {
			evtimer_del(&c->click_timer);
			c->flags &= ~CLIENT_TRIPLECLICK;
			if (m->b == c->click_button) {
				type = TRIPLE;
				x = m->x, y = m->y, b = m->b;
				log_debug("triple-click at %u,%u", x, y);
				goto have_event;
			}
		}

		type = DOWN;
		x = m->x, y = m->y, b = m->b;
		log_debug("down at %u,%u", x, y);
		flag = CLIENT_DOUBLECLICK;

	add_timer:
		if (KEYC_CLICK_TIMEOUT != 0) {
			c->flags |= flag;
			c->click_button = m->b;

			tv.tv_sec = KEYC_CLICK_TIMEOUT / 1000;
			tv.tv_usec = (KEYC_CLICK_TIMEOUT % 1000) * 1000L;
			evtimer_del(&c->click_timer);
			evtimer_add(&c->click_timer, &tv);
		}
	}

have_event:
	if (type == NOTYPE)
		return (KEYC_UNKNOWN);

	/* Always save the session. */
	m->s = s->id;

	/* Is this on the status line? */
	m->statusat = status_at_line(c);
	if (m->statusat != -1 && y == (u_int)m->statusat) {
		w = status_get_window_at(c, x);
		if (w == NULL)
			return (KEYC_UNKNOWN);
		m->w = w->id;
		where = STATUS;
	} else
		m->w = -1;

	/* Not on status line. Adjust position and check for border or pane. */
	if (where == NOWHERE) {
		if (m->statusat == 0 && y > 0)
			y--;
		else if (m->statusat > 0 && y >= (u_int)m->statusat)
			y = m->statusat - 1;

		TAILQ_FOREACH(wp, &s->curw->window->panes, entry) {
			if ((wp->xoff + wp->sx == x &&
			    wp->yoff <= 1 + y &&
			    wp->yoff + wp->sy >= y) ||
			    (wp->yoff + wp->sy == y &&
			    wp->xoff <= 1 + x &&
			    wp->xoff + wp->sx >= x))
				break;
		}
		if (wp != NULL)
			where = BORDER;
		else {
			wp = window_get_active_at(s->curw->window, x, y);
			if (wp != NULL) {
				where = PANE;
				log_debug("mouse at %u,%u is on pane %%%u",
				    x, y, wp->id);
			}
		}
		if (where == NOWHERE)
			return (KEYC_UNKNOWN);
		m->wp = wp->id;
		m->w = wp->window->id;
	} else
		m->wp = -1;

	/* Stop dragging if needed. */
	if (type != DRAG && type != WHEEL && c->tty.mouse_drag_flag) {
		if (c->tty.mouse_drag_release != NULL)
			c->tty.mouse_drag_release(c, m);

		c->tty.mouse_drag_update = NULL;
		c->tty.mouse_drag_release = NULL;

		/*
		 * End a mouse drag by passing a MouseDragEnd key corresponding
		 * to the button that started the drag.
		 */
		switch (c->tty.mouse_drag_flag) {
		case 1:
			if (where == PANE)
				key = KEYC_MOUSEDRAGEND1_PANE;
			if (where == STATUS)
				key = KEYC_MOUSEDRAGEND1_STATUS;
			if (where == BORDER)
				key = KEYC_MOUSEDRAGEND1_BORDER;
			break;
		case 2:
			if (where == PANE)
				key = KEYC_MOUSEDRAGEND2_PANE;
			if (where == STATUS)
				key = KEYC_MOUSEDRAGEND2_STATUS;
			if (where == BORDER)
				key = KEYC_MOUSEDRAGEND2_BORDER;
			break;
		case 3:
			if (where == PANE)
				key = KEYC_MOUSEDRAGEND3_PANE;
			if (where == STATUS)
				key = KEYC_MOUSEDRAGEND3_STATUS;
			if (where == BORDER)
				key = KEYC_MOUSEDRAGEND3_BORDER;
			break;
		default:
			key = KEYC_MOUSE;
			break;
		}
		c->tty.mouse_drag_flag = 0;

		return (key);
	}

	/* Convert to a key binding. */
	key = KEYC_UNKNOWN;
	switch (type) {
	case NOTYPE:
		break;
	case MOVE:
		if (where == PANE)
			key = KEYC_MOUSEMOVE_PANE;
		if (where == STATUS)
			key = KEYC_MOUSEMOVE_STATUS;
		if (where == BORDER)
			key = KEYC_MOUSEMOVE_BORDER;
		break;
	case DRAG:
		if (c->tty.mouse_drag_update != NULL)
			key = KEYC_DRAGGING;
		else {
			switch (MOUSE_BUTTONS(b)) {
			case 0:
				if (where == PANE)
					key = KEYC_MOUSEDRAG1_PANE;
				if (where == STATUS)
					key = KEYC_MOUSEDRAG1_STATUS;
				if (where == BORDER)
					key = KEYC_MOUSEDRAG1_BORDER;
				break;
			case 1:
				if (where == PANE)
					key = KEYC_MOUSEDRAG2_PANE;
				if (where == STATUS)
					key = KEYC_MOUSEDRAG2_STATUS;
				if (where == BORDER)
					key = KEYC_MOUSEDRAG2_BORDER;
				break;
			case 2:
				if (where == PANE)
					key = KEYC_MOUSEDRAG3_PANE;
				if (where == STATUS)
					key = KEYC_MOUSEDRAG3_STATUS;
				if (where == BORDER)
					key = KEYC_MOUSEDRAG3_BORDER;
				break;
			}
		}

		/*
		 * Begin a drag by setting the flag to a non-zero value that
		 * corresponds to the mouse button in use.
		 */
		c->tty.mouse_drag_flag = MOUSE_BUTTONS(b) + 1;
		break;
	case WHEEL:
		if (MOUSE_BUTTONS(b) == MOUSE_WHEEL_UP) {
			if (where == PANE)
				key = KEYC_WHEELUP_PANE;
			if (where == STATUS)
				key = KEYC_WHEELUP_STATUS;
			if (where == BORDER)
				key = KEYC_WHEELUP_BORDER;
		} else {
			if (where == PANE)
				key = KEYC_WHEELDOWN_PANE;
			if (where == STATUS)
				key = KEYC_WHEELDOWN_STATUS;
			if (where == BORDER)
				key = KEYC_WHEELDOWN_BORDER;
		}
		break;
	case UP:
		switch (MOUSE_BUTTONS(b)) {
		case 0:
			if (where == PANE)
				key = KEYC_MOUSEUP1_PANE;
			if (where == STATUS)
				key = KEYC_MOUSEUP1_STATUS;
			if (where == BORDER)
				key = KEYC_MOUSEUP1_BORDER;
			break;
		case 1:
			if (where == PANE)
				key = KEYC_MOUSEUP2_PANE;
			if (where == STATUS)
				key = KEYC_MOUSEUP2_STATUS;
			if (where == BORDER)
				key = KEYC_MOUSEUP2_BORDER;
			break;
		case 2:
			if (where == PANE)
				key = KEYC_MOUSEUP3_PANE;
			if (where == STATUS)
				key = KEYC_MOUSEUP3_STATUS;
			if (where == BORDER)
				key = KEYC_MOUSEUP3_BORDER;
			break;
		}
		break;
	case DOWN:
		switch (MOUSE_BUTTONS(b)) {
		case 0:
			if (where == PANE)
				key = KEYC_MOUSEDOWN1_PANE;
			if (where == STATUS)
				key = KEYC_MOUSEDOWN1_STATUS;
			if (where == BORDER)
				key = KEYC_MOUSEDOWN1_BORDER;
			break;
		case 1:
			if (where == PANE)
				key = KEYC_MOUSEDOWN2_PANE;
			if (where == STATUS)
				key = KEYC_MOUSEDOWN2_STATUS;
			if (where == BORDER)
				key = KEYC_MOUSEDOWN2_BORDER;
			break;
		case 2:
			if (where == PANE)
				key = KEYC_MOUSEDOWN3_PANE;
			if (where == STATUS)
				key = KEYC_MOUSEDOWN3_STATUS;
			if (where == BORDER)
				key = KEYC_MOUSEDOWN3_BORDER;
			break;
		}
		break;
	case DOUBLE:
		switch (MOUSE_BUTTONS(b)) {
		case 0:
			if (where == PANE)
				key = KEYC_DOUBLECLICK1_PANE;
			if (where == STATUS)
				key = KEYC_DOUBLECLICK1_STATUS;
			if (where == BORDER)
				key = KEYC_DOUBLECLICK1_BORDER;
			break;
		case 1:
			if (where == PANE)
				key = KEYC_DOUBLECLICK2_PANE;
			if (where == STATUS)
				key = KEYC_DOUBLECLICK2_STATUS;
			if (where == BORDER)
				key = KEYC_DOUBLECLICK2_BORDER;
			break;
		case 2:
			if (where == PANE)
				key = KEYC_DOUBLECLICK3_PANE;
			if (where == STATUS)
				key = KEYC_DOUBLECLICK3_STATUS;
			if (where == BORDER)
				key = KEYC_DOUBLECLICK3_BORDER;
			break;
		}
		break;
	case TRIPLE:
		switch (MOUSE_BUTTONS(b)) {
		case 0:
			if (where == PANE)
				key = KEYC_TRIPLECLICK1_PANE;
			if (where == STATUS)
				key = KEYC_TRIPLECLICK1_STATUS;
			if (where == BORDER)
				key = KEYC_TRIPLECLICK1_BORDER;
			break;
		case 1:
			if (where == PANE)
				key = KEYC_TRIPLECLICK2_PANE;
			if (where == STATUS)
				key = KEYC_TRIPLECLICK2_STATUS;
			if (where == BORDER)
				key = KEYC_TRIPLECLICK2_BORDER;
			break;
		case 2:
			if (where == PANE)
				key = KEYC_TRIPLECLICK3_PANE;
			if (where == STATUS)
				key = KEYC_TRIPLECLICK3_STATUS;
			if (where == BORDER)
				key = KEYC_TRIPLECLICK3_BORDER;
			break;
		}
		break;
	}
	if (key == KEYC_UNKNOWN)
		return (KEYC_UNKNOWN);

	/* Apply modifiers if any. */
	if (b & MOUSE_MASK_META)
		key |= KEYC_ESCAPE;
	if (b & MOUSE_MASK_CTRL)
		key |= KEYC_CTRL;
	if (b & MOUSE_MASK_SHIFT)
		key |= KEYC_SHIFT;

	return (key);
}

/* Is this fast enough to probably be a paste? */
static int
server_client_assume_paste(struct session *s)
{
	struct timeval	tv;
	int		t;

	if ((t = options_get_number(s->options, "assume-paste-time")) == 0)
		return (0);

	timersub(&s->activity_time, &s->last_activity_time, &tv);
	if (tv.tv_sec == 0 && tv.tv_usec < t * 1000) {
		log_debug("session %s pasting (flag %d)", s->name,
		    !!(s->flags & SESSION_PASTING));
		if (s->flags & SESSION_PASTING)
			return (1);
		s->flags |= SESSION_PASTING;
		return (0);
	}
	log_debug("session %s not pasting", s->name);
	s->flags &= ~SESSION_PASTING;
	return (0);
}

/* Handle data key input from client. */
void
server_client_handle_key(struct client *c, key_code key)
{
	struct mouse_event	*m = &c->tty.mouse;
	struct session		*s = c->session;
	struct window		*w;
	struct window_pane	*wp;
	struct timeval		 tv;
	const char		*name;
	struct key_table	*table;
	struct key_binding	 bd_find, *bd;
	int			 xtimeout;
	struct cmd_find_state	 fs;

	/* Check the client is good to accept input. */
	if (s == NULL || (c->flags & (CLIENT_DEAD|CLIENT_SUSPENDED)) != 0)
		return;
	w = s->curw->window;

	/* Update the activity timer. */
	if (gettimeofday(&c->activity_time, NULL) != 0)
		fatal("gettimeofday failed");
	session_update_activity(s, &c->activity_time);

	/* Number keys jump to pane in identify mode. */
	if (c->flags & CLIENT_IDENTIFY && key >= '0' && key <= '9') {
		if (c->flags & CLIENT_READONLY)
			return;
		window_unzoom(w);
		wp = window_pane_at_index(w, key - '0');
		if (wp != NULL && !window_pane_visible(wp))
			wp = NULL;
		server_client_clear_identify(c, wp);
		return;
	}

	/* Handle status line. */
	if (!(c->flags & CLIENT_READONLY)) {
		status_message_clear(c);
		server_client_clear_identify(c, NULL);
	}
	if (c->prompt_string != NULL) {
		if (c->flags & CLIENT_READONLY)
			return;
		if (status_prompt_key(c, key) == 0)
			return;
	}

	/* Check for mouse keys. */
	m->valid = 0;
	if (key == KEYC_MOUSE) {
		if (c->flags & CLIENT_READONLY)
			return;
		key = server_client_check_mouse(c);
		if (key == KEYC_UNKNOWN)
			return;

		m->valid = 1;
		m->key = key;

		/*
		 * Mouse drag is in progress, so fire the callback (now that
		 * the mouse event is valid).
		 */
		if (key == KEYC_DRAGGING) {
			c->tty.mouse_drag_update(c, m);
			return;
		}
	} else
		m->valid = 0;

	/* Find affected pane. */
	if (KEYC_IS_MOUSE(key) && m->valid)
		wp = cmd_mouse_pane(m, NULL, NULL);
	else
		wp = w->active;

	/* Forward mouse keys if disabled. */
	if (KEYC_IS_MOUSE(key) && !options_get_number(s->options, "mouse"))
		goto forward;

	/* Treat everything as a regular key when pasting is detected. */
	if (!KEYC_IS_MOUSE(key) && server_client_assume_paste(s))
		goto forward;

retry:
	/*
	 * Work out the current key table. If the pane is in a mode, use
	 * the mode table instead of the default key table.
	 */
	name = NULL;
	if (wp != NULL && wp->mode != NULL && wp->mode->key_table != NULL)
		name = wp->mode->key_table(wp);
	if (name == NULL || !server_client_is_default_key_table(c))
		table = c->keytable;
	else
		table = key_bindings_get_table(name, 1);
	if (wp == NULL)
		log_debug("key table %s (no pane)", table->name);
	else
		log_debug("key table %s (pane %%%u)", table->name, wp->id);

	/*
	 * The prefix always takes precedence and forces a switch to the prefix
	 * table, unless we are already there.
	 */
	if ((key == (key_code)options_get_number(s->options, "prefix") ||
	    key == (key_code)options_get_number(s->options, "prefix2")) &&
	    strcmp(table->name, "prefix") != 0) {
		server_client_set_key_table(c, "prefix");
		server_status_client(c);
		return;
	}

	/* Try to see if there is a key binding in the current table. */
	bd_find.key = key;
	bd = RB_FIND(key_bindings, &table->key_bindings, &bd_find);
	if (bd != NULL) {
		/*
		 * Key was matched in this table. If currently repeating but a
		 * non-repeating binding was found, stop repeating and try
		 * again in the root table.
		 */
		if ((c->flags & CLIENT_REPEAT) && !bd->can_repeat) {
			server_client_set_key_table(c, NULL);
			c->flags &= ~CLIENT_REPEAT;
			server_status_client(c);
			goto retry;
		}

		/*
		 * Take a reference to this table to make sure the key binding
		 * doesn't disappear.
		 */
		table->references++;

		/*
		 * If this is a repeating key, start the timer. Otherwise reset
		 * the client back to the root table.
		 */
		xtimeout = options_get_number(s->options, "repeat-time");
		if (xtimeout != 0 && bd->can_repeat) {
			c->flags |= CLIENT_REPEAT;

			tv.tv_sec = xtimeout / 1000;
			tv.tv_usec = (xtimeout % 1000) * 1000L;
			evtimer_del(&c->repeat_timer);
			evtimer_add(&c->repeat_timer, &tv);
		} else {
			c->flags &= ~CLIENT_REPEAT;
			server_client_set_key_table(c, NULL);
		}
		server_status_client(c);

		/* Find default state if the pane is known. */
		if (KEYC_IS_MOUSE(key) && m->valid && wp != NULL) {
			cmd_find_clear_state(&fs, NULL, 0);
			fs.s = s;
			fs.wl = fs.s->curw;
			fs.w = fs.wl->window;
			fs.wp = wp;
			cmd_find_log_state(__func__, &fs);

			if (!cmd_find_valid_state(&fs))
				fatalx("invalid key state");
			key_bindings_dispatch(bd, c, m, &fs);
		} else
			key_bindings_dispatch(bd, c, m, NULL);
		key_bindings_unref_table(table);
		return;
	}

	/*
	 * No match in this table. If repeating, switch the client back to the
	 * root table and try again.
	 */
	if (c->flags & CLIENT_REPEAT) {
		server_client_set_key_table(c, NULL);
		c->flags &= ~CLIENT_REPEAT;
		server_status_client(c);
		goto retry;
	}

	/* If no match and we're not in the root table, that's it. */
	if (name == NULL && !server_client_is_default_key_table(c)) {
		log_debug("no key in key table %s", table->name);
		server_client_set_key_table(c, NULL);
		server_status_client(c);
		return;
	}

forward:
	if (c->flags & CLIENT_READONLY)
		return;
	if (wp != NULL)
		window_pane_key(wp, c, s, key, m);
}

/* Client functions that need to happen every loop. */
void
server_client_loop(void)
{
	struct client		*c;
	struct window		*w;
	struct window_pane	*wp;
	int			 focus;

	TAILQ_FOREACH(c, &clients, entry) {
		server_client_check_exit(c);
		if (c->session != NULL) {
			server_client_check_redraw(c);
			server_client_reset_state(c);
		}
	}

	/*
	 * Any windows will have been redrawn as part of clients, so clear
	 * their flags now. Also check pane focus and resize.
	 */
	focus = options_get_number(global_options, "focus-events");
	RB_FOREACH(w, windows, &windows) {
		TAILQ_FOREACH(wp, &w->panes, entry) {
			if (wp->fd != -1) {
				if (focus)
					server_client_check_focus(wp);
				server_client_check_resize(wp);
			}
			wp->flags &= ~PANE_REDRAW;
		}
		check_window_name(w);
	}
}

/* Resize timer event. */
static void
server_client_resize_event(__unused int fd, __unused short events, void *data)
{
	struct window_pane	*wp = data;
	struct winsize		 ws;

	evtimer_del(&wp->resize_timer);

	if (!(wp->flags & PANE_RESIZE))
		return;

	memset(&ws, 0, sizeof ws);
	ws.ws_col = wp->sx;
	ws.ws_row = wp->sy;

	if (ioctl(wp->fd, TIOCSWINSZ, &ws) == -1)
		fatal("ioctl failed");

	wp->flags &= ~PANE_RESIZE;
}

/* Check if pane should be resized. */
static void
server_client_check_resize(struct window_pane *wp)
{
	struct timeval	 tv = { .tv_usec = 250000 };

	if (!(wp->flags & PANE_RESIZE))
		return;

	if (!event_initialized(&wp->resize_timer))
		evtimer_set(&wp->resize_timer, server_client_resize_event, wp);

	/*
	 * The first resize should happen immediately, so if the timer is not
	 * running, do it now.
	 */
	if (!evtimer_pending(&wp->resize_timer, NULL))
		server_client_resize_event(-1, 0, wp);

	/*
	 * If the pane is in the alternate screen, let the timer expire and
	 * resize to give the application a chance to redraw. If not, keep
	 * pushing the timer back.
	 */
	if (wp->saved_grid != NULL && evtimer_pending(&wp->resize_timer, NULL))
		return;
	evtimer_del(&wp->resize_timer);
	evtimer_add(&wp->resize_timer, &tv);
}

/* Check whether pane should be focused. */
static void
server_client_check_focus(struct window_pane *wp)
{
	struct client	*c;
	int		 push;

	/* Do we need to push the focus state? */
	push = wp->flags & PANE_FOCUSPUSH;
	wp->flags &= ~PANE_FOCUSPUSH;

	/* If we don't care about focus, forget it. */
	if (!(wp->base.mode & MODE_FOCUSON))
		return;

	/* If we're not the active pane in our window, we're not focused. */
	if (wp->window->active != wp)
		goto not_focused;

	/* If we're in a mode, we're not focused. */
	if (wp->screen != &wp->base)
		goto not_focused;

	/*
	 * If our window is the current window in any focused clients with an
	 * attached session, we're focused.
	 */
	TAILQ_FOREACH(c, &clients, entry) {
		if (c->session == NULL || !(c->flags & CLIENT_FOCUSED))
			continue;
		if (c->session->flags & SESSION_UNATTACHED)
			continue;

		if (c->session->curw->window == wp->window)
			goto focused;
	}

not_focused:
	if (push || (wp->flags & PANE_FOCUSED))
		bufferevent_write(wp->event, "\033[O", 3);
	wp->flags &= ~PANE_FOCUSED;
	return;

focused:
	if (push || !(wp->flags & PANE_FOCUSED))
		bufferevent_write(wp->event, "\033[I", 3);
	wp->flags |= PANE_FOCUSED;
}

/*
 * Update cursor position and mode settings. The scroll region and attributes
 * are cleared when idle (waiting for an event) as this is the most likely time
 * a user may interrupt tmux, for example with ~^Z in ssh(1). This is a
 * compromise between excessive resets and likelihood of an interrupt.
 *
 * tty_region/tty_reset/tty_update_mode already take care of not resetting
 * things that are already in their default state.
 */
static void
server_client_reset_state(struct client *c)
{
	struct window		*w = c->session->curw->window;
	struct window_pane	*wp = w->active, *loop;
	struct screen		*s = wp->screen;
	struct options		*oo = c->session->options;
	int			 status, mode, o;

	if (c->flags & (CLIENT_CONTROL|CLIENT_SUSPENDED))
		return;

	tty_region_off(&c->tty);
	tty_margin_off(&c->tty);

	status = options_get_number(oo, "status");
	if (!window_pane_visible(wp) || wp->yoff + s->cy >= c->tty.sy - status)
		tty_cursor(&c->tty, 0, 0);
	else {
		o = status && options_get_number(oo, "status-position") == 0;
		tty_cursor(&c->tty, wp->xoff + s->cx, o + wp->yoff + s->cy);
	}

	/*
	 * Set mouse mode if requested. To support dragging, always use button
	 * mode.
	 */
	mode = s->mode;
	if (options_get_number(oo, "mouse")) {
		mode &= ~ALL_MOUSE_MODES;
		TAILQ_FOREACH(loop, &w->panes, entry) {
			if (loop->screen->mode & MODE_MOUSE_ALL)
				mode |= MODE_MOUSE_ALL;
		}
		if (~mode & MODE_MOUSE_ALL)
			mode |= MODE_MOUSE_BUTTON;
	}

	/* Clear bracketed paste mode if at the prompt. */
	if (c->prompt_string != NULL)
		mode &= ~MODE_BRACKETPASTE;

	/* Set the terminal mode and reset attributes. */
	tty_update_mode(&c->tty, mode, s);
	tty_reset(&c->tty);
}

/* Repeat time callback. */
static void
server_client_repeat_timer(__unused int fd, __unused short events, void *data)
{
	struct client	*c = data;

	if (c->flags & CLIENT_REPEAT) {
		server_client_set_key_table(c, NULL);
		c->flags &= ~CLIENT_REPEAT;
		server_status_client(c);
	}
}

/* Double-click callback. */
static void
server_client_click_timer(__unused int fd, __unused short events, void *data)
{
	struct client	*c = data;

	c->flags &= ~(CLIENT_DOUBLECLICK|CLIENT_TRIPLECLICK);
}

/* Check if client should be exited. */
static void
server_client_check_exit(struct client *c)
{
	if (!(c->flags & CLIENT_EXIT))
		return;

	if (EVBUFFER_LENGTH(c->stdin_data) != 0)
		return;
	if (EVBUFFER_LENGTH(c->stdout_data) != 0)
		return;
	if (EVBUFFER_LENGTH(c->stderr_data) != 0)
		return;

	proc_send(c->peer, MSG_EXIT, -1, &c->retval, sizeof c->retval);
	c->flags &= ~CLIENT_EXIT;
}

/* Redraw timer callback. */
static void
server_client_redraw_timer(__unused int fd, __unused short events,
    __unused void* data)
{
	log_debug("redraw timer fired");
}

/* Check for client redraws. */
static void
server_client_check_redraw(struct client *c)
{
	struct session		*s = c->session;
	struct tty		*tty = &c->tty;
	struct window_pane	*wp;
	int		 	 needed, flags, masked;
	struct timeval		 tv = { .tv_usec = 1000 };
	static struct event	 ev;
	size_t			 left;

	if (c->flags & (CLIENT_CONTROL|CLIENT_SUSPENDED))
		return;

	/*
	 * If there is outstanding data, defer the redraw until it has been
	 * consumed. We can just add a timer to get out of the event loop and
	 * end up back here.
	 */
	needed = 0;
	if (c->flags & CLIENT_REDRAW)
		needed = 1;
	else {
		TAILQ_FOREACH(wp, &c->session->curw->window->panes, entry) {
			if (wp->flags & PANE_REDRAW) {
				needed = 1;
				break;
			}
		}
	}
	if (needed) {
		left = EVBUFFER_LENGTH(tty->out);
		if (left != 0) {
			log_debug("%s: redraw deferred (%zu left)", c->name, left);
			if (evtimer_initialized(&ev) && evtimer_pending(&ev, NULL))
				return;
			log_debug("redraw timer started");
			evtimer_set(&ev, server_client_redraw_timer, NULL);
			evtimer_add(&ev, &tv);

			/*
			 * We may have got here for a single pane redraw, but
			 * force a full redraw next time in case other panes
			 * have been updated.
			 */
			c->flags |= CLIENT_REDRAW;
			return;
		}
		if (evtimer_initialized(&ev))
			evtimer_del(&ev);
		log_debug("%s: redraw needed", c->name);
	}

	if (c->flags & (CLIENT_REDRAW|CLIENT_STATUS)) {
		if (options_get_number(s->options, "set-titles"))
			server_client_set_title(c);
		screen_redraw_update(c); /* will adjust flags */
	}

	flags = tty->flags & (TTY_BLOCK|TTY_FREEZE|TTY_NOCURSOR);
	tty->flags = (tty->flags & ~(TTY_BLOCK|TTY_FREEZE)) | TTY_NOCURSOR;

	if (c->flags & CLIENT_REDRAW) {
		tty_update_mode(tty, tty->mode, NULL);
		screen_redraw_screen(c, 1, 1, 1);
		c->flags &= ~(CLIENT_STATUS|CLIENT_BORDERS);
	} else {
		TAILQ_FOREACH(wp, &c->session->curw->window->panes, entry) {
			if (wp->flags & PANE_REDRAW) {
				tty_update_mode(tty, tty->mode, NULL);
				screen_redraw_pane(c, wp);
			}
		}
	}

	masked = c->flags & (CLIENT_BORDERS|CLIENT_STATUS);
	if (masked != 0)
		tty_update_mode(tty, tty->mode, NULL);
	if (masked == CLIENT_BORDERS)
		screen_redraw_screen(c, 0, 0, 1);
	else if (masked == CLIENT_STATUS)
		screen_redraw_screen(c, 0, 1, 0);
	else if (masked != 0)
		screen_redraw_screen(c, 0, 1, 1);

	tty->flags = (tty->flags & ~(TTY_FREEZE|TTY_NOCURSOR)) | flags;
	tty_update_mode(tty, tty->mode, NULL);

	c->flags &= ~(CLIENT_REDRAW|CLIENT_BORDERS|CLIENT_STATUS|
	    CLIENT_STATUSFORCE);
}

/* Set client title. */
static void
server_client_set_title(struct client *c)
{
	struct session		*s = c->session;
	const char		*template;
	char			*title;
	struct format_tree	*ft;

	template = options_get_string(s->options, "set-titles-string");

	ft = format_create(NULL, FORMAT_NONE, 0);
	format_defaults(ft, c, NULL, NULL, NULL);

	title = format_expand_time(ft, template, time(NULL));
	if (c->title == NULL || strcmp(title, c->title) != 0) {
		free(c->title);
		c->title = xstrdup(title);
		tty_set_title(&c->tty, c->title);
	}
	free(title);

	format_free(ft);
}

/* Dispatch message from client. */
static void
server_client_dispatch(struct imsg *imsg, void *arg)
{
	struct client		*c = arg;
	struct msg_stdin_data	 stdindata;
	const char		*data;
	ssize_t			 datalen;
	struct session		*s;

	if (c->flags & CLIENT_DEAD)
		return;

	if (imsg == NULL) {
		server_client_lost(c);
		return;
	}

	data = imsg->data;
	datalen = imsg->hdr.len - IMSG_HEADER_SIZE;

	switch (imsg->hdr.type) {
	case MSG_IDENTIFY_FLAGS:
	case MSG_IDENTIFY_TERM:
	case MSG_IDENTIFY_TTYNAME:
	case MSG_IDENTIFY_CWD:
	case MSG_IDENTIFY_STDIN:
	case MSG_IDENTIFY_ENVIRON:
	case MSG_IDENTIFY_CLIENTPID:
	case MSG_IDENTIFY_DONE:
		server_client_dispatch_identify(c, imsg);
		break;
	case MSG_COMMAND:
		server_client_dispatch_command(c, imsg);
		break;
	case MSG_STDIN:
		if (datalen != sizeof stdindata)
			fatalx("bad MSG_STDIN size");
		memcpy(&stdindata, data, sizeof stdindata);

		if (c->stdin_callback == NULL)
			break;
		if (stdindata.size <= 0)
			c->stdin_closed = 1;
		else {
			evbuffer_add(c->stdin_data, stdindata.data,
			    stdindata.size);
		}
		c->stdin_callback(c, c->stdin_closed,
		    c->stdin_callback_data);
		break;
	case MSG_RESIZE:
		if (datalen != 0)
			fatalx("bad MSG_RESIZE size");

		if (c->flags & CLIENT_CONTROL)
			break;
		if (tty_resize(&c->tty)) {
			recalculate_sizes();
			server_redraw_client(c);
		}
		if (c->session != NULL)
			notify_client("client-resized", c);
		break;
	case MSG_EXITING:
		if (datalen != 0)
			fatalx("bad MSG_EXITING size");

		c->session = NULL;
		tty_close(&c->tty);
		proc_send(c->peer, MSG_EXITED, -1, NULL, 0);
		break;
	case MSG_WAKEUP:
	case MSG_UNLOCK:
		if (datalen != 0)
			fatalx("bad MSG_WAKEUP size");

		if (!(c->flags & CLIENT_SUSPENDED))
			break;
		c->flags &= ~CLIENT_SUSPENDED;

		if (c->tty.fd == -1) /* exited in the meantime */
			break;
		s = c->session;

		if (gettimeofday(&c->activity_time, NULL) != 0)
			fatal("gettimeofday failed");

		tty_start_tty(&c->tty);
		server_redraw_client(c);
		recalculate_sizes();

		if (s != NULL)
			session_update_activity(s, &c->activity_time);
		break;
	case MSG_SHELL:
		if (datalen != 0)
			fatalx("bad MSG_SHELL size");

		server_client_dispatch_shell(c);
		break;
	}
}

/* Callback when command is done. */
static enum cmd_retval
server_client_command_done(struct cmdq_item *item, __unused void *data)
{
	struct client	*c = item->client;

	if (~c->flags & CLIENT_ATTACHED)
		c->flags |= CLIENT_EXIT;
	return (CMD_RETURN_NORMAL);
}

/* Show an error message. */
static enum cmd_retval
server_client_command_error(struct cmdq_item *item, void *data)
{
	char	*error = data;

	cmdq_error(item, "%s", error);
	free(error);

	return (CMD_RETURN_NORMAL);
}

/* Handle command message. */
static void
server_client_dispatch_command(struct client *c, struct imsg *imsg)
{
	struct msg_command_data	  data;
	char			 *buf;
	size_t			  len;
	struct cmd_list		 *cmdlist = NULL;
	int			  argc;
	char			**argv, *cause;

	if (imsg->hdr.len - IMSG_HEADER_SIZE < sizeof data)
		fatalx("bad MSG_COMMAND size");
	memcpy(&data, imsg->data, sizeof data);

	buf = (char *)imsg->data + sizeof data;
	len = imsg->hdr.len  - IMSG_HEADER_SIZE - sizeof data;
	if (len > 0 && buf[len - 1] != '\0')
		fatalx("bad MSG_COMMAND string");

	argc = data.argc;
	if (cmd_unpack_argv(buf, len, argc, &argv) != 0) {
		cause = xstrdup("command too long");
		goto error;
	}

	if (argc == 0) {
		argc = 1;
		argv = xcalloc(1, sizeof *argv);
		*argv = xstrdup("new-session");
	}

	if ((cmdlist = cmd_list_parse(argc, argv, NULL, 0, &cause)) == NULL) {
		cmd_free_argv(argc, argv);
		goto error;
	}
	cmd_free_argv(argc, argv);

	cmdq_append(c, cmdq_get_command(cmdlist, NULL, NULL, 0));
	cmdq_append(c, cmdq_get_callback(server_client_command_done, NULL));
	cmd_list_free(cmdlist);
	return;

error:
	cmdq_append(c, cmdq_get_callback(server_client_command_error, cause));

	if (cmdlist != NULL)
		cmd_list_free(cmdlist);

	c->flags |= CLIENT_EXIT;
}

/* Handle identify message. */
static void
server_client_dispatch_identify(struct client *c, struct imsg *imsg)
{
	const char	*data, *home;
	size_t	 	 datalen;
	int		 flags;
	char		*name;

	if (c->flags & CLIENT_IDENTIFIED)
		fatalx("out-of-order identify message");

	data = imsg->data;
	datalen = imsg->hdr.len - IMSG_HEADER_SIZE;

	switch (imsg->hdr.type)	{
	case MSG_IDENTIFY_FLAGS:
		if (datalen != sizeof flags)
			fatalx("bad MSG_IDENTIFY_FLAGS size");
		memcpy(&flags, data, sizeof flags);
		c->flags |= flags;
		log_debug("client %p IDENTIFY_FLAGS %#x", c, flags);
		break;
	case MSG_IDENTIFY_TERM:
		if (datalen == 0 || data[datalen - 1] != '\0')
			fatalx("bad MSG_IDENTIFY_TERM string");
		c->term = xstrdup(data);
		log_debug("client %p IDENTIFY_TERM %s", c, data);
		break;
	case MSG_IDENTIFY_TTYNAME:
		if (datalen == 0 || data[datalen - 1] != '\0')
			fatalx("bad MSG_IDENTIFY_TTYNAME string");
		c->ttyname = xstrdup(data);
		log_debug("client %p IDENTIFY_TTYNAME %s", c, data);
		break;
	case MSG_IDENTIFY_CWD:
		if (datalen == 0 || data[datalen - 1] != '\0')
			fatalx("bad MSG_IDENTIFY_CWD string");
		if (access(data, X_OK) == 0)
			c->cwd = xstrdup(data);
		else if ((home = find_home()) != NULL)
			c->cwd = xstrdup(home);
		else
			c->cwd = xstrdup("/");
		log_debug("client %p IDENTIFY_CWD %s", c, data);
		break;
	case MSG_IDENTIFY_STDIN:
		if (datalen != 0)
			fatalx("bad MSG_IDENTIFY_STDIN size");
		c->fd = imsg->fd;
		log_debug("client %p IDENTIFY_STDIN %d", c, imsg->fd);
		break;
	case MSG_IDENTIFY_ENVIRON:
		if (datalen == 0 || data[datalen - 1] != '\0')
			fatalx("bad MSG_IDENTIFY_ENVIRON string");
		if (strchr(data, '=') != NULL)
			environ_put(c->environ, data);
		log_debug("client %p IDENTIFY_ENVIRON %s", c, data);
		break;
	case MSG_IDENTIFY_CLIENTPID:
		if (datalen != sizeof c->pid)
			fatalx("bad MSG_IDENTIFY_CLIENTPID size");
		memcpy(&c->pid, data, sizeof c->pid);
		log_debug("client %p IDENTIFY_CLIENTPID %ld", c, (long)c->pid);
		break;
	default:
		break;
	}

	if (imsg->hdr.type != MSG_IDENTIFY_DONE)
		return;
	c->flags |= CLIENT_IDENTIFIED;

	if (*c->ttyname != '\0')
		name = xstrdup(c->ttyname);
	else
		xasprintf(&name, "client-%ld", (long)c->pid);
	c->name = name;
	log_debug("client %p name is %s", c, c->name);

	if (c->flags & CLIENT_CONTROL) {
		c->stdin_callback = control_callback;

		evbuffer_free(c->stderr_data);
		c->stderr_data = c->stdout_data;

		if (c->flags & CLIENT_CONTROLCONTROL)
			evbuffer_add_printf(c->stdout_data, "\033P1000p");
		proc_send(c->peer, MSG_STDIN, -1, NULL, 0);

		c->tty.fd = -1;

		close(c->fd);
		c->fd = -1;

		return;
	}

	if (c->fd == -1)
		return;
	if (tty_init(&c->tty, c, c->fd, c->term) != 0) {
		close(c->fd);
		c->fd = -1;
		return;
	}
	if (c->flags & CLIENT_UTF8)
		c->tty.flags |= TTY_UTF8;
	if (c->flags & CLIENT_256COLOURS)
		c->tty.term_flags |= TERM_256COLOURS;

	tty_resize(&c->tty);

	if (!(c->flags & CLIENT_CONTROL))
		c->flags |= CLIENT_TERMINAL;
}

/* Handle shell message. */
static void
server_client_dispatch_shell(struct client *c)
{
	const char	*shell;

	shell = options_get_string(global_s_options, "default-shell");
	if (*shell == '\0' || areshell(shell))
		shell = _PATH_BSHELL;
	proc_send_s(c->peer, MSG_SHELL, shell);

	proc_kill_peer(c->peer);
}

/* Event callback to push more stdout data if any left. */
static void
server_client_stdout_cb(__unused int fd, __unused short events, void *arg)
{
	struct client	*c = arg;

	if (~c->flags & CLIENT_DEAD)
		server_client_push_stdout(c);
	server_client_unref(c);
}

/* Push stdout to client if possible. */
void
server_client_push_stdout(struct client *c)
{
	struct msg_stdout_data data;
	size_t                 sent, left;

	left = EVBUFFER_LENGTH(c->stdout_data);
	while (left != 0) {
		sent = left;
		if (sent > sizeof data.data)
			sent = sizeof data.data;
		memcpy(data.data, EVBUFFER_DATA(c->stdout_data), sent);
		data.size = sent;

		if (proc_send(c->peer, MSG_STDOUT, -1, &data, sizeof data) != 0)
			break;
		evbuffer_drain(c->stdout_data, sent);

		left = EVBUFFER_LENGTH(c->stdout_data);
		log_debug("%s: client %p, sent %zu, left %zu", __func__, c,
		    sent, left);
	}
	if (left != 0) {
		c->references++;
		event_once(-1, EV_TIMEOUT, server_client_stdout_cb, c, NULL);
		log_debug("%s: client %p, queued", __func__, c);
	}
}

/* Event callback to push more stderr data if any left. */
static void
server_client_stderr_cb(__unused int fd, __unused short events, void *arg)
{
	struct client	*c = arg;

	if (~c->flags & CLIENT_DEAD)
		server_client_push_stderr(c);
	server_client_unref(c);
}

/* Push stderr to client if possible. */
void
server_client_push_stderr(struct client *c)
{
	struct msg_stderr_data data;
	size_t                 sent, left;

	if (c->stderr_data == c->stdout_data) {
		server_client_push_stdout(c);
		return;
	}

	left = EVBUFFER_LENGTH(c->stderr_data);
	while (left != 0) {
		sent = left;
		if (sent > sizeof data.data)
			sent = sizeof data.data;
		memcpy(data.data, EVBUFFER_DATA(c->stderr_data), sent);
		data.size = sent;

		if (proc_send(c->peer, MSG_STDERR, -1, &data, sizeof data) != 0)
			break;
		evbuffer_drain(c->stderr_data, sent);

		left = EVBUFFER_LENGTH(c->stderr_data);
		log_debug("%s: client %p, sent %zu, left %zu", __func__, c,
		    sent, left);
	}
	if (left != 0) {
		c->references++;
		event_once(-1, EV_TIMEOUT, server_client_stderr_cb, c, NULL);
		log_debug("%s: client %p, queued", __func__, c);
	}
}

/* Add to client message log. */
void
server_client_add_message(struct client *c, const char *fmt, ...)
{
	struct message_entry	*msg, *msg1;
	char			*s;
	va_list			 ap;
	u_int			 limit;

	va_start(ap, fmt);
	xvasprintf(&s, fmt, ap);
	va_end(ap);

	log_debug("message %s (client %p)", s, c);

	msg = xcalloc(1, sizeof *msg);
	msg->msg_time = time(NULL);
	msg->msg_num = c->message_next++;
	msg->msg = s;
	TAILQ_INSERT_TAIL(&c->message_log, msg, entry);

	limit = options_get_number(global_options, "message-limit");
	TAILQ_FOREACH_SAFE(msg, &c->message_log, entry, msg1) {
		if (msg->msg_num + limit >= c->message_next)
			break;
		free(msg->msg);
		TAILQ_REMOVE(&c->message_log, msg, entry);
		free(msg);
	}
}

/* Get client working directory. */
const char *
server_client_get_cwd(struct client *c)
{
	struct session	*s;

	if (c != NULL && c->session == NULL && c->cwd != NULL)
		return (c->cwd);
	if (c != NULL && (s = c->session) != NULL && s->cwd != NULL)
		return (s->cwd);
	return (".");
}

/* Resolve an absolute path or relative to client working directory. */
char *
server_client_get_path(struct client *c, const char *file)
{
	char	*path, resolved[PATH_MAX];

	if (*file == '/')
		path = xstrdup(file);
	else
		xasprintf(&path, "%s/%s", server_client_get_cwd(c), file);
	if (realpath(path, resolved) == NULL)
		return (path);
	free(path);
	return (xstrdup(resolved));
}
@


1.220
log
@Add a suspend helper function, and do not allow detaching or suspending
while already doing so.
@
text
@d1 1
a1 1
/* $OpenBSD: server-client.c,v 1.219 2017/04/19 06:52:27 nicm Exp $ */
d943 2
a944 2
		cmd_find_clear_state(&fs, NULL, 0);
		if (wp != NULL) {
d953 3
a955 4
		}

		/* Dispatch the key binding. */
		key_bindings_dispatch(bd, c, m, &fs);
@


1.219
log
@When the data we have buffered to write to a terminal grows beyond a
reasonable amount (currently width * height * 8 bytes), discard all
output to the terminal and start trying to redraw periodically
instead. Continue with this until the amount of data we are trying to
write falls to a low level again.

This helps to prevent tmux sitting on a huge buffer of data when there
are processes with fast output running inside tmux but the outside
terminal is slow.

A new client_discarded format holds the amount of data that has been
discarded due to this mechanism.

The three variables (when to start this, when to stop, and how often to
redraw) are basically "works for me" at the moment, this is going in to
see how it goes and if it causes problems for anyone else.
@
text
@d1 1
a1 1
/* $OpenBSD: server-client.c,v 1.218 2017/04/18 20:37:49 nicm Exp $ */
d52 1
a52 1
/* Idenfity mode callback. */
d328 14
d346 1
a346 1
	struct session	*s = c->session;
d348 1
a348 1
	if (s == NULL)
d351 1
@


1.218
log
@On terminals without DECSLRM, when a pane that is less than the full
with of the terminal scrolls, tmux needs to redraw the entire pane. This
results in a large amount of output data which can cause slow terminals
to struggle, particularly when many lines are scrolled together quickly.

This can be reduced by only redrawing when tmux doesn't hold any
buffered data for the terminal. If a redraw is required and data is
buffered, the redraw is deferred until all that data is consumed (it is
checked after every event loop, a timer is used to ensure this happens
at some point). While a redraw is pending, no additional data will be
written to the terminal.

The redraw still happens, now it is just pushed back if it is possible
it would just add more data on top of a terminal that is already
behind. This both gives the terminal a chance to catch up, and allows
tmux to process more scrolling (that would require additional redraws)
in the meantime.

Helps with a problem reported by Greg Hurrell.
@
text
@d1 1
a1 1
/* $OpenBSD: server-client.c,v 1.217 2017/04/17 06:40:32 nicm Exp $ */
d1272 2
a1273 2
	flags = tty->flags & (TTY_FREEZE|TTY_NOCURSOR);
	tty->flags = (tty->flags & ~TTY_FREEZE) | TTY_NOCURSOR;
@


1.217
log
@Remove a couple of redraw flags that no longer have any effect.
@
text
@d1 1
a1 1
/* $OpenBSD: server-client.c,v 1.216 2017/04/05 10:49:46 nicm Exp $ */
d1204 8
d1219 4
a1222 1
	int		 	 flags, masked;
d1226 39
@


1.216
log
@Give each client a name. This defaults to the tty name as before but
falls back to an alternative if the tty name is not available. This is
clearer than overloading the client ttyname member and allows us to
remove the path stored in the tty struct, it should always be the same
as the client.
@
text
@d1 1
a1 1
/* $OpenBSD: server-client.c,v 1.215 2017/03/09 22:00:46 nicm Exp $ */
a994 1
		w->flags &= ~WINDOW_REDRAW;
a1228 5
	} else if (c->flags & CLIENT_REDRAWWINDOW) {
		tty_update_mode(tty, tty->mode, NULL);
		TAILQ_FOREACH(wp, &c->session->curw->window->panes, entry)
			screen_redraw_pane(c, wp);
		c->flags &= ~CLIENT_REDRAWWINDOW;
@


1.215
log
@Clear the bracket paste mode when in the command prompt.
@
text
@d1 1
a1 1
/* $OpenBSD: server-client.c,v 1.214 2017/03/09 17:06:35 nicm Exp $ */
a101 3
	if (c->tty.path == NULL)
		return (0);

d107 1
a107 1
		if (strcmp(wp->tty, c->tty.path) == 0)
d322 2
a323 1
	if (c->references == 0)
d325 1
d1472 1
d1538 7
d1695 1
a1695 1
	log_debug("%s: message %s", c->tty.path, s);
@


1.214
log
@Move the client identify (display-panes) code into server-client.c.
@
text
@d1 1
a1 1
/* $OpenBSD: server-client.c,v 1.213 2017/02/14 18:13:05 nicm Exp $ */
d1156 4
@


1.213
log
@Make source-file look for files relative to the client working directory
(like load-buffer and save-buffer), from Chris Pickel. Also break the
where-is-this-file code out into its own function for loadb and saveb.
@
text
@d1 1
a1 1
/* $OpenBSD: server-client.c,v 1.212 2017/02/09 12:09:33 nicm Exp $ */
d52 43
d238 1
a238 1
	server_clear_identify(c, NULL);
d806 1
a806 1
		server_clear_identify(c, wp);
d813 1
a813 1
		server_clear_identify(c, NULL);
@


1.212
log
@Break the message storage function into its own function, useful for
debugging.
@
text
@d1 1
a1 1
/* $OpenBSD: server-client.c,v 1.211 2017/02/08 15:49:29 nicm Exp $ */
d1657 29
@


1.211
log
@Some other tidying bits.
@
text
@d1 1
a1 1
/* $OpenBSD: server-client.c,v 1.210 2017/02/03 11:57:27 nicm Exp $ */
d1625 31
@


1.210
log
@Add a window or pane id "tag" to each format tree and use it to separate
jobs, this means that if the same job is used for different windows or
panes (for example in pane-border-format), it will be run separately for
each pane.
@
text
@d1 1
a1 1
/* $OpenBSD: server-client.c,v 1.209 2017/02/01 09:55:07 nicm Exp $ */
d966 1
@


1.209
log
@Implement "all event" (1003) mouse mode but in a way that works. The
main issue is that if we have two panes, A with 1002 and B with 1003, we
need to set 1003 outside tmux in order to get all the mouse events, but
then we need to suppress the ones that pane A doesn't want. This is easy
in SGR mouse mode, because buttons == 3 is only used for movement events
(for other events the trailing m/M marks a release instead), but in
normal mouse mode we can't tell so easily. So for that, look at the
previous event instead - if it is drag+release as well, then the current
event is a movement event.
@
text
@d1 1
a1 1
/* $OpenBSD: server-client.c,v 1.208 2017/01/13 11:56:43 nicm Exp $ */
d1225 1
a1225 1
	ft = format_create(NULL, 0);
@


1.208
log
@Make options_get_string return const string.
@
text
@d1 1
a1 1
/* $OpenBSD: server-client.c,v 1.207 2017/01/13 10:12:12 nicm Exp $ */
d338 5
a342 2
	enum { NOTYPE, DOWN, UP, DRAG, WHEEL, DOUBLE, TRIPLE } type = NOTYPE;
	enum { NOWHERE, PANE, STATUS, BORDER } where = NOWHERE;
d348 11
a358 1
	if (MOUSE_DRAG(m->b)) {
d516 8
d1079 1
a1079 1
	struct window_pane	*wp = w->active;
d1103 9
a1111 2
	if (options_get_number(oo, "mouse"))
		mode = (mode & ~ALL_MOUSE_MODES) | MODE_MOUSE_BUTTON;
@


1.207
log
@Add -E to detach-client to exec a command to replace the client instead
of exiting it, useful if tmux wasn't exec'd itself. From Jenna Magius.
@
text
@d1 1
a1 1
/* $OpenBSD: server-client.c,v 1.206 2017/01/11 22:36:07 nicm Exp $ */
d299 1
a299 1
/* Execute command to replace a client, */
d304 2
a305 1
	char		*msg, *shell;
@


1.206
log
@Add some missing special keys to key_string_lookup_key, fix a mouse
check in server_client_handle_key, and tweak a comment.
@
text
@d1 1
a1 1
/* $OpenBSD: server-client.c,v 1.205 2016/12/07 09:16:13 nicm Exp $ */
d297 26
@


1.205
log
@Make prefix work in all tables (except the prefix table). Users who want
to avoid this can set prefix to "none" and bind send-prefix
themselves. Allows C-b t be bound in the copy mode tables again, pointed
out by millert@@.
@
text
@d1 1
a1 1
/* $OpenBSD: server-client.c,v 1.204 2016/11/24 18:45:45 nicm Exp $ */
d761 1
a761 1
	if (key == KEYC_MOUSE && !options_get_number(s->options, "mouse"))
@


1.204
log
@The mouse valid flag needs to be correct before we fire the dragging
callback, so move the callback outside of server_client_check_mouse and
use a new special key code to indicate it.
@
text
@d1 1
a1 1
/* $OpenBSD: server-client.c,v 1.203 2016/11/24 14:38:55 nicm Exp $ */
d785 12
d869 1
a870 11
		server_status_client(c);
		return;
	}

	/*
	 * No match, but in the root table. Prefix switches to the prefix table
	 * and everything else is passed through.
	 */
	if (key == (key_code)options_get_number(s->options, "prefix") ||
	    key == (key_code)options_get_number(s->options, "prefix2")) {
		server_client_set_key_table(c, "prefix");
@


1.203
log
@If in the middle of a drag, don't use an invalid key, just use
KEYC_MOUSE as a placeholder. Reported by Artem Fokin.
@
text
@d1 1
a1 1
/* $OpenBSD: server-client.c,v 1.202 2016/11/24 13:46:50 nicm Exp $ */
d477 3
a479 4
		if (c->tty.mouse_drag_update != NULL) {
			c->tty.mouse_drag_update(c, m);
			key = KEYC_MOUSE;
		} else {
d732 1
d744 2
a745 2
		 * A mouse event that continues to be valid but that we do not
		 * want to pass through.
d747 2
a748 1
		if (key == KEYC_MOUSE)
d750 1
@


1.202
log
@Fix so that we work out the right pane from mouse events - we were doing
so too early, before the mouse event was necessarily valid, so could end
up using the pane from the previous mouse event, or the active pane.

It is important that we use the right pane now that different panes can
have different key tables (for copy mode).

Fixes problem reported by Greg Hurrell.
@
text
@d1 1
a1 1
/* $OpenBSD: server-client.c,v 1.201 2016/11/23 17:01:24 nicm Exp $ */
d477 1
a477 1
		if (c->tty.mouse_drag_update != NULL)
d479 2
a480 1
		else {
d742 7
@


1.201
log
@For mouse keys, use the mouse pane as the default current pane.
@
text
@d1 1
a1 1
/* $OpenBSD: server-client.c,v 1.200 2016/11/16 11:37:16 nicm Exp $ */
a700 4
	if (KEYC_IS_MOUSE(key))
		wp = cmd_mouse_pane(m, NULL, NULL);
	else
		wp = w->active;
a740 3

		if (!options_get_number(s->options, "mouse"))
			goto forward;
d744 10
d770 4
@


1.200
log
@Do not stop dragging when the wheel is pressed, from Artem Fokin.
@
text
@d1 1
a1 1
/* $OpenBSD: server-client.c,v 1.199 2016/11/15 15:17:28 nicm Exp $ */
d695 1
d808 13
d822 1
a822 1
		key_bindings_dispatch(bd, c, m);
@


1.199
log
@Turn on margins, with a couple of fixes (only limit to the pane for line
feeds, and do not move cursor to end for full width panes).
@
text
@d1 1
a1 1
/* $OpenBSD: server-client.c,v 1.198 2016/11/15 14:02:32 nicm Exp $ */
d331 1
a331 1
	} else if (MOUSE_BUTTONS(m->b) == 3) {
d426 1
a426 1
	if (type != DRAG && c->tty.mouse_drag_flag) {
@


1.198
log
@Initial attempt to make use of left and right margins if the terminal
supports them (that is, if it advertises itself as a VT420 - probably
just xterm). These are the vertical equivalent of the scroll region and
allow much faster scrolling of panes that do not take up the full width
of the terminal.
@
text
@d1 1
a1 1
/* $OpenBSD: server-client.c,v 1.197 2016/10/19 09:22:07 nicm Exp $ */
d1006 2
a1007 2
	tty_region(&c->tty, 0, c->tty.sy - 1);
	tty_margin(&c->tty, 0, c->tty.sx - 1);
@


1.197
log
@Alerts are too slow, so rather than walking all sessions and windows,
add a link of winlinks to each window and a pointer to the session to
each winlink. Also rewrite the alerts processing to return to the old
behaviour (alert in any window sets the flag on any winlink).
@
text
@d1 1
a1 1
/* $OpenBSD: server-client.c,v 1.196 2016/10/16 22:06:40 nicm Exp $ */
d1007 1
@


1.196
log
@Use the notify name string instead of going via an enum and change
existing hooks to use notifys instead.
@
text
@d1 1
a1 1
/* $OpenBSD: server-client.c,v 1.195 2016/10/16 19:04:05 nicm Exp $ */
d856 1
d870 1
d875 2
a876 1
				server_client_check_focus(wp);
a941 4

	/* Are focus events off? */
	if (!options_get_number(global_options, "focus-events"))
		return;
@


1.195
log
@Mass rename struct cmd_q to struct cmdq_item and related.
@
text
@d1 1
a1 1
/* $OpenBSD: server-client.c,v 1.194 2016/10/16 17:55:14 nicm Exp $ */
d295 1
a295 1
	hooks_run(c->session->hooks, c, NULL, "client-detached");
d1213 1
a1213 1
			hooks_run(c->session->hooks, c, NULL, "client-resized");
@


1.194
log
@Rewrite command queue handling. Each client still has a command queue,
but there is also now a global command queue. Instead of command queues
being dispatched on demand from wherever the command happens to be
added, they are now all dispatched from the top level server
loop. Command queues may now also include callbacks as well as commands,
and items may be inserted after the current command as well as at the end.

This all makes command queues significantly more predictable and easier
to use, and avoids the complex multiple nested command queues used by
source-file, if-shell and friends.

A mass rename of struct cmdq to a better name (cmdq_item probably) is
coming.
@
text
@d1 1
a1 1
/* $OpenBSD: server-client.c,v 1.193 2016/10/12 13:03:27 nicm Exp $ */
d1257 1
a1257 1
server_client_command_done(struct cmd_q *cmdq, __unused void *data)
d1259 1
a1259 1
	struct client	*c = cmdq->client;
d1268 1
a1268 1
server_client_command_error(struct cmd_q *cmdq, void *data)
d1272 1
a1272 1
	cmdq_error(cmdq, "%s", error);
@


1.193
log
@The repeat prompt in both emacs and vi (and the old one in tmux) doesn't
support line editing and instead executes a command as soon as a
non-number key is pressed. Add a -N flag to command-prompt for the same
in copy mode. Reported by Theo Buehler.
@
text
@d1 1
a1 1
/* $OpenBSD: server-client.c,v 1.192 2016/10/11 09:30:36 nicm Exp $ */
d129 1
a129 2
	c->cmdq = cmdq_new(c);
	c->cmdq->client_exit = 1;
a245 4
	c->cmdq->flags |= CMD_Q_DEAD;
	cmdq_free(c->cmdq);
	c->cmdq = NULL;

d279 3
d1255 23
d1300 1
a1300 1
		cmdq_error(c->cmdq, "command too long");
a1310 1
		cmdq_error(c->cmdq, "%s", cause);
d1316 2
a1317 4
	if (c != cfg_client || cfg_finished)
		cmdq_run(c->cmdq, cmdlist, NULL);
	else
		cmdq_append(c->cmdq, cmdlist, NULL);
d1322 2
@


1.192
log
@Support double and triple clicks (they are cumulative, so double is
fired then triple), and use for select-word and select-line in copy
mode. Inspired by a different solution from Omar Sandoval.
@
text
@d1 1
a1 1
/* $OpenBSD: server-client.c,v 1.191 2016/10/11 07:23:34 nicm Exp $ */
d730 4
a733 3
		if (!(c->flags & CLIENT_READONLY))
			status_prompt_key(c, key);
		return;
@


1.191
log
@Fundamental change to how copy mode key bindings work:

The vi-copy and emacs-copy mode key tables are gone, and instead copy
mode commands are bound in one of two normal key tables ("copy-mode" or
"copy-mode-vi"). Keys are bound to "send-keys -X copy-mode-command". So:

    bind -temacs-copy C-Up scroll-up
    bind -temacs-copy -R5 WheelUpPane scroll-up

Becomes:

    bind -Tcopy-mode C-Up send -X scroll-up
    bind -Tcopy-mode WheelUpPane send -N5 -X scroll-up

This allows the full command parser and command set to be used - for
example, we can use the normal command prompt for searching, jumping,
and so on instead of a custom one:

    bind -Tcopy-mode C-r command-prompt -p'search up' "send -X search-backward '%%'"

command-prompt also gets a -1 option to only require on key press, which
is needed for jumping.

The plan is to get rid of mode keys entirely, so more to come eventually.
@
text
@d1 1
a1 1
/* $OpenBSD: server-client.c,v 1.190 2016/10/10 21:29:23 nicm Exp $ */
d40 1
d159 1
d228 1
d305 10
a314 8
	struct session				*s = c->session;
	struct mouse_event			*m = &c->tty.mouse;
	struct window				*w;
	struct window_pane			*wp;
	enum { NOTYPE, DOWN, UP, DRAG, WHEEL }	 type = NOTYPE;
	enum { NOWHERE, PANE, STATUS, BORDER }	 where = NOWHERE;
	u_int					 x, y, b;
	key_code				 key;
d338 21
d362 12
d375 2
d589 56
d1042 9
@


1.190
log
@Loads more static, except for cmd-*.c and window-*.c.
@
text
@d1 1
a1 1
/* $OpenBSD: server-client.c,v 1.189 2016/10/09 16:24:34 nicm Exp $ */
d100 7
d597 1
d606 4
d660 12
d674 1
a674 1
	bd = RB_FIND(key_bindings, &c->keytable->key_bindings, &bd_find);
a691 1
		table = c->keytable;
d730 1
a730 1
	if (strcmp(c->keytable->name, server_client_get_key_table(c)) != 0) {
a749 4
	if (KEYC_IS_MOUSE(key))
		wp = cmd_mouse_pane(m, NULL, NULL);
	else
		wp = w->active;
@


1.189
log
@Make the CLIENT_STATUS flag imply that pane status lines are redrawn if
they are enabled and break the actual screen generation code into a
separate function. Fixes problems reported by Romain Francoise.
@
text
@d1 1
a1 1
/* $OpenBSD: server-client.c,v 1.188 2016/09/28 08:30:44 nicm Exp $ */
d35 15
a49 15
void		server_client_free(int, short, void *);
void		server_client_check_focus(struct window_pane *);
void		server_client_check_resize(struct window_pane *);
key_code	server_client_check_mouse(struct client *);
void		server_client_repeat_timer(int, short, void *);
void		server_client_check_exit(struct client *);
void		server_client_check_redraw(struct client *);
void		server_client_set_title(struct client *);
void		server_client_reset_state(struct client *);
int		server_client_assume_paste(struct session *);

void		server_client_dispatch(struct imsg *, void *);
void		server_client_dispatch_command(struct client *, struct imsg *);
void		server_client_dispatch_identify(struct client *, struct imsg *);
void		server_client_dispatch_shell(struct client *);
d267 1
a267 1
void
d292 1
a292 1
key_code
d558 1
a558 1
int
d790 1
a790 1
void
d820 1
a820 1
void
d881 1
a881 1
void
d917 1
a917 1
void
d930 1
a930 1
void
d948 1
a948 1
void
d1004 1
a1004 1
void
d1029 1
a1029 1
void
d1133 1
a1133 1
void
d1186 1
a1186 1
void
d1294 1
a1294 1
void
@


1.188
log
@Rate limit TIOCSWINSZ on a timer to avoid programs getting hammered with
SIGWINCH when the size changes rapidly. To help a problem reported by
Rui Pinheiro.
@
text
@d1 1
a1 1
/* $OpenBSD: server-client.c,v 1.187 2016/06/16 10:55:47 nicm Exp $ */
d954 1
a954 1
	int		 	 flags, masked, redraw;
d962 1
a962 9

		if (c->message_string != NULL)
			redraw = status_message_redraw(c);
		else if (c->prompt_string != NULL)
			redraw = status_prompt_redraw(c);
		else
			redraw = status_redraw(c);
		if (!redraw)
			c->flags &= ~CLIENT_STATUS;
@


1.187
log
@Allow a command to be specified to display-panes, similar to
command-prompt, rather than always just selecting the pane.
@
text
@d1 1
a1 1
/* $OpenBSD: server-client.c,v 1.186 2016/04/30 18:59:02 nicm Exp $ */
d768 2
a769 3
/* Check if pane should be resized. */
void
server_client_check_resize(struct window_pane *wp)
d771 4
a774 1
	struct winsize	ws;
d787 30
@


1.186
log
@tty_client_ready can not be internal to tty.c again.
@
text
@d1 1
a1 1
/* $OpenBSD: server-client.c,v 1.185 2016/04/29 15:00:48 nicm Exp $ */
d187 1
d610 3
a612 3
		if (wp != NULL && window_pane_visible(wp))
			window_set_active_pane(w, wp);
		server_clear_identify(c);
d619 1
a619 1
		server_clear_identify(c);
@


1.185
log
@Add option to include status text in the pane borders. If
pane-border-status is set to "top" or "bottom" (rather than "off"),
every pane has a permanent top or bottom border containing the text from
pane-border-format.

Based on a diff sent long ago by Jonathan Slenders, mostly rewritten and
simplified by me.
@
text
@d1 1
a1 1
/* $OpenBSD: server-client.c,v 1.184 2016/04/28 06:51:56 nicm Exp $ */
d857 1
a857 4
	if (c->flags & CLIENT_SUSPENDED)
		return;

	if (c->flags & CLIENT_CONTROL)
@


1.184
log
@After unlock, Update activity time after recalculate_sizes() so that the
session attached flag is correct.
@
text
@d1 1
a1 1
/* $OpenBSD: server-client.c,v 1.183 2016/03/18 07:28:27 nicm Exp $ */
d924 1
a924 1
	int		 	 flags, redraw;
d964 2
a965 1
	if (c->flags & CLIENT_BORDERS) {
d967 1
d969 1
a969 4
	}

	if (c->flags & CLIENT_STATUS) {
		tty_update_mode(tty, tty->mode, NULL);
d971 2
a972 1
	}
@


1.183
log
@Instead of reusing MouseUp at the finish of a drag, add a new key
MouseDragEnd. It can be useful to bind them separately in copy mode.
@
text
@d1 1
a1 1
/* $OpenBSD: server-client.c,v 1.182 2016/03/01 12:04:43 nicm Exp $ */
a1092 2
		if (s != NULL)
			session_update_activity(s, &c->activity_time);
d1097 3
@


1.182
log
@When a mouse drag is finished, fire a MouseUp key press, instead of
doing the drag end in code. From Stephen Coakley.
@
text
@d1 1
a1 1
/* $OpenBSD: server-client.c,v 1.181 2016/01/19 15:59:12 nicm Exp $ */
d388 2
a389 2
		 * End a mouse drag by passing a MouseUp key corresponding to
		 * the button that started the drag.
d394 1
a394 1
				key = KEYC_MOUSEUP1_PANE;
d396 1
a396 1
				key = KEYC_MOUSEUP1_STATUS;
d398 1
a398 1
				key = KEYC_MOUSEUP1_BORDER;
d402 1
a402 1
				key = KEYC_MOUSEUP2_PANE;
d404 1
a404 1
				key = KEYC_MOUSEUP2_STATUS;
d406 1
a406 1
				key = KEYC_MOUSEUP2_BORDER;
d410 1
a410 1
				key = KEYC_MOUSEUP3_PANE;
d412 1
a412 1
				key = KEYC_MOUSEUP3_STATUS;
d414 1
a414 1
				key = KEYC_MOUSEUP3_BORDER;
@


1.181
log
@I no longer use my SourceForge address so replace it.
@
text
@d1 1
a1 1
/* $OpenBSD: server-client.c,v 1.180 2015/12/16 21:50:37 nicm Exp $ */
d387 33
d421 2
a422 1
		return (KEYC_MOUSE); /* not a key, but still may want to pass */
d462 5
a466 1
		c->tty.mouse_drag_flag = 1;
@


1.180
log
@Add infrastructure to work out the best target given a pane or window
alone and use it to add pane_died and pane_exited hooks.
@
text
@d1 1
a1 1
/* $OpenBSD: server-client.c,v 1.179 2015/12/15 13:43:07 nicm Exp $ */
d4 1
a4 1
 * Copyright (c) 2009 Nicholas Marriott <nicm@@users.sourceforge.net>
@


1.179
log
@Some hooks API changes to fire a hook while waiting another cmdq and
infrastructure that will be needed soon.
@
text
@d1 1
a1 1
/* $OpenBSD: server-client.c,v 1.178 2015/12/12 18:32:24 nicm Exp $ */
d286 1
a286 1
	hooks_run(c->session->hooks, c, "client-detached");
d1030 1
a1030 1
			hooks_run(c->session->hooks, c, "client-resized");
@


1.178
log
@Add key-table option to set the default key table for a session, allows
different key bindings for different sessions and a few other things.
@
text
@d1 1
a1 1
/* $OpenBSD: server-client.c,v 1.177 2015/12/12 18:19:00 nicm Exp $ */
d286 1
a286 1
	hooks_run(c->session->hooks, "client-detached", c);
d1030 1
a1030 1
			hooks_run(c->session->hooks, "client-resized", c);
@


1.177
log
@Allow prefix and prefix2 to be set to None to disable (useful if you
would rather bind the prefix in the root table).
@
text
@d1 1
a1 1
/* $OpenBSD: server-client.c,v 1.176 2015/12/11 12:27:36 nicm Exp $ */
a34 1
void		server_client_key_table(struct client *, const char *);
d74 1
a74 1
server_client_key_table(struct client *c, const char *name)
d76 3
d84 16
d619 1
a619 1
			server_client_key_table(c, "root");
d646 1
a646 1
			server_client_key_table(c, "root");
d661 1
a661 1
		server_client_key_table(c, "root");
d668 2
a669 2
	if (strcmp(c->keytable->name, "root") != 0) {
		server_client_key_table(c, "root");
d680 1
a680 1
		server_client_key_table(c, "prefix");
d855 1
a855 1
		server_client_key_table(c, "root");
@


1.176
log
@Add cmdq as an argument to format_create and add a format for the
command name (will also be used for more later).
@
text
@d1 1
a1 1
/* $OpenBSD: server-client.c,v 1.175 2015/12/08 08:34:18 nicm Exp $ */
d312 1
a312 1
		return (KEYC_NONE);
d322 1
a322 1
			return (KEYC_NONE);
d355 1
a355 1
			return (KEYC_NONE);
d374 1
a374 1
	key = KEYC_NONE;
d486 2
a487 2
	if (key == KEYC_NONE)
		return (KEYC_NONE);
d575 1
a575 1
		if (key == KEYC_NONE)
@


1.175
log
@Remove format_create_flags and just pass flags to format_create.
@
text
@d1 1
a1 1
/* $OpenBSD: server-client.c,v 1.174 2015/12/08 01:10:31 nicm Exp $ */
d936 1
a936 1
	ft = format_create(0);
@


1.174
log
@Add hooks infrastructure, basic commands (set-hook, show-hooks) and a
couple of not very useful client hooks. This will eventually let
commands be run at various points and on notifications. Joint work with
Thomas Adam.
@
text
@d1 1
a1 1
/* $OpenBSD: server-client.c,v 1.173 2015/12/01 09:41:03 nicm Exp $ */
d936 1
a936 1
	ft = format_create();
@


1.173
log
@Do not deref wp if window_get_active_at returns NULL which can happen on
very large terminals, from Michael Graczyk.
@
text
@d1 1
a1 1
/* $OpenBSD: server-client.c,v 1.172 2015/11/23 20:53:09 nicm Exp $ */
d259 13
d1011 2
@


1.172
log
@Remove support for the UTF-8 mouse extension. This was a briefly used,
poor idea that was fairly quickly replaced by SGR mouse input (which is
now widespread). It is impossible to tell the difference between UTF-8
and non-UTF-8 mouse input; since the mouse-utf8 option was removed tmux
has not handled it correctly in any case; and it is ridiculous to have
three different forms of mouse input.
@
text
@d1 1
a1 1
/* $OpenBSD: server-client.c,v 1.171 2015/11/19 22:46:46 nicm Exp $ */
d335 1
a335 1
			if (wp != NULL)
d337 3
a339 2
			log_debug("mouse at %u,%u is on pane %%%u", x, y,
			    wp->id);
@


1.171
log
@Only assume pasting with at least two characters, reduces problems for
people who can type ^B c very fast, or who are using tmux inside
something else that buffers.
@
text
@d1 1
a1 1
/* $OpenBSD: server-client.c,v 1.170 2015/11/18 14:27:44 nicm Exp $ */
a809 11

	/*
	 * Set UTF-8 mouse input if required. If the terminal is UTF-8 and any
	 * mouse mode is in effect, turn on UTF-8 mouse input. If the receiving
	 * terminal hasn't requested it (that is, it isn't in s->mode), then
	 * it'll be converted in input_mouse.
	 */
	if ((c->tty.flags & TTY_UTF8) && (mode & ALL_MOUSE_MODES))
		mode |= MODE_MOUSE_UTF8;
	else
		mode &= ~MODE_MOUSE_UTF8;
@


1.170
log
@Use __unused rather than rolling our own.
@
text
@d1 1
a1 1
/* $OpenBSD: server-client.c,v 1.169 2015/11/14 09:41:06 nicm Exp $ */
d497 10
a506 2
	if (tv.tv_sec == 0 && tv.tv_usec < t * 1000)
		return (1);
@


1.169
log
@Push stdout and stderr to clients more aggressively, and add an event to
continue if the send fails.
@
text
@d1 1
a1 1
/* $OpenBSD: server-client.c,v 1.168 2015/11/12 11:05:34 nicm Exp $ */
d249 1
a249 1
server_client_free(unused int fd, unused short events, void *arg)
d821 1
a821 1
server_client_repeat_timer(unused int fd, unused short events, void *data)
d1217 1
a1217 1
server_client_stdout_cb(unused int fd, unused short events, void *arg)
d1258 1
a1258 1
server_client_stderr_cb(unused int fd, unused short events, void *arg)
@


1.168
log
@Support UTF-8 key bindings by expanding the key type from int to
uint64_t and converting UTF-8 to Unicode on input and the reverse on
output. (This allows key bindings, there are still omissions - the
largest being that the various prompts do not accept UTF-8.)
@
text
@d1 1
a1 1
/* $OpenBSD: server-client.c,v 1.167 2015/11/11 23:23:33 nicm Exp $ */
a1037 3

	server_push_stdout(c);
	server_push_stderr(c);
d1213 87
@


1.167
log
@Drop mouse-utf8 option and always turn on UTF-8 mouse if the client says
it supports UTF-8.
@
text
@d1 1
a1 1
/* $OpenBSD: server-client.c,v 1.166 2015/10/31 13:12:03 nicm Exp $ */
d35 16
a50 16
void	server_client_key_table(struct client *, const char *);
void	server_client_free(int, short, void *);
void	server_client_check_focus(struct window_pane *);
void	server_client_check_resize(struct window_pane *);
int	server_client_check_mouse(struct client *);
void	server_client_repeat_timer(int, short, void *);
void	server_client_check_exit(struct client *);
void	server_client_check_redraw(struct client *);
void	server_client_set_title(struct client *);
void	server_client_reset_state(struct client *);
int	server_client_assume_paste(struct session *);

void	server_client_dispatch(struct imsg *, void *);
void	server_client_dispatch_command(struct client *, struct imsg *);
void	server_client_dispatch_identify(struct client *, struct imsg *);
void	server_client_dispatch_shell(struct client *);
d260 1
a260 1
int
d270 1
a270 1
	int					 key;
d504 1
a504 1
server_client_handle_key(struct client *c, int key)
d638 2
a639 2
	if (key == options_get_number(s->options, "prefix") ||
	    key == options_get_number(s->options, "prefix2")) {
@


1.166
log
@The output log is only useful once and it means creating a file, so open
it once at startup instead of in every call to tty_open.
@
text
@d1 1
a1 1
/* $OpenBSD: server-client.c,v 1.165 2015/10/31 08:13:58 nicm Exp $ */
d804 4
a807 5
	 * Set UTF-8 mouse input if required. If the terminal is UTF-8, the
	 * user has set mouse-utf8 and any mouse mode is in effect, turn on
	 * UTF-8 mouse input. If the receiving terminal hasn't requested it
	 * (that is, it isn't in s->mode), then it'll be converted in
	 * input_mouse.
d809 1
a809 2
	if ((c->tty.flags & TTY_UTF8) &&
	    (mode & ALL_MOUSE_MODES) && options_get_number(oo, "mouse-utf8"))
@


1.165
log
@Because pledge(2) does not allow us to pass directory file descriptors
around, we can't use file descriptors for the working directory because
we will be unable to pass it to a privileged process to tell it where to
read or write files or spawn children. So move tmux back to using
strings for the current working directory. We try to check it exists
with access() when it is set but ultimately fall back to ~ if it fails
at time of use (or / if that fails too).
@
text
@d1 1
a1 1
/* $OpenBSD: server-client.c,v 1.164 2015/10/28 09:51:55 nicm Exp $ */
a1180 1
		c->tty.log_fd = -1;
@


1.164
log
@Like options, move the environ struct into environ.c.
@
text
@d1 1
a1 1
/* $OpenBSD: server-client.c,v 1.163 2015/10/27 15:58:42 nicm Exp $ */
d101 1
a101 1
	c->cwd = -1;
d197 1
a197 1
	close(c->cwd);
d1102 1
a1102 1
	const char	*data;
d1135 6
a1140 2
		if ((c->cwd = open(data, O_RDONLY)) == -1)
			c->cwd = open("/", O_RDONLY);
@


1.163
log
@Move struct options into options.c.
@
text
@d1 1
a1 1
/* $OpenBSD: server-client.c,v 1.162 2015/10/27 13:23:24 nicm Exp $ */
d62 1
a62 1
	envent = environ_find(&c->environ, "TMUX");
d98 1
a98 1
	environ_init(&c->environ);
d222 1
a222 1
	environ_free(&c->environ);
d1149 1
a1149 1
			environ_put(&c->environ, data);
@


1.162
log
@Break the common process set up, event loop and imsg dispatch code
between server and client out into a separate internal API. This will
make it easier to add another process.
@
text
@d1 1
a1 1
/* $OpenBSD: server-client.c,v 1.161 2015/10/26 23:16:18 nicm Exp $ */
d493 1
a493 1
	if ((t = options_get_number(&s->options, "assume-paste-time")) == 0)
d559 1
a559 1
		if (!options_get_number(&s->options, "mouse"))
d596 1
a596 1
		xtimeout = options_get_number(&s->options, "repeat-time");
d638 2
a639 2
	if (key == options_get_number(&s->options, "prefix") ||
	    key == options_get_number(&s->options, "prefix2")) {
d716 1
a716 1
	if (!options_get_number(&global_options, "focus-events"))
d776 1
a776 1
	struct options		*oo = &c->session->options;
d865 1
a865 1
		if (options_get_number(&s->options, "set-titles"))
d925 1
a925 1
	template = options_get_string(&s->options, "set-titles-string");
d1209 1
a1209 1
	shell = options_get_string(&global_s_options, "default-shell");
@


1.161
log
@If a mouse event has no key binding, pass it through to the pane it
happened in, not the active pane like normal key presses. Fixes problems
seen by Enrico Ghirardi.
@
text
@d1 1
a1 1
/* $OpenBSD: server-client.c,v 1.160 2015/10/26 17:17:06 nicm Exp $ */
d21 1
d26 1
d47 4
a50 4
int	server_client_msg_dispatch(struct client *);
void	server_client_msg_command(struct client *, struct imsg *);
void	server_client_msg_identify(struct client *, struct imsg *);
void	server_client_msg_shell(struct client *);
d92 1
a92 2
	imsg_init(&c->ibuf, fd);
	server_update_event(c);
d224 2
a225 4
	close(c->ibuf.fd);
	imsg_clear(&c->ibuf);
	if (event_initialized(&c->event))
		event_del(&c->event);
a258 34
/* Process a single client event. */
void
server_client_callback(int fd, short events, void *data)
{
	struct client	*c = data;

	if (c->flags & CLIENT_DEAD)
		return;

	if (fd == c->ibuf.fd) {
		if (events & EV_WRITE && msgbuf_write(&c->ibuf.w) <= 0 &&
		    errno != EAGAIN)
			goto client_lost;

		if (c->flags & CLIENT_BAD) {
			if (c->ibuf.w.queued == 0)
				goto client_lost;
			return;
		}

		if (events & EV_READ && server_client_msg_dispatch(c) != 0)
			goto client_lost;
	}

	server_push_stdout(c);
	server_push_stderr(c);

	server_update_event(c);
	return;

client_lost:
	server_client_lost(c);
}

d848 1
a848 1
	server_write_client(c, MSG_EXIT, &c->retval, sizeof c->retval);
d942 2
a943 2
int
server_client_msg_dispatch(struct client *c)
d945 1
a945 1
	struct imsg		 imsg;
d948 1
a948 1
	ssize_t			 n, datalen;
d951 7
a957 2
	if ((n = imsg_read(&c->ibuf)) == -1 || n == 0)
		return (-1);
d959 2
a960 17
	for (;;) {
		if ((n = imsg_get(&c->ibuf, &imsg)) == -1)
			return (-1);
		if (n == 0)
			return (0);

		data = imsg.data;
		datalen = imsg.hdr.len - IMSG_HEADER_SIZE;

		if (imsg.hdr.peerid != PROTOCOL_VERSION) {
			server_write_client(c, MSG_VERSION, NULL, 0);
			c->flags |= CLIENT_BAD;
			if (imsg.fd != -1)
				close(imsg.fd);
			imsg_free(&imsg);
			continue;
		}
d962 18
a979 19
		log_debug("got %u from client %p", imsg.hdr.type, c);
		switch (imsg.hdr.type) {
		case MSG_IDENTIFY_FLAGS:
		case MSG_IDENTIFY_TERM:
		case MSG_IDENTIFY_TTYNAME:
		case MSG_IDENTIFY_CWD:
		case MSG_IDENTIFY_STDIN:
		case MSG_IDENTIFY_ENVIRON:
		case MSG_IDENTIFY_CLIENTPID:
		case MSG_IDENTIFY_DONE:
			server_client_msg_identify(c, &imsg);
			break;
		case MSG_COMMAND:
			server_client_msg_command(c, &imsg);
			break;
		case MSG_STDIN:
			if (datalen != sizeof stdindata)
				fatalx("bad MSG_STDIN size");
			memcpy(&stdindata, data, sizeof stdindata);
d981 1
a981 10
			if (c->stdin_callback == NULL)
				break;
			if (stdindata.size <= 0)
				c->stdin_closed = 1;
			else {
				evbuffer_add(c->stdin_data, stdindata.data,
				    stdindata.size);
			}
			c->stdin_callback(c, c->stdin_closed,
			    c->stdin_callback_data);
d983 12
a994 3
		case MSG_RESIZE:
			if (datalen != 0)
				fatalx("bad MSG_RESIZE size");
d996 1
a996 6
			if (c->flags & CLIENT_CONTROL)
				break;
			if (tty_resize(&c->tty)) {
				recalculate_sizes();
				server_redraw_client(c);
			}
d998 8
a1005 12
		case MSG_EXITING:
			if (datalen != 0)
				fatalx("bad MSG_EXITING size");

			c->session = NULL;
			tty_close(&c->tty);
			server_write_client(c, MSG_EXITED, NULL, 0);
			break;
		case MSG_WAKEUP:
		case MSG_UNLOCK:
			if (datalen != 0)
				fatalx("bad MSG_WAKEUP size");
d1007 8
a1014 3
			if (!(c->flags & CLIENT_SUSPENDED))
				break;
			c->flags &= ~CLIENT_SUSPENDED;
d1016 3
a1018 3
			if (c->tty.fd == -1) /* exited in the meantime */
				break;
			s = c->session;
d1020 1
a1020 8
			if (gettimeofday(&c->activity_time, NULL) != 0)
				fatal("gettimeofday failed");
			if (s != NULL)
				session_update_activity(s, &c->activity_time);

			tty_start_tty(&c->tty);
			server_redraw_client(c);
			recalculate_sizes();
d1022 1
a1022 3
		case MSG_SHELL:
			if (datalen != 0)
				fatalx("bad MSG_SHELL size");
d1024 12
a1035 3
			server_client_msg_shell(c);
			break;
		}
d1037 2
a1038 1
		imsg_free(&imsg);
d1040 3
d1047 1
a1047 1
server_client_msg_command(struct client *c, struct imsg *imsg)
d1100 1
a1100 1
server_client_msg_identify(struct client *c, struct imsg *imsg)
d1174 1
a1174 1
		server_write_client(c, MSG_STDIN, NULL, 0);
d1205 1
a1205 1
server_client_msg_shell(struct client *c)
d1212 1
a1212 1
	server_write_client(c, MSG_SHELL, shell, strlen(shell) + 1);
d1214 1
a1214 1
	c->flags |= CLIENT_BAD;	/* it will die after exec */
@


1.160
log
@Some extra logging of where keys are actually going.
@
text
@d1 1
a1 1
/* $OpenBSD: server-client.c,v 1.159 2015/10/23 23:46:36 nicm Exp $ */
a553 1
	wp = w->active;
d594 2
a595 4
		if (!options_get_number(&s->options, "mouse")) {
			window_pane_key(wp, c, s, key, m);
			return;
		}
d600 2
a601 5
	if (!KEYC_IS_MOUSE(key) && server_client_assume_paste(s)) {
		if (!(c->flags & CLIENT_READONLY))
			window_pane_key(wp, c, s, key, m);
		return;
	}
d677 11
a687 1
	} else if (!(c->flags & CLIENT_READONLY))
@


1.159
log
@Pasting mouse escape sequences is unlikely, so skip them when working
out whether the user is pasting.
@
text
@d1 1
a1 1
/* $OpenBSD: server-client.c,v 1.158 2015/10/22 11:00:51 nicm Exp $ */
d372 2
@


1.158
log
@Log identify messages.
@
text
@d1 1
a1 1
/* $OpenBSD: server-client.c,v 1.157 2015/10/20 21:12:09 nicm Exp $ */
d601 1
a601 1
	if (server_client_assume_paste(s)) {
@


1.157
log
@Use client pointer not file descriptor in logging.
@
text
@d1 1
a1 1
/* $OpenBSD: server-client.c,v 1.156 2015/10/20 14:19:27 nicm Exp $ */
d1158 1
d1164 1
d1170 1
d1177 1
d1183 1
d1190 1
d1196 1
@


1.156
log
@The table could change when retrying so don't save it at start of
server_client_handle_key.
@
text
@d1 1
a1 1
/* $OpenBSD: server-client.c,v 1.155 2015/10/18 20:42:43 nicm Exp $ */
d134 1
a134 1
	log_debug("new client %d", fd);
d175 1
a175 1
	log_debug("lost client %d", c->ibuf.fd);
d241 1
a241 1
	log_debug("unref client %d (%d references)", c->ibuf.fd, c->references);
d254 1
a254 1
	log_debug("free client %d (%d references)", c->ibuf.fd, c->references);
d1001 1
a1001 1
		log_debug("got %u from client %d", imsg.hdr.type, c->ibuf.fd);
@


1.155
log
@Pass current directory as a string rather than a file descriptor because
pledge doesn't let us pass directory file descriptors.
@
text
@d1 1
a1 1
/* $OpenBSD: server-client.c,v 1.154 2015/09/16 22:24:54 nicm Exp $ */
d544 1
a544 1
	struct key_table	*table = c->keytable;
d610 1
a610 1
	bd = RB_FIND(key_bindings, &table->key_bindings, &bd_find);
d628 1
@


1.154
log
@Rename cmd_q dead flag to a general flags bitmask (will be more flags later).
@
text
@d1 1
a1 1
/* $OpenBSD: server-client.c,v 1.153 2015/09/14 10:25:52 nicm Exp $ */
d1169 4
a1172 3
		if (datalen != 0)
			fatalx("bad MSG_IDENTIFY_CWD size");
		c->cwd = imsg->fd;
@


1.153
log
@Make refresh-client force update of jobs, from Sina Siadat.
@
text
@d1 1
a1 1
/* $OpenBSD: server-client.c,v 1.152 2015/09/01 19:50:09 nicm Exp $ */
d217 1
a217 1
	c->cmdq->dead = 1;
@


1.152
log
@Tweak some error messages/comments.
@
text
@d1 1
a1 1
/* $OpenBSD: server-client.c,v 1.151 2015/08/30 15:43:40 nicm Exp $ */
d940 2
a941 1
	c->flags &= ~(CLIENT_REDRAW|CLIENT_STATUS|CLIENT_BORDERS);
@


1.151
log
@Some style nits and dead assignments.
@
text
@d1 1
a1 1
/* $OpenBSD: server-client.c,v 1.150 2015/08/29 08:54:41 nicm Exp $ */
d1063 1
a1063 1
				fatal("gettimeofday");
@


1.150
log
@We already loop over the windows in server_client_loop, so don't do it
again in server_loop just to check names.
@
text
@d1 1
a1 1
/* $OpenBSD: server-client.c,v 1.149 2015/08/28 13:01:03 nicm Exp $ */
a551 7
	wp = w->active;

	/* No session, do nothing. */
	if (c->session == NULL)
		return;
	s = c->session;
	w = c->session->curw->window;
@


1.149
log
@Make session_update_activity more useful and use it in more places.
@
text
@d1 1
a1 1
/* $OpenBSD: server-client.c,v 1.148 2015/08/28 12:16:28 nicm Exp $ */
d720 1
@


1.148
log
@Run status update on a per-client timer at status-interval.
@
text
@d1 1
a1 1
/* $OpenBSD: server-client.c,v 1.147 2015/07/29 11:56:02 nicm Exp $ */
d564 1
a564 3
	memcpy(&s->last_activity_time, &s->activity_time,
	    sizeof s->last_activity_time);
	memcpy(&s->activity_time, &c->activity_time, sizeof s->activity_time);
d982 1
d1066 1
d1070 2
a1071 2
			if (c->session != NULL)
				session_update_activity(c->session);
@


1.147
log
@status_out and associated data structures are no longer used.
@
text
@d1 1
a1 1
/* $OpenBSD: server-client.c,v 1.146 2015/07/17 06:53:47 nicm Exp $ */
d191 2
a291 36
}

/* Handle client status timer. */
void
server_client_status_timer(void)
{
	struct client	*c;
	struct session	*s;
	struct timeval	 tv;
	int		 interval;
	time_t		 difference;

	if (gettimeofday(&tv, NULL) != 0)
		fatal("gettimeofday failed");

	TAILQ_FOREACH(c, &clients, entry) {
		if (c->session == NULL)
			continue;
		if (c->message_string != NULL || c->prompt_string != NULL) {
			/*
			 * Don't need timed redraw for messages/prompts so bail
			 * now. The status timer isn't reset when they are
			 * redrawn anyway.
			 */
			continue;
		}
		s = c->session;

		if (!options_get_number(&s->options, "status"))
			continue;
		interval = options_get_number(&s->options, "status-interval");

		difference = tv.tv_sec - c->status_timer.tv_sec;
		if (interval != 0 && difference >= interval)
			c->flags |= CLIENT_STATUS;
	}
@


1.146
log
@Initialize client fd to -1 as well, from Bobby Powers.
@
text
@d1 1
a1 1
/* $OpenBSD: server-client.c,v 1.145 2015/07/13 15:51:31 nicm Exp $ */
a117 2
	RB_INIT(&c->status_new);
	RB_INIT(&c->status_old);
@


1.145
log
@Fix line endings.
@
text
@d1 1
a1 1
/* $OpenBSD: server-client.c,v 1.144 2015/07/13 15:49:31 nicm Exp $ */
d99 1
@


1.144
log
@Initialize cwd fd to -1 so that we don't close fd 0 if the client is
destroyed before it is changed. Also allow ttyname() to fail. Fixes
problems when running out of file descriptors reported by Bruno Sutic.
@
text
@d1 1
a1 1
/* $OpenBSD: server-client.c,v 1.143 2015/06/14 10:07:44 nicm Exp $ */
d99 2
a100 2
	c->cwd = -1;

d1258 1
a1258 1
	if (tty_init(&c->tty, c, c->fd, c->term) != 0) {
@


1.143
log
@Add a format for client PID (client_pid) and server PID (pid). Diff for
client_pid from Thomas Adam.
@
text
@d1 1
a1 1
/* $OpenBSD: server-client.c,v 1.142 2015/06/05 18:06:30 nicm Exp $ */
d99 2
d1258 1
a1258 1
	if (!isatty(c->fd)) {
a1262 1
	tty_init(&c->tty, c, c->fd, c->term);
@


1.142
log
@Change deref to the more sensible unref, and add a couple I missed before.
@
text
@d1 1
a1 1
/* $OpenBSD: server-client.c,v 1.141 2015/06/05 18:01:12 nicm Exp $ */
d1047 1
d1221 5
@


1.141
log
@Instead of putting dead clients on a list and checking it every loop,
use event_once to queue a callback to deal with them. Also dead clients
with references would never actually be freed because the wrap-up
functions (the callback for stdin, or status_prompt_clear) would never
be called. So call them in server_client_lost.
@
text
@d1 1
a1 1
/* $OpenBSD: server-client.c,v 1.140 2015/06/04 23:27:51 nicm Exp $ */
d225 1
a225 1
	server_client_deref(c);
d236 1
a236 1
server_client_deref(struct client *c)
d238 1
a238 1
	log_debug("deref client %d (%d references)", c->ibuf.fd, c->references);
@


1.140
log
@Move the nested check from client to server and compare the client tty
name to all the pane pty names instead of comparing socket paths. This
means that "new -d" will work without unsetting $TMUX.
@
text
@d1 1
a1 1
/* $OpenBSD: server-client.c,v 1.139 2015/05/27 13:28:04 nicm Exp $ */
d34 1
d89 1
a89 1
	c->references = 0;
d165 8
d225 1
a225 2
	TAILQ_INSERT_TAIL(&dead_clients, c, entry);
	c->flags |= CLIENT_DEAD;
d232 23
@


1.139
log
@Move the jobs output cache into the formats code so that #() work more
generally (for example, again working in set-titles-string).
@
text
@d1 1
a1 1
/* $OpenBSD: server-client.c,v 1.138 2015/05/08 15:56:49 nicm Exp $ */
d48 21
@


1.138
log
@Remove some stuff that accidentally ended up here from portable, and
remove a little-used debug function.
@
text
@d1 1
a1 1
/* $OpenBSD: server-client.c,v 1.137 2015/05/06 07:52:06 nicm Exp $ */
a159 2
	status_free_jobs(&c->status_new);
	status_free_jobs(&c->status_old);
d270 1
a270 2
		if (interval != 0 && difference >= interval) {
			status_update_jobs(c);
a271 1
		}
@


1.137
log
@Turn cursor off during redraw, pointed out by George Nachman.
@
text
@d1 1
a1 1
/* $OpenBSD: server-client.c,v 1.136 2015/04/25 18:33:59 nicm Exp $ */
a1179 5

#ifdef __CYGWIN__
	c->fd = open(c->ttyname, O_RDWR|O_NOCTTY);
	c->cwd = open(".", O_RDONLY);
#endif
@


1.136
log
@Make message log a TAILQ.
@
text
@d1 1
a1 1
/* $OpenBSD: server-client.c,v 1.135 2015/04/24 23:17:11 nicm Exp $ */
d878 1
a884 3
	flags = c->tty.flags & TTY_FREEZE;
	c->tty.flags &= ~TTY_FREEZE;

d899 3
d903 1
d907 1
d913 2
a914 1
			if (wp->flags & PANE_REDRAW)
d916 1
d920 2
a921 1
	if (c->flags & CLIENT_BORDERS)
d923 1
d925 2
a926 1
	if (c->flags & CLIENT_STATUS)
d928 1
d930 2
a931 1
	c->tty.flags |= flags;
@


1.135
log
@Convert clients list into a TAILQ.
@
text
@d1 1
a1 1
/* $OpenBSD: server-client.c,v 1.134 2015/04/22 15:30:11 nicm Exp $ */
d97 1
a97 1
	ARRAY_INIT(&c->message_log);
d141 1
a141 2
	struct message_entry	*msg;
	u_int			 i;
d177 1
a177 2
	for (i = 0; i < ARRAY_LENGTH(&c->message_log); i++) {
		msg = &ARRAY_ITEM(&c->message_log, i);
d179 2
a181 1
	ARRAY_FREE(&c->message_log);
@


1.134
log
@Change the windows array into an RB tree and fix some places where we
were only looking at the first winlink for a window in a session.
@
text
@d1 1
a1 1
/* $OpenBSD: server-client.c,v 1.133 2015/04/21 15:21:41 nicm Exp $ */
a62 1
	u_int		 i;
d110 1
a110 7
	for (i = 0; i < ARRAY_LENGTH(&clients); i++) {
		if (ARRAY_ITEM(&clients, i) == NULL) {
			ARRAY_SET(&clients, i, c);
			return;
		}
	}
	ARRAY_ADD(&clients, c);
d144 1
a144 4
	for (i = 0; i < ARRAY_LENGTH(&clients); i++) {
		if (ARRAY_ITEM(&clients, i) == c)
			ARRAY_SET(&clients, i, NULL);
	}
d198 1
a198 8
	for (i = 0; i < ARRAY_LENGTH(&dead_clients); i++) {
		if (ARRAY_ITEM(&dead_clients, i) == NULL) {
			ARRAY_SET(&dead_clients, i, c);
			break;
		}
	}
	if (i == ARRAY_LENGTH(&dead_clients))
		ARRAY_ADD(&dead_clients, c);
a248 1
	u_int		 i;
d255 2
a256 3
	for (i = 0; i < ARRAY_LENGTH(&clients); i++) {
		c = ARRAY_ITEM(&clients, i);
		if (c == NULL || c->session == NULL)
a685 6
	u_int		 	 i;

	for (i = 0; i < ARRAY_LENGTH(&clients); i++) {
		c = ARRAY_ITEM(&clients, i);
		if (c == NULL)
			continue;
d687 1
a733 1
	u_int		 i;
d761 2
a762 6
	for (i = 0; i < ARRAY_LENGTH(&clients); i++) {
		c = ARRAY_ITEM(&clients, i);
		if (c == NULL || c->session == NULL)
			continue;

		if (!(c->flags & CLIENT_FOCUSED))
@


1.133
log
@Don't eat the mouse event that triggers a drag end because we may want
to pass it on to application inside the pane.
@
text
@d1 1
a1 1
/* $OpenBSD: server-client.c,v 1.132 2015/04/20 15:34:56 nicm Exp $ */
d723 1
a723 5
	for (i = 0; i < ARRAY_LENGTH(&windows); i++) {
		w = ARRAY_ITEM(&windows, i);
		if (w == NULL)
			continue;

@


1.132
log
@Support for multiple key tables to commands to be bound to sequences of
keys. The default key bindings become the "prefix" table and -n the
"root" table. Keys may be bound in new tables with bind -T and
switch-client -T used to specify the table in which the next key should
be looked up. Based on a diff from Keith Amling.
@
text
@d1 1
a1 1
/* $OpenBSD: server-client.c,v 1.131 2015/04/19 21:34:21 nicm Exp $ */
d394 1
a394 1
		return (KEYC_NONE);
@


1.131
log
@Rewrite of tmux mouse support which was a mess. Instead of having
options for "mouse-this" and "mouse-that", mouse events may be bound as
keys and there is one option "mouse" that turns on mouse support
entirely (set -g mouse on).

See the new MOUSE SUPPORT section of the man page for description of the
key names and new flags (-t= to specify the pane or window under mouse
as a target, and send-keys -M to pass through a mouse event).

The default builtin bindings for the mouse are:

    bind -n   MouseDown1Pane select-pane -t=; send-keys -M
    bind -n MouseDown1Status select-window -t=
    bind -n   MouseDrag1Pane copy-mode -M
    bind -n MouseDrag1Border resize-pane -M

To get the effect of turning mode-mouse off, do:

    unbind -n MouseDrag1Pane
    unbind -temacs-copy MouseDrag1Pane

The old mouse options are now gone, set-option -q may be used to
suppress warnings if mixing configuration files.
@
text
@d1 1
a1 1
/* $OpenBSD: server-client.c,v 1.130 2015/04/19 21:05:27 nicm Exp $ */
d33 1
d49 9
d106 3
d180 2
d545 1
a545 1
	struct session		*s;
d549 3
a551 2
	struct key_binding	*bd;
	int		      	 xtimeout, isprefix, ispaste;
d554 1
a554 1
	if ((c->flags & (CLIENT_DEAD|CLIENT_SUSPENDED)) != 0)
d556 2
d573 1
a573 1
	/* Special case: number keys jump to pane in identify mode. */
d614 6
a619 7
	/* Is this a prefix key? */
	if (key == options_get_number(&s->options, "prefix"))
		isprefix = 1;
	else if (key == options_get_number(&s->options, "prefix2"))
		isprefix = 1;
	else
		isprefix = 0;
d621 13
a633 9
	/* Treat prefix as a regular key when pasting is detected. */
	ispaste = server_client_assume_paste(s);
	if (ispaste)
		isprefix = 0;

	/* No previous prefix key. */
	if (!(c->flags & CLIENT_PREFIX)) {
		if (isprefix) {
			c->flags |= CLIENT_PREFIX;
d635 1
a635 1
			return;
d638 19
a656 15
		/* Try as a non-prefix key binding. */
		if (ispaste || (bd = key_bindings_lookup(key)) == NULL) {
			if (!(c->flags & CLIENT_READONLY))
				window_pane_key(wp, c, s, key, m);
		} else
			key_bindings_dispatch(bd, c, m);
		return;
	}

	/* Prefix key already pressed. Reset prefix and lookup key. */
	c->flags &= ~CLIENT_PREFIX;
	server_status_client(c);
	if ((bd = key_bindings_lookup(key | KEYC_PREFIX)) == NULL) {
		/* If repeating, treat this as a key, else ignore. */
		if (c->flags & CLIENT_REPEAT) {
d658 1
a658 4
			if (isprefix)
				c->flags |= CLIENT_PREFIX;
			else if (!(c->flags & CLIENT_READONLY))
				window_pane_key(wp, c, s, key, m);
d660 5
d668 6
a673 2
	/* If already repeating, but this key can't repeat, skip it. */
	if (c->flags & CLIENT_REPEAT && !bd->can_repeat) {
d675 2
a676 5
		if (isprefix)
			c->flags |= CLIENT_PREFIX;
		else if (!(c->flags & CLIENT_READONLY))
			window_pane_key(wp, c, s, key, m);
		return;
d679 5
a683 9
	/* If this key can repeat, reset the repeat flags and timer. */
	xtimeout = options_get_number(&s->options, "repeat-time");
	if (xtimeout != 0 && bd->can_repeat) {
		c->flags |= CLIENT_PREFIX|CLIENT_REPEAT;

		tv.tv_sec = xtimeout / 1000;
		tv.tv_usec = (xtimeout % 1000) * 1000L;
		evtimer_del(&c->repeat_timer);
		evtimer_add(&c->repeat_timer, &tv);
d686 10
a695 2
	/* Dispatch the command. */
	key_bindings_dispatch(bd, c, m);
d883 3
a885 3
		if (c->flags & CLIENT_PREFIX)
			server_status_client(c);
		c->flags &= ~(CLIENT_PREFIX|CLIENT_REPEAT);
@


1.130
log
@Support setting the default window and pane background colours (window
and active pane via window-style and window-active-style options, an
individual pane by a new select-pane -P flag). From J Raynor.
@
text
@d1 1
a1 1
/* $OpenBSD: server-client.c,v 1.129 2015/03/31 17:45:10 nicm Exp $ */
d35 1
a35 1
void	server_client_check_mouse(struct client *, struct window_pane *);
a93 7
	c->tty.mouse.xb = c->tty.mouse.button = 3;
	c->tty.mouse.x = c->tty.mouse.y = -1;
	c->tty.mouse.lx = c->tty.mouse.ly = -1;
	c->tty.mouse.sx = c->tty.mouse.sy = -1;
	c->tty.mouse.event = MOUSE_EVENT_UP;
	c->tty.mouse.flags = 0;

d285 2
a286 2
void
server_client_check_mouse(struct client *c, struct window_pane *wp)
d288 130
a417 4
	struct session		*s = c->session;
	struct options		*oo = &s->options;
	struct mouse_event	*m = &c->tty.mouse;
	int			 statusat;
d419 73
a491 13
	statusat = status_at_line(c);

	/* Is this a window selection click on the status line? */
	if (statusat != -1 && m->y == (u_int)statusat &&
	    options_get_number(oo, "mouse-select-window")) {
		if (m->event & MOUSE_EVENT_CLICK) {
			status_set_window_at(c, m->x);
		} else if (m->event == MOUSE_EVENT_WHEEL) {
			if (m->wheel == MOUSE_WHEEL_UP)
				session_previous(c->session, 0);
			else if (m->wheel == MOUSE_WHEEL_DOWN)
				session_next(c->session, 0);
			server_redraw_session(s);
d493 1
a493 2
		recalculate_sizes();
		return;
d495 2
d498 7
a504 21
	/*
	 * Not on status line - adjust mouse position if status line is at the
	 * top and limit if at the bottom. From here on a struct mouse
	 * represents the offset onto the window itself.
	 */
	if (statusat == 0 && m->y > 0)
		m->y--;
	else if (statusat > 0 && m->y >= (u_int)statusat)
		m->y = statusat - 1;

	/* Is this a pane selection? */
	if (options_get_number(oo, "mouse-select-pane") &&
	    (m->event == MOUSE_EVENT_DOWN || m->event == MOUSE_EVENT_WHEEL)) {
		window_set_active_at(wp->window, m->x, m->y);
		server_redraw_window(wp->window);
		wp = wp->window->active; /* may have changed */
	}

	/* Check if trying to resize pane. */
	if (options_get_number(oo, "mouse-resize-pane"))
		layout_resize_pane_mouse(c);
d506 1
a506 2
	/* Update last and pass through to client. */
	window_pane_mouse(wp, c->session, m);
d529 1
d541 1
d545 2
a550 1

a554 3
	w = c->session->curw->window;
	wp = w->active;

d582 13
a594 3
		server_client_check_mouse(c, wp);
		return;
	}
d620 1
a620 1
				window_pane_key(wp, s, key);
d622 1
a622 1
			key_bindings_dispatch(bd, c);
d636 1
a636 1
				window_pane_key(wp, s, key);
d647 1
a647 1
			window_pane_key(wp, s, key);
d663 1
a663 1
	key_bindings_dispatch(bd, c);
a799 1
	struct options		*wo = &w->options;
d819 2
a820 2
	 * Resizing panes with the mouse requires at least button mode to give
	 * a smooth appearance.
d823 2
a824 19
	if ((c->tty.mouse.flags & MOUSE_RESIZE_PANE) &&
	    !(mode & MODE_MOUSE_BUTTON))
		mode |= MODE_MOUSE_BUTTON;

	/*
	 * Any mode will do for mouse-select-pane, but set standard mode if
	 * none.
	 */
	if ((mode & ALL_MOUSE_MODES) == 0) {
		if (TAILQ_NEXT(TAILQ_FIRST(&w->panes), entry) != NULL &&
		    options_get_number(oo, "mouse-select-pane"))
			mode |= MODE_MOUSE_STANDARD;
		else if (options_get_number(oo, "mouse-resize-pane"))
			mode |= MODE_MOUSE_STANDARD;
		else if (options_get_number(oo, "mouse-select-window"))
			mode |= MODE_MOUSE_STANDARD;
		else if (options_get_number(wo, "mode-mouse"))
			mode |= MODE_MOUSE_STANDARD;
	}
d1105 1
a1105 1
		cmdq_run(c->cmdq, cmdlist);
d1107 1
a1107 1
		cmdq_append(c->cmdq, cmdlist);
@


1.129
log
@Fix some format specifier nits, from Ben Boeckel.
@
text
@d1 1
a1 1
/* $OpenBSD: server-client.c,v 1.128 2015/02/06 17:17:12 nicm Exp $ */
d332 1
a332 2
		server_status_window(wp->window);
		server_redraw_window_borders(wp->window);
@


1.128
log
@Use formats not status_replace for set-titles-string.
@
text
@d1 1
a1 1
/* $OpenBSD: server-client.c,v 1.127 2015/02/01 23:43:23 nicm Exp $ */
d827 1
a827 1
		log_debug("got %d from client %d", imsg.hdr.type, c->ibuf.fd);
@


1.127
log
@Remove two unused arguments from status_replace.
@
text
@d1 1
a1 1
/* $OpenBSD: server-client.c,v 1.126 2014/10/22 23:18:53 nicm Exp $ */
d776 4
a779 3
	struct session	*s = c->session;
	const char	*template;
	char		*title;
d783 4
a786 1
	title = status_replace(c, NULL, template, time(NULL), 1);
d793 2
@


1.126
log
@Fix some spacing nits.
@
text
@d1 1
a1 1
/* $OpenBSD: server-client.c,v 1.125 2014/10/02 09:31:30 nicm Exp $ */
d782 1
a782 1
	title = status_replace(c, NULL, NULL, NULL, template, time(NULL), 1);
@


1.125
log
@Update status when pane selected with mouse, from Balazs Kezes.
@
text
@d1 1
a1 1
/* $OpenBSD: server-client.c,v 1.124 2014/09/01 21:50:18 nicm Exp $ */
d163 1
a163 1
		evbuffer_free (c->stderr_data);
d641 1
a641 1
		o = status && options_get_number (oo, "status-position") == 0;
@


1.124
log
@Various minor style and spacing nits.
@
text
@d1 1
a1 1
/* $OpenBSD: server-client.c,v 1.123 2014/08/09 07:33:37 nicm Exp $ */
d332 1
@


1.123
log
@Remove support for the continuous reporting "any" mouse mode which never
really worked properly and is rarely used.
@
text
@d1 1
a1 1
/* $OpenBSD: server-client.c,v 1.122 2014/07/13 20:51:08 krw Exp $ */
d917 1
a917 1
	buf = (char*)imsg->data + sizeof data;
@


1.122
log
@An EOF is a good reason to close a connection.

ok nicm@@
@
text
@d1 1
a1 1
/* $OpenBSD: server-client.c,v 1.121 2014/07/13 20:23:10 nicm Exp $ */
d650 1
a650 1
	    !(mode & (MODE_MOUSE_BUTTON|MODE_MOUSE_ANY)))
@


1.121
log
@If a client is killed while suspended with ^Z so has gone through the
MSG_EXITED dance, don't try to resume it since a) it's pointless and b)
the tty structures have been cleaned up and tmux will crash.
@
text
@d1 1
a1 1
/* $OpenBSD: server-client.c,v 1.120 2014/04/16 08:02:31 nicm Exp $ */
d227 1
a227 1
		if (events & EV_WRITE && msgbuf_write(&c->ibuf.w) < 0 &&
@


1.120
log
@Because we pass the file descriptor from client to server, tmux can't
usefully work if stdin is /dev/tty. Complain about it more clearly.
@
text
@d1 1
a1 1
/* $OpenBSD: server-client.c,v 1.119 2014/02/23 00:53:06 nicm Exp $ */
d877 3
@


1.119
log
@Change terminal-overrides to a server option (now that we have them), it
doesn't make much sense as a session option.
@
text
@d1 1
a1 1
/* $OpenBSD: server-client.c,v 1.118 2014/02/17 22:42:20 nicm Exp $ */
d121 5
@


1.118
log
@Be consistent and allow only mouse down and mouse wheel for any pane
with mouse-select-pane rather than just in copy mode, reported by Balazs
Kezes.
@
text
@d1 1
a1 1
/* $OpenBSD: server-client.c,v 1.117 2014/02/14 14:00:18 nicm Exp $ */
d117 1
a117 1
server_client_open(struct client *c, struct session *s, char **cause)
a118 3
	struct options	*oo = s != NULL ? &s->options : &global_s_options;
	char		*overrides;

d127 1
a127 2
	overrides = options_get_string(oo, "terminal-overrides");
	if (tty_open(&c->tty, overrides, cause) != 0)
@


1.117
log
@Make status-interval of zero work as indented.
@
text
@d1 1
a1 1
/* $OpenBSD: server-client.c,v 1.116 2014/02/14 13:59:01 nicm Exp $ */
d327 1
a327 1
	/* Is this a pane selection? Allow down only in copy mode. */
d329 1
a329 1
	    (m->event == MOUSE_EVENT_DOWN || wp->mode != &window_copy_mode)) {
@


1.116
log
@Style nit - no space between function name and bracket.
@
text
@d1 1
a1 1
/* $OpenBSD: server-client.c,v 1.115 2014/01/31 14:19:24 nicm Exp $ */
d283 1
a283 1
		if (difference >= interval) {
@


1.115
log
@Break up and simplify screen_redraw_screen.
@
text
@d1 1
a1 1
/* $OpenBSD: server-client.c,v 1.114 2013/11/13 20:43:37 benno Exp $ */
d71 3
a73 3
	c->stdin_data = evbuffer_new ();
	c->stdout_data = evbuffer_new ();
	c->stderr_data = evbuffer_new ();
d126 1
a126 1
		*cause = xstrdup ("not a terminal");
d177 1
a177 1
	if (event_initialized (&c->message_timer))
@


1.114
log
@from nicm: : handle msgbuf_write() returning EAGAIN
@
text
@d1 1
a1 1
/* $OpenBSD: server-client.c,v 1.113 2013/10/20 17:28:43 nicm Exp $ */
d746 1
a746 1
		screen_redraw_screen(c, 0, 0);
d760 1
a760 1
		screen_redraw_screen(c, 0, 1);
d763 1
a763 1
		screen_redraw_screen(c, 1, 0);
@


1.113
log
@Do not run any command line command from the client which starts the
server until after the configuration file completes. This prevents it
racing against run-shell or if-shell in .tmux.conf that run in the
background.
@
text
@d1 1
a1 1
/* $OpenBSD: server-client.c,v 1.112 2013/10/11 08:07:12 nicm Exp $ */
d22 1
d226 2
a227 1
		if (events & EV_WRITE && msgbuf_write(&c->ibuf.w) < 0)
@


1.112
log
@Don't leak file descriptors in the rare MSG_VERSION case. From Chris
Johnsen.
@
text
@d1 1
a1 1
/* $OpenBSD: server-client.c,v 1.111 2013/10/10 12:29:35 nicm Exp $ */
d158 2
a159 2
	evbuffer_free (c->stdin_data);
	evbuffer_free (c->stdout_data);
d935 4
a938 1
	cmdq_run(c->cmdq, cmdlist);
@


1.111
log
@We accidentally haven't been using $TMUX to work out the session for a
while and in fact it is less useful that using the client ttyname. So
don't bother and don't pass it from the client. If we need it in future
it is in c->environ.
@
text
@d1 1
a1 1
/* $OpenBSD: server-client.c,v 1.110 2013/10/10 12:27:38 nicm Exp $ */
d811 2
@


1.110
log
@Don't look at string[length - 1] if length == 0.
@
text
@d1 1
a1 1
/* $OpenBSD: server-client.c,v 1.109 2013/10/10 12:26:36 nicm Exp $ */
d64 2
@


1.109
log
@Alter how tmux handles the working directory to internally use file
descriptors rather than strings.

- Each session still has a current working directory.

- New sessions still get their working directory from the client that
  created them or its attached session if any.

- New windows are created by default in the session working directory.

- The -c flag to new, neww, splitw allows the working directory to be
  overridden.

- The -c flag to attach let's the session working directory be changed.

- The default-path option has been removed.

To get the equivalent to default-path '.', do:

        bind c neww -c $PWD

To get the equivalent of default-path '~', do:

        bind c neww -c ~

This also changes the client identify protocol to be a set of messages rather
than one as well as some other changes that should make it easier to make
backwards-compatible protocol changes in future.
@
text
@d1 1
a1 1
/* $OpenBSD: server-client.c,v 1.108 2013/10/10 12:13:56 nicm Exp $ */
d964 1
a964 1
		if (data[datalen - 1] != '\0')
d969 1
a969 1
		if (data[datalen - 1] != '\0')
d984 1
a984 1
		if (data[datalen - 1] != '\0')
@


1.108
log
@Similarly for MSG_COMMAND - allow full imsg limit not arbitrary 2048.
@
text
@d1 1
a1 1
/* $OpenBSD: server-client.c,v 1.107 2013/10/10 12:13:29 nicm Exp $ */
d44 1
a44 2
void	server_client_msg_identify(
	    struct client *, struct msg_identify_data *, int);
d153 2
d166 1
a183 1
	free(c->cwd);
a789 2
	struct msg_identify_data identifydata;
	struct msg_environ_data	 environdata;
d815 8
a822 6
		case MSG_IDENTIFY:
			if (datalen != sizeof identifydata)
				fatalx("bad MSG_IDENTIFY size");
			memcpy(&identifydata, imsg.data, sizeof identifydata);

			server_client_msg_identify(c, &identifydata, imsg.fd);
a879 9
		case MSG_ENVIRON:
			if (datalen != sizeof environdata)
				fatalx("bad MSG_ENVIRON size");
			memcpy(&environdata, imsg.data, sizeof environdata);

			environdata.var[(sizeof environdata.var) - 1] = '\0';
			if (strchr(environdata.var, '=') != NULL)
				environ_put(&c->environ, environdata.var);
			break;
a885 2
		default:
			fatalx("unexpected message");
d944 1
a944 2
server_client_msg_identify(
    struct client *c, struct msg_identify_data *data, int fd)
d946 55
a1000 4
	c->cwd = NULL;
	data->cwd[(sizeof data->cwd) - 1] = '\0';
	if (*data->cwd != '\0')
		c->cwd = xstrdup(data->cwd);
d1002 1
a1002 1
	if (data->flags & CLIENT_CONTROL) {
d1004 1
d1007 2
a1008 2
		c->flags |= CLIENT_CONTROL;
		if (data->flags & CLIENT_CONTROLCONTROL)
d1015 3
a1017 1
		close(fd);
d1021 1
a1021 1
	if (fd == -1)
d1023 3
a1025 2
	if (!isatty(fd)) {
		close(fd);
d1028 2
a1029 3
	data->term[(sizeof data->term) - 1] = '\0';
	tty_init(&c->tty, c, fd, data->term);
	if (data->flags & CLIENT_UTF8)
d1031 1
a1031 1
	if (data->flags & CLIENT_256COLOURS)
d1036 1
a1036 1
	if (!(data->flags & CLIENT_CONTROL))
@


1.107
log
@Instead of fixed size buffers for some messages, send only the string
length.
@
text
@d1 1
a1 1
/* $OpenBSD: server-client.c,v 1.106 2013/10/10 12:12:54 nicm Exp $ */
d43 1
a43 1
void	server_client_msg_command(struct client *, struct msg_command_data *);
a788 1
	struct msg_command_data	 commanddata;
d792 1
d803 2
a815 7
		case MSG_COMMAND:
			if (datalen != sizeof commanddata)
				fatalx("bad MSG_COMMAND size");
			memcpy(&commanddata, imsg.data, sizeof commanddata);

			server_client_msg_command(c, &commanddata);
			break;
d823 3
d829 1
a829 1
			memcpy(&stdindata, imsg.data, sizeof stdindata);
d904 1
a904 1
server_client_msg_command(struct client *c, struct msg_command_data *data)
d906 18
a923 7
	struct cmd_list	*cmdlist = NULL;
	int		 argc;
	char	       **argv, *cause;

	argc = data->argc;
	data->argv[(sizeof data->argv) - 1] = '\0';
	if (cmd_unpack_argv(data->argv, sizeof data->argv, argc, &argv) != 0) {
@


1.106
log
@retcode -> retval for exit message.
@
text
@d1 1
a1 1
/* $OpenBSD: server-client.c,v 1.105 2013/10/10 12:12:08 nicm Exp $ */
a697 2
	struct msg_exit_data	exitdata;

d708 1
a708 3
	exitdata.retcode = c->retval;
	server_write_client(c, MSG_EXIT, &exitdata, sizeof exitdata);

d992 1
a992 2
	struct msg_shell_data	 data;
	const char		*shell;
a994 1

d997 1
a997 2
	if (strlcpy(data.shell, shell, sizeof data.shell) >= sizeof data.shell)
		strlcpy(data.shell, _PATH_BSHELL, sizeof data.shell);
a998 1
	server_write_client(c, MSG_SHELL, &data, sizeof data);
@


1.105
log
@Merge IDENTIFY_* flags with CLIENT_* flags.
@
text
@d1 1
a1 1
/* $OpenBSD: server-client.c,v 1.104 2013/10/10 11:49:07 nicm Exp $ */
d710 1
a710 1
	exitdata.retcode = c->retcode;
@


1.104
log
@Allow the file descriptor received from the client to be -1.
@
text
@d1 1
a1 1
/* $OpenBSD: server-client.c,v 1.103 2013/06/23 13:10:46 nicm Exp $ */
d957 1
a957 1
	if (data->flags & IDENTIFY_CONTROL) {
d962 1
a962 1
		if (data->flags & IDENTIFY_TERMIOS)
d981 1
a981 1
	if (data->flags & IDENTIFY_UTF8)
d983 1
a983 1
	if (data->flags & IDENTIFY_256COLOURS)
d988 1
a988 1
	if (!(data->flags & IDENTIFY_CONTROL))
@


1.103
log
@Focus events can cause trouble if left on and they can't be turned off
during idle periods (like the other states are) because we'd miss
events. So add a server option to control them. Defaults to off.
@
text
@d1 1
a1 1
/* $OpenBSD: server-client.c,v 1.102 2013/06/23 12:51:28 nicm Exp $ */
a827 2
			if (imsg.fd == -1)
				fatalx("MSG_IDENTIFY missing fd");
d973 2
@


1.102
log
@Always push a focus event when the application turns it on, prompted by
discussion with Hayaki Saito a while ago.
@
text
@d1 1
a1 1
/* $OpenBSD: server-client.c,v 1.101 2013/04/21 21:32:00 nicm Exp $ */
d552 4
@


1.101
log
@Don't let server_client_check_focus use a dead bufferevent, from Romain
Francoise.
@
text
@d1 1
a1 1
/* $OpenBSD: server-client.c,v 1.100 2013/04/10 11:51:16 nicm Exp $ */
d551 5
d588 1
a588 1
	if (wp->flags & PANE_FOCUSED)
d594 1
a594 1
	if (!(wp->flags & PANE_FOCUSED))
@


1.100
log
@Remove some code not needed on OpenBSD.
@
text
@d1 1
a1 1
/* $OpenBSD: server-client.c,v 1.99 2013/03/27 11:17:12 nicm Exp $ */
d517 4
a520 2
			server_client_check_focus(wp);
			server_client_check_resize(wp);
d532 1
a532 1
	if (wp->fd == -1 || !(wp->flags & PANE_RESIZE))
@


1.99
log
@Remove tmux's (already minimal) 88 colour support. Such terminals are
few and unnecessary.
@
text
@d1 1
a1 1
/* $OpenBSD: server-client.c,v 1.98 2013/03/25 11:53:54 nicm Exp $ */
d537 1
a537 10
	if (ioctl(wp->fd, TIOCSWINSZ, &ws) == -1) {
#ifdef __sun
		/*
		 * Some versions of Solaris apparently can return an error when
		 * resizing; don't know why this happens, can't reproduce on
		 * other platforms and ignoring it doesn't seem to cause any
		 * issues.
		 */
		if (errno != EINVAL)
#endif
a538 1
	}
@


1.98
log
@Sort includes and fix spaces.
@
text
@d1 1
a1 1
/* $OpenBSD: server-client.c,v 1.97 2013/03/25 11:36:59 nicm Exp $ */
a983 2
	else if (data->flags & IDENTIFY_88COLOURS)
		c->tty.term_flags |= TERM_88COLOURS;
@


1.97
log
@Use single stdout and stderr for control clients.
@
text
@d1 1
a1 1
/* $OpenBSD: server-client.c,v 1.96 2013/03/25 10:03:24 nicm Exp $ */
d24 2
a27 2
#include <paths.h>
#include <stdlib.h>
@


1.96
log
@Send DSC 1000p at the beginning of a -CC client's lifetime and ST and
the end, from George Nachman.
@
text
@d1 1
a1 1
/* $OpenBSD: server-client.c,v 1.95 2013/03/24 09:57:59 nicm Exp $ */
d157 2
a158 1
	evbuffer_free (c->stderr_data);
d960 2
@


1.95
log
@Add resize-pane -Z to temporary zoom the active pane to occupy the full
window or unzoom (restored to the normal layout) if it already zoomed,
bound to C-b z by default. The pane is unzoomed on pretty much any
excuse whatsoever.

We considered making this a new layout but the requirements are quite
different from layouts so decided it is better as a special case. Each
current layout cell is saved, a temporary one-cell layout generated and
all except the active pane set to NULL.

Prompted by suggestions and scripts from several. Thanks to Aaron Jensen
and Thiago Padilha for testing an earlier version.
@
text
@d1 1
a1 1
/* $OpenBSD: server-client.c,v 1.94 2013/03/24 09:54:10 nicm Exp $ */
d960 2
@


1.94
log
@Add a command queue to standardize and simplify commands that call other
commands and allow a command to block execution of subsequent
commands. This allows run-shell and if-shell to be synchronous which has
been much requested.

Each client has a default command queue and commands are consumed one at
a time from it. A command may suspend execution from the queue by
returning CMD_RETURN_WAIT and then resume it by calling cmd_continue() -
for example run-shell does this from the callback that is fired after
the job is freed.

When the command queue becomes empty, command clients are automatically
exited (unless attaching). A callback is also fired - this is used for
nested commands in, for example, if-shell which can block execution of
the client's cmdq until a new cmdq becomes empty.

Also merge all the old error/info/print functions together and lose the
old curclient/cmdclient distinction - a cmdq is bound to one client (or
none if in the configuration file), this is a command client if
c->session is NULL otherwise an attached client.
@
text
@d1 1
a1 1
/* $OpenBSD: server-client.c,v 1.93 2013/03/24 09:28:59 nicm Exp $ */
d387 1
@


1.93
log
@Handle focus events from the terminal, from Aaron Jensen.
@
text
@d1 1
a1 1
/* $OpenBSD: server-client.c,v 1.92 2013/03/24 09:25:04 nicm Exp $ */
a47 4
void printflike2 server_client_msg_error(struct cmd_ctx *, const char *, ...);
void printflike2 server_client_msg_print(struct cmd_ctx *, const char *, ...);
void printflike2 server_client_msg_info(struct cmd_ctx *, const char *, ...);

d66 3
d183 4
a906 46
/* Callback to send error message to client. */
void printflike2
server_client_msg_error(struct cmd_ctx *ctx, const char *fmt, ...)
{
	va_list	ap;

	va_start(ap, fmt);
	evbuffer_add_vprintf(ctx->cmdclient->stderr_data, fmt, ap);
	va_end(ap);

	evbuffer_add(ctx->cmdclient->stderr_data, "\n", 1);
	server_push_stderr(ctx->cmdclient);
	ctx->cmdclient->retcode = 1;
}

/* Callback to send print message to client. */
void printflike2
server_client_msg_print(struct cmd_ctx *ctx, const char *fmt, ...)
{
	va_list	ap;

	va_start(ap, fmt);
	evbuffer_add_vprintf(ctx->cmdclient->stdout_data, fmt, ap);
	va_end(ap);

	evbuffer_add(ctx->cmdclient->stdout_data, "\n", 1);
	server_push_stdout(ctx->cmdclient);
}

/* Callback to send print message to client, if not quiet. */
void printflike2
server_client_msg_info(struct cmd_ctx *ctx, const char *fmt, ...)
{
	va_list	ap;

	if (options_get_number(&global_options, "quiet"))
		return;

	va_start(ap, fmt);
	evbuffer_add_vprintf(ctx->cmdclient->stdout_data, fmt, ap);
	va_end(ap);

	evbuffer_add(ctx->cmdclient->stdout_data, "\n", 1);
	server_push_stdout(ctx->cmdclient);
}

a910 1
	struct cmd_ctx	*ctx;
a914 6
	ctx = cmd_get_ctx(c, NULL);
	ctx->msgdata = data;
	ctx->error = server_client_msg_error;
	ctx->print = server_client_msg_print;
	ctx->info = server_client_msg_info;

d918 1
a918 1
		server_client_msg_error(ctx, "command too long");
d928 2
a929 2
	if ((cmdlist = cmd_list_parse(argc, argv, &cause)) == NULL) {
		server_client_msg_error(ctx, "%s", cause);
d935 1
a935 10
	switch (cmd_list_exec(cmdlist, ctx))
	{
	case CMD_RETURN_ERROR:
	case CMD_RETURN_NORMAL:
		c->flags |= CLIENT_EXIT;
		break;
	case CMD_RETURN_ATTACH:
	case CMD_RETURN_YIELD:
		break;
	}
a936 1
	cmd_free_ctx(ctx);
a941 1
	cmd_free_ctx(ctx);
@


1.92
log
@Do pane resize ioctls once at the end of the server loop rather than
immediately.
@
text
@d1 1
a1 1
/* $OpenBSD: server-client.c,v 1.91 2013/03/24 09:18:16 nicm Exp $ */
d100 2
d552 2
a553 1
	struct session	*s;
d568 2
a569 2
	 * If our window is the current window in any attached sessions, we're
	 * focused.
d571 6
a576 2
	RB_FOREACH(s, sessions, &sessions) {
		if (s->flags & SESSION_UNATTACHED)
d578 4
a581 1
		if (s->curw->window == wp->window)
@


1.91
log
@Add support for focus notifications when tmux pane changes, based on
work by Aaron Jensen.
@
text
@d1 1
a1 1
/* $OpenBSD: server-client.c,v 1.90 2013/03/22 15:54:29 nicm Exp $ */
d20 1
d33 1
d501 1
a501 1
	 * their flags now. Also check and update pane focus.
d511 1
d515 29
@


1.90
log
@Need to set clients in context before changing their reference count.
@
text
@d1 1
a1 1
/* $OpenBSD: server-client.c,v 1.89 2013/03/22 15:50:42 nicm Exp $ */
d31 1
d499 1
a499 1
	 * their flags now.
d507 2
a508 1
		TAILQ_FOREACH(wp, &w->panes, entry)
d510 1
d512 41
@


1.89
log
@Remove unnecessary initializers of cmd_ctx.
@
text
@d1 1
a1 1
/* $OpenBSD: server-client.c,v 1.88 2013/03/22 15:49:55 nicm Exp $ */
d873 1
a873 1
	ctx = cmd_get_ctx();
a874 1
	ctx->cmdclient = c;
@


1.88
log
@Add functions to allocate and free command contexts rather than doing it
all on the stack.
@
text
@d1 1
a1 1
/* $OpenBSD: server-client.c,v 1.87 2013/03/22 10:31:22 nicm Exp $ */
a874 1
	ctx->curclient = NULL;
a875 1

@


1.87
log
@No more lint means no more ARGSUSED.
@
text
@d1 1
a1 1
/* $OpenBSD: server-client.c,v 1.86 2013/03/21 18:47:01 nicm Exp $ */
d868 1
a868 1
	struct cmd_ctx	 ctx;
d873 8
a880 8
	ctx.error = server_client_msg_error;
	ctx.print = server_client_msg_print;
	ctx.info = server_client_msg_info;

	ctx.msgdata = data;
	ctx.curclient = NULL;

	ctx.cmdclient = c;
d885 1
a885 1
		server_client_msg_error(&ctx, "command too long");
d896 1
a896 1
		server_client_msg_error(&ctx, "%s", cause);
d902 1
a902 1
	switch (cmd_list_exec(cmdlist, &ctx))
d913 1
d919 2
@


1.86
log
@Add various checks to turn off bits that can't work in control mode
(such as lock).
@
text
@d1 1
a1 1
/* $OpenBSD: server-client.c,v 1.85 2013/03/21 16:14:09 nicm Exp $ */
a589 1
/* ARGSUSED */
@


1.85
log
@Add a format client_prefix which is 1 if prefix key has been
pressed, used for example #{?client_prefix,X,Y}. Also a few extra
server_client_status needed.
@
text
@d1 1
a1 1
/* $OpenBSD: server-client.c,v 1.84 2013/01/30 17:00:17 nicm Exp $ */
d359 1
d533 3
d633 1
a633 1
	if (c->flags & CLIENT_SUSPENDED)
d763 2
d934 1
a934 1
		c->flags |= (CLIENT_CONTROL|CLIENT_SUSPENDED);
d959 2
a960 1
	c->flags |= CLIENT_TERMINAL;
@


1.84
log
@Unused variable/type nit from Thomas Adam.
@
text
@d1 1
a1 1
/* $OpenBSD: server-client.c,v 1.83 2013/01/18 02:10:29 nicm Exp $ */
d421 1
d436 1
d592 3
a594 1
	if (c->flags & CLIENT_REPEAT)
d596 1
@


1.83
log
@Style nits - return (x) not return x.
@
text
@d1 1
a1 1
/* $OpenBSD: server-client.c,v 1.82 2013/01/15 22:55:29 nicm Exp $ */
d334 1
a334 1
	u_int		t;
@


1.82
log
@If timing between keys is less than (by default) 1 millisecond, assume
the text is being pasted. assume-paste-time option changes the value (0
disables). Based on a diff from Marcin Kulik.
@
text
@d1 1
a1 1
/* $OpenBSD: server-client.c,v 1.81 2012/10/26 14:35:42 nicm Exp $ */
d337 1
a337 1
		return 0;
d341 2
a342 2
		return 1;
	return 0;
@


1.81
log
@Make mouse event structure clearer by defining events (up, click, drag)
and simplifying how buttons and wheels are represented, from Ailin
Nemui. Should be no functional changes.
@
text
@d1 1
a1 1
/* $OpenBSD: server-client.c,v 1.80 2012/09/27 10:02:56 nicm Exp $ */
d37 1
d329 16
d354 1
a354 1
	int		      	 xtimeout, isprefix;
d366 3
d405 1
a405 1
	if (key == options_get_number(&c->session->options, "prefix"))
d407 1
a407 1
	else if (key == options_get_number(&c->session->options, "prefix2"))
d412 5
d419 1
a419 1
		if (isprefix)
d421 1
a421 7
		else {
			/* Try as a non-prefix key binding. */
			if ((bd = key_bindings_lookup(key)) == NULL) {
				if (!(c->flags & CLIENT_READONLY))
					window_pane_key(wp, c->session, key);
			} else
				key_bindings_dispatch(bd, c);
d423 7
d442 1
a442 1
				window_pane_key(wp, c->session, key);
d453 1
a453 1
			window_pane_key(wp, c->session, key);
d458 1
a458 1
	xtimeout = options_get_number(&c->session->options, "repeat-time");
@


1.80
log
@Do not leak file descriptor if not a tty, reported by Sebastien Marie.
@
text
@d1 1
a1 1
/* $OpenBSD: server-client.c,v 1.79 2012/09/03 09:32:38 nicm Exp $ */
d31 1
a31 2
void	server_client_check_mouse(struct client *, struct window_pane *,
	    struct mouse_event *);
d89 6
a94 2
	c->last_mouse.b = MOUSE_UP;
	c->last_mouse.x = c->last_mouse.y = -1;
d277 1
a277 2
server_client_check_mouse(
    struct client *c, struct window_pane *wp, struct mouse_event *mouse)
d279 4
a282 3
	struct session	*s = c->session;
	struct options	*oo = &s->options;
	int		 statusat;
d287 1
a287 1
	if (statusat != -1 && mouse->y == (u_int)statusat &&
d289 4
a292 7
		if (mouse->b == MOUSE_UP && c->last_mouse.b != MOUSE_UP) {
			status_set_window_at(c, mouse->x);
			recalculate_sizes();
			return;
		}
		if (mouse->b & MOUSE_45) {
			if ((mouse->b & MOUSE_BUTTON) == MOUSE_1) {
d294 1
a294 4
				server_redraw_session(s);
				recalculate_sizes();
			}
			if ((mouse->b & MOUSE_BUTTON) == MOUSE_2) {
d296 1
a296 4
				server_redraw_session(s);
				recalculate_sizes();
			}
			return;
d298 1
a298 1
		memcpy(&c->last_mouse, mouse, sizeof c->last_mouse);
d307 4
a310 4
	if (statusat == 0 &&mouse->y > 0)
		mouse->y--;
	else if (statusat > 0 && mouse->y >= (u_int)statusat)
		mouse->y = statusat - 1;
d314 2
a315 3
	    ((!(mouse->b & MOUSE_DRAG) && mouse->b != MOUSE_UP) ||
	    wp->mode != &window_copy_mode)) {
		window_set_active_at(wp->window, mouse->x, mouse->y);
d322 1
a322 1
		layout_resize_pane_mouse(c, mouse);
d325 1
a325 2
	memcpy(&c->last_mouse, mouse, sizeof c->last_mouse);
	window_pane_mouse(wp, c->session, mouse);
d380 1
a380 1
		server_client_check_mouse(c, wp, &c->tty.mouse);
d519 1
a519 1
	if ((c->last_mouse.b & MOUSE_RESIZE_PANE) &&
@


1.79
log
@Send notifications to control clients. Also don't redraw client when
suspended.
@
text
@d1 1
a1 1
/* $OpenBSD: server-client.c,v 1.78 2012/07/11 07:10:15 nicm Exp $ */
d915 4
a918 2
	if (!isatty(fd))
	    return;
@


1.78
log
@Make command exec functions return an enum rather than -1/0/1 values and
add a new value to mean "leave client running but don't attach" to fix
problems with using some commands in a command sequence. Most of the
work by Thomas Adam, problem reported by "jspenguin" on SF bug 3535531.
@
text
@d1 1
a1 1
/* $OpenBSD: server-client.c,v 1.77 2012/07/10 11:53:01 nicm Exp $ */
d606 3
d906 1
@


1.77
log
@xfree is not particularly helpful, remove it. From Thomas Adam.
@
text
@d1 1
a1 1
/* $OpenBSD: server-client.c,v 1.76 2012/06/20 12:55:55 nicm Exp $ */
d871 4
a874 1
	if (cmd_list_exec(cmdlist, &ctx) != 1)
d876 5
@


1.76
log
@Remove a couple of unused variables from redbrain at gcc dot gnu dot org.
@
text
@d1 1
a1 1
/* $OpenBSD: server-client.c,v 1.75 2012/06/18 13:16:42 nicm Exp $ */
d26 1
d155 1
a155 2
	if (c->title != NULL)
		xfree(c->title);
d162 1
a162 2
	if (c->message_string != NULL)
		xfree(c->message_string);
d167 1
a167 1
		xfree(msg->msg);
d171 3
a173 7
	if (c->prompt_string != NULL)
		xfree(c->prompt_string);
	if (c->prompt_buffer != NULL)
		xfree(c->prompt_buffer);

	if (c->cwd != NULL)
		xfree(c->cwd);
d660 1
a660 2
		if (c->title != NULL)
			xfree(c->title);
d664 1
a664 1
	xfree(title);
@


1.75
log
@Add a skeleton mode to tmux (called "control mode") that let's tmux
commands be sent and output received on stdout. This can be used to
integrate with other terminal emulators and should allow some other
things to be made simpler later. More to come so doesn't do much yet and
deliberately not documented.
@
text
@d1 1
a1 1
/* $OpenBSD: server-client.c,v 1.74 2012/05/22 14:32:28 nicm Exp $ */
a347 1
	struct options		*oo;
a365 1
	oo = &c->session->options;
@


1.74
log
@Store client in tty struct directly instead of using a callback function
pointer.
@
text
@d1 1
a1 1
/* $OpenBSD: server-client.c,v 1.73 2012/05/21 18:27:42 nicm Exp $ */
d111 3
d899 11
@


1.73
log
@Instead of passing stdin/stdout/stderr file descriptors over imsg and
handling them in the server, handle them in the client and pass buffers
over imsg. This is much tidier for some upcoming changes and the
performance hit isn't critical.

The tty fd is still passed to the server as before.

This bumps the tmux protocol version so new clients and old servers are
incompatible.
@
text
@d1 1
a1 1
/* $OpenBSD: server-client.c,v 1.72 2012/05/06 07:38:17 nicm Exp $ */
d30 2
a31 3
void	server_client_check_mouse(struct client *c,
	    struct window_pane *wp, struct mouse_event *mouse);
void	server_client_handle_key(int, struct mouse_event *, void *);
d340 1
a340 1
server_client_handle_key(int key, struct mouse_event *mouse, void *data)
a341 1
	struct client		*c = data;
d392 1
a392 1
		server_client_check_mouse(c, wp, mouse);
d900 1
a900 1
	tty_init(&c->tty, fd, data->term);
a906 2
	c->tty.key_callback = server_client_handle_key;
	c->tty.key_data = c;
@


1.72
log
@Add a helper function to open the terminal for attach-/new-session.
@
text
@d1 1
a1 1
/* $OpenBSD: server-client.c,v 1.71 2012/04/11 06:16:14 nicm Exp $ */
a37 3
void	server_client_in_callback(struct bufferevent *, short, void *);
void	server_client_out_callback(struct bufferevent *, short, void *);
void	server_client_err_callback(struct bufferevent *, short, void *);
d67 3
a69 3
	c->stdin_event = NULL;
	c->stdout_event = NULL;
	c->stderr_event = NULL;
d144 3
a146 18
	if (c->stdin_event != NULL)
		bufferevent_free(c->stdin_event);
	if (c->stdin_fd != -1) {
		setblocking(c->stdin_fd, 1);
		close(c->stdin_fd);
	}
	if (c->stdout_event != NULL)
		bufferevent_free(c->stdout_event);
	if (c->stdout_fd != -1) {
		setblocking(c->stdout_fd, 1);
		close(c->stdout_fd);
	}
	if (c->stderr_event != NULL)
		bufferevent_free(c->stderr_event);
	if (c->stderr_fd != -1) {
		setblocking(c->stderr_fd, 1);
		close(c->stderr_fd);
	}
d225 3
d591 3
a593 2
	if (c->stdout_fd != -1 && c->stdout_event != NULL &&
	    EVBUFFER_LENGTH(c->stdout_event->output) != 0)
d595 1
a595 2
	if (c->stderr_fd != -1 && c->stderr_event != NULL &&
	    EVBUFFER_LENGTH(c->stderr_event->output) != 0)
a673 49
/*
 * Error callback for client stdin. Caller must increase reference count when
 * enabling event!
 */
void
server_client_in_callback(
    unused struct bufferevent *bufev, unused short what, void *data)
{
	struct client	*c = data;

	c->references--;
	if (c->flags & CLIENT_DEAD)
		return;

	bufferevent_disable(c->stdin_event, EV_READ|EV_WRITE);
	setblocking(c->stdin_fd, 1);
	close(c->stdin_fd);
	c->stdin_fd = -1;

	if (c->stdin_callback != NULL)
		c->stdin_callback(c, c->stdin_data);
}

/* Error callback for client stdout. */
void
server_client_out_callback(
    unused struct bufferevent *bufev, unused short what, unused void *data)
{
	struct client	*c = data;

	bufferevent_disable(c->stdout_event, EV_READ|EV_WRITE);
	setblocking(c->stdout_fd, 1);
	close(c->stdout_fd);
	c->stdout_fd = -1;
}

/* Error callback for client stderr. */
void
server_client_err_callback(
    unused struct bufferevent *bufev, unused short what, unused void *data)
{
	struct client	*c = data;

	bufferevent_disable(c->stderr_event, EV_READ|EV_WRITE);
	setblocking(c->stderr_fd, 1);
	close(c->stderr_fd);
	c->stderr_fd = -1;
}

d682 1
a717 7
			c->stdin_fd = imsg.fd;
			c->stdin_event = bufferevent_new(c->stdin_fd,
			    NULL, NULL, server_client_in_callback, c);
			if (c->stdin_event == NULL)
				fatalx("failed to create stdin event");
			setblocking(c->stdin_fd, 0);

d720 4
a723 26
		case MSG_STDOUT:
			if (datalen != 0)
				fatalx("bad MSG_STDOUT size");
			if (imsg.fd == -1)
				fatalx("MSG_STDOUT missing fd");

			c->stdout_fd = imsg.fd;
			c->stdout_event = bufferevent_new(c->stdout_fd,
			    NULL, NULL, server_client_out_callback, c);
			if (c->stdout_event == NULL)
				fatalx("failed to create stdout event");
			setblocking(c->stdout_fd, 0);

			break;
		case MSG_STDERR:
			if (datalen != 0)
				fatalx("bad MSG_STDERR size");
			if (imsg.fd == -1)
				fatalx("MSG_STDERR missing fd");

			c->stderr_fd = imsg.fd;
			c->stderr_event = bufferevent_new(c->stderr_fd,
			    NULL, NULL, server_client_err_callback, c);
			if (c->stderr_event == NULL)
				fatalx("failed to create stderr event");
			setblocking(c->stderr_fd, 0);
d725 10
d801 1
a801 1
	evbuffer_add_vprintf(ctx->cmdclient->stderr_event->output, fmt, ap);
d804 2
a805 1
	bufferevent_write(ctx->cmdclient->stderr_event, "\n", 1);
d816 1
a816 1
	evbuffer_add_vprintf(ctx->cmdclient->stdout_event->output, fmt, ap);
d819 2
a820 1
	bufferevent_write(ctx->cmdclient->stdout_event, "\n", 1);
d833 1
a833 1
	evbuffer_add_vprintf(ctx->cmdclient->stdout_event->output, fmt, ap);
d836 2
a837 1
	bufferevent_write(ctx->cmdclient->stdout_event, "\n", 1);
a893 2
	int	tty_fd;

a900 2
	if ((tty_fd = dup(fd)) == -1)
		fatal("dup failed");
d902 1
a902 1
	tty_init(&c->tty, tty_fd, data->term);
@


1.71
log
@Stop accepting new clients for 1 second on EMFILE/ENFILE. Based on
ongoing fixes to other daemons by Theo.
@
text
@d1 1
a1 1
/* $OpenBSD: server-client.c,v 1.70 2012/03/17 21:34:34 nicm Exp $ */
d106 19
@


1.70
log
@Need to call recalculate_sizes() when changing window with the mouse,
from marcel partap.
@
text
@d1 1
a1 1
/* $OpenBSD: server-client.c,v 1.69 2012/03/17 18:24:07 nicm Exp $ */
d193 2
@


1.69
log
@Check event_initialized before event_del if event may not have been set
up; libevent2 complains about this. Reported by Moriyoshi Koizumi.
@
text
@d1 1
a1 1
/* $OpenBSD: server-client.c,v 1.68 2012/03/09 21:42:13 nicm Exp $ */
d285 1
d292 1
d297 1
@


1.68
log
@Remove some bits leftover from unused backoff code.
@
text
@d1 1
a1 1
/* $OpenBSD: server-client.c,v 1.67 2012/02/02 00:04:54 nicm Exp $ */
d156 2
a157 1
	evtimer_del(&c->identify_timer);
d161 2
a162 1
	evtimer_del(&c->message_timer);
d181 2
a182 1
	event_del(&c->event);
@


1.67
log
@Do not change pane when changing window with mouse on status line,
pointed out by Romain Francoise.
@
text
@d1 1
a1 1
/* $OpenBSD: server-client.c,v 1.66 2012/01/29 09:37:02 nicm Exp $ */
a34 1
void	server_client_check_backoff(struct client *);
@


1.66
log
@Add an option to move the status line to the top of the screen,
requested by many.
@
text
@d1 1
a1 1
/* $OpenBSD: server-client.c,v 1.65 2012/01/29 02:22:11 nicm Exp $ */
d296 2
@


1.65
log
@Call bufferevent_free before closing file descriptor associated with it
or bugs in $EventMechanism on $OtherOS makes libevent get it's knickers
in a twist. From Dylan Alex Simon.
@
text
@d1 1
a1 1
/* $OpenBSD: server-client.c,v 1.64 2012/01/21 23:51:34 nicm Exp $ */
d30 2
d267 59
d381 1
a381 37
		if (options_get_number(oo, "mouse-select-pane") &&
		    (!(options_get_number(oo, "status") &&
		       mouse->y + 1 == c->tty.sy)) &&
		    ((!(mouse->b & MOUSE_DRAG) && mouse->b != MOUSE_UP) ||
		    wp->mode != &window_copy_mode)) {
			/*
			 * Allow pane switching in copy mode only by mouse down
			 * (click).
			 */
			window_set_active_at(w, mouse->x, mouse->y);
			server_redraw_window_borders(w);
			wp = w->active;
		}
		if (mouse->y + 1 == c->tty.sy &&
		    options_get_number(oo, "mouse-select-window") &&
		    options_get_number(oo, "status")) {
			if (mouse->b == MOUSE_UP &&
			    c->last_mouse.b != MOUSE_UP) {
				status_set_window_at(c, mouse->x);
				return;
			}
			if (mouse->b & MOUSE_45) {
				if ((mouse->b & MOUSE_BUTTON) == MOUSE_1) {
					session_previous(c->session, 0);
					server_redraw_session(s);
				}
				if ((mouse->b & MOUSE_BUTTON) == MOUSE_2) {
					session_next(c->session, 0);
					server_redraw_session(s);
				}
				return;
			}
		}
		if (options_get_number(oo, "mouse-resize-pane"))
			layout_resize_pane_mouse(c, mouse);
		memcpy(&c->last_mouse, mouse, sizeof c->last_mouse);
		window_pane_mouse(wp, c->session, mouse);
d500 1
a500 1
	int			 status, mode;
d510 4
a513 2
	else
		tty_cursor(&c->tty, wp->xoff + s->cx, wp->yoff + s->cy);
@


1.64
log
@Remove unused backoff code that doesn't do any good.
@
text
@d1 1
a1 1
/* $OpenBSD: server-client.c,v 1.63 2012/01/21 08:40:09 nicm Exp $ */
d127 2
d133 2
a134 2
	if (c->stdin_event != NULL)
		bufferevent_free(c->stdin_event);
d139 2
a140 2
	if (c->stdout_event != NULL)
		bufferevent_free(c->stdout_event);
a144 2
	if (c->stderr_event != NULL)
		bufferevent_free(c->stderr_event);
@


1.63
log
@Drop the ability to have a list of keys in the prefix in favour of two
separate options, prefix and prefix2. This simplifies the code and gets
rid the data options type which was only used for this one option.

Also add a -2 flag to send-prefix to send the secondary prefix key,
fixing a cause of minor irritation.

People who want three prefix keys are out of luck :-).
@
text
@d1 1
a1 1
/* $OpenBSD: server-client.c,v 1.62 2011/12/24 08:26:59 nicm Exp $ */
a561 44
}

/*
 * Check if the client should backoff. During backoff, data from external
 * programs is not written to the terminal. When the existing data drains, the
 * client is redrawn.
 *
 * There are two backoff phases - both the tty and client have backoff flags -
 * the first to allow existing data to drain and the latter to ensure backoff
 * is disabled until the redraw has finished and prevent the redraw triggering
 * another backoff.
 */
void
server_client_check_backoff(struct client *c)
{
	struct tty	*tty = &c->tty;
	size_t		 used;

	used = EVBUFFER_LENGTH(tty->event->output);

	/*
	 * If in the second backoff phase (redrawing), don't check backoff
	 * until the redraw has completed (or enough of it to drop below the
	 * backoff threshold).
	 */
	if (c->flags & CLIENT_BACKOFF) {
		if (used > BACKOFF_THRESHOLD)
			return;
		c->flags &= ~CLIENT_BACKOFF;
		return;
	}

	/* Once drained, allow data through again and schedule redraw. */
	if (tty->flags & TTY_BACKOFF) {
		if (used != 0)
			return;
		tty->flags &= ~TTY_BACKOFF;
		c->flags |= (CLIENT_BACKOFF|CLIENT_REDRAWWINDOW|CLIENT_STATUS);
		return;
	}

	/* If too much data, start backoff. */
	if (used > BACKOFF_THRESHOLD)
		tty->flags |= TTY_BACKOFF;
@


1.62
log
@Fix so that when mouse-select-pane and mouse-select-window are both
enabled, clicking on the status line does not change the current
pane. From Romain Francoise.
@
text
@d1 1
a1 1
/* $OpenBSD: server-client.c,v 1.61 2011/08/20 20:37:30 nicm Exp $ */
a275 1
	struct keylist		*keylist;
a276 1
	u_int			 i;
d361 6
a366 8
	keylist = options_get_data(&c->session->options, "prefix");
	isprefix = 0;
	for (i = 0; i < ARRAY_LENGTH(keylist); i++) {
		if (key == ARRAY_ITEM(keylist, i)) {
			isprefix = 1;
			break;
		}
	}
@


1.61
log
@Fix a couple of memory leaks, from marcel partap.
@
text
@d1 1
a1 1
/* $OpenBSD: server-client.c,v 1.60 2011/07/08 21:51:40 nicm Exp $ */
d323 2
@


1.60
log
@Do not continue to send data to suspended/locked clients or there will
be a huge rush of it after they are resumed/unlocked. The main output
path was fine but status line updates and the terminal state reset code
were missed.
@
text
@d1 1
a1 1
/* $OpenBSD: server-client.c,v 1.59 2011/05/20 19:03:58 nicm Exp $ */
d173 2
@


1.59
log
@Support xterm(1) cursor colour change sequences through terminfo(5) Cc
(set) and Cr (reset) extensions. Originally by Sean Estabrooks, tweaked
by me and Ailin Nemui.
@
text
@d1 1
a1 1
/* $OpenBSD: server-client.c,v 1.58 2011/05/08 20:45:35 nicm Exp $ */
d476 3
@


1.58
log
@Only select pane on click, not drag. From hsim at gmx.li.
@
text
@d1 1
a1 1
/* $OpenBSD: server-client.c,v 1.57 2011/05/08 20:34:12 nicm Exp $ */
d524 1
a524 1
	tty_update_mode(&c->tty, mode);
@


1.57
log
@Add a new option, mouse-resize-pane. When on, panes may be resized by
dragging their borders. From hsim at gmx.li.
@
text
@d1 1
a1 1
/* $OpenBSD: server-client.c,v 1.56 2011/05/04 18:10:28 nicm Exp $ */
d334 2
a335 1
			if (mouse->b == MOUSE_UP) {
@


1.56
log
@Change window with mouse wheel over status line if mouse-select-window
is on, from marcel partap.
@
text
@d1 1
a1 1
/* $OpenBSD: server-client.c,v 1.55 2011/05/04 17:40:32 nicm Exp $ */
d92 3
d350 3
d485 9
a496 1
	mode = s->mode;
d500 2
@


1.55
log
@Check if mouse-select-pane is ON not off when setting mouse flags,
reported by oga.
@
text
@d1 1
a1 1
/* $OpenBSD: server-client.c,v 1.54 2011/04/19 21:31:33 nicm Exp $ */
d328 1
a328 1
		if (mouse->y + 1 == c->tty.sy && mouse->b == MOUSE_UP &&
d331 15
a345 2
			status_set_window_at(c, mouse->x);
			return;
@


1.54
log
@When mode-mouse is on (it is off by default), automatically enter copy
mode when the mouse is dragged or the mouse wheel is used. Also exit
copy mode when the mouse wheel is scrolled off the bottom. Discussed
with and written by hsim at gmx dot li.
@
text
@d1 1
a1 1
/* $OpenBSD: server-client.c,v 1.53 2011/04/18 19:49:05 nicm Exp $ */
d472 1
a472 1
		    options_get_number(oo, "mouse-select-pane") == 0)
@


1.53
log
@Add an option (mouse-select-window) which allows the mouse to be used by
clicking on the status line, written by hsim at gmx dot li.
@
text
@d1 1
a1 1
/* $OpenBSD: server-client.c,v 1.52 2011/03/29 19:30:16 nicm Exp $ */
d317 7
a323 1
		if (options_get_number(oo, "mouse-select-pane")) {
d454 1
d470 9
a478 8
	if (TAILQ_NEXT(TAILQ_FIRST(&w->panes), entry) != NULL &&
	    options_get_number(oo, "mouse-select-pane") &&
	    (mode & ALL_MOUSE_MODES) == 0)
		mode |= MODE_MOUSE_STANDARD;

	if (options_get_number(oo, "mouse-select-window") &&
	    (mode & ALL_MOUSE_MODES) == 0)
		mode |= MODE_MOUSE_STANDARD;
@


1.52
log
@Change -t on display-message to be target-pane for the #[A-Z]
replacements and add -c as target-client.
@
text
@d1 1
a1 1
/* $OpenBSD: server-client.c,v 1.51 2011/01/26 01:54:56 nicm Exp $ */
d322 6
d465 4
@


1.51
log
@Simplify the way jobs work and drop the persist type, so all jobs are
fire-and-forget.

Status jobs now managed with two trees of output (new and old), rather
than storing the output in the jobs themselves. When the status line is
processed any jobs which don't appear in the new tree are started and
the output from the old tree displayed. When a job finishes it updates
the new tree with its output and that is used for any subsequent
redraws. When the status interval expires, the new tree is moved to the
old so that all jobs are run again.

This fixes the "#(echo %H:%M:%S)" problem which would lead to thousands
of identical persistent jobs and high memory use (this can still be
achieved by adding "sleep 30" but that is much less likely to happen by
accident).
@
text
@d1 1
a1 1
/* $OpenBSD: server-client.c,v 1.50 2011/01/15 00:46:19 nicm Exp $ */
d617 1
a617 1
	title = status_replace(c, NULL, template, time(NULL), 1);
@


1.50
log
@Only set a mouse mode for mouse-select-pane if none already set by the
mode (any will do).
@
text
@d1 1
a1 1
/* $OpenBSD: server-client.c,v 1.49 2011/01/08 01:52:36 nicm Exp $ */
d82 2
a83 1
	job_tree_init(&c->status_jobs);
d143 2
a145 1
	job_tree_free(&c->status_jobs);
a225 1
	struct job	*job;
d254 1
a254 2
			RB_FOREACH(job, jobs, &c->status_jobs)
				job_run(job);
@


1.49
log
@Move all calls to fcntl(...O_NONBLOCK) into a function and clear the
flag on the stdio file descriptors before closing them (fixes things
like "tmux ls && cat").
@
text
@d1 1
a1 1
/* $OpenBSD: server-client.c,v 1.48 2011/01/03 23:35:21 nicm Exp $ */
d452 4
d458 2
a459 1
	    options_get_number(oo, "mouse-select-pane"))
@


1.48
log
@Support for UTF-8 mouse input (\033[1005h). This was added in xterm 262
and supports larger terminals than the older way.

If the new mouse-utf8 option is on, UTF-8 mouse input is enabled for all
UTF-8 terminals. The option defaults to on if LANG etc are set in the
same manner as the utf8 option.

With help and based on code from hsim at gmx.li.
@
text
@d1 1
a1 1
/* $OpenBSD: server-client.c,v 1.47 2011/01/01 01:12:09 nicm Exp $ */
a55 1
	int		 mode;
d58 1
a58 4
	if ((mode = fcntl(fd, F_GETFL)) == -1)
		fatal("fcntl failed");
	if (fcntl(fd, F_SETFL, mode|O_NONBLOCK) == -1)
		fatal("fcntl failed");
d123 2
a124 1
	if (c->stdin_fd != -1)
d126 1
d129 2
a130 1
	if (c->stdout_fd != -1)
d132 1
d135 2
a136 1
	if (c->stderr_fd != -1)
d138 1
d637 1
d653 1
d666 1
a679 1
	int			 mode;
d719 1
a719 3

			if ((mode = fcntl(c->stdin_fd, F_GETFL)) != -1)
				fcntl(c->stdin_fd, F_SETFL, mode|O_NONBLOCK);
d734 1
a735 2
			if ((mode = fcntl(c->stdout_fd, F_GETFL)) != -1)
				fcntl(c->stdout_fd, F_SETFL, mode|O_NONBLOCK);
d748 1
a749 2
			if ((mode = fcntl(c->stderr_fd, F_GETFL)) != -1)
				fcntl(c->stderr_fd, F_SETFL, mode|O_NONBLOCK);
@


1.47
log
@Don't reset the activity timer for unattached sessions every second,
this screws up the choice of most-recently-used. Instead, break the time
update into a little function and do it when the session is attached.

Pointed out by joshe@@.
@
text
@d1 1
a1 1
/* $OpenBSD: server-client.c,v 1.46 2010/12/29 21:49:06 nicm Exp $ */
d454 15
@


1.46
log
@Support all four of the xterm mouse modes. Based on a diff from hsim at
gmx.li.
@
text
@d1 1
a1 1
/* $OpenBSD: server-client.c,v 1.45 2010/12/20 00:17:22 nicm Exp $ */
d764 2
a765 5
			if (c->session != NULL) {
				memcpy(&c->session->activity_time,
				    &c->activity_time,
				    sizeof c->session->activity_time);
			}
@


1.45
log
@Use pointer rather than index for the client's last session.
@
text
@d1 1
a1 1
/* $OpenBSD: server-client.c,v 1.44 2010/12/11 18:39:25 nicm Exp $ */
d453 1
a453 1
		mode |= MODE_MOUSE;
@


1.44
log
@Track the last session for a client and add a flag to switch-client and
a key binding (L) to move a client back to its last session.
@
text
@d1 1
a1 1
/* $OpenBSD: server-client.c,v 1.43 2010/12/11 16:05:57 nicm Exp $ */
d81 1
a81 1
	c->last_session = UINT_MAX;
@


1.43
log
@Make the prompt history global for all clients which is much more useful than per-client history.
@
text
@d1 1
a1 1
/* $OpenBSD: server-client.c,v 1.42 2010/10/16 08:31:55 nicm Exp $ */
d81 1
@


1.42
log
@Trying to set FD_CLOEXEC on every fd is a lost cause, just use
closefrom() before exec.
@
text
@d1 1
a1 1
/* $OpenBSD: server-client.c,v 1.41 2010/09/26 20:43:30 nicm Exp $ */
a72 2
	ARRAY_INIT(&c->prompt_hdata);

a161 3
	for (i = 0; i < ARRAY_LENGTH(&c->prompt_hdata); i++)
		xfree(ARRAY_ITEM(&c->prompt_hdata, i));
	ARRAY_FREE(&c->prompt_hdata);
@


1.41
log
@Two new options:

- server option "exit-unattached" makes the server exit when no clients
  are attached, even if sessions are present;

- session option "destroy-unattached" destroys a session once no clients
  are attached to it.

These are useful for preventing tmux remaining in the background where
it is undesirable and when using tmux as a login shell to keep a limit
on new sessions.
@
text
@d1 1
a1 1
/* $OpenBSD: server-client.c,v 1.40 2010/08/31 22:46:59 nicm Exp $ */
a62 2
	if (fcntl(fd, F_SETFD, FD_CLOEXEC) == -1)
		fatal("fcntl failed");
a706 2
			if (fcntl(c->stdin_fd, F_SETFD, FD_CLOEXEC) == -1)
				fatal("fcntl failed");
a723 2
			if (fcntl(c->stdout_fd, F_SETFD, FD_CLOEXEC) == -1)
				fatal("fcntl failed");
a738 2
			if (fcntl(c->stderr_fd, F_SETFD, FD_CLOEXEC) == -1)
				fatal("fcntl failed");
@


1.40
log
@Add missing prototype.
@
text
@d1 1
a1 1
/* $OpenBSD: server-client.c,v 1.39 2010/08/19 17:20:26 nicm Exp $ */
d188 1
@


1.39
log
@Do not need to dup() the tty fd sent from the client because it is
already dup()d again later. Fixes a leak seen by espie@@.
@
text
@d1 1
a1 1
/* $OpenBSD: server-client.c,v 1.38 2010/08/11 07:34:43 nicm Exp $ */
d33 1
@


1.38
log
@Change the way backoff works. Instead of stopping reading from the pty
when the client tty backs up too much, just stop updating the tty and
only update the internal screen. Then when the tty recovers, force a
redraw.

This prevents a dodgy client from causing other clients to go into
backoff while still allowing tmux to be responsive (locally) when seeing
lots of output.
@
text
@d1 1
a1 1
/* $OpenBSD: server-client.c,v 1.37 2010/07/28 22:15:15 nicm Exp $ */
d699 1
a699 3
			c->stdin_fd = dup(imsg.fd);
			if (c->stdin_fd == -1)
				fatal("dup failed");
d705 3
a707 3
			if ((mode = fcntl(imsg.fd, F_GETFL)) != -1)
				fcntl(imsg.fd, F_SETFL, mode|O_NONBLOCK);
			if (fcntl(imsg.fd, F_SETFD, FD_CLOEXEC) == -1)
@


1.37
log
@dup() the stdin fd so it isn't closed twice (once for stdin, once for tty).
@
text
@d1 1
a1 1
/* $OpenBSD: server-client.c,v 1.36 2010/07/24 20:11:59 nicm Exp $ */
d495 44
d567 4
@


1.37.2.1
log
@MFC:

- - -
revision 1.39
date: 2010/08/19 17:20:26;  author: nicm;  state: Exp;  lines: +5 -7
Do not need to dup() the tty fd sent from the client because it is
already dup()d again later. Fixes a leak seen by espie@@.
- - -

from nicm re PR 6458
ok deraadt
@
text
@d1 1
a1 1
/* $OpenBSD: server-client.c,v 1.37 2010/07/28 22:15:15 nicm Exp $ */
d651 3
a653 1
			c->stdin_fd = imsg.fd;
d659 3
a661 3
			if ((mode = fcntl(c->stdin_fd, F_GETFL)) != -1)
				fcntl(c->stdin_fd, F_SETFL, mode|O_NONBLOCK);
			if (fcntl(c->stdin_fd, F_SETFD, FD_CLOEXEC) == -1)
@


1.36
log
@When changing so that the client passes its stdout and stderr as well as
stdin up to the server, I forgot one essential point - the tmux server
could now be both the producer and consumer. This happens when tmux is
run inside tmux, as well as when piping tmux commands together.

So, using stdio(3) was a bad idea - if sufficient data was written, this
could block in write(2). When that happened and the server was both
producer and consumer, it deadlocks.

Change to use libevent bufferevents for the client stdin, stdout and
stderr instead. This is trivial enough for output but requires a
callback mechanism to trigger when stdin is finished.

This relies on the underlying polling mechanism for libevent to work
with whatever devices to which the user could redirect stdin, stdout or
stderr, hence the change to use poll(2) over kqueue(2) for tmux.
@
text
@d1 1
a1 1
/* $OpenBSD: server-client.c,v 1.35 2010/07/19 18:27:38 nicm Exp $ */
d651 5
a655 3
			c->stdin_fd = imsg.fd;
			c->stdin_event = bufferevent_new(imsg.fd, NULL, NULL,
			    server_client_in_callback, c);
d673 2
a674 2
			c->stdout_event = bufferevent_new(imsg.fd, NULL, NULL,
			    server_client_out_callback, c);
d678 3
a680 3
			if ((mode = fcntl(imsg.fd, F_GETFL)) != -1)
				fcntl(imsg.fd, F_SETFL, mode|O_NONBLOCK);
			if (fcntl(imsg.fd, F_SETFD, FD_CLOEXEC) == -1)
d690 2
a691 2
			c->stderr_event = bufferevent_new(imsg.fd, NULL, NULL,
			    server_client_err_callback, c);
d695 3
a697 3
			if ((mode = fcntl(imsg.fd, F_GETFL)) != -1)
				fcntl(imsg.fd, F_SETFL, mode|O_NONBLOCK);
			if (fcntl(imsg.fd, F_SETFD, FD_CLOEXEC) == -1)
@


1.35
log
@Send the \n to stdout with the message, not stderr... doh.
@
text
@d1 1
a1 1
/* $OpenBSD: server-client.c,v 1.34 2010/07/11 17:06:45 nicm Exp $ */
d32 1
d36 3
d76 3
a78 3
	c->stdin_file = NULL;
	c->stdout_file = NULL;
	c->stderr_file = NULL;
d129 12
a140 6
	if (c->stdin_file != NULL)
		fclose(c->stdin_file);
	if (c->stdout_file != NULL)
		fclose(c->stdout_file);
	if (c->stderr_file != NULL)
		fclose(c->stderr_file);
d403 1
a403 1
		if (c == NULL || c->session == NULL)
d406 5
a410 2
		server_client_check_redraw(c);
		server_client_reset_state(c);
d473 22
d561 46
d616 1
d651 11
a661 3
			c->stdin_file = fdopen(imsg.fd, "r");
			if (c->stdin_file == NULL)
				fatal("fdopen(stdin) failed");
d670 10
a679 3
			c->stdout_file = fdopen(imsg.fd, "w");
			if (c->stdout_file == NULL)
				fatal("fdopen(stdout) failed");
d687 10
a696 3
			c->stderr_file = fdopen(imsg.fd, "w");
			if (c->stderr_file == NULL)
				fatal("fdopen(stderr) failed");
d766 1
a766 1
	vfprintf(ctx->cmdclient->stderr_file, fmt, ap);
d769 1
a769 3
	fputc('\n', ctx->cmdclient->stderr_file);
	fflush(ctx->cmdclient->stderr_file);

d780 1
a780 1
	vfprintf(ctx->cmdclient->stdout_file, fmt, ap);
d783 1
a783 2
	fputc('\n', ctx->cmdclient->stdout_file);
	fflush(ctx->cmdclient->stdout_file);
d796 1
a796 1
	vfprintf(ctx->cmdclient->stdout_file, fmt, ap);
d799 1
a799 2
	fputc('\n', ctx->cmdclient->stdout_file);
	fflush(ctx->cmdclient->stdout_file);
d806 4
a809 5
	struct cmd_ctx	 	ctx;
	struct cmd_list	       *cmdlist = NULL;
	struct msg_exit_data	exitdata;
	int			argc;
	char		      **argv, *cause;
d840 2
a841 4
	if (cmd_list_exec(cmdlist, &ctx) != 1) {
		exitdata.retcode = c->retcode;
		server_write_client(c, MSG_EXIT, &exitdata, sizeof exitdata);
	}
d848 1
a848 2
	exitdata.retcode = c->retcode;
	server_write_client(c, MSG_EXIT, &exitdata, sizeof exitdata);
@


1.34
log
@Return the command client return code with MSG_EXIT now that MSG_ERROR and
MSG_PRINT are unused.

New clients should be compatible with old tmux servers but vice versa may print
an error.
@
text
@d1 1
a1 1
/* $OpenBSD: server-client.c,v 1.33 2010/06/28 22:10:42 nicm Exp $ */
d698 1
a698 1
	fputc('\n', ctx->cmdclient->stderr_file);
@


1.33
log
@Send all three of stdin, stdout, stderr from the client to the server, so that
commands can directly make use of them. This means that load-buffer and
save-buffer can have "-" as the file to read from stdin or write to stdout.

This is a protocol version bump so the tmux server will need to be restarted
after upgrade (or an older client used).
@
text
@d1 1
a1 1
/* $OpenBSD: server-client.c,v 1.32 2010/06/05 16:47:11 nicm Exp $ */
d667 2
d706 5
a710 4
	struct cmd_ctx	 ctx;
	struct cmd_list	*cmdlist = NULL;
	int		 argc;
	char	       **argv, *cause;
d741 4
a744 2
	if (cmd_list_exec(cmdlist, &ctx) != 1)
		server_write_client(c, MSG_EXIT, NULL, 0);
d751 2
a752 1
	server_write_client(c, MSG_EXIT, NULL, 0);
@


1.32
log
@Fix problems with window sizing seen by Raghavendra D Prabhu when
starting tmux from .xinitrc.

One of the very few things the server relies on the client for now is to
pass through a message on SIGWINCH, but there is a condition where
potentially a SIGWINCH may be lost during the transition from unattached
(main.c) to attached (client.c). So trigger a size change immediately
after the client installs its SIGWINCH handler.

Also, when the terminal is resized, reset the scroll region and cursor
position. Previously, we were clearing our saved idea of these, but in
fact some terminals do not reset them on resize, so this caused problems
during redraw.

While here make a resize to the same size not cause a redraw and rename
the tmux.out output log file to include the tmux PID.
@
text
@d1 1
a1 1
/* $OpenBSD: server-client.c,v 1.31 2010/05/23 19:42:19 nicm Exp $ */
d72 4
d125 7
d569 3
d574 20
d659 1
a659 2
	struct msg_print_data	data;
	va_list			ap;
d662 1
a662 1
	xvsnprintf(data.msg, sizeof data.msg, fmt, ap);
d665 2
a666 1
	server_write_client(ctx->cmdclient, MSG_ERROR, &data, sizeof data);
d673 1
a673 2
	struct msg_print_data	data;
	va_list			ap;
d676 1
a676 1
	xvsnprintf(data.msg, sizeof data.msg, fmt, ap);
d679 2
a680 1
	server_write_client(ctx->cmdclient, MSG_PRINT, &data, sizeof data);
d687 1
a687 2
	struct msg_print_data	data;
	va_list			ap;
d693 1
a693 1
	xvsnprintf(data.msg, sizeof data.msg, fmt, ap);
d696 2
a697 1
	server_write_client(ctx->cmdclient, MSG_PRINT, &data, sizeof data);
d754 2
d761 4
d766 1
a766 1
	tty_init(&c->tty, fd, data->term);
@


1.31
log
@Pass in the session, rather than the client, to window modes' key()
function. We were only ever using the client to find the session anyway.

This allows send-key to work properly for manipulating copy mode from
outside tmux.

From Micah Cowan.
@
text
@d1 1
a1 1
/* $OpenBSD: server-client.c,v 1.30 2010/02/06 22:55:31 nicm Exp $ */
d564 4
a567 3
			tty_resize(&c->tty);
			recalculate_sizes();
			server_redraw_client(c);
@


1.30
log
@Support attaching a client read-only with a new -r flag to the attach-session
command.
@
text
@d1 1
a1 1
/* $OpenBSD: server-client.c,v 1.29 2010/02/06 18:47:41 nicm Exp $ */
d303 1
a303 1
		window_pane_mouse(wp, c, mouse);
d325 1
a325 1
					window_pane_key(wp, c, key);
d341 1
a341 1
				window_pane_key(wp, c, key);
d352 1
a352 1
			window_pane_key(wp, c, key);
@


1.29
log
@Change nested check to compare server socket path rather than just assuming
that if $TMUX is set it is nested. From Micah Cowan.
@
text
@d1 1
a1 1
/* $OpenBSD: server-client.c,v 1.28 2010/01/08 09:14:15 nicm Exp $ */
d274 2
d284 4
a287 2
	status_message_clear(c);
	server_clear_identify(c);
d289 2
a290 1
		status_prompt_key(c, key);
d296 2
d323 4
a326 3
			if ((bd = key_bindings_lookup(key)) == NULL)
				window_pane_key(wp, c, key);
			else
d340 1
a340 1
			else
d351 1
a351 1
		else
a670 1
	struct cmd	*cmd;
@


1.28
log
@mouse-select-pane has to redraw the borders now too.
@
text
@d1 1
a1 1
/* $OpenBSD: server-client.c,v 1.27 2010/01/03 12:51:05 nicm Exp $ */
a694 11

	if (data->pid != -1) {
		TAILQ_FOREACH(cmd, cmdlist, qentry) {
			if (cmd->entry->flags & CMD_CANTNEST) {
				server_client_msg_error(&ctx,
				    "sessions should be nested with care. "
				    "unset $TMUX to force");
				goto error;
			}
		}
	}
@


1.27
log
@Options to set the colour of the pane borders, with different colours for the
active pane.
@
text
@d1 1
a1 1
/* $OpenBSD: server-client.c,v 1.26 2009/12/10 09:16:52 nicm Exp $ */
d293 1
@


1.26
log
@Add "server options" which are server-wide and not bound to a session or
window. Set and displayed with "set -s" and "show -s".

Currently the only option is "quiet" (like command-line -q, allowing it to be
set from .tmux.conf), but others will come along.
@
text
@d1 1
a1 1
/* $OpenBSD: server-client.c,v 1.25 2009/12/03 22:50:10 nicm Exp $ */
d466 2
a467 2
		screen_redraw_screen(c, 0);
		c->flags &= ~CLIENT_STATUS;
d475 3
d479 1
a479 1
		screen_redraw_screen(c, 1);
d483 1
a483 1
	c->flags &= ~(CLIENT_REDRAW|CLIENT_STATUS);
@


1.25
log
@Massive spaces->tabs and trailing whitespace cleanup, hopefully for the last
time now I've configured emacs to make them displayed in really annoying
colours...
@
text
@d1 1
a1 1
/* $OpenBSD: server-client.c,v 1.24 2009/11/26 21:37:13 nicm Exp $ */
d643 1
a643 1
	if (be_quiet)
@


1.24
log
@Remove a couple of unused arguments where possible, and add /* ARGSUSED */ to
the rest to reduce lint output.
@
text
@d1 1
a1 1
/* $OpenBSD: server-client.c,v 1.23 2009/11/19 16:22:10 nicm Exp $ */
d39 1
a39 1
    	    struct client *, struct msg_identify_data *, int);
d65 1
a65 1
	
d192 1
a192 1
	server_update_event(c);	
d273 1
a273 1
	if (c->flags & CLIENT_IDENTIFY && key >= '0' && key <= '9') {	
d351 1
a351 1
		
d492 1
a492 1
	
d746 1
a746 1
	
d753 1
a753 1
	
@


1.23
log
@Two new options, window-status-format and window-status-current-format, which
allow the format of each window in the status line window list to be controlled
using similar # sequences as status-left/right.

This diff also moves part of the way towards UTF-8 support in window names but
it isn't quite there yet.
@
text
@d1 1
a1 1
/* $OpenBSD: server-client.c,v 1.22 2009/11/19 10:22:06 nicm Exp $ */
d430 1
@


1.22
log
@Don't interpret #() for display-message, it usually doesn't make sense and may
leak commands.
@
text
@d1 1
a1 1
/* $OpenBSD: server-client.c,v 1.21 2009/11/18 13:16:33 nicm Exp $ */
d492 1
a492 1
	title = status_replace(c, template, time(NULL), 1);
@


1.21
log
@Add a per-client log of status line messages displayed while that client
exists. A new message-limit session option sets the maximum number of entries
and a command, show-messages, shows the log (bound to ~ by default).

This (and prompt history) might be better as a single global log but until
there are global options it is easier for them to be per client.
@
text
@d1 1
a1 1
/* $OpenBSD: server-client.c,v 1.20 2009/11/13 18:13:18 nicm Exp $ */
d492 1
a492 1
	title = status_replace(c, template, time(NULL));
@


1.20
log
@Tidy up and fix some types, prompted by lint via deraadt.
@
text
@d1 1
a1 1
/* $OpenBSD: server-client.c,v 1.19 2009/11/11 08:00:42 nicm Exp $ */
d83 1
d105 2
a106 1
	u_int	i;
d134 5
@


1.19
log
@Only need to chmod +x or -x the socket when a client is created, lost or
attached, rather than every event loop.
@
text
@d1 1
a1 1
/* $OpenBSD: server-client.c,v 1.18 2009/11/05 08:45:08 nicm Exp $ */
d200 3
a202 1
	u_int		 i, interval;
d225 2
a226 1
		if (tv.tv_sec - c->status_timer.tv_sec >= interval) {
d228 1
a228 1
			    job_run(job);
@


1.18
log
@Switch tty key input over to happen on a read event. This is a bit more
complicated because of escape input, but in that case instead of processing a
key immediately, schedule a timer and reprocess the bufer when it expires.

This currently assumes that keys will be atomic (ie that if eg F1 is pressed
the entire sequence is present in the buffer). This is usually but not always
true, a change in the tree format so it can differentiate potential (partial)
key sequences will happens soon and will allow this to be fixed.
@
text
@d1 1
a1 1
/* $OpenBSD: server-client.c,v 1.17 2009/11/05 00:05:00 nicm Exp $ */
d159 1
@


1.17
log
@Convert the key repeat timer to an event.
@
text
@d1 1
a1 1
/* $OpenBSD: server-client.c,v 1.16 2009/11/04 23:42:51 nicm Exp $ */
d30 1
a30 1
void	server_client_handle_data(struct client *);
d34 1
d230 121
d365 2
a366 3
		server_client_handle_data(c);
		if (c->session != NULL)
			server_client_check_redraw(c);
d384 9
a392 1
/* Handle data input or output from client. */
d394 1
a394 1
server_client_handle_data(struct client *c)
d396 5
a400 64
	struct window		*w;
	struct window_pane	*wp;
	struct screen		*s;
	struct options		*oo;
	struct timeval		 tv, tv_now;
	struct key_binding	*bd;
	struct keylist		*keylist;
	struct mouse_event	 mouse;
	int		 	 key, status, xtimeout, mode, isprefix;
	u_int			 i;

	/* Get the time for the activity timer. */
	if (gettimeofday(&tv_now, NULL) != 0)
		fatal("gettimeofday failed");
	xtimeout = options_get_number(&c->session->options, "repeat-time");

	/* Process keys. */
	keylist = options_get_data(&c->session->options, "prefix");
	while (tty_keys_next(&c->tty, &key, &mouse) == 0) {
		if (c->session == NULL)
			return;
		w = c->session->curw->window;
		wp = w->active;	/* could die */
		oo = &c->session->options;

		/* Update activity timer. */
		memcpy(&c->activity_time, &tv_now, sizeof c->activity_time);
		memcpy(&c->session->activity_time,
		    &tv_now, sizeof c->session->activity_time);

		/* Special case: number keys jump to pane in identify mode. */
		if (c->flags & CLIENT_IDENTIFY && key >= '0' && key <= '9') {	
			wp = window_pane_at_index(w, key - '0');
			if (wp != NULL && window_pane_visible(wp))
				window_set_active_pane(w, wp);
			server_clear_identify(c);
			continue;
		}
		
		status_message_clear(c);
		server_clear_identify(c);
		if (c->prompt_string != NULL) {
			status_prompt_key(c, key);
			continue;
		}

		/* Check for mouse keys. */
		if (key == KEYC_MOUSE) {
			if (options_get_number(oo, "mouse-select-pane")) {
				window_set_active_at(w, mouse.x, mouse.y);
				wp = w->active;
			}
			window_pane_mouse(wp, c, &mouse);
			continue;
		}

		/* Is this a prefix key? */
		isprefix = 0;
		for (i = 0; i < ARRAY_LENGTH(keylist); i++) {
			if (key == ARRAY_ITEM(keylist, i)) {
				isprefix = 1;
				break;
			}
		}
a401 68
		/* No previous prefix key. */
		if (!(c->flags & CLIENT_PREFIX)) {
			if (isprefix)
				c->flags |= CLIENT_PREFIX;
			else {
				/* Try as a non-prefix key binding. */
				if ((bd = key_bindings_lookup(key)) == NULL)
					window_pane_key(wp, c, key);
				else
					key_bindings_dispatch(bd, c);
			}
			continue;
		}

		/* Prefix key already pressed. Reset prefix and lookup key. */
		c->flags &= ~CLIENT_PREFIX;
		if ((bd = key_bindings_lookup(key | KEYC_PREFIX)) == NULL) {
			/* If repeating, treat this as a key, else ignore. */
			if (c->flags & CLIENT_REPEAT) {
				c->flags &= ~CLIENT_REPEAT;
				if (isprefix)
					c->flags |= CLIENT_PREFIX;
				else
					window_pane_key(wp, c, key);
			}
			continue;
		}

		/* If already repeating, but this key can't repeat, skip it. */
		if (c->flags & CLIENT_REPEAT && !bd->can_repeat) {
			c->flags &= ~CLIENT_REPEAT;
			if (isprefix)
				c->flags |= CLIENT_PREFIX;
			else
				window_pane_key(wp, c, key);
			continue;
		}

		/* If this key can repeat, reset the repeat flags and timer. */
		if (xtimeout != 0 && bd->can_repeat) {
			c->flags |= CLIENT_PREFIX|CLIENT_REPEAT;

			tv.tv_sec = xtimeout / 1000;
			tv.tv_usec = (xtimeout % 1000) * 1000L;
			evtimer_del(&c->repeat_timer);
			evtimer_add(&c->repeat_timer, &tv);
		}

		/* Dispatch the command. */
		key_bindings_dispatch(bd, c);
	}
	if (c->session == NULL)
		return;
	w = c->session->curw->window;
	wp = w->active;
	oo = &c->session->options;
	s = wp->screen;

	/*
	 * Update cursor position and mode settings. The scroll region and
	 * attributes are cleared across poll(2) as this is the most likely
	 * time a user may interrupt tmux, for example with ~^Z in ssh(1). This
	 * is a compromise between excessive resets and likelihood of an
	 * interrupt.
	 *
	 * tty_region/tty_reset/tty_update_mode already take care of not
	 * resetting things that are already in their default state.
	 */
d720 2
@


1.16
log
@Move status timer check into the global once-per-second timer, this could maybe
be done better but one every second is better than once every 50 ms.
@
text
@d1 1
a1 1
/* $OpenBSD: server-client.c,v 1.15 2009/11/04 23:29:42 nicm Exp $ */
d31 1
a44 1

d87 2
d124 2
d271 1
a271 1
	struct timeval		 tv_add, tv_now;
d278 1
a278 1
	/* Check and update repeat flag. */
a281 4
	if (xtimeout != 0 && c->flags & CLIENT_REPEAT) {
		if (timercmp(&tv_now, &c->repeat_timer, >))
			c->flags &= ~(CLIENT_PREFIX|CLIENT_REPEAT);
	}
d374 4
a377 3
			tv_add.tv_sec = xtimeout / 1000;
			tv_add.tv_usec = (xtimeout % 1000) * 1000L;
			timeradd(&tv_now, &tv_add, &c->repeat_timer);
d414 10
@


1.15
log
@Use timeout events for the identify and message timers.
@
text
@d1 1
a1 1
/* $OpenBSD: server-client.c,v 1.14 2009/11/04 23:12:43 nicm Exp $ */
a32 1
void	server_client_check_timers(struct client *);
d186 39
d240 1
a240 2
		if (c->session != NULL) {
			server_client_check_timers(c);
a241 1
		}
a475 36
}

/* Check client timers. */
void
server_client_check_timers(struct client *c)
{
	struct session	*s = c->session;
	struct job	*job;
	struct timeval	 tv;
	u_int		 interval;

	if (gettimeofday(&tv, NULL) != 0)
		fatal("gettimeofday failed");

	if (c->message_string != NULL || c->prompt_string != NULL) {
		/*
		 * Don't need timed redraw for messages/prompts so bail now.
		 * The status timer isn't reset when they are redrawn anyway.
		 */
		return;

	}
	if (!options_get_number(&s->options, "status"))
		return;

	/* Check timer; resolution is only a second so don't be too clever. */
	interval = options_get_number(&s->options, "status-interval");
	if (interval == 0)
		return;
	if (tv.tv_sec < c->status_timer.tv_sec ||
	    ((u_int) tv.tv_sec) - c->status_timer.tv_sec >= interval) {
		/* Run the jobs for this client and schedule for redraw. */
		RB_FOREACH(job, jobs, &c->status_jobs)
			job_run(job);
		c->flags |= CLIENT_STATUS;
	}
@


1.14
log
@Don't reenlist the client imsg event every loop, instead have a small function
to it and call it after the event triggers or after a imsg is added.
@
text
@d1 1
a1 1
/* $OpenBSD: server-client.c,v 1.13 2009/11/04 21:47:42 nicm Exp $ */
d123 2
d127 1
a452 6

	if (c->flags & CLIENT_IDENTIFY && timercmp(&tv, &c->identify_timer, >))
		server_clear_identify(c);

	if (c->message_string != NULL && timercmp(&tv, &c->message_timer, >))
		status_message_clear(c);
@


1.13
log
@Switch tty fds over to a bufferevent.
@
text
@d1 1
a1 1
/* $OpenBSD: server-client.c,v 1.12 2009/11/04 20:50:11 nicm Exp $ */
d64 1
a153 24
/* Register clients for poll. */
void
server_client_prepare(void)
{
	struct client	*c;
	u_int		 i;
	int		 events;

	for (i = 0; i < ARRAY_LENGTH(&clients); i++) {
		if ((c = ARRAY_ITEM(&clients, i)) == NULL)
			continue;

		events = 0;
		if (!(c->flags & CLIENT_BAD))
			events |= EV_READ;
		if (c->ibuf.w.queued > 0)
			events |= EV_WRITE;
		event_del(&c->event);
		event_set(&c->event,
		    c->ibuf.fd, events, server_client_callback, c);
		event_add(&c->event, NULL);
	}
}

d176 2
a177 1
	
@


1.12
log
@Initial changes to move tmux to libevent.

This moves the client-side loops are pretty much fully over to event-based only
(tmux.c and client.c) but server-side (server.c and friends) treats libevent as
a sort of clever poll, waking up after every event to run various things.

Moving the server stuff over to bufferevents and timers and so on will come
later.
@
text
@d1 1
a1 1
/* $OpenBSD: server-client.c,v 1.11 2009/11/03 22:40:40 nicm Exp $ */
d139 1
a139 2
	event_del(&c->tty.event);
	
a173 12

		if (c->tty.fd == -1)
			continue;
		if (c->flags & CLIENT_SUSPENDED || c->session == NULL)
			continue;
		events = EV_READ;
		if (BUFFER_USED(c->tty.out) > 0)
			events |= EV_WRITE;
		event_del(&c->tty.event);
		event_set(&c->tty.event,
		    c->tty.fd, events, server_client_callback, c);
		event_add(&c->tty.event, NULL);
a196 8
			goto client_lost;
	}

	if (c->tty.fd != -1 && fd == c->tty.fd) {
		if (c->flags & CLIENT_SUSPENDED || c->session == NULL)
			return;

		if (buffer_poll(fd, events, c->tty.in, c->tty.out) != 0)
@


1.11
log
@Add an activity time for clients, like for sessions, and change session and
client lookup to pick the most recently used rather than the most recently
created - this is much more useful when used interactively and (because the
activity time is set at creation) should have no effect on source-file.

Based on a problem reported by Jan Johansson.
@
text
@d1 1
a1 1
/* $OpenBSD: server-client.c,v 1.10 2009/11/03 20:29:47 nicm Exp $ */
d21 1
d138 3
a140 1

d168 1
a168 1
			events |= POLLIN;
d170 5
a174 2
			events |= POLLOUT;
		server_poll_add(c->ibuf.fd, events, server_client_callback, c);
d180 1
a180 1
		events = POLLIN;
d182 5
a186 2
			events |= POLLOUT;
		server_poll_add(c->tty.fd, events, server_client_callback, c);
d192 1
a192 1
server_client_callback(int fd, int events, void *data)
d200 1
a200 4
		if (events & (POLLERR|POLLNVAL|POLLHUP))
			goto client_lost;

		if (events & POLLOUT && msgbuf_write(&c->ibuf.w) < 0)
d209 1
a209 1
		if (events & POLLIN && server_client_msg_dispatch(c) != 0)
d220 1
a220 1

d433 1
a433 1
	
@


1.10
log
@Change session and client activity and creation time members to have more
meaningful names.

Also, remove the code to try and update the session activity time for the
command client when a command message is received as is pointless because it
des not have a session.
@
text
@d1 1
a1 1
/* $OpenBSD: server-client.c,v 1.9 2009/10/27 13:03:33 nicm Exp $ */
d66 1
d291 1
d588 7
a594 3
			if (c->session != NULL &&
			    gettimeofday(&c->session->activity_time, NULL) != 0)
				fatal("gettimeofday failed");
@


1.9
log
@Move the poll registration functions into the server-*.c files.
@
text
@d1 1
a1 1
/* $OpenBSD: server-client.c,v 1.8 2009/10/26 21:42:04 deraadt Exp $ */
d64 1
a64 1
	if (gettimeofday(&c->tv, NULL) != 0)
d264 1
a264 1
	struct timeval	 	 tv;
d271 3
d276 1
a276 3
		if (gettimeofday(&tv, NULL) != 0)
			fatal("gettimeofday failed");
		if (timercmp(&tv, &c->repeat_timer, >))
a284 2

		c->session->activity = time(NULL);
d289 4
d370 3
a372 5
			tv.tv_sec = xtimeout / 1000;
			tv.tv_usec = (xtimeout % 1000) * 1000L;
			if (gettimeofday(&c->repeat_timer, NULL) != 0)
				fatal("gettimeofday failed");
			timeradd(&c->repeat_timer, &tv, &c->repeat_timer);
d585 5
a592 2
			if (c->session != NULL)
				c->session->activity = time(NULL);
a670 3

	if (c->session != NULL)
		c->session->activity = time(NULL);
@


1.8
log
@tabs are better; ok nicm
@
text
@d1 1
a1 1
/* $OpenBSD: server-client.c,v 1.7 2009/10/26 20:47:00 nicm Exp $ */
d148 30
@


1.7
log
@Don't do anything in the client callback if the client has already died to
avoid a use-after-free (the callback is used twice, once for the client itself
and once for the tty). Fixes crashes seen by Han Boetes.
@
text
@d1 1
a1 1
/* $OpenBSD: server-client.c,v 1.6 2009/10/25 22:00:15 nicm Exp $ */
d495 2
a496 2
        if ((n = imsg_read(&c->ibuf)) == -1 || n == 0)
                return (-1);
@


1.6
log
@Don't try to continue processing a client if the session has been destroyed.
@
text
@d1 1
a1 1
/* $OpenBSD: server-client.c,v 1.5 2009/10/25 21:11:21 nicm Exp $ */
d155 3
@


1.5
log
@Remove the -d flag to tmux and just use op/AX to detect default colours.

Irritatingly, although op can be used to tell if a terminal supports default
colours, it can't be used to set them because in some terminfo descriptions it
resets attributes as a side-effect (acts as sgr0) and in others it doesn't, so
it is not possible to determine reliably what the terminal state will be
afterwards. So if AX is missing and op is present, tmux just sends sgr0.

Anyone using -d for a terminal who finds they actually needed it can replace it
using terminal-overrides, but please let me know as it is probably an omission
from terminfo.
@
text
@d1 1
a1 1
/* $OpenBSD: server-client.c,v 1.4 2009/10/25 17:51:07 nicm Exp $ */
d202 4
a205 3

		server_client_check_timers(c);
		server_client_check_redraw(c);
@


1.4
log
@+time.h.
@
text
@d1 1
a1 1
/* $OpenBSD: server-client.c,v 1.3 2009/10/22 21:01:52 nicm Exp $ */
a705 2
	if (data->flags & IDENTIFY_HASDEFAULTS)
		c->tty.term_flags |= TERM_HASDEFAULTS;
@


1.3
log
@Redraw checks have to after handling input or pane redraw flags set by key
presses will not be acted on.
@
text
@d1 1
a1 1
/* $OpenBSD: server-client.c,v 1.2 2009/10/22 20:04:21 nicm Exp $ */
d23 1
@


1.2
log
@The client buffers have to be checked after every event in order to catch the
escape timers and properly reset the cursor.
@
text
@d1 1
a1 1
/* $OpenBSD: server-client.c,v 1.1 2009/10/22 19:41:51 nicm Exp $ */
d200 2
a203 2

		server_client_handle_data(c);
@


1.1
log
@Split the server code handling clients, jobs and windows off into separate
files from server.c (merging server-msg.c into the client file) and rather than
iterating over each set after poll(), allow a callback to be specified when the
fd is added and just walk once over the returned pollfds calling each callback
where needed.

More to come, getting this in so it is tested.
@
text
@d1 1
a1 1
/* $OpenBSD: tmux.h,v 1.145 2009/10/21 20:11:47 nicm Exp $ */
a177 1
		server_client_handle_data(c);
d186 36
a221 1
/* Input data from client. */
a372 33
}

/* Client functions that need to happen every loop. */
void
server_client_loop(void)
{
	struct client		*c;
	struct window		*w;
	struct window_pane	*wp;
	u_int		 	 i;

	for (i = 0; i < ARRAY_LENGTH(&clients); i++) {
		c = ARRAY_ITEM(&clients, i);
		if (c == NULL || c->session == NULL)
			continue;

		server_client_check_timers(c);
		server_client_check_redraw(c);
	}

	/*
	 * Any windows will have been redrawn as part of clients, so clear
	 * their flags now.
	 */
	for (i = 0; i < ARRAY_LENGTH(&windows); i++) {
		w = ARRAY_ITEM(&windows, i);
		if (w == NULL)
			continue;

		w->flags &= ~WINDOW_REDRAW;
		TAILQ_FOREACH(wp, &w->panes, entry)
			wp->flags &= ~PANE_REDRAW;
	}
@

