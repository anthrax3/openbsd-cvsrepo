head	1.36;
access;
symbols
	OPENBSD_6_2:1.36.0.4
	OPENBSD_6_2_BASE:1.36
	OPENBSD_6_1:1.33.0.4
	OPENBSD_6_1_BASE:1.33
	OPENBSD_6_0:1.18.0.4
	OPENBSD_6_0_BASE:1.18
	OPENBSD_5_9:1.18.0.2
	OPENBSD_5_9_BASE:1.18
	OPENBSD_5_8:1.12.0.6
	OPENBSD_5_8_BASE:1.12
	OPENBSD_5_7:1.12.0.2
	OPENBSD_5_7_BASE:1.12
	OPENBSD_5_6:1.10.0.6
	OPENBSD_5_6_BASE:1.10
	OPENBSD_5_5:1.10.0.4
	OPENBSD_5_5_BASE:1.10
	OPENBSD_5_4:1.8.0.6
	OPENBSD_5_4_BASE:1.8
	OPENBSD_5_3:1.8.0.4
	OPENBSD_5_3_BASE:1.8
	OPENBSD_5_2:1.8.0.2
	OPENBSD_5_2_BASE:1.8
	OPENBSD_5_1_BASE:1.7
	OPENBSD_5_1:1.7.0.2
	OPENBSD_5_0:1.5.0.8
	OPENBSD_5_0_BASE:1.5
	OPENBSD_4_9:1.5.0.6
	OPENBSD_4_9_BASE:1.5
	OPENBSD_4_8:1.5.0.4
	OPENBSD_4_8_BASE:1.5
	OPENBSD_4_7:1.5.0.2
	OPENBSD_4_7_BASE:1.5
	OPENBSD_4_6:1.1.0.4
	OPENBSD_4_6_BASE:1.1;
locks; strict;
comment	@ * @;


1.36
date	2017.08.09.13.44.36;	author nicm;	state Exp;
branches;
next	1.35;
commitid	uRe9Vyp2Gljvxkoo;

1.35
date	2017.05.31.17.56.48;	author nicm;	state Exp;
branches;
next	1.34;
commitid	whraM4PaXDvaTw5s;

1.34
date	2017.04.22.06.13.30;	author nicm;	state Exp;
branches;
next	1.33;
commitid	qj69nMLfErnppz7k;

1.33
date	2017.03.08.14.43.40;	author nicm;	state Exp;
branches;
next	1.32;
commitid	uKXHqBNfazZnvl9J;

1.32
date	2017.01.30.21.41.17;	author nicm;	state Exp;
branches;
next	1.31;
commitid	2CvN8VpguQcq8POo;

1.31
date	2017.01.24.19.11.46;	author nicm;	state Exp;
branches;
next	1.30;
commitid	kKr1lZUu2NYuA7Hw;

1.30
date	2017.01.18.08.43.21;	author nicm;	state Exp;
branches;
next	1.29;
commitid	LyKk6b5kGA6UnHQq;

1.29
date	2017.01.18.08.40.50;	author nicm;	state Exp;
branches;
next	1.28;
commitid	e9LZ8YwZPoG7kBbl;

1.28
date	2017.01.16.23.45.08;	author nicm;	state Exp;
branches;
next	1.27;
commitid	m7CcX8nZmFjimxNn;

1.27
date	2017.01.16.14.49.14;	author nicm;	state Exp;
branches;
next	1.26;
commitid	4TgBXjnsq23XHMH4;

1.26
date	2017.01.15.20.48.41;	author nicm;	state Exp;
branches;
next	1.25;
commitid	osUO2wUOqrqm0Q8V;

1.25
date	2017.01.15.20.14.36;	author nicm;	state Exp;
branches;
next	1.24;
commitid	RrTAoVXD1KFuaxWB;

1.24
date	2017.01.13.11.58.49;	author nicm;	state Exp;
branches;
next	1.23;
commitid	IPLHEki7vNAmEUCr;

1.23
date	2017.01.13.11.56.43;	author nicm;	state Exp;
branches;
next	1.22;
commitid	ue6KcgTetKiECTMk;

1.22
date	2017.01.12.15.36.35;	author nicm;	state Exp;
branches;
next	1.21;
commitid	TxelVequscBivd6R;

1.21
date	2017.01.11.14.56.44;	author nicm;	state Exp;
branches;
next	1.20;
commitid	OX4JTH65GquvrMVB;

1.20
date	2016.10.10.21.29.23;	author nicm;	state Exp;
branches;
next	1.19;
commitid	z4Hr4PZF7Ev93uEJ;

1.19
date	2016.09.26.09.02.34;	author nicm;	state Exp;
branches;
next	1.18;
commitid	LE9w75dFwI4CecIe;

1.18
date	2016.01.19.15.59.12;	author nicm;	state Exp;
branches;
next	1.17;
commitid	P3qmSOx6KrDBsb0c;

1.17
date	2015.12.11.15.46.57;	author nicm;	state Exp;
branches;
next	1.16;
commitid	7gYcVEFDdWFs0Erw;

1.16
date	2015.12.08.08.14.04;	author nicm;	state Exp;
branches;
next	1.15;
commitid	bHaj0CFZNVz1dZlv;

1.15
date	2015.11.18.13.06.54;	author nicm;	state Exp;
branches;
next	1.14;
commitid	xAU2oIxJB0E2UZoZ;

1.14
date	2015.11.13.16.06.43;	author nicm;	state Exp;
branches;
next	1.13;
commitid	NcmDayf2Lws5Hmd4;

1.13
date	2015.10.27.15.58.42;	author nicm;	state Exp;
branches;
next	1.12;
commitid	89xhQafU35Q5MQVC;

1.12
date	2015.02.18.15.32.37;	author nicm;	state Exp;
branches;
next	1.11;
commitid	tGcD7jUqiAwOVvVF;

1.11
date	2014.10.20.23.57.14;	author nicm;	state Exp;
branches;
next	1.10;
commitid	PTykIJGtZncJPE4a;

1.10
date	2014.01.28.23.07.09;	author nicm;	state Exp;
branches;
next	1.9;

1.9
date	2014.01.09.13.58.06;	author nicm;	state Exp;
branches;
next	1.8;

1.8
date	2012.07.10.11.53.01;	author nicm;	state Exp;
branches;
next	1.7;

1.7
date	2012.01.21.11.12.13;	author nicm;	state Exp;
branches;
next	1.6;

1.6
date	2012.01.21.08.40.09;	author nicm;	state Exp;
branches;
next	1.5;

1.5
date	2009.09.22.12.38.10;	author nicm;	state Exp;
branches;
next	1.4;

1.4
date	2009.09.21.14.56.03;	author nicm;	state Exp;
branches;
next	1.3;

1.3
date	2009.09.21.07.00.09;	author nicm;	state Exp;
branches;
next	1.2;

1.2
date	2009.07.21.19.54.22;	author nicm;	state Exp;
branches;
next	1.1;

1.1
date	2009.06.01.22.58.49;	author nicm;	state Exp;
branches;
next	;


desc
@@


1.36
log
@Fix filtering so it works after the change to only show windows if they
have multiple panes.
@
text
@/* $OpenBSD: options.c,v 1.35 2017/05/31 17:56:48 nicm Exp $ */

/*
 * Copyright (c) 2008 Nicholas Marriott <nicholas.marriott@@gmail.com>
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF MIND, USE, DATA OR PROFITS, WHETHER
 * IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING
 * OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */

#include <sys/types.h>

#include <ctype.h>
#include <stdarg.h>
#include <stdlib.h>
#include <string.h>

#include "tmux.h"

/*
 * Option handling; each option has a name, type and value and is stored in
 * a red-black tree.
 */

struct options_entry {
	struct options				 *owner;

	const char				 *name;
	const struct options_table_entry	 *tableentry;

	union {
		char				 *string;
		long long			  number;
		struct grid_cell		  style;
		struct {
			const char		**array;
			u_int			  arraysize;
		};
	};

	RB_ENTRY(options_entry)			  entry;
};

struct options {
	RB_HEAD(options_tree, options_entry)	 tree;
	struct options				*parent;
};

static struct options_entry	*options_add(struct options *, const char *);

#define OPTIONS_ARRAY_LIMIT 1000

#define OPTIONS_IS_STRING(o)						\
	((o)->tableentry == NULL ||					\
	    (o)->tableentry->type == OPTIONS_TABLE_STRING)
#define OPTIONS_IS_NUMBER(o) \
	((o)->tableentry != NULL &&					\
	    ((o)->tableentry->type == OPTIONS_TABLE_NUMBER ||		\
	    (o)->tableentry->type == OPTIONS_TABLE_KEY ||		\
	    (o)->tableentry->type == OPTIONS_TABLE_COLOUR ||		\
	    (o)->tableentry->type == OPTIONS_TABLE_ATTRIBUTES ||	\
	    (o)->tableentry->type == OPTIONS_TABLE_FLAG ||		\
	    (o)->tableentry->type == OPTIONS_TABLE_CHOICE))
#define OPTIONS_IS_STYLE(o) \
	((o)->tableentry != NULL &&					\
	    (o)->tableentry->type == OPTIONS_TABLE_STYLE)
#define OPTIONS_IS_ARRAY(o) \
	((o)->tableentry != NULL &&					\
	    (o)->tableentry->type == OPTIONS_TABLE_ARRAY)

static int	options_cmp(struct options_entry *, struct options_entry *);
RB_GENERATE_STATIC(options_tree, options_entry, entry, options_cmp);

static int
options_cmp(struct options_entry *lhs, struct options_entry *rhs)
{
	return (strcmp(lhs->name, rhs->name));
}

static const struct options_table_entry *
options_parent_table_entry(struct options *oo, const char *s)
{
	struct options_entry	*o;

	if (oo->parent == NULL)
		fatalx("no parent options for %s", s);
	o = options_get_only(oo->parent, s);
	if (o == NULL)
		fatalx("%s not in parent options", s);
	return (o->tableentry);
}

struct options *
options_create(struct options *parent)
{
	struct options	*oo;

	oo = xcalloc(1, sizeof *oo);
	RB_INIT(&oo->tree);
	oo->parent = parent;
	return (oo);
}

void
options_free(struct options *oo)
{
	struct options_entry	*o, *tmp;

	RB_FOREACH_SAFE(o, options_tree, &oo->tree, tmp)
		options_remove(o);
	free(oo);
}

struct options_entry *
options_first(struct options *oo)
{
	return (RB_MIN(options_tree, &oo->tree));
}

struct options_entry *
options_next(struct options_entry *o)
{
	return (RB_NEXT(options_tree, &oo->tree, o));
}

struct options_entry *
options_get_only(struct options *oo, const char *name)
{
	struct options_entry	o;

	o.name = name;
	return (RB_FIND(options_tree, &oo->tree, &o));
}

struct options_entry *
options_get(struct options *oo, const char *name)
{
	struct options_entry	*o;

	o = options_get_only(oo, name);
	while (o == NULL) {
		oo = oo->parent;
		if (oo == NULL)
			break;
		o = options_get_only(oo, name);
	}
	return (o);
}

struct options_entry *
options_empty(struct options *oo, const struct options_table_entry *oe)
{
	struct options_entry	*o;

	o = options_add(oo, oe->name);
	o->tableentry = oe;

	return (o);
}

struct options_entry *
options_default(struct options *oo, const struct options_table_entry *oe)
{
	struct options_entry	*o;

	o = options_empty(oo, oe);
	if (oe->type == OPTIONS_TABLE_ARRAY)
		options_array_assign(o, oe->default_str);
	else if (oe->type == OPTIONS_TABLE_STRING)
		o->string = xstrdup(oe->default_str);
	else if (oe->type == OPTIONS_TABLE_STYLE) {
		memcpy(&o->style, &grid_default_cell, sizeof o->style);
		style_parse(&grid_default_cell, &o->style, oe->default_str);
	} else
		o->number = oe->default_num;
	return (o);
}

static struct options_entry *
options_add(struct options *oo, const char *name)
{
	struct options_entry	*o;

	o = options_get_only(oo, name);
	if (o != NULL)
		options_remove(o);

	o = xcalloc(1, sizeof *o);
	o->owner = oo;
	o->name = xstrdup(name);

	RB_INSERT(options_tree, &oo->tree, o);
	return (o);
}

void
options_remove(struct options_entry *o)
{
	struct options	*oo = o->owner;
	u_int		 i;

	if (OPTIONS_IS_STRING(o))
		free((void *)o->string);
	else if (OPTIONS_IS_ARRAY(o)) {
		for (i = 0; i < o->arraysize; i++)
			free((void *)o->array[i]);
		free(o->array);
	}

	RB_REMOVE(options_tree, &oo->tree, o);
	free(o);
}

const char *
options_name(struct options_entry *o)
{
	return (o->name);
}

const struct options_table_entry *
options_table_entry(struct options_entry *o)
{
	return (o->tableentry);
}

void
options_array_clear(struct options_entry *o)
{
	if (OPTIONS_IS_ARRAY(o))
		o->arraysize = 0;
}

const char *
options_array_get(struct options_entry *o, u_int idx)
{
	if (!OPTIONS_IS_ARRAY(o))
		return (NULL);
	if (idx >= o->arraysize)
		return (NULL);
	return (o->array[idx]);
}

int
options_array_set(struct options_entry *o, u_int idx, const char *value,
    int append)
{
	char	*new;
	u_int	 i;

	if (!OPTIONS_IS_ARRAY(o))
		return (-1);

	if (idx >= OPTIONS_ARRAY_LIMIT)
		return (-1);
	if (idx >= o->arraysize) {
		o->array = xreallocarray(o->array, idx + 1, sizeof *o->array);
		for (i = o->arraysize; i < idx + 1; i++)
			o->array[i] = NULL;
		o->arraysize = idx + 1;
	}

	new = NULL;
	if (value != NULL) {
		if (o->array[idx] != NULL && append)
			xasprintf(&new, "%s%s", o->array[idx], value);
		else
			new = xstrdup(value);
	}

	free((void *)o->array[idx]);
	o->array[idx] = new;
	return (0);
}

int
options_array_size(struct options_entry *o, u_int *size)
{
	if (!OPTIONS_IS_ARRAY(o))
		return (-1);
	if (size != NULL)
		*size = o->arraysize;
	return (0);
}

void
options_array_assign(struct options_entry *o, const char *s)
{
	const char	*separator;
	char		*copy, *next, *string;
	u_int		 i;

	separator = o->tableentry->separator;
	if (separator == NULL)
		separator = " ,";

	copy = string = xstrdup(s);
	while ((next = strsep(&string, separator)) != NULL) {
		if (*next == '\0')
			continue;
		for (i = 0; i < OPTIONS_ARRAY_LIMIT; i++) {
			if (i >= o->arraysize || o->array[i] == NULL)
				break;
		}
		if (i == OPTIONS_ARRAY_LIMIT)
			break;
		options_array_set(o, i, next, 0);
	}
	free(copy);
}

int
options_isstring(struct options_entry *o)
{
	if (o->tableentry == NULL)
		return (1);
	return (OPTIONS_IS_STRING(o) || OPTIONS_IS_ARRAY(o));
}

const char *
options_tostring(struct options_entry *o, int idx, int numeric)
{
	static char	 s[1024];
	const char	*tmp;

	if (OPTIONS_IS_ARRAY(o)) {
		if (idx == -1)
			return (NULL);
		if ((u_int)idx >= o->arraysize || o->array[idx] == NULL)
			return ("");
		return (o->array[idx]);
	}
	if (OPTIONS_IS_STYLE(o))
		return (style_tostring(&o->style));
	if (OPTIONS_IS_NUMBER(o)) {
		tmp = NULL;
		switch (o->tableentry->type) {
		case OPTIONS_TABLE_NUMBER:
			xsnprintf(s, sizeof s, "%lld", o->number);
			break;
		case OPTIONS_TABLE_KEY:
			tmp = key_string_lookup_key(o->number);
			break;
		case OPTIONS_TABLE_COLOUR:
			tmp = colour_tostring(o->number);
			break;
		case OPTIONS_TABLE_ATTRIBUTES:
			tmp = attributes_tostring(o->number);
			break;
		case OPTIONS_TABLE_FLAG:
			if (numeric)
				xsnprintf(s, sizeof s, "%lld", o->number);
			else
				tmp = (o->number ? "on" : "off");
			break;
		case OPTIONS_TABLE_CHOICE:
			tmp = o->tableentry->choices[o->number];
			break;
		case OPTIONS_TABLE_STRING:
		case OPTIONS_TABLE_STYLE:
		case OPTIONS_TABLE_ARRAY:
			break;
		}
		if (tmp != NULL)
			xsnprintf(s, sizeof s, "%s", tmp);
		return (s);
	}
	if (OPTIONS_IS_STRING(o))
		return (o->string);
	return (NULL);
}

char *
options_parse(const char *name, int *idx)
{
	char	*copy, *cp, *end;

	if (*name == '\0')
		return (NULL);
	copy = xstrdup(name);
	if ((cp = strchr(copy, '[')) == NULL) {
		*idx = -1;
		return (copy);
	}
	end = strchr(cp + 1, ']');
	if (end == NULL || end[1] != '\0' || !isdigit((u_char)end[-1])) {
		free(copy);
		return (NULL);
	}
	if (sscanf(cp, "[%d]", idx) != 1 || *idx < 0) {
		free(copy);
		return (NULL);
	}
	*cp = '\0';
	return (copy);
}

struct options_entry *
options_parse_get(struct options *oo, const char *s, int *idx, int only)
{
	struct options_entry	*o;
	char			*name;

	name = options_parse(s, idx);
	if (name == NULL)
		return (NULL);
	if (only)
		o = options_get_only(oo, name);
	else
		o = options_get(oo, name);
	free(name);
	return (o);
}

char *
options_match(const char *s, int *idx, int* ambiguous)
{
	const struct options_table_entry	*oe, *found;
	char					*name;
	size_t					 namelen;

	name = options_parse(s, idx);
	if (name == NULL)
		return (NULL);
	namelen = strlen(name);

	if (*name == '@@') {
		*ambiguous = 0;
		return (name);
	}

	found = NULL;
	for (oe = options_table; oe->name != NULL; oe++) {
		if (strcmp(oe->name, name) == 0) {
			found = oe;
			break;
		}
		if (strncmp(oe->name, name, namelen) == 0) {
			if (found != NULL) {
				*ambiguous = 1;
				free(name);
				return (NULL);
			}
			found = oe;
		}
	}
	free(name);
	if (found == NULL) {
		*ambiguous = 0;
		return (NULL);
	}
	return (xstrdup(found->name));
}

struct options_entry *
options_match_get(struct options *oo, const char *s, int *idx, int only,
    int* ambiguous)
{
	char			*name;
	struct options_entry	*o;

	name = options_match(s, idx, ambiguous);
	if (name == NULL)
		return (NULL);
	*ambiguous = 0;
	if (only)
		o = options_get_only(oo, name);
	else
		o = options_get(oo, name);
	free(name);
	return (o);
}

const char *
options_get_string(struct options *oo, const char *name)
{
	struct options_entry	*o;

	o = options_get(oo, name);
	if (o == NULL)
		fatalx("missing option %s", name);
	if (!OPTIONS_IS_STRING(o))
		fatalx("option %s is not a string", name);
	return (o->string);
}

long long
options_get_number(struct options *oo, const char *name)
{
	struct options_entry	*o;

	o = options_get(oo, name);
	if (o == NULL)
		fatalx("missing option %s", name);
	if (!OPTIONS_IS_NUMBER(o))
	    fatalx("option %s is not a number", name);
	return (o->number);
}

const struct grid_cell *
options_get_style(struct options *oo, const char *name)
{
	struct options_entry	*o;

	o = options_get(oo, name);
	if (o == NULL)
		fatalx("missing option %s", name);
	if (!OPTIONS_IS_STYLE(o))
		fatalx("option %s is not a style", name);
	return (&o->style);
}

struct options_entry *
options_set_string(struct options *oo, const char *name, int append,
    const char *fmt, ...)
{
	struct options_entry	*o;
	va_list			 ap;
	char			*s, *value;

	va_start(ap, fmt);
	xvasprintf(&s, fmt, ap);
	va_end(ap);

	o = options_get_only(oo, name);
	if (o != NULL && append && OPTIONS_IS_STRING(o)) {
		xasprintf(&value, "%s%s", o->string, s);
		free(s);
	} else
		value = s;
	if (o == NULL && *name == '@@')
		o = options_add(oo, name);
	else if (o == NULL) {
		o = options_default(oo, options_parent_table_entry(oo, name));
		if (o == NULL)
			return (NULL);
	}

	if (!OPTIONS_IS_STRING(o))
		fatalx("option %s is not a string", name);
	free(o->string);
	o->string = value;
	return (o);
}

struct options_entry *
options_set_number(struct options *oo, const char *name, long long value)
{
	struct options_entry	*o;

	if (*name == '@@')
		fatalx("user option %s must be a string", name);

	o = options_get_only(oo, name);
	if (o == NULL) {
		o = options_default(oo, options_parent_table_entry(oo, name));
		if (o == NULL)
			return (NULL);
	}

	if (!OPTIONS_IS_NUMBER(o))
		fatalx("option %s is not a number", name);
	o->number = value;
	return (o);
}

struct options_entry *
options_set_style(struct options *oo, const char *name, int append,
    const char *value)
{
	struct options_entry	*o;
	struct grid_cell	 gc;

	if (*name == '@@')
		fatalx("user option %s must be a string", name);

	o = options_get_only(oo, name);
	if (o != NULL && append && OPTIONS_IS_STYLE(o))
		memcpy(&gc, &o->style, sizeof gc);
	else
		memcpy(&gc, &grid_default_cell, sizeof gc);
	if (style_parse(&grid_default_cell, &gc, value) == -1)
		return (NULL);
	if (o == NULL) {
		o = options_default(oo, options_parent_table_entry(oo, name));
		if (o == NULL)
			return (NULL);
	}

	if (!OPTIONS_IS_STYLE(o))
		fatalx("option %s is not a style", name);
	memcpy(&o->style, &gc, sizeof o->style);
	return (o);
}

enum options_table_scope
options_scope_from_flags(struct args *args, int window,
    struct cmd_find_state *fs, struct options **oo, char **cause)
{
	struct session	*s = fs->s;
	struct winlink	*wl = fs->wl;
	const char	*target= args_get(args, 't');

	if (args_has(args, 's')) {
		*oo = global_options;
		return (OPTIONS_TABLE_SERVER);
	}

	if (window || args_has(args, 'w')) {
		if (args_has(args, 'g')) {
			*oo = global_w_options;
			return (OPTIONS_TABLE_WINDOW);
		}
		if (wl == NULL) {
			if (target != NULL)
				xasprintf(cause, "no such window: %s", target);
			else
				xasprintf(cause, "no current window");
			return (OPTIONS_TABLE_NONE);
		}
		*oo = wl->window->options;
		return (OPTIONS_TABLE_WINDOW);
	} else {
		if (args_has(args, 'g')) {
			*oo = global_s_options;
			return (OPTIONS_TABLE_SESSION);
		}
		if (s == NULL) {
			if (target != NULL)
				xasprintf(cause, "no such session: %s", target);
			else
				xasprintf(cause, "no current session");
			return (OPTIONS_TABLE_NONE);
		}
		*oo = s->options;
		return (OPTIONS_TABLE_SESSION);
	}
}

void
options_style_update_new(struct options *oo, struct options_entry *o)
{
	const char		*newname = o->tableentry->style;
	struct options_entry	*new;

	if (newname == NULL)
		return;
	new = options_get_only(oo, newname);
	if (new == NULL)
		new = options_set_style(oo, newname, 0, "default");

	if (strstr(o->name, "-bg") != NULL)
		new->style.bg = o->number;
	else if (strstr(o->name, "-fg") != NULL)
		new->style.fg = o->number;
	else if (strstr(o->name, "-attr") != NULL)
		new->style.attr = o->number;
}

void
options_style_update_old(struct options *oo, struct options_entry *o)
{
	char	newname[128];
	int	size;

	size = strrchr(o->name, '-') - o->name;

	xsnprintf(newname, sizeof newname, "%.*s-bg", size, o->name);
	if (options_get(oo, newname) != NULL)
		options_set_number(oo, newname, o->style.bg);

	xsnprintf(newname, sizeof newname, "%.*s-fg", size, o->name);
	if (options_get(oo, newname) != NULL)
		options_set_number(oo, newname, o->style.fg);

	xsnprintf(newname, sizeof newname, "%.*s-attr", size, o->name);
	if (options_get(oo, newname) != NULL)
		options_set_number(oo, newname, o->style.attr);
}
@


1.35
log
@Style and spacing nits.
@
text
@d1 1
a1 1
/* $OpenBSD: options.c,v 1.34 2017/04/22 06:13:30 nicm Exp $ */
a479 1

@


1.34
log
@Memory leaks, from David CARLIER.
@
text
@d1 1
a1 1
/* $OpenBSD: options.c,v 1.33 2017/03/08 14:43:40 nicm Exp $ */
d117 1
a117 1
	RB_FOREACH_SAFE (o, options_tree, &oo->tree, tmp)
@


1.33
log
@Handle empty options correctly.
@
text
@d1 1
a1 1
/* $OpenBSD: options.c,v 1.32 2017/01/30 21:41:17 nicm Exp $ */
d436 1
a436 1
		return (xstrdup(name));
@


1.32
log
@When a flag option is used in a format, it should use the number form
not string.
@
text
@d1 1
a1 1
/* $OpenBSD: options.c,v 1.31 2017/01/24 19:11:46 nicm Exp $ */
d430 2
@


1.31
log
@If given an array option without an index either show or set all items,
and support -a for array options. Allow the separator for set to be
specified in the options table (will be used for backwards compatibility
later).
@
text
@d1 1
a1 1
/* $OpenBSD: options.c,v 1.30 2017/01/18 08:43:21 nicm Exp $ */
d328 1
a328 1
options_tostring(struct options_entry *o, int idx)
d358 4
a361 1
			tmp = (o->number ? "on" : "off");
@


1.30
log
@Do not reset idx, it has just been set.
@
text
@d1 1
a1 1
/* $OpenBSD: options.c,v 1.29 2017/01/18 08:40:50 nicm Exp $ */
a172 2
	char			*cp, *copy, *next;
	u_int			 idx = 0;
d175 3
a177 12

	if (oe->type == OPTIONS_TABLE_ARRAY) {
		copy = cp = xstrdup(oe->default_str);
		while ((next = strsep(&cp, ",")) != NULL) {
			options_array_set(o, idx, next);
			idx++;
		}
		free(copy);
		return (o);
	}

	if (oe->type == OPTIONS_TABLE_STRING)
d234 7
d252 2
a253 1
options_array_set(struct options_entry *o, u_int idx, const char *value)
d255 2
a256 1
	u_int	i;
d269 11
a279 6
	if (o->array[idx] != NULL)
		free((void *)o->array[idx]);
	if (value != NULL)
		o->array[idx] = xstrdup(value);
	else
		o->array[idx] = NULL;
d293 26
a415 6
	if (o != NULL) {
		if (OPTIONS_IS_ARRAY(o) && *idx == -1)
			return (NULL);
		if (!OPTIONS_IS_ARRAY(o) && *idx != -1)
			return (NULL);
	}
a472 6
	if (o != NULL) {
		if (OPTIONS_IS_ARRAY(o) && *idx == -1)
			return (NULL);
		if (!OPTIONS_IS_ARRAY(o) && *idx != -1)
			return (NULL);
	}
@


1.29
log
@options_match needs to explicitly check for user options.
@
text
@d1 1
a1 1
/* $OpenBSD: options.c,v 1.28 2017/01/16 23:45:08 nicm Exp $ */
a405 1
	*idx = -1;
@


1.28
log
@Correctly handle -style options without all of a corresponding -fg/-bg/-attr.
@
text
@d1 1
a1 1
/* $OpenBSD: options.c,v 1.27 2017/01/16 14:49:14 nicm Exp $ */
d405 6
@


1.27
log
@getopt() has a struct option so just return to using options_entry.
@
text
@d1 1
a1 1
/* $OpenBSD: options.c,v 1.26 2017/01/15 20:48:41 nicm Exp $ */
d650 2
a651 1
	options_set_number(oo, newname, o->style.bg);
d654 2
a655 1
	options_set_number(oo, newname, o->style.fg);
d658 2
a659 1
	options_set_number(oo, newname, o->style.attr);
@


1.26
log
@Major tidy up and rework of options tree and set-option/show-options
commands this pushes more of the code into options.c and ties it more
closely to the options table rather than having an unnecessary
split. Also add support for array options (will be used later). Only
(intentional) user visible change is that show-options output is now
passed through vis(3) with VIS_DQ so quotes are escaped.
@
text
@d1 1
a1 1
/* $OpenBSD: options.c,v 1.25 2017/01/15 20:14:36 nicm Exp $ */
d33 1
a33 1
struct option {
d49 1
a49 1
	RB_ENTRY(option)			  entry;
d53 1
a53 1
	RB_HEAD(options_tree, option)		 tree;
d57 1
a57 1
static struct option	*options_add(struct options *, const char *);
d79 2
a80 2
static int	options_cmp(struct option *, struct option *);
RB_GENERATE_STATIC(options_tree, option, entry, options_cmp);
d83 1
a83 1
options_cmp(struct option *lhs, struct option *rhs)
d91 1
a91 1
	struct option	*o;
d115 1
a115 1
	struct option	*o, *tmp;
d122 1
a122 1
struct option *
d128 2
a129 2
struct option *
options_next(struct option *o)
d134 1
a134 1
struct option *
d137 1
a137 1
	struct option	o;
d143 1
a143 1
struct option *
d146 1
a146 1
	struct option	*o;
d158 1
a158 1
struct option *
d161 1
a161 1
	struct option	*o;
d169 1
a169 1
struct option *
d172 3
a174 3
	struct option	*o;
	char		*cp, *copy, *next;
	u_int		 idx = 0;
d198 1
a198 1
static struct option *
d201 1
a201 1
	struct option	*o;
d216 1
a216 1
options_remove(struct option *o)
d234 1
a234 1
options_name(struct option *o)
d240 1
a240 1
options_table_entry(struct option *o)
d246 1
a246 1
options_array_get(struct option *o, u_int idx)
d256 1
a256 1
options_array_set(struct option *o, u_int idx, const char *value)
d281 1
a281 1
options_array_size(struct option *o, u_int *size)
d291 1
a291 1
options_isstring(struct option *o)
d299 1
a299 1
options_tostring(struct option *o, int idx)
d373 1
a373 1
struct option *
d376 2
a377 2
	struct option	*o;
	char		*name;
d429 1
a429 1
struct option *
d433 2
a434 2
	char		*name;
	struct option	*o;
d458 1
a458 1
	struct option	*o;
d471 1
a471 1
	struct option	*o;
d484 1
a484 1
	struct option	*o;
d494 1
a494 1
struct option *
d498 3
a500 3
	struct option	*o;
	va_list		 ap;
	char		*s, *value;
d527 1
a527 1
struct option *
d530 1
a530 1
	struct option	*o;
d548 1
a548 1
struct option *
d552 1
a552 1
	struct option		*o;
d622 1
a622 1
options_style_update_new(struct options *oo, struct option *o)
d624 2
a625 2
	const char	*newname = o->tableentry->style;
	struct option	*new;
d642 1
a642 1
options_style_update_old(struct options *oo, struct option *o)
@


1.25
log
@Append needs to go old,new not new,old...
@
text
@d1 1
a1 1
/* $OpenBSD: options.c,v 1.24 2017/01/13 11:58:49 nicm Exp $ */
d21 1
d33 19
d53 2
a54 2
	RB_HEAD(options_tree, options_entry) tree;
	struct options	*parent;
d57 24
a80 2
static int	options_cmp(struct options_entry *, struct options_entry *);
RB_GENERATE_STATIC(options_tree, options_entry, entry, options_cmp);
d83 7
a89 1
options_cmp(struct options_entry *o1, struct options_entry *o2)
d91 8
a98 1
	return (strcmp(o1->name, o2->name));
a111 25
static void
options_free1(struct options *oo, struct options_entry *o)
{
	RB_REMOVE(options_tree, &oo->tree, o);
	free((char *)o->name);
	if (o->type == OPTIONS_STRING)
		free(o->str);
	free(o);
}

static struct options_entry *
options_new(struct options *oo, const char *name)
{
	struct options_entry	*o;

	if ((o = options_find1(oo, name)) == NULL) {
		o = xmalloc(sizeof *o);
		o->name = xstrdup(name);
		RB_INSERT(options_tree, &oo->tree, o);
		memcpy(&o->style, &grid_default_cell, sizeof o->style);
	} else if (o->type == OPTIONS_STRING)
		free(o->str);
	return (o);
}

d115 1
a115 1
	struct options_entry	*o, *o1;
d117 2
a118 2
	RB_FOREACH_SAFE (o, options_tree, &oo->tree, o1)
		options_free1(oo, o);
d122 1
a122 1
struct options_entry *
d128 2
a129 2
struct options_entry *
options_next(struct options_entry *o)
d134 2
a135 2
struct options_entry *
options_find1(struct options *oo, const char *name)
d137 1
a137 1
	struct options_entry	p;
d139 2
a140 2
	p.name = (char *)name;
	return (RB_FIND(options_tree, &oo->tree, &p));
d143 2
a144 2
struct options_entry *
options_find(struct options *oo, const char *name)
d146 1
a146 1
	struct options_entry	*o, p;
d148 1
a148 2
	p.name = (char *)name;
	o = RB_FIND(options_tree, &oo->tree, &p);
d153 33
a185 1
		o = RB_FIND(options_tree, &oo->tree, &p);
d187 25
d216 134
a349 1
options_remove(struct options *oo, const char *name)
d351 1
a351 1
	struct options_entry	*o;
d353 18
a370 2
	if ((o = options_find1(oo, name)) != NULL)
		options_free1(oo, o);
d373 2
a374 3
struct options_entry *
options_set_string(struct options *oo, const char *name, int append,
    const char *fmt, ...)
d376 2
a377 3
	struct options_entry	*o;
	va_list			 ap;
	char			*s, *value;
d379 16
a394 3
	va_start(ap, fmt);
	xvasprintf(&s, fmt, ap);
	va_end(ap);
d396 29
a424 6
	o = options_find1(oo, name);
	if (o == NULL || !append)
		value = s;
	else {
		xasprintf(&value, "%s%s", o->str, s);
		free(s);
d426 2
d429 6
a434 3
	o = options_new(oo, name);
	o->type = OPTIONS_STRING;
	o->str = value;
d436 15
d454 1
d458 14
a471 1
	struct options_entry	*o;
d473 2
a474 1
	if ((o = options_find(oo, name)) == NULL)
d476 3
a478 3
	if (o->type != OPTIONS_STRING)
		fatalx("option %s not a string", name);
	return (o->str);
d481 16
a496 2
struct options_entry *
options_set_number(struct options *oo, const char *name, long long value)
d498 3
a500 1
	struct options_entry	*o;
d502 17
a518 3
	o = options_new(oo, name);
	o->type = OPTIONS_NUMBER;
	o->num = value;
d520 4
d527 2
a528 2
long long
options_get_number(struct options *oo, const char *name)
d530 4
a533 1
	struct options_entry	*o;
d535 11
a545 5
	if ((o = options_find(oo, name)) == NULL)
		fatalx("missing option %s", name);
	if (o->type != OPTIONS_NUMBER)
		fatalx("option %s not a number", name);
	return (o->num);
d548 1
a548 1
struct options_entry *
d552 5
a556 2
	struct options_entry	*o;
	struct grid_cell	 tmpgc;
d558 3
a560 3
	o = options_find1(oo, name);
	if (o == NULL || !append)
		memcpy(&tmpgc, &grid_default_cell, sizeof tmpgc);
d562 14
a575 1
		memcpy(&tmpgc, &o->style, sizeof tmpgc);
d577 12
a588 2
	if (style_parse(&grid_default_cell, &tmpgc, value) == -1)
		return (NULL);
d590 30
a619 3
	o = options_new(oo, name);
	o->type = OPTIONS_STYLE;
	memcpy(&o->style, &tmpgc, sizeof o->style);
d621 18
a638 1
	return (o);
d641 2
a642 2
const struct grid_cell *
options_get_style(struct options *oo, const char *name)
d644 2
a645 1
	struct options_entry	*o;
d647 10
a656 5
	if ((o = options_find(oo, name)) == NULL)
		fatalx("missing option %s", name);
	if (o->type != OPTIONS_STYLE)
		fatalx("option %s not a style", name);
	return (&o->style);
@


1.24
log
@options_get_style return const too.
@
text
@d1 1
a1 1
/* $OpenBSD: options.c,v 1.23 2017/01/13 11:56:43 nicm Exp $ */
d154 1
a154 1
		xasprintf(&value, "%s%s", s, o->str);
@


1.23
log
@Make options_get_string return const string.
@
text
@d1 1
a1 1
/* $OpenBSD: options.c,v 1.22 2017/01/12 15:36:35 nicm Exp $ */
d224 1
a224 1
struct grid_cell *
@


1.22
log
@Simplify appending to string options.
@
text
@d1 1
a1 1
/* $OpenBSD: options.c,v 1.21 2017/01/11 14:56:44 nicm Exp $ */
d165 1
a165 1
char *
@


1.21
log
@Some tidying and tweaks to options code.
@
text
@d1 1
a1 1
/* $OpenBSD: options.c,v 1.20 2016/10/10 21:29:23 nicm Exp $ */
d68 1
a68 1
options_new(struct options *oo, const char *name, char **s)
a71 3
	if (s != NULL)
		*s = NULL;

d77 2
a78 6
	} else if (o->type == OPTIONS_STRING) {
		if (s != NULL)
			*s = o->str;
		else
			free(o->str);
	}
d139 2
a140 1
options_set_string(struct options *oo, const char *name, const char *fmt, ...)
d144 1
a144 1
	char			*s;
d147 2
d150 9
a158 1
	o = options_new(oo, name, &s);
d160 1
a160 2
	xvasprintf(&o->str, fmt, ap);
	free(s);
a161 1
	va_end(ap);
d182 1
a182 1
	o = options_new(oo, name, NULL);
d202 2
a203 2
options_set_style(struct options *oo, const char *name, const char *value,
    int append)
d217 1
a217 1
	o = options_new(oo, name, NULL);
@


1.20
log
@Loads more static, except for cmd-*.c and window-*.c.
@
text
@d1 1
a1 1
/* $OpenBSD: options.c,v 1.19 2016/09/26 09:02:34 nicm Exp $ */
a39 2
static void	options_free1(struct options *, struct options_entry *);

d67 22
d152 1
a152 8
	s = NULL;
	if ((o = options_find1(oo, name)) == NULL) {
		o = xmalloc(sizeof *o);
		o->name = xstrdup(name);
		RB_INSERT(options_tree, &oo->tree, o);
		memcpy(&o->style, &grid_default_cell, sizeof o->style);
	} else if (o->type == OPTIONS_STRING)
		s = o->str;
d154 1
a154 1
	va_start(ap, fmt);
d157 2
a159 2

	free(s);
d180 1
a180 8
	if ((o = options_find1(oo, name)) == NULL) {
		o = xmalloc(sizeof *o);
		o->name = xstrdup(name);
		RB_INSERT(options_tree, &oo->tree, o);
		memcpy(&o->style, &grid_default_cell, sizeof o->style);
	} else if (o->type == OPTIONS_STRING)
		free(o->str);

d183 1
d215 1
a215 7
	if (o == NULL) {
		o = xmalloc(sizeof *o);
		o->name = xstrdup(name);
		RB_INSERT(options_tree, &oo->tree, o);
	} else if (o->type == OPTIONS_STRING)
		free(o->str);

d218 1
@


1.19
log
@Support set -a (append) with user options, suggested by Xandor Schiefer.
@
text
@d1 1
a1 1
/* $OpenBSD: options.c,v 1.18 2016/01/19 15:59:12 nicm Exp $ */
d38 1
a38 2
RB_PROTOTYPE(options_tree, options_entry, entry, options_cmp);
RB_GENERATE(options_tree, options_entry, entry, options_cmp);
@


1.18
log
@I no longer use my SourceForge address so replace it.
@
text
@d1 1
a1 1
/* $OpenBSD: options.c,v 1.17 2015/12/11 15:46:57 nicm Exp $ */
d131 1
d133 1
d140 1
a140 1
		free(o->str);
d146 2
@


1.17
log
@We cannot do hooks_find and then hooks_remove because it might have come
from the parent (global) tree, instead make it remove by name like options.

While here, also tidy up a few bits of options and hooks handling (use
RB_FOREACH_SAFE, and a helper function for the free).
@
text
@d1 1
a1 1
/* $OpenBSD: options.c,v 1.16 2015/12/08 08:14:04 nicm Exp $ */
d4 1
a4 1
 * Copyright (c) 2008 Nicholas Marriott <nicm@@users.sourceforge.net>
@


1.16
log
@Spacing nits.
@
text
@d1 1
a1 1
/* $OpenBSD: options.c,v 1.15 2015/11/18 13:06:54 nicm Exp $ */
d37 1
a37 1
int	options_cmp(struct options_entry *, struct options_entry *);
d41 3
a43 1
int
d60 10
d73 1
a73 1
	struct options_entry	*o;
d75 2
a76 8
	while (!RB_EMPTY(&oo->tree)) {
		o = RB_ROOT(&oo->tree);
		RB_REMOVE(options_tree, &oo->tree, o);
		free(o->name);
		if (o->type == OPTIONS_STRING)
			free(o->str);
		free(o);
	}
d97 1
a97 1
	p.name = (char *) name;
d106 1
a106 1
	p.name = (char *) name;
d122 2
a123 8
	if ((o = options_find1(oo, name)) == NULL)
		return;

	RB_REMOVE(options_tree, &oo->tree, o);
	free(o->name);
	if (o->type == OPTIONS_STRING)
		free(o->str);
	free(o);
@


1.15
log
@Sync the entire xmalloc.[ch] with the other users, but with the addition
of xrealloc, xvasprintf, xvsnprintf.
@
text
@d1 1
a1 1
/* $OpenBSD: options.c,v 1.14 2015/11/13 16:06:43 nicm Exp $ */
d50 1
a50 1
	struct options *oo;
@


1.14
log
@Log option names in fatal() for missing option.
@
text
@d1 1
a1 1
/* $OpenBSD: options.c,v 1.13 2015/10/27 15:58:42 nicm Exp $ */
d153 1
a153 1
		log_fatalx("missing option %s", name);
d155 1
a155 1
		log_fatalx("option %s not a string", name);
d183 1
a183 1
		log_fatalx("missing option %s", name);
d185 1
a185 1
		log_fatalx("option %s not a number", name);
d223 1
a223 1
		log_fatalx("missing option %s", name);
d225 1
a225 1
		log_fatalx("option %s not a style", name);
@


1.13
log
@Move struct options into options.c.
@
text
@d1 1
a1 1
/* $OpenBSD: options.c,v 1.12 2015/02/18 15:32:37 nicm Exp $ */
d153 1
a153 1
		fatalx("missing option");
d155 1
a155 1
		fatalx("option not a string");
d183 1
a183 1
		fatalx("missing option");
d185 1
a185 1
		fatalx("option not a number");
d223 1
a223 1
		fatalx("missing option");
d225 1
a225 1
		fatalx("option not a style");
@


1.12
log
@When given an invalid style, don't set the option to the default. Fix
from J Raynor. Also make style_parse not alter the grid_cell when it
fails.
@
text
@d1 1
a1 1
/* $OpenBSD: options.c,v 1.11 2014/10/20 23:57:14 nicm Exp $ */
d32 7
d47 2
a48 2
void
options_init(struct options *oo, struct options *parent)
d50 3
d55 1
d71 13
@


1.11
log
@Better format for printf format attributes.
@
text
@d1 1
a1 1
/* $OpenBSD: options.c,v 1.10 2014/01/28 23:07:09 nicm Exp $ */
d170 1
d172 10
a181 1
	if ((o = options_find1(oo, name)) == NULL) {
a187 3
	if (!append)
		memcpy(&o->style, &grid_default_cell, sizeof o->style);

d189 1
a189 2
	if (style_parse(&grid_default_cell, &o->style, value) == -1)
		return (NULL);
@


1.10
log
@Allow replacing each of the many sets of separate foo-{fg,bg,attr}
options with a single foo-style option. For example:

    set -g status-fg yellow
    set -g status-bg red
    set -g status-attr blink

Becomes:

    set -g status-style fg=yellow,bg=red,blink

The -a flag to set can be used to add to rather than replace a style. So:

    set -g status-bg red

Becomes:

    set -ag status-style bg=red

Currently this is fully backwards compatible (all *-{fg,bg,attr} options
remain) but the plan is to deprecate them over time.

From Tiago Cunha.
@
text
@d1 1
a1 1
/* $OpenBSD: options.c,v 1.9 2014/01/09 13:58:06 nicm Exp $ */
d102 1
a102 1
struct options_entry *printflike3
@


1.9
log
@Style and comment fixes from Tiago Cunha.
@
text
@d1 1
a1 1
/* $OpenBSD: options.c,v 1.8 2012/07/10 11:53:01 nicm Exp $ */
d112 1
d144 1
d163 34
@


1.8
log
@xfree is not particularly helpful, remove it. From Thomas Adam.
@
text
@d1 1
a1 1
/* $OpenBSD: options.c,v 1.7 2012/01/21 11:12:13 nicm Exp $ */
d29 1
a29 1
 * a splay tree.
@


1.7
log
@Use RB trees not SPLAY.
@
text
@d1 1
a1 1
/* $OpenBSD: options.c,v 1.6 2012/01/21 08:40:09 nicm Exp $ */
d22 1
d55 1
a55 1
		xfree(o->name);
d57 2
a58 2
			xfree(o->str);
		xfree(o);
d96 1
a96 1
	xfree(o->name);
d98 2
a99 2
		xfree(o->str);
	xfree(o);
d113 1
a113 1
		xfree(o->str);
d144 1
a144 1
		xfree(o->str);
@


1.6
log
@Drop the ability to have a list of keys in the prefix in favour of two
separate options, prefix and prefix2. This simplifies the code and gets
rid the data options type which was only used for this one option.

Also add a -2 flag to send-prefix to send the secondary prefix key,
fixing a cause of minor irritation.

People who want three prefix keys are out of luck :-).
@
text
@d1 1
a1 1
/* $OpenBSD: options.c,v 1.5 2009/09/22 12:38:10 nicm Exp $ */
d31 1
a31 1
SPLAY_GENERATE(options_tree, options_entry, entry, options_cmp);
d42 1
a42 1
	SPLAY_INIT(&oo->tree);
d51 3
a53 3
	while (!SPLAY_EMPTY(&oo->tree)) {
		o = SPLAY_ROOT(&oo->tree);
		SPLAY_REMOVE(options_tree, &oo->tree, o);
d67 1
a67 1
	return (SPLAY_FIND(options_tree, &oo->tree, &p));
d76 1
a76 1
	o = SPLAY_FIND(options_tree, &oo->tree, &p);
d81 1
a81 1
		o = SPLAY_FIND(options_tree, &oo->tree, &p);
d94 1
a94 1
	SPLAY_REMOVE(options_tree, &oo->tree, o);
d110 1
a110 1
		SPLAY_INSERT(options_tree, &oo->tree, o);
d141 1
a141 1
		SPLAY_INSERT(options_tree, &oo->tree, o);
@


1.5
log
@Permit multiple prefix keys to be defined, separated by commas, for example:

set -g prefix ^a,^b

Any key in the list acts as the prefix. The send-prefix command always sends
the first key in the list.
@
text
@d1 1
a1 1
/* $OpenBSD: options.c,v 1.4 2009/09/21 14:56:03 nicm Exp $ */
a56 2
		else if (o->type == OPTIONS_DATA)
			o->freefn(o->data);
a97 2
	else if (o->type == OPTIONS_DATA)
		o->freefn(o->data);
a112 2
	else if (o->type == OPTIONS_DATA)
		o->freefn(o->data);
a143 2
	else if (o->type == OPTIONS_DATA)
		o->freefn(o->data);
a159 33
}

struct options_entry *
options_set_data(
    struct options *oo, const char *name, void *value, void (*freefn)(void *))
{
	struct options_entry	*o;

	if ((o = options_find1(oo, name)) == NULL) {
		o = xmalloc(sizeof *o);
		o->name = xstrdup(name);
		SPLAY_INSERT(options_tree, &oo->tree, o);
	} else if (o->type == OPTIONS_STRING)
		xfree(o->str);
	else if (o->type == OPTIONS_DATA)
		o->freefn(o->data);

	o->type = OPTIONS_DATA;
	o->data = value;
	o->freefn = freefn;
	return (o);
}

void *
options_get_data(struct options *oo, const char *name)
{
	struct options_entry	*o;

	if ((o = options_find(oo, name)) == NULL)
		fatalx("missing option");
	if (o->type != OPTIONS_DATA)
		fatalx("option not data");
	return (o->data);
@


1.4
log
@Use option print function for info messages as well.
@
text
@d1 1
a1 1
/* $OpenBSD: options.c,v 1.3 2009/09/21 07:00:09 nicm Exp $ */
d57 2
d100 2
d117 2
d150 2
d168 33
@


1.3
log
@Drop tiny union from option struct.
@
text
@d1 1
a1 1
/* $OpenBSD: options.c,v 1.2 2009/07/21 19:54:22 nicm Exp $ */
d101 1
a101 1
void printflike3
d118 1
d133 1
a133 1
void
d147 1
a147 1

@


1.2
log
@Make some functions which return unused values void (mostly found by lint) and
tweak a redundant expression in window_pane_set_mode.
@
text
@d1 1
a1 1
/* $OpenBSD: options.c,v 1.1 2009/06/01 22:58:49 nicm Exp $ */
d56 1
a56 1
			xfree(o->value.string);
d97 1
a97 1
		xfree(o->value.string);
d112 1
a112 1
		xfree(o->value.string);
d116 1
a116 1
	xvasprintf(&o->value.string, fmt, ap);
d129 1
a129 1
	return (o->value.string);
d142 1
a142 1
		xfree(o->value.string);
d145 1
a145 1
	o->value.number = value;
d158 1
a158 1
	return (o->value.number);
@


1.1
log
@Import tmux, a terminal multiplexor allowing (among other things) a single
terminal to be switched between several different windows and programs
displayed on one terminal be detached from one terminal and moved to another.

ok deraadt pirofti
@
text
@d1 1
a1 1
/* $OpenBSD$ */
d86 1
a86 1
int
d92 1
a92 1
		return (-1);
a98 1
	return (0);
@

