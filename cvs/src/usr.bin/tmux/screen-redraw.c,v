head	1.46;
access;
symbols
	OPENBSD_6_2:1.46.0.4
	OPENBSD_6_2_BASE:1.46
	OPENBSD_6_1:1.44.0.4
	OPENBSD_6_1_BASE:1.44
	OPENBSD_6_0:1.37.0.2
	OPENBSD_6_0_BASE:1.37
	OPENBSD_5_9:1.35.0.2
	OPENBSD_5_9_BASE:1.35
	OPENBSD_5_8:1.32.0.4
	OPENBSD_5_8_BASE:1.32
	OPENBSD_5_7:1.29.0.2
	OPENBSD_5_7_BASE:1.29
	OPENBSD_5_6:1.27.0.4
	OPENBSD_5_6_BASE:1.27
	OPENBSD_5_5:1.26.0.4
	OPENBSD_5_5_BASE:1.26
	OPENBSD_5_4:1.24.0.2
	OPENBSD_5_4_BASE:1.24
	OPENBSD_5_3:1.22.0.4
	OPENBSD_5_3_BASE:1.22
	OPENBSD_5_2:1.22.0.2
	OPENBSD_5_2_BASE:1.22
	OPENBSD_5_1_BASE:1.21
	OPENBSD_5_1:1.21.0.2
	OPENBSD_5_0:1.18.0.2
	OPENBSD_5_0_BASE:1.18
	OPENBSD_4_9:1.17.0.2
	OPENBSD_4_9_BASE:1.17
	OPENBSD_4_8:1.16.0.4
	OPENBSD_4_8_BASE:1.16
	OPENBSD_4_7:1.16.0.2
	OPENBSD_4_7_BASE:1.16
	OPENBSD_4_6:1.2.0.4
	OPENBSD_4_6_BASE:1.2;
locks; strict;
comment	@ * @;


1.46
date	2017.05.01.12.20.55;	author nicm;	state Exp;
branches;
next	1.45;
commitid	sAXCoXWmq7A1UnAP;

1.45
date	2017.04.05.10.49.46;	author nicm;	state Exp;
branches;
next	1.44;
commitid	1mjoRYvghWl25dW0;

1.44
date	2017.02.08.15.41.41;	author nicm;	state Exp;
branches;
next	1.43;
commitid	0JCt4hH6x9rwToOE;

1.43
date	2017.02.03.11.57.27;	author nicm;	state Exp;
branches;
next	1.42;
commitid	BLRh0qXo7OVTPhiT;

1.42
date	2017.01.07.15.28.13;	author nicm;	state Exp;
branches;
next	1.41;
commitid	llgkTzvAhxXuSWDB;

1.41
date	2016.10.13.20.27.27;	author nicm;	state Exp;
branches;
next	1.40;
commitid	txCyQ5BkKJtZRzfT;

1.40
date	2016.10.12.17.36.52;	author nicm;	state Exp;
branches;
next	1.39;
commitid	2lLr8KT2Ur1GZcJC;

1.39
date	2016.10.10.21.29.23;	author nicm;	state Exp;
branches;
next	1.38;
commitid	z4Hr4PZF7Ev93uEJ;

1.38
date	2016.10.09.16.24.34;	author nicm;	state Exp;
branches;
next	1.37;
commitid	cy0Wx0yJbsZRARd0;

1.37
date	2016.07.15.00.42.56;	author nicm;	state Exp;
branches;
next	1.36;
commitid	EramuEV0ciOaJqkF;

1.36
date	2016.04.29.15.00.48;	author nicm;	state Exp;
branches;
next	1.35;
commitid	z5NrpOKjZoYhx6Qr;

1.35
date	2016.01.19.15.59.12;	author nicm;	state Exp;
branches;
next	1.34;
commitid	P3qmSOx6KrDBsb0c;

1.34
date	2015.12.15.00.00.01;	author nicm;	state Exp;
branches;
next	1.33;
commitid	yMmY7FLVcToE15ZM;

1.33
date	2015.10.27.15.58.42;	author nicm;	state Exp;
branches;
next	1.32;
commitid	89xhQafU35Q5MQVC;

1.32
date	2015.06.04.11.43.51;	author nicm;	state Exp;
branches;
next	1.31;
commitid	rAvOUA4CI6VK3gQ6;

1.31
date	2015.05.07.07.16.14;	author nicm;	state Exp;
branches;
next	1.30;
commitid	Fp7A22xjRdaBPLrs;

1.30
date	2015.04.19.21.05.27;	author nicm;	state Exp;
branches;
next	1.29;
commitid	ksfuI8mTVk7XPyr3;

1.29
date	2015.02.06.15.09.34;	author nicm;	state Exp;
branches;
next	1.28;
commitid	PGKGPybMMWclhLSu;

1.28
date	2014.11.14.02.19.47;	author nicm;	state Exp;
branches;
next	1.27;
commitid	ky6cosN1lXi9yNl0;

1.27
date	2014.03.31.21.34.08;	author nicm;	state Exp;
branches;
next	1.26;

1.26
date	2014.01.31.14.19.24;	author nicm;	state Exp;
branches;
next	1.25;

1.25
date	2014.01.28.23.07.09;	author nicm;	state Exp;
branches;
next	1.24;

1.24
date	2013.03.25.11.41.49;	author nicm;	state Exp;
branches;
next	1.23;

1.23
date	2013.03.25.10.12.01;	author nicm;	state Exp;
branches;
next	1.22;

1.22
date	2012.05.23.19.19.40;	author nicm;	state Exp;
branches;
next	1.21;

1.21
date	2012.01.29.09.37.02;	author nicm;	state Exp;
branches;
next	1.20;

1.20
date	2012.01.21.23.45.44;	author nicm;	state Exp;
branches;
next	1.19;

1.19
date	2011.11.15.23.19.51;	author nicm;	state Exp;
branches;
next	1.18;

1.18
date	2011.07.08.21.51.40;	author nicm;	state Exp;
branches;
next	1.17;

1.17
date	2010.09.11.16.19.22;	author nicm;	state Exp;
branches;
next	1.16;

1.16
date	2010.02.04.18.20.16;	author nicm;	state Exp;
branches;
next	1.15;

1.15
date	2010.01.03.12.51.05;	author nicm;	state Exp;
branches;
next	1.14;

1.14
date	2009.12.03.22.50.10;	author nicm;	state Exp;
branches;
next	1.13;

1.13
date	2009.10.28.08.52.36;	author nicm;	state Exp;
branches;
next	1.12;

1.12
date	2009.10.12.09.29.58;	author nicm;	state Exp;
branches;
next	1.11;

1.11
date	2009.09.10.17.16.24;	author nicm;	state Exp;
branches;
next	1.10;

1.10
date	2009.08.31.20.46.19;	author nicm;	state Exp;
branches;
next	1.9;

1.9
date	2009.08.10.19.42.03;	author nicm;	state Exp;
branches;
next	1.8;

1.8
date	2009.07.31.10.12.49;	author nicm;	state Exp;
branches;
next	1.7;

1.7
date	2009.07.24.19.14.38;	author nicm;	state Exp;
branches;
next	1.6;

1.6
date	2009.07.24.16.21.42;	author nicm;	state Exp;
branches;
next	1.5;

1.5
date	2009.07.14.19.11.58;	author nicm;	state Exp;
branches;
next	1.4;

1.4
date	2009.07.14.19.03.16;	author nicm;	state Exp;
branches;
next	1.3;

1.3
date	2009.07.14.07.23.36;	author nicm;	state Exp;
branches;
next	1.2;

1.2
date	2009.06.25.05.56.44;	author nicm;	state Exp;
branches;
next	1.1;

1.1
date	2009.06.01.22.58.49;	author nicm;	state Exp;
branches;
next	;


desc
@@


1.46
log
@In order that people can use formats like #D in #() in the status line
and not have to wait for an update when they change pane, we allow
commands to run more than once a second if the expanded form
changes. Unfortunately this can mean them being run far too often
(pretty much continually) when multiple clients exist, because some
formats (including #D) will always differ between clients.

To avoid this, give each client its own tree of jobs which means that
the same command will be different instances for each client - similar
to how we have the tag to separate commands for different panes.

GitHub issue 889; test case reported by Paul Johnson.
@
text
@/* $OpenBSD: screen-redraw.c,v 1.45 2017/04/05 10:49:46 nicm Exp $ */

/*
 * Copyright (c) 2007 Nicholas Marriott <nicholas.marriott@@gmail.com>
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF MIND, USE, DATA OR PROFITS, WHETHER
 * IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING
 * OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */

#include <sys/types.h>

#include <string.h>

#include "tmux.h"

static int	screen_redraw_cell_border1(struct window_pane *, u_int, u_int);
static int	screen_redraw_cell_border(struct client *, u_int, u_int);
static int	screen_redraw_check_cell(struct client *, u_int, u_int, int,
		    struct window_pane **);
static int	screen_redraw_check_is(u_int, u_int, int, int, struct window *,
		    struct window_pane *, struct window_pane *);

static int 	screen_redraw_make_pane_status(struct client *, struct window *,
		    struct window_pane *);
static void	screen_redraw_draw_pane_status(struct client *, int);

static void	screen_redraw_draw_borders(struct client *, int, int, u_int);
static void	screen_redraw_draw_panes(struct client *, u_int);
static void	screen_redraw_draw_status(struct client *, u_int);
static void	screen_redraw_draw_number(struct client *, struct window_pane *,
		    u_int);

#define CELL_INSIDE 0
#define CELL_LEFTRIGHT 1
#define CELL_TOPBOTTOM 2
#define CELL_TOPLEFT 3
#define CELL_TOPRIGHT 4
#define CELL_BOTTOMLEFT 5
#define CELL_BOTTOMRIGHT 6
#define CELL_TOPJOIN 7
#define CELL_BOTTOMJOIN 8
#define CELL_LEFTJOIN 9
#define CELL_RIGHTJOIN 10
#define CELL_JOIN 11
#define CELL_OUTSIDE 12

#define CELL_BORDERS " xqlkmjwvtun~"

#define CELL_STATUS_OFF 0
#define CELL_STATUS_TOP 1
#define CELL_STATUS_BOTTOM 2

/* Check if cell is on the border of a particular pane. */
static int
screen_redraw_cell_border1(struct window_pane *wp, u_int px, u_int py)
{
	/* Inside pane. */
	if (px >= wp->xoff && px < wp->xoff + wp->sx &&
	    py >= wp->yoff && py < wp->yoff + wp->sy)
		return (0);

	/* Left/right borders. */
	if ((wp->yoff == 0 || py >= wp->yoff - 1) && py <= wp->yoff + wp->sy) {
		if (wp->xoff != 0 && px == wp->xoff - 1)
			return (1);
		if (px == wp->xoff + wp->sx)
			return (2);
	}

	/* Top/bottom borders. */
	if ((wp->xoff == 0 || px >= wp->xoff - 1) && px <= wp->xoff + wp->sx) {
		if (wp->yoff != 0 && py == wp->yoff - 1)
			return (3);
		if (py == wp->yoff + wp->sy)
			return (4);
	}

	/* Outside pane. */
	return (-1);
}

/* Check if a cell is on the pane border. */
static int
screen_redraw_cell_border(struct client *c, u_int px, u_int py)
{
	struct window		*w = c->session->curw->window;
	struct window_pane	*wp;
	int			 retval;

	/* Check all the panes. */
	TAILQ_FOREACH(wp, &w->panes, entry) {
		if (!window_pane_visible(wp))
			continue;
		if ((retval = screen_redraw_cell_border1(wp, px, py)) != -1)
			return (!!retval);
	}

	return (0);
}

/* Check if cell inside a pane. */
static int
screen_redraw_check_cell(struct client *c, u_int px, u_int py, int pane_status,
    struct window_pane **wpp)
{
	struct window		*w = c->session->curw->window;
	struct window_pane	*wp;
	int			 borders;
	u_int			 right, line;

	*wpp = NULL;

	if (px > w->sx || py > w->sy)
		return (CELL_OUTSIDE);

	if (pane_status != CELL_STATUS_OFF) {
		TAILQ_FOREACH(wp, &w->panes, entry) {
			if (!window_pane_visible(wp))
				continue;

			if (pane_status == CELL_STATUS_TOP)
				line = wp->yoff - 1;
			else
				line = wp->yoff + wp->sy;
			right = wp->xoff + 2 + wp->status_size - 1;

			if (py == line && px >= wp->xoff + 2 && px <= right)
				return (CELL_INSIDE);
		}
	}

	TAILQ_FOREACH(wp, &w->panes, entry) {
		if (!window_pane_visible(wp))
			continue;
		*wpp = wp;

		/* If outside the pane and its border, skip it. */
		if ((wp->xoff != 0 && px < wp->xoff - 1) ||
		    px > wp->xoff + wp->sx ||
		    (wp->yoff != 0 && py < wp->yoff - 1) ||
		    py > wp->yoff + wp->sy)
			continue;

		/* If definitely inside, return so. */
		if (!screen_redraw_cell_border(c, px, py))
			return (CELL_INSIDE);

		/*
		 * Construct a bitmask of whether the cells to the left (bit
		 * 4), right, top, and bottom (bit 1) of this cell are borders.
		 */
		borders = 0;
		if (px == 0 || screen_redraw_cell_border(c, px - 1, py))
			borders |= 8;
		if (px <= w->sx && screen_redraw_cell_border(c, px + 1, py))
			borders |= 4;
		if (pane_status == CELL_STATUS_TOP) {
			if (py != 0 && screen_redraw_cell_border(c, px, py - 1))
				borders |= 2;
		} else {
			if (py == 0 || screen_redraw_cell_border(c, px, py - 1))
				borders |= 2;
		}
		if (py <= w->sy && screen_redraw_cell_border(c, px, py + 1))
			borders |= 1;

		/*
		 * Figure out what kind of border this cell is. Only one bit
		 * set doesn't make sense (can't have a border cell with no
		 * others connected).
		 */
		switch (borders) {
		case 15:	/* 1111, left right top bottom */
			return (CELL_JOIN);
		case 14:	/* 1110, left right top */
			return (CELL_BOTTOMJOIN);
		case 13:	/* 1101, left right bottom */
			return (CELL_TOPJOIN);
		case 12:	/* 1100, left right */
			return (CELL_TOPBOTTOM);
		case 11:	/* 1011, left top bottom */
			return (CELL_RIGHTJOIN);
		case 10:	/* 1010, left top */
			return (CELL_BOTTOMRIGHT);
		case 9:		/* 1001, left bottom */
			return (CELL_TOPRIGHT);
		case 7:		/* 0111, right top bottom */
			return (CELL_LEFTJOIN);
		case 6:		/* 0110, right top */
			return (CELL_BOTTOMLEFT);
		case 5:		/* 0101, right bottom */
			return (CELL_TOPLEFT);
		case 3:		/* 0011, top bottom */
			return (CELL_LEFTRIGHT);
		}
	}

	return (CELL_OUTSIDE);
}

/* Check if the border of a particular pane. */
static int
screen_redraw_check_is(u_int px, u_int py, int type, int pane_status,
    struct window *w, struct window_pane *wantwp, struct window_pane *wp)
{
	int	border;

	/* Is this off the active pane border? */
	border = screen_redraw_cell_border1(wantwp, px, py);
	if (border == 0 || border == -1)
		return (0);
	if (pane_status == CELL_STATUS_TOP && border == 4)
		return (0);
	if (pane_status == CELL_STATUS_BOTTOM && border == 3)
		return (0);

	/* If there are more than two panes, that's enough. */
	if (window_count_panes(w) != 2)
		return (1);

	/* Else if the cell is not a border cell, forget it. */
	if (wp == NULL || (type == CELL_OUTSIDE || type == CELL_INSIDE))
		return (1);

	/* With status lines mark the entire line. */
	if (pane_status != CELL_STATUS_OFF)
		return (1);

	/* Check if the pane covers the whole width. */
	if (wp->xoff == 0 && wp->sx == w->sx) {
		/* This can either be the top pane or the bottom pane. */
		if (wp->yoff == 0) { /* top pane */
			if (wp == wantwp)
				return (px <= wp->sx / 2);
			return (px > wp->sx / 2);
		}
		return (0);
	}

	/* Check if the pane covers the whole height. */
	if (wp->yoff == 0 && wp->sy == w->sy) {
		/* This can either be the left pane or the right pane. */
		if (wp->xoff == 0) { /* left pane */
			if (wp == wantwp)
				return (py <= wp->sy / 2);
			return (py > wp->sy / 2);
		}
		return (0);
	}

	return (1);
}

/* Update pane status. */
static int
screen_redraw_make_pane_status(struct client *c, struct window *w,
    struct window_pane *wp)
{
	struct grid_cell	 gc;
	const char		*fmt;
	struct format_tree	*ft;
	char			*out;
	size_t			 outlen;
	struct screen_write_ctx	 ctx;
	struct screen		 old;

	if (wp == w->active)
		style_apply(&gc, w->options, "pane-active-border-style");
	else
		style_apply(&gc, w->options, "pane-border-style");

	fmt = options_get_string(w->options, "pane-border-format");

	ft = format_create(c, NULL, FORMAT_PANE|wp->id, 0);
	format_defaults(ft, c, NULL, NULL, wp);

	memcpy(&old, &wp->status_screen, sizeof old);
	screen_init(&wp->status_screen, wp->sx, 1, 0);
	wp->status_screen.mode = 0;

	out = format_expand(ft, fmt);
	outlen = screen_write_cstrlen("%s", out);
	if (outlen > wp->sx - 4)
		outlen = wp->sx - 4;
	screen_resize(&wp->status_screen, outlen, 1, 0);

	screen_write_start(&ctx, NULL, &wp->status_screen);
	screen_write_cursormove(&ctx, 0, 0);
	screen_write_clearline(&ctx, 8);
	screen_write_cnputs(&ctx, outlen, &gc, "%s", out);
	screen_write_stop(&ctx);

	format_free(ft);

	wp->status_size = outlen;

	if (grid_compare(wp->status_screen.grid, old.grid) == 0) {
		screen_free(&old);
		return (0);
	}
	screen_free(&old);
	return (1);
}

/* Draw pane status. */
static void
screen_redraw_draw_pane_status(struct client *c, int pane_status)
{
	struct window		*w = c->session->curw->window;
	struct options		*oo = c->session->options;
	struct tty		*tty = &c->tty;
	struct window_pane	*wp;
	int			 spos;
	u_int			 yoff;

	spos = options_get_number(oo, "status-position");
	TAILQ_FOREACH(wp, &w->panes, entry) {
		if (!window_pane_visible(wp))
			continue;
		if (pane_status == CELL_STATUS_TOP)
			yoff = wp->yoff - 1;
		else
			yoff = wp->yoff + wp->sy;
		if (spos == 0)
			yoff += 1;

		tty_draw_line(tty, NULL, &wp->status_screen, 0, wp->xoff + 2,
		    yoff);
	}
	tty_cursor(tty, 0, 0);
}

/* Update status line and change flags if unchanged. */
void
screen_redraw_update(struct client *c)
{
	struct window		*w = c->session->curw->window;
	struct window_pane	*wp;
	struct options		*wo = w->options;
	int			 redraw;

	if (c->message_string != NULL)
		redraw = status_message_redraw(c);
	else if (c->prompt_string != NULL)
		redraw = status_prompt_redraw(c);
	else
		redraw = status_redraw(c);
	if (!redraw)
		c->flags &= ~CLIENT_STATUS;

	if (options_get_number(wo, "pane-border-status") != CELL_STATUS_OFF) {
		redraw = 0;
		TAILQ_FOREACH(wp, &w->panes, entry) {
			if (screen_redraw_make_pane_status(c, w, wp))
				redraw = 1;
		}
		if (redraw)
			c->flags |= CLIENT_BORDERS;
	}
}

/* Redraw entire screen. */
void
screen_redraw_screen(struct client *c, int draw_panes, int draw_status,
    int draw_borders)
{
	struct options		*oo = c->session->options;
	struct tty		*tty = &c->tty;
	struct window		*w = c->session->curw->window;
	struct options		*wo = w->options;
	u_int			 top;
	int	 		 status, pane_status, spos;

	/* Suspended clients should not be updated. */
	if (c->flags & CLIENT_SUSPENDED)
		return;

	/* Get status line, er, status. */
	spos = options_get_number(oo, "status-position");
	if (c->message_string != NULL || c->prompt_string != NULL)
		status = 1;
	else
		status = options_get_number(oo, "status");
	top = 0;
	if (status && spos == 0)
		top = 1;
	if (!status)
		draw_status = 0;

	/* Draw the elements. */
	if (draw_borders) {
		pane_status = options_get_number(wo, "pane-border-status");
		screen_redraw_draw_borders(c, status, pane_status, top);
		if (pane_status != CELL_STATUS_OFF)
			screen_redraw_draw_pane_status(c, pane_status);
	}
	if (draw_panes)
		screen_redraw_draw_panes(c, top);
	if (draw_status)
		screen_redraw_draw_status(c, top);
	tty_reset(tty);
}

/* Draw a single pane. */
void
screen_redraw_pane(struct client *c, struct window_pane *wp)
{
	u_int	i, yoff;

	if (!window_pane_visible(wp))
		return;

	yoff = wp->yoff;
	if (status_at_line(c) == 0)
		yoff++;

	log_debug("%s: redraw pane %%%u (at %u,%u)", c->name, wp->id,
	    wp->xoff, yoff);

	for (i = 0; i < wp->sy; i++)
		tty_draw_pane(&c->tty, wp, i, wp->xoff, yoff);
	tty_reset(&c->tty);
}

/* Draw the borders. */
static void
screen_redraw_draw_borders(struct client *c, int status, int pane_status,
    u_int top)
{
	struct session		*s = c->session;
	struct window		*w = s->curw->window;
	struct options		*oo = w->options;
	struct tty		*tty = &c->tty;
	struct window_pane	*wp;
	struct grid_cell	 m_active_gc, active_gc, m_other_gc, other_gc;
	struct grid_cell	 msg_gc;
	u_int		 	 i, j, type, msgx = 0, msgy = 0;
	int			 active, small, flags;
	char			 msg[256];
	const char		*tmp;
	size_t			 msglen = 0;

	small = (tty->sy - status + top > w->sy) || (tty->sx > w->sx);
	if (small) {
		flags = w->flags & (WINDOW_FORCEWIDTH|WINDOW_FORCEHEIGHT);
		if (flags == (WINDOW_FORCEWIDTH|WINDOW_FORCEHEIGHT))
			tmp = "force-width, force-height";
		else if (flags == WINDOW_FORCEWIDTH)
			tmp = "force-width";
		else if (flags == WINDOW_FORCEHEIGHT)
			tmp = "force-height";
		else
			tmp = "a smaller client";
		xsnprintf(msg, sizeof msg, "(size %ux%u from %s)",
		    w->sx, w->sy, tmp);
		msglen = strlen(msg);

		if (tty->sy - 1 - status + top > w->sy && tty->sx >= msglen) {
			msgx = tty->sx - msglen;
			msgy = tty->sy - 1 - status + top;
		} else if (tty->sx - w->sx > msglen) {
			msgx = tty->sx - msglen;
			msgy = tty->sy - 1 - status + top;
		} else
			small = 0;
	}

	style_apply(&other_gc, oo, "pane-border-style");
	style_apply(&active_gc, oo, "pane-active-border-style");
	active_gc.attr = other_gc.attr = GRID_ATTR_CHARSET;

	memcpy(&m_other_gc, &other_gc, sizeof m_other_gc);
	m_other_gc.attr ^= GRID_ATTR_REVERSE;
	memcpy(&m_active_gc, &active_gc, sizeof m_active_gc);
	m_active_gc.attr ^= GRID_ATTR_REVERSE;

	for (j = 0; j < tty->sy - status; j++) {
		for (i = 0; i < tty->sx; i++) {
			type = screen_redraw_check_cell(c, i, j, pane_status,
			    &wp);
			if (type == CELL_INSIDE)
				continue;
			if (type == CELL_OUTSIDE && small &&
			    i > msgx && j == msgy)
				continue;
			active = screen_redraw_check_is(i, j, type, pane_status,
			    w, w->active, wp);
			if (server_is_marked(s, s->curw, marked_pane.wp) &&
			    screen_redraw_check_is(i, j, type, pane_status, w,
			    marked_pane.wp, wp)) {
				if (active)
					tty_attributes(tty, &m_active_gc, NULL);
				else
					tty_attributes(tty, &m_other_gc, NULL);
			} else if (active)
				tty_attributes(tty, &active_gc, NULL);
			else
				tty_attributes(tty, &other_gc, NULL);
			tty_cursor(tty, i, top + j);
			tty_putc(tty, CELL_BORDERS[type]);
		}
	}

	if (small) {
		memcpy(&msg_gc, &grid_default_cell, sizeof msg_gc);
		tty_attributes(tty, &msg_gc, NULL);
		tty_cursor(tty, msgx, msgy);
		tty_puts(tty, msg);
	}
}

/* Draw the panes. */
static void
screen_redraw_draw_panes(struct client *c, u_int top)
{
	struct window		*w = c->session->curw->window;
	struct tty		*tty = &c->tty;
	struct window_pane	*wp;
	u_int		 	 i;

	TAILQ_FOREACH(wp, &w->panes, entry) {
		if (!window_pane_visible(wp))
			continue;
		for (i = 0; i < wp->sy; i++)
			tty_draw_pane(tty, wp, i, wp->xoff, top + wp->yoff);
		if (c->flags & CLIENT_IDENTIFY)
			screen_redraw_draw_number(c, wp, top);
	}
}

/* Draw the status line. */
static void
screen_redraw_draw_status(struct client *c, u_int top)
{
	struct tty	*tty = &c->tty;

	if (top)
		tty_draw_line(tty, NULL, &c->status, 0, 0, 0);
	else
		tty_draw_line(tty, NULL, &c->status, 0, 0, tty->sy - 1);
}

/* Draw number on a pane. */
static void
screen_redraw_draw_number(struct client *c, struct window_pane *wp, u_int top)
{
	struct tty		*tty = &c->tty;
	struct session		*s = c->session;
	struct options		*oo = s->options;
	struct window		*w = wp->window;
	struct grid_cell	 gc;
	u_int			 idx, px, py, i, j, xoff, yoff;
	int			 colour, active_colour;
	char			 buf[16], *ptr;
	size_t			 len;

	if (window_pane_index(wp, &idx) != 0)
		fatalx("index not found");
	len = xsnprintf(buf, sizeof buf, "%u", idx);

	if (wp->sx < len)
		return;
	colour = options_get_number(oo, "display-panes-colour");
	active_colour = options_get_number(oo, "display-panes-active-colour");

	px = wp->sx / 2; py = wp->sy / 2;
	xoff = wp->xoff; yoff = wp->yoff;

	if (top)
		yoff++;

	if (wp->sx < len * 6 || wp->sy < 5) {
		tty_cursor(tty, xoff + px - len / 2, yoff + py);
		goto draw_text;
	}

	px -= len * 3;
	py -= 2;

	memcpy(&gc, &grid_default_cell, sizeof gc);
	if (w->active == wp)
		gc.bg = active_colour;
	else
		gc.bg = colour;
	gc.flags |= GRID_FLAG_NOPALETTE;

	tty_attributes(tty, &gc, wp);
	for (ptr = buf; *ptr != '\0'; ptr++) {
		if (*ptr < '0' || *ptr > '9')
			continue;
		idx = *ptr - '0';

		for (j = 0; j < 5; j++) {
			for (i = px; i < px + 5; i++) {
				tty_cursor(tty, xoff + i, yoff + py + j);
				if (window_clock_table[idx][j][i - px])
					tty_putc(tty, ' ');
			}
		}
		px += 6;
	}

	len = xsnprintf(buf, sizeof buf, "%ux%u", wp->sx, wp->sy);
	if (wp->sx < len || wp->sy < 6)
		return;
	tty_cursor(tty, xoff + wp->sx - len, yoff);

draw_text:
	memcpy(&gc, &grid_default_cell, sizeof gc);
	if (w->active == wp)
		gc.fg = active_colour;
	else
		gc.fg = colour;
	gc.flags |= GRID_FLAG_NOPALETTE;

	tty_attributes(tty, &gc, wp);
	tty_puts(tty, buf);

	tty_cursor(tty, 0, 0);
}
@


1.45
log
@Give each client a name. This defaults to the tty name as before but
falls back to an alternative if the tty name is not available. This is
clearer than overloading the client ttyname member and allows us to
remove the path stored in the tty struct, it should always be the same
as the client.
@
text
@d1 1
a1 1
/* $OpenBSD: screen-redraw.c,v 1.44 2017/02/08 15:41:41 nicm Exp $ */
d283 1
a283 1
	ft = format_create(NULL, FORMAT_PANE|wp->id, 0);
@


1.44
log
@Add a helper to store a cell, and some tidying.
@
text
@d1 1
a1 1
/* $OpenBSD: screen-redraw.c,v 1.43 2017/02/03 11:57:27 nicm Exp $ */
d426 1
a426 1
	log_debug("%s: redraw pane %%%u (at %u,%u)", c->tty.path, wp->id,
@


1.43
log
@Add a window or pane id "tag" to each format tree and use it to separate
jobs, this means that if the same job is used for different windows or
panes (for example in pane-border-format), it will be run separately for
each pane.
@
text
@d1 1
a1 1
/* $OpenBSD: screen-redraw.c,v 1.42 2017/01/07 15:28:13 nicm Exp $ */
d425 3
@


1.42
log
@Add support for the OSC 4 and OSC 104 palette setting escape sequences,
from S Gilles.
@
text
@d1 1
a1 1
/* $OpenBSD: screen-redraw.c,v 1.41 2016/10/13 20:27:27 nicm Exp $ */
d283 1
a283 1
	ft = format_create(NULL, 0);
@


1.41
log
@Add support for BCE (background colour erase). This makes various escape
sequences (notable EL and ED but also IL, DL, ICH, DCH) create blank
cells using the current background colour rather than the default
colour.

On modern systems BCE doesn't really have many benefits, but most other
terminals now support it, some (lazy) applications rely on it, and it is
not hard to include now that we have pane background colours anyway.

Mostly written by Sean Haugh.
@
text
@d1 1
a1 1
/* $OpenBSD: screen-redraw.c,v 1.40 2016/10/12 17:36:52 nicm Exp $ */
d591 2
d620 2
@


1.40
log
@Compare to see if pane status line has actually changed, not just size, and
do not draw if pane is not visible.
@
text
@d1 1
a1 1
/* $OpenBSD: screen-redraw.c,v 1.39 2016/10/10 21:29:23 nicm Exp $ */
d298 1
a298 1
	screen_write_clearline(&ctx);
@


1.39
log
@Loads more static, except for cmd-*.c and window-*.c.
@
text
@d1 1
a1 1
/* $OpenBSD: screen-redraw.c,v 1.38 2016/10/09 16:24:34 nicm Exp $ */
d272 1
a272 1
	size_t			 outlen, old_size = wp->status_size;
d274 1
d286 1
a286 1
	screen_free(&wp->status_screen);
d305 7
a311 1
	return (wp->status_size != old_size);
d327 2
@


1.38
log
@Make the CLIENT_STATUS flag imply that pane status lines are redrawn if
they are enabled and break the actual screen generation code into a
separate function. Fixes problems reported by Romain Francoise.
@
text
@d1 1
a1 1
/* $OpenBSD: screen-redraw.c,v 1.37 2016/07/15 00:42:56 nicm Exp $ */
d25 16
a40 15
int	screen_redraw_cell_border1(struct window_pane *, u_int, u_int);
int	screen_redraw_cell_border(struct client *, u_int, u_int);
int	screen_redraw_check_cell(struct client *, u_int, u_int, int,
	    struct window_pane **);
int	screen_redraw_check_is(u_int, u_int, int, int, struct window *,
	    struct window_pane *, struct window_pane *);

int 	screen_redraw_make_pane_status(struct client *, struct window *,
	    struct window_pane *);
void	screen_redraw_draw_pane_status(struct client *, int);

void	screen_redraw_draw_borders(struct client *, int, int, u_int);
void	screen_redraw_draw_panes(struct client *, u_int);
void	screen_redraw_draw_status(struct client *, u_int);
void	screen_redraw_draw_number(struct client *, struct window_pane *, u_int);
d63 1
a63 1
int
d92 1
a92 1
int
d111 1
a111 1
int
d120 2
a206 1
	*wpp = NULL;
d211 1
a211 1
int
d264 1
a264 1
int
d308 1
a308 1
void
d423 1
a423 1
void
d510 1
a510 1
void
d529 1
a529 1
void
d541 1
a541 1
void
@


1.37
log
@Instead of representing colours in several different forms with various
cell flags, convert to use an int with flags marking 256 or RGB colours
in the top byte (except in cells, which we don't want to make any
bigger). From Brad Town.
@
text
@d1 1
a1 1
/* $OpenBSD: screen-redraw.c,v 1.36 2016/04/29 15:00:48 nicm Exp $ */
d331 29
d368 1
a368 1
	struct window_pane	*wp;
a387 9
	/* Update pane status lines. */
	pane_status = options_get_number(w->options, "pane-border-status");
	if (pane_status != CELL_STATUS_OFF && (draw_borders || draw_status)) {
		TAILQ_FOREACH(wp, &w->panes, entry) {
			if (screen_redraw_make_pane_status(c, w, wp))
				draw_borders = draw_status = 1;
		}
	}

d389 2
a390 1
	if (draw_borders)
d392 3
a398 2
	if (pane_status != CELL_STATUS_OFF && (draw_borders || draw_status))
		screen_redraw_draw_pane_status(c, pane_status);
@


1.36
log
@Add option to include status text in the pane borders. If
pane-border-status is set to "top" or "bottom" (rather than "off"),
every pane has a permanent top or bottom border containing the text from
pane-border-format.

Based on a diff sent long ago by Jonathan Slenders, mostly rewritten and
simplified by me.
@
text
@d1 1
a1 1
/* $OpenBSD: screen-redraw.c,v 1.35 2016/01/19 15:59:12 nicm Exp $ */
d555 1
a555 1
		colour_set_bg(&gc, active_colour);
d557 1
a557 1
		colour_set_bg(&gc, colour);
d582 1
a582 1
		colour_set_fg(&gc, active_colour);
d584 1
a584 1
		colour_set_fg(&gc, colour);
@


1.35
log
@I no longer use my SourceForge address so replace it.
@
text
@d1 1
a1 1
/* $OpenBSD: screen-redraw.c,v 1.34 2015/12/15 00:00:01 nicm Exp $ */
d27 1
a27 1
int	screen_redraw_check_cell(struct client *, u_int, u_int,
d29 1
a29 1
int	screen_redraw_check_is(u_int, u_int, int, struct window *,
d32 5
a36 1
void	screen_redraw_draw_borders(struct client *, int, u_int);
d57 4
d75 1
a75 1
			return (1);
d81 1
a81 1
			return (1);
d83 1
a83 1
			return (1);
d103 1
a103 1
			return (retval);
d111 1
a111 1
screen_redraw_check_cell(struct client *c, u_int px, u_int py,
d117 1
d122 16
d163 7
a169 2
		if (py == 0 || screen_redraw_cell_border(c, px, py - 1))
			borders |= 2;
d210 2
a211 2
screen_redraw_check_is(u_int px, u_int py, int type, struct window *w,
    struct window_pane *wantwp, struct window_pane *wp)
d213 2
d216 6
a221 1
	if (screen_redraw_cell_border1(wantwp, px, py) != 1)
d232 4
d258 71
a328 1
	return (type);
d336 6
a341 4
	struct options	*oo = c->session->options;
	struct tty	*tty = &c->tty;
	u_int		 top;
	int	 	 status, spos;
d359 10
d370 1
a370 1
		screen_redraw_draw_borders(c, status, top);
d375 2
d400 2
a401 1
screen_redraw_draw_borders(struct client *c, int status, u_int top)
d452 2
a453 1
			type = screen_redraw_check_cell(c, i, j, &wp);
d459 2
a460 2
			active = screen_redraw_check_is(i, j, type, w,
			    w->active, wp);
d462 1
a462 1
			    screen_redraw_check_is(i, j, type, w,
@


1.34
log
@Make the marked pane a cmd_find_state.
@
text
@d1 1
a1 1
/* $OpenBSD: screen-redraw.c,v 1.33 2015/10/27 15:58:42 nicm Exp $ */
d4 1
a4 1
 * Copyright (c) 2007 Nicholas Marriott <nicm@@users.sourceforge.net>
@


1.33
log
@Move struct options into options.c.
@
text
@d1 1
a1 1
/* $OpenBSD: screen-redraw.c,v 1.32 2015/06/04 11:43:51 nicm Exp $ */
d334 1
a334 1
			if (server_is_marked(s, s->curw, marked_window_pane) &&
d336 1
a336 1
			    marked_window_pane, wp)) {
@


1.32
log
@Add support for a single "marked pane". There is one marked pane in the
server at a time; it may be toggled or cleared with select-pane -m and
-M (the border is highlighted). A new target '~' or '{marked}' specifies
the marked pane to commands and it is the default target for the
swap-pane and join-pane -s flag (this makes them much simpler to use -
mark the source pane and then change to the target pane to run swapp or
joinp).
@
text
@d1 1
a1 1
/* $OpenBSD: screen-redraw.c,v 1.31 2015/05/07 07:16:14 nicm Exp $ */
d225 1
a225 1
	struct options	*oo = &c->session->options;
d279 1
a279 1
	struct options		*oo = &w->options;
d395 1
a395 1
	struct options		*oo = &s->options;
@


1.31
log
@If status line is at the top, the offset needs to be adjusted when
drawing pane numbers.  Based on a diff from John O'Meara.
@
text
@d1 1
a1 1
/* $OpenBSD: screen-redraw.c,v 1.30 2015/04/19 21:05:27 nicm Exp $ */
d29 2
a30 2
int	screen_redraw_check_active(u_int, u_int, int, struct window *,
	    struct window_pane *);
d178 1
a178 1
/* Check active pane indicator. */
d180 2
a181 2
screen_redraw_check_active(u_int px, u_int py, int type, struct window *w,
    struct window_pane *wp)
d184 1
a184 1
	if (screen_redraw_cell_border1(w->active, px, py) != 1)
d199 1
a199 1
			if (wp == w->active)
d210 1
a210 1
			if (wp == w->active)
d277 2
a278 1
	struct window		*w = c->session->curw->window;
d282 2
a283 1
	struct grid_cell	 active_gc, other_gc, msg_gc;
d285 1
a285 1
	int			 small, flags;
d319 5
d329 2
a330 2
			if (type == CELL_OUTSIDE &&
			    small && i > msgx && j == msgy)
d332 10
a341 1
			if (screen_redraw_check_active(i, j, type, w, wp))
@


1.30
log
@Support setting the default window and pane background colours (window
and active pane via window-style and window-active-style options, an
individual pane by a new select-pane -P flag). From J Raynor.
@
text
@d1 1
a1 1
/* $OpenBSD: screen-redraw.c,v 1.29 2015/02/06 15:09:34 nicm Exp $ */
d35 1
a35 1
void	screen_redraw_draw_number(struct client *, struct window_pane *);
d357 1
a357 1
			screen_redraw_draw_number(c, wp);
d375 1
a375 1
screen_redraw_draw_number(struct client *c, struct window_pane *wp)
d398 3
@


1.29
log
@Move pane border options to window options rather than session, from Marc Finet.
@
text
@d1 1
a1 1
/* $OpenBSD: screen-redraw.c,v 1.28 2014/11/14 02:19:47 nicm Exp $ */
d269 1
a269 1
		tty_draw_line(&c->tty, wp->screen, i, wp->xoff, yoff);
d326 1
a326 1
				tty_attributes(tty, &active_gc);
d328 1
a328 1
				tty_attributes(tty, &other_gc);
d336 1
a336 1
		tty_attributes(tty, &msg_gc);
a348 1
	struct screen		*s;
a353 1
		s = wp->screen;
d355 1
a355 1
			tty_draw_line(tty, s, i, wp->xoff, top + wp->yoff);
d368 1
a368 1
		tty_draw_line(tty, &c->status, 0, 0, 0);
d370 1
a370 1
		tty_draw_line(tty, &c->status, 0, 0, tty->sy - 1);
d412 1
a412 1
	tty_attributes(tty, &gc);
d439 1
a439 1
	tty_attributes(tty, &gc);
@


1.28
log
@Label windows which are smaller than expected with a reason.
@
text
@d1 1
a1 1
/* $OpenBSD: screen-redraw.c,v 1.27 2014/03/31 21:34:08 nicm Exp $ */
d278 1
a278 1
	struct options		*oo = &c->session->options;
@


1.27
log
@Having three *clock* files is ridiculous, remove clock.c.
@
text
@d1 1
a1 1
/* $OpenBSD: screen-redraw.c,v 1.26 2014/01/31 14:19:24 nicm Exp $ */
d281 31
a311 2
	struct grid_cell	 active_gc, other_gc;
	u_int		 	 i, j, type;
d322 3
d332 7
@


1.26
log
@Break up and simplify screen_redraw_screen.
@
text
@d1 1
a1 1
/* $OpenBSD: screen-redraw.c,v 1.25 2014/01/28 23:07:09 nicm Exp $ */
d384 1
a384 1
				if (clock_table[idx][j][i - px])
@


1.25
log
@Allow replacing each of the many sets of separate foo-{fg,bg,attr}
options with a single foo-style option. For example:

    set -g status-fg yellow
    set -g status-bg red
    set -g status-attr blink

Becomes:

    set -g status-style fg=yellow,bg=red,blink

The -a flag to set can be used to add to rather than replace a style. So:

    set -g status-bg red

Becomes:

    set -ag status-style bg=red

Currently this is fully backwards compatible (all *-{fg,bg,attr} options
remain) but the plan is to deprecate them over time.

From Tiago Cunha.
@
text
@d1 1
a1 1
/* $OpenBSD: screen-redraw.c,v 1.24 2013/03/25 11:41:49 nicm Exp $ */
d32 3
d222 2
a223 1
screen_redraw_screen(struct client *c, int status_only, int borders_only)
d225 4
a228 7
	struct window		*w = c->session->curw->window;
	struct options		*oo = &c->session->options;
	struct tty		*tty = &c->tty;
	struct window_pane	*wp;
	struct grid_cell	 active_gc, other_gc;
	u_int		 	 i, j, type, top;
	int		 	 status, spos;
d243 11
d255 7
a261 7
	/* If only drawing status and it is present, don't need the rest. */
	if (status_only && status) {
		if (top)
			tty_draw_line(tty, &c->status, 0, 0, 0);
		else
			tty_draw_line(tty, &c->status, 0, 0, tty->sy - 1);
		tty_reset(tty);
a262 1
	}
d264 20
a283 1
	/* Set up pane border attributes. */
d286 1
a286 1
	active_gc.attr = other_gc.attr = GRID_ATTR_CHARSET; /* nuke existing */
a287 1
	/* Draw background and borders. */
a288 6
		if (status_only) {
			if (spos == 1 && j != tty->sy - 1)
				continue;
			else if (spos == 0 && j != 0)
				break;
		}
d301 1
d303 9
a311 3
	/* If only drawing borders, that's it. */
	if (borders_only)
		return;
a312 1
	/* Draw the panes, if necessary. */
d316 3
a318 10
		for (i = 0; i < wp->sy; i++) {
			if (status_only) {
				if (spos == 1 && wp->yoff + i != tty->sy - 1)
					continue;
				else if (spos == 0 && wp->yoff + i != 0)
					break;
			}
			tty_draw_line(
			    tty, wp->screen, i, wp->xoff, top + wp->yoff);
		}
a321 9

	/* Draw the status line. */
	if (status) {
		if (top)
			tty_draw_line(tty, &c->status, 0, 0, 0);
		else
			tty_draw_line(tty, &c->status, 0, 0, tty->sy - 1);
	}
	tty_reset(tty);
d324 1
a324 1
/* Draw a single pane. */
d326 1
a326 1
screen_redraw_pane(struct client *c, struct window_pane *wp)
d328 1
a328 1
	u_int	i, yoff;
d330 4
a333 10
	if (!window_pane_visible(wp))
		return;

	yoff = wp->yoff;
	if (status_at_line(c) == 0)
		yoff++;

	for (i = 0; i < wp->sy; i++)
		tty_draw_line(&c->tty, wp->screen, i, wp->xoff, yoff);
	tty_reset(&c->tty);
@


1.24
log
@When only two panes in a window, only draw half the separating line as
active.
@
text
@d1 1
a1 1
/* $OpenBSD: screen-redraw.c,v 1.23 2013/03/25 10:12:01 nicm Exp $ */
d227 1
a227 1
	int		 	 status, spos, fg, bg;
d254 3
a256 11
	memcpy(&other_gc, &grid_marker_cell, sizeof other_gc);
	memcpy(&active_gc, &grid_marker_cell, sizeof active_gc);
	active_gc.attr = other_gc.attr = GRID_ATTR_CHARSET;
	fg = options_get_number(oo, "pane-border-fg");
	colour_set_fg(&other_gc, fg);
	bg = options_get_number(oo, "pane-border-bg");
	colour_set_bg(&other_gc, bg);
	fg = options_get_number(oo, "pane-active-border-fg");
	colour_set_fg(&active_gc, fg);
	bg = options_get_number(oo, "pane-active-border-bg");
	colour_set_bg(&active_gc, bg);
d363 1
a363 1
	memcpy(&gc, &grid_marker_cell, sizeof gc);
d390 1
a390 1
	memcpy(&gc, &grid_marker_cell, sizeof gc);
@


1.23
log
@Do not redraw panes if invisible.
@
text
@d1 1
a1 1
/* $OpenBSD: screen-redraw.c,v 1.22 2012/05/23 19:19:40 nicm Exp $ */
d27 5
a31 1
int	screen_redraw_check_cell(struct client *, u_int, u_int);
d100 2
a101 1
screen_redraw_check_cell(struct client *c, u_int px, u_int py)
d113 1
d171 1
d175 42
d275 1
a275 1
			type = screen_redraw_check_cell(c, i, j);
d278 1
a278 1
			if (screen_redraw_cell_border1(w->active, i, j) == 1)
@


1.22
log
@Use a predefined structure for not-space cells used to set attributes.
@
text
@d1 1
a1 1
/* $OpenBSD: screen-redraw.c,v 1.21 2012/01/29 09:37:02 nicm Exp $ */
d275 3
@


1.21
log
@Add an option to move the status line to the top of the screen,
requested by many.
@
text
@d1 1
a1 1
/* $OpenBSD: screen-redraw.c,v 1.20 2012/01/21 23:45:44 nicm Exp $ */
d205 2
a206 3
	memcpy(&other_gc, &grid_default_cell, sizeof other_gc);
	memcpy(&active_gc, &grid_default_cell, sizeof active_gc);
	active_gc.data = other_gc.data = 'x'; /* not space */
d319 1
a319 2
	memcpy(&gc, &grid_default_cell, sizeof gc);
	gc.data = '_'; /* not space */
d346 1
a346 2
	memcpy(&gc, &grid_default_cell, sizeof gc);
	gc.data = '_'; /* not space */
@


1.20
log
@Show pane size in top right of display panes mode.
@
text
@d1 1
a1 1
/* $OpenBSD: screen-redraw.c,v 1.19 2011/11/15 23:19:51 nicm Exp $ */
d173 1
d177 2
a178 2
	u_int		 	 i, j, type;
	int		 	 status, fg, bg;
d185 1
d189 4
a192 1
		status = options_get_number(&c->session->options, "status");
d196 4
a199 1
		tty_draw_line(tty, &c->status, 0, 0, tty->sy - 1);
d209 1
a209 1
	fg = options_get_number(&c->session->options, "pane-border-fg");
d211 1
a211 1
	bg = options_get_number(&c->session->options, "pane-border-bg");
d213 1
a213 1
	fg = options_get_number(&c->session->options, "pane-active-border-fg");
d215 1
a215 1
	bg = options_get_number(&c->session->options, "pane-active-border-bg");
d220 6
a225 2
		if (status_only && j != tty->sy - 1)
			continue;
d234 1
a234 1
			tty_cursor(tty, i, j);
d248 8
a255 3
			if (status_only && wp->yoff + i != tty->sy - 1)
				continue;
			tty_draw_line(tty, wp->screen, i, wp->xoff, wp->yoff);
d262 6
a267 2
	if (status)
		tty_draw_line(tty, &c->status, 0, 0, tty->sy - 1);
d275 5
a279 1
	u_int	i;
d282 1
a282 1
		tty_draw_line(&c->tty, wp->screen, i, wp->xoff, wp->yoff);
@


1.19
log
@Make window_pane_index work the same as window_index, from Ben Boeckel.
@
text
@d1 1
a1 1
/* $OpenBSD: screen-redraw.c,v 1.18 2011/07/08 21:51:40 nicm Exp $ */
d289 1
a289 9
		memcpy(&gc, &grid_default_cell, sizeof gc);
		gc.data = '_'; /* not space */
		if (w->active == wp)
			colour_set_fg(&gc, active_colour);
		else
			colour_set_fg(&gc, colour);
		tty_attributes(tty, &gc);
		tty_puts(tty, buf);
		return;
d316 17
@


1.18
log
@Do not continue to send data to suspended/locked clients or there will
be a huge rush of it after they are resumed/unlocked. The main output
path was fine but status line updates and the terminal state reset code
were missed.
@
text
@d1 1
a1 1
/* $OpenBSD: screen-redraw.c,v 1.17 2010/09/11 16:19:22 nicm Exp $ */
d267 1
a267 1
	struct options	        *oo = &s->options;
d275 2
a276 1
	idx = window_pane_index(w, wp);
@


1.17
log
@Use UTF-8 line drawing characters on UTF-8 terminals. Fixes some stupid
terminals (I'm looking at you, putty) which disable the vt100 ACS mode
switching sequences in UTF-8 mode.

Also on terminals without ACS at all, use ASCII equivalents where
obvious.
@
text
@d1 1
a1 1
/* $OpenBSD: screen-redraw.c,v 1.16 2010/02/04 18:20:16 nicm Exp $ */
d178 4
@


1.16
log
@Option to display the active pane in a different colour with the display-panes
command. From Paul Hoffman, thanks.
@
text
@d1 1
a1 1
/* $OpenBSD: screen-redraw.c,v 1.15 2010/01/03 12:51:05 nicm Exp $ */
d44 2
a177 2
	const u_char		*base, *ptr;
	u_char		       	 ch, border[20];
d196 1
a206 10
	strlcpy(border, " |-....--||+.", sizeof border);
	if (tty_term_has(tty->term, TTYC_ACSC)) {
		base = " xqlkmjwvtun~";
		for (ptr = base; *ptr != '\0'; ptr++) {
			if ((ch = tty_get_acs(tty, *ptr)) != '\0')
				border[ptr - base] = ch;
		}
		other_gc.attr |= GRID_ATTR_CHARSET;
		active_gc.attr |= GRID_ATTR_CHARSET;
	}
d219 1
a219 1
			tty_putc(tty, border[type]);
@


1.15
log
@Options to set the colour of the pane borders, with different colours for the
active pane.
@
text
@d1 1
a1 1
/* $OpenBSD: screen-redraw.c,v 1.14 2009/12/03 22:50:10 nicm Exp $ */
d272 2
d276 1
a276 1
	int			 colour;
d280 1
a280 1
	idx = window_pane_index(wp->window, wp);
d285 2
a286 1
	colour = options_get_number(&s->options, "display-panes-colour");
d295 4
a298 1
		colour_set_fg(&gc, colour);
d309 4
a312 1
	colour_set_bg(&gc, colour);
@


1.14
log
@Massive spaces->tabs and trailing whitespace cleanup, hopefully for the last
time now I've configured emacs to make them displayed in really annoying
colours...
@
text
@d1 1
a1 1
/* $OpenBSD: screen-redraw.c,v 1.13 2009/10/28 08:52:36 nicm Exp $ */
d25 1
d44 29
d79 1
d85 2
a86 23

		/* Inside pane. */
		if (px >= wp->xoff && px < wp->xoff + wp->sx &&
		    py >= wp->yoff && py < wp->yoff + wp->sy)
			return (0);

		/* Left/right borders. */
		if ((wp->yoff == 0 || py >= wp->yoff - 1) &&
		    py <= wp->yoff + wp->sy) {
			if (wp->xoff != 0 && px == wp->xoff - 1)
				return (1);
			if (px == wp->xoff + wp->sx)
				return (1);
		}

		/* Top/bottom borders. */
		if ((wp->xoff == 0 || px >= wp->xoff - 1) &&
		    px <= wp->xoff + wp->sx) {
			if (wp->yoff != 0 && py == wp->yoff - 1)
				return (1);
			if (py == wp->yoff + wp->sy)
				return (1);
		}
d168 1
a168 1
screen_redraw_screen(struct client *c, int status_only)
d173 1
d175 1
a175 1
	int		 	 status;
d192 13
a205 1
	tty_reset(tty);
d213 2
a214 1
		tty_putcode(tty, TTYC_SMACS);
d221 8
a228 4
			if (type != CELL_INSIDE) {
				tty_cursor(tty, i, j);
				tty_putc(tty, border[type]);
			}
a230 1
	tty_putcode(tty, TTYC_RMACS);
d232 5
a236 1
	/* Draw the panes. */
@


1.13
log
@Add a minor optimisatin: if the character being printed is space, don't worry
about setting the background colour or attributes (except reverse).
@
text
@d1 1
a1 1
/* $OpenBSD: screen-redraw.c,v 1.12 2009/10/12 09:29:58 nicm Exp $ */
d70 1
a70 1
		if ((wp->xoff == 0 || px >= wp->xoff - 1) && 
d108 1
a108 1
		/* 
d122 1
a122 1
		/* 
d266 1
a266 1
	
d278 1
a278 1
		
@


1.12
log
@Similarly add a tty_cursor_pane function to tidy up most of the calls.
@
text
@d1 1
a1 1
/* $OpenBSD: screen-redraw.c,v 1.11 2009/09/10 17:16:24 nicm Exp $ */
d260 1
d271 1
@


1.11
log
@Permit options such as status-bg to be configured using the entire 256 colour
palette by setting "colour0" to "colour255".
@
text
@d1 1
a1 1
/* $OpenBSD: screen-redraw.c,v 1.10 2009/08/31 20:46:19 nicm Exp $ */
d198 1
a198 1
				tty_cursor(tty, i, j, 0, 0);
d242 1
a242 1
	u_int			 idx, px, py, i, j;
d254 3
a256 2
	px = wp->sx / 2;
	py = wp->sy / 2;
d258 1
a258 1
		tty_cursor(tty, px - len / 2, py, wp->xoff, wp->yoff);
d279 1
a279 1
				tty_cursor(tty, i, py + j, wp->xoff, wp->yoff);
@


1.10
log
@Add a new display-panes command, with two options (display-panes-colour and
display-panes-time), which displays a visual indication of the number of each
pane.
@
text
@d1 1
a1 1
/* $OpenBSD: screen-redraw.c,v 1.9 2009/08/10 19:42:03 nicm Exp $ */
d243 1
a243 1
	u_char			 colour;
d259 1
a259 1
		gc.fg = colour;
d269 1
a269 1
	gc.bg = colour;
d279 2
a280 3
				if (!clock_table[idx][j][i - px])
					continue;
				tty_putc(tty, ' ');
@


1.9
log
@Reset the attributes after drawing all or part of the screen, and reset the
region before poll(2). This reduces (but does not eliminate) the chance of the
attributes not being normal if tmux is disconnected without warning (ssh ~.,
reboot from inside, etc).
@
text
@d1 1
a1 1
/* $OpenBSD: screen-redraw.c,v 1.8 2009/07/31 10:12:49 nicm Exp $ */
d27 1
d214 2
d233 53
@


1.8
log
@Pass the ACS border characters through tty_get_acs so they appear correctly on
terminals which don't use the standard set.
@
text
@d1 1
a1 1
/* $OpenBSD: screen-redraw.c,v 1.7 2009/07/24 19:14:38 nicm Exp $ */
d176 1
d218 1
d229 1
@


1.7
log
@Use the full range of ACS line drawing characters to draw pane borders,
including intersections.
@
text
@d1 1
a1 1
/* $OpenBSD: screen-redraw.c,v 1.6 2009/07/24 16:21:42 nicm Exp $ */
d164 2
a165 1
	const u_char		*border;
d181 1
d183 5
a187 1
		border = " xqlkmjwvtun~";
d189 1
a189 2
	} else 
		border = " |-....--||+.";
@


1.6
log
@Simplify screen redrawing by drawing the border and background together rather
than border separately, and consolidating all the drawing characters into one
string.
@
text
@d1 1
a1 1
/* $OpenBSD: screen-redraw.c,v 1.5 2009/07/14 19:11:58 nicm Exp $ */
d25 1
d29 12
a40 5
#define CELL_LEFT 1
#define CELL_RIGHT 2
#define CELL_TOP 3
#define CELL_BOTTOM 4
#define CELL_OUTSIDE 5
d42 1
a42 1
/* Check if cell inside a pane. */
d44 1
a44 1
screen_redraw_check_cell(struct client *c, u_int px, u_int py)
d49 1
a49 3
	if (px > w->sx || py > w->sy)
		return (CELL_OUTSIDE);

d57 1
a57 1
			return (CELL_INSIDE);
d60 2
a61 1
		if (py >= wp->yoff && py < wp->yoff + wp->sy) {
d63 1
a63 1
				return (CELL_LEFT);
d65 1
a65 1
				return (CELL_RIGHT);
d69 2
a70 1
		if (px >= wp->xoff && px < wp->xoff + wp->sx) {
d72 1
a72 1
				return (CELL_TOP);
d74 75
a148 1
				return (CELL_BOTTOM);
d181 1
a181 1
		border = " xxqq~";
d184 1
a184 1
		border = " ||--.";
@


1.5
log
@For some reason when clearing status/message it was redrawing the entire client
not just the status line. Changing this also revealed the check for the status
line was incorrect when drawing the pane.
@
text
@d1 1
a1 1
/* $OpenBSD: screen-redraw.c,v 1.4 2009/07/14 19:03:16 nicm Exp $ */
d27 7
d42 1
a42 1
		return (0);
d51 1
a51 1
			return (1);
d56 1
a56 1
				return (1);
d58 1
a58 1
				return (1);
d64 1
a64 1
				return (1);
d66 1
a66 1
				return (1);
d70 1
a70 1
	return (0);
d80 3
a82 3
	u_int		 	 i, j, sx, sy;
	int		 	 status, has_acs;
	u_char			 choriz, cvert, cbackg;
d96 2
a97 1
	/* Work out ACS characters. */
d99 1
a99 14
		has_acs = 1;
		choriz = tty_get_acs(tty, 'q');
		cvert = tty_get_acs(tty, 'x');
		cbackg = tty_get_acs(tty, '~');
	} else {
		has_acs = 0;
		choriz = '-';
		cvert = '|';
		cbackg = '.';
	}

	/* Clear the screen. */
	tty_reset(tty);
	if (has_acs)
d101 2
d107 2
a108 1
			if (!screen_redraw_check_cell(c, i, j)) {
d110 1
a110 1
				tty_putc(tty, cbackg);
d114 1
a114 2
	if (has_acs)
		tty_putcode(tty, TTYC_RMACS);
a119 45

		tty_reset(tty);

		sx = wp->sx;
		sy = wp->sy;

		/* Draw left and right borders. */
		if (has_acs)
			tty_putcode(tty, TTYC_SMACS);
		if (wp->xoff > 0) {
			for (i = wp->yoff; i < wp->yoff + sy; i++) {
				if (status_only && i != tty->sy - 1)
					continue;
				tty_cursor(tty, wp->xoff - 1, i, 0, 0);
				tty_putc(tty, cvert);
			}
		}
		if (wp->xoff + sx < tty->sx) {
			for (i = wp->yoff; i < wp->yoff + sy; i++) {
				if (status_only && i != tty->sy - 1)
					continue;
				tty_cursor(tty, wp->xoff + sx, i, 0, 0);
				tty_putc(&c->tty, cvert);
			}
		}

		/* Draw top and bottom borders. */
		if (wp->yoff > 0) {
			if (!status_only || wp->yoff - 1 == tty->sy - 1) {
				tty_cursor(tty, wp->xoff, wp->yoff - 1, 0, 0);
				for (i = 0; i < sx; i++)
					tty_putc(tty, choriz);
			}
		}
		if (wp->yoff + sy < tty->sy - status) {
			if (!status_only || wp->yoff + sy == tty->sy - 1) {
				tty_cursor(tty, wp->xoff, wp->yoff + sy, 0, 0);
				for (i = 0; i < sx; i++)
					tty_putc(tty, choriz);
			}
		}
		if (has_acs)
			tty_putcode(tty, TTYC_RMACS);

		/* Draw the pane. */
@


1.4
log
@Instead of faking up a status line in status_redraw, use the same code to
redraw it as to draw the entire screen, just skip all lines but the last.

This makes horizontal split redraw properly when the status line is off.
@
text
@d1 1
a1 1
/* $OpenBSD: screen-redraw.c,v 1.3 2009/07/14 07:23:36 nicm Exp $ */
d169 1
a169 1
			if (status_only && i != tty->sy - 1)
@


1.3
log
@Get rid of the PANE_HIDDEN flag in favour of a function, and moving the
decision for whether or not a pane should be drawn out of the layout code and
into the redraw code.

This is needed for the new layout design, getting it in now to make that easier
to work on.
@
text
@d1 1
a1 1
/* $OpenBSD: screen-redraw.c,v 1.2 2009/06/25 05:56:44 nicm Exp $ */
d66 1
a66 1
/* Redraw entire screen.. */
d68 1
a68 1
screen_redraw_screen(struct client *c)
d78 10
a87 1
	status = options_get_number(&c->session->options, "status");
d107 2
d134 2
d142 2
d151 5
a155 3
			tty_cursor(tty, wp->xoff, wp->yoff - 1, 0, 0);
			for (i = 0; i < sx; i++)
				tty_putc(tty, choriz);
d158 5
a162 3
			tty_cursor(tty, wp->xoff, wp->yoff + sy, 0, 0);
			for (i = 0; i < sx; i++)
				tty_putc(tty, choriz);
d168 5
a172 1
		screen_redraw_pane(c, wp);
d176 2
a177 1
	screen_redraw_status(c);
a187 8
}


/* Draw the status line. */
void
screen_redraw_status(struct client *c)
{
	tty_draw_line(&c->tty, &c->status, 0, 0, c->tty.sy - 1);
@


1.2
log
@Unused variables. Found by lint, no binary change.
@
text
@d1 1
a1 1
/* $OpenBSD: screen-redraw.c,v 1.1 2009/06/01 22:58:49 nicm Exp $ */
d38 3
d110 1
a110 1
		if (wp->flags & PANE_HIDDEN)
@


1.1
log
@Import tmux, a terminal multiplexor allowing (among other things) a single
terminal to be switched between several different windows and programs
displayed on one terminal be detached from one terminal and moved to another.

ok deraadt pirofti
@
text
@d1 1
a1 1
/* $OpenBSD$ */
a69 1
	struct screen		*s;
a111 1
		s = wp->screen;
@

