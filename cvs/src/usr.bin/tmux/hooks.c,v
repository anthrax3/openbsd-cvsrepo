head	1.9;
access;
symbols
	OPENBSD_6_2:1.9.0.6
	OPENBSD_6_2_BASE:1.9
	OPENBSD_6_1:1.9.0.4
	OPENBSD_6_1_BASE:1.9
	OPENBSD_6_0:1.4.0.4
	OPENBSD_6_0_BASE:1.4
	OPENBSD_5_9:1.4.0.2
	OPENBSD_5_9_BASE:1.4;
locks; strict;
comment	@ * @;


1.9
date	2016.10.16.19.36.37;	author nicm;	state Exp;
branches;
next	1.8;
commitid	UfrPlTlFgpvE2jpY;

1.8
date	2016.10.16.19.04.05;	author nicm;	state Exp;
branches;
next	1.7;
commitid	pxm6osuE99zELpkU;

1.7
date	2016.10.16.17.55.14;	author nicm;	state Exp;
branches;
next	1.6;
commitid	1xIYFpLYkPIXNEvU;

1.6
date	2016.10.13.22.48.51;	author nicm;	state Exp;
branches;
next	1.5;
commitid	1GCC1n59gejVg5Ih;

1.5
date	2016.10.10.21.29.23;	author nicm;	state Exp;
branches;
next	1.4;
commitid	z4Hr4PZF7Ev93uEJ;

1.4
date	2015.12.16.21.50.37;	author nicm;	state Exp;
branches;
next	1.3;
commitid	Bam1GajuDZzmKjyE;

1.3
date	2015.12.15.13.43.07;	author nicm;	state Exp;
branches;
next	1.2;
commitid	nxumQwtI4O73Gcjc;

1.2
date	2015.12.11.15.46.57;	author nicm;	state Exp;
branches;
next	1.1;
commitid	7gYcVEFDdWFs0Erw;

1.1
date	2015.12.08.01.10.31;	author nicm;	state Exp;
branches;
next	;
commitid	Q7y3PTVPjE0eQDqD;


desc
@@


1.9
log
@Provide a way for hooks to tag formats onto the commands they fire so
that the user can get at additional information - now used for the
"hook" format, more to come.
@
text
@/* $OpenBSD: hooks.c,v 1.8 2016/10/16 19:04:05 nicm Exp $ */

/*
 * Copyright (c) 2012 Thomas Adam <thomas@@xteddy.org>
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF MIND, USE, DATA OR PROFITS, WHETHER
 * IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING
 * OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */

#include <sys/types.h>

#include <stdlib.h>
#include <string.h>

#include "tmux.h"

struct hooks {
	RB_HEAD(hooks_tree, hook) tree;
	struct hooks	*parent;
};

static int	hooks_cmp(struct hook *, struct hook *);
RB_GENERATE_STATIC(hooks_tree, hook, entry, hooks_cmp);

static struct hook	*hooks_find1(struct hooks *, const char *);
static void		 hooks_free1(struct hooks *, struct hook *);

static int
hooks_cmp(struct hook *hook1, struct hook *hook2)
{
	return (strcmp(hook1->name, hook2->name));
}

struct hooks *
hooks_get(struct session *s)
{
	if (s != NULL)
		return (s->hooks);
	return (global_hooks);
}

struct hooks *
hooks_create(struct hooks *parent)
{
	struct hooks	*hooks;

	hooks = xcalloc(1, sizeof *hooks);
	RB_INIT(&hooks->tree);
	hooks->parent = parent;
	return (hooks);
}

static void
hooks_free1(struct hooks *hooks, struct hook *hook)
{
	RB_REMOVE(hooks_tree, &hooks->tree, hook);
	cmd_list_free(hook->cmdlist);
	free((char *)hook->name);
	free(hook);
}

void
hooks_free(struct hooks *hooks)
{
	struct hook	*hook, *hook1;

	RB_FOREACH_SAFE(hook, hooks_tree, &hooks->tree, hook1)
		hooks_free1(hooks, hook);
	free(hooks);
}

struct hook *
hooks_first(struct hooks *hooks)
{
	return (RB_MIN(hooks_tree, &hooks->tree));
}

struct hook *
hooks_next(struct hook *hook)
{
	return (RB_NEXT(hooks_tree, &hooks->tree, hook));
}

void
hooks_add(struct hooks *hooks, const char *name, struct cmd_list *cmdlist)
{
	struct hook	*hook;

	if ((hook = hooks_find1(hooks, name)) != NULL)
		hooks_free1(hooks, hook);

	hook = xcalloc(1, sizeof *hook);
	hook->name = xstrdup(name);
	hook->cmdlist = cmdlist;
	hook->cmdlist->references++;
	RB_INSERT(hooks_tree, &hooks->tree, hook);
}

void
hooks_remove(struct hooks *hooks, const char *name)
{
	struct hook	*hook;

	if ((hook = hooks_find1(hooks, name)) != NULL)
		hooks_free1(hooks, hook);
}

static struct hook *
hooks_find1(struct hooks *hooks, const char *name)
{
	struct hook	hook;

	hook.name = name;
	return (RB_FIND(hooks_tree, &hooks->tree, &hook));
}

struct hook *
hooks_find(struct hooks *hooks, const char *name)
{
	struct hook	 hook0, *hook;

	hook0.name = name;
	hook = RB_FIND(hooks_tree, &hooks->tree, &hook0);
	while (hook == NULL) {
		hooks = hooks->parent;
		if (hooks == NULL)
			break;
		hook = RB_FIND(hooks_tree, &hooks->tree, &hook0);
	}
	return (hook);
}

void
hooks_run(struct hooks *hooks, struct client *c, struct cmd_find_state *fs,
    const char *fmt, ...)
{
	struct hook		*hook;
	va_list			 ap;
	char			*name;
	struct cmdq_item	*new_item;

	va_start(ap, fmt);
	xvasprintf(&name, fmt, ap);
	va_end(ap);

	hook = hooks_find(hooks, name);
	if (hook == NULL) {
		free(name);
		return;
	}
	log_debug("running hook %s", name);

	new_item = cmdq_get_command(hook->cmdlist, fs, NULL, CMDQ_NOHOOKS);
	cmdq_format(new_item, "hook", "%s", name);
	cmdq_append(c, new_item);

	free(name);
}

void
hooks_insert(struct hooks *hooks, struct cmdq_item *item,
    struct cmd_find_state *fs, const char *fmt, ...)
{
	struct hook		*hook;
	va_list			 ap;
	char			*name;
	struct cmdq_item	*new_item;

	if (item->flags & CMDQ_NOHOOKS)
		return;

	va_start(ap, fmt);
	xvasprintf(&name, fmt, ap);
	va_end(ap);

	hook = hooks_find(hooks, name);
	if (hook == NULL) {
		free(name);
		return;
	}
	log_debug("running hook %s (parent %p)", name, item);

	new_item = cmdq_get_command(hook->cmdlist, fs, NULL, CMDQ_NOHOOKS);
	cmdq_format(new_item, "hook", "%s", name);
	if (item != NULL)
		cmdq_insert_after(item, new_item);
	else
		cmdq_append(NULL, new_item);

	free(name);
}
@


1.8
log
@Mass rename struct cmd_q to struct cmdq_item and related.
@
text
@d1 1
a1 1
/* $OpenBSD: hooks.c,v 1.7 2016/10/16 17:55:14 nicm Exp $ */
d149 1
a149 1
	struct cmdq_item	*new_item, *loop;
d163 2
a165 2
	for (loop = new_item; loop != NULL; loop = loop->next)
		loop->hook = xstrdup(name);
a166 2

	cmdq_append(c, new_item);
d176 1
a176 1
	struct cmdq_item	*new_item, *loop;
d193 1
a193 5

	for (loop = new_item; loop != NULL; loop = loop->next)
		loop->hook = xstrdup(name);
	free(name);

d198 2
@


1.7
log
@Rewrite command queue handling. Each client still has a command queue,
but there is also now a global command queue. Instead of command queues
being dispatched on demand from wherever the command happens to be
added, they are now all dispatched from the top level server
loop. Command queues may now also include callbacks as well as commands,
and items may be inserted after the current command as well as at the end.

This all makes command queues significantly more predictable and easier
to use, and avoids the complex multiple nested command queues used by
source-file, if-shell and friends.

A mass rename of struct cmdq to a better name (cmdq_item probably) is
coming.
@
text
@d1 1
a1 1
/* $OpenBSD: hooks.c,v 1.6 2016/10/13 22:48:51 nicm Exp $ */
d146 4
a149 4
	struct hook	*hook;
	va_list		 ap;
	char		*name;
	struct cmd_q	*new_cmdq, *loop;
d162 1
a162 1
	new_cmdq = cmdq_get_command(hook->cmdlist, fs, NULL, CMD_Q_NOHOOKS);
d164 1
a164 1
	for (loop = new_cmdq; loop != NULL; loop = loop->next)
d168 1
a168 1
	cmdq_append(c, new_cmdq);
d172 2
a173 2
hooks_insert(struct hooks *hooks, struct cmd_q *cmdq, struct cmd_find_state *fs,
    const char *fmt, ...)
d175 4
a178 4
	struct hook	*hook;
	va_list		 ap;
	char		*name;
	struct cmd_q	*new_cmdq, *loop;
d180 1
a180 1
	if (cmdq->flags & CMD_Q_NOHOOKS)
d192 1
a192 1
	log_debug("running hook %s (parent %p)", name, cmdq);
d194 1
a194 1
	new_cmdq = cmdq_get_command(hook->cmdlist, fs, NULL, CMD_Q_NOHOOKS);
d196 1
a196 1
	for (loop = new_cmdq; loop != NULL; loop = loop->next)
d200 2
a201 2
	if (cmdq != NULL)
		cmdq_insert_after(cmdq, new_cmdq);
d203 1
a203 1
		cmdq_append(NULL, new_cmdq);
@


1.6
log
@Trying to do hooks generically is way too complicated and unreliable and
confusing, particularly trying to automatically figure out what target
hooks should be using. So simplify it:

- drop before hooks entirely, they don't seem to be very useful;

- commands with special requirements now fire their own after hook (for
  example, if they change session or window, or if they have -t and -s
  and need to choose which one the hook uses as current target);

- commands with no special requirements can have the CMD_AFTERHOOK flag
  added and they will use the -t state.

At the moment new-session, new-window, split-window fire their own hook,
and display-message uses the flag. The remaining commands still need to
be looked at.
@
text
@d1 1
a1 1
/* $OpenBSD: hooks.c,v 1.5 2016/10/10 21:29:23 nicm Exp $ */
a35 1
static void		 hooks_emptyfn(struct cmd_q *);
d142 1
a142 15
static void
hooks_emptyfn(struct cmd_q *hooks_cmdq)
{
	struct cmd_q	*cmdq = hooks_cmdq->data;

	if (cmdq != NULL) {
		if (hooks_cmdq->client_exit >= 0)
			cmdq->client_exit = hooks_cmdq->client_exit;
		if (!cmdq_free(cmdq))
			cmdq_continue(cmdq);
	}
	cmdq_free(hooks_cmdq);
}

int
a146 1
	struct cmd_q	*hooks_cmdq;
d149 1
d158 1
a158 1
		return (-1);
a160 1
	free(name);
d162 1
a162 2
	hooks_cmdq = cmdq_new(c);
	hooks_cmdq->flags |= CMD_Q_NOHOOKS;
d164 3
a166 3
	if (fs != NULL)
		cmd_find_copy_state(&hooks_cmdq->current, fs);
	hooks_cmdq->parent = NULL;
d168 1
a168 3
	cmdq_run(hooks_cmdq, hook->cmdlist, NULL);
	cmdq_free(hooks_cmdq);
	return (0);
d171 2
a172 2
int
hooks_wait(struct hooks *hooks, struct cmd_q *cmdq, struct cmd_find_state *fs,
a175 1
	struct cmd_q	*hooks_cmdq;
d178 1
d181 1
a181 1
		return (-1);
d190 1
a190 1
		return (-1);
a192 1
	free(name);
d194 1
a194 2
	hooks_cmdq = cmdq_new(cmdq->client);
	hooks_cmdq->flags |= CMD_Q_NOHOOKS;
d196 3
a198 6
	if (fs != NULL)
		cmd_find_copy_state(&hooks_cmdq->current, fs);
	hooks_cmdq->parent = cmdq;

	hooks_cmdq->emptyfn = hooks_emptyfn;
	hooks_cmdq->data = cmdq;
d201 3
a203 3
		cmdq->references++;
	cmdq_run(hooks_cmdq, hook->cmdlist, NULL);
	return (0);
@


1.5
log
@Loads more static, except for cmd-*.c and window-*.c.
@
text
@d1 1
a1 1
/* $OpenBSD: hooks.c,v 1.4 2015/12/16 21:50:37 nicm Exp $ */
d198 3
@


1.4
log
@Add infrastructure to work out the best target given a pane or window
alone and use it to add pane_died and pane_exited hooks.
@
text
@d1 1
a1 1
/* $OpenBSD: hooks.c,v 1.3 2015/12/15 13:43:07 nicm Exp $ */
d32 1
a32 2
RB_PROTOTYPE(hooks_tree, hook, entry, hooks_cmp);
RB_GENERATE(hooks_tree, hook, entry, hooks_cmp);
@


1.3
log
@Some hooks API changes to fire a hook while waiting another cmdq and
infrastructure that will be needed soon.
@
text
@d1 1
a1 1
/* $OpenBSD: hooks.c,v 1.2 2015/12/11 15:46:57 nicm Exp $ */
d46 8
d159 2
a160 1
hooks_run(struct hooks *hooks, struct client *c, const char *fmt, ...)
d181 3
d192 2
a193 1
hooks_wait(struct hooks *hooks, struct cmd_q *cmdq, const char *fmt, ...)
d214 3
@


1.2
log
@We cannot do hooks_find and then hooks_remove because it might have come
from the parent (global) tree, instead make it remove by name like options.

While here, also tidy up a few bits of options and hooks handling (use
RB_FOREACH_SAFE, and a helper function for the free).
@
text
@d1 1
a1 1
/* $OpenBSD: hooks.c,v 1.1 2015/12/08 01:10:31 nicm Exp $ */
d37 1
d136 16
a151 2
void
hooks_run(struct hooks *hooks, const char *name, struct client *c)
d154 7
a160 1
	struct cmd_q	*cmdq;
d163 4
a166 2
	if (hook == NULL)
		return;
d168 30
d199 11
a209 3
	cmdq = cmdq_new(c);
	cmdq_run(cmdq, hook->cmdlist, NULL);
	cmdq_free(cmdq);
@


1.1
log
@Add hooks infrastructure, basic commands (set-hook, show-hooks) and a
couple of not very useful client hooks. This will eventually let
commands be run at various points and on notifications. Joint work with
Thomas Adam.
@
text
@d1 1
a1 1
/* $OpenBSD$ */
d35 2
a36 1
struct hook	*hooks_find1(struct hooks *, const char *);
d55 9
d70 1
a70 1
		hooks_remove(hooks, hook);
d92 1
a92 1
		hooks_remove(hooks, hook);
d102 1
a102 1
hooks_remove(struct hooks *hooks, struct hook *hook)
d104 4
a107 4
	RB_REMOVE(hooks_tree, &hooks->tree, hook);
	cmd_list_free(hook->cmdlist);
	free((char *) hook->name);
	free(hook);
d110 1
a110 1
struct hook *
@

