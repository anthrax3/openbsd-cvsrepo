head	1.54;
access;
symbols
	OPENBSD_6_1:1.48.0.4
	OPENBSD_6_1_BASE:1.48
	OPENBSD_6_0:1.36.0.2
	OPENBSD_6_0_BASE:1.36
	OPENBSD_5_9:1.35.0.2
	OPENBSD_5_9_BASE:1.35
	OPENBSD_5_8:1.24.0.4
	OPENBSD_5_8_BASE:1.24
	OPENBSD_5_7:1.22.0.2
	OPENBSD_5_7_BASE:1.22
	OPENBSD_5_6:1.16.0.4
	OPENBSD_5_6_BASE:1.16
	OPENBSD_5_5:1.15.0.4
	OPENBSD_5_5_BASE:1.15
	OPENBSD_5_4:1.9.0.2
	OPENBSD_5_4_BASE:1.9;
locks; strict;
comment	@ * @;


1.54
date	2017.04.22.10.22.39;	author nicm;	state Exp;
branches;
next	1.53;
commitid	RXMp6wwG5a5Y82bo;

1.53
date	2017.04.21.22.23.24;	author nicm;	state Exp;
branches;
next	1.52;
commitid	N4wUb6jGvG8wvogM;

1.52
date	2017.04.21.20.34.05;	author nicm;	state Exp;
branches;
next	1.51;
commitid	tRaNWQJGCnBzaEqo;

1.51
date	2017.04.21.20.26.34;	author nicm;	state Exp;
branches;
next	1.50;
commitid	utIGVdoSurUxfh14;

1.50
date	2017.04.21.18.18.17;	author nicm;	state Exp;
branches;
next	1.49;
commitid	3KK6QKdcQSP3N5qp;

1.49
date	2017.04.21.14.01.19;	author nicm;	state Exp;
branches;
next	1.48;
commitid	6dh4rgGOD5wckeD9;

1.48
date	2017.02.03.11.57.27;	author nicm;	state Exp;
branches;
next	1.47;
commitid	BLRh0qXo7OVTPhiT;

1.47
date	2017.01.05.09.07.15;	author nicm;	state Exp;
branches;
next	1.46;
commitid	al9tcSDvFKlm4Qpq;

1.46
date	2016.10.18.08.46.43;	author nicm;	state Exp;
branches;
next	1.45;
commitid	u6yWlpHFfUiScqCx;

1.45
date	2016.10.16.19.36.37;	author nicm;	state Exp;
branches;
next	1.44;
commitid	UfrPlTlFgpvE2jpY;

1.44
date	2016.10.16.19.04.05;	author nicm;	state Exp;
branches;
next	1.43;
commitid	pxm6osuE99zELpkU;

1.43
date	2016.10.16.17.55.14;	author nicm;	state Exp;
branches;
next	1.42;
commitid	1xIYFpLYkPIXNEvU;

1.42
date	2016.10.15.00.01.01;	author nicm;	state Exp;
branches;
next	1.41;
commitid	Y3LyKhemZ1e3lTtQ;

1.41
date	2016.10.14.18.41.53;	author nicm;	state Exp;
branches;
next	1.40;
commitid	H2ZMHx3pmW6ppdPc;

1.40
date	2016.10.13.22.48.51;	author nicm;	state Exp;
branches;
next	1.39;
commitid	1GCC1n59gejVg5Ih;

1.39
date	2016.10.13.10.01.49;	author nicm;	state Exp;
branches;
next	1.38;
commitid	AFoah05fh4b2e28V;

1.38
date	2016.10.11.13.21.59;	author nicm;	state Exp;
branches;
next	1.37;
commitid	80rgEIPcNpyBnf95;

1.37
date	2016.09.28.14.40.07;	author nicm;	state Exp;
branches;
next	1.36;
commitid	7T1ym5uQRUPhCpw8;

1.36
date	2016.04.29.14.05.24;	author nicm;	state Exp;
branches;
next	1.35;
commitid	wZaePCOma60t58oN;

1.35
date	2016.01.19.16.01.30;	author nicm;	state Exp;
branches;
next	1.34;
commitid	gdaGX7HuLjiMTGV0;

1.34
date	2016.01.19.15.59.12;	author nicm;	state Exp;
branches;
next	1.33;
commitid	P3qmSOx6KrDBsb0c;

1.33
date	2015.12.16.21.50.37;	author nicm;	state Exp;
branches;
next	1.32;
commitid	Bam1GajuDZzmKjyE;

1.32
date	2015.12.13.16.11.42;	author nicm;	state Exp;
branches;
next	1.31;
commitid	Tvw4fIE0U66uRTPL;

1.31
date	2015.12.13.14.32.38;	author nicm;	state Exp;
branches;
next	1.30;
commitid	uzMkp8Z4FE6WB6s6;

1.30
date	2015.11.27.15.06.43;	author nicm;	state Exp;
branches;
next	1.29;
commitid	UkIx5fVf8smc7ree;

1.29
date	2015.11.14.09.41.06;	author nicm;	state Exp;
branches;
next	1.28;
commitid	FQoND7M2BC89FZoU;

1.28
date	2015.11.12.11.10.50;	author nicm;	state Exp;
branches;
next	1.27;
commitid	zq4e90cLboyOw7qA;

1.27
date	2015.10.20.21.12.08;	author nicm;	state Exp;
branches;
next	1.26;
commitid	fVAT1gEydaesyRmS;

1.26
date	2015.09.16.22.41.00;	author nicm;	state Exp;
branches;
next	1.25;
commitid	Bz7KyDka7E30s5ev;

1.25
date	2015.09.16.22.24.54;	author nicm;	state Exp;
branches;
next	1.24;
commitid	GbMuGsUSIjrHMl0R;

1.24
date	2015.06.17.17.02.15;	author nicm;	state Exp;
branches;
next	1.23;
commitid	8GVmgu6XYagy45yp;

1.23
date	2015.04.19.21.34.21;	author nicm;	state Exp;
branches;
next	1.22;
commitid	wug6ctIOfhVMeWQp;

1.22
date	2015.02.12.09.56.19;	author nicm;	state Exp;
branches;
next	1.21;
commitid	5XWE28nhmFHgBPYf;

1.21
date	2015.02.05.10.26.29;	author nicm;	state Exp;
branches;
next	1.20;
commitid	OxivUTNX4WyBbEer;

1.20
date	2014.10.27.22.23.47;	author nicm;	state Exp;
branches;
next	1.19;
commitid	lLfuAlkV0hLlHdgD;

1.19
date	2014.10.21.22.06.46;	author nicm;	state Exp;
branches;
next	1.18;
commitid	bgdFaoHba92vsNwZ;

1.18
date	2014.10.20.23.57.13;	author nicm;	state Exp;
branches;
next	1.17;
commitid	PTykIJGtZncJPE4a;

1.17
date	2014.09.01.21.50.18;	author nicm;	state Exp;
branches;
next	1.16;
commitid	yvK8NJvd2XzXhKku;

1.16
date	2014.04.17.07.55.43;	author nicm;	state Exp;
branches;
next	1.15;

1.15
date	2014.01.09.13.46.12;	author nicm;	state Exp;
branches;
next	1.14;

1.14
date	2013.10.10.12.26.35;	author nicm;	state Exp;
branches;
next	1.13;

1.13
date	2013.10.10.12.12.54;	author nicm;	state Exp;
branches;
next	1.12;

1.12
date	2013.10.10.12.07.36;	author nicm;	state Exp;
branches;
next	1.11;

1.11
date	2013.10.10.12.04.38;	author nicm;	state Exp;
branches;
next	1.10;

1.10
date	2013.10.10.11.45.28;	author nicm;	state Exp;
branches;
next	1.9;

1.9
date	2013.06.23.12.41.54;	author nicm;	state Exp;
branches;
next	1.8;

1.8
date	2013.04.10.12.15.36;	author nicm;	state Exp;
branches;
next	1.7;

1.7
date	2013.03.26.10.54.48;	author nicm;	state Exp;
branches;
next	1.6;

1.6
date	2013.03.25.11.41.16;	author nicm;	state Exp;
branches;
next	1.5;

1.5
date	2013.03.25.11.36.08;	author nicm;	state Exp;
branches;
next	1.4;

1.4
date	2013.03.25.11.35.55;	author nicm;	state Exp;
branches;
next	1.3;

1.3
date	2013.03.25.10.06.13;	author nicm;	state Exp;
branches;
next	1.2;

1.2
date	2013.03.25.10.05.00;	author nicm;	state Exp;
branches;
next	1.1;

1.1
date	2013.03.24.09.54.10;	author nicm;	state Exp;
branches;
next	;


desc
@@


1.54
log
@Get rid of the extra layer of flags and cmd_prepare() and just store the
CMD_FIND_* flags in the cmd_entry and call it for the command. Commands
with special requirements call it themselves and update the target for
hooks to use.
@
text
@/* $OpenBSD: cmd-queue.c,v 1.53 2017/04/21 22:23:24 nicm Exp $ */

/*
 * Copyright (c) 2013 Nicholas Marriott <nicholas.marriott@@gmail.com>
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF MIND, USE, DATA OR PROFITS, WHETHER
 * IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING
 * OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */

#include <sys/types.h>

#include <ctype.h>
#include <stdlib.h>
#include <string.h>
#include <time.h>

#include "tmux.h"

/* Global command queue. */
static struct cmdq_list global_queue = TAILQ_HEAD_INITIALIZER(global_queue);

/* Get command queue name. */
static const char *
cmdq_name(struct client *c)
{
	static char	s[32];

	if (c == NULL)
		return ("<global>");
	xsnprintf(s, sizeof s, "<%p>", c);
	return (s);
}

/* Get command queue from client. */
static struct cmdq_list *
cmdq_get(struct client *c)
{
	if (c == NULL)
		return (&global_queue);
	return (&c->queue);
}

/* Append an item. */
void
cmdq_append(struct client *c, struct cmdq_item *item)
{
	struct cmdq_list	*queue = cmdq_get(c);
	struct cmdq_item	*next;

	do {
		next = item->next;
		item->next = NULL;

		if (c != NULL)
			c->references++;
		item->client = c;

		item->queue = queue;
		TAILQ_INSERT_TAIL(queue, item, entry);

		item = next;
	} while (item != NULL);
}

/* Insert an item. */
void
cmdq_insert_after(struct cmdq_item *after, struct cmdq_item *item)
{
	struct client		*c = after->client;
	struct cmdq_list	*queue = after->queue;
	struct cmdq_item	*next;

	do {
		next = item->next;
		item->next = NULL;

		if (c != NULL)
			c->references++;
		item->client = c;

		item->queue = queue;
		if (after->next != NULL)
			TAILQ_INSERT_AFTER(queue, after->next, item, entry);
		else
			TAILQ_INSERT_AFTER(queue, after, item, entry);
		after->next = item;

		item = next;
	} while (item != NULL);
}

/* Remove an item. */
static void
cmdq_remove(struct cmdq_item *item)
{
	if (item->shared != NULL && --item->shared->references == 0) {
		if (item->shared->formats != NULL)
			format_free(item->shared->formats);
		free(item->shared);
	}

	if (item->client != NULL)
		server_client_unref(item->client);

	if (item->type == CMDQ_COMMAND)
		cmd_list_free(item->cmdlist);

	TAILQ_REMOVE(item->queue, item, entry);

	free((void *)item->name);
	free(item);
}

/* Set command group. */
static u_int
cmdq_next_group(void)
{
	static u_int	group;

	return (++group);
}

/* Remove all subsequent items that match this item's group. */
static void
cmdq_remove_group(struct cmdq_item *item)
{
	struct cmdq_item	*this, *next;

	this = TAILQ_NEXT(item, entry);
	while (this != NULL) {
		next = TAILQ_NEXT(this, entry);
		if (this->group == item->group)
			cmdq_remove(this);
		this = next;
	}
}

/* Get a command for the command queue. */
struct cmdq_item *
cmdq_get_command(struct cmd_list *cmdlist, struct cmd_find_state *current,
    struct mouse_event *m, int flags)
{
	struct cmdq_item	*item, *first = NULL, *last = NULL;
	struct cmd		*cmd;
	u_int			 group = cmdq_next_group();
	char			*tmp;
	struct cmdq_shared	*shared;

	shared = xcalloc(1, sizeof *shared);
	if (current != NULL)
		cmd_find_copy_state(&shared->current, current);
	else
		cmd_find_clear_state(&shared->current, 0);
	if (m != NULL)
		memcpy(&shared->mouse, m, sizeof shared->mouse);

	TAILQ_FOREACH(cmd, &cmdlist->list, qentry) {
		xasprintf(&tmp, "command[%s]", cmd->entry->name);

		item = xcalloc(1, sizeof *item);
		item->name = tmp;
		item->type = CMDQ_COMMAND;

		item->group = group;
		item->flags = flags;

		item->shared = shared;
		item->cmdlist = cmdlist;
		item->cmd = cmd;

		shared->references++;
		cmdlist->references++;

		if (first == NULL)
			first = item;
		if (last != NULL)
			last->next = item;
		last = item;
	}
	return (first);
}

/* Fill in flag for a command. */
static enum cmd_retval
cmdq_find_flag(struct cmdq_item *item, struct cmd_find_state *fs,
    const struct cmd_entry_flag *flag)
{
	const char	*value;

	if (flag->flag == 0) {
		cmd_find_clear_state(fs, 0);
		return (CMD_RETURN_NORMAL);
	}

	value = args_get(item->cmd->args, flag->flag);
	if (cmd_find_target(fs, item, value, flag->type, flag->flags) != 0) {
		cmd_find_clear_state(fs, 0);
		return (CMD_RETURN_ERROR);
	}
	return (CMD_RETURN_NORMAL);
}

/* Fire command on command queue. */
static enum cmd_retval
cmdq_fire_command(struct cmdq_item *item)
{
	struct client		*c = item->client;
	struct cmd		*cmd = item->cmd;
	const struct cmd_entry	*entry = cmd->entry;
	enum cmd_retval		 retval;
	struct cmd_find_state	*fsp, fs;
	int			 flags;

	flags = !!(cmd->flags & CMD_CONTROL);
	cmdq_guard(item, "begin", flags);

	if (item->client == NULL)
		item->client = cmd_find_client(item, NULL, 1);
	retval = cmdq_find_flag(item, &item->source, &entry->source);
	if (retval == CMD_RETURN_ERROR)
		goto out;
	retval = cmdq_find_flag(item, &item->target, &entry->target);
	if (retval == CMD_RETURN_ERROR)
		goto out;

	retval = entry->exec(cmd, item);
	if (retval == CMD_RETURN_ERROR)
		goto out;

	if (entry->flags & CMD_AFTERHOOK) {
		if (cmd_find_valid_state(&item->target))
			fsp = &item->target;
		else if (cmd_find_valid_state(&item->shared->current))
			fsp = &item->shared->current;
		else if (cmd_find_from_client(&fs, item->client) == 0)
			fsp = &fs;
		else
			goto out;
		hooks_insert(fsp->s->hooks, item, fsp, "after-%s", entry->name);
	}

out:
	item->client = c;
	if (retval == CMD_RETURN_ERROR)
		cmdq_guard(item, "error", flags);
	else
		cmdq_guard(item, "end", flags);
	return (retval);
}

/* Get a callback for the command queue. */
struct cmdq_item *
cmdq_get_callback1(const char *name, cmdq_cb cb, void *data)
{
	struct cmdq_item	*item;
	char			*tmp;

	xasprintf(&tmp, "callback[%s]", name);

	item = xcalloc(1, sizeof *item);
	item->name = tmp;
	item->type = CMDQ_CALLBACK;

	item->group = 0;
	item->flags = 0;

	item->cb = cb;
	item->data = data;

	return (item);
}

/* Fire callback on callback queue. */
static enum cmd_retval
cmdq_fire_callback(struct cmdq_item *item)
{
	return (item->cb(item, item->data));
}

/* Add a format to command queue. */
void
cmdq_format(struct cmdq_item *item, const char *key, const char *fmt, ...)
{
	struct cmdq_shared	*shared = item->shared;
	va_list			 ap;
	char			*value;

	va_start(ap, fmt);
	xvasprintf(&value, fmt, ap);
	va_end(ap);

	if (shared->formats == NULL)
		shared->formats = format_create(NULL, FORMAT_NONE, 0);
	format_add(shared->formats, key, "%s", value);

	free(value);
}

/* Process next item on command queue. */
u_int
cmdq_next(struct client *c)
{
	struct cmdq_list	*queue = cmdq_get(c);
	const char		*name = cmdq_name(c);
	struct cmdq_item	*item;
	enum cmd_retval		 retval;
	u_int			 items = 0;
	static u_int		 number;

	if (TAILQ_EMPTY(queue)) {
		log_debug("%s %s: empty", __func__, name);
		return (0);
	}
	if (TAILQ_FIRST(queue)->flags & CMDQ_WAITING) {
		log_debug("%s %s: waiting", __func__, name);
		return (0);
	}

	log_debug("%s %s: enter", __func__, name);
	for (;;) {
		item = TAILQ_FIRST(queue);
		if (item == NULL)
			break;
		log_debug("%s %s: %s (%d), flags %x", __func__, name,
		    item->name, item->type, item->flags);

		/*
		 * Any item with the waiting flag set waits until an external
		 * event clears the flag (for example, a job - look at
		 * run-shell).
		 */
		if (item->flags & CMDQ_WAITING)
			goto waiting;

		/*
		 * Items are only fired once, once the fired flag is set, a
		 * waiting flag can only be cleared by an external event.
		 */
		if (~item->flags & CMDQ_FIRED) {
			item->time = time(NULL);
			item->number = ++number;

			switch (item->type) {
			case CMDQ_COMMAND:
				retval = cmdq_fire_command(item);

				/*
				 * If a command returns an error, remove any
				 * subsequent commands in the same group.
				 */
				if (retval == CMD_RETURN_ERROR)
					cmdq_remove_group(item);
				break;
			case CMDQ_CALLBACK:
				retval = cmdq_fire_callback(item);
				break;
			default:
				retval = CMD_RETURN_ERROR;
				break;
			}
			item->flags |= CMDQ_FIRED;

			if (retval == CMD_RETURN_WAIT) {
				item->flags |= CMDQ_WAITING;
				goto waiting;
			}
			items++;
		}
		cmdq_remove(item);
	}

	log_debug("%s %s: exit (empty)", __func__, name);
	return (items);

waiting:
	log_debug("%s %s: exit (wait)", __func__, name);
	return (items);
}

/* Print a guard line. */
void
cmdq_guard(struct cmdq_item *item, const char *guard, int flags)
{
	struct client	*c = item->client;

	if (c == NULL || !(c->flags & CLIENT_CONTROL))
		return;

	evbuffer_add_printf(c->stdout_data, "%%%s %ld %u %d\n", guard,
	    (long)item->time, item->number, flags);
	server_client_push_stdout(c);
}

/* Show message from command. */
void
cmdq_print(struct cmdq_item *item, const char *fmt, ...)
{
	struct client	*c = item->client;
	struct window	*w;
	va_list		 ap;
	char		*tmp, *msg;

	va_start(ap, fmt);

	if (c == NULL)
		/* nothing */;
	else if (c->session == NULL || (c->flags & CLIENT_CONTROL)) {
		if (~c->flags & CLIENT_UTF8) {
			xvasprintf(&tmp, fmt, ap);
			msg = utf8_sanitize(tmp);
			free(tmp);
			evbuffer_add(c->stdout_data, msg, strlen(msg));
			free(msg);
		} else
			evbuffer_add_vprintf(c->stdout_data, fmt, ap);
		evbuffer_add(c->stdout_data, "\n", 1);
		server_client_push_stdout(c);
	} else {
		w = c->session->curw->window;
		if (w->active->mode != &window_copy_mode) {
			window_pane_reset_mode(w->active);
			window_pane_set_mode(w->active, &window_copy_mode);
			window_copy_init_for_output(w->active);
		}
		window_copy_vadd(w->active, fmt, ap);
	}

	va_end(ap);
}

/* Show error from command. */
void
cmdq_error(struct cmdq_item *item, const char *fmt, ...)
{
	struct client	*c = item->client;
	struct cmd	*cmd = item->cmd;
	va_list		 ap;
	char		*msg;
	size_t		 msglen;
	char		*tmp;

	va_start(ap, fmt);
	msglen = xvasprintf(&msg, fmt, ap);
	va_end(ap);

	if (c == NULL)
		cfg_add_cause("%s:%u: %s", cmd->file, cmd->line, msg);
	else if (c->session == NULL || (c->flags & CLIENT_CONTROL)) {
		if (~c->flags & CLIENT_UTF8) {
			tmp = msg;
			msg = utf8_sanitize(tmp);
			free(tmp);
			msglen = strlen(msg);
		}
		evbuffer_add(c->stderr_data, msg, msglen);
		evbuffer_add(c->stderr_data, "\n", 1);
		server_client_push_stderr(c);
		c->retval = 1;
	} else {
		*msg = toupper((u_char) *msg);
		status_message_set(c, "%s", msg);
	}

	free(msg);
}
@


1.53
log
@Log error properly when no current state, and some other minor tweaks.
@
text
@d1 1
a1 1
/* $OpenBSD: cmd-queue.c,v 1.52 2017/04/21 20:34:05 nicm Exp $ */
d192 20
d218 1
a219 1
	const char		*name;
d228 5
a232 3

	if (cmd_prepare_state(cmd, item) != 0) {
		retval = CMD_RETURN_ERROR;
a233 1
	}
d235 1
a235 1
	retval = cmd->entry->exec(cmd, item);
d239 3
a241 4
	if (cmd->entry->flags & CMD_AFTERHOOK) {
		name = cmd->entry->name;
		if (cmd_find_valid_state(&item->state.tflag))
			fsp = &item->state.tflag;
d248 1
a248 1
		hooks_insert(fsp->s->hooks, item, fsp, "after-%s", name);
@


1.52
log
@Clear shared state if not filling it in.
@
text
@d1 1
a1 1
/* $OpenBSD: cmd-queue.c,v 1.51 2017/04/21 20:26:34 nicm Exp $ */
d206 3
a212 3

	if (item->client == NULL)
		item->client = cmd_find_client(item, NULL, 1);
@


1.51
log
@Make the cmd_find_* functions more obvious when looking for a client,
rather than having it inside other functions. Should be no change to the
way targets are resolved just yet.
@
text
@d1 1
a1 1
/* $OpenBSD: cmd-queue.c,v 1.50 2017/04/21 18:18:17 nicm Exp $ */
d161 2
d210 1
@


1.50
log
@Style nits and an unused struct.
@
text
@d1 1
a1 1
/* $OpenBSD: cmd-queue.c,v 1.49 2017/04/21 14:01:19 nicm Exp $ */
d219 3
a221 3
		else {
			if (cmd_find_current(&fs, item, CMD_FIND_QUIET) != 0)
				goto out;
d223 2
a224 1
		}
@


1.49
log
@Store state shared between multiple commands in the queue in a shared
structure.
@
text
@d1 1
a1 1
/* $OpenBSD: cmd-queue.c,v 1.48 2017/02/03 11:57:27 nicm Exp $ */
d209 1
a209 1
		item->client = cmd_find_client(item, NULL, CMD_FIND_QUIET);
d328 1
a328 2
			switch (item->type)
			{
@


1.48
log
@Add a window or pane id "tag" to each format tree and use it to separate
jobs, this means that if the same job is used for different windows or
panes (for example in pane-border-format), it will be run separately for
each pane.
@
text
@d1 1
a1 1
/* $OpenBSD: cmd-queue.c,v 1.47 2017/01/05 09:07:15 nicm Exp $ */
d105 5
a109 2
	if (item->formats != NULL)
		format_free(item->formats);
d156 7
d174 1
d178 1
a178 4
		if (current != NULL)
			cmd_find_copy_state(&item->current, current);
		if (m != NULL)
			memcpy(&item->mouse, m, sizeof item->mouse);
d269 1
a270 1
	struct cmdq_item	*loop;
d277 3
a279 5
	for (loop = item; loop != NULL; loop = item->next) {
		if (loop->formats == NULL)
			loop->formats = format_create(NULL, FORMAT_NONE, 0);
		format_add(loop->formats, key, "%s", value);
	}
@


1.47
log
@Highlight all occurrences of search string after searching in copy mode.
@
text
@d1 1
a1 1
/* $OpenBSD: cmd-queue.c,v 1.46 2016/10/18 08:46:43 nicm Exp $ */
d271 1
a271 1
			loop->formats = format_create(NULL, 0);
@


1.46
log
@Give each item on queue a name for better logging.
@
text
@d1 1
a1 1
/* $OpenBSD: cmd-queue.c,v 1.45 2016/10/16 19:36:37 nicm Exp $ */
a276 1

@


1.45
log
@Provide a way for hooks to tag formats onto the commands they fire so
that the user can get at additional information - now used for the
"hook" format, more to come.
@
text
@d1 1
a1 1
/* $OpenBSD: cmd-queue.c,v 1.44 2016/10/16 19:04:05 nicm Exp $ */
d115 2
d152 1
d155 2
d158 1
d160 1
d230 1
a230 1
cmdq_get_callback(cmdq_cb cb, void *data)
d233 3
d238 1
d240 1
d304 2
a305 2
		log_debug("%s %s: type %d, flags %x", __func__, name,
		    item->type, item->flags);
@


1.44
log
@Mass rename struct cmd_q to struct cmdq_item and related.
@
text
@d1 1
a1 1
/* $OpenBSD: cmd-queue.c,v 1.43 2016/10/16 17:55:14 nicm Exp $ */
d105 2
a106 1
	free((void *)item->hook);
d244 22
@


1.43
log
@Rewrite command queue handling. Each client still has a command queue,
but there is also now a global command queue. Instead of command queues
being dispatched on demand from wherever the command happens to be
added, they are now all dispatched from the top level server
loop. Command queues may now also include callbacks as well as commands,
and items may be inserted after the current command as well as at the end.

This all makes command queues significantly more predictable and easier
to use, and avoids the complex multiple nested command queues used by
source-file, if-shell and friends.

A mass rename of struct cmdq to a better name (cmdq_item probably) is
coming.
@
text
@d1 1
a1 1
/* $OpenBSD: cmd-queue.c,v 1.42 2016/10/15 00:01:01 nicm Exp $ */
d29 1
a29 1
static struct cmd_q_list global_queue = TAILQ_HEAD_INITIALIZER(global_queue);
d44 1
a44 1
static struct cmd_q_list *
d54 1
a54 1
cmdq_append(struct client *c, struct cmd_q *cmdq)
d56 2
a57 2
	struct cmd_q_list	*queue = cmdq_get(c);
	struct cmd_q		*next;
d60 2
a61 2
		next = cmdq->next;
		cmdq->next = NULL;
d65 1
a65 1
		cmdq->client = c;
d67 2
a68 2
		cmdq->queue = queue;
		TAILQ_INSERT_TAIL(queue, cmdq, entry);
d70 2
a71 2
		cmdq = next;
	} while (cmdq != NULL);
d76 1
a76 1
cmdq_insert_after(struct cmd_q *after, struct cmd_q *cmdq)
d79 2
a80 2
	struct cmd_q_list	*queue = after->queue;
	struct cmd_q		*next;
d83 2
a84 2
		next = cmdq->next;
		cmdq->next = NULL;
d88 1
a88 1
		cmdq->client = c;
d90 1
a90 1
		cmdq->queue = queue;
d92 1
a92 1
			TAILQ_INSERT_AFTER(queue, after->next, cmdq, entry);
d94 2
a95 2
			TAILQ_INSERT_AFTER(queue, after, cmdq, entry);
		after->next = cmdq;
d97 2
a98 2
		cmdq = next;
	} while (cmdq != NULL);
d103 1
a103 1
cmdq_remove(struct cmd_q *cmdq)
d105 1
a105 1
	free((void *)cmdq->hook);
d107 2
a108 2
	if (cmdq->client != NULL)
		server_client_unref(cmdq->client);
d110 2
a111 2
	if (cmdq->type == CMD_Q_COMMAND)
		cmd_list_free(cmdq->cmdlist);
d113 2
a114 2
	TAILQ_REMOVE(cmdq->queue, cmdq, entry);
	free(cmdq);
d128 1
a128 1
cmdq_remove_group(struct cmd_q *cmdq)
d130 1
a130 1
	struct cmd_q	*this, *next;
d132 1
a132 1
	this = TAILQ_NEXT(cmdq, entry);
d135 1
a135 1
		if (this->group == cmdq->group)
d142 1
a142 1
struct cmd_q *
d146 3
a148 3
	struct cmd_q	*cmdq, *first = NULL, *last = NULL;
	struct cmd	*cmd;
	u_int		 group = cmdq_next_group();
d151 4
a154 4
		cmdq = xcalloc(1, sizeof *cmdq);
		cmdq->type = CMD_Q_COMMAND;
		cmdq->group = group;
		cmdq->flags = flags;
d156 2
a157 2
		cmdq->cmdlist = cmdlist;
		cmdq->cmd = cmd;
d160 1
a160 1
			cmd_find_copy_state(&cmdq->current, current);
d162 1
a162 1
			memcpy(&cmdq->mouse, m, sizeof cmdq->mouse);
d166 1
a166 1
			first = cmdq;
d168 2
a169 2
			last->next = cmdq;
		last = cmdq;
d176 1
a176 1
cmdq_fire_command(struct cmd_q *cmdq)
d178 2
a179 2
	struct client		*c = cmdq->client;
	struct cmd		*cmd = cmdq->cmd;
d186 1
a186 1
	cmdq_guard(cmdq, "begin", flags);
d188 1
a188 1
	if (cmd_prepare_state(cmd, cmdq) != 0) {
d192 2
a193 2
	if (cmdq->client == NULL)
		cmdq->client = cmd_find_client(cmdq, NULL, CMD_FIND_QUIET);
d195 1
a195 1
	retval = cmd->entry->exec(cmd, cmdq);
d201 2
a202 2
		if (cmd_find_valid_state(&cmdq->state.tflag))
			fsp = &cmdq->state.tflag;
d204 1
a204 1
			if (cmd_find_current(&fs, cmdq, CMD_FIND_QUIET) != 0)
d208 1
a208 1
		hooks_insert(fsp->s->hooks, cmdq, fsp, "after-%s", name);
d212 1
a212 1
	cmdq->client = c;
d214 1
a214 1
		cmdq_guard(cmdq, "error", flags);
d216 1
a216 1
		cmdq_guard(cmdq, "end", flags);
d221 2
a222 2
struct cmd_q *
cmdq_get_callback(cmd_q_cb cb, void *data)
d224 1
a224 1
	struct cmd_q	*cmdq;
d226 4
a229 4
	cmdq = xcalloc(1, sizeof *cmdq);
	cmdq->type = CMD_Q_CALLBACK;
	cmdq->group = 0;
	cmdq->flags = 0;
d231 2
a232 2
	cmdq->cb = cb;
	cmdq->data = data;
d234 1
a234 1
	return (cmdq);
d239 1
a239 1
cmdq_fire_callback(struct cmd_q *cmdq)
d241 1
a241 1
	return (cmdq->cb(cmdq, cmdq->data));
d248 1
a248 1
	struct cmd_q_list	*queue = cmdq_get(c);
d250 1
a250 1
	struct cmd_q		*cmdq;
d259 1
a259 1
	if (TAILQ_FIRST(queue)->flags & CMD_Q_WAITING) {
d266 2
a267 2
		cmdq = TAILQ_FIRST(queue);
		if (cmdq == NULL)
d270 1
a270 1
		    cmdq->type, cmdq->flags);
d277 1
a277 1
		if (cmdq->flags & CMD_Q_WAITING)
d284 3
a286 3
		if (~cmdq->flags & CMD_Q_FIRED) {
			cmdq->time = time(NULL);
			cmdq->number = ++number;
d288 1
a288 1
			switch (cmdq->type)
d290 2
a291 2
			case CMD_Q_COMMAND:
				retval = cmdq_fire_command(cmdq);
d298 1
a298 1
					cmdq_remove_group(cmdq);
d300 2
a301 2
			case CMD_Q_CALLBACK:
				retval = cmdq_fire_callback(cmdq);
d307 1
a307 1
			cmdq->flags |= CMD_Q_FIRED;
d310 1
a310 1
				cmdq->flags |= CMD_Q_WAITING;
d315 1
a315 1
		cmdq_remove(cmdq);
d328 1
a328 1
cmdq_guard(struct cmd_q *cmdq, const char *guard, int flags)
d330 1
a330 1
	struct client	*c = cmdq->client;
d336 1
a336 1
	    (long)cmdq->time, cmdq->number, flags);
d342 1
a342 1
cmdq_print(struct cmd_q *cmdq, const char *fmt, ...)
d344 1
a344 1
	struct client	*c = cmdq->client;
d379 1
a379 1
cmdq_error(struct cmd_q *cmdq, const char *fmt, ...)
d381 2
a382 2
	struct client	*c = cmdq->client;
	struct cmd	*cmd = cmdq->cmd;
@


1.42
log
@Drain notifys once at the end of the server loop instead of doing it
from the end of every command queue (which could be nested).
@
text
@d1 1
a1 1
/* $OpenBSD: cmd-queue.c,v 1.41 2016/10/14 18:41:53 nicm Exp $ */
d28 2
a29 2
static enum cmd_retval	cmdq_continue_one(struct cmd_q *);
static void		cmdq_flush(struct cmd_q *);
d31 111
a141 1
/* Create new command queue. */
d143 80
a222 1
cmdq_new(struct client *c)
d227 2
a228 1
	cmdq->references = 1;
d231 2
a232 2
	cmdq->client = c;
	cmdq->client_exit = -1;
d234 2
a235 3
	TAILQ_INIT(&cmdq->queue);
	cmdq->item = NULL;
	cmdq->cmd = NULL;
d237 6
a242 2
	cmd_find_clear_state(&cmdq->current, NULL, 0);
	cmdq->parent = NULL;
d244 10
a253 2
	return (cmdq);
}
d255 2
a256 9
/* Free command queue */
int
cmdq_free(struct cmd_q *cmdq)
{
	log_debug("cmdq %p free: %u references", cmdq, cmdq->references);

	if (--cmdq->references != 0) {
		if (cmdq->flags & CMD_Q_DEAD)
			return (1);
d259 61
d321 17
a337 3
	cmdq_flush(cmdq);
	free(cmdq);
	return (1);
a411 172

/* Print a guard line. */
void
cmdq_guard(struct cmd_q *cmdq, const char *guard, int flags)
{
	struct client	*c = cmdq->client;

	if (c == NULL || !(c->flags & CLIENT_CONTROL))
		return;

	evbuffer_add_printf(c->stdout_data, "%%%s %ld %u %d\n", guard,
	    (long) cmdq->time, cmdq->number, flags);
	server_client_push_stdout(c);
}

/* Add command list to queue and begin processing if needed. */
void
cmdq_run(struct cmd_q *cmdq, struct cmd_list *cmdlist, struct mouse_event *m)
{
	cmdq_append(cmdq, cmdlist, m);

	if (cmdq->item == NULL) {
		cmdq->cmd = NULL;
		cmdq_continue(cmdq);
	}
}

/* Add command list to queue. */
void
cmdq_append(struct cmd_q *cmdq, struct cmd_list *cmdlist, struct mouse_event *m)
{
	struct cmd_q_item	*item;

	item = xcalloc(1, sizeof *item);
	item->cmdlist = cmdlist;
	TAILQ_INSERT_TAIL(&cmdq->queue, item, qentry);
	cmdlist->references++;

	if (m != NULL)
		memcpy(&item->mouse, m, sizeof item->mouse);
	else
		item->mouse.valid = 0;
}

/* Process one command. */
static enum cmd_retval
cmdq_continue_one(struct cmd_q *cmdq)
{
	struct cmd_list		*cmdlist = cmdq->item->cmdlist;
	struct cmd		*cmd = cmdq->cmd;
	enum cmd_retval		 retval;
	char			*tmp;
	int			 flags = !!(cmd->flags & CMD_CONTROL);
	const char		*name;
	struct cmd_find_state	*fsp, fs;

	cmdlist->references++;

	tmp = cmd_print(cmd);
	log_debug("cmdq %p: %s", cmdq, tmp);
	free(tmp);

	cmdq->time = time(NULL);
	cmdq->number++;

	cmdq_guard(cmdq, "begin", flags);

	if (cmd_prepare_state(cmd, cmdq, cmdq->parent) != 0)
		goto error;

	retval = cmd->entry->exec(cmd, cmdq);
	if (retval == CMD_RETURN_ERROR)
		goto error;

	if (~cmd->entry->flags & CMD_AFTERHOOK)
		goto end;

	if (cmd_find_valid_state(&cmdq->state.tflag))
		fsp = &cmdq->state.tflag;
	else {
		if (cmd_find_current(&fs, cmdq, CMD_FIND_QUIET) != 0)
			goto end;
		fsp = &fs;
	}
	name = cmd->entry->name;
	if (hooks_wait(fsp->s->hooks, cmdq, fsp, "after-%s", name) == 0)
		retval = CMD_RETURN_WAIT;

end:
	cmdq_guard(cmdq, "end", flags);
	cmd_list_free(cmdlist);
	return (retval);

error:
	cmdq_guard(cmdq, "error", flags);
	cmd_list_free(cmdlist);
	return (CMD_RETURN_ERROR);
}

/* Continue processing command queue. Returns 1 if finishes empty. */
int
cmdq_continue(struct cmd_q *cmdq)
{
	struct client		*c = cmdq->client;
	struct cmd_q_item	*next;
	enum cmd_retval		 retval;
	int			 empty;

	log_debug("continuing cmdq %p: flags %#x (%p)", cmdq, cmdq->flags, c);
	cmdq->references++;

	empty = TAILQ_EMPTY(&cmdq->queue);
	if (empty)
		goto empty;

	if (cmdq->item == NULL) {
		cmdq->item = TAILQ_FIRST(&cmdq->queue);
		cmdq->cmd = TAILQ_FIRST(&cmdq->item->cmdlist->list);
	} else
		cmdq->cmd = TAILQ_NEXT(cmdq->cmd, qentry);

	do {
		while (cmdq->cmd != NULL) {
			retval = cmdq_continue_one(cmdq);
			if (retval == CMD_RETURN_ERROR)
				break;
			if (retval == CMD_RETURN_WAIT)
				goto out;
			if (retval == CMD_RETURN_STOP) {
				cmdq_flush(cmdq);
				goto empty;
			}
			cmdq->cmd = TAILQ_NEXT(cmdq->cmd, qentry);
		}
		next = TAILQ_NEXT(cmdq->item, qentry);

		TAILQ_REMOVE(&cmdq->queue, cmdq->item, qentry);
		cmd_list_free(cmdq->item->cmdlist);
		free(cmdq->item);

		cmdq->item = next;
		if (cmdq->item != NULL)
			cmdq->cmd = TAILQ_FIRST(&cmdq->item->cmdlist->list);
	} while (cmdq->item != NULL);

empty:
	log_debug("cmdq %p empty", cmdq);
	if (cmdq->client_exit > 0)
		cmdq->client->flags |= CLIENT_EXIT;
	if (cmdq->emptyfn != NULL)
		cmdq->emptyfn(cmdq);
	empty = 1;

out:
	cmdq_free(cmdq);
	return (empty);
}

/* Flush command queue. */
static void
cmdq_flush(struct cmd_q *cmdq)
{
	struct cmd_q_item	*item, *item1;

	TAILQ_FOREACH_SAFE(item, &cmdq->queue, qentry, item1) {
		TAILQ_REMOVE(&cmdq->queue, item, qentry);
		cmd_list_free(item->cmdlist);
		free(item);
	}
	cmdq->item = NULL;
}

@


1.41
log
@source-file and some other commands can recurse back into cmdq_continue,
which could potentially free the currently running command, so we need
to take a reference to it in cmdq_continue_one.

Fixes problem reported by Theo Buehler.
@
text
@d1 1
a1 1
/* $OpenBSD: cmd-queue.c,v 1.40 2016/10/13 22:48:51 nicm Exp $ */
d251 1
a252 3
	notify_disable();

	log_debug("continuing cmdq %p: flags %#x (%p)", cmdq, cmdq->flags, c);
a296 1
	notify_enable();
a297 1

@


1.40
log
@Trying to do hooks generically is way too complicated and unreliable and
confusing, particularly trying to automatically figure out what target
hooks should be using. So simplify it:

- drop before hooks entirely, they don't seem to be very useful;

- commands with special requirements now fire their own after hook (for
  example, if they change session or window, or if they have -t and -s
  and need to choose which one the hook uses as current target);

- commands with no special requirements can have the CMD_AFTERHOOK flag
  added and they will use the -t state.

At the moment new-session, new-window, split-window fire their own hook,
and display-message uses the flag. The remaining commands still need to
be looked at.
@
text
@d1 1
a1 1
/* $OpenBSD: cmd-queue.c,v 1.39 2016/10/13 10:01:49 nicm Exp $ */
d58 2
d191 1
d199 2
d233 1
d238 1
d254 1
a254 2
	log_debug("continuing cmdq %p: flags %#x, client %p", cmdq, cmdq->flags,
	    c);
d291 1
@


1.39
log
@Some improvements and bug fixes for hooks:

- Prepare the state again before the "after" hooks are run, because the
  command may have killed or moved windows.

- Use the hooks list from the newly prepared target, not the old hooks
  list (only matters for new-session really).

- Correctly detect an invalid current state and ignore it in
  cmd_find_target ("killw; swapw").

- Change neww, new, killp, killw, splitw, swapp, swapw to update the
  current state (used if no explicit target is given) to something more
  useful after they have finished. For example, neww changes it to the
  newly created window.

Hooks are still relatively new and primitive so there are likely to be
more changes to come.

Parts based on bug reports from Uwe Werler and Iblis Lin.
@
text
@d1 1
a1 1
/* $OpenBSD: cmd-queue.c,v 1.38 2016/10/11 13:21:59 nicm Exp $ */
a184 18
/* Find hooks list. */
static struct hooks *
cmdq_get_hooks(struct cmd_q *cmdq)
{
	struct session	*s;

	s = NULL;
	if (cmdq->state.tflag.s != NULL)
		s = cmdq->state.tflag.s;
	else if (cmdq->state.sflag.s != NULL)
		s = cmdq->state.sflag.s;
	else if (cmdq->state.c != NULL)
		s = cmdq->state.c->session;
	if (s != NULL)
		return (s->hooks);
	return (global_hooks);
}

d189 6
a194 6
	struct cmd	*cmd = cmdq->cmd;
	const char	*name = cmd->entry->name;
	struct hooks	*hooks;
	enum cmd_retval	 retval;
	char		*tmp;
	int		 flags = !!(cmd->flags & CMD_CONTROL);
d203 1
a203 2
	if (~cmdq->flags & CMD_Q_REENTRY)
		cmdq_guard(cmdq, "begin", flags);
a207 14
	if (~cmdq->flags & CMD_Q_NOHOOKS) {
		hooks = cmdq_get_hooks(cmdq);
		if (~cmdq->flags & CMD_Q_REENTRY) {
			cmdq->flags |= CMD_Q_REENTRY;
			if (hooks_wait(hooks, cmdq, NULL,
			    "before-%s", name) == 0)
				return (CMD_RETURN_WAIT);
			if (cmd_prepare_state(cmd, cmdq, cmdq->parent) != 0)
				goto error;
		}
	} else
		hooks = NULL;
	cmdq->flags &= ~CMD_Q_REENTRY;

d212 9
a220 6
	if (hooks != NULL) {
		if (cmd_prepare_state(cmd, cmdq, cmdq->parent) != 0)
			goto error;
		hooks = cmdq_get_hooks(cmdq);
		if (hooks_wait(hooks, cmdq, NULL, "after-%s", name) == 0)
			retval = CMD_RETURN_WAIT;
d222 5
a227 1

a231 1
	cmdq->flags &= ~CMD_Q_REENTRY;
a246 2
	cmd_find_clear_state(&cmdq->current, NULL, 0);

d254 5
a258 12
	/*
	 * If the command isn't in the middle of running hooks (due to
	 * CMD_RETURN_WAIT), move onto the next command; otherwise, leave the
	 * state of the queue as it is.
	 */
	if (~cmdq->flags & CMD_Q_REENTRY) {
		if (cmdq->item == NULL) {
			cmdq->item = TAILQ_FIRST(&cmdq->queue);
			cmdq->cmd = TAILQ_FIRST(&cmdq->item->cmdlist->list);
		} else
			cmdq->cmd = TAILQ_NEXT(cmdq->cmd, qentry);
	}
@


1.38
log
@Add static in window-*.c and move some internal functions out of tmux.h.
@
text
@d1 1
a1 1
/* $OpenBSD: cmd-queue.c,v 1.37 2016/09/28 14:40:07 nicm Exp $ */
d185 18
a208 1
	struct session	*s;
d228 1
a228 12
		s = NULL;
		if (cmdq->state.tflag.s != NULL)
			s = cmdq->state.tflag.s;
		else if (cmdq->state.sflag.s != NULL)
			s = cmdq->state.sflag.s;
		else if (cmdq->state.c != NULL)
			s = cmdq->state.c->session;
		if (s != NULL)
			hooks = s->hooks;
		else
			hooks = global_hooks;

d245 7
a251 3
	if (hooks != NULL && hooks_wait(hooks, cmdq, NULL,
	    "after-%s", name) == 0)
		retval = CMD_RETURN_WAIT;
d273 2
@


1.37
log
@Couple of vasprintf -> xvasprintf.
@
text
@d1 1
a1 1
/* $OpenBSD: cmd-queue.c,v 1.36 2016/04/29 14:05:24 nicm Exp $ */
d29 1
d323 1
a323 1
void
@


1.36
log
@Final parts of command hooks, add before- and after- hooks to each command.
@
text
@d1 1
a1 1
/* $OpenBSD: cmd-queue.c,v 1.35 2016/01/19 16:01:30 nicm Exp $ */
d83 1
a83 1
			vasprintf(&tmp, fmt, ap);
@


1.35
log
@Split out getting the current state from the target search so it can be
replaced if we already know the current.
@
text
@d1 1
a1 1
/* $OpenBSD: cmd-queue.c,v 1.34 2016/01/19 15:59:12 nicm Exp $ */
d189 3
d203 2
a204 1
	cmdq_guard(cmdq, "begin", flags);
d206 1
a206 1
	if (cmd_prepare_state(cmd, cmdq, NULL) != 0)
d208 26
d238 3
d242 1
d247 1
d270 12
a281 5
	if (cmdq->item == NULL) {
		cmdq->item = TAILQ_FIRST(&cmdq->queue);
		cmdq->cmd = TAILQ_FIRST(&cmdq->item->cmdlist->list);
	} else
		cmdq->cmd = TAILQ_NEXT(cmdq->cmd, qentry);
@


1.34
log
@I no longer use my SourceForge address so replace it.
@
text
@d1 1
a1 1
/* $OpenBSD: cmd-queue.c,v 1.33 2015/12/16 21:50:37 nicm Exp $ */
d202 1
a202 1
	if (cmd_prepare_state(cmd, cmdq) != 0)
@


1.33
log
@Add infrastructure to work out the best target given a pane or window
alone and use it to add pane_died and pane_exited hooks.
@
text
@d1 1
a1 1
/* $OpenBSD: cmd-queue.c,v 1.32 2015/12/13 16:11:42 nicm Exp $ */
d4 1
a4 1
 * Copyright (c) 2013 Nicholas Marriott <nicm@@users.sourceforge.net>
@


1.32
log
@If command returns error, report it.
@
text
@d1 1
a1 1
/* $OpenBSD: cmd-queue.c,v 1.31 2015/12/13 14:32:38 nicm Exp $ */
d47 3
d292 1
@


1.31
log
@Instead of every command resolving the target (-t or -s) itself, prepare
the state (client, session, winlink, pane) for it it before entering the
command. Each command provides some flags that tell the prepare step
what it is expecting.

This is a requirement for having hooks on commands (for example, if you
hook "select-window -t1:2", the hook command should to operate on window
1:2 not whatever it thinks is the current window), and should allow some
other target improvements.

The old cmd_find_* functions remain for the moment but that layer will
be dropped later.

Joint work with Thomas Adam.
@
text
@d1 1
a1 1
/* $OpenBSD: cmd-queue.c,v 1.30 2015/11/27 15:06:43 nicm Exp $ */
d202 2
@


1.30
log
@Do not set a limit on the length of commands when printing them.
@
text
@d1 1
a1 1
/* $OpenBSD: cmd-queue.c,v 1.29 2015/11/14 09:41:06 nicm Exp $ */
d28 1
a28 1
enum cmd_retval	cmdq_continue_one(struct cmd_q *);
d182 1
a182 1
enum cmd_retval
d187 1
a187 1
	char		*s;
d190 3
a192 3
	s = cmd_print(cmd);
	log_debug("cmdq %p: %s", cmdq, s);
	free(s);
d199 2
d203 1
a203 4
	if (retval == CMD_RETURN_ERROR)
		cmdq_guard(cmdq, "error", flags);
	else
		cmdq_guard(cmdq, "end", flags);
d205 4
d215 1
a215 1
	struct client           *c = cmdq->client;
@


1.29
log
@Push stdout and stderr to clients more aggressively, and add an event to
continue if the send fails.
@
text
@d1 1
a1 1
/* $OpenBSD: cmd-queue.c,v 1.28 2015/11/12 11:10:50 nicm Exp $ */
d187 1
a187 1
	char		 tmp[1024];
d190 3
a192 2
	cmd_print(cmd, tmp, sizeof tmp);
	log_debug("cmdq %p: %s", cmdq, tmp);
@


1.28
log
@If we know the terminal outside tmux is not UTF-8, replace UTF-8 in
error messages and whatnot with underscores the same as we do when we
draw UTF-8 characters as part of the screen.
@
text
@d1 1
a1 1
/* $OpenBSD: cmd-queue.c,v 1.27 2015/10/20 21:12:08 nicm Exp $ */
d88 1
a88 1
		server_push_stdout(c);
d128 1
a128 1
		server_push_stderr(c);
d149 1
a149 1
	server_push_stdout(c);
@


1.27
log
@Use client pointer not file descriptor in logging.
@
text
@d1 1
a1 1
/* $OpenBSD: cmd-queue.c,v 1.26 2015/09/16 22:41:00 nicm Exp $ */
d72 1
d79 8
a86 2
		evbuffer_add_vprintf(c->stdout_data, fmt, ap);

d111 1
d120 6
a127 1

@


1.26
log
@Log when cmdq_continue is called.
@
text
@d1 1
a1 1
/* $OpenBSD: cmd-queue.c,v 1.25 2015/09/16 22:24:54 nicm Exp $ */
d206 2
a207 2
	log_debug("continuing cmdq %p: flags=%#x, client=%d", cmdq, cmdq->flags,
	    c != NULL ? c->ibuf.fd : -1);
@


1.25
log
@Rename cmd_q dead flag to a general flags bitmask (will be more flags later).
@
text
@d1 1
a1 1
/* $OpenBSD: cmd-queue.c,v 1.24 2015/06/17 17:02:15 nicm Exp $ */
d198 1
d205 3
@


1.24
log
@Break cmdq_continue inner loop into a helper function.
@
text
@d1 1
a1 1
/* $OpenBSD: cmd-queue.c,v 1.23 2015/04/19 21:34:21 nicm Exp $ */
d38 1
a38 1
	cmdq->dead = 0;
d54 5
a58 2
	if (--cmdq->references != 0)
		return (cmdq->dead);
@


1.23
log
@Rewrite of tmux mouse support which was a mess. Instead of having
options for "mouse-this" and "mouse-that", mouse events may be bound as
keys and there is one option "mouse" that turns on mouse support
entirely (set -g mouse on).

See the new MOUSE SUPPORT section of the man page for description of the
key names and new flags (-t= to specify the pane or window under mouse
as a target, and send-keys -M to pass through a mouse event).

The default builtin bindings for the mouse are:

    bind -n   MouseDown1Pane select-pane -t=; send-keys -M
    bind -n MouseDown1Status select-window -t=
    bind -n   MouseDrag1Pane copy-mode -M
    bind -n MouseDrag1Border resize-pane -M

To get the effect of turning mode-mouse off, do:

    unbind -n MouseDrag1Pane
    unbind -temacs-copy MouseDrag1Pane

The old mouse options are now gone, set-option -q may be used to
suppress warnings if mixing configuration files.
@
text
@d1 1
a1 1
/* $OpenBSD: cmd-queue.c,v 1.22 2015/02/12 09:56:19 nicm Exp $ */
d28 2
d165 26
d197 1
a197 2
	int			 empty, flags;
	char			 s[1024];
d214 1
a214 17
			cmd_print(cmdq->cmd, s, sizeof s);
			log_debug("cmdq %p: %s (client %d)", cmdq, s,
			    cmdq->client != NULL ? cmdq->client->ibuf.fd : -1);

			cmdq->time = time(NULL);
			cmdq->number++;

			flags = !!(cmdq->cmd->flags & CMD_CONTROL);
			cmdq_guard(cmdq, "begin", flags);

			retval = cmdq->cmd->entry->exec(cmdq->cmd, cmdq);

			if (retval == CMD_RETURN_ERROR)
				cmdq_guard(cmdq, "error", flags);
			else
				cmdq_guard(cmdq, "end", flags);

a222 1

@


1.22
log
@Take a reference to prevent cmdq being freed during the command. Can
happen to cfg_cmd_q (possibly others) when source-file recurses into
cmdq_continue. Fixes bug reported by Ismail Donmez and Theo Buehler.
@
text
@d1 1
a1 1
/* $OpenBSD: cmd-queue.c,v 1.21 2015/02/05 10:26:29 nicm Exp $ */
d23 1
d136 1
a136 1
cmdq_run(struct cmd_q *cmdq, struct cmd_list *cmdlist)
d138 1
a138 1
	cmdq_append(cmdq, cmdlist);
d148 1
a148 1
cmdq_append(struct cmd_q *cmdq, struct cmd_list *cmdlist)
d156 5
@


1.21
log
@There is no need to save the guard state because the function checks it
again anyway.
@
text
@d1 1
a1 1
/* $OpenBSD: cmd-queue.c,v 1.20 2014/10/27 22:23:47 nicm Exp $ */
d166 1
d224 1
a224 1
		cmdq->emptyfn(cmdq); /* may free cmdq */
d229 2
@


1.20
log
@Move cfg_causes local into cfg.c and remove struct causelist.
@
text
@d1 1
a1 1
/* $OpenBSD: cmd-queue.c,v 1.19 2014/10/21 22:06:46 nicm Exp $ */
d120 1
a120 1
int
d125 2
a126 4
	if (c == NULL)
		return (0);
	if (!(c->flags & CLIENT_CONTROL))
		return (0);
a130 1
	return (1);
d163 1
a163 1
	int			 empty, guard, flags;
d188 1
a188 1
			guard = cmdq_guard(cmdq, "begin", flags);
d192 4
a195 6
			if (guard) {
				if (retval == CMD_RETURN_ERROR)
					cmdq_guard(cmdq, "error", flags);
				else
					cmdq_guard(cmdq, "end", flags);
			}
@


1.19
log
@Save next item after firing command in case it has added to the queue.
@
text
@d1 1
a1 1
/* $OpenBSD: cmd-queue.c,v 1.18 2014/10/20 23:57:13 nicm Exp $ */
d96 1
a96 1
	char		*msg, *cause;
d103 3
a105 4
	if (c == NULL) {
		xasprintf(&cause, "%s:%u: %s", cmd->file, cmd->line, msg);
		ARRAY_ADD(&cfg_causes, cause);
	} else if (c->session == NULL || (c->flags & CLIENT_CONTROL)) {
@


1.18
log
@Better format for printf format attributes.
@
text
@d1 1
a1 1
/* $OpenBSD: cmd-queue.c,v 1.17 2014/09/01 21:50:18 nicm Exp $ */
a182 2
		next = TAILQ_NEXT(cmdq->item, qentry);

d214 1
@


1.17
log
@Various minor style and spacing nits.
@
text
@d1 1
a1 1
/* $OpenBSD: cmd-queue.c,v 1.16 2014/04/17 07:55:43 nicm Exp $ */
d60 1
a60 1
void printflike2
d90 1
a90 1
void printflike2
@


1.16
log
@Remove the "info" message mechanism, this was only used for about five
mostly useless and annoying messages. Change those commands to silence
on success like all the others. Still accept the -q command line flag
and "quiet" server option for now.
@
text
@d1 1
a1 1
/* $OpenBSD: cmd-queue.c,v 1.15 2014/01/09 13:46:12 nicm Exp $ */
d127 1
a127 1
		return 0;
d129 1
a129 1
		return 0;
d134 1
a134 1
	return 1;
@


1.15
log
@Remove unnecessary calls to va_start/va_end, from Tiago Cunha.
@
text
@d1 1
a1 1
/* $OpenBSD: cmd-queue.c,v 1.14 2013/10/10 12:26:35 nicm Exp $ */
a86 31
}

/* Show info from command. */
void printflike2
cmdq_info(struct cmd_q *cmdq, const char *fmt, ...)
{
	struct client	*c = cmdq->client;
	va_list		 ap;
	char		*msg;

	if (options_get_number(&global_options, "quiet"))
		return;

	va_start(ap, fmt);

	if (c == NULL)
		/* nothing */;
	else if (c->session == NULL || (c->flags & CLIENT_CONTROL)) {
		evbuffer_add_vprintf(c->stdout_data, fmt, ap);

		evbuffer_add(c->stdout_data, "\n", 1);
		server_push_stdout(c);
	} else {
		xvasprintf(&msg, fmt, ap);
		*msg = toupper((u_char) *msg);
		status_message_set(c, "%s", msg);
		free(msg);
	}

	va_end(ap);

@


1.14
log
@Alter how tmux handles the working directory to internally use file
descriptors rather than strings.

- Each session still has a current working directory.

- New sessions still get their working directory from the client that
  created them or its attached session if any.

- New windows are created by default in the session working directory.

- The -c flag to new, neww, splitw allows the working directory to be
  overridden.

- The -c flag to attach let's the session working directory be changed.

- The default-path option has been removed.

To get the equivalent to default-path '.', do:

        bind c neww -c $PWD

To get the equivalent of default-path '~', do:

        bind c neww -c ~

This also changes the client identify protocol to be a set of messages rather
than one as well as some other changes that should make it easier to make
backwards-compatible protocol changes in future.
@
text
@d1 1
a1 1
/* $OpenBSD: cmd-queue.c,v 1.13 2013/10/10 12:12:54 nicm Exp $ */
a71 1
		va_start(ap, fmt);
a72 1
		va_end(ap);
a104 1
		va_start(ap, fmt);
a105 1
		va_end(ap);
@


1.13
log
@retcode -> retval for exit message.
@
text
@d1 1
a1 1
/* $OpenBSD: cmd-queue.c,v 1.12 2013/10/10 12:07:36 nicm Exp $ */
a284 24
}

/* Get default path using command queue. */
const char *
cmdq_default_path(struct cmd_q *cmdq, const char *cwd)
{
	struct client	*c = cmdq->client;
	struct session	*s;
	const char	*current;

	if ((s = cmd_current_session(cmdq, 0)) == NULL)
		return (NULL);

	if (cwd == NULL)
		cwd = options_get_string(&s->options, "default-path");

	if (c != NULL && c->session == NULL && c->cwd != NULL)
		current = c->cwd;
	else if (s->curw != NULL)
		current = get_proc_cwd(s->curw->window->active->fd);
	else
		current = NULL;

	return (cmd_default_path(s->cwd, current, cwd));
@


1.12
log
@Support -c for new-session, based on code from J Raynor.
@
text
@d1 1
a1 1
/* $OpenBSD: cmd-queue.c,v 1.11 2013/10/10 12:04:38 nicm Exp $ */
d146 1
a146 1
		c->retcode = 1;
@


1.11
log
@Make cmdq->client_exit a tristate (-1 means "not set") so that if
explicitly set it can be copied from child to parent cmdq by if-shell
and source-file. This fixes using attach or new. From Chris Johnsen.
@
text
@d1 1
a1 1
/* $OpenBSD: cmd-queue.c,v 1.10 2013/10/10 11:45:28 nicm Exp $ */
d285 24
@


1.10
log
@Pass flags into cmdq_guard as an argument since sometimes cmdq->cmd can
be NULL. Avoids crash when a command in a command client can't be
parsed.
@
text
@d1 1
a1 1
/* $OpenBSD: cmd-queue.c,v 1.9 2013/06/23 12:41:54 nicm Exp $ */
d38 1
a38 1
	cmdq->client_exit = 0;
d262 1
a262 1
	if (cmdq->client_exit)
@


1.9
log
@Mark control commands specially so the client can identify them, based
on a diff from George Nachman a while back.
@
text
@d1 1
a1 1
/* $OpenBSD: cmd-queue.c,v 1.8 2013/04/10 12:15:36 nicm Exp $ */
d157 1
a157 1
cmdq_guard(struct cmd_q *cmdq, const char *guard)
a159 1
	int		 flags;
a165 2
	flags = !!(cmdq->cmd->flags & CMD_CONTROL);

d202 1
a202 1
	int			 empty, guard;
d228 3
a230 1
			guard = cmdq_guard(cmdq, "begin");
d232 1
d235 1
a235 1
				    cmdq_guard(cmdq, "error");
d237 1
a237 1
				    cmdq_guard(cmdq, "end");
@


1.8
log
@Fix bug where end guard in control mode was not printed after session
destroyed, from George Nachman.
@
text
@d1 1
a1 1
/* $OpenBSD: cmd-queue.c,v 1.7 2013/03/26 10:54:48 nicm Exp $ */
d160 1
d167 4
a170 2
	evbuffer_add_printf(c->stdout_data, "%%%s %ld %u\n", guard,
	    (long) cmdq->time, cmdq->number);
@


1.7
log
@Fix compiler warnings, missing #include. From Thomas Adam.
@
text
@d1 1
a1 1
/* $OpenBSD: cmd-queue.c,v 1.6 2013/03/25 11:41:16 nicm Exp $ */
d161 1
a161 1
	if (c == NULL || c->session == NULL)
@


1.6
log
@Only send end guard if begin was sent, from George Nachman.
@
text
@d1 1
a1 1
/* $OpenBSD: cmd-queue.c,v 1.5 2013/03/25 11:36:08 nicm Exp $ */
d23 1
@


1.5
log
@Fix a warning.
@
text
@d1 1
a1 1
/* $OpenBSD: cmd-queue.c,v 1.4 2013/03/25 11:35:55 nicm Exp $ */
d155 1
a155 1
void
d161 1
a161 1
		return;
d163 1
a163 1
		return;
d168 1
d201 1
a201 1
	int			 empty;
d227 1
a227 1
			cmdq_guard(cmdq, "begin");
d229 6
a234 4
			if (retval == CMD_RETURN_ERROR)
				cmdq_guard(cmdq, "error");
			else
				cmdq_guard(cmdq, "end");
@


1.4
log
@Add time and a command count to control mode guards, based on code from
George Nachman.
@
text
@d1 1
a1 1
/* $OpenBSD: cmd-queue.c,v 1.3 2013/03/25 10:06:13 nicm Exp $ */
d166 1
a166 1
	    cmdq->time, cmdq->number);
@


1.3
log
@Add some additional debug logging.
@
text
@d1 1
a1 1
/* $OpenBSD: cmd-queue.c,v 1.2 2013/03/25 10:05:00 nicm Exp $ */
d154 16
a197 1
	struct client		*c = cmdq->client;
d200 1
a200 1
	int			 guards, empty;
a202 4
	guards = 0;
	if (c != NULL && c->session != NULL)
		guards = c->flags & CLIENT_CONTROL;

d223 4
a226 2
			if (guards)
				cmdq_print(cmdq, "%%begin");
d228 4
a231 6
			if (guards) {
				if (retval == CMD_RETURN_ERROR)
					cmdq_print(cmdq, "%%error");
				else
					cmdq_print(cmdq, "%%end");
			}
@


1.2
log
@Print %%error not %%end guard on error, from George Nachman.
@
text
@d1 1
a1 1
/* $OpenBSD: cmd-queue.c,v 1.1 2013/03/24 09:54:10 nicm Exp $ */
d186 1
d208 4
@


1.1
log
@Add a command queue to standardize and simplify commands that call other
commands and allow a command to block execution of subsequent
commands. This allows run-shell and if-shell to be synchronous which has
been much requested.

Each client has a default command queue and commands are consumed one at
a time from it. A command may suspend execution from the queue by
returning CMD_RETURN_WAIT and then resume it by calling cmd_continue() -
for example run-shell does this from the callback that is fired after
the job is freed.

When the command queue becomes empty, command clients are automatically
exited (unless attaching). A callback is also fired - this is used for
nested commands in, for example, if-shell which can block execution of
the client's cmdq until a new cmdq becomes empty.

Also merge all the old error/info/print functions together and lose the
old curclient/cmdclient distinction - a cmdq is bound to one client (or
none if in the configuration file), this is a command client if
c->session is NULL otherwise an attached client.
@
text
@d1 1
a1 1
/* $OpenBSD$ */
d210 6
a215 2
			if (guards)
				cmdq_print(cmdq, "%%end");
@

