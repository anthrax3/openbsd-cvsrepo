head	1.32;
access;
symbols
	OPENBSD_6_1:1.32.0.2
	OPENBSD_6_1_BASE:1.32
	OPENBSD_6_0:1.27.0.2
	OPENBSD_6_0_BASE:1.27
	OPENBSD_5_9:1.26.0.2
	OPENBSD_5_9_BASE:1.26
	OPENBSD_5_8:1.23.0.4
	OPENBSD_5_8_BASE:1.23
	OPENBSD_5_7:1.22.0.2
	OPENBSD_5_7_BASE:1.22
	OPENBSD_5_6:1.22.0.4
	OPENBSD_5_6_BASE:1.22
	OPENBSD_5_5:1.21.0.4
	OPENBSD_5_5_BASE:1.21
	OPENBSD_5_4:1.18.0.2
	OPENBSD_5_4_BASE:1.18
	OPENBSD_5_3:1.16.0.2
	OPENBSD_5_3_BASE:1.16
	OPENBSD_5_2:1.14.0.2
	OPENBSD_5_2_BASE:1.14
	OPENBSD_5_1_BASE:1.8
	OPENBSD_5_1:1.8.0.2
	OPENBSD_5_0:1.7.0.2
	OPENBSD_5_0_BASE:1.7
	OPENBSD_4_9:1.6.0.4
	OPENBSD_4_9_BASE:1.6
	OPENBSD_4_8:1.6.0.2
	OPENBSD_4_8_BASE:1.6
	OPENBSD_4_7:1.5.0.2
	OPENBSD_4_7_BASE:1.5
	OPENBSD_4_6:1.1.0.4
	OPENBSD_4_6_BASE:1.1;
locks; strict;
comment	@ * @;


1.32
date	2017.03.11.15.16.35;	author nicm;	state Exp;
branches;
next	1.31;
commitid	Hq4toy96xVmoeuiL;

1.31
date	2016.10.16.22.06.40;	author nicm;	state Exp;
branches;
next	1.30;
commitid	j0FZs70gSPCmpqWI;

1.30
date	2016.10.10.17.28.30;	author nicm;	state Exp;
branches;
next	1.29;
commitid	CMho0Ft9MVt5ZzOC;

1.29
date	2016.09.04.17.37.06;	author nicm;	state Exp;
branches;
next	1.28;
commitid	D34i60nsvTyoBV4q;

1.28
date	2016.08.03.09.07.02;	author nicm;	state Exp;
branches;
next	1.27;
commitid	PiVgxuhKYG0ljj7x;

1.27
date	2016.04.29.15.00.48;	author nicm;	state Exp;
branches;
next	1.26;
commitid	z5NrpOKjZoYhx6Qr;

1.26
date	2016.01.19.15.59.12;	author nicm;	state Exp;
branches;
next	1.25;
commitid	P3qmSOx6KrDBsb0c;

1.25
date	2015.12.11.16.37.21;	author nicm;	state Exp;
branches;
next	1.24;
commitid	pfV7j8HdB7hdHnZm;

1.24
date	2015.09.18.09.55.22;	author nicm;	state Exp;
branches;
next	1.23;
commitid	W45e7LX7VGTjmrhD;

1.23
date	2015.04.19.21.34.21;	author nicm;	state Exp;
branches;
next	1.22;
commitid	wug6ctIOfhVMeWQp;

1.22
date	2014.05.08.06.03.30;	author nicm;	state Exp;
branches;
next	1.21;

1.21
date	2014.02.22.18.01.10;	author nicm;	state Exp;
branches;
next	1.20;

1.20
date	2013.10.10.12.08.14;	author nicm;	state Exp;
branches;
next	1.19;

1.19
date	2013.10.10.12.03.46;	author nicm;	state Exp;
branches;
next	1.18;

1.18
date	2013.03.24.09.57.59;	author nicm;	state Exp;
branches;
next	1.17;

1.17
date	2013.03.22.10.37.39;	author nicm;	state Exp;
branches;
next	1.16;

1.16
date	2013.01.17.00.11.22;	author nicm;	state Exp;
branches;
next	1.15;

1.15
date	2012.10.26.14.35.42;	author nicm;	state Exp;
branches;
next	1.14;

1.14
date	2012.07.10.11.53.01;	author nicm;	state Exp;
branches;
next	1.13;

1.13
date	2012.04.01.21.07.35;	author nicm;	state Exp;
branches;
next	1.12;

1.12
date	2012.04.01.13.21.38;	author nicm;	state Exp;
branches;
next	1.11;

1.11
date	2012.04.01.13.18.38;	author nicm;	state Exp;
branches;
next	1.10;

1.10
date	2012.03.17.22.35.09;	author nicm;	state Exp;
branches;
next	1.9;

1.9
date	2012.03.03.08.31.18;	author nicm;	state Exp;
branches;
next	1.8;

1.8
date	2012.01.29.09.37.02;	author nicm;	state Exp;
branches;
next	1.7;

1.7
date	2011.05.08.20.34.12;	author nicm;	state Exp;
branches;
next	1.6;

1.6
date	2010.06.29.03.30.14;	author nicm;	state Exp;
branches;
next	1.5;

1.5
date	2010.01.07.20.52.18;	author nicm;	state Exp;
branches;
next	1.4;

1.4
date	2009.12.03.22.50.10;	author nicm;	state Exp;
branches;
next	1.3;

1.3
date	2009.07.19.13.21.40;	author nicm;	state Exp;
branches;
next	1.2;

1.2
date	2009.07.14.07.23.36;	author nicm;	state Exp;
branches;
next	1.1;

1.1
date	2009.06.01.22.58.49;	author nicm;	state Exp;
branches;
next	;


desc
@@


1.32
log
@Fix calculation of size for full size splits.
@
text
@/* $OpenBSD: layout.c,v 1.31 2016/10/16 22:06:40 nicm Exp $ */

/*
 * Copyright (c) 2009 Nicholas Marriott <nicholas.marriott@@gmail.com>
 * Copyright (c) 2016 Stephen Kent <smkent@@smkent.net>
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF MIND, USE, DATA OR PROFITS, WHETHER
 * IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING
 * OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */

#include <sys/types.h>

#include <stdlib.h>

#include "tmux.h"

/*
 * The window layout is a tree of cells each of which can be one of: a
 * left-right container for a list of cells, a top-bottom container for a list
 * of cells, or a container for a window pane.
 *
 * Each window has a pointer to the root of its layout tree (containing its
 * panes), every pane has a pointer back to the cell containing it, and each
 * cell a pointer to its parent cell.
 */

static u_int	layout_resize_check(struct window *, struct layout_cell *,
		    enum layout_type);
static int	layout_resize_pane_grow(struct window *, struct layout_cell *,
		    enum layout_type, int, int);
static int	layout_resize_pane_shrink(struct window *, struct layout_cell *,
		    enum layout_type, int);
static int	layout_need_status(struct layout_cell *, int);
static u_int	layout_new_pane_size(struct window *, u_int,
		    struct layout_cell *, enum layout_type, u_int, u_int,
		    u_int);
static int	layout_set_size_check(struct window *, struct layout_cell *,
		    enum layout_type, int);
static void	layout_resize_child_cells(struct window *,
		    struct layout_cell *);

struct layout_cell *
layout_create_cell(struct layout_cell *lcparent)
{
	struct layout_cell	*lc;

	lc = xmalloc(sizeof *lc);
	lc->type = LAYOUT_WINDOWPANE;
	lc->parent = lcparent;

	TAILQ_INIT(&lc->cells);

	lc->sx = UINT_MAX;
	lc->sy = UINT_MAX;

	lc->xoff = UINT_MAX;
	lc->yoff = UINT_MAX;

	lc->wp = NULL;

	return (lc);
}

void
layout_free_cell(struct layout_cell *lc)
{
	struct layout_cell	*lcchild;

	switch (lc->type) {
	case LAYOUT_LEFTRIGHT:
	case LAYOUT_TOPBOTTOM:
		while (!TAILQ_EMPTY(&lc->cells)) {
			lcchild = TAILQ_FIRST(&lc->cells);
			TAILQ_REMOVE(&lc->cells, lcchild, entry);
			layout_free_cell(lcchild);
		}
		break;
	case LAYOUT_WINDOWPANE:
		if (lc->wp != NULL)
			lc->wp->layout_cell = NULL;
		break;
	}

	free(lc);
}

void
layout_print_cell(struct layout_cell *lc, const char *hdr, u_int n)
{
	struct layout_cell	*lcchild;

	log_debug("%s:%*s%p type %u [parent %p] wp=%p [%u,%u %ux%u]", hdr, n,
	    " ", lc, lc->type, lc->parent, lc->wp, lc->xoff, lc->yoff, lc->sx,
	    lc->sy);
	switch (lc->type) {
	case LAYOUT_LEFTRIGHT:
	case LAYOUT_TOPBOTTOM:
		TAILQ_FOREACH(lcchild, &lc->cells, entry)
		    	layout_print_cell(lcchild, hdr, n + 1);
		break;
	case LAYOUT_WINDOWPANE:
		break;
	}
}

void
layout_set_size(struct layout_cell *lc, u_int sx, u_int sy, u_int xoff,
    u_int yoff)
{
	lc->sx = sx;
	lc->sy = sy;

	lc->xoff = xoff;
	lc->yoff = yoff;
}

void
layout_make_leaf(struct layout_cell *lc, struct window_pane *wp)
{
	lc->type = LAYOUT_WINDOWPANE;

	TAILQ_INIT(&lc->cells);

	wp->layout_cell = lc;
	lc->wp = wp;
}

void
layout_make_node(struct layout_cell *lc, enum layout_type type)
{
	if (type == LAYOUT_WINDOWPANE)
		fatalx("bad layout type");
	lc->type = type;

	TAILQ_INIT(&lc->cells);

	if (lc->wp != NULL)
		lc->wp->layout_cell = NULL;
	lc->wp = NULL;
}

/* Fix cell offsets based on their sizes. */
void
layout_fix_offsets(struct layout_cell *lc)
{
	struct layout_cell	*lcchild;
	u_int			 xoff, yoff;

	if (lc->type == LAYOUT_LEFTRIGHT) {
		xoff = lc->xoff;
		TAILQ_FOREACH(lcchild, &lc->cells, entry) {
			lcchild->xoff = xoff;
			lcchild->yoff = lc->yoff;
			if (lcchild->type != LAYOUT_WINDOWPANE)
				layout_fix_offsets(lcchild);
			xoff += lcchild->sx + 1;
		}
	} else {
		yoff = lc->yoff;
		TAILQ_FOREACH(lcchild, &lc->cells, entry) {
			lcchild->xoff = lc->xoff;
			lcchild->yoff = yoff;
			if (lcchild->type != LAYOUT_WINDOWPANE)
				layout_fix_offsets(lcchild);
			yoff += lcchild->sy + 1;
		}
	}
}

/*
 * Returns 1 if we need to reserve space for the pane status line. This is the
 * case for the most upper panes only.
 */
static int
layout_need_status(struct layout_cell *lc, int at_top)
{
	struct layout_cell	*first_lc;

	if (lc->parent) {
		if (lc->parent->type == LAYOUT_LEFTRIGHT)
			return (layout_need_status(lc->parent, at_top));

		if (at_top)
			first_lc = TAILQ_FIRST(&lc->parent->cells);
		else
			first_lc = TAILQ_LAST(&lc->parent->cells,layout_cells);
		if (lc == first_lc)
			return (layout_need_status(lc->parent, at_top));
		return (0);
	}
	return (1);
}

/* Update pane offsets and sizes based on their cells. */
void
layout_fix_panes(struct window *w, u_int wsx, u_int wsy)
{
	struct window_pane	*wp;
	struct layout_cell	*lc;
	u_int			 sx, sy;
	int			 shift, status, at_top;

	status = options_get_number(w->options, "pane-border-status");
	at_top = (status == 1);
	TAILQ_FOREACH(wp, &w->panes, entry) {
		if ((lc = wp->layout_cell) == NULL)
			continue;

		if (status != 0)
			shift = layout_need_status(lc, at_top);
		else
			shift = 0;

		wp->xoff = lc->xoff;
		wp->yoff = lc->yoff;

		if (shift && at_top)
			wp->yoff += 1;

		/*
		 * Layout cells are limited by the smallest size of other cells
		 * within the same row or column; if this isn't the case
		 * resizing becomes difficult.
		 *
		 * However, panes do not have to take up their entire cell, so
		 * they can be cropped to the window edge if the layout
		 * overflows and they are partly visible.
		 *
		 * This stops cells being hidden unnecessarily.
		 */

		/*
		 * Work out the horizontal size. If the pane is actually
		 * outside the window or the entire pane is already visible,
		 * don't crop.
		 */
		if (lc->xoff >= wsx || lc->xoff + lc->sx < wsx)
			sx = lc->sx;
		else {
			sx = wsx - lc->xoff;
			if (sx < 1)
				sx = lc->sx;
		}

		/*
		 * Similarly for the vertical size; the minimum vertical size
		 * is two because scroll regions cannot be one line.
		 */
		if (lc->yoff >= wsy || lc->yoff + lc->sy < wsy)
			sy = lc->sy;
		else {
			sy = wsy - lc->yoff;
			if (sy < 2)
				sy = lc->sy;
		}

		if (shift)
			sy -= 1;

		window_pane_resize(wp, sx, sy);
	}
}

/* Count the number of available cells in a layout. */
u_int
layout_count_cells(struct layout_cell *lc)
{
	struct layout_cell	*lcchild;
	u_int			 count;

	switch (lc->type) {
	case LAYOUT_WINDOWPANE:
		return (1);
	case LAYOUT_LEFTRIGHT:
	case LAYOUT_TOPBOTTOM:
		count = 0;
		TAILQ_FOREACH(lcchild, &lc->cells, entry)
			count += layout_count_cells(lcchild);
		return (count);
	default:
		fatalx("bad layout type");
	}
}

/* Calculate how much size is available to be removed from a cell. */
static u_int
layout_resize_check(struct window *w, struct layout_cell *lc,
    enum layout_type type)
{
	struct layout_cell	*lcchild;
	u_int			 available, minimum;

	if (lc->type == LAYOUT_WINDOWPANE) {
		/* Space available in this cell only. */
		minimum = PANE_MINIMUM;
		if (type == LAYOUT_LEFTRIGHT)
			available = lc->sx;
		else {
			available = lc->sy;
			minimum += layout_need_status(lc,
			    options_get_number(w->options,
			    "pane-border-status") == 1);
		}
		if (available > minimum)
			available -= minimum;
		else
			available = 0;
	} else if (lc->type == type) {
		/* Same type: total of available space in all child cells. */
		available = 0;
		TAILQ_FOREACH(lcchild, &lc->cells, entry)
			available += layout_resize_check(w, lcchild, type);
	} else {
		/* Different type: minimum of available space in child cells. */
		minimum = UINT_MAX;
		TAILQ_FOREACH(lcchild, &lc->cells, entry) {
			available = layout_resize_check(w, lcchild, type);
			if (available < minimum)
				minimum = available;
		}
		available = minimum;
	}

	return (available);
}

/*
 * Adjust cell size evenly, including altering its children. This function
 * expects the change to have already been bounded to the space available.
 */
void
layout_resize_adjust(struct window *w, struct layout_cell *lc,
    enum layout_type type, int change)
{
	struct layout_cell	*lcchild;

	/* Adjust the cell size. */
	if (type == LAYOUT_LEFTRIGHT)
		lc->sx += change;
	else
		lc->sy += change;

	/* If this is a leaf cell, that is all that is necessary. */
	if (type == LAYOUT_WINDOWPANE)
		return;

	/* Child cell runs in a different direction. */
	if (lc->type != type) {
		TAILQ_FOREACH(lcchild, &lc->cells, entry)
			layout_resize_adjust(w, lcchild, type, change);
		return;
	}

	/*
	 * Child cell runs in the same direction. Adjust each child equally
	 * until no further change is possible.
	 */
	while (change != 0) {
		TAILQ_FOREACH(lcchild, &lc->cells, entry) {
			if (change == 0)
				break;
			if (change > 0) {
				layout_resize_adjust(w, lcchild, type, 1);
				change--;
				continue;
			}
			if (layout_resize_check(w, lcchild, type) > 0) {
				layout_resize_adjust(w, lcchild, type, -1);
				change++;
			}
		}
	}
}

/* Destroy a cell and redistribute the space. */
void
layout_destroy_cell(struct window *w, struct layout_cell *lc,
    struct layout_cell **lcroot)
{
	struct layout_cell     *lcother, *lcparent;

	/*
	 * If no parent, this is the last pane so window close is imminent and
	 * there is no need to resize anything.
	 */
	lcparent = lc->parent;
	if (lcparent == NULL) {
		layout_free_cell(lc);
		*lcroot = NULL;
		return;
	}

	/* Merge the space into the previous or next cell. */
	if (lc == TAILQ_FIRST(&lcparent->cells))
		lcother = TAILQ_NEXT(lc, entry);
	else
		lcother = TAILQ_PREV(lc, layout_cells, entry);
	if (lcparent->type == LAYOUT_LEFTRIGHT)
		layout_resize_adjust(w, lcother, lcparent->type, lc->sx + 1);
	else
		layout_resize_adjust(w, lcother, lcparent->type, lc->sy + 1);

	/* Remove this from the parent's list. */
	TAILQ_REMOVE(&lcparent->cells, lc, entry);
	layout_free_cell(lc);

	/*
	 * If the parent now has one cell, remove the parent from the tree and
	 * replace it by that cell.
	 */
	lc = TAILQ_FIRST(&lcparent->cells);
	if (TAILQ_NEXT(lc, entry) == NULL) {
		TAILQ_REMOVE(&lcparent->cells, lc, entry);

		lc->parent = lcparent->parent;
		if (lc->parent == NULL) {
			lc->xoff = 0; lc->yoff = 0;
			*lcroot = lc;
		} else
			TAILQ_REPLACE(&lc->parent->cells, lcparent, lc, entry);

		layout_free_cell(lcparent);
	}
}

void
layout_init(struct window *w, struct window_pane *wp)
{
	struct layout_cell	*lc;

	lc = w->layout_root = layout_create_cell(NULL);
	layout_set_size(lc, w->sx, w->sy, 0, 0);
	layout_make_leaf(lc, wp);

	layout_fix_panes(w, w->sx, w->sy);
}

void
layout_free(struct window *w)
{
	layout_free_cell(w->layout_root);
}

/* Resize the entire layout after window resize. */
void
layout_resize(struct window *w, u_int sx, u_int sy)
{
	struct layout_cell	*lc = w->layout_root;
	int			 xlimit, ylimit, xchange, ychange;

	/*
	 * Adjust horizontally. Do not attempt to reduce the layout lower than
	 * the minimum (more than the amount returned by layout_resize_check).
	 *
	 * This can mean that the window size is smaller than the total layout
	 * size: redrawing this is handled at a higher level, but it does leave
	 * a problem with growing the window size here: if the current size is
	 * < the minimum, growing proportionately by adding to each pane is
	 * wrong as it would keep the layout size larger than the window size.
	 * Instead, spread the difference between the minimum and the new size
	 * out proportionately - this should leave the layout fitting the new
	 * window size.
	 */
	xchange = sx - w->sx;
	xlimit = layout_resize_check(w, lc, LAYOUT_LEFTRIGHT);
	if (xchange < 0 && xchange < -xlimit)
		xchange = -xlimit;
	if (xlimit == 0) {
		if (sx <= lc->sx)	/* lc->sx is minimum possible */
			xchange = 0;
		else
			xchange = sx - lc->sx;
	}
	if (xchange != 0)
		layout_resize_adjust(w, lc, LAYOUT_LEFTRIGHT, xchange);

	/* Adjust vertically in a similar fashion. */
	ychange = sy - w->sy;
	ylimit = layout_resize_check(w, lc, LAYOUT_TOPBOTTOM);
	if (ychange < 0 && ychange < -ylimit)
		ychange = -ylimit;
	if (ylimit == 0) {
		if (sy <= lc->sy)	/* lc->sy is minimum possible */
			ychange = 0;
		else
			ychange = sy - lc->sy;
	}
	if (ychange != 0)
		layout_resize_adjust(w, lc, LAYOUT_TOPBOTTOM, ychange);

	/* Fix cell offsets. */
	layout_fix_offsets(lc);
	layout_fix_panes(w, sx, sy);
}

/* Resize a pane to an absolute size. */
void
layout_resize_pane_to(struct window_pane *wp, enum layout_type type,
    u_int new_size)
{
	struct layout_cell     *lc, *lcparent;
	int			change, size;

	lc = wp->layout_cell;

	/* Find next parent of the same type. */
	lcparent = lc->parent;
	while (lcparent != NULL && lcparent->type != type) {
		lc = lcparent;
		lcparent = lc->parent;
	}
	if (lcparent == NULL)
		return;

	/* Work out the size adjustment. */
	if (type == LAYOUT_LEFTRIGHT)
		size = lc->sx;
	else
		size = lc->sy;
	if (lc == TAILQ_LAST(&lcparent->cells, layout_cells))
		change = size - new_size;
	else
		change = new_size - size;

	/* Resize the pane. */
	layout_resize_pane(wp, type, change, 1);
}

/* Resize a single pane within the layout. */
void
layout_resize_pane(struct window_pane *wp, enum layout_type type, int change,
    int opposite)
{
	struct window		*w = wp->window;
	struct layout_cell	*lc, *lcparent;
	int			 needed, size;

	lc = wp->layout_cell;

	/* Find next parent of the same type. */
	lcparent = lc->parent;
	while (lcparent != NULL && lcparent->type != type) {
		lc = lcparent;
		lcparent = lc->parent;
	}
	if (lcparent == NULL)
		return;

	/* If this is the last cell, move back one. */
	if (lc == TAILQ_LAST(&lcparent->cells, layout_cells))
		lc = TAILQ_PREV(lc, layout_cells, entry);

	/* Grow or shrink the cell. */
	needed = change;
	while (needed != 0) {
		if (change > 0) {
			size = layout_resize_pane_grow(w, lc, type, needed,
			    opposite);
			needed -= size;
		} else {
			size = layout_resize_pane_shrink(w, lc, type, needed);
			needed += size;
		}

		if (size == 0)	/* no more change possible */
			break;
	}

	/* Fix cell offsets. */
	layout_fix_offsets(wp->window->layout_root);
	layout_fix_panes(wp->window, wp->window->sx, wp->window->sy);
	notify_window("window-layout-changed", wp->window);
}

/* Helper function to grow pane. */
static int
layout_resize_pane_grow(struct window *w, struct layout_cell *lc,
    enum layout_type type, int needed, int opposite)
{
	struct layout_cell	*lcadd, *lcremove;
	u_int			 size = 0;

	/* Growing. Always add to the current cell. */
	lcadd = lc;

	/* Look towards the tail for a suitable cell for reduction. */
	lcremove = TAILQ_NEXT(lc, entry);
	while (lcremove != NULL) {
		size = layout_resize_check(w, lcremove, type);
		if (size > 0)
			break;
		lcremove = TAILQ_NEXT(lcremove, entry);
	}

	/* If none found, look towards the head. */
	if (opposite && lcremove == NULL) {
		lcremove = TAILQ_PREV(lc, layout_cells, entry);
		while (lcremove != NULL) {
			size = layout_resize_check(w, lcremove, type);
			if (size > 0)
				break;
			lcremove = TAILQ_PREV(lcremove, layout_cells, entry);
		}
	}
	if (lcremove == NULL)
		return (0);

	/* Change the cells. */
	if (size > (u_int) needed)
		size = needed;
	layout_resize_adjust(w, lcadd, type, size);
	layout_resize_adjust(w, lcremove, type, -size);
	return (size);
}

/* Helper function to shrink pane. */
static int
layout_resize_pane_shrink(struct window *w, struct layout_cell *lc,
    enum layout_type type, int needed)
{
	struct layout_cell	*lcadd, *lcremove;
	u_int			 size;

	/* Shrinking. Find cell to remove from by walking towards head. */
	lcremove = lc;
	do {
		size = layout_resize_check(w, lcremove, type);
		if (size != 0)
			break;
		lcremove = TAILQ_PREV(lcremove, layout_cells, entry);
	} while (lcremove != NULL);
	if (lcremove == NULL)
		return (0);

	/* And add onto the next cell (from the original cell). */
	lcadd = TAILQ_NEXT(lc, entry);
	if (lcadd == NULL)
		return (0);

	/* Change the cells. */
	if (size > (u_int) -needed)
		size = -needed;
	layout_resize_adjust(w, lcadd, type, size);
	layout_resize_adjust(w, lcremove, type, -size);
	return (size);
}

/* Assign window pane to newly split cell. */
void
layout_assign_pane(struct layout_cell *lc, struct window_pane *wp)
{
	layout_make_leaf(lc, wp);
	layout_fix_panes(wp->window, wp->window->sx, wp->window->sy);
}

/* Calculate the new pane size for resized parent. */
static u_int
layout_new_pane_size(struct window *w, u_int previous, struct layout_cell *lc,
    enum layout_type type, u_int size, u_int count_left, u_int size_left)
{
	u_int	new_size, min, max, available;

	/* If this is the last cell, it can take all of the remaining size. */
	if (count_left == 1)
		return (size_left);

	/* How much is available in this parent? */
	available = layout_resize_check(w, lc, type);

	/*
	 * Work out the minimum size of this cell and the new size
	 * proportionate to the previous size.
	 */
	min = (PANE_MINIMUM + 1) * (count_left - 1);
	if (type == LAYOUT_LEFTRIGHT) {
		if (lc->sx - available > min)
			min = lc->sx - available;
		new_size = (lc->sx * size) / previous;
	} else {
		if (lc->sy - available > min)
			min = lc->sy - available;
		new_size = (lc->sy * size) / previous;
	}

	/* Check against the maximum and minimum size. */
	max = size_left - min;
	if (new_size > max)
		new_size = max;
	if (new_size < PANE_MINIMUM)
		new_size = PANE_MINIMUM;
	return (new_size);
}

/* Check if the cell and all its children can be resized to a specific size. */
static int
layout_set_size_check(struct window *w, struct layout_cell *lc,
    enum layout_type type, int size)
{
	struct layout_cell	*lcchild;
	u_int			new_size, available, previous, count, idx;

	/* Cells with no children must just be bigger than minimum. */
	if (lc->type == LAYOUT_WINDOWPANE)
		return (size >= PANE_MINIMUM);
	available = size;

	/* Count number of children. */
	count = 0;
	TAILQ_FOREACH(lcchild, &lc->cells, entry)
		count++;

	/* Check new size will work for each child. */
	if (lc->type == type) {
		if (type == LAYOUT_LEFTRIGHT)
			previous = lc->sx;
		else
			previous = lc->sy;

		idx = 0;
		TAILQ_FOREACH(lcchild, &lc->cells, entry) {
			new_size = layout_new_pane_size(w, previous, lcchild,
			    type, size, count - idx, available);
			if (new_size > available)
				return (0);

			available -= (new_size + 1);
			if (!layout_set_size_check(w, lcchild, type, new_size))
				return (0);

			idx++;
		}
	} else {
		TAILQ_FOREACH(lcchild, &lc->cells, entry) {
			if (lcchild->type == LAYOUT_WINDOWPANE)
				continue;
			if (!layout_set_size_check(w, lcchild, type, size))
				return (0);
		}
	}

	return (1);
}

/* Resize all child cells to fit within the current cell. */
static void
layout_resize_child_cells(struct window *w, struct layout_cell *lc)
{
	struct layout_cell	*lcchild;
	u_int			 previous, available, count, idx;

	if (lc->type == LAYOUT_WINDOWPANE)
		return;

	/* What is the current size used? */
	count = 0;
	previous = 0;
	TAILQ_FOREACH(lcchild, &lc->cells, entry) {
		count++;
		if (lc->type == LAYOUT_LEFTRIGHT)
			previous += lcchild->sx;
		else if (lc->type == LAYOUT_TOPBOTTOM)
			previous += lcchild->sy;
	}
	previous += (count - 1);

	/* And how much is available? */
	available = 0;
	if (lc->type == LAYOUT_LEFTRIGHT)
		available = lc->sx;
	else if (lc->type == LAYOUT_TOPBOTTOM)
		available = lc->sy;

	/* Resize children into the new size. */
	idx = 0;
	TAILQ_FOREACH(lcchild, &lc->cells, entry) {
		if (lc->type == LAYOUT_TOPBOTTOM) {
			lcchild->sx = lc->sx;
			lcchild->xoff = lc->xoff;
		} else {
			lcchild->sx = layout_new_pane_size(w, previous, lcchild,
			    lc->type, lc->sx, count - idx, available);
			available -= (lcchild->sx + 1);
		}
		if (lc->type == LAYOUT_LEFTRIGHT)
			lcchild->sy = lc->sy;
		else {
			lcchild->sy = layout_new_pane_size(w, previous, lcchild,
			    lc->type, lc->sy, count - idx, available);
			available -= (lcchild->sy + 1);
		}
		layout_resize_child_cells(w, lcchild);
		idx++;
	}
}

/*
 * Split a pane into two. size is a hint, or -1 for default half/half
 * split. This must be followed by layout_assign_pane before much else happens!
 */
struct layout_cell *
layout_split_pane(struct window_pane *wp, enum layout_type type, int size,
    int insert_before, int full_size)
{
	struct layout_cell     *lc, *lcparent, *lcnew, *lc1, *lc2;
	u_int			sx, sy, xoff, yoff, size1, size2;
	u_int			new_size, saved_size, resize_first = 0;

	/*
	 * If full_size is specified, add a new cell at the top of the window
	 * layout. Otherwise, split the cell for the current pane.
	 */
	if (full_size)
		lc = wp->window->layout_root;
	else
		lc = wp->layout_cell;

	/* Copy the old cell size. */
	sx = lc->sx;
	sy = lc->sy;
	xoff = lc->xoff;
	yoff = lc->yoff;

	/* Check there is enough space for the two new panes. */
	switch (type) {
	case LAYOUT_LEFTRIGHT:
		if (sx < PANE_MINIMUM * 2 + 1)
			return (NULL);
		break;
	case LAYOUT_TOPBOTTOM:
		if (sy < PANE_MINIMUM * 2 + 1)
			return (NULL);
		break;
	default:
		fatalx("bad layout type");
	}

	/*
	 * Calculate new cell sizes. size is the target size or -1 for middle
	 * split, size1 is the size of the top/left and size2 the bottom/right.
	 */
	if (type == LAYOUT_LEFTRIGHT)
		saved_size = sx;
	else
		saved_size = sy;
	if (size < 0)
		size2 = ((saved_size + 1) / 2) - 1;
	else if (insert_before)
		size2 = saved_size - size - 1;
	else
		size2 = size;
	if (size2 < PANE_MINIMUM)
		size2 = PANE_MINIMUM;
	else if (size2 > saved_size - 2)
		size2 = saved_size - 2;
	size1 = saved_size - 1 - size2;

	/* Which size are we using? */
	if (insert_before)
		new_size = size2;
	else
		new_size = size1;

	/* Confirm there is enough space for full size pane. */
	if (full_size && !layout_set_size_check(wp->window, lc, type, new_size))
		return (NULL);

	if (lc->parent != NULL && lc->parent->type == type) {
		/*
		 * If the parent exists and is of the same type as the split,
		 * create a new cell and insert it after this one.
		 */
		lcparent = lc->parent;
		lcnew = layout_create_cell(lcparent);
		if (insert_before)
			TAILQ_INSERT_BEFORE(lc, lcnew, entry);
		else
			TAILQ_INSERT_AFTER(&lcparent->cells, lc, lcnew, entry);
	} else if (full_size && lc->parent == NULL && lc->type == type) {
		/*
		 * If the new full size pane is the same type as the root
		 * split, insert the new pane under the existing root cell
		 * instead of creating a new root cell. The existing layout
		 * must be resized before inserting the new cell.
		 */
		if (lc->type == LAYOUT_LEFTRIGHT) {
			lc->sx = new_size;
			layout_resize_child_cells(wp->window, lc);
			lc->sx = saved_size;
		} else if (lc->type == LAYOUT_TOPBOTTOM) {
			lc->sy = new_size;
			layout_resize_child_cells(wp->window, lc);
			lc->sy = saved_size;
		}
		resize_first = 1;

		/* Create the new cell. */
		lcnew = layout_create_cell(lc);
		size = saved_size - 1 - new_size;
		if (lc->type == LAYOUT_LEFTRIGHT)
			layout_set_size(lcnew, size, sy, 0, 0);
		else if (lc->type == LAYOUT_TOPBOTTOM)
			layout_set_size(lcnew, sx, size, 0, 0);
		if (insert_before)
			TAILQ_INSERT_HEAD(&lc->cells, lcnew, entry);
		else
			TAILQ_INSERT_TAIL(&lc->cells, lcnew, entry);
	} else {
		/*
		 * Otherwise create a new parent and insert it.
		 */

		/* Create and insert the replacement parent. */
		lcparent = layout_create_cell(lc->parent);
		layout_make_node(lcparent, type);
		layout_set_size(lcparent, sx, sy, xoff, yoff);
		if (lc->parent == NULL)
			wp->window->layout_root = lcparent;
		else
			TAILQ_REPLACE(&lc->parent->cells, lc, lcparent, entry);

		/* Insert the old cell. */
		lc->parent = lcparent;
		TAILQ_INSERT_HEAD(&lcparent->cells, lc, entry);

		/* Create the new child cell. */
		lcnew = layout_create_cell(lcparent);
		if (insert_before)
			TAILQ_INSERT_HEAD(&lcparent->cells, lcnew, entry);
		else
			TAILQ_INSERT_TAIL(&lcparent->cells, lcnew, entry);
	}
	if (insert_before) {
		lc1 = lcnew;
		lc2 = lc;
	} else {
		lc1 = lc;
		lc2 = lcnew;
	}

	/*
	 * Set new cell sizes. size1 is the size of the top/left and size2 the
	 * bottom/right.
	 */
	if (!resize_first && type == LAYOUT_LEFTRIGHT) {
		layout_set_size(lc1, size1, sy, xoff, yoff);
		layout_set_size(lc2, size2, sy, xoff + lc1->sx + 1, yoff);
	} else if (!resize_first && type == LAYOUT_TOPBOTTOM) {
		layout_set_size(lc1, sx, size1, xoff, yoff);
		layout_set_size(lc2, sx, size2, xoff, yoff + lc1->sy + 1);
	}
	if (full_size) {
		if (!resize_first)
			layout_resize_child_cells(wp->window, lc);
		layout_fix_offsets(wp->window->layout_root);
	} else
		layout_make_leaf(lc, wp);

	return (lcnew);
}

/* Destroy the cell associated with a pane. */
void
layout_close_pane(struct window_pane *wp)
{
	struct window	*w = wp->window;

	/* Remove the cell. */
	layout_destroy_cell(w, wp->layout_cell, &w->layout_root);

	/* Fix pane offsets and sizes. */
	if (w->layout_root != NULL) {
		layout_fix_offsets(w->layout_root);
		layout_fix_panes(w, w->sx, w->sy);
	}
	notify_window("window-layout-changed", w);
}
@


1.31
log
@Use the notify name string instead of going via an enum and change
existing hooks to use notifys instead.
@
text
@d1 1
a1 1
/* $OpenBSD: layout.c,v 1.30 2016/10/10 17:28:30 nicm Exp $ */
d907 1
d909 1
a909 1
			layout_set_size(lcnew, new_size, sy, 0, 0);
d911 1
a911 1
			layout_set_size(lcnew, sx, new_size, 0, 0);
@


1.30
log
@Do not allow the opposite pane to resize when dragging with the mouse
because it is not possible to keep the mouse on the border when the
minimum size is reached.
@
text
@d1 1
a1 1
/* $OpenBSD: layout.c,v 1.29 2016/09/04 17:37:06 nicm Exp $ */
d581 1
a581 1
	notify_window_layout_changed(wp->window);
d983 1
a983 1
	notify_window_layout_changed(w);
@


1.29
log
@Add support for performing a full width split (with splitw -f), rather
than splitting the current cell. From Stephen Kent.
@
text
@d1 1
a1 1
/* $OpenBSD: layout.c,v 1.28 2016/08/03 09:07:02 nicm Exp $ */
d39 1
a39 1
		    enum layout_type, int);
d535 1
a535 1
	layout_resize_pane(wp, type, change);
d540 2
a541 1
layout_resize_pane(struct window_pane *wp, enum layout_type type, int change)
d566 2
a567 1
			size = layout_resize_pane_grow(w, lc, type, needed);
d587 1
a587 1
    enum layout_type type, int needed)
d590 1
a590 1
	u_int			 size;
d605 1
a605 1
	if (lcremove == NULL) {
a612 2
		if (lcremove == NULL)
			return (0);
d614 2
@


1.28
log
@Fix minimum size when pane status line is enabled, reported by Y Petremann.
@
text
@d1 1
a1 1
/* $OpenBSD: layout.c,v 1.27 2016/04/29 15:00:48 nicm Exp $ */
d5 1
d43 7
d278 1
a278 1
	u_int			 n;
d285 1
a285 1
		n = 0;
d287 2
a288 2
			n += layout_count_cells(lcchild);
		return (n);
d663 140
d806 1
a806 1
 **/
d809 1
a809 1
    int insert_before)
d813 1
d815 8
a822 1
	lc = wp->layout_cell;
d844 30
a878 2

		/* Create the new child cell. */
d885 28
d946 3
a948 2
	/* Set new cell sizes.  size is the target size or -1 for middle split,
	 * size1 is the size of the top/left and size2 the bottom/right.
d950 1
a950 13
	switch (type) {
	case LAYOUT_LEFTRIGHT:
		if (size < 0)
			size2 = ((sx + 1) / 2) - 1;
		else if (insert_before)
			size2 = sx - size - 1;
		else
			size2 = size;
		if (size2 < PANE_MINIMUM)
			size2 = PANE_MINIMUM;
		else if (size2 > sx - 2)
			size2 = sx - 2;
		size1 = sx - 1 - size2;
d953 1
a953 13
		break;
	case LAYOUT_TOPBOTTOM:
		if (size < 0)
			size2 = ((sy + 1) / 2) - 1;
		else if (insert_before)
			size2 = sy - size - 1;
		else
			size2 = size;
		if (size2 < PANE_MINIMUM)
			size2 = PANE_MINIMUM;
		else if (size2 > sy - 2)
			size2 = sy - 2;
		size1 = sy - 1 - size2;
a955 3
		break;
	default:
		fatalx("bad layout type");
d957 6
a962 3

	/* Assign the panes. */
	layout_make_leaf(lc, wp);
@


1.27
log
@Add option to include status text in the pane borders. If
pane-border-status is set to "top" or "bottom" (rather than "off"),
every pane has a permanent top or bottom border containing the text from
pane-border-format.

Based on a diff sent long ago by Jonathan Slenders, mostly rewritten and
simplified by me.
@
text
@d1 1
a1 1
/* $OpenBSD: layout.c,v 1.26 2016/01/19 15:59:12 nicm Exp $ */
d35 5
a39 3
static int	layout_resize_pane_grow(struct layout_cell *, enum layout_type,
		    int);
static int	layout_resize_pane_shrink(struct layout_cell *,
d287 3
a289 2
u_int
layout_resize_check(struct layout_cell *lc, enum layout_type type)
d296 1
d299 1
a299 1
		else
d301 6
a306 3

		if (available > PANE_MINIMUM)
			available -= PANE_MINIMUM;
d313 1
a313 1
			available += layout_resize_check(lcchild, type);
d318 1
a318 1
			available = layout_resize_check(lcchild, type);
d333 2
a334 1
layout_resize_adjust(struct layout_cell *lc, enum layout_type type, int change)
d351 1
a351 1
			layout_resize_adjust(lcchild, type, change);
d364 1
a364 1
				layout_resize_adjust(lcchild, type, 1);
d368 2
a369 2
			if (layout_resize_check(lcchild, type) > 0) {
				layout_resize_adjust(lcchild, type, -1);
d378 2
a379 1
layout_destroy_cell(struct layout_cell *lc, struct layout_cell **lcroot)
d400 1
a400 1
		layout_resize_adjust(lcother, lcparent->type, lc->sx + 1);
d402 1
a402 1
		layout_resize_adjust(lcother, lcparent->type, lc->sy + 1);
d466 1
a466 1
	xlimit = layout_resize_check(lc, LAYOUT_LEFTRIGHT);
d476 1
a476 1
		layout_resize_adjust(lc, LAYOUT_LEFTRIGHT, xchange);
d480 1
a480 1
	ylimit = layout_resize_check(lc, LAYOUT_TOPBOTTOM);
d490 1
a490 1
		layout_resize_adjust(lc, LAYOUT_TOPBOTTOM, ychange);
d534 3
a536 2
	struct layout_cell     *lc, *lcparent;
	int			needed, size;
d557 1
a557 1
			size = layout_resize_pane_grow(lc, type, needed);
d560 1
a560 1
			size = layout_resize_pane_shrink(lc, type, needed);
d576 2
a577 2
layout_resize_pane_grow(struct layout_cell *lc, enum layout_type type,
    int needed)
d588 1
a588 1
		size = layout_resize_check(lcremove, type);
d598 1
a598 1
			size = layout_resize_check(lcremove, type);
d610 2
a611 2
	layout_resize_adjust(lcadd, type, size);
	layout_resize_adjust(lcremove, type, -size);
d617 2
a618 2
layout_resize_pane_shrink(struct layout_cell *lc, enum layout_type type,
    int needed)
d626 1
a626 1
		size = layout_resize_check(lcremove, type);
d642 2
a643 2
	layout_resize_adjust(lcadd, type, size);
	layout_resize_adjust(lcremove, type, -size);
d782 2
d785 1
a785 1
	layout_destroy_cell(wp->layout_cell, &wp->window->layout_root);
d788 3
a790 3
	if (wp->window->layout_root != NULL) {
		layout_fix_offsets(wp->window->layout_root);
		layout_fix_panes(wp->window, wp->window->sx, wp->window->sy);
d792 1
a792 1
	notify_window_layout_changed(wp->window);
@


1.26
log
@I no longer use my SourceForge address so replace it.
@
text
@d1 1
a1 1
/* $OpenBSD: layout.c,v 1.25 2015/12/11 16:37:21 nicm Exp $ */
d35 5
a39 2
int	layout_resize_pane_grow(struct layout_cell *, enum layout_type, int);
int	layout_resize_pane_shrink(struct layout_cell *, enum layout_type, int);
d169 24
d200 1
d202 2
d207 6
d216 3
d256 3
d565 1
a565 1
int
d606 1
a606 1
int
@


1.25
log
@Style nits and line wrapping of function declarations.
@
text
@d1 1
a1 1
/* $OpenBSD: layout.c,v 1.24 2015/09/18 09:55:22 nicm Exp $ */
d4 1
a4 1
 * Copyright (c) 2009 Nicholas Marriott <nicm@@users.sourceforge.net>
@


1.24
log
@-l should apply to the new not the old pane with -b, from "MadMaverick9"
on GitHub.
@
text
@d1 1
a1 1
/* $OpenBSD: layout.c,v 1.23 2015/04/19 21:34:21 nicm Exp $ */
d88 3
a90 3
	log_debug(
	    "%s:%*s%p type %u [parent %p] wp=%p [%u,%u %ux%u]", hdr, n, " ", lc,
	    lc->type, lc->parent, lc->wp, lc->xoff, lc->yoff, lc->sx, lc->sy);
d103 2
a104 2
layout_set_size(
    struct layout_cell *lc, u_int sx, u_int sy, u_int xoff, u_int yoff)
d524 2
a525 2
layout_resize_pane_grow(
    struct layout_cell *lc, enum layout_type type, int needed)
d565 2
a566 2
layout_resize_pane_shrink(
    struct layout_cell *lc, enum layout_type type, int needed)
d608 2
a609 2
layout_split_pane(
    struct window_pane *wp, enum layout_type type, int size, int insert_before)
@


1.23
log
@Rewrite of tmux mouse support which was a mess. Instead of having
options for "mouse-this" and "mouse-that", mouse events may be bound as
keys and there is one option "mouse" that turns on mouse support
entirely (set -g mouse on).

See the new MOUSE SUPPORT section of the man page for description of the
key names and new flags (-t= to specify the pane or window under mouse
as a target, and send-keys -M to pass through a mouse event).

The default builtin bindings for the mouse are:

    bind -n   MouseDown1Pane select-pane -t=; send-keys -M
    bind -n MouseDown1Status select-window -t=
    bind -n   MouseDrag1Pane copy-mode -M
    bind -n MouseDrag1Border resize-pane -M

To get the effect of turning mode-mouse off, do:

    unbind -n MouseDrag1Pane
    unbind -temacs-copy MouseDrag1Pane

The old mouse options are now gone, set-option -q may be used to
suppress warnings if mixing configuration files.
@
text
@d1 1
a1 1
/* $OpenBSD: layout.c,v 1.22 2014/05/08 06:03:30 nicm Exp $ */
d689 2
d704 2
@


1.22
log
@Both the two previous ways of navigating panes by direction have
irritating flaws:

a) The old way of always using the top or left if the choice is
ambiguous is annoying when the layout is unbalanced.

b) The new way of remembering the last used pane is annoying if the
layout is balanced and the leftmost is obvious to the user (because
clearly if we go right from the top-left in a tiled set of four we want
to end up in top-right, even if we were last using the bottom-right).

So instead, use a combination of both: if there is only one possible
pane alongside the current pane, move to it, otherwise choose the most
recently used of the choice.
@
text
@d1 1
a1 1
/* $OpenBSD: layout.c,v 1.21 2014/02/22 18:01:10 nicm Exp $ */
a519 52
}

/* Resize pane based on mouse events. */
void
layout_resize_pane_mouse(struct client *c)
{
	struct window		*w;
	struct window_pane	*wp;
	struct mouse_event	*m = &c->tty.mouse;
	int		      	 pane_border;

	w = c->session->curw->window;

	pane_border = 0;
	if (m->event & MOUSE_EVENT_DRAG && m->flags & MOUSE_RESIZE_PANE) {
		TAILQ_FOREACH(wp, &w->panes, entry) {
			if (!window_pane_visible(wp))
				continue;

			if (wp->xoff + wp->sx == m->lx &&
			    wp->yoff <= 1 + m->ly &&
			    wp->yoff + wp->sy >= m->ly) {
				layout_resize_pane(wp, LAYOUT_LEFTRIGHT,
				    m->x - m->lx);
				pane_border = 1;
			}
			if (wp->yoff + wp->sy == m->ly &&
			    wp->xoff <= 1 + m->lx &&
			    wp->xoff + wp->sx >= m->lx) {
				layout_resize_pane(wp, LAYOUT_TOPBOTTOM,
				    m->y - m->ly);
				pane_border = 1;
			}
		}
		if (pane_border)
			server_redraw_window(w);
	} else if (m->event & MOUSE_EVENT_DOWN) {
		TAILQ_FOREACH(wp, &w->panes, entry) {
			if ((wp->xoff + wp->sx == m->x &&
			    wp->yoff <= 1 + m->y &&
			    wp->yoff + wp->sy >= m->y) ||
			    (wp->yoff + wp->sy == m->y &&
			    wp->xoff <= 1 + m->x &&
			    wp->xoff + wp->sx >= m->x)) {
				pane_border = 1;
			}
		}
	}
	if (pane_border)
		m->flags |= MOUSE_RESIZE_PANE;
	else
		m->flags &= ~MOUSE_RESIZE_PANE;
@


1.21
log
@Fix crash due to uninitialized lastwp member of layout_cell, reported by
Balazs Kezes.
@
text
@d1 1
a1 1
/* $OpenBSD: layout.c,v 1.20 2013/10/10 12:08:14 nicm Exp $ */
a55 1
	lc->lastwp = NULL;
@


1.20
log
@mouse-resize-pane: Only resize on border select

The current behaviour of mouse-resize-pane is such that if the mouse
button is held down and a selection takes place within a pane, that if
the mouse pointer then hits a border edge, that pane-resize would
initiate.

This seems counter-intuitive; instead, check for a resize condition if
the border of a pane is selected, and in the case of mouse selection
within a pane, no longer resize the pane if edge of the border is hit.

By Thomas Adam.
@
text
@d1 1
a1 1
/* $OpenBSD: layout.c,v 1.19 2013/10/10 12:03:46 nicm Exp $ */
d56 1
@


1.19
log
@layout-resize-pane-mouse: Consider visible panes only

When a pane is maximized, and text is selected, we end up checking if a
pane switch is needed.  This therefore means we might end up selecting
panes which aren't visible.

By Thomas Adam.
@
text
@d1 1
a1 1
/* $OpenBSD: layout.c,v 1.18 2013/03/24 09:57:59 nicm Exp $ */
d556 1
a556 1
	} else if (~m->event & MOUSE_EVENT_UP) {
@


1.18
log
@Add resize-pane -Z to temporary zoom the active pane to occupy the full
window or unzoom (restored to the normal layout) if it already zoomed,
bound to C-b z by default. The pane is unzoomed on pretty much any
excuse whatsoever.

We considered making this a new layout but the requirements are quite
different from layouts so decided it is better as a special case. Each
current layout cell is saved, a temporary one-cell layout generated and
all except the active pane set to NULL.

Prompted by suggestions and scripts from several. Thanks to Aaron Jensen
and Thiago Padilha for testing an earlier version.
@
text
@d1 1
a1 1
/* $OpenBSD: layout.c,v 1.17 2013/03/22 10:37:39 nicm Exp $ */
d536 3
@


1.17
log
@Add resize-pane -x and -y for absolute pane size (much requested).
@
text
@d1 1
a1 1
/* $OpenBSD: layout.c,v 1.16 2013/01/17 00:11:22 nicm Exp $ */
d377 1
a377 1
layout_init(struct window *w)
d383 1
a383 1
	layout_make_leaf(lc, TAILQ_FIRST(&w->panes));
@


1.16
log
@Remove the layout undo/redo code which never really worked.
@
text
@d1 1
a1 1
/* $OpenBSD: layout.c,v 1.15 2012/10/26 14:35:42 nicm Exp $ */
d446 33
d522 1
d571 1
d612 1
@


1.15
log
@Make mouse event structure clearer by defining events (up, click, drag)
and simplifying how buttons and wheels are represented, from Ailin
Nemui. Should be no functional changes.
@
text
@d1 1
a1 1
/* $OpenBSD: layout.c,v 1.14 2012/07/10 11:53:01 nicm Exp $ */
a21 1
#include <string.h>
a747 71
}

/* Add layout to list. */
void
layout_list_add(struct window *w)
{
	struct last_layout	*ll, *ll_last;
	char			*layout;
	u_int			 limit;

	layout = layout_dump(w);

	ll_last = w->layout_list_last;
	if (ll_last != NULL && strcmp(ll_last->layout, layout) == 0) {
		free(layout);
		return;
	}

	ll = xmalloc(sizeof *ll);
	ll->layout = layout;
	if (ll_last == NULL)
		TAILQ_INSERT_TAIL(&w->layout_list, ll, entry);
	else
		TAILQ_INSERT_AFTER(&w->layout_list, ll_last, ll, entry);
	w->layout_list_size++;
	w->layout_list_last = ll;

	limit = options_get_number(&w->options, "layout-history-limit");
	while (w->layout_list_size > limit) {
		ll = TAILQ_LAST(&w->layout_list, last_layouts);
		if (ll == w->layout_list_last)
			ll = TAILQ_FIRST(&w->layout_list);

		TAILQ_REMOVE(&w->layout_list, ll, entry);
		w->layout_list_size--;

		free(ll->layout);
		free(ll);
	}
}

/* Apply next layout from list. */
const char *
layout_list_redo(struct window *w)
{
	struct last_layout	*ll, *ll_last;

	ll_last = w->layout_list_last;
	if (ll_last == NULL)
		return (NULL);
	ll = TAILQ_NEXT(ll_last, entry);
	if (ll == NULL)
		return (NULL);
	w->layout_list_last = ll;
	return (ll->layout);
}

/* Apply previous layout from list. */
const char *
layout_list_undo(struct window *w)
{
	struct last_layout	*ll, *ll_last;

	ll_last = w->layout_list_last;
	if (ll_last == NULL)
		return (NULL);
	ll = TAILQ_PREV(ll_last, last_layouts, entry);
	if (ll == NULL)
		return (NULL);
	w->layout_list_last = ll;
	return (ll->layout);
@


1.14
log
@xfree is not particularly helpful, remove it. From Thomas Adam.
@
text
@d1 1
a1 1
/* $OpenBSD: layout.c,v 1.13 2012/04/01 21:07:35 nicm Exp $ */
d491 1
a491 1
layout_resize_pane_mouse(struct client *c, struct mouse_event *mouse)
d495 1
d501 1
a501 2
	if ((c->last_mouse.b & MOUSE_BUTTON) != MOUSE_UP &&
	    (c->last_mouse.b & MOUSE_RESIZE_PANE)) {
d503 3
a505 3
			if (wp->xoff + wp->sx == c->last_mouse.x &&
			    wp->yoff <= 1 + c->last_mouse.y &&
			    wp->yoff + wp->sy >= c->last_mouse.y) {
d507 1
a507 1
				    mouse->x - c->last_mouse.x);
d510 3
a512 3
			if (wp->yoff + wp->sy == c->last_mouse.y &&
			    wp->xoff <= 1 + c->last_mouse.x &&
			    wp->xoff + wp->sx >= c->last_mouse.x) {
d514 1
a514 1
				    mouse->y - c->last_mouse.y);
d520 1
a520 2
	} else if (mouse->b != MOUSE_UP &&
	    mouse->b == (mouse->b & MOUSE_BUTTON)) {
d522 6
a527 6
			if ((wp->xoff + wp->sx == mouse->x &&
			    wp->yoff <= 1 + mouse->y &&
			    wp->yoff + wp->sy >= mouse->y) ||
			    (wp->yoff + wp->sy == mouse->y &&
			    wp->xoff <= 1 + mouse->x &&
			    wp->xoff + wp->sx >= mouse->x)) {
d533 3
a535 1
		mouse->b |= MOUSE_RESIZE_PANE;
@


1.13
log
@Fix some indentation.
@
text
@d1 1
a1 1
/* $OpenBSD: layout.c,v 1.12 2012/04/01 13:21:38 nicm Exp $ */
d81 1
a81 1
	xfree(lc);
d784 2
a785 2
		xfree(ll->layout);
		xfree(ll);
@


1.12
log
@Fix option name.
@
text
@d1 1
a1 1
/* $OpenBSD: layout.c,v 1.11 2012/04/01 13:18:38 nicm Exp $ */
d501 1
a501 1
		(c->last_mouse.b & MOUSE_RESIZE_PANE)) {
d504 2
a505 2
				wp->yoff <= 1 + c->last_mouse.y &&
				wp->yoff + wp->sy >= c->last_mouse.y) {
d511 2
a512 2
				wp->xoff <= 1 + c->last_mouse.x &&
				wp->xoff + wp->sx >= c->last_mouse.x) {
d521 1
a521 1
			   mouse->b == (mouse->b & MOUSE_BUTTON)) {
d524 5
a528 5
				 wp->yoff <= 1 + mouse->y &&
				 wp->yoff + wp->sy >= mouse->y) ||
				(wp->yoff + wp->sy == mouse->y &&
				 wp->xoff <= 1 + mouse->x &&
				 wp->xoff + wp->sx >= mouse->x)) {
@


1.11
log
@Add a layout history which can be stepped through with select-layout -u
and -U commands (bound to 'u' and 'U' by default).
@
text
@d1 1
a1 1
/* $OpenBSD: layout.c,v 1.10 2012/03/17 22:35:09 nicm Exp $ */
d775 1
a775 1
	limit = options_get_number(&w->options, "layout-history");
@


1.10
log
@Add notify hooks for various events, the functions are currently empty
stubs but will be filled in for control mode later. From George Nachman.
@
text
@d1 1
a1 1
/* $OpenBSD: layout.c,v 1.9 2012/03/03 08:31:18 nicm Exp $ */
d22 1
d748 71
@


1.9
log
@Add move-pane command (like join-pane but allows the same window). Also
-b flag to join-pane and move-pane to place the pane to the left or
above. From George Nachman.
@
text
@d1 1
a1 1
/* $OpenBSD: layout.c,v 1.8 2012/01/29 09:37:02 nicm Exp $ */
d486 1
d746 1
@


1.8
log
@Add an option to move the status line to the top of the screen,
requested by many.
@
text
@d1 1
a1 1
/* $OpenBSD: layout.c,v 1.7 2011/05/08 20:34:12 nicm Exp $ */
d619 2
a620 1
layout_split_pane(struct window_pane *wp, enum layout_type type, int size)
d622 1
a622 1
	struct layout_cell     *lc, *lcparent, *lcnew;
d654 6
a659 2
		lcnew = layout_create_cell(lc->parent);
		TAILQ_INSERT_AFTER(&lc->parent->cells, lc, lcnew, entry);
d680 11
a690 1
		TAILQ_INSERT_TAIL(&lcparent->cells, lcnew, entry);
d707 2
a708 2
		layout_set_size(lc, size1, sy, xoff, yoff);
		layout_set_size(lcnew, size2, sy, xoff + lc->sx + 1, yoff);
d720 2
a721 2
		layout_set_size(lc, sx, size1, xoff, yoff);
		layout_set_size(lcnew, sx, size2, xoff, yoff + lc->sy + 1);
@


1.7
log
@Add a new option, mouse-resize-pane. When on, panes may be resized by
dragging their borders. From hsim at gmx.li.
@
text
@d1 1
a1 1
/* $OpenBSD: layout.c,v 1.6 2010/06/29 03:30:14 nicm Exp $ */
d505 1
a505 1
								   mouse->x - c->last_mouse.x);
d512 1
a512 1
								   mouse->y - c->last_mouse.y);
@


1.6
log
@Custom layouts. list-windows command displays the layout as a string (such as
"bb62,159x48,0,0{79x48,0,0,79x48,80,0}") and it can be applied to another
window (with the same number of panes or fewer) using select-layout.
@
text
@d1 1
a1 1
/* $OpenBSD: layout.c,v 1.5 2010/01/07 20:52:18 nicm Exp $ */
d486 47
@


1.5
log
@New command, join-pane, to split and move an existing pane into the space (like
splitw then movep, or the reverse of breakp).
@
text
@d1 1
a1 1
/* $OpenBSD: layout.c,v 1.4 2009/12/03 22:50:10 nicm Exp $ */
d221 21
d326 50
d671 1
a671 1
/* Destroy the layout associated with a pane and redistribute the space. */
d675 2
a676 1
	struct layout_cell     *lc, *lcother, *lcparent;
d678 4
a681 11
	lc = wp->layout_cell;
	lcparent = lc->parent;

	/*
	 * If no parent, this is the last pane so window close is imminent and
	 * there is no need to resize anything.
	 */
	if (lcparent == NULL) {
		layout_free_cell(lc);
		wp->window->layout_root = NULL;
		return;
a682 36

	/* Merge the space into the previous or next cell. */
	if (lc == TAILQ_FIRST(&lcparent->cells))
		lcother = TAILQ_NEXT(lc, entry);
	else
		lcother = TAILQ_PREV(lc, layout_cells, entry);
	if (lcparent->type == LAYOUT_LEFTRIGHT)
		layout_resize_adjust(lcother, lcparent->type, lc->sx + 1);
	else
		layout_resize_adjust(lcother, lcparent->type, lc->sy + 1);

	/* Remove this from the parent's list. */
	TAILQ_REMOVE(&lcparent->cells, lc, entry);
	layout_free_cell(lc);

	/*
	 * If the parent now has one cell, remove the parent from the tree and
	 * replace it by that cell.
	 */
	lc = TAILQ_FIRST(&lcparent->cells);
	if (TAILQ_NEXT(lc, entry) == NULL) {
		TAILQ_REMOVE(&lcparent->cells, lc, entry);

		lc->parent = lcparent->parent;
		if (lc->parent == NULL) {
			lc->xoff = 0; lc->yoff = 0;
			wp->window->layout_root = lc;
		} else
			TAILQ_REPLACE(&lc->parent->cells, lcparent, lc, entry);

		layout_free_cell(lcparent);
	}

	/* Fix pane offsets and sizes. */
	layout_fix_offsets(wp->window->layout_root);
	layout_fix_panes(wp->window, wp->window->sx, wp->window->sy);
a683 1

@


1.4
log
@Massive spaces->tabs and trailing whitespace cleanup, hopefully for the last
time now I've configured emacs to make them displayed in really annoying
colours...
@
text
@d1 1
a1 1
/* $OpenBSD: layout.c,v 1.3 2009/07/19 13:21:40 nicm Exp $ */
d488 14
a501 4
/* Split a pane into two. size is a hint, or -1 for default half/half split. */
int
layout_split_pane(struct window_pane *wp,
    enum layout_type type, int size, struct window_pane *new_wp)
d518 1
a518 1
			return (-1);
d522 1
a522 1
			return (-1);
a595 4
	layout_make_leaf(lcnew, new_wp);

	/* Fix pane offsets and sizes. */
	layout_fix_panes(wp->window, wp->window->sx, wp->window->sy);
d597 1
a597 1
	return (0);
@


1.3
log
@Improved layout code.

Each window now has a tree of layout cells associated with it. In this tree,
each node is either a horizontal or vertical cell containing a list of other
cells running from left-to-right or top-to-bottom, or a leaf cell which is
associated with a pane.

The major functional changes are:

- panes may now be split arbitrarily both horizontally (splitw -h, C-b %) and
  vertically (splitw -v, C-b ");
- panes may be resized both horizontally and vertically (resizep -L/-R/-U/-D,
  bound to C-b left/right/up/down and C-b M-left/right/up/down);
- layouts are now applied and then may be modified by resizing or splitting
  panes, rather than being fixed and reapplied when the window is resized or
  panes are added;
- manual-vertical layout is no longer necessary, and active-only layout is gone
  (but may return in future);
- the main-pane layouts now reduce the size of the main pane to fit all panes
  if possible.

Thanks to all who tested.
@
text
@d1 1
a1 1
/* $OpenBSD: layout.c,v 1.1 2009/06/01 22:58:49 nicm Exp $ */
d48 1
a48 1
	
d51 1
a51 1
	
d54 1
a54 1
	
d204 2
a205 2
		
		/* 
d234 1
a234 1
		
d272 1
a272 1
	
d284 2
a285 2
	/* 
	 * Child cell runs in the same direction. Adjust each child equally 
d330 1
a330 1
	/* 
d333 1
a333 1
	 * 
d369 1
a369 1
	
d411 1
a411 1
	
d426 1
a426 1
			
d433 1
a433 1
		lcremove = TAILQ_NEXT(lcremove, entry);	
d517 1
a517 1
	
d531 1
a531 1
		
d540 1
a540 1
		
d544 1
a544 1
		
d557 1
a557 1
 		else
d603 1
a603 1
	/* 
d626 2
a627 2
	
	/* 
@


1.2
log
@Get rid of the PANE_HIDDEN flag in favour of a function, and moving the
decision for whether or not a pane should be drawn out of the layout code and
into the redraw code.

This is needed for the new layout design, getting it in now to make that easier
to work on.
@
text
@d21 1
a21 1
#include <string.h>
d26 3
a28 2
 * Each layout has two functions, _refresh to relayout the panes and _resize to
 * resize a single pane.
d30 3
a32 3
 * Second argument (int) to _refresh is 1 if the only change has been that the
 * active pane has changed. If 0 then panes, active pane or both may have
 * changed.
d35 2
a36 18
void	layout_active_only_refresh(struct window *, int);
void	layout_even_h_refresh(struct window *, int);
void	layout_even_v_refresh(struct window *, int);
void	layout_main_h_refresh(struct window *, int);
void	layout_main_v_refresh(struct window *, int);

const struct {
	const char     *name;
	void		(*refresh)(struct window *, int);
	void		(*resize)(struct window_pane *, int);
} layouts[] = {
	{ "manual-vertical", layout_manual_v_refresh, layout_manual_v_resize },
	{ "active-only", layout_active_only_refresh, NULL },
	{ "even-horizontal", layout_even_h_refresh, NULL },
	{ "even-vertical", layout_even_v_refresh, NULL },
	{ "main-horizontal", layout_main_h_refresh, NULL },
	{ "main-vertical", layout_main_v_refresh, NULL },
};
d38 2
a39 2
const char *
layout_name(struct window *w)
d41 17
a57 1
	return (layouts[w->layout].name);
d60 2
a61 2
int
layout_lookup(const char *name)
d63 1
a63 2
	u_int	i;
	int	matched = -1;
d65 7
a71 5
	for (i = 0; i < nitems(layouts); i++) {
		if (strncmp(layouts[i].name, name, strlen(name)) == 0) {
			if (matched != -1)	/* ambiguous */
				return (-1);
			matched = i;
d73 5
d80 1
a80 1
	return (matched);
d83 2
a84 2
int
layout_select(struct window *w, u_int layout)
d86 1
a86 3
	if (layout > nitems(layouts) - 1 || layout == w->layout)
		return (-1);
	w->layout = layout;
d88 12
a99 2
	layout_refresh(w, 0);
	return (0);
d103 2
a104 1
layout_next(struct window *w)
d106 5
a110 4
	w->layout++;
	if (w->layout > nitems(layouts) - 1)
		w->layout = 0;
	layout_refresh(w, 0);
d114 1
a114 1
layout_previous(struct window *w)
d116 6
a121 5
	if (w->layout == 0)
		w->layout = nitems(layouts) - 1;
	else
		w->layout--;
	layout_refresh(w, 0);
d125 1
a125 1
layout_refresh(struct window *w, int active_only)
d127 9
a135 2
	layouts[w->layout].refresh(w, active_only);
	server_redraw_window(w);
d138 3
a140 2
int
layout_resize(struct window_pane *wp, int adjust)
d142 2
a143 1
	struct window	*w = wp->window;
d145 19
a163 4
	if (layouts[w->layout].resize == NULL)
		return (-1);
	layouts[w->layout].resize(wp, adjust);
	return (0);
d166 1
d168 1
a168 1
layout_active_only_refresh(struct window *w, unused int active_only)
d171 2
a172 1
	u_int			 xoff;
a173 1
	xoff = w->sx;
d175 36
a210 3
		/* Put the active pane on screen and the rest to the right. */
		if (wp == w->active)
			wp->xoff = 0;
d212 3
a214 2
			wp->xoff = xoff;
			xoff += w->sx;
d216 2
a217 2
		wp->yoff = 0;
		window_pane_resize(wp, w->sx, w->sy);
d221 3
a223 2
void
layout_even_h_refresh(struct window *w, int active_only)
d225 2
a226 2
	struct window_pane	*wp;
	u_int			 i, n, width, xoff;
d228 25
a252 7
	if (active_only)
		return;

	/* If the screen is too small, show active only. */
	if (w->sx < PANE_MINIMUM || w->sy < PANE_MINIMUM) {
		layout_active_only_refresh(w, active_only);
		return;
d255 2
a256 4
	/* Get number of panes. */
	n = window_count_panes(w);
	if (n == 0)
		return;
d258 8
a265 6
	/* How many can we fit? */
	if (w->sx / n < PANE_MINIMUM) {
		width = PANE_MINIMUM;
		n = UINT_MAX;
	} else
		width = w->sx / n;
d267 15
a281 12
	/* Fit the panes. */
	i = xoff = 0;
	TAILQ_FOREACH(wp, &w->panes, entry) {
		wp->xoff = xoff;
		wp->yoff = 0;
		if (i != n - 1)
 			window_pane_resize(wp, width - 1, w->sy);
		else
 			window_pane_resize(wp, width, w->sy);

		i++;
		xoff += width;
d284 18
a301 4
	/* Any space left? */
	while (xoff++ < w->sx) {
		wp = TAILQ_LAST(&w->panes, window_panes);
		window_pane_resize(wp, wp->sx + 1, wp->sy);
d306 1
a306 1
layout_even_v_refresh(struct window *w, int active_only)
d308 1
a308 2
	struct window_pane	*wp;
	u_int			 i, n, height, yoff;
d310 3
a312 2
	if (active_only)
		return;
d314 2
a315 5
	/* If the screen is too small, show active only. */
	if (w->sx < PANE_MINIMUM || w->sy < PANE_MINIMUM) {
		layout_active_only_refresh(w, active_only);
		return;
	}
d317 5
a321 4
	/* Get number of panes. */
	n = window_count_panes(w);
	if (n == 0)
		return;
d323 6
a328 6
	/* How many can we fit? */
	if (w->sy / n < PANE_MINIMUM) {
		height = PANE_MINIMUM;
		n = UINT_MAX;
	} else
		height = w->sy / n;
d330 20
a349 7
	/* Fit the panes. */
	i = yoff = 0;
	TAILQ_FOREACH(wp, &w->panes, entry) {
		wp->xoff = 0;
		wp->yoff = yoff;
		if (i != n - 1)
 			window_pane_resize(wp, w->sx, height - 1);
d351 1
a351 4
 			window_pane_resize(wp, w->sx, height);

		i++;
		yoff += height;
d353 2
d356 10
a365 4
	/* Any space left? */
	while (yoff++ < w->sy) {
		wp = TAILQ_LAST(&w->panes, window_panes);
		window_pane_resize(wp, wp->sx, wp->sy + 1);
d367 6
d375 1
d377 1
a377 1
layout_main_v_refresh(struct window *w, int active_only)
d379 2
a380 2
	struct window_pane	*wp;
	u_int			 i, n, mainwidth, height, yoff;
d382 1
a382 2
	if (active_only)
		return;
d384 23
a406 4
	/* Get number of panes. */
	n = window_count_panes(w);
	if (n == 0)
		return;
d408 8
a415 2
	/* Get the main pane width and add one for separator line. */
	mainwidth = options_get_number(&w->options, "main-pane-width") + 1;
d417 17
a433 5
	/* Need >1 pane and minimum columns; if fewer, display active only. */
	if (n == 1 ||
	    w->sx < mainwidth + PANE_MINIMUM || w->sy < PANE_MINIMUM) {
		layout_active_only_refresh(w, active_only);
		return;
a434 1
	n--;
d436 8
a443 15
	/* How many can we fit, not including first? */
	if (w->sy / n < PANE_MINIMUM) {
		height = PANE_MINIMUM;
		n = w->sy / PANE_MINIMUM;
	} else
		height = w->sy / n;

	/* Fit the panes. */
	i = yoff = 0;
	TAILQ_FOREACH(wp, &w->panes, entry) {
		if (wp == TAILQ_FIRST(&w->panes)) {
			wp->xoff = 0;
			wp->yoff = 0;
			window_pane_resize(wp, mainwidth - 1, w->sy);
			continue;
d445 3
d449 7
a455 6
		wp->xoff = mainwidth;
		wp->yoff = yoff;
		if (i != n - 1)
 			window_pane_resize(wp, w->sx - mainwidth, height - 1);
		else
 			window_pane_resize(wp, w->sx - mainwidth, height);
d457 6
a462 3
		i++;
		yoff += height;
	}
d464 5
a468 6
	/* Any space left? */
	while (yoff++ < w->sy) {
		wp = TAILQ_LAST(&w->panes, window_panes);
		while (wp != NULL && wp == TAILQ_FIRST(&w->panes))
			wp = TAILQ_PREV(wp, window_panes, entry);
		if (wp == NULL)
d470 16
a485 2
		window_pane_resize(wp, wp->sx, wp->sy + 1);
	}
d488 4
a491 2
void
layout_main_h_refresh(struct window *w, int active_only)
d493 2
a494 2
	struct window_pane	*wp;
	u_int			 i, n, mainheight, width, xoff;
d496 1
a496 2
	if (active_only)
		return;
d498 89
a586 4
	/* Get number of panes. */
	n = window_count_panes(w);
	if (n == 0)
		return;
d588 2
a589 2
	/* Get the main pane height and add one for separator line. */
	mainheight = options_get_number(&w->options, "main-pane-height") + 1;
d591 2
a592 7
	/* Need >1 pane and minimum rows; if fewer, display active only. */
	if (n == 1 ||
	    w->sy < mainheight + PANE_MINIMUM || w->sx < PANE_MINIMUM) {
		layout_active_only_refresh(w, active_only);
		return;
	}
	n--;
d594 5
a598 6
	/* How many can we fit, not including first? */
	if (w->sx / n < PANE_MINIMUM) {
		width = PANE_MINIMUM;
		n = w->sx / PANE_MINIMUM;
	} else
		width = w->sx / n;
d600 2
a601 9
	/* Fit the panes. */
	i = xoff = 0;
	TAILQ_FOREACH(wp, &w->panes, entry) {
		if (wp == TAILQ_FIRST(&w->panes)) {
			wp->xoff = 0;
			wp->yoff = 0;
			window_pane_resize(wp, w->sx, mainheight - 1);
			continue;
		}
d603 9
a611 6
		wp->xoff = xoff;
		wp->yoff = mainheight;
		if (i != n - 1)
 			window_pane_resize(wp, width - 1, w->sy - mainheight);
		else
 			window_pane_resize(wp, width - 1, w->sy - mainheight);
d613 9
a621 3
		i++;
		xoff += width;
	}
d623 25
a647 9
	/* Any space left? */
	while (xoff++ < w->sx + 1) {
		wp = TAILQ_LAST(&w->panes, window_panes);
		while (wp != NULL && wp == TAILQ_FIRST(&w->panes))
			wp = TAILQ_PREV(wp, window_panes, entry);
		if (wp == NULL)
			break;
		window_pane_resize(wp, wp->sx + 1, wp->sy);
	}
d649 1
@


1.1
log
@Import tmux, a terminal multiplexor allowing (among other things) a single
terminal to be switched between several different windows and programs
displayed on one terminal be detached from one terminal and moved to another.

ok deraadt pirofti
@
text
@d1 1
a1 1
/* $OpenBSD$ */
d128 1
d130 1
d132 9
a140 6
		if (wp == w->active) {
			wp->flags &= ~PANE_HIDDEN;
			wp->xoff = wp->yoff = 0;
			window_pane_resize(wp, w->sx, w->sy);
		} else
			wp->flags |= PANE_HIDDEN;
d153 6
d167 1
a167 1
		n = w->sx / PANE_MINIMUM;
a173 6
		if (i > n) {
			wp->flags |= PANE_HIDDEN;
			continue;
		}
		wp->flags &= ~PANE_HIDDEN;

d201 6
d215 1
a215 1
		n = w->sy / PANE_MINIMUM;
a221 6
		if (i > n) {
			wp->flags |= PANE_HIDDEN;
			continue;
		}
		wp->flags &= ~PANE_HIDDEN;

d258 2
a259 1
	if (n == 1 || w->sx < mainwidth + PANE_MINIMUM) {
a278 1
			wp->flags &= ~PANE_HIDDEN;
a281 6
		if (i > n) {
			wp->flags |= PANE_HIDDEN;
			continue;
		}
		wp->flags &= ~PANE_HIDDEN;

d322 2
a323 1
	if (n == 1 || w->sy < mainheight + PANE_MINIMUM) {
a342 6
			wp->flags &= ~PANE_HIDDEN;
			continue;
		}

		if (i > n) {
			wp->flags |= PANE_HIDDEN;
a344 1
		wp->flags &= ~PANE_HIDDEN;
@

