head	1.43;
access;
symbols
	OPENBSD_6_1:1.42.0.4
	OPENBSD_6_1_BASE:1.42
	OPENBSD_6_0:1.32.0.2
	OPENBSD_6_0_BASE:1.32
	OPENBSD_5_9:1.31.0.2
	OPENBSD_5_9_BASE:1.31
	OPENBSD_5_8:1.10.0.4
	OPENBSD_5_8_BASE:1.10;
locks; strict;
comment	@ * @;


1.43
date	2017.04.05.10.49.46;	author nicm;	state Exp;
branches;
next	1.42;
commitid	1mjoRYvghWl25dW0;

1.42
date	2017.03.13.10.53.32;	author nicm;	state Exp;
branches;
next	1.41;
commitid	mSBoFdc6RNT6wc48;

1.41
date	2017.03.11.15.16.08;	author nicm;	state Exp;
branches;
next	1.40;
commitid	elvVIJV7Kyw8XbIL;

1.40
date	2016.11.16.00.24.03;	author nicm;	state Exp;
branches;
next	1.39;
commitid	ZQAQdE9Fy4gBpQvj;

1.39
date	2016.10.18.12.51.26;	author nicm;	state Exp;
branches;
next	1.38;
commitid	hBZfugPDlIuJ2Yqo;

1.38
date	2016.10.16.22.06.40;	author nicm;	state Exp;
branches;
next	1.37;
commitid	j0FZs70gSPCmpqWI;

1.37
date	2016.10.16.19.04.05;	author nicm;	state Exp;
branches;
next	1.36;
commitid	pxm6osuE99zELpkU;

1.36
date	2016.10.16.17.55.14;	author nicm;	state Exp;
branches;
next	1.35;
commitid	1xIYFpLYkPIXNEvU;

1.35
date	2016.10.15.00.09.30;	author nicm;	state Exp;
branches;
next	1.34;
commitid	X2XXRCKiqkzI3Ni0;

1.34
date	2016.10.13.10.01.49;	author nicm;	state Exp;
branches;
next	1.33;
commitid	AFoah05fh4b2e28V;

1.33
date	2016.10.10.21.51.39;	author nicm;	state Exp;
branches;
next	1.32;
commitid	TaZ3kOtGiWwKofka;

1.32
date	2016.03.03.14.14.46;	author nicm;	state Exp;
branches;
next	1.31;
commitid	rhRImjgSdM3WUy9U;

1.31
date	2016.01.19.16.01.30;	author nicm;	state Exp;
branches;
next	1.30;
commitid	gdaGX7HuLjiMTGV0;

1.30
date	2016.01.19.15.59.12;	author nicm;	state Exp;
branches;
next	1.29;
commitid	P3qmSOx6KrDBsb0c;

1.29
date	2016.01.16.00.36.53;	author nicm;	state Exp;
branches;
next	1.28;
commitid	416B5CZCT2xuRFOv;

1.28
date	2015.12.17.23.08.22;	author nicm;	state Exp;
branches;
next	1.27;
commitid	tULDPNG9fVfuJMNj;

1.27
date	2015.12.16.21.50.37;	author nicm;	state Exp;
branches;
next	1.26;
commitid	Bam1GajuDZzmKjyE;

1.26
date	2015.12.15.14.32.55;	author nicm;	state Exp;
branches;
next	1.25;
commitid	qnzhdpYqhUvOfqsj;

1.25
date	2015.12.15.00.45.02;	author nicm;	state Exp;
branches;
next	1.24;
commitid	2izKrdKD7SBTTeRr;

1.24
date	2015.12.15.00.11.24;	author nicm;	state Exp;
branches;
next	1.23;
commitid	Va8fPQXBKEe5bUey;

1.23
date	2015.12.15.00.00.01;	author nicm;	state Exp;
branches;
next	1.22;
commitid	yMmY7FLVcToE15ZM;

1.22
date	2015.12.14.23.30.58;	author nicm;	state Exp;
branches;
next	1.21;
commitid	Gp2loryMvVho4B6E;

1.21
date	2015.12.13.17.55.14;	author nicm;	state Exp;
branches;
next	1.20;
commitid	Fyn4vblJtlp30z7Q;

1.20
date	2015.12.13.16.44.35;	author nicm;	state Exp;
branches;
next	1.19;
commitid	CpoKtPSIEn27BKfz;

1.19
date	2015.12.13.15.32.12;	author nicm;	state Exp;
branches;
next	1.18;
commitid	aaVCH5jHZVqoxGFq;

1.18
date	2015.12.13.15.00.37;	author nicm;	state Exp;
branches;
next	1.17;
commitid	6wGIbv1dZAryRJ3h;

1.17
date	2015.10.28.09.51.55;	author nicm;	state Exp;
branches;
next	1.16;
commitid	eGVGKzVVYKHFvkn4;

1.16
date	2015.10.27.13.23.24;	author nicm;	state Exp;
branches;
next	1.15;
commitid	g6GdEJXfBNprXHEK;

1.15
date	2015.10.23.16.29.07;	author nicm;	state Exp;
branches;
next	1.14;
commitid	JbQgJmki1PJ0qxEt;

1.14
date	2015.10.22.11.23.00;	author nicm;	state Exp;
branches;
next	1.13;
commitid	vohpt64dxJLwL9xf;

1.13
date	2015.09.14.13.22.02;	author nicm;	state Exp;
branches;
next	1.12;
commitid	kxByHmNsW2wTQbKK;

1.12
date	2015.08.13.15.02.23;	author nicm;	state Exp;
branches;
next	1.11;
commitid	seHx7PqD0HLBi7an;

1.11
date	2015.08.12.08.55.20;	author nicm;	state Exp;
branches;
next	1.10;
commitid	HUSsY4NbLebDVceS;

1.10
date	2015.06.05.09.09.08;	author nicm;	state Exp;
branches;
next	1.9;
commitid	55l1YjvEJoakL5IE;

1.9
date	2015.06.05.08.14.16;	author nicm;	state Exp;
branches;
next	1.8;
commitid	FezlkQJJMDFfG1I5;

1.8
date	2015.06.04.11.43.51;	author nicm;	state Exp;
branches;
next	1.7;
commitid	rAvOUA4CI6VK3gQ6;

1.7
date	2015.05.07.11.42.56;	author nicm;	state Exp;
branches;
next	1.6;
commitid	aHjVLgOHz1Tie9FQ;

1.6
date	2015.04.28.12.09.24;	author nicm;	state Exp;
branches;
next	1.5;
commitid	TSWSz7OdNU4RK1mM;

1.5
date	2015.04.28.11.57.20;	author nicm;	state Exp;
branches;
next	1.4;
commitid	GLwn0zx70t4afH76;

1.4
date	2015.04.28.11.33.17;	author nicm;	state Exp;
branches;
next	1.3;
commitid	3DppsOIbzCswrl9A;

1.3
date	2015.04.27.22.58.58;	author nicm;	state Exp;
branches;
next	1.2;
commitid	CJl5paY8uXxECFrf;

1.2
date	2015.04.27.22.42.10;	author nicm;	state Exp;
branches;
next	1.1;
commitid	6ZVVmrTFqj5k9PGs;

1.1
date	2015.04.27.16.25.57;	author nicm;	state Exp;
branches;
next	;
commitid	0WBWxxZyxaAFVhmn;


desc
@@


1.43
log
@Give each client a name. This defaults to the tty name as before but
falls back to an alternative if the tty name is not available. This is
clearer than overloading the client ttyname member and allows us to
remove the path stored in the tty struct, it should always be the same
as the client.
@
text
@/* $OpenBSD: cmd-find.c,v 1.42 2017/03/13 10:53:32 nicm Exp $ */

/*
 * Copyright (c) 2015 Nicholas Marriott <nicholas.marriott@@gmail.com>
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF MIND, USE, DATA OR PROFITS, WHETHER
 * IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING
 * OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */

#include <sys/types.h>

#include <fnmatch.h>
#include <limits.h>
#include <stdlib.h>
#include <string.h>
#include <paths.h>
#include <unistd.h>

#include "tmux.h"

static struct session *cmd_find_try_TMUX(struct client *, struct window *);
static int	cmd_find_client_better(struct client *, struct client *);
static struct client *cmd_find_best_client(struct client **, u_int);
static int	cmd_find_session_better(struct session *, struct session *,
		    int);
static struct session *cmd_find_best_session(struct session **, u_int, int);
static int	cmd_find_best_session_with_window(struct cmd_find_state *);
static int	cmd_find_best_winlink_with_window(struct cmd_find_state *);

static int	cmd_find_current_session_with_client(struct cmd_find_state *);
static int	cmd_find_current_session(struct cmd_find_state *);
static struct client *cmd_find_current_client(struct cmdq_item *);

static const char *cmd_find_map_table(const char *[][2], const char *);

static int	cmd_find_get_session(struct cmd_find_state *, const char *);
static int	cmd_find_get_window(struct cmd_find_state *, const char *);
static int	cmd_find_get_window_with_session(struct cmd_find_state *,
		    const char *);
static int	cmd_find_get_pane(struct cmd_find_state *, const char *);
static int	cmd_find_get_pane_with_session(struct cmd_find_state *,
		    const char *);
static int	cmd_find_get_pane_with_window(struct cmd_find_state *,
		    const char *);

static const char *cmd_find_session_table[][2] = {
	{ NULL, NULL }
};
static const char *cmd_find_window_table[][2] = {
	{ "{start}", "^" },
	{ "{last}", "!" },
	{ "{end}", "$" },
	{ "{next}", "+" },
	{ "{previous}", "-" },
	{ NULL, NULL }
};
static const char *cmd_find_pane_table[][2] = {
	{ "{last}", "!" },
	{ "{next}", "+" },
	{ "{previous}", "-" },
	{ "{top}", "top" },
	{ "{bottom}", "bottom" },
	{ "{left}", "left" },
	{ "{right}", "right" },
	{ "{top-left}", "top-left" },
	{ "{top-right}", "top-right" },
	{ "{bottom-left}", "bottom-left" },
	{ "{bottom-right}", "bottom-right" },
	{ "{up-of}", "{up-of}" },
	{ "{down-of}", "{down-of}" },
	{ "{left-of}", "{left-of}" },
	{ "{right-of}", "{right-of}" },
	{ NULL, NULL }
};

/* Get session from TMUX if present. */
static struct session *
cmd_find_try_TMUX(struct client *c, struct window *w)
{
	struct environ_entry	*envent;
	char			 tmp[256];
	long long		 pid;
	u_int			 session;
	struct session		*s;

	envent = environ_find(c->environ, "TMUX");
	if (envent == NULL)
		return (NULL);

	if (sscanf(envent->value, "%255[^,],%lld,%d", tmp, &pid, &session) != 3)
		return (NULL);
	if (pid != getpid())
		return (NULL);
	log_debug("client %p TMUX is %s (session @@%u)", c, envent->value,
	    session);

	s = session_find_by_id(session);
	if (s == NULL || (w != NULL && !session_has(s, w)))
		return (NULL);
	return (s);
}

/* Is this client better? */
static int
cmd_find_client_better(struct client *c, struct client *than)
{
	if (than == NULL)
		return (1);
	return (timercmp(&c->activity_time, &than->activity_time, >));
}

/* Find best client from a list, or all if list is NULL. */
static struct client *
cmd_find_best_client(struct client **clist, u_int csize)
{
	struct client	*c_loop, *c;
	u_int		 i;

	c = NULL;
	if (clist != NULL) {
		for (i = 0; i < csize; i++) {
			if (clist[i]->session == NULL)
				continue;
			if (cmd_find_client_better(clist[i], c))
				c = clist[i];
		}
	} else {
		TAILQ_FOREACH(c_loop, &clients, entry) {
			if (c_loop->session == NULL)
				continue;
			if (cmd_find_client_better(c_loop, c))
				c = c_loop;
		}
	}
	return (c);
}

/* Is this session better? */
static int
cmd_find_session_better(struct session *s, struct session *than, int flags)
{
	int	attached;

	if (than == NULL)
		return (1);
	if (flags & CMD_FIND_PREFER_UNATTACHED) {
		attached = (~than->flags & SESSION_UNATTACHED);
		if (attached && (s->flags & SESSION_UNATTACHED))
			return (1);
		else if (!attached && (~s->flags & SESSION_UNATTACHED))
			return (0);
	}
	return (timercmp(&s->activity_time, &than->activity_time, >));
}

/* Find best session from a list, or all if list is NULL. */
static struct session *
cmd_find_best_session(struct session **slist, u_int ssize, int flags)
{
	struct session	 *s_loop, *s;
	u_int		  i;

	s = NULL;
	if (slist != NULL) {
		for (i = 0; i < ssize; i++) {
			if (cmd_find_session_better(slist[i], s, flags))
				s = slist[i];
		}
	} else {
		RB_FOREACH(s_loop, sessions, &sessions) {
			if (cmd_find_session_better(s_loop, s, flags))
				s = s_loop;
		}
	}
	return (s);
}

/* Find best session and winlink for window. */
static int
cmd_find_best_session_with_window(struct cmd_find_state *fs)
{
	struct session	**slist = NULL;
	u_int		  ssize;
	struct session	 *s;

	if (fs->item != NULL && fs->item->client != NULL) {
		fs->s = cmd_find_try_TMUX(fs->item->client, fs->w);
		if (fs->s != NULL)
			return (cmd_find_best_winlink_with_window(fs));
	}

	ssize = 0;
	RB_FOREACH(s, sessions, &sessions) {
		if (!session_has(s, fs->w))
			continue;
		slist = xreallocarray(slist, ssize + 1, sizeof *slist);
		slist[ssize++] = s;
	}
	if (ssize == 0)
		goto fail;
	fs->s = cmd_find_best_session(slist, ssize, fs->flags);
	if (fs->s == NULL)
		goto fail;
	free(slist);
	return (cmd_find_best_winlink_with_window(fs));

fail:
	free(slist);
	return (-1);
}

/*
 * Find the best winlink for a window (the current if it contains the pane,
 * otherwise the first).
 */
static int
cmd_find_best_winlink_with_window(struct cmd_find_state *fs)
{
	struct winlink	 *wl, *wl_loop;

	wl = NULL;
	if (fs->s->curw != NULL && fs->s->curw->window == fs->w)
		wl = fs->s->curw;
	else {
		RB_FOREACH(wl_loop, winlinks, &fs->s->windows) {
			if (wl_loop->window == fs->w) {
				wl = wl_loop;
				break;
			}
		}
	}
	if (wl == NULL)
		return (-1);
	fs->wl = wl;
	fs->idx = fs->wl->idx;
	return (0);
}

/* Find current session when we have an unattached client. */
static int
cmd_find_current_session_with_client(struct cmd_find_state *fs)
{
	struct window_pane	*wp;

	/*
	 * If this is running in a pane, we can use that to limit the list of
	 * sessions to those containing that pane (we still use the current
	 * window in the best session).
	 */
	if (fs->item != NULL) {
		RB_FOREACH(wp, window_pane_tree, &all_window_panes) {
			if (strcmp(wp->tty, fs->item->client->ttyname) == 0)
				break;
		}
	} else
		wp = NULL;

	/* Not running in a pane. We know nothing. Find the best session. */
	if (wp == NULL)
		goto unknown_pane;

	/* Find the best session and winlink containing this pane. */
	fs->w = wp->window;
	if (cmd_find_best_session_with_window(fs) != 0) {
		if (wp != NULL) {
			/*
			 * The window may have been destroyed but the pane
			 * still on all_window_panes due to something else
			 * holding a reference.
			 */
			goto unknown_pane;
		}
		return (-1);
	}

	/* Use the current window and pane from this session. */
	fs->wl = fs->s->curw;
	fs->idx = fs->wl->idx;
	fs->w = fs->wl->window;
	fs->wp = fs->w->active;

	return (0);

unknown_pane:
	fs->s = NULL;
	if (fs->item != NULL)
		fs->s = cmd_find_try_TMUX(fs->item->client, NULL);
	if (fs->s == NULL)
		fs->s = cmd_find_best_session(NULL, 0, fs->flags);
	if (fs->s == NULL)
		return (-1);
	fs->wl = fs->s->curw;
	fs->idx = fs->wl->idx;
	fs->w = fs->wl->window;
	fs->wp = fs->w->active;

	return (0);
}

/*
 * Work out the best current state. If this function succeeds, the state is
 * guaranteed to be completely filled in.
 */
static int
cmd_find_current_session(struct cmd_find_state *fs)
{
	/* If we know the current client, use it. */
	if (fs->item != NULL && fs->item->client != NULL) {
		log_debug("%s: have client %p%s", __func__, fs->item->client,
		    fs->item->client->session == NULL ? "" : " (with session)");
		if (fs->item->client->session == NULL)
			return (cmd_find_current_session_with_client(fs));
		fs->s = fs->item->client->session;
		fs->wl = fs->s->curw;
		fs->idx = fs->wl->idx;
		fs->w = fs->wl->window;
		fs->wp = fs->w->active;
		return (0);
	}

	/* We know nothing, find the best session and client. */
	fs->s = cmd_find_best_session(NULL, 0, fs->flags);
	if (fs->s == NULL)
		return (-1);
	fs->wl = fs->s->curw;
	fs->idx = fs->wl->idx;
	fs->w = fs->wl->window;
	fs->wp = fs->w->active;

	return (0);
}

/* Work out the best current client. */
static struct client *
cmd_find_current_client(struct cmdq_item *item)
{
	struct cmd_find_state	 current;
	struct session		*s;
	struct client		*c, **clist = NULL;
	u_int		 	 csize;

	/* If the queue client has a session, use it. */
	if (item->client != NULL && item->client->session != NULL) {
		log_debug("%s: using item %p client %p", __func__, item,
		    item->client);
		return (item->client);
	}

	/* Otherwise find the current session. */
	cmd_find_clear_state(&current, item, 0);
	if (cmd_find_current_session(&current) != 0)
		return (NULL);

	/* If it is attached, find the best of it's clients. */
	s = current.s;
	log_debug("%s: current session $%u %s", __func__, s->id, s->name);
	if (~s->flags & SESSION_UNATTACHED) {
		csize = 0;
		TAILQ_FOREACH(c, &clients, entry) {
			if (c->session != s)
				continue;
			clist = xreallocarray(clist, csize + 1, sizeof *clist);
			clist[csize++] = c;
		}
		if (csize != 0) {
			c = cmd_find_best_client(clist, csize);
			if (c != NULL) {
				free(clist);
				return (c);
			}
		}
		free(clist);
	}

	/* Otherwise pick best of all clients. */
	return (cmd_find_best_client(NULL, 0));
}

/* Maps string in table. */
static const char *
cmd_find_map_table(const char *table[][2], const char *s)
{
	u_int	i;

	for (i = 0; table[i][0] != NULL; i++) {
		if (strcmp(s, table[i][0]) == 0)
			return (table[i][1]);
	}
	return (s);
}

/* Find session from string. Fills in s. */
static int
cmd_find_get_session(struct cmd_find_state *fs, const char *session)
{
	struct session	*s, *s_loop;
	struct client	*c;

	log_debug("%s: %s", __func__, session);

	/* Check for session ids starting with $. */
	if (*session == '$') {
		fs->s = session_find_by_id_str(session);
		if (fs->s == NULL)
			return (-1);
		return (0);
	}

	/* Look for exactly this session. */
	fs->s = session_find(session);
	if (fs->s != NULL)
		return (0);

	/* Look for as a client. */
	c = cmd_find_client(NULL, session, 1);
	if (c != NULL && c->session != NULL) {
		fs->s = c->session;
		return (0);
	}

	/* Stop now if exact only. */
	if (fs->flags & CMD_FIND_EXACT_SESSION)
		return (-1);

	/* Otherwise look for prefix. */
	s = NULL;
	RB_FOREACH(s_loop, sessions, &sessions) {
		if (strncmp(session, s_loop->name, strlen(session)) == 0) {
			if (s != NULL)
				return (-1);
			s = s_loop;
		}
	}
	if (s != NULL) {
		fs->s = s;
		return (0);
	}

	/* Then as a pattern. */
	s = NULL;
	RB_FOREACH(s_loop, sessions, &sessions) {
		if (fnmatch(session, s_loop->name, 0) == 0) {
			if (s != NULL)
				return (-1);
			s = s_loop;
		}
	}
	if (s != NULL) {
		fs->s = s;
		return (0);
	}

	return (-1);
}

/* Find window from string. Fills in s, wl, w. */
static int
cmd_find_get_window(struct cmd_find_state *fs, const char *window)
{
	log_debug("%s: %s", __func__, window);

	/* Check for window ids starting with @@. */
	if (*window == '@@') {
		fs->w = window_find_by_id_str(window);
		if (fs->w == NULL)
			return (-1);
		return (cmd_find_best_session_with_window(fs));
	}

	/* Not a window id, so use the current session. */
	fs->s = fs->current->s;

	/* We now only need to find the winlink in this session. */
	if (cmd_find_get_window_with_session(fs, window) == 0)
		return (0);

	/* Otherwise try as a session itself. */
	if (cmd_find_get_session(fs, window) == 0) {
		fs->wl = fs->s->curw;
		fs->w = fs->wl->window;
		if (~fs->flags & CMD_FIND_WINDOW_INDEX)
			fs->idx = fs->wl->idx;
		return (0);
	}

	return (-1);
}

/*
 * Find window from string, assuming it is in given session. Needs s, fills in
 * wl and w.
 */
static int
cmd_find_get_window_with_session(struct cmd_find_state *fs, const char *window)
{
	struct winlink	*wl;
	const char	*errstr;
	int		 idx, n, exact;
	struct session	*s;

	log_debug("%s: %s", __func__, window);
	exact = (fs->flags & CMD_FIND_EXACT_WINDOW);

	/*
	 * Start with the current window as the default. So if only an index is
	 * found, the window will be the current.
	 */
	fs->wl = fs->s->curw;
	fs->w = fs->wl->window;

	/* Check for window ids starting with @@. */
	if (*window == '@@') {
		fs->w = window_find_by_id_str(window);
		if (fs->w == NULL || !session_has(fs->s, fs->w))
			return (-1);
		return (cmd_find_best_winlink_with_window(fs));
	}

	/* Try as an offset. */
	if (!exact && (window[0] == '+' || window[0] == '-')) {
		if (window[1] != '\0')
			n = strtonum(window + 1, 1, INT_MAX, NULL);
		else
			n = 1;
		s = fs->s;
		if (fs->flags & CMD_FIND_WINDOW_INDEX) {
			if (window[0] == '+') {
				if (INT_MAX - s->curw->idx < n)
					return (-1);
				fs->idx = s->curw->idx + n;
			} else {
				if (n < s->curw->idx)
					return (-1);
				fs->idx = s->curw->idx - n;
			}
			return (0);
		}
		if (window[0] == '+')
			fs->wl = winlink_next_by_number(s->curw, s, n);
		else
			fs->wl = winlink_previous_by_number(s->curw, s, n);
		if (fs->wl != NULL) {
			fs->idx = fs->wl->idx;
			fs->w = fs->wl->window;
			return (0);
		}
	}

	/* Try special characters. */
	if (!exact) {
		if (strcmp(window, "!") == 0) {
			fs->wl = TAILQ_FIRST(&fs->s->lastw);
			if (fs->wl == NULL)
				return (-1);
			fs->idx = fs->wl->idx;
			fs->w = fs->wl->window;
			return (0);
		} else if (strcmp(window, "^") == 0) {
			fs->wl = RB_MIN(winlinks, &fs->s->windows);
			if (fs->wl == NULL)
				return (-1);
			fs->idx = fs->wl->idx;
			fs->w = fs->wl->window;
			return (0);
		} else if (strcmp(window, "$") == 0) {
			fs->wl = RB_MAX(winlinks, &fs->s->windows);
			if (fs->wl == NULL)
				return (-1);
			fs->idx = fs->wl->idx;
			fs->w = fs->wl->window;
			return (0);
		}
	}

	/* First see if this is a valid window index in this session. */
	if (window[0] != '+' && window[0] != '-') {
		idx = strtonum(window, 0, INT_MAX, &errstr);
		if (errstr == NULL) {
			if (fs->flags & CMD_FIND_WINDOW_INDEX) {
				fs->idx = idx;
				return (0);
			}
			fs->wl = winlink_find_by_index(&fs->s->windows, idx);
			if (fs->wl != NULL) {
				fs->w = fs->wl->window;
				return (0);
			}
		}
	}

	/* Look for exact matches, error if more than one. */
	fs->wl = NULL;
	RB_FOREACH(wl, winlinks, &fs->s->windows) {
		if (strcmp(window, wl->window->name) == 0) {
			if (fs->wl != NULL)
				return (-1);
			fs->wl = wl;
		}
	}
	if (fs->wl != NULL) {
		fs->idx = fs->wl->idx;
		fs->w = fs->wl->window;
		return (0);
	}

	/* Stop now if exact only. */
	if (exact)
		return (-1);

	/* Try as the start of a window name, error if multiple. */
	fs->wl = NULL;
	RB_FOREACH(wl, winlinks, &fs->s->windows) {
		if (strncmp(window, wl->window->name, strlen(window)) == 0) {
			if (fs->wl != NULL)
				return (-1);
			fs->wl = wl;
		}
	}
	if (fs->wl != NULL) {
		fs->idx = fs->wl->idx;
		fs->w = fs->wl->window;
		return (0);
	}

	/* Now look for pattern matches, again error if multiple. */
	fs->wl = NULL;
	RB_FOREACH(wl, winlinks, &fs->s->windows) {
		if (fnmatch(window, wl->window->name, 0) == 0) {
			if (fs->wl != NULL)
				return (-1);
			fs->wl = wl;
		}
	}
	if (fs->wl != NULL) {
		fs->idx = fs->wl->idx;
		fs->w = fs->wl->window;
		return (0);
	}

	return (-1);
}

/* Find pane from string. Fills in s, wl, w, wp. */
static int
cmd_find_get_pane(struct cmd_find_state *fs, const char *pane)
{
	log_debug("%s: %s", __func__, pane);

	/* Check for pane ids starting with %. */
	if (*pane == '%') {
		fs->wp = window_pane_find_by_id_str(pane);
		if (fs->wp == NULL || window_pane_outside(fs->wp))
			return (-1);
		fs->w = fs->wp->window;
		return (cmd_find_best_session_with_window(fs));
	}

	/* Not a pane id, so try the current session and window. */
	fs->s = fs->current->s;
	fs->wl = fs->current->wl;
	fs->idx = fs->current->idx;
	fs->w = fs->current->w;

	/* We now only need to find the pane in this window. */
	if (cmd_find_get_pane_with_window(fs, pane) == 0)
		return (0);

	/* Otherwise try as a window itself (this will also try as session). */
	if (cmd_find_get_window(fs, pane) == 0) {
		fs->wp = fs->w->active;
		return (0);
	}

	return (-1);
}

/*
 * Find pane from string, assuming it is in given session. Needs s, fills in wl
 * and w and wp.
 */
static int
cmd_find_get_pane_with_session(struct cmd_find_state *fs, const char *pane)
{
	log_debug("%s: %s", __func__, pane);

	/* Check for pane ids starting with %. */
	if (*pane == '%') {
		fs->wp = window_pane_find_by_id_str(pane);
		if (fs->wp == NULL || window_pane_outside(fs->wp))
			return (-1);
		fs->w = fs->wp->window;
		return (cmd_find_best_winlink_with_window(fs));
	}

	/* Otherwise use the current window. */
	fs->wl = fs->s->curw;
	fs->idx = fs->wl->idx;
	fs->w = fs->wl->window;

	/* Now we just need to look up the pane. */
	return (cmd_find_get_pane_with_window(fs, pane));
}

/*
 * Find pane from string, assuming it is in the given window. Needs w, fills in
 * wp.
 */
static int
cmd_find_get_pane_with_window(struct cmd_find_state *fs, const char *pane)
{
	const char		*errstr;
	int			 idx;
	struct window_pane	*wp;
	u_int			 n;

	log_debug("%s: %s", __func__, pane);

	/* Check for pane ids starting with %. */
	if (*pane == '%') {
		fs->wp = window_pane_find_by_id_str(pane);
		if (fs->wp == NULL || window_pane_outside(fs->wp))
			return (-1);
		if (fs->wp->window != fs->w)
			return (-1);
		return (0);
	}

	/* Try special characters. */
	if (strcmp(pane, "!") == 0) {
		if (fs->w->last == NULL)
			return (-1);
		fs->wp = fs->w->last;
		if (fs->wp == NULL || window_pane_outside(fs->wp))
			return (-1);
		return (0);
	} else if (strcmp(pane, "{up-of}") == 0) {
		fs->wp = window_pane_find_up(fs->w->active);
		if (fs->wp == NULL || window_pane_outside(fs->wp))
			return (-1);
		return (0);
	} else if (strcmp(pane, "{down-of}") == 0) {
		fs->wp = window_pane_find_down(fs->w->active);
		if (fs->wp == NULL || window_pane_outside(fs->wp))
			return (-1);
		return (0);
	} else if (strcmp(pane, "{left-of}") == 0) {
		fs->wp = window_pane_find_left(fs->w->active);
		if (fs->wp == NULL || window_pane_outside(fs->wp))
			return (-1);
		return (0);
	} else if (strcmp(pane, "{right-of}") == 0) {
		fs->wp = window_pane_find_right(fs->w->active);
		if (fs->wp == NULL || window_pane_outside(fs->wp))
			return (-1);
		return (0);
	}

	/* Try as an offset. */
	if (pane[0] == '+' || pane[0] == '-') {
		if (pane[1] != '\0')
			n = strtonum(pane + 1, 1, INT_MAX, NULL);
		else
			n = 1;
		wp = fs->w->active;
		if (pane[0] == '+')
			fs->wp = window_pane_next_by_number(fs->w, wp, n);
		else
			fs->wp = window_pane_previous_by_number(fs->w, wp, n);
		if (fs->wp != NULL && !window_pane_outside(fs->wp))
			return (0);
	}

	/* Get pane by index. */
	idx = strtonum(pane, 0, INT_MAX, &errstr);
	if (errstr == NULL) {
		fs->wp = window_pane_at_index(fs->w, idx);
		if (fs->wp != NULL && !window_pane_outside(fs->wp))
			return (0);
	}

	/* Try as a description. */
	fs->wp = window_find_string(fs->w, pane);
	if (fs->wp != NULL && !window_pane_outside(fs->wp))
		return (0);

	return (-1);
}

/* Clear state. */
void
cmd_find_clear_state(struct cmd_find_state *fs, struct cmdq_item *item,
    int flags)
{
	memset(fs, 0, sizeof *fs);

	fs->item = item;
	fs->flags = flags;

	fs->idx = -1;
}

/* Check if state is empty/ */
int
cmd_find_empty_state(struct cmd_find_state *fs)
{
	if (fs->s == NULL && fs->wl == NULL && fs->w == NULL && fs->wp == NULL)
		return (1);
	return (0);
}

/* Check if a state if valid. */
int
cmd_find_valid_state(struct cmd_find_state *fs)
{
	struct winlink	*wl;

	if (fs->s == NULL || fs->wl == NULL || fs->w == NULL || fs->wp == NULL)
		return (0);

	if (!session_alive(fs->s))
		return (0);

	RB_FOREACH(wl, winlinks, &fs->s->windows) {
		if (wl->window == fs->w && wl == fs->wl)
			break;
	}
	if (wl == NULL)
		return (0);

	if (fs->w != fs->wl->window)
		return (0);

	if (!window_has_pane(fs->w, fs->wp))
		return (0);
	return (!window_pane_outside(fs->wp));
}

/* Copy a state. */
void
cmd_find_copy_state(struct cmd_find_state *dst, struct cmd_find_state *src)
{
	dst->s = src->s;
	dst->wl = src->wl;
	dst->idx = src->idx;
	dst->w = src->w;
	dst->wp = src->wp;
}

/* Log the result. */
void
cmd_find_log_state(const char *prefix, struct cmd_find_state *fs)
{
	if (fs->s != NULL)
		log_debug("%s: s=$%u", prefix, fs->s->id);
	else
		log_debug("%s: s=none", prefix);
	if (fs->wl != NULL) {
		log_debug("%s: wl=%u %d w=@@%u %s", prefix, fs->wl->idx,
		    fs->wl->window == fs->w, fs->w->id, fs->w->name);
	} else
		log_debug("%s: wl=none", prefix);
	if (fs->wp != NULL)
		log_debug("%s: wp=%%%u", prefix, fs->wp->id);
	else
		log_debug("%s: wp=none", prefix);
	if (fs->idx != -1)
		log_debug("%s: idx=%d", prefix, fs->idx);
	else
		log_debug("%s: idx=none", prefix);
}

/* Find state from a session. */
int
cmd_find_from_session(struct cmd_find_state *fs, struct session *s)
{
	cmd_find_clear_state(fs, NULL, 0);

	fs->s = s;
	fs->wl = fs->s->curw;
	fs->w = fs->wl->window;
	fs->wp = fs->w->active;

	cmd_find_log_state(__func__, fs);
	return (0);
}

/* Find state from a winlink. */
int
cmd_find_from_winlink(struct cmd_find_state *fs, struct session *s,
    struct winlink *wl)
{
	cmd_find_clear_state(fs, NULL, 0);

	fs->s = s;
	fs->wl = wl;
	fs->w = wl->window;
	fs->wp = wl->window->active;

	cmd_find_log_state(__func__, fs);
	return (0);
}

/* Find state from a session and window. */
int
cmd_find_from_session_window(struct cmd_find_state *fs, struct session *s,
    struct window *w)
{
	cmd_find_clear_state(fs, NULL, 0);

	fs->s = s;
	fs->w = w;
	if (cmd_find_best_winlink_with_window(fs) != 0)
		return (-1);
	fs->wp = fs->w->active;

	cmd_find_log_state(__func__, fs);
	return (0);
}

/* Find state from a window. */
int
cmd_find_from_window(struct cmd_find_state *fs, struct window *w)
{
	cmd_find_clear_state(fs, NULL, 0);

	fs->w = w;
	if (cmd_find_best_session_with_window(fs) != 0)
		return (-1);
	if (cmd_find_best_winlink_with_window(fs) != 0)
		return (-1);
	fs->wp = fs->w->active;

	cmd_find_log_state(__func__, fs);
	return (0);
}

/* Find state from a pane. */
int
cmd_find_from_pane(struct cmd_find_state *fs, struct window_pane *wp)
{
	if (cmd_find_from_window(fs, wp->window) != 0)
		return (-1);
	if (window_pane_outside(wp))
		return (-1);
	fs->wp = wp;

	cmd_find_log_state(__func__, fs);
	return (0);
}

/* Find current state. */
int
cmd_find_current(struct cmd_find_state *fs, struct cmdq_item *item, int flags)
{
	cmd_find_clear_state(fs, item, flags);
	if (cmd_find_current_session(fs) != 0) {
		if (~flags & CMD_FIND_QUIET)
			cmdq_error(item, "no current session");
		return (-1);
	}
	return (0);
}

/*
 * Split target into pieces and resolve for the given type. Fills in the given
 * state. Returns 0 on success or -1 on error.
 */
int
cmd_find_target(struct cmd_find_state *fs, struct cmd_find_state *current,
    struct cmdq_item *item, const char *target, enum cmd_find_type type,
    int flags)
{
	struct mouse_event	*m;
	char			*colon, *period, *copy = NULL;
	const char		*session, *window, *pane;

	/* Log the arguments. */
	if (target == NULL)
		log_debug("%s: target none, type %d", __func__, type);
	else
		log_debug("%s: target %s, type %d", __func__, target, type);
	log_debug("%s: item %p, flags %#x", __func__, item, flags);

	/* Clear new state. */
	cmd_find_clear_state(fs, item, flags);

	/* Find current state. */
	if (server_check_marked() && (flags & CMD_FIND_DEFAULT_MARKED)) {
		fs->current = &marked_pane;
		log_debug("%s: current is marked pane", __func__);
	} else if (cmd_find_valid_state(&item->current)) {
		fs->current = &item->current;
		log_debug("%s: current is from queue", __func__);
	} else {
		fs->current = current;
		log_debug("%s: current is from argument", __func__);
	}
	if (!cmd_find_empty_state(fs->current) &&
	    !cmd_find_valid_state(fs->current))
		fatalx("invalid current find state");

	/* An empty or NULL target is the current. */
	if (target == NULL || *target == '\0')
		goto current;

	/* Mouse target is a plain = or {mouse}. */
	if (strcmp(target, "=") == 0 || strcmp(target, "{mouse}") == 0) {
		m = &item->mouse;
		switch (type) {
		case CMD_FIND_PANE:
			fs->wp = cmd_mouse_pane(m, &fs->s, &fs->wl);
			if (fs->wp != NULL && !window_pane_outside(fs->wp))
				fs->w = fs->wl->window;
			break;
		case CMD_FIND_WINDOW:
		case CMD_FIND_SESSION:
			fs->wl = cmd_mouse_window(m, &fs->s);
			if (fs->wl != NULL) {
				fs->w = fs->wl->window;
				fs->wp = fs->w->active;
			}
			break;
		}
		if (fs->wp == NULL) {
			if (~flags & CMD_FIND_QUIET)
				cmdq_error(item, "no mouse target");
			goto error;
		}
		goto found;
	}

	/* Marked target is a plain ~ or {marked}. */
	if (strcmp(target, "~") == 0 || strcmp(target, "{marked}") == 0) {
		if (!server_check_marked()) {
			if (~flags & CMD_FIND_QUIET)
				cmdq_error(item, "no marked target");
			goto error;
		}
		cmd_find_copy_state(fs, &marked_pane);
		goto found;
	}

	/* Find separators if they exist. */
	copy = xstrdup(target);
	colon = strchr(copy, ':');
	if (colon != NULL)
		*colon++ = '\0';
	if (colon == NULL)
		period = strchr(copy, '.');
	else
		period = strchr(colon, '.');
	if (period != NULL)
		*period++ = '\0';

	/* Set session, window and pane parts. */
	session = window = pane = NULL;
	if (colon != NULL && period != NULL) {
		session = copy;
		window = colon;
		pane = period;
	} else if (colon != NULL && period == NULL) {
		session = copy;
		window = colon;
	} else if (colon == NULL && period != NULL) {
		window = copy;
		pane = period;
	} else {
		if (*copy == '$')
			session = copy;
		else if (*copy == '@@')
			window = copy;
		else if (*copy == '%')
			pane = copy;
		else {
			switch (type) {
			case CMD_FIND_SESSION:
				session = copy;
				break;
			case CMD_FIND_WINDOW:
				window = copy;
				break;
			case CMD_FIND_PANE:
				pane = copy;
				break;
			}
		}
	}

	/* Set exact match flags. */
	if (session != NULL && *session == '=') {
		session++;
		fs->flags |= CMD_FIND_EXACT_SESSION;
	}
	if (window != NULL && *window == '=') {
		window++;
		fs->flags |= CMD_FIND_EXACT_WINDOW;
	}

	/* Empty is the same as NULL. */
	if (session != NULL && *session == '\0')
		session = NULL;
	if (window != NULL && *window == '\0')
		window = NULL;
	if (pane != NULL && *pane == '\0')
		pane = NULL;

	/* Map though conversion table. */
	if (session != NULL)
		session = cmd_find_map_table(cmd_find_session_table, session);
	if (window != NULL)
		window = cmd_find_map_table(cmd_find_window_table, window);
	if (pane != NULL)
		pane = cmd_find_map_table(cmd_find_pane_table, pane);

	log_debug("target %s (flags %#x): session=%s, window=%s, pane=%s",
	    target, flags, session == NULL ? "none" : session,
	    window == NULL ? "none" : window, pane == NULL ? "none" : pane);

	/* No pane is allowed if want an index. */
	if (pane != NULL && (flags & CMD_FIND_WINDOW_INDEX)) {
		if (~flags & CMD_FIND_QUIET)
			cmdq_error(item, "can't specify pane here");
		goto error;
	}

	/* If the session isn't NULL, look it up. */
	if (session != NULL) {
		/* This will fill in session. */
		if (cmd_find_get_session(fs, session) != 0)
			goto no_session;

		/* If window and pane are NULL, use that session's current. */
		if (window == NULL && pane == NULL) {
			fs->wl = fs->s->curw;
			fs->idx = -1;
			fs->w = fs->wl->window;
			fs->wp = fs->w->active;
			goto found;
		}

		/* If window is present but pane not, find window in session. */
		if (window != NULL && pane == NULL) {
			/* This will fill in winlink and window. */
			if (cmd_find_get_window_with_session(fs, window) != 0)
				goto no_window;
			fs->wp = fs->wl->window->active;
			goto found;
		}

		/* If pane is present but window not, find pane. */
		if (window == NULL && pane != NULL) {
			/* This will fill in winlink and window and pane. */
			if (cmd_find_get_pane_with_session(fs, pane) != 0)
				goto no_pane;
			goto found;
		}

		/*
		 * If window and pane are present, find both in session. This
		 * will fill in winlink and window.
		 */
		if (cmd_find_get_window_with_session(fs, window) != 0)
			goto no_window;
		/* This will fill in pane. */
		if (cmd_find_get_pane_with_window(fs, pane) != 0)
			goto no_pane;
		goto found;
	}

	/* No session. If window and pane, try them. */
	if (window != NULL && pane != NULL) {
		/* This will fill in session, winlink and window. */
		if (cmd_find_get_window(fs, window) != 0)
			goto no_window;
		/* This will fill in pane. */
		if (cmd_find_get_pane_with_window(fs, pane) != 0)
			goto no_pane;
		goto found;
	}

	/* If just window is present, try it. */
	if (window != NULL && pane == NULL) {
		/* This will fill in session, winlink and window. */
		if (cmd_find_get_window(fs, window) != 0)
			goto no_window;
		fs->wp = fs->wl->window->active;
		goto found;
	}

	/* If just pane is present, try it. */
	if (window == NULL && pane != NULL) {
		/* This will fill in session, winlink, window and pane. */
		if (cmd_find_get_pane(fs, pane) != 0)
			goto no_pane;
		goto found;
	}

current:
	/* Use the current session. */
	cmd_find_copy_state(fs, fs->current);
	if (flags & CMD_FIND_WINDOW_INDEX)
		fs->idx = -1;
	goto found;

error:
	fs->current = NULL;
	log_debug("%s: error", __func__);

	free(copy);
	return (-1);

found:
	fs->current = NULL;
	cmd_find_log_state(__func__, fs);

	free(copy);
	return (0);

no_session:
	if (~flags & CMD_FIND_QUIET)
		cmdq_error(item, "can't find session %s", session);
	goto error;

no_window:
	if (~flags & CMD_FIND_QUIET)
		cmdq_error(item, "can't find window %s", window);
	goto error;

no_pane:
	if (~flags & CMD_FIND_QUIET)
		cmdq_error(item, "can't find pane %s", pane);
	goto error;
}

/* Find the target client or report an error and return NULL. */
struct client *
cmd_find_client(struct cmdq_item *item, const char *target, int quiet)
{
	struct client	*c;
	char		*copy;
	size_t		 size;

	/* A NULL argument means the current client. */
	if (item != NULL && target == NULL) {
		c = cmd_find_current_client(item);
		if (c == NULL && !quiet)
			cmdq_error(item, "no current client");
		log_debug("%s: no target, return %p", __func__, c);
		return (c);
	}
	copy = xstrdup(target);

	/* Trim a single trailing colon if any. */
	size = strlen(copy);
	if (size != 0 && copy[size - 1] == ':')
		copy[size - 1] = '\0';

	/* Check name and path of each client. */
	TAILQ_FOREACH(c, &clients, entry) {
		if (c->session == NULL)
			continue;
		if (strcmp(copy, c->name) == 0)
			break;

		if (*c->ttyname == '\0')
			continue;
		if (strcmp(copy, c->ttyname) == 0)
			break;
		if (strncmp(c->ttyname, _PATH_DEV, (sizeof _PATH_DEV) - 1) != 0)
			continue;
		if (strcmp(copy, c->ttyname + (sizeof _PATH_DEV) - 1) == 0)
			break;
	}

	/* If no client found, report an error. */
	if (c == NULL && !quiet)
		cmdq_error(item, "can't find client %s", copy);

	free(copy);
	log_debug("%s: target %s, return %p", __func__, target, c);
	return (c);
}
@


1.42
log
@Revert previous, breaks normal short targets, reported by Theo Buehler.
@
text
@d1 1
a1 1
/* $OpenBSD: cmd-find.c,v 1.40 2016/11/16 00:24:03 nicm Exp $ */
d259 1
a259 1
	if (fs->item != NULL && fs->item->client->tty.path != NULL) {
d261 1
a261 1
			if (strcmp(wp->tty, fs->item->client->tty.path) == 0)
a1250 1
	const char	*path;
d1267 1
a1267 1
	/* Check path of each client. */
d1269 1
a1269 1
		if (c->session == NULL || c->tty.path == NULL)
d1271 2
a1272 1
		path = c->tty.path;
d1274 3
a1276 2
		/* Try for exact match. */
		if (strcmp(copy, path) == 0)
d1278 1
a1278 3

		/* Try without leading /dev. */
		if (strncmp(path, _PATH_DEV, (sizeof _PATH_DEV) - 1) != 0)
d1280 1
a1280 1
		if (strcmp(copy, path + (sizeof _PATH_DEV) - 1) == 0)
@


1.41
log
@Only look for window and pane parts of target as a sesson and window if
they look like an ID.
@
text
@d486 2
a487 2
	/* Try as a session if it looks like a session. */
	if (*window == '$' && cmd_find_get_session(fs, window) == 0) {
d677 2
a678 2
	/* Try as a window if it looks like a window. */
	if (*pane == '@@' && cmd_find_get_window(fs, pane) == 0) {
@


1.40
log
@The target validity check used window_pane_visible but that may be false
if the pane is zoomed, so instead add a new function to just check if
the pane is actually on screen (most commands still want to accept panes
invisible by zoom). Also reject panes outside the window for various
special targets. Problem reported by Sean Haugh.
@
text
@d1 1
a1 1
/* $OpenBSD: cmd-find.c,v 1.39 2016/10/18 12:51:26 nicm Exp $ */
d486 2
a487 2
	/* Otherwise try as a session itself. */
	if (cmd_find_get_session(fs, window) == 0) {
d677 2
a678 2
	/* Otherwise try as a window itself (this will also try as session). */
	if (cmd_find_get_window(fs, pane) == 0) {
@


1.39
log
@Tweak a couple of log statements.
@
text
@d1 1
a1 1
/* $OpenBSD: cmd-find.c,v 1.38 2016/10/16 22:06:40 nicm Exp $ */
d661 1
a661 1
		if (fs->wp == NULL)
d698 1
a698 1
		if (fs->wp == NULL)
d730 3
a732 1
		if (fs->wp == NULL || fs->wp->window != fs->w)
d742 2
d747 1
a747 1
		if (fs->wp == NULL)
d752 1
a752 1
		if (fs->wp == NULL)
d757 1
a757 1
		if (fs->wp == NULL)
d762 1
a762 1
		if (fs->wp == NULL)
d778 1
a778 1
		if (fs->wp != NULL)
d786 1
a786 1
		if (fs->wp != NULL)
d792 1
a792 1
	if (fs->wp != NULL)
d844 1
a844 1
	return (window_pane_visible(fs->wp));
d952 2
d1021 1
a1021 1
			if (fs->wp != NULL)
@


1.38
log
@Use the notify name string instead of going via an enum and change
existing hooks to use notifys instead.
@
text
@d1 1
a1 1
/* $OpenBSD: cmd-find.c,v 1.37 2016/10/16 19:04:05 nicm Exp $ */
d993 1
a993 1
		log_debug("    current is marked pane");
d996 1
a996 1
		log_debug("    current is from queue");
d999 1
a999 1
		log_debug("    current is from argument");
d1210 1
a1210 1
	log_debug("    error");
@


1.37
log
@Mass rename struct cmd_q to struct cmdq_item and related.
@
text
@d1 1
a1 1
/* $OpenBSD: cmd-find.c,v 1.36 2016/10/16 17:55:14 nicm Exp $ */
d231 1
a231 1
	if (fs->s->curw->window == fs->w)
@


1.36
log
@Rewrite command queue handling. Each client still has a command queue,
but there is also now a global command queue. Instead of command queues
being dispatched on demand from wherever the command happens to be
added, they are now all dispatched from the top level server
loop. Command queues may now also include callbacks as well as commands,
and items may be inserted after the current command as well as at the end.

This all makes command queues significantly more predictable and easier
to use, and avoids the complex multiple nested command queues used by
source-file, if-shell and friends.

A mass rename of struct cmdq to a better name (cmdq_item probably) is
coming.
@
text
@d1 1
a1 1
/* $OpenBSD: cmd-find.c,v 1.35 2016/10/15 00:09:30 nicm Exp $ */
d41 1
a41 1
static struct client *cmd_find_current_client(struct cmd_q *);
d195 2
a196 2
	if (fs->cmdq != NULL && fs->cmdq->client != NULL) {
		fs->s = cmd_find_try_TMUX(fs->cmdq->client, fs->w);
d259 1
a259 1
	if (fs->cmdq != NULL && fs->cmdq->client->tty.path != NULL) {
d261 1
a261 1
			if (strcmp(wp->tty, fs->cmdq->client->tty.path) == 0)
d295 2
a296 2
	if (fs->cmdq != NULL)
		fs->s = cmd_find_try_TMUX(fs->cmdq->client, NULL);
d317 4
a320 4
	if (fs->cmdq != NULL && fs->cmdq->client != NULL) {
		log_debug("%s: have client %p%s", __func__, fs->cmdq->client,
		    fs->cmdq->client->session == NULL ? "" : " (with session)");
		if (fs->cmdq->client->session == NULL)
d322 1
a322 1
		fs->s = fs->cmdq->client->session;
d344 1
a344 1
cmd_find_current_client(struct cmd_q *cmdq)
d352 4
a355 4
	if (cmdq->client != NULL && cmdq->client->session != NULL) {
		log_debug("%s: using cmdq %p client %p", __func__, cmdq,
		    cmdq->client);
		return (cmdq->client);
d359 1
a359 1
	cmd_find_clear_state(&current, cmdq, 0);
d796 2
a797 1
cmd_find_clear_state(struct cmd_find_state *fs, struct cmd_q *cmdq, int flags)
d801 1
a801 1
	fs->cmdq = cmdq;
d956 1
a956 1
cmd_find_current(struct cmd_find_state *fs, struct cmd_q *cmdq, int flags)
d958 1
a958 1
	cmd_find_clear_state(fs, cmdq, flags);
d961 1
a961 1
			cmdq_error(cmdq, "no current session");
d973 2
a974 1
    struct cmd_q *cmdq, const char *target, enum cmd_find_type type, int flags)
d985 1
a985 1
	log_debug("%s: cmdq %p, flags %#x", __func__, cmdq, flags);
d988 1
a988 1
	cmd_find_clear_state(fs, cmdq, flags);
d994 2
a995 2
	} else if (cmd_find_valid_state(&cmdq->current)) {
		fs->current = &cmdq->current;
d1011 1
a1011 1
		m = &cmdq->mouse;
d1029 1
a1029 1
				cmdq_error(cmdq, "no mouse target");
d1039 1
a1039 1
				cmdq_error(cmdq, "no marked target");
d1125 1
a1125 1
			cmdq_error(cmdq, "can't specify pane here");
d1224 1
a1224 1
		cmdq_error(cmdq, "can't find session %s", session);
d1229 1
a1229 1
		cmdq_error(cmdq, "can't find window %s", window);
d1234 1
a1234 1
		cmdq_error(cmdq, "can't find pane %s", pane);
d1240 1
a1240 1
cmd_find_client(struct cmd_q *cmdq, const char *target, int quiet)
d1248 2
a1249 2
	if (cmdq != NULL && target == NULL) {
		c = cmd_find_current_client(cmdq);
d1251 1
a1251 1
			cmdq_error(cmdq, "no current client");
d1281 1
a1281 1
		cmdq_error(cmdq, "can't find client %s", copy);
@


1.35
log
@Fire hooks on the simple notifys (window-renamed and session-renamed),
the complicated ones get no hooks for now (more to come).
@
text
@d1 1
a1 1
/* $OpenBSD: cmd-find.c,v 1.34 2016/10/13 10:01:49 nicm Exp $ */
d1009 1
a1009 1
		m = &cmdq->item->mouse;
@


1.34
log
@Some improvements and bug fixes for hooks:

- Prepare the state again before the "after" hooks are run, because the
  command may have killed or moved windows.

- Use the hooks list from the newly prepared target, not the old hooks
  list (only matters for new-session really).

- Correctly detect an invalid current state and ignore it in
  cmd_find_target ("killw; swapw").

- Change neww, new, killp, killw, splitw, swapp, swapw to update the
  current state (used if no explicit target is given) to something more
  useful after they have finished. For example, neww changes it to the
  newly created window.

Hooks are still relatively new and primitive so there are likely to be
more changes to come.

Parts based on bug reports from Uwe Werler and Iblis Lin.
@
text
@d1 1
a1 1
/* $OpenBSD: cmd-find.c,v 1.33 2016/10/10 21:51:39 nicm Exp $ */
d907 17
d935 1
@


1.33
log
@Add static in cmd-* and fix a few other nits.
@
text
@d1 1
a1 1
/* $OpenBSD: cmd-find.c,v 1.32 2016/03/03 14:14:46 nicm Exp $ */
d806 9
d971 1
a971 1
	if (server_check_marked() && (flags & CMD_FIND_DEFAULT_MARKED))
d973 2
a974 1
	else if (cmd_find_valid_state(&cmdq->current))
d976 2
a977 1
	else
d979 5
@


1.32
log
@Accept clients as sessions in cmd_find_get_session.
@
text
@d1 1
a1 1
/* $OpenBSD: cmd-find.c,v 1.31 2016/01/19 16:01:30 nicm Exp $ */
d30 24
a53 22
struct session	*cmd_find_try_TMUX(struct client *, struct window *);
int		 cmd_find_client_better(struct client *, struct client *);
struct client	*cmd_find_best_client(struct client **, u_int);
int		 cmd_find_session_better(struct session *, struct session *,
		     int);
struct session	*cmd_find_best_session(struct session **, u_int, int);
int		 cmd_find_best_session_with_window(struct cmd_find_state *);
int		 cmd_find_best_winlink_with_window(struct cmd_find_state *);

int		 cmd_find_current_session_with_client(struct cmd_find_state *);
int		 cmd_find_current_session(struct cmd_find_state *);
struct client	*cmd_find_current_client(struct cmd_q *);

const char	*cmd_find_map_table(const char *[][2], const char *);

int	cmd_find_get_session(struct cmd_find_state *, const char *);
int	cmd_find_get_window(struct cmd_find_state *, const char *);
int	cmd_find_get_window_with_session(struct cmd_find_state *, const char *);
int	cmd_find_get_window_with_pane(struct cmd_find_state *);
int	cmd_find_get_pane(struct cmd_find_state *, const char *);
int	cmd_find_get_pane_with_session(struct cmd_find_state *, const char *);
int	cmd_find_get_pane_with_window(struct cmd_find_state *, const char *);
d55 1
a55 1
const char *cmd_find_session_table[][2] = {
d58 1
a58 1
const char *cmd_find_window_table[][2] = {
d66 1
a66 1
const char *cmd_find_pane_table[][2] = {
d86 1
a86 1
struct session *
d113 1
a113 1
int
d122 1
a122 1
struct client *
d148 1
a148 1
int
d166 1
a166 1
struct session *
d188 1
a188 1
int
d225 1
a225 1
int
d249 1
a249 1
int
d313 1
a313 1
int
d343 1
a343 1
struct client *
d389 1
a389 1
const char *
d402 1
a402 1
int
d466 1
a466 1
int
d502 1
a502 1
int
a651 10
/* Find window from given pane. Needs wp, fills in s and wl and w. */
int
cmd_find_get_window_with_pane(struct cmd_find_state *fs)
{
	log_debug("%s", __func__);

	fs->w = fs->wp->window;
	return (cmd_find_best_session_with_window(fs));
}

d653 1
a653 1
int
d690 1
a690 1
int
d717 1
a717 1
int
@


1.31
log
@Split out getting the current state from the target search so it can be
replaced if we already know the current.
@
text
@d1 1
a1 1
/* $OpenBSD: cmd-find.c,v 1.30 2016/01/19 15:59:12 nicm Exp $ */
d404 1
d421 7
d1220 1
a1220 1
	if (target == NULL) {
@


1.30
log
@I no longer use my SourceForge address so replace it.
@
text
@d1 1
a1 1
/* $OpenBSD: cmd-find.c,v 1.29 2016/01/16 00:36:53 nicm Exp $ */
d926 13
d944 2
a945 2
cmd_find_target(struct cmd_find_state *fs, struct cmd_q *cmdq,
    const char *target, enum cmd_find_type type, int flags)
a946 1
	struct cmd_find_state	 current;
d966 2
a967 9
	else {
		cmd_find_clear_state(&current, cmdq, flags);
		if (cmd_find_current_session(&current) != 0) {
			if (~flags & CMD_FIND_QUIET)
				cmdq_error(cmdq, "no current session");
			goto error;
		}
		fs->current = &current;
	}
@


1.29
log
@Add hooks for alerts (bell, silence, activity), from Thomas Adam.
@
text
@d1 1
a1 1
/* $OpenBSD: cmd-find.c,v 1.28 2015/12/17 23:08:22 nicm Exp $ */
d4 1
a4 1
 * Copyright (c) 2015 Nicholas Marriott <nicm@@users.sourceforge.net>
@


1.28
log
@As well as setting up the state, actually use it in cmd_find_target.
@
text
@d1 1
a1 1
/* $OpenBSD: cmd-find.c,v 1.27 2015/12/16 21:50:37 nicm Exp $ */
d877 16
@


1.27
log
@Add infrastructure to work out the best target given a pane or window
alone and use it to add pane_died and pane_exited hooks.
@
text
@d1 1
a1 1
/* $OpenBSD: cmd-find.c,v 1.26 2015/12/15 14:32:55 nicm Exp $ */
a933 1
	fs->current = NULL;
d936 3
a938 1
	if (fs->current == NULL) {
@


1.26
log
@Copy state directly rather than dereferencing wl (which could be NULL).
@
text
@d1 1
a1 1
/* $OpenBSD: cmd-find.c,v 1.25 2015/12/15 00:45:02 nicm Exp $ */
d193 1
a193 1
	if (fs->cmdq->client != NULL) {
d257 1
a257 1
	if (fs->cmdq->client->tty.path != NULL) {
d292 3
a294 1
	fs->s = cmd_find_try_TMUX(fs->cmdq->client, NULL);
d315 1
a315 1
	if (fs->cmdq->client != NULL) {
d865 43
@


1.25
log
@We changed somewhat recently to us the pty when tmux was run inside
itself to work out the current pane. This is confusing in many cases
(particularly notable is that "tmux neww\; splitw" would not split the
new window), and the few advantages do not make up for the confusion.

So drop this behaviour and return to using the current window and pane;
keep the pty check but only use it to limit the list of possible current
sessions.
@
text
@d1 1
a1 1
/* $OpenBSD: cmd-find.c,v 1.24 2015/12/15 00:11:24 nicm Exp $ */
d837 2
a838 2
	dst->idx = dst->wl->idx;
	dst->w = dst->wl->window;
@


1.24
log
@Don't copy marked pane when can just point to it.
@
text
@d1 1
a1 1
/* $OpenBSD: cmd-find.c,v 1.23 2015/12/15 00:00:01 nicm Exp $ */
d252 5
a256 1
	/* If this is running in a pane, that's great. */
d269 1
a269 1
	/* We now know the window and pane. */
a270 3
	fs->wp = wp;

	/* Find the best session and winlink. */
d282 7
d301 1
@


1.23
log
@Make the marked pane a cmd_find_state.
@
text
@d1 1
a1 1
/* $OpenBSD: cmd-find.c,v 1.22 2015/12/14 23:30:58 nicm Exp $ */
d876 3
d880 1
a880 1
	cmd_find_clear_state(&current, cmdq, flags);
d882 3
a884 2
		cmd_find_copy_state(&current, &marked_pane);
	else {
d890 1
a892 4
	/* Clear new state. */
	cmd_find_clear_state(fs, cmdq, flags);
	fs->current = &current;

d1091 1
d1093 1
a1093 2
		current.idx = -1;
	memcpy(fs, &current, sizeof *fs);
@


1.22
log
@Use cmd_find_clear_state instead of an extra function doing the same.
@
text
@d1 1
a1 1
/* $OpenBSD: cmd-find.c,v 1.21 2015/12/13 17:55:14 nicm Exp $ */
d795 61
d878 8
a885 11
	if (server_check_marked() && (flags & CMD_FIND_DEFAULT_MARKED)) {
		current.s = marked_session;
		current.wl = marked_winlink;
		current.idx = current.wl->idx;
		current.w = current.wl->window;
		current.wp = marked_window_pane;
	}
	if (current.s == NULL && cmd_find_current_session(&current) != 0) {
		if (~flags & CMD_FIND_QUIET)
			cmdq_error(cmdq, "no current session");
		goto error;
d929 1
a929 5
		fs->s = marked_session;
		fs->wl = marked_winlink;
		fs->idx = fs->wl->idx;
		fs->w = fs->wl->window;
		fs->wp = marked_window_pane;
a1122 23
}

/* Log the result. */
void
cmd_find_log_state(const char *prefix, struct cmd_find_state *fs)
{
	if (fs->s != NULL)
		log_debug("%s: s=$%u", prefix, fs->s->id);
	else
		log_debug("%s: s=none", prefix);
	if (fs->wl != NULL) {
		log_debug("%s: wl=%u %d w=@@%u %s", prefix, fs->wl->idx,
		    fs->wl->window == fs->w, fs->w->id, fs->w->name);
	} else
		log_debug("%s: wl=none", prefix);
	if (fs->wp != NULL)
		log_debug("%s: wp=%%%u", prefix, fs->wp->id);
	else
		log_debug("%s: wp=none", prefix);
	if (fs->idx != -1)
		log_debug("%s: idx=%d", prefix, fs->idx);
	else
		log_debug("%s: idx=none", prefix);
@


1.21
log
@Use struct cmd_find_state directly and remove cmd_state_flag, also
change so that winlink is set even if an index is too.
@
text
@d1 1
a1 1
/* $OpenBSD: cmd-find.c,v 1.20 2015/12/13 16:44:35 nicm Exp $ */
a51 3

void	cmd_find_clear_state(struct cmd_find_state *, struct cmd_q *, int);
void	cmd_find_log_state(const char *, struct cmd_find_state *);
@


1.20
log
@Change cmd_find_target to use a state struct from the caller.
@
text
@d1 1
a1 1
/* $OpenBSD: cmd-find.c,v 1.19 2015/12/13 15:32:12 nicm Exp $ */
d470 3
a472 3
		if (~fs->flags & CMD_FIND_WINDOW_INDEX) {
			fs->wl = fs->s->curw;
			fs->w = fs->wl->window;
a473 1
		}
d495 7
d985 1
a985 2
			if (~flags & CMD_FIND_WINDOW_INDEX)
				fs->wp = fs->wl->window->active;
d1025 1
a1025 2
		if (~flags & CMD_FIND_WINDOW_INDEX)
			fs->wp = fs->wl->window->active;
@


1.19
log
@Remove the cmd_find_{session,window,pane,index} functions (which are
just wrappers around cmd_find_target) and just use cmd_find_target
directly.
@
text
@d1 1
a1 1
/* $OpenBSD: cmd-find.c,v 1.18 2015/12/13 15:00:37 nicm Exp $ */
d792 7
a798 4
/* Split target into pieces and resolve for the given type. */
struct cmd_find_state *
cmd_find_target(struct cmd_q *cmdq, const char *target, enum cmd_find_type type,
    int flags)
d800 4
a803 4
	static struct cmd_find_state	 fs, current;
	struct mouse_event		*m;
	char				*colon, *period, *copy = NULL;
	const char			*session, *window, *pane;
d828 2
a829 2
	cmd_find_clear_state(&fs, cmdq, flags);
	fs.current = &current;
d840 3
a842 3
			fs.wp = cmd_mouse_pane(m, &fs.s, &fs.wl);
			if (fs.wp != NULL)
				fs.w = fs.wl->window;
d846 4
a849 4
			fs.wl = cmd_mouse_window(m, &fs.s);
			if (fs.wl != NULL) {
				fs.w = fs.wl->window;
				fs.wp = fs.w->active;
d853 1
a853 1
		if (fs.wp == NULL) {
d868 5
a872 5
		fs.s = marked_session;
		fs.wl = marked_winlink;
		fs.idx = fs.wl->idx;
		fs.w = fs.wl->window;
		fs.wp = marked_window_pane;
d925 1
a925 1
		fs.flags |= CMD_FIND_EXACT_SESSION;
d929 1
a929 1
		fs.flags |= CMD_FIND_EXACT_WINDOW;
d962 1
a962 1
		if (cmd_find_get_session(&fs, session) != 0)
d967 4
a970 4
			fs.wl = fs.s->curw;
			fs.idx = -1;
			fs.w = fs.wl->window;
			fs.wp = fs.w->active;
d977 1
a977 1
			if (cmd_find_get_window_with_session(&fs, window) != 0)
d980 1
a980 1
				fs.wp = fs.wl->window->active;
d987 1
a987 1
			if (cmd_find_get_pane_with_session(&fs, pane) != 0)
d996 1
a996 1
		if (cmd_find_get_window_with_session(&fs, window) != 0)
d999 1
a999 1
		if (cmd_find_get_pane_with_window(&fs, pane) != 0)
d1007 1
a1007 1
		if (cmd_find_get_window(&fs, window) != 0)
d1010 1
a1010 1
		if (cmd_find_get_pane_with_window(&fs, pane) != 0)
d1018 1
a1018 1
		if (cmd_find_get_window(&fs, window) != 0)
d1021 1
a1021 1
			fs.wp = fs.wl->window->active;
d1028 1
a1028 1
		if (cmd_find_get_pane(&fs, pane) != 0)
d1034 1
a1034 2
	/* None is the current session. */
	free(copy);
d1037 2
a1038 2
	cmd_find_log_state(__func__, &current);
	return (&current);
d1041 3
d1045 1
a1045 2
	log_debug("    error");
	return (NULL);
d1048 3
a1050 1
	cmd_find_log_state(__func__, &fs);
d1052 1
a1052 1
	return (&fs);
@


1.18
log
@Move logging into cmd_find_target rather than each function.
@
text
@d1 1
a1 1
/* $OpenBSD: cmd-find.c,v 1.17 2015/10/28 09:51:55 nicm Exp $ */
a29 25
#define CMD_FIND_PREFER_UNATTACHED 0x1
#define CMD_FIND_QUIET 0x2
#define CMD_FIND_WINDOW_INDEX 0x4
#define CMD_FIND_DEFAULT_MARKED 0x8
#define CMD_FIND_EXACT_SESSION 0x10
#define CMD_FIND_EXACT_WINDOW 0x20

enum cmd_find_type {
	CMD_FIND_PANE,
	CMD_FIND_WINDOW,
	CMD_FIND_SESSION,
};

struct cmd_find_state {
	struct cmd_q		*cmdq;
	int			 flags;
	struct cmd_find_state	*current;

	struct session          *s;
	struct winlink          *wl;
	struct window		*w;
	struct window_pane      *wp;
	int			 idx;
};

a55 3
struct cmd_find_state	*cmd_find_target(struct cmd_q *, const char *,
	    enum cmd_find_type, int);

a1086 100
/* Find the current session. */
struct session *
cmd_find_current(struct cmd_q *cmdq)
{
	struct cmd_find_state	*fs;
	int			 flags = CMD_FIND_QUIET;

	fs = cmd_find_target(cmdq, NULL, CMD_FIND_SESSION, flags);
	if (fs == NULL)
		return (NULL);

	return (fs->s);
}

/* Find the target session or report an error and return NULL. */
struct session *
cmd_find_session(struct cmd_q *cmdq, const char *target, int prefer_unattached)
{
	struct cmd_find_state	*fs;
	int			 flags = 0;

	if (prefer_unattached)
		flags |= CMD_FIND_PREFER_UNATTACHED;

	fs = cmd_find_target(cmdq, target, CMD_FIND_SESSION, flags);
	if (fs == NULL)
		return (NULL);

	return (fs->s);
}

/* Find the target window or report an error and return NULL. */
struct winlink *
cmd_find_window(struct cmd_q *cmdq, const char *target, struct session **sp)
{
	struct cmd_find_state	*fs;

	fs = cmd_find_target(cmdq, target, CMD_FIND_WINDOW, 0);
	if (fs == NULL)
		return (NULL);

	if (sp != NULL)
		*sp = fs->s;
	return (fs->wl);
}

/* Find the target window, defaulting to marked rather than current. */
struct winlink *
cmd_find_window_marked(struct cmd_q *cmdq, const char *target,
    struct session **sp)
{
	struct cmd_find_state	*fs;
	int			 flags = CMD_FIND_DEFAULT_MARKED;

	fs = cmd_find_target(cmdq, target, CMD_FIND_WINDOW, flags);
	if (fs == NULL)
		return (NULL);

	if (sp != NULL)
		*sp = fs->s;
	return (fs->wl);
}

/* Find the target pane and report an error and return NULL. */
struct winlink *
cmd_find_pane(struct cmd_q *cmdq, const char *target, struct session **sp,
    struct window_pane **wpp)
{
	struct cmd_find_state	*fs;

	fs = cmd_find_target(cmdq, target, CMD_FIND_PANE, 0);
	if (fs == NULL)
		return (NULL);

	if (sp != NULL)
		*sp = fs->s;
	if (wpp != NULL)
		*wpp = fs->wp;
	return (fs->wl);
}

/* Find the target pane, defaulting to marked rather than current. */
struct winlink *
cmd_find_pane_marked(struct cmd_q *cmdq, const char *target,
    struct session **sp, struct window_pane **wpp)
{
	struct cmd_find_state	*fs;
	int			 flags = CMD_FIND_DEFAULT_MARKED;

	fs = cmd_find_target(cmdq, target, CMD_FIND_PANE, flags);
	if (fs == NULL)
		return (NULL);

	if (sp != NULL)
		*sp = fs->s;
	if (wpp != NULL)
		*wpp = fs->wp;
	return (fs->wl);
}

a1134 21
}

/*
 * Find the target session and window index, whether or not it exists in the
 * session. Return -2 on error or -1 if no window index is specified. This is
 * used when parsing an argument for a window target that may not exist (for
 * example if it is going to be created).
 */
int
cmd_find_index(struct cmd_q *cmdq, const char *target, struct session **sp)
{
	struct cmd_find_state	*fs;
	int			 flags = CMD_FIND_WINDOW_INDEX;

	fs = cmd_find_target(cmdq, target, CMD_FIND_WINDOW, flags);
	if (fs == NULL)
		return (-2);

	if (sp != NULL)
		*sp = fs->s;
	return (fs->idx);
@


1.17
log
@Like options, move the environ struct into environ.c.
@
text
@d1 1
a1 1
/* $OpenBSD: cmd-find.c,v 1.16 2015/10/27 13:23:24 nicm Exp $ */
d79 1
a79 1
void	cmd_find_log_state(const char *, const char *, struct cmd_find_state *);
d830 7
d883 1
a883 1
		return (&fs);
d898 1
a898 1
		return (&fs);
d1063 1
d1068 1
d1072 1
d1094 1
a1094 1
cmd_find_log_state(const char *f, const char *target, struct cmd_find_state *fs)
a1095 4
	log_debug("%s: target %s%s", f, target == NULL ? "none" : target,
	    fs != NULL ? "" : " (failed)");
	if (fs == NULL)
		return;
d1097 1
a1097 1
		log_debug("\ts=$%u", fs->s->id);
d1099 1
a1099 1
		log_debug("\ts=none");
d1101 1
a1101 1
		log_debug("\twl=%u %d w=@@%u %s", fs->wl->idx,
d1104 1
a1104 1
		log_debug("\twl=none");
d1106 1
a1106 1
		log_debug("\twp=%%%u", fs->wp->id);
d1108 1
a1108 1
		log_debug("\twp=none");
d1110 1
a1110 1
		log_debug("\tidx=%d", fs->idx);
d1112 1
a1112 1
		log_debug("\tidx=none");
a1122 1
	cmd_find_log_state(__func__, NULL, fs);
a1139 1
	cmd_find_log_state(__func__, target, fs);
a1152 1
	cmd_find_log_state(__func__, target, fs);
a1169 1
	cmd_find_log_state(__func__, target, fs);
a1185 1
	cmd_find_log_state(__func__, target, fs);
a1204 1
	cmd_find_log_state(__func__, target, fs);
a1277 1
	cmd_find_log_state(__func__, target, fs);
@


1.16
log
@Break the common process set up, event loop and imsg dispatch code
between server and client out into a separate internal API. This will
make it easier to add another process.
@
text
@d1 1
a1 1
/* $OpenBSD: cmd-find.c,v 1.15 2015/10/23 16:29:07 nicm Exp $ */
d124 1
a124 1
	envent = environ_find(&c->environ, "TMUX");
@


1.15
log
@If $TMUX is set, and we are unsure about the session, use it.
@
text
@d1 1
a1 1
/* $OpenBSD: cmd-find.c,v 1.14 2015/10/22 11:23:00 nicm Exp $ */
d132 2
a133 2
	log_debug("client %d TMUX is %s (session @@%u)", c->ibuf.fd,
	    envent->value, session);
d336 2
d370 3
a372 1
	if (cmdq->client != NULL && cmdq->client->session != NULL)
d374 1
d383 1
d1229 1
d1261 1
@


1.14
log
@If the pane is still on all_window_panes but not actually connected to
window or session (which can happen if it is killed during a command
sequence and something else has a reference), fall back to the best
effort. Fixes "tmux killw\; detach" for Rudis Muiznieks.
@
text
@d1 1
a1 1
/* $OpenBSD: cmd-find.c,v 1.13 2015/09/14 13:22:02 nicm Exp $ */
d26 1
d55 1
d114 27
d224 6
d315 3
a317 1
	fs->s = cmd_find_best_session(NULL, 0, fs->flags);
@


1.13
log
@Remove some extra blank lines.
@
text
@d1 1
a1 1
/* $OpenBSD: cmd-find.c,v 1.12 2015/08/13 15:02:23 nicm Exp $ */
d258 2
a259 10
	if (wp == NULL) {
		fs->s = cmd_find_best_session(NULL, 0, fs->flags);
		if (fs->s == NULL)
			return (-1);
		fs->wl = fs->s->curw;
		fs->idx = fs->wl->idx;
		fs->w = fs->wl->window;
		fs->wp = fs->w->active;
		return (0);
	}
d266 16
a281 1
	if (cmd_find_best_session_with_window(fs) != 0)
d283 4
@


1.12
log
@right-up should be right-of, also rename the values too.
@
text
@d1 1
a1 1
/* $OpenBSD: cmd-find.c,v 1.11 2015/08/12 08:55:20 nicm Exp $ */
a563 1

@


1.11
log
@Rename left/right/up/down relative to active pane to add -of suffix
(left-of/right-of/etc) to remove conflict with left/right meaning
leftmost or rightmost pane. From Ben Boeckel.
@
text
@d1 1
a1 1
/* $OpenBSD: cmd-find.c,v 1.10 2015/06/05 09:09:08 nicm Exp $ */
d105 4
a108 4
	{ "{up-of}", "{up}" },
	{ "{down-of}", "{down}" },
	{ "{left-of}", "{left}" },
	{ "{right-up}", "{right}" },
d702 1
a702 1
	} else if (strcmp(pane, "{up}") == 0) {
d707 1
a707 1
	} else if (strcmp(pane, "{down}") == 0) {
d712 1
a712 1
	} else if (strcmp(pane, "{left}") == 0) {
d717 1
a717 1
	} else if (strcmp(pane, "{right}") == 0) {
@


1.10
log
@Fix a warning.
@
text
@d1 1
a1 1
/* $OpenBSD: cmd-find.c,v 1.9 2015/06/05 08:14:16 nicm Exp $ */
d105 4
a108 4
	{ "{up}", "{up}" },
	{ "{down}", "{down}" },
	{ "{left}", "{left}" },
	{ "{right}", "{right}" },
@


1.9
log
@Make it so that if a window or session target is prefixed with an =,
only an exact name or index match is accepted, no special character,
prefix match, or fnmatch.
@
text
@d1 1
a1 1
/* $OpenBSD: cmd-find.c,v 1.8 2015/06/04 11:43:51 nicm Exp $ */
d479 1
a479 1
	if (!exact && window[0] == '+' || window[0] == '-') {
@


1.8
log
@Add support for a single "marked pane". There is one marked pane in the
server at a time; it may be toggled or cleared with select-pane -m and
-M (the border is highlighted). A new target '~' or '{marked}' specifies
the marked pane to commands and it is the default target for the
swap-pane and join-pane -s flag (this makes them much simpler to use -
mark the source pane and then change to the target pane to run swapp or
joinp).
@
text
@d1 1
a1 1
/* $OpenBSD: cmd-find.c,v 1.7 2015/05/07 11:42:56 nicm Exp $ */
d33 2
d386 4
d464 1
a464 1
	int		 idx, n;
d468 1
d479 1
a479 1
	if (window[0] == '+' || window[0] == '-') {
d509 23
a531 21
	if (strcmp(window, "!") == 0) {
		fs->wl = TAILQ_FIRST(&fs->s->lastw);
		if (fs->wl == NULL)
			return (-1);
		fs->idx = fs->wl->idx;
		fs->w = fs->wl->window;
		return (0);
	} else if (strcmp(window, "^") == 0) {
		fs->wl = RB_MIN(winlinks, &fs->s->windows);
		if (fs->wl == NULL)
			return (-1);
		fs->idx = fs->wl->idx;
		fs->w = fs->wl->window;
		return (0);
	} else if (strcmp(window, "$") == 0) {
		fs->wl = RB_MAX(winlinks, &fs->s->windows);
		if (fs->wl == NULL)
			return (-1);
		fs->idx = fs->wl->idx;
		fs->w = fs->wl->window;
		return (0);
d535 12
a546 10
	idx = strtonum(window, 0, INT_MAX, &errstr);
	if (errstr == NULL) {
		if (fs->flags & CMD_FIND_WINDOW_INDEX) {
			fs->idx = idx;
			return (0);
		}
		fs->wl = winlink_find_by_index(&fs->s->windows, idx);
		if (fs->wl != NULL) {
			fs->w = fs->wl->window;
			return (0);
d565 5
d885 10
@


1.7
log
@Style spacing nits.
@
text
@d1 1
a1 1
/* $OpenBSD: cmd-find.c,v 1.6 2015/04/28 12:09:24 nicm Exp $ */
d32 1
d763 8
a770 1
	if (cmd_find_current_session(&current) != 0) {
d809 15
a823 1
	copy = xstrdup(target);
d826 1
d1079 18
d1105 20
@


1.6
log
@If looking for an index, don't fill in window when given a session.
@
text
@d1 1
a1 1
/* $OpenBSD: cmd-find.c,v 1.5 2015/04/28 11:57:20 nicm Exp $ */
d196 1
a196 1
		slist = xreallocarray (slist, ssize + 1, sizeof *slist);
d204 1
a204 1
	free (slist);
d332 1
a332 1
			clist = xreallocarray (clist, csize + 1, sizeof *clist);
d742 1
a742 1
	memset (fs, 0, sizeof *fs);
@


1.5
log
@Do not do a search for the tty path if there isn't one.
@
text
@d1 1
a1 1
/* $OpenBSD: cmd-find.c,v 1.4 2015/04/28 11:33:17 nicm Exp $ */
d437 5
a441 3
		fs->wl = fs->s->curw;
		fs->idx = fs->wl->idx;
		fs->w = fs->wl->window;
@


1.4
log
@If can't find pane as a pane, try as a window; likewise if can't find
window as a session.
@
text
@d1 1
a1 1
/* $OpenBSD: cmd-find.c,v 1.3 2015/04/27 22:58:58 nicm Exp $ */
d246 7
a252 4
	RB_FOREACH(wp, window_pane_tree, &all_window_panes) {
		if (strcmp(wp->tty, fs->cmdq->client->tty.path) == 0)
			break;
	}
@


1.3
log
@Do not include unattached clients when trying to find one for target.
@
text
@d1 1
a1 1
/* $OpenBSD: cmd-find.c,v 1.2 2015/04/27 22:42:10 nicm Exp $ */
d429 12
a440 1
	return (cmd_find_get_window_with_session(fs, window));
d606 1
a606 1
	/* Not a pane id, so use the current session and window. */
d613 10
a622 1
	return (cmd_find_get_pane_with_window(fs, pane));
@


1.2
log
@Assign to the right variable when comparing clients.
@
text
@d1 1
a1 1
/* $OpenBSD: cmd-find.c,v 1.1 2015/04/27 16:25:57 nicm Exp $ */
d128 2
d135 2
@


1.1
log
@Rewrite of the target resolution internals to be simpler and more
consistent but with much less duplication, but keeping the same internal
API. Also adds more readable aliases for some of the special tokens used
in targets (eg "{start}" instead of "^"). Some behaviours may have
changed, for example prefix matches now happen before fnmatch.
@
text
@d1 1
a1 1
/* $OpenBSD: cmd.c,v 1.100 2015/04/21 22:42:27 nicm Exp $ */
d134 1
a134 1
				c_loop = c;
@

