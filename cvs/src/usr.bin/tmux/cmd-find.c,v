head	1.57;
access;
symbols
	OPENBSD_6_2:1.57.0.4
	OPENBSD_6_2_BASE:1.57
	OPENBSD_6_1:1.42.0.4
	OPENBSD_6_1_BASE:1.42
	OPENBSD_6_0:1.32.0.2
	OPENBSD_6_0_BASE:1.32
	OPENBSD_5_9:1.31.0.2
	OPENBSD_5_9_BASE:1.31
	OPENBSD_5_8:1.10.0.4
	OPENBSD_5_8_BASE:1.10;
locks; strict;
comment	@ * @;


1.57
date	2017.08.30.10.33.57;	author nicm;	state Exp;
branches;
next	1.56;
commitid	Zpm5Qq40TI2OxytA;

1.56
date	2017.08.28.12.36.38;	author nicm;	state Exp;
branches;
next	1.55;
commitid	jveVHok8dlNw4o8H;

1.55
date	2017.07.07.07.13.14;	author nicm;	state Exp;
branches;
next	1.54;
commitid	XRhhDSiflYTkDI52;

1.54
date	2017.06.16.15.12.38;	author nicm;	state Exp;
branches;
next	1.53;
commitid	xDbTOdwDoeiZKEo6;

1.53
date	2017.06.14.07.37.17;	author nicm;	state Exp;
branches;
next	1.52;
commitid	qtXm1N0pMktu8M53;

1.52
date	2017.04.22.12.08.41;	author nicm;	state Exp;
branches;
next	1.51;
commitid	nT0YDSWP4lX6n1AT;

1.51
date	2017.04.22.10.22.39;	author nicm;	state Exp;
branches;
next	1.50;
commitid	RXMp6wwG5a5Y82bo;

1.50
date	2017.04.21.22.23.24;	author nicm;	state Exp;
branches;
next	1.49;
commitid	N4wUb6jGvG8wvogM;

1.49
date	2017.04.21.22.00.06;	author nicm;	state Exp;
branches;
next	1.48;
commitid	HRK7pw367z8KpcoV;

1.48
date	2017.04.21.20.26.34;	author nicm;	state Exp;
branches;
next	1.47;
commitid	utIGVdoSurUxfh14;

1.47
date	2017.04.21.17.22.20;	author nicm;	state Exp;
branches;
next	1.46;
commitid	vF4GzIrs1TJPdLpP;

1.46
date	2017.04.21.14.09.44;	author nicm;	state Exp;
branches;
next	1.45;
commitid	EVv6VwyOvKb6JnQz;

1.45
date	2017.04.21.14.01.19;	author nicm;	state Exp;
branches;
next	1.44;
commitid	6dh4rgGOD5wckeD9;

1.44
date	2017.04.05.11.04.48;	author nicm;	state Exp;
branches;
next	1.43;
commitid	InkMT4w2vxmbNgcS;

1.43
date	2017.04.05.10.49.46;	author nicm;	state Exp;
branches;
next	1.42;
commitid	1mjoRYvghWl25dW0;

1.42
date	2017.03.13.10.53.32;	author nicm;	state Exp;
branches;
next	1.41;
commitid	mSBoFdc6RNT6wc48;

1.41
date	2017.03.11.15.16.08;	author nicm;	state Exp;
branches;
next	1.40;
commitid	elvVIJV7Kyw8XbIL;

1.40
date	2016.11.16.00.24.03;	author nicm;	state Exp;
branches;
next	1.39;
commitid	ZQAQdE9Fy4gBpQvj;

1.39
date	2016.10.18.12.51.26;	author nicm;	state Exp;
branches;
next	1.38;
commitid	hBZfugPDlIuJ2Yqo;

1.38
date	2016.10.16.22.06.40;	author nicm;	state Exp;
branches;
next	1.37;
commitid	j0FZs70gSPCmpqWI;

1.37
date	2016.10.16.19.04.05;	author nicm;	state Exp;
branches;
next	1.36;
commitid	pxm6osuE99zELpkU;

1.36
date	2016.10.16.17.55.14;	author nicm;	state Exp;
branches;
next	1.35;
commitid	1xIYFpLYkPIXNEvU;

1.35
date	2016.10.15.00.09.30;	author nicm;	state Exp;
branches;
next	1.34;
commitid	X2XXRCKiqkzI3Ni0;

1.34
date	2016.10.13.10.01.49;	author nicm;	state Exp;
branches;
next	1.33;
commitid	AFoah05fh4b2e28V;

1.33
date	2016.10.10.21.51.39;	author nicm;	state Exp;
branches;
next	1.32;
commitid	TaZ3kOtGiWwKofka;

1.32
date	2016.03.03.14.14.46;	author nicm;	state Exp;
branches;
next	1.31;
commitid	rhRImjgSdM3WUy9U;

1.31
date	2016.01.19.16.01.30;	author nicm;	state Exp;
branches;
next	1.30;
commitid	gdaGX7HuLjiMTGV0;

1.30
date	2016.01.19.15.59.12;	author nicm;	state Exp;
branches;
next	1.29;
commitid	P3qmSOx6KrDBsb0c;

1.29
date	2016.01.16.00.36.53;	author nicm;	state Exp;
branches;
next	1.28;
commitid	416B5CZCT2xuRFOv;

1.28
date	2015.12.17.23.08.22;	author nicm;	state Exp;
branches;
next	1.27;
commitid	tULDPNG9fVfuJMNj;

1.27
date	2015.12.16.21.50.37;	author nicm;	state Exp;
branches;
next	1.26;
commitid	Bam1GajuDZzmKjyE;

1.26
date	2015.12.15.14.32.55;	author nicm;	state Exp;
branches;
next	1.25;
commitid	qnzhdpYqhUvOfqsj;

1.25
date	2015.12.15.00.45.02;	author nicm;	state Exp;
branches;
next	1.24;
commitid	2izKrdKD7SBTTeRr;

1.24
date	2015.12.15.00.11.24;	author nicm;	state Exp;
branches;
next	1.23;
commitid	Va8fPQXBKEe5bUey;

1.23
date	2015.12.15.00.00.01;	author nicm;	state Exp;
branches;
next	1.22;
commitid	yMmY7FLVcToE15ZM;

1.22
date	2015.12.14.23.30.58;	author nicm;	state Exp;
branches;
next	1.21;
commitid	Gp2loryMvVho4B6E;

1.21
date	2015.12.13.17.55.14;	author nicm;	state Exp;
branches;
next	1.20;
commitid	Fyn4vblJtlp30z7Q;

1.20
date	2015.12.13.16.44.35;	author nicm;	state Exp;
branches;
next	1.19;
commitid	CpoKtPSIEn27BKfz;

1.19
date	2015.12.13.15.32.12;	author nicm;	state Exp;
branches;
next	1.18;
commitid	aaVCH5jHZVqoxGFq;

1.18
date	2015.12.13.15.00.37;	author nicm;	state Exp;
branches;
next	1.17;
commitid	6wGIbv1dZAryRJ3h;

1.17
date	2015.10.28.09.51.55;	author nicm;	state Exp;
branches;
next	1.16;
commitid	eGVGKzVVYKHFvkn4;

1.16
date	2015.10.27.13.23.24;	author nicm;	state Exp;
branches;
next	1.15;
commitid	g6GdEJXfBNprXHEK;

1.15
date	2015.10.23.16.29.07;	author nicm;	state Exp;
branches;
next	1.14;
commitid	JbQgJmki1PJ0qxEt;

1.14
date	2015.10.22.11.23.00;	author nicm;	state Exp;
branches;
next	1.13;
commitid	vohpt64dxJLwL9xf;

1.13
date	2015.09.14.13.22.02;	author nicm;	state Exp;
branches;
next	1.12;
commitid	kxByHmNsW2wTQbKK;

1.12
date	2015.08.13.15.02.23;	author nicm;	state Exp;
branches;
next	1.11;
commitid	seHx7PqD0HLBi7an;

1.11
date	2015.08.12.08.55.20;	author nicm;	state Exp;
branches;
next	1.10;
commitid	HUSsY4NbLebDVceS;

1.10
date	2015.06.05.09.09.08;	author nicm;	state Exp;
branches;
next	1.9;
commitid	55l1YjvEJoakL5IE;

1.9
date	2015.06.05.08.14.16;	author nicm;	state Exp;
branches;
next	1.8;
commitid	FezlkQJJMDFfG1I5;

1.8
date	2015.06.04.11.43.51;	author nicm;	state Exp;
branches;
next	1.7;
commitid	rAvOUA4CI6VK3gQ6;

1.7
date	2015.05.07.11.42.56;	author nicm;	state Exp;
branches;
next	1.6;
commitid	aHjVLgOHz1Tie9FQ;

1.6
date	2015.04.28.12.09.24;	author nicm;	state Exp;
branches;
next	1.5;
commitid	TSWSz7OdNU4RK1mM;

1.5
date	2015.04.28.11.57.20;	author nicm;	state Exp;
branches;
next	1.4;
commitid	GLwn0zx70t4afH76;

1.4
date	2015.04.28.11.33.17;	author nicm;	state Exp;
branches;
next	1.3;
commitid	3DppsOIbzCswrl9A;

1.3
date	2015.04.27.22.58.58;	author nicm;	state Exp;
branches;
next	1.2;
commitid	CJl5paY8uXxECFrf;

1.2
date	2015.04.27.22.42.10;	author nicm;	state Exp;
branches;
next	1.1;
commitid	6ZVVmrTFqj5k9PGs;

1.1
date	2015.04.27.16.25.57;	author nicm;	state Exp;
branches;
next	;
commitid	0WBWxxZyxaAFVhmn;


desc
@@


1.57
log
@Pass flags into cmd_find_from_* to fix prefer-unattached, reported by
Thomas Sattler.
@
text
@/* $OpenBSD: cmd-find.c,v 1.56 2017/08/28 12:36:38 nicm Exp $ */

/*
 * Copyright (c) 2015 Nicholas Marriott <nicholas.marriott@@gmail.com>
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF MIND, USE, DATA OR PROFITS, WHETHER
 * IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING
 * OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */

#include <sys/types.h>

#include <fnmatch.h>
#include <limits.h>
#include <stdlib.h>
#include <string.h>
#include <paths.h>
#include <unistd.h>

#include "tmux.h"

static int	cmd_find_session_better(struct session *, struct session *,
		    int);
static struct session *cmd_find_best_session(struct session **, u_int, int);
static int	cmd_find_best_session_with_window(struct cmd_find_state *);
static int	cmd_find_best_winlink_with_window(struct cmd_find_state *);

static const char *cmd_find_map_table(const char *[][2], const char *);

static int	cmd_find_get_session(struct cmd_find_state *, const char *);
static int	cmd_find_get_window(struct cmd_find_state *, const char *, int);
static int	cmd_find_get_window_with_session(struct cmd_find_state *,
		    const char *);
static int	cmd_find_get_pane(struct cmd_find_state *, const char *, int);
static int	cmd_find_get_pane_with_session(struct cmd_find_state *,
		    const char *);
static int	cmd_find_get_pane_with_window(struct cmd_find_state *,
		    const char *);

static const char *cmd_find_session_table[][2] = {
	{ NULL, NULL }
};
static const char *cmd_find_window_table[][2] = {
	{ "{start}", "^" },
	{ "{last}", "!" },
	{ "{end}", "$" },
	{ "{next}", "+" },
	{ "{previous}", "-" },
	{ NULL, NULL }
};
static const char *cmd_find_pane_table[][2] = {
	{ "{last}", "!" },
	{ "{next}", "+" },
	{ "{previous}", "-" },
	{ "{top}", "top" },
	{ "{bottom}", "bottom" },
	{ "{left}", "left" },
	{ "{right}", "right" },
	{ "{top-left}", "top-left" },
	{ "{top-right}", "top-right" },
	{ "{bottom-left}", "bottom-left" },
	{ "{bottom-right}", "bottom-right" },
	{ "{up-of}", "{up-of}" },
	{ "{down-of}", "{down-of}" },
	{ "{left-of}", "{left-of}" },
	{ "{right-of}", "{right-of}" },
	{ NULL, NULL }
};

/* Get session from TMUX if present. */
static struct session *
cmd_find_try_TMUX(struct client *c)
{
	struct environ_entry	*envent;
	char			 tmp[256];
	long long		 pid;
	u_int			 session;

	envent = environ_find(c->environ, "TMUX");
	if (envent == NULL)
		return (NULL);

	if (sscanf(envent->value, "%255[^,],%lld,%d", tmp, &pid, &session) != 3)
		return (NULL);
	if (pid != getpid())
		return (NULL);
	log_debug("client %p TMUX %s (session @@%u)", c, envent->value, session);
	return (session_find_by_id(session));
}

/* Find pane containing client if any. */
static struct window_pane *
cmd_find_inside_pane(struct client *c)
{
	struct window_pane	*wp;

	if (c == NULL)
		return (NULL);

	RB_FOREACH(wp, window_pane_tree, &all_window_panes) {
		if (strcmp(wp->tty, c->ttyname) == 0)
			break;
	}
	return (wp);
}

/* Is this client better? */
static int
cmd_find_client_better(struct client *c, struct client *than)
{
	if (than == NULL)
		return (1);
	return (timercmp(&c->activity_time, &than->activity_time, >));
}

/* Find best client for session. */
static struct client *
cmd_find_best_client(struct session *s)
{
	struct client	*c_loop, *c;

	if (s->flags & SESSION_UNATTACHED)
		s = NULL;

	c = NULL;
	TAILQ_FOREACH(c_loop, &clients, entry) {
		if (c_loop->session == NULL)
			continue;
		if (s != NULL && c_loop->session != s)
			continue;
		if (cmd_find_client_better(c_loop, c))
			c = c_loop;
	}
	return (c);
}

/* Is this session better? */
static int
cmd_find_session_better(struct session *s, struct session *than, int flags)
{
	int	attached;

	if (than == NULL)
		return (1);
	if (flags & CMD_FIND_PREFER_UNATTACHED) {
		attached = (~than->flags & SESSION_UNATTACHED);
		if (attached && (s->flags & SESSION_UNATTACHED))
			return (1);
		else if (!attached && (~s->flags & SESSION_UNATTACHED))
			return (0);
	}
	return (timercmp(&s->activity_time, &than->activity_time, >));
}

/* Find best session from a list, or all if list is NULL. */
static struct session *
cmd_find_best_session(struct session **slist, u_int ssize, int flags)
{
	struct session	 *s_loop, *s;
	u_int		  i;

	s = NULL;
	if (slist != NULL) {
		for (i = 0; i < ssize; i++) {
			if (cmd_find_session_better(slist[i], s, flags))
				s = slist[i];
		}
	} else {
		RB_FOREACH(s_loop, sessions, &sessions) {
			if (cmd_find_session_better(s_loop, s, flags))
				s = s_loop;
		}
	}
	return (s);
}

/* Find best session and winlink for window. */
static int
cmd_find_best_session_with_window(struct cmd_find_state *fs)
{
	struct session	**slist = NULL;
	u_int		  ssize;
	struct session	 *s;

	ssize = 0;
	RB_FOREACH(s, sessions, &sessions) {
		if (!session_has(s, fs->w))
			continue;
		slist = xreallocarray(slist, ssize + 1, sizeof *slist);
		slist[ssize++] = s;
	}
	if (ssize == 0)
		goto fail;
	fs->s = cmd_find_best_session(slist, ssize, fs->flags);
	if (fs->s == NULL)
		goto fail;
	free(slist);
	return (cmd_find_best_winlink_with_window(fs));

fail:
	free(slist);
	return (-1);
}

/*
 * Find the best winlink for a window (the current if it contains the pane,
 * otherwise the first).
 */
static int
cmd_find_best_winlink_with_window(struct cmd_find_state *fs)
{
	struct winlink	 *wl, *wl_loop;

	wl = NULL;
	if (fs->s->curw != NULL && fs->s->curw->window == fs->w)
		wl = fs->s->curw;
	else {
		RB_FOREACH(wl_loop, winlinks, &fs->s->windows) {
			if (wl_loop->window == fs->w) {
				wl = wl_loop;
				break;
			}
		}
	}
	if (wl == NULL)
		return (-1);
	fs->wl = wl;
	fs->idx = fs->wl->idx;
	return (0);
}

/* Maps string in table. */
static const char *
cmd_find_map_table(const char *table[][2], const char *s)
{
	u_int	i;

	for (i = 0; table[i][0] != NULL; i++) {
		if (strcmp(s, table[i][0]) == 0)
			return (table[i][1]);
	}
	return (s);
}

/* Find session from string. Fills in s. */
static int
cmd_find_get_session(struct cmd_find_state *fs, const char *session)
{
	struct session	*s, *s_loop;
	struct client	*c;

	log_debug("%s: %s", __func__, session);

	/* Check for session ids starting with $. */
	if (*session == '$') {
		fs->s = session_find_by_id_str(session);
		if (fs->s == NULL)
			return (-1);
		return (0);
	}

	/* Look for exactly this session. */
	fs->s = session_find(session);
	if (fs->s != NULL)
		return (0);

	/* Look for as a client. */
	c = cmd_find_client(NULL, session, 1);
	if (c != NULL && c->session != NULL) {
		fs->s = c->session;
		return (0);
	}

	/* Stop now if exact only. */
	if (fs->flags & CMD_FIND_EXACT_SESSION)
		return (-1);

	/* Otherwise look for prefix. */
	s = NULL;
	RB_FOREACH(s_loop, sessions, &sessions) {
		if (strncmp(session, s_loop->name, strlen(session)) == 0) {
			if (s != NULL)
				return (-1);
			s = s_loop;
		}
	}
	if (s != NULL) {
		fs->s = s;
		return (0);
	}

	/* Then as a pattern. */
	s = NULL;
	RB_FOREACH(s_loop, sessions, &sessions) {
		if (fnmatch(session, s_loop->name, 0) == 0) {
			if (s != NULL)
				return (-1);
			s = s_loop;
		}
	}
	if (s != NULL) {
		fs->s = s;
		return (0);
	}

	return (-1);
}

/* Find window from string. Fills in s, wl, w. */
static int
cmd_find_get_window(struct cmd_find_state *fs, const char *window, int only)
{
	log_debug("%s: %s", __func__, window);

	/* Check for window ids starting with @@. */
	if (*window == '@@') {
		fs->w = window_find_by_id_str(window);
		if (fs->w == NULL)
			return (-1);
		return (cmd_find_best_session_with_window(fs));
	}

	/* Not a window id, so use the current session. */
	fs->s = fs->current->s;

	/* We now only need to find the winlink in this session. */
	if (cmd_find_get_window_with_session(fs, window) == 0)
		return (0);

	/* Otherwise try as a session itself. */
	if (!only && cmd_find_get_session(fs, window) == 0) {
		fs->wl = fs->s->curw;
		fs->w = fs->wl->window;
		if (~fs->flags & CMD_FIND_WINDOW_INDEX)
			fs->idx = fs->wl->idx;
		return (0);
	}

	return (-1);
}

/*
 * Find window from string, assuming it is in given session. Needs s, fills in
 * wl and w.
 */
static int
cmd_find_get_window_with_session(struct cmd_find_state *fs, const char *window)
{
	struct winlink	*wl;
	const char	*errstr;
	int		 idx, n, exact;
	struct session	*s;

	log_debug("%s: %s", __func__, window);
	exact = (fs->flags & CMD_FIND_EXACT_WINDOW);

	/*
	 * Start with the current window as the default. So if only an index is
	 * found, the window will be the current.
	 */
	fs->wl = fs->s->curw;
	fs->w = fs->wl->window;

	/* Check for window ids starting with @@. */
	if (*window == '@@') {
		fs->w = window_find_by_id_str(window);
		if (fs->w == NULL || !session_has(fs->s, fs->w))
			return (-1);
		return (cmd_find_best_winlink_with_window(fs));
	}

	/* Try as an offset. */
	if (!exact && (window[0] == '+' || window[0] == '-')) {
		if (window[1] != '\0')
			n = strtonum(window + 1, 1, INT_MAX, NULL);
		else
			n = 1;
		s = fs->s;
		if (fs->flags & CMD_FIND_WINDOW_INDEX) {
			if (window[0] == '+') {
				if (INT_MAX - s->curw->idx < n)
					return (-1);
				fs->idx = s->curw->idx + n;
			} else {
				if (n < s->curw->idx)
					return (-1);
				fs->idx = s->curw->idx - n;
			}
			return (0);
		}
		if (window[0] == '+')
			fs->wl = winlink_next_by_number(s->curw, s, n);
		else
			fs->wl = winlink_previous_by_number(s->curw, s, n);
		if (fs->wl != NULL) {
			fs->idx = fs->wl->idx;
			fs->w = fs->wl->window;
			return (0);
		}
	}

	/* Try special characters. */
	if (!exact) {
		if (strcmp(window, "!") == 0) {
			fs->wl = TAILQ_FIRST(&fs->s->lastw);
			if (fs->wl == NULL)
				return (-1);
			fs->idx = fs->wl->idx;
			fs->w = fs->wl->window;
			return (0);
		} else if (strcmp(window, "^") == 0) {
			fs->wl = RB_MIN(winlinks, &fs->s->windows);
			if (fs->wl == NULL)
				return (-1);
			fs->idx = fs->wl->idx;
			fs->w = fs->wl->window;
			return (0);
		} else if (strcmp(window, "$") == 0) {
			fs->wl = RB_MAX(winlinks, &fs->s->windows);
			if (fs->wl == NULL)
				return (-1);
			fs->idx = fs->wl->idx;
			fs->w = fs->wl->window;
			return (0);
		}
	}

	/* First see if this is a valid window index in this session. */
	if (window[0] != '+' && window[0] != '-') {
		idx = strtonum(window, 0, INT_MAX, &errstr);
		if (errstr == NULL) {
			if (fs->flags & CMD_FIND_WINDOW_INDEX) {
				fs->idx = idx;
				return (0);
			}
			fs->wl = winlink_find_by_index(&fs->s->windows, idx);
			if (fs->wl != NULL) {
				fs->w = fs->wl->window;
				return (0);
			}
		}
	}

	/* Look for exact matches, error if more than one. */
	fs->wl = NULL;
	RB_FOREACH(wl, winlinks, &fs->s->windows) {
		if (strcmp(window, wl->window->name) == 0) {
			if (fs->wl != NULL)
				return (-1);
			fs->wl = wl;
		}
	}
	if (fs->wl != NULL) {
		fs->idx = fs->wl->idx;
		fs->w = fs->wl->window;
		return (0);
	}

	/* Stop now if exact only. */
	if (exact)
		return (-1);

	/* Try as the start of a window name, error if multiple. */
	fs->wl = NULL;
	RB_FOREACH(wl, winlinks, &fs->s->windows) {
		if (strncmp(window, wl->window->name, strlen(window)) == 0) {
			if (fs->wl != NULL)
				return (-1);
			fs->wl = wl;
		}
	}
	if (fs->wl != NULL) {
		fs->idx = fs->wl->idx;
		fs->w = fs->wl->window;
		return (0);
	}

	/* Now look for pattern matches, again error if multiple. */
	fs->wl = NULL;
	RB_FOREACH(wl, winlinks, &fs->s->windows) {
		if (fnmatch(window, wl->window->name, 0) == 0) {
			if (fs->wl != NULL)
				return (-1);
			fs->wl = wl;
		}
	}
	if (fs->wl != NULL) {
		fs->idx = fs->wl->idx;
		fs->w = fs->wl->window;
		return (0);
	}

	return (-1);
}

/* Find pane from string. Fills in s, wl, w, wp. */
static int
cmd_find_get_pane(struct cmd_find_state *fs, const char *pane, int only)
{
	log_debug("%s: %s", __func__, pane);

	/* Check for pane ids starting with %. */
	if (*pane == '%') {
		fs->wp = window_pane_find_by_id_str(pane);
		if (fs->wp == NULL)
			return (-1);
		fs->w = fs->wp->window;
		return (cmd_find_best_session_with_window(fs));
	}

	/* Not a pane id, so try the current session and window. */
	fs->s = fs->current->s;
	fs->wl = fs->current->wl;
	fs->idx = fs->current->idx;
	fs->w = fs->current->w;

	/* We now only need to find the pane in this window. */
	if (cmd_find_get_pane_with_window(fs, pane) == 0)
		return (0);

	/* Otherwise try as a window itself (this will also try as session). */
	if (!only && cmd_find_get_window(fs, pane, 0) == 0) {
		fs->wp = fs->w->active;
		return (0);
	}

	return (-1);
}

/*
 * Find pane from string, assuming it is in given session. Needs s, fills in wl
 * and w and wp.
 */
static int
cmd_find_get_pane_with_session(struct cmd_find_state *fs, const char *pane)
{
	log_debug("%s: %s", __func__, pane);

	/* Check for pane ids starting with %. */
	if (*pane == '%') {
		fs->wp = window_pane_find_by_id_str(pane);
		if (fs->wp == NULL)
			return (-1);
		fs->w = fs->wp->window;
		return (cmd_find_best_winlink_with_window(fs));
	}

	/* Otherwise use the current window. */
	fs->wl = fs->s->curw;
	fs->idx = fs->wl->idx;
	fs->w = fs->wl->window;

	/* Now we just need to look up the pane. */
	return (cmd_find_get_pane_with_window(fs, pane));
}

/*
 * Find pane from string, assuming it is in the given window. Needs w, fills in
 * wp.
 */
static int
cmd_find_get_pane_with_window(struct cmd_find_state *fs, const char *pane)
{
	const char		*errstr;
	int			 idx;
	struct window_pane	*wp;
	u_int			 n;

	log_debug("%s: %s", __func__, pane);

	/* Check for pane ids starting with %. */
	if (*pane == '%') {
		fs->wp = window_pane_find_by_id_str(pane);
		if (fs->wp == NULL)
			return (-1);
		if (fs->wp->window != fs->w)
			return (-1);
		return (0);
	}

	/* Try special characters. */
	if (strcmp(pane, "!") == 0) {
		if (fs->w->last == NULL)
			return (-1);
		fs->wp = fs->w->last;
		if (fs->wp == NULL)
			return (-1);
		return (0);
	} else if (strcmp(pane, "{up-of}") == 0) {
		fs->wp = window_pane_find_up(fs->w->active);
		if (fs->wp == NULL)
			return (-1);
		return (0);
	} else if (strcmp(pane, "{down-of}") == 0) {
		fs->wp = window_pane_find_down(fs->w->active);
		if (fs->wp == NULL)
			return (-1);
		return (0);
	} else if (strcmp(pane, "{left-of}") == 0) {
		fs->wp = window_pane_find_left(fs->w->active);
		if (fs->wp == NULL)
			return (-1);
		return (0);
	} else if (strcmp(pane, "{right-of}") == 0) {
		fs->wp = window_pane_find_right(fs->w->active);
		if (fs->wp == NULL)
			return (-1);
		return (0);
	}

	/* Try as an offset. */
	if (pane[0] == '+' || pane[0] == '-') {
		if (pane[1] != '\0')
			n = strtonum(pane + 1, 1, INT_MAX, NULL);
		else
			n = 1;
		wp = fs->w->active;
		if (pane[0] == '+')
			fs->wp = window_pane_next_by_number(fs->w, wp, n);
		else
			fs->wp = window_pane_previous_by_number(fs->w, wp, n);
		if (fs->wp != NULL)
			return (0);
	}

	/* Get pane by index. */
	idx = strtonum(pane, 0, INT_MAX, &errstr);
	if (errstr == NULL) {
		fs->wp = window_pane_at_index(fs->w, idx);
		if (fs->wp != NULL)
			return (0);
	}

	/* Try as a description. */
	fs->wp = window_find_string(fs->w, pane);
	if (fs->wp != NULL)
		return (0);

	return (-1);
}

/* Clear state. */
void
cmd_find_clear_state(struct cmd_find_state *fs, int flags)
{
	memset(fs, 0, sizeof *fs);

	fs->flags = flags;

	fs->idx = -1;
}

/* Check if state is empty. */
int
cmd_find_empty_state(struct cmd_find_state *fs)
{
	if (fs->s == NULL && fs->wl == NULL && fs->w == NULL && fs->wp == NULL)
		return (1);
	return (0);
}

/* Check if a state if valid. */
int
cmd_find_valid_state(struct cmd_find_state *fs)
{
	struct winlink	*wl;

	if (fs->s == NULL || fs->wl == NULL || fs->w == NULL || fs->wp == NULL)
		return (0);

	if (!session_alive(fs->s))
		return (0);

	RB_FOREACH(wl, winlinks, &fs->s->windows) {
		if (wl->window == fs->w && wl == fs->wl)
			break;
	}
	if (wl == NULL)
		return (0);

	if (fs->w != fs->wl->window)
		return (0);

	return (window_has_pane(fs->w, fs->wp));
}

/* Copy a state. */
void
cmd_find_copy_state(struct cmd_find_state *dst, struct cmd_find_state *src)
{
	dst->s = src->s;
	dst->wl = src->wl;
	dst->idx = src->idx;
	dst->w = src->w;
	dst->wp = src->wp;
}

/* Log the result. */
void
cmd_find_log_state(const char *prefix, struct cmd_find_state *fs)
{
	if (fs->s != NULL)
		log_debug("%s: s=$%u", prefix, fs->s->id);
	else
		log_debug("%s: s=none", prefix);
	if (fs->wl != NULL) {
		log_debug("%s: wl=%u %d w=@@%u %s", prefix, fs->wl->idx,
		    fs->wl->window == fs->w, fs->w->id, fs->w->name);
	} else
		log_debug("%s: wl=none", prefix);
	if (fs->wp != NULL)
		log_debug("%s: wp=%%%u", prefix, fs->wp->id);
	else
		log_debug("%s: wp=none", prefix);
	if (fs->idx != -1)
		log_debug("%s: idx=%d", prefix, fs->idx);
	else
		log_debug("%s: idx=none", prefix);
}

/* Find state from a session. */
void
cmd_find_from_session(struct cmd_find_state *fs, struct session *s, int flags)
{
	cmd_find_clear_state(fs, flags);

	fs->s = s;
	fs->wl = fs->s->curw;
	fs->w = fs->wl->window;
	fs->wp = fs->w->active;

	cmd_find_log_state(__func__, fs);
}

/* Find state from a winlink. */
void
cmd_find_from_winlink(struct cmd_find_state *fs, struct winlink *wl, int flags)
{
	cmd_find_clear_state(fs, flags);

	fs->s = wl->session;
	fs->wl = wl;
	fs->w = wl->window;
	fs->wp = wl->window->active;

	cmd_find_log_state(__func__, fs);
}

/* Find state from a session and window. */
int
cmd_find_from_session_window(struct cmd_find_state *fs, struct session *s,
    struct window *w, int flags)
{
	cmd_find_clear_state(fs, flags);

	fs->s = s;
	fs->w = w;
	if (cmd_find_best_winlink_with_window(fs) != 0) {
		cmd_find_clear_state(fs, flags);
		return (-1);
	}
	fs->wp = fs->w->active;

	cmd_find_log_state(__func__, fs);
	return (0);
}

/* Find state from a window. */
int
cmd_find_from_window(struct cmd_find_state *fs, struct window *w, int flags)
{
	cmd_find_clear_state(fs, flags);

	fs->w = w;
	if (cmd_find_best_session_with_window(fs) != 0) {
		cmd_find_clear_state(fs, flags);
		return (-1);
	}
	if (cmd_find_best_winlink_with_window(fs) != 0) {
		cmd_find_clear_state(fs, flags);
		return (-1);
	}
	fs->wp = fs->w->active;

	cmd_find_log_state(__func__, fs);
	return (0);
}

/* Find state from a winlink and pane. */
void
cmd_find_from_winlink_pane(struct cmd_find_state *fs, struct winlink *wl,
    struct window_pane *wp, int flags)
{
	cmd_find_clear_state(fs, flags);

	fs->s = wl->session;
	fs->wl = wl;
	fs->idx = fs->wl->idx;
	fs->w = fs->wl->window;
	fs->wp = wp;

	cmd_find_log_state(__func__, fs);
}

/* Find state from a pane. */
int
cmd_find_from_pane(struct cmd_find_state *fs, struct window_pane *wp, int flags)
{
	if (cmd_find_from_window(fs, wp->window, flags) != 0)
		return (-1);
	fs->wp = wp;

	cmd_find_log_state(__func__, fs);
	return (0);
}

/* Find state from nothing. */
int
cmd_find_from_nothing(struct cmd_find_state *fs, int flags)
{
	cmd_find_clear_state(fs, flags);

	fs->s = cmd_find_best_session(NULL, 0, flags);
	if (fs->s == NULL) {
		cmd_find_clear_state(fs, flags);
		return (-1);
	}
	fs->wl = fs->s->curw;
	fs->idx = fs->wl->idx;
	fs->w = fs->wl->window;
	fs->wp = fs->w->active;

	cmd_find_log_state(__func__, fs);
	return (0);
}

/* Find state from mouse. */
int
cmd_find_from_mouse(struct cmd_find_state *fs, struct mouse_event *m, int flags)
{
	cmd_find_clear_state(fs, flags);

	if (!m->valid)
		return (-1);

	fs->wp = cmd_mouse_pane(m, &fs->s, &fs->wl);
	if (fs->wp == NULL) {
		cmd_find_clear_state(fs, flags);
		return (-1);
	}
	fs->w = fs->wl->window;

	cmd_find_log_state(__func__, fs);
	return (0);
}

/* Find state from client. */
int
cmd_find_from_client(struct cmd_find_state *fs, struct client *c, int flags)
{
	struct session		*s;
	struct winlink		*wl;
	struct window_pane	*wp;

	/* If no client, treat as from nothing. */
	if (c == NULL)
		return (cmd_find_from_nothing(fs, flags));

	/* If this is an attached client, all done. */
	if (c->session != NULL) {
		cmd_find_from_session(fs, c->session, flags);
		return (0);
	}
	cmd_find_clear_state(fs, flags);

	/*
	 * If this is an unattached client running in a pane, we can use that
	 * to limit the list of sessions to those containing that pane.
	 */
	wp = cmd_find_inside_pane(c);
	if (wp == NULL)
		goto unknown_pane;

	/* If we have a session in TMUX, see if it has this pane. */
	s = cmd_find_try_TMUX(c);
	if (s != NULL) {
		RB_FOREACH(wl, winlinks, &s->windows) {
			if (window_has_pane(wl->window, wp))
				break;
		}
		if (wl != NULL) {
			fs->s = s;
			fs->wl = s->curw; /* use current session */
			fs->w = fs->wl->window;
			fs->wp = fs->w->active; /* use active pane */

			cmd_find_log_state(__func__, fs);
			return (0);
		}
	}

	/*
	 * Don't have a session, or it doesn't have this pane. Try all
	 * sessions.
	 */
	fs->w = wp->window;
	if (cmd_find_best_session_with_window(fs) != 0) {
		if (wp != NULL) {
			/*
			 * The window may have been destroyed but the pane
			 * still on all_window_panes due to something else
			 * holding a reference.
			 */
			goto unknown_pane;
		}
		cmd_find_clear_state(fs, 0);
		return (-1);
	}
	fs->wl = fs->s->curw;
	fs->w = fs->wl->window;
	fs->wp = fs->w->active; /* use active pane */

	cmd_find_log_state(__func__, fs);
	return (0);

unknown_pane:
	/*
	 * We're not running in a known pane, but maybe this client has TMUX
	 * in the environment. That'd give us a session.
	 */
	s = cmd_find_try_TMUX(c);
	if (s != NULL) {
		cmd_find_from_session(fs, s, flags);
		return (0);
	}

	/* Otherwise we need to guess. */
	return (cmd_find_from_nothing(fs, flags));
}

/*
 * Split target into pieces and resolve for the given type. Fills in the given
 * state. Returns 0 on success or -1 on error.
 */
int
cmd_find_target(struct cmd_find_state *fs, struct cmdq_item *item,
    const char *target, enum cmd_find_type type, int flags)
{
	struct mouse_event	*m;
	struct cmd_find_state	 current;
	char			*colon, *period, *copy = NULL;
	const char		*session, *window, *pane, *s;
	int			 window_only = 0, pane_only = 0;

	/* Can fail flag implies quiet. */
	if (flags & CMD_FIND_CANFAIL)
		flags |= CMD_FIND_QUIET;

	/* Log the arguments. */
	if (type == CMD_FIND_PANE)
		s = "pane";
	else if (type == CMD_FIND_WINDOW)
		s = "window";
	else if (type == CMD_FIND_SESSION)
		s = "session";
	else
		s = "unknown";
	if (target == NULL)
		log_debug("%s: target none, type %s", __func__, s);
	else
		log_debug("%s: target %s, type %s", __func__, target, s);
	log_debug("%s: item %p, flags %#x", __func__, item, flags);

	/* Clear new state. */
	cmd_find_clear_state(fs, flags);

	/* Find current state. */
	if (server_check_marked() && (flags & CMD_FIND_DEFAULT_MARKED)) {
		fs->current = &marked_pane;
		log_debug("%s: current is marked pane", __func__);
	} else if (cmd_find_valid_state(&item->shared->current)) {
		fs->current = &item->shared->current;
		log_debug("%s: current is from queue", __func__);
	} else if (cmd_find_from_client(&current, item->client, flags) == 0) {
		fs->current = &current;
		log_debug("%s: current is from client", __func__);
	} else {
		if (~flags & CMD_FIND_QUIET)
			cmdq_error(item, "no current target");
		goto error;
	}
	if (!cmd_find_valid_state(fs->current))
		fatalx("invalid current find state");

	/* An empty or NULL target is the current. */
	if (target == NULL || *target == '\0')
		goto current;

	/* Mouse target is a plain = or {mouse}. */
	if (strcmp(target, "=") == 0 || strcmp(target, "{mouse}") == 0) {
		m = &item->shared->mouse;
		switch (type) {
		case CMD_FIND_PANE:
			fs->wp = cmd_mouse_pane(m, &fs->s, &fs->wl);
			if (fs->wp != NULL)
				fs->w = fs->wl->window;
			break;
		case CMD_FIND_WINDOW:
		case CMD_FIND_SESSION:
			fs->wl = cmd_mouse_window(m, &fs->s);
			if (fs->wl != NULL) {
				fs->w = fs->wl->window;
				fs->wp = fs->w->active;
			}
			break;
		}
		if (fs->wp == NULL) {
			if (~flags & CMD_FIND_QUIET)
				cmdq_error(item, "no mouse target");
			goto error;
		}
		goto found;
	}

	/* Marked target is a plain ~ or {marked}. */
	if (strcmp(target, "~") == 0 || strcmp(target, "{marked}") == 0) {
		if (!server_check_marked()) {
			if (~flags & CMD_FIND_QUIET)
				cmdq_error(item, "no marked target");
			goto error;
		}
		cmd_find_copy_state(fs, &marked_pane);
		goto found;
	}

	/* Find separators if they exist. */
	copy = xstrdup(target);
	colon = strchr(copy, ':');
	if (colon != NULL)
		*colon++ = '\0';
	if (colon == NULL)
		period = strchr(copy, '.');
	else
		period = strchr(colon, '.');
	if (period != NULL)
		*period++ = '\0';

	/* Set session, window and pane parts. */
	session = window = pane = NULL;
	if (colon != NULL && period != NULL) {
		session = copy;
		window = colon;
		window_only = 1;
		pane = period;
		pane_only = 1;
	} else if (colon != NULL && period == NULL) {
		session = copy;
		window = colon;
		window_only = 1;
	} else if (colon == NULL && period != NULL) {
		window = copy;
		pane = period;
		pane_only = 1;
	} else {
		if (*copy == '$')
			session = copy;
		else if (*copy == '@@')
			window = copy;
		else if (*copy == '%')
			pane = copy;
		else {
			switch (type) {
			case CMD_FIND_SESSION:
				session = copy;
				break;
			case CMD_FIND_WINDOW:
				window = copy;
				break;
			case CMD_FIND_PANE:
				pane = copy;
				break;
			}
		}
	}

	/* Set exact match flags. */
	if (session != NULL && *session == '=') {
		session++;
		fs->flags |= CMD_FIND_EXACT_SESSION;
	}
	if (window != NULL && *window == '=') {
		window++;
		fs->flags |= CMD_FIND_EXACT_WINDOW;
	}

	/* Empty is the same as NULL. */
	if (session != NULL && *session == '\0')
		session = NULL;
	if (window != NULL && *window == '\0')
		window = NULL;
	if (pane != NULL && *pane == '\0')
		pane = NULL;

	/* Map though conversion table. */
	if (session != NULL)
		session = cmd_find_map_table(cmd_find_session_table, session);
	if (window != NULL)
		window = cmd_find_map_table(cmd_find_window_table, window);
	if (pane != NULL)
		pane = cmd_find_map_table(cmd_find_pane_table, pane);

	log_debug("%s: target %s (flags %#x): session=%s, window=%s, pane=%s",
	    __func__, target, flags, session == NULL ? "none" : session,
	    window == NULL ? "none" : window, pane == NULL ? "none" : pane);

	/* No pane is allowed if want an index. */
	if (pane != NULL && (flags & CMD_FIND_WINDOW_INDEX)) {
		if (~flags & CMD_FIND_QUIET)
			cmdq_error(item, "can't specify pane here");
		goto error;
	}

	/* If the session isn't NULL, look it up. */
	if (session != NULL) {
		/* This will fill in session. */
		if (cmd_find_get_session(fs, session) != 0)
			goto no_session;

		/* If window and pane are NULL, use that session's current. */
		if (window == NULL && pane == NULL) {
			fs->wl = fs->s->curw;
			fs->idx = -1;
			fs->w = fs->wl->window;
			fs->wp = fs->w->active;
			goto found;
		}

		/* If window is present but pane not, find window in session. */
		if (window != NULL && pane == NULL) {
			/* This will fill in winlink and window. */
			if (cmd_find_get_window_with_session(fs, window) != 0)
				goto no_window;
			fs->wp = fs->wl->window->active;
			goto found;
		}

		/* If pane is present but window not, find pane. */
		if (window == NULL && pane != NULL) {
			/* This will fill in winlink and window and pane. */
			if (cmd_find_get_pane_with_session(fs, pane) != 0)
				goto no_pane;
			goto found;
		}

		/*
		 * If window and pane are present, find both in session. This
		 * will fill in winlink and window.
		 */
		if (cmd_find_get_window_with_session(fs, window) != 0)
			goto no_window;
		/* This will fill in pane. */
		if (cmd_find_get_pane_with_window(fs, pane) != 0)
			goto no_pane;
		goto found;
	}

	/* No session. If window and pane, try them. */
	if (window != NULL && pane != NULL) {
		/* This will fill in session, winlink and window. */
		if (cmd_find_get_window(fs, window, window_only) != 0)
			goto no_window;
		/* This will fill in pane. */
		if (cmd_find_get_pane_with_window(fs, pane) != 0)
			goto no_pane;
		goto found;
	}

	/* If just window is present, try it. */
	if (window != NULL && pane == NULL) {
		/* This will fill in session, winlink and window. */
		if (cmd_find_get_window(fs, window, window_only) != 0)
			goto no_window;
		fs->wp = fs->wl->window->active;
		goto found;
	}

	/* If just pane is present, try it. */
	if (window == NULL && pane != NULL) {
		/* This will fill in session, winlink, window and pane. */
		if (cmd_find_get_pane(fs, pane, pane_only) != 0)
			goto no_pane;
		goto found;
	}

current:
	/* Use the current session. */
	cmd_find_copy_state(fs, fs->current);
	if (flags & CMD_FIND_WINDOW_INDEX)
		fs->idx = -1;
	goto found;

error:
	fs->current = NULL;
	log_debug("%s: error", __func__);

	free(copy);
	if (flags & CMD_FIND_CANFAIL)
		return (0);
	return (-1);

found:
	fs->current = NULL;
	cmd_find_log_state(__func__, fs);

	free(copy);
	return (0);

no_session:
	if (~flags & CMD_FIND_QUIET)
		cmdq_error(item, "can't find session %s", session);
	goto error;

no_window:
	if (~flags & CMD_FIND_QUIET)
		cmdq_error(item, "can't find window %s", window);
	goto error;

no_pane:
	if (~flags & CMD_FIND_QUIET)
		cmdq_error(item, "can't find pane %s", pane);
	goto error;
}

/* Find the current client. */
static struct client *
cmd_find_current_client(struct cmdq_item *item, int quiet)
{
	struct client		*c;
	struct session		*s;
	struct window_pane	*wp;
	struct cmd_find_state	 fs;

	if (item->client != NULL && item->client->session != NULL)
		return (item->client);

	c = NULL;
	if ((wp = cmd_find_inside_pane(item->client)) != NULL) {
		cmd_find_clear_state(&fs, CMD_FIND_QUIET);
		fs.w = wp->window;
		if (cmd_find_best_session_with_window(&fs) == 0)
			c = cmd_find_best_client(fs.s);
	} else {
		s = cmd_find_best_session(NULL, 0, CMD_FIND_QUIET);
		if (s != NULL)
			c = cmd_find_best_client(s);
	}
	if (c == NULL && !quiet)
		cmdq_error(item, "no current client");
	log_debug("%s: no target, return %p", __func__, c);
	return (c);
}

/* Find the target client or report an error and return NULL. */
struct client *
cmd_find_client(struct cmdq_item *item, const char *target, int quiet)
{
	struct client	*c;
	char		*copy;
	size_t		 size;

	/* A NULL argument means the current client. */
	if (target == NULL)
		return (cmd_find_current_client(item, quiet));
	copy = xstrdup(target);

	/* Trim a single trailing colon if any. */
	size = strlen(copy);
	if (size != 0 && copy[size - 1] == ':')
		copy[size - 1] = '\0';

	/* Check name and path of each client. */
	TAILQ_FOREACH(c, &clients, entry) {
		if (c->session == NULL)
			continue;
		if (strcmp(copy, c->name) == 0)
			break;

		if (*c->ttyname == '\0')
			continue;
		if (strcmp(copy, c->ttyname) == 0)
			break;
		if (strncmp(c->ttyname, _PATH_DEV, (sizeof _PATH_DEV) - 1) != 0)
			continue;
		if (strcmp(copy, c->ttyname + (sizeof _PATH_DEV) - 1) == 0)
			break;
	}

	/* If no client found, report an error. */
	if (c == NULL && !quiet)
		cmdq_error(item, "can't find client %s", copy);

	free(copy);
	log_debug("%s: target %s, return %p", __func__, target, c);
	return (c);
}
@


1.56
log
@Do not forbid targets to specify non-visible panes - the checks for
visibility are better where the target is used. GitHub issue 1049.
@
text
@d1 1
a1 1
/* $OpenBSD: cmd-find.c,v 1.55 2017/07/07 07:13:14 nicm Exp $ */
d731 1
a731 1
cmd_find_from_session(struct cmd_find_state *fs, struct session *s)
d733 1
a733 1
	cmd_find_clear_state(fs, 0);
d745 1
a745 1
cmd_find_from_winlink(struct cmd_find_state *fs, struct winlink *wl)
d747 1
a747 1
	cmd_find_clear_state(fs, 0);
d760 1
a760 1
    struct window *w)
d762 1
a762 1
	cmd_find_clear_state(fs, 0);
d767 1
a767 1
		cmd_find_clear_state(fs, 0);
d778 1
a778 1
cmd_find_from_window(struct cmd_find_state *fs, struct window *w)
d780 1
a780 1
	cmd_find_clear_state(fs, 0);
d784 1
a784 1
		cmd_find_clear_state(fs, 0);
d788 1
a788 1
		cmd_find_clear_state(fs, 0);
d800 1
a800 1
    struct window_pane *wp)
d802 1
a802 1
	cmd_find_clear_state(fs, 0);
d815 1
a815 1
cmd_find_from_pane(struct cmd_find_state *fs, struct window_pane *wp)
d817 1
a817 1
	if (cmd_find_from_window(fs, wp->window) != 0)
d827 1
a827 1
cmd_find_from_nothing(struct cmd_find_state *fs)
d829 1
a829 1
	cmd_find_clear_state(fs, 0);
d831 1
a831 1
	fs->s = cmd_find_best_session(NULL, 0, fs->flags);
d833 1
a833 1
		cmd_find_clear_state(fs, 0);
d847 1
a847 1
cmd_find_from_mouse(struct cmd_find_state *fs, struct mouse_event *m)
d849 1
a849 1
	cmd_find_clear_state(fs, 0);
d856 1
a856 1
		cmd_find_clear_state(fs, 0);
d867 1
a867 1
cmd_find_from_client(struct cmd_find_state *fs, struct client *c)
d875 1
a875 1
		return (cmd_find_from_nothing(fs));
d879 1
a879 1
		cmd_find_from_session(fs, c->session);
d882 1
a882 1
	cmd_find_clear_state(fs, 0);
d941 1
a941 1
		cmd_find_from_session(fs, s);
d946 1
a946 1
	return (cmd_find_from_nothing(fs));
d992 1
a992 1
	} else if (cmd_find_from_client(&current, item->client) == 0) {
@


1.55
log
@When working out the current client (for example for switch-client with
no target), prefer clients attached to the current session if there is
one. GitHub issue 995 from Jan Larres.
@
text
@d1 1
a1 1
/* $OpenBSD: cmd-find.c,v 1.54 2017/06/16 15:12:38 nicm Exp $ */
d513 1
a513 1
		if (fs->wp == NULL || window_pane_outside(fs->wp))
d550 1
a550 1
		if (fs->wp == NULL || window_pane_outside(fs->wp))
d582 1
a582 1
		if (fs->wp == NULL || window_pane_outside(fs->wp))
d594 1
a594 1
		if (fs->wp == NULL || window_pane_outside(fs->wp))
d599 1
a599 1
		if (fs->wp == NULL || window_pane_outside(fs->wp))
d604 1
a604 1
		if (fs->wp == NULL || window_pane_outside(fs->wp))
d609 1
a609 1
		if (fs->wp == NULL || window_pane_outside(fs->wp))
d614 1
a614 1
		if (fs->wp == NULL || window_pane_outside(fs->wp))
d630 1
a630 1
		if (fs->wp != NULL && !window_pane_outside(fs->wp))
d638 1
a638 1
		if (fs->wp != NULL && !window_pane_outside(fs->wp))
d644 1
a644 1
	if (fs->wp != NULL && !window_pane_outside(fs->wp))
d692 1
a692 3
	if (!window_has_pane(fs->w, fs->wp))
		return (0);
	return (!window_pane_outside(fs->wp));
a818 4
	if (window_pane_outside(wp)) {
		cmd_find_clear_state(fs, 0);
		return (-1);
	}
d1013 1
a1013 1
			if (fs->wp != NULL && !window_pane_outside(fs->wp))
@


1.54
log
@Tweak some logging.
@
text
@d1 1
a1 1
/* $OpenBSD: cmd-find.c,v 1.53 2017/06/14 07:37:17 nicm Exp $ */
d99 16
d894 1
a894 4
	RB_FOREACH(wp, window_pane_tree, &all_window_panes) {
		if (strcmp(wp->tty, c->ttyname) == 0)
			break;
	}
d1248 29
a1281 1
	struct session	*s;
d1286 2
a1287 14
	if (target == NULL) {
		c = NULL;
		if (item->client != NULL && item->client->session != NULL)
			c = item->client;
		else {
			s = cmd_find_best_session(NULL, 0, CMD_FIND_QUIET);
			if (s != NULL)
				c = cmd_find_best_client(s);
		}
		if (c == NULL && !quiet)
			cmdq_error(item, "no current client");
		log_debug("%s: no target, return %p", __func__, c);
		return (c);
	}
@


1.53
log
@Add missing error message when no target, GitHub issue 971.
@
text
@d1 1
a1 1
/* $OpenBSD: cmd-find.c,v 1.52 2017/04/22 12:08:41 nicm Exp $ */
d953 1
a953 1
	const char		*session, *window, *pane;
d961 8
d970 1
a970 1
		log_debug("%s: target none, type %d", __func__, type);
d972 1
a972 1
		log_debug("%s: target %s, type %d", __func__, target, type);
@


1.52
log
@Do not need getopt.h.
@
text
@d1 1
a1 1
/* $OpenBSD: cmd-find.c,v 1.51 2017/04/22 10:22:39 nicm Exp $ */
d980 3
a982 1
	} else
d984 1
@


1.51
log
@Get rid of the extra layer of flags and cmd_prepare() and just store the
CMD_FIND_* flags in the cmd_entry and call it for the command. Commands
with special requirements call it themselves and update the target for
hooks to use.
@
text
@d1 1
a1 1
/* $OpenBSD: cmd-find.c,v 1.50 2017/04/21 22:23:24 nicm Exp $ */
d894 1
a894 1
			fs->wl = s->curw; /* use active session */
@


1.50
log
@Log error properly when no current state, and some other minor tweaks.
@
text
@d1 1
a1 1
/* $OpenBSD: cmd-find.c,v 1.49 2017/04/21 22:00:06 nicm Exp $ */
d956 4
d1197 2
@


1.49
log
@Make sure cmd_find_from_* clear the state if they fail.
@
text
@d1 1
a1 1
/* $OpenBSD: cmd-find.c,v 1.48 2017/04/21 20:26:34 nicm Exp $ */
d977 2
a978 3
		return (-1);
	if (!cmd_find_empty_state(fs->current) &&
	    !cmd_find_valid_state(fs->current))
@


1.48
log
@Make the cmd_find_* functions more obvious when looking for a client,
rather than having it inside other functions. Should be no change to the
way targets are resolved just yet.
@
text
@d1 1
a1 1
/* $OpenBSD: cmd-find.c,v 1.47 2017/04/21 17:22:20 nicm Exp $ */
d752 2
a753 1
	if (cmd_find_best_winlink_with_window(fs) != 0)
d755 1
d769 2
a770 1
	if (cmd_find_best_session_with_window(fs) != 0)
d772 3
a774 1
	if (cmd_find_best_winlink_with_window(fs) != 0)
d776 1
d805 2
a806 1
	if (window_pane_outside(wp))
d808 1
d822 2
a823 1
	if (fs->s == NULL)
d825 1
d845 2
a846 1
	if (fs->wp == NULL)
d848 1
d917 1
d1099 2
a1100 2
	log_debug("target %s (flags %#x): session=%s, window=%s, pane=%s",
	    target, flags, session == NULL ? "none" : session,
@


1.47
log
@Add cmd_find_from_winlink_pane and use it in a couple of places, and
make functions that can't fail void.
@
text
@d1 1
a1 1
/* $OpenBSD: cmd-find.c,v 1.46 2017/04/21 14:09:44 nicm Exp $ */
a29 3
static struct session *cmd_find_try_TMUX(struct client *, struct window *);
static int	cmd_find_client_better(struct client *, struct client *);
static struct client *cmd_find_best_client(struct client **, u_int);
a35 4
static int	cmd_find_current_session_with_client(struct cmd_find_state *);
static int	cmd_find_current_session(struct cmd_find_state *);
static struct client *cmd_find_current_client(struct cmdq_item *);

d80 1
a80 1
cmd_find_try_TMUX(struct client *c, struct window *w)
a85 1
	struct session		*s;
d95 2
a96 7
	log_debug("client %p TMUX is %s (session @@%u)", c, envent->value,
	    session);

	s = session_find_by_id(session);
	if (s == NULL || (w != NULL && !session_has(s, w)))
		return (NULL);
	return (s);
d108 1
a108 1
/* Find best client from a list, or all if list is NULL. */
d110 1
a110 1
cmd_find_best_client(struct client **clist, u_int csize)
d113 3
a115 1
	u_int		 i;
d118 7
a124 14
	if (clist != NULL) {
		for (i = 0; i < csize; i++) {
			if (clist[i]->session == NULL)
				continue;
			if (cmd_find_client_better(clist[i], c))
				c = clist[i];
		}
	} else {
		TAILQ_FOREACH(c_loop, &clients, entry) {
			if (c_loop->session == NULL)
				continue;
			if (cmd_find_client_better(c_loop, c))
				c = c_loop;
		}
a176 6
	if (fs->item != NULL && fs->item->client != NULL) {
		fs->s = cmd_find_try_TMUX(fs->item->client, fs->w);
		if (fs->s != NULL)
			return (cmd_find_best_winlink_with_window(fs));
	}

a223 140
/* Find current session when we have an unattached client. */
static int
cmd_find_current_session_with_client(struct cmd_find_state *fs)
{
	struct window_pane	*wp;

	/*
	 * If this is running in a pane, we can use that to limit the list of
	 * sessions to those containing that pane (we still use the current
	 * window in the best session).
	 */
	if (fs->item != NULL) {
		RB_FOREACH(wp, window_pane_tree, &all_window_panes) {
			if (strcmp(wp->tty, fs->item->client->ttyname) == 0)
				break;
		}
	} else
		wp = NULL;

	/* Not running in a pane. We know nothing. Find the best session. */
	if (wp == NULL)
		goto unknown_pane;

	/* Find the best session and winlink containing this pane. */
	fs->w = wp->window;
	if (cmd_find_best_session_with_window(fs) != 0) {
		if (wp != NULL) {
			/*
			 * The window may have been destroyed but the pane
			 * still on all_window_panes due to something else
			 * holding a reference.
			 */
			goto unknown_pane;
		}
		return (-1);
	}

	/* Use the current window and pane from this session. */
	fs->wl = fs->s->curw;
	fs->idx = fs->wl->idx;
	fs->w = fs->wl->window;
	fs->wp = fs->w->active;

	return (0);

unknown_pane:
	fs->s = NULL;
	if (fs->item != NULL)
		fs->s = cmd_find_try_TMUX(fs->item->client, NULL);
	if (fs->s == NULL)
		fs->s = cmd_find_best_session(NULL, 0, fs->flags);
	if (fs->s == NULL)
		return (-1);
	fs->wl = fs->s->curw;
	fs->idx = fs->wl->idx;
	fs->w = fs->wl->window;
	fs->wp = fs->w->active;

	return (0);
}

/*
 * Work out the best current state. If this function succeeds, the state is
 * guaranteed to be completely filled in.
 */
static int
cmd_find_current_session(struct cmd_find_state *fs)
{
	/* If we know the current client, use it. */
	if (fs->item != NULL && fs->item->client != NULL) {
		log_debug("%s: have client %p%s", __func__, fs->item->client,
		    fs->item->client->session == NULL ? "" : " (with session)");
		if (fs->item->client->session == NULL)
			return (cmd_find_current_session_with_client(fs));
		fs->s = fs->item->client->session;
		fs->wl = fs->s->curw;
		fs->idx = fs->wl->idx;
		fs->w = fs->wl->window;
		fs->wp = fs->w->active;
		return (0);
	}

	/* We know nothing, find the best session and client. */
	fs->s = cmd_find_best_session(NULL, 0, fs->flags);
	if (fs->s == NULL)
		return (-1);
	fs->wl = fs->s->curw;
	fs->idx = fs->wl->idx;
	fs->w = fs->wl->window;
	fs->wp = fs->w->active;

	return (0);
}

/* Work out the best current client. */
static struct client *
cmd_find_current_client(struct cmdq_item *item)
{
	struct cmd_find_state	 current;
	struct session		*s;
	struct client		*c, **clist = NULL;
	u_int		 	 csize;

	/* If the queue client has a session, use it. */
	if (item->client != NULL && item->client->session != NULL) {
		log_debug("%s: using item %p client %p", __func__, item,
		    item->client);
		return (item->client);
	}

	/* Otherwise find the current session. */
	cmd_find_clear_state(&current, item, 0);
	if (cmd_find_current_session(&current) != 0)
		return (NULL);

	/* If it is attached, find the best of it's clients. */
	s = current.s;
	log_debug("%s: current session $%u %s", __func__, s->id, s->name);
	if (~s->flags & SESSION_UNATTACHED) {
		csize = 0;
		TAILQ_FOREACH(c, &clients, entry) {
			if (c->session != s)
				continue;
			clist = xreallocarray(clist, csize + 1, sizeof *clist);
			clist[csize++] = c;
		}
		if (csize != 0) {
			c = cmd_find_best_client(clist, csize);
			if (c != NULL) {
				free(clist);
				return (c);
			}
		}
		free(clist);
	}

	/* Otherwise pick best of all clients. */
	return (cmd_find_best_client(NULL, 0));
}

d636 1
a636 2
cmd_find_clear_state(struct cmd_find_state *fs, struct cmdq_item *item,
    int flags)
a639 1
	fs->item = item;
d645 1
a645 1
/* Check if state is empty/ */
d719 1
a719 1
	cmd_find_clear_state(fs, NULL, 0);
d733 1
a733 1
	cmd_find_clear_state(fs, NULL, 0);
d748 1
a748 1
	cmd_find_clear_state(fs, NULL, 0);
d764 1
a764 1
	cmd_find_clear_state(fs, NULL, 0);
d782 1
a782 1
	cmd_find_clear_state(fs, NULL, 0);
d807 1
a807 1
/* Find current state. */
d809 1
a809 1
cmd_find_current(struct cmd_find_state *fs, struct cmdq_item *item, int flags)
d811 94
a904 4
	cmd_find_clear_state(fs, item, flags);
	if (cmd_find_current_session(fs) != 0) {
		if (~flags & CMD_FIND_QUIET)
			cmdq_error(item, "no current session");
d907 5
d913 14
d934 2
a935 3
cmd_find_target(struct cmd_find_state *fs, struct cmd_find_state *current,
    struct cmdq_item *item, const char *target, enum cmd_find_type type,
    int flags)
d938 1
d951 1
a951 1
	cmd_find_clear_state(fs, item, flags);
d960 5
a964 4
	} else {
		fs->current = current;
		log_debug("%s: current is from argument", __func__);
	}
d1211 1
d1216 9
a1224 2
	if (item != NULL && target == NULL) {
		c = cmd_find_current_client(item);
@


1.46
log
@More unnecessary arguments now winlink points back to session.
@
text
@d1 1
a1 1
/* $OpenBSD: cmd-find.c,v 1.45 2017/04/21 14:01:19 nicm Exp $ */
d882 1
a882 1
int
a892 1
	return (0);
d896 1
a896 1
int
a906 1
	return (0);
d941 16
@


1.45
log
@Store state shared between multiple commands in the queue in a shared
structure.
@
text
@d1 1
a1 1
/* $OpenBSD: cmd-find.c,v 1.44 2017/04/05 11:04:48 nicm Exp $ */
d898 1
a898 2
cmd_find_from_winlink(struct cmd_find_state *fs, struct session *s,
    struct winlink *wl)
d902 1
a902 1
	fs->s = s;
@


1.44
log
@Try again to resolve problems with mistaking sessions for windows: now
do not look up windows as sessions (and panes as windows) when they are
qualified with a ':' or a '.'. So 'foo' as a window target will look for
windows and sessions called 'foo', but ':foo' will only look for
windows, and 'foo:' only for sessions. This means the common case of
using an unadorned session as a window target (send -tfoo) should
continue to work, but an explicit window will not get confused with a
session (send -t:foo).
@
text
@d1 1
a1 1
/* $OpenBSD: cmd-find.c,v 1.43 2017/04/05 10:49:46 nicm Exp $ */
d1001 2
a1002 2
	} else if (cmd_find_valid_state(&item->current)) {
		fs->current = &item->current;
d1018 1
a1018 1
		m = &item->mouse;
@


1.43
log
@Give each client a name. This defaults to the tty name as before but
falls back to an alternative if the tty name is not available. This is
clearer than overloading the client ttyname member and allows us to
remove the path stored in the tty struct, it should always be the same
as the client.
@
text
@d1 1
a1 1
/* $OpenBSD: cmd-find.c,v 1.42 2017/03/13 10:53:32 nicm Exp $ */
d46 1
a46 1
static int	cmd_find_get_window(struct cmd_find_state *, const char *);
d49 1
a49 1
static int	cmd_find_get_pane(struct cmd_find_state *, const char *);
d467 1
a467 1
cmd_find_get_window(struct cmd_find_state *fs, const char *window)
d487 1
a487 1
	if (cmd_find_get_session(fs, window) == 0) {
d654 1
a654 1
cmd_find_get_pane(struct cmd_find_state *fs, const char *pane)
d678 1
a678 1
	if (cmd_find_get_window(fs, pane) == 0) {
d985 1
d1070 1
d1072 1
d1076 1
d1080 1
d1187 1
a1187 1
		if (cmd_find_get_window(fs, window) != 0)
d1198 1
a1198 1
		if (cmd_find_get_window(fs, window) != 0)
d1207 1
a1207 1
		if (cmd_find_get_pane(fs, pane) != 0)
@


1.42
log
@Revert previous, breaks normal short targets, reported by Theo Buehler.
@
text
@d1 1
a1 1
/* $OpenBSD: cmd-find.c,v 1.40 2016/11/16 00:24:03 nicm Exp $ */
d259 1
a259 1
	if (fs->item != NULL && fs->item->client->tty.path != NULL) {
d261 1
a261 1
			if (strcmp(wp->tty, fs->item->client->tty.path) == 0)
a1250 1
	const char	*path;
d1267 1
a1267 1
	/* Check path of each client. */
d1269 1
a1269 1
		if (c->session == NULL || c->tty.path == NULL)
d1271 2
a1272 1
		path = c->tty.path;
d1274 3
a1276 2
		/* Try for exact match. */
		if (strcmp(copy, path) == 0)
d1278 1
a1278 3

		/* Try without leading /dev. */
		if (strncmp(path, _PATH_DEV, (sizeof _PATH_DEV) - 1) != 0)
d1280 1
a1280 1
		if (strcmp(copy, path + (sizeof _PATH_DEV) - 1) == 0)
@


1.41
log
@Only look for window and pane parts of target as a sesson and window if
they look like an ID.
@
text
@d486 2
a487 2
	/* Try as a session if it looks like a session. */
	if (*window == '$' && cmd_find_get_session(fs, window) == 0) {
d677 2
a678 2
	/* Try as a window if it looks like a window. */
	if (*pane == '@@' && cmd_find_get_window(fs, pane) == 0) {
@


1.40
log
@The target validity check used window_pane_visible but that may be false
if the pane is zoomed, so instead add a new function to just check if
the pane is actually on screen (most commands still want to accept panes
invisible by zoom). Also reject panes outside the window for various
special targets. Problem reported by Sean Haugh.
@
text
@d1 1
a1 1
/* $OpenBSD: cmd-find.c,v 1.39 2016/10/18 12:51:26 nicm Exp $ */
d486 2
a487 2
	/* Otherwise try as a session itself. */
	if (cmd_find_get_session(fs, window) == 0) {
d677 2
a678 2
	/* Otherwise try as a window itself (this will also try as session). */
	if (cmd_find_get_window(fs, pane) == 0) {
@


1.39
log
@Tweak a couple of log statements.
@
text
@d1 1
a1 1
/* $OpenBSD: cmd-find.c,v 1.38 2016/10/16 22:06:40 nicm Exp $ */
d661 1
a661 1
		if (fs->wp == NULL)
d698 1
a698 1
		if (fs->wp == NULL)
d730 3
a732 1
		if (fs->wp == NULL || fs->wp->window != fs->w)
d742 2
d747 1
a747 1
		if (fs->wp == NULL)
d752 1
a752 1
		if (fs->wp == NULL)
d757 1
a757 1
		if (fs->wp == NULL)
d762 1
a762 1
		if (fs->wp == NULL)
d778 1
a778 1
		if (fs->wp != NULL)
d786 1
a786 1
		if (fs->wp != NULL)
d792 1
a792 1
	if (fs->wp != NULL)
d844 1
a844 1
	return (window_pane_visible(fs->wp));
d952 2
d1021 1
a1021 1
			if (fs->wp != NULL)
@


1.38
log
@Use the notify name string instead of going via an enum and change
existing hooks to use notifys instead.
@
text
@d1 1
a1 1
/* $OpenBSD: cmd-find.c,v 1.37 2016/10/16 19:04:05 nicm Exp $ */
d993 1
a993 1
		log_debug("    current is marked pane");
d996 1
a996 1
		log_debug("    current is from queue");
d999 1
a999 1
		log_debug("    current is from argument");
d1210 1
a1210 1
	log_debug("    error");
@


1.37
log
@Mass rename struct cmd_q to struct cmdq_item and related.
@
text
@d1 1
a1 1
/* $OpenBSD: cmd-find.c,v 1.36 2016/10/16 17:55:14 nicm Exp $ */
d231 1
a231 1
	if (fs->s->curw->window == fs->w)
@


1.36
log
@Rewrite command queue handling. Each client still has a command queue,
but there is also now a global command queue. Instead of command queues
being dispatched on demand from wherever the command happens to be
added, they are now all dispatched from the top level server
loop. Command queues may now also include callbacks as well as commands,
and items may be inserted after the current command as well as at the end.

This all makes command queues significantly more predictable and easier
to use, and avoids the complex multiple nested command queues used by
source-file, if-shell and friends.

A mass rename of struct cmdq to a better name (cmdq_item probably) is
coming.
@
text
@d1 1
a1 1
/* $OpenBSD: cmd-find.c,v 1.35 2016/10/15 00:09:30 nicm Exp $ */
d41 1
a41 1
static struct client *cmd_find_current_client(struct cmd_q *);
d195 2
a196 2
	if (fs->cmdq != NULL && fs->cmdq->client != NULL) {
		fs->s = cmd_find_try_TMUX(fs->cmdq->client, fs->w);
d259 1
a259 1
	if (fs->cmdq != NULL && fs->cmdq->client->tty.path != NULL) {
d261 1
a261 1
			if (strcmp(wp->tty, fs->cmdq->client->tty.path) == 0)
d295 2
a296 2
	if (fs->cmdq != NULL)
		fs->s = cmd_find_try_TMUX(fs->cmdq->client, NULL);
d317 4
a320 4
	if (fs->cmdq != NULL && fs->cmdq->client != NULL) {
		log_debug("%s: have client %p%s", __func__, fs->cmdq->client,
		    fs->cmdq->client->session == NULL ? "" : " (with session)");
		if (fs->cmdq->client->session == NULL)
d322 1
a322 1
		fs->s = fs->cmdq->client->session;
d344 1
a344 1
cmd_find_current_client(struct cmd_q *cmdq)
d352 4
a355 4
	if (cmdq->client != NULL && cmdq->client->session != NULL) {
		log_debug("%s: using cmdq %p client %p", __func__, cmdq,
		    cmdq->client);
		return (cmdq->client);
d359 1
a359 1
	cmd_find_clear_state(&current, cmdq, 0);
d796 2
a797 1
cmd_find_clear_state(struct cmd_find_state *fs, struct cmd_q *cmdq, int flags)
d801 1
a801 1
	fs->cmdq = cmdq;
d956 1
a956 1
cmd_find_current(struct cmd_find_state *fs, struct cmd_q *cmdq, int flags)
d958 1
a958 1
	cmd_find_clear_state(fs, cmdq, flags);
d961 1
a961 1
			cmdq_error(cmdq, "no current session");
d973 2
a974 1
    struct cmd_q *cmdq, const char *target, enum cmd_find_type type, int flags)
d985 1
a985 1
	log_debug("%s: cmdq %p, flags %#x", __func__, cmdq, flags);
d988 1
a988 1
	cmd_find_clear_state(fs, cmdq, flags);
d994 2
a995 2
	} else if (cmd_find_valid_state(&cmdq->current)) {
		fs->current = &cmdq->current;
d1011 1
a1011 1
		m = &cmdq->mouse;
d1029 1
a1029 1
				cmdq_error(cmdq, "no mouse target");
d1039 1
a1039 1
				cmdq_error(cmdq, "no marked target");
d1125 1
a1125 1
			cmdq_error(cmdq, "can't specify pane here");
d1224 1
a1224 1
		cmdq_error(cmdq, "can't find session %s", session);
d1229 1
a1229 1
		cmdq_error(cmdq, "can't find window %s", window);
d1234 1
a1234 1
		cmdq_error(cmdq, "can't find pane %s", pane);
d1240 1
a1240 1
cmd_find_client(struct cmd_q *cmdq, const char *target, int quiet)
d1248 2
a1249 2
	if (cmdq != NULL && target == NULL) {
		c = cmd_find_current_client(cmdq);
d1251 1
a1251 1
			cmdq_error(cmdq, "no current client");
d1281 1
a1281 1
		cmdq_error(cmdq, "can't find client %s", copy);
@


1.35
log
@Fire hooks on the simple notifys (window-renamed and session-renamed),
the complicated ones get no hooks for now (more to come).
@
text
@d1 1
a1 1
/* $OpenBSD: cmd-find.c,v 1.34 2016/10/13 10:01:49 nicm Exp $ */
d1009 1
a1009 1
		m = &cmdq->item->mouse;
@


1.34
log
@Some improvements and bug fixes for hooks:

- Prepare the state again before the "after" hooks are run, because the
  command may have killed or moved windows.

- Use the hooks list from the newly prepared target, not the old hooks
  list (only matters for new-session really).

- Correctly detect an invalid current state and ignore it in
  cmd_find_target ("killw; swapw").

- Change neww, new, killp, killw, splitw, swapp, swapw to update the
  current state (used if no explicit target is given) to something more
  useful after they have finished. For example, neww changes it to the
  newly created window.

Hooks are still relatively new and primitive so there are likely to be
more changes to come.

Parts based on bug reports from Uwe Werler and Iblis Lin.
@
text
@d1 1
a1 1
/* $OpenBSD: cmd-find.c,v 1.33 2016/10/10 21:51:39 nicm Exp $ */
d907 17
d935 1
@


1.33
log
@Add static in cmd-* and fix a few other nits.
@
text
@d1 1
a1 1
/* $OpenBSD: cmd-find.c,v 1.32 2016/03/03 14:14:46 nicm Exp $ */
d806 9
d971 1
a971 1
	if (server_check_marked() && (flags & CMD_FIND_DEFAULT_MARKED))
d973 2
a974 1
	else if (cmd_find_valid_state(&cmdq->current))
d976 2
a977 1
	else
d979 5
@


1.32
log
@Accept clients as sessions in cmd_find_get_session.
@
text
@d1 1
a1 1
/* $OpenBSD: cmd-find.c,v 1.31 2016/01/19 16:01:30 nicm Exp $ */
d30 24
a53 22
struct session	*cmd_find_try_TMUX(struct client *, struct window *);
int		 cmd_find_client_better(struct client *, struct client *);
struct client	*cmd_find_best_client(struct client **, u_int);
int		 cmd_find_session_better(struct session *, struct session *,
		     int);
struct session	*cmd_find_best_session(struct session **, u_int, int);
int		 cmd_find_best_session_with_window(struct cmd_find_state *);
int		 cmd_find_best_winlink_with_window(struct cmd_find_state *);

int		 cmd_find_current_session_with_client(struct cmd_find_state *);
int		 cmd_find_current_session(struct cmd_find_state *);
struct client	*cmd_find_current_client(struct cmd_q *);

const char	*cmd_find_map_table(const char *[][2], const char *);

int	cmd_find_get_session(struct cmd_find_state *, const char *);
int	cmd_find_get_window(struct cmd_find_state *, const char *);
int	cmd_find_get_window_with_session(struct cmd_find_state *, const char *);
int	cmd_find_get_window_with_pane(struct cmd_find_state *);
int	cmd_find_get_pane(struct cmd_find_state *, const char *);
int	cmd_find_get_pane_with_session(struct cmd_find_state *, const char *);
int	cmd_find_get_pane_with_window(struct cmd_find_state *, const char *);
d55 1
a55 1
const char *cmd_find_session_table[][2] = {
d58 1
a58 1
const char *cmd_find_window_table[][2] = {
d66 1
a66 1
const char *cmd_find_pane_table[][2] = {
d86 1
a86 1
struct session *
d113 1
a113 1
int
d122 1
a122 1
struct client *
d148 1
a148 1
int
d166 1
a166 1
struct session *
d188 1
a188 1
int
d225 1
a225 1
int
d249 1
a249 1
int
d313 1
a313 1
int
d343 1
a343 1
struct client *
d389 1
a389 1
const char *
d402 1
a402 1
int
d466 1
a466 1
int
d502 1
a502 1
int
a651 10
/* Find window from given pane. Needs wp, fills in s and wl and w. */
int
cmd_find_get_window_with_pane(struct cmd_find_state *fs)
{
	log_debug("%s", __func__);

	fs->w = fs->wp->window;
	return (cmd_find_best_session_with_window(fs));
}

d653 1
a653 1
int
d690 1
a690 1
int
d717 1
a717 1
int
@


1.31
log
@Split out getting the current state from the target search so it can be
replaced if we already know the current.
@
text
@d1 1
a1 1
/* $OpenBSD: cmd-find.c,v 1.30 2016/01/19 15:59:12 nicm Exp $ */
d404 1
d421 7
d1220 1
a1220 1
	if (target == NULL) {
@


1.30
log
@I no longer use my SourceForge address so replace it.
@
text
@d1 1
a1 1
/* $OpenBSD: cmd-find.c,v 1.29 2016/01/16 00:36:53 nicm Exp $ */
d926 13
d944 2
a945 2
cmd_find_target(struct cmd_find_state *fs, struct cmd_q *cmdq,
    const char *target, enum cmd_find_type type, int flags)
a946 1
	struct cmd_find_state	 current;
d966 2
a967 9
	else {
		cmd_find_clear_state(&current, cmdq, flags);
		if (cmd_find_current_session(&current) != 0) {
			if (~flags & CMD_FIND_QUIET)
				cmdq_error(cmdq, "no current session");
			goto error;
		}
		fs->current = &current;
	}
@


1.29
log
@Add hooks for alerts (bell, silence, activity), from Thomas Adam.
@
text
@d1 1
a1 1
/* $OpenBSD: cmd-find.c,v 1.28 2015/12/17 23:08:22 nicm Exp $ */
d4 1
a4 1
 * Copyright (c) 2015 Nicholas Marriott <nicm@@users.sourceforge.net>
@


1.28
log
@As well as setting up the state, actually use it in cmd_find_target.
@
text
@d1 1
a1 1
/* $OpenBSD: cmd-find.c,v 1.27 2015/12/16 21:50:37 nicm Exp $ */
d877 16
@


1.27
log
@Add infrastructure to work out the best target given a pane or window
alone and use it to add pane_died and pane_exited hooks.
@
text
@d1 1
a1 1
/* $OpenBSD: cmd-find.c,v 1.26 2015/12/15 14:32:55 nicm Exp $ */
a933 1
	fs->current = NULL;
d936 3
a938 1
	if (fs->current == NULL) {
@


1.26
log
@Copy state directly rather than dereferencing wl (which could be NULL).
@
text
@d1 1
a1 1
/* $OpenBSD: cmd-find.c,v 1.25 2015/12/15 00:45:02 nicm Exp $ */
d193 1
a193 1
	if (fs->cmdq->client != NULL) {
d257 1
a257 1
	if (fs->cmdq->client->tty.path != NULL) {
d292 3
a294 1
	fs->s = cmd_find_try_TMUX(fs->cmdq->client, NULL);
d315 1
a315 1
	if (fs->cmdq->client != NULL) {
d865 43
@


1.25
log
@We changed somewhat recently to us the pty when tmux was run inside
itself to work out the current pane. This is confusing in many cases
(particularly notable is that "tmux neww\; splitw" would not split the
new window), and the few advantages do not make up for the confusion.

So drop this behaviour and return to using the current window and pane;
keep the pty check but only use it to limit the list of possible current
sessions.
@
text
@d1 1
a1 1
/* $OpenBSD: cmd-find.c,v 1.24 2015/12/15 00:11:24 nicm Exp $ */
d837 2
a838 2
	dst->idx = dst->wl->idx;
	dst->w = dst->wl->window;
@


1.24
log
@Don't copy marked pane when can just point to it.
@
text
@d1 1
a1 1
/* $OpenBSD: cmd-find.c,v 1.23 2015/12/15 00:00:01 nicm Exp $ */
d252 5
a256 1
	/* If this is running in a pane, that's great. */
d269 1
a269 1
	/* We now know the window and pane. */
a270 3
	fs->wp = wp;

	/* Find the best session and winlink. */
d282 7
d301 1
@


1.23
log
@Make the marked pane a cmd_find_state.
@
text
@d1 1
a1 1
/* $OpenBSD: cmd-find.c,v 1.22 2015/12/14 23:30:58 nicm Exp $ */
d876 3
d880 1
a880 1
	cmd_find_clear_state(&current, cmdq, flags);
d882 3
a884 2
		cmd_find_copy_state(&current, &marked_pane);
	else {
d890 1
a892 4
	/* Clear new state. */
	cmd_find_clear_state(fs, cmdq, flags);
	fs->current = &current;

d1091 1
d1093 1
a1093 2
		current.idx = -1;
	memcpy(fs, &current, sizeof *fs);
@


1.22
log
@Use cmd_find_clear_state instead of an extra function doing the same.
@
text
@d1 1
a1 1
/* $OpenBSD: cmd-find.c,v 1.21 2015/12/13 17:55:14 nicm Exp $ */
d795 61
d878 8
a885 11
	if (server_check_marked() && (flags & CMD_FIND_DEFAULT_MARKED)) {
		current.s = marked_session;
		current.wl = marked_winlink;
		current.idx = current.wl->idx;
		current.w = current.wl->window;
		current.wp = marked_window_pane;
	}
	if (current.s == NULL && cmd_find_current_session(&current) != 0) {
		if (~flags & CMD_FIND_QUIET)
			cmdq_error(cmdq, "no current session");
		goto error;
d929 1
a929 5
		fs->s = marked_session;
		fs->wl = marked_winlink;
		fs->idx = fs->wl->idx;
		fs->w = fs->wl->window;
		fs->wp = marked_window_pane;
a1122 23
}

/* Log the result. */
void
cmd_find_log_state(const char *prefix, struct cmd_find_state *fs)
{
	if (fs->s != NULL)
		log_debug("%s: s=$%u", prefix, fs->s->id);
	else
		log_debug("%s: s=none", prefix);
	if (fs->wl != NULL) {
		log_debug("%s: wl=%u %d w=@@%u %s", prefix, fs->wl->idx,
		    fs->wl->window == fs->w, fs->w->id, fs->w->name);
	} else
		log_debug("%s: wl=none", prefix);
	if (fs->wp != NULL)
		log_debug("%s: wp=%%%u", prefix, fs->wp->id);
	else
		log_debug("%s: wp=none", prefix);
	if (fs->idx != -1)
		log_debug("%s: idx=%d", prefix, fs->idx);
	else
		log_debug("%s: idx=none", prefix);
@


1.21
log
@Use struct cmd_find_state directly and remove cmd_state_flag, also
change so that winlink is set even if an index is too.
@
text
@d1 1
a1 1
/* $OpenBSD: cmd-find.c,v 1.20 2015/12/13 16:44:35 nicm Exp $ */
a51 3

void	cmd_find_clear_state(struct cmd_find_state *, struct cmd_q *, int);
void	cmd_find_log_state(const char *, struct cmd_find_state *);
@


1.20
log
@Change cmd_find_target to use a state struct from the caller.
@
text
@d1 1
a1 1
/* $OpenBSD: cmd-find.c,v 1.19 2015/12/13 15:32:12 nicm Exp $ */
d470 3
a472 3
		if (~fs->flags & CMD_FIND_WINDOW_INDEX) {
			fs->wl = fs->s->curw;
			fs->w = fs->wl->window;
a473 1
		}
d495 7
d985 1
a985 2
			if (~flags & CMD_FIND_WINDOW_INDEX)
				fs->wp = fs->wl->window->active;
d1025 1
a1025 2
		if (~flags & CMD_FIND_WINDOW_INDEX)
			fs->wp = fs->wl->window->active;
@


1.19
log
@Remove the cmd_find_{session,window,pane,index} functions (which are
just wrappers around cmd_find_target) and just use cmd_find_target
directly.
@
text
@d1 1
a1 1
/* $OpenBSD: cmd-find.c,v 1.18 2015/12/13 15:00:37 nicm Exp $ */
d792 7
a798 4
/* Split target into pieces and resolve for the given type. */
struct cmd_find_state *
cmd_find_target(struct cmd_q *cmdq, const char *target, enum cmd_find_type type,
    int flags)
d800 4
a803 4
	static struct cmd_find_state	 fs, current;
	struct mouse_event		*m;
	char				*colon, *period, *copy = NULL;
	const char			*session, *window, *pane;
d828 2
a829 2
	cmd_find_clear_state(&fs, cmdq, flags);
	fs.current = &current;
d840 3
a842 3
			fs.wp = cmd_mouse_pane(m, &fs.s, &fs.wl);
			if (fs.wp != NULL)
				fs.w = fs.wl->window;
d846 4
a849 4
			fs.wl = cmd_mouse_window(m, &fs.s);
			if (fs.wl != NULL) {
				fs.w = fs.wl->window;
				fs.wp = fs.w->active;
d853 1
a853 1
		if (fs.wp == NULL) {
d868 5
a872 5
		fs.s = marked_session;
		fs.wl = marked_winlink;
		fs.idx = fs.wl->idx;
		fs.w = fs.wl->window;
		fs.wp = marked_window_pane;
d925 1
a925 1
		fs.flags |= CMD_FIND_EXACT_SESSION;
d929 1
a929 1
		fs.flags |= CMD_FIND_EXACT_WINDOW;
d962 1
a962 1
		if (cmd_find_get_session(&fs, session) != 0)
d967 4
a970 4
			fs.wl = fs.s->curw;
			fs.idx = -1;
			fs.w = fs.wl->window;
			fs.wp = fs.w->active;
d977 1
a977 1
			if (cmd_find_get_window_with_session(&fs, window) != 0)
d980 1
a980 1
				fs.wp = fs.wl->window->active;
d987 1
a987 1
			if (cmd_find_get_pane_with_session(&fs, pane) != 0)
d996 1
a996 1
		if (cmd_find_get_window_with_session(&fs, window) != 0)
d999 1
a999 1
		if (cmd_find_get_pane_with_window(&fs, pane) != 0)
d1007 1
a1007 1
		if (cmd_find_get_window(&fs, window) != 0)
d1010 1
a1010 1
		if (cmd_find_get_pane_with_window(&fs, pane) != 0)
d1018 1
a1018 1
		if (cmd_find_get_window(&fs, window) != 0)
d1021 1
a1021 1
			fs.wp = fs.wl->window->active;
d1028 1
a1028 1
		if (cmd_find_get_pane(&fs, pane) != 0)
d1034 1
a1034 2
	/* None is the current session. */
	free(copy);
d1037 2
a1038 2
	cmd_find_log_state(__func__, &current);
	return (&current);
d1041 3
d1045 1
a1045 2
	log_debug("    error");
	return (NULL);
d1048 3
a1050 1
	cmd_find_log_state(__func__, &fs);
d1052 1
a1052 1
	return (&fs);
@


1.18
log
@Move logging into cmd_find_target rather than each function.
@
text
@d1 1
a1 1
/* $OpenBSD: cmd-find.c,v 1.17 2015/10/28 09:51:55 nicm Exp $ */
a29 25
#define CMD_FIND_PREFER_UNATTACHED 0x1
#define CMD_FIND_QUIET 0x2
#define CMD_FIND_WINDOW_INDEX 0x4
#define CMD_FIND_DEFAULT_MARKED 0x8
#define CMD_FIND_EXACT_SESSION 0x10
#define CMD_FIND_EXACT_WINDOW 0x20

enum cmd_find_type {
	CMD_FIND_PANE,
	CMD_FIND_WINDOW,
	CMD_FIND_SESSION,
};

struct cmd_find_state {
	struct cmd_q		*cmdq;
	int			 flags;
	struct cmd_find_state	*current;

	struct session          *s;
	struct winlink          *wl;
	struct window		*w;
	struct window_pane      *wp;
	int			 idx;
};

a55 3
struct cmd_find_state	*cmd_find_target(struct cmd_q *, const char *,
	    enum cmd_find_type, int);

a1086 100
/* Find the current session. */
struct session *
cmd_find_current(struct cmd_q *cmdq)
{
	struct cmd_find_state	*fs;
	int			 flags = CMD_FIND_QUIET;

	fs = cmd_find_target(cmdq, NULL, CMD_FIND_SESSION, flags);
	if (fs == NULL)
		return (NULL);

	return (fs->s);
}

/* Find the target session or report an error and return NULL. */
struct session *
cmd_find_session(struct cmd_q *cmdq, const char *target, int prefer_unattached)
{
	struct cmd_find_state	*fs;
	int			 flags = 0;

	if (prefer_unattached)
		flags |= CMD_FIND_PREFER_UNATTACHED;

	fs = cmd_find_target(cmdq, target, CMD_FIND_SESSION, flags);
	if (fs == NULL)
		return (NULL);

	return (fs->s);
}

/* Find the target window or report an error and return NULL. */
struct winlink *
cmd_find_window(struct cmd_q *cmdq, const char *target, struct session **sp)
{
	struct cmd_find_state	*fs;

	fs = cmd_find_target(cmdq, target, CMD_FIND_WINDOW, 0);
	if (fs == NULL)
		return (NULL);

	if (sp != NULL)
		*sp = fs->s;
	return (fs->wl);
}

/* Find the target window, defaulting to marked rather than current. */
struct winlink *
cmd_find_window_marked(struct cmd_q *cmdq, const char *target,
    struct session **sp)
{
	struct cmd_find_state	*fs;
	int			 flags = CMD_FIND_DEFAULT_MARKED;

	fs = cmd_find_target(cmdq, target, CMD_FIND_WINDOW, flags);
	if (fs == NULL)
		return (NULL);

	if (sp != NULL)
		*sp = fs->s;
	return (fs->wl);
}

/* Find the target pane and report an error and return NULL. */
struct winlink *
cmd_find_pane(struct cmd_q *cmdq, const char *target, struct session **sp,
    struct window_pane **wpp)
{
	struct cmd_find_state	*fs;

	fs = cmd_find_target(cmdq, target, CMD_FIND_PANE, 0);
	if (fs == NULL)
		return (NULL);

	if (sp != NULL)
		*sp = fs->s;
	if (wpp != NULL)
		*wpp = fs->wp;
	return (fs->wl);
}

/* Find the target pane, defaulting to marked rather than current. */
struct winlink *
cmd_find_pane_marked(struct cmd_q *cmdq, const char *target,
    struct session **sp, struct window_pane **wpp)
{
	struct cmd_find_state	*fs;
	int			 flags = CMD_FIND_DEFAULT_MARKED;

	fs = cmd_find_target(cmdq, target, CMD_FIND_PANE, flags);
	if (fs == NULL)
		return (NULL);

	if (sp != NULL)
		*sp = fs->s;
	if (wpp != NULL)
		*wpp = fs->wp;
	return (fs->wl);
}

a1134 21
}

/*
 * Find the target session and window index, whether or not it exists in the
 * session. Return -2 on error or -1 if no window index is specified. This is
 * used when parsing an argument for a window target that may not exist (for
 * example if it is going to be created).
 */
int
cmd_find_index(struct cmd_q *cmdq, const char *target, struct session **sp)
{
	struct cmd_find_state	*fs;
	int			 flags = CMD_FIND_WINDOW_INDEX;

	fs = cmd_find_target(cmdq, target, CMD_FIND_WINDOW, flags);
	if (fs == NULL)
		return (-2);

	if (sp != NULL)
		*sp = fs->s;
	return (fs->idx);
@


1.17
log
@Like options, move the environ struct into environ.c.
@
text
@d1 1
a1 1
/* $OpenBSD: cmd-find.c,v 1.16 2015/10/27 13:23:24 nicm Exp $ */
d79 1
a79 1
void	cmd_find_log_state(const char *, const char *, struct cmd_find_state *);
d830 7
d883 1
a883 1
		return (&fs);
d898 1
a898 1
		return (&fs);
d1063 1
d1068 1
d1072 1
d1094 1
a1094 1
cmd_find_log_state(const char *f, const char *target, struct cmd_find_state *fs)
a1095 4
	log_debug("%s: target %s%s", f, target == NULL ? "none" : target,
	    fs != NULL ? "" : " (failed)");
	if (fs == NULL)
		return;
d1097 1
a1097 1
		log_debug("\ts=$%u", fs->s->id);
d1099 1
a1099 1
		log_debug("\ts=none");
d1101 1
a1101 1
		log_debug("\twl=%u %d w=@@%u %s", fs->wl->idx,
d1104 1
a1104 1
		log_debug("\twl=none");
d1106 1
a1106 1
		log_debug("\twp=%%%u", fs->wp->id);
d1108 1
a1108 1
		log_debug("\twp=none");
d1110 1
a1110 1
		log_debug("\tidx=%d", fs->idx);
d1112 1
a1112 1
		log_debug("\tidx=none");
a1122 1
	cmd_find_log_state(__func__, NULL, fs);
a1139 1
	cmd_find_log_state(__func__, target, fs);
a1152 1
	cmd_find_log_state(__func__, target, fs);
a1169 1
	cmd_find_log_state(__func__, target, fs);
a1185 1
	cmd_find_log_state(__func__, target, fs);
a1204 1
	cmd_find_log_state(__func__, target, fs);
a1277 1
	cmd_find_log_state(__func__, target, fs);
@


1.16
log
@Break the common process set up, event loop and imsg dispatch code
between server and client out into a separate internal API. This will
make it easier to add another process.
@
text
@d1 1
a1 1
/* $OpenBSD: cmd-find.c,v 1.15 2015/10/23 16:29:07 nicm Exp $ */
d124 1
a124 1
	envent = environ_find(&c->environ, "TMUX");
@


1.15
log
@If $TMUX is set, and we are unsure about the session, use it.
@
text
@d1 1
a1 1
/* $OpenBSD: cmd-find.c,v 1.14 2015/10/22 11:23:00 nicm Exp $ */
d132 2
a133 2
	log_debug("client %d TMUX is %s (session @@%u)", c->ibuf.fd,
	    envent->value, session);
d336 2
d370 3
a372 1
	if (cmdq->client != NULL && cmdq->client->session != NULL)
d374 1
d383 1
d1229 1
d1261 1
@


1.14
log
@If the pane is still on all_window_panes but not actually connected to
window or session (which can happen if it is killed during a command
sequence and something else has a reference), fall back to the best
effort. Fixes "tmux killw\; detach" for Rudis Muiznieks.
@
text
@d1 1
a1 1
/* $OpenBSD: cmd-find.c,v 1.13 2015/09/14 13:22:02 nicm Exp $ */
d26 1
d55 1
d114 27
d224 6
d315 3
a317 1
	fs->s = cmd_find_best_session(NULL, 0, fs->flags);
@


1.13
log
@Remove some extra blank lines.
@
text
@d1 1
a1 1
/* $OpenBSD: cmd-find.c,v 1.12 2015/08/13 15:02:23 nicm Exp $ */
d258 2
a259 10
	if (wp == NULL) {
		fs->s = cmd_find_best_session(NULL, 0, fs->flags);
		if (fs->s == NULL)
			return (-1);
		fs->wl = fs->s->curw;
		fs->idx = fs->wl->idx;
		fs->w = fs->wl->window;
		fs->wp = fs->w->active;
		return (0);
	}
d266 16
a281 1
	if (cmd_find_best_session_with_window(fs) != 0)
d283 4
@


1.12
log
@right-up should be right-of, also rename the values too.
@
text
@d1 1
a1 1
/* $OpenBSD: cmd-find.c,v 1.11 2015/08/12 08:55:20 nicm Exp $ */
a563 1

@


1.11
log
@Rename left/right/up/down relative to active pane to add -of suffix
(left-of/right-of/etc) to remove conflict with left/right meaning
leftmost or rightmost pane. From Ben Boeckel.
@
text
@d1 1
a1 1
/* $OpenBSD: cmd-find.c,v 1.10 2015/06/05 09:09:08 nicm Exp $ */
d105 4
a108 4
	{ "{up-of}", "{up}" },
	{ "{down-of}", "{down}" },
	{ "{left-of}", "{left}" },
	{ "{right-up}", "{right}" },
d702 1
a702 1
	} else if (strcmp(pane, "{up}") == 0) {
d707 1
a707 1
	} else if (strcmp(pane, "{down}") == 0) {
d712 1
a712 1
	} else if (strcmp(pane, "{left}") == 0) {
d717 1
a717 1
	} else if (strcmp(pane, "{right}") == 0) {
@


1.10
log
@Fix a warning.
@
text
@d1 1
a1 1
/* $OpenBSD: cmd-find.c,v 1.9 2015/06/05 08:14:16 nicm Exp $ */
d105 4
a108 4
	{ "{up}", "{up}" },
	{ "{down}", "{down}" },
	{ "{left}", "{left}" },
	{ "{right}", "{right}" },
@


1.9
log
@Make it so that if a window or session target is prefixed with an =,
only an exact name or index match is accepted, no special character,
prefix match, or fnmatch.
@
text
@d1 1
a1 1
/* $OpenBSD: cmd-find.c,v 1.8 2015/06/04 11:43:51 nicm Exp $ */
d479 1
a479 1
	if (!exact && window[0] == '+' || window[0] == '-') {
@


1.8
log
@Add support for a single "marked pane". There is one marked pane in the
server at a time; it may be toggled or cleared with select-pane -m and
-M (the border is highlighted). A new target '~' or '{marked}' specifies
the marked pane to commands and it is the default target for the
swap-pane and join-pane -s flag (this makes them much simpler to use -
mark the source pane and then change to the target pane to run swapp or
joinp).
@
text
@d1 1
a1 1
/* $OpenBSD: cmd-find.c,v 1.7 2015/05/07 11:42:56 nicm Exp $ */
d33 2
d386 4
d464 1
a464 1
	int		 idx, n;
d468 1
d479 1
a479 1
	if (window[0] == '+' || window[0] == '-') {
d509 23
a531 21
	if (strcmp(window, "!") == 0) {
		fs->wl = TAILQ_FIRST(&fs->s->lastw);
		if (fs->wl == NULL)
			return (-1);
		fs->idx = fs->wl->idx;
		fs->w = fs->wl->window;
		return (0);
	} else if (strcmp(window, "^") == 0) {
		fs->wl = RB_MIN(winlinks, &fs->s->windows);
		if (fs->wl == NULL)
			return (-1);
		fs->idx = fs->wl->idx;
		fs->w = fs->wl->window;
		return (0);
	} else if (strcmp(window, "$") == 0) {
		fs->wl = RB_MAX(winlinks, &fs->s->windows);
		if (fs->wl == NULL)
			return (-1);
		fs->idx = fs->wl->idx;
		fs->w = fs->wl->window;
		return (0);
d535 12
a546 10
	idx = strtonum(window, 0, INT_MAX, &errstr);
	if (errstr == NULL) {
		if (fs->flags & CMD_FIND_WINDOW_INDEX) {
			fs->idx = idx;
			return (0);
		}
		fs->wl = winlink_find_by_index(&fs->s->windows, idx);
		if (fs->wl != NULL) {
			fs->w = fs->wl->window;
			return (0);
d565 5
d885 10
@


1.7
log
@Style spacing nits.
@
text
@d1 1
a1 1
/* $OpenBSD: cmd-find.c,v 1.6 2015/04/28 12:09:24 nicm Exp $ */
d32 1
d763 8
a770 1
	if (cmd_find_current_session(&current) != 0) {
d809 15
a823 1
	copy = xstrdup(target);
d826 1
d1079 18
d1105 20
@


1.6
log
@If looking for an index, don't fill in window when given a session.
@
text
@d1 1
a1 1
/* $OpenBSD: cmd-find.c,v 1.5 2015/04/28 11:57:20 nicm Exp $ */
d196 1
a196 1
		slist = xreallocarray (slist, ssize + 1, sizeof *slist);
d204 1
a204 1
	free (slist);
d332 1
a332 1
			clist = xreallocarray (clist, csize + 1, sizeof *clist);
d742 1
a742 1
	memset (fs, 0, sizeof *fs);
@


1.5
log
@Do not do a search for the tty path if there isn't one.
@
text
@d1 1
a1 1
/* $OpenBSD: cmd-find.c,v 1.4 2015/04/28 11:33:17 nicm Exp $ */
d437 5
a441 3
		fs->wl = fs->s->curw;
		fs->idx = fs->wl->idx;
		fs->w = fs->wl->window;
@


1.4
log
@If can't find pane as a pane, try as a window; likewise if can't find
window as a session.
@
text
@d1 1
a1 1
/* $OpenBSD: cmd-find.c,v 1.3 2015/04/27 22:58:58 nicm Exp $ */
d246 7
a252 4
	RB_FOREACH(wp, window_pane_tree, &all_window_panes) {
		if (strcmp(wp->tty, fs->cmdq->client->tty.path) == 0)
			break;
	}
@


1.3
log
@Do not include unattached clients when trying to find one for target.
@
text
@d1 1
a1 1
/* $OpenBSD: cmd-find.c,v 1.2 2015/04/27 22:42:10 nicm Exp $ */
d429 12
a440 1
	return (cmd_find_get_window_with_session(fs, window));
d606 1
a606 1
	/* Not a pane id, so use the current session and window. */
d613 10
a622 1
	return (cmd_find_get_pane_with_window(fs, pane));
@


1.2
log
@Assign to the right variable when comparing clients.
@
text
@d1 1
a1 1
/* $OpenBSD: cmd-find.c,v 1.1 2015/04/27 16:25:57 nicm Exp $ */
d128 2
d135 2
@


1.1
log
@Rewrite of the target resolution internals to be simpler and more
consistent but with much less duplication, but keeping the same internal
API. Also adds more readable aliases for some of the special tokens used
in targets (eg "{start}" instead of "^"). Some behaviours may have
changed, for example prefix matches now happen before fnmatch.
@
text
@d1 1
a1 1
/* $OpenBSD: cmd.c,v 1.100 2015/04/21 22:42:27 nicm Exp $ */
d134 1
a134 1
				c_loop = c;
@

