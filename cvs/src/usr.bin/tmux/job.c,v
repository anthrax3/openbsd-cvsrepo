head	1.42;
access;
symbols
	OPENBSD_6_1_BASE:1.42
	OPENBSD_6_0:1.40.0.4
	OPENBSD_6_0_BASE:1.40
	OPENBSD_5_9:1.40.0.2
	OPENBSD_5_9_BASE:1.40
	OPENBSD_5_8:1.36.0.4
	OPENBSD_5_8_BASE:1.36
	OPENBSD_5_7:1.34.0.2
	OPENBSD_5_7_BASE:1.34
	OPENBSD_5_6:1.33.0.4
	OPENBSD_5_6_BASE:1.33
	OPENBSD_5_5:1.32.0.4
	OPENBSD_5_5_BASE:1.32
	OPENBSD_5_4:1.31.0.2
	OPENBSD_5_4_BASE:1.31
	OPENBSD_5_3:1.27.0.4
	OPENBSD_5_3_BASE:1.27
	OPENBSD_5_2:1.27.0.2
	OPENBSD_5_2_BASE:1.27
	OPENBSD_5_1_BASE:1.26
	OPENBSD_5_1:1.26.0.2
	OPENBSD_5_0:1.25.0.4
	OPENBSD_5_0_BASE:1.25
	OPENBSD_4_9:1.25.0.2
	OPENBSD_4_9_BASE:1.25
	OPENBSD_4_8:1.19.0.2
	OPENBSD_4_8_BASE:1.19
	OPENBSD_4_7:1.15.0.2
	OPENBSD_4_7_BASE:1.15;
locks; strict;
comment	@ * @;


1.42
date	2017.03.09.17.02.38;	author nicm;	state Exp;
branches;
next	1.41;
commitid	QtFskEpSXY809LlK;

1.41
date	2016.10.10.21.29.23;	author nicm;	state Exp;
branches;
next	1.40;
commitid	z4Hr4PZF7Ev93uEJ;

1.40
date	2016.01.19.15.59.12;	author nicm;	state Exp;
branches;
next	1.39;
commitid	P3qmSOx6KrDBsb0c;

1.39
date	2015.11.18.14.27.44;	author nicm;	state Exp;
branches;
next	1.38;
commitid	RjsAPRkWwvS79w40;

1.38
date	2015.10.31.08.13.58;	author nicm;	state Exp;
branches;
next	1.37;
commitid	B5GekkO0CdWpFMrz;

1.37
date	2015.10.28.09.51.55;	author nicm;	state Exp;
branches;
next	1.36;
commitid	eGVGKzVVYKHFvkn4;

1.36
date	2015.06.17.16.44.49;	author nicm;	state Exp;
branches;
next	1.35;
commitid	uyHvvQkXqCKEuAjn;

1.35
date	2015.04.24.22.19.36;	author nicm;	state Exp;
branches;
next	1.34;
commitid	h1lxJjTgcLGsGtE8;

1.34
date	2014.10.20.23.27.14;	author nicm;	state Exp;
branches;
next	1.33;
commitid	BAMrPS0saBiCc8HD;

1.33
date	2014.04.14.22.27.30;	author nicm;	state Exp;
branches;
next	1.32;

1.32
date	2013.10.10.12.35.31;	author nicm;	state Exp;
branches;
next	1.31;

1.31
date	2013.04.17.08.41.41;	author nicm;	state Exp;
branches;
next	1.30;

1.30
date	2013.04.10.12.20.35;	author nicm;	state Exp;
branches;
next	1.29;

1.29
date	2013.03.25.11.43.01;	author nicm;	state Exp;
branches;
next	1.28;

1.28
date	2013.03.22.10.31.22;	author nicm;	state Exp;
branches;
next	1.27;

1.27
date	2012.07.10.11.53.01;	author nicm;	state Exp;
branches;
next	1.26;

1.26
date	2012.01.29.02.22.11;	author nicm;	state Exp;
branches;
next	1.25;

1.25
date	2011.01.26.01.54.56;	author nicm;	state Exp;
branches;
next	1.24;

1.24
date	2011.01.26.00.11.47;	author nicm;	state Exp;
branches;
next	1.23;

1.23
date	2011.01.23.11.03.43;	author nicm;	state Exp;
branches;
next	1.22;

1.22
date	2011.01.08.01.52.36;	author nicm;	state Exp;
branches;
next	1.21;

1.21
date	2010.10.16.08.31.55;	author nicm;	state Exp;
branches;
next	1.20;

1.20
date	2010.08.19.18.29.01;	author nicm;	state Exp;
branches;
next	1.19;

1.19
date	2010.05.04.17.28.16;	author nicm;	state Exp;
branches;
next	1.18;

1.18
date	2010.05.04.08.48.06;	author nicm;	state Exp;
branches;
next	1.17;

1.17
date	2010.05.03.16.06.32;	author nicm;	state Exp;
branches;
next	1.16;

1.16
date	2010.04.04.19.02.09;	author nicm;	state Exp;
branches;
next	1.15;

1.15
date	2010.02.24.19.13.38;	author nicm;	state Exp;
branches;
next	1.14;

1.14
date	2009.12.03.22.50.10;	author nicm;	state Exp;
branches;
next	1.13;

1.13
date	2009.11.26.21.37.13;	author nicm;	state Exp;
branches;
next	1.12;

1.12
date	2009.11.04.21.10.49;	author nicm;	state Exp;
branches;
next	1.11;

1.11
date	2009.11.04.21.04.43;	author nicm;	state Exp;
branches;
next	1.10;

1.10
date	2009.11.04.20.50.11;	author nicm;	state Exp;
branches;
next	1.9;

1.9
date	2009.11.01.23.20.37;	author nicm;	state Exp;
branches;
next	1.8;

1.8
date	2009.10.21.18.20.16;	author nicm;	state Exp;
branches;
next	1.7;

1.7
date	2009.10.21.07.24.23;	author nicm;	state Exp;
branches;
next	1.6;

1.6
date	2009.10.20.22.15.32;	author nicm;	state Exp;
branches;
next	1.5;

1.5
date	2009.10.11.08.58.05;	author nicm;	state Exp;
branches;
next	1.4;

1.4
date	2009.10.11.07.30.07;	author nicm;	state Exp;
branches;
next	1.3;

1.3
date	2009.10.11.07.20.16;	author nicm;	state Exp;
branches;
next	1.2;

1.2
date	2009.10.10.18.42.14;	author nicm;	state Exp;
branches;
next	1.1;

1.1
date	2009.10.10.15.03.01;	author nicm;	state Exp;
branches;
next	;


desc
@@


1.42
log
@Move server_fill_environ into environ.c and move some other common code
into it.
@
text
@/* $OpenBSD: job.c,v 1.41 2016/10/10 21:29:23 nicm Exp $ */

/*
 * Copyright (c) 2009 Nicholas Marriott <nicholas.marriott@@gmail.com>
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF MIND, USE, DATA OR PROFITS, WHETHER
 * IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING
 * OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */

#include <sys/types.h>
#include <sys/socket.h>

#include <fcntl.h>
#include <paths.h>
#include <signal.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>

#include "tmux.h"

/*
 * Job scheduling. Run queued commands in the background and record their
 * output.
 */

static void	job_callback(struct bufferevent *, short, void *);
static void	job_write_callback(struct bufferevent *, void *);

/* All jobs list. */
struct joblist	all_jobs = LIST_HEAD_INITIALIZER(all_jobs);

/* Start a job running, if it isn't already. */
struct job *
job_run(const char *cmd, struct session *s, const char *cwd,
    void (*callbackfn)(struct job *), void (*freefn)(void *), void *data)
{
	struct job	*job;
	struct environ	*env;
	pid_t		 pid;
	int		 nullfd, out[2];
	const char	*home;

	if (socketpair(AF_UNIX, SOCK_STREAM, PF_UNSPEC, out) != 0)
		return (NULL);

	env = environ_for_session(s);
	switch (pid = fork()) {
	case -1:
		environ_free(env);
		close(out[0]);
		close(out[1]);
		return (NULL);
	case 0:		/* child */
		clear_signals(1);

		if (cwd == NULL || chdir(cwd) != 0) {
			if ((home = find_home()) == NULL || chdir(home) != 0)
				chdir("/");
		}

		environ_push(env);
		environ_free(env);

		if (dup2(out[1], STDIN_FILENO) == -1)
			fatal("dup2 failed");
		if (dup2(out[1], STDOUT_FILENO) == -1)
			fatal("dup2 failed");
		if (out[1] != STDIN_FILENO && out[1] != STDOUT_FILENO)
			close(out[1]);
		close(out[0]);

		nullfd = open(_PATH_DEVNULL, O_RDWR, 0);
		if (nullfd < 0)
			fatal("open failed");
		if (dup2(nullfd, STDERR_FILENO) == -1)
			fatal("dup2 failed");
		if (nullfd != STDERR_FILENO)
			close(nullfd);

		closefrom(STDERR_FILENO + 1);

		execl(_PATH_BSHELL, "sh", "-c", cmd, (char *) NULL);
		fatal("execl failed");
	}

	/* parent */
	environ_free(env);
	close(out[1]);

	job = xmalloc(sizeof *job);
	job->state = JOB_RUNNING;

	job->cmd = xstrdup(cmd);
	job->pid = pid;
	job->status = 0;

	LIST_INSERT_HEAD(&all_jobs, job, lentry);

	job->callbackfn = callbackfn;
	job->freefn = freefn;
	job->data = data;

	job->fd = out[0];
	setblocking(job->fd, 0);

	job->event = bufferevent_new(job->fd, NULL, job_write_callback,
	    job_callback, job);
	bufferevent_enable(job->event, EV_READ|EV_WRITE);

	log_debug("run job %p: %s, pid %ld", job, job->cmd, (long) job->pid);
	return (job);
}

/* Kill and free an individual job. */
void
job_free(struct job *job)
{
	log_debug("free job %p: %s", job, job->cmd);

	LIST_REMOVE(job, lentry);
	free(job->cmd);

	if (job->freefn != NULL && job->data != NULL)
		job->freefn(job->data);

	if (job->pid != -1)
		kill(job->pid, SIGTERM);
	if (job->event != NULL)
		bufferevent_free(job->event);
	if (job->fd != -1)
		close(job->fd);

	free(job);
}

/* Called when output buffer falls below low watermark (default is 0). */
static void
job_write_callback(__unused struct bufferevent *bufev, void *data)
{
	struct job	*job = data;
	size_t		 len = EVBUFFER_LENGTH(EVBUFFER_OUTPUT(job->event));

	log_debug("job write %p: %s, pid %ld, output left %zu", job, job->cmd,
	    (long) job->pid, len);

	if (len == 0) {
		shutdown(job->fd, SHUT_WR);
		bufferevent_disable(job->event, EV_WRITE);
	}
}

/* Job buffer error callback. */
static void
job_callback(__unused struct bufferevent *bufev, __unused short events,
    void *data)
{
	struct job	*job = data;

	log_debug("job error %p: %s, pid %ld", job, job->cmd, (long) job->pid);

	if (job->state == JOB_DEAD) {
		if (job->callbackfn != NULL)
			job->callbackfn(job);
		job_free(job);
	} else {
		bufferevent_disable(job->event, EV_READ);
		job->state = JOB_CLOSED;
	}
}

/* Job died (waitpid() returned its pid). */
void
job_died(struct job *job, int status)
{
	log_debug("job died %p: %s, pid %ld", job, job->cmd, (long) job->pid);

	job->status = status;

	if (job->state == JOB_CLOSED) {
		if (job->callbackfn != NULL)
			job->callbackfn(job);
		job_free(job);
	} else {
		job->pid = -1;
		job->state = JOB_DEAD;
	}
}
@


1.41
log
@Loads more static, except for cmd-*.c and window-*.c.
@
text
@d1 1
a1 1
/* $OpenBSD: job.c,v 1.40 2016/01/19 15:59:12 nicm Exp $ */
d56 1
a56 6
	env = environ_create();
	environ_copy(global_environ, env);
	if (s != NULL)
		environ_copy(s->environ, env);
	server_fill_environ(s, env);

@


1.40
log
@I no longer use my SourceForge address so replace it.
@
text
@d1 1
a1 1
/* $OpenBSD: job.c,v 1.39 2015/11/18 14:27:44 nicm Exp $ */
d36 2
a37 2
void	job_callback(struct bufferevent *, short, void *);
void	job_write_callback(struct bufferevent *, void *);
d152 1
a152 1
void
d168 1
a168 1
void
@


1.39
log
@Use __unused rather than rolling our own.
@
text
@d1 1
a1 1
/* $OpenBSD: job.c,v 1.38 2015/10/31 08:13:58 nicm Exp $ */
d4 1
a4 1
 * Copyright (c) 2009 Nicholas Marriott <nicm@@users.sourceforge.net>
@


1.38
log
@Because pledge(2) does not allow us to pass directory file descriptors
around, we can't use file descriptors for the working directory because
we will be unable to pass it to a privileged process to tell it where to
read or write files or spawn children. So move tmux back to using
strings for the current working directory. We try to check it exists
with access() when it is set but ultimately fall back to ~ if it fails
at time of use (or / if that fails too).
@
text
@d1 1
a1 1
/* $OpenBSD: job.c,v 1.37 2015/10/28 09:51:55 nicm Exp $ */
d153 1
a153 1
job_write_callback(unused struct bufferevent *bufev, void *data)
d169 2
a170 1
job_callback(unused struct bufferevent *bufev, unused short events, void *data)
@


1.37
log
@Like options, move the environ struct into environ.c.
@
text
@d1 1
a1 1
/* $OpenBSD: job.c,v 1.36 2015/06/17 16:44:49 nicm Exp $ */
d44 1
a44 1
job_run(const char *cmd, struct session *s, int cwd,
d51 1
d71 4
a74 2
		if (cwd != -1 && fchdir(cwd) != 0)
			chdir("/");
@


1.36
log
@Use an explicit job state instead of avoid closing our side of the
socketpair and setting it to -1 to mark when the other side is
closed. This avoids closing it while the libevent bufferevent still has
it (it could try to add it to the polled set which some mechanisms don't
like). Fixes part a problem reported by Bruno Sutic.
@
text
@d1 1
a1 1
/* $OpenBSD: job.c,v 1.35 2015/04/24 22:19:36 nicm Exp $ */
d48 1
a48 1
	struct environ	 env;
d55 2
a56 2
	environ_init(&env);
	environ_copy(&global_environ, &env);
d58 2
a59 2
		environ_copy(&s->environ, &env);
	server_fill_environ(s, &env);
d63 1
a63 1
		environ_free(&env);
d73 2
a74 2
		environ_push(&env);
		environ_free(&env);
d99 1
a99 1
	environ_free(&env);
@


1.35
log
@Set working directory for run-shell and if-shell.
@
text
@d1 1
a1 1
/* $OpenBSD: job.c,v 1.34 2014/10/20 23:27:14 nicm Exp $ */
d103 2
d172 1
a172 1
	if (job->pid == -1) {
d178 1
a178 2
		close(job->fd);
		job->fd = -1;
d190 1
a190 1
	if (job->fd == -1) {
d194 1
a194 1
	} else
d196 2
@


1.34
log
@Tidy up some includes.
@
text
@d1 1
a1 1
/* $OpenBSD: job.c,v 1.33 2014/04/14 22:27:30 nicm Exp $ */
d44 1
a44 1
job_run(const char *cmd, struct session *s,
d69 3
@


1.33
log
@Don't leak socketpair file descriptors if fork fails. Spotted by Balazs
Kezes.
@
text
@d1 1
a1 1
/* $OpenBSD: job.c,v 1.32 2013/10/10 12:35:31 nicm Exp $ */
d24 1
@


1.32
log
@Use format_get_command() and some spacing tweaks.
@
text
@d1 1
a1 1
/* $OpenBSD: job.c,v 1.31 2013/04/17 08:41:41 nicm Exp $ */
d63 2
@


1.31
log
@%zu format for size_t.
@
text
@d1 1
a1 1
/* $OpenBSD: job.c,v 1.30 2013/04/10 12:20:35 nicm Exp $ */
d148 1
a148 1
		    (long) job->pid, len);
@


1.30
log
@Set EV_WRITE for jobs or run/if-shell jobs can hang. From Chris Johnsen.
@
text
@d1 1
a1 1
/* $OpenBSD: job.c,v 1.29 2013/03/25 11:43:01 nicm Exp $ */
d147 2
a148 2
	log_debug("job write %p: %s, pid %ld, output left %lu", job, job->cmd,
		    (long) job->pid, (unsigned long) len);
@


1.29
log
@Extend jobs to support writing and use that for copy-pipe instead of
popen, from Chris Johnsen.
@
text
@d1 1
a1 1
/* $OpenBSD: job.c,v 1.28 2013/03/22 10:31:22 nicm Exp $ */
d112 1
a112 1
	bufferevent_enable(job->event, EV_READ);
@


1.28
log
@No more lint means no more ARGSUSED.
@
text
@d1 1
a1 1
/* $OpenBSD: job.c,v 1.27 2012/07/10 11:53:01 nicm Exp $ */
d36 1
d43 1
a43 1
job_run(const char *cmd,
d56 3
a58 1
	server_fill_environ(NULL, &env);
d70 2
d74 1
a74 1
		if (out[1] != STDOUT_FILENO)
a80 2
		if (dup2(nullfd, STDIN_FILENO) == -1)
			fatal("dup2 failed");
d83 1
a83 1
		if (nullfd != STDIN_FILENO && nullfd != STDERR_FILENO)
d110 2
a111 1
	job->event = bufferevent_new(job->fd, NULL, NULL, job_callback, job);
d138 16
@


1.27
log
@xfree is not particularly helpful, remove it. From Thomas Adam.
@
text
@d1 1
a1 1
/* $OpenBSD: job.c,v 1.26 2012/01/29 02:22:11 nicm Exp $ */
a136 1
/* ARGSUSED */
@


1.26
log
@Call bufferevent_free before closing file descriptor associated with it
or bugs in $EventMechanism on $OtherOS makes libevent get it's knickers
in a twist. From Dylan Alex Simon.
@
text
@d1 1
a1 1
/* $OpenBSD: job.c,v 1.25 2011/01/26 01:54:56 nicm Exp $ */
d24 1
d121 1
a121 1
	xfree(job->cmd);
d133 1
a133 1
	xfree(job);
@


1.25
log
@Simplify the way jobs work and drop the persist type, so all jobs are
fire-and-forget.

Status jobs now managed with two trees of output (new and old), rather
than storing the output in the jobs themselves. When the status line is
processed any jobs which don't appear in the new tree are started and
the output from the old tree displayed. When a job finishes it updates
the new tree with its output and that is used for any subsequent
redraws. When the status interval expires, the new tree is moved to the
old so that all jobs are run again.

This fixes the "#(echo %H:%M:%S)" problem which would lead to thousands
of identical persistent jobs and high memory use (this can still be
achieved by adding "sleep 30" but that is much less likely to happen by
accident).
@
text
@d1 1
a1 1
/* $OpenBSD: job.c,v 1.24 2011/01/26 00:11:47 nicm Exp $ */
d127 2
a130 2
	if (job->event != NULL)
		bufferevent_free(job->event);
@


1.24
log
@Use LIST_* not SLIST_*.
@
text
@d1 1
a1 1
/* $OpenBSD: job.c,v 1.23 2011/01/23 11:03:43 nicm Exp $ */
d34 2
d39 1
a39 31
RB_GENERATE(jobs, job, entry, job_cmp);

void	job_callback(struct bufferevent *, short, void *);

int
job_cmp(struct job *job1, struct job *job2)
{
	return (strcmp(job1->cmd, job2->cmd));
}

/* Initialise job tree. */
void
job_tree_init(struct jobs *jobs)
{
	RB_INIT(jobs);
}

/* Destroy a job tree. */
void
job_tree_free(struct jobs *jobs)
{
	struct job	*job;

	while (!RB_EMPTY(jobs)) {
		job = RB_ROOT(jobs);
		RB_REMOVE(jobs, jobs, job);
		job_free(job);
	}
}

/* Find a job and return it. */
d41 1
a41 11
job_get(struct jobs *jobs, const char *cmd)
{
	struct job	job;

	job.cmd = (char *) cmd;
	return (RB_FIND(jobs, jobs, &job));
}

/* Add a job. */
struct job *
job_add(struct jobs *jobs, int flags, struct client *c, const char *cmd,
d45 3
a47 62

	job = xmalloc(sizeof *job);
	job->cmd = xstrdup(cmd);
	job->pid = -1;
	job->status = 0;

	job->client = c;

	job->fd = -1;
	job->event = NULL;

	job->callbackfn = callbackfn;
	job->freefn = freefn;
	job->data = data;

	job->flags = flags;

	if (jobs != NULL)
		RB_INSERT(jobs, jobs, job);
	LIST_INSERT_HEAD(&all_jobs, job, lentry);

	return (job);
}

/* Remove job from tree and free. */
void
job_remove(struct jobs *jobs, struct job *job)
{
	if (jobs != NULL)
		RB_REMOVE(jobs, jobs, job);
	job_free(job);
}

/* Kill and free an individual job. */
void
job_free(struct job *job)
{
	job_kill(job);

	LIST_REMOVE(job, lentry);
	xfree(job->cmd);

	if (job->freefn != NULL && job->data != NULL)
		job->freefn(job->data);

	if (job->fd != -1)
		close(job->fd);
	if (job->event != NULL)
		bufferevent_free(job->event);

	xfree(job);
}

/* Start a job running, if it isn't already. */
int
job_run(struct job *job)
{
	struct environ	env;
	int		nullfd, out[2];

	if (job->fd != -1 || job->pid != -1)
		return (0);
d50 1
a50 1
		return (-1);
d56 1
a56 1
	switch (job->pid = fork()) {
d59 1
a59 1
		return (-1);
d84 1
a84 1
		execl(_PATH_BSHELL, "sh", "-c", job->cmd, (char *) NULL);
d86 32
a117 3
	default:	/* parent */
		environ_free(&env);
		close(out[1]);
d119 2
a120 2
		job->fd = out[0];
		setblocking(job->fd, 0);
d122 9
a130 5
		if (job->event != NULL)
			bufferevent_free(job->event);
		job->event =
		    bufferevent_new(job->fd, NULL, NULL, job_callback, job);
		bufferevent_enable(job->event, EV_READ);
d132 1
a132 2
		return (0);
	}
d142 1
a142 3
	bufferevent_disable(job->event, EV_READ);
	close(job->fd);
	job->fd = -1;
d147 5
a151 2
		if ((!job->flags & JOB_PERSIST))
			job_free(job);
d159 2
a161 1
	job->pid = -1;
d166 3
a168 13
		if ((!job->flags & JOB_PERSIST))
			job_free(job);
	}
}

/* Kill a job. */
void
job_kill(struct job *job)
{
	if (job->pid == -1)
		return;
	kill(job->pid, SIGTERM);
	job->pid = -1;
@


1.23
log
@Set $TMUX without the session when background jobs are run.
@
text
@d1 1
a1 1
/* $OpenBSD: job.c,v 1.22 2011/01/08 01:52:36 nicm Exp $ */
d35 1
a35 1
struct joblist	all_jobs = SLIST_HEAD_INITIALIZER(all_jobs);
d102 1
a102 1
	SLIST_INSERT_HEAD(&all_jobs, job, lentry);
d122 1
a122 1
	SLIST_REMOVE(&all_jobs, job, job, lentry);
@


1.22
log
@Move all calls to fcntl(...O_NONBLOCK) into a function and clear the
flag on the stdio file descriptors before closing them (fixes things
like "tmux ls && cat").
@
text
@d1 1
a1 1
/* $OpenBSD: job.c,v 1.21 2010/10/16 08:31:55 nicm Exp $ */
d140 2
a141 1
	int	nullfd, out[2];
d149 4
d155 1
d160 2
a161 1
		environ_push(&global_environ);
d184 1
@


1.21
log
@Trying to set FD_CLOEXEC on every fd is a lost cause, just use
closefrom() before exec.
@
text
@d1 1
a1 1
/* $OpenBSD: job.c,v 1.20 2010/08/19 18:29:01 nicm Exp $ */
d140 1
a140 1
	int	nullfd, out[2], mode;
d180 1
a180 4
		if ((mode = fcntl(job->fd, F_GETFL)) == -1)
			fatal("fcntl failed");
		if (fcntl(job->fd, F_SETFL, mode|O_NONBLOCK) == -1)
			fatal("fcntl failed");
@


1.20
log
@Do not call event_del() for signals after fork(), just use sigaction()
directly instead - calling libevent functions after fork() w/o
event_reinit() is a bad idea, even if in this case it was harmless.
@
text
@d1 1
a1 1
/* $OpenBSD: job.c,v 1.19 2010/05/04 17:28:16 nicm Exp $ */
d172 2
a182 2
			fatal("fcntl failed");
		if (fcntl(job->fd, F_SETFD, FD_CLOEXEC) == -1)
@


1.19
log
@Put this back in with the initialisation in the right order.
@
text
@d1 1
a1 1
/* $OpenBSD: job.c,v 1.18 2010/05/04 08:48:06 nicm Exp $ */
d152 1
a152 1
		clear_signals();
@


1.18
log
@Revert last change, it appears to be broken somehow.
@
text
@d1 1
a1 1
/* $OpenBSD: job.c,v 1.16 2010/04/04 19:02:09 nicm Exp $ */
d152 1
a152 1
		server_signal_clear();
@


1.17
log
@Make signal handler setup/teardown two common functions instead of six,
and reset SIGCHLD after fork to fix problems with some shells. From
Romain Francois.
@
text
@d152 1
a152 1
		clear_signals();
@


1.16
log
@Run job commands explicitly in the global enviroment (which can be
modified with setenv -g) rather than with the environment tmux started
with.
@
text
@d1 1
a1 1
/* $OpenBSD: job.c,v 1.15 2010/02/24 19:13:38 nicm Exp $ */
d152 1
a152 1
		server_signal_clear();
@


1.15
log
@Typo fix from Tim van der Molen.
@
text
@d1 1
a1 1
/* $OpenBSD: job.c,v 1.14 2009/12/03 22:50:10 nicm Exp $ */
d153 2
a154 1
		/* XXX environ? */
@


1.14
log
@Massive spaces->tabs and trailing whitespace cleanup, hopefully for the last
time now I've configured emacs to make them displayed in really annoying
colours...
@
text
@d1 1
a1 1
/* $OpenBSD: job.c,v 1.13 2009/11/26 21:37:13 nicm Exp $ */
d35 1
a35 1
struct joblist	all_jobs = SLIST_HEAD_INITIALIZER(&all_jobs);
@


1.13
log
@Remove a couple of unused arguments where possible, and add /* ARGSUSED */ to
the rest to reduce lint output.
@
text
@d1 1
a1 1
/* $OpenBSD: job.c,v 1.12 2009/11/04 21:10:49 nicm Exp $ */
d83 1
a83 1
 
d186 1
a186 1
		job->event = 
d219 1
a219 1
	
@


1.12
log
@Add back JOB_PERSIST checks that got lost.
@
text
@d1 1
a1 1
/* $OpenBSD: job.c,v 1.11 2009/11/04 21:04:43 nicm Exp $ */
d195 1
@


1.11
log
@Switch jobs over to use a bufferevent.
@
text
@d1 1
a1 1
/* $OpenBSD: job.c,v 1.10 2009/11/04 20:50:11 nicm Exp $ */
a129 1

d204 6
a209 2
	if (job->pid == -1 && job->callbackfn != NULL)
		job->callbackfn(job);
d219 6
a224 2
	if (job->fd == -1 && job->callbackfn != NULL)
		job->callbackfn(job);
@


1.10
log
@Initial changes to move tmux to libevent.

This moves the client-side loops are pretty much fully over to event-based only
(tmux.c and client.c) but server-side (server.c and friends) treats libevent as
a sort of clever poll, waking up after every event to run various things.

Moving the server stuff over to bufferevents and timers and so on will come
later.
@
text
@d1 1
a1 1
/* $OpenBSD: job.c,v 1.9 2009/11/01 23:20:37 nicm Exp $ */
d20 1
d39 2
d92 1
a92 2
	job->out = buffer_create(BUFSIZ);
	memset(&job->event, 0, sizeof job->event);
d98 1
a98 1
	job->flags = flags|JOB_DONE;
d130 3
a132 3
	if (job->out != NULL)
		buffer_destroy(job->out);
	event_del(&job->event);
d143 1
a143 1
	if (!(job->flags & JOB_DONE))
a144 1
	job->flags &= ~JOB_DONE;
d146 1
a146 1
	if (pipe(out) != 0)
d185 5
a189 2
		if (BUFFER_USED(job->out) != 0)
			buffer_remove(job->out, BUFFER_USED(job->out));
d193 25
@


1.9
log
@Add a flag for jobs that shouldn't be freed after they've died and use it for
status jobs, then only kill those jobs when status-left, status-right or
set-titles-string is changed.

Fixes problems with changing options from inside #().
@
text
@d1 1
a1 1
/* $OpenBSD: job.c,v 1.8 2009/10/21 18:20:16 nicm Exp $ */
d90 1
d130 1
d152 1
a152 1
		sigreset();
@


1.8
log
@Remove unused function.
@
text
@d1 1
a1 1
/* $OpenBSD: job.c,v 1.7 2009/10/21 07:24:23 nicm Exp $ */
d76 1
a76 1
job_add(struct jobs *jobs, struct client *c, const char *cmd,
d84 1
d95 1
a95 1
	job->flags = JOB_DONE;
d100 1
a100 1
	
d102 9
@


1.7
log
@Getting the read and write ends of the pipe the right way round is usually
recommended. DOH.
@
text
@d1 1
a1 1
/* $OpenBSD: job.c,v 1.6 2009/10/20 22:15:32 nicm Exp $ */
a48 13
}

/* Count the number of jobs in a tree. */
u_int
job_tree_size(struct jobs *jobs)
{
	struct job	*job;
	u_int		 n;

	n = 0;
	RB_FOREACH(job, jobs, jobs)
		n++;
	return (n);
@


1.6
log
@Sort out stdout before stdin/stderr in case the stdout side of the pipe got one
of their fds.
@
text
@d1 1
a1 1
/* $OpenBSD: job.c,v 1.5 2009/10/11 08:58:05 nicm Exp $ */
d156 1
a156 2
		close(out[1]);
		if (dup2(out[0], STDOUT_FILENO) == -1)
d158 3
a160 2
		if (out[0] != STDOUT_FILENO)
			close(out[0]);
d162 1
a162 1
		nullfd = open(_PATH_DEVNULL, O_RDONLY, 0);
d175 1
a175 1
		close(out[0]);
d177 1
a177 1
		job->fd = out[1];
@


1.5
log
@Switch run-shell over to queue the command in the background like #().
@
text
@d1 1
a1 1
/* $OpenBSD: job.c,v 1.4 2009/10/11 07:30:07 nicm Exp $ */
d156 6
a170 6

		close(out[1]);
		if (dup2(out[0], STDOUT_FILENO) == -1)
			fatal("dup2 failed");
		if (out[0] != STDOUT_FILENO)
			close(out[0]);
@


1.4
log
@There isn't much point in having a free function if it isn't used.

Also allow a NULL tree.
@
text
@d1 1
a1 1
/* $OpenBSD: job.c,v 1.3 2009/10/11 07:20:16 nicm Exp $ */
a72 1
		SLIST_REMOVE(&all_jobs, job, job, lentry);
d122 1
@


1.3
log
@Collect status from dead jobs and don't invoke the callback until both
all input (the socket is closed) and status is available.
@
text
@d1 1
a1 1
/* $OpenBSD: job.c,v 1.1 2009/10/10 15:03:01 nicm Exp $ */
d110 2
a111 1
	RB_INSERT(jobs, jobs, job);
d124 3
@


1.2
log
@Put all jobs on a global all_jobs list and use that in server.c instead of
running through all the clients.
@
text
@d108 2
d138 1
a138 1
	if (job->fd != -1)
d140 1
@


1.1
log
@Rather than running status-left, status-right and window title #() with popen
immediately every redraw, queue them up and run them in the background,
starting each once every status-interval. The actual status line uses the
output from the last run.

This brings several advantages:

- tmux itself may be called from inside #() without causing the server to hang;
- likewise, sleep or similar doesn't cause the server to block;
- commands aren't run excessively often when redrawing;
- commands shared by status-left and status-right, or used multiple times, will
  only be run once.

run-shell and if-shell still use system()/popen() but will be changed over to
use this too later.
@
text
@d1 1
a1 1
/* $OpenBSD$ */
d33 3
d73 1
d97 1
d109 1
@

