head	1.16;
access;
symbols
	OPENBSD_6_1:1.16.0.6
	OPENBSD_6_1_BASE:1.16
	OPENBSD_6_0:1.16.0.4
	OPENBSD_6_0_BASE:1.16
	OPENBSD_5_9:1.16.0.2
	OPENBSD_5_9_BASE:1.16
	OPENBSD_5_8:1.14.0.6
	OPENBSD_5_8_BASE:1.14
	OPENBSD_5_7:1.14.0.2
	OPENBSD_5_7_BASE:1.14
	OPENBSD_5_6:1.13.0.4
	OPENBSD_5_6_BASE:1.13
	OPENBSD_5_5:1.12.0.6
	OPENBSD_5_5_BASE:1.12
	OPENBSD_5_4:1.12.0.2
	OPENBSD_5_4_BASE:1.12
	OPENBSD_5_3:1.10.0.4
	OPENBSD_5_3_BASE:1.10
	OPENBSD_5_2:1.10.0.2
	OPENBSD_5_2_BASE:1.10
	OPENBSD_5_1_BASE:1.6
	OPENBSD_5_1:1.6.0.6
	OPENBSD_5_0:1.6.0.4
	OPENBSD_5_0_BASE:1.6
	OPENBSD_4_9:1.6.0.2
	OPENBSD_4_9_BASE:1.6
	OPENBSD_4_8:1.5.0.2
	OPENBSD_4_8_BASE:1.5
	OPENBSD_4_7:1.3.0.2
	OPENBSD_4_7_BASE:1.3
	OPENBSD_4_6:1.1.0.4
	OPENBSD_4_6_BASE:1.1;
locks; strict;
comment	@ * @;


1.16
date	2016.01.19.15.59.12;	author nicm;	state Exp;
branches;
next	1.15;
commitid	P3qmSOx6KrDBsb0c;

1.15
date	2015.11.27.15.06.43;	author nicm;	state Exp;
branches;
next	1.14;
commitid	UkIx5fVf8smc7ree;

1.14
date	2014.09.01.21.50.18;	author nicm;	state Exp;
branches;
next	1.13;
commitid	yvK8NJvd2XzXhKku;

1.13
date	2014.04.11.19.35.54;	author nicm;	state Exp;
branches;
next	1.12;

1.12
date	2013.03.24.09.54.10;	author nicm;	state Exp;
branches;
next	1.11;

1.11
date	2013.03.22.15.49.55;	author nicm;	state Exp;
branches;
next	1.10;

1.10
date	2012.07.13.06.27.41;	author nicm;	state Exp;
branches;
next	1.9;

1.9
date	2012.07.11.07.10.15;	author nicm;	state Exp;
branches;
next	1.8;

1.8
date	2012.07.10.11.53.01;	author nicm;	state Exp;
branches;
next	1.7;

1.7
date	2012.06.18.13.16.42;	author nicm;	state Exp;
branches;
next	1.6;

1.6
date	2010.10.29.20.11.57;	author nicm;	state Exp;
branches;
next	1.5;

1.5
date	2010.06.26.18.20.53;	author nicm;	state Exp;
branches;
next	1.4;

1.4
date	2010.03.22.19.14.55;	author nicm;	state Exp;
branches;
next	1.3;

1.3
date	2010.01.30.19.08.47;	author nicm;	state Exp;
branches;
next	1.2;

1.2
date	2009.07.26.12.58.44;	author nicm;	state Exp;
branches;
next	1.1;

1.1
date	2009.06.01.22.58.49;	author nicm;	state Exp;
branches;
next	;


desc
@@


1.16
log
@I no longer use my SourceForge address so replace it.
@
text
@/* $OpenBSD: cmd-list.c,v 1.15 2015/11/27 15:06:43 nicm Exp $ */

/*
 * Copyright (c) 2009 Nicholas Marriott <nicholas.marriott@@gmail.com>
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF MIND, USE, DATA OR PROFITS, WHETHER
 * IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING
 * OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */

#include <sys/types.h>

#include <stdlib.h>
#include <string.h>

#include "tmux.h"

struct cmd_list *
cmd_list_parse(int argc, char **argv, const char *file, u_int line,
    char **cause)
{
	struct cmd_list	*cmdlist;
	struct cmd	*cmd;
	int		 i, lastsplit;
	size_t		 arglen, new_argc;
	char	       **copy_argv, **new_argv;

	copy_argv = cmd_copy_argv(argc, argv);

	cmdlist = xcalloc(1, sizeof *cmdlist);
	cmdlist->references = 1;
	TAILQ_INIT(&cmdlist->list);

	lastsplit = 0;
	for (i = 0; i < argc; i++) {
		arglen = strlen(copy_argv[i]);
		if (arglen == 0 || copy_argv[i][arglen - 1] != ';')
			continue;
		copy_argv[i][arglen - 1] = '\0';

		if (arglen > 1 && copy_argv[i][arglen - 2] == '\\') {
			copy_argv[i][arglen - 2] = ';';
			continue;
		}

		new_argc = i - lastsplit;
		new_argv = copy_argv + lastsplit;
		if (arglen != 1)
			new_argc++;

		cmd = cmd_parse(new_argc, new_argv, file, line, cause);
		if (cmd == NULL)
			goto bad;
		TAILQ_INSERT_TAIL(&cmdlist->list, cmd, qentry);

		lastsplit = i + 1;
	}

	if (lastsplit != argc) {
		cmd = cmd_parse(argc - lastsplit, copy_argv + lastsplit,
		    file, line, cause);
		if (cmd == NULL)
			goto bad;
		TAILQ_INSERT_TAIL(&cmdlist->list, cmd, qentry);
	}

	cmd_free_argv(argc, copy_argv);
	return (cmdlist);

bad:
	cmd_list_free(cmdlist);
	cmd_free_argv(argc, copy_argv);
	return (NULL);
}

void
cmd_list_free(struct cmd_list *cmdlist)
{
	struct cmd	*cmd, *cmd1;

	if (--cmdlist->references != 0)
		return;

	TAILQ_FOREACH_SAFE(cmd, &cmdlist->list, qentry, cmd1) {
		TAILQ_REMOVE(&cmdlist->list, cmd, qentry);
		args_free(cmd->args);
		free(cmd->file);
		free(cmd);
	}

	free(cmdlist);
}

char *
cmd_list_print(struct cmd_list *cmdlist)
{
	struct cmd	*cmd;
	char		*buf, *this;
	size_t		 len;

	len = 1;
	buf = xcalloc(1, len);

	TAILQ_FOREACH(cmd, &cmdlist->list, qentry) {
		this = cmd_print(cmd);

		len += strlen(this) + 3;
		buf = xrealloc(buf, len);

		strlcat(buf, this, len);
		if (TAILQ_NEXT(cmd, qentry) != NULL)
			strlcat(buf, " ; ", len);

		free(this);
	}

	return (buf);
}
@


1.15
log
@Do not set a limit on the length of commands when printing them.
@
text
@d1 1
a1 1
/* $OpenBSD: cmd-list.c,v 1.14 2014/09/01 21:50:18 nicm Exp $ */
d4 1
a4 1
 * Copyright (c) 2009 Nicholas Marriott <nicm@@users.sourceforge.net>
@


1.14
log
@Various minor style and spacing nits.
@
text
@d1 1
a1 1
/* $OpenBSD: cmd-list.c,v 1.13 2014/04/11 19:35:54 nicm Exp $ */
d102 2
a103 2
size_t
cmd_list_print(struct cmd_list *cmdlist, char *buf, size_t len)
d106 5
a110 1
	size_t		 off, used;
a111 1
	off = 0;
d113 10
a122 11
		if (off >= len)
			break;
		off += cmd_print(cmd, buf + off, len - off);
		if (off >= len)
			break;
		if (TAILQ_NEXT(cmd, qentry) != NULL) {
			used = xsnprintf(buf + off, len - off, " ; ");
			if (used > len - off)
				used = len - off;
			off += used;
		}
d124 2
a125 1
	return (off);
@


1.13
log
@Don't blindly increase offsets by the return value of snprintf, if there
wasn't enough space this will go off the end. Instead clamp to the
available space. Fixes crash reported by Julien Rebetez.
@
text
@d1 1
a1 1
/* $OpenBSD: cmd-list.c,v 1.12 2013/03/24 09:54:10 nicm Exp $ */
d27 1
a27 1
cmd_list_parse(int argc, char **argv, const char* file, u_int line,
@


1.12
log
@Add a command queue to standardize and simplify commands that call other
commands and allow a command to block execution of subsequent
commands. This allows run-shell and if-shell to be synchronous which has
been much requested.

Each client has a default command queue and commands are consumed one at
a time from it. A command may suspend execution from the queue by
returning CMD_RETURN_WAIT and then resume it by calling cmd_continue() -
for example run-shell does this from the callback that is fired after
the job is freed.

When the command queue becomes empty, command clients are automatically
exited (unless attaching). A callback is also fired - this is used for
nested commands in, for example, if-shell which can block execution of
the client's cmdq until a new cmdq becomes empty.

Also merge all the old error/info/print functions together and lose the
old curclient/cmdclient distinction - a cmdq is bound to one client (or
none if in the configuration file), this is a command client if
c->session is NULL otherwise an attached client.
@
text
@d1 1
a1 1
/* $OpenBSD: cmd-list.c,v 1.11 2013/03/22 15:49:55 nicm Exp $ */
d106 1
a106 1
	size_t		 off;
d115 6
a120 2
		if (TAILQ_NEXT(cmd, qentry) != NULL)
			off += xsnprintf(buf + off, len - off, " ; ");
@


1.11
log
@Add functions to allocate and free command contexts rather than doing it
all on the stack.
@
text
@d1 1
a1 1
/* $OpenBSD: cmd-list.c,v 1.10 2012/07/13 06:27:41 nicm Exp $ */
d27 2
a28 1
cmd_list_parse(int argc, char **argv, char **cause)
d38 1
a38 1
	cmdlist = xmalloc(sizeof *cmdlist);
d59 1
a59 1
		cmd = cmd_parse(new_argc, new_argv, cause);
d68 2
a69 1
		cmd = cmd_parse(argc - lastsplit, copy_argv + lastsplit, cause);
a83 56
enum cmd_retval
cmd_list_exec(struct cmd_list *cmdlist, struct cmd_ctx *ctx)
{
	struct client	*c = ctx->curclient;
	struct cmd	*cmd;
	enum cmd_retval	 retval;
	int		 guards, n;

	guards = 0;
	if (c != NULL && c->session != NULL)
		guards = c->flags & CLIENT_CONTROL;

	notify_disable();

	retval = 0;
	TAILQ_FOREACH(cmd, &cmdlist->list, qentry) {
		if (guards)
			ctx->print(ctx, "%%begin");
		n = cmd->entry->exec(cmd, ctx);
		if (guards)
			ctx->print(ctx, "%%end");

		switch (n)
		{
		case CMD_RETURN_ERROR:
			return (CMD_RETURN_ERROR);
		case CMD_RETURN_ATTACH:
			/* Client is being attached (send MSG_READY). */
			retval = CMD_RETURN_ATTACH;

			/*
			 * Mangle the context to treat any following commands
			 * as if they were called from inside.
			 */
			if (ctx->curclient == NULL) {
				ctx->curclient = ctx->cmdclient;
				ctx->cmdclient = NULL;

				ctx->error = key_bindings_error;
				ctx->print = key_bindings_print;
				ctx->info = key_bindings_info;
			}
			break;
		case CMD_RETURN_YIELD:
			if (retval == CMD_RETURN_NORMAL)
				retval = CMD_RETURN_YIELD;
			break;
		case CMD_RETURN_NORMAL:
			break;
		}
	}

	notify_enable();
	return (retval);
}

d87 1
a87 1
	struct cmd	*cmd;
d92 1
a92 2
	while (!TAILQ_EMPTY(&cmdlist->list)) {
		cmd = TAILQ_FIRST(&cmdlist->list);
d95 1
d98 1
@


1.10
log
@Add a queue of notifys and a way to turn them off and on (we do not want
notifys to happen during some commands). Based on code from George
Nachman.
@
text
@d1 1
a1 1
/* $OpenBSD: cmd-list.c,v 1.9 2012/07/11 07:10:15 nicm Exp $ */
d100 1
a100 1
		n = cmd_exec(cmd, ctx);
d149 2
a150 1
		cmd_free(cmd);
@


1.9
log
@Make command exec functions return an enum rather than -1/0/1 values and
add a new value to mean "leave client running but don't attach" to fix
problems with using some commands in a command sequence. Most of the
work by Thomas Adam, problem reported by "jspenguin" on SF bug 3535531.
@
text
@d1 1
a1 1
/* $OpenBSD: cmd-list.c,v 1.8 2012/07/10 11:53:01 nicm Exp $ */
d94 2
d133 2
@


1.8
log
@xfree is not particularly helpful, remove it. From Thomas Adam.
@
text
@d1 1
a1 1
/* $OpenBSD: cmd-list.c,v 1.7 2012/06/18 13:16:42 nicm Exp $ */
d82 1
a82 1
int
d87 2
a88 1
	int		 n, retval, guards;
d102 7
a108 10
		/* Return of -1 is an error. */
		if (n == -1)
			return (-1);

		/*
		 * A 1 return value means the command client is being attached
		 * (sent MSG_READY).
		 */
		if (n == 1) {
			retval = 1;
d111 2
a112 3
			 * The command client has been attached, so mangle the
			 * context to treat any following commands as if they
			 * were called from inside.
d122 7
@


1.7
log
@Add a skeleton mode to tmux (called "control mode") that let's tmux
commands be sent and output received on stdout. This can be used to
integrate with other terminal emulators and should allow some other
things to be made simpler later. More to come so doesn't do much yet and
deliberately not documented.
@
text
@d1 1
a1 1
/* $OpenBSD: cmd-list.c,v 1.6 2010/10/29 20:11:57 nicm Exp $ */
d21 1
d143 1
a143 1
	xfree(cmdlist);
@


1.6
log
@We now send argv to the server after parsing it in the client to get the
command, so the client should not modify it. Instead, take a copy. Fixes
parsing command lists, reported by mcbride@@.
@
text
@d1 1
a1 1
/* $OpenBSD: cmd-list.c,v 1.5 2010/06/26 18:20:53 nicm Exp $ */
d84 1
d86 5
a90 1
	int		 n, retval;
d94 8
a101 1
		if ((n = cmd_exec(cmd, ctx)) == -1)
@


1.5
log
@Setting the cmdlist pointer in the bind-key to NULL to prevent it being freed
after the command is executing is bogus because it may still be needed if the
same command is going to be executed again (for example if you "bind-key a
bind-key b ..."). Making a copy is hard, so instead add a reference count to
the cmd_list.

While here, also print bind-key -n and the rest of the flags properly.

Fixes problem reported by mcbride@@.
@
text
@d1 1
a1 1
/* $OpenBSD: cmd-list.c,v 1.4 2010/03/22 19:14:55 nicm Exp $ */
d32 3
a34 1
	char	       **new_argv;
d42 2
a43 2
		arglen = strlen(argv[i]);
		if (arglen == 0 || argv[i][arglen - 1] != ';')
d45 1
a45 1
		argv[i][arglen - 1] = '\0';
d47 2
a48 2
		if (arglen > 1 && argv[i][arglen - 2] == '\\') {
			argv[i][arglen - 2] = ';';
d53 1
a53 1
		new_argv = argv + lastsplit;
d66 1
a66 1
		cmd = cmd_parse(argc - lastsplit, argv + lastsplit, cause);
d72 1
d77 1
@


1.4
log
@Reset output functions too when changing client after attaching, to
avoid crash if a command in a sequence after new/attach causes output.
@
text
@d1 1
a1 1
/* $OpenBSD$ */
d35 2
a36 1
	TAILQ_INIT(cmdlist);
d58 1
a58 1
		TAILQ_INSERT_TAIL(cmdlist, cmd, qentry);
d67 1
a67 1
		TAILQ_INSERT_TAIL(cmdlist, cmd, qentry);
d84 1
a84 1
	TAILQ_FOREACH(cmd, cmdlist, qentry) {
d118 6
a123 3
	while (!TAILQ_EMPTY(cmdlist)) {
		cmd = TAILQ_FIRST(cmdlist);
		TAILQ_REMOVE(cmdlist, cmd, qentry);
d136 1
a136 1
	TAILQ_FOREACH(cmd, cmdlist, qentry) {
@


1.3
log
@Don't stop parsing command sequences when a command requests the client to
stick around (attach-session/new-session).
@
text
@d1 1
a1 1
/* $OpenBSD: cmd-list.c,v 1.2 2009/07/26 12:58:44 nicm Exp $ */
d102 4
@


1.2
log
@Make all messages sent between the client and server fixed size.

This is the first of two changes to make the protocol more resilient and less
sensitive to other changes in the code, particularly with commands. The client
now packs argv into a buffer and sends it to the server for parsing, rather
than doing it itself and sending the parsed command data.

As a side-effect this also removes a lot of now-unused command marshalling
code.

Mixing a server without this change and a client with or vice versa will cause
tmux to hang or crash, please ensure that tmux is entirely killed before
upgrading.
@
text
@d1 1
a1 1
/* $OpenBSD: cmd-list.c,v 1.1 2009/06/01 22:58:49 nicm Exp $ */
d80 1
a80 1
	int		 n;
d82 1
d84 20
a103 2
		if ((n = cmd_exec(cmd, ctx)) != 0)
			return (n);
d105 1
a105 1
	return (0);
@


1.1
log
@Import tmux, a terminal multiplexor allowing (among other things) a single
terminal to be switched between several different windows and programs
displayed on one terminal be detached from one terminal and moved to another.

ok deraadt pirofti
@
text
@d1 1
a1 1
/* $OpenBSD$ */
a86 35
}

void
cmd_list_send(struct cmd_list *cmdlist, struct buffer *b)
{
	struct cmd	*cmd;
	u_int		 n;

	n = 0;
	TAILQ_FOREACH(cmd, cmdlist, qentry)
	    	n++;

	buffer_write(b, &n, sizeof n);
	TAILQ_FOREACH(cmd, cmdlist, qentry)
	    	cmd_send(cmd, b);
}

struct cmd_list *
cmd_list_recv(struct buffer *b)
{
	struct cmd_list	*cmdlist;
	struct cmd	*cmd;
	u_int		 n;

	buffer_read(b, &n, sizeof n);

	cmdlist = xmalloc(sizeof *cmdlist);
	TAILQ_INIT(cmdlist);

	while (n-- > 0) {
		cmd = cmd_recv(b);
		TAILQ_INSERT_TAIL(cmdlist, cmd, qentry);
	}

	return (cmdlist);
@

