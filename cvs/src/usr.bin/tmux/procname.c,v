head	1.16;
access;
symbols
	OPENBSD_6_1_BASE:1.16
	OPENBSD_6_0:1.15.0.4
	OPENBSD_6_0_BASE:1.15
	OPENBSD_5_9:1.15.0.2
	OPENBSD_5_9_BASE:1.15
	OPENBSD_5_8:1.14.0.6
	OPENBSD_5_8_BASE:1.14
	OPENBSD_5_7:1.14.0.2
	OPENBSD_5_7_BASE:1.14
	OPENBSD_5_6:1.13.0.4
	OPENBSD_5_6_BASE:1.13
	OPENBSD_5_5:1.11.0.4
	OPENBSD_5_5_BASE:1.11
	OPENBSD_5_4:1.10.0.4
	OPENBSD_5_4_BASE:1.10
	OPENBSD_5_3:1.10.0.2
	OPENBSD_5_3_BASE:1.10
	OPENBSD_5_2:1.8.0.4
	OPENBSD_5_2_BASE:1.8
	OPENBSD_5_1_BASE:1.8
	OPENBSD_5_1:1.8.0.2
	OPENBSD_5_0:1.7.0.2
	OPENBSD_5_0_BASE:1.7
	OPENBSD_4_9:1.6.0.6
	OPENBSD_4_9_BASE:1.6
	OPENBSD_4_8:1.6.0.4
	OPENBSD_4_8_BASE:1.6
	OPENBSD_4_7:1.6.0.2
	OPENBSD_4_7_BASE:1.6
	OPENBSD_4_6:1.2.0.4
	OPENBSD_4_6_BASE:1.2;
locks; strict;
comment	@ * @;


1.16
date	2016.10.10.21.29.23;	author nicm;	state Exp;
branches;
next	1.15;
commitid	z4Hr4PZF7Ev93uEJ;

1.15
date	2016.01.19.15.59.12;	author nicm;	state Exp;
branches;
next	1.14;
commitid	P3qmSOx6KrDBsb0c;

1.14
date	2015.01.16.06.40.13;	author deraadt;	state Exp;
branches;
next	1.13;
commitid	Uu5nFG3wCl0LACBb;

1.13
date	2014.07.04.05.58.31;	author guenther;	state Exp;
branches;
next	1.12;
commitid	vhXZZxMGVTWiFaF3;

1.12
date	2014.04.16.23.05.38;	author nicm;	state Exp;
branches;
next	1.11;

1.11
date	2013.10.10.12.39.24;	author nicm;	state Exp;
branches;
next	1.10;

1.10
date	2012.12.18.21.28.45;	author millert;	state Exp;
branches;
next	1.9;

1.9
date	2012.09.24.13.05.10;	author nicm;	state Exp;
branches;
next	1.8;

1.8
date	2011.12.09.16.28.18;	author nicm;	state Exp;
branches;
next	1.7;

1.7
date	2011.04.10.03.20.59;	author guenther;	state Exp;
branches;
next	1.6;

1.6
date	2009.12.24.22.29.15;	author guenther;	state Exp;
branches;
next	1.5;

1.5
date	2009.08.09.15.17.50;	author nicm;	state Exp;
branches;
next	1.4;

1.4
date	2009.08.03.17.12.07;	author nicm;	state Exp;
branches;
next	1.3;

1.3
date	2009.07.26.19.42.26;	author nicm;	state Exp;
branches;
next	1.2;

1.2
date	2009.06.26.10.55.37;	author nicm;	state Exp;
branches;
next	1.1;

1.1
date	2009.06.01.22.58.49;	author nicm;	state Exp;
branches;
next	;


desc
@@


1.16
log
@Loads more static, except for cmd-*.c and window-*.c.
@
text
@/* $OpenBSD: procname.c,v 1.15 2016/01/19 15:59:12 nicm Exp $ */

/*
 * Copyright (c) 2009 Nicholas Marriott <nicholas.marriott@@gmail.com>
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF MIND, USE, DATA OR PROFITS, WHETHER
 * IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING
 * OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */

#include <sys/param.h>	/* MAXCOMLEN */
#include <sys/types.h>
#include <sys/proc.h>
#include <sys/sysctl.h>
#include <sys/stat.h>

#include <errno.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>

#ifndef nitems
#define nitems(_a) (sizeof((_a)) / sizeof((_a)[0]))
#endif

#define is_runnable(p) \
	((p)->p_stat == SRUN || (p)->p_stat == SIDL || (p)->p_stat == SONPROC)
#define is_stopped(p) \
	((p)->p_stat == SSTOP || (p)->p_stat == SDEAD)

static struct kinfo_proc *cmp_procs(struct kinfo_proc *, struct kinfo_proc *);
char	*get_proc_name(int, char *);

static struct kinfo_proc *
cmp_procs(struct kinfo_proc *p1, struct kinfo_proc *p2)
{
	if (is_runnable(p1) && !is_runnable(p2))
		return (p1);
	if (!is_runnable(p1) && is_runnable(p2))
		return (p2);

	if (is_stopped(p1) && !is_stopped(p2))
		return (p1);
	if (!is_stopped(p1) && is_stopped(p2))
		return (p2);

	if (p1->p_estcpu > p2->p_estcpu)
		return (p1);
	if (p1->p_estcpu < p2->p_estcpu)
		return (p2);

	if (p1->p_slptime < p2->p_slptime)
		return (p1);
	if (p1->p_slptime > p2->p_slptime)
		return (p2);

	if ((p1->p_flag & P_SINTR) && !(p2->p_flag & P_SINTR))
		return (p1);
	if (!(p1->p_flag & P_SINTR) && (p2->p_flag & P_SINTR))
		return (p2);

	if (strcmp(p1->p_comm, p2->p_comm) < 0)
		return (p1);
	if (strcmp(p1->p_comm, p2->p_comm) > 0)
		return (p2);

	if (p1->p_pid > p2->p_pid)
		return (p1);
	return (p2);
}

char *
get_proc_name(int fd, char *tty)
{
	int		 mib[6] = { CTL_KERN, KERN_PROC, KERN_PROC_PGRP, 0,
				    sizeof(struct kinfo_proc), 0 };
	struct stat	 sb;
	size_t		 len;
	struct kinfo_proc *buf, *newbuf, *bestp;
	u_int		 i;
	char		*name;

	buf = NULL;

	if (stat(tty, &sb) == -1)
		return (NULL);
	if ((mib[3] = tcgetpgrp(fd)) == -1)
		return (NULL);

retry:
	if (sysctl(mib, nitems(mib), NULL, &len, NULL, 0) == -1)
		goto error;
	len = (len * 5) / 4;

	if ((newbuf = realloc(buf, len)) == NULL)
		goto error;
	buf = newbuf;

	mib[5] = (int)(len / sizeof(struct kinfo_proc));
	if (sysctl(mib, nitems(mib), buf, &len, NULL, 0) == -1) {
		if (errno == ENOMEM)
			goto retry;
		goto error;
	}

	bestp = NULL;
	for (i = 0; i < len / sizeof (struct kinfo_proc); i++) {
		if ((dev_t)buf[i].p_tdev != sb.st_rdev)
			continue;
		if (bestp == NULL)
			bestp = &buf[i];
		else
			bestp = cmp_procs(&buf[i], bestp);
	}

	name = NULL;
	if (bestp != NULL)
		name = strdup(bestp->p_comm);

	free(buf);
	return (name);

error:
	free(buf);
	return (NULL);
}
@


1.15
log
@I no longer use my SourceForge address so replace it.
@
text
@d1 1
a1 1
/* $OpenBSD: procname.c,v 1.14 2015/01/16 06:40:13 deraadt Exp $ */
d39 2
a40 2
struct kinfo_proc	*cmp_procs(struct kinfo_proc *, struct kinfo_proc *);
char			*get_proc_name(int, char *);
d42 1
a42 1
struct kinfo_proc *
@


1.14
log
@Replace <sys/param.h> with <limits.h> and other less dirty headers where
possible.  Annotate <sys/param.h> lines with their current reasons.  Switch
to PATH_MAX, NGROUPS_MAX, HOST_NAME_MAX+1, LOGIN_NAME_MAX, etc.  Change
MIN() and MAX() to local definitions of MINIMUM() and MAXIMUM() where
sensible to avoid pulling in the pollution.  These are the files confirmed
through binary verification.
ok guenther, millert, doug (helped with the verification protocol)
@
text
@d1 1
a1 1
/* $OpenBSD: procname.c,v 1.13 2014/07/04 05:58:31 guenther Exp $ */
d4 1
a4 1
 * Copyright (c) 2009 Nicholas Marriott <nicm@@users.sourceforge.net>
@


1.13
log
@Track whether a process is a zombie or not yet fully built via flags
PS_{ZOMBIE,EMBRYO} on the process instead of peeking into the process's
thread data.  This eliminates the need for the thread-level SDEAD state.

Change kvm_getprocs() (both the sysctl() and kvm backends) to report the
"most active" scheduler state for the process's threads.

tweaks kettenis@@
feedback and ok matthew@@
@
text
@d1 1
a1 1
/* $OpenBSD: procname.c,v 1.12 2014/04/16 23:05:38 nicm Exp $ */
d19 2
a20 1
#include <sys/param.h>
@


1.12
log
@Memory leak in error path and unnecessary assignment, from clang.
@
text
@d1 1
a1 1
/* $OpenBSD: procname.c,v 1.11 2013/10/10 12:39:24 nicm Exp $ */
d36 1
a36 1
	((p)->p_stat == SSTOP || (p)->p_stat == SZOMB || (p)->p_stat == SDEAD)
@


1.11
log
@Remove the KERN_PROC_CWD the proc_current_path format (which is the only
thing that uses it now).
@
text
@d1 1
a1 1
/* $OpenBSD: procname.c,v 1.10 2012/12/18 21:28:45 millert Exp $ */
d99 1
a99 1
		return (NULL);
@


1.10
log
@We no longer use struct eproc for kinfo_proc in sysctl.h so there
is no direct need for sys/proc.h or sys/resource.h.  Some consumers
of kinfo_proc need these for the proc flags and rlimit defines like
RLIM_INF so add the appropriate includes to them.
OK deraadt@@ sthen@@
@
text
@d1 1
a1 1
/* $OpenBSD: procname.c,v 1.9 2012/09/24 13:05:10 nicm Exp $ */
a39 1
char			*get_proc_cwd(int);
a132 14
}

char*
get_proc_cwd(int fd)
{
	int		name[] = { CTL_KERN, KERN_PROC_CWD, 0 };
	static char	path[MAXPATHLEN];
	size_t		pathlen = sizeof path;

	if ((name[2] = tcgetpgrp(fd)) == -1)
		return (NULL);
	if (sysctl(name, 3, path, &pathlen, NULL, 0) != 0)
		return (NULL);
	return (path);
@


1.9
log
@Use pgrp of pty fd not pid of immediate child when recovering current
working directory (like current process). From Marcel Partap.
@
text
@d1 1
a1 1
/* $OpenBSD: procname.c,v 1.8 2011/12/09 16:28:18 nicm Exp $ */
d20 1
@


1.8
log
@Change the way the working directory for new processes is discovered. If
default-path isn't empty, it is used. Otherwise:

1) If tmux neww is run from the command line, the working directory of the
   client is used.

2) Otherwise sysctl KERN_PROC_CWD is used to retrieve the current
   working directory of the process in the active pane.

3) If that fails, the directory where the session was created is used.

Support code by Romain Francois, OpenBSD specific bits by me.

Note this requires a recent userland and kernel with KERN_PROC_CWD.
@
text
@d1 1
a1 1
/* $OpenBSD: procname.c,v 1.7 2011/04/10 03:20:59 guenther Exp $ */
d39 1
a39 1
char			*get_proc_cwd(pid_t);
d136 1
a136 1
get_proc_cwd(pid_t pid)
d138 1
a138 1
	int		name[] = { CTL_KERN, KERN_PROC_CWD, (int)pid };
d142 2
@


1.7
log
@Switch back from KERN_PROC2/kinfo_proc2 to KERN_PROC/kinfo_proc now
that we've got name we want for the API we want

"ZAP!" deraadt@@
@
text
@d1 1
a1 1
/* $OpenBSD: procname.c,v 1.6 2009/12/24 22:29:15 guenther Exp $ */
d38 2
a39 1
char		*get_proc_name(int, char *);
d133 12
@


1.6
log
@Use sysctl() KERN_PROC2 instead of KERN_PROC, as the latter's ABI
is sensitive to changes in struct proc.

fixes for warnings and ok nicm@@
@
text
@d1 1
a1 1
/* $OpenBSD: procname.c,v 1.5 2009/08/09 15:17:50 nicm Exp $ */
d37 1
a37 1
struct kinfo_proc2	*cmp_procs(struct kinfo_proc2 *, struct kinfo_proc2 *);
d40 2
a41 2
struct kinfo_proc2 *
cmp_procs(struct kinfo_proc2 *p1, struct kinfo_proc2 *p2)
d81 2
a82 2
	int		 mib[6] = { CTL_KERN, KERN_PROC2, KERN_PROC_PGRP, 0,
				    sizeof(struct kinfo_proc2), 0 };
d85 1
a85 1
	struct kinfo_proc2 *buf, *newbuf, *bestp;
d105 1
a105 1
	mib[5] = (int)(len / sizeof(struct kinfo_proc2));
d113 1
a113 1
	for (i = 0; i < len / sizeof (struct kinfo_proc2); i++) {
@


1.5
log
@Nuke a dead variable found with clang and an unused declaration with lint.
@
text
@d1 1
a1 1
/* $OpenBSD: procname.c,v 1.4 2009/08/03 17:12:07 nicm Exp $ */
d37 1
a37 1
struct proc	*cmp_procs(struct proc *, struct proc *);
d40 2
a41 2
struct proc *
cmp_procs(struct proc *p1, struct proc *p2)
a42 2
	void	*ptr1, *ptr2;

a67 7
	ptr1 = LIST_FIRST(&p1->p_children);
	ptr2 = LIST_FIRST(&p2->p_children);
	if (ptr1 == NULL && ptr2 != NULL)
		return (p1);
	if (ptr1 != NULL && ptr2 == NULL)
		return (p2);

d81 2
a82 1
	int		 mib[4] = { CTL_KERN, KERN_PROC, KERN_PROC_PGRP, 0 };
d85 1
a85 2
	struct kinfo_proc *buf, *newbuf;
	struct proc	*bestp;
d105 1
d113 2
a114 2
	for (i = 0; i < len / sizeof (struct kinfo_proc); i++) {
		if (buf[i].kp_eproc.e_tdev != sb.st_rdev)
d117 1
a117 1
			bestp = &buf[i].kp_proc;
d119 1
a119 1
			bestp = cmp_procs(&buf[i].kp_proc, bestp);
@


1.4
log
@Split the comparison into a function to make this code smaller and more
understandable.
@
text
@d1 1
a1 1
/* $OpenBSD: procname.c,v 1.3 2009/07/26 19:42:26 nicm Exp $ */
d94 1
a94 1
	struct proc	*p, *bestp;
a123 1
		p = &buf[i].kp_proc;
@


1.3
log
@Go to the next if the current best process is replaced, don't keep comparing it
with itself. Also fix process name comparison.
@
text
@d1 1
a1 1
/* $OpenBSD: procname.c,v 1.2 2009/06/26 10:55:37 nicm Exp $ */
d37 49
a85 1
char	*get_proc_name(int, char *);
d110 2
a111 4
	if ((newbuf = realloc(buf, len)) == NULL) {
		free(buf);
		return (NULL);
	}
d117 1
a117 2
		free(buf);
		return (NULL);
d125 4
a128 51
		if (bestp == NULL) {
			bestp = p;
			continue;
		}

		if (is_runnable(p) && !is_runnable(bestp)) {
			bestp = p;
			continue;
		} else if (!is_runnable(p) && is_runnable(bestp))
			continue;

		if (!is_stopped(p) && is_stopped(bestp)) {
			bestp = p;
			continue;
		} else if (is_stopped(p) && !is_stopped(bestp))
			continue;

		if (p->p_estcpu > bestp->p_estcpu) {
			bestp = p;
			continue;
		} else if (p->p_estcpu < bestp->p_estcpu)
			continue;

		if (p->p_slptime < bestp->p_slptime) {
			bestp = p;
			continue;
		} else if (p->p_slptime > bestp->p_slptime)
			continue;

		if (p->p_flag & P_SINTR && !(bestp->p_flag & P_SINTR)) {
			bestp = p;
			continue;
		} else if (!(p->p_flag & P_SINTR) && bestp->p_flag & P_SINTR)
			continue;

		if (LIST_FIRST(&p->p_children) == NULL &&
		    LIST_FIRST(&bestp->p_children) != NULL) { /* XXX ugh */
			bestp = p;
			continue;
		} else if (LIST_FIRST(&p->p_children) != NULL &&
		    LIST_FIRST(&bestp->p_children) == NULL)
			continue;

		if (strcmp(p->p_comm, bestp->p_comm) < 0) {
			bestp = p;
			continue;
		} else if (strcmp(p->p_comm, bestp->p_comm) > 0)
			continue;

		if (p->p_pid > bestp->p_pid)
			bestp = p;
d137 4
@


1.2
log
@Also #ifndef nitems here, caught by Thomas Jeunet.
@
text
@d1 1
a1 1
/* $OpenBSD: procname.c,v 1.1 2009/06/01 22:58:49 nicm Exp $ */
d85 1
a85 1
		if (is_runnable(p) && !is_runnable(bestp))
d87 2
a88 1
		else if (!is_runnable(p) && is_runnable(bestp))
d91 1
a91 1
		if (!is_stopped(p) && is_stopped(bestp))
d93 2
a94 1
		else if (is_stopped(p) && !is_stopped(bestp))
d97 1
a97 1
		if (p->p_estcpu > bestp->p_estcpu)
d99 2
a100 1
		else if (p->p_estcpu < bestp->p_estcpu)
d103 1
a103 1
		if (p->p_slptime < bestp->p_slptime)
d105 2
a106 1
		else if (p->p_slptime > bestp->p_slptime)
d109 1
a109 1
		if (p->p_flag & P_SINTR && !(bestp->p_flag & P_SINTR))
d111 2
a112 1
		else if (!(p->p_flag & P_SINTR) && bestp->p_flag & P_SINTR)
d116 1
a116 1
		    LIST_FIRST(&bestp->p_children) != NULL) /* XXX ugh */
d118 2
a119 1
		else if (LIST_FIRST(&p->p_children) != NULL &&
d123 1
a123 1
		if (strcmp(p->p_comm, p->p_comm) < 0)
d125 2
a126 1
		else if (strcmp(p->p_comm, p->p_comm) > 0)
@


1.1
log
@Import tmux, a terminal multiplexor allowing (among other things) a single
terminal to be switched between several different windows and programs
displayed on one terminal be detached from one terminal and moved to another.

ok deraadt pirofti
@
text
@d1 1
a1 1
/* $OpenBSD$ */
d28 1
d30 1
@

