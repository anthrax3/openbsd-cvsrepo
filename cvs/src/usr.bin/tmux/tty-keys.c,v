head	1.98;
access;
symbols
	OPENBSD_6_1:1.93.0.4
	OPENBSD_6_1_BASE:1.93
	OPENBSD_6_0:1.89.0.2
	OPENBSD_6_0_BASE:1.89
	OPENBSD_5_9:1.84.0.2
	OPENBSD_5_9_BASE:1.84
	OPENBSD_5_8:1.73.0.4
	OPENBSD_5_8_BASE:1.73
	OPENBSD_5_7:1.71.0.2
	OPENBSD_5_7_BASE:1.71
	OPENBSD_5_6:1.70.0.4
	OPENBSD_5_6_BASE:1.70
	OPENBSD_5_5:1.62.0.4
	OPENBSD_5_5_BASE:1.62
	OPENBSD_5_4:1.59.0.2
	OPENBSD_5_4_BASE:1.59
	OPENBSD_5_3:1.47.0.2
	OPENBSD_5_3_BASE:1.47
	OPENBSD_5_2:1.42.0.2
	OPENBSD_5_2_BASE:1.42
	OPENBSD_5_1_BASE:1.34
	OPENBSD_5_1:1.34.0.4
	OPENBSD_5_0:1.34.0.2
	OPENBSD_5_0_BASE:1.34
	OPENBSD_4_9:1.33.0.2
	OPENBSD_4_9_BASE:1.33
	OPENBSD_4_8:1.31.0.2
	OPENBSD_4_8_BASE:1.31
	OPENBSD_4_7:1.29.0.2
	OPENBSD_4_7_BASE:1.29
	OPENBSD_4_6:1.1.0.4
	OPENBSD_4_6_BASE:1.1;
locks; strict;
comment	@ * @;


1.98
date	2017.06.12.07.04.24;	author nicm;	state Exp;
branches;
next	1.97;
commitid	fu4NxKu1IK7xAqw9;

1.97
date	2017.05.07.21.25.59;	author nicm;	state Exp;
branches;
next	1.96;
commitid	JPrRNhEycziODctd;

1.96
date	2017.04.18.21.41.42;	author nicm;	state Exp;
branches;
next	1.95;
commitid	olMj0aSNSMEU2X3g;

1.95
date	2017.04.18.18.21.37;	author nicm;	state Exp;
branches;
next	1.94;
commitid	puXYAvHBv1XeJmEe;

1.94
date	2017.04.18.13.34.04;	author nicm;	state Exp;
branches;
next	1.93;
commitid	m7CbSXC9pE0gjYDg;

1.93
date	2017.02.10.12.59.18;	author nicm;	state Exp;
branches;
next	1.92;
commitid	P7xSjiy29fJgUATs;

1.92
date	2017.01.11.16.05.46;	author nicm;	state Exp;
branches;
next	1.91;
commitid	vc1OjSamlGf0LeFN;

1.91
date	2016.11.15.14.02.32;	author nicm;	state Exp;
branches;
next	1.90;
commitid	DoED1csxpiOGsoJM;

1.90
date	2016.10.10.21.29.23;	author nicm;	state Exp;
branches;
next	1.89;
commitid	z4Hr4PZF7Ev93uEJ;

1.89
date	2016.04.29.10.42.16;	author nicm;	state Exp;
branches;
next	1.88;
commitid	YW31VmzlpdoLpQUa;

1.88
date	2016.04.27.16.46.21;	author nicm;	state Exp;
branches;
next	1.87;
commitid	2Kp3EVbskEnC8X8U;

1.87
date	2016.04.27.16.40.12;	author nicm;	state Exp;
branches;
next	1.86;
commitid	fuZGBaY2g8O3KTQ6;

1.86
date	2016.04.26.22.19.22;	author nicm;	state Exp;
branches;
next	1.85;
commitid	62nr89NQlhi4ONNV;

1.85
date	2016.03.02.15.36.03;	author nicm;	state Exp;
branches;
next	1.84;
commitid	NiBVKnSIZN4ztNWB;

1.84
date	2016.01.19.15.59.12;	author nicm;	state Exp;
branches;
next	1.83;
commitid	P3qmSOx6KrDBsb0c;

1.83
date	2015.12.12.18.19.00;	author nicm;	state Exp;
branches;
next	1.82;
commitid	WD2k8ZkBSmp0TV5S;

1.82
date	2015.11.23.20.53.09;	author nicm;	state Exp;
branches;
next	1.81;
commitid	erDJx2JIDZWB55Vj;

1.81
date	2015.11.18.14.27.44;	author nicm;	state Exp;
branches;
next	1.80;
commitid	RjsAPRkWwvS79w40;

1.80
date	2015.11.14.11.45.43;	author nicm;	state Exp;
branches;
next	1.79;
commitid	gUJFVlXRAaRAnDSU;

1.79
date	2015.11.14.10.57.59;	author nicm;	state Exp;
branches;
next	1.78;
commitid	QXPiEzv5yKH3fVUx;

1.78
date	2015.11.14.10.56.31;	author nicm;	state Exp;
branches;
next	1.77;
commitid	7oTEXFUYU5F7v5X1;

1.77
date	2015.11.12.22.04.37;	author nicm;	state Exp;
branches;
next	1.76;
commitid	fGCLUB4poNC6IhUT;

1.76
date	2015.11.12.11.05.34;	author nicm;	state Exp;
branches;
next	1.75;
commitid	Ih1tdqtjpnEyfE8x;

1.75
date	2015.10.27.15.58.43;	author nicm;	state Exp;
branches;
next	1.74;
commitid	89xhQafU35Q5MQVC;

1.74
date	2015.09.02.17.37.54;	author nicm;	state Exp;
branches;
next	1.73;
commitid	DPDGYd3xfOPOySvU;

1.73
date	2015.06.05.15.10.13;	author nicm;	state Exp;
branches;
next	1.72;
commitid	NbuvQjAZUf4Z2VGU;

1.72
date	2015.04.19.21.34.21;	author nicm;	state Exp;
branches;
next	1.71;
commitid	wug6ctIOfhVMeWQp;

1.71
date	2014.10.22.23.18.53;	author nicm;	state Exp;
branches;
next	1.70;
commitid	eFDptKeckheZa4ap;

1.70
date	2014.07.21.10.25.48;	author nicm;	state Exp;
branches;
next	1.69;
commitid	uQXf8Vu4TQgRm6UX;

1.69
date	2014.06.23.09.52.56;	author nicm;	state Exp;
branches;
next	1.68;
commitid	17kGQFj6GQsdf6gX;

1.68
date	2014.06.19.07.32.12;	author nicm;	state Exp;
branches;
next	1.67;
commitid	k0oq49EQ33JDSQJr;

1.67
date	2014.06.19.07.26.43;	author nicm;	state Exp;
branches;
next	1.66;
commitid	fBvz2uGg2ZeS07lJ;

1.66
date	2014.05.08.07.54.47;	author nicm;	state Exp;
branches;
next	1.65;

1.65
date	2014.04.03.08.20.29;	author nicm;	state Exp;
branches;
next	1.64;

1.64
date	2014.04.03.08.15.17;	author nicm;	state Exp;
branches;
next	1.63;

1.63
date	2014.03.31.21.40.21;	author nicm;	state Exp;
branches;
next	1.62;

1.62
date	2014.02.10.11.20.41;	author nicm;	state Exp;
branches;
next	1.61;

1.61
date	2013.10.10.11.57.52;	author nicm;	state Exp;
branches;
next	1.60;

1.60
date	2013.10.10.11.49.42;	author nicm;	state Exp;
branches;
next	1.59;

1.59
date	2013.03.26.14.14.08;	author nicm;	state Exp;
branches;
next	1.58;

1.58
date	2013.03.25.11.44.16;	author nicm;	state Exp;
branches;
next	1.57;

1.57
date	2013.03.25.11.36.25;	author nicm;	state Exp;
branches;
next	1.56;

1.56
date	2013.03.24.09.28.59;	author nicm;	state Exp;
branches;
next	1.55;

1.55
date	2013.03.22.10.33.50;	author nicm;	state Exp;
branches;
next	1.54;

1.54
date	2013.03.22.10.31.22;	author nicm;	state Exp;
branches;
next	1.53;

1.53
date	2013.03.22.10.30.34;	author nicm;	state Exp;
branches;
next	1.52;

1.52
date	2013.03.21.18.45.38;	author nicm;	state Exp;
branches;
next	1.51;

1.51
date	2013.03.21.18.44.47;	author nicm;	state Exp;
branches;
next	1.50;

1.50
date	2013.03.21.16.52.02;	author nicm;	state Exp;
branches;
next	1.49;

1.49
date	2013.03.21.16.51.11;	author nicm;	state Exp;
branches;
next	1.48;

1.48
date	2013.03.21.16.50.22;	author nicm;	state Exp;
branches;
next	1.47;

1.47
date	2012.11.22.14.41.11;	author nicm;	state Exp;
branches;
next	1.46;

1.46
date	2012.11.22.14.26.04;	author nicm;	state Exp;
branches;
next	1.45;

1.45
date	2012.10.26.14.35.42;	author nicm;	state Exp;
branches;
next	1.44;

1.44
date	2012.09.03.06.26.48;	author nicm;	state Exp;
branches;
next	1.43;

1.43
date	2012.08.21.10.08.11;	author nicm;	state Exp;
branches;
next	1.42;

1.42
date	2012.07.10.11.53.01;	author nicm;	state Exp;
branches;
next	1.41;

1.41
date	2012.05.22.14.32.28;	author nicm;	state Exp;
branches;
next	1.40;

1.40
date	2012.05.22.14.11.30;	author nicm;	state Exp;
branches;
next	1.39;

1.39
date	2012.04.22.05.21.40;	author nicm;	state Exp;
branches;
next	1.38;

1.38
date	2012.03.21.21.28.03;	author nicm;	state Exp;
branches;
next	1.37;

1.37
date	2012.03.17.22.56.04;	author nicm;	state Exp;
branches;
next	1.36;

1.36
date	2012.03.17.18.24.07;	author nicm;	state Exp;
branches;
next	1.35;

1.35
date	2012.03.15.10.36.00;	author nicm;	state Exp;
branches;
next	1.34;

1.34
date	2011.03.04.23.26.44;	author nicm;	state Exp;
branches;
next	1.33;

1.33
date	2011.01.03.23.35.22;	author nicm;	state Exp;
branches;
next	1.32;

1.32
date	2011.01.01.02.16.25;	author nicm;	state Exp;
branches;
next	1.31;

1.31
date	2010.05.31.19.51.29;	author nicm;	state Exp;
branches;
next	1.30;

1.30
date	2010.03.22.19.03.52;	author nicm;	state Exp;
branches;
next	1.29;

1.29
date	2009.12.17.17.39.56;	author nicm;	state Exp;
branches;
next	1.28;

1.28
date	2009.12.14.10.43.41;	author nicm;	state Exp;
branches;
next	1.27;

1.27
date	2009.12.03.22.50.10;	author nicm;	state Exp;
branches;
next	1.26;

1.26
date	2009.12.01.07.59.40;	author nicm;	state Exp;
branches;
next	1.25;

1.25
date	2009.11.30.16.44.03;	author nicm;	state Exp;
branches;
next	1.24;

1.24
date	2009.11.26.22.26.51;	author nicm;	state Exp;
branches;
next	1.23;

1.23
date	2009.11.26.21.37.13;	author nicm;	state Exp;
branches;
next	1.22;

1.22
date	2009.11.26.15.14.03;	author nicm;	state Exp;
branches;
next	1.21;

1.21
date	2009.11.12.08.01.02;	author nicm;	state Exp;
branches;
next	1.20;

1.20
date	2009.11.10.17.59.34;	author nicm;	state Exp;
branches;
next	1.19;

1.19
date	2009.11.09.14.40.06;	author nicm;	state Exp;
branches;
next	1.18;

1.18
date	2009.11.09.11.45.10;	author nicm;	state Exp;
branches;
next	1.17;

1.17
date	2009.11.05.19.32.34;	author nicm;	state Exp;
branches;
next	1.16;

1.16
date	2009.11.05.19.29.41;	author nicm;	state Exp;
branches;
next	1.15;

1.15
date	2009.11.05.10.44.36;	author nicm;	state Exp;
branches;
next	1.14;

1.14
date	2009.11.05.08.45.08;	author nicm;	state Exp;
branches;
next	1.13;

1.13
date	2009.11.04.21.47.42;	author nicm;	state Exp;
branches;
next	1.12;

1.12
date	2009.10.26.17.59.46;	author nicm;	state Exp;
branches;
next	1.11;

1.11
date	2009.10.26.17.46.33;	author nicm;	state Exp;
branches;
next	1.10;

1.10
date	2009.10.26.16.00.51;	author nicm;	state Exp;
branches;
next	1.9;

1.9
date	2009.10.26.13.58.02;	author nicm;	state Exp;
branches;
next	1.8;

1.8
date	2009.10.26.13.41.46;	author nicm;	state Exp;
branches;
next	1.7;

1.7
date	2009.10.26.13.13.33;	author nicm;	state Exp;
branches;
next	1.6;

1.6
date	2009.10.26.13.02.53;	author nicm;	state Exp;
branches;
next	1.5;

1.5
date	2009.10.11.07.01.10;	author nicm;	state Exp;
branches;
next	1.4;

1.4
date	2009.09.20.14.58.12;	author nicm;	state Exp;
branches;
next	1.3;

1.3
date	2009.07.26.21.42.08;	author nicm;	state Exp;
branches;
next	1.2;

1.2
date	2009.07.21.17.57.29;	author nicm;	state Exp;
branches;
next	1.1;

1.1
date	2009.06.01.22.58.49;	author nicm;	state Exp;
branches;
next	;


desc
@@


1.98
log
@Add explicit keys for the bracketed paste sequences, both to avoid mix
ups with other keys and to make logs clearer.
@
text
@/* $OpenBSD: tty-keys.c,v 1.97 2017/05/07 21:25:59 nicm Exp $ */

/*
 * Copyright (c) 2007 Nicholas Marriott <nicholas.marriott@@gmail.com>
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF MIND, USE, DATA OR PROFITS, WHETHER
 * IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING
 * OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */

#include <sys/types.h>
#include <sys/time.h>

#include <limits.h>
#include <stdlib.h>
#include <string.h>
#include <termios.h>
#include <unistd.h>

#include "tmux.h"

/*
 * Handle keys input from the outside terminal. tty_default_*_keys[] are a base
 * table of supported keys which are looked up in terminfo(5) and translated
 * into a ternary tree.
 */

static void	tty_keys_add1(struct tty_key **, const char *, key_code);
static void	tty_keys_add(struct tty *, const char *, key_code);
static void	tty_keys_free1(struct tty_key *);
static struct tty_key *tty_keys_find1(struct tty_key *, const char *, size_t,
		    size_t *);
static struct tty_key *tty_keys_find(struct tty *, const char *, size_t,
		    size_t *);
static int	tty_keys_next1(struct tty *, const char *, size_t, key_code *,
		    size_t *, int);
static void	tty_keys_callback(int, short, void *);
static int	tty_keys_mouse(struct tty *, const char *, size_t, size_t *);
static int	tty_keys_device_attributes(struct tty *, const char *, size_t,
		    size_t *);

/* Default raw keys. */
struct tty_default_key_raw {
	const char	       *string;
	key_code	 	key;
};
static const struct tty_default_key_raw tty_default_raw_keys[] = {
	/*
	 * Numeric keypad. Just use the vt100 escape sequences here and always
	 * put the terminal into keypad_xmit mode. Translation of numbers
	 * mode/applications mode is done in input-keys.c.
	 */
	{ "\033Oo", KEYC_KP_SLASH },
	{ "\033Oj", KEYC_KP_STAR },
	{ "\033Om", KEYC_KP_MINUS },
	{ "\033Ow", KEYC_KP_SEVEN },
	{ "\033Ox", KEYC_KP_EIGHT },
	{ "\033Oy", KEYC_KP_NINE },
	{ "\033Ok", KEYC_KP_PLUS },
	{ "\033Ot", KEYC_KP_FOUR },
	{ "\033Ou", KEYC_KP_FIVE },
	{ "\033Ov", KEYC_KP_SIX },
	{ "\033Oq", KEYC_KP_ONE },
	{ "\033Or", KEYC_KP_TWO },
	{ "\033Os", KEYC_KP_THREE },
	{ "\033OM", KEYC_KP_ENTER },
	{ "\033Op", KEYC_KP_ZERO },
	{ "\033On", KEYC_KP_PERIOD },

	/* Arrow keys. */
	{ "\033OA", KEYC_UP },
	{ "\033OB", KEYC_DOWN },
	{ "\033OC", KEYC_RIGHT },
	{ "\033OD", KEYC_LEFT },

	{ "\033[A", KEYC_UP },
	{ "\033[B", KEYC_DOWN },
	{ "\033[C", KEYC_RIGHT },
	{ "\033[D", KEYC_LEFT },

	/* Other (xterm) "cursor" keys. */
	{ "\033OH", KEYC_HOME },
	{ "\033OF", KEYC_END },

	{ "\033[H", KEYC_HOME },
	{ "\033[F", KEYC_END },

	/* rxvt-style arrow + modifier keys. */
	{ "\033Oa", KEYC_UP|KEYC_CTRL },
	{ "\033Ob", KEYC_DOWN|KEYC_CTRL },
	{ "\033Oc", KEYC_RIGHT|KEYC_CTRL },
	{ "\033Od", KEYC_LEFT|KEYC_CTRL },

	{ "\033[a", KEYC_UP|KEYC_SHIFT },
	{ "\033[b", KEYC_DOWN|KEYC_SHIFT },
	{ "\033[c", KEYC_RIGHT|KEYC_SHIFT },
	{ "\033[d", KEYC_LEFT|KEYC_SHIFT },

	/* rxvt-style function + modifier keys (C = ^, S = $, C-S = @@). */
	{ "\033[11^", KEYC_F1|KEYC_CTRL },
	{ "\033[12^", KEYC_F2|KEYC_CTRL },
	{ "\033[13^", KEYC_F3|KEYC_CTRL },
	{ "\033[14^", KEYC_F4|KEYC_CTRL },
	{ "\033[15^", KEYC_F5|KEYC_CTRL },
	{ "\033[17^", KEYC_F6|KEYC_CTRL },
	{ "\033[18^", KEYC_F7|KEYC_CTRL },
	{ "\033[19^", KEYC_F8|KEYC_CTRL },
	{ "\033[20^", KEYC_F9|KEYC_CTRL },
	{ "\033[21^", KEYC_F10|KEYC_CTRL },
	{ "\033[23^", KEYC_F11|KEYC_CTRL },
	{ "\033[24^", KEYC_F12|KEYC_CTRL },
	{ "\033[2^", KEYC_IC|KEYC_CTRL },
	{ "\033[3^", KEYC_DC|KEYC_CTRL },
	{ "\033[7^", KEYC_HOME|KEYC_CTRL },
	{ "\033[8^", KEYC_END|KEYC_CTRL },
	{ "\033[6^", KEYC_NPAGE|KEYC_CTRL },
	{ "\033[5^", KEYC_PPAGE|KEYC_CTRL },

	{ "\033[11$", KEYC_F1|KEYC_SHIFT },
	{ "\033[12$", KEYC_F2|KEYC_SHIFT },
	{ "\033[13$", KEYC_F3|KEYC_SHIFT },
	{ "\033[14$", KEYC_F4|KEYC_SHIFT },
	{ "\033[15$", KEYC_F5|KEYC_SHIFT },
	{ "\033[17$", KEYC_F6|KEYC_SHIFT },
	{ "\033[18$", KEYC_F7|KEYC_SHIFT },
	{ "\033[19$", KEYC_F8|KEYC_SHIFT },
	{ "\033[20$", KEYC_F9|KEYC_SHIFT },
	{ "\033[21$", KEYC_F10|KEYC_SHIFT },
	{ "\033[23$", KEYC_F11|KEYC_SHIFT },
	{ "\033[24$", KEYC_F12|KEYC_SHIFT },
	{ "\033[2$", KEYC_IC|KEYC_SHIFT },
	{ "\033[3$", KEYC_DC|KEYC_SHIFT },
	{ "\033[7$", KEYC_HOME|KEYC_SHIFT },
	{ "\033[8$", KEYC_END|KEYC_SHIFT },
	{ "\033[6$", KEYC_NPAGE|KEYC_SHIFT },
	{ "\033[5$", KEYC_PPAGE|KEYC_SHIFT },

	{ "\033[11@@", KEYC_F1|KEYC_CTRL|KEYC_SHIFT },
	{ "\033[12@@", KEYC_F2|KEYC_CTRL|KEYC_SHIFT },
	{ "\033[13@@", KEYC_F3|KEYC_CTRL|KEYC_SHIFT },
	{ "\033[14@@", KEYC_F4|KEYC_CTRL|KEYC_SHIFT },
	{ "\033[15@@", KEYC_F5|KEYC_CTRL|KEYC_SHIFT },
	{ "\033[17@@", KEYC_F6|KEYC_CTRL|KEYC_SHIFT },
	{ "\033[18@@", KEYC_F7|KEYC_CTRL|KEYC_SHIFT },
	{ "\033[19@@", KEYC_F8|KEYC_CTRL|KEYC_SHIFT },
	{ "\033[20@@", KEYC_F9|KEYC_CTRL|KEYC_SHIFT },
	{ "\033[21@@", KEYC_F10|KEYC_CTRL|KEYC_SHIFT },
	{ "\033[23@@", KEYC_F11|KEYC_CTRL|KEYC_SHIFT },
	{ "\033[24@@", KEYC_F12|KEYC_CTRL|KEYC_SHIFT },
	{ "\033[2@@", KEYC_IC|KEYC_CTRL|KEYC_SHIFT },
	{ "\033[3@@", KEYC_DC|KEYC_CTRL|KEYC_SHIFT },
	{ "\033[7@@", KEYC_HOME|KEYC_CTRL|KEYC_SHIFT },
	{ "\033[8@@", KEYC_END|KEYC_CTRL|KEYC_SHIFT },
	{ "\033[6@@", KEYC_NPAGE|KEYC_CTRL|KEYC_SHIFT },
	{ "\033[5@@", KEYC_PPAGE|KEYC_CTRL|KEYC_SHIFT },

	/* Focus tracking. */
	{ "\033[I", KEYC_FOCUS_IN },
	{ "\033[O", KEYC_FOCUS_OUT },

	/* Paste keys. */
	{ "\033[200~", KEYC_PASTE_START },
	{ "\033[201~", KEYC_PASTE_END },
};

/* Default terminfo(5) keys. */
struct tty_default_key_code {
	enum tty_code_code	code;
	key_code	 	key;
};
static const struct tty_default_key_code tty_default_code_keys[] = {
	/* Function keys. */
	{ TTYC_KF1, KEYC_F1 },
	{ TTYC_KF2, KEYC_F2 },
	{ TTYC_KF3, KEYC_F3 },
	{ TTYC_KF4, KEYC_F4 },
	{ TTYC_KF5, KEYC_F5 },
	{ TTYC_KF6, KEYC_F6 },
	{ TTYC_KF7, KEYC_F7 },
	{ TTYC_KF8, KEYC_F8 },
	{ TTYC_KF9, KEYC_F9 },
	{ TTYC_KF10, KEYC_F10 },
	{ TTYC_KF11, KEYC_F11 },
	{ TTYC_KF12, KEYC_F12 },

	{ TTYC_KF13, KEYC_F1|KEYC_SHIFT },
	{ TTYC_KF14, KEYC_F2|KEYC_SHIFT },
	{ TTYC_KF15, KEYC_F3|KEYC_SHIFT },
	{ TTYC_KF16, KEYC_F4|KEYC_SHIFT },
	{ TTYC_KF17, KEYC_F5|KEYC_SHIFT },
	{ TTYC_KF18, KEYC_F6|KEYC_SHIFT },
	{ TTYC_KF19, KEYC_F7|KEYC_SHIFT },
	{ TTYC_KF20, KEYC_F8|KEYC_SHIFT },
	{ TTYC_KF21, KEYC_F9|KEYC_SHIFT },
	{ TTYC_KF22, KEYC_F10|KEYC_SHIFT },
	{ TTYC_KF23, KEYC_F11|KEYC_SHIFT },
	{ TTYC_KF24, KEYC_F12|KEYC_SHIFT },

	{ TTYC_KF25, KEYC_F1|KEYC_CTRL },
	{ TTYC_KF26, KEYC_F2|KEYC_CTRL },
	{ TTYC_KF27, KEYC_F3|KEYC_CTRL },
	{ TTYC_KF28, KEYC_F4|KEYC_CTRL },
	{ TTYC_KF29, KEYC_F5|KEYC_CTRL },
	{ TTYC_KF30, KEYC_F6|KEYC_CTRL },
	{ TTYC_KF31, KEYC_F7|KEYC_CTRL },
	{ TTYC_KF32, KEYC_F8|KEYC_CTRL },
	{ TTYC_KF33, KEYC_F9|KEYC_CTRL },
	{ TTYC_KF34, KEYC_F10|KEYC_CTRL },
	{ TTYC_KF35, KEYC_F11|KEYC_CTRL },
	{ TTYC_KF36, KEYC_F12|KEYC_CTRL },

	{ TTYC_KF37, KEYC_F1|KEYC_SHIFT|KEYC_CTRL },
	{ TTYC_KF38, KEYC_F2|KEYC_SHIFT|KEYC_CTRL },
	{ TTYC_KF39, KEYC_F3|KEYC_SHIFT|KEYC_CTRL },
	{ TTYC_KF40, KEYC_F4|KEYC_SHIFT|KEYC_CTRL },
	{ TTYC_KF41, KEYC_F5|KEYC_SHIFT|KEYC_CTRL },
	{ TTYC_KF42, KEYC_F6|KEYC_SHIFT|KEYC_CTRL },
	{ TTYC_KF43, KEYC_F7|KEYC_SHIFT|KEYC_CTRL },
	{ TTYC_KF44, KEYC_F8|KEYC_SHIFT|KEYC_CTRL },
	{ TTYC_KF45, KEYC_F9|KEYC_SHIFT|KEYC_CTRL },
	{ TTYC_KF46, KEYC_F10|KEYC_SHIFT|KEYC_CTRL },
	{ TTYC_KF47, KEYC_F11|KEYC_SHIFT|KEYC_CTRL },
	{ TTYC_KF48, KEYC_F12|KEYC_SHIFT|KEYC_CTRL },

	{ TTYC_KF49, KEYC_F1|KEYC_ESCAPE },
	{ TTYC_KF50, KEYC_F2|KEYC_ESCAPE },
	{ TTYC_KF51, KEYC_F3|KEYC_ESCAPE },
	{ TTYC_KF52, KEYC_F4|KEYC_ESCAPE },
	{ TTYC_KF53, KEYC_F5|KEYC_ESCAPE },
	{ TTYC_KF54, KEYC_F6|KEYC_ESCAPE },
	{ TTYC_KF55, KEYC_F7|KEYC_ESCAPE },
	{ TTYC_KF56, KEYC_F8|KEYC_ESCAPE },
	{ TTYC_KF57, KEYC_F9|KEYC_ESCAPE },
	{ TTYC_KF58, KEYC_F10|KEYC_ESCAPE },
	{ TTYC_KF59, KEYC_F11|KEYC_ESCAPE },
	{ TTYC_KF60, KEYC_F12|KEYC_ESCAPE },

	{ TTYC_KF61, KEYC_F1|KEYC_ESCAPE|KEYC_SHIFT },
	{ TTYC_KF62, KEYC_F2|KEYC_ESCAPE|KEYC_SHIFT },
	{ TTYC_KF63, KEYC_F3|KEYC_ESCAPE|KEYC_SHIFT },

	{ TTYC_KICH1, KEYC_IC },
	{ TTYC_KDCH1, KEYC_DC },
	{ TTYC_KHOME, KEYC_HOME },
	{ TTYC_KEND, KEYC_END },
	{ TTYC_KNP, KEYC_NPAGE },
	{ TTYC_KPP, KEYC_PPAGE },
	{ TTYC_KCBT, KEYC_BTAB },

	/* Arrow keys from terminfo. */
	{ TTYC_KCUU1, KEYC_UP },
	{ TTYC_KCUD1, KEYC_DOWN },
	{ TTYC_KCUB1, KEYC_LEFT },
	{ TTYC_KCUF1, KEYC_RIGHT },

	/*
	 * Key and modifier capabilities. We set the xterm flag to mark that
	 * any leading escape means an escape key press and not the modifier.
	 */
	{ TTYC_KDC2, KEYC_DC|KEYC_SHIFT|KEYC_XTERM },
	{ TTYC_KDC3, KEYC_DC|KEYC_ESCAPE|KEYC_XTERM },
	{ TTYC_KDC4, KEYC_DC|KEYC_SHIFT|KEYC_ESCAPE|KEYC_XTERM },
	{ TTYC_KDC5, KEYC_DC|KEYC_CTRL|KEYC_XTERM },
	{ TTYC_KDC6, KEYC_DC|KEYC_SHIFT|KEYC_CTRL|KEYC_XTERM },
	{ TTYC_KDC7, KEYC_DC|KEYC_ESCAPE|KEYC_CTRL|KEYC_XTERM },
	{ TTYC_KDN2, KEYC_DOWN|KEYC_SHIFT|KEYC_XTERM },
	{ TTYC_KDN3, KEYC_DOWN|KEYC_ESCAPE|KEYC_XTERM },
	{ TTYC_KDN4, KEYC_DOWN|KEYC_SHIFT|KEYC_ESCAPE|KEYC_XTERM },
	{ TTYC_KDN5, KEYC_DOWN|KEYC_CTRL|KEYC_XTERM },
	{ TTYC_KDN6, KEYC_DOWN|KEYC_SHIFT|KEYC_CTRL|KEYC_XTERM },
	{ TTYC_KDN7, KEYC_DOWN|KEYC_ESCAPE|KEYC_CTRL|KEYC_XTERM },
	{ TTYC_KEND2, KEYC_END|KEYC_SHIFT|KEYC_XTERM },
	{ TTYC_KEND3, KEYC_END|KEYC_ESCAPE|KEYC_XTERM },
	{ TTYC_KEND4, KEYC_END|KEYC_SHIFT|KEYC_ESCAPE|KEYC_XTERM },
	{ TTYC_KEND5, KEYC_END|KEYC_CTRL|KEYC_XTERM },
	{ TTYC_KEND6, KEYC_END|KEYC_SHIFT|KEYC_CTRL|KEYC_XTERM },
	{ TTYC_KEND7, KEYC_END|KEYC_ESCAPE|KEYC_CTRL|KEYC_XTERM },
	{ TTYC_KHOM2, KEYC_HOME|KEYC_SHIFT|KEYC_XTERM },
	{ TTYC_KHOM3, KEYC_HOME|KEYC_ESCAPE|KEYC_XTERM },
	{ TTYC_KHOM4, KEYC_HOME|KEYC_SHIFT|KEYC_ESCAPE|KEYC_XTERM },
	{ TTYC_KHOM5, KEYC_HOME|KEYC_CTRL|KEYC_XTERM },
	{ TTYC_KHOM6, KEYC_HOME|KEYC_SHIFT|KEYC_CTRL|KEYC_XTERM },
	{ TTYC_KHOM7, KEYC_HOME|KEYC_ESCAPE|KEYC_CTRL|KEYC_XTERM },
	{ TTYC_KIC2, KEYC_IC|KEYC_SHIFT|KEYC_XTERM },
	{ TTYC_KIC3, KEYC_IC|KEYC_ESCAPE|KEYC_XTERM },
	{ TTYC_KIC4, KEYC_IC|KEYC_SHIFT|KEYC_ESCAPE|KEYC_XTERM },
	{ TTYC_KIC5, KEYC_IC|KEYC_CTRL|KEYC_XTERM },
	{ TTYC_KIC6, KEYC_IC|KEYC_SHIFT|KEYC_CTRL|KEYC_XTERM },
	{ TTYC_KIC7, KEYC_IC|KEYC_ESCAPE|KEYC_CTRL|KEYC_XTERM },
	{ TTYC_KLFT2, KEYC_LEFT|KEYC_SHIFT|KEYC_XTERM },
	{ TTYC_KLFT3, KEYC_LEFT|KEYC_ESCAPE|KEYC_XTERM },
	{ TTYC_KLFT4, KEYC_LEFT|KEYC_SHIFT|KEYC_ESCAPE|KEYC_XTERM },
	{ TTYC_KLFT5, KEYC_LEFT|KEYC_CTRL|KEYC_XTERM },
	{ TTYC_KLFT6, KEYC_LEFT|KEYC_SHIFT|KEYC_CTRL|KEYC_XTERM },
	{ TTYC_KLFT7, KEYC_LEFT|KEYC_ESCAPE|KEYC_CTRL|KEYC_XTERM },
	{ TTYC_KNXT2, KEYC_NPAGE|KEYC_SHIFT|KEYC_XTERM },
	{ TTYC_KNXT3, KEYC_NPAGE|KEYC_ESCAPE|KEYC_XTERM },
	{ TTYC_KNXT4, KEYC_NPAGE|KEYC_SHIFT|KEYC_ESCAPE|KEYC_XTERM },
	{ TTYC_KNXT5, KEYC_NPAGE|KEYC_CTRL|KEYC_XTERM },
	{ TTYC_KNXT6, KEYC_NPAGE|KEYC_SHIFT|KEYC_CTRL|KEYC_XTERM },
	{ TTYC_KNXT7, KEYC_NPAGE|KEYC_ESCAPE|KEYC_CTRL|KEYC_XTERM },
	{ TTYC_KPRV2, KEYC_PPAGE|KEYC_SHIFT|KEYC_XTERM },
	{ TTYC_KPRV3, KEYC_PPAGE|KEYC_ESCAPE|KEYC_XTERM },
	{ TTYC_KPRV4, KEYC_PPAGE|KEYC_SHIFT|KEYC_ESCAPE|KEYC_XTERM },
	{ TTYC_KPRV5, KEYC_PPAGE|KEYC_CTRL|KEYC_XTERM },
	{ TTYC_KPRV6, KEYC_PPAGE|KEYC_SHIFT|KEYC_CTRL|KEYC_XTERM },
	{ TTYC_KPRV7, KEYC_PPAGE|KEYC_ESCAPE|KEYC_CTRL|KEYC_XTERM },
	{ TTYC_KRIT2, KEYC_RIGHT|KEYC_SHIFT|KEYC_XTERM },
	{ TTYC_KRIT3, KEYC_RIGHT|KEYC_ESCAPE|KEYC_XTERM },
	{ TTYC_KRIT4, KEYC_RIGHT|KEYC_SHIFT|KEYC_ESCAPE|KEYC_XTERM },
	{ TTYC_KRIT5, KEYC_RIGHT|KEYC_CTRL|KEYC_XTERM },
	{ TTYC_KRIT6, KEYC_RIGHT|KEYC_SHIFT|KEYC_CTRL|KEYC_XTERM },
	{ TTYC_KRIT7, KEYC_RIGHT|KEYC_ESCAPE|KEYC_CTRL|KEYC_XTERM },
	{ TTYC_KUP2, KEYC_UP|KEYC_SHIFT|KEYC_XTERM },
	{ TTYC_KUP3, KEYC_UP|KEYC_ESCAPE|KEYC_XTERM },
	{ TTYC_KUP4, KEYC_UP|KEYC_SHIFT|KEYC_ESCAPE|KEYC_XTERM },
	{ TTYC_KUP5, KEYC_UP|KEYC_CTRL|KEYC_XTERM },
	{ TTYC_KUP6, KEYC_UP|KEYC_SHIFT|KEYC_CTRL|KEYC_XTERM },
	{ TTYC_KUP7, KEYC_UP|KEYC_ESCAPE|KEYC_CTRL|KEYC_XTERM },
};

/* Add key to tree. */
static void
tty_keys_add(struct tty *tty, const char *s, key_code key)
{
	struct tty_key	*tk;
	size_t		 size;
	const char     	*keystr;

	keystr = key_string_lookup_key(key);
	if ((tk = tty_keys_find(tty, s, strlen(s), &size)) == NULL) {
		log_debug("new key %s: 0x%llx (%s)", s, key, keystr);
		tty_keys_add1(&tty->key_tree, s, key);
	} else {
		log_debug("replacing key %s: 0x%llx (%s)", s, key, keystr);
		tk->key = key;
	}
}

/* Add next node to the tree. */
static void
tty_keys_add1(struct tty_key **tkp, const char *s, key_code key)
{
	struct tty_key	*tk;

	/* Allocate a tree entry if there isn't one already. */
	tk = *tkp;
	if (tk == NULL) {
		tk = *tkp = xcalloc(1, sizeof *tk);
		tk->ch = *s;
		tk->key = KEYC_UNKNOWN;
	}

	/* Find the next entry. */
	if (*s == tk->ch) {
		/* Move forward in string. */
		s++;

		/* If this is the end of the string, no more is necessary. */
		if (*s == '\0') {
			tk->key = key;
			return;
		}

		/* Use the child tree for the next character. */
		tkp = &tk->next;
	} else {
		if (*s < tk->ch)
			tkp = &tk->left;
		else if (*s > tk->ch)
			tkp = &tk->right;
	}

	/* And recurse to add it. */
	tty_keys_add1(tkp, s, key);
}

/* Initialise a key tree from the table. */
void
tty_keys_build(struct tty *tty)
{
	const struct tty_default_key_raw	*tdkr;
	const struct tty_default_key_code	*tdkc;
	u_int		 			 i;
	const char				*s;

	if (tty->key_tree != NULL)
		tty_keys_free(tty);
	tty->key_tree = NULL;

	for (i = 0; i < nitems(tty_default_raw_keys); i++) {
		tdkr = &tty_default_raw_keys[i];

		s = tdkr->string;
		if (*s != '\0')
			tty_keys_add(tty, s, tdkr->key);
	}
	for (i = 0; i < nitems(tty_default_code_keys); i++) {
		tdkc = &tty_default_code_keys[i];

		s = tty_term_string(tty->term, tdkc->code);
		if (*s != '\0')
			tty_keys_add(tty, s, tdkc->key);

	}
}

/* Free the entire key tree. */
void
tty_keys_free(struct tty *tty)
{
	tty_keys_free1(tty->key_tree);
}

/* Free a single key. */
static void
tty_keys_free1(struct tty_key *tk)
{
	if (tk->next != NULL)
		tty_keys_free1(tk->next);
	if (tk->left != NULL)
		tty_keys_free1(tk->left);
	if (tk->right != NULL)
		tty_keys_free1(tk->right);
	free(tk);
}

/* Lookup a key in the tree. */
static struct tty_key *
tty_keys_find(struct tty *tty, const char *buf, size_t len, size_t *size)
{
	*size = 0;
	return (tty_keys_find1(tty->key_tree, buf, len, size));
}

/* Find the next node. */
static struct tty_key *
tty_keys_find1(struct tty_key *tk, const char *buf, size_t len, size_t *size)
{
	/* If the node is NULL, this is the end of the tree. No match. */
	if (tk == NULL)
		return (NULL);

	/* Pick the next in the sequence. */
	if (tk->ch == *buf) {
		/* Move forward in the string. */
		buf++; len--;
		(*size)++;

		/* At the end of the string, return the current node. */
		if (len == 0 || (tk->next == NULL && tk->key != KEYC_UNKNOWN))
			return (tk);

		/* Move into the next tree for the following character. */
		tk = tk->next;
	} else {
		if (*buf < tk->ch)
			tk = tk->left;
		else if (*buf > tk->ch)
			tk = tk->right;
	}

	/* Move to the next in the tree. */
	return (tty_keys_find1(tk, buf, len, size));
}

/* Look up part of the next key. */
static int
tty_keys_next1(struct tty *tty, const char *buf, size_t len, key_code *key,
    size_t *size, int expired)
{
	struct client		*c = tty->client;
	struct tty_key		*tk, *tk1;
	struct utf8_data	 ud;
	enum utf8_state		 more;
	u_int			 i;
	wchar_t			 wc;
	int			 n;

	log_debug("%s: next key is %zu (%.*s) (expired=%d)", c->name, len,
	    (int)len, buf, expired);

	/* Is this a known key? */
	tk = tty_keys_find(tty, buf, len, size);
	if (tk != NULL && tk->key != KEYC_UNKNOWN) {
		tk1 = tk;
		do
			log_debug("%s: keys in list: %#llx", c->name, tk1->key);
		while ((tk1 = tk1->next) != NULL);
		if (tk->next != NULL && !expired)
			return (1);
		*key = tk->key;
		return (0);
	}

	/* Is this an an xterm(1) key? */
	n = xterm_keys_find(buf, len, size, key);
	if (n == 0)
		return (0);
	if (n == 1 && !expired)
		return (1);

	/* Is this valid UTF-8? */
	more = utf8_open(&ud, (u_char)*buf);
	if (more == UTF8_MORE) {
		*size = ud.size;
		if (len < ud.size) {
			if (!expired)
				return (1);
			return (-1);
		}
		for (i = 1; i < ud.size; i++)
			more = utf8_append(&ud, (u_char)buf[i]);
		if (more != UTF8_DONE)
			return (-1);

		if (utf8_combine(&ud, &wc) != UTF8_DONE)
			return (-1);
		*key = wc;

		log_debug("%s: UTF-8 key %.*s %#llx", c->name, (int)ud.size,
		    buf, *key);
		return (0);
	}

	return (-1);
}

/*
 * Process at least one key in the buffer and invoke tty->key_callback. Return
 * 0 if there are no further keys, or 1 if there could be more in the buffer.
 */
key_code
tty_keys_next(struct tty *tty)
{
	struct client	*c = tty->client;
	struct timeval	 tv;
	const char	*buf;
	size_t		 len, size;
	cc_t		 bspace;
	int		 delay, expired = 0, n;
	key_code	 key;

	/* Get key buffer. */
	buf = EVBUFFER_DATA(tty->in);
	len = EVBUFFER_LENGTH(tty->in);

	if (len == 0)
		return (0);
	log_debug("%s: keys are %zu (%.*s)", c->name, len, (int)len, buf);

	/* Is this a device attributes response? */
	switch (tty_keys_device_attributes(tty, buf, len, &size)) {
	case 0:		/* yes */
		key = KEYC_UNKNOWN;
		goto complete_key;
	case -1:	/* no, or not valid */
		break;
	case 1:		/* partial */
		goto partial_key;
	}

	/* Is this a mouse key press? */
	switch (tty_keys_mouse(tty, buf, len, &size)) {
	case 0:		/* yes */
		key = KEYC_MOUSE;
		goto complete_key;
	case -1:	/* no, or not valid */
		break;
	case -2:	/* yes, but we don't care. */
		key = KEYC_MOUSE;
		goto discard_key;
	case 1:		/* partial */
		goto partial_key;
	}

first_key:
	/* Handle keys starting with escape. */
	if (*buf == '\033') {
		/* Look for a key without the escape. */
		n = tty_keys_next1(tty, buf + 1, len - 1, &key, &size, expired);
		if (n == 0) {	/* found */
			if (key & KEYC_XTERM) {
				/*
				 * We want the escape key as well as the xterm
				 * key, because the xterm sequence implicitly
				 * includes the escape (so if we see
				 * \033\033[1;3D we know it is an Escape
				 * followed by M-Left, not just M-Left).
				 */
				key = '\033';
				size = 1;
				goto complete_key;
			}
			key |= KEYC_ESCAPE;
			size++;
			goto complete_key;
		}
		if (n == 1)	/* partial */
			goto partial_key;
	}

	/* Try to lookup key. */
	n = tty_keys_next1(tty, buf, len, &key, &size, expired);
	if (n == 0)	/* found */
		goto complete_key;
	if (n == 1)
		goto partial_key;

	/*
	 * At this point, we know the key is not partial (with or without
	 * escape). So pass it through even if the timer has not expired.
	 */
	if (*buf == '\033' && len >= 2) {
		key = (u_char)buf[1] | KEYC_ESCAPE;
		size = 2;
	} else {
		key = (u_char)buf[0];
		size = 1;
	}
	goto complete_key;

partial_key:
	log_debug("%s: partial key %.*s", c->name, (int)len, buf);

	/* If timer is going, check for expiration. */
	if (tty->flags & TTY_TIMER) {
		if (evtimer_initialized(&tty->key_timer) &&
		    !evtimer_pending(&tty->key_timer, NULL)) {
			expired = 1;
			goto first_key;
		}
		return (0);
	}

	/* Get the time period. */
	delay = options_get_number(global_options, "escape-time");
	tv.tv_sec = delay / 1000;
	tv.tv_usec = (delay % 1000) * 1000L;

	/* Start the timer. */
	if (event_initialized(&tty->key_timer))
		evtimer_del(&tty->key_timer);
	evtimer_set(&tty->key_timer, tty_keys_callback, tty);
	evtimer_add(&tty->key_timer, &tv);

	tty->flags |= TTY_TIMER;
	return (0);

complete_key:
	log_debug("%s: complete key %.*s %#llx", c->name, (int)size, buf, key);

	/*
	 * Check for backspace key using termios VERASE - the terminfo
	 * kbs entry is extremely unreliable, so cannot be safely
	 * used. termios should have a better idea.
	 */
	bspace = tty->tio.c_cc[VERASE];
	if (bspace != _POSIX_VDISABLE && (key & KEYC_MASK_KEY) == bspace)
		key = (key & KEYC_MASK_MOD) | KEYC_BSPACE;

	/* Remove data from buffer. */
	evbuffer_drain(tty->in, size);

	/* Remove key timer. */
	if (event_initialized(&tty->key_timer))
		evtimer_del(&tty->key_timer);
	tty->flags &= ~TTY_TIMER;

	/* Check for focus events. */
	if (key == KEYC_FOCUS_OUT) {
		tty->client->flags &= ~CLIENT_FOCUSED;
		return (1);
	} else if (key == KEYC_FOCUS_IN) {
		tty->client->flags |= CLIENT_FOCUSED;
		return (1);
	}

	/* Fire the key. */
	if (key != KEYC_UNKNOWN)
		server_client_handle_key(tty->client, key);

	return (1);

discard_key:
	log_debug("%s: discard key %.*s %#llx", c->name, (int)size, buf, key);

	/* Remove data from buffer. */
	evbuffer_drain(tty->in, size);

	return (1);
}

/* Key timer callback. */
static void
tty_keys_callback(__unused int fd, __unused short events, void *data)
{
	struct tty	*tty = data;

	if (tty->flags & TTY_TIMER) {
		while (tty_keys_next(tty))
			;
	}
}

/*
 * Handle mouse key input. Returns 0 for success, -1 for failure, 1 for partial
 * (probably a mouse sequence but need more data).
 */
static int
tty_keys_mouse(struct tty *tty, const char *buf, size_t len, size_t *size)
{
	struct client		*c = tty->client;
	struct mouse_event	*m = &tty->mouse;
	u_int			 i, x, y, b, sgr_b;
	u_char			 sgr_type, ch;

	/*
	 * Standard mouse sequences are \033[M followed by three characters
	 * indicating button, X and Y, all based at 32 with 1,1 top-left.
	 *
	 * UTF-8 mouse sequences are similar but the three are expressed as
	 * UTF-8 characters.
	 *
	 * SGR extended mouse sequences are \033[< followed by three numbers in
	 * decimal and separated by semicolons indicating button, X and Y. A
	 * trailing 'M' is click or scroll and trailing 'm' release. All are
	 * based at 0 with 1,1 top-left.
	 */

	*size = 0;
	x = y = b = sgr_b = 0;
	sgr_type = ' ';

	/* First two bytes are always \033[. */
	if (buf[0] != '\033')
		return (-1);
	if (len == 1)
		return (1);
	if (buf[1] != '[')
		return (-1);
	if (len == 2)
		return (1);

	/*
	 * Third byte is M in old standard (and UTF-8 extension which we do not
	 * support), < in SGR extension.
	 */
	if (buf[2] == 'M') {
		/* Read the three inputs. */
		*size = 3;
		for (i = 0; i < 3; i++) {
			if (len <= *size)
				return (1);
			ch = (u_char)buf[(*size)++];
			if (i == 0)
				b = ch;
			else if (i == 1)
				x = ch;
			else
				y = ch;
		}
		log_debug("%s: mouse input: %.*s", c->name, (int)*size, buf);

		/* Check and return the mouse input. */
		if (b < 32)
			return (-1);
		b -= 32;
		if (x >= 33)
			x -= 33;
		else
			x = 256 - x;
		if (y >= 33)
			y -= 33;
		else
			y = 256 - y;
	} else if (buf[2] == '<') {
		/* Read the three inputs. */
		*size = 3;
		while (1) {
			if (len <= *size)
				return (1);
			ch = (u_char)buf[(*size)++];
			if (ch == ';')
				break;
			if (ch < '0' || ch > '9')
				return (-1);
			sgr_b = 10 * sgr_b + (ch - '0');
		}
		while (1) {
			if (len <= *size)
				return (1);
			ch = (u_char)buf[(*size)++];
			if (ch == ';')
				break;
			if (ch < '0' || ch > '9')
				return (-1);
			x = 10 * x + (ch - '0');
		}
		while (1) {
			if (len <= *size)
				return (1);
			ch = (u_char)buf[(*size)++];
			if (ch == 'M' || ch == 'm')
				break;
			if (ch < '0' || ch > '9')
				return (-1);
			y = 10 * y + (ch - '0');
		}
		log_debug("%s: mouse input (SGR): %.*s", c->name, (int)*size,
		    buf);

		/* Check and return the mouse input. */
		if (x < 1 || y < 1)
			return (-1);
		x--;
		y--;
		b = sgr_b;

		/* Type is M for press, m for release. */
		sgr_type = ch;
		if (sgr_type == 'm')
			b |= 3;

		/*
		 * Some terminals (like PuTTY 0.63) mistakenly send
		 * button-release events for scroll-wheel button-press event.
		 * Discard it before it reaches any program running inside
		 * tmux.
		 */
		if (sgr_type == 'm' && (sgr_b & 64))
		    return (-2);
	} else
		return (-1);

	/* Fill mouse event. */
	m->lx = m->x;
	m->x = x;
	m->ly = m->y;
	m->y = y;
	m->lb = m->b;
	m->b = b;
	m->sgr_type = sgr_type;
	m->sgr_b = sgr_b;

	return (0);
}

/*
 * Handle device attributes input. Returns 0 for success, -1 for failure, 1 for
 * partial.
 */
static int
tty_keys_device_attributes(struct tty *tty, const char *buf, size_t len,
    size_t *size)
{
	struct client		*c = tty->client;
	u_int			 i, a, b;
	char			 tmp[64], *endptr;
	static const char	*types[] = TTY_TYPES;
	int			 type;

	*size = 0;

	/* First three bytes are always \033[?. */
	if (buf[0] != '\033')
		return (-1);
	if (len == 1)
		return (1);
	if (buf[1] != '[')
		return (-1);
	if (len == 2)
		return (1);
	if (buf[2] != '?')
		return (-1);
	if (len == 3)
		return (1);

	/* Copy the rest up to a 'c'. */
	for (i = 0; i < (sizeof tmp) - 1 && buf[3 + i] != 'c'; i++) {
		if (3 + i == len)
			return (1);
		tmp[i] = buf[3 + i];
	}
	if (i == (sizeof tmp) - 1)
		return (-1);
	tmp[i] = '\0';
	*size = 4 + i;

	/* Convert version numbers. */
	a = strtoul(tmp, &endptr, 10);
	if (*endptr == ';') {
		b = strtoul(endptr + 1, &endptr, 10);
		if (*endptr != '\0' && *endptr != ';')
			b = 0;
	} else
		a = b = 0;

	/* Store terminal type. */
	type = TTY_UNKNOWN;
	switch (a) {
	case 1:
		if (b == 2)
			type = TTY_VT100;
		else if (b == 0)
			type = TTY_VT101;
		break;
	case 6:
		type = TTY_VT102;
		break;
	case 62:
		type = TTY_VT220;
		break;
	case 63:
		type = TTY_VT320;
		break;
	case 64:
		type = TTY_VT420;
		break;
	}
	tty_set_type(tty, type);

	log_debug("%s: received DA %.*s (%s)", c->name, (int)*size, buf,
	    types[type]);
	return (0);
}
@


1.97
log
@Up to now, tmux sees \033\033[OA as M-Up and since we turned on
xterm-keys by default, generates \033[1;3A instead of
\033\033[OA. Unfortunately this confuses vi, which doesn't understand
xterm keys and now sees Escape+Up pressed within escape-time as Escape
followed by A.

The issue doesn't happen in xterm itself because it gets the keys from X
and can distinguish between a genuine M-Up and Escape+Up.

Because xterm can, tmux can too: xterm will give us \033[1;3A (that is,
kUP3) for a real M-Up and \033\033OA for Escape+Up - in fact, we can be
sure any \033 preceding an xterm key is a real Escape key press because
Meta would be part of the xterm key instead of a separate \033.

So change tmux to recognise both sequences as M-Up for its own purposes,
but generate the xterm version of M-Up only if it originally received
the xterm version from the terminal.

This means we will return to sending \033\033OA instead of the xterm key
for terminals that do not support xterm keys themselves, but there is no
practical way around this because they do not allow us to distinguish
between Escape+Up and M-Up. xterm style escape sequences are now the de
facto standard for these keys in any case.

Problem reported by jsing@@ and subsequently by Cecile Tonglet in GitHub
issue 907.
@
text
@d1 1
a1 1
/* $OpenBSD: tty-keys.c,v 1.96 2017/04/18 21:41:42 nicm Exp $ */
d168 4
@


1.96
log
@Revert use of DECSLRM on iTerm2, it doesn't help as much as we throught,
and there are some question marks about it's support.
@
text
@d1 1
a1 1
/* $OpenBSD: tty-keys.c,v 1.95 2017/04/18 18:21:37 nicm Exp $ */
d260 64
a323 61
	/* Key and modifier capabilities. */
	{ TTYC_KDC2, KEYC_DC|KEYC_SHIFT },
	{ TTYC_KDC3, KEYC_DC|KEYC_ESCAPE },
	{ TTYC_KDC4, KEYC_DC|KEYC_SHIFT|KEYC_ESCAPE },
	{ TTYC_KDC5, KEYC_DC|KEYC_CTRL },
	{ TTYC_KDC6, KEYC_DC|KEYC_SHIFT|KEYC_CTRL },
	{ TTYC_KDC7, KEYC_DC|KEYC_ESCAPE|KEYC_CTRL },
	{ TTYC_KDN2, KEYC_DOWN|KEYC_SHIFT },
	{ TTYC_KDN3, KEYC_DOWN|KEYC_ESCAPE },
	{ TTYC_KDN4, KEYC_DOWN|KEYC_SHIFT|KEYC_ESCAPE },
	{ TTYC_KDN5, KEYC_DOWN|KEYC_CTRL },
	{ TTYC_KDN6, KEYC_DOWN|KEYC_SHIFT|KEYC_CTRL },
	{ TTYC_KDN7, KEYC_DOWN|KEYC_ESCAPE|KEYC_CTRL },
	{ TTYC_KEND2, KEYC_END|KEYC_SHIFT },
	{ TTYC_KEND3, KEYC_END|KEYC_ESCAPE },
	{ TTYC_KEND4, KEYC_END|KEYC_SHIFT|KEYC_ESCAPE },
	{ TTYC_KEND5, KEYC_END|KEYC_CTRL },
	{ TTYC_KEND6, KEYC_END|KEYC_SHIFT|KEYC_CTRL },
	{ TTYC_KEND7, KEYC_END|KEYC_ESCAPE|KEYC_CTRL },
	{ TTYC_KHOM2, KEYC_HOME|KEYC_SHIFT },
	{ TTYC_KHOM3, KEYC_HOME|KEYC_ESCAPE },
	{ TTYC_KHOM4, KEYC_HOME|KEYC_SHIFT|KEYC_ESCAPE },
	{ TTYC_KHOM5, KEYC_HOME|KEYC_CTRL },
	{ TTYC_KHOM6, KEYC_HOME|KEYC_SHIFT|KEYC_CTRL },
	{ TTYC_KHOM7, KEYC_HOME|KEYC_ESCAPE|KEYC_CTRL },
	{ TTYC_KIC2, KEYC_IC|KEYC_SHIFT },
	{ TTYC_KIC3, KEYC_IC|KEYC_ESCAPE },
	{ TTYC_KIC4, KEYC_IC|KEYC_SHIFT|KEYC_ESCAPE },
	{ TTYC_KIC5, KEYC_IC|KEYC_CTRL },
	{ TTYC_KIC6, KEYC_IC|KEYC_SHIFT|KEYC_CTRL },
	{ TTYC_KIC7, KEYC_IC|KEYC_ESCAPE|KEYC_CTRL },
	{ TTYC_KLFT2, KEYC_LEFT|KEYC_SHIFT },
	{ TTYC_KLFT3, KEYC_LEFT|KEYC_ESCAPE },
	{ TTYC_KLFT4, KEYC_LEFT|KEYC_SHIFT|KEYC_ESCAPE },
	{ TTYC_KLFT5, KEYC_LEFT|KEYC_CTRL },
	{ TTYC_KLFT6, KEYC_LEFT|KEYC_SHIFT|KEYC_CTRL },
	{ TTYC_KLFT7, KEYC_LEFT|KEYC_ESCAPE|KEYC_CTRL },
	{ TTYC_KNXT2, KEYC_NPAGE|KEYC_SHIFT },
	{ TTYC_KNXT3, KEYC_NPAGE|KEYC_ESCAPE },
	{ TTYC_KNXT4, KEYC_NPAGE|KEYC_SHIFT|KEYC_ESCAPE },
	{ TTYC_KNXT5, KEYC_NPAGE|KEYC_CTRL },
	{ TTYC_KNXT6, KEYC_NPAGE|KEYC_SHIFT|KEYC_CTRL },
	{ TTYC_KNXT7, KEYC_NPAGE|KEYC_ESCAPE|KEYC_CTRL },
	{ TTYC_KPRV2, KEYC_PPAGE|KEYC_SHIFT },
	{ TTYC_KPRV3, KEYC_PPAGE|KEYC_ESCAPE },
	{ TTYC_KPRV4, KEYC_PPAGE|KEYC_SHIFT|KEYC_ESCAPE },
	{ TTYC_KPRV5, KEYC_PPAGE|KEYC_CTRL },
	{ TTYC_KPRV6, KEYC_PPAGE|KEYC_SHIFT|KEYC_CTRL },
	{ TTYC_KPRV7, KEYC_PPAGE|KEYC_ESCAPE|KEYC_CTRL },
	{ TTYC_KRIT2, KEYC_RIGHT|KEYC_SHIFT },
	{ TTYC_KRIT3, KEYC_RIGHT|KEYC_ESCAPE },
	{ TTYC_KRIT4, KEYC_RIGHT|KEYC_SHIFT|KEYC_ESCAPE },
	{ TTYC_KRIT5, KEYC_RIGHT|KEYC_CTRL },
	{ TTYC_KRIT6, KEYC_RIGHT|KEYC_SHIFT|KEYC_CTRL },
	{ TTYC_KRIT7, KEYC_RIGHT|KEYC_ESCAPE|KEYC_CTRL },
	{ TTYC_KUP2, KEYC_UP|KEYC_SHIFT },
	{ TTYC_KUP3, KEYC_UP|KEYC_ESCAPE },
	{ TTYC_KUP4, KEYC_UP|KEYC_SHIFT|KEYC_ESCAPE },
	{ TTYC_KUP5, KEYC_UP|KEYC_CTRL },
	{ TTYC_KUP6, KEYC_UP|KEYC_SHIFT|KEYC_CTRL },
	{ TTYC_KUP7, KEYC_UP|KEYC_ESCAPE|KEYC_CTRL },
d482 1
d500 7
d587 12
a611 7
		goto partial_key;

	/* Is this an an xterm(1) key? */
	n = xterm_keys_find(buf, len, &size, &key);
	if (n == 0)
		goto complete_key;
	if (n == 1 && !expired)
@


1.95
log
@Detect iTerm2 and use DECSLRM for it as well.
@
text
@d1 1
a1 1
/* $OpenBSD: tty-keys.c,v 1.94 2017/04/18 13:34:04 nicm Exp $ */
a48 2
static int	tty_keys_iterm2_version(struct tty *, const char *, size_t,
		    size_t *);
a555 11
	/* Or a response from iTerm2? */
	switch (tty_keys_iterm2_version(tty, buf, len, &size)) {
	case 0:		/* yes */
		key = KEYC_UNKNOWN;
		goto complete_key;
	case -1:	/* no, or not valid */
		break;
	case 1:		/* partial */
		goto partial_key;
	}

a912 31
	return (0);
}

/*
 * Handle a version response from iTerm2. Returns 0 for success, -1 for
 * failure, 1 for partial.
 */
static int
tty_keys_iterm2_version(struct tty *tty, const char *buf, size_t len,
    size_t *size)
{
	struct client	*c = tty->client;
	u_int		 i;

	*size = 0;

	if (memcmp("\033[ITERM2 ", buf, (len > 9) ? 9 : len) != 0)
		return (-1);
	if (len < 10)
		return (1);
	for (i = 9; i < len; i++) {
		if (buf[i] == 'n')
			break;
	}
	if (i == len)
		return (1);
	*size = i + 1;

	tty_set_type(tty, TTY_ITERM2);

	log_debug("%s: this is iTerm2", c->name);
@


1.94
log
@Include client name in key logging.
@
text
@d1 1
a1 1
/* $OpenBSD: tty-keys.c,v 1.93 2017/02/10 12:59:18 nicm Exp $ */
d49 2
d558 11
d926 31
@


1.93
log
@Don't use a bufferevent for the tty, so we can keep better track of what
is being written and when.

Also a manpage typo fix from jmc@@.
@
text
@d1 1
a1 1
/* $OpenBSD: tty-keys.c,v 1.92 2017/01/11 16:05:46 nicm Exp $ */
d473 1
d480 2
a481 2
	log_debug("next key is %zu (%.*s) (expired=%d)", len, (int)len, buf,
	    expired);
d488 1
a488 1
			log_debug("keys in list: %#llx", tk1->key);
d514 2
a515 1
		log_debug("UTF-8 key %.*s %#llx", (int)ud.size, buf, *key);
d529 1
d543 1
a543 1
	log_debug("keys are %zu (%.*s)", len, (int)len, buf);
d612 1
a612 1
	log_debug("partial key %.*s", (int)len, buf);
d639 1
a639 1
	log_debug("complete key %.*s %#llx", (int)size, buf, key);
d674 1
a674 1
	log_debug("discard key %.*s %#llx", (int)size, buf, key);
d701 1
d704 1
a704 1
	u_char			 sgr_type, c;
d743 1
a743 1
			c = (u_char)buf[(*size)++];
d745 1
a745 1
				b = c;
d747 1
a747 1
				x = c;
d749 1
a749 1
				y = c;
d751 1
a751 1
		log_debug("mouse input: %.*s", (int)*size, buf);
d771 2
a772 2
			c = (u_char)buf[(*size)++];
			if (c == ';')
d774 1
a774 1
			if (c < '0' || c > '9')
d776 1
a776 1
			sgr_b = 10 * sgr_b + (c - '0');
d781 2
a782 2
			c = (u_char)buf[(*size)++];
			if (c == ';')
d784 1
a784 1
			if (c < '0' || c > '9')
d786 1
a786 1
			x = 10 * x + (c - '0');
d791 2
a792 2
			c = (u_char)buf[(*size)++];
			if (c == 'M' || c == 'm')
d794 1
a794 1
			if (c < '0' || c > '9')
d796 1
a796 1
			y = 10 * y + (c - '0');
d798 2
a799 1
		log_debug("mouse input (SGR): %.*s", (int)*size, buf);
d809 1
a809 1
		sgr_type = c;
d845 1
d887 1
d911 2
a912 1
	log_debug("received DA %.*s (%s)", (int)*size, buf, types[type]);
@


1.92
log
@Use a macro for looking up tty types.
@
text
@d1 1
a1 1
/* $OpenBSD: tty-keys.c,v 1.91 2016/11/15 14:02:32 nicm Exp $ */
d535 2
a536 2
	buf = EVBUFFER_DATA(tty->event->input);
	len = EVBUFFER_LENGTH(tty->event->input);
d648 1
a648 1
	evbuffer_drain(tty->event->input, size);
d674 1
a674 1
	evbuffer_drain(tty->event->input, size);
@


1.91
log
@Initial attempt to make use of left and right margins if the terminal
supports them (that is, if it advertises itself as a VT420 - probably
just xterm). These are the vertical equivalent of the scroll region and
allow much faster scrolling of panes that do not take up the full width
of the terminal.
@
text
@d1 1
a1 1
/* $OpenBSD: tty-keys.c,v 1.90 2016/10/10 21:29:23 nicm Exp $ */
d840 4
a843 3
	u_int		 i, a, b;
	char		 tmp[64], *endptr;
	const char	*s;
d881 1
a881 1
	s = "UNKNOWN";
d884 4
a887 7
		if (b == 2) {
			tty_set_type(tty, TTY_VT100);
			s = "VT100";
		} else if (b == 0) {
			tty_set_type(tty, TTY_VT101);
			s = "VT101";
		}
d890 1
a890 2
		tty_set_type(tty, TTY_VT102);
		s = "VT102";
d893 1
a893 2
		tty_set_type(tty, TTY_VT220);
		s = "VT220";
d896 1
a896 2
		tty_set_type(tty, TTY_VT320);
		s = "VT320";
d899 1
a899 2
		tty_set_type(tty, TTY_VT420);
		s = "VT420";
d902 1
a902 1
	log_debug("received DA %.*s (%s)", (int)*size, buf, s);
d904 1
@


1.90
log
@Loads more static, except for cmd-*.c and window-*.c.
@
text
@d1 1
a1 1
/* $OpenBSD: tty-keys.c,v 1.89 2016/04/29 10:42:16 nicm Exp $ */
d47 2
d542 11
d828 81
@


1.89
log
@Fix keys parsing again to correctly accept Unicode when not prefixed
with Escape.
@
text
@d1 1
a1 1
/* $OpenBSD: tty-keys.c,v 1.88 2016/04/27 16:46:21 nicm Exp $ */
d53 1
a53 1
const struct tty_default_key_raw tty_default_raw_keys[] = {
d173 1
a173 1
const struct tty_default_key_code tty_default_code_keys[] = {
@


1.88
log
@Apply backspace check after working out the actual key, so that M-BSpace
can work.
@
text
@d1 1
a1 1
/* $OpenBSD: tty-keys.c,v 1.87 2016/04/27 16:40:12 nicm Exp $ */
a556 7
		/* A single escape goes as-is if the timer has expired. */
		if (expired && len == 1) {
			key = '\033';
			size = 1;
			goto complete_key;
		}

d566 1
d568 6
a573 6
		/* Try with the escape. */
		n = tty_keys_next1(tty, buf, len, &key, &size, expired);
		if (n == 0)	/* found */
			goto complete_key;
		if (n == 1)
			goto partial_key;
d575 6
a580 6
		/* Is this an an xterm(1) key? */
		n = xterm_keys_find(buf, len, &size, &key);
		if (n == 0)	/* found */
			goto complete_key;
		if (n == 1 && !expired)
			goto partial_key;
d582 10
a591 10
		/*
		 * If this is at least two keys, then it must be complete -
		 * whether or not the timer has expired - otherwise
		 * tty_keys_next1 would have returned a partial.
		 */
		if (len >= 2) {
			key = (u_char)buf[1] | KEYC_ESCAPE;
			size = 2;
			goto complete_key;
		}
a592 4

	/* No longer key found, use the first character. */
	key = (u_char)*buf;
	size = 1;
@


1.87
log
@Try again with keys parsing, tidy up further and fix single Escape press.
@
text
@d1 1
a1 1
/* $OpenBSD: tty-keys.c,v 1.86 2016/04/26 22:19:22 nicm Exp $ */
a602 10

	/*
	 * Check for backspace key using termios VERASE - the terminfo
	 * kbs entry is extremely unreliable, so cannot be safely
	 * used. termios should have a better idea.
	 */
	bspace = tty->tio.c_cc[VERASE];
	if (bspace != _POSIX_VDISABLE && key == bspace)
		key = KEYC_BSPACE;

d634 9
@


1.86
log
@Simplify next key matching and fix problems with meta and Unicode keys.
@
text
@d1 1
a1 1
/* $OpenBSD: tty-keys.c,v 1.85 2016/03/02 15:36:03 nicm Exp $ */
d44 1
a44 1
		    size_t *);
d469 1
a469 1
    size_t *size)
d477 2
a478 5
	log_debug("next key is %zu (%.*s)", len, (int)len, buf);

	/* Empty buffer is a partial key. */
	if (len == 0)
		return (1);
d482 1
a482 1
	if (tk != NULL) {
d485 1
a485 1
			log_debug("keys in list: %#llx", tk->key);
d487 2
d490 1
a490 1
		return (tk->next != NULL);
d497 5
a501 2
		if (len < ud.size)
			return (1);
d505 1
a505 1
			return (0);
d508 1
a508 1
			return (0);
d529 1
a529 1
	int		 delay, expired = 0;
d555 1
a555 1
	/* If escape is at the start, try without it. */
d557 4
a560 5
		switch (tty_keys_next1 (tty, buf + 1, len - 1, &key, &size)) {
		case 0:		/* found */
			if (key != KEYC_UNKNOWN)
				key |= KEYC_ESCAPE;
			size++; /* include escape */
d562 10
a571 5
		case -1:	/* not found */
			break;
		case 1:
			if (expired)
				goto complete_key;
a572 2
		}
	}
d574 3
a576 8
	/* Try with the escape. */
	switch (tty_keys_next1 (tty, buf, len, &key, &size)) {
	case 0:		/* found */
		goto complete_key;
	case -1:	/* not found */
		break;
	case 1:
		if (expired)
d578 2
a579 2
		goto partial_key;
	}
d581 6
a586 11
	/* Is this an an xterm(1) key? */
	switch (xterm_keys_find(buf, len, &size, &key)) {
	case 0:		/* found */
		goto complete_key;
	case -1:	/* not found */
		break;
	case 1:
		if (expired)
			break;
		goto partial_key;
	}
d588 5
a592 7
	/*
	 * If this starts with escape and is at least two keys, it must be
	 * complete even if the timer has not expired, because otherwise
	 * tty_keys_next1 would have found a partial key. If just an escape
	 * alone, it needs to wait for the timer first.
	 */
	if (*buf == '\033') {
a597 2
		if (!expired)
			goto partial_key;
@


1.85
log
@Handle wcwidth() and mbtowc() failures in better style and drop
characters where we can't find the width (wcwidth() fails) on input, the
same as we drop invalid UTF-8. Suggested by schwarze@@.
@
text
@d1 1
a1 1
/* $OpenBSD: tty-keys.c,v 1.84 2016/01/19 15:59:12 nicm Exp $ */
d36 4
a39 4
void		tty_keys_add1(struct tty_key **, const char *, key_code);
void		tty_keys_add(struct tty *, const char *, key_code);
void		tty_keys_free1(struct tty_key *);
struct tty_key *tty_keys_find1(struct tty_key *, const char *, size_t,
d41 6
a46 3
struct tty_key *tty_keys_find(struct tty *, const char *, size_t, size_t *);
void		tty_keys_callback(int, short, void *);
int		tty_keys_mouse(struct tty *, const char *, size_t, size_t *);
d322 1
a322 1
void
d340 1
a340 1
void
d415 1
a415 1
void
d428 1
a428 1
struct tty_key *
d436 1
a436 1
struct tty_key *
d466 50
d523 6
a528 11
	struct tty_key		*tk;
	struct timeval		 tv;
	const char		*buf;
	size_t			 len, size;
	cc_t			 bspace;
	int			 delay, expired = 0;
	key_code		 key;
	struct utf8_data	 ud;
	enum utf8_state		 more;
	u_int			 i;
	wchar_t			 wc;
d536 1
a536 1
	log_debug("keys are %zu (%.*s)", len, (int) len, buf);
d552 14
a565 4
	/* Look for matching key string and return if found. */
	tk = tty_keys_find(tty, buf, len, &size);
	if (tk != NULL) {
		if (tk->next != NULL)
d567 6
a572 1
		key = tk->key;
d574 6
d582 1
a582 1
	/* Try to parse a key with an xterm-style modifier. */
d589 2
d594 9
a602 5
first_key:
	/* Is this a meta key? */
	if (len >= 2 && buf[0] == '\033') {
		if (buf[1] != '\033') {
			key = buf[1] | KEYC_ESCAPE;
d606 1
a606 19

		tk = tty_keys_find(tty, buf + 1, len - 1, &size);
		if (tk != NULL && (!expired || tk->next == NULL)) {
			size++;	/* include escape */
			if (tk->next != NULL)
				goto partial_key;
			key = tk->key;
			if (key != KEYC_UNKNOWN)
				key |= KEYC_ESCAPE;
			goto complete_key;
		}
	}

	/* Is this valid UTF-8? */
	if ((more = utf8_open(&ud, (u_char)*buf) == UTF8_MORE)) {
		size = ud.size;
		if (len < size) {
			if (expired)
				goto discard_key;
a607 12
		}
		for (i = 1; i < size; i++)
			more = utf8_append(&ud, (u_char)buf[i]);
		if (more != UTF8_DONE)
			goto discard_key;

		if (utf8_combine(&ud, &wc) != UTF8_DONE)
			goto discard_key;
		key = wc;

		log_debug("UTF-8 key %.*s %#llx", (int)size, buf, key);
		goto complete_key;
d610 1
a610 1
	/* No key found, take first. */
d626 1
a626 1
	log_debug("partial key %.*s", (int) len, buf);
d688 1
a688 1
void
d703 1
a703 1
int
@


1.84
log
@I no longer use my SourceForge address so replace it.
@
text
@d1 1
a1 1
/* $OpenBSD: tty-keys.c,v 1.83 2015/12/12 18:19:00 nicm Exp $ */
d480 1
d556 5
a560 1
		key = utf8_combine(&ud);
@


1.83
log
@Allow prefix and prefix2 to be set to None to disable (useful if you
would rather bind the prefix in the root table).
@
text
@d1 1
a1 1
/* $OpenBSD: tty-keys.c,v 1.82 2015/11/23 20:53:09 nicm Exp $ */
d4 1
a4 1
 * Copyright (c) 2007 Nicholas Marriott <nicm@@users.sourceforge.net>
@


1.82
log
@Remove support for the UTF-8 mouse extension. This was a briefly used,
poor idea that was fairly quickly replaced by SGR mouse input (which is
now widespread). It is impossible to tell the difference between UTF-8
and non-UTF-8 mouse input; since the mouse-utf8 option was removed tmux
has not handled it correctly in any case; and it is ridiculous to have
three different forms of mouse input.
@
text
@d1 1
a1 1
/* $OpenBSD: tty-keys.c,v 1.81 2015/11/18 14:27:44 nicm Exp $ */
d347 1
a347 1
		tk->key = KEYC_NONE;
d447 1
a447 1
		if (len == 0 || (tk->next == NULL && tk->key != KEYC_NONE))
d537 1
a537 1
			if (key != KEYC_NONE)
d623 1
a623 1
	if (key != KEYC_NONE)
@


1.81
log
@Use __unused rather than rolling our own.
@
text
@d1 1
a1 1
/* $OpenBSD: tty-keys.c,v 1.80 2015/11/14 11:45:43 nicm Exp $ */
d484 1
d657 1
a657 2
	struct utf8_data	 ud;
	u_int			 i, value, x, y, b, sgr_b;
a658 1
	enum utf8_state		 more;
d688 2
a689 2
	 * Third byte is M in old standard and UTF-8 extension, < in SGR
	 * extension.
d697 1
a697 20

			if (tty->mode & MODE_MOUSE_UTF8) {
				if (utf8_open(&ud, buf[*size]) == UTF8_MORE) {
					if (ud.size != 2)
						return (-1);
					(*size)++;
					if (len <= *size)
						return (1);
					more = utf8_append(&ud, buf[*size]);
					if (more != UTF8_DONE)
						return (-1);
					value = utf8_combine(&ud);
				} else
					value = (u_char)buf[*size];
				(*size)++;
			} else {
				value = (u_char)buf[*size];
				(*size)++;
			}

d699 1
a699 1
				b = value;
d701 1
a701 1
				x = value;
d703 1
a703 1
				y = value;
@


1.80
log
@All these return values from utf8_* are confusing, use an enum.
@
text
@d1 1
a1 1
/* $OpenBSD: tty-keys.c,v 1.79 2015/11/14 10:57:59 nicm Exp $ */
d638 1
a638 1
tty_keys_callback(unused int fd, unused short events, void *data)
@


1.79
log
@Couple of assignments to remove compiler warnings.
@
text
@d1 1
a1 1
/* $OpenBSD: tty-keys.c,v 1.78 2015/11/14 10:56:31 nicm Exp $ */
d475 1
a475 1
	int			 delay, expired = 0, more;
d478 1
d543 1
a543 1
	if (utf8_open(&ud, (u_char)*buf)) {
a549 1
		more = 1;
d552 1
a552 1
		if (more != 0)
d659 1
a659 1
	int			 more;
d700 1
a700 1
				if (utf8_open(&ud, buf[*size])) {
d707 1
a707 1
					if (more != 0)
@


1.78
log
@Be more strict about invalid UTF-8.
@
text
@d1 1
a1 1
/* $OpenBSD: tty-keys.c,v 1.77 2015/11/12 22:04:37 nicm Exp $ */
d549 1
@


1.77
log
@Rename overly-long utf8data to ud throughout.
@
text
@d1 1
a1 1
/* $OpenBSD: tty-keys.c,v 1.76 2015/11/12 11:05:34 nicm Exp $ */
d475 1
a475 1
	int			 delay, expired = 0;
d550 3
a552 1
			utf8_append(&ud, (u_char)buf[i]);
d658 1
d705 3
a707 1
					utf8_append(&ud, buf[*size]);
@


1.76
log
@Support UTF-8 key bindings by expanding the key type from int to
uint64_t and converting UTF-8 to Unicode on input and the reverse on
output. (This allows key bindings, there are still omissions - the
largest being that the various prompts do not accept UTF-8.)
@
text
@d1 1
a1 1
/* $OpenBSD: tty-keys.c,v 1.75 2015/10/27 15:58:43 nicm Exp $ */
d477 1
a477 1
	struct utf8_data	 utf8data;
d542 2
a543 2
	if (utf8_open(&utf8data, (u_char)*buf)) {
		size = utf8data.size;
d550 2
a551 2
			utf8_append(&utf8data, (u_char)buf[i]);
		key = utf8_combine(&utf8data);
d653 1
a653 1
	struct utf8_data	 utf8data;
d696 2
a697 2
				if (utf8_open(&utf8data, buf[*size])) {
					if (utf8data.size != 2)
d702 2
a703 2
					utf8_append(&utf8data, buf[*size]);
					value = utf8_combine(&utf8data);
@


1.75
log
@Move struct options into options.c.
@
text
@d1 1
a1 1
/* $OpenBSD: tty-keys.c,v 1.74 2015/09/02 17:37:54 nicm Exp $ */
d36 2
a37 2
void		tty_keys_add1(struct tty_key **, const char *, int);
void		tty_keys_add(struct tty *, const char *, int);
d39 2
a40 2
struct tty_key *tty_keys_find1(
		    struct tty_key *, const char *, size_t, size_t *);
d48 1
a48 1
	int	 	 	key;
d168 1
a168 1
	int	 	 	key;
d320 1
a320 1
tty_keys_add(struct tty *tty, const char *s, int key)
d328 1
a328 1
		log_debug("new key %s: 0x%x (%s)", s, key, keystr);
d331 1
a331 1
		log_debug("replacing key %s: 0x%x (%s)", s, key, keystr);
d338 1
a338 1
tty_keys_add1(struct tty_key **tkp, const char *s, int key)
d467 1
a467 1
int
d470 9
a478 6
	struct tty_key	*tk;
	struct timeval	 tv;
	const char	*buf;
	size_t		 len, size;
	cc_t		 bspace;
	int		 key, delay, expired = 0;
d541 15
d557 1
a557 1
	key = (u_char) *buf;
d599 1
a599 1
	log_debug("complete key %.*s %#x", (int) size, buf, key);
d625 1
a625 1
	log_debug("discard key %.*s %#x", (int) size, buf, key);
d705 1
a705 1
					value = (u_char) buf[*size];
d708 1
a708 1
				value = (u_char) buf[*size];
@


1.74
log
@We no longer need the terminal service class, so don't bother asking for it.
@
text
@d1 1
a1 1
/* $OpenBSD: tty-keys.c,v 1.73 2015/06/05 15:10:13 nicm Exp $ */
d567 1
a567 1
	delay = options_get_number(&global_options, "escape-time");
@


1.73
log
@Do not use the key variable uninitialized (in a debug log statement),
reported by jungleboogie0 at gmail dot com.
@
text
@d1 1
a1 1
/* $OpenBSD: tty-keys.c,v 1.72 2015/04/19 21:34:21 nicm Exp $ */
a43 1
int		tty_keys_device(struct tty *, const char *, size_t, size_t *);
a483 11
	/* Is this device attributes response? */
	switch (tty_keys_device(tty, buf, len, &size)) {
	case 0:		/* yes */
		key = KEYC_NONE;
		goto complete_key;
	case -1:	/* no, or not valid */
		break;
	case 1:		/* partial */
		goto partial_key;
	}

a781 57

	return (0);
}

/*
 * Handle device attributes input. Returns 0 for success, -1 for failure, 1 for
 * partial.
 */
int
tty_keys_device(struct tty *tty, const char *buf, size_t len, size_t *size)
{
	u_int i, class;
	char  tmp[64], *endptr;

	/*
	 * Primary device attributes are \033[?a;b and secondary are
	 * \033[>a;b;c.
	 */

	*size = 0;

	/* First three bytes are always \033[?. */
	if (buf[0] != '\033')
		return (-1);
	if (len == 1)
		return (1);
	if (buf[1] != '[')
		return (-1);
	if (len == 2)
		return (1);
	if (buf[2] != '>' && buf[2] != '?')
		return (-1);
	if (len == 3)
		return (1);

	/* Copy the rest up to a 'c'. */
	for (i = 0; i < (sizeof tmp) - 1 && buf[3 + i] != 'c'; i++) {
		if (3 + i == len)
			return (1);
		tmp[i] = buf[3 + i];
	}
	if (i == (sizeof tmp) - 1)
		return (-1);
	tmp[i] = '\0';
	*size = 4 + i;

	/* Only primary is of interest. */
	if (buf[2] != '?')
		return (0);

	/* Convert service class. */
	class = strtoul(tmp, &endptr, 10);
	if (*endptr != ';')
		class = 0;

	log_debug("received service class %u", class);
	tty_set_class(tty, class);
@


1.72
log
@Rewrite of tmux mouse support which was a mess. Instead of having
options for "mouse-this" and "mouse-that", mouse events may be bound as
keys and there is one option "mouse" that turns on mouse support
entirely (set -g mouse on).

See the new MOUSE SUPPORT section of the man page for description of the
key names and new flags (-t= to specify the pane or window under mouse
as a target, and send-keys -M to pass through a mouse event).

The default builtin bindings for the mouse are:

    bind -n   MouseDown1Pane select-pane -t=; send-keys -M
    bind -n MouseDown1Status select-window -t=
    bind -n   MouseDrag1Pane copy-mode -M
    bind -n MouseDrag1Border resize-pane -M

To get the effect of turning mode-mouse off, do:

    unbind -n MouseDrag1Pane
    unbind -temacs-copy MouseDrag1Pane

The old mouse options are now gone, set-option -q may be used to
suppress warnings if mixing configuration files.
@
text
@d1 1
a1 1
/* $OpenBSD: tty-keys.c,v 1.71 2014/10/22 23:18:53 nicm Exp $ */
d504 1
@


1.71
log
@Fix some spacing nits.
@
text
@d1 1
a1 1
/* $OpenBSD: tty-keys.c,v 1.70 2014/07/21 10:25:48 nicm Exp $ */
d647 2
a648 2
	u_int			 i, value, x, y, b, sgr, sgr_b, sgr_rel;
	unsigned char		 c;
d664 2
a665 1
	x = y = b = sgr = sgr_b = sgr_rel = 0;
d712 1
a712 1
		log_debug("mouse input: %.*s", (int) *size, buf);
d752 1
a752 1
			c = (u_char) buf[(*size)++];
d759 1
a759 1
		log_debug("mouse input (sgr): %.*s", (int) *size, buf);
d766 6
a771 2
		sgr = 1;
		sgr_rel = (c == 'm');
d779 1
a779 1
		if (sgr_rel && (sgr_b & 64))
a780 5

		/* Figure out what b would be in old format. */
		b = sgr_b;
		if (sgr_rel)
			b |= 3;
d784 2
a785 9
	/* Fill in mouse structure. */
	if (~m->event & MOUSE_EVENT_WHEEL) {
		m->lx = m->x;
		m->ly = m->y;
	}
	m->xb = b;
	m->sgr = sgr;
	m->sgr_xb = sgr_b;
	m->sgr_rel = sgr_rel;
d787 1
d789 4
a792 37
	if (b & MOUSE_MASK_WHEEL) {
		if (b & MOUSE_MASK_SHIFT)
			m->scroll = 1;
		else
			m->scroll = MOUSE_WHEEL_SCALE;
		if (b & MOUSE_MASK_META)
			m->scroll *= MOUSE_WHEEL_SCALE;
		if (b & MOUSE_MASK_CTRL)
			m->scroll *= MOUSE_WHEEL_SCALE;

		b &= MOUSE_MASK_BUTTONS;
		if (b == 0)
			m->wheel = MOUSE_WHEEL_UP;
		else if (b == 1)
			m->wheel = MOUSE_WHEEL_DOWN;
		m->event = MOUSE_EVENT_WHEEL;

		m->button = 3;
	} else if ((b & MOUSE_MASK_BUTTONS) == 3) {
		if (~m->event & MOUSE_EVENT_DRAG && x == m->sx && y == m->sy) {
			m->event = MOUSE_EVENT_CLICK;
			m->clicks = (m->clicks + 1) % 3;
		} else
			m->event = MOUSE_EVENT_DRAG;
		m->event |= MOUSE_EVENT_UP;
	} else {
		if (b & MOUSE_MASK_DRAG)
			m->event = MOUSE_EVENT_DRAG;
		else {
			m->event = MOUSE_EVENT_DOWN;
			if (x != m->sx || y != m->sy)
				m->clicks = 0;
		}
		m->button = (b & MOUSE_MASK_BUTTONS);
	}
	m->sx = x;
	m->sy = y;
@


1.70
log
@Drop explicit support for F13-F20 and change to match the xterm terminfo
entry:

        F13-F24 are S-F1 to S-F12
        F25-F36 are C-F1 to C-F12
        F37-F48 are C-S-F1 to C-S-F12
        F49-F60 are M-F1 to M-F12
and     F61-F63 are M-S-F1 to M-S-F3

This should be no difference for applications inside tmux, but means
that any key binding for F13 will need to be replaced by S-F1 and so on.
@
text
@d1 1
a1 1
/* $OpenBSD: tty-keys.c,v 1.69 2014/06/23 09:52:56 nicm Exp $ */
d385 1
a385 1
		tty_keys_free (tty);
@


1.69
log
@Count mouse clicks correctly, from Balazs Kezes.
@
text
@d1 1
a1 1
/* $OpenBSD: tty-keys.c,v 1.68 2014/06/19 07:32:12 nicm Exp $ */
a115 8
	{ "\033[25^", KEYC_F13|KEYC_CTRL },
	{ "\033[26^", KEYC_F14|KEYC_CTRL },
	{ "\033[28^", KEYC_F15|KEYC_CTRL },
	{ "\033[29^", KEYC_F16|KEYC_CTRL },
	{ "\033[31^", KEYC_F17|KEYC_CTRL },
	{ "\033[32^", KEYC_F18|KEYC_CTRL },
	{ "\033[33^", KEYC_F19|KEYC_CTRL },
	{ "\033[34^", KEYC_F20|KEYC_CTRL },
a134 8
	{ "\033[25$", KEYC_F13|KEYC_SHIFT },
	{ "\033[26$", KEYC_F14|KEYC_SHIFT },
	{ "\033[28$", KEYC_F15|KEYC_SHIFT },
	{ "\033[29$", KEYC_F16|KEYC_SHIFT },
	{ "\033[31$", KEYC_F17|KEYC_SHIFT },
	{ "\033[32$", KEYC_F18|KEYC_SHIFT },
	{ "\033[33$", KEYC_F19|KEYC_SHIFT },
	{ "\033[34$", KEYC_F20|KEYC_SHIFT },
a153 8
	{ "\033[25@@", KEYC_F13|KEYC_CTRL|KEYC_SHIFT },
	{ "\033[26@@", KEYC_F14|KEYC_CTRL|KEYC_SHIFT },
	{ "\033[28@@", KEYC_F15|KEYC_CTRL|KEYC_SHIFT },
	{ "\033[29@@", KEYC_F16|KEYC_CTRL|KEYC_SHIFT },
	{ "\033[31@@", KEYC_F17|KEYC_CTRL|KEYC_SHIFT },
	{ "\033[32@@", KEYC_F18|KEYC_CTRL|KEYC_SHIFT },
	{ "\033[33@@", KEYC_F19|KEYC_CTRL|KEYC_SHIFT },
	{ "\033[34@@", KEYC_F20|KEYC_CTRL|KEYC_SHIFT },
d185 57
a241 8
	{ TTYC_KF13, KEYC_F13 },
	{ TTYC_KF14, KEYC_F14 },
	{ TTYC_KF15, KEYC_F15 },
	{ TTYC_KF16, KEYC_F16 },
	{ TTYC_KF17, KEYC_F17 },
	{ TTYC_KF18, KEYC_F18 },
	{ TTYC_KF19, KEYC_F19 },
	{ TTYC_KF20, KEYC_F20 },
@


1.68
log
@Reset the buttons when the wheel is used, from Balazs Kezes.
@
text
@d1 1
a1 1
/* $OpenBSD: tty-keys.c,v 1.67 2014/06/19 07:26:43 nicm Exp $ */
d789 1
a789 1
		if (~m->event & MOUSE_EVENT_DRAG && x == m->x && y == m->y)
d791 2
a792 1
		else
d799 2
a800 3
			if (m->event & MOUSE_EVENT_UP && x == m->x && y == m->y)
				m->clicks = (m->clicks + 1) % 3;
			else
a801 3
			m->sx = x;
			m->sy = y;
			m->event = MOUSE_EVENT_DOWN;
d805 2
@


1.67
log
@Some terminals send spurious releases for mouse wheel in SGR mouse mode,
this causes confusion when tmux uses SGR outside but the application
inside tmux is using conventional xterm mouse reporting. So suppress
obviously bad input. From Timothy Allen, SF bug 128.
@
text
@d1 1
a1 1
/* $OpenBSD: tty-keys.c,v 1.66 2014/05/08 07:54:47 nicm Exp $ */
d786 2
@


1.66
log
@Instead of forcing mouse scroll to 1 in choose mode, scale it down
instead. Means modifier keys still increase the line count, just not as
much. Based on a diff from Marcel Partap.
@
text
@d1 1
a1 1
/* $OpenBSD: tty-keys.c,v 1.65 2014/04/03 08:20:29 nicm Exp $ */
d478 2
d591 8
d742 9
@


1.65
log
@Work out mouse scroll wheel effect when the mouse is first detected and
store it in struct mouse_event, reduce the scroll size the 3 but allow
shift to reduce it to 1 and meta and ctrl to multiply by 3 if the
terminal supports them, also support wheel in choose mode. From Marcel
Partap.
@
text
@d1 1
a1 1
/* $OpenBSD: tty-keys.c,v 1.64 2014/04/03 08:15:17 nicm Exp $ */
d755 1
a755 1
			m->scroll = 3;
d757 1
a757 1
			m->scroll *= 3;
d759 1
a759 1
			m->scroll *= 3;
@


1.64
log
@A couple of trivial mouse-related style nits.
@
text
@d1 1
a1 1
/* $OpenBSD: tty-keys.c,v 1.63 2014/03/31 21:40:21 nicm Exp $ */
d752 9
@


1.63
log
@Add names for mouse button bits rather than using magic numbers, from
Marcel Partap.
@
text
@d1 1
a1 1
/* $OpenBSD: tty-keys.c,v 1.62 2014/02/10 11:20:41 nicm Exp $ */
d759 1
a759 1
		if (~m->event & MOUSE_EVENT_DRAG && x == m->x && y == m->y) {
d761 1
a761 1
		} else
@


1.62
log
@The last fix to xterm keys meant that some keys such as \033OA were
being wrongly treated as partial matches. So both check xterm keys after
standard keys and only wildcard the minimum required ('1' to
'8'). Problems reported by Ralf Horstmann and Tim van der Molen.
@
text
@d1 1
a1 1
/* $OpenBSD: tty-keys.c,v 1.61 2013/10/10 11:57:52 nicm Exp $ */
d751 2
a752 2
	if (b & 64) { /* wheel button */
		b &= 3;
d758 1
a758 1
	} else if ((b & 3) == 3) {
d765 1
a765 1
		if (b & 32) /* drag motion */
d776 1
a776 1
		m->button = (b & 3);
@


1.61
log
@Assign mouse x/y coords before checking them. When receiving mouse
inputs, we should set the x/y coordinates earlier than we currently do,
so that we aren't off-by-one in the case when the statusbar is at the
top of the screen. By Thomas Adam.
@
text
@d1 1
a1 1
/* $OpenBSD: tty-keys.c,v 1.60 2013/10/10 11:49:42 nicm Exp $ */
d482 9
a498 9
	}

	/* Look for matching key string and return if found. */
	tk = tty_keys_find(tty, buf, len, &size);
	if (tk != NULL) {
		if (tk->next != NULL)
			goto partial_key;
		key = tk->key;
		goto complete_key;
@


1.60
log
@Handle input mouse positions <33 (we already can generate them).
@
text
@d1 1
a1 1
/* $OpenBSD: tty-keys.c,v 1.59 2013/03/26 14:14:08 nicm Exp $ */
d749 2
a777 2
	m->x = x;
	m->y = y;
@


1.59
log
@Only accept partial keys if the timer has not expired, fixes infinite
loop when Escape is pressed the wrong number of times.
@
text
@d1 1
a1 1
/* $OpenBSD: tty-keys.c,v 1.58 2013/03/25 11:44:16 nicm Exp $ */
d679 1
a679 1
		if (b < 32 || x < 33 || y < 33)
d682 8
a689 2
		x -= 33;
		y -= 33;
@


1.58
log
@Process ^[ as meta when a partial key is found.
@
text
@d1 1
a1 1
/* $OpenBSD: tty-keys.c,v 1.57 2013/03/25 11:36:25 nicm Exp $ */
d451 1
a451 1
	int		 key, delay;
d511 1
a511 1
		if (tk != NULL) {
d543 2
a544 1
		    !evtimer_pending(&tty->key_timer, NULL))
d546 1
@


1.57
log
@Add home and end as modified by xterm in keypad mode, from Chris
Johnsen.
@
text
@d1 1
a1 1
/* $OpenBSD: tty-keys.c,v 1.56 2013/03/24 09:28:59 nicm Exp $ */
d501 1
a521 1
first_key:
@


1.56
log
@Handle focus events from the terminal, from Aaron Jensen.
@
text
@d1 1
a1 1
/* $OpenBSD: tty-keys.c,v 1.55 2013/03/22 10:33:50 nicm Exp $ */
d84 7
@


1.55
log
@Support the latest theory for mouse input, this is enabled/disabled with
SM/RM 1006 and is similar in style to SGR input: \033[<b;x;yM or
\033[b;x;ym. From Egmont Koblinger.
@
text
@d1 1
a1 1
/* $OpenBSD: tty-keys.c,v 1.54 2013/03/22 10:31:22 nicm Exp $ */
d177 4
d565 9
@


1.54
log
@No more lint means no more ARGSUSED.
@
text
@d1 1
a1 1
/* $OpenBSD: tty-keys.c,v 1.53 2013/03/22 10:30:34 nicm Exp $ */
d590 2
a591 1
	u_int			 i, value, x, y, b;
d595 1
a595 1
	 * indicating buttons, X and Y, all based at 32 with 1,1 top-left.
d599 5
d607 1
a607 1
	x = y = b  = 0;
d609 1
a609 1
	/* First three bytes are always \033[M. */
a617 4
	if (buf[2] != 'M')
		return (-1);
	if (len == 3)
		return (1);
d619 25
a643 10
	/* Read the three inputs. */
	*size = 3;
	for (i = 0; i < 3; i++) {
		if (len < *size)
			return (1);

		if (tty->mode & MODE_MOUSE_UTF8) {
			if (utf8_open(&utf8data, buf[*size])) {
				if (utf8data.size != 2)
					return (-1);
d645 8
a652 10
				if (len < *size)
					return (1);
				utf8_append(&utf8data, buf[*size]);
				value = utf8_combine(&utf8data);
			} else
				value = (unsigned char)buf[*size];
			(*size)++;
		} else {
			value = (unsigned char)buf[*size];
			(*size)++;
d654 1
d656 40
a695 8
		if (i == 0)
			b = value;
		else if (i == 1)
			x = value;
		else
			y = value;
	}
	log_debug("mouse input: %.*s", (int) *size, buf);
d697 13
a709 2
	/* Check and return the mouse input. */
	if (b < 32 || x < 33 || y < 33)
a710 4
	b -= 32;
	x -= 33;
	y -= 33;
	log_debug("mouse position: x=%u y=%u b=%u", x, y, b);
d718 3
@


1.53
log
@Remove stray test code which would convert abc to x.
@
text
@d1 1
a1 1
/* $OpenBSD: tty-keys.c,v 1.52 2013/03/21 18:45:38 nicm Exp $ */
a569 1
/* ARGSUSED */
@


1.52
log
@Don't set key KEYC_NONE on xterm_keys_find match()

When calling xterm_keys_find(); if we get a complete match, don't set
the key to unknown before calling the action to complete the binding;
otherwise non-prefixed bindings will not work.

From Thomas Adam
@
text
@d1 1
a1 1
/* $OpenBSD: tty-keys.c,v 1.51 2013/03/21 18:44:47 nicm Exp $ */
a366 2

	tty_keys_add(tty, "abc", 'x');
@


1.51
log
@Include the \033 in the key tree and adjust key matching for this change.
@
text
@d1 1
a1 1
/* $OpenBSD: tty-keys.c,v 1.50 2013/03/21 16:52:02 nicm Exp $ */
a475 1
		key = KEYC_NONE;
@


1.50
log
@Fix a comment for new key table names.
@
text
@d1 1
a1 1
/* $OpenBSD: tty-keys.c,v 1.49 2013/03/21 16:51:11 nicm Exp $ */
d356 2
a357 2
		if (s[0] == '\033' && s[1] != '\0')
			tty_keys_add(tty, s + 1, tdkr->key);
d363 2
a364 2
		if (s[0] == '\033' || s[1] == '\0')
			tty_keys_add(tty, s + 1, tdkc->key);
d367 2
d444 1
a450 16
	/* If a normal key, return it. */
	if (*buf != '\033') {
		key = (u_char) *buf;
		evbuffer_drain(tty->event->input, 1);

		/*
		 * Check for backspace key using termios VERASE - the terminfo
		 * kbs entry is extremely unreliable, so cannot be safely
		 * used. termios should have a better idea.
		 */
		bspace = tty->tio.c_cc[VERASE];
		if (bspace != _POSIX_VDISABLE && key == bspace)
			key = KEYC_BSPACE;
		goto handle_key;
	}

a453 1
		evbuffer_drain(tty->event->input, size);
d455 1
a455 1
		goto handle_key;
a464 1
		evbuffer_drain(tty->event->input, size);
d466 1
a466 1
		goto handle_key;
d476 2
a477 2
		evbuffer_drain(tty->event->input, size);
		goto handle_key;
d485 1
a485 1
	tk = tty_keys_find(tty, buf + 1, len - 1, &size);
d487 2
d490 1
a490 1
		goto found_key;
d493 7
a499 10
	/* Skip the escape. */
	buf++;
	len--;

	/* Is there a normal key following? */
	if (len != 0 && *buf != '\033') {
		key = *buf | KEYC_ESCAPE;
		evbuffer_drain(tty->event->input, 2);
		goto handle_key;
	}
a500 2
	/* Or a key string? */
	if (len > 1) {
a502 1
			key = tk->key | KEYC_ESCAPE;
d504 6
a509 1
			goto found_key;
d513 4
a516 1
	/* Escape and then nothing useful - fall through. */
a517 1
partial_key:
d519 3
a521 2
	 * Escape but no key string. If have already seen an escape and the
	 * timer has expired, give up waiting and send the escape.
d523 8
a530 7
	if ((tty->flags & TTY_ESCAPE) &&
	    evtimer_initialized(&tty->key_timer) &&
	    !evtimer_pending(&tty->key_timer, NULL)) {
		evbuffer_drain(tty->event->input, 1);
		key = '\033';
		goto handle_key;
	}
d532 5
a536 6
	/* Fall through to start the timer. */

start_timer:
	/* If already waiting for timer, do nothing. */
	if (evtimer_initialized(&tty->key_timer) &&
	    evtimer_pending(&tty->key_timer, NULL))
d538 1
d540 1
a540 1
	/* Start the timer and wait for expiry or more data. */
d545 1
d551 1
a551 1
	tty->flags |= TTY_ESCAPE;
d554 2
a555 13
found_key:
	if (tk->next != NULL) {
		/* Partial key. Start the timer if not already expired. */
		if (!(tty->flags & TTY_ESCAPE))
			goto start_timer;

		/* Otherwise, if no key, send the escape alone. */
		if (tk->key == KEYC_NONE)
			goto partial_key;

		/* Or fall through to send the partial key found. */
	}
	evbuffer_drain(tty->event->input, size + 1);
d557 2
a558 1
	goto handle_key;
d560 1
a560 1
handle_key:
d563 1
d565 1
a568 1
	tty->flags &= ~TTY_ESCAPE;
d579 4
a582 5
	if (!(tty->flags & TTY_ESCAPE))
		return;

	while (tty_keys_next(tty))
		;
@


1.49
log
@Fix function parameter to tty_keys_free.
@
text
@d1 1
a1 1
/* $OpenBSD: tty-keys.c,v 1.48 2013/03/21 16:50:22 nicm Exp $ */
d31 3
a33 3
 * Handle keys input from the outside terminal. tty_keys[] is a base table of
 * supported keys which are looked up in terminfo(5) and translated into a
 * ternary tree (a binary tree of binary trees).
@


1.48
log
@Tidy by splitting default key tables into two.
@
text
@d1 1
a1 1
/* $OpenBSD: tty-keys.c,v 1.47 2012/11/22 14:41:11 nicm Exp $ */
d349 1
a349 1
		tty_keys_free (tty->key_tree);
@


1.47
log
@Put helper function back, will be needed in a bit.
@
text
@d1 1
a1 1
/* $OpenBSD: tty-keys.c,v 1.46 2012/11/22 14:26:04 nicm Exp $ */
d46 2
a47 2
struct tty_key_ent {
	enum tty_code_code	code;
a48 1

a49 2
	int		 	flags;
#define TTYKEY_RAW 0x1
d51 1
a51 6

/*
 * Default key tables. Those flagged with TTYKEY_RAW are inserted directly,
 * otherwise they are looked up in terminfo(5).
 */
const struct tty_key_ent tty_keys[] = {
d57 16
a72 16
	{ 0,	"\033Oo",	KEYC_KP_SLASH,		TTYKEY_RAW },
	{ 0,	"\033Oj",	KEYC_KP_STAR,		TTYKEY_RAW },
	{ 0,	"\033Om",	KEYC_KP_MINUS,		TTYKEY_RAW },
	{ 0,	"\033Ow",	KEYC_KP_SEVEN,		TTYKEY_RAW },
	{ 0,	"\033Ox",	KEYC_KP_EIGHT,		TTYKEY_RAW },
	{ 0,	"\033Oy",	KEYC_KP_NINE,		TTYKEY_RAW },
	{ 0,	"\033Ok",	KEYC_KP_PLUS,		TTYKEY_RAW },
	{ 0,	"\033Ot",	KEYC_KP_FOUR,		TTYKEY_RAW },
	{ 0,	"\033Ou",	KEYC_KP_FIVE,		TTYKEY_RAW },
	{ 0,	"\033Ov",	KEYC_KP_SIX,		TTYKEY_RAW },
	{ 0,	"\033Oq",	KEYC_KP_ONE,		TTYKEY_RAW },
	{ 0,	"\033Or",	KEYC_KP_TWO,		TTYKEY_RAW },
	{ 0,	"\033Os",	KEYC_KP_THREE,		TTYKEY_RAW },
	{ 0,	"\033OM",	KEYC_KP_ENTER,		TTYKEY_RAW },
	{ 0,	"\033Op",	KEYC_KP_ZERO,		TTYKEY_RAW },
	{ 0,	"\033On",	KEYC_KP_PERIOD,		TTYKEY_RAW },
d75 9
a83 9
	{ 0,	"\033OA",	KEYC_UP,		TTYKEY_RAW },
	{ 0,	"\033OB",	KEYC_DOWN,		TTYKEY_RAW },
	{ 0,	"\033OC",	KEYC_RIGHT,		TTYKEY_RAW },
	{ 0,	"\033OD",	KEYC_LEFT,		TTYKEY_RAW },

	{ 0,	"\033[A",	KEYC_UP,		TTYKEY_RAW },
	{ 0,	"\033[B",	KEYC_DOWN,		TTYKEY_RAW },
	{ 0,	"\033[C",	KEYC_RIGHT,		TTYKEY_RAW },
	{ 0,	"\033[D",	KEYC_LEFT,		TTYKEY_RAW },
d86 92
a177 96
	{ 0,	"\033Oa",	KEYC_UP|KEYC_CTRL,	TTYKEY_RAW },
	{ 0,	"\033Ob",	KEYC_DOWN|KEYC_CTRL,	TTYKEY_RAW },
	{ 0,	"\033Oc",	KEYC_RIGHT|KEYC_CTRL,	TTYKEY_RAW },
	{ 0,	"\033Od",	KEYC_LEFT|KEYC_CTRL,	TTYKEY_RAW },

	{ 0,	"\033[a",	KEYC_UP|KEYC_SHIFT,	TTYKEY_RAW },
	{ 0,	"\033[b",	KEYC_DOWN|KEYC_SHIFT,	TTYKEY_RAW },
	{ 0,	"\033[c",	KEYC_RIGHT|KEYC_SHIFT,	TTYKEY_RAW },
	{ 0,	"\033[d",	KEYC_LEFT|KEYC_SHIFT,	TTYKEY_RAW },

	/*
	 * rxvt-style function + modifier keys:
	 *		Ctrl = ^, Shift = $, Ctrl+Shift = @@
	 */
	{ 0,	"\033[11^",	KEYC_F1|KEYC_CTRL,	TTYKEY_RAW },
	{ 0,	"\033[12^",	KEYC_F2|KEYC_CTRL,	TTYKEY_RAW },
	{ 0,	"\033[13^",	KEYC_F3|KEYC_CTRL,	TTYKEY_RAW },
	{ 0,	"\033[14^",	KEYC_F4|KEYC_CTRL,	TTYKEY_RAW },
	{ 0,	"\033[15^",	KEYC_F5|KEYC_CTRL,	TTYKEY_RAW },
	{ 0,	"\033[17^",	KEYC_F6|KEYC_CTRL,	TTYKEY_RAW },
	{ 0,	"\033[18^",	KEYC_F7|KEYC_CTRL,	TTYKEY_RAW },
	{ 0,	"\033[19^",	KEYC_F8|KEYC_CTRL,	TTYKEY_RAW },
	{ 0,	"\033[20^",	KEYC_F9|KEYC_CTRL,	TTYKEY_RAW },
	{ 0,	"\033[21^",	KEYC_F10|KEYC_CTRL,	TTYKEY_RAW },
	{ 0,	"\033[23^",	KEYC_F11|KEYC_CTRL,	TTYKEY_RAW },
	{ 0,	"\033[24^",	KEYC_F12|KEYC_CTRL,	TTYKEY_RAW },
	{ 0,	"\033[25^",	KEYC_F13|KEYC_CTRL,	TTYKEY_RAW },
	{ 0,	"\033[26^",	KEYC_F14|KEYC_CTRL,	TTYKEY_RAW },
	{ 0,	"\033[28^",	KEYC_F15|KEYC_CTRL,	TTYKEY_RAW },
	{ 0,	"\033[29^",	KEYC_F16|KEYC_CTRL,	TTYKEY_RAW },
	{ 0,	"\033[31^",	KEYC_F17|KEYC_CTRL,	TTYKEY_RAW },
	{ 0,	"\033[32^",	KEYC_F18|KEYC_CTRL,	TTYKEY_RAW },
	{ 0,	"\033[33^",	KEYC_F19|KEYC_CTRL,	TTYKEY_RAW },
	{ 0,	"\033[34^",	KEYC_F20|KEYC_CTRL,	TTYKEY_RAW },
	{ 0,	"\033[2^",	KEYC_IC|KEYC_CTRL,	TTYKEY_RAW },
	{ 0,	"\033[3^",	KEYC_DC|KEYC_CTRL,	TTYKEY_RAW },
	{ 0,	"\033[7^",	KEYC_HOME|KEYC_CTRL,	TTYKEY_RAW },
	{ 0,	"\033[8^",	KEYC_END|KEYC_CTRL,	TTYKEY_RAW },
	{ 0,	"\033[6^",	KEYC_NPAGE|KEYC_CTRL,	TTYKEY_RAW },
	{ 0,	"\033[5^",	KEYC_PPAGE|KEYC_CTRL,	TTYKEY_RAW },

	{ 0,	"\033[11$",	KEYC_F1|KEYC_SHIFT,	TTYKEY_RAW },
	{ 0,	"\033[12$",	KEYC_F2|KEYC_SHIFT,	TTYKEY_RAW },
	{ 0,	"\033[13$",	KEYC_F3|KEYC_SHIFT,	TTYKEY_RAW },
	{ 0,	"\033[14$",	KEYC_F4|KEYC_SHIFT,	TTYKEY_RAW },
	{ 0,	"\033[15$",	KEYC_F5|KEYC_SHIFT,	TTYKEY_RAW },
	{ 0,	"\033[17$",	KEYC_F6|KEYC_SHIFT,	TTYKEY_RAW },
	{ 0,	"\033[18$",	KEYC_F7|KEYC_SHIFT,	TTYKEY_RAW },
	{ 0,	"\033[19$",	KEYC_F8|KEYC_SHIFT,	TTYKEY_RAW },
	{ 0,	"\033[20$",	KEYC_F9|KEYC_SHIFT,	TTYKEY_RAW },
	{ 0,	"\033[21$",	KEYC_F10|KEYC_SHIFT,	TTYKEY_RAW },
	{ 0,	"\033[23$",	KEYC_F11|KEYC_SHIFT,	TTYKEY_RAW },
	{ 0,	"\033[24$",	KEYC_F12|KEYC_SHIFT,	TTYKEY_RAW },
	{ 0,	"\033[25$",	KEYC_F13|KEYC_SHIFT,	TTYKEY_RAW },
	{ 0,	"\033[26$",	KEYC_F14|KEYC_SHIFT,	TTYKEY_RAW },
	{ 0,	"\033[28$",	KEYC_F15|KEYC_SHIFT,	TTYKEY_RAW },
	{ 0,	"\033[29$",	KEYC_F16|KEYC_SHIFT,	TTYKEY_RAW },
	{ 0,	"\033[31$",	KEYC_F17|KEYC_SHIFT,	TTYKEY_RAW },
	{ 0,	"\033[32$",	KEYC_F18|KEYC_SHIFT,	TTYKEY_RAW },
	{ 0,	"\033[33$",	KEYC_F19|KEYC_SHIFT,	TTYKEY_RAW },
	{ 0,	"\033[34$",	KEYC_F20|KEYC_SHIFT,	TTYKEY_RAW },
	{ 0,	"\033[2$",	KEYC_IC|KEYC_SHIFT,	TTYKEY_RAW },
	{ 0,	"\033[3$",	KEYC_DC|KEYC_SHIFT,	TTYKEY_RAW },
	{ 0,	"\033[7$",	KEYC_HOME|KEYC_SHIFT,	TTYKEY_RAW },
	{ 0,	"\033[8$",	KEYC_END|KEYC_SHIFT,	TTYKEY_RAW },
	{ 0,	"\033[6$",	KEYC_NPAGE|KEYC_SHIFT,	TTYKEY_RAW },
	{ 0,	"\033[5$",	KEYC_PPAGE|KEYC_SHIFT,	TTYKEY_RAW },

	{ 0,	"\033[11@@",	KEYC_F1|KEYC_CTRL|KEYC_SHIFT,	TTYKEY_RAW },
	{ 0,	"\033[12@@",	KEYC_F2|KEYC_CTRL|KEYC_SHIFT,	TTYKEY_RAW },
	{ 0,	"\033[13@@",	KEYC_F3|KEYC_CTRL|KEYC_SHIFT,	TTYKEY_RAW },
	{ 0,	"\033[14@@",	KEYC_F4|KEYC_CTRL|KEYC_SHIFT,	TTYKEY_RAW },
	{ 0,	"\033[15@@",	KEYC_F5|KEYC_CTRL|KEYC_SHIFT,	TTYKEY_RAW },
	{ 0,	"\033[17@@",	KEYC_F6|KEYC_CTRL|KEYC_SHIFT,	TTYKEY_RAW },
	{ 0,	"\033[18@@",	KEYC_F7|KEYC_CTRL|KEYC_SHIFT,	TTYKEY_RAW },
	{ 0,	"\033[19@@",	KEYC_F8|KEYC_CTRL|KEYC_SHIFT,	TTYKEY_RAW },
	{ 0,	"\033[20@@",	KEYC_F9|KEYC_CTRL|KEYC_SHIFT,	TTYKEY_RAW },
	{ 0,	"\033[21@@",	KEYC_F10|KEYC_CTRL|KEYC_SHIFT,	TTYKEY_RAW },
	{ 0,	"\033[23@@",	KEYC_F11|KEYC_CTRL|KEYC_SHIFT,	TTYKEY_RAW },
	{ 0,	"\033[24@@",	KEYC_F12|KEYC_CTRL|KEYC_SHIFT,	TTYKEY_RAW },
	{ 0,	"\033[25@@",	KEYC_F13|KEYC_CTRL|KEYC_SHIFT,	TTYKEY_RAW },
	{ 0,	"\033[26@@",	KEYC_F14|KEYC_CTRL|KEYC_SHIFT,	TTYKEY_RAW },
	{ 0,	"\033[28@@",	KEYC_F15|KEYC_CTRL|KEYC_SHIFT,	TTYKEY_RAW },
	{ 0,	"\033[29@@",	KEYC_F16|KEYC_CTRL|KEYC_SHIFT,	TTYKEY_RAW },
	{ 0,	"\033[31@@",	KEYC_F17|KEYC_CTRL|KEYC_SHIFT,	TTYKEY_RAW },
	{ 0,	"\033[32@@",	KEYC_F18|KEYC_CTRL|KEYC_SHIFT,	TTYKEY_RAW },
	{ 0,	"\033[33@@",	KEYC_F19|KEYC_CTRL|KEYC_SHIFT,	TTYKEY_RAW },
	{ 0,	"\033[34@@",	KEYC_F20|KEYC_CTRL|KEYC_SHIFT,	TTYKEY_RAW },
	{ 0,	"\033[2@@",	KEYC_IC|KEYC_CTRL|KEYC_SHIFT,	TTYKEY_RAW },
	{ 0,	"\033[3@@",	KEYC_DC|KEYC_CTRL|KEYC_SHIFT,	TTYKEY_RAW },
	{ 0,	"\033[7@@",	KEYC_HOME|KEYC_CTRL|KEYC_SHIFT,	TTYKEY_RAW },
	{ 0,	"\033[8@@",	KEYC_END|KEYC_CTRL|KEYC_SHIFT,	TTYKEY_RAW },
	{ 0,	"\033[6@@",	KEYC_NPAGE|KEYC_CTRL|KEYC_SHIFT,TTYKEY_RAW },
	{ 0,	"\033[5@@",	KEYC_PPAGE|KEYC_CTRL|KEYC_SHIFT,TTYKEY_RAW },

	/* terminfo lookups below this line so they can override raw keys. */
d179 6
d186 27
a212 27
	{ TTYC_KF1,	NULL,		KEYC_F1,		0 },
	{ TTYC_KF2,	NULL,		KEYC_F2,		0 },
	{ TTYC_KF3,	NULL,		KEYC_F3,		0 },
	{ TTYC_KF4,	NULL,		KEYC_F4,		0 },
	{ TTYC_KF5,	NULL,		KEYC_F5,		0 },
	{ TTYC_KF6,	NULL,		KEYC_F6,		0 },
	{ TTYC_KF7,	NULL,		KEYC_F7,		0 },
	{ TTYC_KF8,	NULL,		KEYC_F8,		0 },
	{ TTYC_KF9,	NULL,		KEYC_F9,		0 },
	{ TTYC_KF10,	NULL,		KEYC_F10,		0 },
	{ TTYC_KF11,	NULL,		KEYC_F11,		0 },
	{ TTYC_KF12,	NULL,		KEYC_F12,		0 },
	{ TTYC_KF13,	NULL,		KEYC_F13,		0 },
	{ TTYC_KF14,	NULL,		KEYC_F14,		0 },
	{ TTYC_KF15,	NULL,		KEYC_F15,		0 },
	{ TTYC_KF16,	NULL,		KEYC_F16,		0 },
	{ TTYC_KF17,	NULL,		KEYC_F17,		0 },
	{ TTYC_KF18,	NULL,		KEYC_F18,		0 },
	{ TTYC_KF19,	NULL,		KEYC_F19,		0 },
	{ TTYC_KF20,	NULL,		KEYC_F20,		0 },
	{ TTYC_KICH1,	NULL,		KEYC_IC,		0 },
	{ TTYC_KDCH1,	NULL,		KEYC_DC,		0 },
	{ TTYC_KHOME,	NULL,		KEYC_HOME,		0 },
	{ TTYC_KEND,	NULL,		KEYC_END,		0 },
	{ TTYC_KNP,	NULL,		KEYC_NPAGE,		0 },
	{ TTYC_KPP,	NULL,		KEYC_PPAGE,		0 },
	{ TTYC_KCBT,	NULL,		KEYC_BTAB,		0 },
d215 4
a218 4
	{ TTYC_KCUU1,	NULL,		KEYC_UP,		0 },
	{ TTYC_KCUD1,	NULL,		KEYC_DOWN,		0 },
	{ TTYC_KCUB1,	NULL,		KEYC_LEFT,		0 },
	{ TTYC_KCUF1,	NULL,		KEYC_RIGHT,		0 },
d221 60
a280 60
	{ TTYC_KDC2,	NULL,		KEYC_DC|KEYC_SHIFT,	0 },
	{ TTYC_KDC3,	NULL,		KEYC_DC|KEYC_ESCAPE,	0 },
	{ TTYC_KDC4,	NULL,		KEYC_DC|KEYC_SHIFT|KEYC_ESCAPE, 0 },
	{ TTYC_KDC5,	NULL,		KEYC_DC|KEYC_CTRL,	0 },
	{ TTYC_KDC6,	NULL,		KEYC_DC|KEYC_SHIFT|KEYC_CTRL, 0 },
	{ TTYC_KDC7,	NULL,		KEYC_DC|KEYC_ESCAPE|KEYC_CTRL, 0 },
	{ TTYC_KDN2,	NULL,		KEYC_DOWN|KEYC_SHIFT,	0 },
	{ TTYC_KDN3,	NULL,		KEYC_DOWN|KEYC_ESCAPE,	0 },
	{ TTYC_KDN4,	NULL,		KEYC_DOWN|KEYC_SHIFT|KEYC_ESCAPE, 0 },
	{ TTYC_KDN5,	NULL,		KEYC_DOWN|KEYC_CTRL,	0 },
	{ TTYC_KDN6,	NULL,		KEYC_DOWN|KEYC_SHIFT|KEYC_CTRL, 0 },
	{ TTYC_KDN7,	NULL,		KEYC_DOWN|KEYC_ESCAPE|KEYC_CTRL, 0 },
	{ TTYC_KEND2,	NULL,		KEYC_END|KEYC_SHIFT,	0 },
	{ TTYC_KEND3,	NULL,		KEYC_END|KEYC_ESCAPE,	0 },
	{ TTYC_KEND4,	NULL,		KEYC_END|KEYC_SHIFT|KEYC_ESCAPE, 0 },
	{ TTYC_KEND5,	NULL,		KEYC_END|KEYC_CTRL,	0 },
	{ TTYC_KEND6,	NULL,		KEYC_END|KEYC_SHIFT|KEYC_CTRL, 0 },
	{ TTYC_KEND7,	NULL,		KEYC_END|KEYC_ESCAPE|KEYC_CTRL, 0 },
	{ TTYC_KHOM2,	NULL,		KEYC_HOME|KEYC_SHIFT,	0 },
	{ TTYC_KHOM3,	NULL,		KEYC_HOME|KEYC_ESCAPE,	0 },
	{ TTYC_KHOM4,	NULL,		KEYC_HOME|KEYC_SHIFT|KEYC_ESCAPE, 0 },
	{ TTYC_KHOM5,	NULL,		KEYC_HOME|KEYC_CTRL,	0 },
	{ TTYC_KHOM6,	NULL,		KEYC_HOME|KEYC_SHIFT|KEYC_CTRL, 0 },
	{ TTYC_KHOM7,	NULL,		KEYC_HOME|KEYC_ESCAPE|KEYC_CTRL, 0 },
	{ TTYC_KIC2,	NULL,		KEYC_IC|KEYC_SHIFT,	0 },
	{ TTYC_KIC3,	NULL,		KEYC_IC|KEYC_ESCAPE,	0 },
	{ TTYC_KIC4,	NULL,		KEYC_IC|KEYC_SHIFT|KEYC_ESCAPE,	0 },
	{ TTYC_KIC5,	NULL,		KEYC_IC|KEYC_CTRL,	0 },
	{ TTYC_KIC6,	NULL,		KEYC_IC|KEYC_SHIFT|KEYC_CTRL, 0 },
	{ TTYC_KIC7,	NULL,		KEYC_IC|KEYC_ESCAPE|KEYC_CTRL, 0 },
	{ TTYC_KLFT2,	NULL,		KEYC_LEFT|KEYC_SHIFT,	0 },
	{ TTYC_KLFT3,	NULL,		KEYC_LEFT|KEYC_ESCAPE,	0 },
	{ TTYC_KLFT4,	NULL,		KEYC_LEFT|KEYC_SHIFT|KEYC_ESCAPE, 0 },
	{ TTYC_KLFT5,	NULL,		KEYC_LEFT|KEYC_CTRL,	0 },
	{ TTYC_KLFT6,	NULL,		KEYC_LEFT|KEYC_SHIFT|KEYC_CTRL, 0 },
	{ TTYC_KLFT7,	NULL,		KEYC_LEFT|KEYC_ESCAPE|KEYC_CTRL, 0 },
	{ TTYC_KNXT2,	NULL,		KEYC_NPAGE|KEYC_SHIFT,	0 },
	{ TTYC_KNXT3,	NULL,		KEYC_NPAGE|KEYC_ESCAPE,	0 },
	{ TTYC_KNXT4,	NULL,		KEYC_NPAGE|KEYC_SHIFT|KEYC_ESCAPE, 0 },
	{ TTYC_KNXT5,	NULL,		KEYC_NPAGE|KEYC_CTRL,	0 },
	{ TTYC_KNXT6,	NULL,		KEYC_NPAGE|KEYC_SHIFT|KEYC_CTRL, 0 },
	{ TTYC_KNXT7,	NULL,		KEYC_NPAGE|KEYC_ESCAPE|KEYC_CTRL, 0 },
	{ TTYC_KPRV2,	NULL,		KEYC_PPAGE|KEYC_SHIFT,	0 },
	{ TTYC_KPRV3,	NULL,		KEYC_PPAGE|KEYC_ESCAPE,	0 },
	{ TTYC_KPRV4,	NULL,		KEYC_PPAGE|KEYC_SHIFT|KEYC_ESCAPE, 0 },
	{ TTYC_KPRV5,	NULL,		KEYC_PPAGE|KEYC_CTRL,	0 },
	{ TTYC_KPRV6,	NULL,		KEYC_PPAGE|KEYC_SHIFT|KEYC_CTRL, 0 },
	{ TTYC_KPRV7,	NULL,		KEYC_PPAGE|KEYC_ESCAPE|KEYC_CTRL, 0 },
	{ TTYC_KRIT2,	NULL,		KEYC_RIGHT|KEYC_SHIFT,	0 },
	{ TTYC_KRIT3,	NULL,		KEYC_RIGHT|KEYC_ESCAPE,	0 },
	{ TTYC_KRIT4,	NULL,		KEYC_RIGHT|KEYC_SHIFT|KEYC_ESCAPE, 0 },
	{ TTYC_KRIT5,	NULL,		KEYC_RIGHT|KEYC_CTRL,	0 },
	{ TTYC_KRIT6,	NULL,		KEYC_RIGHT|KEYC_SHIFT|KEYC_CTRL, 0 },
	{ TTYC_KRIT7,	NULL,		KEYC_RIGHT|KEYC_ESCAPE|KEYC_CTRL, 0 },
	{ TTYC_KUP2,	NULL,		KEYC_UP|KEYC_SHIFT,	0 },
	{ TTYC_KUP3,	NULL,		KEYC_UP|KEYC_ESCAPE,	0 },
	{ TTYC_KUP4,	NULL,		KEYC_UP|KEYC_SHIFT|KEYC_ESCAPE,	0 },
	{ TTYC_KUP5,	NULL,		KEYC_UP|KEYC_CTRL,	0 },
	{ TTYC_KUP6,	NULL,		KEYC_UP|KEYC_SHIFT|KEYC_CTRL, 0 },
	{ TTYC_KUP7,	NULL,		KEYC_UP|KEYC_ESCAPE|KEYC_CTRL, 0 },
d283 1
d341 1
a341 1
tty_keys_init(struct tty *tty)
d343 4
a346 3
	const struct tty_key_ent	*tke;
	u_int		 		 i;
	const char			*s;
d348 2
a350 2
	for (i = 0; i < nitems(tty_keys); i++) {
		tke = &tty_keys[i];
d352 13
a364 9
		if (tke->flags & TTYKEY_RAW)
			s = tke->string;
		else {
			if (!tty_term_has(tty->term, tke->code))
				continue;
			s = tty_term_string(tty->term, tke->code);
		}
		if (s[0] != '\033' || s[1] == '\0')
			continue;
a365 1
		tty_keys_add(tty, s + 1, tke->key);
@


1.46
log
@Instead of worrying about xterm version, send DA and read DEC service
class which is more likely to be useful. Not used for anything yet
anyway.
@
text
@d1 1
a1 1
/* $OpenBSD: tty-keys.c,v 1.45 2012/10/26 14:35:42 nicm Exp $ */
d727 1
a727 1
	u_int i, n;
d767 1
a767 1
	n = strtoul(tmp, &endptr, 10);
d769 1
a769 1
		n = 0;
d771 2
a772 2
	log_debug("received service class %u", n);
	tty->service_class = n;
@


1.45
log
@Make mouse event structure clearer by defining events (up, click, drag)
and simplifying how buttons and wheels are represented, from Ailin
Nemui. Should be no functional changes.
@
text
@d1 1
a1 1
/* $OpenBSD: tty-keys.c,v 1.44 2012/09/03 06:26:48 nicm Exp $ */
d727 1
a727 1
	u_int i, a, b;
d732 1
a732 2
	 * \033[>a;b;c. We only request attributes on xterm, so we only care
	 * about the middle values which is the xterm version.
d737 1
a737 1
	/* First three bytes are always \033[>. */
d762 2
a763 2
	/* Only secondary is of interest. */
	if (buf[2] != '>')
d766 7
a772 12
	/* Convert version numbers. */
	a = strtoul(tmp, &endptr, 10);
	if (*endptr == ';') {
		b = strtoul(endptr + 1, &endptr, 10);
		if (*endptr != '\0' && *endptr != ';')
			b = 0;
	} else
		a = b = 0;

	log_debug("received xterm version %u", b);
	if (b < 500)
		tty_set_version(tty, b);
@


1.44
log
@Can't call evtimer_pending on uninitialized events, call
evtimer_initialized first. Reported by Vladimir Lomov, fix from Thomas
Adam slightly modified by me.
@
text
@d1 1
a1 1
/* $OpenBSD: tty-keys.c,v 1.43 2012/08/21 10:08:11 nicm Exp $ */
d614 1
a614 1
	u_int			 i, value;
d625 1
d665 1
a665 1
			m->b = value;
d667 1
a667 1
			m->x = value;
d669 1
a669 1
			m->y = value;
d674 1
a674 1
	if (m->b < 32 || m->x < 33 || m->y < 33)
d676 41
a716 4
	m->b -= 32;
	m->x -= 33;
	m->y -= 33;
	log_debug("mouse position: x=%u y=%u b=%u", m->x, m->y, m->b);
@


1.43
log
@xterm won't reach version 500 for a while so set that as the upper limit.
@
text
@d1 1
a1 1
/* $OpenBSD: tty-keys.c,v 1.42 2012/07/10 11:53:01 nicm Exp $ */
d536 1
d547 2
a548 1
	if (evtimer_pending(&tty->key_timer, NULL))
@


1.42
log
@xfree is not particularly helpful, remove it. From Thomas Adam.
@
text
@d1 1
a1 1
/* $OpenBSD: tty-keys.c,v 1.41 2012/05/22 14:32:28 nicm Exp $ */
d737 2
a738 1
	tty_set_version(tty, b);
@


1.41
log
@Store client in tty struct directly instead of using a callback function
pointer.
@
text
@d1 1
a1 1
/* $OpenBSD: tty-keys.c,v 1.40 2012/05/22 14:11:30 nicm Exp $ */
d387 1
a387 1
	xfree(tk);
@


1.40
log
@Store mouse data in tty structure not on the stack.
@
text
@d1 1
a1 1
/* $OpenBSD: tty-keys.c,v 1.39 2012/04/22 05:21:40 nicm Exp $ */
d583 1
a583 1
		tty->key_callback(key, &tty->mouse_event, tty->key_data);
d610 1
a610 1
	struct mouse_event	*m = &tty->mouse_event;
@


1.39
log
@Handle partial keys properly by making sure the timer has actually
expired, fixes problems with mintty reported by Michael Simpson.
@
text
@d1 1
a1 1
/* $OpenBSD: tty-keys.c,v 1.38 2012/03/21 21:28:03 nicm Exp $ */
d43 1
a43 2
int		tty_keys_mouse(struct tty *,
		    const char *, size_t, size_t *, struct mouse_event *);
d436 6
a441 7
	struct tty_key		*tk;
	struct timeval		 tv;
	struct mouse_event	 mouse;
	const char		*buf;
	size_t			 len, size;
	cc_t			 bspace;
	int			 key, delay;
d478 1
a478 1
	switch (tty_keys_mouse(tty, buf, len, &size, &mouse)) {
d583 1
a583 1
		tty->key_callback(key, &mouse, tty->key_data);
d608 1
a608 2
tty_keys_mouse(struct tty *tty,
    const char *buf, size_t len, size_t *size, struct mouse_event *m)
d610 3
a612 2
	struct utf8_data	utf8data;
	u_int			i, value;
@


1.38
log
@Some terminals respond to secondary DA with primary (they ignore the
intermediate character). So ignore the possible responses to primary DA.
@
text
@d1 1
a1 1
/* $OpenBSD: tty-keys.c,v 1.37 2012/03/17 22:56:04 nicm Exp $ */
a478 1

d534 2
a535 2
	 * Escape but no key string. If have already seen an escape, then the
	 * timer must have expired, so give up waiting and send the escape.
d537 2
a538 1
	if (tty->flags & TTY_ESCAPE) {
d547 4
@


1.37
log
@On xterm 271 and later, put the terminal into SCL 5 and use DECCRA for
scrolling the region in panes (if the large region check isn't
hit). With help from Ailin Nemui.
@
text
@d1 1
a1 1
/* $OpenBSD: tty-keys.c,v 1.36 2012/03/17 18:24:07 nicm Exp $ */
d689 3
a691 3
	 * Secondary device attributes are \033[>a;b;c. We only request
	 * attributes on xterm, so we only care about the middle values which
	 * is the xterm version.
d705 1
a705 1
	if (buf[2] != '>')
d720 4
@


1.36
log
@Check event_initialized before event_del if event may not have been set
up; libevent2 complains about this. Reported by Moriyoshi Koizumi.
@
text
@d1 1
a1 1
/* $OpenBSD: tty-keys.c,v 1.35 2012/03/15 10:36:00 nicm Exp $ */
d731 1
a731 2
	if (tty->xterm_version == 0)
		tty->xterm_version = b;
@


1.35
log
@Send secondary DA to terminals with XT in terminfo when starting up and
parse it to work out the xterm version.
@
text
@d1 1
a1 1
/* $OpenBSD: tty-keys.c,v 1.34 2011/03/04 23:26:44 nicm Exp $ */
d552 2
a553 1
	evtimer_del(&tty->key_timer);
d577 2
a578 1
	evtimer_del(&tty->key_timer);
@


1.34
log
@Two fixes by Micah Cowan: make mouse work properly beyond >127 on signed
char architectures and properly parse $TMUX by stopping the socket path
at the first comma.
@
text
@d1 1
a1 1
/* $OpenBSD: tty-keys.c,v 1.33 2011/01/03 23:35:22 nicm Exp $ */
d22 2
d45 1
d467 13
d578 2
a579 1
	tty->key_callback(key, &mouse, tty->key_data);
d673 59
@


1.33
log
@Support for UTF-8 mouse input (\033[1005h). This was added in xterm 262
and supports larger terminals than the older way.

If the new mouse-utf8 option is on, UTF-8 mouse input is enabled for all
UTF-8 terminals. The option defaults to on if LANG etc are set in the
same manner as the utf8 option.

With help and based on code from hsim at gmx.li.
@
text
@d1 1
a1 1
/* $OpenBSD: tty-keys.c,v 1.32 2011/01/01 02:16:25 nicm Exp $ */
d633 1
a633 1
				value = buf[*size];
d636 1
a636 1
			value = buf[*size];
@


1.32
log
@Key table should be const.
@
text
@d1 1
a1 1
/* $OpenBSD: tty-keys.c,v 1.31 2010/05/31 19:51:29 nicm Exp $ */
d41 1
a41 1
int		tty_keys_mouse(
d465 1
a465 1
	switch (tty_keys_mouse(buf, len, &size, &mouse)) {
d587 2
a588 1
tty_keys_mouse(const char *buf, size_t len, size_t *size, struct mouse_event *m)
d590 3
d594 5
a598 2
	 * Mouse sequences are \033[M followed by three characters indicating
	 * buttons, X and Y, all based at 32 with 1,1 top-left.
d603 1
a607 1

a611 1

d617 22
a638 3
	if (len < 6)
		return (1);
	*size = 6;
d640 8
a647 2
	log_debug(
	    "mouse input: %.6s (%hhu,%hhu/%hhu)", buf, buf[4], buf[5], buf[3]);
d649 1
a649 3
	m->b = buf[3];
	m->x = buf[4];
	m->y = buf[5];
d655 1
@


1.31
log
@When the mode-mouse option is on, support dragging to make a selection
in copy mode.

Also support the scroll wheel, although xterm strangely does not ignore
it in application mouse mode, causing redraw artifacts when scrolling up
(other terminals appear to be better behaved).
@
text
@d1 1
a1 1
/* $OpenBSD: tty-keys.c,v 1.30 2010/03/22 19:03:52 nicm Exp $ */
d57 1
a57 1
struct tty_key_ent tty_keys[] = {
d346 3
a348 3
	struct tty_key_ent	*tke;
	u_int		 	 i;
	const char		*s;
@


1.30
log
@Accept a full key match (not a partial) even if there is data left in
the buffer.
@
text
@d1 1
a1 1
/* $OpenBSD$ */
d615 2
a616 1
	log_debug("mouse input is: %.6s", buf);
@


1.29
log
@Allow keys to be replaced and reorder the table so that terminfo-defined keys
(or terminal-overrides) take precedence over internally defined.
@
text
@d1 1
a1 1
/* $OpenBSD: tty-keys.c,v 1.28 2009/12/14 10:43:41 nicm Exp $ */
d411 1
a411 1
		if (len == 0)
@


1.28
log
@New server option, escape-time, to set the timeout used to detect if escapes
are alone or part of a function key or meta sequence.
@
text
@d1 1
a1 1
/* $OpenBSD: tty-keys.c,v 1.27 2009/12/03 22:50:10 nicm Exp $ */
a57 45
	/* Function keys. */
	{ TTYC_KF1,	NULL,		KEYC_F1,		0 },
	{ TTYC_KF2,	NULL,		KEYC_F2,		0 },
	{ TTYC_KF3,	NULL,		KEYC_F3,		0 },
	{ TTYC_KF4,	NULL,		KEYC_F4,		0 },
	{ TTYC_KF5,	NULL,		KEYC_F5,		0 },
	{ TTYC_KF6,	NULL,		KEYC_F6,		0 },
	{ TTYC_KF7,	NULL,		KEYC_F7,		0 },
	{ TTYC_KF8,	NULL,		KEYC_F8,		0 },
	{ TTYC_KF9,	NULL,		KEYC_F9,		0 },
	{ TTYC_KF10,	NULL,		KEYC_F10,		0 },
	{ TTYC_KF11,	NULL,		KEYC_F11,		0 },
	{ TTYC_KF12,	NULL,		KEYC_F12,		0 },
	{ TTYC_KF13,	NULL,		KEYC_F13,		0 },
	{ TTYC_KF14,	NULL,		KEYC_F14,		0 },
	{ TTYC_KF15,	NULL,		KEYC_F15,		0 },
	{ TTYC_KF16,	NULL,		KEYC_F16,		0 },
	{ TTYC_KF17,	NULL,		KEYC_F17,		0 },
	{ TTYC_KF18,	NULL,		KEYC_F18,		0 },
	{ TTYC_KF19,	NULL,		KEYC_F19,		0 },
	{ TTYC_KF20,	NULL,		KEYC_F20,		0 },
	{ TTYC_KICH1,	NULL,		KEYC_IC,		0 },
	{ TTYC_KDCH1,	NULL,		KEYC_DC,		0 },
	{ TTYC_KHOME,	NULL,		KEYC_HOME,		0 },
	{ TTYC_KEND,	NULL,		KEYC_END,		0 },
	{ TTYC_KNP,	NULL,		KEYC_NPAGE,		0 },
	{ TTYC_KPP,	NULL,		KEYC_PPAGE,		0 },
	{ TTYC_KCBT,	NULL,		KEYC_BTAB,		0 },

	/* Arrow keys. */
	{ 0,		"\033OA",	KEYC_UP,		TTYKEY_RAW },
	{ 0,		"\033OB",	KEYC_DOWN,		TTYKEY_RAW },
	{ 0,		"\033OC",	KEYC_RIGHT,		TTYKEY_RAW },
	{ 0,		"\033OD",	KEYC_LEFT,		TTYKEY_RAW },

	{ 0,		"\033[A",	KEYC_UP,		TTYKEY_RAW },
	{ 0,		"\033[B",	KEYC_DOWN,		TTYKEY_RAW },
	{ 0,		"\033[C",	KEYC_RIGHT,		TTYKEY_RAW },
	{ 0,		"\033[D",	KEYC_LEFT,		TTYKEY_RAW },

	{ TTYC_KCUU1,	NULL,		KEYC_UP,		0 },
	{ TTYC_KCUD1,	NULL,		KEYC_DOWN,		0 },
	{ TTYC_KCUB1,	NULL,		KEYC_LEFT,		0 },
	{ TTYC_KCUF1,	NULL,		KEYC_RIGHT,		0 },

d63 16
a78 16
	{ 0,		"\033Oo",	KEYC_KP_SLASH,		TTYKEY_RAW },
	{ 0,		"\033Oj",	KEYC_KP_STAR,		TTYKEY_RAW },
	{ 0,		"\033Om",	KEYC_KP_MINUS,		TTYKEY_RAW },
	{ 0,		"\033Ow",	KEYC_KP_SEVEN,		TTYKEY_RAW },
	{ 0,		"\033Ox",	KEYC_KP_EIGHT,		TTYKEY_RAW },
	{ 0,		"\033Oy",	KEYC_KP_NINE,		TTYKEY_RAW },
	{ 0,		"\033Ok",	KEYC_KP_PLUS,		TTYKEY_RAW },
	{ 0,		"\033Ot",	KEYC_KP_FOUR,		TTYKEY_RAW },
	{ 0,		"\033Ou",	KEYC_KP_FIVE,		TTYKEY_RAW },
	{ 0,		"\033Ov",	KEYC_KP_SIX,		TTYKEY_RAW },
	{ 0,		"\033Oq",	KEYC_KP_ONE,		TTYKEY_RAW },
	{ 0,		"\033Or",	KEYC_KP_TWO,		TTYKEY_RAW },
	{ 0,		"\033Os",	KEYC_KP_THREE,		TTYKEY_RAW },
	{ 0,		"\033OM",	KEYC_KP_ENTER,		TTYKEY_RAW },
	{ 0,		"\033Op",	KEYC_KP_ZERO,		TTYKEY_RAW },
	{ 0,		"\033On",	KEYC_KP_PERIOD,		TTYKEY_RAW },
d80 10
a89 61
	/* Key and modifier capabilities. */
	{ TTYC_KDC2,	NULL,		KEYC_DC|KEYC_SHIFT,	0 },
	{ TTYC_KDC3,	NULL,		KEYC_DC|KEYC_ESCAPE,	0 },
	{ TTYC_KDC4,	NULL,		KEYC_DC|KEYC_SHIFT|KEYC_ESCAPE, 0 },
	{ TTYC_KDC5,	NULL,		KEYC_DC|KEYC_CTRL,	0 },
	{ TTYC_KDC6,	NULL,		KEYC_DC|KEYC_SHIFT|KEYC_CTRL, 0 },
	{ TTYC_KDC7,	NULL,		KEYC_DC|KEYC_ESCAPE|KEYC_CTRL, 0 },
	{ TTYC_KDN2,	NULL,		KEYC_DOWN|KEYC_SHIFT,	0 },
	{ TTYC_KDN3,	NULL,		KEYC_DOWN|KEYC_ESCAPE,	0 },
	{ TTYC_KDN4,	NULL,		KEYC_DOWN|KEYC_SHIFT|KEYC_ESCAPE, 0 },
	{ TTYC_KDN5,	NULL,		KEYC_DOWN|KEYC_CTRL,	0 },
	{ TTYC_KDN6,	NULL,		KEYC_DOWN|KEYC_SHIFT|KEYC_CTRL, 0 },
	{ TTYC_KDN7,	NULL,		KEYC_DOWN|KEYC_ESCAPE|KEYC_CTRL, 0 },
	{ TTYC_KEND2,	NULL,		KEYC_END|KEYC_SHIFT,	0 },
	{ TTYC_KEND3,	NULL,		KEYC_END|KEYC_ESCAPE,	0 },
	{ TTYC_KEND4,	NULL,		KEYC_END|KEYC_SHIFT|KEYC_ESCAPE, 0 },
	{ TTYC_KEND5,	NULL,		KEYC_END|KEYC_CTRL,	0 },
	{ TTYC_KEND6,	NULL,		KEYC_END|KEYC_SHIFT|KEYC_CTRL, 0 },
	{ TTYC_KEND7,	NULL,		KEYC_END|KEYC_ESCAPE|KEYC_CTRL, 0 },
	{ TTYC_KHOM2,	NULL,		KEYC_HOME|KEYC_SHIFT,	0 },
	{ TTYC_KHOM3,	NULL,		KEYC_HOME|KEYC_ESCAPE,	0 },
	{ TTYC_KHOM4,	NULL,		KEYC_HOME|KEYC_SHIFT|KEYC_ESCAPE, 0 },
	{ TTYC_KHOM5,	NULL,		KEYC_HOME|KEYC_CTRL,	0 },
	{ TTYC_KHOM6,	NULL,		KEYC_HOME|KEYC_SHIFT|KEYC_CTRL, 0 },
	{ TTYC_KHOM7,	NULL,		KEYC_HOME|KEYC_ESCAPE|KEYC_CTRL, 0 },
	{ TTYC_KIC2,	NULL,		KEYC_IC|KEYC_SHIFT,	0 },
	{ TTYC_KIC3,	NULL,		KEYC_IC|KEYC_ESCAPE,	0 },
	{ TTYC_KIC4,	NULL,		KEYC_IC|KEYC_SHIFT|KEYC_ESCAPE,	0 },
	{ TTYC_KIC5,	NULL,		KEYC_IC|KEYC_CTRL,	0 },
	{ TTYC_KIC6,	NULL,		KEYC_IC|KEYC_SHIFT|KEYC_CTRL, 0 },
	{ TTYC_KIC7,	NULL,		KEYC_IC|KEYC_ESCAPE|KEYC_CTRL, 0 },
	{ TTYC_KLFT2,	NULL,		KEYC_LEFT|KEYC_SHIFT,	0 },
	{ TTYC_KLFT3,	NULL,		KEYC_LEFT|KEYC_ESCAPE,	0 },
	{ TTYC_KLFT4,	NULL,		KEYC_LEFT|KEYC_SHIFT|KEYC_ESCAPE, 0 },
	{ TTYC_KLFT5,	NULL,		KEYC_LEFT|KEYC_CTRL,	0 },
	{ TTYC_KLFT6,	NULL,		KEYC_LEFT|KEYC_SHIFT|KEYC_CTRL, 0 },
	{ TTYC_KLFT7,	NULL,		KEYC_LEFT|KEYC_ESCAPE|KEYC_CTRL, 0 },
	{ TTYC_KNXT2,	NULL,		KEYC_NPAGE|KEYC_SHIFT,	0 },
	{ TTYC_KNXT3,	NULL,		KEYC_NPAGE|KEYC_ESCAPE,	0 },
	{ TTYC_KNXT4,	NULL,		KEYC_NPAGE|KEYC_SHIFT|KEYC_ESCAPE, 0 },
	{ TTYC_KNXT5,	NULL,		KEYC_NPAGE|KEYC_CTRL,	0 },
	{ TTYC_KNXT6,	NULL,		KEYC_NPAGE|KEYC_SHIFT|KEYC_CTRL, 0 },
	{ TTYC_KNXT7,	NULL,		KEYC_NPAGE|KEYC_ESCAPE|KEYC_CTRL, 0 },
	{ TTYC_KPRV2,	NULL,		KEYC_PPAGE|KEYC_SHIFT,	0 },
	{ TTYC_KPRV3,	NULL,		KEYC_PPAGE|KEYC_ESCAPE,	0 },
	{ TTYC_KPRV4,	NULL,		KEYC_PPAGE|KEYC_SHIFT|KEYC_ESCAPE, 0 },
	{ TTYC_KPRV5,	NULL,		KEYC_PPAGE|KEYC_CTRL,	0 },
	{ TTYC_KPRV6,	NULL,		KEYC_PPAGE|KEYC_SHIFT|KEYC_CTRL, 0 },
	{ TTYC_KPRV7,	NULL,		KEYC_PPAGE|KEYC_ESCAPE|KEYC_CTRL, 0 },
	{ TTYC_KRIT2,	NULL,		KEYC_RIGHT|KEYC_SHIFT,	0 },
	{ TTYC_KRIT3,	NULL,		KEYC_RIGHT|KEYC_ESCAPE,	0 },
	{ TTYC_KRIT4,	NULL,		KEYC_RIGHT|KEYC_SHIFT|KEYC_ESCAPE, 0 },
	{ TTYC_KRIT5,	NULL,		KEYC_RIGHT|KEYC_CTRL,	0 },
	{ TTYC_KRIT6,	NULL,		KEYC_RIGHT|KEYC_SHIFT|KEYC_CTRL, 0 },
	{ TTYC_KRIT7,	NULL,		KEYC_RIGHT|KEYC_ESCAPE|KEYC_CTRL, 0 },
	{ TTYC_KUP2,	NULL,		KEYC_UP|KEYC_SHIFT,	0 },
	{ TTYC_KUP3,	NULL,		KEYC_UP|KEYC_ESCAPE,	0 },
	{ TTYC_KUP4,	NULL,		KEYC_UP|KEYC_SHIFT|KEYC_ESCAPE,	0 },
	{ TTYC_KUP5,	NULL,		KEYC_UP|KEYC_CTRL,	0 },
	{ TTYC_KUP6,	NULL,		KEYC_UP|KEYC_SHIFT|KEYC_CTRL, 0 },
	{ TTYC_KUP7,	NULL,		KEYC_UP|KEYC_ESCAPE|KEYC_CTRL, 0 },
d186 99
d290 3
a292 1
	size_t	size;
d294 3
a296 2
	if (tty_keys_find(tty, s, strlen(s), &size) == NULL) {
		log_debug("new key 0x%x: %s", key, s);
d298 3
a385 1

@


1.27
log
@Massive spaces->tabs and trailing whitespace cleanup, hopefully for the last
time now I've configured emacs to make them displayed in really annoying
colours...
@
text
@d1 1
a1 1
/* $OpenBSD: tty-keys.c,v 1.26 2009/12/01 07:59:40 nicm Exp $ */
d432 1
a432 1
	int			 key;
d524 3
a526 2
	tv.tv_sec = 0;
	tv.tv_usec = ESCAPE_PERIOD * 1000L;
@


1.26
log
@Look for mice and xterm keys before standard function keys as they are less
likely to be partial versions.
@
text
@d1 1
a1 1
/* $OpenBSD: tty-keys.c,v 1.25 2009/11/30 16:44:03 nicm Exp $ */
d38 1
a38 1
    		    struct tty_key *, const char *, size_t, size_t *);
d53 1
a53 1
/* 
d322 1
a322 1
	} else { 
d377 1
a377 1
	
d526 1
a526 1
	
d530 1
a530 1
	
d551 1
a551 1
 	evtimer_del(&tty->key_timer);
d573 1
a573 1
/* 
d596 1
a596 1
		
@


1.25
log
@Handle partial xterm function key sequences.
@
text
@d1 1
a1 1
/* $OpenBSD: tty-keys.c,v 1.24 2009/11/26 22:26:51 nicm Exp $ */
d456 1
a456 8
	/* Look for matching key string and return if found. */
	tk = tty_keys_find(tty, buf + 1, len - 1, &size);
	if (tk != NULL) {
		key = tk->key;
		goto found_key;
	}

	/* Not found. Is this a mouse key press? */
d468 1
a468 1
	/* Not found. Try to parse a key with an xterm-style modifier. */
d477 7
@


1.24
log
@Continue rather than returning if not a mouse key, to avoid hanging on any
function key...
@
text
@d1 1
a1 1
/* $OpenBSD: tty-keys.c,v 1.23 2009/11/26 21:37:13 nicm Exp $ */
a474 1

d476 2
a477 2
	key = xterm_keys_find(buf, len, &size);
	if (key != KEYC_NONE) {
d480 4
@


1.23
log
@Remove a couple of unused arguments where possible, and add /* ARGSUSED */ to
the rest to reduce lint output.
@
text
@d1 1
a1 1
/* $OpenBSD: tty-keys.c,v 1.22 2009/11/26 15:14:03 nicm Exp $ */
d470 1
a470 2
		evbuffer_drain(tty->event->input, size);
		return (1);
@


1.22
log
@Handle the possibility of partial mouse reads, and fix a comment while here.
@
text
@d1 1
a1 1
/* $OpenBSD: tty-keys.c,v 1.21 2009/11/12 08:01:02 nicm Exp $ */
d558 1
@


1.21
log
@Support rxvt-style keys again, but this time: support all the variations, put
them in as raw escape sequences rather than fiddling with the values from
terminfo, put them /after/ the terminfo values so the latter take precedence.
@
text
@d1 1
a1 1
/* $OpenBSD: tty-keys.c,v 1.20 2009/11/10 17:59:34 nicm Exp $ */
d421 1
a421 1
 * 1 if there are no further keys, or 0 if there is more in the buffer.
d464 2
a465 2
	key = tty_keys_mouse(buf, len, &size, &mouse);
	if (key != KEYC_NONE) {
d467 1
d469 5
d476 1
d570 4
a573 1
/* Handle mouse key input. */
d582 19
a600 2
	if (len != 6 || memcmp(buf, "\033[M", 3) != 0)
		return (KEYC_NONE);
d603 1
a603 1
	log_debug("mouse input is: %.*s", (int) len, buf);
d609 1
a609 1
		return (KEYC_NONE);
d613 1
a613 1
	return (KEYC_MOUSE);
@


1.20
log
@Twiddling the last bit is an rxvtism, so do not support it in the table by
default.
@
text
@d1 1
a1 1
/* $OpenBSD: tty-keys.c,v 1.19 2009/11/09 14:40:06 nicm Exp $ */
a59 1
	{ TTYC_KF1,	NULL,		KEYC_F1,		0 },
a102 11
	/* Special-case arrow keys for rxvt until terminfo has kRIT5 etc. */
	{ 0,		"\033Oa",	KEYC_UP|KEYC_CTRL,	TTYKEY_RAW },
	{ 0,		"\033Ob",	KEYC_DOWN|KEYC_CTRL,	TTYKEY_RAW },
	{ 0,		"\033Oc",	KEYC_RIGHT|KEYC_CTRL,	TTYKEY_RAW },
	{ 0,		"\033Od",	KEYC_LEFT|KEYC_CTRL,	TTYKEY_RAW },

	{ 0,		"\033[a",	KEYC_UP|KEYC_SHIFT,	TTYKEY_RAW },
	{ 0,		"\033[b",	KEYC_DOWN|KEYC_SHIFT,	TTYKEY_RAW },
	{ 0,		"\033[c",	KEYC_RIGHT|KEYC_SHIFT,	TTYKEY_RAW },
	{ 0,		"\033[d",	KEYC_LEFT|KEYC_SHIFT,	TTYKEY_RAW },

d186 96
@


1.19
log
@The input key should be a u_char. Fixes top-bit-set input problem reported by
ajacoutot@@.
@
text
@d1 1
a1 1
/* $OpenBSD: tty-keys.c,v 1.18 2009/11/09 11:45:10 nicm Exp $ */
d50 1
a50 2
#define TTYKEY_CTRL 0x1
#define TTYKEY_RAW 0x2
d55 1
a55 2
 * otherwise they are looked up in terminfo(5). Any keys marked TTYKEY_CTRL
 * have their last byte twiddled and are inserted as a Ctrl key as well.
d59 28
a86 28
	{ TTYC_KF1,	NULL,		KEYC_F1,		TTYKEY_CTRL },
	{ TTYC_KF1,	NULL,		KEYC_F1,		TTYKEY_CTRL },
	{ TTYC_KF2,	NULL,		KEYC_F2,		TTYKEY_CTRL },
	{ TTYC_KF3,	NULL,		KEYC_F3,		TTYKEY_CTRL },
	{ TTYC_KF4,	NULL,		KEYC_F4,		TTYKEY_CTRL },
	{ TTYC_KF5,	NULL,		KEYC_F5,		TTYKEY_CTRL },
	{ TTYC_KF6,	NULL,		KEYC_F6,		TTYKEY_CTRL },
	{ TTYC_KF7,	NULL,		KEYC_F7,		TTYKEY_CTRL },
	{ TTYC_KF8,	NULL,		KEYC_F8,		TTYKEY_CTRL },
	{ TTYC_KF9,	NULL,		KEYC_F9,		TTYKEY_CTRL },
	{ TTYC_KF10,	NULL,		KEYC_F10,		TTYKEY_CTRL },
	{ TTYC_KF11,	NULL,		KEYC_F11,		TTYKEY_CTRL },
	{ TTYC_KF12,	NULL,		KEYC_F12,		TTYKEY_CTRL },
	{ TTYC_KF13,	NULL,		KEYC_F13,		TTYKEY_CTRL },
	{ TTYC_KF14,	NULL,		KEYC_F14,		TTYKEY_CTRL },
	{ TTYC_KF15,	NULL,		KEYC_F15,		TTYKEY_CTRL },
	{ TTYC_KF16,	NULL,		KEYC_F16,		TTYKEY_CTRL },
	{ TTYC_KF17,	NULL,		KEYC_F17,		TTYKEY_CTRL },
	{ TTYC_KF18,	NULL,		KEYC_F18,		TTYKEY_CTRL },
	{ TTYC_KF19,	NULL,		KEYC_F19,		TTYKEY_CTRL },
	{ TTYC_KF20,	NULL,		KEYC_F20,		TTYKEY_CTRL },
	{ TTYC_KICH1,	NULL,		KEYC_IC,		TTYKEY_CTRL },
	{ TTYC_KDCH1,	NULL,		KEYC_DC,		TTYKEY_CTRL },
	{ TTYC_KHOME,	NULL,		KEYC_HOME,		TTYKEY_CTRL },
	{ TTYC_KEND,	NULL,		KEYC_END,		TTYKEY_CTRL },
	{ TTYC_KNP,	NULL,		KEYC_NPAGE,		TTYKEY_CTRL },
	{ TTYC_KPP,	NULL,		KEYC_PPAGE,		TTYKEY_CTRL },
	{ TTYC_KCBT,	NULL,		KEYC_BTAB,		TTYKEY_CTRL },
d99 4
a102 4
	{ TTYC_KCUU1,	NULL,		KEYC_UP,		TTYKEY_CTRL },
	{ TTYC_KCUD1,	NULL,		KEYC_DOWN,		TTYKEY_CTRL },
	{ TTYC_KCUB1,	NULL,		KEYC_LEFT,		TTYKEY_CTRL },
	{ TTYC_KCUF1,	NULL,		KEYC_RIGHT,		TTYKEY_CTRL },
a255 1
	char			 tmp[64];
a271 6
		if (!(tke->flags & TTYKEY_CTRL)) {
			if (strlcpy(tmp, s, sizeof tmp) >= sizeof tmp)
				continue;
			tmp[strlen(tmp) - 1] ^= 0x20;
			tty_keys_add(tty, tmp + 1, tke->key | KEYC_CTRL);
		}
@


1.18
log
@Constify buf.
@
text
@d1 1
a1 1
/* $OpenBSD: tty-keys.c,v 1.17 2009/11/05 19:32:34 nicm Exp $ */
d367 1
a367 1
		key = *buf;
@


1.17
log
@Unused variable. Aargh.
@
text
@d1 1
a1 1
/* $OpenBSD: tty-keys.c,v 1.16 2009/11/05 19:29:41 nicm Exp $ */
d41 2
a42 1
int		tty_keys_mouse(char *, size_t, size_t *, struct mouse_event *);
d354 1
a354 1
	char			*buf;
d490 1
a490 1
tty_keys_mouse(char *buf, size_t len, size_t *size, struct mouse_event *m)
@


1.16
log
@Switch the tty key tree over to an (unbalanced) ternary tree which allows
partial matches to be done (they wait for further data or a timer to expire,
like a naked escape).

Mouse and xterm-style keys still expect to be atomic.
@
text
@d1 1
a1 1
/* $OpenBSD: tty-keys.c,v 1.15 2009/11/05 10:44:36 nicm Exp $ */
d353 1
a353 1
	char			*buf, *ptr;
@


1.15
log
@Key flags are only used for initialisation so they are not needed in the main
tty_key struct.
@
text
@d1 1
a1 1
/* $OpenBSD: tty-keys.c,v 1.14 2009/11/05 08:45:08 nicm Exp $ */
d29 3
a31 1
 * Handle keys input from the outside terminal.
d34 8
a41 3
void	tty_keys_add(struct tty *, const char *, int);
void	tty_keys_callback(int, short, void *);
int	tty_keys_mouse(char *, size_t, size_t *, struct mouse_event *);
d53 5
d201 4
a204 1
RB_GENERATE(tty_keys, tty_key, entry, tty_keys_cmp);
d206 4
a209 6
struct tty_key *tty_keys_find(struct tty *, char *, size_t, size_t *);

int
tty_keys_cmp(struct tty_key *k1, struct tty_key *k2)
{
	return (strcmp(k1->string, k2->string));
d212 1
d214 1
a214 1
tty_keys_add(struct tty *tty, const char *s, int key)
d216 1
a216 1
	struct tty_key	*tk, *tl;
d218 30
a247 14
	tk = xmalloc(sizeof *tk);
	tk->string = xstrdup(s);
	tk->key = key;

	if ((tl = RB_INSERT(tty_keys, &tty->ktree, tk)) != NULL) {
		xfree(tk->string);
		xfree(tk);
		log_debug("key exists: %s (old %x, new %x)", s, tl->key, key);
 		return;
	}

	if (strlen(tk->string) > tty->ksize)
		tty->ksize = strlen(tk->string);
	log_debug("new key %x: size now %zu (%s)", key, tty->ksize, tk->string);
d250 1
d259 1
a259 3
	RB_INIT(&tty->ktree);

	tty->ksize = 0;
a268 2
			if (s[0] != '\033' || s[1] == '\0')
				continue;
d270 2
d274 1
a274 1
		if (tke->flags & TTYKEY_CTRL) {
d283 1
d287 2
a288 1
	struct tty_key	*tk;
d290 12
a301 6
	while (!RB_EMPTY(&tty->ktree)) {
		tk = RB_ROOT(&tty->ktree);
		RB_REMOVE(tty_keys, &tty->ktree, tk);
		xfree(tk->string);
		xfree(tk);
	}
d304 1
d306 1
a306 1
tty_keys_find(struct tty *tty, char *buf, size_t len, size_t *size)
d308 3
a310 2
	struct tty_key	*tk, tl;
	char		*s;
d312 6
a317 1
	if (len == 0)
d320 5
a324 6
	s = xmalloc(tty->ksize + 1);
	for (*size = tty->ksize; (*size) > 0; (*size)--) {
		if ((*size) > len)
			continue;
		memcpy(s, buf, *size);
		s[*size] = '\0';
d326 3
a328 1
		log_debug2("looking for key: %s", s);
d330 7
a336 7
		tl.string = s;
		tk = RB_FIND(tty_keys, &tty->ktree, &tl);
		if (tk != NULL) {
			log_debug2("got key: 0x%x", tk->key);
			xfree(s);
			return (tk);
		}
a337 1
	xfree(s);
d339 2
a340 1
	return (NULL);
d343 4
d353 1
a353 1
	char			*buf;
a356 1
	u_char			 ch;
d366 2
a367 2
		bufferevent_read(tty->event, &ch, 1);
		key = ch;
d377 1
a377 1
		goto found;
a382 1
		evbuffer_drain(tty->event->input, size + 1);
d384 1
a384 1
		goto found;
d391 1
a391 1
		goto found;
d398 1
a398 1
		goto found;
d407 3
a409 4
		evbuffer_drain(tty->event->input, 1);
		bufferevent_read(tty->event, &ch, 1);
		key = ch | KEYC_ESCAPE;
		goto found;
a415 1
			evbuffer_drain(tty->event->input, size + 2);
d417 2
a418 1
			goto found;
d422 3
d426 1
a426 1
	 * Escape but no key string. If have, already seen an escape, then the
d432 1
a432 1
		goto found;
d435 3
d449 19
a467 2
found:
	evtimer_del(&tty->key_timer);
d469 1
d474 1
d480 5
a484 2
	if (tty->flags & TTY_ESCAPE)
		tty_keys_next(tty);
d487 1
a495 1
	log_debug("mouse input is: %.*s", (int) len, buf);
d499 2
@


1.14
log
@Switch tty key input over to happen on a read event. This is a bit more
complicated because of escape input, but in that case instead of processing a
key immediately, schedule a timer and reprocess the bufer when it expires.

This currently assumes that keys will be atomic (ie that if eg F1 is pressed
the entire sequence is present in the buffer). This is usually but not always
true, a change in the tree format so it can differentiate potential (partial)
key sequences will happens soon and will allow this to be fixed.
@
text
@d1 1
a1 1
/* $OpenBSD: tty-keys.c,v 1.13 2009/11/04 21:47:42 nicm Exp $ */
d32 1
a32 1
void	tty_keys_add(struct tty *, const char *, int, int);
d42 2
d200 1
a200 1
tty_keys_add(struct tty *tty, const char *s, int key, int flags)
a206 1
	tk->flags = flags;
d244 1
a244 1
		tty_keys_add(tty, s + 1, tke->key, tke->flags);
d249 1
a249 1
			tty_keys_add(tty, tmp + 1, tke->key | KEYC_CTRL, 0);
@


1.13
log
@Switch tty fds over to a bufferevent.
@
text
@d1 1
a1 1
/* $OpenBSD: tty-keys.c,v 1.12 2009/10/26 17:59:46 nicm Exp $ */
d33 1
d298 1
a298 1
tty_keys_next(struct tty *tty, int *key, struct mouse_event *mouse)
d300 8
a307 6
	struct tty_key	*tk;
	struct timeval	 tv;
	char		*buf;
	u_char		 ch;
	size_t		 len, size;
	cc_t		 bspace;
d312 1
a312 1
		return (1);
d318 1
a318 1
		*key = ch;
d326 2
a327 2
		if (bspace != _POSIX_VDISABLE && *key == bspace)
			*key = KEYC_BSPACE;
d335 1
a335 1
		*key = tk->key;
d340 2
a341 2
	*key = tty_keys_mouse(buf, len, &size, mouse);
	if (*key != KEYC_NONE) {
d347 2
a348 2
	*key = xterm_keys_find(buf, len, &size);
	if (*key != KEYC_NONE) {
a352 12
	/* Escape but no key string. If the timer isn't started, start it. */
	if (!(tty->flags & TTY_ESCAPE)) {
		tv.tv_sec = 0;
		tv.tv_usec = ESCAPE_PERIOD * 1000L;
		if (gettimeofday(&tty->key_timer, NULL) != 0)
			fatal("gettimeofday failed");
		timeradd(&tty->key_timer, &tv, &tty->key_timer);

		tty->flags |= TTY_ESCAPE;
		return (1);
	}

d361 1
a361 1
		*key = ch | KEYC_ESCAPE;
d370 1
a370 1
			*key = tk->key | KEYC_ESCAPE;
d375 20
a394 9
	/* If the timer hasn't expired, keep waiting. */
	if (gettimeofday(&tv, NULL) != 0)
		fatal("gettimeofday failed");
	if (timercmp(&tty->key_timer, &tv, >))
		return (1);

	/* Give up and return the escape. */
	evbuffer_drain(tty->event->input, 1);
	*key = '\033';
d397 2
d400 10
a409 1
	return (0);
@


1.12
log
@Not all terminals swap CSI and SS3 on ctrl, so remove that.

Also mark the rxvt special-cases as such until terminfo is updated to have
kLFT5, kRIT5 etc.
@
text
@d1 1
a1 1
/* $OpenBSD: tty-keys.c,v 1.11 2009/10/26 17:46:33 nicm Exp $ */
d302 1
d306 2
a307 2
	buf = BUFFER_OUT(tty->in);
	len = BUFFER_USED(tty->in);
d314 2
a315 1
		*key = buffer_read8(tty->in);
d331 1
a331 1
		buffer_remove(tty->in, size + 1);
d339 1
a339 1
		buffer_remove(tty->in, size);
d346 1
a346 1
		buffer_remove(tty->in, size);
d368 3
a370 2
		buffer_remove(tty->in, 1);
		*key = buffer_read8(tty->in) | KEYC_ESCAPE;
d378 1
a378 1
			buffer_remove(tty->in, size + 2);
d391 1
a391 1
	buffer_remove(tty->in, 1);
@


1.11
log
@Rewrite xterm-keys code (both input and output) so that works (doesn't always
output the same modifiers, accepts all the possible input keys) and is more
understandable.
@
text
@d1 1
a1 1
/* $OpenBSD: tty-keys.c,v 1.10 2009/10/26 16:00:51 nicm Exp $ */
d74 1
a74 5
	/*
	 * Arrow keys. There are several variants of these so just accept them.
	 * We always put the terminal into application keys mode so ctrl should
	 * swap between SS3 and CSI.
	 */
d80 4
a83 4
	{ 0,		"\033[A",	KEYC_UP|KEYC_CTRL,	TTYKEY_RAW },
	{ 0,		"\033[B",	KEYC_DOWN|KEYC_CTRL,	TTYKEY_RAW },
	{ 0,		"\033[C",	KEYC_RIGHT|KEYC_CTRL,	TTYKEY_RAW },
	{ 0,		"\033[D",	KEYC_LEFT|KEYC_CTRL,	TTYKEY_RAW },
d85 6
a99 5

	{ TTYC_KCUU1,	NULL,		KEYC_UP,		TTYKEY_CTRL },
	{ TTYC_KCUD1,	NULL,		KEYC_DOWN,		TTYKEY_CTRL },
	{ TTYC_KCUB1,	NULL,		KEYC_LEFT,		TTYKEY_CTRL },
	{ TTYC_KCUF1,	NULL,		KEYC_RIGHT,		TTYKEY_CTRL },
@


1.10
log
@Support the (mostly new) function key+modifier caps (kIC-kIC7). Most of these
will be caught (soon) by the xterm keys code in xterm itself but some other
descriptions such as rxvt define them as well.
@
text
@d1 1
a1 1
/* $OpenBSD: tty-keys.c,v 1.9 2009/10/26 13:58:02 nicm Exp $ */
d339 7
@


1.9
log
@As we always put the cursor keys into application mode, assume keys sent
with CSI have ctrl.

Also add a couple of comments.
@
text
@d1 1
a1 1
/* $OpenBSD: tty-keys.c,v 1.8 2009/10/26 13:41:46 nicm Exp $ */
d125 62
@


1.8
log
@Tidy up table.
@
text
@d1 1
a1 1
/* $OpenBSD: tty-keys.c,v 1.7 2009/10/26 13:13:33 nicm Exp $ */
d28 4
d74 5
a78 1
	/* Arrow keys. */
d84 4
a87 4
	{ 0,		"\033[A",	KEYC_UP,		TTYKEY_RAW },
	{ 0,		"\033[B",	KEYC_DOWN,		TTYKEY_RAW },
	{ 0,		"\033[C",	KEYC_RIGHT,		TTYKEY_RAW },
	{ 0,		"\033[D",	KEYC_LEFT,		TTYKEY_RAW },
d93 1
@


1.7
log
@Rename keypad keys to something more useful.
@
text
@d1 1
a1 1
/* $OpenBSD: tty-keys.c,v 1.6 2009/10/26 13:02:53 nicm Exp $ */
d41 28
a68 27
	{ TTYC_KF1,   NULL,     KEYC_F1,    TTYKEY_CTRL },
	{ TTYC_KF2,   NULL,     KEYC_F2,    TTYKEY_CTRL },
	{ TTYC_KF3,   NULL,     KEYC_F3,    TTYKEY_CTRL },
	{ TTYC_KF4,   NULL,     KEYC_F4,    TTYKEY_CTRL },
	{ TTYC_KF5,   NULL,     KEYC_F5,    TTYKEY_CTRL },
	{ TTYC_KF6,   NULL,     KEYC_F6,    TTYKEY_CTRL },
	{ TTYC_KF7,   NULL,     KEYC_F7,    TTYKEY_CTRL },
	{ TTYC_KF8,   NULL,     KEYC_F8,    TTYKEY_CTRL },
	{ TTYC_KF9,   NULL,     KEYC_F9,    TTYKEY_CTRL },
	{ TTYC_KF10,  NULL,     KEYC_F10,   TTYKEY_CTRL },
	{ TTYC_KF11,  NULL,     KEYC_F11,   TTYKEY_CTRL },
	{ TTYC_KF12,  NULL,     KEYC_F12,   TTYKEY_CTRL },
	{ TTYC_KF13,  NULL,     KEYC_F13,   TTYKEY_CTRL },
	{ TTYC_KF14,  NULL,     KEYC_F14,   TTYKEY_CTRL },
	{ TTYC_KF15,  NULL,     KEYC_F15,   TTYKEY_CTRL },
	{ TTYC_KF16,  NULL,     KEYC_F16,   TTYKEY_CTRL },
	{ TTYC_KF17,  NULL,     KEYC_F17,   TTYKEY_CTRL },
	{ TTYC_KF18,  NULL,     KEYC_F18,   TTYKEY_CTRL },
	{ TTYC_KF19,  NULL,     KEYC_F19,   TTYKEY_CTRL },
	{ TTYC_KF20,  NULL,     KEYC_F20,   TTYKEY_CTRL },
	{ TTYC_KICH1, NULL,     KEYC_IC,    TTYKEY_CTRL },
	{ TTYC_KDCH1, NULL,     KEYC_DC,    TTYKEY_CTRL },
	{ TTYC_KHOME, NULL,     KEYC_HOME,  TTYKEY_CTRL },
	{ TTYC_KEND,  NULL,     KEYC_END,   TTYKEY_CTRL },
	{ TTYC_KNP,   NULL,     KEYC_NPAGE, TTYKEY_CTRL },
	{ TTYC_KPP,   NULL,     KEYC_PPAGE, TTYKEY_CTRL },
	{ TTYC_KCBT,  NULL,	KEYC_BTAB,  TTYKEY_CTRL },
d71 23
a93 23
	{ 0,          "\033OA", KEYC_UP,    TTYKEY_RAW },
	{ 0,          "\033OB", KEYC_DOWN,  TTYKEY_RAW },
	{ 0,          "\033OC", KEYC_RIGHT, TTYKEY_RAW },
	{ 0,          "\033OD", KEYC_LEFT,  TTYKEY_RAW },

	{ 0,          "\033[A", KEYC_UP,    TTYKEY_RAW },
	{ 0,          "\033[B", KEYC_DOWN,  TTYKEY_RAW },
	{ 0,          "\033[C", KEYC_RIGHT, TTYKEY_RAW },
	{ 0,          "\033[D", KEYC_LEFT,  TTYKEY_RAW },

	{ 0,          "\033Oa", KEYC_UP | KEYC_CTRL,    TTYKEY_RAW },
	{ 0,          "\033Ob", KEYC_DOWN | KEYC_CTRL,  TTYKEY_RAW },
	{ 0,          "\033Oc", KEYC_RIGHT | KEYC_CTRL, TTYKEY_RAW },
	{ 0,          "\033Od", KEYC_LEFT | KEYC_CTRL,  TTYKEY_RAW },
	{ 0,          "\033[a", KEYC_UP | KEYC_SHIFT,    TTYKEY_RAW },
	{ 0,          "\033[b", KEYC_DOWN | KEYC_SHIFT,  TTYKEY_RAW },
	{ 0,          "\033[c", KEYC_RIGHT | KEYC_SHIFT, TTYKEY_RAW },
	{ 0,          "\033[d", KEYC_LEFT | KEYC_SHIFT,  TTYKEY_RAW },

	{ TTYC_KCUU1, NULL,     KEYC_UP,    TTYKEY_CTRL },
	{ TTYC_KCUD1, NULL,     KEYC_DOWN,  TTYKEY_CTRL },
	{ TTYC_KCUB1, NULL,     KEYC_LEFT,  TTYKEY_CTRL },
	{ TTYC_KCUF1, NULL,     KEYC_RIGHT, TTYKEY_CTRL },
d96 3
a98 8
	 * Numeric keypad. termcap and terminfo are totally confusing for this.
	 * There are definitions for some keypad keys and for function keys,
	 * but these seem to now be used for the real function keys rather than
	 * for the keypad keys in application mode (which is different from
	 * what it says in the termcap file). So, we just hardcode the vt100
	 * escape sequences here and always put the terminal into keypad_xmit
	 * mode. Translation of numbers mode/applications mode is done in
	 * input-keys.c.
d100 16
a115 16
	{ 0,          "\033Oo", KEYC_KP_SLASH,  TTYKEY_RAW },
	{ 0,          "\033Oj", KEYC_KP_STAR,   TTYKEY_RAW },
	{ 0,          "\033Om", KEYC_KP_MINUS,  TTYKEY_RAW },
	{ 0,          "\033Ow", KEYC_KP_SEVEN,  TTYKEY_RAW },
	{ 0,          "\033Ox", KEYC_KP_EIGHT,  TTYKEY_RAW },
	{ 0,          "\033Oy", KEYC_KP_NINE,   TTYKEY_RAW },
	{ 0,          "\033Ok", KEYC_KP_PLUS,   TTYKEY_RAW },
	{ 0,          "\033Ot", KEYC_KP_FOUR,   TTYKEY_RAW },
	{ 0,          "\033Ou", KEYC_KP_FIVE,   TTYKEY_RAW },
	{ 0,          "\033Ov", KEYC_KP_SIX,    TTYKEY_RAW },
	{ 0,          "\033Oq", KEYC_KP_ONE,    TTYKEY_RAW },
	{ 0,          "\033Or", KEYC_KP_TWO,    TTYKEY_RAW },
	{ 0,          "\033Os", KEYC_KP_THREE,  TTYKEY_RAW },
	{ 0,          "\033OM", KEYC_KP_ENTER,  TTYKEY_RAW },
	{ 0,          "\033Op", KEYC_KP_ZERO,   TTYKEY_RAW },
	{ 0,          "\033On", KEYC_KP_PERIOD, TTYKEY_RAW },
@


1.6
log
@Remove the xterm-keys code which is broken (a replacement is coming but some
more cleanup is needed first).
@
text
@d1 1
a1 1
/* $OpenBSD: tty-keys.c,v 1.5 2009/10/11 07:01:10 nicm Exp $ */
d104 16
a119 16
	{ 0,          "\033Oo", KEYC_KP0_1, TTYKEY_RAW },
	{ 0,          "\033Oj", KEYC_KP0_2, TTYKEY_RAW },
	{ 0,          "\033Om", KEYC_KP0_3, TTYKEY_RAW },
	{ 0,          "\033Ow", KEYC_KP1_0, TTYKEY_RAW },
	{ 0,          "\033Ox", KEYC_KP1_1, TTYKEY_RAW },
	{ 0,          "\033Oy", KEYC_KP1_2, TTYKEY_RAW },
	{ 0,          "\033Ok", KEYC_KP1_3, TTYKEY_RAW },
	{ 0,          "\033Ot", KEYC_KP2_0, TTYKEY_RAW },
	{ 0,          "\033Ou", KEYC_KP2_1, TTYKEY_RAW },
	{ 0,          "\033Ov", KEYC_KP2_2, TTYKEY_RAW },
	{ 0,          "\033Oq", KEYC_KP3_0, TTYKEY_RAW },
	{ 0,          "\033Or", KEYC_KP3_1, TTYKEY_RAW },
	{ 0,          "\033Os", KEYC_KP3_2, TTYKEY_RAW },
	{ 0,          "\033OM", KEYC_KP3_3, TTYKEY_RAW },
	{ 0,          "\033Op", KEYC_KP4_0, TTYKEY_RAW },
	{ 0,          "\033On", KEYC_KP4_2, TTYKEY_RAW },
@


1.5
log
@Clean up by introducing a wrapper struct for mouse clicks rather than passing
three u_chars around.

As a side-effect this fixes incorrectly rejecting high cursor positions
(because it was comparing them as signed char), reported by Tom Doherty.
@
text
@d1 1
a1 1
/* $OpenBSD: tty-keys.c,v 1.4 2009/09/20 14:58:12 nicm Exp $ */
d29 1
a29 2
int	tty_keys_parse_xterm(struct tty *, char *, size_t, size_t *);
int	tty_keys_parse_mouse(char *, size_t, size_t *, struct mouse_event *);
d271 1
a271 8
	*key = tty_keys_parse_mouse(buf, len, &size, mouse);
	if (*key != KEYC_NONE) {
		buffer_remove(tty->in, size);
		goto found;
	}

	/* Not found. Try to parse xterm-type arguments. */
	*key = tty_keys_parse_xterm(tty, buf, len, &size);
d326 1
a326 1
tty_keys_parse_mouse(char *buf, size_t len, size_t *size, struct mouse_event *m)
a346 65
}

int
tty_keys_parse_xterm(struct tty *tty, char *buf, size_t len, size_t *size)
{
	struct tty_key	*tk;
	char		 tmp[5];
	size_t		 tmplen;
	int		 key;

	/*
	 * xterm sequences with modifier keys are of the form:
	 *
	 * ^[[1;xD becomes ^[[D
	 * ^[[5;x~ becomes ^[[5~
	 *
	 * This function is a bit of a hack. Need to figure out what exact
	 * format and meaning xterm outputs and fix it. XXX
	 */

	log_debug("xterm input is: %.*s", (int) len, buf);
	if (len != 6 || memcmp(buf, "\033[1;", 4) != 0)
		return (KEYC_NONE);
	*size = 6;

	tmplen = 0;
	tmp[tmplen++] = '[';
	if (buf[5] == '~') {
		tmp[tmplen++] = buf[2];
		tmp[tmplen++] = '~';
	} else
		tmp[tmplen++] = buf[5];
	log_debug("xterm output is: %.*s", (int) tmplen, tmp);

	tk = tty_keys_find(tty, tmp, tmplen, size);
	if (tk == NULL)
		return (KEYC_NONE);
	key = tk->key;

	switch (buf[4]) {
	case '8':
		key |= KEYC_SHIFT|KEYC_ESCAPE|KEYC_CTRL;
		break;
	case '7':
		key |= KEYC_ESCAPE|KEYC_CTRL;
		break;
	case '6':
		key |= KEYC_SHIFT|KEYC_CTRL;
		break;
	case '5':
		key |= KEYC_CTRL;
		break;
	case '4':
		key |= KEYC_SHIFT|KEYC_ESCAPE;
		break;
	case '3':
		key |= KEYC_ESCAPE;
		break;
	case '2':
		key |= KEYC_SHIFT;
		break;
	}

	*size = 6;
	return (key);
@


1.4
log
@Regularise some fatal messages.
@
text
@d1 1
a1 1
/* $OpenBSD: tty-keys.c,v 1.3 2009/07/26 21:42:08 nicm Exp $ */
d30 1
a30 1
int	tty_keys_parse_mouse(struct tty *, char *, size_t, size_t *, u_char *);
d234 1
a234 1
tty_keys_next(struct tty *tty, int *key, u_char *mouse)
d272 1
a272 1
	*key = tty_keys_parse_mouse(tty, buf, len, &size, mouse);
d334 1
a334 2
tty_keys_parse_mouse(
    unused struct tty *tty, char *buf, size_t len, size_t *size, u_char *mouse)
d346 4
a349 1
	if (buf[3] < 32 || buf[4] < 33 || buf[5] < 33)
d351 3
a353 4

	mouse[0] = buf[3] - 32;
	mouse[1] = buf[4] - 33;
	mouse[2] = buf[5] - 33;
@


1.3
log
@Detect backspace by looking at termios VERASE and translate it into \177 (which
matches screen's behaviour if not its termcap/terminfo entry). The terminfo kbs
cap is often wrong or missing so it can't be used, and just assuming \177 may
be wrong.
@
text
@d1 1
a1 1
/* $OpenBSD: tty-keys.c,v 1.2 2009/07/21 17:57:29 nicm Exp $ */
d290 1
a290 1
			fatal("gettimeofday");
d320 1
a320 1
		fatal("gettimeofday");
@


1.2
log
@Tidy up keys: use an enum for the key codes, and remove the macros which just
wrap flag sets/clears/tests.
@
text
@d1 1
a1 1
/* $OpenBSD: tty-keys.c,v 1.1 2009/06/01 22:58:49 nicm Exp $ */
d23 2
d240 1
d251 9
@


1.1
log
@Import tmux, a terminal multiplexor allowing (among other things) a single
terminal to be switched between several different windows and programs
displayed on one terminal be detached from one terminal and moved to another.

ok deraadt pirofti
@
text
@d1 1
a1 1
/* $OpenBSD$ */
d79 8
a86 8
	{ 0,          "\033Oa", KEYC_ADDCTL(KEYC_UP),    TTYKEY_RAW },
	{ 0,          "\033Ob", KEYC_ADDCTL(KEYC_DOWN),  TTYKEY_RAW },
	{ 0,          "\033Oc", KEYC_ADDCTL(KEYC_RIGHT), TTYKEY_RAW },
	{ 0,          "\033Od", KEYC_ADDCTL(KEYC_LEFT),  TTYKEY_RAW },
	{ 0,          "\033[a", KEYC_ADDSFT(KEYC_UP),    TTYKEY_RAW },
	{ 0,          "\033[b", KEYC_ADDSFT(KEYC_DOWN),  TTYKEY_RAW },
	{ 0,          "\033[c", KEYC_ADDSFT(KEYC_RIGHT), TTYKEY_RAW },
	{ 0,          "\033[d", KEYC_ADDSFT(KEYC_LEFT),  TTYKEY_RAW },
d182 1
a182 1
			tty_keys_add(tty, tmp + 1, KEYC_ADDCTL(tke->key), 0);
d292 1
a292 1
		*key = KEYC_ADDESC(buffer_read8(tty->in));
d301 1
a301 1
			*key = KEYC_ADDESC(tk->key);
d383 1
a383 3
		key = KEYC_ADDSFT(key);
		key = KEYC_ADDESC(key);
		key = KEYC_ADDCTL(key);
d386 1
a386 2
		key = KEYC_ADDESC(key);
		key = KEYC_ADDCTL(key);
d389 1
a389 2
		key = KEYC_ADDSFT(key);
		key = KEYC_ADDCTL(key);
d392 1
a392 1
		key = KEYC_ADDCTL(key);
d395 1
a395 2
		key = KEYC_ADDSFT(key);
		key = KEYC_ADDESC(key);
d398 1
a398 1
		key = KEYC_ADDESC(key);
d401 1
a401 1
		key = KEYC_ADDSFT(key);
@

