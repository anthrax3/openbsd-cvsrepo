head	1.47;
access;
symbols
	OPENBSD_6_1:1.45.0.4
	OPENBSD_6_1_BASE:1.45
	OPENBSD_6_0:1.38.0.2
	OPENBSD_6_0_BASE:1.38
	OPENBSD_5_9:1.34.0.2
	OPENBSD_5_9_BASE:1.34
	OPENBSD_5_8:1.26.0.4
	OPENBSD_5_8_BASE:1.26
	OPENBSD_5_7:1.25.0.2
	OPENBSD_5_7_BASE:1.25
	OPENBSD_5_6:1.25.0.4
	OPENBSD_5_6_BASE:1.25
	OPENBSD_5_5:1.24.0.6
	OPENBSD_5_5_BASE:1.24
	OPENBSD_5_4:1.24.0.2
	OPENBSD_5_4_BASE:1.24
	OPENBSD_5_3:1.23.0.4
	OPENBSD_5_3_BASE:1.23
	OPENBSD_5_2:1.23.0.2
	OPENBSD_5_2_BASE:1.23
	OPENBSD_5_1_BASE:1.22
	OPENBSD_5_1:1.22.0.2
	OPENBSD_5_0:1.20.0.4
	OPENBSD_5_0_BASE:1.20
	OPENBSD_4_9:1.20.0.2
	OPENBSD_4_9_BASE:1.20
	OPENBSD_4_8:1.18.0.2
	OPENBSD_4_8_BASE:1.18
	OPENBSD_4_7:1.13.0.2
	OPENBSD_4_7_BASE:1.13
	OPENBSD_4_6:1.1.0.4
	OPENBSD_4_6_BASE:1.1;
locks; strict;
comment	@ * @;


1.47
date	2017.06.23.15.36.52;	author nicm;	state Exp;
branches;
next	1.46;
commitid	OmJmrU8DMv4xU3mr;

1.46
date	2017.06.12.07.04.24;	author nicm;	state Exp;
branches;
next	1.45;
commitid	fu4NxKu1IK7xAqw9;

1.45
date	2017.02.22.09.01.32;	author nicm;	state Exp;
branches;
next	1.44;
commitid	SKmqCZ6GhGllt9ad;

1.44
date	2017.02.01.09.55.07;	author nicm;	state Exp;
branches;
next	1.43;
commitid	FpFenXzt7GohJ3lb;

1.43
date	2017.01.11.22.36.07;	author nicm;	state Exp;
branches;
next	1.42;
commitid	HtCLmxuVeKiLFIZu;

1.42
date	2017.01.05.09.07.16;	author nicm;	state Exp;
branches;
next	1.41;
commitid	al9tcSDvFKlm4Qpq;

1.41
date	2016.11.23.16.44.42;	author nicm;	state Exp;
branches;
next	1.40;
commitid	prGwBdvGO7RpDHCa;

1.40
date	2016.10.11.09.30.36;	author nicm;	state Exp;
branches;
next	1.39;
commitid	OThpNjT1frpnaa0G;

1.39
date	2016.10.10.21.29.23;	author nicm;	state Exp;
branches;
next	1.38;
commitid	z4Hr4PZF7Ev93uEJ;

1.38
date	2016.05.26.14.49.48;	author nicm;	state Exp;
branches;
next	1.37;
commitid	hJ3l4wVH9mSkBJoS;

1.37
date	2016.04.25.17.05.53;	author nicm;	state Exp;
branches;
next	1.36;
commitid	8p0Pm5QZl0QSuwph;

1.36
date	2016.03.18.07.28.27;	author nicm;	state Exp;
branches;
next	1.35;
commitid	XKqoAZz4Rl0wxJYw;

1.35
date	2016.03.02.15.36.02;	author nicm;	state Exp;
branches;
next	1.34;
commitid	NiBVKnSIZN4ztNWB;

1.34
date	2016.01.19.15.59.12;	author nicm;	state Exp;
branches;
next	1.33;
commitid	P3qmSOx6KrDBsb0c;

1.33
date	2015.12.12.18.19.00;	author nicm;	state Exp;
branches;
next	1.32;
commitid	WD2k8ZkBSmp0TV5S;

1.32
date	2015.11.14.11.45.43;	author nicm;	state Exp;
branches;
next	1.31;
commitid	gUJFVlXRAaRAnDSU;

1.31
date	2015.11.14.10.57.59;	author nicm;	state Exp;
branches;
next	1.30;
commitid	QXPiEzv5yKH3fVUx;

1.30
date	2015.11.14.10.56.31;	author nicm;	state Exp;
branches;
next	1.29;
commitid	7oTEXFUYU5F7v5X1;

1.29
date	2015.11.12.22.04.37;	author nicm;	state Exp;
branches;
next	1.28;
commitid	fGCLUB4poNC6IhUT;

1.28
date	2015.11.12.11.05.34;	author nicm;	state Exp;
branches;
next	1.27;
commitid	Ih1tdqtjpnEyfE8x;

1.27
date	2015.10.26.22.03.04;	author nicm;	state Exp;
branches;
next	1.26;
commitid	4Bl3FJpzH5LgcBQr;

1.26
date	2015.04.19.21.34.21;	author nicm;	state Exp;
branches;
next	1.25;
commitid	wug6ctIOfhVMeWQp;

1.25
date	2014.07.21.10.25.48;	author nicm;	state Exp;
branches;
next	1.24;
commitid	uQXf8Vu4TQgRm6UX;

1.24
date	2013.03.22.10.30.04;	author nicm;	state Exp;
branches;
next	1.23;

1.23
date	2012.03.04.20.40.54;	author nicm;	state Exp;
branches;
next	1.22;

1.22
date	2012.01.21.08.40.09;	author nicm;	state Exp;
branches;
next	1.21;

1.21
date	2011.10.23.10.19.26;	author nicm;	state Exp;
branches;
next	1.20;

1.20
date	2011.01.23.11.04.25;	author nicm;	state Exp;
branches;
next	1.19;

1.19
date	2011.01.01.03.43.20;	author nicm;	state Exp;
branches;
next	1.18;

1.18
date	2010.06.06.19.00.13;	author nicm;	state Exp;
branches;
next	1.17;

1.17
date	2010.06.05.15.51.53;	author nicm;	state Exp;
branches;
next	1.16;

1.16
date	2010.05.03.09.38.03;	author mcbride;	state Exp;
branches;
next	1.15;

1.15
date	2010.04.23.14.27.04;	author nicm;	state Exp;
branches;
next	1.14;

1.14
date	2010.04.21.21.17.33;	author nicm;	state Exp;
branches;
next	1.13;

1.13
date	2010.01.14.21.53.40;	author nicm;	state Exp;
branches;
next	1.12;

1.12
date	2009.12.03.22.50.10;	author nicm;	state Exp;
branches;
next	1.11;

1.11
date	2009.11.26.22.56.59;	author nicm;	state Exp;
branches;
next	1.10;

1.10
date	2009.11.10.17.24.43;	author nicm;	state Exp;
branches;
next	1.9;

1.9
date	2009.10.26.13.13.33;	author nicm;	state Exp;
branches;
next	1.8;

1.8
date	2009.10.06.07.32.26;	author nicm;	state Exp;
branches;
next	1.7;

1.7
date	2009.10.04.08.50.05;	author nicm;	state Exp;
branches;
next	1.6;

1.6
date	2009.07.28.09.18.01;	author nicm;	state Exp;
branches;
next	1.5;

1.5
date	2009.07.26.21.42.08;	author nicm;	state Exp;
branches;
next	1.4;

1.4
date	2009.07.24.14.57.22;	author nicm;	state Exp;
branches;
next	1.3;

1.3
date	2009.07.21.17.57.29;	author nicm;	state Exp;
branches;
next	1.2;

1.2
date	2009.07.14.06.56.30;	author nicm;	state Exp;
branches;
next	1.1;

1.1
date	2009.06.01.22.58.49;	author nicm;	state Exp;
branches;
next	;


desc
@@


1.47
log
@Add user-keys option to allow user-defined keys to be set, from Dan
Aloni.
@
text
@/* $OpenBSD: key-string.c,v 1.46 2017/06/12 07:04:24 nicm Exp $ */

/*
 * Copyright (c) 2007 Nicholas Marriott <nicholas.marriott@@gmail.com>
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF MIND, USE, DATA OR PROFITS, WHETHER
 * IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING
 * OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */

#include <sys/types.h>

#include <string.h>

#include "tmux.h"

static key_code	key_string_search_table(const char *);
static key_code	key_string_get_modifiers(const char **);

static const struct {
	const char     *string;
	key_code	key;
} key_string_table[] = {
	/* Function keys. */
	{ "F1",		KEYC_F1 },
	{ "F2",		KEYC_F2 },
	{ "F3",		KEYC_F3 },
	{ "F4",		KEYC_F4 },
	{ "F5",		KEYC_F5 },
	{ "F6",		KEYC_F6 },
	{ "F7",		KEYC_F7 },
	{ "F8",		KEYC_F8 },
	{ "F9",		KEYC_F9 },
	{ "F10",	KEYC_F10 },
	{ "F11",	KEYC_F11 },
	{ "F12",	KEYC_F12 },
	{ "IC",		KEYC_IC },
	{ "DC",		KEYC_DC },
	{ "Home",	KEYC_HOME },
	{ "End",	KEYC_END },
	{ "NPage",	KEYC_NPAGE },
	{ "PageDown",	KEYC_NPAGE },
	{ "PgDn",	KEYC_NPAGE },
	{ "PPage",	KEYC_PPAGE },
	{ "PageUp",	KEYC_PPAGE },
	{ "PgUp",	KEYC_PPAGE },
	{ "Tab",	'\011' },
	{ "BTab",	KEYC_BTAB },
	{ "Space",	' ' },
	{ "BSpace",	KEYC_BSPACE },
	{ "Enter",	'\r' },
	{ "Escape",	'\033' },

	/* Arrow keys. */
	{ "Up",		KEYC_UP },
	{ "Down",	KEYC_DOWN },
	{ "Left",	KEYC_LEFT },
	{ "Right",	KEYC_RIGHT },

	/* Numeric keypad. */
	{ "KP/", 	KEYC_KP_SLASH },
	{ "KP*",	KEYC_KP_STAR },
	{ "KP-",	KEYC_KP_MINUS },
	{ "KP7",	KEYC_KP_SEVEN },
	{ "KP8",	KEYC_KP_EIGHT },
	{ "KP9",	KEYC_KP_NINE },
	{ "KP+",	KEYC_KP_PLUS },
	{ "KP4",	KEYC_KP_FOUR },
	{ "KP5",	KEYC_KP_FIVE },
	{ "KP6",	KEYC_KP_SIX },
	{ "KP1",	KEYC_KP_ONE },
	{ "KP2",	KEYC_KP_TWO },
	{ "KP3",	KEYC_KP_THREE },
	{ "KPEnter",	KEYC_KP_ENTER },
	{ "KP0",	KEYC_KP_ZERO },
	{ "KP.",	KEYC_KP_PERIOD },

	/* Mouse keys. */
	KEYC_MOUSE_STRING(MOUSEDOWN1, MouseDown1),
	KEYC_MOUSE_STRING(MOUSEDOWN2, MouseDown2),
	KEYC_MOUSE_STRING(MOUSEDOWN3, MouseDown3),
	KEYC_MOUSE_STRING(MOUSEUP1, MouseUp1),
	KEYC_MOUSE_STRING(MOUSEUP2, MouseUp2),
	KEYC_MOUSE_STRING(MOUSEUP3, MouseUp3),
	KEYC_MOUSE_STRING(MOUSEDRAG1, MouseDrag1),
	KEYC_MOUSE_STRING(MOUSEDRAG2, MouseDrag2),
	KEYC_MOUSE_STRING(MOUSEDRAG3, MouseDrag3),
	KEYC_MOUSE_STRING(MOUSEDRAGEND1, MouseDragEnd1),
	KEYC_MOUSE_STRING(MOUSEDRAGEND2, MouseDragEnd2),
	KEYC_MOUSE_STRING(MOUSEDRAGEND3, MouseDragEnd3),
	KEYC_MOUSE_STRING(WHEELUP, WheelUp),
	KEYC_MOUSE_STRING(WHEELDOWN, WheelDown),
	KEYC_MOUSE_STRING(DOUBLECLICK1, DoubleClick1),
	KEYC_MOUSE_STRING(DOUBLECLICK2, DoubleClick2),
	KEYC_MOUSE_STRING(DOUBLECLICK3, DoubleClick3),
	KEYC_MOUSE_STRING(TRIPLECLICK1, TripleClick1),
	KEYC_MOUSE_STRING(TRIPLECLICK2, TripleClick2),
	KEYC_MOUSE_STRING(TRIPLECLICK3, TripleClick3),
};

/* Find key string in table. */
static key_code
key_string_search_table(const char *string)
{
	u_int	i, user;

	for (i = 0; i < nitems(key_string_table); i++) {
		if (strcasecmp(string, key_string_table[i].string) == 0)
			return (key_string_table[i].key);
	}

	if (sscanf(string, "User%u", &user) == 1 && user < KEYC_NUSER)
		return (KEYC_USER + user);

	return (KEYC_UNKNOWN);
}

/* Find modifiers. */
static key_code
key_string_get_modifiers(const char **string)
{
	key_code	modifiers;

	modifiers = 0;
	while (((*string)[0] != '\0') && (*string)[1] == '-') {
		switch ((*string)[0]) {
		case 'C':
		case 'c':
			modifiers |= KEYC_CTRL;
			break;
		case 'M':
		case 'm':
			modifiers |= KEYC_ESCAPE;
			break;
		case 'S':
		case 's':
			modifiers |= KEYC_SHIFT;
			break;
		default:
			*string = NULL;
			return (0);
		}
		*string += 2;
	}
	return (modifiers);
}

/* Lookup a string and convert to a key value. */
key_code
key_string_lookup_string(const char *string)
{
	static const char	*other = "!#()+,-.0123456789:;<=>?'\r\t";
	key_code		 key;
	u_int			 u;
	key_code		 modifiers;
	struct utf8_data	 ud;
	u_int			 i;
	enum utf8_state		 more;
	wchar_t			 wc;

	/* Is this no key? */
	if (strcasecmp(string, "None") == 0)
		return (KEYC_NONE);

	/* Is this a hexadecimal value? */
	if (string[0] == '0' && string[1] == 'x') {
	        if (sscanf(string + 2, "%x", &u) != 1)
	                return (KEYC_UNKNOWN);
		if (u > 0x1fffff)
	                return (KEYC_UNKNOWN);
	        return (u);
	}

	/* Check for modifiers. */
	modifiers = 0;
	if (string[0] == '^' && string[1] != '\0') {
		modifiers |= KEYC_CTRL;
		string++;
	}
	modifiers |= key_string_get_modifiers(&string);
	if (string == NULL || string[0] == '\0')
		return (KEYC_UNKNOWN);

	/* Is this a standard ASCII key? */
	if (string[1] == '\0' && (u_char)string[0] <= 127) {
		key = (u_char)string[0];
		if (key < 32 || key == 127)
			return (KEYC_UNKNOWN);
	} else {
		/* Try as a UTF-8 key. */
		if ((more = utf8_open(&ud, (u_char)*string)) == UTF8_MORE) {
			if (strlen(string) != ud.size)
				return (KEYC_UNKNOWN);
			for (i = 1; i < ud.size; i++)
				more = utf8_append(&ud, (u_char)string[i]);
			if (more != UTF8_DONE)
				return (KEYC_UNKNOWN);
			if (utf8_combine(&ud, &wc) != UTF8_DONE)
				return (KEYC_UNKNOWN);
			return (wc | modifiers);
		}

		/* Otherwise look the key up in the table. */
		key = key_string_search_table(string);
		if (key == KEYC_UNKNOWN)
			return (KEYC_UNKNOWN);
	}

	/* Convert the standard control keys. */
	if (key < KEYC_BASE && (modifiers & KEYC_CTRL) && !strchr(other, key)) {
		if (key >= 97 && key <= 122)
			key -= 96;
		else if (key >= 64 && key <= 95)
			key -= 64;
		else if (key == 32)
			key = 0;
		else if (key == 63)
			key = KEYC_BSPACE;
		else
			return (KEYC_UNKNOWN);
		modifiers &= ~KEYC_CTRL;
	}

	return (key | modifiers);
}

/* Convert a key code into string format, with prefix if necessary. */
const char *
key_string_lookup_key(key_code key)
{
	static char		out[32];
	char			tmp[8];
	u_int			i;
	struct utf8_data	ud;
	size_t			off;

	*out = '\0';

	/* Handle no key. */
	if (key == KEYC_NONE)
		return ("None");

	/* Handle special keys. */
	if (key == KEYC_UNKNOWN)
		return ("Unknown");
	if (key == KEYC_FOCUS_IN)
		return ("FocusIn");
	if (key == KEYC_FOCUS_OUT)
		return ("FocusOut");
	if (key == KEYC_PASTE_START)
		return ("PasteStart");
	if (key == KEYC_PASTE_END)
		return ("PasteEnd");
	if (key == KEYC_MOUSE)
		return ("Mouse");
	if (key == KEYC_DRAGGING)
		return ("Dragging");
	if (key == KEYC_MOUSEMOVE_PANE)
		return ("MouseMovePane");
	if (key == KEYC_MOUSEMOVE_STATUS)
		return ("MouseMoveStatus");
	if (key == KEYC_MOUSEMOVE_BORDER)
		return ("MouseMoveBorder");
	if (key >= KEYC_USER && key < KEYC_USER + KEYC_NUSER) {
		snprintf(out, sizeof out, "User%u", (u_int)(key - KEYC_USER));
		return (out);
	}

	/*
	 * Special case: display C-@@ as C-Space. Could do this below in
	 * the (key >= 0 && key <= 32), but this way we let it be found
	 * in key_string_table, for the unlikely chance that we might
	 * change its name.
	 */
	if ((key & KEYC_MASK_KEY) == 0)
	    key = ' ' | KEYC_CTRL | (key & KEYC_MASK_MOD);

	/* Fill in the modifiers. */
	if (key & KEYC_CTRL)
		strlcat(out, "C-", sizeof out);
	if (key & KEYC_ESCAPE)
		strlcat(out, "M-", sizeof out);
	if (key & KEYC_SHIFT)
		strlcat(out, "S-", sizeof out);
	key &= KEYC_MASK_KEY;

	/* Try the key against the string table. */
	for (i = 0; i < nitems(key_string_table); i++) {
		if (key == key_string_table[i].key)
			break;
	}
	if (i != nitems(key_string_table)) {
		strlcat(out, key_string_table[i].string, sizeof out);
		return (out);
	}

	/* Is this a UTF-8 key? */
	if (key > 127 && key < KEYC_BASE) {
		if (utf8_split(key, &ud) == UTF8_DONE) {
			off = strlen(out);
			memcpy(out + off, ud.data, ud.size);
			out[off + ud.size] = '\0';
			return (out);
		}
	}

	/* Invalid keys are errors. */
	if (key == 127 || key > 255) {
		snprintf(out, sizeof out, "Invalid#%llx", key);
		return (out);
	}

	/* Check for standard or control key. */
	if (key <= 32) {
		if (key == 0 || key > 26)
			xsnprintf(tmp, sizeof tmp, "C-%c", (int)(64 + key));
		else
			xsnprintf(tmp, sizeof tmp, "C-%c", (int)(96 + key));
	} else if (key >= 32 && key <= 126) {
		tmp[0] = key;
		tmp[1] = '\0';
	} else if (key >= 128)
		xsnprintf(tmp, sizeof tmp, "\\%llo", key);

	strlcat(out, tmp, sizeof out);
	return (out);
}
@


1.46
log
@Add explicit keys for the bracketed paste sequences, both to avoid mix
ups with other keys and to make logs clearer.
@
text
@d1 1
a1 1
/* $OpenBSD: key-string.c,v 1.45 2017/02/22 09:01:32 nicm Exp $ */
d113 1
a113 1
	u_int	i;
d119 4
d272 4
@


1.45
log
@Minor bits: fix an array size, add comment, make grid_cell_entry static.
@
text
@d1 1
a1 1
/* $OpenBSD: key-string.c,v 1.44 2017/02/01 09:55:07 nicm Exp $ */
d254 4
@


1.44
log
@Implement "all event" (1003) mouse mode but in a way that works. The
main issue is that if we have two panes, A with 1002 and B with 1003, we
need to set 1003 outside tmux in order to get all the mouse events, but
then we need to suppress the ones that pane A doesn't want. This is easy
in SGR mouse mode, because buttons == 3 is only used for movement events
(for other events the trailing m/M marks a release instead), but in
normal mouse mode we can't tell so easily. So for that, look at the
previous event instead - if it is drag+release as well, then the current
event is a movement event.
@
text
@d1 1
a1 1
/* $OpenBSD: key-string.c,v 1.43 2017/01/11 22:36:07 nicm Exp $ */
d235 1
a235 1
	static char		out[24];
@


1.43
log
@Add some missing special keys to key_string_lookup_key, fix a mouse
check in server_client_handle_key, and tweak a comment.
@
text
@d1 1
a1 1
/* $OpenBSD: key-string.c,v 1.42 2017/01/05 09:07:16 nicm Exp $ */
d258 6
@


1.42
log
@Highlight all occurrences of search string after searching in copy mode.
@
text
@d1 1
a1 1
/* $OpenBSD: key-string.c,v 1.41 2016/11/23 16:44:42 nicm Exp $ */
d250 4
d256 2
@


1.41
log
@Error on invalid modifier keys.
@
text
@d1 1
a1 1
/* $OpenBSD: key-string.c,v 1.40 2016/10/11 09:30:36 nicm Exp $ */
d145 1
a145 1
			return 0;
@


1.40
log
@Support double and triple clicks (they are cumulative, so double is
fired then triple), and use for select-word and select-line in copy
mode. Inspired by a different solution from Omar Sandoval.
@
text
@d1 1
a1 1
/* $OpenBSD: key-string.c,v 1.39 2016/10/10 21:29:23 nicm Exp $ */
d143 3
d185 1
a185 1
	if (string[0] == '\0')
@


1.39
log
@Loads more static, except for cmd-*.c and window-*.c.
@
text
@d1 1
a1 1
/* $OpenBSD: key-string.c,v 1.38 2016/05/26 14:49:48 nicm Exp $ */
d101 6
@


1.38
log
@Extend 0x1234 keys form to more bits so that Unicode keys work.
@
text
@d1 1
a1 1
/* $OpenBSD: key-string.c,v 1.37 2016/04/25 17:05:53 nicm Exp $ */
d28 1
a28 1
const struct {
@


1.37
log
@Don't overwrite modifiers in the buffer when making UTF-8 strings,
append instead.
@
text
@d1 1
a1 1
/* $OpenBSD: key-string.c,v 1.36 2016/03/18 07:28:27 nicm Exp $ */
d149 1
a149 2
	u_short			 u;
	int			 size;
d162 3
a164 1
	        if (sscanf(string + 2, "%hx%n", &u, &size) != 1 || size > 4)
@


1.36
log
@Instead of reusing MouseUp at the finish of a drag, add a new key
MouseDragEnd. It can be useful to bind them separately in copy mode.
@
text
@d1 1
a1 1
/* $OpenBSD: key-string.c,v 1.35 2016/03/02 15:36:02 nicm Exp $ */
d229 1
d274 3
a276 2
			memcpy(out, ud.data, ud.size);
			out[ud.size] = '\0';
@


1.35
log
@Handle wcwidth() and mbtowc() failures in better style and drop
characters where we can't find the width (wcwidth() fails) on input, the
same as we drop invalid UTF-8. Suggested by schwarze@@.
@
text
@d1 1
a1 1
/* $OpenBSD: key-string.c,v 1.34 2016/01/19 15:59:12 nicm Exp $ */
d96 3
@


1.34
log
@I no longer use my SourceForge address so replace it.
@
text
@d1 1
a1 1
/* $OpenBSD: key-string.c,v 1.33 2015/12/12 18:19:00 nicm Exp $ */
d152 1
d189 3
a191 2
			key = utf8_combine(&ud);
			return (key | modifiers);
@


1.33
log
@Allow prefix and prefix2 to be set to None to disable (useful if you
would rather bind the prefix in the root table).
@
text
@d1 1
a1 1
/* $OpenBSD: key-string.c,v 1.32 2015/11/14 11:45:43 nicm Exp $ */
d4 1
a4 1
 * Copyright (c) 2007 Nicholas Marriott <nicm@@users.sourceforge.net>
@


1.32
log
@All these return values from utf8_* are confusing, use an enum.
@
text
@d1 1
a1 1
/* $OpenBSD: key-string.c,v 1.31 2015/11/14 10:57:59 nicm Exp $ */
d25 2
a26 2
key_code	key_string_search_table(const char *);
key_code	key_string_get_modifiers(const char **);
d101 1
a101 1
key_code
d110 1
a110 1
	return (KEYC_NONE);
d114 1
a114 1
key_code
d153 4
d160 1
a160 1
	                return (KEYC_NONE);
d172 1
a172 1
		return (KEYC_NONE);
d178 1
a178 1
			return (KEYC_NONE);
d183 1
a183 1
				return (KEYC_NONE);
d187 1
a187 1
				return (KEYC_NONE);
d194 2
a195 2
		if (key == KEYC_NONE)
			return (KEYC_NONE);
d209 1
a209 1
			return (KEYC_NONE);
d229 5
a233 1
		return ("<NONE>");
d235 1
a235 1
		return ("<MOUSE>");
d276 1
a276 1
		snprintf(out, sizeof out, "<INVALID#%llx>", key);
@


1.31
log
@Couple of assignments to remove compiler warnings.
@
text
@d1 1
a1 1
/* $OpenBSD: key-string.c,v 1.30 2015/11/14 10:56:31 nicm Exp $ */
d147 1
a147 1
	int			 size, more;
d151 1
d177 1
a177 1
		if (utf8_open(&ud, (u_char)*string)) {
a179 1
			more = 1;
d182 1
a182 1
			if (more != 0)
d259 1
a259 1
		if (utf8_split(key, &ud) == 0) {
@


1.30
log
@Be more strict about invalid UTF-8.
@
text
@d1 1
a1 1
/* $OpenBSD: key-string.c,v 1.29 2015/11/12 22:04:37 nicm Exp $ */
d179 1
@


1.29
log
@Rename overly-long utf8data to ud throughout.
@
text
@d1 1
a1 1
/* $OpenBSD: key-string.c,v 1.28 2015/11/12 11:05:34 nicm Exp $ */
d147 1
a147 1
	int			 size;
d180 3
a182 1
				utf8_append(&ud, (u_char)string[i]);
@


1.28
log
@Support UTF-8 key bindings by expanding the key type from int to
uint64_t and converting UTF-8 to Unicode on input and the reverse on
output. (This allows key bindings, there are still omissions - the
largest being that the various prompts do not accept UTF-8.)
@
text
@d1 1
a1 1
/* $OpenBSD: key-string.c,v 1.27 2015/10/26 22:03:04 nicm Exp $ */
d149 1
a149 1
	struct utf8_data	 utf8data;
d176 2
a177 2
		if (utf8_open(&utf8data, (u_char)*string)) {
			if (strlen(string) != utf8data.size)
d179 3
a181 3
			for (i = 1; i < utf8data.size; i++)
				utf8_append(&utf8data, (u_char)string[i]);
			key = utf8_combine(&utf8data);
d216 1
a216 1
	struct utf8_data	utf8data;
d256 3
a258 3
		if (utf8_split(key, &utf8data) == 0) {
			memcpy(out, utf8data.data, utf8data.size);
			out[utf8data.size] = '\0';
@


1.27
log
@Handle unknown keys more gracefully, return a string instead of NULL.
@
text
@d1 1
a1 1
/* $OpenBSD: key-string.c,v 1.26 2015/04/19 21:34:21 nicm Exp $ */
d25 2
a26 2
int	key_string_search_table(const char *);
int	key_string_get_modifiers(const char **);
d30 1
a30 1
	int	 	key;
d101 1
a101 1
int
d114 1
a114 1
int
d117 1
a117 1
	int	modifiers;
d141 1
a141 1
int
d145 1
a145 1
	int			 key, modifiers;
d148 3
d170 3
a172 3
	if (string[1] == '\0') {
		key = (u_char) string[0];
		if (key < 32 || key == 127 || key > 255)
d175 10
d211 1
a211 1
key_string_lookup_key(int key)
d213 4
a216 3
	static char	out[24];
	char		tmp[8];
	u_int		i;
d254 9
d265 1
a265 1
		snprintf(out, sizeof out, "<INVALID#%04x>", key);
d270 1
a270 1
	if (key >= 0 && key <= 32) {
d272 1
a272 1
			xsnprintf(tmp, sizeof tmp, "C-%c", 64 + key);
d274 1
a274 1
			xsnprintf(tmp, sizeof tmp, "C-%c", 96 + key);
d279 1
a279 1
		xsnprintf(tmp, sizeof tmp, "\\%o", key);
@


1.26
log
@Rewrite of tmux mouse support which was a mess. Instead of having
options for "mouse-this" and "mouse-that", mouse events may be bound as
keys and there is one option "mouse" that turns on mouse support
entirely (set -g mouse on).

See the new MOUSE SUPPORT section of the man page for description of the
key names and new flags (-t= to specify the pane or window under mouse
as a target, and send-keys -M to pass through a mouse event).

The default builtin bindings for the mouse are:

    bind -n   MouseDown1Pane select-pane -t=; send-keys -M
    bind -n MouseDown1Status select-window -t=
    bind -n   MouseDrag1Pane copy-mode -M
    bind -n MouseDrag1Border resize-pane -M

To get the effect of turning mode-mouse off, do:

    unbind -n MouseDrag1Pane
    unbind -temacs-copy MouseDrag1Pane

The old mouse options are now gone, set-option -q may be used to
suppress warnings if mixing configuration files.
@
text
@d1 1
a1 1
/* $OpenBSD: key-string.c,v 1.25 2014/07/21 10:25:48 nicm Exp $ */
d241 4
a244 2
	if (key == 127 || key > 255)
		return (NULL);
@


1.25
log
@Drop explicit support for F13-F20 and change to match the xterm terminfo
entry:

        F13-F24 are S-F1 to S-F12
        F25-F36 are C-F1 to C-F12
        F37-F48 are C-S-F1 to C-S-F12
        F49-F60 are M-F1 to M-F12
and     F61-F63 are M-S-F1 to M-S-F3

This should be no difference for applications inside tmux, but means
that any key binding for F13 will need to be replaced by S-F1 and so on.
@
text
@d1 1
a1 1
/* $OpenBSD: key-string.c,v 1.24 2013/03/22 10:30:04 nicm Exp $ */
d85 13
d208 3
a210 1
		return ("none");
@


1.24
log
@In terminals with XT, turn on modifyOtherKeys=1 with the escape sequence
and handle the most common set. Pass them through if xterm-keys is on.
@
text
@d1 1
a1 1
/* $OpenBSD: key-string.c,v 1.23 2012/03/04 20:40:54 nicm Exp $ */
a44 8
	{ "F13",	KEYC_F13 },
	{ "F14",	KEYC_F14 },
	{ "F15",	KEYC_F15 },
	{ "F16",	KEYC_F16 },
	{ "F17",	KEYC_F17 },
	{ "F18",	KEYC_F18 },
	{ "F19",	KEYC_F19 },
	{ "F20",	KEYC_F20 },
@


1.23
log
@Accept hex values as keys, needed for send-keys, based on a diff from
George Nachman.
@
text
@d1 1
a1 1
/* $OpenBSD: key-string.c,v 1.22 2012/01/21 08:40:09 nicm Exp $ */
d139 4
a142 3
	int	key, modifiers;
	u_short	u;
	int	size;
d174 1
a174 1
	if (key < KEYC_BASE && (modifiers & KEYC_CTRL)) {
d197 1
a197 1
	u_int	   	i;
@


1.22
log
@Drop the ability to have a list of keys in the prefix in favour of two
separate options, prefix and prefix2. This simplifies the code and gets
rid the data options type which was only used for this one option.

Also add a -2 flag to send-prefix to send the secondary prefix key,
fixing a cause of minor irritation.

People who want three prefix keys are out of luck :-).
@
text
@d1 1
a1 1
/* $OpenBSD: key-string.c,v 1.21 2011/10/23 10:19:26 nicm Exp $ */
d140 9
@


1.21
log
@Alias NPage/PPage as PageDown/PgDn/PageUp/PgUp to reduce occasional
confusion.
@
text
@d1 1
a1 1
/* $OpenBSD: key-string.c,v 1.20 2011/01/23 11:04:25 nicm Exp $ */
d190 4
@


1.20
log
@Allow top-bit-set characters to be used for key bindings, from Tiago
Cunha.
@
text
@d1 1
a1 1
/* $OpenBSD: key-string.c,v 1.19 2011/01/01 03:43:20 nicm Exp $ */
d58 2
d61 2
@


1.19
log
@Last few tables that should be const.
@
text
@d1 1
a1 1
/* $OpenBSD: key-string.c,v 1.18 2010/06/06 19:00:13 nicm Exp $ */
d150 1
a150 1
		if (key < 32 || key > 126)
d216 1
a216 1
	if (key >= 127)
d228 3
a230 1
	}
@


1.18
log
@Use a macro-based mask for obtaining a key or modifier-set from the
combination. Display C-@@, etc, as C-Space, in list-keys. By Micah Cowan.
@
text
@d1 1
a1 1
/* $OpenBSD: key-string.c,v 1.17 2010/06/05 15:51:53 nicm Exp $ */
d28 1
a28 1
struct {
@


1.17
log
@Fix binding of C-Space/C-@@, from Micah Cowan.
@
text
@d1 1
a1 1
/* $OpenBSD: key-string.c,v 1.16 2010/05/03 09:38:03 mcbride Exp $ */
d187 9
d203 1
a203 1
	key &= ~(KEYC_CTRL|KEYC_ESCAPE|KEYC_SHIFT);
@


1.16
log
@Make C-] and other punctuation-based control key combinations work again.

ok nicm
@
text
@d1 1
a1 1
/* $OpenBSD: key-string.c,v 1.15 2010/04/23 14:27:04 nicm Exp $ */
d152 6
d159 13
a171 16
		/* Convert the standard control keys. */
		if (modifiers & KEYC_CTRL) {
			if (key >= 97 && key <= 122)
				key -= 96;
			else if (key >= 64 && key <= 95)
				key -= 64;
			else if (key == 32)
				key = 0;
			else if (key == 63)
				key = KEYC_BSPACE;
			else
				return (KEYC_NONE);
			modifiers &= ~KEYC_CTRL;
		}

		return (key | modifiers);
a173 4
	/* Otherwise look the key up in the table. */
	key = key_string_search_table(string);
	if (key == KEYC_NONE)
		return (KEYC_NONE);
@


1.15
log
@When converting A-Z into a control character, want to subtract 64 not
65... whoops.
@
text
@d1 1
a1 1
/* $OpenBSD: key-string.c,v 1.14 2010/04/21 21:17:33 nicm Exp $ */
d157 1
a157 1
			else if (key >= 65 && key <= 90)
@


1.14
log
@Rewrite key string conversions to be readable and to work properly for
multiple modifiers.
@
text
@d1 1
a1 1
/* $OpenBSD: key-string.c,v 1.13 2010/01/14 21:53:40 nicm Exp $ */
d158 1
a158 1
				key -= 65;
@


1.13
log
@Permit S- prefix on keys for shift. Relatively few terminals support this
(basically xterm only) and even fewer have them in terminfo (kLFT2 and kRIT2).
@
text
@d1 1
a1 1
/* $OpenBSD: key-string.c,v 1.12 2009/12/03 22:50:10 nicm Exp $ */
d26 1
d29 2
a30 2
	const char *string;
	int	 key;
d104 28
a131 1
/* Lookup a string and convert to a key value, handling C-/M-/S- prefix. */
d135 1
a135 2
	int	      	 key;
	const char	*ptr;
d137 7
a145 2
	if (string[1] == '\0')
		return ((u_char) string[0]);
d147 4
a150 7
	ptr = NULL;
	if ((string[0] == 'C' || string[0] == 'c') && string[1] == '-')
		ptr = string + 2;
	else if (string[0] == '^')
		ptr = string + 1;
	if (ptr != NULL) {
		if (ptr[0] == '\0')
a151 30
		/*
		 * Lookup as a named key. If a function key (>= KEYC_BASE),
		 * return it with the ctrl modifier, otherwise fallthrough with
		 * the key value from the table (eg for C-Space). If not a
		 * named key, check for single character keys and try that.
		 */
		key = key_string_search_table(ptr);
		if (key != KEYC_NONE) {
			if (key >= KEYC_BASE)
				return (key | KEYC_CTRL);
		} else {
			if (ptr[1] != '\0')
				return (KEYC_NONE);
			key = (u_char) ptr[0];
		}

		/*
		 * Figure out if the single character in key is a valid ctrl
		 * key.
		 */
		if (key == 32)
			return (0);
		if (key == 63)
			return (KEYC_BSPACE);
		if (key >= 64 && key <= 95)
			return (key - 64);
		if (key >= 97 && key <= 122)
			return (key - 96);
		return (KEYC_NONE);
	}
d153 11
a163 10
	if ((string[0] == 'M' || string[0] == 'm') && string[1] == '-') {
		ptr = string + 2;
		if (ptr[0] == '\0')
			return (KEYC_NONE);
		key = key_string_lookup_string(ptr);
		if (key != KEYC_NONE) {
			if (key >= KEYC_BASE)
				return (key | KEYC_ESCAPE);
		} else {
			if (ptr[1] == '\0')
d165 1
a165 1
			key = (u_char) ptr[0];
d168 1
a168 3
		if (key >= 32 && key <= 127)
			return (key | KEYC_ESCAPE);
		return (KEYC_NONE);
d171 3
a173 16
	if ((string[0] == 'S' || string[0] == 's') && string[1] == '-') {
		ptr = string + 2;
		if (ptr[0] == '\0')
			return (KEYC_NONE);
		key = key_string_lookup_string(ptr);
		if (key != KEYC_NONE) {
			if (key >= KEYC_BASE)
				return (key | KEYC_SHIFT);
		} else {
			if (ptr[1] == '\0')
				return (KEYC_NONE);
			key = (u_char) ptr[0];
		}

		if (key >= 32 && key <= 127)
			return (key | KEYC_SHIFT);
d175 1
a175 3
	}

	return (key_string_search_table(string));
d182 14
a195 25
	static char tmp[24], tmp2[24];
	const char *s;
	u_int	    i;

	if (key == 127)
		return (NULL);

	if (key & KEYC_ESCAPE) {
		if ((s = key_string_lookup_key(key & ~KEYC_ESCAPE)) == NULL)
			return (NULL);
		xsnprintf(tmp2, sizeof tmp2, "M-%s", s);
		return (tmp2);
	}
	if (key & KEYC_CTRL) {
		if ((s = key_string_lookup_key(key & ~KEYC_CTRL)) == NULL)
			return (NULL);
		xsnprintf(tmp2, sizeof tmp2, "C-%s", s);
		return (tmp2);
	}
	if (key & KEYC_SHIFT) {
		if ((s = key_string_lookup_key(key & ~KEYC_SHIFT)) == NULL)
			return (NULL);
		xsnprintf(tmp2, sizeof tmp2, "S-%s", s);
		return (tmp2);
	}
d197 1
d200 5
a204 1
			return (key_string_table[i].string);
d207 3
a209 5
	if (key >= 32 && key <= 255) {
		tmp[0] = (char) key;
		tmp[1] = '\0';
		return (tmp);
	}
d211 1
d217 3
a219 1
		return (tmp);
d221 2
a222 2

	return (NULL);
@


1.12
log
@Massive spaces->tabs and trailing whitespace cleanup, hopefully for the last
time now I've configured emacs to make them displayed in really annoying
colours...
@
text
@d1 1
a1 1
/* $OpenBSD: key-string.c,v 1.11 2009/11/26 22:56:59 nicm Exp $ */
d170 19
@


1.11
log
@Make types clearer and lint happier.
@
text
@d1 1
a1 1
/* $OpenBSD: key-string.c,v 1.10 2009/11/10 17:24:43 nicm Exp $ */
d139 1
a139 1
		/* 
d153 1
a153 1
	
@


1.10
log
@Lookup key as a named key (eg 'Space') before checking for single character
keys, makes C-Space/M-Space etc resolve to the correct key code.
@
text
@d1 1
a1 1
/* $OpenBSD: key-string.c,v 1.9 2009/10/26 13:13:33 nicm Exp $ */
d108 1
a108 1
	const u_char	*ptr;
d113 1
a113 1
		return (string[0]);
d136 1
a136 1
			key = ptr[0];
d165 1
a165 1
			key = ptr[0];
d212 1
a212 1
		tmp[0] = key;
@


1.9
log
@Rename keypad keys to something more useful.
@
text
@d1 1
a1 1
/* $OpenBSD: key-string.c,v 1.8 2009/10/06 07:32:26 nicm Exp $ */
d90 1
d103 1
d123 14
a136 10
		if (ptr[1] == '\0') {
			if (ptr[0] == 32)
				return (0);
			if (ptr[0] == 63)
				return (KEYC_BSPACE);
			if (ptr[0] >= 64 && ptr[0] <= 95)
				return (ptr[0] - 64);
			if (ptr[0] >= 97 && ptr[0] <= 122)
				return (ptr[0] - 96);
			return (KEYC_NONE);
d138 13
a150 3
		key = key_string_search_table(ptr);
		if (key != KEYC_NONE)
			return (key | KEYC_CTRL);
d158 6
a163 2
		if (ptr[1] == '\0') {
			if (ptr[0] < 32 || ptr[0] > 127)
d165 1
a165 1
			return (ptr[0] | KEYC_ESCAPE);
d167 2
a168 2
		key = key_string_lookup_string(ptr);
		if (key != KEYC_NONE)
d176 1
@


1.8
log
@Accept ^? for backspace as well as BSpace.
@
text
@d1 1
a1 1
/* $OpenBSD: key-string.c,v 1.7 2009/10/04 08:50:05 nicm Exp $ */
d72 16
a87 16
	{ "KP/", 	KEYC_KP0_1 },
	{ "KP*",	KEYC_KP0_2 },
	{ "KP-",	KEYC_KP0_3 },
	{ "KP7",	KEYC_KP1_0 },
	{ "KP8",	KEYC_KP1_1 },
	{ "KP9",	KEYC_KP1_2 },
	{ "KP+",	KEYC_KP1_3 },
	{ "KP4",	KEYC_KP2_0 },
	{ "KP5",	KEYC_KP2_1 },
	{ "KP6",	KEYC_KP2_2 },
	{ "KP1",	KEYC_KP3_0 },
	{ "KP2",	KEYC_KP3_1 },
	{ "KP3",	KEYC_KP3_2 },
	{ "KPEnter",	KEYC_KP3_3 },
	{ "KP0",	KEYC_KP4_0 },
	{ "KP.",	KEYC_KP4_2 },
@


1.7
log
@Add a key string for space ("Space") and document the names, suggested by
guenther@@. Also document how to bind " and ', suggested by miod@@.
@
text
@d1 1
a1 1
/* $OpenBSD: key-string.c,v 1.6 2009/07/28 09:18:01 nicm Exp $ */
d124 2
@


1.6
log
@Accept and print "Enter" and "Escape" for keys rather than C-m and C-[.
@
text
@d1 1
a1 1
/* $OpenBSD: key-string.c,v 1.5 2009/07/26 21:42:08 nicm Exp $ */
d60 1
@


1.5
log
@Detect backspace by looking at termios VERASE and translate it into \177 (which
matches screen's behaviour if not its termcap/terminfo entry). The terminfo kbs
cap is often wrong or missing so it can't be used, and just assuming \177 may
be wrong.
@
text
@d1 1
a1 1
/* $OpenBSD: key-string.c,v 1.4 2009/07/24 14:57:22 nicm Exp $ */
d61 2
d182 5
a200 4
	for (i = 0; i < nitems(key_string_table); i++) {
		if (key == key_string_table[i].key)
			return (key_string_table[i].string);
	}
@


1.4
log
@Accept lowercase c- and m- prefix as well as C- and M-.
@
text
@d1 1
a1 1
/* $OpenBSD: key-string.c,v 1.3 2009/07/21 17:57:29 nicm Exp $ */
d60 1
a60 1
	{ "BSpace",	'\177' },
@


1.3
log
@Tidy up keys: use an enum for the key codes, and remove the macros which just
wrap flag sets/clears/tests.
@
text
@d1 1
a1 1
/* $OpenBSD: key-string.c,v 1.2 2009/07/14 06:56:30 nicm Exp $ */
d111 1
a111 1
	if (string[0] == 'C' && string[1] == '-')
d132 2
a133 2

	if (string[0] == 'M' && string[1] == '-') {
@


1.2
log
@Add backspace key to named keys.
@
text
@d1 1
a1 1
/* $OpenBSD: key-string.c,v 1.1 2009/06/01 22:58:49 nicm Exp $ */
d129 1
a129 1
			return (KEYC_ADDCTL(key));
d140 1
a140 1
			return (KEYC_ADDESC(ptr[0]));
d144 1
a144 1
			return (KEYC_ADDESC(key));
d161 2
a162 2
	if (KEYC_ISESC(key)) {
		if ((s = key_string_lookup_key(KEYC_REMOVEESC(key))) == NULL)
d167 2
a168 2
	if (KEYC_ISCTL(key)) {
		if ((s = key_string_lookup_key(KEYC_REMOVECTL(key))) == NULL)
d173 2
a174 2
	if (KEYC_ISSFT(key)) {
		if ((s = key_string_lookup_key(KEYC_REMOVESFT(key))) == NULL)
@


1.1
log
@Import tmux, a terminal multiplexor allowing (among other things) a single
terminal to be switched between several different windows and programs
displayed on one terminal be detached from one terminal and moved to another.

ok deraadt pirofti
@
text
@d1 1
a1 1
/* $OpenBSD$ */
d60 1
@

