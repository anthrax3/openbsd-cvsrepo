head	1.112;
access;
symbols
	OPENBSD_6_1:1.112.0.2
	OPENBSD_6_1_BASE:1.112
	OPENBSD_6_0:1.96.0.2
	OPENBSD_6_0_BASE:1.96
	OPENBSD_5_9:1.93.0.2
	OPENBSD_5_9_BASE:1.93
	OPENBSD_5_8:1.76.0.4
	OPENBSD_5_8_BASE:1.76
	OPENBSD_5_7:1.71.0.2
	OPENBSD_5_7_BASE:1.71
	OPENBSD_5_6:1.69.0.4
	OPENBSD_5_6_BASE:1.69
	OPENBSD_5_5:1.66.0.4
	OPENBSD_5_5_BASE:1.66
	OPENBSD_5_4:1.62.0.2
	OPENBSD_5_4_BASE:1.62
	OPENBSD_5_3:1.57.0.4
	OPENBSD_5_3_BASE:1.57
	OPENBSD_5_2:1.57.0.2
	OPENBSD_5_2_BASE:1.57
	OPENBSD_5_1_BASE:1.52
	OPENBSD_5_1:1.52.0.2
	OPENBSD_5_0:1.51.0.2
	OPENBSD_5_0_BASE:1.51
	OPENBSD_4_9:1.47.0.2
	OPENBSD_4_9_BASE:1.47
	OPENBSD_4_8:1.37.0.2
	OPENBSD_4_8_BASE:1.37
	OPENBSD_4_7:1.35.0.2
	OPENBSD_4_7_BASE:1.35
	OPENBSD_4_6:1.2.0.4
	OPENBSD_4_6_BASE:1.2;
locks; strict;
comment	@ * @;


1.112
date	2017.02.16.10.53.25;	author nicm;	state Exp;
branches;
next	1.111;
commitid	LqXOE9qmWQgnS4l6;

1.111
date	2017.02.03.21.01.02;	author nicm;	state Exp;
branches;
next	1.110;
commitid	MRFqlgnbMk0ZRnKS;

1.110
date	2017.01.25.23.50.51;	author nicm;	state Exp;
branches;
next	1.109;
commitid	aBjacBTo3pL6h3gr;

1.109
date	2017.01.24.20.24.54;	author nicm;	state Exp;
branches;
next	1.108;
commitid	0gr9ZsBta92BDuY8;

1.108
date	2017.01.24.19.11.46;	author nicm;	state Exp;
branches;
next	1.107;
commitid	kKr1lZUu2NYuA7Hw;

1.107
date	2017.01.16.14.49.14;	author nicm;	state Exp;
branches;
next	1.106;
commitid	4TgBXjnsq23XHMH4;

1.106
date	2017.01.15.20.50.34;	author nicm;	state Exp;
branches;
next	1.105;
commitid	BHpowksj5uzeuYmj;

1.105
date	2017.01.15.20.48.41;	author nicm;	state Exp;
branches;
next	1.104;
commitid	osUO2wUOqrqm0Q8V;

1.104
date	2017.01.12.15.36.35;	author nicm;	state Exp;
branches;
next	1.103;
commitid	TxelVequscBivd6R;

1.103
date	2017.01.11.14.56.44;	author nicm;	state Exp;
branches;
next	1.102;
commitid	OX4JTH65GquvrMVB;

1.102
date	2016.11.04.18.56.25;	author nicm;	state Exp;
branches;
next	1.101;
commitid	zdHUjBE3tpBbuo8M;

1.101
date	2016.10.16.19.04.05;	author nicm;	state Exp;
branches;
next	1.100;
commitid	pxm6osuE99zELpkU;

1.100
date	2016.10.14.22.14.22;	author nicm;	state Exp;
branches;
next	1.99;
commitid	S3IpyYTkmviA6lfM;

1.99
date	2016.10.10.21.51.39;	author nicm;	state Exp;
branches;
next	1.98;
commitid	TaZ3kOtGiWwKofka;

1.98
date	2016.10.09.07.58.35;	author nicm;	state Exp;
branches;
next	1.97;
commitid	q8ftfwT9VN0ulN8c;

1.97
date	2016.09.26.09.02.34;	author nicm;	state Exp;
branches;
next	1.96;
commitid	LE9w75dFwI4CecIe;

1.96
date	2016.05.30.09.50.20;	author nicm;	state Exp;
branches;
next	1.95;
commitid	6UcyBBKbI1JUqfYo;

1.95
date	2016.04.29.15.00.48;	author nicm;	state Exp;
branches;
next	1.94;
commitid	z5NrpOKjZoYhx6Qr;

1.94
date	2016.03.03.14.15.22;	author nicm;	state Exp;
branches;
next	1.93;
commitid	3WMtbfmTbJwTavl5;

1.93
date	2016.01.19.15.59.12;	author nicm;	state Exp;
branches;
next	1.92;
commitid	P3qmSOx6KrDBsb0c;

1.92
date	2015.12.14.00.31.54;	author nicm;	state Exp;
branches;
next	1.91;
commitid	rE682EC14v4gpeFy;

1.91
date	2015.12.13.21.53.57;	author nicm;	state Exp;
branches;
next	1.90;
commitid	gsQkQsSyBCSmU9ax;

1.90
date	2015.12.13.14.32.38;	author nicm;	state Exp;
branches;
next	1.89;
commitid	uzMkp8Z4FE6WB6s6;

1.89
date	2015.12.12.18.32.24;	author nicm;	state Exp;
branches;
next	1.88;
commitid	q7iDAcShsJWlLYhr;

1.88
date	2015.12.12.18.19.00;	author nicm;	state Exp;
branches;
next	1.87;
commitid	WD2k8ZkBSmp0TV5S;

1.87
date	2015.11.20.12.01.19;	author nicm;	state Exp;
branches;
next	1.86;
commitid	qNEZpcD0RcTrAsAp;

1.86
date	2015.11.18.14.27.44;	author nicm;	state Exp;
branches;
next	1.85;
commitid	RjsAPRkWwvS79w40;

1.85
date	2015.11.12.11.05.34;	author nicm;	state Exp;
branches;
next	1.84;
commitid	Ih1tdqtjpnEyfE8x;

1.84
date	2015.10.27.15.58.42;	author nicm;	state Exp;
branches;
next	1.83;
commitid	89xhQafU35Q5MQVC;

1.83
date	2015.09.14.13.22.02;	author nicm;	state Exp;
branches;
next	1.82;
commitid	kxByHmNsW2wTQbKK;

1.82
date	2015.08.29.08.30.54;	author nicm;	state Exp;
branches;
next	1.81;
commitid	RrlCW4OYH7he0yBf;

1.81
date	2015.08.29.00.29.15;	author nicm;	state Exp;
branches;
next	1.80;
commitid	jhCDxn7bTHMNE4FM;

1.80
date	2015.08.28.16.10.46;	author nicm;	state Exp;
branches;
next	1.79;
commitid	5Oy3Fyd66jXdISPs;

1.79
date	2015.08.28.15.51.48;	author nicm;	state Exp;
branches;
next	1.78;
commitid	blWK8QcMFPW3AUtZ;

1.78
date	2015.08.28.13.12.20;	author nicm;	state Exp;
branches;
next	1.77;
commitid	7dHMdjgnodjQvy6O;

1.77
date	2015.08.28.12.16.28;	author nicm;	state Exp;
branches;
next	1.76;
commitid	LqkiQ6rY2EYTPxv3;

1.76
date	2015.07.27.08.45.45;	author nicm;	state Exp;
branches;
next	1.75;
commitid	bZG82X9pPk548EDZ;

1.75
date	2015.06.04.14.29.33;	author nicm;	state Exp;
branches;
next	1.74;
commitid	3bRmeKjgxs1dRxhJ;

1.74
date	2015.04.24.23.17.11;	author nicm;	state Exp;
branches;
next	1.73;
commitid	iy4fcaIoXzxOx84I;

1.73
date	2015.04.24.21.38.18;	author nicm;	state Exp;
branches;
next	1.72;
commitid	spcw4QBHapvscX4x;

1.72
date	2015.04.22.15.30.11;	author nicm;	state Exp;
branches;
next	1.71;
commitid	0bmlELm9krdoS6OB;

1.71
date	2014.10.20.22.29.25;	author nicm;	state Exp;
branches;
next	1.70;
commitid	Gq8hgMoG3t1Wy1Zv;

1.70
date	2014.09.01.21.50.18;	author nicm;	state Exp;
branches;
next	1.69;
commitid	yvK8NJvd2XzXhKku;

1.69
date	2014.04.17.14.45.49;	author nicm;	state Exp;
branches;
next	1.68;

1.68
date	2014.04.17.07.55.43;	author nicm;	state Exp;
branches;
next	1.67;

1.67
date	2014.04.17.07.51.38;	author nicm;	state Exp;
branches;
next	1.66;

1.66
date	2014.02.17.18.12.47;	author nicm;	state Exp;
branches;
next	1.65;

1.65
date	2014.02.14.13.59.01;	author nicm;	state Exp;
branches;
next	1.64;

1.64
date	2014.01.28.23.07.09;	author nicm;	state Exp;
branches;
next	1.63;

1.63
date	2013.10.10.12.00.23;	author nicm;	state Exp;
branches;
next	1.62;

1.62
date	2013.07.05.15.10.38;	author nicm;	state Exp;
branches;
next	1.61;

1.61
date	2013.03.24.09.55.02;	author nicm;	state Exp;
branches;
next	1.60;

1.60
date	2013.03.24.09.54.10;	author nicm;	state Exp;
branches;
next	1.59;

1.59
date	2013.03.21.16.17.01;	author nicm;	state Exp;
branches;
next	1.58;

1.58
date	2013.03.21.16.15.52;	author nicm;	state Exp;
branches;
next	1.57;

1.57
date	2012.07.11.07.10.15;	author nicm;	state Exp;
branches;
next	1.56;

1.56
date	2012.07.10.11.53.01;	author nicm;	state Exp;
branches;
next	1.55;

1.55
date	2012.04.08.06.47.26;	author nicm;	state Exp;
branches;
next	1.54;

1.54
date	2012.03.17.21.33.33;	author nicm;	state Exp;
branches;
next	1.53;

1.53
date	2012.02.25.12.57.42;	author nicm;	state Exp;
branches;
next	1.52;

1.52
date	2012.01.21.08.40.09;	author nicm;	state Exp;
branches;
next	1.51;

1.51
date	2011.04.05.19.37.01;	author nicm;	state Exp;
branches;
next	1.50;

1.50
date	2011.03.29.21.09.13;	author nicm;	state Exp;
branches;
next	1.49;

1.49
date	2011.03.29.21.07.08;	author nicm;	state Exp;
branches;
next	1.48;

1.48
date	2011.03.29.20.31.22;	author nicm;	state Exp;
branches;
next	1.47;

1.47
date	2011.01.26.01.54.56;	author nicm;	state Exp;
branches;
next	1.46;

1.46
date	2011.01.04.02.03.41;	author nicm;	state Exp;
branches;
next	1.45;

1.45
date	2011.01.04.01.58.12;	author nicm;	state Exp;
branches;
next	1.44;

1.44
date	2011.01.04.00.42.47;	author nicm;	state Exp;
branches;
next	1.43;

1.43
date	2011.01.01.16.51.21;	author nicm;	state Exp;
branches;
next	1.42;

1.42
date	2010.12.30.23.16.18;	author nicm;	state Exp;
branches;
next	1.41;

1.41
date	2010.12.19.18.35.08;	author nicm;	state Exp;
branches;
next	1.40;

1.40
date	2010.12.06.22.51.02;	author nicm;	state Exp;
branches;
next	1.39;

1.39
date	2010.09.26.20.43.30;	author nicm;	state Exp;
branches;
next	1.38;

1.38
date	2010.09.01.21.06.51;	author nicm;	state Exp;
branches;
next	1.37;

1.37
date	2010.06.27.00.22.22;	author nicm;	state Exp;
branches;
next	1.36;

1.36
date	2010.05.14.19.03.09;	author nicm;	state Exp;
branches;
next	1.35;

1.35
date	2010.02.22.20.41.16;	author nicm;	state Exp;
branches;
next	1.34;

1.34
date	2010.02.08.00.14.38;	author nicm;	state Exp;
branches;
next	1.33;

1.33
date	2010.02.04.18.20.16;	author nicm;	state Exp;
branches;
next	1.32;

1.32
date	2010.01.03.12.51.05;	author nicm;	state Exp;
branches;
next	1.31;

1.31
date	2009.12.14.10.43.41;	author nicm;	state Exp;
branches;
next	1.30;

1.30
date	2009.12.11.13.58.48;	author nicm;	state Exp;
branches;
next	1.29;

1.29
date	2009.12.10.09.16.52;	author nicm;	state Exp;
branches;
next	1.28;

1.28
date	2009.12.03.22.50.10;	author nicm;	state Exp;
branches;
next	1.27;

1.27
date	2009.12.03.17.44.02;	author nicm;	state Exp;
branches;
next	1.26;

1.26
date	2009.11.18.13.16.33;	author nicm;	state Exp;
branches;
next	1.25;

1.25
date	2009.11.13.19.53.29;	author nicm;	state Exp;
branches;
next	1.24;

1.24
date	2009.11.01.23.20.37;	author nicm;	state Exp;
branches;
next	1.23;

1.23
date	2009.10.10.15.03.01;	author nicm;	state Exp;
branches;
next	1.22;

1.22
date	2009.10.10.14.51.16;	author nicm;	state Exp;
branches;
next	1.21;

1.21
date	2009.10.10.09.46.11;	author nicm;	state Exp;
branches;
next	1.20;

1.20
date	2009.09.23.06.18.47;	author nicm;	state Exp;
branches;
next	1.19;

1.19
date	2009.09.22.12.38.10;	author nicm;	state Exp;
branches;
next	1.18;

1.18
date	2009.09.18.15.19.27;	author nicm;	state Exp;
branches;
next	1.17;

1.17
date	2009.09.01.13.09.49;	author nicm;	state Exp;
branches;
next	1.16;

1.16
date	2009.08.31.20.46.19;	author nicm;	state Exp;
branches;
next	1.15;

1.15
date	2009.08.13.20.11.58;	author nicm;	state Exp;
branches;
next	1.14;

1.14
date	2009.08.11.12.53.37;	author nicm;	state Exp;
branches;
next	1.13;

1.13
date	2009.08.08.21.52.43;	author nicm;	state Exp;
branches;
next	1.12;

1.12
date	2009.08.08.20.36.42;	author nicm;	state Exp;
branches;
next	1.11;

1.11
date	2009.08.04.18.45.57;	author nicm;	state Exp;
branches;
next	1.10;

1.10
date	2009.08.03.14.10.54;	author nicm;	state Exp;
branches;
next	1.9;

1.9
date	2009.07.26.12.58.44;	author nicm;	state Exp;
branches;
next	1.8;

1.8
date	2009.07.20.14.32.09;	author nicm;	state Exp;
branches;
next	1.7;

1.7
date	2009.07.18.14.59.25;	author nicm;	state Exp;
branches;
next	1.6;

1.6
date	2009.07.15.07.50.34;	author nicm;	state Exp;
branches;
next	1.5;

1.5
date	2009.07.13.23.11.35;	author nicm;	state Exp;
branches;
next	1.4;

1.4
date	2009.07.10.05.50.54;	author nicm;	state Exp;
branches;
next	1.3;

1.3
date	2009.07.07.19.49.19;	author nicm;	state Exp;
branches;
next	1.2;

1.2
date	2009.06.03.16.54.26;	author nicm;	state Exp;
branches;
next	1.1;

1.1
date	2009.06.01.22.58.49;	author nicm;	state Exp;
branches;
next	;


desc
@@


1.112
log
@Style nits.
@
text
@/* $OpenBSD: cmd-set-option.c,v 1.111 2017/02/03 21:01:02 nicm Exp $ */

/*
 * Copyright (c) 2007 Nicholas Marriott <nicholas.marriott@@gmail.com>
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF MIND, USE, DATA OR PROFITS, WHETHER
 * IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING
 * OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */

#include <sys/types.h>

#include <stdlib.h>
#include <string.h>

#include "tmux.h"

/*
 * Set an option.
 */

static enum cmd_retval	cmd_set_option_exec(struct cmd *, struct cmdq_item *);

static int	cmd_set_option_set(struct cmd *, struct cmdq_item *,
		    struct options *, struct options_entry *, const char *);
static int	cmd_set_option_flag(struct cmdq_item *,
		    const struct options_table_entry *, struct options *,
		    const char *);
static int	cmd_set_option_choice(struct cmdq_item *,
		    const struct options_table_entry *, struct options *,
		    const char *);

const struct cmd_entry cmd_set_option_entry = {
	.name = "set-option",
	.alias = "set",

	.args = { "agoqst:uw", 1, 2 },
	.usage = "[-agosquw] [-t target-window] option [value]",

	.tflag = CMD_WINDOW_CANFAIL,

	.flags = CMD_AFTERHOOK,
	.exec = cmd_set_option_exec
};

const struct cmd_entry cmd_set_window_option_entry = {
	.name = "set-window-option",
	.alias = "setw",

	.args = { "agoqt:u", 1, 2 },
	.usage = "[-agoqu] " CMD_TARGET_WINDOW_USAGE " option [value]",

	.tflag = CMD_WINDOW_CANFAIL,

	.flags = CMD_AFTERHOOK,
	.exec = cmd_set_option_exec
};

static enum cmd_retval
cmd_set_option_exec(struct cmd *self, struct cmdq_item *item)
{
	struct args			*args = self->args;
	int				 append = args_has(args, 'a');
	struct cmd_find_state		*fs = &item->state.tflag;
	struct session			*s = fs->s;
	struct winlink			*wl = fs->wl;
	struct window			*w;
	struct client			*c;
	enum options_table_scope	 scope;
	struct options			*oo;
	struct options_entry		*parent, *o;
	const char			*name, *value, *target;
	int				 window, idx, already, error, ambiguous;
	char				*cause;

	/* Parse option name and index. */
	name = options_match(args->argv[0], &idx, &ambiguous);
	if (name == NULL) {
		if (args_has(args, 'q'))
			return (CMD_RETURN_NORMAL);
		if (ambiguous)
			cmdq_error(item, "ambiguous option: %s", args->argv[0]);
		else
			cmdq_error(item, "invalid option: %s", args->argv[0]);
		return (CMD_RETURN_ERROR);
	}
	if (args->argc < 2)
		value = NULL;
	else
		value = args->argv[1];

	/*
	 * Figure out the scope: for user options it comes from the arguments,
	 * otherwise from the option name.
	 */
	if (*name == '@@') {
		window = (self->entry == &cmd_set_window_option_entry);
		scope = options_scope_from_flags(args, window, fs, &oo, &cause);
	} else {
		if (options_get_only(global_options, name) != NULL)
			scope = OPTIONS_TABLE_SERVER;
		else if (options_get_only(global_s_options, name) != NULL)
			scope = OPTIONS_TABLE_SESSION;
		else if (options_get_only(global_w_options, name) != NULL)
			scope = OPTIONS_TABLE_WINDOW;
		else {
			scope = OPTIONS_TABLE_NONE;
			xasprintf(&cause, "unknown option: %s", args->argv[0]);
		}
	}
	if (scope == OPTIONS_TABLE_NONE) {
		if (args_has(args, 'q'))
			return (CMD_RETURN_NORMAL);
		cmdq_error(item, "%s", cause);
		free(cause);
		return (CMD_RETURN_ERROR);
	}

	/* Which table should this option go into? */
	if (scope == OPTIONS_TABLE_SERVER)
		oo = global_options;
	else if (scope == OPTIONS_TABLE_SESSION) {
		if (args_has(self->args, 'g'))
			oo = global_s_options;
		else if (s == NULL) {
			target = args_get(args, 't');
			if (target != NULL)
				cmdq_error(item, "no such session: %s", target);
			else
				cmdq_error(item, "no current session");
			return (CMD_RETURN_ERROR);
		} else
			oo = s->options;
	} else if (scope == OPTIONS_TABLE_WINDOW) {
		if (args_has(self->args, 'g'))
			oo = global_w_options;
		else if (wl == NULL) {
			target = args_get(args, 't');
			if (target != NULL)
				cmdq_error(item, "no such window: %s", target);
			else
				cmdq_error(item, "no current window");
			return (CMD_RETURN_ERROR);
		} else
			oo = wl->window->options;
	}
	o = options_get_only(oo, name);
	parent = options_get(oo, name);

	/* Check that array options and indexes match up. */
	if (idx != -1) {
		if (*name == '@@' || options_array_size(parent, NULL) == -1) {
			cmdq_error(item, "not an array: %s", args->argv[0]);
			return (CMD_RETURN_ERROR);
		}
	}

	/* With -o, check this option is not already set. */
	if (!args_has(args, 'u') && args_has(args, 'o')) {
		if (idx == -1)
			already = (o != NULL);
		else {
			if (o == NULL)
				already = 0;
			else
				already = (options_array_get(o, idx) != NULL);
		}
		if (already) {
			if (args_has(args, 'q'))
				return (CMD_RETURN_NORMAL);
			cmdq_error(item, "already set: %s", args->argv[0]);
			return (CMD_RETURN_ERROR);
		}
	}

	/* Change the option. */
	if (args_has(args, 'u')) {
		if (o == NULL)
			return (CMD_RETURN_NORMAL);
		if (idx == -1) {
			if (oo == global_options ||
			    oo == global_s_options ||
			    oo == global_w_options)
				options_default(oo, options_table_entry(o));
			else
				options_remove(o);
		} else
			options_array_set(o, idx, NULL, 0);
	} else if (*name == '@@') {
		if (value == NULL) {
			cmdq_error(item, "empty value");
			return (CMD_RETURN_ERROR);
		}
		options_set_string(oo, name, append, "%s", value);
	} else if (idx == -1 && options_array_size(parent, NULL) == -1) {
		error = cmd_set_option_set(self, item, oo, parent, value);
		if (error != 0)
			return (CMD_RETURN_ERROR);
	} else {
		if (value == NULL) {
			cmdq_error(item, "empty value");
			return (CMD_RETURN_ERROR);
		}
		if (o == NULL)
			o = options_empty(oo, options_table_entry(parent));
		if (idx == -1) {
			if (!append)
				options_array_clear(o);
			options_array_assign(o, value);
		} else if (options_array_set(o, idx, value, append) != 0) {
			cmdq_error(item, "invalid index: %s", args->argv[0]);
			return (CMD_RETURN_ERROR);
		}
	}

	/* Update timers and so on for various options. */
	if (strcmp(name, "automatic-rename") == 0) {
		RB_FOREACH(w, windows, &windows) {
			if (w->active == NULL)
				continue;
			if (options_get_number(w->options, "automatic-rename"))
				w->active->flags |= PANE_CHANGED;
		}
	}
	if (strcmp(name, "key-table") == 0) {
		TAILQ_FOREACH(c, &clients, entry)
			server_client_set_key_table(c, NULL);
	}
	if (strcmp(name, "status") == 0 ||
	    strcmp(name, "status-interval") == 0)
		status_timer_start_all();
	if (strcmp(name, "monitor-silence") == 0)
		alerts_reset_all();
	if (strcmp(name, "window-style") == 0 ||
	    strcmp(name, "window-active-style") == 0) {
		RB_FOREACH(w, windows, &windows)
			w->flags |= WINDOW_STYLECHANGED;
	}
	if (strcmp(name, "pane-border-status") == 0) {
		RB_FOREACH(w, windows, &windows)
			layout_fix_panes(w, w->sx, w->sy);
	}
	RB_FOREACH (s, sessions, &sessions)
		status_update_saved(s);

	/*
	 * Update sizes and redraw. May not always be necessary but do it
	 * anyway.
	 */
	recalculate_sizes();
	TAILQ_FOREACH(c, &clients, entry) {
		if (c->session != NULL)
			server_redraw_client(c);
	}

	return (CMD_RETURN_NORMAL);
}

static int
cmd_set_option_set(struct cmd *self, struct cmdq_item *item, struct options *oo,
    struct options_entry *parent, const char *value)
{
	const struct options_table_entry	*oe;
	struct args				*args = self->args;
	int					 append = args_has(args, 'a');
	struct options_entry			*o;
	long long				 number;
	const char				*errstr;
	key_code				 key;

	oe = options_table_entry(parent);
	if (value == NULL &&
	    oe->type != OPTIONS_TABLE_FLAG &&
	    oe->type != OPTIONS_TABLE_CHOICE) {
		cmdq_error(item, "empty value");
		return (-1);
	}

	switch (oe->type) {
	case OPTIONS_TABLE_STRING:
		options_set_string(oo, oe->name, append, "%s", value);
		return (0);
	case OPTIONS_TABLE_NUMBER:
		number = strtonum(value, oe->minimum, oe->maximum, &errstr);
		if (errstr != NULL) {
			cmdq_error(item, "value is %s: %s", errstr, value);
			return (-1);
		}
		options_set_number(oo, oe->name, number);
		return (0);
	case OPTIONS_TABLE_KEY:
		key = key_string_lookup_string(value);
		if (key == KEYC_UNKNOWN) {
			cmdq_error(item, "bad key: %s", value);
			return (-1);
		}
		options_set_number(oo, oe->name, key);
		return (0);
	case OPTIONS_TABLE_COLOUR:
		if ((number = colour_fromstring(value)) == -1) {
			cmdq_error(item, "bad colour: %s", value);
			return (-1);
		}
		o = options_set_number(oo, oe->name, number);
		options_style_update_new(oo, o);
		return (0);
	case OPTIONS_TABLE_ATTRIBUTES:
		if ((number = attributes_fromstring(value)) == -1) {
			cmdq_error(item, "bad attributes: %s", value);
			return (-1);
		}
		o = options_set_number(oo, oe->name, number);
		options_style_update_new(oo, o);
		return (0);
	case OPTIONS_TABLE_FLAG:
		return (cmd_set_option_flag(item, oe, oo, value));
	case OPTIONS_TABLE_CHOICE:
		return (cmd_set_option_choice(item, oe, oo, value));
	case OPTIONS_TABLE_STYLE:
		o = options_set_style(oo, oe->name, append, value);
		if (o == NULL) {
			cmdq_error(item, "bad style: %s", value);
			return (-1);
		}
		options_style_update_old(oo, o);
		return (0);
	case OPTIONS_TABLE_ARRAY:
		break;
	}
	return (-1);
}

static int
cmd_set_option_flag(struct cmdq_item *item,
    const struct options_table_entry *oe, struct options *oo,
    const char *value)
{
	int	flag;

	if (value == NULL || *value == '\0')
		flag = !options_get_number(oo, oe->name);
	else if (strcmp(value, "1") == 0 ||
	    strcasecmp(value, "on") == 0 ||
	    strcasecmp(value, "yes") == 0)
		flag = 1;
	else if (strcmp(value, "0") == 0 ||
	    strcasecmp(value, "off") == 0 ||
	    strcasecmp(value, "no") == 0)
		flag = 0;
	else {
		cmdq_error(item, "bad value: %s", value);
		return (-1);
	}
	options_set_number(oo, oe->name, flag);
	return (0);
}

static int
cmd_set_option_choice(struct cmdq_item *item,
    const struct options_table_entry *oe, struct options *oo,
    const char *value)
{
	const char	**cp;
	int		  n, choice = -1;

	if (value == NULL) {
		choice = options_get_number(oo, oe->name);
		if (choice < 2)
			choice = !choice;
	} else {
		n = 0;
		for (cp = oe->choices; *cp != NULL; cp++) {
			if (strcmp(*cp, value) == 0)
				choice = n;
			n++;
		}
		if (choice == -1) {
			cmdq_error(item, "unknown value: %s", value);
			return (-1);
		}
	}
	options_set_number(oo, oe->name, choice);
	return (0);
}
@


1.111
log
@Cache status line position to reduce option lookups during output.
@
text
@d1 1
a1 1
/* $OpenBSD: cmd-set-option.c,v 1.110 2017/01/25 23:50:51 nicm Exp $ */
d75 1
a75 1
	struct window			*w = wl->window;
@


1.110
log
@Clear option before adding to array if no -a, reported by Michael
Nickerson.
@
text
@d1 1
a1 1
/* $OpenBSD: cmd-set-option.c,v 1.109 2017/01/24 20:24:54 nicm Exp $ */
d251 2
@


1.109
log
@Fix set -u on array options.
@
text
@d1 1
a1 1
/* $OpenBSD: cmd-set-option.c,v 1.108 2017/01/24 19:11:46 nicm Exp $ */
d214 3
a216 1
		if (idx == -1)
d218 1
a218 1
		else if (options_array_set(o, idx, value, append) != 0) {
@


1.108
log
@If given an array option without an index either show or set all items,
and support -a for array options. Allow the separator for set to be
specified in the options table (will be used for backwards compatibility
later).
@
text
@d1 1
a1 1
/* $OpenBSD: cmd-set-option.c,v 1.107 2017/01/16 14:49:14 nicm Exp $ */
d71 1
a163 11
	} else if (*name != '@@' && options_array_size(parent, NULL) != -1) {
		if (value == NULL) {
			cmdq_error(item, "empty value");
			return (-1);
		}
		if (o == NULL)
			o = options_empty(oo, options_table_entry(parent));
		if (!args_has(args, 'a'))
			options_array_clear(o);
		options_array_assign(o, value);
		return (CMD_RETURN_NORMAL);
d197 7
a203 3
	} else if (*name == '@@')
		options_set_string(oo, name, args_has(args, 'a'), "%s", value);
	else if (idx == -1) {
d208 4
d214 3
a216 1
		if (options_array_set(o, idx, value, 1) != 0) {
@


1.107
log
@getopt() has a struct option so just return to using options_entry.
@
text
@d1 1
a1 1
/* $OpenBSD: cmd-set-option.c,v 1.106 2017/01/15 20:50:34 nicm Exp $ */
d163 4
a166 4
	} else {
		if (*name != '@@' && options_array_size(parent, NULL) != -1) {
			cmdq_error(item, "is an array: %s", args->argv[0]);
			return (CMD_RETURN_ERROR);
d168 6
d206 1
a206 1
			options_array_set(o, idx, NULL);
d216 1
a216 1
		if (options_array_set(o, idx, value) != 0) {
@


1.106
log
@-q flag now needs to be checked in a couple more places.
@
text
@d1 1
a1 1
/* $OpenBSD: cmd-set-option.c,v 1.105 2017/01/15 20:48:41 nicm Exp $ */
d33 1
a33 1
		    struct options *, struct option *, const char *);
d78 1
a78 1
	struct option			*parent, *o;
d259 1
a259 1
    struct option *parent, const char *value)
d264 1
a264 1
	struct option				*o;
@


1.105
log
@Major tidy up and rework of options tree and set-option/show-options
commands this pushes more of the code into options.c and ties it more
closely to the options table rather than having an unnecessary
split. Also add support for array options (will be used later). Only
(intentional) user visible change is that show-options output is now
passed through vis(3) with VIS_DQ so quotes are escaped.
@
text
@d1 1
a1 1
/* $OpenBSD: cmd-set-option.c,v 1.104 2017/01/12 15:36:35 nicm Exp $ */
d86 2
d119 2
@


1.104
log
@Simplify appending to string options.
@
text
@d1 1
a1 1
/* $OpenBSD: cmd-set-option.c,v 1.103 2017/01/11 14:56:44 nicm Exp $ */
d32 3
a34 4
static enum cmd_retval	cmd_set_option_user(struct cmd *, struct cmdq_item *,
			    const char *, const char *);

static int	cmd_set_option_unset(struct cmd *, struct cmdq_item *,
d37 1
a37 1
static int	cmd_set_option_set(struct cmd *, struct cmdq_item *,
a40 25
static struct options_entry *cmd_set_option_string(struct cmd *,
	    struct cmdq_item *, const struct options_table_entry *,
	    struct options *, const char *);
static struct options_entry *cmd_set_option_number(struct cmd *,
	    struct cmdq_item *, const struct options_table_entry *,
	    struct options *, const char *);
static struct options_entry *cmd_set_option_key(struct cmd *,
	    struct cmdq_item *, const struct options_table_entry *,
	    struct options *, const char *);
static struct options_entry *cmd_set_option_colour(struct cmd *,
	    struct cmdq_item *, const struct options_table_entry *,
	    struct options *, const char *);
static struct options_entry *cmd_set_option_attributes(struct cmd *,
	    struct cmdq_item *, const struct options_table_entry *,
	    struct options *, const char *);
static struct options_entry *cmd_set_option_flag(struct cmd *,
	    struct cmdq_item *, const struct options_table_entry *,
	    struct options *, const char *);
static struct options_entry *cmd_set_option_choice(struct cmd *,
	    struct cmdq_item *, const struct options_table_entry *,
	    struct options *, const char *);
static struct options_entry *cmd_set_option_style(struct cmd *,
	    struct cmdq_item *, const struct options_table_entry *,
	    struct options *, const char *);

d70 20
a89 13
	struct args				*args = self->args;
	struct session				*s = item->state.tflag.s;
	struct winlink				*wl = item->state.tflag.wl;
	struct window				*w;
	struct client				*c;
	const struct options_table_entry	*oe;
	struct options				*oo;
	const char				*optstr, *valstr, *target;

	/* Get the option name and value. */
	optstr = args->argv[0];
	if (*optstr == '\0') {
		cmdq_error(item, "invalid option");
d93 1
a93 1
		valstr = NULL;
d95 1
a95 1
		valstr = args->argv[1];
d97 17
a113 10
	/* Is this a user option? */
	if (*optstr == '@@')
		return (cmd_set_option_user(self, item, optstr, valstr));

	/* Find the option entry. */
	oe = NULL;
	if (options_table_find(optstr, &oe) != 0) {
		if (!args_has(args, 'q')) {
			cmdq_error(item, "ambiguous option: %s", optstr);
			return (CMD_RETURN_ERROR);
a114 1
		return (CMD_RETURN_NORMAL);
d116 4
a119 6
	if (oe == NULL) {
		if (!args_has(args, 'q')) {
			cmdq_error(item, "unknown option: %s", optstr);
			return (CMD_RETURN_ERROR);
		}
		return (CMD_RETURN_NORMAL);
d122 2
a123 2
	/* Work out the tree from the scope of the option. */
	if (oe->scope == OPTIONS_TABLE_SERVER)
d125 13
a137 1
	else if (oe->scope == OPTIONS_TABLE_WINDOW) {
d142 3
a144 4
			if (target != NULL) {
				cmdq_error(item, "no such window: %s",
				    target);
			} else
d149 8
a156 10
	} else if (oe->scope == OPTIONS_TABLE_SESSION) {
		if (args_has(self->args, 'g'))
			oo = global_s_options;
		else if (s == NULL) {
			target = args_get(args, 't');
			if (target != NULL) {
				cmdq_error(item, "no such session: %s",
				    target);
			} else
				cmdq_error(item, "no current session");
d158 1
a158 2
		} else
			oo = s->options;
d160 22
a181 2
		cmdq_error(item, "unknown table");
		return (CMD_RETURN_ERROR);
d184 1
a184 1
	/* Unset or set the option. */
d186 16
a201 1
		if (cmd_set_option_unset(self, item, oe, oo, valstr) != 0)
d204 5
a208 6
		if (args_has(args, 'o') && options_find1(oo, optstr) != NULL) {
			if (!args_has(args, 'q')) {
				cmdq_error(item, "already set: %s", optstr);
				return (CMD_RETURN_ERROR);
			}
			return (CMD_RETURN_NORMAL);
a209 2
		if (cmd_set_option_set(self, item, oe, oo, valstr) != 0)
			return (CMD_RETURN_ERROR);
d213 1
a213 1
	if (strcmp(oe->name, "automatic-rename") == 0) {
d221 1
a221 1
	if (strcmp(oe->name, "key-table") == 0) {
d225 2
a226 2
	if (strcmp(oe->name, "status") == 0 ||
	    strcmp(oe->name, "status-interval") == 0)
d228 1
a228 1
	if (strcmp(oe->name, "monitor-silence") == 0)
d230 2
a231 2
	if (strcmp(oe->name, "window-style") == 0 ||
	    strcmp(oe->name, "window-active-style") == 0) {
d235 1
a235 1
	if (strcmp(oe->name, "pane-border-status") == 0) {
d240 4
a243 1
	/* Update sizes and redraw. May not need it but meh. */
a252 77
/* Set user option. */
static enum cmd_retval
cmd_set_option_user(struct cmd *self, struct cmdq_item *item,
    const char *optstr, const char *valstr)
{
	struct args		*args = self->args;
	struct session		*s = item->state.tflag.s;
	struct winlink		*wl = item->state.tflag.wl;
	struct options		*oo;
	struct options_entry	*o;
	const char		*target;

	if (args_has(args, 's'))
		oo = global_options;
	else if (args_has(self->args, 'w') ||
	    self->entry == &cmd_set_window_option_entry) {
		if (args_has(self->args, 'g'))
			oo = global_w_options;
		else if (wl == NULL) {
			target = args_get(args, 't');
			if (target != NULL) {
				cmdq_error(item, "no such window: %s",
				    target);
			} else
				cmdq_error(item, "no current window");
			return (CMD_RETURN_ERROR);
		} else
			oo = wl->window->options;
	} else {
		if (args_has(self->args, 'g'))
			oo = global_s_options;
		else if (s == NULL) {
			target = args_get(args, 't');
			if (target != NULL) {
				cmdq_error(item, "no such session: %s",
				    target);
			} else
				cmdq_error(item, "no current session");
			return (CMD_RETURN_ERROR);
		} else
			oo = s->options;
	}

	if (args_has(args, 'u')) {
		if (options_find1(oo, optstr) == NULL) {
			if (!args_has(args, 'q')) {
				cmdq_error(item, "unknown option: %s", optstr);
				return (CMD_RETURN_ERROR);
			}
			return (CMD_RETURN_NORMAL);
		}
		if (valstr != NULL) {
			cmdq_error(item, "value passed to unset option: %s",
			    optstr);
			return (CMD_RETURN_ERROR);
		}
		options_remove(oo, optstr);
	} else {
		o = options_find1(oo, optstr);
		if (args_has(args, 'o') && o != NULL) {
			if (!args_has(args, 'q')) {
				cmdq_error(item, "already set: %s", optstr);
				return (CMD_RETURN_ERROR);
			}
			return (CMD_RETURN_NORMAL);
		}
		if (valstr == NULL) {
			cmdq_error(item, "empty value");
			return (CMD_RETURN_ERROR);
		}
		options_set_string(oo, optstr, args_has(args, 'a'), "%s",
		    valstr);
	}
	return (CMD_RETURN_NORMAL);
}

/* Unset an option. */
d254 2
a255 3
cmd_set_option_unset(struct cmd *self, struct cmdq_item *item,
    const struct options_table_entry *oe, struct options *oo,
    const char *value)
d257 13
a269 4
	struct args	*args = self->args;

	if (value != NULL) {
		cmdq_error(item, "value passed to unset option: %s", oe->name);
a272 38
	if (args_has(args, 'g') || oo == global_options) {
		switch (oe->type) {
		case OPTIONS_TABLE_STRING:
			options_set_string(oo, oe->name, 0, "%s",
			    oe->default_str);
			break;
		case OPTIONS_TABLE_STYLE:
			options_set_style(oo, oe->name, 0, oe->default_str);
			break;
		default:
			options_set_number(oo, oe->name, oe->default_num);
			break;
		}
	} else
		options_remove(oo, oe->name);
	return (0);
}

/* Set an option. */
static int
cmd_set_option_set(struct cmd *self, struct cmdq_item *item,
    const struct options_table_entry *oe, struct options *oo,
    const char *value)
{
	struct options_entry	*o;

	switch (oe->type) {
	case OPTIONS_TABLE_FLAG:
	case OPTIONS_TABLE_CHOICE:
		break;
	default:
		if (value == NULL) {
			cmdq_error(item, "empty value");
			return (-1);
		}
	}

	o = NULL;
d275 2
a276 2
		o = cmd_set_option_string(self, item, oe, oo, value);
		break;
d278 7
a284 2
		o = cmd_set_option_number(self, item, oe, oo, value);
		break;
d286 7
a292 2
		o = cmd_set_option_key(self, item, oe, oo, value);
		break;
d294 7
a300 4
		o = cmd_set_option_colour(self, item, oe, oo, value);
		if (o != NULL)
			style_update_new(oo, o->name, oe->style);
		break;
d302 7
a308 4
		o = cmd_set_option_attributes(self, item, oe, oo, value);
		if (o != NULL)
			style_update_new(oo, o->name, oe->style);
		break;
d310 1
a310 2
		o = cmd_set_option_flag(self, item, oe, oo, value);
		break;
d312 1
a312 2
		o = cmd_set_option_choice(self, item, oe, oo, value);
		break;
d314 8
a321 1
		o = cmd_set_option_style(self, item, oe, oo, value);
d324 1
a324 3
	if (o == NULL)
		return (-1);
	return (0);
d327 2
a328 82
/* Set a string option. */
static struct options_entry *
cmd_set_option_string(struct cmd *self, __unused struct cmdq_item *item,
    const struct options_table_entry *oe, struct options *oo,
    const char *value)
{
	struct args	*args = self->args;
	int		 append = args_has(args, 'a');

	return (options_set_string(oo, oe->name, append, "%s", value));
}

/* Set a number option. */
static struct options_entry *
cmd_set_option_number(__unused struct cmd *self, struct cmdq_item *item,
    const struct options_table_entry *oe, struct options *oo,
    const char *value)
{
	long long	 ll;
	const char     	*errstr;

	ll = strtonum(value, oe->minimum, oe->maximum, &errstr);
	if (errstr != NULL) {
		cmdq_error(item, "value is %s: %s", errstr, value);
		return (NULL);
	}

	return (options_set_number(oo, oe->name, ll));
}

/* Set a key option. */
static struct options_entry *
cmd_set_option_key(__unused struct cmd *self, struct cmdq_item *item,
    const struct options_table_entry *oe, struct options *oo,
    const char *value)
{
	key_code	key;

	key = key_string_lookup_string(value);
	if (key == KEYC_UNKNOWN) {
		cmdq_error(item, "bad key: %s", value);
		return (NULL);
	}

	return (options_set_number(oo, oe->name, key));
}

/* Set a colour option. */
static struct options_entry *
cmd_set_option_colour(__unused struct cmd *self, struct cmdq_item *item,
    const struct options_table_entry *oe, struct options *oo,
    const char *value)
{
	int	colour;

	if ((colour = colour_fromstring(value)) == -1) {
		cmdq_error(item, "bad colour: %s", value);
		return (NULL);
	}

	return (options_set_number(oo, oe->name, colour));
}

/* Set an attributes option. */
static struct options_entry *
cmd_set_option_attributes(__unused struct cmd *self, struct cmdq_item *item,
    const struct options_table_entry *oe, struct options *oo,
    const char *value)
{
	int	attr;

	if ((attr = attributes_fromstring(value)) == -1) {
		cmdq_error(item, "bad attributes: %s", value);
		return (NULL);
	}

	return (options_set_number(oo, oe->name, attr));
}

/* Set a flag option. */
static struct options_entry *
cmd_set_option_flag(__unused struct cmd *self, struct cmdq_item *item,
d336 8
d345 2
a346 12
		if ((value[0] == '1' && value[1] == '\0') ||
		    strcasecmp(value, "on") == 0 ||
		    strcasecmp(value, "yes") == 0)
			flag = 1;
		else if ((value[0] == '0' && value[1] == '\0') ||
		    strcasecmp(value, "off") == 0 ||
		    strcasecmp(value, "no") == 0)
			flag = 0;
		else {
			cmdq_error(item, "bad value: %s", value);
			return (NULL);
		}
d348 2
a349 2

	return (options_set_number(oo, oe->name, flag));
d352 2
a353 3
/* Set a choice option. */
static struct options_entry *
cmd_set_option_choice(__unused struct cmd *self, struct cmdq_item *item,
d357 1
a357 1
	const char	**choicep;
d366 3
a368 1
		for (choicep = oe->choices; *choicep != NULL; choicep++) {
a369 8
			if (strncmp(*choicep, value, strlen(value)) != 0)
				continue;

			if (choice != -1) {
				cmdq_error(item, "ambiguous value: %s", value);
				return (NULL);
			}
			choice = n - 1;
d373 1
a373 1
			return (NULL);
d376 2
a377 21

	return (options_set_number(oo, oe->name, choice));
}

/* Set a style option. */
static struct options_entry *
cmd_set_option_style(struct cmd *self, struct cmdq_item *item,
    const struct options_table_entry *oe, struct options *oo,
    const char *value)
{
	struct args		*args = self->args;
	int			 append = args_has(args, 'a');
	struct options_entry	*o;

	if ((o = options_set_style(oo, oe->name, append, value)) == NULL) {
		cmdq_error(item, "bad style: %s", value);
		return (NULL);
	}

	style_update_old(oo, oe->name, &o->style);
	return (o);
@


1.103
log
@Some tidying and tweaks to options code.
@
text
@d1 1
a1 1
/* $OpenBSD: cmd-set-option.c,v 1.102 2016/11/04 18:56:25 nicm Exp $ */
d295 2
a296 4
		if (o != NULL && args_has(args, 'a'))
			options_set_string(oo, optstr, "%s%s", o->str, valstr);
		else
			options_set_string(oo, optstr, "%s", valstr);
d317 2
a318 1
			options_set_string(oo, oe->name, "%s", oe->default_str);
d321 1
a321 1
			options_set_style(oo, oe->name, oe->default_str, 0);
d393 2
a394 11
	struct args		*args = self->args;
	struct options_entry	*o;
	char			*oldval, *newval;

	if (args_has(args, 'a')) {
		oldval = options_get_string(oo, oe->name);
		xasprintf(&newval, "%s%s", oldval, value);
	} else
		newval = xstrdup(value);

	o = options_set_string(oo, oe->name, "%s", newval);
d396 1
a396 2
	free(newval);
	return (o);
d536 1
a537 1
	int			 append;
d539 1
a539 2
	append = args_has(args, 'a');
	if ((o = options_set_style(oo, oe->name, value, append)) == NULL) {
@


1.102
log
@Do not try to set the CHANGED flag on windows with no active pane, fixes
problem reported by Nelo-T Wallus.
@
text
@d1 1
a1 1
/* $OpenBSD: cmd-set-option.c,v 1.101 2016/10/16 19:04:05 nicm Exp $ */
d120 1
a120 1
	/* Find the option entry, try each table. */
d187 1
a187 1
	/* Start or stop timers if necessary. */
a209 2

	/* When the pane-border-status option has been changed, resize panes. */
@


1.101
log
@Mass rename struct cmd_q to struct cmdq_item and related.
@
text
@d1 1
a1 1
/* $OpenBSD: cmd-set-option.c,v 1.100 2016/10/14 22:14:22 nicm Exp $ */
d190 2
@


1.100
log
@Add CMD_AFTERHOOK flag to the easy commands that don't need any special handling.
@
text
@d1 1
a1 1
/* $OpenBSD: cmd-set-option.c,v 1.99 2016/10/10 21:51:39 nicm Exp $ */
d30 1
a30 1
static enum cmd_retval	cmd_set_option_exec(struct cmd *, struct cmd_q *);
d32 2
a33 2
static enum cmd_retval	cmd_set_option_user(struct cmd *, struct cmd_q *,
	    const char *, const char *);
d35 1
a35 1
static int	cmd_set_option_unset(struct cmd *, struct cmd_q *,
d38 1
a38 1
static int	cmd_set_option_set(struct cmd *, struct cmd_q *,
d42 12
a53 12
static struct options_entry *cmd_set_option_string(struct cmd *, struct cmd_q *,
	    const struct options_table_entry *, struct options *,
	    const char *);
static struct options_entry *cmd_set_option_number(struct cmd *, struct cmd_q *,
	    const struct options_table_entry *, struct options *,
	    const char *);
static struct options_entry *cmd_set_option_key(struct cmd *, struct cmd_q *,
	    const struct options_table_entry *, struct options *,
	    const char *);
static struct options_entry *cmd_set_option_colour(struct cmd *, struct cmd_q *,
	    const struct options_table_entry *, struct options *,
	    const char *);
d55 10
a64 1
	    struct cmd_q *, const struct options_table_entry *,
a65 9
static struct options_entry *cmd_set_option_flag(struct cmd *, struct cmd_q *,
	    const struct options_table_entry *, struct options *,
	    const char *);
static struct options_entry *cmd_set_option_choice(struct cmd *, struct cmd_q *,
	    const struct options_table_entry *, struct options *,
	    const char *);
static struct options_entry *cmd_set_option_style(struct cmd *, struct cmd_q *,
	    const struct options_table_entry *, struct options *,
	    const char *);
d94 1
a94 1
cmd_set_option_exec(struct cmd *self, struct cmd_q *cmdq)
d97 2
a98 2
	struct session				*s = cmdq->state.tflag.s;
	struct winlink				*wl = cmdq->state.tflag.wl;
d108 1
a108 1
		cmdq_error(cmdq, "invalid option");
d118 1
a118 1
		return (cmd_set_option_user(self, cmdq, optstr, valstr));
d124 1
a124 1
			cmdq_error(cmdq, "ambiguous option: %s", optstr);
d131 1
a131 1
			cmdq_error(cmdq, "unknown option: %s", optstr);
d146 1
a146 1
				cmdq_error(cmdq, "no such window: %s",
d149 1
a149 1
				cmdq_error(cmdq, "no current window");
d159 1
a159 1
				cmdq_error(cmdq, "no such session: %s",
d162 1
a162 1
				cmdq_error(cmdq, "no current session");
d167 1
a167 1
		cmdq_error(cmdq, "unknown table");
d173 1
a173 1
		if (cmd_set_option_unset(self, cmdq, oe, oo, valstr) != 0)
d178 1
a178 1
				cmdq_error(cmdq, "already set: %s", optstr);
d183 1
a183 1
		if (cmd_set_option_set(self, cmdq, oe, oo, valstr) != 0)
d227 2
a228 2
cmd_set_option_user(struct cmd *self, struct cmd_q *cmdq, const char *optstr,
    const char *valstr)
d231 2
a232 2
	struct session		*s = cmdq->state.tflag.s;
	struct winlink		*wl = cmdq->state.tflag.wl;
d246 1
a246 1
				cmdq_error(cmdq, "no such window: %s",
d249 1
a249 1
				cmdq_error(cmdq, "no current window");
d259 1
a259 1
				cmdq_error(cmdq, "no such session: %s",
d262 1
a262 1
				cmdq_error(cmdq, "no current session");
d271 1
a271 1
				cmdq_error(cmdq, "unknown option: %s", optstr);
d277 1
a277 1
			cmdq_error(cmdq, "value passed to unset option: %s",
d286 1
a286 1
				cmdq_error(cmdq, "already set: %s", optstr);
d292 1
a292 1
			cmdq_error(cmdq, "empty value");
d305 1
a305 1
cmd_set_option_unset(struct cmd *self, struct cmd_q *cmdq,
d312 1
a312 1
		cmdq_error(cmdq, "value passed to unset option: %s", oe->name);
d335 1
a335 1
cmd_set_option_set(struct cmd *self, struct cmd_q *cmdq,
d347 1
a347 1
			cmdq_error(cmdq, "empty value");
d355 1
a355 1
		o = cmd_set_option_string(self, cmdq, oe, oo, value);
d358 1
a358 1
		o = cmd_set_option_number(self, cmdq, oe, oo, value);
d361 1
a361 1
		o = cmd_set_option_key(self, cmdq, oe, oo, value);
d364 1
a364 1
		o = cmd_set_option_colour(self, cmdq, oe, oo, value);
d369 1
a369 1
		o = cmd_set_option_attributes(self, cmdq, oe, oo, value);
d374 1
a374 1
		o = cmd_set_option_flag(self, cmdq, oe, oo, value);
d377 1
a377 1
		o = cmd_set_option_choice(self, cmdq, oe, oo, value);
d380 1
a380 1
		o = cmd_set_option_style(self, cmdq, oe, oo, value);
d390 1
a390 1
cmd_set_option_string(struct cmd *self, __unused struct cmd_q *cmdq,
d412 1
a412 1
cmd_set_option_number(__unused struct cmd *self, struct cmd_q *cmdq,
d421 1
a421 1
		cmdq_error(cmdq, "value is %s: %s", errstr, value);
d430 1
a430 1
cmd_set_option_key(__unused struct cmd *self, struct cmd_q *cmdq,
d438 1
a438 1
		cmdq_error(cmdq, "bad key: %s", value);
d447 1
a447 1
cmd_set_option_colour(__unused struct cmd *self, struct cmd_q *cmdq,
d454 1
a454 1
		cmdq_error(cmdq, "bad colour: %s", value);
d463 1
a463 1
cmd_set_option_attributes(__unused struct cmd *self, struct cmd_q *cmdq,
d470 1
a470 1
		cmdq_error(cmdq, "bad attributes: %s", value);
d479 1
a479 1
cmd_set_option_flag(__unused struct cmd *self, struct cmd_q *cmdq,
d497 1
a497 1
			cmdq_error(cmdq, "bad value: %s", value);
d507 1
a507 1
cmd_set_option_choice(__unused struct cmd *self, struct cmd_q *cmdq,
d526 1
a526 1
				cmdq_error(cmdq, "ambiguous value: %s", value);
d532 1
a532 1
			cmdq_error(cmdq, "unknown value: %s", value);
d542 1
a542 1
cmd_set_option_style(struct cmd *self, struct cmd_q *cmdq,
d552 1
a552 1
		cmdq_error(cmdq, "bad style: %s", value);
@


1.99
log
@Add static in cmd-* and fix a few other nits.
@
text
@d1 1
a1 1
/* $OpenBSD: cmd-set-option.c,v 1.98 2016/10/09 07:58:35 nicm Exp $ */
d76 1
a76 1
	.flags = 0,
d89 1
a89 1
	.flags = 0,
@


1.98
log
@Handle NULL window or session for user options.
@
text
@d1 1
a1 1
/* $OpenBSD: cmd-set-option.c,v 1.97 2016/09/26 09:02:34 nicm Exp $ */
d30 1
a30 1
enum cmd_retval	cmd_set_option_exec(struct cmd *, struct cmd_q *);
d32 1
a32 1
enum cmd_retval	cmd_set_option_user(struct cmd *, struct cmd_q *,
d35 6
a40 6
int	cmd_set_option_unset(struct cmd *, struct cmd_q *,
	    const struct options_table_entry *, struct options *,
	    const char *);
int	cmd_set_option_set(struct cmd *, struct cmd_q *,
	    const struct options_table_entry *, struct options *,
	    const char *);
d42 1
a42 4
struct options_entry *cmd_set_option_string(struct cmd *, struct cmd_q *,
	    const struct options_table_entry *, struct options *,
	    const char *);
struct options_entry *cmd_set_option_number(struct cmd *, struct cmd_q *,
d45 1
a45 1
struct options_entry *cmd_set_option_key(struct cmd *, struct cmd_q *,
d48 1
a48 1
struct options_entry *cmd_set_option_colour(struct cmd *, struct cmd_q *,
d51 1
a51 1
struct options_entry *cmd_set_option_attributes(struct cmd *, struct cmd_q *,
d54 4
a57 1
struct options_entry *cmd_set_option_flag(struct cmd *, struct cmd_q *,
d60 1
a60 1
struct options_entry *cmd_set_option_choice(struct cmd *, struct cmd_q *,
d63 1
a63 1
struct options_entry *cmd_set_option_style(struct cmd *, struct cmd_q *,
d93 1
a93 1
enum cmd_retval
d226 1
a226 1
enum cmd_retval
d304 1
a304 1
int
d334 1
a334 1
int
d389 1
a389 1
struct options_entry *
d411 1
a411 1
struct options_entry *
d429 1
a429 1
struct options_entry *
d446 1
a446 1
struct options_entry *
d462 1
a462 1
struct options_entry *
d478 1
a478 1
struct options_entry *
d506 1
a506 1
struct options_entry *
d541 1
a541 1
struct options_entry *
@


1.97
log
@Support set -a (append) with user options, suggested by Xandor Schiefer.
@
text
@d1 1
a1 1
/* $OpenBSD: cmd-set-option.c,v 1.96 2016/05/30 09:50:20 nicm Exp $ */
d235 1
d243 9
a251 1
		else
d256 9
a264 1
		else
@


1.96
log
@Cache the window styles and do not look up the window-style options
unless they have changed.
@
text
@d1 1
a1 1
/* $OpenBSD: cmd-set-option.c,v 1.95 2016/04/29 15:00:48 nicm Exp $ */
d230 5
a234 4
	struct args	*args = self->args;
	struct session	*s = cmdq->state.tflag.s;
	struct winlink	*wl = cmdq->state.tflag.wl;
	struct options	*oo;
d266 2
a267 5
		if (valstr == NULL) {
			cmdq_error(cmdq, "empty value");
			return (CMD_RETURN_ERROR);
		}
		if (args_has(args, 'o') && options_find1(oo, optstr) != NULL) {
d274 8
a281 1
		options_set_string(oo, optstr, "%s", valstr);
@


1.95
log
@Add option to include status text in the pane borders. If
pane-border-status is set to "top" or "bottom" (rather than "off"),
every pane has a permanent top or bottom border containing the text from
pane-border-format.

Based on a diff sent long ago by Jonathan Slenders, mostly rewritten and
simplified by me.
@
text
@d1 1
a1 1
/* $OpenBSD: cmd-set-option.c,v 1.94 2016/03/03 14:15:22 nicm Exp $ */
d203 5
@


1.94
log
@show-* and set-* need to handle a missing target.
@
text
@d1 1
a1 1
/* $OpenBSD: cmd-set-option.c,v 1.93 2016/01/19 15:59:12 nicm Exp $ */
d203 6
@


1.93
log
@I no longer use my SourceForge address so replace it.
@
text
@d1 1
a1 1
/* $OpenBSD: cmd-set-option.c,v 1.92 2015/12/14 00:31:54 nicm Exp $ */
d103 1
a103 1
	const char				*optstr, *valstr;
d143 9
a151 8
		else {
			if (wl == NULL) {
				cmdq_error(cmdq,
				    "couldn't set '%s'%s", optstr,
				    (!args_has(args, 't') && !args_has(args,
				    'g')) ? " need target window or -g" : "");
				return (CMD_RETURN_ERROR);
			}
a152 1
		}
d156 9
a164 8
		else {
			if (s == NULL) {
				cmdq_error(cmdq,
				    "couldn't set '%s'%s", optstr,
				    (!args_has(args, 't') && !args_has(args,
				    'g')) ? " need target session or -g" : "");
				return (CMD_RETURN_ERROR);
			}
a165 1
		}
@


1.92
log
@Instead of combined flags for -c, -s, -t, split into different sets
using an enum and simplify the parsing code.
@
text
@d1 1
a1 1
/* $OpenBSD: cmd-set-option.c,v 1.91 2015/12/13 21:53:57 nicm Exp $ */
d4 1
a4 1
 * Copyright (c) 2007 Nicholas Marriott <nicm@@users.sourceforge.net>
@


1.91
log
@Use member names in cmd_entry definitions so I stop getting confused
about the order.
@
text
@d1 1
a1 1
/* $OpenBSD: cmd-set-option.c,v 1.90 2015/12/13 14:32:38 nicm Exp $ */
d74 3
a76 1
	.flags = CMD_WINDOW_T|CMD_CANFAIL,
d87 3
a89 1
	.flags = CMD_WINDOW_T|CMD_CANFAIL,
@


1.90
log
@Instead of every command resolving the target (-t or -s) itself, prepare
the state (client, session, winlink, pane) for it it before entering the
command. Each command provides some flags that tell the prepare step
what it is expecting.

This is a requirement for having hooks on commands (for example, if you
hook "select-window -t1:2", the hook command should to operate on window
1:2 not whatever it thinks is the current window), and should allow some
other target improvements.

The old cmd_find_* functions remain for the moment but that layer will
be dropped later.

Joint work with Thomas Adam.
@
text
@d1 1
a1 1
/* $OpenBSD: cmd-set-option.c,v 1.89 2015/12/12 18:32:24 nicm Exp $ */
d68 8
a75 5
	"set-option", "set",
	"agoqst:uw", 1, 2,
	"[-agosquw] [-t target-window] option [value]",
	CMD_WINDOW_T|CMD_CANFAIL,
	cmd_set_option_exec
d79 8
a86 5
	"set-window-option", "setw",
	"agoqt:u", 1, 2,
	"[-agoqu] " CMD_TARGET_WINDOW_USAGE " option [value]",
	CMD_WINDOW_T|CMD_CANFAIL,
	cmd_set_option_exec
@


1.89
log
@Add key-table option to set the default key table for a session, allows
different key bindings for different sessions and a few other things.
@
text
@d1 1
a1 1
/* $OpenBSD: cmd-set-option.c,v 1.88 2015/12/12 18:19:00 nicm Exp $ */
d70 2
a71 2
	"[-agosquw] [-t target-session|target-window] option [value]",
	0,
d79 1
a79 1
	0,
d87 4
a91 3
	struct session				*s;
	struct winlink				*wl;
	struct client				*c;
a92 1
	struct window				*w;
a133 1
			wl = cmd_find_window(cmdq, args_get(args, 't'), NULL);
a146 1
			s = cmd_find_session(cmdq, args_get(args, 't'), 0);
d210 2
a211 2
	struct session	*s;
	struct winlink	*wl;
d220 1
a220 4
		else {
			wl = cmd_find_window(cmdq, args_get(args, 't'), NULL);
			if (wl == NULL)
				return (CMD_RETURN_ERROR);
a221 1
		}
d225 1
a225 4
		else {
			s = cmd_find_session(cmdq, args_get(args, 't'), 0);
			if (s == NULL)
				return (CMD_RETURN_ERROR);
a226 1
		}
@


1.88
log
@Allow prefix and prefix2 to be set to None to disable (useful if you
would rather bind the prefix in the root table).
@
text
@d1 1
a1 1
/* $OpenBSD: cmd-set-option.c,v 1.87 2015/11/20 12:01:19 nicm Exp $ */
d185 4
@


1.87
log
@Instead of separate tables for different types of options, give each
option a scope type (server, session, window) in one table.
@
text
@d1 1
a1 1
/* $OpenBSD: cmd-set-option.c,v 1.86 2015/11/18 14:27:44 nicm Exp $ */
d399 2
a400 1
	if ((key = key_string_lookup_string(value)) == KEYC_NONE) {
@


1.86
log
@Use __unused rather than rolling our own.
@
text
@d1 1
a1 1
/* $OpenBSD: cmd-set-option.c,v 1.85 2015/11/12 11:05:34 nicm Exp $ */
d87 1
a87 1
	const struct options_table_entry	*table, *oe;
d111 2
a112 2
	table = oe = NULL;
	if (options_table_find(optstr, &table, &oe) != 0) {
d127 2
a128 2
	/* Work out the tree from the table. */
	if (table == server_options_table)
d130 1
a130 1
	else if (table == window_options_table) {
d144 1
a144 1
	} else if (table == session_options_table) {
@


1.85
log
@Support UTF-8 key bindings by expanding the key type from int to
uint64_t and converting UTF-8 to Unicode on input and the reverse on
output. (This allows key bindings, there are still omissions - the
largest being that the various prompts do not accept UTF-8.)
@
text
@d1 1
a1 1
/* $OpenBSD: cmd-set-option.c,v 1.84 2015/10/27 15:58:42 nicm Exp $ */
d353 1
a353 1
cmd_set_option_string(struct cmd *self, unused struct cmd_q *cmdq,
d375 1
a375 1
cmd_set_option_number(unused struct cmd *self, struct cmd_q *cmdq,
d393 1
a393 1
cmd_set_option_key(unused struct cmd *self, struct cmd_q *cmdq,
d409 1
a409 1
cmd_set_option_colour(unused struct cmd *self, struct cmd_q *cmdq,
d425 1
a425 1
cmd_set_option_attributes(unused struct cmd *self, struct cmd_q *cmdq,
d441 1
a441 1
cmd_set_option_flag(unused struct cmd *self, struct cmd_q *cmdq,
d469 1
a469 1
cmd_set_option_choice(unused struct cmd *self, struct cmd_q *cmdq,
@


1.84
log
@Move struct options into options.c.
@
text
@d1 1
a1 1
/* $OpenBSD: cmd-set-option.c,v 1.83 2015/09/14 13:22:02 nicm Exp $ */
d397 1
a397 1
	int	key;
@


1.83
log
@Remove some extra blank lines.
@
text
@d1 1
a1 1
/* $OpenBSD: cmd-set-option.c,v 1.82 2015/08/29 08:30:54 nicm Exp $ */
d129 1
a129 1
		oo = &global_options;
d132 1
a132 1
			oo = &global_w_options;
d142 1
a142 1
			oo = &wl->window->options;
d146 1
a146 1
			oo = &global_s_options;
d156 1
a156 1
			oo = &s->options;
d182 1
a182 1
			if (options_get_number(&w->options, "automatic-rename"))
d213 1
a213 1
		oo = &global_options;
d217 1
a217 1
			oo = &global_w_options;
d222 1
a222 1
			oo = &wl->window->options;
d226 1
a226 1
			oo = &global_s_options;
d231 1
a231 1
			oo = &s->options;
d279 1
a279 1
	if (args_has(args, 'g') || oo == &global_options) {
@


1.82
log
@Move alerts onto events rather than checking every loop.
@
text
@d1 1
a1 1
/* $OpenBSD: cmd-set-option.c,v 1.81 2015/08/29 00:29:15 nicm Exp $ */
a264 1

@


1.81
log
@Better take on reducing the name timer. Again check for name changes in
the main loop after events that may have changed the pane, but do so at
most once every 500 millis. If the pane changed too soon, use a timer to
ensure that a check happens later.
@
text
@d1 1
a1 1
/* $OpenBSD: cmd-set-option.c,v 1.79 2015/08/28 15:51:48 nicm Exp $ */
d189 2
@


1.80
log
@Revert previous; we do need a timer, until I have a better idea. We
can't do the name check every loop, because that is too expensive, and
we can't make sure it only happens infrequently because we have no idea
when the next change will happen.
@
text
@d1 1
a1 1
/* $OpenBSD: cmd-set-option.c,v 1.78 2015/08/28 13:12:20 nicm Exp $ */
d183 1
a183 3
				queue_window_name(w);
			else if (event_initialized(&w->name_timer))
				evtimer_del(&w->name_timer);
@


1.79
log
@We now only checking for name changes when the active pane has changed,
but that can only happen when we have already been woken up by a read
event, so there is no need for a timer, we can just check the changed
flag on the end of that read event (we already loop over the windows to
check for bells etc anyway).
@
text
@d183 3
a185 1
				w->active->flags |= PANE_CHANGED;
@


1.78
log
@Per-session timers for locking, and remove the global one-second timer.
@
text
@d1 1
a1 1
/* $OpenBSD: cmd-set-option.c,v 1.77 2015/08/28 12:16:28 nicm Exp $ */
d183 1
a183 3
				queue_window_name(w);
			else if (event_initialized(&w->name_timer))
				evtimer_del(&w->name_timer);
@


1.77
log
@Run status update on a per-client timer at status-interval.
@
text
@d1 1
a1 1
/* $OpenBSD: cmd-set-option.c,v 1.76 2015/07/27 08:45:45 nicm Exp $ */
d179 1
a179 1
	/* Start or stop timers when name or status options changed. */
@


1.76
log
@Make -q suppress ambiguous option warnings too, from Cam Hutchison.
@
text
@d1 1
a1 1
/* $OpenBSD: cmd-set-option.c,v 1.75 2015/06/04 14:29:33 nicm Exp $ */
d179 1
a179 1
	/* Start or stop timers when automatic-rename changed. */
d188 3
@


1.75
log
@Make unsetting a global option restore it to the default. Diff lying
around for a while, I have forgotten who suggested it :-/.
@
text
@d1 1
a1 1
/* $OpenBSD: cmd-set-option.c,v 1.74 2015/04/24 23:17:11 nicm Exp $ */
d113 5
a117 2
		cmdq_error(cmdq, "ambiguous option: %s", optstr);
		return (CMD_RETURN_ERROR);
@


1.74
log
@Convert clients list into a TAILQ.
@
text
@d1 1
a1 1
/* $OpenBSD: cmd-set-option.c,v 1.73 2015/04/24 21:38:18 nicm Exp $ */
a268 4
	if (args_has(args, 'g')) {
		cmdq_error(cmdq, "can't unset global option: %s", oe->name);
		return (-1);
	}
d274 14
a287 1
	options_remove(oo, oe->name);
@


1.73
log
@Allow choice options (multiple states) to be toggled between states 0
and 1.
@
text
@d1 1
a1 1
/* $OpenBSD: cmd-set-option.c,v 1.72 2015/04/22 15:30:11 nicm Exp $ */
a93 1
	u_int					 i;
d188 2
a189 3
	for (i = 0; i < ARRAY_LENGTH(&clients); i++) {
		c = ARRAY_ITEM(&clients, i);
		if (c != NULL && c->session != NULL)
@


1.72
log
@Change the windows array into an RB tree and fix some places where we
were only looking at the first winlink for a window in a session.
@
text
@d1 1
a1 1
/* $OpenBSD: cmd-set-option.c,v 1.71 2014/10/20 22:29:25 nicm Exp $ */
d292 9
a300 3
	if (oe->type != OPTIONS_TABLE_FLAG && value == NULL) {
		cmdq_error(cmdq, "empty value");
		return (-1);
d464 19
a482 8
	n = 0;
	for (choicep = oe->choices; *choicep != NULL; choicep++) {
		n++;
		if (strncmp(*choicep, value, strlen(value)) != 0)
			continue;

		if (choice != -1) {
			cmdq_error(cmdq, "ambiguous value: %s", value);
a484 5
		choice = n - 1;
	}
	if (choice == -1) {
		cmdq_error(cmdq, "unknown value: %s", value);
		return (NULL);
@


1.71
log
@Instead of setting up the default keys by building the key struct
directly with a helper function in the cmd_entry, include a table of
bind-key commands and pass them through the command parser and a
temporary cmd_q.

As well as being smaller, this will allow default bindings to be command
sequences which will probably be needed soon.
@
text
@d1 1
a1 1
/* $OpenBSD: cmd-set-option.c,v 1.70 2014/09/01 21:50:18 nicm Exp $ */
d179 1
a179 3
		for (i = 0; i < ARRAY_LENGTH(&windows); i++) {
			if ((w = ARRAY_ITEM(&windows, i)) == NULL)
				continue;
@


1.70
log
@Various minor style and spacing nits.
@
text
@d1 1
a1 1
/* $OpenBSD: cmd-set-option.c,v 1.69 2014/04/17 14:45:49 nicm Exp $ */
a71 1
	NULL,
a79 1
	NULL,
@


1.69
log
@Some more long lines.
@
text
@d1 1
a1 1
/* $OpenBSD: cmd-set-option.c,v 1.68 2014/04/17 07:55:43 nicm Exp $ */
d204 1
a204 1
cmd_set_option_user(struct cmd *self, struct cmd_q *cmdq, const char* optstr,
d257 1
a257 1
				return CMD_RETURN_ERROR;
@


1.68
log
@Remove the "info" message mechanism, this was only used for about five
mostly useless and annoying messages. Change those commands to silence
on success like all the others. Still accept the -q command line flag
and "quiet" server option for now.
@
text
@d1 1
a1 1
/* $OpenBSD: cmd-set-option.c,v 1.67 2014/04/17 07:51:38 nicm Exp $ */
d270 2
a271 1
    const struct options_table_entry *oe, struct options *oo, const char *value)
d291 2
a292 1
    const struct options_table_entry *oe, struct options *oo, const char *value)
d340 2
a341 1
    const struct options_table_entry *oe, struct options *oo, const char *value)
d362 2
a363 1
    const struct options_table_entry *oe, struct options *oo, const char *value)
d380 2
a381 1
    const struct options_table_entry *oe, struct options *oo, const char *value)
d396 2
a397 1
    const struct options_table_entry *oe, struct options *oo, const char *value)
d412 2
a413 1
    const struct options_table_entry *oe, struct options *oo, const char *value)
d428 2
a429 1
    const struct options_table_entry *oe, struct options *oo, const char *value)
@


1.67
log
@Extend the -q flag to set-option to suppress errors about unknown
options - this will allow options to be removed more easily.
@
text
@d1 1
a1 1
/* $OpenBSD: cmd-set-option.c,v 1.66 2014/02/17 18:12:47 nicm Exp $ */
a261 4
		if (!args_has(args, 'q')) {
			cmdq_info(cmdq, "set option: %s -> %s", optstr,
			    valstr);
		}
a283 2
	if (!args_has(args, 'q'))
		cmdq_info(cmdq, "unset option: %s", oe->name);
a291 1
	struct args		*args = self->args;
a292 1
	const char		*s;
a331 4

	s = options_table_print_entry(oe, o, 0);
	if (!args_has(args, 'q'))
		cmdq_info(cmdq, "set option: %s -> %s", oe->name, s);
@


1.66
log
@Don't crash when given a invalid colour, reported by Felix Rosencrantz,
fix from Thomas Adam.
@
text
@d1 1
a1 1
/* $OpenBSD: cmd-set-option.c,v 1.65 2014/02/14 13:59:01 nicm Exp $ */
d120 5
a124 2
		cmdq_error(cmdq, "unknown option: %s", optstr);
		return (CMD_RETURN_ERROR);
d169 4
a172 2
			if (!args_has(args, 'q'))
				cmdq_print(cmdq, "already set: %s", optstr);
d237 5
a241 2
			cmdq_error(cmdq, "unknown option: %s", optstr);
			return (CMD_RETURN_ERROR);
d255 4
a258 2
			if (!args_has(args, 'q'))
				cmdq_print(cmdq, "already set: %s", optstr);
@


1.65
log
@Style nit - no space between function name and bracket.
@
text
@d1 1
a1 1
/* $OpenBSD: cmd-set-option.c,v 1.64 2014/01/28 23:07:09 nicm Exp $ */
d310 2
a311 1
		style_update_new(oo, o->name, oe->style);
d315 2
a316 1
		style_update_new(oo, o->name, oe->style);
@


1.64
log
@Allow replacing each of the many sets of separate foo-{fg,bg,attr}
options with a single foo-style option. For example:

    set -g status-fg yellow
    set -g status-bg red
    set -g status-attr blink

Becomes:

    set -g status-style fg=yellow,bg=red,blink

The -a flag to set can be used to add to rather than replace a style. So:

    set -g status-bg red

Becomes:

    set -ag status-style bg=red

Currently this is fully backwards compatible (all *-{fg,bg,attr} options
remain) but the plan is to deprecate them over time.

From Tiago Cunha.
@
text
@d1 1
a1 1
/* $OpenBSD: cmd-set-option.c,v 1.63 2013/10/10 12:00:23 nicm Exp $ */
d175 1
a175 1
	if (strcmp (oe->name, "automatic-rename") == 0) {
@


1.63
log
@Remove the barely-used and unnecessary command check() function.
@
text
@d1 1
a1 1
/* $OpenBSD: cmd-set-option.c,v 1.62 2013/07/05 15:10:38 nicm Exp $ */
d63 3
d310 1
d314 1
d322 3
d472 20
@


1.62
log
@Clarify error messages when setting options, from Thomas Adam.
@
text
@d1 1
a1 1
/* $OpenBSD: cmd-set-option.c,v 1.61 2013/03/24 09:55:02 nicm Exp $ */
a69 1
	NULL,
a77 1
	NULL,
@


1.61
log
@Add a -o option to set-option to prevent setting an option already set,
from Thiago Padilha.
@
text
@d1 1
a1 1
/* $OpenBSD: cmd-set-option.c,v 1.60 2013/03/24 09:54:10 nicm Exp $ */
d131 5
a135 1
			if (wl == NULL)
d137 1
d145 5
a149 1
			if (s == NULL)
d151 1
@


1.60
log
@Add a command queue to standardize and simplify commands that call other
commands and allow a command to block execution of subsequent
commands. This allows run-shell and if-shell to be synchronous which has
been much requested.

Each client has a default command queue and commands are consumed one at
a time from it. A command may suspend execution from the queue by
returning CMD_RETURN_WAIT and then resume it by calling cmd_continue() -
for example run-shell does this from the callback that is fired after
the job is freed.

When the command queue becomes empty, command clients are automatically
exited (unless attaching). A callback is also fired - this is used for
nested commands in, for example, if-shell which can block execution of
the client's cmdq until a new cmdq becomes empty.

Also merge all the old error/info/print functions together and lose the
old curclient/cmdclient distinction - a cmdq is bound to one client (or
none if in the configuration file), this is a command client if
c->session is NULL otherwise an attached client.
@
text
@d1 1
a1 1
/* $OpenBSD: cmd-set-option.c,v 1.59 2013/03/21 16:17:01 nicm Exp $ */
d33 1
a33 1
		    const char *, const char *);
d66 2
a67 2
	"agqst:uw", 1, 2,
	"[-agsquw] [-t target-session|target-window] option [value]",
d76 2
a77 2
	"agqt:u", 1, 2,
	"[-agqu] " CMD_TARGET_WINDOW_USAGE " option [value]",
d154 5
d234 5
@


1.59
log
@Add user options, prefixed with @@. May be set to any arbitrary string.
@
text
@d1 1
a1 1
/* $OpenBSD: cmd-set-option.c,v 1.58 2013/03/21 16:15:52 nicm Exp $ */
d30 1
a30 1
enum cmd_retval	cmd_set_option_exec(struct cmd *, struct cmd_ctx *);
d32 1
a32 1
enum cmd_retval	cmd_set_option_user(struct cmd *, struct cmd_ctx *,
d35 1
a35 1
int	cmd_set_option_unset(struct cmd *, struct cmd_ctx *,
d38 1
a38 1
int	cmd_set_option_set(struct cmd *, struct cmd_ctx *,
d42 1
a42 1
struct options_entry *cmd_set_option_string(struct cmd *, struct cmd_ctx *,
d45 1
a45 1
struct options_entry *cmd_set_option_number(struct cmd *, struct cmd_ctx *,
d48 1
a48 1
struct options_entry *cmd_set_option_key(struct cmd *, struct cmd_ctx *,
d51 1
a51 1
struct options_entry *cmd_set_option_colour(struct cmd *, struct cmd_ctx *,
d54 1
a54 1
struct options_entry *cmd_set_option_attributes(struct cmd *, struct cmd_ctx *,
d57 1
a57 1
struct options_entry *cmd_set_option_flag(struct cmd *, struct cmd_ctx *,
d60 1
a60 1
struct options_entry *cmd_set_option_choice(struct cmd *, struct cmd_ctx *,
d85 1
a85 1
cmd_set_option_exec(struct cmd *self, struct cmd_ctx *ctx)
d100 1
a100 1
		ctx->error(ctx, "invalid option");
d110 1
a110 1
		return (cmd_set_option_user(self, ctx, optstr, valstr));
d115 1
a115 1
		ctx->error(ctx, "ambiguous option: %s", optstr);
d119 1
a119 1
		ctx->error(ctx, "unknown option: %s", optstr);
d130 1
a130 1
			wl = cmd_find_window(ctx, args_get(args, 't'), NULL);
d139 1
a139 1
			s = cmd_find_session(ctx, args_get(args, 't'), 0);
d145 1
a145 1
		ctx->error(ctx, "unknown table");
d151 1
a151 1
		if (cmd_set_option_unset(self, ctx, oe, oo, valstr) != 0)
d154 1
a154 1
		if (cmd_set_option_set(self, ctx, oe, oo, valstr) != 0)
d183 1
a183 1
cmd_set_option_user(struct cmd *self, struct cmd_ctx *ctx, const char* optstr,
d198 1
a198 1
			wl = cmd_find_window(ctx, args_get(args, 't'), NULL);
d207 1
a207 1
			s = cmd_find_session(ctx, args_get(args, 't'), 0);
d216 1
a216 1
			ctx->error(ctx, "unknown option: %s", optstr);
d220 1
a220 1
			ctx->error(ctx, "value passed to unset option: %s",
d227 1
a227 1
			ctx->error(ctx, "empty value");
d231 4
a234 2
		if (!args_has(args, 'q'))
			ctx->info(ctx, "set option: %s -> %s", optstr, valstr);
d242 1
a242 1
cmd_set_option_unset(struct cmd *self, struct cmd_ctx *ctx,
d248 1
a248 1
		ctx->error(ctx, "can't unset global option: %s", oe->name);
d252 1
a252 1
		ctx->error(ctx, "value passed to unset option: %s", oe->name);
d258 1
a258 1
		ctx->info(ctx, "unset option: %s", oe->name);
d264 1
a264 1
cmd_set_option_set(struct cmd *self, struct cmd_ctx *ctx,
d272 1
a272 1
		ctx->error(ctx, "empty value");
d279 1
a279 1
		o = cmd_set_option_string(self, ctx, oe, oo, value);
d282 1
a282 1
		o = cmd_set_option_number(self, ctx, oe, oo, value);
d285 1
a285 1
		o = cmd_set_option_key(self, ctx, oe, oo, value);
d288 1
a288 1
		o = cmd_set_option_colour(self, ctx, oe, oo, value);
d291 1
a291 1
		o = cmd_set_option_attributes(self, ctx, oe, oo, value);
d294 1
a294 1
		o = cmd_set_option_flag(self, ctx, oe, oo, value);
d297 1
a297 1
		o = cmd_set_option_choice(self, ctx, oe, oo, value);
d305 1
a305 1
		ctx->info(ctx, "set option: %s -> %s", oe->name, s);
d311 1
a311 1
cmd_set_option_string(struct cmd *self, unused struct cmd_ctx *ctx,
d332 1
a332 1
cmd_set_option_number(unused struct cmd *self, struct cmd_ctx *ctx,
d340 1
a340 1
		ctx->error(ctx, "value is %s: %s", errstr, value);
d349 1
a349 1
cmd_set_option_key(unused struct cmd *self, struct cmd_ctx *ctx,
d355 1
a355 1
		ctx->error(ctx, "bad key: %s", value);
d364 1
a364 1
cmd_set_option_colour(unused struct cmd *self, struct cmd_ctx *ctx,
d370 1
a370 1
		ctx->error(ctx, "bad colour: %s", value);
d379 1
a379 1
cmd_set_option_attributes(unused struct cmd *self, struct cmd_ctx *ctx,
d385 1
a385 1
		ctx->error(ctx, "bad attributes: %s", value);
d394 1
a394 1
cmd_set_option_flag(unused struct cmd *self, struct cmd_ctx *ctx,
d411 1
a411 1
			ctx->error(ctx, "bad value: %s", value);
d421 3
a423 2
cmd_set_option_choice(unused struct cmd *self, struct cmd_ctx *ctx,
    const struct options_table_entry *oe, struct options *oo, const char *value)
d435 1
a435 1
			ctx->error(ctx, "ambiguous value: %s", value);
d441 1
a441 1
		ctx->error(ctx, "unknown value: %s", value);
@


1.58
log
@Add -v to set and setw to show only option value.
@
text
@d1 1
a1 1
/* $OpenBSD: cmd-set-option.c,v 1.57 2012/07/11 07:10:15 nicm Exp $ */
d30 4
a33 1
enum cmd_retval	 cmd_set_option_exec(struct cmd *, struct cmd_ctx *);
d108 4
d180 57
@


1.57
log
@Make command exec functions return an enum rather than -1/0/1 values and
add a new value to mean "leave client running but don't attach" to fix
problems with using some commands in a command sequence. Most of the
work by Thomas Adam, problem reported by "jspenguin" on SF bug 3535531.
@
text
@d1 1
a1 1
/* $OpenBSD: cmd-set-option.c,v 1.56 2012/07/10 11:53:01 nicm Exp $ */
d237 1
a237 1
	s = options_table_print_entry(oe, o);
@


1.56
log
@xfree is not particularly helpful, remove it. From Thomas Adam.
@
text
@d1 1
a1 1
/* $OpenBSD: cmd-set-option.c,v 1.55 2012/04/08 06:47:26 nicm Exp $ */
d30 1
a30 1
int	cmd_set_option_exec(struct cmd *, struct cmd_ctx *);
d81 1
a81 1
int
d98 1
a98 1
		return (-1);
d109 1
a109 1
		return (-1);
d113 1
a113 1
		return (-1);
d125 1
a125 1
				return (-1);
d134 1
a134 1
				return (-1);
d139 1
a139 1
		return (-1);
d145 1
a145 1
			return (-1);
d148 1
a148 1
			return (-1);
d171 1
a171 1
	return (0);
@


1.55
log
@Do not fire name timer when automatic-rename is off, from Tim Ruehsen a
while ago.
@
text
@d1 1
a1 1
/* $OpenBSD: cmd-set-option.c,v 1.54 2012/03/17 21:33:33 nicm Exp $ */
d260 1
a260 1
	xfree(newval);
@


1.54
log
@Add -q option to set-option to turn off info message, from marcel partap.
@
text
@d1 1
a1 1
/* $OpenBSD: cmd-set-option.c,v 1.53 2012/02/25 12:57:42 nicm Exp $ */
d90 1
d149 12
@


1.53
log
@Allow a single option to be specified to show-options to show just that
option.
@
text
@d1 1
a1 1
/* $OpenBSD: cmd-set-option.c,v 1.52 2012/01/21 08:40:09 nicm Exp $ */
d63 2
a64 2
	"agst:uw", 1, 2,
	"[-agsuw] [-t target-session|target-window] option [value]",
d73 2
a74 2
	"agt:u", 1, 2,
	"[-agu] " CMD_TARGET_WINDOW_USAGE " option [value]",
d178 2
a179 1
	ctx->info(ctx, "unset option: %s", oe->name);
d188 1
d225 2
a226 1
	ctx->info(ctx, "set option: %s -> %s", oe->name, s);
d235 1
a235 1
	struct args	*args = self->args;
@


1.52
log
@Drop the ability to have a list of keys in the prefix in favour of two
separate options, prefix and prefix2. This simplifies the code and gets
rid the data options type which was only used for this one option.

Also add a -2 flag to send-prefix to send the secondary prefix key,
fixing a cause of minor irritation.

People who want three prefix keys are out of luck :-).
@
text
@d1 1
a1 1
/* $OpenBSD: cmd-set-option.c,v 1.51 2011/04/05 19:37:01 nicm Exp $ */
a31 3
int	cmd_set_option_find(const char *, const struct options_table_entry **,
	    const struct options_table_entry **);

a80 33
/* Look for an option in all three tables. */
int
cmd_set_option_find(
    const char *optstr, const struct options_table_entry **table,
    const struct options_table_entry **oe)
{
	static const struct options_table_entry	*tables[] = {
		server_options_table,
		window_options_table,
		session_options_table
	};
	const struct options_table_entry	*oe_loop;
	u_int					 i;

	for (i = 0; i < nitems(tables); i++) {
		for (oe_loop = tables[i]; oe_loop->name != NULL; oe_loop++) {
			if (strncmp(oe_loop->name, optstr, strlen(optstr)) != 0)
				continue;

			/* If already found, ambiguous. */
			if (*oe != NULL)
				return (-1);
			*oe = oe_loop;
			*table = tables[i];

			/* Bail now if an exact match. */
			if (strcmp((*oe)->name, optstr) == 0)
				break;
		}
	}
	return (0);
}

d106 1
a106 1
	if (cmd_set_option_find(optstr, &table, &oe) != 0) {
@


1.51
log
@Add a flag to cmd_find_session so that attach-session can prefer
unattached sessions when choosing the most recently used (if -t is not
given). Suggested by claudio@@.
@
text
@d1 1
a1 1
/* $OpenBSD: cmd-set-option.c,v 1.50 2011/03/29 21:09:13 nicm Exp $ */
d48 1
a48 1
struct options_entry *cmd_set_option_keys(struct cmd *, struct cmd_ctx *,
d239 2
a240 2
	case OPTIONS_TABLE_KEYS:
		o = cmd_set_option_keys(self, ctx, oe, oo, value);
d301 1
a301 1
/* Set a keys option. */
d303 1
a303 1
cmd_set_option_keys(unused struct cmd *self, struct cmd_ctx *ctx,
d306 5
a310 16
	struct keylist	*keylist;
	char		*copy, *ptr, *s;
	int		 key;

	keylist = xmalloc(sizeof *keylist);
	ARRAY_INIT(keylist);

	ptr = copy = xstrdup(value);
	while ((s = strsep(&ptr, ",")) != NULL) {
		if ((key = key_string_lookup_string(s)) == KEYC_NONE) {
			ctx->error(ctx, "unknown key: %s", s);
			xfree(copy);
			xfree(keylist);
			return (NULL);
		}
		ARRAY_ADD(keylist, key);
a311 1
	xfree(copy);
d313 1
a313 1
	return (options_set_data(oo, oe->name, keylist, xfree));
@


1.50
log
@For convenience, work out what type of option is being set by name
regardless of the -s or -w flags (these remain documented however).
@
text
@d1 1
a1 1
/* $OpenBSD: cmd-set-option.c,v 1.49 2011/03/29 21:07:08 nicm Exp $ */
d167 1
a167 1
			s = cmd_find_session(ctx, args_get(args, 't'));
@


1.49
log
@Checking for particular options and redrawing is not necessary as we
already redraw unconditionally.
@
text
@d1 1
a1 1
/* $OpenBSD: cmd-set-option.c,v 1.48 2011/03/29 20:31:22 nicm Exp $ */
d32 3
d84 33
d121 1
a121 1
	const struct options_table_entry	*table, *oe, *oe_loop;
d129 24
a152 2
	/* Work out the options tree and table to use. */
	if (args_has(self->args, 's')) {
d154 1
a154 4
		table = server_options_table;
	} else if (args_has(self->args, 'w') ||
	    self->entry == &cmd_set_window_option_entry) {
		table = window_options_table;
d163 1
a163 2
	} else {
		table = session_options_table;
d172 2
a173 31
	}

	/* Get the option name and value. */
	optstr = args->argv[0];
	if (*optstr == '\0') {
		ctx->error(ctx, "invalid option");
		return (-1);
	}
	if (args->argc < 2)
		valstr = NULL;
	else
		valstr = args->argv[1];

	/* Find the option table entry. */
	oe = NULL;
	for (oe_loop = table; oe_loop->name != NULL; oe_loop++) {
		if (strncmp(oe_loop->name, optstr, strlen(optstr)) != 0)
			continue;

		if (oe != NULL) {
			ctx->error(ctx, "ambiguous option: %s", optstr);
			return (-1);
		}
		oe = oe_loop;

		/* Bail now if an exact match. */
		if (strcmp(oe->name, optstr) == 0)
			break;
	}
	if (oe == NULL) {
		ctx->error(ctx, "unknown option: %s", optstr);
@


1.48
log
@Update an out-of-date and inaccurate comment.
@
text
@d1 1
a1 1
/* $OpenBSD: cmd-set-option.c,v 1.47 2011/01/26 01:54:56 nicm Exp $ */
a166 13
	}

	/* Force redraw when some special cases change. */
	if (strcmp(oe->name, "status-left") == 0 ||
	    strcmp(oe->name, "status-right") == 0 ||
	    strcmp(oe->name, "status") == 0 ||
	    strcmp(oe->name, "set-titles-string") == 0 ||
	    strcmp(oe->name, "window-status-format") == 0) {
		for (i = 0; i < ARRAY_LENGTH(&clients); i++) {
			c = ARRAY_ITEM(&clients, i);
			if (c != NULL && c->session != NULL)
				server_redraw_client(c);
		}
@


1.47
log
@Simplify the way jobs work and drop the persist type, so all jobs are
fire-and-forget.

Status jobs now managed with two trees of output (new and old), rather
than storing the output in the jobs themselves. When the status line is
processed any jobs which don't appear in the new tree are started and
the output from the old tree displayed. When a job finishes it updates
the new tree with its output and that is used for any subsequent
redraws. When the status interval expires, the new tree is moved to the
old so that all jobs are run again.

This fixes the "#(echo %H:%M:%S)" problem which would lead to thousands
of identical persistent jobs and high memory use (this can still be
achieved by adding "sleep 30" but that is much less likely to happen by
accident).
@
text
@d1 1
a1 1
/* $OpenBSD: cmd-set-option.c,v 1.46 2011/01/04 02:03:41 nicm Exp $ */
d169 1
a169 5
	/*
	 * Special-case: kill all persistent jobs if status-left, status-right
	 * or set-titles-string have changed. Persistent jobs are only used by
	 * the status line at the moment so this works XXX.
	 */
@


1.46
log
@Now that parsing is common, merge some of the small, related commands
together to use the same code.

Also add some arguments (such as -n and -p) to some commands to match
existing commands.
@
text
@d1 1
a1 1
/* $OpenBSD: cmd-set-option.c,v 1.45 2011/01/04 01:58:12 nicm Exp $ */
a89 2
	struct jobs				*jobs;
	struct job				*job, *nextjob;
a91 1
	int					 try_again;
d181 2
a182 18
			if (c == NULL || c->session == NULL)
				continue;

			jobs = &c->status_jobs;
			do {
				try_again = 0;
				job = RB_ROOT(jobs);
				while (job != NULL) {
					nextjob = RB_NEXT(jobs, jobs, job);
					if (job->flags & JOB_PERSIST) {
						job_remove(jobs, job);
						try_again = 1;
						break;
					}
					job = nextjob;
				}
			} while (try_again);
			server_redraw_client(c);
@


1.45
log
@argc will be 1 not 2 with no option value.
@
text
@d1 1
a1 1
/* $OpenBSD: cmd-set-option.c,v 1.44 2011/01/04 00:42:47 nicm Exp $ */
d71 10
d100 2
a101 1
	} else if (args_has(self->args, 'w')) {
@


1.44
log
@Clean up and simplify tmux command argument parsing.

Originally, tmux commands were parsed in the client process into a
struct with the command data which was then serialised and sent to the
server to be executed. The parsing was later moved into the server (an
argv was sent from the client), but the parse step and intermediate
struct was kept.

This change removes that struct and the separate parse step. Argument
parsing and printing is now common to all commands (in arguments.c) with
each command left with just an optional check function (to validate the
arguments at parse time), the exec function and a function to set up any
key bindings (renamed from the old init function).

This is overall more simple and consistent.

There should be no changes to any commands behaviour or syntax although
as this touches every command please watch for any unexpected changes.
@
text
@d1 1
a1 1
/* $OpenBSD: cmd-set-option.c,v 1.43 2011/01/01 16:51:21 nicm Exp $ */
d118 1
a118 1
	if (args->argc < 1)
@


1.43
log
@Move the user-visible parts of all options (names, types, limit, default
values) together into one set of tables in options-table.c. Also clean
up and simplify cmd-set-options.c and move a common print function into
option-table.c.
@
text
@d1 1
a1 1
/* $OpenBSD: cmd-set-option.c,v 1.42 2010/12/30 23:16:18 nicm Exp $ */
d33 2
a34 1
	    const struct options_table_entry *, struct options *);
d36 2
a37 1
	    const struct options_table_entry *, struct options *);
d40 2
a41 1
	    const struct options_table_entry *, struct options *);
d43 2
a44 1
	    const struct options_table_entry *, struct options *);
d46 2
a47 1
	    const struct options_table_entry *, struct options *);
d49 2
a50 1
	    const struct options_table_entry *, struct options *);
d52 2
a53 1
	    const struct options_table_entry *, struct options *);
d55 2
a56 1
	    const struct options_table_entry *, struct options *);
d58 2
a59 1
	    const struct options_table_entry *, struct options *);
d63 1
d65 1
a65 1
	CMD_ARG12, "agsuw",
d67 2
a68 4
	cmd_target_parse,
	cmd_set_option_exec,
	cmd_target_free,
	cmd_target_print
d74 1
a74 1
	struct cmd_target_data			*data = self->data;
d82 1
d87 1
a87 1
	if (cmd_check_flag(data->chflags, 's')) {
d90 1
a90 1
	} else if (cmd_check_flag(data->chflags, 'w')) {
d92 1
a92 1
		if (cmd_check_flag(data->chflags, 'g'))
d95 1
a95 1
			wl = cmd_find_window(ctx, data->target, NULL);
d102 1
a102 1
		if (cmd_check_flag(data->chflags, 'g'))
d105 1
a105 1
			s = cmd_find_session(ctx, data->target);
d112 11
d126 1
a126 1
		if (strncmp(oe_loop->name, data->arg, strlen(data->arg)) != 0)
d128 1
d130 1
a130 1
			ctx->error(ctx, "ambiguous option: %s", data->arg);
d136 1
a136 1
		if (strcmp(oe->name, data->arg) == 0)
d140 1
a140 1
		ctx->error(ctx, "unknown option: %s", data->arg);
d145 2
a146 2
	if (cmd_check_flag(data->chflags, 'u')) {
		if (cmd_set_option_unset(self, ctx, oe, oo) != 0)
d149 1
a149 1
		if (cmd_set_option_set(self, ctx, oe, oo) != 0)
d200 1
a200 1
    const struct options_table_entry *oe, struct options *oo)
d202 1
a202 1
	struct cmd_target_data	*data = self->data;
d204 1
a204 1
	if (cmd_check_flag(data->chflags, 'g')) {
d208 1
a208 1
	if (data->arg2 != NULL) {
d221 1
a221 1
    const struct options_table_entry *oe, struct options *oo)
a222 1
	struct cmd_target_data	*data = self->data;
d226 2
a227 2
	if (oe->type != OPTIONS_TABLE_FLAG && data->arg2 == NULL) {
		ctx->error(ctx, "empty data->arg2");
d234 1
a234 1
		o = cmd_set_option_string(self, ctx, oe, oo);
d237 1
a237 1
		o = cmd_set_option_number(self, ctx, oe, oo);
d240 1
a240 1
		o = cmd_set_option_keys(self, ctx, oe, oo);
d243 1
a243 1
		o = cmd_set_option_colour(self, ctx, oe, oo);
d246 1
a246 1
		o = cmd_set_option_attributes(self, ctx, oe, oo);
d249 1
a249 1
		o = cmd_set_option_flag(self, ctx, oe, oo);
d252 1
a252 1
		o = cmd_set_option_choice(self, ctx, oe, oo);
d266 1
a266 1
    const struct options_table_entry *oe, struct options *oo)
d268 1
a268 1
	struct cmd_target_data	*data = self->data;
d272 1
a272 1
	if (cmd_check_flag(data->chflags, 'a')) {
d274 1
a274 1
		xasprintf(&newval, "%s%s", oldval, data->arg2);
d276 1
a276 1
		newval = data->arg2;
d280 1
a280 2
	if (newval != data->arg2)
		xfree(newval);
d286 2
a287 2
cmd_set_option_number(struct cmd *self, struct cmd_ctx *ctx,
    const struct options_table_entry *oe, struct options *oo)
d289 2
a290 3
	struct cmd_target_data	*data = self->data;
	long long		 ll;
	const char     		*errstr;
d292 1
a292 1
	ll = strtonum(data->arg2, oe->minimum, oe->maximum, &errstr);
d294 1
a294 1
		ctx->error(ctx, "value is %s: %s", errstr, data->arg2);
d303 2
a304 2
cmd_set_option_keys(struct cmd *self, struct cmd_ctx *ctx,
    const struct options_table_entry *oe, struct options *oo)
d306 3
a308 4
	struct cmd_target_data	*data = self->data;
	struct keylist		*keylist;
	char			*copy, *ptr, *s;
	int		 	 key;
d313 1
a313 1
	ptr = copy = xstrdup(data->arg2);
d330 2
a331 2
cmd_set_option_colour(struct cmd *self, struct cmd_ctx *ctx,
    const struct options_table_entry *oe, struct options *oo)
d333 1
a333 2
	struct cmd_target_data	*data = self->data;
	int			 colour;
d335 2
a336 2
	if ((colour = colour_fromstring(data->arg2)) == -1) {
		ctx->error(ctx, "bad colour: %s", data->arg2);
d345 2
a346 2
cmd_set_option_attributes(struct cmd *self, struct cmd_ctx *ctx,
    const struct options_table_entry *oe, struct options *oo)
d348 1
a348 2
	struct cmd_target_data	*data = self->data;
	int			 attr;
d350 2
a351 2
	if ((attr = attributes_fromstring(data->arg2)) == -1) {
		ctx->error(ctx, "bad attributes: %s", data->arg2);
d360 2
a361 2
cmd_set_option_flag(struct cmd *self, struct cmd_ctx *ctx,
    const struct options_table_entry *oe, struct options *oo)
d363 1
a363 2
	struct cmd_target_data	*data = self->data;
	int			 flag;
d365 1
a365 1
	if (data->arg2 == NULL || *data->arg2 == '\0')
d368 3
a370 3
		if ((data->arg2[0] == '1' && data->arg2[1] == '\0') ||
		    strcasecmp(data->arg2, "on") == 0 ||
		    strcasecmp(data->arg2, "yes") == 0)
d372 3
a374 3
		else if ((data->arg2[0] == '0' && data->arg2[1] == '\0') ||
		    strcasecmp(data->arg2, "off") == 0 ||
		    strcasecmp(data->arg2, "no") == 0)
d377 1
a377 1
			ctx->error(ctx, "bad value: %s", data->arg2);
d387 2
a388 2
cmd_set_option_choice(struct cmd *self, struct cmd_ctx *ctx,
    const struct options_table_entry *oe, struct options *oo)
d390 2
a391 3
	struct cmd_target_data	*data = self->data;
	const char     	       **choicep;
	int		 	 n, choice = -1;
d396 1
a396 1
		if (strncmp(*choicep, data->arg2, strlen(data->arg2)) != 0)
d400 1
a400 1
			ctx->error(ctx, "ambiguous value: %s", data->arg2);
d406 1
a406 1
		ctx->error(ctx, "unknown value: %s", data->arg2);
@


1.42
log
@Change from a per-session stack of buffers to one global stack which is
much more convenient and also simplifies lot of code. This renders
copy-buffer useless and makes buffer-limit now a server option.

By Tiago Cunha.
@
text
@d1 1
a1 1
/* $OpenBSD: cmd-set-option.c,v 1.41 2010/12/19 18:35:08 nicm Exp $ */
d32 19
a50 16
const char *cmd_set_option_print(
	    const struct set_option_entry *, struct options_entry *);
void	cmd_set_option_string(struct cmd_ctx *,
	    struct options *, const struct set_option_entry *, char *, int);
void	cmd_set_option_number(struct cmd_ctx *,
	    struct options *, const struct set_option_entry *, char *);
void	cmd_set_option_keys(struct cmd_ctx *,
	    struct options *, const struct set_option_entry *, char *);
void	cmd_set_option_colour(struct cmd_ctx *,
	    struct options *, const struct set_option_entry *, char *);
void	cmd_set_option_attributes(struct cmd_ctx *,
	    struct options *, const struct set_option_entry *, char *);
void	cmd_set_option_flag(struct cmd_ctx *,
	    struct options *, const struct set_option_entry *, char *);
void	cmd_set_option_choice(struct cmd_ctx *,
	    struct options *, const struct set_option_entry *, char *);
a62 123
const char *set_option_mode_keys_list[] = {
	"emacs", "vi", NULL
};
const char *set_option_clock_mode_style_list[] = {
	"12", "24", NULL
};
const char *set_option_status_keys_list[] = {
	"emacs", "vi", NULL
};
const char *set_option_status_justify_list[] = {
	"left", "centre", "right", NULL
};
const char *set_option_bell_action_list[] = {
	"none", "any", "current", NULL
};

const struct set_option_entry set_option_table[] = {
	{ "buffer-limit", SET_OPTION_NUMBER, 1, INT_MAX, NULL },
	{ "escape-time", SET_OPTION_NUMBER, 0, INT_MAX, NULL },
	{ "exit-unattached", SET_OPTION_FLAG, 0, 0, NULL },
	{ "quiet", SET_OPTION_FLAG, 0, 0, NULL },
	{ NULL, 0, 0, 0, NULL }
};

const struct set_option_entry set_session_option_table[] = {
	{ "base-index", SET_OPTION_NUMBER, 0, INT_MAX, NULL },
	{ "bell-action", SET_OPTION_CHOICE, 0, 0, set_option_bell_action_list },
	{ "default-command", SET_OPTION_STRING, 0, 0, NULL },
	{ "default-path", SET_OPTION_STRING, 0, 0, NULL },
	{ "default-shell", SET_OPTION_STRING, 0, 0, NULL },
	{ "default-terminal", SET_OPTION_STRING, 0, 0, NULL },
	{ "destroy-unattached", SET_OPTION_FLAG, 0, 0, NULL },
	{ "detach-on-destroy", SET_OPTION_FLAG, 0, 0, NULL },
	{ "display-panes-active-colour", SET_OPTION_COLOUR, 0, 0, NULL },
	{ "display-panes-colour", SET_OPTION_COLOUR, 0, 0, NULL },
	{ "display-panes-time", SET_OPTION_NUMBER, 1, INT_MAX, NULL },
	{ "display-time", SET_OPTION_NUMBER, 1, INT_MAX, NULL },
	{ "history-limit", SET_OPTION_NUMBER, 0, INT_MAX, NULL },
	{ "lock-after-time", SET_OPTION_NUMBER, 0, INT_MAX, NULL },
	{ "lock-command", SET_OPTION_STRING, 0, 0, NULL },
	{ "lock-server", SET_OPTION_FLAG, 0, 0, NULL },
	{ "message-attr", SET_OPTION_ATTRIBUTES, 0, 0, NULL },
	{ "message-bg", SET_OPTION_COLOUR, 0, 0, NULL },
	{ "message-fg", SET_OPTION_COLOUR, 0, 0, NULL },
	{ "message-limit", SET_OPTION_NUMBER, 0, INT_MAX, NULL },
	{ "mouse-select-pane", SET_OPTION_FLAG, 0, 0, NULL },
	{ "pane-active-border-bg", SET_OPTION_COLOUR, 0, 0, NULL },
	{ "pane-active-border-fg", SET_OPTION_COLOUR, 0, 0, NULL },
	{ "pane-border-bg", SET_OPTION_COLOUR, 0, 0, NULL },
	{ "pane-border-fg", SET_OPTION_COLOUR, 0, 0, NULL },
	{ "prefix", SET_OPTION_KEYS, 0, 0, NULL },
	{ "repeat-time", SET_OPTION_NUMBER, 0, SHRT_MAX, NULL },
	{ "set-remain-on-exit", SET_OPTION_FLAG, 0, 0, NULL },
	{ "set-titles", SET_OPTION_FLAG, 0, 0, NULL },
	{ "set-titles-string", SET_OPTION_STRING, 0, 0, NULL },
	{ "status", SET_OPTION_FLAG, 0, 0, NULL },
	{ "status-attr", SET_OPTION_ATTRIBUTES, 0, 0, NULL },
	{ "status-bg", SET_OPTION_COLOUR, 0, 0, NULL },
	{ "status-fg", SET_OPTION_COLOUR, 0, 0, NULL },
	{ "status-interval", SET_OPTION_NUMBER, 0, INT_MAX, NULL },
	{ "status-justify",
	  SET_OPTION_CHOICE, 0, 0, set_option_status_justify_list },
	{ "status-keys", SET_OPTION_CHOICE, 0, 0, set_option_status_keys_list },
	{ "status-left", SET_OPTION_STRING, 0, 0, NULL },
	{ "status-left-attr", SET_OPTION_ATTRIBUTES, 0, 0, NULL },
	{ "status-left-bg", SET_OPTION_COLOUR, 0, 0, NULL },
	{ "status-left-fg", SET_OPTION_COLOUR, 0, 0, NULL },
	{ "status-left-length", SET_OPTION_NUMBER, 0, SHRT_MAX, NULL },
	{ "status-right", SET_OPTION_STRING, 0, 0, NULL },
	{ "status-right-attr", SET_OPTION_ATTRIBUTES, 0, 0, NULL },
	{ "status-right-bg", SET_OPTION_COLOUR, 0, 0, NULL },
	{ "status-right-fg", SET_OPTION_COLOUR, 0, 0, NULL },
	{ "status-right-length", SET_OPTION_NUMBER, 0, SHRT_MAX, NULL },
	{ "status-utf8", SET_OPTION_FLAG, 0, 0, NULL },
	{ "terminal-overrides", SET_OPTION_STRING, 0, 0, NULL },
	{ "update-environment", SET_OPTION_STRING, 0, 0, NULL },
	{ "visual-activity", SET_OPTION_FLAG, 0, 0, NULL },
	{ "visual-bell", SET_OPTION_FLAG, 0, 0, NULL },
	{ "visual-content", SET_OPTION_FLAG, 0, 0, NULL },
	{ "visual-silence", SET_OPTION_FLAG, 0, 0, NULL },
	{ NULL, 0, 0, 0, NULL }
};

const struct set_option_entry set_window_option_table[] = {
	{ "aggressive-resize", SET_OPTION_FLAG, 0, 0, NULL },
	{ "alternate-screen", SET_OPTION_FLAG, 0, 0, NULL },
	{ "automatic-rename", SET_OPTION_FLAG, 0, 0, NULL },
	{ "clock-mode-colour", SET_OPTION_COLOUR, 0, 0, NULL },
	{ "clock-mode-style",
	  SET_OPTION_CHOICE, 0, 0, set_option_clock_mode_style_list },
	{ "force-height", SET_OPTION_NUMBER, 0, INT_MAX, NULL },
	{ "force-width", SET_OPTION_NUMBER, 0, INT_MAX, NULL },
	{ "main-pane-height", SET_OPTION_NUMBER, 1, INT_MAX, NULL },
	{ "main-pane-width", SET_OPTION_NUMBER, 1, INT_MAX, NULL },
	{ "mode-attr", SET_OPTION_ATTRIBUTES, 0, 0, NULL },
	{ "mode-bg", SET_OPTION_COLOUR, 0, 0, NULL },
	{ "mode-fg", SET_OPTION_COLOUR, 0, 0, NULL },
	{ "mode-keys", SET_OPTION_CHOICE, 0, 0, set_option_mode_keys_list },
	{ "mode-mouse", SET_OPTION_FLAG, 0, 0, NULL },
	{ "monitor-activity", SET_OPTION_FLAG, 0, 0, NULL },
	{ "monitor-content", SET_OPTION_STRING, 0, 0, NULL },
	{ "monitor-silence",SET_OPTION_NUMBER, 0, INT_MAX, NULL},
	{ "other-pane-height", SET_OPTION_NUMBER, 0, INT_MAX, NULL },
	{ "other-pane-width", SET_OPTION_NUMBER, 0, INT_MAX, NULL },
	{ "remain-on-exit", SET_OPTION_FLAG, 0, 0, NULL },
	{ "synchronize-panes", SET_OPTION_FLAG, 0, 0, NULL },
	{ "utf8", SET_OPTION_FLAG, 0, 0, NULL },
	{ "window-status-alert-attr", SET_OPTION_ATTRIBUTES, 0, 0, NULL },
	{ "window-status-alert-bg", SET_OPTION_COLOUR, 0, 0, NULL },
	{ "window-status-alert-fg", SET_OPTION_COLOUR, 0, 0, NULL },
	{ "window-status-attr", SET_OPTION_ATTRIBUTES, 0, 0, NULL },
	{ "window-status-bg", SET_OPTION_COLOUR, 0, 0, NULL },
	{ "window-status-current-attr", SET_OPTION_ATTRIBUTES, 0, 0, NULL },
	{ "window-status-current-bg", SET_OPTION_COLOUR, 0, 0, NULL },
	{ "window-status-current-fg", SET_OPTION_COLOUR, 0, 0, NULL },
	{ "window-status-current-format", SET_OPTION_STRING, 0, 0, NULL },
	{ "window-status-fg", SET_OPTION_COLOUR, 0, 0, NULL },
	{ "window-status-format", SET_OPTION_STRING, 0, 0, NULL },
	{ "word-separators", SET_OPTION_STRING, 0, 0, NULL },
	{ "xterm-keys", SET_OPTION_FLAG, 0, 0, NULL },
	{ NULL, 0, 0, 0, NULL }
};

d66 10
a75 11
	struct cmd_target_data		*data = self->data;
	const struct set_option_entry	*table;
	struct session			*s;
	struct winlink			*wl;
	struct client			*c;
	struct options			*oo;
	const struct set_option_entry   *entry, *opt;
	struct jobs			*jobs;
	struct job			*job, *nextjob;
	u_int				 i;
	int				 try_again;
d77 1
d80 1
a80 1
		table = set_option_table;
d82 1
a82 1
		table = set_window_option_table;
d92 1
a92 1
		table = set_session_option_table;
d103 4
a106 8
	if (*data->arg == '\0') {
		ctx->error(ctx, "invalid option");
		return (-1);
	}

	entry = NULL;
	for (opt = table; opt->name != NULL; opt++) {
		if (strncmp(opt->name, data->arg, strlen(data->arg)) != 0)
d108 1
a108 1
		if (entry != NULL) {
d112 1
a112 1
		entry = opt;
d115 1
a115 1
		if (strcmp(entry->name, data->arg) == 0)
d118 1
a118 1
	if (entry == NULL) {
d123 1
d125 1
a125 3
		if (cmd_check_flag(data->chflags, 'g')) {
			ctx->error(ctx,
			    "can't unset global option: %s", entry->name);
d127 2
a128 4
		}
		if (data->arg2 != NULL) {
			ctx->error(ctx,
			    "value passed to unset option: %s", entry->name);
a129 29
		}

		options_remove(oo, entry->name);
		ctx->info(ctx, "unset option: %s", entry->name);
	} else {
		switch (entry->type) {
		case SET_OPTION_STRING:
			cmd_set_option_string(ctx, oo, entry,
			    data->arg2, cmd_check_flag(data->chflags, 'a'));
			break;
		case SET_OPTION_NUMBER:
			cmd_set_option_number(ctx, oo, entry, data->arg2);
			break;
		case SET_OPTION_KEYS:
			cmd_set_option_keys(ctx, oo, entry, data->arg2);
			break;
		case SET_OPTION_COLOUR:
			cmd_set_option_colour(ctx, oo, entry, data->arg2);
			break;
		case SET_OPTION_ATTRIBUTES:
			cmd_set_option_attributes(ctx, oo, entry, data->arg2);
			break;
		case SET_OPTION_FLAG:
			cmd_set_option_flag(ctx, oo, entry, data->arg2);
			break;
		case SET_OPTION_CHOICE:
			cmd_set_option_choice(ctx, oo, entry, data->arg2);
			break;
		}
d132 1
d145 5
a149 5
	if (strcmp(entry->name, "status-left") == 0 ||
	    strcmp(entry->name, "status-right") == 0 ||
	    strcmp(entry->name, "status") == 0 ||
	    strcmp(entry->name, "set-titles-string") == 0 ||
	    strcmp(entry->name, "window-status-format") == 0) {
d176 4
a179 3
const char *
cmd_set_option_print(
    const struct set_option_entry *entry, struct options_entry *o)
d181 9
a189 40
	static char	out[BUFSIZ];
	const char     *s;
	struct keylist *keylist;
	u_int		i;

	*out = '\0';
	switch (entry->type) {
		case SET_OPTION_STRING:
			xsnprintf(out, sizeof out, "\"%s\"", o->str);
			break;
		case SET_OPTION_NUMBER:
			xsnprintf(out, sizeof out, "%lld", o->num);
			break;
		case SET_OPTION_KEYS:
			keylist = o->data;
			for (i = 0; i < ARRAY_LENGTH(keylist); i++) {
				strlcat(out, key_string_lookup_key(
				    ARRAY_ITEM(keylist, i)), sizeof out);
				if (i != ARRAY_LENGTH(keylist) - 1)
					strlcat(out, ",", sizeof out);
			}
			break;
		case SET_OPTION_COLOUR:
			s = colour_tostring(o->num);
			xsnprintf(out, sizeof out, "%s", s);
			break;
		case SET_OPTION_ATTRIBUTES:
			s = attributes_tostring(o->num);
			xsnprintf(out, sizeof out, "%s", s);
			break;
		case SET_OPTION_FLAG:
			if (o->num)
				strlcpy(out, "on", sizeof out);
			else
				strlcpy(out, "off", sizeof out);
			break;
		case SET_OPTION_CHOICE:
			s = entry->choices[o->num];
			xsnprintf(out, sizeof out, "%s", s);
			break;
d191 4
a194 1
	return (out);
d197 4
a200 3
void
cmd_set_option_string(struct cmd_ctx *ctx, struct options *oo,
    const struct set_option_entry *entry, char *value, int append)
d202 1
d204 1
a204 1
	char			*oldvalue, *newvalue;
d206 3
a208 3
	if (value == NULL) {
		ctx->error(ctx, "empty value");
		return;
d211 44
a254 3
	if (append) {
		oldvalue = options_get_string(oo, entry->name);
		xasprintf(&newvalue, "%s%s", oldvalue, value);
d256 1
a256 1
		newvalue = value;
d258 1
a258 3
	o = options_set_string(oo, entry->name, "%s", newvalue);
	ctx->info(ctx,
	    "set option: %s -> %s", o->name, cmd_set_option_print(entry, o));
d260 3
a262 2
	if (newvalue != value)
		xfree(newvalue);
d265 4
a268 3
void
cmd_set_option_number(struct cmd_ctx *ctx, struct options *oo,
    const struct set_option_entry *entry, char *value)
d270 2
a271 2
	struct options_entry	*o;
	long long		 number;
d274 1
a274 6
	if (value == NULL) {
		ctx->error(ctx, "empty value");
		return;
	}

	number = strtonum(value, entry->minimum, entry->maximum, &errstr);
d276 2
a277 2
		ctx->error(ctx, "value is %s: %s", errstr, value);
		return;
d280 1
a280 3
	o = options_set_number(oo, entry->name, number);
	ctx->info(ctx,
	    "set option: %s -> %s", o->name, cmd_set_option_print(entry, o));
d283 4
a286 3
void
cmd_set_option_keys(struct cmd_ctx *ctx, struct options *oo,
    const struct set_option_entry *entry, char *value)
d288 1
a288 1
	struct options_entry	*o;
d290 1
a290 1
	char			*copyvalue, *ptr, *str;
a292 5
	if (value == NULL) {
		ctx->error(ctx, "empty value");
		return;
	}

d296 5
a300 3
	ptr = copyvalue = xstrdup(value);
	while ((str = strsep(&ptr, ",")) != NULL) {
		if ((key = key_string_lookup_string(str)) == KEYC_NONE) {
d302 1
a302 3
			ctx->error(ctx, "unknown key: %s", str);
			xfree(copyvalue);
			return;
d306 1
a306 1
	xfree(copyvalue);
d308 1
a308 3
	o = options_set_data(oo, entry->name, keylist, xfree);
	ctx->info(ctx,
	    "set option: %s -> %s", o->name, cmd_set_option_print(entry, o));
d311 4
a314 3
void
cmd_set_option_colour(struct cmd_ctx *ctx, struct options *oo,
    const struct set_option_entry *entry, char *value)
d316 1
a316 1
	struct options_entry	*o;
d319 3
a321 3
	if (value == NULL) {
		ctx->error(ctx, "empty value");
		return;
d324 1
a324 8
	if ((colour = colour_fromstring(value)) == -1) {
		ctx->error(ctx, "bad colour: %s", value);
		return;
	}

	o = options_set_number(oo, entry->name, colour);
	ctx->info(ctx,
	    "set option: %s -> %s", o->name, cmd_set_option_print(entry, o));
d327 4
a330 3
void
cmd_set_option_attributes(struct cmd_ctx *ctx, struct options *oo,
    const struct set_option_entry *entry, char *value)
d332 1
a332 1
	struct options_entry	*o;
d335 3
a337 8
	if (value == NULL) {
		ctx->error(ctx, "empty value");
		return;
	}

	if ((attr = attributes_fromstring(value)) == -1) {
		ctx->error(ctx, "bad attributes: %s", value);
		return;
d340 1
a340 3
	o = options_set_number(oo, entry->name, attr);
	ctx->info(ctx,
	    "set option: %s -> %s", o->name, cmd_set_option_print(entry, o));
d343 4
a346 3
void
cmd_set_option_flag(struct cmd_ctx *ctx, struct options *oo,
    const struct set_option_entry *entry, char *value)
d348 1
a348 1
	struct options_entry	*o;
d351 2
a352 2
	if (value == NULL || *value == '\0')
		flag = !options_get_number(oo, entry->name);
d354 3
a356 3
		if ((value[0] == '1' && value[1] == '\0') ||
		    strcasecmp(value, "on") == 0 ||
		    strcasecmp(value, "yes") == 0)
d358 3
a360 3
		else if ((value[0] == '0' && value[1] == '\0') ||
		    strcasecmp(value, "off") == 0 ||
		    strcasecmp(value, "no") == 0)
d363 2
a364 2
			ctx->error(ctx, "bad value: %s", value);
			return;
d368 1
a368 3
	o = options_set_number(oo, entry->name, flag);
	ctx->info(ctx,
	    "set option: %s -> %s", o->name, cmd_set_option_print(entry, o));
d371 4
a374 3
void
cmd_set_option_choice(struct cmd_ctx *ctx, struct options *oo,
    const struct set_option_entry *entry, char *value)
d376 1
a376 1
	struct options_entry	*o;
a379 5
	if (value == NULL) {
		ctx->error(ctx, "empty value");
		return;
	}

d381 1
a381 1
	for (choicep = entry->choices; *choicep != NULL; choicep++) {
d383 1
a383 1
		if (strncmp(*choicep, value, strlen(value)) != 0)
d387 2
a388 2
			ctx->error(ctx, "ambiguous option value: %s", value);
			return;
d393 2
a394 2
		ctx->error(ctx, "unknown option value: %s", value);
		return;
d397 1
a397 3
	o = options_set_number(oo, entry->name, choice);
	ctx->info(ctx,
	    "set option: %s -> %s", o->name, cmd_set_option_print(entry, o));
@


1.41
log
@Add other-pane-height and other-pane-width options, allowing the width
or height of the smaller panes in the main-horizontal and main-vertical
layouts to be set. Mostly from David Goodlad.
@
text
@d1 1
a1 1
/* $OpenBSD: cmd-set-option.c,v 1.40 2010/12/06 22:51:02 nicm Exp $ */
d77 1
a86 1
	{ "buffer-limit", SET_OPTION_NUMBER, 1, INT_MAX, NULL },
d93 1
a94 1
	{ "display-panes-active-colour", SET_OPTION_COLOUR, 0, 0, NULL },
@


1.40
log
@Add an option to alert (monitor) for silence (lack of activity) in a
window. From Thomas Adam.
@
text
@d1 1
a1 1
/* $OpenBSD: cmd-set-option.c,v 1.39 2010/09/26 20:43:30 nicm Exp $ */
d162 2
@


1.39
log
@Two new options:

- server option "exit-unattached" makes the server exit when no clients
  are attached, even if sessions are present;

- session option "destroy-unattached" destroys a session once no clients
  are attached to it.

These are useful for preventing tmux remaining in the background where
it is undesirable and when using tmux as a login shell to keep a limit
on new sessions.
@
text
@d1 1
a1 1
/* $OpenBSD: cmd-set-option.c,v 1.38 2010/09/01 21:06:51 nicm Exp $ */
d139 1
d161 1
@


1.38
log
@Reset running jobs when the status line is enabled or disabled as well,
some people have it bound to a key.
@
text
@d1 1
a1 1
/* $OpenBSD: cmd-set-option.c,v 1.37 2010/06/27 00:22:22 nicm Exp $ */
d78 1
d91 1
@


1.37
log
@New option, detach-on-destroy, to set what happens to a client when the session
it is attached to is destroyed. If on (the default), it is detached; if off, it
is switched to the most recently active session.
@
text
@d1 1
a1 1
/* $OpenBSD: cmd-set-option.c,v 1.36 2010/05/14 19:03:09 nicm Exp $ */
d296 1
@


1.36
log
@Colour+attribute options for status line alerts, from Alex Alexander.
@
text
@d1 1
a1 1
/* $OpenBSD: cmd-set-option.c,v 1.35 2010/02/22 20:41:16 nicm Exp $ */
d90 1
@


1.35
log
@Option to set the characters considered word separators in copy mode, from
Micah Cowan.
@
text
@d1 1
a1 1
/* $OpenBSD: cmd-set-option.c,v 1.34 2010/02/08 00:14:38 nicm Exp $ */
d160 3
@


1.34
log
@Add an option to disable the smcup/rmcup alternate screen behaviour inside
tmux. From clemens fischer.
@
text
@d1 1
a1 1
/* $OpenBSD: cmd-set-option.c,v 1.33 2010/02/04 18:20:16 nicm Exp $ */
d168 1
@


1.33
log
@Option to display the active pane in a different colour with the display-panes
command. From Paul Hoffman, thanks.
@
text
@d1 1
a1 1
/* $OpenBSD: cmd-set-option.c,v 1.32 2010/01/03 12:51:05 nicm Exp $ */
d141 1
@


1.32
log
@Options to set the colour of the pane borders, with different colours for the
active pane.
@
text
@d1 1
a1 1
/* $OpenBSD: cmd-set-option.c,v 1.31 2009/12/14 10:43:41 nicm Exp $ */
d91 1
@


1.31
log
@New server option, escape-time, to set the timeout used to detect if escapes
are alone or part of a function key or meta sequence.
@
text
@d1 1
a1 1
/* $OpenBSD: cmd-set-option.c,v 1.30 2009/12/11 13:58:48 nicm Exp $ */
d102 4
@


1.30
log
@Use quiet variable, and add missing sentinel to options array.
@
text
@d1 1
a1 1
/* $OpenBSD: cmd-set-option.c,v 1.29 2009/12/10 09:16:52 nicm Exp $ */
d77 1
@


1.29
log
@Add "server options" which are server-wide and not bound to a session or
window. Set and displayed with "set -s" and "show -s".

Currently the only option is "quiet" (like command-line -q, allowing it to be
set from .tmux.conf), but others will come along.
@
text
@d1 1
a1 1
/* $OpenBSD: cmd-set-option.c,v 1.28 2009/12/03 22:50:10 nicm Exp $ */
d78 1
@


1.28
log
@Massive spaces->tabs and trailing whitespace cleanup, hopefully for the last
time now I've configured emacs to make them displayed in really annoying
colours...
@
text
@d1 1
a1 1
/* $OpenBSD: cmd-set-option.c,v 1.27 2009/12/03 17:44:02 nicm Exp $ */
d51 2
a52 2
	"[-aguw] [-t target-session|target-window] option [value]",
	CMD_ARG12, "aguw",
d76 4
d179 4
a182 1
	if (cmd_check_flag(data->chflags, 'w')) {
@


1.27
log
@Eliminate duplicate code and ease the passage for server-wide options by adding
a -w flag to set-option and show-options and making setw and showw aliases to
set -w and show -w.

Note: setw and showw are still there, but now aliases for set -w and show -w.
@
text
@d1 1
a1 1
/* $OpenBSD: cmd-set-option.c,v 1.26 2009/11/18 13:16:33 nicm Exp $ */
d37 1
a37 1
    	    struct options *, const struct set_option_entry *, char *);
d39 1
a39 1
    	    struct options *, const struct set_option_entry *, char *);
d41 1
a41 1
    	    struct options *, const struct set_option_entry *, char *);
d43 1
a43 1
    	    struct options *, const struct set_option_entry *, char *);
d45 1
a45 1
    	    struct options *, const struct set_option_entry *, char *);
d47 1
a47 1
    	    struct options *, const struct set_option_entry *, char *);
d106 1
a106 1
	{ "status-justify", 
d119 1
a119 1
	{ "status-utf8", SET_OPTION_FLAG, 0, 0, NULL },	
d123 1
a123 1
	{ "visual-bell", SET_OPTION_FLAG, 0, 0, NULL },	
d269 1
a269 1
	/* 
d285 1
a285 1
				try_again = 0;	
d369 1
a369 1
		
@


1.26
log
@Add a per-client log of status line messages displayed while that client
exists. A new message-limit session option sets the maximum number of entries
and a command, show-messages, shows the log (bound to ~ by default).

This (and prompt history) might be better as a single global log but until
there are global options it is easier for them to be per client.
@
text
@d1 1
a1 1
/* $OpenBSD: cmd-set-option.c,v 1.25 2009/11/13 19:53:29 nicm Exp $ */
d32 17
d51 2
a52 2
	"[-agu] " CMD_TARGET_SESSION_USAGE " option [value]",
	CMD_ARG12, "agu",
d60 6
d75 2
a76 1
const struct set_option_entry set_option_table[] = {
d128 32
d164 1
d166 1
d175 20
a194 6
	if (cmd_check_flag(data->chflags, 'g'))
		oo = &global_s_options;
	else {
		if ((s = cmd_find_session(ctx, data->target)) == NULL)
			return (-1);
		oo = &s->options;
d203 1
a203 1
	for (opt = set_option_table; opt->name != NULL; opt++) {
d238 1
a238 1
			set_option_string(ctx, oo, entry,
d242 1
a242 1
			set_option_number(ctx, oo, entry, data->arg2);
d245 1
a245 1
			set_option_keys(ctx, oo, entry, data->arg2);
d248 1
a248 1
			set_option_colour(ctx, oo, entry, data->arg2);
d251 1
a251 1
			set_option_attributes(ctx, oo, entry, data->arg2);
d254 1
a254 1
			set_option_flag(ctx, oo, entry, data->arg2);
d257 1
a257 1
			set_option_choice(ctx, oo, entry, data->arg2);
d263 5
d276 2
a277 1
	    strcmp(entry->name, "set-titles-string") == 0) {
d302 240
@


1.25
log
@Get rid of the ugly CMD_CHFLAG macro and use a const string (eg "dDU") in the
command entry structs and a couple of functions to check/set the flags.
@
text
@d1 1
a1 1
/* $OpenBSD: cmd-set-option.c,v 1.24 2009/11/01 23:20:37 nicm Exp $ */
d70 1
@


1.24
log
@Add a flag for jobs that shouldn't be freed after they've died and use it for
status jobs, then only kill those jobs when status-left, status-right or
set-titles-string is changed.

Fixes problems with changing options from inside #().
@
text
@d1 1
a1 1
/* $OpenBSD: cmd-set-option.c,v 1.23 2009/10/10 15:03:01 nicm Exp $ */
d35 1
a35 1
	CMD_ARG12, CMD_CHFLAG('a')|CMD_CHFLAG('g')|CMD_CHFLAG('u'),
d116 1
a116 1
	if (data->chflags & CMD_CHFLAG('g'))
d148 2
a149 2
	if (data->chflags & CMD_CHFLAG('u')) {
		if (data->chflags & CMD_CHFLAG('g')) {
d166 1
a166 1
			    data->arg2, data->chflags & CMD_CHFLAG('a'));
@


1.23
log
@Rather than running status-left, status-right and window title #() with popen
immediately every redraw, queue them up and run them in the background,
starting each once every status-interval. The actual status line uses the
output from the last run.

This brings several advantages:

- tmux itself may be called from inside #() without causing the server to hang;
- likewise, sleep or similar doesn't cause the server to block;
- commands aren't run excessively often when redrawing;
- commands shared by status-left and status-right, or used multiple times, will
  only be run once.

run-shell and if-shell still use system()/popen() but will be changed over to
use this too later.
@
text
@d1 1
a1 1
/* $OpenBSD: cmd-set-option.c,v 1.22 2009/10/10 14:51:16 nicm Exp $ */
d111 2
d114 1
d190 28
a217 5
	for (i = 0; i < ARRAY_LENGTH(&clients); i++) {
		c = ARRAY_ITEM(&clients, i);
		if (c != NULL && c->session != NULL) {
			job_tree_free(&c->status_jobs);
			job_tree_init(&c->status_jobs);
@


1.22
log
@New option, mouse-select-pane. If on, the mouse may be used to select the
current pane.

Suggested by sthen@@ and also by someone else ages ago who I have forgotten.
@
text
@d1 1
a1 1
/* $OpenBSD: cmd-set-option.c,v 1.21 2009/10/10 09:46:11 nicm Exp $ */
d189 3
a191 1
		if (c != NULL && c->session != NULL)
d193 1
@


1.21
log
@Support for individual session idle time locking. May be enabled by turning off
the lock-server option (it is on by default). When this is off, each session
locks when it has been idle for the lock-after-time setting. When on, the
entire server locks when ALL sessions have been idle for their individual
lock-after-time settings.

This replaces one global-only option (lock-after-time) with another
(lock-server), but the default behaviour is usually preferable so there don't
seem to be many alternatives.

Diff/idea largely from Thomas Adam, tweaked by me.
@
text
@d1 1
a1 1
/* $OpenBSD: cmd-set-option.c,v 1.20 2009/09/23 06:18:47 nicm Exp $ */
d70 1
@


1.20
log
@Remove the internal tmux locking and instead detach each client and run the
command specified by a new option "lock-command" (by default "lock -np") in
each client.

This means each terminal has to be unlocked individually but simplifies the
code and allows the system password to be used to unlock.

Note that the set-password command is gone, so it will need to be removed from
configuration files, and the -U command line flag has been removed.

This is the third protocol version change so again it is best to stop the tmux
server before upgrading.
@
text
@d1 1
a1 1
/* $OpenBSD: cmd-set-option.c,v 1.19 2009/09/22 12:38:10 nicm Exp $ */
d66 1
@


1.19
log
@Permit multiple prefix keys to be defined, separated by commas, for example:

set -g prefix ^a,^b

Any key in the list acts as the prefix. The send-prefix command always sends
the first key in the list.
@
text
@d1 1
a1 1
/* $OpenBSD: cmd-set-option.c,v 1.18 2009/09/18 15:19:27 nicm Exp $ */
d65 1
@


1.18
log
@New option, set-titles-string, to allow the window title to be specified (as
for status-left/right) if set-titles is on. Also only update the title when the
status line is being redrawn.
@
text
@d1 1
a1 1
/* $OpenBSD: cmd-set-option.c,v 1.17 2009/09/01 13:09:49 nicm Exp $ */
d68 1
a68 1
	{ "prefix", SET_OPTION_KEY, 0, 0, NULL },
d165 2
a166 2
		case SET_OPTION_KEY:
			set_option_key(ctx, oo, entry, data->arg2);
@


1.17
log
@When using tmux as a login shell, there is currently no way to specify a shell
to be used as a login shell inside tmux, so add a default-shell session option.
This sets the shell invoked as a login shell when the default-command option is
empty.

The default option value is whichever of $SHELL, getpwuid(getuid())'s pw_shell
or /bin/sh is valid first.

Based on a diff from martynas@@, changed by me to be a session option rather
than a window option.
@
text
@d1 1
a1 1
/* $OpenBSD: cmd-set-option.c,v 1.16 2009/08/31 20:46:19 nicm Exp $ */
d72 1
@


1.16
log
@Add a new display-panes command, with two options (display-panes-colour and
display-panes-time), which displays a visual indication of the number of each
pane.
@
text
@d1 1
a1 1
/* $OpenBSD: cmd-set-option.c,v 1.15 2009/08/13 20:11:58 nicm Exp $ */
d58 1
@


1.15
log
@Add a base-index session option to specify the first index checked when looking
for an index for a new window.
@
text
@d1 1
a1 1
/* $OpenBSD: cmd-set-option.c,v 1.14 2009/08/11 12:53:37 nicm Exp $ */
d59 2
@


1.14
log
@Add flags for 1+2 and 2 arguments to the generic target code, use it for
cmd-set-environment/option/window-option and remove the generic options
parsing.
@
text
@d1 1
a1 1
/* $OpenBSD: cmd-set-option.c,v 1.13 2009/08/08 21:52:43 nicm Exp $ */
d53 1
@


1.13
log
@Infrastructure and commands to manage the environment for processes started
within tmux.

There is a global environment, copied from the external environment when the
server is started and each sesssion has an (initially empty) session
environment which overrides it.

New commands set-environment and show-environment manipulate or display the
environments.

A new session option, update-environment, is a space-separated list of
variables which are updated from the external environment into the session
environment every time a new session is created - the default is DISPLAY.
@
text
@d1 1
a1 1
/* $OpenBSD: cmd-set-option.c,v 1.12 2009/08/08 20:36:42 nicm Exp $ */
d34 2
a35 2
	"[-agu] " CMD_OPTION_SESSION_USAGE,
	0, CMD_CHFLAG('a')|CMD_CHFLAG('g')|CMD_CHFLAG('u'),
d37 1
a37 1
	cmd_option_parse,
d39 2
a40 2
	cmd_option_free,
	cmd_option_print
d98 1
a98 1
	struct cmd_option_data		*data = self->data;
d113 1
a113 1
	if (*data->option == '\0') {
d120 1
a120 1
		if (strncmp(opt->name, data->option, strlen(data->option)) != 0)
d123 1
a123 1
			ctx->error(ctx, "ambiguous option: %s", data->option);
d129 1
a129 1
		if (strcmp(entry->name, data->option) == 0)
d133 1
a133 1
		ctx->error(ctx, "unknown option: %s", data->option);
d143 1
a143 1
		if (data->value != NULL) {
d155 1
a155 1
			    data->value, data->chflags & CMD_CHFLAG('a'));
d158 1
a158 1
			set_option_number(ctx, oo, entry, data->value);
d161 1
a161 1
			set_option_key(ctx, oo, entry, data->value);
d164 1
a164 1
			set_option_colour(ctx, oo, entry, data->value);
d167 1
a167 1
			set_option_attributes(ctx, oo, entry, data->value);
d170 1
a170 1
			set_option_flag(ctx, oo, entry, data->value);
d173 1
a173 1
			set_option_choice(ctx, oo, entry, data->value);
@


1.12
log
@Options to set the colours and attributes for status-left/-right. From Thomas
Adam, thanks.
@
text
@d1 1
a1 1
/* $OpenBSD: cmd-set-option.c,v 1.11 2009/08/04 18:45:57 nicm Exp $ */
d88 1
@


1.11
log
@Add a -a flag to set-option and set-window-option to append to an existing
string value, useful for terminal-overrides.
@
text
@d1 1
a1 1
/* $OpenBSD: cmd-set-option.c,v 1.10 2009/08/03 14:10:54 nicm Exp $ */
d77 3
d82 3
@


1.10
log
@Add a terminal-overrides session option allowing individual terminfo(5) entries
to be overridden. The 88col/256col checks are now moved into the default
setting and out of the code.

Also remove a couple of old workarounds for xterm and rxvt which are no longer
necessary (tmux can emulate them if missing).
@
text
@d1 1
a1 1
/* $OpenBSD: cmd-set-option.c,v 1.9 2009/07/26 12:58:44 nicm Exp $ */
d34 2
a35 2
	CMD_OPTION_SESSION_USAGE,
	0, CMD_CHFLAG('g')|CMD_CHFLAG('u'),
d147 2
a148 1
			set_option_string(ctx, oo, entry, data->value);
@


1.9
log
@Make all messages sent between the client and server fixed size.

This is the first of two changes to make the protocol more resilient and less
sensitive to other changes in the code, particularly with commands. The client
now packs argv into a buffer and sends it to the server for parsing, rather
than doing it itself and sending the parsed command data.

As a side-effect this also removes a lot of now-unused command marshalling
code.

Mixing a server without this change and a client with or vice versa will cause
tmux to hang or crash, please ensure that tmux is entirely killed before
upgrading.
@
text
@d1 1
a1 1
/* $OpenBSD: cmd-set-option.c,v 1.8 2009/07/20 14:32:09 nicm Exp $ */
d80 2
a81 1
	{ "status-utf8", SET_OPTION_FLAG, 0, 0, NULL },
@


1.8
log
@Add a status-justify option to allow the window list in the status line to be
positioned at the left, centre, or right.
@
text
@d1 1
a1 1
/* $OpenBSD: cmd-set-option.c,v 1.7 2009/07/18 14:59:25 nicm Exp $ */
a38 2
	cmd_option_send,
	cmd_option_recv,
@


1.7
log
@Add three new session options: visual-activity, visual-bell, visual-content. If
these are enabled (and the monitor-activity, bell-actio and monitor-content
options are configurated appropriately), when activity, a bell, or content is
detected, a message is shown.

Also tidy up the bell/activity/content code in server.c slightly and fix a
couple of errors.
@
text
@d1 1
a1 1
/* $OpenBSD: cmd-set-option.c,v 1.6 2009/07/15 07:50:34 nicm Exp $ */
d48 3
d75 2
@


1.6
log
@Having to update NSETOPTION/NSETWINDOWOPTION when adding new options is a bit
annoying and it is only use for iterating, so use a sentinel to mark the end of
each array instead. Different fix for a problem pointed out by Kalle Olavi
Niemitalo.
@
text
@d1 1
a1 1
/* $OpenBSD: cmd-set-option.c,v 1.5 2009/07/13 23:11:35 nicm Exp $ */
d78 3
@


1.5
log
@Having fixed flags for single-character getopt options is a bit hard to
maintain and is only going to get worse as more are used. So instead, add a new
uint64_t member to cmd_entry which is a bitmask of upper and lowercase options
accepted by the command.

This means new single character options can be used without the need to add it
explicitly to the list.
@
text
@d1 1
a1 1
/* $OpenBSD: cmd-set-option.c,v 1.4 2009/07/10 05:50:54 nicm Exp $ */
d51 1
a51 1
const struct set_option_entry set_option_table[NSETOPTION] = {
d78 1
d88 1
a88 1
	const struct set_option_entry   *entry;
d105 2
a106 3
	for (i = 0; i < NSETOPTION; i++) {
		if (strncmp(set_option_table[i].name,
		    data->option, strlen(data->option)) != 0)
d112 1
a112 1
		entry = &set_option_table[i];
@


1.4
log
@Add a default-terminal option to set the starting value of $TERM in new
windows.

This is "screen" by default and must be either that or something closely
related. This does makes it easier to customise it if necessary.
@
text
@d1 1
a1 1
/* $OpenBSD: cmd-set-option.c,v 1.3 2009/07/07 19:49:19 nicm Exp $ */
d35 1
a35 1
	CMD_GFLAG|CMD_UFLAG,
d90 1
a90 1
	if (data->flags & CMD_GFLAG)
d123 2
a124 2
	if (data->flags & CMD_UFLAG) {
		if (data->flags & CMD_GFLAG) {
@


1.3
log
@Rename the global options variables to be shorter and to make session options
clear. No functional change, getting this out of the way to make later options
changes easier.
@
text
@d1 1
a1 1
/* $OpenBSD: cmd-set-option.c,v 1.2 2009/06/03 16:54:26 nicm Exp $ */
d56 1
@


1.2
log
@New session option, status-utf8, to control the interpretation of top-bit-set
characters in status-left and status-right (if on, they are treated as UTF-8;
otherwise passed through).
@
text
@d1 1
a1 1
/* $OpenBSD: cmd-set-option.c,v 1.1 2009/06/01 22:58:49 nicm Exp $ */
d90 1
a90 1
		oo = &global_options;
@


1.1
log
@Import tmux, a terminal multiplexor allowing (among other things) a single
terminal to be switched between several different windows and programs
displayed on one terminal be detached from one terminal and moved to another.

ok deraadt pirofti
@
text
@d1 1
a1 1
/* $OpenBSD$ */
d76 1
@

