head	1.106;
access;
symbols
	OPENBSD_6_0:1.99.0.2
	OPENBSD_6_0_BASE:1.99
	OPENBSD_5_9:1.98.0.2
	OPENBSD_5_9_BASE:1.98
	OPENBSD_5_8:1.85.0.4
	OPENBSD_5_8_BASE:1.85
	OPENBSD_5_7:1.78.0.2
	OPENBSD_5_7_BASE:1.78
	OPENBSD_5_6:1.76.0.4
	OPENBSD_5_6_BASE:1.76
	OPENBSD_5_5:1.75.0.4
	OPENBSD_5_5_BASE:1.75
	OPENBSD_5_4:1.70.0.2
	OPENBSD_5_4_BASE:1.70
	OPENBSD_5_3:1.61.0.2
	OPENBSD_5_3_BASE:1.61
	OPENBSD_5_2:1.60.0.2
	OPENBSD_5_2_BASE:1.60
	OPENBSD_5_1_BASE:1.53
	OPENBSD_5_1:1.53.0.2
	OPENBSD_5_0:1.50.0.4
	OPENBSD_5_0_BASE:1.50
	OPENBSD_4_9:1.50.0.2
	OPENBSD_4_9_BASE:1.50
	OPENBSD_4_8:1.40.0.2
	OPENBSD_4_8_BASE:1.40
	OPENBSD_4_7:1.34.0.2
	OPENBSD_4_7_BASE:1.34
	OPENBSD_4_6:1.3.0.4
	OPENBSD_4_6_BASE:1.3;
locks; strict;
comment	@ * @;


1.106
date	2017.03.09.17.06.35;	author nicm;	state Exp;
branches;
next	1.105;
commitid	BJxoAdDkAuPxTBwC;

1.105
date	2017.03.09.17.02.38;	author nicm;	state Exp;
branches;
next	1.104;
commitid	QtFskEpSXY809LlK;

1.104
date	2017.02.09.15.04.53;	author nicm;	state Exp;
branches;
next	1.103;
commitid	LotTNNNN3Vrlt9Fn;

1.103
date	2017.01.13.11.56.43;	author nicm;	state Exp;
branches;
next	1.102;
commitid	ue6KcgTetKiECTMk;

1.102
date	2016.10.16.22.06.40;	author nicm;	state Exp;
branches;
next	1.101;
commitid	j0FZs70gSPCmpqWI;

1.101
date	2016.10.11.13.21.59;	author nicm;	state Exp;
branches;
next	1.100;
commitid	80rgEIPcNpyBnf95;

1.100
date	2016.10.10.21.29.23;	author nicm;	state Exp;
branches;
next	1.99;
commitid	z4Hr4PZF7Ev93uEJ;

1.99
date	2016.06.16.10.55.47;	author nicm;	state Exp;
branches;
next	1.98;
commitid	iwpkepU9NO5jIk1m;

1.98
date	2016.01.19.15.59.12;	author nicm;	state Exp;
branches;
next	1.97;
commitid	P3qmSOx6KrDBsb0c;

1.97
date	2015.12.16.21.50.37;	author nicm;	state Exp;
branches;
next	1.96;
commitid	Bam1GajuDZzmKjyE;

1.96
date	2015.12.12.18.32.24;	author nicm;	state Exp;
branches;
next	1.95;
commitid	q7iDAcShsJWlLYhr;

1.95
date	2015.12.11.12.39.47;	author nicm;	state Exp;
branches;
next	1.94;
commitid	VpAlBc26sKMGjzZj;

1.94
date	2015.11.24.23.46.15;	author nicm;	state Exp;
branches;
next	1.93;
commitid	0H2a77mNskMnXKL5;

1.93
date	2015.11.18.14.27.44;	author nicm;	state Exp;
branches;
next	1.92;
commitid	RjsAPRkWwvS79w40;

1.92
date	2015.11.14.09.41.07;	author nicm;	state Exp;
branches;
next	1.91;
commitid	FQoND7M2BC89FZoU;

1.91
date	2015.10.27.15.58.42;	author nicm;	state Exp;
branches;
next	1.90;
commitid	89xhQafU35Q5MQVC;

1.90
date	2015.10.27.13.23.24;	author nicm;	state Exp;
branches;
next	1.89;
commitid	g6GdEJXfBNprXHEK;

1.89
date	2015.10.20.21.12.09;	author nicm;	state Exp;
branches;
next	1.88;
commitid	fVAT1gEydaesyRmS;

1.88
date	2015.09.10.08.58.14;	author nicm;	state Exp;
branches;
next	1.87;
commitid	fjYzZVETyEmTAStI;

1.87
date	2015.08.28.13.01.03;	author nicm;	state Exp;
branches;
next	1.86;
commitid	fIVZtZS9F66XgvbR;

1.86
date	2015.08.28.12.16.28;	author nicm;	state Exp;
branches;
next	1.85;
commitid	LqkiQ6rY2EYTPxv3;

1.85
date	2015.04.29.15.59.08;	author nicm;	state Exp;
branches;
next	1.84;
commitid	8yIyhuBaxmohYzMx;

1.84
date	2015.04.24.23.17.11;	author nicm;	state Exp;
branches;
next	1.83;
commitid	iy4fcaIoXzxOx84I;

1.83
date	2015.04.22.15.32.33;	author nicm;	state Exp;
branches;
next	1.82;
commitid	g5PKK6dkIwS2RVh8;

1.82
date	2015.04.21.21.24.49;	author nicm;	state Exp;
branches;
next	1.81;
commitid	K8Hi9QRAunzeiy2h;

1.81
date	2015.04.19.21.46.52;	author nicm;	state Exp;
branches;
next	1.80;
commitid	ZYGNoSajvPNAKjzQ;

1.80
date	2015.04.19.21.34.21;	author nicm;	state Exp;
branches;
next	1.79;
commitid	wug6ctIOfhVMeWQp;

1.79
date	2015.03.31.17.45.10;	author nicm;	state Exp;
branches;
next	1.78;
commitid	2uQloBaX92ri1PyE;

1.78
date	2015.01.06.09.12.53;	author nicm;	state Exp;
branches;
next	1.77;
commitid	KfIDi5pzqD5rQiap;

1.77
date	2014.10.20.23.27.14;	author nicm;	state Exp;
branches;
next	1.76;
commitid	BAMrPS0saBiCc8HD;

1.76
date	2014.04.17.14.45.49;	author nicm;	state Exp;
branches;
next	1.75;

1.75
date	2014.02.14.13.59.01;	author nicm;	state Exp;
branches;
next	1.74;

1.74
date	2013.10.10.12.26.36;	author nicm;	state Exp;
branches;
next	1.73;

1.73
date	2013.10.10.12.13.56;	author nicm;	state Exp;
branches;
next	1.72;

1.72
date	2013.10.10.12.13.29;	author nicm;	state Exp;
branches;
next	1.71;

1.71
date	2013.10.10.11.46.28;	author nicm;	state Exp;
branches;
next	1.70;

1.70
date	2013.07.05.14.52.33;	author nicm;	state Exp;
branches;
next	1.69;

1.69
date	2013.04.22.13.35.18;	author nicm;	state Exp;
branches;
next	1.68;

1.68
date	2013.03.25.11.36.59;	author nicm;	state Exp;
branches;
next	1.67;

1.67
date	2013.03.25.10.11.45;	author nicm;	state Exp;
branches;
next	1.66;

1.66
date	2013.03.24.09.57.59;	author nicm;	state Exp;
branches;
next	1.65;

1.65
date	2013.03.24.09.54.10;	author nicm;	state Exp;
branches;
next	1.64;

1.64
date	2013.03.22.10.42.55;	author nicm;	state Exp;
branches;
next	1.63;

1.63
date	2013.03.22.10.31.22;	author nicm;	state Exp;
branches;
next	1.62;

1.62
date	2013.03.21.18.47.01;	author nicm;	state Exp;
branches;
next	1.61;

1.61
date	2012.09.03.08.48.57;	author nicm;	state Exp;
branches;
next	1.60;

1.60
date	2012.07.10.11.53.01;	author nicm;	state Exp;
branches;
next	1.59;

1.59
date	2012.06.18.13.16.42;	author nicm;	state Exp;
branches;
next	1.58;

1.58
date	2012.05.22.10.56.48;	author nicm;	state Exp;
branches;
next	1.57;

1.57
date	2012.05.21.18.27.42;	author nicm;	state Exp;
branches;
next	1.56;

1.56
date	2012.04.29.17.20.01;	author nicm;	state Exp;
branches;
next	1.55;

1.55
date	2012.03.17.22.35.09;	author nicm;	state Exp;
branches;
next	1.54;

1.54
date	2012.03.17.18.24.07;	author nicm;	state Exp;
branches;
next	1.53;

1.53
date	2012.01.29.02.22.11;	author nicm;	state Exp;
branches;
next	1.52;

1.52
date	2011.10.23.10.16.14;	author nicm;	state Exp;
branches;
next	1.51;

1.51
date	2011.09.05.23.40.51;	author nicm;	state Exp;
branches;
next	1.50;

1.50
date	2011.01.23.11.03.43;	author nicm;	state Exp;
branches;
next	1.49;

1.49
date	2011.01.01.01.12.09;	author nicm;	state Exp;
branches;
next	1.48;

1.48
date	2010.12.23.21.56.38;	author nicm;	state Exp;
branches;
next	1.47;

1.47
date	2010.12.21.22.37.59;	author nicm;	state Exp;
branches;
next	1.46;

1.46
date	2010.12.20.00.17.22;	author nicm;	state Exp;
branches;
next	1.45;

1.45
date	2010.12.11.18.39.25;	author nicm;	state Exp;
branches;
next	1.44;

1.44
date	2010.10.09.12.58.00;	author nicm;	state Exp;
branches;
next	1.43;

1.43
date	2010.10.05.17.15.21;	author nicm;	state Exp;
branches;
next	1.42;

1.42
date	2010.09.26.20.43.30;	author nicm;	state Exp;
branches;
next	1.41;

1.41
date	2010.08.11.07.36.23;	author nicm;	state Exp;
branches;
next	1.40;

1.40
date	2010.07.24.20.11.59;	author nicm;	state Exp;
branches;
next	1.39;

1.39
date	2010.06.27.00.22.22;	author nicm;	state Exp;
branches;
next	1.38;

1.38
date	2010.06.26.23.55.50;	author nicm;	state Exp;
branches;
next	1.37;

1.37
date	2010.06.21.01.27.46;	author nicm;	state Exp;
branches;
next	1.36;

1.36
date	2010.04.17.23.25.16;	author nicm;	state Exp;
branches;
next	1.35;

1.35
date	2010.03.22.19.18.46;	author nicm;	state Exp;
branches;
next	1.34;

1.34
date	2010.01.23.21.07.31;	author nicm;	state Exp;
branches;
next	1.33;

1.33
date	2010.01.03.12.51.05;	author nicm;	state Exp;
branches;
next	1.32;

1.32
date	2009.12.22.10.20.08;	author nicm;	state Exp;
branches;
next	1.31;

1.31
date	2009.12.03.22.50.10;	author nicm;	state Exp;
branches;
next	1.30;

1.30
date	2009.11.26.21.37.13;	author nicm;	state Exp;
branches;
next	1.29;

1.29
date	2009.11.13.17.33.07;	author nicm;	state Exp;
branches;
next	1.28;

1.28
date	2009.11.04.23.29.42;	author nicm;	state Exp;
branches;
next	1.27;

1.27
date	2009.11.04.23.12.43;	author nicm;	state Exp;
branches;
next	1.26;

1.26
date	2009.10.11.10.39.27;	author nicm;	state Exp;
branches;
next	1.25;

1.25
date	2009.10.10.10.02.48;	author nicm;	state Exp;
branches;
next	1.24;

1.24
date	2009.10.04.10.55.30;	author nicm;	state Exp;
branches;
next	1.23;

1.23
date	2009.09.24.14.17.09;	author nicm;	state Exp;
branches;
next	1.22;

1.22
date	2009.09.23.06.18.47;	author nicm;	state Exp;
branches;
next	1.21;

1.21
date	2009.09.20.17.27.18;	author nicm;	state Exp;
branches;
next	1.20;

1.20
date	2009.09.20.14.58.12;	author nicm;	state Exp;
branches;
next	1.19;

1.19
date	2009.09.12.13.01.19;	author nicm;	state Exp;
branches;
next	1.18;

1.18
date	2009.09.05.17.42.16;	author nicm;	state Exp;
branches;
next	1.17;

1.17
date	2009.09.02.16.38.35;	author nicm;	state Exp;
branches;
next	1.16;

1.16
date	2009.09.01.09.11.05;	author nicm;	state Exp;
branches;
next	1.15;

1.15
date	2009.08.31.20.46.19;	author nicm;	state Exp;
branches;
next	1.14;

1.14
date	2009.08.11.17.18.35;	author nicm;	state Exp;
branches;
next	1.13;

1.13
date	2009.08.08.21.52.43;	author nicm;	state Exp;
branches;
next	1.12;

1.12
date	2009.08.07.15.39.10;	author nicm;	state Exp;
branches;
next	1.11;

1.11
date	2009.07.29.14.17.26;	author nicm;	state Exp;
branches;
next	1.10;

1.10
date	2009.07.26.12.58.44;	author nicm;	state Exp;
branches;
next	1.9;

1.9
date	2009.07.20.14.37.51;	author nicm;	state Exp;
branches;
next	1.8;

1.8
date	2009.07.17.20.37.03;	author nicm;	state Exp;
branches;
next	1.7;

1.7
date	2009.07.17.07.09.46;	author nicm;	state Exp;
branches;
next	1.6;

1.6
date	2009.07.17.06.13.27;	author nicm;	state Exp;
branches;
next	1.5;

1.5
date	2009.07.14.06.59.06;	author nicm;	state Exp;
branches;
next	1.4;

1.4
date	2009.07.10.05.50.54;	author nicm;	state Exp;
branches;
next	1.3;

1.3
date	2009.06.30.13.40.30;	author nicm;	state Exp;
branches;
next	1.2;

1.2
date	2009.06.25.06.15.04;	author nicm;	state Exp;
branches;
next	1.1;

1.1
date	2009.06.01.22.58.49;	author nicm;	state Exp;
branches;
next	;


desc
@@


1.106
log
@Move the client identify (display-panes) code into server-client.c.
@
text
@/* $OpenBSD: server-fn.c,v 1.105 2017/03/09 17:02:38 nicm Exp $ */

/*
 * Copyright (c) 2007 Nicholas Marriott <nicholas.marriott@@gmail.com>
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF MIND, USE, DATA OR PROFITS, WHETHER
 * IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING
 * OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */

#include <sys/types.h>
#include <sys/queue.h>
#include <sys/uio.h>

#include <imsg.h>
#include <stdlib.h>
#include <string.h>
#include <time.h>
#include <unistd.h>

#include "tmux.h"

static struct session	*server_next_session(struct session *);
static void		 server_destroy_session_group(struct session *);

void
server_redraw_client(struct client *c)
{
	c->flags |= CLIENT_REDRAW;
}

void
server_status_client(struct client *c)
{
	c->flags |= CLIENT_STATUS;
}

void
server_redraw_session(struct session *s)
{
	struct client	*c;

	TAILQ_FOREACH(c, &clients, entry) {
		if (c->session == s)
			server_redraw_client(c);
	}
}

void
server_redraw_session_group(struct session *s)
{
	struct session_group	*sg;

	if ((sg = session_group_contains(s)) == NULL)
		server_redraw_session(s);
	else {
		TAILQ_FOREACH(s, &sg->sessions, gentry)
			server_redraw_session(s);
	}
}

void
server_status_session(struct session *s)
{
	struct client	*c;

	TAILQ_FOREACH(c, &clients, entry) {
		if (c->session == s)
			server_status_client(c);
	}
}

void
server_status_session_group(struct session *s)
{
	struct session_group	*sg;

	if ((sg = session_group_contains(s)) == NULL)
		server_status_session(s);
	else {
		TAILQ_FOREACH(s, &sg->sessions, gentry)
			server_status_session(s);
	}
}

void
server_redraw_window(struct window *w)
{
	struct client	*c;

	TAILQ_FOREACH(c, &clients, entry) {
		if (c->session != NULL && c->session->curw->window == w)
			server_redraw_client(c);
	}
	w->flags |= WINDOW_REDRAW;
}

void
server_redraw_window_borders(struct window *w)
{
	struct client	*c;

	TAILQ_FOREACH(c, &clients, entry) {
		if (c->session != NULL && c->session->curw->window == w)
			c->flags |= CLIENT_BORDERS;
	}
}

void
server_status_window(struct window *w)
{
	struct session	*s;

	/*
	 * This is slightly different. We want to redraw the status line of any
	 * clients containing this window rather than anywhere it is the
	 * current window.
	 */

	RB_FOREACH(s, sessions, &sessions) {
		if (session_has(s, w))
			server_status_session(s);
	}
}

void
server_lock(void)
{
	struct client	*c;

	TAILQ_FOREACH(c, &clients, entry) {
		if (c->session != NULL)
			server_lock_client(c);
	}
}

void
server_lock_session(struct session *s)
{
	struct client	*c;

	TAILQ_FOREACH(c, &clients, entry) {
		if (c->session == s)
			server_lock_client(c);
	}
}

void
server_lock_client(struct client *c)
{
	const char	*cmd;

	if (c->flags & CLIENT_CONTROL)
		return;

	if (c->flags & CLIENT_SUSPENDED)
		return;

	cmd = options_get_string(c->session->options, "lock-command");
	if (strlen(cmd) + 1 > MAX_IMSGSIZE - IMSG_HEADER_SIZE)
		return;

	tty_stop_tty(&c->tty);
	tty_raw(&c->tty, tty_term_string(c->tty.term, TTYC_SMCUP));
	tty_raw(&c->tty, tty_term_string(c->tty.term, TTYC_CLEAR));
	tty_raw(&c->tty, tty_term_string(c->tty.term, TTYC_E3));

	c->flags |= CLIENT_SUSPENDED;
	proc_send_s(c->peer, MSG_LOCK, cmd);
}

void
server_kill_window(struct window *w)
{
	struct session		*s, *next_s, *target_s;
	struct session_group	*sg;
	struct winlink		*wl;

	next_s = RB_MIN(sessions, &sessions);
	while (next_s != NULL) {
		s = next_s;
		next_s = RB_NEXT(sessions, &sessions, s);

		if (!session_has(s, w))
			continue;
		server_unzoom_window(w);
		while ((wl = winlink_find_by_window(&s->windows, w)) != NULL) {
			if (session_detach(s, wl)) {
				server_destroy_session_group(s);
				break;
			} else
				server_redraw_session_group(s);
		}

		if (options_get_number(s->options, "renumber-windows")) {
			if ((sg = session_group_contains(s)) != NULL) {
				TAILQ_FOREACH(target_s, &sg->sessions, gentry)
					session_renumber_windows(target_s);
			} else
				session_renumber_windows(s);
		}
	}
	recalculate_sizes();
}

int
server_link_window(struct session *src, struct winlink *srcwl,
    struct session *dst, int dstidx, int killflag, int selectflag,
    char **cause)
{
	struct winlink		*dstwl;
	struct session_group	*srcsg, *dstsg;

	srcsg = session_group_contains(src);
	dstsg = session_group_contains(dst);
	if (src != dst && srcsg != NULL && dstsg != NULL && srcsg == dstsg) {
		xasprintf(cause, "sessions are grouped");
		return (-1);
	}

	dstwl = NULL;
	if (dstidx != -1)
		dstwl = winlink_find_by_index(&dst->windows, dstidx);
	if (dstwl != NULL) {
		if (dstwl->window == srcwl->window) {
			xasprintf(cause, "same index: %d", dstidx);
			return (-1);
		}
		if (killflag) {
			/*
			 * Can't use session_detach as it will destroy session
			 * if this makes it empty.
			 */
			notify_session_window("window-unlinked", dst,
			    dstwl->window);
			dstwl->flags &= ~WINLINK_ALERTFLAGS;
			winlink_stack_remove(&dst->lastw, dstwl);
			winlink_remove(&dst->windows, dstwl);

			/* Force select/redraw if current. */
			if (dstwl == dst->curw) {
				selectflag = 1;
				dst->curw = NULL;
			}
		}
	}

	if (dstidx == -1)
		dstidx = -1 - options_get_number(dst->options, "base-index");
	dstwl = session_attach(dst, srcwl->window, dstidx, cause);
	if (dstwl == NULL)
		return (-1);

	if (selectflag)
		session_select(dst, dstwl->idx);
	server_redraw_session_group(dst);

	return (0);
}

void
server_unlink_window(struct session *s, struct winlink *wl)
{
	if (session_detach(s, wl))
		server_destroy_session_group(s);
	else
		server_redraw_session_group(s);
}

void
server_destroy_pane(struct window_pane *wp, int notify)
{
	struct window		*w = wp->window;
	int			 old_fd;
	struct screen_write_ctx	 ctx;
	struct grid_cell	 gc;

	old_fd = wp->fd;
	if (wp->fd != -1) {
		bufferevent_free(wp->event);
		close(wp->fd);
		wp->fd = -1;
	}

	if (options_get_number(w->options, "remain-on-exit")) {
		if (old_fd == -1)
			return;

		if (notify)
			notify_pane("pane-died", wp);

		screen_write_start(&ctx, wp, &wp->base);
		screen_write_scrollregion(&ctx, 0, screen_size_y(ctx.s) - 1);
		screen_write_cursormove(&ctx, 0, screen_size_y(ctx.s) - 1);
		screen_write_linefeed(&ctx, 1);
		memcpy(&gc, &grid_default_cell, sizeof gc);
		gc.attr |= GRID_ATTR_BRIGHT;
		screen_write_puts(&ctx, &gc, "Pane is dead");
		screen_write_stop(&ctx);
		wp->flags |= PANE_REDRAW;

		return;
	}

	if (notify)
		notify_pane("pane-exited", wp);

	server_unzoom_window(w);
	layout_close_pane(wp);
	window_remove_pane(w, wp);

	if (TAILQ_EMPTY(&w->panes))
		server_kill_window(w);
	else
		server_redraw_window(w);
}

static void
server_destroy_session_group(struct session *s)
{
	struct session_group	*sg;
	struct session		*s1;

	if ((sg = session_group_contains(s)) == NULL)
		server_destroy_session(s);
	else {
		TAILQ_FOREACH_SAFE(s, &sg->sessions, gentry, s1) {
			server_destroy_session(s);
			session_destroy(s);
		}
	}
}

static struct session *
server_next_session(struct session *s)
{
	struct session *s_loop, *s_out;

	s_out = NULL;
	RB_FOREACH(s_loop, sessions, &sessions) {
		if (s_loop == s)
			continue;
		if (s_out == NULL ||
		    timercmp(&s_loop->activity_time, &s_out->activity_time, <))
			s_out = s_loop;
	}
	return (s_out);
}

void
server_destroy_session(struct session *s)
{
	struct client	*c;
	struct session	*s_new;

	if (!options_get_number(s->options, "detach-on-destroy"))
		s_new = server_next_session(s);
	else
		s_new = NULL;

	TAILQ_FOREACH(c, &clients, entry) {
		if (c->session != s)
			continue;
		if (s_new == NULL) {
			c->session = NULL;
			c->flags |= CLIENT_EXIT;
		} else {
			c->last_session = NULL;
			c->session = s_new;
			server_client_set_key_table(c, NULL);
			status_timer_start(c);
			notify_client("client-session-changed", c);
			session_update_activity(s_new, NULL);
			gettimeofday(&s_new->last_attached_time, NULL);
			server_redraw_client(c);
			alerts_check_session(s_new);
		}
	}
	recalculate_sizes();
}

void
server_check_unattached(void)
{
	struct session	*s;

	/*
	 * If any sessions are no longer attached and have destroy-unattached
	 * set, collect them.
	 */
	RB_FOREACH(s, sessions, &sessions) {
		if (!(s->flags & SESSION_UNATTACHED))
			continue;
		if (options_get_number (s->options, "destroy-unattached"))
			session_destroy(s);
	}
}

/* Set stdin callback. */
int
server_set_stdin_callback(struct client *c, void (*cb)(struct client *, int,
    void *), void *cb_data, char **cause)
{
	if (c == NULL || c->session != NULL) {
		*cause = xstrdup("no client with stdin");
		return (-1);
	}
	if (c->flags & CLIENT_TERMINAL) {
		*cause = xstrdup("stdin is a tty");
		return (-1);
	}
	if (c->stdin_callback != NULL) {
		*cause = xstrdup("stdin in use");
		return (-1);
	}

	c->stdin_callback_data = cb_data;
	c->stdin_callback = cb;

	c->references++;

	if (c->stdin_closed)
		c->stdin_callback(c, 1, c->stdin_callback_data);

	proc_send(c->peer, MSG_STDIN, -1, NULL, 0);

	return (0);
}

void
server_unzoom_window(struct window *w)
{
	if (window_unzoom(w) == 0) {
		server_redraw_window(w);
		server_status_window(w);
	}
}
@


1.105
log
@Move server_fill_environ into environ.c and move some other common code
into it.
@
text
@d1 1
a1 1
/* $OpenBSD: server-fn.c,v 1.104 2017/02/09 15:04:53 nicm Exp $ */
a31 1
static void		 server_callback_identify(int, short, void *);
a404 40
}

void
server_set_identify(struct client *c)
{
	struct timeval	tv;
	int		delay;

	delay = options_get_number(c->session->options, "display-panes-time");
	tv.tv_sec = delay / 1000;
	tv.tv_usec = (delay % 1000) * 1000L;

	if (event_initialized(&c->identify_timer))
		evtimer_del(&c->identify_timer);
	evtimer_set(&c->identify_timer, server_callback_identify, c);
	evtimer_add(&c->identify_timer, &tv);

	c->flags |= CLIENT_IDENTIFY;
	c->tty.flags |= (TTY_FREEZE|TTY_NOCURSOR);
	server_redraw_client(c);
}

void
server_clear_identify(struct client *c, struct window_pane *wp)
{
	if (~c->flags & CLIENT_IDENTIFY)
		return;
	c->flags &= ~CLIENT_IDENTIFY;

	if (c->identify_callback != NULL)
		c->identify_callback(c, wp);

	c->tty.flags &= ~(TTY_FREEZE|TTY_NOCURSOR);
	server_redraw_client(c);
}

static void
server_callback_identify(__unused int fd, __unused short events, void *data)
{
	server_clear_identify(data, NULL);
@


1.104
log
@Instead of numbering session groups, give them a name which may be given
to -t instead of a target session. Also allow them to contain only one
session.
@
text
@d1 1
a1 1
/* $OpenBSD: server-fn.c,v 1.103 2017/01/13 11:56:43 nicm Exp $ */
a33 18

void
server_fill_environ(struct session *s, struct environ *env)
{
	const char	*term;
	u_int		 idx;
	long		 pid;

	if (s != NULL) {
		term = options_get_string(global_options, "default-terminal");
		environ_set(env, "TERM", "%s", term);

		idx = s->id;
	} else
		idx = (u_int)-1;
	pid = getpid();
	environ_set(env, "TMUX", "%s,%ld,%u", socket_path, pid, idx);
}
@


1.103
log
@Make options_get_string return const string.
@
text
@d1 1
a1 1
/* $OpenBSD: server-fn.c,v 1.102 2016/10/16 22:06:40 nicm Exp $ */
d81 1
a81 1
	if ((sg = session_group_find(s)) == NULL)
d105 1
a105 1
	if ((sg = session_group_find(s)) == NULL)
d223 1
a223 1
			if ((sg = session_group_find(s)) != NULL) {
d241 2
a242 2
	srcsg = session_group_find(src);
	dstsg = session_group_find(dst);
d351 1
a351 1
	if ((sg = session_group_find(s)) == NULL)
@


1.102
log
@Use the notify name string instead of going via an enum and change
existing hooks to use notifys instead.
@
text
@d1 1
a1 1
/* $OpenBSD: server-fn.c,v 1.101 2016/10/11 13:21:59 nicm Exp $ */
d38 3
a40 3
	char	*term;
	u_int	 idx;
	long	 pid;
@


1.101
log
@Add static in window-*.c and move some internal functions out of tmux.h.
@
text
@d1 1
a1 1
/* $OpenBSD: server-fn.c,v 1.100 2016/10/10 21:29:23 nicm Exp $ */
d261 2
a262 1
			notify_window_unlinked(dst, dstwl->window);
d298 1
a298 1
server_destroy_pane(struct window_pane *wp, int hooks)
a303 1
	struct cmd_find_state	 fs;
d315 4
a328 2
		if (hooks && cmd_find_from_pane(&fs, wp) == 0)
			hooks_run(hooks_get(fs.s), NULL, &fs, "pane-died");
d332 3
a338 3
	if (hooks && cmd_find_from_window(&fs, w) == 0)
		hooks_run(hooks_get(fs.s), NULL, &fs, "pane-exited");

d399 1
a399 1
			notify_attached_session_changed(c);
@


1.100
log
@Loads more static, except for cmd-*.c and window-*.c.
@
text
@d1 1
a1 1
/* $OpenBSD: server-fn.c,v 1.99 2016/06/16 10:55:47 nicm Exp $ */
d33 1
d343 1
a343 1
void
@


1.99
log
@Allow a command to be specified to display-panes, similar to
command-prompt, rather than always just selecting the pane.
@
text
@d1 1
a1 1
/* $OpenBSD: server-fn.c,v 1.98 2016/01/19 15:59:12 nicm Exp $ */
d31 2
a32 2
struct session *server_next_session(struct session *);
void		server_callback_identify(int, short, void *);
d358 1
a358 1
struct session *
d457 1
a457 1
void
@


1.98
log
@I no longer use my SourceForge address so replace it.
@
text
@d1 1
a1 1
/* $OpenBSD: server-fn.c,v 1.97 2015/12/16 21:50:37 nicm Exp $ */
d444 1
a444 1
server_clear_identify(struct client *c)
d446 9
a454 5
	if (c->flags & CLIENT_IDENTIFY) {
		c->flags &= ~CLIENT_IDENTIFY;
		c->tty.flags &= ~(TTY_FREEZE|TTY_NOCURSOR);
		server_redraw_client(c);
	}
d460 1
a460 3
	struct client	*c = data;

	server_clear_identify(c);
@


1.97
log
@Add infrastructure to work out the best target given a pane or window
alone and use it to add pane_died and pane_exited hooks.
@
text
@d1 1
a1 1
/* $OpenBSD: server-fn.c,v 1.96 2015/12/12 18:32:24 nicm Exp $ */
d4 1
a4 1
 * Copyright (c) 2007 Nicholas Marriott <nicm@@users.sourceforge.net>
@


1.96
log
@Add key-table option to set the default key table for a session, allows
different key bindings for different sessions and a few other things.
@
text
@d1 1
a1 1
/* $OpenBSD: server-fn.c,v 1.95 2015/12/11 12:39:47 nicm Exp $ */
d296 1
a296 1
server_destroy_pane(struct window_pane *wp)
d302 1
d323 3
d332 3
@


1.95
log
@Check alerts when session changes, from Patrick Palka.
@
text
@d1 1
a1 1
/* $OpenBSD: server-fn.c,v 1.94 2015/11/24 23:46:15 nicm Exp $ */
d387 1
@


1.94
log
@Make environ_set va_args and use it to tidy up some calls. Also add a
missing word in manpage (from jmc).
@
text
@d1 1
a1 1
/* $OpenBSD: server-fn.c,v 1.93 2015/11/18 14:27:44 nicm Exp $ */
d392 1
@


1.93
log
@Use __unused rather than rolling our own.
@
text
@d1 1
a1 1
/* $OpenBSD: server-fn.c,v 1.92 2015/11/14 09:41:07 nicm Exp $ */
d37 3
a39 3
	char	var[PATH_MAX], *term;
	u_int	idx;
	long	pid;
d43 1
a43 1
		environ_set(env, "TERM", term);
d49 1
a49 2
	xsnprintf(var, sizeof var, "%s,%ld,%u", socket_path, pid, idx);
	environ_set(env, "TMUX", var);
@


1.92
log
@Push stdout and stderr to clients more aggressively, and add an event to
continue if the send fails.
@
text
@d1 1
a1 1
/* $OpenBSD: server-fn.c,v 1.91 2015/10/27 15:58:42 nicm Exp $ */
d446 1
a446 1
server_callback_identify(unused int fd, unused short events, void *data)
@


1.91
log
@Move struct options into options.c.
@
text
@d1 1
a1 1
/* $OpenBSD: server-fn.c,v 1.90 2015/10/27 13:23:24 nicm Exp $ */
a450 44
}

/* Push stdout to client if possible. */
void
server_push_stdout(struct client *c)
{
	struct msg_stdout_data data;
	size_t                 size;

	size = EVBUFFER_LENGTH(c->stdout_data);
	if (size == 0)
		return;
	if (size > sizeof data.data)
		size = sizeof data.data;

	memcpy(data.data, EVBUFFER_DATA(c->stdout_data), size);
	data.size = size;

	if (proc_send(c->peer, MSG_STDOUT, -1, &data, sizeof data) == 0)
		evbuffer_drain(c->stdout_data, size);
}

/* Push stderr to client if possible. */
void
server_push_stderr(struct client *c)
{
	struct msg_stderr_data data;
	size_t                 size;

	if (c->stderr_data == c->stdout_data) {
		server_push_stdout(c);
		return;
	}
	size = EVBUFFER_LENGTH(c->stderr_data);
	if (size == 0)
		return;
	if (size > sizeof data.data)
		size = sizeof data.data;

	memcpy(data.data, EVBUFFER_DATA(c->stderr_data), size);
	data.size = size;

	if (proc_send(c->peer, MSG_STDERR, -1, &data, sizeof data) == 0)
		evbuffer_drain(c->stderr_data, size);
@


1.90
log
@Break the common process set up, event loop and imsg dispatch code
between server and client out into a separate internal API. This will
make it easier to add another process.
@
text
@d1 1
a1 1
/* $OpenBSD: server-fn.c,v 1.89 2015/10/20 21:12:09 nicm Exp $ */
d42 1
a42 1
		term = options_get_string(&global_options, "default-terminal");
d186 1
a186 1
	cmd = options_get_string(&c->session->options, "lock-command");
d222 1
a222 1
		if (options_get_number(&s->options, "renumber-windows")) {
d275 1
a275 1
		dstidx = -1 - options_get_number(&dst->options, "base-index");
d311 1
a311 1
	if (options_get_number(&w->options, "remain-on-exit")) {
d374 1
a374 1
	if (!options_get_number(&s->options, "detach-on-destroy"))
d410 1
a410 1
		if (options_get_number (&s->options, "destroy-unattached"))
d421 1
a421 1
	delay = options_get_number(&c->session->options, "display-panes-time");
@


1.89
log
@Use client pointer not file descriptor in logging.
@
text
@d1 1
a1 1
/* $OpenBSD: server-fn.c,v 1.88 2015/09/10 08:58:14 nicm Exp $ */
d20 2
d23 1
a53 37
server_write_ready(struct client *c)
{
	if (c->flags & CLIENT_CONTROL)
		return;
	server_write_client(c, MSG_READY, NULL, 0);
}

int
server_write_client(struct client *c, enum msgtype type, const void *buf,
    size_t len)
{
	struct imsgbuf	*ibuf = &c->ibuf;
	int              error;

	if (c->flags & CLIENT_BAD)
		return (-1);
	log_debug("writing %d to client %p", type, c);
	error = imsg_compose(ibuf, type, PROTOCOL_VERSION, -1, -1,
	    (void *) buf, len);
	if (error == 1)
		server_update_event(c);
	return (error == 1 ? 0 : -1);
}

void
server_write_session(struct session *s, enum msgtype type, const void *buf,
    size_t len)
{
	struct client	*c;

	TAILQ_FOREACH(c, &clients, entry) {
		if (c->session == s)
			server_write_client(c, type, buf, len);
	}
}

void
d196 1
a196 1
	server_write_client(c, MSG_LOCK, cmd, strlen(cmd) + 1);
a452 16
void
server_update_event(struct client *c)
{
	short	events;

	events = 0;
	if (!(c->flags & CLIENT_BAD))
		events |= EV_READ;
	if (c->ibuf.w.queued > 0)
		events |= EV_WRITE;
	if (event_initialized(&c->event))
		event_del(&c->event);
	event_set(&c->event, c->ibuf.fd, events, server_client_callback, c);
	event_add(&c->event, NULL);
}

d469 1
a469 1
	if (server_write_client(c, MSG_STDOUT, &data, sizeof data) == 0)
d493 1
a493 1
	if (server_write_client(c, MSG_STDERR, &data, sizeof data) == 0)
d523 1
a523 1
	server_write_client(c, MSG_STDIN, NULL, 0);
@


1.88
log
@Add session_last_attached time and format, from Sina Siadat.
@
text
@d1 1
a1 1
/* $OpenBSD: server-fn.c,v 1.87 2015/08/28 13:01:03 nicm Exp $ */
d67 1
a67 1
	log_debug("writing %d to client %d", type, c->ibuf.fd);
@


1.87
log
@Make session_update_activity more useful and use it in more places.
@
text
@d1 1
a1 1
/* $OpenBSD: server-fn.c,v 1.86 2015/08/28 12:16:28 nicm Exp $ */
d425 1
@


1.86
log
@Run status update on a per-client timer at status-interval.
@
text
@d1 1
a1 1
/* $OpenBSD: server-fn.c,v 1.85 2015/04/29 15:59:08 nicm Exp $ */
d424 1
a424 1
			session_update_activity(s_new);
@


1.85
log
@If default-terminal is set to "screen" or "screen-*", emulate screen's
historical (incorrect) behaviour for SGR 3 and send smso
(standout). Previously, we would send sitm (italics) if the terminal
outside had it and smso otherwise. This was acceptably until recently
because xterm's terminfo entry lacked sitm, so most users got smso.

People who want italics should set default-terminal to the forthcoming
"tmux" entry (and be prepared to deal with it being missing on older
hosts).

As a side-effect this changes default-terminal to be a server rather
than a session option.

suggested by and ok naddy
@
text
@d1 1
a1 1
/* $OpenBSD: server-fn.c,v 1.84 2015/04/24 23:17:11 nicm Exp $ */
d422 1
@


1.84
log
@Convert clients list into a TAILQ.
@
text
@d1 1
a1 1
/* $OpenBSD: server-fn.c,v 1.83 2015/04/22 15:32:33 nicm Exp $ */
d39 1
a39 1
		term = options_get_string(&s->options, "default-terminal");
@


1.83
log
@Make session_has return a flag, returning the first winlink found is a
recipe for errors.
@
text
@d1 1
a1 1
/* $OpenBSD: server-fn.c,v 1.82 2015/04/21 21:24:49 nicm Exp $ */
a79 1
	u_int		 i;
d81 1
a81 4
	for (i = 0; i < ARRAY_LENGTH(&clients); i++) {
		c = ARRAY_ITEM(&clients, i);
		if (c == NULL || c->session == NULL)
			continue;
a102 1
	u_int		 i;
d104 1
a104 4
	for (i = 0; i < ARRAY_LENGTH(&clients); i++) {
		c = ARRAY_ITEM(&clients, i);
		if (c == NULL || c->session == NULL)
			continue;
a126 1
	u_int		 i;
d128 1
a128 4
	for (i = 0; i < ARRAY_LENGTH(&clients); i++) {
		c = ARRAY_ITEM(&clients, i);
		if (c == NULL || c->session == NULL)
			continue;
a150 1
	u_int		 i;
d152 2
a153 5
	for (i = 0; i < ARRAY_LENGTH(&clients); i++) {
		c = ARRAY_ITEM(&clients, i);
		if (c == NULL || c->session == NULL)
			continue;
		if (c->session->curw->window == w)
a162 1
	u_int		 i;
d164 2
a165 5
	for (i = 0; i < ARRAY_LENGTH(&clients); i++) {
		c = ARRAY_ITEM(&clients, i);
		if (c == NULL || c->session == NULL)
			continue;
		if (c->session->curw->window == w)
a190 1
	u_int		 i;
d192 3
a194 5
	for (i = 0; i < ARRAY_LENGTH(&clients); i++) {
		c = ARRAY_ITEM(&clients, i);
		if (c == NULL || c->session == NULL)
			continue;
		server_lock_client(c);
a201 1
	u_int		 i;
d203 3
a205 5
	for (i = 0; i < ARRAY_LENGTH(&clients); i++) {
		c = ARRAY_ITEM(&clients, i);
		if (c == NULL || c->session == NULL || c->session != s)
			continue;
		server_lock_client(c);
a406 1
	u_int		 i;
d413 2
a414 3
	for (i = 0; i < ARRAY_LENGTH(&clients); i++) {
		c = ARRAY_ITEM(&clients, i);
		if (c == NULL || c->session != s)
@


1.82
log
@Fix moving windows to nonexistent indexes when renumber-windows is
off. From Thomas Adam, reported by Daniel Levai and Theo Buehler.
@
text
@d1 1
a1 1
/* $OpenBSD: server-fn.c,v 1.81 2015/04/19 21:46:52 nicm Exp $ */
d202 1
a202 1
		if (session_has(s, w) != NULL)
d271 1
a271 1
		if (session_has(s, w) == NULL)
@


1.81
log
@Honour renumber-windows when unlinking a window, from Thomas Adam.
@
text
@d1 1
a1 1
/* $OpenBSD: server-fn.c,v 1.80 2015/04/19 21:34:21 nicm Exp $ */
a353 1
	session_renumber_windows(s);
@


1.80
log
@Rewrite of tmux mouse support which was a mess. Instead of having
options for "mouse-this" and "mouse-that", mouse events may be bound as
keys and there is one option "mouse" that turns on mouse support
entirely (set -g mouse on).

See the new MOUSE SUPPORT section of the man page for description of the
key names and new flags (-t= to specify the pane or window under mouse
as a target, and send-keys -M to pass through a mouse event).

The default builtin bindings for the mouse are:

    bind -n   MouseDown1Pane select-pane -t=; send-keys -M
    bind -n MouseDown1Status select-window -t=
    bind -n   MouseDrag1Pane copy-mode -M
    bind -n MouseDrag1Border resize-pane -M

To get the effect of turning mode-mouse off, do:

    unbind -n MouseDrag1Pane
    unbind -temacs-copy MouseDrag1Pane

The old mouse options are now gone, set-option -q may be used to
suppress warnings if mixing configuration files.
@
text
@d1 1
a1 1
/* $OpenBSD: server-fn.c,v 1.79 2015/03/31 17:45:10 nicm Exp $ */
d354 1
@


1.79
log
@Fix some format specifier nits, from Ben Boeckel.
@
text
@d1 1
a1 1
/* $OpenBSD: server-fn.c,v 1.78 2015/01/06 09:12:53 nicm Exp $ */
d607 4
a610 3
	window_unzoom(w);
	server_redraw_window(w);
	server_status_window(w);
@


1.78
log
@Unzoom before kill, from Thomas Adam.
@
text
@d1 1
a1 1
/* $OpenBSD: server-fn.c,v 1.77 2014/10/20 23:27:14 nicm Exp $ */
d44 1
a44 1
		idx = -1;
d46 1
a46 1
	xsnprintf(var, sizeof var, "%s,%ld,%d", socket_path, pid, idx);
@


1.77
log
@Tidy up some includes.
@
text
@d1 1
a1 1
/* $OpenBSD: server-fn.c,v 1.76 2014/04/17 14:45:49 nicm Exp $ */
d273 1
@


1.76
log
@Some more long lines.
@
text
@d1 1
a1 1
/* $OpenBSD: server-fn.c,v 1.75 2014/02/14 13:59:01 nicm Exp $ */
d34 1
a34 1
	char	var[MAXPATHLEN], *term;
@


1.75
log
@Style nit - no space between function name and bracket.
@
text
@d1 1
a1 1
/* $OpenBSD: server-fn.c,v 1.74 2013/10/10 12:26:36 nicm Exp $ */
d294 2
a295 1
    struct session *dst, int dstidx, int killflag, int selectflag, char **cause)
@


1.74
log
@Alter how tmux handles the working directory to internally use file
descriptors rather than strings.

- Each session still has a current working directory.

- New sessions still get their working directory from the client that
  created them or its attached session if any.

- New windows are created by default in the session working directory.

- The -c flag to new, neww, splitw allows the working directory to be
  overridden.

- The -c flag to attach let's the session working directory be changed.

- The default-path option has been removed.

To get the equivalent to default-path '.', do:

        bind c neww -c $PWD

To get the equivalent of default-path '~', do:

        bind c neww -c ~

This also changes the client identify protocol to be a set of messages rather
than one as well as some other changes that should make it easier to make
backwards-compatible protocol changes in future.
@
text
@d1 1
a1 1
/* $OpenBSD: server-fn.c,v 1.73 2013/10/10 12:13:56 nicm Exp $ */
d457 1
a457 1
server_check_unattached (void)
d483 1
a483 1
	if (event_initialized (&c->identify_timer))
d595 1
a595 1
		c->stdin_callback (c, 1, c->stdin_callback_data);
@


1.73
log
@Similarly for MSG_COMMAND - allow full imsg limit not arbitrary 2048.
@
text
@d1 1
a1 1
/* $OpenBSD: server-fn.c,v 1.72 2013/10/10 12:13:29 nicm Exp $ */
d59 2
a60 2
server_write_client(
    struct client *c, enum msgtype type, const void *buf, size_t len)
d76 2
a77 2
server_write_session(
    struct session *s, enum msgtype type, const void *buf, size_t len)
@


1.72
log
@Instead of fixed size buffers for some messages, send only the string
length.
@
text
@d1 1
a1 1
/* $OpenBSD: server-fn.c,v 1.71 2013/10/10 11:46:28 nicm Exp $ */
a238 1
	size_t		 cmdlen;
@


1.71
log
@Grouped sessions were being leaked on destroy, correctly free them.
@
text
@d1 1
a1 1
/* $OpenBSD: server-fn.c,v 1.70 2013/07/05 14:52:33 nicm Exp $ */
d238 2
a239 3
	const char		*cmd;
	size_t			 cmdlen;
	struct msg_lock_data	 lockdata;
d248 1
a248 2
	cmdlen = strlcpy(lockdata.cmd, cmd, sizeof lockdata.cmd);
	if (cmdlen >= sizeof lockdata.cmd)
d257 1
a257 1
	server_write_client(c, MSG_LOCK, &lockdata, sizeof lockdata);
@


1.70
log
@When the session option renumber-window is used, ensure we iterate over
all sessions in that group when the winlinks are reordered, otherwise
the winlink lists are out of sync with one another. From Thomas Adam.
@
text
@d1 1
a1 1
/* $OpenBSD: server-fn.c,v 1.69 2013/04/22 13:35:18 nicm Exp $ */
d401 1
d406 1
a406 1
		TAILQ_FOREACH(s, &sg->sessions, gentry)
d408 2
a409 2
		TAILQ_REMOVE(&session_groups, sg, entry);
		free(sg);
@


1.69
log
@Call recalculate_sizes() after killing window in case it is in a grouped
session, from Daniel Ralston.
@
text
@d1 1
a1 1
/* $OpenBSD: server-fn.c,v 1.68 2013/03/25 11:36:59 nicm Exp $ */
d265 3
a267 2
	struct session	*s, *next_s;
	struct winlink	*wl;
d284 7
a290 2
		if (options_get_number(&s->options, "renumber-windows"))
			session_renumber_windows(s);
@


1.68
log
@Use single stdout and stderr for control clients.
@
text
@d1 1
a1 1
/* $OpenBSD: server-fn.c,v 1.67 2013/03/25 10:11:45 nicm Exp $ */
d286 1
@


1.67
log
@Rename session idx to session id throughout and add $ prefix to targets
to use it, extended from a diff from George Nachman.
@
text
@d1 1
a1 1
/* $OpenBSD: server-fn.c,v 1.66 2013/03/24 09:57:59 nicm Exp $ */
d549 4
@


1.66
log
@Add resize-pane -Z to temporary zoom the active pane to occupy the full
window or unzoom (restored to the normal layout) if it already zoomed,
bound to C-b z by default. The pane is unzoomed on pretty much any
excuse whatsoever.

We considered making this a new layout but the requirements are quite
different from layouts so decided it is better as a special case. Each
current layout cell is saved, a temporary one-cell layout generated and
all except the active pane set to NULL.

Prompted by suggestions and scripts from several. Thanks to Aaron Jensen
and Thiago Padilha for testing an earlier version.
@
text
@d1 1
a1 1
/* $OpenBSD: server-fn.c,v 1.65 2013/03/24 09:54:10 nicm Exp $ */
d42 1
a42 1
		idx = s->idx;
@


1.65
log
@Add a command queue to standardize and simplify commands that call other
commands and allow a command to block execution of subsequent
commands. This allows run-shell and if-shell to be synchronous which has
been much requested.

Each client has a default command queue and commands are consumed one at
a time from it. A command may suspend execution from the queue by
returning CMD_RETURN_WAIT and then resume it by calling cmd_continue() -
for example run-shell does this from the callback that is fired after
the job is freed.

When the command queue becomes empty, command clients are automatically
exited (unless attaching). A callback is also fired - this is used for
nested commands in, for example, if-shell which can block execution of
the client's cmdq until a new cmdq becomes empty.

Also merge all the old error/info/print functions together and lose the
old curclient/cmdclient distinction - a cmdq is bound to one client (or
none if in the configuration file), this is a command client if
c->session is NULL otherwise an attached client.
@
text
@d1 1
a1 1
/* $OpenBSD: server-fn.c,v 1.64 2013/03/22 10:42:55 nicm Exp $ */
d380 1
d591 8
@


1.64
log
@Prevent lock on control clients, not on others.
@
text
@d1 1
a1 1
/* $OpenBSD: server-fn.c,v 1.63 2013/03/22 10:31:22 nicm Exp $ */
d197 1
a197 1
	 * clients containing this window rather than any where it is the
d566 1
a566 1
	if (c == NULL) {
@


1.63
log
@No more lint means no more ARGSUSED.
@
text
@d1 1
a1 1
/* $OpenBSD: server-fn.c,v 1.62 2013/03/21 18:47:01 nicm Exp $ */
d242 1
a242 1
	if (!(c->flags & CLIENT_CONTROL))
@


1.62
log
@Add various checks to turn off bits that can't work in control mode
(such as lock).
@
text
@d1 1
a1 1
/* $OpenBSD: server-fn.c,v 1.61 2012/09/03 08:48:57 nicm Exp $ */
a496 1
/* ARGSUSED */
@


1.61
log
@If stdin in the client is enable immediately, tmux will eat anything
sent to stdin before it is needed, which can be inconvenient (eg pasting
commands). Instead, start with stdin disabled and reuse MSG_STDIN from
server->client to mean that stdin should be enabled. Based on a diff
from Chris Johnsen.
@
text
@d1 1
a1 1
/* $OpenBSD: server-fn.c,v 1.60 2012/07/10 11:53:01 nicm Exp $ */
d241 3
@


1.60
log
@xfree is not particularly helpful, remove it. From Thomas Adam.
@
text
@d1 1
a1 1
/* $OpenBSD: server-fn.c,v 1.59 2012/06/18 13:16:42 nicm Exp $ */
d584 3
@


1.59
log
@Add a skeleton mode to tmux (called "control mode") that let's tmux
commands be sent and output received on stdout. This can be used to
integrate with other terminal emulators and should allow some other
things to be made simpler later. More to come so doesn't do much yet and
deliberately not documented.
@
text
@d1 1
a1 1
/* $OpenBSD: server-fn.c,v 1.58 2012/05/22 10:56:48 nicm Exp $ */
d21 1
d397 1
a397 1
		xfree(sg);
@


1.58
log
@Add a helper function to send ready message.
@
text
@d1 1
a1 1
/* $OpenBSD: server-fn.c,v 1.57 2012/05/21 18:27:42 nicm Exp $ */
d52 2
@


1.57
log
@Instead of passing stdin/stdout/stderr file descriptors over imsg and
handling them in the server, handle them in the client and pass buffers
over imsg. This is much tidier for some upcoming changes and the
performance hit isn't critical.

The tty fd is still passed to the server as before.

This bumps the tmux protocol version so new clients and old servers are
incompatible.
@
text
@d1 1
a1 1
/* $OpenBSD: server-fn.c,v 1.56 2012/04/29 17:20:01 nicm Exp $ */
d47 6
@


1.56
log
@Add a flag to move-window to renumber the windows in a session (closing
any gaps) and add an option to do this automatically each time a window
is killed. From Thomas Adam.
@
text
@d1 1
a1 1
/* $OpenBSD: server-fn.c,v 1.55 2012/03/17 22:35:09 nicm Exp $ */
d49 1
a49 1
void
d54 1
d57 1
a57 1
		return;
d59 5
a63 2
	imsg_compose(ibuf, type, PROTOCOL_VERSION, -1, -1, (void *) buf, len);
	server_update_event(c);
d508 68
@


1.55
log
@Add notify hooks for various events, the functions are currently empty
stubs but will be filled in for control mode later. From George Nachman.
@
text
@d1 1
a1 1
/* $OpenBSD: server-fn.c,v 1.54 2012/03/17 18:24:07 nicm Exp $ */
d266 3
@


1.54
log
@Check event_initialized before event_del if event may not have been set
up; libevent2 complains about this. Reported by Moriyoshi Koizumi.
@
text
@d1 1
a1 1
/* $OpenBSD: server-fn.c,v 1.53 2012/01/29 02:22:11 nicm Exp $ */
d296 1
d423 1
@


1.53
log
@Call bufferevent_free before closing file descriptor associated with it
or bugs in $EventMechanism on $OtherOS makes libevent get it's knickers
in a twist. From Dylan Alex Simon.
@
text
@d1 1
a1 1
/* $OpenBSD: server-fn.c,v 1.52 2011/10/23 10:16:14 nicm Exp $ */
d456 2
a457 1
	evtimer_del(&c->identify_timer);
d495 2
a496 1
	event_del(&c->event);
@


1.52
log
@Support for \e[3J to clear the history. Also send the corresponding
terminfo code (E3) before locking.
@
text
@d1 1
a1 1
/* $OpenBSD: server-fn.c,v 1.51 2011/09/05 23:40:51 nicm Exp $ */
d340 1
a341 1
		bufferevent_free(wp->event);
@


1.51
log
@Mark dead panes with some text saying they are dead, suggested by and
with help from Randy Stauner.
@
text
@d1 1
a1 1
/* $OpenBSD: server-fn.c,v 1.50 2011/01/23 11:03:43 nicm Exp $ */
d240 1
@


1.50
log
@Set $TMUX without the session when background jobs are run.
@
text
@d1 1
a1 1
/* $OpenBSD: server-fn.c,v 1.49 2011/01/01 01:12:09 nicm Exp $ */
d332 4
a335 1
	struct window	*w = wp->window;
d337 1
d344 12
a355 1
	if (options_get_number(&w->options, "remain-on-exit"))
d357 1
@


1.49
log
@Don't reset the activity timer for unattached sessions every second,
this screws up the choice of most-recently-used. Instead, break the time
update into a little function and do it when the session is attached.

Pointed out by joshe@@.
@
text
@d1 1
a1 1
/* $OpenBSD: server-fn.c,v 1.48 2010/12/23 21:56:38 nicm Exp $ */
d33 14
a46 8
	char	tmuxvar[MAXPATHLEN], *term;

	xsnprintf(tmuxvar, sizeof tmuxvar,
	    "%s,%ld,%u", socket_path, (long) getpid(), s->idx);
	environ_set(env, "TMUX", tmuxvar);

	term = options_get_string(&s->options, "default-terminal");
	environ_set(env, "TERM", term);
@


1.48
log
@server_kill_window can modify the RB tree so don't use RB_FOREACH, fixes
crash seen by Dan Harnett.
@
text
@d1 1
a1 1
/* $OpenBSD: server-fn.c,v 1.47 2010/12/21 22:37:59 nicm Exp $ */
d399 1
@


1.47
log
@Store sessions in an RB tree by name rather than a list, this is tidier
and allows them to easily be shown sorted in various lists
(list-sessions/choose-sessions).

Keep a session index which is used in a couple of places internally but
make it an ever-increasing number rather than filling in gaps with new
sessions.
@
text
@d1 1
a1 1
/* $OpenBSD: server-fn.c,v 1.46 2010/12/20 00:17:22 nicm Exp $ */
d242 1
a242 1
	struct session	*s;
d245 5
a249 1
	RB_FOREACH(s, sessions, &sessions) {
@


1.46
log
@Use pointer rather than index for the client's last session.
@
text
@d1 1
a1 1
/* $OpenBSD: server-fn.c,v 1.45 2010/12/11 18:39:25 nicm Exp $ */
d33 1
a33 2
	char		 tmuxvar[MAXPATHLEN], *term;
	u_int		 idx;
a34 2
	if (session_index(s, &idx) != 0)
		fatalx("session not found");
d36 1
a36 1
	    "%s,%ld,%u", socket_path, (long) getpid(), idx);
a174 1
	u_int		 i;
d182 2
a183 3
	for (i = 0; i < ARRAY_LENGTH(&sessions); i++) {
		s = ARRAY_ITEM(&sessions, i);
		if (s != NULL && session_has(s, w) != NULL)
a243 1
	u_int		 i;
d245 2
a246 3
	for (i = 0; i < ARRAY_LENGTH(&sessions); i++) {
		s = ARRAY_ITEM(&sessions, i);
		if (s == NULL || session_has(s, w) == NULL)
a360 1
	u_int		i;
d363 2
a364 3
	for (i = 0; i < ARRAY_LENGTH(&sessions); i++) {
		s_loop = ARRAY_ITEM(&sessions, i);
		if (s_loop == NULL || s_loop == s)
a404 1
	u_int		 i;
d410 2
a411 3
	for (i = 0; i < ARRAY_LENGTH(&sessions); i++) {
		s = ARRAY_ITEM(&sessions, i);
		if (s == NULL || !(s->flags & SESSION_UNATTACHED))
@


1.45
log
@Track the last session for a client and add a flag to switch-client and
a key binding (L) to move a client back to its last session.
@
text
@d1 1
a1 1
/* $OpenBSD: server-fn.c,v 1.44 2010/10/09 12:58:00 nicm Exp $ */
d402 1
a402 1
			c->last_session = UINT_MAX;
@


1.44
log
@Set cause when failing due to linking a window to itself, from Martin
Pieuchot.
@
text
@d1 1
a1 1
/* $OpenBSD: server-fn.c,v 1.43 2010/10/05 17:15:21 nicm Exp $ */
d402 1
@


1.43
log
@Skip NULL entries in the sessions list when choosing the next session,
from Simon Olofsson.
@
text
@d1 1
a1 1
/* $OpenBSD: server-fn.c,v 1.42 2010/09/26 20:43:30 nicm Exp $ */
d283 2
a284 1
		if (dstwl->window == srcwl->window)
d286 1
@


1.42
log
@Two new options:

- server option "exit-unattached" makes the server exit when no clients
  are attached, even if sessions are present;

- session option "destroy-unattached" destroys a session once no clients
  are attached to it.

These are useful for preventing tmux remaining in the background where
it is undesirable and when using tmux as a login shell to keep a limit
on new sessions.
@
text
@d1 1
a1 1
/* $OpenBSD: server-fn.c,v 1.41 2010/08/11 07:36:23 nicm Exp $ */
d371 1
a371 1
		if (s_loop == s)
@


1.41
log
@Treat trying to link or move to the same window as an error to avoid
removing it accidentally.
@
text
@d1 1
a1 1
/* $OpenBSD: server-fn.c,v 1.40 2010/07/24 20:11:59 nicm Exp $ */
d405 19
@


1.40
log
@When changing so that the client passes its stdout and stderr as well as
stdin up to the server, I forgot one essential point - the tmux server
could now be both the producer and consumer. This happens when tmux is
run inside tmux, as well as when piping tmux commands together.

So, using stdio(3) was a bad idea - if sufficient data was written, this
could block in write(2). When that happened and the server was both
producer and consumer, it deadlocks.

Change to use libevent bufferevents for the client stdin, stdout and
stderr instead. This is trivial enough for output but requires a
callback mechanism to trigger when stdin is finished.

This relies on the underlying polling mechanism for libevent to work
with whatever devices to which the user could redirect stdin, stdout or
stderr, hence the change to use poll(2) over kqueue(2) for tmux.
@
text
@d1 1
a1 1
/* $OpenBSD: server-fn.c,v 1.39 2010/06/27 00:22:22 nicm Exp $ */
d284 1
a284 1
			return (0);
@


1.39
log
@New option, detach-on-destroy, to set what happens to a client when the session
it is attached to is destroyed. If on (the default), it is detached; if off, it
is switched to the most recently active session.
@
text
@d1 1
a1 1
/* $OpenBSD: server-fn.c,v 1.38 2010/06/26 23:55:50 nicm Exp $ */
d398 1
a398 1
			server_write_client(c, MSG_EXIT, NULL, 0);
@


1.38
log
@Use server_destroy_session() for kill-session.
@
text
@d1 1
a1 1
/* $OpenBSD: server-fn.c,v 1.37 2010/06/21 01:27:46 nicm Exp $ */
d27 2
a28 1
void	server_callback_identify(int, short, void *);
d362 18
d384 1
d387 5
d396 7
a402 2
		c->session = NULL;
		server_write_client(c, MSG_EXIT, NULL, 0);
@


1.37
log
@Having a list of winlinks->alerts for each session is stupid, just store
the alert flags directly in the winlink itself.
@
text
@d1 1
a1 1
/* $OpenBSD: server-fn.c,v 1.36 2010/04/17 23:25:16 nicm Exp $ */
d374 1
@


1.36
log
@If remain-on-exit is set, both the error callback and a SIGCHLD could
destroy the same pane (because the first one doesn't remove it from the
list of panes), causing the pane bufferevent to be freed twice. So don't
free it if the fd has already been set to -1, from Romain Francoise.
@
text
@d1 1
a1 1
/* $OpenBSD: server-fn.c,v 1.35 2010/03/22 19:18:46 nicm Exp $ */
d187 1
a187 1
		if (s != NULL && session_has(s, w))
d252 1
a252 1
		if (s == NULL || !session_has(s, w))
d289 1
a289 1
			session_alert_cancel(dst, dstwl);
@


1.35
log
@Dead functions, lint.
@
text
@d1 1
a1 1
/* $OpenBSD: server-fn.c,v 1.34 2010/01/23 21:07:31 nicm Exp $ */
d328 5
a332 3
	close(wp->fd);
	bufferevent_free(wp->event);
	wp->fd = -1;
@


1.34
log
@When a window is destroyed, remove all links to it from each session rather
than just the first. Reported by Robin Lee Powell.
@
text
@d1 1
a1 1
/* $OpenBSD: server-fn.c,v 1.33 2010/01/03 12:51:05 nicm Exp $ */
a42 9
}

void
server_write_error(struct client *c, const char *msg)
{
	struct msg_print_data	printdata;

	strlcpy(printdata.msg, msg, sizeof printdata.msg);
	server_write_client(c, MSG_ERROR, &printdata, sizeof printdata);
@


1.33
log
@Options to set the colour of the pane borders, with different colours for the
active pane.
@
text
@d1 1
a1 1
/* $OpenBSD: server-fn.c,v 1.32 2009/12/22 10:20:08 nicm Exp $ */
d263 7
a269 7
		if ((wl = winlink_find_by_window(&s->windows, w)) == NULL)
			continue;

		if (session_detach(s, wl))
			server_destroy_session_group(s);
		else
			server_redraw_session_group(s);
@


1.32
log
@Fix a couple of problems with grouped sessions reported by danh: redraw
properly and choose the correct last window after a window is killed.
@
text
@d1 1
a1 1
/* $OpenBSD: server-fn.c,v 1.31 2009/12/03 22:50:10 nicm Exp $ */
d165 15
@


1.31
log
@Massive spaces->tabs and trailing whitespace cleanup, hopefully for the last
time now I've configured emacs to make them displayed in really annoying
colours...
@
text
@d1 1
a1 1
/* $OpenBSD: server-fn.c,v 1.30 2009/11/26 21:37:13 nicm Exp $ */
d253 2
a254 4
		else {
			server_redraw_session(s);
			server_status_session_group(s);
		}
@


1.30
log
@Remove a couple of unused arguments where possible, and add /* ARGSUSED */ to
the rest to reduce lint output.
@
text
@d1 1
a1 1
/* $OpenBSD: server-fn.c,v 1.29 2009/11/13 17:33:07 nicm Exp $ */
d64 1
a64 1
	server_update_event(c);	
d211 1
a211 1
	}	
d228 1
a228 1
      
d243 1
a243 1
	
d250 1
a250 1
		
d360 1
a360 1
	
d379 1
a379 1
	
d420 1
a420 1
	event_add(&c->event, NULL);	
@


1.29
log
@Destroy panes immediately rather than checking them all every loop.
@
text
@d1 1
a1 1
/* $OpenBSD: server-fn.c,v 1.28 2009/11/04 23:29:42 nicm Exp $ */
d399 1
@


1.28
log
@Use timeout events for the identify and message timers.
@
text
@d1 1
a1 1
/* $OpenBSD: server-fn.c,v 1.27 2009/11/04 23:12:43 nicm Exp $ */
d317 21
@


1.27
log
@Don't reenlist the client imsg event every loop, instead have a small function
to it and call it after the event triggers or after a imsg is added.
@
text
@d1 1
a1 1
/* $OpenBSD: server-fn.c,v 1.26 2009/10/11 10:39:27 nicm Exp $ */
d27 2
d358 4
a361 4

	if (gettimeofday(&c->identify_timer, NULL) != 0)
		fatal("gettimeofday failed");
	timeradd(&c->identify_timer, &tv, &c->identify_timer);
d376 8
@


1.26
log
@Set the current window pointer to NULL when killing a winlink that is to be
replaced with link-window -k. This prevents it being pushed onto the last
window stack and causing a use-after-free.

Only took me an hour to find this :-/...
@
text
@d1 1
a1 1
/* $OpenBSD: server-fn.c,v 1.25 2009/10/10 10:02:48 nicm Exp $ */
d62 1
d374 15
@


1.25
log
@Add "grouped sessions" which have independent name, options, current window and
so on but where the linked windows are synchronized (ie creating, killing
windows and so on are mirrored between the sessions). A grouped session may be
created by passing -t to new-session.

Had this around for a while, tested by a couple of people.
@
text
@d1 1
a1 1
/* $OpenBSD: server-fn.c,v 1.24 2009/10/04 10:55:30 nicm Exp $ */
d287 1
a287 1
			if (dstwl == dst->curw)
d289 2
@


1.24
log
@Check for already locked/suspended clients in server_lock_client rather than
its callers.
@
text
@d1 1
a1 1
/* $OpenBSD: server-fn.c,v 1.23 2009/09/24 14:17:09 nicm Exp $ */
d108 13
d136 13
d249 2
a250 2
			server_destroy_session(s);
		else
d252 2
d258 2
a259 3
server_link_window(
    struct winlink *srcwl, struct session *dst, int dstidx,
    int killflag, int selectflag, char **cause)
d261 9
a269 1
	struct winlink	*dstwl;
d298 1
a298 3
	if (!selectflag)
		server_status_session(dst);
	else {
d300 1
a300 2
		server_redraw_session(dst);
	}
d309 11
d321 6
a326 2
	else
		server_redraw_session(s);
@


1.23
log
@New lock-client and lock-session commands to lock an individual client or all
clients attached to a session respectively.
@
text
@d1 1
a1 1
/* $OpenBSD: server-fn.c,v 1.22 2009/09/23 06:18:47 nicm Exp $ */
a166 2
		if (c->flags & CLIENT_SUSPENDED)
			continue;
a180 2
		if (c->flags & CLIENT_SUSPENDED)
			continue;
d191 3
@


1.22
log
@Remove the internal tmux locking and instead detach each client and run the
command specified by a new option "lock-command" (by default "lock -np") in
each client.

This means each terminal has to be unlocked individually but simplifies the
code and allows the system password to be used to unlock.

Note that the set-password command is gone, so it will need to be removed from
configuration files, and the -U command line flag has been removed.

This is the third protocol version change so again it is best to stop the tmux
server before upgrading.
@
text
@d1 1
a1 1
/* $OpenBSD: server-fn.c,v 1.21 2009/09/20 17:27:18 nicm Exp $ */
d160 2
a161 4
	struct client		*c;
	const char		*cmd;
	struct msg_lock_data	 lockdata;
	u_int			 i;
d169 3
d173 11
a183 3
		cmd = options_get_string(&c->session->options, "lock-command");
		if (strlcpy(lockdata.cmd, 
		    cmd, sizeof lockdata.cmd) >= sizeof lockdata.cmd)
d185 3
d189 6
a194 3
		tty_stop_tty(&c->tty);
		tty_raw(&c->tty, tty_term_string(c->tty.term, TTYC_SMCUP));
		tty_raw(&c->tty, tty_term_string(c->tty.term, TTYC_CLEAR));
d196 11
a206 3
		c->flags |= CLIENT_SUSPENDED;
		server_write_client(c, MSG_LOCK, &lockdata, sizeof lockdata);
	}
@


1.21
log
@Move some common and untidy code for window link/unlink into generic functions
instead of duplicating it in move/link window..
@
text
@d1 1
a1 1
/* $OpenBSD: server-fn.c,v 1.20 2009/09/20 14:58:12 nicm Exp $ */
a20 2
#include <login_cap.h>
#include <pwd.h>
a26 2
int	server_lock_callback(void *, const char *);

d160 4
a163 13
	struct client	       *c;
	static struct passwd   *pw, pwstore;
	static char		pwbuf[_PW_BUF_LEN];
	u_int			i;

	if (server_locked)
		return;

	if (getpwuid_r(getuid(), &pwstore, pwbuf, sizeof pwbuf, &pw) != 0) {
		server_locked_pw = NULL;
		return;
	}
	server_locked_pw = pw;
d169 1
a169 42

		status_prompt_clear(c);
		status_prompt_set(c,
		    "Password:", server_lock_callback, NULL, c, PROMPT_HIDDEN);
  		server_redraw_client(c);
	}

	server_locked = 1;
}

int
server_lock_callback(unused void *data, const char *s)
{
	return (server_unlock(s));
}

int
server_unlock(const char *s)
{
	struct client	*c;
	login_cap_t	*lc;
	u_int		 i;
	char		*out;
	u_int		 failures, tries, backoff;

	if (!server_locked || server_locked_pw == NULL)
		return (0);
	server_activity = time(NULL);
	if (server_activity < password_backoff)
		return (-2);

	if (server_password != NULL) {
		if (s == NULL)
			return (-1);
		out = crypt(s, server_password);
		if (strcmp(out, server_password) != 0)
			goto wrong;
	}

	for (i = 0; i < ARRAY_LENGTH(&clients); i++) {
		c = ARRAY_ITEM(&clients, i);
		if (c == NULL)
d172 3
a174 16
		status_prompt_clear(c);
  		server_redraw_client(c);
	}

	server_locked = 0;
	password_failures = 0;
	password_backoff = 0;
	return (0);

wrong:
	password_failures++;
	password_backoff = 0;

	for (i = 0; i < ARRAY_LENGTH(&clients); i++) {
		c = ARRAY_ITEM(&clients, i);
		if (c == NULL || c->prompt_buffer == NULL)
d177 3
a179 4
		*c->prompt_buffer = '\0';
		c->prompt_index = 0;
  		server_redraw_client(c);
	}
d181 2
a182 17
	/*
	 * Start slowing down after "login-backoff" attempts and reset every
	 * "login-tries" attempts.
	 */
	lc = login_getclass(server_locked_pw->pw_class);
	if (lc != NULL) {
		tries = login_getcapnum(lc, (char *) "login-tries", 10, 10);
		backoff = login_getcapnum(lc, (char *) "login-backoff", 3, 3);
	} else {
		tries = 10;
		backoff = 3;
	}
	failures = password_failures % tries;
	if (failures > backoff) {
		password_backoff = 
		    server_activity + ((failures - backoff) * tries / 2);
		return (-2);
a183 1
	return (-1);
@


1.20
log
@Regularise some fatal messages.
@
text
@d1 1
a1 1
/* $OpenBSD: server-fn.c,v 1.19 2009/09/12 13:01:19 nicm Exp $ */
d289 53
a341 1
	recalculate_sizes();
@


1.19
log
@Tidy some common code for destroying sessions into a new function.
@
text
@d1 1
a1 1
/* $OpenBSD: server-fn.c,v 1.18 2009/09/05 17:42:16 nicm Exp $ */
d318 1
a318 1
		fatal("gettimeofday");
@


1.18
log
@Only redraw all clients once when the backoff timer expires rather than every
second all the time.

Reported by Simon Nicolussi.
@
text
@d1 1
a1 1
/* $OpenBSD: server-fn.c,v 1.17 2009/09/02 16:38:35 nicm Exp $ */
d275 1
a275 4
	struct client	*c;
	u_int		 i, j;
	int		 destroyed;

d284 4
a287 12
		destroyed = session_detach(s, wl);
		for (j = 0; j < ARRAY_LENGTH(&clients); j++) {
			c = ARRAY_ITEM(&clients, j);
			if (c == NULL || c->session != s)
				continue;
			
			if (destroyed) {
				c->session = NULL;
				server_write_client(c, MSG_EXIT, NULL, 0);
			} else
				server_redraw_client(c);
		}
d290 15
@


1.17
log
@When incorrect passwords are entered, behave similarly to login(1) and backoff
for a bit. Based on a diff from martynas@@.
@
text
@d1 1
a1 1
/* $OpenBSD: server-fn.c,v 1.16 2009/09/01 09:11:05 nicm Exp $ */
a235 1
	password_backoff = server_activity;
d237 1
d263 2
a264 1
		password_backoff += ((failures - backoff) * tries / 2);
@


1.16
log
@Use "Password:" with no space for password prompts and don't display a *s for
the password, like pretty much everything else. From martynas@@ with minor
tweaks by me.
@
text
@d1 1
a1 1
/* $OpenBSD: server-fn.c,v 1.15 2009/08/31 20:46:19 nicm Exp $ */
d21 2
d164 4
a167 2
	struct client	*c;
	u_int		 i;
d172 6
d188 1
d202 1
d205 1
d207 1
a207 1
	if (!server_locked)
d210 2
d232 1
d236 1
d238 1
d249 17
@


1.15
log
@Add a new display-panes command, with two options (display-panes-colour and
display-panes-time), which displays a visual indication of the number of each
pane.
@
text
@d1 1
a1 1
/* $OpenBSD: server-fn.c,v 1.14 2009/08/11 17:18:35 nicm Exp $ */
d175 1
a175 1
		    "Password: ", server_lock_callback, NULL, c, PROMPT_HIDDEN);
@


1.14
log
@Switch tmux to use imsg. This is the last major change to make the
client-server protocol more resilient and make the protocol versioning work
properly. In future, the only things requiring a protocol version bump will be
changes in the message structs, and (when both client and server have this
change) mixing different versions should nicely report an error message.

As a side effect this also makes the code tidier, fixes a problem with the way
errors reported during server startup were handled, and supports fd passing
(which will be used in future).

Looked over by eric@@, thanks.

Please note that mixing a client with this change with an older server or vice
versa may cause tmux to crash or hang - tmux should be completely exited before
upgrading.
@
text
@d1 1
a1 1
/* $OpenBSD: server-fn.c,v 1.13 2009/08/08 21:52:43 nicm Exp $ */
d265 29
@


1.13
log
@Infrastructure and commands to manage the environment for processes started
within tmux.

There is a global environment, copied from the external environment when the
server is started and each sesssion has an (initially empty) session
environment which overrides it.

New commands set-environment and show-environment manipulate or display the
environments.

A new session option, update-environment, is a space-separated list of
variables which are updated from the external environment into the session
environment every time a new session is created - the default is DISPLAY.
@
text
@d1 1
a1 1
/* $OpenBSD: server-fn.c,v 1.12 2009/08/07 15:39:10 nicm Exp $ */
d58 1
a58 1
	struct hdr	 hdr;
d62 2
a63 8
	log_debug("writing %d to client %d", type, c->fd);

	hdr.type = type;
	hdr.size = len;

	buffer_write(c->out, &hdr, sizeof hdr);
	if (buf != NULL && len > 0)
		buffer_write(c->out, buf, len);
@


1.12
log
@If there is an error in the configuration file, don't just exit(1) as this can
cause the client to hang. Instead, send the error message, then mark the client
as bad and start a normal shutdown so the server exits once the error is
written.

This also allows some code duplicating daemon(3) to be trimmed and logging to
begin earlier.

Prompted by Theo noticing the behaviour on error wasn't documented.
@
text
@d1 1
a1 1
/* $OpenBSD: server-fn.c,v 1.11 2009/07/29 14:17:26 nicm Exp $ */
d29 2
a30 2
const char **
server_fill_environ(struct session *s)
d32 2
a33 3
	static const char *env[] = { NULL /* TMUX= */, NULL /* TERM */, NULL };
	static char	tmuxvar[MAXPATHLEN + 256], termvar[256];
	u_int		idx;
a36 1

d38 2
a39 6
	    "TMUX=%s,%ld,%u", socket_path, (long) getpid(), idx);
	env[0] = tmuxvar;

	xsnprintf(termvar, sizeof termvar,
	    "TERM=%s", options_get_string(&s->options, "default-terminal"));
	env[1] = termvar;
d41 2
a42 1
	return (env);
@


1.11
log
@Rename struct hdrtype to msgtype which is a better name and can be used even
when struct hdr disappears.
@
text
@d1 1
a1 1
/* $OpenBSD: server-fn.c,v 1.10 2009/07/26 12:58:44 nicm Exp $ */
d65 2
@


1.10
log
@Make all messages sent between the client and server fixed size.

This is the first of two changes to make the protocol more resilient and less
sensitive to other changes in the code, particularly with commands. The client
now packs argv into a buffer and sends it to the server for parsing, rather
than doing it itself and sending the parsed command data.

As a side-effect this also removes a lot of now-unused command marshalling
code.

Mixing a server without this change and a client with or vice versa will cause
tmux to hang or crash, please ensure that tmux is entirely killed before
upgrading.
@
text
@d1 1
a1 1
/* $OpenBSD: server-fn.c,v 1.9 2009/07/20 14:37:51 nicm Exp $ */
d61 1
a61 1
    struct client *c, enum hdrtype type, const void *buf, size_t len)
d77 1
a77 1
    struct session *s, enum hdrtype type, const void *buf, size_t len)
@


1.9
log
@Display the number of failed password attempts (if any) when the server is
locked. From Tom Doherty.
@
text
@d1 1
a1 1
/* $OpenBSD: server-fn.c,v 1.8 2009/07/17 20:37:03 nicm Exp $ */
d51 9
d232 1
a232 1
                if (c == NULL || c->prompt_buffer == NULL)
@


1.8
log
@Make it so using kill-pane to destroy the last pane in a window destroys the
window instead of being an error.
@
text
@d1 1
a1 1
/* $OpenBSD: server-fn.c,v 1.7 2009/07/17 07:09:46 nicm Exp $ */
d216 1
d220 1
d228 1
a228 1
  		server_status_client(c);
@


1.7
log
@Oops, it is always a good idea to get arguments the right way round.
@
text
@d1 1
a1 1
/* $OpenBSD: server-fn.c,v 1.6 2009/07/17 06:13:27 nicm Exp $ */
d230 33
@


1.6
log
@Memory could be leaked if a second prompt or message appeared while another was
still present, so add a separate prompt free callback and make the _clear
function responsible for calling it if necessary (rather than the individual
prompt callbacks). Also make both messages and prompts clear any existing when
a new is set.

In addition, the screen could be modified while the prompt is there, restore
the redraw-entire-screen behaviour on prompt clear; add a comment as a
reminder.
@
text
@d1 1
a1 1
/* $OpenBSD: server-fn.c,v 1.5 2009/07/14 06:59:06 nicm Exp $ */
d175 1
a175 1
		    "Password: ", server_lock_callback, c, NULL, PROMPT_HIDDEN);
@


1.5
log
@Need time.h not sys/time.h for time(2).
@
text
@d1 1
a1 1
/* $OpenBSD: server-fn.c,v 1.4 2009/07/10 05:50:54 nicm Exp $ */
d174 2
a175 2
		status_prompt_set(
		    c, "Password: ", server_lock_callback, c, PROMPT_HIDDEN);
@


1.4
log
@Add a default-terminal option to set the starting value of $TERM in new
windows.

This is "screen" by default and must be either that or something closely
related. This does makes it easier to customise it if necessary.
@
text
@d1 1
a1 1
/* $OpenBSD: server-fn.c,v 1.3 2009/06/30 13:40:30 nicm Exp $ */
a19 1
#include <sys/time.h>
d22 1
@


1.3
log
@When unlocking the server, don't try to clear the prompt on clients without a
prompt (such as the one issuing the unlock request).

This caused the server to die if the wrong password was entered when unlocking
from the command line with -U (nasty).
@
text
@d1 1
a1 1
/* $OpenBSD: server-fn.c,v 1.2 2009/06/25 06:15:04 nicm Exp $ */
d32 2
a33 2
	static const char *env[] = { NULL /* TMUX= */, "TERM=screen", NULL };
	static char	tmuxvar[MAXPATHLEN + 256];
d42 4
@


1.2
log
@Miscellaneous unused functions, including one which was basically a
duplicate. Found by lint.
@
text
@d1 1
a1 1
/* $OpenBSD: server-fn.c,v 1.1 2009/06/01 22:58:49 nicm Exp $ */
d217 1
a217 1
		if (c == NULL)
@


1.1
log
@Import tmux, a terminal multiplexor allowing (among other things) a single
terminal to be switched between several different windows and programs
displayed on one terminal be detached from one terminal and moved to another.

ok deraadt pirofti
@
text
@d1 1
a1 1
/* $OpenBSD$ */
a73 16
			server_write_client(c, type, buf, len);
	}
}

void
server_write_window(
    struct window *w, enum hdrtype type, const void *buf, size_t len)
{
	struct client	*c;
	u_int		 i;

	for (i = 0; i < ARRAY_LENGTH(&clients); i++) {
		c = ARRAY_ITEM(&clients, i);
		if (c == NULL || c->session == NULL)
			continue;
		if (c->session->curw->window == w)
@

