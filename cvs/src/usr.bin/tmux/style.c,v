head	1.14;
access;
symbols
	OPENBSD_6_1:1.14.0.4
	OPENBSD_6_1_BASE:1.14
	OPENBSD_6_0:1.10.0.2
	OPENBSD_6_0_BASE:1.10
	OPENBSD_5_9:1.9.0.2
	OPENBSD_5_9_BASE:1.9
	OPENBSD_5_8:1.7.0.4
	OPENBSD_5_8_BASE:1.7
	OPENBSD_5_7:1.5.0.2
	OPENBSD_5_7_BASE:1.5
	OPENBSD_5_6:1.3.0.4
	OPENBSD_5_6_BASE:1.3
	OPENBSD_5_5:1.2.0.4
	OPENBSD_5_5_BASE:1.2;
locks; strict;
comment	@ * @;


1.14
date	2017.03.22.07.16.54;	author nicm;	state Exp;
branches;
next	1.13;
commitid	YlKgZy2nlCejSvNQ;

1.13
date	2017.01.15.20.48.41;	author nicm;	state Exp;
branches;
next	1.12;
commitid	osUO2wUOqrqm0Q8V;

1.12
date	2017.01.13.11.58.49;	author nicm;	state Exp;
branches;
next	1.11;
commitid	IPLHEki7vNAmEUCr;

1.11
date	2017.01.12.15.36.35;	author nicm;	state Exp;
branches;
next	1.10;
commitid	TxelVequscBivd6R;

1.10
date	2016.07.15.00.42.56;	author nicm;	state Exp;
branches;
next	1.9;
commitid	EramuEV0ciOaJqkF;

1.9
date	2016.01.19.15.59.12;	author nicm;	state Exp;
branches;
next	1.8;
commitid	P3qmSOx6KrDBsb0c;

1.8
date	2015.09.14.11.34.50;	author nicm;	state Exp;
branches;
next	1.7;
commitid	jBSEJQfSIiCoo49j;

1.7
date	2015.05.07.11.42.56;	author nicm;	state Exp;
branches;
next	1.6;
commitid	aHjVLgOHz1Tie9FQ;

1.6
date	2015.04.15.15.44.40;	author nicm;	state Exp;
branches;
next	1.5;
commitid	7fFwhG8KSwI251R3;

1.5
date	2015.02.18.15.32.37;	author nicm;	state Exp;
branches;
next	1.4;
commitid	tGcD7jUqiAwOVvVF;

1.4
date	2014.10.20.23.27.14;	author nicm;	state Exp;
branches;
next	1.3;
commitid	BAMrPS0saBiCc8HD;

1.3
date	2014.05.08.05.53.29;	author nicm;	state Exp;
branches;
next	1.2;

1.2
date	2014.02.22.01.38.47;	author nicm;	state Exp;
branches;
next	1.1;

1.1
date	2014.01.28.23.07.09;	author nicm;	state Exp;
branches;
next	;


desc
@@


1.14
log
@Add support for the strikethrough attribute (SGR 9), using the new smxx
terminfo capability. This means there are now nine attribute bits, so
anything above 0xff uses an extended cell.
@
text
@/* $OpenBSD: style.c,v 1.13 2017/01/15 20:48:41 nicm Exp $ */

/*
 * Copyright (c) 2007 Nicholas Marriott <nicholas.marriott@@gmail.com>
 * Copyright (c) 2014 Tiago Cunha <tcunha@@users.sourceforge.net>
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF MIND, USE, DATA OR PROFITS, WHETHER
 * IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING
 * OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */

#include <sys/types.h>

#include <string.h>

#include "tmux.h"

/* Parse an embedded style of the form "fg=colour,bg=colour,bright,...". */
int
style_parse(const struct grid_cell *defgc, struct grid_cell *gc,
    const char *in)
{
	struct grid_cell	savedgc;
	const char		delimiters[] = " ,";
	char			tmp[32];
	int			val, fg, bg, attr, flags;
	size_t			end;

	if (*in == '\0')
		return (0);
	if (strchr(delimiters, in[strlen(in) - 1]) != NULL)
		return (-1);
	memcpy(&savedgc, gc, sizeof savedgc);

	fg = gc->fg;
	bg = gc->bg;
	attr = gc->attr;
	flags = gc->flags;
	do {
		end = strcspn(in, delimiters);
		if (end > (sizeof tmp) - 1)
			goto error;
		memcpy(tmp, in, end);
		tmp[end] = '\0';

		if (strcasecmp(tmp, "default") == 0) {
			fg = defgc->fg;
			bg = defgc->bg;
			attr = defgc->attr;
			flags = defgc->flags;
		} else if (end > 3 && strncasecmp(tmp + 1, "g=", 2) == 0) {
			if ((val = colour_fromstring(tmp + 3)) == -1)
				goto error;
			if (*in == 'f' || *in == 'F') {
				if (val != 8)
					fg = val;
				else
					fg = defgc->fg;
			} else if (*in == 'b' || *in == 'B') {
				if (val != 8)
					bg = val;
				else
					bg = defgc->bg;
			} else
				goto error;
		} else if (strcasecmp(tmp, "none") == 0)
			attr = 0;
		else if (end > 2 && strncasecmp(tmp, "no", 2) == 0) {
			if ((val = attributes_fromstring(tmp + 2)) == -1)
				goto error;
			attr &= ~val;
		} else {
			if ((val = attributes_fromstring(tmp)) == -1)
				goto error;
			attr |= val;
		}

		in += end + strspn(in + end, delimiters);
	} while (*in != '\0');
	gc->fg = fg;
	gc->bg = bg;
	gc->attr = attr;
	gc->flags = flags;

	return (0);

error:
	memcpy(gc, &savedgc, sizeof *gc);
	return (-1);
}

/* Convert style to a string. */
const char *
style_tostring(struct grid_cell *gc)
{
	int		 off = 0, comma = 0;
	static char	 s[256];

	*s = '\0';

	if (gc->fg != 8) {
		off += xsnprintf(s, sizeof s, "fg=%s", colour_tostring(gc->fg));
		comma = 1;
	}

	if (gc->bg != 8) {
		off += xsnprintf(s + off, sizeof s - off, "%sbg=%s",
		    comma ? "," : "", colour_tostring(gc->bg));
		comma = 1;
	}

	if (gc->attr != 0 && gc->attr != GRID_ATTR_CHARSET) {
		xsnprintf(s + off, sizeof s - off, "%s%s",
		    comma ? "," : "", attributes_tostring(gc->attr));
	}

	if (*s == '\0')
		return ("default");
	return (s);
}

/* Apply a style. */
void
style_apply(struct grid_cell *gc, struct options *oo, const char *name)
{
	const struct grid_cell	*gcp;

	memcpy(gc, &grid_default_cell, sizeof *gc);
	gcp = options_get_style(oo, name);
	gc->fg = gcp->fg;
	gc->bg = gcp->bg;
	gc->attr |= gcp->attr;
}

/* Apply a style, updating if default. */
void
style_apply_update(struct grid_cell *gc, struct options *oo, const char *name)
{
	const struct grid_cell	*gcp;

	gcp = options_get_style(oo, name);
	if (gcp->fg != 8)
		gc->fg = gcp->fg;
	if (gcp->bg != 8)
		gc->bg = gcp->bg;
	if (gcp->attr != 0)
		gc->attr |= gcp->attr;
}

/* Check if two styles are the same. */
int
style_equal(const struct grid_cell *gc1, const struct grid_cell *gc2)
{
	return (gc1->fg == gc2->fg &&
	    gc1->bg == gc2->bg &&
	    (gc1->flags & ~GRID_FLAG_PADDING) ==
	    (gc2->flags & ~GRID_FLAG_PADDING) &&
	    (gc1->attr & ~GRID_ATTR_CHARSET) ==
	    (gc2->attr & ~GRID_ATTR_CHARSET));
}
@


1.13
log
@Major tidy up and rework of options tree and set-option/show-options
commands this pushes more of the code into options.c and ties it more
closely to the options table rather than having an unnecessary
split. Also add support for array options (will be used later). Only
(intentional) user visible change is that show-options output is now
passed through vis(3) with VIS_DQ so quotes are escaped.
@
text
@d1 1
a1 1
/* $OpenBSD: style.c,v 1.12 2017/01/13 11:58:49 nicm Exp $ */
d34 1
a34 1
	int			val;
a35 2
	int			fg, bg;
	u_char			attr, flags;
@


1.12
log
@options_get_style return const too.
@
text
@d1 1
a1 1
/* $OpenBSD: style.c,v 1.11 2017/01/12 15:36:35 nicm Exp $ */
a129 49
}

/* Synchronize new -style option with the old one. */
void
style_update_new(struct options *oo, const char *name, const char *newname)
{
	int			 value;
	struct grid_cell	*gc;
	struct options_entry	*o;

	/* It's a colour or attribute, but with no -style equivalent. */
	if (newname == NULL)
		return;

	o = options_find1(oo, newname);
	if (o == NULL)
		o = options_set_style(oo, newname, 0, "default");
	gc = &o->style;

	o = options_find1(oo, name);
	if (o == NULL)
		o = options_set_number(oo, name, 8);
	value = o->num;

	if (strstr(name, "-bg") != NULL)
		gc->bg = value;
	else if (strstr(name, "-fg") != NULL)
		gc->fg = value;
	else if (strstr(name, "-attr") != NULL)
		gc->attr = value;
}

/* Synchronize all the old options with the new -style one. */
void
style_update_old(struct options *oo, const char *name, struct grid_cell *gc)
{
	char	newname[128];
	int	size;

	size = strrchr(name, '-') - name;

	xsnprintf(newname, sizeof newname, "%.*s-bg", size, name);
	options_set_number(oo, newname, gc->bg);

	xsnprintf(newname, sizeof newname, "%.*s-fg", size, name);
	options_set_number(oo, newname, gc->fg);

	xsnprintf(newname, sizeof newname, "%.*s-attr", size, name);
	options_set_number(oo, newname, gc->attr);
@


1.11
log
@Simplify appending to string options.
@
text
@d1 1
a1 1
/* $OpenBSD: style.c,v 1.10 2016/07/15 00:42:56 nicm Exp $ */
d185 1
a185 1
	struct grid_cell	*gcp;
d198 1
a198 1
	struct grid_cell	*gcp;
@


1.10
log
@Instead of representing colours in several different forms with various
cell flags, convert to use an int with flags marking 256 or RGB colours
in the top byte (except in cells, which we don't want to make any
bigger). From Brad Town.
@
text
@d1 1
a1 1
/* $OpenBSD: style.c,v 1.9 2016/01/19 15:59:12 nicm Exp $ */
d146 1
a146 1
		o = options_set_style(oo, newname, "default", 0);
@


1.9
log
@I no longer use my SourceForge address so replace it.
@
text
@d1 1
a1 1
/* $OpenBSD: style.c,v 1.8 2015/09/14 11:34:50 nicm Exp $ */
d36 2
a37 1
	u_char			fg, bg, attr, flags;
d60 1
a60 3
			flags &= ~(GRID_FLAG_FG256|GRID_FLAG_BG256);
			flags |=
			    defgc->flags & (GRID_FLAG_FG256|GRID_FLAG_BG256);
d65 1
a65 6
				if (val != 8) {
					if (val & 0x100) {
						flags |= GRID_FLAG_FG256;
						val &= ~0x100;
					} else
						flags &= ~GRID_FLAG_FG256;
d67 1
a67 1
				} else {
a68 3
					flags &= ~GRID_FLAG_FG256;
					flags |= defgc->flags & GRID_FLAG_FG256;
				}
d70 1
a70 6
				if (val != 8) {
					if (val & 0x100) {
						flags |= GRID_FLAG_BG256;
						val &= ~0x100;
					} else
						flags &= ~GRID_FLAG_BG256;
d72 1
a72 1
				} else {
a73 3
					flags &= ~GRID_FLAG_BG256;
					flags |= defgc->flags & GRID_FLAG_BG256;
				}
d106 1
a106 1
	int		 c, off = 0, comma = 0;
d111 2
a112 6
	if (gc->fg != 8 || gc->flags & GRID_FLAG_FG256) {
		if (gc->flags & GRID_FLAG_FG256)
			c = gc->fg | 0x100;
		else
			c = gc->fg;
		off += xsnprintf(s, sizeof s, "fg=%s", colour_tostring(c));
d116 1
a116 5
	if (gc->bg != 8 || gc->flags & GRID_FLAG_BG256) {
		if (gc->flags & GRID_FLAG_BG256)
			c = gc->bg | 0x100;
		else
			c = gc->bg;
d118 1
a118 1
		    comma ? "," : "", colour_tostring(c));
d155 1
a155 1
		colour_set_bg(gc, value);
d157 1
a157 1
		colour_set_fg(gc, value);
d167 1
a167 1
	int	c, size;
a170 4
	if (gc->flags & GRID_FLAG_BG256)
		c = gc->bg | 0x100;
	else
		c = gc->bg;
d172 1
a172 1
	options_set_number(oo, newname, c);
a173 4
	if (gc->flags & GRID_FLAG_FG256)
		c = gc->fg | 0x100;
	else
		c = gc->fg;
d175 1
a175 1
	options_set_number(oo, newname, c);
d189 2
a190 8
	if (gcp->flags & GRID_FLAG_FG256)
		colour_set_fg(gc, gcp->fg | 0x100);
	else
		colour_set_fg(gc, gcp->fg);
	if (gcp->flags & GRID_FLAG_BG256)
		colour_set_bg(gc, gcp->bg | 0x100);
	else
		colour_set_bg(gc, gcp->bg);
d201 4
a204 12
	if (gcp->fg != 8 || gcp->flags & GRID_FLAG_FG256) {
		if (gcp->flags & GRID_FLAG_FG256)
			colour_set_fg(gc, gcp->fg | 0x100);
		else
			colour_set_fg(gc, gcp->fg);
	}
	if (gcp->bg != 8 || gcp->flags & GRID_FLAG_BG256) {
		if (gcp->flags & GRID_FLAG_BG256)
			colour_set_bg(gc, gcp->bg | 0x100);
		else
			colour_set_bg(gc, gcp->bg);
	}
d213 6
a218 6
	return gc1->fg == gc2->fg &&
		gc1->bg == gc2->bg &&
		(gc1->flags & ~GRID_FLAG_PADDING) ==
		(gc2->flags & ~GRID_FLAG_PADDING) &&
		(gc1->attr & ~GRID_ATTR_CHARSET) ==
		(gc2->attr & ~GRID_ATTR_CHARSET);
@


1.8
log
@When the active pane changes, redraw panes if the style has
changed. From Cam Hutchison.
@
text
@d1 1
a1 1
/* $OpenBSD: style.c,v 1.7 2015/05/07 11:42:56 nicm Exp $ */
d4 1
a4 1
 * Copyright (c) 2007 Nicholas Marriott <nicm@@users.sourceforge.net>
@


1.7
log
@Style spacing nits.
@
text
@d1 1
a1 1
/* $OpenBSD: style.c,v 1.6 2015/04/15 15:44:40 nicm Exp $ */
d254 12
@


1.6
log
@Fix setting old-style window -fg/-bg/-attr options that aren't global.
@
text
@d1 1
a1 1
/* $OpenBSD: style.c,v 1.5 2015/02/18 15:32:37 nicm Exp $ */
d171 1
a171 1
		o = options_set_style (oo, newname, "default", 0);
d176 1
a176 1
		o = options_set_number (oo, name, 8);
@


1.5
log
@When given an invalid style, don't set the option to the default. Fix
from J Raynor. Also make style_parse not alter the grid_cell when it
fails.
@
text
@d1 1
a1 1
/* $OpenBSD: style.c,v 1.4 2014/10/20 23:27:14 nicm Exp $ */
d163 1
d169 9
a177 2
	gc = options_get_style(oo, newname);
	value = options_get_number(oo, name);
@


1.4
log
@Tidy up some includes.
@
text
@d1 1
a1 1
/* $OpenBSD: style.c,v 1.3 2014/05/08 05:53:29 nicm Exp $ */
d31 6
a36 5
	const char	delimiters[] = " ,";
	char		tmp[32];
	int		val;
	size_t		end;
	u_char		fg, bg, attr, flags;
d42 1
d51 1
a51 1
			return (-1);
d64 1
a64 1
				return (-1);
d92 1
a92 1
				return (-1);
d97 1
a97 1
				return (-1);
d101 1
a101 1
				return (-1);
d113 4
@


1.3
log
@Handle colour 8 properly in the 256 colour palette, from Timothy Allen.
@
text
@d1 1
a1 1
/* $OpenBSD: style.c,v 1.2 2014/02/22 01:38:47 nicm Exp $ */
d19 2
@


1.2
log
@Fix -fg/-bg/-style with 256 colour terminals.
@
text
@d1 1
a1 1
/* $OpenBSD: style.c,v 1.1 2014/01/28 23:07:09 nicm Exp $ */
d120 1
a120 1
	if (gc->fg != 8) {
d129 1
a129 1
	if (gc->bg != 8) {
d224 1
a224 1
	if (gcp->fg != 8) {
d230 1
a230 1
	if (gcp->bg != 8) {
@


1.1
log
@Allow replacing each of the many sets of separate foo-{fg,bg,attr}
options with a single foo-style option. For example:

    set -g status-fg yellow
    set -g status-bg red
    set -g status-attr blink

Becomes:

    set -g status-style fg=yellow,bg=red,blink

The -a flag to set can be used to add to rather than replace a style. So:

    set -g status-bg red

Becomes:

    set -ag status-style bg=red

Currently this is fully backwards compatible (all *-{fg,bg,attr} options
remain) but the plan is to deprecate them over time.

From Tiago Cunha.
@
text
@d1 1
a1 1
/* $OpenBSD$ */
d206 8
a213 2
	colour_set_fg(gc, gcp->fg);
	colour_set_bg(gc, gcp->bg);
d224 12
a235 4
	if (gcp->fg != 8)
		colour_set_fg(gc, gcp->fg);
	if (gcp->bg != 8)
		colour_set_bg(gc, gcp->bg);
@

