head	1.46;
access;
symbols
	OPENBSD_6_0:1.39.0.2
	OPENBSD_6_0_BASE:1.39
	OPENBSD_5_9:1.37.0.2
	OPENBSD_5_9_BASE:1.37
	OPENBSD_5_8:1.33.0.6
	OPENBSD_5_8_BASE:1.33
	OPENBSD_5_7:1.33.0.2
	OPENBSD_5_7_BASE:1.33
	OPENBSD_5_6:1.27.0.6
	OPENBSD_5_6_BASE:1.27
	OPENBSD_5_5:1.27.0.4
	OPENBSD_5_5_BASE:1.27
	OPENBSD_5_4:1.26.0.2
	OPENBSD_5_4_BASE:1.26
	OPENBSD_5_3:1.24.0.2
	OPENBSD_5_3_BASE:1.24
	OPENBSD_5_2:1.23.0.2
	OPENBSD_5_2_BASE:1.23
	OPENBSD_5_1_BASE:1.21
	OPENBSD_5_1:1.21.0.4
	OPENBSD_5_0:1.21.0.2
	OPENBSD_5_0_BASE:1.21
	OPENBSD_4_9:1.17.0.2
	OPENBSD_4_9_BASE:1.17
	OPENBSD_4_8:1.16.0.2
	OPENBSD_4_8_BASE:1.16
	OPENBSD_4_7:1.14.0.2
	OPENBSD_4_7_BASE:1.14
	OPENBSD_4_6:1.5.0.4
	OPENBSD_4_6_BASE:1.5;
locks; strict;
comment	@ * @;


1.46
date	2017.02.08.16.45.18;	author nicm;	state Exp;
branches;
next	1.45;
commitid	ZNCPaF6tGzHeJGxd;

1.45
date	2016.11.24.13.38.44;	author nicm;	state Exp;
branches;
next	1.44;
commitid	xEmWv4VOf7iteHdC;

1.44
date	2016.10.13.20.27.27;	author nicm;	state Exp;
branches;
next	1.43;
commitid	txCyQ5BkKJtZRzfT;

1.43
date	2016.10.12.13.24.07;	author nicm;	state Exp;
branches;
next	1.42;
commitid	qR81tw3cGEFCEM0c;

1.42
date	2016.10.11.13.21.59;	author nicm;	state Exp;
branches;
next	1.41;
commitid	80rgEIPcNpyBnf95;

1.41
date	2016.10.10.21.29.23;	author nicm;	state Exp;
branches;
next	1.40;
commitid	z4Hr4PZF7Ev93uEJ;

1.40
date	2016.09.02.20.57.20;	author nicm;	state Exp;
branches;
next	1.39;
commitid	KNa3UznuiHkLoVpf;

1.39
date	2016.07.15.00.49.08;	author nicm;	state Exp;
branches;
next	1.38;
commitid	4uHSvNNDvwUmOB9Y;

1.38
date	2016.06.10.11.46.15;	author nicm;	state Exp;
branches;
next	1.37;
commitid	TblPKwjIqwAkkisN;

1.37
date	2016.01.19.15.59.12;	author nicm;	state Exp;
branches;
next	1.36;
commitid	P3qmSOx6KrDBsb0c;

1.36
date	2015.12.28.14.02.52;	author nicm;	state Exp;
branches;
next	1.35;
commitid	DXGWmCt5QwGKppVd;

1.35
date	2015.10.27.09.28.31;	author nicm;	state Exp;
branches;
next	1.34;
commitid	bdxJiCO6ICmMCg1i;

1.34
date	2015.08.28.17.11.12;	author nicm;	state Exp;
branches;
next	1.33;
commitid	ZZR0Fn1BgOb3h3mP;

1.33
date	2015.01.11.04.14.40;	author deraadt;	state Exp;
branches;
next	1.32;
commitid	j8CWcMD2p0OrOH19;

1.32
date	2014.11.06.09.17.25;	author nicm;	state Exp;
branches;
next	1.31;
commitid	CCUZqfCax9h5WQau;

1.31
date	2014.10.20.23.27.14;	author nicm;	state Exp;
branches;
next	1.30;
commitid	BAMrPS0saBiCc8HD;

1.30
date	2014.10.08.17.35.58;	author nicm;	state Exp;
branches;
next	1.29;
commitid	mK8z9uVwDZMfiNoM;

1.29
date	2014.09.01.21.50.18;	author nicm;	state Exp;
branches;
next	1.28;
commitid	yvK8NJvd2XzXhKku;

1.28
date	2014.08.11.22.18.16;	author nicm;	state Exp;
branches;
next	1.27;
commitid	aoiUaOZcuwvS7PHQ;

1.27
date	2014.01.09.14.05.55;	author nicm;	state Exp;
branches;
next	1.26;

1.26
date	2013.05.15.15.39.51;	author nicm;	state Exp;
branches;
next	1.25;

1.25
date	2013.03.21.16.12.10;	author nicm;	state Exp;
branches;
next	1.24;

1.24
date	2013.02.05.11.08.59;	author nicm;	state Exp;
branches;
next	1.23;

1.23
date	2012.07.10.11.53.01;	author nicm;	state Exp;
branches;
next	1.22;

1.22
date	2012.03.17.21.37.36;	author nicm;	state Exp;
branches;
next	1.21;

1.21
date	2011.05.20.19.17.39;	author nicm;	state Exp;
branches;
next	1.20;

1.20
date	2011.05.20.19.03.58;	author nicm;	state Exp;
branches;
next	1.19;

1.19
date	2011.05.04.17.43.35;	author nicm;	state Exp;
branches;
next	1.18;

1.18
date	2011.05.04.17.43.11;	author nicm;	state Exp;
branches;
next	1.17;

1.17
date	2010.12.11.17.56.01;	author nicm;	state Exp;
branches;
next	1.16;

1.16
date	2010.04.06.21.35.44;	author nicm;	state Exp;
branches;
next	1.15;

1.15
date	2010.04.04.23.05.15;	author beck;	state Exp;
branches;
next	1.14;

1.14
date	2010.02.06.17.35.01;	author nicm;	state Exp;
branches;
next	1.13;

1.13
date	2010.01.03.17.12.04;	author nicm;	state Exp;
branches;
next	1.12;

1.12
date	2009.12.03.22.50.10;	author nicm;	state Exp;
branches;
next	1.11;

1.11
date	2009.08.08.13.29.27;	author nicm;	state Exp;
branches;
next	1.10;

1.10
date	2009.07.30.20.41.48;	author nicm;	state Exp;
branches;
next	1.9;

1.9
date	2009.07.17.18.35.11;	author nicm;	state Exp;
branches;
next	1.8;

1.8
date	2009.07.13.10.43.52;	author nicm;	state Exp;
branches;
next	1.7;

1.7
date	2009.07.09.22.48.20;	author nicm;	state Exp;
branches;
next	1.6;

1.6
date	2009.07.08.05.56.11;	author nicm;	state Exp;
branches;
next	1.5;

1.5
date	2009.06.24.22.51.47;	author nicm;	state Exp;
branches;
next	1.4;

1.4
date	2009.06.24.19.12.44;	author nicm;	state Exp;
branches;
next	1.3;

1.3
date	2009.06.04.18.48.24;	author nicm;	state Exp;
branches;
next	1.2;

1.2
date	2009.06.03.19.33.04;	author nicm;	state Exp;
branches;
next	1.1;

1.1
date	2009.06.01.22.58.49;	author nicm;	state Exp;
branches;
next	;


desc
@@


1.46
log
@Collect sequences of printable ASCII characters and process them
together instead of handling them one by one. This is significantly
faster. Sequences are terminated when we reach the end of the line, fill
the internal buffer, or a different character is seen by the input
parser (an escape sequence, or UTF-8).

Rather than writing collected sequences out immediately, hold them until
it is necessary (another screen modification, or we consume all
available data). This means we can discard changes that would have no
effect (for example, lines that would just be scrolled off the screen or
cleared). This reduces the total amount of data we write out to the
terminal - not important for fast terminals, but a big help with slow
(like xterm).
@
text
@/* $OpenBSD: screen.c,v 1.45 2016/11/24 13:38:44 nicm Exp $ */

/*
 * Copyright (c) 2007 Nicholas Marriott <nicholas.marriott@@gmail.com>
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF MIND, USE, DATA OR PROFITS, WHETHER
 * IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING
 * OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */

#include <sys/types.h>

#include <stdlib.h>
#include <string.h>
#include <unistd.h>

#include "tmux.h"

static void	screen_resize_x(struct screen *, u_int);
static void	screen_resize_y(struct screen *, u_int);

static void	screen_reflow(struct screen *, u_int);

/* Create a new screen. */
void
screen_init(struct screen *s, u_int sx, u_int sy, u_int hlimit)
{
	s->grid = grid_create(sx, sy, hlimit);
	s->title = xstrdup("");

	s->cstyle = 0;
	s->ccolour = xstrdup("");
	s->tabs = NULL;

	screen_reinit(s);
}

/* Reinitialise screen. */
void
screen_reinit(struct screen *s)
{
	s->cx = 0;
	s->cy = 0;

	s->rupper = 0;
	s->rlower = screen_size_y(s) - 1;

	s->mode = MODE_CURSOR | MODE_WRAP;

	screen_reset_tabs(s);

	grid_clear_lines(s->grid, s->grid->hsize, s->grid->sy, 8);

	screen_clear_selection(s);
}

/* Destroy a screen. */
void
screen_free(struct screen *s)
{
	free(s->tabs);
	free(s->title);
	free(s->ccolour);
	grid_destroy(s->grid);
}

/* Reset tabs to default, eight spaces apart. */
void
screen_reset_tabs(struct screen *s)
{
	u_int	i;

	free(s->tabs);

	if ((s->tabs = bit_alloc(screen_size_x(s))) == NULL)
		fatal("bit_alloc failed");
	for (i = 8; i < screen_size_x(s); i += 8)
		bit_set(s->tabs, i);
}

/* Set screen cursor style. */
void
screen_set_cursor_style(struct screen *s, u_int style)
{
	if (style <= 6)
		s->cstyle = style;
}

/* Set screen cursor colour. */
void
screen_set_cursor_colour(struct screen *s, const char *colour)
{
	free(s->ccolour);
	s->ccolour = xstrdup(colour);
}

/* Set screen title. */
void
screen_set_title(struct screen *s, const char *title)
{
	free(s->title);
	s->title = xstrdup(title);
}

/* Resize screen. */
void
screen_resize(struct screen *s, u_int sx, u_int sy, int reflow)
{
	if (sx < 1)
		sx = 1;
	if (sy < 1)
		sy = 1;

	if (sx != screen_size_x(s)) {
		screen_resize_x(s, sx);

		/*
		 * It is unclear what should happen to tabs on resize. xterm
		 * seems to try and maintain them, rxvt resets them. Resetting
		 * is simpler and more reliable so let's do that.
		 */
		screen_reset_tabs(s);
	}

	if (sy != screen_size_y(s))
		screen_resize_y(s, sy);

	if (reflow)
		screen_reflow(s, sx);
}

static void
screen_resize_x(struct screen *s, u_int sx)
{
	struct grid		*gd = s->grid;

	if (sx == 0)
		fatalx("zero size");

	/*
	 * Treat resizing horizontally simply: just ensure the cursor is
	 * on-screen and change the size. Don't bother to truncate any lines -
	 * then the data should be accessible if the size is then increased.
	 *
	 * The only potential wrinkle is if UTF-8 double-width characters are
	 * left in the last column, but UTF-8 terminals should deal with this
	 * sanely.
	 */
	if (s->cx >= sx)
		s->cx = sx - 1;
	gd->sx = sx;
}

static void
screen_resize_y(struct screen *s, u_int sy)
{
	struct grid	*gd = s->grid;
	u_int		 needed, available, oldy, i;

	if (sy == 0)
		fatalx("zero size");
	oldy = screen_size_y(s);

	/*
	 * When resizing:
	 *
	 * If the height is decreasing, delete lines from the bottom until
	 * hitting the cursor, then push lines from the top into the history.
	 *
	 * When increasing, pull as many lines as possible from scrolled
	 * history (not explicitly cleared from view) to the top, then fill the
	 * remaining with blanks at the bottom.
	 */

	/* Size decreasing. */
	if (sy < oldy) {
		needed = oldy - sy;

		/* Delete as many lines as possible from the bottom. */
		available = oldy - 1 - s->cy;
		if (available > 0) {
			if (available > needed)
				available = needed;
			grid_view_delete_lines(gd, oldy - available, available,
			    8);
		}
		needed -= available;

		/*
		 * Now just increase the history size, if possible, to take
		 * over the lines which are left. If history is off, delete
		 * lines from the top.
		 */
		available = s->cy;
		if (gd->flags & GRID_HISTORY) {
			gd->hscrolled += needed;
			gd->hsize += needed;
		} else if (needed > 0 && available > 0) {
			if (available > needed)
				available = needed;
			grid_view_delete_lines(gd, 0, available, 8);
		}
		s->cy -= needed;
	}

	/* Resize line arrays. */
	gd->linedata = xreallocarray(gd->linedata, gd->hsize + sy,
	    sizeof *gd->linedata);

	/* Size increasing. */
	if (sy > oldy) {
		needed = sy - oldy;

		/*
		 * Try to pull as much as possible out of scrolled history, if
		 * is is enabled.
		 */
		available = gd->hscrolled;
		if (gd->flags & GRID_HISTORY && available > 0) {
			if (available > needed)
				available = needed;
			gd->hscrolled -= available;
			gd->hsize -= available;
			s->cy += available;
		} else
			available = 0;
		needed -= available;

		/* Then fill the rest in with blanks. */
		for (i = gd->hsize + sy - needed; i < gd->hsize + sy; i++)
			memset(&gd->linedata[i], 0, sizeof gd->linedata[i]);
	}

	/* Set the new size, and reset the scroll region. */
	gd->sy = sy;
	s->rupper = 0;
	s->rlower = screen_size_y(s) - 1;
}

/* Set selection. */
void
screen_set_selection(struct screen *s, u_int sx, u_int sy,
    u_int ex, u_int ey, u_int rectflag, struct grid_cell *gc)
{
	struct screen_sel	*sel = &s->sel;

	memcpy(&sel->cell, gc, sizeof sel->cell);
	sel->flag = 1;
	sel->hidden = 0;

	sel->rectflag = rectflag;

	sel->sx = sx; sel->sy = sy;
	sel->ex = ex; sel->ey = ey;
}

/* Clear selection. */
void
screen_clear_selection(struct screen *s)
{
	struct screen_sel	*sel = &s->sel;

	sel->flag = 0;
	sel->hidden = 0;
	sel->lineflag = LINE_SEL_NONE;
}

/* Hide selection. */
void
screen_hide_selection(struct screen *s)
{
	struct screen_sel	*sel = &s->sel;

	sel->hidden = 1;
}

/* Check if cell in selection. */
int
screen_check_selection(struct screen *s, u_int px, u_int py)
{
	struct screen_sel	*sel = &s->sel;
	u_int			 xx;

	if (!sel->flag || sel->hidden)
		return (0);

	if (sel->rectflag) {
		if (sel->sy < sel->ey) {
			/* start line < end line -- downward selection. */
			if (py < sel->sy || py > sel->ey)
				return (0);
		} else if (sel->sy > sel->ey) {
			/* start line > end line -- upward selection. */
			if (py > sel->sy || py < sel->ey)
				return (0);
		} else {
			/* starting line == ending line. */
			if (py != sel->sy)
				return (0);
		}

		/*
		 * Need to include the selection start row, but not the cursor
		 * row, which means the selection changes depending on which
		 * one is on the left.
		 */
		if (sel->ex < sel->sx) {
			/* Cursor (ex) is on the left. */
			if (px < sel->ex)
				return (0);

			if (px > sel->sx)
				return (0);
		} else {
			/* Selection start (sx) is on the left. */
			if (px < sel->sx)
				return (0);

			if (px > sel->ex)
				return (0);
		}
	} else {
		/*
		 * Like emacs, keep the top-left-most character, and drop the
		 * bottom-right-most, regardless of copy direction.
		 */
		if (sel->sy < sel->ey) {
			/* starting line < ending line -- downward selection. */
			if (py < sel->sy || py > sel->ey)
				return (0);

			if (py == sel->sy && px < sel->sx)
				return (0);

			if (py == sel->ey && px > sel->ex)
				return (0);
		} else if (sel->sy > sel->ey) {
			/* starting line > ending line -- upward selection. */
			if (py > sel->sy || py < sel->ey)
				return (0);

			if (py == sel->ey && px < sel->ex)
				return (0);

			if (sel->modekeys == MODEKEY_EMACS)
				xx = sel->sx - 1;
			else
				xx = sel->sx;
			if (py == sel->sy && (sel->sx == 0 || px > xx))
				return (0);
		} else {
			/* starting line == ending line. */
			if (py != sel->sy)
				return (0);

			if (sel->ex < sel->sx) {
				/* cursor (ex) is on the left */
				if (sel->modekeys == MODEKEY_EMACS)
					xx = sel->sx - 1;
				else
					xx = sel->sx;
				if (px > xx || px < sel->ex)
					return (0);
			} else {
				/* selection start (sx) is on the left */
				if (px < sel->sx || px > sel->ex)
					return (0);
			}
		}
	}

	return (1);
}

/* Get selected grid cell. */
void
screen_select_cell(struct screen *s, struct grid_cell *dst,
    const struct grid_cell *src)
{
	if (!s->sel.flag || s->sel.hidden)
		return;

	memcpy(dst, &s->sel.cell, sizeof *dst);

	utf8_copy(&dst->data, &src->data);
	dst->attr = dst->attr & ~GRID_ATTR_CHARSET;
	dst->attr |= src->attr & GRID_ATTR_CHARSET;
	dst->flags = src->flags;
}

/* Reflow wrapped lines. */
static void
screen_reflow(struct screen *s, u_int new_x)
{
	struct grid	*old = s->grid;
	u_int		 change;

	s->grid = grid_create(old->sx, old->sy, old->hlimit);

	change = grid_reflow(s->grid, old, new_x);
	if (change < s->cy)
		s->cy -= change;
	else
		s->cy = 0;
}
@


1.45
log
@Make the selection able to exist independent of the cursor position, so
that it is not affected by scrolling. If MouseDragEnd1Pane is bound to
the new "stop-selection" command:

    bind -Tcopy-mode MouseDragEnd1Pane stop-selection

A selection made with the mouse will stay as it is after button 1 is
released. (It also works bound to a key.)

From Artem Fokin.
@
text
@d1 1
a1 1
/* $OpenBSD: screen.c,v 1.44 2016/10/13 20:27:27 nicm Exp $ */
a42 3
	s->dirty = NULL;
	s->dirtysize = 0;

a68 1
	free(s->dirty);
d357 1
a357 1
			if (py == sel->sy && px > xx)
@


1.44
log
@Add support for BCE (background colour erase). This makes various escape
sequences (notable EL and ED but also IL, DL, ICH, DCH) create blank
cells using the current background colour rather than the default
colour.

On modern systems BCE doesn't really have many benefits, but most other
terminals now support it, some (lazy) applications rely on it, and it is
not hard to include now that we have pane background colours anyway.

Mostly written by Sean Haugh.
@
text
@d1 1
a1 1
/* $OpenBSD: screen.c,v 1.43 2016/10/12 13:24:07 nicm Exp $ */
d261 2
d276 1
d280 9
d296 1
a296 1
	if (!sel->flag)
d392 1
a392 1
	if (!s->sel.flag)
@


1.43
log
@Redraw selection in tty_draw_line, so it appears when redrawing whole
pane. Reported by Theo Buehler.
@
text
@d1 1
a1 1
/* $OpenBSD: screen.c,v 1.42 2016/10/11 13:21:59 nicm Exp $ */
d63 1
a63 1
	grid_clear_lines(s->grid, s->grid->hsize, s->grid->sy);
d196 2
a197 1
			grid_view_delete_lines(gd, oldy - available, available);
d213 1
a213 1
			grid_view_delete_lines(gd, 0, available);
@


1.42
log
@Add static in window-*.c and move some internal functions out of tmux.h.
@
text
@d1 1
a1 1
/* $OpenBSD: screen.c,v 1.41 2016/10/10 21:29:23 nicm Exp $ */
d372 16
@


1.41
log
@Loads more static, except for cmd-*.c and window-*.c.
@
text
@d1 1
a1 1
/* $OpenBSD: screen.c,v 1.40 2016/09/02 20:57:20 nicm Exp $ */
d30 2
d375 1
a375 1
void
@


1.40
log
@Remember the number of lines scrolled into the history (versus cleared
into the history) and when resizing only use scrolled lines and not
cleared lines (which are probably not intended to reappear). From
Chaoren Lin.
@
text
@d1 1
a1 1
/* $OpenBSD: screen.c,v 1.39 2016/07/15 00:49:08 nicm Exp $ */
d27 2
a28 2
void	screen_resize_x(struct screen *, u_int);
void	screen_resize_y(struct screen *, u_int);
d142 1
a142 1
void
d164 1
a164 1
void
d224 2
a225 2
		 * Try to pull as much as possible out of scrolled history, if is
		 * is enabled.
@


1.39
log
@Don't update cells in each block of data read from a pane immediately,
instead track them as change (dirty) and update them once at the end,
saves much time if repeatedly writing the same cell. Also fix comparison
of cells being equal in a few places (memcmp is not enough).
@
text
@d1 1
a1 1
/* $OpenBSD: screen.c,v 1.38 2016/06/10 11:46:15 nicm Exp $ */
d180 3
a182 2
	 * When increasing, pull as many lines as possible from the history to
	 * the top, then fill the remaining with blanks at the bottom.
d204 2
a205 1
		if (gd->flags & GRID_HISTORY)
d207 1
a207 1
		else if (needed > 0 && available > 0) {
d224 1
a224 1
		 * Try to pull as much as possible out of the history, if is
d227 1
a227 1
		available = gd->hsize;
d231 1
@


1.38
log
@Spelling error (incrased -> increased), from Josh Soref.
@
text
@d1 1
a1 1
/* $OpenBSD: screen.c,v 1.37 2016/01/19 15:59:12 nicm Exp $ */
d41 3
d70 1
@


1.37
log
@I no longer use my SourceForge address so replace it.
@
text
@d1 1
a1 1
/* $OpenBSD: screen.c,v 1.36 2015/12/28 14:02:52 nicm Exp $ */
d149 1
a149 1
	 * then the data should be accessible if the size is then incrased.
@


1.36
log
@Couple of trivial style nits.
@
text
@d1 1
a1 1
/* $OpenBSD: screen.c,v 1.35 2015/10/27 09:28:31 nicm Exp $ */
d4 1
a4 1
 * Copyright (c) 2007 Nicholas Marriott <nicm@@users.sourceforge.net>
@


1.35
log
@Count brackets in #{?...} so that nested conditional formats work, from
Daniel De Graaf.
@
text
@d1 1
a1 1
/* $OpenBSD: screen.c,v 1.34 2015/08/28 17:11:12 nicm Exp $ */
d97 1
a97 1
screen_set_cursor_colour(struct screen *s, const char *colour_string)
d100 1
a100 1
	s->ccolour = xstrdup(colour_string);
@


1.34
log
@Only set default title to hostname on screens that are being used for a
window pane, no point in calling gethostname() for temporary screens.
@
text
@d1 1
a1 1
/* $OpenBSD: screen.c,v 1.33 2015/01/11 04:14:40 deraadt Exp $ */
a196 2
		 *
		 * XXX Should apply history limit?
@


1.33
log
@correctly use HOST_NAME_MAX.

Some notes:
POSIX HOST_NAME_MAX doesn't include the NUL.
POSIX LOGIN_NAME_MAX and TTY_NAME_MAX do include the NUL.

BSD MAXHOSTNAMELEN includes the NUL.  Actually, most of the historical
BSD MAX* defines did include the NUL, except for the historical
mistake of utmp fields without NULs in the string, which directly led
to strncpy..  just showing how error prone this kind of accounting is.
CSRG did right.  Somehow POSIX missed the memo on the concepts of
carefulness and consistancy, and we are still paying the price when
people trip over this.  Of course, glibc is even more amazing (that is
a hint to blackhats)

ok guenther
@
text
@d1 1
a1 1
/* $OpenBSD: screen.c,v 1.32 2014/11/06 09:17:25 nicm Exp $ */
a33 2
	char host[HOST_NAME_MAX+1];

d35 1
a35 5

	if (gethostname(host, sizeof(host)) == 0)
		s->title = xstrdup(host);
	else
		s->title = xstrdup("");
@


1.32
log
@Add V for select line with vi(1) keys. From Juho Pohjala.
@
text
@d1 1
a1 1
/* $OpenBSD: screen.c,v 1.31 2014/10/20 23:27:14 nicm Exp $ */
d34 1
a34 1
	char host[HOST_NAME_MAX];
d38 1
a38 1
	if (gethostname(host, HOST_NAME_MAX) == 0)
@


1.31
log
@Tidy up some includes.
@
text
@d1 1
a1 1
/* $OpenBSD: screen.c,v 1.30 2014/10/08 17:35:58 nicm Exp $ */
d272 1
@


1.30
log
@Add xreallocarray and remove nmemb argument from xrealloc.
@
text
@d1 1
a1 1
/* $OpenBSD: screen.c,v 1.29 2014/09/01 21:50:18 nicm Exp $ */
d34 1
a34 1
	char hn[MAXHOSTNAMELEN];
d38 2
a39 2
	if (gethostname(hn, MAXHOSTNAMELEN) == 0)
		s->title = xstrdup(hn);
@


1.29
log
@Various minor style and spacing nits.
@
text
@d1 1
a1 1
/* $OpenBSD: screen.c,v 1.28 2014/08/11 22:18:16 nicm Exp $ */
d218 2
a219 2
	gd->linedata = xrealloc(
	    gd->linedata, gd->hsize + sy, sizeof *gd->linedata);
@


1.28
log
@Fix two copy mode problems:

1. In vi mode the selection doesn't include the last character if you
   moved the cursor up or left.
2. In emacs mode the selection includes the last character if you moved
   the cursor to the left.

From Balazs Kezes.
@
text
@d1 1
a1 1
/* $OpenBSD: screen.c,v 1.27 2014/01/09 14:05:55 nicm Exp $ */
d330 1
a330 1
				return 0;
@


1.27
log
@Three small changes from Tiago Cunha:

- Check for truncation when copying path.
- Don't need to use a temporary buffer in screen_set_title.
- Include strerror in output when connecting to server fails.
@
text
@d1 1
a1 1
/* $OpenBSD: screen.c,v 1.26 2013/05/15 15:39:51 nicm Exp $ */
d279 1
d329 4
a332 2
			if ((py == sel->sy && px < sel->sx)
			    || (py == sel->ey && px > sel->ex))
d339 8
a346 2
			if ((py == sel->sy && px >= sel->sx)
			    || (py == sel->ey && px < sel->ex))
d355 5
a359 1
				if (px > sel->sx || px < sel->ex)
@


1.26
log
@Don't let cursor position overflow when reflowing, from Christopher
Collins.
@
text
@d1 1
a1 1
/* $OpenBSD: screen.c,v 1.25 2013/03/21 16:12:10 nicm Exp $ */
a112 4
	char	tmp[BUFSIZ];

	strlcpy(tmp, title, sizeof tmp);

d114 1
a114 1
	s->title = xstrdup(tmp);
@


1.25
log
@Rework reflow code so it does not do so much allocation which should be
faster with large histories.
@
text
@d1 1
a1 1
/* $OpenBSD: screen.c,v 1.24 2013/02/05 11:08:59 nicm Exp $ */
d368 1
d371 6
a376 1
	s->cy -= grid_reflow(s->grid, old, new_x);
@


1.24
log
@Automatically reflow wrapped lines when a pane is resized, requested by
many over the years and finally implemented by Richard Woodbury.
@
text
@d1 1
a1 1
/* $OpenBSD: screen.c,v 1.23 2012/07/10 11:53:01 nicm Exp $ */
d365 1
a365 1
screen_reflow(struct screen *s, u_int sx)
d367 1
a367 1
	struct grid	*old, *new;
d369 2
a370 7
	old = s->grid;
	new = grid_create(old->sx, old->sy, old->hlimit);

	s->cy -= grid_reflow(new, old, sx);
	s->grid = new;

	grid_destroy(old);
@


1.23
log
@xfree is not particularly helpful, remove it. From Thomas Adam.
@
text
@d1 1
a1 1
/* $OpenBSD: screen.c,v 1.22 2012/03/17 21:37:36 nicm Exp $ */
d123 1
a123 1
screen_resize(struct screen *s, u_int sx, u_int sy)
d143 3
d361 15
@


1.22
log
@Michael Krysiak points out that some terminals (eg mintty) have cursor
styles 5 and 6 too, so allow them to be set.
@
text
@d1 1
a1 1
/* $OpenBSD: screen.c,v 1.21 2011/05/20 19:17:39 nicm Exp $ */
d73 3
a75 4
	if (s->tabs != NULL)
		xfree(s->tabs);
	xfree(s->title);
	xfree(s->ccolour);
d85 1
a85 2
	if (s->tabs != NULL)
		xfree(s->tabs);
d105 1
a105 1
	xfree(s->ccolour);
d117 1
a117 1
	xfree(s->title);
@


1.21
log
@Support DECSCUSR sequence to set the cursor style with two new
terminfo(5) extensions, Cs and Csr. Written by Ailin Nemui.
@
text
@d1 1
a1 1
/* $OpenBSD: screen.c,v 1.20 2011/05/20 19:03:58 nicm Exp $ */
d99 1
a99 1
	if (style <= 4)
@


1.20
log
@Support xterm(1) cursor colour change sequences through terminfo(5) Cc
(set) and Cr (reset) extensions. Originally by Sean Estabrooks, tweaked
by me and Ailin Nemui.
@
text
@d1 1
a1 1
/* $OpenBSD: screen.c,v 1.19 2011/05/04 17:43:35 nicm Exp $ */
d43 1
d93 8
@


1.19
log
@Don't need vis.h anymore.
@
text
@d1 1
a1 1
/* $OpenBSD: screen.c,v 1.18 2011/05/04 17:43:11 nicm Exp $ */
d43 1
d75 1
d92 8
@


1.18
log
@Don't use strnvis for the title as it breaks UTF-8. set-titles is now
off by default and we have to trust the terminal can understand what we
send it anyway so there isn't any harm.
@
text
@d1 1
a1 1
/* $OpenBSD: screen.c,v 1.17 2010/12/11 17:56:01 nicm Exp $ */
a23 1
#include <vis.h>
@


1.17
log
@Fix rectangle copy to behave like emacs - the cursor is not part of the
selection on the right edge but on the left it is.
@
text
@d1 1
a1 1
/* $OpenBSD: screen.c,v 1.16 2010/04/06 21:35:44 nicm Exp $ */
d99 1
a99 1
	strnvis(tmp, title, sizeof tmp, VIS_OCTAL|VIS_TAB|VIS_NL);
@


1.16
log
@Merge copy mode and output mode, dropping the latter. Idea and code from
Micah Cowan.
@
text
@d1 1
a1 1
/* $OpenBSD: screen.c,v 1.15 2010/04/04 23:05:15 beck Exp $ */
d290 1
a290 1
			if (px <= sel->ex)
d300 1
a300 1
			if (px >= sel->ex)
@


1.15
log
@rather than using an empty "" as the default window title, put the hostname
of the machine we are running on in there.

makes my many green lines easier to deal with without using fiddly options to
set it.

ok nicm@@
@
text
@d1 1
a1 1
/* $OpenBSD: screen.c,v 1.14 2010/02/06 17:35:01 nicm Exp $ */
d23 1
d59 1
a59 1
	s->mode = MODE_CURSOR;
@


1.14
log
@Rectangle copy support, from Robin Lee Powell.
@
text
@d1 1
a1 1
/* $OpenBSD: screen.c,v 1.13 2010/01/03 17:12:04 nicm Exp $ */
d34 2
d38 4
a41 1
	s->title = xstrdup("");
@


1.13
log
@Fix selection behaviour when the cursor is moved backwards (ie so the selection
start is after the end).
@
text
@d1 1
a1 1
/* $OpenBSD: screen.c,v 1.12 2009/12/03 22:50:10 nicm Exp $ */
d231 2
a232 2
screen_set_selection(struct screen *s,
    u_int sx, u_int sy, u_int ex, u_int ey, struct grid_cell *gc)
d238 1
d240 2
a241 27
	/* starting line < ending line -- downward selection. */
	if (sy < ey) {
		sel->sx = sx; sel->sy = sy;
		sel->ex = ex; sel->ey = ey;
		return;
	}

	/* starting line > ending line -- upward selection. */
	if (sy > ey) {
		if (sx > 0) {
			sel->sx = ex; sel->sy = ey;
			sel->ex = sx - 1; sel->ey = sy;
		} else {
			sel->sx = ex; sel->sy = ey;
			sel->ex = -1; sel->ey = sy - 1;
		}
		return;
	}

	/* starting line == ending line. */
	if (ex < sx) {
		sel->sx = ex; sel->sy = ey;
		sel->ex = sx - 1; sel->ey = sy;
	} else {
		sel->sx = sx; sel->sy = sy;
		sel->ex = ex; sel->ey = ey;
	}
d259 1
a259 1
	if (!sel->flag || py < sel->sy || py > sel->ey)
d262 71
a332 4
	if (py == sel->sy && py == sel->ey) {
		if (px < sel->sx || px > sel->ex)
			return (0);
		return (1);
a334 2
	if ((py == sel->sy && px < sel->sx) || (py == sel->ey && px > sel->ex))
		return (0);
@


1.12
log
@Massive spaces->tabs and trailing whitespace cleanup, hopefully for the last
time now I've configured emacs to make them displayed in really annoying
colours...
@
text
@d1 1
a1 1
/* $OpenBSD: screen.c,v 1.11 2009/08/08 13:29:27 nicm Exp $ */
d237 8
d246 14
a259 2
	sel->flag = 1;
	if (ey < sy || (sy == ey && ex < sx)) {
d261 1
a261 1
		sel->ex = sx; sel->ey = sy;
@


1.11
log
@Change the way the grid is stored, previously it was:

- a two-dimensional array of cells;
- a two-dimensional array of utf8 data;
- an array of line lengths.

Now it is a single array of a new struct grid_line each of which represents a
line and containts the length and an array of cells and an array of utf8 data.

This will make it easier to add additional per-line members, such as flags.
@
text
@d1 1
a1 1
/* $OpenBSD: screen.c,v 1.10 2009/07/30 20:41:48 nicm Exp $ */
d54 1
a54 1
	
d155 1
a155 1
	/* 
d160 1
a160 1
	 * 
d194 1
a194 1
 	}
@


1.10
log
@Plug some memory leaks.
@
text
@d1 1
a1 1
/* $OpenBSD: screen.c,v 1.9 2009/07/17 18:35:11 nicm Exp $ */
d197 2
a198 4
	gd->size = xrealloc(gd->size, gd->hsize + sy, sizeof *gd->size);
	gd->data = xrealloc(gd->data, gd->hsize + sy, sizeof *gd->data);
	gd->usize = xrealloc(gd->usize, gd->hsize + sy, sizeof *gd->usize);
	gd->udata = xrealloc(gd->udata, gd->hsize + sy, sizeof *gd->udata);
d219 2
a220 6
		for (i = gd->hsize + sy - needed; i < gd->hsize + sy; i++) {
			gd->size[i] = 0;
			gd->data[i] = NULL;
			gd->usize[i] = 0;
			gd->udata[i] = NULL;
		}
@


1.9
log
@When resizing a screen smaller in alternate screen mode, all the lines needed
could be consumed by deleting from the bottom, leaving none to be removed from
the top. In this case, don't call grid_view_delete_lines with ny of 0 as this
is incorrect and causes a bounds check to fatal error if built with -DDEBUG.
@
text
@d1 1
a1 1
/* $OpenBSD: screen.c,v 1.8 2009/07/13 10:43:52 nicm Exp $ */
d66 2
@


1.8
log
@Support "alternate screen" mode (terminfo smcup/rmcup) typically used by full
screen interactive programs to preserve the screen contents. When activated, it
saves a copy of the visible grid and disables scrolling into and resizing out
of the history; when deactivated the visible data is restored and the history
reenabled.
@
text
@d1 1
a1 1
/* $OpenBSD: screen.c,v 1.7 2009/07/09 22:48:20 nicm Exp $ */
d186 1
a186 1
		else if (available > 0) {
@


1.7
log
@When the terminal size is reduced horizontally, don't truncate lines to the new
width, so that if the same lines are later increased in size the content
reappears.
@
text
@d1 1
a1 1
/* $OpenBSD: screen.c,v 1.6 2009/07/08 05:56:11 nicm Exp $ */
d177 5
a181 2
		 * Now just increase the history size to take over the lines
		 * which are left. XXX Should apply history limit?
d183 8
a190 1
		gd->hsize += needed;
d204 4
a207 1
		/* Try to pull as much as possible out of the history. */
d209 1
a209 1
		if (available > 0) {
d214 2
a215 1
		}
@


1.6
log
@When reinitialising the screen, do not omit to clear the last line.
@
text
@d1 1
a1 1
/* $OpenBSD: screen.c,v 1.5 2009/06/24 22:51:47 nicm Exp $ */
a124 3
	const struct grid_cell	*gc;
	const struct grid_utf8	*gu;
	u_int			 xx, yy;
d129 9
a137 31
	/* If getting larger, not much to do. */
	if (sx > screen_size_x(s)) {
		gd->sx = sx;
		return;
	}

	/* If getting smaller, nuke any data in lines over the new size. */
	for (yy = gd->hsize; yy < gd->hsize + screen_size_y(s); yy++) {
		/*
		 * If the character after the last is wide or padding, remove
		 * it and any leading padding.
		 */
		gc = &grid_default_cell;
		for (xx = sx; xx > 0; xx--) {
			gc = grid_peek_cell(gd, xx - 1, yy);
			if (!(gc->flags & GRID_FLAG_PADDING))
				break;
			grid_set_cell(gd, xx - 1, yy, &grid_default_cell);
		}
		if (xx > 0 && xx != sx && gc->flags & GRID_FLAG_UTF8) {
			gu = grid_peek_utf8(gd, xx - 1, yy);
			if (gu->width > 1) {
				grid_set_cell(
				    gd, xx - 1, yy, &grid_default_cell);
			}
		}

		/* Reduce the line size. */
		grid_reduce_line(gd, yy, sx);
	}

@


1.5
log
@Fix a type mismatch warning in assignment.
@
text
@d1 1
a1 1
/* $OpenBSD: screen.c,v 1.4 2009/06/24 19:12:44 nicm Exp $ */
d57 1
a57 1
	grid_clear_lines(s->grid, s->grid->hsize, s->grid->sy - 1);
@


1.4
log
@Change to match xterm's resizing behaviour, including pushing lines into the
history from the top when reducing vertical size and pulling them again when
increasing size.

ok todd sthen
@
text
@d1 1
a1 1
/* $OpenBSD: screen.c,v 1.3 2009/06/04 18:48:24 nicm Exp $ */
d231 4
a234 2
			gd->size[i] = gd->usize[i] = 0;
			gd->data[i] = gd->udata[i] = NULL;
@


1.3
log
@Proper support for tab stops (\033H etc), using a bitstring(3). Makes another
vttest test happy.
@
text
@d1 1
a1 1
/* $OpenBSD: screen.c,v 1.2 2009/06/03 19:33:04 nicm Exp $ */
d172 1
a172 1
	u_int		 oy, yy, ny;
d176 11
d189 2
a190 14
	if (sy < screen_size_y(s)) {
		oy = screen_size_y(s);

		if (s->cy != 0) {
			/*
			 * The cursor is not at the start. Try to remove as
			 * many lines as possible from the top. (Up to the
			 * cursor line.)
			 */
			ny = s->cy;
			if (ny > oy - sy)
				ny = oy - sy;

			grid_view_delete_lines(gd, 0, ny);
d192 6
a197 2
 			s->cy -= ny;
			oy -= ny;
d199 1
d201 7
a207 7
		if (sy < oy) {
			/* Remove any remaining lines from the bottom. */
			grid_view_delete_lines(gd, sy, oy - sy);
			if (s->cy >= sy)
				s->cy = sy - 1;
		}
	}
d216 17
a232 7
	if (sy > screen_size_y(s)) {
		oy = screen_size_y(s);
		for (yy = gd->hsize + oy; yy < gd->hsize + sy; yy++) {
			gd->size[yy] = 0;
			gd->data[yy] = NULL;
			gd->usize[yy] = 0;
			gd->udata[yy] = NULL;
d236 1
a237 1

@


1.2
log
@Pass window titles through vis(1). <0x20 is dropped anyway by the input state
machine but top-bit-set nonprintables could cause trouble, and they are neater
like this anyway.

Suggested by deraadt a few days ago.
@
text
@d1 1
a1 1
/* $OpenBSD: screen.c,v 1.1 2009/06/01 22:58:49 nicm Exp $ */
d21 1
d38 2
d54 2
d70 15
d106 1
a106 1
	if (sx != screen_size_x(s))
d108 9
@


1.1
log
@Import tmux, a terminal multiplexor allowing (among other things) a single
terminal to be switched between several different windows and programs
displayed on one terminal be detached from one terminal and moved to another.

ok deraadt pirofti
@
text
@d1 1
a1 1
/* $OpenBSD$ */
d22 1
d69 4
d74 1
a74 1
	s->title = xstrdup(title);
@

