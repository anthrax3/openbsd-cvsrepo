head	1.165;
access;
symbols
	OPENBSD_6_1:1.162.0.4
	OPENBSD_6_1_BASE:1.162
	OPENBSD_6_0:1.149.0.2
	OPENBSD_6_0_BASE:1.149
	OPENBSD_5_9:1.148.0.2
	OPENBSD_5_9_BASE:1.148
	OPENBSD_5_8:1.132.0.4
	OPENBSD_5_8_BASE:1.132
	OPENBSD_5_7:1.124.0.2
	OPENBSD_5_7_BASE:1.124
	OPENBSD_5_6:1.114.0.4
	OPENBSD_5_6_BASE:1.114
	OPENBSD_5_5:1.110.0.4
	OPENBSD_5_5_BASE:1.110
	OPENBSD_5_4:1.107.0.2
	OPENBSD_5_4_BASE:1.107
	OPENBSD_5_3:1.95.0.2
	OPENBSD_5_3_BASE:1.95
	OPENBSD_5_2:1.94.0.2
	OPENBSD_5_2_BASE:1.94
	OPENBSD_5_1_BASE:1.87
	OPENBSD_5_1:1.87.0.2
	OPENBSD_5_0:1.77.0.2
	OPENBSD_5_0_BASE:1.77
	OPENBSD_4_9:1.71.0.2
	OPENBSD_4_9_BASE:1.71
	OPENBSD_4_8:1.63.0.2
	OPENBSD_4_8_BASE:1.63
	OPENBSD_4_7:1.58.0.2
	OPENBSD_4_7_BASE:1.58
	OPENBSD_4_6:1.5.0.4
	OPENBSD_4_6_BASE:1.5;
locks; strict;
comment	@ * @;


1.165
date	2017.05.03.05.53.34;	author nicm;	state Exp;
branches;
next	1.164;
commitid	koR7M5sfoImvwKg7;

1.164
date	2017.05.01.12.20.55;	author nicm;	state Exp;
branches;
next	1.163;
commitid	sAXCoXWmq7A1UnAP;

1.163
date	2017.04.22.12.55.06;	author nicm;	state Exp;
branches;
next	1.162;
commitid	OOYv4gToHhYNwR41;

1.162
date	2017.02.09.12.09.33;	author nicm;	state Exp;
branches;
next	1.161;
commitid	R14ylgibGw7VkoGU;

1.161
date	2017.02.03.21.01.02;	author nicm;	state Exp;
branches;
next	1.160;
commitid	MRFqlgnbMk0ZRnKS;

1.160
date	2017.02.03.11.57.27;	author nicm;	state Exp;
branches;
next	1.159;
commitid	BLRh0qXo7OVTPhiT;

1.159
date	2017.01.13.11.56.43;	author nicm;	state Exp;
branches;
next	1.158;
commitid	ue6KcgTetKiECTMk;

1.158
date	2017.01.06.11.57.03;	author nicm;	state Exp;
branches;
next	1.157;
commitid	m6HBAjiRCa66sywZ;

1.157
date	2017.01.05.09.07.16;	author nicm;	state Exp;
branches;
next	1.156;
commitid	al9tcSDvFKlm4Qpq;

1.156
date	2016.12.07.23.03.04;	author nicm;	state Exp;
branches;
next	1.155;
commitid	cv5FumdZxsajckL9;

1.155
date	2016.10.12.14.50.14;	author nicm;	state Exp;
branches;
next	1.154;
commitid	2r95FFcJGHvdfgBR;

1.154
date	2016.10.12.13.03.27;	author nicm;	state Exp;
branches;
next	1.153;
commitid	eul7q5vzLp6bFmDk;

1.153
date	2016.10.11.07.23.34;	author nicm;	state Exp;
branches;
next	1.152;
commitid	leUN1UeapgUoieJj;

1.152
date	2016.10.11.07.11.40;	author nicm;	state Exp;
branches;
next	1.151;
commitid	RhjRBUnJaRXbs4fU;

1.151
date	2016.10.10.21.29.23;	author nicm;	state Exp;
branches;
next	1.150;
commitid	z4Hr4PZF7Ev93uEJ;

1.150
date	2016.09.12.15.40.58;	author nicm;	state Exp;
branches;
next	1.149;
commitid	FmdCsJJj2mhuDrZn;

1.149
date	2016.06.06.07.23.36;	author nicm;	state Exp;
branches;
next	1.148;
commitid	bvdc21LgUX4ahocw;

1.148
date	2016.01.19.15.59.12;	author nicm;	state Exp;
branches;
next	1.147;
commitid	P3qmSOx6KrDBsb0c;

1.147
date	2016.01.01.08.04.20;	author nicm;	state Exp;
branches;
next	1.146;
commitid	bUp8Y66KfWdfVDqH;

1.146
date	2015.12.11.16.37.21;	author nicm;	state Exp;
branches;
next	1.145;
commitid	pfV7j8HdB7hdHnZm;

1.145
date	2015.12.11.12.27.36;	author nicm;	state Exp;
branches;
next	1.144;
commitid	ns7JfXpW9TsHrnT3;

1.144
date	2015.12.08.08.34.18;	author nicm;	state Exp;
branches;
next	1.143;
commitid	MRfGAYPLeVqV46rT;

1.143
date	2015.11.22.18.28.01;	author tim;	state Exp;
branches;
next	1.142;
commitid	LIvsufdSwNJM2Y5g;

1.142
date	2015.11.20.12.01.19;	author nicm;	state Exp;
branches;
next	1.141;
commitid	qNEZpcD0RcTrAsAp;

1.141
date	2015.11.18.14.27.44;	author nicm;	state Exp;
branches;
next	1.140;
commitid	RjsAPRkWwvS79w40;

1.140
date	2015.11.13.08.09.28;	author nicm;	state Exp;
branches;
next	1.139;
commitid	3vFd8TIqn7NVGuk0;

1.139
date	2015.11.12.11.09.11;	author nicm;	state Exp;
branches;
next	1.138;
commitid	tEN3cHiOuN3KscbT;

1.138
date	2015.11.12.11.05.34;	author nicm;	state Exp;
branches;
next	1.137;
commitid	Ih1tdqtjpnEyfE8x;

1.137
date	2015.10.27.15.58.42;	author nicm;	state Exp;
branches;
next	1.136;
commitid	89xhQafU35Q5MQVC;

1.136
date	2015.10.20.21.12.09;	author nicm;	state Exp;
branches;
next	1.135;
commitid	fVAT1gEydaesyRmS;

1.135
date	2015.09.14.10.25.52;	author nicm;	state Exp;
branches;
next	1.134;
commitid	UTR5DL8aBfSehB3O;

1.134
date	2015.08.29.09.25.00;	author nicm;	state Exp;
branches;
next	1.133;
commitid	UXoQGD7QOZAJI1XC;

1.133
date	2015.08.28.12.16.28;	author nicm;	state Exp;
branches;
next	1.132;
commitid	LqkiQ6rY2EYTPxv3;

1.132
date	2015.07.29.11.56.02;	author nicm;	state Exp;
branches;
next	1.131;
commitid	47sVTxMc5nNTsinQ;

1.131
date	2015.07.28.15.18.10;	author nicm;	state Exp;
branches;
next	1.130;
commitid	TNUQ68WbdVxASnmd;

1.130
date	2015.07.20.15.50.04;	author nicm;	state Exp;
branches;
next	1.129;
commitid	XjcnBmI1AcHx5t2a;

1.129
date	2015.05.27.13.28.04;	author nicm;	state Exp;
branches;
next	1.128;
commitid	jNiCCHdN1zYsiWiL;

1.128
date	2015.05.06.23.56.46;	author nicm;	state Exp;
branches;
next	1.127;
commitid	ABy4BhUuTJpRxEfH;

1.127
date	2015.04.25.18.33.59;	author nicm;	state Exp;
branches;
next	1.126;
commitid	R776bB84r7VPzyws;

1.126
date	2015.04.24.22.19.36;	author nicm;	state Exp;
branches;
next	1.125;
commitid	h1lxJjTgcLGsGtE8;

1.125
date	2015.04.19.21.34.21;	author nicm;	state Exp;
branches;
next	1.124;
commitid	wug6ctIOfhVMeWQp;

1.124
date	2015.02.06.23.28.52;	author nicm;	state Exp;
branches;
next	1.123;
commitid	Q0WFia1zGeTlKDW9;

1.123
date	2015.02.06.17.21.08;	author nicm;	state Exp;
branches;
next	1.122;
commitid	ycB52gvvJRKxbdB6;

1.122
date	2015.02.06.17.11.39;	author nicm;	state Exp;
branches;
next	1.121;
commitid	524Kssnx5Ady6qyZ;

1.121
date	2015.02.05.10.29.43;	author nicm;	state Exp;
branches;
next	1.120;
commitid	b1G1TVWY7l4KyoY6;

1.120
date	2015.02.01.23.43.23;	author nicm;	state Exp;
branches;
next	1.119;
commitid	dy3XCJyolFNoNYim;

1.119
date	2015.01.20.10.57.10;	author sthen;	state Exp;
branches;
next	1.118;
commitid	C7ITYAyXmctmhYR6;

1.118
date	2014.11.05.23.15.11;	author nicm;	state Exp;
branches;
next	1.117;
commitid	mPOFk7MKvspTVFch;

1.117
date	2014.10.20.23.57.14;	author nicm;	state Exp;
branches;
next	1.116;
commitid	PTykIJGtZncJPE4a;

1.116
date	2014.10.08.17.35.58;	author nicm;	state Exp;
branches;
next	1.115;
commitid	mK8z9uVwDZMfiNoM;

1.115
date	2014.10.02.10.39.43;	author nicm;	state Exp;
branches;
next	1.114;
commitid	zFk4cykZddCubqSz;

1.114
date	2014.04.24.09.14.43;	author nicm;	state Exp;
branches;
next	1.113;

1.113
date	2014.04.17.07.36.45;	author nicm;	state Exp;
branches;
next	1.112;

1.112
date	2014.04.02.17.08.23;	author nicm;	state Exp;
branches;
next	1.111;

1.111
date	2014.03.31.21.41.35;	author nicm;	state Exp;
branches;
next	1.110;

1.110
date	2014.02.14.13.59.01;	author nicm;	state Exp;
branches;
next	1.109;

1.109
date	2014.02.14.12.37.54;	author nicm;	state Exp;
branches;
next	1.108;

1.108
date	2014.01.28.23.07.09;	author nicm;	state Exp;
branches;
next	1.107;

1.107
date	2013.07.05.14.44.06;	author nicm;	state Exp;
branches;
next	1.106;

1.106
date	2013.07.05.14.41.36;	author nicm;	state Exp;
branches;
next	1.105;

1.105
date	2013.07.05.14.38.22;	author nicm;	state Exp;
branches;
next	1.104;

1.104
date	2013.05.31.19.56.05;	author nicm;	state Exp;
branches;
next	1.103;

1.103
date	2013.03.25.11.43.01;	author nicm;	state Exp;
branches;
next	1.102;

1.102
date	2013.03.22.15.55.22;	author nicm;	state Exp;
branches;
next	1.101;

1.101
date	2013.03.22.15.52.40;	author nicm;	state Exp;
branches;
next	1.100;

1.100
date	2013.03.22.10.31.22;	author nicm;	state Exp;
branches;
next	1.99;

1.99
date	2013.03.21.16.25.08;	author nicm;	state Exp;
branches;
next	1.98;

1.98
date	2013.03.21.16.24.03;	author nicm;	state Exp;
branches;
next	1.97;

1.97
date	2013.03.21.16.14.09;	author nicm;	state Exp;
branches;
next	1.96;

1.96
date	2013.03.21.16.13.24;	author nicm;	state Exp;
branches;
next	1.95;

1.95
date	2012.11.27.13.52.23;	author nicm;	state Exp;
branches;
next	1.94;

1.94
date	2012.07.10.11.53.01;	author nicm;	state Exp;
branches;
next	1.93;

1.93
date	2012.07.09.09.55.57;	author nicm;	state Exp;
branches;
next	1.92;

1.92
date	2012.04.29.07.33.41;	author nicm;	state Exp;
branches;
next	1.91;

1.91
date	2012.04.23.22.23.14;	author nicm;	state Exp;
branches;
next	1.90;

1.90
date	2012.03.17.18.24.07;	author nicm;	state Exp;
branches;
next	1.89;

1.89
date	2012.03.04.07.38.11;	author nicm;	state Exp;
branches;
next	1.88;

1.88
date	2012.03.03.08.55.56;	author nicm;	state Exp;
branches;
next	1.87;

1.87
date	2012.01.29.09.37.02;	author nicm;	state Exp;
branches;
next	1.86;

1.86
date	2012.01.26.09.05.54;	author nicm;	state Exp;
branches;
next	1.85;

1.85
date	2012.01.26.09.03.09;	author nicm;	state Exp;
branches;
next	1.84;

1.84
date	2012.01.20.19.51.28;	author nicm;	state Exp;
branches;
next	1.83;

1.83
date	2012.01.20.19.10.29;	author nicm;	state Exp;
branches;
next	1.82;

1.82
date	2011.12.01.20.42.31;	author nicm;	state Exp;
branches;
next	1.81;

1.81
date	2011.11.15.23.34.12;	author nicm;	state Exp;
branches;
next	1.80;

1.80
date	2011.11.15.23.19.51;	author nicm;	state Exp;
branches;
next	1.79;

1.79
date	2011.11.05.09.06.31;	author nicm;	state Exp;
branches;
next	1.78;

1.78
date	2011.08.20.20.37.31;	author nicm;	state Exp;
branches;
next	1.77;

1.77
date	2011.07.08.06.37.57;	author nicm;	state Exp;
branches;
next	1.76;

1.76
date	2011.07.02.21.05.44;	author nicm;	state Exp;
branches;
next	1.75;

1.75
date	2011.04.29.07.07.31;	author nicm;	state Exp;
branches;
next	1.74;

1.74
date	2011.04.24.21.32.07;	author nicm;	state Exp;
branches;
next	1.73;

1.73
date	2011.04.18.19.49.05;	author nicm;	state Exp;
branches;
next	1.72;

1.72
date	2011.03.29.19.30.16;	author nicm;	state Exp;
branches;
next	1.71;

1.71
date	2011.01.26.01.54.56;	author nicm;	state Exp;
branches;
next	1.70;

1.70
date	2011.01.03.21.30.49;	author nicm;	state Exp;
branches;
next	1.69;

1.69
date	2011.01.01.16.51.21;	author nicm;	state Exp;
branches;
next	1.68;

1.68
date	2010.12.30.23.16.18;	author nicm;	state Exp;
branches;
next	1.67;

1.67
date	2010.12.30.21.35.17;	author nicm;	state Exp;
branches;
next	1.66;

1.66
date	2010.12.11.16.13.15;	author nicm;	state Exp;
branches;
next	1.65;

1.65
date	2010.12.11.16.05.57;	author nicm;	state Exp;
branches;
next	1.64;

1.64
date	2010.12.06.22.51.02;	author nicm;	state Exp;
branches;
next	1.63;

1.63
date	2010.06.21.01.27.46;	author nicm;	state Exp;
branches;
next	1.62;

1.62
date	2010.05.14.19.03.09;	author nicm;	state Exp;
branches;
next	1.61;

1.61
date	2010.03.31.18.05.14;	author nicm;	state Exp;
branches;
next	1.60;

1.60
date	2010.03.27.15.06.40;	author nicm;	state Exp;
branches;
next	1.59;

1.59
date	2010.03.22.19.18.46;	author nicm;	state Exp;
branches;
next	1.58;

1.58
date	2010.01.27.20.26.42;	author nicm;	state Exp;
branches;
next	1.57;

1.57
date	2010.01.26.21.36.53;	author nicm;	state Exp;
branches;
next	1.56;

1.56
date	2009.12.14.10.47.11;	author nicm;	state Exp;
branches;
next	1.55;

1.55
date	2009.12.03.22.50.10;	author nicm;	state Exp;
branches;
next	1.54;

1.54
date	2009.12.03.17.44.02;	author nicm;	state Exp;
branches;
next	1.53;

1.53
date	2009.11.26.22.28.24;	author nicm;	state Exp;
branches;
next	1.52;

1.52
date	2009.11.26.21.37.13;	author nicm;	state Exp;
branches;
next	1.51;

1.51
date	2009.11.20.07.01.12;	author nicm;	state Exp;
branches;
next	1.50;

1.50
date	2009.11.20.06.33.26;	author nicm;	state Exp;
branches;
next	1.49;

1.49
date	2009.11.19.21.30.53;	author nicm;	state Exp;
branches;
next	1.48;

1.48
date	2009.11.19.19.47.28;	author nicm;	state Exp;
branches;
next	1.47;

1.47
date	2009.11.19.16.22.10;	author nicm;	state Exp;
branches;
next	1.46;

1.46
date	2009.11.19.11.38.54;	author nicm;	state Exp;
branches;
next	1.45;

1.45
date	2009.11.19.10.22.07;	author nicm;	state Exp;
branches;
next	1.44;

1.44
date	2009.11.18.13.16.33;	author nicm;	state Exp;
branches;
next	1.43;

1.43
date	2009.11.17.13.30.07;	author nicm;	state Exp;
branches;
next	1.42;

1.42
date	2009.11.04.23.29.42;	author nicm;	state Exp;
branches;
next	1.41;

1.41
date	2009.11.04.21.04.43;	author nicm;	state Exp;
branches;
next	1.40;

1.40
date	2009.11.04.20.35.19;	author nicm;	state Exp;
branches;
next	1.39;

1.39
date	2009.11.01.23.20.37;	author nicm;	state Exp;
branches;
next	1.38;

1.38
date	2009.10.10.15.03.01;	author nicm;	state Exp;
branches;
next	1.37;

1.37
date	2009.10.10.10.02.48;	author nicm;	state Exp;
branches;
next	1.36;

1.36
date	2009.09.23.14.42.48;	author nicm;	state Exp;
branches;
next	1.35;

1.35
date	2009.09.23.06.18.48;	author nicm;	state Exp;
branches;
next	1.34;

1.34
date	2009.09.20.14.58.12;	author nicm;	state Exp;
branches;
next	1.33;

1.33
date	2009.09.10.17.16.24;	author nicm;	state Exp;
branches;
next	1.32;

1.32
date	2009.09.07.18.50.45;	author nicm;	state Exp;
branches;
next	1.31;

1.31
date	2009.09.07.10.49.32;	author nicm;	state Exp;
branches;
next	1.30;

1.30
date	2009.09.02.06.33.20;	author nicm;	state Exp;
branches;
next	1.29;

1.29
date	2009.09.01.09.11.05;	author nicm;	state Exp;
branches;
next	1.28;

1.28
date	2009.08.31.20.46.19;	author nicm;	state Exp;
branches;
next	1.27;

1.27
date	2009.08.19.10.39.50;	author nicm;	state Exp;
branches;
next	1.26;

1.26
date	2009.08.18.07.23.43;	author nicm;	state Exp;
branches;
next	1.25;

1.25
date	2009.08.13.23.44.18;	author nicm;	state Exp;
branches;
next	1.24;

1.24
date	2009.08.08.20.36.42;	author nicm;	state Exp;
branches;
next	1.23;

1.23
date	2009.08.05.16.26.38;	author nicm;	state Exp;
branches;
next	1.22;

1.22
date	2009.07.30.20.41.48;	author nicm;	state Exp;
branches;
next	1.21;

1.21
date	2009.07.28.07.03.32;	author nicm;	state Exp;
branches;
next	1.20;

1.20
date	2009.07.27.19.29.35;	author nicm;	state Exp;
branches;
next	1.19;

1.19
date	2009.07.27.18.51.46;	author nicm;	state Exp;
branches;
next	1.18;

1.18
date	2009.07.27.12.11.11;	author nicm;	state Exp;
branches;
next	1.17;

1.17
date	2009.07.26.21.13.47;	author nicm;	state Exp;
branches;
next	1.16;

1.16
date	2009.07.21.18.40.30;	author nicm;	state Exp;
branches;
next	1.15;

1.15
date	2009.07.20.14.32.09;	author nicm;	state Exp;
branches;
next	1.14;

1.14
date	2009.07.20.09.15.18;	author nicm;	state Exp;
branches;
next	1.13;

1.13
date	2009.07.17.18.45.08;	author nicm;	state Exp;
branches;
next	1.12;

1.12
date	2009.07.17.06.13.27;	author nicm;	state Exp;
branches;
next	1.11;

1.11
date	2009.07.16.23.25.21;	author nicm;	state Exp;
branches;
next	1.10;

1.10
date	2009.07.15.17.39.00;	author nicm;	state Exp;
branches;
next	1.9;

1.9
date	2009.07.15.07.50.34;	author nicm;	state Exp;
branches;
next	1.8;

1.8
date	2009.07.14.19.11.58;	author nicm;	state Exp;
branches;
next	1.7;

1.7
date	2009.07.14.19.03.16;	author nicm;	state Exp;
branches;
next	1.6;

1.6
date	2009.07.12.16.15.34;	author nicm;	state Exp;
branches;
next	1.5;

1.5
date	2009.06.26.15.13.39;	author nicm;	state Exp;
branches;
next	1.4;

1.4
date	2009.06.04.21.43.24;	author nicm;	state Exp;
branches;
next	1.3;

1.3
date	2009.06.03.16.54.26;	author nicm;	state Exp;
branches;
next	1.2;

1.2
date	2009.06.03.16.05.46;	author nicm;	state Exp;
branches;
next	1.1;

1.1
date	2009.06.01.22.58.49;	author nicm;	state Exp;
branches;
next	;


desc
@@


1.165
log
@Add a format for the last search string in copy mode and fix the prompt
so it can work when in -I, suggested by Suraj N Kurapati.
@
text
@/* $OpenBSD: status.c,v 1.164 2017/05/01 12:20:55 nicm Exp $ */

/*
 * Copyright (c) 2007 Nicholas Marriott <nicholas.marriott@@gmail.com>
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF MIND, USE, DATA OR PROFITS, WHETHER
 * IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING
 * OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */

#include <sys/types.h>
#include <sys/time.h>

#include <errno.h>
#include <limits.h>
#include <stdarg.h>
#include <stdlib.h>
#include <string.h>
#include <time.h>
#include <unistd.h>

#include "tmux.h"

static char	*status_redraw_get_left(struct client *, time_t,
		     struct grid_cell *, size_t *);
static char	*status_redraw_get_right(struct client *, time_t,
		     struct grid_cell *, size_t *);
static char	*status_print(struct client *, struct winlink *, time_t,
		     struct grid_cell *);
static char	*status_replace(struct client *, struct winlink *, const char *,
		     time_t);
static void	 status_message_callback(int, short, void *);
static void	 status_timer_callback(int, short, void *);

static char	*status_prompt_find_history_file(void);
static const char *status_prompt_up_history(u_int *);
static const char *status_prompt_down_history(u_int *);
static void	 status_prompt_add_history(const char *);

static const char **status_prompt_complete_list(u_int *, const char *);
static char	*status_prompt_complete_prefix(const char **, u_int);
static char	*status_prompt_complete(struct session *, const char *);

/* Status prompt history. */
#define PROMPT_HISTORY 100
static char	**status_prompt_hlist;
static u_int	  status_prompt_hsize;

/* Find the history file to load/save from/to. */
static char *
status_prompt_find_history_file(void)
{
	const char	*home, *history_file;
	char		*path;

	history_file = options_get_string(global_options, "history-file");
	if (*history_file == '\0')
		return (NULL);
	if (*history_file == '/')
		return (xstrdup(history_file));

	if (history_file[0] != '~' || history_file[1] != '/')
		return (NULL);
	if ((home = find_home()) == NULL)
		return (NULL);
	xasprintf(&path, "%s%s", home, history_file + 1);
	return (path);
}

/* Load status prompt history from file. */
void
status_prompt_load_history(void)
{
	FILE	*f;
	char	*history_file, *line, *tmp;
	size_t	 length;

	if ((history_file = status_prompt_find_history_file()) == NULL)
		return;
	log_debug("loading history from %s", history_file);

	f = fopen(history_file, "r");
	if (f == NULL) {
		log_debug("%s: %s", history_file, strerror(errno));
		free(history_file);
		return;
	}
	free(history_file);

	for (;;) {
		if ((line = fgetln(f, &length)) == NULL)
			break;

		if (length > 0) {
			if (line[length - 1] == '\n') {
				line[length - 1] = '\0';
				status_prompt_add_history(line);
			} else {
				tmp = xmalloc(length + 1);
				memcpy(tmp, line, length);
				tmp[length] = '\0';
				status_prompt_add_history(tmp);
				free(tmp);
			}
		}
	}
	fclose(f);
}

/* Save status prompt history to file. */
void
status_prompt_save_history(void)
{
	FILE	*f;
	u_int	 i;
	char	*history_file;

	if ((history_file = status_prompt_find_history_file()) == NULL)
		return;
	log_debug("saving history to %s", history_file);

	f = fopen(history_file, "w");
	if (f == NULL) {
		log_debug("%s: %s", history_file, strerror(errno));
		free(history_file);
		return;
	}
	free(history_file);

	for (i = 0; i < status_prompt_hsize; i++) {
		fputs(status_prompt_hlist[i], f);
		fputc('\n', f);
	}
	fclose(f);

}

/* Status timer callback. */
static void
status_timer_callback(__unused int fd, __unused short events, void *arg)
{
	struct client	*c = arg;
	struct session	*s = c->session;
	struct timeval	 tv;

	evtimer_del(&c->status_timer);

	if (s == NULL)
		return;

	if (c->message_string == NULL && c->prompt_string == NULL)
		c->flags |= CLIENT_STATUS;

	timerclear(&tv);
	tv.tv_sec = options_get_number(s->options, "status-interval");

	if (tv.tv_sec != 0)
		evtimer_add(&c->status_timer, &tv);
	log_debug("client %p, status interval %d", c, (int)tv.tv_sec);
}

/* Start status timer for client. */
void
status_timer_start(struct client *c)
{
	struct session	*s = c->session;

	if (event_initialized(&c->status_timer))
		evtimer_del(&c->status_timer);
	else
		evtimer_set(&c->status_timer, status_timer_callback, c);

	if (s != NULL && options_get_number(s->options, "status"))
		status_timer_callback(-1, 0, c);
}

/* Start status timer for all clients. */
void
status_timer_start_all(void)
{
	struct client	*c;

	TAILQ_FOREACH(c, &clients, entry)
		status_timer_start(c);
}

/* Update status cache. */
void
status_update_saved(struct session *s)
{
	if (!options_get_number(s->options, "status"))
		s->statusat = -1;
	else if (options_get_number(s->options, "status-position") == 0)
		s->statusat = 0;
	else
		s->statusat = 1;
}

/* Get screen line of status line. -1 means off. */
int
status_at_line(struct client *c)
{
	struct session	*s = c->session;

	if (s->statusat != 1)
		return (s->statusat);
	return (c->tty.sy - 1);
}

/* Retrieve options for left string. */
static char *
status_redraw_get_left(struct client *c, time_t t, struct grid_cell *gc,
    size_t *size)
{
	struct session	*s = c->session;
	const char	*template;
	char		*left;
	size_t		 leftlen;

	style_apply_update(gc, s->options, "status-left-style");

	template = options_get_string(s->options, "status-left");
	left = status_replace(c, NULL, template, t);

	*size = options_get_number(s->options, "status-left-length");
	leftlen = screen_write_cstrlen("%s", left);
	if (leftlen < *size)
		*size = leftlen;
	return (left);
}

/* Retrieve options for right string. */
static char *
status_redraw_get_right(struct client *c, time_t t, struct grid_cell *gc,
    size_t *size)
{
	struct session	*s = c->session;
	const char	*template;
	char		*right;
	size_t		 rightlen;

	style_apply_update(gc, s->options, "status-right-style");

	template = options_get_string(s->options, "status-right");
	right = status_replace(c, NULL, template, t);

	*size = options_get_number(s->options, "status-right-length");
	rightlen = screen_write_cstrlen("%s", right);
	if (rightlen < *size)
		*size = rightlen;
	return (right);
}

/* Get window at window list position. */
struct window *
status_get_window_at(struct client *c, u_int x)
{
	struct session	*s = c->session;
	struct winlink	*wl;
	struct options	*oo;
	const char	*sep;
	size_t		 seplen;

	x += c->wlmouse;
	RB_FOREACH(wl, winlinks, &s->windows) {
		oo = wl->window->options;

		sep = options_get_string(oo, "window-status-separator");
		seplen = screen_write_cstrlen("%s", sep);

		if (x < wl->status_width)
			return (wl->window);
		x -= wl->status_width + seplen;
	}
	return (NULL);
}

/* Draw status for client on the last lines of given context. */
int
status_redraw(struct client *c)
{
	struct screen_write_ctx	 ctx;
	struct session		*s = c->session;
	struct winlink		*wl;
	struct screen		 old_status, window_list;
	struct grid_cell	 stdgc, lgc, rgc, gc;
	struct options		*oo;
	time_t			 t;
	char			*left, *right;
	const char		*sep;
	u_int			 offset, needed;
	u_int			 wlstart, wlwidth, wlavailable, wloffset, wlsize;
	size_t			 llen, rlen, seplen;
	int			 larrow, rarrow;

	/* No status line? */
	if (c->tty.sy == 0 || !options_get_number(s->options, "status"))
		return (1);
	left = right = NULL;
	larrow = rarrow = 0;

	/* Store current time. */
	t = time(NULL);

	/* Set up default colour. */
	style_apply(&stdgc, s->options, "status-style");

	/* Create the target screen. */
	memcpy(&old_status, &c->status, sizeof old_status);
	screen_init(&c->status, c->tty.sx, 1, 0);
	screen_write_start(&ctx, NULL, &c->status);
	for (offset = 0; offset < c->tty.sx; offset++)
		screen_write_putc(&ctx, &stdgc, ' ');
	screen_write_stop(&ctx);

	/* If the height is one line, blank status line. */
	if (c->tty.sy <= 1)
		goto out;

	/* Work out left and right strings. */
	memcpy(&lgc, &stdgc, sizeof lgc);
	left = status_redraw_get_left(c, t, &lgc, &llen);
	memcpy(&rgc, &stdgc, sizeof rgc);
	right = status_redraw_get_right(c, t, &rgc, &rlen);

	/*
	 * Figure out how much space we have for the window list. If there
	 * isn't enough space, just show a blank status line.
	 */
	needed = 0;
	if (llen != 0)
		needed += llen;
	if (rlen != 0)
		needed += rlen;
	if (c->tty.sx == 0 || c->tty.sx <= needed)
		goto out;
	wlavailable = c->tty.sx - needed;

	/* Calculate the total size needed for the window list. */
	wlstart = wloffset = wlwidth = 0;
	RB_FOREACH(wl, winlinks, &s->windows) {
		free(wl->status_text);
		memcpy(&wl->status_cell, &stdgc, sizeof wl->status_cell);
		wl->status_text = status_print(c, wl, t, &wl->status_cell);
		wl->status_width = screen_write_cstrlen("%s", wl->status_text);

		if (wl == s->curw)
			wloffset = wlwidth;

		oo = wl->window->options;
		sep = options_get_string(oo, "window-status-separator");
		seplen = screen_write_cstrlen("%s", sep);
		wlwidth += wl->status_width + seplen;
	}

	/* Create a new screen for the window list. */
	screen_init(&window_list, wlwidth, 1, 0);

	/* And draw the window list into it. */
	screen_write_start(&ctx, NULL, &window_list);
	RB_FOREACH(wl, winlinks, &s->windows) {
		screen_write_cnputs(&ctx, -1, &wl->status_cell, "%s",
		    wl->status_text);

		oo = wl->window->options;
		sep = options_get_string(oo, "window-status-separator");
		screen_write_cnputs(&ctx, -1, &stdgc, "%s", sep);
	}
	screen_write_stop(&ctx);

	/* If there is enough space for the total width, skip to draw now. */
	if (wlwidth <= wlavailable)
		goto draw;

	/* Find size of current window text. */
	wlsize = s->curw->status_width;

	/*
	 * If the current window is already on screen, good to draw from the
	 * start and just leave off the end.
	 */
	if (wloffset + wlsize < wlavailable) {
		if (wlavailable > 0) {
			rarrow = 1;
			wlavailable--;
		}
		wlwidth = wlavailable;
	} else {
		/*
		 * Work out how many characters we need to omit from the
		 * start. There are wlavailable characters to fill, and
		 * wloffset + wlsize must be the last. So, the start character
		 * is wloffset + wlsize - wlavailable.
		 */
		if (wlavailable > 0) {
			larrow = 1;
			wlavailable--;
		}

		wlstart = wloffset + wlsize - wlavailable;
		if (wlavailable > 0 && wlwidth > wlstart + wlavailable + 1) {
			rarrow = 1;
			wlstart++;
			wlavailable--;
		}
		wlwidth = wlavailable;
	}

	/* Bail if anything is now too small too. */
	if (wlwidth == 0 || wlavailable == 0) {
		screen_free(&window_list);
		goto out;
	}

	/*
	 * Now the start position is known, work out the state of the left and
	 * right arrows.
	 */
	offset = 0;
	RB_FOREACH(wl, winlinks, &s->windows) {
		if (wl->flags & WINLINK_ALERTFLAGS &&
		    larrow == 1 && offset < wlstart)
			larrow = -1;

		offset += wl->status_width;

		if (wl->flags & WINLINK_ALERTFLAGS &&
		    rarrow == 1 && offset > wlstart + wlwidth)
			rarrow = -1;
	}

draw:
	/* Begin drawing. */
	screen_write_start(&ctx, NULL, &c->status);

	/* Draw the left string and arrow. */
	screen_write_cursormove(&ctx, 0, 0);
	if (llen != 0)
		screen_write_cnputs(&ctx, llen, &lgc, "%s", left);
	if (larrow != 0) {
		memcpy(&gc, &stdgc, sizeof gc);
		if (larrow == -1)
			gc.attr ^= GRID_ATTR_REVERSE;
		screen_write_putc(&ctx, &gc, '<');
	}

	/* Draw the right string and arrow. */
	if (rarrow != 0) {
		screen_write_cursormove(&ctx, c->tty.sx - rlen - 1, 0);
		memcpy(&gc, &stdgc, sizeof gc);
		if (rarrow == -1)
			gc.attr ^= GRID_ATTR_REVERSE;
		screen_write_putc(&ctx, &gc, '>');
	} else
		screen_write_cursormove(&ctx, c->tty.sx - rlen, 0);
	if (rlen != 0)
		screen_write_cnputs(&ctx, rlen, &rgc, "%s", right);

	/* Figure out the offset for the window list. */
	if (llen != 0)
		wloffset = llen;
	else
		wloffset = 0;
	if (wlwidth < wlavailable) {
		switch (options_get_number(s->options, "status-justify")) {
		case 1:	/* centred */
			wloffset += (wlavailable - wlwidth) / 2;
			break;
		case 2:	/* right */
			wloffset += (wlavailable - wlwidth);
			break;
		}
	}
	if (larrow != 0)
		wloffset++;

	/* Copy the window list. */
	c->wlmouse = -wloffset + wlstart;
	screen_write_cursormove(&ctx, wloffset, 0);
	screen_write_copy(&ctx, &window_list, wlstart, 0, wlwidth, 1, NULL,
	    NULL);
	screen_free(&window_list);

	screen_write_stop(&ctx);

out:
	free(left);
	free(right);

	if (grid_compare(c->status.grid, old_status.grid) == 0) {
		screen_free(&old_status);
		return (0);
	}
	screen_free(&old_status);
	return (1);
}

/* Replace special sequences in fmt. */
static char *
status_replace(struct client *c, struct winlink *wl, const char *fmt, time_t t)
{
	struct format_tree	*ft;
	char			*expanded;
	u_int			 tag;

	if (fmt == NULL)
		return (xstrdup(""));

	if (wl != NULL)
		tag = FORMAT_WINDOW|wl->window->id;
	else
		tag = FORMAT_NONE;
	if (c->flags & CLIENT_STATUSFORCE)
		ft = format_create(c, NULL, tag, FORMAT_STATUS|FORMAT_FORCE);
	else
		ft = format_create(c, NULL, tag, FORMAT_STATUS);
	format_defaults(ft, c, NULL, wl, NULL);

	expanded = format_expand_time(ft, fmt, t);

	format_free(ft);
	return (expanded);
}

/* Return winlink status line entry and adjust gc as necessary. */
static char *
status_print(struct client *c, struct winlink *wl, time_t t,
    struct grid_cell *gc)
{
	struct options	*oo = wl->window->options;
	struct session	*s = c->session;
	const char	*fmt;
	char   		*text;

	style_apply_update(gc, oo, "window-status-style");
	fmt = options_get_string(oo, "window-status-format");
	if (wl == s->curw) {
		style_apply_update(gc, oo, "window-status-current-style");
		fmt = options_get_string(oo, "window-status-current-format");
	}
	if (wl == TAILQ_FIRST(&s->lastw))
		style_apply_update(gc, oo, "window-status-last-style");

	if (wl->flags & WINLINK_BELL)
		style_apply_update(gc, oo, "window-status-bell-style");
	else if (wl->flags & (WINLINK_ACTIVITY|WINLINK_SILENCE))
		style_apply_update(gc, oo, "window-status-activity-style");

	text = status_replace(c, wl, fmt, t);
	return (text);
}

/* Set a status line message. */
void
status_message_set(struct client *c, const char *fmt, ...)
{
	struct timeval	tv;
	va_list		ap;
	int		delay;

	status_message_clear(c);

	va_start(ap, fmt);
	xvasprintf(&c->message_string, fmt, ap);
	va_end(ap);

	server_client_add_message(c, "%s", c->message_string);

	delay = options_get_number(c->session->options, "display-time");
	if (delay > 0) {
		tv.tv_sec = delay / 1000;
		tv.tv_usec = (delay % 1000) * 1000L;

		if (event_initialized(&c->message_timer))
			evtimer_del(&c->message_timer);
		evtimer_set(&c->message_timer, status_message_callback, c);
		evtimer_add(&c->message_timer, &tv);
	}

	c->tty.flags |= (TTY_NOCURSOR|TTY_FREEZE);
	c->flags |= CLIENT_STATUS;
}

/* Clear status line message. */
void
status_message_clear(struct client *c)
{
	if (c->message_string == NULL)
		return;

	free(c->message_string);
	c->message_string = NULL;

	if (c->prompt_string == NULL)
		c->tty.flags &= ~(TTY_NOCURSOR|TTY_FREEZE);
	c->flags |= CLIENT_REDRAW; /* screen was frozen and may have changed */

	screen_reinit(&c->status);
}

/* Clear status line message after timer expires. */
static void
status_message_callback(__unused int fd, __unused short event, void *data)
{
	struct client	*c = data;

	status_message_clear(c);
}

/* Draw client message on status line of present else on last line. */
int
status_message_redraw(struct client *c)
{
	struct screen_write_ctx		ctx;
	struct session		       *s = c->session;
	struct screen		        old_status;
	size_t			        len;
	struct grid_cell		gc;

	if (c->tty.sx == 0 || c->tty.sy == 0)
		return (0);
	memcpy(&old_status, &c->status, sizeof old_status);
	screen_init(&c->status, c->tty.sx, 1, 0);

	len = screen_write_strlen("%s", c->message_string);
	if (len > c->tty.sx)
		len = c->tty.sx;

	style_apply(&gc, s->options, "message-style");

	screen_write_start(&ctx, NULL, &c->status);

	screen_write_cursormove(&ctx, 0, 0);
	screen_write_nputs(&ctx, len, &gc, "%s", c->message_string);
	for (; len < c->tty.sx; len++)
		screen_write_putc(&ctx, &gc, ' ');

	screen_write_stop(&ctx);

	if (grid_compare(c->status.grid, old_status.grid) == 0) {
		screen_free(&old_status);
		return (0);
	}
	screen_free(&old_status);
	return (1);
}

/* Enable status line prompt. */
void
status_prompt_set(struct client *c, const char *msg, const char *input,
    int (*callbackfn)(void *, const char *, int), void (*freefn)(void *),
    void *data, int flags)
{
	struct format_tree	*ft;
	time_t			 t;
	char			*tmp, *cp;

	ft = format_create(c, NULL, FORMAT_NONE, 0);
	format_defaults(ft, c, NULL, NULL, NULL);

	t = time(NULL);
	tmp = format_expand_time(ft, input, t);

	status_message_clear(c);
	status_prompt_clear(c);

	c->prompt_string = format_expand_time(ft, msg, t);

	c->prompt_buffer = utf8_fromcstr(tmp);
	c->prompt_index = utf8_strlen(c->prompt_buffer);

	c->prompt_callbackfn = callbackfn;
	c->prompt_freefn = freefn;
	c->prompt_data = data;

	c->prompt_hindex = 0;

	c->prompt_flags = flags;
	c->prompt_mode = PROMPT_ENTRY;

	if (~flags & PROMPT_INCREMENTAL)
		c->tty.flags |= (TTY_NOCURSOR|TTY_FREEZE);
	c->flags |= CLIENT_STATUS;

	if ((flags & PROMPT_INCREMENTAL) && *tmp != '\0') {
		xasprintf(&cp, "=%s", tmp);
		c->prompt_callbackfn(c->prompt_data, cp, 0);
		free(cp);
	}

	free(tmp);
	format_free(ft);
}

/* Remove status line prompt. */
void
status_prompt_clear(struct client *c)
{
	if (c->prompt_string == NULL)
		return;

	if (c->prompt_freefn != NULL && c->prompt_data != NULL)
		c->prompt_freefn(c->prompt_data);

	free(c->prompt_string);
	c->prompt_string = NULL;

	free(c->prompt_buffer);
	c->prompt_buffer = NULL;

	c->tty.flags &= ~(TTY_NOCURSOR|TTY_FREEZE);
	c->flags |= CLIENT_REDRAW; /* screen was frozen and may have changed */

	screen_reinit(&c->status);
}

/* Update status line prompt with a new prompt string. */
void
status_prompt_update(struct client *c, const char *msg, const char *input)
{
	struct format_tree	*ft;
	time_t			 t;
	char			*tmp;

	ft = format_create(c, NULL, FORMAT_NONE, 0);
	format_defaults(ft, c, NULL, NULL, NULL);

	t = time(NULL);
	tmp = format_expand_time(ft, input, t);

	free(c->prompt_string);
	c->prompt_string = format_expand_time(ft, msg, t);

	free(c->prompt_buffer);
	c->prompt_buffer = utf8_fromcstr(tmp);
	c->prompt_index = utf8_strlen(c->prompt_buffer);

	c->prompt_hindex = 0;

	c->flags |= CLIENT_STATUS;

	free(tmp);
	format_free(ft);
}

/* Draw client prompt on status line of present else on last line. */
int
status_prompt_redraw(struct client *c)
{
	struct screen_write_ctx	 ctx;
	struct session		*s = c->session;
	struct screen		 old_status;
	u_int			 i, offset, left, start, pcursor, pwidth, width;
	struct grid_cell	 gc, cursorgc;

	if (c->tty.sx == 0 || c->tty.sy == 0)
		return (0);
	memcpy(&old_status, &c->status, sizeof old_status);
	screen_init(&c->status, c->tty.sx, 1, 0);

	if (c->prompt_mode == PROMPT_COMMAND)
		style_apply(&gc, s->options, "message-command-style");
	else
		style_apply(&gc, s->options, "message-style");

	memcpy(&cursorgc, &gc, sizeof cursorgc);
	cursorgc.attr ^= GRID_ATTR_REVERSE;

	start = screen_write_strlen("%s", c->prompt_string);
	if (start > c->tty.sx)
		start = c->tty.sx;

	screen_write_start(&ctx, NULL, &c->status);
	screen_write_cursormove(&ctx, 0, 0);
	screen_write_nputs(&ctx, start, &gc, "%s", c->prompt_string);
	while (c->status.cx < screen_size_x(&c->status))
		screen_write_putc(&ctx, &gc, ' ');
	screen_write_cursormove(&ctx, start, 0);

	left = c->tty.sx - start;
	if (left == 0)
		goto finished;

	pcursor = utf8_strwidth(c->prompt_buffer, c->prompt_index);
	pwidth = utf8_strwidth(c->prompt_buffer, -1);
	if (pcursor >= left) {
		/*
		 * The cursor would be outside the screen so start drawing
		 * with it on the right.
		 */
		offset = (pcursor - left) + 1;
		pwidth = left;
	} else
		offset = 0;
	if (pwidth > left)
		pwidth = left;

	width = 0;
	for (i = 0; c->prompt_buffer[i].size != 0; i++) {
		if (width < offset) {
			width += c->prompt_buffer[i].width;
			continue;
		}
		if (width >= offset + pwidth)
			break;
		width += c->prompt_buffer[i].width;
		if (width > offset + pwidth)
			break;

		if (i != c->prompt_index) {
			utf8_copy(&gc.data, &c->prompt_buffer[i]);
			screen_write_cell(&ctx, &gc);
		} else {
			utf8_copy(&cursorgc.data, &c->prompt_buffer[i]);
			screen_write_cell(&ctx, &cursorgc);
		}
	}
	if (c->status.cx < screen_size_x(&c->status) && c->prompt_index >= i)
		screen_write_putc(&ctx, &cursorgc, ' ');

finished:
	screen_write_stop(&ctx);

	if (grid_compare(c->status.grid, old_status.grid) == 0) {
		screen_free(&old_status);
		return (0);
	}
	screen_free(&old_status);
	return (1);
}

/* Is this a separator? */
static int
status_prompt_in_list(const char *ws, const struct utf8_data *ud)
{
	if (ud->size != 1 || ud->width != 1)
		return (0);
	return (strchr(ws, *ud->data) != NULL);
}

/* Is this a space? */
static int
status_prompt_space(const struct utf8_data *ud)
{
	if (ud->size != 1 || ud->width != 1)
		return (0);
	return (*ud->data == ' ');
}

/*
 * Translate key from emacs to vi. Return 0 to drop key, 1 to process the key
 * as an emacs key; return 2 to append to the buffer.
 */
static int
status_prompt_translate_key(struct client *c, key_code key, key_code *new_key)
{
	if (c->prompt_mode == PROMPT_ENTRY) {
		switch (key) {
		case '\003': /* C-c */
		case '\010': /* C-h */
		case '\011': /* Tab */
		case '\025': /* C-u */
		case '\027': /* C-w */
		case '\n':
		case '\r':
		case KEYC_BSPACE:
		case KEYC_DC:
		case KEYC_DOWN:
		case KEYC_END:
		case KEYC_HOME:
		case KEYC_LEFT:
		case KEYC_RIGHT:
		case KEYC_UP:
			*new_key = key;
			return (1);
		case '\033': /* Escape */
			c->prompt_mode = PROMPT_COMMAND;
			c->flags |= CLIENT_STATUS;
			return (0);
		}
		*new_key = key;
		return (2);
	}

	switch (key) {
	case 'A':
	case 'I':
	case 'C':
	case 's':
	case 'a':
		c->prompt_mode = PROMPT_ENTRY;
		c->flags |= CLIENT_STATUS;
		break; /* switch mode and... */
	case 'S':
		c->prompt_mode = PROMPT_ENTRY;
		c->flags |= CLIENT_STATUS;
		*new_key = '\025'; /* C-u */
		return (1);
	case 'i':
	case '\033': /* Escape */
		c->prompt_mode = PROMPT_ENTRY;
		c->flags |= CLIENT_STATUS;
		return (0);
	}

	switch (key) {
	case 'A':
	case '$':
		*new_key = KEYC_END;
		return (1);
	case 'I':
	case '0':
	case '^':
		*new_key = KEYC_HOME;
		return (1);
	case 'C':
	case 'D':
		*new_key = '\013'; /* C-k */
		return (1);
	case KEYC_BSPACE:
	case 'X':
		*new_key = KEYC_BSPACE;
		return (1);
	case 'b':
	case 'B':
		*new_key = 'b'|KEYC_ESCAPE;
		return (1);
	case 'd':
		*new_key = '\025';
		return (1);
	case 'e':
	case 'E':
	case 'w':
	case 'W':
		*new_key = 'f'|KEYC_ESCAPE;
		return (1);
	case 'p':
		*new_key = '\031'; /* C-y */
		return (1);
	case 's':
	case KEYC_DC:
	case 'x':
		*new_key = KEYC_DC;
		return (1);
	case KEYC_DOWN:
	case 'j':
		*new_key = KEYC_DOWN;
		return (1);
	case KEYC_LEFT:
	case 'h':
		*new_key = KEYC_LEFT;
		return (1);
	case 'a':
	case KEYC_RIGHT:
	case 'l':
		*new_key = KEYC_RIGHT;
		return (1);
	case KEYC_UP:
	case 'k':
		*new_key = KEYC_UP;
		return (1);
	case '\010' /* C-h */:
	case '\003' /* C-c */:
	case '\n':
	case '\r':
		return (1);
	}
	return (0);
}

/* Handle keys in prompt. */
int
status_prompt_key(struct client *c, key_code key)
{
	struct options		*oo = c->session->options;
	struct paste_buffer	*pb;
	char			*s, *cp, word[64], prefix = '=';
	const char		*histstr, *bufdata, *ws = NULL;
	u_char			 ch;
	size_t			 size, n, off, idx, bufsize, used;
	struct utf8_data	 tmp, *first, *last, *ud;
	int			 keys;

	size = utf8_strlen(c->prompt_buffer);

	if (c->prompt_flags & PROMPT_NUMERIC) {
		if (key >= '0' && key <= '9')
			goto append_key;
		s = utf8_tocstr(c->prompt_buffer);
		c->prompt_callbackfn(c->prompt_data, s, 1);
		status_prompt_clear(c);
		free(s);
		return (1);
	}

	keys = options_get_number(c->session->options, "status-keys");
	if (keys == MODEKEY_VI) {
		switch (status_prompt_translate_key(c, key, &key)) {
		case 1:
			goto process_key;
		case 2:
			goto append_key;
		default:
			return (0);
		}
	}

process_key:
	switch (key) {
	case KEYC_LEFT:
	case '\002': /* C-b */
		if (c->prompt_index > 0) {
			c->prompt_index--;
			break;
		}
		break;
	case KEYC_RIGHT:
	case '\006': /* C-f */
		if (c->prompt_index < size) {
			c->prompt_index++;
			break;
		}
		break;
	case KEYC_HOME:
	case '\001': /* C-a */
		if (c->prompt_index != 0) {
			c->prompt_index = 0;
			break;
		}
		break;
	case KEYC_END:
	case '\005': /* C-e */
		if (c->prompt_index != size) {
			c->prompt_index = size;
			break;
		}
		break;
	case '\011': /* Tab */
		if (c->prompt_buffer[0].size == 0)
			break;

		idx = c->prompt_index;
		if (idx != 0)
			idx--;

		/* Find the word we are in. */
		first = &c->prompt_buffer[idx];
		while (first > c->prompt_buffer && !status_prompt_space(first))
			first--;
		while (first->size != 0 && status_prompt_space(first))
			first++;
		last = &c->prompt_buffer[idx];
		while (last->size != 0 && !status_prompt_space(last))
			last++;
		while (last > c->prompt_buffer && status_prompt_space(last))
			last--;
		if (last->size != 0)
			last++;
		if (last <= first)
			break;

		used = 0;
		for (ud = first; ud < last; ud++) {
			if (used + ud->size >= sizeof word)
				break;
			memcpy(word + used, ud->data, ud->size);
			used += ud->size;
		}
		if (ud != last)
			break;
		word[used] = '\0';

		/* And try to complete it. */
		if ((s = status_prompt_complete(c->session, word)) == NULL)
			break;

		/* Trim out word. */
		n = size - (last - c->prompt_buffer) + 1; /* with \0 */
		memmove(first, last, n * sizeof *c->prompt_buffer);
		size -= last - first;

		/* Insert the new word. */
		size += strlen(s);
		off = first - c->prompt_buffer;
		c->prompt_buffer = xreallocarray(c->prompt_buffer, size + 1,
		    sizeof *c->prompt_buffer);
		first = c->prompt_buffer + off;
		memmove(first + strlen(s), first, n * sizeof *c->prompt_buffer);
		for (idx = 0; idx < strlen(s); idx++)
			utf8_set(&first[idx], s[idx]);

		c->prompt_index = (first - c->prompt_buffer) + strlen(s);
		free(s);

		goto changed;
	case KEYC_BSPACE:
	case '\010': /* C-h */
		if (c->prompt_index != 0) {
			if (c->prompt_index == size)
				c->prompt_buffer[--c->prompt_index].size = 0;
			else {
				memmove(c->prompt_buffer + c->prompt_index - 1,
				    c->prompt_buffer + c->prompt_index,
				    (size + 1 - c->prompt_index) *
				    sizeof *c->prompt_buffer);
				c->prompt_index--;
			}
			goto changed;
		}
		break;
	case KEYC_DC:
	case '\004': /* C-d */
		if (c->prompt_index != size) {
			memmove(c->prompt_buffer + c->prompt_index,
			    c->prompt_buffer + c->prompt_index + 1,
			    (size + 1 - c->prompt_index) *
			    sizeof *c->prompt_buffer);
			goto changed;
		}
		break;
	case '\025': /* C-u */
		c->prompt_buffer[0].size = 0;
		c->prompt_index = 0;
		goto changed;
	case '\013': /* C-k */
		if (c->prompt_index < size) {
			c->prompt_buffer[c->prompt_index].size = 0;
			goto changed;
		}
		break;
	case '\027': /* C-w */
		ws = options_get_string(oo, "word-separators");
		idx = c->prompt_index;

		/* Find a non-separator. */
		while (idx != 0) {
			idx--;
			if (!status_prompt_in_list(ws, &c->prompt_buffer[idx]))
				break;
		}

		/* Find the separator at the beginning of the word. */
		while (idx != 0) {
			idx--;
			if (status_prompt_in_list(ws, &c->prompt_buffer[idx])) {
				/* Go back to the word. */
				idx++;
				break;
			}
		}

		memmove(c->prompt_buffer + idx,
		    c->prompt_buffer + c->prompt_index,
		    (size + 1 - c->prompt_index) *
		    sizeof *c->prompt_buffer);
		memset(c->prompt_buffer + size - (c->prompt_index - idx),
		    '\0', (c->prompt_index - idx) * sizeof *c->prompt_buffer);
		c->prompt_index = idx;

		goto changed;
	case 'f'|KEYC_ESCAPE:
		ws = options_get_string(oo, "word-separators");

		/* Find a word. */
		while (c->prompt_index != size) {
			idx = ++c->prompt_index;
			if (!status_prompt_in_list(ws, &c->prompt_buffer[idx]))
				break;
		}

		/* Find the separator at the end of the word. */
		while (c->prompt_index != size) {
			idx = ++c->prompt_index;
			if (status_prompt_in_list(ws, &c->prompt_buffer[idx]))
				break;
		}

		/* Back up to the end-of-word like vi. */
		if (options_get_number(oo, "status-keys") == MODEKEY_VI &&
		    c->prompt_index != 0)
			c->prompt_index--;

		goto changed;
	case 'b'|KEYC_ESCAPE:
		ws = options_get_string(oo, "word-separators");

		/* Find a non-separator. */
		while (c->prompt_index != 0) {
			idx = --c->prompt_index;
			if (!status_prompt_in_list(ws, &c->prompt_buffer[idx]))
				break;
		}

		/* Find the separator at the beginning of the word. */
		while (c->prompt_index != 0) {
			idx = --c->prompt_index;
			if (status_prompt_in_list(ws, &c->prompt_buffer[idx])) {
				/* Go back to the word. */
				c->prompt_index++;
				break;
			}
		}
		goto changed;
	case KEYC_UP:
	case '\020': /* C-p */
		histstr = status_prompt_up_history(&c->prompt_hindex);
		if (histstr == NULL)
			break;
		free(c->prompt_buffer);
		c->prompt_buffer = utf8_fromcstr(histstr);
		c->prompt_index = utf8_strlen(c->prompt_buffer);
		goto changed;
	case KEYC_DOWN:
	case '\016': /* C-n */
		histstr = status_prompt_down_history(&c->prompt_hindex);
		if (histstr == NULL)
			break;
		free(c->prompt_buffer);
		c->prompt_buffer = utf8_fromcstr(histstr);
		c->prompt_index = utf8_strlen(c->prompt_buffer);
		goto changed;
	case '\031': /* C-y */
		if ((pb = paste_get_top(NULL)) == NULL)
			break;
		bufdata = paste_buffer_data(pb, &bufsize);
		for (n = 0; n < bufsize; n++) {
			ch = (u_char)bufdata[n];
			if (ch < 32 || ch >= 127)
				break;
		}

		c->prompt_buffer = xreallocarray(c->prompt_buffer, size + n + 1,
		    sizeof *c->prompt_buffer);
		if (c->prompt_index == size) {
			for (idx = 0; idx < n; idx++) {
				ud = &c->prompt_buffer[c->prompt_index + idx];
				utf8_set(ud, bufdata[idx]);
			}
			c->prompt_index += n;
			c->prompt_buffer[c->prompt_index].size = 0;
		} else {
			memmove(c->prompt_buffer + c->prompt_index + n,
			    c->prompt_buffer + c->prompt_index,
			    (size + 1 - c->prompt_index) *
			    sizeof *c->prompt_buffer);
			for (idx = 0; idx < n; idx++) {
				ud = &c->prompt_buffer[c->prompt_index + idx];
				utf8_set(ud, bufdata[idx]);
			}
			c->prompt_index += n;
		}
		goto changed;
	case '\024': /* C-t */
		idx = c->prompt_index;
		if (idx < size)
			idx++;
		if (idx >= 2) {
			utf8_copy(&tmp, &c->prompt_buffer[idx - 2]);
			utf8_copy(&c->prompt_buffer[idx - 2],
			    &c->prompt_buffer[idx - 1]);
			utf8_copy(&c->prompt_buffer[idx - 1], &tmp);
			c->prompt_index = idx;
			goto changed;
		}
		break;
	case '\r':
	case '\n':
		s = utf8_tocstr(c->prompt_buffer);
		if (*s != '\0')
			status_prompt_add_history(s);
		if (c->prompt_callbackfn(c->prompt_data, s, 1) == 0)
			status_prompt_clear(c);
		free(s);
		break;
	case '\033': /* Escape */
	case '\003': /* C-c */
		if (c->prompt_callbackfn(c->prompt_data, NULL, 1) == 0)
			status_prompt_clear(c);
		break;
	case '\022': /* C-r */
		if (c->prompt_flags & PROMPT_INCREMENTAL) {
			prefix = '-';
			goto changed;
		}
		break;
	case '\023': /* C-s */
		if (c->prompt_flags & PROMPT_INCREMENTAL) {
			prefix = '+';
			goto changed;
		}
		break;
	default:
		goto append_key;
	}

	c->flags |= CLIENT_STATUS;
	return (0);

append_key:
	if (key <= 0x1f || key >= KEYC_BASE)
		return (0);
	if (utf8_split(key, &tmp) != UTF8_DONE)
		return (0);

	c->prompt_buffer = xreallocarray(c->prompt_buffer, size + 2,
	    sizeof *c->prompt_buffer);

	if (c->prompt_index == size) {
		utf8_copy(&c->prompt_buffer[c->prompt_index], &tmp);
		c->prompt_index++;
		c->prompt_buffer[c->prompt_index].size = 0;
	} else {
		memmove(c->prompt_buffer + c->prompt_index + 1,
		    c->prompt_buffer + c->prompt_index,
		    (size + 1 - c->prompt_index) *
		    sizeof *c->prompt_buffer);
		utf8_copy(&c->prompt_buffer[c->prompt_index], &tmp);
		c->prompt_index++;
	}

	if (c->prompt_flags & PROMPT_SINGLE) {
		s = utf8_tocstr(c->prompt_buffer);
		if (strlen(s) != 1)
			status_prompt_clear(c);
		else if (c->prompt_callbackfn(c->prompt_data, s, 1) == 0)
			status_prompt_clear(c);
		free(s);
	}

changed:
	c->flags |= CLIENT_STATUS;
	if (c->prompt_flags & PROMPT_INCREMENTAL) {
		s = utf8_tocstr(c->prompt_buffer);
		xasprintf(&cp, "%c%s", prefix, s);
		c->prompt_callbackfn(c->prompt_data, cp, 0);
		free(cp);
		free(s);
	}
	return (0);
}

/* Get previous line from the history. */
static const char *
status_prompt_up_history(u_int *idx)
{
	/*
	 * History runs from 0 to size - 1. Index is from 0 to size. Zero is
	 * empty.
	 */

	if (status_prompt_hsize == 0 || *idx == status_prompt_hsize)
		return (NULL);
	(*idx)++;
	return (status_prompt_hlist[status_prompt_hsize - *idx]);
}

/* Get next line from the history. */
static const char *
status_prompt_down_history(u_int *idx)
{
	if (status_prompt_hsize == 0 || *idx == 0)
		return ("");
	(*idx)--;
	if (*idx == 0)
		return ("");
	return (status_prompt_hlist[status_prompt_hsize - *idx]);
}

/* Add line to the history. */
static void
status_prompt_add_history(const char *line)
{
	size_t	size;

	if (status_prompt_hsize > 0 &&
	    strcmp(status_prompt_hlist[status_prompt_hsize - 1], line) == 0)
		return;

	if (status_prompt_hsize == PROMPT_HISTORY) {
		free(status_prompt_hlist[0]);

		size = (PROMPT_HISTORY - 1) * sizeof *status_prompt_hlist;
		memmove(&status_prompt_hlist[0], &status_prompt_hlist[1], size);

		status_prompt_hlist[status_prompt_hsize - 1] = xstrdup(line);
		return;
	}

	status_prompt_hlist = xreallocarray(status_prompt_hlist,
	    status_prompt_hsize + 1, sizeof *status_prompt_hlist);
	status_prompt_hlist[status_prompt_hsize++] = xstrdup(line);
}

/* Build completion list. */
static const char **
status_prompt_complete_list(u_int *size, const char *s)
{
	const char				**list = NULL, **layout;
	const struct cmd_entry			**cmdent;
	const struct options_table_entry	 *oe;
	const char				 *layouts[] = {
		"even-horizontal", "even-vertical", "main-horizontal",
		"main-vertical", "tiled", NULL
	};

	*size = 0;
	for (cmdent = cmd_table; *cmdent != NULL; cmdent++) {
		if (strncmp((*cmdent)->name, s, strlen(s)) == 0) {
			list = xreallocarray(list, (*size) + 1, sizeof *list);
			list[(*size)++] = (*cmdent)->name;
		}
	}
	for (oe = options_table; oe->name != NULL; oe++) {
		if (strncmp(oe->name, s, strlen(s)) == 0) {
			list = xreallocarray(list, (*size) + 1, sizeof *list);
			list[(*size)++] = oe->name;
		}
	}
	for (layout = layouts; *layout != NULL; layout++) {
		if (strncmp(*layout, s, strlen(s)) == 0) {
			list = xreallocarray(list, (*size) + 1, sizeof *list);
			list[(*size)++] = *layout;
		}
	}
	return (list);
}

/* Find longest prefix. */
static char *
status_prompt_complete_prefix(const char **list, u_int size)
{
	char	 *out;
	u_int	  i;
	size_t	  j;

	out = xstrdup(list[0]);
	for (i = 1; i < size; i++) {
		j = strlen(list[i]);
		if (j > strlen(out))
			j = strlen(out);
		for (; j > 0; j--) {
			if (out[j - 1] != list[i][j - 1])
				out[j - 1] = '\0';
		}
	}
	return (out);
}

/* Complete word. */
static char *
status_prompt_complete(struct session *session, const char *s)
{
	const char	**list = NULL, *colon;
	u_int		  size = 0, i;
	struct session	 *s_loop;
	struct winlink	 *wl;
	struct window	 *w;
	char		 *copy, *out, *tmp;

	if (*s == '\0')
		return (NULL);
	out = NULL;

	if (strncmp(s, "-t", 2) != 0 && strncmp(s, "-s", 2) != 0) {
		list = status_prompt_complete_list(&size, s);
		if (size == 0)
			out = NULL;
		else if (size == 1)
			xasprintf(&out, "%s ", list[0]);
		else
			out = status_prompt_complete_prefix(list, size);
		free(list);
		return (out);
	}
	copy = xstrdup(s);

	colon = ":";
	if (copy[strlen(copy) - 1] == ':')
		copy[strlen(copy) - 1] = '\0';
	else
		colon = "";
	s = copy + 2;

	RB_FOREACH(s_loop, sessions, &sessions) {
		if (strncmp(s_loop->name, s, strlen(s)) == 0) {
			list = xreallocarray(list, size + 2, sizeof *list);
			list[size++] = s_loop->name;
		}
	}
	if (size == 1) {
		out = xstrdup(list[0]);
		if (session_find(list[0]) != NULL)
			colon = ":";
	} else if (size != 0)
		out = status_prompt_complete_prefix(list, size);
	if (out != NULL) {
		xasprintf(&tmp, "-%c%s%s", copy[1], out, colon);
		free(out);
		out = tmp;
		goto found;
	}

	colon = "";
	if (*s == ':') {
		RB_FOREACH(wl, winlinks, &session->windows) {
			xasprintf(&tmp, ":%s", wl->window->name);
			if (strncmp(tmp, s, strlen(s)) == 0){
				list = xreallocarray(list, size + 1,
				    sizeof *list);
				list[size++] = tmp;
				continue;
			}
			free(tmp);

			xasprintf(&tmp, ":%d", wl->idx);
			if (strncmp(tmp, s, strlen(s)) == 0) {
				list = xreallocarray(list, size + 1,
				    sizeof *list);
				list[size++] = tmp;
				continue;
			}
			free(tmp);
		}
	} else {
		RB_FOREACH(s_loop, sessions, &sessions) {
			RB_FOREACH(wl, winlinks, &s_loop->windows) {
				w = wl->window;

				xasprintf(&tmp, "%s:%s", s_loop->name, w->name);
				if (strncmp(tmp, s, strlen(s)) == 0) {
					list = xreallocarray(list, size + 1,
					    sizeof *list);
					list[size++] = tmp;
					continue;
				}
				free(tmp);

				xasprintf(&tmp, "%s:%d", s_loop->name, wl->idx);
				if (strncmp(tmp, s, strlen(s)) == 0) {
					list = xreallocarray(list, size + 1,
					    sizeof *list);
					list[size++] = tmp;
					continue;
				}
				free(tmp);
			}
		}
	}
	if (size == 1) {
		out = xstrdup(list[0]);
		colon = " ";
	} else if (size != 0)
		out = status_prompt_complete_prefix(list, size);
	if (out != NULL) {
		xasprintf(&tmp, "-%c%s%s", copy[1], out, colon);
		out = tmp;
	}

	for (i = 0; i < size; i++)
		free((void *)list[i]);

found:
	free(copy);
	free(list);
	return (out);
}
@


1.164
log
@In order that people can use formats like #D in #() in the status line
and not have to wait for an update when they change pane, we allow
commands to run more than once a second if the expanded form
changes. Unfortunately this can mean them being run far too often
(pretty much continually) when multiple clients exist, because some
formats (including #D) will always differ between clients.

To avoid this, give each client its own tree of jobs which means that
the same command will be different instances for each client - similar
to how we have the tag to separate commands for different panes.

GitHub issue 889; test case reported by Paul Johnson.
@
text
@d1 1
a1 1
/* $OpenBSD: status.c,v 1.163 2017/04/22 12:55:06 nicm Exp $ */
d664 1
a664 1
	char			*tmp;
d692 6
@


1.163
log
@Memory leak from David CARLIER.
@
text
@d1 1
a1 1
/* $OpenBSD: status.c,v 1.162 2017/02/09 12:09:33 nicm Exp $ */
d522 1
a522 1
		ft = format_create(NULL, tag, FORMAT_STATUS|FORMAT_FORCE);
d524 1
a524 1
		ft = format_create(NULL, tag, FORMAT_STATUS);
d666 1
a666 1
	ft = format_create(NULL, FORMAT_NONE, 0);
d727 1
a727 1
	ft = format_create(NULL, FORMAT_NONE, 0);
@


1.162
log
@Break the message storage function into its own function, useful for
debugging.
@
text
@d1 1
a1 1
/* $OpenBSD: status.c,v 1.161 2017/02/03 21:01:02 nicm Exp $ */
d1500 1
@


1.161
log
@Cache status line position to reduce option lookups during output.
@
text
@d1 1
a1 1
/* $OpenBSD: status.c,v 1.160 2017/02/03 11:57:27 nicm Exp $ */
d565 3
a567 7
	struct timeval		 tv;
	struct message_entry	*msg, *msg1;
	va_list			 ap;
	int			 delay;
	u_int			 limit;

	limit = options_get_number(global_options, "message-limit");
d575 1
a575 13
	msg = xcalloc(1, sizeof *msg);
	msg->msg_time = time(NULL);
	msg->msg_num = c->message_next++;
	msg->msg = xstrdup(c->message_string);
	TAILQ_INSERT_TAIL(&c->message_log, msg, entry);

	TAILQ_FOREACH_SAFE(msg, &c->message_log, entry, msg1) {
		if (msg->msg_num + limit >= c->message_next)
			break;
		free(msg->msg);
		TAILQ_REMOVE(&c->message_log, msg, entry);
		free(msg);
	}
@


1.160
log
@Add a window or pane id "tag" to each format tree and use it to separate
jobs, this means that if the same job is used for different windows or
panes (for example in pane-border-format), it will be run separately for
each pane.
@
text
@d1 1
a1 1
/* $OpenBSD: status.c,v 1.159 2017/01/13 11:56:43 nicm Exp $ */
d195 12
d213 2
a214 5
	if (!options_get_number(s->options, "status"))
		return (-1);

	if (options_get_number(s->options, "status-position") == 0)
		return (0);
@


1.159
log
@Make options_get_string return const string.
@
text
@d1 1
a1 1
/* $OpenBSD: status.c,v 1.158 2017/01/06 11:57:03 nicm Exp $ */
d503 1
d508 4
d513 1
a513 1
		ft = format_create(NULL, FORMAT_STATUS|FORMAT_FORCE);
d515 1
a515 1
		ft = format_create(NULL, FORMAT_STATUS);
d673 1
a673 1
	ft = format_create(NULL, 0);
d734 1
a734 1
	ft = format_create(NULL, 0);
@


1.158
log
@Incremental search in copy mode (on for emacs keys by default) - much
the same as normal searching but updates the cursor position and marked
search terms as you type. C-r and C-s in the prompt repeat the search,
once finished searching (with Enter), N and n work as before.
@
text
@d1 1
a1 1
/* $OpenBSD: status.c,v 1.157 2017/01/05 09:07:16 nicm Exp $ */
d281 13
a293 12
	struct screen_write_ctx	ctx;
	struct session	       *s = c->session;
	struct winlink	       *wl;
	struct screen		old_status, window_list;
	struct grid_cell	stdgc, lgc, rgc, gc;
	struct options	       *oo;
	time_t			t;
	char		       *left, *right, *sep;
	u_int			offset, needed;
	u_int			wlstart, wlwidth, wlavailable, wloffset, wlsize;
	size_t			llen, rlen, seplen;
	int			larrow, rarrow;
@


1.157
log
@Highlight all occurrences of search string after searching in copy mode.
@
text
@d1 1
a1 1
/* $OpenBSD: status.c,v 1.156 2016/12/07 23:03:04 nicm Exp $ */
d660 1
a660 1
    int (*callbackfn)(void *, const char *), void (*freefn)(void *),
d690 2
a691 1
	c->tty.flags |= (TTY_NOCURSOR|TTY_FREEZE);
d980 1
a980 1
	char			*s, word[64];
d993 1
a993 1
		c->prompt_callbackfn(c->prompt_data, s);
d1017 1
a1017 1
			c->flags |= CLIENT_STATUS;
d1024 1
a1024 1
			c->flags |= CLIENT_STATUS;
d1031 1
a1031 1
			c->flags |= CLIENT_STATUS;
d1038 1
a1038 1
			c->flags |= CLIENT_STATUS;
d1098 1
a1098 2
		c->flags |= CLIENT_STATUS;
		break;
d1111 1
a1111 1
			c->flags |= CLIENT_STATUS;
d1121 1
a1121 1
			c->flags |= CLIENT_STATUS;
d1127 1
a1127 2
		c->flags |= CLIENT_STATUS;
		break;
d1131 1
a1131 1
			c->flags |= CLIENT_STATUS;
d1163 1
a1163 2
		c->flags |= CLIENT_STATUS;
		break;
d1186 1
a1186 2
		c->flags |= CLIENT_STATUS;
		break;
d1206 1
a1206 3

		c->flags |= CLIENT_STATUS;
		break;
d1215 1
a1215 2
		c->flags |= CLIENT_STATUS;
		break;
d1224 1
a1224 2
		c->flags |= CLIENT_STATUS;
		break;
d1255 1
a1255 3

		c->flags |= CLIENT_STATUS;
		break;
d1266 1
a1266 1
			c->flags |= CLIENT_STATUS;
d1274 1
a1274 1
		if (c->prompt_callbackfn(c->prompt_data, s) == 0)
d1280 1
a1280 1
		if (c->prompt_callbackfn(c->prompt_data, NULL) == 0)
d1283 14
d1299 3
d1328 1
a1328 1
		else if (c->prompt_callbackfn(c->prompt_data, s) == 0)
d1333 1
d1335 7
@


1.156
log
@Do not clear the prompt when a message is shown, just leave it around and
return to it when the message is finished.
@
text
@d1 1
a1 1
/* $OpenBSD: status.c,v 1.155 2016/10/12 14:50:14 nicm Exp $ */
d478 2
a479 1
	screen_write_copy(&ctx, &window_list, wlstart, 0, wlwidth, 1);
@


1.155
log
@Drop the edit mode key tables and just use fixed key bindings for the
command prompt.
@
text
@d1 1
a1 1
/* $OpenBSD: status.c,v 1.154 2016/10/12 13:03:27 nicm Exp $ */
a556 1
	status_prompt_clear(c);
d602 2
a603 1
	c->tty.flags &= ~(TTY_NOCURSOR|TTY_FREEZE);
@


1.154
log
@The repeat prompt in both emacs and vi (and the old one in tmux) doesn't
support line editing and instead executes a command as soon as a
non-number key is pressed. Add a -N flag to command-prompt for the same
in copy mode. Reported by Theo Buehler.
@
text
@d1 1
a1 1
/* $OpenBSD: status.c,v 1.153 2016/10/11 07:23:34 nicm Exp $ */
a662 1
	int			 keys;
d687 1
a687 6

	keys = options_get_number(c->session->options, "status-keys");
	if (keys == MODEKEY_EMACS)
		mode_key_init(&c->prompt_mdata, &mode_key_tree_emacs_edit);
	else
		mode_key_init(&c->prompt_mdata, &mode_key_tree_vi_edit);
d762 1
a762 1
	if (c->prompt_mdata.mode == 1)
d851 121
d983 1
d997 16
a1012 2
	switch (mode_key_lookup(&c->prompt_mdata, key)) {
	case MODEKEYEDIT_CURSORLEFT:
d1018 2
a1019 7
	case MODEKEYEDIT_SWITCHMODE:
		c->flags |= CLIENT_STATUS;
		break;
	case MODEKEYEDIT_SWITCHMODEAPPEND:
		c->flags |= CLIENT_STATUS;
		/* FALLTHROUGH */
	case MODEKEYEDIT_CURSORRIGHT:
d1025 2
a1026 4
	case MODEKEYEDIT_SWITCHMODEBEGINLINE:
		c->flags |= CLIENT_STATUS;
		/* FALLTHROUGH */
	case MODEKEYEDIT_STARTOFLINE:
d1032 2
a1033 4
	case MODEKEYEDIT_SWITCHMODEAPPENDLINE:
		c->flags |= CLIENT_STATUS;
		/* FALLTHROUGH */
	case MODEKEYEDIT_ENDOFLINE:
d1039 1
a1039 1
	case MODEKEYEDIT_COMPLETE:
d1098 2
a1099 1
	case MODEKEYEDIT_BACKSPACE:
d1113 2
a1114 2
	case MODEKEYEDIT_DELETE:
	case MODEKEYEDIT_SWITCHMODESUBSTITUTE:
d1123 1
a1123 2
	case MODEKEYEDIT_DELETELINE:
	case MODEKEYEDIT_SWITCHMODESUBSTITUTELINE:
d1128 1
a1128 2
	case MODEKEYEDIT_DELETETOENDOFLINE:
	case MODEKEYEDIT_SWITCHMODECHANGELINE:
d1134 1
a1134 1
	case MODEKEYEDIT_DELETEWORD:
d1165 2
a1166 29
	case MODEKEYEDIT_NEXTSPACE:
		ws = " ";
		/* FALLTHROUGH */
	case MODEKEYEDIT_NEXTWORD:
		if (ws == NULL)
			ws = options_get_string(oo, "word-separators");

		/* Find a separator. */
		while (c->prompt_index != size) {
			idx = ++c->prompt_index;
			if (status_prompt_in_list(ws, &c->prompt_buffer[idx]))
				break;
		}

		/* Find the word right after the separator. */
		while (c->prompt_index != size) {
			idx = ++c->prompt_index;
			if (!status_prompt_in_list(ws, &c->prompt_buffer[idx]))
				break;
		}

		c->flags |= CLIENT_STATUS;
		break;
	case MODEKEYEDIT_NEXTSPACEEND:
		ws = " ";
		/* FALLTHROUGH */
	case MODEKEYEDIT_NEXTWORDEND:
		if (ws == NULL)
			ws = options_get_string(oo, "word-separators");
d1189 2
a1190 6
	case MODEKEYEDIT_PREVIOUSSPACE:
		ws = " ";
		/* FALLTHROUGH */
	case MODEKEYEDIT_PREVIOUSWORD:
		if (ws == NULL)
			ws = options_get_string(oo, "word-separators");
d1211 2
a1212 1
	case MODEKEYEDIT_HISTORYUP:
d1221 2
a1222 1
	case MODEKEYEDIT_HISTORYDOWN:
d1231 1
a1231 1
	case MODEKEYEDIT_PASTE:
d1264 1
a1264 1
	case MODEKEYEDIT_TRANSPOSECHARS:
d1277 2
a1278 1
	case MODEKEYEDIT_ENTER:
d1286 2
a1287 1
	case MODEKEYEDIT_CANCEL:
a1290 4
	case MODEKEY_OTHER:
		break;
	default:
		return (0);
@


1.153
log
@Fundamental change to how copy mode key bindings work:

The vi-copy and emacs-copy mode key tables are gone, and instead copy
mode commands are bound in one of two normal key tables ("copy-mode" or
"copy-mode-vi"). Keys are bound to "send-keys -X copy-mode-command". So:

    bind -temacs-copy C-Up scroll-up
    bind -temacs-copy -R5 WheelUpPane scroll-up

Becomes:

    bind -Tcopy-mode C-Up send -X scroll-up
    bind -Tcopy-mode WheelUpPane send -N5 -X scroll-up

This allows the full command parser and command set to be used - for
example, we can use the normal command prompt for searching, jumping,
and so on instead of a custom one:

    bind -Tcopy-mode C-r command-prompt -p'search up' "send -X search-backward '%%'"

command-prompt also gets a -1 option to only require on key press, which
is needed for jumping.

The plan is to get rid of mode keys entirely, so more to come eventually.
@
text
@d1 1
a1 1
/* $OpenBSD: status.c,v 1.152 2016/10/11 07:11:40 nicm Exp $ */
d858 1
a858 1
void
d870 11
d1199 4
a1202 4
		if (key <= 0x1f || key >= KEYC_BASE)
			break;
		if (utf8_split(key, &tmp) != UTF8_DONE)
			break;
d1204 5
a1208 2
		c->prompt_buffer = xreallocarray(c->prompt_buffer, size + 2,
		    sizeof *c->prompt_buffer);
d1210 2
a1211 12
		if (c->prompt_index == size) {
			utf8_copy(&c->prompt_buffer[c->prompt_index], &tmp);
			c->prompt_index++;
			c->prompt_buffer[c->prompt_index].size = 0;
		} else {
			memmove(c->prompt_buffer + c->prompt_index + 1,
			    c->prompt_buffer + c->prompt_index,
			    (size + 1 - c->prompt_index) *
			    sizeof *c->prompt_buffer);
			utf8_copy(&c->prompt_buffer[c->prompt_index], &tmp);
			c->prompt_index++;
		}
d1213 12
a1224 8
		if (c->prompt_flags & PROMPT_SINGLE) {
			s = utf8_tocstr(c->prompt_buffer);
			if (strlen(s) != 1)
				status_prompt_clear(c);
			else if (c->prompt_callbackfn(c->prompt_data, s) == 0)
				status_prompt_clear(c);
			free(s);
		}
d1226 7
a1232 4
		c->flags |= CLIENT_STATUS;
		break;
	default:
		break;
d1234 3
@


1.152
log
@Support UTF-8 entry into the command prompt.
@
text
@d1 1
a1 1
/* $OpenBSD: status.c,v 1.151 2016/10/10 21:29:23 nicm Exp $ */
d870 1
a870 1
	switch (mode_key_lookup(&c->prompt_mdata, key, NULL, NULL)) {
@


1.151
log
@Loads more static, except for cmd-*.c and window-*.c.
@
text
@d1 1
a1 1
/* $OpenBSD: status.c,v 1.150 2016/09/12 15:40:58 nicm Exp $ */
d665 1
d669 1
d671 1
d678 2
a679 2
	c->prompt_buffer = format_expand_time(ft, input, t);
	c->prompt_index = strlen(c->prompt_buffer);
d698 1
d730 1
d734 1
d736 1
d742 2
a743 2
	c->prompt_buffer = format_expand_time(ft, input, t);
	c->prompt_index = strlen(c->prompt_buffer);
d749 1
d757 5
a761 5
	struct screen_write_ctx		ctx;
	struct session		       *s = c->session;
	struct screen		        old_status;
	size_t			        i, size, left, len, off;
	struct grid_cell		gc;
a767 6
	len = screen_write_strlen("%s", c->prompt_string);
	if (len > c->tty.sx)
		len = c->tty.sx;
	off = 0;

	/* Change colours for command mode. */
d773 7
a780 1

d782 4
a785 1
	screen_write_nputs(&ctx, len, &gc, "%s", c->prompt_string);
d787 23
a809 8
	left = c->tty.sx - len;
	if (left != 0) {
		size = screen_write_strlen("%s", c->prompt_buffer);
		if (c->prompt_index >= left) {
			off = c->prompt_index - left + 1;
			if (c->prompt_index == size)
				left--;
			size = left;
d811 5
a815 2
		screen_write_nputs(&ctx, left, &gc, "%s", c->prompt_buffer +
		    off);
d817 7
a823 2
		for (i = len + size; i < c->tty.sx; i++)
			screen_write_putc(&ctx, &gc, ' ');
d825 2
d828 1
a830 6
	/* Apply fake cursor. */
	off = len + c->prompt_index - off;
	grid_view_get_cell(c->status.grid, off, 0, &gc);
	gc.attr ^= GRID_ATTR_REVERSE;
	grid_view_set_cell(c->status.grid, off, 0, &gc);

d839 18
d861 1
a861 2
	struct session		*sess = c->session;
	struct options		*oo = sess->options;
d863 2
a864 2
	char			*s, *first, *last, word[64], swapc;
	const char		*histstr, *bufdata, *wsep = NULL;
d866 2
a867 1
	size_t			 size, n, off, idx, bufsize;
d869 1
a869 1
	size = strlen(c->prompt_buffer);
d908 1
a908 1
		if (*c->prompt_buffer == '\0')
d916 2
a917 2
		first = c->prompt_buffer + idx;
		while (first > c->prompt_buffer && *first != ' ')
d919 1
a919 1
		while (*first == ' ')
d921 2
a922 2
		last = c->prompt_buffer + idx;
		while (*last != '\0' && *last != ' ')
d924 1
a924 1
		while (*last == ' ')
d926 1
a926 1
		if (*last != '\0')
d928 11
a938 2
		if (last <= first ||
		    ((size_t) (last - first)) > (sizeof word) - 1)
d940 1
a940 2
		memcpy(word, first, last - first);
		word[last - first] = '\0';
d943 1
a943 1
		if ((s = status_prompt_complete(sess, word)) == NULL)
d948 1
a948 1
		memmove(first, last, n);
d954 2
a955 1
		c->prompt_buffer = xrealloc(c->prompt_buffer, size + 1);
d957 3
a959 2
		memmove(first + strlen(s), first, n);
		memcpy(first, s, strlen(s));
d969 1
a969 1
				c->prompt_buffer[--c->prompt_index] = '\0';
d973 2
a974 1
				    size + 1 - c->prompt_index);
d985 2
a986 1
			    size + 1 - c->prompt_index);
d992 1
a992 1
		*c->prompt_buffer = '\0';
d999 1
a999 1
			c->prompt_buffer[c->prompt_index] = '\0';
d1004 1
a1004 1
		wsep = options_get_string(oo, "word-separators");
d1010 1
a1010 1
			if (!strchr(wsep, c->prompt_buffer[idx]))
d1017 1
a1017 1
			if (strchr(wsep, c->prompt_buffer[idx])) {
d1026 2
a1027 1
		    size + 1 - c->prompt_index);
d1029 1
a1029 1
		    '\0', c->prompt_index - idx);
d1031 1
d1035 1
a1035 1
		wsep = " ";
d1038 2
a1039 2
		if (wsep == NULL)
			wsep = options_get_string(oo, "word-separators");
d1043 2
a1044 2
			c->prompt_index++;
			if (strchr(wsep, c->prompt_buffer[c->prompt_index]))
d1048 1
a1048 1
		/* Find the word right after the separation. */
d1050 2
a1051 2
			c->prompt_index++;
			if (!strchr(wsep, c->prompt_buffer[c->prompt_index]))
d1058 1
a1058 1
		wsep = " ";
d1061 2
a1062 2
		if (wsep == NULL)
			wsep = options_get_string(oo, "word-separators");
d1066 2
a1067 2
			c->prompt_index++;
			if (!strchr(wsep, c->prompt_buffer[c->prompt_index]))
d1073 2
a1074 2
			c->prompt_index++;
			if (strchr(wsep, c->prompt_buffer[c->prompt_index]))
d1086 1
a1086 1
		wsep = " ";
d1089 2
a1090 2
		if (wsep == NULL)
			wsep = options_get_string(oo, "word-separators");
d1094 2
a1095 2
			c->prompt_index--;
			if (!strchr(wsep, c->prompt_buffer[c->prompt_index]))
d1101 2
a1102 2
			c->prompt_index--;
			if (strchr(wsep, c->prompt_buffer[c->prompt_index])) {
d1116 2
a1117 2
		c->prompt_buffer = xstrdup(histstr);
		c->prompt_index = strlen(c->prompt_buffer);
d1125 2
a1126 2
		c->prompt_buffer = xstrdup(histstr);
		c->prompt_index = strlen(c->prompt_buffer);
d1135 1
a1135 1
			if (ch < 32 || ch == 127)
d1139 2
a1140 1
		c->prompt_buffer = xrealloc(c->prompt_buffer, size + n + 1);
d1142 4
a1145 1
			memcpy(c->prompt_buffer + c->prompt_index, bufdata, n);
d1147 1
a1147 1
			c->prompt_buffer[c->prompt_index] = '\0';
d1151 6
a1156 2
			    size + 1 - c->prompt_index);
			memcpy(c->prompt_buffer + c->prompt_index, bufdata, n);
d1167 4
a1170 3
			swapc = c->prompt_buffer[idx - 2];
			c->prompt_buffer[idx - 2] = c->prompt_buffer[idx - 1];
			c->prompt_buffer[idx - 1] = swapc;
d1176 4
a1179 3
		if (*c->prompt_buffer != '\0')
			status_prompt_add_history(c->prompt_buffer);
		if (c->prompt_callbackfn(c->prompt_data, c->prompt_buffer) == 0)
d1181 1
d1188 3
a1190 1
		if (key <= 0x1f || key >= 0x7f)
d1192 3
a1194 1
		c->prompt_buffer = xrealloc(c->prompt_buffer, size + 2);
d1197 3
a1199 2
			c->prompt_buffer[c->prompt_index++] = key;
			c->prompt_buffer[c->prompt_index] = '\0';
d1203 4
a1206 2
			    size + 1 - c->prompt_index);
			c->prompt_buffer[c->prompt_index++] = key;
d1210 4
a1213 2
			if (c->prompt_callbackfn(c->prompt_data,
			    c->prompt_buffer) == 0)
d1215 1
d1334 1
a1334 1
status_prompt_complete(struct session *sess, const char *s)
d1387 1
a1387 1
		RB_FOREACH(wl, winlinks, &sess->windows) {
@


1.150
log
@Allow repeat count to be specified in mode key tables with bind-key -R,
and set the default repeat count to 5 for WheelUp and WheelDown in
copy-mode.
@
text
@d1 1
a1 1
/* $OpenBSD: status.c,v 1.149 2016/06/06 07:23:36 nicm Exp $ */
d32 19
a50 19
char   *status_redraw_get_left(struct client *, time_t, struct grid_cell *,
	    size_t *);
char   *status_redraw_get_right(struct client *, time_t, struct grid_cell *,
	    size_t *);
char   *status_print(struct client *, struct winlink *, time_t,
	    struct grid_cell *);
char   *status_replace(struct client *, struct winlink *, const char *, time_t);
void	status_message_callback(int, short, void *);
void	status_timer_callback(int, short, void *);

const char *status_prompt_up_history(u_int *);
const char *status_prompt_down_history(u_int *);
void	status_prompt_add_history(const char *);

const char **status_prompt_complete_list(u_int *, const char *);
char   *status_prompt_complete_prefix(const char **, u_int);
char   *status_prompt_complete(struct session *, const char *);

char   *status_prompt_find_history_file(void);
d54 2
a55 2
char	**status_prompt_hlist;
u_int	  status_prompt_hsize;
d58 1
a58 1
char *
d147 1
a147 1
void
d210 1
a210 1
char *
d232 1
a232 1
char *
d496 1
a496 1
char *
d518 1
a518 1
char *
d610 1
a610 1
void
d1142 1
a1142 1
const char *
d1157 1
a1157 1
const char *
d1169 1
a1169 1
void
d1194 1
a1194 1
const char **
d1228 1
a1228 1
char *
d1249 1
a1249 1
char *
@


1.149
log
@Allow #[] in window-status-separator.
@
text
@d1 1
a1 1
/* $OpenBSD: status.c,v 1.148 2016/01/19 15:59:12 nicm Exp $ */
d821 1
a821 1
	switch (mode_key_lookup(&c->prompt_mdata, key, NULL)) {
@


1.148
log
@I no longer use my SourceForge address so replace it.
@
text
@d1 1
a1 1
/* $OpenBSD: status.c,v 1.147 2016/01/01 08:04:20 nicm Exp $ */
d260 2
a261 1
	size_t		 len;
d266 3
a268 1
		len = strlen(options_get_string(oo, "window-status-separator"));
d272 1
a272 1
		x -= wl->status_width + len;
d350 1
a350 1
		seplen = screen_write_strlen("%s", sep);
d365 1
a365 1
		screen_write_nputs(&ctx, -1, &stdgc, "%s", sep);
@


1.147
log
@Don't rely on a calculation wrapping when applying message-limit, and
break out of the loop early. From Nicolas Viennot.
@
text
@d1 1
a1 1
/* $OpenBSD: status.c,v 1.146 2015/12/11 16:37:21 nicm Exp $ */
d4 1
a4 1
 * Copyright (c) 2007 Nicholas Marriott <nicm@@users.sourceforge.net>
@


1.146
log
@Style nits and line wrapping of function declarations.
@
text
@d1 1
a1 1
/* $OpenBSD: status.c,v 1.145 2015/12/11 12:27:36 nicm Exp $ */
d550 1
a550 1
	u_int			 first, limit;
a566 1
	first = c->message_next - limit;
d568 2
a569 2
		if (msg->msg_num >= first)
			continue;
@


1.145
log
@Add cmdq as an argument to format_create and add a format for the
command name (will also be used for more later).
@
text
@d1 1
a1 1
/* $OpenBSD: status.c,v 1.144 2015/12/08 08:34:18 nicm Exp $ */
d1127 2
a1128 2
			if (c->prompt_callbackfn(
			    c->prompt_data, c->prompt_buffer) == 0)
@


1.144
log
@Remove format_create_flags and just pass flags to format_create.
@
text
@d1 1
a1 1
/* $OpenBSD: status.c,v 1.143 2015/11/22 18:28:01 tim Exp $ */
d503 1
a503 1
		ft = format_create(FORMAT_STATUS|FORMAT_FORCE);
d505 1
a505 1
		ft = format_create(FORMAT_STATUS);
d664 1
a664 1
	ft = format_create(0);
d725 1
a725 1
	ft = format_create(0);
@


1.143
log
@If display-time is set to 0, show status messages until a key is pressed;
OK nicm@@
@
text
@d1 1
a1 1
/* $OpenBSD: status.c,v 1.142 2015/11/20 12:01:19 nicm Exp $ */
d503 1
a503 1
		ft = format_create_flags(FORMAT_STATUS|FORMAT_FORCE);
d505 1
a505 1
		ft = format_create_flags(FORMAT_STATUS);
d664 1
a664 1
	ft = format_create();
d725 1
a725 1
	ft = format_create();
@


1.142
log
@Instead of separate tables for different types of options, give each
option a scope type (server, session, window) in one table.
@
text
@d1 1
a1 1
/* $OpenBSD: status.c,v 1.141 2015/11/18 14:27:44 nicm Exp $ */
d577 9
a585 7
	tv.tv_sec = delay / 1000;
	tv.tv_usec = (delay % 1000) * 1000L;

	if (event_initialized(&c->message_timer))
		evtimer_del(&c->message_timer);
	evtimer_set(&c->message_timer, status_message_callback, c);
	evtimer_add(&c->message_timer, &tv);
@


1.141
log
@Use __unused rather than rolling our own.
@
text
@d1 1
a1 1
/* $OpenBSD: status.c,v 1.140 2015/11/13 08:09:28 nicm Exp $ */
d1208 1
a1208 13
	for (oe = server_options_table; oe->name != NULL; oe++) {
		if (strncmp(oe->name, s, strlen(s)) == 0) {
			list = xreallocarray(list, (*size) + 1, sizeof *list);
			list[(*size)++] = oe->name;
		}
	}
	for (oe = session_options_table; oe->name != NULL; oe++) {
		if (strncmp(oe->name, s, strlen(s)) == 0) {
			list = xreallocarray(list, (*size) + 1, sizeof *list);
			list[(*size)++] = oe->name;
		}
	}
	for (oe = window_options_table; oe->name != NULL; oe++) {
@


1.140
log
@Long overdue change to the way we store cells in the grid: now, instead
of storing a full grid_cell with UTF-8 data and everything, store a new
type grid_cell_entry. This can either be the cell itself (for ASCII
cells), or an offset into an extended array (per line) for UTF-8
data.

This avoid a large (8 byte) overhead on non-UTF-8 cells (by far the
majority for most users) without the complexity of the shadow array we
had before. Grid memory without any UTF-8 is about half.

The disadvantage that cells can no longer be modified in place and need
to be copied out of the grid and back but it turned out to be lot less
complicated than I expected.
@
text
@d1 1
a1 1
/* $OpenBSD: status.c,v 1.139 2015/11/12 11:09:11 nicm Exp $ */
d148 1
a148 1
status_timer_callback(unused int fd, unused short events, void *arg)
d607 1
a607 1
status_message_callback(unused int fd, unused short event, void *data)
@


1.139
log
@Nuke the utf8 and status-utf8 options and make tmux only a UTF-8
terminal. We still support non-UTF-8 terminals outside tmux, but inside
it is always UTF-8 (as when the utf8 and status-utf8 options were on).
@
text
@d1 1
a1 1
/* $OpenBSD: status.c,v 1.138 2015/11/12 11:05:34 nicm Exp $ */
d749 1
a749 1
	struct grid_cell		gc, *gcp;
d792 3
a794 2
	gcp = grid_view_get_cell(c->status.grid, off, 0);
	gcp->attr ^= GRID_ATTR_REVERSE;
@


1.138
log
@Support UTF-8 key bindings by expanding the key type from int to
uint64_t and converting UTF-8 to Unicode on input and the reverse on
output. (This allows key bindings, there are still omissions - the
largest being that the various prompts do not accept UTF-8.)
@
text
@d1 1
a1 1
/* $OpenBSD: status.c,v 1.137 2015/10/27 15:58:42 nicm Exp $ */
d32 3
a34 1
char   *status_redraw_get_left(struct client *, time_t, int, struct grid_cell *,
a35 2
char   *status_redraw_get_right(struct client *, time_t, int,
	    struct grid_cell *, size_t *);
d211 2
a212 2
status_redraw_get_left(struct client *c, time_t t, int utf8flag,
    struct grid_cell *gc, size_t *size)
d225 1
a225 1
	leftlen = screen_write_cstrlen(utf8flag, "%s", left);
d233 2
a234 2
status_redraw_get_right(struct client *c, time_t t, int utf8flag,
    struct grid_cell *gc, size_t *size)
d247 1
a247 1
	rightlen = screen_write_cstrlen(utf8flag, "%s", right);
d289 1
a289 1
	int			larrow, rarrow, utf8flag;
a314 3
	/* Get UTF-8 flag. */
	utf8flag = options_get_number(s->options, "status-utf8");

d317 1
a317 1
	left = status_redraw_get_left(c, t, utf8flag, &lgc, &llen);
d319 1
a319 1
	right = status_redraw_get_right(c, t, utf8flag, &rgc, &rlen);
d340 1
a340 2
		wl->status_width =
		    screen_write_cstrlen(utf8flag, "%s", wl->status_text);
d347 1
a347 1
		seplen = screen_write_strlen(utf8flag, "%s", sep);
d357 2
a358 2
		screen_write_cnputs(&ctx,
		    -1, &wl->status_cell, utf8flag, "%s", wl->status_text);
d362 1
a362 1
		screen_write_nputs(&ctx, -1, &stdgc, utf8flag, "%s", sep);
d434 1
a434 1
		screen_write_cnputs(&ctx, llen, &lgc, utf8flag, "%s", left);
d452 1
a452 1
		screen_write_cnputs(&ctx, rlen, &rgc, utf8flag, "%s", right);
a622 1
	int				utf8flag;
d629 1
a629 3
	utf8flag = options_get_number(s->options, "status-utf8");

	len = screen_write_strlen(utf8flag, "%s", c->message_string);
d638 1
a638 1
	screen_write_nputs(&ctx, len, &gc, utf8flag, "%s", c->message_string);
a749 1
	int				utf8flag;
d756 1
a756 3
	utf8flag = options_get_number(s->options, "status-utf8");

	len = screen_write_strlen(utf8flag, "%s", c->prompt_string);
d770 1
a770 1
	screen_write_nputs(&ctx, len, &gc, utf8flag, "%s", c->prompt_string);
d774 1
a774 1
		size = screen_write_strlen(utf8flag, "%s", c->prompt_buffer);
d781 2
a782 2
		screen_write_nputs(
		    &ctx, left, &gc, utf8flag, "%s", c->prompt_buffer + off);
@


1.137
log
@Move struct options into options.c.
@
text
@d1 1
a1 1
/* $OpenBSD: status.c,v 1.136 2015/10/20 21:12:09 nicm Exp $ */
d815 1
a815 1
status_prompt_key(struct client *c, int key)
d1119 1
a1119 1
		if ((key & 0xff00) != 0 || key < 32 || key == 127)
@


1.136
log
@Use client pointer not file descriptor in logging.
@
text
@d1 1
a1 1
/* $OpenBSD: status.c,v 1.135 2015/09/14 10:25:52 nicm Exp $ */
d64 1
a64 1
	history_file = options_get_string(&global_options, "history-file");
d163 1
a163 1
	tv.tv_sec = options_get_number(&s->options, "status-interval");
d181 1
a181 1
	if (s != NULL && options_get_number(&s->options, "status"))
d201 1
a201 1
	if (!options_get_number(&s->options, "status"))
d204 1
a204 1
	if (options_get_number(&s->options, "status-position") == 0)
d219 1
a219 1
	style_apply_update(gc, &s->options, "status-left-style");
d221 1
a221 1
	template = options_get_string(&s->options, "status-left");
d224 1
a224 1
	*size = options_get_number(&s->options, "status-left-length");
d241 1
a241 1
	style_apply_update(gc, &s->options, "status-right-style");
d243 1
a243 1
	template = options_get_string(&s->options, "status-right");
d246 1
a246 1
	*size = options_get_number(&s->options, "status-right-length");
d264 1
a264 1
		oo = &wl->window->options;
d292 1
a292 1
	if (c->tty.sy == 0 || !options_get_number(&s->options, "status"))
d301 1
a301 1
	style_apply(&stdgc, &s->options, "status-style");
d316 1
a316 1
	utf8flag = options_get_number(&s->options, "status-utf8");
d349 1
a349 1
		oo = &wl->window->options;
d364 1
a364 1
		oo = &wl->window->options;
d464 1
a464 1
		switch (options_get_number(&s->options, "status-justify")) {
d523 1
a523 1
	struct options	*oo = &wl->window->options;
d556 1
a556 1
	limit = options_get_number(&global_options, "message-limit");
d580 1
a580 1
	delay = options_get_number(&c->session->options, "display-time");
d634 1
a634 1
	utf8flag = options_get_number(&s->options, "status-utf8");
d640 1
a640 1
	style_apply(&gc, &s->options, "message-style");
d689 1
a689 1
	keys = options_get_number(&c->session->options, "status-keys");
d764 1
a764 1
	utf8flag = options_get_number(&s->options, "status-utf8");
d773 1
a773 1
		style_apply(&gc, &s->options, "message-command-style");
d775 1
a775 1
		style_apply(&gc, &s->options, "message-style");
d818 1
a818 1
	struct options		*oo = &sess->options;
@


1.135
log
@Make refresh-client force update of jobs, from Sina Siadat.
@
text
@d1 1
a1 1
/* $OpenBSD: status.c,v 1.134 2015/08/29 09:25:00 nicm Exp $ */
d167 1
a167 1
	log_debug("client %d, status interval %d", c->ibuf.fd, (int)tv.tv_sec);
@


1.134
log
@Move struct paste_buffer out of tmux.h.
@
text
@d1 1
a1 1
/* $OpenBSD: status.c,v 1.133 2015/08/28 12:16:28 nicm Exp $ */
d506 4
a509 1
	ft = format_create_status(1);
@


1.133
log
@Run status update on a per-client timer at status-interval.
@
text
@d1 1
a1 1
/* $OpenBSD: status.c,v 1.132 2015/07/29 11:56:02 nicm Exp $ */
d818 1
a818 2
	const char		*histstr;
	const char		*wsep = NULL;
d820 1
a820 1
	size_t			 size, n, off, idx;
d1069 1
a1069 1
		if ((pb = paste_get_top()) == NULL)
d1071 3
a1073 2
		for (n = 0; n < pb->size; n++) {
			ch = (u_char) pb->data[n];
d1080 1
a1080 1
			memcpy(c->prompt_buffer + c->prompt_index, pb->data, n);
d1087 1
a1087 1
			memcpy(c->prompt_buffer + c->prompt_index, pb->data, n);
@


1.132
log
@status_out and associated data structures are no longer used.
@
text
@d1 1
a1 1
/* $OpenBSD: status.c,v 1.131 2015/07/28 15:18:10 nicm Exp $ */
d40 1
d146 49
d297 2
a298 4
	/* Update status timer. */
	if (gettimeofday(&c->status_timer, NULL) != 0)
		fatal("gettimeofday failed");
	t = c->status_timer.tv_sec;
@


1.131
log
@Tidy up the way terminals are described and move some structs out of tmux.h.
@
text
@d1 1
a1 1
/* $OpenBSD: status.c,v 1.130 2015/07/20 15:50:04 nicm Exp $ */
a142 10
}

/* Status output tree. */
RB_GENERATE(status_out_tree, status_out, entry, status_out_cmp);

/* Output tree comparison function. */
int
status_out_cmp(struct status_out *so1, struct status_out *so2)
{
	return (strcmp(so1->cmd, so2->cmd));
@


1.130
log
@Add an option (history-file) for a file to save/restore command prompt
history, from Olof-Joachim Frahm.
@
text
@d1 1
a1 1
/* $OpenBSD: status.c,v 1.129 2015/05/27 13:28:04 nicm Exp $ */
a38 1
void	status_replace1(char **, char **, char *, size_t);
@


1.129
log
@Move the jobs output cache into the formats code so that #() work more
generally (for example, again working in set-titles-string).
@
text
@d1 1
a1 1
/* $OpenBSD: status.c,v 1.128 2015/05/06 23:56:46 nicm Exp $ */
d50 2
d56 89
@


1.128
log
@Remove ARRAY_* from history and expand completion to complete a) layout
names and b) targets beginning with -t or -s.
@
text
@d1 1
a1 1
/* $OpenBSD: status.c,v 1.127 2015/04/25 18:33:59 nicm Exp $ */
a35 3
char   *status_find_job(struct client *, char **);
void	status_job_free(void *);
void	status_job_callback(struct job *);
d39 1
a39 1
void	status_replace1(struct client *, char **, char **, char *, size_t);
a367 67
/* Replace a single special sequence (prefixed by #). */
void
status_replace1(struct client *c, char **iptr, char **optr, char *out,
    size_t outsize)
{
	char	ch, tmp[256], *ptr, *endptr;
	size_t	ptrlen;
	long	limit;

	errno = 0;
	limit = strtol(*iptr, &endptr, 10);
	if ((limit == 0 && errno != EINVAL) ||
	    (limit == LONG_MIN && errno != ERANGE) ||
	    (limit == LONG_MAX && errno != ERANGE) ||
	    limit != 0)
		*iptr = endptr;
	if (limit <= 0)
		limit = LONG_MAX;

	switch (*(*iptr)++) {
	case '(':
		if ((ptr = status_find_job(c, iptr)) == NULL)
			return;
		goto do_replace;
	case '[':
		/*
		 * Embedded style, handled at display time. Leave present and
		 * skip input until ].
		 */
		ch = ']';
		goto skip_to;
	case '{':
		ptr = (char *) "#{";
		goto do_replace;
	default:
		xsnprintf(tmp, sizeof tmp, "#%c", *(*iptr - 1));
		ptr = tmp;
		goto do_replace;
	}

	return;

do_replace:
	ptrlen = strlen(ptr);
	if ((size_t) limit < ptrlen)
		ptrlen = limit;

	if (*optr + ptrlen >= out + outsize - 1)
		return;
	while (ptrlen > 0 && *ptr != '\0') {
		*(*optr)++ = *ptr++;
		ptrlen--;
	}

	return;

skip_to:
	*(*optr)++ = '#';

	(*iptr)--;	/* include ch */
	while (**iptr != ch && **iptr != '\0') {
		if (*optr >=  out + outsize - 1)
			break;
		*(*optr)++ = *(*iptr)++;
	}
}

a371 3
	static char		 out[BUFSIZ];
	char			 in[BUFSIZ], ch, *iptr, *optr, *expanded;
	size_t			 len;
d373 1
d378 2
a379 5
	len = strftime(in, sizeof in, fmt, localtime(&t));
	in[len] = '\0';

	iptr = in;
	optr = out;
d381 1
a381 4
	while (*iptr != '\0') {
		if (optr >= out + (sizeof out) - 1)
			break;
		ch = *iptr++;
a382 11
		if (ch != '#' || *iptr == '\0') {
			*optr++ = ch;
			continue;
		}
		status_replace1(c, &iptr, &optr, out, sizeof out);
	}
	*optr = '\0';

	ft = format_create();
	format_defaults(ft, c, NULL, wl, NULL);
	expanded = format_expand(ft, out);
a384 135
}

/* Figure out job name and get its result, starting it off if necessary. */
char *
status_find_job(struct client *c, char **iptr)
{
	struct status_out	*so, so_find;
	char   			*cmd;
	int			 lastesc;
	size_t			 len;

	if (**iptr == '\0')
		return (NULL);
	if (**iptr == ')') {		/* no command given */
		(*iptr)++;
		return (NULL);
	}

	cmd = xmalloc(strlen(*iptr) + 1);
	len = 0;

	lastesc = 0;
	for (; **iptr != '\0'; (*iptr)++) {
		if (!lastesc && **iptr == ')')
			break;		/* unescaped ) is the end */
		if (!lastesc && **iptr == '\\') {
			lastesc = 1;
			continue;	/* skip \ if not escaped */
		}
		lastesc = 0;
		cmd[len++] = **iptr;
	}
	if (**iptr == '\0')		/* no terminating ) */ {
		free(cmd);
		return (NULL);
	}
	(*iptr)++;			/* skip final ) */
	cmd[len] = '\0';

	/* First try in the new tree. */
	so_find.cmd = cmd;
	so = RB_FIND(status_out_tree, &c->status_new, &so_find);
	if (so != NULL && so->out != NULL) {
		free(cmd);
		return (so->out);
	}

	/* If not found at all, start the job and add to the tree. */
	if (so == NULL) {
		job_run(cmd, NULL, -1, status_job_callback, status_job_free, c);
		c->references++;

		so = xmalloc(sizeof *so);
		so->cmd = xstrdup(cmd);
		so->out = NULL;
		RB_INSERT(status_out_tree, &c->status_new, so);
	}

	/* Lookup in the old tree. */
	so_find.cmd = cmd;
	so = RB_FIND(status_out_tree, &c->status_old, &so_find);
	free(cmd);
	if (so != NULL)
		return (so->out);
	return (NULL);
}

/* Free job tree. */
void
status_free_jobs(struct status_out_tree *sotree)
{
	struct status_out	*so, *so_next;

	so_next = RB_MIN(status_out_tree, sotree);
	while (so_next != NULL) {
		so = so_next;
		so_next = RB_NEXT(status_out_tree, sotree, so);

		RB_REMOVE(status_out_tree, sotree, so);
		free(so->out);
		free(so->cmd);
		free(so);
	}
}

/* Update jobs on status interval. */
void
status_update_jobs(struct client *c)
{
	/* Free the old tree. */
	status_free_jobs(&c->status_old);

	/* Move the new to old. */
	memcpy(&c->status_old, &c->status_new, sizeof c->status_old);
	RB_INIT(&c->status_new);
}

/* Free status job. */
void
status_job_free(void *data)
{
	struct client	*c = data;

	c->references--;
}

/* Job has finished: save its result. */
void
status_job_callback(struct job *job)
{
	struct client		*c = job->data;
	struct status_out	*so, so_find;
	char			*line, *buf;
	size_t			 len;

	if (c->flags & CLIENT_DEAD)
		return;

	so_find.cmd = job->cmd;
	so = RB_FIND(status_out_tree, &c->status_new, &so_find);
	if (so == NULL || so->out != NULL)
		return;

	buf = NULL;
	if ((line = evbuffer_readline(job->event->input)) == NULL) {
		len = EVBUFFER_LENGTH(job->event->input);
		buf = xmalloc(len + 1);
		if (len != 0)
			memcpy(buf, EVBUFFER_DATA(job->event->input), len);
		buf[len] = '\0';
	} else
		buf = line;

	so->out = buf;
	server_status_client(c);
@


1.127
log
@Make message log a TAILQ.
@
text
@d1 1
a1 1
/* $OpenBSD: status.c,v 1.126 2015/04/24 22:19:36 nicm Exp $ */
d48 4
a51 1
char   *status_prompt_complete(const char *);
d54 3
a56 1
ARRAY_DECL(, char *) status_prompt_history = ARRAY_INITIALIZER;
d985 1
a985 1
		if ((s = status_prompt_complete(word)) == NULL)
a1242 2
	u_int size;

d1244 2
a1245 3
	 * History runs from 0 to size - 1.
	 *
	 * Index is from 0 to size. Zero is empty.
d1248 1
a1248 2
	size = ARRAY_LENGTH(&status_prompt_history);
	if (size == 0 || *idx == size)
d1251 1
a1251 1
	return (ARRAY_ITEM(&status_prompt_history, size - *idx));
d1258 1
a1258 4
	u_int size;

	size = ARRAY_LENGTH(&status_prompt_history);
	if (size == 0 || *idx == 0)
d1263 1
a1263 1
	return (ARRAY_ITEM(&status_prompt_history, size - *idx));
d1270 1
a1270 1
	u_int size;
d1272 2
a1273 2
	size = ARRAY_LENGTH(&status_prompt_history);
	if (size > 0 && strcmp(ARRAY_LAST(&status_prompt_history), line) == 0)
d1276 2
a1277 4
	if (size == PROMPT_HISTORY) {
		free(ARRAY_FIRST(&status_prompt_history));
		ARRAY_REMOVE(&status_prompt_history, 0);
	}
d1279 2
a1280 2
	ARRAY_ADD(&status_prompt_history, xstrdup(line));
}
d1282 3
a1284 10
/* Complete word. */
char *
status_prompt_complete(const char *s)
{
	const struct cmd_entry 	  	       **cmdent;
	const struct options_table_entry	*oe;
	ARRAY_DECL(, const char *)		 list;
	char					*prefix, *s2;
	u_int					 i;
	size_t				 	 j;
d1286 16
a1301 2
	if (*s == '\0')
		return (NULL);
d1303 1
a1303 2
	/* First, build a list of all the possible matches. */
	ARRAY_INIT(&list);
d1305 4
a1308 2
		if (strncmp((*cmdent)->name, s, strlen(s)) == 0)
			ARRAY_ADD(&list, (*cmdent)->name);
d1311 4
a1314 2
		if (strncmp(oe->name, s, strlen(s)) == 0)
			ARRAY_ADD(&list, oe->name);
d1317 4
a1320 2
		if (strncmp(oe->name, s, strlen(s)) == 0)
			ARRAY_ADD(&list, oe->name);
d1323 31
a1353 2
		if (strncmp(oe->name, s, strlen(s)) == 0)
			ARRAY_ADD(&list, oe->name);
d1355 2
d1358 12
a1369 3
	/* If none, bail now. */
	if (ARRAY_LENGTH(&list) == 0) {
		ARRAY_FREE(&list);
d1371 21
a1391 1
	}
d1393 29
a1421 6
	/* If an exact match, return it, with a trailing space. */
	if (ARRAY_LENGTH(&list) == 1) {
		xasprintf(&s2, "%s ", ARRAY_FIRST(&list));
		ARRAY_FREE(&list);
		return (s2);
	}
d1423 32
a1454 11
	/* Now loop through the list and find the longest common prefix. */
	prefix = xstrdup(ARRAY_FIRST(&list));
	for (i = 1; i < ARRAY_LENGTH(&list); i++) {
		s = ARRAY_ITEM(&list, i);

		j = strlen(s);
		if (j > strlen(prefix))
			j = strlen(prefix);
		for (; j > 0; j--) {
			if (prefix[j - 1] != s[j - 1])
				prefix[j - 1] = '\0';
d1457 17
a1473 3

	ARRAY_FREE(&list);
	return (prefix);
@


1.126
log
@Set working directory for run-shell and if-shell.
@
text
@d1 1
a1 1
/* $OpenBSD: status.c,v 1.125 2015/04/19 21:34:21 nicm Exp $ */
d639 1
a639 1
	struct message_entry	*msg;
d642 3
a644 1
	u_int			 i, limit;
d653 1
a653 2
	ARRAY_EXPAND(&c->message_log, 1);
	msg = &ARRAY_LAST(&c->message_log);
d655 1
d657 1
d659 7
a665 8
	limit = options_get_number(&global_options, "message-limit");
	if (ARRAY_LENGTH(&c->message_log) > limit) {
		limit = ARRAY_LENGTH(&c->message_log) - limit;
		for (i = 0; i < limit; i++) {
			msg = &ARRAY_FIRST(&c->message_log);
			free(msg->msg);
			ARRAY_REMOVE(&c->message_log, 0);
		}
@


1.125
log
@Rewrite of tmux mouse support which was a mess. Instead of having
options for "mouse-this" and "mouse-that", mouse events may be bound as
keys and there is one option "mouse" that turns on mouse support
entirely (set -g mouse on).

See the new MOUSE SUPPORT section of the man page for description of the
key names and new flags (-t= to specify the pane or window under mouse
as a target, and send-keys -M to pass through a mouse event).

The default builtin bindings for the mouse are:

    bind -n   MouseDown1Pane select-pane -t=; send-keys -M
    bind -n MouseDown1Status select-window -t=
    bind -n   MouseDrag1Pane copy-mode -M
    bind -n MouseDrag1Border resize-pane -M

To get the effect of turning mode-mouse off, do:

    unbind -n MouseDrag1Pane
    unbind -temacs-copy MouseDrag1Pane

The old mouse options are now gone, set-option -q may be used to
suppress warnings if mixing configuration files.
@
text
@d1 1
a1 1
/* $OpenBSD: status.c,v 1.124 2015/02/06 23:28:52 nicm Exp $ */
d518 1
a518 1
		job_run(cmd, NULL, status_job_callback, status_job_free, c);
@


1.124
log
@Use the same time for both calls to format_expand_time.
@
text
@d1 1
a1 1
/* $OpenBSD: status.c,v 1.123 2015/02/06 17:21:08 nicm Exp $ */
d121 3
a123 3
/* Set window at window list position. */
void
status_set_window_at(struct client *c, u_int x)
d133 1
d135 2
a136 3
		len = strlen(options_get_string(oo, "window-status-separator"));
		if (x < wl->status_width && session_select(s, wl->idx) == 0)
			server_redraw_session(s);
d139 1
@


1.123
log
@status_replace can now become local to status.c and it no longer needs
the jobsflag argument. While here there is no need to repeat work that
format_defaults already does.
@
text
@d1 1
a1 1
/* $OpenBSD: status.c,v 1.122 2015/02/06 17:11:39 nicm Exp $ */
d761 1
a761 1
	c->prompt_string = format_expand_time(ft, msg, time(NULL));
d763 1
a763 1
	c->prompt_buffer = format_expand_time(ft, input, time(NULL));
d820 1
a820 1
	c->prompt_string = format_expand_time(ft, msg, time(NULL));
d823 1
a823 1
	c->prompt_buffer = format_expand_time(ft, input, time(NULL));
@


1.122
log
@Add format_expand_time and use it instead of status_replace where
command execution is not needed.
@
text
@d1 1
a1 1
/* $OpenBSD: status.c,v 1.121 2015/02/05 10:29:43 nicm Exp $ */
d32 4
a35 4
char   *status_redraw_get_left(
	    struct client *, time_t, int, struct grid_cell *, size_t *);
char   *status_redraw_get_right(
	    struct client *, time_t, int, struct grid_cell *, size_t *);
d39 4
a42 3
char   *status_print(
	    struct client *, struct winlink *, time_t, struct grid_cell *);
void	status_replace1(struct client *, char **, char **, char *, size_t, int);
d90 1
a90 1
	left = status_replace(c, NULL, template , t, 1);
d112 1
a112 1
	right = status_replace(c, NULL, template, t, 1);
d368 1
a368 1
    size_t outsize, int jobsflag)
a385 4
		if (!jobsflag) {
			ch = ')';
			goto skip_to;
		}
d434 1
a434 2
status_replace(struct client *c, struct winlink *wl, const char *fmt, time_t t,
    int jobsflag)
a435 2
	struct session		*s = NULL;
	struct window_pane	*wp = NULL;
a443 7
	if (c != NULL)
		s = c->session;
	if (wl == NULL && s != NULL)
		wl = s->curw;
	if (wl != NULL)
		wp = wl->window->active;

d459 1
a459 1
		status_replace1(c, &iptr, &optr, out, sizeof out, jobsflag);
d464 1
a464 1
	format_defaults(ft, c, s, wl, wp);
d629 1
a629 1
	text = status_replace(c, wl, fmt, t, 1);
@


1.121
log
@Wrap all the individual format_* calls in a single format_defaults
functions.
@
text
@d1 1
a1 1
/* $OpenBSD: status.c,v 1.120 2015/02/01 23:43:23 nicm Exp $ */
d763 7
a769 1
	int	keys;
d774 1
a774 1
	c->prompt_string = status_replace(c, NULL, msg, time(NULL), 0);
d776 1
a776 1
	c->prompt_buffer = status_replace(c, NULL, input, time(NULL), 0);
d795 2
d825 7
d833 1
a833 1
	c->prompt_string = status_replace(c, NULL, msg, time(NULL), 0);
d836 1
a836 1
	c->prompt_buffer = status_replace(c, NULL, input, time(NULL), 0);
d842 2
@


1.120
log
@Remove two unused arguments from status_replace.
@
text
@d1 1
a1 1
/* $OpenBSD: status.c,v 1.119 2015/01/20 10:57:10 sthen Exp $ */
d477 1
a477 8
	if (c != NULL)
		format_client(ft, c);
	if (s != NULL)
		format_session(ft, s);
	if (s != NULL && wl != NULL)
		format_winlink(ft, s, wl);
	if (wp != NULL)
		format_window_pane(ft, wp);
@


1.119
log
@typo in comment ;)  ok nicm
@
text
@d1 1
a1 1
/* $OpenBSD: status.c,v 1.118 2014/11/05 23:15:11 nicm Exp $ */
d78 2
a79 2
status_redraw_get_left(struct client *c,
    time_t t, int utf8flag, struct grid_cell *gc, size_t *size)
d82 1
d88 2
a89 2
	left = status_replace(c, NULL,
	    NULL, NULL, options_get_string(&s->options, "status-left"), t, 1);
d100 2
a101 2
status_redraw_get_right(struct client *c,
    time_t t, int utf8flag, struct grid_cell *gc, size_t *size)
d104 1
d110 2
a111 2
	right = status_replace(c, NULL,
	    NULL, NULL, options_get_string(&s->options, "status-right"), t, 1);
d437 2
a438 2
status_replace(struct client *c, struct session *s, struct winlink *wl,
    struct window_pane *wp, const char *fmt, time_t t, int jobsflag)
d440 2
d450 1
a450 1
	if (s == NULL && c != NULL)
d454 1
a454 1
	if (wp == NULL && wl != NULL)
d627 2
a628 2
status_print(
    struct client *c, struct winlink *wl, time_t t, struct grid_cell *gc)
d649 1
a649 1
	text = status_replace(c, NULL, wl, NULL, fmt, t, 1);
d775 1
a775 2
	c->prompt_string = status_replace(c, NULL, NULL, NULL, msg,
	    time(NULL), 0);
d777 1
a777 2
	c->prompt_buffer = status_replace(c, NULL, NULL, NULL, input,
	    time(NULL), 0);
d825 1
a825 2
	c->prompt_string = status_replace(c, NULL, NULL, NULL, msg,
	    time(NULL), 0);
d828 1
a828 2
	c->prompt_buffer = status_replace(c, NULL, NULL, NULL, input,
	    time(NULL), 0);
@


1.118
log
@Do not put a space between status-left/status-right and the window list,
instead move the space into the defaults for the options (so status-left
now defaults to "[#S] ". From Balazs Kezes.
@
text
@d1 1
a1 1
/* $OpenBSD: status.c,v 1.117 2014/10/20 23:57:14 nicm Exp $ */
d331 1
a331 1
		case 1:	/* centered */
@


1.117
log
@Better format for printf format attributes.
@
text
@d1 1
a1 1
/* $OpenBSD: status.c,v 1.116 2014/10/08 17:35:58 nicm Exp $ */
d196 1
a196 1
		needed += llen + 1;
d198 1
a198 1
		needed += rlen + 1;
d303 1
a303 1
	if (llen != 0) {
a304 2
		screen_write_putc(&ctx, &stdgc, ' ');
	}
d314 1
a314 1
		screen_write_cursormove(&ctx, c->tty.sx - rlen - 2, 0);
d320 2
a321 3
		screen_write_cursormove(&ctx, c->tty.sx - rlen - 1, 0);
	if (rlen != 0) {
		screen_write_putc(&ctx, &stdgc, ' ');
a322 1
	}
d326 1
a326 1
		wloffset = llen + 1;
@


1.116
log
@Add xreallocarray and remove nmemb argument from xrealloc.
@
text
@d1 1
a1 1
/* $OpenBSD: status.c,v 1.115 2014/10/02 10:39:43 nicm Exp $ */
d654 1
a654 1
void printflike2
@


1.115
log
@Take account of window-status-separator when checking window position,
based on diff from Balazs Kezes.
@
text
@d1 1
a1 1
/* $OpenBSD: status.c,v 1.114 2014/04/24 09:14:43 nicm Exp $ */
d995 1
a995 1
		c->prompt_buffer = xrealloc(c->prompt_buffer, 1, size + 1);
d1173 1
a1173 1
		c->prompt_buffer = xrealloc(c->prompt_buffer, 1, size + n + 1);
d1213 1
a1213 1
		c->prompt_buffer = xrealloc(c->prompt_buffer, 1, size + 2);
@


1.114
log
@There is no longer a need for a paste_stack struct or for global_buffers
to be global. Move to paste.c.
@
text
@d1 1
a1 1
/* $OpenBSD: status.c,v 1.113 2014/04/17 07:36:45 nicm Exp $ */
d124 2
d129 3
d134 1
a134 1
		x -= wl->status_width + 1;
@


1.113
log
@Remove the monitor-content option and associated bits and bobs. It's
never worked very well. If there is a big demand for it to return, will
consider better ways to do it.
@
text
@d1 1
a1 1
/* $OpenBSD: status.c,v 1.112 2014/04/02 17:08:23 nicm Exp $ */
d1160 1
a1160 1
		if ((pb = paste_get_top(&global_buffers)) == NULL)
@


1.112
log
@Do not replace ## with # in status_replace1 because it'll be done later
by the format code.
@
text
@d1 1
a1 1
/* $OpenBSD: status.c,v 1.111 2014/03/31 21:41:35 nicm Exp $ */
a640 2
	else if (wl->flags & WINLINK_CONTENT)
		style_apply_update(gc, oo, "window-status-content-style");
@


1.111
log
@Make message-limit a server option.
@
text
@d1 1
a1 1
/* $OpenBSD: status.c,v 1.110 2014/02/14 13:59:01 nicm Exp $ */
a398 3
	case '#':
		*(*optr)++ = '#';
		break;
@


1.110
log
@Style nit - no space between function name and bracket.
@
text
@d1 1
a1 1
/* $OpenBSD: status.c,v 1.109 2014/02/14 12:37:54 nicm Exp $ */
a657 1
	struct session		*s = c->session;
d675 1
a675 4
	if (s == NULL)
		limit = 0;
	else
		limit = options_get_number(&s->options, "message-limit");
@


1.109
log
@Check for NULL session and whatnot in status_replace, from Thomas Adam.
@
text
@d1 1
a1 1
/* $OpenBSD: status.c,v 1.108 2014/01/28 23:07:09 nicm Exp $ */
d693 1
a693 1
	if (event_initialized (&c->message_timer))
@


1.108
log
@Allow replacing each of the many sets of separate foo-{fg,bg,attr}
options with a single foo-style option. For example:

    set -g status-fg yellow
    set -g status-bg red
    set -g status-attr blink

Becomes:

    set -g status-style fg=yellow,bg=red,blink

The -a flag to set can be used to add to rather than replace a style. So:

    set -g status-bg red

Becomes:

    set -ag status-style bg=red

Currently this is fully backwards compatible (all *-{fg,bg,attr} options
remain) but the plan is to deprecate them over time.

From Tiago Cunha.
@
text
@d1 1
a1 1
/* $OpenBSD: status.c,v 1.107 2013/07/05 14:44:06 nicm Exp $ */
d448 1
a448 1
	if (s == NULL)
d450 1
a450 1
	if (wl == NULL)
d452 1
a452 1
	if (wp == NULL)
d475 8
a482 4
	format_client(ft, c);
	format_session(ft, s);
	format_winlink(ft, s, wl);
	format_window_pane(ft, wp);
@


1.107
log
@Whitespace nits, from Ben Boeckel.
@
text
@d1 1
a1 1
/* $OpenBSD: status.c,v 1.106 2013/07/05 14:41:36 nicm Exp $ */
a82 1
	int		 fg, bg, attr;
d85 1
a85 9
	fg = options_get_number(&s->options, "status-left-fg");
	if (fg != 8)
		colour_set_fg(gc, fg);
	bg = options_get_number(&s->options, "status-left-bg");
	if (bg != 8)
		colour_set_bg(gc, bg);
	attr = options_get_number(&s->options, "status-left-attr");
	if (attr != 0)
		gc->attr = attr;
a103 1
	int		 fg, bg, attr;
d106 1
a106 9
	fg = options_get_number(&s->options, "status-right-fg");
	if (fg != 8)
		colour_set_fg(gc, fg);
	bg = options_get_number(&s->options, "status-right-bg");
	if (bg != 8)
		colour_set_bg(gc, bg);
	attr = options_get_number(&s->options, "status-right-attr");
	if (attr != 0)
		gc->attr = attr;
d162 1
a162 4
	memcpy(&stdgc, &grid_default_cell, sizeof gc);
	colour_set_fg(&stdgc, options_get_number(&s->options, "status-fg"));
	colour_set_bg(&stdgc, options_get_number(&s->options, "status-bg"));
	stdgc.attr |= options_get_number(&s->options, "status-attr");
a627 1
	int		 fg, bg, attr;
d629 1
a629 9
	fg = options_get_number(oo, "window-status-fg");
	if (fg != 8)
		colour_set_fg(gc, fg);
	bg = options_get_number(oo, "window-status-bg");
	if (bg != 8)
		colour_set_bg(gc, bg);
	attr = options_get_number(oo, "window-status-attr");
	if (attr != 0)
		gc->attr = attr;
d632 1
a632 9
		fg = options_get_number(oo, "window-status-current-fg");
		if (fg != 8)
			colour_set_fg(gc, fg);
		bg = options_get_number(oo, "window-status-current-bg");
		if (bg != 8)
			colour_set_bg(gc, bg);
		attr = options_get_number(oo, "window-status-current-attr");
		if (attr != 0)
			gc->attr = attr;
d635 9
a643 43
	if (wl == TAILQ_FIRST(&s->lastw)) {
		fg = options_get_number(oo, "window-status-last-fg");
		if (fg != 8)
			colour_set_fg(gc, fg);
		bg = options_get_number(oo, "window-status-last-bg");
		if (bg != 8)
			colour_set_bg(gc, bg);
		attr = options_get_number(oo, "window-status-last-attr");
		if (attr != 0)
			gc->attr = attr;
	}

	if (wl->flags & WINLINK_BELL) {
		fg = options_get_number(oo, "window-status-bell-fg");
		if (fg != 8)
			colour_set_fg(gc, fg);
		bg = options_get_number(oo, "window-status-bell-bg");
		if (bg != 8)
			colour_set_bg(gc, bg);
		attr = options_get_number(oo, "window-status-bell-attr");
		if (attr != 0)
			gc->attr = attr;
	} else if (wl->flags & WINLINK_CONTENT) {
		fg = options_get_number(oo, "window-status-content-fg");
		if (fg != 8)
			colour_set_fg(gc, fg);
		bg = options_get_number(oo, "window-status-content-bg");
		if (bg != 8)
			colour_set_bg(gc, bg);
		attr = options_get_number(oo, "window-status-content-attr");
		if (attr != 0)
			gc->attr = attr;
	} else if (wl->flags & (WINLINK_ACTIVITY|WINLINK_SILENCE)) {
		fg = options_get_number(oo, "window-status-activity-fg");
		if (fg != 8)
			colour_set_fg(gc, fg);
		bg = options_get_number(oo, "window-status-activity-bg");
		if (bg != 8)
			colour_set_bg(gc, bg);
		attr = options_get_number(oo, "window-status-activity-attr");
		if (attr != 0)
			gc->attr = attr;
	}
d745 1
a745 4
	memcpy(&gc, &grid_default_cell, sizeof gc);
	colour_set_fg(&gc, options_get_number(&s->options, "message-fg"));
	colour_set_bg(&gc, options_get_number(&s->options, "message-bg"));
	gc.attr |= options_get_number(&s->options, "message-attr");
a862 2
	memcpy(&gc, &grid_default_cell, sizeof gc);

d864 4
a867 9
	if (c->prompt_mdata.mode == 1) {
		colour_set_fg(&gc, options_get_number(&s->options, "message-command-fg"));
		colour_set_bg(&gc, options_get_number(&s->options, "message-command-bg"));
		gc.attr |= options_get_number(&s->options, "message-command-attr");
	} else {
		colour_set_fg(&gc, options_get_number(&s->options, "message-fg"));
		colour_set_bg(&gc, options_get_number(&s->options, "message-bg"));
		gc.attr |= options_get_number(&s->options, "message-attr");
	}
@


1.106
log
@Act like vi(1) when moving words, from Ben Boeckel.
@
text
@d1 1
a1 1
/* $OpenBSD: status.c,v 1.105 2013/07/05 14:38:22 nicm Exp $ */
d145 1
a145 2
		if (x < wl->status_width &&
			session_select(s, wl->idx) == 0) {
a146 1
		}
@


1.105
log
@Implement s, S, C mode switch commands in vi(1) mode, from Ben Boeckel.
@
text
@d1 1
a1 1
/* $OpenBSD: status.c,v 1.104 2013/05/31 19:56:05 nicm Exp $ */
d941 1
d1196 5
@


1.104
log
@Demote the old single-character replacement variables (#S and friends)
to aliases of formats. From Tiago Cunha.
@
text
@d1 1
a1 1
/* $OpenBSD: status.c,v 1.103 2013/03/25 11:43:01 nicm Exp $ */
d1102 1
d1111 1
d1117 1
@


1.103
log
@Extend jobs to support writing and use that for copy-pipe instead of
popen, from Chris Johnsen.
@
text
@d1 1
a1 1
/* $OpenBSD: status.c,v 1.102 2013/03/22 15:55:22 nicm Exp $ */
d41 1
a41 2
void	status_replace1(struct client *, struct session *, struct winlink *,
	    struct window_pane *, char **, char **, char *, size_t, int);
d386 1
a386 2
status_replace1(struct client *c, struct session *s, struct winlink *wl,
    struct window_pane *wp, char **iptr, char **optr, char *out,
d389 1
a389 1
	char	ch, tmp[256], *ptr, *endptr, *freeptr;
a391 1
	u_int	idx;
a402 2
	freeptr = NULL;

a411 39
	case 'D':
		xsnprintf(tmp, sizeof tmp, "%%%u", wp->id);
		ptr = tmp;
		goto do_replace;
	case 'H':
		if (gethostname(tmp, sizeof tmp) != 0)
			fatal("gethostname failed");
		ptr = tmp;
		goto do_replace;
	case 'h':
		if (gethostname(tmp, sizeof tmp) != 0)
			fatal("gethostname failed");
		if ((ptr = strchr(tmp, '.')) != NULL)
			*ptr = '\0';
		ptr = tmp;
		goto do_replace;
	case 'I':
		xsnprintf(tmp, sizeof tmp, "%d", wl->idx);
		ptr = tmp;
		goto do_replace;
	case 'P':
		if (window_pane_index(wp, &idx) != 0)
			fatalx("index not found");
		xsnprintf(tmp, sizeof tmp, "%u", idx);
		ptr = tmp;
		goto do_replace;
	case 'S':
		ptr = s->name;
		goto do_replace;
	case 'T':
		ptr = wp->base.title;
		goto do_replace;
	case 'W':
		ptr = wl->window->name;
		goto do_replace;
	case 'F':
		ptr = window_printable_flags(s, wl);
		freeptr = ptr;
		goto do_replace;
d425 4
d439 1
a439 1
		goto out;
a444 2
out:
	free(freeptr);
d493 1
a493 2
		status_replace1(
		    c, s, wl, wp, &iptr, &optr, out, sizeof out, jobsflag);
@


1.102
log
@evbuffer_readline returns allocated storage, don't leak it.
@
text
@d1 1
a1 1
/* $OpenBSD: status.c,v 1.101 2013/03/22 15:52:40 nicm Exp $ */
d597 1
a597 1
		job_run(cmd, status_job_callback, status_job_free, c);
@


1.101
log
@Add copy-pipe mode command to copy selection and also pipe to a command.
@
text
@d1 1
a1 1
/* $OpenBSD: status.c,v 1.100 2013/03/22 10:31:22 nicm Exp $ */
d679 1
a679 1
		buf = xstrdup(line);
@


1.100
log
@No more lint means no more ARGSUSED.
@
text
@d1 1
a1 1
/* $OpenBSD: status.c,v 1.99 2013/03/21 16:25:08 nicm Exp $ */
d1045 1
a1045 1
	switch (mode_key_lookup(&c->prompt_mdata, key)) {
@


1.99
log
@Aargh. Spaces -> tabs.
@
text
@d1 1
a1 1
/* $OpenBSD: status.c,v 1.98 2013/03/21 16:24:03 nicm Exp $ */
a831 1
/* ARGSUSED */
@


1.98
log
@Do not leak formats in status_replace.
@
text
@d1 1
a1 1
/* $OpenBSD: status.c,v 1.97 2013/03/21 16:14:09 nicm Exp $ */
d545 3
a547 3
    expanded = format_expand(ft, out);
    format_free(ft);
    return (expanded);
@


1.97
log
@Add a format client_prefix which is 1 if prefix key has been
pressed, used for example #{?client_prefix,X,Y}. Also a few extra
server_client_status needed.
@
text
@d1 1
a1 1
/* $OpenBSD: status.c,v 1.96 2013/03/21 16:13:24 nicm Exp $ */
d506 1
a506 1
	char			 in[BUFSIZ], ch, *iptr, *optr;
d545 3
a547 1
	return (format_expand(ft, out));
@


1.96
log
@Allow formats in status options.
@
text
@d1 1
a1 1
/* $OpenBSD: status.c,v 1.95 2012/11/27 13:52:23 nicm Exp $ */
d440 1
a440 2
		xsnprintf(
		    tmp, sizeof tmp, "%u", idx);
d541 1
@


1.95
log
@Add window-status-last-* options, from Boris Faure.
@
text
@d1 1
a1 1
/* $OpenBSD: status.c,v 1.94 2012/07/10 11:53:01 nicm Exp $ */
a395 7
	if (s == NULL)
		s = c->session;
	if (wl == NULL)
		wl = s->curw;
	if (wp == NULL)
		wp = wl->window->active;

d464 3
d506 4
a509 3
	static char	out[BUFSIZ];
	char		in[BUFSIZ], ch, *iptr, *optr;
	size_t		len;
d514 7
d541 5
a545 1
	return (xstrdup(out));
@


1.94
log
@xfree is not particularly helpful, remove it. From Thomas Adam.
@
text
@d1 1
a1 1
/* $OpenBSD: status.c,v 1.93 2012/07/09 09:55:57 nicm Exp $ */
d707 11
@


1.93
log
@Move a NULL check inside a function, from Tiago Cunha.
@
text
@d1 1
a1 1
/* $OpenBSD: status.c,v 1.92 2012/04/29 07:33:41 nicm Exp $ */
d225 1
a225 2
		if (wl->status_text != NULL)
			xfree(wl->status_text);
d374 2
a375 4
	if (left != NULL)
		xfree(left);
	if (right != NULL)
		xfree(right);
d491 1
a491 2
	if (freeptr != NULL)
		xfree(freeptr);
d571 1
a571 1
		xfree(cmd);
d581 1
a581 1
		xfree(cmd);
d599 1
a599 1
	xfree(cmd);
d617 3
a619 4
		if (so->out != NULL)
			xfree(so->out);
		xfree(so->cmd);
		xfree(so);
d776 1
a776 1
			xfree(msg->msg);
d801 1
a801 1
	xfree(c->message_string);
d910 1
a910 1
	xfree(c->prompt_string);
d913 1
a913 1
	xfree(c->prompt_buffer);
d926 1
a926 1
	xfree(c->prompt_string);
d930 1
a930 1
	xfree(c->prompt_buffer);
d1107 1
a1107 1
		xfree(s);
d1248 1
a1248 1
		xfree(c->prompt_buffer);
d1257 1
a1257 1
		xfree(c->prompt_buffer);
d1381 1
a1381 1
		xfree(ARRAY_FIRST(&status_prompt_history));
@


1.92
log
@Use int not u_char for colours from options since they may have bit 8
set to mark them as 256-colour. Reported by Chris Johnson.
@
text
@d1 1
a1 1
/* $OpenBSD: status.c,v 1.91 2012/04/23 22:23:14 nicm Exp $ */
d518 3
a882 2
	if (input == NULL)
		input = "";
a935 2
	if (input == NULL)
		input = "";
@


1.91
log
@Add window-status-separator option, from Thomas Adam.
@
text
@d1 1
a1 1
/* $OpenBSD: status.c,v 1.90 2012/03/17 18:24:07 nicm Exp $ */
d84 1
a84 1
	u_char		 fg, bg, attr;
d114 1
a114 1
	u_char		 fg, bg, attr;
d686 1
a686 1
	u_char		 fg, bg, attr;
@


1.90
log
@Check event_initialized before event_del if event may not have been set
up; libevent2 complains about this. Reported by Moriyoshi Koizumi.
@
text
@d1 1
a1 1
/* $OpenBSD: status.c,v 1.89 2012/03/04 07:38:11 nicm Exp $ */
d163 1
d165 1
a165 1
	char		       *left, *right;
d168 1
a168 1
	size_t			llen, rlen;
d234 5
a238 1
		wlwidth += wl->status_width + 1;
d249 4
a252 1
		screen_write_putc(&ctx, &stdgc, ' ');
@


1.89
log
@Add A and I keys for vi status line editing.
@
text
@d1 1
a1 1
/* $OpenBSD: status.c,v 1.88 2012/03/03 08:55:56 nicm Exp $ */
d779 2
a780 1
	evtimer_del(&c->message_timer);
@


1.88
log
@The wlmouse offset should be part of the client, not the server. From
Ailin Nemui.
@
text
@d1 1
a1 1
/* $OpenBSD: status.c,v 1.87 2012/01/29 09:37:02 nicm Exp $ */
d1041 3
d1050 3
@


1.87
log
@Add an option to move the status line to the top of the screen,
requested by many.
@
text
@d1 1
a1 1
/* $OpenBSD: status.c,v 1.86 2012/01/26 09:05:54 nicm Exp $ */
d144 1
a144 1
	x += s->wlmouse;
d359 1
a359 1
	s->wlmouse = -wloffset + wlstart;
@


1.86
log
@Terminate strftime buffer properly even if a really long format string
is given, from Tiago Cunha.
@
text
@d1 1
a1 1
/* $OpenBSD: status.c,v 1.85 2012/01/26 09:03:09 nicm Exp $ */
d61 14
@


1.85
log
@Fix memory leak in error path, from Tiago Cunha.
@
text
@d1 1
a1 1
/* $OpenBSD: status.c,v 1.84 2012/01/20 19:51:28 nicm Exp $ */
d494 1
d496 2
a497 2
	strftime(in, sizeof in, fmt, localtime(&t));
	in[(sizeof in) - 1] = '\0';
@


1.84
log
@Add some trivial additional status line attributes from jwcxz at users
dot sourceforge dot net.
@
text
@d1 1
a1 1
/* $OpenBSD: status.c,v 1.83 2012/01/20 19:10:29 nicm Exp $ */
d465 1
a465 1
		return;
d471 1
@


1.83
log
@Add space movement keys for vi mode in the status line from Ben Boeckel.
@
text
@d1 1
a1 1
/* $OpenBSD: status.c,v 1.82 2011/12/01 20:42:31 nicm Exp $ */
d687 2
a688 2
	if (wl->flags & WINLINK_ALERTFLAGS) {
		fg = options_get_number(oo, "window-status-alert-fg");
d691 1
a691 1
		bg = options_get_number(oo, "window-status-alert-bg");
d694 21
a714 1
		attr = options_get_number(oo, "window-status-alert-attr");
@


1.82
log
@Make M-f and M-b work the same at the command prompt as in copy mode,
pointed out by Romain Francoise.
@
text
@d1 1
a1 1
/* $OpenBSD: status.c,v 1.81 2011/11/15 23:34:12 nicm Exp $ */
d981 1
a981 1
	const char		*wsep;
d1127 3
d1131 2
a1132 1
		wsep = options_get_string(oo, "word-separators");
d1150 3
d1154 2
a1155 1
		wsep = options_get_string(oo, "word-separators");
d1173 3
d1177 2
a1178 1
		wsep = options_get_string(oo, "word-separators");
@


1.81
log
@Add word movement and editing command for command prompt editing, from
Ben Boeckel.
@
text
@d1 1
a1 1
/* $OpenBSD: status.c,v 1.80 2011/11/15 23:19:51 nicm Exp $ */
d1159 1
a1159 3
			if (strchr(wsep, c->prompt_buffer[c->prompt_index])) {
				/* Go back to the word. */
				c->prompt_index--;
a1160 1
			}
@


1.80
log
@Make window_pane_index work the same as window_index, from Ben Boeckel.
@
text
@d1 1
a1 1
/* $OpenBSD: status.c,v 1.79 2011/11/05 09:06:31 nicm Exp $ */
d976 2
d979 3
a981 2
	char   			*s, *first, *last, word[64], swapc;
	const char              *histstr;
d1098 92
d1194 1
a1194 1
	       	xfree(c->prompt_buffer);
@


1.79
log
@Option to change status line (message) background when using vi keys and
in command mode. From Ben Boeckel.
@
text
@d1 1
a1 1
/* $OpenBSD: status.c,v 1.78 2011/08/20 20:37:31 nicm Exp $ */
d375 1
d426 2
d429 1
a429 1
		    tmp, sizeof tmp, "%u", window_pane_index(wl->window, wp));
@


1.78
log
@Fix a couple of memory leaks, from marcel partap.
@
text
@d1 1
a1 1
/* $OpenBSD: status.c,v 1.77 2011/07/08 06:37:57 nicm Exp $ */
d922 10
a931 3
	colour_set_fg(&gc, options_get_number(&s->options, "message-fg"));
	colour_set_bg(&gc, options_get_number(&s->options, "message-bg"));
	gc.attr |= options_get_number(&s->options, "message-attr");
d987 3
d991 2
@


1.77
log
@Make confirm-before prompt customizable with -p option like
command-prompt. Also move responsibility for calling status_replace into
status_prompt_{set,update} and add #W and #P to the default kill-window
and kill-pane prompts. By Tiago Cunha.
@
text
@d1 1
a1 1
/* $OpenBSD: status.c,v 1.76 2011/07/02 21:05:44 nicm Exp $ */
d554 2
a555 1
	if (so != NULL && so->out != NULL)
d557 1
@


1.76
log
@Allow the initial context on prompts to be set with the new -I option to
command-prompt. From Tiago Cunha.
@
text
@d1 1
a1 1
/* $OpenBSD: status.c,v 1.75 2011/04/29 07:07:31 nicm Exp $ */
d827 2
a828 1
	c->prompt_string = xstrdup(msg);
d830 4
a833 4
	if (input != NULL)
		c->prompt_buffer = xstrdup(input);
	else
		c->prompt_buffer = xstrdup("");
d881 2
a882 1
	c->prompt_string = xstrdup(msg);
d885 4
a888 4
	if (input != NULL)
		c->prompt_buffer = xstrdup(input);
	else
		c->prompt_buffer = xstrdup("");
@


1.75
log
@Only redraw the status line on command update, not the entire client
(big DOH).
@
text
@d1 1
a1 1
/* $OpenBSD: status.c,v 1.74 2011/04/24 21:32:07 nicm Exp $ */
d818 1
a818 1
status_prompt_set(struct client *c, const char *msg,
d829 5
a833 2
	c->prompt_buffer = xstrdup("");
	c->prompt_index = 0;
d877 1
a877 1
status_prompt_update(struct client *c, const char *msg)
d882 6
a887 2
	*c->prompt_buffer = '\0';
	c->prompt_index = 0;
@


1.74
log
@Provide #h for short hostname (no domain) from Michal Mazurek.
@
text
@d1 1
a1 1
/* $OpenBSD: status.c,v 1.73 2011/04/18 19:49:05 nicm Exp $ */
d645 1
a645 1
	server_redraw_client(c);
@


1.73
log
@Add an option (mouse-select-window) which allows the mouse to be used by
clicking on the status line, written by hsim at gmx dot li.
@
text
@d1 1
a1 1
/* $OpenBSD: status.c,v 1.72 2011/03/29 19:30:16 nicm Exp $ */
d411 7
@


1.72
log
@Change -t on display-message to be target-pane for the #[A-Z]
replacements and add -c as target-client.
@
text
@d1 1
a1 1
/* $OpenBSD: status.c,v 1.71 2011/01/26 01:54:56 nicm Exp $ */
d123 17
d345 1
@


1.71
log
@Simplify the way jobs work and drop the persist type, so all jobs are
fire-and-forget.

Status jobs now managed with two trees of output (new and old), rather
than storing the output in the jobs themselves. When the status line is
processed any jobs which don't appear in the new tree are started and
the output from the old tree displayed. When a job finishes it updates
the new tree with its output and that is used for any subsequent
redraws. When the status interval expires, the new tree is moved to the
old so that all jobs are run again.

This fixes the "#(echo %H:%M:%S)" problem which would lead to thousands
of identical persistent jobs and high memory use (this can still be
achieved by adding "sleep 30" but that is much less likely to happen by
accident).
@
text
@d1 1
a1 1
/* $OpenBSD: status.c,v 1.70 2011/01/03 21:30:49 nicm Exp $ */
d41 2
a42 2
void	status_replace1(struct client *,
	    struct winlink *, char **, char **, char *, size_t, int);
d83 2
a84 2
	left = status_replace(
	    c, NULL, options_get_string(&s->options, "status-left"), t, 1);
d113 2
a114 2
	right = status_replace(
	    c, NULL, options_get_string(&s->options, "status-right"), t, 1);
d350 7
a356 7
status_replace1(struct client *c,struct winlink *wl,
    char **iptr, char **optr, char *out, size_t outsize, int jobsflag)
{
	struct session *s = c->session;
	char		ch, tmp[256], *ptr, *endptr, *freeptr;
	size_t		ptrlen;
	long		limit;
d358 2
d362 2
d386 4
d400 2
a401 2
		xsnprintf(tmp, sizeof tmp, "%u",
		    window_pane_index(wl->window, wl->window->active));
d408 1
a408 1
		ptr = wl->window->active->base.title;
d460 2
a461 2
status_replace(struct client *c,
    struct winlink *wl, const char *fmt, time_t t, int jobsflag)
d481 2
a482 1
		status_replace1(c, wl, &iptr, &optr, out, sizeof out, jobsflag);
d669 1
a669 1
	text = status_replace(c, wl, fmt, t, 1);
@


1.70
log
@Handle a # at the end of a replacement string (such as status-left)
correctly. Found by Thomas Adam.
@
text
@d1 1
a1 1
/* $OpenBSD: status.c,v 1.69 2011/01/01 16:51:21 nicm Exp $ */
d36 2
a37 1
char   *status_job(struct client *, char **);
d53 10
d379 1
a379 1
		if ((ptr = status_job(c, iptr)) == NULL)
a380 1
		freeptr = ptr;
d482 1
a482 1
status_job(struct client *c, char **iptr)
d484 4
a487 4
	struct job	*job;
	char   		*cmd;
	int		 lastesc;
	size_t		 len;
d517 42
a558 5
	job = job_get(&c->status_jobs, cmd);
	if (job == NULL) {
		job = job_add(&c->status_jobs,
		    JOB_PERSIST, c, cmd, status_job_callback, xfree, NULL);
		job_run(job);
d560 21
a580 4
	xfree(cmd);
	if (job->data == NULL)
		return (xstrdup(""));
	return (xstrdup(job->data));
d587 12
a598 2
	char	*line, *buf;
	size_t	 len;
d607 2
a608 6
	}

	if (job->data != NULL)
		xfree(job->data);
	else
		server_redraw_client(job->client);
d610 2
a611 4
	if (line == NULL)
		job->data = buf;
	else
		job->data = xstrdup(line);
@


1.69
log
@Move the user-visible parts of all options (names, types, limit, default
values) together into one set of tables in options-table.c. Also clean
up and simplify cmd-set-options.c and move a common print function into
option-table.c.
@
text
@d1 1
a1 1
/* $OpenBSD: status.c,v 1.68 2010/12/30 23:16:18 nicm Exp $ */
d459 1
a459 1
		if (ch != '#') {
@


1.68
log
@Change from a per-session stack of buffers to one global stack which is
much more convenient and also simplifies lot of code. This renders
copy-buffer useless and makes buffer-limit now a server option.

By Tiago Cunha.
@
text
@d1 1
a1 1
/* $OpenBSD: status.c,v 1.67 2010/12/30 21:35:17 nicm Exp $ */
d1115 6
a1120 6
	const struct cmd_entry 	      **cmdent;
	const struct set_option_entry  *entry;
	ARRAY_DECL(, const char *)	list;
	char			       *prefix, *s2;
	u_int				i;
	size_t			 	j;
d1131 11
a1141 11
	for (entry = set_option_table; entry->name != NULL; entry++) {
		if (strncmp(entry->name, s, strlen(s)) == 0)
			ARRAY_ADD(&list, entry->name);
	}
	for (entry = set_session_option_table; entry->name != NULL; entry++) {
		if (strncmp(entry->name, s, strlen(s)) == 0)
			ARRAY_ADD(&list, entry->name);
	}
	for (entry = set_window_option_table; entry->name != NULL; entry++) {
		if (strncmp(entry->name, s, strlen(s)) == 0)
			ARRAY_ADD(&list, entry->name);
@


1.67
log
@Add a function to create window flags rather than doing the same thing
in two places. From Thomas Adam.
@
text
@d1 1
a1 1
/* $OpenBSD: status.c,v 1.66 2010/12/11 16:13:15 nicm Exp $ */
d986 1
a986 1
		if ((pb = paste_get_top(&c->session->buffers)) == NULL)
@


1.66
log
@Oops, these functions return a const char *, so make the local variable
const as well.
@
text
@d1 1
a1 1
/* $OpenBSD: status.c,v 1.65 2010/12/11 16:05:57 nicm Exp $ */
d396 2
a397 15
		tmp[0] = ' ';
		if (wl->flags & WINLINK_CONTENT)
			tmp[0] = '+';
		else if (wl->flags & WINLINK_BELL)
			tmp[0] = '!';
		else if (wl->flags & WINLINK_ACTIVITY)
			tmp[0] = '#';
		else if (wl->flags & WINLINK_SILENCE)
			tmp[0] = '~';
		else if (wl == s->curw)
			tmp[0] = '*';
		else if (wl == TAILQ_FIRST(&s->lastw))
			tmp[0] = '-';
		tmp[1] = '\0';
		ptr = tmp;
@


1.65
log
@Make the prompt history global for all clients which is much more useful than per-client history.
@
text
@d1 1
a1 1
/* $OpenBSD: status.c,v 1.64 2010/12/06 22:51:02 nicm Exp $ */
d868 1
d981 2
a982 2
		s = status_prompt_up_history(&c->prompt_hindex);
		if (s == NULL)
d985 1
a985 1
		c->prompt_buffer = xstrdup(s);
d990 2
a991 2
		s = status_prompt_down_history(&c->prompt_hindex);
		if (s == NULL)
d994 1
a994 1
		c->prompt_buffer = xstrdup(s);
@


1.64
log
@Add an option to alert (monitor) for silence (lack of activity) in a
window. From Thomas Adam.
@
text
@d1 1
a1 1
/* $OpenBSD: status.c,v 1.63 2010/06/21 01:27:46 nicm Exp $ */
d44 3
a46 1
void	status_prompt_add_history(struct client *);
d49 3
d980 2
a981 1
		if (ARRAY_LENGTH(&c->prompt_hdata) == 0)
d984 1
a984 6

		c->prompt_buffer = xstrdup(ARRAY_ITEM(&c->prompt_hdata,
		    ARRAY_LENGTH(&c->prompt_hdata) - 1 - c->prompt_hindex));
		if (c->prompt_hindex != ARRAY_LENGTH(&c->prompt_hdata) - 1)
			c->prompt_hindex++;

d989 3
d993 1
a993 9

		if (c->prompt_hindex != 0) {
			c->prompt_hindex--;
			c->prompt_buffer = xstrdup(ARRAY_ITEM(
			    &c->prompt_hdata, ARRAY_LENGTH(
			    &c->prompt_hdata) - 1 - c->prompt_hindex));
		} else
			c->prompt_buffer = xstrdup("");

d1035 1
a1035 1
			status_prompt_add_history(c);
d1071 34
d1107 1
a1107 1
status_prompt_add_history(struct client *c)
d1109 4
a1112 2
	if (ARRAY_LENGTH(&c->prompt_hdata) > 0 &&
	    strcmp(ARRAY_LAST(&c->prompt_hdata), c->prompt_buffer) == 0)
d1115 3
a1117 3
	if (ARRAY_LENGTH(&c->prompt_hdata) == PROMPT_HISTORY) {
		xfree(ARRAY_FIRST(&c->prompt_hdata));
		ARRAY_REMOVE(&c->prompt_hdata, 0);
d1120 1
a1120 1
	ARRAY_ADD(&c->prompt_hdata, xstrdup(c->prompt_buffer));
@


1.63
log
@Having a list of winlinks->alerts for each session is stupid, just store
the alert flags directly in the winlink itself.
@
text
@d1 1
a1 1
/* $OpenBSD: status.c,v 1.62 2010/05/14 19:03:09 nicm Exp $ */
d398 2
@


1.62
log
@Colour+attribute options for status line alerts, from Alex Alexander.
@
text
@d1 1
a1 1
/* $OpenBSD: status.c,v 1.61 2010/03/31 18:05:14 nicm Exp $ */
d251 3
a253 8
		if (larrow == 1 && offset < wlstart) {
			if (session_alert_has(s, wl, WINDOW_ACTIVITY))
				larrow = -1;
			else if (session_alert_has(s, wl, WINDOW_BELL))
				larrow = -1;
			else if (session_alert_has(s, wl, WINDOW_CONTENT))
				larrow = -1;
		}
d257 3
a259 8
		if (rarrow == 1 && offset > wlstart + wlwidth) {
			if (session_alert_has(s, wl, WINDOW_ACTIVITY))
				rarrow = -1;
			else if (session_alert_has(s, wl, WINDOW_BELL))
				rarrow = -1;
			else if (session_alert_has(s, wl, WINDOW_CONTENT))
				rarrow = -1;
		}
d392 1
a392 1
		if (session_alert_has(s, wl, WINDOW_CONTENT))
d394 1
a394 1
		else if (session_alert_has(s, wl, WINDOW_BELL))
d396 1
a396 1
		else if (session_alert_has(s, wl, WINDOW_ACTIVITY))
d586 1
a586 3
	if (session_alert_has(s, wl, WINDOW_ACTIVITY) ||
	    session_alert_has(s, wl, WINDOW_BELL) ||
	    session_alert_has(s, wl, WINDOW_CONTENT)) {
@


1.61
log
@Don't accept keys with modifiers as input. Fixes crash reported by Brian
R Landy.
@
text
@d1 1
a1 1
/* $OpenBSD: status.c,v 1.60 2010/03/27 15:06:40 nicm Exp $ */
d598 11
a608 2
	    session_alert_has(s, wl, WINDOW_CONTENT))
		gc->attr ^= GRID_ATTR_REVERSE;
@


1.60
log
@Don't leak job command in #().
@
text
@d1 1
a1 1
/* $OpenBSD: status.c,v 1.59 2010/03/22 19:18:46 nicm Exp $ */
d1049 1
a1049 1
		if (key < 32 || key == 127)
@


1.59
log
@Dead functions, lint.
@
text
@d1 1
a1 1
/* $OpenBSD: status.c,v 1.58 2010/01/27 20:26:42 nicm Exp $ */
d529 1
@


1.58
log
@Calculate offset correctly, fixes incorrect offset and prevents crash when
status-left is empty. From Micah Cowan.
@
text
@d1 1
a1 1
/* $OpenBSD: status.c,v 1.57 2010/01/26 21:36:53 nicm Exp $ */
a37 1
size_t	status_width(struct client *, struct winlink *, time_t);
a558 24
}

/* Calculate winlink status line entry width. */
size_t
status_width(struct client *c, struct winlink *wl, time_t t)
{
	struct options	*oo = &wl->window->options;
	struct session	*s = c->session;
	const char	*fmt;
	char		*text;
	size_t		 size;
	int		 utf8flag;

	utf8flag = options_get_number(&s->options, "status-utf8");

	fmt = options_get_string(&wl->window->options, "window-status-format");
	if (wl == s->curw)
		fmt = options_get_string(oo, "window-status-current-format");

	text = status_replace(c, wl, fmt, t, 1);
	size = screen_write_cstrlen(utf8flag, "%s", text);
	xfree(text);

	return (size);
@


1.57
log
@Actually use the copy made when no newline is found, from martynas@@.
@
text
@d1 1
a1 1
/* $OpenBSD: status.c,v 1.56 2009/12/14 10:47:11 nicm Exp $ */
d305 4
a308 1
	wloffset = 1;
d312 1
a312 1
			wloffset = 1 + (wlavailable - wlwidth) / 2;
d315 1
a315 1
			wloffset = 1 + (wlavailable - wlwidth);
a318 1
	wloffset += llen;
@


1.56
log
@Add server options to completion as well.
@
text
@d1 1
a1 1
/* $OpenBSD: status.c,v 1.55 2009/12/03 22:50:10 nicm Exp $ */
a552 1
	job->data = xstrdup(line);
d554 4
a557 2
	if (buf != NULL)
		xfree(buf);
@


1.55
log
@Massive spaces->tabs and trailing whitespace cleanup, hopefully for the last
time now I've configured emacs to make them displayed in really annoying
colours...
@
text
@d1 1
a1 1
/* $OpenBSD: status.c,v 1.54 2009/12/03 17:44:02 nicm Exp $ */
d1132 4
@


1.54
log
@Eliminate duplicate code and ease the passage for server-wide options by adding
a -w flag to set-option and show-options and making setw and showw aliases to
set -w and show -w.

Note: setw and showw are still there, but now aliases for set -w and show -w.
@
text
@d1 1
a1 1
/* $OpenBSD: status.c,v 1.53 2009/11/26 22:28:24 nicm Exp $ */
d40 1
a40 1
    	    struct client *, struct winlink *, time_t, struct grid_cell *);
d42 1
a42 1
    	    struct winlink *, char **, char **, char *, size_t, int);
d166 1
a166 1
        needed = 0;
d182 1
a182 1
		wl->status_width = 
d196 1
a196 1
 		screen_write_cnputs(&ctx,
d230 1
a230 1
		
d274 1
a274 1
 	/* Begin drawing. */
d323 1
a323 1
 	screen_free(&window_list);
d358 1
a358 1
	    (limit == LONG_MAX && errno != ERANGE) || 
d415 1
a415 1
		/* 
d427 1
a427 1
	
d782 1
a782 1
 	if (c->prompt_string == NULL)
d860 2
a861 2
 		for (i = len + size; i < c->tty.sx; i++)
 			screen_write_putc(&ctx, &gc, ' ');
d952 1
a952 1
 		size += strlen(s);
d954 1
a954 1
 		c->prompt_buffer = xrealloc(c->prompt_buffer, 1, size + 1);
d956 2
a957 2
 		memmove(first + strlen(s), first, n);
 		memcpy(first, s, strlen(s));
d977 1
a977 1
 	case MODEKEYEDIT_DELETE:
d1059 1
a1059 1
 	case MODEKEYEDIT_ENTER:
@


1.53
log
@Tidy up various bits of the paste code, make the data buffer char * and add
comments.
@
text
@d1 1
a1 1
/* $OpenBSD: status.c,v 1.52 2009/11/26 21:37:13 nicm Exp $ */
d1118 1
a1118 1
	const struct set_option_entry  *optent;
d1133 7
a1139 7
	for (optent = set_option_table; optent->name != NULL; optent++) {
		if (strncmp(optent->name, s, strlen(s)) == 0)
			ARRAY_ADD(&list, optent->name);
	}
	for (optent = set_window_option_table; optent->name != NULL; optent++) {
		if (strncmp(optent->name, s, strlen(s)) == 0)
			ARRAY_ADD(&list, optent->name);
@


1.52
log
@Remove a couple of unused arguments where possible, and add /* ARGSUSED */ to
the rest to reduce lint output.
@
text
@d1 1
a1 1
/* $OpenBSD: status.c,v 1.51 2009/11/20 07:01:12 nicm Exp $ */
d885 1
d1027 2
a1028 1
			if (pb->data[n] < 32 || pb->data[n] == 127)
@


1.51
log
@Display UTF-8 properly in status line messages and prompt. Cursor handling is
still way off though.
@
text
@d1 1
a1 1
/* $OpenBSD: status.c,v 1.50 2009/11/20 06:33:26 nicm Exp $ */
d691 1
@


1.50
log
@Remove oldest messages from log when limit is hit, not newest.
@
text
@d1 1
a1 1
/* $OpenBSD: status.c,v 1.49 2009/11/19 21:30:53 nicm Exp $ */
d708 1
d715 3
a717 1
	len = strlen(c->message_string);
d729 1
a729 1
	screen_write_puts(&ctx, &gc, "%.*s", (int) len, c->message_string);
d818 1
a818 1
	struct screen_write_ctx	ctx;
d822 2
a823 2
	char				ch;
	struct grid_cell		gc;
a828 1
	off = 0;
d830 3
a832 1
	len = strlen(c->prompt_string);
d835 1
d845 1
a845 1
	screen_write_puts(&ctx, &gc, "%.*s", (int) len, c->prompt_string);
d849 2
a850 3
		if (c->prompt_index < left)
			size = strlen(c->prompt_buffer);
		else {
d852 1
a852 1
			if (c->prompt_index == strlen(c->prompt_buffer))
d856 2
a857 2
		screen_write_puts(
		    &ctx, &gc, "%.*s", (int) left, c->prompt_buffer + off);
d859 2
a860 10
		for (i = len + size; i < c->tty.sx; i++)
			screen_write_putc(&ctx, &gc, ' ');

		/* Draw a fake cursor. */
		ch = ' ';
		screen_write_cursormove(&ctx, len + c->prompt_index - off, 0);
		if (c->prompt_index < strlen(c->prompt_buffer))
			ch = c->prompt_buffer[c->prompt_index];
		gc.attr ^= GRID_ATTR_REVERSE;
		screen_write_putc(&ctx, &gc, ch);
d864 5
@


1.49
log
@Get some brackets in the right place so ## works. Also fix a space in a
comment.
@
text
@d1 1
a1 1
/* $OpenBSD: status.c,v 1.48 2009/11/19 19:47:28 nicm Exp $ */
d653 7
a659 4
	for (i = ARRAY_LENGTH(&c->message_log); i > limit; i--) {
		msg = &ARRAY_ITEM(&c->message_log, i - 1);
		xfree(msg->msg);
		ARRAY_REMOVE(&c->message_log, i - 1);
@


1.48
log
@Change status line drawing to create the window list in a separate screen and
then copy it into the status line screen. This allows UTF-8 in window names and
fixes some problems with #[] in window-status-format.
@
text
@d1 1
a1 1
/* $OpenBSD: status.c,v 1.47 2009/11/19 16:22:10 nicm Exp $ */
d124 1
a124 1
	/* No status line?*/
d422 1
a422 1
		*(*optr++) = '#';
@


1.47
log
@Two new options, window-status-format and window-status-current-format, which
allow the format of each window in the status line window list to be controlled
using similar # sequences as status-left/right.

This diff also moves part of the way towards UTF-8 support in window names but
it isn't quite there yet.
@
text
@d1 1
a1 1
/* $OpenBSD: status.c,v 1.46 2009/11/19 11:38:54 nicm Exp $ */
d32 4
d48 60
d112 11
a122 13
	struct screen_write_ctx		ctx;
	struct session		       *s = c->session;
	struct winlink		       *wl;
	struct screen		      	old_status;
	char		 	       *left, *right, *text, *ptr;
	size_t				llen, llen2, rlen, rlen2, offset;
	size_t				ox, xx, yy, size, start, width;
	struct grid_cell	        stdgc, sl_stdgc, sr_stdgc, gc;
	int				larrow, rarrow, utf8flag;
	int				sl_fg, sl_bg, sr_fg, sr_bg;
	int				sl_attr, sr_attr;

	left = right = NULL;
d127 1
d130 1
a130 4
	/* Create the target screen. */
	memcpy(&old_status, &c->status, sizeof old_status);
	screen_init(&c->status, c->tty.sx, 1, 0);

d133 3
d141 11
a151 29
	/* 
	 * Set the status-left and status-right parts to the default status
	 * line options and only change them where they differ from the
	 * defaults.
	 */
	memcpy(&sl_stdgc, &stdgc, sizeof sl_stdgc);
	memcpy(&sr_stdgc, &stdgc, sizeof sr_stdgc);
	sl_fg = options_get_number(&s->options, "status-left-fg");
	if (sl_fg != 8)
		colour_set_fg(&sl_stdgc, sl_fg);
	sl_bg = options_get_number(&s->options, "status-left-bg");
	if (sl_bg != 8)
		colour_set_bg(&sl_stdgc, sl_bg);
	sl_attr = options_get_number(&s->options, "status-left-attr");
	if (sl_attr != 0)
		sl_stdgc.attr = sl_attr;
	sr_fg = options_get_number(&s->options, "status-right-fg");
	if (sr_fg != 8)
		colour_set_fg(&sr_stdgc, sr_fg);
	sr_bg = options_get_number(&s->options, "status-right-bg");
	if (sr_bg != 8)
		colour_set_bg(&sr_stdgc, sr_bg);
	sr_attr = options_get_number(&s->options, "status-right-attr");
	if (sr_attr != 0)
		sr_stdgc.attr = sr_attr;

	yy = c->tty.sy - 1;
	if (yy == 0)
		goto blank;
d153 1
a153 1
	/* Caring about UTF-8 in status line? */
d156 5
a160 14
	/* Work out the left and right strings. */
	left = status_replace(c, NULL, options_get_string(
	    &s->options, "status-left"), c->status_timer.tv_sec, 1);
	llen = options_get_number(&s->options, "status-left-length");
	llen2 = screen_write_cstrlen(utf8flag, "%s", left);
	if (llen2 < llen)
		llen = llen2;

	right = status_replace(c, NULL, options_get_string(
	    &s->options, "status-right"), c->status_timer.tv_sec, 1);
	rlen = options_get_number(&s->options, "status-right-length");
	rlen2 = screen_write_cstrlen(utf8flag, "%s", right);
	if (rlen2 < rlen)
		rlen = rlen2;
d163 2
a164 2
	 * Figure out how much space we have for the window list. If there isn't
	 * enough space, just wimp out.
d166 1
a166 1
	xx = 0;
d168 1
a168 1
		xx += llen + 1;
d170 4
a173 4
		xx += rlen + 1;
	if (c->tty.sx == 0 || c->tty.sx <= xx)
		goto blank;
	xx = c->tty.sx - xx;
d175 2
a176 5
	/*
	 * Right. We have xx characters to fill. Find out how much is to go in
	 * them and the offset of the current window (it must be on screen).
	 */
	width = offset = 0;
d178 7
a184 1
		size = status_width(c, wl, c->status_timer.tv_sec) + 1;
d186 13
a198 2
			offset = width;
		width += size;
d200 1
a200 1
	start = 0;
d202 2
a203 2
	/* If there is enough space for the total width, all is gravy. */
	if (width <= xx)
d207 1
a207 1
	size = status_width(c, s->curw, c->status_timer.tv_sec);
d210 1
a210 1
	 * If the offset is already on screen, we're good to draw from the
d213 20
a232 2
	if (offset + size < xx) {
		if (xx > 0) {
d234 2
a235 1
			xx--;
d237 2
d240 4
a243 2
		width = xx;
		goto draw;
d247 2
a248 3
	 * Work out how many characters we need to omit from the start. There
	 * are xx characters to fill, and offset + size must be the last. So,
	 * the start character is offset + size - xx.
a249 49
	if (xx > 0) {
		larrow = 1;
		xx--;
	}

	start = offset + size - xx;
 	if (xx > 0 && width > start + xx + 1) { /* + 1, eh? */
 		rarrow = 1;
 		start++;
 		xx--;
 	}
 	width = xx;

draw:
	/* Bail here if anything is too small too. XXX. */
	if (width == 0 || xx == 0)
		goto blank;

 	/* Begin drawing and move to the starting position. */
	screen_write_start(&ctx, NULL, &c->status);
	if (llen != 0) {
 		screen_write_cursormove(&ctx, 0, yy);
		screen_write_cnputs(&ctx, llen, &sl_stdgc, utf8flag, "%s", left);
		screen_write_putc(&ctx, &stdgc, ' ');
		if (larrow)
			screen_write_putc(&ctx, &stdgc, ' ');
	} else {
		if (larrow)
			screen_write_cursormove(&ctx, 1, yy);
		else
			screen_write_cursormove(&ctx, 0, yy);
	}

	ox = 0;
	if (width < xx) {
		switch (options_get_number(&s->options, "status-justify")) {
		case 1:	/* centered */
			ox = 1 + (xx - width) / 2;
			break;
		case 2:	/* right */
			ox = 1 + (xx - width);
			break;
		}
		xx -= ox;
		while (ox-- > 0)
			screen_write_putc(&ctx, &stdgc, ' ');
	}

	/* Draw each character in succession. */
d252 1
a252 4
		memcpy(&gc, &stdgc, sizeof gc);
		text = status_print(c, wl, c->status_timer.tv_sec, &gc);

		if (larrow == 1 && offset < start) {
d261 1
a261 8
		ptr = text;
		for (; offset < start; offset++)
			ptr++;	/* XXX should skip UTF-8 characters */
		if (offset < start + width) {
			screen_write_cnputs(&ctx, 
			    start + width - offset, &gc, utf8flag, "%s", text);
			offset += screen_write_cstrlen(utf8flag, "%s", text);
		}
d263 1
a263 1
		if (rarrow == 1 && offset > start + width) {
a270 9

		if (offset < start + width) {
			if (offset >= start) {
				screen_write_putc(&ctx, &stdgc, ' ');
			}
			offset++;
		}

		xfree(text);
d273 3
a275 3
	/* Fill the remaining space if any. */
 	while (offset++ < xx)
		screen_write_putc(&ctx, &stdgc, ' ');
d277 4
a280 3
	/* Draw the last item. */
	if (rlen != 0) {
		screen_write_cursormove(&ctx, c->tty.sx - rlen - 1, yy);
a281 1
		screen_write_cnputs(&ctx, rlen, &sr_stdgc, utf8flag, "%s", right);
a282 2

	/* Draw the arrows. */
a286 4
		if (llen != 0)
			screen_write_cursormove(&ctx, llen + 1, yy);
		else
			screen_write_cursormove(&ctx, 0, yy);
d289 2
d292 1
a295 4
		if (rlen != 0)
			screen_write_cursormove(&ctx, c->tty.sx - rlen - 2, yy);
		else
			screen_write_cursormove(&ctx, c->tty.sx - 1, yy);
d297 5
d304 20
a323 1
	goto out;
d325 1
a325 6
blank:
 	/* Just draw the whole line as blank. */
	screen_write_start(&ctx, NULL, &c->status);
	screen_write_cursormove(&ctx, 0, yy);
	for (offset = 0; offset < c->tty.sx; offset++)
		screen_write_putc(&ctx, &stdgc, ' ');
a327 2
	screen_write_stop(&ctx);

@


1.46
log
@Tidy up by breaking the # replacement code into a separate function, also add a
few comments.
@
text
@d1 1
a1 1
/* $OpenBSD: status.c,v 1.45 2009/11/19 10:22:07 nicm Exp $ */
d34 5
a38 4
size_t	status_width(struct winlink *);
char   *status_print(struct session *, struct winlink *, struct grid_cell *);
void	status_replace1(
	    struct client *, char **, char **, char *, size_t, int);
d112 1
a112 1
	left = status_replace(c, options_get_string(
d119 1
a119 1
	right = status_replace(c, options_get_string(
d145 1
a145 1
		size = status_width(wl) + 1;
d157 1
a157 1
	size = status_width(s->curw);
d230 1
a230 1
		text = status_print(s, wl, &gc);
d241 7
a247 4
 		for (ptr = text; *ptr != '\0'; ptr++) {
			if (offset >= start && offset < start + width)
				screen_write_putc(&ctx, &gc, *ptr);
			offset++;
d329 1
a329 1
status_replace1(struct client *c,
a332 1
	struct winlink *wl = s->curw;
d337 3
d385 15
d443 2
a444 1
status_replace(struct client *c, const char *fmt, time_t t, int jobsflag)
d448 1
a448 1
	
d464 1
a464 1
		status_replace1(c, &iptr, &optr, out, sizeof out, jobsflag);
d547 1
a547 1
status_width(struct winlink *wl)
d549 18
a566 1
	return (xsnprintf(NULL, 0, "%d:%s ", wl->idx, wl->window->name));
d571 2
a572 1
status_print(struct session *s, struct winlink *wl, struct grid_cell *gc)
d575 3
a577 1
	char   		*text, flag;
d589 1
a589 4

	flag = ' ';
 	if (wl == TAILQ_FIRST(&s->lastw))
		flag = '-';
d600 1
a600 1
		flag = '*';
d603 3
a605 5
	if (session_alert_has(s, wl, WINDOW_ACTIVITY)) {
		flag = '#';
		gc->attr ^= GRID_ATTR_REVERSE;
	} else if (session_alert_has(s, wl, WINDOW_BELL)) {
		flag = '!';
a606 4
	} else if (session_alert_has(s, wl, WINDOW_CONTENT)) {
		flag = '+';
		gc->attr ^= GRID_ATTR_REVERSE;
	}
d608 1
a608 1
	xasprintf(&text, "%d:%s%c", wl->idx, wl->window->name, flag);
@


1.45
log
@Don't interpret #() for display-message, it usually doesn't make sense and may
leak commands.
@
text
@d1 1
a1 1
/* $OpenBSD: status.c,v 1.44 2009/11/18 13:16:33 nicm Exp $ */
d36 2
d323 4
a326 2
char *
status_replace(struct client *c, const char *fmt, time_t t, int run_jobs)
d330 94
d425 1
a425 5
	char		in[BUFSIZ], tmp[256], ch, *iptr, *optr, *ptr, *endptr;
	char           *savedptr;	/* freed at end of each loop */
	size_t		len;
	long		n;
	
a431 1
	savedptr = NULL;
d436 3
a438 102
		switch (ch = *iptr++) {
		case '#':
			errno = 0;
			n = strtol(iptr, &endptr, 10);
			if ((n == 0 && errno != EINVAL) ||
			    (n == LONG_MIN && errno != ERANGE) ||
			    (n == LONG_MAX && errno != ERANGE) ||
			    n != 0)
				iptr = endptr;
			if (n <= 0)
				n = LONG_MAX;

			ptr = NULL;
			switch (*iptr++) {
			case '(':
				if (run_jobs) {
					if (ptr == NULL) {
						ptr = status_job(c, &iptr);
						if (ptr == NULL)
							break;
						savedptr = ptr;
					}
				} else {
					/* Don't run jobs. Copy to ). */
					*optr++ = '#';

					iptr--;	/* include [ */
					while (*iptr != ')' && *iptr != '\0') {
						if (optr >=
						    out + (sizeof out) - 1)
							break;
						*optr++ = *iptr++;
					}
					break;
				}
				/* FALLTHROUGH */
			case 'H':
				if (ptr == NULL) {
					if (gethostname(tmp, sizeof tmp) != 0)
						fatal("gethostname failed");
					ptr = tmp;
				}
				/* FALLTHROUGH */
			case 'I':
				if (ptr == NULL) {
					xsnprintf(tmp, sizeof tmp, "%d", wl->idx);
					ptr = tmp;
				}
				/* FALLTHROUGH */
			case 'P':
				if (ptr == NULL) {
					xsnprintf(tmp, sizeof tmp, "%u",
					    window_pane_index(wl->window,
					    wl->window->active));
					ptr = tmp;
				}
				/* FALLTHROUGH */
			case 'S':
				if (ptr == NULL)
					ptr = s->name;
				/* FALLTHROUGH */
			case 'T':
				if (ptr == NULL)
					ptr = wl->window->active->base.title;
				/* FALLTHROUGH */
			case 'W':
				if (ptr == NULL)
					ptr = wl->window->name;
				len = strlen(ptr);
				if ((size_t) n < len)
					len = n;
				if (optr + len >= out + (sizeof out) - 1)
					break;
				while (len > 0 && *ptr != '\0') {
					*optr++ = *ptr++;
					len--;
				}
				break;
			case '[':
				/* 
				 * Embedded style, handled at display time.
				 * Leave present and skip input until ].
				 */
				*optr++ = '#';

				iptr--;	/* include [ */
				while (*iptr != ']' && *iptr != '\0') {
					if (optr >= out + (sizeof out) - 1)
						break;
					*optr++ = *iptr++;
				}
				break;
			case '#':
				*optr++ = '#';
				break;
			}
			if (savedptr != NULL) {
				xfree(savedptr);
				savedptr = NULL;
			}
			break;
		default:
d440 1
a440 1
			break;
d442 1
d449 1
d497 1
d523 1
d530 1
d579 1
d624 1
d640 1
d690 1
d724 1
d746 1
@


1.44
log
@Add a per-client log of status line messages displayed while that client
exists. A new message-limit session option sets the maximum number of entries
and a command, show-messages, shows the log (bound to ~ by default).

This (and prompt history) might be better as a single global log but until
there are global options it is easier for them to be per client.
@
text
@d1 1
a1 1
/* $OpenBSD: status.c,v 1.43 2009/11/17 13:30:07 nicm Exp $ */
d110 1
a110 1
	    &s->options, "status-left"), c->status_timer.tv_sec);
d117 1
a117 1
	    &s->options, "status-right"), c->status_timer.tv_sec);
d322 1
a322 1
status_replace(struct client *c, const char *fmt, time_t t)
d358 19
a376 5
				if (ptr == NULL) {
					ptr = status_job(c, &iptr);
					if (ptr == NULL)
						break;
					savedptr = ptr;
@


1.43
log
@Permit top-bit-set characters to be entered in the status line. They could
already be set from the shell and are just passed through when printing (so
invisible characters or displaying on terminals with different character sets
may cause problems).

Note that entering UTF-8 may not work and in any case currently the status line
cannot display it correctly (outside of status-left/status-right).
@
text
@d1 1
a1 1
/* $OpenBSD: status.c,v 1.42 2009/11/04 23:29:42 nicm Exp $ */
d569 6
a574 3
	struct timeval	tv;
	va_list		ap;
	int		delay;
d583 15
d601 1
a601 1
	
@


1.42
log
@Use timeout events for the identify and message timers.
@
text
@d1 1
a1 1
/* $OpenBSD: status.c,v 1.41 2009/11/04 21:04:43 nicm Exp $ */
d979 1
a979 1
		if (key < 32 || key > 126)
@


1.41
log
@Switch jobs over to use a bufferevent.
@
text
@d1 1
a1 1
/* $OpenBSD: status.c,v 1.40 2009/11/04 20:35:19 nicm Exp $ */
d36 1
d583 4
a586 4

	if (gettimeofday(&c->message_timer, NULL) != 0)
		fatal("gettimeofday failed");
	timeradd(&c->message_timer, &tv, &c->message_timer);
d605 8
@


1.40
log
@Unused (but assigned to) variable, found by lint.
@
text
@d1 1
a1 1
/* $OpenBSD: status.c,v 1.39 2009/11/01 23:20:37 nicm Exp $ */
d489 1
a489 1
	char	*buf;
d492 8
a499 6
	len = BUFFER_USED(job->out);
	buf = xmalloc(len + 1);
	if (len != 0)
		buffer_read(job->out, buf, len);
	buf[len] = '\0';
	buf[strcspn(buf, "\n")] = '\0';
d505 1
a505 1
	job->data = xstrdup(buf);
d507 2
a508 1
	xfree(buf);
@


1.39
log
@Add a flag for jobs that shouldn't be freed after they've died and use it for
status jobs, then only kill those jobs when status-left, status-right or
set-titles-string is changed.

Fixes problems with changing options from inside #().
@
text
@d1 1
a1 1
/* $OpenBSD: status.c,v 1.38 2009/10/10 15:03:01 nicm Exp $ */
d443 1
a443 1
	char   		*buf, *cmd;
a452 2

	buf = NULL;
@


1.38
log
@Rather than running status-left, status-right and window title #() with popen
immediately every redraw, queue them up and run them in the background,
starting each once every status-interval. The actual status line uses the
output from the last run.

This brings several advantages:

- tmux itself may be called from inside #() without causing the server to hang;
- likewise, sleep or similar doesn't cause the server to block;
- commands aren't run excessively often when redrawing;
- commands shared by status-left and status-right, or used multiple times, will
  only be run once.

run-shell and if-shell still use system()/popen() but will be changed over to
use this too later.
@
text
@d1 1
a1 1
/* $OpenBSD: status.c,v 1.37 2009/10/10 10:02:48 nicm Exp $ */
d479 2
a480 2
		job = job_add(
		    &c->status_jobs, c, cmd, status_job_callback, xfree, NULL);
@


1.37
log
@Add "grouped sessions" which have independent name, options, current window and
so on but where the linked windows are synchronized (ie creating, killing
windows and so on are mirrored between the sessions). A grouped session may be
created by passing -t to new-session.

Had this around for a while, tested by a couple of people.
@
text
@d1 1
a1 1
/* $OpenBSD: status.c,v 1.36 2009/09/23 14:42:48 nicm Exp $ */
d32 2
a33 1
char   *status_replace_popen(char **);
d108 1
a108 1
	left = status_replace(s, options_get_string(
d115 1
a115 1
	right = status_replace(s, options_get_string(
d321 1
a321 1
status_replace(struct session *s, const char *fmt, time_t t)
d323 1
d327 1
a327 1
	char           *savedptr;
d330 2
a331 1

d358 1
a358 1
					ptr = status_replace_popen(&iptr);
d380 2
a381 2
						  window_pane_index(wl->window,
						  wl->window->active));
d440 1
a440 1
status_replace_popen(char **iptr)
d442 4
a445 4
	FILE	*f;
	char	*buf, *cmd, *ptr;
	int	lastesc;
	size_t	len;
d470 4
a473 2
	if (**iptr == '\0')		/* no terminating ) */
		goto out;
d477 10
a486 2
	if ((f = popen(cmd, "r")) == NULL)
		goto out;
d488 18
a505 14
	if ((buf = fgetln(f, &len)) == NULL) {
		pclose(f);
		goto out;
	}
	if (buf[len - 1] == '\n') {
		buf[len - 1] = '\0';
		buf = xstrdup(buf);
	} else {
		ptr = xmalloc(len + 1);
		memcpy(ptr, buf, len);
		ptr[len] = '\0';
		buf = ptr;
	}
	pclose(f);
d507 1
a507 3
out:
	xfree(cmd);
	return (buf);
@


1.36
log
@Remove PROMPT_HIDDEN code which is now unused.
@
text
@d1 1
a1 1
/* $OpenBSD: status.c,v 1.35 2009/09/23 06:18:48 nicm Exp $ */
d519 1
a519 1
 	if (wl == SLIST_FIRST(&s->lastw))
@


1.35
log
@Remove the internal tmux locking and instead detach each client and run the
command specified by a new option "lock-command" (by default "lock -np") in
each client.

This means each terminal has to be unlocked individually but simplifies the
code and allows the system password to be used to unlock.

Note that the set-password command is gone, so it will need to be removed from
configuration files, and the -U command line flag has been removed.

This is the third protocol version change so again it is best to stop the tmux
server before upgrading.
@
text
@d1 1
a1 1
/* $OpenBSD: status.c,v 1.34 2009/09/20 14:58:12 nicm Exp $ */
a675 2
	if (c->prompt_flags & PROMPT_HIDDEN)
		memset(c->prompt_buffer, 0, strlen(c->prompt_buffer));
d740 2
a741 6
		if (c->prompt_flags & PROMPT_HIDDEN)
			size = 0;
		else {
			screen_write_puts(&ctx, &gc,
			    "%.*s", (int) left, c->prompt_buffer + off);
		}
d748 3
a750 8
		if (c->prompt_flags & PROMPT_HIDDEN)
			screen_write_cursormove(&ctx, len, 0);
		else {
			screen_write_cursormove(&ctx,
			    len + c->prompt_index - off, 0);
			if (c->prompt_index < strlen(c->prompt_buffer))
				ch = c->prompt_buffer[c->prompt_index];
		}
a883 2
		if (c->prompt_flags & PROMPT_HIDDEN)
			memset(c->prompt_buffer, 0, strlen(c->prompt_buffer));
a894 2
		if (c->prompt_flags & PROMPT_HIDDEN)
			memset(c->prompt_buffer, 0, strlen(c->prompt_buffer));
@


1.34
log
@Regularise some fatal messages.
@
text
@d1 1
a1 1
/* $OpenBSD: status.c,v 1.33 2009/09/10 17:16:24 nicm Exp $ */
a892 3
		if (server_locked)
			break;

a907 3
		if (server_locked)
			break;

a999 3
	if (server_locked)
		return;

@


1.33
log
@Permit options such as status-bg to be configured using the entire 256 colour
palette by setting "colour0" to "colour255".
@
text
@d1 1
a1 1
/* $OpenBSD: status.c,v 1.32 2009/09/07 18:50:45 nicm Exp $ */
d67 1
a67 1
		fatal("gettimeofday");
d364 1
a364 1
						fatal("gethostname");
d568 1
a568 1
		fatal("gettimeofday");
@


1.32
log
@Give each paste buffer a size member instead of requiring them to be
zero-terminated.
@
text
@d1 1
a1 1
/* $OpenBSD: status.c,v 1.31 2009/09/07 10:49:32 nicm Exp $ */
d69 2
a70 2
	stdgc.fg = options_get_number(&s->options, "status-fg");
	stdgc.bg = options_get_number(&s->options, "status-bg");
d82 1
a82 1
		sl_stdgc.fg = sl_fg;
d85 1
a85 1
		sl_stdgc.bg = sl_bg;		
d91 1
a91 1
		sr_stdgc.fg = sr_fg;
d94 1
a94 1
		sr_stdgc.bg = sr_bg;
d504 3
a506 2
	char   *text, flag;
	u_char	fg, bg, attr;
d508 1
a508 1
	fg = options_get_number(&wl->window->options, "window-status-fg");
d510 2
a511 2
		gc->fg = fg;
	bg = options_get_number(&wl->window->options, "window-status-bg");
d513 2
a514 2
		gc->bg = bg;
	attr = options_get_number(&wl->window->options, "window-status-attr");
d522 1
a522 1
		fg = options_get_number(&wl->window->options, "window-status-current-fg");
d524 2
a525 2
			gc->fg = fg;
		bg = options_get_number(&wl->window->options, "window-status-current-bg");
d527 2
a528 2
			gc->bg = bg;
		attr = options_get_number(&wl->window->options, "window-status-current-attr");
d610 2
a611 2
	gc.fg = options_get_number(&s->options, "message-fg");
	gc.bg = options_get_number(&s->options, "message-bg");
d723 2
a724 2
	gc.fg = options_get_number(&s->options, "message-fg");
	gc.bg = options_get_number(&s->options, "message-bg");
@


1.31
log
@Permit embedded colour and attributes in status-left and status-right using new
#[] special characters, for example #[fg=red,bg=blue,blink].
@
text
@d1 1
a1 1
/* $OpenBSD: status.c,v 1.30 2009/09/02 06:33:20 nicm Exp $ */
d931 4
a934 3
		if ((last = strchr(pb->data, '\n')) == NULL)
			last = strchr(pb->data, '\0');
		n = last - pb->data;
@


1.30
log
@Add a transpose-chars command in edit mode (C-t in emacs mode only). From Kalle
Olavi Niemitalo.
@
text
@d1 1
a1 1
/* $OpenBSD: status.c,v 1.29 2009/09/01 09:11:05 nicm Exp $ */
d110 1
a110 1
	llen2 = screen_write_strlen(utf8flag, "%s", left);
d117 1
a117 1
	rlen2 = screen_write_strlen(utf8flag, "%s", right);
d195 1
a195 1
		screen_write_nputs(&ctx, llen, &sl_stdgc, utf8flag, "%s", left);
d269 1
a269 1
		screen_write_nputs(&ctx, rlen, &sr_stdgc, utf8flag, "%s", right);
d401 14
@


1.29
log
@Use "Password:" with no space for password prompts and don't display a *s for
the password, like pretty much everything else. From martynas@@ with minor
tweaks by me.
@
text
@d1 1
a1 1
/* $OpenBSD: status.c,v 1.28 2009/08/31 20:46:19 nicm Exp $ */
d766 1
a766 1
	char   			*s, *first, *last, word[64];
d935 12
@


1.28
log
@Add a new display-panes command, with two options (display-panes-colour and
display-panes-time), which displays a visual indication of the number of each
pane.
@
text
@d1 1
a1 1
/* $OpenBSD: status.c,v 1.27 2009/08/19 10:39:50 nicm Exp $ */
d693 1
a693 1
	size_t			        i, size, left, len, off, n;
d727 3
a729 7
		if (c->prompt_flags & PROMPT_HIDDEN) {
			n = strlen(c->prompt_buffer);
			if (n > left)
				n = left;
			for (i = 0; i < n; i++)
				screen_write_putc(&ctx, &gc, '*');
		} else {
d738 3
a740 3
		screen_write_cursormove(&ctx, len + c->prompt_index - off, 0);
		if (c->prompt_index == strlen(c->prompt_buffer))
			ch = ' ';
d742 3
a744 3
			if (c->prompt_flags & PROMPT_HIDDEN)
				ch = '*';
			else
a746 2
		if (ch == '\0')
			ch = ' ';
@


1.27
log
@Extend command-prompt with a -p option which is a comma-separated list of one
or more prompts to present in order.

The responses to the prompt are replaced in the template string: %% are
replaced in order, so the first prompt replaces the first %%, the second
replaces the second, and so on. In addition, %1 up to %9 are replaced with the
responses to the first the ninth prompts

The default template is "%1" so the response to the first prompt is processed
as a command.

Note that this changes the behaviour for %% so if there is only one prompt,
only the first %% will be replaced. Templates such as "neww -n '%%' 'ssh %%'"
should be changed to "neww -n '%1' 'ssh %1'".

From Tiago Cunha.
@
text
@d1 1
a1 1
/* $OpenBSD: status.c,v 1.26 2009/08/18 07:23:43 nicm Exp $ */
d544 4
a551 3
	va_start(ap, fmt);
	xvasprintf(&c->message_string, fmt, ap);
	va_end(ap);
@


1.26
log
@Add a "delete line" key when editing in the status line or the search up/down
prompt. C-u with emacs keys, d with vi.
@
text
@d1 1
a1 1
/* $OpenBSD: status.c,v 1.25 2009/08/13 23:44:18 nicm Exp $ */
d669 14
@


1.25
log
@Switch the prompt code to return an empty string when the user enters no
response and reserve NULL for an explicit cancel. Change all callbacks to treat
them the same so no functional change.

Also add cancel key bindings to emacs mode which were missing.
@
text
@d1 1
a1 1
/* $OpenBSD: status.c,v 1.24 2009/08/08 20:36:42 nicm Exp $ */
d856 5
@


1.24
log
@Options to set the colours and attributes for status-left/-right. From Thomas
Adam, thanks.
@
text
@d1 1
a1 1
/* $OpenBSD: status.c,v 1.23 2009/08/05 16:26:38 nicm Exp $ */
d923 1
a923 1
		if (*c->prompt_buffer != '\0') {
d925 3
a927 6
			if (c->prompt_callbackfn(
			    c->prompt_data, c->prompt_buffer) == 0)
				status_prompt_clear(c);
			break;
		}
		/* FALLTHROUGH */
@


1.23
log
@If colours are not supported by the terminal, try to emulate a coloured
background by setting or clearing the reverse attribute.

This makes a few applications which don't use the reverse attribute themselves
a little happier, and allows the status, message and mode options to have
default attributes and fg/bg options that work as expected when set as reverse.
@
text
@d1 1
a1 1
/* $OpenBSD: status.c,v 1.22 2009/07/30 20:41:48 nicm Exp $ */
d50 1
a50 1
	struct grid_cell	        stdgc, gc;
d52 2
d73 26
d195 1
a195 1
		screen_write_nputs(&ctx, llen, &stdgc, utf8flag, "%s", left);
d269 1
a269 1
		screen_write_nputs(&ctx, rlen, &stdgc, utf8flag, "%s", right);
@


1.22
log
@Plug some memory leaks.
@
text
@d1 1
a1 1
/* $OpenBSD: status.c,v 1.21 2009/07/28 07:03:32 nicm Exp $ */
d67 2
a68 2
	stdgc.bg = options_get_number(&s->options, "status-fg");
	stdgc.fg = options_get_number(&s->options, "status-bg");
d566 2
a567 2
	gc.bg = options_get_number(&s->options, "message-fg");
	gc.fg = options_get_number(&s->options, "message-bg");
d665 2
a666 2
	gc.bg = options_get_number(&s->options, "message-fg");
	gc.fg = options_get_number(&s->options, "message-bg");
@


1.21
log
@Next step towards customisable mode keys: build each default table of keys into
a named tree on start and use that for lookups. Also add command to string
translation tables and modify list-keys to show the the mode key bindings (new
-t argument).
@
text
@d1 1
a1 1
/* $OpenBSD: status.c,v 1.20 2009/07/27 19:29:35 nicm Exp $ */
d804 1
@


1.20
log
@Change mode key bindings from big switches into a set of tables. Rather than
lumping them all together, split editing keys from those used in choice/more
mode and those for copy/scroll mode.

Tidier and clearer, and the first step towards customisable mode keys.
@
text
@d1 1
a1 1
/* $OpenBSD: status.c,v 1.19 2009/07/27 18:51:46 nicm Exp $ */
d612 1
a612 1
		mode_key_init(&c->prompt_mdata, mode_key_emacs_edit);
d614 1
a614 1
		mode_key_init(&c->prompt_mdata, mode_key_vi_edit);
@


1.19
log
@Get rid of empty mode_key_free function.
@
text
@d1 1
a1 1
/* $OpenBSD: status.c,v 1.18 2009/07/27 12:11:11 nicm Exp $ */
d592 2
d610 5
a614 3
	mode_key_init(&c->prompt_mdata,
	    options_get_number(&c->session->options, "status-keys"),
	    MODEKEY_CANEDIT);
d734 1
a734 1
	case MODEKEYCMD_LEFT:
d740 2
a741 1
	case MODEKEYCMD_RIGHT:
d747 1
a747 2
	case MODEKEYCMD_STARTOFLINE:
	case MODEKEYCMD_BACKTOINDENTATION:
d753 1
a753 1
	case MODEKEYCMD_ENDOFLINE:
d759 1
a759 1
	case MODEKEYCMD_COMPLETE:
d807 1
a807 1
	case MODEKEYCMD_BACKSPACE:
d820 1
a820 1
 	case MODEKEYCMD_DELETE:
d828 1
a828 1
	case MODEKEYCMD_DELETETOENDOFLINE:
d834 1
a834 1
	case MODEKEYCMD_UP:
d852 1
a852 1
	case MODEKEYCMD_DOWN:
d871 1
a871 1
	case MODEKEYCMD_PASTE:
d893 1
a893 1
 	case MODEKEYCMD_CHOOSE:
d902 1
a902 1
	case MODEKEYCMD_QUIT:
d906 1
a906 1
	case MODEKEYCMD_OTHERKEY:
@


1.18
log
@Add a key to delete to end of line at the prompt (^K in emacs mode, C/D in vi).

From Kalle Olavi Niemitalo.
@
text
@d1 1
a1 1
/* $OpenBSD: status.c,v 1.17 2009/07/26 21:13:47 nicm Exp $ */
a623 2

	mode_key_free(&c->prompt_mdata);
@


1.17
log
@Calculate the space available for the prompt buffer and the cursor position
correctly, and make it work when the screen is not wide enough.

Noticed by Kalle Olavi Niemitalo.
@
text
@d1 1
a1 1
/* $OpenBSD: status.c,v 1.16 2009/07/21 18:40:30 nicm Exp $ */
d823 6
@


1.16
log
@Remove a couple of unused functions and fix a type ("FALLTHOUGH"), found by
lint.
@
text
@d1 1
a1 1
/* $OpenBSD: status.c,v 1.15 2009/07/20 14:32:09 nicm Exp $ */
d648 1
a648 1
	size_t			        i, size, left, len, offset, n;
d656 1
a656 1
	offset = 0;
d677 1
a677 1
			offset = c->prompt_index - left - 1;
d690 1
a690 1
			    "%.*s", (int) left, c->prompt_buffer + offset);
a694 1
	}
d696 14
a709 9
	/* Draw a fake cursor. */
	screen_write_cursormove(&ctx, len + c->prompt_index - offset, 0);
	if (c->prompt_index == strlen(c->prompt_buffer))
		ch = ' ';
	else {
		if (c->prompt_flags & PROMPT_HIDDEN)
			ch = '*';
		else
			ch = c->prompt_buffer[c->prompt_index];
a710 4
	if (ch == '\0')
		ch = ' ';
	gc.attr ^= GRID_ATTR_REVERSE;
	screen_write_putc(&ctx, &gc, ch);
@


1.15
log
@Add a status-justify option to allow the window list in the status line to be
positioned at the left, centre, or right.
@
text
@d1 1
a1 1
/* $OpenBSD: status.c,v 1.14 2009/07/20 09:15:18 nicm Exp $ */
d353 1
a353 1
				/* FALLTHOUGH */
@


1.14
log
@New options, window-status-current-{fg,bg,attr}, to set the fg, bg and
attributes with which the current window is shown in the status line. From
Johan Friis, thanks.
@
text
@d1 1
a1 1
/* $OpenBSD: status.c,v 1.13 2009/07/17 18:45:08 nicm Exp $ */
d49 1
a49 1
	size_t				xx, yy, size, start, width;
d176 15
@


1.13
log
@- New command display-message (alias display) to display a message in the
  status line (bound to "i" and displays the current window and time by
  default). The same substitutions are applied as for status-left/right.
- Add support for including the window index (#I), pane index (#P) and window
  name (#W) in the message, and status-left or status-right.
- Bump protocol version.

From Tiago Cunha, thanks!
@
text
@d1 1
a1 1
/* $OpenBSD: status.c,v 1.12 2009/07/17 06:13:27 nicm Exp $ */
d463 10
a472 1
	if (wl == s->curw)
d474 1
@


1.12
log
@Memory could be leaked if a second prompt or message appeared while another was
still present, so add a separate prompt free callback and make the _clear
function responsible for calling it if necessary (rather than the individual
prompt callbacks). Also make both messages and prompts clear any existing when
a new is set.

In addition, the screen could be modified while the prompt is there, restore
the redraw-entire-screen behaviour on prompt clear; add a comment as a
reminder.
@
text
@d1 1
a1 1
/* $OpenBSD: status.c,v 1.11 2009/07/16 23:25:21 nicm Exp $ */
a31 1
char   *status_replace(struct session *, char *, time_t);
d277 1
a277 1
status_replace(struct session *s, char *fmt, time_t t)
d325 14
d346 4
@


1.11
log
@Remove some duplicate code that was causing the status line to be redrawn even
when it hadn't changed.
@
text
@d1 1
a1 1
/* $OpenBSD: status.c,v 1.10 2009/07/15 17:39:00 nicm Exp $ */
d471 3
d499 1
a499 1
	c->flags |= CLIENT_STATUS;
d546 3
a548 2
status_prompt_set(struct client *c,
    const char *msg, int (*fn)(void *, const char *), void *data, int flags)
d550 3
d558 2
a559 1
	c->prompt_callback = fn;
d577 1
a577 1
	if (c->prompt_string == NULL)
d580 3
d594 1
a594 1
	c->flags |= CLIENT_STATUS;
d846 1
a846 1
			if (c->prompt_callback(
d853 1
a853 1
		if (c->prompt_callback(c->prompt_data, NULL) == 0)
d872 1
a872 1
			if (c->prompt_callback(
@


1.10
log
@Make status_message_set a variadic printf-like function. No functional change -
helpful for a couple of things coming soon.
@
text
@d1 1
a1 1
/* $OpenBSD: status.c,v 1.9 2009/07/15 07:50:34 nicm Exp $ */
a59 4

	/* Create the target screen. */
	memcpy(&old_status, &c->status, sizeof old_status);
	screen_init(&c->status, c->tty.sx, 1, 0);
@


1.9
log
@Having to update NSETOPTION/NSETWINDOWOPTION when adding new options is a bit
annoying and it is only use for iterating, so use a sentinel to mark the end of
each array instead. Different fix for a problem pointed out by Kalle Olavi
Niemitalo.
@
text
@d1 1
a1 1
/* $OpenBSD: status.c,v 1.8 2009/07/14 19:11:58 nicm Exp $ */
d468 2
a469 2
void
status_message_set(struct client *c, const char *msg)
d472 1
d479 3
a481 1
	c->message_string = xstrdup(msg);
@


1.8
log
@For some reason when clearing status/message it was redrawing the entire client
not just the status line. Changing this also revealed the check for the status
line was incorrect when drawing the pane.
@
text
@d1 1
a1 1
/* $OpenBSD: status.c,v 1.7 2009/07/14 19:03:16 nicm Exp $ */
d901 1
a901 1
	u_int			 	i;
d913 1
a913 2
	for (i = 0; i < NSETOPTION; i++) {
		optent = &set_option_table[i];
d917 1
a917 2
	for (i = 0; i < NSETWINDOWOPTION; i++) {
		optent = &set_window_option_table[i];
@


1.7
log
@Instead of faking up a status line in status_redraw, use the same code to
redraw it as to draw the entire screen, just skip all lines but the last.

This makes horizontal split redraw properly when the status line is off.
@
text
@d1 1
a1 1
/* $OpenBSD: status.c,v 1.6 2009/07/12 16:15:34 nicm Exp $ */
d497 1
a497 1
	c->flags |= CLIENT_REDRAW;
d584 1
a584 1
	c->flags |= CLIENT_REDRAW;
@


1.6
log
@Add a "back to indentation" key in copy mode to move the cursor to the first
non-whitespace character. ^ with vi and M-m with emacs key bindings. Another
from Kalle Olavi Niemitalo, thanks.
@
text
@d1 1
a1 1
/* $OpenBSD: status.c,v 1.5 2009/06/26 15:13:39 nicm Exp $ */
d47 1
a47 2
	struct window_pane	       *wp;
	struct screen		       *sc = NULL, old_status;
d50 1
a50 1
	size_t				xx, yy, sy, size, start, width;
d56 5
d65 3
a67 4
	/* No status line? */
	if (c->tty.sy == 0 || !options_get_number(&s->options, "status"))
		goto off;
	larrow = rarrow = 0;
a264 26
	goto out;

off:
	/*
	 * Draw the real window last line. Necessary to wipe over message if
	 * status is off. Not sure this is the right place for this.
	 */
	memcpy(&stdgc, &grid_default_cell, sizeof stdgc);
	screen_write_start(&ctx, NULL, &c->status);

	sy = 0;
	TAILQ_FOREACH(wp, &s->curw->window->panes, entry) {
		sy += wp->sy + 1;
		sc = wp->screen;
	}

	screen_write_cursormove(&ctx, 0, 0);
	if (sy < c->tty.sy) {
		/* If the screen is too small, use blank. */
 		for (offset = 0; offset < c->tty.sx; offset++)
 			screen_write_putc(&ctx, &stdgc, ' ');
	} else {
		screen_write_copy(&ctx,
		    sc, 0, sc->grid->hsize + screen_size_y(sc) - 1, c->tty.sx, 1);
	}

d498 2
d585 2
@


1.5
log
@Status line fixes: don't truncate status-right now the length calculation is
done for UTF-8, limit to the maximum length correctly when printing, and always
print a space even if the left string is longer than the width available.
@
text
@d1 1
a1 1
/* $OpenBSD: status.c,v 1.4 2009/06/04 21:43:24 nicm Exp $ */
d712 1
@


1.4
log
@If the prompt is hidden or a password is sent with -U, zero it before freeing
it.
@
text
@d1 1
a1 1
/* $OpenBSD: status.c,v 1.3 2009/06/03 16:54:26 nicm Exp $ */
a93 1
	right[rlen] = '\0';
d169 2
a170 2
		screen_write_nputs(
		    &ctx, llen + 1, &stdgc, utf8flag, "%s ", left);
d227 2
a228 2
		screen_write_nputs(
		    &ctx, rlen + 1, &stdgc, utf8flag, " %s", right);
@


1.3
log
@New session option, status-utf8, to control the interpretation of top-bit-set
characters in status-left and status-right (if on, they are treated as UTF-8;
otherwise passed through).
@
text
@d1 1
a1 1
/* $OpenBSD: status.c,v 1.2 2009/06/03 16:05:46 nicm Exp $ */
d600 2
d799 2
d815 2
@


1.2
log
@Add a UTF-8 aware string length function and make UTF-8 in
status-left/status-right work properly. At the moment any top-bit-set
characters are assumed to be UTF-8: a status-utf8 option to configure this will
come shortly.
@
text
@d1 1
a1 1
/* $OpenBSD: status.c,v 1.1 2009/06/01 22:58:49 nicm Exp $ */
d53 1
a53 1
	int				larrow, rarrow;
d77 3
d84 1
a84 1
	llen2 = screen_write_strlen("%s", left);
d91 1
a91 1
	rlen2 = screen_write_strlen("%s", right);
d170 2
a171 1
		screen_write_nputs(&ctx, llen + 1, &stdgc, "%s ", left);
d228 2
a229 1
		screen_write_nputs(&ctx, rlen + 1, &stdgc, " %s", right);
@


1.1
log
@Import tmux, a terminal multiplexor allowing (among other things) a single
terminal to be switched between several different windows and programs
displayed on one terminal be detached from one terminal and moved to another.

ok deraadt pirofti
@
text
@d1 1
a1 1
/* $OpenBSD$ */
d50 2
a51 2
	size_t				llen, rlen, offset, xx, yy, sy;
	size_t				size, start, width;
d81 3
a83 3
	if (strlen(left) < llen)
		llen = strlen(left);
	left[llen] = '\0';
d88 3
a90 2
	if (strlen(right) < rlen)
		rlen = strlen(right);
d167 1
a167 1
		screen_write_puts(&ctx, &stdgc, "%s ", left);
d224 1
a224 1
		screen_write_puts(&ctx, &stdgc, " %s", right);
@

