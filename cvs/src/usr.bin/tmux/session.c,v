head	1.73;
access;
symbols
	OPENBSD_6_1:1.73.0.4
	OPENBSD_6_1_BASE:1.73
	OPENBSD_6_0:1.62.0.4
	OPENBSD_6_0_BASE:1.62
	OPENBSD_5_9:1.62.0.2
	OPENBSD_5_9_BASE:1.62
	OPENBSD_5_8:1.50.0.4
	OPENBSD_5_8_BASE:1.50
	OPENBSD_5_7:1.46.0.2
	OPENBSD_5_7_BASE:1.46
	OPENBSD_5_6:1.44.0.4
	OPENBSD_5_6_BASE:1.44
	OPENBSD_5_5:1.42.0.4
	OPENBSD_5_5_BASE:1.42
	OPENBSD_5_4:1.38.0.2
	OPENBSD_5_4_BASE:1.38
	OPENBSD_5_3:1.36.0.4
	OPENBSD_5_3_BASE:1.36
	OPENBSD_5_2:1.36.0.2
	OPENBSD_5_2_BASE:1.36
	OPENBSD_5_1_BASE:1.32
	OPENBSD_5_1:1.32.0.2
	OPENBSD_5_0:1.31.0.2
	OPENBSD_5_0_BASE:1.31
	OPENBSD_4_9:1.30.0.2
	OPENBSD_4_9_BASE:1.30
	OPENBSD_4_8:1.19.0.2
	OPENBSD_4_8_BASE:1.19
	OPENBSD_4_7:1.16.0.2
	OPENBSD_4_7_BASE:1.16
	OPENBSD_4_6:1.1.0.4
	OPENBSD_4_6_BASE:1.1;
locks; strict;
comment	@ * @;


1.73
date	2017.03.09.17.02.38;	author nicm;	state Exp;
branches;
next	1.72;
commitid	QtFskEpSXY809LlK;

1.72
date	2017.02.09.15.04.53;	author nicm;	state Exp;
branches;
next	1.71;
commitid	LotTNNNN3Vrlt9Fn;

1.71
date	2017.02.03.21.01.02;	author nicm;	state Exp;
branches;
next	1.70;
commitid	MRFqlgnbMk0ZRnKS;

1.70
date	2016.10.19.09.22.07;	author nicm;	state Exp;
branches;
next	1.69;
commitid	leRKiNVAXYb2Wrn1;

1.69
date	2016.10.19.08.17.11;	author nicm;	state Exp;
branches;
next	1.68;
commitid	mJwe5IdsC7W1Y5Er;

1.68
date	2016.10.16.22.06.40;	author nicm;	state Exp;
branches;
next	1.67;
commitid	j0FZs70gSPCmpqWI;

1.67
date	2016.10.15.09.27.52;	author nicm;	state Exp;
branches;
next	1.66;
commitid	3LOsIpF6UVTyfOf3;

1.66
date	2016.10.15.00.12.58;	author nicm;	state Exp;
branches;
next	1.65;
commitid	W1m68Q2tEflX7Raw;

1.65
date	2016.10.13.21.37.03;	author nicm;	state Exp;
branches;
next	1.64;
commitid	ZCNRzNzyBFHddYXj;

1.64
date	2016.10.11.13.21.59;	author nicm;	state Exp;
branches;
next	1.63;
commitid	80rgEIPcNpyBnf95;

1.63
date	2016.10.10.21.29.23;	author nicm;	state Exp;
branches;
next	1.62;
commitid	z4Hr4PZF7Ev93uEJ;

1.62
date	2016.01.19.15.59.12;	author nicm;	state Exp;
branches;
next	1.61;
commitid	P3qmSOx6KrDBsb0c;

1.61
date	2015.12.08.01.10.31;	author nicm;	state Exp;
branches;
next	1.60;
commitid	Q7y3PTVPjE0eQDqD;

1.60
date	2015.11.18.14.27.44;	author nicm;	state Exp;
branches;
next	1.59;
commitid	RjsAPRkWwvS79w40;

1.59
date	2015.11.18.09.22.29;	author nicm;	state Exp;
branches;
next	1.58;
commitid	ARqipz9eYSlmUvw1;

1.58
date	2015.10.31.08.13.58;	author nicm;	state Exp;
branches;
next	1.57;
commitid	B5GekkO0CdWpFMrz;

1.57
date	2015.10.28.09.51.55;	author nicm;	state Exp;
branches;
next	1.56;
commitid	eGVGKzVVYKHFvkn4;

1.56
date	2015.10.27.15.58.42;	author nicm;	state Exp;
branches;
next	1.55;
commitid	89xhQafU35Q5MQVC;

1.55
date	2015.09.01.18.50.16;	author nicm;	state Exp;
branches;
next	1.54;
commitid	XbPD13Dvda5IOjRa;

1.54
date	2015.08.29.08.30.54;	author nicm;	state Exp;
branches;
next	1.53;
commitid	RrlCW4OYH7he0yBf;

1.53
date	2015.08.28.13.16.03;	author nicm;	state Exp;
branches;
next	1.52;
commitid	4brsHKGGGLJU2sO8;

1.52
date	2015.08.28.13.12.20;	author nicm;	state Exp;
branches;
next	1.51;
commitid	7dHMdjgnodjQvy6O;

1.51
date	2015.08.28.13.01.03;	author nicm;	state Exp;
branches;
next	1.50;
commitid	fIVZtZS9F66XgvbR;

1.50
date	2015.06.05.18.18.32;	author nicm;	state Exp;
branches;
next	1.49;
commitid	ZQGnMCbBqbBRSCmt;

1.49
date	2015.05.06.08.35.39;	author nicm;	state Exp;
branches;
next	1.48;
commitid	7XqxdN1FHegvjfQk;

1.48
date	2015.04.25.18.09.28;	author nicm;	state Exp;
branches;
next	1.47;
commitid	B7W3z8l90mUfy5Jt;

1.47
date	2015.04.22.15.32.33;	author nicm;	state Exp;
branches;
next	1.46;
commitid	g5PKK6dkIwS2RVh8;

1.46
date	2014.10.22.23.18.53;	author nicm;	state Exp;
branches;
next	1.45;
commitid	eFDptKeckheZa4ap;

1.45
date	2014.10.22.23.11.41;	author nicm;	state Exp;
branches;
next	1.44;
commitid	rjYMtvWWeOUV78xG;

1.44
date	2014.05.13.08.08.32;	author nicm;	state Exp;
branches;
next	1.43;

1.43
date	2014.04.17.13.02.59;	author nicm;	state Exp;
branches;
next	1.42;

1.42
date	2014.01.22.14.00.08;	author nicm;	state Exp;
branches;
next	1.41;

1.41
date	2013.10.10.12.26.36;	author nicm;	state Exp;
branches;
next	1.40;

1.40
date	2013.10.10.11.58.24;	author nicm;	state Exp;
branches;
next	1.39;

1.39
date	2013.10.10.11.46.29;	author nicm;	state Exp;
branches;
next	1.38;

1.38
date	2013.03.25.10.11.45;	author nicm;	state Exp;
branches;
next	1.37;

1.37
date	2013.03.22.16.00.26;	author nicm;	state Exp;
branches;
next	1.36;

1.36
date	2012.07.10.11.53.01;	author nicm;	state Exp;
branches;
next	1.35;

1.35
date	2012.07.08.07.27.32;	author nicm;	state Exp;
branches;
next	1.34;

1.34
date	2012.04.29.17.20.01;	author nicm;	state Exp;
branches;
next	1.33;

1.33
date	2012.03.17.22.35.09;	author nicm;	state Exp;
branches;
next	1.32;

1.32
date	2011.08.16.09.36.23;	author nicm;	state Exp;
branches;
next	1.31;

1.31
date	2011.04.06.21.51.31;	author nicm;	state Exp;
branches;
next	1.30;

1.30
date	2011.01.25.22.31.50;	author nicm;	state Exp;
branches;
next	1.29;

1.29
date	2011.01.13.02.08.14;	author nicm;	state Exp;
branches;
next	1.28;

1.28
date	2011.01.13.02.07.06;	author nicm;	state Exp;
branches;
next	1.27;

1.27
date	2011.01.01.01.12.09;	author nicm;	state Exp;
branches;
next	1.26;

1.26
date	2010.12.30.23.16.18;	author nicm;	state Exp;
branches;
next	1.25;

1.25
date	2010.12.21.22.37.59;	author nicm;	state Exp;
branches;
next	1.24;

1.24
date	2010.12.20.01.28.18;	author nicm;	state Exp;
branches;
next	1.23;

1.23
date	2010.12.20.00.43.24;	author nicm;	state Exp;
branches;
next	1.22;

1.22
date	2010.12.20.00.19.20;	author nicm;	state Exp;
branches;
next	1.21;

1.21
date	2010.12.20.00.03.55;	author nicm;	state Exp;
branches;
next	1.20;

1.20
date	2010.09.08.22.02.28;	author nicm;	state Exp;
branches;
next	1.19;

1.19
date	2010.06.27.02.56.59;	author nicm;	state Exp;
branches;
next	1.18;

1.18
date	2010.06.21.01.27.46;	author nicm;	state Exp;
branches;
next	1.17;

1.17
date	2010.06.21.00.25.32;	author nicm;	state Exp;
branches;
next	1.16;

1.16
date	2009.12.22.10.20.08;	author nicm;	state Exp;
branches;
next	1.15;

1.15
date	2009.12.03.22.50.10;	author nicm;	state Exp;
branches;
next	1.14;

1.14
date	2009.11.26.21.37.13;	author nicm;	state Exp;
branches;
next	1.13;

1.13
date	2009.11.13.14.47.31;	author nicm;	state Exp;
branches;
next	1.12;

1.12
date	2009.11.03.20.29.47;	author nicm;	state Exp;
branches;
next	1.11;

1.11
date	2009.10.10.10.02.48;	author nicm;	state Exp;
branches;
next	1.10;

1.10
date	2009.10.10.09.46.11;	author nicm;	state Exp;
branches;
next	1.9;

1.9
date	2009.09.20.14.58.12;	author nicm;	state Exp;
branches;
next	1.8;

1.8
date	2009.09.16.12.35.04;	author nicm;	state Exp;
branches;
next	1.7;

1.7
date	2009.09.07.21.01.50;	author nicm;	state Exp;
branches;
next	1.6;

1.6
date	2009.09.01.13.09.49;	author nicm;	state Exp;
branches;
next	1.5;

1.5
date	2009.08.13.20.11.58;	author nicm;	state Exp;
branches;
next	1.4;

1.4
date	2009.08.13.19.04.00;	author nicm;	state Exp;
branches;
next	1.3;

1.3
date	2009.08.08.21.52.43;	author nicm;	state Exp;
branches;
next	1.2;

1.2
date	2009.07.07.19.49.19;	author nicm;	state Exp;
branches;
next	1.1;

1.1
date	2009.06.01.22.58.49;	author nicm;	state Exp;
branches;
next	;


desc
@@


1.73
log
@Move server_fill_environ into environ.c and move some other common code
into it.
@
text
@/* $OpenBSD: session.c,v 1.72 2017/02/09 15:04:53 nicm Exp $ */

/*
 * Copyright (c) 2007 Nicholas Marriott <nicholas.marriott@@gmail.com>
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF MIND, USE, DATA OR PROFITS, WHETHER
 * IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING
 * OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */

#include <sys/types.h>
#include <sys/time.h>

#include <paths.h>
#include <string.h>
#include <stdlib.h>
#include <unistd.h>
#include <time.h>

#include "tmux.h"

struct sessions		sessions;
static u_int		next_session_id;
struct session_groups	session_groups;

static void	session_free(int, short, void *);

static void	session_lock_timer(int, short, void *);

static struct winlink *session_next_alert(struct winlink *);
static struct winlink *session_previous_alert(struct winlink *);

static void	session_group_remove(struct session *);
static u_int	session_group_count(struct session_group *);
static void	session_group_synchronize1(struct session *, struct session *);

static u_int	session_group_count(struct session_group *);
static void	session_group_synchronize1(struct session *, struct session *);

RB_GENERATE(sessions, session, entry, session_cmp);

int
session_cmp(struct session *s1, struct session *s2)
{
	return (strcmp(s1->name, s2->name));
}

RB_GENERATE(session_groups, session_group, entry, session_group_cmp);

int
session_group_cmp(struct session_group *s1, struct session_group *s2)
{
	return (strcmp(s1->name, s2->name));
}

/*
 * Find if session is still alive. This is true if it is still on the global
 * sessions list.
 */
int
session_alive(struct session *s)
{
	struct session *s_loop;

	RB_FOREACH(s_loop, sessions, &sessions) {
		if (s_loop == s)
			return (1);
	}
	return (0);
}

/* Find session by name. */
struct session *
session_find(const char *name)
{
	struct session	s;

	s.name = (char *) name;
	return (RB_FIND(sessions, &sessions, &s));
}

/* Find session by id parsed from a string. */
struct session *
session_find_by_id_str(const char *s)
{
	const char	*errstr;
	u_int		 id;

	if (*s != '$')
		return (NULL);

	id = strtonum(s + 1, 0, UINT_MAX, &errstr);
	if (errstr != NULL)
		return (NULL);
	return (session_find_by_id(id));
}

/* Find session by id. */
struct session *
session_find_by_id(u_int id)
{
	struct session	*s;

	RB_FOREACH(s, sessions, &sessions) {
		if (s->id == id)
			return (s);
	}
	return (NULL);
}

/* Create a new session. */
struct session *
session_create(const char *prefix, const char *name, int argc, char **argv,
    const char *path, const char *cwd, struct environ *env, struct termios *tio,
    int idx, u_int sx, u_int sy, char **cause)
{
	struct session	*s;
	struct winlink	*wl;

	s = xcalloc(1, sizeof *s);
	s->references = 1;
	s->flags = 0;

	s->cwd = xstrdup(cwd);

	s->curw = NULL;
	TAILQ_INIT(&s->lastw);
	RB_INIT(&s->windows);

	s->environ = environ_create();
	if (env != NULL)
		environ_copy(env, s->environ);

	s->options = options_create(global_s_options);
	s->hooks = hooks_create(global_hooks);

	status_update_saved(s);

	s->tio = NULL;
	if (tio != NULL) {
		s->tio = xmalloc(sizeof *s->tio);
		memcpy(s->tio, tio, sizeof *s->tio);
	}

	s->sx = sx;
	s->sy = sy;

	if (name != NULL) {
		s->name = xstrdup(name);
		s->id = next_session_id++;
	} else {
		s->name = NULL;
		do {
			s->id = next_session_id++;
			free(s->name);
			if (prefix != NULL)
				xasprintf(&s->name, "%s-%u", prefix, s->id);
			else
				xasprintf(&s->name, "%u", s->id);
		} while (RB_FIND(sessions, &sessions, s) != NULL);
	}
	RB_INSERT(sessions, &sessions, s);

	log_debug("new session %s $%u", s->name, s->id);

	if (gettimeofday(&s->creation_time, NULL) != 0)
		fatal("gettimeofday failed");
	session_update_activity(s, &s->creation_time);

	if (argc >= 0) {
		wl = session_new(s, NULL, argc, argv, path, cwd, idx, cause);
		if (wl == NULL) {
			session_destroy(s);
			return (NULL);
		}
		session_select(s, RB_ROOT(&s->windows)->idx);
	}

	log_debug("session %s created", s->name);

	return (s);
}

/* Remove a reference from a session. */
void
session_unref(struct session *s)
{
	log_debug("session %s has %d references", s->name, s->references);

	s->references--;
	if (s->references == 0)
		event_once(-1, EV_TIMEOUT, session_free, s, NULL);
}

/* Free session. */
static void
session_free(__unused int fd, __unused short events, void *arg)
{
	struct session	*s = arg;

	log_debug("session %s freed (%d references)", s->name, s->references);

	if (s->references == 0) {
		environ_free(s->environ);

		options_free(s->options);
		hooks_free(s->hooks);

		free(s->name);
		free(s);
	}
}

/* Destroy a session. */
void
session_destroy(struct session *s)
{
	struct winlink	*wl;

	log_debug("session %s destroyed", s->name);
	s->curw = NULL;

	RB_REMOVE(sessions, &sessions, s);
	notify_session("session-closed", s);

	free(s->tio);

	if (event_initialized(&s->lock_timer))
		event_del(&s->lock_timer);

	session_group_remove(s);

	while (!TAILQ_EMPTY(&s->lastw))
		winlink_stack_remove(&s->lastw, TAILQ_FIRST(&s->lastw));
	while (!RB_EMPTY(&s->windows)) {
		wl = RB_ROOT(&s->windows);
		notify_session_window("window-unlinked", s, wl->window);
		winlink_remove(&s->windows, wl);
	}

	free((void *)s->cwd);

	session_unref(s);
}

/* Check a session name is valid: not empty and no colons or periods. */
int
session_check_name(const char *name)
{
	return (*name != '\0' && name[strcspn(name, ":.")] == '\0');
}

/* Lock session if it has timed out. */
static void
session_lock_timer(__unused int fd, __unused short events, void *arg)
{
	struct session	*s = arg;

	if (s->flags & SESSION_UNATTACHED)
		return;

	log_debug("session %s locked, activity time %lld", s->name,
	    (long long)s->activity_time.tv_sec);

	server_lock_session(s);
	recalculate_sizes();
}

/* Update activity time. */
void
session_update_activity(struct session *s, struct timeval *from)
{
	struct timeval	*last = &s->last_activity_time;
	struct timeval	 tv;

	memcpy(last, &s->activity_time, sizeof *last);
	if (from == NULL)
		gettimeofday(&s->activity_time, NULL);
	else
		memcpy(&s->activity_time, from, sizeof s->activity_time);

	log_debug("session %s activity %lld.%06d (last %lld.%06d)", s->name,
	    (long long)s->activity_time.tv_sec, (int)s->activity_time.tv_usec,
	    (long long)last->tv_sec, (int)last->tv_usec);

	if (evtimer_initialized(&s->lock_timer))
		evtimer_del(&s->lock_timer);
	else
		evtimer_set(&s->lock_timer, session_lock_timer, s);

	if (~s->flags & SESSION_UNATTACHED) {
		timerclear(&tv);
		tv.tv_sec = options_get_number(s->options, "lock-after-time");
		if (tv.tv_sec != 0)
			evtimer_add(&s->lock_timer, &tv);
	}
}

/* Find the next usable session. */
struct session *
session_next_session(struct session *s)
{
	struct session *s2;

	if (RB_EMPTY(&sessions) || !session_alive(s))
		return (NULL);

	s2 = RB_NEXT(sessions, &sessions, s);
	if (s2 == NULL)
		s2 = RB_MIN(sessions, &sessions);
	if (s2 == s)
		return (NULL);
	return (s2);
}

/* Find the previous usable session. */
struct session *
session_previous_session(struct session *s)
{
	struct session *s2;

	if (RB_EMPTY(&sessions) || !session_alive(s))
		return (NULL);

	s2 = RB_PREV(sessions, &sessions, s);
	if (s2 == NULL)
		s2 = RB_MAX(sessions, &sessions);
	if (s2 == s)
		return (NULL);
	return (s2);
}

/* Create a new window on a session. */
struct winlink *
session_new(struct session *s, const char *name, int argc, char **argv,
    const char *path, const char *cwd, int idx, char **cause)
{
	struct window	*w;
	struct winlink	*wl;
	struct environ	*env;
	const char	*shell;
	u_int		 hlimit;

	if ((wl = winlink_add(&s->windows, idx)) == NULL) {
		xasprintf(cause, "index in use: %d", idx);
		return (NULL);
	}
	wl->session = s;

	shell = options_get_string(s->options, "default-shell");
	if (*shell == '\0' || areshell(shell))
		shell = _PATH_BSHELL;

	hlimit = options_get_number(s->options, "history-limit");
	env = environ_for_session(s);
	w = window_create_spawn(name, argc, argv, path, shell, cwd, env, s->tio,
	    s->sx, s->sy, hlimit, cause);
	if (w == NULL) {
		winlink_remove(&s->windows, wl);
		environ_free(env);
		return (NULL);
	}
	winlink_set_window(wl, w);
	environ_free(env);
	notify_session_window("window-linked", s, w);

	session_group_synchronize_from(s);
	return (wl);
}

/* Attach a window to a session. */
struct winlink *
session_attach(struct session *s, struct window *w, int idx, char **cause)
{
	struct winlink	*wl;

	if ((wl = winlink_add(&s->windows, idx)) == NULL) {
		xasprintf(cause, "index in use: %d", idx);
		return (NULL);
	}
	wl->session = s;
	winlink_set_window(wl, w);
	notify_session_window("window-linked", s, w);

	session_group_synchronize_from(s);
	return (wl);
}

/* Detach a window from a session. */
int
session_detach(struct session *s, struct winlink *wl)
{
	if (s->curw == wl &&
	    session_last(s) != 0 &&
	    session_previous(s, 0) != 0)
		session_next(s, 0);

	wl->flags &= ~WINLINK_ALERTFLAGS;
	notify_session_window("window-unlinked", s, wl->window);
	winlink_stack_remove(&s->lastw, wl);
	winlink_remove(&s->windows, wl);

	session_group_synchronize_from(s);

	if (RB_EMPTY(&s->windows)) {
		session_destroy(s);
		return (1);
	}
	return (0);
}

/* Return if session has window. */
int
session_has(struct session *s, struct window *w)
{
	struct winlink	*wl;

	TAILQ_FOREACH(wl, &w->winlinks, wentry) {
		if (wl->session == s)
			return (1);
	}
	return (0);
}

/*
 * Return 1 if a window is linked outside this session (not including session
 * groups). The window must be in this session!
 */
int
session_is_linked(struct session *s, struct window *w)
{
	struct session_group	*sg;

	if ((sg = session_group_contains(s)) != NULL)
		return (w->references != session_group_count(sg));
	return (w->references != 1);
}

static struct winlink *
session_next_alert(struct winlink *wl)
{
	while (wl != NULL) {
		if (wl->flags & WINLINK_ALERTFLAGS)
			break;
		wl = winlink_next(wl);
	}
	return (wl);
}

/* Move session to next window. */
int
session_next(struct session *s, int alert)
{
	struct winlink	*wl;

	if (s->curw == NULL)
		return (-1);

	wl = winlink_next(s->curw);
	if (alert)
		wl = session_next_alert(wl);
	if (wl == NULL) {
		wl = RB_MIN(winlinks, &s->windows);
		if (alert && ((wl = session_next_alert(wl)) == NULL))
			return (-1);
	}
	return (session_set_current(s, wl));
}

static struct winlink *
session_previous_alert(struct winlink *wl)
{
	while (wl != NULL) {
		if (wl->flags & WINLINK_ALERTFLAGS)
			break;
		wl = winlink_previous(wl);
	}
	return (wl);
}

/* Move session to previous window. */
int
session_previous(struct session *s, int alert)
{
	struct winlink	*wl;

	if (s->curw == NULL)
		return (-1);

	wl = winlink_previous(s->curw);
	if (alert)
		wl = session_previous_alert(wl);
	if (wl == NULL) {
		wl = RB_MAX(winlinks, &s->windows);
		if (alert && (wl = session_previous_alert(wl)) == NULL)
			return (-1);
	}
	return (session_set_current(s, wl));
}

/* Move session to specific window. */
int
session_select(struct session *s, int idx)
{
	struct winlink	*wl;

	wl = winlink_find_by_index(&s->windows, idx);
	return (session_set_current(s, wl));
}

/* Move session to last used window. */
int
session_last(struct session *s)
{
	struct winlink	*wl;

	wl = TAILQ_FIRST(&s->lastw);
	if (wl == NULL)
		return (-1);
	if (wl == s->curw)
		return (1);

	return (session_set_current(s, wl));
}

/* Set current winlink to wl .*/
int
session_set_current(struct session *s, struct winlink *wl)
{
	if (wl == NULL)
		return (-1);
	if (wl == s->curw)
		return (1);

	winlink_stack_remove(&s->lastw, wl);
	winlink_stack_push(&s->lastw, s->curw);
	s->curw = wl;
	winlink_clear_flags(wl);
	window_update_activity(wl->window);
	return (0);
}

/* Find the session group containing a session. */
struct session_group *
session_group_contains(struct session *target)
{
	struct session_group	*sg;
	struct session		*s;

	RB_FOREACH(sg, session_groups, &session_groups) {
		TAILQ_FOREACH(s, &sg->sessions, gentry) {
			if (s == target)
				return (sg);
		}
	}
	return (NULL);
}

/* Find session group by name. */
struct session_group *
session_group_find(const char *name)
{
	struct session_group	sg;

	sg.name = name;
	return (RB_FIND(session_groups, &session_groups, &sg));
}

/* Create a new session group. */
struct session_group *
session_group_new(const char *name)
{
	struct session_group	*sg;

	if ((sg = session_group_find(name)) != NULL)
		return (sg);

	sg = xcalloc(1, sizeof *sg);
	sg->name = xstrdup(name);
	TAILQ_INIT(&sg->sessions);

	RB_INSERT(session_groups, &session_groups, sg);
	return (sg);
}

/* Add a session to a session group. */
void
session_group_add(struct session_group *sg, struct session *s)
{
	if (session_group_contains(s) == NULL)
		TAILQ_INSERT_TAIL(&sg->sessions, s, gentry);
}

/* Remove a session from its group and destroy the group if empty. */
static void
session_group_remove(struct session *s)
{
	struct session_group	*sg;

	if ((sg = session_group_contains(s)) == NULL)
		return;
	TAILQ_REMOVE(&sg->sessions, s, gentry);
	if (TAILQ_EMPTY(&sg->sessions)) {
		RB_REMOVE(session_groups, &session_groups, sg);
		free(sg);
	}
}

/* Count number of sessions in session group. */
static u_int
session_group_count(struct session_group *sg)
{
	struct session	*s;
	u_int		 n;

	n = 0;
	TAILQ_FOREACH(s, &sg->sessions, gentry)
	    n++;
	return (n);
}

/* Synchronize a session to its session group. */
void
session_group_synchronize_to(struct session *s)
{
	struct session_group	*sg;
	struct session		*target;

	if ((sg = session_group_contains(s)) == NULL)
		return;

	target = NULL;
	TAILQ_FOREACH(target, &sg->sessions, gentry) {
		if (target != s)
			break;
	}
	if (target != NULL)
		session_group_synchronize1(target, s);
}

/* Synchronize a session group to a session. */
void
session_group_synchronize_from(struct session *target)
{
	struct session_group	*sg;
	struct session		*s;

	if ((sg = session_group_contains(target)) == NULL)
		return;

	TAILQ_FOREACH(s, &sg->sessions, gentry) {
		if (s != target)
			session_group_synchronize1(target, s);
	}
}

/*
 * Synchronize a session with a target session. This means destroying all
 * winlinks then recreating them, then updating the current window, last window
 * stack and alerts.
 */
static void
session_group_synchronize1(struct session *target, struct session *s)
{
	struct winlinks		 old_windows, *ww;
	struct winlink_stack	 old_lastw;
	struct winlink		*wl, *wl2;

	/* Don't do anything if the session is empty (it'll be destroyed). */
	ww = &target->windows;
	if (RB_EMPTY(ww))
		return;

	/* If the current window has vanished, move to the next now. */
	if (s->curw != NULL &&
	    winlink_find_by_index(ww, s->curw->idx) == NULL &&
	    session_last(s) != 0 && session_previous(s, 0) != 0)
		session_next(s, 0);

	/* Save the old pointer and reset it. */
	memcpy(&old_windows, &s->windows, sizeof old_windows);
	RB_INIT(&s->windows);

	/* Link all the windows from the target. */
	RB_FOREACH(wl, winlinks, ww) {
		wl2 = winlink_add(&s->windows, wl->idx);
		wl2->session = s;
		winlink_set_window(wl2, wl->window);
		notify_session_window("window-linked", s, wl2->window);
		wl2->flags |= wl->flags & WINLINK_ALERTFLAGS;
	}

	/* Fix up the current window. */
	if (s->curw != NULL)
		s->curw = winlink_find_by_index(&s->windows, s->curw->idx);
	else
		s->curw = winlink_find_by_index(&s->windows, target->curw->idx);

	/* Fix up the last window stack. */
	memcpy(&old_lastw, &s->lastw, sizeof old_lastw);
	TAILQ_INIT(&s->lastw);
	TAILQ_FOREACH(wl, &old_lastw, sentry) {
		wl2 = winlink_find_by_index(&s->windows, wl->idx);
		if (wl2 != NULL)
			TAILQ_INSERT_TAIL(&s->lastw, wl2, sentry);
	}

	/* Then free the old winlinks list. */
	while (!RB_EMPTY(&old_windows)) {
		wl = RB_ROOT(&old_windows);
		wl2 = winlink_find_by_window_id(&s->windows, wl->window->id);
		if (wl2 == NULL)
			notify_session_window("window-unlinked", s, wl->window);
		winlink_remove(&old_windows, wl);
	}
}

/* Renumber the windows across winlinks attached to a specific session. */
void
session_renumber_windows(struct session *s)
{
	struct winlink		*wl, *wl1, *wl_new;
	struct winlinks		 old_wins;
	struct winlink_stack	 old_lastw;
	int			 new_idx, new_curw_idx;

	/* Save and replace old window list. */
	memcpy(&old_wins, &s->windows, sizeof old_wins);
	RB_INIT(&s->windows);

	/* Start renumbering from the base-index if it's set. */
	new_idx = options_get_number(s->options, "base-index");
	new_curw_idx = 0;

	/* Go through the winlinks and assign new indexes. */
	RB_FOREACH(wl, winlinks, &old_wins) {
		wl_new = winlink_add(&s->windows, new_idx);
		wl_new->session = s;
		winlink_set_window(wl_new, wl->window);
		wl_new->flags |= wl->flags & WINLINK_ALERTFLAGS;

		if (wl == s->curw)
			new_curw_idx = wl_new->idx;

		new_idx++;
	}

	/* Fix the stack of last windows now. */
	memcpy(&old_lastw, &s->lastw, sizeof old_lastw);
	TAILQ_INIT(&s->lastw);
	TAILQ_FOREACH(wl, &old_lastw, sentry) {
		wl_new = winlink_find_by_window(&s->windows, wl->window);
		if (wl_new != NULL)
			TAILQ_INSERT_TAIL(&s->lastw, wl_new, sentry);
	}

	/* Set the current window. */
	s->curw = winlink_find_by_index(&s->windows, new_curw_idx);

	/* Free the old winlinks (reducing window references too). */
	RB_FOREACH_SAFE(wl, winlinks, &old_wins, wl1)
		winlink_remove(&old_wins, wl);
}
@


1.72
log
@Instead of numbering session groups, give them a name which may be given
to -t instead of a target session. Also allow them to contain only one
session.
@
text
@d1 1
a1 1
/* $OpenBSD: session.c,v 1.71 2017/02/03 21:01:02 nicm Exp $ */
a357 5
	env = environ_create();
	environ_copy(global_environ, env);
	environ_copy(s->environ, env);
	server_fill_environ(s, env);

d363 1
d372 1
a373 1
	environ_free(env);
@


1.71
log
@Cache status line position to reduce option lookups during output.
@
text
@d1 1
a1 1
/* $OpenBSD: session.c,v 1.70 2016/10/19 09:22:07 nicm Exp $ */
d45 3
d56 8
d121 3
a123 3
session_create(const char *name, int argc, char **argv, const char *path,
    const char *cwd, struct environ *env, struct termios *tio, int idx,
    u_int sx, u_int sy, char **cause)
d164 4
a167 1
			xasprintf(&s->name, "%u", s->id);
d446 1
a446 1
	if ((sg = session_group_find(s)) != NULL)
d557 1
a557 1
session_group_find(struct session *target)
d562 1
a562 1
	TAILQ_FOREACH(sg, &session_groups, entry) {
d571 3
a573 3
/* Find session group index. */
u_int
session_group_index(struct session_group *sg)
d575 5
a579 2
	struct session_group   *sg2;
	u_int			i;
d581 12
a592 6
	i = 0;
	TAILQ_FOREACH(sg2, &session_groups, entry) {
		if (sg == sg2)
			return (i);
		i++;
	}
d594 2
a595 1
	fatalx("session group not found");
d598 1
a598 4
/*
 * Add a session to the session group containing target, creating it if
 * necessary.
 */
d600 1
a600 1
session_group_add(struct session *target, struct session *s)
d602 2
a603 9
	struct session_group	*sg;

	if ((sg = session_group_find(target)) == NULL) {
		sg = xmalloc(sizeof *sg);
		TAILQ_INSERT_TAIL(&session_groups, sg, entry);
		TAILQ_INIT(&sg->sessions);
		TAILQ_INSERT_TAIL(&sg->sessions, target, gentry);
	}
	TAILQ_INSERT_TAIL(&sg->sessions, s, gentry);
d612 1
a612 1
	if ((sg = session_group_find(s)) == NULL)
a614 2
	if (TAILQ_NEXT(TAILQ_FIRST(&sg->sessions), gentry) == NULL)
		TAILQ_REMOVE(&sg->sessions, TAILQ_FIRST(&sg->sessions), gentry);
d616 1
a616 1
		TAILQ_REMOVE(&session_groups, sg, entry);
d641 1
a641 1
	if ((sg = session_group_find(s)) == NULL)
d649 2
a650 1
	session_group_synchronize1(target, s);
d660 1
a660 1
	if ((sg = session_group_find(target)) == NULL)
@


1.70
log
@Alerts are too slow, so rather than walking all sessions and windows,
add a link of winlinks to each window and a pointer to the session to
each winlink. Also rewrite the alerts processing to return to the old
behaviour (alert in any window sets the flag on any winlink).
@
text
@d1 1
a1 1
/* $OpenBSD: session.c,v 1.69 2016/10/19 08:17:11 nicm Exp $ */
d133 2
@


1.69
log
@Move session-create hook out of session_create so it works with grouped sessions.
@
text
@d1 1
a1 1
/* $OpenBSD: session.c,v 1.68 2016/10/16 22:06:40 nicm Exp $ */
d340 1
d377 1
d414 2
a415 2
	RB_FOREACH(wl, winlinks, &s->windows) {
		if (wl->window == w)
d684 1
d735 1
@


1.68
log
@Use the notify name string instead of going via an enum and change
existing hooks to use notifys instead.
@
text
@d1 1
a1 1
/* $OpenBSD: session.c,v 1.67 2016/10/15 09:27:52 nicm Exp $ */
a171 1
	notify_session("session-created", s);
@


1.67
log
@Give window_create and window_create1 better names.
@
text
@d1 1
a1 1
/* $OpenBSD: session.c,v 1.66 2016/10/15 00:12:58 nicm Exp $ */
d172 1
a172 1
	notify_session_created(s);
d217 1
a217 1
	notify_session_closed(s);
d230 1
a230 1
		notify_window_unlinked(s, wl->window);
d360 1
a360 1
	notify_window_linked(s, w);
d378 1
a378 1
	notify_window_linked(s, w);
d394 1
a394 1
	notify_window_unlinked(s, wl->window);
d684 1
a684 1
		notify_window_linked(s, wl2->window);
d708 1
a708 1
			notify_window_unlinked(s, wl->window);
@


1.66
log
@Rename a function for consistency and some spacing nits.
@
text
@d1 1
a1 1
/* $OpenBSD: session.c,v 1.65 2016/10/13 21:37:03 nicm Exp $ */
d352 1
a352 1
	w = window_create(name, argc, argv, path, shell, cwd, env, s->tio,
@


1.65
log
@Remove the set-remain-on-exit option, it was always a hack and can now
be done with hooks instead.
@
text
@d1 1
a1 1
/* $OpenBSD: session.c,v 1.64 2016/10/11 13:21:59 nicm Exp $ */
d214 1
d389 2
a390 1
	    session_last(s) != 0 && session_previous(s, 0) != 0)
d397 1
d399 1
@


1.64
log
@Add static in window-*.c and move some internal functions out of tmux.h.
@
text
@d1 1
a1 1
/* $OpenBSD: session.c,v 1.63 2016/10/10 21:29:23 nicm Exp $ */
a360 3

	if (options_get_number(s->options, "set-remain-on-exit"))
		options_set_number(w->options, "remain-on-exit", 1);
@


1.63
log
@Loads more static, except for cmd-*.c and window-*.c.
@
text
@d1 1
a1 1
/* $OpenBSD: session.c,v 1.62 2016/01/19 15:59:12 nicm Exp $ */
d41 4
d589 1
a589 1
void
d606 1
a606 1
u_int
d657 1
a657 1
void
@


1.62
log
@I no longer use my SourceForge address so replace it.
@
text
@d1 1
a1 1
/* $OpenBSD: session.c,v 1.61 2015/12/08 01:10:31 nicm Exp $ */
d30 3
a32 3
struct sessions	sessions;
u_int		next_session_id;
struct session_groups session_groups;
d34 1
a34 1
void	session_free(int, short, void *);
d36 1
a36 1
void	session_lock_timer(int, short, void *);
d38 2
a39 2
struct winlink *session_next_alert(struct winlink *);
struct winlink *session_previous_alert(struct winlink *);
d185 1
a185 1
void
d242 1
a242 1
void
d429 1
a429 1
struct winlink *
d460 1
a460 1
struct winlink *
@


1.61
log
@Add hooks infrastructure, basic commands (set-hook, show-hooks) and a
couple of not very useful client hooks. This will eventually let
commands be run at various points and on notifications. Joint work with
Thomas Adam.
@
text
@d1 1
a1 1
/* $OpenBSD: session.c,v 1.60 2015/11/18 14:27:44 nicm Exp $ */
d4 1
a4 1
 * Copyright (c) 2007 Nicholas Marriott <nicm@@users.sourceforge.net>
@


1.60
log
@Use __unused rather than rolling our own.
@
text
@d1 1
a1 1
/* $OpenBSD: session.c,v 1.59 2015/11/18 09:22:29 nicm Exp $ */
d126 1
d128 1
d194 1
d196 1
@


1.59
log
@Don't update activity time twice for new sessions, and add some logging.
@
text
@d1 1
a1 1
/* $OpenBSD: session.c,v 1.58 2015/10/31 08:13:58 nicm Exp $ */
d184 1
a184 1
session_free(unused int fd, unused short events, void *arg)
d239 1
a239 1
session_lock_timer(unused int fd, unused short events, void *arg)
@


1.58
log
@Because pledge(2) does not allow us to pass directory file descriptors
around, we can't use file descriptors for the working directory because
we will be unable to pass it to a privileged process to tell it where to
read or write files or spawn children. So move tmux back to using
strings for the current working directory. We try to check it exists
with access() when it is set but ultimately fall back to ~ if it fails
at time of use (or / if that fails too).
@
text
@d1 1
a1 1
/* $OpenBSD: session.c,v 1.57 2015/10/28 09:51:55 nicm Exp $ */
a133 4
	if (gettimeofday(&s->creation_time, NULL) != 0)
		fatal("gettimeofday failed");
	session_update_activity(s, &s->creation_time);

d150 2
d265 4
@


1.57
log
@Like options, move the environ struct into environ.c.
@
text
@d1 1
a1 1
/* $OpenBSD: session.c,v 1.56 2015/10/27 15:58:42 nicm Exp $ */
d107 2
a108 2
    int cwd, struct environ *env, struct termios *tio, int idx, u_int sx,
    u_int sy, char **cause)
d117 1
a117 1
	s->cwd = dup(cwd);
d227 1
a227 1
	close(s->cwd);
d318 1
a318 1
    const char *path, int cwd, int idx, char **cause)
@


1.56
log
@Move struct options into options.c.
@
text
@d1 1
a1 1
/* $OpenBSD: session.c,v 1.55 2015/09/01 18:50:16 nicm Exp $ */
d123 1
a123 1
	environ_init(&s->environ);
d125 1
a125 1
		environ_copy(env, &s->environ);
d193 1
a193 1
		environ_free(&s->environ);
d322 1
a322 1
	struct environ	 env;
d331 4
a334 4
	environ_init(&env);
	environ_copy(&global_environ, &env);
	environ_copy(&s->environ, &env);
	server_fill_environ(s, &env);
d341 1
a341 1
	w = window_create(name, argc, argv, path, shell, cwd, &env, s->tio,
d345 1
a345 1
		environ_free(&env);
d350 1
a350 1
	environ_free(&env);
@


1.55
log
@Fix a spelling error, sesson -> session.
@
text
@d1 1
a1 1
/* $OpenBSD: session.c,v 1.54 2015/08/29 08:30:54 nicm Exp $ */
a122 1
	options_init(&s->options, &global_s_options);
d126 1
d193 3
a217 2
	environ_free(&s->environ);
	options_free(&s->options);
d275 1
a275 1
		tv.tv_sec = options_get_number(&s->options, "lock-after-time");
d336 1
a336 1
	shell = options_get_string(&s->options, "default-shell");
d340 1
a340 1
	hlimit = options_get_number(&s->options, "history-limit");
d352 2
a353 2
	if (options_get_number(&s->options, "set-remain-on-exit"))
		options_set_number(&w->options, "remain-on-exit", 1);
d716 1
a716 1
	new_idx = options_get_number(&s->options, "base-index");
@


1.54
log
@Move alerts onto events rather than checking every loop.
@
text
@d1 1
a1 1
/* $OpenBSD: session.c,v 1.53 2015/08/28 13:16:03 nicm Exp $ */
d190 1
a190 1
	log_debug("sesson %s freed (%d references)", s->name, s->references);
@


1.53
log
@Don't leak name when freeing session, from Kuang-che Wu.
@
text
@d1 1
a1 1
/* $OpenBSD: session.c,v 1.52 2015/08/28 13:12:20 nicm Exp $ */
d522 1
@


1.52
log
@Per-session timers for locking, and remove the global one-second timer.
@
text
@d1 1
a1 1
/* $OpenBSD: session.c,v 1.51 2015/08/28 13:01:03 nicm Exp $ */
d192 2
a193 1
	if (s->references == 0)
d195 1
@


1.51
log
@Make session_update_activity more useful and use it in more places.
@
text
@d1 1
a1 1
/* $OpenBSD: session.c,v 1.50 2015/06/05 18:18:32 nicm Exp $ */
d36 2
d113 1
a113 1
	s = xmalloc(sizeof *s);
d154 4
d209 3
d236 16
d257 1
d264 12
@


1.50
log
@Similarly, for sessions use a callback to free rather than checking
every loop.
@
text
@d1 1
a1 1
/* $OpenBSD: session.c,v 1.49 2015/05/06 08:35:39 nicm Exp $ */
a114 4
	if (gettimeofday(&s->creation_time, NULL) != 0)
		fatal("gettimeofday failed");
	session_update_activity(s);

d132 4
d227 1
a227 1
/* Update session active time. */
d229 1
a229 1
session_update_activity(struct session *s)
d231 7
a237 2
	if (gettimeofday(&s->activity_time, NULL) != 0)
		fatal("gettimeofday");
@


1.49
log
@Add a format window_linked which is 1 if a window has been linked
multiple times, also remove the default space in window_flags and use a
conditional to add it in window-status-format (this means additional
flags can be added in the option without extra spaces). From Thomas Adam
with tweaks by me.
@
text
@d1 1
a1 1
/* $OpenBSD: session.c,v 1.48 2015/04/25 18:09:28 nicm Exp $ */
a29 1
/* Global session list. */
a30 1
struct sessions dead_sessions;
d34 2
d112 1
a112 1
	s->references = 0;
d167 23
d217 1
a217 1
	RB_INSERT(sessions, &dead_sessions, s);
@


1.48
log
@Move the functions to convert ids from strings into session.c and window.c.
@
text
@d1 1
a1 1
/* $OpenBSD: session.c,v 1.47 2015/04/22 15:32:33 nicm Exp $ */
d338 14
@


1.47
log
@Make session_has return a flag, returning the first winlink found is a
recipe for errors.
@
text
@d1 1
a1 1
/* $OpenBSD: session.c,v 1.46 2014/10/22 23:18:53 nicm Exp $ */
d71 16
@


1.46
log
@Fix some spacing nits.
@
text
@d1 1
a1 1
/* $OpenBSD: session.c,v 1.45 2014/10/22 23:11:41 nicm Exp $ */
d312 1
a312 1
struct winlink *
d319 1
a319 1
			return (wl);
d321 1
a321 1
	return (NULL);
@


1.45
log
@Merge unlink-window into kill-window.
@
text
@d1 1
a1 1
/* $OpenBSD: session.c,v 1.44 2014/05/13 08:08:32 nicm Exp $ */
d130 1
a130 1
			free (s->name);
@


1.44
log
@If multiple arguments are given to new-session, new-window,
split-window, respawn-window or respawn-pane, pass them directly to
execvp() to help avoid quoting problems. One argument still goes to "sh
-c" like before. Requested by many over the years. Patch from J Raynor.
@
text
@d1 1
a1 1
/* $OpenBSD: session.c,v 1.43 2014/04/17 13:02:59 nicm Exp $ */
d495 13
d595 3
a597 2
		if (winlink_find_by_window_id(&s->windows, wl->window->id) == NULL)
		    notify_window_unlinked(s, wl->window);
@


1.43
log
@Set PATH explicitly, either from client or session
environment. Previously it came from the session environment. From J
Raynor.
@
text
@d1 1
a1 1
/* $OpenBSD: session.c,v 1.42 2014/01/22 14:00:08 nicm Exp $ */
d88 3
a90 3
session_create(const char *name, const char *cmd, const char *path, int cwd,
    struct environ *env, struct termios *tio, int idx, u_int sx, u_int sy,
    char **cause)
d93 1
d136 3
a138 2
	if (cmd != NULL) {
		if (session_new(s, NULL, cmd, path, cwd, idx, cause) == NULL) {
d232 1
a232 1
session_new(struct session *s, const char *name, const char *cmd,
d256 2
a257 2
	w = window_create(name, cmd, path, shell, cwd, &env, s->tio, s->sx,
	    s->sy, hlimit, cause);
@


1.42
log
@Do not permit periods in session names (colons are already banned). From
J Raynor.
@
text
@d1 1
a1 1
/* $OpenBSD: session.c,v 1.41 2013/10/10 12:26:36 nicm Exp $ */
d88 3
a90 2
session_create(const char *name, const char *cmd, int cwd, struct environ *env,
    struct termios *tio, int idx, u_int sx, u_int sy, char **cause)
d136 1
a136 1
		if (session_new(s, NULL, cmd, cwd, idx, cause) == NULL) {
d230 2
a231 2
session_new(struct session *s, const char *name, const char *cmd, int cwd,
    int idx, char **cause)
d254 2
a255 2
	w = window_create(name, cmd, shell, cwd, &env, s->tio, s->sx, s->sy,
	    hlimit, cause);
@


1.41
log
@Alter how tmux handles the working directory to internally use file
descriptors rather than strings.

- Each session still has a current working directory.

- New sessions still get their working directory from the client that
  created them or its attached session if any.

- New windows are created by default in the session working directory.

- The -c flag to new, neww, splitw allows the working directory to be
  overridden.

- The -c flag to attach let's the session working directory be changed.

- The default-path option has been removed.

To get the equivalent to default-path '.', do:

        bind c neww -c $PWD

To get the equivalent of default-path '~', do:

        bind c neww -c ~

This also changes the client identify protocol to be a set of messages rather
than one as well as some other changes that should make it easier to make
backwards-compatible protocol changes in future.
@
text
@d1 1
a1 1
/* $OpenBSD: session.c,v 1.40 2013/10/10 11:58:24 nicm Exp $ */
d178 1
a178 1
/* Check a session name is valid: not empty and no colons. */
d182 1
a182 1
	return (*name != '\0' && strchr(name, ':') == NULL);
@


1.40
log
@Renumber windows: Lookup lastw via window not index

When calling 'movew -r' on a session to reorder the winlinks, ensure
when adding back in the information for the lastw stack that we look up
the winlink based on the window and not its index.

Using the index doesn't make sense here because when comparing it to the
old set, it will never match since the winlink has been renumbered.

Bug reported by Ben Boeckel. Patch by Thomas Adam.
@
text
@d1 1
a1 1
/* $OpenBSD: session.c,v 1.39 2013/10/10 11:46:29 nicm Exp $ */
d88 2
a89 3
session_create(const char *name, const char *cmd, const char *cwd,
    struct environ *env, struct termios *tio, int idx, u_int sx, u_int sy,
    char **cause)
d101 1
a101 1
	s->cwd = xstrdup(cwd);
d173 1
a173 1
	free(s->cwd);
d229 2
a230 2
session_new(struct session *s,
    const char *name, const char *cmd, const char *cwd, int idx, char **cause)
d253 2
a254 2
	w = window_create(
	    name, cmd, shell, cwd, &env, s->tio, s->sx, s->sy, hlimit, cause);
@


1.39
log
@Grouped sessions were being leaked on destroy, correctly free them.
@
text
@d1 1
a1 1
/* $OpenBSD: session.c,v 1.38 2013/03/25 10:11:45 nicm Exp $ */
d619 1
a619 1
		wl_new = winlink_find_by_index(&s->windows, wl->idx);
@


1.38
log
@Rename session idx to session id throughout and add $ prefix to targets
to use it, extended from a diff from George Nachman.
@
text
@d1 1
a1 1
/* $OpenBSD: session.c,v 1.37 2013/03/22 16:00:26 nicm Exp $ */
d154 1
@


1.37
log
@Add session_set_current helper function, extracted from a diff from
Aaron Jensen.
@
text
@d1 1
a1 1
/* $OpenBSD: session.c,v 1.36 2012/07/10 11:53:01 nicm Exp $ */
d33 1
a33 1
u_int		next_session;
d73 1
a73 1
/* Find session by index. */
d75 1
a75 1
session_find_by_index(u_int idx)
d80 1
a80 1
		if (s->idx == idx)
d124 1
a124 1
		s->idx = next_session++;
d128 1
a128 1
			s->idx = next_session++;
d130 1
a130 1
			xasprintf(&s->name, "%u", s->idx);
@


1.36
log
@xfree is not particularly helpful, remove it. From Thomas Adam.
@
text
@d1 1
a1 1
/* $OpenBSD: session.c,v 1.35 2012/07/08 07:27:32 nicm Exp $ */
d349 1
a349 7
	if (wl == s->curw)
		return (1);
	winlink_stack_remove(&s->lastw, wl);
	winlink_stack_push(&s->lastw, s->curw);
	s->curw = wl;
	winlink_clear_flags(wl);
	return (0);
d380 1
a380 7
	if (wl == s->curw)
		return (1);
	winlink_stack_remove(&s->lastw, wl);
	winlink_stack_push(&s->lastw, s->curw);
	s->curw = wl;
	winlink_clear_flags(wl);
	return (0);
d390 1
a390 9
	if (wl == NULL)
		return (-1);
	if (wl == s->curw)
		return (1);
	winlink_stack_remove(&s->lastw, wl);
	winlink_stack_push(&s->lastw, s->curw);
	s->curw = wl;
	winlink_clear_flags(wl);
	return (0);
d400 12
@


1.35
log
@Clear flags across all sessions, from Thomas Adam.
@
text
@d1 1
a1 1
/* $OpenBSD: session.c,v 1.34 2012/04/29 17:20:01 nicm Exp $ */
d129 1
a129 2
			if (s->name != NULL)
				xfree (s->name);
d159 1
a159 2
	if (s->tio != NULL)
		xfree(s->tio);
d173 1
a173 1
	xfree(s->cwd);
d496 1
a496 1
		xfree(sg);
@


1.34
log
@Add a flag to move-window to renumber the windows in a session (closing
any gaps) and add an option to do this automatically each time a window
is killed. From Thomas Adam.
@
text
@d1 1
a1 1
/* $OpenBSD: session.c,v 1.33 2012/03/17 22:35:09 nicm Exp $ */
d356 1
a356 1
	wl->flags &= ~WINLINK_ALERTFLAGS;
d393 1
a393 1
	wl->flags &= ~WINLINK_ALERTFLAGS;
d411 1
a411 1
	wl->flags &= ~WINLINK_ALERTFLAGS;
d430 1
a430 1
	wl->flags &= ~WINLINK_ALERTFLAGS;
@


1.33
log
@Add notify hooks for various events, the functions are currently empty
stubs but will be filled in for control mode later. From George Nachman.
@
text
@d1 1
a1 1
/* $OpenBSD: session.c,v 1.32 2011/08/16 09:36:23 nicm Exp $ */
d593 46
@


1.32
log
@Correctly skip existing numbers when generating the name for a new
session.
@
text
@d1 1
a1 1
/* $OpenBSD: session.c,v 1.31 2011/04/06 21:51:31 nicm Exp $ */
d145 1
d154 1
d158 1
d169 5
a173 2
	while (!RB_EMPTY(&s->windows))
		winlink_remove(&s->windows, RB_ROOT(&s->windows));
d263 1
d284 1
d299 1
d567 1
d589 2
@


1.31
log
@Change so that an empty session name always means the current sessions
even if given with, for example, -t '', and explicitly forbid empty
session names and those containing a : when they are created.
@
text
@d1 1
a1 1
/* $OpenBSD: session.c,v 1.30 2011/01/25 22:31:50 nicm Exp $ */
d122 1
a122 2
	s->idx = next_session++;
	if (name != NULL)
d124 10
a133 2
	else
		xasprintf(&s->name, "%u", s->idx);
@


1.30
log
@Check if the index is in use and fail before creating the child process,
rather than leaving a stray child on failure.
@
text
@d1 1
a1 1
/* $OpenBSD: session.c,v 1.29 2011/01/13 02:08:14 nicm Exp $ */
d165 7
@


1.29
log
@Er, fix next and previous session functions to actually work, part 2.
@
text
@d1 1
a1 1
/* $OpenBSD: session.c,v 1.28 2011/01/13 02:07:06 nicm Exp $ */
d215 1
d220 5
d238 1
d242 1
d248 2
a249 1
	return (session_attach(s, w, idx, cause));
d258 1
a258 1
	if ((wl = winlink_add(&s->windows, w, idx)) == NULL)
d260 4
d542 2
a543 1
		wl2 = winlink_add(&s->windows, wl->window, wl->idx);
@


1.28
log
@Fix next and previous session functions to actually work.
@
text
@d1 1
a1 1
/* $OpenBSD: session.c,v 1.27 2011/01/01 01:12:09 nicm Exp $ */
d184 1
a184 1
	s2 = RB_NEXT(sessions, &sessions, s2);
d201 1
a201 1
	s2 = RB_PREV(sessions, &sessions, s2);
@


1.27
log
@Don't reset the activity timer for unattached sessions every second,
this screws up the choice of most-recently-used. Instead, break the time
update into a little function and do it when the session is attached.

Pointed out by joshe@@.
@
text
@d1 1
a1 1
/* $OpenBSD: session.c,v 1.26 2010/12/30 23:16:18 nicm Exp $ */
d184 3
a186 6
	s2 = s;
	do {
		s2 = RB_NEXT(sessions, &sessions, s2);
		if (s2 == NULL)
			s2 = RB_MIN(sessions, &sessions);
	} while (s2 != s);
d201 3
a203 6
	s2 = s;
	do {
		s2 = RB_PREV(sessions, &sessions, s2);
		if (s2 == NULL)
			s2 = RB_MAX(sessions, &sessions);
	} while (s2 != s);
@


1.26
log
@Change from a per-session stack of buffers to one global stack which is
much more convenient and also simplifies lot of code. This renders
copy-buffer useless and makes buffer-limit now a server option.

By Tiago Cunha.
@
text
@d1 1
a1 1
/* $OpenBSD: session.c,v 1.25 2010/12/21 22:37:59 nicm Exp $ */
d100 1
a100 1
	memcpy(&s->activity_time, &s->creation_time, sizeof s->activity_time);
d165 8
@


1.25
log
@Store sessions in an RB tree by name rather than a list, this is tidier
and allows them to easily be shown sorted in various lists
(list-sessions/choose-sessions).

Keep a session index which is used in a couple of places internally but
make it an ever-increasing number rather than filling in gaps with new
sessions.
@
text
@d1 1
a1 1
/* $OpenBSD: session.c,v 1.24 2010/12/20 01:28:18 nicm Exp $ */
a107 2
	paste_init_stack(&s->buffers);

a155 1
	paste_free_stack(&s->buffers);
@


1.24
log
@Fix another stray addition that was too early. Oops.
@
text
@d1 1
a1 1
/* $OpenBSD: session.c,v 1.23 2010/12/20 00:43:24 nicm Exp $ */
d33 1
d39 8
d54 1
a54 1
	u_int	idx;
d56 5
a60 1
	return (session_index(s, &idx) == 0);
d67 10
a77 1
	u_int		 i;
d79 2
a80 3
	for (i = 0; i < ARRAY_LENGTH(&sessions); i++) {
		s = ARRAY_ITEM(&sessions, i);
		if (s != NULL && strcmp(s->name, name) == 0)
a82 1

a92 1
	u_int		 i;
d124 1
a124 9
	for (i = 0; i < ARRAY_LENGTH(&sessions); i++) {
		if (ARRAY_ITEM(&sessions, i) == NULL) {
			ARRAY_SET(&sessions, i, s);
			break;
		}
	}
	if (i == ARRAY_LENGTH(&sessions))
		ARRAY_ADD(&sessions, s);

d128 2
a129 1
		xasprintf(&s->name, "%u", i);
a147 2
	u_int	i;

d150 1
a150 5
	if (session_index(s, &i) != 0)
		fatalx("session not found");
	ARRAY_SET(&sessions, i, NULL);
	while (!ARRAY_EMPTY(&sessions) && ARRAY_LAST(&sessions) == NULL)
		ARRAY_TRUNC(&sessions, 1);
a165 1
	xfree(s->name);
d167 1
a167 19
	for (i = 0; i < ARRAY_LENGTH(&dead_sessions); i++) {
		if (ARRAY_ITEM(&dead_sessions, i) == NULL) {
			ARRAY_SET(&dead_sessions, i, s);
			break;
		}
	}
	if (i == ARRAY_LENGTH(&dead_sessions))
		ARRAY_ADD(&dead_sessions, s);
}

/* Find session index. */
int
session_index(struct session *s, u_int *i)
{
	for (*i = 0; *i < ARRAY_LENGTH(&sessions); (*i)++) {
		if (s == ARRAY_ITEM(&sessions, *i))
			return (0);
	}
	return (-1);
a174 1
	u_int		i;
d176 1
a176 1
	if (ARRAY_LENGTH(&sessions) == 0 || session_index(s, &i) != 0)
d179 1
d181 6
a186 7
		if (i == ARRAY_LENGTH(&sessions) - 1)
			i = 0;
		else
			i++;
		s2 = ARRAY_ITEM(&sessions, i);
	} while (s2 == NULL);

a194 1
	u_int		i;
d196 1
a196 1
	if (ARRAY_LENGTH(&sessions) == 0 || session_index(s, &i) != 0)
d199 1
d201 6
a206 7
		if (i == 0)
			i = ARRAY_LENGTH(&sessions) - 1;
		else
			i--;
		s2 = ARRAY_ITEM(&sessions, i);
	} while (s2 == NULL);

@


1.23
log
@Undo a change to next/previous session that got mixed in prematurely.
@
text
@d1 1
a1 1
/* $OpenBSD: session.c,v 1.22 2010/12/20 00:19:20 nicm Exp $ */
a192 1
	i = 0;
@


1.22
log
@Dead sessions are never on the active sessions list, so the SESSION_DEAD
flag is effectively unused. Remove it.
@
text
@d1 1
a1 1
/* $OpenBSD: session.c,v 1.21 2010/12/20 00:03:55 nicm Exp $ */
d190 1
a190 1
	if (ARRAY_LENGTH(&sessions) == 0 || !session_alive(s))
d193 1
d212 1
a212 1
	if (ARRAY_LENGTH(&sessions) == 0 || !session_alive(s))
@


1.21
log
@Unify the way sessions are used by callbacks - store the address and use
the reference count, then check it is still on the global sessions list
in the callback.
@
text
@d1 1
a1 1
/* $OpenBSD: session.c,v 1.20 2010/09/08 22:02:28 nicm Exp $ */
a169 1
	s->flags |= SESSION_DEAD;
d190 1
a190 1
	if (ARRAY_LENGTH(&sessions) == 0 || session_index(s, &i) != 0)
d199 1
a199 1
	} while (s2 == NULL || s2->flags & SESSION_DEAD);
d211 1
a211 1
	if (ARRAY_LENGTH(&sessions) == 0 || session_index(s, &i) != 0)
d220 1
a220 1
	} while (s2 == NULL || s2->flags & SESSION_DEAD);
@


1.20
log
@Add -n and -p flags to switch-client to move to the next and previous
session (yes, it doesn't match window/pane, but so what, nor does
switch-client).

Based on a diff long ago from "edsouza".
@
text
@d1 1
a1 1
/* $OpenBSD: session.c,v 1.19 2010/06/27 02:56:59 nicm Exp $ */
d37 12
@


1.19
log
@Store the current working directory in the session, change the default-path
option to default to empty and make that mean that the stored session CWD is
used.
@
text
@d1 1
a1 1
/* $OpenBSD: session.c,v 1.18 2010/06/21 01:27:46 nicm Exp $ */
d170 42
@


1.18
log
@Having a list of winlinks->alerts for each session is stupid, just store
the alert flags directly in the winlink itself.
@
text
@d1 1
a1 1
/* $OpenBSD: session.c,v 1.17 2010/06/21 00:25:32 nicm Exp $ */
d71 2
d147 1
@


1.17
log
@Rename activity->alert in a couple of functions for consistency.
@
text
@d1 1
a1 1
/* $OpenBSD: session.c,v 1.16 2009/12/22 10:20:08 nicm Exp $ */
d35 2
a36 65
struct winlink *session_next_alert(struct session *, struct winlink *);
struct winlink *session_previous_alert(struct session *, struct winlink *);

void
session_alert_cancel(struct session *s, struct winlink *wl)
{
	struct session_alert	*sa, *sb;

	sa = SLIST_FIRST(&s->alerts);
	while (sa != NULL) {
		sb = sa;
		sa = SLIST_NEXT(sa, entry);

		if (wl == NULL || sb->wl == wl) {
			SLIST_REMOVE(&s->alerts, sb, session_alert, entry);
			xfree(sb);
		}
	}
}

void
session_alert_add(struct session *s, struct window *w, int type)
{
	struct session_alert	*sa;
	struct winlink		*wl;

	RB_FOREACH(wl, winlinks, &s->windows) {
		if (wl == s->curw)
			continue;

		if (wl->window == w &&
		    !session_alert_has(s, wl, type)) {
			sa = xmalloc(sizeof *sa);
			sa->wl = wl;
			sa->type = type;
			SLIST_INSERT_HEAD(&s->alerts, sa, entry);
		}
	}
}

int
session_alert_has(struct session *s, struct winlink *wl, int type)
{
	struct session_alert	*sa;

	SLIST_FOREACH(sa, &s->alerts, entry) {
		if (sa->wl == wl && sa->type == type)
			return (1);
	}

	return (0);
}

int
session_alert_has_window(struct session *s, struct window *w, int type)
{
	struct session_alert	*sa;

	SLIST_FOREACH(sa, &s->alerts, entry) {
		if (sa->wl->window == w && sa->type == type)
			return (1);
	}

	return (0);
}
a73 1
	SLIST_INIT(&s->alerts);
a135 1
	session_alert_cancel(s, NULL);
d223 1
a223 1
	session_alert_cancel(s, wl);
d235 1
a235 1
int
d242 1
a242 1
			return (1);
d244 1
a244 1
	return (0);
d248 1
a248 1
session_next_alert(struct session *s, struct winlink *wl)
d251 1
a251 5
		if (session_alert_has(s, wl, WINDOW_BELL))
			break;
		if (session_alert_has(s, wl, WINDOW_ACTIVITY))
			break;
		if (session_alert_has(s, wl, WINDOW_CONTENT))
d269 1
a269 1
		wl = session_next_alert(s, wl);
d272 1
a272 1
		if (alert && ((wl = session_next_alert(s, wl)) == NULL))
d280 1
a280 1
	session_alert_cancel(s, wl);
d285 1
a285 1
session_previous_alert(struct session *s, struct winlink *wl)
d288 1
a288 5
		if (session_alert_has(s, wl, WINDOW_BELL))
			break;
		if (session_alert_has(s, wl, WINDOW_ACTIVITY))
			break;
		if (session_alert_has(s, wl, WINDOW_CONTENT))
d306 1
a306 1
		wl = session_previous_alert(s, wl);
d309 1
a309 1
		if (alert && (wl = session_previous_alert(s, wl)) == NULL)
d317 1
a317 1
	session_alert_cancel(s, wl);
d335 1
a335 1
	session_alert_cancel(s, wl);
d354 1
a354 1
	session_alert_cancel(s, wl);
a470 1
	struct session_alert	*sa;
d488 4
a491 2
	RB_FOREACH(wl, winlinks, ww)
		winlink_add(&s->windows, wl->window, wl->idx);
a505 9
	}

	/* And update the alerts list. */
	SLIST_FOREACH(sa, &s->alerts, entry) {
		wl = winlink_find_by_index(&s->windows, sa->wl->idx);
		if (wl == NULL)
			session_alert_cancel(s, sa->wl);
		else
			sa->wl = wl;
@


1.16
log
@Fix a couple of problems with grouped sessions reported by danh: redraw
properly and choose the correct last window after a window is killed.
@
text
@d1 1
a1 1
/* $OpenBSD: session.c,v 1.15 2009/12/03 22:50:10 nicm Exp $ */
d35 2
a36 2
struct winlink *session_next_activity(struct session *, struct winlink *);
struct winlink *session_previous_activity(struct session *, struct winlink *);
d313 1
a313 1
session_next_activity(struct session *s, struct winlink *wl)
d329 1
a329 1
session_next(struct session *s, int activity)
d337 2
a338 2
	if (activity)
		wl = session_next_activity(s, wl);
d341 1
a341 1
		if (activity && ((wl = session_next_activity(s, wl)) == NULL))
d354 1
a354 1
session_previous_activity(struct session *s, struct winlink *wl)
d370 1
a370 1
session_previous(struct session *s, int activity)
d378 2
a379 2
	if (activity)
		wl = session_previous_activity(s, wl);
d382 1
a382 1
		if (activity && (wl = session_previous_activity(s, wl)) == NULL)
@


1.15
log
@Massive spaces->tabs and trailing whitespace cleanup, hopefully for the last
time now I've configured emacs to make them displayed in really annoying
colours...
@
text
@d1 1
a1 1
/* $OpenBSD: session.c,v 1.14 2009/11/26 21:37:13 nicm Exp $ */
d552 4
a555 4
	if (s->curw != NULL) {
		while (winlink_find_by_index(ww, s->curw->idx) == NULL)
			session_next(s, 0);
	}
@


1.14
log
@Remove a couple of unused arguments where possible, and add /* ARGSUSED */ to
the rest to reduce lint output.
@
text
@d1 1
a1 1
/* $OpenBSD: session.c,v 1.13 2009/11/13 14:47:31 nicm Exp $ */
d168 1
a168 1
	
d211 1
a211 1
	
d236 1
a236 1
session_new(struct session *s, 
d466 1
a466 1
 * necessary. 
@


1.13
log
@Use winlink_remove() to remove old winlinks when synchronizing grouped sessions
rather than doing it manually and not adjusted the reference count. Fixes
crash seen by Dan Harnett.
@
text
@d1 1
a1 1
/* $OpenBSD: session.c,v 1.12 2009/11/03 20:29:47 nicm Exp $ */
d322 1
a322 1
		wl = winlink_next(&s->windows, wl);
d336 1
a336 1
	wl = winlink_next(&s->windows, s->curw);
d363 1
a363 1
		wl = winlink_previous(&s->windows, wl);
d377 1
a377 1
	wl = winlink_previous(&s->windows, s->curw);
@


1.12
log
@Change session and client activity and creation time members to have more
meaningful names.

Also, remove the code to try and update the session activity time for the
command client when a command message is received as is pointless because it
des not have a session.
@
text
@d1 1
a1 1
/* $OpenBSD: session.c,v 1.11 2009/10/10 10:02:48 nicm Exp $ */
d592 1
a592 2
		RB_REMOVE(winlinks, &old_windows, wl);
		xfree(wl);
@


1.11
log
@Add "grouped sessions" which have independent name, options, current window and
so on but where the linked windows are synchronized (ie creating, killing
windows and so on are mirrored between the sessions). A grouped session may be
created by passing -t to new-session.

Had this around for a while, tested by a couple of people.
@
text
@d1 1
a1 1
/* $OpenBSD: session.c,v 1.10 2009/10/10 09:46:11 nicm Exp $ */
a128 1
	s->activity = time(NULL);
d130 1
a130 1
	if (gettimeofday(&s->tv, NULL) != 0)
d132 1
@


1.10
log
@Support for individual session idle time locking. May be enabled by turning off
the lock-server option (it is on by default). When this is off, each session
locks when it has been idle for the lock-after-time setting. When on, the
entire server locks when ALL sessions have been idle for their individual
lock-after-time settings.

This replaces one global-only option (lock-after-time) with another
(lock-server), but the default behaviour is usually preferable so there don't
seem to be many alternatives.

Diff/idea largely from Thomas Adam, tweaked by me.
@
text
@d1 1
a1 1
/* $OpenBSD: session.c,v 1.9 2009/09/20 14:58:12 nicm Exp $ */
d33 1
d135 1
a135 1
	SLIST_INIT(&s->lastw);
d168 7
a174 3
	if (session_new(s, NULL, cmd, cwd, idx, cause) == NULL) {
		session_destroy(s);
		return (NULL);
a175 1
	session_select(s, RB_ROOT(&s->windows)->idx);
d199 1
d205 2
a206 2
	while (!SLIST_EMPTY(&s->lastw))
		winlink_stack_remove(&s->lastw, SLIST_FIRST(&s->lastw));
d276 1
d291 1
d418 1
a418 1
	wl = SLIST_FIRST(&s->lastw);
d429 166
@


1.9
log
@Regularise some fatal messages.
@
text
@d1 1
a1 1
/* $OpenBSD: session.c,v 1.8 2009/09/16 12:35:04 nicm Exp $ */
d26 1
d128 1
@


1.8
log
@Rather than constructing an entire termios struct from ttydefaults.h, just let
forkpty do it and then alter the bits that should be changed after fork. A
little neater and more portable.
@
text
@d1 1
a1 1
/* $OpenBSD: session.c,v 1.7 2009/09/07 21:01:50 nicm Exp $ */
d129 1
a129 1
		fatal("gettimeofday");
@


1.7
log
@Reference count clients and sessions rather than relying on a saved index for
cmd-choose-*.
@
text
@d1 1
a1 1
/* $OpenBSD: session.c,v 1.6 2009/09/01 13:09:49 nicm Exp $ */
d142 6
a147 1
	memcpy(&s->tio, tio, sizeof s->tio);
d190 3
d248 1
a248 1
	    name, cmd, shell, cwd, &env, &s->tio, s->sx, s->sy, hlimit, cause);
@


1.6
log
@When using tmux as a login shell, there is currently no way to specify a shell
to be used as a login shell inside tmux, so add a default-shell session option.
This sets the shell invoked as a login shell when the default-command option is
empty.

The default option value is whichever of $SHELL, getpwuid(getuid())'s pw_shell
or /bin/sh is valid first.

Based on a diff from martynas@@, changed by me to be a session option rather
than a window option.
@
text
@d1 1
a1 1
/* $OpenBSD: session.c,v 1.5 2009/08/13 20:11:58 nicm Exp $ */
d31 1
d125 1
d127 1
d130 1
d135 1
d137 1
d196 10
a205 1
	xfree(s);
@


1.5
log
@Add a base-index session option to specify the first index checked when looking
for an index for a new window.
@
text
@d1 1
a1 1
/* $OpenBSD: session.c,v 1.4 2009/08/13 19:04:00 nicm Exp $ */
d22 1
d211 1
d219 4
d225 1
a225 1
	    name, cmd, cwd, &env, &s->tio, s->sx, s->sy, hlimit, cause);
@


1.4
log
@When creating a new session from the command-line where there is an external
terminal, copy the termios(4) special characters and use them for new windows
created in the new session. Suggested by Theo.
@
text
@d1 1
a1 1
/* $OpenBSD: session.c,v 1.3 2009/08/08 21:52:43 nicm Exp $ */
d116 2
a117 1
    struct environ *env, struct termios *tio, u_int sx, u_int sy, char **cause)
d153 1
a153 1
	if (session_new(s, NULL, cmd, cwd, -1, cause) == NULL) {
d157 1
a157 1
	session_select(s, 0);
@


1.3
log
@Infrastructure and commands to manage the environment for processes started
within tmux.

There is a global environment, copied from the external environment when the
server is started and each sesssion has an (initially empty) session
environment which overrides it.

New commands set-environment and show-environment manipulate or display the
environments.

A new session option, update-environment, is a space-separated list of
variables which are updated from the external environment into the session
environment every time a new session is created - the default is DISPLAY.
@
text
@d1 1
a1 1
/* $OpenBSD: session.c,v 1.2 2009/07/07 19:49:19 nicm Exp $ */
d116 1
a116 1
    struct environ *env, u_int sx, u_int sy, char **cause)
d134 1
d204 1
a204 1
session_new(struct session *s,
d217 2
a218 1
	w = window_create(name, cmd, cwd, &env, s->sx, s->sy, hlimit, cause);
@


1.2
log
@Rename the global options variables to be shorter and to make session options
clear. No functional change, getting this out of the way to make later options
changes easier.
@
text
@d1 1
a1 1
/* $OpenBSD: session.c,v 1.1 2009/06/01 22:58:49 nicm Exp $ */
d115 2
a116 2
session_create(const char *name,
    const char *cmd, const char *cwd, u_int sx, u_int sy, char **cause)
d131 3
d177 1
d207 1
a207 1
	const char     **env;
d210 4
a213 1
	env = server_fill_environ(s);
d216 3
a218 2
	w = window_create(name, cmd, cwd, env, s->sx, s->sy, hlimit, cause);
	if (w == NULL)
d220 2
@


1.1
log
@Import tmux, a terminal multiplexor allowing (among other things) a single
terminal to be switched between several different windows and programs
displayed on one terminal be detached from one terminal and moved to another.

ok deraadt pirofti
@
text
@d1 1
a1 1
/* $OpenBSD$ */
d130 1
a130 1
	options_init(&s->options, &global_options);
@

