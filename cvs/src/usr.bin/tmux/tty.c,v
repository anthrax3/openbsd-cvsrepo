head	1.279;
access;
symbols
	OPENBSD_6_1:1.256.0.4
	OPENBSD_6_1_BASE:1.256
	OPENBSD_6_0:1.205.0.2
	OPENBSD_6_0_BASE:1.205
	OPENBSD_5_9:1.199.0.2
	OPENBSD_5_9_BASE:1.199
	OPENBSD_5_8:1.185.0.4
	OPENBSD_5_8_BASE:1.185
	OPENBSD_5_7:1.173.0.2
	OPENBSD_5_7_BASE:1.173
	OPENBSD_5_6:1.169.0.4
	OPENBSD_5_6_BASE:1.169
	OPENBSD_5_5:1.166.0.4
	OPENBSD_5_5_BASE:1.166
	OPENBSD_5_4:1.162.0.2
	OPENBSD_5_4_BASE:1.162
	OPENBSD_5_3:1.147.0.2
	OPENBSD_5_3_BASE:1.147
	OPENBSD_5_2:1.138.0.2
	OPENBSD_5_2_BASE:1.138
	OPENBSD_5_1_BASE:1.113
	OPENBSD_5_1:1.113.0.2
	OPENBSD_5_0:1.109.0.2
	OPENBSD_5_0_BASE:1.109
	OPENBSD_4_9:1.99.0.2
	OPENBSD_4_9_BASE:1.99
	OPENBSD_4_8:1.88.0.2
	OPENBSD_4_8_BASE:1.88
	OPENBSD_4_7:1.85.0.2
	OPENBSD_4_7_BASE:1.85
	OPENBSD_4_6:1.8.0.4
	OPENBSD_4_6_BASE:1.8;
locks; strict;
comment	@ * @;


1.279
date	2017.05.12.14.13.54;	author nicm;	state Exp;
branches;
next	1.278;
commitid	LZjqtmOddvxveMhu;

1.278
date	2017.05.12.13.00.56;	author nicm;	state Exp;
branches;
next	1.277;
commitid	1bIKLBYAOfKIM4e4;

1.277
date	2017.05.12.11.19.24;	author nicm;	state Exp;
branches;
next	1.276;
commitid	aCmRUe6tHT4RZlbT;

1.276
date	2017.05.12.11.13.43;	author nicm;	state Exp;
branches;
next	1.275;
commitid	XmMkAjUyXp7P2HYY;

1.275
date	2017.05.12.10.50.11;	author nicm;	state Exp;
branches;
next	1.274;
commitid	NrV8qEjGzQCLtssv;

1.274
date	2017.05.12.10.49.04;	author nicm;	state Exp;
branches;
next	1.273;
commitid	hPdLx2nUi9H1d9lB;

1.273
date	2017.05.11.11.38.49;	author nicm;	state Exp;
branches;
next	1.272;
commitid	e9Ot60pABIcQUacY;

1.272
date	2017.05.10.18.40.13;	author nicm;	state Exp;
branches;
next	1.271;
commitid	meeLt5pdZ3tU3UFY;

1.271
date	2017.05.10.16.47.03;	author nicm;	state Exp;
branches;
next	1.270;
commitid	B2fZqQhXU79gEkYm;

1.270
date	2017.05.09.13.04.36;	author nicm;	state Exp;
branches;
next	1.269;
commitid	igyxLFletneL7Fbv;

1.269
date	2017.04.28.17.58.44;	author nicm;	state Exp;
branches;
next	1.268;
commitid	sv1fKc3uN5OrbQdV;

1.268
date	2017.04.25.18.30.29;	author nicm;	state Exp;
branches;
next	1.267;
commitid	nqUaGBE0wtGMeCFj;

1.267
date	2017.04.23.18.13.24;	author nicm;	state Exp;
branches;
next	1.266;
commitid	KiDukwVLzMOD3Cq2;

1.266
date	2017.04.19.06.52.27;	author nicm;	state Exp;
branches;
next	1.265;
commitid	J75yaiuz8O54rLmn;

1.265
date	2017.04.18.21.41.42;	author nicm;	state Exp;
branches;
next	1.264;
commitid	olMj0aSNSMEU2X3g;

1.264
date	2017.04.18.18.21.37;	author nicm;	state Exp;
branches;
next	1.263;
commitid	puXYAvHBv1XeJmEe;

1.263
date	2017.04.18.15.44.17;	author nicm;	state Exp;
branches;
next	1.262;
commitid	bYu9iw9cp97E6crN;

1.262
date	2017.04.18.15.27.47;	author nicm;	state Exp;
branches;
next	1.261;
commitid	ijmgeDQuh3BwJbuu;

1.261
date	2017.04.17.08.10.44;	author nicm;	state Exp;
branches;
next	1.260;
commitid	jVzRXG7LwqX8vgv3;

1.260
date	2017.04.17.06.40.32;	author nicm;	state Exp;
branches;
next	1.259;
commitid	VGpPUc11r7Q41gvd;

1.259
date	2017.04.16.20.32.14;	author nicm;	state Exp;
branches;
next	1.258;
commitid	LgtUWoQdrbfV2VC9;

1.258
date	2017.04.05.10.49.46;	author nicm;	state Exp;
branches;
next	1.257;
commitid	1mjoRYvghWl25dW0;

1.257
date	2017.04.05.10.45.20;	author nicm;	state Exp;
branches;
next	1.256;
commitid	gfF9LuSZUEKocQDo;

1.256
date	2017.03.24.14.45.00;	author nicm;	state Exp;
branches;
next	1.255;
commitid	4nN5BrhnkOVFk0ML;

1.255
date	2017.03.22.07.16.54;	author nicm;	state Exp;
branches;
next	1.254;
commitid	YlKgZy2nlCejSvNQ;

1.254
date	2017.03.15.15.22.14;	author nicm;	state Exp;
branches;
next	1.253;
commitid	KnZ3dtCBlstOfAnt;

1.253
date	2017.03.15.09.21.21;	author nicm;	state Exp;
branches;
next	1.252;
commitid	4v3wBMnCcN2g63N7;

1.252
date	2017.03.08.14.34.35;	author nicm;	state Exp;
branches;
next	1.251;
commitid	ZQgmPtY8UOreICEz;

1.251
date	2017.03.06.09.02.59;	author nicm;	state Exp;
branches;
next	1.250;
commitid	8TVWfiZyUkjAe01j;

1.250
date	2017.02.21.16.25.04;	author nicm;	state Exp;
branches;
next	1.249;
commitid	1W2TXcey78gHm1es;

1.249
date	2017.02.16.12.56.01;	author nicm;	state Exp;
branches;
next	1.248;
commitid	DHL5GKmdVY8CDJYy;

1.248
date	2017.02.15.11.22.13;	author nicm;	state Exp;
branches;
next	1.247;
commitid	e2Xchw7PlSTzitak;

1.247
date	2017.02.10.15.39.43;	author nicm;	state Exp;
branches;
next	1.246;
commitid	ggobBHEz9jwMz5Id;

1.246
date	2017.02.10.15.39.14;	author nicm;	state Exp;
branches;
next	1.245;
commitid	2Nkd3LTXqQBgVe3X;

1.245
date	2017.02.10.15.38.23;	author nicm;	state Exp;
branches;
next	1.244;
commitid	6lezr903YEeB5Kj1;

1.244
date	2017.02.10.12.59.18;	author nicm;	state Exp;
branches;
next	1.243;
commitid	P7xSjiy29fJgUATs;

1.243
date	2017.02.08.23.53.03;	author nicm;	state Exp;
branches;
next	1.242;
commitid	vbFmEbkUQGcgwXYc;

1.242
date	2017.02.08.23.47.35;	author nicm;	state Exp;
branches;
next	1.241;
commitid	U3kIivCSLZ29e6GT;

1.241
date	2017.02.08.22.42.07;	author nicm;	state Exp;
branches;
next	1.240;
commitid	ifoyhYqBhTPq32Gl;

1.240
date	2017.02.08.17.31.09;	author nicm;	state Exp;
branches;
next	1.239;
commitid	AzNCw8YfPlNCzX1E;

1.239
date	2017.02.08.16.45.18;	author nicm;	state Exp;
branches;
next	1.238;
commitid	ZNCPaF6tGzHeJGxd;

1.238
date	2017.02.08.16.18.20;	author nicm;	state Exp;
branches;
next	1.237;
commitid	cv2ro9bRS6Zl3t9g;

1.237
date	2017.02.08.15.49.29;	author nicm;	state Exp;
branches;
next	1.236;
commitid	9p1dhEKzsTLyX59I;

1.236
date	2017.02.08.15.24.48;	author nicm;	state Exp;
branches;
next	1.235;
commitid	iq8BMeIpyggwuzci;

1.235
date	2017.02.08.13.53.32;	author nicm;	state Exp;
branches;
next	1.234;
commitid	o58B3QeQE1FqWAyy;

1.234
date	2017.02.08.08.54.45;	author nicm;	state Exp;
branches;
next	1.233;
commitid	FOaPLr2b71gwgPue;

1.233
date	2017.02.08.08.50.10;	author nicm;	state Exp;
branches;
next	1.232;
commitid	5cRmkTFFolQ68i4L;

1.232
date	2017.02.07.18.27.46;	author nicm;	state Exp;
branches;
next	1.231;
commitid	c4I0jYdlZbm6GtqS;

1.231
date	2017.02.07.17.13.28;	author nicm;	state Exp;
branches;
next	1.230;
commitid	HoUNJcjksmPqg1wU;

1.230
date	2017.02.07.14.33.37;	author nicm;	state Exp;
branches;
next	1.229;
commitid	s7EVCpMWlnwsozCX;

1.229
date	2017.02.06.22.05.11;	author nicm;	state Exp;
branches;
next	1.228;
commitid	EudrDiTB8CsH17qW;

1.228
date	2017.02.06.19.45.23;	author nicm;	state Exp;
branches;
next	1.227;
commitid	TdUc3pYVaobdWEim;

1.227
date	2017.02.06.19.26.49;	author nicm;	state Exp;
branches;
next	1.226;
commitid	Rhdtq12XKh2I54nR;

1.226
date	2017.02.06.13.23.00;	author nicm;	state Exp;
branches;
next	1.225;
commitid	qejB8XDaRPwhZhRq;

1.225
date	2017.02.01.09.55.07;	author nicm;	state Exp;
branches;
next	1.224;
commitid	FpFenXzt7GohJ3lb;

1.224
date	2017.01.12.00.30.41;	author nicm;	state Exp;
branches;
next	1.223;
commitid	HHVWcYRYlQRNTAnd;

1.223
date	2017.01.12.00.19.32;	author nicm;	state Exp;
branches;
next	1.222;
commitid	5Rj7IbEXrGVYho74;

1.222
date	2017.01.11.23.10.04;	author nicm;	state Exp;
branches;
next	1.221;
commitid	MBXib6HyIaEqNAWP;

1.221
date	2017.01.11.22.36.07;	author nicm;	state Exp;
branches;
next	1.220;
commitid	HtCLmxuVeKiLFIZu;

1.220
date	2017.01.11.16.09.57;	author nicm;	state Exp;
branches;
next	1.219;
commitid	6XANvQoNZoJEjE5C;

1.219
date	2017.01.07.15.28.13;	author nicm;	state Exp;
branches;
next	1.218;
commitid	llgkTzvAhxXuSWDB;

1.218
date	2016.12.07.09.16.55;	author nicm;	state Exp;
branches;
next	1.217;
commitid	ZsTf3VG2coyQ16hy;

1.217
date	2016.11.30.13.20.02;	author nicm;	state Exp;
branches;
next	1.216;
commitid	4Mk7knWIMcmTtpIV;

1.216
date	2016.11.28.17.50.00;	author nicm;	state Exp;
branches;
next	1.215;
commitid	CFitCdmRpkXqianC;

1.215
date	2016.11.16.13.31.22;	author nicm;	state Exp;
branches;
next	1.214;
commitid	W2g8zUQEjutlYyWc;

1.214
date	2016.11.15.15.17.28;	author nicm;	state Exp;
branches;
next	1.213;
commitid	thg4UrdurnKYfFrH;

1.213
date	2016.11.15.14.08.27;	author nicm;	state Exp;
branches;
next	1.212;
commitid	LcW9iQj0aLJyrfEk;

1.212
date	2016.11.15.14.02.32;	author nicm;	state Exp;
branches;
next	1.211;
commitid	DoED1csxpiOGsoJM;

1.211
date	2016.10.14.21.48.00;	author nicm;	state Exp;
branches;
next	1.210;
commitid	kvVCHUHpQxcpcteN;

1.210
date	2016.10.13.20.27.27;	author nicm;	state Exp;
branches;
next	1.209;
commitid	txCyQ5BkKJtZRzfT;

1.209
date	2016.10.12.13.24.07;	author nicm;	state Exp;
branches;
next	1.208;
commitid	qR81tw3cGEFCEM0c;

1.208
date	2016.10.11.13.21.59;	author nicm;	state Exp;
branches;
next	1.207;
commitid	80rgEIPcNpyBnf95;

1.207
date	2016.10.10.21.29.23;	author nicm;	state Exp;
branches;
next	1.206;
commitid	z4Hr4PZF7Ev93uEJ;

1.206
date	2016.10.03.19.19.18;	author nicm;	state Exp;
branches;
next	1.205;
commitid	UddQ7ATj8NYYBfTb;

1.205
date	2016.07.15.00.49.08;	author nicm;	state Exp;
branches;
next	1.204;
commitid	4uHSvNNDvwUmOB9Y;

1.204
date	2016.07.15.00.42.56;	author nicm;	state Exp;
branches;
next	1.203;
commitid	EramuEV0ciOaJqkF;

1.203
date	2016.05.30.09.50.21;	author nicm;	state Exp;
branches;
next	1.202;
commitid	6UcyBBKbI1JUqfYo;

1.202
date	2016.05.30.09.26.49;	author nicm;	state Exp;
branches;
next	1.201;
commitid	ScGDvkDRXOwLVagu;

1.201
date	2016.04.30.18.59.02;	author nicm;	state Exp;
branches;
next	1.200;
commitid	WGzrFN9OgQx3k86Y;

1.200
date	2016.03.03.12.58.15;	author nicm;	state Exp;
branches;
next	1.199;
commitid	YN6zuXnCKYVti2dd;

1.199
date	2016.01.29.11.13.56;	author nicm;	state Exp;
branches;
next	1.198;
commitid	Rew2ppunRTmAT23L;

1.198
date	2016.01.19.15.59.12;	author nicm;	state Exp;
branches;
next	1.197;
commitid	P3qmSOx6KrDBsb0c;

1.197
date	2015.12.28.14.02.52;	author nicm;	state Exp;
branches;
next	1.196;
commitid	DXGWmCt5QwGKppVd;

1.196
date	2015.12.11.16.37.21;	author nicm;	state Exp;
branches;
next	1.195;
commitid	pfV7j8HdB7hdHnZm;

1.195
date	2015.11.23.20.53.09;	author nicm;	state Exp;
branches;
next	1.194;
commitid	erDJx2JIDZWB55Vj;

1.194
date	2015.11.18.14.27.44;	author nicm;	state Exp;
branches;
next	1.193;
commitid	RjsAPRkWwvS79w40;

1.193
date	2015.11.13.08.09.28;	author nicm;	state Exp;
branches;
next	1.192;
commitid	3vFd8TIqn7NVGuk0;

1.192
date	2015.10.31.13.12.03;	author nicm;	state Exp;
branches;
next	1.191;
commitid	YMQrsd7hfJkvI0rw;

1.191
date	2015.10.27.15.58.43;	author nicm;	state Exp;
branches;
next	1.190;
commitid	89xhQafU35Q5MQVC;

1.190
date	2015.10.23.16.30.15;	author nicm;	state Exp;
branches;
next	1.189;
commitid	OfTVqENPXKuxOhhK;

1.189
date	2015.10.23.15.52.54;	author nicm;	state Exp;
branches;
next	1.188;
commitid	AIT5Hv9BEGfsZBQa;

1.188
date	2015.09.25.23.30.12;	author nicm;	state Exp;
branches;
next	1.187;
commitid	A8iusKZRUd8Ruv1p;

1.187
date	2015.09.02.17.43.25;	author nicm;	state Exp;
branches;
next	1.186;
commitid	xHcEu21xENWEDDuX;

1.186
date	2015.09.02.17.37.54;	author nicm;	state Exp;
branches;
next	1.185;
commitid	DPDGYd3xfOPOySvU;

1.185
date	2015.07.13.15.51.31;	author nicm;	state Exp;
branches;
next	1.184;
commitid	FFYcWp5eb58J4GT4;

1.184
date	2015.07.13.15.49.31;	author nicm;	state Exp;
branches;
next	1.183;
commitid	ECzzymgpZWtUKc3b;

1.183
date	2015.05.19.08.48.37;	author nicm;	state Exp;
branches;
next	1.182;
commitid	2JBfQoeSzyLcHlia;

1.182
date	2015.05.12.22.40.38;	author nicm;	state Exp;
branches;
next	1.181;
commitid	sxqWZ5H5R3E3KABV;

1.181
date	2015.05.06.07.52.06;	author nicm;	state Exp;
branches;
next	1.180;
commitid	QsYIHO7vmkeMFepO;

1.180
date	2015.04.29.15.59.08;	author nicm;	state Exp;
branches;
next	1.179;
commitid	8yIyhuBaxmohYzMx;

1.179
date	2015.04.25.15.57.48;	author nicm;	state Exp;
branches;
next	1.178;
commitid	MZqxxwKVnZwE7nEq;

1.178
date	2015.04.24.23.17.11;	author nicm;	state Exp;
branches;
next	1.177;
commitid	iy4fcaIoXzxOx84I;

1.177
date	2015.04.19.21.34.21;	author nicm;	state Exp;
branches;
next	1.176;
commitid	wug6ctIOfhVMeWQp;

1.176
date	2015.04.19.21.05.27;	author nicm;	state Exp;
branches;
next	1.175;
commitid	ksfuI8mTVk7XPyr3;

1.175
date	2015.04.15.22.34.46;	author nicm;	state Exp;
branches;
next	1.174;
commitid	PMqsL2hp9AeXoJBm;

1.174
date	2015.04.15.22.10.13;	author nicm;	state Exp;
branches;
next	1.173;
commitid	1OeHXH4eRo6WxjgX;

1.173
date	2015.02.05.11.46.57;	author nicm;	state Exp;
branches;
next	1.172;
commitid	ApJMzW5WdasXzunH;

1.172
date	2015.01.30.12.33.03;	author nicm;	state Exp;
branches;
next	1.171;
commitid	ip4SYd9vrHSJRNNL;

1.171
date	2015.01.20.08.18.04;	author nicm;	state Exp;
branches;
next	1.170;
commitid	rWJzz3mLtR2DyuLJ;

1.170
date	2014.08.09.07.33.37;	author nicm;	state Exp;
branches;
next	1.169;
commitid	EaH1ezsTMWHeIyGh;

1.169
date	2014.04.25.12.45.16;	author jsg;	state Exp;
branches;
next	1.168;

1.168
date	2014.04.17.14.45.49;	author nicm;	state Exp;
branches;
next	1.167;

1.167
date	2014.04.17.12.57.28;	author nicm;	state Exp;
branches;
next	1.166;

1.166
date	2014.02.23.00.53.06;	author nicm;	state Exp;
branches;
next	1.165;

1.165
date	2014.02.14.14.37.08;	author nicm;	state Exp;
branches;
next	1.164;

1.164
date	2014.01.28.23.07.09;	author nicm;	state Exp;
branches;
next	1.163;

1.163
date	2013.10.20.09.37.50;	author nicm;	state Exp;
branches;
next	1.162;

1.162
date	2013.06.23.13.10.48;	author nicm;	state Exp;
branches;
next	1.161;

1.161
date	2013.06.11.19.18.02;	author sthen;	state Exp;
branches;
next	1.160;

1.160
date	2013.06.02.07.52.15;	author nicm;	state Exp;
branches;
next	1.159;

1.159
date	2013.04.11.07.27.27;	author nicm;	state Exp;
branches;
next	1.158;

1.158
date	2013.03.27.11.17.12;	author nicm;	state Exp;
branches;
next	1.157;

1.157
date	2013.03.24.09.29.00;	author nicm;	state Exp;
branches;
next	1.156;

1.156
date	2013.03.24.09.18.16;	author nicm;	state Exp;
branches;
next	1.155;

1.155
date	2013.03.22.10.40.22;	author nicm;	state Exp;
branches;
next	1.154;

1.154
date	2013.03.22.10.34.46;	author nicm;	state Exp;
branches;
next	1.153;

1.153
date	2013.03.22.10.33.50;	author nicm;	state Exp;
branches;
next	1.152;

1.152
date	2013.03.22.10.31.22;	author nicm;	state Exp;
branches;
next	1.151;

1.151
date	2013.03.22.10.30.04;	author nicm;	state Exp;
branches;
next	1.150;

1.150
date	2013.03.22.10.29.31;	author nicm;	state Exp;
branches;
next	1.149;

1.149
date	2013.03.21.18.44.47;	author nicm;	state Exp;
branches;
next	1.148;

1.148
date	2013.03.21.16.50.22;	author nicm;	state Exp;
branches;
next	1.147;

1.147
date	2013.01.18.02.16.21;	author nicm;	state Exp;
branches;
next	1.146;

1.146
date	2013.01.15.23.18.55;	author nicm;	state Exp;
branches;
next	1.145;

1.145
date	2012.11.22.14.41.11;	author nicm;	state Exp;
branches;
next	1.144;

1.144
date	2012.11.22.14.26.04;	author nicm;	state Exp;
branches;
next	1.143;

1.143
date	2012.11.22.14.10.53;	author nicm;	state Exp;
branches;
next	1.142;

1.142
date	2012.09.29.06.57.56;	author nicm;	state Exp;
branches;
next	1.141;

1.141
date	2012.09.05.09.59.41;	author nicm;	state Exp;
branches;
next	1.140;

1.140
date	2012.09.03.15.47.40;	author nicm;	state Exp;
branches;
next	1.139;

1.139
date	2012.08.14.08.58.25;	author nicm;	state Exp;
branches;
next	1.138;

1.138
date	2012.07.10.11.53.01;	author nicm;	state Exp;
branches;
next	1.137;

1.137
date	2012.06.20.12.55.55;	author nicm;	state Exp;
branches;
next	1.136;

1.136
date	2012.05.22.14.32.28;	author nicm;	state Exp;
branches;
next	1.135;

1.135
date	2012.05.22.09.37.54;	author nicm;	state Exp;
branches;
next	1.134;

1.134
date	2012.05.22.09.36.12;	author nicm;	state Exp;
branches;
next	1.133;

1.133
date	2012.05.22.09.09.16;	author nicm;	state Exp;
branches;
next	1.132;

1.132
date	2012.05.05.18.45.55;	author nicm;	state Exp;
branches;
next	1.131;

1.131
date	2012.05.05.18.31.09;	author nicm;	state Exp;
branches;
next	1.130;

1.130
date	2012.05.05.18.17.59;	author nicm;	state Exp;
branches;
next	1.129;

1.129
date	2012.03.20.11.01.00;	author nicm;	state Exp;
branches;
next	1.128;

1.128
date	2012.03.17.22.56.04;	author nicm;	state Exp;
branches;
next	1.127;

1.127
date	2012.03.17.21.27.51;	author nicm;	state Exp;
branches;
next	1.126;

1.126
date	2012.03.17.19.29.46;	author nicm;	state Exp;
branches;
next	1.125;

1.125
date	2012.03.17.19.18.37;	author nicm;	state Exp;
branches;
next	1.124;

1.124
date	2012.03.17.18.51.50;	author nicm;	state Exp;
branches;
next	1.123;

1.123
date	2012.03.17.18.24.07;	author nicm;	state Exp;
branches;
next	1.122;

1.122
date	2012.03.17.17.36.03;	author nicm;	state Exp;
branches;
next	1.121;

1.121
date	2012.03.15.10.36.00;	author nicm;	state Exp;
branches;
next	1.120;

1.120
date	2012.03.15.09.22.31;	author nicm;	state Exp;
branches;
next	1.119;

1.119
date	2012.03.15.09.10.33;	author nicm;	state Exp;
branches;
next	1.118;

1.118
date	2012.03.12.12.43.18;	author nicm;	state Exp;
branches;
next	1.117;

1.117
date	2012.03.12.12.38.42;	author nicm;	state Exp;
branches;
next	1.116;

1.116
date	2012.03.09.21.42.13;	author nicm;	state Exp;
branches;
next	1.115;

1.115
date	2012.03.03.09.43.23;	author nicm;	state Exp;
branches;
next	1.114;

1.114
date	2012.02.15.17.25.02;	author nicm;	state Exp;
branches;
next	1.113;

1.113
date	2012.01.29.09.37.02;	author nicm;	state Exp;
branches;
next	1.112;

1.112
date	2012.01.21.08.23.12;	author nicm;	state Exp;
branches;
next	1.111;

1.111
date	2012.01.15.19.39.42;	author nicm;	state Exp;
branches;
next	1.110;

1.110
date	2011.08.24.09.58.44;	author nicm;	state Exp;
branches;
next	1.109;

1.109
date	2011.05.26.07.08.48;	author nicm;	state Exp;
branches;
next	1.108;

1.108
date	2011.05.20.19.17.39;	author nicm;	state Exp;
branches;
next	1.107;

1.107
date	2011.05.20.19.03.58;	author nicm;	state Exp;
branches;
next	1.106;

1.106
date	2011.05.18.20.24.29;	author nicm;	state Exp;
branches;
next	1.105;

1.105
date	2011.05.08.19.53.08;	author nicm;	state Exp;
branches;
next	1.104;

1.104
date	2011.04.09.07.48.08;	author nicm;	state Exp;
branches;
next	1.103;

1.103
date	2011.03.27.20.36.19;	author nicm;	state Exp;
branches;
next	1.102;

1.102
date	2011.03.26.19.07.33;	author nicm;	state Exp;
branches;
next	1.101;

1.101
date	2011.03.08.19.23.49;	author nicm;	state Exp;
branches;
next	1.100;

1.100
date	2011.03.07.23.46.27;	author nicm;	state Exp;
branches;
next	1.99;

1.99
date	2011.01.29.08.39.43;	author nicm;	state Exp;
branches;
next	1.98;

1.98
date	2011.01.15.00.46.19;	author nicm;	state Exp;
branches;
next	1.97;

1.97
date	2011.01.15.00.16.00;	author nicm;	state Exp;
branches;
next	1.96;

1.96
date	2011.01.08.01.52.37;	author nicm;	state Exp;
branches;
next	1.95;

1.95
date	2011.01.03.23.35.22;	author nicm;	state Exp;
branches;
next	1.94;

1.94
date	2010.12.29.21.49.06;	author nicm;	state Exp;
branches;
next	1.93;

1.93
date	2010.11.22.21.13.13;	author nicm;	state Exp;
branches;
next	1.92;

1.92
date	2010.10.16.08.31.55;	author nicm;	state Exp;
branches;
next	1.91;

1.91
date	2010.09.11.16.20.58;	author nicm;	state Exp;
branches;
next	1.90;

1.90
date	2010.09.11.16.19.22;	author nicm;	state Exp;
branches;
next	1.89;

1.89
date	2010.08.11.07.34.43;	author nicm;	state Exp;
branches;
next	1.88;

1.88
date	2010.06.05.16.47.11;	author nicm;	state Exp;
branches;
next	1.87;

1.87
date	2010.06.05.16.32.22;	author nicm;	state Exp;
branches;
next	1.86;

1.86
date	2010.05.31.19.51.29;	author nicm;	state Exp;
branches;
next	1.85;

1.85
date	2010.03.01.22.44.31;	author nicm;	state Exp;
branches;
next	1.84;

1.84
date	2010.02.24.19.08.39;	author nicm;	state Exp;
branches;
next	1.83;

1.83
date	2010.02.01.23.06.24;	author nicm;	state Exp;
branches;
next	1.82;

1.82
date	2010.01.01.14.29.18;	author nicm;	state Exp;
branches;
next	1.81;

1.81
date	2009.12.26.11.02.32;	author nicm;	state Exp;
branches;
next	1.80;

1.80
date	2009.12.26.10.39.02;	author nicm;	state Exp;
branches;
next	1.79;

1.79
date	2009.12.14.21.33.38;	author nicm;	state Exp;
branches;
next	1.78;

1.78
date	2009.12.04.11.01.29;	author nicm;	state Exp;
branches;
next	1.77;

1.77
date	2009.12.03.22.50.10;	author nicm;	state Exp;
branches;
next	1.76;

1.76
date	2009.12.02.22.13.15;	author nicm;	state Exp;
branches;
next	1.75;

1.75
date	2009.11.27.09.41.03;	author nicm;	state Exp;
branches;
next	1.74;

1.74
date	2009.11.26.22.47.14;	author nicm;	state Exp;
branches;
next	1.73;

1.73
date	2009.11.26.21.37.13;	author nicm;	state Exp;
branches;
next	1.72;

1.72
date	2009.11.26.14.46.08;	author nicm;	state Exp;
branches;
next	1.71;

1.71
date	2009.11.18.17.02.17;	author nicm;	state Exp;
branches;
next	1.70;

1.70
date	2009.11.12.08.05.23;	author nicm;	state Exp;
branches;
next	1.69;

1.69
date	2009.11.09.22.50.29;	author nicm;	state Exp;
branches;
next	1.68;

1.68
date	2009.11.05.22.35.28;	author nicm;	state Exp;
branches;
next	1.67;

1.67
date	2009.11.05.08.45.08;	author nicm;	state Exp;
branches;
next	1.66;

1.66
date	2009.11.04.21.47.42;	author nicm;	state Exp;
branches;
next	1.65;

1.65
date	2009.11.04.15.59.27;	author nicm;	state Exp;
branches;
next	1.64;

1.64
date	2009.11.04.13.34.26;	author nicm;	state Exp;
branches;
next	1.63;

1.63
date	2009.10.28.08.52.36;	author nicm;	state Exp;
branches;
next	1.62;

1.62
date	2009.10.28.08.33.20;	author nicm;	state Exp;
branches;
next	1.61;

1.61
date	2009.10.28.08.27.33;	author nicm;	state Exp;
branches;
next	1.60;

1.60
date	2009.10.26.21.42.04;	author deraadt;	state Exp;
branches;
next	1.59;

1.59
date	2009.10.25.21.11.21;	author nicm;	state Exp;
branches;
next	1.58;

1.58
date	2009.10.21.19.27.09;	author nicm;	state Exp;
branches;
next	1.57;

1.57
date	2009.10.21.16.52.30;	author nicm;	state Exp;
branches;
next	1.56;

1.56
date	2009.10.21.13.42.44;	author nicm;	state Exp;
branches;
next	1.55;

1.55
date	2009.10.21.09.36.53;	author nicm;	state Exp;
branches;
next	1.54;

1.54
date	2009.10.20.19.18.28;	author nicm;	state Exp;
branches;
next	1.53;

1.53
date	2009.10.20.17.33.33;	author nicm;	state Exp;
branches;
next	1.52;

1.52
date	2009.10.20.16.32.23;	author nicm;	state Exp;
branches;
next	1.51;

1.51
date	2009.10.17.08.35.38;	author nicm;	state Exp;
branches;
next	1.50;

1.50
date	2009.10.17.08.24.46;	author nicm;	state Exp;
branches;
next	1.49;

1.49
date	2009.10.16.19.09.40;	author nicm;	state Exp;
branches;
next	1.48;

1.48
date	2009.10.13.08.37.15;	author nicm;	state Exp;
branches;
next	1.47;

1.47
date	2009.10.13.00.44.16;	author nicm;	state Exp;
branches;
next	1.46;

1.46
date	2009.10.12.17.19.47;	author nicm;	state Exp;
branches;
next	1.45;

1.45
date	2009.10.12.16.41.02;	author nicm;	state Exp;
branches;
next	1.44;

1.44
date	2009.10.12.16.37.43;	author nicm;	state Exp;
branches;
next	1.43;

1.43
date	2009.10.12.14.54.19;	author nicm;	state Exp;
branches;
next	1.42;

1.42
date	2009.10.12.13.01.18;	author nicm;	state Exp;
branches;
next	1.41;

1.41
date	2009.10.12.09.29.58;	author nicm;	state Exp;
branches;
next	1.40;

1.40
date	2009.10.12.09.16.59;	author nicm;	state Exp;
branches;
next	1.39;

1.39
date	2009.10.12.09.09.35;	author nicm;	state Exp;
branches;
next	1.38;

1.38
date	2009.10.11.22.35.10;	author nicm;	state Exp;
branches;
next	1.37;

1.37
date	2009.10.10.10.36.46;	author nicm;	state Exp;
branches;
next	1.36;

1.36
date	2009.10.09.07.33.12;	author nicm;	state Exp;
branches;
next	1.35;

1.35
date	2009.10.09.07.23.28;	author nicm;	state Exp;
branches;
next	1.34;

1.34
date	2009.09.23.12.03.31;	author nicm;	state Exp;
branches;
next	1.33;

1.33
date	2009.09.23.07.25.31;	author nicm;	state Exp;
branches;
next	1.32;

1.32
date	2009.09.23.06.18.48;	author nicm;	state Exp;
branches;
next	1.31;

1.31
date	2009.09.23.06.12.58;	author nicm;	state Exp;
branches;
next	1.30;

1.30
date	2009.09.23.06.05.02;	author nicm;	state Exp;
branches;
next	1.29;

1.29
date	2009.09.22.19.11.52;	author nicm;	state Exp;
branches;
next	1.28;

1.28
date	2009.09.10.17.16.24;	author nicm;	state Exp;
branches;
next	1.27;

1.27
date	2009.08.31.20.46.19;	author nicm;	state Exp;
branches;
next	1.26;

1.26
date	2009.08.21.12.29.59;	author nicm;	state Exp;
branches;
next	1.25;

1.25
date	2009.08.14.08.53.52;	author nicm;	state Exp;
branches;
next	1.24;

1.24
date	2009.08.12.09.41.59;	author nicm;	state Exp;
branches;
next	1.23;

1.23
date	2009.08.11.22.34.17;	author nicm;	state Exp;
branches;
next	1.22;

1.22
date	2009.08.11.21.28.11;	author nicm;	state Exp;
branches;
next	1.21;

1.21
date	2009.08.11.20.29.05;	author nicm;	state Exp;
branches;
next	1.20;

1.20
date	2009.08.11.19.32.25;	author nicm;	state Exp;
branches;
next	1.19;

1.19
date	2009.08.08.13.29.27;	author nicm;	state Exp;
branches;
next	1.18;

1.18
date	2009.08.05.16.26.38;	author nicm;	state Exp;
branches;
next	1.17;

1.17
date	2009.08.03.14.10.54;	author nicm;	state Exp;
branches;
next	1.16;

1.16
date	2009.07.27.11.33.21;	author nicm;	state Exp;
branches;
next	1.15;

1.15
date	2009.07.22.20.56.58;	author nicm;	state Exp;
branches;
next	1.14;

1.14
date	2009.07.22.20.53.38;	author nicm;	state Exp;
branches;
next	1.13;

1.13
date	2009.07.22.18.02.23;	author nicm;	state Exp;
branches;
next	1.12;

1.12
date	2009.07.22.16.45.31;	author nicm;	state Exp;
branches;
next	1.11;

1.11
date	2009.07.22.15.55.32;	author nicm;	state Exp;
branches;
next	1.10;

1.10
date	2009.07.10.07.11.59;	author nicm;	state Exp;
branches;
next	1.9;

1.9
date	2009.07.07.17.24.32;	author nicm;	state Exp;
branches;
next	1.8;

1.8
date	2009.06.27.12.57.14;	author nicm;	state Exp;
branches;
next	1.7;

1.7
date	2009.06.25.06.15.04;	author nicm;	state Exp;
branches;
next	1.6;

1.6
date	2009.06.25.05.56.44;	author nicm;	state Exp;
branches;
next	1.5;

1.5
date	2009.06.24.16.01.02;	author nicm;	state Exp;
branches;
next	1.4;

1.4
date	2009.06.03.23.30.40;	author nicm;	state Exp;
branches;
next	1.3;

1.3
date	2009.06.03.23.26.56;	author nicm;	state Exp;
branches;
next	1.2;

1.2
date	2009.06.02.23.39.32;	author nicm;	state Exp;
branches;
next	1.1;

1.1
date	2009.06.01.22.58.49;	author nicm;	state Exp;
branches;
next	;


desc
@@


1.279
log
@Cannot rely on cursor position after DL and IL (some terminals move to
column 0, some do not).
@
text
@/* $OpenBSD: tty.c,v 1.278 2017/05/12 13:00:56 nicm Exp $ */

/*
 * Copyright (c) 2007 Nicholas Marriott <nicholas.marriott@@gmail.com>
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF MIND, USE, DATA OR PROFITS, WHETHER
 * IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING
 * OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */

#include <sys/types.h>
#include <sys/ioctl.h>

#include <netinet/in.h>

#include <curses.h>
#include <errno.h>
#include <fcntl.h>
#include <resolv.h>
#include <stdlib.h>
#include <string.h>
#include <termios.h>
#include <unistd.h>

#include "tmux.h"

static int	tty_log_fd = -1;

static int	tty_client_ready(struct client *, struct window_pane *);

static void	tty_set_italics(struct tty *);
static int	tty_try_colour(struct tty *, int, const char *);
static void	tty_force_cursor_colour(struct tty *, const char *);
static void	tty_cursor_pane(struct tty *, const struct tty_ctx *, u_int,
		    u_int);
static void	tty_cursor_pane_unless_wrap(struct tty *,
		    const struct tty_ctx *, u_int, u_int);
static void	tty_invalidate(struct tty *);
static void	tty_colours(struct tty *, const struct grid_cell *);
static void	tty_check_fg(struct tty *, const struct window_pane *,
		    struct grid_cell *);
static void	tty_check_bg(struct tty *, const struct window_pane *,
		    struct grid_cell *);
static void	tty_colours_fg(struct tty *, const struct grid_cell *);
static void	tty_colours_bg(struct tty *, const struct grid_cell *);

static void	tty_region_pane(struct tty *, const struct tty_ctx *, u_int,
		    u_int);
static void	tty_region(struct tty *, u_int, u_int);
static void	tty_margin_pane(struct tty *, const struct tty_ctx *);
static void	tty_margin(struct tty *, u_int, u_int);
static int	tty_large_region(struct tty *, const struct tty_ctx *);
static int	tty_fake_bce(const struct tty *, const struct window_pane *,
		    u_int);
static void	tty_redraw_region(struct tty *, const struct tty_ctx *);
static void	tty_emulate_repeat(struct tty *, enum tty_code_code,
		    enum tty_code_code, u_int);
static void	tty_repeat_space(struct tty *, u_int);
static void	tty_cell(struct tty *, const struct grid_cell *,
		    const struct window_pane *);
static void	tty_default_colours(struct grid_cell *,
		    const struct window_pane *);
static void	tty_default_attributes(struct tty *, const struct window_pane *,
		    u_int);

#define tty_use_acs(tty) \
	(tty_term_has((tty)->term, TTYC_ACSC) && !((tty)->flags & TTY_UTF8))
#define tty_use_margin(tty) \
	((tty)->term_type == TTY_VT420)

#define tty_pane_full_width(tty, ctx) \
	((ctx)->xoff == 0 && screen_size_x((ctx)->wp->screen) >= (tty)->sx)

#define TTY_BLOCK_INTERVAL (100000 /* 100 milliseconds */)
#define TTY_BLOCK_START(tty) (1 + ((tty)->sx * (tty)->sy) * 8)
#define TTY_BLOCK_STOP(tty) (1 + ((tty)->sx * (tty)->sy) / 8)

void
tty_create_log(void)
{
	char	name[64];

	xsnprintf(name, sizeof name, "tmux-out-%ld.log", (long)getpid());

	tty_log_fd = open(name, O_WRONLY|O_CREAT|O_TRUNC, 0644);
	if (tty_log_fd != -1 && fcntl(tty_log_fd, F_SETFD, FD_CLOEXEC) == -1)
		fatal("fcntl failed");
}

int
tty_init(struct tty *tty, struct client *c, int fd, char *term)
{
	if (!isatty(fd))
		return (-1);

	memset(tty, 0, sizeof *tty);

	if (term == NULL || *term == '\0')
		tty->term_name = xstrdup("unknown");
	else
		tty->term_name = xstrdup(term);

	tty->fd = fd;
	tty->client = c;

	tty->cstyle = 0;
	tty->ccolour = xstrdup("");

	tty->flags = 0;

	tty->term_flags = 0;
	tty->term_type = TTY_UNKNOWN;

	return (0);
}

int
tty_resize(struct tty *tty)
{
	struct client	*c = tty->client;
	struct winsize	 ws;
	u_int		 sx, sy;

	if (ioctl(tty->fd, TIOCGWINSZ, &ws) != -1) {
		sx = ws.ws_col;
		if (sx == 0)
			sx = 80;
		sy = ws.ws_row;
		if (sy == 0)
			sy = 24;
	} else {
		sx = 80;
		sy = 24;
	}
	log_debug("%s: %s now %ux%u", __func__, c->name, sx, sy);

	if (!tty_set_size(tty, sx, sy))
		return (0);
	tty_invalidate(tty);
	return (1);
}

int
tty_set_size(struct tty *tty, u_int sx, u_int sy)
{
	if (sx == tty->sx && sy == tty->sy)
		return (0);
	tty->sx = sx;
	tty->sy = sy;
	return (1);
}

static void
tty_read_callback(__unused int fd, __unused short events, void *data)
{
	struct tty	*tty = data;
	struct client	*c = tty->client;
	size_t		 size = EVBUFFER_LENGTH(tty->in);
	int		 nread;

	nread = evbuffer_read(tty->in, tty->fd, -1);
	if (nread == -1)
		return;
	log_debug("%s: read %d bytes (already %zu)", c->name, nread, size);

	while (tty_keys_next(tty))
		;
}

static void
tty_timer_callback(__unused int fd, __unused short events, void *data)
{
	struct tty	*tty = data;
	struct client	*c = tty->client;
	struct timeval	 tv = { .tv_usec = TTY_BLOCK_INTERVAL };

	log_debug("%s: %zu discarded", c->name, tty->discarded);

	c->flags |= CLIENT_REDRAW;
	c->discarded += tty->discarded;

	if (tty->discarded < TTY_BLOCK_STOP(tty)) {
		tty->flags &= ~TTY_BLOCK;
		tty_invalidate(tty);
		return;
	}
	tty->discarded = 0;
	evtimer_add(&tty->timer, &tv);
}

static int
tty_block_maybe(struct tty *tty)
{
	struct client	*c = tty->client;
	size_t		 size = EVBUFFER_LENGTH(tty->out);
	struct timeval	 tv = { .tv_usec = TTY_BLOCK_INTERVAL };

	if (size < TTY_BLOCK_START(tty))
		return (0);

	if (tty->flags & TTY_BLOCK)
		return (1);
	tty->flags |= TTY_BLOCK;

	log_debug("%s: can't keep up, %zu discarded", c->name, size);

	evbuffer_drain(tty->out, size);
	c->discarded += size;

	tty->discarded = 0;
	evtimer_add(&tty->timer, &tv);
	return (1);
}

static void
tty_write_callback(__unused int fd, __unused short events, void *data)
{
	struct tty	*tty = data;
	struct client	*c = tty->client;
	size_t		 size = EVBUFFER_LENGTH(tty->out);
	int		 nwrite;

	nwrite = evbuffer_write(tty->out, tty->fd);
	if (nwrite == -1)
		return;
	log_debug("%s: wrote %d bytes (of %zu)", c->name, nwrite, size);

	if (c->redraw > 0) {
		if ((size_t)nwrite >= c->redraw)
			c->redraw = 0;
		else
			c->redraw -= nwrite;
		log_debug("%s: waiting for redraw, %zu bytes left", c->name,
		    c->redraw);
	} else if (tty_block_maybe(tty))
		return;

	if (EVBUFFER_LENGTH(tty->out) != 0)
		event_add(&tty->event_out, NULL);
}

int
tty_open(struct tty *tty, char **cause)
{
	tty->term = tty_term_find(tty->term_name, tty->fd, cause);
	if (tty->term == NULL) {
		tty_close(tty);
		return (-1);
	}
	tty->flags |= TTY_OPENED;

	tty->flags &= ~(TTY_NOCURSOR|TTY_FREEZE|TTY_BLOCK|TTY_TIMER);

	event_set(&tty->event_in, tty->fd, EV_PERSIST|EV_READ,
	    tty_read_callback, tty);
	tty->in = evbuffer_new();

	event_set(&tty->event_out, tty->fd, EV_WRITE, tty_write_callback, tty);
	tty->out = evbuffer_new();

	evtimer_set(&tty->timer, tty_timer_callback, tty);

	tty_start_tty(tty);

	tty_keys_build(tty);

	return (0);
}

void
tty_start_tty(struct tty *tty)
{
	struct termios	tio;

	if (tty->fd != -1 && tcgetattr(tty->fd, &tty->tio) == 0) {
		setblocking(tty->fd, 0);
		event_add(&tty->event_in, NULL);

		memcpy(&tio, &tty->tio, sizeof tio);
		tio.c_iflag &= ~(IXON|IXOFF|ICRNL|INLCR|IGNCR|IMAXBEL|ISTRIP);
		tio.c_iflag |= IGNBRK;
		tio.c_oflag &= ~(OPOST|ONLCR|OCRNL|ONLRET);
		tio.c_lflag &= ~(IEXTEN|ICANON|ECHO|ECHOE|ECHONL|ECHOCTL|
		    ECHOPRT|ECHOKE|ISIG);
		tio.c_cc[VMIN] = 1;
		tio.c_cc[VTIME] = 0;
		if (tcsetattr(tty->fd, TCSANOW, &tio) == 0)
			tcflush(tty->fd, TCIOFLUSH);
	}

	tty_putcode(tty, TTYC_SMCUP);

	tty_putcode(tty, TTYC_SMKX);
	if (tty_use_acs(tty))
		tty_putcode(tty, TTYC_ENACS);
	tty_putcode(tty, TTYC_CLEAR);

	tty_putcode(tty, TTYC_CNORM);
	if (tty_term_has(tty->term, TTYC_KMOUS))
		tty_puts(tty, "\033[?1000l\033[?1002l\033[?1006l\033[?1005l");

	if (tty_term_flag(tty->term, TTYC_XT)) {
		if (options_get_number(global_options, "focus-events")) {
			tty->flags |= TTY_FOCUS;
			tty_puts(tty, "\033[?1004h");
		}
		tty_puts(tty, "\033[c");
	}

	tty->flags |= TTY_STARTED;
	tty_invalidate(tty);

	tty_force_cursor_colour(tty, "");

	tty->mouse_drag_flag = 0;
	tty->mouse_drag_update = NULL;
	tty->mouse_drag_release = NULL;
}

void
tty_stop_tty(struct tty *tty)
{
	struct winsize	ws;

	if (!(tty->flags & TTY_STARTED))
		return;
	tty->flags &= ~TTY_STARTED;

	event_del(&tty->timer);
	tty->flags &= ~TTY_BLOCK;

	event_del(&tty->event_in);
	event_del(&tty->event_out);

	/*
	 * Be flexible about error handling and try not kill the server just
	 * because the fd is invalid. Things like ssh -t can easily leave us
	 * with a dead tty.
	 */
	if (ioctl(tty->fd, TIOCGWINSZ, &ws) == -1)
		return;
	if (tcsetattr(tty->fd, TCSANOW, &tty->tio) == -1)
		return;

	tty_raw(tty, tty_term_string2(tty->term, TTYC_CSR, 0, ws.ws_row - 1));
	if (tty_use_acs(tty))
		tty_raw(tty, tty_term_string(tty->term, TTYC_RMACS));
	tty_raw(tty, tty_term_string(tty->term, TTYC_SGR0));
	tty_raw(tty, tty_term_string(tty->term, TTYC_RMKX));
	tty_raw(tty, tty_term_string(tty->term, TTYC_CLEAR));
	if (tty_term_has(tty->term, TTYC_SS) && tty->cstyle != 0) {
		if (tty_term_has(tty->term, TTYC_SE))
			tty_raw(tty, tty_term_string(tty->term, TTYC_SE));
		else
			tty_raw(tty, tty_term_string1(tty->term, TTYC_SS, 0));
	}
	if (tty->mode & MODE_BRACKETPASTE)
		tty_raw(tty, "\033[?2004l");
	tty_raw(tty, tty_term_string(tty->term, TTYC_CR));

	tty_raw(tty, tty_term_string(tty->term, TTYC_CNORM));
	if (tty_term_has(tty->term, TTYC_KMOUS))
		tty_raw(tty, "\033[?1000l\033[?1002l\033[?1006l\033[?1005l");

	if (tty_term_flag(tty->term, TTYC_XT)) {
		if (tty->flags & TTY_FOCUS) {
			tty->flags &= ~TTY_FOCUS;
			tty_raw(tty, "\033[?1004l");
		}
	}

	if (tty_use_margin(tty))
		tty_raw(tty, "\033[?69l"); /* DECLRMM */
	tty_raw(tty, tty_term_string(tty->term, TTYC_RMCUP));

	setblocking(tty->fd, 1);
}

void
tty_close(struct tty *tty)
{
	if (event_initialized(&tty->key_timer))
		evtimer_del(&tty->key_timer);
	tty_stop_tty(tty);

	if (tty->flags & TTY_OPENED) {
		evbuffer_free(tty->in);
		event_del(&tty->event_in);
		evbuffer_free(tty->out);
		event_del(&tty->event_out);

		tty_term_free(tty->term);
		tty_keys_free(tty);

		tty->flags &= ~TTY_OPENED;
	}

	if (tty->fd != -1) {
		close(tty->fd);
		tty->fd = -1;
	}
}

void
tty_free(struct tty *tty)
{
	tty_close(tty);

	free(tty->ccolour);
	free(tty->term_name);
}

void
tty_set_type(struct tty *tty, int type)
{
	tty->term_type = type;

	if (tty_use_margin(tty))
		tty_puts(tty, "\033[?69h"); /* DECLRMM */
}

void
tty_raw(struct tty *tty, const char *s)
{
	ssize_t	n, slen;
	u_int	i;

	slen = strlen(s);
	for (i = 0; i < 5; i++) {
		n = write(tty->fd, s, slen);
		if (n >= 0) {
			s += n;
			slen -= n;
			if (slen == 0)
				break;
		} else if (n == -1 && errno != EAGAIN)
			break;
		usleep(100);
	}
}

void
tty_putcode(struct tty *tty, enum tty_code_code code)
{
	tty_puts(tty, tty_term_string(tty->term, code));
}

void
tty_putcode1(struct tty *tty, enum tty_code_code code, int a)
{
	if (a < 0)
		return;
	tty_puts(tty, tty_term_string1(tty->term, code, a));
}

void
tty_putcode2(struct tty *tty, enum tty_code_code code, int a, int b)
{
	if (a < 0 || b < 0)
		return;
	tty_puts(tty, tty_term_string2(tty->term, code, a, b));
}

void
tty_putcode_ptr1(struct tty *tty, enum tty_code_code code, const void *a)
{
	if (a != NULL)
		tty_puts(tty, tty_term_ptr1(tty->term, code, a));
}

void
tty_putcode_ptr2(struct tty *tty, enum tty_code_code code, const void *a,
    const void *b)
{
	if (a != NULL && b != NULL)
		tty_puts(tty, tty_term_ptr2(tty->term, code, a, b));
}

static void
tty_add(struct tty *tty, const char *buf, size_t len)
{
	struct client	*c = tty->client;

	if (tty->flags & TTY_BLOCK) {
		tty->discarded += len;
		return;
	}

	evbuffer_add(tty->out, buf, len);
	log_debug("%s: %.*s", c->name, (int)len, buf);
	c->written += len;

	if (tty_log_fd != -1)
		write(tty_log_fd, buf, len);
	if (tty->flags & TTY_STARTED)
		event_add(&tty->event_out, NULL);
}

void
tty_puts(struct tty *tty, const char *s)
{
	if (*s != '\0')
		tty_add(tty, s, strlen(s));
}

void
tty_putc(struct tty *tty, u_char ch)
{
	const char	*acs;

	if (tty->cell.attr & GRID_ATTR_CHARSET) {
		acs = tty_acs_get(tty, ch);
		if (acs != NULL)
			tty_add(tty, acs, strlen(acs));
		else
			tty_add(tty, &ch, 1);
	} else
		tty_add(tty, &ch, 1);

	if (ch >= 0x20 && ch != 0x7f) {
		if (tty->cx >= tty->sx) {
			tty->cx = 1;
			if (tty->cy != tty->rlower)
				tty->cy++;

			/*
			 * On !xenl terminals, force the cursor position to
			 * where we think it should be after a line wrap - this
			 * means it works on sensible terminals as well.
			 */
			if (tty->term->flags & TERM_EARLYWRAP)
				tty_putcode2(tty, TTYC_CUP, tty->cy, tty->cx);
		} else
			tty->cx++;
	}
}

void
tty_putn(struct tty *tty, const void *buf, size_t len, u_int width)
{
	tty_add(tty, buf, len);
	if (tty->cx + width > tty->sx) {
		tty->cx = (tty->cx + width) - tty->sx;
		if (tty->cx <= tty->sx)
			tty->cy++;
		else
			tty->cx = tty->cy = UINT_MAX;
	} else
		tty->cx += width;
}

static void
tty_set_italics(struct tty *tty)
{
	const char	*s;

	if (tty_term_has(tty->term, TTYC_SITM)) {
		s = options_get_string(global_options, "default-terminal");
		if (strcmp(s, "screen") != 0 && strncmp(s, "screen-", 7) != 0) {
			tty_putcode(tty, TTYC_SITM);
			return;
		}
	}
	tty_putcode(tty, TTYC_SMSO);
}

void
tty_set_title(struct tty *tty, const char *title)
{
	if (!tty_term_has(tty->term, TTYC_TSL) ||
	    !tty_term_has(tty->term, TTYC_FSL))
		return;

	tty_putcode(tty, TTYC_TSL);
	tty_puts(tty, title);
	tty_putcode(tty, TTYC_FSL);
}

static void
tty_force_cursor_colour(struct tty *tty, const char *ccolour)
{
	if (*ccolour == '\0')
		tty_putcode(tty, TTYC_CR);
	else
		tty_putcode_ptr1(tty, TTYC_CS, ccolour);
	free(tty->ccolour);
	tty->ccolour = xstrdup(ccolour);
}

void
tty_update_mode(struct tty *tty, int mode, struct screen *s)
{
	int	changed;

	if (s != NULL && strcmp(s->ccolour, tty->ccolour) != 0)
		tty_force_cursor_colour(tty, s->ccolour);

	if (tty->flags & TTY_NOCURSOR)
		mode &= ~MODE_CURSOR;

	changed = mode ^ tty->mode;
	if (changed & MODE_BLINKING) {
		if (tty_term_has(tty->term, TTYC_CVVIS))
			tty_putcode(tty, TTYC_CVVIS);
		else
			tty_putcode(tty, TTYC_CNORM);
		changed |= MODE_CURSOR;
	}
	if (changed & MODE_CURSOR) {
		if (mode & MODE_CURSOR)
			tty_putcode(tty, TTYC_CNORM);
		else
			tty_putcode(tty, TTYC_CIVIS);
	}
	if (s != NULL && tty->cstyle != s->cstyle) {
		if (tty_term_has(tty->term, TTYC_SS)) {
			if (s->cstyle == 0 &&
			    tty_term_has(tty->term, TTYC_SE))
				tty_putcode(tty, TTYC_SE);
			else
				tty_putcode1(tty, TTYC_SS, s->cstyle);
		}
		tty->cstyle = s->cstyle;
	}
	if (changed & ALL_MOUSE_MODES) {
		if (mode & ALL_MOUSE_MODES) {
			/*
			 * Enable the SGR (1006) extension unconditionally, as
			 * it is safe from misinterpretation.
			 */
			tty_puts(tty, "\033[?1006h");
			if (mode & MODE_MOUSE_ALL)
				tty_puts(tty, "\033[?1003h");
			else if (mode & MODE_MOUSE_BUTTON)
				tty_puts(tty, "\033[?1002h");
			else if (mode & MODE_MOUSE_STANDARD)
				tty_puts(tty, "\033[?1000h");
		} else {
			if (tty->mode & MODE_MOUSE_ALL)
				tty_puts(tty, "\033[?1003l");
			else if (tty->mode & MODE_MOUSE_BUTTON)
				tty_puts(tty, "\033[?1002l");
			else if (tty->mode & MODE_MOUSE_STANDARD)
				tty_puts(tty, "\033[?1000l");
			tty_puts(tty, "\033[?1006l");
		}
	}
	if (changed & MODE_BRACKETPASTE) {
		if (mode & MODE_BRACKETPASTE)
			tty_puts(tty, "\033[?2004h");
		else
			tty_puts(tty, "\033[?2004l");
	}
	tty->mode = mode;
}

static void
tty_emulate_repeat(struct tty *tty, enum tty_code_code code,
    enum tty_code_code code1, u_int n)
{
	if (tty_term_has(tty->term, code))
		tty_putcode1(tty, code, n);
	else {
		while (n-- > 0)
			tty_putcode(tty, code1);
	}
}

static void
tty_repeat_space(struct tty *tty, u_int n)
{
	static char s[500];

	if (*s != ' ')
		memset(s, ' ', sizeof s);

	while (n > sizeof s) {
		tty_putn(tty, s, sizeof s, sizeof s);
		n -= sizeof s;
	}
	if (n != 0)
		tty_putn(tty, s, n, n);
}

/*
 * Is the region large enough to be worth redrawing once later rather than
 * probably several times now? Currently yes if it is more than 50% of the
 * pane.
 */
static int
tty_large_region(__unused struct tty *tty, const struct tty_ctx *ctx)
{
	struct window_pane	*wp = ctx->wp;

	return (ctx->orlower - ctx->orupper >= screen_size_y(wp->screen) / 2);
}

/*
 * Return if BCE is needed but the terminal doesn't have it - it'll need to be
 * emulated.
 */
static int
tty_fake_bce(const struct tty *tty, const struct window_pane *wp, u_int bg)
{
	struct grid_cell	gc;

	if (tty_term_flag(tty->term, TTYC_BCE))
		return (0);

	memcpy(&gc, &grid_default_cell, sizeof gc);
	if (wp != NULL)
		tty_default_colours(&gc, wp);

	if (bg != 8 || gc.bg != 8)
		return (1);
	return (0);
}

/*
 * Redraw scroll region using data from screen (already updated). Used when
 * CSR not supported, or window is a pane that doesn't take up the full
 * width of the terminal.
 */
static void
tty_redraw_region(struct tty *tty, const struct tty_ctx *ctx)
{
	struct window_pane	*wp = ctx->wp;
	struct screen		*s = wp->screen;
	u_int			 i;

	/*
	 * If region is large, schedule a window redraw. In most cases this is
	 * likely to be followed by some more scrolling.
	 */
	if (tty_large_region(tty, ctx)) {
		wp->flags |= PANE_REDRAW;
		return;
	}

	if (ctx->ocy < ctx->orupper || ctx->ocy > ctx->orlower) {
		for (i = ctx->ocy; i < screen_size_y(s); i++)
			tty_draw_pane(tty, wp, i, ctx->xoff, ctx->yoff);
	} else {
		for (i = ctx->orupper; i <= ctx->orlower; i++)
			tty_draw_pane(tty, wp, i, ctx->xoff, ctx->yoff);
	}
}

static void
tty_clear_line(struct tty *tty, const struct window_pane *wp, u_int py,
    u_int px, u_int nx, u_int bg)
{
	log_debug("%s: %u at %u,%u", __func__, nx, px, py);

	/* Nothing to clear. */
	if (nx == 0)
		return;

	/* If genuine BCE is available, can try escape sequences. */
	if (!tty_fake_bce(tty, wp, bg)) {
		/* Off the end of the line, use EL if available. */
		if (px + nx >= tty->sx && tty_term_has(tty->term, TTYC_EL)) {
			tty_cursor(tty, px, py);
			tty_putcode(tty, TTYC_EL);
			return;
		}

		/* At the start of the line. Use EL1. */
		if (px == 0 && tty_term_has(tty->term, TTYC_EL1)) {
			tty_cursor(tty, px + nx - 1, py);
			tty_putcode(tty, TTYC_EL1);
			return;
		}

		/* Section of line. Use ECH if possible. */
		if (tty_term_has(tty->term, TTYC_ECH)) {
			tty_cursor(tty, px, py);
			tty_putcode1(tty, TTYC_ECH, nx);
			return;
		}
	}

	/* Couldn't use an escape sequence, use spaces. */
	tty_cursor(tty, px, py);
	tty_repeat_space(tty, nx);
}

static void
tty_clear_area(struct tty *tty, const struct window_pane *wp, u_int py,
    u_int ny, u_int px, u_int nx, u_int bg)
{
	u_int	yy;
	char	tmp[64];

	log_debug("%s: %u,%u at %u,%u", __func__, nx, ny, px, py);

	/* Nothing to clear. */
	if (nx == 0 || ny == 0)
		return;

	/* If genuine BCE is available, can try escape sequences. */
	if (!tty_fake_bce(tty, wp, bg)) {
		/* Use ED if clearing off the bottom of the terminal. */
		if (px == 0 &&
		    px + nx >= tty->sx &&
		    py + ny >= tty->sy &&
		    tty_term_has(tty->term, TTYC_ED)) {
			tty_cursor(tty, 0, py);
			tty_putcode(tty, TTYC_ED);
			return;
		}

		/*
		 * On VT420 compatible terminals we can use DECFRA if the
		 * background colour isn't default (because it doesn't work
		 * after SGR 0).
		 */
		if (tty->term_type == TTY_VT420 && bg != 8) {
			xsnprintf(tmp, sizeof tmp, "\033[32;%u;%u;%u;%u$x",
			    py + 1, px + 1, py + ny, px + nx);
			tty_puts(tty, tmp);
			return;
		}

		/*
		 * If margins are supported, can just scroll the area off to
		 * clear it.
		 */
		if (nx > 2 &&
		    ny > 2 &&
		    tty_use_margin(tty) &&
		    tty_term_has(tty->term, TTYC_INDN)) {
			tty_region(tty, py, py + ny - 1);
			tty_margin(tty, px, px + nx - 1);
			tty_putcode1(tty, TTYC_INDN, ny);
			return;
		}
	}

	/* Couldn't use an escape sequence, loop over the lines. */
	for (yy = py; yy < py + ny; yy++)
		tty_clear_line(tty, wp, yy, px, nx, bg);
}

void
tty_draw_pane(struct tty *tty, const struct window_pane *wp, u_int py, u_int ox,
    u_int oy)
{
	tty_draw_line(tty, wp, wp->screen, py, ox, oy);
}

void
tty_draw_line(struct tty *tty, const struct window_pane *wp,
    struct screen *s, u_int py, u_int ox, u_int oy)
{
	struct grid_cell	 gc, last;
	u_int			 i, j, sx, nx, width;
	int			 flags, cleared = 0;
	char			 buf[512];
	size_t			 len;

	flags = (tty->flags & TTY_NOCURSOR);
	tty->flags |= TTY_NOCURSOR;
	tty_update_mode(tty, tty->mode, s);

	tty_region_off(tty);
	tty_margin_off(tty);

	/*
	 * Clamp the width to cellsize - note this is not cellused, because
	 * there may be empty background cells after it (from BCE).
	 */
	sx = screen_size_x(s);
	if (sx > s->grid->linedata[s->grid->hsize + py].cellsize)
		sx = s->grid->linedata[s->grid->hsize + py].cellsize;
	if (sx > tty->sx)
		sx = tty->sx;

	if (wp == NULL ||
	    py == 0 ||
	    (~s->grid->linedata[s->grid->hsize + py - 1].flags & GRID_LINE_WRAPPED) ||
	    ox != 0 ||
	    tty->cx < tty->sx ||
	    screen_size_x(s) < tty->sx) {
		if (screen_size_x(s) < tty->sx &&
		    ox == 0 &&
		    sx != screen_size_x(s) &&
		    tty_term_has(tty->term, TTYC_EL1) &&
		    !tty_fake_bce(tty, wp, 8)) {
			tty_default_attributes(tty, wp, 8);
			tty_cursor(tty, screen_size_x(s) - 1, oy + py);
			tty_putcode(tty, TTYC_EL1);
			cleared = 1;
		}
		if (sx != 0)
			tty_cursor(tty, ox, oy + py);
	} else
		log_debug("%s: wrapped line %u", __func__, oy + py);

	memcpy(&last, &grid_default_cell, sizeof last);
	len = 0;
	width = 0;

	for (i = 0; i < sx; i++) {
		grid_view_get_cell(s->grid, i, py, &gc);
		if (len != 0 &&
		    (((~tty->flags & TTY_UTF8) &&
		    (gc.data.size != 1 ||
		    *gc.data.data >= 0x7f ||
		    gc.data.width != 1)) ||
		    (gc.attr & GRID_ATTR_CHARSET) ||
		    gc.flags != last.flags ||
		    gc.attr != last.attr ||
		    gc.fg != last.fg ||
		    gc.bg != last.bg ||
		    (sizeof buf) - len < gc.data.size)) {
			tty_attributes(tty, &last, wp);
			tty_putn(tty, buf, len, width);

			len = 0;
			width = 0;
		}

		if (gc.flags & GRID_FLAG_SELECTED)
			screen_select_cell(s, &last, &gc);
		else
			memcpy(&last, &gc, sizeof last);
		if (((~tty->flags & TTY_UTF8) &&
		    (gc.data.size != 1 ||
		    *gc.data.data >= 0x7f ||
		    gc.data.width != 1)) ||
		    (gc.attr & GRID_ATTR_CHARSET)) {
			tty_attributes(tty, &last, wp);
			if (~tty->flags & TTY_UTF8) {
				for (j = 0; j < gc.data.width; j++)
					tty_putc(tty, '_');
			} else {
				for (j = 0; j < gc.data.size; j++)
					tty_putc(tty, gc.data.data[j]);
			}
		} else {
			memcpy(buf + len, gc.data.data, gc.data.size);
			len += gc.data.size;
			width += gc.data.width;
		}
	}
	if (len != 0) {
		tty_attributes(tty, &last, wp);
		tty_putn(tty, buf, len, width);
	}

	nx = screen_size_x(s) - sx;
	if (!cleared && sx < tty->sx && nx != 0) {
		tty_default_attributes(tty, wp, 8);
		tty_clear_line(tty, wp, oy + py, ox + sx, nx, 8);
	}

	tty->flags = (tty->flags & ~TTY_NOCURSOR) | flags;
	tty_update_mode(tty, tty->mode, s);
}

static int
tty_client_ready(struct client *c, struct window_pane *wp)
{
	if (c->session == NULL || c->tty.term == NULL)
		return (0);
	if (c->flags & (CLIENT_REDRAW|CLIENT_SUSPENDED))
		return (0);
	if (c->tty.flags & TTY_FREEZE)
		return (0);
	if (c->session->curw->window != wp->window)
		return (0);
	return (1);
}

void
tty_write(void (*cmdfn)(struct tty *, const struct tty_ctx *),
    struct tty_ctx *ctx)
{
	struct window_pane	*wp = ctx->wp;
	struct client		*c;

	/* wp can be NULL if updating the screen but not the terminal. */
	if (wp == NULL)
		return;

	if ((wp->flags & (PANE_REDRAW|PANE_DROP)) || !window_pane_visible(wp))
		return;

	TAILQ_FOREACH(c, &clients, entry) {
		if (!tty_client_ready(c, wp))
			continue;

		ctx->xoff = wp->xoff;
		ctx->yoff = wp->yoff;
		if (status_at_line(c) == 0)
			ctx->yoff++;

		cmdfn(&c->tty, ctx);
	}
}

void
tty_cmd_insertcharacter(struct tty *tty, const struct tty_ctx *ctx)
{
	struct window_pane	*wp = ctx->wp;

	if (!tty_pane_full_width(tty, ctx) ||
	    tty_fake_bce(tty, wp, ctx->bg) ||
	    (!tty_term_has(tty->term, TTYC_ICH) &&
	    !tty_term_has(tty->term, TTYC_ICH1))) {
		tty_draw_pane(tty, wp, ctx->ocy, ctx->xoff, ctx->yoff);
		return;
	}

	tty_default_attributes(tty, wp, ctx->bg);

	tty_cursor_pane(tty, ctx, ctx->ocx, ctx->ocy);

	tty_emulate_repeat(tty, TTYC_ICH, TTYC_ICH1, ctx->num);
}

void
tty_cmd_deletecharacter(struct tty *tty, const struct tty_ctx *ctx)
{
	struct window_pane	*wp = ctx->wp;

	if (!tty_pane_full_width(tty, ctx) ||
	    tty_fake_bce(tty, wp, ctx->bg) ||
	    (!tty_term_has(tty->term, TTYC_DCH) &&
	    !tty_term_has(tty->term, TTYC_DCH1))) {
		tty_draw_pane(tty, wp, ctx->ocy, ctx->xoff, ctx->yoff);
		return;
	}

	tty_default_attributes(tty, wp, ctx->bg);

	tty_cursor_pane(tty, ctx, ctx->ocx, ctx->ocy);

	tty_emulate_repeat(tty, TTYC_DCH, TTYC_DCH1, ctx->num);
}

void
tty_cmd_clearcharacter(struct tty *tty, const struct tty_ctx *ctx)
{
	tty_default_attributes(tty, ctx->wp, ctx->bg);

	tty_cursor_pane(tty, ctx, ctx->ocx, ctx->ocy);

	if (tty_term_has(tty->term, TTYC_ECH) &&
	    !tty_fake_bce(tty, ctx->wp, 8))
		tty_putcode1(tty, TTYC_ECH, ctx->num);
	else
		tty_repeat_space(tty, ctx->num);
}

void
tty_cmd_insertline(struct tty *tty, const struct tty_ctx *ctx)
{
	if (!tty_pane_full_width(tty, ctx) ||
	    tty_fake_bce(tty, ctx->wp, ctx->bg) ||
	    !tty_term_has(tty->term, TTYC_CSR) ||
	    !tty_term_has(tty->term, TTYC_IL1)) {
		tty_redraw_region(tty, ctx);
		return;
	}

	tty_default_attributes(tty, ctx->wp, ctx->bg);

	tty_region_pane(tty, ctx, ctx->orupper, ctx->orlower);
	tty_margin_off(tty);
	tty_cursor_pane(tty, ctx, ctx->ocx, ctx->ocy);

	tty_emulate_repeat(tty, TTYC_IL, TTYC_IL1, ctx->num);
	tty->cx = tty->cy = UINT_MAX;
}

void
tty_cmd_deleteline(struct tty *tty, const struct tty_ctx *ctx)
{
	if (!tty_pane_full_width(tty, ctx) ||
	    tty_fake_bce(tty, ctx->wp, ctx->bg) ||
	    !tty_term_has(tty->term, TTYC_CSR) ||
	    !tty_term_has(tty->term, TTYC_DL1)) {
		tty_redraw_region(tty, ctx);
		return;
	}

	tty_default_attributes(tty, ctx->wp, ctx->bg);

	tty_region_pane(tty, ctx, ctx->orupper, ctx->orlower);
	tty_margin_off(tty);
	tty_cursor_pane(tty, ctx, ctx->ocx, ctx->ocy);

	tty_emulate_repeat(tty, TTYC_DL, TTYC_DL1, ctx->num);
	tty->cx = tty->cy = UINT_MAX;
}

void
tty_cmd_clearline(struct tty *tty, const struct tty_ctx *ctx)
{
	struct window_pane	*wp = ctx->wp;
	u_int			 nx, py = ctx->yoff + ctx->ocy;

	tty_default_attributes(tty, wp, ctx->bg);

	nx = screen_size_x(wp->screen);
	tty_clear_line(tty, wp, py, ctx->xoff, nx, ctx->bg);
}

void
tty_cmd_clearendofline(struct tty *tty, const struct tty_ctx *ctx)
{
	struct window_pane	*wp = ctx->wp;
	u_int			 nx, py = ctx->yoff + ctx->ocy;

	tty_default_attributes(tty, wp, ctx->bg);

	nx = screen_size_x(wp->screen) - ctx->ocx;
	tty_clear_line(tty, wp, py, ctx->xoff + ctx->ocx, nx, ctx->bg);
}

void
tty_cmd_clearstartofline(struct tty *tty, const struct tty_ctx *ctx)
{
	struct window_pane	*wp = ctx->wp;
	u_int			 nx, py = ctx->yoff + ctx->ocy;

	tty_default_attributes(tty, wp, ctx->bg);

	nx = screen_size_x(wp->screen) - ctx->ocx;
	tty_clear_line(tty, wp, py, ctx->xoff, ctx->ocx + 1, ctx->bg);
}

void
tty_cmd_reverseindex(struct tty *tty, const struct tty_ctx *ctx)
{
	struct window_pane	*wp = ctx->wp;

	if (ctx->ocy != ctx->orupper)
		return;

	if (!tty_pane_full_width(tty, ctx) ||
	    tty_fake_bce(tty, wp, 8) ||
	    !tty_term_has(tty->term, TTYC_CSR) ||
	    !tty_term_has(tty->term, TTYC_RI)) {
		tty_redraw_region(tty, ctx);
		return;
	}

	tty_default_attributes(tty, wp, ctx->bg);

	tty_region_pane(tty, ctx, ctx->orupper, ctx->orlower);
	tty_margin_off(tty);
	tty_cursor_pane(tty, ctx, ctx->ocx, ctx->orupper);

	tty_putcode(tty, TTYC_RI);
}

void
tty_cmd_linefeed(struct tty *tty, const struct tty_ctx *ctx)
{
	struct window_pane	*wp = ctx->wp;

	if (ctx->ocy != ctx->orlower)
		return;

	if ((!tty_pane_full_width(tty, ctx) && !tty_use_margin(tty)) ||
	    tty_fake_bce(tty, wp, 8) ||
	    !tty_term_has(tty->term, TTYC_CSR)) {
		tty_redraw_region(tty, ctx);
		return;
	}

	tty_default_attributes(tty, wp, ctx->bg);

	tty_region_pane(tty, ctx, ctx->orupper, ctx->orlower);
	tty_margin_pane(tty, ctx);

	/*
	 * If we want to wrap a pane, the cursor needs to be exactly on the
	 * right of the region. But if the pane isn't on the right, it may be
	 * off the edge - if so, move the cursor back to the right.
	 */
	if (ctx->xoff + ctx->ocx > tty->rright)
		tty_cursor(tty, tty->rright, ctx->yoff + ctx->ocy);
	else
		tty_cursor_pane(tty, ctx, ctx->ocx, ctx->ocy);

	tty_putc(tty, '\n');
}

void
tty_cmd_scrollup(struct tty *tty, const struct tty_ctx *ctx)
{
	struct window_pane	*wp = ctx->wp;
	u_int			 i, lines;

	if ((!tty_pane_full_width(tty, ctx) && !tty_use_margin(tty)) ||
	    tty_fake_bce(tty, wp, 8) ||
	    !tty_term_has(tty->term, TTYC_CSR)) {
		tty_redraw_region(tty, ctx);
		return;
	}

	tty_default_attributes(tty, wp, ctx->bg);

	tty_region_pane(tty, ctx, ctx->orupper, ctx->orlower);
	tty_margin_pane(tty, ctx);

	/*
	 * Konsole has a bug where it will ignore SU if the parameter is more
	 * than the height of the scroll region. Clamping the parameter doesn't
	 * hurt in any case.
	 */
	lines = tty->rlower - tty->rupper;
	if (lines > ctx->num)
		lines = ctx->num;

	if (lines == 1 || !tty_term_has(tty->term, TTYC_INDN)) {
		tty_cursor(tty, tty->rright, tty->rlower);
		for (i = 0; i < lines; i++)
			tty_putc(tty, '\n');
	} else
		tty_putcode1(tty, TTYC_INDN, lines);
}

void
tty_cmd_clearendofscreen(struct tty *tty, const struct tty_ctx *ctx)
{
	struct window_pane	*wp = ctx->wp;
	u_int			 px, py, nx, ny;

	tty_default_attributes(tty, wp, ctx->bg);

	tty_region_pane(tty, ctx, 0, screen_size_y(wp->screen) - 1);
	tty_margin_off(tty);

	px = ctx->xoff;
	nx = screen_size_x(wp->screen);
	py = ctx->yoff + ctx->ocy + 1;
	ny = screen_size_y(wp->screen) - ctx->ocy - 1;

	tty_clear_area(tty, wp, py, ny, px, nx, ctx->bg);

	px = ctx->xoff + ctx->ocx;
	nx = screen_size_x(wp->screen) - ctx->ocx;
	py = ctx->yoff + ctx->ocy;

	tty_clear_line(tty, wp, py, px, nx, ctx->bg);
}

void
tty_cmd_clearstartofscreen(struct tty *tty, const struct tty_ctx *ctx)
{
	struct window_pane	*wp = ctx->wp;
	u_int			 px, py, nx, ny;

	tty_default_attributes(tty, wp, ctx->bg);

	tty_region_pane(tty, ctx, 0, screen_size_y(wp->screen) - 1);
	tty_margin_off(tty);

	px = ctx->xoff;
	nx = screen_size_x(wp->screen);
	py = ctx->yoff;
	ny = ctx->ocy - 1;

	tty_clear_area(tty, wp, py, ny, px, nx, ctx->bg);

	px = ctx->xoff;
	nx = ctx->ocx + 1;
	py = ctx->yoff + ctx->ocy;

	tty_clear_line(tty, wp, py, px, nx, ctx->bg);
}

void
tty_cmd_clearscreen(struct tty *tty, const struct tty_ctx *ctx)
{
	struct window_pane	*wp = ctx->wp;
	u_int			 px, py, nx, ny;

	tty_default_attributes(tty, wp, ctx->bg);

	tty_region_pane(tty, ctx, 0, screen_size_y(wp->screen) - 1);
	tty_margin_off(tty);

	px = ctx->xoff;
	nx = screen_size_x(wp->screen);
	py = ctx->yoff;
	ny = screen_size_y(wp->screen);

	tty_clear_area(tty, wp, py, ny, px, nx, ctx->bg);
}

void
tty_cmd_alignmenttest(struct tty *tty, const struct tty_ctx *ctx)
{
	struct window_pane	*wp = ctx->wp;
	struct screen		*s = wp->screen;
	u_int			 i, j;

	tty_attributes(tty, &grid_default_cell, wp);

	tty_region_pane(tty, ctx, 0, screen_size_y(s) - 1);
	tty_margin_off(tty);

	for (j = 0; j < screen_size_y(s); j++) {
		tty_cursor_pane(tty, ctx, 0, j);
		for (i = 0; i < screen_size_x(s); i++)
			tty_putc(tty, 'E');
	}
}

void
tty_cmd_cell(struct tty *tty, const struct tty_ctx *ctx)
{
	if (ctx->xoff + ctx->ocx > tty->sx - 1 && ctx->ocy == ctx->orlower) {
		if (tty_pane_full_width(tty, ctx))
			tty_region_pane(tty, ctx, ctx->orupper, ctx->orlower);
		else
			tty_margin_off(tty);
	}

	tty_cursor_pane_unless_wrap(tty, ctx, ctx->ocx, ctx->ocy);

	tty_cell(tty, ctx->cell, ctx->wp);
}

void
tty_cmd_cells(struct tty *tty, const struct tty_ctx *ctx)
{
	tty_cursor_pane_unless_wrap(tty, ctx, ctx->ocx, ctx->ocy);

	tty_attributes(tty, ctx->cell, ctx->wp);
	tty_putn(tty, ctx->ptr, ctx->num, ctx->num);
}

void
tty_cmd_setselection(struct tty *tty, const struct tty_ctx *ctx)
{
	char	*buf;
	size_t	 off;

	if (!tty_term_has(tty->term, TTYC_MS))
		return;

	off = 4 * ((ctx->num + 2) / 3) + 1; /* storage for base64 */
	buf = xmalloc(off);

	b64_ntop(ctx->ptr, ctx->num, buf, off);
	tty_putcode_ptr2(tty, TTYC_MS, "", buf);

	free(buf);
}

void
tty_cmd_rawstring(struct tty *tty, const struct tty_ctx *ctx)
{
	tty_add(tty, ctx->ptr, ctx->num);
	tty_invalidate(tty);
}

static void
tty_cell(struct tty *tty, const struct grid_cell *gc,
    const struct window_pane *wp)
{
	u_int	i;

	/* Skip last character if terminal is stupid. */
	if ((tty->term->flags & TERM_EARLYWRAP) &&
	    tty->cy == tty->sy - 1 &&
	    tty->cx == tty->sx - 1)
		return;

	/* If this is a padding character, do nothing. */
	if (gc->flags & GRID_FLAG_PADDING)
		return;

	/* Set the attributes. */
	tty_attributes(tty, gc, wp);

	/* Get the cell and if ASCII write with putc to do ACS translation. */
	if (gc->data.size == 1) {
		if (*gc->data.data < 0x20 || *gc->data.data == 0x7f)
			return;
		tty_putc(tty, *gc->data.data);
		return;
	}

	/* If not UTF-8, write _. */
	if (!(tty->flags & TTY_UTF8)) {
		for (i = 0; i < gc->data.width; i++)
			tty_putc(tty, '_');
		return;
	}

	/* Write the data. */
	tty_putn(tty, gc->data.data, gc->data.size, gc->data.width);
}

void
tty_reset(struct tty *tty)
{
	struct grid_cell	*gc = &tty->cell;

	if (!grid_cells_equal(gc, &grid_default_cell)) {
		if ((gc->attr & GRID_ATTR_CHARSET) && tty_use_acs(tty))
			tty_putcode(tty, TTYC_RMACS);
		tty_putcode(tty, TTYC_SGR0);
		memcpy(gc, &grid_default_cell, sizeof *gc);
	}

	memcpy(&tty->last_cell, &grid_default_cell, sizeof tty->last_cell);
	tty->last_wp = -1;
}

static void
tty_invalidate(struct tty *tty)
{
	memcpy(&tty->cell, &grid_default_cell, sizeof tty->cell);

	memcpy(&tty->last_cell, &grid_default_cell, sizeof tty->last_cell);
	tty->last_wp = -1;

	tty->cx = tty->cy = UINT_MAX;

	tty->rupper = tty->rleft = UINT_MAX;
	tty->rlower = tty->rright = UINT_MAX;

	if (tty->flags & TTY_STARTED) {
		tty_putcode(tty, TTYC_SGR0);

		tty->mode = ALL_MODES;
		tty_update_mode(tty, MODE_CURSOR, NULL);

		tty_cursor(tty, 0, 0);
		tty_region_off(tty);
		tty_margin_off(tty);
	} else
		tty->mode = MODE_CURSOR;
}

/* Turn off margin. */
void
tty_region_off(struct tty *tty)
{
	tty_region(tty, 0, tty->sy - 1);
}

/* Set region inside pane. */
static void
tty_region_pane(struct tty *tty, const struct tty_ctx *ctx, u_int rupper,
    u_int rlower)
{
	tty_region(tty, ctx->yoff + rupper, ctx->yoff + rlower);
}

/* Set region at absolute position. */
static void
tty_region(struct tty *tty, u_int rupper, u_int rlower)
{
	if (tty->rlower == rlower && tty->rupper == rupper)
		return;
	if (!tty_term_has(tty->term, TTYC_CSR))
		return;

	tty->rupper = rupper;
	tty->rlower = rlower;

	/*
	 * Some terminals (such as PuTTY) do not correctly reset the cursor to
	 * 0,0 if it is beyond the last column (they do not reset their wrap
	 * flag so further output causes a line feed). As a workaround, do an
	 * explicit move to 0 first.
	 */
	if (tty->cx >= tty->sx)
		tty_cursor(tty, 0, tty->cy);

	tty_putcode2(tty, TTYC_CSR, tty->rupper, tty->rlower);
	tty->cx = tty->cy = UINT_MAX;
}

/* Turn off margin. */
void
tty_margin_off(struct tty *tty)
{
	tty_margin(tty, 0, tty->sx - 1);
}

/* Set margin inside pane. */
static void
tty_margin_pane(struct tty *tty, const struct tty_ctx *ctx)
{
	tty_margin(tty, ctx->xoff, ctx->xoff + ctx->wp->sx - 1);
}

/* Set margin at absolute position. */
static void
tty_margin(struct tty *tty, u_int rleft, u_int rright)
{
	char s[64];

	if (!tty_use_margin(tty))
		return;
	if (tty->rleft == rleft && tty->rright == rright)
		return;

	tty_putcode2(tty, TTYC_CSR, tty->rupper, tty->rlower);

	tty->rleft = rleft;
	tty->rright = rright;

	if (rleft == 0 && rright == tty->sx - 1)
		snprintf(s, sizeof s, "\033[s");
	else
		snprintf(s, sizeof s, "\033[%u;%us", rleft + 1, rright + 1);
	tty_puts(tty, s);
	tty->cx = tty->cy = UINT_MAX;
}

/*
 * Move the cursor, unless it would wrap itself when the next character is
 * printed.
 */
static void
tty_cursor_pane_unless_wrap(struct tty *tty, const struct tty_ctx *ctx,
    u_int cx, u_int cy)
{
	if (!ctx->wrapped ||
	    !tty_pane_full_width(tty, ctx) ||
	    (tty->term->flags & TERM_EARLYWRAP) ||
	    ctx->xoff + cx != 0 ||
	    ctx->yoff + cy != tty->cy + 1 ||
	    tty->cx < tty->sx ||
	    tty->cy == tty->rlower)
		tty_cursor_pane(tty, ctx, cx, cy);
	else
		log_debug("%s: will wrap at %u,%u", __func__, tty->cx, tty->cy);
}

/* Move cursor inside pane. */
static void
tty_cursor_pane(struct tty *tty, const struct tty_ctx *ctx, u_int cx, u_int cy)
{
	tty_cursor(tty, ctx->xoff + cx, ctx->yoff + cy);
}

/* Move cursor to absolute position. */
void
tty_cursor(struct tty *tty, u_int cx, u_int cy)
{
	struct tty_term	*term = tty->term;
	u_int		 thisx, thisy;
	int		 change;

	if (cx > tty->sx - 1)
		cx = tty->sx - 1;

	thisx = tty->cx;
	thisy = tty->cy;

	/* No change. */
	if (cx == thisx && cy == thisy)
		return;

	/* Very end of the line, just use absolute movement. */
	if (thisx > tty->sx - 1)
		goto absolute;

	/* Move to home position (0, 0). */
	if (cx == 0 && cy == 0 && tty_term_has(term, TTYC_HOME)) {
		tty_putcode(tty, TTYC_HOME);
		goto out;
	}

	/* Zero on the next line. */
	if (cx == 0 && cy == thisy + 1 && thisy != tty->rlower) {
		tty_putc(tty, '\r');
		tty_putc(tty, '\n');
		goto out;
	}

	/* Moving column or row. */
	if (cy == thisy) {
		/*
		 * Moving column only, row staying the same.
		 */

		/* To left edge. */
		if (cx == 0) {
			tty_putc(tty, '\r');
			goto out;
		}

		/* One to the left. */
		if (cx == thisx - 1 && tty_term_has(term, TTYC_CUB1)) {
			tty_putcode(tty, TTYC_CUB1);
			goto out;
		}

		/* One to the right. */
		if (cx == thisx + 1 && tty_term_has(term, TTYC_CUF1)) {
			tty_putcode(tty, TTYC_CUF1);
			goto out;
		}

		/* Calculate difference. */
		change = thisx - cx;	/* +ve left, -ve right */

		/*
		 * Use HPA if change is larger than absolute, otherwise move
		 * the cursor with CUB/CUF.
		 */
		if ((u_int) abs(change) > cx && tty_term_has(term, TTYC_HPA)) {
			tty_putcode1(tty, TTYC_HPA, cx);
			goto out;
		} else if (change > 0 && tty_term_has(term, TTYC_CUB)) {
			if (change == 2 && tty_term_has(term, TTYC_CUB1)) {
				tty_putcode(tty, TTYC_CUB1);
				tty_putcode(tty, TTYC_CUB1);
				goto out;
			}
			tty_putcode1(tty, TTYC_CUB, change);
			goto out;
		} else if (change < 0 && tty_term_has(term, TTYC_CUF)) {
			tty_putcode1(tty, TTYC_CUF, -change);
			goto out;
		}
	} else if (cx == thisx) {
		/*
		 * Moving row only, column staying the same.
		 */

		/* One above. */
		if (thisy != tty->rupper &&
		    cy == thisy - 1 && tty_term_has(term, TTYC_CUU1)) {
			tty_putcode(tty, TTYC_CUU1);
			goto out;
		}

		/* One below. */
		if (thisy != tty->rlower &&
		    cy == thisy + 1 && tty_term_has(term, TTYC_CUD1)) {
			tty_putcode(tty, TTYC_CUD1);
			goto out;
		}

		/* Calculate difference. */
		change = thisy - cy;	/* +ve up, -ve down */

		/*
		 * Try to use VPA if change is larger than absolute or if this
		 * change would cross the scroll region, otherwise use CUU/CUD.
		 */
		if ((u_int) abs(change) > cy ||
		    (change < 0 && cy - change > tty->rlower) ||
		    (change > 0 && cy - change < tty->rupper)) {
			    if (tty_term_has(term, TTYC_VPA)) {
				    tty_putcode1(tty, TTYC_VPA, cy);
				    goto out;
			    }
		} else if (change > 0 && tty_term_has(term, TTYC_CUU)) {
			tty_putcode1(tty, TTYC_CUU, change);
			goto out;
		} else if (change < 0 && tty_term_has(term, TTYC_CUD)) {
			tty_putcode1(tty, TTYC_CUD, -change);
			goto out;
		}
	}

absolute:
	/* Absolute movement. */
	tty_putcode2(tty, TTYC_CUP, cy, cx);

out:
	tty->cx = cx;
	tty->cy = cy;
}

void
tty_attributes(struct tty *tty, const struct grid_cell *gc,
    const struct window_pane *wp)
{
	struct grid_cell	*tc = &tty->cell, gc2;
	int			 changed;

	/* Ignore cell if it is the same as the last one. */
	if (wp != NULL &&
	    (int)wp->id == tty->last_wp &&
	    ~(wp->window->flags & WINDOW_STYLECHANGED) &&
	    gc->attr == tty->last_cell.attr &&
	    gc->fg == tty->last_cell.fg &&
	    gc->bg == tty->last_cell.bg)
		return;
	tty->last_wp = (wp != NULL ? (int)wp->id : -1);
	memcpy(&tty->last_cell, gc, sizeof tty->last_cell);

	/* Copy cell and update default colours. */
	memcpy(&gc2, gc, sizeof gc2);
	if (wp != NULL)
		tty_default_colours(&gc2, wp);

	/*
	 * If no setab, try to use the reverse attribute as a best-effort for a
	 * non-default background. This is a bit of a hack but it doesn't do
	 * any serious harm and makes a couple of applications happier.
	 */
	if (!tty_term_has(tty->term, TTYC_SETAB)) {
		if (gc2.attr & GRID_ATTR_REVERSE) {
			if (gc2.fg != 7 && gc2.fg != 8)
				gc2.attr &= ~GRID_ATTR_REVERSE;
		} else {
			if (gc2.bg != 0 && gc2.bg != 8)
				gc2.attr |= GRID_ATTR_REVERSE;
		}
	}

	/* Fix up the colours if necessary. */
	tty_check_fg(tty, wp, &gc2);
	tty_check_bg(tty, wp, &gc2);

	/* If any bits are being cleared, reset everything. */
	if (tc->attr & ~gc2.attr)
		tty_reset(tty);

	/*
	 * Set the colours. This may call tty_reset() (so it comes next) and
	 * may add to (NOT remove) the desired attributes by changing new_attr.
	 */
	tty_colours(tty, &gc2);

	/* Filter out attribute bits already set. */
	changed = gc2.attr & ~tc->attr;
	tc->attr = gc2.attr;

	/* Set the attributes. */
	if (changed & GRID_ATTR_BRIGHT)
		tty_putcode(tty, TTYC_BOLD);
	if (changed & GRID_ATTR_DIM)
		tty_putcode(tty, TTYC_DIM);
	if (changed & GRID_ATTR_ITALICS)
		tty_set_italics(tty);
	if (changed & GRID_ATTR_UNDERSCORE)
		tty_putcode(tty, TTYC_SMUL);
	if (changed & GRID_ATTR_BLINK)
		tty_putcode(tty, TTYC_BLINK);
	if (changed & GRID_ATTR_REVERSE) {
		if (tty_term_has(tty->term, TTYC_REV))
			tty_putcode(tty, TTYC_REV);
		else if (tty_term_has(tty->term, TTYC_SMSO))
			tty_putcode(tty, TTYC_SMSO);
	}
	if (changed & GRID_ATTR_HIDDEN)
		tty_putcode(tty, TTYC_INVIS);
	if (changed & GRID_ATTR_STRIKETHROUGH)
		tty_putcode(tty, TTYC_SMXX);
	if ((changed & GRID_ATTR_CHARSET) && tty_use_acs(tty))
		tty_putcode(tty, TTYC_SMACS);
}

static void
tty_colours(struct tty *tty, const struct grid_cell *gc)
{
	struct grid_cell	*tc = &tty->cell;
	int			 have_ax;

	/* No changes? Nothing is necessary. */
	if (gc->fg == tc->fg && gc->bg == tc->bg)
		return;

	/*
	 * Is either the default colour? This is handled specially because the
	 * best solution might be to reset both colours to default, in which
	 * case if only one is default need to fall onward to set the other
	 * colour.
	 */
	if (gc->fg == 8 || gc->bg == 8) {
		/*
		 * If don't have AX but do have op, send sgr0 (op can't
		 * actually be used because it is sometimes the same as sgr0
		 * and sometimes isn't). This resets both colours to default.
		 *
		 * Otherwise, try to set the default colour only as needed.
		 */
		have_ax = tty_term_flag(tty->term, TTYC_AX);
		if (!have_ax && tty_term_has(tty->term, TTYC_OP))
			tty_reset(tty);
		else {
			if (gc->fg == 8 && tc->fg != 8) {
				if (have_ax)
					tty_puts(tty, "\033[39m");
				else if (tc->fg != 7)
					tty_putcode1(tty, TTYC_SETAF, 7);
				tc->fg = 8;
			}
			if (gc->bg == 8 && tc->bg != 8) {
				if (have_ax)
					tty_puts(tty, "\033[49m");
				else if (tc->bg != 0)
					tty_putcode1(tty, TTYC_SETAB, 0);
				tc->bg = 8;
			}
		}
	}

	/* Set the foreground colour. */
	if (gc->fg != 8 && gc->fg != tc->fg)
		tty_colours_fg(tty, gc);

	/*
	 * Set the background colour. This must come after the foreground as
	 * tty_colour_fg() can call tty_reset().
	 */
	if (gc->bg != 8 && gc->bg != tc->bg)
		tty_colours_bg(tty, gc);
}

static void
tty_check_fg(struct tty *tty, const struct window_pane *wp,
    struct grid_cell *gc)
{
	u_char	r, g, b;
	u_int	colours;
	int	c;

	/* Perform substitution if this pane has a palette */
	if ((~gc->flags & GRID_FLAG_NOPALETTE) &&
	    (c = window_pane_get_palette(wp, gc->fg)) != -1)
		gc->fg = c;

	/* Is this a 24-bit colour? */
	if (gc->fg & COLOUR_FLAG_RGB) {
		/* Not a 24-bit terminal? Translate to 256-colour palette. */
		if (!tty_term_flag(tty->term, TTYC_TC)) {
			colour_split_rgb(gc->fg, &r, &g, &b);
			gc->fg = colour_find_rgb(r, g, b);
		} else
			return;
	}

	/* How many colours does this terminal have? */
	if ((tty->term->flags|tty->term_flags) & TERM_256COLOURS)
		colours = 256;
	else
		colours = tty_term_number(tty->term, TTYC_COLORS);

	/* Is this a 256-colour colour? */
	if (gc->fg & COLOUR_FLAG_256) {
		/* And not a 256 colour mode? */
		if (colours != 256) {
			gc->fg = colour_256to16(gc->fg);
			if (gc->fg & 8) {
				gc->fg &= 7;
				if (colours >= 16)
					gc->fg += 90;
				else
					gc->attr |= GRID_ATTR_BRIGHT;
			} else
				gc->attr &= ~GRID_ATTR_BRIGHT;
		}
		return;
	}

	/* Is this an aixterm colour? */
	if (gc->fg >= 90 && gc->fg <= 97 && colours < 16) {
		gc->fg -= 90;
		gc->attr |= GRID_ATTR_BRIGHT;
	}
}

static void
tty_check_bg(struct tty *tty, const struct window_pane *wp,
    struct grid_cell *gc)
{
	u_char	r, g, b;
	u_int	colours;
	int	c;

	/* Perform substitution if this pane has a palette */
	if ((~gc->flags & GRID_FLAG_NOPALETTE) &&
	    (c = window_pane_get_palette(wp, gc->bg)) != -1)
		gc->bg = c;

	/* Is this a 24-bit colour? */
	if (gc->bg & COLOUR_FLAG_RGB) {
		/* Not a 24-bit terminal? Translate to 256-colour palette. */
		if (!tty_term_flag(tty->term, TTYC_TC)) {
			colour_split_rgb(gc->bg, &r, &g, &b);
			gc->bg = colour_find_rgb(r, g, b);
		} else
			return;
	}

	/* How many colours does this terminal have? */
	if ((tty->term->flags|tty->term_flags) & TERM_256COLOURS)
		colours = 256;
	else
		colours = tty_term_number(tty->term, TTYC_COLORS);

	/* Is this a 256-colour colour? */
	if (gc->bg & COLOUR_FLAG_256) {
		/*
		 * And not a 256 colour mode? Translate to 16-colour
		 * palette. Bold background doesn't exist portably, so just
		 * discard the bold bit if set.
		 */
		if (colours != 256) {
			gc->bg = colour_256to16(gc->bg);
			if (gc->bg & 8) {
				gc->bg &= 7;
				if (colours >= 16)
					gc->fg += 90;
			}
		}
		return;
	}

	/* Is this an aixterm colour? */
	if (gc->bg >= 90 && gc->bg <= 97 && colours < 16)
		gc->bg -= 90;
}

static void
tty_colours_fg(struct tty *tty, const struct grid_cell *gc)
{
	struct grid_cell	*tc = &tty->cell;
	char			 s[32];

	/* Is this a 24-bit or 256-colour colour? */
	if (gc->fg & COLOUR_FLAG_RGB ||
	    gc->fg & COLOUR_FLAG_256) {
		if (tty_try_colour(tty, gc->fg, "38") == 0)
			goto save_fg;
		/* Should not get here, already converted in tty_check_fg. */
		return;
	}

	/* Is this an aixterm bright colour? */
	if (gc->fg >= 90 && gc->fg <= 97) {
		xsnprintf(s, sizeof s, "\033[%dm", gc->fg);
		tty_puts(tty, s);
		goto save_fg;
	}

	/* Otherwise set the foreground colour. */
	tty_putcode1(tty, TTYC_SETAF, gc->fg);

save_fg:
	/* Save the new values in the terminal current cell. */
	tc->fg = gc->fg;
}

static void
tty_colours_bg(struct tty *tty, const struct grid_cell *gc)
{
	struct grid_cell	*tc = &tty->cell;
	char			 s[32];

	/* Is this a 24-bit or 256-colour colour? */
	if (gc->bg & COLOUR_FLAG_RGB ||
	    gc->bg & COLOUR_FLAG_256) {
		if (tty_try_colour(tty, gc->bg, "48") == 0)
			goto save_bg;
		/* Should not get here, already converted in tty_check_bg. */
		return;
	}

	/* Is this an aixterm bright colour? */
	if (gc->bg >= 90 && gc->bg <= 97) {
		xsnprintf(s, sizeof s, "\033[%dm", gc->bg + 10);
		tty_puts(tty, s);
		goto save_bg;
	}

	/* Otherwise set the background colour. */
	tty_putcode1(tty, TTYC_SETAB, gc->bg);

save_bg:
	/* Save the new values in the terminal current cell. */
	tc->bg = gc->bg;
}

static int
tty_try_colour(struct tty *tty, int colour, const char *type)
{
	u_char	r, g, b;
	char	s[32];

	if (colour & COLOUR_FLAG_256) {
		/*
		 * If the user has specified -2 to the client, setaf and setab
		 * may not work (or they may not want to use them), so send the
		 * usual sequence.
		 */
		if (tty->term_flags & TERM_256COLOURS)
			goto fallback_256;

		/*
		 * If the terminfo entry has 256 colours and setaf and setab
		 * exist, assume that they work correctly.
		 */
		if (tty->term->flags & TERM_256COLOURS) {
			if (*type == '3') {
				if (!tty_term_has(tty->term, TTYC_SETAF))
					goto fallback_256;
				tty_putcode1(tty, TTYC_SETAF, colour & 0xff);
			} else {
				if (!tty_term_has(tty->term, TTYC_SETAB))
					goto fallback_256;
				tty_putcode1(tty, TTYC_SETAB, colour & 0xff);
			}
			return (0);
		}
		goto fallback_256;
	}

	if (colour & COLOUR_FLAG_RGB) {
		if (!tty_term_flag(tty->term, TTYC_TC))
			return (-1);

		colour_split_rgb(colour & 0xffffff, &r, &g, &b);
		xsnprintf(s, sizeof s, "\033[%s;2;%hhu;%hhu;%hhum", type,
		    r, g, b);
		tty_puts(tty, s);
		return (0);
	}

	return (-1);

fallback_256:
	xsnprintf(s, sizeof s, "\033[%s;5;%dm", type, colour & 0xff);
	tty_puts(tty, s);
	return (0);
}

static void
tty_default_colours(struct grid_cell *gc, const struct window_pane *wp)
{
	struct window		*w = wp->window;
	struct options		*oo = w->options;
	const struct grid_cell	*agc, *pgc, *wgc;
	int			 c;

	if (w->flags & WINDOW_STYLECHANGED) {
		w->flags &= ~WINDOW_STYLECHANGED;
		agc = options_get_style(oo, "window-active-style");
		memcpy(&w->active_style, agc, sizeof w->active_style);
		wgc = options_get_style(oo, "window-style");
		memcpy(&w->style, wgc, sizeof w->style);
	} else {
		agc = &w->active_style;
		wgc = &w->style;
	}
	pgc = &wp->colgc;

	if (gc->fg == 8) {
		if (pgc->fg != 8)
			gc->fg = pgc->fg;
		else if (wp == w->active && agc->fg != 8)
			gc->fg = agc->fg;
		else
			gc->fg = wgc->fg;

		if (gc->fg != 8 &&
		    (c = window_pane_get_palette(wp, gc->fg)) != -1)
			gc->fg = c;
	}

	if (gc->bg == 8) {
		if (pgc->bg != 8)
			gc->bg = pgc->bg;
		else if (wp == w->active && agc->bg != 8)
			gc->bg = agc->bg;
		else
			gc->bg = wgc->bg;

		if (gc->bg != 8 &&
		    (c = window_pane_get_palette(wp, gc->bg)) != -1)
			gc->bg = c;
	}
}

static void
tty_default_attributes(struct tty *tty, const struct window_pane *wp, u_int bg)
{
	static struct grid_cell gc;

	memcpy(&gc, &grid_default_cell, sizeof gc);
	gc.bg = bg;
	tty_attributes(tty, &gc, wp);
}
@


1.278
log
@Scrolling needs to use background colour.
@
text
@d1 1
a1 1
/* $OpenBSD: tty.c,v 1.277 2017/05/12 11:19:24 nicm Exp $ */
d1083 1
d1104 1
@


1.277
log
@Regions can't be smaller than 2 so don't try to clear them by scrolling if so.
@
text
@d1 1
a1 1
/* $OpenBSD: tty.c,v 1.276 2017/05/12 11:13:43 nicm Exp $ */
d1144 2
d1150 1
a1150 1
	    tty_fake_bce(tty, ctx->wp, 8) ||
d1157 1
a1157 1
	tty_attributes(tty, &grid_default_cell, ctx->wp);
d1181 1
a1181 1
	tty_attributes(tty, &grid_default_cell, wp);
d1212 1
a1212 1
	tty_attributes(tty, &grid_default_cell, wp);
@


1.276
log
@Can use INDN to clear regions with default background colour if margins
are supported.
@
text
@d1 1
a1 1
/* $OpenBSD: tty.c,v 1.275 2017/05/12 10:50:11 nicm Exp $ */
d837 4
a840 1
		if (tty_use_margin(tty) && tty_term_has(tty->term, TTYC_INDN)) {
@


1.275
log
@ECH needs to use background colour.
@
text
@d1 1
a1 1
/* $OpenBSD: tty.c,v 1.274 2017/05/12 10:49:04 nicm Exp $ */
d811 1
d822 3
a824 2
		 * If we're setting a background colour (so it is not default),
		 * we can use DECFRA.
d830 11
@


1.274
log
@Can use DECFRA to clear area when not using default background.
@
text
@d1 1
a1 1
/* $OpenBSD: tty.c,v 1.273 2017/05/11 11:38:49 nicm Exp $ */
d1038 1
a1038 1
	tty_attributes(tty, &grid_default_cell, ctx->wp);
@


1.273
log
@Need to redraw out to cellsize (total cells used in a line) rather than
cellused (only non-space cells) because there may be cells with a
nondefault background.
@
text
@d1 1
a1 1
/* $OpenBSD: tty.c,v 1.272 2017/05/10 18:40:13 nicm Exp $ */
d801 1
d817 11
@


1.272
log
@Move to the right cursor position before using spaces to clear.
@
text
@d1 1
a1 1
/* $OpenBSD: tty.c,v 1.271 2017/05/10 16:47:03 nicm Exp $ */
d849 4
d854 2
a855 2
	if (sx > s->grid->linedata[s->grid->hsize + py].cellused)
		sx = s->grid->linedata[s->grid->hsize + py].cellused;
@


1.271
log
@We can use ECH to clear sections of lines, so use it for internal panes
(that don't touch an edge). Move all the tty clear code into two common
functions rather than having the same bunch of checks everywhere.
@
text
@d1 1
a1 1
/* $OpenBSD: tty.c,v 1.270 2017/05/09 13:04:36 nicm Exp $ */
d792 1
@


1.270
log
@If the current screen was complex enough, it was possible to make redraw
itself hit the "terminal can't keep up" check. To avoid this, record how
much data we send during redraw (we know we will be starting with 0) and
skip the check until it has been flushed. GitHub issue 912.
@
text
@d1 1
a1 1
/* $OpenBSD: tty.c,v 1.269 2017/04/28 17:58:44 nicm Exp $ */
d757 67
d836 1
a836 1
	u_int			 i, j, sx, width;
d927 2
a928 1
	if (!cleared && sx < tty->sx) {
d930 1
a930 8
		tty_cursor(tty, ox + sx, oy + py);
		if (sx != screen_size_x(s) &&
		    ox + screen_size_x(s) >= tty->sx &&
		    tty_term_has(tty->term, TTYC_EL) &&
		    !tty_fake_bce(tty, wp, 8))
			tty_putcode(tty, TTYC_EL);
		else
			tty_repeat_space(tty, screen_size_x(s) - sx);
d1076 1
a1076 2
	struct screen		*s = wp->screen;
	u_int			 sx = screen_size_x(s);
d1080 2
a1081 8
	tty_cursor_pane(tty, ctx, 0, ctx->ocy);

	if (tty_pane_full_width(tty, ctx) &&
	    !tty_fake_bce(tty, wp, ctx->bg) &&
	    tty_term_has(tty->term, TTYC_EL))
		tty_putcode(tty, TTYC_EL);
	else
		tty_repeat_space(tty, sx);
d1088 1
a1088 2
	struct screen		*s = wp->screen;
	u_int			 sx = screen_size_x(s);
d1092 2
a1093 8
	tty_cursor_pane(tty, ctx, ctx->ocx, ctx->ocy);

	if (tty_pane_full_width(tty, ctx) &&
	    tty_term_has(tty->term, TTYC_EL) &&
	    !tty_fake_bce(tty, wp, ctx->bg))
		tty_putcode(tty, TTYC_EL);
	else
		tty_repeat_space(tty, sx - ctx->ocx);
d1100 1
d1104 2
a1105 9
	if (ctx->xoff == 0 &&
	    tty_term_has(tty->term, TTYC_EL1) &&
	    !tty_fake_bce(tty, ctx->wp, ctx->bg)) {
		tty_cursor_pane(tty, ctx, ctx->ocx, ctx->ocy);
		tty_putcode(tty, TTYC_EL1);
	} else {
		tty_cursor_pane(tty, ctx, 0, ctx->ocy);
		tty_repeat_space(tty, ctx->ocx + 1);
	}
d1203 1
a1203 3
	struct screen		*s = wp->screen;
	u_int			 i, j;
	u_int			 sx = screen_size_x(s), sy = screen_size_y(s);
d1207 1
a1207 1
	tty_region_pane(tty, ctx, 0, sy - 1);
d1210 12
a1221 29
	if (tty_pane_full_width(tty, ctx) &&
	    ctx->yoff + wp->sy >= tty->sy - 1 &&
	    status_at_line(tty->client) <= 0 &&
	    tty_term_has(tty->term, TTYC_ED)) {
		tty_cursor_pane(tty, ctx, ctx->ocx, ctx->ocy);
		tty_putcode(tty, TTYC_ED);
	} else if (tty_pane_full_width(tty, ctx) &&
	    tty_term_has(tty->term, TTYC_EL) &&
	    !tty_fake_bce(tty, wp, ctx->bg)) {
		tty_cursor_pane(tty, ctx, ctx->ocx, ctx->ocy);
		tty_putcode(tty, TTYC_EL);
		if (ctx->ocy != sy - 1) {
			tty_cursor_pane(tty, ctx, 0, ctx->ocy + 1);
			for (i = ctx->ocy + 1; i < sy; i++) {
				tty_putcode(tty, TTYC_EL);
				if (i == sy - 1)
					continue;
				tty_emulate_repeat(tty, TTYC_CUD, TTYC_CUD1, 1);
				tty->cy++;
			}
		}
	} else {
		tty_cursor_pane(tty, ctx, ctx->ocx, ctx->ocy);
		tty_repeat_space(tty, sx - ctx->ocx);
		for (j = ctx->ocy + 1; j < sy; j++) {
			tty_cursor_pane(tty, ctx, 0, j);
			tty_repeat_space(tty, sx);
		}
	}
d1228 1
a1228 3
	struct screen		*s = wp->screen;
	u_int			 i, j;
	u_int			 sx = screen_size_x(s), sy = screen_size_y(s);
d1232 1
a1232 1
	tty_region_pane(tty, ctx, 0, sy - 1);
d1235 12
a1246 18
	if (tty_pane_full_width(tty, ctx) &&
	    tty_term_has(tty->term, TTYC_EL) &&
	    !tty_fake_bce(tty, wp, ctx->bg)) {
		tty_cursor_pane(tty, ctx, 0, 0);
		for (i = 0; i < ctx->ocy; i++) {
			tty_putcode(tty, TTYC_EL);
			tty_emulate_repeat(tty, TTYC_CUD, TTYC_CUD1, 1);
			tty->cy++;
		}
	} else {
		tty_cursor_pane(tty, ctx, 0, 0);
		for (j = 0; j < ctx->ocy; j++) {
			tty_cursor_pane(tty, ctx, 0, j);
			tty_repeat_space(tty, sx);
		}
	}
	tty_cursor_pane(tty, ctx, 0, ctx->ocy);
	tty_repeat_space(tty, ctx->ocx + 1);
d1253 1
a1253 3
	struct screen		*s = wp->screen;
	u_int			 i, j;
	u_int			 sx = screen_size_x(s), sy = screen_size_y(s);
d1257 1
a1257 1
	tty_region_pane(tty, ctx, 0, sy - 1);
d1260 6
a1265 24
	if (tty_pane_full_width(tty, ctx) &&
	    ctx->yoff + wp->sy >= tty->sy - 1 &&
	    status_at_line(tty->client) <= 0 &&
	    tty_term_has(tty->term, TTYC_ED)) {
		tty_cursor_pane(tty, ctx, 0, 0);
		tty_putcode(tty, TTYC_ED);
	} else if (tty_pane_full_width(tty, ctx) &&
	    tty_term_has(tty->term, TTYC_EL) &&
	    !tty_fake_bce(tty, wp, ctx->bg)) {
		tty_cursor_pane(tty, ctx, 0, 0);
		for (i = 0; i < sy; i++) {
			tty_putcode(tty, TTYC_EL);
			if (i != sy - 1) {
				tty_emulate_repeat(tty, TTYC_CUD, TTYC_CUD1, 1);
				tty->cy++;
			}
		}
	} else {
		tty_cursor_pane(tty, ctx, 0, 0);
		for (j = 0; j < sy; j++) {
			tty_cursor_pane(tty, ctx, 0, j);
			tty_repeat_space(tty, sx);
		}
	}
@


1.269
log
@Konsole incorrectly ignores SU (CSI S) if the parameter is bigger than
the scroll region, so clamp it. Reported by Moritz Bunkus.
@
text
@d1 1
a1 1
/* $OpenBSD: tty.c,v 1.268 2017/04/25 18:30:29 nicm Exp $ */
d236 8
a243 1
	if (tty_block_maybe(tty))
d498 1
a498 1
	log_debug("%s: %.*s", c->name, (int)len, (const char *)buf);
@


1.268
log
@Make full width panes try to play more nicely with terminal copy and
paste by avoiding explicit line wraps if we think the terminal will wrap
anyway.
@
text
@d1 1
a1 1
/* $OpenBSD: tty.c,v 1.267 2017/04/23 18:13:24 nicm Exp $ */
d1120 1
a1120 1
	u_int			 i;
d1134 10
a1143 1
	if (ctx->num == 1 || !tty_term_has(tty->term, TTYC_INDN)) {
d1145 1
a1145 1
		for (i = 0; i < ctx->num; i++)
d1148 1
a1148 1
		tty_putcode1(tty, TTYC_INDN, ctx->num);
@


1.267
log
@Only use ED for clear screen if at the bottom, same as earlier fix to
clear end of screen.
@
text
@d1 1
a1 1
/* $OpenBSD: tty.c,v 1.266 2017/04/19 06:52:27 nicm Exp $ */
d543 7
a549 3
	if (tty->cx + width > tty->sx)
		tty->cx = tty->cy = UINT_MAX;
	else
d780 20
a799 12
	if (screen_size_x(s) < tty->sx &&
	    ox == 0 &&
	    sx != screen_size_x(s) &&
	    tty_term_has(tty->term, TTYC_EL1) &&
	    !tty_fake_bce(tty, wp, 8)) {
		tty_default_attributes(tty, wp, 8);
		tty_cursor(tty, screen_size_x(s) - 1, oy + py);
		tty_putcode(tty, TTYC_EL1);
		cleared = 1;
	}
	if (sx != 0)
		tty_cursor(tty, ox, oy + py);
d1492 2
a1493 1
	if (!tty_pane_full_width(tty, ctx) ||
@


1.266
log
@When the data we have buffered to write to a terminal grows beyond a
reasonable amount (currently width * height * 8 bytes), discard all
output to the terminal and start trying to redraw periodically
instead. Continue with this until the amount of data we are trying to
write falls to a low level again.

This helps to prevent tmux sitting on a huge buffer of data when there
are processes with fast output running inside tmux but the outside
terminal is slow.

A new client_discarded format holds the amount of data that has been
discarded due to this mechanism.

The three variables (when to start this, when to stop, and how often to
redraw) are basically "works for me" at the moment, this is going in to
see how it goes and if it causes problems for anyone else.
@
text
@d1 1
a1 1
/* $OpenBSD: tty.c,v 1.265 2017/04/18 21:41:42 nicm Exp $ */
d1221 1
@


1.265
log
@Revert use of DECSLRM on iTerm2, it doesn't help as much as we throught,
and there are some question marks about it's support.
@
text
@d1 1
a1 1
/* $OpenBSD: tty.c,v 1.264 2017/04/18 18:21:37 nicm Exp $ */
d82 4
d179 45
d236 3
d253 1
a253 1
	tty->flags &= ~(TTY_NOCURSOR|TTY_FREEZE);
d262 2
d330 3
d485 5
d492 1
a492 1
	tty->written += len;
@


1.264
log
@Detect iTerm2 and use DECSLRM for it as well.
@
text
@d1 1
a1 1
/* $OpenBSD: tty.c,v 1.263 2017/04/18 15:44:17 nicm Exp $ */
d77 1
a77 1
	((tty)->term_type == TTY_VT420 || (tty)->term_type == TTY_ITERM2)
d254 1
a254 1
		tty_puts(tty, "\033[c\033[1337n");
@


1.263
log
@Add a format for number of bytes writtent to client, useful for debugging.
@
text
@d1 1
a1 1
/* $OpenBSD: tty.c,v 1.262 2017/04/18 15:27:47 nicm Exp $ */
d77 1
a77 1
	((tty)->term_type == TTY_VT420)
d79 1
a79 1
#define tty_pane_full_width(tty, ctx)					\
d254 1
a254 1
		tty_puts(tty, "\033[c");
@


1.262
log
@Do not check for BCE for a background colour that isn't needed, use
colour 8 instead.
@
text
@d1 1
a1 1
/* $OpenBSD: tty.c,v 1.261 2017/04/17 08:10:44 nicm Exp $ */
d430 1
@


1.261
log
@Don't bother moving the cursor for empty lines.
@
text
@d1 1
a1 1
/* $OpenBSD: tty.c,v 1.260 2017/04/17 06:40:32 nicm Exp $ */
d883 1
a883 1
	    !tty_fake_bce(tty, ctx->wp, ctx->bg))
d992 1
a992 1
	    tty_fake_bce(tty, ctx->wp, ctx->bg) ||
d1017 1
a1017 1
	    tty_fake_bce(tty, wp, ctx->bg) ||
d1048 1
a1048 1
	    tty_fake_bce(tty, wp, ctx->bg) ||
@


1.260
log
@Remove a couple of redraw flags that no longer have any effect.
@
text
@d1 1
a1 1
/* $OpenBSD: tty.c,v 1.259 2017/04/16 20:32:14 nicm Exp $ */
d723 2
a724 1
	tty_cursor(tty, ox, oy + py);
a779 1

@


1.259
log
@Use EL1 to clear lines when redrawing the leftmost pane, rather than
spaces.
@
text
@d1 1
a1 1
/* $OpenBSD: tty.c,v 1.258 2017/04/05 10:49:46 nicm Exp $ */
d819 1
a819 3
	if (wp->window->flags & WINDOW_REDRAW || wp->flags & PANE_REDRAW)
		return;
	if (!window_pane_visible(wp) || wp->flags & PANE_DROP)
@


1.258
log
@Give each client a name. This defaults to the tty name as before but
falls back to an alternative if the tty name is not available. This is
clearer than overloading the client ttyname member and allows us to
remove the path stored in the tty struct, it should always be the same
as the client.
@
text
@d1 1
a1 1
/* $OpenBSD: tty.c,v 1.257 2017/04/05 10:45:20 nicm Exp $ */
d696 1
a696 1
	int			 flags = (tty->flags & TTY_NOCURSOR);
d700 1
d713 10
d777 1
a777 1
	if (sx < tty->sx) {
@


1.257
log
@Change tty_repeat_space to write large sets of spaces together instead
of writing them individually.
@
text
@d1 1
a1 1
/* $OpenBSD: tty.c,v 1.256 2017/03/24 14:45:00 nicm Exp $ */
a96 2
	char	*path;

d106 1
a109 3
	if ((path = ttyname(fd)) == NULL)
		return (-1);
	tty->path = xstrdup(path);
d124 3
a126 2
	struct winsize	ws;
	u_int		sx, sy;
d139 2
a140 1
	log_debug("%s: %s now %ux%u", __func__, tty->path, sx, sy);
d161 1
d168 1
a168 1
	log_debug("%s: read %d bytes (already %zu)", tty->path, nread, size);
d178 1
d185 1
a185 1
	log_debug("%s: wrote %d bytes (of %zu)", tty->path, nwrite, size);
a353 1
	free(tty->path);
d426 2
d429 1
a429 1
	log_debug("%s: %.*s", tty->path, (int)len, (const char *)buf);
@


1.256
log
@Write raw strings in one go rather than character at a time.
@
text
@d1 1
a1 1
/* $OpenBSD: tty.c,v 1.255 2017/03/22 07:16:54 nicm Exp $ */
d605 11
a615 2
	while (n-- > 0)
		tty_putc(tty, ' ');
a867 2
	u_int	i;

d875 2
a876 4
	else {
		for (i = 0; i < ctx->num; i++)
			tty_putc(tty, ' ');
	}
@


1.255
log
@Add support for the strikethrough attribute (SGR 9), using the new smxx
terminfo capability. This means there are now nine attribute bits, so
anything above 0xff uses an extended cell.
@
text
@d1 1
a1 1
/* $OpenBSD: tty.c,v 1.254 2017/03/15 15:22:14 nicm Exp $ */
d1231 1
a1231 5
	u_int	 i;
	u_char	*str = ctx->ptr;

	for (i = 0; i < ctx->num; i++)
		tty_putc(tty, str[i]);
@


1.254
log
@Invalidate the cursor when we think we should have wrapped.
@
text
@d1 1
a1 1
/* $OpenBSD: tty.c,v 1.253 2017/03/15 09:21:21 nicm Exp $ */
d1560 1
a1560 1
	u_char			 changed;
d1630 2
@


1.253
log
@Try to avoid moving the cursor to the start of the next line when
printing cells if it is already at the very end of the line and the
terminal will wrap it to the next line itself, this means terminals
still see it as a wrapped line for the purposes of their own mouse
selection. Reported by millert@@.
@
text
@d1 1
a1 1
/* $OpenBSD: tty.c,v 1.252 2017/03/08 14:34:35 nicm Exp $ */
d479 4
a482 1
	tty->cx += width;
d1409 2
a1410 1
	    tty->cx < tty->sx)
@


1.252
log
@Always send smkx to the terminal outside, the keys we get from terminfo
are the keys when it is on.
@
text
@d1 1
a1 1
/* $OpenBSD: tty.c,v 1.251 2017/03/06 09:02:59 nicm Exp $ */
d44 2
d1193 1
a1193 1
	tty_cursor_pane(tty, ctx, ctx->ocx, ctx->ocy);
d1201 1
a1201 1
	tty_cursor_pane(tty, ctx, ctx->ocx, ctx->ocy);
d1392 18
@


1.251
log
@Collect strings correctly when on terminals that don't support UTF-8.
@
text
@d1 1
a1 1
/* $OpenBSD: tty.c,v 1.250 2017/02/21 16:25:04 nicm Exp $ */
d238 1
a238 1
	tty_putcode(tty, TTYC_RMKX);
a574 6
	}
	if (changed & MODE_KKEYPAD) {
		if (mode & MODE_KKEYPAD)
			tty_putcode(tty, TTYC_SMKX);
		else
			tty_putcode(tty, TTYC_RMKX);
@


1.250
log
@Change pane redraw to collect cells up as well, and simplify it a bit.
@
text
@d1 1
a1 1
/* $OpenBSD: tty.c,v 1.249 2017/02/16 12:56:01 nicm Exp $ */
d712 5
a716 1
		    (gc.attr & GRID_ATTR_CHARSET ||
d733 5
a737 1
		if (gc.attr & GRID_ATTR_CHARSET) {
d739 7
a745 2
			for (j = 0; j < gc.data.size; j++)
				tty_putc(tty, gc.data.data[j]);
@


1.249
log
@There are buggy terminals out there that do not move the cursor to 0,0
after CSR, so invalidate the cursor position rather than assuming 0,0.
@
text
@d1 1
a1 1
/* $OpenBSD: tty.c,v 1.248 2017/02/15 11:22:13 nicm Exp $ */
d685 5
a689 4
	struct grid_cell	 gc, tmp_gc;
	struct grid_line	*gl;
	u_int			 i, sx;
	int			 flags;
a690 1
	flags = tty->flags & TTY_NOCURSOR;
d698 2
a699 2
	if (sx > s->grid->linedata[s->grid->hsize + py].cellsize)
		sx = s->grid->linedata[s->grid->hsize + py].cellsize;
d703 5
a707 11
	/*
	 * Don't move the cursor to the start position if it will wrap there
	 * itself.
	 */
	gl = NULL;
	if (py != 0)
		gl = &s->grid->linedata[s->grid->hsize + py - 1];
	if (oy + py == 0 || gl == NULL || !(gl->flags & GRID_LINE_WRAPPED) ||
	    tty->cx < tty->sx || ox != 0 ||
	    (oy + py != tty->cy + 1 && tty->cy != s->rlower + oy))
		tty_cursor(tty, ox, oy + py);
d711 31
a741 5
		if (gc.flags & GRID_FLAG_SELECTED) {
			screen_select_cell(s, &tmp_gc, &gc);
			tty_cell(tty, &tmp_gc, wp);
		} else
			tty_cell(tty, &gc, wp);
@


1.248
log
@Do not clear to end of screen unless the pane is at the bottom.
@
text
@d1 1
a1 1
/* $OpenBSD: tty.c,v 1.247 2017/02/10 15:39:43 nicm Exp $ */
d1324 1
a1324 1
	tty->cx = tty->cy = 0;
d1362 1
a1362 1
	tty->cx = tty->cy = 0;
@


1.247
log
@Add not delete the event if more to write.
@
text
@d1 1
a1 1
/* $OpenBSD: tty.c,v 1.246 2017/02/10 15:39:14 nicm Exp $ */
d1034 1
@


1.246
log
@Revert; committed from the wrong directory.
@
text
@d1 1
a1 1
/* $OpenBSD: tty.c,v 1.244 2017/02/10 12:59:18 nicm Exp $ */
d185 2
a186 2
	if (EVBUFFER_LENGTH(tty->out) == 0)
		event_del(&tty->event_out);
@


1.245
log
@Add rather than delete the event if more writing to come.
@
text
@a173 21
tty_timer_callback(__unused int fd, __unused short events, void *data)
{
	struct tty		*tty = data;
	struct client		*c = tty->client;
	const struct timeval	 tv = { .tv_usec = 250000 };

	server_client_add_message(c, "%s: %zu discarded", tty->path,
	    tty->discarded);

	c->flags |= CLIENT_REDRAW;

	if (tty->discarded < 256) {
		tty->flags &= ~TTY_BLOCK;
		tty_invalidate(tty);
		return;
	}
	tty->discarded = 0;
	evtimer_add(&tty->timer, &tv);
}

static void
d176 3
a178 5
	struct tty		*tty = data;
	struct client		*c = tty->client;
	size_t			 size = EVBUFFER_LENGTH(tty->out), left;
	int			 nwrite;
	const struct timeval	 tv = { .tv_usec = 250000 };
d185 1
a185 19
	/*
	 * If we aren't managing to write everything (so we are creating more
	 * data than the terminal can accept), then the terminal can't keep up.
	 */
	left = EVBUFFER_LENGTH(tty->out);
	if (left > 32768 && nwrite < (int)size && (~tty->flags & TTY_BLOCK)) {
		server_client_add_message(c, "%s: can't keep up, %zu discarded",
		    tty->path, left);

		evbuffer_drain(tty->out, left);
		event_del(&tty->event_out);

		tty->discarded = 0;
		evtimer_add(&tty->timer, &tv);

		tty->flags |= TTY_BLOCK;
		return;
	}
	if (left == 0)
d199 1
a199 1
	tty->flags &= ~(TTY_NOCURSOR|TTY_FREEZE|TTY_BLOCK|TTY_TIMER);
a207 2
	evtimer_set(&tty->timer, tty_timer_callback, tty);

a273 3
	event_del(&tty->timer);
	tty->flags &= ~TTY_BLOCK;

a424 5
	if ((tty->flags & TTY_BLOCK) && (~tty->flags & TTY_FORCE)) {
		tty->discarded += len;
		return;
	}

@


1.244
log
@Don't use a bufferevent for the tty, so we can keep better track of what
is being written and when.

Also a manpage typo fix from jmc@@.
@
text
@d1 1
a1 1
/* $OpenBSD: tty.c,v 1.243 2017/02/08 23:53:03 nicm Exp $ */
d174 21
d197 5
a201 3
	struct tty	*tty = data;
	size_t		 size = EVBUFFER_LENGTH(tty->out);
	int		 nwrite;
d208 19
a226 1
	if (EVBUFFER_LENGTH(tty->out) == 0)
d240 1
a240 1
	tty->flags &= ~(TTY_NOCURSOR|TTY_FREEZE);
d249 2
d317 3
d471 5
@


1.243
log
@Another helper function to write to terminal and log.
@
text
@d1 1
a1 1
/* $OpenBSD: tty.c,v 1.242 2017/02/08 23:47:35 nicm Exp $ */
a36 5
static void	tty_init_termios(int, struct termios *, struct bufferevent *);

static void	tty_read_callback(struct bufferevent *, void *);
static void	tty_error_callback(struct bufferevent *, short, void *);

d157 32
d199 5
a203 1
	tty->flags &= ~(TTY_NOCURSOR|TTY_FREEZE|TTY_TIMER);
d205 2
a206 2
	tty->event = bufferevent_new(tty->fd, tty_read_callback, NULL,
	    tty_error_callback, tty);
d215 2
a216 17
static void
tty_read_callback(__unused struct bufferevent *bufev, void *data)
{
	struct tty	*tty = data;

	while (tty_keys_next(tty))
		;
}

static void
tty_error_callback(__unused struct bufferevent *bufev, __unused short what,
    __unused void *data)
{
}

static void
tty_init_termios(int fd, struct termios *orig_tio, struct bufferevent *bufev)
d220 15
a234 24
	if (fd == -1 || tcgetattr(fd, orig_tio) != 0)
		return;

	setblocking(fd, 0);

	if (bufev != NULL)
		bufferevent_enable(bufev, EV_READ|EV_WRITE);

	memcpy(&tio, orig_tio, sizeof tio);
	tio.c_iflag &= ~(IXON|IXOFF|ICRNL|INLCR|IGNCR|IMAXBEL|ISTRIP);
	tio.c_iflag |= IGNBRK;
	tio.c_oflag &= ~(OPOST|ONLCR|OCRNL|ONLRET);
	tio.c_lflag &= ~(IEXTEN|ICANON|ECHO|ECHOE|ECHONL|ECHOCTL|
	    ECHOPRT|ECHOKE|ISIG);
	tio.c_cc[VMIN] = 1;
	tio.c_cc[VTIME] = 0;
	if (tcsetattr(fd, TCSANOW, &tio) == 0)
		tcflush(fd, TCIOFLUSH);
}

void
tty_start_tty(struct tty *tty)
{
	tty_init_termios(tty->fd, &tty->tio, tty->event);
d274 2
a275 1
	bufferevent_disable(tty->event, EV_READ|EV_WRITE);
d329 4
a332 1
		bufferevent_free(tty->event);
d425 2
a426 2
	bufferevent_write(tty->event, buf, len);
	log_debug("%s: %.*s", tty->path, (int)len, buf);
d430 2
d746 1
a746 1
	if (c->flags & CLIENT_SUSPENDED)
@


1.242
log
@Add a common function to invalidate all the terminal cached state.
@
text
@d1 1
a1 1
/* $OpenBSD: tty.c,v 1.241 2017/02/08 22:42:07 nicm Exp $ */
d411 10
d424 2
a425 10
	size_t	size = EVBUFFER_LENGTH(tty->event->output);

	if (*s == '\0')
		return;

	bufferevent_write(tty->event, s, strlen(s));
	log_debug("%s (%zu): %s", tty->path, size, s);

	if (tty_log_fd != -1)
		write(tty_log_fd, s, strlen(s));
a430 1
	size_t		 size = EVBUFFER_LENGTH(tty->event->output);
d435 6
a440 11
		if (acs != NULL) {
			bufferevent_write(tty->event, acs, strlen(acs));
			log_debug("%s (%zu): %s", tty->path, size, acs);
		} else {
			bufferevent_write(tty->event, &ch, 1);
			log_debug("%s (%zu): %c", tty->path, size, ch);
		}
	} else {
		bufferevent_write(tty->event, &ch, 1);
		log_debug("%s (%zu): %c", tty->path, size, ch);
	}
a457 3

	if (tty_log_fd != -1)
		write(tty_log_fd, &ch, 1);
d463 1
a463 8
	size_t	size = EVBUFFER_LENGTH(tty->event->output);

	bufferevent_write(tty->event, buf, len);
	log_debug("%s (%zu): %.*s", tty->path, size, (int)len, (char *)buf);

	if (tty_log_fd != -1)
		write(tty_log_fd, buf, len);

@


1.241
log
@Do not adjust region lower by pane offset when scrolling up, it is
already an absolute position.
@
text
@d1 1
a1 1
/* $OpenBSD: tty.c,v 1.240 2017/02/08 17:31:09 nicm Exp $ */
d49 1
a49 1

d148 1
a148 17

	tty->cx = UINT_MAX;
	tty->cy = UINT_MAX;

	tty->rupper = tty->rleft = UINT_MAX;
	tty->rlower = tty->rright = UINT_MAX;

	/*
	 * If the terminal has been started, reset the actual scroll region and
	 * cursor position, as this may not have happened.
	 */
	if (tty->flags & TTY_STARTED) {
		tty_cursor(tty, 0, 0);
		tty_region_off(tty);
		tty_margin_off(tty);
	}

a230 6
	tty_putcode(tty, TTYC_SGR0);
	memcpy(&tty->cell, &grid_default_cell, sizeof tty->cell);

	memcpy(&tty->last_cell, &grid_default_cell, sizeof tty->last_cell);
	tty->last_wp = -1;

a247 8
	tty->cx = UINT_MAX;
	tty->cy = UINT_MAX;

	tty->rupper = tty->rleft = UINT_MAX;
	tty->rlower = tty->rright = UINT_MAX;

	tty->mode = MODE_CURSOR;

d249 1
d1204 1
a1204 6

	tty->cx = tty->cy = UINT_MAX;
	tty->rupper = tty->rlower = UINT_MAX;

	tty_attributes(tty, &grid_default_cell, ctx->wp);
	tty_cursor(tty, 0, 0);
d1259 26
@


1.240
log
@Add support for scroll up escape sequence (CSI S) and use it when
possible instead of sending individual line feeds.
@
text
@d1 1
a1 1
/* $OpenBSD: tty.c,v 1.239 2017/02/08 16:45:18 nicm Exp $ */
d1043 1
a1043 1
		tty_cursor(tty, tty->rright, ctx->yoff + tty->rlower);
@


1.239
log
@Collect sequences of printable ASCII characters and process them
together instead of handling them one by one. This is significantly
faster. Sequences are terminated when we reach the end of the line, fill
the internal buffer, or a different character is seen by the input
parser (an escape sequence, or UTF-8).

Rather than writing collected sequences out immediately, hold them until
it is necessary (another screen modification, or we consume all
available data). This means we can discard changes that would have no
effect (for example, lines that would just be scrolled off the screen or
cleared). This reduces the total amount of data we write out to the
terminal - not important for fast terminals, but a big help with slow
(like xterm).
@
text
@d1 1
a1 1
/* $OpenBSD: tty.c,v 1.238 2017/02/08 16:18:20 nicm Exp $ */
d1022 26
@


1.238
log
@Fix clear start of line.
@
text
@d1 1
a1 1
/* $OpenBSD: tty.c,v 1.237 2017/02/08 15:49:29 nicm Exp $ */
d1170 9
@


1.237
log
@Some other tidying bits.
@
text
@d1 1
a1 1
/* $OpenBSD: tty.c,v 1.236 2017/02/08 15:24:48 nicm Exp $ */
a956 2
	tty_cursor_pane(tty, ctx, 0, ctx->ocy);

d959 2
a960 1
	    !tty_fake_bce(tty, ctx->wp, ctx->bg))
d962 2
a963 1
	else
d965 1
@


1.236
log
@Remove unnecessary duplicate check.
@
text
@d1 1
a1 1
/* $OpenBSD: tty.c,v 1.235 2017/02/08 13:53:32 nicm Exp $ */
a1158 2
	struct window_pane	*wp = ctx->wp;

d1168 1
a1168 1
	tty_cell(tty, ctx->cell, wp);
@


1.235
log
@Improve some of the logging on resize.
@
text
@d1 1
a1 1
/* $OpenBSD: tty.c,v 1.234 2017/02/08 08:54:45 nicm Exp $ */
d1001 1
a1001 4
		if (tty_large_region(tty, ctx))
			wp->flags |= PANE_REDRAW;
		else
			tty_redraw_region(tty, ctx);
@


1.234
log
@Log size of output buffer as well.
@
text
@d1 1
a1 1
/* $OpenBSD: tty.c,v 1.233 2017/02/08 08:50:10 nicm Exp $ */
d145 1
@


1.233
log
@Trying to avoid the occasional newline by saving the last cell on screen
is not actually helping us much and just adds complexity, so don't
bother.
@
text
@d1 1
a1 1
/* $OpenBSD: tty.c,v 1.232 2017/02/07 18:27:46 nicm Exp $ */
d442 2
d446 1
d448 1
a451 1
	log_debug("%s: %s", tty->path, s);
d457 1
d464 1
a464 1
			log_debug("%s: %s", tty->path, acs);
d467 1
a467 1
			log_debug("%s: %c", tty->path, ch);
d471 1
a471 1
		log_debug("%s: %c", tty->path, ch);
d498 2
d501 1
a504 1
	log_debug("%s: %.*s", tty->path, (int)len, (char *)buf);
@


1.232
log
@Do not clear the scroll region, instead set it to the scroll region we
actually want.
@
text
@d1 1
a1 1
/* $OpenBSD: tty.c,v 1.231 2017/02/07 17:13:28 nicm Exp $ */
a1000 11
	/*
	 * If this line wrapped naturally (ctx->num is nonzero) and we are not
	 * using margins, don't do anything - the cursor can just be moved
	 * to the last cell and wrap naturally.
	 */
	if ((!tty_use_margin(tty) ||
	    tty_pane_full_width(tty, ctx)) &&
	    ctx->num != 0 &&
	    !(tty->term->flags & TERM_EARLYWRAP))
		return;

a1155 2
	struct screen		*s = wp->screen;
	u_int			 cx, width;
d1164 1
a1164 25
	/* Is the cursor in the very last position? */
	width = ctx->cell->data.width;
	if (ctx->ocx > wp->sx - width) {
		if (!tty_pane_full_width(tty, ctx)) {
			/*
			 * The pane doesn't fill the entire line, the linefeed
			 * will already have happened, so just move the cursor.
			 */
			if (ctx->ocy != wp->yoff + wp->screen->rlower)
				tty_cursor_pane(tty, ctx, 0, ctx->ocy + 1);
			else
				tty_cursor_pane(tty, ctx, 0, ctx->ocy);
		} else if (tty->cy != ctx->yoff + ctx->ocy ||
		    tty->cx < tty->sx) {
			/*
			 * The cursor isn't in the last position already, so
			 * move as far right as possible and redraw the last
			 * cell to move into the last position.
			 */
			cx = screen_size_x(s) - ctx->last_cell.data.width;
			tty_cursor_pane(tty, ctx, cx, ctx->ocy);
			tty_cell(tty, &ctx->last_cell, wp);
		}
	} else
		tty_cursor_pane(tty, ctx, ctx->ocx, ctx->ocy);
@


1.231
log
@DECSLRM in xterm(1) appears to have a quirk where it can generate an
extra scroll of the entire terminal; issuing DECSTBM first prevents
this. Do that for now.
@
text
@d1 1
a1 1
/* $OpenBSD: tty.c,v 1.230 2017/02/07 14:33:37 nicm Exp $ */
d1359 1
a1359 2
	tty->rupper = 0;
	tty->rlower = tty->sy - 1;
d1364 4
a1367 1
	snprintf(s, sizeof s, "\033[r\033[%u;%us", rleft + 1, rright + 1);
@


1.230
log
@Unfortunately DECFRA does not handle default colours properly (it does
not reset colours when in SGR 0), so we can't use it without more
trouble than it is worth. Abandon the idea for now.
@
text
@d1 1
a1 1
/* $OpenBSD: tty.c,v 1.229 2017/02/06 22:05:11 nicm Exp $ */
d448 1
d458 1
a458 1
		if (acs != NULL)
d460 2
a461 1
		else
d463 3
a465 1
	} else
d467 2
d495 1
d498 2
d1331 1
a1331 1
	tty_cursor(tty, 0, 0);
d1359 3
d1365 1
a1365 1
	snprintf(s, sizeof s, "\033[%u;%us", rleft + 1, rright + 1);
d1367 1
a1367 1
	tty_cursor(tty, 0, 0);
@


1.229
log
@Use DECFRA on VT420 compatible terminals (so, xterm) and ED on all
others for clearing panes.
@
text
@d1 1
a1 1
/* $OpenBSD: tty.c,v 1.228 2017/02/06 19:45:23 nicm Exp $ */
a66 2
static void	tty_clear_area(struct tty *, const struct tty_ctx *ctx, u_int,
		    u_int, u_int, u_int);
a687 11
static void
tty_clear_area(struct tty *tty, const struct tty_ctx *ctx, u_int sx, u_int sy,
    u_int ex, u_int ey)
{
	char s[64];

	snprintf (s, sizeof s, "\033[32;%u;%u;%u;%u$x", ctx->yoff + sy + 1,
	    ctx->xoff + sx + 1, ctx->yoff + ey + 1, ctx->xoff + ex + 1);
	tty_puts(tty, s);
}

a910 3
	else if (tty->term_type == TTY_VT420 &&
	    !tty_fake_bce(tty, wp, ctx->bg))
		tty_clear_area(tty, ctx, 0, ctx->ocy, sx - 1, ctx->ocy);
a929 3
	else if (tty->term_type == TTY_VT420 &&
	    !tty_fake_bce(tty, wp, ctx->bg))
		tty_clear_area(tty, ctx, ctx->ocx, ctx->ocy, sx - 1, ctx->ocy);
d941 2
d945 1
a945 2
	    !tty_fake_bce(tty, ctx->wp, ctx->bg)) {
		tty_cursor_pane(tty, ctx, ctx->ocx, ctx->ocy);
d947 1
a947 5
	} else if (tty->term_type == TTY_VT420 &&
	    !tty_fake_bce(tty, wp, ctx->bg))
		tty_clear_area(tty, ctx, 0, ctx->ocy, ctx->ocx, ctx->ocy);
	else {
		tty_cursor_pane(tty, ctx, 0, ctx->ocy);
a948 1
	}
a1038 12
	} else if (tty->term_type == TTY_VT420 &&
	    !tty_fake_bce(tty, wp, ctx->bg)) {
		tty_cursor_pane(tty, ctx, ctx->ocx, ctx->ocy);
		if (tty_pane_full_width(tty, ctx) &&
		    tty_term_has(tty->term, TTYC_EL))
			tty_putcode(tty, TTYC_EL);
		else
			tty_repeat_space(tty, sx - ctx->ocx);
		if (ctx->ocy != sy - 1) {
			tty_clear_area(tty, ctx, 0, ctx->ocy + 1, sx - 1,
			    sy - 1);
		}
d1077 1
a1077 4
	if (tty->term_type == TTY_VT420 &&
	    !tty_fake_bce(tty, wp, ctx->bg))
		tty_clear_area(tty, ctx, 0, 0, sx - 1, ctx->ocy - 1);
	else if (tty_pane_full_width(tty, ctx) &&
d1115 1
a1115 4
	} else if (tty->term_type == TTY_VT420 &&
	    !tty_fake_bce(tty, wp, ctx->bg))
		tty_clear_area(tty, ctx, 0, 0, sx - 1, sy - 1);
	else if (tty_pane_full_width(tty, ctx) &&
@


1.228
log
@Do not go through the whole attributes setting process if the new cell
is the same as the previous one.
@
text
@d1 1
a1 1
/* $OpenBSD: tty.c,v 1.227 2017/02/06 19:26:49 nicm Exp $ */
d67 2
d84 1
a84 1
#define tty_pane_full_width(tty, ctx) \
d690 11
d914 1
d924 3
d928 1
a928 1
		tty_repeat_space(tty, screen_size_x(s));
d936 1
d946 3
d950 1
a950 1
		tty_repeat_space(tty, screen_size_x(s) - ctx->ocx);
d965 4
a968 1
	} else {
d1050 1
d1054 1
a1054 1
	tty_region_pane(tty, ctx, 0, screen_size_y(s) - 1);
a1055 1
	tty_cursor_pane(tty, ctx, ctx->ocx, ctx->ocy);
d1058 17
d1077 1
d1079 1
a1079 1
		if (ctx->ocy != screen_size_y(s) - 1) {
d1081 1
a1081 1
			for (i = ctx->ocy + 1; i < screen_size_y(s); i++) {
d1083 1
a1083 1
				if (i == screen_size_y(s) - 1)
d1090 3
a1092 2
		tty_repeat_space(tty, screen_size_x(s) - ctx->ocx);
		for (j = ctx->ocy + 1; j < screen_size_y(s); j++) {
d1094 1
a1094 1
			tty_repeat_space(tty, screen_size_x(s));
d1105 1
d1109 1
a1109 1
	tty_region_pane(tty, ctx, 0, screen_size_y(s) - 1);
a1110 1
	tty_cursor_pane(tty, ctx, 0, 0);
d1112 4
a1115 1
	if (tty_pane_full_width(tty, ctx) &&
d1118 1
d1125 1
d1128 1
a1128 1
			tty_repeat_space(tty, screen_size_x(s));
d1131 1
d1141 1
d1145 1
a1145 1
	tty_region_pane(tty, ctx, 0, screen_size_y(s) - 1);
a1146 1
	tty_cursor_pane(tty, ctx, 0, 0);
d1149 8
d1159 2
a1160 1
		for (i = 0; i < screen_size_y(s); i++) {
d1162 1
a1162 1
			if (i != screen_size_y(s) - 1) {
d1168 2
a1169 1
		for (j = 0; j < screen_size_y(s); j++) {
d1171 1
a1171 1
			tty_repeat_space(tty, screen_size_x(s));
@


1.227
log
@Add BCE for clear to start of screen, which was somehow missed.
@
text
@d1 1
a1 1
/* $OpenBSD: tty.c,v 1.226 2017/02/06 13:23:00 nicm Exp $ */
d249 3
d1256 6
a1261 2
	if (grid_cells_equal(gc, &grid_default_cell))
		return;
d1263 2
a1264 4
	if ((gc->attr & GRID_ATTR_CHARSET) && tty_use_acs(tty))
		tty_putcode(tty, TTYC_RMACS);
	tty_putcode(tty, TTYC_SGR0);
	memcpy(gc, &grid_default_cell, sizeof *gc);
d1486 12
@


1.226
log
@Only redraw the modified character when adding combining characters, not
the whole line.
@
text
@d1 1
a1 1
/* $OpenBSD: tty.c,v 1.225 2017/02/01 09:55:07 nicm Exp $ */
d1060 1
a1060 1
	tty_attributes(tty, &grid_default_cell, wp);
@


1.225
log
@Implement "all event" (1003) mouse mode but in a way that works. The
main issue is that if we have two panes, A with 1002 and B with 1003, we
need to set 1003 outside tmux in order to get all the mouse events, but
then we need to suppress the ones that pane A doesn't want. This is easy
in SGR mouse mode, because buttons == 3 is only used for movement events
(for other events the trailing m/M marks a release instead), but in
normal mouse mode we can't tell so easily. So for that, look at the
previous event instead - if it is drag+release as well, then the current
event is a movement event.
@
text
@d1 1
a1 1
/* $OpenBSD: tty.c,v 1.224 2017/01/12 00:30:41 nicm Exp $ */
a1173 12
}

void
tty_cmd_utf8character(struct tty *tty, const struct tty_ctx *ctx)
{
	struct window_pane	*wp = ctx->wp;

	/*
	 * Cannot rely on not being a partial character, so just redraw the
	 * whole line.
	 */
	tty_draw_pane(tty, wp, ctx->ocy, ctx->xoff, ctx->yoff);
@


1.224
log
@aixterm colours can be used if -2 is given, as well as if TERM tells us
the terminal has >=16 colours.
@
text
@d1 1
a1 1
/* $OpenBSD: tty.c,v 1.223 2017/01/12 00:19:32 nicm Exp $ */
d571 3
a573 1
			if (mode & MODE_MOUSE_BUTTON)
d578 3
a580 1
			if (tty->mode & MODE_MOUSE_BUTTON)
@


1.223
log
@Fix setting the palette of aixterm colours (90-97).
@
text
@d1 1
a1 1
/* $OpenBSD: tty.c,v 1.222 2017/01/11 23:10:04 nicm Exp $ */
d1628 6
a1633 1
	colours = tty_term_number(tty->term, TTYC_COLORS);
d1638 1
a1638 2
		if (!(tty->term->flags & TERM_256COLOURS) &&
		    !(tty->term_flags & TERM_256COLOURS)) {
d1681 6
a1686 1
	colours = tty_term_number(tty->term, TTYC_COLORS);
d1695 1
a1695 2
		if (!(tty->term->flags & TERM_256COLOURS) &&
		    !(tty->term_flags & TERM_256COLOURS)) {
@


1.222
log
@Be less aggressive about turning margins off.
@
text
@d1 1
a1 1
/* $OpenBSD: tty.c,v 1.221 2017/01/11 22:36:07 nicm Exp $ */
d1612 1
d1616 2
a1617 2
	    gc->fg != 8 && WINDOW_PANE_PALETTE_HAS(wp, gc->fg))
		gc->fg = wp->palette[gc->fg & 0xff];
d1661 1
d1665 2
a1666 2
	    gc->bg != 8 && WINDOW_PANE_PALETTE_HAS(wp, gc->bg))
		gc->bg = wp->palette[gc->bg & 0xff];
d1822 1
d1844 3
a1846 2
		if (gc->fg != 8 && WINDOW_PANE_PALETTE_HAS(wp, gc->fg))
			gc->fg = wp->palette[gc->fg & 0xff];
d1857 3
a1859 2
		if (gc->bg != 8 && WINDOW_PANE_PALETTE_HAS(wp, gc->bg))
			gc->bg = wp->palette[gc->bg & 0xff];
@


1.221
log
@Add some missing special keys to key_string_lookup_key, fix a mouse
check in server_client_handle_key, and tweak a comment.
@
text
@d1 1
a1 1
/* $OpenBSD: tty.c,v 1.220 2017/01/11 16:09:57 nicm Exp $ */
d1136 6
a1141 7
	if (ctx->xoff + ctx->ocx > tty->sx - 1 &&
	    ctx->ocy == ctx->orlower &&
	    tty_pane_full_width(tty, ctx))
		tty_region_pane(tty, ctx, ctx->orupper, ctx->orlower);
	else
		tty_region_off(tty);
	tty_margin_off(tty);
@


1.220
log
@Add a format for terminal type.
@
text
@d1 1
a1 1
/* $OpenBSD: tty.c,v 1.219 2017/01/07 15:28:13 nicm Exp $ */
d568 1
a568 3
			 * this is safe from misinterpretation. Do it in this
			 * order, because in some terminals it's the last one
			 * that takes effect and SGR is the preferred one.
@


1.219
log
@Add support for the OSC 4 and OSC 104 palette setting escape sequences,
from S Gilles.
@
text
@d1 1
a1 1
/* $OpenBSD: tty.c,v 1.218 2016/12/07 09:16:55 nicm Exp $ */
d108 1
a108 1
		tty->termname = xstrdup("unknown");
d110 1
a110 1
		tty->termname = xstrdup(term);
d180 1
a180 1
	tty->term = tty_term_find(tty->termname, tty->fd, cause);
d367 1
a367 1
	free(tty->termname);
@


1.218
log
@Only skip moving the cursor if it is already in the last position _on
the same line_, fixes redraw bug reported by patrick keshishian.
@
text
@d1 1
a1 1
/* $OpenBSD: tty.c,v 1.217 2016/11/30 13:20:02 nicm Exp $ */
d51 4
a54 2
static void	tty_check_fg(struct tty *, struct grid_cell *);
static void	tty_check_bg(struct tty *, struct grid_cell *);
d1512 2
a1513 2
	tty_check_fg(tty, &gc2);
	tty_check_bg(tty, &gc2);
d1609 3
a1611 2
void
tty_check_fg(struct tty *tty, struct grid_cell *gc)
d1616 5
d1657 3
a1659 2
void
tty_check_bg(struct tty *tty, struct grid_cell *gc)
d1664 5
d1843 3
d1855 3
@


1.217
log
@Fix check for cursor at end of line.
@
text
@d1 1
a1 1
/* $OpenBSD: tty.c,v 1.216 2016/11/28 17:50:00 nicm Exp $ */
d1156 2
a1157 1
		} else if (tty->cx != tty->sx - 1) {
@


1.216
log
@When comparing ocy to orlower in tty_cmd_cell, there is no need to add
yoff (because they are both already relative to the pane). Also fix some
other minor nits.
@
text
@d1 1
a1 1
/* $OpenBSD: tty.c,v 1.215 2016/11/16 13:31:22 nicm Exp $ */
d1156 1
a1156 1
		} else if (tty->cx < tty->sx) {
@


1.215
log
@Fix calculation of whether we need a region for drawing a cell (only if
full width and at the edge of the region), otherwise clear the region entirely.
@
text
@d1 1
a1 1
/* $OpenBSD: tty.c,v 1.214 2016/11/15 15:17:28 nicm Exp $ */
d992 1
a992 1
	    !(tty->term->flags & TERM_EARLYWRAP)) {
a993 1
	}
d1006 1
a1006 1
		tty_cursor(tty, tty->rright, tty->rlower);
d1137 1
a1137 1
	    ctx->yoff + ctx->ocy == ctx->orlower &&
d1147 1
a1147 1
		if (ctx->xoff != 0 || wp->sx != tty->sx) {
d1159 1
a1159 1
			 * move as far left as possible and redraw the last
@


1.214
log
@Turn on margins, with a couple of fixes (only limit to the pane for line
feeds, and do not move cursor to end for full width panes).
@
text
@d1 1
a1 1
/* $OpenBSD: tty.c,v 1.213 2016/11/15 14:08:27 nicm Exp $ */
d1007 1
a1007 1
		tty_cursor(tty, tty->rright, ctx->yoff + ctx->ocy);
d1137 3
a1139 1
	if (ctx->ocy == ctx->orlower)
d1141 2
@


1.213
log
@And of course I just find a bug, disable previous for now.
@
text
@d1 1
a1 1
/* $OpenBSD: tty.c,v 1.212 2016/11/15 14:02:32 nicm Exp $ */
d58 1
d60 1
d78 1
a78 1
	(0 && (tty)->term_type == TTY_VT420)
d158 2
a159 2
		tty_region(tty, 0, tty->sy - 1);
		tty_margin(tty, 0, tty->sx - 1);
d701 3
d863 1
a863 1
	tty_margin_pane(tty, ctx);
d883 1
a883 1
	tty_margin_pane(tty, ctx);
d960 1
a960 1
	tty_margin_pane(tty, ctx);
d989 2
a990 1
	if (!tty_use_margin(tty) &&
d1024 1
a1024 1
	tty_margin_pane(tty, ctx);
d1060 1
a1060 1
	tty_margin_pane(tty, ctx);
d1090 1
a1090 1
	tty_margin_pane(tty, ctx);
d1121 1
a1121 1
	tty_margin_pane(tty, ctx);
d1139 1
a1139 1
	tty_margin_pane(tty, ctx);
d1267 7
d1283 1
a1283 1
void
d1307 7
d1322 1
a1322 1
void
@


1.212
log
@Initial attempt to make use of left and right margins if the terminal
supports them (that is, if it advertises itself as a VT420 - probably
just xterm). These are the vertical equivalent of the scroll region and
allow much faster scrolling of panes that do not take up the full width
of the terminal.
@
text
@d1 1
a1 1
/* $OpenBSD: tty.c,v 1.211 2016/10/14 21:48:00 nicm Exp $ */
d76 1
a76 1
	((tty)->term_type == TTY_VT420)
@


1.211
log
@Don't make assumptions about line wrap on !xenl terminals, means that
using a wrong TERM without xenl is not so broken if used on a sensible
terminal.
@
text
@d1 1
a1 1
/* $OpenBSD: tty.c,v 1.210 2016/10/13 20:27:27 nicm Exp $ */
d24 1
d58 1
d75 2
d117 1
d119 1
d147 2
a148 2
	tty->rupper = UINT_MAX;
	tty->rlower = UINT_MAX;
d157 1
d164 2
a165 1
tty_set_size(struct tty *tty, u_int sx, u_int sy) {
d259 1
d265 2
a266 2
	tty->rlower = UINT_MAX;
	tty->rupper = UINT_MAX;
d327 2
d367 9
d858 1
d878 1
d955 1
d969 1
a969 1
	if (!tty_pane_full_width(tty, ctx) ||
d980 3
a982 3
	 * If this line wrapped naturally (ctx->num is nonzero), don't do
	 * anything - the cursor can just be moved to the last cell and wrap
	 * naturally.
d984 3
a986 1
	if (ctx->num && !(tty->term->flags & TERM_EARLYWRAP))
d988 1
d993 11
a1003 1
	tty_cursor_pane(tty, ctx, ctx->ocx, ctx->ocy);
d1018 1
d1054 1
d1084 1
d1115 1
d1133 1
d1291 26
@


1.210
log
@Add support for BCE (background colour erase). This makes various escape
sequences (notable EL and ED but also IL, DL, ICH, DCH) create blank
cells using the current background colour rather than the default
colour.

On modern systems BCE doesn't really have many benefits, but most other
terminals now support it, some (lazy) applications rely on it, and it is
not hard to include now that we have pane background colours anyway.

Mostly written by Sean Haugh.
@
text
@d1 1
a1 1
/* $OpenBSD: tty.c,v 1.209 2016/10/12 13:24:07 nicm Exp $ */
a426 1
	u_int		 sx;
d438 1
a438 5
		sx = tty->sx;
		if (tty->term->flags & TERM_EARLYWRAP)
			sx--;

		if (tty->cx >= sx) {
d442 8
d1175 3
a1177 2
	if (tty->term->flags & TERM_EARLYWRAP &&
	    tty->cy == tty->sy - 1 && tty->cx == tty->sx - 1)
@


1.209
log
@Redraw selection in tty_draw_line, so it appears when redrawing whole
pane. Reported by Theo Buehler.
@
text
@d1 1
a1 1
/* $OpenBSD: tty.c,v 1.208 2016/10/11 13:21:59 nicm Exp $ */
d58 2
a59 1
static int	tty_fake_bce(const struct tty *, const struct window_pane *);
d68 2
d610 1
a610 1
tty_fake_bce(const struct tty *tty, const struct window_pane *wp)
d614 3
d621 3
a623 3
	if (gc.bg == 8)
		return (0);
	return (!tty_term_flag(tty->term, TTYC_BCE));
d704 1
a704 1
		tty_attributes(tty, &grid_default_cell, wp);
d710 1
a710 1
		    !tty_fake_bce(tty, wp))
d768 4
a771 3
	if (!tty_pane_full_width(tty, ctx) || tty_fake_bce(tty, wp) ||
	    (!tty_term_has(tty->term, TTYC_DCH) &&
	    !tty_term_has(tty->term, TTYC_DCH1))) {
d776 1
a776 1
	tty_attributes(tty, &grid_default_cell, wp);
d788 2
a789 1
	if (!tty_pane_full_width(tty, ctx) || tty_fake_bce(tty, wp) ||
d796 1
a796 1
	tty_attributes(tty, &grid_default_cell, wp);
d812 2
a813 1
	if (tty_term_has(tty->term, TTYC_ECH) && !tty_fake_bce(tty, ctx->wp))
d824 2
a825 1
	if (!tty_pane_full_width(tty, ctx) || tty_fake_bce(tty, ctx->wp) ||
d832 1
a832 1
	tty_attributes(tty, &grid_default_cell, ctx->wp);
d843 2
a844 1
	if (!tty_pane_full_width(tty, ctx) || tty_fake_bce(tty, ctx->wp) ||
d851 1
a851 1
	tty_attributes(tty, &grid_default_cell, ctx->wp);
d865 1
a865 1
	tty_attributes(tty, &grid_default_cell, wp);
d869 2
a870 1
	if (tty_pane_full_width(tty, ctx) && !tty_fake_bce(tty, wp) &&
d883 1
a883 1
	tty_attributes(tty, &grid_default_cell, wp);
d888 2
a889 1
	    tty_term_has(tty->term, TTYC_EL) && !tty_fake_bce(tty, wp))
d898 3
a900 1
	tty_attributes(tty, &grid_default_cell, ctx->wp);
d902 3
a904 2
	if (ctx->xoff == 0 && tty_term_has(tty->term, TTYC_EL1) &&
	    !tty_fake_bce(tty, ctx->wp)) {
d919 2
a920 1
	if (!tty_pane_full_width(tty, ctx) || tty_fake_bce(tty, ctx->wp) ||
d943 2
a944 1
	if (!tty_pane_full_width(tty, ctx) || tty_fake_bce(tty, wp) ||
d976 1
a976 1
	tty_attributes(tty, &grid_default_cell, wp);
d982 2
a983 1
	    tty_term_has(tty->term, TTYC_EL) && !tty_fake_bce(tty, wp)) {
d1017 2
a1018 1
	    tty_term_has(tty->term, TTYC_EL) && !tty_fake_bce(tty, wp)) {
d1040 1
a1040 1
	tty_attributes(tty, &grid_default_cell, wp);
d1046 2
a1047 1
	    tty_term_has(tty->term, TTYC_EL) && !tty_fake_bce(tty, wp)) {
d1744 10
@


1.208
log
@Add static in window-*.c and move some internal functions out of tmux.h.
@
text
@d1 1
a1 1
/* $OpenBSD: tty.c,v 1.207 2016/10/10 21:29:23 nicm Exp $ */
d661 1
a661 1
	struct grid_cell	 gc;
d690 5
a694 1
		tty_cell(tty, &gc, wp);
@


1.207
log
@Loads more static, except for cmd-*.c and window-*.c.
@
text
@d1 1
a1 1
/* $OpenBSD: tty.c,v 1.206 2016/10/03 19:19:18 nicm Exp $ */
d36 2
d45 3
d55 2
d199 1
a199 1
void
d488 1
a488 1
void
d1192 1
a1192 1
void
d1225 1
a1225 1
void
@


1.206
log
@Remove some redundant checks and make ich/dch consistent.
@
text
@d1 1
a1 1
/* $OpenBSD: tty.c,v 1.205 2016/07/15 00:49:08 nicm Exp $ */
d34 1
a34 1
static int tty_log_fd = -1;
d36 2
a37 2
void	tty_read_callback(struct bufferevent *, void *);
void	tty_error_callback(struct bufferevent *, short, void *);
d39 1
a39 1
static int tty_client_ready(struct client *, struct window_pane *);
d41 19
a59 18
void	tty_set_italics(struct tty *);
int	tty_try_colour(struct tty *, int, const char *);

void	tty_colours(struct tty *, const struct grid_cell *);
void	tty_check_fg(struct tty *, struct grid_cell *);
void	tty_check_bg(struct tty *, struct grid_cell *);
void	tty_colours_fg(struct tty *, const struct grid_cell *);
void	tty_colours_bg(struct tty *, const struct grid_cell *);

int	tty_large_region(struct tty *, const struct tty_ctx *);
int	tty_fake_bce(const struct tty *, const struct window_pane *);
void	tty_redraw_region(struct tty *, const struct tty_ctx *);
void	tty_emulate_repeat(struct tty *, enum tty_code_code, enum tty_code_code,
	    u_int);
void	tty_repeat_space(struct tty *, u_int);
void	tty_cell(struct tty *, const struct grid_cell *,
	    const struct window_pane *);
void	tty_default_colours(struct grid_cell *, const struct window_pane *);
d177 1
a177 1
void
d186 1
a186 1
void
d454 1
a454 1
void
d563 1
a563 1
void
d575 1
a575 1
void
d587 1
a587 1
int
d599 1
a599 1
int
d618 1
a618 1
void
d1133 1
a1133 1
void
d1423 1
a1423 1
void
d1563 1
a1563 1
void
d1593 1
a1593 1
void
d1623 1
a1623 1
int
d1676 1
a1676 1
void
@


1.205
log
@Don't update cells in each block of data read from a pane immediately,
instead track them as change (dirty) and update them once at the end,
saves much time if repeatedly writing the same cell. Also fix comparison
of cells being equal in a few places (memcmp is not enough).
@
text
@d1 1
a1 1
/* $OpenBSD: tty.c,v 1.204 2016/07/15 00:42:56 nicm Exp $ */
d750 3
a752 1
	if (!tty_pane_full_width(tty, ctx)) {
d761 1
a761 5
	if (!tty_fake_bce(tty, wp) && (tty_term_has(tty->term, TTYC_ICH) ||
	    tty_term_has(tty->term, TTYC_ICH1)))
		tty_emulate_repeat(tty, TTYC_ICH, TTYC_ICH1, ctx->num);
	else
		tty_draw_pane(tty, wp, ctx->ocy, ctx->xoff, ctx->yoff);
d780 1
a780 3
	if (tty_term_has(tty->term, TTYC_DCH) ||
	    tty_term_has(tty->term, TTYC_DCH1))
		tty_emulate_repeat(tty, TTYC_DCH, TTYC_DCH1, ctx->num);
@


1.204
log
@Instead of representing colours in several different forms with various
cell flags, convert to use an int with flags marking 256 or RGB colours
in the top byte (except in cells, which we don't want to make any
bigger). From Brad Town.
@
text
@d1 1
a1 1
/* $OpenBSD: tty.c,v 1.203 2016/05/30 09:50:21 nicm Exp $ */
d1178 1
a1178 1
	if (memcmp(gc, &grid_default_cell, sizeof *gc) == 0)
@


1.203
log
@Cache the window styles and do not look up the window-style options
unless they have changed.
@
text
@d1 1
a1 1
/* $OpenBSD: tty.c,v 1.202 2016/05/30 09:26:49 nicm Exp $ */
a38 6
static int tty_same_fg(const struct grid_cell *, const struct grid_cell *);
static int tty_same_bg(const struct grid_cell *, const struct grid_cell *);
static int tty_same_colours(const struct grid_cell *, const struct grid_cell *);
static int tty_is_fg(const struct grid_cell *, int);
static int tty_is_bg(const struct grid_cell *, int);

d42 1
a42 2
int	tty_try_256(struct tty *, u_char, const char *);
int	tty_try_rgb(struct tty *, const struct grid_cell_rgb *, const char *);
a65 68
static int
tty_same_fg(const struct grid_cell *gc1, const struct grid_cell *gc2)
{
	int	flags1, flags2;

	flags1 = (gc1->flags & (GRID_FLAG_FG256|GRID_FLAG_FGRGB));
	flags2 = (gc2->flags & (GRID_FLAG_FG256|GRID_FLAG_FGRGB));

	if (flags1 != flags2)
	    return (0);

	if (flags1 & GRID_FLAG_FGRGB) {
		if (gc1->fg_rgb.r != gc2->fg_rgb.r)
			return (0);
		if (gc1->fg_rgb.g != gc2->fg_rgb.g)
			return (0);
		if (gc1->fg_rgb.b != gc2->fg_rgb.b)
			return (0);
		return (1);
	}
	return (gc1->fg == gc2->fg);
}

static int
tty_same_bg(const struct grid_cell *gc1, const struct grid_cell *gc2)
{
	int	flags1, flags2;

	flags1 = (gc1->flags & (GRID_FLAG_BG256|GRID_FLAG_BGRGB));
	flags2 = (gc2->flags & (GRID_FLAG_BG256|GRID_FLAG_BGRGB));

	if (flags1 != flags2)
	    return (0);

	if (flags1 & GRID_FLAG_BGRGB) {
		if (gc1->bg_rgb.r != gc2->bg_rgb.r)
			return (0);
		if (gc1->bg_rgb.g != gc2->bg_rgb.g)
			return (0);
		if (gc1->bg_rgb.b != gc2->bg_rgb.b)
			return (0);
		return (1);
	}
	return (gc1->bg == gc2->bg);
}

static int
tty_same_colours(const struct grid_cell *gc1, const struct grid_cell *gc2)
{
	return (tty_same_fg(gc1, gc2) && tty_same_bg(gc1, gc2));
}

static int
tty_is_fg(const struct grid_cell *gc, int c)
{
	if (gc->flags & (GRID_FLAG_FG256|GRID_FLAG_FGRGB))
		return (0);
	return (gc->fg == c);
}

static int
tty_is_bg(const struct grid_cell *gc, int c)
{
	if (gc->flags & (GRID_FLAG_BG256|GRID_FLAG_BGRGB))
		return (0);
	return (gc->bg == c);
}

d607 1
a607 1
	if (gc.bg == 8 && !(gc.flags & GRID_FLAG_BG256))
d622 1
a622 1
	u_int		 	 i;
a681 5
		if (screen_check_selection(s, i, py)) {
			gc.flags &= ~(GRID_FLAG_FG256|GRID_FLAG_BG256);
			gc.flags |= s->sel.cell.flags &
			    (GRID_FLAG_FG256|GRID_FLAG_BG256);
		}
d948 1
a948 1
	u_int		 	 i, j;
d982 1
a982 1
	u_int		 	 i, j;
d1010 1
a1010 1
	u_int		 	 i, j;
d1430 1
a1430 1
	int			 have_ax, fg_default, bg_default;
d1433 1
a1433 1
	if (tty_same_colours(gc, tc))
d1442 1
a1442 3
	fg_default = tty_is_fg(gc, 8);
	bg_default = tty_is_bg(gc, 8);
	if (fg_default || bg_default) {
d1454 1
a1454 1
			if (fg_default && !tty_is_fg(tc, 8)) {
d1457 1
a1457 1
				else if (!tty_is_fg(tc, 7))
a1459 1
				tc->flags &= ~(GRID_FLAG_FG256|GRID_FLAG_FGRGB);
d1461 1
a1461 1
			if (bg_default && !tty_is_bg(tc, 8)) {
d1464 1
a1464 1
				else if (!tty_is_bg(tc, 0))
a1466 1
				tc->flags &= ~(GRID_FLAG_BG256|GRID_FLAG_BGRGB);
d1472 1
a1472 1
	if (!fg_default && !tty_same_fg(gc, tc))
d1479 1
a1479 1
	if (!bg_default && !tty_same_bg(gc, tc))
d1486 2
a1487 2
	struct grid_cell_rgb	*rgb = &gc->fg_rgb;
	u_int			 colours;
d1490 1
a1490 1
	if (gc->flags & GRID_FLAG_FGRGB) {
d1493 3
a1495 5
			gc->flags &= ~GRID_FLAG_FGRGB;
			gc->flags |= GRID_FLAG_FG256;
			gc->fg = colour_find_rgb(rgb->r, rgb->g, rgb->b);
		}
		else
d1501 1
a1501 1
	if (gc->flags & GRID_FLAG_FG256) {
a1513 1
			gc->flags &= ~GRID_FLAG_FG256;
d1528 2
a1529 2
	struct grid_cell_rgb	*rgb = &gc->bg_rgb;
	u_int			 colours;
d1532 1
a1532 1
	if (gc->flags & GRID_FLAG_BGRGB) {
d1535 3
a1537 5
			gc->flags &= ~GRID_FLAG_BGRGB;
			gc->flags |= GRID_FLAG_BG256;
			gc->bg = colour_find_rgb(rgb->r, rgb->g, rgb->b);
		}
		else
d1543 1
a1543 1
	if (gc->flags & GRID_FLAG_BG256) {
a1556 1
			gc->flags &= ~GRID_FLAG_BG256;
a1569 1
	u_char			 fg = gc->fg;
d1572 4
a1575 13
	tc->flags &= ~(GRID_FLAG_FG256|GRID_FLAG_FGRGB);

	/* Is this a 24-bit colour? */
	if (gc->flags & GRID_FLAG_FGRGB) {
		if (tty_try_rgb(tty, &gc->fg_rgb, "38") == 0)
			goto save_fg;
		/* Should not get here, already converted in tty_check_fg. */
		return;
	}

	/* Is this a 256-colour colour? */
	if (gc->flags & GRID_FLAG_FG256) {
		if (tty_try_256(tty, fg, "38") == 0)
d1582 2
a1583 2
	if (fg >= 90 && fg <= 97) {
		xsnprintf(s, sizeof s, "\033[%dm", fg);
d1589 1
a1589 1
	tty_putcode1(tty, TTYC_SETAF, fg);
d1593 1
a1593 6
	if (gc->flags & GRID_FLAG_FGRGB)
		memcpy(&tc->fg_rgb, &gc->fg_rgb, sizeof tc->fg_rgb);
	else
		tc->fg = fg;
	tc->flags &= ~(GRID_FLAG_FGRGB|GRID_FLAG_FG256);
	tc->flags |= (gc->flags & (GRID_FLAG_FG256|GRID_FLAG_FGRGB));
a1599 1
	u_char			 bg = gc->bg;
d1602 4
a1605 11
	/* Is this a 24-bit colour? */
	if (gc->flags & GRID_FLAG_BGRGB) {
		if (tty_try_rgb(tty, &gc->bg_rgb, "48") == 0)
			goto save_bg;
		/* Should not get here, already converted in tty_check_bg. */
		return;
	}

	/* Is this a 256-colour colour? */
	if (gc->flags & GRID_FLAG_BG256) {
		if (tty_try_256(tty, bg, "48") == 0)
d1612 2
a1613 2
	if (bg >= 90 && bg <= 97) {
		xsnprintf(s, sizeof s, "\033[%dm", bg + 10);
d1619 1
a1619 1
	tty_putcode1(tty, TTYC_SETAB, bg);
d1623 1
a1623 6
	if (gc->flags & GRID_FLAG_BGRGB)
		memcpy(&tc->bg_rgb, &gc->bg_rgb, sizeof tc->bg_rgb);
	else
		tc->bg = bg;
	tc->flags &= ~(GRID_FLAG_BGRGB|GRID_FLAG_BG256);
	tc->flags |= (gc->flags & (GRID_FLAG_BG256|GRID_FLAG_BGRGB));
d1627 1
a1627 1
tty_try_256(struct tty *tty, u_char colour, const char *type)
d1629 1
d1632 8
a1639 6
	/*
	 * If the user has specified -2 to the client, setaf and setab may not
	 * work (or they may not want to use them), so send the usual sequence.
	 */
	if (tty->term_flags & TERM_256COLOURS)
		goto fallback;
d1641 15
a1655 13
	/*
	 * If the terminfo entry has 256 colours and setaf and setab exist,
	 * assume that they work correctly.
	 */
	if (tty->term->flags & TERM_256COLOURS) {
		if (*type == '3') {
			if (!tty_term_has(tty->term, TTYC_SETAF))
				goto fallback;
			tty_putcode1(tty, TTYC_SETAF, colour);
		} else {
			if (!tty_term_has(tty->term, TTYC_SETAB))
				goto fallback;
			tty_putcode1(tty, TTYC_SETAB, colour);
d1657 11
d1673 2
a1674 16
fallback:
	xsnprintf(s, sizeof s, "\033[%s;5;%hhum", type, colour);
	tty_puts(tty, s);
	return (0);
}

int
tty_try_rgb(struct tty *tty, const struct grid_cell_rgb *rgb, const char *type)
{
	char	s[32];

	if (!tty_term_flag(tty->term, TTYC_TC))
		return (-1);

	xsnprintf(s, sizeof s, "\033[%s;2;%hhu;%hhu;%hhum", type, rgb->r,
	    rgb->g, rgb->b);
d1698 2
a1699 2
	if (gc->fg == 8 && !(gc->flags & GRID_FLAG_FG256)) {
		if (pgc->fg != 8 || (pgc->flags & GRID_FLAG_FG256)) {
d1701 1
a1701 3
			gc->flags |= (pgc->flags & GRID_FLAG_FG256);
		} else if (wp == w->active &&
		    (agc->fg != 8 || (agc->flags & GRID_FLAG_FG256))) {
d1703 1
a1703 2
			gc->flags |= (agc->flags & GRID_FLAG_FG256);
		} else {
a1704 2
			gc->flags |= (wgc->flags & GRID_FLAG_FG256);
		}
d1707 2
a1708 2
	if (gc->bg == 8 && !(gc->flags & GRID_FLAG_BG256)) {
		if (pgc->bg != 8 || (pgc->flags & GRID_FLAG_BG256)) {
d1710 1
a1710 3
			gc->flags |= (pgc->flags & GRID_FLAG_BG256);
		} else if (wp == w->active &&
		    (agc->bg != 8 || (agc->flags & GRID_FLAG_BG256))) {
d1712 1
a1712 2
			gc->flags |= (agc->flags & GRID_FLAG_BG256);
		} else {
a1713 2
			gc->flags |= (wgc->flags & GRID_FLAG_BG256);
		}
@


1.202
log
@Send two cub1 instead of using cub for moving the cursor two left. This
is normally better because using cub1 will be ^H^H (so two bytes) but
cub would be ^[[2D (four).
@
text
@d1 1
a1 1
/* $OpenBSD: tty.c,v 1.201 2016/04/30 18:59:02 nicm Exp $ */
d679 2
a680 1
	tty_default_colours(&gc, wp);
d1137 1
a1137 2
	u_int			 cx;
	u_int			 width;
d1139 2
a1140 1
	tty_region_pane(tty, ctx, ctx->orupper, ctx->orlower);
d1447 2
a1448 1
	tty_default_colours(&gc2, wp);
d1798 14
a1811 5
	const struct grid_cell        *agc, *pgc, *wgc;

	if (wp == NULL)
		return;

a1812 2
	agc = options_get_style(wp->window->options, "window-active-style");
	wgc = options_get_style(wp->window->options, "window-style");
d1818 1
a1818 1
		} else if (wp == wp->window->active &&
d1832 1
a1832 1
		} else if (wp == wp->window->active &&
@


1.201
log
@tty_client_ready can not be internal to tty.c again.
@
text
@d1 1
a1 1
/* $OpenBSD: tty.c,v 1.200 2016/03/03 12:58:15 nicm Exp $ */
d1348 1
a1348 1
		if (cx == 0)	{
d1376 5
@


1.200
log
@RGB colours shouldn't be mixed up with aixterm colours, return before
that happens when working out if they are supported.
@
text
@d1 1
a1 1
/* $OpenBSD: tty.c,v 1.199 2016/01/29 11:13:56 nicm Exp $ */
d45 2
d781 1
a781 1
int
@


1.199
log
@Support for RGB colour, using the extended cell mechanism to avoid
wasting unnecessary space. The 'Tc' flag must be set in the external
TERM entry (using terminal-overrides or a custom terminfo entry), if not
tmux will map to the closest of the 256 or 16 colour palettes.

Mostly from Suraj N Kurapati, based on a diff originally by someone else.
@
text
@d1 1
a1 1
/* $OpenBSD: tty.c,v 1.198 2016/01/19 15:59:12 nicm Exp $ */
d1572 2
d1617 2
@


1.198
log
@I no longer use my SourceForge address so replace it.
@
text
@d1 1
a1 1
/* $OpenBSD: tty.c,v 1.197 2015/12/28 14:02:52 nicm Exp $ */
d39 6
d47 1
d71 68
a1500 1
	u_char			 fg = gc->fg, bg = gc->bg, flags = gc->flags;
d1504 1
a1504 2
	if (fg == tc->fg && bg == tc->bg &&
	    ((flags ^ tc->flags) & (GRID_FLAG_FG256|GRID_FLAG_BG256)) == 0)
d1513 2
a1514 2
	fg_default = (fg == 8 && !(flags & GRID_FLAG_FG256));
	bg_default = (bg == 8 && !(flags & GRID_FLAG_BG256));
d1527 1
a1527 2
			if (fg_default &&
			    (tc->fg != 8 || tc->flags & GRID_FLAG_FG256)) {
d1530 1
a1530 2
				else if (tc->fg != 7 ||
				    tc->flags & GRID_FLAG_FG256)
d1533 1
a1533 1
				tc->flags &= ~GRID_FLAG_FG256;
d1535 1
a1535 2
			if (bg_default &&
			    (tc->bg != 8 || tc->flags & GRID_FLAG_BG256)) {
d1538 1
a1538 2
				else if (tc->bg != 0 ||
				    tc->flags & GRID_FLAG_BG256)
d1541 1
a1541 1
				tc->flags &= ~GRID_FLAG_BG256;
d1547 1
a1547 2
	if (!fg_default && (fg != tc->fg ||
	    ((flags & GRID_FLAG_FG256) != (tc->flags & GRID_FLAG_FG256))))
d1554 1
a1554 2
	if (!bg_default && (bg != tc->bg ||
	    ((flags & GRID_FLAG_BG256) != (tc->flags & GRID_FLAG_BG256))))
d1561 2
a1562 1
	u_int	colours;
d1564 9
d1604 2
a1605 1
	u_int	colours;
d1607 9
d1650 10
a1661 1
		/* Try as 256 colours. */
d1664 1
a1664 1
		/* Else already handled by tty_check_fg. */
d1680 6
a1685 3
	tc->fg = fg;
	tc->flags &= ~GRID_FLAG_FG256;
	tc->flags |= gc->flags & GRID_FLAG_FG256;
d1695 8
a1704 1
		/* Try as 256 colours. */
d1707 1
a1707 1
		/* Else already handled by tty_check_bg. */
d1723 6
a1728 3
	tc->bg = bg;
	tc->flags &= ~GRID_FLAG_BG256;
	tc->flags |= gc->flags & GRID_FLAG_BG256;
d1764 14
@


1.197
log
@Couple of trivial style nits.
@
text
@d1 1
a1 1
/* $OpenBSD: tty.c,v 1.196 2015/12/11 16:37:21 nicm Exp $ */
d4 1
a4 1
 * Copyright (c) 2007 Nicholas Marriott <nicm@@users.sourceforge.net>
@


1.196
log
@Style nits and line wrapping of function declarations.
@
text
@d1 1
a1 1
/* $OpenBSD: tty.c,v 1.195 2015/11/23 20:53:09 nicm Exp $ */
d494 1
a494 1
	if (s != NULL && strcmp(s->ccolour, tty->ccolour))
@


1.195
log
@Remove support for the UTF-8 mouse extension. This was a briefly used,
poor idea that was fairly quickly replaced by SGR mouse input (which is
now widespread). It is impossible to tell the difference between UTF-8
and non-UTF-8 mouse input; since the mouse-utf8 option was removed tmux
has not handled it correctly in any case; and it is ridiculous to have
three different forms of mouse input.
@
text
@d1 1
a1 1
/* $OpenBSD: tty.c,v 1.194 2015/11/18 14:27:44 nicm Exp $ */
d51 2
a52 2
void	tty_emulate_repeat(
	    struct tty *, enum tty_code_code, enum tty_code_code, u_int);
d164 2
a165 2
	tty->event = bufferevent_new(
	    tty->fd, tty_read_callback, NULL, tty_error_callback, tty);
d1191 2
a1192 2
tty_region_pane(
    struct tty *tty, const struct tty_ctx *ctx, u_int rupper, u_int rlower)
@


1.194
log
@Use __unused rather than rolling our own.
@
text
@d1 1
a1 1
/* $OpenBSD: tty.c,v 1.193 2015/11/13 08:09:28 nicm Exp $ */
d524 1
a524 1
	if (changed & (ALL_MOUSE_MODES|MODE_MOUSE_UTF8)) {
a526 1
			 * Enable the UTF-8 (1005) extension if configured to.
a531 4
			if (mode & MODE_MOUSE_UTF8)
				tty_puts(tty, "\033[?1005h");
			else
				tty_puts(tty, "\033[?1005l");
a532 1

a541 1

a542 2
			if (tty->mode & MODE_MOUSE_UTF8)
				tty_puts(tty, "\033[?1005l");
@


1.193
log
@Long overdue change to the way we store cells in the grid: now, instead
of storing a full grid_cell with UTF-8 data and everything, store a new
type grid_cell_entry. This can either be the cell itself (for ASCII
cells), or an offset into an extended array (per line) for UTF-8
data.

This avoid a large (8 byte) overhead on non-UTF-8 cells (by far the
majority for most users) without the complexity of the shadow array we
had before. Grid memory without any UTF-8 is about half.

The disadvantage that cells can no longer be modified in place and need
to be copied out of the grid and back but it turned out to be lot less
complicated than I expected.
@
text
@d1 1
a1 1
/* $OpenBSD: tty.c,v 1.192 2015/10/31 13:12:03 nicm Exp $ */
d175 1
a175 1
tty_read_callback(unused struct bufferevent *bufev, void *data)
d184 2
a185 2
tty_error_callback(
    unused struct bufferevent *bufev, unused short what, unused void *data)
d594 1
a594 1
tty_large_region(unused struct tty *tty, const struct tty_ctx *ctx)
@


1.192
log
@The output log is only useful once and it means creating a file, so open
it once at startup instead of in every call to tty_open.
@
text
@d1 1
a1 1
/* $OpenBSD: tty.c,v 1.191 2015/10/27 15:58:43 nicm Exp $ */
d659 1
a659 1
	const struct grid_cell	*gc;
a660 2
	struct grid_cell	 tmpgc;
	struct utf8_data	 ud;
d687 1
a687 1
		gc = grid_view_peek_cell(s->grid, i, py);
d689 2
a690 6
			memcpy(&tmpgc, &s->sel.cell, sizeof tmpgc);
			grid_cell_get(gc, &ud);
			grid_cell_set(&tmpgc, &ud);
			tmpgc.flags = gc->flags &
			    ~(GRID_FLAG_FG256|GRID_FLAG_BG256);
			tmpgc.flags |= s->sel.cell.flags &
d692 2
a693 3
			tty_cell(tty, &tmpgc, wp);
		} else
			tty_cell(tty, gc, wp);
d1074 1
a1074 1
	width = grid_cell_width(ctx->cell);
d1091 1
a1091 1
			cx = screen_size_x(s) - grid_cell_width(&ctx->last_cell);
d1151 1
a1151 2
	struct utf8_data	ud;
	u_int			i;
d1166 2
a1167 3
	grid_cell_get(gc, &ud);
	if (ud.size == 1) {
		if (*ud.data < 0x20 || *ud.data == 0x7f)
d1169 1
a1169 1
		tty_putc(tty, *ud.data);
d1175 1
a1175 1
		for (i = 0; i < ud.width; i++)
d1181 1
a1181 1
	tty_putn(tty, ud.data, ud.size, ud.width);
@


1.191
log
@Move struct options into options.c.
@
text
@d1 1
a1 1
/* $OpenBSD: tty.c,v 1.190 2015/10/23 16:30:15 nicm Exp $ */
d34 2
d64 12
a84 1
	tty->log_fd = -1;
a154 11
	char	out[64];
	int	fd;

	if (debug_level > 3) {
		xsnprintf(out, sizeof out, "tmux-out-%ld.log", (long) getpid());
		fd = open(out, O_WRONLY|O_CREAT|O_TRUNC, 0644);
		if (fd != -1 && fcntl(fd, F_SETFD, FD_CLOEXEC) == -1)
			fatal("fcntl failed");
		tty->log_fd = fd;
	}

a312 5
	if (tty->log_fd != -1) {
		close(tty->log_fd);
		tty->log_fd = -1;
	}

d406 2
a407 2
	if (tty->log_fd != -1)
		write(tty->log_fd, s, strlen(s));
d438 2
a439 2
	if (tty->log_fd != -1)
		write(tty->log_fd, &ch, 1);
d446 2
a447 2
	if (tty->log_fd != -1)
		write(tty->log_fd, buf, len);
@


1.190
log
@Remove some unnecessary checks before free().
@
text
@d1 1
a1 1
/* $OpenBSD: tty.c,v 1.189 2015/10/23 15:52:54 nicm Exp $ */
d232 1
a232 1
		if (options_get_number(&global_options, "focus-events")) {
d460 1
a460 1
		s = options_get_string(&global_options, "default-terminal");
d1689 2
a1690 2
	agc = options_get_style(&wp->window->options, "window-active-style");
	wgc = options_get_style(&wp->window->options, "window-style");
@


1.189
log
@Use tty_term_flag not _has for XT, and make -2 force direct use of
256-colour escape sequences (so setaf/setab can be bypassed if needed).
@
text
@d1 1
a1 1
/* $OpenBSD: tty.c,v 1.188 2015/09/25 23:30:12 nicm Exp $ */
d341 2
a342 4
	if (tty->path != NULL)
		free(tty->path);
	if (tty->termname != NULL)
		free(tty->termname);
@


1.188
log
@If the terminal has colors=256, only try to use setaf/setab if they
exist, reported by Filipe Brandenburger.
@
text
@d1 1
a1 1
/* $OpenBSD: tty.c,v 1.187 2015/09/02 17:43:25 nicm Exp $ */
d231 1
a231 1
	if (tty_term_has(tty->term, TTYC_XT)) {
d296 1
a296 1
	if (tty_term_has(tty->term, TTYC_XT)) {
d1651 7
a1672 7

	/*
	 * If the user has specified -2 to the client, setaf and setab may not
	 * work, so send the usual sequence.
	 */
	if (tty->term_flags & TERM_256COLOURS)
		goto fallback;
@


1.187
log
@A one line helper function is a little silly.
@
text
@d1 1
a1 1
/* $OpenBSD: tty.c,v 1.186 2015/09/02 17:37:54 nicm Exp $ */
d1651 2
a1652 2
	 * If the terminfo entry has 256 colours, assume that setaf and setab
	 * work correctly.
d1655 3
a1657 1
		if (*type == '3')
d1659 3
a1661 1
		else
d1663 1
d1671 2
a1672 5
	if (tty->term_flags & TERM_256COLOURS) {
		xsnprintf(s, sizeof s, "\033[%s;5;%hhum", type, colour);
		tty_puts(tty, s);
		return (0);
	}
d1675 5
@


1.186
log
@We no longer need the terminal service class, so don't bother asking for it.
@
text
@d1 1
a1 1
/* $OpenBSD: tty.c,v 1.185 2015/07/13 15:51:31 nicm Exp $ */
a1713 6
}

void
tty_bell(struct tty *tty)
{
	tty_putcode(tty, TTYC_BEL);
@


1.185
log
@Fix line endings.
@
text
@d1 1
a1 1
/* $OpenBSD: tty.c,v 1.184 2015/07/13 15:49:31 nicm Exp $ */
a235 1
		tty_puts(tty, "\033[c");
a252 8
}

void
tty_set_class(struct tty *tty, u_int class)
{
	if (tty->class != 0)
		return;
	tty->class = class;
@


1.184
log
@Initialize cwd fd to -1 so that we don't close fd 0 if the client is
destroyed before it is changed. Also allow ttyname() to fail. Fixes
problems when running out of file descriptors reported by Bruno Sutic.
@
text
@d1 1
a1 1
/* $OpenBSD: tty.c,v 1.183 2015/05/19 08:48:37 nicm Exp $ */
d62 1
a62 1
int
d67 3
a69 3
	if (!isatty(fd))
		return (-1);

d81 1
a81 1
		return (-1);
d88 2
a89 2

	return (0);
@


1.183
log
@In terminfo, sometimes cvvis implies cnorm and sometimes it doesn't, so
don't assume it does. Fixes missing cursor with emacs-in-tmux-in-tmux.
@
text
@d1 1
a1 1
/* $OpenBSD: tty.c,v 1.182 2015/05/12 22:40:38 nicm Exp $ */
d62 1
a62 1
void
d67 3
d81 1
a81 1
		fatalx("ttyname failed");
d88 2
@


1.182
log
@To replace c0-*, add a high watermark to the pty event, and also backoff
when the any of the ttys the pane is going to write to has buffered
enough data.
@
text
@d1 1
a1 1
/* $OpenBSD: tty.c,v 1.181 2015/05/06 07:52:06 nicm Exp $ */
d510 11
a520 8
	if (changed & (MODE_CURSOR|MODE_BLINKING)) {
		if (mode & MODE_CURSOR) {
			if (mode & MODE_BLINKING &&
			    tty_term_has(tty->term, TTYC_CVVIS))
				tty_putcode(tty, TTYC_CVVIS);
			else
				tty_putcode(tty, TTYC_CNORM);
		} else
@


1.181
log
@Turn cursor off during redraw, pointed out by George Nachman.
@
text
@d1 1
a1 1
/* $OpenBSD: tty.c,v 1.180 2015/04/29 15:59:08 nicm Exp $ */
d726 14
d741 2
a742 2
tty_write(
    void (*cmdfn)(struct tty *, const struct tty_ctx *), struct tty_ctx *ctx)
d757 1
a757 7
		if (c->session == NULL || c->tty.term == NULL)
			continue;
		if (c->flags & CLIENT_SUSPENDED)
			continue;
		if (c->tty.flags & TTY_FREEZE)
			continue;
		if (c->session->curw->window != wp->window)
@


1.180
log
@If default-terminal is set to "screen" or "screen-*", emulate screen's
historical (incorrect) behaviour for SGR 3 and send smso
(standout). Previously, we would send sitm (italics) if the terminal
outside had it and smso otherwise. This was acceptably until recently
because xterm's terminfo entry lacked sitm, so most users got smso.

People who want italics should set default-terminal to the forthcoming
"tmux" entry (and be prepared to deal with it being missing on older
hosts).

As a side-effect this changes default-terminal to be a server rather
than a session option.

suggested by and ok naddy
@
text
@d1 1
a1 1
/* $OpenBSD: tty.c,v 1.179 2015/04/25 15:57:48 nicm Exp $ */
d503 1
a503 1
	if (strcmp(s->ccolour, tty->ccolour))
d520 1
a520 1
	if (tty->cstyle != s->cstyle) {
d670 1
d672 3
a674 1
	tty_update_mode(tty, tty->mode & ~MODE_CURSOR, s);
d709 11
a719 3
	if (sx >= tty->sx) {
		tty_update_mode(tty, tty->mode, s);
		return;
a720 1
	tty_attributes(tty, &grid_default_cell, wp);
d722 1
a722 6
	tty_cursor(tty, ox + sx, oy + py);
	if (sx != screen_size_x(s) && ox + screen_size_x(s) >= tty->sx &&
	    tty_term_has(tty->term, TTYC_EL) && !tty_fake_bce(tty, wp))
		tty_putcode(tty, TTYC_EL);
	else
		tty_repeat_space(tty, screen_size_x(s) - sx);
@


1.179
log
@Explicitly cancel mouse "button" mode, this happens implicitly with some
one of the other things we send with xterm, but not with urxvt. Reported
by sthen@@.
@
text
@d1 1
a1 1
/* $OpenBSD: tty.c,v 1.178 2015/04/24 23:17:11 nicm Exp $ */
d37 1
d461 15
d1415 2
a1416 6
	if (changed & GRID_ATTR_ITALICS) {
		if (tty_term_has(tty->term, TTYC_SITM))
			tty_putcode(tty, TTYC_SITM);
		else
			tty_putcode(tty, TTYC_SMSO);
	}
@


1.178
log
@Convert clients list into a TAILQ.
@
text
@d1 1
a1 1
/* $OpenBSD: tty.c,v 1.177 2015/04/19 21:34:21 nicm Exp $ */
d223 1
a223 1
		tty_puts(tty, "\033[?1000l\033[?1006l\033[?1005l");
d297 1
a297 1
		tty_raw(tty, "\033[?1000l\033[?1006l\033[?1005l");
@


1.177
log
@Rewrite of tmux mouse support which was a mess. Instead of having
options for "mouse-this" and "mouse-that", mouse events may be bound as
keys and there is one option "mouse" that turns on mouse support
entirely (set -g mouse on).

See the new MOUSE SUPPORT section of the man page for description of the
key names and new flags (-t= to specify the pane or window under mouse
as a target, and send-keys -M to pass through a mouse event).

The default builtin bindings for the mouse are:

    bind -n   MouseDown1Pane select-pane -t=; send-keys -M
    bind -n MouseDown1Status select-window -t=
    bind -n   MouseDrag1Pane copy-mode -M
    bind -n MouseDrag1Border resize-pane -M

To get the effect of turning mode-mouse off, do:

    unbind -n MouseDrag1Pane
    unbind -temacs-copy MouseDrag1Pane

The old mouse options are now gone, set-option -q may be used to
suppress warnings if mixing configuration files.
@
text
@d1 1
a1 1
/* $OpenBSD: tty.c,v 1.176 2015/04/19 21:05:27 nicm Exp $ */
a710 1
	u_int		 	 i;
d721 2
a722 3
	for (i = 0; i < ARRAY_LENGTH(&clients); i++) {
		c = ARRAY_ITEM(&clients, i);
		if (c == NULL || c->session == NULL || c->tty.term == NULL)
@


1.176
log
@Support setting the default window and pane background colours (window
and active pane via window-style and window-active-style options, an
individual pane by a new select-pane -P flag). From J Raynor.
@
text
@d1 1
a1 1
/* $OpenBSD: tty.c,v 1.175 2015/04/15 22:34:46 nicm Exp $ */
d244 4
@


1.175
log
@Fix some issues in bright colour handling. Bold background doesn't exist
so there is no reason for tty_check_bg to mess with the BRIGHT flag at
all, ever. Also use aixterm colours for 256-to-16 translation if the
terminal supports them. And there is no reason for tty_colours_bg to
worry about whether the terminal supports them - tty_check_bg has
already taken care of it.
@
text
@d1 1
a1 1
/* $OpenBSD: tty.c,v 1.174 2015/04/15 22:10:13 nicm Exp $ */
d46 1
d51 3
a53 1
void	tty_cell(struct tty *, const struct grid_cell *);
d588 17
d627 1
a627 1
			tty_draw_line(tty, s, i, ctx->xoff, ctx->yoff);
d630 1
a630 1
			tty_draw_line(tty, s, i, ctx->xoff, ctx->yoff);
d635 9
a643 1
tty_draw_line(struct tty *tty, struct screen *s, u_int py, u_int ox, u_int oy)
d681 1
a681 1
			tty_cell(tty, &tmpgc);
d683 1
a683 1
			tty_cell(tty, gc);
d690 1
a690 1
	tty_reset(tty);
d694 1
a694 1
	    tty_term_has(tty->term, TTYC_EL))
d744 1
a744 1
		tty_draw_line(tty, wp->screen, ctx->ocy, ctx->xoff, ctx->yoff);
d748 1
a748 1
	tty_reset(tty);
d752 2
a753 2
	if (tty_term_has(tty->term, TTYC_ICH) ||
	    tty_term_has(tty->term, TTYC_ICH1))
d756 1
a756 1
		tty_draw_line(tty, wp->screen, ctx->ocy, ctx->xoff, ctx->yoff);
d764 1
a764 1
	if (!tty_pane_full_width(tty, ctx) ||
d767 1
a767 1
		tty_draw_line(tty, wp->screen, ctx->ocy, ctx->xoff, ctx->yoff);
d771 1
a771 1
	tty_reset(tty);
d785 1
a785 1
	tty_reset(tty);
d789 1
a789 1
	if (tty_term_has(tty->term, TTYC_ECH))
d800 1
a800 1
	if (!tty_pane_full_width(tty, ctx) ||
d807 1
a807 1
	tty_reset(tty);
d818 1
a818 1
	if (!tty_pane_full_width(tty, ctx) ||
d825 1
a825 1
	tty_reset(tty);
d839 1
a839 1
	tty_reset(tty);
d843 2
a844 1
	if (tty_pane_full_width(tty, ctx) && tty_term_has(tty->term, TTYC_EL))
d856 1
a856 1
	tty_reset(tty);
d860 2
a861 1
	if (tty_pane_full_width(tty, ctx) && tty_term_has(tty->term, TTYC_EL))
d870 1
a870 1
	tty_reset(tty);
d872 2
a873 1
	if (ctx->xoff == 0 && tty_term_has(tty->term, TTYC_EL1)) {
d888 1
a888 1
	if (!tty_pane_full_width(tty, ctx) ||
d895 1
a895 1
	tty_reset(tty);
d911 1
a911 1
	if (!tty_pane_full_width(tty, ctx) ||
d928 1
a928 1
	tty_reset(tty);
d943 1
a943 1
	tty_reset(tty);
d948 2
a949 1
	if (tty_pane_full_width(tty, ctx) && tty_term_has(tty->term, TTYC_EL)) {
d977 1
a977 1
	tty_reset(tty);
d982 2
a983 1
	if (tty_pane_full_width(tty, ctx) && tty_term_has(tty->term, TTYC_EL)) {
d1005 1
a1005 1
	tty_reset(tty);
d1010 2
a1011 1
	if (tty_pane_full_width(tty, ctx) && tty_term_has(tty->term, TTYC_EL)) {
d1034 1
a1034 1
	tty_reset(tty);
d1075 1
a1075 1
			tty_cell(tty, &ctx->last_cell);
d1080 1
a1080 1
	tty_cell(tty, ctx->cell);
d1092 1
a1092 1
	tty_draw_line(tty, wp->screen, ctx->ocy, ctx->xoff, ctx->yoff);
d1125 1
a1125 1
	tty_reset(tty);
d1130 2
a1131 1
tty_cell(struct tty *tty, const struct grid_cell *gc)
d1146 1
a1146 1
	tty_attributes(tty, gc);
d1350 2
a1351 1
tty_attributes(struct tty *tty, const struct grid_cell *gc)
d1357 1
d1647 41
@


1.174
log
@Use tty_term_flag not _has for flags, also fix a typo (position not
permission).
@
text
@d1 1
a1 1
/* $OpenBSD: tty.c,v 1.173 2015/02/05 11:46:57 nicm Exp $ */
d1456 2
d1466 4
a1469 1
				gc->attr |= GRID_ATTR_BRIGHT;
a1477 1
	colours = tty_term_number(tty->term, TTYC_COLORS);
d1489 2
d1501 1
a1501 1
			if (gc->bg & 8)
d1503 3
a1505 1
			gc->attr &= ~GRID_ATTR_BRIGHT;
d1512 1
a1512 2
	colours = tty_term_number(tty->term, TTYC_COLORS);
	if (gc->bg >= 90 && gc->bg <= 97 && colours < 16) {
a1513 2
		gc->attr |= GRID_ATTR_BRIGHT;
	}
d1567 3
a1569 8
		/* 16 colour terminals or above only. */
		if (tty_term_number(tty->term, TTYC_COLORS) >= 16) {
			xsnprintf(s, sizeof s, "\033[%dm", bg + 10);
			tty_puts(tty, s);
			goto save_bg;
		}
		bg -= 90;
		/* no such thing as a bold background */
@


1.173
log
@Reset bracket paste mode on detach.
@
text
@d1 1
a1 1
/* $OpenBSD: tty.c,v 1.172 2015/01/30 12:33:03 nicm Exp $ */
d632 1
a632 1
	 * Don't move the cursor to the start permission if it will wrap there
d1410 1
a1410 1
		have_ax = tty_term_has(tty->term, TTYC_AX);
@


1.172
log
@Focus off needs to be sent with tty_raw, reported by Geoff Nixon.
@
text
@d1 1
a1 1
/* $OpenBSD: tty.c,v 1.171 2015/01/20 08:18:04 nicm Exp $ */
d284 2
@


1.171
log
@Support blinking cursor mode, both the xterm CSI ?12 h/l and (the
backwards) screen CSI 34 h/l. From Guanpeng Xu.
@
text
@d1 1
a1 1
/* $OpenBSD: tty.c,v 1.170 2014/08/09 07:33:37 nicm Exp $ */
d293 1
a293 1
			tty_puts(tty, "\033[?1004l");
@


1.170
log
@Remove support for the continuous reporting "any" mouse mode which never
really worked properly and is rarely used.
@
text
@d1 1
a1 1
/* $OpenBSD: tty.c,v 1.169 2014/04/25 12:45:16 jsg Exp $ */
d485 8
a492 4
	if (changed & MODE_CURSOR) {
		if (mode & MODE_CURSOR)
			tty_putcode(tty, TTYC_CNORM);
		else
@


1.169
log
@specifying ECHOCTL once is enough
ok nicm@@
@
text
@d1 1
a1 1
/* $OpenBSD: tty.c,v 1.168 2014/04/17 14:45:49 nicm Exp $ */
d516 1
a516 3
			if (mode & MODE_MOUSE_ANY)
				tty_puts(tty, "\033[?1003h");
			else if (mode & MODE_MOUSE_BUTTON)
d521 1
a521 3
			if (tty->mode & MODE_MOUSE_ANY)
				tty_puts(tty, "\033[?1003l");
			else if (tty->mode & MODE_MOUSE_BUTTON)
@


1.168
log
@Some more long lines.
@
text
@d1 1
a1 1
/* $OpenBSD: tty.c,v 1.167 2014/04/17 12:57:28 nicm Exp $ */
d196 1
a196 1
	    ECHOPRT|ECHOKE|ECHOCTL|ISIG);
@


1.167
log
@Wrap some long lines.
@
text
@d1 1
a1 1
/* $OpenBSD: tty.c,v 1.166 2014/02/23 00:53:06 nicm Exp $ */
d551 2
a552 2
tty_emulate_repeat(
    struct tty *tty, enum tty_code_code code, enum tty_code_code code1, u_int n)
@


1.166
log
@Change terminal-overrides to a server option (now that we have them), it
doesn't make much sense as a session option.
@
text
@d1 1
a1 1
/* $OpenBSD: tty.c,v 1.165 2014/02/14 14:37:08 nicm Exp $ */
d391 2
a392 1
tty_putcode_ptr2(struct tty *tty, enum tty_code_code code, const void *a, const void *b)
@


1.165
log
@If the terminfo entry has colors#256, assume that setaf and setab work
and use them for the 256 colour set. If the terminfo entry doesn't have
colors#256 and the user gives -2 to the client, use a \033[38;5;Xm
sequence as before. Should allow fbterm to work with it's weird setaf
and setab.
@
text
@d1 1
a1 1
/* $OpenBSD: tty.c,v 1.164 2014/01/28 23:07:09 nicm Exp $ */
d131 1
a131 1
tty_open(struct tty *tty, const char *overrides, char **cause)
d144 1
a144 1
	tty->term = tty_term_find(tty->termname, tty->fd, overrides, cause);
@


1.164
log
@Allow replacing each of the many sets of separate foo-{fg,bg,attr}
options with a single foo-style option. For example:

    set -g status-fg yellow
    set -g status-bg red
    set -g status-attr blink

Becomes:

    set -g status-style fg=yellow,bg=red,blink

The -a flag to set can be used to add to rather than replace a style. So:

    set -g status-bg red

Becomes:

    set -ag status-style bg=red

Currently this is fully backwards compatible (all *-{fg,bg,attr} options
remain) but the plan is to deprecate them over time.

From Tiago Cunha.
@
text
@d1 1
a1 1
/* $OpenBSD: tty.c,v 1.163 2013/10/20 09:37:50 nicm Exp $ */
d1584 21
a1604 3
	if (!(tty->term->flags & TERM_256COLOURS) &&
	    !(tty->term_flags & TERM_256COLOURS))
		return (-1);
d1606 1
a1606 3
	xsnprintf(s, sizeof s, "\033[%s;5;%hhum", type, colour);
	tty_puts(tty, s);
	return (0);
@


1.163
log
@Don't turn on modifyOtherKeys by default, it is annoying if tmux is
killed and it's left on and we can't turn it on and off like we do for
attributes. It's not hard to enable in .Xresources or .Xdefaults anyway.
@
text
@d1 1
a1 1
/* $OpenBSD: tty.c,v 1.162 2013/06/23 13:10:48 nicm Exp $ */
d1357 1
a1357 2
	if (changed & GRID_ATTR_ITALICS)
	{
@


1.162
log
@Focus events can cause trouble if left on and they can't be turned off
during idle periods (like the other states are) because we'd miss
events. So add a server option to control them. Defaults to off.
@
text
@d1 1
a1 1
/* $OpenBSD: tty.c,v 1.160 2013/06/02 07:52:15 nicm Exp $ */
d227 1
a227 1
		tty_puts(tty, "\033[c\033[>4;1m\033[m");
a294 1
		tty_raw(tty, "\033[>4m\033[m");
@


1.161
log
@revert r1.156 "Add support for focus notifications when tmux pane changes"
beck@@ found annoying beeps if a machine was shutdown while tmux is running
and you then focus in/out of an xterm; kettenis tracked it down to 1.156.
@
text
@d1 1
a1 1
/* $OpenBSD: tty.c,v 1.156 2013/03/24 09:18:16 nicm Exp $ */
d222 5
a226 1
	if (tty_term_has(tty->term, TTYC_XT))
d228 1
d290 5
a294 1
	if (tty_term_has(tty->term, TTYC_XT))
d296 1
@


1.160
log
@The actual terminfo entries we ended up with for cursor changes are Cs,
Ce, Ss and Se (not Cc, Ce, Cs, Csr). So use and document these instead
of the ones we were using earlier.
@
text
@d1 1
a1 1
/* $OpenBSD: tty.c,v 1.159 2013/04/11 07:27:27 nicm Exp $ */
d223 1
a223 1
		tty_puts(tty, "\033[c\033[>4;1m\033[?1004h\033[m");
d286 1
a286 1
		tty_raw(tty, "\033[>4m\033[?1004l\033[m");
@


1.159
log
@Send an SGR0 after turning on modifyOtherKeys to fix Terminal.app which
treats \033[>4;1m and \033[4;1m (bold+underline). Reported & tested by
otto@@.
@
text
@d1 1
a1 1
/* $OpenBSD: tty.c,v 1.158 2013/03/27 11:17:12 nicm Exp $ */
d273 3
a275 3
	if (tty_term_has(tty->term, TTYC_CS1) && tty->cstyle != 0) {
		if (tty_term_has(tty->term, TTYC_CSR1))
			tty_raw(tty, tty_term_string(tty->term, TTYC_CSR1));
d277 1
a277 1
			tty_raw(tty, tty_term_string1(tty->term, TTYC_CS1, 0));
d458 1
a458 1
		tty_putcode_ptr1(tty, TTYC_CC, ccolour);
d482 1
a482 1
		if (tty_term_has(tty->term, TTYC_CS1)) {
d484 2
a485 2
			    tty_term_has(tty->term, TTYC_CSR1))
				tty_putcode(tty, TTYC_CSR1);
d487 1
a487 1
				tty_putcode1(tty, TTYC_CS1, s->cstyle);
@


1.158
log
@Remove tmux's (already minimal) 88 colour support. Such terminals are
few and unnecessary.
@
text
@d1 1
a1 1
/* $OpenBSD: tty.c,v 1.157 2013/03/24 09:29:00 nicm Exp $ */
d223 1
a223 1
		tty_puts(tty, "\033[c\033[>4;1m\033[?1004h");
d286 1
a286 1
		tty_raw(tty, "\033[>4m\033[?1004l");
@


1.157
log
@Handle focus events from the terminal, from Aaron Jensen.
@
text
@d1 1
a1 1
/* $OpenBSD: tty.c,v 1.156 2013/03/24 09:18:16 nicm Exp $ */
a37 1
int	tty_try_88(struct tty *, u_char, const char *);
d1448 1
a1448 3
		if (!(tty->term->flags & TERM_88COLOURS) &&
		    !(tty->term_flags & TERM_88COLOURS) &&
		    !(tty->term->flags & TERM_256COLOURS) &&
d1481 1
a1481 3
		if (!(tty->term->flags & TERM_88COLOURS) &&
		    !(tty->term_flags & TERM_88COLOURS) &&
		    !(tty->term->flags & TERM_256COLOURS) &&
d1509 1
a1509 1
		/* Try as 256 colours or translating to 88. */
a1511 2
		if (tty_try_88(tty, fg, "38") == 0)
			goto save_fg;
d1542 1
a1542 1
		/* Try as 256 colours or translating to 88. */
a1544 2
		if (tty_try_88(tty, bg, "48") == 0)
			goto save_bg;
a1578 15

	xsnprintf(s, sizeof s, "\033[%s;5;%hhum", type, colour);
	tty_puts(tty, s);
	return (0);
}

int
tty_try_88(struct tty *tty, u_char colour, const char *type)
{
	char	s[32];

	if (!(tty->term->flags & TERM_88COLOURS) &&
	    !(tty->term_flags & TERM_88COLOURS))
		return (-1);
	colour = colour_256to88(colour);
@


1.156
log
@Add support for focus notifications when tmux pane changes, based on
work by Aaron Jensen.
@
text
@d1 1
a1 1
/* $OpenBSD: tty.c,v 1.155 2013/03/22 10:40:22 nicm Exp $ */
d224 1
a224 1
		tty_puts(tty, "\033[c\033[>4;1m\033[?1004l");
d287 1
a287 1
		tty_raw(tty, "\033[>4m");
@


1.155
log
@Use tty_raw on stop, not tty_puts.
@
text
@d1 1
a1 1
/* $OpenBSD: tty.c,v 1.154 2013/03/22 10:34:46 nicm Exp $ */
d224 1
a224 1
		tty_puts(tty, "\033[c\033[>4;1m");
@


1.154
log
@Correctly handle UTF8 mouse option being toggled, from Egmont Koblinger.
@
text
@d1 1
a1 1
/* $OpenBSD: tty.c,v 1.153 2013/03/22 10:33:50 nicm Exp $ */
d287 1
a287 1
		tty_puts(tty, "\033[>4m");
@


1.153
log
@Support the latest theory for mouse input, this is enabled/disabled with
SM/RM 1006 and is similar in style to SGR input: \033[<b;x;yM or
\033[b;x;ym. From Egmont Koblinger.
@
text
@d1 1
a1 1
/* $OpenBSD: tty.c,v 1.152 2013/03/22 10:31:22 nicm Exp $ */
d492 1
a492 1
	if (changed & ALL_MOUSE_MODES) {
d503 2
@


1.152
log
@No more lint means no more ARGSUSED.
@
text
@d1 1
a1 1
/* $OpenBSD: tty.c,v 1.151 2013/03/22 10:30:04 nicm Exp $ */
d221 1
a221 1
		tty_puts(tty, "\033[?1000l");
d284 1
a284 1
		tty_raw(tty, "\033[?1000l");
d494 7
d503 2
d518 2
@


1.151
log
@In terminals with XT, turn on modifyOtherKeys=1 with the escape sequence
and handle the most common set. Pass them through if xterm-keys is on.
@
text
@d1 1
a1 1
/* $OpenBSD: tty.c,v 1.150 2013/03/22 10:29:31 nicm Exp $ */
a163 1
/* ARGSUSED */
a172 1
/* ARGSUSED */
@


1.150
log
@I strongly suspect it is possible for tmux to block on detach in
tty_raw, so make the fd blocking again much later and have tty_raw just
retry the write a few times.
@
text
@d1 1
a1 1
/* $OpenBSD: tty.c,v 1.149 2013/03/21 18:44:47 nicm Exp $ */
d226 1
a226 1
		tty_puts(tty, "\033[c");
d287 3
@


1.149
log
@Include the \033 in the key tree and adjust key matching for this change.
@
text
@d1 1
a1 1
/* $OpenBSD: tty.c,v 1.148 2013/03/21 16:50:22 nicm Exp $ */
a269 2
	setblocking(tty->fd, 1);

d289 2
d335 15
a349 1
	write(tty->fd, s, strlen(s));
@


1.148
log
@Tidy by splitting default key tables into two.
@
text
@d1 1
a1 1
/* $OpenBSD: tty.c,v 1.147 2013/01/18 02:16:21 nicm Exp $ */
d152 1
a152 1
	tty->flags &= ~(TTY_NOCURSOR|TTY_FREEZE|TTY_ESCAPE);
@


1.147
log
@Rather than having two grids for each pane, one for ASCII and one for
UTF-8, collapse the two together. Simplifies the code at the expense of
more memory (which can probably be reduced again later).
@
text
@d1 1
a1 1
/* $OpenBSD: tty.c,v 1.146 2013/01/15 23:18:55 nicm Exp $ */
d159 1
a159 1
	tty_keys_init(tty);
@


1.146
log
@Implement ECH (erase character, CSI X). Reported by Christian Neukirchen.
@
text
@d1 1
a1 1
/* $OpenBSD: tty.c,v 1.145 2012/11/22 14:41:11 nicm Exp $ */
d51 1
a51 2
void	tty_cell(struct tty *,
	    const struct grid_cell *, const struct grid_utf8 *);
d418 1
a418 1
tty_pututf8(struct tty *tty, const struct grid_utf8 *gu)
d420 1
a420 4
	size_t	size;

	size = grid_utf8_size(gu);
	bufferevent_write(tty->event, gu->data, size);
d422 2
a423 2
		write(tty->log_fd, gu->data, size);
	tty->cx += gu->width;
d581 1
a581 1
	const struct grid_utf8	*gu;
a605 5

		gu = NULL;
		if (gc->flags & GRID_FLAG_UTF8)
			gu = grid_view_peek_utf8(s->grid, i, py);

d608 2
a609 1
			tmpgc.data = gc->data;
d614 1
a614 1
			tty_cell(tty, &tmpgc, gu);
d616 1
a616 1
			tty_cell(tty, gc, gu);
a978 7
	const struct grid_cell	*gc = ctx->cell;
	const struct grid_utf8	*gu = ctx->utf8;

	if (gc->flags & GRID_FLAG_UTF8)
		width = gu->width;
	else
		width = 1;
d983 1
d1000 1
a1000 4
			if (ctx->last_cell.flags & GRID_FLAG_UTF8)
				cx = screen_size_x(s) - ctx->last_utf8.width;
			else
				cx = screen_size_x(s) - 1;
d1002 1
a1002 1
			tty_cell(tty, &ctx->last_cell, &ctx->last_utf8);
d1007 1
a1007 1
	tty_cell(tty, ctx->cell, ctx->utf8);
d1057 1
a1057 2
tty_cell(
    struct tty *tty, const struct grid_cell *gc, const struct grid_utf8 *gu)
d1059 2
a1060 1
	u_int	i;
d1074 4
a1077 3
	/* If not UTF-8, write directly. */
	if (!(gc->flags & GRID_FLAG_UTF8)) {
		if (gc->data < 0x20 || gc->data == 0x7f)
d1079 1
a1079 1
		tty_putc(tty, gc->data);
d1083 1
a1083 1
	/* If the terminal doesn't support UTF-8, write underscores. */
d1085 1
a1085 1
		for (i = 0; i < gu->width; i++)
d1090 2
a1091 2
	/* Otherwise, write UTF-8. */
	tty_pututf8(tty, gu);
@


1.145
log
@Put helper function back, will be needed in a bit.
@
text
@d1 1
a1 1
/* $OpenBSD: tty.c,v 1.144 2012/11/22 14:26:04 nicm Exp $ */
d719 17
@


1.144
log
@Instead of worrying about xterm version, send DA and read DEC service
class which is more likely to be useful. Not used for anything yet
anyway.
@
text
@d1 1
a1 1
/* $OpenBSD: tty.c,v 1.143 2012/11/22 14:10:53 nicm Exp $ */
d240 8
@


1.143
log
@Don't need to send DECSL on detaching now, the code using higher levels
has gone.
@
text
@d1 1
a1 1
/* $OpenBSD: tty.c,v 1.142 2012/09/29 06:57:56 nicm Exp $ */
d227 1
a227 1
		tty_puts(tty, "\033[>c");
a239 8
}

void
tty_set_version(struct tty *tty, u_int version)
{
	if (tty->xterm_version != 0)
		return;
	tty->xterm_version = version;
@


1.142
log
@Do not test client flags against TTY_FREEZE bit, reported by Tom Ryder.
@
text
@d1 1
a1 1
/* $OpenBSD: tty.c,v 1.141 2012/09/05 09:59:41 nicm Exp $ */
a291 3

	if (tty->xterm_version > 270)
		tty_raw(tty, "\033[61;1\"p");
@


1.141
log
@We can't tell what the terminal has done with a DCS string, so reset the
cursor and attributes afterwards.
@
text
@d1 1
a1 1
/* $OpenBSD: tty.c,v 1.140 2012/09/03 15:47:40 nicm Exp $ */
d666 3
a668 1
		if (c->flags & (CLIENT_SUSPENDED|TTY_FREEZE))
@


1.140
log
@Remove xterm CRA support - support is patchy and it will be done better
using margins.
@
text
@d1 1
a1 1
/* $OpenBSD: tty.c,v 1.139 2012/08/14 08:58:25 nicm Exp $ */
d1049 6
@


1.139
log
@Tidy up tty_write, from Sean Estabrooks.
@
text
@d1 1
a1 1
/* $OpenBSD: tty.c,v 1.138 2012/07/10 11:53:01 nicm Exp $ */
a46 4
void	tty_cra_pane(struct tty *,
    const struct tty_ctx *, u_int, u_int, u_int, u_int, u_int, u_int);
void	tty_era_pane(struct tty *,
    const struct tty_ctx *, u_int, u_int, u_int, u_int);
a55 2
#define tty_use_rect(tty) \
	((tty)->xterm_version > 270)
a247 13

	if (tty->xterm_version > 270) {
		tty_puts(tty, "\033[65;1\"p");

		tty_putcode(tty, TTYC_RMACS);
		memcpy(&tty->cell, &grid_default_cell, sizeof tty->cell);

		tty->cx = UINT_MAX;
		tty->cy = UINT_MAX;

		tty->rupper = UINT_MAX;
		tty->rlower = UINT_MAX;
	}
a680 32
tty_cra_pane(struct tty *tty, const struct tty_ctx *ctx,
    u_int t, u_int l, u_int b, u_int r, u_int tt, u_int tl)
{
	char	 tmp[64];

	snprintf(tmp, sizeof tmp,
		 "\033[%u;%u;%u;%u;1;%u;%u;1$v",
		 ctx->yoff + t + 1,
		 ctx->xoff + l + 1,
		 ctx->yoff + b + 1,
		 ctx->xoff + r + 1,
		 ctx->yoff + tt + 1,
		 ctx->xoff + tl + 1);
	tty_puts(tty, tmp);
}

void
tty_era_pane(struct tty *tty, const struct tty_ctx *ctx,
    u_int t, u_int l, u_int b, u_int r)
{
	char	 tmp[64];

	snprintf(tmp, sizeof tmp,
		 "\033[%u;%u;%u;%u$z",
		 ctx->yoff + t + 1,
		 ctx->xoff + l + 1,
		 ctx->yoff + b + 1,
		 ctx->xoff + r + 1);
	tty_puts(tty, tmp);
}

void
a828 1
	struct screen		*s = wp->screen;
d837 1
a837 6
		else if (tty_use_rect(tty)) {
			tty_cra_pane (tty, ctx, ctx->orupper + 1, 0,
			    ctx->orlower, screen_size_x(s) - 1,
			    ctx->orupper, 0);
			tty_cmd_clearline(tty, ctx);
		} else
@


1.138
log
@xfree is not particularly helpful, remove it. From Thomas Adam.
@
text
@d1 1
a1 1
/* $OpenBSD: tty.c,v 1.137 2012/06/20 12:55:55 nicm Exp $ */
a669 1
	struct session		*s;
d683 1
a683 1
		if (c == NULL || c->session == NULL)
d685 3
a687 1
		if (c->flags & CLIENT_SUSPENDED)
a688 1
		s = c->session;
d690 4
a693 10
		if (s->curw->window == wp->window) {
			if (c->tty.term == NULL)
				continue;
			if (c->tty.flags & TTY_FREEZE)
				continue;

			ctx->xoff = wp->xoff;
			ctx->yoff = wp->yoff;
			if (status_at_line(c) == 0)
				ctx->yoff++;
d695 1
a695 2
			cmdfn(&c->tty, ctx);
		}
@


1.137
log
@Remove a couple of unused variables from redbrain at gcc dot gnu dot org.
@
text
@d1 1
a1 1
/* $OpenBSD: tty.c,v 1.136 2012/05/22 14:32:28 nicm Exp $ */
d348 1
a348 1
	xfree(tty->ccolour);
d350 1
a350 1
		xfree(tty->path);
d352 1
a352 1
		xfree(tty->termname);
d471 1
a471 1
	xfree(tty->ccolour);
d1102 1
a1102 1
	xfree(buf);
@


1.136
log
@Store client in tty struct directly instead of using a callback function
pointer.
@
text
@d1 1
a1 1
/* $OpenBSD: tty.c,v 1.135 2012/05/22 09:37:54 nicm Exp $ */
a670 1
	struct options		*oo;
a694 1
			oo = &s->options;
@


1.135
log
@Use tty_pane_full_width macro in some more places.
@
text
@d1 1
a1 1
/* $OpenBSD: tty.c,v 1.134 2012/05/22 09:36:12 nicm Exp $ */
d67 1
a67 1
tty_init(struct tty *tty, int fd, char *term)
d79 1
@


1.134
log
@If there are any terminals with insert mode but not ich1, they can go
through the slow path. Tidies code slightly.
@
text
@d1 1
a1 1
/* $OpenBSD: tty.c,v 1.133 2012/05/22 09:09:16 nicm Exp $ */
a742 1
	struct screen		*s = wp->screen;
d744 1
a744 1
	if (ctx->xoff != 0 || screen_size_x(s) < tty->sx) {
a763 1
	struct screen		*s = wp->screen;
d765 1
a765 1
	if (ctx->xoff != 0 || screen_size_x(s) < tty->sx ||
@


1.133
log
@Move some common code to repeat spaces into a function.
@
text
@d1 1
a1 1
/* $OpenBSD: tty.c,v 1.132 2012/05/05 18:45:55 nicm Exp $ */
d757 1
a757 6
	else if (tty_term_has(tty->term, TTYC_SMIR) &&
	    tty_term_has(tty->term, TTYC_RMIR)) {
		tty_putcode(tty, TTYC_SMIR);
		tty_repeat_space(tty, ctx->num);
		tty_putcode(tty, TTYC_RMIR);
	} else
@


1.132
log
@Tidy up by adding a macro for the pane being the full screen width, from
Ailin Nemui.
@
text
@d1 1
a1 1
/* $OpenBSD: tty.c,v 1.131 2012/05/05 18:31:09 nicm Exp $ */
d54 1
d550 7
d658 2
a659 4
	else {
		for (i = sx; i < screen_size_x(s); i++)
			tty_putc(tty, ' ');
	}
a743 1
	u_int			 i;
d760 1
a760 2
		for (i = 0; i < ctx->num; i++)
			tty_putc(tty, ' ');
a828 1
	u_int		 	 i;
d834 1
a834 1
	if (tty_pane_full_width(tty, ctx) && tty_term_has(tty->term, TTYC_EL)) {
d836 2
a837 4
	} else {
		for (i = 0; i < screen_size_x(s); i++)
			tty_putc(tty, ' ');
	}
a844 1
	u_int		 	 i;
d852 2
a853 4
	else {
		for (i = ctx->ocx; i < screen_size_x(s); i++)
			tty_putc(tty, ' ');
	}
a858 2
	u_int 	 i;

d866 1
a866 2
		for (i = 0; i < ctx->ocx + 1; i++)
			tty_putc(tty, ' ');
d955 1
a955 2
		for (i = ctx->ocx; i < screen_size_x(s); i++)
			tty_putc(tty, ' ');
d958 1
a958 2
			for (i = 0; i < screen_size_x(s); i++)
				tty_putc(tty, ' ');
d984 1
a984 2
			for (i = 0; i < screen_size_x(s); i++)
				tty_putc(tty, ' ');
d987 1
a987 2
	for (i = 0; i <= ctx->ocx; i++)
		tty_putc(tty, ' ');
d1013 1
a1013 2
			for (i = 0; i < screen_size_x(s); i++)
				tty_putc(tty, ' ');
@


1.131
log
@Missing ()s in macros.
@
text
@d1 1
a1 1
/* $OpenBSD: tty.c,v 1.130 2012/05/05 18:17:59 nicm Exp $ */
d62 3
d787 1
a787 4
	struct window_pane	*wp = ctx->wp;
	struct screen		*s = wp->screen;

	if (ctx->xoff != 0 || screen_size_x(s) < tty->sx ||
d805 1
a805 4
	struct window_pane	*wp = ctx->wp;
	struct screen		*s = wp->screen;

	if (ctx->xoff != 0 || screen_size_x(s) < tty->sx ||
d831 1
a831 2
	if (ctx->xoff == 0 && screen_size_x(s) >= tty->sx &&
	    tty_term_has(tty->term, TTYC_EL)) {
d850 1
a850 2
	if (ctx->xoff == 0 && screen_size_x(s) >= tty->sx &&
	    tty_term_has(tty->term, TTYC_EL))
a877 3
	struct window_pane	*wp = ctx->wp;
	struct screen		*s = wp->screen;

d881 1
a881 1
	if (ctx->xoff != 0 || screen_size_x(s) < tty->sx ||
d905 1
a905 1
	if (ctx->xoff != 0 || screen_size_x(s) < tty->sx ||
d947 1
a947 2
	if (ctx->xoff == 0 && screen_size_x(s) >= tty->sx &&
	    tty_term_has(tty->term, TTYC_EL)) {
d982 1
a982 2
	if (ctx->xoff == 0 && screen_size_x(s) >= tty->sx &&
	    tty_term_has(tty->term, TTYC_EL)) {
d1011 1
a1011 2
	if (ctx->xoff == 0 && screen_size_x(s) >= tty->sx &&
	    tty_term_has(tty->term, TTYC_EL)) {
@


1.130
log
@Pull CRA out into a separate function and add ERA, from Ailin Nemui.
@
text
@d1 1
a1 1
/* $OpenBSD: tty.c,v 1.129 2012/03/20 11:01:00 nicm Exp $ */
d58 1
a58 1
	(tty_term_has(tty->term, TTYC_ACSC) && !((tty)->flags & TTY_UTF8))
d60 1
a60 1
	(tty->xterm_version > 270)
@


1.129
log
@Add a simple form of output rate limiting by counting the number of
certain C0 sequences (linefeeds, backspaces, carriage returns) and if it
exceeds a threshold (current default 50/millisecond), start to redraw
the pane every 100 milliseconds instead of making each change as it
comes. Two configuration options - c0-change-trigger and
c0-change-interval.

This makes tmux much more responsive under very fast output (for example
yes(1) or accidentally cat'ing a large file) but may not be perfect on
all terminals and connections - feedback very welcome, particularly
where this change has a negative rather than positive effect (making it
off by default is a possibility).

After much experimentation based originally on a request Robin Lee
Powell (which ended with a completely different solution), this idea
from discussion with Ailin Nemui.
@
text
@d1 1
a1 1
/* $OpenBSD: tty.c,v 1.128 2012/03/17 22:56:04 nicm Exp $ */
d47 4
d59 2
d699 32
a908 1
	char			 tmp[64];
d917 4
a920 10
		else if (tty->xterm_version > 270) {
			snprintf(tmp, sizeof tmp,
			    "\033[%u;%u;%u;%u;1;%u;%u;1$v",
			    ctx->yoff + ctx->orupper + 2,
			    ctx->xoff + 1,
			    ctx->yoff + ctx->orlower + 1,
			    ctx->xoff + screen_size_x(s),
			    ctx->yoff + ctx->orupper + 1,
			    ctx->xoff + 1);
			tty_puts(tty, tmp);
@


1.128
log
@On xterm 271 and later, put the terminal into SCL 5 and use DECCRA for
scrolling the region in panes (if the large region check isn't
hit). With help from Ailin Nemui.
@
text
@d1 1
a1 1
/* $OpenBSD: tty.c,v 1.127 2012/03/17 21:27:51 nicm Exp $ */
d664 1
a664 1
	if (!window_pane_visible(wp))
@


1.127
log
@Break out termios initialization into a separate function, from George
Nachman.
@
text
@d1 1
a1 1
/* $OpenBSD: tty.c,v 1.126 2012/03/17 19:29:46 nicm Exp $ */
d180 1
a180 1
	struct termios	 tio;
d238 21
d300 3
d871 1
d878 15
a892 1
		tty_redraw_region(tty, ctx);
@


1.126
log
@Do not clear to end of line if the line is full, fixes missing last
character in rightmost pane.
@
text
@d1 1
a1 1
/* $OpenBSD: tty.c,v 1.125 2012/03/17 19:18:37 nicm Exp $ */
d178 1
a178 1
tty_start_tty(struct tty *tty)
d182 1
a182 1
	if (tty->fd == -1 || tcgetattr(tty->fd, &tty->tio) != 0)
d185 1
a185 1
	setblocking(tty->fd, 0);
d187 2
a188 1
	bufferevent_enable(tty->event, EV_READ|EV_WRITE);
d190 1
a190 1
	memcpy(&tio, &tty->tio, sizeof tio);
d198 8
a205 2
	if (tcsetattr(tty->fd, TCSANOW, &tio) == 0)
		tcflush(tty->fd, TCIOFLUSH);
@


1.125
log
@Use the region lower not the pane size to work out where the bottom line
is.
@
text
@d1 1
a1 1
/* $OpenBSD: tty.c,v 1.124 2012/03/17 18:51:50 nicm Exp $ */
d607 1
a607 1
	if (ox + screen_size_x(s) >= tty->sx &&
@


1.124
log
@Tweak last fix to actually hit the right end of pane.
@
text
@d1 1
a1 1
/* $OpenBSD: tty.c,v 1.123 2012/03/17 18:24:07 nicm Exp $ */
d1004 1
a1004 1
			if (ctx->ocy != wp->yoff + wp->sy - 1)
@


1.123
log
@Check event_initialized before event_del if event may not have been set
up; libevent2 complains about this. Reported by Moriyoshi Koizumi.
@
text
@d1 1
a1 1
/* $OpenBSD: tty.c,v 1.122 2012/03/17 17:36:03 nicm Exp $ */
d1004 1
a1004 1
			if (ctx->ocy != wp->yoff + wp->sy)
@


1.122
log
@Revert screen-write.c r1.54 and fix the bug properly. After wrapping a
line in a pane, the cursor needs to move to the next line unless it
scrolled.
@
text
@d1 1
a1 1
/* $OpenBSD: tty.c,v 1.121 2012/03/15 10:36:00 nicm Exp $ */
d282 2
a283 1
	evtimer_del(&tty->key_timer);
@


1.121
log
@Send secondary DA to terminals with XT in terminfo when starting up and
parse it to work out the xterm version.
@
text
@d1 1
a1 1
/* $OpenBSD: tty.c,v 1.120 2012/03/15 09:22:31 nicm Exp $ */
d1003 4
a1006 1
			tty_cursor_pane(tty, ctx, 0, ctx->ocy + 1);
@


1.120
log
@Fix a warning. Doh.
@
text
@d1 1
a1 1
/* $OpenBSD: tty.c,v 1.119 2012/03/15 09:10:33 nicm Exp $ */
d213 3
@


1.119
log
@Add a helper function for enabling an optimization to make some code
clearer.
@
text
@d1 1
a1 1
/* $OpenBSD: tty.c,v 1.118 2012/03/12 12:43:18 nicm Exp $ */
d46 1
@


1.118
log
@Erm, use EL in a way that actually works...
@
text
@d1 1
a1 1
/* $OpenBSD: tty.c,v 1.117 2012/03/12 12:38:42 nicm Exp $ */
d505 13
d530 2
a531 4
	 * If region is >= 50% of the screen, just schedule a window redraw. In
	 * most cases, this is likely to be followed by some more scrolling -
	 * without this, the entire pane ends up being redrawn many times which
	 * can be much more data.
d533 1
a533 1
	if (ctx->orlower - ctx->orupper >= screen_size_y(s) / 2) {
@


1.117
log
@Use EL to clear to end of line if possible.
@
text
@d1 1
a1 1
/* $OpenBSD: tty.c,v 1.116 2012/03/09 21:42:13 nicm Exp $ */
d591 1
a591 1
	if (ox + sx + screen_size_x(s) >= tty->sx &&
@


1.116
log
@Remove some bits leftover from unused backoff code.
@
text
@d1 1
a1 1
/* $OpenBSD: tty.c,v 1.115 2012/03/03 09:43:23 nicm Exp $ */
d591 2
a592 1
	if (screen_size_x(s) >= tty->sx && tty_term_has(tty->term, TTYC_EL))
@


1.115
log
@Support "bracketed paste" mode. This adds a -p flag to paste-buffer - if
this is used and the application has requested bracketed pastes, then
tmux surrounds the pasted text by \033[200~ and \033[201~. Applications
like vim can (apparently) use this to avoid, for example, indenting the
text. From Ailin Nemui.
@
text
@d1 1
a1 1
/* $OpenBSD: tty.c,v 1.114 2012/02/15 17:25:02 nicm Exp $ */
d630 1
a630 1
			if (c->tty.flags & (TTY_FREEZE|TTY_BACKOFF))
@


1.114
log
@Add a wrapper function tty_set_size from George Nachman.
@
text
@d1 1
a1 1
/* $OpenBSD: tty.c,v 1.113 2012/01/29 09:37:02 nicm Exp $ */
d482 6
@


1.113
log
@Add an option to move the status line to the top of the screen,
requested by many.
@
text
@d1 1
a1 1
/* $OpenBSD: tty.c,v 1.112 2012/01/21 08:23:12 nicm Exp $ */
d96 1
a96 1
	if (sx == tty->sx && sy == tty->sy)
a97 2
	tty->sx = sx;
	tty->sy = sy;
d114 9
@


1.112
log
@Add strings to allow the aixterm bright colours to be used when
configuring colours, requested by Elliott Cable a few months ago.
@
text
@d1 1
a1 1
/* $OpenBSD: tty.c,v 1.111 2012/01/15 19:39:42 nicm Exp $ */
d516 1
a516 1
			tty_draw_line(tty, s, i, wp->xoff, wp->yoff);
d519 1
a519 1
			tty_draw_line(tty, s, i, wp->xoff, wp->yoff);
d588 2
a589 2
tty_write(void (*cmdfn)(
    struct tty *, const struct tty_ctx *), const struct tty_ctx *ctx)
d593 2
d612 1
d614 1
a614 1
		if (c->session->curw->window == wp->window) {
d619 7
d638 2
a639 2
	if (wp->xoff != 0 || screen_size_x(s) < tty->sx) {
		tty_draw_line(tty, wp->screen, ctx->ocy, wp->xoff, wp->yoff);
d657 1
a657 1
		tty_draw_line(tty, wp->screen, ctx->ocy, wp->xoff, wp->yoff);
d666 1
a666 1
	if (wp->xoff != 0 || screen_size_x(s) < tty->sx ||
d669 1
a669 1
		tty_draw_line(tty, wp->screen, ctx->ocy, wp->xoff, wp->yoff);
d688 1
a688 1
	if (wp->xoff != 0 || screen_size_x(s) < tty->sx ||
d709 1
a709 1
	if (wp->xoff != 0 || screen_size_x(s) < tty->sx ||
d735 1
a735 1
	if (wp->xoff == 0 && screen_size_x(s) >= tty->sx &&
d755 1
a755 1
	if (wp->xoff == 0 && screen_size_x(s) >= tty->sx &&
d767 1
a767 2
	struct window_pane	*wp = ctx->wp;
	u_int		 	 i;
d771 1
a771 1
	if (wp->xoff == 0 && tty_term_has(tty->term, TTYC_EL1)) {
d790 1
a790 1
	if (wp->xoff != 0 || screen_size_x(s) < tty->sx ||
d814 1
a814 1
	if (wp->xoff != 0 || screen_size_x(s) < tty->sx ||
d848 1
a848 1
	if (wp->xoff == 0 && screen_size_x(s) >= tty->sx &&
d884 1
a884 1
	if (wp->xoff == 0 && screen_size_x(s) >= tty->sx &&
d914 1
a914 1
	if (wp->xoff == 0 && screen_size_x(s) >= tty->sx &&
d969 1
a969 1
		if (wp->xoff != 0 || wp->sx != tty->sx) {
d1003 1
a1003 1
	tty_draw_line(tty, wp->screen, ctx->ocy, wp->xoff, wp->yoff);
d1090 1
a1090 3
	struct window_pane	*wp = ctx->wp;

	tty_region(tty, wp->yoff + rupper, wp->yoff + rlower);
d1122 1
a1122 3
	struct window_pane	*wp = ctx->wp;

	tty_cursor(tty, wp->xoff + cx, wp->yoff + cy);
@


1.111
log
@Calculate last position correctly for UTF-8 wide characters, reported by
Matthias Lederhofer.
@
text
@d1 1
a1 1
/* $OpenBSD: tty.c,v 1.110 2011/08/24 09:58:44 nicm Exp $ */
d1443 1
a1443 1
	if (gc->bg >= 100 && gc->bg <= 107 && colours < 16) {
d1503 1
a1503 1
	if (bg >= 100 && bg <= 107) {
d1506 1
a1506 1
			xsnprintf(s, sizeof s, "\033[%dm", bg);
d1510 1
a1510 1
		bg -= 100;
@


1.110
log
@Add a tty_bell wrapper function, from Dylan Alex Simon.
@
text
@d1 1
a1 1
/* $OpenBSD: tty.c,v 1.109 2011/05/26 07:08:48 nicm Exp $ */
d972 4
a975 1
			cx = screen_size_x(s) - width;
@


1.109
log
@Trim another useless if statement, from Ailin Nemui.
@
text
@d1 1
a1 1
/* $OpenBSD: tty.c,v 1.108 2011/05/20 19:17:39 nicm Exp $ */
d1548 6
@


1.108
log
@Support DECSCUSR sequence to set the cursor style with two new
terminfo(5) extensions, Cs and Csr. Written by Ailin Nemui.
@
text
@d1 1
a1 1
/* $OpenBSD: tty.c,v 1.107 2011/05/20 19:03:58 nicm Exp $ */
d251 1
a251 1
		else if (tty_term_has(tty->term, TTYC_CS1))
@


1.107
log
@Support xterm(1) cursor colour change sequences through terminfo(5) Cc
(set) and Cr (reset) extensions. Originally by Sean Estabrooks, tweaked
by me and Ailin Nemui.
@
text
@d1 1
a1 1
/* $OpenBSD: tty.c,v 1.106 2011/05/18 20:24:29 nicm Exp $ */
d72 1
d248 6
d438 10
@


1.106
log
@Support setting the xterm clipboard when copying from copy mode using
the xterm escape sequence for the purpose (if xterm is configured to
allow it).

Written by and much discussed Ailin Nemui, guidance on
xterm/termcap/terminfo from Thomas Dickey.
@
text
@d1 1
a1 1
/* $OpenBSD: tty.c,v 1.105 2011/05/08 19:53:08 nicm Exp $ */
d72 1
d214 2
d247 1
d287 1
d323 7
d404 12
a415 1
tty_update_mode(struct tty *tty, int mode)
d419 3
d515 1
a515 1
	tty_update_mode(tty, tty->mode & ~MODE_CURSOR);
d555 1
a555 1
		tty_update_mode(tty, tty->mode);
d567 1
a567 1
	tty_update_mode(tty, tty->mode);
@


1.105
log
@Use the tsl and fsl terminfo(5) capabilities to update terminal title
and automatically fill them in on terminals with the XT capability
(which means their title setting is xterm-compatible). From hsim at
gmx.li.
@
text
@d1 1
a1 1
/* $OpenBSD: tty.c,v 1.104 2011/04/09 07:48:08 nicm Exp $ */
d22 2
d26 1
d318 7
d949 18
@


1.104
log
@If the terminal supports sitm for italics, use it instead of standout
(smso). From Tiago Resende.
@
text
@d1 1
a1 1
/* $OpenBSD: tty.c,v 1.103 2011/03/27 20:36:19 nicm Exp $ */
d372 2
a373 3
	if (strstr(tty->termname, "xterm") == NULL &&
	    strstr(tty->termname, "rxvt") == NULL &&
	    strcmp(tty->termname, "screen") != 0)
d376 1
a376 1
	tty_puts(tty, "\033]0;");
d378 1
a378 1
	tty_putc(tty, '\007');
@


1.103
log
@Set the terminal blocking again earlier, before sending the reset
sequences.
@
text
@d1 1
a1 1
/* $OpenBSD: tty.c,v 1.102 2011/03/26 19:07:33 nicm Exp $ */
d1221 6
a1226 1
		tty_putcode(tty, TTYC_SMSO);
@


1.102
log
@Fix to properly wrap wide characters, from Micah Cowan.
@
text
@d1 1
a1 1
/* $OpenBSD: tty.c,v 1.101 2011/03/08 19:23:49 nicm Exp $ */
d233 2
a246 2

	setblocking(tty->fd, 1);
@


1.101
log
@Fix an incorrect test which was always true (oupper is always < olower),
from Yusuke ENDOH.
@
text
@d1 1
a1 1
/* $OpenBSD: tty.c,v 1.100 2011/03/07 23:46:27 nicm Exp $ */
d895 8
d907 1
a907 1
	if (ctx->ocx > wp->sx - ctx->last_width) {
d917 1
a917 1
			 * move as far left as possinble and redraw the last
d920 1
a920 1
			cx = screen_size_x(s) - ctx->last_width;
@


1.100
log
@Support passing through escape sequences to the underlying terminal by
using DCS with a "tmux;" prefix. Escape characters in the sequences must
be doubled. For example:

$ printf '\033Ptmux;\033\033]12;red\007\033\\'

Will pass \033]12;red\007 to the terminal (and change the cursor colour
in xterm). From Kevin Goodsell.
@
text
@d1 1
a1 1
/* $OpenBSD: tty.c,v 1.99 2011/01/29 08:39:43 nicm Exp $ */
d457 1
a457 1
	if (ctx->orupper - ctx->orlower >= screen_size_y(s) / 2) {
@


1.99
log
@Accept tcgetattr/tcsetattr failure, fixes problems with fatal() if the
terminal disappears while locked.
@
text
@d1 1
a1 1
/* $OpenBSD: tty.c,v 1.98 2011/01/15 00:46:19 nicm Exp $ */
d932 10
@


1.98
log
@Only set a mouse mode for mouse-select-pane if none already set by the
mode (any will do).
@
text
@d1 1
a1 1
/* $OpenBSD: tty.c,v 1.97 2011/01/15 00:16:00 nicm Exp $ */
d169 1
a169 1
	if (tty->fd == -1)
a175 2
	if (tcgetattr(tty->fd, &tty->tio) != 0)
		fatal("tcgetattr failed");
d184 2
a185 3
	if (tcsetattr(tty->fd, TCSANOW, &tio) != 0)
		fatal("tcsetattr failed");
	tcflush(tty->fd, TCIOFLUSH);
@


1.97
log
@Mouse highlight mode (1001) requires a program to cooperate so
supporting it through tmux is not as easy as this, remove it for now.
@
text
@d1 1
a1 1
/* $OpenBSD: tty.c,v 1.96 2011/01/08 01:52:37 nicm Exp $ */
d404 2
a405 2
			if (mode & MODE_MOUSE_STANDARD)
				tty_puts(tty, "\033[?1000h");
d408 2
a409 2
			else if (mode & MODE_MOUSE_ANY)
				tty_puts(tty, "\033[?1003h");
d411 2
a412 2
			if (tty->mode & MODE_MOUSE_STANDARD)
				tty_puts(tty, "\033[?1000l");
d415 2
a416 2
			else if (tty->mode & MODE_MOUSE_ANY)
				tty_puts(tty, "\033[?1003l");
@


1.96
log
@Move all calls to fcntl(...O_NONBLOCK) into a function and clear the
flag on the stdio file descriptors before closing them (fixes things
like "tmux ls && cat").
@
text
@d1 1
a1 1
/* $OpenBSD: tty.c,v 1.95 2011/01/03 23:35:22 nicm Exp $ */
a405 2
			else if (mode & MODE_MOUSE_HIGHLIGHT)
				tty_puts(tty, "\033[?1001h");
a412 2
			else if (tty->mode & MODE_MOUSE_HIGHLIGHT)
				tty_puts(tty, "\033[?1001l");
@


1.95
log
@Support for UTF-8 mouse input (\033[1005h). This was added in xterm 262
and supports larger terminals than the older way.

If the new mouse-utf8 option is on, UTF-8 mouse input is enabled for all
UTF-8 terminals. The option defaults to on if LANG etc are set in the
same manner as the utf8 option.

With help and based on code from hsim at gmx.li.
@
text
@d1 1
a1 1
/* $OpenBSD: tty.c,v 1.94 2010/12/29 21:49:06 nicm Exp $ */
a167 1
	int		 mode;
d172 1
a172 4
	if ((mode = fcntl(tty->fd, F_GETFL)) == -1)
		fatal("fcntl failed");
	if (fcntl(tty->fd, F_SETFL, mode|O_NONBLOCK) == -1)
		fatal("fcntl failed");
a218 1
	int		mode;
d249 1
a249 2
	if ((mode = fcntl(tty->fd, F_GETFL)) != -1)
		fcntl(tty->fd, F_SETFL, mode & ~O_NONBLOCK);
@


1.94
log
@Support all four of the xterm mouse modes. Based on a diff from hsim at
gmx.li.
@
text
@d1 1
a1 1
/* $OpenBSD: tty.c,v 1.93 2010/11/22 21:13:13 nicm Exp $ */
d408 2
d427 2
@


1.93
log
@There is somewhere that WINDOW_HIDDEN is getting set when it shouldn't
be and I can't find it, but the flag itself is a useless optimisation
that only applies to automatic-resize windows, so just dispose of it
entirely.

Fixes problems reported by Nicholas Riley.
@
text
@d1 1
a1 1
/* $OpenBSD: tty.c,v 1.92 2010/10/16 08:31:55 nicm Exp $ */
d406 9
a414 3
	if (changed & (MODE_MOUSE|MODE_MOUSEMOTION)) {
		if (mode & MODE_MOUSE) {
			if (mode & MODE_MOUSEMOTION)
a415 2
			else
				tty_puts(tty, "\033[?1000h");
d417 7
a423 1
			if (mode & MODE_MOUSEMOTION)
a424 2
			else
				tty_puts(tty, "\033[?1000l");
@


1.92
log
@Trying to set FD_CLOEXEC on every fd is a lost cause, just use
closefrom() before exec.
@
text
@d1 1
a1 1
/* $OpenBSD: tty.c,v 1.91 2010/09/11 16:20:58 nicm Exp $ */
d550 1
a550 1
	if (wp->window->flags & WINDOW_HIDDEN || !window_pane_visible(wp))
@


1.91
log
@Ugh. Pass the right type into tty_term_has. Teaches me to make last
minute changes :-/.
@
text
@d1 1
a1 1
/* $OpenBSD: tty.c,v 1.90 2010/09/11 16:19:22 nicm Exp $ */
a63 3

	if (fcntl(fd, F_SETFD, FD_CLOEXEC) == -1)
		fatal("fcntl failed");
@


1.90
log
@Use UTF-8 line drawing characters on UTF-8 terminals. Fixes some stupid
terminals (I'm looking at you, putty) which disable the vt100 ACS mode
switching sequences in UTF-8 mode.

Also on terminals without ACS at all, use ASCII equivalents where
obvious.
@
text
@d1 1
a1 1
/* $OpenBSD: tty.c,v 1.89 2010/08/11 07:34:43 nicm Exp $ */
d50 1
a50 1
	(tty_term_has(tty, TTYC_ACSC) && !((tty)->flags & TTY_UTF8))
@


1.89
log
@Change the way backoff works. Instead of stopping reading from the pty
when the client tty backs up too much, just stop updating the tty and
only update the internal screen. Then when the tty recovers, force a
redraw.

This prevents a dodgy client from causing other clients to go into
backoff while still allowing tmux to be responsive (locally) when seeing
lots of output.
@
text
@d1 1
a1 1
/* $OpenBSD: tty.c,v 1.88 2010/06/05 16:47:11 nicm Exp $ */
a33 2
void	tty_fill_acs(struct tty *);

d49 3
a146 2
	tty_fill_acs(tty);

d203 2
a204 1
	tty_putcode(tty, TTYC_ENACS);
d245 2
a246 1
	tty_raw(tty, tty_term_string(tty->term, TTYC_RMACS));
a261 24
tty_fill_acs(struct tty *tty)
{
	const char *ptr;

	memset(tty->acs, 0, sizeof tty->acs);
	if (!tty_term_has(tty->term, TTYC_ACSC))
		return;

	ptr = tty_term_string(tty->term, TTYC_ACSC);
	if (strlen(ptr) % 2 != 0)
		return;
	for (; *ptr != '\0'; ptr += 2)
		tty->acs[(u_char) ptr[0]] = ptr[1];
}

u_char
tty_get_acs(struct tty *tty, u_char ch)
{
	if (tty->acs[ch] != '\0')
		return (tty->acs[ch]);
	return (ch);
}

void
d340 2
a341 1
	u_int	sx;
d343 8
a350 3
	if (tty->cell.attr & GRID_ATTR_CHARSET)
		ch = tty_get_acs(tty, ch);
	bufferevent_write(tty->event, &ch, 1);
d983 1
a983 1
	if (tty_term_has(tty->term, TTYC_RMACS) && gc->attr & GRID_ATTR_CHARSET)
d1220 1
a1220 1
	if (changed & GRID_ATTR_CHARSET)
@


1.88
log
@Fix problems with window sizing seen by Raghavendra D Prabhu when
starting tmux from .xinitrc.

One of the very few things the server relies on the client for now is to
pass through a message on SIGWINCH, but there is a condition where
potentially a SIGWINCH may be lost during the transition from unattached
(main.c) to attached (client.c). So trigger a size change immediately
after the client installs its SIGWINCH handler.

Also, when the terminal is resized, reset the scroll region and cursor
position. Previously, we were clearing our saved idea of these, but in
fact some terminals do not reset them on resize, so this caused problems
during redraw.

While here make a resize to the same size not cause a redraw and rename
the tmux.out output log file to include the tmux PID.
@
text
@d1 1
a1 1
/* $OpenBSD: tty.c,v 1.87 2010/06/05 16:32:22 nicm Exp $ */
d581 3
a583 1
			if (c->tty.flags & TTY_FREEZE || c->tty.term == NULL)
@


1.87
log
@Shut up gcc4 warnings.
@
text
@d1 1
a1 1
/* $OpenBSD: tty.c,v 1.86 2010/05/31 19:51:29 nicm Exp $ */
d76 1
a76 1
void
d80 1
d83 9
a91 2
		tty->sx = ws.ws_col;
		tty->sy = ws.ws_row;
d93 4
a96 4
	if (tty->sx == 0)
		tty->sx = 80;
	if (tty->sy == 0)
		tty->sy = 24;
d103 11
d119 1
d123 2
a124 1
		fd = open("tmux.out", O_WRONLY|O_CREAT|O_TRUNC, 0644);
@


1.86
log
@When the mode-mouse option is on, support dragging to make a selection
in copy mode.

Also support the scroll wheel, although xterm strangely does not ignore
it in application mouse mode, causing redraw artifacts when scrolling up
(other terminals appear to be better behaved).
@
text
@d1 1
a1 1
/* $OpenBSD: tty.c,v 1.85 2010/03/01 22:44:31 nicm Exp $ */
d1093 1
a1093 1
		if (abs(change) > cx && tty_term_has(term, TTYC_HPA)) {
d1129 1
a1129 1
		if (abs(change) > cy ||
@


1.85
log
@Check for colour and attribute modifications early so the translated
values can be stored in the cached terminal attributes rather than the
requested (untranslated) values. Prevents tmux clearing and setting the
attributes for every character when using aixterm colours.
@
text
@d1 1
a1 1
/* $OpenBSD: tty.c,v 1.84 2010/02/24 19:08:39 nicm Exp $ */
d405 12
a416 5
	if (changed & MODE_MOUSE) {
		if (mode & MODE_MOUSE)
			tty_puts(tty, "\033[?1000h");
		else
			tty_puts(tty, "\033[?1000l");
@


1.84
log
@Don't set the terminal to nonblocking on detach until we have finished with it
entirely.
@
text
@d1 1
a1 1
/* $OpenBSD: tty.c,v 1.83 2010/02/01 23:06:24 nicm Exp $ */
d39 4
a42 2
void	tty_colours(struct tty *, const struct grid_cell *, u_char *);
void	tty_colours_fg(struct tty *, const struct grid_cell *, u_char *);
d1151 1
a1151 1
	u_char			 changed, new_attr;
d1153 1
a1153 9
	/* If the character is space, don't care about foreground. */
	if (gc->data == ' ' && !(gc->flags & GRID_FLAG_UTF8)) {
		memcpy(&gc2, gc, sizeof gc2);
		if (gc->attr & GRID_ATTR_REVERSE)
			gc2.bg = tc->bg;
		else
			gc2.fg = tc->fg;
		gc = &gc2;
	}
d1161 2
a1162 7
		if (gc != &gc2) {
			memcpy(&gc2, gc, sizeof gc2);
			gc = &gc2;
		}

		if (gc->attr & GRID_ATTR_REVERSE) {
			if (gc->fg != 7 && gc->fg != 8)
d1165 1
a1165 1
			if (gc->bg != 0 && gc->bg != 8)
d1170 4
d1175 1
a1175 1
	if (tc->attr & ~gc->attr)
d1182 1
a1182 2
	new_attr = gc->attr;
	tty_colours(tty, gc, &new_attr);
d1185 2
a1186 2
	changed = new_attr & ~tc->attr;
	tc->attr = new_attr;
d1212 1
a1212 1
tty_colours(struct tty *tty, const struct grid_cell *gc, u_char *attr)
d1269 1
a1269 1
		tty_colours_fg(tty, gc, attr);
d1281 65
a1345 1
tty_colours_fg(struct tty *tty, const struct grid_cell *gc, u_char *attr)
d1358 2
a1359 8

		/* Translate to 16-colour palette, updating bold if needed. */
		fg = colour_256to16(fg);
		if (fg & 8) {
			fg &= 7;
			(*attr) |= GRID_ATTR_BRIGHT;
		} else
			tty_reset(tty);		/* turn off bold */
d1364 3
a1366 8
		/* 16 colour terminals or above only. */
		if (tty_term_number(tty->term, TTYC_COLORS) >= 16) {
			xsnprintf(s, sizeof s, "\033[%dm", fg);
			tty_puts(tty, s);
			goto save_fg;
		}
		fg -= 90;
		(*attr) |= GRID_ATTR_BRIGHT;
d1393 2
a1394 8

		/*
		 * Translate to 16-colour palette. Bold background doesn't
		 * exist portably, so just discard the bold bit if set.
		 */
		bg = colour_256to16(bg);
		if (bg & 8)
			bg &= 7;
@


1.83
log
@If redrawing line 0 of the screen onto the tty, there can't be a wrap flag on
the previous line, so move the cursor. Fixes status line redraw issues when
resizing in choose mode and hopefully at other times as well.
@
text
@d1 1
a1 1
/* $OpenBSD: tty.c,v 1.82 2010/01/01 14:29:18 nicm Exp $ */
a215 4
	if ((mode = fcntl(tty->fd, F_GETFL)) == -1)
		return;
	if (fcntl(tty->fd, F_SETFL, mode & ~O_NONBLOCK) == -1)
		return;
d232 3
@


1.82
log
@Use tcflush(3) instead of TIOCFLUSH, from Ed Schouten.
@
text
@d1 1
a1 1
/* $OpenBSD: tty.c,v 1.81 2009/12/26 11:02:32 nicm Exp $ */
d487 1
a487 1
	if (oy + py == 0 || (gl != NULL && !(gl->flags & GRID_LINE_WRAPPED)) ||
@


1.81
log
@Fix the logic so that transition from a 256 colour to default works properly.
@
text
@d1 1
a1 1
/* $OpenBSD: tty.c,v 1.80 2009/12/26 10:39:02 nicm Exp $ */
d149 1
a149 1
	int		 what, mode;
d173 1
a173 4

	what = 0;
	if (ioctl(tty->fd, TIOCFLUSH, &what) != 0)
		fatal("ioctl(TIOCFLUSH)");
@


1.80
log
@Nuke some stray debugging.
@
text
@d1 1
a1 1
/* $OpenBSD: tty.c,v 1.79 2009/12/14 21:33:38 nicm Exp $ */
d1256 1
a1256 1
			    fg != tc->fg && !(tc->flags & GRID_FLAG_FG256)) {
d1259 2
a1260 1
				else if (tc->fg != 7)
d1266 1
a1266 1
			    bg != tc->bg && !(tc->flags & GRID_FLAG_BG256)) {
d1269 2
a1270 1
				else if (tc->bg != 0)
@


1.79
log
@Pass through the aixterm bright colours if the terminal supports them (>= 16
colours).
@
text
@d1 1
a1 1
/* $OpenBSD: tty.c,v 1.78 2009/12/04 11:01:29 nicm Exp $ */
a1233 1
	log_debug("fg was %hhu, now %hhu", tc->fg, fg);
@


1.78
log
@vte is buggy and doesn't home the cursor after changing the scroll
region. Several people are hitting this, so add a workaround.
@
text
@d1 1
a1 1
/* $OpenBSD: tty.c,v 1.77 2009/12/03 22:50:10 nicm Exp $ */
d1234 1
d1296 1
d1315 12
d1342 1
d1359 12
@


1.77
log
@Massive spaces->tabs and trailing whitespace cleanup, hopefully for the last
time now I've configured emacs to make them displayed in really annoying
colours...
@
text
@d1 1
a1 1
/* $OpenBSD: tty.c,v 1.76 2009/12/02 22:13:15 nicm Exp $ */
a1008 3
	tty->cx = 0;
	tty->cy = 0;

d1010 1
@


1.76
log
@Reflect the keypad mode of the application so that numlock works.
@
text
@d1 1
a1 1
/* $OpenBSD: tty.c,v 1.75 2009/11/27 09:41:03 nicm Exp $ */
d47 1
a47 1
    	    const struct grid_cell *, const struct grid_utf8 *);
d505 1
a505 1
			tmpgc.flags = gc->flags & 
d565 1
a565 1
  	struct window_pane	*wp = ctx->wp;
d576 1
a576 1
 	tty_cursor_pane(tty, ctx, ctx->ocx, ctx->ocy);
d581 1
a581 1
	else if (tty_term_has(tty->term, TTYC_SMIR) && 
d594 1
a594 1
  	struct window_pane	*wp = ctx->wp;
d606 1
a606 1
 	tty_cursor_pane(tty, ctx, ctx->ocx, ctx->ocy);
d616 1
a616 1
  	struct window_pane	*wp = ctx->wp;
d619 2
a620 2
 	if (wp->xoff != 0 || screen_size_x(s) < tty->sx ||
	    !tty_term_has(tty->term, TTYC_CSR) || 
d628 2
a629 2
 	tty_region_pane(tty, ctx, ctx->orupper, ctx->orlower);
 	tty_cursor_pane(tty, ctx, ctx->ocx, ctx->ocy);
d637 1
a637 1
  	struct window_pane	*wp = ctx->wp;
d640 1
a640 1
 	if (wp->xoff != 0 || screen_size_x(s) < tty->sx ||
d649 2
a650 2
 	tty_region_pane(tty, ctx, ctx->orupper, ctx->orlower);
 	tty_cursor_pane(tty, ctx, ctx->ocx, ctx->ocy);
d658 1
a658 1
  	struct window_pane	*wp = ctx->wp;
d664 1
a664 1
 	tty_cursor_pane(tty, ctx, 0, ctx->ocy);
d678 1
a678 1
  	struct window_pane	*wp = ctx->wp;
d698 1
a698 1
  	struct window_pane	*wp = ctx->wp;
d716 1
a716 1
  	struct window_pane	*wp = ctx->wp;
d722 1
a722 1
 	if (wp->xoff != 0 || screen_size_x(s) < tty->sx ||
d730 1
a730 1
	
d733 1
a733 1
	
d740 1
a740 1
  	struct window_pane	*wp = ctx->wp;
d746 1
a746 1
 	if (wp->xoff != 0 || screen_size_x(s) < tty->sx ||
d761 1
a761 1
	
d764 1
a764 1
	
d771 1
a771 1
  	struct window_pane	*wp = ctx->wp;
d807 1
a807 1
 	struct window_pane	*wp = ctx->wp;
d837 1
a837 1
 	struct window_pane	*wp = ctx->wp;
d924 1
a924 1
	tty_draw_line(tty, wp->screen, ctx->ocy, wp->xoff, wp->yoff);	
d983 1
a983 1
  	struct window_pane	*wp = ctx->wp;
d1019 1
a1019 1
  	struct window_pane	*wp = ctx->wp;
d1031 1
a1031 1
	
d1106 1
a1106 1
		if (thisy != tty->rupper && 
d1123 2
a1124 2
		 * Try to use VPA if change is larger than absolute or if this change
		 * would cross the scroll region, otherwise use CUU/CUD.
d1268 1
a1268 1
				if (have_ax)					
d1318 1
a1318 1
save_fg:	
@


1.75
log
@Add a couple of comments.
@
text
@d1 1
a1 1
/* $OpenBSD: tty.c,v 1.74 2009/11/26 22:47:14 nicm Exp $ */
d183 1
a183 1
	tty_putcode(tty, TTYC_SMKX);
d412 6
@


1.74
log
@Fix type - attributes should be u_char not int.
@
text
@d1 1
a1 1
/* $OpenBSD: tty.c,v 1.73 2009/11/26 21:37:13 nicm Exp $ */
d532 1
@


1.73
log
@Remove a couple of unused arguments where possible, and add /* ARGSUSED */ to
the rest to reduce lint output.
@
text
@d1 1
a1 1
/* $OpenBSD: tty.c,v 1.72 2009/11/26 14:46:08 nicm Exp $ */
d39 2
a40 2
void	tty_colours(struct tty *, const struct grid_cell *, int *);
void	tty_colours_fg(struct tty *, const struct grid_cell *, int *);
d1148 1
a1148 2
	u_char			 changed;
	u_int			 new_attr;
d1219 1
a1219 1
tty_colours(struct tty *tty, const struct grid_cell *gc, int *attr)
d1286 1
a1286 1
tty_colours_fg(struct tty *tty, const struct grid_cell *gc, int *attr)
@


1.72
log
@Emulate il1, dl1, ich1 to run (albeit slowly) with vt100 feature set.
@
text
@d1 1
a1 1
/* $OpenBSD: tty.c,v 1.71 2009/11/18 17:02:17 nicm Exp $ */
d41 1
a41 1
void	tty_colours_bg(struct tty *, const struct grid_cell *, int *);
d128 1
d138 1
d1283 1
a1283 1
		tty_colours_bg(tty, gc, attr);
d1320 1
a1320 1
tty_colours_bg(struct tty *tty, const struct grid_cell *gc, unused int *attr)
@


1.71
log
@Cleanup by moving various (mostly horrible) little bits handling UTF-8 grid
data into functions in a new file, grid-utf8.c, and use sizeof intead of
UTF8_DATA.

Also nuke trailing whitespace from tmux.1, reminded by jmc.
@
text
@d1 1
a1 1
/* $OpenBSD: tty.c,v 1.70 2009/11/12 08:05:23 nicm Exp $ */
d572 2
a573 1
	else {
d578 2
a579 1
	}
d611 2
a612 1
	    !tty_term_has(tty->term, TTYC_CSR)) {
d632 2
a633 1
	    !tty_term_has(tty->term, TTYC_CSR)) {
@


1.70
log
@Emulate the ri (reverse index) capability: this allows tmux to at least start
on Sun consoles (TERM=sun or sun-color), even if there appear to still be
problems on some boxes (my Blade 100 is fine but edd's Blade 1000 shows odd
screen corruption).
@
text
@d1 1
a1 1
/* $OpenBSD: tty.c,v 1.69 2009/11/09 22:50:29 nicm Exp $ */
d368 1
a368 9
	u_int	i;

	for (i = 0; i < UTF8_SIZE; i++) {
		if (gu->data[i] == 0xff)
			break;
		bufferevent_write(tty->event, &gu->data[i], 1);
		if (tty->log_fd != -1)
			write(tty->log_fd, &gu->data[i], 1);
	}
d370 4
@


1.69
log
@Just ignore tty fd errors rather than dying, stops the server dying if the
session is disconnected abrubtly (eg ssh ~.).
@
text
@d1 1
a1 1
/* $OpenBSD: tty.c,v 1.68 2009/11/05 22:35:28 nicm Exp $ */
d714 2
a715 1
	    !tty_term_has(tty->term, TTYC_CSR)) {
@


1.68
log
@Clear to the end of the screen from the right starting point when drawing
line-by-line (in panes or if ed not supported). Fixes problem spotted by Frank
Terbeck.
@
text
@d1 1
a1 1
/* $OpenBSD: tty.c,v 1.67 2009/11/05 08:45:08 nicm Exp $ */
a140 1
	fatalx("lost terminal");
@


1.67
log
@Switch tty key input over to happen on a read event. This is a bit more
complicated because of escape input, but in that case instead of processing a
key immediately, schedule a timer and reprocess the bufer when it expires.

This currently assumes that keys will be atomic (ie that if eg F1 is pressed
the entire sequence is present in the buffer). This is usually but not always
true, a change in the tree format so it can differentiate potential (partial)
key sequences will happens soon and will allow this to be fixed.
@
text
@d1 1
a1 1
/* $OpenBSD: tty.c,v 1.66 2009/11/04 21:47:42 nicm Exp $ */
d787 1
a787 1
		for (j = ctx->ocy; j < screen_size_y(s); j++) {
@


1.66
log
@Switch tty fds over to a bufferevent.
@
text
@d1 1
a1 1
/* $OpenBSD: tty.c,v 1.65 2009/11/04 15:59:27 nicm Exp $ */
d31 1
d117 1
a117 1
	    tty->fd, NULL, NULL, tty_error_callback, tty);
d129 9
d272 1
@


1.65
log
@Ignore the colour on space, /not/ the attributes.
@
text
@d1 1
a1 1
/* $OpenBSD: tty.c,v 1.64 2009/11/04 13:34:26 nicm Exp $ */
d31 2
d113 1
a113 2
	tty->in = buffer_create(BUFSIZ);
	tty->out = buffer_create(BUFSIZ);
d115 2
a116 1
	tty->flags &= ~(TTY_NOCURSOR|TTY_FREEZE|TTY_ESCAPE);
d128 7
d148 2
d201 2
d265 2
a269 3
		buffer_destroy(tty->in);
		buffer_destroy(tty->out);

d323 1
a323 1
	buffer_write(tty->out, s, strlen(s));
d336 1
a336 1
	buffer_write8(tty->out, ch);
d363 1
a363 1
		buffer_write8(tty->out, gu->data[i]);
@


1.64
log
@Fix the reverse emulation when a terminal doesn't have setab to use the correct
fg/bg (adjusted if spaces) and happen before attribute setting.
@
text
@d1 1
a1 1
/* $OpenBSD: tty.c,v 1.63 2009/10/28 08:52:36 nicm Exp $ */
a1128 1

a1132 3
		gc2.attr = tc->attr & ~GRID_ATTR_REVERSE;
		gc2.attr |= gc->attr & GRID_ATTR_REVERSE;

@


1.63
log
@Add a minor optimisatin: if the character being printed is space, don't worry
about setting the background colour or attributes (except reverse).
@
text
@d1 1
a1 1
/* $OpenBSD: tty.c,v 1.62 2009/10/28 08:33:20 nicm Exp $ */
d1124 1
a1124 1
	u_int			 fg = gc->fg, bg = gc->bg, attr = gc->attr;
a1139 10
	/* If any bits are being cleared, reset everything. */
	if (tc->attr & ~attr)
		tty_reset(tty);

	/*
	 * Set the colours. This may call tty_reset() (so it comes next) and
	 * may add to the desired attributes in attr.
	 */
	tty_colours(tty, gc, &attr);

d1146 8
a1153 3
		if (attr & GRID_ATTR_REVERSE) {
			if (fg != 7 && fg != 8)
				attr &= ~GRID_ATTR_REVERSE;
d1155 2
a1156 2
			if (bg != 0 && bg != 8)
				attr |= GRID_ATTR_REVERSE;
d1160 11
d1172 2
a1173 2
	changed = attr & ~tc->attr;
	tc->attr = attr;
@


1.62
log
@Twaek this slightly to avoid confusing use of flags variable.
@
text
@d1 1
a1 1
/* $OpenBSD: tty.c,v 1.61 2009/10/28 08:27:33 nicm Exp $ */
d1122 1
a1122 1
	struct grid_cell	*tc = &tty->cell;
d1126 14
d1202 1
a1202 1
		return;  
@


1.61
log
@Setting SGR0 when setting the fg and bg has problems if only one of the two is
meant to be default, so rewrite the code to move this outside, move setting
colours before attributes and generally clean up.

Tested by sthen@@, fixes problems he was seeing with mutt and should fix some
existing problems with (rarely) lost attributes.
@
text
@d1 1
a1 1
/* $OpenBSD: tty.c,v 1.60 2009/10/26 21:42:04 deraadt Exp $ */
d1182 2
a1183 3
	u_char			 fg = gc->fg, bg = gc->bg;
	int			 flags, have_ax;
	int			 fg_default, bg_default;
d1186 3
a1188 3
	flags = (gc->flags ^ tc->flags) & (GRID_FLAG_FG256|GRID_FLAG_BG256);
	if (fg == tc->fg && bg == tc->bg && flags == 0)
		return;
d1196 2
a1197 2
	fg_default = (fg == 8 && !(gc->flags & GRID_FLAG_FG256));
	bg_default = (bg == 8 && !(gc->flags & GRID_FLAG_BG256));
d1233 1
a1233 1
	    ((gc->flags & GRID_FLAG_FG256) != (tc->flags & GRID_FLAG_FG256))))
d1241 1
a1241 1
	    ((gc->flags & GRID_FLAG_BG256) != (tc->flags & GRID_FLAG_BG256))))
@


1.60
log
@tabs are better; ok nicm
@
text
@d1 1
a1 1
/* $OpenBSD: tty.c,v 1.59 2009/10/25 21:11:21 nicm Exp $ */
d36 3
a38 2
void	tty_attributes_fg(struct tty *, const struct grid_cell *);
void	tty_attributes_bg(struct tty *, const struct grid_cell *);
d1124 11
a1134 1
	u_int			 fg, bg, attr;
a1140 1
	fg = gc->fg; bg = gc->bg; attr = gc->attr;
a1150 4
	/* If any bits are being cleared, reset everything. */
	if (tc->attr & ~attr)
		tty_reset(tty);

a1175 18

	/* Set foreground colour. */
	if (fg != tc->fg ||
	    (gc->flags & GRID_FLAG_FG256) != (tc->flags & GRID_FLAG_FG256)) {
		tty_attributes_fg(tty, gc);
		tc->fg = fg;
		tc->flags &= ~GRID_FLAG_FG256;
		tc->flags |= gc->flags & GRID_FLAG_FG256;
	}

	/* Set background colour. */
	if (bg != tc->bg ||
	    (gc->flags & GRID_FLAG_BG256) != (tc->flags & GRID_FLAG_BG256)) {
		tty_attributes_bg(tty, gc);
		tc->bg = bg;
		tc->flags &= ~GRID_FLAG_BG256;
		tc->flags |= gc->flags & GRID_FLAG_BG256;
	}
d1178 2
a1179 2
int
tty_try_256(struct tty *tty, u_char colour, const char *type)
d1181 9
a1189 1
	char	s[32];
d1191 40
a1230 3
	if (!(tty->term->flags & TERM_256COLOURS) &&
	    !(tty->term_flags & TERM_256COLOURS))
		return (-1);
d1232 4
a1235 4
	xsnprintf(s, sizeof s, "\033[%s;5;%hhum", type, colour);
	tty_puts(tty, s);
	return (0);
}
d1237 7
a1243 13
int
tty_try_88(struct tty *tty, u_char colour, const char *type)
{
	char	s[32];

	if (!(tty->term->flags & TERM_88COLOURS) &&
	    !(tty->term_flags & TERM_88COLOURS))
		return (-1);
	colour = colour_256to88(colour);

	xsnprintf(s, sizeof s, "\033[%s;5;%hhum", type, colour);
	tty_puts(tty, s);
	return (0);
d1247 1
a1247 1
tty_attributes_fg(struct tty *tty, const struct grid_cell *gc)
d1249 2
a1250 1
	u_char	fg;
d1252 1
a1252 1
	fg = gc->fg;
d1254 1
d1256 1
a1256 1
			return;
d1258 3
a1260 1
			return;
d1264 3
a1266 4
			tty_putcode(tty, TTYC_BOLD);
			tty->cell.attr |= GRID_ATTR_BRIGHT;
		} else if (tty->cell.attr & GRID_ATTR_BRIGHT)
			tty_reset(tty);
d1269 8
a1276 16
	if (fg == 8) {
		if (tty_term_has(tty->term, TTYC_AX)) {
			/* AX is an extension that means \033[39m works. */
			tty_puts(tty, "\033[39m");	
		} else if (tty_term_has(tty->term, TTYC_OP)) {
			/*
			 * op can be used to look for default colours but there
			 * is no point in using it - with some terminals it
			 * does SGR0 and others not, so SGR0 is needed anyway
			 * to put the terminal into a known state.
			 */
			tty_reset(tty);
		} else
			tty_putcode1(tty, TTYC_SETAF, 7);
	} else
		tty_putcode1(tty, TTYC_SETAF, fg);
d1280 1
a1280 1
tty_attributes_bg(struct tty *tty, const struct grid_cell *gc)
d1282 2
a1283 1
	u_char	bg;
d1285 1
a1285 1
	bg = gc->bg;
d1287 1
d1289 1
a1289 1
			return;
d1291 6
a1296 1
			return;
d1302 37
a1338 9
	if (bg == 8) {
		if (tty_term_has(tty->term, TTYC_AX)) {
			tty_puts(tty, "\033[49m");	
		} else if (tty_term_has(tty->term, TTYC_OP))
			tty_reset(tty);
		else
			tty_putcode1(tty, TTYC_SETAB, 0);
	} else
		tty_putcode1(tty, TTYC_SETAB, bg);
@


1.59
log
@Remove the -d flag to tmux and just use op/AX to detect default colours.

Irritatingly, although op can be used to tell if a terminal supports default
colours, it can't be used to set them because in some terminfo descriptions it
resets attributes as a side-effect (acts as sgr0) and in others it doesn't, so
it is not possible to determine reliably what the terminal state will be
afterwards. So if AX is missing and op is present, tmux just sends sgr0.

Anyone using -d for a terminal who finds they actually needed it can replace it
using terminal-overrides, but please let me know as it is probably an omission
from terminfo.
@
text
@d1 1
a1 1
/* $OpenBSD: tty.c,v 1.58 2009/10/21 19:27:09 nicm Exp $ */
d147 1
a147 1
        tio.c_cc[VTIME] = 0;
@


1.58
log
@Unused variable.
@
text
@d1 1
a1 1
/* $OpenBSD: tty.c,v 1.57 2009/10/21 16:52:30 nicm Exp $ */
d1239 15
a1253 7
	if (fg == 8 &&
	    !(tty->term->flags & TERM_HASDEFAULTS) &&
	    !(tty->term_flags & TERM_HASDEFAULTS))
		fg = 7;
	if (fg == 8)
		tty_puts(tty, "\033[39m");
	else
d1273 8
a1280 7
	if (bg == 8 &&
	    !(tty->term->flags & TERM_HASDEFAULTS) &&
	    !(tty->term_flags & TERM_HASDEFAULTS))
		bg = 0;
	if (bg == 8)
		tty_puts(tty, "\033[49m");
	else
@


1.57
log
@Now we are correctly not redrawing the whole pane on linefeed, redo the
last-cursor-position code to move to the right position when panes reach EOL.
@
text
@d1 1
a1 1
/* $OpenBSD: tty.c,v 1.56 2009/10/21 13:42:44 nicm Exp $ */
d854 1
a854 1
	u_int			 cx, sx;
@


1.56
log
@Don't redraw the scroll region on linefeed/reverse index unless it is necessary
(the cursor is at the bottom/top). Should fix slow cursor movement when using
vi in a pane spotted by pirofti@@.
@
text
@d1 1
a1 1
/* $OpenBSD: tty.c,v 1.55 2009/10/21 09:36:53 nicm Exp $ */
d854 1
a854 1
	u_int			 cx;
d858 14
a871 7
	/*
	 * Should the cursor be in the last cursor position ready for a natural
	 * wrap? If so - and it isn't - move to and rewrite the last cell.
	 */
	if (!(tty->term->flags & TERM_EARLYWRAP) &&
	    ctx->ocx + wp->xoff > tty->sx - ctx->last_width) {
		if (tty->cx < tty->sx) {
@


1.55
log
@Some terminals don't correctly clear their let's-wrap flag after changing the
scroll region (which moves the cursor to 0,0). This means that if the cursor
was at the edge of the screen, any further output after scroll region change
incorrectly causes a line wrap. Add a workaround to move the cursor to position
0 if it is at the screen edge before changing scroll region.
@
text
@d1 1
a1 1
/* $OpenBSD: tty.c,v 1.54 2009/10/20 19:18:28 nicm Exp $ */
d687 3
d696 6
a701 8
	if (ctx->ocy == ctx->orupper) {
		tty_reset(tty);

		tty_region_pane(tty, ctx, ctx->orupper, ctx->orlower);
		tty_cursor_pane(tty, ctx, ctx->ocx, ctx->orupper);

		tty_putcode(tty, TTYC_RI);
	}
d710 3
d727 6
a732 8
	if (ctx->ocy == ctx->orlower) {
		tty_reset(tty);

		tty_region_pane(tty, ctx, ctx->orupper, ctx->orlower);
		tty_cursor_pane(tty, ctx, ctx->ocx, ctx->ocy);

		tty_putc(tty, '\n');
	}
@


1.54
log
@Try to reduce the UTF-8 mess.

Get rid of passing around u_char[4]s and define a struct utf8_data which has
character data, size (sequence length) and width. Move UTF-8 character
collection into two functions utf8_open/utf8_append in utf8.c which fill in
this struct and use these functions from input.c and the various functions in
screen-write.c.

Space for rather more data than is necessary for one UTF-8 sequence is in the
utf8_data struct because screen_write_copy is still nasty and needs to reinject
the character (after combining) into screen_write_cell.
@
text
@d1 1
a1 1
/* $OpenBSD: tty.c,v 1.53 2009/10/20 17:33:33 nicm Exp $ */
d957 9
@


1.53
log
@UTF-8 combined character fixes.

Thai can have treble combinations (1 x width=1 then 2 x width=0) so bump the
UTF-8 cell data size to 9 and alter the code to allow this.

Also break off the combining code into a separate function, handle any further
combining beyond the buffer size by replacing the character with _s, and when
redrawing the UTF-8 character don't assume the first part has just been
printed, redraw the entire line.
@
text
@d1 1
a1 1
/* $OpenBSD: tty.c,v 1.52 2009/10/20 16:32:23 nicm Exp $ */
d345 1
a345 1
	u_int	i, width;
d355 1
a355 2
	width = utf8_width(gu->data);
	tty->cx += width;
@


1.52
log
@Move the check for whether to force a line wrapper lower down into the tty code
where it has access to the tty width, which is what should have been checked.
@
text
@d1 1
a1 1
/* $OpenBSD: tty.c,v 1.51 2009/10/17 08:35:38 nicm Exp $ */
d877 1
a877 2
	u_char	*ptr = ctx->ptr;
	size_t	 i;
d879 5
a883 5
	for (i = 0; i < UTF8_SIZE; i++) {
		if (ptr[i] == 0xff)
			break;
		tty_putc(tty, ptr[i]);
	}
@


1.51
log
@Always move the cursor position on !xenl terminals, since there is no invisible
last cursor position.

Also nuke an unused variable.
@
text
@d1 1
a1 1
/* $OpenBSD: tty.c,v 1.50 2009/10/17 08:24:46 nicm Exp $ */
d715 8
@


1.50
log
@Instead of having a complicated check to see if the cursor is in the last
position to avoid an explicit wrap, actually move it there.

Some UTF-8 fixes to come.
@
text
@d1 1
a1 1
/* $OpenBSD: tty.c,v 1.49 2009/10/16 19:09:40 nicm Exp $ */
d853 2
a854 1
	if (ctx->ocx + wp->xoff > tty->sx - ctx->last_width) {
@


1.49
log
@When checking whether the region will scroll and the cursor position is thus
unsuitable for using CUD/CUU, check the current cursor position not the target
position.
@
text
@d1 1
a1 1
/* $OpenBSD: tty.c,v 1.48 2009/10/13 08:37:15 nicm Exp $ */
d459 1
a459 1
	 * itself; much the same as the conditions in tty_cmd_cell.
d845 1
a845 2
	struct grid_line	*gl;
	u_int			 wx, wy;
a848 3
	wx = ctx->ocx + wp->xoff;
	wy = ctx->ocy + wp->yoff;

d850 2
a851 10
	 * If:
	 * 
	 * - the line was wrapped:
	 * - the cursor is beyond the edge of the screen,
	 * - the desired position is at the left,
	 * - and either a) the desired next line is the one below the current
	 *   or b) the current line is the bottom of the scroll region,
	 *
	 * Then just printing the next character will be enough to scroll into
	 * place, so don't do an explicit cursor move.
d853 7
a859 7
	gl = NULL;
	if (ctx->ocy != 0)
		gl = &s->grid->linedata[s->grid->hsize + ctx->ocy - 1];
	if (wy == 0 || (gl != NULL && !(gl->flags & GRID_LINE_WRAPPED)) ||
	    tty->cx < tty->sx ||	/* not at edge of screen */
	    wx != 0 ||			/* don't want 0 next */
	    (wy != tty->cy + 1 && tty->cy != ctx->orlower + wp->yoff))
@


1.48
log
@Don't try to use \n across scroll region when doing \r\n either.
@
text
@d1 1
a1 1
/* $OpenBSD: tty.c,v 1.47 2009/10/13 00:44:16 nicm Exp $ */
d1060 1
a1060 1
		if (cy != tty->rupper && 
d1067 1
a1067 1
		if (cy != tty->rlower &&
@


1.47
log
@Instead of using something sort of similar for both newline checks, use
something the same. Doesn't fix the bug I'm looking for though :-/.
@
text
@d1 1
a1 1
/* $OpenBSD: tty.c,v 1.46 2009/10/12 17:19:47 nicm Exp $ */
d1007 1
a1007 1
	if (cx == 0 && cy == thisy + 1) {
@


1.46
log
@When drawing lines that have wrapped naturally, don't force a newline but
permit them to wrap naturally again. This allows terminals that use this to
guess where lines start and end for eg mouse selecting (like xterm) to work
correctly.

This was another long-standing issue raised by several people over the last
while.

Thanks to martynas@@ for much testing. This was not trivial to get right so
bringing it in for wider testing and adn to fix any further glitches in-tree.
@
text
@d1 1
a1 1
/* $OpenBSD: tty.c,v 1.45 2009/10/12 16:41:02 nicm Exp $ */
d464 3
a466 2
	if (ox != 0 || (gl != NULL && !(gl->flags & GRID_LINE_WRAPPED)) ||
	    tty->cy != oy + py - 1 || tty->cx < tty->sx)
@


1.45
log
@Don't run through the column unchanged case if the row was unchanged but there
were no suitable optimisations, instead make it an else to fall through to
absolute addressing.
@
text
@d1 1
a1 1
/* $OpenBSD: tty.c,v 1.44 2009/10/12 16:37:43 nicm Exp $ */
d330 4
a333 3
		if (tty->cx == sx) {
			tty->cx = 0;
			tty->cy++;
d444 1
d457 11
a467 1
	tty_cursor(tty, ox, oy + py);
d842 30
a871 1
	tty_cursor_pane(tty, ctx, ctx->ocx, ctx->ocy);
@


1.44
log
@If the vertical cursor movement crosses the scroll region, CUU and CUD
shouldn't be used even if VPA isn't present - in that case CUP should be used.
@
text
@d1 1
a1 1
/* $OpenBSD: tty.c,v 1.43 2009/10/12 14:54:19 nicm Exp $ */
d971 1
a971 1
	/* Row staying the same. */
d973 4
d1012 4
a1015 1
	}
a1016 2
	/* Column staying the same. */
	if (cx == thisx ) {
@


1.43
log
@Use absolute movement if right at the end of the line as it isn't a reliable
place to move from relatively.
@
text
@d1 1
a1 1
/* $OpenBSD: tty.c,v 1.42 2009/10/12 13:01:18 nicm Exp $ */
d1030 1
a1030 1
		 * Use VPA if change is larger than absolute or if this change
d1033 1
a1033 1
		if ((abs(change) > cy ||
d1035 5
a1039 4
		    (change > 0 && cy - change < tty->rupper)) &&
		    tty_term_has(term, TTYC_VPA)) {
			tty_putcode1(tty, TTYC_VPA, cy);
			goto out;
@


1.42
log
@Use relative cursor movement instead of absolute when possible and when
supported by the terminal to reduce the size of the output data (generally
about 10-20%).
@
text
@d1 1
a1 1
/* $OpenBSD: tty.c,v 1.41 2009/10/12 09:29:58 nicm Exp $ */
a947 2
	if (thisx > tty->sx - 1)
		thisx = tty->sx - 1;
d954 4
d1048 1
@


1.41
log
@Similarly add a tty_cursor_pane function to tidy up most of the calls.
@
text
@d1 1
a1 1
/* $OpenBSD: tty.c,v 1.39 2009/10/12 09:09:35 nicm Exp $ */
d24 1
d920 1
a920 1
	
d927 1
d936 1
d940 24
a963 2
	if (cx == 0 && tty->cx != 0 && tty->cy == cy) {
		tty->cx = 0;
d965 41
a1005 4
	} else if (tty->cx != cx || tty->cy != cy) {
		tty->cx = cx;
		tty->cy = cy;
		tty_putcode2(tty, TTYC_CUP, tty->cy, tty->cx);
d1007 45
@


1.40
log
@_absolute is redundant, just use tty_region.
@
text
@d454 1
a454 1
	tty_cursor(tty, 0, py, ox, oy);
d480 1
a480 1
	tty_cursor(tty, sx, py, ox, oy);
d535 2
a536 1
 	tty_cursor(tty, ctx->ocx, ctx->ocy, wp->xoff, wp->yoff);
d563 2
a564 1
 	tty_cursor(tty, ctx->ocx, ctx->ocy, wp->xoff, wp->yoff);
d585 1
a586 1
 	tty_cursor(tty, ctx->ocx, ctx->ocy, wp->xoff, wp->yoff);
d605 1
a606 1
 	tty_cursor(tty, ctx->ocx, ctx->ocy, wp->xoff, wp->yoff);
d619 2
a620 1
 	tty_cursor(tty, 0, ctx->ocy, wp->xoff, wp->yoff);
d639 2
a640 1
	tty_cursor(tty, ctx->ocx, ctx->ocy, wp->xoff, wp->yoff);
d659 1
a659 1
		tty_cursor(tty, ctx->ocx, ctx->ocy, wp->xoff, wp->yoff);
d662 1
a662 1
		tty_cursor(tty, 0, ctx->ocy, wp->xoff, wp->yoff);
d684 1
a684 1
		tty_cursor(tty, ctx->ocx, ctx->orupper, wp->xoff, wp->yoff);
d706 1
a706 1
		tty_cursor(tty, ctx->ocx, ctx->ocy, wp->xoff, wp->yoff);
d722 1
a722 1
	tty_cursor(tty, ctx->ocx, ctx->ocy, wp->xoff, wp->yoff);
d728 1
a728 1
			tty_cursor(tty, 0, ctx->ocy + 1, wp->xoff, wp->yoff);
d741 1
a741 1
			tty_cursor(tty, 0, j, wp->xoff, wp->yoff);
d758 1
a758 1
	tty_cursor(tty, 0, 0, wp->xoff, wp->yoff);
d769 1
a769 1
			tty_cursor(tty, 0, j, wp->xoff, wp->yoff);
d788 1
a788 1
	tty_cursor(tty, 0, 0, wp->xoff, wp->yoff);
d801 1
a801 1
			tty_cursor(tty, 0, j, wp->xoff, wp->yoff);
d820 1
a820 1
		tty_cursor(tty, 0, j, wp->xoff, wp->yoff);
d829 1
a829 3
	struct window_pane	*wp = ctx->wp;

	tty_cursor(tty, ctx->ocx, ctx->ocy, wp->xoff, wp->yoff);
d927 9
a935 1
tty_cursor(struct tty *tty, u_int cx, u_int cy, u_int ox, u_int oy)
d937 1
a937 1
	if (ox + cx == 0 && tty->cx != 0 && tty->cy == oy + cy) {
d940 3
a942 3
	} else if (tty->cx != ox + cx || tty->cy != oy + cy) {
		tty->cx = ox + cx;
		tty->cy = oy + cy;
@


1.39
log
@Cleanup: use two functions for region setting, one for absolute and one inside
pane.
@
text
@d1 1
a1 1
/* $OpenBSD: tty.c,v 1.38 2009/10/11 22:35:10 nicm Exp $ */
d896 1
d903 1
a903 1
	tty_region_absolute(tty, wp->yoff + rupper, wp->yoff + rlower);
d906 1
d908 1
a908 1
tty_region_absolute(struct tty *tty, u_int rupper, u_int rlower)
@


1.38
log
@Like linefeed, don't set the scroll region for reverse index unless it will be
needed.

While here, also tidy up a couple of long lines and remove an extraneous blank.
@
text
@d1 1
a1 1
/* $OpenBSD: tty.c,v 1.37 2009/10/10 10:36:46 nicm Exp $ */
d582 1
a582 1
 	tty_region(tty, ctx->orupper, ctx->orlower, wp->yoff);
d602 1
a602 1
 	tty_region(tty, ctx->orupper, ctx->orlower, wp->yoff);
d678 2
a679 1
		tty_region(tty, ctx->orupper, ctx->orlower, wp->yoff);
d681 1
d700 2
a701 1
		tty_region(tty, ctx->orupper, ctx->orlower, wp->yoff);
d703 1
d717 1
a717 1
	tty_region(tty, 0, screen_size_y(s) - 1, wp->yoff);
d719 1
d753 1
a753 1
	tty_region(tty, 0, screen_size_y(s) - 1, wp->yoff);
d755 1
d783 1
a783 1
	tty_region(tty, 0, screen_size_y(s) - 1, wp->yoff);
d785 1
d813 1
a813 1
	tty_region(tty, 0, screen_size_y(s) - 1, wp->yoff);
d897 2
a898 1
tty_region(struct tty *tty, u_int rupper, u_int rlower, u_int oy)
d900 10
d912 8
a919 7
	if (tty->rlower != oy + rlower || tty->rupper != oy + rupper) {
		tty->rlower = oy + rlower;
		tty->rupper = oy + rupper;
		tty->cx = 0;
	 	tty->cy = 0;
		tty_putcode2(tty, TTYC_CSR, tty->rupper, tty->rlower);
	}
@


1.37
log
@There is no point setting the scroll region up for line feeds unless scrolling
is actually going to happen, so don't.
@
text
@d1 1
a1 1
/* $OpenBSD: tty.c,v 1.36 2009/10/09 07:33:12 nicm Exp $ */
d465 4
a468 2
			tmpgc.flags = gc->flags & ~(GRID_FLAG_FG256|GRID_FLAG_BG256);
			tmpgc.flags |= s->sel.cell.flags & (GRID_FLAG_FG256|GRID_FLAG_BG256);
a675 4
	tty_reset(tty);

 	tty_region(tty, ctx->orupper, ctx->orlower, wp->yoff);

d677 2
a694 1

@


1.36
log
@The UTF-8 detection idea doesn't work and I am reasonably happy with the
current methods, so remove the (already #ifdef 0'd) code.
@
text
@d1 1
a1 1
/* $OpenBSD: tty.c,v 1.35 2009/10/09 07:23:28 nicm Exp $ */
a695 3
	tty_reset(tty);

 	tty_region(tty, ctx->orupper, ctx->orlower, wp->yoff);
d698 2
@


1.35
log
@Be less aggressive about turning the cursor off, only explicitly turn it off
when tmux is redrawing, otherwise leave in the state set by the application.
@
text
@d1 1
a1 1
/* $OpenBSD: tty.c,v 1.34 2009/09/23 12:03:31 nicm Exp $ */
a136 4
#if 0
	tty_detect_utf8(tty);
#endif

a213 77

#if 0
void
tty_detect_utf8(struct tty *tty)
{
	struct pollfd	pfd;
	char	      	buf[7];
	size_t		len;
	ssize_t		n;
	int		nfds;
	struct termios	tio, old_tio;
	int		 what;

	if (tty->flags & TTY_UTF8)
		return;

	/*
	 * If the terminal looks reasonably likely to support this, try to
	 * write a three-byte UTF-8 wide character to the terminal, then read
	 * the cursor position.
	 *
	 * XXX This entire function is a hack.
	 */

	/* Check if the terminal looks sort of vt100. */
	if (strstr(tty_term_string(tty->term, TTYC_CLEAR), "[2J") == NULL ||
	    strstr(tty_term_string(tty->term, TTYC_CUP), "H") == NULL)
		return;

	if (tcgetattr(tty->fd, &old_tio) != 0)
		fatal("tcgetattr failed");
	cfmakeraw(&tio);
	if (tcsetattr(tty->fd, TCSANOW, &tio) != 0)
		fatal("tcsetattr failed");

	what = 0;
	if (ioctl(tty->fd, TIOCFLUSH, &what) != 0)
		fatal("ioctl(TIOCFLUSH)");

#define UTF8_TEST_DATA "\033[H\357\277\246\033[6n"
	if (write(tty->fd, UTF8_TEST_DATA, (sizeof UTF8_TEST_DATA) - 1) == -1)
		fatal("write failed");
#undef UTF8_TEST_DATA

	len = 0;
	for (;;) {
		pfd.fd = tty->fd;
		pfd.events = POLLIN;

		nfds = poll(&pfd, 1, 500);
		if (nfds == -1) {
			if (errno == EAGAIN || errno == EINTR)
				continue;
			fatal("poll failed");
		}
		if (nfds == 0)
			break;
		if (pfd.revents & (POLLERR|POLLNVAL|POLLHUP))
			break;
		if (!(pfd.revents & POLLIN))
			continue;

		if ((n = read(tty->fd, buf + len, 1)) != 1)
			break;
		buf[++len] = '\0';

		if (len == (sizeof buf) - 1) {
			if (strcmp(buf, "\033[1;3R") == 0)
				tty->flags |= TTY_UTF8;
			break;
		}
	}

	if (tcsetattr(tty->fd, TCSANOW, &old_tio) != 0)
		fatal("tcsetattr failed");
}
#endif
@


1.34
log
@Support -c like sh(1) to execute a command, useful when tmux is a login
shell. Suggested by halex@@.

This includes another protocol version increase (the last for now) so again
restart the tmux server before upgrading.
@
text
@d1 1
a1 1
/* $OpenBSD: tty.c,v 1.33 2009/09/23 07:25:31 nicm Exp $ */
d527 2
d553 2
a554 1
	if (sx >= tty->sx)
d556 1
d566 1
a594 1
			tty_update_mode(&c->tty, c->tty.mode & ~MODE_CURSOR);
@


1.33
log
@Don't die if the client is detaching (the tty has been closed) after waking up
from locking.
@
text
@d1 1
a1 1
/* $OpenBSD: tty.c,v 1.32 2009/09/23 06:18:48 nicm Exp $ */
a46 1
	int	 mode;
a56 4
	if ((mode = fcntl(fd, F_GETFL)) == -1)
		fatal("fcntl failed");
	if (fcntl(fd, F_SETFL, mode|O_NONBLOCK) == -1)
		fatal("fcntl failed");
d127 1
a127 1
	int		 what;
d132 5
d186 1
d197 4
@


1.32
log
@Remove the internal tmux locking and instead detach each client and run the
command specified by a new option "lock-command" (by default "lock -np") in
each client.

This means each terminal has to be unlocked individually but simplifies the
code and allows the system password to be used to unlock.

Note that the set-password command is gone, so it will need to be removed from
configuration files, and the -U command line flag has been removed.

This is the third protocol version change so again it is best to stop the tmux
server before upgrading.
@
text
@d1 1
a1 1
/* $OpenBSD: tty.c,v 1.31 2009/09/23 06:12:58 nicm Exp $ */
d133 3
@


1.31
log
@Trim some code by moving the ioctl(TIOCGWINSZ) after SIGWINCH from the client
into the server.

This is another (the second of four) protocol version changes coming this
morning, so again the server should be killed before upgrading.
@
text
@d1 1
a1 1
/* $OpenBSD: tty.c,v 1.30 2009/09/23 06:05:02 nicm Exp $ */
a30 2

void	tty_raw(struct tty *, const char *);
@


1.30
log
@Don't attempt to open() the tty path, rely on the client sending its stdin fd
with imsg and fatal if it doesn't, then set the FD_CLOEXEC flag in tty_init
instead of tty_open to prevent them leaking into child processes if any are
created between the two calls.

This bumps the protocol version, so the tmux server should be killed before
upgrading.
@
text
@d1 1
a1 1
/* $OpenBSD: tty.c,v 1.29 2009/09/22 19:11:52 nicm Exp $ */
d74 21
@


1.29
log
@Be more careful about what flags are cleared when opening the terminal,
otherwise the opened/started flags are cleared and the terminal never released.
@
text
@d1 1
a1 1
/* $OpenBSD: tty.c,v 1.28 2009/09/10 17:16:24 nicm Exp $ */
d47 1
a47 1
tty_init(struct tty *tty, int fd, char *path, char *term)
d49 4
a52 2
	tty->path = xstrdup(path);
	tty->fd = fd;
d59 13
d79 1
a79 1
	int	mode;
d81 5
a85 6
	if (tty->fd == -1) {
		tty->fd = open(tty->path, O_RDWR|O_NONBLOCK);
		if (tty->fd == -1) {
			xasprintf(cause, "%s: %s", tty->path, strerror(errno));
			return (-1);
		}
a86 12

	if ((mode = fcntl(tty->fd, F_GETFL)) == -1)
		fatal("fcntl failed");
	if (fcntl(tty->fd, F_SETFL, mode|O_NONBLOCK) == -1)
		fatal("fcntl failed");
	if (fcntl(tty->fd, F_SETFD, FD_CLOEXEC) == -1)
		fatal("fcntl failed");

	if (debug_level > 3)
		tty->log_fd = open("tmux.out", O_WRONLY|O_CREAT|O_TRUNC, 0644);
	else
		tty->log_fd = -1;
@


1.28
log
@Permit options such as status-bg to be configured using the entire 256 colour
palette by setting "colour0" to "colour255".
@
text
@d1 1
a1 1
/* $OpenBSD: tty.c,v 1.27 2009/08/31 20:46:19 nicm Exp $ */
d96 1
a96 1
	tty->flags &= TTY_UTF8;
@


1.27
log
@Add a new display-panes command, with two options (display-panes-colour and
display-panes-time), which displays a visual indication of the number of each
pane.
@
text
@d1 1
a1 1
/* $OpenBSD: tty.c,v 1.26 2009/08/21 12:29:59 nicm Exp $ */
d515 2
a516 1
			tmpgc.flags = gc->flags;
@


1.26
log
@Emulate dch/dch1 if missing by redrawing the entire line.
@
text
@d1 1
a1 1
/* $OpenBSD: tty.c,v 1.25 2009/08/14 08:53:52 nicm Exp $ */
a36 1
void	tty_attributes(struct tty *, const struct grid_cell *);
@


1.25
log
@Send SGR0 when initialising the screen. Fixes problems on terminals with BCE
(like putty) if the background colours is non-default when tmux starts. May
also fix problems when resuming a suspended tmux.
@
text
@d1 1
a1 1
/* $OpenBSD: tty.c,v 1.24 2009/08/12 09:41:59 nicm Exp $ */
d599 3
a601 1
	if (wp->xoff != 0 || screen_size_x(s) < tty->sx) {
d609 3
a611 1
	tty_emulate_repeat(tty, TTYC_DCH, TTYC_DCH1, ctx->num);
@


1.24
log
@A tty context must not be modified as it may be reused to update multiple
clients, so make it const.

Also fix an actual modification which caused a hang when a session was
connected to multiple terminals at least one of which was missing ich/ich1.
@
text
@d1 1
a1 1
/* $OpenBSD: tty.c,v 1.23 2009/08/11 22:34:17 nicm Exp $ */
d137 3
a146 2

	memcpy(&tty->cell, &grid_default_cell, sizeof tty->cell);
@


1.23
log
@Initialise log_fd to -1, prevents spurious disconnection of the client when it
ends up as fd 0 (likely if the server is started with "tmux start").

Also add some extra debugging messages to server.c.
@
text
@d1 1
a1 1
/* $OpenBSD: tty.c,v 1.22 2009/08/11 21:28:11 nicm Exp $ */
d41 1
a41 1
void	tty_redraw_region(struct tty *, struct tty_ctx *);
d464 1
a464 1
tty_redraw_region(struct tty *tty, struct tty_ctx *ctx)
d535 2
a536 1
tty_write(void (*cmdfn)(struct tty *, struct tty_ctx *), struct tty_ctx *ctx)
d567 1
a567 1
tty_cmd_insertcharacter(struct tty *tty, struct tty_ctx *ctx)
d571 1
d586 1
a586 1
		while (ctx->num-- > 0)
d593 1
a593 1
tty_cmd_deletecharacter(struct tty *tty, struct tty_ctx *ctx)
d610 1
a610 1
tty_cmd_insertline(struct tty *tty, struct tty_ctx *ctx)
d630 1
a630 1
tty_cmd_deleteline(struct tty *tty, struct tty_ctx *ctx)
d650 1
a650 1
tty_cmd_clearline(struct tty *tty, struct tty_ctx *ctx)
d669 1
a669 1
tty_cmd_clearendofline(struct tty *tty, struct tty_ctx *ctx)
d688 1
a688 1
tty_cmd_clearstartofline(struct tty *tty, struct tty_ctx *ctx)
d706 1
a706 1
tty_cmd_reverseindex(struct tty *tty, struct tty_ctx *ctx)
d728 1
a728 1
tty_cmd_linefeed(struct tty *tty, struct tty_ctx *ctx)
d750 1
a750 1
tty_cmd_clearendofscreen(struct tty *tty, struct tty_ctx *ctx)
d785 1
a785 1
tty_cmd_clearstartofscreen(struct tty *tty, struct tty_ctx *ctx)
d814 1
a814 1
tty_cmd_clearscreen(struct tty *tty, struct tty_ctx *ctx)
d843 1
a843 1
tty_cmd_alignmenttest(struct tty *tty, struct tty_ctx *ctx)
d861 1
a861 1
tty_cmd_cell(struct tty *tty, struct tty_ctx *ctx)
d871 1
a871 1
tty_cmd_utf8character(struct tty *tty, struct tty_ctx *ctx)
@


1.22
log
@Have the client pass its stdin fd to the server when identifying itself and
have the server use that rather than reopening the tty. If the fd isn't given,
use the old behaviour (so no need for a version change).

This allows tmux to be used as the shell, so also change so that when working
out the command to execute if default-command is empty (the default), tmux will
try not execute itself.
@
text
@d1 1
a1 1
/* $OpenBSD: tty.c,v 1.21 2009/08/11 20:29:05 nicm Exp $ */
d52 1
@


1.21
log
@Add a TTY_OPENED flag and tidy a little.
@
text
@d1 1
a1 1
/* $OpenBSD: tty.c,v 1.20 2009/08/11 19:32:25 nicm Exp $ */
d48 1
a48 1
tty_init(struct tty *tty, char *path, char *term)
d51 2
d64 1
a64 1
	int		 mode;
a65 1
	tty->fd = open(tty->path, O_RDWR|O_NONBLOCK);
d67 5
a71 2
		xasprintf(cause, "%s: %s", tty->path, strerror(errno));
		return (-1);
@


1.20
log
@Drop the no_stop argument to tty_close and tty_free in favour of a flag in the
tty struct.
@
text
@d1 1
a1 1
/* $OpenBSD: tty.c,v 1.19 2009/08/08 13:29:27 nicm Exp $ */
d83 5
a87 2
	if (tty->term == NULL)
		goto error;
a100 6

error:
	close(tty->fd);
	tty->fd = -1;

	return (-1);
a288 3
	if (tty->fd == -1)
		return;

d296 6
a301 2
	tty_term_free(tty->term);
	tty_keys_free(tty);
d303 2
a304 2
	close(tty->fd);
	tty->fd = -1;
d306 4
a309 2
	buffer_destroy(tty->in);
	buffer_destroy(tty->out);
@


1.19
log
@Change the way the grid is stored, previously it was:

- a two-dimensional array of cells;
- a two-dimensional array of utf8 data;
- an array of line lengths.

Now it is a single array of a new struct grid_line each of which represents a
line and containts the length and an array of cells and an array of utf8 data.

This will make it easier to add additional per-line members, such as flags.
@
text
@d1 1
a1 1
/* $OpenBSD: tty.c,v 1.18 2009/08/05 16:26:38 nicm Exp $ */
d152 2
d161 4
d290 1
a290 1
tty_close(struct tty *tty, int no_stop)
d300 1
a300 2
	if (!no_stop)
		tty_stop_tty(tty);
d313 1
a313 1
tty_free(struct tty *tty, int no_stop)
d315 1
a315 1
	tty_close(tty, no_stop);
@


1.18
log
@If colours are not supported by the terminal, try to emulate a coloured
background by setting or clearing the reverse attribute.

This makes a few applications which don't use the reverse attribute themselves
a little happier, and allows the status, message and mode options to have
default attributes and fg/bg options that work as expected when set as reverse.
@
text
@d1 1
a1 1
/* $OpenBSD: tty.c,v 1.17 2009/08/03 14:10:54 nicm Exp $ */
d489 2
a490 2
	if (sx > s->grid->size[s->grid->hsize + py])
		sx = s->grid->size[s->grid->hsize + py];
@


1.17
log
@Add a terminal-overrides session option allowing individual terminfo(5) entries
to be overridden. The 88col/256col checks are now moved into the default
setting and out of the code.

Also remove a couple of old workarounds for xterm and rxvt which are no longer
necessary (tmux can emulate them if missing).
@
text
@d1 1
a1 1
/* $OpenBSD: tty.c,v 1.16 2009/07/27 11:33:21 nicm Exp $ */
d954 17
a970 1
	u_int			 fg, bg;
d973 1
a973 1
	if (tc->attr & ~gc->attr)
d977 2
a978 2
	changed = gc->attr & ~tc->attr;
	tc->attr = gc->attr;
a980 2
	fg = gc->fg;
	bg = gc->bg;
@


1.16
log
@Draw UTF-8 characters under the selection correctly.
@
text
@d1 1
a1 1
/* $OpenBSD: tty.c,v 1.15 2009/07/22 20:56:58 nicm Exp $ */
d60 1
a60 1
tty_open(struct tty *tty, char **cause)
d82 2
a83 1
	if ((tty->term = tty_term_find(tty->termname, tty->fd, cause)) == NULL)
@


1.15
log
@tty_write is relatively short and the only function left in tty-write.c so move
it into tty.c.
@
text
@d1 1
a1 1
/* $OpenBSD: tty.c,v 1.14 2009/07/22 20:53:38 nicm Exp $ */
d483 1
d502 4
a505 2
			s->sel.cell.data = gc->data;
			tty_cell(tty, &s->sel.cell, gu);
@


1.14
log
@More tty code tidying: move the saved cursor/region position (from before the
screen was updated) out of struct screen and into struct tty_ctx.
@
text
@d1 1
a1 1
/* $OpenBSD: tty.c,v 1.13 2009/07/22 18:02:23 nicm Exp $ */
d517 31
@


1.13
log
@enum tty_cmd is only used as an index into the array of command function
pointers, so remove it and use the function pointers directly to represent
themselves.
@
text
@d1 1
a1 1
/* $OpenBSD: tty.c,v 1.12 2009/07/22 16:45:31 nicm Exp $ */
d41 1
d44 2
a45 2
void	 tty_cell(struct tty *,
    		     const struct grid_cell *, const struct grid_utf8 *);
d453 1
a453 1
tty_redraw_region(struct tty *tty, struct window_pane *wp)
d455 3
a457 2
	struct screen	*s = wp->screen;
	u_int		 i;
d465 1
a465 1
	if (s->old_rupper - s->old_rlower >= screen_size_y(s) / 2) {
d470 2
a471 2
	if (s->old_cy < s->old_rupper || s->old_cy > s->old_rlower) {
		for (i = s->old_cy; i < screen_size_y(s); i++)
d474 1
a474 1
		for (i = s->old_rupper; i <= s->old_rlower; i++)
d527 1
a527 1
		tty_draw_line(tty, wp->screen, s->old_cy, wp->xoff, wp->yoff);
d533 1
a533 1
 	tty_cursor(tty, s->old_cx, s->old_cy, wp->xoff, wp->yoff);
d552 1
a552 1
		tty_draw_line(tty, wp->screen, s->old_cy, wp->xoff, wp->yoff);
d558 1
a558 1
 	tty_cursor(tty, s->old_cx, s->old_cy, wp->xoff, wp->yoff);
d570 1
a570 1
		tty_redraw_region(tty, wp);
d576 1
a576 1
 	tty_region(tty, s->old_rupper, s->old_rlower, wp->yoff);
d578 1
a578 1
 	tty_cursor(tty, s->old_cx, s->old_cy, wp->xoff, wp->yoff);
d590 1
a590 1
		tty_redraw_region(tty, wp);
d596 1
a596 1
 	tty_region(tty, s->old_rupper, s->old_rlower, wp->yoff);
d598 1
a598 1
 	tty_cursor(tty, s->old_cx, s->old_cy, wp->xoff, wp->yoff);
d611 1
a611 1
 	tty_cursor(tty, 0, s->old_cy, wp->xoff, wp->yoff);
d630 1
a630 1
	tty_cursor(tty, s->old_cx, s->old_cy, wp->xoff, wp->yoff);
d635 1
a635 1
		for (i = s->old_cx; i < screen_size_x(s); i++)
a643 1
	struct screen		*s = wp->screen;
d649 1
a649 1
		tty_cursor(tty, s->old_cx, s->old_cy, wp->xoff, wp->yoff);
d652 2
a653 2
		tty_cursor(tty, 0, s->old_cy, wp->xoff, wp->yoff);
		for (i = 0; i < s->old_cx + 1; i++)
d666 1
a666 1
		tty_redraw_region(tty, wp);
d672 1
a672 1
 	tty_region(tty, s->old_rupper, s->old_rlower, wp->yoff);
d674 2
a675 2
	if (s->old_cy == s->old_rupper) {
		tty_cursor(tty, s->old_cx, s->old_rupper, wp->xoff, wp->yoff);
d688 1
a688 1
		tty_redraw_region(tty, wp);
d694 1
a694 1
 	tty_region(tty, s->old_rupper, s->old_rlower, wp->yoff);
d696 2
a697 2
	if (s->old_cy == s->old_rlower) {
		tty_cursor(tty, s->old_cx, s->old_cy, wp->xoff, wp->yoff);
d712 1
a712 1
	tty_cursor(tty, s->old_cx, s->old_cy, wp->xoff, wp->yoff);
d716 3
a718 3
		if (s->old_cy != screen_size_y(s) - 1) {
			tty_cursor(tty, 0, s->old_cy + 1, wp->xoff, wp->yoff);
			for (i = s->old_cy + 1; i < screen_size_y(s); i++) {
d727 1
a727 1
		for (i = s->old_cx; i < screen_size_x(s); i++)
d729 1
a729 1
		for (j = s->old_cy; j < screen_size_y(s); j++) {
d750 1
a750 1
		for (i = 0; i < s->old_cy; i++) {
d756 1
a756 1
		for (j = 0; j < s->old_cy; j++) {
d762 1
a762 1
	for (i = 0; i <= s->old_cx; i++)
a816 1
	struct screen		*s = wp->screen;
d818 1
a818 1
	tty_cursor(tty, s->old_cx, s->old_cy, wp->xoff, wp->yoff);
@


1.12
log
@There are relatively few arguments to tty_cmd_* functions now, so tidy them up
by using a struct rather than hiding everything with varargs.
@
text
@d1 1
a1 1
/* $OpenBSD: tty.c,v 1.11 2009/07/22 15:55:32 nicm Exp $ */
d41 4
a44 33
void	tty_cmd_alignmenttest(struct tty *, struct tty_ctx *);
void	tty_cmd_cell(struct tty *, struct tty_ctx *);
void	tty_cmd_clearendofline(struct tty *, struct tty_ctx *);
void	tty_cmd_clearendofscreen(struct tty *, struct tty_ctx *);
void	tty_cmd_clearline(struct tty *, struct tty_ctx *);
void	tty_cmd_clearscreen(struct tty *, struct tty_ctx *);
void	tty_cmd_clearstartofline(struct tty *, struct tty_ctx *);
void	tty_cmd_clearstartofscreen(struct tty *, struct tty_ctx *);
void	tty_cmd_deletecharacter(struct tty *, struct tty_ctx *);
void	tty_cmd_deleteline(struct tty *, struct tty_ctx *);
void	tty_cmd_insertcharacter(struct tty *, struct tty_ctx *);
void	tty_cmd_insertline(struct tty *, struct tty_ctx *);
void	tty_cmd_linefeed(struct tty *, struct tty_ctx *);
void	tty_cmd_utf8character(struct tty *, struct tty_ctx *);
void	tty_cmd_reverseindex(struct tty *, struct tty_ctx *);

void (*tty_cmds[])(struct tty *, struct tty_ctx *) = {
	tty_cmd_alignmenttest,
	tty_cmd_cell,
	tty_cmd_clearendofline,
	tty_cmd_clearendofscreen,
	tty_cmd_clearline,
	tty_cmd_clearscreen,
	tty_cmd_clearstartofline,
	tty_cmd_clearstartofscreen,
	tty_cmd_deletecharacter,
	tty_cmd_deleteline,
	tty_cmd_insertcharacter,
	tty_cmd_insertline,
	tty_cmd_linefeed,
	tty_cmd_utf8character,
	tty_cmd_reverseindex,
};
a515 9
}

void
tty_write(struct tty *tty, enum tty_cmd cmd, struct tty_ctx *ctx)
{
	if (tty->flags & TTY_FREEZE || tty->term == NULL)
		return;
	if (tty_cmds[cmd] != NULL)
		tty_cmds[cmd](tty, ctx);
@


1.11
log
@tty_cmd_raw is only used once, for raw UTF-8 output, so rename it to
tty_cmd_utf8character and eliminate the size argument.
@
text
@d1 1
a1 1
/* $OpenBSD: tty.c,v 1.10 2009/07/10 07:11:59 nicm Exp $ */
d41 15
a55 15
void	tty_cmd_alignmenttest(struct tty *, struct window_pane *, va_list);
void	tty_cmd_cell(struct tty *, struct window_pane *, va_list);
void	tty_cmd_clearendofline(struct tty *, struct window_pane *, va_list);
void	tty_cmd_clearendofscreen(struct tty *, struct window_pane *, va_list);
void	tty_cmd_clearline(struct tty *, struct window_pane *, va_list);
void	tty_cmd_clearscreen(struct tty *, struct window_pane *, va_list);
void	tty_cmd_clearstartofline(struct tty *, struct window_pane *, va_list);
void	tty_cmd_clearstartofscreen(struct tty *, struct window_pane *, va_list);
void	tty_cmd_deletecharacter(struct tty *, struct window_pane *, va_list);
void	tty_cmd_deleteline(struct tty *, struct window_pane *, va_list);
void	tty_cmd_insertcharacter(struct tty *, struct window_pane *, va_list);
void	tty_cmd_insertline(struct tty *, struct window_pane *, va_list);
void	tty_cmd_linefeed(struct tty *, struct window_pane *, va_list);
void	tty_cmd_utf8character(struct tty *, struct window_pane *, va_list);
void	tty_cmd_reverseindex(struct tty *, struct window_pane *, va_list);
d57 1
a57 1
void (*tty_cmds[])(struct tty *, struct window_pane *, va_list) = {
d548 1
a548 2
tty_vwrite(
    struct tty *tty, struct window_pane *wp, enum tty_cmd cmd, va_list ap)
d553 1
a553 1
		tty_cmds[cmd](tty, wp, ap);
d557 1
a557 1
tty_cmd_insertcharacter(struct tty *tty, struct window_pane *wp, va_list ap)
d559 2
a560 2
	struct screen	*s = wp->screen;
	u_int		 ua;
a566 2
	ua = va_arg(ap, u_int);

d572 1
a572 1
		tty_emulate_repeat(tty, TTYC_ICH, TTYC_ICH1, ua);
d575 1
a575 1
		while (ua-- > 0)
d582 1
a582 1
tty_cmd_deletecharacter(struct tty *tty, struct window_pane *wp, va_list ap)
d584 2
a585 2
	struct screen	*s = wp->screen;
	u_int		 ua;
a591 2
	ua = va_arg(ap, u_int);

d595 1
a595 1
	tty_emulate_repeat(tty, TTYC_DCH, TTYC_DCH1, ua);
d599 1
a599 1
tty_cmd_insertline(struct tty *tty, struct window_pane *wp, va_list ap)
d601 2
a602 2
	struct screen	*s = wp->screen;
	u_int		 ua;
a609 2
	ua = va_arg(ap, u_int);

d615 1
a615 1
	tty_emulate_repeat(tty, TTYC_IL, TTYC_IL1, ua);
d619 1
a619 1
tty_cmd_deleteline(struct tty *tty, struct window_pane *wp, va_list ap)
d621 2
a622 2
	struct screen	*s = wp->screen;
	u_int		 ua;
a629 2
	ua = va_arg(ap, u_int);

d635 1
a635 1
	tty_emulate_repeat(tty, TTYC_DL, TTYC_DL1, ua);
d639 1
a639 1
tty_cmd_clearline(struct tty *tty, struct window_pane *wp, unused va_list ap)
d641 3
a643 2
	struct screen	*s = wp->screen;
	u_int		 i;
d658 1
a658 2
tty_cmd_clearendofline(
    struct tty *tty, struct window_pane *wp, unused va_list ap)
d660 3
a662 2
	struct screen	*s = wp->screen;
	u_int		 i;
d677 1
a677 2
tty_cmd_clearstartofline(
    struct tty *tty, struct window_pane *wp, unused va_list ap)
d679 3
a681 2
	struct screen	*s = wp->screen;
	u_int		 i;
d696 1
a696 1
tty_cmd_reverseindex(struct tty *tty, struct window_pane *wp, unused va_list ap)
d698 2
a699 1
	struct screen	*s = wp->screen;
d718 1
a718 1
tty_cmd_linefeed(struct tty *tty, struct window_pane *wp, unused va_list ap)
d720 2
a721 1
	struct screen	*s = wp->screen;
d740 1
a740 2
tty_cmd_clearendofscreen(
    struct tty *tty, struct window_pane *wp, unused va_list ap)
d742 3
a744 2
	struct screen	*s = wp->screen;
	u_int		 i, j;
d775 1
a775 2
tty_cmd_clearstartofscreen(
    struct tty *tty, struct window_pane *wp, unused va_list ap)
d777 3
a779 2
	struct screen	*s = wp->screen;
	u_int		 i, j;
d804 1
a804 2
tty_cmd_clearscreen(
    struct tty *tty, struct window_pane *wp, unused va_list ap)
d806 3
a808 2
	struct screen	*s = wp->screen;
	u_int		 i, j;
d833 1
a833 2
tty_cmd_alignmenttest(
    struct tty *tty, struct window_pane *wp, unused va_list ap)
d835 3
a837 2
	struct screen	*s = wp->screen;
	u_int		 i, j;
d851 1
a851 1
tty_cmd_cell(struct tty *tty, struct window_pane *wp, va_list ap)
d853 1
a854 5
	struct grid_cell	*gc;
	struct grid_utf8	*gu;

	gc = va_arg(ap, struct grid_cell *);
	gu = va_arg(ap, struct grid_utf8 *);
d858 1
a858 1
	tty_cell(tty, gc, gu);
d862 1
a862 2
tty_cmd_utf8character(
    struct tty *tty, unused struct window_pane *wp, va_list ap)
d864 1
a864 1
	u_char	*buf;
a866 2
	buf = va_arg(ap, u_char *);
	
d868 1
a868 1
		if (buf[i] == 0xff)
d870 1
a870 1
		tty_putc(tty, buf[i]);
@


1.10
log
@Don't send initialisation strings is1/2/3 (barely anything else does) and move
smcup to the first and rmcup to the last sequences output to the terminal. This
allows tmux to use the alternate screen (smcup/rmcup) when available.
@
text
@d1 1
a1 1
/* $OpenBSD: tty.c,v 1.9 2009/07/07 17:24:32 nicm Exp $ */
d54 1
a54 1
void	tty_cmd_raw(struct tty *, struct window_pane *, va_list);
d71 1
a71 1
	tty_cmd_raw,
d872 2
a873 1
tty_cmd_raw(struct tty *tty, unused struct window_pane *wp, va_list ap)
d876 1
a876 1
	size_t	 i, len;
d879 4
a882 3
	len = va_arg(ap, size_t);

	for (i = 0; i < len; i++)
d884 1
@


1.9
log
@Handle empty or unset TERM correctly; also fix a fatal() message while here.
@
text
@d1 1
a1 1
/* $OpenBSD: tty.c,v 1.8 2009/06/27 12:57:14 nicm Exp $ */
d160 1
a160 3
	tty_putcode(tty, TTYC_IS1);
	tty_putcode(tty, TTYC_IS2);
	tty_putcode(tty, TTYC_IS3);
a161 1
	tty_putcode(tty, TTYC_SMCUP);
a199 1
	tty_raw(tty, tty_term_string(tty->term, TTYC_RMCUP));
d205 2
@


1.8
log
@Copy the 256-colour flag into the tty saved cell as well as the actual colour,
otherwise colour 8 isn't reset properly.
@
text
@d1 1
a1 1
/* $OpenBSD: tty.c,v 1.7 2009/06/25 06:15:04 nicm Exp $ */
d79 1
a79 1
	if (term == NULL)
d101 1
a101 1
		fatal("fcntl failedo");
@


1.7
log
@Miscellaneous unused functions, including one which was basically a
duplicate. Found by lint.
@
text
@d1 1
a1 1
/* $OpenBSD: tty.c,v 1.6 2009/06/25 05:56:44 nicm Exp $ */
d1008 2
d1017 2
@


1.6
log
@Unused variables. Found by lint, no binary change.
@
text
@d1 1
a1 1
/* $OpenBSD: tty.c,v 1.5 2009/06/24 16:01:02 nicm Exp $ */
a546 10
}

void
tty_write(struct tty *tty, struct window_pane *wp, enum tty_cmd cmd, ...)
{
	va_list	ap;

	va_start(ap, cmd);
	tty_vwrite(tty, wp, cmd, ap);
	va_end(ap);
@


1.5
log
@Trying to predict the cursor position for UTF-8 output in the same way as for
normal eight-bit output is wrong, separate it into a different function. Fixes
spacing when mixing UTF-8 with some escape sequences, notably the way w3m does
it.
@
text
@d1 1
a1 1
/* $OpenBSD: tty.c,v 1.4 2009/06/03 23:30:40 nicm Exp $ */
d762 1
a762 3
	u_int		 i, j, oy;

	oy = wp->yoff;
@


1.4
log
@Implement the DEC alignment test. With the last change this is enough for the
first cursor test in vttest (in ports) to pass; it still shops a few more
problems though.
@
text
@d1 1
a1 1
/* $OpenBSD: tty.c,v 1.3 2009/06/03 23:26:56 nicm Exp $ */
d412 17
d932 1
a932 5
	for (i = 0; i < UTF8_SIZE; i++) {
		if (gu->data[i] == 0xff)
			break;
		tty_putc(tty, gu->data[i]);
	}
@


1.3
log
@Fix some miscalculations when clearing to start of screen: the number of lines
to the cursor is cy not cy - 1, and the current cursor cell should be included.
@
text
@d1 1
a1 1
/* $OpenBSD: tty.c,v 1.2 2009/06/02 23:39:32 nicm Exp $ */
d41 1
d58 1
d832 18
@


1.2
log
@Recent code to try and detect if a terminal supports UTF-8 by printing to it
fails spectacularly on (at least) sparc64, so disable it for now. Thanks to
naddy and Josh Elsasser for help and testing.
@
text
@d1 1
a1 1
/* $OpenBSD: tty.c,v 1.1 2009/06/01 22:58:49 nicm Exp $ */
d800 1
a800 1
	for (i = 0; i < s->old_cx; i++)
@


1.1
log
@Import tmux, a terminal multiplexor allowing (among other things) a single
terminal to be switched between several different windows and programs
displayed on one terminal be detached from one terminal and moved to another.

ok deraadt pirofti
@
text
@d1 1
a1 1
/* $OpenBSD$ */
d137 1
d139 1
d209 1
d284 1
@

