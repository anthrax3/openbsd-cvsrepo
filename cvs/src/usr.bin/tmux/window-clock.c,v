head	1.24;
access;
symbols
	OPENBSD_6_2_BASE:1.24
	OPENBSD_6_1:1.22.0.4
	OPENBSD_6_1_BASE:1.22
	OPENBSD_6_0:1.18.0.2
	OPENBSD_6_0_BASE:1.18
	OPENBSD_5_9:1.17.0.2
	OPENBSD_5_9_BASE:1.17
	OPENBSD_5_8:1.11.0.4
	OPENBSD_5_8_BASE:1.11
	OPENBSD_5_7:1.10.0.2
	OPENBSD_5_7_BASE:1.10
	OPENBSD_5_6:1.10.0.4
	OPENBSD_5_6_BASE:1.10
	OPENBSD_5_5:1.9.0.6
	OPENBSD_5_5_BASE:1.9
	OPENBSD_5_4:1.9.0.2
	OPENBSD_5_4_BASE:1.9
	OPENBSD_5_3:1.8.0.2
	OPENBSD_5_3_BASE:1.8
	OPENBSD_5_2:1.7.0.2
	OPENBSD_5_2_BASE:1.7
	OPENBSD_5_1_BASE:1.6
	OPENBSD_5_1:1.6.0.8
	OPENBSD_5_0:1.6.0.6
	OPENBSD_5_0_BASE:1.6
	OPENBSD_4_9:1.6.0.4
	OPENBSD_4_9_BASE:1.6
	OPENBSD_4_8:1.6.0.2
	OPENBSD_4_8_BASE:1.6
	OPENBSD_4_7:1.5.0.2
	OPENBSD_4_7_BASE:1.5
	OPENBSD_4_6:1.2.0.4
	OPENBSD_4_6_BASE:1.2;
locks; strict;
comment	@ * @;


1.24
date	2017.05.30.21.44.59;	author nicm;	state Exp;
branches;
next	1.23;
commitid	ai2b3hkAsUowPSMm;

1.23
date	2017.05.07.22.27.57;	author nicm;	state Exp;
branches;
next	1.22;
commitid	w7Gc3icV91j6BiYu;

1.22
date	2017.01.07.15.28.13;	author nicm;	state Exp;
branches;
next	1.21;
commitid	llgkTzvAhxXuSWDB;

1.21
date	2016.10.13.20.27.27;	author nicm;	state Exp;
branches;
next	1.20;
commitid	txCyQ5BkKJtZRzfT;

1.20
date	2016.10.11.07.23.34;	author nicm;	state Exp;
branches;
next	1.19;
commitid	leUN1UeapgUoieJj;

1.19
date	2016.10.10.21.51.39;	author nicm;	state Exp;
branches;
next	1.18;
commitid	TaZ3kOtGiWwKofka;

1.18
date	2016.07.15.00.42.56;	author nicm;	state Exp;
branches;
next	1.17;
commitid	EramuEV0ciOaJqkF;

1.17
date	2016.01.19.15.59.12;	author nicm;	state Exp;
branches;
next	1.16;
commitid	P3qmSOx6KrDBsb0c;

1.16
date	2015.11.18.14.27.44;	author nicm;	state Exp;
branches;
next	1.15;
commitid	RjsAPRkWwvS79w40;

1.15
date	2015.11.12.11.05.34;	author nicm;	state Exp;
branches;
next	1.14;
commitid	Ih1tdqtjpnEyfE8x;

1.14
date	2015.10.27.15.58.43;	author nicm;	state Exp;
branches;
next	1.13;
commitid	89xhQafU35Q5MQVC;

1.13
date	2015.09.14.13.22.02;	author nicm;	state Exp;
branches;
next	1.12;
commitid	kxByHmNsW2wTQbKK;

1.12
date	2015.08.28.12.25.42;	author nicm;	state Exp;
branches;
next	1.11;
commitid	6bG4Sc33YFhgSCnx;

1.11
date	2015.04.19.21.34.21;	author nicm;	state Exp;
branches;
next	1.10;
commitid	wug6ctIOfhVMeWQp;

1.10
date	2014.03.31.21.34.08;	author nicm;	state Exp;
branches;
next	1.9;

1.9
date	2013.03.22.10.31.22;	author nicm;	state Exp;
branches;
next	1.8;

1.8
date	2013.02.05.11.08.59;	author nicm;	state Exp;
branches;
next	1.7;

1.7
date	2012.07.10.11.53.01;	author nicm;	state Exp;
branches;
next	1.6;

1.6
date	2010.05.23.19.42.19;	author nicm;	state Exp;
branches;
next	1.5;

1.5
date	2009.12.03.22.50.10;	author nicm;	state Exp;
branches;
next	1.4;

1.4
date	2009.11.26.23.13.47;	author nicm;	state Exp;
branches;
next	1.3;

1.3
date	2009.11.26.21.37.13;	author nicm;	state Exp;
branches;
next	1.2;

1.2
date	2009.06.27.14.40.22;	author nicm;	state Exp;
branches;
next	1.1;

1.1
date	2009.06.01.22.58.49;	author nicm;	state Exp;
branches;
next	;


desc
@@


1.24
log
@Rewrite of choose mode, both to simplify and tidy the code and to add
some modern features.

Now the common code is in mode-tree.c, which provides an API used by the
three modes now separated into window-{buffer,client,tree}.c. Buffer
mode shows buffers, client mode clients and tree mode a tree of
sessions, windows and panes.

Each mode has a common set of key bindings plus a few that are specific
to the mode. Other changes are:

- each mode has a preview pane: for buffers this is the buffer content
  (very useful), for others it is a preview of the pane;

- items may be sorted in different ways ('O' key);

- multiple items may be tagged and an operation applied to all of them
  (for example, to delete multiple buffers at once);

- in tree mode a command may be run on the selected item (session,
  window, pane) or on tagged items (key ':');

- displayed items may be filtered in tree mode by using a format (this
  is used to implement find-window) (key 'f');

- the custom format (-F) for the display is no longer available;

- shortcut keys change from 0-9, a-z, A-Z which was always a bit weird
  with keys used for other uses to 0-9, M-a to M-z.

Now that the code is simpler, other improvements will come later.

Primary key bindings for each mode are documented under the commands in
the man page (choose-buffer, choose-client, choose-tree).

Parts written by Thomas Adam.
@
text
@/* $OpenBSD: window-clock.c,v 1.23 2017/05/07 22:27:57 nicm Exp $ */

/*
 * Copyright (c) 2009 Nicholas Marriott <nicholas.marriott@@gmail.com>
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF MIND, USE, DATA OR PROFITS, WHETHER
 * IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING
 * OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */

#include <sys/types.h>

#include <stdlib.h>
#include <string.h>
#include <time.h>

#include "tmux.h"

static struct screen *window_clock_init(struct window_pane *,
		    struct cmd_find_state *, struct args *);
static void	window_clock_free(struct window_pane *);
static void	window_clock_resize(struct window_pane *, u_int, u_int);
static void	window_clock_key(struct window_pane *, struct client *,
		    struct session *, key_code, struct mouse_event *);

static void	window_clock_timer_callback(int, short, void *);
static void	window_clock_draw_screen(struct window_pane *);

const struct window_mode window_clock_mode = {
	.name = "clock-mode",

	.init = window_clock_init,
	.free = window_clock_free,
	.resize = window_clock_resize,
	.key = window_clock_key,
};

struct window_clock_mode_data {
	struct screen	        screen;
	time_t			tim;
	struct event		timer;
};

const char window_clock_table[14][5][5] = {
	{ { 1,1,1,1,1 }, /* 0 */
	  { 1,0,0,0,1 },
	  { 1,0,0,0,1 },
	  { 1,0,0,0,1 },
	  { 1,1,1,1,1 } },
	{ { 0,0,0,0,1 }, /* 1 */
	  { 0,0,0,0,1 },
	  { 0,0,0,0,1 },
	  { 0,0,0,0,1 },
	  { 0,0,0,0,1 } },
	{ { 1,1,1,1,1 }, /* 2 */
	  { 0,0,0,0,1 },
	  { 1,1,1,1,1 },
	  { 1,0,0,0,0 },
	  { 1,1,1,1,1 } },
	{ { 1,1,1,1,1 }, /* 3 */
	  { 0,0,0,0,1 },
	  { 1,1,1,1,1 },
	  { 0,0,0,0,1 },
	  { 1,1,1,1,1 } },
	{ { 1,0,0,0,1 }, /* 4 */
	  { 1,0,0,0,1 },
	  { 1,1,1,1,1 },
	  { 0,0,0,0,1 },
	  { 0,0,0,0,1 } },
	{ { 1,1,1,1,1 }, /* 5 */
	  { 1,0,0,0,0 },
	  { 1,1,1,1,1 },
	  { 0,0,0,0,1 },
	  { 1,1,1,1,1 } },
	{ { 1,1,1,1,1 }, /* 6 */
	  { 1,0,0,0,0 },
	  { 1,1,1,1,1 },
	  { 1,0,0,0,1 },
	  { 1,1,1,1,1 } },
	{ { 1,1,1,1,1 }, /* 7 */
	  { 0,0,0,0,1 },
	  { 0,0,0,0,1 },
	  { 0,0,0,0,1 },
	  { 0,0,0,0,1 } },
	{ { 1,1,1,1,1 }, /* 8 */
	  { 1,0,0,0,1 },
	  { 1,1,1,1,1 },
	  { 1,0,0,0,1 },
	  { 1,1,1,1,1 } },
	{ { 1,1,1,1,1 }, /* 9 */
	  { 1,0,0,0,1 },
	  { 1,1,1,1,1 },
	  { 0,0,0,0,1 },
	  { 1,1,1,1,1 } },
	{ { 0,0,0,0,0 }, /* : */
	  { 0,0,1,0,0 },
	  { 0,0,0,0,0 },
	  { 0,0,1,0,0 },
	  { 0,0,0,0,0 } },
	{ { 1,1,1,1,1 }, /* A */
	  { 1,0,0,0,1 },
	  { 1,1,1,1,1 },
	  { 1,0,0,0,1 },
	  { 1,0,0,0,1 } },
	{ { 1,1,1,1,1 }, /* P */
	  { 1,0,0,0,1 },
	  { 1,1,1,1,1 },
	  { 1,0,0,0,0 },
	  { 1,0,0,0,0 } },
	{ { 1,0,0,0,1 }, /* M */
	  { 1,1,0,1,1 },
	  { 1,0,1,0,1 },
	  { 1,0,0,0,1 },
	  { 1,0,0,0,1 } },
};

static void
window_clock_timer_callback(__unused int fd, __unused short events, void *arg)
{
	struct window_pane		*wp = arg;
	struct window_clock_mode_data	*data = wp->modedata;
	struct tm			 now, then;
	time_t				 t;
	struct timeval			 tv = { .tv_sec = 1 };

	evtimer_del(&data->timer);
	evtimer_add(&data->timer, &tv);

	t = time(NULL);
	gmtime_r(&t, &now);
	gmtime_r(&data->tim, &then);
	if (now.tm_min == then.tm_min)
		return;
	data->tim = t;

	window_clock_draw_screen(wp);
	server_redraw_window(wp->window);
}

static struct screen *
window_clock_init(struct window_pane *wp, __unused struct cmd_find_state *fs,
    __unused struct args *args)
{
	struct window_clock_mode_data	*data;
	struct screen			*s;
	struct timeval			 tv = { .tv_sec = 1 };

	wp->modedata = data = xmalloc(sizeof *data);
	data->tim = time(NULL);

	evtimer_set(&data->timer, window_clock_timer_callback, wp);
	evtimer_add(&data->timer, &tv);

	s = &data->screen;
	screen_init(s, screen_size_x(&wp->base), screen_size_y(&wp->base), 0);
	s->mode &= ~MODE_CURSOR;

	window_clock_draw_screen(wp);

	return (s);
}

static void
window_clock_free(struct window_pane *wp)
{
	struct window_clock_mode_data	*data = wp->modedata;

	evtimer_del(&data->timer);
	screen_free(&data->screen);
	free(data);
}

static void
window_clock_resize(struct window_pane *wp, u_int sx, u_int sy)
{
	struct window_clock_mode_data	*data = wp->modedata;
	struct screen			*s = &data->screen;

	screen_resize(s, sx, sy, 0);
	window_clock_draw_screen(wp);
}

static void
window_clock_key(struct window_pane *wp, __unused struct client *c,
    __unused struct session *sess, __unused key_code key,
    __unused struct mouse_event *m)
{
	window_pane_reset_mode(wp);
}

static void
window_clock_draw_screen(struct window_pane *wp)
{
	struct window_clock_mode_data	*data = wp->modedata;
	struct screen_write_ctx	 	 ctx;
	int				 colour, style;
	struct screen			*s = &data->screen;
	struct grid_cell		 gc;
	char				 tim[64], *ptr;
	time_t				 t;
	struct tm			*tm;
	u_int				 i, j, x, y, idx;

	colour = options_get_number(wp->window->options, "clock-mode-colour");
	style = options_get_number(wp->window->options, "clock-mode-style");

	screen_write_start(&ctx, NULL, s);

	t = time(NULL);
	tm = localtime(&t);
	if (style == 0) {
		strftime(tim, sizeof tim, "%l:%M ", localtime(&t));
		if (tm->tm_hour >= 12)
			strlcat(tim, "PM", sizeof tim);
		else
			strlcat(tim, "AM", sizeof tim);
	} else
		strftime(tim, sizeof tim, "%H:%M", tm);

	screen_write_clearscreen(&ctx, 8);

	if (screen_size_x(s) < 6 * strlen(tim) || screen_size_y(s) < 6) {
		if (screen_size_x(s) >= strlen(tim) && screen_size_y(s) != 0) {
			x = (screen_size_x(s) / 2) - (strlen(tim) / 2);
			y = screen_size_y(s) / 2;
			screen_write_cursormove(&ctx, x, y);

			memcpy(&gc, &grid_default_cell, sizeof gc);
			gc.flags |= GRID_FLAG_NOPALETTE;
			gc.fg = colour;
			screen_write_puts(&ctx, &gc, "%s", tim);
		}

		screen_write_stop(&ctx);
		return;
	}

	x = (screen_size_x(s) / 2) - 3 * strlen(tim);
	y = (screen_size_y(s) / 2) - 3;

	memcpy(&gc, &grid_default_cell, sizeof gc);
	gc.flags |= GRID_FLAG_NOPALETTE;
	gc.bg = colour;
	for (ptr = tim; *ptr != '\0'; ptr++) {
		if (*ptr >= '0' && *ptr <= '9')
			idx = *ptr - '0';
		else if (*ptr == ':')
			idx = 10;
		else if (*ptr == 'A')
			idx = 11;
		else if (*ptr == 'P')
			idx = 12;
		else if (*ptr == 'M')
			idx = 13;
		else {
			x += 6;
			continue;
		}

		for (j = 0; j < 5; j++) {
			for (i = 0; i < 5; i++) {
				screen_write_cursormove(&ctx, x + i, y + j);
				if (window_clock_table[idx][j][i])
					screen_write_putc(&ctx, &gc, ' ');
			}
		}
		x += 6;
	}

	screen_write_stop(&ctx);
}
@


1.23
log
@Add a format for the name of the pane's mode, lets it be used as a
conditional for key bindings.
@
text
@d1 1
a1 1
/* $OpenBSD: window-clock.c,v 1.22 2017/01/07 15:28:13 nicm Exp $ */
d27 2
a28 1
static struct screen *window_clock_init(struct window_pane *);
d149 2
a150 1
window_clock_init(struct window_pane *wp)
@


1.22
log
@Add support for the OSC 4 and OSC 104 palette setting escape sequences,
from S Gilles.
@
text
@d1 1
a1 1
/* $OpenBSD: window-clock.c,v 1.21 2016/10/13 20:27:27 nicm Exp $ */
d37 2
@


1.21
log
@Add support for BCE (background colour erase). This makes various escape
sequences (notable EL and ED but also IL, DL, ICH, DCH) create blank
cells using the current background colour rather than the default
colour.

On modern systems BCE doesn't really have many benefits, but most other
terminals now support it, some (lazy) applications rely on it, and it is
not hard to include now that we have pane background colours anyway.

Mostly written by Sean Haugh.
@
text
@d1 1
a1 1
/* $OpenBSD: window-clock.c,v 1.20 2016/10/11 07:23:34 nicm Exp $ */
d233 1
d246 1
@


1.20
log
@Fundamental change to how copy mode key bindings work:

The vi-copy and emacs-copy mode key tables are gone, and instead copy
mode commands are bound in one of two normal key tables ("copy-mode" or
"copy-mode-vi"). Keys are bound to "send-keys -X copy-mode-command". So:

    bind -temacs-copy C-Up scroll-up
    bind -temacs-copy -R5 WheelUpPane scroll-up

Becomes:

    bind -Tcopy-mode C-Up send -X scroll-up
    bind -Tcopy-mode WheelUpPane send -N5 -X scroll-up

This allows the full command parser and command set to be used - for
example, we can use the normal command prompt for searching, jumping,
and so on instead of a custom one:

    bind -Tcopy-mode C-r command-prompt -p'search up' "send -X search-backward '%%'"

command-prompt also gets a -1 option to only require on key press, which
is needed for jumping.

The plan is to get rid of mode keys entirely, so more to come eventually.
@
text
@d1 1
a1 1
/* $OpenBSD: window-clock.c,v 1.19 2016/10/10 21:51:39 nicm Exp $ */
d224 1
a224 1
	screen_write_clearscreen(&ctx);
@


1.19
log
@Add static in cmd-* and fix a few other nits.
@
text
@d1 1
a1 1
/* $OpenBSD: window-clock.c,v 1.18 2016/07/15 00:42:56 nicm Exp $ */
d37 4
a40 4
	window_clock_init,
	window_clock_free,
	window_clock_resize,
	window_clock_key,
@


1.18
log
@Instead of representing colours in several different forms with various
cell flags, convert to use an int with flags marking 256 or RGB colours
in the top byte (except in cells, which we don't want to make any
bigger). From Brad Town.
@
text
@d1 1
a1 1
/* $OpenBSD: window-clock.c,v 1.17 2016/01/19 15:59:12 nicm Exp $ */
d27 5
a31 5
struct screen *window_clock_init(struct window_pane *);
void	window_clock_free(struct window_pane *);
void	window_clock_resize(struct window_pane *, u_int, u_int);
void	window_clock_key(struct window_pane *, struct client *,
	    struct session *, key_code, struct mouse_event *);
d33 2
a34 2
void	window_clock_timer_callback(int, short, void *);
void	window_clock_draw_screen(struct window_pane *);
d122 1
a122 1
void
d145 1
a145 1
struct screen *
d167 1
a167 1
void
d177 1
a177 1
void
d187 1
a187 1
void
d195 1
a195 1
void
@


1.17
log
@I no longer use my SourceForge address so replace it.
@
text
@d1 1
a1 1
/* $OpenBSD: window-clock.c,v 1.16 2015/11/18 14:27:44 nicm Exp $ */
d233 1
a233 1
			colour_set_fg(&gc, colour);
d245 1
a245 1
	colour_set_bg(&gc, colour);
@


1.16
log
@Use __unused rather than rolling our own.
@
text
@d1 1
a1 1
/* $OpenBSD: window-clock.c,v 1.15 2015/11/12 11:05:34 nicm Exp $ */
d4 1
a4 1
 * Copyright (c) 2009 Nicholas Marriott <nicm@@users.sourceforge.net>
@


1.15
log
@Support UTF-8 key bindings by expanding the key type from int to
uint64_t and converting UTF-8 to Unicode on input and the reverse on
output. (This allows key bindings, there are still omissions - the
largest being that the various prompts do not accept UTF-8.)
@
text
@d1 1
a1 1
/* $OpenBSD: window-clock.c,v 1.14 2015/10/27 15:58:43 nicm Exp $ */
d123 1
a123 1
window_clock_timer_callback(unused int fd, unused short events, void *arg)
d188 3
a190 3
window_clock_key(struct window_pane *wp, unused struct client *c,
    unused struct session *sess, unused key_code key,
    unused struct mouse_event *m)
@


1.14
log
@Move struct options into options.c.
@
text
@d1 1
a1 1
/* $OpenBSD: window-clock.c,v 1.13 2015/09/14 13:22:02 nicm Exp $ */
d31 1
a31 1
	    struct session *, int, struct mouse_event *);
d189 2
a190 1
    unused struct session *sess, unused int key, unused struct mouse_event *m)
@


1.13
log
@Remove some extra blank lines.
@
text
@d1 1
a1 1
/* $OpenBSD: window-clock.c,v 1.12 2015/08/28 12:25:42 nicm Exp $ */
d207 2
a208 2
	colour = options_get_number(&wp->window->options, "clock-mode-colour");
	style = options_get_number(&wp->window->options, "clock-mode-style");
@


1.12
log
@Give clock mode its own timer.
@
text
@d1 1
a1 1
/* $OpenBSD: window-clock.c,v 1.11 2015/04/19 21:34:21 nicm Exp $ */
a234 1

@


1.11
log
@Rewrite of tmux mouse support which was a mess. Instead of having
options for "mouse-this" and "mouse-that", mouse events may be bound as
keys and there is one option "mouse" that turns on mouse support
entirely (set -g mouse on).

See the new MOUSE SUPPORT section of the man page for description of the
key names and new flags (-t= to specify the pane or window under mouse
as a target, and send-keys -M to pass through a mouse event).

The default builtin bindings for the mouse are:

    bind -n   MouseDown1Pane select-pane -t=; send-keys -M
    bind -n MouseDown1Status select-window -t=
    bind -n   MouseDrag1Pane copy-mode -M
    bind -n MouseDrag1Border resize-pane -M

To get the effect of turning mode-mouse off, do:

    unbind -n MouseDrag1Pane
    unbind -temacs-copy MouseDrag1Pane

The old mouse options are now gone, set-option -q may be used to
suppress warnings if mixing configuration files.
@
text
@d1 1
a1 1
/* $OpenBSD: window-clock.c,v 1.10 2014/03/31 21:34:08 nicm Exp $ */
a31 1
void	window_clock_timer(struct window_pane *);
d33 1
a40 1
	window_clock_timer,
d46 1
d122 23
d150 1
d155 3
d172 1
a191 18
}

void
window_clock_timer(struct window_pane *wp)
{
	struct window_clock_mode_data	*data = wp->modedata;
	struct tm			 now, then;
	time_t				 t;

	t = time(NULL);
	gmtime_r(&t, &now);
	gmtime_r(&data->tim, &then);
	if (now.tm_min == then.tm_min)
		return;
	data->tim = t;

	window_clock_draw_screen(wp);
	server_redraw_window(wp->window);
@


1.10
log
@Having three *clock* files is ridiculous, remove clock.c.
@
text
@d1 1
a1 1
/* $OpenBSD: window-clock.c,v 1.9 2013/03/22 10:31:22 nicm Exp $ */
d30 2
a31 1
void	window_clock_key(struct window_pane *, struct session *, int);
a40 1
	NULL,
d160 2
a161 2
window_clock_key(
    struct window_pane *wp, unused struct session *sess, unused int key)
@


1.9
log
@No more lint means no more ARGSUSED.
@
text
@d1 1
a1 1
/* $OpenBSD: window-clock.c,v 1.8 2013/02/05 11:08:59 nicm Exp $ */
d49 73
d190 6
d200 62
a261 2
	screen_write_start(&ctx, NULL, &data->screen);
	clock_draw(&ctx, colour, style);
@


1.8
log
@Automatically reflow wrapped lines when a pane is resized, requested by
many over the years and finally implemented by Richard Woodbury.
@
text
@d1 1
a1 1
/* $OpenBSD: window-clock.c,v 1.7 2012/07/10 11:53:01 nicm Exp $ */
a85 1
/* ARGSUSED */
@


1.7
log
@xfree is not particularly helpful, remove it. From Thomas Adam.
@
text
@d1 1
a1 1
/* $OpenBSD: window-clock.c,v 1.6 2010/05/23 19:42:19 nicm Exp $ */
d82 1
a82 1
	screen_resize(s, sx, sy);
@


1.6
log
@Pass in the session, rather than the client, to window modes' key()
function. We were only ever using the client to find the session anyway.

This allows send-key to work properly for manipulating copy mode from
outside tmux.

From Micah Cowan.
@
text
@d1 1
a1 1
/* $OpenBSD: window-clock.c,v 1.5 2009/12/03 22:50:10 nicm Exp $ */
d21 1
d73 1
a73 1
	xfree(data);
@


1.5
log
@Massive spaces->tabs and trailing whitespace cleanup, hopefully for the last
time now I've configured emacs to make them displayed in really annoying
colours...
@
text
@d1 1
a1 1
/* $OpenBSD: window-clock.c,v 1.4 2009/11/26 23:13:47 nicm Exp $ */
d29 1
a29 1
void	window_clock_key(struct window_pane *, struct client *, int);
d88 1
a88 1
    struct window_pane *wp, unused struct client *c, unused int key)
@


1.4
log
@This doesn't need to be u_int.
@
text
@d1 1
a1 1
/* $OpenBSD: window-clock.c,v 1.3 2009/11/26 21:37:13 nicm Exp $ */
d81 1
a81 1
 	screen_resize(s, sx, sy);
@


1.3
log
@Remove a couple of unused arguments where possible, and add /* ARGSUSED */ to
the rest to reduce lint output.
@
text
@d1 1
a1 1
/* $OpenBSD: window-clock.c,v 1.2 2009/06/27 14:40:22 nicm Exp $ */
d116 1
a116 2
	u_int				 colour;
	int				 style;
@


1.2
log
@Use gmtime_r so the current time isn't overwritten, the minute comparison works
and the clock is actually updated. It was already used for lock-server but not
here.
@
text
@d1 1
a1 1
/* $OpenBSD: window-clock.c,v 1.1 2009/06/01 22:58:49 nicm Exp $ */
d85 1
@


1.1
log
@Import tmux, a terminal multiplexor allowing (among other things) a single
terminal to be switched between several different windows and programs
displayed on one terminal be detached from one terminal and moved to another.

ok deraadt pirofti
@
text
@d1 1
a1 1
/* $OpenBSD$ */
d96 1
a96 1
	struct tm			*now, *then;
d100 3
a102 3
	now = gmtime(&t);
	then = gmtime(&data->tim);
	if (now->tm_min == then->tm_min)
@

