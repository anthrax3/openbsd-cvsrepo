head	1.170;
access;
symbols
	OPENBSD_6_0:1.151.0.2
	OPENBSD_6_0_BASE:1.151
	OPENBSD_5_9:1.145.0.2
	OPENBSD_5_9_BASE:1.145
	OPENBSD_5_8:1.130.0.4
	OPENBSD_5_8_BASE:1.130
	OPENBSD_5_7:1.123.0.2
	OPENBSD_5_7_BASE:1.123
	OPENBSD_5_6:1.111.0.4
	OPENBSD_5_6_BASE:1.111
	OPENBSD_5_5:1.102.0.4
	OPENBSD_5_5_BASE:1.102
	OPENBSD_5_4:1.94.0.2
	OPENBSD_5_4_BASE:1.94
	OPENBSD_5_3:1.87.0.2
	OPENBSD_5_3_BASE:1.87
	OPENBSD_5_2:1.81.0.2
	OPENBSD_5_2_BASE:1.81
	OPENBSD_5_1_BASE:1.76
	OPENBSD_5_1:1.76.0.2
	OPENBSD_5_0:1.73.0.2
	OPENBSD_5_0_BASE:1.73
	OPENBSD_4_9:1.66.0.2
	OPENBSD_4_9_BASE:1.66
	OPENBSD_4_8:1.61.0.2
	OPENBSD_4_8_BASE:1.61
	OPENBSD_4_7:1.51.0.2
	OPENBSD_4_7_BASE:1.51
	OPENBSD_4_6:1.2.0.4
	OPENBSD_4_6_BASE:1.2;
locks; strict;
comment	@ * @;


1.170
date	2017.03.24.07.14.27;	author nicm;	state Exp;
branches;
next	1.169;
commitid	rM9AlDAJoNtHb0WX;

1.169
date	2017.03.21.09.51.00;	author nicm;	state Exp;
branches;
next	1.168;
commitid	QdAc6yarMJFMabH3;

1.168
date	2017.03.08.20.05.25;	author nicm;	state Exp;
branches;
next	1.167;
commitid	Grt6OB8xNppaXkqd;

1.167
date	2017.03.08.13.36.12;	author nicm;	state Exp;
branches;
next	1.166;
commitid	jI8R4kuPSDw6nngR;

1.166
date	2017.02.08.17.33.51;	author nicm;	state Exp;
branches;
next	1.165;
commitid	FRXDgwv9Efe1jYmg;

1.165
date	2017.02.03.11.57.28;	author nicm;	state Exp;
branches;
next	1.164;
commitid	BLRh0qXo7OVTPhiT;

1.164
date	2017.01.07.15.28.13;	author nicm;	state Exp;
branches;
next	1.163;
commitid	llgkTzvAhxXuSWDB;

1.163
date	2017.01.06.11.57.03;	author nicm;	state Exp;
branches;
next	1.162;
commitid	m6HBAjiRCa66sywZ;

1.162
date	2017.01.05.09.07.16;	author nicm;	state Exp;
branches;
next	1.161;
commitid	al9tcSDvFKlm4Qpq;

1.161
date	2016.11.24.13.38.44;	author nicm;	state Exp;
branches;
next	1.160;
commitid	xEmWv4VOf7iteHdC;

1.160
date	2016.11.15.09.53.23;	author nicm;	state Exp;
branches;
next	1.159;
commitid	JNIvRleVGan7dplH;

1.159
date	2016.10.13.20.27.27;	author nicm;	state Exp;
branches;
next	1.158;
commitid	txCyQ5BkKJtZRzfT;

1.158
date	2016.10.12.09.07.58;	author nicm;	state Exp;
branches;
next	1.157;
commitid	cT7Nken6nHGGrKeY;

1.157
date	2016.10.11.13.21.59;	author nicm;	state Exp;
branches;
next	1.156;
commitid	80rgEIPcNpyBnf95;

1.156
date	2016.10.11.09.30.36;	author nicm;	state Exp;
branches;
next	1.155;
commitid	OThpNjT1frpnaa0G;

1.155
date	2016.10.11.07.23.34;	author nicm;	state Exp;
branches;
next	1.154;
commitid	leUN1UeapgUoieJj;

1.154
date	2016.10.09.07.30.28;	author nicm;	state Exp;
branches;
next	1.153;
commitid	c9k2cRsBDrU0aCxp;

1.153
date	2016.10.03.22.52.11;	author nicm;	state Exp;
branches;
next	1.152;
commitid	brRovAmeQVyBbZ4S;

1.152
date	2016.09.12.15.40.58;	author nicm;	state Exp;
branches;
next	1.151;
commitid	FmdCsJJj2mhuDrZn;

1.151
date	2016.05.23.20.03.14;	author nicm;	state Exp;
branches;
next	1.150;
commitid	aMXF9Lu1jv0pugAf;

1.150
date	2016.05.03.13.40.50;	author nicm;	state Exp;
branches;
next	1.149;
commitid	Y75pZddd5WMVn87Z;

1.149
date	2016.05.01.13.39.05;	author nicm;	state Exp;
branches;
next	1.148;
commitid	pVfiolwomsfXbbZY;

1.148
date	2016.04.27.09.39.09;	author nicm;	state Exp;
branches;
next	1.147;
commitid	0bQ3quXnMplDQUsb;

1.147
date	2016.03.18.14.27.24;	author nicm;	state Exp;
branches;
next	1.146;
commitid	eImnC1LNR8lsdytU;

1.146
date	2016.03.01.12.04.43;	author nicm;	state Exp;
branches;
next	1.145;
commitid	8tE2MJr7RYWnQBde;

1.145
date	2016.02.05.10.20.06;	author nicm;	state Exp;
branches;
next	1.144;
commitid	sO4AD3ZygEIPlaeJ;

1.144
date	2016.01.19.15.59.12;	author nicm;	state Exp;
branches;
next	1.143;
commitid	P3qmSOx6KrDBsb0c;

1.143
date	2015.12.11.12.27.36;	author nicm;	state Exp;
branches;
next	1.142;
commitid	ns7JfXpW9TsHrnT3;

1.142
date	2015.12.08.08.34.18;	author nicm;	state Exp;
branches;
next	1.141;
commitid	MRfGAYPLeVqV46rT;

1.141
date	2015.11.18.14.27.44;	author nicm;	state Exp;
branches;
next	1.140;
commitid	RjsAPRkWwvS79w40;

1.140
date	2015.11.13.08.09.28;	author nicm;	state Exp;
branches;
next	1.139;
commitid	3vFd8TIqn7NVGuk0;

1.139
date	2015.11.12.11.09.11;	author nicm;	state Exp;
branches;
next	1.138;
commitid	tEN3cHiOuN3KscbT;

1.138
date	2015.11.12.11.05.34;	author nicm;	state Exp;
branches;
next	1.137;
commitid	Ih1tdqtjpnEyfE8x;

1.137
date	2015.10.31.08.13.58;	author nicm;	state Exp;
branches;
next	1.136;
commitid	B5GekkO0CdWpFMrz;

1.136
date	2015.10.27.15.58.43;	author nicm;	state Exp;
branches;
next	1.135;
commitid	89xhQafU35Q5MQVC;

1.135
date	2015.10.23.16.02.21;	author nicm;	state Exp;
branches;
next	1.134;
commitid	dVDXU9Ok8jlPT5fI;

1.134
date	2015.09.14.11.57.22;	author nicm;	state Exp;
branches;
next	1.133;
commitid	wKlWtZcqFB2WciZ5;

1.133
date	2015.09.13.13.31.40;	author nicm;	state Exp;
branches;
next	1.132;
commitid	ToibECMiP97xJ3jN;

1.132
date	2015.08.29.09.25.00;	author nicm;	state Exp;
branches;
next	1.131;
commitid	UXoQGD7QOZAJI1XC;

1.131
date	2015.08.28.12.25.42;	author nicm;	state Exp;
branches;
next	1.130;
commitid	6bG4Sc33YFhgSCnx;

1.130
date	2015.04.24.22.19.36;	author nicm;	state Exp;
branches;
next	1.129;
commitid	h1lxJjTgcLGsGtE8;

1.129
date	2015.04.21.15.16.06;	author nicm;	state Exp;
branches;
next	1.128;
commitid	7hjLmPAyPakj9JwF;

1.128
date	2015.04.20.15.41.32;	author nicm;	state Exp;
branches;
next	1.127;
commitid	jCkBw367YfIy8ICD;

1.127
date	2015.04.20.09.39.21;	author nicm;	state Exp;
branches;
next	1.126;
commitid	heZfFI0NqHNIdU3s;

1.126
date	2015.04.19.21.34.21;	author nicm;	state Exp;
branches;
next	1.125;
commitid	wug6ctIOfhVMeWQp;

1.125
date	2015.04.10.16.00.08;	author nicm;	state Exp;
branches;
next	1.124;
commitid	k7RbsMc8eByIqjzu;

1.124
date	2015.03.31.17.45.10;	author nicm;	state Exp;
branches;
next	1.123;
commitid	2uQloBaX92ri1PyE;

1.123
date	2015.02.05.10.29.43;	author nicm;	state Exp;
branches;
next	1.122;
commitid	b1G1TVWY7l4KyoY6;

1.122
date	2015.01.15.13.35.13;	author nicm;	state Exp;
branches;
next	1.121;
commitid	l4xL44nwmKQKyT0Z;

1.121
date	2014.12.15.10.02.55;	author nicm;	state Exp;
branches;
next	1.120;
commitid	uVC0lkLxHKNkrstI;

1.120
date	2014.11.09.15.13.01;	author nicm;	state Exp;
branches;
next	1.119;
commitid	49V8qpRYoUhIhGdm;

1.119
date	2014.11.06.10.56.44;	author nicm;	state Exp;
branches;
next	1.118;
commitid	YLPg8pOrZkhW9oL8;

1.118
date	2014.11.06.09.17.26;	author nicm;	state Exp;
branches;
next	1.117;
commitid	CCUZqfCax9h5WQau;

1.117
date	2014.10.22.23.18.53;	author nicm;	state Exp;
branches;
next	1.116;
commitid	eFDptKeckheZa4ap;

1.116
date	2014.10.08.17.35.58;	author nicm;	state Exp;
branches;
next	1.115;
commitid	mK8z9uVwDZMfiNoM;

1.115
date	2014.10.02.08.36.26;	author nicm;	state Exp;
branches;
next	1.114;
commitid	GtxJuJKVNnFOgxeQ;

1.114
date	2014.09.01.21.50.18;	author nicm;	state Exp;
branches;
next	1.113;
commitid	yvK8NJvd2XzXhKku;

1.113
date	2014.08.11.22.39.57;	author nicm;	state Exp;
branches;
next	1.112;
commitid	5P6S7HkajnxiDJ0l;

1.112
date	2014.08.11.22.18.16;	author nicm;	state Exp;
branches;
next	1.111;
commitid	aoiUaOZcuwvS7PHQ;

1.111
date	2014.06.19.07.37.59;	author nicm;	state Exp;
branches;
next	1.110;
commitid	MqaWT93As1lqFg7u;

1.110
date	2014.05.14.06.39.58;	author nicm;	state Exp;
branches;
next	1.109;

1.109
date	2014.05.13.07.54.20;	author nicm;	state Exp;
branches;
next	1.108;

1.108
date	2014.05.13.07.34.35;	author nicm;	state Exp;
branches;
next	1.107;

1.107
date	2014.04.24.09.14.43;	author nicm;	state Exp;
branches;
next	1.106;

1.106
date	2014.04.17.14.45.49;	author nicm;	state Exp;
branches;
next	1.105;

1.105
date	2014.04.11.19.35.54;	author nicm;	state Exp;
branches;
next	1.104;

1.104
date	2014.04.03.08.20.29;	author nicm;	state Exp;
branches;
next	1.103;

1.103
date	2014.03.31.21.39.31;	author nicm;	state Exp;
branches;
next	1.102;

1.102
date	2014.02.17.23.07.03;	author nicm;	state Exp;
branches;
next	1.101;

1.101
date	2014.01.28.23.07.09;	author nicm;	state Exp;
branches;
next	1.100;

1.100
date	2014.01.22.22.32.15;	author nicm;	state Exp;
branches;
next	1.99;

1.99
date	2014.01.22.13.57.49;	author nicm;	state Exp;
branches;
next	1.98;

1.98
date	2013.11.20.17.01.23;	author deraadt;	state Exp;
branches;
next	1.97;

1.97
date	2013.11.09.00.48.57;	author nicm;	state Exp;
branches;
next	1.96;

1.96
date	2013.11.08.12.39.20;	author nicm;	state Exp;
branches;
next	1.95;

1.95
date	2013.10.23.11.31.03;	author nicm;	state Exp;
branches;
next	1.94;

1.94
date	2013.07.12.09.52.36;	author nicm;	state Exp;
branches;
next	1.93;

1.93
date	2013.07.05.14.44.06;	author nicm;	state Exp;
branches;
next	1.92;

1.92
date	2013.07.05.14.41.36;	author nicm;	state Exp;
branches;
next	1.91;

1.91
date	2013.03.25.11.43.33;	author nicm;	state Exp;
branches;
next	1.90;

1.90
date	2013.03.25.11.43.01;	author nicm;	state Exp;
branches;
next	1.89;

1.89
date	2013.03.22.15.52.42;	author nicm;	state Exp;
branches;
next	1.88;

1.88
date	2013.03.22.10.31.22;	author nicm;	state Exp;
branches;
next	1.87;

1.87
date	2013.02.05.11.08.59;	author nicm;	state Exp;
branches;
next	1.86;

1.86
date	2013.01.18.02.16.21;	author nicm;	state Exp;
branches;
next	1.85;

1.85
date	2012.11.27.14.42.56;	author nicm;	state Exp;
branches;
next	1.84;

1.84
date	2012.10.26.14.35.42;	author nicm;	state Exp;
branches;
next	1.83;

1.83
date	2012.09.25.07.39.28;	author nicm;	state Exp;
branches;
next	1.82;

1.82
date	2012.08.11.06.45.33;	author nicm;	state Exp;
branches;
next	1.81;

1.81
date	2012.07.10.11.53.01;	author nicm;	state Exp;
branches;
next	1.80;

1.80
date	2012.04.01.20.53.47;	author nicm;	state Exp;
branches;
next	1.79;

1.79
date	2012.04.01.09.23.31;	author nicm;	state Exp;
branches;
next	1.78;

1.78
date	2012.03.17.21.40.53;	author nicm;	state Exp;
branches;
next	1.77;

1.77
date	2012.03.11.23.01.19;	author nicm;	state Exp;
branches;
next	1.76;

1.76
date	2011.12.04.16.18.01;	author nicm;	state Exp;
branches;
next	1.75;

1.75
date	2011.11.15.23.24.04;	author nicm;	state Exp;
branches;
next	1.74;

1.74
date	2011.10.23.23.38.16;	author nicm;	state Exp;
branches;
next	1.73;

1.73
date	2011.06.27.00.04.49;	author nicm;	state Exp;
branches;
next	1.72;

1.72
date	2011.05.18.20.24.29;	author nicm;	state Exp;
branches;
next	1.71;

1.71
date	2011.05.18.18.06.36;	author nicm;	state Exp;
branches;
next	1.70;

1.70
date	2011.05.18.08.04.47;	author nicm;	state Exp;
branches;
next	1.69;

1.69
date	2011.04.24.21.06.12;	author nicm;	state Exp;
branches;
next	1.68;

1.68
date	2011.04.19.21.31.33;	author nicm;	state Exp;
branches;
next	1.67;

1.67
date	2011.03.28.19.44.31;	author nicm;	state Exp;
branches;
next	1.66;

1.66
date	2010.12.30.23.16.18;	author nicm;	state Exp;
branches;
next	1.65;

1.65
date	2010.12.29.21.49.06;	author nicm;	state Exp;
branches;
next	1.64;

1.64
date	2010.12.11.17.56.01;	author nicm;	state Exp;
branches;
next	1.63;

1.63
date	2010.09.11.15.39.55;	author nicm;	state Exp;
branches;
next	1.62;

1.62
date	2010.09.08.20.36.42;	author nicm;	state Exp;
branches;
next	1.61;

1.61
date	2010.07.22.21.10.51;	author nicm;	state Exp;
branches;
next	1.60;

1.60
date	2010.06.29.05.24.49;	author tedu;	state Exp;
branches;
next	1.59;

1.59
date	2010.06.06.19.00.13;	author nicm;	state Exp;
branches;
next	1.58;

1.58
date	2010.06.05.15.49.48;	author nicm;	state Exp;
branches;
next	1.57;

1.57
date	2010.05.31.19.51.29;	author nicm;	state Exp;
branches;
next	1.56;

1.56
date	2010.05.23.19.42.19;	author nicm;	state Exp;
branches;
next	1.55;

1.55
date	2010.04.28.18.19.16;	author nicm;	state Exp;
branches;
next	1.54;

1.54
date	2010.04.06.21.35.44;	author nicm;	state Exp;
branches;
next	1.53;

1.53
date	2010.03.22.19.13.28;	author nicm;	state Exp;
branches;
next	1.52;

1.52
date	2010.03.22.19.10.42;	author nicm;	state Exp;
branches;
next	1.51;

1.51
date	2010.03.14.23.31.23;	author nicm;	state Exp;
branches;
next	1.50;

1.50
date	2010.03.02.00.32.41;	author nicm;	state Exp;
branches;
next	1.49;

1.49
date	2010.03.01.23.53.27;	author nicm;	state Exp;
branches;
next	1.48;

1.48
date	2010.02.22.20.41.16;	author nicm;	state Exp;
branches;
next	1.47;

1.47
date	2010.02.22.20.28.21;	author nicm;	state Exp;
branches;
next	1.46;

1.46
date	2010.02.19.00.03.21;	author nicm;	state Exp;
branches;
next	1.45;

1.45
date	2010.02.17.21.27.18;	author nicm;	state Exp;
branches;
next	1.44;

1.44
date	2010.02.17.20.58.24;	author nicm;	state Exp;
branches;
next	1.43;

1.43
date	2010.02.11.20.39.40;	author nicm;	state Exp;
branches;
next	1.42;

1.42
date	2010.02.06.17.35.01;	author nicm;	state Exp;
branches;
next	1.41;

1.41
date	2010.02.04.20.00.26;	author nicm;	state Exp;
branches;
next	1.40;

1.40
date	2010.01.27.20.18.52;	author nicm;	state Exp;
branches;
next	1.39;

1.39
date	2010.01.25.22.34.11;	author nicm;	state Exp;
branches;
next	1.38;

1.38
date	2010.01.25.21.37.40;	author nicm;	state Exp;
branches;
next	1.37;

1.37
date	2010.01.25.21.33.39;	author nicm;	state Exp;
branches;
next	1.36;

1.36
date	2010.01.24.21.05.12;	author nicm;	state Exp;
branches;
next	1.35;

1.35
date	2009.12.03.22.50.10;	author nicm;	state Exp;
branches;
next	1.34;

1.34
date	2009.11.26.21.37.13;	author nicm;	state Exp;
branches;
next	1.33;

1.33
date	2009.11.18.17.03.16;	author nicm;	state Exp;
branches;
next	1.32;

1.32
date	2009.11.18.17.02.17;	author nicm;	state Exp;
branches;
next	1.31;

1.31
date	2009.10.20.21.35.25;	author nicm;	state Exp;
branches;
next	1.30;

1.30
date	2009.10.13.13.45.56;	author nicm;	state Exp;
branches;
next	1.29;

1.29
date	2009.10.11.07.01.10;	author nicm;	state Exp;
branches;
next	1.28;

1.28
date	2009.10.06.07.09.00;	author nicm;	state Exp;
branches;
next	1.27;

1.27
date	2009.09.10.17.16.24;	author nicm;	state Exp;
branches;
next	1.26;

1.26
date	2009.09.07.18.50.45;	author nicm;	state Exp;
branches;
next	1.25;

1.25
date	2009.08.21.07.33.58;	author nicm;	state Exp;
branches;
next	1.24;

1.24
date	2009.08.19.14.46.56;	author nicm;	state Exp;
branches;
next	1.23;

1.23
date	2009.08.18.09.51.51;	author nicm;	state Exp;
branches;
next	1.22;

1.22
date	2009.08.18.07.23.43;	author nicm;	state Exp;
branches;
next	1.21;

1.21
date	2009.08.18.07.08.26;	author nicm;	state Exp;
branches;
next	1.20;

1.20
date	2009.08.13.22.32.18;	author nicm;	state Exp;
branches;
next	1.19;

1.19
date	2009.08.13.22.11.43;	author nicm;	state Exp;
branches;
next	1.18;

1.18
date	2009.08.13.19.35.20;	author nicm;	state Exp;
branches;
next	1.17;

1.17
date	2009.08.13.16.48.43;	author nicm;	state Exp;
branches;
next	1.16;

1.16
date	2009.08.08.15.57.49;	author nicm;	state Exp;
branches;
next	1.15;

1.15
date	2009.08.08.13.29.27;	author nicm;	state Exp;
branches;
next	1.14;

1.14
date	2009.08.05.16.26.38;	author nicm;	state Exp;
branches;
next	1.13;

1.13
date	2009.07.30.07.04.50;	author nicm;	state Exp;
branches;
next	1.12;

1.12
date	2009.07.28.07.03.32;	author nicm;	state Exp;
branches;
next	1.11;

1.11
date	2009.07.27.20.36.13;	author nicm;	state Exp;
branches;
next	1.10;

1.10
date	2009.07.27.19.29.35;	author nicm;	state Exp;
branches;
next	1.9;

1.9
date	2009.07.27.18.51.46;	author nicm;	state Exp;
branches;
next	1.8;

1.8
date	2009.07.27.07.42.45;	author nicm;	state Exp;
branches;
next	1.7;

1.7
date	2009.07.23.17.03.47;	author nicm;	state Exp;
branches;
next	1.6;

1.6
date	2009.07.12.16.15.34;	author nicm;	state Exp;
branches;
next	1.5;

1.5
date	2009.07.12.16.12.34;	author nicm;	state Exp;
branches;
next	1.4;

1.4
date	2009.07.11.19.09.24;	author nicm;	state Exp;
branches;
next	1.3;

1.3
date	2009.07.09.15.02.00;	author nicm;	state Exp;
branches;
next	1.2;

1.2
date	2009.07.02.16.15.43;	author nicm;	state Exp;
branches;
next	1.1;

1.1
date	2009.06.01.22.58.49;	author nicm;	state Exp;
branches;
next	;


desc
@@


1.170
log
@Show count of search results in copy mode.
@
text
@/* $OpenBSD: window-copy.c,v 1.169 2017/03/21 09:51:00 nicm Exp $ */

/*
 * Copyright (c) 2007 Nicholas Marriott <nicholas.marriott@@gmail.com>
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF MIND, USE, DATA OR PROFITS, WHETHER
 * IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING
 * OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */

#include <sys/types.h>

#include <ctype.h>
#include <stdlib.h>
#include <string.h>

#include "tmux.h"

static const char *window_copy_key_table(struct window_pane *);
static void	window_copy_command(struct window_pane *, struct client *,
		    struct session *, struct args *, struct mouse_event *);
static struct screen *window_copy_init(struct window_pane *);
static void	window_copy_free(struct window_pane *);
static int	window_copy_pagedown(struct window_pane *, int);
static void	window_copy_next_paragraph(struct window_pane *);
static void	window_copy_previous_paragraph(struct window_pane *);
static void	window_copy_resize(struct window_pane *, u_int, u_int);

static void	window_copy_redraw_selection(struct window_pane *, u_int);
static void	window_copy_redraw_lines(struct window_pane *, u_int, u_int);
static void	window_copy_redraw_screen(struct window_pane *);
static void	window_copy_write_line(struct window_pane *,
		    struct screen_write_ctx *, u_int);
static void	window_copy_write_lines(struct window_pane *,
		    struct screen_write_ctx *, u_int, u_int);

static void	window_copy_scroll_to(struct window_pane *, u_int, u_int);
static int	window_copy_search_compare(struct grid *, u_int, u_int,
		    struct grid *, u_int, int);
static int	window_copy_search_lr(struct grid *, struct grid *, u_int *,
		    u_int, u_int, u_int, int);
static int	window_copy_search_rl(struct grid *, struct grid *, u_int *,
		    u_int, u_int, u_int, int);
static int	window_copy_search_marks(struct window_pane *, struct screen *);
static void	window_copy_clear_marks(struct window_pane *);
static void	window_copy_move_left(struct screen *, u_int *, u_int *);
static void	window_copy_move_right(struct screen *, u_int *, u_int *);
static int	window_copy_is_lowercase(const char *);
static int	window_copy_search_jump(struct window_pane *, struct grid *,
		    struct grid *, u_int, u_int, u_int, int, int, int);
static int	window_copy_search(struct window_pane *, int, int);
static int	window_copy_search_up(struct window_pane *, int);
static int	window_copy_search_down(struct window_pane *, int);
static void	window_copy_goto_line(struct window_pane *, const char *);
static void	window_copy_update_cursor(struct window_pane *, u_int, u_int);
static void	window_copy_start_selection(struct window_pane *);
static int	window_copy_adjust_selection(struct window_pane *, u_int *,
		    u_int *);
static int	window_copy_update_selection(struct window_pane *, int);
static void	window_copy_synchronize_cursor(struct window_pane *wp);
static void    *window_copy_get_selection(struct window_pane *, size_t *);
static void	window_copy_copy_buffer(struct window_pane *, const char *,
		    void *, size_t);
static void	window_copy_copy_pipe(struct window_pane *, struct session *,
		    const char *, const char *);
static void	window_copy_copy_selection(struct window_pane *, const char *);
static void	window_copy_append_selection(struct window_pane *,
		    const char *);
static void	window_copy_clear_selection(struct window_pane *);
static void	window_copy_copy_line(struct window_pane *, char **, size_t *,
		    u_int, u_int, u_int);
static int	window_copy_in_set(struct window_pane *, u_int, u_int,
		    const char *);
static u_int	window_copy_find_length(struct window_pane *, u_int);
static void	window_copy_cursor_start_of_line(struct window_pane *);
static void	window_copy_cursor_back_to_indentation(struct window_pane *);
static void	window_copy_cursor_end_of_line(struct window_pane *);
static void	window_copy_other_end(struct window_pane *);
static void	window_copy_cursor_left(struct window_pane *);
static void	window_copy_cursor_right(struct window_pane *);
static void	window_copy_cursor_up(struct window_pane *, int);
static void	window_copy_cursor_down(struct window_pane *, int);
static void	window_copy_cursor_jump(struct window_pane *);
static void	window_copy_cursor_jump_back(struct window_pane *);
static void	window_copy_cursor_jump_to(struct window_pane *, int);
static void	window_copy_cursor_jump_to_back(struct window_pane *, int);
static void	window_copy_cursor_next_word(struct window_pane *,
		    const char *);
static void	window_copy_cursor_next_word_end(struct window_pane *,
		    const char *);
static void	window_copy_cursor_previous_word(struct window_pane *,
		    const char *);
static void	window_copy_scroll_up(struct window_pane *, u_int);
static void	window_copy_scroll_down(struct window_pane *, u_int);
static void	window_copy_rectangle_toggle(struct window_pane *);
static void	window_copy_move_mouse(struct mouse_event *);
static void	window_copy_drag_update(struct client *, struct mouse_event *);

const struct window_mode window_copy_mode = {
	.init = window_copy_init,
	.free = window_copy_free,
	.resize = window_copy_resize,
	.key_table = window_copy_key_table,
	.command = window_copy_command,
};

enum {
	WINDOW_COPY_OFF,
	WINDOW_COPY_SEARCHUP,
	WINDOW_COPY_SEARCHDOWN,
	WINDOW_COPY_JUMPFORWARD,
	WINDOW_COPY_JUMPBACKWARD,
	WINDOW_COPY_JUMPTOFORWARD,
	WINDOW_COPY_JUMPTOBACKWARD,
};

enum {
	WINDOW_COPY_REL_POS_ABOVE,
	WINDOW_COPY_REL_POS_ON_SCREEN,
	WINDOW_COPY_REL_POS_BELOW,
};

/*
 * Copy mode's visible screen (the "screen" field) is filled from one of two
 * sources: the original contents of the pane (used when we actually enter via
 * the "copy-mode" command, to copy the contents of the current pane), or else
 * a series of lines containing the output from an output-writing tmux command
 * (such as any of the "show-*" or "list-*" commands).
 *
 * In either case, the full content of the copy-mode grid is pointed at by the
 * "backing" field, and is copied into "screen" as needed (that is, when
 * scrolling occurs). When copy-mode is backed by a pane, backing points
 * directly at that pane's screen structure (&wp->base); when backed by a list
 * of output-lines from a command, it points at a newly-allocated screen
 * structure (which is deallocated when the mode ends).
 */
struct window_copy_mode_data {
	struct screen	 screen;

	struct screen	*backing;
	int		 backing_written; /* backing display started */

	u_int		 oy; /* number of lines scrolled up */

	u_int		 selx; /* beginning of selection */
	u_int		 sely;

	u_int		 endselx; /* end of selection */
	u_int		 endsely;

	enum {
		CURSORDRAG_NONE,	/* selection is independent of cursor */
		CURSORDRAG_ENDSEL,	/* end is synchronized with cursor */
		CURSORDRAG_SEL,		/* start is synchronized with cursor */
	} cursordrag;

	int		 rectflag;	/* in rectangle copy mode? */
	int		 scroll_exit;	/* exit on scroll to end? */

	u_int		 cx;
	u_int		 cy;

	u_int		 lastcx; /* position in last line w/ content */
	u_int		 lastsx; /* size of last line w/ content */

	int		 searchtype;
	char		*searchstr;
	bitstr_t        *searchmark;
	u_int		 searchcount;
	int		 searchthis;
	int		 searchx;
	int		 searchy;
	int		 searcho;

	int		 jumptype;
	char		 jumpchar;
};

static struct screen *
window_copy_init(struct window_pane *wp)
{
	struct window_copy_mode_data	*data;
	struct screen			*s;

	wp->modedata = data = xmalloc(sizeof *data);

	data->oy = 0;
	data->cx = 0;
	data->cy = 0;

	data->cursordrag = CURSORDRAG_NONE;

	data->lastcx = 0;
	data->lastsx = 0;

	data->backing_written = 0;

	data->rectflag = 0;
	data->scroll_exit = 0;

	data->searchtype = WINDOW_COPY_OFF;
	data->searchstr = NULL;
	data->searchmark = NULL;
	data->searchx = data->searchy = data->searcho = -1;

	if (wp->fd != -1)
		bufferevent_disable(wp->event, EV_READ|EV_WRITE);

	data->jumptype = WINDOW_COPY_OFF;
	data->jumpchar = '\0';

	s = &data->screen;
	screen_init(s, screen_size_x(&wp->base), screen_size_y(&wp->base), 0);
	s->sel.modekeys = options_get_number(wp->window->options, "mode-keys");

	data->backing = NULL;

	return (s);
}

void
window_copy_init_from_pane(struct window_pane *wp, int scroll_exit)
{
	struct window_copy_mode_data	*data = wp->modedata;
	struct screen			*s = &data->screen;
	struct screen_write_ctx	 	 ctx;
	u_int				 i;

	if (wp->mode != &window_copy_mode)
		fatalx("not in copy mode");

	data->backing = &wp->base;
	data->cx = data->backing->cx;
	data->cy = data->backing->cy;
	data->scroll_exit = scroll_exit;

	s->cx = data->cx;
	s->cy = data->cy;

	screen_write_start(&ctx, NULL, s);
	for (i = 0; i < screen_size_y(s); i++)
		window_copy_write_line(wp, &ctx, i);
	screen_write_cursormove(&ctx, data->cx, data->cy);
	screen_write_stop(&ctx);
}

void
window_copy_init_for_output(struct window_pane *wp)
{
	struct window_copy_mode_data	*data = wp->modedata;

	data->backing = xmalloc(sizeof *data->backing);
	screen_init(data->backing, screen_size_x(&wp->base),
	    screen_size_y(&wp->base), UINT_MAX);
}

static void
window_copy_free(struct window_pane *wp)
{
	struct window_copy_mode_data	*data = wp->modedata;

	if (wp->fd != -1)
		bufferevent_enable(wp->event, EV_READ|EV_WRITE);

	free(data->searchmark);
	free(data->searchstr);

	if (data->backing != &wp->base) {
		screen_free(data->backing);
		free(data->backing);
	}
	screen_free(&data->screen);

	free(data);
}

void
window_copy_add(struct window_pane *wp, const char *fmt, ...)
{
	va_list	ap;

	va_start(ap, fmt);
	window_copy_vadd(wp, fmt, ap);
	va_end(ap);
}

void
window_copy_vadd(struct window_pane *wp, const char *fmt, va_list ap)
{
	struct window_copy_mode_data	*data = wp->modedata;
	struct screen			*backing = data->backing;
	struct screen_write_ctx	 	 back_ctx, ctx;
	struct grid_cell		 gc;
	u_int				 old_hsize, old_cy;

	if (backing == &wp->base)
		return;

	memcpy(&gc, &grid_default_cell, sizeof gc);

	old_hsize = screen_hsize(data->backing);
	screen_write_start(&back_ctx, NULL, backing);
	if (data->backing_written) {
		/*
		 * On the second or later line, do a CRLF before writing
		 * (so it's on a new line).
		 */
		screen_write_carriagereturn(&back_ctx);
		screen_write_linefeed(&back_ctx, 0);
	} else
		data->backing_written = 1;
	old_cy = backing->cy;
	screen_write_vnputs(&back_ctx, 0, &gc, fmt, ap);
	screen_write_stop(&back_ctx);

	data->oy += screen_hsize(data->backing) - old_hsize;

	screen_write_start(&ctx, wp, &data->screen);

	/*
	 * If the history has changed, draw the top line.
	 * (If there's any history at all, it has changed.)
	 */
	if (screen_hsize(data->backing))
		window_copy_redraw_lines(wp, 0, 1);

	/* Write the new lines. */
	window_copy_redraw_lines(wp, old_cy, backing->cy - old_cy + 1);

	screen_write_stop(&ctx);
}

void
window_copy_pageup(struct window_pane *wp, int half_page)
{
	struct window_copy_mode_data	*data = wp->modedata;
	struct screen			*s = &data->screen;
	u_int				 n, ox, oy, px, py;

	oy = screen_hsize(data->backing) + data->cy - data->oy;
	ox = window_copy_find_length(wp, oy);

	if (s->sel.lineflag == LINE_SEL_LEFT_RIGHT && oy == data->sely)
		window_copy_other_end(wp);

	if (data->cx != ox) {
		data->lastcx = data->cx;
		data->lastsx = ox;
	}
	data->cx = data->lastcx;

	n = 1;
	if (screen_size_y(s) > 2) {
		if (half_page)
			n = screen_size_y(s) / 2;
		else
			n = screen_size_y(s) - 2;
	}

	if (data->oy + n > screen_hsize(data->backing))
		data->oy = screen_hsize(data->backing);
	else
		data->oy += n;

	if (!data->screen.sel.flag || !data->rectflag) {
		py = screen_hsize(data->backing) + data->cy - data->oy;
		px = window_copy_find_length(wp, py);
		if ((data->cx >= data->lastsx && data->cx != px) ||
		    data->cx > px)
			window_copy_cursor_end_of_line(wp);
	}

	window_copy_update_selection(wp, 1);
	window_copy_redraw_screen(wp);
}

static int
window_copy_pagedown(struct window_pane *wp, int half_page)
{
	struct window_copy_mode_data	*data = wp->modedata;
	struct screen			*s = &data->screen;
	u_int				 n, ox, oy, px, py;

	oy = screen_hsize(data->backing) + data->cy - data->oy;
	ox = window_copy_find_length(wp, oy);

	if (s->sel.lineflag == LINE_SEL_RIGHT_LEFT && oy == data->sely)
		window_copy_other_end(wp);

	if (data->cx != ox) {
		data->lastcx = data->cx;
		data->lastsx = ox;
	}
	data->cx = data->lastcx;

	n = 1;
	if (screen_size_y(s) > 2) {
		if (half_page)
			n = screen_size_y(s) / 2;
		else
			n = screen_size_y(s) - 2;
	}

	if (data->oy < n)
		data->oy = 0;
	else
		data->oy -= n;

	if (!data->screen.sel.flag || !data->rectflag) {
		py = screen_hsize(data->backing) + data->cy - data->oy;
		px = window_copy_find_length(wp, py);
		if ((data->cx >= data->lastsx && data->cx != px) ||
		    data->cx > px)
			window_copy_cursor_end_of_line(wp);
	}

	if (data->scroll_exit && data->oy == 0)
		return (1);
	window_copy_update_selection(wp, 1);
	window_copy_redraw_screen(wp);
	return (0);
}

static void
window_copy_previous_paragraph(struct window_pane *wp)
{
	struct window_copy_mode_data	*data = wp->modedata;
	u_int				 oy;

	oy = screen_hsize(data->backing) + data->cy - data->oy;

	while (oy > 0 && window_copy_find_length(wp, oy) == 0)
		oy--;

	while (oy > 0 && window_copy_find_length(wp, oy) > 0)
		oy--;

	window_copy_scroll_to(wp, 0, oy);
}

static void
window_copy_next_paragraph(struct window_pane *wp)
{
	struct window_copy_mode_data	*data = wp->modedata;
	struct screen			*s = &data->screen;
	u_int				 maxy, ox, oy;

	oy = screen_hsize(data->backing) + data->cy - data->oy;
	maxy = screen_hsize(data->backing) + screen_size_y(s) - 1;

	while (oy < maxy && window_copy_find_length(wp, oy) == 0)
		oy++;

	while (oy < maxy && window_copy_find_length(wp, oy) > 0)
		oy++;

	ox = window_copy_find_length(wp, oy);
	window_copy_scroll_to(wp, ox, oy);
}

static void
window_copy_resize(struct window_pane *wp, u_int sx, u_int sy)
{
	struct window_copy_mode_data	*data = wp->modedata;
	struct screen			*s = &data->screen;
	struct screen_write_ctx	 	 ctx;

	screen_resize(s, sx, sy, 1);
	if (data->backing != &wp->base)
		screen_resize(data->backing, sx, sy, 1);

	if (data->cy > sy - 1)
		data->cy = sy - 1;
	if (data->cx > sx)
		data->cx = sx;
	if (data->oy > screen_hsize(data->backing))
		data->oy = screen_hsize(data->backing);

	window_copy_clear_selection(wp);

	screen_write_start(&ctx, NULL, s);
	window_copy_write_lines(wp, &ctx, 0, screen_size_y(s) - 1);
	screen_write_stop(&ctx);

	if (data->searchmark != NULL)
		window_copy_search_marks(wp, NULL);
	data->searchx = data->cx;
	data->searchy = data->cy;
	data->searcho = data->oy;

	window_copy_redraw_screen(wp);
}

static const char *
window_copy_key_table(struct window_pane *wp)
{
	if (options_get_number(wp->window->options, "mode-keys") == MODEKEY_VI)
		return ("copy-mode-vi");
	return ("copy-mode");
}

static void
window_copy_command(struct window_pane *wp, struct client *c, struct session *s,
    struct args *args, struct mouse_event *m)
{
	struct window_copy_mode_data	*data = wp->modedata;
	struct screen			*sn = &data->screen;
	const char			*command, *argument, *ws;
	u_int				 np = wp->modeprefix;
	int				 cancel = 0, redraw = 0;
	char				 prefix;

	if (args->argc == 0)
		return;
	command = args->argv[0];

	if (m != NULL && m->valid)
		window_copy_move_mouse(m);

	if (args->argc == 1) {
		if (strcmp(command, "append-selection") == 0) {
			if (s != NULL)
				window_copy_append_selection(wp, NULL);
			window_copy_clear_selection(wp);
			redraw = 1;
		}
		if (strcmp(command, "append-selection-and-cancel") == 0) {
			if (s != NULL)
				window_copy_append_selection(wp, NULL);
			window_copy_clear_selection(wp);
			redraw = 1;
			cancel = 1;
		}
		if (strcmp(command, "back-to-indentation") == 0)
			window_copy_cursor_back_to_indentation(wp);
		if (strcmp(command, "begin-selection") == 0) {
			if (m != NULL)
				window_copy_start_drag(c, m);
			else {
				sn->sel.lineflag = LINE_SEL_NONE;
				window_copy_start_selection(wp);
				redraw = 1;
			}
		}
		if (strcmp(command, "stop-selection") == 0)
			data->cursordrag = CURSORDRAG_NONE;
		if (strcmp(command, "bottom-line") == 0) {
			data->cx = 0;
			data->cy = screen_size_y(sn) - 1;
			window_copy_update_selection(wp, 1);
			redraw = 1;
		}
		if (strcmp(command, "cancel") == 0)
			cancel = 1;
		if (strcmp(command, "clear-selection") == 0) {
			window_copy_clear_selection(wp);
			redraw = 1;
		}
		if (strcmp(command, "copy-end-of-line") == 0) {
			window_copy_start_selection(wp);
			for (; np > 1; np--)
				window_copy_cursor_down(wp, 0);
			window_copy_cursor_end_of_line(wp);
			redraw = 1;

			if (s != NULL) {
				window_copy_copy_selection(wp, NULL);
				cancel = 1;
			}
		}
		if (strcmp(command, "copy-line") == 0) {
			window_copy_cursor_start_of_line(wp);
			window_copy_start_selection(wp);
			for (; np > 1; np--)
				window_copy_cursor_down(wp, 0);
			window_copy_cursor_end_of_line(wp);
			redraw = 1;

			if (s != NULL) {
				window_copy_copy_selection(wp, NULL);
				cancel = 1;
			}
		}
		if (strcmp(command, "copy-selection") == 0) {
			if (s != NULL)
				window_copy_copy_selection(wp, NULL);
			window_copy_clear_selection(wp);
			redraw = 1;
		}
		if (strcmp(command, "copy-selection-and-cancel") == 0) {
			if (s != NULL)
				window_copy_copy_selection(wp, NULL);
			window_copy_clear_selection(wp);
			redraw = 1;
			cancel = 1;
		}
		if (strcmp(command, "cursor-down") == 0) {
			for (; np != 0; np--)
				window_copy_cursor_down(wp, 0);
		}
		if (strcmp(command, "cursor-left") == 0) {
			for (; np != 0; np--)
				window_copy_cursor_left(wp);
		}
		if (strcmp(command, "cursor-right") == 0) {
			for (; np != 0; np--)
				window_copy_cursor_right(wp);
		}
		if (strcmp(command, "cursor-up") == 0) {
			for (; np != 0; np--)
				window_copy_cursor_up(wp, 0);
		}
		if (strcmp(command, "end-of-line") == 0)
			window_copy_cursor_end_of_line(wp);
		if (strcmp(command, "halfpage-down") == 0) {
			for (; np != 0; np--) {
				if (window_copy_pagedown(wp, 1)) {
					cancel = 1;
					break;
				}
			}
		}
		if (strcmp(command, "halfpage-up") == 0) {
			for (; np != 0; np--)
				window_copy_pageup(wp, 1);
		}
		if (strcmp(command, "history-bottom") == 0) {
			data->cx = 0;
			data->cy = screen_size_y(sn) - 1;
			data->oy = 0;
			window_copy_update_selection(wp, 1);
			redraw = 1;
		}
		if (strcmp(command, "history-top") == 0) {
			data->cx = 0;
			data->cy = 0;
			data->oy = screen_hsize(data->backing);
			window_copy_update_selection(wp, 1);
			redraw = 1;
		}
		if (strcmp(command, "jump-again") == 0) {
			switch (data->jumptype) {
			case WINDOW_COPY_JUMPFORWARD:
				for (; np != 0; np--)
					window_copy_cursor_jump(wp);
				break;
			case WINDOW_COPY_JUMPBACKWARD:
				for (; np != 0; np--)
					window_copy_cursor_jump_back(wp);
				break;
			case WINDOW_COPY_JUMPTOFORWARD:
				for (; np != 0; np--)
					window_copy_cursor_jump_to(wp, 1);
				break;
			case WINDOW_COPY_JUMPTOBACKWARD:
				for (; np != 0; np--)
					window_copy_cursor_jump_to_back(wp, 1);
				break;
			}
		}
		if (strcmp(command, "jump-reverse") == 0) {
			switch (data->jumptype) {
			case WINDOW_COPY_JUMPFORWARD:
				for (; np != 0; np--)
					window_copy_cursor_jump_back(wp);
				break;
			case WINDOW_COPY_JUMPBACKWARD:
				for (; np != 0; np--)
					window_copy_cursor_jump(wp);
				break;
			case WINDOW_COPY_JUMPTOFORWARD:
				for (; np != 0; np--)
					window_copy_cursor_jump_to_back(wp, 1);
				break;
			case WINDOW_COPY_JUMPTOBACKWARD:
				for (; np != 0; np--)
					window_copy_cursor_jump_to(wp, 1);
				break;
			}
		}
		if (strcmp(command, "middle-line") == 0) {
			data->cx = 0;
			data->cy = (screen_size_y(sn) - 1) / 2;
			window_copy_update_selection(wp, 1);
			redraw = 1;
		}
		if (strcmp(command, "next-paragraph") == 0) {
			for (; np != 0; np--)
				window_copy_next_paragraph(wp);
		}
		if (strcmp(command, "next-space") == 0) {
			for (; np != 0; np--)
				window_copy_cursor_next_word(wp, " ");
		}
		if (strcmp(command, "next-space-end") == 0) {
			for (; np != 0; np--)
				window_copy_cursor_next_word_end(wp, " ");
		}
		if (strcmp(command, "next-word") == 0) {
			ws = options_get_string(s->options, "word-separators");
			for (; np != 0; np--)
				window_copy_cursor_next_word(wp, ws);
		}
		if (strcmp(command, "next-word-end") == 0) {
			ws = options_get_string(s->options, "word-separators");
			for (; np != 0; np--)
				window_copy_cursor_next_word_end(wp, ws);
		}
		if (strcmp(command, "other-end") == 0) {
			if ((np % 2) != 0)
				window_copy_other_end(wp);
		}
		if (strcmp(command, "page-down") == 0) {
			for (; np != 0; np--) {
				if (window_copy_pagedown(wp, 0)) {
					cancel = 1;
					break;
				}
			}
		}
		if (strcmp(command, "page-up") == 0) {
			for (; np != 0; np--)
				window_copy_pageup(wp, 0);
		}
		if (strcmp(command, "previous-paragraph") == 0) {
			for (; np != 0; np--)
				window_copy_previous_paragraph(wp);
		}
		if (strcmp(command, "previous-space") == 0) {
			for (; np != 0; np--)
				window_copy_cursor_previous_word(wp, " ");
		}
		if (strcmp(command, "previous-word") == 0) {
			ws = options_get_string(s->options, "word-separators");
			for (; np != 0; np--)
				window_copy_cursor_previous_word(wp, ws);
		}
		if (strcmp(command, "rectangle-toggle") == 0) {
			sn->sel.lineflag = LINE_SEL_NONE;
			window_copy_rectangle_toggle(wp);
		}
		if (strcmp(command, "scroll-down") == 0) {
			for (; np != 0; np--)
				window_copy_cursor_down(wp, 1);
			if (data->scroll_exit && data->oy == 0)
				cancel = 1;
		}
		if (strcmp(command, "scroll-up") == 0) {
			for (; np != 0; np--)
				window_copy_cursor_up(wp, 1);
		}
		if (strcmp(command, "search-again") == 0) {
			if (data->searchtype == WINDOW_COPY_SEARCHUP) {
				for (; np != 0; np--)
					window_copy_search_up(wp, 1);
			} else if (data->searchtype == WINDOW_COPY_SEARCHDOWN) {
				for (; np != 0; np--)
					window_copy_search_down(wp, 1);
			}
		}
		if (strcmp(command, "search-reverse") == 0) {
			if (data->searchtype == WINDOW_COPY_SEARCHUP) {
				for (; np != 0; np--)
					window_copy_search_down(wp, 1);
			} else if (data->searchtype == WINDOW_COPY_SEARCHDOWN) {
				for (; np != 0; np--)
					window_copy_search_up(wp, 1);
			}
		}
		if (strcmp(command, "select-line") == 0) {
			sn->sel.lineflag = LINE_SEL_LEFT_RIGHT;
			data->rectflag = 0;
			window_copy_cursor_start_of_line(wp);
			window_copy_start_selection(wp);
			for (; np > 1; np--)
				window_copy_cursor_down(wp, 0);
			window_copy_cursor_end_of_line(wp);
			redraw = 1;
		}
		if (strcmp(command, "select-word") == 0) {
			sn->sel.lineflag = LINE_SEL_LEFT_RIGHT;
			data->rectflag = 0;
			ws = options_get_string(s->options, "word-separators");
			window_copy_cursor_previous_word(wp, ws);
			window_copy_start_selection(wp);
			window_copy_cursor_next_word_end(wp, ws);
			redraw = 1;
		}
		if (strcmp(command, "start-of-line") == 0)
			window_copy_cursor_start_of_line(wp);
		if (strcmp(command, "top-line") == 0) {
			data->cx = 0;
			data->cy = 0;
			window_copy_update_selection(wp, 1);
			redraw = 1;
		}
	} else if (args->argc == 2 && *args->argv[1] != '\0') {
		argument = args->argv[1];
		if (strcmp(command, "copy-pipe") == 0) {
			if (s != NULL)
				window_copy_copy_pipe(wp, s, NULL, argument);
		}
		if (strcmp(command, "copy-pipe-and-cancel") == 0) {
			if (s != NULL) {
				window_copy_copy_pipe(wp, s, NULL, argument);
				cancel = 1;
			}
		}
		if (strcmp(command, "goto-line") == 0)
			window_copy_goto_line(wp, argument);
		if (strcmp(command, "jump-backward") == 0) {
			data->jumptype = WINDOW_COPY_JUMPBACKWARD;
			data->jumpchar = *argument;
			for (; np != 0; np--)
				window_copy_cursor_jump_back(wp);
		}
		if (strcmp(command, "jump-forward") == 0) {
			data->jumptype = WINDOW_COPY_JUMPFORWARD;
			data->jumpchar = *argument;
			for (; np != 0; np--)
				window_copy_cursor_jump(wp);
		}
		if (strcmp(command, "jump-to-backward") == 0) {
			data->jumptype = WINDOW_COPY_JUMPTOBACKWARD;
			data->jumpchar = *argument;
			for (; np != 0; np--)
				window_copy_cursor_jump_to_back(wp, 1);
		}
		if (strcmp(command, "jump-to-forward") == 0) {
			data->jumptype = WINDOW_COPY_JUMPTOFORWARD;
			data->jumpchar = *argument;
			for (; np != 0; np--)
				window_copy_cursor_jump_to(wp, 1);
		}
		if (strcmp(command, "search-backward") == 0) {
			data->searchtype = WINDOW_COPY_SEARCHUP;
			free(data->searchstr);
			data->searchstr = xstrdup(argument);
			for (; np != 0; np--)
				window_copy_search_up(wp, 1);
		}
		if (strcmp(command, "search-forward") == 0) {
			data->searchtype = WINDOW_COPY_SEARCHDOWN;
			free(data->searchstr);
			data->searchstr = xstrdup(argument);
			for (; np != 0; np--)
				window_copy_search_down(wp, 1);
		}
		if (strcmp(command, "search-backward-incremental") == 0) {
			prefix = *argument++;
			if (data->searchx == -1 || data->searchy == -1) {
				data->searchx = data->cx;
				data->searchy = data->cy;
				data->searcho = data->oy;
			} else if (data->searchstr != NULL &&
			    strcmp(argument, data->searchstr) != 0) {
				data->cx = data->searchx;
				data->cy = data->searchy;
				data->oy = data->searcho;
				redraw = 1;
			}
			if (*argument == '\0') {
				window_copy_clear_marks(wp);
				redraw = 1;
			} else if (prefix == '=' || prefix == '-') {
				data->searchtype = WINDOW_COPY_SEARCHUP;
				free(data->searchstr);
				data->searchstr = xstrdup(argument);
				if (!window_copy_search_up(wp, 1)) {
					window_copy_clear_marks(wp);
					redraw = 1;
				}
			} else if (prefix == '+') {
				data->searchtype = WINDOW_COPY_SEARCHDOWN;
				free(data->searchstr);
				data->searchstr = xstrdup(argument);
				if (!window_copy_search_down(wp, 1)) {
					window_copy_clear_marks(wp);
					redraw = 1;
				}
			}
		}
		if (strcmp(command, "search-forward-incremental") == 0) {
			prefix = *argument++;
			if (data->searchx == -1 || data->searchy == -1) {
				data->searchx = data->cx;
				data->searchy = data->cy;
				data->searcho = data->oy;
			} else if (data->searchstr != NULL &&
			    strcmp(argument, data->searchstr) != 0) {
				data->cx = data->searchx;
				data->cy = data->searchy;
				data->oy = data->searcho;
				redraw = 1;
			}
			if (*argument == '\0') {
				window_copy_clear_marks(wp);
				redraw = 1;
			} else if (prefix == '=' || prefix == '+') {
				data->searchtype = WINDOW_COPY_SEARCHDOWN;
				free(data->searchstr);
				data->searchstr = xstrdup(argument);
				if (!window_copy_search_down(wp, 1)) {
					window_copy_clear_marks(wp);
					redraw = 1;
				}
			} else if (prefix == '-') {
				data->searchtype = WINDOW_COPY_SEARCHUP;
				free(data->searchstr);
				data->searchstr = xstrdup(argument);
				if (!window_copy_search_up(wp, 1)) {
					window_copy_clear_marks(wp);
					redraw = 1;
				}
			}
		}
	}

	if (strncmp(command, "search-", 7) != 0 && data->searchmark != NULL) {
		window_copy_clear_marks(wp);
		redraw = 1;
		data->searchx = data->searchy = -1;
	}

	if (cancel)
		window_pane_reset_mode(wp);
	else if (redraw)
		window_copy_redraw_screen(wp);
	wp->modeprefix = 1;
}

static void
window_copy_scroll_to(struct window_pane *wp, u_int px, u_int py)
{
	struct window_copy_mode_data	*data = wp->modedata;
	struct grid			*gd = data->backing->grid;
	u_int				 offset, gap;

	data->cx = px;

	gap = gd->sy / 4;
	if (py < gd->sy) {
		offset = 0;
		data->cy = py;
	} else if (py > gd->hsize + gd->sy - gap) {
		offset = gd->hsize;
		data->cy = py - gd->hsize;
	} else {
		offset = py + gap - gd->sy;
		data->cy = py - offset;
	}
	data->oy = gd->hsize - offset;

	window_copy_update_selection(wp, 1);
	window_copy_redraw_screen(wp);
}

static int
window_copy_search_compare(struct grid *gd, u_int px, u_int py,
    struct grid *sgd, u_int spx, int cis)
{
	struct grid_cell	 gc, sgc;
	const struct utf8_data	*ud, *sud;

	grid_get_cell(gd, px, py, &gc);
	ud = &gc.data;
	grid_get_cell(sgd, spx, 0, &sgc);
	sud = &sgc.data;

	if (ud->size != sud->size || ud->width != sud->width)
		return (0);

	if (cis && ud->size == 1)
		return (tolower(ud->data[0]) == sud->data[0]);

	return (memcmp(ud->data, sud->data, ud->size) == 0);
}

static int
window_copy_search_lr(struct grid *gd,
    struct grid *sgd, u_int *ppx, u_int py, u_int first, u_int last, int cis)
{
	u_int	ax, bx, px;
	int	matched;

	for (ax = first; ax < last; ax++) {
		if (ax + sgd->sx >= gd->sx)
			break;
		for (bx = 0; bx < sgd->sx; bx++) {
			px = ax + bx;
			matched = window_copy_search_compare(gd, px, py, sgd,
			    bx, cis);
			if (!matched)
				break;
		}
		if (bx == sgd->sx) {
			*ppx = ax;
			return (1);
		}
	}
	return (0);
}

static int
window_copy_search_rl(struct grid *gd,
    struct grid *sgd, u_int *ppx, u_int py, u_int first, u_int last, int cis)
{
	u_int	ax, bx, px;
	int	matched;

	for (ax = last + 1; ax > first; ax--) {
		if (gd->sx - (ax - 1) < sgd->sx)
			continue;
		for (bx = 0; bx < sgd->sx; bx++) {
			px = ax - 1 + bx;
			matched = window_copy_search_compare(gd, px, py, sgd,
			    bx, cis);
			if (!matched)
				break;
		}
		if (bx == sgd->sx) {
			*ppx = ax - 1;
			return (1);
		}
	}
	return (0);
}

static void
window_copy_move_left(struct screen *s, u_int *fx, u_int *fy)
{
	if (*fx == 0) {	/* left */
		if (*fy == 0) /* top */
			return;
		*fx = screen_size_x(s) - 1;
		*fy = *fy - 1;
	} else
		*fx = *fx - 1;
}

static void
window_copy_move_right(struct screen *s, u_int *fx, u_int *fy)
{
	if (*fx == screen_size_x(s) - 1) { /* right */
		if (*fy == screen_hsize(s) + screen_size_y(s)) /* bottom */
			return;
		*fx = 0;
		*fy = *fy + 1;
	} else
		*fx = *fx + 1;
}

static int
window_copy_is_lowercase(const char *ptr)
{
	while (*ptr != '\0') {
		if (*ptr != tolower((u_char)*ptr))
			return (0);
		++ptr;
	}
	return (1);
}

/*
 * Search for text stored in sgd starting from position fx,fy up to endline. If
 * found, jump to it. If cis then ignore case. The direction is 0 for searching
 * up, down otherwise. If wrap then go to begin/end of grid and try again if
 * not found.
 */
static int
window_copy_search_jump(struct window_pane *wp, struct grid *gd,
    struct grid *sgd, u_int fx, u_int fy, u_int endline, int cis, int wrap,
    int direction)
{
	u_int	i, px;
	int	found;

	found = 0;
	if (direction) {
		for (i = fy; i <= endline; i++) {
			found = window_copy_search_lr(gd, sgd, &px, i, fx,
			    gd->sx, cis);
			if (found)
				break;
			fx = 0;
		}
	} else {
		for (i = fy + 1; endline < i; i--) {
			found = window_copy_search_rl(gd, sgd, &px, i - 1, 0,
			    fx, cis);
			if (found) {
				i--;
				break;
			}
			fx = gd->sx;
		}
	}

	if (found) {
		window_copy_scroll_to(wp, px, i);
		return (1);
	}
	if (wrap) {
		return (window_copy_search_jump(wp, gd, sgd,
		    direction ? 0 : gd->sx - 1,
		    direction ? 0 : gd->hsize + gd->sy - 1, fy, cis, 0,
		    direction));
	}
	return (0);
}

/*
 * Search in for text searchstr. If direction is 0 then search up, otherwise
 * down. If moveflag is 0 then look for string at the current cursor position
 * as well.
 */
static int
window_copy_search(struct window_pane *wp, int direction, int moveflag)
{
	struct window_copy_mode_data	*data = wp->modedata;
	struct screen			*s = data->backing, ss;
	struct screen_write_ctx		 ctx;
	struct grid			*gd = s->grid;
	u_int				 fx, fy, endline;
	int				 wrapflag, cis, found;

	fx = data->cx;
	fy = screen_hsize(data->backing) - data->oy + data->cy;

	screen_init(&ss, screen_write_strlen("%s", data->searchstr), 1, 0);
	screen_write_start(&ctx, NULL, &ss);
	screen_write_nputs(&ctx, -1, &grid_default_cell, "%s", data->searchstr);
	screen_write_stop(&ctx);

	if (moveflag) {
		if (direction)
			window_copy_move_right(s, &fx, &fy);
		else
			window_copy_move_left(s, &fx, &fy);
	}
	window_copy_clear_selection(wp);

	wrapflag = options_get_number(wp->window->options, "wrap-search");
	cis = window_copy_is_lowercase(data->searchstr);

	if (direction)
		endline = gd->hsize + gd->sy - 1;
	else
		endline = 0;
	found = window_copy_search_jump(wp, gd, ss.grid, fx, fy, endline, cis,
	    wrapflag, direction);

	if (window_copy_search_marks(wp, &ss))
		window_copy_redraw_screen(wp);

	screen_free(&ss);
	return (found);
}

static int
window_copy_search_marks(struct window_pane *wp, struct screen *ssp)
{
	struct window_copy_mode_data	*data = wp->modedata;
	struct screen			*s = data->backing, ss;
	struct screen_write_ctx		 ctx;
	struct grid			*gd = s->grid;
	int				 found, cis, which = -1;
	u_int				 px, py, b, nfound = 0, width;

	if (ssp == NULL) {
		width = screen_write_strlen("%s", data->searchstr);
		screen_init(&ss, width, 1, 0);
		screen_write_start(&ctx, NULL, &ss);
		screen_write_nputs(&ctx, -1, &grid_default_cell, "%s",
		    data->searchstr);
		screen_write_stop(&ctx);
		ssp = &ss;
	} else
		width = screen_size_x(ssp);

	cis = window_copy_is_lowercase(data->searchstr);

	free(data->searchmark);
	data->searchmark = bit_alloc((gd->hsize + gd->sy) * gd->sx);

	for (py = 0; py < gd->hsize + gd->sy; py++) {
		px = 0;
		for (;;) {
			found = window_copy_search_lr(gd, ssp->grid, &px, py,
			    px, gd->sx, cis);
			if (!found)
				break;

			nfound++;
			if (px == data->cx && py == gd->hsize + data->cy - data->oy)
				which = nfound;

			b = (py * gd->sx) + px;
			bit_nset(data->searchmark, b, b + width - 1);

			px++;
		}
	}

	if (which != -1)
		data->searchthis = 1 + nfound - which;
	else
		data->searchthis = -1;
	data->searchcount = nfound;

	if (ssp == &ss)
		screen_free(&ss);
	return (nfound);
}

static void
window_copy_clear_marks(struct window_pane *wp)
{
	struct window_copy_mode_data	*data = wp->modedata;

	free(data->searchmark);
	data->searchmark = NULL;
}

static int
window_copy_search_up(struct window_pane *wp, int moveflag)
{
	return (window_copy_search(wp, 0, moveflag));
}

static int
window_copy_search_down(struct window_pane *wp, int moveflag)
{
	return (window_copy_search(wp, 1, moveflag));
}

static void
window_copy_goto_line(struct window_pane *wp, const char *linestr)
{
	struct window_copy_mode_data	*data = wp->modedata;
	const char			*errstr;
	u_int				 lineno;

	lineno = strtonum(linestr, 0, screen_hsize(data->backing), &errstr);
	if (errstr != NULL)
		return;

	data->oy = lineno;
	window_copy_update_selection(wp, 1);
	window_copy_redraw_screen(wp);
}

static void
window_copy_write_line(struct window_pane *wp, struct screen_write_ctx *ctx,
    u_int py)
{
	struct window_copy_mode_data	*data = wp->modedata;
	struct screen			*s = &data->screen;
	struct options			*oo = wp->window->options;
	struct grid_cell		 gc;
	char				 hdr[512];
	size_t				 size = 0;

	style_apply(&gc, oo, "mode-style");
	gc.flags |= GRID_FLAG_NOPALETTE;

	if (py == 0) {
		if (data->searchmark == NULL) {
			size = xsnprintf(hdr, sizeof hdr,
			    "[%u/%u]", data->oy, screen_hsize(data->backing));
		} else {
			if (data->searchthis == -1) {
				size = xsnprintf(hdr, sizeof hdr,
				    "(%u results) [%d/%u]", data->searchcount,
				    data->oy, screen_hsize(data->backing));
			} else {
				size = xsnprintf(hdr, sizeof hdr,
				    "(%u/%u results) [%d/%u]", data->searchthis,
				    data->searchcount, data->oy,
				    screen_hsize(data->backing));
			}
		}
		if (size > screen_size_x(s))
			size = screen_size_x(s);
		screen_write_cursormove(ctx, screen_size_x(s) - size, 0);
		screen_write_puts(ctx, &gc, "%s", hdr);
	} else
		size = 0;

	if (size < screen_size_x(s)) {
		screen_write_cursormove(ctx, 0, py);
		screen_write_copy(ctx, data->backing, 0,
		    (screen_hsize(data->backing) - data->oy) + py,
		    screen_size_x(s) - size, 1, data->searchmark, &gc);
	}

	if (py == data->cy && data->cx == screen_size_x(s)) {
		memcpy(&gc, &grid_default_cell, sizeof gc);
		screen_write_cursormove(ctx, screen_size_x(s) - 1, py);
		screen_write_putc(ctx, &gc, '$');
	}
}

static void
window_copy_write_lines(struct window_pane *wp, struct screen_write_ctx *ctx,
    u_int py, u_int ny)
{
	u_int	yy;

	for (yy = py; yy < py + ny; yy++)
		window_copy_write_line(wp, ctx, py);
}

static void
window_copy_redraw_selection(struct window_pane *wp, u_int old_y)
{
	struct window_copy_mode_data	*data = wp->modedata;
	u_int				 new_y, start, end;

	new_y = data->cy;
	if (old_y <= new_y) {
		start = old_y;
		end = new_y;
	} else {
		start = new_y;
		end = old_y;
	}
	window_copy_redraw_lines(wp, start, end - start + 1);
}

static void
window_copy_redraw_lines(struct window_pane *wp, u_int py, u_int ny)
{
	struct window_copy_mode_data	*data = wp->modedata;
	struct screen_write_ctx	 	 ctx;
	u_int				 i;

	screen_write_start(&ctx, wp, NULL);
	for (i = py; i < py + ny; i++)
		window_copy_write_line(wp, &ctx, i);
	screen_write_cursormove(&ctx, data->cx, data->cy);
	screen_write_stop(&ctx);
}

static void
window_copy_redraw_screen(struct window_pane *wp)
{
	struct window_copy_mode_data	*data = wp->modedata;

	window_copy_redraw_lines(wp, 0, screen_size_y(&data->screen));
}

static void
window_copy_synchronize_cursor(struct window_pane *wp)
{
	struct window_copy_mode_data	*data = wp->modedata;
	u_int				 xx, yy;

	xx = data->cx;
	yy = screen_hsize(data->backing) + data->cy - data->oy;

	switch (data->cursordrag) {
	case CURSORDRAG_ENDSEL:
		data->endselx = xx;
		data->endsely = yy;
		break;
	case CURSORDRAG_SEL:
		data->selx = xx;
		data->sely = yy;
		break;
	case CURSORDRAG_NONE:
		break;
	}
}

static void
window_copy_update_cursor(struct window_pane *wp, u_int cx, u_int cy)
{
	struct window_copy_mode_data	*data = wp->modedata;
	struct screen			*s = &data->screen;
	struct screen_write_ctx		 ctx;
	u_int				 old_cx, old_cy;

	old_cx = data->cx; old_cy = data->cy;
	data->cx = cx; data->cy = cy;
	if (old_cx == screen_size_x(s))
		window_copy_redraw_lines(wp, old_cy, 1);
	if (data->cx == screen_size_x(s))
		window_copy_redraw_lines(wp, data->cy, 1);
	else {
		screen_write_start(&ctx, wp, NULL);
		screen_write_cursormove(&ctx, data->cx, data->cy);
		screen_write_stop(&ctx);
	}
}

static void
window_copy_start_selection(struct window_pane *wp)
{
	struct window_copy_mode_data	*data = wp->modedata;
	struct screen			*s = &data->screen;

	data->selx = data->cx;
	data->sely = screen_hsize(data->backing) + data->cy - data->oy;

	data->endselx = data->selx;
	data->endsely = data->sely;

	data->cursordrag = CURSORDRAG_ENDSEL;

	s->sel.flag = 1;
	window_copy_update_selection(wp, 1);
}

static int
window_copy_adjust_selection(struct window_pane *wp, u_int *selx, u_int *sely)
{
	struct window_copy_mode_data	*data = wp->modedata;
	struct screen			*s = &data->screen;
	u_int 				 sx, sy, ty;
	int				 relpos;

	sx = *selx;
	sy = *sely;

	ty = screen_hsize(data->backing) - data->oy;
	if (sy < ty) {
		relpos = WINDOW_COPY_REL_POS_ABOVE;
		if (!data->rectflag)
			sx = 0;
		sy = 0;
	} else if (sy > ty + screen_size_y(s) - 1) {
		relpos = WINDOW_COPY_REL_POS_BELOW;
		if (!data->rectflag)
			sx = screen_size_x(s) - 1;
		sy = screen_size_y(s) - 1;
	} else {
		relpos = WINDOW_COPY_REL_POS_ON_SCREEN;
		sy -= ty;
	}

	*selx = sx;
	*sely = screen_hsize(s) + sy;
	return (relpos);
}

static int
window_copy_update_selection(struct window_pane *wp, int may_redraw)
{
	struct window_copy_mode_data	*data = wp->modedata;
	struct screen			*s = &data->screen;
	struct options			*oo = wp->window->options;
	struct grid_cell		 gc;
	u_int				 sx, sy, cy, endsx, endsy;
	int				 startrelpos, endrelpos;

	if (!s->sel.flag && s->sel.lineflag == LINE_SEL_NONE)
		return (0);

	window_copy_synchronize_cursor(wp);

	/* Adjust the selection. */
	sx = data->selx;
	sy = data->sely;
	startrelpos = window_copy_adjust_selection(wp, &sx, &sy);

	/* Adjust the end of selection. */
	endsx = data->endselx;
	endsy = data->endsely;
	endrelpos = window_copy_adjust_selection(wp, &endsx, &endsy);

	/* Selection is outside of the current screen */
	if (startrelpos == endrelpos &&
	    startrelpos != WINDOW_COPY_REL_POS_ON_SCREEN) {
		screen_hide_selection(s);
		return (0);
	}

	/* Set colours and selection. */
	style_apply(&gc, oo, "mode-style");
	gc.flags |= GRID_FLAG_NOPALETTE;
	screen_set_selection(s, sx, sy, endsx, endsy, data->rectflag, &gc);

	if (data->rectflag && may_redraw) {
		/*
		 * Can't rely on the caller to redraw the right lines for
		 * rectangle selection - find the highest line and the number
		 * of lines, and redraw just past that in both directions
		 */
		cy = data->cy;
		if (sy < cy)
			window_copy_redraw_lines(wp, sy, cy - sy + 1);
		else
			window_copy_redraw_lines(wp, cy, sy - cy + 1);
	}

	return (1);
}

static void *
window_copy_get_selection(struct window_pane *wp, size_t *len)
{
	struct window_copy_mode_data	*data = wp->modedata;
	struct screen			*s = &data->screen;
	char				*buf;
	size_t				 off;
	u_int				 i, xx, yy, sx, sy, ex, ey, ey_last;
	u_int				 firstsx, lastex, restex, restsx;
	int				 keys;

	if (!s->sel.flag && s->sel.lineflag == LINE_SEL_NONE)
		return (NULL);

	buf = xmalloc(1);
	off = 0;

	*buf = '\0';

	/*
	 * The selection extends from selx,sely to (adjusted) cx,cy on
	 * the base screen.
	 */

	/* Find start and end. */
	xx = data->endselx;
	yy = data->endsely;
	if (yy < data->sely || (yy == data->sely && xx < data->selx)) {
		sx = xx; sy = yy;
		ex = data->selx; ey = data->sely;
	} else {
		sx = data->selx; sy = data->sely;
		ex = xx; ey = yy;
	}

	/* Trim ex to end of line. */
	ey_last = window_copy_find_length(wp, ey);
	if (ex > ey_last)
		ex = ey_last;

	/*
	 * Deal with rectangle-copy if necessary; four situations: start of
	 * first line (firstsx), end of last line (lastex), start (restsx) and
	 * end (restex) of all other lines.
	 */
	xx = screen_size_x(s);

	/*
	 * Behave according to mode-keys. If it is emacs, copy like emacs,
	 * keeping the top-left-most character, and dropping the
	 * bottom-right-most, regardless of copy direction. If it is vi, also
	 * keep bottom-right-most character.
	 */
	keys = options_get_number(wp->window->options, "mode-keys");
	if (data->rectflag) {
		/*
		 * Need to ignore the column with the cursor in it, which for
		 * rectangular copy means knowing which side the cursor is on.
		 */
		if (data->selx < data->cx) {
			/* Selection start is on the left. */
			if (keys == MODEKEY_EMACS) {
				lastex = data->cx;
				restex = data->cx;
			}
			else {
				lastex = data->cx + 1;
				restex = data->cx + 1;
			}
			firstsx = data->selx;
			restsx = data->selx;
		} else {
			/* Cursor is on the left. */
			lastex = data->selx + 1;
			restex = data->selx + 1;
			firstsx = data->cx;
			restsx = data->cx;
		}
	} else {
		if (keys == MODEKEY_EMACS)
			lastex = ex;
		else
			lastex = ex + 1;
		restex = xx;
		firstsx = sx;
		restsx = 0;
	}

	/* Copy the lines. */
	for (i = sy; i <= ey; i++) {
		window_copy_copy_line(wp, &buf, &off, i,
		    (i == sy ? firstsx : restsx),
		    (i == ey ? lastex : restex));
	}

	/* Don't bother if no data. */
	if (off == 0) {
		free(buf);
		return (NULL);
	}
	if (keys == MODEKEY_EMACS || lastex <= ey_last)
		off -= 1; /* remove final \n (unless at end in vi mode) */
	*len = off;
	return (buf);
}

static void
window_copy_copy_buffer(struct window_pane *wp, const char *bufname, void *buf,
    size_t len)
{
	struct screen_write_ctx	ctx;

	if (options_get_number(global_options, "set-clipboard")) {
		screen_write_start(&ctx, wp, NULL);
		screen_write_setselection(&ctx, buf, len);
		screen_write_stop(&ctx);
	}

	if (paste_set(buf, len, bufname, NULL) != 0)
		free(buf);
}

static void
window_copy_copy_pipe(struct window_pane *wp, struct session *s,
    const char *bufname, const char *arg)
{
	void		*buf;
	size_t		 len;
	struct job	*job;
	char		*expanded;

	buf = window_copy_get_selection(wp, &len);
	if (buf == NULL)
		return;
	expanded = format_single(NULL, arg, NULL, s, NULL, wp);

	job = job_run(expanded, s, NULL, NULL, NULL, NULL);
	bufferevent_write(job->event, buf, len);

	free(expanded);
	window_copy_copy_buffer(wp, bufname, buf, len);
}

static void
window_copy_copy_selection(struct window_pane *wp, const char *bufname)
{
	void	*buf;
	size_t	 len;

	buf = window_copy_get_selection(wp, &len);
	if (buf == NULL)
		return;

	window_copy_copy_buffer(wp, bufname, buf, len);
}

static void
window_copy_append_selection(struct window_pane *wp, const char *bufname)
{
	char				*buf;
	struct paste_buffer		*pb;
	const char			*bufdata;
	size_t				 len, bufsize;
	struct screen_write_ctx		 ctx;

	buf = window_copy_get_selection(wp, &len);
	if (buf == NULL)
		return;

	if (options_get_number(global_options, "set-clipboard")) {
		screen_write_start(&ctx, wp, NULL);
		screen_write_setselection(&ctx, buf, len);
		screen_write_stop(&ctx);
	}

	if (bufname == NULL || *bufname == '\0')
		pb = paste_get_top(&bufname);
	else
		pb = paste_get_name(bufname);
	if (pb != NULL) {
		bufdata = paste_buffer_data(pb, &bufsize);
		buf = xrealloc(buf, len + bufsize);
		memmove(buf + bufsize, buf, len);
		memcpy(buf, bufdata, bufsize);
		len += bufsize;
	}
	if (paste_set(buf, len, bufname, NULL) != 0)
		free(buf);
}

static void
window_copy_copy_line(struct window_pane *wp, char **buf, size_t *off, u_int sy,
    u_int sx, u_int ex)
{
	struct window_copy_mode_data	*data = wp->modedata;
	struct grid			*gd = data->backing->grid;
	struct grid_cell		 gc;
	struct grid_line		*gl;
	struct utf8_data		 ud;
	u_int				 i, xx, wrapped = 0;
	const char			*s;

	if (sx > ex)
		return;

	/*
	 * Work out if the line was wrapped at the screen edge and all of it is
	 * on screen.
	 */
	gl = &gd->linedata[sy];
	if (gl->flags & GRID_LINE_WRAPPED && gl->cellsize <= gd->sx)
		wrapped = 1;

	/* If the line was wrapped, don't strip spaces (use the full length). */
	if (wrapped)
		xx = gl->cellsize;
	else
		xx = window_copy_find_length(wp, sy);
	if (ex > xx)
		ex = xx;
	if (sx > xx)
		sx = xx;

	if (sx < ex) {
		for (i = sx; i < ex; i++) {
			grid_get_cell(gd, i, sy, &gc);
			if (gc.flags & GRID_FLAG_PADDING)
				continue;
			utf8_copy(&ud, &gc.data);
			if (ud.size == 1 && (gc.attr & GRID_ATTR_CHARSET)) {
				s = tty_acs_get(NULL, ud.data[0]);
				if (s != NULL && strlen(s) <= sizeof ud.data) {
					ud.size = strlen(s);
					memcpy(ud.data, s, ud.size);
				}
			}

			*buf = xrealloc(*buf, (*off) + ud.size);
			memcpy(*buf + *off, ud.data, ud.size);
			*off += ud.size;
		}
	}

	/* Only add a newline if the line wasn't wrapped. */
	if (!wrapped || ex != xx) {
		*buf = xrealloc(*buf, (*off) + 1);
		(*buf)[(*off)++] = '\n';
	}
}

static void
window_copy_clear_selection(struct window_pane *wp)
{
	struct window_copy_mode_data   *data = wp->modedata;
	u_int				px, py;

	screen_clear_selection(&data->screen);

	data->cursordrag = CURSORDRAG_NONE;

	py = screen_hsize(data->backing) + data->cy - data->oy;
	px = window_copy_find_length(wp, py);
	if (data->cx > px)
		window_copy_update_cursor(wp, px, data->cy);
}

static int
window_copy_in_set(struct window_pane *wp, u_int px, u_int py, const char *set)
{
	struct window_copy_mode_data	*data = wp->modedata;
	struct grid_cell		 gc;
	const struct utf8_data		*ud;

	grid_get_cell(data->backing->grid, px, py, &gc);

	ud = &gc.data;
	if (ud->size != 1 || (gc.flags & GRID_FLAG_PADDING))
		return (0);
	if (*ud->data == 0x00 || *ud->data == 0x7f)
		return (0);
	return (strchr(set, *ud->data) != NULL);
}

static u_int
window_copy_find_length(struct window_pane *wp, u_int py)
{
	struct window_copy_mode_data	*data = wp->modedata;
	struct screen			*s = data->backing;
	struct grid_cell		 gc;
	u_int				 px;

	/*
	 * If the pane has been resized, its grid can contain old overlong
	 * lines. grid_peek_cell does not allow accessing cells beyond the
	 * width of the grid, and screen_write_copy treats them as spaces, so
	 * ignore them here too.
	 */
	px = s->grid->linedata[py].cellsize;
	if (px > screen_size_x(s))
		px = screen_size_x(s);
	while (px > 0) {
		grid_get_cell(s->grid, px - 1, py, &gc);
		if (gc.data.size != 1 || *gc.data.data != ' ')
			break;
		px--;
	}
	return (px);
}

static void
window_copy_cursor_start_of_line(struct window_pane *wp)
{
	struct window_copy_mode_data	*data = wp->modedata;
	struct screen			*back_s = data->backing;
	struct screen			*s = &data->screen;
	struct grid			*gd = back_s->grid;
	u_int				 py;

	if (data->cx == 0 && s->sel.lineflag == LINE_SEL_NONE) {
		py = screen_hsize(back_s) + data->cy - data->oy;
		while (py > 0 &&
		    gd->linedata[py-1].flags & GRID_LINE_WRAPPED) {
			window_copy_cursor_up(wp, 0);
			py = screen_hsize(back_s) + data->cy - data->oy;
		}
	}
	window_copy_update_cursor(wp, 0, data->cy);
	if (window_copy_update_selection(wp, 1))
		window_copy_redraw_lines(wp, data->cy, 1);
}

static void
window_copy_cursor_back_to_indentation(struct window_pane *wp)
{
	struct window_copy_mode_data	*data = wp->modedata;
	u_int				 px, py, xx;
	struct grid_cell		 gc;

	px = 0;
	py = screen_hsize(data->backing) + data->cy - data->oy;
	xx = window_copy_find_length(wp, py);

	while (px < xx) {
		grid_get_cell(data->backing->grid, px, py, &gc);
		if (gc.data.size != 1 || *gc.data.data != ' ')
			break;
		px++;
	}

	window_copy_update_cursor(wp, px, data->cy);
	if (window_copy_update_selection(wp, 1))
		window_copy_redraw_lines(wp, data->cy, 1);
}

static void
window_copy_cursor_end_of_line(struct window_pane *wp)
{
	struct window_copy_mode_data	*data = wp->modedata;
	struct screen			*back_s = data->backing;
	struct screen			*s = &data->screen;
	struct grid			*gd = back_s->grid;
	u_int				 px, py;

	py = screen_hsize(back_s) + data->cy - data->oy;
	px = window_copy_find_length(wp, py);

	if (data->cx == px && s->sel.lineflag == LINE_SEL_NONE) {
		if (data->screen.sel.flag && data->rectflag)
			px = screen_size_x(back_s);
		if (gd->linedata[py].flags & GRID_LINE_WRAPPED) {
			while (py < gd->sy + gd->hsize &&
			    gd->linedata[py].flags & GRID_LINE_WRAPPED) {
				window_copy_cursor_down(wp, 0);
				py = screen_hsize(back_s)
				     + data->cy - data->oy;
			}
			px = window_copy_find_length(wp, py);
		}
	}
	window_copy_update_cursor(wp, px, data->cy);

	if (window_copy_update_selection(wp, 1))
		window_copy_redraw_lines(wp, data->cy, 1);
}

static void
window_copy_other_end(struct window_pane *wp)
{
	struct window_copy_mode_data	*data = wp->modedata;
	struct screen			*s = &data->screen;
	u_int				 selx, sely, cy, yy, hsize;

	if (!s->sel.flag && s->sel.lineflag == LINE_SEL_NONE)
		return;

	if (s->sel.lineflag == LINE_SEL_LEFT_RIGHT)
		s->sel.lineflag = LINE_SEL_RIGHT_LEFT;
	else if (s->sel.lineflag == LINE_SEL_RIGHT_LEFT)
		s->sel.lineflag = LINE_SEL_LEFT_RIGHT;

	switch (data->cursordrag) {
		case CURSORDRAG_NONE:
		case CURSORDRAG_SEL:
			data->cursordrag = CURSORDRAG_ENDSEL;
			break;
		case CURSORDRAG_ENDSEL:
			data->cursordrag = CURSORDRAG_SEL;
			break;
	}

	selx = data->endselx;
	sely = data->endsely;
	if (data->cursordrag == CURSORDRAG_SEL) {
		selx = data->selx;
		sely = data->sely;
	}

	cy = data->cy;
	yy = screen_hsize(data->backing) + data->cy - data->oy;

	data->cx = selx;

	hsize = screen_hsize(data->backing);
	if (sely < hsize - data->oy) { /* above */
		data->oy = hsize - sely;
		data->cy = 0;
	} else if (sely > hsize - data->oy + screen_size_y(s)) { /* below */
		data->oy = hsize - sely + screen_size_y(s) - 1;
		data->cy = screen_size_y(s) - 1;
	} else
		data->cy = cy + sely - yy;

	window_copy_update_selection(wp, 1);
	window_copy_redraw_screen(wp);
}

static void
window_copy_cursor_left(struct window_pane *wp)
{
	struct window_copy_mode_data	*data = wp->modedata;
	u_int				 py, cx;
	struct grid_cell		 gc;

	py = screen_hsize(data->backing) + data->cy - data->oy;
	cx = data->cx;
	while (cx > 0) {
		grid_get_cell(data->backing->grid, cx, py, &gc);
		if (~gc.flags & GRID_FLAG_PADDING)
			break;
		cx--;
	}
	if (cx == 0 && py > 0) {
		window_copy_cursor_up(wp, 0);
		window_copy_cursor_end_of_line(wp);
	} else if (cx > 0) {
		window_copy_update_cursor(wp, cx - 1, data->cy);
		if (window_copy_update_selection(wp, 1))
			window_copy_redraw_lines(wp, data->cy, 1);
	}
}

static void
window_copy_cursor_right(struct window_pane *wp)
{
	struct window_copy_mode_data	*data = wp->modedata;
	u_int				 px, py, yy, cx, cy;
	struct grid_cell		 gc;

	py = screen_hsize(data->backing) + data->cy - data->oy;
	yy = screen_hsize(data->backing) + screen_size_y(data->backing) - 1;
	if (data->screen.sel.flag && data->rectflag)
		px = screen_size_x(&data->screen);
	else
		px = window_copy_find_length(wp, py);

	if (data->cx >= px && py < yy) {
		window_copy_cursor_start_of_line(wp);
		window_copy_cursor_down(wp, 0);
	} else if (data->cx < px) {
		cx = data->cx + 1;
		cy = screen_hsize(data->backing) + data->cy - data->oy;
		while (cx < px) {
			grid_get_cell(data->backing->grid, cx, cy, &gc);
			if (~gc.flags & GRID_FLAG_PADDING)
				break;
			cx++;
		}
		window_copy_update_cursor(wp, cx, data->cy);
		if (window_copy_update_selection(wp, 1))
			window_copy_redraw_lines(wp, data->cy, 1);
	}
}

static void
window_copy_cursor_up(struct window_pane *wp, int scroll_only)
{
	struct window_copy_mode_data	*data = wp->modedata;
	struct screen			*s = &data->screen;
	u_int				 ox, oy, px, py;

	oy = screen_hsize(data->backing) + data->cy - data->oy;
	ox = window_copy_find_length(wp, oy);
	if (data->cx != ox) {
		data->lastcx = data->cx;
		data->lastsx = ox;
	}

	if (s->sel.lineflag == LINE_SEL_LEFT_RIGHT && oy == data->sely)
		window_copy_other_end(wp);

	data->cx = data->lastcx;
	if (scroll_only || data->cy == 0) {
		window_copy_scroll_down(wp, 1);
		if (scroll_only) {
			if (data->cy == screen_size_y(s) - 1)
				window_copy_redraw_lines(wp, data->cy, 1);
			else
				window_copy_redraw_lines(wp, data->cy, 2);
		}
	} else {
		window_copy_update_cursor(wp, data->cx, data->cy - 1);
		if (window_copy_update_selection(wp, 1)) {
			if (data->cy == screen_size_y(s) - 1)
				window_copy_redraw_lines(wp, data->cy, 1);
			else
				window_copy_redraw_lines(wp, data->cy, 2);
		}
	}

	if (!data->screen.sel.flag || !data->rectflag) {
		py = screen_hsize(data->backing) + data->cy - data->oy;
		px = window_copy_find_length(wp, py);
		if ((data->cx >= data->lastsx && data->cx != px) ||
		    data->cx > px)
			window_copy_cursor_end_of_line(wp);
	}

	if (s->sel.lineflag == LINE_SEL_LEFT_RIGHT)
		window_copy_cursor_end_of_line(wp);
	else if (s->sel.lineflag == LINE_SEL_RIGHT_LEFT)
		window_copy_cursor_start_of_line(wp);
}

static void
window_copy_cursor_down(struct window_pane *wp, int scroll_only)
{
	struct window_copy_mode_data	*data = wp->modedata;
	struct screen			*s = &data->screen;
	u_int				 ox, oy, px, py;

	oy = screen_hsize(data->backing) + data->cy - data->oy;
	ox = window_copy_find_length(wp, oy);
	if (data->cx != ox) {
		data->lastcx = data->cx;
		data->lastsx = ox;
	}

	if (s->sel.lineflag == LINE_SEL_RIGHT_LEFT && oy == data->endsely)
		window_copy_other_end(wp);

	data->cx = data->lastcx;
	if (scroll_only || data->cy == screen_size_y(s) - 1) {
		window_copy_scroll_up(wp, 1);
		if (scroll_only && data->cy > 0)
			window_copy_redraw_lines(wp, data->cy - 1, 2);
	} else {
		window_copy_update_cursor(wp, data->cx, data->cy + 1);
		if (window_copy_update_selection(wp, 1))
			window_copy_redraw_lines(wp, data->cy - 1, 2);
	}

	if (!data->screen.sel.flag || !data->rectflag) {
		py = screen_hsize(data->backing) + data->cy - data->oy;
		px = window_copy_find_length(wp, py);
		if ((data->cx >= data->lastsx && data->cx != px) ||
		    data->cx > px)
			window_copy_cursor_end_of_line(wp);
	}

	if (s->sel.lineflag == LINE_SEL_LEFT_RIGHT)
		window_copy_cursor_end_of_line(wp);
	else if (s->sel.lineflag == LINE_SEL_RIGHT_LEFT)
		window_copy_cursor_start_of_line(wp);
}

static void
window_copy_cursor_jump(struct window_pane *wp)
{
	struct window_copy_mode_data	*data = wp->modedata;
	struct screen			*back_s = data->backing;
	struct grid_cell		 gc;
	u_int				 px, py, xx;

	px = data->cx + 1;
	py = screen_hsize(back_s) + data->cy - data->oy;
	xx = window_copy_find_length(wp, py);

	while (px < xx) {
		grid_get_cell(back_s->grid, px, py, &gc);
		if (!(gc.flags & GRID_FLAG_PADDING) &&
		    gc.data.size == 1 && *gc.data.data == data->jumpchar) {
			window_copy_update_cursor(wp, px, data->cy);
			if (window_copy_update_selection(wp, 1))
				window_copy_redraw_lines(wp, data->cy, 1);
			return;
		}
		px++;
	}
}

static void
window_copy_cursor_jump_back(struct window_pane *wp)
{
	struct window_copy_mode_data	*data = wp->modedata;
	struct screen			*back_s = data->backing;
	struct grid_cell		 gc;
	u_int				 px, py;

	px = data->cx;
	py = screen_hsize(back_s) + data->cy - data->oy;

	if (px > 0)
		px--;

	for (;;) {
		grid_get_cell(back_s->grid, px, py, &gc);
		if (!(gc.flags & GRID_FLAG_PADDING) &&
		    gc.data.size == 1 && *gc.data.data == data->jumpchar) {
			window_copy_update_cursor(wp, px, data->cy);
			if (window_copy_update_selection(wp, 1))
				window_copy_redraw_lines(wp, data->cy, 1);
			return;
		}
		if (px == 0)
			break;
		px--;
	}
}

static void
window_copy_cursor_jump_to(struct window_pane *wp, int jump_again)
{
	struct window_copy_mode_data	*data = wp->modedata;
	struct screen			*back_s = data->backing;
	struct grid_cell		 gc;
	u_int				 px, py, xx;

	px = data->cx + 1 + jump_again;
	py = screen_hsize(back_s) + data->cy - data->oy;
	xx = window_copy_find_length(wp, py);

	while (px < xx) {
		grid_get_cell(back_s->grid, px, py, &gc);
		if (!(gc.flags & GRID_FLAG_PADDING) &&
		    gc.data.size == 1 && *gc.data.data == data->jumpchar) {
			window_copy_update_cursor(wp, px - 1, data->cy);
			if (window_copy_update_selection(wp, 1))
				window_copy_redraw_lines(wp, data->cy, 1);
			return;
		}
		px++;
	}
}

static void
window_copy_cursor_jump_to_back(struct window_pane *wp, int jump_again)
{
	struct window_copy_mode_data	*data = wp->modedata;
	struct screen			*back_s = data->backing;
	struct grid_cell		 gc;
	u_int				 px, py;

	px = data->cx;
	py = screen_hsize(back_s) + data->cy - data->oy;

	if (px > 0)
		px--;

	if (jump_again && px > 0)
		px--;

	for (;;) {
		grid_get_cell(back_s->grid, px, py, &gc);
		if (!(gc.flags & GRID_FLAG_PADDING) &&
		    gc.data.size == 1 && *gc.data.data == data->jumpchar) {
			window_copy_update_cursor(wp, px + 1, data->cy);
			if (window_copy_update_selection(wp, 1))
				window_copy_redraw_lines(wp, data->cy, 1);
			return;
		}
		if (px == 0)
			break;
		px--;
	}
}

static void
window_copy_cursor_next_word(struct window_pane *wp, const char *separators)
{
	struct window_copy_mode_data	*data = wp->modedata;
	struct screen			*back_s = data->backing;
	u_int				 px, py, xx, yy;
	int				 expected = 0;

	px = data->cx;
	py = screen_hsize(back_s) + data->cy - data->oy;
	xx = window_copy_find_length(wp, py);
	yy = screen_hsize(back_s) + screen_size_y(back_s) - 1;

	/*
	 * First skip past any nonword characters and then any word characters.
	 *
	 * expected is initially set to 0 for the former and then 1 for the
	 * latter.
	 */
	do {
		while (px > xx ||
		    window_copy_in_set(wp, px, py, separators) == expected) {
			/* Move down if we're past the end of the line. */
			if (px > xx) {
				if (py == yy)
					return;
				window_copy_cursor_down(wp, 0);
				px = 0;

				py = screen_hsize(back_s) + data->cy - data->oy;
				xx = window_copy_find_length(wp, py);
			} else
				px++;
		}
		expected = !expected;
	} while (expected == 1);

	window_copy_update_cursor(wp, px, data->cy);
	if (window_copy_update_selection(wp, 1))
		window_copy_redraw_lines(wp, data->cy, 1);
}

static void
window_copy_cursor_next_word_end(struct window_pane *wp,
    const char *separators)
{
	struct window_copy_mode_data	*data = wp->modedata;
	struct options			*oo = wp->window->options;
	struct screen			*back_s = data->backing;
	u_int				 px, py, xx, yy;
	int				 keys, expected = 1;

	px = data->cx;
	py = screen_hsize(back_s) + data->cy - data->oy;
	xx = window_copy_find_length(wp, py);
	yy = screen_hsize(back_s) + screen_size_y(back_s) - 1;

	keys = options_get_number(oo, "mode-keys");
	if (keys == MODEKEY_VI && !window_copy_in_set(wp, px, py, separators))
		px++;

	/*
	 * First skip past any word characters, then any nonword characters.
	 *
	 * expected is initially set to 1 for the former and then 0 for the
	 * latter.
	 */
	do {
		while (px > xx ||
		    window_copy_in_set(wp, px, py, separators) == expected) {
			/* Move down if we're past the end of the line. */
			if (px > xx) {
				if (py == yy)
					return;
				window_copy_cursor_down(wp, 0);
				px = 0;

				py = screen_hsize(back_s) + data->cy - data->oy;
				xx = window_copy_find_length(wp, py);
			} else
				px++;
		}
		expected = !expected;
	} while (expected == 0);

	if (keys == MODEKEY_VI && px != 0)
		px--;

	window_copy_update_cursor(wp, px, data->cy);
	if (window_copy_update_selection(wp, 1))
		window_copy_redraw_lines(wp, data->cy, 1);
}

/* Move to the previous place where a word begins. */
static void
window_copy_cursor_previous_word(struct window_pane *wp,
    const char *separators)
{
	struct window_copy_mode_data	*data = wp->modedata;
	u_int				 px, py;

	px = data->cx;
	py = screen_hsize(data->backing) + data->cy - data->oy;

	/* Move back to the previous word character. */
	for (;;) {
		if (px > 0) {
			px--;
			if (!window_copy_in_set(wp, px, py, separators))
				break;
		} else {
			if (data->cy == 0 &&
			    (screen_hsize(data->backing) == 0 ||
			    data->oy >= screen_hsize(data->backing) - 1))
				goto out;
			window_copy_cursor_up(wp, 0);

			py = screen_hsize(data->backing) + data->cy - data->oy;
			px = window_copy_find_length(wp, py);
		}
	}

	/* Move back to the beginning of this word. */
	while (px > 0 && !window_copy_in_set(wp, px - 1, py, separators))
		px--;

out:
	window_copy_update_cursor(wp, px, data->cy);
	if (window_copy_update_selection(wp, 1))
		window_copy_redraw_lines(wp, data->cy, 1);
}

static void
window_copy_scroll_up(struct window_pane *wp, u_int ny)
{
	struct window_copy_mode_data	*data = wp->modedata;
	struct screen			*s = &data->screen;
	struct screen_write_ctx		 ctx;

	if (data->oy < ny)
		ny = data->oy;
	if (ny == 0)
		return;
	data->oy -= ny;

	window_copy_update_selection(wp, 0);

	screen_write_start(&ctx, wp, NULL);
	screen_write_cursormove(&ctx, 0, 0);
	screen_write_deleteline(&ctx, ny, 8);
	window_copy_write_lines(wp, &ctx, screen_size_y(s) - ny, ny);
	window_copy_write_line(wp, &ctx, 0);
	if (screen_size_y(s) > 1)
		window_copy_write_line(wp, &ctx, 1);
	if (screen_size_y(s) > 3)
		window_copy_write_line(wp, &ctx, screen_size_y(s) - 2);
	if (s->sel.flag && screen_size_y(s) > ny)
		window_copy_write_line(wp, &ctx, screen_size_y(s) - ny - 1);
	screen_write_cursormove(&ctx, data->cx, data->cy);
	screen_write_stop(&ctx);
}

static void
window_copy_scroll_down(struct window_pane *wp, u_int ny)
{
	struct window_copy_mode_data	*data = wp->modedata;
	struct screen			*s = &data->screen;
	struct screen_write_ctx		 ctx;

	if (ny > screen_hsize(data->backing))
		return;

	if (data->oy > screen_hsize(data->backing) - ny)
		ny = screen_hsize(data->backing) - data->oy;
	if (ny == 0)
		return;
	data->oy += ny;

	window_copy_update_selection(wp, 0);

	screen_write_start(&ctx, wp, NULL);
	screen_write_cursormove(&ctx, 0, 0);
	screen_write_insertline(&ctx, ny, 8);
	window_copy_write_lines(wp, &ctx, 0, ny);
	if (s->sel.flag && screen_size_y(s) > ny)
		window_copy_write_line(wp, &ctx, ny);
	else if (ny == 1) /* nuke position */
		window_copy_write_line(wp, &ctx, 1);
	screen_write_cursormove(&ctx, data->cx, data->cy);
	screen_write_stop(&ctx);
}

int
window_copy_scroll_position(struct window_pane *wp)
{
	struct window_copy_mode_data	*data = wp->modedata;

	if (wp->mode != &window_copy_mode)
		return (-1);
	return (data->oy);
}

static void
window_copy_rectangle_toggle(struct window_pane *wp)
{
	struct window_copy_mode_data	*data = wp->modedata;
	u_int				 px, py;

	data->rectflag = !data->rectflag;

	py = screen_hsize(data->backing) + data->cy - data->oy;
	px = window_copy_find_length(wp, py);
	if (data->cx > px)
		window_copy_update_cursor(wp, px, data->cy);

	window_copy_update_selection(wp, 1);
	window_copy_redraw_screen(wp);
}

static void
window_copy_move_mouse(struct mouse_event *m)
{
	struct window_pane	*wp;
	u_int			 x, y;

	wp = cmd_mouse_pane(m, NULL, NULL);
	if (wp == NULL || wp->mode != &window_copy_mode)
		return;

	if (cmd_mouse_at(wp, m, &x, &y, 1) != 0)
		return;

	window_copy_update_cursor(wp, x, y);
}

void
window_copy_start_drag(struct client *c, struct mouse_event *m)
{
	struct window_pane	*wp;
	u_int			 x, y;

	if (c == NULL)
		return;

	wp = cmd_mouse_pane(m, NULL, NULL);
	if (wp == NULL || wp->mode != &window_copy_mode)
		return;

	if (cmd_mouse_at(wp, m, &x, &y, 1) != 0)
		return;

	c->tty.mouse_drag_update = window_copy_drag_update;
	c->tty.mouse_drag_release = NULL; /* will fire MouseDragEnd key */

	window_copy_update_cursor(wp, x, y);
	window_copy_start_selection(wp);
	window_copy_redraw_screen(wp);
}

static void
window_copy_drag_update(__unused struct client *c, struct mouse_event *m)
{
	struct window_pane		*wp;
	struct window_copy_mode_data	*data;
	u_int				 x, y, old_cy;

	wp = cmd_mouse_pane(m, NULL, NULL);
	if (wp == NULL || wp->mode != &window_copy_mode)
		return;
	data = wp->modedata;

	if (cmd_mouse_at(wp, m, &x, &y, 0) != 0)
		return;
	old_cy = data->cy;

	window_copy_update_cursor(wp, x, y);
	if (window_copy_update_selection(wp, 1))
		window_copy_redraw_selection(wp, old_cy);
}
@


1.169
log
@Fix movement after select-line, from Omar Sandoval.
@
text
@d1 1
a1 1
/* $OpenBSD: window-copy.c,v 1.168 2017/03/08 20:05:25 nicm Exp $ */
d177 2
d1175 1
a1175 1
	int				 found, cis;
d1201 1
d1203 2
d1213 6
d1276 15
a1290 2
		size = xsnprintf(hdr, sizeof hdr,
		    "[%u/%u]", data->oy, screen_hsize(data->backing));
@


1.168
log
@Skip over padding cells when moving the cursor left or right.
@
text
@d1 1
a1 1
/* $OpenBSD: window-copy.c,v 1.167 2017/03/08 13:36:12 nicm Exp $ */
d2041 1
a2041 1
	if (s->sel.lineflag == LINE_SEL_RIGHT_LEFT && oy == data->sely)
@


1.167
log
@Add a helper function for the most common format_create/defaults/expand
pattern.
@
text
@d1 1
a1 1
/* $OpenBSD: window-copy.c,v 1.166 2017/02/08 17:33:51 nicm Exp $ */
d1924 2
a1925 1
	u_int				 py;
d1928 8
a1935 1
	if (data->cx == 0 && py > 0) {
d1938 2
a1939 2
	} else if (data->cx > 0) {
		window_copy_update_cursor(wp, data->cx - 1, data->cy);
d1949 2
a1950 1
	u_int				 px, py, yy;
d1956 1
a1956 1
	else {
a1957 1
	}
d1963 9
a1971 1
		window_copy_update_cursor(wp, data->cx + 1, data->cy);
@


1.166
log
@window_copy_pagedown shouldn't reset the mode anymore, instead let the
caller do it so it can free the marks. Problem reported by attila at
stalphonsos dot com.
@
text
@d1 1
a1 1
/* $OpenBSD: window-copy.c,v 1.165 2017/02/03 11:57:28 nicm Exp $ */
d1607 1
a1607 1
window_copy_copy_pipe(struct window_pane *wp, struct session *sess,
d1610 4
a1613 5
	void			*buf;
	size_t			 len;
	struct job		*job;
	struct format_tree	*ft;
	char			*expanded;
d1618 1
d1620 1
a1620 5
	ft = format_create(NULL, FORMAT_NONE, 0);
	format_defaults(ft, NULL, sess, NULL, wp);
	expanded = format_expand(ft, arg);

	job = job_run(expanded, sess, NULL, NULL, NULL, NULL);
a1623 2
	format_free(ft);

@


1.165
log
@Add a window or pane id "tag" to each format tree and use it to separate
jobs, this means that if the same job is used for different windows or
panes (for example in pane-border-format), it will be run separately for
each pane.
@
text
@d1 1
a1 1
/* $OpenBSD: window-copy.c,v 1.164 2017/01/07 15:28:13 nicm Exp $ */
d32 1
a32 1
static void	window_copy_pagedown(struct window_pane *, int);
d383 1
a383 1
static void
d423 2
a424 5
	if (data->scroll_exit && data->oy == 0) {
		window_pane_reset_mode(wp);
		return;
	}

d427 1
d622 6
a627 2
			for (; np != 0; np--)
				window_copy_pagedown(wp, 1);
d720 6
a725 2
			for (; np != 0; np--)
				window_copy_pagedown(wp, 0);
@


1.164
log
@Add support for the OSC 4 and OSC 104 palette setting escape sequences,
from S Gilles.
@
text
@d1 1
a1 1
/* $OpenBSD: window-copy.c,v 1.163 2017/01/06 11:57:03 nicm Exp $ */
d1614 1
a1614 1
	ft = format_create(NULL, 0);
@


1.163
log
@Incremental search in copy mode (on for emacs keys by default) - much
the same as normal searching but updates the cursor position and marked
search terms as you type. C-r and C-s in the prompt repeat the search,
once finished searching (with Enter), N and n work as before.
@
text
@d1 1
a1 1
/* $OpenBSD: window-copy.c,v 1.162 2017/01/05 09:07:16 nicm Exp $ */
d1256 1
d1459 1
@


1.162
log
@Highlight all occurrences of search string after searching in copy mode.
@
text
@d1 1
a1 1
/* $OpenBSD: window-copy.c,v 1.161 2016/11/24 13:38:44 nicm Exp $ */
d53 1
d57 1
a57 1
static void	window_copy_search_jump(struct window_pane *, struct grid *,
d59 3
a61 3
static void	window_copy_search(struct window_pane *, int, int);
static void	window_copy_search_up(struct window_pane *, int);
static void	window_copy_search_down(struct window_pane *, int);
d177 3
d210 1
d495 3
d518 2
a519 1
	int				 cancel = 0;
d533 1
a533 1
			window_copy_redraw_screen(wp);
d539 1
a539 1
			window_copy_redraw_screen(wp);
d550 1
a550 1
				window_copy_redraw_screen(wp);
d559 1
a559 1
			window_copy_redraw_screen(wp);
d565 1
a565 1
			window_copy_redraw_screen(wp);
d572 1
a572 1
			window_copy_redraw_screen(wp);
d585 1
a585 1
			window_copy_redraw_screen(wp);
d596 1
a596 1
			window_copy_redraw_screen(wp);
d602 1
a602 1
			window_copy_redraw_screen(wp);
d636 1
a636 1
			window_copy_redraw_screen(wp);
d643 1
a643 1
			window_copy_redraw_screen(wp);
d689 1
a689 1
			window_copy_redraw_screen(wp);
d778 1
a778 1
			window_copy_redraw_screen(wp);
d787 1
a787 1
			window_copy_redraw_screen(wp);
d795 1
a795 1
			window_copy_redraw_screen(wp);
d837 1
d844 1
d849 68
d920 3
a922 3
		free(data->searchmark);
		data->searchmark = NULL;
		window_copy_redraw_screen(wp);
d927 2
d1070 1
a1070 1
static void
d1099 1
a1099 1
	if (found)
d1101 5
a1105 2
	else if (wrap) {
		window_copy_search_jump(wp, gd, sgd, direction ? 0 : gd->sx - 1,
d1107 1
a1107 1
		    direction);
d1109 1
d1117 1
a1117 1
static void
d1125 1
a1125 1
	int				 wrapflag, cis;
d1150 1
a1150 1
	window_copy_search_jump(wp, gd, ss.grid, fx, fy, endline, cis,
d1157 1
d1208 9
d1219 1
a1219 1
	window_copy_search(wp, 0, moveflag);
d1222 1
a1222 1
static void
d1225 1
a1225 1
	window_copy_search(wp, 1, moveflag);
@


1.161
log
@Make the selection able to exist independent of the cursor position, so
that it is not affected by scrolling. If MouseDragEnd1Pane is bound to
the new "stop-selection" command:

    bind -Tcopy-mode MouseDragEnd1Pane stop-selection

A selection made with the mouse will stay as it is after button 1 is
released. (It also works bound to a key.)

From Artem Fokin.
@
text
@d1 1
a1 1
/* $OpenBSD: window-copy.c,v 1.160 2016/11/15 09:53:23 nicm Exp $ */
d52 1
d58 3
a60 5
static void	window_copy_search(struct window_pane *, const char *, int,
		    int);
static void	window_copy_search_up(struct window_pane *, const char *, int);
static void	window_copy_search_down(struct window_pane *, const char *,
		    int);
d175 1
d188 1
d205 1
d266 1
d339 1
a339 1
	u_int				 n, ox, oy;
d367 4
a370 3
		u_int py = screen_hsize(data->backing) + data->cy - data->oy;
		u_int px = window_copy_find_length(wp, py);
		if ((data->cx >= data->lastsx && data->cx != px) || data->cx > px)
d488 3
d508 1
a508 1
	const char			*command, *argument, *ws, *ss;
d510 1
d531 1
a531 1
			window_pane_reset_mode(wp);
d553 1
a553 1
			window_pane_reset_mode(wp);
d567 1
a567 1
				window_pane_reset_mode(wp);
d580 1
a580 1
				window_pane_reset_mode(wp);
d594 1
a594 1
			window_pane_reset_mode(wp);
d737 1
a737 1
				window_pane_reset_mode(wp);
a743 1
			ss = data->searchstr;
d746 1
a746 1
					window_copy_search_up(wp, ss, 1);
d749 1
a749 1
					window_copy_search_down(wp, ss, 1);
a752 1
			ss = data->searchstr;
d755 1
a755 1
					window_copy_search_down(wp, ss, 1);
d758 1
a758 1
					window_copy_search_up(wp, ss, 1);
d797 1
a797 1
				window_pane_reset_mode(wp);
d830 1
a830 1
				window_copy_search_up(wp, data->searchstr, 1);
d836 1
a836 1
				window_copy_search_down(wp, data->searchstr, 1);
d840 8
d1033 1
a1033 2
window_copy_search(struct window_pane *wp, const char *searchstr, int direction,
    int moveflag)
d1045 1
a1045 1
	screen_init(&ss, screen_write_strlen("%s", searchstr), 1, 0);
d1047 1
a1047 1
	screen_write_nputs(&ctx, -1, &grid_default_cell, "%s", searchstr);
d1059 1
a1059 1
	cis = window_copy_is_lowercase(searchstr);
d1065 5
a1069 2
	window_copy_search_jump(wp, gd, ss.grid, fx, fy, endline, cis, wrapflag,
	    direction);
d1074 47
d1122 1
a1122 2
window_copy_search_up(struct window_pane *wp, const char *searchstr,
    int moveflag)
d1124 1
a1124 1
	window_copy_search(wp, searchstr, 0, moveflag);
d1128 1
a1128 2
window_copy_search_down(struct window_pane *wp, const char *searchstr,
    int moveflag)
d1130 1
a1130 1
	window_copy_search(wp, searchstr, 1, moveflag);
d1158 1
a1158 1
	size_t				 xoff = 0, size = 0;
d1173 2
a1174 2
		screen_write_cursormove(ctx, xoff, py);
		screen_write_copy(ctx, data->backing, xoff,
d1176 1
a1176 1
		    screen_size_x(s) - size, 1);
@


1.160
log
@Add copy-pipe-and-cancel, from Artem Fokin.
@
text
@d1 1
a1 1
/* $OpenBSD: window-copy.c,v 1.159 2016/10/13 20:27:27 nicm Exp $ */
d65 2
d68 1
d125 6
d132 5
a136 6
 * Copy-mode's visible screen (the "screen" field) is filled from one of
 * two sources: the original contents of the pane (used when we
 * actually enter via the "copy-mode" command, to copy the contents of
 * the current pane), or else a series of lines containing the output
 * from an output-writing tmux command (such as any of the "show-*" or
 * "list-*" commands).
d138 6
a143 7
 * In either case, the full content of the copy-mode grid is pointed at
 * by the "backing" field, and is copied into "screen" as needed (that
 * is, when scrolling occurs). When copy-mode is backed by a pane,
 * backing points directly at that pane's screen structure (&wp->base);
 * when backed by a list of output-lines from a command, it points at
 * a newly-allocated screen structure (which is deallocated when the
 * mode ends).
d151 1
a151 1
	u_int		 oy;
d153 1
a153 1
	u_int		 selx;
d156 9
d192 2
d379 1
a379 1
	u_int				 n, ox, oy;
d407 4
a410 3
		u_int py = screen_hsize(data->backing) + data->cy - data->oy;
		u_int px = window_copy_find_length(wp, py);
		if ((data->cx >= data->lastsx && data->cx != px) || data->cx > px)
d536 2
d1175 23
d1227 5
d1237 32
d1275 2
a1276 1
	u_int				 sx, sy, ty, cy;
d1281 1
a1281 5
	/* Set colours. */
	style_apply(&gc, oo, "mode-style");

	/* Find top of screen. */
	ty = screen_hsize(data->backing) - data->oy;
d1286 13
a1298 11
	if (sy < ty) {					/* above screen */
		if (!data->rectflag)
			sx = 0;
		sy = 0;
	} else if (sy > ty + screen_size_y(s) - 1) {	/* below screen */
		if (!data->rectflag)
			sx = screen_size_x(s) - 1;
		sy = screen_size_y(s) - 1;
	} else
		sy -= ty;
	sy = screen_hsize(s) + sy;
d1300 3
a1302 2
	screen_set_selection(s,
	    sx, sy, data->cx, screen_hsize(s) + data->cy, data->rectflag, &gc);
d1345 2
a1346 2
	xx = data->cx;
	yy = screen_hsize(data->backing) + data->cy - data->oy;
d1584 2
d1716 1
a1716 1
	u_int				 selx, sely, cx, cy, yy, hsize;
d1726 17
a1742 3
	selx = data->selx;
	sely = data->sely;
	cx = data->cx;
a1745 2
	data->selx = cx;
	data->sely = yy;
d1749 1
a1749 1
	if (sely < hsize - data->oy) {
d1752 1
a1752 1
	} else if (sely > hsize - data->oy + screen_size_y(s)) {
d1758 1
@


1.159
log
@Add support for BCE (background colour erase). This makes various escape
sequences (notable EL and ED but also IL, DL, ICH, DCH) create blank
cells using the current background colour rather than the default
colour.

On modern systems BCE doesn't really have many benefits, but most other
terminals now support it, some (lazy) applications rely on it, and it is
not hard to include now that we have pane background colours anyway.

Mostly written by Sean Haugh.
@
text
@d1 1
a1 1
/* $OpenBSD: window-copy.c,v 1.158 2016/10/12 09:07:58 nicm Exp $ */
d66 1
a66 1
static void   *window_copy_get_selection(struct window_pane *, size_t *);
d764 4
@


1.158
log
@Unused variable and missing time.h.
@
text
@d1 1
a1 1
/* $OpenBSD: window-copy.c,v 1.157 2016/10/11 13:21:59 nicm Exp $ */
d2055 1
a2055 1
	screen_write_deleteline(&ctx, ny);
d2088 1
a2088 1
	screen_write_insertline(&ctx, ny);
@


1.157
log
@Add static in window-*.c and move some internal functions out of tmux.h.
@
text
@d1 1
a1 1
/* $OpenBSD: window-copy.c,v 1.156 2016/10/11 09:30:36 nicm Exp $ */
d1072 1
a1072 1
	size_t				 last, xoff = 0, size = 0;
a1075 1
	last = screen_size_y(s) - 1;
@


1.156
log
@Support double and triple clicks (they are cumulative, so double is
fired then triple), and use for select-word and select-line in copy
mode. Inspired by a different solution from Omar Sandoval.
@
text
@d1 1
a1 1
/* $OpenBSD: window-copy.c,v 1.155 2016/10/11 07:23:34 nicm Exp $ */
d27 76
a102 70
const char *window_copy_key_table(struct window_pane *);
void	window_copy_command(struct window_pane *, struct client *,
	    struct session *, struct args *, struct mouse_event *);
struct screen *window_copy_init(struct window_pane *);
void	window_copy_free(struct window_pane *);
void	window_copy_pagedown(struct window_pane *, int);
void	window_copy_next_paragraph(struct window_pane *);
void	window_copy_previous_paragraph(struct window_pane *);
void	window_copy_resize(struct window_pane *, u_int, u_int);

void	window_copy_redraw_selection(struct window_pane *, u_int);
void	window_copy_redraw_lines(struct window_pane *, u_int, u_int);
void	window_copy_redraw_screen(struct window_pane *);
void	window_copy_write_line(struct window_pane *, struct screen_write_ctx *,
	    u_int);
void	window_copy_write_lines(struct window_pane *,
	    struct screen_write_ctx *, u_int, u_int);

void	window_copy_scroll_to(struct window_pane *, u_int, u_int);
int	window_copy_search_compare(struct grid *, u_int, u_int, struct grid *,
	    u_int, int);
int	window_copy_search_lr(struct grid *, struct grid *, u_int *, u_int,
	    u_int, u_int, int);
int	window_copy_search_rl(struct grid *, struct grid *, u_int *, u_int,
	    u_int, u_int, int);
void	window_copy_move_left(struct screen *, u_int *, u_int *);
void	window_copy_move_right(struct screen *, u_int *, u_int *);
int	window_copy_is_lowercase(const char *);
void	window_copy_search_jump(struct window_pane *, struct grid *,
	    struct grid *, u_int, u_int, u_int, int, int, int);
void	window_copy_search(struct window_pane *, const char *, int, int);
void	window_copy_search_up(struct window_pane *, const char *, int);
void	window_copy_search_down(struct window_pane *, const char *, int);
void	window_copy_goto_line(struct window_pane *, const char *);
void	window_copy_update_cursor(struct window_pane *, u_int, u_int);
void	window_copy_start_selection(struct window_pane *);
int	window_copy_update_selection(struct window_pane *, int);
void   *window_copy_get_selection(struct window_pane *, size_t *);
void	window_copy_copy_buffer(struct window_pane *, const char *, void *,
	    size_t);
void	window_copy_copy_pipe(struct window_pane *, struct session *,
	    const char *, const char *);
void	window_copy_copy_selection(struct window_pane *, const char *);
void	window_copy_append_selection(struct window_pane *, const char *);
void	window_copy_clear_selection(struct window_pane *);
void	window_copy_copy_line(struct window_pane *, char **, size_t *, u_int,
	    u_int, u_int);
int	window_copy_in_set(struct window_pane *, u_int, u_int, const char *);
u_int	window_copy_find_length(struct window_pane *, u_int);
void	window_copy_cursor_start_of_line(struct window_pane *);
void	window_copy_cursor_back_to_indentation(struct window_pane *);
void	window_copy_cursor_end_of_line(struct window_pane *);
void	window_copy_other_end(struct window_pane *);
void	window_copy_cursor_left(struct window_pane *);
void	window_copy_cursor_right(struct window_pane *);
void	window_copy_cursor_up(struct window_pane *, int);
void	window_copy_cursor_down(struct window_pane *, int);
void	window_copy_cursor_jump(struct window_pane *);
void	window_copy_cursor_jump_back(struct window_pane *);
void	window_copy_cursor_jump_to(struct window_pane *, int);
void	window_copy_cursor_jump_to_back(struct window_pane *, int);
void	window_copy_cursor_next_word(struct window_pane *, const char *);
void	window_copy_cursor_next_word_end(struct window_pane *, const char *);
void	window_copy_cursor_previous_word(struct window_pane *, const char *);
void	window_copy_scroll_up(struct window_pane *, u_int);
void	window_copy_scroll_down(struct window_pane *, u_int);
void	window_copy_rectangle_toggle(struct window_pane *);
void	window_copy_move_mouse(struct mouse_event *);
void	window_copy_drag_update(struct client *, struct mouse_event *);
void	window_copy_drag_release(struct client *, struct mouse_event *);
d165 1
a165 1
struct screen *
d238 1
a238 1
void
d356 1
a356 1
void
d404 1
a404 1
void
d421 1
a421 1
void
d441 1
a441 1
void
d468 1
a468 1
const char *
d476 1
a476 1
void
d812 1
a812 1
void
d838 1
a838 1
int
d859 1
a859 1
int
d884 1
a884 1
int
d909 1
a909 1
void
d921 1
a921 1
void
d933 1
a933 1
int
d950 1
a950 1
void
d993 1
a993 1
void
d1033 1
a1033 1
void
d1040 1
a1040 1
void
d1047 1
a1047 1
void
d1063 1
a1063 1
void
d1101 1
a1101 1
void
d1111 1
a1111 1
void
d1128 1
a1128 1
void
d1142 1
a1142 1
void
d1150 1
a1150 1
void
d1171 1
a1171 1
void
d1184 1
a1184 1
int
d1236 1
a1236 1
void *
d1342 1
a1342 1
void
d1358 1
a1358 1
void
d1385 1
a1385 1
void
d1398 1
a1398 1
void
d1432 1
a1432 1
void
d1492 1
a1492 1
void
d1506 1
a1506 1
int
d1523 1
a1523 1
u_int
d1549 1
a1549 1
void
d1571 1
a1571 1
void
d1594 1
a1594 1
void
d1625 1
a1625 1
void
d1663 1
a1663 1
void
d1680 1
a1680 1
void
d1704 1
a1704 1
void
d1754 1
a1754 1
void
d1796 1
a1796 1
void
d1821 1
a1821 1
void
d1850 1
a1850 1
void
d1875 1
a1875 1
void
d1907 1
a1907 1
void
d1949 1
a1949 1
void
d2001 1
a2001 1
void
d2039 1
a2039 1
void
d2069 1
a2069 1
void
d2109 1
a2109 1
void
d2126 1
a2126 1
void
d2166 1
a2166 1
void
@


1.155
log
@Fundamental change to how copy mode key bindings work:

The vi-copy and emacs-copy mode key tables are gone, and instead copy
mode commands are bound in one of two normal key tables ("copy-mode" or
"copy-mode-vi"). Keys are bound to "send-keys -X copy-mode-command". So:

    bind -temacs-copy C-Up scroll-up
    bind -temacs-copy -R5 WheelUpPane scroll-up

Becomes:

    bind -Tcopy-mode C-Up send -X scroll-up
    bind -Tcopy-mode WheelUpPane send -N5 -X scroll-up

This allows the full command parser and command set to be used - for
example, we can use the normal command prompt for searching, jumping,
and so on instead of a custom one:

    bind -Tcopy-mode C-r command-prompt -p'search up' "send -X search-backward '%%'"

command-prompt also gets a -1 option to only require on key press, which
is needed for jumping.

The plan is to get rid of mode keys entirely, so more to come eventually.
@
text
@d1 1
a1 1
/* $OpenBSD: window-copy.c,v 1.154 2016/10/09 07:30:28 nicm Exp $ */
d94 1
d483 3
d738 10
a747 1
		if (strcmp(command, "start-of-line") == 0) {
a748 1
		}
d2118 16
@


1.154
log
@Use xsnprintf not snprintf for the prompt in window_copy_write_line
because we don't care if it is truncated to the screen width, we don't
want it to be fatal.
@
text
@d1 1
a1 1
/* $OpenBSD: window-copy.c,v 1.153 2016/10/03 22:52:11 nicm Exp $ */
d27 3
a35 4
void	window_copy_key(struct window_pane *, struct client *, struct session *,
	    key_code, struct mouse_event *);
int	window_copy_key_input(struct window_pane *, key_code);
int	window_copy_key_numeric_prefix(struct window_pane *, key_code);
d98 5
a102 4
	window_copy_init,
	window_copy_free,
	window_copy_resize,
	window_copy_key,
d105 1
a105 1
enum window_copy_input_type {
a106 2
	WINDOW_COPY_NAMEDBUFFER,
	WINDOW_COPY_NUMERICPREFIX,
d110 1
a110 1
	WINDOW_COPY_JUMPBACK,
d112 1
a112 2
	WINDOW_COPY_JUMPTOBACK,
	WINDOW_COPY_GOTOLINE,
d132 1
a132 1
	struct screen		 screen;
d134 2
a135 2
	struct screen		*backing;
	int			 backing_written; /* backing display started */
d137 1
a137 1
	struct mode_key_data	 mdata;
d139 2
a140 1
	u_int			 oy;
d142 2
a143 2
	u_int			 selx;
	u_int			 sely;
d145 2
a146 2
	int			 rectflag;	/* in rectangle copy mode? */
	int			 scroll_exit;	/* exit on scroll to end? */
d148 2
a149 2
	u_int			 cx;
	u_int			 cy;
d151 2
a152 2
	u_int			 lastcx; /* position in last line w/ content */
	u_int			 lastsx; /* size of last line w/ content */
d154 2
a155 12
	enum window_copy_input_type inputtype;
	const char		*inputprompt;
	char			*inputstr;
	int			 inputexit;

	int			 numprefix;

	enum window_copy_input_type searchtype;
	char			*searchstr;

	enum window_copy_input_type jumptype;
	char			 jumpchar;
a162 1
	int				 keys;
a176 5
	data->inputtype = WINDOW_COPY_OFF;
	data->inputprompt = NULL;
	data->inputstr = xstrdup("");
	data->numprefix = -1;

d188 1
a188 7

	keys = options_get_number(wp->window->options, "mode-keys");
	if (keys == MODEKEY_EMACS)
		mode_key_init(&data->mdata, &mode_key_tree_emacs_copy);
	else
		mode_key_init(&data->mdata, &mode_key_tree_vi_copy);
	s->sel.modekeys = keys;
a239 1
	free(data->inputstr);
d461 8
d470 2
a471 2
window_copy_key(struct window_pane *wp, struct client *c, struct session *sess,
    key_code key, struct mouse_event *m)
a472 1
	const char			*word_separators;
d474 7
a480 5
	struct screen			*s = &data->screen;
	u_int				 np;
	int				 keys;
	enum mode_key_cmd		 cmd;
	const char			*arg, *ss;
d482 23
a504 14
	np = 1;
	if (data->numprefix > 0)
		np = data->numprefix;

	if (data->inputtype == WINDOW_COPY_JUMPFORWARD ||
	    data->inputtype == WINDOW_COPY_JUMPBACK ||
	    data->inputtype == WINDOW_COPY_JUMPTOFORWARD ||
	    data->inputtype == WINDOW_COPY_JUMPTOBACK) {
		/* Ignore keys with modifiers. */
		if ((key & KEYC_MASK_MOD) == 0) {
			data->jumpchar = key;
			if (data->inputtype == WINDOW_COPY_JUMPFORWARD) {
				for (; np != 0; np--)
					window_copy_cursor_jump(wp);
d506 23
a528 11
			if (data->inputtype == WINDOW_COPY_JUMPBACK) {
				for (; np != 0; np--)
					window_copy_cursor_jump_back(wp);
			}
			if (data->inputtype == WINDOW_COPY_JUMPTOFORWARD) {
				for (; np != 0; np--)
					window_copy_cursor_jump_to(wp, 0);
			}
			if (data->inputtype == WINDOW_COPY_JUMPTOBACK) {
				for (; np != 0; np--)
					window_copy_cursor_jump_to_back(wp, 0);
d531 7
a537 14
		data->jumptype = data->inputtype;
		data->inputtype = WINDOW_COPY_OFF;
		window_copy_redraw_lines(wp, screen_size_y(s) - 1, 1);
		return;
	} else if (data->inputtype == WINDOW_COPY_NUMERICPREFIX) {
		if (window_copy_key_numeric_prefix(wp, key) == 0)
			return;
		data->inputtype = WINDOW_COPY_OFF;
		window_copy_redraw_lines(wp, screen_size_y(s) - 1, 1);
	} else if (data->inputtype != WINDOW_COPY_OFF) {
		if (window_copy_key_input(wp, key) != 0)
			goto input_off;
		return;
	}
d539 2
a540 15
	cmd = mode_key_lookup(&data->mdata, key, &arg, &np);
	if (data->numprefix > 0)
		np = data->numprefix;
	if (cmd != MODEKEYCOPY_PREVIOUSPAGE &&
	    cmd != MODEKEYCOPY_NEXTPAGE &&
	    cmd != MODEKEYCOPY_SCROLLUP &&
	    cmd != MODEKEYCOPY_SCROLLDOWN &&
	    cmd != MODEKEYCOPY_HALFPAGEUP &&
	    cmd != MODEKEYCOPY_HALFPAGEDOWN)
		data->scroll_exit = 0;
	switch (cmd) {
	case MODEKEYCOPY_APPENDSELECTION:
		if (sess != NULL) {
			window_copy_append_selection(wp, NULL);
			if (arg == NULL) {
a541 1
				return;
d543 4
d550 5
a554 32
		break;
	case MODEKEYCOPY_CANCEL:
		window_pane_reset_mode(wp);
		return;
	case MODEKEYCOPY_OTHEREND:
		if (np % 2)
			window_copy_other_end(wp);
		break;
	case MODEKEYCOPY_LEFT:
		for (; np != 0; np--)
			window_copy_cursor_left(wp);
		break;
	case MODEKEYCOPY_RIGHT:
		for (; np != 0; np--)
			window_copy_cursor_right(wp);
		break;
	case MODEKEYCOPY_UP:
		for (; np != 0; np--)
			window_copy_cursor_up(wp, 0);
		break;
	case MODEKEYCOPY_DOWN:
		for (; np != 0; np--)
			window_copy_cursor_down(wp, 0);
		break;
	case MODEKEYCOPY_SCROLLUP:
		for (; np != 0; np--)
			window_copy_cursor_up(wp, 1);
		break;
	case MODEKEYCOPY_SCROLLDOWN:
		for (; np != 0; np--)
			window_copy_cursor_down(wp, 1);
		if (data->scroll_exit && data->oy == 0) {
a555 1
			return;
d557 31
a587 64
		break;
	case MODEKEYCOPY_PREVIOUSPAGE:
		for (; np != 0; np--)
			window_copy_pageup(wp, 0);
		break;
	case MODEKEYCOPY_NEXTPAGE:
		for (; np != 0; np--)
			window_copy_pagedown(wp, 0);
		break;
	case MODEKEYCOPY_PREVIOUSPARAGRAPH:
		for (; np != 0; np--)
			window_copy_previous_paragraph(wp);
		break;
	case MODEKEYCOPY_NEXTPARAGRAPH:
		for (; np != 0; np--)
			window_copy_next_paragraph(wp);
		break;
	case MODEKEYCOPY_HALFPAGEUP:
		for (; np != 0; np--)
			window_copy_pageup(wp, 1);
		break;
	case MODEKEYCOPY_HALFPAGEDOWN:
		for (; np != 0; np--)
			window_copy_pagedown(wp, 1);
		break;
	case MODEKEYCOPY_TOPLINE:
		data->cx = 0;
		data->cy = 0;
		window_copy_update_selection(wp, 1);
		window_copy_redraw_screen(wp);
		break;
	case MODEKEYCOPY_MIDDLELINE:
		data->cx = 0;
		data->cy = (screen_size_y(s) - 1) / 2;
		window_copy_update_selection(wp, 1);
		window_copy_redraw_screen(wp);
		break;
	case MODEKEYCOPY_BOTTOMLINE:
		data->cx = 0;
		data->cy = screen_size_y(s) - 1;
		window_copy_update_selection(wp, 1);
		window_copy_redraw_screen(wp);
		break;
	case MODEKEYCOPY_HISTORYTOP:
		data->cx = 0;
		data->cy = 0;
		data->oy = screen_hsize(data->backing);
		window_copy_update_selection(wp, 1);
		window_copy_redraw_screen(wp);
		break;
	case MODEKEYCOPY_HISTORYBOTTOM:
		data->cx = 0;
		data->cy = screen_size_y(s) - 1;
		data->oy = 0;
		window_copy_update_selection(wp, 1);
		window_copy_redraw_screen(wp);
		break;
	case MODEKEYCOPY_STARTSELECTION:
		if (KEYC_IS_MOUSE(key)) {
			if (c != NULL)
				window_copy_start_drag(c, m);
		} else {
			s->sel.lineflag = LINE_SEL_NONE;
			window_copy_start_selection(wp);
d590 6
a595 22
		break;
	case MODEKEYCOPY_SELECTLINE:
		s->sel.lineflag = LINE_SEL_LEFT_RIGHT;
		data->rectflag = 0;
		/* FALLTHROUGH */
	case MODEKEYCOPY_COPYLINE:
		window_copy_cursor_start_of_line(wp);
		/* FALLTHROUGH */
	case MODEKEYCOPY_COPYENDOFLINE:
		window_copy_start_selection(wp);
		for (; np > 1; np--)
			window_copy_cursor_down(wp, 0);
		window_copy_cursor_end_of_line(wp);
		window_copy_redraw_screen(wp);

		/* If a copy command then copy the selection and exit. */
		if (sess != NULL &&
		    (cmd == MODEKEYCOPY_COPYLINE ||
		    cmd == MODEKEYCOPY_COPYENDOFLINE)) {
			window_copy_copy_selection(wp, NULL);
			window_pane_reset_mode(wp);
			return;
d597 19
a615 10
		break;
	case MODEKEYCOPY_CLEARSELECTION:
		window_copy_clear_selection(wp);
		window_copy_redraw_screen(wp);
		break;
	case MODEKEYCOPY_COPYPIPE:
		if (sess != NULL) {
			window_copy_copy_pipe(wp, sess, NULL, arg);
			window_pane_reset_mode(wp);
			return;
d617 18
a634 7
		break;
	case MODEKEYCOPY_COPYSELECTION:
		if (sess != NULL) {
			window_copy_copy_selection(wp, NULL);
			if (arg == NULL) {
				window_pane_reset_mode(wp);
				return;
d636 5
a640 1
			window_copy_clear_selection(wp);
d643 19
a661 48
		break;
	case MODEKEYCOPY_STARTOFLINE:
		window_copy_cursor_start_of_line(wp);
		break;
	case MODEKEYCOPY_BACKTOINDENTATION:
		window_copy_cursor_back_to_indentation(wp);
		break;
	case MODEKEYCOPY_ENDOFLINE:
		window_copy_cursor_end_of_line(wp);
		break;
	case MODEKEYCOPY_NEXTSPACE:
		for (; np != 0; np--)
			window_copy_cursor_next_word(wp, " ");
		break;
	case MODEKEYCOPY_NEXTSPACEEND:
		for (; np != 0; np--)
			window_copy_cursor_next_word_end(wp, " ");
		break;
	case MODEKEYCOPY_NEXTWORD:
		word_separators =
		    options_get_string(sess->options, "word-separators");
		for (; np != 0; np--)
			window_copy_cursor_next_word(wp, word_separators);
		break;
	case MODEKEYCOPY_NEXTWORDEND:
		word_separators =
		    options_get_string(sess->options, "word-separators");
		for (; np != 0; np--)
			window_copy_cursor_next_word_end(wp, word_separators);
		break;
	case MODEKEYCOPY_PREVIOUSSPACE:
		for (; np != 0; np--)
			window_copy_cursor_previous_word(wp, " ");
		break;
	case MODEKEYCOPY_PREVIOUSWORD:
		word_separators =
		    options_get_string(sess->options, "word-separators");
		for (; np != 0; np--)
			window_copy_cursor_previous_word(wp, word_separators);
		break;
	case MODEKEYCOPY_JUMP:
		data->inputtype = WINDOW_COPY_JUMPFORWARD;
		data->inputprompt = "Jump Forward";
		*data->inputstr = '\0';
		window_copy_redraw_lines(wp, screen_size_y(s) - 1, 1);
		return; /* skip numprefix reset */
	case MODEKEYCOPY_JUMPAGAIN:
		if (data->jumptype == WINDOW_COPY_JUMPFORWARD) {
d663 7
a669 2
				window_copy_cursor_jump(wp);
		} else if (data->jumptype == WINDOW_COPY_JUMPBACK) {
d671 3
a673 2
				window_copy_cursor_jump_back(wp);
		} else if (data->jumptype == WINDOW_COPY_JUMPTOFORWARD) {
d675 3
a677 2
				window_copy_cursor_jump_to(wp, 1);
		} else if (data->jumptype == WINDOW_COPY_JUMPTOBACK) {
d679 1
a679 1
				window_copy_cursor_jump_to_back(wp, 1);
d681 1
a681 3
		break;
	case MODEKEYCOPY_JUMPREVERSE:
		if (data->jumptype == WINDOW_COPY_JUMPFORWARD) {
d683 4
a686 2
				window_copy_cursor_jump_back(wp);
		} else if (data->jumptype == WINDOW_COPY_JUMPBACK) {
d688 7
a694 2
				window_copy_cursor_jump(wp);
		} else if (data->jumptype == WINDOW_COPY_JUMPTOFORWARD) {
d696 5
a700 2
				window_copy_cursor_jump_to_back(wp, 1);
		} else if (data->jumptype == WINDOW_COPY_JUMPTOBACK) {
d702 1
a702 1
				window_copy_cursor_jump_to(wp, 1);
d704 1
a704 40
		break;
	case MODEKEYCOPY_JUMPBACK:
		data->inputtype = WINDOW_COPY_JUMPBACK;
		data->inputprompt = "Jump Back";
		*data->inputstr = '\0';
		window_copy_redraw_lines(wp, screen_size_y(s) - 1, 1);
		return; /* skip numprefix reset */
	case MODEKEYCOPY_JUMPTO:
		data->inputtype = WINDOW_COPY_JUMPTOFORWARD;
		data->inputprompt = "Jump To";
		*data->inputstr = '\0';
		window_copy_redraw_lines(wp, screen_size_y(s) - 1, 1);
		return; /* skip numprefix reset */
	case MODEKEYCOPY_JUMPTOBACK:
		data->inputtype = WINDOW_COPY_JUMPTOBACK;
		data->inputprompt = "Jump To Back";
		*data->inputstr = '\0';
		window_copy_redraw_lines(wp, screen_size_y(s) - 1, 1);
		return; /* skip numprefix reset */
	case MODEKEYCOPY_SEARCHUP:
		data->inputtype = WINDOW_COPY_SEARCHUP;
		data->inputprompt = "Search Up";
		goto input_on;
	case MODEKEYCOPY_SEARCHDOWN:
		data->inputtype = WINDOW_COPY_SEARCHDOWN;
		data->inputprompt = "Search Down";
		goto input_on;
	case MODEKEYCOPY_SEARCHAGAIN:
	case MODEKEYCOPY_SEARCHREVERSE:
		switch (data->searchtype) {
		case WINDOW_COPY_OFF:
		case WINDOW_COPY_GOTOLINE:
		case WINDOW_COPY_JUMPFORWARD:
		case WINDOW_COPY_JUMPBACK:
		case WINDOW_COPY_JUMPTOFORWARD:
		case WINDOW_COPY_JUMPTOBACK:
		case WINDOW_COPY_NAMEDBUFFER:
		case WINDOW_COPY_NUMERICPREFIX:
			break;
		case WINDOW_COPY_SEARCHUP:
d706 1
a706 1
			if (cmd == MODEKEYCOPY_SEARCHAGAIN) {
d709 1
a709 1
			} else {
d713 2
a714 2
			break;
		case WINDOW_COPY_SEARCHDOWN:
d716 1
a716 1
			if (cmd == MODEKEYCOPY_SEARCHAGAIN) {
d719 1
a719 1
			} else {
a722 1
			break;
d724 46
a769 19
		break;
	case MODEKEYCOPY_GOTOLINE:
		data->inputtype = WINDOW_COPY_GOTOLINE;
		data->inputprompt = "Goto Line";
		*data->inputstr = '\0';
		goto input_on;
	case MODEKEYCOPY_STARTNAMEDBUFFER:
		data->inputtype = WINDOW_COPY_NAMEDBUFFER;
		data->inputexit = (arg == NULL);
		data->inputprompt = "Buffer";
		*data->inputstr = '\0';
		goto input_on;
	case MODEKEYCOPY_STARTNUMBERPREFIX:
		key &= KEYC_MASK_KEY;
		if (key >= '0' && key <= '9') {
			data->inputtype = WINDOW_COPY_NUMERICPREFIX;
			data->numprefix = 0;
			window_copy_key_numeric_prefix(wp, key);
			return;
d771 5
a775 66
		break;
	case MODEKEYCOPY_RECTANGLETOGGLE:
		s->sel.lineflag = LINE_SEL_NONE;
		window_copy_rectangle_toggle(wp);
		break;
	default:
		break;
	}

	data->numprefix = -1;
	return;

input_on:
	keys = options_get_number(wp->window->options, "mode-keys");
	if (keys == MODEKEY_EMACS)
		mode_key_init(&data->mdata, &mode_key_tree_emacs_edit);
	else
		mode_key_init(&data->mdata, &mode_key_tree_vi_edit);

	window_copy_redraw_lines(wp, screen_size_y(s) - 1, 1);
	return;

input_off:
	keys = options_get_number(wp->window->options, "mode-keys");
	if (keys == MODEKEY_EMACS)
		mode_key_init(&data->mdata, &mode_key_tree_emacs_copy);
	else
		mode_key_init(&data->mdata, &mode_key_tree_vi_copy);

	data->inputtype = WINDOW_COPY_OFF;
	data->inputprompt = NULL;

	window_copy_redraw_lines(wp, screen_size_y(s) - 1, 1);
}

int
window_copy_key_input(struct window_pane *wp, key_code key)
{
	struct window_copy_mode_data	*data = wp->modedata;
	struct screen			*s = &data->screen;
	const char			*bufdata;
	size_t				 inputlen, n, bufsize;
	u_int				 np;
	struct paste_buffer		*pb;
	u_char				 ch;

	switch (mode_key_lookup(&data->mdata, key, NULL, &np)) {
	case MODEKEYEDIT_CANCEL:
		data->numprefix = -1;
		return (-1);
	case MODEKEYEDIT_BACKSPACE:
		inputlen = strlen(data->inputstr);
		if (inputlen > 0)
			data->inputstr[inputlen - 1] = '\0';
		break;
	case MODEKEYEDIT_DELETELINE:
		*data->inputstr = '\0';
		break;
	case MODEKEYEDIT_PASTE:
		if ((pb = paste_get_top(NULL)) == NULL)
			break;
		bufdata = paste_buffer_data(pb, &bufsize);
		for (n = 0; n < bufsize; n++) {
			ch = (u_char)bufdata[n];
			if (ch < 32 || ch == 127)
				break;
d777 3
a779 20
		inputlen = strlen(data->inputstr);

		data->inputstr = xrealloc(data->inputstr, inputlen + n + 1);
		memcpy(data->inputstr + inputlen, bufdata, n);
		data->inputstr[inputlen + n] = '\0';
		break;
	case MODEKEYEDIT_ENTER:
		if (data->numprefix > 0)
			np = data->numprefix;
		switch (data->inputtype) {
		case WINDOW_COPY_OFF:
		case WINDOW_COPY_JUMPFORWARD:
		case WINDOW_COPY_JUMPBACK:
		case WINDOW_COPY_JUMPTOFORWARD:
		case WINDOW_COPY_JUMPTOBACK:
		case WINDOW_COPY_NUMERICPREFIX:
			break;
		case WINDOW_COPY_SEARCHUP:
			data->searchtype = data->inputtype;
			data->searchstr = xstrdup(data->inputstr);
d781 5
a785 5
				window_copy_search_up(wp, data->inputstr, 1);
			break;
		case WINDOW_COPY_SEARCHDOWN:
			data->searchtype = data->inputtype;
			data->searchstr = xstrdup(data->inputstr);
d787 1
a787 16
				window_copy_search_down(wp, data->inputstr, 1);
			break;
		case WINDOW_COPY_NAMEDBUFFER:
			window_copy_copy_selection(wp, data->inputstr);
			*data->inputstr = '\0';
			if (data->inputexit) {
				window_pane_reset_mode(wp);
				return (0);
			}
			window_copy_clear_selection(wp);
			window_copy_redraw_screen(wp);
			break;
		case WINDOW_COPY_GOTOLINE:
			window_copy_goto_line(wp, data->inputstr);
			*data->inputstr = '\0';
			break;
a788 13
		data->numprefix = -1;
		return (1);
	case MODEKEY_OTHER:
		if (key < 32 || key > 126)
			break;
		inputlen = strlen(data->inputstr) + 2;

		data->inputstr = xrealloc(data->inputstr, inputlen);
		data->inputstr[inputlen - 2] = key;
		data->inputstr[inputlen - 1] = '\0';
		break;
	default:
		break;
d791 1
a791 20
	window_copy_redraw_lines(wp, screen_size_y(s) - 1, 1);
	return (0);
}

int
window_copy_key_numeric_prefix(struct window_pane *wp, key_code key)
{
	struct window_copy_mode_data	*data = wp->modedata;
	struct screen			*s = &data->screen;

	key &= KEYC_MASK_KEY;
	if (key < '0' || key > '9')
		return (1);

	if (data->numprefix >= 100) 	/* no more than three digits */
		return (0);
	data->numprefix = data->numprefix * 10 + key - '0';

	window_copy_redraw_lines(wp, screen_size_y(s) - 1, 1);
	return (0);
d1054 1
a1054 1
	size_t				 last, xoff = 0, size = 0, limit;
a1065 14
	} else if (py == last && data->inputtype != WINDOW_COPY_OFF) {
		limit = sizeof hdr;
		if (limit > screen_size_x(s) + 1)
			limit = screen_size_x(s) + 1;
		if (data->inputtype == WINDOW_COPY_NUMERICPREFIX) {
			xoff = size = xsnprintf(hdr, limit,
			    "Repeat: %d", data->numprefix);
		} else {
			/* We don't care about truncation. */
			xoff = size = snprintf(hdr, limit,
			    "%s: %s", data->inputprompt, data->inputstr);
		}
		screen_write_cursormove(ctx, 0, last);
		screen_write_puts(ctx, &gc, "%s", hdr);
d2114 3
d2125 1
a2125 1
	c->tty.mouse_drag_release = NULL; /* will fire MouseUp key */
@


1.153
log
@Remove some dead code in cmd-move-window.c and make a load of local
functions static.
@
text
@d1 1
a1 1
/* $OpenBSD: window-copy.c,v 1.152 2016/09/12 15:40:58 nicm Exp $ */
d1291 2
a1292 1
			xoff = size = xsnprintf(hdr, limit,
@


1.152
log
@Allow repeat count to be specified in mode key tables with bind-key -R,
and set the default repeat count to 5 for WheelUp and WheelDown in
copy-mode.
@
text
@d1 1
a1 1
/* $OpenBSD: window-copy.c,v 1.151 2016/05/23 20:03:14 nicm Exp $ */
d951 1
a951 1
				window_copy_search_up(wp, data->inputstr, 0);
d957 1
a957 1
				window_copy_search_down(wp, data->inputstr, 0);
@


1.151
log
@Remove unused variable, from Ben Boeckel.
@
text
@d1 1
a1 1
/* $OpenBSD: window-copy.c,v 1.150 2016/05/03 13:40:50 nicm Exp $ */
d541 3
a543 1
	cmd = mode_key_lookup(&data->mdata, key, &arg);
d905 1
a905 1
	int				 np;
d909 1
a909 1
	switch (mode_key_lookup(&data->mdata, key, NULL)) {
d937 2
a938 4
		np = data->numprefix;
		if (np <= 0)
			np = 1;

@


1.150
log
@Some tidying of copy mode search functions, based on a diff from Lukasz
Piatkowski (initial changes to help some more to come).
@
text
@d1 1
a1 1
/* $OpenBSD: window-copy.c,v 1.149 2016/05/01 13:39:05 nicm Exp $ */
d426 1
a426 1
	u_int				 ox, oy;
a428 1
	ox = window_copy_find_length(wp, oy);
@


1.149
log
@Use the same code for half page scrolling as full, from Michal Mazurek.
@
text
@d1 1
a1 1
/* $OpenBSD: window-copy.c,v 1.148 2016/04/27 09:39:09 nicm Exp $ */
d53 8
a60 2
void	window_copy_search_up(struct window_pane *, const char *);
void	window_copy_search_down(struct window_pane *, const char *);
d825 1
a825 1
					window_copy_search_up(wp, ss);
d828 1
a828 1
					window_copy_search_down(wp, ss);
d835 1
a835 1
					window_copy_search_down(wp, ss);
d838 1
a838 1
					window_copy_search_up(wp, ss);
a948 2
			for (; np != 0; np--)
				window_copy_search_up(wp, data->inputstr);
d951 2
a954 2
			for (; np != 0; np--)
				window_copy_search_down(wp, data->inputstr);
d957 2
d1110 1
a1110 1
window_copy_search_up(struct window_pane *wp, const char *searchstr)
d1112 8
a1119 9
	struct window_copy_mode_data	*data = wp->modedata;
	struct screen			*s = data->backing, ss;
	struct screen_write_ctx		 ctx;
	struct grid			*gd = s->grid, *sgd;
	struct grid_cell	 	 gc;
	size_t				 searchlen;
	u_int				 i, last, fx, fy, px;
	int				 n, wrapped, wrapflag, cis;
	const char			*ptr;
d1121 5
a1125 16
	if (*searchstr == '\0')
		return;
	wrapflag = options_get_number(wp->window->options, "wrap-search");
	searchlen = screen_write_strlen("%s", searchstr);

	screen_init(&ss, searchlen, 1, 0);
	screen_write_start(&ctx, NULL, &ss);
	memcpy(&gc, &grid_default_cell, sizeof gc);
	screen_write_nputs(&ctx, -1, &gc, "%s", searchstr);
	screen_write_stop(&ctx);

	fx = data->cx;
	fy = gd->hsize - data->oy + data->cy;

	if (fx == 0) {
		if (fy == 0)
d1127 2
a1128 2
		fx = gd->sx - 1;
		fy--;
d1130 2
a1131 2
		fx--;
	n = wrapped = 0;
d1133 7
a1139 6
	cis = 1;
	for (ptr = searchstr; *ptr != '\0'; ptr++) {
		if (*ptr != tolower((u_char)*ptr)) {
			cis = 0;
			break;
		}
d1141 2
d1144 32
a1175 10
retry:
	sgd = ss.grid;
	for (i = fy + 1; i > 0; i--) {
		last = screen_size_x(s);
		if (i == fy + 1)
			last = fx;
		n = window_copy_search_rl(gd, sgd, &px, i - 1, 0, last, cis);
		if (n) {
			window_copy_scroll_to(wp, px, i - 1);
			break;
d1178 7
a1184 5
	if (wrapflag && !n && !wrapped) {
		fx = gd->sx - 1;
		fy = gd->hsize + gd->sy - 1;
		wrapped = 1;
		goto retry;
a1185 2

	screen_free(&ss);
d1188 5
d1194 2
a1195 1
window_copy_search_down(struct window_pane *wp, const char *searchstr)
d1200 3
a1202 6
	struct grid			*gd = s->grid, *sgd;
	struct grid_cell	 	 gc;
	size_t				 searchlen;
	u_int				 i, first, fx, fy, px;
	int				 n, wrapped, wrapflag, cis;
	const char			*ptr;
d1204 2
a1205 4
	if (*searchstr == '\0')
		return;
	wrapflag = options_get_number(wp->window->options, "wrap-search");
	searchlen = screen_write_strlen("%s", searchstr);
d1207 1
a1207 1
	screen_init(&ss, searchlen, 1, 0);
d1209 1
a1209 2
	memcpy(&gc, &grid_default_cell, sizeof gc);
	screen_write_nputs(&ctx, -1, &gc, "%s", searchstr);
d1212 10
a1221 2
	fx = data->cx;
	fy = gd->hsize - data->oy + data->cy;
d1223 6
a1228 8
	if (fx == gd->sx - 1) {
		if (fy == gd->hsize + gd->sy)
			return;
		fx = 0;
		fy++;
	} else
		fx++;
	n = wrapped = 0;
d1230 2
a1231 7
	cis = 1;
	for (ptr = searchstr; *ptr != '\0'; ptr++) {
		if (*ptr != tolower((u_char)*ptr)) {
			cis = 0;
			break;
		}
	}
d1233 6
a1238 19
retry:
	sgd = ss.grid;
	for (i = fy + 1; i < gd->hsize + gd->sy + 1; i++) {
		first = 0;
		if (i == fy + 1)
			first = fx;
		n = window_copy_search_lr(gd, sgd, &px, i - 1, first, gd->sx,
		    cis);
		if (n) {
			window_copy_scroll_to(wp, px, i - 1);
			break;
		}
	}
	if (wrapflag && !n && !wrapped) {
		fx = 0;
		fy = 0;
		wrapped = 1;
		goto retry;
	}
d1240 5
a1244 1
	screen_free(&ss);
@


1.148
log
@Add next/previous paragraph, from J Raynor.
@
text
@d1 1
a1 1
/* $OpenBSD: window-copy.c,v 1.147 2016/03/18 14:27:24 nicm Exp $ */
d29 1
a29 1
void	window_copy_pagedown(struct window_pane *);
d326 1
a326 1
window_copy_pageup(struct window_pane *wp)
d345 6
a350 2
	if (screen_size_y(s) > 2)
		n = screen_size_y(s) - 2;
d369 1
a369 1
window_copy_pagedown(struct window_pane *wp)
d388 6
a393 2
	if (screen_size_y(s) > 2)
		n = screen_size_y(s) - 2;
d488 1
a488 1
	u_int				 n, np;
d593 1
a593 1
			window_copy_pageup(wp);
d597 1
a597 1
			window_copy_pagedown(wp);
d608 2
a609 9
		n = screen_size_y(s) / 2;
		for (; np != 0; np--) {
			if (data->oy + n > screen_hsize(data->backing))
				data->oy = screen_hsize(data->backing);
			else
				data->oy += n;
		}
		window_copy_update_selection(wp, 1);
		window_copy_redraw_screen(wp);
d612 2
a613 13
		n = screen_size_y(s) / 2;
		for (; np != 0; np--) {
			if (data->oy < n)
				data->oy = 0;
			else
				data->oy -= n;
		}
		if (data->scroll_exit && data->oy == 0) {
			window_pane_reset_mode(wp);
			return;
		}
		window_copy_update_selection(wp, 1);
		window_copy_redraw_screen(wp);
@


1.147
log
@Make scrolling behaviour more sensible and maintain cursor position, as
if the same had been done line-by-line. From Michal Mazurek.
@
text
@d1 1
a1 1
/* $OpenBSD: window-copy.c,v 1.146 2016/03/01 12:04:43 nicm Exp $ */
d30 2
d409 38
d590 8
@


1.146
log
@When a mouse drag is finished, fire a MouseUp key press, instead of
doing the drag end in code. From Stephen Coakley.
@
text
@d1 1
a1 1
/* $OpenBSD: window-copy.c,v 1.145 2016/02/05 10:20:06 nicm Exp $ */
d29 1
d328 13
a340 1
	u_int				 n;
d345 1
d350 52
d548 2
a549 15
		n = 1;
		if (screen_size_y(s) > 2)
			n = screen_size_y(s) - 2;
		for (; np != 0; np--) {
			if (data->oy < n)
				data->oy = 0;
			else
				data->oy -= n;
		}
		if (data->scroll_exit && data->oy == 0) {
			window_pane_reset_mode(wp);
			return;
		}
		window_copy_update_selection(wp, 1);
		window_copy_redraw_screen(wp);
@


1.145
log
@Do not wrap cursor at start or end of history, from Michal Mazurek.
@
text
@d1 1
a1 1
/* $OpenBSD: window-copy.c,v 1.144 2016/01/19 15:59:12 nicm Exp $ */
d2251 1
a2251 1
	c->tty.mouse_drag_release = window_copy_drag_release;
a2276 13
}

void
window_copy_drag_release(__unused struct client *c, struct mouse_event *m)
{
	struct window_pane	*wp;

	wp = cmd_mouse_pane(m, NULL, NULL);
	if (wp == NULL || wp->mode != &window_copy_mode)
		return;

	window_copy_copy_selection(wp, NULL);
	window_pane_reset_mode(wp);
@


1.144
log
@I no longer use my SourceForge address so replace it.
@
text
@d1 1
a1 1
/* $OpenBSD: window-copy.c,v 1.143 2015/12/11 12:27:36 nicm Exp $ */
d1778 1
d1780 2
a1781 1
	if (data->cx == 0) {
d1784 1
a1784 1
	} else {
d1795 1
a1795 1
	u_int				 px, py;
d1797 2
a1801 1
		py = screen_hsize(data->backing) + data->cy - data->oy;
d1805 1
a1805 1
	if (data->cx >= px) {
d1808 1
a1808 1
	} else {
@


1.143
log
@Add cmdq as an argument to format_create and add a format for the
command name (will also be used for more later).
@
text
@d1 1
a1 1
/* $OpenBSD: window-copy.c,v 1.142 2015/12/08 08:34:18 nicm Exp $ */
d4 1
a4 1
 * Copyright (c) 2007 Nicholas Marriott <nicm@@users.sourceforge.net>
@


1.142
log
@Remove format_create_flags and just pass flags to format_create.
@
text
@d1 1
a1 1
/* $OpenBSD: window-copy.c,v 1.141 2015/11/18 14:27:44 nicm Exp $ */
d1483 1
a1483 1
	ft = format_create(0);
@


1.141
log
@Use __unused rather than rolling our own.
@
text
@d1 1
a1 1
/* $OpenBSD: window-copy.c,v 1.140 2015/11/13 08:09:28 nicm Exp $ */
d1483 1
a1483 1
	ft = format_create();
@


1.140
log
@Long overdue change to the way we store cells in the grid: now, instead
of storing a full grid_cell with UTF-8 data and everything, store a new
type grid_cell_entry. This can either be the cell itself (for ASCII
cells), or an offset into an extended array (per line) for UTF-8
data.

This avoid a large (8 byte) overhead on non-UTF-8 cells (by far the
majority for most users) without the complexity of the shadow array we
had before. Grid memory without any UTF-8 is about half.

The disadvantage that cells can no longer be modified in place and need
to be copied out of the grid and back but it turned out to be lot less
complicated than I expected.
@
text
@d1 1
a1 1
/* $OpenBSD: window-copy.c,v 1.139 2015/11/12 11:09:11 nicm Exp $ */
d2235 1
a2235 1
window_copy_start_drag(struct client *c, unused struct mouse_event *m)
d2256 1
a2256 1
window_copy_drag_update(unused struct client *c, struct mouse_event *m)
d2277 1
a2277 1
window_copy_drag_release(unused struct client *c, struct mouse_event *m)
@


1.139
log
@Nuke the utf8 and status-utf8 options and make tmux only a UTF-8
terminal. We still support non-UTF-8 terminals outside tmux, but inside
it is always UTF-8 (as when the utf8 and status-utf8 options were on).
@
text
@d1 1
a1 1
/* $OpenBSD: window-copy.c,v 1.138 2015/11/12 11:05:34 nicm Exp $ */
d945 2
a946 2
	const struct grid_cell	*gc, *sgc;
	struct utf8_data	 ud, sud;
d948 4
a951 4
	gc = grid_peek_cell(gd, px, py);
	grid_cell_get(gc, &ud);
	sgc = grid_peek_cell(sgd, spx, 0);
	grid_cell_get(sgc, &sud);
d953 1
a953 1
	if (ud.size != sud.size || ud.width != sud.width)
d956 2
a957 2
	if (cis && ud.size == 1)
		return (tolower(ud.data[0]) == sud.data[0]);
d959 1
a959 1
	return (memcmp(ud.data, sud.data, ud.size) == 0);
d1544 2
a1545 2
window_copy_copy_line(struct window_pane *wp,
    char **buf, size_t *off, u_int sy, u_int sx, u_int ex)
d1549 1
a1549 1
	const struct grid_cell		*gc;
d1578 2
a1579 2
			gc = grid_peek_cell(gd, i, sy);
			if (gc->flags & GRID_FLAG_PADDING)
d1581 2
a1582 2
			grid_cell_get(gc, &ud);
			if (ud.size == 1 && (gc->attr & GRID_ATTR_CHARSET)) {
d1621 4
a1624 2
	const struct grid_cell		*gc;
	struct utf8_data		 ud;
d1626 2
a1627 3
	gc = grid_peek_cell(data->backing->grid, px, py);
	grid_cell_get(gc, &ud);
	if (ud.size != 1 || gc->flags & GRID_FLAG_PADDING)
d1629 1
a1629 1
	if (*ud.data == 0x00 || *ud.data == 0x7f)
d1631 1
a1631 1
	return (strchr(set, *ud.data) != NULL);
d1639 1
a1639 2
	const struct grid_cell		*gc;
	struct utf8_data		 ud;
d1652 2
a1653 3
		gc = grid_peek_cell(s->grid, px - 1, py);
		grid_cell_get(gc, &ud);
		if (ud.size != 1 || *ud.data != ' ')
d1687 1
a1687 2
	const struct grid_cell		*gc;
	struct utf8_data		 ud;
d1694 2
a1695 3
		gc = grid_peek_cell(data->backing->grid, px, py);
		grid_cell_get(gc, &ud);
		if (ud.size != 1 || *ud.data != ' ')
d1909 1
a1909 2
	const struct grid_cell		*gc;
	struct utf8_data		 ud;
d1917 3
a1919 4
		gc = grid_peek_cell(back_s->grid, px, py);
		grid_cell_get(gc, &ud);
		if (!(gc->flags & GRID_FLAG_PADDING) &&
		    ud.size == 1 && *ud.data == data->jumpchar) {
d1934 1
a1934 2
	const struct grid_cell		*gc;
	struct utf8_data		 ud;
d1944 3
a1946 4
		gc = grid_peek_cell(back_s->grid, px, py);
		grid_cell_get(gc, &ud);
		if (!(gc->flags & GRID_FLAG_PADDING) &&
		    ud.size == 1 && *ud.data == data->jumpchar) {
d1963 1
a1963 2
	const struct grid_cell		*gc;
	struct utf8_data		 ud;
d1971 3
a1973 4
		gc = grid_peek_cell(back_s->grid, px, py);
		grid_cell_get(gc, &ud);
		if (!(gc->flags & GRID_FLAG_PADDING) &&
		    ud.size == 1 && *ud.data == data->jumpchar) {
d1988 1
a1988 2
	const struct grid_cell		*gc;
	struct utf8_data		 ud;
d2001 3
a2003 4
		gc = grid_peek_cell(back_s->grid, px, py);
		grid_cell_get(gc, &ud);
		if (!(gc->flags & GRID_FLAG_PADDING) &&
		    ud.size == 1 && *ud.data == data->jumpchar) {
@


1.138
log
@Support UTF-8 key bindings by expanding the key type from int to
uint64_t and converting UTF-8 to Unicode on input and the reverse on
output. (This allows key bindings, there are still omissions - the
largest being that the various prompts do not accept UTF-8.)
@
text
@d1 1
a1 1
/* $OpenBSD: window-copy.c,v 1.137 2015/10/31 08:13:58 nicm Exp $ */
a282 1
	int				 utf8flag;
a287 1
	utf8flag = options_get_number(wp->window->options, "utf8");
d302 1
a302 1
	screen_write_vnputs(&back_ctx, 0, &gc, utf8flag, fmt, ap);
d1022 1
a1022 1
	int				 utf8flag, n, wrapped, wrapflag, cis;
a1026 1
	utf8flag = options_get_number(wp->window->options, "utf8");
d1028 1
a1028 1
	searchlen = screen_write_strlen(utf8flag, "%s", searchstr);
d1033 1
a1033 1
	screen_write_nputs(&ctx, -1, &gc, utf8flag, "%s", searchstr);
d1088 1
a1088 1
	int				 utf8flag, n, wrapped, wrapflag, cis;
a1092 1
	utf8flag = options_get_number(wp->window->options, "utf8");
d1094 1
a1094 1
	searchlen = screen_write_strlen(utf8flag, "%s", searchstr);
d1099 1
a1099 1
	screen_write_nputs(&ctx, -1, &gc, utf8flag, "%s", searchstr);
@


1.137
log
@Because pledge(2) does not allow us to pass directory file descriptors
around, we can't use file descriptors for the working directory because
we will be unable to pass it to a privileged process to tell it where to
read or write files or spawn children. So move tmux back to using
strings for the current working directory. We try to check it exists
with access() when it is set but ultimately fall back to ~ if it fails
at time of use (or / if that fails too).
@
text
@d1 1
a1 1
/* $OpenBSD: window-copy.c,v 1.136 2015/10/27 15:58:43 nicm Exp $ */
d31 3
a33 3
	    int, struct mouse_event *);
int	window_copy_key_input(struct window_pane *, int);
int	window_copy_key_numeric_prefix(struct window_pane *, int);
d371 1
a371 1
    int key, struct mouse_event *m)
d803 1
a803 1
window_copy_key_input(struct window_pane *wp, int key)
d900 1
a900 1
window_copy_key_numeric_prefix(struct window_pane *wp, int key)
@


1.136
log
@Move struct options into options.c.
@
text
@d1 1
a1 1
/* $OpenBSD: window-copy.c,v 1.135 2015/10/23 16:02:21 nicm Exp $ */
d1491 1
a1491 1
	job = job_run(expanded, sess, -1, NULL, NULL, NULL);
@


1.135
log
@Format for scroll position, from Jorge Morante.
@
text
@d1 1
a1 1
/* $OpenBSD: window-copy.c,v 1.134 2015/09/14 11:57:22 nicm Exp $ */
d198 1
a198 1
	keys = options_get_number(&wp->window->options, "mode-keys");
d289 1
a289 1
	utf8flag = options_get_number(&wp->window->options, "utf8");
d632 1
a632 1
		    options_get_string(&sess->options, "word-separators");
d638 1
a638 1
		    options_get_string(&sess->options, "word-separators");
d648 1
a648 1
		    options_get_string(&sess->options, "word-separators");
d780 1
a780 1
	keys = options_get_number(&wp->window->options, "mode-keys");
d790 1
a790 1
	keys = options_get_number(&wp->window->options, "mode-keys");
d1029 2
a1030 2
	utf8flag = options_get_number(&wp->window->options, "utf8");
	wrapflag = options_get_number(&wp->window->options, "wrap-search");
d1096 2
a1097 2
	utf8flag = options_get_number(&wp->window->options, "utf8");
	wrapflag = options_get_number(&wp->window->options, "wrap-search");
d1171 1
a1171 1
	struct options			*oo = &wp->window->options;
d1304 1
a1304 1
	struct options			*oo = &wp->window->options;
d1404 1
a1404 1
	keys = options_get_number(&wp->window->options, "mode-keys");
d1463 1
a1463 1
	if (options_get_number(&global_options, "set-clipboard")) {
d1526 1
a1526 1
	if (options_get_number(&global_options, "set-clipboard")) {
d2077 1
a2077 1
	struct options			*oo = &wp->window->options;
@


1.134
log
@Style nit, int for flags not u_int.
@
text
@d1 1
a1 1
/* $OpenBSD: window-copy.c,v 1.133 2015/09/13 13:31:40 nicm Exp $ */
d2220 10
@


1.133
log
@Add copy-mode -e to exit copy mode when scrolling off the bottom, useful
for quick view of history, from Cam Hutchison.
@
text
@d1 1
a1 1
/* $OpenBSD: window-copy.c,v 1.132 2015/08/29 09:25:00 nicm Exp $ */
d211 1
a211 1
window_copy_init_from_pane(struct window_pane *wp, u_int scroll_exit)
@


1.132
log
@Move struct paste_buffer out of tmux.h.
@
text
@d1 1
a1 1
/* $OpenBSD: window-copy.c,v 1.131 2015/08/28 12:25:42 nicm Exp $ */
d138 2
a139 1
	u_int			 rectflag; /* are we in rectangle copy mode? */
d179 1
d211 1
a211 1
window_copy_init_from_pane(struct window_pane *wp)
d224 1
d425 7
d474 4
d493 4
d518 4
@


1.131
log
@Give clock mode its own timer.
@
text
@d1 1
a1 1
/* $OpenBSD: window-copy.c,v 1.130 2015/04/24 22:19:36 nicm Exp $ */
d785 2
a786 1
	size_t				 inputlen, n;
d804 1
a804 1
		if ((pb = paste_get_top()) == NULL)
d806 3
a808 2
		for (n = 0; n < pb->size; n++) {
			ch = (u_char) pb->data[n];
d815 1
a815 1
		memcpy(data->inputstr + inputlen, pb->data, n);
d1496 2
a1497 1
	size_t				 len;
d1510 3
a1512 5
	if (bufname == NULL || *bufname == '\0') {
		pb = paste_get_top();
		if (pb != NULL)
			bufname = pb->name;
	} else
d1515 5
a1519 4
		buf = xrealloc(buf, len + pb->size);
		memmove(buf + pb->size, buf, len);
		memcpy(buf, pb->data, pb->size);
		len += pb->size;
@


1.130
log
@Set working directory for run-shell and if-shell.
@
text
@d1 1
a1 1
/* $OpenBSD: window-copy.c,v 1.129 2015/04/21 15:16:06 nicm Exp $ */
a93 1
	NULL,
@


1.129
log
@cmd_mouse_pane can return NULL, check for that.
@
text
@d1 1
a1 1
/* $OpenBSD: window-copy.c,v 1.128 2015/04/20 15:41:32 nicm Exp $ */
d1468 1
a1468 1
	job = job_run(expanded, sess, NULL, NULL, NULL);
@


1.128
log
@Remove unused-but-set variables, from Thomas Adam.
@
text
@d1 1
a1 1
/* $OpenBSD: window-copy.c,v 1.127 2015/04/20 09:39:21 nicm Exp $ */
d2223 1
a2223 1
	if (wp->mode != &window_copy_mode)
d2245 1
a2245 1
	if (wp->mode != &window_copy_mode)
d2264 1
a2264 1
	if (wp->mode != &window_copy_mode)
@


1.127
log
@Make jump-to-backward/jump-to-forward repeatable with
jump-reverse/jump-again, from Jacob Niehus.
@
text
@d1 1
a1 1
/* $OpenBSD: window-copy.c,v 1.126 2015/04/19 21:34:21 nicm Exp $ */
d2219 2
a2220 3
	struct window_pane		*wp;
	struct window_copy_mode_data	*data;
	u_int				 x, y;
a2224 1
	data = wp->modedata;
d2261 1
a2261 2
	struct window_pane		*wp;
	struct window_copy_mode_data	*data;
a2265 1
	data = wp->modedata;
@


1.126
log
@Rewrite of tmux mouse support which was a mess. Instead of having
options for "mouse-this" and "mouse-that", mouse events may be bound as
keys and there is one option "mouse" that turns on mouse support
entirely (set -g mouse on).

See the new MOUSE SUPPORT section of the man page for description of the
key names and new flags (-t= to specify the pane or window under mouse
as a target, and send-keys -M to pass through a mouse event).

The default builtin bindings for the mouse are:

    bind -n   MouseDown1Pane select-pane -t=; send-keys -M
    bind -n MouseDown1Status select-window -t=
    bind -n   MouseDrag1Pane copy-mode -M
    bind -n MouseDrag1Border resize-pane -M

To get the effect of turning mode-mouse off, do:

    unbind -n MouseDrag1Pane
    unbind -temacs-copy MouseDrag1Pane

The old mouse options are now gone, set-option -q may be used to
suppress warnings if mixing configuration files.
@
text
@d1 1
a1 1
/* $OpenBSD: window-copy.c,v 1.125 2015/04/10 16:00:08 nicm Exp $ */
d78 2
a79 2
void	window_copy_cursor_jump_to(struct window_pane *);
void	window_copy_cursor_jump_to_back(struct window_pane *);
d400 1
a400 1
					window_copy_cursor_jump_to(wp);
d404 1
a404 1
					window_copy_cursor_jump_to_back(wp);
d646 1
a646 1
				window_copy_cursor_jump_to(wp);
d649 1
a649 1
				window_copy_cursor_jump_to_back(wp);
d661 1
a661 1
				window_copy_cursor_jump_to_back(wp);
d664 1
a664 1
				window_copy_cursor_jump_to(wp);
d1947 1
a1947 1
window_copy_cursor_jump_to(struct window_pane *wp)
d1955 1
a1955 1
	px = data->cx + 1;
d1974 1
a1974 1
window_copy_cursor_jump_to_back(struct window_pane *wp)
d1986 3
@


1.125
log
@Add a -x flag to copy-selection, append-selection and start-named-buffer
to prevent it exiting copy mode after copying. From J Raynor with a few
tweaks by me.
@
text
@d1 1
a1 1
/* $OpenBSD: window-copy.c,v 1.124 2015/03/31 17:45:10 nicm Exp $ */
d30 2
a31 1
void	window_copy_key(struct window_pane *, struct session *, int);
a33 2
void	window_copy_mouse(struct window_pane *, struct session *,
	    struct mouse_event *);
d86 2
a93 1
	window_copy_mouse,
d127 1
a127 1
	struct screen	screen;
d129 2
a130 2
	struct screen  *backing;
	int		backing_written; /* backing display has started */
d132 1
a132 1
	struct mode_key_data mdata;
d134 1
a134 1
	u_int		oy;
d136 2
a137 2
	u_int		selx;
	u_int		sely;
d139 1
a139 1
	u_int		rectflag; /* are we in rectangle copy mode? */
d141 2
a142 2
	u_int		cx;
	u_int		cy;
d144 2
a145 2
	u_int		lastcx; /* position in last line with content */
	u_int		lastsx; /* size of last line with content */
d148 3
a150 3
	const char     *inputprompt;
	char	       *inputstr;
	int		inputexit;
d152 1
a152 1
	int		numprefix;
d155 1
a155 1
	char	       *searchstr;
d158 1
a158 1
	char		jumpchar;
a195 2
	if (options_get_number(&wp->window->options, "mode-mouse"))
		s->mode |= MODE_MOUSE_STANDARD;
d368 2
a369 1
window_copy_key(struct window_pane *wp, struct session *sess, int key)
d374 2
a375 2
	u_int				 n;
	int				 np, keys;
d379 3
a381 3
	np = data->numprefix;
	if (np <= 0)
		np = 1;
d538 8
a545 3
		s->sel.lineflag = LINE_SEL_NONE;
		window_copy_start_selection(wp);
		window_copy_redraw_screen(wp);
a894 69
window_copy_mouse(struct window_pane *wp, struct session *sess,
    struct mouse_event *m)
{
	struct window_copy_mode_data	*data = wp->modedata;
	struct screen			*s = &data->screen;
	u_int				 i, old_cy;

	if (m->x >= screen_size_x(s))
		return;
	if (m->y >= screen_size_y(s))
		return;

	/* If mouse wheel (buttons 4 and 5), scroll. */
	if (m->event == MOUSE_EVENT_WHEEL) {
		for (i = 0; i < m->scroll; i++) {
			if (m->wheel == MOUSE_WHEEL_UP)
				window_copy_cursor_up(wp, 1);
			else {
				window_copy_cursor_down(wp, 1);

				/*
				 * We reached the bottom, leave copy mode, but
				 * only if no selection is in progress.
				 */
				if (data->oy == 0 && !s->sel.flag &&
				    s->sel.lineflag == LINE_SEL_NONE)
					goto reset_mode;
			}
		}
		return;
	}

	/*
	 * If already reading motion, move the cursor while buttons are still
	 * pressed, or stop the selection on their release.
	 */
	if (s->mode & MODE_MOUSE_BUTTON) {
		if (~m->event & MOUSE_EVENT_UP) {
			old_cy = data->cy;
			window_copy_update_cursor(wp, m->x, m->y);
			if (window_copy_update_selection(wp, 1))
				window_copy_redraw_selection(wp, old_cy);
			return;
		}
		goto reset_mode;
	}

	/* Otherwise if other buttons pressed, start selection and motion. */
	if (~m->event & MOUSE_EVENT_UP) {
		s->mode &= ~MODE_MOUSE_STANDARD;
		s->mode |= MODE_MOUSE_BUTTON;

		window_copy_update_cursor(wp, m->x, m->y);
		window_copy_start_selection(wp);
		window_copy_redraw_screen(wp);
	}

	return;

reset_mode:
	s->mode &= ~MODE_MOUSE_BUTTON;
	s->mode |= MODE_MOUSE_STANDARD;
	if (sess != NULL) {
		window_copy_copy_selection(wp, NULL);
		window_pane_reset_mode(wp);
	}
}

void
d2211 59
@


1.124
log
@Fix some format specifier nits, from Ben Boeckel.
@
text
@d1 1
a1 1
/* $OpenBSD: window-copy.c,v 1.123 2015/02/05 10:29:43 nicm Exp $ */
d150 1
d428 6
a433 2
			window_pane_reset_mode(wp);
			return;
d580 6
a585 2
			window_pane_reset_mode(wp);
			return;
d730 1
d841 7
a847 2
			window_pane_reset_mode(wp);
			return (0);
@


1.123
log
@Wrap all the individual format_* calls in a single format_defaults
functions.
@
text
@d1 1
a1 1
/* $OpenBSD: window-copy.c,v 1.122 2015/01/15 13:35:13 nicm Exp $ */
d1219 1
a1219 1
			    "Repeat: %u", data->numprefix);
@


1.122
log
@Shorten some long lines.
@
text
@d1 1
a1 1
/* $OpenBSD: window-copy.c,v 1.121 2014/12/15 10:02:55 nicm Exp $ */
d1515 1
a1515 3
	format_window_pane(ft, wp);
	if (sess != NULL)
		format_session(ft, sess);
@


1.121
log
@Only redraw affected lines when selection changes with mouse. From
Michael Graczyk.
@
text
@d1 1
a1 1
/* $OpenBSD: window-copy.c,v 1.120 2014/11/09 15:13:01 nicm Exp $ */
d393 2
a394 1
			} else if (data->inputtype == WINDOW_COPY_JUMPBACK) {
d397 2
a398 1
			} else if (data->inputtype == WINDOW_COPY_JUMPTOFORWARD) {
d401 2
a402 1
			} else if (data->inputtype == WINDOW_COPY_JUMPTOBACK) {
d1777 1
a1777 1
	u_int				 selx, sely, cx, cy, yy;
d1797 3
a1799 2
	if (sely < screen_hsize(data->backing) - data->oy) {
		data->oy = screen_hsize(data->backing) - sely;
d1801 2
a1802 2
	} else if (sely > screen_hsize(data->backing) - data->oy + screen_size_y(s)) {
		data->oy = screen_hsize(data->backing) - sely + screen_size_y(s) - 1;
a1803 1

@


1.120
log
@Expand formats in copy-pipe command, suggested by Suraj N Kurapati.
@
text
@d1 1
a1 1
/* $OpenBSD: window-copy.c,v 1.119 2014/11/06 10:56:44 nicm Exp $ */
d36 1
d878 1
a878 1
	u_int				 i;
d911 1
d914 1
a914 1
				window_copy_redraw_screen(wp);
d1248 17
@


1.119
log
@Wrap when copy mode is used for output, from Balazs Kezes.
@
text
@d1 1
a1 1
/* $OpenBSD: window-copy.c,v 1.118 2014/11/06 09:17:26 nicm Exp $ */
d1482 5
a1486 4
	void		*buf;
	size_t		 len;
	struct job	*job;

d1492 7
a1498 1
	job = job_run(arg, sess, NULL, NULL, NULL);
d1500 3
@


1.118
log
@Add V for select line with vi(1) keys. From Juho Pohjala.
@
text
@d1 1
a1 1
/* $OpenBSD: window-copy.c,v 1.117 2014/10/22 23:18:53 nicm Exp $ */
a241 1
	data->backing->mode &= ~MODE_WRAP;
d282 1
a282 1
	u_int				 old_hsize;
d301 1
d316 2
a317 3
	/* Write the line, if it's visible. */
	if (backing->cy + data->oy < screen_size_y(backing))
		window_copy_redraw_lines(wp, backing->cy, 1);
d347 1
a347 1
	screen_resize(s, sx, sy, 0);
d349 1
a349 1
		screen_resize(data->backing, sx, sy, 0);
@


1.117
log
@Fix some spacing nits.
@
text
@d1 1
a1 1
/* $OpenBSD: window-copy.c,v 1.116 2014/10/08 17:35:58 nicm Exp $ */
d33 2
a34 2
void	window_copy_mouse(
	    struct window_pane *, struct session *, struct mouse_event *);
d38 4
a41 4
void	window_copy_write_line(
	    struct window_pane *, struct screen_write_ctx *, u_int);
void	window_copy_write_lines(
	    struct window_pane *, struct screen_write_ctx *, u_int, u_int);
d44 6
a49 6
int	window_copy_search_compare(
	    struct grid *, u_int, u_int, struct grid *, u_int, int);
int	window_copy_search_lr(
	    struct grid *, struct grid *, u_int *, u_int, u_int, u_int, int);
int	window_copy_search_rl(
	    struct grid *, struct grid *, u_int *, u_int, u_int, u_int, int);
d377 1
a377 1
	const char			*arg;
d531 1
d535 4
a539 1
	case MODEKEYCOPY_SELECTLINE:
d690 1
d692 2
a693 4
				for (; np != 0; np--) {
					window_copy_search_up(
					    wp, data->searchstr);
				}
d695 2
a696 4
				for (; np != 0; np--) {
					window_copy_search_down(
					    wp, data->searchstr);
				}
d700 1
d702 2
a703 4
				for (; np != 0; np--) {
					window_copy_search_down(
					    wp, data->searchstr);
				}
d705 2
a706 4
				for (; np != 0; np--) {
					window_copy_search_up(
					    wp, data->searchstr);
				}
d731 1
d873 2
a874 2
window_copy_mouse(
    struct window_pane *wp, struct session *sess, struct mouse_event *m)
d897 2
a898 1
				if (data->oy == 0 && !s->sel.flag)
d967 2
a968 2
window_copy_search_compare(
    struct grid *gd, u_int px, u_int py, struct grid *sgd, u_int spx, int cis)
d1189 2
a1190 2
window_copy_write_line(
    struct window_pane *wp, struct screen_write_ctx *ctx, u_int py)
d1240 2
a1241 2
window_copy_write_lines(
    struct window_pane *wp, struct screen_write_ctx *ctx, u_int py, u_int ny)
d1314 1
a1314 1
	if (!s->sel.flag)
d1368 1
a1368 1
	if (!s->sel.flag)
d1668 1
d1672 1
a1672 1
	if (data->cx == 0) {
d1674 2
a1675 1
		while (py > 0 && gd->linedata[py-1].flags & GRID_LINE_WRAPPED) {
d1715 1
d1722 1
a1722 1
	if (data->cx == px) {
d1748 1
a1748 1
	if (!s->sel.flag)
d1751 5
d1831 3
d1860 5
d1881 3
d1902 5
@


1.116
log
@Add xreallocarray and remove nmemb argument from xrealloc.
@
text
@d1 1
a1 1
/* $OpenBSD: window-copy.c,v 1.115 2014/10/02 08:36:26 nicm Exp $ */
d1588 1
a1588 1
					memcpy (ud.data, s, ud.size);
@


1.115
log
@Copy ACS characters as UTF-8, from Balazs Kezes.
@
text
@d1 1
a1 1
/* $OpenBSD: window-copy.c,v 1.114 2014/09/01 21:50:18 nicm Exp $ */
d797 1
a797 1
		data->inputstr = xrealloc(data->inputstr, 1, inputlen + n + 1);
d843 1
a843 1
		data->inputstr = xrealloc(data->inputstr, 1, inputlen);
d1536 1
a1536 1
		buf = xrealloc(buf, 1, len + pb->size);
d1592 1
a1592 1
			*buf = xrealloc(*buf, 1, (*off) + ud.size);
d1600 1
a1600 1
		*buf = xrealloc(*buf, 1, (*off) + 1);
@


1.114
log
@Various minor style and spacing nits.
@
text
@d1 1
a1 1
/* $OpenBSD: window-copy.c,v 1.113 2014/08/11 22:39:57 nicm Exp $ */
d1555 1
d1584 7
@


1.113
log
@No need to repeat other-end more than once, from Juho Pohjala. Also add
it to the commands list while here.
@
text
@d1 1
a1 1
/* $OpenBSD: window-copy.c,v 1.112 2014/08/11 22:18:16 nicm Exp $ */
d1501 2
a1502 2
	void*	buf;
	size_t	len;
@


1.112
log
@Fix two copy mode problems:

1. In vi mode the selection doesn't include the last character if you
   moved the cursor up or left.
2. In emacs mode the selection includes the last character if you moved
   the cursor to the left.

From Balazs Kezes.
@
text
@d1 1
a1 1
/* $OpenBSD: window-copy.c,v 1.111 2014/06/19 07:37:59 nicm Exp $ */
d432 1
a432 1
		for (; np != 0; np--)
@


1.111
log
@Copy newline when at EOL in vi(1) mode, from Balazs Kezes.
@
text
@d1 1
a1 1
/* $OpenBSD: window-copy.c,v 1.110 2014/05/14 06:39:58 nicm Exp $ */
d202 1
@


1.110
log
@Simplify copy lines, from Keith Amling.
@
text
@d1 1
a1 1
/* $OpenBSD: window-copy.c,v 1.109 2014/05/13 07:54:20 nicm Exp $ */
d1363 1
a1363 1
	u_int				 i, xx, yy, sx, sy, ex, ey;
d1392 3
a1394 3
	xx = window_copy_find_length(wp, ey);
	if (ex > xx)
		ex = xx;
d1456 3
a1458 1
	*len = off - 1;	/* remove final \n */
@


1.109
log
@Add a copy mode key binding to copy to a named buffer. From J Raynor.
@
text
@d1 1
a1 1
/* $OpenBSD: window-copy.c,v 1.108 2014/05/13 07:34:35 nicm Exp $ */
d1445 4
a1448 11
	if (sy == ey)
		window_copy_copy_line(wp, &buf, &off, sy, firstsx, lastex);
	else {
		window_copy_copy_line(wp, &buf, &off, sy, firstsx, restex);
		if (ey - sy > 1) {
			for (i = sy + 1; i < ey; i++) {
				window_copy_copy_line(
				    wp, &buf, &off, i, restsx, restex);
			}
		}
		window_copy_copy_line(wp, &buf, &off, ey, restsx, lastex);
@


1.108
log
@Add support for named buffers. If you don't name a buffer, things work
much as before - buffers are automatically named "buffer0000",
"buffer0001" and so on and ordered as a stack. Buffers can be named
explicitly when creating ("loadb -b foo" etc) or renamed ("setb -b
buffer0000 -n foo"). If buffers are named explicitly, they are not
deleted when buffer-limit is reached. Diff from J Raynor.
@
text
@d1 1
a1 1
/* $OpenBSD: window-copy.c,v 1.107 2014/04/24 09:14:43 nicm Exp $ */
d64 2
a65 2
void	window_copy_copy_line(
	    struct window_pane *, char **, size_t *, u_int, u_int, u_int);
d98 1
d681 1
d717 5
d825 5
@


1.107
log
@There is no longer a need for a paste_stack struct or for global_buffers
to be global. Move to paste.c.
@
text
@d1 1
a1 1
/* $OpenBSD: window-copy.c,v 1.106 2014/04/17 14:45:49 nicm Exp $ */
d57 6
a62 5
void	window_copy_copy_buffer(struct window_pane *, int, void *, size_t);
void	window_copy_copy_pipe(
	    struct window_pane *, struct session *, int, const char *);
void	window_copy_copy_selection(struct window_pane *, int);
void	window_copy_append_selection(struct window_pane *, int);
d421 1
a421 1
			window_copy_append_selection(wp, data->numprefix);
d547 1
a547 1
			window_copy_copy_selection(wp, -1);
d558 1
a558 1
			window_copy_copy_pipe(wp, sess, data->numprefix, arg);
d565 1
a565 1
			window_copy_copy_selection(wp, data->numprefix);
d922 1
a922 1
		window_copy_copy_selection(wp, -1);
d1456 2
a1457 1
window_copy_copy_buffer(struct window_pane *wp, int idx, void *buf, size_t len)
a1458 1
	u_int			limit;
d1467 1
a1467 4
	if (idx == -1) {
		limit = options_get_number(&global_options, "buffer-limit");
		paste_add(buf, len, limit);
	} else if (paste_replace(idx, buf, len) != 0)
d1472 2
a1473 2
window_copy_copy_pipe(
    struct window_pane *wp, struct session *sess, int idx, const char *arg)
d1487 1
a1487 1
	window_copy_copy_buffer(wp, idx, buf, len);
d1491 1
a1491 1
window_copy_copy_selection(struct window_pane *wp, int idx)
d1500 1
a1500 1
	window_copy_copy_buffer(wp, idx, buf, len);
d1504 1
a1504 1
window_copy_append_selection(struct window_pane *wp, int idx)
d1506 4
a1509 5
	char			*buf;
	struct paste_buffer	*pb;
	size_t			 len;
	u_int			 limit;
	struct screen_write_ctx	 ctx;
d1521 6
a1526 10
	if (idx == -1)
		idx = 0;

	if (idx == 0 && paste_get_top() == NULL) {
		limit = options_get_number(&global_options, "buffer-limit");
		paste_add(buf, len, limit);
		return;
	}

	pb = paste_get_index(idx);
d1533 1
a1533 2

	if (paste_replace(idx, buf, len) != 0)
@


1.106
log
@Some more long lines.
@
text
@d1 1
a1 1
/* $OpenBSD: window-copy.c,v 1.105 2014/04/11 19:35:54 nicm Exp $ */
d779 1
a779 1
		if ((pb = paste_get_top(&global_buffers)) == NULL)
d1468 2
a1469 2
		paste_add(&global_buffers, buf, len, limit);
	} else if (paste_replace(&global_buffers, idx, buf, len) != 0)
d1527 1
a1527 1
	if (idx == 0 && paste_get_top(&global_buffers) == NULL) {
d1529 1
a1529 1
		paste_add(&global_buffers, buf, len, limit);
d1533 1
a1533 1
	pb = paste_get_index(&global_buffers, idx);
d1541 1
a1541 1
	if (paste_replace(&global_buffers, idx, buf, len) != 0)
@


1.105
log
@Don't blindly increase offsets by the return value of snprintf, if there
wasn't enough space this will go off the end. Instead clamp to the
available space. Fixes crash reported by Julien Rebetez.
@
text
@d1 1
a1 1
/* $OpenBSD: window-copy.c,v 1.104 2014/04/03 08:20:29 nicm Exp $ */
d2036 2
a2037 1
window_copy_cursor_next_word_end(struct window_pane *wp, const char *separators)
d2088 2
a2089 1
window_copy_cursor_previous_word(struct window_pane *wp, const char *separators)
@


1.104
log
@Work out mouse scroll wheel effect when the mouse is first detected and
store it in struct mouse_event, reduce the scroll size the 3 but allow
shift to reduce it to 1 and meta and ctrl to multiply by 3 if the
terminal supports them, also support wheel in choose mode. From Marcel
Partap.
@
text
@d1 1
a1 1
/* $OpenBSD: window-copy.c,v 1.103 2014/03/31 21:39:31 nicm Exp $ */
d1197 2
a1198 2
		if (limit > screen_size_x(s))
			limit = screen_size_x(s);
d1211 6
a1216 4
	screen_write_cursormove(ctx, xoff, py);
	screen_write_copy(ctx, data->backing, xoff,
	    (screen_hsize(data->backing) - data->oy) + py,
	    screen_size_x(s) - size, 1);
@


1.103
log
@Add setb -a to append and a copy mode append command, from J Raynor with
minor changes.
@
text
@d1 1
a1 1
/* $OpenBSD: window-copy.c,v 1.102 2014/02/17 23:07:03 nicm Exp $ */
d874 2
a875 2
		if (m->wheel == MOUSE_WHEEL_UP) {
			for (i = 0; i < 5; i++)
d877 1
a877 2
		} else if (m->wheel == MOUSE_WHEEL_DOWN) {
			for (i = 0; i < 5; i++)
d879 8
a886 6
			/*
			 * We reached the bottom, leave copy mode,
			 * but only if no selection is in progress.
			 */
			if (data->oy == 0 && !s->sel.flag)
			    goto reset_mode;
@


1.102
log
@Fix memory leaks with paste_replace, based on changes from J Raynor.
@
text
@d1 1
a1 1
/* $OpenBSD: window-copy.c,v 1.101 2014/01/28 23:07:09 nicm Exp $ */
d61 1
d418 7
d1500 40
@


1.101
log
@Allow replacing each of the many sets of separate foo-{fg,bg,attr}
options with a single foo-style option. For example:

    set -g status-fg yellow
    set -g status-bg red
    set -g status-attr blink

Becomes:

    set -g status-style fg=yellow,bg=red,blink

The -a flag to set can be used to add to rather than replace a style. So:

    set -g status-bg red

Becomes:

    set -ag status-style bg=red

Currently this is fully backwards compatible (all *-{fg,bg,attr} options
remain) but the plan is to deprecate them over time.

From Tiago Cunha.
@
text
@d1 1
a1 1
/* $OpenBSD: window-copy.c,v 1.100 2014/01/22 22:32:15 nicm Exp $ */
d1458 2
a1459 2
	} else
		paste_replace(&global_buffers, idx, buf, len);
@


1.100
log
@Support paste key in copy mode input (for search etc). Also clamp length
to screen width.
@
text
@d1 1
a1 1
/* $OpenBSD: window-copy.c,v 1.99 2014/01/22 13:57:49 nicm Exp $ */
d1176 1
a1176 1
	window_mode_attrs(&gc, oo);
d1293 1
a1293 1
	window_mode_attrs(&gc, oo);
@


1.99
log
@Only exit copy mode at the bottom if no selection in progress, from
Benoit Pierre.
@
text
@d1 1
a1 1
/* $OpenBSD: window-copy.c,v 1.98 2013/11/20 17:01:23 deraadt Exp $ */
d753 1
a753 1
	size_t				 inputlen;
d755 2
d770 14
d1173 2
a1174 2
	char				 hdr[32];
	size_t				 last, xoff = 0, size = 0;
d1187 3
d1191 1
a1191 1
			xoff = size = xsnprintf(hdr, sizeof hdr,
d1194 1
a1194 1
			xoff = size = xsnprintf(hdr, sizeof hdr,
@


1.98
log
@missing unsigned char casts areound tolower()
ok nicm
@
text
@d1 1
a1 1
/* $OpenBSD: window-copy.c,v 1.97 2013/11/09 00:48:57 nicm Exp $ */
d856 6
a861 2
			if (data->oy == 0)
				goto reset_mode;
@


1.97
log
@Support case insensitive searching in the same manner as emacs - all
lowercase means case insensitive, any uppercase means case
sensitive. From J Raynor.
@
text
@d1 1
a1 1
/* $OpenBSD: window-copy.c,v 1.96 2013/11/08 12:39:20 nicm Exp $ */
d1033 1
a1033 1
		if (*ptr != tolower(*ptr)) {
d1100 1
a1100 1
		if (*ptr != tolower(*ptr)) {
@


1.96
log
@Correctly redraw the top two lines in copy mode when they are selected -
the selection was being updated before the redraw so the markings were
lost. Based on a fix from J Raynor.
@
text
@d1 1
a1 1
/* $OpenBSD: window-copy.c,v 1.95 2013/10/23 11:31:03 nicm Exp $ */
d21 1
d45 1
a45 1
	    struct grid *, u_int, u_int, struct grid *, u_int);
d47 1
a47 1
	    struct grid *, struct grid *, u_int *, u_int, u_int, u_int);
d49 1
a49 1
	    struct grid *, struct grid *, u_int *, u_int, u_int, u_int);
d925 1
a925 1
    struct grid *gd, u_int px, u_int py, struct grid *sgd, u_int spx)
d937 4
d946 1
a946 1
    struct grid *sgd, u_int *ppx, u_int py, u_int first, u_int last)
d949 1
d956 3
a958 1
			if (!window_copy_search_compare(gd, px, py, sgd, bx))
d971 1
a971 1
    struct grid *sgd, u_int *ppx, u_int py, u_int first, u_int last)
d974 1
d981 3
a983 1
			if (!window_copy_search_compare(gd, px, py, sgd, bx))
d1004 2
a1005 1
	int				 utf8flag, n, wrapped, wrapflag;
d1031 8
d1045 1
a1045 1
		n = window_copy_search_rl(gd, sgd, &px, i - 1, 0, last);
d1071 2
a1072 1
	int				 utf8flag, n, wrapped, wrapflag;
d1098 8
d1112 2
a1113 1
		n = window_copy_search_lr(gd, sgd, &px, i - 1, first, gd->sx);
@


1.95
log
@Key to swap to other end of selection (bound to o with vi keys), from J
Raynor.
@
text
@d1 1
a1 1
/* $OpenBSD: window-copy.c,v 1.94 2013/07/12 09:52:36 nicm Exp $ */
d54 1
a54 1
int	window_copy_update_selection(struct window_pane *);
d332 1
a332 1
	window_copy_update_selection(wp);
d461 1
a461 1
		window_copy_update_selection(wp);
d472 1
a472 1
		window_copy_update_selection(wp);
d483 1
a483 1
		window_copy_update_selection(wp);
d489 1
a489 1
		window_copy_update_selection(wp);
d495 1
a495 1
		window_copy_update_selection(wp);
d501 1
a501 1
		window_copy_update_selection(wp);
d508 1
a508 1
		window_copy_update_selection(wp);
d515 1
a515 1
		window_copy_update_selection(wp);
d868 1
a868 1
			if (window_copy_update_selection(wp))
d918 1
a918 1
	window_copy_update_selection(wp);
d1111 1
a1111 1
	window_copy_update_selection(wp);
d1224 1
a1224 1
	window_copy_update_selection(wp);
d1228 1
a1228 1
window_copy_update_selection(struct window_pane *wp)
d1263 1
a1263 1
	if (data->rectflag) {
d1567 1
a1567 1
	if (window_copy_update_selection(wp))
d1592 1
a1592 1
	if (window_copy_update_selection(wp))
d1622 1
a1622 1
	if (window_copy_update_selection(wp))
d1669 1
a1669 1
		if (window_copy_update_selection(wp))
d1692 1
a1692 1
		if (window_copy_update_selection(wp))
d1722 1
a1722 1
		if (window_copy_update_selection(wp)) {
d1760 1
a1760 1
		if (window_copy_update_selection(wp))
d1792 1
a1792 1
			if (window_copy_update_selection(wp))
d1821 1
a1821 1
			if (window_copy_update_selection(wp))
d1850 1
a1850 1
			if (window_copy_update_selection(wp))
d1879 1
a1879 1
			if (window_copy_update_selection(wp))
d1927 1
a1927 1
	if (window_copy_update_selection(wp))
d1977 1
a1977 1
	if (window_copy_update_selection(wp))
d2015 1
a2015 1
	if (window_copy_update_selection(wp))
d2032 2
d2043 1
a2043 2
	if (s->sel.flag && screen_size_y(s) > ny) {
		window_copy_update_selection(wp);
a2044 1
	}
a2045 1
	window_copy_update_selection(wp);
d2065 2
d2071 1
a2071 2
	if (s->sel.flag && screen_size_y(s) > ny) {
		window_copy_update_selection(wp);
d2073 1
a2073 1
	} else if (ny == 1) /* nuke position */
a2075 1
	window_copy_update_selection(wp);
d2092 1
a2092 1
	window_copy_update_selection(wp);
@


1.94
log
@Make next-word-end work properly with vi(1) keys, reported by patrick
keshishian.
@
text
@d1 1
a1 1
/* $OpenBSD: window-copy.c,v 1.93 2013/07/05 14:44:06 nicm Exp $ */
d68 1
d419 4
d1624 33
@


1.93
log
@Whitespace nits, from Ben Boeckel.
@
text
@d1 1
a1 1
/* $OpenBSD: window-copy.c,v 1.92 2013/07/05 14:41:36 nicm Exp $ */
d1900 1
a1900 1
	int				 expected = 1;
d1907 4
d1935 1
a1935 2
	/* Back up to the end-of-word like vi. */
	if (options_get_number(oo, "status-keys") == MODEKEY_VI && px != 0)
@


1.92
log
@Act like vi(1) when moving words, from Ben Boeckel.
@
text
@d1 1
a1 1
/* $OpenBSD: window-copy.c,v 1.91 2013/03/25 11:43:33 nicm Exp $ */
d1119 1
a1119 1
	size_t	 			 last, xoff = 0, size = 0;
@


1.91
log
@Create a new context when copying instead of using the input
context. The input context may not exist yet. Fixes crash when copying
from config file errors.
@
text
@d1 1
a1 1
/* $OpenBSD: window-copy.c,v 1.90 2013/03/25 11:43:01 nicm Exp $ */
d1897 1
d1930 4
@


1.90
log
@Extend jobs to support writing and use that for copy-pipe instead of
popen, from Chris Johnsen.
@
text
@d1 1
a1 1
/* $OpenBSD: window-copy.c,v 1.89 2013/03/22 15:52:42 nicm Exp $ */
d1388 2
a1389 1
	u_int	limit;
d1391 5
a1395 2
	if (options_get_number(&global_options, "set-clipboard"))
		screen_write_setselection(&wp->ictx.ctx, buf, len);
@


1.89
log
@Add copy-pipe mode command to copy selection and also pipe to a command.
@
text
@d1 1
a1 1
/* $OpenBSD: window-copy.c,v 1.88 2013/03/22 10:31:22 nicm Exp $ */
d57 2
a58 1
void	window_copy_copy_pipe(struct window_pane *, int, const char *);
d543 1
a543 1
			window_copy_copy_pipe(wp, data->numprefix, arg);
d1401 2
a1402 1
window_copy_copy_pipe(struct window_pane *wp, int idx, const char *arg)
d1404 4
a1407 3
	void*	buf;
	size_t	len;
	FILE*	f;
d1413 2
a1414 5
	f = popen(arg, "w");
	if (f != NULL) {
		fwrite(buf, 1, len, f);
		pclose(f);
	}
@


1.88
log
@No more lint means no more ARGSUSED.
@
text
@d1 1
a1 1
/* $OpenBSD: window-copy.c,v 1.87 2013/02/05 11:08:59 nicm Exp $ */
d55 3
d370 1
d412 1
a412 1
	cmd = mode_key_lookup(&data->mdata, key);
d540 7
d749 1
a749 1
	switch (mode_key_lookup(&data->mdata, key)) {
d1273 2
a1274 2
void
window_copy_copy_selection(struct window_pane *wp, int idx)
d1280 1
a1280 1
	u_int				 i, xx, yy, sx, sy, ex, ey, limit;
d1285 1
a1285 1
		return;
d1378 1
a1378 1
		return;
d1380 8
a1387 1
	off--;	/* remove final \n */
d1390 1
a1390 1
		screen_write_setselection(&wp->ictx.ctx, buf, off);
a1391 1
	/* Add the buffer to the stack. */
d1394 1
a1394 1
		paste_add(&global_buffers, buf, off, limit);
d1396 34
a1429 1
		paste_replace(&global_buffers, idx, buf, off);
@


1.87
log
@Automatically reflow wrapped lines when a pane is resized, requested by
many over the years and finally implemented by Richard Woodbury.
@
text
@d1 1
a1 1
/* $OpenBSD: window-copy.c,v 1.86 2013/01/18 02:16:21 nicm Exp $ */
a816 1
/* ARGSUSED */
@


1.86
log
@Rather than having two grids for each pane, one for ASCII and one for
UTF-8, collapse the two together. Simplifies the code at the expense of
more memory (which can probably be reduced again later).
@
text
@d1 1
a1 1
/* $OpenBSD: window-copy.c,v 1.85 2012/11/27 14:42:56 nicm Exp $ */
d338 1
a338 1
	screen_resize(s, sx, sy);
d340 1
a340 1
		screen_resize(data->backing, sx, sy);
@


1.85
log
@When scrolling in copy mode with the mouse, scroll screen rather than
moving cursor. This change from Ailin Nemui, alternative to a change
from Stephen Hicks.
@
text
@d1 1
a1 1
/* $OpenBSD: window-copy.c,v 1.84 2012/10/26 14:35:42 nicm Exp $ */
d911 1
a911 1
	const struct grid_utf8	*gu, *sgu;
d914 1
d916 1
d918 1
a918 1
	if ((gc->flags & GRID_FLAG_UTF8) != (sgc->flags & GRID_FLAG_UTF8))
d920 1
a920 11

	if (gc->flags & GRID_FLAG_UTF8) {
		gu = grid_peek_utf8(gd, px, py);
		sgu = grid_peek_utf8(sgd, spx, 0);
		if (grid_utf8_compare(gu, sgu))
			return (1);
	} else {
		if (gc->data == sgc->data)
			return (1);
	}
	return (0);
a1389 1
	const struct grid_utf8		*gu;
d1391 1
a1392 1
	size_t				 size;
d1420 5
a1424 9
			if (!(gc->flags & GRID_FLAG_UTF8)) {
				*buf = xrealloc(*buf, 1, (*off) + 1);
				(*buf)[(*off)++] = gc->data;
			} else {
				gu = grid_peek_utf8(gd, i, sy);
				size = grid_utf8_size(gu);
				*buf = xrealloc(*buf, 1, (*off) + size);
				*off += grid_utf8_copy(gu, *buf + *off, size);
			}
d1454 1
d1457 2
a1458 1
	if (gc->flags & (GRID_FLAG_PADDING|GRID_FLAG_UTF8))
d1460 1
a1460 1
	if (gc->data == 0x00 || gc->data == 0x7f)
d1462 1
a1462 1
	return (strchr(set, gc->data) != NULL);
d1471 1
d1485 2
a1486 3
		if (gc->flags & GRID_FLAG_UTF8)
			break;
		if (gc->data != ' ')
d1519 1
d1527 2
a1528 3
		if (gc->flags & GRID_FLAG_UTF8)
			break;
		if (gc->data != ' ')
d1688 1
d1697 3
a1699 3
		if ((gc->flags & (GRID_FLAG_PADDING|GRID_FLAG_UTF8)) == 0
		    && gc->data == data->jumpchar) {

d1715 1
d1726 3
a1728 3
		if ((gc->flags & (GRID_FLAG_PADDING|GRID_FLAG_UTF8)) == 0
		    && gc->data == data->jumpchar) {

d1746 1
d1755 3
a1757 3
		if ((gc->flags & (GRID_FLAG_PADDING|GRID_FLAG_UTF8)) == 0
		    && gc->data == data->jumpchar) {

d1773 1
d1784 3
a1786 3
		if ((gc->flags & (GRID_FLAG_PADDING|GRID_FLAG_UTF8)) == 0
		    && gc->data == data->jumpchar) {

@


1.84
log
@Make mouse event structure clearer by defining events (up, click, drag)
and simplifying how buttons and wheels are represented, from Ailin
Nemui. Should be no functional changes.
@
text
@d1 1
a1 1
/* $OpenBSD: window-copy.c,v 1.83 2012/09/25 07:39:28 nicm Exp $ */
d835 1
a835 1
				window_copy_cursor_up(wp, 0);
d838 1
a838 1
				window_copy_cursor_down(wp, 0);
@


1.83
log
@Fix search forward so it can match strings on the last line, SF bug
3571114 from "LiJunLe".
@
text
@d1 1
a1 1
/* $OpenBSD: window-copy.c,v 1.82 2012/08/11 06:45:33 nicm Exp $ */
d832 2
a833 2
	if ((m->b & MOUSE_45)) {
		if ((m->b & MOUSE_BUTTON) == MOUSE_1) {
d836 1
a836 1
		} else if ((m->b & MOUSE_BUTTON) == MOUSE_2) {
d850 1
a850 1
		if ((m->b & MOUSE_BUTTON) != MOUSE_UP) {
d860 1
a860 1
	if ((m->b & MOUSE_BUTTON) != MOUSE_UP) {
@


1.82
log
@Instead of numbering choose mode items 0-9a-z and then nothing, number
them all and if there are more than 10 use a prompt when 0-9 is
pressed. From Thomas Adam.
@
text
@d1 1
a1 1
/* $OpenBSD: window-copy.c,v 1.81 2012/07/10 11:53:01 nicm Exp $ */
d1071 1
a1071 1
	for (i = fy + 1; i < gd->hsize + gd->sy; i++) {
@


1.81
log
@xfree is not particularly helpful, remove it. From Thomas Adam.
@
text
@d1 1
a1 1
/* $OpenBSD: window-copy.c,v 1.80 2012/04/01 20:53:47 nicm Exp $ */
d1118 1
a1118 4
	memcpy(&gc, &grid_default_cell, sizeof gc);
	colour_set_fg(&gc, options_get_number(oo, "mode-fg"));
	colour_set_bg(&gc, options_get_number(oo, "mode-bg"));
	gc.attr |= options_get_number(oo, "mode-attr");
d1232 1
a1232 4
	memcpy(&gc, &grid_default_cell, sizeof gc);
	colour_set_fg(&gc, options_get_number(oo, "mode-fg"));
	colour_set_bg(&gc, options_get_number(oo, "mode-bg"));
	gc.attr |= options_get_number(oo, "mode-attr");
@


1.80
log
@Minor style nits - return ().
@
text
@d1 1
a1 1
/* $OpenBSD: window-copy.c,v 1.79 2012/04/01 09:23:31 nicm Exp $ */
d243 2
a244 3
	if (data->searchstr != NULL)
		xfree(data->searchstr);
	xfree(data->inputstr);
d248 1
a248 1
		xfree(data->backing);
d252 1
a252 1
	xfree(data);
d1381 1
a1381 1
		xfree(buf);
@


1.79
log
@Only exit mouse mode on scroll wheel when actually reaching the end of
the history, from James Nylen.
@
text
@d1 1
a1 1
/* $OpenBSD: window-copy.c,v 1.78 2012/03/17 21:40:53 nicm Exp $ */
d808 1
a808 1
		return 1;
d811 1
a811 1
		return 0;
d815 1
a815 1
	return 0;
@


1.78
log
@Add a wrap-search option to turn off wrapping of searches in copy
mode. From Jacobo de Vera.
@
text
@d1 1
a1 1
/* $OpenBSD: window-copy.c,v 1.77 2012/03/11 23:01:19 nicm Exp $ */
d825 1
a825 1
	u_int				 i, old_cy;
a837 1
			old_cy = data->cy;
d840 1
a840 1
			if (old_cy == data->cy)
@


1.77
log
@Always remember last cursor position when moving up or down, not just
for if crossing zero length lines. From Itay Perl.
@
text
@d1 1
a1 1
/* $OpenBSD: window-copy.c,v 1.76 2011/12/04 16:18:01 nicm Exp $ */
d987 1
a987 1
	int				 utf8flag, n, wrapped;
d992 1
d1025 1
a1025 1
	if (!n && !wrapped) {
d1045 1
a1045 1
	int				 utf8flag, n, wrapped;
d1050 1
d1083 1
a1083 1
	if (!n && !wrapped) {
@


1.76
log
@Support "jump to" like vi in copy mode using t and T keys. Also add x
and X for delete in edit mode.

From Ben Boeckel, thanks.
@
text
@d1 1
a1 1
/* $OpenBSD: window-copy.c,v 1.75 2011/11/15 23:24:04 nicm Exp $ */
d1632 1
a1632 1
	if (ox != 0) {
d1674 1
a1674 1
	if (ox != 0) {
@


1.75
log
@Move word-separators to be a session rather than window option, from Ben
Boeckel.
@
text
@d1 1
a1 1
/* $OpenBSD: window-copy.c,v 1.74 2011/10/23 23:38:16 nicm Exp $ */
d70 2
d95 2
d139 1
a139 1
	char   	       *inputstr;
d374 3
a376 1
	    data->inputtype == WINDOW_COPY_JUMPBACK) {
d383 1
a383 1
			}  else {
d386 6
d596 6
d611 6
d625 12
d652 2
d760 2
d1745 56
@


1.74
log
@When copying, make repeat count indicate buffer to replace if used.
@
text
@d1 1
a1 1
/* $OpenBSD: window-copy.c,v 1.73 2011/06/27 00:04:49 nicm Exp $ */
d551 1
a551 1
		    options_get_string(&wp->window->options, "word-separators");
d557 1
a557 1
		    options_get_string(&wp->window->options, "word-separators");
d567 1
a567 1
		    options_get_string(&wp->window->options, "word-separators");
@


1.73
log
@PANE_FREEZE doesn't do anything anymore, so remove it.
@
text
@d1 1
a1 1
/* $OpenBSD: window-copy.c,v 1.72 2011/05/18 20:24:29 nicm Exp $ */
d55 1
a55 1
void	window_copy_copy_selection(struct window_pane *);
d137 1
a137 1
	u_int		numprefix;
d168 1
a168 1
	data->numprefix = 0;
d361 2
a362 2
	u_int				 n, np;
	int				 keys;
d366 1
a366 1
	if (np == 0)
d516 1
a516 1
			window_copy_copy_selection(wp);
d527 1
a527 1
			window_copy_copy_selection(wp);
d667 1
a667 1
	data->numprefix = 0;
d699 1
a699 1
	u_int				 np;
d703 1
a703 1
		data->numprefix = 0;
d715 1
a715 1
		if (np == 0)
d741 1
a741 1
		data->numprefix = 0;
d770 1
a770 1
	if (data->numprefix >= 100)	/* no more than three digits */
d837 1
a837 1
		window_copy_copy_selection(wp);
d1238 1
a1238 1
window_copy_copy_selection(struct window_pane *wp)
d1318 1
a1318 1
		else	
d1350 5
a1354 2
	limit = options_get_number(&global_options, "buffer-limit");
	paste_add(&global_buffers, buf, off, limit);
@


1.72
log
@Support setting the xterm clipboard when copying from copy mode using
the xterm escape sequence for the purpose (if xterm is configured to
allow it).

Written by and much discussed Ailin Nemui, guidance on
xterm/termcap/terminfo from Thomas Dickey.
@
text
@d1 1
a1 1
/* $OpenBSD: window-copy.c,v 1.71 2011/05/18 18:06:36 nicm Exp $ */
a172 1
	wp->flags |= PANE_FREEZE;
a235 1
	wp->flags &= ~PANE_FREEZE;
@


1.71
log
@Add three new copy-mode commands - select-line, copy-line,
copy-end-of-line. From Dave Disser and Randy Stauner a while back.
@
text
@d1 1
a1 1
/* $OpenBSD: window-copy.c,v 1.70 2011/05/18 08:04:47 nicm Exp $ */
d1347 3
@


1.70
log
@Use button mouse mode not any for copy mode, fixes issues with
putty. From Ailin Nemui.
@
text
@d1 1
a1 1
/* $OpenBSD: window-copy.c,v 1.69 2011/04/24 21:06:12 nicm Exp $ */
d502 20
@


1.69
log
@Tweak copy behaviour slightly in vi mode to be closer to real vi. From
Tiago Resende.
@
text
@d1 1
a1 1
/* $OpenBSD: window-copy.c,v 1.68 2011/04/19 21:31:33 nicm Exp $ */
d793 1
a793 1
	if (s->mode & MODE_MOUSE_ANY) {
d806 1
a806 1
		s->mode |= MODE_MOUSE_ANY;
d816 1
a816 1
	s->mode &= ~MODE_MOUSE_ANY;
@


1.68
log
@When mode-mouse is on (it is off by default), automatically enter copy
mode when the mouse is dragged or the mouse wheel is used. Also exit
copy mode when the mouse wheel is scrolled off the bottom. Discussed
with and written by hsim at gmx dot li.
@
text
@d1 1
a1 1
/* $OpenBSD: window-copy.c,v 1.67 2011/03/28 19:44:31 nicm Exp $ */
d1228 1
d1265 8
d1280 8
a1287 2
			lastex = data->cx;
			restex = data->cx;
d1298 4
a1301 5
		/*
		 * Like emacs, keep the top-left-most character, and drop the
		 * bottom-right-most, regardless of copy direction.
		 */
		lastex = ex;
@


1.67
log
@Style: uint -> u_int and a missing else.
@
text
@d1 1
a1 1
/* $OpenBSD: window-copy.c,v 1.66 2010/12/30 23:16:18 nicm Exp $ */
d763 1
a763 1
    struct window_pane *wp, unused struct session *sess, struct mouse_event *m)
d767 1
a767 1
	u_int				 i;
d780 1
d783 2
d798 1
a798 7
		} else {
			s->mode &= ~MODE_MOUSE_ANY;
			s->mode |= MODE_MOUSE_STANDARD;
			if (sess != NULL) {
				window_copy_copy_selection(wp);
				window_pane_reset_mode(wp);
			}
d800 1
a800 1
		return;
d811 10
@


1.66
log
@Change from a per-session stack of buffers to one global stack which is
much more convenient and also simplifies lot of code. This renders
copy-buffer useless and makes buffer-limit now a server option.

By Tiago Cunha.
@
text
@d1 1
a1 1
/* $OpenBSD: window-copy.c,v 1.65 2010/12/29 21:49:06 nicm Exp $ */
d371 2
a372 2
	if (data->inputtype == WINDOW_COPY_JUMPFORWARD
	    || data->inputtype == WINDOW_COPY_JUMPBACK) {
d388 1
a388 1
	} if (data->inputtype == WINDOW_COPY_NUMERICPREFIX) {
d1620 1
a1620 1
	uint				 px, py, xx;
d1646 1
a1646 1
	uint				 px, py;
@


1.65
log
@Support all four of the xterm mouse modes. Based on a diff from hsim at
gmx.li.
@
text
@d1 1
a1 1
/* $OpenBSD: window-copy.c,v 1.64 2010/12/11 17:56:01 nicm Exp $ */
d55 1
a55 1
void	window_copy_copy_selection(struct window_pane *, struct session *);
d509 1
a509 1
			window_copy_copy_selection(wp, sess);
d799 1
a799 1
				window_copy_copy_selection(wp, sess);
d1213 1
a1213 1
window_copy_copy_selection(struct window_pane *wp, struct session *sess)
d1308 2
a1309 2
	limit = options_get_number(&sess->options, "buffer-limit");
	paste_add(&sess->buffers, buf, off, limit);
@


1.64
log
@Fix rectangle copy to behave like emacs - the cursor is not part of the
selection on the right edge but on the left it is.
@
text
@d1 1
a1 1
/* $OpenBSD: window-copy.c,v 1.63 2010/09/11 15:39:55 nicm Exp $ */
d183 1
a183 1
		s->mode |= MODE_MOUSE;
d790 1
a790 1
	if (s->mode & MODE_MOUSEMOTION) {
d796 2
a797 1
			s->mode &= ~MODE_MOUSEMOTION;
d806 1
a806 1
	/* Otherwise i other buttons pressed, start selection and motion. */
d808 2
a809 1
		s->mode |= MODE_MOUSEMOTION;
@


1.63
log
@When resizing the copy mode screen, don't allow it to end up with the
viewable position beyond the size of the history.
@
text
@d1 1
a1 1
/* $OpenBSD: window-copy.c,v 1.62 2010/09/08 20:36:42 nicm Exp $ */
d1270 2
a1271 2
			firstsx = data->cx + 1;
			restsx = data->cx + 1;
@


1.62
log
@Do not crash if the screen size is too small for the indicator in copy mode.
@
text
@d1 1
a1 1
/* $OpenBSD: window-copy.c,v 1.61 2010/07/22 21:10:51 nicm Exp $ */
d345 2
@


1.61
log
@Fix a crash: if remain-on-exit is set and the pane has exited, the
buffers may not be valid, so do not try to disable/enable them when
switching to copy mode.
@
text
@d1 1
a1 1
/* $OpenBSD: window-copy.c,v 1.60 2010/06/29 05:24:49 tedu Exp $ */
d1058 2
@


1.60
log
@replace some magic mouse constants with defines for clarity. ok nicm
@
text
@d1 1
a1 1
/* $OpenBSD: window-copy.c,v 1.59 2010/06/06 19:00:13 nicm Exp $ */
d174 2
a175 1
	bufferevent_disable(wp->event, EV_READ|EV_WRITE);
d238 2
a239 1
	bufferevent_enable(wp->event, EV_READ|EV_WRITE);
@


1.59
log
@Use a macro-based mask for obtaining a key or modifier-set from the
combination. Display C-@@, etc, as C-Space, in list-keys. By Micah Cowan.
@
text
@d1 1
a1 1
/* $OpenBSD: window-copy.c,v 1.58 2010/06/05 15:49:48 nicm Exp $ */
a764 9
	/*
	 * xterm mouse mode is fairly silly. Buttons are in the bottom two
	 * bits: 0 button 1; 1 button 2; 2 button 3; 3 buttons released.
	 *
	 * Bit 3 is shift; bit 4 is meta; bit 5 control.
	 *
	 * Bit 6 is added for mouse buttons 4 and 5.
	 */

d771 2
a772 2
	if ((m->b & 64) == 64) {
		if ((m->b & 3) == 0) {
d775 1
a775 1
		} else if ((m->b & 3) == 1) {
d787 1
a787 1
		if ((m->b & 3) != 3) {
d802 1
a802 1
	if ((m->b & 3) != 3) {
@


1.58
log
@Make start-of-line work the same as end-of-line on wrapped lines (jump
to real start if at edge of screen). By Micah Cowan.
@
text
@d1 1
a1 1
/* $OpenBSD: window-copy.c,v 1.57 2010/05/31 19:51:29 nicm Exp $ */
d370 1
a370 1
		if ((key & 0xff00) == 0) {
d630 1
a630 1
		key &= 0xff;
d744 1
a744 1
	key &= 0xff;
@


1.57
log
@When the mode-mouse option is on, support dragging to make a selection
in copy mode.

Also support the scroll wheel, although xterm strangely does not ignore
it in application mouse mode, causing redraw artifacts when scrolling up
(other terminals appear to be better behaved).
@
text
@d1 1
a1 1
/* $OpenBSD: window-copy.c,v 1.56 2010/05/23 19:42:19 nicm Exp $ */
d1430 11
a1440 1

@


1.56
log
@Pass in the session, rather than the client, to window modes' key()
function. We were only ever using the client to find the session anyway.

This allows send-key to work properly for manipulating copy mode from
outside tmux.

From Micah Cowan.
@
text
@d1 1
a1 1
/* $OpenBSD: window-copy.c,v 1.55 2010/04/28 18:19:16 nicm Exp $ */
d763 10
a773 2
	if ((m->b & 3) == 3)
		return;
d779 37
a815 2
	window_copy_update_cursor(wp, m->x, m->y);
	if (window_copy_update_selection(wp))
d817 1
@


1.55
log
@Fix crash when resizing in copy mode, when cursor can end up outside screen.

Reported by Romain Francois, fixed by Micah Cowan.
@
text
@d1 1
a1 1
/* $OpenBSD: window-copy.c,v 1.54 2010/04/06 21:35:44 nicm Exp $ */
d29 1
a29 1
void	window_copy_key(struct window_pane *, struct client *, int);
d33 1
a33 1
	    struct window_pane *, struct client *, struct mouse_event *);
d55 1
a55 1
void	window_copy_copy_selection(struct window_pane *, struct client *);
a342 2
	if (data->oy > screen_hsize(data->backing))
		data->oy = screen_hsize(data->backing);
d354 1
a354 1
window_copy_key(struct window_pane *wp, struct client *c, int key)
d504 2
a505 2
		if (c != NULL && c->session != NULL) {
			window_copy_copy_selection(wp, c);
d759 1
a759 1
    struct window_pane *wp, unused struct client *c, struct mouse_event *m)
d1170 1
a1170 1
window_copy_copy_selection(struct window_pane *wp, struct client *c)
d1265 2
a1266 2
	limit = options_get_number(&c->session->options, "buffer-limit");
	paste_add(&c->session->buffers, buf, off, limit);
@


1.54
log
@Merge copy mode and output mode, dropping the latter. Idea and code from
Micah Cowan.
@
text
@d1 1
a1 1
/* $OpenBSD: window-copy.c,v 1.53 2010/03/22 19:13:28 nicm Exp $ */
d343 2
@


1.53
log
@paste-buffer should be per pane, from C. Coutinho.
@
text
@d1 1
a1 1
/* $OpenBSD$ */
d96 16
d115 3
a150 2
	struct screen_write_ctx	 	 ctx;
	u_int				 i;
d155 2
a156 2
	data->cx = wp->base.cx;
	data->cy = wp->base.cy;
d161 2
d190 20
d218 1
d220 9
a228 1
	return (s);
d243 4
d253 58
d320 2
a321 2
	if (data->oy + n > screen_hsize(&wp->base))
		data->oy = screen_hsize(&wp->base);
d336 2
d444 2
a445 2
			if (data->oy + n > screen_hsize(&wp->base))
				data->oy = screen_hsize(&wp->base);
d484 1
a484 1
		data->oy = screen_hsize(&wp->base);
d780 1
a780 2
	struct screen			*s = &wp->base;
	struct grid			*gd = s->grid;
d875 1
a875 1
	struct screen			*s = &wp->base, ss;
d932 1
a932 1
	struct screen			*s = &wp->base, ss;
d992 1
a992 1
	lineno = strtonum(linestr, 0, screen_hsize(&wp->base), &errstr);
d1020 1
a1020 1
		    "[%u/%u]", data->oy, screen_hsize(&wp->base));
d1037 3
a1039 2
	screen_write_copy(ctx, &wp->base, xoff, (screen_hsize(&wp->base) -
	    data->oy) + py, screen_size_x(s) - size, 1);
d1108 1
a1108 1
	data->sely = screen_hsize(&wp->base) + data->cy - data->oy;
d1133 1
a1133 1
	ty = screen_hsize(&wp->base) - data->oy;
d1194 1
a1194 1
	yy = screen_hsize(&wp->base) + data->cy - data->oy;
d1273 7
a1279 6
	struct grid		*gd = wp->base.grid;
	const struct grid_cell	*gc;
	const struct grid_utf8	*gu;
	struct grid_line	*gl;
	u_int			 i, xx, wrapped = 0;
	size_t			 size;
d1334 1
a1334 1
	py = screen_hsize(&wp->base) + data->cy - data->oy;
d1343 2
a1344 1
	const struct grid_cell	*gc;
d1346 1
a1346 1
	gc = grid_peek_cell(wp->base.grid, px, py);
d1357 4
a1360 2
	const struct grid_cell	*gc;
	u_int			 px;
d1368 3
a1370 3
	px = wp->base.grid->linedata[py].cellsize;
	if (px > screen_size_x(&wp->base))
		px = screen_size_x(&wp->base);
d1372 1
a1372 1
		gc = grid_peek_cell(wp->base.grid, px - 1, py);
d1400 1
a1400 1
	py = screen_hsize(&wp->base) + data->cy - data->oy;
d1404 1
a1404 1
		gc = grid_peek_cell(wp->base.grid, px, py);
d1421 2
a1422 2
	struct screen			*base_s = &wp->base;
	struct grid			*gd = base_s->grid;
d1425 1
a1425 1
	py = screen_hsize(base_s) + data->cy - data->oy;
d1430 1
a1430 1
			px = screen_size_x(&wp->base);
d1435 2
a1436 1
				py = screen_hsize(base_s) + data->cy - data->oy;
d1471 1
a1471 1
		py = screen_hsize(&wp->base) + data->cy - data->oy;
d1492 1
a1492 1
	oy = screen_hsize(&wp->base) + data->cy - data->oy;
d1519 1
a1519 1
		py = screen_hsize(&wp->base) + data->cy - data->oy;
d1534 1
a1534 1
	oy = screen_hsize(&wp->base) + data->cy - data->oy;
d1553 1
a1553 1
		py = screen_hsize(&wp->base) + data->cy - data->oy;
d1565 1
a1565 1
	struct screen			*base_s = &wp->base;
d1570 1
a1570 1
	py = screen_hsize(base_s) + data->cy - data->oy;
d1574 1
a1574 1
		gc = grid_peek_cell(base_s->grid, px, py);
d1591 1
a1591 1
	struct screen			*base_s = &wp->base;
d1596 1
a1596 1
	py = screen_hsize(base_s) + data->cy - data->oy;
d1602 1
a1602 1
		gc = grid_peek_cell(base_s->grid, px, py);
d1621 1
a1621 1
	struct screen			*base_s = &wp->base;
d1626 1
a1626 1
	py = screen_hsize(base_s) + data->cy - data->oy;
d1628 1
a1628 1
	yy = screen_hsize(base_s) + screen_size_y(base_s) - 1;
d1646 1
a1646 1
				py = screen_hsize(base_s) + data->cy - data->oy;
d1663 1
a1663 1
	struct screen			*base_s = &wp->base;
d1668 1
a1668 1
	py = screen_hsize(base_s) + data->cy - data->oy;
d1670 1
a1670 1
	yy = screen_hsize(base_s) + screen_size_y(base_s) - 1;
d1688 1
a1688 1
				py = screen_hsize(base_s) + data->cy - data->oy;
d1709 1
a1709 1
	py = screen_hsize(&wp->base) + data->cy - data->oy;
d1719 2
a1720 2
			    (screen_hsize(&wp->base) == 0 ||
			    data->oy >= screen_hsize(&wp->base) - 1))
d1724 1
a1724 1
			py = screen_hsize(&wp->base) + data->cy - data->oy;
d1777 1
a1777 1
	if (ny > screen_hsize(&wp->base))
d1780 2
a1781 2
	if (data->oy > screen_hsize(&wp->base) - ny)
		ny = screen_hsize(&wp->base) - data->oy;
d1808 1
a1808 1
	py = screen_hsize(&wp->base) + data->cy - data->oy;
@


1.52
log
@Add vi-style "jump" commands for copy mode, from Micah Cowan.
@
text
@d1 1
a1 1
/* $Id: window-copy.c,v 1.112 2010/03/16 17:51:32 nicm Exp $ */
@


1.51
log
@Fix a use-after-free when cancelling copy mode, or trying to repeat cancel.

ok kettenis
@
text
@d1 1
a1 1
/* $OpenBSD: window-copy.c,v 1.50 2010/03/02 00:32:41 nicm Exp $ */
d68 2
d91 2
d122 3
d157 3
d255 18
a272 1
	if (data->inputtype == WINDOW_COPY_NUMERICPREFIX) {
d437 30
d480 2
d586 2
d1441 56
@


1.50
log
@Permit keys in copy mode to be prefixed by a repeat count, entered with
[1-9] in vi mode, or M-[1-9] in emacs mode.

From Micah Cowan, tweaked a little by me.
@
text
@d1 1
a1 1
/* $OpenBSD: window-copy.c,v 1.49 2010/03/01 23:53:27 nicm Exp $ */
d259 2
a260 3
		for (; np != 0; np--)
			window_pane_reset_mode(wp);
		break;
d368 1
@


1.49
log
@Extend the end-of-line key so that in normal mode a second press moves
the cursor to the end of a wrapped line (if present) and in rectangle
mode it toggles between the end of the text and the last cell on the
line.

From Micah Cowan.
@
text
@d1 1
a1 1
/* $OpenBSD: window-copy.c,v 1.48 2010/02/22 20:41:16 nicm Exp $ */
d31 1
d86 1
d114 2
d142 1
d237 1
a237 1
	u_int				 n;
d241 10
a250 1
	if (data->inputtype != WINDOW_COPY_OFF) {
d259 2
a260 1
		window_pane_reset_mode(wp);
d263 3
a265 2
		window_copy_cursor_left(wp);
		return;
d267 3
a269 2
		window_copy_cursor_right(wp);
		return;
d271 3
a273 2
		window_copy_cursor_up(wp, 0);
		return;
d275 3
a277 2
		window_copy_cursor_down(wp, 0);
		return;
d279 2
a280 1
		window_copy_cursor_up(wp, 1);
d283 2
a284 1
		window_copy_cursor_down(wp, 1);
d287 2
a288 1
		window_copy_pageup(wp);
d294 6
a299 4
		if (data->oy < n)
			data->oy = 0;
		else
			data->oy -= n;
d305 6
a310 4
		if (data->oy + n > screen_hsize(&wp->base))
			data->oy = screen_hsize(&wp->base);
		else
			data->oy += n;
d316 6
a321 4
		if (data->oy < n)
			data->oy = 0;
		else
			data->oy -= n;
d381 2
a382 1
		window_copy_cursor_next_word(wp, " ");
d385 2
a386 1
		window_copy_cursor_next_word_end(wp, " ");
d391 2
a392 1
		window_copy_cursor_next_word(wp, word_separators);
d397 2
a398 1
		window_copy_cursor_next_word_end(wp, word_separators);
d401 2
a402 1
		window_copy_cursor_previous_word(wp, " ");
d407 2
a408 1
		window_copy_cursor_previous_word(wp, word_separators);
d423 1
d426 11
a436 4
			if (cmd == MODEKEYCOPY_SEARCHAGAIN)
				window_copy_search_up(wp, data->searchstr);
			else
				window_copy_search_down(wp, data->searchstr);
d439 11
a449 4
			if (cmd == MODEKEYCOPY_SEARCHAGAIN)
				window_copy_search_down(wp, data->searchstr);
			else
				window_copy_search_up(wp, data->searchstr);
d458 9
d469 1
a469 1
		return;
d474 1
d506 1
d510 1
d521 4
d527 1
d530 2
a531 1
			window_copy_search_up(wp, data->inputstr);
d536 2
a537 1
			window_copy_search_down(wp, data->inputstr);
d546 1
d565 18
d852 7
a858 2
		xoff = size = xsnprintf(hdr, sizeof hdr,
		    "%s: %s", data->inputprompt, data->inputstr);
@


1.48
log
@Option to set the characters considered word separators in copy mode, from
Micah Cowan.
@
text
@d1 1
a1 1
/* $OpenBSD: window-copy.c,v 1.47 2010/02/22 20:28:21 nicm Exp $ */
d1152 2
d1156 1
a1156 1
	py = screen_hsize(&wp->base) + data->cy - data->oy;
d1159 12
d1172 1
d1251 2
a1252 1
		if (data->cx >= data->lastsx || data->cx > px)
d1285 2
a1286 1
		if (data->cx >= data->lastsx || data->cx > px)
@


1.47
log
@Another copy mode fix from Micah Cowan: in rectangle copy mode, the cursor
should not wrap at the end of the text on the line but should be allowed to
move freely.
@
text
@d1 1
a1 1
/* $OpenBSD: window-copy.c,v 1.46 2010/02/19 00:03:21 nicm Exp $ */
d229 1
a229 1
	const char			*word_separators = " -_@@";
d359 2
d364 2
d372 2
d1280 1
d1287 23
a1309 18
	/* Are we in a word? Skip it! */
	while (!window_copy_in_set(wp, px, py, separators))
		px++;

	/* Find the start of a word. */
	while (px > xx || window_copy_in_set(wp, px, py, separators)) {
		/* Past the end of the line? Nothing but spaces. */
		if (px > xx) {
			if (py == yy)
				return;
			window_copy_cursor_down(wp, 0);
			px = 0;

			py = screen_hsize(base_s) + data->cy - data->oy;
			xx = window_copy_find_length(wp, py);
		} else
			px++;
	}
d1322 1
d1329 23
a1351 18
	/* Are we on spaces? Skip 'em! */
	while (px > xx || window_copy_in_set(wp, px, py, separators)) {
		/* Nothing but spaces past the end of the line, so move down. */
		if (px > xx) {
			if (py == yy)
				return;
			window_copy_cursor_down(wp, 0);
			px = 0;

			py = screen_hsize(base_s) + data->cy - data->oy;
			xx = window_copy_find_length(wp, py);
		} else
			px++;
	}

	/* Find the end of this word. */
	while (!window_copy_in_set(wp, px, py, separators))
		px++;
@


1.46
log
@copy mode uses the real screen as backing and if it is updated while copying,
strange things can happen. So, freeze reading from the pty while in copy mode.
@
text
@d1 1
a1 1
/* $OpenBSD: window-copy.c,v 1.45 2010/02/17 21:27:18 nicm Exp $ */
d55 1
d217 1
a217 1
	screen_clear_selection(&data->screen);
d334 1
a334 1
		screen_clear_selection(&data->screen);
d1054 14
d1177 6
a1182 2
	py = screen_hsize(&wp->base) + data->cy - data->oy;
	px = window_copy_find_length(wp, py);
d1227 6
a1232 4
	py = screen_hsize(&wp->base) + data->cy - data->oy;
	px = window_copy_find_length(wp, py);
	if (data->cx >= data->lastsx || data->cx > px)
		window_copy_cursor_end_of_line(wp);
d1260 6
a1265 4
	py = screen_hsize(&wp->base) + data->cy - data->oy;
	px = window_copy_find_length(wp, py);
	if (data->cx >= data->lastsx || data->cx > px)
		window_copy_cursor_end_of_line(wp);
d1443 1
d1446 5
@


1.45
log
@Make next-word stop at beginning of word even if it is at the start of the
line, from Micah Cowan.
@
text
@d1 1
a1 1
/* $OpenBSD: window-copy.c,v 1.44 2010/02/17 20:58:24 nicm Exp $ */
d141 3
d171 3
@


1.44
log
@Don't strip add newline if only copying part of wrapped line. Problem spotted
by and fix from Micah Cowan.
@
text
@d1 1
a1 1
/* $OpenBSD: window-copy.c,v 1.43 2010/02/11 20:39:40 nicm Exp $ */
d1266 2
a1267 2
		}
		px++;
d1298 2
a1299 2
		}
		px++;
a1419 1

@


1.43
log
@Add "N" key to search the opposite way from the last search (reverse of "n"),
from Micah Cowan.
@
text
@d1 1
a1 1
/* $OpenBSD: window-copy.c,v 1.42 2010/02/06 17:35:01 nicm Exp $ */
d1041 1
a1041 1
	if (!wrapped) {
@


1.42
log
@Rectangle copy support, from Robin Lee Powell.
@
text
@d1 1
a1 1
/* $OpenBSD: window-copy.c,v 1.41 2010/02/04 20:00:26 nicm Exp $ */
d227 1
d235 2
a236 1
	switch (mode_key_lookup(&data->mdata, key)) {
d372 1
d378 4
a381 1
			window_copy_search_up(wp, data->searchstr);
d384 4
a387 1
			window_copy_search_down(wp, data->searchstr);
@


1.41
log
@vi-style B, W and E keys in copy mode to navigate between words treating only
spaces as word separators. Also add . to the list of word separators for
standard word navigation.

From Micah Cowan, tweaked slightly by me.
@
text
@d1 1
a1 1
/* $OpenBSD: window-copy.c,v 1.40 2010/01/27 20:18:52 nicm Exp $ */
d71 1
d99 2
d132 2
d387 3
d834 1
a834 1
	u_int				 sx, sy, ty;
d852 2
a853 1
		sx = 0;
d856 2
a857 1
		sx = screen_size_x(s) - 1;
d863 16
a878 2
	screen_set_selection(
	    s, sx, sy, data->cx, screen_hsize(s) + data->cy, &gc);
d888 3
a890 2
	size_t	 			 off;
	u_int	 			 i, xx, yy, sx, sy, ex, ey, limit;
d921 35
d958 1
a958 1
		window_copy_copy_line(wp, &buf, &off, sy, sx, ex);
d960 1
a960 2
		xx = screen_size_x(s);
		window_copy_copy_line(wp, &buf, &off, sy, sx, xx);
d962 4
a965 2
			for (i = sy + 1; i < ey; i++)
				window_copy_copy_line(wp, &buf, &off, i, 0, xx);
d967 1
a967 1
		window_copy_copy_line(wp, &buf, &off, ey, 0, ex);
a1351 1
	window_copy_update_selection(wp);
d1362 2
a1363 1
	if (s->sel.flag && screen_size_y(s) > ny)
d1365 1
d1367 1
a1385 1
	window_copy_update_selection(wp);
d1391 2
a1392 1
	if (s->sel.flag && screen_size_y(s) > ny)
d1394 1
a1394 1
	else if (ny == 1) /* nuke position */
d1397 1
d1400 12
@


1.40
log
@Alter next-word to have vi-like movement behaviour, and add next-word-end with
the existing emacs behaviour. From Micah Cowan.
@
text
@d1 1
a1 1
/* $OpenBSD: window-copy.c,v 1.39 2010/01/25 22:34:11 nicm Exp $ */
d57 1
a57 1
int	window_copy_is_space(struct window_pane *, u_int, u_int);
d66 3
a68 3
void	window_copy_cursor_next_word(struct window_pane *);
void	window_copy_cursor_next_word_end(struct window_pane *);
void	window_copy_cursor_previous_word(struct window_pane *);
d217 1
d338 6
d345 1
a345 1
		window_copy_cursor_next_word(wp);
d348 4
a351 1
		window_copy_cursor_next_word_end(wp);
d354 1
a354 1
		window_copy_cursor_previous_word(wp);
d978 1
a978 1
window_copy_is_space(struct window_pane *wp, u_int px, u_int py)
a980 1
	const char     		*spaces = " -_@@";
d987 1
a987 1
	return (strchr(spaces, gc->data) != NULL);
a1036 4
	/*
	 * Don't use window_copy_is_space because that treats some word
	 * delimiters as spaces.
	 */
d1170 1
a1170 1
window_copy_cursor_next_word(struct window_pane *wp)
d1182 1
a1182 1
	while (!window_copy_is_space(wp, px, py))
d1186 1
a1186 1
	while (px > xx || window_copy_is_space(wp, px, py)) {
d1206 1
a1206 1
window_copy_cursor_next_word_end(struct window_pane *wp)
d1218 1
a1218 1
	while (px > xx || window_copy_is_space(wp, px, py)) {
d1233 1
a1233 1
	while (!window_copy_is_space(wp, px, py))
d1243 1
a1243 1
window_copy_cursor_previous_word(struct window_pane *wp)
d1255 1
a1255 1
			if (!window_copy_is_space(wp, px, py))
d1270 1
a1270 1
	while (px > 0 && !window_copy_is_space(wp, px - 1, py))
@


1.39
log
@Hugely simplify window_copy_cursor_next_word, which was way overcomplicated.
@
text
@d1 1
a1 1
/* $OpenBSD: window-copy.c,v 1.38 2010/01/25 21:37:40 nicm Exp $ */
d67 1
d340 3
d1166 36
@


1.38
log
@Update the selection properly after goto line or searching.
@
text
@d1 1
a1 1
/* $OpenBSD: window-copy.c,v 1.37 2010/01/25 21:33:39 nicm Exp $ */
d1164 2
a1165 2
	struct screen			*s = &data->screen;
	u_int				 px, py, xx, skip;
d1168 1
a1168 1
	py = screen_hsize(&wp->base) + data->cy - data->oy;
d1170 1
d1172 8
a1179 13
	skip = 1;
	if (px < xx) {
		/* If currently on a space, skip space. */
		if (window_copy_is_space(wp, px, py))
			skip = 0;
	} else
		skip = 0;
	for (;;) {
		if (px >= xx) {
			if (skip) {
				px = xx;
				break;
			}
d1181 2
a1182 23
			while (px >= xx) {
				if (data->cy == screen_size_y(s) - 1) {
					if (data->oy == 0)
						goto out;
				}

				px = 0;
				window_copy_cursor_down(wp, 0);

				py =screen_hsize(
				    &wp->base) + data->cy - data->oy;
				xx = window_copy_find_length(wp, py);
			}
		}

		if (skip) {
			/* Currently skipping non-space (until space). */
			if (window_copy_is_space(wp, px, py))
				break;
		} else {
			/* Currently skipping space (until non-space). */
			if (!window_copy_is_space(wp, px, py))
				skip = 1;
d1184 2
d1187 2
a1189 1
	}
a1190 1
out:
d1219 1
a1219 2
			py = screen_hsize(
			    &wp->base) + data->cy - data->oy;
@


1.37
log
@Top/bottom of history mode keys, diff from Micah Cowan, tweaked by me.
@
text
@d1 1
a1 1
/* $OpenBSD: window-copy.c,v 1.36 2010/01/24 21:05:12 nicm Exp $ */
d495 1
d694 1
@


1.36
log
@Redraw properly when scrolling backward and the cursor is on the last
line. Based on a fix from Micah Cowan.
@
text
@d1 1
a1 1
/* $OpenBSD: window-copy.c,v 1.35 2009/12/03 22:50:10 nicm Exp $ */
d296 14
@


1.35
log
@Massive spaces->tabs and trailing whitespace cleanup, hopefully for the last
time now I've configured emacs to make them displayed in really annoying
colours...
@
text
@d1 1
a1 1
/* $OpenBSD: window-copy.c,v 1.34 2009/11/26 21:37:13 nicm Exp $ */
d1078 1
d1091 6
a1096 2
		if (scroll_only)
			window_copy_redraw_lines(wp, data->cy, 2);
d1099 6
a1104 2
		if (window_copy_update_selection(wp))
			window_copy_redraw_lines(wp, data->cy, 2);
@


1.34
log
@Remove a couple of unused arguments where possible, and add /* ARGSUSED */ to
the rest to reduce lint output.
@
text
@d1 1
a1 1
/* $OpenBSD: window-copy.c,v 1.33 2009/11/18 17:03:16 nicm Exp $ */
d32 1
a32 1
    	    struct window_pane *, struct client *, struct mouse_event *);
d37 1
a37 1
    	    struct window_pane *, struct screen_write_ctx *, u_int);
d39 1
a39 1
    	    struct window_pane *, struct screen_write_ctx *, u_int, u_int);
d198 1
a198 1
	
d236 1
a236 1
 		return;
d300 1
a300 1
 		window_copy_start_selection(wp);
d425 1
a425 1
		
d455 1
a455 1
 		window_copy_redraw_screen(wp);
d479 1
a479 1
 	data->oy = gd->hsize - offset;
d493 1
a493 1
	
d677 1
a677 1
	
d896 2
a897 2
 	const struct grid_cell	*gc;
 	const struct grid_utf8	*gu;
d910 1
a910 1
 	if (gl->flags & GRID_LINE_WRAPPED && gl->cellsize <= gd->sx)
d941 1
a941 1
 	if (!wrapped) {
@


1.33
log
@Missed an unused variable :-/.
@
text
@d1 1
a1 1
/* $OpenBSD: window-copy.c,v 1.32 2009/11/18 17:02:17 nicm Exp $ */
d438 1
@


1.32
log
@Cleanup by moving various (mostly horrible) little bits handling UTF-8 grid
data into functions in a new file, grid-utf8.c, and use sizeof intead of
UTF8_DATA.

Also nuke trailing whitespace from tmux.1, reminded by jmc.
@
text
@d1 1
a1 1
/* $OpenBSD: window-copy.c,v 1.31 2009/10/20 21:35:25 nicm Exp $ */
a488 1
	size_t			 size;
@


1.31
log
@Correctly nuke the EOL $ marker when scrolling, reported by martynas@@, thanks.
@
text
@d1 1
a1 1
/* $OpenBSD: window-copy.c,v 1.30 2009/10/13 13:45:56 nicm Exp $ */
d489 1
d500 1
a500 1
		if (memcmp(gu->data, sgu->data, UTF8_SIZE) == 0)
d899 2
a900 1
	u_int			 i, j, xx, wrapped = 0;
d933 3
a935 6
				*buf = xrealloc(*buf, 1, (*off) + UTF8_SIZE);
				for (j = 0; j < UTF8_SIZE; j++) {
					if (gu->data[j] == 0xff)
						break;
					(*buf)[(*off)++] = gu->data[j];
				}
@


1.30
log
@Add mode keys to move the cursor to the top, middle and bottom of the screen.
H/M/L in vi mode and M-R/M-r in emacs (bottom of screen not bound in emacs).
@
text
@d1 1
a1 1
/* $OpenBSD: window-copy.c,v 1.29 2009/10/11 07:01:10 nicm Exp $ */
d1091 1
a1091 1
		if (scroll_only && window_copy_update_selection(wp))
d1122 1
a1122 1
		if (scroll_only && window_copy_update_selection(wp))
d1253 4
a1256 1
	window_copy_write_line(wp, &ctx, 1);
@


1.29
log
@Clean up by introducing a wrapper struct for mouse clicks rather than passing
three u_chars around.

As a side-effect this fixes incorrectly rejecting high cursor positions
(because it was comparing them as signed char), reported by Tom Doherty.
@
text
@d1 1
a1 1
/* $OpenBSD: window-copy.c,v 1.28 2009/10/06 07:09:00 nicm Exp $ */
d278 18
@


1.28
log
@Make C-Up and C-Down in copy mode scroll the screen up and down one line
without moving the cursor, like Up and Down in scroll mode (which will shortly
disappear).
@
text
@d1 1
a1 1
/* $OpenBSD: window-copy.c,v 1.27 2009/09/10 17:16:24 nicm Exp $ */
d32 1
a32 1
    	    struct window_pane *, struct client *, u_char, u_char, u_char);
d421 2
a422 2
window_copy_mouse(struct window_pane *wp,
    unused struct client *c, u_char b, u_char x, u_char y)
d427 1
a427 1
	if ((b & 3) == 3)
d429 1
a429 1
	if (x >= screen_size_x(s))
d431 1
a431 1
	if (y >= screen_size_y(s))
d434 1
a434 1
	window_copy_update_cursor(wp, x, y);
@


1.27
log
@Permit options such as status-bg to be configured using the entire 256 colour
palette by setting "colour0" to "colour255".
@
text
@d1 1
a1 1
/* $OpenBSD: window-copy.c,v 1.26 2009/09/07 18:50:45 nicm Exp $ */
d64 2
a65 2
void	window_copy_cursor_up(struct window_pane *);
void	window_copy_cursor_down(struct window_pane *);
d238 1
a238 1
		window_copy_cursor_up(wp);
d241 1
a241 1
		window_copy_cursor_down(wp);
d243 6
d1029 1
a1029 1
		window_copy_cursor_up(wp);
d1049 1
a1049 1
		window_copy_cursor_down(wp);
d1058 1
a1058 1
window_copy_cursor_up(struct window_pane *wp)
d1071 1
a1071 1
	if (data->cy == 0)
d1073 3
a1075 1
	else {
d1088 1
a1088 1
window_copy_cursor_down(struct window_pane *wp)
d1102 1
a1102 1
	if (data->cy == screen_size_y(s) - 1)
d1104 3
a1106 1
	else {
d1150 1
a1150 1
				window_copy_cursor_down(wp);
d1198 1
a1198 1
			window_copy_cursor_up(wp);
@


1.26
log
@Give each paste buffer a size member instead of requiring them to be
zero-terminated.
@
text
@d1 1
a1 1
/* $OpenBSD: window-copy.c,v 1.25 2009/08/21 07:33:58 nicm Exp $ */
d663 1
d669 3
a671 3
	gc.fg = options_get_number(&wp->window->options, "mode-fg");
	gc.bg = options_get_number(&wp->window->options, "mode-bg");
	gc.attr |= options_get_number(&wp->window->options, "mode-attr");
d769 1
d778 3
a780 3
	gc.fg = options_get_number(&wp->window->options, "mode-fg");
	gc.bg = options_get_number(&wp->window->options, "mode-bg");
	gc.attr |= options_get_number(&wp->window->options, "mode-attr");
@


1.25
log
@When moving up or down in copy mode, save the cursor position and size of the
last line with content (width != 0) and use it to determine if the cursor
should be at the end of the line. Fixes problem of the cursor always jumping to
the end of the line when scrolling past a blank line.
@
text
@d1 1
a1 1
/* $OpenBSD: window-copy.c,v 1.24 2009/08/19 14:46:56 nicm Exp $ */
d852 6
a857 3
	/* Terminate buffer, overwriting final \n. */
	if (off != 0)
		buf[off - 1] = '\0';
d861 1
a861 1
	paste_add(&c->session->buffers, buf, limit);
@


1.24
log
@Don't read beyond the edge of the screen when searching (dies with debug
enabled).
@
text
@d1 1
a1 1
/* $OpenBSD: window-copy.c,v 1.23 2009/08/18 09:51:51 nicm Exp $ */
d100 3
d125 3
d1054 4
d1059 1
d1070 1
a1070 2

	if (data->cx >= px || data->cx >= ox)
d1083 4
d1088 1
d1099 1
a1099 2

	if (data->cx >= px || data->cx >= ox)
@


1.23
log
@Nuke unnecessary assignment.
@
text
@d1 1
a1 1
/* $OpenBSD: window-copy.c,v 1.22 2009/08/18 07:23:43 nicm Exp $ */
d507 2
@


1.22
log
@Add a "delete line" key when editing in the status line or the search up/down
prompt. C-u with emacs keys, d with vi.
@
text
@d1 1
a1 1
/* $OpenBSD: window-copy.c,v 1.21 2009/08/18 07:08:26 nicm Exp $ */
a598 1
	searchlen = strlen(searchstr);
@


1.21
log
@Add (naive) searching and goto line in copy mode. Searching is C-r and C-s with
emacs keys, / and ? with vi; n repeats the search again with either key
set. All searching wraps the top/bottom. Goto line is g for both emacs and vi.

The search prompts don't have full line editing, just simple append and delete
characters.

Also sort the mode keys list in tmux.1.
@
text
@d1 1
a1 1
/* $OpenBSD: window-copy.c,v 1.20 2009/08/13 22:32:18 nicm Exp $ */
d367 3
@


1.20
log
@vi(1)-style half page scroll in copy and scroll modes. Move the vi full page
scroll key to C-b instead of C-u and use C-u/C-d for half page scrolling with
vi keys. In emacs mode, half page scrolling is bound to M-Up and M-Down.

Suggested by merdely (about a year ago :-)).
@
text
@d1 1
a1 1
/* $OpenBSD: window-copy.c,v 1.19 2009/08/13 22:11:43 nicm Exp $ */
d21 1
d30 1
d41 10
d80 7
d90 6
a95 1
	struct mode_key_data	mdata;
d97 2
a98 1
	u_int	oy;
d100 3
a102 2
	u_int	selx;
	u_int	sely;
d104 2
a105 2
	u_int	cx;
	u_int	cy;
d122 7
d157 4
d162 1
d213 7
d298 99
d400 3
d425 223
d655 6
a660 1
	size_t	 			 size;
d662 1
a663 1
		memcpy(&gc, &grid_default_cell, sizeof gc);
a665 4
		gc.fg = options_get_number(&wp->window->options, "mode-fg");
		gc.bg = options_get_number(&wp->window->options, "mode-bg");
		gc.attr |= options_get_number(
		    &wp->window->options, "mode-attr");
d668 5
d676 2
a677 2
	screen_write_cursormove(ctx, 0, py);
	screen_write_copy(ctx, &wp->base, 0, (screen_hsize(&wp->base) -
@


1.19
log
@Scroll by two less than the number of lines in the screen, like emacs, rather
than by the entire screen, to make it easier to pull things out from under the
line indicator. Suggested by claudio.
@
text
@d1 1
a1 1
/* $OpenBSD: window-copy.c,v 1.18 2009/08/13 19:35:20 nicm Exp $ */
d199 18
@


1.18
log
@Allowing copy mode to scroll left and right is annoying, so limit it to the
real screen width. To indicate the cursor is at the end of the line rather than
the cell before, put a '$' in the last cell.

Also clear the selection when the terminal is resized to avoid tmux getting
confused.
@
text
@d1 1
a1 1
/* $OpenBSD: window-copy.c,v 1.17 2009/08/13 16:48:43 nicm Exp $ */
d133 1
d135 4
a138 1
	if (data->oy + screen_size_y(s) > screen_hsize(&wp->base))
d141 1
a141 1
		data->oy += screen_size_y(s);
d174 1
d196 4
a199 1
		if (data->oy < screen_size_y(s))
d202 1
a202 1
			data->oy -= screen_size_y(s);
@


1.17
log
@Redraw the screen after resizing.
@
text
@d1 1
a1 1
/* $OpenBSD: window-copy.c,v 1.16 2009/08/08 15:57:49 nicm Exp $ */
a37 4
void	window_copy_write_column(
    	    struct window_pane *, struct screen_write_ctx *, u_int);
void	window_copy_write_columns(
    	    struct window_pane *, struct screen_write_ctx *, u_int, u_int);
d39 1
a39 1
void	window_copy_update_cursor(struct window_pane *);
a46 1
void	window_copy_set_cursor_x(struct window_pane *, u_int);
a55 2
void	window_copy_scroll_left(struct window_pane *, u_int);
void	window_copy_scroll_right(struct window_pane *, u_int);
a72 1
	u_int	ox;
a91 1
	data->ox = 0;
d150 8
d161 1
a161 1
	window_copy_update_selection(wp);
d246 1
a246 3
	data->cx = x;
	data->cy = y;

a248 1
	window_copy_update_cursor(wp);
d252 2
a253 1
window_copy_write_line(struct window_pane *wp, struct screen_write_ctx *ctx, u_int py)
d264 1
a264 1
		    "[%u,%u/%u]", data->ox, data->oy, screen_hsize(&wp->base));
d267 2
a268 1
		gc.attr |= options_get_number(&wp->window->options, "mode-attr");
d275 1
a275 1
	screen_write_copy(ctx, &wp->base, data->ox, (screen_hsize(&wp->base) -
d277 6
a295 22
window_copy_write_column(
    struct window_pane *wp, struct screen_write_ctx *ctx, u_int px)
{
	struct window_copy_mode_data	*data = wp->modedata;
	struct screen			*s = &data->screen;

	screen_write_cursormove(ctx, px, 0);
	screen_write_copy(ctx, &wp->base,
	    data->ox + px, screen_hsize(&wp->base) - data->oy, 1, screen_size_y(s));
}

void
window_copy_write_columns(
    struct window_pane *wp, struct screen_write_ctx *ctx, u_int px, u_int nx)
{
	u_int	xx;

	for (xx = px; xx < px + nx; xx++)
		window_copy_write_column(wp, ctx, xx);
}

void
d318 1
a318 1
window_copy_update_cursor(struct window_pane *wp)
d321 1
d323 1
d325 11
a335 3
	screen_write_start(&ctx, wp, NULL);
	screen_write_cursormove(&ctx, data->cx, data->cy);
	screen_write_stop(&ctx);
d344 1
a344 1
	data->selx = data->cx + data->ox;
d357 1
a357 1
	u_int				 sx, sy, tx, ty;
d368 1
a368 2
	/* Find top-left of screen. */
	tx = data->ox;
d374 1
a374 2
	if (sy < ty) {
		/* Above it. */
d377 1
a377 2
	} else if (sy > ty + screen_size_y(s) - 1) {
		/* Below it. */
d380 1
a380 11
	} else if (sx < tx) {
		/* To the left. */
		sx = 0;
	} else if (sx > tx + screen_size_x(s) - 1) {
		/* To the right. */
		sx = 0;
		sy++;
		if (sy > screen_size_y(s) - 1)
			sy = screen_size_y(s) - 1;
	} else {
		sx -= tx;
a381 1
	}
d412 1
a412 1
	xx = data->cx + data->ox;
a546 42
/*
 * Set the cursor X coordinate and scroll horizontally to make it visible.
 * Also redraw the selection or the cursor, as needed.
 */
void
window_copy_set_cursor_x(struct window_pane *wp, u_int px)
{
	struct window_copy_mode_data	*data = wp->modedata;
	struct screen			*s = &data->screen;

	/* On screen. */
	if (px > data->ox && px <= data->ox + screen_size_x(s) - 1)
		data->cx = px - data->ox;

	/* Off right of screen. */
	if (px > data->ox + screen_size_x(s) - 1) {
		/* Move cursor to last and scroll screen. */
		window_copy_scroll_left(
		    wp, px - data->ox - (screen_size_x(s) - 1));
		data->cx = screen_size_x(s) - 1;
	}

	/* Off left of screen. */
	if (px <= data->ox) {
		if (px < screen_size_x(s) - 1) {
			/* Short enough to fit on screen. */
			window_copy_scroll_right(wp, data->ox);
			data->cx = px;
		} else {
			/* Too long to fit on screen. */
			window_copy_scroll_right(
			    wp, data->ox - (px - (screen_size_x(s) - 1)));
			data->cx = screen_size_x(s) - 1;
		}
 	}

	if (window_copy_update_selection(wp))
		window_copy_redraw_lines(wp, data->cy, 1);
	else
		window_copy_update_cursor(wp);
}

d552 1
a552 4
	if (data->ox != 0)
		window_copy_scroll_right(wp, data->ox);
	data->cx = 0;

a554 2
	else
		window_copy_update_cursor(wp);
d581 3
a583 1
	window_copy_set_cursor_x(wp, px);
d595 3
a597 1
	window_copy_set_cursor_x(wp, px);
d606 2
a607 6
		if (data->ox > 0)
			window_copy_scroll_right(wp, 1);
		else {
			window_copy_cursor_up(wp);
			window_copy_cursor_end_of_line(wp);
		}
d609 1
a609 1
		data->cx--;
a611 2
		else
			window_copy_update_cursor(wp);
d628 1
a628 1
		data->cx++;
a630 2
		else
			window_copy_update_cursor(wp);
d646 1
a646 1
		data->cy--;
a648 2
		else
			window_copy_update_cursor(wp);
d654 1
a654 1
	if (data->cx + data->ox >= px || data->cx + data->ox >= ox)
d671 1
a671 1
		data->cy++;
a673 2
		else
			window_copy_update_cursor(wp);
d679 1
a679 1
	if (data->cx + data->ox >= px || data->cx + data->ox >= ox)
d690 1
a690 1
	px = data->ox + data->cx;
d735 1
d737 3
a739 2

	window_copy_set_cursor_x(wp, px);
d749 1
a749 1
	px = data->ox + data->cx;
d776 3
a778 59
	window_copy_set_cursor_x(wp, px);
}

void
window_copy_scroll_left(struct window_pane *wp, u_int nx)
{
	struct window_copy_mode_data	*data = wp->modedata;
	struct screen			*s = &data->screen;
	struct screen_write_ctx		 ctx;
	u_int				 i;

	if (data->ox > SHRT_MAX - nx)
		nx = SHRT_MAX - data->ox;
	if (nx == 0)
		return;
	data->ox += nx;
	window_copy_update_selection(wp);

	screen_write_start(&ctx, wp, NULL);
	for (i = 1; i < screen_size_y(s); i++) {
		screen_write_cursormove(&ctx, 0, i);
		screen_write_deletecharacter(&ctx, nx);
	}
	window_copy_write_columns(wp, &ctx, screen_size_x(s) - nx, nx);
	window_copy_write_line(wp, &ctx, 0);
	if (s->sel.flag) {
		window_copy_update_selection(wp);
		window_copy_write_lines(wp, &ctx, data->cy, 1);
	}
	screen_write_cursormove(&ctx, data->cx, data->cy);
	screen_write_stop(&ctx);
}

void
window_copy_scroll_right(struct window_pane *wp, u_int nx)
{
	struct window_copy_mode_data	*data = wp->modedata;
	struct screen			*s = &data->screen;
	struct screen_write_ctx		 ctx;
	u_int		 		 i;

	if (data->ox < nx)
		nx = data->ox;
	if (nx == 0)
		return;
	data->ox -= nx;
	window_copy_update_selection(wp);

	screen_write_start(&ctx, wp, NULL);
	for (i = 1; i < screen_size_y(s); i++) {
		screen_write_cursormove(&ctx, 0, i);
		screen_write_insertcharacter(&ctx, nx);
	}
	window_copy_write_columns(wp, &ctx, 0, nx);
	window_copy_write_line(wp, &ctx, 0);
	if (s->sel.flag)
		window_copy_write_line(wp, &ctx, data->cy);
	screen_write_cursormove(&ctx, data->cx, data->cy);
	screen_write_stop(&ctx);
@


1.16
log
@Add a flags member to the grid_line struct and use it to differentiate lines
wrapped at the screen edge from those terminated by a newline. Then use this
when copying to combine wrapped lines together into one.
@
text
@d1 1
a1 1
/* $OpenBSD: window-copy.c,v 1.15 2009/08/08 13:29:27 nicm Exp $ */
d163 1
@


1.15
log
@Change the way the grid is stored, previously it was:

- a two-dimensional array of cells;
- a two-dimensional array of utf8 data;
- an array of line lengths.

Now it is a single array of a new struct grid_line each of which represents a
line and containts the length and an array of cells and an array of utf8 data.

This will make it easier to add additional per-line members, such as flags.
@
text
@d1 1
a1 1
/* $OpenBSD: window-copy.c,v 1.14 2009/08/05 16:26:38 nicm Exp $ */
d452 1
a452 1
		xx = window_copy_find_length(wp, sy);
d455 1
a455 2
			for (i = sy + 1; i < ey; i++) {
				xx = window_copy_find_length(wp, i);
a456 1
			}
d474 1
d477 2
a478 1
	u_int			 i, j, xx;
d483 13
a495 1
	xx = window_copy_find_length(wp, sy);
d503 1
a503 1
			gc = grid_peek_cell(wp->base.grid, i, sy);
d510 1
a510 1
				gu = grid_peek_utf8(wp->base.grid, i, sy);
d521 5
a525 3
	*buf = xrealloc(*buf, 1, (*off) + 1);
	(*buf)[*off] = '\n';
	(*off)++;
@


1.14
log
@If colours are not supported by the terminal, try to emulate a coloured
background by setting or clearing the reverse attribute.

This makes a few applications which don't use the reverse attribute themselves
a little happier, and allows the status, message and mode options to have
default attributes and fg/bg options that work as expected when set as reverse.
@
text
@d1 1
a1 1
/* $OpenBSD: window-copy.c,v 1.13 2009/07/30 07:04:50 nicm Exp $ */
d540 1
a540 1
	px = wp->base.grid->size[py];
@


1.13
log
@Add a mode-mouse option to prevent tmux taking over the mouse in choice or copy
modes.
@
text
@d1 1
a1 1
/* $OpenBSD: window-copy.c,v 1.12 2009/07/28 07:03:32 nicm Exp $ */
d267 2
a268 2
		gc.bg = options_get_number(&wp->window->options, "mode-fg");
		gc.fg = options_get_number(&wp->window->options, "mode-bg");
d371 2
a372 2
	gc.bg = options_get_number(&wp->window->options, "mode-fg");
	gc.fg = options_get_number(&wp->window->options, "mode-bg");
@


1.12
log
@Next step towards customisable mode keys: build each default table of keys into
a named tree on start and use that for lookups. Also add command to string
translation tables and modify list-keys to show the the mode key bindings (new
-t argument).
@
text
@d1 1
a1 1
/* $OpenBSD: window-copy.c,v 1.11 2009/07/27 20:36:13 nicm Exp $ */
d107 2
a108 1
	s->mode |= MODE_MOUSE;
@


1.11
log
@Remove an unused entry in the mode keys command enum and rename
MODEKEYCOPY_QUIT to _CANCEL to match the others.
@
text
@d1 1
a1 1
/* $OpenBSD: window-copy.c,v 1.10 2009/07/27 19:29:35 nicm Exp $ */
d111 1
a111 1
		mode_key_init(&data->mdata, mode_key_emacs_copy);
d113 1
a113 1
		mode_key_init(&data->mdata, mode_key_vi_copy);
@


1.10
log
@Change mode key bindings from big switches into a set of tables. Rather than
lumping them all together, split editing keys from those used in choice/more
mode and those for copy/scroll mode.

Tidier and clearer, and the first step towards customisable mode keys.
@
text
@d1 1
a1 1
/* $OpenBSD: window-copy.c,v 1.9 2009/07/27 18:51:46 nicm Exp $ */
d171 1
a171 1
	case MODEKEYCOPY_QUIT:
@


1.9
log
@Get rid of empty mode_key_free function.
@
text
@d1 1
a1 1
/* $OpenBSD: window-copy.c,v 1.8 2009/07/27 07:42:45 nicm Exp $ */
d97 1
d109 5
a113 2
	mode_key_init(&data->mdata,
	    options_get_number(&wp->window->options, "mode-keys"), 0);
d171 1
a171 1
	case MODEKEYCMD_QUIT:
d174 1
a174 1
	case MODEKEYCMD_LEFT:
d177 1
a177 1
	case MODEKEYCMD_RIGHT:
d180 1
a180 1
	case MODEKEYCMD_UP:
d183 1
a183 1
	case MODEKEYCMD_DOWN:
d186 1
a186 1
	case MODEKEYCMD_PREVIOUSPAGE:
d189 1
a189 1
	case MODEKEYCMD_NEXTPAGE:
d197 1
a197 1
	case MODEKEYCMD_STARTSELECTION:
d201 1
a201 1
	case MODEKEYCMD_CLEARSELECTION:
d205 1
a205 1
	case MODEKEYCMD_COPYSELECTION:
d211 1
a211 1
	case MODEKEYCMD_STARTOFLINE:
d214 1
a214 1
	case MODEKEYCMD_BACKTOINDENTATION:
d217 1
a217 1
	case MODEKEYCMD_ENDOFLINE:
d220 1
a220 1
	case MODEKEYCMD_NEXTWORD:
d223 1
a223 1
	case MODEKEYCMD_PREVIOUSWORD:
@


1.8
log
@Change previous-word behavior to move to the beginning of the word (matches
emacs and vi). From Kalle Olavi Niemitalo.
@
text
@d1 1
a1 1
/* $OpenBSD: window-copy.c,v 1.7 2009/07/23 17:03:47 nicm Exp $ */
a126 2

 	mode_key_free(&data->mdata);
@


1.7
log
@Redraw after starting selection to correctly remove any existing selection.
@
text
@d1 1
a1 1
/* $OpenBSD: window-copy.c,v 1.6 2009/07/12 16:15:34 nicm Exp $ */
d799 1
d804 1
a804 1
	u_int				 ox, px, py, skip;
d806 1
a806 1
	ox = px = data->ox + data->cx;
d809 1
a809 6
	skip = 1;
	if (px != 0) {
		/* If currently on a space, skip space. */
		if (window_copy_is_space(wp, px - 1, py))
			skip = 0;
	}
d811 3
a813 2
		if (px == 0) {
			if (ox != 0)
d815 6
d822 3
a824 23
			while (px == 0) {
				if (data->cy == 0 &&
				    (screen_hsize(&wp->base) == 0 ||
				    data->oy >= screen_hsize(&wp->base) - 1))
					goto out;

				window_copy_cursor_up(wp);

				py = screen_hsize(
				    &wp->base) + data->cy - data->oy;
				px = window_copy_find_length(wp, py);
			}
			goto out;
		}

		if (skip) {
			/* Currently skipping non-space (until space). */
			if (window_copy_is_space(wp, px - 1, py))
				skip = 0;
		} else {
			/* Currently skipping space (until non-space). */
			if (!window_copy_is_space(wp, px - 1, py))
				break;
d826 1
d828 2
d831 1
a831 1
	}
a832 1

@


1.6
log
@Add a "back to indentation" key in copy mode to move the cursor to the first
non-whitespace character. ^ with vi and M-m with emacs key bindings. Another
from Kalle Olavi Niemitalo, thanks.
@
text
@d1 1
a1 1
/* $OpenBSD: window-copy.c,v 1.5 2009/07/12 16:12:34 nicm Exp $ */
d197 1
@


1.5
log
@Merge three copies of identical code to move the cursor x position into a
single function, from Kalle Olavi Niemitalo.
@
text
@d1 1
a1 1
/* $OpenBSD: window-copy.c,v 1.4 2009/07/11 19:09:24 nicm Exp $ */
d53 1
d211 3
d605 27
@


1.4
log
@Copy was using the real line length which after resize can be larger than the
screen width. When built with -DDEBUG, this made the grid bounds checking code
kill the server. Restrict copying to the actual width.

From Kalle Olavi Niemitalo, thanks.
@
text
@d1 1
a1 1
/* $OpenBSD: window-copy.c,v 1.3 2009/07/09 15:02:00 nicm Exp $ */
d51 1
d546 4
d551 1
a551 16
window_copy_cursor_start_of_line(struct window_pane *wp)
{
	struct window_copy_mode_data	*data = wp->modedata;

	if (data->ox != 0)
		window_copy_scroll_right(wp, data->ox);
	data->cx = 0;

	if (window_copy_update_selection(wp))
		window_copy_redraw_lines(wp, data->cy, 1);
	else
		window_copy_update_cursor(wp);
}

void
window_copy_cursor_end_of_line(struct window_pane *wp)
a554 4
	u_int				 px, py;

	py = screen_hsize(&wp->base) + data->cy - data->oy;
	px = window_copy_find_length(wp, py);
d589 27
d764 1
a764 30
	/* On screen. */
	if (px > data->ox && px <= data->ox + screen_size_x(s) - 1)
		data->cx = px - data->ox;

	/* Off right of screen. */
	if (px > data->ox + screen_size_x(s) - 1) {
		/* Move cursor to last and scroll screen. */
		window_copy_scroll_left(
		    wp, px - data->ox - (screen_size_x(s) - 1));
		data->cx = screen_size_x(s) - 1;
	}

	/* Off left of screen. */
	if (px <= data->ox) {
		if (px < screen_size_x(s) - 1) {
			/* Short enough to fit on screen. */
			window_copy_scroll_right(wp, data->ox);
			data->cx = px;
		} else {
			/* Too long to fit on screen. */
			window_copy_scroll_right(
			    wp, data->ox - (px - (screen_size_x(s) - 1)));
			data->cx = screen_size_x(s) - 1;
		}
 	}

	if (window_copy_update_selection(wp))
		window_copy_redraw_lines(wp, data->cy, 1);
	else
		window_copy_update_cursor(wp);
a770 1
	struct screen			*s = &data->screen;
d816 1
a816 30
	/* On screen. */
	if (px > data->ox && px <= data->ox + screen_size_x(s) - 1)
		data->cx = px - data->ox;

	/* Off right of screen. */
	if (px > data->ox + screen_size_x(s) - 1) {
		/* Move cursor to last and scroll screen. */
		window_copy_scroll_left(
		    wp, px - data->ox - (screen_size_x(s) - 1));
		data->cx = screen_size_x(s) - 1;
	}

	/* Off left of screen. */
	if (px <= data->ox) {
		if (px < screen_size_x(s) - 1) {
			/* Short enough to fit on screen. */
			window_copy_scroll_right(wp, data->ox);
			data->cx = px;
		} else {
			/* Too long to fit on screen. */
			window_copy_scroll_right(
			    wp, data->ox - (px - (screen_size_x(s) - 1)));
			data->cx = screen_size_x(s) - 1;
		}
 	}

	if (window_copy_update_selection(wp))
		window_copy_redraw_lines(wp, data->cy, 1);
	else
		window_copy_update_cursor(wp);
@


1.3
log
@Stop in the right place so all the lines selected are copied. Reported by Kalle
Olavi Niemitalo, thanks.
@
text
@d1 1
a1 1
/* $OpenBSD: window-copy.c,v 1.2 2009/07/02 16:15:43 nicm Exp $ */
d525 6
d532 2
@


1.2
log
@Fix two copy/paste bugs: forbid zero-length buffers to prevent a fatal error
when trying to paste them, found by me, and miscalculation of the start/end
causing random fatal errors when copying in copy-mode, reported by sthen.

ok sthen "put it in" deraadt
@
text
@d1 1
a1 1
/* $OpenBSD: window-copy.c,v 1.1 2009/06/01 22:58:49 nicm Exp $ */
d446 1
a446 1
			for (i = sy + 1; i < ey - 1; i++) {
@


1.1
log
@Import tmux, a terminal multiplexor allowing (among other things) a single
terminal to be switched between several different windows and programs
displayed on one terminal be detached from one terminal and moved to another.

ok deraadt pirofti
@
text
@d1 1
a1 1
/* $OpenBSD$ */
d426 1
a426 1
	if (xx < data->selx || (yy == data->sely && xx < data->selx)) {
@

