head	1.11;
access;
symbols
	OPENBSD_6_1_BASE:1.11
	OPENBSD_6_0:1.10.0.2
	OPENBSD_6_0_BASE:1.10
	OPENBSD_5_9:1.9.0.2
	OPENBSD_5_9_BASE:1.9
	OPENBSD_5_8:1.7.0.6
	OPENBSD_5_8_BASE:1.7
	OPENBSD_5_7:1.7.0.2
	OPENBSD_5_7_BASE:1.7
	OPENBSD_5_6:1.4.0.12
	OPENBSD_5_6_BASE:1.4
	OPENBSD_5_5:1.4.0.10
	OPENBSD_5_5_BASE:1.4
	OPENBSD_5_4:1.4.0.6
	OPENBSD_5_4_BASE:1.4
	OPENBSD_5_3:1.4.0.4
	OPENBSD_5_3_BASE:1.4
	OPENBSD_5_2:1.4.0.2
	OPENBSD_5_2_BASE:1.4
	OPENBSD_5_1_BASE:1.3
	OPENBSD_5_1:1.3.0.10
	OPENBSD_5_0:1.3.0.8
	OPENBSD_5_0_BASE:1.3
	OPENBSD_4_9:1.3.0.6
	OPENBSD_4_9_BASE:1.3
	OPENBSD_4_8:1.3.0.4
	OPENBSD_4_8_BASE:1.3
	OPENBSD_4_7:1.3.0.2
	OPENBSD_4_7_BASE:1.3
	OPENBSD_4_6:1.1.0.4
	OPENBSD_4_6_BASE:1.1;
locks; strict;
comment	@ * @;


1.11
date	2016.11.17.10.06.08;	author nicm;	state Exp;
branches;
next	1.10;
commitid	pfA3XECBcSQOLE32;

1.10
date	2016.04.04.16.19.43;	author nicm;	state Exp;
branches;
next	1.9;
commitid	kadY24QzC3ep4u2e;

1.9
date	2015.11.18.13.06.54;	author nicm;	state Exp;
branches;
next	1.8;
commitid	xAU2oIxJB0E2UZoZ;

1.8
date	2015.11.17.18.25.03;	author tobias;	state Exp;
branches;
next	1.7;
commitid	FhbAgvR7WtTmuXiY;

1.7
date	2014.10.20.23.57.14;	author nicm;	state Exp;
branches;
next	1.6;
commitid	PTykIJGtZncJPE4a;

1.6
date	2014.10.20.23.27.14;	author nicm;	state Exp;
branches;
next	1.5;
commitid	BAMrPS0saBiCc8HD;

1.5
date	2014.10.08.17.35.58;	author nicm;	state Exp;
branches;
next	1.4;
commitid	mK8z9uVwDZMfiNoM;

1.4
date	2012.07.10.11.53.01;	author nicm;	state Exp;
branches;
next	1.3;

1.3
date	2009.10.26.21.42.04;	author deraadt;	state Exp;
branches;
next	1.2;

1.2
date	2009.10.26.21.10.24;	author nicm;	state Exp;
branches;
next	1.1;

1.1
date	2009.06.01.22.58.49;	author nicm;	state Exp;
branches;
next	;


desc
@@


1.11
log
@Key running commands for #() by the unexpanded command, and run them
again if the expanded form changes (otherwise at most once per second as
usual). Fixes issues reported by Gregory Pakosz.
@
text
@/* $OpenBSD: xmalloc.c,v 1.10 2016/04/04 16:19:43 nicm Exp $ */

/*
 * Author: Tatu Ylonen <ylo@@cs.hut.fi>
 * Copyright (c) 1995 Tatu Ylonen <ylo@@cs.hut.fi>, Espoo, Finland
 *                    All rights reserved
 * Versions of malloc and friends that check their results, and never return
 * failure (they call fatalx if they encounter an error).
 *
 * As far as I am concerned, the code I have written for this software
 * can be used freely for any purpose.  Any derived versions of this
 * software must be clearly marked as such, and if the derived work is
 * incompatible with the protocol description in the RFC file, it must be
 * called by a name other than "ssh" or "Secure Shell".
 */

#include <errno.h>
#include <limits.h>
#include <stdint.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#include "tmux.h"

void *
xmalloc(size_t size)
{
	void *ptr;

	if (size == 0)
		fatalx("xmalloc: zero size");
	ptr = malloc(size);
	if (ptr == NULL)
		fatalx("xmalloc: allocating %zu bytes: %s",
		    size, strerror(errno));
	return ptr;
}

void *
xcalloc(size_t nmemb, size_t size)
{
	void *ptr;

	if (size == 0 || nmemb == 0)
		fatalx("xcalloc: zero size");
	ptr = calloc(nmemb, size);
	if (ptr == NULL)
		fatalx("xcalloc: allocating %zu * %zu bytes: %s",
		    nmemb, size, strerror(errno));
	return ptr;
}

void *
xrealloc(void *ptr, size_t size)
{
	return xreallocarray(ptr, 1, size);
}

void *
xreallocarray(void *ptr, size_t nmemb, size_t size)
{
	void *new_ptr;

	if (nmemb == 0 || size == 0)
		fatalx("xreallocarray: zero size");
	new_ptr = reallocarray(ptr, nmemb, size);
	if (new_ptr == NULL)
		fatalx("xreallocarray: allocating %zu * %zu bytes: %s",
		    nmemb, size, strerror(errno));
	return new_ptr;
}

char *
xstrdup(const char *str)
{
	char *cp;

	if ((cp = strdup(str)) == NULL)
		fatalx("xstrdup: %s", strerror(errno));
	return cp;
}

char *
xstrndup(const char *str, size_t maxlen)
{
	char *cp;

	if ((cp = strndup(str, maxlen)) == NULL)
		fatalx("xstrndup: %s", strerror(errno));
	return cp;
}

int
xasprintf(char **ret, const char *fmt, ...)
{
	va_list ap;
	int i;

	va_start(ap, fmt);
	i = xvasprintf(ret, fmt, ap);
	va_end(ap);

	return i;
}

int
xvasprintf(char **ret, const char *fmt, va_list ap)
{
	int i;

	i = vasprintf(ret, fmt, ap);

	if (i < 0 || *ret == NULL)
		fatalx("xasprintf: %s", strerror(errno));

	return i;
}

int
xsnprintf(char *str, size_t len, const char *fmt, ...)
{
	va_list ap;
	int i;

	va_start(ap, fmt);
	i = xvsnprintf(str, len, fmt, ap);
	va_end(ap);

	return i;
}

int
xvsnprintf(char *str, size_t len, const char *fmt, va_list ap)
{
	int i;

	if (len > INT_MAX)
		fatalx("xsnprintf: len > INT_MAX");

	i = vsnprintf(str, len, fmt, ap);

	if (i < 0 || i >= (int)len)
		fatalx("xsnprintf: overflow");

	return i;
}
@


1.10
log
@fatalx() not fatal().
@
text
@d1 1
a1 1
/* $OpenBSD: xmalloc.c,v 1.9 2015/11/18 13:06:54 nicm Exp $ */
d81 10
@


1.9
log
@Sync the entire xmalloc.[ch] with the other users, but with the addition
of xrealloc, xvasprintf, xvsnprintf.
@
text
@d1 1
a1 1
/* $OpenBSD: xmalloc.c,v 1.13 2015/11/17 18:25:02 tobias Exp $ */
d8 1
a8 1
 * failure (they call fatal if they encounter an error).
d32 1
a32 1
		fatal("xmalloc: zero size");
d35 1
a35 1
		fatal("xmalloc: allocating %zu bytes: %s",
d46 1
a46 1
		fatal("xcalloc: zero size");
d49 1
a49 1
		fatal("xcalloc: allocating %zu * %zu bytes: %s",
d66 1
a66 1
		fatal("xreallocarray: zero size");
d69 1
a69 1
		fatal("xreallocarray: allocating %zu * %zu bytes: %s",
d80 1
a80 1
		fatal("xstrdup: %s", strerror(errno));
d105 1
a105 1
		fatal("xasprintf: %s", strerror(errno));
d129 1
a129 1
		fatal("xsnprintf: len > INT_MAX");
d134 1
a134 1
		fatal("xsnprintf: overflow");
@


1.8
log
@Merge xmalloc.[ch] files across base, skipping OpenSSH for now.

ok nicm
@
text
@d1 1
a1 1
/* $OpenBSD: xmalloc.c,v 1.7 2014/10/20 23:57:14 nicm Exp $ */
d4 5
a8 1
 * Copyright (c) 2004 Nicholas Marriott <nicm@@users.sourceforge.net>
d10 5
a14 11
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF MIND, USE, DATA OR PROFITS, WHETHER
 * IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING
 * OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
d17 2
a18 2
#include <sys/types.h>

d20 1
d26 2
a27 2
char *
xstrdup(const char *str)
d29 1
a29 1
	char	*cp;
d31 7
a37 3
	if ((cp = strdup(str)) == NULL)
		fatal("xstrdup");
	return (cp);
d43 1
a43 1
	void	*ptr;
d46 6
a51 5
		fatalx("xcalloc: zero size");
	if ((ptr = calloc(nmemb, size)) == NULL)
		log_fatal("xcalloc: allocating %zu bytes", size);

	return (ptr);
d55 1
a55 1
xmalloc(size_t size)
d57 1
a57 8
	void	*ptr;

	if (size == 0)
		fatalx("xmalloc: zero size");
	if ((ptr = malloc(size)) == NULL)
		log_fatal("xmalloc: allocating %zu bytes", size);

	return (ptr);
d61 1
a61 1
xrealloc(void *oldptr, size_t newsize)
d63 1
a63 1
	void	*newptr;
d65 7
a71 6
	if (newsize == 0)
		fatalx("xrealloc: zero size");
	if ((newptr = realloc(oldptr, newsize)) == NULL)
		log_fatal("xrealloc: allocating %zu bytes", newsize);

	return (newptr);
d74 2
a75 2
void *
xreallocarray(void *oldptr, size_t nmemb, size_t size)
d77 1
a77 1
	void	*newptr;
d79 3
a81 7
	if (nmemb == 0 || size == 0)
		fatalx("xreallocarray: zero size");
	if ((newptr = reallocarray(oldptr, nmemb, size)) == NULL)
		log_fatal("xreallocarray: allocating %zu * %zu bytes",
		    nmemb, size);

	return (newptr);
d88 1
a88 1
	int	i;
d94 1
a94 1
	return (i);
d100 1
a100 1
	int	i;
d103 1
d105 1
a105 1
		fatal("xvasprintf");
d107 1
a107 1
	return (i);
d111 1
a111 1
xsnprintf(char *buf, size_t len, const char *fmt, ...)
d114 1
a114 1
	int	i;
d117 1
a117 1
	i = xvsnprintf(buf, len, fmt, ap);
d120 1
a120 1
	return (i);
d124 1
a124 1
xvsnprintf(char *buf, size_t len, const char *fmt, va_list ap)
d126 1
a126 1
	int	i;
d129 3
a131 1
		fatalx("xvsnprintf: len > INT_MAX");
a132 1
	i = vsnprintf(buf, len, fmt, ap);
d134 1
a134 1
		fatalx("xvsnprintf: overflow");
d136 1
a136 1
	return (i);
@


1.7
log
@Better format for printf format attributes.
@
text
@d1 1
a1 1
/* $OpenBSD: xmalloc.c,v 1.6 2014/10/20 23:27:14 nicm Exp $ */
d28 1
a28 1
xstrdup(const char *s)
d30 1
a30 2
	char	*ptr;
	size_t	 len;
d32 3
a34 5
	len = strlen(s) + 1;
	ptr = xmalloc(len);

	strlcpy(ptr, s, len);
	return (ptr);
d43 1
a43 3
		fatalx("zero size");
	if (SIZE_MAX / nmemb < size)
		fatalx("nmemb * size > SIZE_MAX");
d45 1
a45 1
		fatal("xcalloc failed");
d56 1
a56 1
		fatalx("zero size");
d58 1
a58 1
		fatal("xmalloc failed");
d69 1
a69 1
		fatalx("zero size");
d71 1
a71 1
		fatal("xrealloc failed");
a78 1
	size_t	 newsize = nmemb * size;
d81 5
a85 6
	if (newsize == 0)
		fatalx("zero size");
	if (SIZE_MAX / nmemb < size)
		fatalx("nmemb * size > SIZE_MAX");
	if ((newptr = realloc(oldptr, newsize)) == NULL)
		fatal("xreallocarray failed");
d110 1
a110 1
		fatal("xvasprintf failed");
d134 1
a134 1
		fatalx("len > INT_MAX");
d137 2
a138 2
	if (i < 0)
		fatal("vsnprintf failed");
@


1.6
log
@Tidy up some includes.
@
text
@d1 1
a1 1
/* $OpenBSD: xmalloc.c,v 1.5 2014/10/08 17:35:58 nicm Exp $ */
d97 1
a97 1
int printflike2
d122 1
a122 1
int printflike3
@


1.5
log
@Add xreallocarray and remove nmemb argument from xrealloc.
@
text
@d1 1
a1 1
/* $OpenBSD: xmalloc.c,v 1.4 2012/07/10 11:53:01 nicm Exp $ */
d19 1
a19 1
#include <sys/param.h>
a20 2
#include <errno.h>
#include <libgen.h>
@


1.4
log
@xfree is not particularly helpful, remove it. From Thomas Adam.
@
text
@d1 1
a1 1
/* $OpenBSD: xmalloc.c,v 1.3 2009/10/26 21:42:04 deraadt Exp $ */
d71 14
a84 1
xrealloc(void *oldptr, size_t nmemb, size_t size)
d94 1
a94 1
		fatal("xrealloc failed");
@


1.3
log
@tabs are better; ok nicm
@
text
@d1 1
a1 1
/* $OpenBSD: xmalloc.c,v 1.2 2009/10/26 21:10:24 nicm Exp $ */
a83 8
}

void
xfree(void *ptr)
{
	if (ptr == NULL)
		fatalx("null pointer");
	free(ptr);
@


1.2
log
@Use strlcpy instead of strncpy, pointed out by deraadt.
@
text
@d1 1
a1 1
/* $OpenBSD: xmalloc.c,v 1.1 2009/06/01 22:58:49 nicm Exp $ */
d45 1
a45 1
        void	*ptr;
d47 1
a47 1
        if (size == 0 || nmemb == 0)
d49 3
a51 3
        if (SIZE_MAX / nmemb < size)
                fatalx("nmemb * size > SIZE_MAX");
        if ((ptr = calloc(nmemb, size)) == NULL)
d54 1
a54 1
        return (ptr);
d62 3
a64 3
        if (size == 0)
                fatalx("zero size");
        if ((ptr = malloc(size)) == NULL)
d67 1
a67 1
        return (ptr);
d77 4
a80 4
                fatalx("zero size");
        if (SIZE_MAX / nmemb < size)
                fatalx("nmemb * size > SIZE_MAX");
        if ((newptr = realloc(oldptr, newsize)) == NULL)
d83 1
a83 1
        return (newptr);
d97 2
a98 2
        va_list ap;
        int	i;
d100 3
a102 3
        va_start(ap, fmt);
        i = xvasprintf(ret, fmt, ap);
        va_end(ap);
d113 2
a114 2
        if (i < 0 || *ret == NULL)
                fatal("xvasprintf failed");
d116 1
a116 1
        return (i);
d122 2
a123 2
        va_list ap;
        int	i;
d125 3
a127 3
        va_start(ap, fmt);
        i = xvsnprintf(buf, len, fmt, ap);
        va_end(ap);
d141 2
a142 2
        if (i < 0)
                fatal("vsnprintf failed");
d144 1
a144 1
        return (i);
@


1.1
log
@Import tmux, a terminal multiplexor allowing (among other things) a single
terminal to be switched between several different windows and programs
displayed on one terminal be detached from one terminal and moved to another.

ok deraadt pirofti
@
text
@d1 1
a1 1
/* $OpenBSD$ */
d32 1
a32 1
	void	*ptr;
d38 2
a39 1
        return (strncpy(ptr, s, len));
@

