head	1.15;
access;
symbols
	OPENBSD_6_2:1.15.0.2
	OPENBSD_6_2_BASE:1.15
	OPENBSD_6_1:1.15.0.4
	OPENBSD_6_1_BASE:1.15
	OPENBSD_6_0:1.14.0.2
	OPENBSD_6_0_BASE:1.14
	OPENBSD_5_9:1.12.0.2
	OPENBSD_5_9_BASE:1.12
	OPENBSD_5_8:1.11.0.4
	OPENBSD_5_8_BASE:1.11
	OPENBSD_5_7:1.7.0.2
	OPENBSD_5_7_BASE:1.7
	OPENBSD_5_6:1.6.0.8
	OPENBSD_5_6_BASE:1.6
	OPENBSD_5_5:1.6.0.6
	OPENBSD_5_5_BASE:1.6
	OPENBSD_5_4:1.6.0.2
	OPENBSD_5_4_BASE:1.6
	OPENBSD_5_3:1.5.0.6
	OPENBSD_5_3_BASE:1.5
	OPENBSD_5_2:1.5.0.4
	OPENBSD_5_2_BASE:1.5
	OPENBSD_5_1_BASE:1.5
	OPENBSD_5_1:1.5.0.2
	OPENBSD_5_0:1.3.0.4
	OPENBSD_5_0_BASE:1.3
	OPENBSD_4_9:1.3.0.2
	OPENBSD_4_9_BASE:1.3
	OPENBSD_4_8:1.2.0.4
	OPENBSD_4_8_BASE:1.2
	OPENBSD_4_7:1.2.0.2
	OPENBSD_4_7_BASE:1.2
	OPENBSD_4_6:1.1.0.4
	OPENBSD_4_6_BASE:1.1;
locks; strict;
comment	@ * @;


1.15
date	2017.03.24.07.14.27;	author nicm;	state Exp;
branches;
next	1.14;
commitid	rM9AlDAJoNtHb0WX;

1.14
date	2016.07.15.00.42.56;	author nicm;	state Exp;
branches;
next	1.13;
commitid	EramuEV0ciOaJqkF;

1.13
date	2016.06.06.10.12.58;	author nicm;	state Exp;
branches;
next	1.12;
commitid	813Qigtl4pp9wQfi;

1.12
date	2016.01.19.15.59.12;	author nicm;	state Exp;
branches;
next	1.11;
commitid	P3qmSOx6KrDBsb0c;

1.11
date	2015.06.05.22.50.27;	author nicm;	state Exp;
branches;
next	1.10;
commitid	fxuUgpSysBP8vyLL;

1.10
date	2015.06.05.22.33.39;	author nicm;	state Exp;
branches;
next	1.9;
commitid	bhwpTfoxc2Bk5WKg;

1.9
date	2015.06.05.22.01.17;	author nicm;	state Exp;
branches;
next	1.8;
commitid	YlMimkZBgYBSiNwz;

1.8
date	2015.03.31.17.45.10;	author nicm;	state Exp;
branches;
next	1.7;
commitid	2uQloBaX92ri1PyE;

1.7
date	2015.02.07.23.43.41;	author nicm;	state Exp;
branches;
next	1.6;
commitid	PKOo47n6DiX2Jae1;

1.6
date	2013.03.27.11.17.12;	author nicm;	state Exp;
branches;
next	1.5;

1.5
date	2012.01.21.08.23.12;	author nicm;	state Exp;
branches;
next	1.4;

1.4
date	2011.08.22.10.14.15;	author nicm;	state Exp;
branches;
next	1.3;

1.3
date	2011.01.08.00.48.54;	author nicm;	state Exp;
branches;
next	1.2;

1.2
date	2009.09.10.17.16.24;	author nicm;	state Exp;
branches;
next	1.1;

1.1
date	2009.06.01.22.58.49;	author nicm;	state Exp;
branches;
next	;


desc
@@


1.15
log
@Show count of search results in copy mode.
@
text
@/* $OpenBSD: colour.c,v 1.14 2016/07/15 00:42:56 nicm Exp $ */

/*
 * Copyright (c) 2008 Nicholas Marriott <nicholas.marriott@@gmail.com>
 * Copyright (c) 2016 Avi Halachmi <avihpit@@yahoo.com>
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF MIND, USE, DATA OR PROFITS, WHETHER
 * IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING
 * OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */

#include <sys/types.h>

#include <ctype.h>
#include <stdlib.h>
#include <string.h>

#include "tmux.h"

static int
colour_dist_sq(int R, int G, int B, int r, int g, int b)
{
	return ((R - r) * (R - r) + (G - g) * (G - g) + (B - b) * (B - b));
}

static int
colour_to_6cube(int v)
{
	if (v < 48)
		return (0);
	if (v < 114)
		return (1);
	return ((v - 35) / 40);
}

/*
 * Convert an RGB triplet to the xterm(1) 256 colour palette.
 *
 * xterm provides a 6x6x6 colour cube (16 - 231) and 24 greys (232 - 255). We
 * map our RGB colour to the closest in the cube, also work out the closest
 * grey, and use the nearest of the two.
 *
 * Note that the xterm has much lower resolution for darker colours (they are
 * not evenly spread out), so our 6 levels are not evenly spread: 0x0, 0x5f
 * (95), 0x87 (135), 0xaf (175), 0xd7 (215) and 0xff (255). Greys are more
 * evenly spread (8, 18, 28 ... 238).
 */
int
colour_find_rgb(u_char r, u_char g, u_char b)
{
	static const int	q2c[6] = { 0x00, 0x5f, 0x87, 0xaf, 0xd7, 0xff };
	int			qr, qg, qb, cr, cg, cb, d, idx;
	int			grey_avg, grey_idx, grey;

	/* Map RGB to 6x6x6 cube. */
	qr = colour_to_6cube(r); cr = q2c[qr];
	qg = colour_to_6cube(g); cg = q2c[qg];
	qb = colour_to_6cube(b); cb = q2c[qb];

	/* If we have hit the colour exactly, return early. */
	if (cr == r && cg == g && cb == b)
		return ((16 + (36 * qr) + (6 * qg) + qb) | COLOUR_FLAG_256);

	/* Work out the closest grey (average of RGB). */
	grey_avg = (r + g + b) / 3;
	if (grey_avg > 238)
		grey_idx = 23;
	else
		grey_idx = (grey_avg - 3) / 10;
	grey = 8 + (10 * grey_idx);

	/* Is grey or 6x6x6 colour closest? */
	d = colour_dist_sq(cr, cg, cb, r, g, b);
	if (colour_dist_sq(grey, grey, grey, r, g, b) < d)
		idx = 232 + grey_idx;
	else
		idx = 16 + (36 * qr) + (6 * qg) + qb;
	return (idx | COLOUR_FLAG_256);
}

/* Join RGB into a colour. */
int
colour_join_rgb(u_char r, u_char g, u_char b)
{
	return ((((int)((r) & 0xff)) << 16) |
	    (((int)((g) & 0xff)) << 8) |
	    (((int)((b) & 0xff))) | COLOUR_FLAG_RGB);
}

/* Split colour into RGB. */
void
colour_split_rgb(int c, u_char *r, u_char *g, u_char *b)
{
	*r = (c >> 16) & 0xff;
	*g = (c >> 8) & 0xff;
	*b = c & 0xff;
}

/* Convert colour to a string. */
const char *
colour_tostring(int c)
{
	static char	s[32];
	u_char		r, g, b;

	if (c & COLOUR_FLAG_RGB) {
		colour_split_rgb(c, &r, &g, &b);
		xsnprintf(s, sizeof s, "#%02x%02x%02x", r, g, b);
		return (s);
	}

	if (c & COLOUR_FLAG_256) {
		xsnprintf(s, sizeof s, "colour%u", c & 0xff);
		return (s);
	}

	switch (c) {
	case 0:
		return ("black");
	case 1:
		return ("red");
	case 2:
		return ("green");
	case 3:
		return ("yellow");
	case 4:
		return ("blue");
	case 5:
		return ("magenta");
	case 6:
		return ("cyan");
	case 7:
		return ("white");
	case 8:
		return ("default");
	case 90:
		return ("brightblack");
	case 91:
		return ("brightred");
	case 92:
		return ("brightgreen");
	case 93:
		return ("brightyellow");
	case 94:
		return ("brightblue");
	case 95:
		return ("brightmagenta");
	case 96:
		return ("brightcyan");
	case 97:
		return ("brightwhite");
	}
	return (NULL);
}

/* Convert colour from string. */
int
colour_fromstring(const char *s)
{
	const char	*errstr;
	const char	*cp;
	int		 n;
	u_char		 r, g, b;

	if (*s == '#' && strlen(s) == 7) {
		for (cp = s + 1; isxdigit((u_char) *cp); cp++)
			;
		if (*cp != '\0')
			return (-1);
		n = sscanf(s + 1, "%2hhx%2hhx%2hhx", &r, &g, &b);
		if (n != 3)
			return (-1);
		return (colour_join_rgb(r, g, b));
	}

	if (strncasecmp(s, "colour", (sizeof "colour") - 1) == 0) {
		n = strtonum(s + (sizeof "colour") - 1, 0, 255, &errstr);
		if (errstr != NULL)
			return (-1);
		return (n | COLOUR_FLAG_256);
	}

	if (strcasecmp(s, "black") == 0 || strcmp(s, "0") == 0)
		return (0);
	if (strcasecmp(s, "red") == 0 || strcmp(s, "1") == 0)
		return (1);
	if (strcasecmp(s, "green") == 0 || strcmp(s, "2") == 0)
		return (2);
	if (strcasecmp(s, "yellow") == 0 || strcmp(s, "3") == 0)
		return (3);
	if (strcasecmp(s, "blue") == 0 || strcmp(s, "4") == 0)
		return (4);
	if (strcasecmp(s, "magenta") == 0 || strcmp(s, "5") == 0)
		return (5);
	if (strcasecmp(s, "cyan") == 0 || strcmp(s, "6") == 0)
		return (6);
	if (strcasecmp(s, "white") == 0 || strcmp(s, "7") == 0)
		return (7);
	if (strcasecmp(s, "default") == 0 || strcmp(s, "8") == 0)
		return (8);
	if (strcasecmp(s, "brightblack") == 0 || strcmp(s, "90") == 0)
		return (90);
	if (strcasecmp(s, "brightred") == 0 || strcmp(s, "91") == 0)
		return (91);
	if (strcasecmp(s, "brightgreen") == 0 || strcmp(s, "92") == 0)
		return (92);
	if (strcasecmp(s, "brightyellow") == 0 || strcmp(s, "93") == 0)
		return (93);
	if (strcasecmp(s, "brightblue") == 0 || strcmp(s, "94") == 0)
		return (94);
	if (strcasecmp(s, "brightmagenta") == 0 || strcmp(s, "95") == 0)
		return (95);
	if (strcasecmp(s, "brightcyan") == 0 || strcmp(s, "96") == 0)
		return (96);
	if (strcasecmp(s, "brightwhite") == 0 || strcmp(s, "97") == 0)
		return (97);
	return (-1);
}

/* Convert 256 colour palette to 16. */
u_char
colour_256to16(u_char c)
{
	static const u_char table[256] = {
		 0,  1,  2,  3,  4,  5,  6,  7,  8,  9, 10, 11, 12, 13, 14, 15,
		 0,  4,  4,  4, 12, 12,  2,  6,  4,  4, 12, 12,  2,  2,  6,  4,
		12, 12,  2,  2,  2,  6, 12, 12, 10, 10, 10, 10, 14, 12, 10, 10,
		10, 10, 10, 14,  1,  5,  4,  4, 12, 12,  3,  8,  4,  4, 12, 12,
		 2,  2,  6,  4, 12, 12,  2,  2,  2,  6, 12, 12, 10, 10, 10, 10,
		14, 12, 10, 10, 10, 10, 10, 14,  1,  1,  5,  4, 12, 12,  1,  1,
		 5,  4, 12, 12,  3,  3,  8,  4, 12, 12,  2,  2,  2,  6, 12, 12,
		10, 10, 10, 10, 14, 12, 10, 10, 10, 10, 10, 14,  1,  1,  1,  5,
		12, 12,  1,  1,  1,  5, 12, 12,  1,  1,  1,  5, 12, 12,  3,  3,
		 3,  7, 12, 12, 10, 10, 10, 10, 14, 12, 10, 10, 10, 10, 10, 14,
		 9,  9,  9,  9, 13, 12,  9,  9,  9,  9, 13, 12,  9,  9,  9,  9,
		13, 12,  9,  9,  9,  9, 13, 12, 11, 11, 11, 11,  7, 12, 10, 10,
		10, 10, 10, 14,  9,  9,  9,  9,  9, 13,  9,  9,  9,  9,  9, 13,
		 9,  9,  9,  9,  9, 13,  9,  9,  9,  9,  9, 13,  9,  9,  9,  9,
		 9, 13, 11, 11, 11, 11, 11, 15,  0,  0,  0,  0,  0,  0,  8,  8,
		 8,  8,  8,  8,  7,  7,  7,  7,  7,  7, 15, 15, 15, 15, 15, 15
	};

	return (table[c]);
}
@


1.14
log
@Instead of representing colours in several different forms with various
cell flags, convert to use an int with flags marking 256 or RGB colours
in the top byte (except in cells, which we don't want to make any
bigger). From Brad Town.
@
text
@d1 1
a1 1
/* $OpenBSD: colour.c,v 1.13 2016/06/06 10:12:58 nicm Exp $ */
d51 1
a51 1
 * Note that the xterm has much lower resolution for darker colors (they are
@


1.13
log
@Much faster (and smaller) method of mapping RGB colour to an xterm(1)
colour, from Avi Halachmi.
@
text
@d1 1
a1 1
/* $OpenBSD: colour.c,v 1.12 2016/01/19 15:59:12 nicm Exp $ */
d70 1
a70 1
		return (16 + (36 * qr) + (6 * qg) + qb);
d86 1
a86 1
	return (idx);
d89 3
a91 3
/* Set grid cell foreground colour. */
void
colour_set_fg(struct grid_cell *gc, int c)
d93 3
a95 3
	if (c & 0x100)
		gc->flags |= GRID_FLAG_FG256;
	gc->fg = c;
d98 1
a98 1
/* Set grid cell background colour. */
d100 1
a100 1
colour_set_bg(struct grid_cell *gc, int c)
d102 3
a104 3
	if (c & 0x100)
		gc->flags |= GRID_FLAG_BG256;
	gc->bg = c;
d112 7
d120 2
a121 2
	if (c & 0x100) {
		xsnprintf(s, sizeof s, "colour%d", c & ~0x100);
d181 1
a181 1
		return (colour_find_rgb(r, g, b) | 0x100);
d188 1
a188 1
		return (n | 0x100);
@


1.12
log
@I no longer use my SourceForge address so replace it.
@
text
@d1 1
a1 1
/* $OpenBSD: colour.c,v 1.11 2015/06/05 22:50:27 nicm Exp $ */
d5 1
d28 5
a32 256
/*
 * Colour to string conversion functions. Bit 8 of the colour means it is one
 * of the 256 colour palette.
 */

struct colour_rgb {
	u_char  i;
	u_char	r;
	u_char	g;
	u_char	b;
};

const struct colour_rgb colour_from_256[] = {
	{   0, 0x00, 0x00, 0x00 }, {   1, 0x00, 0x00, 0x5f },
	{   2, 0x00, 0x00, 0x87 }, {   3, 0x00, 0x00, 0xaf },
	{   4, 0x00, 0x00, 0xd7 }, {   5, 0x00, 0x00, 0xff },
	{   6, 0x00, 0x5f, 0x00 }, {   7, 0x00, 0x5f, 0x5f },
	{   8, 0x00, 0x5f, 0x87 }, {   9, 0x00, 0x5f, 0xaf },
	{  10, 0x00, 0x5f, 0xd7 }, {  11, 0x00, 0x5f, 0xff },
	{  12, 0x00, 0x87, 0x00 }, {  13, 0x00, 0x87, 0x5f },
	{  14, 0x00, 0x87, 0x87 }, {  15, 0x00, 0x87, 0xaf },
	{  16, 0x00, 0x87, 0xd7 }, {  17, 0x00, 0x87, 0xff },
	{  18, 0x00, 0xaf, 0x00 }, {  19, 0x00, 0xaf, 0x5f },
	{  20, 0x00, 0xaf, 0x87 }, {  21, 0x00, 0xaf, 0xaf },
	{  22, 0x00, 0xaf, 0xd7 }, {  23, 0x00, 0xaf, 0xff },
	{  24, 0x00, 0xd7, 0x00 }, {  25, 0x00, 0xd7, 0x5f },
	{  26, 0x00, 0xd7, 0x87 }, {  27, 0x00, 0xd7, 0xaf },
	{  28, 0x00, 0xd7, 0xd7 }, {  29, 0x00, 0xd7, 0xff },
	{  30, 0x00, 0xff, 0x00 }, {  31, 0x00, 0xff, 0x5f },
	{  32, 0x00, 0xff, 0x87 }, {  33, 0x00, 0xff, 0xaf },
	{  34, 0x00, 0xff, 0xd7 }, {  35, 0x00, 0xff, 0xff },
	{  36, 0x5f, 0x00, 0x00 }, {  37, 0x5f, 0x00, 0x5f },
	{  38, 0x5f, 0x00, 0x87 }, {  39, 0x5f, 0x00, 0xaf },
	{  40, 0x5f, 0x00, 0xd7 }, {  41, 0x5f, 0x00, 0xff },
	{  42, 0x5f, 0x5f, 0x00 }, {  43, 0x5f, 0x5f, 0x5f },
	{  44, 0x5f, 0x5f, 0x87 }, {  45, 0x5f, 0x5f, 0xaf },
	{  46, 0x5f, 0x5f, 0xd7 }, {  47, 0x5f, 0x5f, 0xff },
	{  48, 0x5f, 0x87, 0x00 }, {  49, 0x5f, 0x87, 0x5f },
	{  50, 0x5f, 0x87, 0x87 }, {  51, 0x5f, 0x87, 0xaf },
	{  52, 0x5f, 0x87, 0xd7 }, {  53, 0x5f, 0x87, 0xff },
	{  54, 0x5f, 0xaf, 0x00 }, {  55, 0x5f, 0xaf, 0x5f },
	{  56, 0x5f, 0xaf, 0x87 }, {  57, 0x5f, 0xaf, 0xaf },
	{  58, 0x5f, 0xaf, 0xd7 }, {  59, 0x5f, 0xaf, 0xff },
	{  60, 0x5f, 0xd7, 0x00 }, {  61, 0x5f, 0xd7, 0x5f },
	{  62, 0x5f, 0xd7, 0x87 }, {  63, 0x5f, 0xd7, 0xaf },
	{  64, 0x5f, 0xd7, 0xd7 }, {  65, 0x5f, 0xd7, 0xff },
	{  66, 0x5f, 0xff, 0x00 }, {  67, 0x5f, 0xff, 0x5f },
	{  68, 0x5f, 0xff, 0x87 }, {  69, 0x5f, 0xff, 0xaf },
	{  70, 0x5f, 0xff, 0xd7 }, {  71, 0x5f, 0xff, 0xff },
	{  72, 0x87, 0x00, 0x00 }, {  73, 0x87, 0x00, 0x5f },
	{  74, 0x87, 0x00, 0x87 }, {  75, 0x87, 0x00, 0xaf },
	{  76, 0x87, 0x00, 0xd7 }, {  77, 0x87, 0x00, 0xff },
	{  78, 0x87, 0x5f, 0x00 }, {  79, 0x87, 0x5f, 0x5f },
	{  80, 0x87, 0x5f, 0x87 }, {  81, 0x87, 0x5f, 0xaf },
	{  82, 0x87, 0x5f, 0xd7 }, {  83, 0x87, 0x5f, 0xff },
	{  84, 0x87, 0x87, 0x00 }, {  85, 0x87, 0x87, 0x5f },
	{  86, 0x87, 0x87, 0x87 }, {  87, 0x87, 0x87, 0xaf },
	{  88, 0x87, 0x87, 0xd7 }, {  89, 0x87, 0x87, 0xff },
	{  90, 0x87, 0xaf, 0x00 }, {  91, 0x87, 0xaf, 0x5f },
	{  92, 0x87, 0xaf, 0x87 }, {  93, 0x87, 0xaf, 0xaf },
	{  94, 0x87, 0xaf, 0xd7 }, {  95, 0x87, 0xaf, 0xff },
	{  96, 0x87, 0xd7, 0x00 }, {  97, 0x87, 0xd7, 0x5f },
	{  98, 0x87, 0xd7, 0x87 }, {  99, 0x87, 0xd7, 0xaf },
	{ 100, 0x87, 0xd7, 0xd7 }, { 101, 0x87, 0xd7, 0xff },
	{ 102, 0x87, 0xff, 0x00 }, { 103, 0x87, 0xff, 0x5f },
	{ 104, 0x87, 0xff, 0x87 }, { 105, 0x87, 0xff, 0xaf },
	{ 106, 0x87, 0xff, 0xd7 }, { 107, 0x87, 0xff, 0xff },
	{ 108, 0xaf, 0x00, 0x00 }, { 109, 0xaf, 0x00, 0x5f },
	{ 110, 0xaf, 0x00, 0x87 }, { 111, 0xaf, 0x00, 0xaf },
	{ 112, 0xaf, 0x00, 0xd7 }, { 113, 0xaf, 0x00, 0xff },
	{ 114, 0xaf, 0x5f, 0x00 }, { 115, 0xaf, 0x5f, 0x5f },
	{ 116, 0xaf, 0x5f, 0x87 }, { 117, 0xaf, 0x5f, 0xaf },
	{ 118, 0xaf, 0x5f, 0xd7 }, { 119, 0xaf, 0x5f, 0xff },
	{ 120, 0xaf, 0x87, 0x00 }, { 121, 0xaf, 0x87, 0x5f },
	{ 122, 0xaf, 0x87, 0x87 }, { 123, 0xaf, 0x87, 0xaf },
	{ 124, 0xaf, 0x87, 0xd7 }, { 125, 0xaf, 0x87, 0xff },
	{ 126, 0xaf, 0xaf, 0x00 }, { 127, 0xaf, 0xaf, 0x5f },
	{ 128, 0xaf, 0xaf, 0x87 }, { 129, 0xaf, 0xaf, 0xaf },
	{ 130, 0xaf, 0xaf, 0xd7 }, { 131, 0xaf, 0xaf, 0xff },
	{ 132, 0xaf, 0xd7, 0x00 }, { 133, 0xaf, 0xd7, 0x5f },
	{ 134, 0xaf, 0xd7, 0x87 }, { 135, 0xaf, 0xd7, 0xaf },
	{ 136, 0xaf, 0xd7, 0xd7 }, { 137, 0xaf, 0xd7, 0xff },
	{ 138, 0xaf, 0xff, 0x00 }, { 139, 0xaf, 0xff, 0x5f },
	{ 140, 0xaf, 0xff, 0x87 }, { 141, 0xaf, 0xff, 0xaf },
	{ 142, 0xaf, 0xff, 0xd7 }, { 143, 0xaf, 0xff, 0xff },
	{ 144, 0xd7, 0x00, 0x00 }, { 145, 0xd7, 0x00, 0x5f },
	{ 146, 0xd7, 0x00, 0x87 }, { 147, 0xd7, 0x00, 0xaf },
	{ 148, 0xd7, 0x00, 0xd7 }, { 149, 0xd7, 0x00, 0xff },
	{ 150, 0xd7, 0x5f, 0x00 }, { 151, 0xd7, 0x5f, 0x5f },
	{ 152, 0xd7, 0x5f, 0x87 }, { 153, 0xd7, 0x5f, 0xaf },
	{ 154, 0xd7, 0x5f, 0xd7 }, { 155, 0xd7, 0x5f, 0xff },
	{ 156, 0xd7, 0x87, 0x00 }, { 157, 0xd7, 0x87, 0x5f },
	{ 158, 0xd7, 0x87, 0x87 }, { 159, 0xd7, 0x87, 0xaf },
	{ 160, 0xd7, 0x87, 0xd7 }, { 161, 0xd7, 0x87, 0xff },
	{ 162, 0xd7, 0xaf, 0x00 }, { 163, 0xd7, 0xaf, 0x5f },
	{ 164, 0xd7, 0xaf, 0x87 }, { 165, 0xd7, 0xaf, 0xaf },
	{ 166, 0xd7, 0xaf, 0xd7 }, { 167, 0xd7, 0xaf, 0xff },
	{ 168, 0xd7, 0xd7, 0x00 }, { 169, 0xd7, 0xd7, 0x5f },
	{ 170, 0xd7, 0xd7, 0x87 }, { 171, 0xd7, 0xd7, 0xaf },
	{ 172, 0xd7, 0xd7, 0xd7 }, { 173, 0xd7, 0xd7, 0xff },
	{ 174, 0xd7, 0xff, 0x00 }, { 175, 0xd7, 0xff, 0x5f },
	{ 176, 0xd7, 0xff, 0x87 }, { 177, 0xd7, 0xff, 0xaf },
	{ 178, 0xd7, 0xff, 0xd7 }, { 179, 0xd7, 0xff, 0xff },
	{ 180, 0xff, 0x00, 0x00 }, { 181, 0xff, 0x00, 0x5f },
	{ 182, 0xff, 0x00, 0x87 }, { 183, 0xff, 0x00, 0xaf },
	{ 184, 0xff, 0x00, 0xd7 }, { 185, 0xff, 0x00, 0xff },
	{ 186, 0xff, 0x5f, 0x00 }, { 187, 0xff, 0x5f, 0x5f },
	{ 188, 0xff, 0x5f, 0x87 }, { 189, 0xff, 0x5f, 0xaf },
	{ 190, 0xff, 0x5f, 0xd7 }, { 191, 0xff, 0x5f, 0xff },
	{ 192, 0xff, 0x87, 0x00 }, { 193, 0xff, 0x87, 0x5f },
	{ 194, 0xff, 0x87, 0x87 }, { 195, 0xff, 0x87, 0xaf },
	{ 196, 0xff, 0x87, 0xd7 }, { 197, 0xff, 0x87, 0xff },
	{ 198, 0xff, 0xaf, 0x00 }, { 199, 0xff, 0xaf, 0x5f },
	{ 200, 0xff, 0xaf, 0x87 }, { 201, 0xff, 0xaf, 0xaf },
	{ 202, 0xff, 0xaf, 0xd7 }, { 203, 0xff, 0xaf, 0xff },
	{ 204, 0xff, 0xd7, 0x00 }, { 205, 0xff, 0xd7, 0x5f },
	{ 206, 0xff, 0xd7, 0x87 }, { 207, 0xff, 0xd7, 0xaf },
	{ 208, 0xff, 0xd7, 0xd7 }, { 209, 0xff, 0xd7, 0xff },
	{ 210, 0xff, 0xff, 0x00 }, { 211, 0xff, 0xff, 0x5f },
	{ 212, 0xff, 0xff, 0x87 }, { 213, 0xff, 0xff, 0xaf },
	{ 214, 0xff, 0xff, 0xd7 }, { 215, 0xff, 0xff, 0xff },
	{ 216, 0x08, 0x08, 0x08 }, { 217, 0x12, 0x12, 0x12 },
	{ 218, 0x1c, 0x1c, 0x1c }, { 219, 0x26, 0x26, 0x26 },
	{ 220, 0x30, 0x30, 0x30 }, { 221, 0x3a, 0x3a, 0x3a },
	{ 222, 0x44, 0x44, 0x44 }, { 223, 0x4e, 0x4e, 0x4e },
	{ 224, 0x58, 0x58, 0x58 }, { 225, 0x62, 0x62, 0x62 },
	{ 226, 0x6c, 0x6c, 0x6c }, { 227, 0x76, 0x76, 0x76 },
	{ 228, 0x80, 0x80, 0x80 }, { 229, 0x8a, 0x8a, 0x8a },
	{ 230, 0x94, 0x94, 0x94 }, { 231, 0x9e, 0x9e, 0x9e },
	{ 232, 0xa8, 0xa8, 0xa8 }, { 233, 0xb2, 0xb2, 0xb2 },
	{ 234, 0xbc, 0xbc, 0xbc }, { 235, 0xc6, 0xc6, 0xc6 },
	{ 236, 0xd0, 0xd0, 0xd0 }, { 237, 0xda, 0xda, 0xda },
	{ 238, 0xe4, 0xe4, 0xe4 }, { 239, 0xee, 0xee, 0xee },
};
const struct colour_rgb colour_to_256[] = {
	{   0, 0x00, 0x00, 0x00 }, {   1, 0x00, 0x00, 0x5f },
	{   2, 0x00, 0x00, 0x87 }, {   3, 0x00, 0x00, 0xaf },
	{   4, 0x00, 0x00, 0xd7 }, {   5, 0x00, 0x00, 0xff },
	{   6, 0x00, 0x5f, 0x00 }, {   7, 0x00, 0x5f, 0x5f },
	{   8, 0x00, 0x5f, 0x87 }, {   9, 0x00, 0x5f, 0xaf },
	{  10, 0x00, 0x5f, 0xd7 }, {  11, 0x00, 0x5f, 0xff },
	{  12, 0x00, 0x87, 0x00 }, {  13, 0x00, 0x87, 0x5f },
	{  14, 0x00, 0x87, 0x87 }, {  15, 0x00, 0x87, 0xaf },
	{  16, 0x00, 0x87, 0xd7 }, {  17, 0x00, 0x87, 0xff },
	{  18, 0x00, 0xaf, 0x00 }, {  19, 0x00, 0xaf, 0x5f },
	{  20, 0x00, 0xaf, 0x87 }, {  21, 0x00, 0xaf, 0xaf },
	{  22, 0x00, 0xaf, 0xd7 }, {  23, 0x00, 0xaf, 0xff },
	{  24, 0x00, 0xd7, 0x00 }, {  25, 0x00, 0xd7, 0x5f },
	{  26, 0x00, 0xd7, 0x87 }, {  27, 0x00, 0xd7, 0xaf },
	{  28, 0x00, 0xd7, 0xd7 }, {  29, 0x00, 0xd7, 0xff },
	{  30, 0x00, 0xff, 0x00 }, {  31, 0x00, 0xff, 0x5f },
	{  32, 0x00, 0xff, 0x87 }, {  33, 0x00, 0xff, 0xaf },
	{  34, 0x00, 0xff, 0xd7 }, {  35, 0x00, 0xff, 0xff },
	{ 216, 0x08, 0x08, 0x08 }, { 217, 0x12, 0x12, 0x12 },
	{ 218, 0x1c, 0x1c, 0x1c }, { 219, 0x26, 0x26, 0x26 },
	{ 220, 0x30, 0x30, 0x30 }, { 221, 0x3a, 0x3a, 0x3a },
	{ 222, 0x44, 0x44, 0x44 }, { 223, 0x4e, 0x4e, 0x4e },
	{ 224, 0x58, 0x58, 0x58 }, {  36, 0x5f, 0x00, 0x00 },
	{  37, 0x5f, 0x00, 0x5f }, {  38, 0x5f, 0x00, 0x87 },
	{  39, 0x5f, 0x00, 0xaf }, {  40, 0x5f, 0x00, 0xd7 },
	{  41, 0x5f, 0x00, 0xff }, {  42, 0x5f, 0x5f, 0x00 },
	{  43, 0x5f, 0x5f, 0x5f }, {  44, 0x5f, 0x5f, 0x87 },
	{  45, 0x5f, 0x5f, 0xaf }, {  46, 0x5f, 0x5f, 0xd7 },
	{  47, 0x5f, 0x5f, 0xff }, {  48, 0x5f, 0x87, 0x00 },
	{  49, 0x5f, 0x87, 0x5f }, {  50, 0x5f, 0x87, 0x87 },
	{  51, 0x5f, 0x87, 0xaf }, {  52, 0x5f, 0x87, 0xd7 },
	{  53, 0x5f, 0x87, 0xff }, {  54, 0x5f, 0xaf, 0x00 },
	{  55, 0x5f, 0xaf, 0x5f }, {  56, 0x5f, 0xaf, 0x87 },
	{  57, 0x5f, 0xaf, 0xaf }, {  58, 0x5f, 0xaf, 0xd7 },
	{  59, 0x5f, 0xaf, 0xff }, {  60, 0x5f, 0xd7, 0x00 },
	{  61, 0x5f, 0xd7, 0x5f }, {  62, 0x5f, 0xd7, 0x87 },
	{  63, 0x5f, 0xd7, 0xaf }, {  64, 0x5f, 0xd7, 0xd7 },
	{  65, 0x5f, 0xd7, 0xff }, {  66, 0x5f, 0xff, 0x00 },
	{  67, 0x5f, 0xff, 0x5f }, {  68, 0x5f, 0xff, 0x87 },
	{  69, 0x5f, 0xff, 0xaf }, {  70, 0x5f, 0xff, 0xd7 },
	{  71, 0x5f, 0xff, 0xff }, { 225, 0x62, 0x62, 0x62 },
	{ 226, 0x6c, 0x6c, 0x6c }, { 227, 0x76, 0x76, 0x76 },
	{ 228, 0x80, 0x80, 0x80 }, {  72, 0x87, 0x00, 0x00 },
	{  73, 0x87, 0x00, 0x5f }, {  74, 0x87, 0x00, 0x87 },
	{  75, 0x87, 0x00, 0xaf }, {  76, 0x87, 0x00, 0xd7 },
	{  77, 0x87, 0x00, 0xff }, {  78, 0x87, 0x5f, 0x00 },
	{  79, 0x87, 0x5f, 0x5f }, {  80, 0x87, 0x5f, 0x87 },
	{  81, 0x87, 0x5f, 0xaf }, {  82, 0x87, 0x5f, 0xd7 },
	{  83, 0x87, 0x5f, 0xff }, {  84, 0x87, 0x87, 0x00 },
	{  85, 0x87, 0x87, 0x5f }, {  86, 0x87, 0x87, 0x87 },
	{  87, 0x87, 0x87, 0xaf }, {  88, 0x87, 0x87, 0xd7 },
	{  89, 0x87, 0x87, 0xff }, {  90, 0x87, 0xaf, 0x00 },
	{  91, 0x87, 0xaf, 0x5f }, {  92, 0x87, 0xaf, 0x87 },
	{  93, 0x87, 0xaf, 0xaf }, {  94, 0x87, 0xaf, 0xd7 },
	{  95, 0x87, 0xaf, 0xff }, {  96, 0x87, 0xd7, 0x00 },
	{  97, 0x87, 0xd7, 0x5f }, {  98, 0x87, 0xd7, 0x87 },
	{  99, 0x87, 0xd7, 0xaf }, { 100, 0x87, 0xd7, 0xd7 },
	{ 101, 0x87, 0xd7, 0xff }, { 102, 0x87, 0xff, 0x00 },
	{ 103, 0x87, 0xff, 0x5f }, { 104, 0x87, 0xff, 0x87 },
	{ 105, 0x87, 0xff, 0xaf }, { 106, 0x87, 0xff, 0xd7 },
	{ 107, 0x87, 0xff, 0xff }, { 229, 0x8a, 0x8a, 0x8a },
	{ 230, 0x94, 0x94, 0x94 }, { 231, 0x9e, 0x9e, 0x9e },
	{ 232, 0xa8, 0xa8, 0xa8 }, { 108, 0xaf, 0x00, 0x00 },
	{ 109, 0xaf, 0x00, 0x5f }, { 110, 0xaf, 0x00, 0x87 },
	{ 111, 0xaf, 0x00, 0xaf }, { 112, 0xaf, 0x00, 0xd7 },
	{ 113, 0xaf, 0x00, 0xff }, { 114, 0xaf, 0x5f, 0x00 },
	{ 115, 0xaf, 0x5f, 0x5f }, { 116, 0xaf, 0x5f, 0x87 },
	{ 117, 0xaf, 0x5f, 0xaf }, { 118, 0xaf, 0x5f, 0xd7 },
	{ 119, 0xaf, 0x5f, 0xff }, { 120, 0xaf, 0x87, 0x00 },
	{ 121, 0xaf, 0x87, 0x5f }, { 122, 0xaf, 0x87, 0x87 },
	{ 123, 0xaf, 0x87, 0xaf }, { 124, 0xaf, 0x87, 0xd7 },
	{ 125, 0xaf, 0x87, 0xff }, { 126, 0xaf, 0xaf, 0x00 },
	{ 127, 0xaf, 0xaf, 0x5f }, { 128, 0xaf, 0xaf, 0x87 },
	{ 129, 0xaf, 0xaf, 0xaf }, { 130, 0xaf, 0xaf, 0xd7 },
	{ 131, 0xaf, 0xaf, 0xff }, { 132, 0xaf, 0xd7, 0x00 },
	{ 133, 0xaf, 0xd7, 0x5f }, { 134, 0xaf, 0xd7, 0x87 },
	{ 135, 0xaf, 0xd7, 0xaf }, { 136, 0xaf, 0xd7, 0xd7 },
	{ 137, 0xaf, 0xd7, 0xff }, { 138, 0xaf, 0xff, 0x00 },
	{ 139, 0xaf, 0xff, 0x5f }, { 140, 0xaf, 0xff, 0x87 },
	{ 141, 0xaf, 0xff, 0xaf }, { 142, 0xaf, 0xff, 0xd7 },
	{ 143, 0xaf, 0xff, 0xff }, { 233, 0xb2, 0xb2, 0xb2 },
	{ 234, 0xbc, 0xbc, 0xbc }, { 235, 0xc6, 0xc6, 0xc6 },
	{ 236, 0xd0, 0xd0, 0xd0 }, { 144, 0xd7, 0x00, 0x00 },
	{ 145, 0xd7, 0x00, 0x5f }, { 146, 0xd7, 0x00, 0x87 },
	{ 147, 0xd7, 0x00, 0xaf }, { 148, 0xd7, 0x00, 0xd7 },
	{ 149, 0xd7, 0x00, 0xff }, { 150, 0xd7, 0x5f, 0x00 },
	{ 151, 0xd7, 0x5f, 0x5f }, { 152, 0xd7, 0x5f, 0x87 },
	{ 153, 0xd7, 0x5f, 0xaf }, { 154, 0xd7, 0x5f, 0xd7 },
	{ 155, 0xd7, 0x5f, 0xff }, { 156, 0xd7, 0x87, 0x00 },
	{ 157, 0xd7, 0x87, 0x5f }, { 158, 0xd7, 0x87, 0x87 },
	{ 159, 0xd7, 0x87, 0xaf }, { 160, 0xd7, 0x87, 0xd7 },
	{ 161, 0xd7, 0x87, 0xff }, { 162, 0xd7, 0xaf, 0x00 },
	{ 163, 0xd7, 0xaf, 0x5f }, { 164, 0xd7, 0xaf, 0x87 },
	{ 165, 0xd7, 0xaf, 0xaf }, { 166, 0xd7, 0xaf, 0xd7 },
	{ 167, 0xd7, 0xaf, 0xff }, { 168, 0xd7, 0xd7, 0x00 },
	{ 169, 0xd7, 0xd7, 0x5f }, { 170, 0xd7, 0xd7, 0x87 },
	{ 171, 0xd7, 0xd7, 0xaf }, { 172, 0xd7, 0xd7, 0xd7 },
	{ 173, 0xd7, 0xd7, 0xff }, { 174, 0xd7, 0xff, 0x00 },
	{ 175, 0xd7, 0xff, 0x5f }, { 176, 0xd7, 0xff, 0x87 },
	{ 177, 0xd7, 0xff, 0xaf }, { 178, 0xd7, 0xff, 0xd7 },
	{ 179, 0xd7, 0xff, 0xff }, { 237, 0xda, 0xda, 0xda },
	{ 238, 0xe4, 0xe4, 0xe4 }, { 239, 0xee, 0xee, 0xee },
	{ 180, 0xff, 0x00, 0x00 }, { 181, 0xff, 0x00, 0x5f },
	{ 182, 0xff, 0x00, 0x87 }, { 183, 0xff, 0x00, 0xaf },
	{ 184, 0xff, 0x00, 0xd7 }, { 185, 0xff, 0x00, 0xff },
	{ 186, 0xff, 0x5f, 0x00 }, { 187, 0xff, 0x5f, 0x5f },
	{ 188, 0xff, 0x5f, 0x87 }, { 189, 0xff, 0x5f, 0xaf },
	{ 190, 0xff, 0x5f, 0xd7 }, { 191, 0xff, 0x5f, 0xff },
	{ 192, 0xff, 0x87, 0x00 }, { 193, 0xff, 0x87, 0x5f },
	{ 194, 0xff, 0x87, 0x87 }, { 195, 0xff, 0x87, 0xaf },
	{ 196, 0xff, 0x87, 0xd7 }, { 197, 0xff, 0x87, 0xff },
	{ 198, 0xff, 0xaf, 0x00 }, { 199, 0xff, 0xaf, 0x5f },
	{ 200, 0xff, 0xaf, 0x87 }, { 201, 0xff, 0xaf, 0xaf },
	{ 202, 0xff, 0xaf, 0xd7 }, { 203, 0xff, 0xaf, 0xff },
	{ 204, 0xff, 0xd7, 0x00 }, { 205, 0xff, 0xd7, 0x5f },
	{ 206, 0xff, 0xd7, 0x87 }, { 207, 0xff, 0xd7, 0xaf },
	{ 208, 0xff, 0xd7, 0xd7 }, { 209, 0xff, 0xd7, 0xff },
	{ 210, 0xff, 0xff, 0x00 }, { 211, 0xff, 0xff, 0x5f },
	{ 212, 0xff, 0xff, 0x87 }, { 213, 0xff, 0xff, 0xaf },
	{ 214, 0xff, 0xff, 0xd7 }, { 215, 0xff, 0xff, 0xff },
};
d34 2
a35 5
int	colour_cmp_rgb(const void *, const void *);

/* Compare function for bsearch(). */
int
colour_cmp_rgb(const void *lhs0, const void *rhs0)
d37 3
a39 5
	const struct colour_rgb *lhs = lhs0, *rhs = rhs0;

	if (lhs->r < rhs->r)
		return (-1);
	if (lhs->r > rhs->r)
d41 1
a41 12

	if (lhs->g < rhs->g)
		return (-1);
	if (lhs->g > rhs->g)
		return (1);

	if (lhs->b < rhs->b)
		return (-1);
	if (lhs->b > rhs->b)
		return (1);

	return (0);
d44 12
a55 1
/* Work out the nearest colour from the 256 colour set. */
d59 28
a86 23
	struct colour_rgb	rgb = { .r = r, .g = g, .b = b }, *found;
	u_int			distance, lowest, colour, i;
	int			dr, dg, db;

	found = bsearch(&rgb, colour_to_256, nitems(colour_to_256),
	    sizeof colour_to_256[0], colour_cmp_rgb);
	if (found != NULL)
		return (16 + found->i);

	colour = 16;
	lowest = UINT_MAX;
	for (i = 0; i < 240; i++) {
		dr = (int)colour_from_256[i].r - r;
		dg = (int)colour_from_256[i].g - g;
		db = (int)colour_from_256[i].b - b;

		distance = dr * dr + dg * dg + db * db;
		if (distance < lowest) {
			lowest = distance;
			colour = 16 + i;
		}
	}
	return (colour);
@


1.11
log
@Use ints for the calculations rather than u_char, they could end up
signed.
@
text
@d1 1
a1 1
/* $OpenBSD: colour.c,v 1.10 2015/06/05 22:33:39 nicm Exp $ */
d4 1
a4 1
 * Copyright (c) 2008 Nicholas Marriott <nicm@@users.sourceforge.net>
@


1.10
log
@Handle the RGB colour escape sequence (\033[38;2;<r>;<g>;<b>m and 48;2)
like xterm(1) does, by mapping to the nearest in the 256 colour palette.
@
text
@d1 1
a1 1
/* $OpenBSD: colour.c,v 1.9 2015/06/05 22:01:17 nicm Exp $ */
d316 1
d326 3
a328 3
		r = colour_from_256[i].r - rgb.r;
		g = colour_from_256[i].g - rgb.g;
		b = colour_from_256[i].b - rgb.b;
d330 1
a330 1
		distance = r * r + g * g + b * b;
@


1.9
log
@Use fixed colour tables rather than generated and do a quick search for
exact match before doing the distance comparison.
@
text
@d1 1
a1 1
/* $OpenBSD: colour.c,v 1.8 2015/03/31 17:45:10 nicm Exp $ */
d284 1
a284 2
int	colour_rgb_cmp(const void *, const void *);
int	colour_rgb_find(struct colour_rgb *);
d288 1
a288 1
colour_rgb_cmp(const void *lhs0, const void *rhs0)
d312 1
a312 1
colour_rgb_find(struct colour_rgb *rgb)
d314 2
a315 3
	struct colour_rgb	*found;
	u_int			 distance, lowest, colour, i;
	int			 r, g, b;
d317 2
a318 2
	found = bsearch(rgb, colour_to_256, nitems(colour_to_256),
	    sizeof colour_to_256[0], colour_rgb_cmp);
d325 3
a327 3
		r = colour_from_256[i].r - rgb->r;
		g = colour_from_256[i].g - rgb->g;
		b = colour_from_256[i].b - rgb->b;
d410 4
a413 4
	const char		*errstr;
	const char		*cp;
	struct colour_rgb	 rgb;
	int			 n;
d420 1
a420 1
		n = sscanf(s + 1, "%2hhx%2hhx%2hhx", &rgb.r, &rgb.g, &rgb.b);
d423 1
a423 1
		return (colour_rgb_find(&rgb) | 0x100);
@


1.8
log
@Fix some format specifier nits, from Ben Boeckel.
@
text
@d1 1
a1 1
/* $OpenBSD: colour.c,v 1.7 2015/02/07 23:43:41 nicm Exp $ */
a31 1
/* An RGB colour. */
d33 1
d39 244
a282 2
/* 256 colour RGB table, generated on first use. */
struct colour_rgb *colour_rgb_256;
d284 1
a284 2
void	colour_rgb_generate256(void);
u_int	colour_rgb_distance(struct colour_rgb *, struct colour_rgb *);
d287 3
a289 3
/* Generate 256 colour RGB table. */
void
colour_rgb_generate256(void)
d291 1
a291 2
	struct colour_rgb	*rgb;
	u_int			 i, r, g, b;
d293 4
a296 28
	/*
	 * Allocate the table. The first 16 colours are often changed by users
	 * and terminals so don't include them.
	 */
	colour_rgb_256 = xcalloc(240, sizeof *colour_rgb_256);

	/* Add the colours first. */
	r = g = b = 0;
	for (i = 240; i > 24; i--) {
		rgb = &colour_rgb_256[240 - i];

		if (r != 0)
			rgb->r = (r * 40) + 55;
		if (g != 0)
			rgb->g = (g * 40) + 55;
		if (b != 0)
			rgb->b = (b * 40) + 55;

		b++;
		if (b > 5) {
			b = 0;
			g++;
		}
		if (g > 5) {
			g = 0;
			r++;
		}
	}
d298 4
a301 9
	/* Then add the greys. */
	for (i = 24; i > 0; i--) {
		rgb = &colour_rgb_256[240 - i];

		rgb->r = 8 + (24 - i) * 10;
		rgb->g = 8 + (24 - i) * 10;
		rgb->b = 8 + (24 - i) * 10;
	}
}
d303 4
a306 5
/* Get colour RGB distance. */
u_int
colour_rgb_distance(struct colour_rgb *rgb1, struct colour_rgb *rgb2)
{
	int	r, g, b;
d308 1
a308 4
	r = rgb1->r - rgb2->r;
	g = rgb1->g - rgb2->g;
	b = rgb1->b - rgb2->b;
	return (r * r + g * g + b * b);
d315 8
a322 4
	u_int	distance, lowest, colour, i;

	if (colour_rgb_256 == NULL)
		colour_rgb_generate256();
d327 5
a331 1
		distance = colour_rgb_distance(&colour_rgb_256[i], rgb);
d435 1
a435 1
	if (strcasecmp(s, "black") == 0 || (s[0] == '0' && s[1] == '\0'))
d437 1
a437 1
	if (strcasecmp(s, "red") == 0 || (s[0] == '1' && s[1] == '\0'))
d439 1
a439 1
	if (strcasecmp(s, "green") == 0 || (s[0] == '2' && s[1] == '\0'))
d441 1
a441 1
	if (strcasecmp(s, "yellow") == 0 || (s[0] == '3' && s[1] == '\0'))
d443 1
a443 1
	if (strcasecmp(s, "blue") == 0 || (s[0] == '4' && s[1] == '\0'))
d445 1
a445 1
	if (strcasecmp(s, "magenta") == 0 || (s[0] == '5' && s[1] == '\0'))
d447 1
a447 1
	if (strcasecmp(s, "cyan") == 0 || (s[0] == '6' && s[1] == '\0'))
d449 1
a449 1
	if (strcasecmp(s, "white") == 0 || (s[0] == '7' && s[1] == '\0'))
d451 1
a451 1
	if (strcasecmp(s, "default") == 0 || (s[0] == '8' && s[1] == '\0'))
d453 1
a453 2
	if (strcasecmp(s, "brightblack") == 0 ||
	    (s[0] == '9' && s[1] == '0' && s[2] == '\0'))
d455 1
a455 2
	if (strcasecmp(s, "brightred") == 0 ||
	    (s[0] == '9' && s[1] == '1' && s[2] == '\0'))
d457 1
a457 2
	if (strcasecmp(s, "brightgreen") == 0 ||
	    (s[0] == '9' && s[1] == '2' && s[2] == '\0'))
d459 1
a459 2
	if (strcasecmp(s, "brightyellow") == 0 ||
	    (s[0] == '9' && s[1] == '3' && s[2] == '\0'))
d461 1
a461 2
	if (strcasecmp(s, "brightblue") == 0 ||
	    (s[0] == '9' && s[1] == '4' && s[2] == '\0'))
d463 1
a463 2
	if (strcasecmp(s, "brightmagenta") == 0 ||
	    (s[0] == '9' && s[1] == '5' && s[2] == '\0'))
d465 1
a465 2
	if (strcasecmp(s, "brightcyan") == 0 ||
	    (s[0] == '9' && s[1] == '6' && s[2] == '\0'))
d467 1
a467 2
	if (strcasecmp(s, "brightwhite") == 0 ||
	    (s[0] == '9' && s[1] == '7' && s[2] == '\0'))
@


1.7
log
@Check for \0 in the right place, from J Raynor.
@
text
@d1 1
a1 1
/* $OpenBSD: colour.c,v 1.6 2013/03/27 11:17:12 nicm Exp $ */
d150 1
a150 1
		xsnprintf(s, sizeof s, "colour%u", c & ~0x100);
@


1.6
log
@Remove tmux's (already minimal) 88 colour support. Such terminals are
few and unnecessary.
@
text
@d1 1
a1 1
/* $OpenBSD: colour.c,v 1.5 2012/01/21 08:23:12 nicm Exp $ */
d239 1
a239 1
	    (s[0] == '9' && s[1] == '0' && s[1] == '\0'))
d242 1
a242 1
	    (s[0] == '9' && s[1] == '1' && s[1] == '\0'))
d245 1
a245 1
	    (s[0] == '9' && s[1] == '2' && s[1] == '\0'))
d248 1
a248 1
	    (s[0] == '9' && s[1] == '3' && s[1] == '\0'))
d251 1
a251 1
	    (s[0] == '9' && s[1] == '4' && s[1] == '\0'))
d254 1
a254 1
	    (s[0] == '9' && s[1] == '5' && s[1] == '\0'))
d257 1
a257 1
	    (s[0] == '9' && s[1] == '6' && s[1] == '\0'))
d260 1
a260 1
	    (s[0] == '9' && s[1] == '7' && s[1] == '\0'))
@


1.5
log
@Add strings to allow the aixterm bright colours to be used when
configuring colours, requested by Elliott Cable a few months ago.
@
text
@d1 1
a1 1
/* $OpenBSD: colour.c,v 1.4 2011/08/22 10:14:15 nicm Exp $ */
a285 26
	};

	return (table[c]);
}

/* Convert 256 colour palette to 88. */
u_char
colour_256to88(u_char c)
{
	static const u_char table[256] = {
		 0,  1,  2,  3,  4,  5,  6,  7,  8,  9, 10, 11, 12, 13, 14, 15,
		16, 17, 17, 18, 18, 19, 20, 21, 21, 22, 22, 23, 20, 21, 21, 22,
		22, 23, 24, 25, 25, 26, 26, 27, 24, 25, 25, 26, 26, 27, 28, 29,
		29, 30, 30, 31, 32, 33, 33, 34, 34, 35, 36, 37, 37, 38, 38, 39,
		36, 37, 37, 38, 38, 39, 40, 41, 41, 42, 42, 43, 40, 41, 41, 42,
		42, 43, 44, 45, 45, 46, 46, 47, 32, 33, 33, 34, 34, 35, 36, 37,
		37, 38, 38, 39, 36, 37, 37, 38, 38, 39, 40, 41, 41, 42, 42, 43,
		40, 41, 41, 42, 42, 43, 44, 45, 45, 46, 46, 47, 48, 49, 49, 50,
		50, 51, 52, 53, 53, 54, 54, 55, 52, 53, 53, 54, 54, 55, 56, 57,
		57, 58, 58, 59, 56, 57, 57, 58, 58, 59, 60, 61, 61, 62, 62, 63,
		48, 49, 49, 50, 50, 51, 52, 53, 53, 54, 54, 55, 52, 53, 53, 54,
		54, 55, 56, 57, 57, 58, 58, 59, 56, 57, 57, 58, 58, 59, 60, 61,
		61, 62, 62, 63, 64, 65, 65, 66, 66, 67, 68, 69, 69, 70, 70, 71,
		68, 69, 69, 70, 70, 71, 72, 73, 73, 74, 74, 75, 72, 73, 73, 74,
		74, 75, 76, 77, 77, 78, 78, 79,  0,  0, 80, 80, 80, 81, 81, 81,
		82, 82, 82, 83, 83, 83, 84, 84, 84, 85, 85, 85, 86, 86, 86, 87
@


1.4
log
@There is no need to use sqrt()/INFINITY here which simplifies the code
and makes it more portable, from Havard Eidnes.
@
text
@d1 1
a1 1
/* $OpenBSD: colour.c,v 1.3 2011/01/08 00:48:54 nicm Exp $ */
d173 16
d238 24
@


1.3
log
@Accept colours of the hex form #ffffff and translate to the nearest from
the xterm(1) 256-colour set.
@
text
@d1 1
a1 1
/* $OpenBSD: colour.c,v 1.2 2009/09/10 17:16:24 nicm Exp $ */
a21 1
#include <math.h>
d43 1
a43 1
double	colour_rgb_distance(struct colour_rgb *, struct colour_rgb *);
d93 1
a93 1
double
d101 1
a101 1
	return (sqrt(r * r + g * g + b * b));
d108 1
a108 2
	double	distance, lowest;
	u_int	colour, i;
d114 1
a114 1
	lowest = INFINITY;
@


1.2
log
@Permit options such as status-bg to be configured using the entire 256 colour
palette by setting "colour0" to "colour255".
@
text
@d1 1
a1 1
/* $OpenBSD: colour.c,v 1.1 2009/06/01 22:58:49 nicm Exp $ */
d21 2
d33 95
d136 1
d145 1
d179 1
d183 15
a197 2
	const char	*errstr;
	int		 n;
d227 1
d253 1
@


1.1
log
@Import tmux, a terminal multiplexor allowing (among other things) a single
terminal to be switched between several different windows and programs
displayed on one terminal be detached from one terminal and moved to another.

ok deraadt pirofti
@
text
@d1 1
a1 1
/* $OpenBSD$ */
d21 1
d26 21
d48 1
a48 1
colour_tostring(u_char c)
d50 7
d83 10
@

