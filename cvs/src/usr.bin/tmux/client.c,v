head	1.122;
access;
symbols
	OPENBSD_6_1:1.120.0.4
	OPENBSD_6_1_BASE:1.120
	OPENBSD_6_0:1.113.0.4
	OPENBSD_6_0_BASE:1.113
	OPENBSD_5_9:1.113.0.2
	OPENBSD_5_9_BASE:1.113
	OPENBSD_5_8:1.91.0.4
	OPENBSD_5_8_BASE:1.91
	OPENBSD_5_7:1.85.0.2
	OPENBSD_5_7_BASE:1.85
	OPENBSD_5_6:1.82.0.4
	OPENBSD_5_6_BASE:1.82
	OPENBSD_5_5:1.78.0.4
	OPENBSD_5_5_BASE:1.78
	OPENBSD_5_4:1.66.0.2
	OPENBSD_5_4_BASE:1.66
	OPENBSD_5_3:1.60.0.2
	OPENBSD_5_3_BASE:1.60
	OPENBSD_5_2:1.58.0.2
	OPENBSD_5_2_BASE:1.58
	OPENBSD_5_1_BASE:1.48
	OPENBSD_5_1:1.48.0.4
	OPENBSD_5_0:1.48.0.2
	OPENBSD_5_0_BASE:1.48
	OPENBSD_4_9:1.47.0.2
	OPENBSD_4_9_BASE:1.47
	OPENBSD_4_8:1.42.0.2
	OPENBSD_4_8_BASE:1.42
	OPENBSD_4_7:1.35.0.2
	OPENBSD_4_7_BASE:1.35
	OPENBSD_4_6:1.3.0.4
	OPENBSD_4_6_BASE:1.3;
locks; strict;
comment	@ * @;


1.122
date	2017.07.12.09.24.17;	author nicm;	state Exp;
branches;
next	1.121;
commitid	GhkQsamphQVs3LP1;

1.121
date	2017.07.12.09.21.25;	author nicm;	state Exp;
branches;
next	1.120;
commitid	1yAGUDv9FQeUA9gG;

1.120
date	2017.01.24.19.53.37;	author nicm;	state Exp;
branches;
next	1.119;
commitid	APEyI6NiCN6S4KhZ;

1.119
date	2017.01.23.10.09.43;	author nicm;	state Exp;
branches;
next	1.118;
commitid	anZBbATBZNigju2F;

1.118
date	2017.01.20.14.02.33;	author nicm;	state Exp;
branches;
next	1.117;
commitid	iN6xGnnIIWx8ijwz;

1.117
date	2017.01.16.14.52.25;	author nicm;	state Exp;
branches;
next	1.116;
commitid	DhrjePH0tXykfoeE;

1.116
date	2017.01.16.14.49.14;	author nicm;	state Exp;
branches;
next	1.115;
commitid	4TgBXjnsq23XHMH4;

1.115
date	2017.01.13.10.12.12;	author nicm;	state Exp;
branches;
next	1.114;
commitid	bQ0icVBejLnBpF27;

1.114
date	2016.10.03.22.52.11;	author nicm;	state Exp;
branches;
next	1.113;
commitid	brRovAmeQVyBbZ4S;

1.113
date	2016.01.19.15.59.12;	author nicm;	state Exp;
branches;
next	1.112;
commitid	P3qmSOx6KrDBsb0c;

1.112
date	2015.11.25.07.58.55;	author nicm;	state Exp;
branches;
next	1.111;
commitid	vlwpMaweGkoy3Xy1;

1.111
date	2015.11.24.23.22.51;	author nicm;	state Exp;
branches;
next	1.110;
commitid	GfId0ZOaXFcgaWPG;

1.110
date	2015.11.24.23.01.51;	author nicm;	state Exp;
branches;
next	1.109;
commitid	43ZLrb9ocz8bOA55;

1.109
date	2015.11.24.22.45.44;	author nicm;	state Exp;
branches;
next	1.108;
commitid	nUeDHL98RWfbdI9h;

1.108
date	2015.11.24.22.27.22;	author nicm;	state Exp;
branches;
next	1.107;
commitid	h20Fi6Gop7tu9Q4A;

1.107
date	2015.11.24.22.04.36;	author nicm;	state Exp;
branches;
next	1.106;
commitid	T0v6qARRlAqepFCr;

1.106
date	2015.11.18.14.27.44;	author nicm;	state Exp;
branches;
next	1.105;
commitid	RjsAPRkWwvS79w40;

1.105
date	2015.11.15.14.32.48;	author nicm;	state Exp;
branches;
next	1.104;
commitid	Vya5bw5HIjQNToOw;

1.104
date	2015.11.14.09.41.06;	author nicm;	state Exp;
branches;
next	1.103;
commitid	FQoND7M2BC89FZoU;

1.103
date	2015.10.31.13.43.38;	author nicm;	state Exp;
branches;
next	1.102;
commitid	uaemvciE6Lbd3u9I;

1.102
date	2015.10.31.08.13.58;	author nicm;	state Exp;
branches;
next	1.101;
commitid	B5GekkO0CdWpFMrz;

1.101
date	2015.10.28.09.51.55;	author nicm;	state Exp;
branches;
next	1.100;
commitid	eGVGKzVVYKHFvkn4;

1.100
date	2015.10.27.15.58.42;	author nicm;	state Exp;
branches;
next	1.99;
commitid	89xhQafU35Q5MQVC;

1.99
date	2015.10.27.13.23.24;	author nicm;	state Exp;
branches;
next	1.98;
commitid	g6GdEJXfBNprXHEK;

1.98
date	2015.10.18.20.42.42;	author nicm;	state Exp;
branches;
next	1.97;
commitid	nMwmdaY8loLzimxC;

1.97
date	2015.10.17.18.30.43;	author nicm;	state Exp;
branches;
next	1.96;
commitid	Tx7adQCMmqAoU7NA;

1.96
date	2015.10.11.00.26.23;	author guenther;	state Exp;
branches;
next	1.95;
commitid	EiEgif09VdYpflOP;

1.95
date	2015.09.24.12.06.20;	author nicm;	state Exp;
branches;
next	1.94;
commitid	KSq0PAbcOEK0q9CQ;

1.94
date	2015.09.09.12.09.21;	author nicm;	state Exp;
branches;
next	1.93;
commitid	yi7yvCISyWrOJyUb;

1.93
date	2015.08.30.22.40.25;	author nicm;	state Exp;
branches;
next	1.92;
commitid	O1jOOL2q5ONABWr1;

1.92
date	2015.08.30.22.19.07;	author nicm;	state Exp;
branches;
next	1.91;
commitid	nMCE84XHv5ujel0H;

1.91
date	2015.07.13.18.10.26;	author nicm;	state Exp;
branches;
next	1.90;
commitid	DrqaqATdX0HayV76;

1.90
date	2015.06.14.10.07.44;	author nicm;	state Exp;
branches;
next	1.89;
commitid	0pZ95JQFEhIowUtr;

1.89
date	2015.06.04.23.27.51;	author nicm;	state Exp;
branches;
next	1.88;
commitid	xevJfLLQ14ORIsEv;

1.88
date	2015.04.24.20.58.44;	author nicm;	state Exp;
branches;
next	1.87;
commitid	PueFP1h2OTV2C0PZ;

1.87
date	2015.04.21.22.21.41;	author nicm;	state Exp;
branches;
next	1.86;
commitid	uyxQu3oFpNmYlCT1;

1.86
date	2015.03.31.17.45.10;	author nicm;	state Exp;
branches;
next	1.85;
commitid	2uQloBaX92ri1PyE;

1.85
date	2014.10.20.23.27.14;	author nicm;	state Exp;
branches;
next	1.84;
commitid	BAMrPS0saBiCc8HD;

1.84
date	2014.10.01.23.23.19;	author nicm;	state Exp;
branches;
next	1.83;
commitid	Kc7HBaRzGKuNgOAg;

1.83
date	2014.09.01.21.50.18;	author nicm;	state Exp;
branches;
next	1.82;
commitid	yvK8NJvd2XzXhKku;

1.82
date	2014.07.21.10.52.48;	author nicm;	state Exp;
branches;
next	1.81;
commitid	iAQWR82ZELL44q5e;

1.81
date	2014.07.13.20.51.08;	author krw;	state Exp;
branches;
next	1.80;
commitid	w5uWmngrpmxyyxKN;

1.80
date	2014.04.29.22.31.22;	author nicm;	state Exp;
branches;
next	1.79;

1.79
date	2014.04.17.11.38.35;	author nicm;	state Exp;
branches;
next	1.78;

1.78
date	2014.01.09.21.20.45;	author nicm;	state Exp;
branches;
next	1.77;

1.77
date	2014.01.09.14.05.55;	author nicm;	state Exp;
branches;
next	1.76;

1.76
date	2013.11.13.20.43.36;	author benno;	state Exp;
branches;
next	1.75;

1.75
date	2013.10.10.12.35.30;	author nicm;	state Exp;
branches;
next	1.74;

1.74
date	2013.10.10.12.29.35;	author nicm;	state Exp;
branches;
next	1.73;

1.73
date	2013.10.10.12.28.08;	author nicm;	state Exp;
branches;
next	1.72;

1.72
date	2013.10.10.12.27.38;	author nicm;	state Exp;
branches;
next	1.71;

1.71
date	2013.10.10.12.26.34;	author nicm;	state Exp;
branches;
next	1.70;

1.70
date	2013.10.10.12.13.56;	author nicm;	state Exp;
branches;
next	1.69;

1.69
date	2013.10.10.12.13.29;	author nicm;	state Exp;
branches;
next	1.68;

1.68
date	2013.10.10.12.12.08;	author nicm;	state Exp;
branches;
next	1.67;

1.67
date	2013.10.10.12.09.34;	author nicm;	state Exp;
branches;
next	1.66;

1.66
date	2013.04.22.08.42.19;	author nicm;	state Exp;
branches;
next	1.65;

1.65
date	2013.03.25.11.38.57;	author nicm;	state Exp;
branches;
next	1.64;

1.64
date	2013.03.25.10.11.45;	author nicm;	state Exp;
branches;
next	1.63;

1.63
date	2013.03.25.10.03.24;	author nicm;	state Exp;
branches;
next	1.62;

1.62
date	2013.03.24.09.54.10;	author nicm;	state Exp;
branches;
next	1.61;

1.61
date	2013.03.22.10.31.22;	author nicm;	state Exp;
branches;
next	1.60;

1.60
date	2012.09.03.08.48.57;	author nicm;	state Exp;
branches;
next	1.59;

1.59
date	2012.08.27.21.35.11;	author nicm;	state Exp;
branches;
next	1.58;

1.58
date	2012.07.10.11.53.01;	author nicm;	state Exp;
branches;
next	1.57;

1.57
date	2012.06.18.13.34.56;	author nicm;	state Exp;
branches;
next	1.56;

1.56
date	2012.06.18.13.16.42;	author nicm;	state Exp;
branches;
next	1.55;

1.55
date	2012.05.25.08.28.10;	author nicm;	state Exp;
branches;
next	1.54;

1.54
date	2012.05.21.18.27.42;	author nicm;	state Exp;
branches;
next	1.53;

1.53
date	2012.04.23.23.25.02;	author nicm;	state Exp;
branches;
next	1.52;

1.52
date	2012.04.23.23.18.43;	author nicm;	state Exp;
branches;
next	1.51;

1.51
date	2012.03.24.11.23.19;	author nicm;	state Exp;
branches;
next	1.50;

1.50
date	2012.03.19.08.42.06;	author nicm;	state Exp;
branches;
next	1.49;

1.49
date	2012.03.09.09.57.40;	author nicm;	state Exp;
branches;
next	1.48;

1.48
date	2011.03.03.08.51.47;	author nicm;	state Exp;
branches;
next	1.47;

1.47
date	2011.01.08.01.52.36;	author nicm;	state Exp;
branches;
next	1.46;

1.46
date	2010.10.18.20.00.02;	author nicm;	state Exp;
branches;
next	1.45;

1.45
date	2010.10.16.08.31.55;	author nicm;	state Exp;
branches;
next	1.44;

1.44
date	2010.08.23.17.36.32;	author nicm;	state Exp;
branches;
next	1.43;

1.43
date	2010.08.22.16.09.49;	author nicm;	state Exp;
branches;
next	1.42;

1.42
date	2010.06.28.22.10.42;	author nicm;	state Exp;
branches;
next	1.41;

1.41
date	2010.06.05.16.47.11;	author nicm;	state Exp;
branches;
next	1.40;

1.40
date	2010.06.05.16.29.45;	author nicm;	state Exp;
branches;
next	1.39;

1.39
date	2010.05.12.15.05.39;	author jsing;	state Exp;
branches;
next	1.38;

1.38
date	2010.05.04.17.28.16;	author nicm;	state Exp;
branches;
next	1.37;

1.37
date	2010.05.04.08.48.06;	author nicm;	state Exp;
branches;
next	1.36;

1.36
date	2010.05.03.16.06.32;	author nicm;	state Exp;
branches;
next	1.35;

1.35
date	2009.12.03.22.50.09;	author nicm;	state Exp;
branches;
next	1.34;

1.34
date	2009.11.26.21.37.13;	author nicm;	state Exp;
branches;
next	1.33;

1.33
date	2009.11.13.18.07.52;	author nicm;	state Exp;
branches;
next	1.32;

1.32
date	2009.11.10.15.47.48;	author nicm;	state Exp;
branches;
next	1.31;

1.31
date	2009.11.04.22.57.49;	author nicm;	state Exp;
branches;
next	1.30;

1.30
date	2009.11.04.20.50.11;	author nicm;	state Exp;
branches;
next	1.29;

1.29
date	2009.11.02.13.42.25;	author nicm;	state Exp;
branches;
next	1.28;

1.28
date	2009.11.02.13.41.25;	author nicm;	state Exp;
branches;
next	1.27;

1.27
date	2009.10.26.21.38.18;	author nicm;	state Exp;
branches;
next	1.26;

1.26
date	2009.10.21.21.11.55;	author nicm;	state Exp;
branches;
next	1.25;

1.25
date	2009.10.21.20.11.47;	author nicm;	state Exp;
branches;
next	1.24;

1.24
date	2009.10.13.13.15.26;	author nicm;	state Exp;
branches;
next	1.23;

1.23
date	2009.10.13.13.11.06;	author nicm;	state Exp;
branches;
next	1.22;

1.22
date	2009.09.23.12.03.30;	author nicm;	state Exp;
branches;
next	1.21;

1.21
date	2009.09.23.06.18.47;	author nicm;	state Exp;
branches;
next	1.20;

1.20
date	2009.09.23.06.12.58;	author nicm;	state Exp;
branches;
next	1.19;

1.19
date	2009.09.23.06.05.02;	author nicm;	state Exp;
branches;
next	1.18;

1.18
date	2009.09.20.14.58.12;	author nicm;	state Exp;
branches;
next	1.17;

1.17
date	2009.09.02.23.49.25;	author nicm;	state Exp;
branches;
next	1.16;

1.16
date	2009.09.02.20.15.49;	author nicm;	state Exp;
branches;
next	1.15;

1.15
date	2009.09.02.20.00.10;	author nicm;	state Exp;
branches;
next	1.14;

1.14
date	2009.08.12.06.04.28;	author nicm;	state Exp;
branches;
next	1.13;

1.13
date	2009.08.11.21.28.11;	author nicm;	state Exp;
branches;
next	1.12;

1.12
date	2009.08.11.17.18.35;	author nicm;	state Exp;
branches;
next	1.11;

1.11
date	2009.08.08.21.52.43;	author nicm;	state Exp;
branches;
next	1.10;

1.10
date	2009.08.08.21.18.23;	author nicm;	state Exp;
branches;
next	1.9;

1.9
date	2009.07.30.16.32.12;	author nicm;	state Exp;
branches;
next	1.8;

1.8
date	2009.07.30.16.16.19;	author nicm;	state Exp;
branches;
next	1.7;

1.7
date	2009.07.26.12.58.44;	author nicm;	state Exp;
branches;
next	1.6;

1.6
date	2009.07.23.21.19.11;	author nicm;	state Exp;
branches;
next	1.5;

1.5
date	2009.07.23.20.24.27;	author nicm;	state Exp;
branches;
next	1.4;

1.4
date	2009.07.22.21.58.56;	author nicm;	state Exp;
branches;
next	1.3;

1.3
date	2009.06.25.22.09.20;	author nicm;	state Exp;
branches;
next	1.2;

1.2
date	2009.06.05.07.15.58;	author nicm;	state Exp;
branches;
next	1.1;

1.1
date	2009.06.01.22.58.49;	author nicm;	state Exp;
branches;
next	;


desc
@@


1.122
log
@Move signal code into proc.c.
@
text
@/* $OpenBSD: client.c,v 1.121 2017/07/12 09:21:25 nicm Exp $ */

/*
 * Copyright (c) 2007 Nicholas Marriott <nicholas.marriott@@gmail.com>
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF MIND, USE, DATA OR PROFITS, WHETHER
 * IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING
 * OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */

#include <sys/types.h>
#include <sys/file.h>
#include <sys/socket.h>
#include <sys/stat.h>
#include <sys/un.h>
#include <sys/wait.h>

#include <errno.h>
#include <event.h>
#include <fcntl.h>
#include <imsg.h>
#include <signal.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>

#include "tmux.h"

static struct tmuxproc	*client_proc;
static struct tmuxpeer	*client_peer;
static int		 client_flags;
static struct event	 client_stdin;
static enum {
	CLIENT_EXIT_NONE,
	CLIENT_EXIT_DETACHED,
	CLIENT_EXIT_DETACHED_HUP,
	CLIENT_EXIT_LOST_TTY,
	CLIENT_EXIT_TERMINATED,
	CLIENT_EXIT_LOST_SERVER,
	CLIENT_EXIT_EXITED,
	CLIENT_EXIT_SERVER_EXITED,
} client_exitreason = CLIENT_EXIT_NONE;
static int		 client_exitval;
static enum msgtype	 client_exittype;
static const char	*client_exitsession;
static const char	*client_execshell;
static const char	*client_execcmd;
static int		 client_attached;

static __dead void	 client_exec(const char *,const char *);
static int		 client_get_lock(char *);
static int		 client_connect(struct event_base *, const char *, int);
static void		 client_send_identify(const char *, const char *);
static void		 client_stdin_callback(int, short, void *);
static void		 client_write(int, const char *, size_t);
static void		 client_signal(int);
static void		 client_dispatch(struct imsg *, void *);
static void		 client_dispatch_attached(struct imsg *);
static void		 client_dispatch_wait(struct imsg *);
static const char	*client_exit_message(void);

/*
 * Get server create lock. If already held then server start is happening in
 * another client, so block until the lock is released and return -2 to
 * retry. Return -1 on failure to continue and start the server anyway.
 */
static int
client_get_lock(char *lockfile)
{
	int lockfd;

	log_debug("lock file is %s", lockfile);

	if ((lockfd = open(lockfile, O_WRONLY|O_CREAT, 0600)) == -1) {
		log_debug("open failed: %s", strerror(errno));
		return (-1);
	}

	if (flock(lockfd, LOCK_EX|LOCK_NB) == -1) {
		log_debug("flock failed: %s", strerror(errno));
		if (errno != EAGAIN)
			return (lockfd);
		while (flock(lockfd, LOCK_EX) == -1 && errno == EINTR)
			/* nothing */;
		close(lockfd);
		return (-2);
	}
	log_debug("flock succeeded");

	return (lockfd);
}

/* Connect client to server. */
static int
client_connect(struct event_base *base, const char *path, int start_server)
{
	struct sockaddr_un	sa;
	size_t			size;
	int			fd, lockfd = -1, locked = 0;
	char		       *lockfile = NULL;

	memset(&sa, 0, sizeof sa);
	sa.sun_family = AF_UNIX;
	size = strlcpy(sa.sun_path, path, sizeof sa.sun_path);
	if (size >= sizeof sa.sun_path) {
		errno = ENAMETOOLONG;
		return (-1);
	}
	log_debug("socket is %s", path);

retry:
	if ((fd = socket(AF_UNIX, SOCK_STREAM, 0)) == -1)
		return (-1);

	log_debug("trying connect");
	if (connect(fd, (struct sockaddr *)&sa, sizeof sa) == -1) {
		log_debug("connect failed: %s", strerror(errno));
		if (errno != ECONNREFUSED && errno != ENOENT)
			goto failed;
		if (!start_server)
			goto failed;
		close(fd);

		if (!locked) {
			xasprintf(&lockfile, "%s.lock", path);
			if ((lockfd = client_get_lock(lockfile)) < 0) {
				log_debug("didn't get lock (%d)", lockfd);

				free(lockfile);
				lockfile = NULL;

				if (lockfd == -2)
					goto retry;
			}
			log_debug("got lock (%d)", lockfd);

			/*
			 * Always retry at least once, even if we got the lock,
			 * because another client could have taken the lock,
			 * started the server and released the lock between our
			 * connect() and flock().
			 */
			locked = 1;
			goto retry;
		}

		if (lockfd >= 0 && unlink(path) != 0 && errno != ENOENT) {
			free(lockfile);
			close(lockfd);
			return (-1);
		}
		fd = server_start(client_proc, base, lockfd, lockfile);
	}

	if (locked && lockfd >= 0) {
		free(lockfile);
		close(lockfd);
	}
	setblocking(fd, 0);
	return (fd);

failed:
	if (locked) {
		free(lockfile);
		close(lockfd);
	}
	close(fd);
	return (-1);
}

/* Get exit string from reason number. */
const char *
client_exit_message(void)
{
	static char msg[256];

	switch (client_exitreason) {
	case CLIENT_EXIT_NONE:
		break;
	case CLIENT_EXIT_DETACHED:
		if (client_exitsession != NULL) {
			xsnprintf(msg, sizeof msg, "detached "
			    "(from session %s)", client_exitsession);
			return (msg);
		}
		return ("detached");
	case CLIENT_EXIT_DETACHED_HUP:
		if (client_exitsession != NULL) {
			xsnprintf(msg, sizeof msg, "detached and SIGHUP "
			    "(from session %s)", client_exitsession);
			return (msg);
		}
		return ("detached and SIGHUP");
	case CLIENT_EXIT_LOST_TTY:
		return ("lost tty");
	case CLIENT_EXIT_TERMINATED:
		return ("terminated");
	case CLIENT_EXIT_LOST_SERVER:
		return ("lost server");
	case CLIENT_EXIT_EXITED:
		return ("exited");
	case CLIENT_EXIT_SERVER_EXITED:
		return ("server exited");
	}
	return ("unknown reason");
}

/* Client main loop. */
int
client_main(struct event_base *base, int argc, char **argv, int flags)
{
	struct cmd		*cmd;
	struct cmd_list		*cmdlist;
	struct msg_command_data	*data;
	int			 cmdflags, fd, i;
	const char		*ttynam, *cwd;
	pid_t			 ppid;
	enum msgtype		 msg;
	char			*cause, path[PATH_MAX];
	struct termios		 tio, saved_tio;
	size_t			 size;

	/* Ignore SIGCHLD now or daemon() in the server will leave a zombie. */
	signal(SIGCHLD, SIG_IGN);

	/* Save the flags. */
	client_flags = flags;

	/* Set up the initial command. */
	cmdflags = 0;
	if (shell_command != NULL) {
		msg = MSG_SHELL;
		cmdflags = CMD_STARTSERVER;
	} else if (argc == 0) {
		msg = MSG_COMMAND;
		cmdflags = CMD_STARTSERVER;
	} else {
		msg = MSG_COMMAND;

		/*
		 * It sucks parsing the command string twice (in client and
		 * later in server) but it is necessary to get the start server
		 * flag.
		 */
		cmdlist = cmd_list_parse(argc, argv, NULL, 0, &cause);
		if (cmdlist != NULL) {
			TAILQ_FOREACH(cmd, &cmdlist->list, qentry) {
				if (cmd->entry->flags & CMD_STARTSERVER)
					cmdflags |= CMD_STARTSERVER;
			}
			cmd_list_free(cmdlist);
		}
	}

	/* Create client process structure (starts logging). */
	client_proc = proc_start("client");
	proc_set_signals(client_proc, client_signal);

	/* Initialize the client socket and start the server. */
	fd = client_connect(base, socket_path, cmdflags & CMD_STARTSERVER);
	if (fd == -1) {
		if (errno == ECONNREFUSED) {
			fprintf(stderr, "no server running on %s\n",
			    socket_path);
		} else {
			fprintf(stderr, "error connecting to %s (%s)\n",
			    socket_path, strerror(errno));
		}
		return (1);
	}
	client_peer = proc_add_peer(client_proc, fd, client_dispatch, NULL);

	/* Save these before pledge(). */
	if ((cwd = getcwd(path, sizeof path)) == NULL) {
		if ((cwd = find_home()) == NULL)
			cwd = "/";
	}
	if ((ttynam = ttyname(STDIN_FILENO)) == NULL)
		ttynam = "";

	/*
	 * Drop privileges for client. "proc exec" is needed for -c and for
	 * locking (which uses system(3)).
	 *
	 * "tty" is needed to restore termios(4) and also for some reason -CC
	 * does not work properly without it (input is not recognised).
	 *
	 * "sendfd" is dropped later in client_dispatch_wait().
	 */
	if (pledge("stdio unix sendfd proc exec tty", NULL) != 0)
		fatal("pledge failed");

	/* Free stuff that is not used in the client. */
	if (ptm_fd != -1)
		close(ptm_fd);
	options_free(global_options);
	options_free(global_s_options);
	options_free(global_w_options);
	environ_free(global_environ);

	/* Create stdin handler. */
	setblocking(STDIN_FILENO, 0);
	event_set(&client_stdin, STDIN_FILENO, EV_READ|EV_PERSIST,
	    client_stdin_callback, NULL);
	if (client_flags & CLIENT_CONTROLCONTROL) {
		if (tcgetattr(STDIN_FILENO, &saved_tio) != 0) {
			fprintf(stderr, "tcgetattr failed: %s\n",
			    strerror(errno));
			return (1);
		}
		cfmakeraw(&tio);
		tio.c_iflag = ICRNL|IXANY;
		tio.c_oflag = OPOST|ONLCR;
		tio.c_lflag = NOKERNINFO;
		tio.c_cflag = CREAD|CS8|HUPCL;
		tio.c_cc[VMIN] = 1;
		tio.c_cc[VTIME] = 0;
		cfsetispeed(&tio, cfgetispeed(&saved_tio));
		cfsetospeed(&tio, cfgetospeed(&saved_tio));
		tcsetattr(STDIN_FILENO, TCSANOW, &tio);
	}

	/* Send identify messages. */
	client_send_identify(ttynam, cwd);

	/* Send first command. */
	if (msg == MSG_COMMAND) {
		/* How big is the command? */
		size = 0;
		for (i = 0; i < argc; i++)
			size += strlen(argv[i]) + 1;
		data = xmalloc((sizeof *data) + size);

		/* Prepare command for server. */
		data->argc = argc;
		if (cmd_pack_argv(argc, argv, (char *)(data + 1), size) != 0) {
			fprintf(stderr, "command too long\n");
			free(data);
			return (1);
		}
		size += sizeof *data;

		/* Send the command. */
		if (proc_send(client_peer, msg, -1, data, size) != 0) {
			fprintf(stderr, "failed to send command\n");
			free(data);
			return (1);
		}
		free(data);
	} else if (msg == MSG_SHELL)
		proc_send(client_peer, msg, -1, NULL, 0);

	/* Start main loop. */
	proc_loop(client_proc, NULL);

	/* Run command if user requested exec, instead of exiting. */
	if (client_exittype == MSG_EXEC) {
		if (client_flags & CLIENT_CONTROLCONTROL)
			tcsetattr(STDOUT_FILENO, TCSAFLUSH, &saved_tio);
		proc_clear_signals(client_proc);
		client_exec(client_execshell, client_execcmd);
	}

	/* Print the exit message, if any, and exit. */
	if (client_attached) {
		if (client_exitreason != CLIENT_EXIT_NONE)
			printf("[%s]\n", client_exit_message());

		ppid = getppid();
		if (client_exittype == MSG_DETACHKILL && ppid > 1)
			kill(ppid, SIGHUP);
	} else if (client_flags & CLIENT_CONTROLCONTROL) {
		if (client_exitreason != CLIENT_EXIT_NONE)
			printf("%%exit %s\n", client_exit_message());
		else
			printf("%%exit\n");
		printf("\033\\");
		tcsetattr(STDOUT_FILENO, TCSAFLUSH, &saved_tio);
	} else if (client_exitreason != CLIENT_EXIT_NONE)
		fprintf(stderr, "%s\n", client_exit_message());
	setblocking(STDIN_FILENO, 1);
	return (client_exitval);
}

/* Send identify messages to server. */
static void
client_send_identify(const char *ttynam, const char *cwd)
{
	const char	 *s;
	char		**ss;
	size_t		  sslen;
	int		  fd, flags = client_flags;
	pid_t		  pid;

	proc_send(client_peer, MSG_IDENTIFY_FLAGS, -1, &flags, sizeof flags);

	if ((s = getenv("TERM")) == NULL)
		s = "";
	proc_send(client_peer, MSG_IDENTIFY_TERM, -1, s, strlen(s) + 1);

	proc_send(client_peer, MSG_IDENTIFY_TTYNAME, -1, ttynam,
	    strlen(ttynam) + 1);
	proc_send(client_peer, MSG_IDENTIFY_CWD, -1, cwd, strlen(cwd) + 1);

	if ((fd = dup(STDIN_FILENO)) == -1)
		fatal("dup failed");
	proc_send(client_peer, MSG_IDENTIFY_STDIN, fd, NULL, 0);

	pid = getpid();
	proc_send(client_peer, MSG_IDENTIFY_CLIENTPID, -1, &pid, sizeof pid);

	for (ss = environ; *ss != NULL; ss++) {
		sslen = strlen(*ss) + 1;
		if (sslen > MAX_IMSGSIZE - IMSG_HEADER_SIZE)
			continue;
		proc_send(client_peer, MSG_IDENTIFY_ENVIRON, -1, *ss, sslen);
	}

	proc_send(client_peer, MSG_IDENTIFY_DONE, -1, NULL, 0);
}

/* Callback for client stdin read events. */
static void
client_stdin_callback(__unused int fd, __unused short events,
    __unused void *arg)
{
	struct msg_stdin_data	data;

	data.size = read(STDIN_FILENO, data.data, sizeof data.data);
	if (data.size < 0 && (errno == EINTR || errno == EAGAIN))
		return;

	proc_send(client_peer, MSG_STDIN, -1, &data, sizeof data);
	if (data.size <= 0)
		event_del(&client_stdin);
}

/* Force write to file descriptor. */
static void
client_write(int fd, const char *data, size_t size)
{
	ssize_t	used;

	while (size != 0) {
		used = write(fd, data, size);
		if (used == -1) {
			if (errno == EINTR || errno == EAGAIN)
				continue;
			break;
		}
		data += used;
		size -= used;
	}
}

/* Run command in shell; used for -c. */
static __dead void
client_exec(const char *shell, const char *shellcmd)
{
	const char	*name, *ptr;
	char		*argv0;

	log_debug("shell %s, command %s", shell, shellcmd);

	ptr = strrchr(shell, '/');
	if (ptr != NULL && *(ptr + 1) != '\0')
		name = ptr + 1;
	else
		name = shell;
	if (client_flags & CLIENT_LOGIN)
		xasprintf(&argv0, "-%s", name);
	else
		xasprintf(&argv0, "%s", name);
	setenv("SHELL", shell, 1);

	setblocking(STDIN_FILENO, 1);
	setblocking(STDOUT_FILENO, 1);
	setblocking(STDERR_FILENO, 1);
	closefrom(STDERR_FILENO + 1);

	execl(shell, argv0, "-c", shellcmd, (char *) NULL);
	fatal("execl failed");
}

/* Callback to handle signals in the client. */
static void
client_signal(int sig)
{
	struct sigaction sigact;
	int		 status;

	if (sig == SIGCHLD)
		waitpid(WAIT_ANY, &status, WNOHANG);
	else if (!client_attached) {
		if (sig == SIGTERM)
			proc_exit(client_proc);
	} else {
		switch (sig) {
		case SIGHUP:
			client_exitreason = CLIENT_EXIT_LOST_TTY;
			client_exitval = 1;
			proc_send(client_peer, MSG_EXITING, -1, NULL, 0);
			break;
		case SIGTERM:
			client_exitreason = CLIENT_EXIT_TERMINATED;
			client_exitval = 1;
			proc_send(client_peer, MSG_EXITING, -1, NULL, 0);
			break;
		case SIGWINCH:
			proc_send(client_peer, MSG_RESIZE, -1, NULL, 0);
			break;
		case SIGCONT:
			memset(&sigact, 0, sizeof sigact);
			sigemptyset(&sigact.sa_mask);
			sigact.sa_flags = SA_RESTART;
			sigact.sa_handler = SIG_IGN;
			if (sigaction(SIGTSTP, &sigact, NULL) != 0)
				fatal("sigaction failed");
			proc_send(client_peer, MSG_WAKEUP, -1, NULL, 0);
			break;
		}
	}
}

/* Callback for client read events. */
static void
client_dispatch(struct imsg *imsg, __unused void *arg)
{
	if (imsg == NULL) {
		client_exitreason = CLIENT_EXIT_LOST_SERVER;
		client_exitval = 1;
		proc_exit(client_proc);
		return;
	}

	if (client_attached)
		client_dispatch_attached(imsg);
	else
		client_dispatch_wait(imsg);
}

/* Dispatch imsgs when in wait state (before MSG_READY). */
static void
client_dispatch_wait(struct imsg *imsg)
{
	char			*data;
	ssize_t			 datalen;
	struct msg_stdout_data	 stdoutdata;
	struct msg_stderr_data	 stderrdata;
	int			 retval;
	static int		 pledge_applied;

	/*
	 * "sendfd" is no longer required once all of the identify messages
	 * have been sent. We know the server won't send us anything until that
	 * point (because we don't ask it to), so we can drop "sendfd" once we
	 * get the first message from the server.
	 */
	if (!pledge_applied) {
		if (pledge("stdio unix proc exec tty", NULL) != 0)
			fatal("pledge failed");
		pledge_applied = 1;
	};

	data = imsg->data;
	datalen = imsg->hdr.len - IMSG_HEADER_SIZE;

	switch (imsg->hdr.type) {
	case MSG_EXIT:
	case MSG_SHUTDOWN:
		if (datalen != sizeof retval && datalen != 0)
			fatalx("bad MSG_EXIT size");
		if (datalen == sizeof retval) {
			memcpy(&retval, data, sizeof retval);
			client_exitval = retval;
		}
		proc_exit(client_proc);
		break;
	case MSG_READY:
		if (datalen != 0)
			fatalx("bad MSG_READY size");

		event_del(&client_stdin);
		client_attached = 1;
		proc_send(client_peer, MSG_RESIZE, -1, NULL, 0);
		break;
	case MSG_STDIN:
		if (datalen != 0)
			fatalx("bad MSG_STDIN size");

		event_add(&client_stdin, NULL);
		break;
	case MSG_STDOUT:
		if (datalen != sizeof stdoutdata)
			fatalx("bad MSG_STDOUT size");
		memcpy(&stdoutdata, data, sizeof stdoutdata);

		client_write(STDOUT_FILENO, stdoutdata.data,
		    stdoutdata.size);
		break;
	case MSG_STDERR:
		if (datalen != sizeof stderrdata)
			fatalx("bad MSG_STDERR size");
		memcpy(&stderrdata, data, sizeof stderrdata);

		client_write(STDERR_FILENO, stderrdata.data,
		    stderrdata.size);
		break;
	case MSG_VERSION:
		if (datalen != 0)
			fatalx("bad MSG_VERSION size");

		fprintf(stderr, "protocol version mismatch "
		    "(client %d, server %u)\n", PROTOCOL_VERSION,
		    imsg->hdr.peerid & 0xff);
		client_exitval = 1;
		proc_exit(client_proc);
		break;
	case MSG_SHELL:
		if (datalen == 0 || data[datalen - 1] != '\0')
			fatalx("bad MSG_SHELL string");

		proc_clear_signals(client_proc);
		client_exec(data, shell_command);
		/* NOTREACHED */
	case MSG_DETACH:
	case MSG_DETACHKILL:
		proc_send(client_peer, MSG_EXITING, -1, NULL, 0);
		break;
	case MSG_EXITED:
		proc_exit(client_proc);
		break;
	}
}

/* Dispatch imsgs in attached state (after MSG_READY). */
static void
client_dispatch_attached(struct imsg *imsg)
{
	struct sigaction	 sigact;
	char			*data;
	ssize_t			 datalen;

	data = imsg->data;
	datalen = imsg->hdr.len - IMSG_HEADER_SIZE;

	switch (imsg->hdr.type) {
	case MSG_DETACH:
	case MSG_DETACHKILL:
		if (datalen == 0 || data[datalen - 1] != '\0')
			fatalx("bad MSG_DETACH string");

		client_exitsession = xstrdup(data);
		client_exittype = imsg->hdr.type;
		if (imsg->hdr.type == MSG_DETACHKILL)
			client_exitreason = CLIENT_EXIT_DETACHED_HUP;
		else
			client_exitreason = CLIENT_EXIT_DETACHED;
		proc_send(client_peer, MSG_EXITING, -1, NULL, 0);
		break;
	case MSG_EXEC:
		if (datalen == 0 || data[datalen - 1] != '\0' ||
		    strlen(data) + 1 == (size_t)datalen)
			fatalx("bad MSG_EXEC string");
		client_execcmd = xstrdup(data);
		client_execshell = xstrdup(data + strlen(data) + 1);

		client_exittype = imsg->hdr.type;
		proc_send(client_peer, MSG_EXITING, -1, NULL, 0);
		break;
	case MSG_EXIT:
		if (datalen != 0 && datalen != sizeof (int))
			fatalx("bad MSG_EXIT size");

		proc_send(client_peer, MSG_EXITING, -1, NULL, 0);
		client_exitreason = CLIENT_EXIT_EXITED;
		break;
	case MSG_EXITED:
		if (datalen != 0)
			fatalx("bad MSG_EXITED size");

		proc_exit(client_proc);
		break;
	case MSG_SHUTDOWN:
		if (datalen != 0)
			fatalx("bad MSG_SHUTDOWN size");

		proc_send(client_peer, MSG_EXITING, -1, NULL, 0);
		client_exitreason = CLIENT_EXIT_SERVER_EXITED;
		client_exitval = 1;
		break;
	case MSG_SUSPEND:
		if (datalen != 0)
			fatalx("bad MSG_SUSPEND size");

		memset(&sigact, 0, sizeof sigact);
		sigemptyset(&sigact.sa_mask);
		sigact.sa_flags = SA_RESTART;
		sigact.sa_handler = SIG_DFL;
		if (sigaction(SIGTSTP, &sigact, NULL) != 0)
			fatal("sigaction failed");
		kill(getpid(), SIGTSTP);
		break;
	case MSG_LOCK:
		if (datalen == 0 || data[datalen - 1] != '\0')
			fatalx("bad MSG_LOCK string");

		system(data);
		proc_send(client_peer, MSG_UNLOCK, -1, NULL, 0);
		break;
	}
}
@


1.121
log
@Make shell_command a global like other stuff rather than making it an
exception and using callback argument.
@
text
@d1 1
a1 1
/* $OpenBSD: client.c,v 1.120 2017/01/24 19:53:37 nicm Exp $ */
d160 1
a160 1
		fd = server_start(base, lockfd, lockfile);
d264 2
a265 1
	client_proc = proc_start("client", base, 0, client_signal);
d368 1
a368 1
		clear_signals(0);
d631 1
a631 1
		clear_signals(0);
@


1.120
log
@Add support for custom command aliases, this is an array option which
contains items of the form "alias=command". This is consulted when an
unknown command is parsed.
@
text
@d1 1
a1 1
/* $OpenBSD: client.c,v 1.119 2017/01/23 10:09:43 nicm Exp $ */
d67 1
a67 1
static void		 client_dispatch_wait(struct imsg *, const char *);
d218 1
a218 2
client_main(struct event_base *base, int argc, char **argv, int flags,
    const char *shellcmd)
d239 1
a239 1
	if (shellcmd != NULL) {
d278 1
a278 2
	client_peer = proc_add_peer(client_proc, fd, client_dispatch,
	    (void *)shellcmd);
d534 1
a534 1
client_dispatch(struct imsg *imsg, void *arg)
d546 1
a546 1
		client_dispatch_wait(imsg, arg);
d551 1
a551 1
client_dispatch_wait(struct imsg *imsg, const char *shellcmd)
d631 1
a631 1
		client_exec(data, shellcmd);
@


1.119
log
@Open /dev/ptm before pledge() and save it to be used for PTMGET later
(this means inlining forkpty()).

ok deraadt
@
text
@d1 1
a1 1
/* $OpenBSD: client.c,v 1.118 2017/01/20 14:02:33 nicm Exp $ */
d255 6
a260 8
		if (cmdlist == NULL) {
			fprintf(stderr, "%s\n", cause);
			return (1);
		}
		cmdflags &= ~CMD_STARTSERVER;
		TAILQ_FOREACH(cmd, &cmdlist->list, qentry) {
			if (cmd->entry->flags & CMD_STARTSERVER)
				cmdflags |= CMD_STARTSERVER;
a261 1
		cmd_list_free(cmdlist);
@


1.118
log
@Print error rather than fatal() if tcgetattr() fails, which is much more
useful to user.
@
text
@d1 1
a1 1
/* $OpenBSD: client.c,v 1.117 2017/01/16 14:52:25 nicm Exp $ */
d306 2
@


1.117
log
@Revert WIP parts of previous I didn't mean to commit yet.
@
text
@d1 1
a1 1
/* $OpenBSD: client.c,v 1.115 2017/01/13 10:12:12 nicm Exp $ */
d316 5
a320 2
		if (tcgetattr(STDIN_FILENO, &saved_tio) != 0)
			fatal("tcgetattr failed");
@


1.116
log
@getopt() has a struct option so just return to using options_entry.
@
text
@d255 3
a257 6
		if (cmdlist != NULL) {
			TAILQ_FOREACH(cmd, &cmdlist->list, qentry) {
				if (cmd->entry->flags & CMD_STARTSERVER)
					cmdflags |= CMD_STARTSERVER;
			}
			cmd_list_free(cmdlist);
d259 6
@


1.115
log
@Add -E to detach-client to exec a command to replace the client instead
of exiting it, useful if tmux wasn't exec'd itself. From Jenna Magius.
@
text
@d1 1
a1 1
/* $OpenBSD: client.c,v 1.114 2016/10/03 22:52:11 nicm Exp $ */
d255 6
a260 8
		if (cmdlist == NULL) {
			fprintf(stderr, "%s\n", cause);
			return (1);
		}
		cmdflags &= ~CMD_STARTSERVER;
		TAILQ_FOREACH(cmd, &cmdlist->list, qentry) {
			if (cmd->entry->flags & CMD_STARTSERVER)
				cmdflags |= CMD_STARTSERVER;
a261 1
		cmd_list_free(cmdlist);
@


1.114
log
@Remove some dead code in cmd-move-window.c and make a load of local
functions static.
@
text
@d1 1
a1 1
/* $OpenBSD: client.c,v 1.113 2016/01/19 15:59:12 nicm Exp $ */
d54 2
d363 8
d666 10
@


1.113
log
@I no longer use my SourceForge address so replace it.
@
text
@d1 1
a1 1
/* $OpenBSD: client.c,v 1.112 2015/11/25 07:58:55 nicm Exp $ */
d37 5
a41 5
struct tmuxproc	*client_proc;
struct tmuxpeer	*client_peer;
int		 client_flags;
struct event	 client_stdin;
enum {
d51 16
a66 16
int		 client_exitval;
enum msgtype	 client_exittype;
const char	*client_exitsession;
int		 client_attached;

__dead void	client_exec(const char *,const char *);
int		client_get_lock(char *);
int		client_connect(struct event_base *, const char *, int);
void		client_send_identify(const char *, const char *);
void		client_stdin_callback(int, short, void *);
void		client_write(int, const char *, size_t);
void		client_signal(int);
void		client_dispatch(struct imsg *, void *);
void		client_dispatch_attached(struct imsg *);
void		client_dispatch_wait(struct imsg *, const char *);
const char     *client_exit_message(void);
d73 1
a73 1
int
d100 1
a100 1
int
d383 1
a383 1
void
d420 1
a420 1
void
d436 1
a436 1
void
d454 1
a454 1
__dead void
d483 1
a483 1
void
d523 1
a523 1
void
d540 1
a540 1
void
d634 1
a634 1
void
@


1.112
log
@Don't print error if none to print.
@
text
@d1 1
a1 1
/* $OpenBSD: client.c,v 1.111 2015/11/24 23:22:51 nicm Exp $ */
d4 1
a4 1
 * Copyright (c) 2007 Nicholas Marriott <nicm@@users.sourceforge.net>
@


1.111
log
@Shell command from -c doesn't have to be global, pass it as an argument.
@
text
@d1 1
a1 1
/* $OpenBSD: client.c,v 1.110 2015/11/24 23:01:51 nicm Exp $ */
d376 1
a376 1
	} else
@


1.110
log
@Do lock failures slightly better, return a special value so we don't
unlink the wrong thing.
@
text
@d1 1
a1 1
/* $OpenBSD: client.c,v 1.109 2015/11/24 22:45:44 nicm Exp $ */
d56 1
a56 1
__dead void	client_exec(const char *);
d65 1
a65 1
void		client_dispatch_wait(struct imsg *);
d216 2
a217 1
client_main(struct event_base *base, int argc, char **argv, int flags)
d238 1
a238 1
	if (shell_cmd != NULL) {
d280 2
a281 1
	client_peer = proc_add_peer(client_proc, fd, client_dispatch, NULL);
d455 1
a455 1
client_exec(const char *shell)
d460 1
a460 1
	log_debug("shell %s, command %s", shell, shell_cmd);
d478 1
a478 1
	execl(shell, argv0, "-c", shell_cmd, (char *) NULL);
d524 1
a524 1
client_dispatch(struct imsg *imsg, __unused void *arg)
d536 1
a536 1
		client_dispatch_wait(imsg);
d541 1
a541 1
client_dispatch_wait(struct imsg *imsg)
d621 1
a621 1
		client_exec(data);
@


1.109
log
@Actually show something (even if it not that helpful) if the server
fails to start (for example if it can't create the socket), rather than
hanging or showing nothing.
@
text
@d1 1
a1 1
/* $OpenBSD: client.c,v 1.108 2015/11/24 22:27:22 nicm Exp $ */
d70 2
a71 3
 * another client, so block until the lock is released and return -1 to
 * retry. Ignore other errors - just continue and start the server without the
 * lock.
d78 2
d81 2
a82 4
		lockfd = open("/dev/null", O_WRONLY);
		if (lockfd == -1)
			fatal("open failed");
		return (lockfd);
a83 1
	log_debug("lock file is %s", lockfile);
d92 1
a92 1
		return (-1);
d132 3
a134 2
			if ((lockfd = client_get_lock(lockfile)) == -1) {
				log_debug("didn't get lock");
d136 4
a139 1
				goto retry;
d141 1
a141 1
			log_debug("got lock");
d153 1
a153 1
		if (unlink(path) != 0 && errno != ENOENT) {
d161 1
a161 1
	if (locked) {
@


1.108
log
@Tidy the code that works out the socket path, and just use the full path
in the global socket_path rather than copying it.
@
text
@d1 1
a1 1
/* $OpenBSD: client.c,v 1.107 2015/11/24 22:04:36 nicm Exp $ */
d79 6
a84 2
	if ((lockfd = open(lockfile, O_WRONLY|O_CREAT, 0600)) == -1)
		fatal("open failed");
d121 1
a121 1
		fatal("socket failed");
d124 1
a124 1
	if (connect(fd, (struct sockaddr *) &sa, sizeof(sa)) == -1) {
d262 3
a276 3

	/* Build process state. */
	client_proc = proc_start("client", base, 0, client_signal);
d372 2
a373 1
	}
d525 5
a529 1
	} else if (client_attached)
@


1.107
log
@Switch a fprintf to a fatal, and wrap some long lines.
@
text
@d1 1
a1 1
/* $OpenBSD: client.c,v 1.106 2015/11/18 14:27:44 nicm Exp $ */
d58 1
a58 1
int		client_connect(struct event_base *, char *, int);
d99 1
a99 1
client_connect(struct event_base *base, char *path, int start_server)
@


1.106
log
@Use __unused rather than rolling our own.
@
text
@d1 1
a1 1
/* $OpenBSD: client.c,v 1.105 2015/11/15 14:32:48 nicm Exp $ */
d306 2
a307 5
		if (tcgetattr(STDIN_FILENO, &saved_tio) != 0) {
			fprintf(stderr, "tcgetattr failed: %s\n",
			    strerror(errno));
			return (1);
		}
d389 2
a390 1
	proc_send(client_peer, MSG_IDENTIFY_TTYNAME, -1, ttynam, strlen(ttynam) + 1);
d402 3
a404 2
		if (sslen <= MAX_IMSGSIZE - IMSG_HEADER_SIZE)
			proc_send(client_peer, MSG_IDENTIFY_ENVIRON, -1, *ss, sslen);
@


1.105
log
@Accidentally turned off pledge, turn it back on.
@
text
@d1 1
a1 1
/* $OpenBSD: client.c,v 1.104 2015/11/14 09:41:06 nicm Exp $ */
d413 2
a414 1
client_stdin_callback(unused int fd, unused short events, unused void *arg)
d516 1
a516 1
client_dispatch(struct imsg *imsg, unused void *arg)
@


1.104
log
@Push stdout and stderr to clients more aggressively, and add an event to
continue if the send fails.
@
text
@d1 1
a1 1
/* $OpenBSD: client.c,v 1.103 2015/10/31 13:43:38 nicm Exp $ */
d292 1
a292 1
	if (0 && pledge("stdio unix sendfd proc exec tty", NULL) != 0)
d544 1
a544 1
		if (0 && pledge("stdio unix proc exec tty", NULL) != 0)
@


1.103
log
@Don't shift version out of peerid, it is needed later.
@
text
@d1 1
a1 1
/* $OpenBSD: client.c,v 1.102 2015/10/31 08:13:58 nicm Exp $ */
d292 1
a292 1
	if (pledge("stdio unix sendfd proc exec tty", NULL) != 0)
d544 1
a544 1
		if (pledge("stdio unix proc exec tty", NULL) != 0)
@


1.102
log
@Because pledge(2) does not allow us to pass directory file descriptors
around, we can't use file descriptors for the working directory because
we will be unable to pass it to a privileged process to tell it where to
read or write files or spawn children. So move tmux back to using
strings for the current working directory. We try to check it exists
with access() when it is set but ultimately fall back to ~ if it fails
at time of use (or / if that fails too).
@
text
@d1 1
a1 1
/* $OpenBSD: client.c,v 1.101 2015/10/28 09:51:55 nicm Exp $ */
d599 1
a599 1
		    imsg->hdr.peerid);
@


1.101
log
@Like options, move the environ struct into environ.c.
@
text
@d1 1
a1 1
/* $OpenBSD: client.c,v 1.100 2015/10/27 15:58:42 nicm Exp $ */
d276 4
a279 2
	if ((cwd = getcwd(path, sizeof path)) == NULL)
		cwd = "/";
@


1.100
log
@Move struct options into options.c.
@
text
@d1 1
a1 1
/* $OpenBSD: client.c,v 1.99 2015/10/27 13:23:24 nicm Exp $ */
d297 1
a297 1
	environ_free(&global_environ);
@


1.99
log
@Break the common process set up, event loop and imsg dispatch code
between server and client out into a separate internal API. This will
make it easier to add another process.
@
text
@d1 1
a1 1
/* $OpenBSD: client.c,v 1.98 2015/10/18 20:42:42 nicm Exp $ */
d294 3
a296 3
	options_free(&global_options);
	options_free(&global_s_options);
	options_free(&global_w_options);
@


1.98
log
@Pass current directory as a string rather than a file descriptor because
pledge doesn't let us pass directory file descriptors.
@
text
@d1 1
a1 1
/* $OpenBSD: client.c,v 1.97 2015/10/17 18:30:43 nicm Exp $ */
d29 1
d37 4
a40 4
int		client_flags;
struct imsgbuf	client_ibuf;
struct event	client_event;
struct event	client_stdin;
d51 4
a54 4
int		client_exitval;
enum msgtype	client_exittype;
const char     *client_exitsession;
int		client_attached;
a59 4
int		client_write_one(enum msgtype, int, const void *, size_t);
int		client_write_server(enum msgtype, const void *, size_t);
void		client_update_event(void);
void		client_signal(int, short, void *);
d62 4
a65 3
void		client_callback(int, short, void *);
int		client_dispatch_attached(void);
int		client_dispatch_wait(void);
d223 3
a257 7
	/* Set process title, log and signals now this is the client. */
	setproctitle("client (%s)", socket_path);
	logfile("client");

	/* Establish signal handlers. */
	set_signals(client_signal);

d271 4
a298 4
	/* Create imsg. */
	imsg_init(&client_ibuf, fd);
	event_set(&client_event, fd, EV_READ, client_callback, NULL);

d342 1
a342 1
		if (client_write_server(msg, data, size) != 0) {
d349 1
a349 1
		client_write_server(msg, NULL, 0);
d351 2
a352 3
	/* Set the event and dispatch. */
	client_update_event();
	event_dispatch();
d384 1
a384 1
	client_write_one(MSG_IDENTIFY_FLAGS, -1, &flags, sizeof flags);
d388 1
a388 1
	client_write_one(MSG_IDENTIFY_TERM, -1, s, strlen(s) + 1);
d390 2
a391 2
	client_write_one(MSG_IDENTIFY_TTYNAME, -1, ttynam, strlen(ttynam) + 1);
	client_write_one(MSG_IDENTIFY_CWD, -1, cwd, strlen(cwd) + 1);
d395 1
a395 1
	client_write_one(MSG_IDENTIFY_STDIN, fd, NULL, 0);
d398 1
a398 1
	client_write_one(MSG_IDENTIFY_CLIENTPID, -1, &pid, sizeof pid);
d403 1
a403 1
			client_write_one(MSG_IDENTIFY_ENVIRON, -1, *ss, sslen);
d406 1
a406 116
	client_write_one(MSG_IDENTIFY_DONE, -1, NULL, 0);
}

/* Helper to send one message. */
int
client_write_one(enum msgtype type, int fd, const void *buf, size_t len)
{
	int	retval;

	retval = imsg_compose(&client_ibuf, type, PROTOCOL_VERSION, -1, fd,
	    (void *)buf, len);
	if (retval != 1)
		return (-1);
	return (0);
}

/* Write a message to the server without a file descriptor. */
int
client_write_server(enum msgtype type, const void *buf, size_t len)
{
	int	retval;

	retval = client_write_one(type, -1, buf, len);
	if (retval == 0)
		client_update_event();
	return (retval);
}

/* Update client event based on whether it needs to read or read and write. */
void
client_update_event(void)
{
	short	events;

	event_del(&client_event);
	events = EV_READ;
	if (client_ibuf.w.queued > 0)
		events |= EV_WRITE;
	event_set(&client_event, client_ibuf.fd, events, client_callback, NULL);
	event_add(&client_event, NULL);
}

/* Callback to handle signals in the client. */
void
client_signal(int sig, unused short events, unused void *arg)
{
	struct sigaction sigact;
	int		 status;

	if (sig == SIGCHLD)
		waitpid(WAIT_ANY, &status, WNOHANG);
	else if (!client_attached) {
		if (sig == SIGTERM)
			event_loopexit(NULL);
	} else {
		switch (sig) {
		case SIGHUP:
			client_exitreason = CLIENT_EXIT_LOST_TTY;
			client_exitval = 1;
			client_write_server(MSG_EXITING, NULL, 0);
			break;
		case SIGTERM:
			client_exitreason = CLIENT_EXIT_TERMINATED;
			client_exitval = 1;
			client_write_server(MSG_EXITING, NULL, 0);
			break;
		case SIGWINCH:
			client_write_server(MSG_RESIZE, NULL, 0);
			break;
		case SIGCONT:
			memset(&sigact, 0, sizeof sigact);
			sigemptyset(&sigact.sa_mask);
			sigact.sa_flags = SA_RESTART;
			sigact.sa_handler = SIG_IGN;
			if (sigaction(SIGTSTP, &sigact, NULL) != 0)
				fatal("sigaction failed");
			client_write_server(MSG_WAKEUP, NULL, 0);
			break;
		}
	}

	client_update_event();
}

/* Callback for client imsg read events. */
void
client_callback(unused int fd, short events, unused void *arg)
{
	ssize_t	n;
	int	retval;

	if (events & EV_READ) {
		if ((n = imsg_read(&client_ibuf)) == -1 || n == 0)
			goto lost_server;
		if (client_attached)
			retval = client_dispatch_attached();
		else
			retval = client_dispatch_wait();
		if (retval != 0) {
			event_loopexit(NULL);
			return;
		}
	}

	if (events & EV_WRITE) {
		if (msgbuf_write(&client_ibuf.w) <= 0 && errno != EAGAIN)
			goto lost_server;
	}

	client_update_event();
	return;

lost_server:
	client_exitreason = CLIENT_EXIT_LOST_SERVER;
	client_exitval = 1;
	event_loopexit(NULL);
d419 1
a419 1
	client_write_server(MSG_STDIN, &data, sizeof data);
a421 1
	client_update_event();
d471 53
d525 2
a526 2
int
client_dispatch_wait(void)
a527 1
	struct imsg		 imsg;
d529 1
a529 1
	ssize_t			 n, datalen;
d547 2
a548 32
	for (;;) {
		if ((n = imsg_get(&client_ibuf, &imsg)) == -1)
			fatalx("imsg_get failed");
		if (n == 0)
			return (0);

		data = imsg.data;
		datalen = imsg.hdr.len - IMSG_HEADER_SIZE;

		log_debug("got %u from server", imsg.hdr.type);
		switch (imsg.hdr.type) {
		case MSG_EXIT:
		case MSG_SHUTDOWN:
			if (datalen != sizeof retval && datalen != 0)
				fatalx("bad MSG_EXIT size");
			if (datalen == sizeof retval) {
				memcpy(&retval, data, sizeof retval);
				client_exitval = retval;
			}
			imsg_free(&imsg);
			return (-1);
		case MSG_READY:
			if (datalen != 0)
				fatalx("bad MSG_READY size");

			event_del(&client_stdin);
			client_attached = 1;
			client_write_server(MSG_RESIZE, NULL, 0);
			break;
		case MSG_STDIN:
			if (datalen != 0)
				fatalx("bad MSG_STDIN size");
d550 14
a563 6
			event_add(&client_stdin, NULL);
			break;
		case MSG_STDOUT:
			if (datalen != sizeof stdoutdata)
				fatalx("bad MSG_STDOUT size");
			memcpy(&stdoutdata, data, sizeof stdoutdata);
d565 7
a571 7
			client_write(STDOUT_FILENO, stdoutdata.data,
			    stdoutdata.size);
			break;
		case MSG_STDERR:
			if (datalen != sizeof stderrdata)
				fatalx("bad MSG_STDERR size");
			memcpy(&stderrdata, data, sizeof stderrdata);
d573 6
a578 11
			client_write(STDERR_FILENO, stderrdata.data,
			    stderrdata.size);
			break;
		case MSG_VERSION:
			if (datalen != 0)
				fatalx("bad MSG_VERSION size");

			fprintf(stderr, "protocol version mismatch "
			    "(client %d, server %u)\n", PROTOCOL_VERSION,
			    imsg.hdr.peerid);
			client_exitval = 1;
d580 7
a586 17
			imsg_free(&imsg);
			return (-1);
		case MSG_SHELL:
			if (datalen == 0 || data[datalen - 1] != '\0')
				fatalx("bad MSG_SHELL string");

			clear_signals(0);
			client_exec(data);
			/* NOTREACHED */
		case MSG_DETACH:
		case MSG_DETACHKILL:
			client_write_server(MSG_EXITING, NULL, 0);
			break;
		case MSG_EXITED:
			imsg_free(&imsg);
			return (-1);
		}
d588 27
a614 1
		imsg_free(&imsg);
d619 2
a620 2
int
client_dispatch_attached(void)
a621 1
	struct imsg		 imsg;
d624 1
a624 1
	ssize_t			 n, datalen;
d626 2
a627 27
	for (;;) {
		if ((n = imsg_get(&client_ibuf, &imsg)) == -1)
			fatalx("imsg_get failed");
		if (n == 0)
			return (0);

		data = imsg.data;
		datalen = imsg.hdr.len - IMSG_HEADER_SIZE;

		log_debug("got %u from server", imsg.hdr.type);
		switch (imsg.hdr.type) {
		case MSG_DETACH:
		case MSG_DETACHKILL:
			if (datalen == 0 || data[datalen - 1] != '\0')
				fatalx("bad MSG_DETACH string");

			client_exitsession = xstrdup(data);
			client_exittype = imsg.hdr.type;
			if (imsg.hdr.type == MSG_DETACHKILL)
				client_exitreason = CLIENT_EXIT_DETACHED_HUP;
			else
				client_exitreason = CLIENT_EXIT_DETACHED;
			client_write_server(MSG_EXITING, NULL, 0);
			break;
		case MSG_EXIT:
			if (datalen != 0 && datalen != sizeof (int))
				fatalx("bad MSG_EXIT size");
d629 17
a645 6
			client_write_server(MSG_EXITING, NULL, 0);
			client_exitreason = CLIENT_EXIT_EXITED;
			break;
		case MSG_EXITED:
			if (datalen != 0)
				fatalx("bad MSG_EXITED size");
d647 6
a652 5
			imsg_free(&imsg);
			return (-1);
		case MSG_SHUTDOWN:
			if (datalen != 0)
				fatalx("bad MSG_SHUTDOWN size");
d654 25
a678 7
			client_write_server(MSG_EXITING, NULL, 0);
			client_exitreason = CLIENT_EXIT_SERVER_EXITED;
			client_exitval = 1;
			break;
		case MSG_SUSPEND:
			if (datalen != 0)
				fatalx("bad MSG_SUSPEND size");
d680 3
a682 18
			memset(&sigact, 0, sizeof sigact);
			sigemptyset(&sigact.sa_mask);
			sigact.sa_flags = SA_RESTART;
			sigact.sa_handler = SIG_DFL;
			if (sigaction(SIGTSTP, &sigact, NULL) != 0)
				fatal("sigaction failed");
			kill(getpid(), SIGTSTP);
			break;
		case MSG_LOCK:
			if (datalen == 0 || data[datalen - 1] != '\0')
				fatalx("bad MSG_LOCK string");

			system(data);
			client_write_server(MSG_UNLOCK, NULL, 0);
			break;
		}

		imsg_free(&imsg);
@


1.97
log
@Add pledge "stdio unix sendfd proc exec tty" to tmux client process,
"sendfd" is dropped after first message from the server.
@
text
@d1 1
a1 1
/* $OpenBSD: client.c,v 1.96 2015/10/11 00:26:23 guenther Exp $ */
d58 1
a58 1
void		client_send_identify(const char *, int);
d217 2
a218 2
	int			 cmdflags, fd, i, cwd;
	const char*              ttynam;
d221 1
a221 1
	char			*cause;
d278 2
a279 2
	if ((cwd = open(".", O_RDONLY)) == -1)
		cwd = open("/", O_RDONLY);
d328 1
a328 1
	client_send_identify(ttynam, cwd); /* closes cwd */
d383 1
a383 1
client_send_identify(const char *ttynam, int cwd)
d398 1
a398 1
	client_write_one(MSG_IDENTIFY_CWD, cwd, NULL, 0);
@


1.96
log
@Userspace doesn't need to use SUN_LEN(): connect() and bind() must accept
sizeof(struct sockaddr_un), so do the simple, portable thing

ok beck@@ deraadt@@
@
text
@d1 1
a1 1
/* $OpenBSD: client.c,v 1.95 2015/09/24 12:06:20 nicm Exp $ */
d58 1
a58 1
void		client_send_identify(void);
d217 2
a218 1
	int			 cmdflags, fd, i;
d276 20
d328 1
a328 1
	client_send_identify();
d383 1
a383 1
client_send_identify(void)
d397 2
a398 7
	if ((s = ttyname(STDIN_FILENO)) == NULL)
		s = "";
	client_write_one(MSG_IDENTIFY_TTYNAME, -1, s, strlen(s) + 1);

	if ((fd = open(".", O_RDONLY)) == -1)
		fd = open("/", O_RDONLY);
	client_write_one(MSG_IDENTIFY_CWD, fd, NULL, 0);
a413 2

	client_update_event();
d604 13
@


1.95
log
@Don't leak fd and path on failure.
@
text
@d1 1
a1 1
/* $OpenBSD: client.c,v 1.94 2015/09/09 12:09:21 nicm Exp $ */
d122 1
a122 1
	if (connect(fd, (struct sockaddr *) &sa, SUN_LEN(&sa)) == -1) {
@


1.94
log
@No need to keep global options around for client which doesn't use them.
@
text
@d1 1
a1 1
/* $OpenBSD: client.c,v 1.93 2015/08/30 22:40:25 nicm Exp $ */
d156 1
a160 1

d165 4
@


1.93
log
@Login shell can be a client flag, and move the exec code into client.c.
@
text
@d1 1
a1 1
/* $OpenBSD: client.c,v 1.92 2015/08/30 22:19:07 nicm Exp $ */
d271 4
@


1.92
log
@Event base does not need to be global.
@
text
@d1 1
a1 1
/* $OpenBSD: client.c,v 1.91 2015/07/13 18:10:26 nicm Exp $ */
d36 1
d55 1
d58 1
a58 1
void		client_send_identify(int);
d67 1
a67 1
int		client_dispatch_wait(void *);
d220 3
d274 1
a274 1
	event_set(&client_event, fd, EV_READ, client_callback, shell_cmd);
d280 1
a280 1
	if (flags & CLIENT_CONTROLCONTROL) {
d299 1
a299 1
	client_send_identify(flags);
d334 1
a334 1
		if (client_exitreason != CLIENT_EXIT_NONE && !login_shell)
d340 1
a340 1
	} else if (flags & CLIENT_CONTROLCONTROL) {
d354 1
a354 1
client_send_identify(int flags)
d359 1
a359 1
	int		  fd;
d429 1
a429 2
	event_set(
	    &client_event, client_ibuf.fd, events, client_callback, shell_cmd);
d435 1
a435 1
client_signal(int sig, unused short events, unused void *data)
d477 1
a477 1
client_callback(unused int fd, short events, void *data)
d488 1
a488 1
			retval = client_dispatch_wait(data);
d511 1
a511 1
client_stdin_callback(unused int fd, unused short events, unused void *data1)
d543 29
d574 1
a574 1
client_dispatch_wait(void *data0)
d650 1
a650 1
			shell_exec(data, data0);
@


1.91
log
@Ignore environment variables that are too long to send to the server.
@
text
@d1 1
a1 1
/* $OpenBSD: client.c,v 1.90 2015/06/14 10:07:44 nicm Exp $ */
d55 1
a55 1
int		client_connect(char *, int);
d99 1
a99 1
client_connect(char *path, int start_server)
d152 1
a152 1
		fd = server_start(lockfd, lockfile);
d206 1
a206 1
client_main(int argc, char **argv, int flags)
d255 1
a255 1
	fd = client_connect(socket_path, cmdflags & CMD_STARTSERVER);
@


1.90
log
@Add a format for client PID (client_pid) and server PID (pid). Diff for
client_pid from Thomas Adam.
@
text
@d1 1
a1 1
/* $OpenBSD: client.c,v 1.89 2015/06/04 23:27:51 nicm Exp $ */
d353 1
d378 5
a382 2
	for (ss = environ; *ss != NULL; ss++)
		client_write_one(MSG_IDENTIFY_ENVIRON, -1, *ss, strlen(*ss) + 1);
@


1.89
log
@Move the nested check from client to server and compare the client tty
name to all the pane pty names instead of comparing socket paths. This
means that "new -d" will work without unsetting $TMUX.
@
text
@d1 1
a1 1
/* $OpenBSD: client.c,v 1.88 2015/04/24 20:58:44 nicm Exp $ */
d351 1
a351 1
	const char	*s;
d353 2
a354 1
	int		 fd;
d373 3
@


1.88
log
@Set up signal handler earlier so that we don't get zombies, reported by
sobrado@@.
@
text
@d1 1
a1 1
/* $OpenBSD: client.c,v 1.87 2015/04/21 22:21:41 nicm Exp $ */
d225 1
a225 1
		cmdflags = CMD_STARTSERVER|CMD_CANTNEST;
a242 2
			if (cmd->entry->flags & CMD_CANTNEST)
				cmdflags |= CMD_CANTNEST;
a244 12
	}

	/*
	 * Check if this could be a nested session, if the command can't nest:
	 * if the socket path matches $TMUX, this is probably the same server.
	 */
	if (shell_cmd == NULL && environ_path != NULL &&
	    (cmdflags & CMD_CANTNEST) &&
	    strcmp(socket_path, environ_path) == 0) {
		fprintf(stderr, "sessions should be nested with care, "
		    "unset $TMUX to force\n");
		return (1);
@


1.87
log
@Simplify error messages when socket connect fails, suggested by "Karthik K".
@
text
@d1 1
a1 1
/* $OpenBSD: client.c,v 1.86 2015/03/31 17:45:10 nicm Exp $ */
d265 3
a305 3

	/* Establish signal handlers. */
	set_signals(client_signal);
@


1.86
log
@Fix some format specifier nits, from Ben Boeckel.
@
text
@d1 1
a1 1
/* $OpenBSD: client.c,v 1.85 2014/10/20 23:27:14 nicm Exp $ */
d268 7
a274 2
		fprintf(stderr, "failed to connect to server: %s\n",
		    strerror(errno));
@


1.85
log
@Tidy up some includes.
@
text
@d1 1
a1 1
/* $OpenBSD: client.c,v 1.84 2014/10/01 23:23:19 nicm Exp $ */
d560 1
a560 1
		log_debug("got %d from server", imsg.hdr.type);
d607 1
a607 1
			    "(client %u, server %u)\n", PROTOCOL_VERSION,
d651 1
a651 1
		log_debug("got %d from server", imsg.hdr.type);
@


1.84
log
@Call waitpid on SIGCHLD even if client not attached, it is possible (on
very slow platforms) for the first daemon() child to still be running
when client_attached is set so we end up with a zombie. From J Raynor.
@
text
@d1 1
a1 1
/* $OpenBSD: client.c,v 1.83 2014/09/01 21:50:18 nicm Exp $ */
d29 1
@


1.83
log
@Various minor style and spacing nits.
@
text
@d1 1
a1 1
/* $OpenBSD: client.c,v 1.82 2014/07/21 10:52:48 nicm Exp $ */
d436 4
a439 6
	if (!client_attached) {
		switch (sig) {
		case SIGCHLD:
			waitpid(WAIT_ANY, &status, WNOHANG);
			break;
		case SIGTERM:
a440 2
			break;
		}
@


1.82
log
@lockf is entirely useless and it was a mistake to change to it, go back
to using flock which actually works sensibly. Also always retry the lock
to fix a potential race, and add some extra logging.
@
text
@d1 1
a1 1
/* $OpenBSD: client.c,v 1.81 2014/07/13 20:51:08 krw Exp $ */
d314 1
a314 1
		if (cmd_pack_argv(argc, argv, (char*)(data + 1), size) != 0) {
d396 1
a396 1
	    (void*)buf, len);
@


1.81
log
@An EOF is a good reason to close a connection.

ok nicm@@
@
text
@d1 1
a1 1
/* $OpenBSD: client.c,v 1.80 2014/04/29 22:31:22 nicm Exp $ */
d80 1
d82 5
a86 2
	if (lockf(lockfd, F_TLOCK, 0) == -1 && errno == EAGAIN) {
		while (lockf(lockfd, F_LOCK, 0) == -1 && errno == EINTR)
d91 1
d102 2
a103 2
	int			fd, lockfd;
	char		       *lockfile;
d112 1
d118 1
d120 1
d127 16
a142 3
		xasprintf(&lockfile, "%s.lock", path);
		if ((lockfd = client_get_lock(lockfile)) == -1) {
			free(lockfile);
d145 1
d152 2
d260 5
a264 1
	/* Initialise the client socket and start the server. */
a270 4

	/* Set process title, log and signals now this is the client. */
	setproctitle("client (%s)", socket_path);
	logfile("client");
@


1.80
log
@fcntl.h is still needed here.
@
text
@d1 1
a1 1
/* $OpenBSD: client.c,v 1.79 2014/04/17 11:38:35 nicm Exp $ */
d472 1
a472 1
		if (msgbuf_write(&client_ibuf.w) < 0 && errno != EAGAIN)
@


1.79
log
@Remove some unnecessary includes and fix a typo.
@
text
@d1 1
a1 1
/* $OpenBSD: client.c,v 1.78 2014/01/09 21:20:45 nicm Exp $ */
d28 1
@


1.78
log
@Fix a memory/fd leak reported by Tiago Cunha.
@
text
@d1 1
a1 1
/* $OpenBSD: client.c,v 1.77 2014/01/09 14:05:55 nicm Exp $ */
a27 2
#include <fcntl.h>
#include <pwd.h>
@


1.77
log
@Three small changes from Tiago Cunha:

- Check for truncation when copying path.
- Don't need to use a temporary buffer in screen_set_title.
- Include strerror in output when connecting to server fails.
@
text
@d1 1
a1 1
/* $OpenBSD: client.c,v 1.76 2013/11/13 20:43:36 benno Exp $ */
d121 2
a122 1
		if ((lockfd = client_get_lock(lockfile)) == -1)
d124 4
a127 1
		if (unlink(path) != 0 && errno != ENOENT)
d129 1
@


1.76
log
@from nicm: : handle msgbuf_write() returning EAGAIN
@
text
@d1 1
a1 1
/* $OpenBSD: client.c,v 1.75 2013/10/10 12:35:30 nicm Exp $ */
d235 2
a236 1
		fprintf(stderr, "failed to connect to server\n");
@


1.75
log
@Use format_get_command() and some spacing tweaks.
@
text
@d1 1
a1 1
/* $OpenBSD: client.c,v 1.74 2013/10/10 12:29:35 nicm Exp $ */
d467 1
a467 1
		if (msgbuf_write(&client_ibuf.w) < 0)
@


1.74
log
@We accidentally haven't been using $TMUX to work out the session for a
while and in fact it is less useful that using the client ttyname. So
don't bother and don't pass it from the client. If we need it in future
it is in c->environ.
@
text
@d1 1
a1 1
/* $OpenBSD: client.c,v 1.73 2013/10/10 12:28:08 nicm Exp $ */
d354 1
@


1.73
log
@Show session name in detached message. Requested by somebody a few
months ago who didn't bother testing it. But it works for me anyway.
@
text
@d1 1
a1 1
/* $OpenBSD: client.c,v 1.72 2013/10/10 12:27:38 nicm Exp $ */
a281 4

		/* Fill in command line arguments. */
		data->pid = environ_pid;
		data->session_id = environ_session_id;
@


1.72
log
@Don't look at string[length - 1] if length == 0.
@
text
@d1 1
a1 1
/* $OpenBSD: client.c,v 1.71 2013/10/10 12:26:34 nicm Exp $ */
d51 1
d142 2
d148 5
d155 5
d598 1
d630 1
d632 2
a633 3
		case MSG_DETACH:
			if (datalen != 0)
				fatalx("bad MSG_DETACH size");
d635 1
@


1.71
log
@Alter how tmux handles the working directory to internally use file
descriptors rather than strings.

- Each session still has a current working directory.

- New sessions still get their working directory from the client that
  created them or its attached session if any.

- New windows are created by default in the session working directory.

- The -c flag to new, neww, splitw allows the working directory to be
  overridden.

- The -c flag to attach let's the session working directory be changed.

- The default-path option has been removed.

To get the equivalent to default-path '.', do:

        bind c neww -c $PWD

To get the equivalent of default-path '~', do:

        bind c neww -c ~

This also changes the client identify protocol to be a set of messages rather
than one as well as some other changes that should make it easier to make
backwards-compatible protocol changes in future.
@
text
@d1 1
a1 1
/* $OpenBSD: client.c,v 1.70 2013/10/10 12:13:56 nicm Exp $ */
d578 1
a578 1
			if (data[datalen - 1] != '\0')
d662 1
a662 1
			if (data[datalen - 1] != '\0')
@


1.70
log
@Similarly for MSG_COMMAND - allow full imsg limit not arbitrary 2048.
@
text
@d1 1
a1 1
/* $OpenBSD: client.c,v 1.69 2013/10/10 12:13:29 nicm Exp $ */
a55 1
void		client_send_environ(void);
d259 1
a259 2
	/* Send initial environment. */
	client_send_environ();
d317 1
a317 1
/* Send identify message to server with the file descriptors. */
d321 17
a337 13
	struct msg_identify_data	data;
	char			       *term;
	int				fd;

	data.flags = flags;

	if (getcwd(data.cwd, sizeof data.cwd) == NULL)
		*data.cwd = '\0';

	term = getenv("TERM");
	if (term == NULL ||
	    strlcpy(data.term, term, sizeof data.term) >= sizeof data.term)
		*data.term = '\0';
d341 1
a341 4
	imsg_compose(&client_ibuf,
	    MSG_IDENTIFY, PROTOCOL_VERSION, -1, fd, &data, sizeof data);
	client_update_event();
}
d343 3
a345 6
/* Forward entire environment to server. */
void
client_send_environ(void)
{
	struct msg_environ_data	data;
	char		      **var;
d347 1
a347 5
	for (var = environ; *var != NULL; var++) {
		if (strlcpy(data.var, *var, sizeof data.var) >= sizeof data.var)
			continue;
		client_write_server(MSG_ENVIRON, &data, sizeof data);
	}
a589 2
		default:
			fatalx("unexpected message");
a667 2
		default:
			fatalx("unexpected message");
@


1.69
log
@Instead of fixed size buffers for some messages, send only the string
length.
@
text
@d1 1
a1 1
/* $OpenBSD: client.c,v 1.68 2013/10/10 12:12:08 nicm Exp $ */
d57 2
a58 1
void		client_write_server(enum msgtype, void *, size_t);
d169 2
a170 2
	struct msg_command_data	 cmddata;
	int			 cmdflags, fd;
d175 1
d266 6
d273 2
a274 2
		cmddata.pid = environ_pid;
		cmddata.session_id = environ_session_id;
d277 2
a278 3
		cmddata.argc = argc;
		if (cmd_pack_argv(
		    argc, argv, cmddata.argv, sizeof cmddata.argv) != 0) {
d280 1
d283 1
d285 7
a291 1
		client_write_server(msg, &cmddata, sizeof cmddata);
d358 13
d372 2
a373 2
void
client_write_server(enum msgtype type, void *buf, size_t len)
d375 6
a380 2
	imsg_compose(&client_ibuf, type, PROTOCOL_VERSION, -1, -1, buf, len);
	client_update_event();
d563 2
a564 1
			client_write(STDOUT_FILENO, stdoutdata.data, stdoutdata.size);
d571 2
a572 1
			client_write(STDERR_FILENO, stderrdata.data, stderrdata.size);
@


1.68
log
@Merge IDENTIFY_* flags with CLIENT_* flags.
@
text
@d1 1
a1 1
/* $OpenBSD: client.c,v 1.67 2013/10/10 12:09:34 nicm Exp $ */
d482 1
a482 1
client_dispatch_wait(void *data)
d484 6
a489 7
	struct imsg		imsg;
	ssize_t			n, datalen;
	struct msg_shell_data	shelldata;
	struct msg_exit_data	exitdata;
	struct msg_stdout_data	stdoutdata;
	struct msg_stderr_data	stderrdata;
	const char             *shellcmd = data;
d496 2
d504 5
a508 6
			if (datalen != sizeof exitdata) {
				if (datalen != 0)
					fatalx("bad MSG_EXIT size");
			} else {
				memcpy(&exitdata, imsg.data, sizeof exitdata);
				client_exitval = exitdata.retcode;
d528 2
a529 2
				fatalx("bad MSG_STDOUT");
			memcpy(&stdoutdata, imsg.data, sizeof stdoutdata);
d535 2
a536 2
				fatalx("bad MSG_STDERR");
			memcpy(&stderrdata, imsg.data, sizeof stderrdata);
d552 2
a553 4
			if (datalen != sizeof shelldata)
				fatalx("bad MSG_SHELL size");
			memcpy(&shelldata, imsg.data, sizeof shelldata);
			shelldata.shell[(sizeof shelldata.shell) - 1] = '\0';
d556 1
a556 2

			shell_exec(shelldata.shell, shellcmd);
d576 4
a579 4
	struct imsg		imsg;
	struct msg_lock_data	lockdata;
	struct sigaction	sigact;
	ssize_t			n, datalen;
d586 2
d605 1
a605 2
			if (datalen != 0 &&
			    datalen != sizeof (struct msg_exit_data))
d638 2
a639 3
			if (datalen != sizeof lockdata)
				fatalx("bad MSG_LOCK size");
			memcpy(&lockdata, imsg.data, sizeof lockdata);
d641 1
a641 2
			lockdata.cmd[(sizeof lockdata.cmd) - 1] = '\0';
			system(lockdata.cmd);
@


1.67
log
@Remove CMD_SENDENVIRON.
@
text
@d1 1
a1 1
/* $OpenBSD: client.c,v 1.66 2013/04/22 08:42:19 nicm Exp $ */
d237 1
a237 1
	if (flags & IDENTIFY_TERMIOS) {
d292 6
a297 8
	} else if (flags & IDENTIFY_TERMIOS) {
		if (flags & IDENTIFY_CONTROL) {
			if (client_exitreason != CLIENT_EXIT_NONE)
			    printf("%%exit %s\n", client_exit_message());
			else
			    printf("%%exit\n");
			printf("\033\\");
		}
@


1.66
log
@Use lockf which is more portable than flock, from Dagobert Michelsen.
@
text
@d1 1
a1 1
/* $OpenBSD: client.c,v 1.65 2013/03/25 11:38:57 nicm Exp $ */
d182 1
a182 1
		cmdflags = CMD_STARTSERVER|CMD_SENDENVIRON|CMD_CANTNEST;
a199 2
			if (cmd->entry->flags & CMD_SENDENVIRON)
				cmdflags |= CMD_SENDENVIRON;
d259 1
a259 2
	if (cmdflags & CMD_SENDENVIRON)
		client_send_environ();
@


1.65
log
@We ignore SIGWINCH until ready, so send a MSG_RESIZE immediately when
becoming ready.
@
text
@d1 1
a1 1
/* $OpenBSD: client.c,v 1.64 2013/03/25 10:11:45 nicm Exp $ */
d81 2
a82 2
	if (flock(lockfd, LOCK_EX|LOCK_NB) == -1 && errno == EWOULDBLOCK) {
		while (flock(lockfd, LOCK_EX) == -1 && errno == EINTR)
@


1.64
log
@Rename session idx to session id throughout and add $ prefix to targets
to use it, extended from a diff from George Nachman.
@
text
@d1 1
a1 1
/* $OpenBSD: client.c,v 1.63 2013/03/25 10:03:24 nicm Exp $ */
d523 1
@


1.63
log
@Send DSC 1000p at the beginning of a -CC client's lifetime and ST and
the end, from George Nachman.
@
text
@d1 1
a1 1
/* $OpenBSD: client.c,v 1.62 2013/03/24 09:54:10 nicm Exp $ */
d269 1
a269 1
		cmddata.idx = environ_idx;
@


1.62
log
@Add a command queue to standardize and simplify commands that call other
commands and allow a command to block execution of subsequent
commands. This allows run-shell and if-shell to be synchronous which has
been much requested.

Each client has a default command queue and commands are consumed one at
a time from it. A command may suspend execution from the queue by
returning CMD_RETURN_WAIT and then resume it by calling cmd_continue() -
for example run-shell does this from the callback that is fired after
the job is freed.

When the command queue becomes empty, command clients are automatically
exited (unless attaching). A callback is also fired - this is used for
nested commands in, for example, if-shell which can block execution of
the client's cmdq until a new cmdq becomes empty.

Also merge all the old error/info/print functions together and lose the
old curclient/cmdclient distinction - a cmdq is bound to one client (or
none if in the configuration file), this is a command client if
c->session is NULL otherwise an attached client.
@
text
@d1 1
a1 1
/* $OpenBSD: client.c,v 1.61 2013/03/22 10:31:22 nicm Exp $ */
d295 8
a302 1
	} else if (flags & IDENTIFY_TERMIOS)
d304 1
@


1.61
log
@No more lint means no more ARGSUSED.
@
text
@d1 1
a1 1
/* $OpenBSD: client.c,v 1.60 2012/09/03 08:48:57 nicm Exp $ */
d191 2
a192 1
		if ((cmdlist = cmd_list_parse(argc, argv, &cause)) == NULL) {
@


1.60
log
@If stdin in the client is enable immediately, tmux will eat anything
sent to stdin before it is needed, which can be inconvenient (eg pasting
commands). Instead, start with stdin disabled and reuse MSG_STDIN from
server->client to mean that stdin should be enabled. Based on a diff
from Chris Johnsen.
@
text
@d1 1
a1 1
/* $OpenBSD: client.c,v 1.59 2012/08/27 21:35:11 nicm Exp $ */
a362 1
/* ARGSUSED */
a408 1
/* ARGSUSED */
a442 1
/* ARGSUSED */
a570 1
/* ARGSUSED */
@


1.59
log
@Change a log to fprintf that was missed last time around, from Tiago Cunha.
@
text
@d1 1
a1 1
/* $OpenBSD: client.c,v 1.58 2012/07/10 11:53:01 nicm Exp $ */
a283 1
	event_add (&client_stdin, NULL);
d517 6
@


1.58
log
@xfree is not particularly helpful, remove it. From Thomas Adam.
@
text
@d1 1
a1 1
/* $OpenBSD: client.c,v 1.57 2012/06/18 13:34:56 nicm Exp $ */
d192 1
a192 1
			log_warnx("%s", cause);
@


1.57
log
@Actually write all the data to stdout/stderr.
@
text
@d1 1
a1 1
/* $OpenBSD: client.c,v 1.56 2012/06/18 13:16:42 nicm Exp $ */
d125 1
a125 1
		xfree(lockfile);
@


1.56
log
@Add a skeleton mode to tmux (called "control mode") that let's tmux
commands be sent and output received on stdout. This can be used to
integrate with other terminal emulators and should allow some other
things to be made simpler later. More to come so doesn't do much yet and
deliberately not documented.
@
text
@d1 1
a1 1
/* $OpenBSD: client.c,v 1.55 2012/05/25 08:28:10 nicm Exp $ */
d61 1
d462 18
d524 1
a524 1
			fwrite(stdoutdata.data, stdoutdata.size, 1, stdout);
d531 1
a531 1
			fwrite(stderrdata.data, stderrdata.size, 1, stderr);
@


1.55
log
@Simplify logging and just fprintf(stderr, ...) for early errors.
@
text
@d1 1
a1 1
/* $OpenBSD: client.c,v 1.54 2012/05/21 18:27:42 nicm Exp $ */
d172 1
d237 17
d294 2
a295 1
	}
d535 6
@


1.54
log
@Instead of passing stdin/stdout/stderr file descriptors over imsg and
handling them in the server, handle them in the client and pass buffers
over imsg. This is much tidier for some upcoming changes and the
performance hit isn't critical.

The tty fd is still passed to the server as before.

This bumps the tmux protocol version so new clients and old servers are
incompatible.
@
text
@d1 1
a1 1
/* $OpenBSD: client.c,v 1.53 2012/04/23 23:25:02 nicm Exp $ */
d212 2
a213 2
		log_warnx("sessions should be nested with care. "
		    "unset $TMUX to force.");
d220 1
a220 1
		log_warn("failed to connect to server");
d255 1
a255 1
			log_warnx("command too long");
d541 1
a541 1
		log_debug("client got %d", imsg.hdr.type);
@


1.53
log
@Add missing prototype.
@
text
@d1 1
a1 1
/* $OpenBSD: client.c,v 1.52 2012/04/23 23:18:43 nicm Exp $ */
d38 1
d60 1
d232 5
d265 1
d277 1
a298 10
	if ((fd = dup(STDOUT_FILENO)) == -1)
		fatal("dup failed");
	imsg_compose(&client_ibuf,
	    MSG_STDOUT, PROTOCOL_VERSION, -1, fd, NULL, 0);

	if ((fd = dup(STDERR_FILENO)) == -1)
		fatal("dup failed");
	imsg_compose(&client_ibuf,
	    MSG_STDERR, PROTOCOL_VERSION, -1, fd, NULL, 0);

d303 1
d325 1
d425 17
d450 2
a453 3
	if ((n = imsg_read(&client_ibuf)) == -1 || n == 0)
		fatalx("imsg_read failed");

d461 1
d478 1
d481 14
d499 3
a501 2
			log_warnx("protocol version mismatch (client %u, "
			    "server %u)", PROTOCOL_VERSION, imsg.hdr.peerid);
@


1.52
log
@Use an enum for client exit reasons, from George Nachman.
@
text
@d1 1
a1 1
/* $OpenBSD: client.c,v 1.51 2012/03/24 11:23:19 nicm Exp $ */
d62 1
@


1.51
log
@Add sys/file.h.
@
text
@d1 1
a1 1
/* $OpenBSD: client.c,v 1.50 2012/03/19 08:42:06 nicm Exp $ */
d38 10
a47 1
const char     *client_exitmsg;
d133 25
d207 2
a208 1
	    cmdflags & CMD_CANTNEST && strcmp(socket_path, environ_path) == 0) {
d261 2
a262 2
		if (client_exitmsg != NULL && !login_shell)
			printf("[%s]\n", client_exitmsg);
d361 1
a361 1
			client_exitmsg = "lost tty";
d366 1
a366 1
			client_exitmsg = "terminated";
d418 1
a418 1
	client_exitmsg = "lost server";
d515 1
a515 1
				client_exitmsg = "detached and SIGHUP";
d517 1
a517 1
				client_exitmsg = "detached";
d526 1
a526 1
			client_exitmsg = "exited";
d539 1
a539 1
			client_exitmsg = "server exited";
@


1.50
log
@Move MSG_IDENTIFY to the last sent by the client, this will be needed by
control clients and irrelevant for others.
@
text
@d1 1
a1 1
/* $OpenBSD: client.c,v 1.49 2012/03/09 09:57:40 nicm Exp $ */
d20 1
@


1.49
log
@Use a lock file and flock() to serialize server start, avoids problems
when running a bunch of tmux from cron at the same time. Based on a diff
from Tim Ruehsen.
@
text
@d1 1
a1 1
/* $OpenBSD: client.c,v 1.48 2011/03/03 08:51:47 nicm Exp $ */
a252 5
	if ((fd = dup(STDIN_FILENO)) == -1)
		fatal("dup failed");
	imsg_compose(&client_ibuf,
	    MSG_IDENTIFY, PROTOCOL_VERSION, -1, fd, &data, sizeof data);

d262 5
@


1.48
log
@Add a -P option to detach to HUP the client's parent process (usually
causing it to exit as well).
@
text
@d1 1
a1 1
/* $OpenBSD: client.c,v 1.47 2011/01/08 01:52:36 nicm Exp $ */
d42 1
d53 24
d83 2
a84 1
	int			fd;
d94 1
d99 2
d103 10
a112 12
		switch (errno) {
		case ECONNREFUSED:
			if (unlink(path) != 0)
				goto failed;
			/* FALLTHROUGH */
		case ENOENT:
			if ((fd = server_start()) == -1)
				goto failed;
			break;
		default:
			goto failed;
		}
@


1.47
log
@Move all calls to fcntl(...O_NONBLOCK) into a function and clear the
flag on the stdio file descriptors before closing them (fixes things
like "tmux ls && cat").
@
text
@d1 1
a1 1
/* $OpenBSD: client.c,v 1.46 2010/10/18 20:00:02 nicm Exp $ */
d39 1
d104 1
d197 8
a204 2
	if (client_attached && client_exitmsg != NULL && !login_shell)
		printf("[%s]\n", client_exitmsg);
d445 1
d450 5
a455 1
			client_exitmsg = "detached";
@


1.46
log
@Merge the before and after attach client code into one in client.c
(instead of two in tmux.c and client.c).
@
text
@d1 1
a1 1
/* $OpenBSD: client.c,v 1.45 2010/10/16 08:31:55 nicm Exp $ */
d57 1
a57 1
	int			fd, mode;
d87 1
a87 4
	if ((mode = fcntl(fd, F_GETFL)) == -1)
		fatal("fcntl failed");
	if (fcntl(fd, F_SETFL, mode|O_NONBLOCK) == -1)
		fatal("fcntl failed");
@


1.45
log
@Trying to set FD_CLOEXEC on every fd is a lost cause, just use
closefrom() before exec.
@
text
@d1 1
a1 1
/* $OpenBSD: client.c,v 1.44 2010/08/23 17:36:32 nicm Exp $ */
a30 1
#include <syslog.h>
d39 1
d41 1
d48 2
a49 1
int		client_dispatch(void);
d51 3
a53 2
struct imsgbuf *
client_init(char *path, int cmdflags, int flags)
a57 5
	char		      	rpathbuf[MAXPATHLEN];

	if (realpath(path, rpathbuf) == NULL)
		strlcpy(rpathbuf, path, sizeof rpathbuf);
	setproctitle("client (%s)", rpathbuf);
d64 1
a64 1
		goto not_found;
d71 2
a72 2
		if (!(cmdflags & CMD_STARTSERVER))
			goto not_found;
d76 1
a76 1
				goto not_found;
d79 5
a83 3
			if ((fd = server_start(path)) == -1)
				goto start_failed;
			goto server_started;
a84 1
		goto not_found;
a86 1
server_started:
d91 73
d165 4
a168 1
	event_set(&client_event, fd, EV_READ, client_callback, NULL);
d170 1
d175 17
a191 1
	return (&client_ibuf);
d193 8
a200 7
start_failed:
	log_warnx("server failed to start");
	return (NULL);

not_found:
	log_warn("server not found");
	return (NULL);
d203 1
d228 2
a229 1
	imsg_compose(&client_ibuf, MSG_STDOUT, PROTOCOL_VERSION, -1, fd, NULL, 0);
d233 2
a234 1
	imsg_compose(&client_ibuf, MSG_STDERR, PROTOCOL_VERSION, -1, fd, NULL, 0);
d237 1
d251 1
d258 1
d268 2
a269 1
	event_set(&client_event, client_ibuf.fd, events, client_callback, NULL);
d273 1
a273 37
__dead void
client_main(void)
{
	logfile("client");

	/* Note: event_init() has already been called. */

	/* Set up signals. */
	set_signals(client_signal);

	/*
	 * Send a resize message immediately in case the terminal size has
	 * changed between the identify message to the server and the MSG_READY
	 * telling us to move into the client code.
	 */
	 client_write_server(MSG_RESIZE, NULL, 0);

	/*
	 * imsg_read in the first client poll loop (before the terminal has
	 * been initialised) may have read messages into the buffer after the
	 * MSG_READY switched to here. Process anything outstanding now to
	 * avoid hanging waiting for messages that have already arrived.
	 */
	if (client_dispatch() != 0)
		goto out;

	/* Set the event and dispatch. */
	client_update_event();
	event_dispatch();

out:
	/* Print the exit message, if any, and exit. */
	if (client_exitmsg != NULL && !login_shell)
		printf("[%s]\n", client_exitmsg);
	exit(client_exitval);
}

d278 2
a279 1
	struct sigaction	sigact;
d281 34
a314 23
	switch (sig) {
	case SIGHUP:
		client_exitmsg = "lost tty";
		client_exitval = 1;
		client_write_server(MSG_EXITING, NULL, 0);
		break;
	case SIGTERM:
		client_exitmsg = "terminated";
		client_exitval = 1;
		client_write_server(MSG_EXITING, NULL, 0);
		break;
	case SIGWINCH:
		client_write_server(MSG_RESIZE, NULL, 0);
		break;
	case SIGCONT:
		memset(&sigact, 0, sizeof sigact);
		sigemptyset(&sigact.sa_mask);
		sigact.sa_flags = SA_RESTART;
		sigact.sa_handler = SIG_IGN;
		if (sigaction(SIGTSTP, &sigact, NULL) != 0)
			fatal("sigaction failed");
		client_write_server(MSG_WAKEUP, NULL, 0);
		break;
d320 1
d323 1
a323 1
client_callback(unused int fd, short events, unused void *data)
d326 1
d331 5
a335 1
		if (client_dispatch() != 0) {
d355 68
d424 1
a424 1
client_dispatch(void)
@


1.44
log
@Can't call event_del() without event_set() first - so call event_set()
when setting up the client.
@
text
@d1 1
a1 1
/* $OpenBSD: client.c,v 1.43 2010/08/22 16:09:49 nicm Exp $ */
a91 2
		fatal("fcntl failed");
	if (fcntl(fd, F_SETFD, FD_CLOEXEC) == -1)
@


1.43
log
@MSG_EXIT can now have a return code in the message, so check for that
size as well. Stops the client fatal()ing on exit.
@
text
@d1 1
a1 1
/* $OpenBSD: client.c,v 1.42 2010/06/28 22:10:42 nicm Exp $ */
d96 1
@


1.42
log
@Send all three of stdin, stdout, stderr from the client to the server, so that
commands can directly make use of them. This means that load-buffer and
save-buffer can have "-" as the file to read from stdin or write to stdout.

This is a protocol version bump so the tmux server will need to be restarted
after upgrade (or an older client used).
@
text
@d1 1
a1 1
/* $OpenBSD: client.c,v 1.41 2010/06/05 16:47:11 nicm Exp $ */
d300 2
a301 1
			if (datalen != 0)
@


1.41
log
@Fix problems with window sizing seen by Raghavendra D Prabhu when
starting tmux from .xinitrc.

One of the very few things the server relies on the client for now is to
pass through a message on SIGWINCH, but there is a condition where
potentially a SIGWINCH may be lost during the transition from unattached
(main.c) to attached (client.c). So trigger a size change immediately
after the client installs its SIGWINCH handler.

Also, when the terminal is resized, reset the scroll region and cursor
position. Previously, we were clearing our saved idea of these, but in
fact some terminals do not reset them on resize, so this caused problems
during redraw.

While here make a resize to the same size not cause a redraw and rename
the tmux.out output log file to include the tmux PID.
@
text
@d1 1
a1 1
/* $OpenBSD: client.c,v 1.40 2010/06/05 16:29:45 nicm Exp $ */
d99 1
a99 2
	if (isatty(STDIN_FILENO))
		client_send_identify(flags);
d133 8
@


1.40
log
@This ioctl(TIOCGWINSZ) call is no longer necessary, the result is never
used and the server now does it later on the tty fd directly.
@
text
@d1 1
a1 1
/* $OpenBSD: client.c,v 1.39 2010/05/12 15:05:39 jsing Exp $ */
d177 7
@


1.39
log
@Catch SIGHUP and terminate if running as a client. This prevents clients
from being left hanging around when, for example, a SSH session is
disconnected.

ok nicm@@
@
text
@d1 1
a1 1
/* $OpenBSD: client.c,v 1.37 2010/05/04 08:48:06 nicm Exp $ */
a19 1
#include <sys/ioctl.h>
a116 1
	struct winsize			ws;
a119 2
	if (ioctl(STDIN_FILENO, TIOCGWINSZ, &ws) == -1)
		fatal("ioctl(TIOCGWINSZ)");
@


1.38
log
@Put this back in with the initialisation in the right order.
@
text
@d209 5
@


1.37
log
@Revert last change, it appears to be broken somehow.
@
text
@d1 1
a1 1
/* $OpenBSD: client.c,v 1.35 2009/12/03 22:50:09 nicm Exp $ */
a174 3
	struct event		ev_sigcont, ev_sigterm, ev_sigwinch;
	struct sigaction	sigact;

d180 1
a180 21
	memset(&sigact, 0, sizeof sigact);
	sigemptyset(&sigact.sa_mask);
	sigact.sa_flags = SA_RESTART;
	sigact.sa_handler = SIG_IGN;
	if (sigaction(SIGINT, &sigact, NULL) != 0)
		fatal("sigaction failed");
	if (sigaction(SIGPIPE, &sigact, NULL) != 0)
		fatal("sigaction failed");
	if (sigaction(SIGUSR1, &sigact, NULL) != 0)
		fatal("sigaction failed");
	if (sigaction(SIGUSR2, &sigact, NULL) != 0)
		fatal("sigaction failed");
	if (sigaction(SIGTSTP, &sigact, NULL) != 0)
		fatal("sigaction failed");

	signal_set(&ev_sigcont, SIGCONT, client_signal, NULL);
	signal_add(&ev_sigcont, NULL);
	signal_set(&ev_sigterm, SIGTERM, client_signal, NULL);
	signal_add(&ev_sigterm, NULL);
	signal_set(&ev_sigwinch, SIGWINCH, client_signal, NULL);
	signal_add(&ev_sigwinch, NULL);
@


1.36
log
@Make signal handler setup/teardown two common functions instead of six,
and reset SIGCHLD after fork to fix problems with some shells. From
Romain Francois.
@
text
@d175 3
d183 21
a203 1
	set_signals(client_signal);
@


1.35
log
@Massive spaces->tabs and trailing whitespace cleanup, hopefully for the last
time now I've configured emacs to make them displayed in really annoying
colours...
@
text
@d1 1
a1 1
/* $OpenBSD: client.c,v 1.34 2009/11/26 21:37:13 nicm Exp $ */
a174 3
	struct event		ev_sigcont, ev_sigterm, ev_sigwinch;
	struct sigaction	sigact;

d180 1
a180 21
	memset(&sigact, 0, sizeof sigact);
	sigemptyset(&sigact.sa_mask);
	sigact.sa_flags = SA_RESTART;
	sigact.sa_handler = SIG_IGN;
	if (sigaction(SIGINT, &sigact, NULL) != 0)
		fatal("sigaction failed");
	if (sigaction(SIGPIPE, &sigact, NULL) != 0)
		fatal("sigaction failed");
	if (sigaction(SIGUSR1, &sigact, NULL) != 0)
		fatal("sigaction failed");
	if (sigaction(SIGUSR2, &sigact, NULL) != 0)
		fatal("sigaction failed");
	if (sigaction(SIGTSTP, &sigact, NULL) != 0)
		fatal("sigaction failed");

	signal_set(&ev_sigcont, SIGCONT, client_signal, NULL);
	signal_add(&ev_sigcont, NULL);
	signal_set(&ev_sigterm, SIGTERM, client_signal, NULL);
	signal_add(&ev_sigterm, NULL);
	signal_set(&ev_sigwinch, SIGWINCH, client_signal, NULL);
	signal_add(&ev_sigwinch, NULL);
@


1.34
log
@Remove a couple of unused arguments where possible, and add /* ARGSUSED */ to
the rest to reduce lint output.
@
text
@d1 1
a1 1
/* $OpenBSD: client.c,v 1.33 2009/11/13 18:07:52 nicm Exp $ */
d128 1
a128 1
	
d146 1
a146 1
 	for (var = environ; *var != NULL; var++) {
d156 1
a156 1
 	imsg_compose(&client_ibuf, type, PROTOCOL_VERSION, -1, -1, buf, len);
d182 1
a182 1
 	/* Set up signals. */
d266 1
a266 1
		}	
d268 1
a268 1
	
d344 1
a344 1
			
@


1.33
log
@imsg_read returns ssize_t not int, pointed out by lint via deraadt.
@
text
@d1 1
a1 1
/* $OpenBSD: client.c,v 1.32 2009/11/10 15:47:48 nicm Exp $ */
d225 1
d254 1
@


1.32
log
@Don't return 1 unless there was actually a problem (signal/lost server) rather
than for all events (normal exit/detach/etc).
@
text
@d1 1
a1 1
/* $OpenBSD: client.c,v 1.31 2009/11/04 22:57:49 nicm Exp $ */
d256 1
a256 1
	int	n;
@


1.31
log
@Move some common code into a function.
@
text
@d1 1
a1 1
/* $OpenBSD: client.c,v 1.30 2009/11/04 20:50:11 nicm Exp $ */
d40 1
d215 1
a215 1
	client_update_event();	
d220 3
a222 6
	if (client_exitmsg != NULL) {
		if (!login_shell)
			printf("[%s]\n", client_exitmsg);
		exit(1);
	}
	exit(0);
d233 1
d277 1
d324 1
@


1.30
log
@Initial changes to move tmux to libevent.

This moves the client-side loops are pretty much fully over to event-based only
(tmux.c and client.c) but server-side (server.c and friends) treats libevent as
a sort of clever poll, waking up after every event to run various things.

Moving the server stuff over to bufferevents and timers and so on will come
later.
@
text
@d1 1
a1 1
/* $OpenBSD: client.c,v 1.29 2009/11/02 13:42:25 nicm Exp $ */
d44 1
d158 13
a175 1
	short	 		events;
d213 2
a214 7
	/* Set up the client-server socket event. */
	events = EV_READ;
	if (client_ibuf.w.queued > 0)
		events |= EV_WRITE;
	event_set(&client_event, client_ibuf.fd, events, client_callback, NULL);
	event_add(&client_event, NULL);
	
d228 1
a228 1
client_signal(int sig, short events, unused void *data)
d251 1
a251 6
	event_del(&client_event);
	events = EV_READ;
	if (client_ibuf.w.queued > 0)
		events |= EV_WRITE;
	event_set(&client_event, client_ibuf.fd, events, client_callback, NULL);
	event_add(&client_event, NULL);
d273 1
a273 7
	event_del(&client_event);
	events = EV_READ;
	if (client_ibuf.w.queued > 0)
		events |= EV_WRITE;
	event_set(&client_event, client_ibuf.fd, events, client_callback, NULL);
	event_add(&client_event, NULL);

@


1.29
log
@Leftover unused variable :-/.
@
text
@d1 1
a1 1
/* $OpenBSD: client.c,v 1.28 2009/11/02 13:41:25 nicm Exp $ */
d27 1
d38 1
d41 6
a46 5
void	client_send_identify(int);
void	client_send_environ(void);
void	client_write_server(enum msgtype, void *, size_t);
int	client_dispatch(void);
void	client_suspend(void);
d160 3
a162 2
	struct pollfd	 pfd;
	int		 n, nfds;
d164 19
a182 1
	siginit();
d184 6
a189 1
	logfile("client");
d193 3
a195 3
	 * been initialiased) may have read messages into the buffer after the
	 * MSG_READY switched to here. Process anything outstanding now so poll
	 * doesn't hang waiting for messages that have already arrived.
d200 8
a207 54
	for (;;) {
		if (sigterm) {
			client_exitmsg = "terminated";
			client_write_server(MSG_EXITING, NULL, 0);
		}
		if (sigchld) {
			sigchld = 0;
			waitpid(WAIT_ANY, NULL, WNOHANG);
			continue;
		}
		if (sigwinch) {
			sigwinch = 0;
			client_write_server(MSG_RESIZE, NULL, 0);
			continue;
		}
		if (sigcont) {
			sigcont = 0;
			siginit();
			client_write_server(MSG_WAKEUP, NULL, 0);
			continue;
		}

		pfd.fd = client_ibuf.fd;
		pfd.events = POLLIN;
		if (client_ibuf.w.queued > 0)
			pfd.events |= POLLOUT;

		if ((nfds = poll(&pfd, 1, INFTIM)) == -1) {
			if (errno == EAGAIN || errno == EINTR)
				continue;
			fatal("poll failed");
		}
		if (nfds == 0)
			continue;

		if (pfd.revents & (POLLERR|POLLHUP|POLLNVAL))
			fatalx("socket error");

		if (pfd.revents & POLLIN) {
			if ((n = imsg_read(&client_ibuf)) == -1 || n == 0) {
				client_exitmsg = "lost server";
				break;
			}
			if (client_dispatch() != 0)
				break;
		}

		if (pfd.revents & POLLOUT) {
			if (msgbuf_write(&client_ibuf.w) < 0) {
				client_exitmsg = "lost server";
				break;
			}
		}
	}
d219 65
d287 4
a290 3
	struct imsg		 imsg;
	struct msg_lock_data	 lockdata;
	ssize_t			 n, datalen;
d299 1
d332 7
a338 1
			client_suspend();
a354 20
}

void
client_suspend(void)
{
	struct sigaction	 act;

	memset(&act, 0, sizeof act);
	sigemptyset(&act.sa_mask);
	act.sa_flags = SA_RESTART;

	act.sa_handler = SIG_DFL;
	if (sigaction(SIGTSTP, &act, NULL) != 0)
		fatal("sigaction failed");

	act.sa_handler = sighandler;
	if (sigaction(SIGCONT, &act, NULL) != 0)
		fatal("sigaction failed");

	kill(getpid(), SIGTSTP);
@


1.28
log
@There isn't much point in doing lstat before connect so instead just do connect
and handle ENOENT from it which is a little tidier.
@
text
@d1 1
a1 1
/* $OpenBSD: client.c,v 1.27 2009/10/26 21:38:18 nicm Exp $ */
a48 1
	struct stat		sb;
@


1.27
log
@Clear signal flags /before/ taking action and continue afterwards to reduce
chance of dropping signals. Pointed out by deraadt@@.
@
text
@d1 1
a1 1
/* $OpenBSD: client.c,v 1.26 2009/10/21 21:11:55 nicm Exp $ */
a57 13
	if (lstat(path, &sb) != 0) {
		if (cmdflags & CMD_STARTSERVER && errno == ENOENT) {
			if ((fd = server_start(path)) == -1)
				goto start_failed;
			goto server_started;
		}
		goto not_found;
	}
	if (!S_ISSOCK(sb.st_mode)) {
		errno = ENOTSOCK;
		goto not_found;
	}

d70 5
a74 2
		if (errno == ECONNREFUSED) {
			if (unlink(path) != 0 || !(cmdflags & CMD_STARTSERVER))
d76 2
@


1.26
log
@Tidy identify message send into a separate function.
@
text
@d1 1
a1 1
/* $OpenBSD: client.c,v 1.25 2009/10/21 20:11:47 nicm Exp $ */
d188 1
d190 1
a190 1
			sigchld = 0;
d193 1
d195 1
a195 1
 			sigwinch = 0;
d198 1
d201 1
a201 1
			sigcont = 0;
@


1.25
log
@Client tidying: get rid of client_ctx struct in favour of two variables in
client.c, and move the functions in client-fn.c into other files.
@
text
@d1 1
a1 1
/* $OpenBSD: client.c,v 1.24 2009/10/13 13:15:26 nicm Exp $ */
d39 1
d48 5
a52 8
	struct sockaddr_un		sa;
	struct stat			sb;
	struct msg_identify_data	data;
	struct winsize			ws;
	size_t				size;
	int				fd, fd2, mode;
	char			       *term;
	char		 		rpathbuf[MAXPATHLEN];
d104 2
a105 20
	if (isatty(STDIN_FILENO)) {
		if (ioctl(STDIN_FILENO, TIOCGWINSZ, &ws) == -1)
			fatal("ioctl(TIOCGWINSZ)");
		data.flags = flags;

		if (getcwd(data.cwd, sizeof data.cwd) == NULL)
			*data.cwd = '\0';

		*data.term = '\0';
		if ((term = getenv("TERM")) != NULL) {
			if (strlcpy(data.term,
			    term, sizeof data.term) >= sizeof data.term)
				*data.term = '\0';
		}

		if ((fd2 = dup(STDIN_FILENO)) == -1)
			fatal("dup failed");
		imsg_compose(&client_ibuf, MSG_IDENTIFY,
		    PROTOCOL_VERSION, -1, fd2, &data, sizeof data);
	}
d119 26
d147 1
a148 1
	struct msg_environ_data	data;
@


1.24
log
@Do this in a better way - print messages when exiting with nonzero.

Also remove the login shell information from server-info, only the client
should care about it.
@
text
@d1 1
a1 1
/* $OpenBSD: client.c,v 1.23 2009/10/13 13:11:06 nicm Exp $ */
d36 2
a37 1
void	client_send_environ(struct client_ctx *);
d39 7
a45 2
int
client_init(char *path, struct client_ctx *cctx, int cmdflags, int flags)
d102 1
a102 1
	imsg_init(&cctx->ibuf, fd);
d105 1
a105 1
		client_send_environ(cctx);
d123 1
a123 1
		imsg_compose(&cctx->ibuf, MSG_IDENTIFY,
d127 1
a127 1
	return (0);
d131 1
a131 1
	return (1);
d135 1
a135 1
	return (1);
d139 1
a139 1
client_send_environ(struct client_ctx *cctx)
d147 1
a147 1
		client_write_server(cctx, MSG_ENVIRON, &data, sizeof data);
d151 8
a158 2
int
client_main(struct client_ctx *cctx)
d173 1
a173 1
	if (client_msg_dispatch(cctx) != 0)
d177 4
a180 2
		if (sigterm)
			client_write_server(cctx, MSG_EXITING, NULL, 0);
d186 1
a186 1
			client_write_server(cctx, MSG_RESIZE, NULL, 0);
d191 1
a191 1
			client_write_server(cctx, MSG_WAKEUP, NULL, 0);
d195 1
a195 1
		pfd.fd = cctx->ibuf.fd;
d197 1
a197 1
		if (cctx->ibuf.w.queued > 0)
d212 2
a213 2
			if ((n = imsg_read(&cctx->ibuf)) == -1 || n == 0) {
				cctx->exittype = CCTX_DIED;
d216 1
a216 1
			if (client_msg_dispatch(cctx) != 0)
d221 2
a222 2
			if (msgbuf_write(&cctx->ibuf.w) < 0) {
				cctx->exittype = CCTX_DIED;
d229 2
a230 25
	/*
	 * Print exit status message, unless running as a login shell where it
	 * would either be pointless or irritating.
	 */
	if (sigterm) {
		printf("[terminated]\n");
		return (1);
	}
	switch (cctx->exittype) {
	case CCTX_DIED:
		printf("[lost server]\n");
		return (0);
	case CCTX_SHUTDOWN:
 		if (!login_shell)
			printf("[server exited]\n");
		return (0);
	case CCTX_EXIT:
		if (cctx->errstr != NULL) {
			printf("[error: %s]\n", cctx->errstr);
			return (1);
		}
 		if (!login_shell)
			printf("[exited]\n");
		return (0);
	case CCTX_DETACH:
d232 2
a233 5
			printf("[detached]\n");
		return (0);
	default:
		printf("[unknown error]\n");
		return (1);
d235 1
d239 1
a239 1
client_msg_dispatch(struct client_ctx *cctx)
a241 1
	struct msg_print_data	 printdata;
d246 1
a246 1
		if ((n = imsg_get(&cctx->ibuf, &imsg)) == -1)
d257 2
a258 2
			client_write_server(cctx, MSG_EXITING, NULL, 0);
			cctx->exittype = CCTX_DETACH;
a259 10
		case MSG_ERROR:
			if (datalen != sizeof printdata)
				fatalx("bad MSG_ERROR size");
			memcpy(&printdata, imsg.data, sizeof printdata);

			printdata.msg[(sizeof printdata.msg) - 1] = '\0';
			/* Error string used after exit message from server. */
			cctx->errstr = xstrdup(printdata.msg);
			imsg_free(&imsg);
			return (-1);
d264 2
a265 2
			client_write_server(cctx, MSG_EXITING, NULL, 0);
			cctx->exittype = CCTX_EXIT;
d277 2
a278 2
			client_write_server(cctx, MSG_EXITING, NULL, 0);
			cctx->exittype = CCTX_SHUTDOWN;
d293 1
a293 1
			client_write_server(cctx, MSG_UNLOCK, NULL, 0);
d301 20
@


1.23
log
@Don't print exit messages when used as a login shell, requested by martynas@@ a
while back.
@
text
@d1 1
a1 1
/* $OpenBSD: client.c,v 1.22 2009/09/23 12:03:30 nicm Exp $ */
d219 15
a233 3
	if (!login_shell) {
		if (sigterm) {
			printf("[terminated]\n");
d236 1
a236 12
		switch (cctx->exittype) {
		case CCTX_DIED:
			printf("[lost server]\n");
			return (0);
		case CCTX_SHUTDOWN:
			printf("[server exited]\n");
			return (0);
		case CCTX_EXIT:
			if (cctx->errstr != NULL) {
				printf("[error: %s]\n", cctx->errstr);
				return (1);
			}
d238 3
a240 2
			return (0);
		case CCTX_DETACH:
d242 4
a245 5
			return (0);
		default:
			printf("[unknown error]\n");
			return (1);
		}
@


1.22
log
@Support -c like sh(1) to execute a command, useful when tmux is a login
shell. Suggested by halex@@.

This includes another protocol version increase (the last for now) so again
restart the tmux server before upgrading.
@
text
@d1 1
a1 1
/* $OpenBSD: client.c,v 1.21 2009/09/23 06:18:47 nicm Exp $ */
d215 28
a242 14
 	if (sigterm) {
 		printf("[terminated]\n");
 		return (1);
 	}
	switch (cctx->exittype) {
	case CCTX_DIED:
		printf("[lost server]\n");
		return (0);
	case CCTX_SHUTDOWN:
		printf("[server exited]\n");
		return (0);
	case CCTX_EXIT:
		if (cctx->errstr != NULL) {
			printf("[error: %s]\n", cctx->errstr);
a244 8
		printf("[exited]\n");
		return (0);
	case CCTX_DETACH:
		printf("[detached]\n");
		return (0);
	default:
		printf("[unknown error]\n");
		return (1);
@


1.21
log
@Remove the internal tmux locking and instead detach each client and run the
command specified by a new option "lock-command" (by default "lock -np") in
each client.

This means each terminal has to be unlocked individually but simplifies the
code and allows the system password to be used to unlock.

Note that the set-password command is gone, so it will need to be removed from
configuration files, and the -U command line flag has been removed.

This is the third protocol version change so again it is best to stop the tmux
server before upgrading.
@
text
@d1 1
a1 1
/* $OpenBSD: client.c,v 1.20 2009/09/23 06:12:58 nicm Exp $ */
d93 2
@


1.20
log
@Trim some code by moving the ioctl(TIOCGWINSZ) after SIGWINCH from the client
into the server.

This is another (the second of four) protocol version changes coming this
morning, so again the server should be killed before upgrading.
@
text
@d1 1
a1 1
/* $OpenBSD: client.c,v 1.19 2009/09/23 06:05:02 nicm Exp $ */
d245 1
d298 9
@


1.19
log
@Don't attempt to open() the tty path, rely on the client sending its stdin fd
with imsg and fatal if it doesn't, then set the FD_CLOEXEC flag in tty_init
instead of tty_open to prevent them leaking into child processes if any are
created between the two calls.

This bumps the protocol version, so the tmux server should be killed before
upgrading.
@
text
@d1 1
a1 1
/* $OpenBSD: client.c,v 1.18 2009/09/20 14:58:12 nicm Exp $ */
a36 1
void	client_handle_winch(struct client_ctx *);
a101 2
		data.sx = ws.ws_col;
		data.sy = ws.ws_row;
d169 4
a172 2
		if (sigwinch)
			client_handle_winch(cctx);
a237 16
}

void
client_handle_winch(struct client_ctx *cctx)
{
	struct msg_resize_data	data;
	struct winsize		ws;

	if (ioctl(STDIN_FILENO, TIOCGWINSZ, &ws) == -1)
		fatal("ioctl failed");

	data.sx = ws.ws_col;
	data.sy = ws.ws_row;
	client_write_server(cctx, MSG_RESIZE, &data, sizeof data);

	sigwinch = 0;
@


1.18
log
@Regularise some fatal messages.
@
text
@d1 1
a1 1
/* $OpenBSD: client.c,v 1.17 2009/09/02 23:49:25 nicm Exp $ */
d48 1
a48 1
	char			       *name, *term;
d116 2
a117 7
		*data.tty = '\0';
		if ((name = ttyname(STDIN_FILENO)) == NULL)
			fatal("ttyname failed");
		if (strlcpy(data.tty, name, sizeof data.tty) >= sizeof data.tty)
			fatalx("ttyname failed");

		fd2 = dup(STDIN_FILENO);
@


1.17
log
@Fix a race condition when asking a client to take over the terminal (switching
to a different poll loop):

If a MSG_READY was followed very quickly by a MSG_EXIT (for example if doing
"tmux new 'exit'"), both messages could be read as part of the same imsg_read
in the first client poll loop. The MSG_READY would then cause a switch to the
second client loop, which would immediately call poll(2) again, causing the
client to hang forever waiting for an exit message that it already had.

Change to call imsg_get to process any existing messages before polling.
@
text
@d1 1
a1 1
/* $OpenBSD: client.c,v 1.16 2009/09/02 20:15:49 nicm Exp $ */
d77 1
a77 1
		fatal("socket");
@


1.16
log
@That was the wrong fix. MSG_ERROR should set the error and the client should
use the error and exit on MSG_EXIT (it was being handled in the default
case). Undo the last change, move the errstr check into the MSG_EXIT case, and
add a comment.
@
text
@d1 1
a1 1
/* $OpenBSD: client.c,v 1.15 2009/09/02 20:00:10 nicm Exp $ */
d155 1
a155 1
	int		 nfds;
d161 9
d202 4
d217 2
a218 1
	
a267 5

	if ((n = imsg_read(&cctx->ibuf)) == -1 || n == 0) {
		cctx->exittype = CCTX_DIED;
		return (-1);
	}
@


1.15
log
@Set exittype for error exit as well as the error string.
@
text
@d1 1
a1 1
/* $OpenBSD: client.c,v 1.14 2009/08/12 06:04:28 nicm Exp $ */
d217 4
a225 3
	case CCTX_ERROR:
		printf("[error: %s]\n", cctx->errstr);
		return (1);
d227 1
a227 1
		printf("[error: unknown error]\n");
d281 1
a282 1
			cctx->exittype = CCTX_ERROR;
@


1.14
log
@imsg closes the fd after sending, so dup() STDIN_FILENO before passing it to
the parent, otherwise TIOCGWINSZ will fail when the window is resized (that
could actually be moved into the server but this is more future-proof and
avoids breaking the protocol).
@
text
@d1 1
a1 1
/* $OpenBSD: client.c,v 1.13 2009/08/11 21:28:11 nicm Exp $ */
d204 1
a204 1

d222 3
d226 1
a226 1
		printf("[error: %s]\n", cctx->errstr);
d281 1
@


1.13
log
@Have the client pass its stdin fd to the server when identifying itself and
have the server use that rather than reopening the tty. If the fd isn't given,
use the old behaviour (so no need for a version change).

This allows tmux to be used as the shell, so also change so that when working
out the command to execute if default-command is empty (the default), tmux will
try not execute itself.
@
text
@d1 1
a1 1
/* $OpenBSD: client.c,v 1.12 2009/08/11 17:18:35 nicm Exp $ */
d47 1
a47 1
	int				fd, mode;
d122 1
d124 1
a124 1
		    PROTOCOL_VERSION, -1, STDIN_FILENO, &data, sizeof data);
@


1.12
log
@Switch tmux to use imsg. This is the last major change to make the
client-server protocol more resilient and make the protocol versioning work
properly. In future, the only things requiring a protocol version bump will be
changes in the message structs, and (when both client and server have this
change) mixing different versions should nicely report an error message.

As a side effect this also makes the code tidier, fixes a problem with the way
errors reported during server startup were handled, and supports fd passing
(which will be used in future).

Looked over by eric@@, thanks.

Please note that mixing a client with this change with an older server or vice
versa may cause tmux to crash or hang - tmux should be completely exited before
upgrading.
@
text
@d1 1
a1 1
/* $OpenBSD: client.c,v 1.11 2009/08/08 21:52:43 nicm Exp $ */
d122 2
a123 1
		client_write_server(cctx, MSG_IDENTIFY, &data, sizeof data);
@


1.11
log
@Infrastructure and commands to manage the environment for processes started
within tmux.

There is a global environment, copied from the external environment when the
server is started and each sesssion has an (initially empty) session
environment which overrides it.

New commands set-environment and show-environment manipulate or display the
environments.

A new session option, update-environment, is a space-separated list of
variables which are updated from the external environment into the session
environment every time a new session is created - the default is DISPLAY.
@
text
@d1 1
a1 1
/* $OpenBSD: client.c,v 1.10 2009/08/08 21:18:23 nicm Exp $ */
d95 1
a95 3
	cctx->srv_fd = fd;
	cctx->srv_in = buffer_create(BUFSIZ);
	cctx->srv_out = buffer_create(BUFSIZ);
a101 1
		data.version = PROTOCOL_VERSION;
d153 1
d174 1
a174 1
		pfd.fd = cctx->srv_fd;
d176 1
a176 1
		if (BUFFER_USED(cctx->srv_out) > 0)
d179 1
a179 1
		if (poll(&pfd, 1, INFTIM) == -1) {
d184 5
d190 3
a192 3
		if (buffer_poll(&pfd, cctx->srv_in, cctx->srv_out) != 0) {
			cctx->exittype = CCTX_DIED;
			break;
d195 6
a200 2
		if (client_msg_dispatch(cctx) != 0)
			break;
d245 1
a245 1
	struct hdr		 hdr;
d247 6
d255 3
a257 4
		if (BUFFER_USED(cctx->srv_in) < sizeof hdr)
			return (0);
		memcpy(&hdr, BUFFER_OUT(cctx->srv_in), sizeof hdr);
		if (BUFFER_USED(cctx->srv_in) < (sizeof hdr) + hdr.size)
d259 1
a259 1
		buffer_remove(cctx->srv_in, sizeof hdr);
d261 1
a261 1
		switch (hdr.type) {
d263 1
a263 1
			if (hdr.size != 0)
d270 3
a272 3
			if (hdr.size != sizeof printdata)
				fatalx("bad MSG_PRINT size");
			buffer_read(cctx->srv_in, &printdata, sizeof printdata);
d276 1
d279 1
a279 1
			if (hdr.size != 0)
d281 1
a281 1
		
d286 1
a286 1
			if (hdr.size != 0)
d289 1
d292 1
a292 1
			if (hdr.size != 0)
d299 1
a299 1
			if (hdr.size != 0)
d307 2
@


1.10
log
@Tidy function a little by using a temporary variable.
@
text
@d1 1
a1 1
/* $OpenBSD: client.c,v 1.9 2009/07/30 16:32:12 nicm Exp $ */
d36 1
d99 2
d139 13
d261 1
a262 1

@


1.9
log
@There aren't many client message types or code to handle them so get rid of the
lookup table and use a switch, merge the tiny handler functions into it, and
move the whole lot to client.c.

Also change client_msg_dispatch to consume as many messages as possible and
move the call to it to the right place so it checks for signals afterwards.

Prompted by suggestions from eric@@.
@
text
@d1 1
a1 1
/* $OpenBSD: client.c,v 1.8 2009/07/30 16:16:19 nicm Exp $ */
d46 1
a46 1
	int				mode;
d56 1
a56 1
			if ((cctx->srv_fd = server_start(path)) == -1)
d75 1
a75 1
	if ((cctx->srv_fd = socket(AF_UNIX, SOCK_STREAM, 0)) == -1)
d78 1
a78 2
	if (connect(
	    cctx->srv_fd, (struct sockaddr *) &sa, SUN_LEN(&sa)) == -1) {
d82 1
a82 1
			if ((cctx->srv_fd = server_start(path)) == -1)
d90 1
a90 1
	if ((mode = fcntl(cctx->srv_fd, F_GETFL)) == -1)
d92 1
a92 1
	if (fcntl(cctx->srv_fd, F_SETFL, mode|O_NONBLOCK) == -1)
d94 1
@


1.8
log
@Tell the server when the client gets SIGTERM so it can clean up the terminal
properly, rather than just exiting.
@
text
@d1 1
a1 1
/* $OpenBSD: client.c,v 1.7 2009/07/26 12:58:44 nicm Exp $ */
a139 1
	int		 xtimeout; /* Yay for ncurses namespace! */
a159 13
		switch (client_msg_dispatch(cctx)) {
		case -1:
			goto out;
		case 0:
			/* May be more in buffer, don't let poll block. */
			xtimeout = 0;
			break;
		default:
			/* Out of data, poll may block. */
			xtimeout = INFTIM;
			break;
		}

d165 1
a165 1
		if (poll(&pfd, 1, xtimeout) == -1) {
d175 3
a179 1
out:
d217 61
@


1.7
log
@Make all messages sent between the client and server fixed size.

This is the first of two changes to make the protocol more resilient and less
sensitive to other changes in the code, particularly with commands. The client
now packs argv into a buffer and sends it to the server for parsing, rather
than doing it itself and sending the parsed command data.

As a side-effect this also removes a lot of now-unused command marshalling
code.

Mixing a server without this change and a client with or vice versa will cause
tmux to hang or crash, please ensure that tmux is entirely killed before
upgrading.
@
text
@d1 1
a1 1
/* $OpenBSD: client.c,v 1.6 2009/07/23 21:19:11 nicm Exp $ */
d146 3
a148 1
	while (!sigterm) {
@


1.6
log
@None of the server message functions return anything but 0, so make them all
void.

Also remove a leftover variable in client.c.
@
text
@d1 1
a1 1
/* $OpenBSD: client.c,v 1.5 2009/07/23 20:24:27 nicm Exp $ */
d47 1
a47 2
	struct buffer		       *b;
	char			       *name;
d105 1
a105 1
		*data.tty = '\0';
d109 8
d122 1
a122 5
		b = buffer_create(BUFSIZ);
		cmd_send_string(b, getenv("TERM"));
		client_write_server2(cctx, MSG_IDENTIFY,
		    &data, sizeof data, BUFFER_OUT(b), BUFFER_USED(b));
		buffer_destroy(b);
@


1.5
log
@Tidy client message return slightly: convert flags into an enum, and merge
error string into struct client_ctx as well.
@
text
@d1 1
a1 1
/* $OpenBSD: client.c,v 1.4 2009/07/22 21:58:56 nicm Exp $ */
a136 1
	char		*error;
a142 1
	error = NULL;
@


1.4
log
@Pass a set of flags into client_init rather than just a start_server
variable. Only one flag now but more to come later.
@
text
@d1 1
a1 1
/* $OpenBSD: client.c,v 1.3 2009/06/25 22:09:20 nicm Exp $ */
d158 1
a158 1
		switch (client_msg_dispatch(cctx, &error)) {
d182 4
a185 2
		if (buffer_poll(&pfd, cctx->srv_in, cctx->srv_out) != 0)
			goto server_dead;
d193 5
a197 2

	if (cctx->flags & CCTX_SHUTDOWN) {
d200 1
a200 3
	}

	if (cctx->flags & CCTX_EXIT) {
d203 1
a203 3
	}

	if (cctx->flags & CCTX_DETACH) {
d206 3
a209 7

	printf("[error: %s]\n", error);
	return (1);

server_dead:
	printf("[lost server]\n");
	return (0);
@


1.3
log
@Remove some dead assignments, found by sthen with clang.
@
text
@d1 1
a1 1
/* $OpenBSD: client.c,v 1.2 2009/06/05 07:15:58 nicm Exp $ */
d39 1
a39 1
client_init(char *path, struct client_ctx *cctx, int start_server, int flags)
d56 1
a56 1
		if (start_server && errno == ENOENT) {
d82 1
a82 1
			if (unlink(path) != 0 || !start_server)
@


1.2
log
@Call setproctitle earlier in the client, and include the socket name. Makes it
easier to match client to server in ps/pgrep when using several servers.
@
text
@d1 1
a1 1
/* $OpenBSD: client.c,v 1.1 2009/06/01 22:58:49 nicm Exp $ */
a144 1
	xtimeout = INFTIM;
@


1.1
log
@Import tmux, a terminal multiplexor allowing (among other things) a single
terminal to be switched between several different windows and programs
displayed on one terminal be detached from one terminal and moved to another.

ok deraadt pirofti
@
text
@d1 1
a1 1
/* $OpenBSD$ */
d49 5
a142 1
	setproctitle("client");
@

