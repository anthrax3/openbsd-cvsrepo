head	1.18;
access;
symbols
	OPENBSD_6_1:1.18.0.2
	OPENBSD_6_1_BASE:1.18
	OPENBSD_6_0:1.15.0.2
	OPENBSD_6_0_BASE:1.15
	OPENBSD_5_9:1.12.0.2
	OPENBSD_5_9_BASE:1.12
	OPENBSD_5_8:1.8.0.4
	OPENBSD_5_8_BASE:1.8
	OPENBSD_5_7:1.7.0.2
	OPENBSD_5_7_BASE:1.7
	OPENBSD_5_6:1.6.0.4
	OPENBSD_5_6_BASE:1.6
	OPENBSD_5_5:1.5.0.10
	OPENBSD_5_5_BASE:1.5
	OPENBSD_5_4:1.5.0.6
	OPENBSD_5_4_BASE:1.5
	OPENBSD_5_3:1.5.0.4
	OPENBSD_5_3_BASE:1.5
	OPENBSD_5_2:1.5.0.2
	OPENBSD_5_2_BASE:1.5
	OPENBSD_5_1_BASE:1.4
	OPENBSD_5_1:1.4.0.8
	OPENBSD_5_0:1.4.0.6
	OPENBSD_5_0_BASE:1.4
	OPENBSD_4_9:1.4.0.4
	OPENBSD_4_9_BASE:1.4
	OPENBSD_4_8:1.4.0.2
	OPENBSD_4_8_BASE:1.4
	OPENBSD_4_7:1.3.0.2
	OPENBSD_4_7_BASE:1.3;
locks; strict;
comment	@ * @;


1.18
date	2017.03.09.17.02.38;	author nicm;	state Exp;
branches;
next	1.17;
commitid	QtFskEpSXY809LlK;

1.17
date	2017.01.24.20.15.32;	author nicm;	state Exp;
branches;
next	1.16;
commitid	OhhGixV64mirqDj8;

1.16
date	2016.10.10.21.29.23;	author nicm;	state Exp;
branches;
next	1.15;
commitid	z4Hr4PZF7Ev93uEJ;

1.15
date	2016.07.15.09.52.34;	author nicm;	state Exp;
branches;
next	1.14;
commitid	GqpJHQB3A3bbJxMc;

1.14
date	2016.07.15.09.28.32;	author nicm;	state Exp;
branches;
next	1.13;
commitid	Bi60xSMBeQjDRMSa;

1.13
date	2016.05.26.12.15.42;	author nicm;	state Exp;
branches;
next	1.12;
commitid	0sRStIEmZWCMpaLj;

1.12
date	2016.01.19.15.59.12;	author nicm;	state Exp;
branches;
next	1.11;
commitid	P3qmSOx6KrDBsb0c;

1.11
date	2016.01.15.11.33.41;	author nicm;	state Exp;
branches;
next	1.10;
commitid	le8VafK5cMYEKk0a;

1.10
date	2015.11.24.23.46.15;	author nicm;	state Exp;
branches;
next	1.9;
commitid	0H2a77mNskMnXKL5;

1.9
date	2015.10.28.09.51.55;	author nicm;	state Exp;
branches;
next	1.8;
commitid	eGVGKzVVYKHFvkn4;

1.8
date	2015.05.07.07.35.31;	author nicm;	state Exp;
branches;
next	1.7;
commitid	WhAs4CJ8P1xvQIPB;

1.7
date	2015.01.25.16.53.46;	author nicm;	state Exp;
branches;
next	1.6;
commitid	mCwiKD9U4vCJyg8i;

1.6
date	2014.04.17.14.45.49;	author nicm;	state Exp;
branches;
next	1.5;

1.5
date	2012.07.10.11.53.01;	author nicm;	state Exp;
branches;
next	1.4;

1.4
date	2010.04.04.19.02.09;	author nicm;	state Exp;
branches;
next	1.3;

1.3
date	2009.08.09.15.17.50;	author nicm;	state Exp;
branches;
next	1.2;

1.2
date	2009.08.08.21.54.26;	author nicm;	state Exp;
branches;
next	1.1;

1.1
date	2009.08.08.21.52.43;	author nicm;	state Exp;
branches;
next	;


desc
@@


1.18
log
@Move server_fill_environ into environ.c and move some other common code
into it.
@
text
@/* $OpenBSD: environ.c,v 1.17 2017/01/24 20:15:32 nicm Exp $ */

/*
 * Copyright (c) 2009 Nicholas Marriott <nicholas.marriott@@gmail.com>
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF MIND, USE, DATA OR PROFITS, WHETHER
 * IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING
 * OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */

#include <sys/types.h>

#include <stdlib.h>
#include <string.h>
#include <unistd.h>

#include "tmux.h"

/*
 * Environment - manipulate a set of environment variables.
 */

RB_HEAD(environ, environ_entry);
static int environ_cmp(struct environ_entry *, struct environ_entry *);
RB_GENERATE_STATIC(environ, environ_entry, entry, environ_cmp);

static int
environ_cmp(struct environ_entry *envent1, struct environ_entry *envent2)
{
	return (strcmp(envent1->name, envent2->name));
}

/* Initialise the environment. */
struct environ *
environ_create(void)
{
	struct environ	*env;

	env = xcalloc(1, sizeof *env);
	RB_INIT(env);

	return (env);
}

/* Free an environment. */
void
environ_free(struct environ *env)
{
	struct environ_entry	*envent, *envent1;

	RB_FOREACH_SAFE(envent, environ, env, envent1) {
		RB_REMOVE(environ, env, envent);
		free(envent->name);
		free(envent->value);
		free(envent);
	}
	free(env);
}

struct environ_entry *
environ_first(struct environ *env)
{
	return (RB_MIN(environ, env));
}

struct environ_entry *
environ_next(struct environ_entry *envent)
{
	return (RB_NEXT(environ, env, envent));
}

/* Copy one environment into another. */
void
environ_copy(struct environ *srcenv, struct environ *dstenv)
{
	struct environ_entry	*envent;

	RB_FOREACH(envent, environ, srcenv) {
		if (envent->value == NULL)
			environ_clear(dstenv, envent->name);
		else
			environ_set(dstenv, envent->name, "%s", envent->value);
	}
}

/* Find an environment variable. */
struct environ_entry *
environ_find(struct environ *env, const char *name)
{
	struct environ_entry	envent;

	envent.name = (char *) name;
	return (RB_FIND(environ, env, &envent));
}

/* Set an environment variable. */
void
environ_set(struct environ *env, const char *name, const char *fmt, ...)
{
	struct environ_entry	*envent;
	va_list			 ap;

	va_start(ap, fmt);
	if ((envent = environ_find(env, name)) != NULL) {
		free(envent->value);
		xvasprintf(&envent->value, fmt, ap);
	} else {
		envent = xmalloc(sizeof *envent);
		envent->name = xstrdup(name);
		xvasprintf(&envent->value, fmt, ap);
		RB_INSERT(environ, env, envent);
	}
	va_end(ap);
}

/* Clear an environment variable. */
void
environ_clear(struct environ *env, const char *name)
{
	struct environ_entry	*envent;

	if ((envent = environ_find(env, name)) != NULL) {
		free(envent->value);
		envent->value = NULL;
	} else {
		envent = xmalloc(sizeof *envent);
		envent->name = xstrdup(name);
		envent->value = NULL;
		RB_INSERT(environ, env, envent);
	}
}

/* Set an environment variable from a NAME=VALUE string. */
void
environ_put(struct environ *env, const char *var)
{
	char	*name, *value;

	value = strchr(var, '=');
	if (value == NULL)
		return;
	value++;

	name = xstrdup(var);
	name[strcspn(name, "=")] = '\0';

	environ_set(env, name, "%s", value);
	free(name);
}

/* Unset an environment variable. */
void
environ_unset(struct environ *env, const char *name)
{
	struct environ_entry	*envent;

	if ((envent = environ_find(env, name)) == NULL)
		return;
	RB_REMOVE(environ, env, envent);
	free(envent->name);
	free(envent->value);
	free(envent);
}

/* Copy variables from a destination into a source * environment. */
void
environ_update(struct options *oo, struct environ *src, struct environ *dst)
{
	struct environ_entry	*envent;
	struct options_entry	*o;
	u_int			 size, idx;
	const char		*value;

	o = options_get(oo, "update-environment");
	if (o == NULL || options_array_size(o, &size) == -1)
		return;
	for (idx = 0; idx < size; idx++) {
		value = options_array_get(o, idx);
		if (value == NULL)
			continue;
		if ((envent = environ_find(src, value)) == NULL)
			environ_clear(dst, value);
		else
			environ_set(dst, envent->name, "%s", envent->value);
	}
}

/* Push environment into the real environment - use after fork(). */
void
environ_push(struct environ *env)
{
	struct environ_entry	*envent;

	environ = xcalloc(1, sizeof *environ);
	RB_FOREACH(envent, environ, env) {
		if (envent->value != NULL && *envent->name != '\0')
			setenv(envent->name, envent->value, 1);
	}
}

/* Log the environment. */
void
environ_log(struct environ *env, const char *prefix)
{
	struct environ_entry	*envent;

	RB_FOREACH(envent, environ, env) {
		if (envent->value != NULL && *envent->name != '\0') {
			log_debug("%s%s=%s", prefix, envent->name,
			    envent->value);
		}
	}
}

/* Create initial environment for new child. */
struct environ *
environ_for_session(struct session *s)
{
	struct environ	*env;
	const char	*value;
	int		 idx;

	env = environ_create();
	environ_copy(global_environ, env);
	if (s != NULL)
		environ_copy(s->environ, env);

	value = options_get_string(global_options, "default-terminal");
	environ_set(env, "TERM", "%s", value);

	if (s != NULL)
		idx = s->id;
	else
		idx = -1;
	environ_set(env, "TMUX", "%s,%ld,%d", socket_path, (long)getpid(), idx);

	return (env);
}
@


1.17
log
@Make update-environment an array as well.
@
text
@d1 1
a1 1
/* $OpenBSD: environ.c,v 1.16 2016/10/10 21:29:23 nicm Exp $ */
d23 1
d221 25
@


1.16
log
@Loads more static, except for cmd-*.c and window-*.c.
@
text
@d1 1
a1 1
/* $OpenBSD: environ.c,v 1.15 2016/07/15 09:52:34 nicm Exp $ */
d172 1
a172 4
/*
 * Copy a space-separated list of variables from a destination into a source
 * environment.
 */
d174 1
a174 2
environ_update(const char *vars, struct environ *srcenv,
    struct environ *dstenv)
d177 3
a179 1
	char			*copyvars, *var, *next;
d181 9
a189 4
	copyvars = next = xstrdup(vars);
	while ((var = strsep(&next, " ")) != NULL) {
		if ((envent = environ_find(srcenv, var)) == NULL)
			environ_clear(dstenv, var);
d191 1
a191 1
			environ_set(dstenv, envent->name, "%s", envent->value);
a192 1
	free(copyvars);
@


1.15
log
@Tweak output of environment logging.
@
text
@d1 1
a1 1
/* $OpenBSD: environ.c,v 1.14 2016/07/15 09:28:32 nicm Exp $ */
d31 2
a32 3
int	environ_cmp(struct environ_entry *, struct environ_entry *);
RB_PROTOTYPE(environ, environ_entry, entry, environ_cmp);
RB_GENERATE(environ, environ_entry, entry, environ_cmp);
d34 1
a34 1
int
@


1.14
log
@Log environment to new panes.
@
text
@d1 1
a1 1
/* $OpenBSD: environ.c,v 1.13 2016/05/26 12:15:42 nicm Exp $ */
d209 1
a209 1
environ_log(struct environ *env)
d213 6
a218 2
	RB_FOREACH(envent, environ, env)
	    log_debug("%s=%s", envent->name, envent->value);
@


1.13
log
@Just nuke environ instead of trying to unsetenv everything because that
doesn't necessarily work if there is an entry with an empty name.
@
text
@d1 1
a1 1
/* $OpenBSD: environ.c,v 1.12 2016/01/19 15:59:12 nicm Exp $ */
d205 10
@


1.12
log
@I no longer use my SourceForge address so replace it.
@
text
@d1 1
a1 1
/* $OpenBSD: environ.c,v 1.11 2016/01/15 11:33:41 nicm Exp $ */
d198 1
a198 10
	struct environ_entry	 *envent;
	char			*v;

	while (*environ != NULL) {
		v = xstrdup(*environ);
		v[strcspn(v, "=")] = '\0';

		unsetenv(v);
		free(v);
	}
d200 1
d202 1
a202 1
		if (envent->value != NULL)
@


1.11
log
@Clear the environment properly by looping until it is empty rather than
looping over it (which may skip entries), from Brad King.
@
text
@d1 1
a1 1
/* $OpenBSD: environ.c,v 1.10 2015/11/24 23:46:15 nicm Exp $ */
d4 1
a4 1
 * Copyright (c) 2009 Nicholas Marriott <nicm@@users.sourceforge.net>
@


1.10
log
@Make environ_set va_args and use it to tidy up some calls. Also add a
missing word in manpage (from jmc).
@
text
@d1 1
a1 1
/* $OpenBSD: environ.c,v 1.9 2015/10/28 09:51:55 nicm Exp $ */
d199 1
a199 1
	char			**vp, *v;
d201 2
a202 2
	for (vp = environ; *vp != NULL; vp++) {
		v = xstrdup(*vp);
@


1.9
log
@Like options, move the environ struct into environ.c.
@
text
@d1 1
a1 1
/* $OpenBSD: environ.c,v 1.8 2015/05/07 07:35:31 nicm Exp $ */
d86 6
a91 2
	RB_FOREACH(envent, environ, srcenv)
		environ_set(dstenv, envent->name, envent->value);
d106 1
a106 1
environ_set(struct environ *env, const char *name, const char *value)
d109 1
d111 1
d114 19
a132 4
		if (value != NULL)
			envent->value = xstrdup(value);
		else
			envent->value = NULL;
d136 1
a136 4
		if (value != NULL)
			envent->value = xstrdup(value);
		else
			envent->value = NULL;
d155 1
a155 1
	environ_set(env, name, value);
d187 1
a187 1
			environ_set(dstenv, var, NULL);
d189 1
a189 1
			environ_set(dstenv, envent->name, envent->value);
@


1.8
log
@Simplify environ_push so it doesn't need the ARRAY_* functions.
@
text
@d1 1
a1 1
/* $OpenBSD: environ.c,v 1.7 2015/01/25 16:53:46 nicm Exp $ */
d30 3
d42 2
a43 2
void
environ_init(struct environ *env)
d45 3
d49 2
d57 1
a57 1
	struct environ_entry	*envent;
d59 1
a59 2
	while (!RB_EMPTY(env)) {
		envent = RB_ROOT(env);
d65 13
@


1.7
log
@Don't leak the individual strings when copying environment.
@
text
@d1 1
a1 1
/* $OpenBSD: environ.c,v 1.6 2014/04/17 14:45:49 nicm Exp $ */
d160 9
a168 15
	ARRAY_DECL(, char *)	varlist;
	struct environ_entry   *envent;
	char		      **varp, *var;
	u_int			i;

	ARRAY_INIT(&varlist);
	for (varp = environ; *varp != NULL; varp++) {
		var = xstrdup(*varp);
		var[strcspn(var, "=")] = '\0';
		ARRAY_ADD(&varlist, var);
	}
	for (i = 0; i < ARRAY_LENGTH(&varlist); i++) {
		var = ARRAY_ITEM(&varlist, i);
		unsetenv(var);
		free(var);
a169 1
	ARRAY_FREE(&varlist);
@


1.6
log
@Some more long lines.
@
text
@d1 1
a1 1
/* $OpenBSD: environ.c,v 1.5 2012/07/10 11:53:01 nicm Exp $ */
d171 5
a175 2
	for (i = 0; i < ARRAY_LENGTH(&varlist); i++)
		unsetenv(ARRAY_ITEM(&varlist, i));
@


1.5
log
@xfree is not particularly helpful, remove it. From Thomas Adam.
@
text
@d1 1
a1 1
/* $OpenBSD: environ.c,v 1.4 2010/04/04 19:02:09 nicm Exp $ */
d140 2
a141 1
environ_update(const char *vars, struct environ *srcenv, struct environ *dstenv)
@


1.4
log
@Run job commands explicitly in the global enviroment (which can be
modified with setenv -g) rather than with the environment tmux started
with.
@
text
@d1 1
a1 1
/* $OpenBSD: environ.c,v 1.3 2009/08/09 15:17:50 nicm Exp $ */
d54 3
a56 4
		xfree(envent->name);
		if (envent->value != NULL)
			xfree(envent->value);
		xfree(envent);
d87 1
a87 2
		if (envent->value != NULL)
			xfree(envent->value);
d118 1
a118 1
	xfree(name);
d130 3
a132 4
	xfree(envent->name);
	if (envent->value != NULL)
		xfree(envent->value);
	xfree(envent);
d152 1
a152 1
	xfree(copyvars);
@


1.3
log
@Nuke a dead variable found with clang and an unused declaration with lint.
@
text
@d1 1
a1 1
/* $OpenBSD: environ.c,v 1.2 2009/08/08 21:54:26 nicm Exp $ */
d38 1
d45 1
d61 1
d71 1
d81 1
d105 1
d109 1
a109 1
	char		*name, *value;
d123 1
d138 4
d156 25
@


1.2
log
@Use a temporary variable for strdup of const char *.
@
text
@d1 1
a1 1
/* $OpenBSD: environ.c,v 1.1 2009/08/08 21:52:43 nicm Exp $ */
a30 2

void	environ_set1(struct environ *, char *, char *);
@


1.1
log
@Infrastructure and commands to manage the environment for processes started
within tmux.

There is a global environment, copied from the external environment when the
server is started and each sesssion has an (initially empty) session
environment which overrides it.

New commands set-environment and show-environment manipulate or display the
environments.

A new session option, update-environment, is a space-separated list of
variables which are updated from the external environment into the session
environment every time a new session is created - the default is DISPLAY.
@
text
@d1 1
a1 1
/* $OpenBSD: session.c,v 1.1 2009/06/01 22:58:49 nicm Exp $ */
d137 1
a137 1
	char			*var, *next;
d139 1
a139 1
	vars = next = xstrdup(vars);
d146 1
a146 1
	xfree(vars);
@

