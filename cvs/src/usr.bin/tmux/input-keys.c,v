head	1.62;
access;
symbols
	OPENBSD_6_2_BASE:1.62
	OPENBSD_6_1:1.59.0.4
	OPENBSD_6_1_BASE:1.59
	OPENBSD_6_0:1.55.0.2
	OPENBSD_6_0_BASE:1.55
	OPENBSD_5_9:1.53.0.2
	OPENBSD_5_9_BASE:1.53
	OPENBSD_5_8:1.43.0.4
	OPENBSD_5_8_BASE:1.43
	OPENBSD_5_7:1.40.0.2
	OPENBSD_5_7_BASE:1.40
	OPENBSD_5_6:1.39.0.4
	OPENBSD_5_6_BASE:1.39
	OPENBSD_5_5:1.33.0.6
	OPENBSD_5_5_BASE:1.33
	OPENBSD_5_4:1.33.0.2
	OPENBSD_5_4_BASE:1.33
	OPENBSD_5_3:1.30.0.2
	OPENBSD_5_3_BASE:1.30
	OPENBSD_5_2:1.26.0.2
	OPENBSD_5_2_BASE:1.26
	OPENBSD_5_1_BASE:1.23
	OPENBSD_5_1:1.23.0.4
	OPENBSD_5_0:1.23.0.2
	OPENBSD_5_0_BASE:1.23
	OPENBSD_4_9:1.21.0.2
	OPENBSD_4_9_BASE:1.21
	OPENBSD_4_8:1.18.0.4
	OPENBSD_4_8_BASE:1.18
	OPENBSD_4_7:1.18.0.2
	OPENBSD_4_7_BASE:1.18
	OPENBSD_4_6:1.1.0.4
	OPENBSD_4_6_BASE:1.1;
locks; strict;
comment	@ * @;


1.62
date	2017.06.28.11.36.39;	author nicm;	state Exp;
branches;
next	1.61;
commitid	z6XCHRBq9DeWsQAl;

1.61
date	2017.06.12.07.04.24;	author nicm;	state Exp;
branches;
next	1.60;
commitid	fu4NxKu1IK7xAqw9;

1.60
date	2017.05.07.21.25.59;	author nicm;	state Exp;
branches;
next	1.59;
commitid	JPrRNhEycziODctd;

1.59
date	2017.02.01.09.55.07;	author nicm;	state Exp;
branches;
next	1.58;
commitid	FpFenXzt7GohJ3lb;

1.58
date	2017.01.25.14.36.08;	author nicm;	state Exp;
branches;
next	1.57;
commitid	Qp0SbpiBu6Bm6g4g;

1.57
date	2017.01.25.14.24.54;	author nicm;	state Exp;
branches;
next	1.56;
commitid	lN9aftWGvZoDBI6a;

1.56
date	2016.10.03.22.52.11;	author nicm;	state Exp;
branches;
next	1.55;
commitid	brRovAmeQVyBbZ4S;

1.55
date	2016.03.02.15.33.36;	author nicm;	state Exp;
branches;
next	1.54;
commitid	GaDJShO0yTu7CfgE;

1.54
date	2016.03.01.12.02.08;	author nicm;	state Exp;
branches;
next	1.53;
commitid	waz0Ov6Cd4sWsxcD;

1.53
date	2016.01.19.15.59.12;	author nicm;	state Exp;
branches;
next	1.52;
commitid	P3qmSOx6KrDBsb0c;

1.52
date	2015.12.12.18.19.00;	author nicm;	state Exp;
branches;
next	1.51;
commitid	WD2k8ZkBSmp0TV5S;

1.51
date	2015.11.23.23.47.57;	author nicm;	state Exp;
branches;
next	1.50;
commitid	il6j3tv774whObqw;

1.50
date	2015.11.23.20.53.09;	author nicm;	state Exp;
branches;
next	1.49;
commitid	erDJx2JIDZWB55Vj;

1.49
date	2015.11.16.22.57.51;	author nicm;	state Exp;
branches;
next	1.48;
commitid	NcQ0NBZHn2GPHYj0;

1.48
date	2015.11.14.11.45.43;	author nicm;	state Exp;
branches;
next	1.47;
commitid	gUJFVlXRAaRAnDSU;

1.47
date	2015.11.12.22.04.37;	author nicm;	state Exp;
branches;
next	1.46;
commitid	fGCLUB4poNC6IhUT;

1.46
date	2015.11.12.11.05.34;	author nicm;	state Exp;
branches;
next	1.45;
commitid	Ih1tdqtjpnEyfE8x;

1.45
date	2015.10.27.15.58.42;	author nicm;	state Exp;
branches;
next	1.44;
commitid	89xhQafU35Q5MQVC;

1.44
date	2015.10.26.17.17.06;	author nicm;	state Exp;
branches;
next	1.43;
commitid	Lk56WR8dOlvW1M6L;

1.43
date	2015.04.21.15.21.41;	author nicm;	state Exp;
branches;
next	1.42;
commitid	cdlRUhzXG2wYIDxB;

1.42
date	2015.04.19.21.34.21;	author nicm;	state Exp;
branches;
next	1.41;
commitid	wug6ctIOfhVMeWQp;

1.41
date	2015.03.31.17.45.10;	author nicm;	state Exp;
branches;
next	1.40;
commitid	2uQloBaX92ri1PyE;

1.40
date	2014.11.05.23.25.02;	author nicm;	state Exp;
branches;
next	1.39;
commitid	HCpksV7mGIomCoEW;

1.39
date	2014.07.21.20.45.35;	author nicm;	state Exp;
branches;
next	1.38;
commitid	Vdg3SAXanzdCZwXl;

1.38
date	2014.07.21.10.25.48;	author nicm;	state Exp;
branches;
next	1.37;
commitid	uQXf8Vu4TQgRm6UX;

1.37
date	2014.05.08.07.59.16;	author nicm;	state Exp;
branches;
next	1.36;

1.36
date	2014.04.24.09.14.43;	author nicm;	state Exp;
branches;
next	1.35;

1.35
date	2014.04.03.08.15.17;	author nicm;	state Exp;
branches;
next	1.34;

1.34
date	2014.03.31.21.42.45;	author nicm;	state Exp;
branches;
next	1.33;

1.33
date	2013.05.07.11.00.16;	author nicm;	state Exp;
branches;
next	1.32;

1.32
date	2013.03.24.09.57.59;	author nicm;	state Exp;
branches;
next	1.31;

1.31
date	2013.03.22.10.33.50;	author nicm;	state Exp;
branches;
next	1.30;

1.30
date	2012.11.27.20.22.12;	author nicm;	state Exp;
branches;
next	1.29;

1.29
date	2012.11.27.14.26.48;	author nicm;	state Exp;
branches;
next	1.28;

1.28
date	2012.11.27.14.22.43;	author nicm;	state Exp;
branches;
next	1.27;

1.27
date	2012.10.26.14.35.42;	author nicm;	state Exp;
branches;
next	1.26;

1.26
date	2012.07.10.11.53.01;	author nicm;	state Exp;
branches;
next	1.25;

1.25
date	2012.05.05.18.48.31;	author nicm;	state Exp;
branches;
next	1.24;

1.24
date	2012.04.01.20.56.47;	author nicm;	state Exp;
branches;
next	1.23;

1.23
date	2011.07.30.18.01.26;	author nicm;	state Exp;
branches;
next	1.22;

1.22
date	2011.04.19.21.31.33;	author nicm;	state Exp;
branches;
next	1.21;

1.21
date	2011.01.03.23.35.21;	author nicm;	state Exp;
branches;
next	1.20;

1.20
date	2011.01.01.03.43.20;	author nicm;	state Exp;
branches;
next	1.19;

1.19
date	2010.12.29.21.49.06;	author nicm;	state Exp;
branches;
next	1.18;

1.18
date	2009.12.03.22.50.10;	author nicm;	state Exp;
branches;
next	1.17;

1.17
date	2009.11.25.12.24.31;	author nicm;	state Exp;
branches;
next	1.16;

1.16
date	2009.11.10.18.48.03;	author nicm;	state Exp;
branches;
next	1.15;

1.15
date	2009.11.04.23.00.22;	author nicm;	state Exp;
branches;
next	1.14;

1.14
date	2009.11.04.22.43.11;	author nicm;	state Exp;
branches;
next	1.13;

1.13
date	2009.10.26.17.59.46;	author nicm;	state Exp;
branches;
next	1.12;

1.12
date	2009.10.26.17.46.33;	author nicm;	state Exp;
branches;
next	1.11;

1.11
date	2009.10.26.14.30.57;	author nicm;	state Exp;
branches;
next	1.10;

1.10
date	2009.10.26.14.27.13;	author nicm;	state Exp;
branches;
next	1.9;

1.9
date	2009.10.26.13.34.26;	author nicm;	state Exp;
branches;
next	1.8;

1.8
date	2009.10.26.13.29.24;	author nicm;	state Exp;
branches;
next	1.7;

1.7
date	2009.10.26.13.22.30;	author nicm;	state Exp;
branches;
next	1.6;

1.6
date	2009.10.26.13.13.33;	author nicm;	state Exp;
branches;
next	1.5;

1.5
date	2009.10.26.13.02.53;	author nicm;	state Exp;
branches;
next	1.4;

1.4
date	2009.10.11.07.01.10;	author nicm;	state Exp;
branches;
next	1.3;

1.3
date	2009.07.26.21.42.08;	author nicm;	state Exp;
branches;
next	1.2;

1.2
date	2009.07.21.17.57.29;	author nicm;	state Exp;
branches;
next	1.1;

1.1
date	2009.06.01.22.58.49;	author nicm;	state Exp;
branches;
next	;


desc
@@


1.62
log
@Apply the xterm key flag when needed for send-keys, fixes problem
reported by Franky Spamschleuder.
@
text
@/* $OpenBSD: input-keys.c,v 1.61 2017/06/12 07:04:24 nicm Exp $ */

/*
 * Copyright (c) 2007 Nicholas Marriott <nicholas.marriott@@gmail.com>
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF MIND, USE, DATA OR PROFITS, WHETHER
 * IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING
 * OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */

#include <sys/types.h>

#include <stdint.h>
#include <stdlib.h>
#include <string.h>

#include "tmux.h"

/*
 * This file is rather misleadingly named, it contains the code which takes a
 * key code and translates it into something suitable to be sent to the
 * application running in a pane (similar to input.c does in the other
 * direction with output).
 */

static void	 input_key_mouse(struct window_pane *, struct mouse_event *);

struct input_key_ent {
	key_code	 key;
	const char	*data;

	int		 flags;
#define INPUTKEY_KEYPAD 0x1	/* keypad key */
#define INPUTKEY_CURSOR 0x2	/* cursor key */
};

static const struct input_key_ent input_keys[] = {
	/* Backspace key. */
	{ KEYC_BSPACE,		"\177",		0 },

	/* Paste keys. */
	{ KEYC_PASTE_START,	"\033[200~",	0 },
	{ KEYC_PASTE_END,	"\033[201~",	0 },

	/* Function keys. */
	{ KEYC_F1,		"\033OP",	0 },
	{ KEYC_F2,		"\033OQ",	0 },
	{ KEYC_F3,		"\033OR",	0 },
	{ KEYC_F4,		"\033OS",	0 },
	{ KEYC_F5,		"\033[15~",	0 },
	{ KEYC_F6,		"\033[17~",	0 },
	{ KEYC_F7,		"\033[18~",	0 },
	{ KEYC_F8,		"\033[19~",	0 },
	{ KEYC_F9,		"\033[20~",	0 },
	{ KEYC_F10,		"\033[21~",	0 },
	{ KEYC_F11,		"\033[23~",	0 },
	{ KEYC_F12,		"\033[24~",	0 },
	{ KEYC_F1|KEYC_SHIFT,	"\033[25~",	0 },
	{ KEYC_F2|KEYC_SHIFT,	"\033[26~",	0 },
	{ KEYC_F3|KEYC_SHIFT,	"\033[28~",	0 },
	{ KEYC_F4|KEYC_SHIFT,	"\033[29~",	0 },
	{ KEYC_F5|KEYC_SHIFT,	"\033[31~",	0 },
	{ KEYC_F6|KEYC_SHIFT,	"\033[32~",	0 },
	{ KEYC_F7|KEYC_SHIFT,	"\033[33~",	0 },
	{ KEYC_F8|KEYC_SHIFT,	"\033[34~",	0 },
	{ KEYC_IC,		"\033[2~",	0 },
	{ KEYC_DC,		"\033[3~",	0 },
	{ KEYC_HOME,		"\033[1~",	0 },
	{ KEYC_END,		"\033[4~",	0 },
	{ KEYC_NPAGE,		"\033[6~",	0 },
	{ KEYC_PPAGE,		"\033[5~",	0 },
	{ KEYC_BTAB,		"\033[Z",	0 },

	/*
	 * Arrow keys. Cursor versions must come first. The codes are toggled
	 * between CSI and SS3 versions when ctrl is pressed.
	 */
	{ KEYC_UP|KEYC_CTRL,	"\033[A",	INPUTKEY_CURSOR },
	{ KEYC_DOWN|KEYC_CTRL,	"\033[B",	INPUTKEY_CURSOR },
	{ KEYC_RIGHT|KEYC_CTRL,	"\033[C",	INPUTKEY_CURSOR },
	{ KEYC_LEFT|KEYC_CTRL,	"\033[D",	INPUTKEY_CURSOR },

	{ KEYC_UP,		"\033OA",	INPUTKEY_CURSOR },
	{ KEYC_DOWN,		"\033OB",	INPUTKEY_CURSOR },
	{ KEYC_RIGHT,		"\033OC",	INPUTKEY_CURSOR },
	{ KEYC_LEFT,		"\033OD",	INPUTKEY_CURSOR },

	{ KEYC_UP|KEYC_CTRL,	"\033OA",	0 },
	{ KEYC_DOWN|KEYC_CTRL,	"\033OB",	0 },
	{ KEYC_RIGHT|KEYC_CTRL,	"\033OC",	0 },
	{ KEYC_LEFT|KEYC_CTRL,	"\033OD",	0 },

	{ KEYC_UP,		"\033[A",	0 },
	{ KEYC_DOWN,		"\033[B",	0 },
	{ KEYC_RIGHT,		"\033[C",	0 },
	{ KEYC_LEFT,		"\033[D",	0 },

	/* Keypad keys. Keypad versions must come first. */
	{ KEYC_KP_SLASH,	"\033Oo",	INPUTKEY_KEYPAD },
	{ KEYC_KP_STAR,		"\033Oj",	INPUTKEY_KEYPAD },
	{ KEYC_KP_MINUS,	"\033Om",	INPUTKEY_KEYPAD },
	{ KEYC_KP_SEVEN,	"\033Ow",	INPUTKEY_KEYPAD },
	{ KEYC_KP_EIGHT,	"\033Ox",	INPUTKEY_KEYPAD },
	{ KEYC_KP_NINE,		"\033Oy",	INPUTKEY_KEYPAD },
	{ KEYC_KP_PLUS,		"\033Ok",	INPUTKEY_KEYPAD },
	{ KEYC_KP_FOUR,		"\033Ot",	INPUTKEY_KEYPAD },
	{ KEYC_KP_FIVE,		"\033Ou",	INPUTKEY_KEYPAD },
	{ KEYC_KP_SIX,		"\033Ov",	INPUTKEY_KEYPAD },
	{ KEYC_KP_ONE,		"\033Oq",	INPUTKEY_KEYPAD },
	{ KEYC_KP_TWO,		"\033Or",	INPUTKEY_KEYPAD },
	{ KEYC_KP_THREE,	"\033Os",	INPUTKEY_KEYPAD },
	{ KEYC_KP_ENTER,	"\033OM",	INPUTKEY_KEYPAD },
	{ KEYC_KP_ZERO,		"\033Op",	INPUTKEY_KEYPAD },
	{ KEYC_KP_PERIOD,	"\033On",	INPUTKEY_KEYPAD },

	{ KEYC_KP_SLASH,	"/",		0 },
	{ KEYC_KP_STAR,		"*",		0 },
	{ KEYC_KP_MINUS,	"-",		0 },
	{ KEYC_KP_SEVEN,	"7",		0 },
	{ KEYC_KP_EIGHT,	"8",		0 },
	{ KEYC_KP_NINE,		"9",		0 },
	{ KEYC_KP_PLUS,		"+",		0 },
	{ KEYC_KP_FOUR,		"4",		0 },
	{ KEYC_KP_FIVE,		"5",		0 },
	{ KEYC_KP_SIX,		"6",		0 },
	{ KEYC_KP_ONE,		"1",		0 },
	{ KEYC_KP_TWO,		"2",		0 },
	{ KEYC_KP_THREE,	"3",		0 },
	{ KEYC_KP_ENTER,	"\n",		0 },
	{ KEYC_KP_ZERO,		"0",		0 },
	{ KEYC_KP_PERIOD,	".",		0 },
};

/* Split a character into two UTF-8 bytes. */
static size_t
input_split2(u_int c, u_char *dst)
{
	if (c > 0x7f) {
		dst[0] = (c >> 6) | 0xc0;
		dst[1] = (c & 0x3f) | 0x80;
		return (2);
	}
	dst[0] = c;
	return (1);
}

/* Translate a key code into an output key sequence. */
void
input_key(struct window_pane *wp, key_code key, struct mouse_event *m)
{
	const struct input_key_ent	*ike;
	u_int				 i;
	size_t				 dlen;
	char				*out;
	key_code			 justkey;
	struct utf8_data		 ud;

	log_debug("writing key 0x%llx (%s) to %%%u", key,
	    key_string_lookup_key(key), wp->id);

	/* If this is a mouse key, pass off to mouse function. */
	if (KEYC_IS_MOUSE(key)) {
		if (m != NULL && m->wp != -1 && (u_int)m->wp == wp->id)
			input_key_mouse(wp, m);
		return;
	}

	/*
	 * If this is a normal 7-bit key, just send it, with a leading escape
	 * if necessary. If it is a UTF-8 key, split it and send it.
	 */
	justkey = (key & ~(KEYC_XTERM|KEYC_ESCAPE));
	if (justkey <= 0x7f) {
		if (key & KEYC_ESCAPE)
			bufferevent_write(wp->event, "\033", 1);
		ud.data[0] = justkey;
		bufferevent_write(wp->event, &ud.data[0], 1);
		return;
	}
	if (justkey > 0x7f && justkey < KEYC_BASE) {
		if (utf8_split(justkey, &ud) != UTF8_DONE)
			return;
		if (key & KEYC_ESCAPE)
			bufferevent_write(wp->event, "\033", 1);
		bufferevent_write(wp->event, ud.data, ud.size);
		return;
	}

	/*
	 * Then try to look this up as an xterm key, if the flag to output them
	 * is set.
	 */
	if (options_get_number(wp->window->options, "xterm-keys")) {
		if ((out = xterm_keys_lookup(key)) != NULL) {
			bufferevent_write(wp->event, out, strlen(out));
			free(out);
			return;
		}
	}
	key &= ~KEYC_XTERM;

	/* Otherwise look the key up in the table. */
	for (i = 0; i < nitems(input_keys); i++) {
		ike = &input_keys[i];

		if ((ike->flags & INPUTKEY_KEYPAD) &&
		    !(wp->screen->mode & MODE_KKEYPAD))
			continue;
		if ((ike->flags & INPUTKEY_CURSOR) &&
		    !(wp->screen->mode & MODE_KCURSOR))
			continue;

		if ((key & KEYC_ESCAPE) && (ike->key | KEYC_ESCAPE) == key)
			break;
		if (ike->key == key)
			break;
	}
	if (i == nitems(input_keys)) {
		log_debug("key 0x%llx missing", key);
		return;
	}
	dlen = strlen(ike->data);
	log_debug("found key 0x%llx: \"%s\"", key, ike->data);

	/* Prefix a \033 for escape. */
	if (key & KEYC_ESCAPE)
		bufferevent_write(wp->event, "\033", 1);
	bufferevent_write(wp->event, ike->data, dlen);
}

/* Translate mouse and output. */
static void
input_key_mouse(struct window_pane *wp, struct mouse_event *m)
{
	struct screen	*s = wp->screen;
	int		 mode = s->mode;
	char		 buf[40];
	size_t		 len;
	u_int		 x, y;

	if ((mode & ALL_MOUSE_MODES) == 0)
		return;
	if (!window_pane_visible(wp))
		return;
	if (cmd_mouse_at(wp, m, &x, &y, 0) != 0)
		return;

	/* If this pane is not in button or all mode, discard motion events. */
	if (MOUSE_DRAG(m->b) &&
	    (mode & (MODE_MOUSE_BUTTON|MODE_MOUSE_ALL)) == 0)
	    return;

	/*
	 * If this event is a release event and not in all mode, discard it.
	 * In SGR mode we can tell absolutely because a release is normally
	 * shown by the last character. Without SGR, we check if the last
	 * buttons was also a release.
	 */
	if (m->sgr_type != ' ') {
		if (MOUSE_DRAG(m->sgr_b) &&
		    MOUSE_BUTTONS(m->sgr_b) == 3 &&
		    (~mode & MODE_MOUSE_ALL))
			return;
	} else {
		if (MOUSE_DRAG(m->b) &&
		    MOUSE_BUTTONS(m->b) == 3 &&
		    MOUSE_BUTTONS(m->lb) == 3 &&
		    (~mode & MODE_MOUSE_ALL))
			return;
	}

	/*
	 * Use the SGR (1006) extension only if the application requested it
	 * and the underlying terminal also sent the event in this format (this
	 * is because an old style mouse release event cannot be converted into
	 * the new SGR format, since the released button is unknown). Otherwise
	 * pretend that tmux doesn't speak this extension, and fall back to the
	 * UTF-8 (1005) extension if the application requested, or to the
	 * legacy format.
	 */
	if (m->sgr_type != ' ' && (s->mode & MODE_MOUSE_SGR)) {
		len = xsnprintf(buf, sizeof buf, "\033[<%u;%u;%u%c",
		    m->sgr_b, x + 1, y + 1, m->sgr_type);
	} else if (s->mode & MODE_MOUSE_UTF8) {
		if (m->b > 0x7ff - 32 || x > 0x7ff - 33 || y > 0x7ff - 33)
			return;
		len = xsnprintf(buf, sizeof buf, "\033[M");
		len += input_split2(m->b + 32, &buf[len]);
		len += input_split2(x + 33, &buf[len]);
		len += input_split2(y + 33, &buf[len]);
	} else {
		if (m->b > 223)
			return;
		len = xsnprintf(buf, sizeof buf, "\033[M");
		buf[len++] = m->b + 32;
		buf[len++] = x + 33;
		buf[len++] = y + 33;
	}
	log_debug("writing mouse %.*s to %%%u", (int)len, buf, wp->id);
	bufferevent_write(wp->event, buf, len);
}
@


1.61
log
@Add explicit keys for the bracketed paste sequences, both to avoid mix
ups with other keys and to make logs clearer.
@
text
@d1 1
a1 1
/* $OpenBSD: input-keys.c,v 1.60 2017/05/07 21:25:59 nicm Exp $ */
d180 1
a180 1
	justkey = (key & ~KEYC_ESCAPE);
@


1.60
log
@Up to now, tmux sees \033\033[OA as M-Up and since we turned on
xterm-keys by default, generates \033[1;3A instead of
\033\033[OA. Unfortunately this confuses vi, which doesn't understand
xterm keys and now sees Escape+Up pressed within escape-time as Escape
followed by A.

The issue doesn't happen in xterm itself because it gets the keys from X
and can distinguish between a genuine M-Up and Escape+Up.

Because xterm can, tmux can too: xterm will give us \033[1;3A (that is,
kUP3) for a real M-Up and \033\033OA for Escape+Up - in fact, we can be
sure any \033 preceding an xterm key is a real Escape key press because
Meta would be part of the xterm key instead of a separate \033.

So change tmux to recognise both sequences as M-Up for its own purposes,
but generate the xterm version of M-Up only if it originally received
the xterm version from the terminal.

This means we will return to sending \033\033OA instead of the xterm key
for terminals that do not support xterm keys themselves, but there is no
practical way around this because they do not allow us to distinguish
between Escape+Up and M-Up. xterm style escape sequences are now the de
facto standard for these keys in any case.

Problem reported by jsing@@ and subsequently by Cecile Tonglet in GitHub
issue 907.
@
text
@d1 1
a1 1
/* $OpenBSD: input-keys.c,v 1.59 2017/02/01 09:55:07 nicm Exp $ */
d48 4
@


1.59
log
@Implement "all event" (1003) mouse mode but in a way that works. The
main issue is that if we have two panes, A with 1002 and B with 1003, we
need to set 1003 outside tmux in order to get all the mouse events, but
then we need to suppress the ones that pane A doesn't want. This is easy
in SGR mouse mode, because buttons == 3 is only used for movement events
(for other events the trailing m/M marks a release instead), but in
normal mouse mode we can't tell so easily. So for that, look at the
previous event instead - if it is drag+release as well, then the current
event is a movement event.
@
text
@d1 1
a1 1
/* $OpenBSD: input-keys.c,v 1.58 2017/01/25 14:36:08 nicm Exp $ */
d204 1
@


1.58
log
@Revert previous for now, it will break TERM=screen.
@
text
@d1 1
a1 1
/* $OpenBSD: input-keys.c,v 1.56 2016/10/03 22:52:11 nicm Exp $ */
d238 5
a242 3
	char	buf[40];
	size_t	len;
	u_int	x, y;
d244 1
a244 1
	if ((wp->screen->mode & ALL_MOUSE_MODES) == 0)
d251 23
a273 3
	/* If this pane is not in button mode, discard motion events. */
	if (!(wp->screen->mode & MODE_MOUSE_BUTTON) && (m->b & MOUSE_MASK_DRAG))
		return;
d284 1
a284 1
	if (m->sgr_type != ' ' && (wp->screen->mode & MODE_MOUSE_SGR)) {
d287 1
a287 1
	} else if (wp->screen->mode & MODE_MOUSE_UTF8) {
@


1.57
log
@If xterm-keys is on, use xterm(1) style keys for Home and End as well as
modified keys.
@
text
@a160 1
	int				 mode;
a196 1
	mode = wp->screen->mode;
d198 1
a198 1
		if ((out = xterm_keys_lookup(key, mode)) != NULL) {
d209 2
a210 1
		if ((ike->flags & INPUTKEY_KEYPAD) && (~mode & MODE_KKEYPAD))
d212 2
a213 1
		if ((ike->flags & INPUTKEY_CURSOR) && (~mode & MODE_KCURSOR))
@


1.56
log
@Remove some dead code in cmd-move-window.c and make a load of local
functions static.
@
text
@d1 1
a1 1
/* $OpenBSD: input-keys.c,v 1.55 2016/03/02 15:33:36 nicm Exp $ */
d161 1
d198 1
d200 1
a200 1
		if ((out = xterm_keys_lookup(key)) != NULL) {
d211 1
a211 2
		if ((ike->flags & INPUTKEY_KEYPAD) &&
		    !(wp->screen->mode & MODE_KKEYPAD))
d213 1
a213 2
		if ((ike->flags & INPUTKEY_CURSOR) &&
		    !(wp->screen->mode & MODE_KCURSOR))
@


1.55
log
@Limit x, y and b to 0x7ff for UTF-8 mouse input, suggested by schwarze@@.
@
text
@d1 1
a1 1
/* $OpenBSD: input-keys.c,v 1.54 2016/03/01 12:02:08 nicm Exp $ */
d34 1
a34 1
void	 input_key_mouse(struct window_pane *, struct mouse_event *);
d45 1
a45 1
const struct input_key_ent input_keys[] = {
d235 1
a235 1
void
@


1.54
log
@Use system wcwidth() instead of carrying around UTF-8 width tables.
@
text
@d1 1
a1 1
/* $OpenBSD: input-keys.c,v 1.53 2016/01/19 15:59:12 nicm Exp $ */
d266 2
@


1.53
log
@I no longer use my SourceForge address so replace it.
@
text
@d1 1
a1 1
/* $OpenBSD: input-keys.c,v 1.52 2015/12/12 18:19:00 nicm Exp $ */
d138 13
d267 3
a269 3
		len += utf8_split2(m->b + 32, &buf[len]);
		len += utf8_split2(x + 33, &buf[len]);
		len += utf8_split2(y + 33, &buf[len]);
@


1.52
log
@Allow prefix and prefix2 to be set to None to disable (useful if you
would rather bind the prefix in the root table).
@
text
@d1 1
a1 1
/* $OpenBSD: input-keys.c,v 1.51 2015/11/23 23:47:57 nicm Exp $ */
d4 1
a4 1
 * Copyright (c) 2007 Nicholas Marriott <nicm@@users.sourceforge.net>
@


1.51
log
@Partly revert previous, it is harmless to keep support for UTF-8 mouse
mode inside tmux, just no longer support it for tmux itself.
@
text
@d1 1
a1 1
/* $OpenBSD: input-keys.c,v 1.50 2015/11/23 20:53:09 nicm Exp $ */
d164 1
a164 1
	if (key != KEYC_NONE && justkey <= 0x7f) {
d171 1
a171 1
	if (key != KEYC_NONE && justkey > 0x7f && justkey < KEYC_BASE) {
@


1.50
log
@Remove support for the UTF-8 mouse extension. This was a briefly used,
poor idea that was fairly quickly replaced by SGR mouse input (which is
now widespread). It is impossible to tell the difference between UTF-8
and non-UTF-8 mouse input; since the mouse-utf8 option was removed tmux
has not handled it correctly in any case; and it is ridiculous to have
three different forms of mouse input.
@
text
@d1 1
a1 1
/* $OpenBSD: input-keys.c,v 1.49 2015/11/16 22:57:51 nicm Exp $ */
d246 1
d252 5
@


1.49
log
@0x7f is a valid key.
@
text
@d1 1
a1 1
/* $OpenBSD: input-keys.c,v 1.48 2015/11/14 11:45:43 nicm Exp $ */
a245 1
	 * UTF-8 (1005) extension if the application requested, or to the
a250 5
	} else if (wp->screen->mode & MODE_MOUSE_UTF8) {
		len = xsnprintf(buf, sizeof buf, "\033[M");
		len += utf8_split2(m->b + 32, &buf[len]);
		len += utf8_split2(x + 33, &buf[len]);
		len += utf8_split2(y + 33, &buf[len]);
@


1.48
log
@All these return values from utf8_* are confusing, use an enum.
@
text
@d1 1
a1 1
/* $OpenBSD: input-keys.c,v 1.47 2015/11/12 22:04:37 nicm Exp $ */
d164 1
a164 1
	if (key != KEYC_NONE && justkey < 0x7f) {
@


1.47
log
@Rename overly-long utf8data to ud throughout.
@
text
@d1 1
a1 1
/* $OpenBSD: input-keys.c,v 1.46 2015/11/12 11:05:34 nicm Exp $ */
d172 1
a172 1
		if (utf8_split(justkey, &ud) != 0)
@


1.46
log
@Support UTF-8 key bindings by expanding the key type from int to
uint64_t and converting UTF-8 to Unicode on input and the reverse on
output. (This allows key bindings, there are still omissions - the
largest being that the various prompts do not accept UTF-8.)
@
text
@d1 1
a1 1
/* $OpenBSD: input-keys.c,v 1.45 2015/10/27 15:58:42 nicm Exp $ */
d147 1
a147 1
	struct utf8_data		 utf8data;
d167 2
a168 2
		utf8data.data[0] = justkey;
		bufferevent_write(wp->event, &utf8data.data[0], 1);
d172 1
a172 1
		if (utf8_split(justkey, &utf8data) != 0)
d176 1
a176 1
		bufferevent_write(wp->event, utf8data.data, utf8data.size);
@


1.45
log
@Move struct options into options.c.
@
text
@d1 1
a1 1
/* $OpenBSD: input-keys.c,v 1.44 2015/10/26 17:17:06 nicm Exp $ */
d37 1
a37 1
	int		 key;
d140 1
a140 1
input_key(struct window_pane *wp, int key, struct mouse_event *m)
d142 6
a147 5
	const struct input_key_ent     *ike;
	u_int				i;
	size_t				dlen;
	char			       *out;
	u_char				ch;
d149 1
a149 1
	log_debug("writing key 0x%x (%s) to %%%u", key,
d161 1
a161 1
	 * if necessary.
d163 2
a164 1
	if (key != KEYC_NONE && (key & ~KEYC_ESCAPE) < 0x100) {
d167 10
a176 2
		ch = key & ~KEYC_ESCAPE;
		bufferevent_write(wp->event, &ch, 1);
d209 1
a209 1
		log_debug("key 0x%x missing", key);
d213 1
a213 1
	log_debug("found key 0x%x: \"%s\"", key, ike->data);
@


1.44
log
@Some extra logging of where keys are actually going.
@
text
@d1 1
a1 1
/* $OpenBSD: input-keys.c,v 1.43 2015/04/21 15:21:41 nicm Exp $ */
d174 1
a174 1
	if (options_get_number(&wp->window->options, "xterm-keys")) {
@


1.43
log
@Don't eat the mouse event that triggers a drag end because we may want
to pass it on to application inside the pane.
@
text
@d1 1
a1 1
/* $OpenBSD: input-keys.c,v 1.42 2015/04/19 21:34:21 nicm Exp $ */
d148 2
a149 1
	log_debug("writing key 0x%x (%s)", key, key_string_lookup_key(key));
d255 1
a255 1
	log_debug("writing mouse %.*s", (int)len, buf);
@


1.42
log
@Rewrite of tmux mouse support which was a mess. Instead of having
options for "mouse-this" and "mouse-that", mouse events may be bound as
keys and there is one option "mouse" that turns on mouse support
entirely (set -g mouse on).

See the new MOUSE SUPPORT section of the man page for description of the
key names and new flags (-t= to specify the pane or window under mouse
as a target, and send-keys -M to pass through a mouse event).

The default builtin bindings for the mouse are:

    bind -n   MouseDown1Pane select-pane -t=; send-keys -M
    bind -n MouseDown1Status select-window -t=
    bind -n   MouseDrag1Pane copy-mode -M
    bind -n MouseDrag1Border resize-pane -M

To get the effect of turning mode-mouse off, do:

    unbind -n MouseDrag1Pane
    unbind -temacs-copy MouseDrag1Pane

The old mouse options are now gone, set-option -q may be used to
suppress warnings if mixing configuration files.
@
text
@d1 1
a1 1
/* $OpenBSD: input-keys.c,v 1.41 2015/03/31 17:45:10 nicm Exp $ */
d254 1
@


1.41
log
@Fix some format specifier nits, from Ben Boeckel.
@
text
@d1 1
a1 1
/* $OpenBSD: input-keys.c,v 1.40 2014/11/05 23:25:02 nicm Exp $ */
d34 2
d140 1
a140 1
input_key(struct window_pane *wp, int key)
d148 8
a155 1
	log_debug("writing key 0x%x", key);
d212 1
a212 1
input_mouse(struct window_pane *wp, struct session *s, struct mouse_event *m)
d214 9
a222 34
	char			 buf[40];
	size_t			 len;
	struct paste_buffer	*pb;
	int			 event;

	if (wp->screen->mode & ALL_MOUSE_MODES) {
		/*
		 * Use the SGR (1006) extension only if the application
		 * requested it and the underlying terminal also sent the event
		 * in this format (this is because an old style mouse release
		 * event cannot be converted into the new SGR format, since the
		 * released button is unknown). Otherwise pretend that tmux
		 * doesn't speak this extension, and fall back to the UTF-8
		 * (1005) extension if the application requested, or to the
		 * legacy format.
		 */
		if (m->sgr && (wp->screen->mode & MODE_MOUSE_SGR)) {
			len = xsnprintf(buf, sizeof buf, "\033[<%u;%u;%u%c",
			    m->sgr_xb, m->x + 1, m->y + 1,
			    m->sgr_rel ? 'm' : 'M');
		} else if (wp->screen->mode & MODE_MOUSE_UTF8) {
			len = xsnprintf(buf, sizeof buf, "\033[M");
			len += utf8_split2(m->xb + 32, &buf[len]);
			len += utf8_split2(m->x + 33, &buf[len]);
			len += utf8_split2(m->y + 33, &buf[len]);
		} else {
			if (m->xb > 223)
				return;
			len = xsnprintf(buf, sizeof buf, "\033[M");
			buf[len++] = m->xb + 32;
			buf[len++] = m->x + 33;
			buf[len++] = m->y + 33;
		}
		bufferevent_write(wp->event, buf, len);
a223 1
	}
d225 2
a226 1
	if (options_get_number(&wp->window->options, "mode-mouse") != 1)
d228 25
a252 9
	event = m->event & (MOUSE_EVENT_CLICK|MOUSE_EVENT_WHEEL);
	if (wp->mode == NULL && m->button == 1 && event == MOUSE_EVENT_CLICK) {
		pb = paste_get_top();
		if (pb != NULL)
			paste_send_pane(pb, wp, "\r", 1);
	} else if (window_pane_set_mode(wp, &window_copy_mode) == 0) {
		window_copy_init_from_pane(wp);
		if (wp->mode->mouse != NULL)
			wp->mode->mouse(wp, s, m);
d254 1
@


1.40
log
@Tidy up mode-mouse check.
@
text
@d1 1
a1 1
/* $OpenBSD: input-keys.c,v 1.39 2014/07/21 20:45:35 nicm Exp $ */
d222 1
a222 1
			len = xsnprintf(buf, sizeof buf, "\033[<%d;%d;%d%c",
@


1.39
log
@Revert the up/down wheel emulation for now, there will be a better way
to do this along later for those who want it.
@
text
@d1 1
a1 1
/* $OpenBSD: input-keys.c,v 1.38 2014/07/21 10:25:48 nicm Exp $ */
d208 1
d242 4
a245 2
	if (m->button == 1 && (m->event & MOUSE_EVENT_CLICK) &&
	    options_get_number(&wp->window->options, "mode-mouse") == 1) {
d247 6
a252 11
		if (pb != NULL) {
			paste_send_pane(pb, wp, "\r",
			    wp->screen->mode & MODE_BRACKETPASTE);
		}
	} else if (m->button != 1 &&
	    options_get_number(&wp->window->options, "mode-mouse") == 1) {
		if (window_pane_set_mode(wp, &window_copy_mode) == 0) {
			window_copy_init_from_pane(wp);
			if (wp->mode->mouse != NULL)
				wp->mode->mouse(wp, s, m);
		}
@


1.38
log
@Drop explicit support for F13-F20 and change to match the xterm terminfo
entry:

        F13-F24 are S-F1 to S-F12
        F25-F36 are C-F1 to C-F12
        F37-F48 are C-S-F1 to C-S-F12
        F49-F60 are M-F1 to M-F12
and     F61-F63 are M-S-F1 to M-S-F3

This should be no difference for applications inside tmux, but means
that any key binding for F13 will need to be replaced by S-F1 and so on.
@
text
@d1 1
a1 1
/* $OpenBSD: input-keys.c,v 1.37 2014/05/08 07:59:16 nicm Exp $ */
a207 15
	u_int			 i;

	/*
	 * If the alternate screen is active and hasn't enabled the mouse, send
	 * up and down key presses for the mouse wheel.
	 */
	if (wp->saved_grid != NULL && !(wp->screen->mode & ALL_MOUSE_MODES)) {
		for (i = 0; i < m->scroll; i++) {
			if (m->wheel == MOUSE_WHEEL_UP)
				input_key(wp, KEYC_UP);
			else
				input_key(wp, KEYC_DOWN);
		}
		return;
	}
@


1.37
log
@Send up and down keys for mouse wheel in alternate screen mode (when it
normally does nothing), from Marcel Partap.
@
text
@d1 1
a1 1
/* $OpenBSD: input-keys.c,v 1.36 2014/04/24 09:14:43 nicm Exp $ */
d60 8
a67 8
	{ KEYC_F13,		"\033[25~",	0 },
	{ KEYC_F14,		"\033[26~",	0 },
	{ KEYC_F15,		"\033[28~",	0 },
	{ KEYC_F16,		"\033[29~",	0 },
	{ KEYC_F17,		"\033[31~",	0 },
	{ KEYC_F18,		"\033[32~",	0 },
	{ KEYC_F19,		"\033[33~",	0 },
	{ KEYC_F20,		"\033[34~",	0 },
@


1.36
log
@There is no longer a need for a paste_stack struct or for global_buffers
to be global. Move to paste.c.
@
text
@d1 1
a1 1
/* $OpenBSD: input-keys.c,v 1.35 2014/04/03 08:15:17 nicm Exp $ */
d208 15
@


1.35
log
@A couple of trivial mouse-related style nits.
@
text
@d1 1
a1 1
/* $OpenBSD: input-keys.c,v 1.34 2014/03/31 21:42:45 nicm Exp $ */
d243 1
a243 1
		pb = paste_get_top(&global_buffers);
@


1.34
log
@Remove log_debug2 as well and simplify log.c.
@
text
@d1 1
a1 1
/* $OpenBSD: input-keys.c,v 1.33 2013/05/07 11:00:16 nicm Exp $ */
d248 1
a248 1
	} else if ((m->xb & 3) != 1 &&
@


1.33
log
@Don't limit width and height to 222 in standard mouse mode.
@
text
@d1 1
a1 1
/* $OpenBSD: input-keys.c,v 1.32 2013/03/24 09:57:59 nicm Exp $ */
d146 1
a146 1
	log_debug2("writing key 0x%x", key);
d189 1
a189 1
		log_debug2("key 0x%x missing", key);
d193 1
a193 1
	log_debug2("found key 0x%x: \"%s\"", key, ike->data);
@


1.32
log
@Add resize-pane -Z to temporary zoom the active pane to occupy the full
window or unzoom (restored to the normal layout) if it already zoomed,
bound to C-b z by default. The pane is unzoomed on pretty much any
excuse whatsoever.

We considered making this a new layout but the requirements are quite
different from layouts so decided it is better as a special case. Each
current layout cell is saved, a temporary one-cell layout generated and
all except the active pane set to NULL.

Prompted by suggestions and scripts from several. Thanks to Aaron Jensen
and Thiago Padilha for testing an earlier version.
@
text
@d1 1
a1 1
/* $OpenBSD: input-keys.c,v 1.31 2013/03/22 10:33:50 nicm Exp $ */
d230 1
a230 1
			if (m->xb > 223 || m->x >= 222 || m->y > 222)
@


1.31
log
@Support the latest theory for mouse input, this is enabled/disabled with
SM/RM 1006 and is similar in style to SGR input: \033[<b;x;yM or
\033[b;x;ym. From Egmont Koblinger.
@
text
@d1 1
a1 1
/* $OpenBSD: input-keys.c,v 1.30 2012/11/27 20:22:12 nicm Exp $ */
d222 2
a223 1
			    m->sgr_xb, m->x + 1, m->y + 1, m->sgr_rel ? 'm' : 'M');
@


1.30
log
@Support middle-click paste, based on a diff from Ailin Nemui.
@
text
@d1 1
a1 1
/* $OpenBSD: input-keys.c,v 1.27 2012/10/26 14:35:42 nicm Exp $ */
d205 1
a205 1
	char			 buf[10];
d210 14
a223 1
		if (wp->screen->mode & MODE_MOUSE_UTF8) {
@


1.29
log
@Revert last, after discussion it isn't necessary.
@
text
@d205 3
a207 2
	char	buf[10];
	size_t	len;
d227 8
a234 1
	if ((m->xb & 3) != 1 &&
a240 1
		return;
@


1.28
log
@If the application inside tmux has requested any mouse modes itself, do
not let mode-mouse take any effect. From Sergey Naumov.
@
text
@d227 1
a227 2
	    options_get_number(&wp->window->options, "mode-mouse") == 1 &&
	    (wp->base.mode & ALL_MOUSE_MODES) == 0) {
@


1.27
log
@Make mouse event structure clearer by defining events (up, click, drag)
and simplifying how buttons and wheels are represented, from Ailin
Nemui. Should be no functional changes.
@
text
@d1 1
a1 1
/* $OpenBSD: input-keys.c,v 1.26 2012/07/10 11:53:01 nicm Exp $ */
d227 2
a228 1
	    options_get_number(&wp->window->options, "mode-mouse") == 1) {
@


1.26
log
@xfree is not particularly helpful, remove it. From Thomas Adam.
@
text
@d1 1
a1 1
/* $OpenBSD: input-keys.c,v 1.25 2012/05/05 18:48:31 nicm Exp $ */
d203 1
a203 1
input_mouse(struct window_pane *wp, struct mouse_event *m)
d211 1
a211 1
			len += utf8_split2(m->b + 32, &buf[len]);
d215 1
a215 1
			if (m->b > 223 || m->x >= 222 || m->y > 222)
d218 1
a218 1
			buf[len++] = m->b + 32;
d226 1
a226 1
	if ((m->b & 3) != 1 &&
d231 1
a231 1
				wp->mode->mouse(wp, NULL, m);
@


1.25
log
@Only enter copy mode on scroll up, from Ailin Nemui.
@
text
@d1 1
a1 1
/* $OpenBSD: input-keys.c,v 1.24 2012/04/01 20:56:47 nicm Exp $ */
d167 1
a167 1
			xfree(out);
@


1.24
log
@Simplify mouse input function.
@
text
@d1 1
a1 1
/* $OpenBSD: input-keys.c,v 1.23 2011/07/30 18:01:26 nicm Exp $ */
d226 2
a227 1
	if (options_get_number(&wp->window->options, "mode-mouse") == 1) {
@


1.23
log
@Extend the mode-mouse option to add a third choice which means the mouse
does not enter copy mode. Patch from SF bug 3374493.

In future the mode-mouse option is likely to die and be broken into
several smaller options.
@
text
@d1 1
a1 1
/* $OpenBSD: input-keys.c,v 1.22 2011/04/19 21:31:33 nicm Exp $ */
a206 1
	int	value;
d223 5
a227 4
	} else if ((m->b & MOUSE_BUTTON) != MOUSE_2) {
		value = options_get_number(&wp->window->options, "mode-mouse");
		if (value == 1 &&
		    window_pane_set_mode(wp, &window_copy_mode) == 0) {
d232 1
@


1.22
log
@When mode-mouse is on (it is off by default), automatically enter copy
mode when the mouse is dragged or the mouse wheel is used. Also exit
copy mode when the mouse wheel is scrolled off the bottom. Discussed
with and written by hsim at gmx dot li.
@
text
@d1 1
a1 1
/* $OpenBSD: input-keys.c,v 1.21 2011/01/03 23:35:21 nicm Exp $ */
d207 1
d225 2
a226 1
		if (options_get_number(&wp->window->options, "mode-mouse") &&
@


1.21
log
@Support for UTF-8 mouse input (\033[1005h). This was added in xterm 262
and supports larger terminals than the older way.

If the new mouse-utf8 option is on, UTF-8 mouse input is enabled for all
UTF-8 terminals. The option defaults to on if LANG etc are set in the
same manner as the utf8 option.

With help and based on code from hsim at gmx.li.
@
text
@d1 1
a1 1
/* $OpenBSD: input-keys.c,v 1.20 2011/01/01 03:43:20 nicm Exp $ */
d223 7
@


1.20
log
@Last few tables that should be const.
@
text
@d1 1
a1 1
/* $OpenBSD: input-keys.c,v 1.19 2010/12/29 21:49:06 nicm Exp $ */
d205 2
a206 1
	char	out[8];
d209 14
a222 3
		xsnprintf(out, sizeof out,
		    "\033[M%c%c%c", m->b + 32, m->x + 33, m->y + 33);
		bufferevent_write(wp->event, out, strlen(out));
@


1.19
log
@Support all four of the xterm mouse modes. Based on a diff from hsim at
gmx.li.
@
text
@d1 1
a1 1
/* $OpenBSD: input-keys.c,v 1.18 2009/12/03 22:50:10 nicm Exp $ */
d43 1
a43 1
struct input_key_ent input_keys[] = {
d140 5
a144 5
	struct input_key_ent   *ike;
	u_int			i;
	size_t			dlen;
	char		       *out;
	u_char			ch;
@


1.18
log
@Massive spaces->tabs and trailing whitespace cleanup, hopefully for the last
time now I've configured emacs to make them displayed in really annoying
colours...
@
text
@d1 1
a1 1
/* $OpenBSD: input-keys.c,v 1.17 2009/11/25 12:24:31 nicm Exp $ */
d207 1
a207 1
	if (wp->screen->mode & MODE_MOUSE) {
@


1.17
log
@Output the right keys for application and number keypad modes (they were the
wrong way round).
@
text
@d1 1
a1 1
/* $OpenBSD: input-keys.c,v 1.16 2009/11/10 18:48:03 nicm Exp $ */
d84 1
a84 1
	
d125 1
a125 1
	{ KEYC_KP_FOUR,		"4",		0 },	
d160 1
a160 1
	/* 
@


1.16
log
@Don't output rxvtisms either.
@
text
@d1 1
a1 1
/* $OpenBSD: input-keys.c,v 1.15 2009/11/04 23:00:22 nicm Exp $ */
d101 33
a133 33
	{ KEYC_KP_SLASH,	"/",		INPUTKEY_KEYPAD },
	{ KEYC_KP_STAR,		"*",		INPUTKEY_KEYPAD },
	{ KEYC_KP_MINUS,	"-",		INPUTKEY_KEYPAD },
	{ KEYC_KP_SEVEN,	"7",		INPUTKEY_KEYPAD },
	{ KEYC_KP_EIGHT,	"8",		INPUTKEY_KEYPAD },
	{ KEYC_KP_NINE,		"9",		INPUTKEY_KEYPAD },
	{ KEYC_KP_PLUS,		"+",		INPUTKEY_KEYPAD },
	{ KEYC_KP_FOUR,		"4",		INPUTKEY_KEYPAD },	
	{ KEYC_KP_FIVE,		"5",		INPUTKEY_KEYPAD },
	{ KEYC_KP_SIX,		"6",		INPUTKEY_KEYPAD },
	{ KEYC_KP_ONE,		"1",		INPUTKEY_KEYPAD },
	{ KEYC_KP_TWO,		"2",		INPUTKEY_KEYPAD },
	{ KEYC_KP_THREE,	"3",		INPUTKEY_KEYPAD },
	{ KEYC_KP_ENTER,	"\n",		INPUTKEY_KEYPAD },
	{ KEYC_KP_ZERO,		"0",		INPUTKEY_KEYPAD },
	{ KEYC_KP_PERIOD,	".",		INPUTKEY_KEYPAD },

	{ KEYC_KP_SLASH,	"\033Oo",	0 },
	{ KEYC_KP_STAR,		"\033Oj",	0 },
	{ KEYC_KP_MINUS,	"\033Om",	0 },
	{ KEYC_KP_SEVEN,	"\033Ow",	0 },
	{ KEYC_KP_EIGHT,	"\033Ox",	0 },
	{ KEYC_KP_NINE,		"\033Oy",	0 },
	{ KEYC_KP_PLUS,		"\033Ok",	0 },
	{ KEYC_KP_FOUR,		"\033Ot",	0 },
	{ KEYC_KP_FIVE,		"\033Ou",	0 },
	{ KEYC_KP_SIX,		"\033Ov",	0 },
	{ KEYC_KP_ONE,		"\033Oq",	0 },
	{ KEYC_KP_TWO,		"\033Or",	0 },
	{ KEYC_KP_THREE,	"\033Os",	0 },
	{ KEYC_KP_ENTER,	"\033OM",	0 },
	{ KEYC_KP_ZERO,		"\033Op",	0 },
	{ KEYC_KP_PERIOD,	"\033On",	0 },
@


1.15
log
@It would help if I read my own comments... make alt keys work again by sending
alt AND the key not alt instead of it.
@
text
@d1 1
a1 1
/* $OpenBSD: input-keys.c,v 1.14 2009/11/04 22:43:11 nicm Exp $ */
a52 1
	{ KEYC_F5|KEYC_CTRL,	"\033[15^",	0 },
a53 1
	{ KEYC_F6|KEYC_CTRL,	"\033[17^",	0 },
a54 1
	{ KEYC_F7|KEYC_CTRL,	"\033[18^",	0 },
a55 1
	{ KEYC_F8|KEYC_CTRL,	"\033[19^",	0 },
a56 1
	{ KEYC_F9|KEYC_CTRL,	"\033[20^",	0 },
a57 1
	{ KEYC_F10|KEYC_CTRL,	"\033[21^",	0 },
a58 1
	{ KEYC_F1|KEYC_CTRL,	"\033[23^",	0 },
a59 1
	{ KEYC_F12|KEYC_CTRL,	"\033[24^",	0 },
a60 1
	{ KEYC_F13|KEYC_CTRL,	"\033[25^",	0 },
a61 1
	{ KEYC_F14|KEYC_CTRL,	"\033[26^",	0 },
a62 1
	{ KEYC_F15|KEYC_CTRL,	"\033[28^",	0 },
a63 1
	{ KEYC_F16|KEYC_CTRL,	"\033[29^",	0 },
a64 1
	{ KEYC_F17|KEYC_CTRL,	"\033[31^",	0 },
a65 1
	{ KEYC_F18|KEYC_CTRL,	"\033[32^",	0 },
a66 1
	{ KEYC_F19|KEYC_CTRL,	"\033[33^",	0 },
a67 1
	{ KEYC_F20|KEYC_CTRL,	"\033[34^",	0 },
a68 1
	{ KEYC_IC|KEYC_CTRL,	"\033[2^",	0 },
a69 1
	{ KEYC_DC|KEYC_CTRL,	"\033[3^",	0 },
a70 1
	{ KEYC_HOME|KEYC_CTRL,	"\033[1^",	0 },
a71 1
	{ KEYC_END|KEYC_CTRL,	"\033[4^",	0 },
a72 1
	{ KEYC_NPAGE|KEYC_CTRL,	"\033[6^",	0 },
a73 1
	{ KEYC_PPAGE|KEYC_CTRL,	"\033[5^",	0 },
@


1.14
log
@Convert the window pane (pty master side) fd over to use a bufferevent.

The evbuffer API is very similar to the existing tmux buffer API so this was
remarkably painless. Not many possible ways to do it, I suppose.
@
text
@d1 1
a1 1
/* $OpenBSD: input-keys.c,v 1.13 2009/10/26 17:59:46 nicm Exp $ */
d176 2
a177 3
			ch = '\033';
		else
			ch = key & ~KEYC_ESCAPE;
@


1.13
log
@Not all terminals swap CSI and SS3 on ctrl, so remove that.

Also mark the rxvt special-cases as such until terminfo is updated to have
kLFT5, kRIT5 etc.
@
text
@d1 1
a1 1
/* $OpenBSD: input-keys.c,v 1.12 2009/10/26 17:46:33 nicm Exp $ */
d166 1
d176 4
a179 2
			buffer_write8(wp->out, '\033');
		buffer_write8(wp->out, (uint8_t) (key & ~KEYC_ESCAPE));
d189 1
a189 1
			buffer_write(wp->out, out, strlen(out));
d220 2
a221 2
		buffer_write8(wp->out, '\033');
	buffer_write(wp->out, ike->data, dlen);
d228 2
d231 3
a233 4
		buffer_write(wp->out, "\033[M", 3);
		buffer_write8(wp->out, m->b + 32);
		buffer_write8(wp->out, m->x + 33);
		buffer_write8(wp->out, m->y + 33);
@


1.12
log
@Rewrite xterm-keys code (both input and output) so that works (doesn't always
output the same modifiers, accepts all the possible input keys) and is more
understandable.
@
text
@d1 1
a1 1
/* $OpenBSD: input-keys.c,v 1.11 2009/10/26 14:30:57 nicm Exp $ */
d98 4
a101 1
	/* Arrow keys. Cursor versions must come first. */
@


1.11
log
@On second thoughts, drop the rxvt output entirely.
@
text
@d1 1
a1 1
/* $OpenBSD: input-keys.c,v 1.10 2009/10/26 14:27:13 nicm Exp $ */
d175 12
@


1.10
log
@Set the output code for ctrl+cursor keys correctly, and disable (comment)
rxvt-style output.
@
text
@d1 1
a1 1
/* $OpenBSD: input-keys.c,v 1.9 2009/10/26 13:34:26 nicm Exp $ */
a98 12
/*
	{ KEYC_UP|KEYC_CTRL,	"\033Oa",	0 },
	{ KEYC_DOWN|KEYC_CTRL,	"\033Ob",	0 },
	{ KEYC_RIGHT|KEYC_CTRL,	"\033Oc",	0 },
	{ KEYC_LEFT|KEYC_CTRL,	"\033Od",	0 },
	
	{ KEYC_UP|KEYC_SHIFT,	"\033[a",	0 },
	{ KEYC_DOWN|KEYC_SHIFT,	"\033[b",	0 },
	{ KEYC_RIGHT|KEYC_SHIFT,"\033[c",	0 },
	{ KEYC_LEFT|KEYC_SHIFT,	"\033[d",	0 },
*/

@


1.9
log
@Drop INPUTKEY_CTRL and just handle it as part of the table.
@
text
@d1 1
a1 1
/* $OpenBSD: input-keys.c,v 1.8 2009/10/26 13:29:24 nicm Exp $ */
d99 1
d109 1
d111 4
a114 4
	{ KEYC_UP|KEYC_CTRL,	"\033OA",	INPUTKEY_CURSOR },
	{ KEYC_DOWN|KEYC_CTRL,	"\033OB",	INPUTKEY_CURSOR },
	{ KEYC_RIGHT|KEYC_CTRL,	"\033OC",	INPUTKEY_CURSOR },
	{ KEYC_LEFT|KEYC_CTRL,	"\033OD",	INPUTKEY_CURSOR },
d174 1
@


1.8
log
@Add or fix some comments.
@
text
@d1 1
a1 1
/* $OpenBSD: input-keys.c,v 1.7 2009/10/26 13:22:30 nicm Exp $ */
a40 1
#define INPUTKEY_CTRL 0x4	/* may be modified with ctrl */
d48 49
a96 27
	{ KEYC_F1,		"\033OP",	INPUTKEY_CTRL },
	{ KEYC_F2,		"\033OQ",	INPUTKEY_CTRL },
	{ KEYC_F3,		"\033OR",	INPUTKEY_CTRL },
	{ KEYC_F4,		"\033OS",	INPUTKEY_CTRL },
	{ KEYC_F5,		"\033[15~",	INPUTKEY_CTRL },
	{ KEYC_F6,		"\033[17~",	INPUTKEY_CTRL },
	{ KEYC_F7,		"\033[18~",	INPUTKEY_CTRL },
	{ KEYC_F8,		"\033[19~",	INPUTKEY_CTRL },
	{ KEYC_F9,		"\033[20~",	INPUTKEY_CTRL },
	{ KEYC_F10,		"\033[21~",	INPUTKEY_CTRL },
	{ KEYC_F11,		"\033[23~",	INPUTKEY_CTRL },
	{ KEYC_F12,		"\033[24~",	INPUTKEY_CTRL },
	{ KEYC_F13,		"\033[25~",	INPUTKEY_CTRL },
	{ KEYC_F14,		"\033[26~",	INPUTKEY_CTRL },
	{ KEYC_F15,		"\033[28~",	INPUTKEY_CTRL },
	{ KEYC_F16,		"\033[29~",	INPUTKEY_CTRL },
	{ KEYC_F17,		"\033[31~",	INPUTKEY_CTRL },
	{ KEYC_F18,		"\033[32~",	INPUTKEY_CTRL },
	{ KEYC_F19,		"\033[33~",	INPUTKEY_CTRL },
	{ KEYC_F20,		"\033[34~",	INPUTKEY_CTRL },
	{ KEYC_IC,		"\033[2~",	INPUTKEY_CTRL },
	{ KEYC_DC,		"\033[3~",	INPUTKEY_CTRL },
	{ KEYC_HOME,		"\033[1~",	INPUTKEY_CTRL },
	{ KEYC_END,		"\033[4~",	INPUTKEY_CTRL },
	{ KEYC_NPAGE,		"\033[6~",	INPUTKEY_CTRL },
	{ KEYC_PPAGE,		"\033[5~",	INPUTKEY_CTRL },
	{ KEYC_BTAB,		"\033[Z",	INPUTKEY_CTRL },
d98 1
a98 1
	/* Arrow keys. Cursor versions must come first .*/
d108 5
d119 5
a198 6
		if ((key & KEYC_SHIFT) && (ike->key | KEYC_SHIFT) == key)
			break;
		if ((key & KEYC_CTRL) && (ike->key | KEYC_CTRL) == key) {
			if (ike->flags & INPUTKEY_CTRL)
				break;
		}
a206 1

d209 1
a209 1
	/* Prefix a \033 for escape and set bit 5 of the last byte for ctrl. */
a211 5
	if (key & KEYC_CTRL && ike->flags & INPUTKEY_CTRL) {
		buffer_write(wp->out, ike->data, dlen - 1);
		buffer_write8(wp->out, ike->data[dlen - 1] ^ 0x20);
		return;
	}
@


1.7
log
@Tidy up table.
@
text
@d1 1
a1 1
/* $OpenBSD: input-keys.c,v 1.6 2009/10/26 13:13:33 nicm Exp $ */
d27 7
d98 1
a98 1
	/* Keypad keys. Keypad versions must come first.*/
d134 1
a134 1
/* Translate a key code from client into an output key sequence. */
a139 1
	char			ch;
a140 1
	int			xterm_keys;
d144 4
d155 1
d185 1
a185 4
	/*
	 * Not in xterm mode. Prefix a \033 for escape, and set bit 5 of the
	 * last byte for ctrl.
	 */
d196 1
a196 1
/* Handle input mouse. */
@


1.6
log
@Rename keypad keys to something more useful.
@
text
@d1 1
a1 1
/* $OpenBSD: input-keys.c,v 1.5 2009/10/26 13:02:53 nicm Exp $ */
d39 1
a39 1
	{ KEYC_BSPACE, "\177",	   0 },
d42 33
a74 33
	{ KEYC_F1,     "\033OP",   INPUTKEY_CTRL },
	{ KEYC_F2,     "\033OQ",   INPUTKEY_CTRL },
	{ KEYC_F3,     "\033OR",   INPUTKEY_CTRL },
	{ KEYC_F4,     "\033OS",   INPUTKEY_CTRL },
	{ KEYC_F5,     "\033[15~", INPUTKEY_CTRL },
	{ KEYC_F6,     "\033[17~", INPUTKEY_CTRL },
	{ KEYC_F7,     "\033[18~", INPUTKEY_CTRL },
	{ KEYC_F8,     "\033[19~", INPUTKEY_CTRL },
	{ KEYC_F9,     "\033[20~", INPUTKEY_CTRL },
	{ KEYC_F10,    "\033[21~", INPUTKEY_CTRL },
	{ KEYC_F11,    "\033[23~", INPUTKEY_CTRL },
	{ KEYC_F12,    "\033[24~", INPUTKEY_CTRL },
	{ KEYC_F13,    "\033[25~", INPUTKEY_CTRL },
	{ KEYC_F14,    "\033[26~", INPUTKEY_CTRL },
	{ KEYC_F15,    "\033[28~", INPUTKEY_CTRL },
	{ KEYC_F16,    "\033[29~", INPUTKEY_CTRL },
	{ KEYC_F17,    "\033[31~", INPUTKEY_CTRL },
	{ KEYC_F18,    "\033[32~", INPUTKEY_CTRL },
	{ KEYC_F19,    "\033[33~", INPUTKEY_CTRL },
	{ KEYC_F20,    "\033[34~", INPUTKEY_CTRL },
	{ KEYC_IC,     "\033[2~",  INPUTKEY_CTRL },
	{ KEYC_DC,     "\033[3~",  INPUTKEY_CTRL },
	{ KEYC_HOME,   "\033[1~",  INPUTKEY_CTRL },
	{ KEYC_END,    "\033[4~",  INPUTKEY_CTRL },
	{ KEYC_NPAGE,  "\033[6~",  INPUTKEY_CTRL },
	{ KEYC_PPAGE,  "\033[5~",  INPUTKEY_CTRL },
	{ KEYC_BTAB,   "\033[Z",   INPUTKEY_CTRL },

	/* Arrow keys. Cursor versions must come first. */
	{ KEYC_UP | KEYC_CTRL,     "\033Oa", 0 },
	{ KEYC_DOWN | KEYC_CTRL,   "\033Ob", 0 },
	{ KEYC_RIGHT | KEYC_CTRL,  "\033Oc", 0 },
	{ KEYC_LEFT | KEYC_CTRL,   "\033Od", 0 },
d76 4
a79 4
	{ KEYC_UP | KEYC_SHIFT,    "\033[a", 0 },
	{ KEYC_DOWN | KEYC_SHIFT,  "\033[b", 0 },
	{ KEYC_RIGHT | KEYC_SHIFT, "\033[c", 0 },
	{ KEYC_LEFT | KEYC_SHIFT,  "\033[d", 0 },
d81 44
a124 43
	{ KEYC_UP,     "\033OA",   INPUTKEY_CURSOR },
	{ KEYC_DOWN,   "\033OB",   INPUTKEY_CURSOR },
	{ KEYC_RIGHT,  "\033OC",   INPUTKEY_CURSOR },
	{ KEYC_LEFT,   "\033OD",   INPUTKEY_CURSOR },

	{ KEYC_UP,     "\033[A",   0 },
	{ KEYC_DOWN,   "\033[B",   0 },
	{ KEYC_RIGHT,  "\033[C",   0 },
	{ KEYC_LEFT,   "\033[D",   0 },

	/* Keypad keys. Keypad versions must come first. */
	{ KEYC_KP_SLASH,  "/", INPUTKEY_KEYPAD },
	{ KEYC_KP_STAR,   "*", INPUTKEY_KEYPAD },
	{ KEYC_KP_MINUS,  "-", INPUTKEY_KEYPAD },
	{ KEYC_KP_SEVEN,  "7", INPUTKEY_KEYPAD },
	{ KEYC_KP_EIGHT,  "8", INPUTKEY_KEYPAD },
	{ KEYC_KP_NINE,   "9", INPUTKEY_KEYPAD },
	{ KEYC_KP_PLUS,   "+", INPUTKEY_KEYPAD },
	{ KEYC_KP_FOUR,   "4", INPUTKEY_KEYPAD },
	{ KEYC_KP_FIVE,   "5", INPUTKEY_KEYPAD },
	{ KEYC_KP_SIX,    "6", INPUTKEY_KEYPAD },
	{ KEYC_KP_ONE,    "1", INPUTKEY_KEYPAD },
	{ KEYC_KP_TWO,    "2", INPUTKEY_KEYPAD },
	{ KEYC_KP_THREE,  "3", INPUTKEY_KEYPAD },
	{ KEYC_KP_ENTER,  "\n", INPUTKEY_KEYPAD },
	{ KEYC_KP_ZERO,   "0", INPUTKEY_KEYPAD },
	{ KEYC_KP_PERIOD, ".", INPUTKEY_KEYPAD },
	{ KEYC_KP_SLASH,  "\033Oo", 0 },
	{ KEYC_KP_STAR,   "\033Oj", 0 },
	{ KEYC_KP_MINUS,  "\033Om", 0 },
	{ KEYC_KP_SEVEN,  "\033Ow", 0 },
	{ KEYC_KP_EIGHT,  "\033Ox", 0 },
	{ KEYC_KP_NINE,   "\033Oy", 0 },
	{ KEYC_KP_PLUS,   "\033Ok", 0 },
	{ KEYC_KP_FOUR,   "\033Ot", 0 },
	{ KEYC_KP_FIVE,   "\033Ou", 0 },
	{ KEYC_KP_SIX,    "\033Ov", 0 },
	{ KEYC_KP_ONE,    "\033Oq", 0 },
	{ KEYC_KP_TWO,    "\033Or", 0 },
	{ KEYC_KP_THREE,  "\033Os", 0 },
	{ KEYC_KP_ENTER,  "\033OM", 0 },
	{ KEYC_KP_ZERO,   "\033Op", 0 },
	{ KEYC_KP_PERIOD, "\033On", 0 },
@


1.5
log
@Remove the xterm-keys code which is broken (a replacement is coming but some
more cleanup is needed first).
@
text
@d1 1
a1 1
/* $OpenBSD: input-keys.c,v 1.4 2009/10/11 07:01:10 nicm Exp $ */
d92 32
a123 32
	{ KEYC_KP0_1,  "/", INPUTKEY_KEYPAD },
	{ KEYC_KP0_2,  "*", INPUTKEY_KEYPAD },
	{ KEYC_KP0_3,  "-", INPUTKEY_KEYPAD },
	{ KEYC_KP1_0,  "7", INPUTKEY_KEYPAD },
	{ KEYC_KP1_1,  "8", INPUTKEY_KEYPAD },
	{ KEYC_KP1_2,  "9", INPUTKEY_KEYPAD },
	{ KEYC_KP1_3,  "+", INPUTKEY_KEYPAD },
	{ KEYC_KP2_0,  "4", INPUTKEY_KEYPAD },
	{ KEYC_KP2_1,  "5", INPUTKEY_KEYPAD },
	{ KEYC_KP2_2,  "6", INPUTKEY_KEYPAD },
	{ KEYC_KP3_0,  "1", INPUTKEY_KEYPAD },
	{ KEYC_KP3_1,  "2", INPUTKEY_KEYPAD },
	{ KEYC_KP3_2,  "3", INPUTKEY_KEYPAD },
	{ KEYC_KP3_3,  "\n", INPUTKEY_KEYPAD }, /* this can be CRLF too? */
	{ KEYC_KP4_0,  "0", INPUTKEY_KEYPAD },
	{ KEYC_KP4_2,  ".", INPUTKEY_KEYPAD },
	{ KEYC_KP0_1,  "\033Oo", 0 },
	{ KEYC_KP0_2,  "\033Oj", 0 },
	{ KEYC_KP0_3,  "\033Om", 0 },
	{ KEYC_KP1_0,  "\033Ow", 0 },
	{ KEYC_KP1_1,  "\033Ox", 0 },
	{ KEYC_KP1_2,  "\033Oy", 0 },
	{ KEYC_KP1_3,  "\033Ok", 0 },
	{ KEYC_KP2_0,  "\033Ot", 0 },
	{ KEYC_KP2_1,  "\033Ou", 0 },
	{ KEYC_KP2_2,  "\033Ov", 0 },
	{ KEYC_KP3_0,  "\033Oq", 0 },
	{ KEYC_KP3_1,  "\033Or", 0 },
	{ KEYC_KP3_2,  "\033Os", 0 },
	{ KEYC_KP3_3,  "\033OM", 0 },
	{ KEYC_KP4_0,  "\033Op", 0 },
	{ KEYC_KP4_2,  "\033On", 0 },
@


1.4
log
@Clean up by introducing a wrapper struct for mouse clicks rather than passing
three u_chars around.

As a side-effect this fixes incorrectly rejecting high cursor positions
(because it was comparing them as signed char), reported by Tom Doherty.
@
text
@d1 1
a1 1
/* $OpenBSD: input-keys.c,v 1.3 2009/07/26 21:42:08 nicm Exp $ */
a34 1
#define INPUTKEY_XTERM 0x4	/* may have xterm argument appended */
d42 26
a67 26
	{ KEYC_F1,     "\033OP",   INPUTKEY_CTRL|INPUTKEY_XTERM },
	{ KEYC_F2,     "\033OQ",   INPUTKEY_CTRL|INPUTKEY_XTERM },
	{ KEYC_F3,     "\033OR",   INPUTKEY_CTRL|INPUTKEY_XTERM },
	{ KEYC_F4,     "\033OS",   INPUTKEY_CTRL|INPUTKEY_XTERM },
	{ KEYC_F5,     "\033[15~", INPUTKEY_CTRL|INPUTKEY_XTERM },
	{ KEYC_F6,     "\033[17~", INPUTKEY_CTRL|INPUTKEY_XTERM },
	{ KEYC_F7,     "\033[18~", INPUTKEY_CTRL|INPUTKEY_XTERM },
	{ KEYC_F8,     "\033[19~", INPUTKEY_CTRL|INPUTKEY_XTERM },
	{ KEYC_F9,     "\033[20~", INPUTKEY_CTRL|INPUTKEY_XTERM },
	{ KEYC_F10,    "\033[21~", INPUTKEY_CTRL|INPUTKEY_XTERM },
	{ KEYC_F11,    "\033[23~", INPUTKEY_CTRL|INPUTKEY_XTERM },
	{ KEYC_F12,    "\033[24~", INPUTKEY_CTRL|INPUTKEY_XTERM },
	{ KEYC_F13,    "\033[25~", INPUTKEY_CTRL|INPUTKEY_XTERM },
	{ KEYC_F14,    "\033[26~", INPUTKEY_CTRL|INPUTKEY_XTERM },
	{ KEYC_F15,    "\033[28~", INPUTKEY_CTRL|INPUTKEY_XTERM },
	{ KEYC_F16,    "\033[29~", INPUTKEY_CTRL|INPUTKEY_XTERM },
	{ KEYC_F17,    "\033[31~", INPUTKEY_CTRL|INPUTKEY_XTERM },
	{ KEYC_F18,    "\033[32~", INPUTKEY_CTRL|INPUTKEY_XTERM },
	{ KEYC_F19,    "\033[33~", INPUTKEY_CTRL|INPUTKEY_XTERM },
	{ KEYC_F20,    "\033[34~", INPUTKEY_CTRL|INPUTKEY_XTERM },
	{ KEYC_IC,     "\033[2~",  INPUTKEY_CTRL|INPUTKEY_XTERM },
	{ KEYC_DC,     "\033[3~",  INPUTKEY_CTRL|INPUTKEY_XTERM },
	{ KEYC_HOME,   "\033[1~",  INPUTKEY_CTRL|INPUTKEY_XTERM },
	{ KEYC_END,    "\033[4~",  INPUTKEY_CTRL|INPUTKEY_XTERM },
	{ KEYC_NPAGE,  "\033[6~",  INPUTKEY_CTRL|INPUTKEY_XTERM },
	{ KEYC_PPAGE,  "\033[5~",  INPUTKEY_CTRL|INPUTKEY_XTERM },
a172 31

	/*
	 * If in xterm keys mode, work out and append the modifier as an
	 * argument.
	 */
	xterm_keys = options_get_number(&wp->window->options, "xterm-keys");
	if (xterm_keys && ike->flags & INPUTKEY_XTERM) {
		ch = '\0';
		if (key & (KEYC_SHIFT|KEYC_ESCAPE|KEYC_CTRL))
			ch = '8';
		else if (key & (KEYC_ESCAPE|KEYC_CTRL))
			ch = '7';
		else if (key & (KEYC_SHIFT|KEYC_CTRL))
			ch = '6';
		else if (key & KEYC_CTRL)
			ch = '5';
		else if (key & (KEYC_SHIFT|KEYC_ESCAPE))
			ch = '4';
		else if (key & KEYC_ESCAPE)
			ch = '3';
		else if (key & KEYC_SHIFT)
			ch = '2';
		if (ch != '\0') {
			buffer_write(wp->out, ike->data, dlen - 1);
			buffer_write8(wp->out, ';');
			buffer_write8(wp->out, ch);
			buffer_write8(wp->out, ike->data[dlen - 1]);
		} else
			buffer_write(wp->out, ike->data, dlen);
		return;
	}
@


1.3
log
@Detect backspace by looking at termios VERASE and translate it into \177 (which
matches screen's behaviour if not its termcap/terminfo entry). The terminfo kbs
cap is often wrong or missing so it can't be used, and just assuming \177 may
be wrong.
@
text
@d1 1
a1 1
/* $OpenBSD: input-keys.c,v 1.2 2009/07/21 17:57:29 nicm Exp $ */
d222 1
a222 1
input_mouse(struct window_pane *wp, u_char b, u_char x, u_char y)
d226 3
a228 3
		buffer_write8(wp->out, b + 32);
		buffer_write8(wp->out, x + 33);
		buffer_write8(wp->out, y + 33);
@


1.2
log
@Tidy up keys: use an enum for the key codes, and remove the macros which just
wrap flag sets/clears/tests.
@
text
@d1 1
a1 1
/* $OpenBSD: input-keys.c,v 1.1 2009/06/01 22:58:49 nicm Exp $ */
d39 3
@


1.1
log
@Import tmux, a terminal multiplexor allowing (among other things) a single
terminal to be switched between several different windows and programs
displayed on one terminal be detached from one terminal and moved to another.

ok deraadt pirofti
@
text
@d1 1
a1 1
/* $OpenBSD$ */
d69 10
a78 10
	{ KEYC_ADDCTL(KEYC_UP),    "\033Oa", 0 },
	{ KEYC_ADDCTL(KEYC_DOWN),  "\033Ob", 0 },
	{ KEYC_ADDCTL(KEYC_RIGHT), "\033Oc", 0 },
	{ KEYC_ADDCTL(KEYC_LEFT),  "\033Od", 0 },

	{ KEYC_ADDSFT(KEYC_UP),    "\033[a", 0 },
	{ KEYC_ADDSFT(KEYC_DOWN),  "\033[b", 0 },
	{ KEYC_ADDSFT(KEYC_RIGHT), "\033[c", 0 },
	{ KEYC_ADDSFT(KEYC_LEFT),  "\033[d", 0 },

d136 2
a137 2
	if (key != KEYC_NONE && KEYC_REMOVEESC(key) < KEYC_OFFSET) {
		if (KEYC_ISESC(key))
d139 1
a139 1
		buffer_write8(wp->out, (uint8_t) KEYC_REMOVEESC(key));
d153 1
a153 1
		if (KEYC_ISESC(key) && KEYC_ADDESC(ike->key) == key)
d155 1
a155 1
		if (KEYC_ISSFT(key) && KEYC_ADDSFT(ike->key) == key)
d157 1
a157 1
		if (KEYC_ISCTL(key) && KEYC_ADDCTL(ike->key) == key) {
d179 1
a179 1
		if (KEYC_ISSFT(key) && KEYC_ISESC(key) && KEYC_ISCTL(key))
d181 1
a181 1
		else if (KEYC_ISESC(key) && KEYC_ISCTL(key))
d183 1
a183 1
		else if (KEYC_ISSFT(key) && KEYC_ISCTL(key))
d185 1
a185 1
		else if (KEYC_ISCTL(key))
d187 1
a187 1
		else if (KEYC_ISSFT(key) && KEYC_ISESC(key))
d189 1
a189 1
		else if (KEYC_ISESC(key))
d191 1
a191 1
		else if (KEYC_ISSFT(key))
d207 1
a207 1
	if (KEYC_ISESC(key))
d209 1
a209 1
	if (KEYC_ISCTL(key) && ike->flags & INPUTKEY_CTRL) {
@

