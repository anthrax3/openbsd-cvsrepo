head	1.175;
access;
symbols
	OPENBSD_6_1:1.166.0.4
	OPENBSD_6_1_BASE:1.166
	OPENBSD_6_0:1.159.0.2
	OPENBSD_6_0_BASE:1.159
	OPENBSD_5_9:1.157.0.2
	OPENBSD_5_9_BASE:1.157
	OPENBSD_5_8:1.129.0.4
	OPENBSD_5_8_BASE:1.129
	OPENBSD_5_7:1.118.0.2
	OPENBSD_5_7_BASE:1.118
	OPENBSD_5_6:1.115.0.4
	OPENBSD_5_6_BASE:1.115
	OPENBSD_5_5:1.111.0.4
	OPENBSD_5_5_BASE:1.111
	OPENBSD_5_4:1.110.0.2
	OPENBSD_5_4_BASE:1.110
	OPENBSD_5_3:1.107.0.2
	OPENBSD_5_3_BASE:1.107
	OPENBSD_5_2:1.105.0.2
	OPENBSD_5_2_BASE:1.105
	OPENBSD_5_1_BASE:1.102
	OPENBSD_5_1:1.102.0.4
	OPENBSD_5_0:1.102.0.2
	OPENBSD_5_0_BASE:1.102
	OPENBSD_4_9:1.101.0.2
	OPENBSD_4_9_BASE:1.101
	OPENBSD_4_8:1.91.0.2
	OPENBSD_4_8_BASE:1.91
	OPENBSD_4_7:1.83.0.2
	OPENBSD_4_7_BASE:1.83
	OPENBSD_4_6:1.5.0.4
	OPENBSD_4_6_BASE:1.5;
locks; strict;
comment	@ * @;


1.175
date	2017.07.12.10.04.51;	author nicm;	state Exp;
branches;
next	1.174;
commitid	AQOFbEqorBS7o8Il;

1.174
date	2017.07.12.09.24.17;	author nicm;	state Exp;
branches;
next	1.173;
commitid	GhkQsamphQVs3LP1;

1.173
date	2017.07.09.22.33.09;	author nicm;	state Exp;
branches;
next	1.172;
commitid	CGfMLOla6ygOWaAk;

1.172
date	2017.07.03.08.16.03;	author nicm;	state Exp;
branches;
next	1.171;
commitid	3rK8y6YdEO1TozsR;

1.171
date	2017.06.04.08.25.57;	author nicm;	state Exp;
branches;
next	1.170;
commitid	WVrnfI8R8Z2jveSi;

1.170
date	2017.04.22.06.13.30;	author nicm;	state Exp;
branches;
next	1.169;
commitid	qj69nMLfErnppz7k;

1.169
date	2017.04.21.20.26.34;	author nicm;	state Exp;
branches;
next	1.168;
commitid	utIGVdoSurUxfh14;

1.168
date	2017.04.21.14.04.54;	author nicm;	state Exp;
branches;
next	1.167;
commitid	VtR2SR2RBAosVqPt;

1.167
date	2017.04.20.09.20.22;	author nicm;	state Exp;
branches;
next	1.166;
commitid	Mq5Wq9pThOn7RhSJ;

1.166
date	2017.02.09.15.04.53;	author nicm;	state Exp;
branches;
next	1.165;
commitid	LotTNNNN3Vrlt9Fn;

1.165
date	2017.01.24.21.50.22;	author nicm;	state Exp;
branches;
next	1.164;
commitid	RhpGrb29XR7z4pyo;

1.164
date	2016.11.12.19.04.41;	author nicm;	state Exp;
branches;
next	1.163;
commitid	UaKjdiDUYOsjcHt2;

1.163
date	2016.10.16.19.15.02;	author nicm;	state Exp;
branches;
next	1.162;
commitid	BsOGDBdjoFC7iuvC;

1.162
date	2016.10.16.17.55.14;	author nicm;	state Exp;
branches;
next	1.161;
commitid	1xIYFpLYkPIXNEvU;

1.161
date	2016.10.15.00.01.01;	author nicm;	state Exp;
branches;
next	1.160;
commitid	Y3LyKhemZ1e3lTtQ;

1.160
date	2016.10.10.21.29.23;	author nicm;	state Exp;
branches;
next	1.159;
commitid	z4Hr4PZF7Ev93uEJ;

1.159
date	2016.07.07.09.24.09;	author semarie;	state Exp;
branches;
next	1.158;
commitid	hE1KWX6z2fMHBxIr;

1.158
date	2016.03.30.13.20.07;	author nicm;	state Exp;
branches;
next	1.157;
commitid	abY4AFxXtTXZxmld;

1.157
date	2016.01.19.15.59.12;	author nicm;	state Exp;
branches;
next	1.156;
commitid	P3qmSOx6KrDBsb0c;

1.156
date	2015.12.16.21.50.37;	author nicm;	state Exp;
branches;
next	1.155;
commitid	Bam1GajuDZzmKjyE;

1.155
date	2015.12.15.00.00.01;	author nicm;	state Exp;
branches;
next	1.154;
commitid	yMmY7FLVcToE15ZM;

1.154
date	2015.11.24.23.01.51;	author nicm;	state Exp;
branches;
next	1.153;
commitid	43ZLrb9ocz8bOA55;

1.153
date	2015.11.24.21.52.06;	author nicm;	state Exp;
branches;
next	1.152;
commitid	Wy0S0Ml5dOX2TIOy;

1.152
date	2015.11.24.21.19.46;	author nicm;	state Exp;
branches;
next	1.151;
commitid	WYqwkdfYHZzn9ayb;

1.151
date	2015.11.22.19.41.19;	author nicm;	state Exp;
branches;
next	1.150;
commitid	eQiXkQ2tR16i0GKB;

1.150
date	2015.11.18.14.27.44;	author nicm;	state Exp;
branches;
next	1.149;
commitid	RjsAPRkWwvS79w40;

1.149
date	2015.11.15.14.32.48;	author nicm;	state Exp;
branches;
next	1.148;
commitid	Vya5bw5HIjQNToOw;

1.148
date	2015.11.14.09.41.07;	author nicm;	state Exp;
branches;
next	1.147;
commitid	FQoND7M2BC89FZoU;

1.147
date	2015.11.12.12.19.57;	author nicm;	state Exp;
branches;
next	1.146;
commitid	jNkHcPRyvqShNcEt;

1.146
date	2015.10.31.13.12.03;	author nicm;	state Exp;
branches;
next	1.145;
commitid	YMQrsd7hfJkvI0rw;

1.145
date	2015.10.27.15.58.42;	author nicm;	state Exp;
branches;
next	1.144;
commitid	89xhQafU35Q5MQVC;

1.144
date	2015.10.27.13.23.24;	author nicm;	state Exp;
branches;
next	1.143;
commitid	g6GdEJXfBNprXHEK;

1.143
date	2015.10.23.16.07.29;	author nicm;	state Exp;
branches;
next	1.142;
commitid	xGflsqvIYR0qhE2C;

1.142
date	2015.10.22.10.48.30;	author nicm;	state Exp;
branches;
next	1.141;
commitid	E1HLj251fpKFll2w;

1.141
date	2015.10.22.10.46.24;	author nicm;	state Exp;
branches;
next	1.140;
commitid	0XlcsPZMaVqmd7Qz;

1.140
date	2015.10.11.00.26.23;	author guenther;	state Exp;
branches;
next	1.139;
commitid	EiEgif09VdYpflOP;

1.139
date	2015.09.01.10.01.56;	author nicm;	state Exp;
branches;
next	1.138;
commitid	HiJ8QXCMc25AkMAL;

1.138
date	2015.08.30.22.19.07;	author nicm;	state Exp;
branches;
next	1.137;
commitid	nMCE84XHv5ujel0H;

1.137
date	2015.08.29.08.54.41;	author nicm;	state Exp;
branches;
next	1.136;
commitid	aTZI9iHPczxhIdBt;

1.136
date	2015.08.29.08.30.54;	author nicm;	state Exp;
branches;
next	1.135;
commitid	RrlCW4OYH7he0yBf;

1.135
date	2015.08.28.13.21.25;	author nicm;	state Exp;
branches;
next	1.134;
commitid	03O6hLLxn92YQ1Pr;

1.134
date	2015.08.28.13.12.20;	author nicm;	state Exp;
branches;
next	1.133;
commitid	7dHMdjgnodjQvy6O;

1.133
date	2015.08.28.12.31.55;	author nicm;	state Exp;
branches;
next	1.132;
commitid	TVJDgAOZtMm4s2XM;

1.132
date	2015.08.28.12.25.42;	author nicm;	state Exp;
branches;
next	1.131;
commitid	6bG4Sc33YFhgSCnx;

1.131
date	2015.08.28.12.16.28;	author nicm;	state Exp;
branches;
next	1.130;
commitid	LqkiQ6rY2EYTPxv3;

1.130
date	2015.08.28.11.38.27;	author nicm;	state Exp;
branches;
next	1.129;
commitid	Tft8aiYUxsfXokWg;

1.129
date	2015.07.20.15.50.04;	author nicm;	state Exp;
branches;
next	1.128;
commitid	XjcnBmI1AcHx5t2a;

1.128
date	2015.06.05.18.18.32;	author nicm;	state Exp;
branches;
next	1.127;
commitid	ZQGnMCbBqbBRSCmt;

1.127
date	2015.06.05.18.01.12;	author nicm;	state Exp;
branches;
next	1.126;
commitid	38CNdOauYnpJlZqC;

1.126
date	2015.06.04.11.43.51;	author nicm;	state Exp;
branches;
next	1.125;
commitid	rAvOUA4CI6VK3gQ6;

1.125
date	2015.06.01.09.20.19;	author nicm;	state Exp;
branches;
next	1.124;
commitid	n2VW51CRjba7kbk8;

1.124
date	2015.05.31.23.27.06;	author deraadt;	state Exp;
branches;
next	1.123;
commitid	1YCqkCnixYNrG7Pl;

1.123
date	2015.05.27.13.28.04;	author nicm;	state Exp;
branches;
next	1.122;
commitid	jNiCCHdN1zYsiWiL;

1.122
date	2015.04.24.23.17.11;	author nicm;	state Exp;
branches;
next	1.121;
commitid	iy4fcaIoXzxOx84I;

1.121
date	2015.04.22.15.30.11;	author nicm;	state Exp;
branches;
next	1.120;
commitid	0bmlELm9krdoS6OB;

1.120
date	2015.04.22.15.05.03;	author nicm;	state Exp;
branches;
next	1.119;
commitid	NOv4t3Ada2mtdBzi;

1.119
date	2015.04.21.22.32.40;	author nicm;	state Exp;
branches;
next	1.118;
commitid	RdNUD7saZLMVpMJa;

1.118
date	2014.12.09.19.23.35;	author nicm;	state Exp;
branches;
next	1.117;
commitid	F9Ad8BPsskeeEtGX;

1.117
date	2014.10.27.22.23.47;	author nicm;	state Exp;
branches;
next	1.116;
commitid	lLfuAlkV0hLlHdgD;

1.116
date	2014.09.01.21.58.41;	author nicm;	state Exp;
branches;
next	1.115;
commitid	PB2QtqgfNXhDsTfg;

1.115
date	2014.07.21.10.52.48;	author nicm;	state Exp;
branches;
next	1.114;
commitid	iAQWR82ZELL44q5e;

1.114
date	2014.05.14.06.21.19;	author nicm;	state Exp;
branches;
next	1.113;

1.113
date	2014.04.24.09.14.43;	author nicm;	state Exp;
branches;
next	1.112;

1.112
date	2014.04.17.14.45.49;	author nicm;	state Exp;
branches;
next	1.111;

1.111
date	2013.10.20.17.28.43;	author nicm;	state Exp;
branches;
next	1.110;

1.110
date	2013.04.24.10.01.32;	author nicm;	state Exp;
branches;
next	1.109;

1.109
date	2013.03.24.09.54.10;	author nicm;	state Exp;
branches;
next	1.108;

1.108
date	2013.03.22.10.31.22;	author nicm;	state Exp;
branches;
next	1.107;

1.107
date	2012.12.06.12.49.13;	author nicm;	state Exp;
branches;
next	1.106;

1.106
date	2012.11.19.10.38.06;	author nicm;	state Exp;
branches;
next	1.105;

1.105
date	2012.07.10.11.53.01;	author nicm;	state Exp;
branches;
next	1.104;

1.104
date	2012.04.11.06.16.14;	author nicm;	state Exp;
branches;
next	1.103;

1.103
date	2012.03.09.09.57.40;	author nicm;	state Exp;
branches;
next	1.102;

1.102
date	2011.03.27.20.27.26;	author nicm;	state Exp;
branches;
next	1.101;

1.101
date	2011.01.26.00.11.47;	author nicm;	state Exp;
branches;
next	1.100;

1.100
date	2011.01.08.01.52.36;	author nicm;	state Exp;
branches;
next	1.99;

1.99
date	2011.01.01.01.12.09;	author nicm;	state Exp;
branches;
next	1.98;

1.98
date	2010.12.30.23.16.18;	author nicm;	state Exp;
branches;
next	1.97;

1.97
date	2010.12.21.22.37.59;	author nicm;	state Exp;
branches;
next	1.96;

1.96
date	2010.10.18.20.00.02;	author nicm;	state Exp;
branches;
next	1.95;

1.95
date	2010.10.16.08.31.55;	author nicm;	state Exp;
branches;
next	1.94;

1.94
date	2010.09.26.20.43.30;	author nicm;	state Exp;
branches;
next	1.93;

1.93
date	2010.09.26.18.51.48;	author nicm;	state Exp;
branches;
next	1.92;

1.92
date	2010.08.19.18.29.01;	author nicm;	state Exp;
branches;
next	1.91;

1.91
date	2010.08.04.19.46.13;	author deraadt;	state Exp;
branches;
next	1.90;

1.90
date	2010.07.24.19.25.32;	author nicm;	state Exp;
branches;
next	1.89;

1.89
date	2010.06.21.00.18.57;	author nicm;	state Exp;
branches;
next	1.88;

1.88
date	2010.05.04.17.28.16;	author nicm;	state Exp;
branches;
next	1.87;

1.87
date	2010.05.04.08.48.06;	author nicm;	state Exp;
branches;
next	1.86;

1.86
date	2010.05.03.16.06.32;	author nicm;	state Exp;
branches;
next	1.85;

1.85
date	2010.04.06.21.35.44;	author nicm;	state Exp;
branches;
next	1.84;

1.84
date	2010.03.22.19.11.54;	author nicm;	state Exp;
branches;
next	1.83;

1.83
date	2010.02.06.23.22.27;	author nicm;	state Exp;
branches;
next	1.82;

1.82
date	2010.02.06.17.15.33;	author nicm;	state Exp;
branches;
next	1.81;

1.81
date	2010.01.30.19.05.18;	author nicm;	state Exp;
branches;
next	1.80;

1.80
date	2009.12.03.22.50.10;	author nicm;	state Exp;
branches;
next	1.79;

1.79
date	2009.12.02.15.06.14;	author nicm;	state Exp;
branches;
next	1.78;

1.78
date	2009.11.26.21.37.13;	author nicm;	state Exp;
branches;
next	1.77;

1.77
date	2009.11.13.17.33.07;	author nicm;	state Exp;
branches;
next	1.76;

1.76
date	2009.11.11.13.24.42;	author nicm;	state Exp;
branches;
next	1.75;

1.75
date	2009.11.11.08.00.42;	author nicm;	state Exp;
branches;
next	1.74;

1.74
date	2009.11.05.08.50.32;	author nicm;	state Exp;
branches;
next	1.73;

1.73
date	2009.11.05.08.48.15;	author nicm;	state Exp;
branches;
next	1.72;

1.72
date	2009.11.04.23.42.51;	author nicm;	state Exp;
branches;
next	1.71;

1.71
date	2009.11.04.23.12.43;	author nicm;	state Exp;
branches;
next	1.70;

1.70
date	2009.11.04.22.47.34;	author nicm;	state Exp;
branches;
next	1.69;

1.69
date	2009.11.04.22.43.11;	author nicm;	state Exp;
branches;
next	1.68;

1.68
date	2009.11.04.22.40.36;	author nicm;	state Exp;
branches;
next	1.67;

1.67
date	2009.11.04.21.04.43;	author nicm;	state Exp;
branches;
next	1.66;

1.66
date	2009.11.04.20.50.11;	author nicm;	state Exp;
branches;
next	1.65;

1.65
date	2009.11.03.20.29.47;	author nicm;	state Exp;
branches;
next	1.64;

1.64
date	2009.11.02.12.48.44;	author nicm;	state Exp;
branches;
next	1.63;

1.63
date	2009.10.27.13.03.33;	author nicm;	state Exp;
branches;
next	1.62;

1.62
date	2009.10.26.21.42.04;	author deraadt;	state Exp;
branches;
next	1.61;

1.61
date	2009.10.26.21.38.18;	author nicm;	state Exp;
branches;
next	1.60;

1.60
date	2009.10.22.19.41.51;	author nicm;	state Exp;
branches;
next	1.59;

1.59
date	2009.10.13.06.14.08;	author nicm;	state Exp;
branches;
next	1.58;

1.58
date	2009.10.12.09.29.58;	author nicm;	state Exp;
branches;
next	1.57;

1.57
date	2009.10.12.09.16.59;	author nicm;	state Exp;
branches;
next	1.56;

1.56
date	2009.10.12.09.09.35;	author nicm;	state Exp;
branches;
next	1.55;

1.55
date	2009.10.11.10.04.27;	author nicm;	state Exp;
branches;
next	1.54;

1.54
date	2009.10.11.08.58.05;	author nicm;	state Exp;
branches;
next	1.53;

1.53
date	2009.10.11.07.20.16;	author nicm;	state Exp;
branches;
next	1.52;

1.52
date	2009.10.11.07.01.10;	author nicm;	state Exp;
branches;
next	1.51;

1.51
date	2009.10.11.00.53.14;	author nicm;	state Exp;
branches;
next	1.50;

1.50
date	2009.10.10.18.42.14;	author nicm;	state Exp;
branches;
next	1.49;

1.49
date	2009.10.10.15.03.01;	author nicm;	state Exp;
branches;
next	1.48;

1.48
date	2009.10.10.14.51.16;	author nicm;	state Exp;
branches;
next	1.47;

1.47
date	2009.10.10.10.02.48;	author nicm;	state Exp;
branches;
next	1.46;

1.46
date	2009.10.10.09.46.11;	author nicm;	state Exp;
branches;
next	1.45;

1.45
date	2009.10.10.09.31.39;	author nicm;	state Exp;
branches;
next	1.44;

1.44
date	2009.10.05.18.30.54;	author nicm;	state Exp;
branches;
next	1.43;

1.43
date	2009.09.24.07.02.56;	author nicm;	state Exp;
branches;
next	1.42;

1.42
date	2009.09.23.08.21.57;	author nicm;	state Exp;
branches;
next	1.41;

1.41
date	2009.09.23.06.18.47;	author nicm;	state Exp;
branches;
next	1.40;

1.40
date	2009.09.22.12.38.10;	author nicm;	state Exp;
branches;
next	1.39;

1.39
date	2009.09.20.14.58.12;	author nicm;	state Exp;
branches;
next	1.38;

1.38
date	2009.09.18.15.19.27;	author nicm;	state Exp;
branches;
next	1.37;

1.37
date	2009.09.15.07.45.16;	author nicm;	state Exp;
branches;
next	1.36;

1.36
date	2009.09.14.11.25.35;	author nicm;	state Exp;
branches;
next	1.35;

1.35
date	2009.09.12.13.09.43;	author nicm;	state Exp;
branches;
next	1.34;

1.34
date	2009.09.12.13.01.19;	author nicm;	state Exp;
branches;
next	1.33;

1.33
date	2009.09.10.17.16.24;	author nicm;	state Exp;
branches;
next	1.32;

1.32
date	2009.09.07.21.12.12;	author nicm;	state Exp;
branches;
next	1.31;

1.31
date	2009.09.07.21.01.50;	author nicm;	state Exp;
branches;
next	1.30;

1.30
date	2009.09.07.19.08.45;	author kili;	state Exp;
branches;
next	1.29;

1.29
date	2009.09.05.17.42.16;	author nicm;	state Exp;
branches;
next	1.28;

1.28
date	2009.09.04.13.29.10;	author nicm;	state Exp;
branches;
next	1.27;

1.27
date	2009.09.02.21.25.57;	author nicm;	state Exp;
branches;
next	1.26;

1.26
date	2009.08.31.20.46.19;	author nicm;	state Exp;
branches;
next	1.25;

1.25
date	2009.08.31.11.37.27;	author nicm;	state Exp;
branches;
next	1.24;

1.24
date	2009.08.23.17.29.51;	author nicm;	state Exp;
branches;
next	1.23;

1.23
date	2009.08.18.21.37.04;	author nicm;	state Exp;
branches;
next	1.22;

1.22
date	2009.08.18.21.14.24;	author nicm;	state Exp;
branches;
next	1.21;

1.21
date	2009.08.14.11.23.34;	author nicm;	state Exp;
branches;
next	1.20;

1.20
date	2009.08.11.22.34.17;	author nicm;	state Exp;
branches;
next	1.19;

1.19
date	2009.08.11.19.32.25;	author nicm;	state Exp;
branches;
next	1.18;

1.18
date	2009.08.11.17.18.35;	author nicm;	state Exp;
branches;
next	1.17;

1.17
date	2009.08.10.19.42.03;	author nicm;	state Exp;
branches;
next	1.16;

1.16
date	2009.08.07.15.39.10;	author nicm;	state Exp;
branches;
next	1.15;

1.15
date	2009.07.28.07.03.32;	author nicm;	state Exp;
branches;
next	1.14;

1.14
date	2009.07.24.14.52.47;	author nicm;	state Exp;
branches;
next	1.13;

1.13
date	2009.07.21.19.54.22;	author nicm;	state Exp;
branches;
next	1.12;

1.12
date	2009.07.20.14.37.51;	author nicm;	state Exp;
branches;
next	1.11;

1.11
date	2009.07.19.13.21.40;	author nicm;	state Exp;
branches;
next	1.10;

1.10
date	2009.07.18.14.59.25;	author nicm;	state Exp;
branches;
next	1.9;

1.9
date	2009.07.14.19.03.16;	author nicm;	state Exp;
branches;
next	1.8;

1.8
date	2009.07.12.17.33.18;	author nicm;	state Exp;
branches;
next	1.7;

1.7
date	2009.07.12.16.07.56;	author nicm;	state Exp;
branches;
next	1.6;

1.6
date	2009.07.07.19.49.19;	author nicm;	state Exp;
branches;
next	1.5;

1.5
date	2009.06.26.22.12.19;	author nicm;	state Exp;
branches;
next	1.4;

1.4
date	2009.06.25.22.09.20;	author nicm;	state Exp;
branches;
next	1.3;

1.3
date	2009.06.24.22.49.56;	author nicm;	state Exp;
branches;
next	1.2;

1.2
date	2009.06.24.17.36.15;	author nicm;	state Exp;
branches;
next	1.1;

1.1
date	2009.06.01.22.58.49;	author nicm;	state Exp;
branches;
next	;


desc
@@


1.175
log
@Block signals between forking and clearing signal handlers (or calling
event_reinit) - if the child gets a signal and fires the libevent signal
handler during this period it could write a signal into the parent's
signal pipe. GitHub issue 1001 from Aaron van Geffen.
@
text
@/* $OpenBSD: server.c,v 1.174 2017/07/12 09:24:17 nicm Exp $ */

/*
 * Copyright (c) 2007 Nicholas Marriott <nicholas.marriott@@gmail.com>
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF MIND, USE, DATA OR PROFITS, WHETHER
 * IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING
 * OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */

#include <sys/types.h>
#include <sys/ioctl.h>
#include <sys/socket.h>
#include <sys/stat.h>
#include <sys/un.h>
#include <sys/wait.h>

#include <errno.h>
#include <event.h>
#include <fcntl.h>
#include <paths.h>
#include <signal.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <termios.h>
#include <time.h>
#include <unistd.h>

#include "tmux.h"

/*
 * Main server functions.
 */

struct clients		 clients;

struct tmuxproc		*server_proc;
static int		 server_fd;
static int		 server_exit;
static struct event	 server_ev_accept;

struct cmd_find_state	 marked_pane;

static int	server_create_socket(void);
static int	server_loop(void);
static void	server_send_exit(void);
static void	server_accept(int, short, void *);
static void	server_signal(int);
static void	server_child_signal(void);
static void	server_child_exited(pid_t, int);
static void	server_child_stopped(pid_t, int);

/* Set marked pane. */
void
server_set_marked(struct session *s, struct winlink *wl, struct window_pane *wp)
{
	cmd_find_clear_state(&marked_pane, 0);
	marked_pane.s = s;
	marked_pane.wl = wl;
	marked_pane.w = wl->window;
	marked_pane.wp = wp;
}

/* Clear marked pane. */
void
server_clear_marked(void)
{
	cmd_find_clear_state(&marked_pane, 0);
}

/* Is this the marked pane? */
int
server_is_marked(struct session *s, struct winlink *wl, struct window_pane *wp)
{
	if (s == NULL || wl == NULL || wp == NULL)
		return (0);
	if (marked_pane.s != s || marked_pane.wl != wl)
		return (0);
	if (marked_pane.wp != wp)
		return (0);
	return (server_check_marked());
}

/* Check if the marked pane is still valid. */
int
server_check_marked(void)
{
	return (cmd_find_valid_state(&marked_pane));
}

/* Create server socket. */
static int
server_create_socket(void)
{
	struct sockaddr_un	sa;
	size_t			size;
	mode_t			mask;
	int			fd;

	memset(&sa, 0, sizeof sa);
	sa.sun_family = AF_UNIX;
	size = strlcpy(sa.sun_path, socket_path, sizeof sa.sun_path);
	if (size >= sizeof sa.sun_path) {
		errno = ENAMETOOLONG;
		return (-1);
	}
	unlink(sa.sun_path);

	if ((fd = socket(AF_UNIX, SOCK_STREAM, 0)) == -1)
		return (-1);

	mask = umask(S_IXUSR|S_IXGRP|S_IRWXO);
	if (bind(fd, (struct sockaddr *) &sa, sizeof(sa)) == -1) {
		close(fd);
		return (-1);
	}
	umask(mask);

	if (listen(fd, 128) == -1) {
		close(fd);
		return (-1);
	}
	setblocking(fd, 0);

	return (fd);
}

/* Fork new server. */
int
server_start(struct tmuxproc *client, struct event_base *base, int lockfd,
    char *lockfile)
{
	int		 pair[2];
	struct job	*job;
	sigset_t	 set, oldset;

	if (socketpair(AF_UNIX, SOCK_STREAM, PF_UNSPEC, pair) != 0)
		fatal("socketpair failed");

	sigfillset(&set);
	sigprocmask(SIG_BLOCK, &set, &oldset);
	switch (fork()) {
	case -1:
		fatal("fork failed");
	case 0:
		break;
	default:
		sigprocmask(SIG_SETMASK, &oldset, NULL);
		close(pair[1]);
		return (pair[0]);
	}
	close(pair[0]);
	if (daemon(1, 0) != 0)
		fatal("daemon failed");
	proc_clear_signals(client);
	if (event_reinit(base) != 0)
		fatalx("event_reinit failed");
	server_proc = proc_start("server");
	proc_set_signals(server_proc, server_signal);
	sigprocmask(SIG_SETMASK, &oldset, NULL);

	if (log_get_level() > 1)
		tty_create_log();
	if (pledge("stdio rpath wpath cpath fattr unix getpw recvfd proc exec "
	    "tty ps", NULL) != 0)
		fatal("pledge failed");

	RB_INIT(&windows);
	RB_INIT(&all_window_panes);
	TAILQ_INIT(&clients);
	RB_INIT(&sessions);
	RB_INIT(&session_groups);
	key_bindings_init();

	gettimeofday(&start_time, NULL);

	server_fd = server_create_socket();
	if (server_fd == -1)
		fatal("couldn't create socket");
	server_update_socket();
	server_client_create(pair[1]);

	if (lockfd >= 0) {
		unlink(lockfile);
		free(lockfile);
		close(lockfd);
	}

	start_cfg();

	server_add_accept(0);

	proc_loop(server_proc, server_loop);

	LIST_FOREACH(job, &all_jobs, entry) {
		if (job->pid != -1)
			kill(job->pid, SIGTERM);
	}

	status_prompt_save_history();
	exit(0);
}

/* Server loop callback. */
static int
server_loop(void)
{
	struct client	*c;
	u_int		 items;

	do {
		items = cmdq_next(NULL);
		TAILQ_FOREACH(c, &clients, entry) {
			if (c->flags & CLIENT_IDENTIFIED)
				items += cmdq_next(c);
		}
	} while (items != 0);

	server_client_loop();

	if (!options_get_number(global_options, "exit-unattached")) {
		if (!RB_EMPTY(&sessions))
			return (0);
	}

	TAILQ_FOREACH(c, &clients, entry) {
		if (c->session != NULL)
			return (0);
	}

	/*
	 * No attached clients therefore want to exit - flush any waiting
	 * clients but don't actually exit until they've gone.
	 */
	cmd_wait_for_flush();
	if (!TAILQ_EMPTY(&clients))
		return (0);

	return (1);
}

/* Exit the server by killing all clients and windows. */
static void
server_send_exit(void)
{
	struct client	*c, *c1;
	struct session	*s, *s1;

	cmd_wait_for_flush();

	TAILQ_FOREACH_SAFE(c, &clients, entry, c1) {
		if (c->flags & CLIENT_SUSPENDED)
			server_client_lost(c);
		else
			proc_send(c->peer, MSG_SHUTDOWN, -1, NULL, 0);
		c->session = NULL;
	}

	RB_FOREACH_SAFE(s, sessions, &sessions, s1)
		session_destroy(s, __func__);
}

/* Update socket execute permissions based on whether sessions are attached. */
void
server_update_socket(void)
{
	struct session	*s;
	static int	 last = -1;
	int		 n, mode;
	struct stat      sb;

	n = 0;
	RB_FOREACH(s, sessions, &sessions) {
		if (!(s->flags & SESSION_UNATTACHED)) {
			n++;
			break;
		}
	}

	if (n != last) {
		last = n;

		if (stat(socket_path, &sb) != 0)
			return;
		mode = sb.st_mode & ACCESSPERMS;
		if (n != 0) {
			if (mode & S_IRUSR)
				mode |= S_IXUSR;
			if (mode & S_IRGRP)
				mode |= S_IXGRP;
			if (mode & S_IROTH)
				mode |= S_IXOTH;
		} else
			mode &= ~(S_IXUSR|S_IXGRP|S_IXOTH);
		chmod(socket_path, mode);
	}
}

/* Callback for server socket. */
static void
server_accept(int fd, short events, __unused void *data)
{
	struct sockaddr_storage	sa;
	socklen_t		slen = sizeof sa;
	int			newfd;

	server_add_accept(0);
	if (!(events & EV_READ))
		return;

	newfd = accept(fd, (struct sockaddr *) &sa, &slen);
	if (newfd == -1) {
		if (errno == EAGAIN || errno == EINTR || errno == ECONNABORTED)
			return;
		if (errno == ENFILE || errno == EMFILE) {
			/* Delete and don't try again for 1 second. */
			server_add_accept(1);
			return;
		}
		fatal("accept failed");
	}
	if (server_exit) {
		close(newfd);
		return;
	}
	server_client_create(newfd);
}

/*
 * Add accept event. If timeout is nonzero, add as a timeout instead of a read
 * event - used to backoff when running out of file descriptors.
 */
void
server_add_accept(int timeout)
{
	struct timeval tv = { timeout, 0 };

	if (event_initialized(&server_ev_accept))
		event_del(&server_ev_accept);

	if (timeout == 0) {
		event_set(&server_ev_accept, server_fd, EV_READ, server_accept,
		    NULL);
		event_add(&server_ev_accept, NULL);
	} else {
		event_set(&server_ev_accept, server_fd, EV_TIMEOUT,
		    server_accept, NULL);
		event_add(&server_ev_accept, &tv);
	}
}

/* Signal handler. */
static void
server_signal(int sig)
{
	int	fd;

	log_debug("%s: %s", __func__, strsignal(sig));
	switch (sig) {
	case SIGTERM:
		server_exit = 1;
		server_send_exit();
		break;
	case SIGCHLD:
		server_child_signal();
		break;
	case SIGUSR1:
		event_del(&server_ev_accept);
		fd = server_create_socket();
		if (fd != -1) {
			close(server_fd);
			server_fd = fd;
			server_update_socket();
		}
		server_add_accept(0);
		break;
	case SIGUSR2:
		proc_toggle_log(server_proc);
		break;
	}
}

/* Handle SIGCHLD. */
static void
server_child_signal(void)
{
	int	 status;
	pid_t	 pid;

	for (;;) {
		switch (pid = waitpid(WAIT_ANY, &status, WNOHANG|WUNTRACED)) {
		case -1:
			if (errno == ECHILD)
				return;
			fatal("waitpid failed");
		case 0:
			return;
		}
		if (WIFSTOPPED(status))
			server_child_stopped(pid, status);
		else if (WIFEXITED(status) || WIFSIGNALED(status))
			server_child_exited(pid, status);
	}
}

/* Handle exited children. */
static void
server_child_exited(pid_t pid, int status)
{
	struct window		*w, *w1;
	struct window_pane	*wp;
	struct job		*job;

	RB_FOREACH_SAFE(w, windows, &windows, w1) {
		TAILQ_FOREACH(wp, &w->panes, entry) {
			if (wp->pid == pid) {
				wp->status = status;

				log_debug("%%%u exited", wp->id);
				wp->flags |= PANE_EXITED;

				if (window_pane_destroy_ready(wp))
					server_destroy_pane(wp, 1);
				break;
			}
		}
	}

	LIST_FOREACH(job, &all_jobs, entry) {
		if (pid == job->pid) {
			job_died(job, status);	/* might free job */
			break;
		}
	}
}

/* Handle stopped children. */
static void
server_child_stopped(pid_t pid, int status)
{
	struct window		*w;
	struct window_pane	*wp;

	if (WSTOPSIG(status) == SIGTTIN || WSTOPSIG(status) == SIGTTOU)
		return;

	RB_FOREACH(w, windows, &windows) {
		TAILQ_FOREACH(wp, &w->panes, entry) {
			if (wp->pid == pid) {
				if (killpg(pid, SIGCONT) != 0)
					kill(pid, SIGCONT);
			}
		}
	}
}
@


1.174
log
@Move signal code into proc.c.
@
text
@d1 1
a1 1
/* $OpenBSD: server.c,v 1.173 2017/07/09 22:33:09 nicm Exp $ */
d144 1
d149 2
d157 1
a161 1

d169 1
@


1.173
log
@Some extra logging to show why tmux might exit.
@
text
@d1 1
a1 1
/* $OpenBSD: server.c,v 1.172 2017/07/03 08:16:03 nicm Exp $ */
d139 2
a140 1
server_start(struct event_base *base, int lockfd, char *lockfile)
d148 6
a153 2
	server_proc = proc_start("server", base, 1, server_signal);
	if (server_proc == NULL) {
d158 8
@


1.172
log
@Do not close panes until process has exited and any outstanding data
has been written to the pipe-pane event if there is one. GitHub issue 991.
@
text
@d1 1
a1 1
/* $OpenBSD: server.c,v 1.171 2017/06/04 08:25:57 nicm Exp $ */
d252 1
a252 1
		session_destroy(s);
d350 1
@


1.171
log
@Support SIGUSR2 to stop and start logging for an existing server. Also
we currently only have two log levels so just use -v and -vv rather than
-v and -vvvv, and clarify the man page entry for -v.
@
text
@d1 1
a1 1
/* $OpenBSD: server.c,v 1.170 2017/04/22 06:13:30 nicm Exp $ */
d409 6
a414 1
				server_destroy_pane(wp, 1);
@


1.170
log
@Memory leaks, from David CARLIER.
@
text
@d1 1
a1 1
/* $OpenBSD: server.c,v 1.169 2017/04/21 20:26:34 nicm Exp $ */
d154 1
a154 1
	if (log_get_level() > 3)
d367 3
@


1.169
log
@Make the cmd_find_* functions more obvious when looking for a client,
rather than having it inside other functions. Should be no change to the
way targets are resolved just yet.
@
text
@d1 1
a1 1
/* $OpenBSD: server.c,v 1.168 2017/04/21 14:04:54 nicm Exp $ */
d122 2
a123 1
	if (bind(fd, (struct sockaddr *) &sa, sizeof(sa)) == -1)
d125 1
d128 2
a129 1
	if (listen(fd, 128) == -1)
d131 1
@


1.168
log
@History needs to be loaded after config parsing is done - now that
commands are queued, that's in cfg_done not after start_cfg finishes.
@
text
@d1 1
a1 1
/* $OpenBSD: server.c,v 1.167 2017/04/20 09:20:22 nicm Exp $ */
d66 1
a66 1
	cmd_find_clear_state(&marked_pane, NULL, 0);
d77 1
a77 1
	cmd_find_clear_state(&marked_pane, NULL, 0);
@


1.167
log
@If a #() command doesn't exit, use its most recent line of output (it
must be a full line). Don't let it redraw the status line more than once
a second.

Requested by someone about 10 years ago...
@
text
@d1 1
a1 1
/* $OpenBSD: server.c,v 1.166 2017/02/09 15:04:53 nicm Exp $ */
a177 2

	status_prompt_load_history();
@


1.166
log
@Instead of numbering session groups, give them a name which may be given
to -t instead of a target session. Also allow them to contain only one
session.
@
text
@d1 1
a1 1
/* $OpenBSD: server.c,v 1.165 2017/01/24 21:50:22 nicm Exp $ */
d137 2
a138 1
	int	pair[2];
d184 6
d410 1
a410 1
	LIST_FOREACH(job, &all_jobs, lentry) {
@


1.165
log
@Fixed keys for choose mode, and remove the last mode keys bits.
@
text
@d1 1
a1 1
/* $OpenBSD: server.c,v 1.164 2016/11/12 19:04:41 nicm Exp $ */
d159 1
a159 1
	TAILQ_INIT(&session_groups);
@


1.164
log
@Do not execute commands for a client until it has identified, fixes
problem reported by Frank Terbeck.
@
text
@d1 1
a1 1
/* $OpenBSD: server.c,v 1.163 2016/10/16 19:15:02 nicm Exp $ */
a159 1
	mode_key_init_trees();
@


1.163
log
@Notifys can go via the command queue instead of using their own queue.
@
text
@d1 1
a1 1
/* $OpenBSD: server.c,v 1.162 2016/10/16 17:55:14 nicm Exp $ */
d197 4
a200 2
		TAILQ_FOREACH(c, &clients, entry)
		    items += cmdq_next(c);
@


1.162
log
@Rewrite command queue handling. Each client still has a command queue,
but there is also now a global command queue. Instead of command queues
being dispatched on demand from wherever the command happens to be
added, they are now all dispatched from the top level server
loop. Command queues may now also include callbacks as well as commands,
and items may be inserted after the current command as well as at the end.

This all makes command queues significantly more predictable and easier
to use, and avoids the complex multiple nested command queues used by
source-file, if-shell and friends.

A mass rename of struct cmdq to a better name (cmdq_item probably) is
coming.
@
text
@d1 1
a1 1
/* $OpenBSD: server.c,v 1.161 2016/10/15 00:01:01 nicm Exp $ */
a193 2

	notify_drain();
@


1.161
log
@Drain notifys once at the end of the server loop instead of doing it
from the end of every command queue (which could be nested).
@
text
@d1 1
a1 1
/* $OpenBSD: server.c,v 1.160 2016/10/10 21:29:23 nicm Exp $ */
d193 9
a203 1
	notify_drain();
@


1.160
log
@Loads more static, except for cmd-*.c and window-*.c.
@
text
@d1 1
a1 1
/* $OpenBSD: server.c,v 1.159 2016/07/07 09:24:09 semarie Exp $ */
d195 1
@


1.159
log
@tmux: only consider ACCESSPERMS for setting mode on socket_path.

it explicitly removes any S_ISUID|S_ISGID|S_ISTXT bits, instead of letting
pledge(2) silenciously remove them.

ok nicm@@ beck@@ deraadt@@
@
text
@d1 1
a1 1
/* $OpenBSD: server.c,v 1.158 2016/03/30 13:20:07 nicm Exp $ */
d47 3
a49 3
int			 server_fd;
int			 server_exit;
struct event		 server_ev_accept;
d53 8
a60 9
int	server_create_socket(void);
int	server_loop(void);
int	server_should_exit(void);
void	server_send_exit(void);
void	server_accept(int, short, void *);
void	server_signal(int);
void	server_child_signal(void);
void	server_child_exited(pid_t, int);
void	server_child_stopped(pid_t, int);
d101 1
a101 1
int
d189 1
a189 1
int
d218 1
a218 1
void
d275 1
a275 1
void
d328 1
a328 1
void
d355 1
a355 1
void
d378 1
a378 1
void
d404 1
a404 1
void
@


1.158
log
@Bump the listen() backlog up, some people have scripts that run up a lot
of clients quickly.
@
text
@d1 1
a1 1
/* $OpenBSD: server.c,v 1.157 2016/01/19 15:59:12 nicm Exp $ */
d261 1
a261 1
		mode = sb.st_mode;
@


1.157
log
@I no longer use my SourceForge address so replace it.
@
text
@d1 1
a1 1
/* $OpenBSD: server.c,v 1.156 2015/12/16 21:50:37 nicm Exp $ */
d127 1
a127 1
	if (listen(fd, 16) == -1)
@


1.156
log
@Add infrastructure to work out the best target given a pane or window
alone and use it to add pane_died and pane_exited hooks.
@
text
@d1 1
a1 1
/* $OpenBSD: server.c,v 1.155 2015/12/15 00:00:01 nicm Exp $ */
d4 1
a4 1
 * Copyright (c) 2007 Nicholas Marriott <nicm@@users.sourceforge.net>
@


1.155
log
@Make the marked pane a cmd_find_state.
@
text
@d1 1
a1 1
/* $OpenBSD: server.c,v 1.154 2015/11/24 23:01:51 nicm Exp $ */
d390 1
a390 1
				server_destroy_pane(wp);
@


1.154
log
@Do lock failures slightly better, return a special value so we don't
unlink the wrong thing.
@
text
@d1 1
a1 1
/* $OpenBSD: server.c,v 1.153 2015/11/24 21:52:06 nicm Exp $ */
d44 1
a44 1
struct clients	 clients;
d46 6
a51 10
struct tmuxproc	*server_proc;
int		 server_fd;
int		 server_exit;
struct event	 server_ev_accept;

struct session		*marked_session;
struct winlink		*marked_winlink;
struct window		*marked_window;
struct window_pane	*marked_window_pane;
struct layout_cell	*marked_layout_cell;
d67 5
a71 5
	marked_session = s;
	marked_winlink = wl;
	marked_window = wl->window;
	marked_window_pane = wp;
	marked_layout_cell = wp->layout_cell;
d78 1
a78 5
	marked_session = NULL;
	marked_winlink = NULL;
	marked_window = NULL;
	marked_window_pane = NULL;
	marked_layout_cell = NULL;
d87 1
a87 1
	if (marked_session != s || marked_winlink != wl)
d89 1
a89 1
	if (marked_window_pane != wp)
d98 1
a98 19
	struct winlink	*wl;

	if (marked_window_pane == NULL)
		return (0);
	if (marked_layout_cell != marked_window_pane->layout_cell)
		return (0);

	if (!session_alive(marked_session))
		return (0);
	RB_FOREACH(wl, winlinks, &marked_session->windows) {
		if (wl->window == marked_window && wl == marked_winlink)
			break;
	}
	if (wl == NULL)
		return (0);

	if (!window_has_pane(marked_window, marked_window_pane))
		return (0);
	return (window_pane_visible(marked_window_pane));
@


1.153
log
@Remove the -I part of show-messages which isn't really that useful; the
server start time can now be accessed with a new start_time format (use:
tmux display -p '#{t:start_time}')
@
text
@d1 1
a1 1
/* $OpenBSD: server.c,v 1.152 2015/11/24 21:19:46 nicm Exp $ */
d198 5
a202 3
	unlink(lockfile);
	free(lockfile);
	close(lockfd);
@


1.152
log
@Make the log stuff a bit tidier with some helper functions.
@
text
@d1 1
a1 1
/* $OpenBSD: server.c,v 1.151 2015/11/22 19:41:19 nicm Exp $ */
d190 1
a190 1
	start_time = time(NULL);
@


1.151
log
@Add getpw to pledge, makes tmux work in YP environments, discovered by
matthieu, ok deraadt
@
text
@d1 1
a1 1
/* $OpenBSD: server.c,v 1.150 2015/11/18 14:27:44 nicm Exp $ */
d176 1
a176 1
	if (debug_level > 3)
@


1.150
log
@Use __unused rather than rolling our own.
@
text
@d1 1
a1 1
/* $OpenBSD: server.c,v 1.149 2015/11/15 14:32:48 nicm Exp $ */
d178 2
a179 2
	if (pledge("stdio rpath wpath cpath fattr unix recvfd proc exec tty "
	    "ps", NULL) != 0)
@


1.149
log
@Accidentally turned off pledge, turn it back on.
@
text
@d1 1
a1 1
/* $OpenBSD: server.c,v 1.148 2015/11/14 09:41:07 nicm Exp $ */
d301 1
a301 1
server_accept(int fd, short events, unused void *data)
@


1.148
log
@Push stdout and stderr to clients more aggressively, and add an event to
continue if the send fails.
@
text
@d1 1
a1 1
/* $OpenBSD: server.c,v 1.147 2015/11/12 12:19:57 nicm Exp $ */
d178 1
a178 1
	if (0 && pledge("stdio rpath wpath cpath fattr unix recvfd proc exec tty "
@


1.147
log
@Tidy utf8.c a little: build table on first use, and make utf8_width take
a u_int rather than splitting and then combining again in utf8_split.
@
text
@d1 1
a1 1
/* $OpenBSD: server.c,v 1.146 2015/10/31 13:12:03 nicm Exp $ */
d178 1
a178 1
	if (pledge("stdio rpath wpath cpath fattr unix recvfd proc exec tty "
@


1.146
log
@The output log is only useful once and it means creating a file, so open
it once at startup instead of in every call to tty_open.
@
text
@d1 1
a1 1
/* $OpenBSD: server.c,v 1.145 2015/10/27 15:58:42 nicm Exp $ */
a188 1
	utf8_build();
@


1.145
log
@Move struct options into options.c.
@
text
@d1 1
a1 1
/* $OpenBSD: server.c,v 1.144 2015/10/27 13:23:24 nicm Exp $ */
d176 2
@


1.144
log
@Break the common process set up, event loop and imsg dispatch code
between server and client out into a separate internal API. This will
make it easier to add another process.
@
text
@d1 1
a1 1
/* $OpenBSD: server.c,v 1.143 2015/10/23 16:07:29 nicm Exp $ */
d220 1
a220 1
	if (!options_get_number(&global_options, "exit-unattached")) {
@


1.143
log
@tmux can call pledge() in main with large set and then reduce it
slightly in the server to "stdio rpath wpath cpath fattr unix recvfd
proc exec tty ps".
@
text
@d1 1
a1 1
/* $OpenBSD: server.c,v 1.142 2015/10/22 10:48:30 nicm Exp $ */
d46 1
d58 1
a58 1
void	server_loop(void);
d61 2
a62 2
void	server_accept_callback(int, short, void *);
void	server_signal_callback(int, short, void *);
a165 1
	/* The first client is special and gets a socketpair; create it. */
a167 1
	log_debug("starting server");
d169 2
a170 6
	switch (fork()) {
	case -1:
		fatal("fork failed");
	case 0:
		break;
	default:
a179 15
	/*
	 * Must daemonise before loading configuration as the PID changes so
	 * $TMUX would be wrong for sessions created in the config file.
	 */
	if (daemon(1, 0) != 0)
		fatal("daemon failed");

	/* event_init() was called in our parent, need to reinit. */
	clear_signals(0);
	if (event_reinit(base) != 0)
		fatal("event_reinit failed");

	logfile("server");
	log_debug("server started, pid %ld", (long) getpid());

a189 2
	log_debug("socket path %s", socket_path);
	setproctitle("server (%s)", socket_path);
d207 1
a207 2
	set_signals(server_signal_callback);
	server_loop();
d212 2
a213 2
/* Main server loop. */
void
d216 1
a216 8
	while (!server_should_exit()) {
		log_debug("event dispatch enter");
		event_loop(EVLOOP_ONCE);
		log_debug("event dispatch exit");

		server_client_loop();
	}
}
d218 1
a218 5
/* Check if the server should exit (no more clients or sessions). */
int
server_should_exit(void)
{
	struct client	*c;
d251 1
a251 1
		if (c->flags & (CLIENT_BAD|CLIENT_SUSPENDED))
d254 1
a254 1
			server_write_client(c, MSG_SHUTDOWN, NULL, 0);
d300 1
a300 1
server_accept_callback(int fd, short events, unused void *data)
d341 2
a342 2
		event_set(&server_ev_accept,
		    server_fd, EV_READ, server_accept_callback, NULL);
d345 2
a346 2
		event_set(&server_ev_accept,
		    server_fd, EV_TIMEOUT, server_accept_callback, NULL);
d353 1
a353 1
server_signal_callback(int sig, unused short events, unused void *data)
@


1.142
log
@This should not be changed.
@
text
@d1 1
a1 1
/* $OpenBSD: server.c,v 1.141 2015/10/22 10:46:24 nicm Exp $ */
d180 4
@


1.141
log
@Rename shutdown to exit.
@
text
@d1 1
a1 1
/* $OpenBSD: server.c,v 1.140 2015/10/11 00:26:23 guenther Exp $ */
d284 1
a284 1
			server_write_client(c, MSG_EXIT, NULL, 0);
@


1.140
log
@Userspace doesn't need to use SUN_LEN(): connect() and bind() must accept
sizeof(struct sockaddr_un), so do the simple, portable thing

ok beck@@ deraadt@@
@
text
@d1 1
a1 1
/* $OpenBSD: server.c,v 1.139 2015/09/01 10:01:56 nicm Exp $ */
d47 1
a47 1
int		 server_shutdown;
d58 2
a59 2
int	server_should_shutdown(void);
void	server_send_shutdown(void);
d235 1
a235 1
	while (!server_should_shutdown()) {
d246 1
a246 1
server_should_shutdown(void)
d271 1
a271 1
/* Shutdown the server by killing all clients and windows. */
d273 1
a273 1
server_send_shutdown(void)
d284 1
a284 1
			server_write_client(c, MSG_SHUTDOWN, NULL, 0);
d351 1
a351 1
	if (server_shutdown) {
d389 2
a390 2
		server_shutdown = 1;
		server_send_shutdown();
@


1.139
log
@Move initial conf load into cfg.c.
@
text
@d1 1
a1 1
/* $OpenBSD: server.c,v 1.138 2015/08/30 22:19:07 nicm Exp $ */
d148 1
a148 1
	if (bind(fd, (struct sockaddr *) &sa, SUN_LEN(&sa)) == -1)
@


1.138
log
@Event base does not need to be global.
@
text
@d1 1
a1 1
/* $OpenBSD: server.c,v 1.137 2015/08/29 08:54:41 nicm Exp $ */
d163 1
a163 2
	int	 pair[2];
	char	*cause;
d219 2
a220 18
	cfg_cmd_q = cmdq_new(NULL);
	cfg_cmd_q->emptyfn = cfg_default_done;
	cfg_finished = 0;
	cfg_references = 1;
	cfg_client = TAILQ_FIRST(&clients);
	if (cfg_client != NULL)
		cfg_client->references++;

	if (access(TMUX_CONF, R_OK) == 0) {
		if (load_cfg(TMUX_CONF, cfg_cmd_q, &cause) == -1)
			cfg_add_cause("%s: %s", TMUX_CONF, cause);
	} else if (errno != ENOENT)
		cfg_add_cause("%s: %s", TMUX_CONF, strerror(errno));
	if (cfg_file != NULL) {
		if (load_cfg(cfg_file, cfg_cmd_q, &cause) == -1)
			cfg_add_cause("%s: %s", cfg_file, cause);
	}
	cmdq_continue(cfg_cmd_q);
@


1.137
log
@We already loop over the windows in server_client_loop, so don't do it
again in server_loop just to check names.
@
text
@d1 1
a1 1
/* $OpenBSD: server.c,v 1.136 2015/08/29 08:30:54 nicm Exp $ */
d161 1
a161 1
server_start(int lockfd, char *lockfile)
d191 1
a191 1
	if (event_reinit(ev_base) != 0)
@


1.136
log
@Move alerts onto events rather than checking every loop.
@
text
@d1 1
a1 1
/* $OpenBSD: server.c,v 1.135 2015/08/28 13:21:25 nicm Exp $ */
a251 2
	struct window	*w;

d253 1
d255 1
a256 2
		RB_FOREACH(w, windows, &windows)
		    check_window_name(w);
@


1.135
log
@Remove unused prototypes.
@
text
@d1 1
a1 1
/* $OpenBSD: server.c,v 1.134 2015/08/28 13:12:20 nicm Exp $ */
d252 2
d257 2
a258 1
		server_window_loop();
@


1.134
log
@Per-session timers for locking, and remove the global one-second timer.
@
text
@d1 1
a1 1
/* $OpenBSD: server.c,v 1.133 2015/08/28 12:31:55 nicm Exp $ */
a64 2
void	server_second_callback(int, short, void *);
void	server_lock_sessions(void);
@


1.133
log
@Remove the lock-server option which is a bit redundant, it isn't that
different without it.
@
text
@d1 1
a1 1
/* $OpenBSD: server.c,v 1.132 2015/08/28 12:25:42 nicm Exp $ */
a48 1
struct event	 server_ev_second;
d165 2
a166 3
	int	 	 pair[2];
	struct timeval	 tv;
	char		*cause;
a243 5
	memset(&tv, 0, sizeof tv);
	tv.tv_sec = 1;
	evtimer_set(&server_ev_second, server_second_callback, NULL);
	evtimer_add(&server_ev_second, &tv);

a490 34
		}
	}
}

/* Handle once-per-second timer events. */
void
server_second_callback(unused int fd, unused short events, unused void *arg)
{
	struct timeval		 tv;

	server_lock_sessions();

	evtimer_del(&server_ev_second);
	memset(&tv, 0, sizeof tv);
	tv.tv_sec = 1;
	evtimer_add(&server_ev_second, &tv);
}

/* Lock any sessions which have timed out. */
void
server_lock_sessions(void)
{
	struct session  *s;
	int		 timeout;
	time_t		 t;

	t = time(NULL);
	RB_FOREACH(s, sessions, &sessions) {
		if (s->flags & SESSION_UNATTACHED)
			continue;
		timeout = options_get_number(&s->options, "lock-after-time");
		if (timeout > 0 && t > s->activity_time.tv_sec + timeout) {
			server_lock_session(s);
			recalculate_sizes();
@


1.132
log
@Give clock mode its own timer.
@
text
@d1 1
a1 1
/* $OpenBSD: server.c,v 1.131 2015/08/28 12:16:28 nicm Exp $ */
a66 1
void	server_lock_server(void);
d508 1
a508 4
	if (options_get_number(&global_s_options, "lock-server"))
		server_lock_server();
	else
		server_lock_sessions();
a513 21
}

/* Lock the server if ALL sessions have hit the time limit. */
void
server_lock_server(void)
{
	struct session  *s;
	int		 timeout;
	time_t           t;

	t = time(NULL);
	RB_FOREACH(s, sessions, &sessions) {
		if (s->flags & SESSION_UNATTACHED)
			continue;
		timeout = options_get_number(&s->options, "lock-after-time");
		if (timeout <= 0 || t <= s->activity_time.tv_sec + timeout)
			return;	/* not timed out */
	}

	server_lock();
	recalculate_sizes();
@


1.131
log
@Run status update on a per-client timer at status-interval.
@
text
@d1 1
a1 1
/* $OpenBSD: server.c,v 1.130 2015/08/28 11:38:27 nicm Exp $ */
a506 2
	struct window		*w;
	struct window_pane	*wp;
a512 7

	RB_FOREACH(w, windows, &windows) {
		TAILQ_FOREACH(wp, &w->panes, entry) {
			if (wp->mode != NULL && wp->mode->timer != NULL)
				wp->mode->timer(wp);
		}
	}
@


1.130
log
@Move format job cleanup onto its own timer.
@
text
@d1 1
a1 1
/* $OpenBSD: server.c,v 1.129 2015/07/20 15:50:04 nicm Exp $ */
a521 2

	server_client_status_timer();
@


1.129
log
@Add an option (history-file) for a file to save/restore command prompt
history, from Olof-Joachim Frahm.
@
text
@d1 1
a1 1
/* $OpenBSD: server.c,v 1.128 2015/06/05 18:18:32 nicm Exp $ */
a523 2

	format_clean();
@


1.128
log
@Similarly, for sessions use a callback to free rather than checking
every loop.
@
text
@d1 1
a1 1
/* $OpenBSD: server.c,v 1.127 2015/06/05 18:01:12 nicm Exp $ */
d243 1
d254 1
@


1.127
log
@Instead of putting dead clients on a list and checking it every loop,
use event_once to queue a callback to deal with them. Also dead clients
with references would never actually be freed because the wrap-up
functions (the callback for stdin, or status_prompt_clear) would never
be called. So call them in server_client_lost.
@
text
@d1 1
a1 1
/* $OpenBSD: server.c,v 1.126 2015/06/04 11:43:51 nicm Exp $ */
a60 1
void	server_clean_dead(void);
a205 1
	RB_INIT(&dead_sessions);
a264 2

		server_clean_dead();
a313 15
}

/* Free dead, unreferenced clients and sessions. */
void
server_clean_dead(void)
{
	struct session	*s, *s1;

	RB_FOREACH_SAFE(s, sessions, &dead_sessions, s1) {
		if (s->references != 0)
			continue;
		RB_REMOVE(sessions, &dead_sessions, s);
		free(s->name);
		free(s);
	}
@


1.126
log
@Add support for a single "marked pane". There is one marked pane in the
server at a time; it may be toggled or cleared with select-pane -m and
-M (the border is highlighted). A new target '~' or '{marked}' specifies
the marked pane to commands and it is the default target for the
swap-pane and join-pane -s flag (this makes them much simpler to use -
mark the source pane and then change to the target pane to run swapp or
joinp).
@
text
@d1 1
a1 1
/* $OpenBSD: server.c,v 1.125 2015/06/01 09:20:19 nicm Exp $ */
a43 1
/* Client list. */
a44 1
struct clients	 dead_clients;
a205 1
	TAILQ_INIT(&dead_clients);
a324 1
	struct client	*c, *c1;
a331 7
	}

	TAILQ_FOREACH_SAFE(c, &dead_clients, entry, c1) {
		if (c->references != 0)
			continue;
		TAILQ_REMOVE(&dead_clients, c, entry);
		free(c);
@


1.125
log
@Clear signal handlers before event_reinit as apparently it can otherwise
cause libevent to go strange.
@
text
@d1 1
a1 1
/* $OpenBSD: server.c,v 1.124 2015/05/31 23:27:06 deraadt Exp $ */
d53 79
a131 13
int		 server_create_socket(void);
void		 server_loop(void);
int		 server_should_shutdown(void);
void		 server_send_shutdown(void);
void		 server_clean_dead(void);
void		 server_accept_callback(int, short, void *);
void		 server_signal_callback(int, short, void *);
void		 server_child_signal(void);
void		 server_child_exited(pid_t, int);
void		 server_child_stopped(pid_t, int);
void		 server_second_callback(int, short, void *);
void		 server_lock_server(void);
void		 server_lock_sessions(void);
@


1.124
log
@does not need syslog.h
@
text
@d1 1
a1 1
/* $OpenBSD: server.c,v 1.123 2015/05/27 13:28:04 nicm Exp $ */
d132 1
a134 1
	clear_signals(0);
@


1.123
log
@Move the jobs output cache into the formats code so that #() work more
generally (for example, again working in set-titles-string).
@
text
@d1 1
a1 1
/* $OpenBSD: server.c,v 1.122 2015/04/24 23:17:11 nicm Exp $ */
a33 1
#include <syslog.h>
@


1.122
log
@Convert clients list into a TAILQ.
@
text
@d1 1
a1 1
/* $OpenBSD: server.c,v 1.121 2015/04/22 15:30:11 nicm Exp $ */
d487 2
@


1.121
log
@Change the windows array into an RB tree and fix some places where we
were only looking at the first winlink for a window in a session.
@
text
@d1 1
a1 1
/* $OpenBSD: server.c,v 1.120 2015/04/22 15:05:03 nicm Exp $ */
d142 2
a143 2
	ARRAY_INIT(&clients);
	ARRAY_INIT(&dead_clients);
d169 1
a169 1
	cfg_client = ARRAY_FIRST(&clients);
a214 1
	u_int		 i;
d221 2
a222 3
	for (i = 0; i < ARRAY_LENGTH(&clients); i++) {
		c = ARRAY_ITEM(&clients, i);
		if (c != NULL && c->session != NULL)
d231 2
a232 4
	for (i = 0; i < ARRAY_LENGTH(&clients); i++) {
		if (ARRAY_ITEM(&clients, i) != NULL)
			return (0);
	}
d241 2
a242 3
	struct client	*c;
	struct session	*s, *next_s;
	u_int		 i;
d246 6
a251 9
	for (i = 0; i < ARRAY_LENGTH(&clients); i++) {
		c = ARRAY_ITEM(&clients, i);
		if (c != NULL) {
			if (c->flags & (CLIENT_BAD|CLIENT_SUSPENDED))
				server_client_lost(c);
			else
				server_write_client(c, MSG_SHUTDOWN, NULL, 0);
			c->session = NULL;
		}
d254 1
a254 3
	s = RB_MIN(sessions, &sessions);
	while (s != NULL) {
		next_s = RB_NEXT(sessions, &sessions, s);
a255 2
		s = next_s;
	}
d262 2
a263 3
	struct session	*s, *next_s;
	struct client	*c;
	u_int		 i;
d265 6
a270 9
	s = RB_MIN(sessions, &dead_sessions);
	while (s != NULL) {
		next_s = RB_NEXT(sessions, &dead_sessions, s);
		if (s->references == 0) {
			RB_REMOVE(sessions, &dead_sessions, s);
			free(s->name);
			free(s);
		}
		s = next_s;
d273 2
a274 3
	for (i = 0; i < ARRAY_LENGTH(&dead_clients); i++) {
		c = ARRAY_ITEM(&dead_clients, i);
		if (c == NULL || c->references != 0)
d276 1
a276 1
		ARRAY_SET(&dead_clients, i, NULL);
@


1.120
log
@window_index is only used in one place (window_destroy) so inline it there.
@
text
@d1 1
a1 1
/* $OpenBSD: server.c,v 1.119 2015/04/21 22:32:40 nicm Exp $ */
d140 1
a140 1
	ARRAY_INIT(&windows);
d441 1
a441 1
	struct window		*w;
a443 1
	u_int		 	 i;
d445 1
a445 3
	for (i = 0; i < ARRAY_LENGTH(&windows); i++) {
		if ((w = ARRAY_ITEM(&windows, i)) == NULL)
			continue;
a468 1
	u_int			 i;
d473 1
a473 3
	for (i = 0; i < ARRAY_LENGTH(&windows); i++) {
		if ((w = ARRAY_ITEM(&windows, i)) == NULL)
			continue;
a489 1
	u_int		 	 i;
d496 1
a496 5
	for (i = 0; i < ARRAY_LENGTH(&windows); i++) {
		w = ARRAY_ITEM(&windows, i);
		if (w == NULL)
			continue;

@


1.119
log
@Do not die on USR1 if any of the socket parent directories are
missing. Reported by Robin Powell.
@
text
@d1 1
a1 1
/* $OpenBSD: server.c,v 1.118 2014/12/09 19:23:35 nicm Exp $ */
d392 1
@


1.118
log
@Add pane_dead_status for exit status of dead panes.
@
text
@d1 1
a1 1
/* $OpenBSD: server.c,v 1.117 2014/10/27 22:23:47 nicm Exp $ */
d82 1
a82 1
		fatal("socket failed");
d87 1
a87 1
		fatal("socket failed");
d91 1
a91 1
		fatal("bind failed");
d95 1
a95 1
		fatal("listen failed");
a97 2
	server_update_socket();

d156 3
d391 1
d402 6
a407 2
		close(server_fd);
		server_fd = server_create_socket();
@


1.117
log
@Move cfg_causes local into cfg.c and remove struct causelist.
@
text
@d1 1
a1 1
/* $OpenBSD: server.c,v 1.116 2014/09/01 21:58:41 nicm Exp $ */
d444 1
@


1.116
log
@Wake up any clients waiting with the wait-for command when the server
exits.
@
text
@d1 1
a1 1
/* $OpenBSD: server.c,v 1.115 2014/07/21 10:52:48 nicm Exp $ */
a167 1
	ARRAY_INIT(&cfg_causes);
d173 4
a176 8
		if (load_cfg(TMUX_CONF, cfg_cmd_q, &cause) == -1) {
			xasprintf(&cause, "%s: %s", TMUX_CONF, cause);
			ARRAY_ADD(&cfg_causes, cause);
		}
	} else if (errno != ENOENT) {
		xasprintf(&cause, "%s: %s", TMUX_CONF, strerror(errno));
		ARRAY_ADD(&cfg_causes, cause);
	}
d178 2
a179 4
		if (load_cfg(cfg_file, cfg_cmd_q, &cause) == -1) {
			xasprintf(&cause, "%s: %s", cfg_file, cause);
			ARRAY_ADD(&cfg_causes, cause);
		}
@


1.115
log
@lockf is entirely useless and it was a mistake to change to it, go back
to using flock which actually works sensibly. Also always retry the lock
to fix a potential race, and add some extra logging.
@
text
@d1 1
a1 1
/* $OpenBSD: server.c,v 1.114 2014/05/14 06:21:19 nicm Exp $ */
d220 2
a221 1
	u_int	i;
d227 12
d243 1
d254 2
@


1.114
log
@Now that cmdlists are reference counted, there is no need for two-step
deletion via the dead_key_bindings tree. From Keith Amling.
@
text
@d1 1
a1 1
/* $OpenBSD: server.c,v 1.113 2014/04/24 09:14:43 nicm Exp $ */
d114 1
@


1.113
log
@There is no longer a need for a paste_stack struct or for global_buffers
to be global. Move to paste.c.
@
text
@d1 1
a1 1
/* $OpenBSD: server.c,v 1.112 2014/04/17 14:45:49 nicm Exp $ */
a210 1
		key_bindings_clean();
@


1.112
log
@Some more long lines.
@
text
@d1 1
a1 1
/* $OpenBSD: server.c,v 1.111 2013/10/20 17:28:43 nicm Exp $ */
a53 2
struct paste_stack global_buffers;

a147 1
	ARRAY_INIT(&global_buffers);
@


1.111
log
@Do not run any command line command from the client which starts the
server until after the configuration file completes. This prevents it
racing against run-shell or if-shell in .tmux.conf that run in the
background.
@
text
@d1 1
a1 1
/* $OpenBSD: server.c,v 1.110 2013/04/24 10:01:32 nicm Exp $ */
d219 1
a219 1
/* Check if the server should be shutting down (no more clients or sessions). */
@


1.110
log
@Rename global configuration define.
@
text
@d1 1
a1 1
/* $OpenBSD: server.c,v 1.109 2013/03/24 09:54:10 nicm Exp $ */
d171 3
@


1.109
log
@Add a command queue to standardize and simplify commands that call other
commands and allow a command to block execution of subsequent
commands. This allows run-shell and if-shell to be synchronous which has
been much requested.

Each client has a default command queue and commands are consumed one at
a time from it. A command may suspend execution from the queue by
returning CMD_RETURN_WAIT and then resume it by calling cmd_continue() -
for example run-shell does this from the callback that is fired after
the job is freed.

When the command queue becomes empty, command clients are automatically
exited (unless attaching). A callback is also fired - this is used for
nested commands in, for example, if-shell which can block execution of
the client's cmdq until a new cmdq becomes empty.

Also merge all the old error/info/print functions together and lose the
old curclient/cmdclient distinction - a cmdq is bound to one client (or
none if in the configuration file), this is a command client if
c->session is NULL otherwise an attached client.
@
text
@d1 1
a1 1
/* $OpenBSD: server.c,v 1.108 2013/03/22 10:31:22 nicm Exp $ */
d172 3
a174 3
	if (access(SYSTEM_CFG, R_OK) == 0) {
		if (load_cfg(SYSTEM_CFG, cfg_cmd_q, &cause) == -1) {
			xasprintf(&cause, "%s: %s", SYSTEM_CFG, cause);
d178 1
a178 1
		xasprintf(&cause, "%s: %s", SYSTEM_CFG, strerror(errno));
@


1.108
log
@No more lint means no more ARGSUSED.
@
text
@d1 1
a1 1
/* $OpenBSD: server.c,v 1.107 2012/12/06 12:49:13 nicm Exp $ */
d109 3
a111 2
	int	 	pair[2];
	struct timeval	tv;
d166 14
a179 5
	if (access(SYSTEM_CFG, R_OK) == 0)
		load_cfg(SYSTEM_CFG, NULL, &cfg_causes);
	else if (errno != ENOENT) {
		cfg_add_cause(
		    &cfg_causes, "%s: %s", SYSTEM_CFG, strerror(errno));
d181 7
a187 11
	if (cfg_file != NULL)
		load_cfg(cfg_file, NULL, &cfg_causes);

	/*
	 * If there is a session already, put the current window and pane into
	 * more mode.
	 */
	if (!RB_EMPTY(&sessions) && !ARRAY_EMPTY(&cfg_causes))
		show_cfg_causes(RB_MIN(sessions, &sessions));

	cfg_finished = 1;
@


1.107
log
@Fix argument order in a log statement.
@
text
@d1 1
a1 1
/* $OpenBSD: server.c,v 1.106 2012/11/19 10:38:06 nicm Exp $ */
a318 1
/* ARGSUSED */
a371 1
/* ARGSUSED */
a466 1
/* ARGSUSED */
@


1.106
log
@Use a utility function for common code to show errors in config file,
from Thomas Adam.
@
text
@d1 1
a1 1
/* $OpenBSD: server.c,v 1.105 2012/07/10 11:53:01 nicm Exp $ */
d169 1
a169 1
		    &cfg_causes, "%s: %s", strerror(errno), SYSTEM_CFG);
@


1.105
log
@xfree is not particularly helpful, remove it. From Thomas Adam.
@
text
@d1 1
a1 1
/* $OpenBSD: server.c,v 1.104 2012/04/11 06:16:14 nicm Exp $ */
d109 2
a110 5
	struct window_pane	*wp;
	int	 		 pair[2];
	char			*cause;
	struct timeval		 tv;
	u_int			 i;
d178 3
a180 11
	if (!RB_EMPTY(&sessions) && !ARRAY_EMPTY(&cfg_causes)) {
		wp = RB_MIN(sessions, &sessions)->curw->window->active;
		window_pane_set_mode(wp, &window_copy_mode);
		window_copy_init_for_output(wp);
		for (i = 0; i < ARRAY_LENGTH(&cfg_causes); i++) {
			cause = ARRAY_ITEM(&cfg_causes, i);
			window_copy_add(wp, "%s", cause);
			free(cause);
		}
		ARRAY_FREE(&cfg_causes);
	}
@


1.104
log
@Stop accepting new clients for 1 second on EMFILE/ENFILE. Based on
ongoing fixes to other daemons by Theo.
@
text
@d1 1
a1 1
/* $OpenBSD: server.c,v 1.103 2012/03/09 09:57:40 nicm Exp $ */
d165 1
a165 1
	xfree(lockfile);
d188 1
a188 1
			xfree(cause);
d278 2
a279 2
			xfree(s->name);
			xfree(s);
d289 1
a289 1
		xfree(c);
@


1.103
log
@Use a lock file and flock() to serialize server start, avoids problems
when running a bunch of tmux from cron at the same time. Based on a diff
from Tim Ruehsen.
@
text
@d1 1
a1 1
/* $OpenBSD: server.c,v 1.102 2011/03/27 20:27:26 nicm Exp $ */
d194 1
a194 3
	event_set(&server_ev_accept,
	    server_fd, EV_READ|EV_PERSIST, server_accept_callback, NULL);
	event_add(&server_ev_accept, NULL);
d338 1
d346 5
d360 23
d400 1
a400 3
		event_set(&server_ev_accept, server_fd,
		    EV_READ|EV_PERSIST, server_accept_callback, NULL);
		event_add(&server_ev_accept, NULL);
@


1.102
log
@Give each pane created in a tmux server a unique id (starting from 0),
put it in the TMUX_PANE environment variable and accept it as a
target. Suggested by and with testing and tweaks from Ben Boeckel.
@
text
@d1 1
a1 1
/* $OpenBSD: server.c,v 1.101 2011/01/26 00:11:47 nicm Exp $ */
d107 1
a107 1
server_start(void)
d163 4
@


1.101
log
@Use LIST_* not SLIST_*.
@
text
@d1 1
a1 1
/* $OpenBSD: server.c,v 1.100 2011/01/08 01:52:36 nicm Exp $ */
d146 1
@


1.100
log
@Move all calls to fcntl(...O_NONBLOCK) into a function and clear the
flag on the stdio file descriptors before closing them (fixes things
like "tmux ls && cat").
@
text
@d1 1
a1 1
/* $OpenBSD: server.c,v 1.99 2011/01/01 01:12:09 nicm Exp $ */
d418 1
a418 1
	SLIST_FOREACH(job, &all_jobs, lentry) {
@


1.99
log
@Don't reset the activity timer for unattached sessions every second,
this screws up the choice of most-recently-used. Instead, break the time
update into a little function and do it when the session is attached.

Pointed out by joshe@@.
@
text
@d1 1
a1 1
/* $OpenBSD: server.c,v 1.98 2010/12/30 23:16:18 nicm Exp $ */
d77 1
a77 1
	int			fd, mode;
d98 1
a98 5

	if ((mode = fcntl(fd, F_GETFL)) == -1)
		fatal("fcntl failed");
	if (fcntl(fd, F_SETFL, mode|O_NONBLOCK) == -1)
		fatal("fcntl failed");
@


1.98
log
@Change from a per-session stack of buffers to one global stack which is
much more convenient and also simplifies lot of code. This renders
copy-buffer useless and makes buffer-limit now a server option.

By Tiago Cunha.
@
text
@d1 1
a1 1
/* $OpenBSD: server.c,v 1.97 2010/12/21 22:37:59 nicm Exp $ */
d497 1
a497 3
		if (s->flags & SESSION_UNATTACHED) {
			if (gettimeofday(&s->activity_time, NULL) != 0)
				fatal("gettimeofday failed");
a498 2
		}

d518 1
a518 3
		if (s->flags & SESSION_UNATTACHED) {
			if (gettimeofday(&s->activity_time, NULL) != 0)
				fatal("gettimeofday failed");
a519 2
		}

@


1.97
log
@Store sessions in an RB tree by name rather than a list, this is tidier
and allows them to easily be shown sorted in various lists
(list-sessions/choose-sessions).

Keep a session index which is used in a couple of places internally but
make it an ever-increasing number rather than filling in gaps with new
sessions.
@
text
@d1 1
a1 1
/* $OpenBSD: server.c,v 1.96 2010/10/18 20:00:02 nicm Exp $ */
d54 2
d155 1
@


1.96
log
@Merge the before and after attach client code into one in client.c
(instead of two in tmux.c and client.c).
@
text
@d1 1
a1 1
/* $OpenBSD: server.c,v 1.95 2010/10/16 08:31:55 nicm Exp $ */
d150 2
a151 2
	ARRAY_INIT(&sessions);
	ARRAY_INIT(&dead_sessions);
d177 2
a178 2
	if (!ARRAY_EMPTY(&sessions) && !ARRAY_EMPTY(&cfg_causes)) {
		wp = ARRAY_FIRST(&sessions)->curw->window->active;
d226 2
a227 4
		for (i = 0; i < ARRAY_LENGTH(&sessions); i++) {
			if (ARRAY_ITEM(&sessions, i) != NULL)
				return (0);
		}
d241 1
a241 1
	struct session	*s;
d255 5
a259 3
	for (i = 0; i < ARRAY_LENGTH(&sessions); i++) {
		if ((s = ARRAY_ITEM(&sessions, i)) != NULL)
			session_destroy(s);
d267 1
a267 1
	struct session	*s;
d271 9
a279 6
	for (i = 0; i < ARRAY_LENGTH(&dead_sessions); i++) {
		s = ARRAY_ITEM(&dead_sessions, i);
		if (s == NULL || s->references != 0)
			continue;
		ARRAY_SET(&dead_sessions, i, NULL);
		xfree(s);
a295 1
	u_int		 i;
d301 2
a302 3
	for (i = 0; i < ARRAY_LENGTH(&sessions); i++) {
		s = ARRAY_ITEM(&sessions, i);
		if (s != NULL && !(s->flags & SESSION_UNATTACHED)) {
a488 1
	u_int            i;
d493 1
a493 4
	for (i = 0; i < ARRAY_LENGTH(&sessions); i++) {
		if ((s = ARRAY_ITEM(&sessions, i)) == NULL)
			continue;

a513 1
	u_int		 i;
d518 1
a518 4
	for (i = 0; i < ARRAY_LENGTH(&sessions); i++) {
		if ((s = ARRAY_ITEM(&sessions, i)) == NULL)
			continue;

@


1.95
log
@Trying to set FD_CLOEXEC on every fd is a lost cause, just use
closefrom() before exec.
@
text
@d1 1
a1 1
/* $OpenBSD: server.c,v 1.94 2010/09/26 20:43:30 nicm Exp $ */
d109 1
a109 1
server_start(char *path)
d113 1
a113 1
	char			 rpathbuf[MAXPATHLEN], *cause;
a157 4
	socket_path = path;

	if (realpath(socket_path, rpathbuf) == NULL)
		strlcpy(rpathbuf, socket_path, sizeof rpathbuf);
d159 1
a159 1
	setproctitle("server (%s)", rpathbuf);
@


1.94
log
@Two new options:

- server option "exit-unattached" makes the server exit when no clients
  are attached, even if sessions are present;

- session option "destroy-unattached" destroys a session once no clients
  are attached to it.

These are useful for preventing tmux remaining in the background where
it is undesirable and when using tmux as a login shell to keep a limit
on new sessions.
@
text
@d1 1
a1 1
/* $OpenBSD: server.c,v 1.93 2010/09/26 18:51:48 nicm Exp $ */
a99 2
		fatal("fcntl failed");
	if (fcntl(fd, F_SETFD, FD_CLOEXEC) == -1)
@


1.93
log
@Modify the permissions on the socket when adding or removing +x to show
attached sessions, rather than replacing them.
@
text
@d1 1
a1 1
/* $OpenBSD: server.c,v 1.92 2010/08/19 18:29:01 nicm Exp $ */
d225 1
a225 1
/* Check if the server should be shutting down (no more clients or windows). */
d231 5
a235 3
	for (i = 0; i < ARRAY_LENGTH(&sessions); i++) {
		if (ARRAY_ITEM(&sessions, i) != NULL)
			return (0);
@


1.92
log
@Do not call event_del() for signals after fork(), just use sigaction()
directly instead - calling libevent functions after fork() w/o
event_reinit() is a bad idea, even if in this case it was harmless.
@
text
@d1 1
a1 1
/* $OpenBSD: server.c,v 1.91 2010/08/04 19:46:13 deraadt Exp $ */
d299 2
a300 1
	int		 n;
d313 14
a326 4
		if (n != 0)
			chmod(socket_path, S_IRWXU|S_IRWXG);
		else
			chmod(socket_path, S_IRUSR|S_IWUSR|S_IRGRP|S_IWGRP);
@


1.91
log
@switch back to kqueue for now, since (a) kqueue has been fixed to deal
with strange devices and (b) since there appears to be a bull in the
poll code in libevent as well...
requested by nicm who is away
@
text
@d1 1
a1 1
/* $OpenBSD: server.c,v 1.90 2010/07/24 19:25:32 nicm Exp $ */
d144 1
a144 1
	clear_signals();
@


1.90
log
@kqueue(2) is currently broken when used with /dev/null and a few other
devices.

An upcoming fix for some problems with the client stdout/stderr handling
relies on it working, so make tmux force libevent to use poll(2) via
EVENT_NOKQUEUE, until we have fixed kqueue.
@
text
@d1 1
a1 1
/* $OpenBSD: server.c,v 1.89 2010/06/21 00:18:57 nicm Exp $ */
a141 2
	if (setenv("EVENT_NOKQUEUE", "1", 1) != 0)
		fatal("setenv");
a143 1
	unsetenv("EVENT_NOKQUEUE");
@


1.89
log
@Give tmux sockets (but not the containing folder) group
permissions. This allows hardlinks to the sockets to be used more
easily.
@
text
@d1 1
a1 1
/* $OpenBSD: server.c,v 1.88 2010/05/04 17:28:16 nicm Exp $ */
d142 2
d146 1
@


1.88
log
@Put this back in with the initialisation in the right order.
@
text
@d1 1
a1 1
/* $OpenBSD: server.c,v 1.87 2010/05/04 08:48:06 nicm Exp $ */
d89 1
a89 1
	mask = umask(S_IXUSR|S_IRWXG|S_IRWXO);
d313 1
a313 1
			chmod(socket_path, S_IRWXU);
d315 1
a315 1
			chmod(socket_path, S_IRUSR|S_IWUSR);
@


1.87
log
@Revert last change, it appears to be broken somehow.
@
text
@d1 1
a1 1
/* $OpenBSD: server.c,v 1.85 2010/04/06 21:35:44 nicm Exp $ */
a51 3
struct event	 server_ev_sigterm;
struct event	 server_ev_sigusr1;
struct event	 server_ev_sigchld;
d141 5
a166 2
	event_init();

d205 1
a205 1
	server_signal_set();
a341 55
}

/* Set up server signal handling. */
void
server_signal_set(void)
{
	struct sigaction	 sigact;

	memset(&sigact, 0, sizeof sigact);
	sigemptyset(&sigact.sa_mask);
	sigact.sa_flags = SA_RESTART;
	sigact.sa_handler = SIG_IGN;
	if (sigaction(SIGINT, &sigact, NULL) != 0)
		fatal("sigaction failed");
	if (sigaction(SIGPIPE, &sigact, NULL) != 0)
		fatal("sigaction failed");
	if (sigaction(SIGUSR2, &sigact, NULL) != 0)
		fatal("sigaction failed");
	if (sigaction(SIGTSTP, &sigact, NULL) != 0)
		fatal("sigaction failed");
	if (sigaction(SIGHUP, &sigact, NULL) != 0)
		fatal("sigaction failed");

	signal_set(&server_ev_sigchld, SIGCHLD, server_signal_callback, NULL);
	signal_add(&server_ev_sigchld, NULL);
	signal_set(&server_ev_sigterm, SIGTERM, server_signal_callback, NULL);
	signal_add(&server_ev_sigterm, NULL);
	signal_set(&server_ev_sigusr1, SIGUSR1, server_signal_callback, NULL);
	signal_add(&server_ev_sigusr1, NULL);
}

/* Destroy server signal events. */
void
server_signal_clear(void)
{
	struct sigaction	 sigact;

	memset(&sigact, 0, sizeof sigact);
	sigemptyset(&sigact.sa_mask);
	sigact.sa_flags = SA_RESTART;
	sigact.sa_handler = SIG_DFL;
	if (sigaction(SIGINT, &sigact, NULL) != 0)
		fatal("sigaction failed");
	if (sigaction(SIGPIPE, &sigact, NULL) != 0)
		fatal("sigaction failed");
	if (sigaction(SIGUSR2, &sigact, NULL) != 0)
		fatal("sigaction failed");
	if (sigaction(SIGTSTP, &sigact, NULL) != 0)
		fatal("sigaction failed");
	if (sigaction(SIGHUP, &sigact, NULL) != 0)
		fatal("sigaction failed");

	signal_del(&server_ev_sigchld);
	signal_del(&server_ev_sigterm);
	signal_del(&server_ev_sigusr1);
@


1.86
log
@Make signal handler setup/teardown two common functions instead of six,
and reset SIGCHLD after fork to fix problems with some shells. From
Romain Francois.
@
text
@d52 3
a136 6
	/* event_init() was called by the parent, need to reinit. */
	if (event_reinit(ev_base) != 0)
		fatal("event_reinit failed");

	clear_signals();

d165 2
d205 1
a205 1
	set_signals(server_signal_callback);
d342 55
@


1.85
log
@Merge copy mode and output mode, dropping the latter. Idea and code from
Micah Cowan.
@
text
@d1 1
a1 1
/* $OpenBSD: server.c,v 1.84 2010/03/22 19:11:54 nicm Exp $ */
a51 3
struct event	 server_ev_sigterm;
struct event	 server_ev_sigusr1;
struct event	 server_ev_sigchld;
d134 6
a167 2
	event_init();

d206 1
a206 1
	server_signal_set();
a342 55
}

/* Set up server signal handling. */
void
server_signal_set(void)
{
	struct sigaction	 sigact;

	memset(&sigact, 0, sizeof sigact);
	sigemptyset(&sigact.sa_mask);
	sigact.sa_flags = SA_RESTART;
	sigact.sa_handler = SIG_IGN;
	if (sigaction(SIGINT, &sigact, NULL) != 0)
		fatal("sigaction failed");
	if (sigaction(SIGPIPE, &sigact, NULL) != 0)
		fatal("sigaction failed");
	if (sigaction(SIGUSR2, &sigact, NULL) != 0)
		fatal("sigaction failed");
	if (sigaction(SIGTSTP, &sigact, NULL) != 0)
		fatal("sigaction failed");
	if (sigaction(SIGHUP, &sigact, NULL) != 0)
		fatal("sigaction failed");

	signal_set(&server_ev_sigchld, SIGCHLD, server_signal_callback, NULL);
	signal_add(&server_ev_sigchld, NULL);
	signal_set(&server_ev_sigterm, SIGTERM, server_signal_callback, NULL);
	signal_add(&server_ev_sigterm, NULL);
	signal_set(&server_ev_sigusr1, SIGUSR1, server_signal_callback, NULL);
	signal_add(&server_ev_sigusr1, NULL);
}

/* Destroy server signal events. */
void
server_signal_clear(void)
{
	struct sigaction	 sigact;

	memset(&sigact, 0, sizeof sigact);
	sigemptyset(&sigact.sa_mask);
	sigact.sa_flags = SA_RESTART;
	sigact.sa_handler = SIG_DFL;
	if (sigaction(SIGINT, &sigact, NULL) != 0)
		fatal("sigaction failed");
	if (sigaction(SIGPIPE, &sigact, NULL) != 0)
		fatal("sigaction failed");
	if (sigaction(SIGUSR2, &sigact, NULL) != 0)
		fatal("sigaction failed");
	if (sigaction(SIGTSTP, &sigact, NULL) != 0)
		fatal("sigaction failed");
	if (sigaction(SIGHUP, &sigact, NULL) != 0)
		fatal("sigaction failed");

	signal_del(&server_ev_sigchld);
	signal_del(&server_ev_sigterm);
	signal_del(&server_ev_sigusr1);
@


1.84
log
@Nuke unused variable.
@
text
@d1 1
a1 1
/* $OpenBSD$ */
d185 2
a186 1
		window_pane_set_mode(wp, &window_more_mode);
d189 1
a189 1
			window_more_add(wp, "%s", cause);
@


1.83
log
@Use the array.h code for the causes list.
@
text
@d1 1
a1 1
/* $OpenBSD: server.c,v 1.82 2010/02/06 17:15:33 nicm Exp $ */
d117 1
a117 1
	int	 		 pair[2], retval;
a169 1
	retval = 0;
@


1.82
log
@Instead of bailing out on the first configuration file error, carry on,
collecting all the errors, then start with the active window in more mode
displaying them.
@
text
@d1 1
a1 1
/* $OpenBSD: server.c,v 1.81 2010/01/30 19:05:18 nicm Exp $ */
d118 1
a118 1
	char			 rpathbuf[MAXPATHLEN];
d172 1
a172 1
		load_cfg(SYSTEM_CFG, NULL, &cfg_ncauses, &cfg_causes);
d174 2
a175 2
		cfg_add_cause(&cfg_ncauses, &cfg_causes,
		    "%s: %s", strerror(errno), SYSTEM_CFG);
d178 1
a178 1
		load_cfg(cfg_file, NULL, &cfg_ncauses, &cfg_causes);
d184 1
a184 1
	if (!ARRAY_EMPTY(&sessions) && cfg_ncauses != 0) {
d187 4
a190 3
		for (i = 0; i < cfg_ncauses; i++) {
			window_more_add(wp, "%s", cfg_causes[i]);
			xfree(cfg_causes[i]);
d192 1
a192 2
		xfree(cfg_causes);
		cfg_ncauses = 0;
@


1.81
log
@Ignore SIGHUP as well.
@
text
@d1 1
a1 1
/* $OpenBSD: server.c,v 1.80 2009/12/03 22:50:10 nicm Exp $ */
d116 5
a120 4
	struct client	*c;
	int		 pair[2];
	char		*cause, rpathbuf[MAXPATHLEN];
	struct timeval	 tv;
d170 6
a175 6
	if (access(SYSTEM_CFG, R_OK) == 0) {
		if (load_cfg(SYSTEM_CFG, NULL, &cause) != 0)
			goto error;
	} else if (errno != ENOENT) {
		xasprintf(&cause, "%s: %s", strerror(errno), SYSTEM_CFG);
		goto error;
d177 18
a194 2
	if (cfg_file != NULL && load_cfg(cfg_file, NULL, &cause) != 0)
		goto error;
a207 14

error:
	/* Write the error and shutdown the server. */
	c = ARRAY_FIRST(&clients);

	server_write_error(c, cause);
	server_write_client(c, MSG_EXIT, NULL, 0);
	xfree(cause);

	server_shutdown = 1;

	server_signal_set();
	server_loop();
	exit(1);
@


1.80
log
@Massive spaces->tabs and trailing whitespace cleanup, hopefully for the last
time now I've configured emacs to make them displayed in really annoying
colours...
@
text
@d1 1
a1 1
/* $OpenBSD: server.c,v 1.79 2009/12/02 15:06:14 nicm Exp $ */
d359 2
d387 2
@


1.79
log
@Close the pane if the process died due to a signal, not just if it exited
normally.
@
text
@d1 1
a1 1
/* $OpenBSD: server.c,v 1.78 2009/11/26 21:37:13 nicm Exp $ */
d219 1
a219 1
	} 
d457 1
a457 1
	}		
d557 1
a557 1
        struct session  *s;
@


1.78
log
@Remove a couple of unused arguments where possible, and add /* ARGSUSED */ to
the rest to reduce lint output.
@
text
@d1 1
a1 1
/* $OpenBSD: server.c,v 1.77 2009/11/13 17:33:07 nicm Exp $ */
d434 1
a434 1
		else if (WIFEXITED(status))
@


1.77
log
@Destroy panes immediately rather than checking them all every loop.
@
text
@d1 1
a1 1
/* $OpenBSD: server.c,v 1.76 2009/11/11 13:24:42 nicm Exp $ */
d317 1
d393 1
d491 1
@


1.76
log
@Free the pane bufferevent when the fd is closed (the signal could come before
the error callback).
@
text
@d1 1
a1 1
/* $OpenBSD: server.c,v 1.75 2009/11/11 08:00:42 nicm Exp $ */
a337 1

d451 2
a452 3
				close(wp->fd);
				bufferevent_free(wp->event);
				wp->fd = -1;
@


1.75
log
@Only need to chmod +x or -x the socket when a client is created, lost or
attached, rather than every event loop.
@
text
@d1 1
a1 1
/* $OpenBSD: server.c,v 1.74 2009/11/05 08:50:32 nicm Exp $ */
d453 1
@


1.74
log
@EVLOOP_ONCE takes care of the wakeup, so no need to call event_loopexit(NULL).
@
text
@d1 1
a1 1
/* $OpenBSD: server.c,v 1.73 2009/11/05 08:48:15 nicm Exp $ */
a61 1
int		 server_update_socket(void);
d107 2
a211 2
		server_update_socket();

d290 1
a290 1
int
a313 2

	return (n);
@


1.73
log
@Now all timers are events, there is no longer any need to wake up every 50 ms -
only wake up when an event happens.
@
text
@d1 1
a1 1
/* $OpenBSD: server.c,v 1.72 2009/11/04 23:42:51 nicm Exp $ */
a212 1
		event_loopexit(NULL);
@


1.72
log
@Move status timer check into the global once-per-second timer, this could maybe
be done better but one every second is better than once every 50 ms.
@
text
@d1 1
a1 1
/* $OpenBSD: server.c,v 1.71 2009/11/04 23:12:43 nicm Exp $ */
a209 5
	struct timeval	tv;

	memset(&tv, 0, sizeof tv);
	tv.tv_usec = POLL_TIMEOUT * 1000;

d213 1
a213 1
		event_loopexit(&tv);
@


1.71
log
@Don't reenlist the client imsg event every loop, instead have a small function
to it and call it after the event triggers or after a imsg is added.
@
text
@d1 1
a1 1
/* $OpenBSD: server.c,v 1.70 2009/11/04 22:47:34 nicm Exp $ */
d522 2
@


1.70
log
@Tell the client to exit on configuration file error.
@
text
@d1 1
a1 1
/* $OpenBSD: server.c,v 1.69 2009/11/04 22:43:11 nicm Exp $ */
d163 2
a167 2
	event_init();

a216 2

		server_client_prepare();
@


1.69
log
@Convert the window pane (pty master side) fd over to use a bufferevent.

The evbuffer API is very similar to the existing tmux buffer API so this was
remarkably painless. Not many possible ways to do it, I suppose.
@
text
@d1 1
a1 1
/* $OpenBSD: server.c,v 1.68 2009/11/04 22:40:36 nicm Exp $ */
d196 1
@


1.68
log
@Call event_init() before loading the config file, since potentially it could
set up events.
@
text
@d1 1
a1 1
/* $OpenBSD: server.c,v 1.67 2009/11/04 21:04:43 nicm Exp $ */
a216 1
		server_window_prepare();
@


1.67
log
@Switch jobs over to use a bufferevent.
@
text
@d1 1
a1 1
/* $OpenBSD: server.c,v 1.66 2009/11/04 20:50:11 nicm Exp $ */
d166 2
a176 2

	event_init();
@


1.66
log
@Initial changes to move tmux to libevent.

This moves the client-side loops are pretty much fully over to event-based only
(tmux.c and client.c) but server-side (server.c and friends) treats libevent as
a sort of clever poll, waking up after every event to run various things.

Moving the server stuff over to bufferevents and timers and so on will come
later.
@
text
@d1 1
a1 1
/* $OpenBSD: server.c,v 1.65 2009/11/03 20:29:47 nicm Exp $ */
a216 1
		server_job_prepare();
a222 1
		server_job_loop();
d471 2
a472 2
			job->pid = -1;
			job->status = status;
@


1.65
log
@Change session and client activity and creation time members to have more
meaningful names.

Also, remove the code to try and update the session activity time for the
command client when a command message is received as is pointless because it
des not have a session.
@
text
@d1 1
a1 1
/* $OpenBSD: server.c,v 1.64 2009/11/02 12:48:44 nicm Exp $ */
d27 1
d49 7
a55 19
/* Mapping of a pollfd to an fd independent of its position in the array. */
struct poll_item {
	int	 fd;
	int	 events;

	void	 (*fn)(int, int, void *);
	void	*data;

	RB_ENTRY(poll_item) entry;
};
RB_HEAD(poll_items, poll_item) poll_items;

int		 server_poll_cmp(struct poll_item *, struct poll_item *);
struct poll_item*server_poll_lookup(int);
struct pollfd	*server_poll_flatten(int *);
void		 server_poll_dispatch(struct pollfd *, int);
void		 server_poll_reset(void);
RB_PROTOTYPE(poll_items, poll_item, entry, server_poll_cmp);
RB_GENERATE(poll_items, poll_item, entry, server_poll_cmp);
d58 1
a58 3
void		 server_callback(int, int, void *);
int		 server_main(int);
void		 server_shutdown(void);
d60 5
d66 3
a68 2
void		 server_clean_dead(void);
void		 server_second_timers(void);
a70 76
int		 server_update_socket(void);

int
server_poll_cmp(struct poll_item *pitem1, struct poll_item *pitem2)
{
	return (pitem1->fd - pitem2->fd);
}

void
server_poll_add(int fd, int events, void (*fn)(int, int, void *), void *data)
{
	struct poll_item	*pitem;

	pitem = xmalloc(sizeof *pitem);
	pitem->fd = fd;
	pitem->events = events;

	pitem->fn = fn;
	pitem->data = data;

	RB_INSERT(poll_items, &poll_items, pitem);
}

struct poll_item *
server_poll_lookup(int fd)
{
	struct poll_item	pitem;

	pitem.fd = fd;
	return (RB_FIND(poll_items, &poll_items, &pitem));
}

struct pollfd *
server_poll_flatten(int *nfds)
{
	struct poll_item	*pitem;
	struct pollfd		*pfds;

	pfds = NULL;
	*nfds = 0;
	RB_FOREACH(pitem, poll_items, &poll_items) {
		pfds = xrealloc(pfds, (*nfds) + 1, sizeof *pfds);
		pfds[*nfds].fd = pitem->fd;
		pfds[*nfds].events = pitem->events;
		(*nfds)++;
	}
	return (pfds);
}

void
server_poll_dispatch(struct pollfd *pfds, int nfds)
{
	struct poll_item	*pitem;
	struct pollfd		*pfd;

	while (nfds > 0) {
		pfd = &pfds[--nfds];
		if (pfd->revents != 0) {
			pitem = server_poll_lookup(pfd->fd);
			pitem->fn(pitem->fd, pfd->revents, pitem->data);
		}
	}
	xfree(pfds);
}

void
server_poll_reset(void)
{
	struct poll_item	*pitem;

	while (!RB_EMPTY(&poll_items)) {
		pitem = RB_ROOT(&poll_items);
		RB_REMOVE(poll_items, &poll_items, pitem);
		xfree(pitem);
	}
}
a110 26
/* Callback for server socket. */
void
server_callback(int fd, int events, unused void *data)
{
	struct sockaddr_storage	sa;
	socklen_t		slen = sizeof sa;
	int			newfd;

	if (events & (POLLERR|POLLNVAL|POLLHUP))
		fatalx("lost server socket");
	if (!(events & POLLIN))
		return;

	newfd = accept(fd, (struct sockaddr *) &sa, &slen);
	if (newfd == -1) {
		if (errno == EAGAIN || errno == EINTR || errno == ECONNABORTED)
			return;
		fatal("accept failed");
	}
	if (sigterm) {
		close(newfd);
		return;
	}
	server_client_create(newfd);
}

d116 3
a118 3
	int		 pair[2], srv_fd;
	char		*cause;
	char		 rpathbuf[MAXPATHLEN];
d163 1
a163 1
	srv_fd = server_create_socket();
d176 14
a189 1
	exit(server_main(srv_fd));
d198 1
a198 2
	sigterm = 1;
	server_shutdown();
d200 3
a202 1
	exit(server_main(srv_fd));
d206 2
a207 2
int
server_main(int srv_fd)
d209 1
a209 19
	struct pollfd	*pfds;
	int		 nfds, xtimeout;
	u_int		 i;
	time_t		 now, last;

	siginit();
	log_debug("server socket is %d", srv_fd);

	last = time(NULL);

	pfds = NULL;
	for (;;) {
		/* If sigterm, kill all windows and clients. */
		if (sigterm)
			server_shutdown();

		/* Stop if no sessions or clients left. */
		if (server_should_shutdown())
			break;
d211 2
a212 6
		/* Handle child exit. */
		if (sigchld) {
			sigchld = 0;
			server_child_signal();
			continue;
		}
d214 2
a215 7
		/* Recreate socket on SIGUSR1. */
		if (sigusr1) {
			sigusr1 = 0;
			close(srv_fd);
			srv_fd = server_create_socket();
			continue;
		}
a216 5
		/* Initialise pollfd array and add server socket. */
		server_poll_reset();
		server_poll_add(srv_fd, POLLIN, server_callback, NULL);

		/* Fill window and client sockets. */
a219 14
		
		/* Update socket permissions. */
		xtimeout = INFTIM;
		if (server_update_socket() != 0)
			xtimeout = POLL_TIMEOUT;

		/* Do the poll. */
		pfds = server_poll_flatten(&nfds);
		if (poll(pfds, nfds, xtimeout) == -1) {
			if (errno == EAGAIN || errno == EINTR)
				continue;
			fatal("poll failed");
		}
		server_poll_dispatch(pfds, nfds);
d221 2
a222 6
		/* Call second-based timers. */
		now = time(NULL);
		if (now != last) {
			last = now;
			server_second_timers();
		}
a223 1
		/* Run once-per-loop events. */
a227 1
		/* Collect any unset key bindings. */
d229 3
d233 5
a237 4
		/* Collect dead clients and sessions. */
		server_clean_dead();
	}
	server_poll_reset();
d241 1
a241 1
			session_destroy(ARRAY_ITEM(&sessions, i));
a242 2
	ARRAY_FREE(&sessions);

d245 1
a245 1
			server_client_lost(ARRAY_ITEM(&clients, i));
d247 1
a247 14
	ARRAY_FREE(&clients);

	mode_key_free_trees();
	key_bindings_free();

	close(srv_fd);

	unlink(socket_path);
	xfree(socket_path);

	options_free(&global_s_options);
	options_free(&global_w_options);

	return (0);
d250 1
a250 1
/* Kill all clients. */
d252 1
a252 1
server_shutdown(void)
d254 1
d256 1
a256 2
	struct client	*c;
	u_int		 i, j;
d265 1
d270 1
a270 9
		s = ARRAY_ITEM(&sessions, i);
		for (j = 0; j < ARRAY_LENGTH(&clients); j++) {
			c = ARRAY_ITEM(&clients, j);
			if (c != NULL && c->session == s) {
				s = NULL;
				break;
			}
		}
		if (s != NULL)
d275 26
a300 1
/* Check if the server should be shutting down (no more clients or windows). */
d302 1
a302 1
server_should_shutdown(void)
d304 4
a307 1
	u_int	i;
d309 1
d311 38
a348 2
		if (ARRAY_ITEM(&sessions, i) != NULL)
			return (0);
d350 75
a424 3
	for (i = 0; i < ARRAY_LENGTH(&clients); i++) {
		if (ARRAY_ITEM(&clients, i) != NULL)
			return (0);
a425 1
	return (1);
d432 2
a433 6
	struct window		*w;
	struct window_pane	*wp;
	struct job		*job;
	int		 	 status;
	pid_t		 	 pid;
	u_int		 	 i;
d444 23
a466 6
		if (!WIFSTOPPED(status)) {
			SLIST_FOREACH(job, &all_jobs, lentry) {
				if (pid == job->pid) {
					job->pid = -1;
					job->status = status;
				}
a467 1
			continue;
d469 1
a469 2
		if (WSTOPSIG(status) == SIGTTIN || WSTOPSIG(status) == SIGTTOU)
			continue;
d471 4
a474 10
		for (i = 0; i < ARRAY_LENGTH(&windows); i++) {
			w = ARRAY_ITEM(&windows, i);
			if (w == NULL)
				continue;
			TAILQ_FOREACH(wp, &w->panes, entry) {
				if (wp->pid == pid) {
					if (killpg(pid, SIGCONT) != 0)
						kill(pid, SIGCONT);
				}
			}
d479 1
a479 1
/* Free dead, unreferenced clients and sessions. */
d481 1
a481 1
server_clean_dead(void)
d483 3
a485 3
	struct session	*s;
	struct client	*c;
	u_int		 i;
d487 2
a488 7
	for (i = 0; i < ARRAY_LENGTH(&dead_sessions); i++) {
		s = ARRAY_ITEM(&dead_sessions, i);
		if (s == NULL || s->references != 0)
			continue;
		ARRAY_SET(&dead_sessions, i, NULL);
		xfree(s);
	}
d490 2
a491 3
	for (i = 0; i < ARRAY_LENGTH(&dead_clients); i++) {
		c = ARRAY_ITEM(&dead_clients, i);
		if (c == NULL || c->references != 0)
d493 6
a498 2
		ARRAY_SET(&dead_clients, i, NULL);
		xfree(c);
d502 1
a502 1
/* Call any once-per-second timers. */
d504 1
a504 1
server_second_timers(void)
d508 1
d526 5
a587 29
}

/* Update socket execute permissions based on whether sessions are attached. */
int
server_update_socket(void)
{
	struct session	*s;
	u_int		 i;
	static int	 last = -1;
	int		 n;

	n = 0;
	for (i = 0; i < ARRAY_LENGTH(&sessions); i++) {
		s = ARRAY_ITEM(&sessions, i);
		if (s != NULL && !(s->flags & SESSION_UNATTACHED)) {
			n++;
			break;
		}
	}

	if (n != last) {
		last = n;
		if (n != 0)
			chmod(socket_path, S_IRWXU);
		else
			chmod(socket_path, S_IRUSR|S_IWUSR);
	}

	return (n);
@


1.64
log
@Reorder slightly to tidy code.
@
text
@d1 1
a1 1
/* $OpenBSD: server.c,v 1.63 2009/10/27 13:03:33 nicm Exp $ */
d568 2
a569 1
			s->activity = time(NULL);
d574 1
a574 1
		if (timeout <= 0 || t <= s->activity + timeout)
d597 2
a598 1
			s->activity = time(NULL);
d603 1
a603 1
		if (timeout > 0 && t > s->activity + timeout) {
@


1.63
log
@Move the poll registration functions into the server-*.c files.
@
text
@d1 1
a1 1
/* $OpenBSD: server.c,v 1.62 2009/10/26 21:42:04 deraadt Exp $ */
d275 2
a276 4
	if (access(SYSTEM_CFG, R_OK) != 0) {
		if (errno != ENOENT) {
			xasprintf(
			    &cause, "%s: %s", strerror(errno), SYSTEM_CFG);
d278 2
a279 2
		}
	} else if (load_cfg(SYSTEM_CFG, NULL, &cause) != 0)
d281 1
@


1.62
log
@tabs are better; ok nicm
@
text
@d1 1
a1 1
/* $OpenBSD: server.c,v 1.61 2009/10/26 21:38:18 nicm Exp $ */
a61 1
void		 server_poll_add(int, int, void (*)(int, int, void *), void *);
a73 3
void		 server_fill_windows(void);
void		 server_fill_clients(void);
void		 server_fill_jobs(void);
d345 4
a348 4
		server_fill_jobs();
		server_fill_windows();
		server_fill_clients();

a500 79
	}
}

/* Fill window pollfds. */
void
server_fill_windows(void)
{
	struct window		*w;
	struct window_pane	*wp;
	u_int		 	 i;
	int			 events;

	for (i = 0; i < ARRAY_LENGTH(&windows); i++) {
		w = ARRAY_ITEM(&windows, i);
		if (w == NULL)
			continue;

		TAILQ_FOREACH(wp, &w->panes, entry) {	
			if (wp->fd == -1)
				continue;
			events = POLLIN;
			if (BUFFER_USED(wp->out) > 0)
				events |= POLLOUT;
			server_poll_add(
			    wp->fd, events, server_window_callback, wp);

			if (wp->pipe_fd == -1)
				continue;
			events = 0;
			if (BUFFER_USED(wp->pipe_buf) > 0)
				events |= POLLOUT;
			server_poll_add(
			    wp->pipe_fd, events, server_window_callback, wp);
		}
	}
}

/* Fill client pollfds. */
void
server_fill_clients(void)
{
	struct client	*c;
	u_int		 i;
	int		 events;

	for (i = 0; i < ARRAY_LENGTH(&clients); i++) {
		c = ARRAY_ITEM(&clients, i);

		if (c != NULL) {
			events = 0;
			if (!(c->flags & CLIENT_BAD))
				events |= POLLIN;
			if (c->ibuf.w.queued > 0)
				events |= POLLOUT;
			server_poll_add(
			    c->ibuf.fd, events, server_client_callback, c);
		}

		if (c != NULL && !(c->flags & CLIENT_SUSPENDED) &&
		    c->tty.fd != -1 && c->session != NULL) {
			events = POLLIN;
			if (BUFFER_USED(c->tty.out) > 0)
				events |= POLLOUT;
			server_poll_add(
			    c->tty.fd, events, server_client_callback, c);
		}
	}
}

/* Fill in job fds. */
void
server_fill_jobs(void)
{
	struct job	*job;

	SLIST_FOREACH(job, &all_jobs, lentry) {
		if (job->fd == -1)
			continue;
		server_poll_add(job->fd, POLLIN, server_job_callback, job);
@


1.61
log
@Clear signal flags /before/ taking action and continue afterwards to reduce
chance of dropping signals. Pointed out by deraadt@@.
@
text
@d1 1
a1 1
/* $OpenBSD: server.c,v 1.60 2009/10/22 19:41:51 nicm Exp $ */
d670 1
a670 1
        u_int            i;
d672 1
a672 1
        time_t           t;
d674 2
a675 2
        t = time(NULL);
        for (i = 0; i < ARRAY_LENGTH(&sessions); i++) {
@


1.60
log
@Split the server code handling clients, jobs and windows off into separate
files from server.c (merging server-msg.c into the client file) and rather than
iterating over each set after poll(), allow a callback to be specified when the
fd is added and just walk once over the returned pollfds calling each callback
where needed.

More to come, getting this in so it is tested.
@
text
@d1 1
a1 1
/* $OpenBSD: server.c,v 1.59 2009/10/13 06:14:08 nicm Exp $ */
d331 1
d333 1
a333 1
			sigchld = 0;
d338 1
d341 1
a341 1
			sigusr1 = 0;
@


1.59
log
@When a session is unattached, reset its activity timer to prevent it locking
instantly when reattached.
@
text
@d1 1
a1 1
/* $OpenBSD: server.c,v 1.58 2009/10/12 09:29:58 nicm Exp $ */
d50 5
a54 1
	struct pollfd	 pfd;
d61 2
a62 2
struct pollfd	*server_poll_lookup(int);
void		 server_poll_add(int, int);
d64 1
a64 1
void		 server_poll_parse(struct pollfd *);
a68 1
void		 server_create_client(int);
d70 1
a75 1
void		 server_handle_windows(void);
a76 1
void		 server_handle_clients(void);
a77 9
void		 server_handle_jobs(void);
void		 server_accept_client(int);
void		 server_handle_client(struct client *);
void		 server_handle_window(struct window *, struct window_pane *);
int		 server_check_window_bell(struct session *, struct window *);
int		 server_check_window_activity(struct session *,
		      struct window *);
int		 server_check_window_content(struct session *, struct window *,
		      struct window_pane *);
d79 1
a79 6
void		 server_lost_client(struct client *);
void	 	 server_check_window(struct window *);
void		 server_check_redraw(struct client *);
void		 server_set_title(struct client *);
void		 server_check_timers(struct client *);
void		 server_check_jobs(void);
a81 2
void		 server_check_clients(void);
void		 server_second_timers(void);
d87 1
a87 1
	return (pitem1->pfd.fd - pitem2->pfd.fd);
d90 2
a91 2
struct pollfd *
server_poll_lookup(int fd)
d93 8
a100 1
	struct poll_item	pitem;
d102 1
a102 2
	pitem.pfd.fd = fd;
	return (&RB_FIND(poll_items, &poll_items, &pitem)->pfd);
d105 2
a106 2
void
server_poll_add(int fd, int events)
d108 1
a108 1
	struct poll_item	*pitem;
d110 2
a111 4
	pitem = xmalloc(sizeof *pitem);
	pitem->pfd.fd = fd;
	pitem->pfd.events = events;
	RB_INSERT(poll_items, &poll_items, pitem);
d124 2
a125 2
		pfds[*nfds].fd = pitem->pfd.fd;
		pfds[*nfds].events = pitem->pfd.events;
d132 1
a132 1
server_poll_parse(struct pollfd *pfds)
d135 1
a135 1
	int			 nfds;
d137 6
a142 4
	nfds = 0;
	RB_FOREACH(pitem, poll_items, &poll_items) {
		pitem->pfd.revents = pfds[nfds].revents;
		nfds++;
d159 3
a161 3
/* Create a new client. */
void
server_create_client(int fd)
d163 24
a186 3
	struct client	*c;
	int		 mode;
	u_int		 i;
d195 15
a209 24
	c = xcalloc(1, sizeof *c);
	c->references = 0;
	imsg_init(&c->ibuf, fd);
	
	if (gettimeofday(&c->tv, NULL) != 0)
		fatal("gettimeofday failed");

	ARRAY_INIT(&c->prompt_hdata);

	c->tty.fd = -1;
	c->title = NULL;

	c->session = NULL;
	c->tty.sx = 80;
	c->tty.sy = 24;

	screen_init(&c->status, c->tty.sx, 1, 0);
	job_tree_init(&c->status_jobs);

	c->message_string = NULL;

	c->prompt_string = NULL;
	c->prompt_buffer = NULL;
	c->prompt_index = 0;
d211 3
a213 3
	for (i = 0; i < ARRAY_LENGTH(&clients); i++) {
		if (ARRAY_ITEM(&clients, i) == NULL) {
			ARRAY_SET(&clients, i, c);
d215 5
a219 1
		}
d221 1
a221 2
	ARRAY_ADD(&clients, c);
	log_debug("new client %d", fd);
d277 1
a277 1
	server_create_client(pair[1]);
a304 39
/* Create server socket. */
int
server_create_socket(void)
{
	struct sockaddr_un	sa;
	size_t			size;
	mode_t			mask;
	int			fd, mode;

	memset(&sa, 0, sizeof sa);
	sa.sun_family = AF_UNIX;
	size = strlcpy(sa.sun_path, socket_path, sizeof sa.sun_path);
	if (size >= sizeof sa.sun_path) {
		errno = ENAMETOOLONG;
		fatal("socket failed");
	}
	unlink(sa.sun_path);

	if ((fd = socket(AF_UNIX, SOCK_STREAM, 0)) == -1)
		fatal("socket failed");

	mask = umask(S_IXUSR|S_IRWXG|S_IRWXO);
	if (bind(fd, (struct sockaddr *) &sa, SUN_LEN(&sa)) == -1)
		fatal("bind failed");
	umask(mask);

	if (listen(fd, 16) == -1)
		fatal("listen failed");

	if ((mode = fcntl(fd, F_GETFL)) == -1)
		fatal("fcntl failed");
	if (fcntl(fd, F_SETFL, mode|O_NONBLOCK) == -1)
		fatal("fcntl failed");
	if (fcntl(fd, F_SETFD, FD_CLOEXEC) == -1)
		fatal("fcntl failed");

	return (fd);
}

d309 1
a309 1
	struct pollfd	*pfds, *pfd;
a341 4
		/* Collect any jobs that have died and process clients. */
		server_check_jobs();
		server_check_clients();

d344 1
a344 1
		server_poll_add(srv_fd, POLLIN);
d363 1
a363 10
		server_poll_parse(pfds);

		/* Handle server socket. */
		pfd = server_poll_lookup(srv_fd);
		if (pfd->revents & (POLLERR|POLLNVAL|POLLHUP))
			fatalx("lost server socket");
		if (pfd->revents & POLLIN) {
			server_accept_client(srv_fd);
			continue;
		}
d372 4
a375 7
		/* Set window names. */
		set_window_names();

		/* Handle window and client sockets. */
		server_handle_jobs();
		server_handle_windows();
		server_handle_clients();
d393 1
a393 1
			server_lost_client(ARRAY_ITEM(&clients, i));
d423 1
a423 1
				server_lost_client(c);
d526 2
a527 1
			server_poll_add(wp->fd, events);
d534 2
a535 39
			server_poll_add(wp->pipe_fd, events);
		}
	}
}

/* Handle window pollfds. */
void
server_handle_windows(void)
{
	struct window		*w;
	struct window_pane	*wp;
	struct pollfd		*pfd;
	u_int		 	 i;

	for (i = 0; i < ARRAY_LENGTH(&windows); i++) {
		w = ARRAY_ITEM(&windows, i);
		if (w == NULL)
			continue;

		TAILQ_FOREACH(wp, &w->panes, entry) {
			if (wp->fd == -1)
				continue;
			if ((pfd = server_poll_lookup(wp->fd)) == NULL)
				continue;
			if (buffer_poll(pfd, wp->in, wp->out) != 0) {
				close(wp->fd);
				wp->fd = -1;
			} else
				server_handle_window(w, wp);

			if (wp->pipe_fd == -1)
				continue;
			if ((pfd = server_poll_lookup(wp->pipe_fd)) == NULL)
				continue;
			if (buffer_poll(pfd, NULL, wp->pipe_buf) != 0) {
				buffer_destroy(wp->pipe_buf);
				close(wp->pipe_fd);
				wp->pipe_fd = -1;
			}
a536 139

		server_check_window(w);
	}
}

/* Check clients for redraw and timers. */
void
server_check_clients(void)
{
	struct client		*c;
	struct window		*w;
	struct window_pane	*wp;
	u_int		 	 i;

	for (i = 0; i < ARRAY_LENGTH(&clients); i++) {
		c = ARRAY_ITEM(&clients, i);
		if (c == NULL || c->session == NULL)
			continue;

		server_check_timers(c);
		server_check_redraw(c);
	}

	/*
	 * Clear any window redraw flags (will have been redrawn as part of
	 * client).
	 */
	for (i = 0; i < ARRAY_LENGTH(&windows); i++) {
		w = ARRAY_ITEM(&windows, i);
		if (w == NULL)
			continue;

		w->flags &= ~WINDOW_REDRAW;
		TAILQ_FOREACH(wp, &w->panes, entry)
			wp->flags &= ~PANE_REDRAW;
	}
}

/* Check for general redraw on client. */
void
server_check_redraw(struct client *c)
{
	struct session		*s = c->session;
	struct window_pane	*wp;
	int		 	 flags, redraw;

	flags = c->tty.flags & TTY_FREEZE;
	c->tty.flags &= ~TTY_FREEZE;

	if (c->flags & (CLIENT_REDRAW|CLIENT_STATUS)) {
		if (options_get_number(&s->options, "set-titles"))
			server_set_title(c);
	
		if (c->message_string != NULL)
			redraw = status_message_redraw(c);
		else if (c->prompt_string != NULL)
			redraw = status_prompt_redraw(c);
		else
			redraw = status_redraw(c);
		if (!redraw)
			c->flags &= ~CLIENT_STATUS;
	}

	if (c->flags & CLIENT_REDRAW) {
		screen_redraw_screen(c, 0);
		c->flags &= ~CLIENT_STATUS;
	} else {
		TAILQ_FOREACH(wp, &c->session->curw->window->panes, entry) {
			if (wp->flags & PANE_REDRAW)
				screen_redraw_pane(c, wp);
		}
	}

	if (c->flags & CLIENT_STATUS)
		screen_redraw_screen(c, 1);

	c->tty.flags |= flags;

	c->flags &= ~(CLIENT_REDRAW|CLIENT_STATUS);
}

/* Set client title. */
void
server_set_title(struct client *c)
{
	struct session	*s = c->session;
	const char	*template;
	char		*title;

	template = options_get_string(&s->options, "set-titles-string");
	
	title = status_replace(c, template, time(NULL));
	if (c->title == NULL || strcmp(title, c->title) != 0) {
		if (c->title != NULL)
			xfree(c->title);
		c->title = xstrdup(title);
		tty_set_title(&c->tty, c->title);
	}
	xfree(title);
}

/* Check for timers on client. */
void
server_check_timers(struct client *c)
{
	struct session	*s = c->session;
	struct job	*job;
	struct timeval	 tv;
	u_int		 interval;

	if (gettimeofday(&tv, NULL) != 0)
		fatal("gettimeofday failed");

	if (c->flags & CLIENT_IDENTIFY && timercmp(&tv, &c->identify_timer, >))
		server_clear_identify(c);

	if (c->message_string != NULL && timercmp(&tv, &c->message_timer, >))
		status_message_clear(c);

	if (c->message_string != NULL || c->prompt_string != NULL) {
		/*
		 * Don't need timed redraw for messages/prompts so bail now.
		 * The status timer isn't reset when they are redrawn anyway.
		 */
		return;
	}
	if (!options_get_number(&s->options, "status"))
		return;

	/* Check timer; resolution is only a second so don't be too clever. */
	interval = options_get_number(&s->options, "status-interval");
	if (interval == 0)
		return;
	if (tv.tv_sec < c->status_timer.tv_sec ||
	    ((u_int) tv.tv_sec) - c->status_timer.tv_sec >= interval) {
		/* Run the jobs for this client and schedule for redraw. */
		RB_FOREACH(job, jobs, &c->status_jobs)
			job_run(job);
		c->flags |= CLIENT_STATUS;
d557 2
a558 1
			server_poll_add(c->ibuf.fd, events);
d566 2
a567 1
			server_poll_add(c->tty.fd, events);
d581 1
a581 20
		server_poll_add(job->fd, POLLIN);
	}
}

/* Handle job fds. */
void
server_handle_jobs(void)
{
	struct job	*job;
	struct pollfd	*pfd;

	SLIST_FOREACH(job, &all_jobs, lentry) {
		if (job->fd == -1)
			continue;
		if ((pfd = server_poll_lookup(job->fd)) == NULL)
			continue;
		if (buffer_poll(pfd, job->out, NULL) != 0) {
			close(job->fd);
			job->fd = -1;
		}
a584 299
/* Handle job fds. */
void
server_check_jobs(void)
{
	struct job	*job;
	
restart:
	SLIST_FOREACH(job, &all_jobs, lentry) {
		if (job->flags & JOB_DONE || job->fd != -1 || job->pid != -1)
			continue;
		job->flags |= JOB_DONE;

		if (job->callbackfn != NULL) {
			job->callbackfn(job);
			goto restart;	/* could be freed by callback */
		}
	}
}

/* Handle client pollfds. */
void
server_handle_clients(void)
{
	struct client	*c;
	struct pollfd	*pfd;
	u_int		 i;

	for (i = 0; i < ARRAY_LENGTH(&clients); i++) {
		c = ARRAY_ITEM(&clients, i);

		if (c != NULL) {
			if ((pfd = server_poll_lookup(c->ibuf.fd)) == NULL)
				continue;
			if (pfd->revents & (POLLERR|POLLNVAL|POLLHUP)) {
				server_lost_client(c);
				continue;
			}

			if (pfd->revents & POLLOUT) {
				if (msgbuf_write(&c->ibuf.w) < 0) {
					server_lost_client(c);
					continue;
				}
			}

			if (c->flags & CLIENT_BAD) {
				if (c->ibuf.w.queued == 0)
					server_lost_client(c);
				continue;
			} else if (pfd->revents & POLLIN) {
				if (server_msg_dispatch(c) != 0) {
					server_lost_client(c);
					continue;
				}
			}
		}

		if (c != NULL && !(c->flags & CLIENT_SUSPENDED) &&
		    c->tty.fd != -1 && c->session != NULL) {
			if ((pfd = server_poll_lookup(c->tty.fd)) == NULL)
				continue;
			if (buffer_poll(pfd, c->tty.in, c->tty.out) != 0)
				server_lost_client(c);
			else
				server_handle_client(c);
		}
	}
}

/* accept(2) and create new client. */
void
server_accept_client(int srv_fd)
{
	struct sockaddr_storage	sa;
	socklen_t		slen = sizeof sa;
	int			fd;

	fd = accept(srv_fd, (struct sockaddr *) &sa, &slen);
	if (fd == -1) {
		if (errno == EAGAIN || errno == EINTR || errno == ECONNABORTED)
			return;
		fatal("accept failed");
	}
	if (sigterm) {
		close(fd);
		return;
	}
	server_create_client(fd);
}

/* Input data from client. */
void
server_handle_client(struct client *c)
{
	struct window		*w;
	struct window_pane	*wp;
	struct screen		*s;
	struct options		*oo;
	struct timeval	 	 tv;
	struct key_binding	*bd;
	struct keylist		*keylist;
	struct mouse_event	 mouse;
	int		 	 key, status, xtimeout, mode, isprefix;
	u_int			 i;

	xtimeout = options_get_number(&c->session->options, "repeat-time");
	if (xtimeout != 0 && c->flags & CLIENT_REPEAT) {
		if (gettimeofday(&tv, NULL) != 0)
			fatal("gettimeofday failed");
		if (timercmp(&tv, &c->repeat_timer, >))
			c->flags &= ~(CLIENT_PREFIX|CLIENT_REPEAT);
	}

	/* Process keys. */
	keylist = options_get_data(&c->session->options, "prefix");
	while (tty_keys_next(&c->tty, &key, &mouse) == 0) {
		if (c->session == NULL)
			return;

		c->session->activity = time(NULL);
		w = c->session->curw->window;
		wp = w->active;	/* could die */
		oo = &c->session->options;

		/* Special case: number keys jump to pane in identify mode. */
		if (c->flags & CLIENT_IDENTIFY && key >= '0' && key <= '9') {	
			wp = window_pane_at_index(w, key - '0');
			if (wp != NULL && window_pane_visible(wp))
				window_set_active_pane(w, wp);
			server_clear_identify(c);
			continue;
		}
		
		status_message_clear(c);
		server_clear_identify(c);
		if (c->prompt_string != NULL) {
			status_prompt_key(c, key);
			continue;
		}

		/* Check for mouse keys. */
		if (key == KEYC_MOUSE) {
			if (options_get_number(oo, "mouse-select-pane")) {
				window_set_active_at(w, mouse.x, mouse.y);
				wp = w->active;
			}
			window_pane_mouse(wp, c, &mouse);
			continue;
		}

		/* Is this a prefix key? */
		isprefix = 0;
		for (i = 0; i < ARRAY_LENGTH(keylist); i++) {
			if (key == ARRAY_ITEM(keylist, i)) {
				isprefix = 1;
				break;
			}
		}

		/* No previous prefix key. */
		if (!(c->flags & CLIENT_PREFIX)) {
			if (isprefix)
				c->flags |= CLIENT_PREFIX;
			else {
				/* Try as a non-prefix key binding. */
				if ((bd = key_bindings_lookup(key)) == NULL)
					window_pane_key(wp, c, key);
				else
					key_bindings_dispatch(bd, c);
			}
			continue;
		}

		/* Prefix key already pressed. Reset prefix and lookup key. */
		c->flags &= ~CLIENT_PREFIX;
		if ((bd = key_bindings_lookup(key | KEYC_PREFIX)) == NULL) {
			/* If repeating, treat this as a key, else ignore. */
			if (c->flags & CLIENT_REPEAT) {
				c->flags &= ~CLIENT_REPEAT;
				if (isprefix)
					c->flags |= CLIENT_PREFIX;
				else
					window_pane_key(wp, c, key);
			}
			continue;
		}

		/* If already repeating, but this key can't repeat, skip it. */
		if (c->flags & CLIENT_REPEAT && !bd->can_repeat) {
			c->flags &= ~CLIENT_REPEAT;
			if (isprefix)
				c->flags |= CLIENT_PREFIX;
			else
				window_pane_key(wp, c, key);
			continue;
		}

		/* If this key can repeat, reset the repeat flags and timer. */
		if (xtimeout != 0 && bd->can_repeat) {
			c->flags |= CLIENT_PREFIX|CLIENT_REPEAT;

			tv.tv_sec = xtimeout / 1000;
			tv.tv_usec = (xtimeout % 1000) * 1000L;
			if (gettimeofday(&c->repeat_timer, NULL) != 0)
				fatal("gettimeofday failed");
			timeradd(&c->repeat_timer, &tv, &c->repeat_timer);
		}

		/* Dispatch the command. */
		key_bindings_dispatch(bd, c);
	}
	if (c->session == NULL)
		return;
	w = c->session->curw->window;
	wp = w->active;
	oo = &c->session->options;
	s = wp->screen;

	/*
	 * Update cursor position and mode settings. The scroll region and
	 * attributes are cleared across poll(2) as this is the most likely
	 * time a user may interrupt tmux, for example with ~^Z in ssh(1). This
	 * is a compromise between excessive resets and likelihood of an
	 * interrupt.
	 *
	 * tty_region/tty_reset/tty_update_mode already take care of not
	 * resetting things that are already in their default state.
	 */
	tty_region(&c->tty, 0, c->tty.sy - 1);

	status = options_get_number(oo, "status");
	if (!window_pane_visible(wp) || wp->yoff + s->cy >= c->tty.sy - status)
		tty_cursor(&c->tty, 0, 0);
	else
		tty_cursor(&c->tty, wp->xoff + s->cx, wp->yoff + s->cy);

	mode = s->mode;
	if (TAILQ_NEXT(TAILQ_FIRST(&w->panes), entry) != NULL &&
	    options_get_number(oo, "mouse-select-pane"))
		mode |= MODE_MOUSE;
	tty_update_mode(&c->tty, mode);
	tty_reset(&c->tty);
}

/* Lost a client. */
void
server_lost_client(struct client *c)
{
	u_int	i;

	for (i = 0; i < ARRAY_LENGTH(&clients); i++) {
		if (ARRAY_ITEM(&clients, i) == c)
			ARRAY_SET(&clients, i, NULL);
	}
	log_debug("lost client %d", c->ibuf.fd);

	/*
	 * If CLIENT_TERMINAL hasn't been set, then tty_init hasn't been called
	 * and tty_free might close an unrelated fd.
	 */
	if (c->flags & CLIENT_TERMINAL)
		tty_free(&c->tty);

	screen_free(&c->status);
	job_tree_free(&c->status_jobs);

	if (c->title != NULL)
		xfree(c->title);

	if (c->message_string != NULL)
		xfree(c->message_string);

	if (c->prompt_string != NULL)
		xfree(c->prompt_string);
	if (c->prompt_buffer != NULL)
		xfree(c->prompt_buffer);
	for (i = 0; i < ARRAY_LENGTH(&c->prompt_hdata); i++)
		xfree(ARRAY_ITEM(&c->prompt_hdata, i));
	ARRAY_FREE(&c->prompt_hdata);

	if (c->cwd != NULL)
		xfree(c->cwd);

	close(c->ibuf.fd);
	imsg_clear(&c->ibuf);

	for (i = 0; i < ARRAY_LENGTH(&dead_clients); i++) {
		if (ARRAY_ITEM(&dead_clients, i) == NULL) {
			ARRAY_SET(&dead_clients, i, c);
			break;
		}
	}
	if (i == ARRAY_LENGTH(&dead_clients))
		ARRAY_ADD(&dead_clients, c);
	c->flags |= CLIENT_DEAD;

	recalculate_sizes();
}

d610 1
a610 1
/* Handle window data. */
d612 1
a612 1
server_handle_window(struct window *w, struct window_pane *wp)
d614 2
a615 162
	struct session	*s;
	u_int		 i;
	int		 update;

	window_pane_parse(wp);

	if ((w->flags & (WINDOW_BELL|WINDOW_ACTIVITY|WINDOW_CONTENT)) == 0)
		return;

	update = 0;
	for (i = 0; i < ARRAY_LENGTH(&sessions); i++) {
		s = ARRAY_ITEM(&sessions, i);
		if (s == NULL || !session_has(s, w))
			continue;

		update += server_check_window_bell(s, w);
		update += server_check_window_activity(s, w);
		update += server_check_window_content(s, w, wp);
	}
	if (update)
		server_status_window(w);

	w->flags &= ~(WINDOW_BELL|WINDOW_ACTIVITY|WINDOW_CONTENT);
}

int
server_check_window_bell(struct session *s, struct window *w)
{
	struct client	*c;
	u_int		 i;
	int		 action, visual;

	if (!(w->flags & WINDOW_BELL))
		return (0);
	if (session_alert_has_window(s, w, WINDOW_BELL))
		return (0);
	session_alert_add(s, w, WINDOW_BELL);

	action = options_get_number(&s->options, "bell-action");
	switch (action) {
	case BELL_ANY:
		if (s->flags & SESSION_UNATTACHED)
			break;
		visual = options_get_number(&s->options, "visual-bell");
		for (i = 0; i < ARRAY_LENGTH(&clients); i++) {
			c = ARRAY_ITEM(&clients, i);
			if (c == NULL || c->session != s)
				continue;
			if (!visual) {
				tty_putcode(&c->tty, TTYC_BEL);
				continue;
			}
 			if (c->session->curw->window == w) {
				status_message_set(c, "Bell in current window");
				continue;
			}
			status_message_set(c, "Bell in window %u",
			    winlink_find_by_window(&s->windows, w)->idx);
		}
		break;
	case BELL_CURRENT:
		if (s->flags & SESSION_UNATTACHED)
			break;
		visual = options_get_number(&s->options, "visual-bell");
		for (i = 0; i < ARRAY_LENGTH(&clients); i++) {
			c = ARRAY_ITEM(&clients, i);
			if (c == NULL || c->session != s)
				continue;
 			if (c->session->curw->window != w)
				continue;
			if (!visual) {
				tty_putcode(&c->tty, TTYC_BEL);
				continue;
			}
			status_message_set(c, "Bell in current window");
		}
		break;
	}
	return (1);
}

int
server_check_window_activity(struct session *s, struct window *w)
{
	struct client	*c;
	u_int		 i;

	if (!(w->flags & WINDOW_ACTIVITY))
		return (0);

	if (!options_get_number(&w->options, "monitor-activity"))
		return (0);

	if (session_alert_has_window(s, w, WINDOW_ACTIVITY))
		return (0);
	if (s->curw->window == w)
		return (0);

	session_alert_add(s, w, WINDOW_ACTIVITY);
	if (s->flags & SESSION_UNATTACHED)
		return (0);
 	if (options_get_number(&s->options, "visual-activity")) {
		for (i = 0; i < ARRAY_LENGTH(&clients); i++) {
			c = ARRAY_ITEM(&clients, i);
			if (c == NULL || c->session != s)
				continue;
			status_message_set(c, "Activity in window %u",
			    winlink_find_by_window(&s->windows, w)->idx);
		}
	}

	return (1);
}

int
server_check_window_content(
    struct session *s, struct window *w, struct window_pane *wp)
{
	struct client	*c;
	u_int		 i;
	char		*found, *ptr;
	
	if (!(w->flags & WINDOW_ACTIVITY))	/* activity for new content */
		return (0);

	ptr = options_get_string(&w->options, "monitor-content");
	if (ptr == NULL || *ptr == '\0')
		return (0);

	if (session_alert_has_window(s, w, WINDOW_CONTENT))
		return (0);
	if (s->curw->window == w)
		return (0);

	if ((found = window_pane_search(wp, ptr, NULL)) == NULL)
		return (0);
    	xfree(found);

	session_alert_add(s, w, WINDOW_CONTENT);
	if (s->flags & SESSION_UNATTACHED)
		return (0);
 	if (options_get_number(&s->options, "visual-content")) {
		for (i = 0; i < ARRAY_LENGTH(&clients); i++) {
			c = ARRAY_ITEM(&clients, i);
			if (c == NULL || c->session != s)
				continue;
			status_message_set(c, "Content in window %u",
			    winlink_find_by_window(&s->windows, w)->idx);
		}
	}

	return (1);
}

/* Check if window still exists. */
void
server_check_window(struct window *w)
{
	struct window_pane	*wp, *wq;
	struct options		*oo = &w->options;
	struct session		*s;
	struct winlink		*wl;
a616 1
	int		 	 destroyed;
d618 4
a621 1
	destroyed = 1;
d623 3
a625 26
	wp = TAILQ_FIRST(&w->panes);
	while (wp != NULL) {
		wq = TAILQ_NEXT(wp, entry);
		/*
		 * If the pane has died and the remain-on-exit flag is not set,
		 * remove the pane; otherwise, if the flag is set, don't allow
		 * the window to be destroyed (or it'll close when the last
		 * pane dies).
		 */
		if (wp->fd == -1 && !options_get_number(oo, "remain-on-exit")) {
			layout_close_pane(wp);
			window_remove_pane(w, wp);
			server_redraw_window(w);
		} else 
			destroyed = 0;
		wp = wq;
	}

	if (!destroyed)
		return;

	for (i = 0; i < ARRAY_LENGTH(&sessions); i++) {
		s = ARRAY_ITEM(&sessions, i);
		if (s == NULL)
			continue;
		if (!session_has(s, w))
d628 3
a630 12
	restart:
		/* Detach window and either redraw or kill clients. */
		RB_FOREACH(wl, winlinks, &s->windows) {
			if (wl->window != w)
				continue;
			if (session_detach(s, wl)) {
				server_destroy_session_group(s);
				break;
			}
			server_redraw_session(s);
			server_status_session_group(s);
			goto restart;
a632 2

	recalculate_sizes();
a685 25
		}
	}
}

/* Call any once-per-second timers. */
void
server_second_timers(void)
{
	struct window		*w;
	struct window_pane	*wp;
	u_int		 	 i;

	if (options_get_number(&global_s_options, "lock-server"))
		server_lock_server();
	else
		server_lock_sessions();

	for (i = 0; i < ARRAY_LENGTH(&windows); i++) {
		w = ARRAY_ITEM(&windows, i);
		if (w == NULL)
			continue;

		TAILQ_FOREACH(wp, &w->panes, entry) {
			if (wp->mode != NULL && wp->mode->timer != NULL)
				wp->mode->timer(wp);
@


1.58
log
@Similarly add a tty_cursor_pane function to tidy up most of the calls.
@
text
@d1 1
a1 1
/* $OpenBSD: server.c,v 1.57 2009/10/12 09:16:59 nicm Exp $ */
d1380 5
d1407 5
@


1.57
log
@_absolute is redundant, just use tty_region.
@
text
@d1 1
a1 1
/* $OpenBSD: server.c,v 1.56 2009/10/12 09:09:35 nicm Exp $ */
d1057 1
a1057 1
		tty_cursor(&c->tty, 0, 0, 0, 0);
d1059 1
a1059 1
		tty_cursor(&c->tty, s->cx, s->cy, wp->xoff, wp->yoff);
@


1.56
log
@Cleanup: use two functions for region setting, one for absolute and one inside
pane.
@
text
@d1 1
a1 1
/* $OpenBSD: server.c,v 1.55 2009/10/11 10:04:27 nicm Exp $ */
d1053 1
a1053 1
	tty_region_absolute(&c->tty, 0, c->tty.sy - 1);
@


1.55
log
@Add a pipe-pane command to allow a pane to be piped to a shell command, for
example:

	pipe-pane 'cat >~/out'

No arguments stops outputing and closes the pipe; the -o flag toggles a pipe
and on and off (useful for key bindings).

Suggested by espie@@.
@
text
@d1 1
a1 1
/* $OpenBSD: server.c,v 1.54 2009/10/11 08:58:05 nicm Exp $ */
d1053 2
a1055 1
	tty_region(&c->tty, 0, c->tty.sy - 1, 0);
@


1.54
log
@Switch run-shell over to queue the command in the background like #().
@
text
@d1 1
a1 1
/* $OpenBSD: server.c,v 1.53 2009/10/11 07:20:16 nicm Exp $ */
d575 7
d610 10
@


1.53
log
@Collect status from dead jobs and don't invoke the callback until both
all input (the socket is closed) and status is available.
@
text
@d1 1
a1 1
/* $OpenBSD: server.c,v 1.52 2009/10/11 07:01:10 nicm Exp $ */
d813 2
a814 1

d818 3
a820 1
		if (job->callbackfn != NULL)
d822 2
a823 1
		job->flags |= JOB_DONE;
@


1.52
log
@Clean up by introducing a wrapper struct for mouse clicks rather than passing
three u_chars around.

As a side-effect this fixes incorrectly rejecting high cursor positions
(because it was comparing them as signed char), reported by Tom Doherty.
@
text
@d1 1
a1 1
/* $OpenBSD: server.c,v 1.51 2009/10/11 00:53:14 nicm Exp $ */
d91 1
d374 2
a375 1
		/* Process client actions. */
a393 1
		log_debug("polling %d", nfds);
d514 1
d528 7
a534 1
		if (!WIFSTOPPED(status))
d536 1
a803 2
			if (job->callbackfn != NULL)
				job->callbackfn(job);
d805 15
@


1.51
log
@Braek some bits out of server_fill_client() that aren't really related to
polling into their own function.
@
text
@d1 1
a1 1
/* $OpenBSD: server.c,v 1.49 2009/10/10 15:03:01 nicm Exp $ */
d883 1
a885 1
	u_char			 mouse[3];
d897 1
a897 1
	while (tty_keys_next(&c->tty, &key, mouse) == 0) {
d925 1
a925 1
				window_set_active_at(w, mouse[1], mouse[2]);
d928 1
a928 1
			window_pane_mouse(wp, c, mouse[0], mouse[1], mouse[2]);
@


1.50
log
@Put all jobs on a global all_jobs list and use that in server.c instead of
running through all the clients.
@
text
@d93 1
d373 3
d600 33
d637 1
a637 1
	struct session		*s;
a640 4
	if (c == NULL || c->session == NULL)
		return;
	s = c->session;

d700 1
a700 1
	struct session	*s;
a704 4
	if (c == NULL || c->session == NULL)
		return;
	s = c->session;

d741 3
a743 5
	struct client		*c;
	struct window		*w;
	struct window_pane	*wp;
	u_int		 	 i;
	int			 events;
a747 3
		server_check_timers(c);
		server_check_redraw(c);

a763 14
	}

	/*
	 * Clear any window redraw flags (will have been redrawn as part of
	 * client).
	 */
	for (i = 0; i < ARRAY_LENGTH(&windows); i++) {
		w = ARRAY_ITEM(&windows, i);
		if (w == NULL)
			continue;

		w->flags &= ~WINDOW_REDRAW;
		TAILQ_FOREACH(wp, &w->panes, entry)
			wp->flags &= ~PANE_REDRAW;
@


1.49
log
@Rather than running status-left, status-right and window title #() with popen
immediately every redraw, queue them up and run them in the background,
starting each once every status-interval. The actual status line uses the
output from the last run.

This brings several advantages:

- tmux itself may be called from inside #() without causing the server to hang;
- likewise, sleep or similar doesn't cause the server to block;
- commands aren't run excessively often when redrawing;
- commands shared by status-left and status-right, or used multiple times, will
  only be run once.

run-shell and if-shell still use system()/popen() but will be changed over to
use this too later.
@
text
@d1 1
a1 1
/* $OpenBSD: server.c,v 1.48 2009/10/10 14:51:16 nicm Exp $ */
a75 1
void		 server_fill_jobs1(struct jobs *);
a76 1
void		 server_handle_jobs1(struct jobs *);
d415 1
a415 5
		/*
		 * Handle window and client sockets. Clients can create
		 * windows, so windows must come first to avoid messing up by
		 * increasing the array size.
		 */
a760 13
 	struct client	*c;
	u_int		 i;

	for (i = 0; i < ARRAY_LENGTH(&clients); i++) {
		c = ARRAY_ITEM(&clients, i);
		if (c != NULL)
			server_fill_jobs1(&c->status_jobs);
	}
}

void
server_fill_jobs1(struct jobs *jobs)
{
d763 1
a763 1
	RB_FOREACH(job, jobs, jobs) {
a773 13
	struct client	*c;
	u_int		 i;
	
	for (i = 0; i < ARRAY_LENGTH(&clients); i++) {
		c = ARRAY_ITEM(&clients, i);
		if (c != NULL)
			server_handle_jobs1(&c->status_jobs);
	}
}

void
server_handle_jobs1(struct jobs *jobs)
{
d777 1
a777 1
	RB_FOREACH(job, jobs, jobs) {
@


1.48
log
@New option, mouse-select-pane. If on, the mouse may be used to select the
current pane.

Suggested by sthen@@ and also by someone else ages ago who I have forgotten.
@
text
@d1 1
a1 1
/* $OpenBSD: server.c,v 1.47 2009/10/10 10:02:48 nicm Exp $ */
d75 4
d197 1
d199 1
d379 1
d422 1
d659 1
a659 1
	title = status_replace(c->session, template, time(NULL));
d674 1
d706 4
a709 1
	    ((u_int) tv.tv_sec) - c->status_timer.tv_sec >= interval)
d711 1
d763 60
d1067 1
@


1.47
log
@Add "grouped sessions" which have independent name, options, current window and
so on but where the linked windows are synchronized (ie creating, killing
windows and so on are mirrored between the sessions). A grouped session may be
created by passing -t to new-session.

Had this around for a while, tested by a couple of people.
@
text
@d1 1
a1 1
/* $OpenBSD: server.c,v 1.46 2009/10/10 09:46:11 nicm Exp $ */
d828 1
d853 1
d873 4
d944 3
a946 1
	wp = c->session->curw->window->active;	/* could die - do each loop */
d959 1
a959 1
	status = options_get_number(&c->session->options, "status");
d967 3
@


1.46
log
@Support for individual session idle time locking. May be enabled by turning off
the lock-server option (it is on by default). When this is off, each session
locks when it has been idle for the lock-after-time setting. When on, the
entire server locks when ALL sessions have been idle for their individual
lock-after-time settings.

This replaces one global-only option (lock-after-time) with another
(lock-server), but the default behaviour is usually preferable so there don't
seem to be many alternatives.

Diff/idea largely from Thomas Adam, tweaked by me.
@
text
@d1 1
a1 1
/* $OpenBSD: server.c,v 1.45 2009/10/10 09:31:39 nicm Exp $ */
d250 1
d1247 1
a1247 1
				server_destroy_session(s);
d1251 1
@


1.45
log
@Instead of passing a struct pollfd ** around through various functions, build
them into a tree and then convert into a flat poll array before and after poll.

This adds a little code but should reduce annoying problems with ordering when
adding new things that also need to be polled.
@
text
@d1 1
a1 1
/* $OpenBSD: server.c,v 1.44 2009/10/05 18:30:54 nicm Exp $ */
d89 2
a253 2
	server_activity = time(NULL);

a844 2
		server_activity = time(NULL);

d847 2
d1257 45
a1308 2
	int			 xtimeout;
	time_t		 	 t;
d1310 4
a1313 7
	t = time(NULL);

	xtimeout = options_get_number(&global_s_options, "lock-after-time");
	if (xtimeout > 0 && t > server_activity + xtimeout) {
		server_lock();
		recalculate_sizes();
	}
@


1.44
log
@If no target client is specified to commands which accept one, try to guess the
current client, in a similar manner to how sessions already work: if the
current session can be established and has only one client, use that; otherwise
use the most recently created client.
@
text
@d1 1
a1 1
/* $OpenBSD: server.c,v 1.43 2009/09/24 07:02:56 nicm Exp $ */
d48 17
d71 4
a74 4
void		 server_fill_windows(struct pollfd **);
void		 server_handle_windows(struct pollfd **);
void		 server_fill_clients(struct pollfd **);
void		 server_handle_clients(struct pollfd **);
d92 69
a333 1
	struct window	*w;
d367 3
a369 16
		/* Initialise pollfd array. */
		nfds = 1;
		for (i = 0; i < ARRAY_LENGTH(&windows); i++) {
			w = ARRAY_ITEM(&windows, i);
			if (w != NULL)
				nfds += window_count_panes(w);
		}
		nfds += ARRAY_LENGTH(&clients) * 2;
		pfds = xrealloc(pfds, nfds, sizeof *pfds);
		memset(pfds, 0, nfds * sizeof *pfds);
		pfd = pfds;

		/* Fill server socket. */
		pfd->fd = srv_fd;
		pfd->events = POLLIN;
		pfd++;
d372 2
a373 2
		server_fill_windows(&pfd);
		server_fill_clients(&pfd);
d381 2
d388 1
a388 1
		pfd = pfds;
d391 1
a397 1
		pfd++;
d414 2
a415 2
		server_handle_windows(&pfd);
		server_handle_clients(&pfd);
d423 1
a423 2
	if (pfds != NULL)
		xfree(pfds);
d540 1
a540 1
server_fill_windows(struct pollfd **pfd)
d545 1
d552 7
a558 8
		TAILQ_FOREACH(wp, &w->panes, entry) {
			(*pfd)->fd = wp->fd;
			if (wp->fd != -1) {
				(*pfd)->events = POLLIN;
				if (BUFFER_USED(wp->out) > 0)
					(*pfd)->events |= POLLOUT;
			}
			(*pfd)++;
d565 1
a565 1
server_handle_windows(struct pollfd **pfd)
d569 1
d578 9
a586 8
			if (wp->fd != -1) {
				if (buffer_poll(*pfd, wp->in, wp->out) != 0) {
					close(wp->fd);
					wp->fd = -1;
				} else
					server_handle_window(w, wp);
			}
			(*pfd)++;
d702 1
a702 1
server_fill_clients(struct pollfd **pfd)
d708 1
d716 2
a717 4
		if (c == NULL)
			(*pfd)->fd = -1;
		else {
			(*pfd)->fd = c->ibuf.fd;
d719 1
a719 1
				(*pfd)->events |= POLLIN;
d721 2
a722 1
				(*pfd)->events |= POLLOUT;
a723 1
		(*pfd)++;
d725 3
a727 6
		if (c == NULL || c->flags & CLIENT_SUSPENDED ||
		    c->tty.fd == -1 || c->session == NULL)
			(*pfd)->fd = -1;
		else {
			(*pfd)->fd = c->tty.fd;
			(*pfd)->events = POLLIN;
d729 2
a730 1
				(*pfd)->events |= POLLOUT;
a731 1
		(*pfd)++;
d751 1
a751 1
server_handle_clients(struct pollfd **pfd)
d754 1
d761 3
a763 1
			if ((*pfd)->revents & (POLLERR|POLLNVAL|POLLHUP)) {
a764 1
				(*pfd) += 2;
d768 1
a768 1
			if ((*pfd)->revents & POLLOUT) {
a770 1
					(*pfd) += 2;
a777 1
				(*pfd) += 2;
d779 1
a779 1
			} else if ((*pfd)->revents & POLLIN) {
a781 1
					(*pfd) += 2;
a785 1
		(*pfd)++;
d789 3
a791 1
			if (buffer_poll(*pfd, c->tty.in, c->tty.out) != 0)
a795 1
		(*pfd)++;
@


1.43
log
@Don't allow locked or suspended clients to limit the size of active clients.
@
text
@d1 1
a1 1
/* $OpenBSD: server.c,v 1.42 2009/09/23 08:21:57 nicm Exp $ */
d93 3
@


1.42
log
@On SIGTERM, just abandon any suspended/locked clients and leave them to it,
otherwise the server will hang around (refusing new connections) until they
exit properly.
@
text
@d1 1
a1 1
/* $OpenBSD: server.c,v 1.41 2009/09/23 06:18:47 nicm Exp $ */
d1197 1
a1197 1
	if (xtimeout > 0 && t > server_activity + xtimeout)
d1199 2
@


1.41
log
@Remove the internal tmux locking and instead detach each client and run the
command specified by a new option "lock-command" (by default "lock -np") in
each client.

This means each terminal has to be unlocked individually but simplifies the
code and allows the system password to be used to unlock.

Note that the set-password command is gone, so it will need to be removed from
configuration files, and the -U command line flag has been removed.

This is the third protocol version change so again it is best to stop the tmux
server before upgrading.
@
text
@d1 1
a1 1
/* $OpenBSD: server.c,v 1.40 2009/09/22 12:38:10 nicm Exp $ */
d52 1
d248 1
a248 1
	u_int		 i, n;
d262 4
a344 16
		
		/*
		 * If we have no sessions and clients left, let's get out
		 * of here...
		 */
		n = 0;
		for (i = 0; i < ARRAY_LENGTH(&sessions); i++) {
			if (ARRAY_ITEM(&sessions, i) != NULL)
				n++;
		}
		for (i = 0; i < ARRAY_LENGTH(&clients); i++) {
			if (ARRAY_ITEM(&clients, i) != NULL)
				n++;
		}
		if (n == 0)
			break;
d383 10
d405 7
d413 4
d418 2
a419 7
		c = ARRAY_ITEM(&clients, i);
		if (c != NULL) {
			if (c->flags & CLIENT_BAD)
				server_lost_client(c);
			else
				server_write_client(c, MSG_SHUTDOWN, NULL, 0);
		}
d421 1
@


1.40
log
@Permit multiple prefix keys to be defined, separated by commas, for example:

set -g prefix ^a,^b

Any key in the list acts as the prefix. The send-prefix command always sends
the first key in the list.
@
text
@d1 1
a1 1
/* $OpenBSD: server.c,v 1.39 2009/09/20 14:58:12 nicm Exp $ */
a69 1
void		 server_redraw_locked(struct client *);
a161 2
	server_locked = 0;
	server_password = NULL;
a381 2
	if (server_password != NULL)
		xfree(server_password);
d539 1
a539 4
		if (server_locked)
			server_redraw_locked(c);
		else
 			screen_redraw_screen(c, 0);
a575 43
/* Redraw client when locked. */
void
server_redraw_locked(struct client *c)
{
	struct screen_write_ctx	ctx;
	struct screen		screen;
	struct grid_cell	gc;
	u_int			colour, xx, yy, i;
	int    			style;

	xx = c->tty.sx;
	yy = c->tty.sy - 1;
	if (xx == 0 || yy == 0)
		return;
	colour = options_get_number(&global_w_options, "clock-mode-colour");
	style = options_get_number(&global_w_options, "clock-mode-style");

	memcpy(&gc, &grid_default_cell, sizeof gc);
	colour_set_fg(&gc, colour);
	gc.attr |= GRID_ATTR_BRIGHT;

	screen_init(&screen, xx, yy, 0);

	screen_write_start(&ctx, NULL, &screen);
	clock_draw(&ctx, colour, style);

	if (password_failures != 0) {
		screen_write_cursormove(&ctx, 0, 0);
		screen_write_puts(
		    &ctx, &gc, "%u failed attempts", password_failures);
		if (time(NULL) < password_backoff)
			screen_write_puts(&ctx, &gc, "; sleeping");
	}

	screen_write_stop(&ctx);

	for (i = 0; i < screen_size_y(&screen); i++)
		tty_draw_line(&c->tty, &screen, i, 0, 0);
	screen_redraw_screen(c, 1);

	screen_free(&screen);
}

a787 2
		if (server_locked)
			continue;
a878 2
	if (server_locked)
		mode &= ~TTY_NOCURSOR;
a1182 1
	struct client		*c;
a1185 2
	struct tm	 	 now, then;
	static time_t	 	 last_t = 0;
a1201 23
		}
	}

	if (password_backoff != 0 && t >= password_backoff) {
		for (i = 0; i < ARRAY_LENGTH(&clients); i++) {
			if ((c = ARRAY_ITEM(&clients, i)) != NULL)
				server_redraw_client(c);
		}
		password_backoff = 0;
	}

	/* Check for a minute having passed. */
	gmtime_r(&t, &now);
	gmtime_r(&last_t, &then);
	if (now.tm_min == then.tm_min)
		return;
	last_t = t;

	/* If locked, redraw all clients. */
	if (server_locked) {
		for (i = 0; i < ARRAY_LENGTH(&clients); i++) {
			if ((c = ARRAY_ITEM(&clients, i)) != NULL)
				server_redraw_client(c);
@


1.39
log
@Regularise some fatal messages.
@
text
@d1 1
a1 1
/* $OpenBSD: server.c,v 1.38 2009/09/18 15:19:27 nicm Exp $ */
d801 3
a803 2
	int		 	 key, prefix, status, xtimeout;
	int			 mode;
d815 1
a815 1
	prefix = options_get_number(&c->session->options, "prefix");
d848 9
d859 1
a859 1
			if (key == prefix)
d877 1
a877 1
				if (key == prefix)
d888 1
a888 1
			if (key == prefix)
@


1.38
log
@New option, set-titles-string, to allow the window title to be specified (as
for status-left/right) if set-titles is on. Also only update the title when the
status line is being redrawn.
@
text
@d1 1
a1 1
/* $OpenBSD: server.c,v 1.37 2009/09/15 07:45:16 nicm Exp $ */
d438 1
a438 1
			fatal("waitpid");
d640 1
a640 1
		fatal("gettimeofday");
d808 1
a808 1
			fatal("gettimeofday");
d892 1
a892 1
				fatal("gettimeofday");
@


1.37
log
@The default terminal size should be 80x24, not 80x25.
@
text
@d1 1
a1 1
/* $OpenBSD: server.c,v 1.36 2009/09/14 11:25:35 nicm Exp $ */
d69 1
a519 1
	char		 	 title[512];
a528 12
	if (options_get_number(&s->options, "set-titles")) {
		xsnprintf(title, sizeof title, "%s:%u:%s - \"%s\"",
		    s->name, s->curw->idx, s->curw->window->name,
		    s->curw->window->active->screen->title);
		if (c->title == NULL || strcmp(title, c->title) != 0) {
			if (c->title != NULL)
				xfree(c->title);
			c->title = xstrdup(title);
			tty_set_title(&c->tty, c->title);
		}
	}

d530 3
d562 20
@


1.36
log
@Nuke unused server_client_index function, pointed out by martynas@@.
@
text
@d1 1
a1 1
/* $OpenBSD: server.c,v 1.35 2009/09/12 13:09:43 nicm Exp $ */
d100 1
a100 1
	c->tty.sy = 25;
@


1.35
log
@Doh, trim variables unused now.
@
text
@d1 1
a1 1
/* $OpenBSD: server.c,v 1.34 2009/09/12 13:01:19 nicm Exp $ */
a116 13
}

/* Find client index. */
int
server_client_index(struct client *c)
{
	u_int	i;

	for (i = 0; i < ARRAY_LENGTH(&clients); i++) {
		if (c == ARRAY_ITEM(&clients, i))
			return (i);
	}
	return (-1);
@


1.34
log
@Tidy some common code for destroying sessions into a new function.
@
text
@d1 1
a1 1
/* $OpenBSD: server.c,v 1.33 2009/09/10 17:16:24 nicm Exp $ */
a1172 1
	struct client		*c;
d1175 1
a1175 1
	u_int		 	 i, j;
@


1.33
log
@Permit options such as status-bg to be configured using the entire 256 colour
palette by setting "colour0" to "colour255".
@
text
@d1 1
a1 1
/* $OpenBSD: server.c,v 1.32 2009/09/07 21:12:12 nicm Exp $ */
d1214 3
a1216 11
			destroyed = session_detach(s, wl);
			for (j = 0; j < ARRAY_LENGTH(&clients); j++) {
				c = ARRAY_ITEM(&clients, j);
				if (c == NULL || c->session != s)
					continue;
				if (!destroyed) {
					server_redraw_client(c);
					continue;
				}
				c->session = NULL;
				server_write_client(c, MSG_EXIT, NULL, 0);
d1218 1
a1218 3
			/* If the session was destroyed, bail now. */
			if (destroyed)
				break;
@


1.32
log
@While the display-panes indicator is on screen, make the number keys select the
pane with that index.
@
text
@d1 1
a1 1
/* $OpenBSD: server.c,v 1.31 2009/09/07 21:01:50 nicm Exp $ */
d604 1
a604 1
	gc.fg = colour;
@


1.31
log
@Reference count clients and sessions rather than relying on a saved index for
cmd-choose-*.
@
text
@d1 1
a1 1
/* $OpenBSD: server.c,v 1.30 2009/09/07 19:08:45 kili Exp $ */
d798 1
d822 2
a823 1
		wp = c->session->curw->window->active;	/* could die */
d825 9
@


1.30
log
@Tiny cleanup.

ok nicm@@
@
text
@d1 1
a1 1
/* $OpenBSD: server.c,v 1.29 2009/09/05 17:42:16 nicm Exp $ */
d46 1
d65 1
d90 1
d168 1
d170 1
d352 3
d959 10
a968 1
	xfree(c);
d971 25
@


1.29
log
@Only redraw all clients once when the backoff timer expires rather than every
second all the time.

Reported by Simon Nicolussi.
@
text
@d1 1
a1 1
/* $OpenBSD: server.c,v 1.28 2009/09/04 13:29:10 nicm Exp $ */
d1231 2
a1232 2
			if (ARRAY_ITEM(&clients, i) != NULL)
				server_redraw_client(ARRAY_ITEM(&clients, i));
@


1.28
log
@Tell the user when sleeping due to password backoff.
@
text
@d1 1
a1 1
/* $OpenBSD: server.c,v 1.27 2009/09/02 21:25:57 nicm Exp $ */
d1213 1
a1213 1
	if (t > password_backoff) {
d1218 1
@


1.27
log
@When shutting down the server, expect clients to be polite and exit when asked
with the right message.
@
text
@d1 1
a1 1
/* $OpenBSD: server.c,v 1.26 2009/08/31 20:46:19 nicm Exp $ */
d608 2
d1188 1
d1197 1
d1210 7
@


1.26
log
@Add a new display-panes command, with two options (display-panes-colour and
display-panes-time), which displays a visual indication of the number of each
pane.
@
text
@d1 1
a1 1
/* $OpenBSD: server.c,v 1.25 2009/08/31 11:37:27 nicm Exp $ */
d205 1
a206 1
	c->flags |= CLIENT_BAD;
d307 1
a307 1
		if (sigterm || server_update_socket() != 0)
a422 1
			c->flags |= CLIENT_BAD;
@


1.25
log
@Don't call tty_free unless the client is a terminal, otherwise tty_init hasn't
been called and it may end up doing close(0). From Kalle Olavi Niemitalo.
@
text
@d1 1
a1 1
/* $OpenBSD: server.c,v 1.24 2009/08/23 17:29:51 nicm Exp $ */
d635 3
d815 1
@


1.24
log
@When using source-file, run the commands in the context of the source-file
command rather than with no context. This makes things like attach work from a
file.
@
text
@d1 1
a1 1
/* $OpenBSD: server.c,v 1.23 2009/08/18 21:37:04 nicm Exp $ */
d918 6
a923 1
	tty_free(&c->tty);
@


1.23
log
@Whoops, getting the comparison the right way round is usually recommended.
@
text
@d1 1
a1 1
/* $OpenBSD: server.c,v 1.22 2009/08/18 21:14:24 nicm Exp $ */
d191 1
a191 1
	} else if (load_cfg(SYSTEM_CFG, &cause) != 0)
d193 1
a193 1
	if (cfg_file != NULL && load_cfg(cfg_file, &cause) != 0)
@


1.22
log
@options_get_number() is relatively expensive and a check for dead panes happens
a lot more often than actually finding one, so instead of getting the option
for every check, get it for every dead window found.
@
text
@d1 1
a1 1
/* $OpenBSD: server.c,v 1.21 2009/08/14 11:23:34 nicm Exp $ */
d1127 1
a1127 1
		if (wp->fd == -1 && options_get_number(oo, "remain-on-exit")) {
@


1.21
log
@Reset attributes as well as scroll region before poll(2) and add a big comment
explaining why.
@
text
@d1 1
a1 1
/* $OpenBSD: server.c,v 1.20 2009/08/11 22:34:17 nicm Exp $ */
d1109 1
d1114 1
a1114 3
	int		 	 destroyed, flag;

	flag = options_get_number(&w->options, "remain-on-exit");
d1127 1
a1127 1
		if (wp->fd == -1 && !flag) {
@


1.20
log
@Initialise log_fd to -1, prevents spurious disconnection of the client when it
ends up as fd 0 (likely if the server is started with "tmux start").

Also add some extra debugging messages to server.c.
@
text
@d1 1
a1 1
/* $OpenBSD: server.c,v 1.19 2009/08/11 19:32:25 nicm Exp $ */
d882 10
a891 1
	/* Ensure cursor position and mode settings. */
d903 1
@


1.19
log
@Drop the no_stop argument to tty_close and tty_free in favour of a flag in the
tty struct.
@
text
@d1 1
a1 1
/* $OpenBSD: server.c,v 1.18 2009/08/11 17:18:35 nicm Exp $ */
d113 1
d261 1
d906 1
@


1.18
log
@Switch tmux to use imsg. This is the last major change to make the
client-server protocol more resilient and make the protocol versioning work
properly. In future, the only things requiring a protocol version bump will be
changes in the message structs, and (when both client and server have this
change) mixing different versions should nicely report an error message.

As a side effect this also makes the code tidier, fixes a problem with the way
errors reported during server startup were handled, and supports fd passing
(which will be used in future).

Looked over by eric@@, thanks.

Please note that mixing a client with this change with an older server or vice
versa may cause tmux to crash or hang - tmux should be completely exited before
upgrading.
@
text
@d1 1
a1 1
/* $OpenBSD: server.c,v 1.17 2009/08/10 19:42:03 nicm Exp $ */
d905 1
a905 1
	tty_free(&c->tty, c->flags & CLIENT_SUSPENDED);
@


1.17
log
@Reset the attributes after drawing all or part of the screen, and reset the
region before poll(2). This reduces (but does not eliminate) the chance of the
attributes not being normal if tmux is disconnected without warning (ssh ~.,
reboot from inside, etc).
@
text
@d1 1
a1 1
/* $OpenBSD: server.c,v 1.16 2009/08/07 15:39:10 nicm Exp $ */
d88 1
a88 3
	c->fd = fd;
	c->in = buffer_create(BUFSIZ);
	c->out = buffer_create(BUFSIZ);
d673 1
a673 1
			(*pfd)->fd = c->fd;
d675 2
a676 2
				(*pfd)->events = POLLIN;
			if (BUFFER_USED(c->out) > 0)
d719 1
a719 1
			if (buffer_poll(*pfd, c->in, c->out) != 0) {
d723 12
a734 2
			} else if (c->flags & CLIENT_BAD) {
				if (BUFFER_USED(c->out) == 0)
d737 8
a744 3
				continue;			
			} else
				server_msg_dispatch(c);
d926 2
a927 3
	close(c->fd);
	buffer_destroy(c->in);
	buffer_destroy(c->out);
@


1.16
log
@If there is an error in the configuration file, don't just exit(1) as this can
cause the client to hang. Instead, send the error message, then mark the client
as bad and start a normal shutdown so the server exits once the error is
written.

This also allows some code duplicating daemon(3) to be trimmed and logging to
begin earlier.

Prompted by Theo noticing the behaviour on error wasn't documented.
@
text
@d1 1
a1 1
/* $OpenBSD: server.c,v 1.15 2009/07/28 07:03:32 nicm Exp $ */
d869 1
@


1.15
log
@Next step towards customisable mode keys: build each default table of keys into
a named tree on start and use that for lookups. Also add command to string
translation tables and modify list-keys to show the the mode key bindings (new
-t argument).
@
text
@d1 1
a1 1
/* $OpenBSD: server.c,v 1.14 2009/07/24 14:52:47 nicm Exp $ */
d134 4
a137 3
	int	pair[2], srv_fd, null_fd;
	char   *cause;
	char	rpathbuf[MAXPATHLEN];
d158 1
a158 1
	if (daemon(1, 1) != 0)
d161 3
d178 8
d188 8
a195 14
			log_warn("%s", SYSTEM_CFG);
			exit(1);
		}
	} else {
		if (load_cfg(SYSTEM_CFG, &cause) != 0) {
			log_warnx("%s", cause);
			exit(1);
		}
	}
	if (cfg_file != NULL && load_cfg(cfg_file, &cause) != 0) {
		log_warnx("%s", cause);
		exit(1);
	}
	logfile("server");
d197 1
a197 11
	/*
	 * Close stdin/stdout/stderr. Can't let daemon() do this as they are
	 * needed until now to print configuration file errors.
	 */
        if ((null_fd = open(_PATH_DEVNULL, O_RDWR)) != -1) {
                dup2(null_fd, STDIN_FILENO);
                dup2(null_fd, STDOUT_FILENO);
                dup2(null_fd, STDERR_FILENO);
                if (null_fd > 2)
                        close(null_fd);
        }
d199 3
a201 2
	log_debug("server started, pid %ld", (long) getpid());
	log_debug("socket path %s", socket_path);
d203 2
a204 3
	if (realpath(socket_path, rpathbuf) == NULL)
		strlcpy(rpathbuf, socket_path, sizeof rpathbuf);
	setproctitle("server (%s)", rpathbuf);
d206 2
a207 2
	srv_fd = server_create_socket();
	server_create_client(pair[1]);
d418 7
a424 2
		if (c != NULL)
			server_write_client(c, MSG_SHUTDOWN, NULL, 0);
d676 2
a677 1
			(*pfd)->events = POLLIN;
d725 5
@


1.14
log
@Permit commands to be bound to key presses without the prefix key first. The
new -n flag to bind-key and unbind-key sets or removes these bindings, and
list-key shows them in []s.
@
text
@d1 1
a1 1
/* $OpenBSD: server.c,v 1.13 2009/07/21 19:54:22 nicm Exp $ */
d163 1
d383 1
@


1.13
log
@Make some functions which return unused values void (mostly found by lint) and
tweak a redundant expression in window_pane_set_mode.
@
text
@d1 1
a1 1
/* $OpenBSD: server.c,v 1.12 2009/07/20 14:37:51 nicm Exp $ */
d805 7
a811 2
			else
				window_pane_key(wp, c, key);
d817 1
a817 1
		if ((bd = key_bindings_lookup(key)) == NULL) {
@


1.12
log
@Display the number of failed password attempts (if any) when the server is
locked. From Tom Doherty.
@
text
@d1 1
a1 1
/* $OpenBSD: server.c,v 1.11 2009/07/19 13:21:40 nicm Exp $ */
d47 1
d56 1
a56 1
struct client	*server_accept_client(int);
d73 1
a73 1
struct client *
d111 1
a111 1
			return (c);
a114 1
	return (c);
d738 1
a738 1
struct client *
d748 1
a748 1
			return (NULL);
d753 1
a753 1
		return (NULL);
d755 1
a755 1
	return (server_create_client(fd));
@


1.11
log
@Improved layout code.

Each window now has a tree of layout cells associated with it. In this tree,
each node is either a horizontal or vertical cell containing a list of other
cells running from left-to-right or top-to-bottom, or a leaf cell which is
associated with a pane.

The major functional changes are:

- panes may now be split arbitrarily both horizontally (splitw -h, C-b %) and
  vertically (splitw -v, C-b ");
- panes may be resized both horizontally and vertically (resizep -L/-R/-U/-D,
  bound to C-b left/right/up/down and C-b M-left/right/up/down);
- layouts are now applied and then may be modified by resizing or splitting
  panes, rather than being fixed and reapplied when the window is resized or
  panes are added;
- manual-vertical layout is no longer necessary, and active-only layout is gone
  (but may return in future);
- the main-pane layouts now reduce the size of the main pane to fit all panes
  if possible.

Thanks to all who tested.
@
text
@d1 1
a1 1
/* $OpenBSD: server.c,v 1.10 2009/07/18 14:59:25 nicm Exp $ */
d582 1
d593 4
d601 7
@


1.10
log
@Add three new session options: visual-activity, visual-bell, visual-content. If
these are enabled (and the monitor-activity, bell-actio and monitor-content
options are configurated appropriately), when activity, a bell, or content is
detected, a message is shown.

Also tidy up the bell/activity/content code in server.c slightly and fix a
couple of errors.
@
text
@d1 1
a1 1
/* $OpenBSD: server.c,v 1.9 2009/07/14 19:03:16 nicm Exp $ */
d843 3
a845 1
	if (wp->yoff + s->cy < c->tty.sy - status)
d1077 1
a1079 1
			layout_refresh(w, 0);
@


1.9
log
@Instead of faking up a status line in status_redraw, use the same code to
redraw it as to draw the entire screen, just skip all lines but the last.

This makes horizontal split redraw properly when the status line is off.
@
text
@d1 1
a1 1
/* $OpenBSD: server.c,v 1.8 2009/07/12 17:33:18 nicm Exp $ */
d58 1
a58 2
int		 server_check_window_bell(struct session *, struct window *,
		      struct window_pane *);
d911 1
a911 1
		update += server_check_window_bell(s, w, wp);
d922 1
a922 2
server_check_window_bell(
    struct session *s, struct window *w, struct window_pane *wp)
d926 1
a926 1
	int		 action;
d939 1
d942 3
a944 1
			if (c != NULL && c->session == s)
d946 8
d957 1
a957 1
		if (w->active != wp)
d959 1
d962 5
a966 1
			if (c != NULL && c->session == s)
d968 3
d980 3
d985 1
d988 1
d991 3
d995 12
d1014 6
a1019 1
	char	*found, *ptr;
d1021 2
a1022 1
	if (!(w->flags & WINDOW_CONTENT))
d1024 2
a1025 1
	if ((ptr = options_get_string(&w->options, "monitor-content")) == NULL)
d1027 1
a1027 3
	if (*ptr == '\0')
		return (0);
	if (session_alert_has_window(s, w, WINDOW_CONTENT))
d1029 1
d1032 2
d1035 12
a1046 1
    	xfree(found);
@


1.8
log
@Creating a key binding which replaces itself (such as "bind x bind x lsw")
frees the command list bound to the key while it is still being executed,
leading to a use after free. To prevent this, create a dead keys list and defer
freeing replaced or removed key bindings until the main loop when the key
binding will have finished executing.

Found by Johan Friis when creating a key binding to reload his configuration
file.
@
text
@d1 1
a1 1
/* $OpenBSD: server.c,v 1.7 2009/07/12 16:07:56 nicm Exp $ */
d560 1
a560 1
 			screen_redraw_screen(c);
d570 1
a570 1
		screen_redraw_status(c);
d601 1
a601 1
	screen_redraw_status(c);
@


1.7
log
@If it exist, load a system-wide configuration file /etc/tmux.conf before any
user-specified one.
@
text
@d1 1
a1 1
/* $OpenBSD: server.c,v 1.6 2009/07/07 19:49:19 nicm Exp $ */
d349 3
@


1.6
log
@Rename the global options variables to be shorter and to make session options
clear. No functional change, getting this out of the way to make later options
changes easier.
@
text
@d1 1
a1 1
/* $OpenBSD: server.c,v 1.5 2009/06/26 22:12:19 nicm Exp $ */
d174 11
@


1.5
log
@After logging (if enabled) is switched to file, there is no reason to keep
stdin/stdout/stderr active, so dup them to /dev/null.
@
text
@d1 1
a1 1
/* $OpenBSD: server.c,v 1.4 2009/06/25 22:09:20 nicm Exp $ */
d376 2
a377 2
	options_free(&global_options);
	options_free(&global_window_options);
d576 2
a577 4
	colour = options_get_number(
	    &global_window_options, "clock-mode-colour");
	style = options_get_number(
	    &global_window_options, "clock-mode-style");
d1063 1
a1063 1
	xtimeout = options_get_number(&global_options, "lock-after-time");
@


1.4
log
@Remove some dead assignments, found by sthen with clang.
@
text
@d1 1
a1 1
/* $OpenBSD: server.c,v 1.3 2009/06/24 22:49:56 nicm Exp $ */
d28 1
d135 1
a135 1
	int	pair[2], srv_fd;
d179 12
@


1.3
log
@Change find-window and monitor-content to use fnmatch(3). For convenience and
compatibility, *s are implicitly added at the start and end of the pattern.

Also display the line number and the entire line in the results, and lose the
nasty section_string function and the now empty util.c file.

Initially from Tiago Cunha.
@
text
@d1 1
a1 1
/* $OpenBSD: server.c,v 1.2 2009/06/24 17:36:15 nicm Exp $ */
d291 1
a291 1
		if ((nfds = poll(pfds, nfds, xtimeout)) == -1) {
@


1.2
log
@Make remain-on-exit work again when there is only one pane left, which was
broken sometime during the pane/layout changes. Reported/tested by Iain Morgan,
thanks.
@
text
@d1 1
a1 1
/* $OpenBSD: server.c,v 1.1 2009/06/01 22:58:49 nicm Exp $ */
d962 1
a962 1
	if ((found = window_pane_search(wp, ptr)) == NULL)
@


1.1
log
@Import tmux, a terminal multiplexor allowing (among other things) a single
terminal to be switched between several different windows and programs
displayed on one terminal be detached from one terminal and moved to another.

ok deraadt pirofti
@
text
@d1 1
a1 1
/* $OpenBSD$ */
d969 1
a969 1
/* Check if window still exists.. */
d987 7
a993 3
		if (wp->fd != -1)
			destroyed = 0;
		else if (!flag) {
d997 2
a998 1
		}
@

