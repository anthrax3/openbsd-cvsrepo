head	1.144;
access;
symbols
	OPENBSD_6_1:1.123.0.4
	OPENBSD_6_1_BASE:1.123
	OPENBSD_6_0:1.107.0.2
	OPENBSD_6_0_BASE:1.107
	OPENBSD_5_9:1.105.0.2
	OPENBSD_5_9_BASE:1.105
	OPENBSD_5_8:1.75.0.4
	OPENBSD_5_8_BASE:1.75
	OPENBSD_5_7:1.58.0.2
	OPENBSD_5_7_BASE:1.58
	OPENBSD_5_6:1.47.0.4
	OPENBSD_5_6_BASE:1.47
	OPENBSD_5_5:1.40.0.4
	OPENBSD_5_5_BASE:1.40
	OPENBSD_5_4:1.26.0.2
	OPENBSD_5_4_BASE:1.26
	OPENBSD_5_3:1.12.0.2
	OPENBSD_5_3_BASE:1.12
	OPENBSD_5_2:1.9.0.2
	OPENBSD_5_2_BASE:1.9
	OPENBSD_5_1_BASE:1.6
	OPENBSD_5_1:1.6.0.2;
locks; strict;
comment	@ * @;


1.144
date	2017.07.27.10.42.05;	author nicm;	state Exp;
branches;
next	1.143;
commitid	GpJ139WCZJhx0UUo;

1.143
date	2017.07.07.14.39.45;	author nicm;	state Exp;
branches;
next	1.142;
commitid	XdQobahcWfsB7PTl;

1.142
date	2017.05.31.17.56.48;	author nicm;	state Exp;
branches;
next	1.141;
commitid	whraM4PaXDvaTw5s;

1.141
date	2017.05.30.21.44.59;	author nicm;	state Exp;
branches;
next	1.140;
commitid	ai2b3hkAsUowPSMm;

1.140
date	2017.05.29.18.06.34;	author nicm;	state Exp;
branches;
next	1.139;
commitid	728WJnnykoH2198t;

1.139
date	2017.05.29.15.43.48;	author nicm;	state Exp;
branches;
next	1.138;
commitid	lLdjo9JMMa8zEJJY;

1.138
date	2017.05.12.22.43.15;	author nicm;	state Exp;
branches;
next	1.137;
commitid	C0DHIpxeZhlk4sML;

1.137
date	2017.05.12.22.42.46;	author nicm;	state Exp;
branches;
next	1.136;
commitid	rpU1hcNIscaTdRRg;

1.136
date	2017.05.12.13.27.57;	author nicm;	state Exp;
branches;
next	1.135;
commitid	wPLDLniWacsiMbSQ;

1.135
date	2017.05.12.10.45.38;	author nicm;	state Exp;
branches;
next	1.134;
commitid	jng8rFxtzJgvDp1f;

1.134
date	2017.05.07.22.27.57;	author nicm;	state Exp;
branches;
next	1.133;
commitid	w7Gc3icV91j6BiYu;

1.133
date	2017.05.05.11.59.47;	author nicm;	state Exp;
branches;
next	1.132;
commitid	KUlkX3dFRhjvqCpc;

1.132
date	2017.05.03.05.53.34;	author nicm;	state Exp;
branches;
next	1.131;
commitid	koR7M5sfoImvwKg7;

1.131
date	2017.05.01.12.20.55;	author nicm;	state Exp;
branches;
next	1.130;
commitid	sAXCoXWmq7A1UnAP;

1.130
date	2017.04.21.14.01.19;	author nicm;	state Exp;
branches;
next	1.129;
commitid	6dh4rgGOD5wckeD9;

1.129
date	2017.04.20.09.43.45;	author nicm;	state Exp;
branches;
next	1.128;
commitid	wTqD4LJDLZSJgn81;

1.128
date	2017.04.20.09.39.07;	author nicm;	state Exp;
branches;
next	1.127;
commitid	UvG2E3PZHiLbgCmS;

1.127
date	2017.04.20.09.20.22;	author nicm;	state Exp;
branches;
next	1.126;
commitid	Mq5Wq9pThOn7RhSJ;

1.126
date	2017.04.19.06.52.27;	author nicm;	state Exp;
branches;
next	1.125;
commitid	J75yaiuz8O54rLmn;

1.125
date	2017.04.18.15.44.17;	author nicm;	state Exp;
branches;
next	1.124;
commitid	bYu9iw9cp97E6crN;

1.124
date	2017.04.05.10.49.46;	author nicm;	state Exp;
branches;
next	1.123;
commitid	1mjoRYvghWl25dW0;

1.123
date	2017.03.08.13.36.12;	author nicm;	state Exp;
branches;
next	1.122;
commitid	jI8R4kuPSDw6nngR;

1.122
date	2017.02.09.15.04.53;	author nicm;	state Exp;
branches;
next	1.121;
commitid	LotTNNNN3Vrlt9Fn;

1.121
date	2017.02.07.18.06.42;	author nicm;	state Exp;
branches;
next	1.120;
commitid	x5r2mFQ2wJE50YHb;

1.120
date	2017.02.03.11.57.27;	author nicm;	state Exp;
branches;
next	1.119;
commitid	BLRh0qXo7OVTPhiT;

1.119
date	2017.02.01.09.55.07;	author nicm;	state Exp;
branches;
next	1.118;
commitid	FpFenXzt7GohJ3lb;

1.118
date	2017.01.30.21.41.17;	author nicm;	state Exp;
branches;
next	1.117;
commitid	2CvN8VpguQcq8POo;

1.117
date	2017.01.16.14.49.14;	author nicm;	state Exp;
branches;
next	1.116;
commitid	4TgBXjnsq23XHMH4;

1.116
date	2017.01.15.20.48.41;	author nicm;	state Exp;
branches;
next	1.115;
commitid	osUO2wUOqrqm0Q8V;

1.115
date	2017.01.11.16.09.57;	author nicm;	state Exp;
branches;
next	1.114;
commitid	6XANvQoNZoJEjE5C;

1.114
date	2017.01.09.21.03.25;	author nicm;	state Exp;
branches;
next	1.113;
commitid	ZwBJ1q637vKZayHI;

1.113
date	2016.11.17.10.06.08;	author nicm;	state Exp;
branches;
next	1.112;
commitid	pfA3XECBcSQOLE32;

1.112
date	2016.10.16.19.36.37;	author nicm;	state Exp;
branches;
next	1.111;
commitid	UfrPlTlFgpvE2jpY;

1.111
date	2016.10.16.19.04.05;	author nicm;	state Exp;
branches;
next	1.110;
commitid	pxm6osuE99zELpkU;

1.110
date	2016.10.16.17.55.14;	author nicm;	state Exp;
branches;
next	1.109;
commitid	1xIYFpLYkPIXNEvU;

1.109
date	2016.10.11.13.45.47;	author nicm;	state Exp;
branches;
next	1.108;
commitid	m8cwMB6WuKLMPXh5;

1.108
date	2016.10.10.21.29.23;	author nicm;	state Exp;
branches;
next	1.107;
commitid	z4Hr4PZF7Ev93uEJ;

1.107
date	2016.05.23.20.39.26;	author nicm;	state Exp;
branches;
next	1.106;
commitid	CPIHobsZxckqPTmB;

1.106
date	2016.04.29.14.05.24;	author nicm;	state Exp;
branches;
next	1.105;
commitid	wZaePCOma60t58oN;

1.105
date	2016.01.31.09.54.46;	author nicm;	state Exp;
branches;
next	1.104;
commitid	oAWyhU18KzfHWLS1;

1.104
date	2016.01.19.15.59.12;	author nicm;	state Exp;
branches;
next	1.103;
commitid	P3qmSOx6KrDBsb0c;

1.103
date	2015.12.12.18.32.24;	author nicm;	state Exp;
branches;
next	1.102;
commitid	q7iDAcShsJWlLYhr;

1.102
date	2015.12.11.12.27.36;	author nicm;	state Exp;
branches;
next	1.101;
commitid	ns7JfXpW9TsHrnT3;

1.101
date	2015.12.08.08.34.18;	author nicm;	state Exp;
branches;
next	1.100;
commitid	MRfGAYPLeVqV46rT;

1.100
date	2015.11.24.21.52.06;	author nicm;	state Exp;
branches;
next	1.99;
commitid	Wy0S0Ml5dOX2TIOy;

1.99
date	2015.11.18.14.27.44;	author nicm;	state Exp;
branches;
next	1.98;
commitid	RjsAPRkWwvS79w40;

1.98
date	2015.11.18.14.13.55;	author nicm;	state Exp;
branches;
next	1.97;
commitid	6kYbPIRshE0950Wv;

1.97
date	2015.11.13.12.18.52;	author nicm;	state Exp;
branches;
next	1.96;
commitid	3DFPxebuSqPBSCxc;

1.96
date	2015.11.13.10.00.26;	author nicm;	state Exp;
branches;
next	1.95;
commitid	XBr52OmGRr7N73uY;

1.95
date	2015.11.13.08.09.28;	author nicm;	state Exp;
branches;
next	1.94;
commitid	3vFd8TIqn7NVGuk0;

1.94
date	2015.11.12.11.09.11;	author nicm;	state Exp;
branches;
next	1.93;
commitid	tEN3cHiOuN3KscbT;

1.93
date	2015.11.12.11.07.10;	author nicm;	state Exp;
branches;
next	1.92;
commitid	KbUixzkkNinCEW1g;

1.92
date	2015.10.31.08.13.58;	author nicm;	state Exp;
branches;
next	1.91;
commitid	B5GekkO0CdWpFMrz;

1.91
date	2015.10.28.09.51.55;	author nicm;	state Exp;
branches;
next	1.90;
commitid	eGVGKzVVYKHFvkn4;

1.90
date	2015.10.27.15.58.42;	author nicm;	state Exp;
branches;
next	1.89;
commitid	89xhQafU35Q5MQVC;

1.89
date	2015.10.27.09.28.31;	author nicm;	state Exp;
branches;
next	1.88;
commitid	bdxJiCO6ICmMCg1i;

1.88
date	2015.10.27.09.18.06;	author nicm;	state Exp;
branches;
next	1.87;
commitid	9uivQ3nxtfNDGLVe;

1.87
date	2015.10.25.22.29.17;	author nicm;	state Exp;
branches;
next	1.86;
commitid	lyC76bFrgfVLq7ku;

1.86
date	2015.10.25.08.59.26;	author nicm;	state Exp;
branches;
next	1.85;
commitid	eIJWBJQsyicJYMUm;

1.85
date	2015.10.23.16.02.21;	author nicm;	state Exp;
branches;
next	1.84;
commitid	dVDXU9Ok8jlPT5fI;

1.84
date	2015.09.14.10.25.52;	author nicm;	state Exp;
branches;
next	1.83;
commitid	UTR5DL8aBfSehB3O;

1.83
date	2015.09.10.08.58.14;	author nicm;	state Exp;
branches;
next	1.82;
commitid	fjYzZVETyEmTAStI;

1.82
date	2015.09.03.14.30.23;	author nicm;	state Exp;
branches;
next	1.81;
commitid	bw4E49eG9lQRqXVw;

1.81
date	2015.08.29.09.25.00;	author nicm;	state Exp;
branches;
next	1.80;
commitid	UXoQGD7QOZAJI1XC;

1.80
date	2015.08.28.17.01.42;	author nicm;	state Exp;
branches;
next	1.79;
commitid	de9IxkiGYY09YILj;

1.79
date	2015.08.28.16.46.40;	author nicm;	state Exp;
branches;
next	1.78;
commitid	7S6rw4eFrVJwC5RB;

1.78
date	2015.08.28.12.16.28;	author nicm;	state Exp;
branches;
next	1.77;
commitid	LqkiQ6rY2EYTPxv3;

1.77
date	2015.08.28.11.38.27;	author nicm;	state Exp;
branches;
next	1.76;
commitid	Tft8aiYUxsfXokWg;

1.76
date	2015.08.28.10.06.52;	author nicm;	state Exp;
branches;
next	1.75;
commitid	rtePJoUcvKw62ne4;

1.75
date	2015.07.13.15.37.26;	author nicm;	state Exp;
branches;
next	1.74;
commitid	MXrp0CD24CxANcKO;

1.74
date	2015.06.18.23.55.24;	author nicm;	state Exp;
branches;
next	1.73;
commitid	lyqKrG2jqFMGT1W0;

1.73
date	2015.06.15.10.58.01;	author nicm;	state Exp;
branches;
next	1.72;
commitid	HBSnpNJTrYXYaYTN;

1.72
date	2015.06.14.10.07.44;	author nicm;	state Exp;
branches;
next	1.71;
commitid	0pZ95JQFEhIowUtr;

1.71
date	2015.06.10.12.56.04;	author nicm;	state Exp;
branches;
next	1.70;
commitid	IsY9zB0kRvnazUMf;

1.70
date	2015.05.29.23.26.52;	author nicm;	state Exp;
branches;
next	1.69;
commitid	ivHzVQ23bfdDeFTe;

1.69
date	2015.05.29.23.12.38;	author nicm;	state Exp;
branches;
next	1.68;
commitid	RwhLSsKLHFmbSDaB;

1.68
date	2015.05.27.13.28.04;	author nicm;	state Exp;
branches;
next	1.67;
commitid	jNiCCHdN1zYsiWiL;

1.67
date	2015.05.20.06.39.02;	author nicm;	state Exp;
branches;
next	1.66;
commitid	Gf18MFs2cIpCPBWT;

1.66
date	2015.05.12.15.29.29;	author nicm;	state Exp;
branches;
next	1.65;
commitid	pHyo7O6edHQdopKa;

1.65
date	2015.05.08.16.18.04;	author nicm;	state Exp;
branches;
next	1.64;
commitid	jGuK9ADiqvyOz7AE;

1.64
date	2015.05.06.08.35.39;	author nicm;	state Exp;
branches;
next	1.63;
commitid	7XqxdN1FHegvjfQk;

1.63
date	2015.04.21.22.38.49;	author nicm;	state Exp;
branches;
next	1.62;
commitid	MULQMBCHDfIGQ0ED;

1.62
date	2015.04.21.15.18.38;	author nicm;	state Exp;
branches;
next	1.61;
commitid	zgsbRt5RpvxQ5s5I;

1.61
date	2015.04.20.15.34.56;	author nicm;	state Exp;
branches;
next	1.60;
commitid	1fc4pMkRD7YjyQWP;

1.60
date	2015.03.31.17.58.36;	author nicm;	state Exp;
branches;
next	1.59;
commitid	q3za2CHNdxysAEy9;

1.59
date	2015.03.31.17.45.10;	author nicm;	state Exp;
branches;
next	1.58;
commitid	2uQloBaX92ri1PyE;

1.58
date	2015.02.06.17.11.39;	author nicm;	state Exp;
branches;
next	1.57;
commitid	524Kssnx5Ady6qyZ;

1.57
date	2015.02.05.10.29.43;	author nicm;	state Exp;
branches;
next	1.56;
commitid	b1G1TVWY7l4KyoY6;

1.56
date	2015.01.11.04.14.40;	author deraadt;	state Exp;
branches;
next	1.55;
commitid	j8CWcMD2p0OrOH19;

1.55
date	2014.12.09.19.23.35;	author nicm;	state Exp;
branches;
next	1.54;
commitid	F9Ad8BPsskeeEtGX;

1.54
date	2014.12.02.23.19.45;	author nicm;	state Exp;
branches;
next	1.53;
commitid	gPfaYZLsz4KUq58B;

1.53
date	2014.12.01.14.30.18;	author nicm;	state Exp;
branches;
next	1.52;
commitid	f8aUAcybehkSe466;

1.52
date	2014.11.08.12.50.38;	author nicm;	state Exp;
branches;
next	1.51;
commitid	j6KvDy0w9G9LsIae;

1.51
date	2014.10.25.08.47.04;	author nicm;	state Exp;
branches;
next	1.50;
commitid	EL8qayrhcDXf5Ris;

1.50
date	2014.10.08.17.35.58;	author nicm;	state Exp;
branches;
next	1.49;
commitid	mK8z9uVwDZMfiNoM;

1.49
date	2014.09.08.14.29.05;	author nicm;	state Exp;
branches;
next	1.48;
commitid	biBiUFLYYgChJ8LI;

1.48
date	2014.08.09.07.33.37;	author nicm;	state Exp;
branches;
next	1.47;
commitid	EaH1ezsTMWHeIyGh;

1.47
date	2014.05.27.12.49.36;	author nicm;	state Exp;
branches;
next	1.46;

1.46
date	2014.05.13.08.08.32;	author nicm;	state Exp;
branches;
next	1.45;

1.45
date	2014.05.13.07.34.35;	author nicm;	state Exp;
branches;
next	1.44;

1.44
date	2014.04.17.15.37.55;	author nicm;	state Exp;
branches;
next	1.43;

1.43
date	2014.04.17.07.36.45;	author nicm;	state Exp;
branches;
next	1.42;

1.42
date	2014.04.02.18.12.18;	author nicm;	state Exp;
branches;
next	1.41;

1.41
date	2014.03.31.21.37.55;	author nicm;	state Exp;
branches;
next	1.40;

1.40
date	2013.11.24.11.29.09;	author nicm;	state Exp;
branches;
next	1.39;

1.39
date	2013.10.11.08.03.43;	author nicm;	state Exp;
branches;
next	1.38;

1.38
date	2013.10.11.08.01.29;	author nicm;	state Exp;
branches;
next	1.37;

1.37
date	2013.10.10.23.31.03;	author nicm;	state Exp;
branches;
next	1.36;

1.36
date	2013.10.10.12.39.24;	author nicm;	state Exp;
branches;
next	1.35;

1.35
date	2013.10.10.12.35.31;	author nicm;	state Exp;
branches;
next	1.34;

1.34
date	2013.10.10.12.26.35;	author nicm;	state Exp;
branches;
next	1.33;

1.33
date	2013.10.10.12.04.01;	author nicm;	state Exp;
branches;
next	1.32;

1.32
date	2013.10.10.11.56.50;	author nicm;	state Exp;
branches;
next	1.31;

1.31
date	2013.10.10.11.50.36;	author nicm;	state Exp;
branches;
next	1.30;

1.30
date	2013.10.10.11.50.20;	author nicm;	state Exp;
branches;
next	1.29;

1.29
date	2013.10.10.11.47.52;	author nicm;	state Exp;
branches;
next	1.28;

1.28
date	2013.10.10.11.47.28;	author nicm;	state Exp;
branches;
next	1.27;

1.27
date	2013.10.10.11.47.11;	author nicm;	state Exp;
branches;
next	1.26;

1.26
date	2013.07.05.15.27.14;	author nicm;	state Exp;
branches;
next	1.25;

1.25
date	2013.05.31.19.46.42;	author nicm;	state Exp;
branches;
next	1.24;

1.24
date	2013.04.17.14.52.31;	author deraadt;	state Exp;
branches;
next	1.23;

1.23
date	2013.03.25.11.40.54;	author nicm;	state Exp;
branches;
next	1.22;

1.22
date	2013.03.25.10.11.45;	author nicm;	state Exp;
branches;
next	1.21;

1.21
date	2013.03.25.10.07.21;	author nicm;	state Exp;
branches;
next	1.20;

1.20
date	2013.03.24.09.54.10;	author nicm;	state Exp;
branches;
next	1.19;

1.19
date	2013.03.24.09.29.40;	author nicm;	state Exp;
branches;
next	1.18;

1.18
date	2013.03.24.09.23.00;	author nicm;	state Exp;
branches;
next	1.17;

1.17
date	2013.03.24.09.19.51;	author nicm;	state Exp;
branches;
next	1.16;

1.16
date	2013.03.22.16.03.35;	author nicm;	state Exp;
branches;
next	1.15;

1.15
date	2013.03.22.10.32.36;	author nicm;	state Exp;
branches;
next	1.14;

1.14
date	2013.03.21.16.14.09;	author nicm;	state Exp;
branches;
next	1.13;

1.13
date	2013.03.21.16.13.24;	author nicm;	state Exp;
branches;
next	1.12;

1.12
date	2013.02.05.11.01.45;	author nicm;	state Exp;
branches;
next	1.11;

1.11
date	2013.01.18.02.16.21;	author nicm;	state Exp;
branches;
next	1.10;

1.10
date	2012.09.24.13.05.10;	author nicm;	state Exp;
branches;
next	1.9;

1.9
date	2012.07.10.11.53.01;	author nicm;	state Exp;
branches;
next	1.8;

1.8
date	2012.05.22.11.35.37;	author nicm;	state Exp;
branches;
next	1.7;

1.7
date	2012.04.01.10.42.39;	author nicm;	state Exp;
branches;
next	1.6;

1.6
date	2012.02.02.00.03.45;	author nicm;	state Exp;
branches;
next	1.5;

1.5
date	2012.01.30.09.39.34;	author nicm;	state Exp;
branches;
next	1.4;

1.4
date	2011.11.15.23.21.52;	author nicm;	state Exp;
branches;
next	1.3;

1.3
date	2011.10.23.01.12.46;	author nicm;	state Exp;
branches;
next	1.2;

1.2
date	2011.10.02.06.55.48;	author nicm;	state Exp;
branches;
next	1.1;

1.1
date	2011.08.26.10.53.16;	author nicm;	state Exp;
branches;
next	;


desc
@@


1.144
log
@Add pane_at_left/right/top/bottom formats, from Amos Bird.
@
text
@/* $OpenBSD: format.c,v 1.143 2017/07/07 14:39:45 nicm Exp $ */

/*
 * Copyright (c) 2011 Nicholas Marriott <nicholas.marriott@@gmail.com>
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF MIND, USE, DATA OR PROFITS, WHETHER
 * IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING
 * OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */

#include <sys/types.h>
#include <sys/wait.h>

#include <errno.h>
#include <fnmatch.h>
#include <libgen.h>
#include <stdarg.h>
#include <stdlib.h>
#include <string.h>
#include <time.h>
#include <unistd.h>

#include "tmux.h"

/*
 * Build a list of key-value pairs and use them to expand #{key} entries in a
 * string.
 */

struct format_entry;
typedef void (*format_cb)(struct format_tree *, struct format_entry *);

static char	*format_job_get(struct format_tree *, const char *);
static void	 format_job_timer(int, short, void *);

static char	*format_find(struct format_tree *, const char *, int);
static void	 format_add_cb(struct format_tree *, const char *, format_cb);
static void	 format_add_tv(struct format_tree *, const char *,
		     struct timeval *);
static int	 format_replace(struct format_tree *, const char *, size_t,
		     char **, size_t *, size_t *);

static void	 format_defaults_session(struct format_tree *,
		     struct session *);
static void	 format_defaults_client(struct format_tree *, struct client *);
static void	 format_defaults_winlink(struct format_tree *,
		     struct winlink *);

/* Entry in format job tree. */
struct format_job {
	struct client		*client;
	u_int			 tag;
	const char		*cmd;
	const char		*expanded;

	time_t			 last;
	char			*out;
	int			 updated;

	struct job		*job;
	int			 status;

	RB_ENTRY(format_job)	 entry;
};

/* Format job tree. */
static struct event format_job_event;
static int format_job_cmp(struct format_job *, struct format_job *);
static RB_HEAD(format_job_tree, format_job) format_jobs = RB_INITIALIZER();
RB_GENERATE_STATIC(format_job_tree, format_job, entry, format_job_cmp);

/* Format job tree comparison function. */
static int
format_job_cmp(struct format_job *fj1, struct format_job *fj2)
{
	if (fj1->tag < fj2->tag)
		return (-1);
	if (fj1->tag > fj2->tag)
		return (1);
	return (strcmp(fj1->cmd, fj2->cmd));
}

/* Format modifiers. */
#define FORMAT_TIMESTRING 0x1
#define FORMAT_BASENAME 0x2
#define FORMAT_DIRNAME 0x4
#define FORMAT_SUBSTITUTE 0x8

/* Entry in format tree. */
struct format_entry {
	char			*key;
	char			*value;
	time_t			 t;
	format_cb		 cb;
	RB_ENTRY(format_entry)	 entry;
};

/* Format entry tree. */
struct format_tree {
	struct window		*w;
	struct winlink		*wl;
	struct session		*s;
	struct window_pane	*wp;

	struct client		*client;
	u_int			 tag;
	int			 flags;

	RB_HEAD(format_entry_tree, format_entry) tree;
};
static int format_entry_cmp(struct format_entry *, struct format_entry *);
RB_GENERATE_STATIC(format_entry_tree, format_entry, entry, format_entry_cmp);

/* Format entry tree comparison function. */
static int
format_entry_cmp(struct format_entry *fe1, struct format_entry *fe2)
{
	return (strcmp(fe1->key, fe2->key));
}

/* Single-character uppercase aliases. */
static const char *format_upper[] = {
	NULL,		/* A */
	NULL,		/* B */
	NULL,		/* C */
	"pane_id",	/* D */
	NULL,		/* E */
	"window_flags",	/* F */
	NULL,		/* G */
	"host",		/* H */
	"window_index",	/* I */
	NULL,		/* J */
	NULL,		/* K */
	NULL,		/* L */
	NULL,		/* M */
	NULL,		/* N */
	NULL,		/* O */
	"pane_index",	/* P */
	NULL,		/* Q */
	NULL,		/* R */
	"session_name",	/* S */
	"pane_title",	/* T */
	NULL,		/* U */
	NULL,		/* V */
	"window_name",	/* W */
	NULL,		/* X */
	NULL,		/* Y */
	NULL 		/* Z */
};

/* Single-character lowercase aliases. */
static const char *format_lower[] = {
	NULL,		/* a */
	NULL,		/* b */
	NULL,		/* c */
	NULL,		/* d */
	NULL,		/* e */
	NULL,		/* f */
	NULL,		/* g */
	"host_short",	/* h */
	NULL,		/* i */
	NULL,		/* j */
	NULL,		/* k */
	NULL,		/* l */
	NULL,		/* m */
	NULL,		/* n */
	NULL,		/* o */
	NULL,		/* p */
	NULL,		/* q */
	NULL,		/* r */
	NULL,		/* s */
	NULL,		/* t */
	NULL,		/* u */
	NULL,		/* v */
	NULL,		/* w */
	NULL,		/* x */
	NULL,		/* y */
	NULL		/* z */
};

/* Format job update callback. */
static void
format_job_update(struct job *job)
{
	struct format_job	*fj = job->data;
	char			*line;
	time_t			 t;

	if ((line = evbuffer_readline(job->event->input)) == NULL)
		return;
	fj->updated = 1;

	free(fj->out);
	fj->out = line;

	log_debug("%s: %p %s: %s", __func__, fj, fj->cmd, fj->out);

	t = time(NULL);
	if (fj->status && fj->last != t) {
		if (fj->client != NULL)
			server_status_client(fj->client);
		fj->last = t;
	}
}

/* Format job complete callback. */
static void
format_job_complete(struct job *job)
{
	struct format_job	*fj = job->data;
	char			*line, *buf;
	size_t			 len;

	fj->job = NULL;

	buf = NULL;
	if ((line = evbuffer_readline(job->event->input)) == NULL) {
		len = EVBUFFER_LENGTH(job->event->input);
		buf = xmalloc(len + 1);
		if (len != 0)
			memcpy(buf, EVBUFFER_DATA(job->event->input), len);
		buf[len] = '\0';
	} else
		buf = line;

	log_debug("%s: %p %s: %s", __func__, fj, fj->cmd, buf);

	if (*buf != '\0' || !fj->updated) {
		free(fj->out);
		fj->out = buf;
	} else
		free(buf);

	if (fj->status) {
		if (fj->client != NULL)
			server_status_client(fj->client);
		fj->status = 0;
	}
}

/* Find a job. */
static char *
format_job_get(struct format_tree *ft, const char *cmd)
{
	struct format_job_tree	*jobs;
	struct format_job	 fj0, *fj;
	time_t			 t;
	char			*expanded;
	int			 force;

	if (ft->client == NULL)
		jobs = &format_jobs;
	else if (ft->client->jobs != NULL)
		jobs = ft->client->jobs;
	else {
		jobs = ft->client->jobs = xmalloc(sizeof *ft->client->jobs);
		RB_INIT(jobs);
	}

	fj0.tag = ft->tag;
	fj0.cmd = cmd;
	if ((fj = RB_FIND(format_job_tree, jobs, &fj0)) == NULL) {
		fj = xcalloc(1, sizeof *fj);
		fj->client = ft->client;
		fj->tag = ft->tag;
		fj->cmd = xstrdup(cmd);
		fj->expanded = NULL;

		xasprintf(&fj->out, "<'%s' not ready>", fj->cmd);

		RB_INSERT(format_job_tree, jobs, fj);
	}

	expanded = format_expand(ft, cmd);
	if (fj->expanded == NULL || strcmp(expanded, fj->expanded) != 0) {
		free((void *)fj->expanded);
		fj->expanded = xstrdup(expanded);
		force = 1;
	} else
		force = (ft->flags & FORMAT_FORCE);

	t = time(NULL);
	if (fj->job == NULL && (force || fj->last != t)) {
		fj->job = job_run(expanded, NULL, NULL, format_job_update,
		    format_job_complete, NULL, fj);
		if (fj->job == NULL) {
			free(fj->out);
			xasprintf(&fj->out, "<'%s' didn't start>", fj->cmd);
		}
		fj->last = t;
		fj->updated = 0;
	}

	if (ft->flags & FORMAT_STATUS)
		fj->status = 1;

	free(expanded);
	return (format_expand(ft, fj->out));
}

/* Remove old jobs. */
static void
format_job_tidy(struct format_job_tree *jobs, int force)
{
	struct format_job	*fj, *fj1;
	time_t			 now;

	now = time(NULL);
	RB_FOREACH_SAFE(fj, format_job_tree, jobs, fj1) {
		if (!force && (fj->last > now || now - fj->last < 3600))
			continue;
		RB_REMOVE(format_job_tree, jobs, fj);

		log_debug("%s: %s", __func__, fj->cmd);

		if (fj->job != NULL)
			job_free(fj->job);

		free((void *)fj->expanded);
		free((void *)fj->cmd);
		free(fj->out);

		free(fj);
	}
}

/* Remove old jobs for client. */
void
format_lost_client(struct client *c)
{
	if (c->jobs != NULL)
		format_job_tidy(c->jobs, 1);
	free(c->jobs);
}

/* Remove old jobs periodically. */
static void
format_job_timer(__unused int fd, __unused short events, __unused void *arg)
{
	struct client	*c;
	struct timeval	 tv = { .tv_sec = 60 };

	format_job_tidy(&format_jobs, 0);
	TAILQ_FOREACH(c, &clients, entry) {
		if (c->jobs != NULL)
			format_job_tidy(c->jobs, 0);
	}

	evtimer_del(&format_job_event);
	evtimer_add(&format_job_event, &tv);
}

/* Callback for host. */
static void
format_cb_host(__unused struct format_tree *ft, struct format_entry *fe)
{
	char host[HOST_NAME_MAX + 1];

	if (gethostname(host, sizeof host) != 0)
		fe->value = xstrdup("");
	else
		fe->value = xstrdup(host);
}

/* Callback for host_short. */
static void
format_cb_host_short(__unused struct format_tree *ft, struct format_entry *fe)
{
	char host[HOST_NAME_MAX + 1], *cp;

	if (gethostname(host, sizeof host) != 0)
		fe->value = xstrdup("");
	else {
		if ((cp = strchr(host, '.')) != NULL)
			*cp = '\0';
		fe->value = xstrdup(host);
	}
}

/* Callback for pid. */
static void
format_cb_pid(__unused struct format_tree *ft, struct format_entry *fe)
{
	xasprintf(&fe->value, "%ld", (long)getpid());
}

/* Callback for session_alerts. */
static void
format_cb_session_alerts(struct format_tree *ft, struct format_entry *fe)
{
	struct session	*s = ft->s;
	struct winlink	*wl;
	char		 alerts[1024], tmp[16];

	if (s == NULL)
		return;

	*alerts = '\0';
	RB_FOREACH(wl, winlinks, &s->windows) {
		if ((wl->flags & WINLINK_ALERTFLAGS) == 0)
			continue;
		xsnprintf(tmp, sizeof tmp, "%u", wl->idx);

		if (*alerts != '\0')
			strlcat(alerts, ",", sizeof alerts);
		strlcat(alerts, tmp, sizeof alerts);
		if (wl->flags & WINLINK_ACTIVITY)
			strlcat(alerts, "#", sizeof alerts);
		if (wl->flags & WINLINK_BELL)
			strlcat(alerts, "!", sizeof alerts);
		if (wl->flags & WINLINK_SILENCE)
			strlcat(alerts, "~", sizeof alerts);
	}
	fe->value = xstrdup(alerts);
}

/* Callback for session_stack. */
static void
format_cb_session_stack(struct format_tree *ft, struct format_entry *fe)
{
	struct session	*s = ft->s;
	struct winlink	*wl;
	char		 result[1024], tmp[16];

	if (s == NULL)
		return;

	xsnprintf(result, sizeof result, "%u", s->curw->idx);
	TAILQ_FOREACH(wl, &s->lastw, sentry) {
		xsnprintf(tmp, sizeof tmp, "%u", wl->idx);

		if (*result != '\0')
			strlcat(result, ",", sizeof result);
		strlcat(result, tmp, sizeof result);
	}
	fe->value = xstrdup(result);
}

/* Callback for window_stack_index. */
static void
format_cb_window_stack_index(struct format_tree *ft, struct format_entry *fe)
{
	struct session	*s = ft->wl->session;
	struct winlink	*wl;
	u_int		 idx;

	idx = 0;
	TAILQ_FOREACH(wl, &s->lastw, sentry) {
		idx++;
		if (wl == ft->wl)
			break;
	}
	if (wl != NULL)
		xasprintf(&fe->value, "%u", idx);
	else
		fe->value = xstrdup("0");
}

/* Callback for window_layout. */
static void
format_cb_window_layout(struct format_tree *ft, struct format_entry *fe)
{
	struct window	*w = ft->w;

	if (w == NULL)
		return;

	if (w->saved_layout_root != NULL)
		fe->value = layout_dump(w->saved_layout_root);
	else
		fe->value = layout_dump(w->layout_root);
}

/* Callback for window_visible_layout. */
static void
format_cb_window_visible_layout(struct format_tree *ft, struct format_entry *fe)
{
	struct window	*w = ft->w;

	if (w == NULL)
		return;

	fe->value = layout_dump(w->layout_root);
}

/* Callback for pane_start_command. */
static void
format_cb_start_command(struct format_tree *ft, struct format_entry *fe)
{
	struct window_pane	*wp = ft->wp;

	if (wp == NULL)
		return;

	fe->value = cmd_stringify_argv(wp->argc, wp->argv);
}

/* Callback for pane_current_command. */
static void
format_cb_current_command(struct format_tree *ft, struct format_entry *fe)
{
	struct window_pane	*wp = ft->wp;
	char			*cmd;

	if (wp == NULL)
		return;

	cmd = get_proc_name(wp->fd, wp->tty);
	if (cmd == NULL || *cmd == '\0') {
		free(cmd);
		cmd = cmd_stringify_argv(wp->argc, wp->argv);
		if (cmd == NULL || *cmd == '\0') {
			free(cmd);
			cmd = xstrdup(wp->shell);
		}
	}
	fe->value = parse_window_name(cmd);
	free(cmd);
}

/* Callback for history_bytes. */
static void
format_cb_history_bytes(struct format_tree *ft, struct format_entry *fe)
{
	struct window_pane	*wp = ft->wp;
	struct grid		*gd;
	struct grid_line	*gl;
	unsigned long long	 size;
	u_int			 i;

	if (wp == NULL)
		return;
	gd = wp->base.grid;

	size = 0;
	for (i = 0; i < gd->hsize; i++) {
		gl = &gd->linedata[i];
		size += gl->cellsize * sizeof *gl->celldata;
		size += gl->extdsize * sizeof *gl->extddata;
	}
	size += gd->hsize * sizeof *gd->linedata;

	xasprintf(&fe->value, "%llu", size);
}

/* Callback for pane_tabs. */
static void
format_cb_pane_tabs(struct format_tree *ft, struct format_entry *fe)
{
	struct window_pane	*wp = ft->wp;
	struct evbuffer		*buffer;
	u_int			 i;
	int			 size;

	if (wp == NULL)
		return;

	buffer = evbuffer_new();
	for (i = 0; i < wp->base.grid->sx; i++) {
		if (!bit_test(wp->base.tabs, i))
			continue;

		if (EVBUFFER_LENGTH(buffer) > 0)
			evbuffer_add(buffer, ",", 1);
		evbuffer_add_printf(buffer, "%u", i);
	}
	size = EVBUFFER_LENGTH(buffer);
	xasprintf(&fe->value, "%.*s", size, EVBUFFER_DATA(buffer));
	evbuffer_free(buffer);
}

/* Merge a format tree. */
static void
format_merge(struct format_tree *ft, struct format_tree *from)
{
	struct format_entry	*fe;

	RB_FOREACH(fe, format_entry_tree, &from->tree) {
		if (fe->value != NULL)
			format_add(ft, fe->key, "%s", fe->value);
	}
}

/* Create a new tree. */
struct format_tree *
format_create(struct client *c, struct cmdq_item *item, int tag, int flags)
{
	struct format_tree	*ft;

	if (!event_initialized(&format_job_event)) {
		evtimer_set(&format_job_event, format_job_timer, NULL);
		format_job_timer(-1, 0, NULL);
	}

	ft = xcalloc(1, sizeof *ft);
	RB_INIT(&ft->tree);

	if (c != NULL) {
		ft->client = c;
		ft->client->references++;
	}

	ft->tag = tag;
	ft->flags = flags;

	format_add_cb(ft, "host", format_cb_host);
	format_add_cb(ft, "host_short", format_cb_host_short);
	format_add_cb(ft, "pid", format_cb_pid);
	format_add(ft, "socket_path", "%s", socket_path);
	format_add_tv(ft, "start_time", &start_time);

	if (item != NULL) {
		if (item->cmd != NULL)
			format_add(ft, "command", "%s", item->cmd->entry->name);
		if (item->shared != NULL && item->shared->formats != NULL)
			format_merge(ft, item->shared->formats);
	}

	return (ft);
}

/* Free a tree. */
void
format_free(struct format_tree *ft)
{
	struct format_entry	*fe, *fe1;

	RB_FOREACH_SAFE(fe, format_entry_tree, &ft->tree, fe1) {
		RB_REMOVE(format_entry_tree, &ft->tree, fe);
		free(fe->value);
		free(fe->key);
		free(fe);
	}

	if (ft->client != NULL)
		server_client_unref(ft->client);
	free(ft);
}

/* Add a key-value pair. */
void
format_add(struct format_tree *ft, const char *key, const char *fmt, ...)
{
	struct format_entry	*fe;
	struct format_entry	*fe_now;
	va_list			 ap;

	fe = xmalloc(sizeof *fe);
	fe->key = xstrdup(key);

	fe_now = RB_INSERT(format_entry_tree, &ft->tree, fe);
	if (fe_now != NULL) {
		free(fe->key);
		free(fe);
		free(fe_now->value);
		fe = fe_now;
	}

	fe->cb = NULL;
	fe->t = 0;

	va_start(ap, fmt);
	xvasprintf(&fe->value, fmt, ap);
	va_end(ap);
}

/* Add a key and time. */
static void
format_add_tv(struct format_tree *ft, const char *key, struct timeval *tv)
{
	struct format_entry	*fe;
	struct format_entry	*fe_now;

	fe = xmalloc(sizeof *fe);
	fe->key = xstrdup(key);

	fe_now = RB_INSERT(format_entry_tree, &ft->tree, fe);
	if (fe_now != NULL) {
		free(fe->key);
		free(fe);
		free(fe_now->value);
		fe = fe_now;
	}

	fe->cb = NULL;
	fe->t = tv->tv_sec;

	fe->value = NULL;
}

/* Add a key and function. */
static void
format_add_cb(struct format_tree *ft, const char *key, format_cb cb)
{
	struct format_entry	*fe;
	struct format_entry	*fe_now;

	fe = xmalloc(sizeof *fe);
	fe->key = xstrdup(key);

	fe_now = RB_INSERT(format_entry_tree, &ft->tree, fe);
	if (fe_now != NULL) {
		free(fe->key);
		free(fe);
		free(fe_now->value);
		fe = fe_now;
	}

	fe->cb = cb;
	fe->t = 0;

	fe->value = NULL;
}

/* Find a format entry. */
static char *
format_find(struct format_tree *ft, const char *key, int modifiers)
{
	struct format_entry	*fe, fe_find;
	struct environ_entry	*envent;
	static char		 s[64];
	struct options_entry	*o;
	const char		*found;
	int			 idx;
	char			*copy, *saved;

	if (~modifiers & FORMAT_TIMESTRING) {
		o = options_parse_get(global_options, key, &idx, 0);
		if (o == NULL && ft->w != NULL)
			o = options_parse_get(ft->w->options, key, &idx, 0);
		if (o == NULL)
			o = options_parse_get(global_w_options, key, &idx, 0);
		if (o == NULL && ft->s != NULL)
			o = options_parse_get(ft->s->options, key, &idx, 0);
		if (o == NULL)
			o = options_parse_get(global_s_options, key, &idx, 0);
		if (o != NULL) {
			found = options_tostring(o, idx, 1);
			goto found;
		}
	}
	found = NULL;

	fe_find.key = (char *) key;
	fe = RB_FIND(format_entry_tree, &ft->tree, &fe_find);
	if (fe != NULL) {
		if (modifiers & FORMAT_TIMESTRING) {
			if (fe->t == 0)
				return (NULL);
			ctime_r(&fe->t, s);
			s[strcspn(s, "\n")] = '\0';
			found = s;
			goto found;
		}
		if (fe->t != 0) {
			xsnprintf(s, sizeof s, "%lld", (long long)fe->t);
			found = s;
			goto found;
		}
		if (fe->value == NULL && fe->cb != NULL)
			fe->cb(ft, fe);
		found = fe->value;
		goto found;
	}

	if (~modifiers & FORMAT_TIMESTRING) {
		envent = NULL;
		if (ft->s != NULL)
			envent = environ_find(ft->s->environ, key);
		if (envent == NULL)
			envent = environ_find(global_environ, key);
		if (envent != NULL) {
			found = envent->value;
			goto found;
		}
	}

	return (NULL);

found:
	if (found == NULL)
		return (NULL);
	copy = xstrdup(found);
	if (modifiers & FORMAT_BASENAME) {
		saved = copy;
		copy = xstrdup(basename(saved));
		free(saved);
	}
	if (modifiers & FORMAT_DIRNAME) {
		saved = copy;
		copy = xstrdup(dirname(saved));
		free(saved);
	}
	return (copy);
}

/* Skip until comma. */
static char *
format_skip(char *s)
{
	int	brackets = 0;

	for (; *s != '\0'; s++) {
		if (*s == '{')
			brackets++;
		if (*s == '}')
			brackets--;
		if (*s == ',' && brackets == 0)
			break;
	}
	if (*s == '\0')
		return (NULL);
	return (s);
}

/* Return left and right alternatives separated by commas. */
static int
format_choose(char *s, char **left, char **right)
{
	char	*cp;

	cp = format_skip(s);
	if (cp == NULL)
		return (-1);
	*cp = '\0';

	*left = s;
	*right = cp + 1;
	return (0);
}

/* Is this true? */
int
format_true(const char *s)
{
	if (s != NULL && *s != '\0' && (s[0] != '0' || s[1] != '\0'))
		return (1);
	return (0);
}

/* Replace a key. */
static int
format_replace(struct format_tree *ft, const char *key, size_t keylen,
    char **buf, size_t *len, size_t *off)
{
	struct window_pane	*wp = ft->wp;
	char			*copy, *copy0, *endptr, *ptr, *found, *new;
	char			*value, *from = NULL, *to = NULL, *left, *right;
	size_t			 valuelen, newlen, fromlen, tolen, used;
	long			 limit = 0;
	int			 modifiers = 0, compare = 0, search = 0;

	/* Make a copy of the key. */
	copy0 = copy = xmalloc(keylen + 1);
	memcpy(copy, key, keylen);
	copy[keylen] = '\0';

	/* Is there a length limit or whatnot? */
	switch (copy[0]) {
	case 'm':
		if (copy[1] != ':')
			break;
		compare = -2;
		copy += 2;
		break;
	case 'C':
		if (copy[1] != ':')
			break;
		search = 1;
		copy += 2;
		break;
	case '|':
		if (copy[1] != '|' || copy[2] != ':')
			break;
		compare = -3;
		copy += 3;
		break;
	case '&':
		if (copy[1] != '&' || copy[2] != ':')
			break;
		compare = -4;
		copy += 3;
		break;
	case '!':
		if (copy[1] == '=' && copy[2] == ':') {
			compare = -1;
			copy += 3;
			break;
		}
		break;
	case '=':
		if (copy[1] == '=' && copy[2] == ':') {
			compare = 1;
			copy += 3;
			break;
		}
		errno = 0;
		limit = strtol(copy + 1, &endptr, 10);
		if (errno == ERANGE && (limit == LONG_MIN || limit == LONG_MAX))
			break;
		if (*endptr != ':')
			break;
		copy = endptr + 1;
		break;
	case 'b':
		if (copy[1] != ':')
			break;
		modifiers |= FORMAT_BASENAME;
		copy += 2;
		break;
	case 'd':
		if (copy[1] != ':')
			break;
		modifiers |= FORMAT_DIRNAME;
		copy += 2;
		break;
	case 't':
		if (copy[1] != ':')
			break;
		modifiers |= FORMAT_TIMESTRING;
		copy += 2;
		break;
	case 's':
		if (copy[1] != '/')
			break;
		from = copy + 2;
		for (copy = from; *copy != '\0' && *copy != '/'; copy++)
			/* nothing */;
		if (copy[0] != '/' || copy == from) {
			copy = copy0;
			break;
		}
		copy[0] = '\0';
		to = copy + 1;
		for (copy = to; *copy != '\0' && *copy != '/'; copy++)
			/* nothing */;
		if (copy[0] != '/' || copy[1] != ':') {
			copy = copy0;
			break;
		}
		copy[0] = '\0';

		modifiers |= FORMAT_SUBSTITUTE;
		copy += 2;
		break;
	}

	/* Is this a comparison or a conditional? */
	if (search) {
		/* Search in pane. */
		if (wp == NULL)
			value = xstrdup("0");
		else
			xasprintf(&value, "%u", window_pane_search(wp, copy));
	} else if (compare != 0) {
		/* Comparison: compare comma-separated left and right. */
		if (format_choose(copy, &left, &right) != 0)
			goto fail;
		left = format_expand(ft, left);
		right = format_expand(ft, right);
		if (compare == -3 &&
		    (format_true(left) || format_true(right)))
			value = xstrdup("1");
		else if (compare == -4 &&
		    (format_true(left) && format_true(right)))
			value = xstrdup("1");
		else if (compare == 1 && strcmp(left, right) == 0)
			value = xstrdup("1");
		else if (compare == -1 && strcmp(left, right) != 0)
			value = xstrdup("1");
		else if (compare == -2 && fnmatch(left, right, 0) == 0)
			value = xstrdup("1");
		else
			value = xstrdup("0");
		free(right);
		free(left);
	} else if (*copy == '?') {
		/* Conditional: check first and choose second or third. */
		ptr = format_skip(copy);
		if (ptr == NULL)
			goto fail;
		*ptr = '\0';

		found = format_find(ft, copy + 1, modifiers);
		if (found == NULL)
			found = format_expand(ft, copy + 1);
		if (format_choose(ptr + 1, &left, &right) != 0)
			goto fail;

		if (format_true(found))
			value = format_expand(ft, left);
		else
			value = format_expand(ft, right);
		free(found);
	} else {
		/* Neither: look up directly. */
		value = format_find(ft, copy, modifiers);
		if (value == NULL)
			value = xstrdup("");
	}

	/* Perform substitution if any. */
	if (modifiers & FORMAT_SUBSTITUTE) {
		fromlen = strlen(from);
		tolen = strlen(to);

		newlen = strlen(value) + 1;
		copy = new = xmalloc(newlen);
		for (ptr = value; *ptr != '\0'; /* nothing */) {
			if (strncmp(ptr, from, fromlen) != 0) {
				*new++ = *ptr++;
				continue;
			}
			used = new - copy;

			newlen += tolen;
			copy = xrealloc(copy, newlen);

			new = copy + used;
			memcpy(new, to, tolen);

			new += tolen;
			ptr += fromlen;
		}
		*new = '\0';
		free(value);
		value = copy;
	}

	/* Truncate the value if needed. */
	if (limit > 0) {
		new = utf8_trimcstr(value, limit);
		free(value);
		value = new;
	} else if (limit < 0) {
		new = utf8_rtrimcstr(value, -limit);
		free(value);
		value = new;
	}

	/* Expand the buffer and copy in the value. */
	valuelen = strlen(value);
	while (*len - *off < valuelen + 1) {
		*buf = xreallocarray(*buf, 2, *len);
		*len *= 2;
	}
	memcpy(*buf + *off, value, valuelen);
	*off += valuelen;

	free(value);
	free(copy0);
	return (0);

fail:
	free(copy0);
	return (-1);
}

/* Expand keys in a template, passing through strftime first. */
char *
format_expand_time(struct format_tree *ft, const char *fmt, time_t t)
{
	struct tm	*tm;
	char		 s[2048];

	if (fmt == NULL || *fmt == '\0')
		return (xstrdup(""));

	tm = localtime(&t);

	if (strftime(s, sizeof s, fmt, tm) == 0)
		return (xstrdup(""));

	return (format_expand(ft, s));
}

/* Expand keys in a template. */
char *
format_expand(struct format_tree *ft, const char *fmt)
{
	char		*buf, *out;
	const char	*ptr, *s, *saved = fmt;
	size_t		 off, len, n, outlen;
	int     	 ch, brackets;

	if (fmt == NULL)
		return (xstrdup(""));

	len = 64;
	buf = xmalloc(len);
	off = 0;

	while (*fmt != '\0') {
		if (*fmt != '#') {
			while (len - off < 2) {
				buf = xreallocarray(buf, 2, len);
				len *= 2;
			}
			buf[off++] = *fmt++;
			continue;
		}
		fmt++;

		ch = (u_char) *fmt++;
		switch (ch) {
		case '(':
			brackets = 1;
			for (ptr = fmt; *ptr != '\0'; ptr++) {
				if (*ptr == '(')
					brackets++;
				if (*ptr == ')' && --brackets == 0)
					break;
			}
			if (*ptr != ')' || brackets != 0)
				break;
			n = ptr - fmt;

			if (ft->flags & FORMAT_NOJOBS)
				out = xstrdup("");
			else
				out = format_job_get(ft, xstrndup(fmt, n));
			outlen = strlen(out);

			while (len - off < outlen + 1) {
				buf = xreallocarray(buf, 2, len);
				len *= 2;
			}
			memcpy(buf + off, out, outlen);
			off += outlen;

			free(out);

			fmt += n + 1;
			continue;
		case '{':
			brackets = 1;
			for (ptr = fmt; *ptr != '\0'; ptr++) {
				if (*ptr == '{')
					brackets++;
				if (*ptr == '}' && --brackets == 0)
					break;
			}
			if (*ptr != '}' || brackets != 0)
				break;
			n = ptr - fmt;

			if (format_replace(ft, fmt, n, &buf, &len, &off) != 0)
				break;
			fmt += n + 1;
			continue;
		case '#':
			while (len - off < 2) {
				buf = xreallocarray(buf, 2, len);
				len *= 2;
			}
			buf[off++] = '#';
			continue;
		default:
			s = NULL;
			if (ch >= 'A' && ch <= 'Z')
				s = format_upper[ch - 'A'];
			else if (ch >= 'a' && ch <= 'z')
				s = format_lower[ch - 'a'];
			if (s == NULL) {
				while (len - off < 3) {
					buf = xreallocarray(buf, 2, len);
					len *= 2;
				}
				buf[off++] = '#';
				buf[off++] = ch;
				continue;
			}
			n = strlen(s);
			if (format_replace(ft, s, n, &buf, &len, &off) != 0)
				break;
			continue;
		}

		break;
	}
	buf[off] = '\0';

	log_debug("format '%s' -> '%s'", saved, buf);
	return (buf);
}

/* Expand a single string. */
char *
format_single(struct cmdq_item *item, const char *fmt, struct client *c,
    struct session *s, struct winlink *wl, struct window_pane *wp)
{
	struct format_tree	*ft;
	char			*expanded;

	if (item != NULL)
		ft = format_create(item->client, item, FORMAT_NONE, 0);
	else
		ft = format_create(NULL, item, FORMAT_NONE, 0);
	format_defaults(ft, c, s, wl, wp);

	expanded = format_expand(ft, fmt);
	format_free(ft);
	return (expanded);
}

/* Set defaults for any of arguments that are not NULL. */
void
format_defaults(struct format_tree *ft, struct client *c, struct session *s,
    struct winlink *wl, struct window_pane *wp)
{
	if (s == NULL && c != NULL)
		s = c->session;
	if (wl == NULL && s != NULL)
		wl = s->curw;
	if (wp == NULL && wl != NULL)
		wp = wl->window->active;

	if (c != NULL)
		format_defaults_client(ft, c);
	if (s != NULL)
		format_defaults_session(ft, s);
	if (wl != NULL)
		format_defaults_winlink(ft, wl);
	if (wp != NULL)
		format_defaults_pane(ft, wp);
}

/* Set default format keys for a session. */
static void
format_defaults_session(struct format_tree *ft, struct session *s)
{
	struct session_group	*sg;

	ft->s = s;

	format_add(ft, "session_name", "%s", s->name);
	format_add(ft, "session_windows", "%u", winlink_count(&s->windows));
	format_add(ft, "session_width", "%u", s->sx);
	format_add(ft, "session_height", "%u", s->sy);
	format_add(ft, "session_id", "$%u", s->id);

	sg = session_group_contains(s);
	format_add(ft, "session_grouped", "%d", sg != NULL);
	if (sg != NULL)
		format_add(ft, "session_group", "%s", sg->name);

	format_add_tv(ft, "session_created", &s->creation_time);
	format_add_tv(ft, "session_last_attached", &s->last_attached_time);
	format_add_tv(ft, "session_activity", &s->activity_time);

	format_add(ft, "session_attached", "%u", s->attached);
	format_add(ft, "session_many_attached", "%d", s->attached > 1);

	format_add_cb(ft, "session_alerts", format_cb_session_alerts);
	format_add_cb(ft, "session_stack", format_cb_session_stack);
}

/* Set default format keys for a client. */
static void
format_defaults_client(struct format_tree *ft, struct client *c)
{
	struct session	*s;
	const char	*name;
	struct tty	*tty = &c->tty;
	const char	*types[] = TTY_TYPES;

	if (ft->s == NULL)
		ft->s = c->session;

	format_add(ft, "client_name", "%s", c->name);
	format_add(ft, "client_pid", "%ld", (long) c->pid);
	format_add(ft, "client_height", "%u", tty->sy);
	format_add(ft, "client_width", "%u", tty->sx);
	format_add(ft, "client_tty", "%s", c->ttyname);
	format_add(ft, "client_control_mode", "%d",
		!!(c->flags & CLIENT_CONTROL));

	if (tty->term_name != NULL)
		format_add(ft, "client_termname", "%s", tty->term_name);
	if (tty->term_name != NULL)
		format_add(ft, "client_termtype", "%s", types[tty->term_type]);

	format_add_tv(ft, "client_created", &c->creation_time);
	format_add_tv(ft, "client_activity", &c->activity_time);

	format_add(ft, "client_written", "%zu", c->written);
	format_add(ft, "client_discarded", "%zu", c->discarded);

	name = server_client_get_key_table(c);
	if (strcmp(c->keytable->name, name) == 0)
		format_add(ft, "client_prefix", "%d", 0);
	else
		format_add(ft, "client_prefix", "%d", 1);
	format_add(ft, "client_key_table", "%s", c->keytable->name);

	if (tty->flags & TTY_UTF8)
		format_add(ft, "client_utf8", "%d", 1);
	else
		format_add(ft, "client_utf8", "%d", 0);

	if (c->flags & CLIENT_READONLY)
		format_add(ft, "client_readonly", "%d", 1);
	else
		format_add(ft, "client_readonly", "%d", 0);

	s = c->session;
	if (s != NULL)
		format_add(ft, "client_session", "%s", s->name);
	s = c->last_session;
	if (s != NULL && session_alive(s))
		format_add(ft, "client_last_session", "%s", s->name);
}

/* Set default format keys for a window. */
void
format_defaults_window(struct format_tree *ft, struct window *w)
{
	ft->w = w;

	format_add_tv(ft, "window_activity", &w->activity_time);
	format_add(ft, "window_id", "@@%u", w->id);
	format_add(ft, "window_name", "%s", w->name);
	format_add(ft, "window_width", "%u", w->sx);
	format_add(ft, "window_height", "%u", w->sy);
	format_add_cb(ft, "window_layout", format_cb_window_layout);
	format_add_cb(ft, "window_visible_layout",
	    format_cb_window_visible_layout);
	format_add(ft, "window_panes", "%u", window_count_panes(w));
	format_add(ft, "window_zoomed_flag", "%d",
	    !!(w->flags & WINDOW_ZOOMED));
}

/* Set default format keys for a winlink. */
static void
format_defaults_winlink(struct format_tree *ft, struct winlink *wl)
{
	struct session	*s = wl->session;
	struct window	*w = wl->window;

	if (ft->w == NULL)
		ft->w = wl->window;
	ft->wl = wl;

	format_defaults_window(ft, w);

	format_add(ft, "window_index", "%d", wl->idx);
	format_add_cb(ft, "window_stack_index", format_cb_window_stack_index);
	format_add(ft, "window_flags", "%s", window_printable_flags(wl));
	format_add(ft, "window_active", "%d", wl == s->curw);

	format_add(ft, "window_bell_flag", "%d",
	    !!(wl->flags & WINLINK_BELL));
	format_add(ft, "window_activity_flag", "%d",
	    !!(wl->flags & WINLINK_ACTIVITY));
	format_add(ft, "window_silence_flag", "%d",
	    !!(wl->flags & WINLINK_SILENCE));
	format_add(ft, "window_last_flag", "%d",
	    !!(wl == TAILQ_FIRST(&s->lastw)));
	format_add(ft, "window_linked", "%d", session_is_linked(s, wl->window));
}

/* Set default format keys for a window pane. */
void
format_defaults_pane(struct format_tree *ft, struct window_pane *wp)
{
	struct grid	*gd = wp->base.grid;
	u_int		 idx;
	int  		 status, scroll_position;

	if (ft->w == NULL)
		ft->w = wp->window;
	ft->wp = wp;

	format_add(ft, "history_size", "%u", gd->hsize);
	format_add(ft, "history_limit", "%u", gd->hlimit);
	format_add_cb(ft, "history_bytes", format_cb_history_bytes);

	if (window_pane_index(wp, &idx) != 0)
		fatalx("index not found");
	format_add(ft, "pane_index", "%u", idx);

	format_add(ft, "pane_width", "%u", wp->sx);
	format_add(ft, "pane_height", "%u", wp->sy);
	format_add(ft, "pane_title", "%s", wp->base.title);
	format_add(ft, "pane_id", "%%%u", wp->id);
	format_add(ft, "pane_active", "%d", wp == wp->window->active);
	format_add(ft, "pane_input_off", "%d", !!(wp->flags & PANE_INPUTOFF));
	format_add(ft, "pane_pipe", "%d", wp->pipe_fd != -1);

	status = wp->status;
	if (wp->fd == -1 && WIFEXITED(status))
		format_add(ft, "pane_dead_status", "%d", WEXITSTATUS(status));
	format_add(ft, "pane_dead", "%d", wp->fd == -1);

	if (window_pane_visible(wp)) {
		format_add(ft, "pane_left", "%u", wp->xoff);
		format_add(ft, "pane_top", "%u", wp->yoff);
		format_add(ft, "pane_right", "%u", wp->xoff + wp->sx - 1);
		format_add(ft, "pane_bottom", "%u", wp->yoff + wp->sy - 1);
		format_add(ft, "pane_at_left", "%d", wp->xoff == 0);
		format_add(ft, "pane_at_top", "%d", wp->yoff == 0);
		format_add(ft, "pane_at_right", "%d", wp->xoff + wp->sx == wp->window->sx);
		format_add(ft, "pane_at_bottom", "%d", wp->yoff + wp->sy == wp->window->sy);
	}

	format_add(ft, "pane_in_mode", "%d", wp->screen != &wp->base);
	if (wp->mode != NULL)
		format_add(ft, "pane_mode", "%s", wp->mode->name);

	format_add(ft, "pane_synchronized", "%d",
	    !!options_get_number(wp->window->options, "synchronize-panes"));
	if (wp->searchstr != NULL)
		format_add(ft, "pane_search_string", "%s", wp->searchstr);

	format_add(ft, "pane_tty", "%s", wp->tty);
	format_add(ft, "pane_pid", "%ld", (long) wp->pid);
	format_add_cb(ft, "pane_start_command", format_cb_start_command);
	format_add_cb(ft, "pane_current_command", format_cb_current_command);

	format_add(ft, "cursor_x", "%u", wp->base.cx);
	format_add(ft, "cursor_y", "%u", wp->base.cy);
	format_add(ft, "scroll_region_upper", "%u", wp->base.rupper);
	format_add(ft, "scroll_region_lower", "%u", wp->base.rlower);

	scroll_position = window_copy_scroll_position(wp);
	if (scroll_position != -1)
		format_add(ft, "scroll_position", "%d", scroll_position);

	format_add(ft, "alternate_on", "%d", wp->saved_grid ? 1 : 0);
	format_add(ft, "alternate_saved_x", "%u", wp->saved_cx);
	format_add(ft, "alternate_saved_y", "%u", wp->saved_cy);

	format_add(ft, "cursor_flag", "%d",
	    !!(wp->base.mode & MODE_CURSOR));
	format_add(ft, "insert_flag", "%d",
	    !!(wp->base.mode & MODE_INSERT));
	format_add(ft, "keypad_cursor_flag", "%d",
	    !!(wp->base.mode & MODE_KCURSOR));
	format_add(ft, "keypad_flag", "%d",
	    !!(wp->base.mode & MODE_KKEYPAD));
	format_add(ft, "wrap_flag", "%d",
	    !!(wp->base.mode & MODE_WRAP));

	format_add(ft, "mouse_any_flag", "%d",
	    !!(wp->base.mode & ALL_MOUSE_MODES));
	format_add(ft, "mouse_standard_flag", "%d",
	    !!(wp->base.mode & MODE_MOUSE_STANDARD));
	format_add(ft, "mouse_button_flag", "%d",
	    !!(wp->base.mode & MODE_MOUSE_BUTTON));
	format_add(ft, "mouse_all_flag", "%d",
	    !!(wp->base.mode & MODE_MOUSE_ALL));

	format_add_cb(ft, "pane_tabs", format_cb_pane_tabs);
}

/* Set default format keys for paste buffer. */
void
format_defaults_paste_buffer(struct format_tree *ft, struct paste_buffer *pb)
{
	size_t	 bufsize;
	char	*s;

	paste_buffer_data(pb, &bufsize);
	format_add(ft, "buffer_size", "%zu", bufsize);
	format_add(ft, "buffer_name", "%s", paste_buffer_name(pb));

	s = paste_make_sample(pb);
	format_add(ft, "buffer_sample", "%s", s);
	free(s);
}
@


1.143
log
@Add a pane_pipe format to show if pipe-pane is active, GitHub issue 990.
@
text
@d1 1
a1 1
/* $OpenBSD: format.c,v 1.142 2017/05/31 17:56:48 nicm Exp $ */
d1408 4
@


1.142
log
@Style and spacing nits.
@
text
@d1 1
a1 1
/* $OpenBSD: format.c,v 1.141 2017/05/30 21:44:59 nicm Exp $ */
d1396 1
@


1.141
log
@Rewrite of choose mode, both to simplify and tidy the code and to add
some modern features.

Now the common code is in mode-tree.c, which provides an API used by the
three modes now separated into window-{buffer,client,tree}.c. Buffer
mode shows buffers, client mode clients and tree mode a tree of
sessions, windows and panes.

Each mode has a common set of key bindings plus a few that are specific
to the mode. Other changes are:

- each mode has a preview pane: for buffers this is the buffer content
  (very useful), for others it is a preview of the pane;

- items may be sorted in different ways ('O' key);

- multiple items may be tagged and an operation applied to all of them
  (for example, to delete multiple buffers at once);

- in tree mode a command may be run on the selected item (session,
  window, pane) or on tagged items (key ':');

- displayed items may be filtered in tree mode by using a format (this
  is used to implement find-window) (key 'f');

- the custom format (-F) for the display is no longer available;

- shortcut keys change from 0-9, a-z, A-Z which was always a bit weird
  with keys used for other uses to 0-9, M-a to M-z.

Now that the code is simpler, other improvements will come later.

Primary key bindings for each mode are documented under the commands in
the man page (choose-buffer, choose-client, choose-tree).

Parts written by Thomas Adam.
@
text
@d1 1
a1 1
/* $OpenBSD: format.c,v 1.140 2017/05/29 18:06:34 nicm Exp $ */
d206 1
a206 1
	t = time (NULL);
@


1.140
log
@Add ||, && format operators and C: to search pane content.
@
text
@d1 1
a1 1
/* $OpenBSD: format.c,v 1.139 2017/05/29 15:43:48 nicm Exp $ */
a21 1
#include <ctype.h>
a24 1
#include <netdb.h>
d841 1
a841 1
static int
@


1.139
log
@Add m: for fnmatch(3) format matching.
@
text
@d1 1
a1 1
/* $OpenBSD: format.c,v 1.138 2017/05/12 22:43:15 nicm Exp $ */
d851 1
a851 4
/*
 * Replace a key/value pair in buffer. #{blah} is expanded directly,
 * #{?blah,a,b} is replace with a if blah exists and is nonzero else b.
 */
d856 6
a861 5
	char		*copy, *copy0, *endptr, *ptr, *found, *new, *value;
	char		*from = NULL, *to = NULL, *left, *right;
	size_t		 valuelen, newlen, fromlen, tolen, used;
	long		 limit = 0;
	int		 modifiers = 0, compare = 0;
d876 18
d959 7
a965 1
	if (compare != 0) {
d971 7
a977 1
		if (compare == 1 && strcmp(left, right) == 0)
@


1.138
log
@Remove an unused variable.
@
text
@d1 1
a1 1
/* $OpenBSD: format.c,v 1.137 2017/05/12 22:42:46 nicm Exp $ */
d24 1
d872 6
d952 2
@


1.137
log
@Reset updated flag when restarting job so new output is detected,
reported by Gregory Pakosz in GitHub issue 922.
@
text
@d1 1
a1 1
/* $OpenBSD: format.c,v 1.136 2017/05/12 13:27:57 nicm Exp $ */
a196 1
	struct client		*c;
@


1.136
log
@Only redraw single client, and tweak some logging.
@
text
@d1 1
a1 1
/* $OpenBSD: format.c,v 1.135 2017/05/12 10:45:38 nicm Exp $ */
d301 1
@


1.135
log
@Store copy mode search string in pane so search-again command works even
if you exit and reenter copy mode (it doesn't remember the position,
just the search string), suggested by espie@@.
@
text
@d1 1
a1 1
/* $OpenBSD: format.c,v 1.134 2017/05/07 22:27:57 nicm Exp $ */
d206 1
a206 1
	log_debug("%s: %s: %s", __func__, fj->cmd, fj->out);
d210 2
a211 2
		TAILQ_FOREACH(c, &clients, entry)
		    server_status_client(c);
d236 2
a240 1
		log_debug("%s: %s: %s", __func__, fj->cmd, fj->out);
@


1.134
log
@Add a format for the name of the pane's mode, lets it be used as a
conditional for key bindings.
@
text
@d1 1
a1 1
/* $OpenBSD: format.c,v 1.133 2017/05/05 11:59:47 nicm Exp $ */
d1379 2
a1380 2
	format_add(ft, "pane_search_string", "%s",
	    window_copy_search_string(wp));
@


1.133
log
@Add some formats to look at the session window stack, suggested by Scott
ROCHFORD.
@
text
@d1 1
a1 1
/* $OpenBSD: format.c,v 1.132 2017/05/03 05:53:34 nicm Exp $ */
d1374 3
@


1.132
log
@Add a format for the last search string in copy mode and fix the prompt
so it can work when in -I, suggested by Suraj N Kurapati.
@
text
@d1 1
a1 1
/* $OpenBSD: format.c,v 1.131 2017/05/01 12:20:55 nicm Exp $ */
a44 19
static void	 format_cb_host(struct format_tree *, struct format_entry *);
static void	 format_cb_host_short(struct format_tree *,
		     struct format_entry *);
static void	 format_cb_pid(struct format_tree *, struct format_entry *);
static void	 format_cb_session_alerts(struct format_tree *,
		     struct format_entry *);
static void	 format_cb_window_layout(struct format_tree *,
		     struct format_entry *);
static void	 format_cb_window_visible_layout(struct format_tree *,
		     struct format_entry *);
static void	 format_cb_start_command(struct format_tree *,
		     struct format_entry *);
static void	 format_cb_current_command(struct format_tree *,
		     struct format_entry *);
static void	 format_cb_history_bytes(struct format_tree *,
		     struct format_entry *);
static void	 format_cb_pane_tabs(struct format_tree *,
		     struct format_entry *);

d110 1
d401 1
a401 1
	char		 alerts[256], tmp[16];
d425 42
d1227 1
d1314 1
d1319 1
@


1.131
log
@In order that people can use formats like #D in #() in the status line
and not have to wait for an update when they change pane, we allow
commands to run more than once a second if the expanded form
changes. Unfortunately this can mean them being run far too often
(pretty much continually) when multiple clients exist, because some
formats (including #D) will always differ between clients.

To avoid this, give each client its own tree of jobs which means that
the same command will be different instances for each client - similar
to how we have the tag to separate commands for different panes.

GitHub issue 889; test case reported by Paul Johnson.
@
text
@d1 1
a1 1
/* $OpenBSD: format.c,v 1.130 2017/04/21 14:01:19 nicm Exp $ */
d1349 2
@


1.130
log
@Store state shared between multiple commands in the queue in a shared
structure.
@
text
@d1 1
a1 1
/* $OpenBSD: format.c,v 1.129 2017/04/20 09:43:45 nicm Exp $ */
d79 1
d132 1
a240 1
	struct client		*c;
d262 2
a263 2
		TAILQ_FOREACH(c, &clients, entry)
		    server_status_client(c);
d272 1
d278 9
d289 1
a289 1
	if ((fj = RB_FIND(format_job_tree, &format_jobs, &fj0)) == NULL) {
d291 1
d298 1
a298 1
		RB_INSERT(format_job_tree, &format_jobs, fj);
d329 1
a329 1
format_job_timer(__unused int fd, __unused short events, __unused void *arg)
a332 1
	struct timeval		 tv = { .tv_sec = 60 };
d335 2
a336 2
	RB_FOREACH_SAFE(fj, format_job_tree, &format_jobs, fj1) {
		if (fj->last > now || now - fj->last < 3600)
d338 1
a338 1
		RB_REMOVE(format_job_tree, &format_jobs, fj);
d351 23
d570 1
a570 1
format_create(struct cmdq_item *item, int tag, int flags)
d582 5
d619 2
d1143 4
a1146 1
	ft = format_create(item, FORMAT_NONE, 0);
@


1.129
log
@Now that struct winlink has a session pointer, can remove some arguments.
@
text
@d1 1
a1 1
/* $OpenBSD: format.c,v 1.128 2017/04/20 09:39:07 nicm Exp $ */
d557 6
a562 4
	if (item != NULL && item->cmd != NULL)
		format_add(ft, "command", "%s", item->cmd->entry->name);
	if (item != NULL && item->formats != NULL)
		format_merge(ft, item->formats);
@


1.128
log
@There is no real need for window_printable_flags to allocate, make it
return a buffer from the stack.
@
text
@d1 1
a1 1
/* $OpenBSD: format.c,v 1.127 2017/04/20 09:20:22 nicm Exp $ */
d74 1
a74 1
static void	 format_defaults_winlink(struct format_tree *, struct session *,
d1124 2
a1125 2
	if (s != NULL && wl != NULL)
		format_defaults_winlink(ft, s, wl);
d1236 1
a1236 2
format_defaults_winlink(struct format_tree *ft, struct session *s,
    struct winlink *wl)
d1238 1
d1247 1
a1247 1
	format_add(ft, "window_flags", "%s", window_printable_flags(s, wl));
@


1.127
log
@If a #() command doesn't exit, use its most recent line of output (it
must be a full line). Don't let it redraw the status line more than once
a second.

Requested by someone about 10 years ago...
@
text
@d1 1
a1 1
/* $OpenBSD: format.c,v 1.126 2017/04/19 06:52:27 nicm Exp $ */
a1239 1
	char		*flags;
a1243 2
	flags = window_printable_flags(s, wl);

d1247 1
a1247 1
	format_add(ft, "window_flags", "%s", flags);
a1258 2

	free(flags);
@


1.126
log
@When the data we have buffered to write to a terminal grows beyond a
reasonable amount (currently width * height * 8 bytes), discard all
output to the terminal and start trying to redraw periodically
instead. Continue with this until the amount of data we are trying to
write falls to a low level again.

This helps to prevent tmux sitting on a huge buffer of data when there
are processes with fast output running inside tmux but the outside
terminal is slow.

A new client_discarded format holds the amount of data that has been
discarded due to this mechanism.

The three variables (when to start this, when to stop, and how often to
redraw) are basically "works for me" at the moment, this is going in to
see how it goes and if it causes problems for anyone else.
@
text
@d1 1
a1 1
/* $OpenBSD: format.c,v 1.125 2017/04/18 15:44:17 nicm Exp $ */
a41 1
static void	 format_job_callback(struct job *);
d85 1
d206 1
a206 1
/* Format job callback. */
d208 27
a234 1
format_job_callback(struct job *job)
a241 1
	free(fj->out);
d252 7
a258 1
	fj->out = buf;
a264 2

	log_debug("%s: %s: %s", __func__, fj->cmd, fj->out);
d299 2
a300 2
		fj->job = job_run(expanded, NULL, NULL, format_job_callback,
		    NULL, fj);
@


1.125
log
@Add a format for number of bytes writtent to client, useful for debugging.
@
text
@d1 1
a1 1
/* $OpenBSD: format.c,v 1.124 2017/04/05 10:49:46 nicm Exp $ */
d1157 3
a1159 1
	format_add(ft, "client_written", "%zu", tty->written);
@


1.124
log
@Give each client a name. This defaults to the tty name as before but
falls back to an alternative if the tty name is not available. This is
clearer than overloading the client ttyname member and allows us to
remove the path stored in the tty struct, it should always be the same
as the client.
@
text
@d1 1
a1 1
/* $OpenBSD: format.c,v 1.123 2017/03/08 13:36:12 nicm Exp $ */
d1157 1
@


1.123
log
@Add a helper function for the most common format_create/defaults/expand
pattern.
@
text
@d1 1
a1 1
/* $OpenBSD: format.c,v 1.122 2017/02/09 15:04:53 nicm Exp $ */
d1142 1
d1146 1
a1146 2
	if (tty->path != NULL)
		format_add(ft, "client_tty", "%s", tty->path);
@


1.122
log
@Instead of numbering session groups, give them a name which may be given
to -t instead of a target session. Also allow them to contain only one
session.
@
text
@d1 1
a1 1
/* $OpenBSD: format.c,v 1.121 2017/02/07 18:06:42 nicm Exp $ */
a502 1

d1061 16
@


1.121
log
@Remove a debugging leftover.
@
text
@d1 1
a1 1
/* $OpenBSD: format.c,v 1.120 2017/02/03 11:57:27 nicm Exp $ */
d1100 1
a1100 1
	sg = session_group_find(s);
d1103 1
a1103 1
		format_add(ft, "session_group", "%u", session_group_index(sg));
@


1.120
log
@Add a window or pane id "tag" to each format tree and use it to separate
jobs, this means that if the same job is used for different windows or
panes (for example in pane-border-format), it will be run separately for
each pane.
@
text
@d1 1
a1 1
/* $OpenBSD: format.c,v 1.119 2017/02/01 09:55:07 nicm Exp $ */
d862 2
a863 3
		if (found == NULL) {
			log_debug("XXX %s", copy + 1);
			found = format_expand(ft, copy + 1);}
@


1.119
log
@Implement "all event" (1003) mouse mode but in a way that works. The
main issue is that if we have two panes, A with 1002 and B with 1003, we
need to set 1003 outside tmux in order to get all the mouse events, but
then we need to suppress the ones that pane A doesn't want. This is easy
in SGR mouse mode, because buttons == 3 is only used for movement events
(for other events the trailing m/M marks a release instead), but in
normal mouse mode we can't tell so easily. So for that, look at the
previous event instead - if it is drag+release as well, then the current
event is a movement event.
@
text
@d1 1
a1 1
/* $OpenBSD: format.c,v 1.118 2017/01/30 21:41:17 nicm Exp $ */
d80 1
d103 4
d131 1
d247 1
d251 1
d508 1
a508 1
format_create(struct cmdq_item *item, int flags)
d519 2
@


1.118
log
@When a flag option is used in a format, it should use the number form
not string.
@
text
@d1 1
a1 1
/* $OpenBSD: format.c,v 1.117 2017/01/16 14:49:14 nicm Exp $ */
d1283 1
a1283 1
	    !!(wp->base.mode & (MODE_MOUSE_STANDARD|MODE_MOUSE_BUTTON)));
d1288 2
@


1.117
log
@getopt() has a struct option so just return to using options_entry.
@
text
@d1 1
a1 1
/* $OpenBSD: format.c,v 1.116 2017/01/15 20:48:41 nicm Exp $ */
d641 1
a641 1
			found = options_tostring(o, idx);
@


1.116
log
@Major tidy up and rework of options tree and set-option/show-options
commands this pushes more of the code into options.c and ties it more
closely to the options table rather than having an unnecessary
split. Also add support for array options (will be used later). Only
(intentional) user visible change is that show-options output is now
passed through vis(3) with VIS_DQ so quotes are escaped.
@
text
@d1 1
a1 1
/* $OpenBSD: format.c,v 1.115 2017/01/11 16:09:57 nicm Exp $ */
d625 1
a625 1
	struct option		*o;
@


1.115
log
@Add a format for terminal type.
@
text
@d1 1
a1 1
/* $OpenBSD: format.c,v 1.114 2017/01/09 21:03:25 nicm Exp $ */
a622 1
	struct options_entry	*o;
d625 1
d627 1
a629 2
	found = NULL;

d631 1
a631 1
		o = options_find(global_options, key);
d633 1
a633 1
			o = options_find(ft->w->options, key);
d635 1
a635 1
			o = options_find(global_w_options, key);
d637 1
a637 1
			o = options_find(ft->s->options, key);
d639 1
a639 1
			o = options_find(global_s_options, key);
d641 2
a642 12
			switch (o->type) {
			case OPTIONS_STRING:
				found = o->str;
				goto found;
			case OPTIONS_NUMBER:
				xsnprintf(s, sizeof s, "%lld", o->num);
				found = s;
				goto found;
			case OPTIONS_STYLE:
				found = style_tostring(&o->style);
				goto found;
			}
d645 1
@


1.114
log
@Add simple comparisons in formats: #{==:a,b} and #{!=:a,b} ("a" and "b"
are expanded so can compare formats). And expand the condition to
#{?a,b,c} (the "a" part) if it doesn't work as a simple lookup.

Also add FORMAT_NOJOBS flag to disable jobs in a format.
@
text
@d1 1
a1 1
/* $OpenBSD: format.c,v 1.113 2016/11/17 10:06:08 nicm Exp $ */
d1122 2
d1129 4
a1132 6
	format_add(ft, "client_height", "%u", c->tty.sy);
	format_add(ft, "client_width", "%u", c->tty.sx);
	if (c->tty.path != NULL)
		format_add(ft, "client_tty", "%s", c->tty.path);
	if (c->tty.termname != NULL)
		format_add(ft, "client_termname", "%s", c->tty.termname);
d1136 5
d1151 1
a1151 1
	if (c->tty.flags & TTY_UTF8)
@


1.113
log
@Key running commands for #() by the unexpanded command, and run them
again if the expanded form changes (otherwise at most once per second as
usual). Fixes issues reported by Gregory Pakosz.
@
text
@d1 1
a1 1
/* $OpenBSD: format.c,v 1.112 2016/10/16 19:36:37 nicm Exp $ */
d710 44
d763 1
a763 1
	char		*from = NULL, *to = NULL;
d766 1
a766 1
	int		 modifiers = 0, brackets;
d775 7
d783 5
d839 18
a856 6
	/*
	 * Is this a conditional? If so, check it exists and extract either the
	 * first or second element. If not, look up the key directly.
	 */
	if (*copy == '?') {
		ptr = strchr(copy, ',');
a860 1
		value = ptr + 1;
d862 4
a865 11

		brackets = 0;
		for (ptr = ptr + 1; *ptr != '\0'; ptr++) {
			if (*ptr == '{')
				brackets++;
			if (*ptr == '}')
				brackets--;
			if (*ptr == ',' && brackets == 0)
				break;
		}
		if (*ptr == '\0')
d868 4
a871 6
		if (found != NULL && *found != '\0' &&
		    (found[0] != '0' || found[1] != '\0')) {
			*ptr = '\0';
		} else
			value = ptr + 1;
		value = format_expand(ft, value);
d874 1
d996 4
a999 1
			out = format_job_get(ft, xstrndup(fmt, n));
@


1.112
log
@Provide a way for hooks to tag formats onto the commands they fire so
that the user can get at additional information - now used for the
"hook" format, more to come.
@
text
@d1 1
a1 1
/* $OpenBSD: format.c,v 1.111 2016/10/16 19:04:05 nicm Exp $ */
d81 1
d236 4
a239 2
	struct format_job	fj0, *fj;
	time_t			t;
d245 1
d252 8
d261 2
a262 2
	if (fj->job == NULL && ((ft->flags & FORMAT_FORCE) || fj->last != t)) {
		fj->job = job_run(fj->cmd, NULL, NULL, format_job_callback,
d274 1
d297 1
d900 1
a900 1
	char		*buf, *tmp, *cmd, *out;
d937 1
a937 6
			tmp = xmalloc(n + 1);
			memcpy(tmp, fmt, n);
			tmp[n] = '\0';
			cmd = format_expand(ft, tmp);

			out = format_job_get(ft, cmd);
a938 3

			free(cmd);
			free(tmp);
@


1.111
log
@Mass rename struct cmd_q to struct cmdq_item and related.
@
text
@d1 1
a1 1
/* $OpenBSD: format.c,v 1.110 2016/10/16 17:55:14 nicm Exp $ */
d471 13
d507 2
a508 2
	if (item != NULL && item->hook != NULL)
		format_add(ft, "hook", "%s", item->hook);
@


1.110
log
@Rewrite command queue handling. Each client still has a command queue,
but there is also now a global command queue. Instead of command queues
being dispatched on demand from wherever the command happens to be
added, they are now all dispatched from the top level server
loop. Command queues may now also include callbacks as well as commands,
and items may be inserted after the current command as well as at the end.

This all makes command queues significantly more predictable and easier
to use, and avoids the complex multiple nested command queues used by
source-file, if-shell and friends.

A mass rename of struct cmdq to a better name (cmdq_item probably) is
coming.
@
text
@d1 1
a1 1
/* $OpenBSD: format.c,v 1.109 2016/10/11 13:45:47 nicm Exp $ */
d473 1
a473 1
format_create(struct cmd_q *cmdq, int flags)
d492 4
a495 4
	if (cmdq != NULL && cmdq->cmd != NULL)
		format_add(ft, "command", "%s", cmdq->cmd->entry->name);
	if (cmdq != NULL && cmdq->hook != NULL)
		format_add(ft, "hook", "%s", cmdq->hook);
@


1.109
log
@Some other stuff that can be local to one file.
@
text
@d1 1
a1 1
/* $OpenBSD: format.c,v 1.108 2016/10/10 21:29:23 nicm Exp $ */
a475 1
	struct cmd		*cmd;
d493 3
a495 5
		format_add(ft, "command_name", "%s", cmdq->cmd->entry->name);
	if (cmdq != NULL && cmdq->parent != NULL) {
		cmd = cmdq->parent->cmd;
		format_add(ft, "command_hooked", "%s", cmd->entry->name);
	}
@


1.108
log
@Loads more static, except for cmd-*.c and window-*.c.
@
text
@d1 1
a1 1
/* $OpenBSD: format.c,v 1.107 2016/05/23 20:39:26 nicm Exp $ */
d94 1
a94 1
RB_HEAD(format_job_tree, format_job) format_jobs = RB_INITIALIZER();
@


1.107
log
@Use a fixed buffer for strftime() because there is no portable way to
tell if the buffer is too small, and an expanding buffer is overkill
anyway.
@
text
@d1 1
a1 1
/* $OpenBSD: format.c,v 1.106 2016/04/29 14:05:24 nicm Exp $ */
d42 35
a76 28
void	 format_job_callback(struct job *);
char	*format_job_get(struct format_tree *, const char *);
void	 format_job_timer(int, short, void *);

void	 format_cb_host(struct format_tree *, struct format_entry *);
void	 format_cb_host_short(struct format_tree *, struct format_entry *);
void	 format_cb_pid(struct format_tree *, struct format_entry *);
void	 format_cb_session_alerts(struct format_tree *, struct format_entry *);
void	 format_cb_window_layout(struct format_tree *, struct format_entry *);
void	 format_cb_window_visible_layout(struct format_tree *,
	     struct format_entry *);
void	 format_cb_start_command(struct format_tree *, struct format_entry *);
void	 format_cb_current_command(struct format_tree *, struct format_entry *);
void	 format_cb_history_bytes(struct format_tree *, struct format_entry *);
void	 format_cb_pane_tabs(struct format_tree *, struct format_entry *);

char	*format_find(struct format_tree *, const char *, int);
void	 format_add_cb(struct format_tree *, const char *, format_cb);
void	 format_add_tv(struct format_tree *, const char *, struct timeval *);
int	 format_replace(struct format_tree *, const char *, size_t, char **,
	     size_t *, size_t *);
char	*format_time_string(time_t);

void	 format_defaults_pane_tabs(struct format_tree *, struct window_pane *);
void	 format_defaults_session(struct format_tree *, struct session *);
void	 format_defaults_client(struct format_tree *, struct client *);
void	 format_defaults_winlink(struct format_tree *, struct session *,
	     struct winlink *);
d92 2
a93 2
struct event format_job_event;
int	format_job_cmp(struct format_job *, struct format_job *);
d95 1
a95 2
RB_PROTOTYPE(format_job_tree, format_job, entry, format_job_cmp);
RB_GENERATE(format_job_tree, format_job, entry, format_job_cmp);
d98 1
a98 1
int
d129 2
a130 3
int	format_entry_cmp(struct format_entry *, struct format_entry *);
RB_PROTOTYPE(format_entry_tree, format_entry, entry, format_entry_cmp);
RB_GENERATE(format_entry_tree, format_entry, entry, format_entry_cmp);
d133 1
a133 1
int
d140 1
a140 1
const char *format_upper[] = {
d170 1
a170 1
const char *format_lower[] = {
d200 1
a200 1
void
d232 1
a232 1
char *
d266 1
a266 1
void
d295 1
a295 1
void
d307 1
a307 1
void
d322 1
a322 1
void
d329 1
a329 1
void
d359 1
a359 1
void
d374 1
a374 1
void
d386 1
a386 1
void
d398 1
a398 1
void
d421 1
a421 1
void
d446 1
a446 1
void
d547 1
a547 1
void
d571 1
a571 1
void
d595 1
a595 1
char *
d690 1
a690 1
int
d1010 1
a1010 1
void
d1039 1
a1039 1
void
d1106 1
a1106 1
void
@


1.106
log
@Final parts of command hooks, add before- and after- hooks to each command.
@
text
@d1 1
a1 1
/* $OpenBSD: format.c,v 1.105 2016/01/31 09:54:46 nicm Exp $ */
a852 2
	char		*tmp, *expanded;
	size_t		 tmplen;
d854 1
d861 2
a862 10
	tmp = NULL;
	tmplen = strlen(fmt);

	do {
		tmp = xreallocarray(tmp, 2, tmplen);
		tmplen *= 2;
	} while (strftime(tmp, tmplen, fmt, tm) == 0);

	expanded = format_expand(ft, tmp);
	free(tmp);
d864 1
a864 1
	return (expanded);
@


1.105
log
@Support negative trim values (#{=-10:pane_title}) to trim from the end,
suggested by Kevin Brubeck Unhammer.
@
text
@d1 1
a1 1
/* $OpenBSD: format.c,v 1.104 2016/01/19 15:59:12 nicm Exp $ */
d471 1
d490 4
@


1.104
log
@I no longer use my SourceForge address so replace it.
@
text
@d1 1
a1 1
/* $OpenBSD: format.c,v 1.103 2015/12/12 18:32:24 nicm Exp $ */
d687 1
a687 1
	u_long		 limit = 0;
d699 2
a700 2
		limit = strtoul(copy + 1, &endptr, 10);
		if (errno == ERANGE && limit == ULONG_MAX)
d816 1
a816 1
	if (limit != 0) {
d818 4
@


1.103
log
@Add key-table option to set the default key table for a session, allows
different key bindings for different sessions and a few other things.
@
text
@d1 1
a1 1
/* $OpenBSD: format.c,v 1.102 2015/12/11 12:27:36 nicm Exp $ */
d4 1
a4 1
 * Copyright (c) 2011 Nicholas Marriott <nicm@@users.sourceforge.net>
@


1.102
log
@Add cmdq as an argument to format_create and add a format for the
command name (will also be used for more later).
@
text
@d1 1
a1 1
/* $OpenBSD: format.c,v 1.101 2015/12/08 08:34:18 nicm Exp $ */
d1038 1
d1056 2
a1057 1
	if (strcmp(c->keytable->name, "root") == 0)
@


1.101
log
@Remove format_create_flags and just pass flags to format_create.
@
text
@d1 1
a1 1
/* $OpenBSD: format.c,v 1.100 2015/11/24 21:52:06 nicm Exp $ */
d468 1
a468 1
format_create(int flags)
d486 3
@


1.100
log
@Remove the -I part of show-messages which isn't really that useful; the
server start time can now be accessed with a new start_time format (use:
tmux display -p '#{t:start_time}')
@
text
@d1 1
a1 1
/* $OpenBSD: format.c,v 1.99 2015/11/18 14:27:44 nicm Exp $ */
d468 1
a468 8
format_create(void)
{
	return (format_create_flags(0));
}

/* Create a new tree for the status line. */
struct format_tree *
format_create_flags(int flags)
@


1.99
log
@Use __unused rather than rolling our own.
@
text
@d1 1
a1 1
/* $OpenBSD: format.c,v 1.98 2015/11/18 14:13:55 nicm Exp $ */
d491 2
@


1.98
log
@Add s/foo/bar/: prefix for formats to substitute bar for foo.
@
text
@d1 1
a1 1
/* $OpenBSD: format.c,v 1.97 2015/11/13 12:18:52 nicm Exp $ */
d262 1
a262 1
format_job_timer(unused int fd, unused short events, unused void *arg)
d291 1
a291 1
format_cb_host(unused struct format_tree *ft, struct format_entry *fe)
d303 1
a303 1
format_cb_host_short(unused struct format_tree *ft, struct format_entry *fe)
d318 1
a318 1
format_cb_pid(unused struct format_tree *ft, struct format_entry *fe)
@


1.97
log
@Two spacing and spelling nits.
@
text
@d1 1
a1 1
/* $OpenBSD: format.c,v 1.96 2015/11/13 10:00:26 nicm Exp $ */
d102 1
d686 3
a688 2
	char		*copy, *copy0, *endptr, *ptr, *saved, *trimmed, *value;
	size_t		 valuelen;
d726 23
d762 1
a762 1
		saved = format_find(ft, copy + 1, modifiers);
d776 2
a777 2
		if (saved != NULL && *saved != '\0' &&
		    (saved[0] != '0' || saved[1] != '\0')) {
d782 1
a782 2
		free(saved);
		saved = value;
d784 1
a784 1
		saved = value = format_find(ft, copy, modifiers);
d786 29
a814 1
			saved = value = xstrdup("");
d819 3
a821 3
		value = trimmed = utf8_trimcstr(value, limit);
		free(saved);
		saved = trimmed;
a822 1
	valuelen = strlen(value);
d825 1
d833 1
a833 1
	free(saved);
@


1.96
log
@Add window_visible_layout which ignores zoomed panes and use it for
control mode (which needs to know all panes), from George Nachman.
@
text
@d1 1
a1 1
/* $OpenBSD: format.c,v 1.95 2015/11/13 08:09:28 nicm Exp $ */
d51 2
a52 1
void format_cb_window_visible_layout(struct format_tree *, struct format_entry *);
@


1.95
log
@Long overdue change to the way we store cells in the grid: now, instead
of storing a full grid_cell with UTF-8 data and everything, store a new
type grid_cell_entry. This can either be the cell itself (for ASCII
cells), or an offset into an extended array (per line) for UTF-8
data.

This avoid a large (8 byte) overhead on non-UTF-8 cells (by far the
majority for most users) without the complexity of the shadow array we
had before. Grid memory without any UTF-8 is about half.

The disadvantage that cells can no longer be modified in place and need
to be copied out of the grid and back but it turned out to be lot less
complicated than I expected.
@
text
@d1 1
a1 1
/* $OpenBSD: format.c,v 1.94 2015/11/12 11:09:11 nicm Exp $ */
d51 1
d366 12
d1040 2
@


1.94
log
@Nuke the utf8 and status-utf8 options and make tmux only a UTF-8
terminal. We still support non-UTF-8 terminals outside tmux, but inside
it is always UTF-8 (as when the utf8 and status-utf8 options were on).
@
text
@d1 1
a1 1
/* $OpenBSD: format.c,v 1.93 2015/11/12 11:07:10 nicm Exp $ */
d418 1
@


1.93
log
@Remove the mouse_utf8_flag format as well.
@
text
@d1 1
a1 1
/* $OpenBSD: format.c,v 1.92 2015/10/31 08:13:58 nicm Exp $ */
d1147 1
a1147 2
format_defaults_paste_buffer(struct format_tree *ft, struct paste_buffer *pb,
    int utf8flag)
d1156 1
a1156 1
	s = paste_make_sample(pb, utf8flag);
@


1.92
log
@Because pledge(2) does not allow us to pass directory file descriptors
around, we can't use file descriptors for the working directory because
we will be unable to pass it to a privileged process to tell it where to
read or write files or spawn children. So move tmux back to using
strings for the current working directory. We try to check it exists
with access() when it is set but ultimately fall back to ~ if it fails
at time of use (or / if that fails too).
@
text
@d1 1
a1 1
/* $OpenBSD: format.c,v 1.91 2015/10/28 09:51:55 nicm Exp $ */
a1140 2
	format_add(ft, "mouse_utf8_flag", "%d",
	    !!(wp->base.mode & MODE_MOUSE_UTF8));
@


1.91
log
@Like options, move the environ struct into environ.c.
@
text
@d1 1
a1 1
/* $OpenBSD: format.c,v 1.90 2015/10/27 15:58:42 nicm Exp $ */
d242 1
a242 1
		fj->job = job_run(fj->cmd, NULL, -1, format_job_callback,
@


1.90
log
@Move struct options into options.c.
@
text
@d1 1
a1 1
/* $OpenBSD: format.c,v 1.89 2015/10/27 09:28:31 nicm Exp $ */
d634 1
a634 1
			envent = environ_find(&ft->s->environ, key);
d636 1
a636 1
			envent = environ_find(&global_environ, key);
@


1.89
log
@Count brackets in #{?...} so that nested conditional formats work, from
Daniel De Graaf.
@
text
@d1 1
a1 1
/* $OpenBSD: format.c,v 1.88 2015/10/27 09:18:06 nicm Exp $ */
d584 1
a584 1
		o = options_find(&global_options, key);
d586 1
a586 1
			o = options_find(&ft->w->options, key);
d588 1
a588 1
			o = options_find(&global_w_options, key);
d590 1
a590 1
			o = options_find(&ft->s->options, key);
d592 1
a592 1
			o = options_find(&global_s_options, key);
d1104 1
a1104 1
	    !!options_get_number(&wp->window->options, "synchronize-panes"));
@


1.88
log
@The format callback may not always succeed, so we need to check for
NULL. From Patrick Palka.
@
text
@d1 1
a1 1
/* $OpenBSD: format.c,v 1.87 2015/10/25 22:29:17 nicm Exp $ */
d673 1
a673 1
	int		 modifiers = 0;
d721 17
a737 7
		value = saved = format_find(ft, copy + 1, modifiers);
		if (value != NULL && *value != '\0' &&
		    (value[0] != '0' || value[1] != '\0')) {
			value = ptr + 1;
			ptr = strchr(value, ',');
			if (ptr == NULL)
				goto fail;
d739 1
a739 4
		} else {
			ptr = strchr(ptr + 1, ',');
			if (ptr == NULL)
				goto fail;
a740 1
		}
@


1.87
log
@Extend the modifiers allowed before formats: as well as the existing
#{=10:...}  length limit, add #{t:...} to convert a time_t format to a
string, #{b:...} for basename and #{d:...} for dirname. Remove all the
foo_string time formats as they can now be replaced by "t:", for example
#{window_activity_string} becomes #{t:window_activity}.
@
text
@d1 1
a1 1
/* $OpenBSD: format.c,v 1.86 2015/10/25 08:59:26 nicm Exp $ */
d646 2
@


1.86
log
@Pass output from jobs through format_expand() so they are expanded again
(this was the previous behaviour).
@
text
@d1 1
a1 1
/* $OpenBSD: format.c,v 1.85 2015/10/23 16:02:21 nicm Exp $ */
d24 1
d56 1
d58 1
d96 5
d105 1
d515 1
d522 24
d565 1
d571 2
a572 2
const char *
format_find(struct format_tree *ft, const char *key)
d577 29
a605 20
	static char		 s[16];

	o = options_find(&global_options, key);
	if (o == NULL && ft->w != NULL)
		o = options_find(&ft->w->options, key);
	if (o == NULL)
		o = options_find(&global_w_options, key);
	if (o == NULL && ft->s != NULL)
		o = options_find(&ft->s->options, key);
	if (o == NULL)
		o = options_find(&global_s_options, key);
	if (o != NULL) {
		switch (o->type) {
		case OPTIONS_STRING:
			return (o->str);
		case OPTIONS_NUMBER:
			xsnprintf(s, sizeof s, "%lld", o->num);
			return (s);
		case OPTIONS_STYLE:
			return (style_tostring(&o->style));
d612 13
d627 2
a628 1
		return (fe->value);
d631 11
a641 7
	envent = NULL;
	if (ft->s != NULL)
		envent = environ_find(&ft->s->environ, key);
	if (envent == NULL)
		envent = environ_find(&global_environ, key);
	if (envent != NULL)
		return (envent->value);
d644 14
d668 1
a668 2
	char		*copy, *copy0, *endptr, *ptr, *saved, *trimmed;
	const char	*value;
d671 1
d679 28
a706 18
	if (!isalpha((u_char) *copy) && *copy != '@@' && *copy != '?') {
		while (*copy != ':' && *copy != '\0') {
			switch (*copy) {
			case '=':
				errno = 0;
				limit = strtoul(copy + 1, &endptr, 10);
				if (errno == ERANGE && limit == ULONG_MAX)
					goto fail;
				copy = endptr;
				break;
			default:
				copy++;
				break;
			}
		}
		if (*copy != ':')
			goto fail;
		copy++;
d719 1
a719 1
		value = format_find(ft, copy + 1);
d733 3
a735 2
		saved = format_expand(ft, value);
		value = saved;
d737 1
a737 1
		value = format_find(ft, copy);
d739 1
a739 2
			value = "";
		saved = NULL;
a908 12
/* Get time as a string. */
char *
format_time_string(time_t t)
{
	char	*tim;

	tim = ctime(&t);
	*strchr(tim, '\n') = '\0';

	return (tim);
}

a935 1
	time_t			 t;
d950 3
a952 14
	t = s->creation_time.tv_sec;
	format_add(ft, "session_created", "%lld", (long long) t);
	format_add(ft, "session_created_string", "%s", format_time_string(t));

	t = s->last_attached_time.tv_sec;
	if (t != 0) { /* zero if never attached */
		format_add(ft, "session_last_attached", "%lld", (long long) t);
		format_add(ft, "session_last_attached_string", "%s",
		    format_time_string(t));
	}

	t = s->activity_time.tv_sec;
	format_add(ft, "session_activity", "%lld", (long long) t);
	format_add(ft, "session_activity_string", "%s", format_time_string(t));
a964 1
	time_t		 t;
d979 2
a980 7
	t = c->creation_time.tv_sec;
	format_add(ft, "client_created", "%lld", (long long) t);
	format_add(ft, "client_created_string", "%s", format_time_string(t));

	t = c->activity_time.tv_sec;
	format_add(ft, "client_activity", "%lld", (long long) t);
	format_add(ft, "client_activity_string", "%s", format_time_string(t));
a1009 2
	time_t	 t;

d1012 1
a1012 4
	t = w->activity_time.tv_sec;
	format_add(ft, "window_activity", "%lld", (long long) t);
	format_add(ft, "window_activity_string", "%s", format_time_string(t));

@


1.85
log
@Format for scroll position, from Jorge Morante.
@
text
@d1 1
a1 1
/* $OpenBSD: format.c,v 1.84 2015/09/14 10:25:52 nicm Exp $ */
d42 1
a42 1
const char *format_job_get(struct format_tree *, const char *);
d215 1
a215 1
const char *
d245 1
a245 1
	return (fj->out);
d712 1
a712 1
	char		*buf, *tmp, *cmd;
d714 1
a714 1
	size_t		 off, len, n, slen;
d754 2
a755 2
			s = format_job_get(ft, cmd);
			slen = strlen(s);
d760 1
a760 1
			while (len - off < slen + 1) {
d764 4
a767 2
			memcpy(buf + off, s, slen);
			off += slen;
@


1.84
log
@Make refresh-client force update of jobs, from Sina Siadat.
@
text
@d1 1
a1 1
/* $OpenBSD: format.c,v 1.83 2015/09/10 08:58:14 nicm Exp $ */
d1008 1
a1008 1
	int  		 status;
d1054 4
@


1.83
log
@Add session_last_attached time and format, from Sina Siadat.
@
text
@d1 1
a1 1
/* $OpenBSD: format.c,v 1.82 2015/09/03 14:30:23 nicm Exp $ */
d107 1
a107 1
	int			 status;
d219 1
a224 1
		fj->status = ft->status;
d231 2
a232 1
	if (fj->job == NULL && fj->last != time(NULL)) {
d239 1
d241 3
a243 1
	fj->last = time(NULL);
d445 1
a445 1
	return (format_create_status(0));
d450 1
a450 1
format_create_status(int status)
d461 1
a461 1
	ft->status = status;
@


1.82
log
@A couple of style nits.
@
text
@d1 1
a1 1
/* $OpenBSD: format.c,v 1.81 2015/08/29 09:25:00 nicm Exp $ */
d874 7
@


1.81
log
@Move struct paste_buffer out of tmux.h.
@
text
@d1 1
a1 1
/* $OpenBSD: format.c,v 1.80 2015/08/28 17:01:42 nicm Exp $ */
d221 1
a221 2
	if ((fj = RB_FIND(format_job_tree, &format_jobs, &fj0)) == NULL)
	{
@


1.80
log
@Make a few more expensive (ish) formats functions instead of inline.
@
text
@d1 1
a1 1
/* $OpenBSD: format.c,v 1.79 2015/08/28 16:46:40 nicm Exp $ */
d1077 1
d1080 3
a1082 2
	format_add(ft, "buffer_size", "%zu", pb->size);
	format_add(ft, "buffer_name", "%s", pb->name);
@


1.79
log
@Allow formats to be specified as functions (in the code) so they are
only evaluated on demand rather than each time a format tree is
constructed. Use this for expensive formats like pane_current_command.
@
text
@d1 1
a1 1
/* $OpenBSD: format.c,v 1.78 2015/08/28 12:16:28 nicm Exp $ */
d48 2
d52 2
d308 45
d388 50
a857 2
	struct winlink		*wl;
	char			 alerts[256], tmp[16];
d883 1
a883 17
	*alerts = '\0';
	RB_FOREACH (wl, winlinks, &s->windows) {
		if ((wl->flags & WINLINK_ALERTFLAGS) == 0)
			continue;
		xsnprintf(tmp, sizeof tmp, "%u", wl->idx);

		if (*alerts != '\0')
			strlcat(alerts, ",", sizeof alerts);
		strlcat(alerts, tmp, sizeof alerts);
		if (wl->flags & WINLINK_ACTIVITY)
			strlcat(alerts, "#", sizeof alerts);
		if (wl->flags & WINLINK_BELL)
			strlcat(alerts, "!", sizeof alerts);
		if (wl->flags & WINLINK_SILENCE)
			strlcat(alerts, "~", sizeof alerts);
	}
	format_add(ft, "session_alerts", "%s", alerts);
a941 1
	char	*layout;
a945 5
	if (w->saved_layout_root != NULL)
		layout = layout_dump(w->saved_layout_root);
	else
		layout = layout_dump(w->layout_root);

d954 1
a954 1
	format_add(ft, "window_layout", "%s", layout);
a957 2

	free(layout);
a991 22
/* Add window pane tabs. */
void
format_defaults_pane_tabs(struct format_tree *ft, struct window_pane *wp)
{
	struct evbuffer	*buffer;
	u_int		 i;

	buffer = evbuffer_new();
	for (i = 0; i < wp->base.grid->sx; i++) {
		if (!bit_test(wp->base.tabs, i))
			continue;

		if (EVBUFFER_LENGTH(buffer) > 0)
			evbuffer_add(buffer, ",", 1);
		evbuffer_add_printf(buffer, "%u", i);
	}

	format_add(ft, "pane_tabs", "%.*s", (int) EVBUFFER_LENGTH(buffer),
	    EVBUFFER_DATA(buffer));
	evbuffer_free(buffer);
}

d996 3
a998 5
	struct grid		*gd = wp->base.grid;
	struct grid_line	*gl;
	unsigned long long	 size;
	u_int			 i, idx;
	int			 status;
a1003 6
	size = 0;
	for (i = 0; i < gd->hsize; i++) {
		gl = &gd->linedata[i];
		size += gl->cellsize * sizeof *gl->celldata;
	}
	size += gd->hsize * sizeof *gd->linedata;
d1006 1
a1006 1
	format_add(ft, "history_bytes", "%llu", size);
d1069 1
a1069 1
	format_defaults_pane_tabs(ft, wp);
@


1.78
log
@Run status update on a per-client timer at status-interval.
@
text
@d1 1
a1 1
/* $OpenBSD: format.c,v 1.77 2015/08/28 11:38:27 nicm Exp $ */
d38 3
d45 7
a54 1
char	*format_get_command(struct window_pane *);
d91 4
a94 4
	char		       *key;
	char		       *value;

	RB_ENTRY(format_entry)	entry;
d99 3
a101 2
	struct window	*w;
	struct session	*s;
d103 1
a103 1
	int		 status;
d270 69
a350 1
	char			 host[HOST_NAME_MAX + 1], *ptr;
d361 3
a363 7
	if (gethostname(host, sizeof host) == 0) {
		format_add(ft, "host", "%s", host);
		if ((ptr = strchr(host, '.')) != NULL)
			*ptr = '\0';
		format_add(ft, "host_short", "%s", host);
	}
	format_add(ft, "pid", "%ld", (long) getpid());
d395 10
d408 11
a421 2
		free(fe_now->value);
		fe_now->value = fe->value;
d424 2
d427 4
d465 3
a467 1
	if (fe != NULL)
d469 1
d611 1
a611 1
	const char	*ptr, *s;
d715 1
a718 20
/* Get command name for format. */
char *
format_get_command(struct window_pane *wp)
{
	char	*cmd, *out;

	cmd = get_proc_name(wp->fd, wp->tty);
	if (cmd == NULL || *cmd == '\0') {
		free(cmd);
		cmd = cmd_stringify_argv(wp->argc, wp->argv);
		if (cmd == NULL || *cmd == '\0') {
			free(cmd);
			cmd = xstrdup(wp->shell);
		}
	}
	out = parse_window_name(cmd);
	free(cmd);
	return (out);
}

a948 1
	char			*cmd;
d953 1
d994 2
a995 8
	if ((cmd = cmd_stringify_argv(wp->argc, wp->argv)) != NULL) {
		format_add(ft, "pane_start_command", "%s", cmd);
		free(cmd);
	}
	if ((cmd = format_get_command(wp)) != NULL) {
		format_add(ft, "pane_current_command", "%s", cmd);
		free(cmd);
	}
@


1.77
log
@Move format job cleanup onto its own timer.
@
text
@d1 1
a1 1
/* $OpenBSD: format.c,v 1.76 2015/08/28 10:06:52 nicm Exp $ */
d250 1
a250 1
		free((void*)fj->cmd);
@


1.76
log
@Allow environment variables in #{}.
@
text
@d1 1
a1 1
/* $OpenBSD: format.c,v 1.75 2015/07/13 15:37:26 nicm Exp $ */
d40 1
d67 1
d196 2
d233 1
a233 1
format_clean(void)
d237 1
d245 2
d255 3
d273 5
@


1.75
log
@Add a format to show if client is a control client. From Bruno Sutic.
@
text
@d1 1
a1 1
/* $OpenBSD: format.c,v 1.74 2015/06/18 23:55:24 nicm Exp $ */
d325 1
d351 12
a362 3
	if (fe == NULL)
		return (NULL);
	return (fe->value);
d384 1
a384 1
	if (!islower((u_char) *copy) && *copy != '@@' && *copy != '?') {
@


1.74
log
@Use xsnprintf.
@
text
@d1 1
a1 1
/* $OpenBSD: format.c,v 1.73 2015/06/15 10:58:01 nicm Exp $ */
d714 2
@


1.73
log
@Add window_activity format, from Thomas Adam based on a diff originally
from propos6 at gmail dot com.
@
text
@d1 1
a1 1
/* $OpenBSD: format.c,v 1.72 2015/06/14 10:07:44 nicm Exp $ */
d341 1
a341 1
			snprintf(s, sizeof s, "%lld", o->num);
d682 1
a682 1
		snprintf(tmp, sizeof tmp, "%u", wl->idx);
@


1.72
log
@Add a format for client PID (client_pid) and server PID (pid). Diff for
client_pid from Thomas Adam.
@
text
@d1 1
a1 1
/* $OpenBSD: format.c,v 1.71 2015/06/10 12:56:04 nicm Exp $ */
d752 1
d760 4
@


1.71
log
@wp->tty is a char [] not a char * so it can't be NULL. From Thomas Adam.
@
text
@d1 1
a1 1
/* $OpenBSD: format.c,v 1.70 2015/05/29 23:26:52 nicm Exp $ */
d274 1
d707 1
@


1.70
log
@Don't use special strings if #() commands fail, just remove the format
(as if the command produced nothing). Makes constructions that can fail
like '#(test whatever && echo foo)' work as they did before.
@
text
@d1 1
a1 1
/* $OpenBSD: format.c,v 1.69 2015/05/29 23:12:38 nicm Exp $ */
d875 1
a875 2
	if (wp->tty != NULL)
		format_add(ft, "pane_tty", "%s", wp->tty);
@


1.69
log
@Expand formats again inside #(), and free the temporaries.
@
text
@d1 1
a1 1
/* $OpenBSD: format.c,v 1.68 2015/05/27 13:28:04 nicm Exp $ */
a176 11

	if (WIFEXITED(job->status) && WEXITSTATUS(job->status) != 0) {
		xasprintf(&fj->out, "<'%s' exited with %d>", fj->cmd,
		    WEXITSTATUS(job->status));
		return;
	}
	if (WIFSIGNALED(job->status)) {
		xasprintf(&fj->out, "<'%s' got signal %d>", fj->cmd,
		    WTERMSIG(job->status));
		return;
	}
@


1.68
log
@Move the jobs output cache into the formats code so that #() work more
generally (for example, again working in set-titles-string).
@
text
@d1 1
a1 1
/* $OpenBSD: format.c,v 1.67 2015/05/20 06:39:02 nicm Exp $ */
d493 1
a493 1
	char		*buf, *tmp;
d533 1
d535 1
a535 1
			s = format_job_get(ft, tmp);
d537 3
@


1.67
log
@Return empty string if format is empty rather than attempting to
allocate zero bytes.
@
text
@d1 1
a1 1
/* $OpenBSD: format.c,v 1.66 2015/05/12 15:29:29 nicm Exp $ */
d38 3
d52 26
d86 1
a86 1
/* Tree of format entries. */
d91 3
a93 1
	RB_HEAD(format_rb_tree, format_entry) tree;
d95 3
d99 1
a99 6
/* Format key-value replacement entry. */
int	format_cmp(struct format_entry *, struct format_entry *);
RB_PROTOTYPE(format_rb_tree, format_entry, entry, format_cmp);
RB_GENERATE(format_rb_tree, format_entry, entry, format_cmp);

/* Format tree comparison function. */
d101 1
a101 1
format_cmp(struct format_entry *fe1, struct format_entry *fe2)
d166 95
d265 7
d273 1
a273 1
	char			 host[HOST_NAME_MAX+1], *ptr;
d277 1
d295 2
a296 2
	RB_FOREACH_SAFE(fe, format_rb_tree, &ft->tree, fe1) {
		RB_REMOVE(format_rb_tree, &ft->tree, fe);
d320 1
a320 1
	fe_now = RB_INSERT(format_rb_tree, &ft->tree, fe);
d359 1
a359 1
	fe = RB_FIND(format_rb_tree, &ft->tree, &fe_find);
d493 1
a493 1
	char		*buf;
d495 1
a495 1
	size_t		 off, len, n;
d518 28
@


1.66
log
@Add a session_alerts format which is a list of all the alerts in the
current session in symbolic form (something like "0!,4~,5!"). Use this
in the default set-titles-string. Prompted by a request from Jan ONDREJ.
@
text
@d1 1
a1 1
/* $OpenBSD: format.c,v 1.65 2015/05/08 16:18:04 nicm Exp $ */
d338 1
a338 1
	if (fmt == NULL)
@


1.65
log
@Move input parser structs into input.c (removing fairly useless
saved_cursor_[xy] formats as a side-effect).
@
text
@d1 1
a1 1
/* $OpenBSD: format.c,v 1.64 2015/05/06 08:35:39 nicm Exp $ */
d497 2
d523 18
@


1.64
log
@Add a format window_linked which is 1 if a window has been linked
multiple times, also remove the default space in window_flags and use a
conditional to add it in window-status-format (this means additional
flags can be added in the option without extra spaces). From Thomas Adam
with tweaks by me.
@
text
@d1 1
a1 1
/* $OpenBSD: format.c,v 1.63 2015/04/21 22:38:49 nicm Exp $ */
a717 2
	format_add(ft, "saved_cursor_x", "%u", wp->ictx.old_cx);
	format_add(ft, "saved_cursor_y", "%u", wp->ictx.old_cy);
@


1.63
log
@Always format real layout even when zoomed.
@
text
@d1 1
a1 1
/* $OpenBSD: format.c,v 1.62 2015/04/21 15:18:38 nicm Exp $ */
d624 1
@


1.62
log
@Put mouse_any_flag back, don't know where it went to (still in man page).
@
text
@d1 1
a1 1
/* $OpenBSD: format.c,v 1.61 2015/04/20 15:34:56 nicm Exp $ */
d580 4
a583 1
	layout = layout_dump(w);
@


1.61
log
@Support for multiple key tables to commands to be bound to sequences of
keys. The default key bindings become the "prefix" table and -n the
"root" table. Keys may be bound in new tables with bind -T and
switch-client -T used to specify the table in which the next key should
be looked up. Based on a diff from Keith Amling.
@
text
@d1 1
a1 1
/* $OpenBSD: format.c,v 1.60 2015/03/31 17:58:36 nicm Exp $ */
d732 2
@


1.60
log
@Add a helper function to convert time, and add session_activity formats
(the latter from Takatoshi Matsumoto).
@
text
@d1 1
a1 1
/* $OpenBSD: format.c,v 1.59 2015/03/31 17:45:10 nicm Exp $ */
d548 5
a552 1
	format_add(ft, "client_prefix", "%d", !!(c->flags & CLIENT_PREFIX));
@


1.59
log
@Fix some format specifier nits, from Ben Boeckel.
@
text
@d1 1
a1 1
/* $OpenBSD: format.c,v 1.58 2015/02/06 17:11:39 nicm Exp $ */
d40 1
d457 12
a495 1
	char			*tim;
d513 5
a517 3
	tim = ctime(&t);
	*strchr(tim, '\n') = '\0';
	format_add(ft, "session_created_string", "%s", tim);
d527 1
a527 1
	char		*tim;
a528 1
	struct session	*s;
d542 1
a542 3
	tim = ctime(&t);
	*strchr(tim, '\n') = '\0';
	format_add(ft, "client_created_string", "%s", tim);
d546 1
a546 3
	tim = ctime(&t);
	*strchr(tim, '\n') = '\0';
	format_add(ft, "client_activity_string", "%s", tim);
@


1.58
log
@Add format_expand_time and use it instead of status_replace where
command execution is not needed.
@
text
@d1 1
a1 1
/* $OpenBSD: format.c,v 1.57 2015/02/05 10:29:43 nicm Exp $ */
d506 1
a506 1
	format_add(ft, "session_many_attached", "%u", s->attached > 1);
d575 1
a575 1
	format_add(ft, "window_zoomed_flag", "%u",
d600 1
a600 1
	format_add(ft, "window_bell_flag", "%u",
d602 1
a602 1
	format_add(ft, "window_activity_flag", "%u",
d604 1
a604 1
	format_add(ft, "window_silence_flag", "%u",
d606 1
a606 1
	format_add(ft, "window_last_flag", "%u",
d626 1
a626 1
		evbuffer_add_printf(buffer, "%d", i);
d697 6
a702 6
	format_add(ft, "cursor_x", "%d", wp->base.cx);
	format_add(ft, "cursor_y", "%d", wp->base.cy);
	format_add(ft, "scroll_region_upper", "%d", wp->base.rupper);
	format_add(ft, "scroll_region_lower", "%d", wp->base.rlower);
	format_add(ft, "saved_cursor_x", "%d", wp->ictx.old_cx);
	format_add(ft, "saved_cursor_y", "%d", wp->ictx.old_cy);
d705 2
a706 2
	format_add(ft, "alternate_saved_x", "%d", wp->saved_cx);
	format_add(ft, "alternate_saved_y", "%d", wp->saved_cy);
@


1.57
log
@Wrap all the individual format_* calls in a single format_defaults
functions.
@
text
@d1 1
a1 1
/* $OpenBSD: format.c,v 1.56 2015/01/11 04:14:40 deraadt Exp $ */
d329 27
d364 3
@


1.56
log
@correctly use HOST_NAME_MAX.

Some notes:
POSIX HOST_NAME_MAX doesn't include the NUL.
POSIX LOGIN_NAME_MAX and TTY_NAME_MAX do include the NUL.

BSD MAXHOSTNAMELEN includes the NUL.  Actually, most of the historical
BSD MAX* defines did include the NUL, except for the historical
mistake of utmp fields without NULs in the string, which directly led
to strncpy..  just showing how error prone this kind of accounting is.
CSRG did right.  Somehow POSIX missed the memo on the concepts of
carefulness and consistancy, and we are still paying the price when
people trip over this.  Of course, glibc is even more amazing (that is
a hint to blackhats)

ok guenther
@
text
@d1 1
a1 1
/* $OpenBSD: format.c,v 1.55 2014/12/09 19:23:35 nicm Exp $ */
d41 6
a46 1
void	 format_window_pane_tabs(struct format_tree *, struct window_pane *);
d426 22
d450 1
a450 1
format_session(struct format_tree *ft, struct session *s)
d481 1
a481 1
format_client(struct format_tree *ft, struct client *c)
d531 1
a531 1
format_window(struct format_tree *ft, struct window *w)
d553 2
a554 1
format_winlink(struct format_tree *ft, struct session *s, struct winlink *wl)
d564 1
a564 1
	format_window(ft, w);
d584 1
a584 1
format_window_pane_tabs(struct format_tree *ft, struct window_pane *wp)
d606 1
a606 1
format_window_pane(struct format_tree *ft, struct window_pane *wp)
d696 1
a696 1
	format_window_pane_tabs(ft, wp);
d701 1
a701 1
format_paste_buffer(struct format_tree *ft, struct paste_buffer *pb,
@


1.55
log
@Add pane_dead_status for exit status of dead panes.
@
text
@d1 1
a1 1
/* $OpenBSD: format.c,v 1.54 2014/12/02 23:19:45 nicm Exp $ */
d136 1
a136 1
	char			 host[MAXHOSTNAMELEN], *ptr;
@


1.54
log
@Permit option values to be used in formats.
@
text
@d1 1
a1 1
/* $OpenBSD: format.c,v 1.53 2014/12/01 14:30:18 nicm Exp $ */
d20 1
d585 1
d609 5
a614 1
	format_add(ft, "pane_input_off", "%d", !!(wp->flags & PANE_INPUTOFF));
@


1.53
log
@Check ZOOMED flag on window.
@
text
@d1 1
a1 1
/* $OpenBSD: format.c,v 1.52 2014/11/08 12:50:38 nicm Exp $ */
d42 16
d59 3
a61 1
RB_GENERATE(format_tree, format_entry, entry, format_cmp);
d137 2
a138 2
	ft = xmalloc(sizeof *ft);
	RB_INIT(ft);
d154 1
a154 6
	struct format_entry	*fe, *fe_next;

	fe_next = RB_MIN(format_tree, ft);
	while (fe_next != NULL) {
		fe = fe_next;
		fe_next = RB_NEXT(format_tree, ft, fe);
d156 2
a157 1
		RB_REMOVE(format_tree, ft, fe);
d181 1
a181 1
	fe_now = RB_INSERT(format_tree, ft, fe);
d195 23
d220 1
a220 1
	fe = RB_FIND(format_tree, ft, &fe_find);
d245 1
a245 1
	if (!islower((u_char) *copy) && *copy != '?') {
d428 2
d459 3
d507 2
d530 3
d584 3
@


1.52
log
@Empty strings should be false too for #{?}, from Marc Finet.
@
text
@d1 1
a1 1
/* $OpenBSD: format.c,v 1.51 2014/10/25 08:47:04 nicm Exp $ */
d473 2
a501 2
	format_add(ft, "window_zoomed_flag", "%u",
	    !!(wl->flags & WINDOW_ZOOMED));
@


1.51
log
@Add pane_input_off format, from Anish R Athalye.
@
text
@d1 1
a1 1
/* $OpenBSD: format.c,v 1.50 2014/10/08 17:35:58 nicm Exp $ */
d239 2
a240 1
		if (value != NULL && (value[0] != '0' || value[1] != '\0')) {
@


1.50
log
@Add xreallocarray and remove nmemb argument from xrealloc.
@
text
@d1 1
a1 1
/* $OpenBSD: format.c,v 1.49 2014/09/08 14:29:05 nicm Exp $ */
d557 1
@


1.49
log
@Add window_last_flag and window_zoomed_flag. From John Morrissey.
@
text
@d1 1
a1 1
/* $OpenBSD: format.c,v 1.48 2014/08/09 07:33:37 nicm Exp $ */
d270 1
a270 1
		*buf = xrealloc(*buf, 2, *len);
d301 1
a301 1
				buf = xrealloc(buf, 2, len);
d329 1
a329 1
				buf = xrealloc(buf, 2, len);
d342 1
a342 1
					buf = xrealloc(buf, 2, len);
@


1.48
log
@Remove support for the continuous reporting "any" mouse mode which never
really worked properly and is rarely used.
@
text
@d1 1
a1 1
/* $OpenBSD: format.c,v 1.47 2014/05/27 12:49:36 nicm Exp $ */
d497 4
a500 1

@


1.47
log
@Add some formats for pane bounds.
@
text
@d1 1
a1 1
/* $OpenBSD: format.c,v 1.46 2014/05/13 08:08:32 nicm Exp $ */
a603 2
	format_add(ft, "mouse_any_flag", "%d",
	    !!(wp->base.mode & MODE_MOUSE_ANY));
@


1.46
log
@If multiple arguments are given to new-session, new-window,
split-window, respawn-window or respawn-pane, pass them directly to
execvp() to help avoid quoting problems. One argument still goes to "sh
-c" like before. Requested by many over the years. Patch from J Raynor.
@
text
@d1 1
a1 1
/* $OpenBSD: format.c,v 1.45 2014/05/13 07:34:35 nicm Exp $ */
d554 7
@


1.45
log
@Add support for named buffers. If you don't name a buffer, things work
much as before - buffers are automatically named "buffer0000",
"buffer0001" and so on and ordered as a stack. Buffers can be named
explicitly when creating ("loadb -b foo" etc) or renamed ("setb -b
buffer0000 -n foo"). If buffers are named explicitly, they are not
deleted when buffer-limit is reached. Diff from J Raynor.
@
text
@d1 1
a1 1
/* $OpenBSD: format.c,v 1.44 2014/04/17 15:37:55 nicm Exp $ */
d371 1
a371 1
		cmd = xstrdup(wp->cmd);
d562 4
a565 2
	if (wp->cmd != NULL)
		format_add(ft, "pane_start_command", "%s", wp->cmd);
@


1.44
log
@Add some UTF-8 utility functions and use them to prevent the width limit
on formats from splitting UTF-8 characters improperly.
@
text
@d1 1
a1 1
/* $OpenBSD: format.c,v 1.43 2014/04/17 07:36:45 nicm Exp $ */
d611 1
@


1.43
log
@Remove the monitor-content option and associated bits and bobs. It's
never worked very well. If there is a big demand for it to return, will
consider better ways to do it.
@
text
@d1 1
a1 1
/* $OpenBSD: format.c,v 1.42 2014/04/02 18:12:18 nicm Exp $ */
d197 1
a197 1
	char		*copy, *copy0, *endptr, *ptr, *saved;
d200 1
a200 1
	u_long		 limit = ULONG_MAX;
a258 1
	valuelen = strlen(value);
d261 6
a266 2
	if (valuelen > limit)
		valuelen = limit;
@


1.42
log
@Support UTF-8 with choose-buffer, from Kosuke ASAMI. Also make
buffer_sample bigger to let it trim at window right edge.
@
text
@d1 1
a1 1
/* $OpenBSD: format.c,v 1.41 2014/03/31 21:37:55 nicm Exp $ */
a489 2
	format_add(ft, "window_content_flag", "%u",
	    !!(wl->flags & WINLINK_CONTENT));
@


1.41
log
@Make session_attached a count and add session_many_attached flag.
@
text
@d1 1
a1 1
/* $OpenBSD: format.c,v 1.40 2013/11/24 11:29:09 nicm Exp $ */
d604 2
a605 1
format_paste_buffer(struct format_tree *ft, struct paste_buffer *pb)
d607 1
a607 1
	char	*pb_print = paste_print(pb, 50);
a609 1
	format_add(ft, "buffer_sample", "%s", pb_print);
d611 3
a613 1
	free(pb_print);
@


1.40
log
@Replace ## by # in format.
@
text
@d1 1
a1 1
/* $OpenBSD: format.c,v 1.39 2013/10/11 08:03:43 nicm Exp $ */
d404 2
a405 4
	if (s->flags & SESSION_UNATTACHED)
		format_add(ft, "session_attached", "%d", 0);
	else
		format_add(ft, "session_attached", "%d", 1);
@


1.39
log
@And get it right this time... don't leak if it is an empty string either.
@
text
@d1 1
a1 1
/* $OpenBSD: format.c,v 1.38 2013/10/11 08:01:29 nicm Exp $ */
d323 7
@


1.38
log
@Don't free the pane name by accident.
@
text
@d1 1
a1 1
/* $OpenBSD: format.c,v 1.37 2013/10/10 23:31:03 nicm Exp $ */
d360 1
d362 2
a363 1
		if (cmd == NULL || *cmd == '\0')
d365 1
@


1.37
log
@Fix leak in format_get_command.
@
text
@d1 1
a1 1
/* $OpenBSD: format.c,v 1.36 2013/10/10 12:39:24 nicm Exp $ */
d360 1
a360 1
		cmd = wp->cmd;
d362 1
a362 1
			cmd = wp->shell;
@


1.36
log
@Remove the KERN_PROC_CWD the proc_current_path format (which is the only
thing that uses it now).
@
text
@d1 1
a1 1
/* $OpenBSD: format.c,v 1.35 2013/10/10 12:35:31 nicm Exp $ */
d356 1
a356 1
	char	*cmd;
d364 3
a366 1
	return (parse_window_name(cmd));
@


1.35
log
@Use format_get_command() and some spacing tweaks.
@
text
@d1 1
a1 1
/* $OpenBSD: format.c,v 1.34 2013/10/10 12:26:35 nicm Exp $ */
a520 1
	const char		*cwd;
a552 2
	if ((cwd = get_proc_cwd(wp->fd)) != NULL)
		format_add(ft, "pane_current_path", "%s", cwd);
@


1.34
log
@Alter how tmux handles the working directory to internally use file
descriptors rather than strings.

- Each session still has a current working directory.

- New sessions still get their working directory from the client that
  created them or its attached session if any.

- New windows are created by default in the session working directory.

- The -c flag to new, neww, splitw allows the working directory to be
  overridden.

- The -c flag to attach let's the session working directory be changed.

- The default-path option has been removed.

To get the equivalent to default-path '.', do:

        bind c neww -c $PWD

To get the equivalent of default-path '~', do:

        bind c neww -c ~

This also changes the client identify protocol to be a set of messages rather
than one as well as some other changes that should make it easier to make
backwards-compatible protocol changes in future.
@
text
@d1 1
a1 1
/* $OpenBSD: format.c,v 1.33 2013/10/10 12:04:01 nicm Exp $ */
d556 1
a556 1
	if ((cmd = get_proc_name(wp->fd, wp->tty)) != NULL) {
@


1.33
log
@First period not last for host_short, from Michael Scholz.
@
text
@d1 1
a1 1
/* $OpenBSD: format.c,v 1.32 2013/10/10 11:56:50 nicm Exp $ */
a405 1
	format_add(ft, "client_cwd", "%s", c->cwd);
a553 2
	if (wp->cwd != NULL)
		format_add(ft, "pane_start_path", "%s", wp->cwd);
@


1.32
log
@Add automatic-rename-format option allowing automatic rename to use
something other than pane_current_command.
@
text
@d1 1
a1 1
/* $OpenBSD: format.c,v 1.31 2013/10/10 11:50:36 nicm Exp $ */
d124 1
a124 1
		if ((ptr = strrchr(host, '.')) != NULL)
@


1.31
log
@Allow nested format expansion.
@
text
@d1 1
a1 1
/* $OpenBSD: format.c,v 1.30 2013/10/10 11:50:20 nicm Exp $ */
d37 4
a40 3
int	format_replace(struct format_tree *, const char *, size_t, char **,
	    size_t *, size_t *);
void	format_window_pane_tabs(struct format_tree *, struct window_pane *);
d352 15
d446 18
d469 1
a469 1
	char		*layout, *flags;
a470 1
	layout = layout_dump(w);
d473 2
a474 1
	format_add(ft, "window_id", "@@%u", w->id);
a475 3
	format_add(ft, "window_name", "%s", w->name);
	format_add(ft, "window_width", "%u", w->sx);
	format_add(ft, "window_height", "%u", w->sy);
a476 1
	format_add(ft, "window_layout", "%s", layout);
a477 1
	format_add(ft, "window_panes", "%u", window_count_panes(w));
d488 1
a489 1
	free(layout);
@


1.30
log
@Add length limit operator for formats.
@
text
@d1 1
a1 1
/* $OpenBSD: format.c,v 1.29 2013/10/10 11:47:52 nicm Exp $ */
d196 1
a196 1
	char		*copy, *copy0, *endptr, *ptr;
d250 2
d256 1
d272 1
d285 2
a286 2
	char		*buf, *ptr;
	const char	*s;
d288 1
a288 1
	int     	 ch;
a305 1

d308 8
a315 2
			ptr = strchr(fmt, '}');
			if (ptr == NULL)
@


1.29
log
@Add formats for window flags.
@
text
@d1 1
a1 1
/* $OpenBSD: format.c,v 1.28 2013/10/10 11:47:28 nicm Exp $ */
d21 2
d193 2
a194 2
format_replace(struct format_tree *ft,
    const char *key, size_t keylen, char **buf, size_t *len, size_t *off)
d196 1
a196 1
	char		*copy, *ptr;
d199 1
d202 1
a202 1
	copy = xmalloc(keylen + 1);
d206 21
d257 4
d269 1
a269 1
	free(copy);
d273 1
a273 1
	free(copy);
@


1.28
log
@Don't leak formats if they are added multiple times.
@
text
@d1 1
a1 1
/* $OpenBSD: format.c,v 1.27 2013/10/10 11:47:11 nicm Exp $ */
d412 9
@


1.27
log
@Don't add client formats when they are NULL.
@
text
@d1 1
a1 1
/* $OpenBSD: format.c,v 1.26 2013/07/05 15:27:14 nicm Exp $ */
d154 1
d164 7
a170 1
	RB_INSERT(format_tree, ft, fe);
@


1.26
log
@Add pane_synchronized format, from Romain Francoise.
@
text
@d1 1
a1 1
/* $OpenBSD: format.c,v 1.25 2013/05/31 19:46:42 nicm Exp $ */
d349 4
a352 2
	format_add(ft, "client_tty", "%s", c->tty.path);
	format_add(ft, "client_termname", "%s", c->tty.termname);
@


1.25
log
@Add host_short format, from Tiago Cunha.
@
text
@d1 1
a1 1
/* $OpenBSD: format.c,v 1.24 2013/04/17 14:52:31 deraadt Exp $ */
d463 2
@


1.24
log
@(long long) and %lld for time_t output
ok nicm
@
text
@d1 1
a1 1
/* $OpenBSD: format.c,v 1.23 2013/03/25 11:40:54 nicm Exp $ */
d49 2
a50 2
/* Single-character aliases. */
const char *format_aliases[26] = {
d79 30
d114 1
a114 1
	char			 host[MAXHOSTNAMELEN];
d119 1
a119 1
	if (gethostname(host, sizeof host) == 0)
d121 4
d146 1
a146 1
	free (ft);
d267 1
d280 9
a288 8
			if (ch >= 'A' && ch <= 'Z') {
				s = format_aliases[ch - 'A'];
				if (s != NULL) {
					n = strlen(s);
					if (format_replace (
					    ft, s, n, &buf, &len, &off) != 0)
						break;
					continue;
d290 3
d294 3
a296 6
			while (len - off < 3) {
				buf = xrealloc(buf, 2, len);
				len *= 2;
			}
			buf[off++] = '#';
			buf[off++] = ch;
@


1.23
log
@Include prefix on ids, from George Nachman.
@
text
@d1 1
a1 1
/* $OpenBSD: format.c,v 1.22 2013/03/25 10:11:45 nicm Exp $ */
d291 1
a291 1
	format_add(ft, "session_created", "%ld", (long) t);
d317 1
a317 1
	format_add(ft, "client_created", "%ld", (long) t);
d323 1
a323 1
	format_add(ft, "client_activity", "%ld", (long) t);
@


1.22
log
@Rename session idx to session id throughout and add $ prefix to targets
to use it, extended from a diff from George Nachman.
@
text
@d1 1
a1 1
/* $OpenBSD: format.c,v 1.21 2013/03/25 10:07:21 nicm Exp $ */
d283 1
a283 1
	format_add(ft, "session_id", "%u", s->id);
@


1.21
log
@Do not leak command in formats, from Romain Francoise.
@
text
@d1 1
a1 1
/* $OpenBSD: format.c,v 1.20 2013/03/24 09:54:10 nicm Exp $ */
d283 1
@


1.20
log
@Add a command queue to standardize and simplify commands that call other
commands and allow a command to block execution of subsequent
commands. This allows run-shell and if-shell to be synchronous which has
been much requested.

Each client has a default command queue and commands are consumed one at
a time from it. A command may suspend execution from the queue by
returning CMD_RETURN_WAIT and then resume it by calling cmd_continue() -
for example run-shell does this from the callback that is fired after
the job is freed.

When the command queue becomes empty, command clients are automatically
exited (unless attaching). A callback is also fired - this is used for
nested commands in, for example, if-shell which can block execution of
the client's cmdq until a new cmdq becomes empty.

Also merge all the old error/info/print functions together and lose the
old curclient/cmdclient distinction - a cmdq is bound to one client (or
none if in the configuration file), this is a command client if
c->session is NULL otherwise an attached client.
@
text
@d1 1
a1 1
/* $OpenBSD: format.c,v 1.19 2013/03/24 09:29:40 nicm Exp $ */
d401 2
a402 1
	const char		*cwd, *cmd;
d436 1
a436 1
	if ((cmd = get_proc_name(wp->fd, wp->tty)) != NULL)
d438 2
@


1.19
log
@Add pane_tabs format to format_window_pane based on code from George
Nachman.
@
text
@d1 1
a1 1
/* $OpenBSD: format.c,v 1.18 2013/03/24 09:23:00 nicm Exp $ */
d400 2
a401 4
	u_int			 i;
	u_int			 idx;
	const char		*cwd;
	const char		*cmd;
@


1.18
log
@Whoops fix build.
@
text
@d1 1
a1 1
/* $OpenBSD: format.c,v 1.17 2013/03/24 09:19:51 nicm Exp $ */
d35 3
a37 2
int	format_replace(struct format_tree *,
	    const char *, size_t, char **, size_t *, size_t *);
d371 22
d470 2
d474 1
@


1.17
log
@Add pane_current_command format.
@
text
@d1 1
a1 1
/* $OpenBSD: format.c,v 1.16 2013/03/22 16:03:35 nicm Exp $ */
d414 1
a414 1
	if ((cmd = osdep_get_name(wp->fd, wp->tty)) != NULL)
@


1.16
log
@Add a load of miscellaneous pane formats, from George Nachman.
@
text
@d1 1
a1 1
/* $OpenBSD: format.c,v 1.15 2013/03/22 10:32:36 nicm Exp $ */
d380 1
d414 2
@


1.15
log
@Add client_session and client_last_session formats.
@
text
@d1 1
a1 1
/* $OpenBSD: format.c,v 1.14 2013/03/21 16:14:09 nicm Exp $ */
d387 3
d393 1
a397 4
	format_add(ft, "pane_index", "%u", idx);
	format_add(ft, "history_size", "%u", gd->hsize);
	format_add(ft, "history_limit", "%u", gd->hlimit);
	format_add(ft, "history_bytes", "%llu", size);
d401 6
d413 31
a443 3
	format_add(ft, "pane_pid", "%ld", (long) wp->pid);
	if (wp->tty != NULL)
		format_add(ft, "pane_tty", "%s", wp->tty);
@


1.14
log
@Add a format client_prefix which is 1 if prefix key has been
pressed, used for example #{?client_prefix,X,Y}. Also a few extra
server_client_status needed.
@
text
@d1 1
a1 1
/* $OpenBSD: format.c,v 1.13 2013/03/21 16:13:24 nicm Exp $ */
d304 3
a306 2
	char	*tim;
	time_t	 t;
d337 7
@


1.13
log
@Allow formats in status options.
@
text
@d1 1
a1 1
/* $OpenBSD: format.c,v 1.12 2013/02/05 11:01:45 nicm Exp $ */
d324 2
@


1.12
log
@Don't set some string formats if the string is NULL.
@
text
@d1 1
a1 1
/* $OpenBSD: format.c,v 1.11 2013/01/18 02:16:21 nicm Exp $ */
d254 1
a254 1
			while (len - off < 2) {
d258 1
@


1.11
log
@Rather than having two grids for each pane, one for ASCII and one for
UTF-8, collapse the two together. Simplifies the code at the expense of
more memory (which can probably be reduced again later).
@
text
@d1 1
a1 1
/* $OpenBSD: format.c,v 1.10 2012/09/24 13:05:10 nicm Exp $ */
d368 1
d394 2
a395 1
	format_add(ft, "pane_current_path", "%s", get_proc_cwd(wp->fd));
d397 2
a398 1
	format_add(ft, "pane_tty", "%s", wp->tty);
@


1.10
log
@Use pgrp of pty fd not pid of immediate child when recovering current
working directory (like current process). From Marcel Partap.
@
text
@d1 1
a1 1
/* $OpenBSD: format.c,v 1.9 2012/07/10 11:53:01 nicm Exp $ */
a372 1
		size += gl->utf8size * sizeof *gl->utf8data;
@


1.9
log
@xfree is not particularly helpful, remove it. From Thomas Adam.
@
text
@d1 1
a1 1
/* $OpenBSD: format.c,v 1.8 2012/05/22 11:35:37 nicm Exp $ */
d394 1
a394 1
	format_add(ft, "pane_current_path", "%s", get_proc_cwd(wp->pid));
@


1.8
log
@Switch all of the various choose- and list- commands over to the format
infrastructure, from Thomas Adam.
@
text
@d1 1
a1 1
/* $OpenBSD: format.c,v 1.7 2012/04/01 10:42:39 nicm Exp $ */
d23 1
d106 3
a108 3
		xfree(fe->value);
		xfree(fe->key);
		xfree(fe);
d111 1
a111 1
	xfree (ft);
d199 1
a199 1
	xfree(copy);
d203 1
a203 1
	xfree(copy);
d355 2
a356 2
	xfree(flags);
	xfree(layout);
d407 1
a407 1
	xfree(pb_print);
@


1.7
log
@Add pane_current_path format, suggested by Mikolaj Kucharski.
@
text
@d1 1
a1 1
/* $OpenBSD: format.c,v 1.6 2012/02/02 00:03:45 nicm Exp $ */
d352 1
d396 11
@


1.6
log
@Get client_width and client_height the right way round, from Stephen
Thirlwall.
@
text
@d1 1
a1 1
/* $OpenBSD: format.c,v 1.5 2012/01/30 09:39:34 nicm Exp $ */
d392 1
@


1.5
log
@Give each window a unique id, like panes but prefixed with @@. Based on
work from George Nachman.
@
text
@d1 1
a1 1
/* $OpenBSD: format.c,v 1.4 2011/11/15 23:21:52 nicm Exp $ */
d306 2
a307 2
	format_add(ft, "client_height", "%u", c->tty.sx);
	format_add(ft, "client_width", "%u", c->tty.sy);
@


1.4
log
@Add a pane_index format string and use it, from Ben Boeckel.
@
text
@d1 1
a1 1
/* $OpenBSD: format.c,v 1.3 2011/10/23 01:12:46 nicm Exp $ */
d344 1
@


1.3
log
@Add client formats, from Ben Boeckel.
@
text
@d1 1
a1 1
/* $OpenBSD: format.c,v 1.2 2011/10/02 06:55:48 nicm Exp $ */
d364 1
d374 3
d380 1
@


1.2
log
@Add a few more formats for panes (tty, pid, start cmd/cwd).
@
text
@d1 1
a1 1
/* $OpenBSD: format.c,v 1.1 2011/08/26 10:53:16 nicm Exp $ */
d296 36
@


1.1
log
@Add initial framework for more powerful formatting of command output and
use it for list-{panes,windows,sessions}. This allows more descriptive
replacements (such as #{session_name}) and conditionals.

Later this will be used for status_replace and list-keys and other
places.
@
text
@d1 1
a1 1
/* $OpenBSD$ */
d346 6
@

