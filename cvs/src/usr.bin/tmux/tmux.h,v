head	1.751;
access;
symbols
	OPENBSD_6_1:1.733.0.4
	OPENBSD_6_1_BASE:1.733
	OPENBSD_6_0:1.640.0.2
	OPENBSD_6_0_BASE:1.640
	OPENBSD_5_9:1.620.0.2
	OPENBSD_5_9_BASE:1.620
	OPENBSD_5_8:1.531.0.4
	OPENBSD_5_8_BASE:1.531
	OPENBSD_5_7:1.490.0.2
	OPENBSD_5_7_BASE:1.490
	OPENBSD_5_6:1.466.0.4
	OPENBSD_5_6_BASE:1.466
	OPENBSD_5_5:1.437.0.4
	OPENBSD_5_5_BASE:1.437
	OPENBSD_5_4:1.415.0.2
	OPENBSD_5_4_BASE:1.415
	OPENBSD_5_3:1.374.0.2
	OPENBSD_5_3_BASE:1.374
	OPENBSD_5_2:1.349.0.2
	OPENBSD_5_2_BASE:1.349
	OPENBSD_5_1_BASE:1.311
	OPENBSD_5_1:1.311.0.2
	OPENBSD_5_0:1.292.0.2
	OPENBSD_5_0_BASE:1.292
	OPENBSD_4_9:1.271.0.2
	OPENBSD_4_9_BASE:1.271
	OPENBSD_4_8:1.236.0.2
	OPENBSD_4_8_BASE:1.236
	OPENBSD_4_7:1.209.0.2
	OPENBSD_4_7_BASE:1.209
	OPENBSD_4_6:1.15.0.4
	OPENBSD_4_6_BASE:1.15;
locks; strict;
comment	@ * @;


1.751
date	2017.04.22.10.22.39;	author nicm;	state Exp;
branches;
next	1.750;
commitid	RXMp6wwG5a5Y82bo;

1.750
date	2017.04.21.20.26.34;	author nicm;	state Exp;
branches;
next	1.749;
commitid	utIGVdoSurUxfh14;

1.749
date	2017.04.21.18.18.17;	author nicm;	state Exp;
branches;
next	1.748;
commitid	3KK6QKdcQSP3N5qp;

1.748
date	2017.04.21.17.22.20;	author nicm;	state Exp;
branches;
next	1.747;
commitid	vF4GzIrs1TJPdLpP;

1.747
date	2017.04.21.16.04.18;	author nicm;	state Exp;
branches;
next	1.746;
commitid	QOXi0jcfhHEFBBHZ;

1.746
date	2017.04.21.14.09.44;	author nicm;	state Exp;
branches;
next	1.745;
commitid	EVv6VwyOvKb6JnQz;

1.745
date	2017.04.21.14.01.19;	author nicm;	state Exp;
branches;
next	1.744;
commitid	6dh4rgGOD5wckeD9;

1.744
date	2017.04.20.17.49.26;	author nicm;	state Exp;
branches;
next	1.743;
commitid	OfL2Obmz7xdpsjZq;

1.743
date	2017.04.20.09.43.45;	author nicm;	state Exp;
branches;
next	1.742;
commitid	wTqD4LJDLZSJgn81;

1.742
date	2017.04.20.09.39.07;	author nicm;	state Exp;
branches;
next	1.741;
commitid	UvG2E3PZHiLbgCmS;

1.741
date	2017.04.20.09.20.22;	author nicm;	state Exp;
branches;
next	1.740;
commitid	Mq5Wq9pThOn7RhSJ;

1.740
date	2017.04.19.14.00.28;	author nicm;	state Exp;
branches;
next	1.739;
commitid	VxIcEJR3Nj27vycD;

1.739
date	2017.04.19.06.52.27;	author nicm;	state Exp;
branches;
next	1.738;
commitid	J75yaiuz8O54rLmn;

1.738
date	2017.04.18.21.41.42;	author nicm;	state Exp;
branches;
next	1.737;
commitid	olMj0aSNSMEU2X3g;

1.737
date	2017.04.18.18.21.37;	author nicm;	state Exp;
branches;
next	1.736;
commitid	puXYAvHBv1XeJmEe;

1.736
date	2017.04.18.15.44.17;	author nicm;	state Exp;
branches;
next	1.735;
commitid	bYu9iw9cp97E6crN;

1.735
date	2017.04.17.06.40.32;	author nicm;	state Exp;
branches;
next	1.734;
commitid	VGpPUc11r7Q41gvd;

1.734
date	2017.04.05.10.49.46;	author nicm;	state Exp;
branches;
next	1.733;
commitid	1mjoRYvghWl25dW0;

1.733
date	2017.03.22.07.16.54;	author nicm;	state Exp;
branches;
next	1.732;
commitid	YlKgZy2nlCejSvNQ;

1.732
date	2017.03.09.17.06.35;	author nicm;	state Exp;
branches;
next	1.731;
commitid	BJxoAdDkAuPxTBwC;

1.731
date	2017.03.09.17.02.38;	author nicm;	state Exp;
branches;
next	1.730;
commitid	QtFskEpSXY809LlK;

1.730
date	2017.03.08.13.36.12;	author nicm;	state Exp;
branches;
next	1.729;
commitid	jI8R4kuPSDw6nngR;

1.729
date	2017.02.27.13.07.57;	author nicm;	state Exp;
branches;
next	1.728;
commitid	xaSatUk82c2wHmar;

1.728
date	2017.02.21.14.18.12;	author nicm;	state Exp;
branches;
next	1.727;
commitid	Lw2yDuABK2nzv3LB;

1.727
date	2017.02.14.18.13.05;	author nicm;	state Exp;
branches;
next	1.726;
commitid	xvcFJuJjtbCqRtLW;

1.726
date	2017.02.10.12.59.18;	author nicm;	state Exp;
branches;
next	1.725;
commitid	P7xSjiy29fJgUATs;

1.725
date	2017.02.09.15.04.53;	author nicm;	state Exp;
branches;
next	1.724;
commitid	LotTNNNN3Vrlt9Fn;

1.724
date	2017.02.09.12.09.33;	author nicm;	state Exp;
branches;
next	1.723;
commitid	R14ylgibGw7VkoGU;

1.723
date	2017.02.08.23.53.03;	author nicm;	state Exp;
branches;
next	1.722;
commitid	vbFmEbkUQGcgwXYc;

1.722
date	2017.02.08.23.47.35;	author nicm;	state Exp;
branches;
next	1.721;
commitid	U3kIivCSLZ29e6GT;

1.721
date	2017.02.08.17.31.09;	author nicm;	state Exp;
branches;
next	1.720;
commitid	AzNCw8YfPlNCzX1E;

1.720
date	2017.02.08.16.45.18;	author nicm;	state Exp;
branches;
next	1.719;
commitid	ZNCPaF6tGzHeJGxd;

1.719
date	2017.02.08.08.50.10;	author nicm;	state Exp;
branches;
next	1.718;
commitid	5cRmkTFFolQ68i4L;

1.718
date	2017.02.08.08.25.12;	author nicm;	state Exp;
branches;
next	1.717;
commitid	rYBoJWPEuxHYqS9Q;

1.717
date	2017.02.06.22.05.11;	author nicm;	state Exp;
branches;
next	1.716;
commitid	EudrDiTB8CsH17qW;

1.716
date	2017.02.06.19.45.23;	author nicm;	state Exp;
branches;
next	1.715;
commitid	TdUc3pYVaobdWEim;

1.715
date	2017.02.06.19.26.49;	author nicm;	state Exp;
branches;
next	1.714;
commitid	Rhdtq12XKh2I54nR;

1.714
date	2017.02.06.15.00.41;	author nicm;	state Exp;
branches;
next	1.713;
commitid	2TKl6DV1kcWaPxr9;

1.713
date	2017.02.06.13.23.00;	author nicm;	state Exp;
branches;
next	1.712;
commitid	qejB8XDaRPwhZhRq;

1.712
date	2017.02.03.21.01.02;	author nicm;	state Exp;
branches;
next	1.711;
commitid	MRFqlgnbMk0ZRnKS;

1.711
date	2017.02.03.11.57.27;	author nicm;	state Exp;
branches;
next	1.710;
commitid	BLRh0qXo7OVTPhiT;

1.710
date	2017.02.01.09.55.07;	author nicm;	state Exp;
branches;
next	1.709;
commitid	FpFenXzt7GohJ3lb;

1.709
date	2017.01.30.21.41.17;	author nicm;	state Exp;
branches;
next	1.708;
commitid	2CvN8VpguQcq8POo;

1.708
date	2017.01.25.14.36.08;	author nicm;	state Exp;
branches;
next	1.707;
commitid	Qp0SbpiBu6Bm6g4g;

1.707
date	2017.01.25.14.24.54;	author nicm;	state Exp;
branches;
next	1.706;
commitid	lN9aftWGvZoDBI6a;

1.706
date	2017.01.24.21.50.23;	author nicm;	state Exp;
branches;
next	1.705;
commitid	RhpGrb29XR7z4pyo;

1.705
date	2017.01.24.20.15.32;	author nicm;	state Exp;
branches;
next	1.704;
commitid	OhhGixV64mirqDj8;

1.704
date	2017.01.24.19.53.37;	author nicm;	state Exp;
branches;
next	1.703;
commitid	APEyI6NiCN6S4KhZ;

1.703
date	2017.01.24.19.11.46;	author nicm;	state Exp;
branches;
next	1.702;
commitid	kKr1lZUu2NYuA7Hw;

1.702
date	2017.01.23.10.09.43;	author nicm;	state Exp;
branches;
next	1.701;
commitid	anZBbATBZNigju2F;

1.701
date	2017.01.18.10.08.05;	author nicm;	state Exp;
branches;
next	1.700;
commitid	xB3kWBq9sJabS6m7;

1.700
date	2017.01.16.14.52.25;	author nicm;	state Exp;
branches;
next	1.699;
commitid	DhrjePH0tXykfoeE;

1.699
date	2017.01.16.14.49.14;	author nicm;	state Exp;
branches;
next	1.698;
commitid	4TgBXjnsq23XHMH4;

1.698
date	2017.01.15.22.00.56;	author nicm;	state Exp;
branches;
next	1.697;
commitid	P8Zuj7wnJMd8B8vz;

1.697
date	2017.01.15.20.48.41;	author nicm;	state Exp;
branches;
next	1.696;
commitid	osUO2wUOqrqm0Q8V;

1.696
date	2017.01.13.11.58.49;	author nicm;	state Exp;
branches;
next	1.695;
commitid	IPLHEki7vNAmEUCr;

1.695
date	2017.01.13.11.56.43;	author nicm;	state Exp;
branches;
next	1.694;
commitid	ue6KcgTetKiECTMk;

1.694
date	2017.01.13.10.12.12;	author nicm;	state Exp;
branches;
next	1.693;
commitid	bQ0icVBejLnBpF27;

1.693
date	2017.01.12.15.36.35;	author nicm;	state Exp;
branches;
next	1.692;
commitid	TxelVequscBivd6R;

1.692
date	2017.01.12.10.15.55;	author nicm;	state Exp;
branches;
next	1.691;
commitid	tR9p5bWPfvbLb8Sj;

1.691
date	2017.01.12.00.19.32;	author nicm;	state Exp;
branches;
next	1.690;
commitid	5Rj7IbEXrGVYho74;

1.690
date	2017.01.11.16.09.57;	author nicm;	state Exp;
branches;
next	1.689;
commitid	6XANvQoNZoJEjE5C;

1.689
date	2017.01.11.16.05.46;	author nicm;	state Exp;
branches;
next	1.688;
commitid	vc1OjSamlGf0LeFN;

1.688
date	2017.01.11.14.56.44;	author nicm;	state Exp;
branches;
next	1.687;
commitid	OX4JTH65GquvrMVB;

1.687
date	2017.01.09.21.03.25;	author nicm;	state Exp;
branches;
next	1.686;
commitid	ZwBJ1q637vKZayHI;

1.686
date	2017.01.09.19.27.00;	author nicm;	state Exp;
branches;
next	1.685;
commitid	OxA55NgX2OxpYMnz;

1.685
date	2017.01.07.15.28.13;	author nicm;	state Exp;
branches;
next	1.684;
commitid	llgkTzvAhxXuSWDB;

1.684
date	2017.01.06.11.57.03;	author nicm;	state Exp;
branches;
next	1.683;
commitid	m6HBAjiRCa66sywZ;

1.683
date	2017.01.05.09.07.16;	author nicm;	state Exp;
branches;
next	1.682;
commitid	al9tcSDvFKlm4Qpq;

1.682
date	2016.12.28.10.34.34;	author nicm;	state Exp;
branches;
next	1.681;
commitid	LPxrRrTzsBpY7px2;

1.681
date	2016.11.24.18.45.45;	author nicm;	state Exp;
branches;
next	1.680;
commitid	hrLdEAZgp94v5471;

1.680
date	2016.11.24.13.38.44;	author nicm;	state Exp;
branches;
next	1.679;
commitid	xEmWv4VOf7iteHdC;

1.679
date	2016.11.23.17.01.24;	author nicm;	state Exp;
branches;
next	1.678;
commitid	MqQ1xWjJDuKsBsyT;

1.678
date	2016.11.16.00.24.03;	author nicm;	state Exp;
branches;
next	1.677;
commitid	ZQAQdE9Fy4gBpQvj;

1.677
date	2016.11.15.15.17.28;	author nicm;	state Exp;
branches;
next	1.676;
commitid	thg4UrdurnKYfFrH;

1.676
date	2016.11.15.14.02.32;	author nicm;	state Exp;
branches;
next	1.675;
commitid	DoED1csxpiOGsoJM;

1.675
date	2016.11.04.14.47.38;	author nicm;	state Exp;
branches;
next	1.674;
commitid	OiD1PXbeLHTuXNNF;

1.674
date	2016.10.19.09.22.07;	author nicm;	state Exp;
branches;
next	1.673;
commitid	leRKiNVAXYb2Wrn1;

1.673
date	2016.10.18.08.46.43;	author nicm;	state Exp;
branches;
next	1.672;
commitid	u6yWlpHFfUiScqCx;

1.672
date	2016.10.16.22.18.04;	author nicm;	state Exp;
branches;
next	1.671;
commitid	hN37jNkXLWeSlPkK;

1.671
date	2016.10.16.22.06.40;	author nicm;	state Exp;
branches;
next	1.670;
commitid	j0FZs70gSPCmpqWI;

1.670
date	2016.10.16.19.36.37;	author nicm;	state Exp;
branches;
next	1.669;
commitid	UfrPlTlFgpvE2jpY;

1.669
date	2016.10.16.19.15.02;	author nicm;	state Exp;
branches;
next	1.668;
commitid	BsOGDBdjoFC7iuvC;

1.668
date	2016.10.16.19.04.05;	author nicm;	state Exp;
branches;
next	1.667;
commitid	pxm6osuE99zELpkU;

1.667
date	2016.10.16.17.55.14;	author nicm;	state Exp;
branches;
next	1.666;
commitid	1xIYFpLYkPIXNEvU;

1.666
date	2016.10.15.09.27.52;	author nicm;	state Exp;
branches;
next	1.665;
commitid	3LOsIpF6UVTyfOf3;

1.665
date	2016.10.15.00.12.58;	author nicm;	state Exp;
branches;
next	1.664;
commitid	W1m68Q2tEflX7Raw;

1.664
date	2016.10.15.00.09.30;	author nicm;	state Exp;
branches;
next	1.663;
commitid	X2XXRCKiqkzI3Ni0;

1.663
date	2016.10.15.00.01.01;	author nicm;	state Exp;
branches;
next	1.662;
commitid	Y3LyKhemZ1e3lTtQ;

1.662
date	2016.10.13.22.48.51;	author nicm;	state Exp;
branches;
next	1.661;
commitid	1GCC1n59gejVg5Ih;

1.661
date	2016.10.13.20.27.27;	author nicm;	state Exp;
branches;
next	1.660;
commitid	txCyQ5BkKJtZRzfT;

1.660
date	2016.10.13.10.01.49;	author nicm;	state Exp;
branches;
next	1.659;
commitid	AFoah05fh4b2e28V;

1.659
date	2016.10.12.15.26.37;	author nicm;	state Exp;
branches;
next	1.658;
commitid	egGk3cDHeazu3VVH;

1.658
date	2016.10.12.14.50.14;	author nicm;	state Exp;
branches;
next	1.657;
commitid	2r95FFcJGHvdfgBR;

1.657
date	2016.10.12.13.24.07;	author nicm;	state Exp;
branches;
next	1.656;
commitid	qR81tw3cGEFCEM0c;

1.656
date	2016.10.12.13.03.27;	author nicm;	state Exp;
branches;
next	1.655;
commitid	eul7q5vzLp6bFmDk;

1.655
date	2016.10.11.13.45.47;	author nicm;	state Exp;
branches;
next	1.654;
commitid	m8cwMB6WuKLMPXh5;

1.654
date	2016.10.11.13.21.59;	author nicm;	state Exp;
branches;
next	1.653;
commitid	80rgEIPcNpyBnf95;

1.653
date	2016.10.11.09.30.36;	author nicm;	state Exp;
branches;
next	1.652;
commitid	OThpNjT1frpnaa0G;

1.652
date	2016.10.11.07.23.34;	author nicm;	state Exp;
branches;
next	1.651;
commitid	leUN1UeapgUoieJj;

1.651
date	2016.10.11.07.11.40;	author nicm;	state Exp;
branches;
next	1.650;
commitid	RhjRBUnJaRXbs4fU;

1.650
date	2016.10.10.17.28.30;	author nicm;	state Exp;
branches;
next	1.649;
commitid	CMho0Ft9MVt5ZzOC;

1.649
date	2016.10.10.13.54.47;	author nicm;	state Exp;
branches;
next	1.648;
commitid	OFXFRx5WnTtCw3R9;

1.648
date	2016.10.09.16.24.34;	author nicm;	state Exp;
branches;
next	1.647;
commitid	cy0Wx0yJbsZRARd0;

1.647
date	2016.10.05.12.34.05;	author nicm;	state Exp;
branches;
next	1.646;
commitid	ngPu4hsxEkYwKqTw;

1.646
date	2016.09.28.08.30.44;	author nicm;	state Exp;
branches;
next	1.645;
commitid	l0DpFzkilFIpFuoD;

1.645
date	2016.09.16.13.43.41;	author nicm;	state Exp;
branches;
next	1.644;
commitid	ykp4HhimaTwh0QYH;

1.644
date	2016.09.12.15.40.58;	author nicm;	state Exp;
branches;
next	1.643;
commitid	FmdCsJJj2mhuDrZn;

1.643
date	2016.09.04.17.37.06;	author nicm;	state Exp;
branches;
next	1.642;
commitid	D34i60nsvTyoBV4q;

1.642
date	2016.09.02.20.57.20;	author nicm;	state Exp;
branches;
next	1.641;
commitid	KNa3UznuiHkLoVpf;

1.641
date	2016.08.03.09.07.02;	author nicm;	state Exp;
branches;
next	1.640;
commitid	PiVgxuhKYG0ljj7x;

1.640
date	2016.07.15.09.52.34;	author nicm;	state Exp;
branches;
next	1.639;
commitid	GqpJHQB3A3bbJxMc;

1.639
date	2016.07.15.09.28.32;	author nicm;	state Exp;
branches;
next	1.638;
commitid	Bi60xSMBeQjDRMSa;

1.638
date	2016.07.15.00.49.08;	author nicm;	state Exp;
branches;
next	1.637;
commitid	4uHSvNNDvwUmOB9Y;

1.637
date	2016.07.15.00.42.56;	author nicm;	state Exp;
branches;
next	1.636;
commitid	EramuEV0ciOaJqkF;

1.636
date	2016.06.16.10.55.47;	author nicm;	state Exp;
branches;
next	1.635;
commitid	iwpkepU9NO5jIk1m;

1.635
date	2016.06.15.09.13.46;	author nicm;	state Exp;
branches;
next	1.634;
commitid	qFQIj3KrXkLdlwNy;

1.634
date	2016.06.06.07.28.52;	author nicm;	state Exp;
branches;
next	1.633;
commitid	SyahRiFMqLwjdSRW;

1.633
date	2016.06.06.07.24.31;	author nicm;	state Exp;
branches;
next	1.632;
commitid	E78aCj5t0oSJORb6;

1.632
date	2016.05.30.09.50.20;	author nicm;	state Exp;
branches;
next	1.631;
commitid	6UcyBBKbI1JUqfYo;

1.631
date	2016.05.27.17.05.42;	author nicm;	state Exp;
branches;
next	1.630;
commitid	1MCy1pI3Tx6IhcqA;

1.630
date	2016.05.12.16.05.33;	author tim;	state Exp;
branches;
next	1.629;
commitid	T3Sd9myvNE2f79sY;

1.629
date	2016.05.01.13.39.05;	author nicm;	state Exp;
branches;
next	1.628;
commitid	pVfiolwomsfXbbZY;

1.628
date	2016.04.30.18.59.02;	author nicm;	state Exp;
branches;
next	1.627;
commitid	WGzrFN9OgQx3k86Y;

1.627
date	2016.04.29.15.00.48;	author nicm;	state Exp;
branches;
next	1.626;
commitid	z5NrpOKjZoYhx6Qr;

1.626
date	2016.04.29.13.36.10;	author nicm;	state Exp;
branches;
next	1.625;
commitid	7Lz69alYJZN2W8qc;

1.625
date	2016.04.29.13.21.33;	author nicm;	state Exp;
branches;
next	1.624;
commitid	KGWNr1jgb560pkTW;

1.624
date	2016.04.27.09.39.09;	author nicm;	state Exp;
branches;
next	1.623;
commitid	0bQ3quXnMplDQUsb;

1.623
date	2016.03.18.07.28.27;	author nicm;	state Exp;
branches;
next	1.622;
commitid	XKqoAZz4Rl0wxJYw;

1.622
date	2016.03.02.15.36.02;	author nicm;	state Exp;
branches;
next	1.621;
commitid	NiBVKnSIZN4ztNWB;

1.621
date	2016.03.01.12.02.08;	author nicm;	state Exp;
branches;
next	1.620;
commitid	waz0Ov6Cd4sWsxcD;

1.620
date	2016.01.31.09.57.41;	author nicm;	state Exp;
branches;
next	1.619;
commitid	s3fnPgOt96UPeX6P;

1.619
date	2016.01.29.11.13.56;	author nicm;	state Exp;
branches;
next	1.618;
commitid	Rew2ppunRTmAT23L;

1.618
date	2016.01.19.16.01.30;	author nicm;	state Exp;
branches;
next	1.617;
commitid	gdaGX7HuLjiMTGV0;

1.617
date	2016.01.19.15.59.12;	author nicm;	state Exp;
branches;
next	1.616;
commitid	P3qmSOx6KrDBsb0c;

1.616
date	2016.01.16.00.36.53;	author nicm;	state Exp;
branches;
next	1.615;
commitid	416B5CZCT2xuRFOv;

1.615
date	2016.01.15.11.31.47;	author nicm;	state Exp;
branches;
next	1.614;
commitid	tQD3qrBCJTPkSPCm;

1.614
date	2015.12.16.22.05.35;	author nicm;	state Exp;
branches;
next	1.613;
commitid	6LxvgMFtrwxMsdPn;

1.613
date	2015.12.16.21.50.37;	author nicm;	state Exp;
branches;
next	1.612;
commitid	Bam1GajuDZzmKjyE;

1.612
date	2015.12.15.13.43.07;	author nicm;	state Exp;
branches;
next	1.611;
commitid	nxumQwtI4O73Gcjc;

1.611
date	2015.12.15.00.00.01;	author nicm;	state Exp;
branches;
next	1.610;
commitid	yMmY7FLVcToE15ZM;

1.610
date	2015.12.14.23.30.58;	author nicm;	state Exp;
branches;
next	1.609;
commitid	Gp2loryMvVho4B6E;

1.609
date	2015.12.14.00.31.54;	author nicm;	state Exp;
branches;
next	1.608;
commitid	rE682EC14v4gpeFy;

1.608
date	2015.12.13.21.53.57;	author nicm;	state Exp;
branches;
next	1.607;
commitid	gsQkQsSyBCSmU9ax;

1.607
date	2015.12.13.18.31.47;	author nicm;	state Exp;
branches;
next	1.606;
commitid	vOQHO6uiGtto54AC;

1.606
date	2015.12.13.17.55.14;	author nicm;	state Exp;
branches;
next	1.605;
commitid	Fyn4vblJtlp30z7Q;

1.605
date	2015.12.13.16.44.35;	author nicm;	state Exp;
branches;
next	1.604;
commitid	CpoKtPSIEn27BKfz;

1.604
date	2015.12.13.15.32.12;	author nicm;	state Exp;
branches;
next	1.603;
commitid	aaVCH5jHZVqoxGFq;

1.603
date	2015.12.13.14.32.38;	author nicm;	state Exp;
branches;
next	1.602;
commitid	uzMkp8Z4FE6WB6s6;

1.602
date	2015.12.12.18.32.24;	author nicm;	state Exp;
branches;
next	1.601;
commitid	q7iDAcShsJWlLYhr;

1.601
date	2015.12.12.18.19.00;	author nicm;	state Exp;
branches;
next	1.600;
commitid	WD2k8ZkBSmp0TV5S;

1.600
date	2015.12.11.16.37.21;	author nicm;	state Exp;
branches;
next	1.599;
commitid	pfV7j8HdB7hdHnZm;

1.599
date	2015.12.11.15.46.57;	author nicm;	state Exp;
branches;
next	1.598;
commitid	7gYcVEFDdWFs0Erw;

1.598
date	2015.12.11.12.27.36;	author nicm;	state Exp;
branches;
next	1.597;
commitid	ns7JfXpW9TsHrnT3;

1.597
date	2015.12.08.08.34.18;	author nicm;	state Exp;
branches;
next	1.596;
commitid	MRfGAYPLeVqV46rT;

1.596
date	2015.12.08.08.14.04;	author nicm;	state Exp;
branches;
next	1.595;
commitid	bHaj0CFZNVz1dZlv;

1.595
date	2015.12.08.01.10.31;	author nicm;	state Exp;
branches;
next	1.594;
commitid	Q7y3PTVPjE0eQDqD;

1.594
date	2015.12.07.09.47.41;	author nicm;	state Exp;
branches;
next	1.593;
commitid	DEG5t4Tpp1OvTShQ;

1.593
date	2015.11.27.15.06.43;	author nicm;	state Exp;
branches;
next	1.592;
commitid	UkIx5fVf8smc7ree;

1.592
date	2015.11.24.23.46.15;	author nicm;	state Exp;
branches;
next	1.591;
commitid	0H2a77mNskMnXKL5;

1.591
date	2015.11.24.23.22.51;	author nicm;	state Exp;
branches;
next	1.590;
commitid	GfId0ZOaXFcgaWPG;

1.590
date	2015.11.24.22.27.22;	author nicm;	state Exp;
branches;
next	1.589;
commitid	h20Fi6Gop7tu9Q4A;

1.589
date	2015.11.24.21.52.06;	author nicm;	state Exp;
branches;
next	1.588;
commitid	Wy0S0Ml5dOX2TIOy;

1.588
date	2015.11.24.21.19.46;	author nicm;	state Exp;
branches;
next	1.587;
commitid	WYqwkdfYHZzn9ayb;

1.587
date	2015.11.24.09.34.55;	author nicm;	state Exp;
branches;
next	1.586;
commitid	7H0ObHzXstG7tLHE;

1.586
date	2015.11.23.23.47.57;	author nicm;	state Exp;
branches;
next	1.585;
commitid	il6j3tv774whObqw;

1.585
date	2015.11.23.20.53.09;	author nicm;	state Exp;
branches;
next	1.584;
commitid	erDJx2JIDZWB55Vj;

1.584
date	2015.11.20.12.01.19;	author nicm;	state Exp;
branches;
next	1.583;
commitid	qNEZpcD0RcTrAsAp;

1.583
date	2015.11.19.22.46.46;	author nicm;	state Exp;
branches;
next	1.582;
commitid	mCtl6P7knl540hRA;

1.582
date	2015.11.18.14.27.44;	author nicm;	state Exp;
branches;
next	1.581;
commitid	RjsAPRkWwvS79w40;

1.581
date	2015.11.18.13.06.54;	author nicm;	state Exp;
branches;
next	1.580;
commitid	xAU2oIxJB0E2UZoZ;

1.580
date	2015.11.15.22.50.38;	author nicm;	state Exp;
branches;
next	1.579;
commitid	IsEkC94OD9OnZ3oK;

1.579
date	2015.11.14.11.45.43;	author nicm;	state Exp;
branches;
next	1.578;
commitid	gUJFVlXRAaRAnDSU;

1.578
date	2015.11.14.10.56.31;	author nicm;	state Exp;
branches;
next	1.577;
commitid	7oTEXFUYU5F7v5X1;

1.577
date	2015.11.14.09.41.07;	author nicm;	state Exp;
branches;
next	1.576;
commitid	FQoND7M2BC89FZoU;

1.576
date	2015.11.13.08.09.28;	author nicm;	state Exp;
branches;
next	1.575;
commitid	3vFd8TIqn7NVGuk0;

1.575
date	2015.11.12.12.43.36;	author nicm;	state Exp;
branches;
next	1.574;
commitid	dJNPbZGePibWAHfZ;

1.574
date	2015.11.12.12.19.57;	author nicm;	state Exp;
branches;
next	1.573;
commitid	jNkHcPRyvqShNcEt;

1.573
date	2015.11.12.11.10.50;	author nicm;	state Exp;
branches;
next	1.572;
commitid	zq4e90cLboyOw7qA;

1.572
date	2015.11.12.11.09.11;	author nicm;	state Exp;
branches;
next	1.571;
commitid	tEN3cHiOuN3KscbT;

1.571
date	2015.11.12.11.05.34;	author nicm;	state Exp;
branches;
next	1.570;
commitid	Ih1tdqtjpnEyfE8x;

1.570
date	2015.10.31.13.12.03;	author nicm;	state Exp;
branches;
next	1.569;
commitid	YMQrsd7hfJkvI0rw;

1.569
date	2015.10.31.08.13.58;	author nicm;	state Exp;
branches;
next	1.568;
commitid	B5GekkO0CdWpFMrz;

1.568
date	2015.10.28.09.51.55;	author nicm;	state Exp;
branches;
next	1.567;
commitid	eGVGKzVVYKHFvkn4;

1.567
date	2015.10.27.15.58.42;	author nicm;	state Exp;
branches;
next	1.566;
commitid	89xhQafU35Q5MQVC;

1.566
date	2015.10.27.13.23.24;	author nicm;	state Exp;
branches;
next	1.565;
commitid	g6GdEJXfBNprXHEK;

1.565
date	2015.10.25.22.29.17;	author nicm;	state Exp;
branches;
next	1.564;
commitid	lyC76bFrgfVLq7ku;

1.564
date	2015.10.23.16.02.21;	author nicm;	state Exp;
branches;
next	1.563;
commitid	dVDXU9Ok8jlPT5fI;

1.563
date	2015.10.18.20.42.42;	author nicm;	state Exp;
branches;
next	1.562;
commitid	nMwmdaY8loLzimxC;

1.562
date	2015.09.25.15.53.07;	author nicm;	state Exp;
branches;
next	1.561;
commitid	lqg6HJokMJTX5DQE;

1.561
date	2015.09.16.22.24.54;	author nicm;	state Exp;
branches;
next	1.560;
commitid	GbMuGsUSIjrHMl0R;

1.560
date	2015.09.14.11.57.22;	author nicm;	state Exp;
branches;
next	1.559;
commitid	wKlWtZcqFB2WciZ5;

1.559
date	2015.09.14.11.34.50;	author nicm;	state Exp;
branches;
next	1.558;
commitid	jBSEJQfSIiCoo49j;

1.558
date	2015.09.14.10.25.52;	author nicm;	state Exp;
branches;
next	1.557;
commitid	UTR5DL8aBfSehB3O;

1.557
date	2015.09.13.13.31.40;	author nicm;	state Exp;
branches;
next	1.556;
commitid	ToibECMiP97xJ3jN;

1.556
date	2015.09.11.14.41.50;	author nicm;	state Exp;
branches;
next	1.555;
commitid	ufD4awhmzmSoxn7X;

1.555
date	2015.09.10.08.58.14;	author nicm;	state Exp;
branches;
next	1.554;
commitid	fjYzZVETyEmTAStI;

1.554
date	2015.09.02.17.43.25;	author nicm;	state Exp;
branches;
next	1.553;
commitid	xHcEu21xENWEDDuX;

1.553
date	2015.09.02.17.37.54;	author nicm;	state Exp;
branches;
next	1.552;
commitid	DPDGYd3xfOPOySvU;

1.552
date	2015.09.01.11.13.39;	author nicm;	state Exp;
branches;
next	1.551;
commitid	tL1ivcqrZ0DN19Hl;

1.551
date	2015.09.01.10.10.59;	author nicm;	state Exp;
branches;
next	1.550;
commitid	d18I0q3dD3BLOXHE;

1.550
date	2015.09.01.10.01.56;	author nicm;	state Exp;
branches;
next	1.549;
commitid	HiJ8QXCMc25AkMAL;

1.549
date	2015.09.01.09.48.34;	author nicm;	state Exp;
branches;
next	1.548;
commitid	pJBAqtVcysxCLBnf;

1.548
date	2015.08.30.22.56.36;	author nicm;	state Exp;
branches;
next	1.547;
commitid	xUatsx2gIvYjL0KZ;

1.547
date	2015.08.30.22.40.25;	author nicm;	state Exp;
branches;
next	1.546;
commitid	O1jOOL2q5ONABWr1;

1.546
date	2015.08.30.22.19.07;	author nicm;	state Exp;
branches;
next	1.545;
commitid	nMCE84XHv5ujel0H;

1.545
date	2015.08.29.23.55.55;	author nicm;	state Exp;
branches;
next	1.544;
commitid	30I1jbL0UB55CZIu;

1.544
date	2015.08.29.23.19.52;	author nicm;	state Exp;
branches;
next	1.543;
commitid	lH5qyru4sbPQeeeg;

1.543
date	2015.08.29.09.36.46;	author nicm;	state Exp;
branches;
next	1.542;
commitid	iO5QEcohpHfgM5Iz;

1.542
date	2015.08.29.09.25.00;	author nicm;	state Exp;
branches;
next	1.541;
commitid	UXoQGD7QOZAJI1XC;

1.541
date	2015.08.29.08.30.54;	author nicm;	state Exp;
branches;
next	1.540;
commitid	RrlCW4OYH7he0yBf;

1.540
date	2015.08.29.00.29.15;	author nicm;	state Exp;
branches;
next	1.539;
commitid	jhCDxn7bTHMNE4FM;

1.539
date	2015.08.28.16.10.46;	author nicm;	state Exp;
branches;
next	1.538;
commitid	5Oy3Fyd66jXdISPs;

1.538
date	2015.08.28.15.51.48;	author nicm;	state Exp;
branches;
next	1.537;
commitid	blWK8QcMFPW3AUtZ;

1.537
date	2015.08.28.13.12.20;	author nicm;	state Exp;
branches;
next	1.536;
commitid	7dHMdjgnodjQvy6O;

1.536
date	2015.08.28.13.01.03;	author nicm;	state Exp;
branches;
next	1.535;
commitid	fIVZtZS9F66XgvbR;

1.535
date	2015.08.28.12.25.42;	author nicm;	state Exp;
branches;
next	1.534;
commitid	6bG4Sc33YFhgSCnx;

1.534
date	2015.08.28.12.16.28;	author nicm;	state Exp;
branches;
next	1.533;
commitid	LqkiQ6rY2EYTPxv3;

1.533
date	2015.08.28.11.38.27;	author nicm;	state Exp;
branches;
next	1.532;
commitid	Tft8aiYUxsfXokWg;

1.532
date	2015.08.28.07.49.24;	author nicm;	state Exp;
branches;
next	1.531;
commitid	0EjAW6v3xnwJqHbL;

1.531
date	2015.07.29.11.56.02;	author nicm;	state Exp;
branches;
next	1.530;
commitid	47sVTxMc5nNTsinQ;

1.530
date	2015.07.28.15.18.10;	author nicm;	state Exp;
branches;
next	1.529;
commitid	TNUQ68WbdVxASnmd;

1.529
date	2015.07.20.15.50.04;	author nicm;	state Exp;
branches;
next	1.528;
commitid	XjcnBmI1AcHx5t2a;

1.528
date	2015.07.13.15.51.31;	author nicm;	state Exp;
branches;
next	1.527;
commitid	FFYcWp5eb58J4GT4;

1.527
date	2015.07.13.15.49.31;	author nicm;	state Exp;
branches;
next	1.526;
commitid	ECzzymgpZWtUKc3b;

1.526
date	2015.06.17.16.50.28;	author nicm;	state Exp;
branches;
next	1.525;
commitid	zbvekK98PFlsEYIW;

1.525
date	2015.06.17.16.44.49;	author nicm;	state Exp;
branches;
next	1.524;
commitid	uyHvvQkXqCKEuAjn;

1.524
date	2015.06.15.10.58.01;	author nicm;	state Exp;
branches;
next	1.523;
commitid	HBSnpNJTrYXYaYTN;

1.523
date	2015.06.14.10.07.44;	author nicm;	state Exp;
branches;
next	1.522;
commitid	0pZ95JQFEhIowUtr;

1.522
date	2015.06.07.21.39.39;	author nicm;	state Exp;
branches;
next	1.521;
commitid	N9n0sMf4KapNFAh6;

1.521
date	2015.06.05.22.33.39;	author nicm;	state Exp;
branches;
next	1.520;
commitid	bhwpTfoxc2Bk5WKg;

1.520
date	2015.06.05.18.18.32;	author nicm;	state Exp;
branches;
next	1.519;
commitid	ZQGnMCbBqbBRSCmt;

1.519
date	2015.06.05.18.06.30;	author nicm;	state Exp;
branches;
next	1.518;
commitid	31HWw6xUnTEvtfY4;

1.518
date	2015.06.05.18.01.12;	author nicm;	state Exp;
branches;
next	1.517;
commitid	38CNdOauYnpJlZqC;

1.517
date	2015.06.04.23.27.51;	author nicm;	state Exp;
branches;
next	1.516;
commitid	xevJfLLQ14ORIsEv;

1.516
date	2015.06.04.11.43.51;	author nicm;	state Exp;
branches;
next	1.515;
commitid	rAvOUA4CI6VK3gQ6;

1.515
date	2015.05.27.13.28.04;	author nicm;	state Exp;
branches;
next	1.514;
commitid	jNiCCHdN1zYsiWiL;

1.514
date	2015.05.12.22.40.38;	author nicm;	state Exp;
branches;
next	1.513;
commitid	sxqWZ5H5R3E3KABV;

1.513
date	2015.05.12.15.27.46;	author nicm;	state Exp;
branches;
next	1.512;
commitid	p5bGRCMzjTiUkjhK;

1.512
date	2015.05.11.10.10.16;	author nicm;	state Exp;
branches;
next	1.511;
commitid	yarRVqbIkdPvB3jr;

1.511
date	2015.05.08.16.48.12;	author nicm;	state Exp;
branches;
next	1.510;
commitid	78FmjS8FabTyXQb5;

1.510
date	2015.05.08.16.44.03;	author nicm;	state Exp;
branches;
next	1.509;
commitid	URneboKlXytNYgiE;

1.509
date	2015.05.08.16.33.29;	author nicm;	state Exp;
branches;
next	1.508;
commitid	n1lmYmWcWtKCVPGf;

1.508
date	2015.05.08.16.23.34;	author nicm;	state Exp;
branches;
next	1.507;
commitid	liqxkhz3VaAx6PRF;

1.507
date	2015.05.08.16.18.04;	author nicm;	state Exp;
branches;
next	1.506;
commitid	jGuK9ADiqvyOz7AE;

1.506
date	2015.05.07.08.08.54;	author nicm;	state Exp;
branches;
next	1.505;
commitid	w1QdYIaJj92r1JR4;

1.505
date	2015.05.06.23.56.46;	author nicm;	state Exp;
branches;
next	1.504;
commitid	ABy4BhUuTJpRxEfH;

1.504
date	2015.05.06.08.35.39;	author nicm;	state Exp;
branches;
next	1.503;
commitid	7XqxdN1FHegvjfQk;

1.503
date	2015.04.28.10.43.14;	author nicm;	state Exp;
branches;
next	1.502;
commitid	S1rOdgmrftCOUlG6;

1.502
date	2015.04.27.16.25.57;	author nicm;	state Exp;
branches;
next	1.501;
commitid	0WBWxxZyxaAFVhmn;

1.501
date	2015.04.25.18.33.59;	author nicm;	state Exp;
branches;
next	1.500;
commitid	R776bB84r7VPzyws;

1.500
date	2015.04.25.18.09.28;	author nicm;	state Exp;
branches;
next	1.499;
commitid	B7W3z8l90mUfy5Jt;

1.499
date	2015.04.24.23.17.11;	author nicm;	state Exp;
branches;
next	1.498;
commitid	iy4fcaIoXzxOx84I;

1.498
date	2015.04.24.22.19.36;	author nicm;	state Exp;
branches;
next	1.497;
commitid	h1lxJjTgcLGsGtE8;

1.497
date	2015.04.22.15.32.33;	author nicm;	state Exp;
branches;
next	1.496;
commitid	g5PKK6dkIwS2RVh8;

1.496
date	2015.04.22.15.30.11;	author nicm;	state Exp;
branches;
next	1.495;
commitid	0bmlELm9krdoS6OB;

1.495
date	2015.04.22.15.05.03;	author nicm;	state Exp;
branches;
next	1.494;
commitid	NOv4t3Ada2mtdBzi;

1.494
date	2015.04.21.22.38.49;	author nicm;	state Exp;
branches;
next	1.493;
commitid	MULQMBCHDfIGQ0ED;

1.493
date	2015.04.20.15.34.56;	author nicm;	state Exp;
branches;
next	1.492;
commitid	1fc4pMkRD7YjyQWP;

1.492
date	2015.04.19.21.34.21;	author nicm;	state Exp;
branches;
next	1.491;
commitid	wug6ctIOfhVMeWQp;

1.491
date	2015.04.19.21.05.27;	author nicm;	state Exp;
branches;
next	1.490;
commitid	ksfuI8mTVk7XPyr3;

1.490
date	2015.02.06.17.21.08;	author nicm;	state Exp;
branches;
next	1.489;
commitid	ycB52gvvJRKxbdB6;

1.489
date	2015.02.06.17.11.39;	author nicm;	state Exp;
branches;
next	1.488;
commitid	524Kssnx5Ady6qyZ;

1.488
date	2015.02.05.10.29.43;	author nicm;	state Exp;
branches;
next	1.487;
commitid	b1G1TVWY7l4KyoY6;

1.487
date	2015.02.05.10.26.29;	author nicm;	state Exp;
branches;
next	1.486;
commitid	OxivUTNX4WyBbEer;

1.486
date	2015.02.01.23.43.23;	author nicm;	state Exp;
branches;
next	1.485;
commitid	dy3XCJyolFNoNYim;

1.485
date	2015.01.20.08.18.04;	author nicm;	state Exp;
branches;
next	1.484;
commitid	rWJzz3mLtR2DyuLJ;

1.484
date	2014.12.09.19.23.35;	author nicm;	state Exp;
branches;
next	1.483;
commitid	F9Ad8BPsskeeEtGX;

1.483
date	2014.12.02.23.19.45;	author nicm;	state Exp;
branches;
next	1.482;
commitid	gPfaYZLsz4KUq58B;

1.482
date	2014.11.30.08.03.29;	author nicm;	state Exp;
branches;
next	1.481;
commitid	0xxsJuH6TmmoEwPt;

1.481
date	2014.11.14.02.19.47;	author nicm;	state Exp;
branches;
next	1.480;
commitid	ky6cosN1lXi9yNl0;

1.480
date	2014.11.06.09.17.26;	author nicm;	state Exp;
branches;
next	1.479;
commitid	CCUZqfCax9h5WQau;

1.479
date	2014.10.27.22.23.47;	author nicm;	state Exp;
branches;
next	1.478;
commitid	lLfuAlkV0hLlHdgD;

1.478
date	2014.10.22.23.11.41;	author nicm;	state Exp;
branches;
next	1.477;
commitid	rjYMtvWWeOUV78xG;

1.477
date	2014.10.21.22.22.04;	author nicm;	state Exp;
branches;
next	1.476;
commitid	65v69dyr6BLoa8kb;

1.476
date	2014.10.20.23.57.14;	author nicm;	state Exp;
branches;
next	1.475;
commitid	PTykIJGtZncJPE4a;

1.475
date	2014.10.20.23.35.28;	author nicm;	state Exp;
branches;
next	1.474;
commitid	RV1NOSXD1mUR8LDP;

1.474
date	2014.10.20.23.27.14;	author nicm;	state Exp;
branches;
next	1.473;
commitid	BAMrPS0saBiCc8HD;

1.473
date	2014.10.20.22.29.25;	author nicm;	state Exp;
branches;
next	1.472;
commitid	Gq8hgMoG3t1Wy1Zv;

1.472
date	2014.10.08.17.35.58;	author nicm;	state Exp;
branches;
next	1.471;
commitid	mK8z9uVwDZMfiNoM;

1.471
date	2014.09.01.21.58.41;	author nicm;	state Exp;
branches;
next	1.470;
commitid	PB2QtqgfNXhDsTfg;

1.470
date	2014.09.01.21.50.18;	author nicm;	state Exp;
branches;
next	1.469;
commitid	yvK8NJvd2XzXhKku;

1.469
date	2014.08.11.22.18.16;	author nicm;	state Exp;
branches;
next	1.468;
commitid	aoiUaOZcuwvS7PHQ;

1.468
date	2014.08.11.22.14.30;	author nicm;	state Exp;
branches;
next	1.467;
commitid	whaUj6ycByfMr14q;

1.467
date	2014.08.09.07.33.37;	author nicm;	state Exp;
branches;
next	1.466;
commitid	EaH1ezsTMWHeIyGh;

1.466
date	2014.07.21.10.25.48;	author nicm;	state Exp;
branches;
next	1.465;
commitid	uQXf8Vu4TQgRm6UX;

1.465
date	2014.06.06.13.21.41;	author nicm;	state Exp;
branches;
next	1.464;
commitid	n10vUmd4HT5z6ANF;

1.464
date	2014.05.14.06.21.19;	author nicm;	state Exp;
branches;
next	1.463;

1.463
date	2014.05.13.08.08.32;	author nicm;	state Exp;
branches;
next	1.462;

1.462
date	2014.05.13.07.54.20;	author nicm;	state Exp;
branches;
next	1.461;

1.461
date	2014.05.13.07.34.35;	author nicm;	state Exp;
branches;
next	1.460;

1.460
date	2014.05.09.09.11.24;	author nicm;	state Exp;
branches;
next	1.459;

1.459
date	2014.05.08.07.54.47;	author nicm;	state Exp;
branches;
next	1.458;

1.458
date	2014.05.08.06.03.30;	author nicm;	state Exp;
branches;
next	1.457;

1.457
date	2014.04.24.09.14.43;	author nicm;	state Exp;
branches;
next	1.456;

1.456
date	2014.04.17.15.37.55;	author nicm;	state Exp;
branches;
next	1.455;

1.455
date	2014.04.17.13.02.59;	author nicm;	state Exp;
branches;
next	1.454;

1.454
date	2014.04.17.12.43.38;	author nicm;	state Exp;
branches;
next	1.453;

1.453
date	2014.04.17.09.13.13;	author nicm;	state Exp;
branches;
next	1.452;

1.452
date	2014.04.17.07.55.43;	author nicm;	state Exp;
branches;
next	1.451;

1.451
date	2014.04.17.07.36.45;	author nicm;	state Exp;
branches;
next	1.450;

1.450
date	2014.04.16.21.16.19;	author nicm;	state Exp;
branches;
next	1.449;

1.449
date	2014.04.16.21.02.41;	author nicm;	state Exp;
branches;
next	1.448;

1.448
date	2014.04.03.08.20.29;	author nicm;	state Exp;
branches;
next	1.447;

1.447
date	2014.04.02.18.12.18;	author nicm;	state Exp;
branches;
next	1.446;

1.446
date	2014.04.01.05.50.30;	author deraadt;	state Exp;
branches;
next	1.445;

1.445
date	2014.03.31.21.42.27;	author nicm;	state Exp;
branches;
next	1.444;

1.444
date	2014.03.31.21.42.05;	author nicm;	state Exp;
branches;
next	1.443;

1.443
date	2014.03.31.21.40.21;	author nicm;	state Exp;
branches;
next	1.442;

1.442
date	2014.03.31.21.39.59;	author nicm;	state Exp;
branches;
next	1.441;

1.441
date	2014.03.31.21.39.31;	author nicm;	state Exp;
branches;
next	1.440;

1.440
date	2014.03.31.21.37.55;	author nicm;	state Exp;
branches;
next	1.439;

1.439
date	2014.03.31.21.36.43;	author nicm;	state Exp;
branches;
next	1.438;

1.438
date	2014.03.31.21.34.08;	author nicm;	state Exp;
branches;
next	1.437;

1.437
date	2014.02.23.00.53.06;	author nicm;	state Exp;
branches;
next	1.436;

1.436
date	2014.01.31.14.19.24;	author nicm;	state Exp;
branches;
next	1.435;

1.435
date	2014.01.28.23.07.09;	author nicm;	state Exp;
branches;
next	1.434;

1.434
date	2014.01.28.22.19.17;	author nicm;	state Exp;
branches;
next	1.433;

1.433
date	2014.01.09.14.20.55;	author nicm;	state Exp;
branches;
next	1.432;

1.432
date	2013.10.23.11.31.03;	author nicm;	state Exp;
branches;
next	1.431;

1.431
date	2013.10.20.17.28.43;	author nicm;	state Exp;
branches;
next	1.430;

1.430
date	2013.10.10.12.39.25;	author nicm;	state Exp;
branches;
next	1.429;

1.429
date	2013.10.10.12.29.35;	author nicm;	state Exp;
branches;
next	1.428;

1.428
date	2013.10.10.12.26.36;	author nicm;	state Exp;
branches;
next	1.427;

1.427
date	2013.10.10.12.13.56;	author nicm;	state Exp;
branches;
next	1.426;

1.426
date	2013.10.10.12.13.29;	author nicm;	state Exp;
branches;
next	1.425;

1.425
date	2013.10.10.12.12.54;	author nicm;	state Exp;
branches;
next	1.424;

1.424
date	2013.10.10.12.12.08;	author nicm;	state Exp;
branches;
next	1.423;

1.423
date	2013.10.10.12.11.45;	author nicm;	state Exp;
branches;
next	1.422;

1.422
date	2013.10.10.12.09.34;	author nicm;	state Exp;
branches;
next	1.421;

1.421
date	2013.10.10.12.07.37;	author nicm;	state Exp;
branches;
next	1.420;

1.420
date	2013.10.10.12.02.24;	author nicm;	state Exp;
branches;
next	1.419;

1.419
date	2013.10.10.12.00.24;	author nicm;	state Exp;
branches;
next	1.418;

1.418
date	2013.10.10.11.59.23;	author nicm;	state Exp;
branches;
next	1.417;

1.417
date	2013.10.10.11.56.50;	author nicm;	state Exp;
branches;
next	1.416;

1.416
date	2013.10.10.11.45.29;	author nicm;	state Exp;
branches;
next	1.415;

1.415
date	2013.07.05.14.38.23;	author nicm;	state Exp;
branches;
next	1.414;

1.414
date	2013.06.23.13.10.48;	author nicm;	state Exp;
branches;
next	1.413;

1.413
date	2013.06.23.12.51.29;	author nicm;	state Exp;
branches;
next	1.412;

1.412
date	2013.06.23.12.41.55;	author nicm;	state Exp;
branches;
next	1.411;

1.411
date	2013.06.02.07.52.15;	author nicm;	state Exp;
branches;
next	1.410;

1.410
date	2013.05.31.12.19.34;	author nicm;	state Exp;
branches;
next	1.409;

1.409
date	2013.04.24.10.01.32;	author nicm;	state Exp;
branches;
next	1.408;

1.408
date	2013.04.22.22.17.29;	author nicm;	state Exp;
branches;
next	1.407;

1.407
date	2013.03.27.11.17.12;	author nicm;	state Exp;
branches;
next	1.406;

1.406
date	2013.03.25.11.44.00;	author nicm;	state Exp;
branches;
next	1.405;

1.405
date	2013.03.25.11.43.01;	author nicm;	state Exp;
branches;
next	1.404;

1.404
date	2013.03.25.11.41.16;	author nicm;	state Exp;
branches;
next	1.403;

1.403
date	2013.03.25.11.35.55;	author nicm;	state Exp;
branches;
next	1.402;

1.402
date	2013.03.25.10.11.45;	author nicm;	state Exp;
branches;
next	1.401;

1.401
date	2013.03.25.10.09.07;	author nicm;	state Exp;
branches;
next	1.400;

1.400
date	2013.03.25.10.05.35;	author nicm;	state Exp;
branches;
next	1.399;

1.399
date	2013.03.24.09.58.40;	author nicm;	state Exp;
branches;
next	1.398;

1.398
date	2013.03.24.09.57.59;	author nicm;	state Exp;
branches;
next	1.397;

1.397
date	2013.03.24.09.54.10;	author nicm;	state Exp;
branches;
next	1.396;

1.396
date	2013.03.24.09.28.59;	author nicm;	state Exp;
branches;
next	1.395;

1.395
date	2013.03.24.09.27.20;	author nicm;	state Exp;
branches;
next	1.394;

1.394
date	2013.03.24.09.25.04;	author nicm;	state Exp;
branches;
next	1.393;

1.393
date	2013.03.24.09.18.16;	author nicm;	state Exp;
branches;
next	1.392;

1.392
date	2013.03.22.16.00.26;	author nicm;	state Exp;
branches;
next	1.391;

1.391
date	2013.03.22.15.56.11;	author nicm;	state Exp;
branches;
next	1.390;

1.390
date	2013.03.22.15.54.29;	author nicm;	state Exp;
branches;
next	1.389;

1.389
date	2013.03.22.15.52.41;	author nicm;	state Exp;
branches;
next	1.388;

1.388
date	2013.03.22.15.51.54;	author nicm;	state Exp;
branches;
next	1.387;

1.387
date	2013.03.22.15.49.55;	author nicm;	state Exp;
branches;
next	1.386;

1.386
date	2013.03.22.10.38.13;	author nicm;	state Exp;
branches;
next	1.385;

1.385
date	2013.03.22.10.37.39;	author nicm;	state Exp;
branches;
next	1.384;

1.384
date	2013.03.22.10.33.50;	author nicm;	state Exp;
branches;
next	1.383;

1.383
date	2013.03.21.18.47.56;	author nicm;	state Exp;
branches;
next	1.382;

1.382
date	2013.03.21.18.44.47;	author nicm;	state Exp;
branches;
next	1.381;

1.381
date	2013.03.21.16.50.22;	author nicm;	state Exp;
branches;
next	1.380;

1.380
date	2013.03.21.16.19.25;	author nicm;	state Exp;
branches;
next	1.379;

1.379
date	2013.03.21.16.15.52;	author nicm;	state Exp;
branches;
next	1.378;

1.378
date	2013.03.21.16.12.10;	author nicm;	state Exp;
branches;
next	1.377;

1.377
date	2013.03.21.16.09.59;	author nicm;	state Exp;
branches;
next	1.376;

1.376
date	2013.03.21.16.09.17;	author nicm;	state Exp;
branches;
next	1.375;

1.375
date	2013.03.21.16.08.24;	author nicm;	state Exp;
branches;
next	1.374;

1.374
date	2013.02.05.11.08.59;	author nicm;	state Exp;
branches;
next	1.373;

1.373
date	2013.01.18.02.16.21;	author nicm;	state Exp;
branches;
next	1.372;

1.372
date	2013.01.17.00.11.22;	author nicm;	state Exp;
branches;
next	1.371;

1.371
date	2013.01.15.23.18.55;	author nicm;	state Exp;
branches;
next	1.370;

1.370
date	2013.01.15.22.55.29;	author nicm;	state Exp;
branches;
next	1.369;

1.369
date	2012.12.24.12.33.05;	author nicm;	state Exp;
branches;
next	1.368;

1.368
date	2012.11.27.22.59.34;	author nicm;	state Exp;
branches;
next	1.367;

1.367
date	2012.11.27.20.22.12;	author nicm;	state Exp;
branches;
next	1.366;

1.366
date	2012.11.27.20.08.42;	author nicm;	state Exp;
branches;
next	1.365;

1.365
date	2012.11.27.16.12.29;	author nicm;	state Exp;
branches;
next	1.364;

1.364
date	2012.11.22.14.41.11;	author nicm;	state Exp;
branches;
next	1.363;

1.363
date	2012.11.22.14.26.04;	author nicm;	state Exp;
branches;
next	1.362;

1.362
date	2012.11.19.10.38.06;	author nicm;	state Exp;
branches;
next	1.361;

1.361
date	2012.11.05.13.13.04;	author nicm;	state Exp;
branches;
next	1.360;

1.360
date	2012.10.26.14.35.42;	author nicm;	state Exp;
branches;
next	1.359;

1.359
date	2012.10.02.08.16.28;	author nicm;	state Exp;
branches;
next	1.358;

1.358
date	2012.09.25.07.41.22;	author nicm;	state Exp;
branches;
next	1.357;

1.357
date	2012.09.24.13.39.10;	author nicm;	state Exp;
branches;
next	1.356;

1.356
date	2012.09.24.13.05.10;	author nicm;	state Exp;
branches;
next	1.355;

1.355
date	2012.09.03.12.20.17;	author nicm;	state Exp;
branches;
next	1.354;

1.354
date	2012.09.03.09.57.57;	author nicm;	state Exp;
branches;
next	1.353;

1.353
date	2012.09.03.09.32.38;	author nicm;	state Exp;
branches;
next	1.352;

1.352
date	2012.08.21.10.00.33;	author nicm;	state Exp;
branches;
next	1.351;

1.351
date	2012.08.14.08.51.53;	author nicm;	state Exp;
branches;
next	1.350;

1.350
date	2012.08.11.06.45.33;	author nicm;	state Exp;
branches;
next	1.349;

1.349
date	2012.07.13.06.27.41;	author nicm;	state Exp;
branches;
next	1.348;

1.348
date	2012.07.11.07.10.15;	author nicm;	state Exp;
branches;
next	1.347;

1.347
date	2012.07.10.11.53.01;	author nicm;	state Exp;
branches;
next	1.346;

1.346
date	2012.07.08.16.04.38;	author nicm;	state Exp;
branches;
next	1.345;

1.345
date	2012.07.08.07.27.32;	author nicm;	state Exp;
branches;
next	1.344;

1.344
date	2012.06.25.14.27.25;	author nicm;	state Exp;
branches;
next	1.343;

1.343
date	2012.06.25.14.08.55;	author nicm;	state Exp;
branches;
next	1.342;

1.342
date	2012.06.18.13.16.42;	author nicm;	state Exp;
branches;
next	1.341;

1.341
date	2012.05.28.07.59.07;	author nicm;	state Exp;
branches;
next	1.340;

1.340
date	2012.05.27.21.43.57;	author nicm;	state Exp;
branches;
next	1.339;

1.339
date	2012.05.25.08.28.10;	author nicm;	state Exp;
branches;
next	1.338;

1.338
date	2012.05.23.19.19.40;	author nicm;	state Exp;
branches;
next	1.337;

1.337
date	2012.05.22.14.32.28;	author nicm;	state Exp;
branches;
next	1.336;

1.336
date	2012.05.22.14.11.30;	author nicm;	state Exp;
branches;
next	1.335;

1.335
date	2012.05.22.11.35.37;	author nicm;	state Exp;
branches;
next	1.334;

1.334
date	2012.05.22.10.56.48;	author nicm;	state Exp;
branches;
next	1.333;

1.333
date	2012.05.22.09.36.12;	author nicm;	state Exp;
branches;
next	1.332;

1.332
date	2012.05.21.18.27.42;	author nicm;	state Exp;
branches;
next	1.331;

1.331
date	2012.05.06.07.38.17;	author nicm;	state Exp;
branches;
next	1.330;

1.330
date	2012.04.29.17.20.01;	author nicm;	state Exp;
branches;
next	1.329;

1.329
date	2012.04.25.21.12.49;	author nicm;	state Exp;
branches;
next	1.328;

1.328
date	2012.04.11.06.16.14;	author nicm;	state Exp;
branches;
next	1.327;

1.327
date	2012.04.01.21.45.48;	author nicm;	state Exp;
branches;
next	1.326;

1.326
date	2012.04.01.13.18.38;	author nicm;	state Exp;
branches;
next	1.325;

1.325
date	2012.03.20.11.01.00;	author nicm;	state Exp;
branches;
next	1.324;

1.324
date	2012.03.17.22.56.04;	author nicm;	state Exp;
branches;
next	1.323;

1.323
date	2012.03.17.22.35.09;	author nicm;	state Exp;
branches;
next	1.322;

1.322
date	2012.03.17.21.27.51;	author nicm;	state Exp;
branches;
next	1.321;

1.321
date	2012.03.15.10.36.00;	author nicm;	state Exp;
branches;
next	1.320;

1.320
date	2012.03.09.21.42.13;	author nicm;	state Exp;
branches;
next	1.319;

1.319
date	2012.03.09.09.57.40;	author nicm;	state Exp;
branches;
next	1.318;

1.318
date	2012.03.04.07.38.11;	author nicm;	state Exp;
branches;
next	1.317;

1.317
date	2012.03.03.09.43.23;	author nicm;	state Exp;
branches;
next	1.316;

1.316
date	2012.03.03.08.55.56;	author nicm;	state Exp;
branches;
next	1.315;

1.315
date	2012.03.03.08.31.18;	author nicm;	state Exp;
branches;
next	1.314;

1.314
date	2012.03.02.11.16.44;	author nicm;	state Exp;
branches;
next	1.313;

1.313
date	2012.02.25.12.57.42;	author nicm;	state Exp;
branches;
next	1.312;

1.312
date	2012.02.15.17.25.02;	author nicm;	state Exp;
branches;
next	1.311;

1.311
date	2012.02.02.00.10.12;	author nicm;	state Exp;
branches;
next	1.310;

1.310
date	2012.01.31.15.52.21;	author nicm;	state Exp;
branches;
next	1.309;

1.309
date	2012.01.30.09.39.34;	author nicm;	state Exp;
branches;
next	1.308;

1.308
date	2012.01.29.09.37.02;	author nicm;	state Exp;
branches;
next	1.307;

1.307
date	2012.01.21.23.51.34;	author nicm;	state Exp;
branches;
next	1.306;

1.306
date	2012.01.21.11.12.13;	author nicm;	state Exp;
branches;
next	1.305;

1.305
date	2012.01.21.08.40.09;	author nicm;	state Exp;
branches;
next	1.304;

1.304
date	2012.01.21.08.10.21;	author nicm;	state Exp;
branches;
next	1.303;

1.303
date	2012.01.20.19.54.07;	author nicm;	state Exp;
branches;
next	1.302;

1.302
date	2012.01.20.19.10.29;	author nicm;	state Exp;
branches;
next	1.301;

1.301
date	2011.12.09.16.28.18;	author nicm;	state Exp;
branches;
next	1.300;

1.300
date	2011.12.04.16.18.01;	author nicm;	state Exp;
branches;
next	1.299;

1.299
date	2011.11.15.23.34.12;	author nicm;	state Exp;
branches;
next	1.298;

1.298
date	2011.11.15.23.19.51;	author nicm;	state Exp;
branches;
next	1.297;

1.297
date	2011.10.23.10.16.14;	author nicm;	state Exp;
branches;
next	1.296;

1.296
date	2011.10.23.08.34.01;	author nicm;	state Exp;
branches;
next	1.295;

1.295
date	2011.10.23.01.12.46;	author nicm;	state Exp;
branches;
next	1.294;

1.294
date	2011.08.26.10.53.16;	author nicm;	state Exp;
branches;
next	1.293;

1.293
date	2011.08.24.09.58.44;	author nicm;	state Exp;
branches;
next	1.292;

1.292
date	2011.07.02.21.05.44;	author nicm;	state Exp;
branches;
next	1.291;

1.291
date	2011.06.27.00.04.49;	author nicm;	state Exp;
branches;
next	1.290;

1.290
date	2011.06.05.11.19.03;	author nicm;	state Exp;
branches;
next	1.289;

1.289
date	2011.06.05.10.53.05;	author nicm;	state Exp;
branches;
next	1.288;

1.288
date	2011.05.20.19.17.39;	author nicm;	state Exp;
branches;
next	1.287;

1.287
date	2011.05.20.19.03.58;	author nicm;	state Exp;
branches;
next	1.286;

1.286
date	2011.05.18.20.24.29;	author nicm;	state Exp;
branches;
next	1.285;

1.285
date	2011.05.18.18.06.36;	author nicm;	state Exp;
branches;
next	1.284;

1.284
date	2011.05.08.20.34.12;	author nicm;	state Exp;
branches;
next	1.283;

1.283
date	2011.05.08.19.53.07;	author nicm;	state Exp;
branches;
next	1.282;

1.282
date	2011.04.19.21.31.33;	author nicm;	state Exp;
branches;
next	1.281;

1.281
date	2011.04.18.19.49.05;	author nicm;	state Exp;
branches;
next	1.280;

1.280
date	2011.04.09.07.48.08;	author nicm;	state Exp;
branches;
next	1.279;

1.279
date	2011.04.06.21.51.31;	author nicm;	state Exp;
branches;
next	1.278;

1.278
date	2011.04.05.19.37.01;	author nicm;	state Exp;
branches;
next	1.277;

1.277
date	2011.03.29.19.30.16;	author nicm;	state Exp;
branches;
next	1.276;

1.276
date	2011.03.28.19.44.31;	author nicm;	state Exp;
branches;
next	1.275;

1.275
date	2011.03.27.20.31.25;	author nicm;	state Exp;
branches;
next	1.274;

1.274
date	2011.03.27.20.27.27;	author nicm;	state Exp;
branches;
next	1.273;

1.273
date	2011.03.07.23.46.27;	author nicm;	state Exp;
branches;
next	1.272;

1.272
date	2011.03.03.08.51.47;	author nicm;	state Exp;
branches;
next	1.271;

1.271
date	2011.01.26.01.54.56;	author nicm;	state Exp;
branches;
next	1.270;

1.270
date	2011.01.26.00.11.47;	author nicm;	state Exp;
branches;
next	1.269;

1.269
date	2011.01.25.23.40.26;	author nicm;	state Exp;
branches;
next	1.268;

1.268
date	2011.01.25.22.31.50;	author nicm;	state Exp;
branches;
next	1.267;

1.267
date	2011.01.23.11.03.43;	author nicm;	state Exp;
branches;
next	1.266;

1.266
date	2011.01.15.00.16.00;	author nicm;	state Exp;
branches;
next	1.265;

1.265
date	2011.01.08.01.52.37;	author nicm;	state Exp;
branches;
next	1.264;

1.264
date	2011.01.04.00.42.47;	author nicm;	state Exp;
branches;
next	1.263;

1.263
date	2011.01.03.23.35.21;	author nicm;	state Exp;
branches;
next	1.262;

1.262
date	2011.01.01.16.51.21;	author nicm;	state Exp;
branches;
next	1.261;

1.261
date	2011.01.01.03.39.21;	author nicm;	state Exp;
branches;
next	1.260;

1.260
date	2011.01.01.03.32.28;	author nicm;	state Exp;
branches;
next	1.259;

1.259
date	2011.01.01.01.12.09;	author nicm;	state Exp;
branches;
next	1.258;

1.258
date	2010.12.30.23.20.13;	author nicm;	state Exp;
branches;
next	1.257;

1.257
date	2010.12.30.23.16.18;	author nicm;	state Exp;
branches;
next	1.256;

1.256
date	2010.12.30.21.35.17;	author nicm;	state Exp;
branches;
next	1.255;

1.255
date	2010.12.29.21.49.06;	author nicm;	state Exp;
branches;
next	1.254;

1.254
date	2010.12.21.22.37.59;	author nicm;	state Exp;
branches;
next	1.253;

1.253
date	2010.12.20.00.19.20;	author nicm;	state Exp;
branches;
next	1.252;

1.252
date	2010.12.20.00.17.22;	author nicm;	state Exp;
branches;
next	1.251;

1.251
date	2010.12.20.00.03.55;	author nicm;	state Exp;
branches;
next	1.250;

1.250
date	2010.12.11.18.39.25;	author nicm;	state Exp;
branches;
next	1.249;

1.249
date	2010.12.11.16.05.57;	author nicm;	state Exp;
branches;
next	1.248;

1.248
date	2010.12.06.22.51.02;	author nicm;	state Exp;
branches;
next	1.247;

1.247
date	2010.11.22.21.13.13;	author nicm;	state Exp;
branches;
next	1.246;

1.246
date	2010.11.11.20.51.30;	author nicm;	state Exp;
branches;
next	1.245;

1.245
date	2010.10.29.20.11.57;	author nicm;	state Exp;
branches;
next	1.244;

1.244
date	2010.10.23.13.04.34;	author nicm;	state Exp;
branches;
next	1.243;

1.243
date	2010.10.18.20.00.03;	author nicm;	state Exp;
branches;
next	1.242;

1.242
date	2010.09.28.07.15.45;	author nicm;	state Exp;
branches;
next	1.241;

1.241
date	2010.09.26.20.43.30;	author nicm;	state Exp;
branches;
next	1.240;

1.240
date	2010.09.11.16.19.22;	author nicm;	state Exp;
branches;
next	1.239;

1.239
date	2010.09.08.22.02.28;	author nicm;	state Exp;
branches;
next	1.238;

1.238
date	2010.08.19.18.29.01;	author nicm;	state Exp;
branches;
next	1.237;

1.237
date	2010.08.11.07.34.43;	author nicm;	state Exp;
branches;
next	1.236;

1.236
date	2010.07.24.20.11.59;	author nicm;	state Exp;
branches;
next	1.235;

1.235
date	2010.07.14.18.37.49;	author nicm;	state Exp;
branches;
next	1.234;

1.234
date	2010.07.11.17.06.45;	author nicm;	state Exp;
branches;
next	1.233;

1.233
date	2010.06.29.05.24.49;	author tedu;	state Exp;
branches;
next	1.232;

1.232
date	2010.06.29.03.30.14;	author nicm;	state Exp;
branches;
next	1.231;

1.231
date	2010.06.28.22.10.42;	author nicm;	state Exp;
branches;
next	1.230;

1.230
date	2010.06.27.02.56.59;	author nicm;	state Exp;
branches;
next	1.229;

1.229
date	2010.06.26.18.20.53;	author nicm;	state Exp;
branches;
next	1.228;

1.228
date	2010.06.21.21.44.09;	author nicm;	state Exp;
branches;
next	1.227;

1.227
date	2010.06.21.01.46.36;	author nicm;	state Exp;
branches;
next	1.226;

1.226
date	2010.06.21.01.27.46;	author nicm;	state Exp;
branches;
next	1.225;

1.225
date	2010.06.06.19.00.13;	author nicm;	state Exp;
branches;
next	1.224;

1.224
date	2010.06.05.16.47.11;	author nicm;	state Exp;
branches;
next	1.223;

1.223
date	2010.05.31.19.51.29;	author nicm;	state Exp;
branches;
next	1.222;

1.222
date	2010.05.26.16.44.32;	author nicm;	state Exp;
branches;
next	1.221;

1.221
date	2010.05.23.19.42.19;	author nicm;	state Exp;
branches;
next	1.220;

1.220
date	2010.05.05.23.24.23;	author nicm;	state Exp;
branches;
next	1.219;

1.219
date	2010.05.04.17.28.16;	author nicm;	state Exp;
branches;
next	1.218;

1.218
date	2010.05.04.08.48.06;	author nicm;	state Exp;
branches;
next	1.217;

1.217
date	2010.05.03.16.06.32;	author nicm;	state Exp;
branches;
next	1.216;

1.216
date	2010.04.06.21.35.44;	author nicm;	state Exp;
branches;
next	1.215;

1.215
date	2010.04.04.19.02.09;	author nicm;	state Exp;
branches;
next	1.214;

1.214
date	2010.04.04.18.48.37;	author nicm;	state Exp;
branches;
next	1.213;

1.213
date	2010.03.22.19.18.46;	author nicm;	state Exp;
branches;
next	1.212;

1.212
date	2010.03.22.19.10.42;	author nicm;	state Exp;
branches;
next	1.211;

1.211
date	2010.03.22.19.07.52;	author nicm;	state Exp;
branches;
next	1.210;

1.210
date	2010.03.22.19.02.54;	author nicm;	state Exp;
branches;
next	1.209;

1.209
date	2010.03.02.00.32.41;	author nicm;	state Exp;
branches;
next	1.208;

1.208
date	2010.02.19.00.03.21;	author nicm;	state Exp;
branches;
next	1.207;

1.207
date	2010.02.11.20.39.40;	author nicm;	state Exp;
branches;
next	1.206;

1.206
date	2010.02.06.23.22.27;	author nicm;	state Exp;
branches;
next	1.205;

1.205
date	2010.02.06.22.55.31;	author nicm;	state Exp;
branches;
next	1.204;

1.204
date	2010.02.06.17.35.01;	author nicm;	state Exp;
branches;
next	1.203;

1.203
date	2010.02.06.17.15.33;	author nicm;	state Exp;
branches;
next	1.202;

1.202
date	2010.02.04.20.00.26;	author nicm;	state Exp;
branches;
next	1.201;

1.201
date	2010.02.01.22.15.51;	author nicm;	state Exp;
branches;
next	1.200;

1.200
date	2010.01.27.20.18.52;	author nicm;	state Exp;
branches;
next	1.199;

1.199
date	2010.01.25.21.33.39;	author nicm;	state Exp;
branches;
next	1.198;

1.198
date	2010.01.07.20.52.18;	author nicm;	state Exp;
branches;
next	1.197;

1.197
date	2010.01.03.12.51.05;	author nicm;	state Exp;
branches;
next	1.196;

1.196
date	2009.12.17.17.39.56;	author nicm;	state Exp;
branches;
next	1.195;

1.195
date	2009.12.14.10.43.41;	author nicm;	state Exp;
branches;
next	1.194;

1.194
date	2009.12.10.09.16.52;	author nicm;	state Exp;
branches;
next	1.193;

1.193
date	2009.12.08.07.49.31;	author nicm;	state Exp;
branches;
next	1.192;

1.192
date	2009.12.03.22.50.10;	author nicm;	state Exp;
branches;
next	1.191;

1.191
date	2009.12.03.17.44.02;	author nicm;	state Exp;
branches;
next	1.190;

1.190
date	2009.12.01.18.42.38;	author nicm;	state Exp;
branches;
next	1.189;

1.189
date	2009.11.30.16.44.03;	author nicm;	state Exp;
branches;
next	1.188;

1.188
date	2009.11.26.23.13.47;	author nicm;	state Exp;
branches;
next	1.187;

1.187
date	2009.11.26.22.28.24;	author nicm;	state Exp;
branches;
next	1.186;

1.186
date	2009.11.26.21.37.13;	author nicm;	state Exp;
branches;
next	1.185;

1.185
date	2009.11.25.12.24.31;	author nicm;	state Exp;
branches;
next	1.184;

1.184
date	2009.11.19.19.47.28;	author nicm;	state Exp;
branches;
next	1.183;

1.183
date	2009.11.19.16.22.10;	author nicm;	state Exp;
branches;
next	1.182;

1.182
date	2009.11.19.10.22.07;	author nicm;	state Exp;
branches;
next	1.181;

1.181
date	2009.11.18.17.02.17;	author nicm;	state Exp;
branches;
next	1.180;

1.180
date	2009.11.18.13.16.33;	author nicm;	state Exp;
branches;
next	1.179;

1.179
date	2009.11.13.19.58.32;	author nicm;	state Exp;
branches;
next	1.178;

1.178
date	2009.11.13.19.53.29;	author nicm;	state Exp;
branches;
next	1.177;

1.177
date	2009.11.13.17.33.07;	author nicm;	state Exp;
branches;
next	1.176;

1.176
date	2009.11.13.07.00.54;	author nicm;	state Exp;
branches;
next	1.175;

1.175
date	2009.11.11.08.00.42;	author nicm;	state Exp;
branches;
next	1.174;

1.174
date	2009.11.10.17.41.35;	author nicm;	state Exp;
branches;
next	1.173;

1.173
date	2009.11.05.19.29.41;	author nicm;	state Exp;
branches;
next	1.172;

1.172
date	2009.11.05.10.44.36;	author nicm;	state Exp;
branches;
next	1.171;

1.171
date	2009.11.05.08.48.15;	author nicm;	state Exp;
branches;
next	1.170;

1.170
date	2009.11.05.08.45.08;	author nicm;	state Exp;
branches;
next	1.169;

1.169
date	2009.11.05.00.05.00;	author nicm;	state Exp;
branches;
next	1.168;

1.168
date	2009.11.04.23.54.57;	author nicm;	state Exp;
branches;
next	1.167;

1.167
date	2009.11.04.23.42.51;	author nicm;	state Exp;
branches;
next	1.166;

1.166
date	2009.11.04.23.29.42;	author nicm;	state Exp;
branches;
next	1.165;

1.165
date	2009.11.04.23.12.43;	author nicm;	state Exp;
branches;
next	1.164;

1.164
date	2009.11.04.22.44.53;	author nicm;	state Exp;
branches;
next	1.163;

1.163
date	2009.11.04.22.43.11;	author nicm;	state Exp;
branches;
next	1.162;

1.162
date	2009.11.04.22.02.38;	author nicm;	state Exp;
branches;
next	1.161;

1.161
date	2009.11.04.21.47.42;	author nicm;	state Exp;
branches;
next	1.160;

1.160
date	2009.11.04.21.04.43;	author nicm;	state Exp;
branches;
next	1.159;

1.159
date	2009.11.04.20.50.11;	author nicm;	state Exp;
branches;
next	1.158;

1.158
date	2009.11.03.22.40.40;	author nicm;	state Exp;
branches;
next	1.157;

1.157
date	2009.11.03.20.59.22;	author nicm;	state Exp;
branches;
next	1.156;

1.156
date	2009.11.03.20.29.47;	author nicm;	state Exp;
branches;
next	1.155;

1.155
date	2009.11.03.17.17.24;	author nicm;	state Exp;
branches;
next	1.154;

1.154
date	2009.11.02.20.18.22;	author nicm;	state Exp;
branches;
next	1.153;

1.153
date	2009.11.01.23.20.37;	author nicm;	state Exp;
branches;
next	1.152;

1.152
date	2009.10.28.22.53.14;	author nicm;	state Exp;
branches;
next	1.151;

1.151
date	2009.10.27.13.03.33;	author nicm;	state Exp;
branches;
next	1.150;

1.150
date	2009.10.26.17.46.33;	author nicm;	state Exp;
branches;
next	1.149;

1.149
date	2009.10.26.16.00.51;	author nicm;	state Exp;
branches;
next	1.148;

1.148
date	2009.10.26.13.13.33;	author nicm;	state Exp;
branches;
next	1.147;

1.147
date	2009.10.25.21.11.21;	author nicm;	state Exp;
branches;
next	1.146;

1.146
date	2009.10.22.19.41.51;	author nicm;	state Exp;
branches;
next	1.145;

1.145
date	2009.10.21.20.11.47;	author nicm;	state Exp;
branches;
next	1.144;

1.144
date	2009.10.21.18.20.16;	author nicm;	state Exp;
branches;
next	1.143;

1.143
date	2009.10.20.19.18.28;	author nicm;	state Exp;
branches;
next	1.142;

1.142
date	2009.10.20.17.33.33;	author nicm;	state Exp;
branches;
next	1.141;

1.141
date	2009.10.20.14.22.57;	author nicm;	state Exp;
branches;
next	1.140;

1.140
date	2009.10.17.08.24.46;	author nicm;	state Exp;
branches;
next	1.139;

1.139
date	2009.10.13.15.38.37;	author nicm;	state Exp;
branches;
next	1.138;

1.138
date	2009.10.13.13.45.56;	author nicm;	state Exp;
branches;
next	1.137;

1.137
date	2009.10.12.17.19.47;	author nicm;	state Exp;
branches;
next	1.136;

1.136
date	2009.10.12.16.59.55;	author nicm;	state Exp;
branches;
next	1.135;

1.135
date	2009.10.12.13.01.18;	author nicm;	state Exp;
branches;
next	1.134;

1.134
date	2009.10.12.09.29.58;	author nicm;	state Exp;
branches;
next	1.133;

1.133
date	2009.10.12.09.16.59;	author nicm;	state Exp;
branches;
next	1.132;

1.132
date	2009.10.12.09.09.35;	author nicm;	state Exp;
branches;
next	1.131;

1.131
date	2009.10.11.10.04.27;	author nicm;	state Exp;
branches;
next	1.130;

1.130
date	2009.10.11.07.20.16;	author nicm;	state Exp;
branches;
next	1.129;

1.129
date	2009.10.11.07.01.10;	author nicm;	state Exp;
branches;
next	1.128;

1.128
date	2009.10.10.18.42.14;	author nicm;	state Exp;
branches;
next	1.127;

1.127
date	2009.10.10.17.19.38;	author nicm;	state Exp;
branches;
next	1.126;

1.126
date	2009.10.10.15.03.01;	author nicm;	state Exp;
branches;
next	1.125;

1.125
date	2009.10.10.14.51.16;	author nicm;	state Exp;
branches;
next	1.124;

1.124
date	2009.10.10.10.02.48;	author nicm;	state Exp;
branches;
next	1.123;

1.123
date	2009.10.10.09.46.11;	author nicm;	state Exp;
branches;
next	1.122;

1.122
date	2009.10.09.07.33.12;	author nicm;	state Exp;
branches;
next	1.121;

1.121
date	2009.10.06.07.19.32;	author nicm;	state Exp;
branches;
next	1.120;

1.120
date	2009.10.06.07.09.00;	author nicm;	state Exp;
branches;
next	1.119;

1.119
date	2009.10.05.18.30.54;	author nicm;	state Exp;
branches;
next	1.118;

1.118
date	2009.09.24.14.17.09;	author nicm;	state Exp;
branches;
next	1.117;

1.117
date	2009.09.23.14.42.48;	author nicm;	state Exp;
branches;
next	1.116;

1.116
date	2009.09.23.12.03.31;	author nicm;	state Exp;
branches;
next	1.115;

1.115
date	2009.09.23.06.18.48;	author nicm;	state Exp;
branches;
next	1.114;

1.114
date	2009.09.23.06.12.58;	author nicm;	state Exp;
branches;
next	1.113;

1.113
date	2009.09.23.06.05.02;	author nicm;	state Exp;
branches;
next	1.112;

1.112
date	2009.09.22.12.38.10;	author nicm;	state Exp;
branches;
next	1.111;

1.111
date	2009.09.21.14.56.03;	author nicm;	state Exp;
branches;
next	1.110;

1.110
date	2009.09.21.14.46.47;	author nicm;	state Exp;
branches;
next	1.109;

1.109
date	2009.09.21.07.00.09;	author nicm;	state Exp;
branches;
next	1.108;

1.108
date	2009.09.21.06.55.06;	author nicm;	state Exp;
branches;
next	1.107;

1.107
date	2009.09.20.19.15.02;	author nicm;	state Exp;
branches;
next	1.106;

1.106
date	2009.09.20.17.27.18;	author nicm;	state Exp;
branches;
next	1.105;

1.105
date	2009.09.16.12.35.04;	author nicm;	state Exp;
branches;
next	1.104;

1.104
date	2009.09.14.11.25.35;	author nicm;	state Exp;
branches;
next	1.103;

1.103
date	2009.09.12.13.01.19;	author nicm;	state Exp;
branches;
next	1.102;

1.102
date	2009.09.10.17.16.24;	author nicm;	state Exp;
branches;
next	1.101;

1.101
date	2009.09.07.21.01.50;	author nicm;	state Exp;
branches;
next	1.100;

1.100
date	2009.09.07.18.50.45;	author nicm;	state Exp;
branches;
next	1.99;

1.99
date	2009.09.07.10.49.32;	author nicm;	state Exp;
branches;
next	1.98;

1.98
date	2009.09.02.20.15.49;	author nicm;	state Exp;
branches;
next	1.97;

1.97
date	2009.09.02.20.00.10;	author nicm;	state Exp;
branches;
next	1.96;

1.96
date	2009.09.02.17.34.57;	author nicm;	state Exp;
branches;
next	1.95;

1.95
date	2009.09.02.16.38.35;	author nicm;	state Exp;
branches;
next	1.94;

1.94
date	2009.09.02.06.33.20;	author nicm;	state Exp;
branches;
next	1.93;

1.93
date	2009.09.01.13.09.50;	author nicm;	state Exp;
branches;
next	1.92;

1.92
date	2009.08.31.20.46.19;	author nicm;	state Exp;
branches;
next	1.91;

1.91
date	2009.08.25.12.18.51;	author nicm;	state Exp;
branches;
next	1.90;

1.90
date	2009.08.24.08.03.11;	author nicm;	state Exp;
branches;
next	1.89;

1.89
date	2009.08.23.17.29.51;	author nicm;	state Exp;
branches;
next	1.88;

1.88
date	2009.08.23.16.45.00;	author nicm;	state Exp;
branches;
next	1.87;

1.87
date	2009.08.19.10.39.50;	author nicm;	state Exp;
branches;
next	1.86;

1.86
date	2009.08.18.21.41.13;	author nicm;	state Exp;
branches;
next	1.85;

1.85
date	2009.08.18.14.48.42;	author nicm;	state Exp;
branches;
next	1.84;

1.84
date	2009.08.18.07.23.43;	author nicm;	state Exp;
branches;
next	1.83;

1.83
date	2009.08.18.07.08.26;	author nicm;	state Exp;
branches;
next	1.82;

1.82
date	2009.08.13.22.32.18;	author nicm;	state Exp;
branches;
next	1.81;

1.81
date	2009.08.13.20.11.58;	author nicm;	state Exp;
branches;
next	1.80;

1.80
date	2009.08.13.19.04.00;	author nicm;	state Exp;
branches;
next	1.79;

1.79
date	2009.08.12.09.41.59;	author nicm;	state Exp;
branches;
next	1.78;

1.78
date	2009.08.11.21.28.11;	author nicm;	state Exp;
branches;
next	1.77;

1.77
date	2009.08.11.20.29.04;	author nicm;	state Exp;
branches;
next	1.76;

1.76
date	2009.08.11.19.32.25;	author nicm;	state Exp;
branches;
next	1.75;

1.75
date	2009.08.11.17.18.35;	author nicm;	state Exp;
branches;
next	1.74;

1.74
date	2009.08.11.12.53.37;	author nicm;	state Exp;
branches;
next	1.73;

1.73
date	2009.08.08.21.52.43;	author nicm;	state Exp;
branches;
next	1.72;

1.72
date	2009.08.08.15.57.49;	author nicm;	state Exp;
branches;
next	1.71;

1.71
date	2009.08.08.13.29.27;	author nicm;	state Exp;
branches;
next	1.70;

1.70
date	2009.08.07.15.39.10;	author nicm;	state Exp;
branches;
next	1.69;

1.69
date	2009.08.07.00.12.13;	author nicm;	state Exp;
branches;
next	1.68;

1.68
date	2009.08.04.18.45.57;	author nicm;	state Exp;
branches;
next	1.67;

1.67
date	2009.08.03.14.10.54;	author nicm;	state Exp;
branches;
next	1.66;

1.66
date	2009.07.30.16.32.12;	author nicm;	state Exp;
branches;
next	1.65;

1.65
date	2009.07.30.13.45.56;	author nicm;	state Exp;
branches;
next	1.64;

1.64
date	2009.07.29.14.17.26;	author nicm;	state Exp;
branches;
next	1.63;

1.63
date	2009.07.28.17.05.10;	author nicm;	state Exp;
branches;
next	1.62;

1.62
date	2009.07.28.07.03.32;	author nicm;	state Exp;
branches;
next	1.61;

1.61
date	2009.07.28.06.48.44;	author nicm;	state Exp;
branches;
next	1.60;

1.60
date	2009.07.27.20.36.13;	author nicm;	state Exp;
branches;
next	1.59;

1.59
date	2009.07.27.19.29.35;	author nicm;	state Exp;
branches;
next	1.58;

1.58
date	2009.07.27.18.51.46;	author nicm;	state Exp;
branches;
next	1.57;

1.57
date	2009.07.27.12.11.11;	author nicm;	state Exp;
branches;
next	1.56;

1.56
date	2009.07.26.21.42.08;	author nicm;	state Exp;
branches;
next	1.55;

1.55
date	2009.07.26.12.58.44;	author nicm;	state Exp;
branches;
next	1.54;

1.54
date	2009.07.24.14.52.47;	author nicm;	state Exp;
branches;
next	1.53;

1.53
date	2009.07.23.20.24.27;	author nicm;	state Exp;
branches;
next	1.52;

1.52
date	2009.07.23.12.33.48;	author nicm;	state Exp;
branches;
next	1.51;

1.51
date	2009.07.22.21.34.36;	author nicm;	state Exp;
branches;
next	1.50;

1.50
date	2009.07.22.20.56.58;	author nicm;	state Exp;
branches;
next	1.49;

1.49
date	2009.07.22.20.53.38;	author nicm;	state Exp;
branches;
next	1.48;

1.48
date	2009.07.22.18.06.58;	author nicm;	state Exp;
branches;
next	1.47;

1.47
date	2009.07.22.18.02.23;	author nicm;	state Exp;
branches;
next	1.46;

1.46
date	2009.07.22.16.45.31;	author nicm;	state Exp;
branches;
next	1.45;

1.45
date	2009.07.22.15.55.32;	author nicm;	state Exp;
branches;
next	1.44;

1.44
date	2009.07.21.19.54.22;	author nicm;	state Exp;
branches;
next	1.43;

1.43
date	2009.07.21.18.40.30;	author nicm;	state Exp;
branches;
next	1.42;

1.42
date	2009.07.21.18.38.52;	author nicm;	state Exp;
branches;
next	1.41;

1.41
date	2009.07.21.17.57.29;	author nicm;	state Exp;
branches;
next	1.40;

1.40
date	2009.07.20.14.37.51;	author nicm;	state Exp;
branches;
next	1.39;

1.39
date	2009.07.19.13.21.40;	author nicm;	state Exp;
branches;
next	1.38;

1.38
date	2009.07.18.14.59.25;	author nicm;	state Exp;
branches;
next	1.37;

1.37
date	2009.07.17.20.37.03;	author nicm;	state Exp;
branches;
next	1.36;

1.36
date	2009.07.17.18.45.08;	author nicm;	state Exp;
branches;
next	1.35;

1.35
date	2009.07.17.15.03.11;	author nicm;	state Exp;
branches;
next	1.34;

1.34
date	2009.07.17.07.05.58;	author nicm;	state Exp;
branches;
next	1.33;

1.33
date	2009.07.17.06.13.27;	author nicm;	state Exp;
branches;
next	1.32;

1.32
date	2009.07.15.17.39.00;	author nicm;	state Exp;
branches;
next	1.31;

1.31
date	2009.07.15.07.50.34;	author nicm;	state Exp;
branches;
next	1.30;

1.30
date	2009.07.14.20.20.04;	author nicm;	state Exp;
branches;
next	1.29;

1.29
date	2009.07.14.19.03.16;	author nicm;	state Exp;
branches;
next	1.28;

1.28
date	2009.07.14.07.23.36;	author nicm;	state Exp;
branches;
next	1.27;

1.27
date	2009.07.13.23.11.35;	author nicm;	state Exp;
branches;
next	1.26;

1.26
date	2009.07.13.17.47.46;	author nicm;	state Exp;
branches;
next	1.25;

1.25
date	2009.07.13.10.43.52;	author nicm;	state Exp;
branches;
next	1.24;

1.24
date	2009.07.12.23.46.49;	author nicm;	state Exp;
branches;
next	1.23;

1.23
date	2009.07.12.16.15.34;	author nicm;	state Exp;
branches;
next	1.22;

1.22
date	2009.07.12.16.07.56;	author nicm;	state Exp;
branches;
next	1.21;

1.21
date	2009.07.11.19.14.56;	author nicm;	state Exp;
branches;
next	1.20;

1.20
date	2009.07.10.05.50.54;	author nicm;	state Exp;
branches;
next	1.19;

1.19
date	2009.07.09.15.47.49;	author nicm;	state Exp;
branches;
next	1.18;

1.18
date	2009.07.09.00.29.32;	author nicm;	state Exp;
branches;
next	1.17;

1.17
date	2009.07.08.05.26.45;	author nicm;	state Exp;
branches;
next	1.16;

1.16
date	2009.07.07.19.49.19;	author nicm;	state Exp;
branches;
next	1.15;

1.15
date	2009.06.26.19.44.36;	author nicm;	state Exp;
branches;
next	1.14;

1.14
date	2009.06.25.22.08.15;	author nicm;	state Exp;
branches;
next	1.13;

1.13
date	2009.06.25.06.23.10;	author nicm;	state Exp;
branches;
next	1.12;

1.12
date	2009.06.25.06.15.04;	author nicm;	state Exp;
branches;
next	1.11;

1.11
date	2009.06.25.06.05.47;	author nicm;	state Exp;
branches;
next	1.10;

1.10
date	2009.06.24.22.49.56;	author nicm;	state Exp;
branches;
next	1.9;

1.9
date	2009.06.24.22.04.18;	author nicm;	state Exp;
branches;
next	1.8;

1.8
date	2009.06.24.16.01.02;	author nicm;	state Exp;
branches;
next	1.7;

1.7
date	2009.06.24.05.35.07;	author nicm;	state Exp;
branches;
next	1.6;

1.6
date	2009.06.04.18.48.24;	author nicm;	state Exp;
branches;
next	1.5;

1.5
date	2009.06.03.23.30.40;	author nicm;	state Exp;
branches;
next	1.4;

1.4
date	2009.06.03.16.54.26;	author nicm;	state Exp;
branches;
next	1.3;

1.3
date	2009.06.03.16.05.46;	author nicm;	state Exp;
branches;
next	1.2;

1.2
date	2009.06.03.07.51.24;	author nicm;	state Exp;
branches;
next	1.1;

1.1
date	2009.06.01.22.58.49;	author nicm;	state Exp;
branches;
next	;


desc
@@


1.751
log
@Get rid of the extra layer of flags and cmd_prepare() and just store the
CMD_FIND_* flags in the cmd_entry and call it for the command. Commands
with special requirements call it themselves and update the target for
hooks to use.
@
text
@/* $OpenBSD: tmux.h,v 1.750 2017/04/21 20:26:34 nicm Exp $ */

/*
 * Copyright (c) 2007 Nicholas Marriott <nicholas.marriott@@gmail.com>
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF MIND, USE, DATA OR PROFITS, WHETHER
 * IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING
 * OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */

#ifndef TMUX_H
#define TMUX_H

#define PROTOCOL_VERSION 8

#include <sys/time.h>
#include <sys/queue.h>
#include <sys/tree.h>

#include <bitstring.h>
#include <event.h>
#include <limits.h>
#include <stdarg.h>
#include <stdint.h>
#include <stdio.h>
#include <termios.h>
#include <wchar.h>

#include "xmalloc.h"

extern char   **environ;

struct args;
struct client;
struct cmdq_item;
struct cmdq_list;
struct environ;
struct input_ctx;
struct mode_key_cmdstr;
struct mouse_event;
struct options;
struct options_entry;
struct session;
struct tmuxpeer;
struct tmuxproc;

/* Default global configuration file. */
#define TMUX_CONF "/etc/tmux.conf"

/*
 * Minimum layout cell size, NOT including separator line. The scroll region
 * cannot be one line in height so this must be at least two.
 */
#define PANE_MINIMUM 2

/* Automatic name refresh interval, in microseconds. Must be < 1 second. */
#define NAME_INTERVAL 500000

/* Maximum size of data to hold from a pane. */
#define READ_SIZE 4096

/* Attribute to make GCC check printf-like arguments. */
#define printflike(a, b) __attribute__ ((format (printf, a, b)))

/* Number of items in array. */
#ifndef nitems
#define nitems(_a) (sizeof((_a)) / sizeof((_a)[0]))
#endif

/* Bell option values. */
#define BELL_NONE 0
#define BELL_ANY 1
#define BELL_CURRENT 2
#define BELL_OTHER 3

/* Special key codes. */
#define KEYC_NONE 0xffff00000000ULL
#define KEYC_UNKNOWN 0xfffe00000000ULL
#define KEYC_BASE 0x000010000000ULL

/* Key modifier bits. */
#define KEYC_ESCAPE 0x200000000000ULL
#define KEYC_CTRL   0x400000000000ULL
#define KEYC_SHIFT  0x800000000000ULL

/* Mask to obtain key w/o modifiers. */
#define KEYC_MASK_MOD (KEYC_ESCAPE|KEYC_CTRL|KEYC_SHIFT)
#define KEYC_MASK_KEY (~KEYC_MASK_MOD)

/* Is this a mouse key? */
#define KEYC_IS_MOUSE(key) (((key) & KEYC_MASK_KEY) >= KEYC_MOUSE &&	\
    ((key) & KEYC_MASK_KEY) < KEYC_BSPACE)

/* Multiple click timeout. */
#define KEYC_CLICK_TIMEOUT 300

/* Mouse key codes. */
#define KEYC_MOUSE_KEY(name)				\
	KEYC_ ## name ## _PANE,				\
	KEYC_ ## name ## _STATUS,			\
	KEYC_ ## name ## _BORDER
#define KEYC_MOUSE_STRING(name, s)			\
	{ #s "Pane", KEYC_ ## name ## _PANE },		\
	{ #s "Status", KEYC_ ## name ## _STATUS },	\
	{ #s "Border", KEYC_ ## name ## _BORDER }

/*
 * A single key. This can be ASCII or Unicode or one of the keys starting at
 * KEYC_BASE.
 */
typedef unsigned long long key_code;

/* Special key codes. */
enum {
	/* Focus events. */
	KEYC_FOCUS_IN = KEYC_BASE,
	KEYC_FOCUS_OUT,

	/* Mouse keys. */
	KEYC_MOUSE, /* unclassified mouse event */
	KEYC_DRAGGING, /* dragging in progress */
	KEYC_MOUSE_KEY(MOUSEMOVE),
	KEYC_MOUSE_KEY(MOUSEDOWN1),
	KEYC_MOUSE_KEY(MOUSEDOWN2),
	KEYC_MOUSE_KEY(MOUSEDOWN3),
	KEYC_MOUSE_KEY(MOUSEUP1),
	KEYC_MOUSE_KEY(MOUSEUP2),
	KEYC_MOUSE_KEY(MOUSEUP3),
	KEYC_MOUSE_KEY(MOUSEDRAG1),
	KEYC_MOUSE_KEY(MOUSEDRAG2),
	KEYC_MOUSE_KEY(MOUSEDRAG3),
	KEYC_MOUSE_KEY(MOUSEDRAGEND1),
	KEYC_MOUSE_KEY(MOUSEDRAGEND2),
	KEYC_MOUSE_KEY(MOUSEDRAGEND3),
	KEYC_MOUSE_KEY(WHEELUP),
	KEYC_MOUSE_KEY(WHEELDOWN),
	KEYC_MOUSE_KEY(DOUBLECLICK1),
	KEYC_MOUSE_KEY(DOUBLECLICK2),
	KEYC_MOUSE_KEY(DOUBLECLICK3),
	KEYC_MOUSE_KEY(TRIPLECLICK1),
	KEYC_MOUSE_KEY(TRIPLECLICK2),
	KEYC_MOUSE_KEY(TRIPLECLICK3),

	/* Backspace key. */
	KEYC_BSPACE,

	/* Function keys. */
	KEYC_F1,
	KEYC_F2,
	KEYC_F3,
	KEYC_F4,
	KEYC_F5,
	KEYC_F6,
	KEYC_F7,
	KEYC_F8,
	KEYC_F9,
	KEYC_F10,
	KEYC_F11,
	KEYC_F12,
	KEYC_IC,
	KEYC_DC,
	KEYC_HOME,
	KEYC_END,
	KEYC_NPAGE,
	KEYC_PPAGE,
	KEYC_BTAB,

	/* Arrow keys. */
	KEYC_UP,
	KEYC_DOWN,
	KEYC_LEFT,
	KEYC_RIGHT,

	/* Numeric keypad. */
	KEYC_KP_SLASH,
	KEYC_KP_STAR,
	KEYC_KP_MINUS,
	KEYC_KP_SEVEN,
	KEYC_KP_EIGHT,
	KEYC_KP_NINE,
	KEYC_KP_PLUS,
	KEYC_KP_FOUR,
	KEYC_KP_FIVE,
	KEYC_KP_SIX,
	KEYC_KP_ONE,
	KEYC_KP_TWO,
	KEYC_KP_THREE,
	KEYC_KP_ENTER,
	KEYC_KP_ZERO,
	KEYC_KP_PERIOD,
};

/* Termcap codes. */
enum tty_code_code {
	TTYC_AX = 0,
	TTYC_ACSC,	/* acs_chars, ac */
	TTYC_BCE,	/* back_color_erase, ut */
	TTYC_BEL,	/* bell, bl */
	TTYC_BLINK,	/* enter_blink_mode, mb */
	TTYC_BOLD,	/* enter_bold_mode, md */
	TTYC_CIVIS,	/* cursor_invisible, vi */
	TTYC_CLEAR,	/* clear_screen, cl */
	TTYC_CNORM,	/* cursor_normal, ve */
	TTYC_COLORS,	/* max_colors, Co */
	TTYC_CR,	/* restore cursor colour, Cr */
	TTYC_CS,	/* set cursor colour, Cs */
	TTYC_CSR,	/* change_scroll_region, cs */
	TTYC_CUB,	/* parm_left_cursor, LE */
	TTYC_CUB1,	/* cursor_left, le */
	TTYC_CUD,	/* parm_down_cursor, DO */
	TTYC_CUD1,	/* cursor_down, do */
	TTYC_CUF,	/* parm_right_cursor, RI */
	TTYC_CUF1,	/* cursor_right, nd */
	TTYC_CUP,	/* cursor_address, cm */
	TTYC_CUU,	/* parm_up_cursor, UP */
	TTYC_CUU1,	/* cursor_up, up */
	TTYC_CVVIS,	/* cursor_visible, vs */
	TTYC_DCH,	/* parm_dch, DC */
	TTYC_DCH1,	/* delete_character, dc */
	TTYC_DIM,	/* enter_dim_mode, mh */
	TTYC_DL,	/* parm_delete_line, DL */
	TTYC_DL1,	/* delete_line, dl */
	TTYC_E3,
	TTYC_ECH,	/* erase_chars, ec */
	TTYC_ED,	/* clr_eos, cd */
	TTYC_EL,	/* clr_eol, ce */
	TTYC_EL1,	/* clr_bol, cb */
	TTYC_ENACS,	/* ena_acs, eA */
	TTYC_FSL,	/* from_status_line, fsl */
	TTYC_HOME,	/* cursor_home, ho */
	TTYC_HPA,	/* column_address, ch */
	TTYC_ICH,	/* parm_ich, IC */
	TTYC_ICH1,	/* insert_character, ic */
	TTYC_IL,	/* parm_insert_line, IL */
	TTYC_IL1,	/* insert_line, il */
	TTYC_INDN,      /* parm_index, indn */
	TTYC_INVIS,	/* enter_secure_mode, mk */
	TTYC_KCBT,	/* key_btab, kB */
	TTYC_KCUB1,	/* key_left, kl */
	TTYC_KCUD1,	/* key_down, kd */
	TTYC_KCUF1,	/* key_right, kr */
	TTYC_KCUU1,	/* key_up, ku */
	TTYC_KDC2,
	TTYC_KDC3,
	TTYC_KDC4,
	TTYC_KDC5,
	TTYC_KDC6,
	TTYC_KDC7,
	TTYC_KDCH1,	/* key_dc, kD */
	TTYC_KDN2,
	TTYC_KDN3,
	TTYC_KDN4,
	TTYC_KDN5,
	TTYC_KDN6,
	TTYC_KDN7,
	TTYC_KEND,	/* key_end, ke */
	TTYC_KEND2,
	TTYC_KEND3,
	TTYC_KEND4,
	TTYC_KEND5,
	TTYC_KEND6,
	TTYC_KEND7,
	TTYC_KF1,
	TTYC_KF10,
	TTYC_KF11,
	TTYC_KF12,
	TTYC_KF13,
	TTYC_KF14,
	TTYC_KF15,
	TTYC_KF16,
	TTYC_KF17,
	TTYC_KF18,
	TTYC_KF19,
	TTYC_KF2,
	TTYC_KF20,
	TTYC_KF21,
	TTYC_KF22,
	TTYC_KF23,
	TTYC_KF24,
	TTYC_KF25,
	TTYC_KF26,
	TTYC_KF27,
	TTYC_KF28,
	TTYC_KF29,
	TTYC_KF3,
	TTYC_KF30,
	TTYC_KF31,
	TTYC_KF32,
	TTYC_KF33,
	TTYC_KF34,
	TTYC_KF35,
	TTYC_KF36,
	TTYC_KF37,
	TTYC_KF38,
	TTYC_KF39,
	TTYC_KF4,
	TTYC_KF40,
	TTYC_KF41,
	TTYC_KF42,
	TTYC_KF43,
	TTYC_KF44,
	TTYC_KF45,
	TTYC_KF46,
	TTYC_KF47,
	TTYC_KF48,
	TTYC_KF49,
	TTYC_KF5,
	TTYC_KF50,
	TTYC_KF51,
	TTYC_KF52,
	TTYC_KF53,
	TTYC_KF54,
	TTYC_KF55,
	TTYC_KF56,
	TTYC_KF57,
	TTYC_KF58,
	TTYC_KF59,
	TTYC_KF6,
	TTYC_KF60,
	TTYC_KF61,
	TTYC_KF62,
	TTYC_KF63,
	TTYC_KF7,
	TTYC_KF8,
	TTYC_KF9,
	TTYC_KHOM2,
	TTYC_KHOM3,
	TTYC_KHOM4,
	TTYC_KHOM5,
	TTYC_KHOM6,
	TTYC_KHOM7,
	TTYC_KHOME,	/* key_home, kh */
	TTYC_KIC2,
	TTYC_KIC3,
	TTYC_KIC4,
	TTYC_KIC5,
	TTYC_KIC6,
	TTYC_KIC7,
	TTYC_KICH1,	/* key_ic, kI */
	TTYC_KLFT2,
	TTYC_KLFT3,
	TTYC_KLFT4,
	TTYC_KLFT5,
	TTYC_KLFT6,
	TTYC_KLFT7,
	TTYC_KMOUS,	/* key_mouse, Km */
	TTYC_KNP,	/* key_npage, kN */
	TTYC_KNXT2,
	TTYC_KNXT3,
	TTYC_KNXT4,
	TTYC_KNXT5,
	TTYC_KNXT6,
	TTYC_KNXT7,
	TTYC_KPP,	/* key_ppage, kP */
	TTYC_KPRV2,
	TTYC_KPRV3,
	TTYC_KPRV4,
	TTYC_KPRV5,
	TTYC_KPRV6,
	TTYC_KPRV7,
	TTYC_KRIT2,
	TTYC_KRIT3,
	TTYC_KRIT4,
	TTYC_KRIT5,
	TTYC_KRIT6,
	TTYC_KRIT7,
	TTYC_KUP2,
	TTYC_KUP3,
	TTYC_KUP4,
	TTYC_KUP5,
	TTYC_KUP6,
	TTYC_KUP7,
	TTYC_MS,	/* modify xterm(1) selection */
	TTYC_OP,	/* orig_pair, op */
	TTYC_REV,	/* enter_reverse_mode, mr */
	TTYC_RI,	/* scroll_reverse, sr */
	TTYC_RMACS,	/* exit_alt_charset_mode */
	TTYC_RMCUP,	/* exit_ca_mode, te */
	TTYC_RMKX,	/* keypad_local, ke */
	TTYC_SE,	/* reset cursor style, Se */
	TTYC_SETAB,	/* set_a_background, AB */
	TTYC_SETAF,	/* set_a_foreground, AF */
	TTYC_SGR0,	/* exit_attribute_mode, me */
	TTYC_SITM,	/* enter_italics_mode, it */
	TTYC_SMACS,	/* enter_alt_charset_mode, as */
	TTYC_SMCUP,	/* enter_ca_mode, ti */
	TTYC_SMKX,	/* keypad_xmit, ks */
	TTYC_SMSO,	/* enter_standout_mode, so */
	TTYC_SMUL,	/* enter_underline_mode, us */
	TTYC_SMXX,
	TTYC_SS,	/* set cursor style, Ss */
	TTYC_TC,	/* 24-bit "true" colour, Tc */
	TTYC_TSL,	/* to_status_line, tsl */
	TTYC_VPA,	/* row_address, cv */
	TTYC_XENL,	/* eat_newline_glitch, xn */
	TTYC_XT,	/* xterm(1)-compatible title, XT */
};

/* Message codes. */
enum msgtype {
	MSG_VERSION = 12,

	MSG_IDENTIFY_FLAGS = 100,
	MSG_IDENTIFY_TERM,
	MSG_IDENTIFY_TTYNAME,
	MSG_IDENTIFY_OLDCWD, /* unused */
	MSG_IDENTIFY_STDIN,
	MSG_IDENTIFY_ENVIRON,
	MSG_IDENTIFY_DONE,
	MSG_IDENTIFY_CLIENTPID,
	MSG_IDENTIFY_CWD,

	MSG_COMMAND = 200,
	MSG_DETACH,
	MSG_DETACHKILL,
	MSG_EXIT,
	MSG_EXITED,
	MSG_EXITING,
	MSG_LOCK,
	MSG_READY,
	MSG_RESIZE,
	MSG_SHELL,
	MSG_SHUTDOWN,
	MSG_STDERR,
	MSG_STDIN,
	MSG_STDOUT,
	MSG_SUSPEND,
	MSG_UNLOCK,
	MSG_WAKEUP,
	MSG_EXEC,
};

/*
 * Message data.
 *
 * Don't forget to bump PROTOCOL_VERSION if any of these change!
 */
struct msg_command_data {
	int	argc;
}; /* followed by packed argv */

struct msg_stdin_data {
	ssize_t	size;
	char	data[BUFSIZ];
};

struct msg_stdout_data {
	ssize_t	size;
	char	data[BUFSIZ];
};

struct msg_stderr_data {
	ssize_t	size;
	char	data[BUFSIZ];
};

/* Mode keys. */
#define MODEKEY_EMACS 0
#define MODEKEY_VI 1

/* Modes. */
#define MODE_CURSOR 0x1
#define MODE_INSERT 0x2
#define MODE_KCURSOR 0x4
#define MODE_KKEYPAD 0x8	/* set = application, clear = number */
#define MODE_WRAP 0x10		/* whether lines wrap */
#define MODE_MOUSE_STANDARD 0x20
#define MODE_MOUSE_BUTTON 0x40
#define MODE_BLINKING 0x80
#define MODE_MOUSE_UTF8 0x100
#define MODE_MOUSE_SGR 0x200
#define MODE_BRACKETPASTE 0x400
#define MODE_FOCUSON 0x800
#define MODE_MOUSE_ALL 0x1000

#define ALL_MODES 0xffffff
#define ALL_MOUSE_MODES (MODE_MOUSE_STANDARD|MODE_MOUSE_BUTTON|MODE_MOUSE_ALL)

/*
 * A single UTF-8 character. UTF8_SIZE must be big enough to hold at least one
 * combining character as well.
*/
#define UTF8_SIZE 9
struct utf8_data {
	u_char	data[UTF8_SIZE];

	u_char	have;
	u_char	size;

	u_char	width;	/* 0xff if invalid */
} __packed;
enum utf8_state {
	UTF8_MORE,
	UTF8_DONE,
	UTF8_ERROR
};

/* Colour flags. */
#define COLOUR_FLAG_256 0x01000000
#define COLOUR_FLAG_RGB 0x02000000

/* Grid attributes. Anything above 0xff is stored in an extended cell. */
#define GRID_ATTR_BRIGHT 0x1
#define GRID_ATTR_DIM 0x2
#define GRID_ATTR_UNDERSCORE 0x4
#define GRID_ATTR_BLINK 0x8
#define GRID_ATTR_REVERSE 0x10
#define GRID_ATTR_HIDDEN 0x20
#define GRID_ATTR_ITALICS 0x40
#define GRID_ATTR_CHARSET 0x80	/* alternative character set */
#define GRID_ATTR_STRIKETHROUGH 0x100

/* Grid flags. */
#define GRID_FLAG_FG256 0x1
#define GRID_FLAG_BG256 0x2
#define GRID_FLAG_PADDING 0x4
#define GRID_FLAG_EXTENDED 0x8
#define GRID_FLAG_SELECTED 0x10
#define GRID_FLAG_NOPALETTE 0x20

/* Grid line flags. */
#define GRID_LINE_WRAPPED 0x1
#define GRID_LINE_EXTENDED 0x2

/* Grid cell data. */
struct grid_cell {
	u_char			flags;
	u_short			attr;
	int			fg;
	int			bg;
	struct utf8_data	data;
};
struct grid_cell_entry {
	u_char			flags;
	union {
		u_int		offset;
		struct {
			u_char	attr;
			u_char	fg;
			u_char	bg;
			u_char	data;
		} data;
	};
} __packed;

/* Grid line. */
struct grid_line {
	u_int			 cellused;
	u_int			 cellsize;
	struct grid_cell_entry	*celldata;

	u_int			 extdsize;
	struct grid_cell	*extddata;

	int			 flags;
} __packed;

/* Entire grid of cells. */
struct grid {
	int			 flags;
#define GRID_HISTORY 0x1 /* scroll lines into history */

	u_int			 sx;
	u_int			 sy;

	u_int			 hscrolled;
	u_int			 hsize;
	u_int			 hlimit;

	struct grid_line	*linedata;
};

/* Hook data structures. */
struct hook {
	const char	*name;

	struct cmd_list	*cmdlist;

	RB_ENTRY(hook)	 entry;
};

/* Scheduled job. */
struct job;
typedef void (*job_update_cb) (struct job *);
typedef void (*job_complete_cb) (struct job *);
typedef void (*job_free_cb) (void *);
struct job {
	enum {
		JOB_RUNNING,
		JOB_DEAD,
		JOB_CLOSED
	} state;

	char			*cmd;
	pid_t			 pid;
	int			 status;

	int			 fd;
	struct bufferevent	*event;

	job_update_cb		 updatecb;
	job_complete_cb		 completecb;
	job_free_cb		 freecb;
	void			*data;

	LIST_ENTRY(job)	 	 entry;
};
LIST_HEAD(joblist, job);

/* Screen selection. */
struct screen_sel {
	int		 flag;
	int		 hidden;

	int		 rectflag;
	enum {
		LINE_SEL_NONE,
		LINE_SEL_LEFT_RIGHT,
		LINE_SEL_RIGHT_LEFT,
	} lineflag;

	int		 modekeys;

	u_int		 sx;
	u_int		 sy;

	u_int		 ex;
	u_int		 ey;

	struct grid_cell cell;
};

/* Virtual screen. */
struct screen {
	char			*title;

	struct grid		*grid;		/* grid data */

	u_int			 cx;		/* cursor x */
	u_int			 cy;		/* cursor y */

	u_int			 cstyle;	/* cursor style */
	char			*ccolour;	/* cursor colour string */

	u_int			 rupper;	/* scroll region top */
	u_int			 rlower;	/* scroll region bottom */

	int			 mode;

	bitstr_t		*tabs;

	struct screen_sel	 sel;
};

/* Screen write context. */
struct screen_write_collect_item;
struct screen_write_collect_line;
struct screen_write_ctx {
	struct window_pane	*wp;
	struct screen		*s;

	struct screen_write_collect_item *item;
	struct screen_write_collect_line *list;
	u_int			 scrolled;

	u_int			 cells;
	u_int			 written;
	u_int			 skipped;
};

/* Screen size. */
#define screen_size_x(s) ((s)->grid->sx)
#define screen_size_y(s) ((s)->grid->sy)
#define screen_hsize(s) ((s)->grid->hsize)
#define screen_hlimit(s) ((s)->grid->hlimit)

/*
 * Window mode. Windows can be in several modes and this is used to call the
 * right function to handle input and output.
 */
struct window_mode {
	struct screen *(*init)(struct window_pane *);
	void	(*free)(struct window_pane *);
	void	(*resize)(struct window_pane *, u_int, u_int);
	void	(*key)(struct window_pane *, struct client *, struct session *,
		    key_code, struct mouse_event *);

	const char *(*key_table)(struct window_pane *);
	void	(*command)(struct window_pane *, struct client *,
		    struct session *, struct args *, struct mouse_event *);
};
#define WINDOW_MODE_TIMEOUT 180

/* Structures for choose mode. */
struct window_choose_data {
	struct client		*start_client;
	struct session		*start_session;

	u_int			 idx;
	int			 type;
#define TREE_OTHER 0x0
#define TREE_WINDOW 0x1
#define TREE_SESSION 0x2

	struct session		*tree_session; /* session of items in tree */

	struct winlink		*wl;
	int			 pane_id;

	char			*ft_template;
	struct format_tree	*ft;

	char			*command;
};

/* Child window structure. */
struct window_pane {
	u_int		 id;
	u_int		 active_point;

	struct window	*window;

	struct layout_cell *layout_cell;
	struct layout_cell *saved_layout_cell;

	u_int		 sx;
	u_int		 sy;

	u_int		 xoff;
	u_int		 yoff;

	int		 flags;
#define PANE_REDRAW 0x1
#define PANE_DROP 0x2
#define PANE_FOCUSED 0x4
#define PANE_RESIZE 0x8
#define PANE_FOCUSPUSH 0x10
#define PANE_INPUTOFF 0x20
#define PANE_CHANGED 0x40

	int		 argc;
	char	       **argv;
	char		*shell;
	const char	*cwd;

	pid_t		 pid;
	char		 tty[TTY_NAME_MAX];
	int		 status;

	int		 fd;
	struct bufferevent *event;

	struct event	 resize_timer;

	struct input_ctx *ictx;

	struct grid_cell colgc;

	int		*palette;

	int		 pipe_fd;
	struct bufferevent *pipe_event;
	size_t		 pipe_off;

	struct screen	*screen;
	struct screen	 base;

	struct screen	 status_screen;
	size_t		 status_size;

	/* Saved in alternative screen mode. */
	u_int		 saved_cx;
	u_int		 saved_cy;
	struct grid	*saved_grid;
	struct grid_cell saved_cell;

	const struct window_mode *mode;
	void		*modedata;
	struct event	 modetimer;
	time_t		 modelast;
	u_int		 modeprefix;

	TAILQ_ENTRY(window_pane) entry;
	RB_ENTRY(window_pane) tree_entry;
};
TAILQ_HEAD(window_panes, window_pane);
RB_HEAD(window_pane_tree, window_pane);

/* Window structure. */
struct window {
	u_int		 id;

	char		*name;
	struct event	 name_event;
	struct timeval	 name_time;

	struct event	 alerts_timer;

	struct timeval	 activity_time;

	struct window_pane *active;
	struct window_pane *last;
	struct window_panes panes;

	int		 lastlayout;
	struct layout_cell *layout_root;
	struct layout_cell *saved_layout_root;
	char		*old_layout;

	u_int		 sx;
	u_int		 sy;

	int		 flags;
#define WINDOW_BELL 0x1
#define WINDOW_ACTIVITY 0x2
/* 0x4 unused */
#define WINDOW_SILENCE 0x8
#define WINDOW_ZOOMED 0x1000
#define WINDOW_FORCEWIDTH 0x2000
#define WINDOW_FORCEHEIGHT 0x4000
#define WINDOW_STYLECHANGED 0x8000
#define WINDOW_ALERTFLAGS (WINDOW_BELL|WINDOW_ACTIVITY|WINDOW_SILENCE)

	int		 alerts_queued;
	TAILQ_ENTRY(window) alerts_entry;

	struct options	*options;

	struct grid_cell style;
	struct grid_cell active_style;

	u_int		 references;
	TAILQ_HEAD(, winlink) winlinks;

	RB_ENTRY(window) entry;
};
RB_HEAD(windows, window);

/* Entry on local window list. */
struct winlink {
	int		 idx;
	struct session	*session;
	struct window	*window;

	size_t		 status_width;
	struct grid_cell status_cell;
	char		*status_text;

	int		 flags;
#define WINLINK_BELL 0x1
#define WINLINK_ACTIVITY 0x2
#define WINLINK_SILENCE 0x4
#define WINLINK_ALERTFLAGS (WINLINK_BELL|WINLINK_ACTIVITY|WINLINK_SILENCE)

	RB_ENTRY(winlink) entry;
	TAILQ_ENTRY(winlink) wentry;
	TAILQ_ENTRY(winlink) sentry;
};
RB_HEAD(winlinks, winlink);
TAILQ_HEAD(winlink_stack, winlink);

/* Layout direction. */
enum layout_type {
	LAYOUT_LEFTRIGHT,
	LAYOUT_TOPBOTTOM,
	LAYOUT_WINDOWPANE
};

/* Layout cells queue. */
TAILQ_HEAD(layout_cells, layout_cell);

/* Layout cell. */
struct layout_cell {
	enum layout_type type;

	struct layout_cell *parent;

	u_int		 sx;
	u_int		 sy;

	u_int		 xoff;
	u_int		 yoff;

	struct window_pane *wp;
	struct layout_cells cells;

	TAILQ_ENTRY(layout_cell) entry;
};

/* Environment variable. */
struct environ_entry {
	char		*name;
	char		*value;

	RB_ENTRY(environ_entry) entry;
};

/* Client session. */
struct session_group {
	const char		*name;
	TAILQ_HEAD(, session)	 sessions;

	RB_ENTRY(session_group)	 entry;
};
RB_HEAD(session_groups, session_group);

struct session {
	u_int		 id;

	char		*name;
	const char	*cwd;

	struct timeval	 creation_time;
	struct timeval	 last_attached_time;
	struct timeval	 activity_time;
	struct timeval	 last_activity_time;

	struct event	 lock_timer;

	u_int		 sx;
	u_int		 sy;

	struct winlink	*curw;
	struct winlink_stack lastw;
	struct winlinks	 windows;

	int		 statusat;

	struct hooks	*hooks;
	struct options	*options;

#define SESSION_UNATTACHED 0x1	/* not attached to any clients */
#define SESSION_PASTING 0x2
#define SESSION_ALERTED 0x4
	int		 flags;

	u_int		 attached;

	struct termios	*tio;

	struct environ	*environ;

	int		 references;

	TAILQ_ENTRY(session) gentry;
	RB_ENTRY(session)    entry;
};
RB_HEAD(sessions, session);

/* Mouse button masks. */
#define MOUSE_MASK_BUTTONS 3
#define MOUSE_MASK_SHIFT 4
#define MOUSE_MASK_META 8
#define MOUSE_MASK_CTRL 16
#define MOUSE_MASK_DRAG 32
#define MOUSE_MASK_WHEEL 64

/* Mouse wheel states. */
#define MOUSE_WHEEL_UP 0
#define MOUSE_WHEEL_DOWN 64

/* Mouse helpers. */
#define MOUSE_BUTTONS(b) ((b) & MOUSE_MASK_BUTTONS)
#define MOUSE_WHEEL(b) ((b) & MOUSE_MASK_WHEEL)
#define MOUSE_DRAG(b) ((b) & MOUSE_MASK_DRAG)
#define MOUSE_RELEASE(b) (((b) & MOUSE_MASK_BUTTONS) == 3)

/* Mouse input. */
struct mouse_event {
	int		valid;

	key_code	key;
	int		statusat;

	u_int		x;
	u_int		y;
	u_int		b;

	u_int		lx;
	u_int		ly;
	u_int		lb;

	int		s;
	int		w;
	int		wp;

	u_int		sgr_type;
	u_int		sgr_b;
};

/* TTY information. */
struct tty_key {
	char		 ch;
	key_code	 key;

	struct tty_key	*left;
	struct tty_key	*right;

	struct tty_key	*next;
};

struct tty_code;
struct tty_term {
	char		*name;
	u_int		 references;

	char		 acs[UCHAR_MAX + 1][2];

	struct tty_code	*codes;

#define TERM_256COLOURS 0x1
#define TERM_EARLYWRAP 0x2
	int		 flags;

	LIST_ENTRY(tty_term) entry;
};
LIST_HEAD(tty_terms, tty_term);

struct tty {
	struct client	*client;

	u_int		 sx;
	u_int		 sy;

	u_int		 cx;
	u_int		 cy;
	u_int		 cstyle;
	char		*ccolour;

	int		 mode;

	u_int		 rlower;
	u_int		 rupper;

	u_int		 rleft;
	u_int		 rright;

	int		 fd;
	struct event	 event_in;
	struct evbuffer	*in;
	struct event	 event_out;
	struct evbuffer	*out;
	struct event	 timer;
	size_t		 discarded;

	struct termios	 tio;

	struct grid_cell cell;

	int		 last_wp;
	struct grid_cell last_cell;

#define TTY_NOCURSOR 0x1
#define TTY_FREEZE 0x2
#define TTY_TIMER 0x4
#define TTY_UTF8 0x8
#define TTY_STARTED 0x10
#define TTY_OPENED 0x20
#define TTY_FOCUS 0x40
#define TTY_BLOCK 0x80
	int		 flags;

	struct tty_term	*term;
	char		*term_name;
	int		 term_flags;
	enum {
		TTY_VT100,
		TTY_VT101,
		TTY_VT102,
		TTY_VT220,
		TTY_VT320,
		TTY_VT420,
		TTY_UNKNOWN
	} term_type;

	struct mouse_event mouse;
	int		 mouse_drag_flag;
	void		(*mouse_drag_update)(struct client *,
			    struct mouse_event *);
	void		(*mouse_drag_release)(struct client *,
			    struct mouse_event *);

	struct event	 key_timer;
	struct tty_key	*key_tree;
};
#define TTY_TYPES \
	{ "VT100", "VT101", "VT102", "VT220", "VT320", "VT420", "Unknown" }

/* TTY command context. */
struct tty_ctx {
	struct window_pane	*wp;

	const struct grid_cell	*cell;

	u_int		 num;
	void		*ptr;

	/*
	 * Cursor and region position before the screen was updated - this is
	 * where the command should be applied; the values in the screen have
	 * already been updated.
	 */
	u_int		 ocx;
	u_int		 ocy;

	u_int		 orupper;
	u_int		 orlower;

	u_int		 xoff;
	u_int		 yoff;

	/* The background colour used for clearing (erasing). */
	u_int		 bg;
};

/* Saved message entry. */
struct message_entry {
	char	*msg;
	u_int	 msg_num;
	time_t	 msg_time;
	TAILQ_ENTRY(message_entry) entry;
};

/* Parsed arguments structures. */
struct args_entry;
RB_HEAD(args_tree, args_entry);
struct args {
	struct args_tree	  tree;
	int			  argc;
	char			**argv;
};

/* Command find structures. */
enum cmd_find_type {
	CMD_FIND_PANE,
	CMD_FIND_WINDOW,
	CMD_FIND_SESSION,
};
struct cmd_find_state {
	int			 flags;
	struct cmd_find_state	*current;

	struct session		*s;
	struct winlink		*wl;
	struct window		*w;
	struct window_pane	*wp;
	int			 idx;
};

/* Command find flags. */
#define CMD_FIND_PREFER_UNATTACHED 0x1
#define CMD_FIND_QUIET 0x2
#define CMD_FIND_WINDOW_INDEX 0x4
#define CMD_FIND_DEFAULT_MARKED 0x8
#define CMD_FIND_EXACT_SESSION 0x10
#define CMD_FIND_EXACT_WINDOW 0x20
#define CMD_FIND_CANFAIL 0x40

/* Command and list of commands. */
struct cmd {
	const struct cmd_entry	*entry;
	struct args		*args;

	char			*file;
	u_int			 line;

#define CMD_CONTROL 0x1
	int			 flags;

	TAILQ_ENTRY(cmd)	 qentry;
};

struct cmd_list {
	int			 references;
	TAILQ_HEAD(, cmd)	 list;
};

/* Command return values. */
enum cmd_retval {
	CMD_RETURN_ERROR = -1,
	CMD_RETURN_NORMAL = 0,
	CMD_RETURN_WAIT,
	CMD_RETURN_STOP
};

/* Command queue item type. */
enum cmdq_type {
	CMDQ_COMMAND,
	CMDQ_CALLBACK,
};

/* Command queue item shared state. */
struct cmdq_shared {
	int			 references;

	int			 flags;
#define CMDQ_SHARED_REPEAT 0x1

	struct format_tree	*formats;

	struct mouse_event	 mouse;
	struct cmd_find_state	 current;
};

/* Command queue item. */
typedef enum cmd_retval (*cmdq_cb) (struct cmdq_item *, void *);
struct cmdq_item {
	const char		*name;
	struct cmdq_list	*queue;
	struct cmdq_item	*next;

	struct client		*client;

	enum cmdq_type		 type;
	u_int			 group;

	u_int			 number;
	time_t			 time;

	int			 flags;
#define CMDQ_FIRED 0x1
#define CMDQ_WAITING 0x2
#define CMDQ_NOHOOKS 0x4

	struct cmdq_shared	*shared;
	struct cmd_find_state	 source;
	struct cmd_find_state	 target;

	struct cmd_list		*cmdlist;
	struct cmd		*cmd;

	cmdq_cb			 cb;
	void			*data;

	TAILQ_ENTRY(cmdq_item)	 entry;
};
TAILQ_HEAD(cmdq_list, cmdq_item);

/* Command definition flag. */
struct cmd_entry_flag {
	char			 flag;
	enum cmd_find_type	 type;
	int			 flags;
};

/* Command definition. */
struct cmd_entry {
	const char		*name;
	const char		*alias;

	struct {
		const char	*template;
		int		 lower;
		int		 upper;
	} args;
	const char		*usage;

	struct cmd_entry_flag	 source;
	struct cmd_entry_flag	 target;

#define CMD_STARTSERVER 0x1
#define CMD_READONLY 0x2
#define CMD_AFTERHOOK 0x4
	int		 flags;

	enum cmd_retval	 (*exec)(struct cmd *, struct cmdq_item *);
};

/* Client connection. */
struct client {
	const char	*name;
	struct tmuxpeer	*peer;
	struct cmdq_list queue;

	pid_t		 pid;
	int		 fd;
	struct event	 event;
	int		 retval;

	struct timeval	 creation_time;
	struct timeval	 activity_time;

	struct environ	*environ;

	char		*title;
	const char	*cwd;

	char		*term;
	char		*ttyname;
	struct tty	 tty;

	size_t		 written;
	size_t		 discarded;

	void		(*stdin_callback)(struct client *, int, void *);
	void		*stdin_callback_data;
	struct evbuffer	*stdin_data;
	int		 stdin_closed;
	struct evbuffer	*stdout_data;
	struct evbuffer	*stderr_data;

	struct event	 repeat_timer;

	struct event	 click_timer;
	u_int		 click_button;

	struct event	 status_timer;
	struct screen	 status;

#define CLIENT_TERMINAL 0x1
#define CLIENT_LOGIN 0x2
#define CLIENT_EXIT 0x4
#define CLIENT_REDRAW 0x8
#define CLIENT_STATUS 0x10
#define CLIENT_REPEAT 0x20
#define CLIENT_SUSPENDED 0x40
#define CLIENT_ATTACHED 0x80
#define CLIENT_IDENTIFY 0x100
#define CLIENT_DEAD 0x200
#define CLIENT_BORDERS 0x400
#define CLIENT_READONLY 0x800
#define CLIENT_DETACHING 0x1000
#define CLIENT_CONTROL 0x2000
#define CLIENT_CONTROLCONTROL 0x4000
#define CLIENT_FOCUSED 0x8000
#define CLIENT_UTF8 0x10000
#define CLIENT_256COLOURS 0x20000
#define CLIENT_IDENTIFIED 0x40000
#define CLIENT_STATUSFORCE 0x80000
#define CLIENT_DOUBLECLICK 0x100000
#define CLIENT_TRIPLECLICK 0x200000
	int		 flags;
	struct key_table *keytable;

	struct event	 identify_timer;
	void		(*identify_callback)(struct client *, struct window_pane *);
	void		*identify_callback_data;

	char		*message_string;
	struct event	 message_timer;
	u_int		 message_next;
	TAILQ_HEAD(, message_entry) message_log;

	char		*prompt_string;
	struct utf8_data *prompt_buffer;
	size_t		 prompt_index;
	int		 (*prompt_callbackfn)(void *, const char *, int);
	void		 (*prompt_freefn)(void *);
	void		*prompt_data;
	u_int		 prompt_hindex;
	enum { PROMPT_ENTRY, PROMPT_COMMAND } prompt_mode;

#define PROMPT_SINGLE 0x1
#define PROMPT_NUMERIC 0x2
#define PROMPT_INCREMENTAL 0x4
	int		 prompt_flags;

	struct session	*session;
	struct session	*last_session;

	int		 wlmouse;

	int		 references;

	TAILQ_ENTRY(client) entry;
};
TAILQ_HEAD(clients, client);

/* Key binding and key table. */
struct key_binding {
	key_code		 key;
	struct cmd_list		*cmdlist;

	int			 flags;
#define KEY_BINDING_REPEAT 0x1

	RB_ENTRY(key_binding)	 entry;
};
RB_HEAD(key_bindings, key_binding);

struct key_table {
	const char		 *name;
	struct key_bindings	 key_bindings;

	u_int			 references;

	RB_ENTRY(key_table)	 entry;
};
RB_HEAD(key_tables, key_table);

/* Option table entries. */
enum options_table_type {
	OPTIONS_TABLE_STRING,
	OPTIONS_TABLE_NUMBER,
	OPTIONS_TABLE_KEY,
	OPTIONS_TABLE_COLOUR,
	OPTIONS_TABLE_ATTRIBUTES,
	OPTIONS_TABLE_FLAG,
	OPTIONS_TABLE_CHOICE,
	OPTIONS_TABLE_STYLE,
	OPTIONS_TABLE_ARRAY,
};
enum options_table_scope {
	OPTIONS_TABLE_NONE,
	OPTIONS_TABLE_SERVER,
	OPTIONS_TABLE_SESSION,
	OPTIONS_TABLE_WINDOW,
};

struct options_table_entry {
	const char		 *name;
	enum options_table_type	  type;
	enum options_table_scope  scope;

	u_int			  minimum;
	u_int			  maximum;
	const char		**choices;

	const char		 *default_str;
	long long		  default_num;

	const char		 *separator;
	const char		 *style;
};

/* Common command usages. */
#define CMD_TARGET_PANE_USAGE "[-t target-pane]"
#define CMD_TARGET_WINDOW_USAGE "[-t target-window]"
#define CMD_TARGET_SESSION_USAGE "[-t target-session]"
#define CMD_TARGET_CLIENT_USAGE "[-t target-client]"
#define CMD_SRCDST_PANE_USAGE "[-s src-pane] [-t dst-pane]"
#define CMD_SRCDST_WINDOW_USAGE "[-s src-window] [-t dst-window]"
#define CMD_SRCDST_SESSION_USAGE "[-s src-session] [-t dst-session]"
#define CMD_SRCDST_CLIENT_USAGE "[-s src-client] [-t dst-client]"
#define CMD_BUFFER_USAGE "[-b buffer-name]"

/* tmux.c */
extern struct hooks	*global_hooks;
extern struct options	*global_options;
extern struct options	*global_s_options;
extern struct options	*global_w_options;
extern struct environ	*global_environ;
extern struct timeval	 start_time;
extern const char	*socket_path;
extern int		 ptm_fd;
int		 areshell(const char *);
void		 setblocking(int, int);
const char	*find_home(void);

/* proc.c */
struct imsg;
int	proc_send(struct tmuxpeer *, enum msgtype, int, const void *, size_t);
int	proc_send_s(struct tmuxpeer *, enum msgtype, const char *);
struct tmuxproc *proc_start(const char *, struct event_base *, int,
	    void (*)(int));
void	proc_loop(struct tmuxproc *, int (*)(void));
void	proc_exit(struct tmuxproc *);
struct tmuxpeer *proc_add_peer(struct tmuxproc *, int,
	    void (*)(struct imsg *, void *), void *);
void	proc_remove_peer(struct tmuxpeer *);
void	proc_kill_peer(struct tmuxpeer *);

/* cfg.c */
extern int cfg_finished;
extern struct client *cfg_client;
void	start_cfg(void);
int	load_cfg(const char *, struct client *, struct cmdq_item *, int);
void	set_cfg_file(const char *);
void printflike(1, 2) cfg_add_cause(const char *, ...);
void	cfg_print_causes(struct cmdq_item *);
void	cfg_show_causes(struct session *);

/* paste.c */
struct paste_buffer;
const char	*paste_buffer_name(struct paste_buffer *);
u_int		 paste_buffer_order(struct paste_buffer *);
time_t		 paste_buffer_created(struct paste_buffer *);
const char	*paste_buffer_data(struct paste_buffer *, size_t *);
struct paste_buffer *paste_walk(struct paste_buffer *);
struct paste_buffer *paste_get_top(const char **);
struct paste_buffer *paste_get_name(const char *);
void		 paste_free(struct paste_buffer *);
void		 paste_add(char *, size_t);
int		 paste_rename(const char *, const char *, char **);
int		 paste_set(char *, size_t, const char *, char **);
char		*paste_make_sample(struct paste_buffer *);

/* format.c */
#define FORMAT_STATUS 0x1
#define FORMAT_FORCE 0x2
#define FORMAT_NOJOBS 0x4
#define FORMAT_NONE 0
#define FORMAT_PANE 0x80000000U
#define FORMAT_WINDOW 0x40000000U
struct format_tree;
struct format_tree *format_create(struct cmdq_item *, int, int);
void		 format_free(struct format_tree *);
void printflike(3, 4) format_add(struct format_tree *, const char *,
		     const char *, ...);
char		*format_expand_time(struct format_tree *, const char *, time_t);
char		*format_expand(struct format_tree *, const char *);
char		*format_single(struct cmdq_item *, const char *,
		     struct client *, struct session *, struct winlink *,
		     struct window_pane *);
void		 format_defaults(struct format_tree *, struct client *,
		     struct session *, struct winlink *, struct window_pane *);
void		 format_defaults_window(struct format_tree *, struct window *);
void		 format_defaults_pane(struct format_tree *,
		     struct window_pane *);
void		 format_defaults_paste_buffer(struct format_tree *,
		     struct paste_buffer *);

/* hooks.c */
struct hook;
struct hooks	*hooks_get(struct session *);
struct hooks	*hooks_create(struct hooks *);
void		 hooks_free(struct hooks *);
struct hook	*hooks_first(struct hooks *);
struct hook	*hooks_next(struct hook *);
void		 hooks_add(struct hooks *, const char *, struct cmd_list *);
void		 hooks_copy(struct hooks *, struct hooks *);
void		 hooks_remove(struct hooks *, const char *);
struct hook	*hooks_find(struct hooks *, const char *);
void printflike(4, 5) hooks_run(struct hooks *, struct client *,
		    struct cmd_find_state *, const char *, ...);
void printflike(4, 5) hooks_insert(struct hooks *, struct cmdq_item *,
		    struct cmd_find_state *, const char *, ...);

/* notify.c */
void	notify_input(struct window_pane *, struct evbuffer *);
void	notify_client(const char *, struct client *);
void	notify_session(const char *, struct session *);
void	notify_winlink(const char *, struct winlink *);
void	notify_session_window(const char *, struct session *, struct window *);
void	notify_window(const char *, struct window *);
void	notify_pane(const char *, struct window_pane *);

/* options.c */
struct options	*options_create(struct options *);
void		 options_free(struct options *);
struct options_entry *options_first(struct options *);
struct options_entry *options_next(struct options_entry *);
struct options_entry *options_empty(struct options *,
		     const struct options_table_entry *);
struct options_entry *options_default(struct options *,
		     const struct options_table_entry *);
const char	*options_name(struct options_entry *);
const struct options_table_entry *options_table_entry(struct options_entry *);
struct options_entry *options_get_only(struct options *, const char *);
struct options_entry *options_get(struct options *, const char *);
void		 options_remove(struct options_entry *);
void		 options_array_clear(struct options_entry *);
const char	*options_array_get(struct options_entry *, u_int);
int		 options_array_set(struct options_entry *, u_int, const char *,
		     int);
int		 options_array_size(struct options_entry *, u_int *);
void		 options_array_assign(struct options_entry *, const char *);
int		 options_isstring(struct options_entry *);
const char	*options_tostring(struct options_entry *, int, int);
char		*options_parse(const char *, int *);
struct options_entry *options_parse_get(struct options *, const char *, int *,
		     int);
char		*options_match(const char *, int *, int *);
struct options_entry *options_match_get(struct options *, const char *, int *,
		     int, int *);
const char	*options_get_string(struct options *, const char *);
long long	 options_get_number(struct options *, const char *);
const struct grid_cell *options_get_style(struct options *, const char *);
struct options_entry * printflike(4, 5) options_set_string(struct options *,
		     const char *, int, const char *, ...);
struct options_entry *options_set_number(struct options *, const char *,
		     long long);
struct options_entry *options_set_style(struct options *, const char *, int,
		     const char *);
enum options_table_scope options_scope_from_flags(struct args *, int,
		     struct cmd_find_state *, struct options **, char **);
void		 options_style_update_new(struct options *,
		     struct options_entry *);
void		 options_style_update_old(struct options *,
		     struct options_entry *);

/* options-table.c */
extern const struct options_table_entry options_table[];

/* job.c */
extern struct joblist all_jobs;
struct job	*job_run(const char *, struct session *, const char *,
		     job_update_cb, job_complete_cb, job_free_cb, void *);
void		 job_free(struct job *);
void		 job_died(struct job *, int);

/* environ.c */
struct environ *environ_create(void);
void	environ_free(struct environ *);
struct environ_entry *environ_first(struct environ *);
struct environ_entry *environ_next(struct environ_entry *);
void	environ_copy(struct environ *, struct environ *);
struct environ_entry *environ_find(struct environ *, const char *);
void printflike(3, 4) environ_set(struct environ *, const char *, const char *,
	    ...);
void	environ_clear(struct environ *, const char *);
void	environ_put(struct environ *, const char *);
void	environ_unset(struct environ *, const char *);
void	environ_update(struct options *, struct environ *, struct environ *);
void	environ_push(struct environ *);
void	environ_log(struct environ *, const char *);
struct environ *environ_for_session(struct session *);

/* tty.c */
void	tty_create_log(void);
void	tty_raw(struct tty *, const char *);
void	tty_attributes(struct tty *, const struct grid_cell *,
	    const struct window_pane *);
void	tty_reset(struct tty *);
void	tty_region_off(struct tty *);
void	tty_margin_off(struct tty *);
void	tty_cursor(struct tty *, u_int, u_int);
void	tty_putcode(struct tty *, enum tty_code_code);
void	tty_putcode1(struct tty *, enum tty_code_code, int);
void	tty_putcode2(struct tty *, enum tty_code_code, int, int);
void	tty_putcode_ptr1(struct tty *, enum tty_code_code, const void *);
void	tty_putcode_ptr2(struct tty *, enum tty_code_code, const void *,
	    const void *);
void	tty_puts(struct tty *, const char *);
void	tty_putc(struct tty *, u_char);
void	tty_putn(struct tty *, const void *, size_t, u_int);
int	tty_init(struct tty *, struct client *, int, char *);
int	tty_resize(struct tty *);
int	tty_set_size(struct tty *, u_int, u_int);
void	tty_start_tty(struct tty *);
void	tty_stop_tty(struct tty *);
void	tty_set_title(struct tty *, const char *);
void	tty_update_mode(struct tty *, int, struct screen *);
void	tty_draw_pane(struct tty *, const struct window_pane *, u_int, u_int,
	    u_int);
void	tty_draw_line(struct tty *, const struct window_pane *, struct screen *,
	    u_int, u_int, u_int);
int	tty_open(struct tty *, char **);
void	tty_close(struct tty *);
void	tty_free(struct tty *);
void	tty_set_type(struct tty *, int);
void	tty_write(void (*)(struct tty *, const struct tty_ctx *),
	    struct tty_ctx *);
void	tty_cmd_alignmenttest(struct tty *, const struct tty_ctx *);
void	tty_cmd_cell(struct tty *, const struct tty_ctx *);
void	tty_cmd_cells(struct tty *, const struct tty_ctx *);
void	tty_cmd_clearendofline(struct tty *, const struct tty_ctx *);
void	tty_cmd_clearendofscreen(struct tty *, const struct tty_ctx *);
void	tty_cmd_clearline(struct tty *, const struct tty_ctx *);
void	tty_cmd_clearscreen(struct tty *, const struct tty_ctx *);
void	tty_cmd_clearstartofline(struct tty *, const struct tty_ctx *);
void	tty_cmd_clearstartofscreen(struct tty *, const struct tty_ctx *);
void	tty_cmd_deletecharacter(struct tty *, const struct tty_ctx *);
void	tty_cmd_clearcharacter(struct tty *, const struct tty_ctx *);
void	tty_cmd_deleteline(struct tty *, const struct tty_ctx *);
void	tty_cmd_erasecharacter(struct tty *, const struct tty_ctx *);
void	tty_cmd_insertcharacter(struct tty *, const struct tty_ctx *);
void	tty_cmd_insertline(struct tty *, const struct tty_ctx *);
void	tty_cmd_linefeed(struct tty *, const struct tty_ctx *);
void	tty_cmd_scrollup(struct tty *, const struct tty_ctx *);
void	tty_cmd_reverseindex(struct tty *, const struct tty_ctx *);
void	tty_cmd_setselection(struct tty *, const struct tty_ctx *);
void	tty_cmd_rawstring(struct tty *, const struct tty_ctx *);

/* tty-term.c */
extern struct tty_terms tty_terms;
u_int		 tty_term_ncodes(void);
struct tty_term *tty_term_find(char *, int, char **);
void		 tty_term_free(struct tty_term *);
int		 tty_term_has(struct tty_term *, enum tty_code_code);
const char	*tty_term_string(struct tty_term *, enum tty_code_code);
const char	*tty_term_string1(struct tty_term *, enum tty_code_code, int);
const char	*tty_term_string2(struct tty_term *, enum tty_code_code, int,
		     int);
const char	*tty_term_ptr1(struct tty_term *, enum tty_code_code,
		     const void *);
const char	*tty_term_ptr2(struct tty_term *, enum tty_code_code,
		     const void *, const void *);
int		 tty_term_number(struct tty_term *, enum tty_code_code);
int		 tty_term_flag(struct tty_term *, enum tty_code_code);
const char	*tty_term_describe(struct tty_term *, enum tty_code_code);

/* tty-acs.c */
const char	*tty_acs_get(struct tty *, u_char);

/* tty-keys.c */
void		tty_keys_build(struct tty *);
void		tty_keys_free(struct tty *);
key_code	tty_keys_next(struct tty *);

/* arguments.c */
struct args	*args_parse(const char *, int, char **);
void		 args_free(struct args *);
char		*args_print(struct args *);
int		 args_has(struct args *, u_char);
const char	*args_get(struct args *, u_char);
long long	 args_strtonum(struct args *, u_char, long long, long long,
		     char **);

/* cmd-find.c */
int		 cmd_find_target(struct cmd_find_state *, struct cmdq_item *,
		     const char *, enum cmd_find_type, int);
struct client	*cmd_find_client(struct cmdq_item *, const char *, int);
void		 cmd_find_clear_state(struct cmd_find_state *, int);
int		 cmd_find_empty_state(struct cmd_find_state *);
int		 cmd_find_valid_state(struct cmd_find_state *);
void		 cmd_find_copy_state(struct cmd_find_state *,
		     struct cmd_find_state *);
void		 cmd_find_log_state(const char *, struct cmd_find_state *);
void		 cmd_find_from_session(struct cmd_find_state *,
		     struct session *);
void		 cmd_find_from_winlink(struct cmd_find_state *,
		     struct winlink *);
int		 cmd_find_from_session_window(struct cmd_find_state *,
		     struct session *, struct window *);
int		 cmd_find_from_window(struct cmd_find_state *, struct window *);
void		 cmd_find_from_winlink_pane(struct cmd_find_state *,
		     struct winlink *, struct window_pane *);
int		 cmd_find_from_pane(struct cmd_find_state *,
		     struct window_pane *);
int		 cmd_find_from_client(struct cmd_find_state *, struct client *);
int		 cmd_find_from_mouse(struct cmd_find_state *,
		     struct mouse_event *);
int		 cmd_find_from_nothing(struct cmd_find_state *);

/* cmd.c */
int		 cmd_pack_argv(int, char **, char *, size_t);
int		 cmd_unpack_argv(char *, size_t, int, char ***);
char	       **cmd_copy_argv(int, char **);
void		 cmd_free_argv(int, char **);
char		*cmd_stringify_argv(int, char **);
struct cmd	*cmd_parse(int, char **, const char *, u_int, char **);
char		*cmd_print(struct cmd *);
int		 cmd_mouse_at(struct window_pane *, struct mouse_event *,
		     u_int *, u_int *, int);
struct winlink	*cmd_mouse_window(struct mouse_event *, struct session **);
struct window_pane *cmd_mouse_pane(struct mouse_event *, struct session **,
		     struct winlink **);
char		*cmd_template_replace(const char *, const char *, int);
extern const struct cmd_entry *cmd_table[];

/* cmd-attach-session.c */
enum cmd_retval	 cmd_attach_session(struct cmdq_item *, const char *, int, int,
		     const char *, int);

/* cmd-list.c */
struct cmd_list	*cmd_list_parse(int, char **, const char *, u_int, char **);
void		 cmd_list_free(struct cmd_list *);
char		*cmd_list_print(struct cmd_list *);

/* cmd-queue.c */
struct cmdq_item *cmdq_get_command(struct cmd_list *, struct cmd_find_state *,
		     struct mouse_event *, int);
#define cmdq_get_callback(cb, data) cmdq_get_callback1(#cb, cb, data)
struct cmdq_item *cmdq_get_callback1(const char *, cmdq_cb, void *);
void		 cmdq_insert_after(struct cmdq_item *, struct cmdq_item *);
void		 cmdq_append(struct client *, struct cmdq_item *);
void printflike(3, 4) cmdq_format(struct cmdq_item *, const char *,
		     const char *, ...);
u_int		 cmdq_next(struct client *);
void		 cmdq_guard(struct cmdq_item *, const char *, int);
void printflike(2, 3) cmdq_print(struct cmdq_item *, const char *, ...);
void printflike(2, 3) cmdq_error(struct cmdq_item *, const char *, ...);

/* cmd-string.c */
int		 cmd_string_split(const char *, int *, char ***);
struct cmd_list	*cmd_string_parse(const char *, const char *, u_int, char **);

/* cmd-wait-for.c */
void	cmd_wait_for_flush(void);

/* client.c */
int	client_main(struct event_base *, int, char **, int, const char *);

/* key-bindings.c */
RB_PROTOTYPE(key_bindings, key_binding, entry, key_bindings_cmp);
RB_PROTOTYPE(key_tables, key_table, entry, key_table_cmp);
extern struct key_tables key_tables;
int	 key_table_cmp(struct key_table *, struct key_table *);
int	 key_bindings_cmp(struct key_binding *, struct key_binding *);
struct key_table *key_bindings_get_table(const char *, int);
void	 key_bindings_unref_table(struct key_table *);
void	 key_bindings_add(const char *, key_code, int, struct cmd_list *);
void	 key_bindings_remove(const char *, key_code);
void	 key_bindings_remove_table(const char *);
void	 key_bindings_init(void);
void	 key_bindings_dispatch(struct key_binding *, struct client *,
	     struct mouse_event *, struct cmd_find_state *);

/* key-string.c */
key_code	 key_string_lookup_string(const char *);
const char	*key_string_lookup_key(key_code);

/* alerts.c */
void	alerts_reset_all(void);
void	alerts_queue(struct window *, int);
void	alerts_check_session(struct session *);

/* server.c */
extern struct tmuxproc *server_proc;
extern struct clients clients;
extern struct cmd_find_state marked_pane;
void	 server_set_marked(struct session *, struct winlink *,
	     struct window_pane *);
void	 server_clear_marked(void);
int	 server_is_marked(struct session *, struct winlink *,
	     struct window_pane *);
int	 server_check_marked(void);
int	 server_start(struct event_base *, int, char *);
void	 server_update_socket(void);
void	 server_add_accept(int);

/* server-client.c */
void	 server_client_set_identify(struct client *);
void	 server_client_clear_identify(struct client *, struct window_pane *);
void	 server_client_set_key_table(struct client *, const char *);
const char *server_client_get_key_table(struct client *);
int	 server_client_check_nested(struct client *);
void	 server_client_handle_key(struct client *, key_code);
void	 server_client_create(int);
int	 server_client_open(struct client *, char **);
void	 server_client_unref(struct client *);
void	 server_client_lost(struct client *);
void	 server_client_suspend(struct client *);
void	 server_client_detach(struct client *, enum msgtype);
void	 server_client_exec(struct client *, const char *);
void	 server_client_loop(void);
void	 server_client_push_stdout(struct client *);
void	 server_client_push_stderr(struct client *);
void printflike(2, 3) server_client_add_message(struct client *, const char *,
	     ...);
char	*server_client_get_path(struct client *, const char *);
const char *server_client_get_cwd(struct client *);

/* server-fn.c */
void	 server_redraw_client(struct client *);
void	 server_status_client(struct client *);
void	 server_redraw_session(struct session *);
void	 server_redraw_session_group(struct session *);
void	 server_status_session(struct session *);
void	 server_status_session_group(struct session *);
void	 server_redraw_window(struct window *);
void	 server_redraw_window_borders(struct window *);
void	 server_status_window(struct window *);
void	 server_lock(void);
void	 server_lock_session(struct session *);
void	 server_lock_client(struct client *);
void	 server_kill_window(struct window *);
int	 server_link_window(struct session *,
	     struct winlink *, struct session *, int, int, int, char **);
void	 server_unlink_window(struct session *, struct winlink *);
void	 server_destroy_pane(struct window_pane *, int);
void	 server_destroy_session(struct session *);
void	 server_check_unattached(void);
int	 server_set_stdin_callback(struct client *, void (*)(struct client *,
	     int, void *), void *, char **);
void	 server_unzoom_window(struct window *);

/* status.c */
void	 status_timer_start(struct client *);
void	 status_timer_start_all(void);
void	 status_update_saved(struct session *s);
int	 status_at_line(struct client *);
struct window *status_get_window_at(struct client *, u_int);
int	 status_redraw(struct client *);
void printflike(2, 3) status_message_set(struct client *, const char *, ...);
void	 status_message_clear(struct client *);
int	 status_message_redraw(struct client *);
void	 status_prompt_set(struct client *, const char *, const char *,
	     int (*)(void *, const char *, int), void (*)(void *), void *, int);
void	 status_prompt_clear(struct client *);
int	 status_prompt_redraw(struct client *);
int	 status_prompt_key(struct client *, key_code);
void	 status_prompt_update(struct client *, const char *, const char *);
void	 status_prompt_load_history(void);
void	 status_prompt_save_history(void);

/* resize.c */
void	 recalculate_sizes(void);

/* input.c */
void	 input_init(struct window_pane *);
void	 input_free(struct window_pane *);
void	 input_reset(struct window_pane *, int);
struct evbuffer *input_pending(struct window_pane *);
void	 input_parse(struct window_pane *);

/* input-key.c */
void	 input_key(struct window_pane *, key_code, struct mouse_event *);

/* xterm-keys.c */
char	*xterm_keys_lookup(key_code);
int	 xterm_keys_find(const char *, size_t, size_t *, key_code *);

/* colour.c */
int	 colour_find_rgb(u_char, u_char, u_char);
int	 colour_join_rgb(u_char, u_char, u_char);
void	 colour_split_rgb(int, u_char *, u_char *, u_char *);
const char *colour_tostring(int);
int	 colour_fromstring(const char *s);
u_char	 colour_256to16(u_char);

/* attributes.c */
const char *attributes_tostring(int);
int	 attributes_fromstring(const char *);

/* grid.c */
extern const struct grid_cell grid_default_cell;
int	 grid_cells_equal(const struct grid_cell *, const struct grid_cell *);
struct grid *grid_create(u_int, u_int, u_int);
void	 grid_destroy(struct grid *);
int	 grid_compare(struct grid *, struct grid *);
void	 grid_collect_history(struct grid *, u_int);
void	 grid_scroll_history(struct grid *, u_int);
void	 grid_scroll_history_region(struct grid *, u_int, u_int);
void	 grid_clear_history(struct grid *);
const struct grid_line *grid_peek_line(struct grid *, u_int);
void	 grid_get_cell(struct grid *, u_int, u_int, struct grid_cell *);
void	 grid_set_cell(struct grid *, u_int, u_int, const struct grid_cell *);
void	 grid_set_cells(struct grid *, u_int, u_int, const struct grid_cell *,
	     const char *, size_t);
void	 grid_clear(struct grid *, u_int, u_int, u_int, u_int, u_int);
void	 grid_clear_lines(struct grid *, u_int, u_int, u_int);
void	 grid_move_lines(struct grid *, u_int, u_int, u_int, u_int);
void	 grid_move_cells(struct grid *, u_int, u_int, u_int, u_int, u_int);
char	*grid_string_cells(struct grid *, u_int, u_int, u_int,
	     struct grid_cell **, int, int, int);
void	 grid_duplicate_lines(struct grid *, u_int, struct grid *, u_int,
	     u_int);
u_int	 grid_reflow(struct grid *, struct grid *, u_int);

/* grid-view.c */
void	 grid_view_get_cell(struct grid *, u_int, u_int, struct grid_cell *);
void	 grid_view_set_cell(struct grid *, u_int, u_int,
	     const struct grid_cell *);
void	 grid_view_set_cells(struct grid *, u_int, u_int,
	     const struct grid_cell *, const char *, size_t);
void	 grid_view_clear_history(struct grid *, u_int);
void	 grid_view_clear(struct grid *, u_int, u_int, u_int, u_int, u_int);
void	 grid_view_scroll_region_up(struct grid *, u_int, u_int);
void	 grid_view_scroll_region_down(struct grid *, u_int, u_int);
void	 grid_view_insert_lines(struct grid *, u_int, u_int, u_int);
void	 grid_view_insert_lines_region(struct grid *, u_int, u_int, u_int,
	u_int);
void	 grid_view_delete_lines(struct grid *, u_int, u_int, u_int);
void	 grid_view_delete_lines_region(struct grid *, u_int, u_int, u_int,
	u_int);
void	 grid_view_insert_cells(struct grid *, u_int, u_int, u_int, u_int);
void	 grid_view_delete_cells(struct grid *, u_int, u_int, u_int, u_int);
char	*grid_view_string_cells(struct grid *, u_int, u_int, u_int);

/* screen-write.c */
void	 screen_write_start(struct screen_write_ctx *, struct window_pane *,
	     struct screen *);
void	 screen_write_stop(struct screen_write_ctx *);
void	 screen_write_reset(struct screen_write_ctx *);
size_t printflike(1, 2) screen_write_cstrlen(const char *, ...);
void printflike(4, 5) screen_write_cnputs(struct screen_write_ctx *,
	     ssize_t, const struct grid_cell *, const char *, ...);
size_t printflike(1, 2) screen_write_strlen(const char *, ...);
void printflike(3, 4) screen_write_puts(struct screen_write_ctx *,
	     const struct grid_cell *, const char *, ...);
void printflike(4, 5) screen_write_nputs(struct screen_write_ctx *,
	     ssize_t, const struct grid_cell *, const char *, ...);
void	 screen_write_vnputs(struct screen_write_ctx *, ssize_t,
	     const struct grid_cell *, const char *, va_list);
void	 screen_write_putc(struct screen_write_ctx *, const struct grid_cell *,
	     u_char);
void	 screen_write_copy(struct screen_write_ctx *, struct screen *, u_int,
	     u_int, u_int, u_int, bitstr_t *, const struct grid_cell *);
void	 screen_write_backspace(struct screen_write_ctx *);
void	 screen_write_mode_set(struct screen_write_ctx *, int);
void	 screen_write_mode_clear(struct screen_write_ctx *, int);
void	 screen_write_cursorup(struct screen_write_ctx *, u_int);
void	 screen_write_cursordown(struct screen_write_ctx *, u_int);
void	 screen_write_cursorright(struct screen_write_ctx *, u_int);
void	 screen_write_cursorleft(struct screen_write_ctx *, u_int);
void	 screen_write_alignmenttest(struct screen_write_ctx *);
void	 screen_write_insertcharacter(struct screen_write_ctx *, u_int, u_int);
void	 screen_write_deletecharacter(struct screen_write_ctx *, u_int, u_int);
void	 screen_write_clearcharacter(struct screen_write_ctx *, u_int);
void	 screen_write_insertline(struct screen_write_ctx *, u_int, u_int);
void	 screen_write_deleteline(struct screen_write_ctx *, u_int, u_int);
void	 screen_write_clearline(struct screen_write_ctx *, u_int);
void	 screen_write_clearendofline(struct screen_write_ctx *, u_int);
void	 screen_write_clearstartofline(struct screen_write_ctx *, u_int);
void	 screen_write_cursormove(struct screen_write_ctx *, u_int, u_int);
void	 screen_write_reverseindex(struct screen_write_ctx *);
void	 screen_write_scrollregion(struct screen_write_ctx *, u_int, u_int);
void	 screen_write_linefeed(struct screen_write_ctx *, int);
void	 screen_write_scrollup(struct screen_write_ctx *, u_int);
void	 screen_write_carriagereturn(struct screen_write_ctx *);
void	 screen_write_clearendofscreen(struct screen_write_ctx *, u_int);
void	 screen_write_clearstartofscreen(struct screen_write_ctx *, u_int);
void	 screen_write_clearscreen(struct screen_write_ctx *, u_int);
void	 screen_write_clearhistory(struct screen_write_ctx *);
void	 screen_write_collect_end(struct screen_write_ctx *);
void	 screen_write_collect_add(struct screen_write_ctx *,
	     const struct grid_cell *);
void	 screen_write_cell(struct screen_write_ctx *, const struct grid_cell *);
void	 screen_write_setselection(struct screen_write_ctx *, u_char *, u_int);
void	 screen_write_rawstring(struct screen_write_ctx *, u_char *, u_int);

/* screen-redraw.c */
void	 screen_redraw_update(struct client *);
void	 screen_redraw_screen(struct client *, int, int, int);
void	 screen_redraw_pane(struct client *, struct window_pane *);

/* screen.c */
void	 screen_init(struct screen *, u_int, u_int, u_int);
void	 screen_reinit(struct screen *);
void	 screen_free(struct screen *);
void	 screen_reset_tabs(struct screen *);
void	 screen_set_cursor_style(struct screen *, u_int);
void	 screen_set_cursor_colour(struct screen *, const char *);
void	 screen_set_title(struct screen *, const char *);
void	 screen_resize(struct screen *, u_int, u_int, int);
void	 screen_set_selection(struct screen *,
	     u_int, u_int, u_int, u_int, u_int, struct grid_cell *);
void	 screen_clear_selection(struct screen *);
void	 screen_hide_selection(struct screen *);
int	 screen_check_selection(struct screen *, u_int, u_int);
void	 screen_select_cell(struct screen *, struct grid_cell *,
	     const struct grid_cell *);

/* window.c */
extern struct windows windows;
extern struct window_pane_tree all_window_panes;
int		 window_cmp(struct window *, struct window *);
RB_PROTOTYPE(windows, window, entry, window_cmp);
int		 winlink_cmp(struct winlink *, struct winlink *);
RB_PROTOTYPE(winlinks, winlink, entry, winlink_cmp);
int		 window_pane_cmp(struct window_pane *, struct window_pane *);
RB_PROTOTYPE(window_pane_tree, window_pane, tree_entry, window_pane_cmp);
struct winlink	*winlink_find_by_index(struct winlinks *, int);
struct winlink	*winlink_find_by_window(struct winlinks *, struct window *);
struct winlink	*winlink_find_by_window_id(struct winlinks *, u_int);
u_int		 winlink_count(struct winlinks *);
struct winlink	*winlink_add(struct winlinks *, int);
void		 winlink_set_window(struct winlink *, struct window *);
void		 winlink_remove(struct winlinks *, struct winlink *);
struct winlink	*winlink_next(struct winlink *);
struct winlink	*winlink_previous(struct winlink *);
struct winlink	*winlink_next_by_number(struct winlink *, struct session *,
		     int);
struct winlink	*winlink_previous_by_number(struct winlink *, struct session *,
		     int);
void		 winlink_stack_push(struct winlink_stack *, struct winlink *);
void		 winlink_stack_remove(struct winlink_stack *, struct winlink *);
struct window	*window_find_by_id_str(const char *);
struct window	*window_find_by_id(u_int);
void		 window_update_activity(struct window *);
struct window	*window_create(u_int, u_int);
struct window	*window_create_spawn(const char *, int, char **, const char *,
		     const char *, const char *, struct environ *,
		     struct termios *, u_int, u_int, u_int, char **);
struct window_pane *window_get_active_at(struct window *, u_int, u_int);
struct window_pane *window_find_string(struct window *, const char *);
int		 window_has_pane(struct window *, struct window_pane *);
int		 window_set_active_pane(struct window *, struct window_pane *);
void		 window_redraw_active_switch(struct window *,
		     struct window_pane *);
struct window_pane *window_add_pane(struct window *, struct window_pane *,
		     int, u_int);
void		 window_resize(struct window *, u_int, u_int);
int		 window_zoom(struct window_pane *);
int		 window_unzoom(struct window *);
void		 window_lost_pane(struct window *, struct window_pane *);
void		 window_remove_pane(struct window *, struct window_pane *);
struct window_pane *window_pane_at_index(struct window *, u_int);
struct window_pane *window_pane_next_by_number(struct window *,
			struct window_pane *, u_int);
struct window_pane *window_pane_previous_by_number(struct window *,
			struct window_pane *, u_int);
int		 window_pane_index(struct window_pane *, u_int *);
u_int		 window_count_panes(struct window *);
void		 window_destroy_panes(struct window *);
struct window_pane *window_pane_find_by_id_str(const char *);
struct window_pane *window_pane_find_by_id(u_int);
int		 window_pane_spawn(struct window_pane *, int, char **,
		     const char *, const char *, const char *, struct environ *,
		     struct termios *, char **);
void		 window_pane_resize(struct window_pane *, u_int, u_int);
void		 window_pane_alternate_on(struct window_pane *,
		     struct grid_cell *, int);
void		 window_pane_alternate_off(struct window_pane *,
		     struct grid_cell *, int);
void		 window_pane_set_palette(struct window_pane *, u_int, int);
void		 window_pane_unset_palette(struct window_pane *, u_int);
void		 window_pane_reset_palette(struct window_pane *);
int		 window_pane_get_palette(const struct window_pane *, int);
int		 window_pane_set_mode(struct window_pane *,
		     const struct window_mode *);
void		 window_pane_reset_mode(struct window_pane *);
void		 window_pane_key(struct window_pane *, struct client *,
		     struct session *, key_code, struct mouse_event *);
int		 window_pane_outside(struct window_pane *);
int		 window_pane_visible(struct window_pane *);
char		*window_pane_search(struct window_pane *, const char *,
		     u_int *);
const char	*window_printable_flags(struct winlink *);
struct window_pane *window_pane_find_up(struct window_pane *);
struct window_pane *window_pane_find_down(struct window_pane *);
struct window_pane *window_pane_find_left(struct window_pane *);
struct window_pane *window_pane_find_right(struct window_pane *);
void		 window_set_name(struct window *, const char *);
void		 window_remove_ref(struct window *);
void		 winlink_clear_flags(struct winlink *);
int		 winlink_shuffle_up(struct session *, struct winlink *);

/* layout.c */
u_int		 layout_count_cells(struct layout_cell *);
struct layout_cell *layout_create_cell(struct layout_cell *);
void		 layout_free_cell(struct layout_cell *);
void		 layout_print_cell(struct layout_cell *, const char *, u_int);
void		 layout_destroy_cell(struct window *, struct layout_cell *,
		     struct layout_cell **);
void		 layout_set_size(struct layout_cell *, u_int, u_int, u_int,
		     u_int);
void		 layout_make_leaf(struct layout_cell *, struct window_pane *);
void		 layout_make_node(struct layout_cell *, enum layout_type);
void		 layout_fix_offsets(struct layout_cell *);
void		 layout_fix_panes(struct window *, u_int, u_int);
void		 layout_resize_adjust(struct window *, struct layout_cell *,
		     enum layout_type, int);
void		 layout_init(struct window *, struct window_pane *);
void		 layout_free(struct window *);
void		 layout_resize(struct window *, u_int, u_int);
void		 layout_resize_pane(struct window_pane *, enum layout_type,
		     int, int);
void		 layout_resize_pane_to(struct window_pane *, enum layout_type,
		     u_int);
void		 layout_assign_pane(struct layout_cell *, struct window_pane *);
struct layout_cell *layout_split_pane(struct window_pane *, enum layout_type,
		     int, int, int);
void		 layout_close_pane(struct window_pane *);

/* layout-custom.c */
char		*layout_dump(struct layout_cell *);
int		 layout_parse(struct window *, const char *);

/* layout-set.c */
int		 layout_set_lookup(const char *);
u_int		 layout_set_select(struct window *, u_int);
u_int		 layout_set_next(struct window *);
u_int		 layout_set_previous(struct window *);

/* window-clock.c */
extern const struct window_mode window_clock_mode;
extern const char window_clock_table[14][5][5];

/* window-copy.c */
extern const struct window_mode window_copy_mode;
void		 window_copy_init_from_pane(struct window_pane *, int);
void		 window_copy_init_for_output(struct window_pane *);
void printflike(2, 3) window_copy_add(struct window_pane *, const char *, ...);
void		 window_copy_vadd(struct window_pane *, const char *, va_list);
void		 window_copy_pageup(struct window_pane *, int);
void		 window_copy_start_drag(struct client *, struct mouse_event *);
int		 window_copy_scroll_position(struct window_pane *);

/* window-choose.c */
extern const struct window_mode window_choose_mode;
void		 window_choose_add(struct window_pane *,
			 struct window_choose_data *);
void		 window_choose_ready(struct window_pane *,
		     u_int, void (*)(struct window_choose_data *));
struct window_choose_data	*window_choose_data_create (int,
		     struct client *, struct session *);
void	window_choose_data_run(struct window_choose_data *);
struct window_choose_data	*window_choose_add_window(struct window_pane *,
			struct client *, struct session *, struct winlink *,
			const char *, const char *, u_int);
struct window_choose_data	*window_choose_add_session(struct window_pane *,
			struct client *, struct session *, const char *,
			const char *, u_int);
void	window_choose_expand_all(struct window_pane *);
void	window_choose_set_current(struct window_pane *, u_int);

/* names.c */
void	 check_window_name(struct window *);
char	*default_window_name(struct window *);
char	*parse_window_name(const char *);

/* signal.c */
void	set_signals(void(*)(int, short, void *), void *);
void	clear_signals(int);

/* control.c */
void	control_callback(struct client *, int, void *);
void printflike(2, 3) control_write(struct client *, const char *, ...);
void	control_write_buffer(struct client *, struct evbuffer *);

/* control-notify.c */
void	control_notify_input(struct client *, struct window_pane *,
	    struct evbuffer *);
void	control_notify_window_layout_changed(struct window *);
void	control_notify_window_unlinked(struct session *, struct window *);
void	control_notify_window_linked(struct session *, struct window *);
void	control_notify_window_renamed(struct window *);
void	control_notify_client_session_changed(struct client *);
void	control_notify_session_renamed(struct session *);
void	control_notify_session_created(struct session *);
void	control_notify_session_closed(struct session *);

/* session.c */
extern struct sessions sessions;
extern struct session_groups session_groups;
int	session_cmp(struct session *, struct session *);
RB_PROTOTYPE(sessions, session, entry, session_cmp);
int	session_group_cmp(struct session_group *, struct session_group *);
RB_PROTOTYPE(session_groups, session_group, entry, session_group_cmp);
int		 session_alive(struct session *);
struct session	*session_find(const char *);
struct session	*session_find_by_id_str(const char *);
struct session	*session_find_by_id(u_int);
struct session	*session_create(const char *, const char *, int, char **,
		     const char *, const char *, struct environ *,
		     struct termios *, int, u_int, u_int, char **);
void		 session_destroy(struct session *);
void		 session_unref(struct session *);
int		 session_check_name(const char *);
void		 session_update_activity(struct session *, struct timeval *);
struct session	*session_next_session(struct session *);
struct session	*session_previous_session(struct session *);
struct winlink	*session_new(struct session *, const char *, int, char **,
		     const char *, const char *, int, char **);
struct winlink	*session_attach(struct session *, struct window *, int,
		     char **);
int		 session_detach(struct session *, struct winlink *);
int		 session_has(struct session *, struct window *);
int		 session_is_linked(struct session *, struct window *);
int		 session_next(struct session *, int);
int		 session_previous(struct session *, int);
int		 session_select(struct session *, int);
int		 session_last(struct session *);
int		 session_set_current(struct session *, struct winlink *);
struct session_group *session_group_contains(struct session *);
struct session_group *session_group_find(const char *);
struct session_group *session_group_new(const char *);
void		 session_group_add(struct session_group *, struct session *);
void		 session_group_synchronize_to(struct session *);
void		 session_group_synchronize_from(struct session *);
void		 session_renumber_windows(struct session *);

/* utf8.c */
void		 utf8_set(struct utf8_data *, u_char);
void		 utf8_copy(struct utf8_data *, const struct utf8_data *);
enum utf8_state	 utf8_open(struct utf8_data *, u_char);
enum utf8_state	 utf8_append(struct utf8_data *, u_char);
enum utf8_state	 utf8_combine(const struct utf8_data *, wchar_t *);
enum utf8_state	 utf8_split(wchar_t, struct utf8_data *);
int		 utf8_strvis(char *, const char *, size_t, int);
int		 utf8_stravis(char **, const char *, int);
char		*utf8_sanitize(const char *);
size_t		 utf8_strlen(const struct utf8_data *);
u_int		 utf8_strwidth(const struct utf8_data *, ssize_t);
struct utf8_data *utf8_fromcstr(const char *);
char		*utf8_tocstr(struct utf8_data *);
u_int		 utf8_cstrwidth(const char *);
char		*utf8_rtrimcstr(const char *, u_int);
char		*utf8_trimcstr(const char *, u_int);
char		*utf8_padcstr(const char *, u_int);

/* procname.c */
char   *get_proc_name(int, char *);

/* log.c */
void	log_add_level(void);
int	log_get_level(void);
void	log_open(const char *);
void	log_close(void);
void printflike(1, 2) log_debug(const char *, ...);
__dead void printflike(1, 2) fatal(const char *, ...);
__dead void printflike(1, 2) fatalx(const char *, ...);

/* style.c */
int		 style_parse(const struct grid_cell *,
		     struct grid_cell *, const char *);
const char	*style_tostring(struct grid_cell *);
void		 style_apply(struct grid_cell *, struct options *,
		     const char *);
void		 style_apply_update(struct grid_cell *, struct options *,
		     const char *);
int		 style_equal(const struct grid_cell *,
		     const struct grid_cell *);

#endif /* TMUX_H */
@


1.750
log
@Make the cmd_find_* functions more obvious when looking for a client,
rather than having it inside other functions. Should be no change to the
way targets are resolved just yet.
@
text
@d1 1
a1 1
/* $OpenBSD: tmux.h,v 1.749 2017/04/21 18:18:17 nicm Exp $ */
d1165 1
a1165 7

/* Context for command being executed. */
struct cmd_state {
	struct client		*c;
	struct cmd_find_state	 tflag;
	struct cmd_find_state	 sflag;
};
d1234 3
a1242 2
	struct cmd_state	 state;

d1247 5
a1251 22
/* Command -c, -t or -s flags. */
enum cmd_entry_flag {
	CMD_NONE,

	CMD_CLIENT,
	CMD_CLIENT_CANFAIL,

	CMD_SESSION,
	CMD_SESSION_CANFAIL,
	CMD_SESSION_PREFERUNATTACHED,
	CMD_SESSION_WITHPANE, /* implies PREFERUNATTACHED */

	CMD_WINDOW,
	CMD_WINDOW_CANFAIL,
	CMD_WINDOW_MARKED,
	CMD_WINDOW_INDEX,

	CMD_PANE,
	CMD_PANE_CANFAIL,
	CMD_PANE_MARKED,

	CMD_MOVEW_R,
d1266 2
a1267 3
	enum cmd_entry_flag	 tflag;
	enum cmd_entry_flag	 sflag;
	enum cmd_entry_flag	 cflag;
d1274 1
a1274 1
	enum cmd_retval		 (*exec)(struct cmd *, struct cmdq_item *);
a1740 1
int		 cmd_prepare_state(struct cmd *, struct cmdq_item *);
d1751 2
a1752 2
enum cmd_retval	 cmd_attach_session(struct cmdq_item *, int, int, const char *,
		     int);
@


1.749
log
@Style nits and an unused struct.
@
text
@d1 1
a1 1
/* $OpenBSD: tmux.h,v 1.748 2017/04/21 17:22:20 nicm Exp $ */
a1147 1
	struct cmdq_item	*item;
d1732 2
a1733 5
int		 cmd_find_current(struct cmd_find_state *, struct cmdq_item *,
		     int);
int		 cmd_find_target(struct cmd_find_state *,
		     struct cmd_find_state *, struct cmdq_item *, const char *,
		     enum cmd_find_type, int);
d1735 1
a1735 2
void		 cmd_find_clear_state(struct cmd_find_state *,
		     struct cmdq_item *, int);
d1748 2
d1752 4
a1755 2
void		 cmd_find_from_winlink_pane(struct cmd_find_state *,
		     struct winlink *, struct window_pane *);
@


1.748
log
@Add cmd_find_from_winlink_pane and use it in a couple of places, and
make functions that can't fail void.
@
text
@d1 1
a1 1
/* $OpenBSD: tmux.h,v 1.747 2017/04/21 16:04:18 nicm Exp $ */
a43 1
struct cmdq_subitem;
@


1.747
log
@It is annoying that the copy mode key table (or any other key table)
will suppress root key table bindings. So change to always check the
root table if no binding is found in the current table (whether it be
the prefix table from pressing the prefix or the copy mode table from a
pane).

A root key binding can be blocked by binding the key to a command that
does nothing (like send-keys with no arguments).

Problem reported by Thomas Sattler.
@
text
@d1 1
a1 1
/* $OpenBSD: tmux.h,v 1.746 2017/04/21 14:09:44 nicm Exp $ */
d1747 1
a1747 1
int		 cmd_find_from_session(struct cmd_find_state *,
d1749 1
a1749 1
int		 cmd_find_from_winlink(struct cmd_find_state *,
d1756 2
@


1.746
log
@More unnecessary arguments now winlink points back to session.
@
text
@d1 1
a1 1
/* $OpenBSD: tmux.h,v 1.745 2017/04/21 14:01:19 nicm Exp $ */
a1849 1
int	 server_client_is_default_key_table(struct client *);
@


1.745
log
@Store state shared between multiple commands in the queue in a shared
structure.
@
text
@d1 1
a1 1
/* $OpenBSD: tmux.h,v 1.744 2017/04/20 17:49:26 nicm Exp $ */
d1566 1
a1566 1
void	notify_winlink(const char *, struct session *, struct winlink *);
d1750 1
a1750 1
		     struct session *, struct winlink *);
@


1.744
log
@Use fdforkpty() instead of our own unwrapped versions.
@
text
@d1 1
a1 1
/* $OpenBSD: tmux.h,v 1.743 2017/04/20 09:43:45 nicm Exp $ */
d44 1
d1208 13
a1235 2
	struct format_tree	*formats;

d1241 1
a1243 1
	int			 repeat;
a1247 1
	struct cmd_find_state	 current;
a1249 2
	struct mouse_event	 mouse;

d1406 3
a1408 1
	int			 can_repeat;
@


1.743
log
@Now that struct winlink has a session pointer, can remove some arguments.
@
text
@d1 1
a1 1
/* $OpenBSD: tmux.h,v 1.742 2017/04/20 09:39:07 nicm Exp $ */
a2308 4

/* pty.c */
int		 pty_open(int *);
pid_t		 pty_fork(int, int *, char *, size_t, struct winsize *);
@


1.742
log
@There is no real need for window_printable_flags to allocate, make it
return a buffer from the stack.
@
text
@d1 1
a1 1
/* $OpenBSD: tmux.h,v 1.741 2017/04/20 09:20:22 nicm Exp $ */
d2123 1
a2123 1
const char	*window_printable_flags(struct session *, struct winlink *);
@


1.741
log
@If a #() command doesn't exit, use its most recent line of output (it
must be a full line). Don't let it redraw the status line more than once
a second.

Requested by someone about 10 years ago...
@
text
@d1 1
a1 1
/* $OpenBSD: tmux.h,v 1.740 2017/04/19 14:00:28 nicm Exp $ */
d2123 1
a2123 1
char		*window_printable_flags(struct session *, struct winlink *);
@


1.740
log
@Add a suspend helper function, and do not allow detaching or suspending
while already doing so.
@
text
@d1 1
a1 1
/* $OpenBSD: tmux.h,v 1.739 2017/04/19 06:52:27 nicm Exp $ */
d591 4
d602 11
a612 10
	char		*cmd;
	pid_t		 pid;
	int		 status;

	int		 fd;
	struct bufferevent *event;

	void		(*callbackfn)(struct job *);
	void		(*freefn)(void *);
	void		*data;
d614 1
a614 1
	LIST_ENTRY(job)	 lentry;
d1609 4
a1612 4
struct job *job_run(const char *, struct session *, const char *,
	    void (*)(struct job *), void (*)(void *), void *);
void	job_free(struct job *);
void	job_died(struct job *, int);
@


1.739
log
@When the data we have buffered to write to a terminal grows beyond a
reasonable amount (currently width * height * 8 bytes), discard all
output to the terminal and start trying to redraw periodically
instead. Continue with this until the amount of data we are trying to
write falls to a low level again.

This helps to prevent tmux sitting on a huge buffer of data when there
are processes with fast output running inside tmux but the outside
terminal is slow.

A new client_discarded format holds the amount of data that has been
discarded due to this mechanism.

The three variables (when to start this, when to stop, and how often to
redraw) are basically "works for me" at the moment, this is going in to
see how it goes and if it causes problems for anyone else.
@
text
@d1 1
a1 1
/* $OpenBSD: tmux.h,v 1.738 2017/04/18 21:41:42 nicm Exp $ */
d1341 1
a1341 1
/* 0x1000 unused */
d1841 1
@


1.738
log
@Revert use of DECSLRM on iTerm2, it doesn't help as much as we throught,
and there are some question marks about it's support.
@
text
@d1 1
a1 1
/* $OpenBSD: tmux.h,v 1.737 2017/04/18 18:21:37 nicm Exp $ */
d1046 2
a1047 1
	size_t		 written;
d1063 1
d1310 3
@


1.737
log
@Detect iTerm2 and use DECSLRM for it as well.
@
text
@d1 1
a1 1
/* $OpenBSD: tmux.h,v 1.736 2017/04/18 15:44:17 nicm Exp $ */
a1073 1
		TTY_ITERM2,
d1088 1
a1088 2
	{ "VT100", "VT101", "VT102", "VT220", "VT320", "VT420", "iTerm2", \
	  "Unknown" }
@


1.736
log
@Add a format for number of bytes writtent to client, useful for debugging.
@
text
@d1 1
a1 1
/* $OpenBSD: tmux.h,v 1.735 2017/04/17 06:40:32 nicm Exp $ */
d1074 1
d1089 2
a1090 1
	{ "VT100", "VT101", "VT102", "VT220", "VT320", "VT420", "UNKNOWN" }
@


1.735
log
@Remove a couple of redraw flags that no longer have any effect.
@
text
@d1 1
a1 1
/* $OpenBSD: tmux.h,v 1.734 2017/04/05 10:49:46 nicm Exp $ */
d1046 1
@


1.734
log
@Give each client a name. This defaults to the tty name as before but
falls back to an alternative if the tty name is not available. This is
clearer than overloading the client ttyname member and allows us to
remove the path stored in the tty struct, it should always be the same
as the client.
@
text
@d1 1
a1 1
/* $OpenBSD: tmux.h,v 1.733 2017/03/22 07:16:54 nicm Exp $ */
d819 1
a819 1
#define WINDOW_REDRAW 0x4
d1335 1
a1335 1
#define CLIENT_REDRAWWINDOW 0x1000
@


1.733
log
@Add support for the strikethrough attribute (SGR 9), using the new smxx
terminfo capability. This means there are now nine attribute bits, so
anything above 0xff uses an extended cell.
@
text
@d1 1
a1 1
/* $OpenBSD: tmux.h,v 1.732 2017/03/09 17:06:35 nicm Exp $ */
a1023 1
	char		*path;
d1287 1
@


1.732
log
@Move the client identify (display-panes) code into server-client.c.
@
text
@d1 1
a1 1
/* $OpenBSD: tmux.h,v 1.731 2017/03/09 17:02:38 nicm Exp $ */
d398 1
d510 1
a510 1
/* Grid attributes. */
d519 1
d536 1
a536 1
	u_char			attr;
d1914 1
a1914 1
const char *attributes_tostring(u_char);
@


1.731
log
@Move server_fill_environ into environ.c and move some other common code
into it.
@
text
@d1 1
a1 1
/* $OpenBSD: tmux.h,v 1.730 2017/03/08 13:36:12 nicm Exp $ */
d1822 2
a1862 2
void	 server_set_identify(struct client *);
void	 server_clear_identify(struct client *, struct window_pane *);
@


1.730
log
@Add a helper function for the most common format_create/defaults/expand
pattern.
@
text
@d1 1
a1 1
/* $OpenBSD: tmux.h,v 1.729 2017/02/27 13:07:57 nicm Exp $ */
d1616 1
a1841 1
void	 server_fill_environ(struct session *, struct environ *);
@


1.729
log
@If splitw -b is used, insert the new pane before the current one in the
pane list. This means the numbering is in order (for example for
display-panes) and fixes a problem with redrawing the active pane
borders.
@
text
@d1 1
a1 1
/* $OpenBSD: tmux.h,v 1.728 2017/02/21 14:18:12 nicm Exp $ */
d1511 3
@


1.728
log
@Don't need is1,is2,is3 so remove them.
@
text
@d1 1
a1 1
/* $OpenBSD: tmux.h,v 1.727 2017/02/14 18:13:05 nicm Exp $ */
d2069 1
a2069 1
		     u_int);
@


1.727
log
@Make source-file look for files relative to the client working directory
(like load-buffer and save-buffer), from Chris Pickel. Also break the
where-is-this-file code out into its own function for loadb and saveb.
@
text
@d1 1
a1 1
/* $OpenBSD: tmux.h,v 1.726 2017/02/10 12:59:18 nicm Exp $ */
a245 3
	TTYC_IS1,	/* init_1string, i1 */
	TTYC_IS2,	/* init_2string, i2 */
	TTYC_IS3,	/* init_3string, i3 */
@


1.726
log
@Don't use a bufferevent for the tty, so we can keep better track of what
is being written and when.

Also a manpage typo fix from jmc@@.
@
text
@d1 1
a1 1
/* $OpenBSD: tmux.h,v 1.725 2017/02/09 15:04:53 nicm Exp $ */
d1837 2
@


1.725
log
@Instead of numbering session groups, give them a name which may be given
to -t instead of a target session. Also allow them to contain only one
session.
@
text
@d1 1
a1 1
/* $OpenBSD: tmux.h,v 1.724 2017/02/09 12:09:33 nicm Exp $ */
d1044 4
a1047 1
	struct bufferevent *event;
@


1.724
log
@Break the message storage function into its own function, useful for
debugging.
@
text
@d1 1
a1 1
/* $OpenBSD: tmux.h,v 1.723 2017/02/08 23:53:03 nicm Exp $ */
d904 2
a905 1
	TAILQ_HEAD(, session) sessions;
d907 1
a907 1
	TAILQ_ENTRY(session_group) entry;
d909 1
a909 1
TAILQ_HEAD(session_groups, session_group);
d2214 2
d2220 3
a2222 3
struct session	*session_create(const char *, int, char **, const char *,
		     const char *, struct environ *, struct termios *, int,
		     u_int, u_int, char **);
d2241 4
a2244 3
struct session_group *session_group_find(struct session *);
u_int		 session_group_index(struct session_group *);
void		 session_group_add(struct session *, struct session *);
@


1.723
log
@Another helper function to write to terminal and log.
@
text
@d1 1
a1 1
/* $OpenBSD: tmux.h,v 1.722 2017/02/08 23:47:35 nicm Exp $ */
d1831 2
@


1.722
log
@Add a common function to invalidate all the terminal cached state.
@
text
@d1 1
a1 1
/* $OpenBSD: tmux.h,v 1.721 2017/02/08 17:31:09 nicm Exp $ */
d1089 1
a1089 1
	struct window_pane *wp;
d1091 1
a1091 1
	const struct grid_cell *cell;
@


1.721
log
@Add support for scroll up escape sequence (CSI S) and use it when
possible instead of sending individual line feeds.
@
text
@d1 1
a1 1
/* $OpenBSD: tmux.h,v 1.720 2017/02/08 16:45:18 nicm Exp $ */
d486 1
@


1.720
log
@Collect sequences of printable ASCII characters and process them
together instead of handling them one by one. This is significantly
faster. Sequences are terminated when we reach the end of the line, fill
the internal buffer, or a different character is seen by the input
parser (an escape sequence, or UTF-8).

Rather than writing collected sequences out immediately, hold them until
it is necessary (another screen modification, or we consume all
available data). This means we can discard changes that would have no
effect (for example, lines that would just be scrolled off the screen or
cleared). This reduces the total amount of data we write out to the
terminal - not important for fast terminals, but a big help with slow
(like xterm).
@
text
@d1 1
a1 1
/* $OpenBSD: tmux.h,v 1.719 2017/02/08 08:50:10 nicm Exp $ */
d244 1
d667 1
d1663 1
d1990 1
@


1.719
log
@Trying to avoid the occasional newline by saving the last cell on screen
is not actually helping us much and just adds complexity, so don't
bother.
@
text
@d1 1
a1 1
/* $OpenBSD: tmux.h,v 1.718 2017/02/08 08:25:12 nicm Exp $ */
a653 3
	bitstr_t		*dirty;
	u_int			 dirtysize;

d658 2
d663 3
a665 1
	u_int			 dirty;
d1046 1
a1046 1
	int              last_wp;
d1647 1
d1916 2
d1932 2
d1992 3
@


1.718
log
@Remove event watermarks, don't work well enough to be worth it.
@
text
@d1 1
a1 1
/* $OpenBSD: tmux.h,v 1.717 2017/02/06 22:05:11 nicm Exp $ */
a1107 3

	/* Saved last cell on line. */
	struct grid_cell last_cell;
@


1.717
log
@Use DECFRA on VT420 compatible terminals (so, xterm) and ED on all
others for clearing panes.
@
text
@d1 1
a1 1
/* $OpenBSD: tmux.h,v 1.716 2017/02/06 19:45:23 nicm Exp $ */
d67 2
a68 12
/*
 * Event watermarks. We start with FAST then if we hit full size for HITS reads
 * in succession switch to SLOW, and return when we hit EMPTY the same number
 * of times.
 */
#define READ_FAST_SIZE 4096
#define READ_SLOW_SIZE 128

#define READ_FULL_SIZE (4096 - 16)
#define READ_EMPTY_SIZE 16

#define READ_CHANGE_HITS 3
d233 1
a233 1
	TTYC_ED,	/* csr_eos, cd */
a753 3

	u_int		 wmark_size;
	u_int		 wmark_hits;
@


1.716
log
@Do not go through the whole attributes setting process if the new cell
is the same as the previous one.
@
text
@d1 1
a1 1
/* $OpenBSD: tmux.h,v 1.715 2017/02/06 19:26:49 nicm Exp $ */
d243 1
@


1.715
log
@Add BCE for clear to start of screen, which was somehow missed.
@
text
@d1 1
a1 1
/* $OpenBSD: tmux.h,v 1.714 2017/02/06 15:00:41 nicm Exp $ */
d1056 3
@


1.714
log
@Cancel key table when switching session, unless the key is going to
repeat. Reported by Amos Bird.
@
text
@d1 1
a1 1
/* $OpenBSD: tmux.h,v 1.713 2017/02/06 13:23:00 nicm Exp $ */
d1995 1
a1995 1
void	 screen_write_clearstartofscreen(struct screen_write_ctx *);
@


1.713
log
@Only redraw the modified character when adding combining characters, not
the whole line.
@
text
@d1 1
a1 1
/* $OpenBSD: tmux.h,v 1.712 2017/02/03 21:01:02 nicm Exp $ */
d1229 1
@


1.712
log
@Cache status line position to reduce option lookups during output.
@
text
@d1 1
a1 1
/* $OpenBSD: tmux.h,v 1.711 2017/02/03 11:57:27 nicm Exp $ */
a1669 1
void	tty_cmd_utf8character(struct tty *, const struct tty_ctx *);
@


1.711
log
@Add a window or pane id "tag" to each format tree and use it to separate
jobs, this means that if the same job is used for different windows or
panes (for example in pane-border-format), it will be run separately for
each pane.
@
text
@d1 1
a1 1
/* $OpenBSD: tmux.h,v 1.710 2017/02/01 09:55:07 nicm Exp $ */
a547 1

d938 2
d1868 1
@


1.710
log
@Implement "all event" (1003) mouse mode but in a way that works. The
main issue is that if we have two panes, A with 1002 and B with 1003, we
need to set 1003 outside tmux in order to get all the mouse events, but
then we need to suppress the ones that pane A doesn't want. This is easy
in SGR mouse mode, because buttons == 3 is only used for movement events
(for other events the trailing m/M marks a release instead), but in
normal mouse mode we can't tell so easily. So for that, look at the
previous event instead - if it is drag+release as well, then the current
event is a movement event.
@
text
@d1 1
a1 1
/* $OpenBSD: tmux.h,v 1.709 2017/01/30 21:41:17 nicm Exp $ */
d1506 3
d1510 1
a1510 1
struct format_tree *format_create(struct cmdq_item *, int);
@


1.709
log
@When a flag option is used in a format, it should use the number form
not string.
@
text
@d1 1
a1 1
/* $OpenBSD: tmux.h,v 1.708 2017/01/25 14:36:08 nicm Exp $ */
d140 1
d492 1
d494 1
a494 1
#define ALL_MOUSE_MODES (MODE_MOUSE_STANDARD|MODE_MOUSE_BUTTON)
@


1.708
log
@Revert previous for now, it will break TERM=screen.
@
text
@d1 1
a1 1
/* $OpenBSD: tmux.h,v 1.706 2017/01/24 21:50:23 nicm Exp $ */
d1565 1
a1565 1
const char	*options_tostring(struct options_entry *, int);
@


1.707
log
@If xterm-keys is on, use xterm(1) style keys for Home and End as well as
modified keys.
@
text
@d1891 1
a1891 1
char	*xterm_keys_lookup(key_code, int);
@


1.706
log
@Fixed keys for choose mode, and remove the last mode keys bits.
@
text
@d1 1
a1 1
/* $OpenBSD: tmux.h,v 1.705 2017/01/24 20:15:32 nicm Exp $ */
d1891 1
a1891 1
char	*xterm_keys_lookup(key_code);
@


1.705
log
@Make update-environment an array as well.
@
text
@d1 1
a1 1
/* $OpenBSD: tmux.h,v 1.704 2017/01/24 19:53:37 nicm Exp $ */
d474 1
a474 31
/* Mode key commands. */
enum mode_key_cmd {
	MODEKEY_NONE,
	MODEKEY_OTHER,

	/* Menu (choice) keys. */
	MODEKEYCHOICE_BACKSPACE,
	MODEKEYCHOICE_BOTTOMLINE,
	MODEKEYCHOICE_CANCEL,
	MODEKEYCHOICE_CHOOSE,
	MODEKEYCHOICE_DOWN,
	MODEKEYCHOICE_ENDOFLIST,
	MODEKEYCHOICE_PAGEDOWN,
	MODEKEYCHOICE_PAGEUP,
	MODEKEYCHOICE_SCROLLDOWN,
	MODEKEYCHOICE_SCROLLUP,
	MODEKEYCHOICE_STARTNUMBERPREFIX,
	MODEKEYCHOICE_STARTOFLIST,
	MODEKEYCHOICE_TOPLINE,
	MODEKEYCHOICE_TREE_COLLAPSE,
	MODEKEYCHOICE_TREE_COLLAPSE_ALL,
	MODEKEYCHOICE_TREE_EXPAND,
	MODEKEYCHOICE_TREE_EXPAND_ALL,
	MODEKEYCHOICE_TREE_TOGGLE,
	MODEKEYCHOICE_UP,
};

/* Data required while mode keys are in use. */
struct mode_key_data {
	struct mode_key_tree   *tree;
};
a477 18
/* Binding between a key and a command. */
struct mode_key_binding {
	key_code			 key;
	enum mode_key_cmd		 cmd;

	RB_ENTRY(mode_key_binding)	 entry;
};
RB_HEAD(mode_key_tree, mode_key_binding);

/* Named mode key table description. */
struct mode_key_entry;
struct mode_key_table {
	const char			*name;
	const struct mode_key_cmdstr	*cmdstr;
	struct mode_key_tree		*tree;
	const struct mode_key_entry	*table;	/* default entries */
};

a1533 14

/* mode-key.c */
extern struct mode_key_tree mode_key_tree_vi_choice;
extern struct mode_key_tree mode_key_tree_emacs_choice;
int	mode_key_cmp(struct mode_key_binding *, struct mode_key_binding *);
RB_PROTOTYPE(mode_key_tree, mode_key_binding, entry, mode_key_cmp);
const char *mode_key_tostring(const struct mode_key_cmdstr *,
	    enum mode_key_cmd);
enum mode_key_cmd mode_key_fromstring(const struct mode_key_cmdstr *,
	    const char *);
const struct mode_key_table *mode_key_findtable(const char *);
void	mode_key_init_trees(void);
void	mode_key_init(struct mode_key_data *, struct mode_key_tree *);
enum mode_key_cmd mode_key_lookup(struct mode_key_data *, key_code);
@


1.704
log
@Add support for custom command aliases, this is an array option which
contains items of the form "alias=command". This is consulted when an
unknown command is parsed.
@
text
@d1 1
a1 1
/* $OpenBSD: tmux.h,v 1.703 2017/01/24 19:11:46 nicm Exp $ */
d1672 1
a1672 1
void	environ_update(const char *, struct environ *, struct environ *);
@


1.703
log
@If given an array option without an index either show or set all items,
and support -a for array options. Allow the separator for set to be
specified in the options table (will be used for backwards compatibility
later).
@
text
@d1 1
a1 1
/* $OpenBSD: tmux.h,v 1.702 2017/01/23 10:09:43 nicm Exp $ */
d1831 1
@


1.702
log
@Open /dev/ptm before pledge() and save it to be used for PTMGET later
(this means inlining forkpty()).

ok deraadt
@
text
@d1 1
a1 1
/* $OpenBSD: tmux.h,v 1.701 2017/01/18 10:08:05 nicm Exp $ */
d1482 1
d1620 1
d1622 2
a1623 1
int		 options_array_set(struct options_entry *, u_int, const char *);
d1625 1
d1630 1
a1630 1
		    int);
d1633 1
a1633 1
		    int, int *);
@


1.701
log
@Plain stravis() because it will mangle UTF-8 characters, so add
utf8_stravis() which calls our existing utf8_strvis() and use it instead
@
text
@d1 1
a1 1
/* $OpenBSD: tmux.h,v 1.700 2017/01/16 14:52:25 nicm Exp $ */
d1504 1
d2332 4
@


1.700
log
@Revert WIP parts of previous I didn't mean to commit yet.
@
text
@d1 1
a1 1
/* $OpenBSD: tmux.h,v 1.699 2017/01/16 14:49:14 nicm Exp $ */
d2298 1
@


1.699
log
@getopt() has a struct option so just return to using options_entry.
@
text
@d1 1
a1 1
/* $OpenBSD: tmux.h,v 1.698 2017/01/15 22:00:56 nicm Exp $ */
a1825 1
int		 cmd_string_split(const char *, int *, char ***);
@


1.698
log
@It is silly for cmd_list_parse to return an integer error when it could
just return NULL.
@
text
@d1 1
a1 1
/* $OpenBSD: tmux.h,v 1.697 2017/01/15 20:48:41 nicm Exp $ */
d50 1
d1451 1
a1451 5
/*
 * Option table entries. The option table is the user-visible part of the
 * option, as opposed to the internal options (struct option) which are just
 * number or string.
 */
d1607 3
a1609 3
struct option	*options_first(struct options *);
struct option	*options_next(struct option *);
struct option	*options_empty(struct options *,
d1611 1
a1611 1
struct option	*options_default(struct options *,
d1613 10
a1622 10
const char	*options_name(struct option *);
const struct options_table_entry *options_table_entry(struct option *);
struct option	*options_get_only(struct options *, const char *);
struct option	*options_get(struct options *, const char *);
void		 options_remove(struct option *);
const char	*options_array_get(struct option *, u_int);
int		 options_array_set(struct option *, u_int, const char *);
int		 options_array_size(struct option *, u_int *);
int		 options_isstring(struct option *);
const char	*options_tostring(struct option *, int);
d1624 1
a1624 1
struct option	*options_parse_get(struct options *, const char *, int *,
d1627 1
a1627 1
struct option	*options_match_get(struct options *, const char *, int *,
d1632 1
a1632 1
struct option * printflike(4, 5) options_set_string(struct options *,
d1634 3
a1636 2
struct option	*options_set_number(struct options *, const char *, long long);
struct option	*options_set_style(struct options *, const char *, int,
d1640 4
a1643 2
void		 options_style_update_new(struct options *, struct option *);
void		 options_style_update_old(struct options *, struct option *);
d1826 1
@


1.697
log
@Major tidy up and rework of options tree and set-option/show-options
commands this pushes more of the code into options.c and ties it more
closely to the options table rather than having an unnecessary
split. Also add support for array options (will be used later). Only
(intentional) user visible change is that show-options output is now
passed through vis(3) with VIS_DQ so quotes are escaped.
@
text
@d1 1
a1 1
/* $OpenBSD: tmux.h,v 1.696 2017/01/13 11:58:49 nicm Exp $ */
d1826 1
a1826 2
int	cmd_string_parse(const char *, struct cmd_list **, const char *,
	    u_int, char **);
@


1.696
log
@options_get_style return const too.
@
text
@d1 1
a1 1
/* $OpenBSD: tmux.h,v 1.695 2017/01/13 11:56:43 nicm Exp $ */
a643 17
/* Option data structures. */
struct options_entry {
	const char		*name;

	enum {
		OPTIONS_STRING,
		OPTIONS_NUMBER,
		OPTIONS_STYLE
	} type;

	char			*str;
	long long		 num;
	struct grid_cell	 style;

	RB_ENTRY(options_entry)	 entry;
};

d1463 2
a1464 1
	OPTIONS_TABLE_STYLE
d1608 26
a1633 15
struct options *options_create(struct options *);
void	options_free(struct options *);
struct options_entry *options_first(struct options *);
struct options_entry *options_next(struct options_entry *);
struct options_entry *options_find1(struct options *, const char *);
struct options_entry *options_find(struct options *, const char *);
void	options_remove(struct options *, const char *);
struct options_entry * printflike(4, 5) options_set_string(struct options *,
	    const char *, int, const char *, ...);
const char *options_get_string(struct options *, const char *);
struct options_entry *options_set_number(struct options *, const char *,
	    long long);
long long options_get_number(struct options *, const char *);
struct options_entry *options_set_style(struct options *, const char *, int,
	    const char *);
d1635 9
a1646 4
void	options_table_populate_tree(enum options_table_scope, struct options *);
const char *options_table_print_entry(const struct options_table_entry *,
	    struct options_entry *, int);
int	options_table_find(const char *, const struct options_table_entry **);
a2324 3
void		 style_update_new(struct options *, const char *, const char *);
void		 style_update_old(struct options *, const char *,
		     struct grid_cell *);
@


1.695
log
@Make options_get_string return const string.
@
text
@d1 1
a1 1
/* $OpenBSD: tmux.h,v 1.694 2017/01/13 10:12:12 nicm Exp $ */
d1639 1
a1639 1
struct grid_cell *options_get_style(struct options *, const char *);
@


1.694
log
@Add -E to detach-client to exec a command to replace the client instead
of exiting it, useful if tmux wasn't exec'd itself. From Jenna Magius.
@
text
@d1 1
a1 1
/* $OpenBSD: tmux.h,v 1.693 2017/01/12 15:36:35 nicm Exp $ */
d1633 1
a1633 1
char   *options_get_string(struct options *, const char *);
@


1.693
log
@Simplify appending to string options.
@
text
@d1 1
a1 1
/* $OpenBSD: tmux.h,v 1.692 2017/01/12 10:15:55 nicm Exp $ */
d446 1
d1884 1
@


1.692
log
@Put all palette functions together in the file.
@
text
@d1 1
a1 1
/* $OpenBSD: tmux.h,v 1.691 2017/01/12 00:19:32 nicm Exp $ */
d1630 2
a1631 2
struct options_entry *printflike(3, 4) options_set_string(struct options *,
	    const char *, const char *, ...);
d1636 2
a1637 2
struct options_entry *options_set_style(struct options *, const char *,
	    const char *, int);
@


1.691
log
@Fix setting the palette of aixterm colours (90-97).
@
text
@d1 1
a1 1
/* $OpenBSD: tmux.h,v 1.690 2017/01/11 16:09:57 nicm Exp $ */
d2137 1
a2155 1
int		 window_pane_get_palette(const struct window_pane *, int);
@


1.690
log
@Add a format for terminal type.
@
text
@d1 1
a1 1
/* $OpenBSD: tmux.h,v 1.689 2017/01/11 16:05:46 nicm Exp $ */
a862 5
#define WINDOW_PANE_PALETTE_HAS(wp, c)			\
	((wp) != NULL && (wp)->palette != NULL &&	\
	    ((c) < 0x100 || (c) & COLOUR_FLAG_256) &&	\
	    (wp)->palette[(c) & 0xff] != 0)

d2155 1
@


1.689
log
@Use a macro for looking up tty types.
@
text
@d1 1
a1 1
/* $OpenBSD: tmux.h,v 1.688 2017/01/11 14:56:44 nicm Exp $ */
a1114 3
	char		*termname;
	struct tty_term	*term;

d1131 2
@


1.688
log
@Some tidying and tweaks to options code.
@
text
@d1 1
a1 1
/* $OpenBSD: tmux.h,v 1.687 2017/01/09 21:03:25 nicm Exp $ */
d1155 2
@


1.687
log
@Add simple comparisons in formats: #{==:a,b} and #{!=:a,b} ("a" and "b"
are expanded so can compare formats). And expand the condition to
#{?a,b,c} (the "a" part) if it doesn't work as a simple lookup.

Also add FORMAT_NOJOBS flag to disable jobs in a format.
@
text
@d1 1
a1 1
/* $OpenBSD: tmux.h,v 1.686 2017/01/09 19:27:00 nicm Exp $ */
d657 1
a657 1
	RB_ENTRY(options_entry) entry;
@


1.686
log
@Run the source-file pattern through glob(3).
@
text
@d1 1
a1 1
/* $OpenBSD: tmux.h,v 1.685 2017/01/07 15:28:13 nicm Exp $ */
d1571 1
@


1.685
log
@Add support for the OSC 4 and OSC 104 palette setting escape sequences,
from S Gilles.
@
text
@d1 1
a1 1
/* $OpenBSD: tmux.h,v 1.684 2017/01/06 11:57:03 nicm Exp $ */
d79 1
a79 1
/* Attribute to make gcc check printf-like arguments. */
@


1.684
log
@Incremental search in copy mode (on for emacs keys by default) - much
the same as normal searching but updates the cursor position and marked
search terms as you type. C-r and C-s in the prompt repeat the search,
once finished searching (with Enter), N and n work as before.
@
text
@d1 1
a1 1
/* $OpenBSD: tmux.h,v 1.683 2017/01/05 09:07:16 nicm Exp $ */
d579 1
d833 2
d863 5
d2137 3
@


1.683
log
@Highlight all occurrences of search string after searching in copy mode.
@
text
@d1 1
a1 1
/* $OpenBSD: tmux.h,v 1.682 2016/12/28 10:34:34 nicm Exp $ */
d1420 1
a1420 1
	int		 (*prompt_callbackfn)(void *, const char *);
d1428 1
d1919 1
a1919 1
	     int (*)(void *, const char *), void (*)(void *), void *, int);
@


1.682
log
@Fix the prefer unattached session behaviour of
attach-session/switch-client, reported by Thomas Sattle.
@
text
@d1 1
a1 1
/* $OpenBSD: tmux.h,v 1.681 2016/11/24 18:45:45 nicm Exp $ */
d2014 1
a2014 1
	     u_int, u_int, u_int);
@


1.681
log
@The mouse valid flag needs to be correct before we fire the dragging
callback, so move the callback outside of server_client_check_mouse and
use a new special key code to indicate it.
@
text
@d1 1
a1 1
/* $OpenBSD: tmux.h,v 1.680 2016/11/24 13:38:44 nicm Exp $ */
d1308 1
a1308 1
	CMD_SESSION_WITHPANE,
@


1.680
log
@Make the selection able to exist independent of the cursor position, so
that it is not affected by scrolling. If MouseDragEnd1Pane is bound to
the new "stop-selection" command:

    bind -Tcopy-mode MouseDragEnd1Pane stop-selection

A selection made with the mouse will stay as it is after button 1 is
released. (It also works bound to a key.)

From Artem Fokin.
@
text
@d1 1
a1 1
/* $OpenBSD: tmux.h,v 1.679 2016/11/23 17:01:24 nicm Exp $ */
d138 1
@


1.679
log
@For mouse keys, use the mouse pane as the default current pane.
@
text
@d1 1
a1 1
/* $OpenBSD: tmux.h,v 1.678 2016/11/16 00:24:03 nicm Exp $ */
d684 2
d2060 1
@


1.678
log
@The target validity check used window_pane_visible but that may be false
if the pane is zoomed, so instead add a new function to just check if
the pane is actually on screen (most commands still want to accept panes
invisible by zoom). Also reject panes outside the window for various
special targets. Problem reported by Sean Haugh.
@
text
@d1 1
a1 1
/* $OpenBSD: tmux.h,v 1.677 2016/11/15 15:17:28 nicm Exp $ */
d1838 1
a1838 1
	     struct mouse_event *);
@


1.677
log
@Turn on margins, with a couple of fixes (only limit to the pane for line
feeds, and do not move cursor to end for full width panes).
@
text
@d1 1
a1 1
/* $OpenBSD: tmux.h,v 1.676 2016/11/15 14:02:32 nicm Exp $ */
d2129 1
@


1.676
log
@Initial attempt to make use of left and right margins if the terminal
supports them (that is, if it advertises itself as a VT420 - probably
just xterm). These are the vertical equivalent of the scroll region and
allow much faster scrolling of panes that do not take up the full width
of the terminal.
@
text
@d1 1
a1 1
/* $OpenBSD: tmux.h,v 1.675 2016/11/04 14:47:38 nicm Exp $ */
d1667 2
a1668 2
void	tty_region(struct tty *, u_int, u_int);
void	tty_margin(struct tty *, u_int, u_int);
@


1.675
log
@enum values need to fit in 32 bits; we only use enum for numbering and
Unicode characters fit in 24 bits, so we can leave key_code as 64 bits
and change KEYC_BASE down to 0x10000000.
@
text
@d1 1
a1 1
/* $OpenBSD: tmux.h,v 1.674 2016/10/19 09:22:07 nicm Exp $ */
d1101 3
d1124 9
d1668 1
d1693 1
@


1.674
log
@Alerts are too slow, so rather than walking all sessions and windows,
add a link of winlinks to each window and a pointer to the session to
each winlink. Also rewrite the alerts processing to return to the old
behaviour (alert in any window sets the flag on any winlink).
@
text
@d1 1
a1 1
/* $OpenBSD: tmux.h,v 1.673 2016/10/18 08:46:43 nicm Exp $ */
d96 1
a96 1
#define KEYC_BASE 0x100000000000ULL
@


1.673
log
@Give each item on queue a name for better logging.
@
text
@d1 1
a1 1
/* $OpenBSD: tmux.h,v 1.672 2016/10/16 22:18:04 nicm Exp $ */
d892 3
d901 1
d910 1
d924 1
d999 1
a2078 1
void		 window_destroy(struct window *);
@


1.672
log
@Use notifys for alerts too.
@
text
@d1 1
a1 1
/* $OpenBSD: tmux.h,v 1.671 2016/10/16 22:06:40 nicm Exp $ */
d1242 1
d1783 2
a1784 1
struct cmdq_item *cmdq_get_callback(cmdq_cb, void *);
@


1.671
log
@Use the notify name string instead of going via an enum and change
existing hooks to use notifys instead.
@
text
@d1 1
a1 1
/* $OpenBSD: tmux.h,v 1.670 2016/10/16 19:36:37 nicm Exp $ */
d1588 1
@


1.670
log
@Provide a way for hooks to tag formats onto the commands they fire so
that the user can get at additional information - now used for the
"hook" format, more to come.
@
text
@d1 1
a1 1
/* $OpenBSD: tmux.h,v 1.669 2016/10/16 19:15:02 nicm Exp $ */
d1586 5
a1590 8
void	notify_window_layout_changed(struct window *);
void	notify_window_unlinked(struct session *, struct window *);
void	notify_window_linked(struct session *, struct window *);
void	notify_window_renamed(struct window *);
void	notify_attached_session_changed(struct client *);
void	notify_session_renamed(struct session *);
void	notify_session_created(struct session *);
void	notify_session_closed(struct session *);
d2209 1
a2209 1
void	control_notify_attached_session_changed(struct client *);
@


1.669
log
@Notifys can go via the command queue instead of using their own queue.
@
text
@d1 1
a1 1
/* $OpenBSD: tmux.h,v 1.668 2016/10/16 19:04:05 nicm Exp $ */
d1253 2
a1254 1
	const char		*hook;
d1787 2
@


1.668
log
@Mass rename struct cmd_q to struct cmdq_item and related.
@
text
@d1 1
a1 1
/* $OpenBSD: tmux.h,v 1.667 2016/10/16 17:55:14 nicm Exp $ */
a1583 1
void	notify_drain(void);
@


1.667
log
@Rewrite command queue handling. Each client still has a command queue,
but there is also now a global command queue. Instead of command queues
being dispatched on demand from wherever the command happens to be
added, they are now all dispatched from the top level server
loop. Command queues may now also include callbacks as well as commands,
and items may be inserted after the current command as well as at the end.

This all makes command queues significantly more predictable and easier
to use, and avoids the complex multiple nested command queues used by
source-file, if-shell and friends.

A mass rename of struct cmdq to a better name (cmdq_item probably) is
coming.
@
text
@d1 1
a1 1
/* $OpenBSD: tmux.h,v 1.666 2016/10/15 09:27:52 nicm Exp $ */
d43 2
a44 2
struct cmd_q;
struct cmd_q_list;
d1180 1
a1180 1
	struct cmd_q		*cmdq;
d1234 3
a1236 3
enum cmd_q_type {
	CMD_Q_COMMAND,
	CMD_Q_CALLBACK,
d1240 4
a1243 4
typedef enum cmd_retval (*cmd_q_cb) (struct cmd_q *, void *);
struct cmd_q {
	struct cmd_q_list	*queue;
	struct cmd_q		*next;
d1247 1
a1247 1
	enum cmd_q_type		 type;
d1255 3
a1257 3
#define CMD_Q_FIRED 0x1
#define CMD_Q_WAITING 0x2
#define CMD_Q_NOHOOKS 0x4
d1262 1
a1262 1
	cmd_q_cb		 cb;
d1270 1
a1270 1
	TAILQ_ENTRY(cmd_q)	 entry;
d1272 1
a1272 1
TAILQ_HEAD(cmd_q_list, cmd_q);
d1319 1
a1319 1
	enum cmd_retval		 (*exec)(struct cmd *, struct cmd_q *);
d1325 1
a1325 1
	struct cmd_q_list queue;
d1513 3
a1515 3
void		 start_cfg(void);
int		 load_cfg(const char *, struct client *, struct cmd_q *, int);
void		 set_cfg_file(const char *);
d1517 2
a1518 2
void		 cfg_print_causes(struct cmd_q *);
void		 cfg_show_causes(struct session *);
d1539 1
a1539 1
struct format_tree *format_create(struct cmd_q *, int);
d1566 1
a1566 1
void printflike(4, 5) hooks_insert(struct hooks *, struct cmd_q *,
d1732 1
a1732 1
int		 cmd_find_current(struct cmd_find_state *, struct cmd_q *,
d1735 1
a1735 1
		     struct cmd_find_state *, struct cmd_q *, const char *,
d1737 3
a1739 3
struct client	*cmd_find_client(struct cmd_q *, const char *, int);
void		 cmd_find_clear_state(struct cmd_find_state *, struct cmd_q *,
		     int);
d1762 1
a1762 1
int		 cmd_prepare_state(struct cmd *, struct cmd_q *);
d1773 2
a1774 2
enum cmd_retval	 cmd_attach_session(struct cmd_q *, int, int, const char *,
    int);
d1782 1
a1782 1
struct cmd_q	*cmdq_get_command(struct cmd_list *, struct cmd_find_state *,
d1784 3
a1786 3
struct cmd_q	*cmdq_get_callback(cmd_q_cb, void *);
void		 cmdq_insert_after(struct cmd_q *, struct cmd_q *);
void		 cmdq_append(struct client *, struct cmd_q *);
d1788 3
a1790 3
void		 cmdq_guard(struct cmd_q *, const char *, int);
void printflike(2, 3) cmdq_print(struct cmd_q *, const char *, ...);
void printflike(2, 3) cmdq_error(struct cmd_q *, const char *, ...);
@


1.666
log
@Give window_create and window_create1 better names.
@
text
@d1 1
a1 1
/* $OpenBSD: tmux.h,v 1.665 2016/10/15 00:12:58 nicm Exp $ */
d43 2
a635 1
	struct cmd_q	*cmdq;
a1163 95
/* Client connection. */
struct client {
	struct tmuxpeer	*peer;

	pid_t		 pid;
	int		 fd;
	struct event	 event;
	int		 retval;

	struct timeval	 creation_time;
	struct timeval	 activity_time;

	struct environ	*environ;

	char		*title;
	const char	*cwd;

	char		*term;
	char		*ttyname;
	struct tty	 tty;

	void		(*stdin_callback)(struct client *, int, void *);
	void		*stdin_callback_data;
	struct evbuffer	*stdin_data;
	int		 stdin_closed;
	struct evbuffer	*stdout_data;
	struct evbuffer	*stderr_data;

	struct event	 repeat_timer;

	struct event	 click_timer;
	u_int		 click_button;

	struct event	 status_timer;
	struct screen	 status;

#define CLIENT_TERMINAL 0x1
#define CLIENT_LOGIN 0x2
#define CLIENT_EXIT 0x4
#define CLIENT_REDRAW 0x8
#define CLIENT_STATUS 0x10
#define CLIENT_REPEAT 0x20
#define CLIENT_SUSPENDED 0x40
/* 0x80 unused */
#define CLIENT_IDENTIFY 0x100
#define CLIENT_DEAD 0x200
#define CLIENT_BORDERS 0x400
#define CLIENT_READONLY 0x800
#define CLIENT_REDRAWWINDOW 0x1000
#define CLIENT_CONTROL 0x2000
#define CLIENT_CONTROLCONTROL 0x4000
#define CLIENT_FOCUSED 0x8000
#define CLIENT_UTF8 0x10000
#define CLIENT_256COLOURS 0x20000
#define CLIENT_IDENTIFIED 0x40000
#define CLIENT_STATUSFORCE 0x80000
#define CLIENT_DOUBLECLICK 0x100000
#define CLIENT_TRIPLECLICK 0x200000
	int		 flags;
	struct key_table *keytable;

	struct event	 identify_timer;
	void		(*identify_callback)(struct client *, struct window_pane *);
	void		*identify_callback_data;

	char		*message_string;
	struct event	 message_timer;
	u_int		 message_next;
	TAILQ_HEAD(, message_entry) message_log;

	char		*prompt_string;
	struct utf8_data *prompt_buffer;
	size_t		 prompt_index;
	int		 (*prompt_callbackfn)(void *, const char *);
	void		 (*prompt_freefn)(void *);
	void		*prompt_data;
	u_int		 prompt_hindex;
	enum { PROMPT_ENTRY, PROMPT_COMMAND } prompt_mode;

#define PROMPT_SINGLE 0x1
#define PROMPT_NUMERIC 0x2
	int		 prompt_flags;

	struct session	*session;
	struct session	*last_session;

	int		 wlmouse;

	struct cmd_q	*cmdq;
	int		 references;

	TAILQ_ENTRY(client) entry;
};
TAILQ_HEAD(clients, client);

d1233 4
a1236 7
/* Command queue entry. */
struct cmd_q_item {
	struct cmd_list		*cmdlist;

	struct mouse_event	 mouse;

	TAILQ_ENTRY(cmd_q_item)	 qentry;
a1237 1
TAILQ_HEAD(cmd_q_items, cmd_q_item);
d1239 2
a1240 1
/* Command queue. */
d1242 2
a1243 4
	int			 references;
	int			 flags;
#define CMD_Q_DEAD 0x1
#define CMD_Q_NOHOOKS 0x2
a1245 1
	int			 client_exit;
d1247 13
a1259 2
	struct cmd_q_items	 queue;
	struct cmd_q_item	*item;
d1261 3
a1263 1
	struct cmd_q		*parent;
d1268 1
a1268 2
	time_t			 time;
	u_int			 number;
d1270 1
a1270 4
	void			 (*emptyfn)(struct cmd_q *);
	void			*data;

	TAILQ_ENTRY(cmd_q)	 waitentry;
d1272 1
d1322 95
a1511 1
extern int cfg_references;
d1514 1
a1514 1
int		 load_cfg(const char *, struct cmd_q *, int);
d1564 1
a1564 1
int printflike(4, 5) hooks_run(struct hooks *, struct client *,
d1566 1
a1566 1
int printflike(4, 5) hooks_wait(struct hooks *, struct cmd_q *,
d1762 1
a1762 2
int		 cmd_prepare_state(struct cmd *, struct cmd_q *,
		     struct cmd_q *);
d1782 7
a1788 2
struct cmd_q	*cmdq_new(struct client *);
int		 cmdq_free(struct cmd_q *);
a1790 6
void		 cmdq_guard(struct cmd_q *, const char *, int);
void		 cmdq_run(struct cmd_q *, struct cmd_list *,
		     struct mouse_event *);
void		 cmdq_append(struct cmd_q *, struct cmd_list *,
		     struct mouse_event *);
int		 cmdq_continue(struct cmd_q *);
@


1.665
log
@Rename a function for consistency and some spacing nits.
@
text
@d1 1
a1 1
/* $OpenBSD: tmux.h,v 1.664 2016/10/15 00:09:30 nicm Exp $ */
d2064 2
a2065 2
struct window	*window_create1(u_int, u_int);
struct window	*window_create(const char *, int, char **, const char *,
@


1.664
log
@Fire hooks on the simple notifys (window-renamed and session-renamed),
the complicated ones get no hooks for now (more to come).
@
text
@d1 1
a1 1
/* $OpenBSD: tmux.h,v 1.663 2016/10/15 00:01:01 nicm Exp $ */
d2211 1
a2211 1
void	control_notify_session_close(struct session *);
@


1.663
log
@Drain notifys once at the end of the server loop instead of doing it
from the end of every command queue (which could be nested).
@
text
@d1 1
a1 1
/* $OpenBSD: tmux.h,v 1.662 2016/10/13 22:48:51 nicm Exp $ */
d1745 2
@


1.662
log
@Trying to do hooks generically is way too complicated and unreliable and
confusing, particularly trying to automatically figure out what target
hooks should be using. So simplify it:

- drop before hooks entirely, they don't seem to be very useful;

- commands with special requirements now fire their own after hook (for
  example, if they change session or window, or if they have -t and -s
  and need to choose which one the hook uses as current target);

- commands with no special requirements can have the CMD_AFTERHOOK flag
  added and they will use the -t state.

At the moment new-session, new-window, split-window fire their own hook,
and display-message uses the flag. The remaining commands still need to
be looked at.
@
text
@d1 1
a1 1
/* $OpenBSD: tmux.h,v 1.661 2016/10/13 20:27:27 nicm Exp $ */
d1580 1
a1580 2
void	notify_enable(void);
void	notify_disable(void);
@


1.661
log
@Add support for BCE (background colour erase). This makes various escape
sequences (notable EL and ED but also IL, DL, ICH, DCH) create blank
cells using the current background colour rather than the default
colour.

On modern systems BCE doesn't really have many benefits, but most other
terminals now support it, some (lazy) applications rely on it, and it is
not hard to include now that we have pane background colours anyway.

Mostly written by Sean Haugh.
@
text
@d1 1
a1 1
/* $OpenBSD: tmux.h,v 1.660 2016/10/13 10:01:49 nicm Exp $ */
d1342 1
a1342 2
#define CMD_Q_REENTRY 0x2
#define CMD_Q_NOHOOKS 0x4
d1406 1
@


1.660
log
@Some improvements and bug fixes for hooks:

- Prepare the state again before the "after" hooks are run, because the
  command may have killed or moved windows.

- Use the hooks list from the newly prepared target, not the old hooks
  list (only matters for new-session really).

- Correctly detect an invalid current state and ignore it in
  cmd_find_target ("killw; swapw").

- Change neww, new, killp, killw, splitw, swapp, swapw to update the
  current state (used if no explicit target is given) to something more
  useful after they have finished. For example, neww changes it to the
  newly created window.

Hooks are still relatively new and primitive so there are likely to be
more changes to come.

Parts based on bug reports from Uwe Werler and Iblis Lin.
@
text
@d1 1
a1 1
/* $OpenBSD: tmux.h,v 1.659 2016/10/12 15:26:37 nicm Exp $ */
d605 1
d714 1
a714 1
	u_int		 	 rlower;	/* scroll region bottom */
d1148 3
d1194 1
a1194 1
	u_int            click_button;
d1278 2
a1279 2
	struct session          *s;
	struct winlink          *wl;
d1281 1
a1281 1
	struct window_pane      *wp;
d1551 1
a1551 1
struct hooks 	*hooks_get(struct session *);
d1932 2
a1933 2
void	 grid_collect_history(struct grid *);
void	 grid_scroll_history(struct grid *);
d1939 4
a1942 4
void	 grid_clear(struct grid *, u_int, u_int, u_int, u_int);
void	 grid_clear_lines(struct grid *, u_int, u_int);
void	 grid_move_lines(struct grid *, u_int, u_int, u_int);
void	 grid_move_cells(struct grid *, u_int, u_int, u_int, u_int);
d1953 2
a1954 2
void	 grid_view_clear_history(struct grid *);
void	 grid_view_clear(struct grid *, u_int, u_int, u_int, u_int);
d1957 8
a1964 6
void	 grid_view_insert_lines(struct grid *, u_int, u_int);
void	 grid_view_insert_lines_region(struct grid *, u_int, u_int, u_int);
void	 grid_view_delete_lines(struct grid *, u_int, u_int);
void	 grid_view_delete_lines_region(struct grid *, u_int, u_int, u_int);
void	 grid_view_insert_cells(struct grid *, u_int, u_int, u_int);
void	 grid_view_delete_cells(struct grid *, u_int, u_int, u_int);
d1994 2
a1995 2
void	 screen_write_insertcharacter(struct screen_write_ctx *, u_int);
void	 screen_write_deletecharacter(struct screen_write_ctx *, u_int);
d1997 5
a2001 5
void	 screen_write_insertline(struct screen_write_ctx *, u_int);
void	 screen_write_deleteline(struct screen_write_ctx *, u_int);
void	 screen_write_clearline(struct screen_write_ctx *);
void	 screen_write_clearendofline(struct screen_write_ctx *);
void	 screen_write_clearstartofline(struct screen_write_ctx *);
d2007 1
a2007 1
void	 screen_write_clearendofscreen(struct screen_write_ctx *);
d2009 1
a2009 1
void	 screen_write_clearscreen(struct screen_write_ctx *);
@


1.659
log
@bind-key -c has gone, remove from man page, and unused table declarations.
@
text
@d1 1
a1 1
/* $OpenBSD: tmux.h,v 1.658 2016/10/12 14:50:14 nicm Exp $ */
d1733 1
@


1.658
log
@Drop the edit mode key tables and just use fixed key bindings for the
command prompt.
@
text
@d1 1
a1 1
/* $OpenBSD: tmux.h,v 1.657 2016/10/12 13:24:07 nicm Exp $ */
a1561 1
extern struct mode_key_tree mode_key_tree_vi_edit;
a1562 1
extern struct mode_key_tree mode_key_tree_emacs_edit;
@


1.657
log
@Redraw selection in tty_draw_line, so it appears when redrawing whole
pane. Reported by Theo Buehler.
@
text
@d1 1
a1 1
/* $OpenBSD: tmux.h,v 1.656 2016/10/12 13:03:27 nicm Exp $ */
a473 31
	/* Editing keys. */
	MODEKEYEDIT_BACKSPACE,
	MODEKEYEDIT_CANCEL,
	MODEKEYEDIT_COMPLETE,
	MODEKEYEDIT_CURSORLEFT,
	MODEKEYEDIT_CURSORRIGHT,
	MODEKEYEDIT_DELETE,
	MODEKEYEDIT_DELETELINE,
	MODEKEYEDIT_DELETETOENDOFLINE,
	MODEKEYEDIT_DELETEWORD,
	MODEKEYEDIT_ENDOFLINE,
	MODEKEYEDIT_ENTER,
	MODEKEYEDIT_HISTORYDOWN,
	MODEKEYEDIT_HISTORYUP,
	MODEKEYEDIT_NEXTSPACE,
	MODEKEYEDIT_NEXTSPACEEND,
	MODEKEYEDIT_NEXTWORD,
	MODEKEYEDIT_NEXTWORDEND,
	MODEKEYEDIT_PASTE,
	MODEKEYEDIT_PREVIOUSSPACE,
	MODEKEYEDIT_PREVIOUSWORD,
	MODEKEYEDIT_STARTOFLINE,
	MODEKEYEDIT_SWITCHMODE,
	MODEKEYEDIT_SWITCHMODEAPPEND,
	MODEKEYEDIT_SWITCHMODEAPPENDLINE,
	MODEKEYEDIT_SWITCHMODEBEGINLINE,
	MODEKEYEDIT_SWITCHMODECHANGELINE,
	MODEKEYEDIT_SWITCHMODESUBSTITUTE,
	MODEKEYEDIT_SWITCHMODESUBSTITUTELINE,
	MODEKEYEDIT_TRANSPOSECHARS,

a498 1
	int			mode;
a505 2

	int				 mode;
d1236 1
a1240 2

	struct mode_key_data prompt_mdata;
@


1.656
log
@The repeat prompt in both emacs and vi (and the old one in tmux) doesn't
support line editing and instead executes a command as soon as a
non-number key is pressed. Add a -N flag to command-prompt for the same
in copy mode. Reported by Theo Buehler.
@
text
@d1 1
a1 1
/* $OpenBSD: tmux.h,v 1.655 2016/10/11 13:45:47 nicm Exp $ */
d2063 2
@


1.655
log
@Some other stuff that can be local to one file.
@
text
@d1 1
a1 1
/* $OpenBSD: tmux.h,v 1.654 2016/10/11 13:21:59 nicm Exp $ */
d1272 1
d1924 1
a1924 1
void	 status_prompt_key(struct client *, key_code);
@


1.654
log
@Add static in window-*.c and move some internal functions out of tmux.h.
@
text
@d1 1
a1 1
/* $OpenBSD: tmux.h,v 1.653 2016/10/11 09:30:36 nicm Exp $ */
d45 1
a545 6
/* Command to string mapping. */
struct mode_key_cmdstr {
	enum mode_key_cmd	 cmd;
	const char		*name;
};

a1595 1
extern const struct mode_key_table mode_key_tables[];
a1597 1
extern struct mode_key_tree mode_key_tree_vi_copy;
a1599 1
extern struct mode_key_tree mode_key_tree_emacs_copy;
@


1.653
log
@Support double and triple clicks (they are cumulative, so double is
fired then triple), and use for select-word and select-line in copy
mode. Inspired by a different solution from Omar Sandoval.
@
text
@d1 1
a1 1
/* $OpenBSD: tmux.h,v 1.652 2016/10/11 07:23:34 nicm Exp $ */
a1522 2
const char	*getshell(void);
int		 checkshell(const char *);
a1681 1
void	tty_init_termios(int, struct termios *, struct bufferevent *);
a1685 1
void	tty_region_pane(struct tty *, const struct tty_ctx *, u_int, u_int);
a1686 1
void	tty_cursor_pane(struct tty *, const struct tty_ctx *, u_int, u_int);
a1703 1
void	tty_force_cursor_colour(struct tty *, const char *);
a1759 1
struct args	*args_create(int, ...);
a1763 1
void		 args_set(struct args *, u_char, const char *);
a1826 1
void		 cmdq_flush(struct cmd_q *);
a1909 1
void	 server_destroy_session_group(struct session *);
a1974 1
void	 grid_expand_line(struct grid *, u_int, u_int);
a2069 1
void	 screen_reflow(struct screen *, u_int);
a2082 1
int		 winlink_next_index(struct winlinks *, int);
a2125 2
struct window_pane *window_pane_create(struct window *, u_int, u_int, u_int);
void		 window_pane_destroy(struct window_pane *);
a2210 1
void	window_choose_data_free(struct window_choose_data *);
a2218 1
void	window_choose_collapse_all(struct window_pane *);
a2223 1
char	*format_window_name(struct window *);
a2279 2
void		 session_group_remove(struct session *);
u_int		 session_group_count(struct session_group *);
a2281 1
void		 session_group_synchronize1(struct session *, struct session *);
@


1.652
log
@Fundamental change to how copy mode key bindings work:

The vi-copy and emacs-copy mode key tables are gone, and instead copy
mode commands are bound in one of two normal key tables ("copy-mode" or
"copy-mode-vi"). Keys are bound to "send-keys -X copy-mode-command". So:

    bind -temacs-copy C-Up scroll-up
    bind -temacs-copy -R5 WheelUpPane scroll-up

Becomes:

    bind -Tcopy-mode C-Up send -X scroll-up
    bind -Tcopy-mode WheelUpPane send -N5 -X scroll-up

This allows the full command parser and command set to be used - for
example, we can use the normal command prompt for searching, jumping,
and so on instead of a custom one:

    bind -Tcopy-mode C-r command-prompt -p'search up' "send -X search-backward '%%'"

command-prompt also gets a -1 option to only require on key press, which
is needed for jumping.

The plan is to get rid of mode keys entirely, so more to come eventually.
@
text
@d1 1
a1 1
/* $OpenBSD: tmux.h,v 1.651 2016/10/11 07:11:40 nicm Exp $ */
d108 3
d149 6
d1228 3
d1254 2
@


1.651
log
@Support UTF-8 entry into the command prompt.
@
text
@d1 1
a1 1
/* $OpenBSD: tmux.h,v 1.650 2016/10/10 17:28:30 nicm Exp $ */
d41 1
a514 52

	/* Copy keys. */
	MODEKEYCOPY_APPENDSELECTION,
	MODEKEYCOPY_BACKTOINDENTATION,
	MODEKEYCOPY_BOTTOMLINE,
	MODEKEYCOPY_CANCEL,
	MODEKEYCOPY_CLEARSELECTION,
	MODEKEYCOPY_COPYPIPE,
	MODEKEYCOPY_COPYLINE,
	MODEKEYCOPY_COPYENDOFLINE,
	MODEKEYCOPY_COPYSELECTION,
	MODEKEYCOPY_DOWN,
	MODEKEYCOPY_ENDOFLINE,
	MODEKEYCOPY_GOTOLINE,
	MODEKEYCOPY_HALFPAGEDOWN,
	MODEKEYCOPY_HALFPAGEUP,
	MODEKEYCOPY_HISTORYBOTTOM,
	MODEKEYCOPY_HISTORYTOP,
	MODEKEYCOPY_JUMP,
	MODEKEYCOPY_JUMPAGAIN,
	MODEKEYCOPY_JUMPREVERSE,
	MODEKEYCOPY_JUMPBACK,
	MODEKEYCOPY_JUMPTO,
	MODEKEYCOPY_JUMPTOBACK,
	MODEKEYCOPY_LEFT,
	MODEKEYCOPY_MIDDLELINE,
	MODEKEYCOPY_NEXTPAGE,
	MODEKEYCOPY_NEXTPARAGRAPH,
	MODEKEYCOPY_NEXTSPACE,
	MODEKEYCOPY_NEXTSPACEEND,
	MODEKEYCOPY_NEXTWORD,
	MODEKEYCOPY_NEXTWORDEND,
	MODEKEYCOPY_OTHEREND,
	MODEKEYCOPY_PREVIOUSPAGE,
	MODEKEYCOPY_PREVIOUSPARAGRAPH,
	MODEKEYCOPY_PREVIOUSSPACE,
	MODEKEYCOPY_PREVIOUSWORD,
	MODEKEYCOPY_RECTANGLETOGGLE,
	MODEKEYCOPY_RIGHT,
	MODEKEYCOPY_SCROLLDOWN,
	MODEKEYCOPY_SCROLLUP,
	MODEKEYCOPY_SEARCHAGAIN,
	MODEKEYCOPY_SEARCHDOWN,
	MODEKEYCOPY_SEARCHREVERSE,
	MODEKEYCOPY_SEARCHUP,
	MODEKEYCOPY_SELECTLINE,
	MODEKEYCOPY_STARTNAMEDBUFFER,
	MODEKEYCOPY_STARTNUMBERPREFIX,
	MODEKEYCOPY_STARTOFLINE,
	MODEKEYCOPY_STARTSELECTION,
	MODEKEYCOPY_TOPLINE,
	MODEKEYCOPY_UP,
a527 1
	u_int				 repeat;
a530 1
	const char			*arg;
d782 4
d877 1
d1605 1
a1605 2
enum mode_key_cmd mode_key_lookup(struct mode_key_data *, key_code,
	    const char **, u_int *);
d1874 1
@


1.650
log
@Do not allow the opposite pane to resize when dragging with the mouse
because it is not possible to keep the mouse on the border when the
minimum size is reached.
@
text
@d1 1
a1 1
/* $OpenBSD: tmux.h,v 1.649 2016/10/10 13:54:47 nicm Exp $ */
d1303 1
a1303 1
	char		*prompt_buffer;
d2348 2
@


1.649
log
@Some more static.
@
text
@d1 1
a1 1
/* $OpenBSD: tmux.h,v 1.648 2016/10/09 16:24:34 nicm Exp $ */
d2220 1
a2220 1
		     int);
@


1.648
log
@Make the CLIENT_STATUS flag imply that pane status lines are redrawn if
they are enabled and break the actual screen generation code into a
separate function. Fixes problems reported by Romain Francoise.
@
text
@d1 1
a1 1
/* $OpenBSD: tmux.h,v 1.647 2016/10/05 12:34:05 nicm Exp $ */
a1800 2
int		 args_cmp(struct args_entry *, struct args_entry *);
RB_PROTOTYPE(args_tree, args_entry, entry, args_cmp);
@


1.647
log
@Keep buffer creation time and add accessors for it and the order number.
@
text
@d1 1
a1 1
/* $OpenBSD: tmux.h,v 1.646 2016/09/28 08:30:44 nicm Exp $ */
d2100 1
@


1.646
log
@Rate limit TIOCSWINSZ on a timer to avoid programs getting hammered with
SIGWINCH when the size changes rapidly. To help a problem reported by
Rui Pinheiro.
@
text
@d1 1
a1 1
/* $OpenBSD: tmux.h,v 1.645 2016/09/16 13:43:41 nicm Exp $ */
d1590 2
@


1.645
log
@Swap watermarks from high (4096) to low (128) when we get full buffers
into the read callback several times in succession; swap back when we
see empty buffers several times. This hopefully limits how much programs
that print a lot for a long period can monopolize tmux (like large, fast
compiling), without penalizing programs that print a lot briefly (like
most curses applications). Helps a lot for me, the actual numbers may
need tweaking later.
@
text
@d1 1
a1 1
/* $OpenBSD: tmux.h,v 1.644 2016/09/12 15:40:58 nicm Exp $ */
d896 2
@


1.644
log
@Allow repeat count to be specified in mode key tables with bind-key -R,
and set the default repeat count to 5 for WheelUp and WheelDown in
copy-mode.
@
text
@d1 1
a1 1
/* $OpenBSD: tmux.h,v 1.643 2016/09/04 17:37:06 nicm Exp $ */
d62 12
a73 2
/* The maximum amount of data to hold from a pty (the event high watermark). */
#define READ_SIZE 4096
d896 3
@


1.643
log
@Add support for performing a full width split (with splitw -f), rather
than splitting the current cell. From Stephen Kent.
@
text
@d1 1
a1 1
/* $OpenBSD: tmux.h,v 1.642 2016/09/02 20:57:20 nicm Exp $ */
d569 1
d1637 1
a1637 1
	    const char **);
@


1.642
log
@Remember the number of lines scrolled into the history (versus cleared
into the history) and when resizing only use scrolled lines and not
cleared lines (which are probably not intended to reappear). From
Chaoren Lin.
@
text
@d1 1
a1 1
/* $OpenBSD: tmux.h,v 1.641 2016/08/03 09:07:02 nicm Exp $ */
d2208 1
a2208 1
		     int, int);
@


1.641
log
@Fix minimum size when pane status line is enabled, reported by Y Petremann.
@
text
@d1 1
a1 1
/* $OpenBSD: tmux.h,v 1.640 2016/07/15 09:52:34 nicm Exp $ */
d694 1
@


1.640
log
@Tweak output of environment logging.
@
text
@d1 1
a1 1
/* $OpenBSD: tmux.h,v 1.639 2016/07/15 09:28:32 nicm Exp $ */
d2188 1
a2188 1
void		 layout_destroy_cell(struct layout_cell *,
d2196 2
a2197 3
u_int		 layout_resize_check(struct layout_cell *, enum layout_type);
void		 layout_resize_adjust(struct layout_cell *, enum layout_type,
		     int);
@


1.639
log
@Log environment to new panes.
@
text
@d1 1
a1 1
/* $OpenBSD: tmux.h,v 1.638 2016/07/15 00:49:08 nicm Exp $ */
d1696 1
a1696 1
void	environ_log(struct environ *);
@


1.638
log
@Don't update cells in each block of data read from a pane immediately,
instead track them as change (dirty) and update them once at the end,
saves much time if repeatedly writing the same cell. Also fix comparison
of cells being equal in a few places (memcmp is not enough).
@
text
@d1 1
a1 1
/* $OpenBSD: tmux.h,v 1.637 2016/07/15 00:42:56 nicm Exp $ */
d1696 1
@


1.637
log
@Instead of representing colours in several different forms with various
cell flags, convert to use an int with flags marking 256 or RGB colours
in the top byte (except in cells, which we don't want to make any
bigger). From Brad Town.
@
text
@d1 1
a1 1
/* $OpenBSD: tmux.h,v 1.636 2016/06/16 10:55:47 nicm Exp $ */
d63 1
a63 1
#define READ_SIZE 128
d651 1
d773 3
a775 1
	char		*title;
d777 2
a778 1
	struct grid	*grid;		/* grid data */
d780 2
a781 2
	u_int		 cx;		/* cursor x */
	u_int		 cy;		/* cursor y */
d783 2
a784 2
	u_int		 cstyle;	/* cursor style */
	char		*ccolour;	/* cursor colour string */
d786 1
a786 2
	u_int		 rupper;	/* scroll region top */
	u_int		 rlower;	/* scroll region bottom */
d788 1
a788 1
	int		 mode;
d790 2
a791 1
	bitstr_t	*tabs;
d793 1
a793 1
	struct screen_sel sel;
d798 7
a804 2
	struct window_pane *wp;
	struct screen	*s;
a1209 1
	u_int		 last_width;
d1993 1
@


1.636
log
@Allow a command to be specified to display-panes, similar to
command-prompt, rather than always just selecting the pane.
@
text
@d1 1
a1 1
/* $OpenBSD: tmux.h,v 1.635 2016/06/15 09:13:46 nicm Exp $ */
d628 4
d647 1
a647 3
#define GRID_FLAG_FGRGB 0x10
#define GRID_FLAG_BGRGB 0x20
#define GRID_FLAG_SELECTED 0x40
a651 7
/* Grid cell RGB colours. */
struct grid_cell_rgb {
	u_char	r;
	u_char	g;
	u_char	b;
};

d656 2
a657 8
	union {
		u_char		fg;
		struct grid_cell_rgb	fg_rgb;
	};
	union {
		u_char		bg;
		struct grid_cell_rgb	bg_rgb;
	};
d1973 2
a1974 2
void	 colour_set_fg(struct grid_cell *, int);
void	 colour_set_bg(struct grid_cell *, int);
d1976 1
a1976 1
int	 colour_fromstring(const char *);
@


1.635
log
@Copy mode needs to keep the original grid intact so it can copy from it
if needed, so it disables reading from the pane. This can be problem
with some programs. So make tmux automatically exit all modes after 180
seconds of inactivity and if there is pending output.
@
text
@d1 1
a1 1
/* $OpenBSD: tmux.h,v 1.634 2016/06/06 07:28:52 nicm Exp $ */
d1280 2
d1942 1
a1942 1
void	 server_clear_identify(struct client *);
@


1.634
log
@Cache selected state so that cells going from selected to unselected are not
skipped, reported by Omar Sandoval.
@
text
@d1 1
a1 1
/* $OpenBSD: tmux.h,v 1.633 2016/06/06 07:24:31 nicm Exp $ */
d826 1
d909 2
@


1.633
log
@Insert new panes after the pane being split in the list rather than
always after the active pane. This is more sensible when doing it with
commands rather than keys.
@
text
@d1 1
a1 1
/* $OpenBSD: tmux.h,v 1.632 2016/05/30 09:50:20 nicm Exp $ */
d645 1
@


1.632
log
@Cache the window styles and do not look up the window-style options
unless they have changed.
@
text
@d1 1
a1 1
/* $OpenBSD: tmux.h,v 1.631 2016/05/27 17:05:42 nicm Exp $ */
d2133 2
a2134 1
struct window_pane *window_add_pane(struct window *, u_int);
@


1.631
log
@Use getprogname() instead of __progname to make portability easier.
@
text
@d1 1
a1 1
/* $OpenBSD: tmux.h,v 1.630 2016/05/12 16:05:33 tim Exp $ */
d946 1
d950 3
@


1.630
log
@- Rework load_cfg() error handling a little.
- Add -q to source-file to suppress errors about nonexistent files.

Input and OK nicm@@
@
text
@d1 1
a1 1
/* $OpenBSD: tmux.h,v 1.629 2016/05/01 13:39:05 nicm Exp $ */
a38 1
extern char    *__progname;
@


1.629
log
@Use the same code for half page scrolling as full, from Michal Mazurek.
@
text
@d1 1
a1 1
/* $OpenBSD: tmux.h,v 1.628 2016/04/30 18:59:02 nicm Exp $ */
d1558 1
a1558 1
int		 load_cfg(const char *, struct cmd_q *, char **);
@


1.628
log
@tty_client_ready can not be internal to tty.c again.
@
text
@d1 1
a1 1
/* $OpenBSD: tmux.h,v 1.627 2016/04/29 15:00:48 nicm Exp $ */
d2222 1
a2222 1
void		 window_copy_pageup(struct window_pane *);
@


1.627
log
@Add option to include status text in the pane borders. If
pane-border-status is set to "top" or "bottom" (rather than "off"),
every pane has a permanent top or bottom border containing the text from
pane-border-format.

Based on a diff sent long ago by Jonathan Slenders, mostly rewritten and
simplified by me.
@
text
@d1 1
a1 1
/* $OpenBSD: tmux.h,v 1.626 2016/04/29 13:36:10 nicm Exp $ */
a1727 1
int	tty_client_ready(struct client *, struct window_pane *wp);
@


1.626
log
@The backoff timer is causing no end of trouble with disconnected clients
stopping data in attached ones. So get rid of it and see how we get on
with just a high watermark on each pane.
@
text
@d1 1
a1 1
/* $OpenBSD: tmux.h,v 1.625 2016/04/29 13:21:33 nicm Exp $ */
d896 3
@


1.625
log
@Make the grid_cell passed into screen_write_* const.
@
text
@d1 1
a1 1
/* $OpenBSD: tmux.h,v 1.624 2016/04/27 09:39:09 nicm Exp $ */
d63 2
a64 9
/*
 * READ_SIZE is the maximum size of data to hold from a pty (the event high
 * watermark). READ_BACKOFF is the amount of data waiting to be output to a tty
 * before pty reads will be backed off. READ_TIME is how long to back off
 * before the next read (in microseconds) if a tty is above READ_BACKOFF.
 */
#define READ_SIZE 1024
#define READ_BACKOFF 512
#define READ_TIME 100
a884 1
	struct event	 timer;
@


1.624
log
@Add next/previous paragraph, from J Raynor.
@
text
@d1 1
a1 1
/* $OpenBSD: tmux.h,v 1.623 2016/03/18 07:28:27 nicm Exp $ */
d2037 1
a2037 1
	     ssize_t, struct grid_cell *, const char *, ...);
d2040 1
a2040 1
	     struct grid_cell *, const char *, ...);
d2042 1
a2042 1
	     ssize_t, struct grid_cell *, const char *, ...);
d2044 2
a2045 2
	     struct grid_cell *, const char *, va_list);
void	 screen_write_putc(struct screen_write_ctx *, struct grid_cell *,
@


1.623
log
@Instead of reusing MouseUp at the finish of a drag, add a new key
MouseDragEnd. It can be useful to bind them separately in copy mode.
@
text
@d1 1
a1 1
/* $OpenBSD: tmux.h,v 1.622 2016/03/02 15:36:02 nicm Exp $ */
d539 1
d546 1
@


1.622
log
@Handle wcwidth() and mbtowc() failures in better style and drop
characters where we can't find the width (wcwidth() fails) on input, the
same as we drop invalid UTF-8. Suggested by schwarze@@.
@
text
@d1 1
a1 1
/* $OpenBSD: tmux.h,v 1.621 2016/03/01 12:02:08 nicm Exp $ */
d138 3
@


1.621
log
@Use system wcwidth() instead of carrying around UTF-8 width tables.
@
text
@d1 1
a1 1
/* $OpenBSD: tmux.h,v 1.620 2016/01/31 09:57:41 nicm Exp $ */
d2319 1
a2319 2
u_int		 utf8_width(wchar_t);
wchar_t		 utf8_combine(const struct utf8_data *);
@


1.620
log
@Whoops, need this for the previous reverse trim commit too.
@
text
@d1 1
a1 1
/* $OpenBSD: tmux.h,v 1.619 2016/01/29 11:13:56 nicm Exp $ */
d35 1
a2314 1
u_int		 utf8_width(u_int);
d2319 3
a2321 3
u_int		 utf8_combine(const struct utf8_data *);
enum utf8_state	 utf8_split(u_int, struct utf8_data *);
u_int		 utf8_split2(u_int, u_char *);
@


1.619
log
@Support for RGB colour, using the extended cell mechanism to avoid
wasting unnecessary space. The 'Tc' flag must be set in the external
TERM entry (using terminal-overrides or a custom terminfo entry), if not
tmux will map to the closest of the 256 or 16 colour palettes.

Mostly from Suraj N Kurapati, based on a diff originally by someone else.
@
text
@d1 1
a1 1
/* $OpenBSD: tmux.h,v 1.618 2016/01/19 16:01:30 nicm Exp $ */
d2327 1
@


1.618
log
@Split out getting the current state from the target search so it can be
replaced if we already know the current.
@
text
@d1 1
a1 1
/* $OpenBSD: tmux.h,v 1.617 2016/01/19 15:59:12 nicm Exp $ */
d388 1
d645 2
d651 7
d662 8
a669 2
	u_char			fg;
	u_char			bg;
@


1.617
log
@I no longer use my SourceForge address so replace it.
@
text
@d1 1
a1 1
/* $OpenBSD: tmux.h,v 1.616 2016/01/16 00:36:53 nicm Exp $ */
d1772 5
a1776 2
int		 cmd_find_target(struct cmd_find_state *, struct cmd_q *,
		     const char *, enum cmd_find_type, int);
d1799 2
a1800 1
int		 cmd_prepare_state(struct cmd *, struct cmd_q *);
@


1.616
log
@Add hooks for alerts (bell, silence, activity), from Thomas Adam.
@
text
@d1 1
a1 1
/* $OpenBSD: tmux.h,v 1.615 2016/01/15 11:31:47 nicm Exp $ */
d4 1
a4 1
 * Copyright (c) 2007 Nicholas Marriott <nicm@@users.sourceforge.net>
@


1.615
log
@A couple of missing printflike attributes, from Andrey Starodubtsev.
@
text
@d1 1
a1 1
/* $OpenBSD: tmux.h,v 1.614 2015/12/16 22:05:35 nicm Exp $ */
d1783 2
@


1.614
log
@send-keys -R should reset the input parser to ground state (so it can be
used to escape from, for example, printf '\033]2;').
@
text
@d1 1
a1 1
/* $OpenBSD: tmux.h,v 1.613 2015/12/16 21:50:37 nicm Exp $ */
d1543 1
a1543 1
void		 cfg_add_cause(const char *, ...);
@


1.613
log
@Add infrastructure to work out the best target given a pane or window
alone and use it to add pane_died and pane_exited hooks.
@
text
@d1 1
a1 1
/* $OpenBSD: tmux.h,v 1.612 2015/12/15 13:43:07 nicm Exp $ */
d1940 1
a1940 1
void	 input_reset(struct window_pane *);
@


1.612
log
@Some hooks API changes to fire a hook while waiting another cmdq and
infrastructure that will be needed soon.
@
text
@d1 1
a1 1
/* $OpenBSD: tmux.h,v 1.611 2015/12/15 00:00:01 nicm Exp $ */
d1382 1
d1580 1
d1589 4
a1592 4
int printflike(3, 4) hooks_run(struct hooks *, struct client *, const char *,
		    ...);
int printflike(3, 4) hooks_wait(struct hooks *, struct cmd_q *, const char *,
		    ...);
d1781 5
d1906 1
a1906 1
void	 server_destroy_pane(struct window_pane *);
@


1.611
log
@Make the marked pane a cmd_find_state.
@
text
@d1 1
a1 1
/* $OpenBSD: tmux.h,v 1.610 2015/12/14 23:30:58 nicm Exp $ */
d1371 2
d1380 1
d1587 4
a1590 1
void		 hooks_run(struct hooks *, const char *, struct client *);
@


1.610
log
@Use cmd_find_clear_state instead of an extra function doing the same.
@
text
@d1 1
a1 1
/* $OpenBSD: tmux.h,v 1.609 2015/12/14 00:31:54 nicm Exp $ */
d1769 3
d1850 1
a1850 3
extern struct session *marked_session;
extern struct winlink *marked_winlink;
extern struct window_pane *marked_window_pane;
@


1.609
log
@Instead of combined flags for -c, -s, -t, split into different sets
using an enum and simplify the parsing code.
@
text
@d1 1
a1 1
/* $OpenBSD: tmux.h,v 1.608 2015/12/13 21:53:57 nicm Exp $ */
d1767 3
@


1.608
log
@Use member names in cmd_entry definitions so I stop getting confused
about the order.
@
text
@d1 1
a1 1
/* $OpenBSD: tmux.h,v 1.607 2015/12/13 18:31:47 nicm Exp $ */
d1390 24
d1424 1
d1426 3
a1428 1
	const char		*usage;
d1432 1
a1432 19
#define CMD_SESSION_T 0x4
#define CMD_SESSION_S 0x8
#define CMD_WINDOW_T 0x10
#define CMD_WINDOW_S 0x20
#define CMD_PANE_T 0x40
#define CMD_PANE_S 0x80
#define CMD_CLIENT_T 0x100
#define CMD_CLIENT_C 0x200
#define CMD_INDEX_T 0x400
#define CMD_INDEX_S 0x800
#define CMD_CANFAIL 0x1000
#define CMD_PREFERUNATTACHED 0x2000
#define CMD_MOVEW_R 0x4000 /* for movew -r only */
#define CMD_PANE_MARKED_S 0x8000
#define CMD_PANE_MARKED_T 0x10000
#define CMD_WINDOW_MARKED_T 0x20000
#define CMD_WINDOW_MARKED_S 0x40000
#define CMD_CLIENT_CANFAIL 0x80000
	int			 flags;
a1435 4
#define CMD_ALL_T (CMD_SESSION_T|CMD_WINDOW_T|CMD_PANE_T|CMD_INDEX_T| \
    CMD_MOVEW_R|CMD_PANE_MARKED_T|CMD_WINDOW_MARKED_T)
#define CMD_ALL_S (CMD_SESSION_S|CMD_WINDOW_S|CMD_PANE_S|CMD_INDEX_S| \
    CMD_PANE_MARKED_S|CMD_WINDOW_MARKED_S)
@


1.607
log
@-c needs to be able for fail for display-message.
@
text
@d1 1
a1 1
/* $OpenBSD: tmux.h,v 1.606 2015/12/13 17:55:14 nicm Exp $ */
d1392 2
a1393 2
	const char	*name;
	const char	*alias;
d1395 5
a1399 3
	const char	*args_template;
	int		 args_lower;
	int		 args_upper;
d1401 1
a1401 1
	const char	*usage;
d1423 1
a1423 1
	int		 flags;
d1425 1
a1425 1
	enum cmd_retval	 (*exec)(struct cmd *, struct cmd_q *);
@


1.606
log
@Use struct cmd_find_state directly and remove cmd_state_flag, also
change so that winlink is set even if an index is too.
@
text
@d1 1
a1 1
/* $OpenBSD: tmux.h,v 1.605 2015/12/13 16:44:35 nicm Exp $ */
d1420 1
@


1.605
log
@Change cmd_find_target to use a state struct from the caller.
@
text
@d1 1
a1 1
/* $OpenBSD: tmux.h,v 1.604 2015/12/13 15:32:12 nicm Exp $ */
d1296 15
a1310 5
/* Context for a command about to be executed. */
struct cmd_state_flag {
	struct session		*s;
	struct winlink		*wl;
	struct window_pane	*wp;
d1312 9
d1322 1
a1322 1
};
d1325 2
a1326 2
	struct cmd_state_flag	 tflag;
	struct cmd_state_flag	 sflag;
a1427 26

/* Command find structures. */
enum cmd_find_type {
	CMD_FIND_PANE,
	CMD_FIND_WINDOW,
	CMD_FIND_SESSION,
};
struct cmd_find_state {
	struct cmd_q		*cmdq;
	int			 flags;
	struct cmd_find_state	*current;

	struct session          *s;
	struct winlink          *wl;
	struct window		*w;
	struct window_pane      *wp;
	int			 idx;
};

/* Command fine flags. */
#define CMD_FIND_PREFER_UNATTACHED 0x1
#define CMD_FIND_QUIET 0x2
#define CMD_FIND_WINDOW_INDEX 0x4
#define CMD_FIND_DEFAULT_MARKED 0x8
#define CMD_FIND_EXACT_SESSION 0x10
#define CMD_FIND_EXACT_WINDOW 0x20
@


1.604
log
@Remove the cmd_find_{session,window,pane,index} functions (which are
just wrappers around cmd_find_target) and just use cmd_find_target
directly.
@
text
@d1 1
a1 1
/* $OpenBSD: tmux.h,v 1.603 2015/12/13 14:32:38 nicm Exp $ */
d1763 2
a1764 2
struct cmd_find_state *cmd_find_target(struct cmd_q *, const char *,
		     enum cmd_find_type, int);
@


1.603
log
@Instead of every command resolving the target (-t or -s) itself, prepare
the state (client, session, winlink, pane) for it it before entering the
command. Each command provides some flags that tell the prepare step
what it is expecting.

This is a requirement for having hooks on commands (for example, if you
hook "select-window -t1:2", the hook command should to operate on window
1:2 not whatever it thinks is the current window), and should allow some
other target improvements.

The old cmd_find_* functions remain for the moment but that layer will
be dropped later.

Joint work with Thomas Adam.
@
text
@d1 1
a1 1
/* $OpenBSD: tmux.h,v 1.602 2015/12/12 18:32:24 nicm Exp $ */
d1410 26
d1763 2
a1764 10
struct session	*cmd_find_current(struct cmd_q *);
struct session	*cmd_find_session(struct cmd_q *, const char *, int);
struct winlink	*cmd_find_window(struct cmd_q *, const char *,
		     struct session **);
struct winlink	*cmd_find_window_marked(struct cmd_q *, const char *,
		     struct session **);
struct winlink	*cmd_find_pane(struct cmd_q *, const char *, struct session **,
		     struct window_pane **);
struct winlink	*cmd_find_pane_marked(struct cmd_q *, const char *,
		     struct session **, struct window_pane **);
a1765 2
int		 cmd_find_index(struct cmd_q *, const char *,
		     struct session **);
@


1.602
log
@Add key-table option to set the default key table for a session, allows
different key bindings for different sessions and a few other things.
@
text
@d1 1
a1 1
/* $OpenBSD: tmux.h,v 1.601 2015/12/12 18:19:00 nicm Exp $ */
d1296 14
d1360 2
d1384 17
d1405 4
d1758 1
d1769 2
a1770 2
enum cmd_retval	 cmd_attach_session(struct cmd_q *, const char *, int, int,
		     const char *, int);
@


1.601
log
@Allow prefix and prefix2 to be set to None to disable (useful if you
would rather bind the prefix in the root table).
@
text
@d1 1
a1 1
/* $OpenBSD: tmux.h,v 1.600 2015/12/11 16:37:21 nicm Exp $ */
d1803 2
@


1.600
log
@Style nits and line wrapping of function declarations.
@
text
@d1 1
a1 1
/* $OpenBSD: tmux.h,v 1.599 2015/12/11 15:46:57 nicm Exp $ */
d88 1
@


1.599
log
@We cannot do hooks_find and then hooks_remove because it might have come
from the parent (global) tree, instead make it remove by name like options.

While here, also tidy up a few bits of options and hooks handling (use
RB_FOREACH_SAFE, and a helper function for the free).
@
text
@d1 1
a1 1
/* $OpenBSD: tmux.h,v 1.598 2015/12/11 12:27:36 nicm Exp $ */
d1667 4
a1670 4
const char	*tty_term_string2(
		     struct tty_term *, enum tty_code_code, int, int);
const char	*tty_term_ptr1(
		     struct tty_term *, enum tty_code_code, const void *);
d1907 2
a1908 2
void	 grid_duplicate_lines(
	     struct grid *, u_int, struct grid *, u_int, u_int);
d2059 2
a2060 2
int		 window_pane_set_mode(
		     struct window_pane *, const struct window_mode *);
d2065 2
a2066 2
char		*window_pane_search(
		     struct window_pane *, const char *, u_int *);
d2082 5
a2086 5
void		 layout_destroy_cell(struct layout_cell *, struct layout_cell **);
void		 layout_set_size(
		     struct layout_cell *, u_int, u_int, u_int, u_int);
void		 layout_make_leaf(
		     struct layout_cell *, struct window_pane *);
d2091 2
a2092 2
void		 layout_resize_adjust(
		     struct layout_cell *, enum layout_type, int);
d2101 2
a2102 2
struct layout_cell *layout_split_pane(
		     struct window_pane *, enum layout_type, int, int);
@


1.598
log
@Add cmdq as an argument to format_create and add a format for the
command name (will also be used for more later).
@
text
@d1 1
a1 1
/* $OpenBSD: tmux.h,v 1.597 2015/12/08 08:34:18 nicm Exp $ */
d706 1
a706 1
	char		*name;
d1517 1
a1517 1
void		 hooks_remove(struct hooks *, struct hook *);
@


1.597
log
@Remove format_create_flags and just pass flags to format_create.
@
text
@d1 1
a1 1
/* $OpenBSD: tmux.h,v 1.596 2015/12/08 08:14:04 nicm Exp $ */
d1495 1
a1495 1
struct format_tree *format_create(int);
@


1.596
log
@Spacing nits.
@
text
@d1 1
a1 1
/* $OpenBSD: tmux.h,v 1.595 2015/12/08 01:10:31 nicm Exp $ */
d1495 1
a1495 2
struct format_tree *format_create(void);
struct format_tree *format_create_flags(int);
@


1.595
log
@Add hooks infrastructure, basic commands (set-hook, show-hooks) and a
couple of not very useful client hooks. This will eventually let
commands be run at various points and on notifications. Joint work with
Thomas Adam.
@
text
@d1 1
a1 1
/* $OpenBSD: tmux.h,v 1.594 2015/12/07 09:47:41 nicm Exp $ */
d696 6
a701 4
	const char      *name;
	struct cmd_q    *cmdq;
	struct cmd_list *cmdlist;
	RB_ENTRY(hook)   entry;
@


1.594
log
@Fix bell indicators across detach, reported by Torbjorn Lonnemark, diff
from Thomas Adam.
@
text
@d1 1
a1 1
/* $OpenBSD: tmux.h,v 1.593 2015/11/27 15:06:43 nicm Exp $ */
d694 8
d1022 1
d1439 5
a1443 4
extern struct options *global_options;
extern struct options *global_s_options;
extern struct options *global_w_options;
extern struct environ *global_environ;
d1508 12
d1807 1
@


1.593
log
@Do not set a limit on the length of commands when printing them.
@
text
@d1 1
a1 1
/* $OpenBSD: tmux.h,v 1.592 2015/11/24 23:46:15 nicm Exp $ */
d1760 1
@


1.592
log
@Make environ_set va_args and use it to tidy up some calls. Also add a
missing word in manpage (from jmc).
@
text
@d1 1
a1 1
/* $OpenBSD: tmux.h,v 1.591 2015/11/24 23:22:51 nicm Exp $ */
d1668 1
a1668 1
size_t		 args_print(struct args *, char *, size_t);
d1697 1
a1697 1
size_t		 cmd_print(struct cmd *, char *, size_t);
d1713 1
a1713 1
size_t		 cmd_list_print(struct cmd_list *, char *, size_t);
@


1.591
log
@Shell command from -c doesn't have to be global, pass it as an argument.
@
text
@d1 1
a1 1
/* $OpenBSD: tmux.h,v 1.590 2015/11/24 22:27:22 nicm Exp $ */
d1570 3
a1572 1
void	environ_set(struct environ *, const char *, const char *);
d1744 1
a1744 1
struct	 key_table *key_bindings_get_table(const char *, int);
@


1.590
log
@Tidy the code that works out the socket path, and just use the full path
in the global socket_path rather than copying it.
@
text
@d1 1
a1 1
/* $OpenBSD: tmux.h,v 1.589 2015/11/24 21:52:06 nicm Exp $ */
a1433 1
extern char		*shell_cmd;
d1734 1
a1734 1
int	client_main(struct event_base *, int, char **, int);
@


1.589
log
@Remove the -I part of show-messages which isn't really that useful; the
server start time can now be accessed with a new start_time format (use:
tmux display -p '#{t:start_time}')
@
text
@d1 1
a1 1
/* $OpenBSD: tmux.h,v 1.588 2015/11/24 21:19:46 nicm Exp $ */
d1436 1
a1436 1
extern char		 socket_path[PATH_MAX];
@


1.588
log
@Make the log stuff a bit tidier with some helper functions.
@
text
@d1 1
a1 1
/* $OpenBSD: tmux.h,v 1.587 2015/11/24 09:34:55 nicm Exp $ */
d1434 3
a1436 3
extern char	*shell_cmd;
extern time_t	 start_time;
extern char	 socket_path[PATH_MAX];
@


1.587
log
@Don't allow options in table without scope set.
@
text
@d1 1
a1 1
/* $OpenBSD: tmux.h,v 1.586 2015/11/23 23:47:57 nicm Exp $ */
a1434 1
extern int	 debug_level;
a1436 1
void		 logfile(const char *);
d2211 4
a2214 2
void		 log_open(const char *);
void		 log_close(void);
@


1.586
log
@Partly revert previous, it is harmless to keep support for UTF-8 mouse
mode inside tmux, just no longer support it for tmux itself.
@
text
@d1 1
a1 1
/* $OpenBSD: tmux.h,v 1.585 2015/11/23 20:53:09 nicm Exp $ */
d1397 1
@


1.585
log
@Remove support for the UTF-8 mouse extension. This was a briefly used,
poor idea that was fairly quickly replaced by SGR mouse input (which is
now widespread). It is impossible to tell the difference between UTF-8
and non-UTF-8 mouse input; since the mouse-utf8 option was removed tmux
has not handled it correctly in any case; and it is ridiculous to have
three different forms of mouse input.
@
text
@d1 1
a1 1
/* $OpenBSD: tmux.h,v 1.584 2015/11/20 12:01:19 nicm Exp $ */
d602 1
a602 1
/* 0x100 unused */
@


1.584
log
@Instead of separate tables for different types of options, give each
option a scope type (server, session, window) in one table.
@
text
@d1 1
a1 1
/* $OpenBSD: tmux.h,v 1.583 2015/11/19 22:46:46 nicm Exp $ */
d602 1
a602 1
#define MODE_MOUSE_UTF8 0x100
@


1.583
log
@Only assume pasting with at least two characters, reduces problems for
people who can type ^B c very fast, or who are using tmux inside
something else that buffers.
@
text
@d1 1
a1 1
/* $OpenBSD: tmux.h,v 1.582 2015/11/18 14:27:44 nicm Exp $ */
d1396 5
d1403 3
a1405 2
	const char	       *name;
	enum options_table_type	type;
d1407 3
a1409 3
	u_int			minimum;
	u_int			maximum;
	const char	      **choices;
d1411 2
a1412 2
	const char	       *default_str;
	long long		default_num;
d1414 1
a1414 1
	const char	       *style;
d1552 2
a1553 5
extern const struct options_table_entry server_options_table[];
extern const struct options_table_entry session_options_table[];
extern const struct options_table_entry window_options_table[];
void	options_table_populate_tree(const struct options_table_entry *,
	    struct options *);
d1556 1
a1556 2
int	options_table_find(const char *, const struct options_table_entry **,
	    const struct options_table_entry **);
@


1.582
log
@Use __unused rather than rolling our own.
@
text
@d1 1
a1 1
/* $OpenBSD: tmux.h,v 1.581 2015/11/18 13:06:54 nicm Exp $ */
d36 2
a49 2
#include "xmalloc.h"

d1017 1
d1151 1
a1151 1
/* TTY command context and function pointer. */
@


1.581
log
@Sync the entire xmalloc.[ch] with the other users, but with the addition
of xrealloc, xvasprintf, xvsnprintf.
@
text
@d1 1
a1 1
/* $OpenBSD: tmux.h,v 1.580 2015/11/15 22:50:38 nicm Exp $ */
a70 3

/* Definition to shut gcc up about unused arguments. */
#define unused __attribute__ ((unused))
@


1.580
log
@Make key_code unsigned long long not uint64_t which is more portable for
printf formats, and move UTF8_SIZE define down to near the rest of the
UTF-8 bits.
@
text
@d1 1
a1 1
/* $OpenBSD: tmux.h,v 1.579 2015/11/14 11:45:43 nicm Exp $ */
d48 2
a71 4
/* Fatal errors. */
#define fatal(msg) log_fatal("%s: %s", __func__, msg);
#define fatalx(msg) log_fatalx("%s: %s", __func__, msg);

d2215 2
a2216 13
__dead void printflike(1, 2) log_fatal(const char *, ...);
__dead void printflike(1, 2) log_fatalx(const char *, ...);

/* xmalloc.c */
char		*xstrdup(const char *);
void		*xcalloc(size_t, size_t);
void		*xmalloc(size_t);
void		*xrealloc(void *, size_t);
void		*xreallocarray(void *, size_t, size_t);
int printflike(2, 3) xasprintf(char **, const char *, ...);
int		 xvasprintf(char **, const char *, va_list);
int printflike(3, 4) xsnprintf(char *, size_t, const char *, ...);
int		 xvsnprintf(char *, size_t, const char *, va_list);
@


1.579
log
@All these return values from utf8_* are confusing, use an enum.
@
text
@d1 1
a1 1
/* $OpenBSD: tmux.h,v 1.578 2015/11/14 10:56:31 nicm Exp $ */
a60 6
 * UTF-8 data size. This must be big enough to hold combined characters as well
 * as single.
 */
#define UTF8_SIZE 9

/*
d122 1
a122 1
typedef uint64_t key_code;
d614 5
a618 1
/* A single UTF-8 character. */
@


1.578
log
@Be more strict about invalid UTF-8.
@
text
@d1 1
a1 1
/* $OpenBSD: tmux.h,v 1.577 2015/11/14 09:41:07 nicm Exp $ */
d629 5
d2199 2
a2200 2
int		 utf8_open(struct utf8_data *, u_char);
int		 utf8_append(struct utf8_data *, u_char);
d2202 1
a2202 1
int		 utf8_split(u_int, struct utf8_data *);
@


1.577
log
@Push stdout and stderr to clients more aggressively, and add an event to
continue if the send fails.
@
text
@d1 1
a1 1
/* $OpenBSD: tmux.h,v 1.576 2015/11/13 08:09:28 nicm Exp $ */
d627 1
a627 1
	u_char	width;
@


1.576
log
@Long overdue change to the way we store cells in the grid: now, instead
of storing a full grid_cell with UTF-8 data and everything, store a new
type grid_cell_entry. This can either be the cell itself (for ASCII
cells), or an offset into an extended array (per line) for UTF-8
data.

This avoid a large (8 byte) overhead on non-UTF-8 cells (by far the
majority for most users) without the complexity of the shadow array we
had before. Grid memory without any UTF-8 is about half.

The disadvantage that cells can no longer be modified in place and need
to be copied out of the grid and back but it turned out to be lot less
complicated than I expected.
@
text
@d1 1
a1 1
/* $OpenBSD: tmux.h,v 1.575 2015/11/12 12:43:36 nicm Exp $ */
d1784 2
a1810 2
void	 server_push_stdout(struct client *);
void	 server_push_stderr(struct client *);
@


1.575
log
@Add utf8_padcstr and use it to align columns in list-keys.
@
text
@d1 1
a1 1
/* $OpenBSD: tmux.h,v 1.574 2015/11/12 12:19:57 nicm Exp $ */
d624 2
a625 2
	size_t	have;
	size_t	size;
d627 2
a628 2
	u_int	width;
};
d644 1
d651 18
a668 7
	u_char	attr;
	u_char	flags;
	u_char	fg;
	u_char	bg;

	u_char	xstate; /* top 4 bits width, bottom 4 bits size */
	u_char	xdata[UTF8_SIZE];
d673 5
a677 2
	u_int	cellsize;
	struct grid_cell *celldata;
d679 1
a679 1
	int	flags;
d684 2
a685 2
	int	flags;
#define GRID_HISTORY 0x1	/* scroll lines into history */
d687 2
a688 2
	u_int	sx;
	u_int	sy;
d690 2
a691 2
	u_int	hsize;
	u_int	hlimit;
d693 1
a693 1
	struct grid_line *linedata;
a1871 1
const struct grid_cell *grid_peek_cell(struct grid *, u_int, u_int);
d1873 1
a1873 1
struct grid_cell *grid_get_cell(struct grid *, u_int, u_int);
a1884 6
/* grid-cell.c */
u_int	 grid_cell_width(const struct grid_cell *);
void	 grid_cell_get(const struct grid_cell *, struct utf8_data *);
void	 grid_cell_set(struct grid_cell *, const struct utf8_data *);
void	 grid_cell_one(struct grid_cell *, u_char);

d1886 3
a1888 4
const struct grid_cell *grid_view_peek_cell(struct grid *, u_int, u_int);
struct grid_cell *grid_view_get_cell(struct grid *, u_int, u_int);
void	 grid_view_set_cell(
	     struct grid *, u_int, u_int, const struct grid_cell *);
d2193 1
@


1.574
log
@Tidy utf8.c a little: build table on first use, and make utf8_width take
a u_int rather than splitting and then combining again in utf8_split.
@
text
@d1 1
a1 1
/* $OpenBSD: tmux.h,v 1.573 2015/11/12 11:10:50 nicm Exp $ */
d2197 1
@


1.573
log
@If we know the terminal outside tmux is not UTF-8, replace UTF-8 in
error messages and whatnot with underscores the same as we do when we
draw UTF-8 characters as part of the screen.
@
text
@d1 1
a1 1
/* $OpenBSD: tmux.h,v 1.572 2015/11/12 11:09:11 nicm Exp $ */
d2184 1
a2184 1
void		 utf8_build(void);
@


1.572
log
@Nuke the utf8 and status-utf8 options and make tmux only a UTF-8
terminal. We still support non-UTF-8 terminals outside tmux, but inside
it is always UTF-8 (as when the utf8 and status-utf8 options were on).
@
text
@d1 1
a1 1
/* $OpenBSD: tmux.h,v 1.571 2015/11/12 11:05:34 nicm Exp $ */
d2192 1
@


1.571
log
@Support UTF-8 key bindings by expanding the key type from int to
uint64_t and converting UTF-8 to Unicode on input and the reverse on
output. (This allows key bindings, there are still omissions - the
largest being that the various prompts do not accept UTF-8.)
@
text
@d1 1
a1 1
/* $OpenBSD: tmux.h,v 1.570 2015/10/31 13:12:03 nicm Exp $ */
d1459 1
a1459 1
char		*paste_make_sample(struct paste_buffer *, int);
d1478 1
a1478 1
		     struct paste_buffer *, int);
d1895 2
a1896 2
void	 screen_write_start(
	     struct screen_write_ctx *, struct window_pane *, struct screen *);
d1899 4
a1902 4
size_t printflike(2, 3) screen_write_cstrlen(int, const char *, ...);
void printflike(5, 6) screen_write_cnputs(struct screen_write_ctx *,
	     ssize_t, struct grid_cell *, int, const char *, ...);
size_t printflike(2, 3) screen_write_strlen(int, const char *, ...);
d1905 8
a1912 8
void printflike(5, 6) screen_write_nputs(struct screen_write_ctx *,
	     ssize_t, struct grid_cell *, int, const char *, ...);
void	 screen_write_vnputs(struct screen_write_ctx *,
	     ssize_t, struct grid_cell *, int, const char *, va_list);
void	 screen_write_putc(
	     struct screen_write_ctx *, struct grid_cell *, u_char);
void	 screen_write_copy(struct screen_write_ctx *,
	     struct screen *, u_int, u_int, u_int, u_int);
@


1.570
log
@The output log is only useful once and it means creating a file, so open
it once at startup instead of in every call to tty_open.
@
text
@d1 1
a1 1
/* $OpenBSD: tmux.h,v 1.569 2015/10/31 08:13:58 nicm Exp $ */
d98 2
a99 2
#define KEYC_NONE 0xfff
#define KEYC_BASE 0x1000
d102 3
a104 3
#define KEYC_ESCAPE 0x2000
#define KEYC_CTRL 0x4000
#define KEYC_SHIFT 0x8000
d124 6
d131 1
a131 1
enum key_code {
d579 1
a579 1
	int				 key;
d785 1
a785 1
		    int, struct mouse_event *);
d1039 1
a1039 1
	int	valid;
d1041 2
a1042 2
	int	key;
	int	statusat;
d1044 3
a1046 3
	u_int	x;
	u_int	y;
	u_int	b;
d1048 3
a1050 3
	u_int	lx;
	u_int	ly;
	u_int	lb;
d1052 3
a1054 3
	int	s;
	int	w;
	int	wp;
d1056 2
a1057 2
	u_int	sgr_type;
	u_int	sgr_b;
d1063 1
a1063 1
	int		 key;
d1349 1
a1349 1
	int			 key;
d1497 2
a1498 1
enum mode_key_cmd mode_key_lookup(struct mode_key_data *, int, const char **);
d1642 3
a1644 3
void	tty_keys_build(struct tty *);
void	tty_keys_free(struct tty *);
int	tty_keys_next(struct tty *);
d1730 2
a1731 2
void	 key_bindings_add(const char *, int, int, struct cmd_list *);
void	 key_bindings_remove(const char *, int);
d1738 2
a1739 2
int	 key_string_lookup_string(const char *);
const char *key_string_lookup_key(int);
d1763 1
a1763 1
void	 server_client_handle_key(struct client *, int);
d1813 1
a1813 1
void	 status_prompt_key(struct client *, int);
d1829 1
a1829 1
void	 input_key(struct window_pane *, int, struct mouse_event *);
d1832 2
a1833 2
char	*xterm_keys_lookup(int);
int	 xterm_keys_find(const char *, size_t, size_t *, int *);
d2030 1
a2030 1
		     struct session *, int, struct mouse_event *);
d2189 1
@


1.569
log
@Because pledge(2) does not allow us to pass directory file descriptors
around, we can't use file descriptors for the working directory because
we will be unable to pass it to a privileged process to tell it where to
read or write files or spawn children. So move tmux back to using
strings for the current working directory. We try to check it exists
with access() when it is set but ultimately fall back to ~ if it fails
at time of use (or / if that fails too).
@
text
@d1 1
a1 1
/* $OpenBSD: tmux.h,v 1.568 2015/10/28 09:51:55 nicm Exp $ */
a1104 2
	int		 log_fd;

d1556 1
@


1.568
log
@Like options, move the environ struct into environ.c.
@
text
@d1 1
a1 1
/* $OpenBSD: tmux.h,v 1.567 2015/10/27 15:58:42 nicm Exp $ */
d832 1
a832 1
	int		 cwd;
d979 1
a979 1
	int		 cwd;
d1184 1
a1184 1
	int		 cwd;
d1539 1
a1539 1
struct job *job_run(const char *, struct session *, int,
d1985 2
a1986 2
		     const char *, int, struct environ *, struct termios *,
		     u_int, u_int, u_int, char **);
d2013 1
a2013 1
		     const char *, const char *, int, struct environ *,
d2147 2
a2148 2
		     int, struct environ *, struct termios *, int, u_int,
		     u_int, char **);
d2156 1
a2156 1
		     const char *, int, int, char **);
@


1.567
log
@Move struct options into options.c.
@
text
@d1 1
a1 1
/* $OpenBSD: tmux.h,v 1.566 2015/10/27 13:23:24 nicm Exp $ */
d39 9
a773 3
struct client;
struct session;
struct mouse_event;
a804 1
struct input_ctx;
a868 1
struct options;
a965 1
RB_HEAD(environ, environ_entry);
d1004 1
a1004 1
	struct environ	 environ;
a1169 2
struct tmuxproc;
struct tmuxpeer;
d1181 1
a1181 1
	struct environ	 environ;
d1408 1
a1408 1
extern struct environ global_environ;
d1545 1
a1545 3
int	environ_cmp(struct environ_entry *, struct environ_entry *);
RB_PROTOTYPE(environ, environ_entry, entry, environ_cmp);
void	environ_init(struct environ *);
d1547 2
@


1.566
log
@Break the common process set up, event loop and imsg dispatch code
between server and client out into a separate internal API. This will
make it easier to add another process.
@
text
@d1 1
a1 1
/* $OpenBSD: tmux.h,v 1.565 2015/10/25 22:29:17 nicm Exp $ */
a682 5
struct options {
	RB_HEAD(options_tree, options_entry) tree;
	struct options	*parent;
};

d864 1
d898 1
a898 1
	struct options	 options;
d992 1
a992 1
	struct options	 options;
d1404 3
a1406 3
extern struct options global_options;
extern struct options global_s_options;
extern struct options global_w_options;
d1508 1
a1508 3
int	options_cmp(struct options_entry *, struct options_entry *);
RB_PROTOTYPE(options_tree, options_entry, entry, options_cmp);
void	options_init(struct options *, struct options *);
d1510 2
@


1.565
log
@Extend the modifiers allowed before formats: as well as the existing
#{=10:...}  length limit, add #{t:...} to convert a time_t format to a
string, #{b:...} for basename and #{d:...} for dirname. Remove all the
foo_string time formats as they can now be replaced by "t:", for example
#{window_activity_string} becomes #{t:window_activity}.
@
text
@d1 1
a1 1
/* $OpenBSD: tmux.h,v 1.564 2015/10/23 16:02:21 nicm Exp $ */
a26 1
#include <sys/uio.h>
a29 1
#include <imsg.h>
d1171 2
d1174 1
a1174 1
	struct imsgbuf	 ibuf;
d1212 1
a1212 1
#define CLIENT_BAD 0x80
d1423 13
d1743 1
a1764 1
void	 server_client_callback(int, short, void *);
a1768 5
void	 server_write_ready(struct client *);
int	 server_write_client(struct client *, enum msgtype, const void *,
	     size_t);
void	 server_write_session(struct session *, enum msgtype, const void *,
	     size_t);
a1790 1
void	 server_update_event(struct client *);
d2120 1
a2120 1
void	set_signals(void(*)(int, short, void *));
@


1.564
log
@Format for scroll position, from Jorge Morante.
@
text
@d1 1
a1 1
/* $OpenBSD: tmux.h,v 1.563 2015/10/18 20:42:42 nicm Exp $ */
a1455 1
const char	*format_find(struct format_tree *, const char *);
@


1.563
log
@Pass current directory as a string rather than a file descriptor because
pledge doesn't let us pass directory file descriptors.
@
text
@d1 1
a1 1
/* $OpenBSD: tmux.h,v 1.562 2015/09/25 15:53:07 nicm Exp $ */
d2085 1
@


1.562
log
@Free the history when it is cleared, based on a diff from Carlo Cannas.
@
text
@d1 1
a1 1
/* $OpenBSD: tmux.h,v 1.561 2015/09/16 22:24:54 nicm Exp $ */
d398 1
a398 1
	MSG_IDENTIFY_CWD,
d403 1
@


1.561
log
@Rename cmd_q dead flag to a general flags bitmask (will be more flags later).
@
text
@d1 1
a1 1
/* $OpenBSD: tmux.h,v 1.560 2015/09/14 11:57:22 nicm Exp $ */
d1845 1
@


1.560
log
@Style nit, int for flags not u_int.
@
text
@d1 1
a1 1
/* $OpenBSD: tmux.h,v 1.559 2015/09/14 11:34:50 nicm Exp $ */
d1308 2
a1309 1
	int			 dead;
@


1.559
log
@When the active pane changes, redraw panes if the style has
changed. From Cam Hutchison.
@
text
@d1 1
a1 1
/* $OpenBSD: tmux.h,v 1.558 2015/09/14 10:25:52 nicm Exp $ */
d2076 1
a2076 1
void		 window_copy_init_from_pane(struct window_pane *, u_int);
@


1.558
log
@Make refresh-client force update of jobs, from Sina Siadat.
@
text
@d1 1
a1 1
/* $OpenBSD: tmux.h,v 1.557 2015/09/13 13:31:40 nicm Exp $ */
d1986 2
d2215 2
@


1.557
log
@Add copy-mode -e to exit copy mode when scrolling off the bottom, useful
for quick view of history, from Cam Hutchison.
@
text
@d1 1
a1 1
/* $OpenBSD: tmux.h,v 1.556 2015/09/11 14:41:50 nicm Exp $ */
d1223 1
d1446 2
d1450 1
a1450 1
struct format_tree *format_create_status(int);
@


1.556
log
@Merge delete-buffer into cmd-set-buffer.c and change the paste buffer
API so it has one paste_free() rather than free_top and free_name
(everywhere that uses it already has the right pointer).
@
text
@d1 1
a1 1
/* $OpenBSD: tmux.h,v 1.555 2015/09/10 08:58:14 nicm Exp $ */
d2071 1
a2071 1
void		 window_copy_init_from_pane(struct window_pane *);
@


1.555
log
@Add session_last_attached time and format, from Sina Siadat.
@
text
@d1 1
a1 1
/* $OpenBSD: tmux.h,v 1.554 2015/09/02 17:43:25 nicm Exp $ */
d1438 1
a1438 2
int		 paste_free_top(void);
int		 paste_free_name(const char *);
@


1.554
log
@A one line helper function is a little silly.
@
text
@d1 1
a1 1
/* $OpenBSD: tmux.h,v 1.553 2015/09/02 17:37:54 nicm Exp $ */
d984 1
@


1.553
log
@We no longer need the terminal service class, so don't bother asking for it.
@
text
@d1 1
a1 1
/* $OpenBSD: tmux.h,v 1.552 2015/09/01 11:13:39 nicm Exp $ */
a1598 1
void	tty_bell(struct tty *);
@


1.552
log
@Remove dead_clients which is no longer used.
@
text
@d1 1
a1 1
/* $OpenBSD: tmux.h,v 1.551 2015/09/01 10:10:59 nicm Exp $ */
a1084 1

a1085 1
	u_int		 class;
a1564 1
void	tty_set_class(struct tty *, u_int);
@


1.551
log
@Work out config file when needed not at startup.
@
text
@d1 1
a1 1
/* $OpenBSD: tmux.h,v 1.550 2015/09/01 10:01:56 nicm Exp $ */
a1730 1
extern struct clients dead_clients;
@


1.550
log
@Move initial conf load into cfg.c.
@
text
@d1 1
a1 1
/* $OpenBSD: tmux.h,v 1.549 2015/09/01 09:48:34 nicm Exp $ */
a1409 1
extern char	*cfg_file;
d1427 1
@


1.549
log
@All the cmd_*_entry declarations do not need to be in tmux.h.
@
text
@d1 1
a1 1
/* $OpenBSD: tmux.h,v 1.548 2015/08/30 22:56:36 nicm Exp $ */
a1422 1
extern struct cmd_q *cfg_cmd_q;
d1426 1
a1427 1
void		 cfg_default_done(struct cmd_q *);
@


1.548
log
@Path from $TMUX does not need to be global anymore.
@
text
@d1 1
a1 1
/* $OpenBSD: tmux.h,v 1.547 2015/08/30 22:40:25 nicm Exp $ */
a1673 86
extern const struct cmd_entry cmd_attach_session_entry;
extern const struct cmd_entry cmd_bind_key_entry;
extern const struct cmd_entry cmd_break_pane_entry;
extern const struct cmd_entry cmd_capture_pane_entry;
extern const struct cmd_entry cmd_choose_buffer_entry;
extern const struct cmd_entry cmd_choose_client_entry;
extern const struct cmd_entry cmd_choose_session_entry;
extern const struct cmd_entry cmd_choose_tree_entry;
extern const struct cmd_entry cmd_choose_window_entry;
extern const struct cmd_entry cmd_clear_history_entry;
extern const struct cmd_entry cmd_clock_mode_entry;
extern const struct cmd_entry cmd_command_prompt_entry;
extern const struct cmd_entry cmd_confirm_before_entry;
extern const struct cmd_entry cmd_copy_mode_entry;
extern const struct cmd_entry cmd_delete_buffer_entry;
extern const struct cmd_entry cmd_detach_client_entry;
extern const struct cmd_entry cmd_display_message_entry;
extern const struct cmd_entry cmd_display_panes_entry;
extern const struct cmd_entry cmd_down_pane_entry;
extern const struct cmd_entry cmd_find_window_entry;
extern const struct cmd_entry cmd_has_session_entry;
extern const struct cmd_entry cmd_if_shell_entry;
extern const struct cmd_entry cmd_join_pane_entry;
extern const struct cmd_entry cmd_kill_pane_entry;
extern const struct cmd_entry cmd_kill_server_entry;
extern const struct cmd_entry cmd_kill_session_entry;
extern const struct cmd_entry cmd_kill_window_entry;
extern const struct cmd_entry cmd_last_pane_entry;
extern const struct cmd_entry cmd_last_window_entry;
extern const struct cmd_entry cmd_link_window_entry;
extern const struct cmd_entry cmd_list_buffers_entry;
extern const struct cmd_entry cmd_list_clients_entry;
extern const struct cmd_entry cmd_list_commands_entry;
extern const struct cmd_entry cmd_list_keys_entry;
extern const struct cmd_entry cmd_list_panes_entry;
extern const struct cmd_entry cmd_list_sessions_entry;
extern const struct cmd_entry cmd_list_windows_entry;
extern const struct cmd_entry cmd_load_buffer_entry;
extern const struct cmd_entry cmd_lock_client_entry;
extern const struct cmd_entry cmd_lock_server_entry;
extern const struct cmd_entry cmd_lock_session_entry;
extern const struct cmd_entry cmd_move_pane_entry;
extern const struct cmd_entry cmd_move_window_entry;
extern const struct cmd_entry cmd_new_session_entry;
extern const struct cmd_entry cmd_new_window_entry;
extern const struct cmd_entry cmd_next_layout_entry;
extern const struct cmd_entry cmd_next_window_entry;
extern const struct cmd_entry cmd_paste_buffer_entry;
extern const struct cmd_entry cmd_pipe_pane_entry;
extern const struct cmd_entry cmd_previous_layout_entry;
extern const struct cmd_entry cmd_previous_window_entry;
extern const struct cmd_entry cmd_refresh_client_entry;
extern const struct cmd_entry cmd_rename_session_entry;
extern const struct cmd_entry cmd_rename_window_entry;
extern const struct cmd_entry cmd_resize_pane_entry;
extern const struct cmd_entry cmd_respawn_pane_entry;
extern const struct cmd_entry cmd_respawn_window_entry;
extern const struct cmd_entry cmd_rotate_window_entry;
extern const struct cmd_entry cmd_run_shell_entry;
extern const struct cmd_entry cmd_save_buffer_entry;
extern const struct cmd_entry cmd_select_layout_entry;
extern const struct cmd_entry cmd_select_pane_entry;
extern const struct cmd_entry cmd_select_window_entry;
extern const struct cmd_entry cmd_send_keys_entry;
extern const struct cmd_entry cmd_send_prefix_entry;
extern const struct cmd_entry cmd_server_info_entry;
extern const struct cmd_entry cmd_set_buffer_entry;
extern const struct cmd_entry cmd_set_environment_entry;
extern const struct cmd_entry cmd_set_option_entry;
extern const struct cmd_entry cmd_set_window_option_entry;
extern const struct cmd_entry cmd_show_buffer_entry;
extern const struct cmd_entry cmd_show_environment_entry;
extern const struct cmd_entry cmd_show_messages_entry;
extern const struct cmd_entry cmd_show_options_entry;
extern const struct cmd_entry cmd_show_window_options_entry;
extern const struct cmd_entry cmd_source_file_entry;
extern const struct cmd_entry cmd_split_window_entry;
extern const struct cmd_entry cmd_start_server_entry;
extern const struct cmd_entry cmd_suspend_client_entry;
extern const struct cmd_entry cmd_swap_pane_entry;
extern const struct cmd_entry cmd_swap_window_entry;
extern const struct cmd_entry cmd_switch_client_entry;
extern const struct cmd_entry cmd_unbind_key_entry;
extern const struct cmd_entry cmd_unlink_window_entry;
extern const struct cmd_entry cmd_up_pane_entry;
extern const struct cmd_entry cmd_wait_for_entry;
@


1.547
log
@Login shell can be a client flag, and move the exec code into client.c.
@
text
@d1 1
a1 1
/* $OpenBSD: tmux.h,v 1.546 2015/08/30 22:19:07 nicm Exp $ */
a1414 1
extern char	*environ_path;
@


1.546
log
@Event base does not need to be global.
@
text
@d1 1
a1 1
/* $OpenBSD: tmux.h,v 1.545 2015/08/29 23:55:55 nicm Exp $ */
d1206 1
a1206 1
/* 0x2 unused */
a1414 1
extern int	 login_shell;
a1420 1
__dead void	 shell_exec(const char *, const char *);
@


1.545
log
@Remove some old prototypes and unused functions.
@
text
@d1 1
a1 1
/* $OpenBSD: tmux.h,v 1.544 2015/08/29 23:19:52 nicm Exp $ */
a1409 1
extern struct event_base *ev_base;
d1794 1
a1794 1
int	client_main(int, char **, int);
d1831 1
a1831 1
int	 server_start(int, char *);
@


1.544
log
@struct args_entry can go into arguments.c.
@
text
@d1 1
a1 1
/* $OpenBSD: tmux.h,v 1.543 2015/08/29 09:36:46 nicm Exp $ */
a1843 1
void	 server_client_status_timer(void);
a1864 1
int	 server_unlock(const char *);
a2013 1
void	 screen_write_linefeedscreen(struct screen_write_ctx *, int);
a2075 1
void		 window_set_active_at(struct window *, u_int, u_int);
a2155 1
const char	*layout_set_name(u_int);
a2159 1
void		 layout_set_active_changed(struct window *);
@


1.543
log
@paste_send_pane can be merged into cmd-paste-buffer.c now.
@
text
@d1 1
a1 1
/* $OpenBSD: tmux.h,v 1.542 2015/08/29 09:25:00 nicm Exp $ */
d1260 1
a1260 5
struct args_entry {
	u_char			 flag;
	char			*value;
	RB_ENTRY(args_entry)	 entry;
};
a1261 1

@


1.542
log
@Move struct paste_buffer out of tmux.h.
@
text
@d1 1
a1 1
/* $OpenBSD: tmux.h,v 1.541 2015/08/29 08:30:54 nicm Exp $ */
a1454 2
void		 paste_send_pane(struct paste_buffer *, struct window_pane *,
		     const char *, int);
@


1.541
log
@Move alerts onto events rather than checking every loop.
@
text
@d1 1
a1 1
/* $OpenBSD: tmux.h,v 1.540 2015/08/29 00:29:15 nicm Exp $ */
a959 13
/* Paste buffer. */
struct paste_buffer {
	char		*data;
	size_t		 size;

	char		*name;
	int		 automatic;
	u_int		 order;

	RB_ENTRY(paste_buffer) name_entry;
	RB_ENTRY(paste_buffer) time_entry;
};

d1442 16
a1640 13

/* paste.c */
struct paste_buffer *paste_walk(struct paste_buffer *);
struct paste_buffer *paste_get_top(void);
struct paste_buffer *paste_get_name(const char *);
int		 paste_free_top(void);
int		 paste_free_name(const char *);
void		 paste_add(char *, size_t);
int		 paste_rename(const char *, const char *, char **);
int		 paste_set(char *, size_t, const char *, char **);
char		*paste_make_sample(struct paste_buffer *, int);
void		 paste_send_pane(struct paste_buffer *, struct window_pane *,
		     const char *, int);
@


1.540
log
@Better take on reducing the name timer. Again check for name changes in
the main loop after events that may have changed the pane, but do so at
most once every 500 millis. If the pane changed too soon, use a timer to
ensure that a check happens later.
@
text
@d1 1
a1 1
/* $OpenBSD: tmux.h,v 1.538 2015/08/28 15:51:48 nicm Exp $ */
d877 2
a878 1
	struct timeval	 silence_timer;
d1833 4
a1863 3
/* server-window.c */
void	 server_window_loop(void);

d2089 1
@


1.539
log
@Revert previous; we do need a timer, until I have a better idea. We
can't do the name check every loop, because that is too expensive, and
we can't make sure it only happens infrequently because we have no idea
when the next change will happen.
@
text
@d1 1
a1 1
/* $OpenBSD: tmux.h,v 1.537 2015/08/28 13:12:20 nicm Exp $ */
d50 2
a51 2
/* Automatic name refresh interval, in milliseconds. */
#define NAME_INTERVAL 500
d872 1
d874 3
a876 1
	struct event	 name_timer;
d2215 1
a2215 1
void	 queue_window_name(struct window *);
@


1.538
log
@We now only checking for name changes when the active pane has changed,
but that can only happen when we have already been woken up by a read
event, so there is no need for a timer, we can just check the changed
flag on the end of that read event (we already loop over the windows to
check for bells etc anyway).
@
text
@d873 1
d2212 1
a2212 1
void	 check_window_name(struct window *);
@


1.537
log
@Per-session timers for locking, and remove the global one-second timer.
@
text
@d1 1
a1 1
/* $OpenBSD: tmux.h,v 1.536 2015/08/28 13:01:03 nicm Exp $ */
a872 1
	struct event	 name_timer;
d2211 1
a2211 1
void	 queue_window_name(struct window *);
@


1.536
log
@Make session_update_activity more useful and use it in more places.
@
text
@d1 1
a1 1
/* $OpenBSD: tmux.h,v 1.535 2015/08/28 12:25:42 nicm Exp $ */
d995 2
@


1.535
log
@Give clock mode its own timer.
@
text
@d1 1
a1 1
/* $OpenBSD: tmux.h,v 1.534 2015/08/28 12:16:28 nicm Exp $ */
d2251 1
a2251 1
void		 session_update_activity(struct session *);
@


1.534
log
@Run status update on a per-client timer at status-interval.
@
text
@d1 1
a1 1
/* $OpenBSD: tmux.h,v 1.533 2015/08/28 11:38:27 nicm Exp $ */
a779 1
	void	(*timer)(struct window_pane *);
@


1.533
log
@Move format job cleanup onto its own timer.
@
text
@d1 1
a1 1
/* $OpenBSD: tmux.h,v 1.532 2015/08/28 07:49:24 nicm Exp $ */
d1210 1
a1210 1
	struct timeval	 status_timer;
d1896 2
@


1.532
log
@Only do the automatic-rename dance if the pane has changed (seen output,
or new active pane).
@
text
@d1 1
a1 1
/* $OpenBSD: tmux.h,v 1.531 2015/07/29 11:56:02 nicm Exp $ */
a1451 1
void		 format_clean(void);
@


1.531
log
@status_out and associated data structures are no longer used.
@
text
@d1 1
a1 1
/* $OpenBSD: tmux.h,v 1.530 2015/07/28 15:18:10 nicm Exp $ */
d829 1
@


1.530
log
@Tidy up the way terminals are described and move some structs out of tmux.h.
@
text
@d1 1
a1 1
/* $OpenBSD: tmux.h,v 1.529 2015/07/20 15:50:04 nicm Exp $ */
a1178 9
/* Status output data from a job. */
struct status_out {
	char	*cmd;
	char	*out;

	RB_ENTRY(status_out) entry;
};
RB_HEAD(status_out_tree, status_out);

a1208 2
	struct status_out_tree status_old;
	struct status_out_tree status_new;
a1895 2
int	 status_out_cmp(struct status_out *, struct status_out *);
RB_PROTOTYPE(status_out_tree, status_out, entry, status_out_cmp);
a1896 2
void	 status_free_jobs(struct status_out_tree *);
void	 status_update_jobs(struct client *);
@


1.529
log
@Add an option (history-file) for a file to save/restore command prompt
history, from Olof-Joachim Frahm.
@
text
@d1 1
a1 1
/* $OpenBSD: tmux.h,v 1.528 2015/07/13 15:51:31 nicm Exp $ */
a389 26
#define NTTYCODE (TTYC_XT + 1)

/* Termcap types. */
enum tty_code_type {
	TTYCODE_NONE = 0,
	TTYCODE_STRING,
	TTYCODE_NUMBER,
	TTYCODE_FLAG,
};

/* Termcap code. */
struct tty_code {
	enum tty_code_type	type;
	union {
		char	       *string;
		int		number;
		int		flag;
	} value;
};

/* Entry in terminal code table. */
struct tty_term_code_entry {
	enum tty_code_code	code;
	enum tty_code_type	type;
	const char	       *name;
};
d1073 1
d1080 1
a1080 1
	struct tty_code	 codes[NTTYCODE];
d1621 1
a1621 1
extern const struct tty_term_code_entry tty_term_codes[NTTYCODE];
d1635 1
@


1.528
log
@Fix line endings.
@
text
@d1 1
a1 1
/* $OpenBSD: tmux.h,v 1.527 2015/07/13 15:49:31 nicm Exp $ */
d1472 1
d1947 2
@


1.527
log
@Initialize cwd fd to -1 so that we don't close fd 0 if the client is
destroyed before it is changed. Also allow ttyname() to fail. Fixes
problems when running out of file descriptors reported by Bruno Sutic.
@
text
@d1 1
a1 1
/* $OpenBSD: tmux.h,v 1.526 2015/06/17 16:50:28 nicm Exp $ */
d1603 1
a1603 1
int	tty_init(struct tty *, struct client *, int, char *);
@


1.526
log
@Move the shuffle code from new-window -a into a function and add a -a
flag for move-window too. From Thomas Adam.
@
text
@d1 1
a1 1
/* $OpenBSD: tmux.h,v 1.525 2015/06/17 16:44:49 nicm Exp $ */
d1603 1
a1603 1
void	tty_init(struct tty *, struct client *, int, char *);
@


1.525
log
@Use an explicit job state instead of avoid closing our side of the
socketpair and setting it to -1 to mark when the other side is
closed. This avoids closing it while the libevent bufferevent still has
it (it could try to add it to the polled set which some mechanisms don't
like). Fixes part a problem reported by Bruno Sutic.
@
text
@d1 1
a1 1
/* $OpenBSD: tmux.h,v 1.524 2015/06/15 10:58:01 nicm Exp $ */
d2169 1
@


1.524
log
@Add window_activity format, from Thomas Adam based on a diff originally
from propos6 at gmail dot com.
@
text
@d1 1
a1 1
/* $OpenBSD: tmux.h,v 1.523 2015/06/14 10:07:44 nicm Exp $ */
d717 6
@


1.523
log
@Add a format for client PID (client_pid) and server PID (pid). Diff for
client_pid from Thomas Adam.
@
text
@d1 1
a1 1
/* $OpenBSD: tmux.h,v 1.522 2015/06/07 21:39:39 nicm Exp $ */
d895 1
@


1.522
log
@Add -E flag when attaching or switching client to bypass
update-environment, from Steven Lu.
@
text
@d1 1
a1 1
/* $OpenBSD: tmux.h,v 1.521 2015/06/05 22:33:39 nicm Exp $ */
d428 1
d1210 1
@


1.521
log
@Handle the RGB colour escape sequence (\033[38;2;<r>;<g>;<b>m and 48;2)
like xterm(1) does, by mapping to the nearest in the 256 colour palette.
@
text
@d1 1
a1 1
/* $OpenBSD: tmux.h,v 1.520 2015/06/05 18:18:32 nicm Exp $ */
d1804 1
a1804 1
		     const char *);
@


1.520
log
@Similarly, for sessions use a callback to free rather than checking
every loop.
@
text
@d1 1
a1 1
/* $OpenBSD: tmux.h,v 1.519 2015/06/05 18:06:30 nicm Exp $ */
d1956 1
@


1.519
log
@Change deref to the more sensible unref, and add a couple I missed before.
@
text
@d1 1
a1 1
/* $OpenBSD: tmux.h,v 1.518 2015/06/05 18:01:12 nicm Exp $ */
a2261 1
extern struct sessions dead_sessions;
d2273 1
@


1.518
log
@Instead of putting dead clients on a list and checking it every loop,
use event_once to queue a callback to deal with them. Also dead clients
with references would never actually be freed because the wrap-up
functions (the callback for stdin, or status_prompt_clear) would never
be called. So call them in server_client_lost.
@
text
@d1 1
a1 1
/* $OpenBSD: tmux.h,v 1.517 2015/06/04 23:27:51 nicm Exp $ */
d1874 1
a1874 1
void	 server_client_deref(struct client *);
@


1.517
log
@Move the nested check from client to server and compare the client tty
name to all the pane pty names instead of comparing socket paths. This
means that "new -d" will work without unsetting $TMUX.
@
text
@d1 1
a1 1
/* $OpenBSD: tmux.h,v 1.516 2015/06/04 11:43:51 nicm Exp $ */
d1874 1
@


1.516
log
@Add support for a single "marked pane". There is one marked pane in the
server at a time; it may be toggled or cleared with select-pane -m and
-M (the border is highlighted). A new target '~' or '{marked}' specifies
the marked pane to commands and it is the default target for the
swap-pane and join-pane -s flag (this makes them much simpler to use -
mark the source pane and then change to the target pane to run swapp or
joinp).
@
text
@d1 1
a1 1
/* $OpenBSD: tmux.h,v 1.515 2015/05/27 13:28:04 nicm Exp $ */
d1377 1
a1377 2
#define CMD_CANTNEST 0x2
#define CMD_READONLY 0x4
d1870 1
@


1.515
log
@Move the jobs output cache into the formats code so that #() work more
generally (for example, again working in set-titles-string).
@
text
@d1 1
a1 1
/* $OpenBSD: tmux.h,v 1.514 2015/05/12 22:40:38 nicm Exp $ */
d1691 2
d1695 2
d1857 9
@


1.514
log
@To replace c0-*, add a high watermark to the pty event, and also backoff
when the any of the ttys the pane is going to write to has buffered
enough data.
@
text
@d1 1
a1 1
/* $OpenBSD: tmux.h,v 1.513 2015/05/12 15:27:46 nicm Exp $ */
d1478 1
d1480 1
@


1.513
log
@Add bell-action "other" to pass through bells in all windows except the
current, suggested by Jan ONDREJ.
@
text
@d1 1
a1 1
/* $OpenBSD: tmux.h,v 1.512 2015/05/11 10:10:16 nicm Exp $ */
d59 10
d860 1
d1609 3
a1611 2
void	tty_write(
	    void (*)(struct tty *, const struct tty_ctx *), struct tty_ctx *);
@


1.512
log
@Remove the c0-* options which never really worked satisfactorily. Going
to try something else...
@
text
@d1 1
a1 1
/* $OpenBSD: tmux.h,v 1.511 2015/05/08 16:48:12 nicm Exp $ */
d78 1
@


1.511
log
@Put the tty structs together, and tabify.
@
text
@d1 1
a1 1
/* $OpenBSD: tmux.h,v 1.510 2015/05/08 16:44:03 nicm Exp $ */
a846 4
	u_int		 changes;
	struct event	 changes_timer;
	u_int		 changes_redraw;

a2105 1
void		 window_pane_timer_start(struct window_pane *);
@


1.510
log
@grid_marker_cell is no longer used.
@
text
@d1 1
a1 1
/* $OpenBSD: tmux.h,v 1.509 2015/05/08 16:33:29 nicm Exp $ */
d692 1
a692 1
	long long	 	 num;
d807 1
a807 1
	char		        *ft_template;
d885 1
a885 1
	struct timeval   silence_timer;
d926 1
a926 1
	int              flags;
d1018 1
a1018 1
	u_int            attached;
a1030 27
/* TTY information. */
struct tty_key {
	char		 ch;
	int		 key;

	struct tty_key	*left;
	struct tty_key	*right;

	struct tty_key	*next;
};

struct tty_term {
	char		*name;
	u_int		 references;

	char		 acs[UCHAR_MAX + 1][2];

	struct tty_code	 codes[NTTYCODE];

#define TERM_256COLOURS 0x1
#define TERM_EARLYWRAP 0x2
	int		 flags;

	LIST_ENTRY(tty_term) entry;
};
LIST_HEAD(tty_terms, tty_term);

d1072 27
d1146 1
a1146 1
	    		    struct mouse_event *);
d1220 1
a1220 1
	int              stdin_closed;
d1266 1
a1266 1
	u_int            prompt_hindex;
d1295 2
a1296 2
	int		 	  argc;
	char	       		**argv;
d1314 2
a1315 2
	int		 	 references;
	TAILQ_HEAD(, cmd) 	 list;
d1354 1
a1354 1
	TAILQ_ENTRY(cmd_q)       waitentry;
d1416 2
a1417 2
	u_int		 	minimum;
	u_int		 	maximum;
d1804 1
a1804 1
	             struct mouse_event *);
d1826 2
a1827 2
struct 	 key_table *key_bindings_get_table(const char *, int);
void 	 key_bindings_unref_table(struct key_table *);
d1849 1
a1849 1
int      server_client_open(struct client *, char **);
d2100 1
a2100 1
		        struct window_pane *, u_int);
d2102 1
a2102 1
		        struct window_pane *, u_int);
@


1.509
log
@mode_key_entry can go into mode-key.c; also a few spaces->tabs.
@
text
@d1 1
a1 1
/* $OpenBSD: tmux.h,v 1.508 2015/05/08 16:23:34 nicm Exp $ */
a1942 1
extern const struct grid_cell grid_marker_cell;
@


1.508
log
@window_choose_mode_item can move into window-choose.c.
@
text
@d1 1
a1 1
/* $OpenBSD: tmux.h,v 1.507 2015/05/08 16:18:04 nicm Exp $ */
a568 14
/* Entry in the default mode key tables. */
struct mode_key_entry {
	int			key;

	/*
	 * Editing mode for vi: 0 is edit mode, keys not in the table are
	 * returned as MODEKEY_OTHER; 1 is command mode, keys not in the table
	 * are returned as MODEKEY_NONE. This is also matched on, allowing some
	 * keys to be bound in edit mode.
	 */
	int			mode;
	enum mode_key_cmd	cmd;
};

d596 1
d1182 3
a1184 3
	char   *msg;
	u_int	msg_num;
	time_t	msg_time;
d1190 2
a1191 2
	char   *cmd;
	char   *out;
d1312 1
d1385 1
@


1.507
log
@Move input parser structs into input.c (removing fairly useless
saved_cursor_[xy] formats as a side-effect).
@
text
@d1 1
a1 1
/* $OpenBSD: tmux.h,v 1.506 2015/05/07 08:08:54 nicm Exp $ */
a823 8
};

struct window_choose_mode_item {
	struct window_choose_data	*wcd;
	char				*name;
	int				 pos;
	int				 state;
#define TREE_EXPANDED 0x1
@


1.506
log
@array.h can be local to window-choose.c now.
@
text
@d1 1
a1 1
/* $OpenBSD: tmux.h,v 1.505 2015/05/06 23:56:46 nicm Exp $ */
a787 49
/* Input parser cell. */
struct input_cell {
	struct grid_cell	cell;
	int			set;
	int			g0set;	/* 1 if ACS */
	int			g1set;	/* 1 if ACS */
};

/* Input parser context. */
struct input_ctx {
	struct window_pane     *wp;
	struct screen_write_ctx ctx;

	struct input_cell	cell;

	struct input_cell	old_cell;
	u_int 			old_cx;
	u_int			old_cy;

	u_char			interm_buf[4];
	size_t			interm_len;

	u_char			param_buf[64];
	size_t			param_len;

#define INPUT_BUF_START 32
#define INPUT_BUF_LIMIT 1048576
	u_char		       *input_buf;
	size_t			input_len;
	size_t			input_space;

	int			param_list[24];	/* -1 not present */
	u_int			param_list_len;

	struct utf8_data	utf8data;

	int			ch;
	int			flags;
#define INPUT_DISCARD 0x1

	const struct input_state *state;

	/*
	 * All input received since we were last in the ground state. Sent to
	 * control clients on connection.
	 */
	struct evbuffer	 	*since_ground;
};

d835 1
d875 1
a875 1
	struct input_ctx ictx;
d1938 2
@


1.505
log
@Remove ARRAY_* from history and expand completion to complete a) layout
names and b) targets beginning with -t or -s.
@
text
@d1 1
a1 1
/* $OpenBSD: tmux.h,v 1.504 2015/05/06 08:35:39 nicm Exp $ */
a36 2

#include "array.h"
@


1.504
log
@Add a format window_linked which is 1 if a window has been linked
multiple times, also remove the default space in window_flags and use a
conditional to add it in window-status-format (this means additional
flags can be added in the option without extra spaces). From Thomas Adam
with tweaks by me.
@
text
@d1 1
a1 1
/* $OpenBSD: tmux.h,v 1.503 2015/04/28 10:43:14 nicm Exp $ */
a44 3

/* Default prompt history length. */
#define PROMPT_HISTORY 100
@


1.503
log
@Add select-layout -o to undo the last layout change (apply the previously
set layout).
@
text
@d1 1
a1 1
/* $OpenBSD: tmux.h,v 1.502 2015/04/27 16:25:57 nicm Exp $ */
d2331 1
@


1.502
log
@Rewrite of the target resolution internals to be simpler and more
consistent but with much less duplication, but keeping the same internal
API. Also adds more readable aliases for some of the special tokens used
in targets (eg "{start}" instead of "^"). Some behaviours may have
changed, for example prefix matches now happen before fnmatch.
@
text
@d1 1
a1 1
/* $OpenBSD: tmux.h,v 1.501 2015/04/25 18:33:59 nicm Exp $ */
d968 1
@


1.501
log
@Make message log a TAILQ.
@
text
@d1 1
a1 1
/* $OpenBSD: tmux.h,v 1.500 2015/04/25 18:09:28 nicm Exp $ */
d1743 13
a1755 2
long long	 args_strtonum(
		    struct args *, u_char, long long, long long, char **);
a1769 10
struct session	*cmd_current_session(struct cmd_q *, int);
struct client	*cmd_current_client(struct cmd_q *);
struct client	*cmd_find_client(struct cmd_q *, const char *, int);
struct session	*cmd_find_session(struct cmd_q *, const char *, int);
struct winlink	*cmd_find_window(struct cmd_q *, const char *,
		     struct session **);
int		 cmd_find_index(struct cmd_q *, const char *,
		     struct session **);
struct winlink	*cmd_find_pane(struct cmd_q *, const char *, struct session **,
		     struct window_pane **);
@


1.500
log
@Move the functions to convert ids from strings into session.c and window.c.
@
text
@d1 1
a1 1
/* $OpenBSD: tmux.h,v 1.499 2015/04/24 23:17:11 nicm Exp $ */
a952 1
ARRAY_DECL(window_pane_list, struct window_pane *);
a1102 1
ARRAY_DECL(sessionslist, struct session *);
d1256 1
d1258 1
d1330 2
a1331 1
	ARRAY_DECL(, struct message_entry) message_log;
@


1.499
log
@Convert clients list into a TAILQ.
@
text
@d1 1
a1 1
/* $OpenBSD: tmux.h,v 1.498 2015/04/24 22:19:36 nicm Exp $ */
a1768 2
struct window	*cmd_lookup_windowid(const char *);
struct window_pane *cmd_lookup_paneid(const char *);
d2148 1
d2174 1
d2312 1
@


1.498
log
@Set working directory for run-shell and if-shell.
@
text
@d1 1
a1 1
/* $OpenBSD: tmux.h,v 1.497 2015/04/22 15:32:33 nicm Exp $ */
d1352 2
d1355 1
a1355 1
ARRAY_DECL(clients, struct client *);
@


1.497
log
@Make session_has return a flag, returning the first winlink found is a
recipe for errors.
@
text
@d1 1
a1 1
/* $OpenBSD: tmux.h,v 1.496 2015/04/22 15:30:11 nicm Exp $ */
d1616 1
a1616 1
struct job *job_run(const char *, struct session *,
@


1.496
log
@Change the windows array into an RB tree and fix some places where we
were only looking at the first winlink for a window in a session.
@
text
@d1 1
a1 1
/* $OpenBSD: tmux.h,v 1.495 2015/04/22 15:05:03 nicm Exp $ */
d2324 1
a2324 1
struct winlink	*session_has(struct session *, struct window *);
@


1.495
log
@window_index is only used in one place (window_destroy) so inline it there.
@
text
@d1 1
a1 1
/* $OpenBSD: tmux.h,v 1.494 2015/04/21 22:38:49 nicm Exp $ */
d986 2
d989 1
a989 1
ARRAY_DECL(windows, struct window *);
d2126 2
@


1.494
log
@Always format real layout even when zoomed.
@
text
@d1 1
a1 1
/* $OpenBSD: tmux.h,v 1.493 2015/04/20 15:34:56 nicm Exp $ */
a2143 1
int		 window_index(struct window *, u_int *);
@


1.493
log
@Support for multiple key tables to commands to be bound to sequences of
keys. The default key bindings become the "prefix" table and -n the
"root" table. Keys may be bound in new tables with bind -T and
switch-client -T used to specify the table in which the next key should
be looked up. Based on a diff from Keith Amling.
@
text
@d1 1
a1 1
/* $OpenBSD: tmux.h,v 1.492 2015/04/19 21:34:21 nicm Exp $ */
d2228 1
a2228 1
char		*layout_dump(struct window *);
@


1.492
log
@Rewrite of tmux mouse support which was a mess. Instead of having
options for "mouse-this" and "mouse-that", mouse events may be bound as
keys and there is one option "mouse" that turns on mouse support
entirely (set -g mouse on).

See the new MOUSE SUPPORT section of the man page for description of the
key names and new flags (-t= to specify the pane or window under mouse
as a target, and send-keys -M to pass through a mouse event).

The default builtin bindings for the mouse are:

    bind -n   MouseDown1Pane select-pane -t=; send-keys -M
    bind -n MouseDown1Status select-window -t=
    bind -n   MouseDrag1Pane copy-mode -M
    bind -n MouseDrag1Border resize-pane -M

To get the effect of turning mode-mouse off, do:

    unbind -n MouseDrag1Pane
    unbind -temacs-copy MouseDrag1Pane

The old mouse options are now gone, set-option -q may be used to
suppress warnings if mixing configuration files.
@
text
@d1 1
a1 1
/* $OpenBSD: tmux.h,v 1.491 2015/04/19 21:05:27 nicm Exp $ */
a91 1
#define KEYC_PREFIX 0x10000
d94 1
a94 1
#define KEYC_MASK_MOD (KEYC_ESCAPE|KEYC_CTRL|KEYC_SHIFT|KEYC_PREFIX)
d1303 1
a1303 1
#define CLIENT_PREFIX 0x2
d1322 1
d1443 1
a1443 1
/* Key binding. */
d1445 3
a1447 3
	int		 key;
	struct cmd_list	*cmdlist;
	int		 can_repeat;
d1449 1
a1449 1
	RB_ENTRY(key_binding) entry;
d1452 9
d1888 4
a1891 1
extern struct key_bindings key_bindings;
d1893 5
a1897 4
RB_PROTOTYPE(key_bindings, key_binding, entry, key_bindings_cmp);
struct key_binding *key_bindings_lookup(int);
void	 key_bindings_add(int, int, struct cmd_list *);
void	 key_bindings_remove(int);
@


1.491
log
@Support setting the default window and pane background colours (window
and active pane via window-style and window-active-style options, an
individual pane by a new select-pane -P flag). From J Raynor.
@
text
@d1 1
a1 1
/* $OpenBSD: tmux.h,v 1.490 2015/02/06 17:21:08 nicm Exp $ */
d98 15
a112 1
/* Other key codes. */
d114 17
a130 2
	/* Mouse key. */
	KEYC_MOUSE = KEYC_BASE,
a178 3

	KEYC_FOCUS_IN,
	KEYC_FOCUS_OUT,
d847 1
a848 1
struct window;
d854 2
a855 3
	void	(*key)(struct window_pane *, struct session *, int);
	void	(*mouse)(struct window_pane *,
		    struct session *, struct mouse_event *);
d1142 1
a1142 1
#define MOUSE_WHEEL_DOWN 1
d1144 5
a1148 2
/* Mouse wheel multipler. */
#define MOUSE_WHEEL_SCALE 3
d1150 3
a1152 6
/* Mouse event bits. */
#define MOUSE_EVENT_DOWN 0x1
#define MOUSE_EVENT_DRAG 0x2
#define MOUSE_EVENT_UP 0x4
#define MOUSE_EVENT_CLICK 0x8
#define MOUSE_EVENT_WHEEL 0x10
d1154 2
a1155 2
/* Mouse flag bits. */
#define MOUSE_RESIZE_PANE 0x1
d1157 3
a1159 13
/*
 * Mouse input. When sent by xterm:
 *
 * - buttons are in the bottom two bits: 0 = b1; 1 = b2; 2 = b3; 3 = released
 * - bits 3, 4 and 5 are for keys
 * - bit 6 is set for dragging
 * - bit 7 for buttons 4 and 5
 *
 * With the SGR 1006 extension the released button becomes known. Store these
 * in separate fields and store the value converted to the old format in xb.
 */
struct mouse_event {
	u_int	xb;
a1160 1
	u_int	x;
d1162 2
a1163 1
	u_int	sx;
d1165 3
a1167 3
	u_int	y;
	u_int	ly;
	u_int	sy;
d1169 2
a1170 11
	u_int   sgr;		/* whether the input arrived in SGR format */
	u_int   sgr_xb;		/* only for SGR: the unmangled button */
	u_int   sgr_rel;	/* only for SGR: if it is a release event */

	u_int	button;
	u_int	clicks;
	u_int	scroll;

	int	wheel;
	int     event;
	int     flags;
d1216 5
d1396 3
d1740 5
d1861 4
a1864 2
void		 cmdq_run(struct cmd_q *, struct cmd_list *);
void		 cmdq_append(struct cmd_q *, struct cmd_list *);
d1886 2
a1887 1
void	 key_bindings_dispatch(struct key_binding *, struct client *);
d1955 1
a1955 1
void	 status_set_window_at(struct client *, u_int);
d1976 1
a1976 3
void	 input_key(struct window_pane *, int);
void	 input_mouse(struct window_pane *, struct session *,
	     struct mouse_event *);
d2141 1
d2172 2
a2173 3
void		 window_pane_key(struct window_pane *, struct session *, int);
void		 window_pane_mouse(struct window_pane *,
		     struct session *, struct mouse_event *);
a2208 1
void		 layout_resize_pane_mouse(struct client *);
d2237 1
@


1.490
log
@status_replace can now become local to status.c and it no longer needs
the jobsflag argument. While here there is no need to repeat work that
format_defaults already does.
@
text
@d1 1
a1 1
/* $OpenBSD: tmux.h,v 1.489 2015/02/06 17:11:39 nicm Exp $ */
d159 1
d906 2
d1612 2
a1613 1
void	tty_attributes(struct tty *, const struct grid_cell *);
d1637 4
a1640 1
void	tty_draw_line(struct tty *, struct screen *, u_int, u_int, u_int);
@


1.489
log
@Add format_expand_time and use it instead of status_replace where
command execution is not needed.
@
text
@d1 1
a1 1
/* $OpenBSD: tmux.h,v 1.488 2015/02/05 10:29:43 nicm Exp $ */
a1927 2
char	*status_replace(struct client *, struct winlink *, const char *, time_t,
	     int);
@


1.488
log
@Wrap all the individual format_* calls in a single format_defaults
functions.
@
text
@d1 1
a1 1
/* $OpenBSD: tmux.h,v 1.487 2015/02/05 10:26:29 nicm Exp $ */
d1515 1
@


1.487
log
@There is no need to save the guard state because the function checks it
again anyway.
@
text
@d1 1
a1 1
/* $OpenBSD: tmux.h,v 1.486 2015/02/01 23:43:23 nicm Exp $ */
d1516 4
a1519 6
void		 format_session(struct format_tree *, struct session *);
void		 format_client(struct format_tree *, struct client *);
void		 format_window(struct format_tree *, struct window *);
void		 format_winlink(struct format_tree *, struct session *,
		     struct winlink *);
void		 format_window_pane(struct format_tree *,
d1521 1
a1521 1
void		 format_paste_buffer(struct format_tree *,
@


1.486
log
@Remove two unused arguments from status_replace.
@
text
@d1 1
a1 1
/* $OpenBSD: tmux.h,v 1.485 2015/01/20 08:18:04 nicm Exp $ */
d1835 1
a1835 1
int		 cmdq_guard(struct cmd_q *, const char *, int);
@


1.485
log
@Support blinking cursor mode, both the xterm CSI ?12 h/l and (the
backwards) screen CSI 34 h/l. From Guanpeng Xu.
@
text
@d1 1
a1 1
/* $OpenBSD: tmux.h,v 1.484 2014/12/09 19:23:35 nicm Exp $ */
d1929 2
a1930 2
char	*status_replace(struct client *, struct session *, struct winlink *,
	     struct window_pane *, const char *, time_t, int);
@


1.484
log
@Add pane_dead_status for exit status of dead panes.
@
text
@d1 1
a1 1
/* $OpenBSD: tmux.h,v 1.483 2014/12/02 23:19:45 nicm Exp $ */
d178 1
d604 1
a604 1
/* 0x80 unused */
@


1.483
log
@Permit option values to be used in formats.
@
text
@d1 1
a1 1
/* $OpenBSD: tmux.h,v 1.482 2014/11/30 08:03:29 nicm Exp $ */
d893 1
@


1.482
log
@Remove dead code, from Thomas Adam.
@
text
@d1 1
a1 1
/* $OpenBSD: tmux.h,v 1.481 2014/11/14 02:19:47 nicm Exp $ */
a1463 9
/* Tree of format entries. */
struct format_entry {
	char		       *key;
	char		       *value;

	RB_ENTRY(format_entry)	entry;
};
RB_HEAD(format_tree, format_entry);

d1507 1
a1507 2
int		 format_cmp(struct format_entry *, struct format_entry *);
RB_PROTOTYPE(format_tree, format_entry, entry, format_cmp);
@


1.481
log
@Label windows which are smaller than expected with a reason.
@
text
@d1 1
a1 1
/* $OpenBSD: tmux.h,v 1.480 2014/11/06 09:17:26 nicm Exp $ */
a2237 3
			const char *, u_int);
struct window_choose_data	*window_choose_add_item(struct window_pane *,
			struct client *, struct winlink *, const char *,
@


1.480
log
@Add V for select line with vi(1) keys. From Juho Pohjala.
@
text
@d1 1
a1 1
/* $OpenBSD: tmux.h,v 1.479 2014/10/27 22:23:47 nicm Exp $ */
d949 3
a951 1
#define WINDOW_ZOOMED 0x10
@


1.479
log
@Move cfg_causes local into cfg.c and remove struct causelist.
@
text
@d1 1
a1 1
/* $OpenBSD: tmux.h,v 1.478 2014/10/22 23:11:41 nicm Exp $ */
d715 6
@


1.478
log
@Merge unlink-window into kill-window.
@
text
@d1 1
a1 1
/* $OpenBSD: tmux.h,v 1.477 2014/10/21 22:22:04 nicm Exp $ */
a383 3
/* List of error causes. */
ARRAY_DECL(causelist, char *);

a1499 1
extern struct causelist cfg_causes;
d1503 2
@


1.477
log
@Only redraw pane when it has actually changed.
@
text
@d1 1
a1 1
/* $OpenBSD: tmux.h,v 1.476 2014/10/20 23:57:14 nicm Exp $ */
d2299 1
@


1.476
log
@Better format for printf format attributes.
@
text
@d1 1
a1 1
/* $OpenBSD: tmux.h,v 1.475 2014/10/20 23:35:28 nicm Exp $ */
d2119 1
a2119 1
void		 window_set_active_pane(struct window *, struct window_pane *);
@


1.475
log
@Move template defines back into .c files.
@
text
@d1 1
a1 1
/* $OpenBSD: tmux.h,v 1.474 2014/10/20 23:27:14 nicm Exp $ */
d72 1
a72 5
#define printflike1 __attribute__ ((format (printf, 1, 2)))
#define printflike2 __attribute__ ((format (printf, 2, 3)))
#define printflike3 __attribute__ ((format (printf, 3, 4)))
#define printflike4 __attribute__ ((format (printf, 4, 5)))
#define printflike5 __attribute__ ((format (printf, 5, 6)))
d1514 2
a1515 2
void printflike3 format_add(struct format_tree *, const char *, const char *,
		     ...);
d1568 1
a1568 1
struct options_entry *printflike3 options_set_string(struct options *,
d1835 2
a1836 2
void printflike2 cmdq_print(struct cmd_q *, const char *, ...);
void printflike2 cmdq_error(struct cmd_q *, const char *, ...);
d1931 3
a1933 3
char	*status_replace(struct client *, struct session *,
	     struct winlink *, struct window_pane *, const char *, time_t, int);
void printflike2 status_message_set(struct client *, const char *, ...);
d2023 2
a2024 2
size_t printflike2 screen_write_cstrlen(int, const char *, ...);
void printflike5 screen_write_cnputs(struct screen_write_ctx *,
d2026 2
a2027 2
size_t printflike2 screen_write_strlen(int, const char *, ...);
void printflike3 screen_write_puts(struct screen_write_ctx *,
d2029 1
a2029 1
void printflike5 screen_write_nputs(struct screen_write_ctx *,
d2213 1
a2213 1
void printflike2 window_copy_add(struct window_pane *, const char *, ...);
d2252 1
a2252 1
void printflike2 control_write(struct client *, const char *, ...);
d2323 3
a2325 3
void printflike1 log_debug(const char *, ...);
__dead void printflike1 log_fatal(const char *, ...);
__dead void printflike1 log_fatalx(const char *, ...);
d2333 1
a2333 1
int printflike2	 xasprintf(char **, const char *, ...);
d2335 1
a2335 1
int printflike3	 xsnprintf(char *, size_t, const char *, ...);
@


1.474
log
@Tidy up some includes.
@
text
@d1 1
a1 1
/* $OpenBSD: tmux.h,v 1.473 2014/10/20 22:29:25 nicm Exp $ */
a81 72

/* Default template for choose-buffer. */
#define CHOOSE_BUFFER_TEMPLATE					\
	"#{buffer_name}: #{buffer_size} bytes: #{buffer_sample}"

/* Default template for choose-client. */
#define CHOOSE_CLIENT_TEMPLATE					\
	"#{client_tty}: #{session_name} "			\
	"[#{client_width}x#{client_height} #{client_termname}]"	\
	"#{?client_utf8, (utf8),}#{?client_readonly, (ro),} "	\
	"(last used #{client_activity_string})"

/* Default templates for choose-tree. */
#define CHOOSE_TREE_SESSION_TEMPLATE				\
	"#{session_name}: #{session_windows} windows"		\
	"#{?session_grouped, (group ,}"				\
	"#{session_group}#{?session_grouped,),}"		\
	"#{?session_attached, (attached),}"
#define CHOOSE_TREE_WINDOW_TEMPLATE				\
	"#{window_index}: #{window_name}#{window_flags} "	\
	"\"#{pane_title}\""

/* Default template for display-message. */
#define DISPLAY_MESSAGE_TEMPLATE				\
	"[#{session_name}] #{window_index}:"			\
	"#{window_name}, current pane #{pane_index} "		\
	"- (%H:%M %d-%b-%y)"

/* Default template for find-window. */
#define FIND_WINDOW_TEMPLATE					\
	"#{window_index}: #{window_name} "			\
	"[#{window_width}x#{window_height}] "			\
	"(#{window_panes} panes) #{window_find_matches}"

/* Default template for list-buffers. */
#define LIST_BUFFERS_TEMPLATE					\
	"#{buffer_name}: #{buffer_size} bytes: "		\
	"\"#{buffer_sample}\""

/* Default template for list-clients. */
#define LIST_CLIENTS_TEMPLATE					\
	"#{client_tty}: #{session_name} "			\
	"[#{client_width}x#{client_height} #{client_termname}]"	\
	"#{?client_utf8, (utf8),} #{?client_readonly, (ro),}"

/* Default template for list-sessions. */
#define LIST_SESSIONS_TEMPLATE					\
	"#{session_name}: #{session_windows} windows "		\
	"(created #{session_created_string}) "			\
	"[#{session_width}x#{session_height}]"			\
	"#{?session_grouped, (group ,}"				\
	"#{session_group}#{?session_grouped,),}"		\
	"#{?session_attached, (attached),}"

/* Default templates for list-windows. */
#define LIST_WINDOWS_TEMPLATE					\
	"#{window_index}: #{window_name}#{window_flags} "	\
	"(#{window_panes} panes) "				\
	"[#{window_width}x#{window_height}] "			\
	"[layout #{window_layout}] #{window_id}"		\
	"#{?window_active, (active),}";
#define LIST_WINDOWS_WITH_SESSION_TEMPLATE			\
	"#{session_name}:"					\
	"#{window_index}: #{window_name}#{window_flags} "	\
	"(#{window_panes} panes) "				\
	"[#{window_width}x#{window_height}] "

/* Default templates for break-pane, new-window and split-window. */
#define BREAK_PANE_TEMPLATE "#{session_name}:#{window_index}.#{pane_index}"
#define NEW_SESSION_TEMPLATE "#{session_name}:"
#define NEW_WINDOW_TEMPLATE BREAK_PANE_TEMPLATE
#define SPLIT_WINDOW_TEMPLATE BREAK_PANE_TEMPLATE
@


1.473
log
@Instead of setting up the default keys by building the key struct
directly with a helper function in the cmd_entry, include a table of
bind-key commands and pass them through the command parser and a
temporary cmd_q.

As well as being smaller, this will allow default bindings to be command
sequences which will probably be needed soon.
@
text
@d1 1
a1 1
/* $OpenBSD: tmux.h,v 1.472 2014/10/08 17:35:58 nicm Exp $ */
a23 1
#include <sys/param.h>
a30 1
#include <getopt.h>
a32 1
#include <signal.h>
d1565 1
a1565 1
extern char	 socket_path[MAXPATHLEN];
@


1.472
log
@Add xreallocarray and remove nmemb argument from xrealloc.
@
text
@d1 1
a1 1
/* $OpenBSD: tmux.h,v 1.471 2014/09/01 21:58:41 nicm Exp $ */
a1494 1
	void		 (*key_binding)(struct cmd *, int);
@


1.471
log
@Wake up any clients waiting with the wait-for command when the server
exits.
@
text
@d1 1
a1 1
/* $OpenBSD: tmux.h,v 1.470 2014/09/01 21:50:18 nicm Exp $ */
d2411 2
a2412 1
void		*xrealloc(void *, size_t, size_t);
@


1.470
log
@Various minor style and spacing nits.
@
text
@d1 1
a1 1
/* $OpenBSD: tmux.h,v 1.469 2014/08/11 22:18:16 nicm Exp $ */
d1926 3
@


1.469
log
@Fix two copy mode problems:

1. In vi mode the selection doesn't include the last character if you
   moved the cursor up or left.
2. In emacs mode the selection includes the last character if you moved
   the cursor to the left.

From Balazs Kezes.
@
text
@d1 1
a1 1
/* $OpenBSD: tmux.h,v 1.468 2014/08/11 22:14:30 nicm Exp $ */
d2328 1
a2328 1
void	control_callback(struct client *, int, void*);
@


1.468
log
@Add flags to selectp to enable and disable input to a pane, from Anish
Athalye.
@
text
@d1 1
a1 1
/* $OpenBSD: tmux.h,v 1.467 2014/08/09 07:33:37 nicm Exp $ */
d797 1
@


1.467
log
@Remove support for the continuous reporting "any" mouse mode which never
really worked properly and is rarely used.
@
text
@d1 1
a1 1
/* $OpenBSD: tmux.h,v 1.466 2014/07/21 10:25:48 nicm Exp $ */
d959 1
@


1.466
log
@Drop explicit support for F13-F20 and change to match the xterm terminfo
entry:

        F13-F24 are S-F1 to S-F12
        F25-F36 are C-F1 to C-F12
        F37-F48 are C-S-F1 to C-S-F12
        F49-F60 are M-F1 to M-F12
and     F61-F63 are M-S-F1 to M-S-F3

This should be no difference for applications inside tmux, but means
that any key binding for F13 will need to be replaced by S-F1 and so on.
@
text
@d1 1
a1 1
/* $OpenBSD: tmux.h,v 1.465 2014/06/06 13:21:41 nicm Exp $ */
d685 1
a685 1
#define MODE_MOUSE_ANY 0x80
d691 1
a691 1
#define ALL_MOUSE_MODES (MODE_MOUSE_STANDARD|MODE_MOUSE_BUTTON|MODE_MOUSE_ANY)
@


1.465
log
@Properly track switching G0 and G1 modes between US-ASCII and VT100 line
drawing rather than just treating them as SO and SI.
@
text
@d1 1
a1 1
/* $OpenBSD: tmux.h,v 1.464 2014/05/14 06:21:19 nicm Exp $ */
a197 8
	KEYC_F13,
	KEYC_F14,
	KEYC_F15,
	KEYC_F16,
	KEYC_F17,
	KEYC_F18,
	KEYC_F19,
	KEYC_F20,
d303 63
a365 20
	TTYC_KF1,	/* key_f1, k1 */
	TTYC_KF10,	/* key_f10, k; */
	TTYC_KF11,	/* key_f11, F1 */
	TTYC_KF12,	/* key_f12, F2 */
	TTYC_KF13,	/* key_f13, F3 */
	TTYC_KF14,	/* key_f14, F4 */
	TTYC_KF15,	/* key_f15, F5 */
	TTYC_KF16,	/* key_f16, F6 */
	TTYC_KF17,	/* key_f17, F7 */
	TTYC_KF18,	/* key_f18, F8 */
	TTYC_KF19,	/* key_f19, F9 */
	TTYC_KF2,	/* key_f2, k2 */
	TTYC_KF20,	/* key_f20, F10 */
	TTYC_KF3,	/* key_f3, k3 */
	TTYC_KF4,	/* key_f4, k4 */
	TTYC_KF5,	/* key_f5, k5 */
	TTYC_KF6,	/* key_f6, k6 */
	TTYC_KF7,	/* key_f7, k7 */
	TTYC_KF8,	/* key_f8, k8 */
	TTYC_KF9,	/* key_f9, k9 */
@


1.464
log
@Now that cmdlists are reference counted, there is no need for two-step
deletion via the dead_key_bindings tree. From Keith Amling.
@
text
@d1 1
a1 1
/* $OpenBSD: tmux.h,v 1.463 2014/05/13 08:08:32 nicm Exp $ */
d806 8
d819 1
a819 1
	struct grid_cell	cell;
d821 1
a821 1
	struct grid_cell	old_cell;
d833 1
a833 1
	u_char*			input_buf;
@


1.463
log
@If multiple arguments are given to new-session, new-window,
split-window, respawn-window or respawn-pane, pass them directly to
execvp() to help avoid quoting problems. One argument still goes to "sh
-c" like before. Requested by many over the years. Patch from J Raynor.
@
text
@d1 1
a1 1
/* $OpenBSD: tmux.h,v 1.462 2014/05/13 07:54:20 nicm Exp $ */
a1891 1
void	 key_bindings_clean(void);
@


1.462
log
@Add a copy mode key binding to copy to a named buffer. From J Raynor.
@
text
@d1 1
a1 1
/* $OpenBSD: tmux.h,v 1.461 2014/05/13 07:34:35 nicm Exp $ */
d917 2
a918 1
	char		*cmd;
d1754 1
d2145 1
a2145 1
struct window	*window_create(const char *, const char *, const char *,
d2171 1
a2171 1
int		 window_pane_spawn(struct window_pane *, const char *,
d2309 3
a2311 3
struct session	*session_create(const char *, const char *, const char *, int,
		     struct environ *, struct termios *, int, u_int, u_int,
		     char **);
d2317 1
a2317 1
struct winlink	*session_new(struct session *, const char *, const char *,
d2319 2
a2320 2
struct winlink	*session_attach(
		     struct session *, struct window *, int, char **);
@


1.461
log
@Add support for named buffers. If you don't name a buffer, things work
much as before - buffers are automatically named "buffer0000",
"buffer0001" and so on and ordered as a stack. Buffers can be named
explicitly when creating ("loadb -b foo" etc) or renamed ("setb -b
buffer0000 -n foo"). If buffers are named explicitly, they are not
deleted when buffer-limit is reached. Diff from J Raynor.
@
text
@d1 1
a1 1
/* $OpenBSD: tmux.h,v 1.460 2014/05/09 09:11:24 nicm Exp $ */
d586 1
@


1.460
log
@Just use char ** for argv like normal people, not char *const *.
@
text
@d1 1
a1 1
/* $OpenBSD: tmux.h,v 1.459 2014/05/08 07:54:47 nicm Exp $ */
d88 1
a88 1
	"#{line}: #{buffer_size} bytes: #{buffer_sample}"
d121 2
a122 1
	"#{line}: #{buffer_size} bytes: \"#{buffer_sample}\""
d1040 7
d1510 1
a1510 1
#define CMD_BUFFER_USAGE "[-b buffer-index]"
d1722 1
a1722 1
struct paste_buffer *paste_walk_stack(u_int *);
d1724 1
a1724 1
struct paste_buffer *paste_get_index(u_int);
d1726 4
a1729 3
int		 paste_free_index(u_int);
void		 paste_add(char *, size_t, u_int);
int		 paste_replace(u_int, char *, size_t);
@


1.459
log
@Instead of forcing mouse scroll to 1 in choose mode, scale it down
instead. Means modifier keys still increase the line count, just not as
much. Based on a diff from Marcel Partap.
@
text
@d1 1
a1 1
/* $OpenBSD: tmux.h,v 1.458 2014/05/08 06:03:30 nicm Exp $ */
d1741 1
a1741 1
char	       **cmd_copy_argv(int, char *const *);
@


1.458
log
@Both the two previous ways of navigating panes by direction have
irritating flaws:

a) The old way of always using the top or left if the choice is
ambiguous is annoying when the layout is unbalanced.

b) The new way of remembering the last used pane is annoying if the
layout is balanced and the leftmost is obvious to the user (because
clearly if we go right from the top-left in a tiled set of four we want
to end up in top-right, even if we were last using the bottom-right).

So instead, use a combination of both: if there is only one possible
pane alongside the current pane, move to it, otherwise choose the most
recently used of the choice.
@
text
@d1 1
a1 1
/* $OpenBSD: tmux.h,v 1.457 2014/04/24 09:14:43 nicm Exp $ */
d1132 3
@


1.457
log
@There is no longer a need for a paste_stack struct or for global_buffers
to be global. Move to paste.c.
@
text
@d1 1
a1 1
/* $OpenBSD: tmux.h,v 1.456 2014/04/17 15:37:55 nicm Exp $ */
d895 1
d952 1
a1029 2
	struct window_pane *lastwp;

@


1.456
log
@Add some UTF-8 utility functions and use them to prevent the width limit
on formats from splitting UTF-8 characters improperly.
@
text
@d1 1
a1 1
/* $OpenBSD: tmux.h,v 1.455 2014/04/17 13:02:59 nicm Exp $ */
a1039 1
ARRAY_DECL(paste_stack, struct paste_buffer *);
d1711 7
a1717 7
struct paste_buffer *paste_walk_stack(struct paste_stack *, u_int *);
struct paste_buffer *paste_get_top(struct paste_stack *);
struct paste_buffer *paste_get_index(struct paste_stack *, u_int);
int		 paste_free_top(struct paste_stack *);
int		 paste_free_index(struct paste_stack *, u_int);
void		 paste_add(struct paste_stack *, char *, size_t, u_int);
int		 paste_replace(struct paste_stack *, u_int, char *, size_t);
a1887 1
extern struct paste_stack global_buffers;
@


1.455
log
@Set PATH explicitly, either from client or session
environment. Previously it came from the session environment. From J
Raynor.
@
text
@d1 1
a1 1
/* $OpenBSD: tmux.h,v 1.454 2014/04/17 12:43:38 nicm Exp $ */
d2309 1
a2309 1
struct winlink*	 session_has(struct session *, struct window *);
d2325 11
a2335 6
void	utf8_build(void);
int	utf8_open(struct utf8_data *, u_char);
int	utf8_append(struct utf8_data *, u_char);
u_int	utf8_combine(const struct utf8_data *);
u_int	utf8_split2(u_int, u_char *);
int	utf8_strvis(char *, const char *, size_t, int);
@


1.454
log
@Don't limit the DCS buffer to 256 bytes, expand it as needed. Requested
by Suraj Kurapati.
@
text
@d1 1
a1 1
/* $OpenBSD: tmux.h,v 1.453 2014/04/17 09:13:13 nicm Exp $ */
d2132 3
a2134 3
struct window	*window_create(const char *, const char *, const char *, int,
		     struct environ *, struct termios *, u_int, u_int, u_int,
		     char **);
d2159 2
a2160 2
		     const char *, int, struct environ *, struct termios *,
		     char **);
d2296 1
a2296 1
struct session	*session_create(const char *, const char *, int,
d2304 2
a2305 2
struct winlink	*session_new(struct session *, const char *, const char *, int,
		     int, char **);
@


1.453
log
@Correct the dance to fix the active pane in join-pane by pulling the
(right) code from break-pane and window_remove_pane into a helper
function.
@
text
@d1 1
a1 1
/* $OpenBSD: tmux.h,v 1.452 2014/04/17 07:55:43 nicm Exp $ */
d821 3
a823 1
	u_char			input_buf[256];
d825 1
@


1.452
log
@Remove the "info" message mechanism, this was only used for about five
mostly useless and annoying messages. Change those commands to silence
on success like all the others. Still accept the -q command line flag
and "quiet" server option for now.
@
text
@d1 1
a1 1
/* $OpenBSD: tmux.h,v 1.451 2014/04/17 07:36:45 nicm Exp $ */
d2141 1
@


1.451
log
@Remove the monitor-content option and associated bits and bobs. It's
never worked very well. If there is a big demand for it to return, will
consider better ways to do it.
@
text
@d1 1
a1 1
/* $OpenBSD: tmux.h,v 1.450 2014/04/16 21:16:19 nicm Exp $ */
a1853 1
void printflike2 cmdq_info(struct cmd_q *, const char *, ...);
@


1.450
log
@Remove a leftover prototype and fix some spacing.
@
text
@d1 1
a1 1
/* $OpenBSD: tmux.h,v 1.449 2014/04/16 21:02:41 nicm Exp $ */
d993 2
a994 4
#define WINLINK_CONTENT 0x4
#define WINLINK_SILENCE 0x8
#define WINLINK_ALERTFLAGS \
    (WINLINK_BELL|WINLINK_ACTIVITY|WINLINK_CONTENT|WINLINK_SILENCE)
@


1.449
log
@Remove the choose-list command to prepare for some later choose-* work.
@
text
@d1 1
a1 1
/* $OpenBSD: tmux.h,v 1.448 2014/04/03 08:20:29 nicm Exp $ */
a2337 1
void printflike1 log_debug2(const char *, ...);
d2358 4
a2361 2
void	style_apply(struct grid_cell *, struct options *, const char *);
void	style_apply_update(struct grid_cell *, struct options *, const char *);
@


1.448
log
@Work out mouse scroll wheel effect when the mouse is first detected and
store it in struct mouse_event, reduce the scroll size the 3 but allow
shift to reduce it to 1 and meta and ctrl to multiply by 3 if the
terminal supports them, also support wheel in choose mode. From Marcel
Partap.
@
text
@d1 1
a1 1
/* $OpenBSD: tmux.h,v 1.447 2014/04/02 18:12:18 nicm Exp $ */
a1761 1
extern const struct cmd_entry cmd_choose_list_entry;
@


1.447
log
@Support UTF-8 with choose-buffer, from Kosuke ASAMI. Also make
buffer_sample bigger to let it trim at window right edge.
@
text
@d1 1
a1 1
/* $OpenBSD: tmux.h,v 1.446 2014/04/01 05:50:30 deraadt Exp $ */
d1171 1
@


1.446
log
@missed commit matching log.c
@
text
@d1 1
a1 1
/* $OpenBSD: tmux.h,v 1.445 2014/03/31 21:42:27 nicm Exp $ */
d88 1
a88 1
	"#{line}: #{buffer_size} bytes: \"#{buffer_sample}\""
d1547 1
a1547 1
		     struct paste_buffer *);
d1717 1
a1717 1
char		*paste_print(struct paste_buffer *, size_t);
d2329 1
@


1.445
log
@GRID_DEBUG is no longer needed.
@
text
@d1 1
a1 1
/* $OpenBSD: tmux.h,v 1.444 2014/03/31 21:42:05 nicm Exp $ */
d2334 1
a2334 1
void		 log_open(int, const char *);
@


1.444
log
@Remove unused log functions.
@
text
@d1 1
a1 1
/* $OpenBSD: tmux.h,v 1.443 2014/03/31 21:40:21 nicm Exp $ */
a664 10

/* Grid output. */
#if defined(DEBUG) && \
    ((defined(__STDC_VERSION__) && __STDC_VERSION__ >= 199901L) || \
     (defined(__GNUC__) && __GNUC__ >= 3))
#define GRID_DEBUG(gd, fmt, ...) log_debug2("%s: (sx=%u, sy=%u, hsize=%u) " \
    fmt, __func__, (gd)->sx, (gd)->sy, (gd)->hsize, ## __VA_ARGS__)
#else
#define GRID_DEBUG(...)
#endif
@


1.443
log
@Add names for mouse button bits rather than using magic numbers, from
Marcel Partap.
@
text
@d1 1
a1 1
/* $OpenBSD: tmux.h,v 1.442 2014/03/31 21:39:59 nicm Exp $ */
a2345 3
void printflike1 log_warn(const char *, ...);
void printflike1 log_warnx(const char *, ...);
void printflike1 log_info(const char *, ...);
@


1.442
log
@Use hex constants rather than shifts for mouse events and flags, pointed
out by Marcel Partap.
@
text
@d1 1
a1 1
/* $OpenBSD: tmux.h,v 1.441 2014/03/31 21:39:31 nicm Exp $ */
d1131 8
d1143 1
a1143 1
/* Mouse events. */
d1150 1
a1150 1
/* Mouse flags. */
@


1.441
log
@Add setb -a to append and a copy mode append command, from J Raynor with
minor changes.
@
text
@d1 1
a1 1
/* $OpenBSD: tmux.h,v 1.440 2014/03/31 21:37:55 nicm Exp $ */
d1136 5
a1140 5
#define MOUSE_EVENT_DOWN (1 << 0)
#define MOUSE_EVENT_DRAG (1 << 1)
#define MOUSE_EVENT_UP (1 << 2)
#define MOUSE_EVENT_CLICK (1 << 3)
#define MOUSE_EVENT_WHEEL (1 << 4)
d1143 1
a1143 1
#define MOUSE_RESIZE_PANE (1 << 0)
@


1.440
log
@Make session_attached a count and add session_many_attached flag.
@
text
@d1 1
a1 1
/* $OpenBSD: tmux.h,v 1.439 2014/03/31 21:36:43 nicm Exp $ */
d543 1
@


1.439
log
@Add start-of-list, end-of-list, top-line and bottom-line in choice mode,
from madmaverick9 at roxxmail dot eu, similar diff a few days later from
Marcel Partap.
@
text
@d1 1
a1 1
/* $OpenBSD: tmux.h,v 1.438 2014/03/31 21:34:08 nicm Exp $ */
d1088 2
@


1.438
log
@Having three *clock* files is ridiculous, remove clock.c.
@
text
@d1 1
a1 1
/* $OpenBSD: tmux.h,v 1.437 2014/02/23 00:53:06 nicm Exp $ */
d523 1
d527 1
d533 2
@


1.437
log
@Change terminal-overrides to a server option (now that we have them), it
doesn't make much sense as a session option.
@
text
@d1 1
a1 1
/* $OpenBSD: tmux.h,v 1.436 2014/01/31 14:19:24 nicm Exp $ */
a1715 4
/* clock.c */
extern const char clock_table[14][5][5];
void		 clock_draw(struct screen_write_ctx *, int, int);

d2221 1
@


1.436
log
@Break up and simplify screen_redraw_screen.
@
text
@d1 1
a1 1
/* $OpenBSD: tmux.h,v 1.435 2014/01/28 23:07:09 nicm Exp $ */
d1653 1
a1653 1
int	tty_open(struct tty *, const char *, char **);
d1682 1
a1682 1
struct tty_term *tty_term_find(char *, int, const char *, char **);
d1896 1
a1896 1
int      server_client_open(struct client *, struct session *, char **);
@


1.435
log
@Allow replacing each of the many sets of separate foo-{fg,bg,attr}
options with a single foo-style option. For example:

    set -g status-fg yellow
    set -g status-bg red
    set -g status-attr blink

Becomes:

    set -g status-style fg=yellow,bg=red,blink

The -a flag to set can be used to add to rather than replace a style. So:

    set -g status-bg red

Becomes:

    set -ag status-style bg=red

Currently this is fully backwards compatible (all *-{fg,bg,attr} options
remain) but the plan is to deprecate them over time.

From Tiago Cunha.
@
text
@d1 1
a1 1
/* $OpenBSD: tmux.h,v 1.434 2014/01/28 22:19:17 nicm Exp $ */
d2087 1
a2087 1
void	 screen_redraw_screen(struct client *, int, int);
@


1.434
log
@Remember the last active pane in the top-bottom or left-right cell so
that it can be restored when moving back to that cell with selectp
-L/-R/etc. From Suraj N Kurapati.
@
text
@d1 1
a1 1
/* $OpenBSD: tmux.h,v 1.433 2014/01/09 14:20:55 nicm Exp $ */
d729 1
a729 1
		OPTIONS_DATA,
d732 3
a734 2
	char		*str;
	long long	 num;
d1457 2
a1458 1
	OPTIONS_TABLE_CHOICE
d1471 2
d1584 2
a1585 2
struct options_entry *printflike3 options_set_string(
	    struct options *, const char *, const char *, ...);
d1587 2
a1588 2
struct options_entry *options_set_number(
	    struct options *, const char *, long long);
d1590 3
a2051 2
void	 screen_write_parsestyle(
	     struct grid_cell *, struct grid_cell *, const char *);
a2180 1
void		 window_mode_attrs(struct grid_cell *, struct options *);
d2351 10
@


1.433
log
@Allow attach-session -t to accept a window and pane to select them on
attach. Based on a diff from J Raynor.
@
text
@d1 1
a1 1
/* $OpenBSD: tmux.h,v 1.432 2013/10/23 11:31:03 nicm Exp $ */
d1031 2
@


1.432
log
@Key to swap to other end of selection (bound to o with vi keys), from J
Raynor.
@
text
@d1 1
a1 1
/* $OpenBSD: tmux.h,v 1.431 2013/10/20 17:28:43 nicm Exp $ */
d1742 2
@


1.431
log
@Do not run any command line command from the client which starts the
server until after the configuration file completes. This prevents it
racing against run-shell or if-shell in .tmux.conf that run in the
background.
@
text
@d1 1
a1 1
/* $OpenBSD: tmux.h,v 1.430 2013/10/10 12:39:25 nicm Exp $ */
d567 1
@


1.430
log
@Remove the KERN_PROC_CWD the proc_current_path format (which is the only
thing that uses it now).
@
text
@d1 1
a1 1
/* $OpenBSD: tmux.h,v 1.429 2013/10/10 12:29:35 nicm Exp $ */
d1513 1
@


1.429
log
@We accidentally haven't been using $TMUX to work out the session for a
while and in fact it is less useful that using the client ttyname. So
don't bother and don't pass it from the client. If we need it in future
it is in c->environ.
@
text
@d1 1
a1 1
/* $OpenBSD: tmux.h,v 1.428 2013/10/10 12:26:36 nicm Exp $ */
a2319 1
char   *get_proc_cwd(int);
@


1.428
log
@Alter how tmux handles the working directory to internally use file
descriptors rather than strings.

- Each session still has a current working directory.

- New sessions still get their working directory from the client that
  created them or its attached session if any.

- New windows are created by default in the session working directory.

- The -c flag to new, neww, splitw allows the working directory to be
  overridden.

- The -c flag to attach let's the session working directory be changed.

- The default-path option has been removed.

To get the equivalent to default-path '.', do:

        bind c neww -c $PWD

To get the equivalent of default-path '~', do:

        bind c neww -c ~

This also changes the client identify protocol to be a set of messages rather
than one as well as some other changes that should make it easier to make
backwards-compatible protocol changes in future.
@
text
@d1 1
a1 1
/* $OpenBSD: tmux.h,v 1.427 2013/10/10 12:13:56 nicm Exp $ */
a466 3
	pid_t	pid;		/* from $TMUX or -1 */
	int	session_id;	/* from $TMUX or -1 */

a1407 2
	struct msg_command_data	*msgdata;

a1500 2
extern pid_t	 environ_pid;
extern int	 environ_session_id;
@


1.427
log
@Similarly for MSG_COMMAND - allow full imsg limit not arbitrary 2048.
@
text
@d1 1
a1 1
/* $OpenBSD: tmux.h,v 1.426 2013/10/10 12:13:29 nicm Exp $ */
a61 7
 * Maximum sizes of strings in message data. Don't forget to bump
 * PROTOCOL_VERSION if any of these change!
 */
#define TERMINAL_LENGTH 128	/* length of TERM environment variable */
#define ENVIRON_LENGTH 1024	/* environment variable length */

/*
a458 3

	MSG_IDENTIFY = 300,
	MSG_ENVIRON
a472 11
struct msg_identify_data {
	char		cwd[MAXPATHLEN];
	char		term[TERMINAL_LENGTH];

	int		flags;
};

struct msg_environ_data {
	char		var[ENVIRON_LENGTH];
};

d919 1
a919 1
	char		*cwd;
d1066 1
a1066 1
	char		*cwd;
d1266 1
d1276 1
a1276 1
	char		*cwd;
d1278 2
a1511 1
const char*	 get_full_path(const char *, const char *);
a1746 1
const char     	*cmd_default_path(const char *, const char *, const char *);
d1837 2
a1838 1
enum cmd_retval	 cmd_attach_session(struct cmd_q *, const char*, int, int);
a1855 1
const char     	*cmdq_default_path(struct cmd_q *, const char *);
d2127 3
a2129 3
struct window	*window_create(const char *, const char *, const char *,
		     const char *, struct environ *, struct termios *,
		     u_int, u_int, u_int, char **);
d2153 2
a2154 2
		     const char *, const char *, struct environ *,
		     struct termios *, char **);
d2290 1
a2290 1
struct session	*session_create(const char *, const char *, const char *,
d2298 2
a2299 2
struct winlink	*session_new(struct session *,
		     const char *, const char *, const char *, int, char **);
@


1.426
log
@Instead of fixed size buffers for some messages, send only the string
length.
@
text
@d1 1
a1 1
/* $OpenBSD: tmux.h,v 1.425 2013/10/10 12:12:54 nicm Exp $ */
a64 1
#define COMMAND_LENGTH 2048	/* packed argv size */
d477 2
a478 2
	pid_t		pid;		/* from $TMUX or -1 */
	int		session_id;	/* from $TMUX or -1 */
d480 2
a481 3
	int		argc;
	char		argv[COMMAND_LENGTH];
};
a484 1

d1319 1
a1319 1
#define CLIENT_REPEAT 0x20 /* allow command to repeat within repeat time */
d1922 4
a1925 4
int	 server_write_client(
	     struct client *, enum msgtype, const void *, size_t);
void	 server_write_session(
	     struct session *, enum msgtype, const void *, size_t);
@


1.425
log
@retcode -> retval for exit message.
@
text
@d1 1
a1 1
/* $OpenBSD: tmux.h,v 1.424 2013/10/10 12:12:08 nicm Exp $ */
a492 4
struct msg_lock_data {
	char		cmd[COMMAND_LENGTH];
};

a494 8
};

struct msg_shell_data {
	char		shell[MAXPATHLEN];
};

struct msg_exit_data {
	int		retcode;
@


1.424
log
@Merge IDENTIFY_* flags with CLIENT_* flags.
@
text
@d1 1
a1 1
/* $OpenBSD: tmux.h,v 1.423 2013/10/10 12:11:45 nicm Exp $ */
d1301 1
d1303 1
a1303 1
	int		 retcode;
@


1.423
log
@Bump protocol version and add new message types.
@
text
@d1 1
a1 1
/* $OpenBSD: tmux.h,v 1.422 2013/10/10 12:09:34 nicm Exp $ */
a489 5
#define IDENTIFY_UTF8 0x1
#define IDENTIFY_256COLOURS 0x2
/* 0x4 unused */
#define IDENTIFY_CONTROL 0x8
#define IDENTIFY_TERMIOS 0x10
d1342 5
a1346 1
#define CLIENT_FOCUSED 0x4000
@


1.422
log
@Remove CMD_SENDENVIRON.
@
text
@d1 1
a1 1
/* $OpenBSD: tmux.h,v 1.421 2013/10/10 12:07:37 nicm Exp $ */
d22 1
a22 1
#define PROTOCOL_VERSION 7
d440 11
a450 1
	MSG_COMMAND,
d452 1
a452 1
	MSG_ERROR,
d456 1
a456 2
	MSG_IDENTIFY,
	MSG_STDIN,
d459 1
d461 3
d465 1
a465 1
	MSG_VERSION,
d467 3
a469 7
	MSG_ENVIRON,
	MSG_UNLOCK,
	MSG_LOCK,
	MSG_SHELL,
	MSG_STDERR,
	MSG_STDOUT,
	MSG_DETACHKILL
@


1.421
log
@Support -c for new-session, based on code from J Raynor.
@
text
@d1 1
a1 1
/* $OpenBSD: tmux.h,v 1.420 2013/10/10 12:02:24 nicm Exp $ */
d1453 1
a1453 2
#define CMD_SENDENVIRON 0x4
#define CMD_READONLY 0x8
@


1.420
log
@No space in lsw -a targets.
@
text
@d1 1
a1 1
/* $OpenBSD: tmux.h,v 1.419 2013/10/10 12:00:24 nicm Exp $ */
d1773 1
a1773 1
const char     	*cmd_get_default_path(struct cmd_q *, const char *);
d1882 1
@


1.419
log
@Remove the barely-used and unnecessary command check() function.
@
text
@d1 1
a1 1
/* $OpenBSD: tmux.h,v 1.418 2013/10/10 11:59:23 nicm Exp $ */
d154 1
a154 1
	"#{session_name}: "					\
@


1.418
log
@Clear window->flags when clearing winlinks

When clearing WINLINK_ALERTFLAGS for all sessions, we must also, for
that window, clear the window->flags as well, otherwise sessions may
well still see flags for winlinks long since cleared.

This therefore introduces WINDOW_ALERTFLAGS to help with this.
@
text
@d1 1
a1 1
/* $OpenBSD: tmux.h,v 1.417 2013/10/10 11:56:50 nicm Exp $ */
a1457 1
	int		 (*check)(struct args *);
@


1.417
log
@Add automatic-rename-format option allowing automatic rename to use
something other than pane_current_command.
@
text
@d1 1
a1 1
/* $OpenBSD: tmux.h,v 1.416 2013/10/10 11:45:29 nicm Exp $ */
d1011 1
@


1.416
log
@Pass flags into cmdq_guard as an argument since sometimes cmdq->cmd can
be NULL. Avoids crash when a command in a command client can't be
parsed.
@
text
@d1 1
a1 1
/* $OpenBSD: tmux.h,v 1.415 2013/07/05 14:38:23 nicm Exp $ */
d1555 2
a1556 2
void printflike3 format_add(
		     struct format_tree *, const char *, const char *, ...);
d1561 7
a1567 4
void		 format_winlink(
		     struct format_tree *, struct session *, struct winlink *);
void		 format_window_pane(struct format_tree *, struct window_pane *);
void		 format_paste_buffer(struct format_tree *, struct paste_buffer *);
d2281 4
a2284 2
void		 queue_window_name(struct window *);
char		*default_window_name(struct window *);
@


1.415
log
@Implement s, S, C mode switch commands in vi(1) mode, from Ben Boeckel.
@
text
@d1 1
a1 1
/* $OpenBSD: tmux.h,v 1.414 2013/06/23 13:10:48 nicm Exp $ */
d1874 1
a1874 1
int		 cmdq_guard(struct cmd_q *, const char *);
@


1.414
log
@Focus events can cause trouble if left on and they can't be turned off
during idle periods (like the other states are) because we'd miss
events. So add a server option to control them. Defaults to off.
@
text
@d1 1
a1 1
/* $OpenBSD: tmux.h,v 1.413 2013/06/23 12:51:29 nicm Exp $ */
d551 3
@


1.413
log
@Always push a focus event when the application turns it on, prompted by
discussion with Hayaki Saito a while ago.
@
text
@d1 1
a1 1
/* $OpenBSD: tmux.h,v 1.412 2013/06/23 12:41:55 nicm Exp $ */
d1236 1
@


1.412
log
@Mark control commands specially so the client can identify them, based
on a diff from George Nachman a while back.
@
text
@d1 1
a1 1
/* $OpenBSD: tmux.h,v 1.411 2013/06/02 07:52:15 nicm Exp $ */
d944 1
@


1.411
log
@The actual terminfo entries we ended up with for cursor changes are Cs,
Ce, Ss and Se (not Cc, Ce, Cs, Csr). So use and document these instead
of the ones we were using earlier.
@
text
@d1 1
a1 1
/* $OpenBSD: tmux.h,v 1.410 2013/05/31 12:19:34 nicm Exp $ */
d1385 3
@


1.410
log
@Instead of eating 1024 bytes or so for the arguments of each command,
save memory by using an RB tree. From Tiago Cunha.
@
text
@d1 1
a1 1
/* $OpenBSD: tmux.h,v 1.409 2013/04/24 10:01:32 nicm Exp $ */
a255 1
	TTYC_CC,	/* set colour cursor, Cc */
d261 1
a261 1
	TTYC_CS1,	/* set cursor style, Cs */
a262 1
	TTYC_CSR1,	/* reset cursor style, Csr */
d392 1
d402 1
@


1.409
log
@Rename global configuration define.
@
text
@d1 1
a1 1
/* $OpenBSD: tmux.h,v 1.408 2013/04/22 22:17:29 nicm Exp $ */
d1364 8
a1371 1
/* Parsed arguments. */
d1373 3
a1375 5
	bitstr_t	*flags;
	char		*values[SCHAR_MAX]; /* XXX This is awfully big. */

	int		 argc;
	char	       **argv;
d1732 2
@


1.408
log
@When using choose-tree -u, start with the current window
highlighted. From Thomas Adam.
@
text
@d1 1
a1 1
/* $OpenBSD: tmux.h,v 1.407 2013/03/27 11:17:12 nicm Exp $ */
d46 2
a47 3
/* Default configuration files. */
#define DEFAULT_CFG ".tmux.conf"
#define SYSTEM_CFG "/etc/tmux.conf"
@


1.407
log
@Remove tmux's (already minimal) 88 colour support. Such terminals are
few and unnecessary.
@
text
@d1 1
a1 1
/* $OpenBSD: tmux.h,v 1.406 2013/03/25 11:44:00 nicm Exp $ */
d2260 2
@


1.406
log
@Add -P and -F to new-session.
@
text
@d1 1
a1 1
/* $OpenBSD: tmux.h,v 1.405 2013/03/25 11:43:01 nicm Exp $ */
d484 1
a484 1
#define IDENTIFY_88COLOURS 0x4
d1144 1
a1144 2
#define TERM_88COLOURS 0x2
#define TERM_EARLYWRAP 0x4
a1987 1
u_char	 colour_256to88(u_char);
@


1.405
log
@Extend jobs to support writing and use that for copy-pipe instead of
popen, from Chris Johnsen.
@
text
@d1 1
a1 1
/* $OpenBSD: tmux.h,v 1.404 2013/03/25 11:41:16 nicm Exp $ */
d162 1
@


1.404
log
@Only send end guard if begin was sent, from George Nachman.
@
text
@d1 1
a1 1
/* $OpenBSD: tmux.h,v 1.403 2013/03/25 11:35:55 nicm Exp $ */
a782 3
	struct bufferevent *out;
	int		outdone;

d1614 2
a1615 2
struct job *job_run(
	    const char *, void (*)(struct job *), void (*)(void *), void *);
@


1.403
log
@Add time and a command count to control mode guards, based on code from
George Nachman.
@
text
@d1 1
a1 1
/* $OpenBSD: tmux.h,v 1.402 2013/03/25 10:11:45 nicm Exp $ */
d1863 1
a1863 1
void		 cmdq_guard(struct cmd_q *, const char *);
@


1.402
log
@Rename session idx to session id throughout and add $ prefix to targets
to use it, extended from a diff from George Nachman.
@
text
@d1 1
a1 1
/* $OpenBSD: tmux.h,v 1.401 2013/03/25 10:09:07 nicm Exp $ */
d1419 3
d1863 1
@


1.401
log
@Add a wait-for command which blocks a client on a named channel until it
is woken up again (with wait-for -S). From Thiago Padilha.
@
text
@d1 1
a1 1
/* $OpenBSD: tmux.h,v 1.400 2013/03/25 10:05:35 nicm Exp $ */
d469 2
a470 2
	pid_t		pid;	/* PID from $TMUX or -1 */
	int		idx;	/* index from $TMUX or -1 */
d1093 1
a1093 1
	u_int		 idx;
d1520 1
a1520 1
extern int	 environ_idx;
d2294 1
a2294 1
struct session	*session_find_by_index(u_int);
@


1.400
log
@Preserve trailing spaces with capture-pane -J, from George Nachman.
@
text
@d1 1
a1 1
/* $OpenBSD: tmux.h,v 1.399 2013/03/24 09:58:40 nicm Exp $ */
d1423 2
d1844 1
@


1.399
log
@Add -A flag to new-session to make it behave like attach-session if the
session exists. If -A is used, -D behaves like -d to attach-session.
@
text
@d1 1
a1 1
/* $OpenBSD: tmux.h,v 1.398 2013/03/24 09:57:59 nicm Exp $ */
d2009 1
a2009 1
	     struct grid_cell **, int, int);
@


1.398
log
@Add resize-pane -Z to temporary zoom the active pane to occupy the full
window or unzoom (restored to the normal layout) if it already zoomed,
bound to C-b z by default. The pane is unzoomed on pretty much any
excuse whatsoever.

We considered making this a new layout but the requirements are quite
different from layouts so decided it is better as a special case. Each
current layout cell is saved, a temporary one-cell layout generated and
all except the active pane set to NULL.

Prompted by suggestions and scripts from several. Thanks to Aaron Jensen
and Thiago Padilha for testing an earlier version.
@
text
@d1 1
a1 1
/* $OpenBSD: tmux.h,v 1.397 2013/03/24 09:54:10 nicm Exp $ */
d1842 3
@


1.397
log
@Add a command queue to standardize and simplify commands that call other
commands and allow a command to block execution of subsequent
commands. This allows run-shell and if-shell to be synchronous which has
been much requested.

Each client has a default command queue and commands are consumed one at
a time from it. A command may suspend execution from the queue by
returning CMD_RETURN_WAIT and then resume it by calling cmd_continue() -
for example run-shell does this from the callback that is fired after
the job is freed.

When the command queue becomes empty, command clients are automatically
exited (unless attaching). A callback is also fired - this is used for
nested commands in, for example, if-shell which can block execution of
the client's cmdq until a new cmdq becomes empty.

Also merge all the old error/info/print functions together and lose the
old curclient/cmdclient distinction - a cmdq is bound to one client (or
none if in the configuration file), this is a command client if
c->session is NULL otherwise an attached client.
@
text
@d1 1
a1 1
/* $OpenBSD: tmux.h,v 1.396 2013/03/24 09:28:59 nicm Exp $ */
d932 1
d934 1
d999 1
d1009 1
d1936 1
d2140 2
d2198 1
a2198 1
void		 layout_init(struct window *);
@


1.396
log
@Handle focus events from the terminal, from Aaron Jensen.
@
text
@d1 1
a1 1
/* $OpenBSD: tmux.h,v 1.395 2013/03/24 09:27:20 nicm Exp $ */
d435 3
d783 3
d1359 1
d1373 1
a1373 31
/* Key/command line command. */
struct cmd_ctx {
	/*
	 * curclient is the client where this command was executed if inside
	 * tmux. This is NULL if the command came from the command-line.
	 *
	 * cmdclient is the client which sent the MSG_COMMAND to the server, if
	 * any. This is NULL unless the command came from the command-line.
	 *
	 * cmdclient and curclient may both be NULL if the command is in the
	 * configuration file.
	 */
	struct client		*curclient;
	struct client		*cmdclient;

	int			 references;

	struct msg_command_data	*msgdata;

	/* gcc2 doesn't understand attributes on function pointers... */
#if defined(__GNUC__) && __GNUC__ >= 3
	void printflike2 (*print)(struct cmd_ctx *, const char *, ...);
	void printflike2 (*info)(struct cmd_ctx *, const char *, ...);
	void printflike2 (*error)(struct cmd_ctx *, const char *, ...);
#else
	void (*print)(struct cmd_ctx *, const char *, ...);
	void (*info)(struct cmd_ctx *, const char *, ...);
	void (*error)(struct cmd_ctx *, const char *, ...);
#endif
};

d1378 3
d1388 1
d1392 27
a1418 2
	CMD_RETURN_YIELD,
	CMD_RETURN_ATTACH
d1421 1
d1440 1
a1440 1
	enum cmd_retval	 (*exec)(struct cmd *, struct cmd_ctx *);
a1488 3
/* List of configuration causes. */
ARRAY_DECL(causelist, char *);

d1524 3
a1526 2
extern int       cfg_finished;
extern int       cfg_references;
d1528 3
a1530 3
void printflike2 cfg_add_cause(struct causelist *, const char *, ...);
enum cmd_retval	 load_cfg(const char *, struct cmd_ctx *, struct causelist *);
void		 show_cfg_causes(struct session *);
a1732 3
struct cmd_ctx	*cmd_get_ctx(struct client *, struct client *);
void		 cmd_free_ctx(struct cmd_ctx *);
void		 cmd_ref_ctx(struct cmd_ctx *);
d1737 1
a1737 1
struct cmd	*cmd_parse(int, char **, char **);
d1739 10
a1748 10
struct session	*cmd_current_session(struct cmd_ctx *, int);
struct client	*cmd_current_client(struct cmd_ctx *);
struct client	*cmd_find_client(struct cmd_ctx *, const char *, int);
struct session	*cmd_find_session(struct cmd_ctx *, const char *, int);
struct winlink	*cmd_find_window(
		     struct cmd_ctx *, const char *, struct session **);
int		 cmd_find_index(
		     struct cmd_ctx *, const char *, struct session **);
struct winlink	*cmd_find_pane(struct cmd_ctx *,
		     const char *, struct session **, struct window_pane **);
d1750 1
a1750 1
const char     	*cmd_get_default_path(struct cmd_ctx *, const char *);
d1840 1
a1840 2
struct cmd_list	*cmd_list_parse(int, char **, char **);
enum cmd_retval	 cmd_list_exec(struct cmd_list *, struct cmd_ctx *);
d1844 11
d1856 2
a1857 1
int	cmd_string_parse(const char *, struct cmd_list **, char **);
a1871 3
void printflike2 key_bindings_error(struct cmd_ctx *, const char *, ...);
void printflike2 key_bindings_print(struct cmd_ctx *, const char *, ...);
void printflike2 key_bindings_info(struct cmd_ctx *, const char *, ...);
@


1.395
log
@Fix error reporting for client commands by adding a flag to
cmd_find_client to tell it whether or not to show errors, sometimes it's
needed and sometimes not.
@
text
@d1 1
a1 1
/* $OpenBSD: tmux.h,v 1.394 2013/03/24 09:25:04 nicm Exp $ */
d244 3
d1326 1
@


1.394
log
@Do pane resize ioctls once at the end of the server loop rather than
immediately.
@
text
@d1 1
a1 1
/* $OpenBSD: tmux.h,v 1.393 2013/03/24 09:18:16 nicm Exp $ */
d1735 1
a1735 1
struct client	*cmd_find_client(struct cmd_ctx *, const char *);
@


1.393
log
@Add support for focus notifications when tmux pane changes, based on
work by Aaron Jensen.
@
text
@d1 1
a1 1
/* $OpenBSD: tmux.h,v 1.392 2013/03/22 16:00:26 nicm Exp $ */
d935 1
@


1.392
log
@Add session_set_current helper function, extracted from a diff from
Aaron Jensen.
@
text
@d1 1
a1 1
/* $OpenBSD: tmux.h,v 1.391 2013/03/22 15:56:11 nicm Exp $ */
d672 1
d934 1
@


1.391
log
@Add -C and -J to capture pane to escape control sequences and to join
wrapped line, based on a diff from George Nachman.
@
text
@d1 1
a1 1
/* $OpenBSD: tmux.h,v 1.390 2013/03/22 15:54:29 nicm Exp $ */
d2283 1
@


1.390
log
@Need to set clients in context before changing their reference count.
@
text
@d1 1
a1 1
/* $OpenBSD: tmux.h,v 1.389 2013/03/22 15:52:41 nicm Exp $ */
d1976 1
d1984 1
a1984 1
	     struct grid_cell **, int);
@


1.389
log
@Add copy-pipe mode command to copy selection and also pipe to a command.
@
text
@d1 1
a1 1
/* $OpenBSD: tmux.h,v 1.388 2013/03/22 15:51:54 nicm Exp $ */
d1721 1
a1721 1
struct cmd_ctx	*cmd_get_ctx(void);
@


1.388
log
@Add -e flag to capture-pane to include embedded ANSI SGR escape
sequences, from George Nachman.
@
text
@d1 1
a1 1
/* $OpenBSD: tmux.h,v 1.387 2013/03/22 15:49:55 nicm Exp $ */
d569 1
d636 1
a636 1
	int			key;
d638 3
a640 2
	int			mode;
	enum mode_key_cmd	cmd;
d642 1
a642 1
	RB_ENTRY(mode_key_binding) entry;
d1553 1
a1553 1
enum mode_key_cmd mode_key_lookup(struct mode_key_data *, int);
@


1.387
log
@Add functions to allocate and free command contexts rather than doing it
all on the stack.
@
text
@d1 1
a1 1
/* $OpenBSD: tmux.h,v 1.386 2013/03/22 10:38:13 nicm Exp $ */
d1980 2
a1981 1
char	*grid_string_cells(struct grid *, u_int, u_int, u_int);
@


1.386
log
@Fix double space in sessions template.
@
text
@d1 1
a1 1
/* $OpenBSD: tmux.h,v 1.385 2013/03/22 10:37:39 nicm Exp $ */
d1369 4
a1372 2
	struct client  *curclient;
	struct client  *cmdclient;
d1719 3
a1726 2
enum cmd_retval	 cmd_exec(struct cmd *, struct cmd_ctx *);
void		 cmd_free(struct cmd *);
@


1.385
log
@Add resize-pane -x and -y for absolute pane size (much requested).
@
text
@d1 1
a1 1
/* $OpenBSD: tmux.h,v 1.384 2013/03/22 10:33:50 nicm Exp $ */
d108 1
a108 1
	"#{session_name}: #{session_windows} windows "		\
@


1.384
log
@Support the latest theory for mouse input, this is enabled/disabled with
SM/RM 1006 and is similar in style to SGR input: \033[<b;x;yM or
\033[b;x;ym. From Egmont Koblinger.
@
text
@d1 1
a1 1
/* $OpenBSD: tmux.h,v 1.383 2013/03/21 18:47:56 nicm Exp $ */
d1174 1
a1174 1
	u_int   sgr_rel;	/* only for SGR: whether it is a release event */
d2170 5
a2174 3
void		 layout_resize_pane(
		     struct window_pane *, enum layout_type, int);
void		 layout_resize_pane_mouse(struct client *c);
@


1.383
log
@Instead of loads of little screen_write_*_on and off functions which
just change mode flags, just have screen_write_mode_set and
screen_write_mode_clear.
@
text
@d1 1
a1 1
/* $OpenBSD: tmux.h,v 1.382 2013/03/21 18:44:47 nicm Exp $ */
d668 2
a669 1
#define MODE_BRACKETPASTE 0x200
d1157 3
d1171 4
@


1.382
log
@Include the \033 in the key tree and adjust key matching for this change.
@
text
@d1 1
a1 1
/* $OpenBSD: tmux.h,v 1.381 2013/03/21 16:50:22 nicm Exp $ */
d2019 2
a2034 1
void	 screen_write_cursormode(struct screen_write_ctx *, int);
a2036 4
void	 screen_write_insertmode(struct screen_write_ctx *, int);
void	 screen_write_utf8mousemode(struct screen_write_ctx *, int);
void	 screen_write_mousemode_on(struct screen_write_ctx *, int);
void	 screen_write_mousemode_off(struct screen_write_ctx *);
a2039 2
void	 screen_write_kcursormode(struct screen_write_ctx *, int);
void	 screen_write_kkeypadmode(struct screen_write_ctx *, int);
a2046 1
void	 screen_write_bracketpaste(struct screen_write_ctx *, int);
@


1.381
log
@Tidy by splitting default key tables into two.
@
text
@d1 1
a1 1
/* $OpenBSD: tmux.h,v 1.380 2013/03/21 16:19:25 nicm Exp $ */
d1209 1
a1209 1
#define TTY_ESCAPE 0x4
@


1.380
log
@Fix constness of cmd_template_replace, window_choose_add_item and
window_choose_add_window.
@
text
@d1 1
a1 1
/* $OpenBSD: tmux.h,v 1.379 2013/03/21 16:15:52 nicm Exp $ */
d1677 1
a1677 1
void	tty_keys_init(struct tty *);
@


1.379
log
@Add -v to set and setw to show only option value.
@
text
@d1 1
a1 1
/* $OpenBSD: tmux.h,v 1.378 2013/03/21 16:12:10 nicm Exp $ */
d1727 1
a1727 1
char		*cmd_template_replace(char *, const char *, int);
d2211 1
a2211 1
			const char *, char *, u_int);
d2214 1
a2214 1
			char *, u_int);
d2217 1
a2217 1
			char *, u_int);
@


1.378
log
@Rework reflow code so it does not do so much allocation which should be
faster with large histories.
@
text
@d1 1
a1 1
/* $OpenBSD: tmux.h,v 1.377 2013/03/21 16:09:59 nicm Exp $ */
d1575 5
a1579 6
void	options_table_populate_tree(
	    const struct options_table_entry *, struct options *);
const char *options_table_print_entry(
	    const struct options_table_entry *, struct options_entry *);
int	options_table_find(
	    const char *, const struct options_table_entry **,
@


1.377
log
@Allow choose commands to be used outside tmux, so long as at least one
client is attached.
@
text
@d1 1
a1 1
/* $OpenBSD: tmux.h,v 1.376 2013/03/21 16:09:17 nicm Exp $ */
d1973 1
a1973 1
u_int	 grid_reflow(struct grid *, const struct grid *, u_int);
@


1.376
log
@Remove free callback for window_choose_data objects.
@
text
@d1 1
a1 1
/* $OpenBSD: tmux.h,v 1.375 2013/03/21 16:08:24 nicm Exp $ */
d2211 1
a2211 1
			struct cmd_ctx *, struct session *, struct winlink *,
d2214 1
a2214 1
			struct cmd_ctx *, struct session *, const char *,
d2217 1
a2217 1
			struct cmd_ctx *, struct winlink *, const char *,
@


1.375
log
@Miscellaneous tidying of choose API, including:

- rename client and session to start_client and start_session in
  window_choose_data struct. also add TREE_OTHER define and reorder
  the struct
- rename window_choose_ctx to window_choose_data_run
- don't pass a cmd_ctx into window_choose_create (will let it use a
  different client later). instead take type, session, client
- add window_choose_data_free and use it to dispose of wcd rather than
  each cmd-*.c doing it individually
- change so ref counting is done by wcd_add and wcd_free rather than
  callers
- also add a ref to tree_session
- all the callbacks except choose-client and find-window are the same so
  remove them and add window_choose_default_callback
- reorder/rename some other bits and pieces for tidyness
@
text
@d1 1
a1 1
/* $OpenBSD: tmux.h,v 1.374 2013/02/05 11:08:59 nicm Exp $ */
d2205 1
a2205 2
		     u_int, void (*)(struct window_choose_data *),
		     void (*)(struct window_choose_data *));
@


1.374
log
@Automatically reflow wrapped lines when a pane is resized, requested by
many over the years and finally implemented by Richard Woodbury.
@
text
@d1 1
a1 1
/* $OpenBSD: tmux.h,v 1.373 2013/01/18 02:16:21 nicm Exp $ */
d886 3
a888 7
	struct client		*client;
	struct session		*session; /* Session of current client. */
	struct session		*tree_session; /* Session of items in tree. */
	struct format_tree	*ft;
	struct winlink		*wl;
	char		        *ft_template;
	char			*command;
d891 1
d894 4
d899 5
d2207 4
a2210 2
struct window_choose_data	*window_choose_data_create(struct cmd_ctx *);
void		 window_choose_ctx(struct window_choose_data *);
@


1.373
log
@Rather than having two grids for each pane, one for ASCII and one for
UTF-8, collapse the two together. Simplifies the code at the expense of
more memory (which can probably be reduced again later).
@
text
@d1 1
a1 1
/* $OpenBSD: tmux.h,v 1.372 2013/01/17 00:11:22 nicm Exp $ */
d1967 1
d2061 1
a2061 1
void	 screen_resize(struct screen *, u_int, u_int);
d2066 1
@


1.372
log
@Remove the layout undo/redo code which never really worked.
@
text
@d1 1
a1 1
/* $OpenBSD: tmux.h,v 1.371 2013/01/15 23:18:55 nicm Exp $ */
d672 1
a672 7
/*
 * A single UTF-8 character.
 *
 * The data member in this must be UTF8_SIZE to allow screen_write_copy to
 * reinject stored UTF-8 data back into screen_write_cell after combining (ugh
 * XXX XXX).
 */
a705 1
#define GRID_FLAG_UTF8 0x8
a715 2
	u_char	data;
} __packed;
d717 2
a718 4
/* Grid cell UTF-8 data. Used instead of data in grid_cell for UTF-8 cells. */
struct grid_utf8 {
	u_char	width;
	u_char	data[UTF8_SIZE];
a725 3
	u_int	utf8size;
	struct grid_utf8 *utf8data;

a1221 1
	const struct grid_utf8 *utf8;
a1241 1
	struct grid_utf8 last_utf8;
d1610 2
a1611 1
void	tty_putcode_ptr2(struct tty *, enum tty_code_code, const void *, const void *);
d1614 1
a1614 1
void	tty_pututf8(struct tty *, const struct grid_utf8 *);
a1956 1
void	 grid_expand_line_utf8(struct grid *, u_int, u_int);
a1959 3
const struct grid_utf8 *grid_peek_utf8(struct grid *, u_int, u_int);
struct grid_utf8 *grid_get_utf8(struct grid *, u_int, u_int);
void	 grid_set_utf8(struct grid *, u_int, u_int, const struct grid_utf8 *);
d1968 5
a1972 6
/* grid-utf8.c */
size_t	 grid_utf8_size(const struct grid_utf8 *);
size_t	 grid_utf8_copy(const struct grid_utf8 *, char *, size_t);
void	 grid_utf8_set(struct grid_utf8 *, const struct utf8_data *);
int	 grid_utf8_append(struct grid_utf8 *, const struct utf8_data *);
int	 grid_utf8_compare(const struct grid_utf8 *, const struct grid_utf8 *);
a1978 4
const struct grid_utf8 *grid_view_peek_utf8(struct grid *, u_int, u_int);
struct grid_utf8 *grid_view_get_utf8(struct grid *, u_int, u_int);
void	 grid_view_set_utf8(
	     struct grid *, u_int, u_int, const struct grid_utf8 *);
d2043 1
a2043 2
void	 screen_write_cell(struct screen_write_ctx *,
	     const struct grid_cell *, const struct utf8_data *);
@


1.371
log
@Implement ECH (erase character, CSI X). Reported by Christian Neukirchen.
@
text
@d1 1
a1 1
/* $OpenBSD: tmux.h,v 1.370 2013/01/15 22:55:29 nicm Exp $ */
a976 7
/* Window last layout. */
struct last_layout {
	char	*layout;

	TAILQ_ENTRY(last_layout) entry;
};

a989 3
	TAILQ_HEAD(last_layouts, last_layout) layout_list;
	u_int		 layout_list_size;
	struct last_layout *layout_list_last;
d2172 1
a2172 2
void		 layout_destroy_cell(
		     struct layout_cell *, struct layout_cell **);
a2192 3
void		 layout_list_add(struct window *);
const char	*layout_list_redo(struct window *);
const char	*layout_list_undo(struct window *);
@


1.370
log
@If timing between keys is less than (by default) 1 millisecond, assume
the text is being pasted. assume-paste-time option changes the value (0
disables). Based on a diff from Marcin Kulik.
@
text
@d1 1
a1 1
/* $OpenBSD: tmux.h,v 1.369 2012/12/24 12:33:05 nicm Exp $ */
d277 1
d1664 1
d2054 1
@


1.369
log
@Add missing function prototype.
@
text
@d1 1
a1 1
/* $OpenBSD: tmux.h,v 1.368 2012/11/27 22:59:34 nicm Exp $ */
d1098 1
a1709 1

@


1.368
log
@Fix return value of load_cfg, from Thomas Adam.
@
text
@d1 1
a1 1
/* $OpenBSD: tmux.h,v 1.367 2012/11/27 20:22:12 nicm Exp $ */
d2246 1
@


1.367
log
@Support middle-click paste, based on a diff from Ailin Nemui.
@
text
@d1 1
a1 1
/* $OpenBSD: tmux.h,v 1.366 2012/11/27 20:08:42 nicm Exp $ */
d1523 1
a1523 1
int		 load_cfg(const char *, struct cmd_ctx *, struct causelist *);
@


1.366
log
@Support the 47 and 1047 SM and RM sequences (alternate screen without
cursor), requested by I forget who ages ago.
@
text
@d1 1
a1 1
/* $OpenBSD: tmux.h,v 1.365 2012/11/27 16:12:29 nicm Exp $ */
d1685 2
a1686 2
const char	*tty_term_ptr2(
		     struct tty_term *, enum tty_code_code, const void *, const void *);
d1707 3
d1912 1
a1912 1
void	 server_check_unattached (void);
@


1.365
log
@Correctly aggregate together errors from nested config files (with
source-file). Fix by Thomas Adam, reported by Sam Livingstone-Gray
@
text
@d1 1
a1 1
/* $OpenBSD: tmux.h,v 1.364 2012/11/22 14:41:11 nicm Exp $ */
d2148 4
a2151 4
void		 window_pane_alternate_on(
		     struct window_pane *, struct grid_cell *);
void		 window_pane_alternate_off(
		     struct window_pane *, struct grid_cell *);
@


1.364
log
@Put helper function back, will be needed in a bit.
@
text
@d1 1
a1 1
/* $OpenBSD: tmux.h,v 1.363 2012/11/22 14:26:04 nicm Exp $ */
d1520 1
@


1.363
log
@Instead of worrying about xterm version, send DA and read DEC service
class which is more likely to be useful. Not used for anything yet
anyway.
@
text
@d1 1
a1 1
/* $OpenBSD: tmux.h,v 1.362 2012/11/19 10:38:06 nicm Exp $ */
d1196 1
a1196 1
	u_int		 service_class;
d1640 1
@


1.362
log
@Use a utility function for common code to show errors in config file,
from Thomas Adam.
@
text
@d1 1
a1 1
/* $OpenBSD: tmux.h,v 1.361 2012/11/05 13:13:04 nicm Exp $ */
d1196 1
a1196 1
	u_int		 xterm_version;
a1640 1
void	tty_set_version(struct tty *, u_int);
@


1.361
log
@Show last client activity time in default choose-client list.
@
text
@d1 1
a1 1
/* $OpenBSD: tmux.h,v 1.360 2012/10/26 14:35:42 nicm Exp $ */
d1523 1
@


1.360
log
@Make mouse event structure clearer by defining events (up, click, drag)
and simplifying how buttons and wheels are represented, from Ailin
Nemui. Should be no functional changes.
@
text
@d1 1
a1 1
/* $OpenBSD: tmux.h,v 1.359 2012/10/02 08:16:28 nicm Exp $ */
d103 2
a104 1
	"#{?client_utf8, (utf8),} #{?client_readonly, (ro),}"
@


1.359
log
@Allow session tree (C-b s) to expand and collapse sessions with
left/right/space keys. From Thomas Adam.
@
text
@d1 1
a1 1
/* $OpenBSD: tmux.h,v 1.358 2012/09/25 07:41:22 nicm Exp $ */
a1121 23
/*
 * Mouse input. xterm mouse mode is fairly silly. Buttons are in the bottom two
 * bits: 0 = button 1; 1 = button 2; 2 = button 3; 3 = buttons released. Bits
 * 3, 4 and 5 are for keys. Bit 6 is set for dragging and 7 for mouse buttons 4
 * and 5.
 */
struct mouse_event {
	u_int	b;
#define MOUSE_1 0
#define MOUSE_2 1
#define MOUSE_3 2
#define MOUSE_UP 3
#define MOUSE_BUTTON 3
#define MOUSE_SHIFT 4
#define MOUSE_ESCAPE 8
#define MOUSE_CTRL 16
#define MOUSE_DRAG 32
#define MOUSE_45 64
#define MOUSE_RESIZE_PANE 128 /* marker for resizing */
	u_int	x;
	u_int	y;
};

d1150 41
a1350 2
	struct mouse_event last_mouse;

d1945 2
a1946 1
void	 input_mouse(struct window_pane *, struct mouse_event *);
d2190 1
a2190 2
void		 layout_resize_pane_mouse(
		     struct client *c, struct mouse_event *mouse);
@


1.358
log
@Add notification for input from a pane, from George Nachman.
@
text
@d1 1
a1 1
/* $OpenBSD: tmux.h,v 1.357 2012/09/24 13:39:10 nicm Exp $ */
d555 5
d899 2
a900 1
	struct session		*session;
d906 3
d916 2
@


1.357
log
@Add control_write_buffer, from George Nachman.
@
text
@d1 1
a1 1
/* $OpenBSD: tmux.h,v 1.356 2012/09/24 13:05:10 nicm Exp $ */
d1534 1
d2228 2
@


1.356
log
@Use pgrp of pty fd not pid of immediate child when recovering current
working directory (like current process). From Marcel Partap.
@
text
@d1 1
a1 1
/* $OpenBSD: tmux.h,v 1.355 2012/09/03 12:20:17 nicm Exp $ */
d2224 1
@


1.355
log
@When choosing a pane found by find-window, switch to that pane rather
than just the window. Also use a helper function for the inner loop.
@
text
@d1 1
a1 1
/* $OpenBSD: tmux.h,v 1.354 2012/09/03 09:57:57 nicm Exp $ */
d2280 1
a2280 1
char   *get_proc_cwd(pid_t);
@


1.354
log
@add cmd-choose-list to allow arbitrary options to be selected. From
Thomas Adam.
@
text
@d1 1
a1 1
/* $OpenBSD: tmux.h,v 1.353 2012/09/03 09:32:38 nicm Exp $ */
d900 1
@


1.353
log
@Send notifications to control clients. Also don't redraw client when
suspended.
@
text
@d1 1
a1 1
/* $OpenBSD: tmux.h,v 1.352 2012/08/21 10:00:33 nicm Exp $ */
d1719 1
d2207 3
@


1.352
log
@Fix up window reference counting and don't crash if the rename timer
fires while the window is dead but still referenced. Fixes problem
reported by Michael Scholz.
@
text
@d1 1
a1 1
/* $OpenBSD: tmux.h,v 1.351 2012/08/14 08:51:53 nicm Exp $ */
d2218 11
@


1.351
log
@Use a separate define for each default format template and strip clutter
from the choose-tree defaults.
@
text
@d1 1
a1 1
/* $OpenBSD: tmux.h,v 1.350 2012/08/11 06:45:33 nicm Exp $ */
d2133 1
@


1.350
log
@Instead of numbering choose mode items 0-9a-z and then nothing, number
them all and if there are more than 10 use a prompt when 0-9 is
pressed. From Thomas Adam.
@
text
@d1 1
a1 1
/* $OpenBSD: tmux.h,v 1.349 2012/07/13 06:27:41 nicm Exp $ */
d95 2
a96 2
/* Default format templates. */
#define DEFAULT_BUFFER_LIST_TEMPLATE				\
d98 3
a100 1
#define DEFAULT_CLIENT_TEMPLATE					\
d104 13
a116 1
#define DEFAULT_DISPLAY_MESSAGE_TEMPLATE			\
d120 3
a122 1
#define DEFAULT_FIND_WINDOW_TEMPLATE				\
d126 13
a138 1
#define DEFAULT_SESSION_TEMPLATE \
d145 3
a147 1
#define DEFAULT_WINDOW_TEMPLATE					\
d150 13
a162 3
	"[#{window_width}x#{window_height}]"
#define DEFAULT_PANE_INFO_TEMPLATE				\
	"#{session_name}:#{window_index}.#{pane_index}"
@


1.349
log
@Add a queue of notifys and a way to turn them off and on (we do not want
notifys to happen during some commands). Based on code from George
Nachman.
@
text
@d1 1
a1 1
/* $OpenBSD: tmux.h,v 1.348 2012/07/11 07:10:15 nicm Exp $ */
d506 1
d514 1
d856 1
d863 3
a865 2
    struct window_choose_data   *wcd;
    char                        *name;
d2094 1
@


1.348
log
@Make command exec functions return an enum rather than -1/0/1 values and
add a new value to mean "leave client running but don't attach" to fix
problems with using some commands in a command sequence. Most of the
work by Thomas Adam, problem reported by "jspenguin" on SF bug 3535531.
@
text
@d1 1
a1 1
/* $OpenBSD: tmux.h,v 1.347 2012/07/10 11:53:01 nicm Exp $ */
d1487 2
d2167 2
a2168 2
void set_signals(void(*)(int, short, void *));
void clear_signals(int);
d2171 1
a2171 1
void control_callback(struct client *, int, void*);
@


1.347
log
@xfree is not particularly helpful, remove it. From Thomas Adam.
@
text
@d1 1
a1 1
/* $OpenBSD: tmux.h,v 1.346 2012/07/08 16:04:38 nicm Exp $ */
d1334 7
d1359 1
a1359 1
	int		 (*exec)(struct cmd *, struct cmd_ctx *);
d1651 1
a1651 1
int		 cmd_exec(struct cmd *, struct cmd_ctx *);
d1755 1
a1755 1
int		 cmd_list_exec(struct cmd_list *, struct cmd_ctx *);
@


1.346
log
@Add choose-tree command to show windows and sessions in the same
list. Change choose-window and -session to use the same code. From
Thomas Adam.
@
text
@d1 1
a1 1
/* $OpenBSD: tmux.h,v 1.345 2012/07/08 07:27:32 nicm Exp $ */
a2226 1
void		 xfree(void *);
@


1.345
log
@Clear flags across all sessions, from Thomas Adam.
@
text
@d1 1
a1 1
/* $OpenBSD: tmux.h,v 1.344 2012/06/25 14:27:25 nicm Exp $ */
d1667 1
@


1.344
log
@Provide common helper function for adding windows and sessions to choose
lists and expand %% in command before using it rather than at callback
time. From Thomas Adam.
@
text
@d1 1
a1 1
/* $OpenBSD: tmux.h,v 1.343 2012/06/25 14:08:55 nicm Exp $ */
d2079 1
@


1.343
log
@Clean up and simplify the choose mode code, from Thomas Adam.
@
text
@d1 1
a1 1
/* $OpenBSD: tmux.h,v 1.342 2012/06/18 13:16:42 nicm Exp $ */
d855 1
a855 2
	char			*raw_format;
	char			*action;
a2136 2
void		 window_choose_vadd(
		     struct window_pane *, int, const char *, va_list);
d2142 1
a2142 2
struct window_choose_data	*window_choose_data_create(
			struct cmd_ctx *);
d2144 6
@


1.342
log
@Add a skeleton mode to tmux (called "control mode") that let's tmux
commands be sent and output received on stdout. This can be used to
integrate with other terminal emulators and should allow some other
things to be made simpler later. More to come so doesn't do much yet and
deliberately not documented.
@
text
@d1 1
a1 1
/* $OpenBSD: tmux.h,v 1.341 2012/05/28 07:59:07 nicm Exp $ */
d849 16
d2140 2
a2141 2
void printflike3 window_choose_add(
		     struct window_pane *, int, const char *, ...);
d2143 5
a2147 1
		     u_int, void (*)(void *, int), void (*)(void *), void *);
@


1.341
log
@Strip layout from choose-windows again (leave in list-windows),
suggested by Romain Francoise, diff from Thomas Adam.
@
text
@d1 1
a1 1
/* $OpenBSD: tmux.h,v 1.340 2012/05/27 21:43:57 nicm Exp $ */
d436 2
d1237 1
d2136 3
@


1.340
log
@Fix client templates, from Romain Francoise.
@
text
@d1 1
a1 1
/* $OpenBSD: tmux.h,v 1.339 2012/05/25 08:28:10 nicm Exp $ */
d120 1
a120 3
	"[#{window_width}x#{window_height}] "			\
	"[layout #{window_layout}] #{window_id}"		\
	"#{?window_active, (active),}"
@


1.339
log
@Simplify logging and just fprintf(stderr, ...) for early errors.
@
text
@d1 1
a1 1
/* $OpenBSD: tmux.h,v 1.338 2012/05/23 19:19:40 nicm Exp $ */
d100 2
a101 2
	"[#client_width}x#{client_height} #{client_termname}]"	\
	"{?client_utf8, (utf8),} #{?client_readonly, (ro),}"
@


1.338
log
@Use a predefined structure for not-space cells used to set attributes.
@
text
@d1 1
a1 1
/* $OpenBSD: tmux.h,v 1.337 2012/05/22 14:32:28 nicm Exp $ */
d2184 1
a2184 2
void		 log_open_tty(int);
void		 log_open_file(int, const char *);
@


1.337
log
@Store client in tty struct directly instead of using a callback function
pointer.
@
text
@d1 1
a1 1
/* $OpenBSD: tmux.h,v 1.336 2012/05/22 14:11:30 nicm Exp $ */
d1865 1
@


1.336
log
@Store mouse data in tty structure not on the stack.
@
text
@d1 1
a1 1
/* $OpenBSD: tmux.h,v 1.335 2012/05/22 11:35:37 nicm Exp $ */
d1103 2
d1143 2
a1144 3
	struct mouse_event mouse_event;
	void		 (*key_callback)(int, struct mouse_event *, void *);
	void		*key_data;
d1537 1
a1537 1
void	tty_init(struct tty *, int, char *);
d1768 1
@


1.335
log
@Switch all of the various choose- and list- commands over to the format
infrastructure, from Thomas Adam.
@
text
@d1 1
a1 1
/* $OpenBSD: tmux.h,v 1.334 2012/05/22 10:56:48 nicm Exp $ */
d1051 23
d1141 1
a1177 23
/*
 * Mouse input. xterm mouse mode is fairly silly. Buttons are in the bottom two
 * bits: 0 = button 1; 1 = button 2; 2 = button 3; 3 = buttons released. Bits
 * 3, 4 and 5 are for keys. Bit 6 is set for dragging and 7 for mouse buttons 4
 * and 5.
 */
struct mouse_event {
	u_int	b;
#define MOUSE_1 0
#define MOUSE_2 1
#define MOUSE_3 2
#define MOUSE_UP 3
#define MOUSE_BUTTON 3
#define MOUSE_SHIFT 4
#define MOUSE_ESCAPE 8
#define MOUSE_CTRL 16
#define MOUSE_DRAG 32
#define MOUSE_45 64
#define MOUSE_RESIZE_PANE 128 /* marker for resizing */
	u_int	x;
	u_int	y;
};

d1228 1
a1228 1
#define CLIENT_REPEAT 0x20	/* allow command to repeat within repeat time */
@


1.334
log
@Add a helper function to send ready message.
@
text
@d1 1
a1 1
/* $OpenBSD: tmux.h,v 1.333 2012/05/22 09:36:12 nicm Exp $ */
d95 31
d1440 1
@


1.333
log
@If there are any terminals with insert mode but not ich1, they can go
through the slow path. Tidies code slightly.
@
text
@d1 1
a1 1
/* $OpenBSD: tmux.h,v 1.332 2012/05/21 18:27:42 nicm Exp $ */
d1746 1
@


1.332
log
@Instead of passing stdin/stdout/stderr file descriptors over imsg and
handling them in the server, handle them in the client and pass buffers
over imsg. This is much tidier for some upcoming changes and the
performance hit isn't critical.

The tty fd is still passed to the server as before.

This bumps the tmux protocol version so new clients and old servers are
incompatible.
@
text
@d1 1
a1 1
/* $OpenBSD: tmux.h,v 1.331 2012/05/06 07:38:17 nicm Exp $ */
a318 1
	TTYC_RMIR,	/* exit_insert_mode, ei */
a325 1
	TTYC_SMIR,	/* enter_insert_mode, im */
@


1.331
log
@Add a helper function to open the terminal for attach-/new-session.
@
text
@d1 1
a1 1
/* $OpenBSD: tmux.h,v 1.330 2012/04/29 17:20:01 nicm Exp $ */
d22 1
a22 1
#define PROTOCOL_VERSION 6
d372 1
a372 1
	MSG_PRINT,
d428 15
d1179 6
a1184 10
	int		 stdin_fd;
	void		*stdin_data;
	void		(*stdin_callback)(struct client *, void *);
	struct bufferevent *stdin_event;

	int		 stdout_fd;
	struct bufferevent *stdout_event;

	int		 stderr_fd;
	struct bufferevent *stderr_event;
d1748 1
a1748 1
void	 server_write_client(
d1776 4
@


1.330
log
@Add a flag to move-window to renumber the windows in a session (closing
any gaps) and add an option to do this automatically each time a window
is killed. From Thomas Adam.
@
text
@d1 1
a1 1
/* $OpenBSD: tmux.h,v 1.329 2012/04/25 21:12:49 nicm Exp $ */
d1726 1
@


1.329
log
@Add a buffer with all input from last ground state, will be used for
control mode. From George Nachman.
@
text
@d1 1
a1 1
/* $OpenBSD: tmux.h,v 1.328 2012/04/11 06:16:14 nicm Exp $ */
d2119 1
@


1.328
log
@Stop accepting new clients for 1 second on EMFILE/ENFILE. Based on
ongoing fixes to other daemons by Theo.
@
text
@d1 1
a1 1
/* $OpenBSD: tmux.h,v 1.327 2012/04/01 21:45:48 nicm Exp $ */
d780 6
@


1.327
log
@Fix comment for mouse bits.
@
text
@d1 1
a1 1
/* $OpenBSD: tmux.h,v 1.326 2012/04/01 13:18:38 nicm Exp $ */
d1716 1
@


1.326
log
@Add a layout history which can be stepped through with select-layout -u
and -U commands (bound to 'u' and 'U' by default).
@
text
@d1 1
a1 1
/* $OpenBSD: tmux.h,v 1.325 2012/03/20 11:01:00 nicm Exp $ */
d1105 4
a1108 6
 * xterm mouse mode is fairly silly. Buttons are in the bottom two
 * bits: 0 button 1; 1 button 2; 2 button 3; 3 buttons released.
 *
 * Bit 3 is shift; bit 4 is meta; bit 5 control.
 *
 * Bit 6 is added for mouse buttons 4 and 5.
a1109 1
/* Mouse input. */
d1117 3
@


1.325
log
@Add a simple form of output rate limiting by counting the number of
certain C0 sequences (linefeeds, backspaces, carriage returns) and if it
exceeds a threshold (current default 50/millisecond), start to redraw
the pane every 100 milliseconds instead of making each change as it
comes. Two configuration options - c0-change-trigger and
c0-change-interval.

This makes tmux much more responsive under very fast output (for example
yes(1) or accidentally cat'ing a large file) but may not be perfect on
all terminals and connections - feedback very welcome, particularly
where this change has a negative rather than positive effect (making it
off by default is a possibility).

After much experimentation based originally on a request Robin Lee
Powell (which ended with a completely different solution), this idea
from discussion with Ailin Nemui.
@
text
@d1 1
a1 1
/* $OpenBSD: tmux.h,v 1.324 2012/03/17 22:56:04 nicm Exp $ */
d854 7
d874 3
d2011 2
a2012 1
void		 layout_destroy_cell(struct layout_cell *, struct layout_cell **);
d2034 3
@


1.324
log
@On xterm 271 and later, put the terminal into SCL 5 and use DECCRA for
scrolling the region in panes (if the large region check isn't
hit). With help from Ailin Nemui.
@
text
@d1 1
a1 1
/* $OpenBSD: tmux.h,v 1.323 2012/03/17 22:35:09 nicm Exp $ */
d814 1
d823 4
d1971 1
a1989 1

@


1.323
log
@Add notify hooks for various events, the functions are currently empty
stubs but will be filled in for control mode later. From George Nachman.
@
text
@d1 1
a1 1
/* $OpenBSD: tmux.h,v 1.322 2012/03/17 21:27:51 nicm Exp $ */
d1475 1
a1475 1
int	tty_set_size(struct tty *tty, u_int sx, u_int sy);
d1477 1
@


1.322
log
@Break out termios initialization into a separate function, from George
Nachman.
@
text
@d1 1
a1 1
/* $OpenBSD: tmux.h,v 1.321 2012/03/15 10:36:00 nicm Exp $ */
d1398 10
@


1.321
log
@Send secondary DA to terminals with XT in terminfo when starting up and
parse it to work out the xterm version.
@
text
@d1 1
a1 1
/* $OpenBSD: tmux.h,v 1.320 2012/03/09 21:42:13 nicm Exp $ */
d1447 1
@


1.320
log
@Remove some bits leftover from unused backoff code.
@
text
@d1 1
a1 1
/* $OpenBSD: tmux.h,v 1.319 2012/03/09 09:57:40 nicm Exp $ */
d1016 1
@


1.319
log
@Use a lock file and flock() to serialize server start, avoids problems
when running a bunch of tmux from cron at the same time. Based on a diff
from Tim Ruehsen.
@
text
@d1 1
a1 1
/* $OpenBSD: tmux.h,v 1.318 2012/03/04 07:38:11 nicm Exp $ */
a61 3
/* Maximum data to buffer for output before suspending writing to a tty. */
#define BACKOFF_THRESHOLD 16384

a1047 1
#define TTY_BACKOFF 0x40
@


1.318
log
@Add A and I keys for vi status line editing.
@
text
@d1 1
a1 1
/* $OpenBSD: tmux.h,v 1.317 2012/03/03 09:43:23 nicm Exp $ */
d1690 1
a1690 1
int	 server_start(void);
@


1.317
log
@Support "bracketed paste" mode. This adds a -p flag to paste-buffer - if
this is used and the application has requested bracketed pastes, then
tmux surrounds the pasted text by \033[200~ and \033[201~. Applications
like vim can (apparently) use this to avoid, for example, indenting the
text. From Ailin Nemui.
@
text
@d1 1
a1 1
/* $OpenBSD: tmux.h,v 1.316 2012/03/03 08:55:56 nicm Exp $ */
d460 2
@


1.316
log
@The wlmouse offset should be part of the client, not the server. From
Ailin Nemui.
@
text
@d1 1
a1 1
/* $OpenBSD: tmux.h,v 1.315 2012/03/03 08:31:18 nicm Exp $ */
d576 1
d1887 1
@


1.315
log
@Add move-pane command (like join-pane but allows the same window). Also
-b flag to join-pane and move-pane to place the pane to the left or
above. From George Nachman.
@
text
@d1 1
a1 1
/* $OpenBSD: tmux.h,v 1.314 2012/03/02 11:16:44 nicm Exp $ */
a977 2
	int		 wlmouse;

d1199 2
@


1.314
log
@Add printf attribute to a couple of functions, from Tim Ruehsen.
@
text
@d1 1
a1 1
/* $OpenBSD: tmux.h,v 1.313 2012/02/25 12:57:42 nicm Exp $ */
d1608 1
d2003 1
a2003 1
		     struct window_pane *, enum layout_type, int);
@


1.313
log
@Allow a single option to be specified to show-options to show just that
option.
@
text
@d1 1
a1 1
/* $OpenBSD: tmux.h,v 1.312 2012/02/15 17:25:02 nicm Exp $ */
d1370 1
a1370 1
void		 format_add(
d2024 1
a2024 1
void		 window_copy_add(struct window_pane *, const char *, ...);
@


1.312
log
@Add a wrapper function tty_set_size from George Nachman.
@
text
@d1 1
a1 1
/* $OpenBSD: tmux.h,v 1.311 2012/02/02 00:10:12 nicm Exp $ */
d1422 3
@


1.311
log
@Move window name changes into wrapper function window_set_name, from
George Nachman.
@
text
@d1 1
a1 1
/* $OpenBSD: tmux.h,v 1.310 2012/01/31 15:52:21 nicm Exp $ */
d1461 1
@


1.310
log
@Provide defined ways to set the various default-path possibilities: ~
for home directory, . for server start directory, - for session start
directory and empty for the pane's working directory (the default). All
can also be used as part of a relative path (eg -/foo). Also provide -c
flags to neww and splitw to override default-path setting.

Based on a diff from sthen. ok sthen
@
text
@d1 1
a1 1
/* $OpenBSD: tmux.h,v 1.309 2012/01/30 09:39:34 nicm Exp $ */
d1971 1
@


1.309
log
@Give each window a unique id, like panes but prefixed with @@. Based on
work from George Nachman.
@
text
@d1 1
a1 1
/* $OpenBSD: tmux.h,v 1.308 2012/01/29 09:37:02 nicm Exp $ */
d1562 1
a1562 1
const char     	*cmd_get_default_path(struct cmd_ctx *ctx);
@


1.308
log
@Add an option to move the status line to the top of the screen,
requested by many.
@
text
@d1 1
a1 1
/* $OpenBSD: tmux.h,v 1.307 2012/01/21 23:51:34 nicm Exp $ */
d851 1
d1909 1
d1924 1
@


1.307
log
@Remove unused backoff code that doesn't do any good.
@
text
@d1 1
a1 1
/* $OpenBSD: tmux.h,v 1.306 2012/01/21 11:12:13 nicm Exp $ */
d1081 3
d1469 2
a1470 2
void	tty_write(void (*)(
	    struct tty *, const struct tty_ctx *), const struct tty_ctx *);
d1728 1
@


1.306
log
@Use RB trees not SPLAY.
@
text
@d1 1
a1 1
/* $OpenBSD: tmux.h,v 1.305 2012/01/21 08:40:09 nicm Exp $ */
d1171 1
a1171 2
#define CLIENT_BACKOFF 0x1000
#define CLIENT_REDRAWWINDOW 0x2000
@


1.305
log
@Drop the ability to have a list of keys in the prefix in favour of two
separate options, prefix and prefix2. This simplifies the code and gets
rid the data options type which was only used for this one option.

Also add a -2 flag to send-prefix to send the secondary prefix key,
fixing a cause of minor irritation.

People who want three prefix keys are out of luck :-).
@
text
@d1 1
a1 1
/* $OpenBSD: tmux.h,v 1.304 2012/01/21 08:10:21 nicm Exp $ */
d548 1
a548 1
	SPLAY_ENTRY(mode_key_binding) entry;
d550 1
a550 1
SPLAY_HEAD(mode_key_tree, mode_key_binding);
d677 1
a677 1
	SPLAY_ENTRY(options_entry) entry;
d681 1
a681 1
	SPLAY_HEAD(options_tree, options_entry) tree;
d1279 1
a1279 1
	SPLAY_ENTRY(key_binding) entry;
d1281 1
a1281 1
SPLAY_HEAD(key_bindings, key_binding);
d1386 1
a1386 1
SPLAY_PROTOTYPE(mode_key_tree, mode_key_binding, entry, mode_key_cmp);
d1398 1
a1398 1
SPLAY_PROTOTYPE(options_tree, options_entry, entry, options_cmp);
d1660 1
a1660 1
SPLAY_PROTOTYPE(key_bindings, key_binding, entry, key_bindings_cmp);
@


1.304
log
@Add a -R flag to send-keys to reset the terminal. Written ages ago and
Suggested by someone, I forget who.
@
text
@d1 1
a1 1
/* $OpenBSD: tmux.h,v 1.303 2012/01/20 19:54:07 nicm Exp $ */
a675 3
	void		*data;

	void		 (*freefn)(void *);
a684 3
/* Key list for prefix option. */
ARRAY_DECL(keylist, int);

d1291 1
a1291 1
	OPTIONS_TABLE_KEYS,
a1409 3
struct options_entry *options_set_data(
	    struct options *, const char *, void *, void (*)(void *));
void   *options_get_data(struct options *, const char *);
@


1.303
log
@Add some const and fix a warning.
@
text
@d1 1
a1 1
/* $OpenBSD: tmux.h,v 1.302 2012/01/20 19:10:29 nicm Exp $ */
d1835 1
@


1.302
log
@Add space movement keys for vi mode in the status line from Ben Boeckel.
@
text
@d1 1
a1 1
/* $OpenBSD: tmux.h,v 1.301 2011/12/09 16:28:18 nicm Exp $ */
d1568 1
a1568 1
char		*cmd_get_default_path(struct cmd_ctx *ctx);
@


1.301
log
@Change the way the working directory for new processes is discovered. If
default-path isn't empty, it is used. Otherwise:

1) If tmux neww is run from the command line, the working directory of the
   client is used.

2) Otherwise sysctl KERN_PROC_CWD is used to retrieve the current
   working directory of the process in the active pane.

3) If that fails, the directory where the session was created is used.

Support code by Romain Francois, OpenBSD specific bits by me.

Note this requires a recent userland and kernel with KERN_PROC_CWD.
@
text
@d1 1
a1 1
/* $OpenBSD: tmux.h,v 1.300 2011/12/04 16:18:01 nicm Exp $ */
d450 2
d455 1
@


1.300
log
@Support "jump to" like vi in copy mode using t and T keys. Also add x
and X for delete in edit mode.

From Ben Boeckel, thanks.
@
text
@d1 1
a1 1
/* $OpenBSD: tmux.h,v 1.299 2011/11/15 23:34:12 nicm Exp $ */
d1565 1
d2083 1
@


1.299
log
@Add word movement and editing command for command prompt editing, from
Ben Boeckel.
@
text
@d1 1
a1 1
/* $OpenBSD: tmux.h,v 1.298 2011/11/15 23:19:51 nicm Exp $ */
d488 2
@


1.298
log
@Make window_pane_index work the same as window_index, from Ben Boeckel.
@
text
@d1 1
a1 1
/* $OpenBSD: tmux.h,v 1.297 2011/10/23 10:16:14 nicm Exp $ */
d445 1
d450 2
d453 1
@


1.297
log
@Support for \e[3J to clear the history. Also send the corresponding
terminfo code (E3) before locking.
@
text
@d1 1
a1 1
/* $OpenBSD: tmux.h,v 1.296 2011/10/23 08:34:01 nicm Exp $ */
d1934 1
a1934 1
u_int		 window_pane_index(struct window *, struct window_pane *);
@


1.296
log
@Try to resolve relative paths for loadb and saveb (first using client
working directory if any then default-path or session wd).
@
text
@d1 1
a1 1
/* $OpenBSD: tmux.h,v 1.295 2011/10/23 01:12:46 nicm Exp $ */
d209 1
d1870 1
@


1.295
log
@Add client formats, from Ben Boeckel.
@
text
@d1 1
a1 1
/* $OpenBSD: tmux.h,v 1.294 2011/08/26 10:53:16 nicm Exp $ */
d1348 1
@


1.294
log
@Add initial framework for more powerful formatting of command output and
use it for list-{panes,windows,sessions}. This allows more descriptive
replacements (such as #{session_name}) and conditionals.

Later this will be used for status_replace and list-keys and other
places.
@
text
@d1 1
a1 1
/* $OpenBSD: tmux.h,v 1.293 2011/08/24 09:58:44 nicm Exp $ */
d1367 1
@


1.293
log
@Add a tty_bell wrapper function, from Dylan Alex Simon.
@
text
@d1 1
a1 1
/* $OpenBSD: tmux.h,v 1.292 2011/07/02 21:05:44 nicm Exp $ */
d1306 9
d1356 14
@


1.292
log
@Allow the initial context on prompts to be set with the new -I option to
command-prompt. From Tiago Cunha.
@
text
@d1 1
a1 1
/* $OpenBSD: tmux.h,v 1.291 2011/06/27 00:04:49 nicm Exp $ */
d1461 1
@


1.291
log
@PANE_FREEZE doesn't do anything anymore, so remove it.
@
text
@d1 1
a1 1
/* $OpenBSD: tmux.h,v 1.290 2011/06/05 11:19:03 nicm Exp $ */
d1707 1
a1707 1
void	 status_prompt_set(struct client *, const char *,
d1712 1
a1712 1
void	 status_prompt_update(struct client *, const char *);
@


1.290
log
@Add a respawn-pane command, from Marcel Partap.
@
text
@d1 1
a1 1
/* $OpenBSD: tmux.h,v 1.289 2011/06/05 10:53:05 nicm Exp $ */
a809 1
#define PANE_FREEZE 0x2
@


1.289
log
@Get rid of the layout string code which tries to walk through the layout
hierarchy and instead just look at what panes are actually in the window.
@
text
@d1 1
a1 1
/* $OpenBSD: tmux.h,v 1.288 2011/05/20 19:17:39 nicm Exp $ */
d1587 1
@


1.288
log
@Support DECSCUSR sequence to set the cursor style with two new
terminfo(5) extensions, Cs and Csr. Written by Ailin Nemui.
@
text
@d1 1
a1 1
/* $OpenBSD: tmux.h,v 1.287 2011/05/20 19:03:58 nicm Exp $ */
d1894 1
d1896 1
a1974 4

/* layout-string.c */
struct layout_cell *layout_find_string(struct window *, const char *);
struct layout_cell *layout_find_bottomright(struct layout_cell *);
@


1.287
log
@Support xterm(1) cursor colour change sequences through terminfo(5) Cc
(set) and Cr (reset) extensions. Originally by Sean Estabrooks, tweaked
by me and Ailin Nemui.
@
text
@d1 1
a1 1
/* $OpenBSD: tmux.h,v 1.286 2011/05/18 20:24:29 nicm Exp $ */
d192 1
d194 1
d721 1
d1020 1
d1857 1
@


1.286
log
@Support setting the xterm clipboard when copying from copy mode using
the xterm escape sequence for the purpose (if xterm is configured to
allow it).

Written by and much discussed Ailin Nemui, guidance on
xterm/termcap/terminfo from Thomas Dickey.
@
text
@d1 1
a1 1
/* $OpenBSD: tmux.h,v 1.285 2011/05/18 18:06:36 nicm Exp $ */
d186 1
d191 1
d719 2
d1017 1
d1422 1
d1432 2
a1433 1
void	tty_update_mode(struct tty *, int);
d1469 2
d1853 1
@


1.285
log
@Add three new copy-mode commands - select-line, copy-line,
copy-end-of-line. From Dave Disser and Randy Stauner a while back.
@
text
@d1 1
a1 1
/* $OpenBSD: tmux.h,v 1.284 2011/05/08 20:34:12 nicm Exp $ */
d311 1
d1417 1
d1449 1
d1462 2
d1832 1
@


1.284
log
@Add a new option, mouse-resize-pane. When on, panes may be resized by
dragging their borders. From hsim at gmx.li.
@
text
@d1 1
a1 1
/* $OpenBSD: tmux.h,v 1.283 2011/05/08 19:53:07 nicm Exp $ */
d464 2
d496 1
@


1.283
log
@Use the tsl and fsl terminfo(5) capabilities to update terminal title
and automatically fill them in on terminals with the XT capability
(which means their title setting is xterm-compatible). From hsim at
gmx.li.
@
text
@d1 1
a1 1
/* $OpenBSD: tmux.h,v 1.282 2011/04/19 21:31:33 nicm Exp $ */
d1089 1
d1181 2
d1931 2
@


1.282
log
@When mode-mouse is on (it is off by default), automatically enter copy
mode when the mouse is dragged or the mouse wheel is used. Also exit
copy mode when the mouse wheel is scrolled off the bottom. Discussed
with and written by hsim at gmx dot li.
@
text
@d1 1
a1 1
/* $OpenBSD: tmux.h,v 1.281 2011/04/18 19:49:05 nicm Exp $ */
d208 1
d321 1
d328 1
a328 1
	TTYC_SITM,	/* enter_italics_mode, it */
d331 1
d333 1
a333 1
#define NTTYCODE (TTYC_XENL + 1)
@


1.281
log
@Add an option (mouse-select-window) which allows the mouse to be used by
clicking on the status line, written by hsim at gmx dot li.
@
text
@d1 1
a1 1
/* $OpenBSD: tmux.h,v 1.280 2011/04/09 07:48:08 nicm Exp $ */
d1084 1
d1432 1
@


1.280
log
@If the terminal supports sitm for italics, use it instead of standout
(smso). From Tiago Resende.
@
text
@d1 1
a1 1
/* $OpenBSD: tmux.h,v 1.279 2011/04/06 21:51:31 nicm Exp $ */
d960 2
d1671 1
@


1.279
log
@Change so that an empty session name always means the current sessions
even if given with, for example, -t '', and explicitly forbid empty
session names and those containing a : when they are created.
@
text
@d1 1
a1 1
/* $OpenBSD: tmux.h,v 1.278 2011/04/05 19:37:01 nicm Exp $ */
d326 1
@


1.278
log
@Add a flag to cmd_find_session so that attach-session can prefer
unattached sessions when choosing the most recently used (if -t is not
given). Suggested by claudio@@.
@
text
@d1 1
a1 1
/* $OpenBSD: tmux.h,v 1.277 2011/03/29 19:30:16 nicm Exp $ */
d1981 1
@


1.277
log
@Change -t on display-message to be target-pane for the #[A-Z]
replacements and add -c as target-client.
@
text
@d1 1
a1 1
/* $OpenBSD: tmux.h,v 1.276 2011/03/28 19:44:31 nicm Exp $ */
d1490 1
a1490 1
struct session	*cmd_current_session(struct cmd_ctx *);
d1493 1
a1493 1
struct session	*cmd_find_session(struct cmd_ctx *, const char *);
@


1.276
log
@Style: uint -> u_int and a missing else.
@
text
@d1 1
a1 1
/* $OpenBSD: tmux.h,v 1.275 2011/03/27 20:31:25 nicm Exp $ */
d1669 2
a1670 2
char	*status_replace(
	     struct client *, struct winlink *, const char *, time_t, int);
@


1.275
log
@Don't include meta twice when working out the flags to output for
xterm-style keys - bit 3 is accepted on input but not on output. Also a
style nit in the header.
@
text
@d1 1
a1 1
/* $OpenBSD: tmux.h,v 1.274 2011/03/27 20:27:27 nicm Exp $ */
d1457 1
a1457 1
struct paste_buffer *paste_walk_stack(struct paste_stack *, uint *);
@


1.274
log
@Give each pane created in a tmux server a unique id (starting from 0),
put it in the TMUX_PANE environment variable and accept it as a
target. Suggested by and with testing and tweaks from Ben Boeckel.
@
text
@d1 1
a1 1
/* $OpenBSD: tmux.h,v 1.273 2011/03/07 23:46:27 nicm Exp $ */
d113 1
a113 1
/* Mask to obtain key w/o modifiers */
@


1.273
log
@Support passing through escape sequences to the underlying terminal by
using DCS with a "tmux;" prefix. Escape characters in the sequences must
be doubled. For example:

$ printf '\033Ptmux;\033\033]12;red\007\033\\'

Will pass \033]12;red\007 to the terminal (and change the cursor colour
in xterm). From Kevin Goodsell.
@
text
@d1 1
a1 1
/* $OpenBSD: tmux.h,v 1.272 2011/03/03 08:51:47 nicm Exp $ */
d782 2
d826 1
d829 1
d1832 1
d1835 2
d1871 1
@


1.272
log
@Add a -P option to detach to HUP the client's parent process (usually
causing it to exit as well).
@
text
@d1 1
a1 1
/* $OpenBSD: tmux.h,v 1.271 2011/01/26 01:54:56 nicm Exp $ */
d1429 1
d1808 1
@


1.271
log
@Simplify the way jobs work and drop the persist type, so all jobs are
fire-and-forget.

Status jobs now managed with two trees of output (new and old), rather
than storing the output in the jobs themselves. When the status line is
processed any jobs which don't appear in the new tree are started and
the output from the old tree displayed. When a job finishes it updates
the new tree with its output and that is used for any subsequent
redraws. When the status interval expires, the new tree is moved to the
old so that all jobs are run again.

This fixes the "#(echo %H:%M:%S)" problem which would lead to thousands
of identical persistent jobs and high memory use (this can still be
achieved by adding "sleep 30" but that is much less likely to happen by
accident).
@
text
@d1 1
a1 1
/* $OpenBSD: tmux.h,v 1.270 2011/01/26 00:11:47 nicm Exp $ */
d378 1
@


1.270
log
@Use LIST_* not SLIST_*.
@
text
@d1 1
a1 1
/* $OpenBSD: tmux.h,v 1.269 2011/01/25 23:40:26 nicm Exp $ */
a673 2
	struct client	*client;

a680 4
	int		 flags;
#define JOB_PERSIST 0x1	/* don't free after callback */

	RB_ENTRY(job)	 entry;
a682 1
RB_HEAD(jobs, job);
d1087 9
d1125 2
a1127 1
	struct jobs	 status_jobs;
d1369 1
a1369 6
int	job_cmp(struct job *, struct job *);
RB_PROTOTYPE(jobs, job, entry, job_cmp);
void	job_tree_init(struct jobs *);
void	job_tree_free(struct jobs *);
struct job *job_get(struct jobs *, const char *);
struct job *job_add(struct jobs *, int, struct client *,
a1370 1
void	job_remove(struct jobs *, struct job *);
a1371 1
int	job_run(struct job *);
a1372 1
void	job_kill(struct job *);
d1658 4
@


1.269
log
@When clearing the entire screen, clear lines that are used into the
history like xterm does. Requested ages ago by someone I've forgotten.
@
text
@d1 1
a1 1
/* $OpenBSD: tmux.h,v 1.268 2011/01/25 22:31:50 nicm Exp $ */
d687 1
a687 1
	SLIST_ENTRY(job) lentry;
d690 1
a690 1
SLIST_HEAD(joblist, job);
d993 1
a993 1
	SLIST_ENTRY(tty_term) entry;
d995 1
a995 1
SLIST_HEAD(tty_terms, tty_term);
@


1.268
log
@Check if the index is in use and fail before creating the child process,
rather than leaving a stray child on failure.
@
text
@d1 1
a1 1
/* $OpenBSD: tmux.h,v 1.267 2011/01/23 11:03:43 nicm Exp $ */
d1744 1
@


1.267
log
@Set $TMUX without the session when background jobs are run.
@
text
@d1 1
a1 1
/* $OpenBSD: tmux.h,v 1.266 2011/01/15 00:16:00 nicm Exp $ */
d1831 2
a1832 1
struct winlink	*winlink_add(struct winlinks *, struct window *, int);
@


1.266
log
@Mouse highlight mode (1001) requires a program to cooperate so
supporting it through tmux is not as easy as this, remove it for now.
@
text
@d1 1
a1 1
/* $OpenBSD: tmux.h,v 1.265 2011/01/08 01:52:37 nicm Exp $ */
d386 2
a387 2
	pid_t		pid;			/* pid from $TMUX or -1 */
	u_int		idx;			/* index from $TMUX */
d1304 1
a1304 1
extern u_int	 environ_idx;
@


1.265
log
@Move all calls to fcntl(...O_NONBLOCK) into a function and clear the
flag on the stdio file descriptors before closing them (fixes things
like "tmux ls && cat").
@
text
@d1 1
a1 1
/* $OpenBSD: tmux.h,v 1.264 2011/01/04 00:42:47 nicm Exp $ */
d550 3
a552 4
#define MODE_MOUSE_HIGHLIGHT 0x40
#define MODE_MOUSE_BUTTON 0x80
#define MODE_MOUSE_ANY 0x100
#define MODE_MOUSE_UTF8 0x200
d554 1
a554 2
#define ALL_MOUSE_MODES (MODE_MOUSE_STANDARD| \
    MODE_MOUSE_HIGHLIGHT|MODE_MOUSE_BUTTON|MODE_MOUSE_ANY)
@


1.264
log
@Clean up and simplify tmux command argument parsing.

Originally, tmux commands were parsed in the client process into a
struct with the command data which was then serialised and sent to the
server to be executed. The parsing was later moved into the server (an
argv was sent from the client), but the parse step and intermediate
struct was kept.

This change removes that struct and the separate parse step. Argument
parsing and printing is now common to all commands (in arguments.c) with
each command left with just an optional check function (to validate the
arguments at parse time), the exec function and a function to set up any
key bindings (renamed from the old init function).

This is overall more simple and consistent.

There should be no changes to any commands behaviour or syntax although
as this touches every command please watch for any unexpected changes.
@
text
@d1 1
a1 1
/* $OpenBSD: tmux.h,v 1.263 2011/01/03 23:35:21 nicm Exp $ */
d1311 1
@


1.263
log
@Support for UTF-8 mouse input (\033[1005h). This was added in xterm 262
and supports larger terminals than the older way.

If the new mouse-utf8 option is on, UTF-8 mouse input is enabled for all
UTF-8 terminals. The option defaults to on if LANG etc are set in the
same manner as the utf8 option.

With help and based on code from hsim at gmx.li.
@
text
@d1 1
a1 1
/* $OpenBSD: tmux.h,v 1.262 2011/01/01 16:51:21 nicm Exp $ */
d1171 9
d1210 2
a1211 2
	const struct cmd_entry *entry;
	void		*data;
d1213 1
a1213 1
	TAILQ_ENTRY(cmd) qentry;
d1216 2
a1217 2
	int		 references;
	TAILQ_HEAD(, cmd) list;
d1223 5
d1233 1
a1233 5
#define CMD_ARG1 0x8
#define CMD_ARG01 0x10
#define CMD_ARG2 0x20
#define CMD_ARG12 0x40
#define CMD_READONLY 0x80
d1236 2
a1237 4
	const char	*chflags;

	void		 (*init)(struct cmd *, int);
	int		 (*parse)(struct cmd *, int, char **, char **);
a1238 31
	void		 (*free)(struct cmd *);
	size_t		 (*print)(struct cmd *, char *, size_t);
};

/* Generic command data. */
struct cmd_target_data {
	uint64_t chflags;

	char	*target;

	char	*arg;
	char	*arg2;
};

struct cmd_srcdst_data {
	uint64_t chflags;

	char	*src;
	char	*dst;

	char	*arg;
	char	*arg2;
};

struct cmd_buffer_data {
	uint64_t chflags;

	int	 buffer;

	char	*arg;
	char	*arg2;
d1281 11
d1470 11
d1484 1
a1484 1
char	       **cmd_copy_argv(int, char **);
a1592 26

/* cmd-generic.c */
size_t	cmd_prarg(char *, size_t, const char *, char *);
int	cmd_check_flag(uint64_t, int);
void	cmd_set_flag(uint64_t *, int);
#define CMD_TARGET_PANE_USAGE "[-t target-pane]"
#define CMD_TARGET_WINDOW_USAGE "[-t target-window]"
#define CMD_TARGET_SESSION_USAGE "[-t target-session]"
#define CMD_TARGET_CLIENT_USAGE "[-t target-client]"
void	cmd_target_init(struct cmd *, int);
int	cmd_target_parse(struct cmd *, int, char **, char **);
void	cmd_target_free(struct cmd *);
size_t	cmd_target_print(struct cmd *, char *, size_t);
#define CMD_SRCDST_PANE_USAGE "[-s src-pane] [-t dst-pane]"
#define CMD_SRCDST_WINDOW_USAGE "[-s src-window] [-t dst-window]"
#define CMD_SRCDST_SESSION_USAGE "[-s src-session] [-t dst-session]"
#define CMD_SRCDST_CLIENT_USAGE "[-s src-client] [-t dst-client]"
void	cmd_srcdst_init(struct cmd *, int);
int	cmd_srcdst_parse(struct cmd *, int, char **, char **);
void	cmd_srcdst_free(struct cmd *);
size_t	cmd_srcdst_print(struct cmd *, char *, size_t);
#define CMD_BUFFER_USAGE "[-b buffer-index]"
void	cmd_buffer_init(struct cmd *, int);
int	cmd_buffer_parse(struct cmd *, int, char **, char **);
void	cmd_buffer_free(struct cmd *);
size_t	cmd_buffer_print(struct cmd *, char *, size_t);
@


1.262
log
@Move the user-visible parts of all options (names, types, limit, default
values) together into one set of tables in options-table.c. Also clean
up and simplify cmd-set-options.c and move a common print function into
option-table.c.
@
text
@d1 1
a1 1
/* $OpenBSD: tmux.h,v 1.261 2011/01/01 03:39:21 nicm Exp $ */
d553 1
d1079 1
a1079 1
	u_char	b;
d1086 2
a1087 2
	u_char	x;
	u_char	y;
d1821 1
d2022 2
@


1.261
log
@Sprinkle a little more const.
@
text
@d1 1
a1 1
/* $OpenBSD: tmux.h,v 1.260 2011/01/01 03:32:28 nicm Exp $ */
d1273 18
a1290 12
/* Set/display option data. */
struct set_option_entry {
	const char	*name;
	enum {
		SET_OPTION_STRING,
		SET_OPTION_NUMBER,
		SET_OPTION_KEYS,
		SET_OPTION_COLOUR,
		SET_OPTION_ATTRIBUTES,
		SET_OPTION_FLAG,
		SET_OPTION_CHOICE
	} type;
d1292 3
a1294 2
	u_int		 minimum;
	u_int		 maximum;
d1296 2
a1297 1
	const char     **choices;
d1367 9
a1479 7

/* cmd-set-option.c */
extern const struct set_option_entry set_option_table[];
extern const struct set_option_entry set_session_option_table[];
extern const struct set_option_entry set_window_option_table[];
const char	*cmd_set_option_print(
		    const struct set_option_entry *, struct options_entry *);
@


1.260
log
@Another table that should be const.
@
text
@d1 1
a1 1
/* $OpenBSD: tmux.h,v 1.259 2011/01/01 01:12:09 nicm Exp $ */
d537 4
a540 4
	const char		*name;
	struct mode_key_cmdstr	*cmdstr;
	struct mode_key_tree	*tree;
	const struct mode_key_entry *table;	/* default entries */
d1332 4
a1335 2
const char *mode_key_tostring(struct mode_key_cmdstr *r, enum mode_key_cmd);
enum mode_key_cmd mode_key_fromstring(struct mode_key_cmdstr *, const char *);
@


1.259
log
@Don't reset the activity timer for unattached sessions every second,
this screws up the choice of most-recently-used. Instead, break the time
update into a little function and do it when the session is attached.

Pointed out by joshe@@.
@
text
@d1 1
a1 1
/* $OpenBSD: tmux.h,v 1.258 2010/12/30 23:20:13 nicm Exp $ */
d1429 1
a1429 1
extern struct tty_term_code_entry tty_term_codes[NTTYCODE];
@


1.258
log
@Remove some unused defines.
@
text
@d1 1
a1 1
/* $OpenBSD: tmux.h,v 1.257 2010/12/30 23:16:18 nicm Exp $ */
d1983 1
@


1.257
log
@Change from a per-session stack of buffers to one global stack which is
much more convenient and also simplifies lot of code. This renders
copy-buffer useless and makes buffer-limit now a server option.

By Tiago Cunha.
@
text
@d1 1
a1 1
/* $OpenBSD: tmux.h,v 1.256 2010/12/30 21:35:17 nicm Exp $ */
a1601 3
#define CMD_BUFFER_PANE_USAGE "[-b buffer-index] [-t target-pane]"
#define CMD_BUFFER_WINDOW_USAGE "[-b buffer-index] [-t target-window]"
#define CMD_BUFFER_CLIENT_USAGE "[-b buffer-index] [-t target-client]"
@


1.256
log
@Add a function to create window flags rather than doing the same thing
in two places. From Thomas Adam.
@
text
@d1 1
a1 1
/* $OpenBSD: tmux.h,v 1.255 2010/12/29 21:49:06 nicm Exp $ */
a954 2
	struct paste_stack buffers;

a1256 1
	char	*target;
a1448 2
void		 paste_init_stack(struct paste_stack *);
void		 paste_free_stack(struct paste_stack *);
a1501 1
extern const struct cmd_entry cmd_copy_buffer_entry;
a1603 1
#define CMD_BUFFER_SESSION_USAGE "[-b buffer-index] [-t target-session]"
d1605 1
d1635 1
@


1.255
log
@Support all four of the xterm mouse modes. Based on a diff from hsim at
gmx.li.
@
text
@d1 1
a1 1
/* $OpenBSD: tmux.h,v 1.254 2010/12/21 22:37:59 nicm Exp $ */
d1901 2
@


1.254
log
@Store sessions in an RB tree by name rather than a list, this is tidier
and allows them to easily be shown sorted in various lists
(list-sessions/choose-sessions).

Keep a session index which is used in a couple of places internally but
make it an ever-increasing number rather than filling in gaps with new
sessions.
@
text
@d1 1
a1 1
/* $OpenBSD: tmux.h,v 1.253 2010/12/20 00:19:20 nicm Exp $ */
d548 8
a555 3
#define MODE_MOUSE 0x10
#define MODE_MOUSEMOTION 0x20
#define MODE_WRAP 0x40		/* whether lines wrap */
d1816 2
a1817 1
void	 screen_write_mousemode(struct screen_write_ctx *, int);
@


1.253
log
@Dead sessions are never on the active sessions list, so the SESSION_DEAD
flag is effectively unused. Remove it.
@
text
@d1 1
a1 1
/* $OpenBSD: tmux.h,v 1.252 2010/12/20 00:17:22 nicm Exp $ */
d933 2
d962 1
d964 2
a965 1
ARRAY_DECL(sessions, struct session *);
d1974 2
d1978 1
a1982 1
int		 session_index(struct session *, u_int *);
@


1.252
log
@Use pointer rather than index for the client's last session.
@
text
@d1 1
a1 1
/* $OpenBSD: tmux.h,v 1.251 2010/12/20 00:03:55 nicm Exp $ */
a950 1
#define SESSION_DEAD 0x2
@


1.251
log
@Unify the way sessions are used by callbacks - store the address and use
the reference count, then check it is still on the global sessions list
in the callback.
@
text
@d1 1
a1 1
/* $OpenBSD: tmux.h,v 1.250 2010/12/11 18:39:25 nicm Exp $ */
d1158 1
a1158 1
	u_int            last_session;
@


1.250
log
@Track the last session for a client and add a flag to switch-client and
a key binding (L) to move a client back to its last session.
@
text
@d1 1
a1 1
/* $OpenBSD: tmux.h,v 1.249 2010/12/11 16:05:57 nicm Exp $ */
d1971 1
@


1.249
log
@Make the prompt history global for all clients which is much more useful than per-client history.
@
text
@d1 1
a1 1
/* $OpenBSD: tmux.h,v 1.248 2010/12/06 22:51:02 nicm Exp $ */
d1158 1
@


1.248
log
@Add an option to alert (monitor) for silence (lack of activity) in a
window. From Thomas Adam.
@
text
@d1 1
a1 1
/* $OpenBSD: tmux.h,v 1.247 2010/11/22 21:13:13 nicm Exp $ */
d1150 1
a1153 3

	u_int		 prompt_hindex;
	ARRAY_DECL(, char *) prompt_hdata;
@


1.247
log
@There is somewhere that WINDOW_HIDDEN is getting set when it shouldn't
be and I can't find it, but the flag itself is a useless optimisation
that only applies to automatic-resize windows, so just dispose of it
entirely.

Fixes problems reported by Nicholas Riley.
@
text
@d1 1
a1 1
/* $OpenBSD: tmux.h,v 1.246 2010/11/11 20:51:30 nicm Exp $ */
d833 1
d849 1
d870 3
a872 1
#define WINLINK_ALERTFLAGS (WINLINK_BELL|WINLINK_ACTIVITY|WINLINK_CONTENT)
@


1.246
log
@Declaration in header should be extern.
@
text
@d1 1
a1 1
/* $OpenBSD: tmux.h,v 1.245 2010/10/29 20:11:57 nicm Exp $ */
d846 2
a847 3
#define WINDOW_HIDDEN 0x2
#define WINDOW_ACTIVITY 0x4
#define WINDOW_REDRAW 0x8
@


1.245
log
@We now send argv to the server after parsing it in the client to get the
command, so the client should not modify it. Instead, take a copy. Fixes
parsing command lists, reported by mcbride@@.
@
text
@d1 1
a1 1
/* $OpenBSD: tmux.h,v 1.244 2010/10/23 13:04:34 nicm Exp $ */
d1311 1
a1311 1
struct causelist cfg_causes;
@


1.244
log
@Add a last-pane command (bound to ; by default). Requested ages ago by
somebody whose name I have forgotten.
@
text
@d1 1
a1 1
/* $OpenBSD: tmux.h,v 1.243 2010/10/18 20:00:03 nicm Exp $ */
d1467 1
@


1.243
log
@Merge the before and after attach client code into one in client.c
(instead of two in tmux.c and client.c).
@
text
@d1 1
a1 1
/* $OpenBSD: tmux.h,v 1.242 2010/09/28 07:15:45 nicm Exp $ */
d835 1
d1511 1
@


1.242
log
@Nuke a leftover RB tree declaration spotted by blambert.
@
text
@d1 1
a1 1
/* $OpenBSD: tmux.h,v 1.241 2010/09/26 20:43:30 nicm Exp $ */
d1294 1
a1295 1
extern int	 be_quiet;
d1297 1
a1297 1
extern char	*socket_path;
d1299 3
d1306 1
d1605 1
a1605 2
struct imsgbuf *client_init(char *, int, int);
__dead void	client_main(void);
d1628 1
a1628 1
int	 server_start(char *);
@


1.241
log
@Two new options:

- server option "exit-unattached" makes the server exit when no clients
  are attached, even if sessions are present;

- session option "destroy-unattached" destroys a session once no clients
  are attached to it.

These are useful for preventing tmux remaining in the background where
it is undesirable and when using tmux as a login shell to keep a limit
on new sessions.
@
text
@d1 1
a1 1
/* $OpenBSD: tmux.h,v 1.240 2010/09/11 16:19:22 nicm Exp $ */
a1829 1
int		 window_cmp(struct window *, struct window *);
a1830 1
RB_PROTOTYPE(windows, window, entry, window_cmp);
@


1.240
log
@Use UTF-8 line drawing characters on UTF-8 terminals. Fixes some stupid
terminals (I'm looking at you, putty) which disable the vt100 ACS mode
switching sequences in UTF-8 mode.

Also on terminals without ACS at all, use ASCII equivalents where
obvious.
@
text
@d1 1
a1 1
/* $OpenBSD: tmux.h,v 1.239 2010/09/08 22:02:28 nicm Exp $ */
d1664 1
@


1.239
log
@Add -n and -p flags to switch-client to move to the next and previous
session (yes, it doesn't match window/pane, but so what, nor does
switch-client).

Based on a diff long ago from "edsouza".
@
text
@d1 1
a1 1
/* $OpenBSD: tmux.h,v 1.238 2010/08/19 18:29:01 nicm Exp $ */
d975 2
a1013 2
	u_char		 acs[UCHAR_MAX + 1];

a1374 1
u_char	tty_get_acs(struct tty *, u_char);
d1427 3
@


1.238
log
@Do not call event_del() for signals after fork(), just use sigaction()
directly instead - calling libevent functions after fork() w/o
event_reinit() is a bad idea, even if in this case it was harmless.
@
text
@d1 1
a1 1
/* $OpenBSD: tmux.h,v 1.237 2010/08/11 07:34:43 nicm Exp $ */
d1968 2
@


1.237
log
@Change the way backoff works. Instead of stopping reading from the pty
when the client tty backs up too much, just stop updating the tty and
only update the internal screen. Then when the tty recovers, force a
redraw.

This prevents a dodgy client from causing other clients to go into
backoff while still allowing tmux to be responsive (locally) when seeing
lots of output.
@
text
@d1 1
a1 1
/* $OpenBSD: tmux.h,v 1.236 2010/07/24 20:11:59 nicm Exp $ */
d1955 2
a1956 2
void set_signals(void(*handler)(int, short, unused void *));
void clear_signals(void);
@


1.236
log
@When changing so that the client passes its stdout and stderr as well as
stdin up to the server, I forgot one essential point - the tmux server
could now be both the producer and consumer. This happens when tmux is
run inside tmux, as well as when piping tmux commands together.

So, using stdio(3) was a bad idea - if sufficient data was written, this
could block in write(2). When that happened and the server was both
producer and consumer, it deadlocks.

Change to use libevent bufferevents for the client stdin, stdout and
stderr instead. This is trivial enough for output but requires a
callback mechanism to trigger when stdin is finished.

This relies on the underlying polling mechanism for libevent to work
with whatever devices to which the user could redirect stdin, stdout or
stderr, hence the change to use poll(2) over kqueue(2) for tmux.
@
text
@d1 1
a1 1
/* $OpenBSD: tmux.h,v 1.235 2010/07/14 18:37:49 nicm Exp $ */
d62 2
a63 2
/* Maximum data to buffer for output before suspending reading from panes. */
#define BACKOFF_THRESHOLD 1024
d1020 1
d1130 2
@


1.235
log
@Make pane/window wrapping more logical (so with 10 windows, +10 from
window 5 stays in the same place), and tidy the code. From Tiago Cunha.
@
text
@d1 1
a1 1
/* $OpenBSD: tmux.h,v 1.234 2010/07/11 17:06:45 nicm Exp $ */
d1099 11
a1109 3
	FILE		*stdin_file;
	FILE		*stdout_file;
	FILE		*stderr_file;
d1119 1
a1119 1
/* 0x4 unused */
@


1.234
log
@Return the command client return code with MSG_EXIT now that MSG_ERROR and
MSG_PRINT are unused.

New clients should be compatible with old tmux servers but vice versa may print
an error.
@
text
@d1 1
a1 1
/* $OpenBSD: tmux.h,v 1.233 2010/06/29 05:24:49 tedu Exp $ */
d1828 4
a1831 2
struct winlink	*winlink_next_by_number(struct winlink *, int);
struct winlink	*winlink_previous_by_number(struct winlink *, int);
d1846 4
@


1.233
log
@replace some magic mouse constants with defines for clarity. ok nicm
@
text
@d1 1
a1 1
/* $OpenBSD: tmux.h,v 1.232 2010/06/29 03:30:14 nicm Exp $ */
d416 4
d1088 1
@


1.232
log
@Custom layouts. list-windows command displays the layout as a string (such as
"bb62,159x48,0,0{79x48,0,0,79x48,80,0}") and it can be applied to another
window (with the same number of panes or fewer) using select-layout.
@
text
@d1 1
a1 1
/* $OpenBSD: tmux.h,v 1.231 2010/06/28 22:10:42 nicm Exp $ */
d1053 8
d1064 6
@


1.231
log
@Send all three of stdin, stdout, stderr from the client to the server, so that
commands can directly make use of them. This means that load-buffer and
save-buffer can have "-" as the file to read from stdin or write to stdout.

This is a protocol version bump so the tmux server will need to be restarted
after upgrade (or an older client used).
@
text
@d1 1
a1 1
/* $OpenBSD: tmux.h,v 1.230 2010/06/27 02:56:59 nicm Exp $ */
d1853 1
d1857 1
d1878 4
d1892 1
@


1.230
log
@Store the current working directory in the session, change the default-path
option to default to empty and make that mean that the stored session CWD is
used.
@
text
@d1 1
a1 1
/* $OpenBSD: tmux.h,v 1.229 2010/06/26 18:20:53 nicm Exp $ */
d22 1
a22 1
#define PROTOCOL_VERSION 5
a70 1
#define PRINT_LENGTH 512	/* printed error/message size */
d375 3
a377 1
	MSG_SHELL
a384 4
struct msg_print_data {
	char		msg[PRINT_LENGTH];
};

d1080 4
@


1.229
log
@Setting the cmdlist pointer in the bind-key to NULL to prevent it being freed
after the command is executing is bogus because it may still be needed if the
same command is going to be executed again (for example if you "bind-key a
bind-key b ..."). Making a copy is hard, so instead add a reference count to
the cmd_list.

While here, also print bind-key -n and the rest of the flags properly.

Fixes problem reported by mcbride@@.
@
text
@d1 1
a1 1
/* $OpenBSD: tmux.h,v 1.228 2010/06/21 21:44:09 nicm Exp $ */
d929 1
@


1.228
log
@Add a choose-buffer command for easier use of the paste buffer stack.
@
text
@d1 1
a1 1
/* $OpenBSD: tmux.h,v 1.227 2010/06/21 01:46:36 nicm Exp $ */
d1164 4
a1167 1
TAILQ_HEAD(cmd_list, cmd);
@


1.227
log
@Extend the -t:+ and -t:- window targets for next and previous window to
accept an offset such as -t:+2. From Tiago Cunha.
@
text
@d1 1
a1 1
/* $OpenBSD: tmux.h,v 1.226 2010/06/21 01:27:46 nicm Exp $ */
d1409 1
d1446 1
@


1.226
log
@Having a list of winlinks->alerts for each session is stupid, just store
the alert flags directly in the winlink itself.
@
text
@d1 1
a1 1
/* $OpenBSD: tmux.h,v 1.225 2010/06/06 19:00:13 nicm Exp $ */
d1802 2
@


1.225
log
@Use a macro-based mask for obtaining a key or modifier-set from the
combination. Display C-@@, etc, as C-Space, in list-keys. By Micah Cowan.
@
text
@d1 1
a1 1
/* $OpenBSD: tmux.h,v 1.224 2010/06/05 16:47:11 nicm Exp $ */
d846 1
a846 2
#define WINDOW_CONTENT 0x8
#define WINDOW_REDRAW 0x10
d863 6
a919 7
struct session_alert {
	struct winlink	*wl;
	int		 type;

	SLIST_ENTRY(session_alert) entry;
};

a943 2
	SLIST_HEAD(, session_alert) alerts;

a1909 4
void	 session_alert_add(struct session *, struct window *, int);
void	 session_alert_cancel(struct session *, struct winlink *);
int	 session_alert_has(struct session *, struct winlink *, int);
int	 session_alert_has_window(struct session *, struct window *, int);
d1921 1
a1921 1
int		 session_has(struct session *, struct window *);
@


1.224
log
@Fix problems with window sizing seen by Raghavendra D Prabhu when
starting tmux from .xinitrc.

One of the very few things the server relies on the client for now is to
pass through a message on SIGWINCH, but there is a condition where
potentially a SIGWINCH may be lost during the transition from unattached
(main.c) to attached (client.c). So trigger a size change immediately
after the client installs its SIGWINCH handler.

Also, when the terminal is resized, reset the scroll region and cursor
position. Previously, we were clearing our saved idea of these, but in
fact some terminals do not reset them on resize, so this caused problems
during redraw.

While here make a resize to the same size not cause a redraw and rename
the tmux.out output log file to include the tmux PID.
@
text
@d1 1
a1 1
/* $OpenBSD: tmux.h,v 1.223 2010/05/31 19:51:29 nicm Exp $ */
d113 4
@


1.223
log
@When the mode-mouse option is on, support dragging to make a selection
in copy mode.

Also support the scroll wheel, although xterm strangely does not ignore
it in application mouse mode, causing redraw artifacts when scrolling up
(other terminals appear to be better behaved).
@
text
@d1 1
a1 1
/* $OpenBSD: tmux.h,v 1.222 2010/05/26 16:44:32 nicm Exp $ */
d1354 1
a1354 1
void	tty_resize(struct tty *);
@


1.222
log
@Move imsg into libutil and add a man page.

Minor bump for libutil.

Previous versions of this diff and man page looked at by various people.

"you should just commit" deraadt
@
text
@d1 1
a1 1
/* $OpenBSD: tmux.h,v 1.221 2010/05/23 19:42:19 nicm Exp $ */
d544 2
a545 1
#define MODE_WRAP 0x20		/* whether lines wrap */
d1090 1
a1090 1
#define CLIENT_MOUSE 0x4
@


1.221
log
@Pass in the session, rather than the client, to window modes' key()
function. We were only ever using the client to find the session anyway.

This allows send-key to work properly for manipulating copy mode from
outside tmux.

From Micah Cowan.
@
text
@d1 1
a1 1
/* $OpenBSD: tmux.h,v 1.220 2010/05/05 23:24:23 nicm Exp $ */
d33 1
a41 1
#include "imsg.h"
@


1.220
log
@Identical behaviour to select-prompt can now be obtained with
command-prompt, so remove select-prompt and change ' to be bound to
command-prompt -p index "select-window -t :%%".
@
text
@d1 1
a1 1
/* $OpenBSD: tmux.h,v 1.219 2010/05/04 17:28:16 nicm Exp $ */
d763 1
a763 1
struct client;
d770 1
a770 1
	void	(*key)(struct window_pane *, struct client *, int);
d772 1
a772 1
		    struct client *, struct mouse_event *);
d1831 1
a1831 1
void		 window_pane_key(struct window_pane *, struct client *, int);
d1833 1
a1833 1
		     struct client *, struct mouse_event *);
@


1.219
log
@Put this back in with the initialisation in the right order.
@
text
@d1 1
a1 1
/* $OpenBSD: tmux.h,v 1.218 2010/05/04 08:48:06 nicm Exp $ */
a1497 1
extern const struct cmd_entry cmd_select_prompt_entry;
@


1.218
log
@Revert last change, it appears to be broken somehow.
@
text
@d1 1
a1 1
/* $OpenBSD: tmux.h,v 1.216 2010/04/06 21:35:44 nicm Exp $ */
d1256 1
a1586 2
void	 server_signal_set(void);
void	 server_signal_clear(void);
d1901 4
@


1.217
log
@Make signal handler setup/teardown two common functions instead of six,
and reset SIGCHLD after fork to fix problems with some shells. From
Romain Francois.
@
text
@a1255 1
extern struct event_base *ev_base;
d1586 2
a1901 4

/* signal.c */
void		 set_signals(void(*)(int, short, void *));
void		 clear_signals(void);
@


1.216
log
@Merge copy mode and output mode, dropping the latter. Idea and code from
Micah Cowan.
@
text
@d1 1
a1 1
/* $OpenBSD: tmux.h,v 1.215 2010/04/04 19:02:09 nicm Exp $ */
d1256 1
a1586 2
void	 server_signal_set(void);
void	 server_signal_clear(void);
d1901 4
@


1.215
log
@Run job commands explicitly in the global enviroment (which can be
modified with setenv -g) rather than with the environment tmux started
with.
@
text
@d1 1
a1 1
/* $OpenBSD: tmux.h,v 1.214 2010/04/04 18:48:37 nicm Exp $ */
d544 1
d1884 4
a1888 5

/* window-more.c */
extern const struct window_mode window_more_mode;
void		 window_more_add(struct window_pane *, const char *, ...);
void		 window_more_vadd(struct window_pane *, const char *, va_list);
@


1.214
log
@Squash a function that is only called in a callback into the callback
function.
@
text
@d1 1
a1 1
/* $OpenBSD: tmux.h,v 1.213 2010/03/22 19:18:46 nicm Exp $ */
d1333 1
@


1.213
log
@Dead functions, lint.
@
text
@d1 1
a1 1
/* $OpenBSD: tmux.h,v 1.212 2010/03/22 19:10:42 nicm Exp $ */
a1830 1
void		 window_pane_parse(struct window_pane *);
@


1.212
log
@Add vi-style "jump" commands for copy mode, from Micah Cowan.
@
text
@d1 1
a1 1
/* $OpenBSD: tmux.h,v 1.211 2010/03/22 19:07:52 nicm Exp $ */
a1599 1
void	 server_write_error(struct client *, const char *);
@


1.211
log
@Support up, down, left, right movement through panes with -UDLR flags to
select-pane.

Also REMOVE the up- and down-pane commands: equivalent behaviour is now
available using -t :.+ and -t :.-.
@
text
@d1 1
a1 1
/* $OpenBSD: tmux.h,v 1.210 2010/03/22 19:02:54 nicm Exp $ */
d462 4
@


1.210
log
@New input parser based on http://vt100.net/emu/dec_ansi_parser.
@
text
@d1 1
a1 1
/* $OpenBSD$ */
d1835 4
@


1.209
log
@Permit keys in copy mode to be prefixed by a repeat count, entered with
[1-9] in vi mode, or M-[1-9] in emacs mode.

From Micah Cowan, tweaked a little by me.
@
text
@d1 1
a1 1
/* $OpenBSD: tmux.h,v 1.208 2010/02/19 00:03:21 nicm Exp $ */
a721 6
/* Input parser sequence argument. */
struct input_arg {
	u_char		 data[64];
	size_t		 used;
};

d724 1
a724 1
	struct window_pane *wp;
d727 8
a734 4
	u_char		*buf;
	size_t		 len;
	size_t		 off;
	size_t		 was;
d736 2
a737 1
	struct grid_cell cell;
d739 2
a740 3
	struct grid_cell saved_cell;
	u_int		 saved_cx;
	u_int		 saved_cy;
d742 2
a743 7
#define MAXSTRINGLEN	1024
	u_char		*string_buf;
	size_t		 string_len;
	int		 string_type;
#define STRING_SYSTEM 0
#define STRING_APPLICATION 1
#define STRING_NAME 2
d745 1
a745 1
	struct utf8_data utf8data;
d747 3
a749 2
	u_char		 intermediate;
	void		*(*state)(u_char, struct input_ctx *);
d751 1
a751 2
	u_char		 private;
	ARRAY_DECL(, struct input_arg) args;
d1821 4
@


1.208
log
@copy mode uses the real screen as backing and if it is updated while copying,
strange things can happen. So, freeze reading from the pty while in copy mode.
@
text
@d1 1
a1 1
/* $OpenBSD: tmux.h,v 1.207 2010/02/11 20:39:40 nicm Exp $ */
d480 1
@


1.207
log
@Add "N" key to search the opposite way from the last search (reverse of "n"),
from Micah Cowan.
@
text
@d1 1
a1 1
/* $OpenBSD: tmux.h,v 1.206 2010/02/06 23:22:27 nicm Exp $ */
d790 1
@


1.206
log
@Use the array.h code for the causes list.
@
text
@d1 1
a1 1
/* $OpenBSD: tmux.h,v 1.205 2010/02/06 22:55:31 nicm Exp $ */
d478 1
@


1.205
log
@Support attaching a client read-only with a new -r flag to the attach-session
command.
@
text
@d1 1
a1 1
/* $OpenBSD: tmux.h,v 1.204 2010/02/06 17:35:01 nicm Exp $ */
d1247 3
d1268 3
a1270 4
extern char    **cfg_causes;
extern u_int     cfg_ncauses;
void printflike3 cfg_add_cause(u_int *, char ***, const char *, ...);
int		 load_cfg(const char *, struct cmd_ctx *, u_int *, char ***);
@


1.204
log
@Rectangle copy support, from Robin Lee Powell.
@
text
@d1 1
a1 1
/* $OpenBSD: tmux.h,v 1.203 2010/02/06 17:15:33 nicm Exp $ */
d1097 1
d1176 1
@


1.203
log
@Instead of bailing out on the first configuration file error, carry on,
collecting all the errors, then start with the active window in more mode
displaying them.
@
text
@d1 1
a1 1
/* $OpenBSD: tmux.h,v 1.202 2010/02/04 20:00:26 nicm Exp $ */
d472 1
d678 1
d1779 2
a1780 2
void	 screen_set_selection(
	     struct screen *, u_int, u_int, u_int, u_int, struct grid_cell *);
@


1.202
log
@vi-style B, W and E keys in copy mode to navigate between words treating only
spaces as word separators. Also add . to the list of word separators for
standard word navigation.

From Micah Cowan, tweaked slightly by me.
@
text
@d1 1
a1 1
/* $OpenBSD: tmux.h,v 1.201 2010/02/01 22:15:51 nicm Exp $ */
d1260 5
a1264 1
int		 load_cfg(const char *, struct cmd_ctx *, char **);
d1874 1
@


1.201
log
@Add scroll-up/scroll-down for choose/more mode, from Micah Cowan.
@
text
@d1 1
a1 1
/* $OpenBSD: tmux.h,v 1.200 2010/01/27 20:18:52 nicm Exp $ */
d465 2
d470 1
@


1.200
log
@Alter next-word to have vi-like movement behaviour, and add next-word-end with
the existing emacs behaviour. From Micah Cowan.
@
text
@d1 1
a1 1
/* $OpenBSD: tmux.h,v 1.199 2010/01/25 21:33:39 nicm Exp $ */
d445 2
@


1.199
log
@Top/bottom of history mode keys, diff from Micah Cowan, tweaked by me.
@
text
@d1 1
a1 1
/* $OpenBSD: tmux.h,v 1.198 2010/01/07 20:52:18 nicm Exp $ */
d464 1
@


1.198
log
@New command, join-pane, to split and move an existing pane into the space (like
splitw then movep, or the reverse of breakp).
@
text
@d1 1
a1 1
/* $OpenBSD: tmux.h,v 1.197 2010/01/03 12:51:05 nicm Exp $ */
d458 2
@


1.197
log
@Options to set the colour of the pane borders, with different colours for the
active pane.
@
text
@d1 1
a1 1
/* $OpenBSD: tmux.h,v 1.196 2009/12/17 17:39:56 nicm Exp $ */
d1440 1
d1837 3
a1839 2
int		 layout_split_pane(struct window_pane *,
		     enum layout_type, int, struct window_pane *);
@


1.196
log
@Allow keys to be replaced and reorder the table so that terminfo-defined keys
(or terminal-overrides) take precedence over internally defined.
@
text
@d1 1
a1 1
/* $OpenBSD: tmux.h,v 1.195 2009/12/14 10:43:41 nicm Exp $ */
d1086 1
d1593 1
d1754 1
a1754 1
void	 screen_redraw_screen(struct client *, int);
@


1.195
log
@New server option, escape-time, to set the timeout used to detect if escapes
are alone or part of a function key or meta sequence.
@
text
@d1 1
a1 1
/* $OpenBSD: tmux.h,v 1.194 2009/12/10 09:16:52 nicm Exp $ */
d1024 1
a1024 1
	void		*ptr; 
d1026 1
a1026 1
	/* 
@


1.194
log
@Add "server options" which are server-wide and not bound to a session or
window. Set and displayed with "set -s" and "show -s".

Currently the only option is "quiet" (like command-line -q, allowing it to be
set from .tmux.conf), but others will come along.
@
text
@d1 1
a1 1
/* $OpenBSD: tmux.h,v 1.193 2009/12/08 07:49:31 nicm Exp $ */
d53 1
a53 1
/* 
a60 3

/* Escape timer period, in milliseconds. */
#define ESCAPE_PERIOD 500
@


1.193
log
@Permit panes to be referred to as "top", "bottom", "top-left" etc, if the right
pane can be identified.
@
text
@d1 1
a1 1
/* $OpenBSD: tmux.h,v 1.192 2009/12/03 22:50:10 nicm Exp $ */
d1238 1
d1395 1
@


1.192
log
@Massive spaces->tabs and trailing whitespace cleanup, hopefully for the last
time now I've configured emacs to make them displayed in really annoying
colours...
@
text
@d1 1
a1 1
/* $OpenBSD: tmux.h,v 1.191 2009/12/03 17:44:02 nicm Exp $ */
d1846 3
@


1.191
log
@Eliminate duplicate code and ease the passage for server-wide options by adding
a -w flag to set-option and show-options and making setw and showw aliases to
set -w and show -w.

Note: setw and showw are still there, but now aliases for set -w and show -w.
@
text
@d1 1
a1 1
/* $OpenBSD: tmux.h,v 1.190 2009/12/01 18:42:38 nicm Exp $ */
d343 3
a345 3
		char 	       *string;
		int	 	number;
		int	 	flag;
d407 1
a407 1
	char	       	cmd[COMMAND_LENGTH];
d411 1
a411 1
	char	     	var[ENVIRON_LENGTH];
d415 1
a415 1
	char	       	shell[MAXPATHLEN];
d441 1
a441 1
	
d514 1
a514 1
	enum mode_key_cmd      	 cmd;
d520 1
a520 1
	const char	       	*name;
d686 1
a686 1
	struct grid     *grid;		/* grid data */
d696 1
a696 1
	bitstr_t      	*tabs;
d746 1
a746 1
	void 		*(*state)(u_char, struct input_ctx *);
d765 1
a765 1
	    	    struct client *, struct mouse_event *);
d803 2
a804 2
 	u_int		 saved_cx;
 	u_int		 saved_cy;
d952 1
a952 1
	int	 	 key;
d978 2
a979 2
        u_int            sx;
        u_int            sy;
d997 1
a997 1
	struct termios   tio;
d1009 1
a1009 1
	int    		 flags;
d1072 1
a1072 1
	struct tty 	 tty;
d1149 1
a1149 1
	void	       	*data;
d1175 1
a1175 1
	size_t 		 (*print)(struct cmd *, char *, size_t);
d1245 1
a1245 1
extern char 	*socket_path;
d1281 1
a1281 1
    	    struct options *, const char *, const char *, ...);
d1284 1
a1284 1
    	    struct options *, const char *, long long);
d1287 1
a1287 1
    	    struct options *, const char *, void *, void (*)(void *));
d1315 1
a1315 1
void 	environ_update(const char *, struct environ *, struct environ *);
d1364 1
a1364 1
void 		 tty_term_free(struct tty_term *);
d1369 1
a1369 1
    		     struct tty_term *, enum tty_code_code, int, int);
d1384 1
a1384 1
int	     	 paste_free_top(struct paste_stack *);
d1396 1
a1396 1
const char 	*cmd_set_option_print(
d1511 1
a1511 1
size_t  cmd_prarg(char *, size_t, const char *, char *);
d1583 1
a1583 1
             struct client *, enum msgtype, const void *, size_t);
d1585 1
a1585 1
             struct session *, enum msgtype, const void *, size_t);
d1612 1
a1612 1
    	     struct client *, struct winlink *, const char *, time_t, int);
d1617 1
a1617 1
    	     int (*)(void *, const char *), void (*)(void *), void *, int);
d1636 1
a1636 1
char 	*xterm_keys_lookup(int);
d1673 1
a1673 1
    	     struct grid *, u_int, struct grid *, u_int, u_int);
d1686 1
a1686 1
    	     struct grid *, u_int, u_int, const struct grid_cell *);
d1690 1
a1690 1
    	     struct grid *, u_int, u_int, const struct grid_utf8 *);
d1704 1
a1704 1
    	     struct screen_write_ctx *, struct window_pane *, struct screen *);
d1708 1
a1708 1
    ssize_t, struct grid_cell *, int, const char *, ...);
d1711 1
a1711 1
    	     struct grid_cell *, const char *, ...);
d1713 1
a1713 1
    ssize_t, struct grid_cell *, int, const char *, ...);
d1717 1
a1717 1
    	     struct grid_cell *, struct grid_cell *, const char *);
d1719 1
a1719 1
    	     struct screen_write_ctx *, struct grid_cell *, u_char);
d1750 1
a1750 1
    	     const struct grid_cell *, const struct utf8_data *);
d1775 1
a1775 1
struct winlink 	*winlink_find_by_window(struct winlinks *, struct window *);
d1784 1
a1784 1
int	 	 window_index(struct window *, u_int *);
d1788 1
a1788 1
    		     u_int, u_int, u_int, char **);
d1811 1
a1811 1
    		     struct client *, struct mouse_event *);
d1814 1
a1814 1
    		     struct window_pane *, const char *, u_int *);
d1834 1
a1834 1
    		     struct window_pane *, enum layout_type, int);
d1852 1
a1852 1
void 		 window_copy_pageup(struct window_pane *);
d1856 1
a1856 1
void 		 window_more_vadd(struct window_pane *, const char *, va_list);
d1860 2
a1861 2
void 		 window_choose_vadd(
    		     struct window_pane *, int, const char *, va_list);
d1863 1
a1863 1
    		     struct window_pane *, int, const char *, ...);
d1869 1
a1869 1
char 		*default_window_name(struct window *);
d1883 2
a1884 2
void	 	 session_destroy(struct session *);
int	 	 session_index(struct session *, u_int *);
d1886 1
a1886 1
	    	     const char *, const char *, const char *, int, char **);
d1888 1
a1888 1
    		     struct session *, struct window *, int, char **);
@


1.190
log
@New command, capture-pane, which copies the entire pane contents to a paste
buffer. From Jonathan Alvarado.
@
text
@d1 1
a1 1
/* $OpenBSD: tmux.h,v 1.189 2009/11/30 16:44:03 nicm Exp $ */
a1235 2
extern const struct set_option_entry set_option_table[];
extern const struct set_option_entry set_window_option_table[];
a1377 18
/* options-cmd.c */
const char *set_option_print(
    	    const struct set_option_entry *, struct options_entry *);
void	set_option_string(struct cmd_ctx *,
	    struct options *, const struct set_option_entry *, char *, int);
void	set_option_number(struct cmd_ctx *,
    	    struct options *, const struct set_option_entry *, char *);
void	set_option_keys(struct cmd_ctx *,
    	    struct options *, const struct set_option_entry *, char *);
void	set_option_colour(struct cmd_ctx *,
    	    struct options *, const struct set_option_entry *, char *);
void	set_option_attributes(struct cmd_ctx *,
    	    struct options *, const struct set_option_entry *, char *);
void	set_option_flag(struct cmd_ctx *,
    	    struct options *, const struct set_option_entry *, char *);
void	set_option_choice(struct cmd_ctx *,
    	    struct options *, const struct set_option_entry *, char *);

d1392 6
@


1.189
log
@Handle partial xterm function key sequences.
@
text
@d1 1
a1 1
/* $OpenBSD: tmux.h,v 1.188 2009/11/26 23:13:47 nicm Exp $ */
d1436 1
@


1.188
log
@This doesn't need to be u_int.
@
text
@d1 1
a1 1
/* $OpenBSD: tmux.h,v 1.187 2009/11/26 22:28:24 nicm Exp $ */
d1650 1
a1650 1
int	 xterm_keys_find(const char *, size_t, size_t *);
@


1.187
log
@Tidy up various bits of the paste code, make the data buffer char * and add
comments.
@
text
@d1 1
a1 1
/* $OpenBSD: tmux.h,v 1.186 2009/11/26 21:37:13 nicm Exp $ */
d1411 1
a1411 1
void		 clock_draw(struct screen_write_ctx *, u_int, int);
@


1.186
log
@Remove a couple of unused arguments where possible, and add /* ARGSUSED */ to
the rest to reduce lint output.
@
text
@d1 1
a1 1
/* $OpenBSD: tmux.h,v 1.185 2009/11/25 12:24:31 nicm Exp $ */
d887 1
a887 1
     	char		*data;
d1406 2
a1407 2
void		 paste_add(struct paste_stack *, u_char *, size_t, u_int);
int		 paste_replace(struct paste_stack *, u_int, u_char *, size_t);
@


1.185
log
@Output the right keys for application and number keypad modes (they were the
wrong way round).
@
text
@d1 1
a1 1
/* $OpenBSD: tmux.h,v 1.184 2009/11/19 19:47:28 nicm Exp $ */
d1793 2
a1794 2
struct winlink	*winlink_next(struct winlinks *, struct winlink *);
struct winlink	*winlink_previous(struct winlinks *, struct winlink *);
@


1.184
log
@Change status line drawing to create the window list in a separate screen and
then copy it into the status line screen. This allows UTF-8 in window names and
fixes some problems with #[] in window-status-format.
@
text
@d1 1
a1 1
/* $OpenBSD: tmux.h,v 1.183 2009/11/19 16:22:10 nicm Exp $ */
d530 1
a530 1
#define MODE_KKEYPAD 0x8
@


1.183
log
@Two new options, window-status-format and window-status-current-format, which
allow the format of each window in the status line window list to be controlled
using similar # sequences as status-left/right.

This diff also moves part of the way towards UTF-8 support in window names but
it isn't quite there yet.
@
text
@d1 1
a1 1
/* $OpenBSD: tmux.h,v 1.182 2009/11/19 10:22:07 nicm Exp $ */
d846 4
@


1.182
log
@Don't interpret #() for display-message, it usually doesn't make sense and may
leak commands.
@
text
@d1 1
a1 1
/* $OpenBSD: tmux.h,v 1.181 2009/11/18 17:02:17 nicm Exp $ */
d1620 2
a1621 1
char	*status_replace(struct client *, const char *, time_t, int);
@


1.181
log
@Cleanup by moving various (mostly horrible) little bits handling UTF-8 grid
data into functions in a new file, grid-utf8.c, and use sizeof intead of
UTF8_DATA.

Also nuke trailing whitespace from tmux.1, reminded by jmc.
@
text
@d1 1
a1 1
/* $OpenBSD: tmux.h,v 1.180 2009/11/18 13:16:33 nicm Exp $ */
d1620 1
a1620 1
char	*status_replace(struct client *, const char *, time_t);
@


1.180
log
@Add a per-client log of status line messages displayed while that client
exists. A new message-limit session option sets the maximum number of entries
and a command, show-messages, shows the log (bound to ~ by default).

This (and prompt history) might be better as a single global log but until
there are global options it is easier for them to be per client.
@
text
@d1 1
a1 1
/* $OpenBSD: tmux.h,v 1.179 2009/11/13 19:58:32 nicm Exp $ */
d77 6
d534 1
a534 1
 * A single UTF-8 character. 
a539 1
#define UTF8_SIZE 9
d1682 7
@


1.179
log
@Tweak a comment and add some spacing.
@
text
@d1 1
a1 1
/* $OpenBSD: tmux.h,v 1.178 2009/11/13 19:53:29 nicm Exp $ */
d1044 6
d1086 1
d1491 1
@


1.178
log
@Get rid of the ugly CMD_CHFLAG macro and use a const string (eg "dDU") in the
command entry structs and a couple of functions to check/set the flags.
@
text
@d1 1
a1 1
/* $OpenBSD: tmux.h,v 1.177 2009/11/13 17:33:07 nicm Exp $ */
d1165 1
d1167 1
d1174 1
d1177 1
d1184 1
d1187 1
@


1.177
log
@Destroy panes immediately rather than checking them all every loop.
@
text
@d1 1
a1 1
/* $OpenBSD: tmux.h,v 1.176 2009/11/13 07:00:54 nicm Exp $ */
d1153 1
a1153 4
#define CMD_CHFLAG(flag) \
	((flag) >= 'a' && (flag) <= 'z' ? 1ULL << ((flag) - 'a') :	\
	(flag) >= 'A' && (flag) <= 'Z' ? 1ULL << (26 + (flag) - 'A') : 0)
	uint64_t	 chflags;
d1502 2
@


1.176
log
@Zap unused functions, prompted by deraadt.
@
text
@d1 1
a1 1
/* $OpenBSD: tmux.h,v 1.175 2009/11/11 08:00:42 nicm Exp $ */
d1593 1
@


1.175
log
@Only need to chmod +x or -x the socket when a client is created, lost or
attached, rather than every event loop.
@
text
@d1 1
a1 1
/* $OpenBSD: tmux.h,v 1.174 2009/11/10 17:41:35 nicm Exp $ */
a1251 1
void	mode_key_free_trees(void);
a1542 1
void	 key_bindings_free(void);
@


1.174
log
@Whoops, this is needed for last commit as well.
@
text
@d1 1
a1 1
/* $OpenBSD: tmux.h,v 1.173 2009/11/05 19:29:41 nicm Exp $ */
d1560 1
@


1.173
log
@Switch the tty key tree over to an (unbalanced) ternary tree which allows
partial matches to be done (they wait for further data or a timer to expire,
like a naked escape).

Mouse and xterm-style keys still expect to be atomic.
@
text
@d1 1
a1 1
/* $OpenBSD: tmux.h,v 1.172 2009/11/05 10:44:36 nicm Exp $ */
d101 1
a101 1
/* Key codes. ncurses defines KEY_*. Grrr. */
d103 3
a105 1
/* 0x1000 is base for special keys */
d111 1
d114 1
a114 1
	KEYC_MOUSE = 0x1000,
@


1.172
log
@Key flags are only used for initialisation so they are not needed in the main
tty_key struct.
@
text
@d1 1
a1 1
/* $OpenBSD: tmux.h,v 1.171 2009/11/05 08:48:15 nicm Exp $ */
d939 1
a940 1
	char		*string;
d942 4
a945 1
	RB_ENTRY(tty_key) entry;
d1004 1
a1004 3

	size_t		 ksize;	/* maximum key size */
	RB_HEAD(tty_keys, tty_key) ktree;
a1354 2
int	tty_keys_cmp(struct tty_key *, struct tty_key *);
RB_PROTOTYPE(tty_keys, tty_key, entry, tty_keys_cmp);
@


1.171
log
@Now all timers are events, there is no longer any need to wake up every 50 ms -
only wake up when an event happens.
@
text
@d1 1
a1 1
/* $OpenBSD: tmux.h,v 1.170 2009/11/05 08:45:08 nicm Exp $ */
a940 4

	int		 flags;
#define TTYKEY_CTRL 0x1
#define TTYKEY_RAW 0x2
@


1.170
log
@Switch tty key input over to happen on a read event. This is a bit more
complicated because of escape input, but in that case instead of processing a
key immediately, schedule a timer and reprocess the bufer when it expires.

This currently assumes that keys will be atomic (ie that if eg F1 is pressed
the entire sequence is present in the buffer). This is usually but not always
true, a change in the tree format so it can differentiate potential (partial)
key sequences will happens soon and will allow this to be fixed.
@
text
@d1 1
a1 1
/* $OpenBSD: tmux.h,v 1.169 2009/11/05 00:05:00 nicm Exp $ */
a63 3

/* Maximum poll timeout (when attached). */
#define POLL_TIMEOUT 50
@


1.169
log
@Convert the key repeat timer to an event.
@
text
@d1 1
a1 1
/* $OpenBSD: tmux.h,v 1.168 2009/11/04 23:54:57 nicm Exp $ */
d1005 3
a1007 1
	struct timeval	 key_timer;
d1365 1
a1365 1
int	tty_keys_next(struct tty *, int *, struct mouse_event *);
@


1.168
log
@Change window name change to use a timer event rather than a gettimeofday()
check every loop.
@
text
@d1 1
a1 1
/* $OpenBSD: tmux.h,v 1.167 2009/11/04 23:42:51 nicm Exp $ */
d1059 1
a1059 1
	struct timeval	 repeat_timer;
@


1.167
log
@Move status timer check into the global once-per-second timer, this could maybe
be done better but one every second is better than once every 50 ms.
@
text
@d1 1
a1 1
/* $OpenBSD: tmux.h,v 1.166 2009/11/04 23:29:42 nicm Exp $ */
d813 1
a813 1
	struct timeval	 name_timer;
d1854 1
a1854 1
void		 set_window_names(void);
@


1.166
log
@Use timeout events for the identify and message timers.
@
text
@d1 1
a1 1
/* $OpenBSD: tmux.h,v 1.165 2009/11/04 23:12:43 nicm Exp $ */
d1568 1
@


1.165
log
@Don't reenlist the client imsg event every loop, instead have a small function
to it and call it after the event triggers or after a imsg is added.
@
text
@d1 1
a1 1
/* $OpenBSD: tmux.h,v 1.164 2009/11/04 22:44:53 nicm Exp $ */
d1077 1
a1077 1
	struct timeval	 identify_timer;
d1080 1
a1080 1
	struct timeval	 message_timer;
@


1.164
log
@Bye-bye buffer*.c.
@
text
@d1 1
a1 1
/* $OpenBSD: tmux.h,v 1.163 2009/11/04 22:43:11 nicm Exp $ */
a1566 1
void	 server_client_prepare(void);
d1600 1
@


1.163
log
@Convert the window pane (pty master side) fd over to use a bufferevent.

The evbuffer API is very similar to the existing tmux buffer API so this was
remarkably painless. Not many possible ways to do it, I suppose.
@
text
@d1 1
a1 1
/* $OpenBSD: tmux.h,v 1.162 2009/11/04 22:02:38 nicm Exp $ */
a98 15
/* Buffer macros. */
#define BUFFER_USED(b) ((b)->size)
#define BUFFER_FREE(b) ((b)->space - (b)->off - (b)->size)
#define BUFFER_IN(b) ((b)->base + (b)->off + (b)->size)
#define BUFFER_OUT(b) ((b)->base + (b)->off)

/* Buffer structure. */
struct buffer {
	u_char	*base;		/* buffer start */
	size_t	 space;		/* total size of buffer */

	size_t	 size;		/* size of data in buffer */
	size_t	 off;		/* offset of data in buffer */
};

a1894 14

/* buffer.c */
struct buffer 	*buffer_create(size_t);
void		 buffer_destroy(struct buffer *);
void		 buffer_ensure(struct buffer *, size_t);
void		 buffer_add(struct buffer *, size_t);
void		 buffer_remove(struct buffer *, size_t);
void		 buffer_write(struct buffer *, const void *, size_t);
void		 buffer_read(struct buffer *, void *, size_t);
void	 	 buffer_write8(struct buffer *, uint8_t);
uint8_t		 buffer_read8(struct buffer *);

/* buffer-poll.c */
int		 buffer_poll(int, int, struct buffer *, struct buffer *);
@


1.162
log
@Switch window pane pipe redirect fd over to a bufferevent.
@
text
@d1 1
a1 1
/* $OpenBSD: tmux.h,v 1.161 2009/11/04 21:47:42 nicm Exp $ */
d801 1
a801 3
	struct event	 event;
	struct buffer	*in;
	struct buffer	*out;
a1586 2
void	 server_window_prepare(void);
void	 server_window_callback(int, short, void *);
@


1.161
log
@Switch tty fds over to a bufferevent.
@
text
@d1 1
a1 1
/* $OpenBSD: tmux.h,v 1.160 2009/11/04 21:04:43 nicm Exp $ */
d808 1
a808 2
	struct event	 pipe_event;
	struct buffer	*pipe_buf;
@


1.160
log
@Switch jobs over to use a bufferevent.
@
text
@d1 1
a1 1
/* $OpenBSD: tmux.h,v 1.159 2009/11/04 20:50:11 nicm Exp $ */
d1003 1
a1003 3
	struct event	 event;
	struct buffer	*in;
	struct buffer	*out;
@


1.159
log
@Initial changes to move tmux to libevent.

This moves the client-side loops are pretty much fully over to event-based only
(tmux.c and client.c) but server-side (server.c and friends) treats libevent as
a sort of clever poll, waking up after every event to run various things.

Moving the server stuff over to bufferevents and timers and so on will come
later.
@
text
@d1 1
a1 1
/* $OpenBSD: tmux.h,v 1.158 2009/11/03 22:40:40 nicm Exp $ */
d664 1
a664 2
	struct event	 event;
	struct buffer	*out;
d671 1
a671 2
#define JOB_DONE 0x1
#define JOB_PERSIST 0x2	/* don't free after callback */
d1307 1
a1589 5

/* server-job.c */
void	 server_job_prepare(void);
void	 server_job_callback(int, short, void *);
void	 server_job_loop(void);
@


1.158
log
@Add an activity time for clients, like for sessions, and change session and
client lookup to pick the most recently used rather than the most recently
created - this is much more useful when used interactively and (because the
activity time is set at creation) should have no effect on source-file.

Based on a problem reported by Jan Johansson.
@
text
@d1 1
a1 1
/* $OpenBSD: tmux.h,v 1.157 2009/11/03 20:59:22 nicm Exp $ */
d31 1
a33 1
#include <poll.h>
d664 1
d800 2
d803 1
a803 1
	char		 tty[TTY_NAME_MAX];
d810 1
d1005 1
d1070 1
a1243 6
extern volatile sig_atomic_t sigwinch;
extern volatile sig_atomic_t sigterm;
extern volatile sig_atomic_t sigcont;
extern volatile sig_atomic_t sigchld;
extern volatile sig_atomic_t sigusr1;
extern volatile sig_atomic_t sigusr2;
a1253 3
void		 siginit(void);
void		 sigreset(void);
void		 sighandler(int);
d1582 2
a1583 1
void	 server_poll_add(int, int, void (*)(int, int, void *), void *);
d1589 1
a1589 1
void	 server_client_callback(int, int, void *);
d1594 1
a1594 1
void	 server_job_callback(int, int, void *);
d1599 1
a1599 1
void	 server_window_callback(int, int, void *);
@


1.157
log
@If it isn't available explicitly, work out the current client in a similar way
to the current session - build a list of the possibilities then pick the
newest.
@
text
@d1 1
a1 1
/* $OpenBSD: tmux.h,v 1.156 2009/11/03 20:29:47 nicm Exp $ */
d1067 1
@


1.156
log
@Change session and client activity and creation time members to have more
meaningful names.

Also, remove the code to try and update the session activity time for the
command client when a command message is received as is pointless because it
des not have a session.
@
text
@d1 1
a1 1
/* $OpenBSD: tmux.h,v 1.155 2009/11/03 17:17:24 nicm Exp $ */
d1430 1
@


1.155
log
@tv member of struct paste_buffer is updated but not otherwise used, so remove
it.
@
text
@d1 1
a1 1
/* $OpenBSD: tmux.h,v 1.154 2009/11/02 20:18:22 nicm Exp $ */
d925 3
a927 2
	struct timeval	 tv;
	time_t		 activity;
d1065 2
a1066 1
	struct timeval	 tv;
@


1.154
log
@Double the escape timer (the time after a \033 is received before tmux gives up
waiting to see if it is part of a key sequence and passes it through) to 500
ms, the previous setting was too fast. Suggested by naddy.
@
text
@d1 1
a1 1
/* $OpenBSD: tmux.h,v 1.153 2009/11/01 23:20:37 nicm Exp $ */
a895 1
	struct timeval	 tv;
@


1.153
log
@Add a flag for jobs that shouldn't be freed after they've died and use it for
status jobs, then only kill those jobs when status-left, status-right or
set-titles-string is changed.

Fixes problems with changing options from inside #().
@
text
@d1 1
a1 1
/* $OpenBSD: tmux.h,v 1.152 2009/10/28 22:53:14 nicm Exp $ */
d63 1
a63 1
#define ESCAPE_PERIOD 250
@


1.152
log
@If any client currently displaying a window pane has more than 1 KB of output
buffered, don't accept any further data from the process running in the pane.

This makes tmux much more responsive when flooded with output, although other
buffers can still have an impact when running remotely.

Prompted by a query from Ranganathan Sankaralingam.
@
text
@d1 1
a1 1
/* $OpenBSD: tmux.h,v 1.151 2009/10/27 13:03:33 nicm Exp $ */
d672 1
d1305 1
a1305 1
struct job *job_add(struct jobs *, struct client *,
d1307 1
@


1.151
log
@Move the poll registration functions into the server-*.c files.
@
text
@d1 1
a1 1
/* $OpenBSD: tmux.h,v 1.150 2009/10/26 17:46:33 nicm Exp $ */
d67 3
@


1.150
log
@Rewrite xterm-keys code (both input and output) so that works (doesn't always
output the same modifiers, accepts all the possible input keys) and is more
understandable.
@
text
@d1 1
a1 1
/* $OpenBSD: tmux.h,v 1.149 2009/10/26 16:00:51 nicm Exp $ */
d1577 1
d1582 1
d1587 1
d1592 1
@


1.149
log
@Support the (mostly new) function key+modifier caps (kIC-kIC7). Most of these
will be caught (soon) by the xterm keys code in xterm itself but some other
descriptions such as rxvt define them as well.
@
text
@d1 1
a1 1
/* $OpenBSD: tmux.h,v 1.148 2009/10/26 13:13:33 nicm Exp $ */
d1644 4
@


1.148
log
@Rename keypad keys to something more useful.
@
text
@d1 1
a1 1
/* $OpenBSD: tmux.h,v 1.147 2009/10/25 21:11:21 nicm Exp $ */
d229 6
d236 6
d243 6
d269 6
d276 6
d283 6
d291 6
d298 18
@


1.147
log
@Remove the -d flag to tmux and just use op/AX to detect default colours.

Irritatingly, although op can be used to tell if a terminal supports default
colours, it can't be used to set them because in some terminfo descriptions it
resets attributes as a side-effect (acts as sgr0) and in others it doesn't, so
it is not possible to determine reliably what the terminal state will be
afterwards. So if AX is missing and op is present, tmux just sends sgr0.

Anyone using -d for a terminal who finds they actually needed it can replace it
using terminal-overrides, but please let me know as it is probably an omission
from terminfo.
@
text
@d1 1
a1 1
/* $OpenBSD: tmux.h,v 1.146 2009/10/22 19:41:51 nicm Exp $ */
d166 17
a182 17
	/* Numeric keypad. Numbered from top-left, KPY_X. */
	KEYC_KP0_1,
	KEYC_KP0_2,
	KEYC_KP0_3,
	KEYC_KP1_0,
	KEYC_KP1_1,
	KEYC_KP1_2,
	KEYC_KP1_3,
	KEYC_KP2_0,
	KEYC_KP2_1,
	KEYC_KP2_2,
	KEYC_KP3_0,
	KEYC_KP3_1,
	KEYC_KP3_2,
	KEYC_KP3_3,
	KEYC_KP4_0,
	KEYC_KP4_2,
@


1.146
log
@Split the server code handling clients, jobs and windows off into separate
files from server.c (merging server-msg.c into the client file) and rather than
iterating over each set after poll(), allow a callback to be specified when the
fd is added and just walk once over the returned pollfds calling each callback
where needed.

More to come, getting this in so it is tested.
@
text
@d1 1
a1 1
/* $OpenBSD: tmux.h,v 1.145 2009/10/21 20:11:47 nicm Exp $ */
a348 1
#define IDENTIFY_HASDEFAULTS 0x8
d910 3
a912 4
#define TERM_HASDEFAULTS 0x1
#define TERM_256COLOURS 0x2
#define TERM_88COLOURS 0x4
#define TERM_EARLYWRAP 0x8
@


1.145
log
@Client tidying: get rid of client_ctx struct in favour of two variables in
client.c, and move the functions in client-fn.c into other files.
@
text
@d1 1
a1 1
/* $OpenBSD: tmux.h,v 1.144 2009/10/21 18:20:16 nicm Exp $ */
d1520 13
a1532 2
/* server-msg.c */
int	 server_msg_dispatch(struct client *);
d1864 1
a1864 1
int		 buffer_poll(struct pollfd *, struct buffer *, struct buffer *);
@


1.144
log
@Remove unused function.
@
text
@d1 1
a1 1
/* $OpenBSD: tmux.h,v 1.143 2009/10/20 19:18:28 nicm Exp $ */
a1054 13
/* Client context. */
struct client_ctx {
	struct imsgbuf	 ibuf;

	enum {
		CCTX_DETACH,
		CCTX_EXIT,
		CCTX_DIED,
		CCTX_SHUTDOWN
	} exittype;
	const char	*errstr;
};

d1493 2
a1494 8
int	 client_init(char *, struct client_ctx *, int, int);
int	 client_main(struct client_ctx *);
int	 client_msg_dispatch(struct client_ctx *);

/* client-fn.c */
void	 client_write_server(struct client_ctx *, enum msgtype, void *, size_t);
void	 client_fill_session(struct msg_command_data *);
void	 client_suspend(void);
@


1.143
log
@Try to reduce the UTF-8 mess.

Get rid of passing around u_char[4]s and define a struct utf8_data which has
character data, size (sequence length) and width. Move UTF-8 character
collection into two functions utf8_open/utf8_append in utf8.c which fill in
this struct and use these functions from input.c and the various functions in
screen-write.c.

Space for rather more data than is necessary for one UTF-8 sequence is in the
utf8_data struct because screen_write_copy is still nasty and needs to reinject
the character (after combining) into screen_write_cell.
@
text
@d1 1
a1 1
/* $OpenBSD: tmux.h,v 1.142 2009/10/20 17:33:33 nicm Exp $ */
a1254 1
u_int	job_tree_size(struct jobs *);
@


1.142
log
@UTF-8 combined character fixes.

Thai can have treble combinations (1 x width=1 then 2 x width=0) so bump the
UTF-8 cell data size to 9 and alter the code to allow this.

Also break off the combining code into a separate function, handle any further
combining beyond the buffer size by replacing the character with _s, and when
redrawing the UTF-8 character don't assume the first part has just been
printed, redraw the entire line.
@
text
@d1 1
a1 1
/* $OpenBSD: tmux.h,v 1.141 2009/10/20 14:22:57 nicm Exp $ */
d480 17
a535 1
#define UTF8_SIZE 9
d691 1
a691 3
	u_char		 utf8_buf[4];
	u_int		 utf8_len;
	u_int		 utf8_off;
d1699 2
a1700 2
void	 screen_write_cell(
    	     struct screen_write_ctx *, const struct grid_cell *, u_char *);
d1855 2
a1856 1
int	utf8_width(const u_char *);
@


1.141
log
@Nuke stray blank line.
@
text
@d1 1
a1 1
/* $OpenBSD: tmux.h,v 1.140 2009/10/17 08:24:46 nicm Exp $ */
d519 1
a519 1
#define UTF8_SIZE 8
@


1.140
log
@Instead of having a complicated check to see if the cursor is in the last
position to avoid an explicit wrap, actually move it there.

Some UTF-8 fixes to come.
@
text
@d1 1
a1 1
/* $OpenBSD: tmux.h,v 1.139 2009/10/13 15:38:37 nicm Exp $ */
a132 1

@


1.139
log
@Move lines into the history when scrolling even if the scroll region is not
the entire screen.

Allows ircII users to see history, prompted by naddy.
@
text
@d1 1
a1 1
/* $OpenBSD: tmux.h,v 1.138 2009/10/13 13:45:56 nicm Exp $ */
d973 5
@


1.138
log
@Add mode keys to move the cursor to the top, middle and bottom of the screen.
H/M/L in vi mode and M-R/M-r in emacs (bottom of screen not bound in emacs).
@
text
@d1 1
a1 1
/* $OpenBSD: tmux.h,v 1.137 2009/10/12 17:19:47 nicm Exp $ */
d1595 3
a1599 1
void	 grid_scroll_line(struct grid *);
@


1.137
log
@When drawing lines that have wrapped naturally, don't force a newline but
permit them to wrap naturally again. This allows terminals that use this to
guess where lines start and end for eg mouse selecting (like xterm) to work
correctly.

This was another long-standing issue raised by several people over the last
while.

Thanks to martynas@@ for much testing. This was not trivial to get right so
bringing it in for wider testing and adn to fix any further glitches in-tree.
@
text
@d1 1
a1 1
/* $OpenBSD: tmux.h,v 1.136 2009/10/12 16:59:55 nicm Exp $ */
d400 1
d410 1
d423 1
@


1.136
log
@When backspace is received at the beginning of a line and the previous line was
wrapped, move the cursor back up to the end of the previous line.

Another one of the forgotten persons requested this quite a while ago (I need
to start noting names on todo items...) when it was quite hard to
implement. Now it is easy and I don't see it can do any harm, so hey presto...
@
text
@d1 1
a1 1
/* $OpenBSD: tmux.h,v 1.135 2009/10/12 13:01:18 nicm Exp $ */
d1669 1
@


1.135
log
@Use relative cursor movement instead of absolute when possible and when
supported by the terminal to reduce the size of the output data (generally
about 10-20%).
@
text
@d1 1
a1 1
/* $OpenBSD: tmux.h,v 1.134 2009/10/12 09:29:58 nicm Exp $ */
d1649 1
@


1.134
log
@Similarly add a tty_cursor_pane function to tidy up most of the calls.
@
text
@d1 1
a1 1
/* $OpenBSD: tmux.h,v 1.133 2009/10/12 09:16:59 nicm Exp $ */
d198 2
d202 2
d205 2
d215 2
d243 1
a244 1
	TTYC_KF2,	/* key_f2, k2 */
d273 1
@


1.133
log
@_absolute is redundant, just use tty_region.
@
text
@d1 1
a1 1
/* $OpenBSD: tmux.h,v 1.132 2009/10/12 09:09:35 nicm Exp $ */
d1252 2
a1253 1
void	tty_cursor(struct tty *, u_int, u_int, u_int, u_int);
@


1.132
log
@Cleanup: use two functions for region setting, one for absolute and one inside
pane.
@
text
@d1 1
a1 1
/* $OpenBSD: tmux.h,v 1.131 2009/10/11 10:04:27 nicm Exp $ */
d1251 1
a1251 1
void	tty_region_absolute(struct tty *, u_int, u_int);
@


1.131
log
@Add a pipe-pane command to allow a pane to be piped to a shell command, for
example:

	pipe-pane 'cat >~/out'

No arguments stops outputing and closes the pipe; the -o flag toggles a pipe
and on and off (useful for key bindings).

Suggested by espie@@.
@
text
@d1 1
a1 1
/* $OpenBSD: tmux.h,v 1.130 2009/10/11 07:20:16 nicm Exp $ */
d1250 2
a1251 1
void	tty_region(struct tty *, u_int, u_int, u_int);
@


1.130
log
@Collect status from dead jobs and don't invoke the callback until both
all input (the socket is closed) and status is available.
@
text
@d1 1
a1 1
/* $OpenBSD: tmux.h,v 1.129 2009/10/11 07:01:10 nicm Exp $ */
d718 4
d1401 1
@


1.129
log
@Clean up by introducing a wrapper struct for mouse clicks rather than passing
three u_chars around.

As a side-effect this fixes incorrectly rejecting high cursor positions
(because it was comparing them as signed char), reported by Tom Doherty.
@
text
@d1 1
a1 1
/* $OpenBSD: tmux.h,v 1.128 2009/10/10 18:42:14 nicm Exp $ */
d570 1
d580 3
@


1.128
log
@Put all jobs on a global all_jobs list and use that in server.c instead of
running through all the clients.
@
text
@d1 1
a1 1
/* $OpenBSD: tmux.h,v 1.127 2009/10/10 17:19:38 nicm Exp $ */
d677 1
d684 1
a684 1
	    	    struct client *, u_char, u_char, u_char);
d955 7
d1296 1
a1296 1
int	tty_keys_next(struct tty *, int *, u_char *);
d1553 1
a1553 1
void	 input_mouse(struct window_pane *, u_char, u_char, u_char);
d1716 1
a1716 1
    		     struct client *, u_char, u_char, u_char);
@


1.127
log
@Split list-panes off from list-windows.
@
text
@d1 1
a1 1
/* $OpenBSD: tmux.h,v 1.126 2009/10/10 15:03:01 nicm Exp $ */
d581 1
d584 1
d1204 1
a1204 1
extern struct jobs jobs_tree;
@


1.126
log
@Rather than running status-left, status-right and window title #() with popen
immediately every redraw, queue them up and run them in the background,
starting each once every status-interval. The actual status line uses the
output from the last run.

This brings several advantages:

- tmux itself may be called from inside #() without causing the server to hang;
- likewise, sleep or similar doesn't cause the server to block;
- commands aren't run excessively often when redrawing;
- commands shared by status-left and status-right, or used multiple times, will
  only be run once.

run-shell and if-shell still use system()/popen() but will be changed over to
use this too later.
@
text
@d1 1
a1 1
/* $OpenBSD: tmux.h,v 1.125 2009/10/10 14:51:16 nicm Exp $ */
d1370 1
@


1.125
log
@New option, mouse-select-pane. If on, the mouse may be used to select the
current pane.

Suggested by sthen@@ and also by someone else ages ago who I have forgotten.
@
text
@d1 1
a1 1
/* $OpenBSD: tmux.h,v 1.124 2009/10/10 10:02:48 nicm Exp $ */
d566 18
a962 1
	struct timeval	 status_timer;
d965 2
d1201 14
d1521 1
a1521 1
char	*status_replace(struct session *, const char *, time_t);
@


1.124
log
@Add "grouped sessions" which have independent name, options, current window and
so on but where the linked windows are synchronized (ie creating, killing
windows and so on are mirrored between the sessions). A grouped session may be
created by passing -t to new-session.

Had this around for a while, tested by a couple of people.
@
text
@d1 1
a1 1
/* $OpenBSD: tmux.h,v 1.123 2009/10/10 09:46:11 nicm Exp $ */
d1651 1
@


1.123
log
@Support for individual session idle time locking. May be enabled by turning off
the lock-server option (it is on by default). When this is off, each session
locks when it has been idle for the lock-after-time setting. When on, the
entire server locks when ALL sessions have been idle for their individual
lock-after-time settings.

This replaces one global-only option (lock-after-time) with another
(lock-server), but the default behaviour is usually preferable so there don't
seem to be many alternatives.

Diff/idea largely from Thomas Adam, tweaked by me.
@
text
@d1 1
a1 1
/* $OpenBSD: tmux.h,v 1.122 2009/10/09 07:33:12 nicm Exp $ */
d742 1
a742 1
	SLIST_ENTRY(winlink) sentry;
d745 1
a745 1
SLIST_HEAD(winlink_stack, winlink);
d800 7
d834 2
d1468 1
d1470 1
d1478 1
a1478 1
int	 server_link_window(
d1481 1
d1734 1
d1755 7
@


1.122
log
@The UTF-8 detection idea doesn't work and I am reasonably happy with the
current methods, so remove the (already #ifdef 0'd) code.
@
text
@d1 1
a1 1
/* $OpenBSD: tmux.h,v 1.121 2009/10/06 07:19:32 nicm Exp $ */
d803 1
a1120 1
extern time_t	 server_activity;
@


1.121
log
@Remove scroll mode which is now redundant, copy mode should be used instead.

The = key binding now does nothing.
@
text
@d1 1
a1 1
/* $OpenBSD: tmux.h,v 1.120 2009/10/06 07:09:00 nicm Exp $ */
a1201 1
void	tty_detect_utf8(struct tty *);
@


1.120
log
@Make C-Up and C-Down in copy mode scroll the screen up and down one line
without moving the cursor, like Up and Down in scroll mode (which will shortly
disappear).
@
text
@d1 1
a1 1
/* $OpenBSD: tmux.h,v 1.119 2009/10/05 18:30:54 nicm Exp $ */
a1350 1
extern const struct cmd_entry cmd_scroll_mode_entry;
a1701 4

/* window-scroll.c */
extern const struct window_mode window_scroll_mode;
void 		 window_scroll_pageup(struct window_pane *);
@


1.119
log
@If no target client is specified to commands which accept one, try to guess the
current client, in a similar manner to how sessions already work: if the
current session can be established and has only one client, use that; otherwise
use the most recently created client.
@
text
@d1 1
a1 1
/* $OpenBSD: tmux.h,v 1.118 2009/09/24 14:17:09 nicm Exp $ */
d405 2
@


1.118
log
@New lock-client and lock-session commands to lock an individual client or all
clients attached to a session respectively.
@
text
@d1 1
a1 1
/* $OpenBSD: tmux.h,v 1.117 2009/09/23 14:42:48 nicm Exp $ */
d925 1
@


1.117
log
@Remove PROMPT_HIDDEN code which is now unused.
@
text
@d1 1
a1 1
/* $OpenBSD: tmux.h,v 1.116 2009/09/23 12:03:31 nicm Exp $ */
d1329 1
d1331 1
d1462 2
@


1.116
log
@Support -c like sh(1) to execute a command, useful when tmux is a login
shell. Suggested by halex@@.

This includes another protocol version increase (the last for now) so again
restart the tmux server before upgrading.
@
text
@d1 1
a1 1
/* $OpenBSD: tmux.h,v 1.115 2009/09/23 06:18:48 nicm Exp $ */
d961 1
a961 2
#define PROMPT_HIDDEN 0x1
#define PROMPT_SINGLE 0x2
@


1.115
log
@Remove the internal tmux locking and instead detach each client and run the
command specified by a new option "lock-command" (by default "lock -np") in
each client.

This means each terminal has to be unlocked individually but simplifies the
code and allows the system password to be used to unlock.

Note that the set-password command is gone, so it will need to be removed from
configuration files, and the -U command line flag has been removed.

This is the third protocol version change so again it is best to stop the tmux
server before upgrading.
@
text
@d1 1
a1 1
/* $OpenBSD: tmux.h,v 1.114 2009/09/23 06:12:58 nicm Exp $ */
d22 1
a22 1
#define PROTOCOL_VERSION 4
d133 1
d312 2
a313 1
	MSG_LOCK
d351 4
@


1.114
log
@Trim some code by moving the ioctl(TIOCGWINSZ) after SIGWINCH from the client
into the server.

This is another (the second of four) protocol version changes coming this
morning, so again the server should be killed before upgrading.
@
text
@d1 1
a1 1
/* $OpenBSD: tmux.h,v 1.113 2009/09/23 06:05:02 nicm Exp $ */
d22 1
a22 1
#define PROTOCOL_VERSION 3
a306 1
	MSG_UNLOCK,
d309 3
a311 1
	MSG_ENVIRON
d343 2
a344 2
struct msg_unlock_data {
	char	       	pass[PASS_MAX];
a1111 5
extern int	 server_locked;
extern struct passwd *server_locked_pw;
extern u_int	 password_failures;
extern time_t	 password_backoff;
extern char	*server_password;
d1178 1
a1351 1
extern const struct cmd_entry cmd_set_password_entry;
@


1.113
log
@Don't attempt to open() the tty path, rely on the client sending its stdin fd
with imsg and fatal if it doesn't, then set the FD_CLOEXEC flag in tty_init
instead of tty_open to prevent them leaking into child processes if any are
created between the two calls.

This bumps the protocol version, so the tmux server should be killed before
upgrading.
@
text
@d1 1
a1 1
/* $OpenBSD: tmux.h,v 1.112 2009/09/22 12:38:10 nicm Exp $ */
d22 1
a22 1
#define PROTOCOL_VERSION 2
a339 8

	u_int		sx;
	u_int		sy;
};

struct msg_resize_data {
	u_int		sx;
	u_int		sy;
d1194 1
@


1.112
log
@Permit multiple prefix keys to be defined, separated by commas, for example:

set -g prefix ^a,^b

Any key in the list acts as the prefix. The send-prefix command always sends
the first key in the list.
@
text
@d1 1
a1 1
/* $OpenBSD: tmux.h,v 1.111 2009/09/21 14:56:03 nicm Exp $ */
d22 1
a22 1
#define PROTOCOL_VERSION 1
a330 2
	char		tty[TTY_NAME_MAX];

d1201 1
a1201 1
void	tty_init(struct tty *, int, char *, char *);
@


1.111
log
@Use option print function for info messages as well.
@
text
@d1 1
a1 1
/* $OpenBSD: tmux.h,v 1.110 2009/09/21 14:46:47 nicm Exp $ */
d547 1
d552 3
d564 3
d1095 1
a1095 1
		SET_OPTION_KEY,
d1175 3
d1258 1
a1258 1
void	set_option_key(struct cmd_ctx *,
@


1.110
log
@Move common code from show-options and show-window-options into a function.
@
text
@d1 1
a1 1
/* $OpenBSD: tmux.h,v 1.109 2009/09/21 07:00:09 nicm Exp $ */
d1162 1
a1162 1
void printflike3 options_set_string(
d1165 2
a1166 1
void	options_set_number(struct options *, const char *, long long);
@


1.109
log
@Drop tiny union from option struct.
@
text
@d1 1
a1 1
/* $OpenBSD: tmux.h,v 1.108 2009/09/21 06:55:06 nicm Exp $ */
d1241 2
@


1.108
log
@Key options were implemented as a number so these struct members are unused.
@
text
@d1 1
a1 1
/* $OpenBSD: tmux.h,v 1.107 2009/09/20 19:15:02 nicm Exp $ */
d548 3
a550 4
	union {
		char	*string;
		long long number;
	} value;
@


1.107
log
@run-shell command to run a shell command without opening a window, sending
stdout to output mode.
@
text
@d1 1
a1 1
/* $OpenBSD: tmux.h,v 1.106 2009/09/20 17:27:18 nicm Exp $ */
a546 1
		OPTIONS_KEY,
a550 1
		int	 key;
@


1.106
log
@Move some common and untidy code for window link/unlink into generic functions
instead of duplicating it in move/link window..
@
text
@d1 1
a1 1
/* $OpenBSD: tmux.h,v 1.105 2009/09/16 12:35:04 nicm Exp $ */
d1341 1
@


1.105
log
@Rather than constructing an entire termios struct from ttydefaults.h, just let
forkpty do it and then alter the bits that should be changed after fork. A
little neater and more portable.
@
text
@d1 1
a1 1
/* $OpenBSD: tmux.h,v 1.104 2009/09/14 11:25:35 nicm Exp $ */
d1459 3
@


1.104
log
@Nuke unused server_client_index function, pointed out by martynas@@.
@
text
@d1 1
a1 1
/* $OpenBSD: tmux.h,v 1.103 2009/09/12 13:01:19 nicm Exp $ */
d818 1
a818 1
	struct termios   tio;
@


1.103
log
@Tidy some common code for destroying sessions into a new function.
@
text
@d1 1
a1 1
/* $OpenBSD: tmux.h,v 1.102 2009/09/10 17:16:24 nicm Exp $ */
a1437 1
int	 server_client_index(struct client *);
@


1.102
log
@Permit options such as status-bg to be configured using the entire 256 colour
palette by setting "colour0" to "colour255".
@
text
@d1 1
a1 1
/* $OpenBSD: tmux.h,v 1.101 2009/09/07 21:01:50 nicm Exp $ */
d1460 1
@


1.101
log
@Reference count clients and sessions rather than relying on a saved index for
cmd-choose-*.
@
text
@d1 1
a1 1
/* $OpenBSD: tmux.h,v 1.100 2009/09/07 18:50:45 nicm Exp $ */
d1489 3
a1491 1
const char *colour_tostring(u_char);
@


1.100
log
@Give each paste buffer a size member instead of requiring them to be
zero-terminated.
@
text
@d1 1
a1 1
/* $OpenBSD: tmux.h,v 1.99 2009/09/07 10:49:32 nicm Exp $ */
d815 1
d821 2
d945 1
d970 2
d1437 1
d1712 1
@


1.99
log
@Permit embedded colour and attributes in status-left and status-right using new
#[] special characters, for example #[fg=red,bg=blue,blink].
@
text
@d1 1
a1 1
/* $OpenBSD: tmux.h,v 1.98 2009/09/02 20:15:49 nicm Exp $ */
d775 1
d1261 2
a1262 2
void		 paste_add(struct paste_stack *, char *, u_int);
int		 paste_replace(struct paste_stack *, u_int, char *);
@


1.98
log
@That was the wrong fix. MSG_ERROR should set the error and the client should
use the error and exit on MSG_EXIT (it was being handled in the default
case). Undo the last change, move the errstr check into the MSG_EXIT case, and
add a comment.
@
text
@d1 1
a1 1
/* $OpenBSD: tmux.h,v 1.97 2009/09/02 20:00:10 nicm Exp $ */
d1536 3
d1546 2
@


1.97
log
@Set exittype for error exit as well as the error string.
@
text
@d1 1
a1 1
/* $OpenBSD: tmux.h,v 1.96 2009/09/02 17:34:57 nicm Exp $ */
d976 1
a976 2
		CCTX_SHUTDOWN,
		CCTX_ERROR
@


1.96
log
@Accept -l to make it easier for people who use tmux as a login shell to use
$SHELL. Originally from martynas@@, tweaked by me.
@
text
@d1 1
a1 1
/* $OpenBSD: tmux.h,v 1.95 2009/09/02 16:38:35 nicm Exp $ */
d977 1
@


1.95
log
@When incorrect passwords are entered, behave similarly to login(1) and backoff
for a bit. Based on a diff from martynas@@.
@
text
@d1 1
a1 1
/* $OpenBSD: tmux.h,v 1.94 2009/09/02 06:33:20 nicm Exp $ */
d1120 1
@


1.94
log
@Add a transpose-chars command in edit mode (C-t in emacs mode only). From Kalle
Olavi Niemitalo.
@
text
@d1 1
a1 1
/* $OpenBSD: tmux.h,v 1.93 2009/09/01 13:09:50 nicm Exp $ */
d1111 1
d1113 1
@


1.93
log
@When using tmux as a login shell, there is currently no way to specify a shell
to be used as a login shell inside tmux, so add a default-shell session option.
This sets the shell invoked as a login shell when the default-command option is
empty.

The default option value is whichever of $SHELL, getpwuid(getuid())'s pw_shell
or /bin/sh is valid first.

Based on a diff from martynas@@, changed by me to be a session option rather
than a window option.
@
text
@d1 1
a1 1
/* $OpenBSD: tmux.h,v 1.92 2009/08/31 20:46:19 nicm Exp $ */
d382 1
@


1.92
log
@Add a new display-panes command, with two options (display-panes-colour and
display-panes-time), which displays a visual indication of the number of each
pane.
@
text
@d1 1
a1 1
/* $OpenBSD: tmux.h,v 1.91 2009/08/25 12:18:51 nicm Exp $ */
d678 1
d1121 3
a1588 1
const char	*window_default_command(void);
d1606 2
a1607 2
    		     struct environ *, struct termios *, u_int, u_int, u_int,
		     char **);
d1620 2
a1621 1
		     const char *, struct environ *, struct termios *, char **);
@


1.91
log
@Add a choose-client command and extend choose-{session,window} to accept a
template. After a choice is made, %% (or %1) in the template is replaced by the
name of the session, window or client suitable for -t and the result executed
as a command. So, for example, "choose-window "killw -t '%%'"" will kill the
selected window.

The defaults if no template is given are (as now) select-window for
choose-window, switch-client for choose-session, and detach-client for
choose-client (now bound to D).
@
text
@d1 1
a1 1
/* $OpenBSD: tmux.h,v 1.90 2009/08/24 08:03:11 nicm Exp $ */
d938 1
d941 2
d1170 1
d1256 1
d1293 1
d1444 2
@


1.90
log
@gcc2 doesn't understand attributes on function pointers.
@
text
@d1 1
a1 1
/* $OpenBSD: tmux.h,v 1.89 2009/08/23 17:29:51 nicm Exp $ */
d1271 1
d1276 1
@


1.89
log
@When using source-file, run the commands in the context of the source-file
command rather than with no context. This makes things like attach work from a
file.
@
text
@d1 1
a1 1
/* $OpenBSD: tmux.h,v 1.88 2009/08/23 16:45:00 nicm Exp $ */
d993 2
d998 5
@


1.88
log
@The cursession member in struct cmd_ctx is always either curclient->session or
NULL when curclient is also NULL, so just eliminate it.
@
text
@d1 1
a1 1
/* $OpenBSD: tmux.h,v 1.87 2009/08/19 10:39:50 nicm Exp $ */
d1112 1
a1112 1
int		 load_cfg(const char *, char **x);
@


1.87
log
@Extend command-prompt with a -p option which is a comma-separated list of one
or more prompts to present in order.

The responses to the prompt are replaced in the template string: %% are
replaced in order, so the first prompt replaces the first %%, the second
replaces the second, and so on. In addition, %1 up to %9 are replaced with the
responses to the first the ninth prompts

The default template is "%1" so the response to the first prompt is processed
as a command.

Note that this changes the behaviour for %% so if there is only one prompt,
only the first %% will be replaced. Templates such as "neww -n '%%' 'ssh %%'"
should be changed to "neww -n '%1' 'ssh %1'".

From Tiago Cunha.
@
text
@d1 1
a1 1
/* $OpenBSD: tmux.h,v 1.86 2009/08/18 21:41:13 nicm Exp $ */
a989 2

	struct session *cursession;
@


1.86
log
@Instead of just checking for an empty buffer, which may not be the case if
there is unconsumed data, save the previous size and use it instead. This means
that activity monitoring should work in this (unlikely) event.

Also remove a debugging statement that no longer seems necessary.
@
text
@d1 1
a1 1
/* $OpenBSD: tmux.h,v 1.85 2009/08/18 14:48:42 nicm Exp $ */
d1443 1
@


1.85
log
@Tag a few missed printf-like functions and fix a missing "%s".
@
text
@d1 1
a1 1
/* $OpenBSD: tmux.h,v 1.84 2009/08/18 07:23:43 nicm Exp $ */
d620 1
@


1.84
log
@Add a "delete line" key when editing in the status line or the search up/down
prompt. C-u with emacs keys, d with vi.
@
text
@d1 1
a1 1
/* $OpenBSD: tmux.h,v 1.83 2009/08/18 07:08:26 nicm Exp $ */
d994 3
a996 3
	void		(*print)(struct cmd_ctx *, const char *, ...);
	void		(*info)(struct cmd_ctx *, const char *, ...);
	void		(*error)(struct cmd_ctx *, const char *, ...);
d1725 2
a1726 2
__dead void	 log_fatal(const char *, ...);
__dead void	 log_fatalx(const char *, ...);
@


1.83
log
@Add (naive) searching and goto line in copy mode. Searching is C-r and C-s with
emacs keys, / and ? with vi; n repeats the search again with either key
set. All searching wraps the top/bottom. Goto line is g for both emacs and vi.

The search prompts don't have full line editing, just simple append and delete
characters.

Also sort the mode keys list in tmux.1.
@
text
@d1 1
a1 1
/* $OpenBSD: tmux.h,v 1.82 2009/08/13 22:32:18 nicm Exp $ */
d372 1
@


1.82
log
@vi(1)-style half page scroll in copy and scroll modes. Move the vi full page
scroll key to C-b instead of C-u and use C-u/C-d for half page scrolling with
vi keys. In emacs mode, half page scrolling is bound to M-Up and M-Down.

Suggested by merdely (about a year ago :-)).
@
text
@d1 1
a1 1
/* $OpenBSD: tmux.h,v 1.81 2009/08/13 20:11:58 nicm Exp $ */
d397 1
d406 3
@


1.81
log
@Add a base-index session option to specify the first index checked when looking
for an index for a new window.
@
text
@d1 1
a1 1
/* $OpenBSD: tmux.h,v 1.80 2009/08/13 19:04:00 nicm Exp $ */
d391 1
a392 1
	MODEKEYCOPY_BACKTOINDENTATION,
d397 2
@


1.80
log
@When creating a new session from the command-line where there is an external
terminal, copy the termios(4) special characters and use them for new windows
created in the new session. Suggested by Theo.
@
text
@d1 1
a1 1
/* $OpenBSD: tmux.h,v 1.79 2009/08/12 09:41:59 nicm Exp $ */
d1568 1
a1568 1
int		 winlink_next_index(struct winlinks *);
d1673 2
a1674 1
    		     struct environ *, struct termios *, u_int, u_int, char **);
@


1.79
log
@A tty context must not be modified as it may be reused to update multiple
clients, so make it const.

Also fix an actual modification which caused a hang when a session was
connected to multiple terminals at least one of which was missing ich/ich1.
@
text
@d1 1
a1 1
/* $OpenBSD: tmux.h,v 1.78 2009/08/11 21:28:11 nicm Exp $ */
d806 2
d1579 2
a1580 1
    		     struct environ *, u_int, u_int, u_int, char **);
d1592 2
a1593 2
int		 window_pane_spawn(struct window_pane *,
		     const char *, const char *, struct environ *, char **);
d1672 2
a1673 2
struct session	*session_create(const char *, const char *,
    		     const char *, struct environ *, u_int, u_int, char **);
@


1.78
log
@Have the client pass its stdin fd to the server when identifying itself and
have the server use that rather than reopening the tty. If the fd isn't given,
use the old behaviour (so no need for a version change).

This allows tmux to be used as the shell, so also change so that when working
out the command to execute if default-command is empty (the default), tmux will
try not execute itself.
@
text
@d1 1
a1 1
/* $OpenBSD: tmux.h,v 1.77 2009/08/11 20:29:04 nicm Exp $ */
d1171 17
a1187 16
void	tty_write(void (*)(struct tty *, struct tty_ctx *), struct tty_ctx *);
void	tty_cmd_alignmenttest(struct tty *, struct tty_ctx *);
void	tty_cmd_cell(struct tty *, struct tty_ctx *);
void	tty_cmd_clearendofline(struct tty *, struct tty_ctx *);
void	tty_cmd_clearendofscreen(struct tty *, struct tty_ctx *);
void	tty_cmd_clearline(struct tty *, struct tty_ctx *);
void	tty_cmd_clearscreen(struct tty *, struct tty_ctx *);
void	tty_cmd_clearstartofline(struct tty *, struct tty_ctx *);
void	tty_cmd_clearstartofscreen(struct tty *, struct tty_ctx *);
void	tty_cmd_deletecharacter(struct tty *, struct tty_ctx *);
void	tty_cmd_deleteline(struct tty *, struct tty_ctx *);
void	tty_cmd_insertcharacter(struct tty *, struct tty_ctx *);
void	tty_cmd_insertline(struct tty *, struct tty_ctx *);
void	tty_cmd_linefeed(struct tty *, struct tty_ctx *);
void	tty_cmd_utf8character(struct tty *, struct tty_ctx *);
void	tty_cmd_reverseindex(struct tty *, struct tty_ctx *);
@


1.77
log
@Add a TTY_OPENED flag and tidy a little.
@
text
@d1 1
a1 1
/* $OpenBSD: tmux.h,v 1.76 2009/08/11 19:32:25 nicm Exp $ */
d1161 1
a1161 1
void	tty_init(struct tty *, char *, char *);
@


1.76
log
@Drop the no_stop argument to tty_close and tty_free in favour of a flag in the
tty struct.
@
text
@d1 1
a1 1
/* $OpenBSD: tmux.h,v 1.75 2009/08/11 17:18:35 nicm Exp $ */
d872 1
@


1.75
log
@Switch tmux to use imsg. This is the last major change to make the
client-server protocol more resilient and make the protocol versioning work
properly. In future, the only things requiring a protocol version bump will be
changes in the message structs, and (when both client and server have this
change) mixing different versions should nicely report an error message.

As a side effect this also makes the code tidier, fixes a problem with the way
errors reported during server startup were handled, and supports fd passing
(which will be used in future).

Looked over by eric@@, thanks.

Please note that mixing a client with this change with an older server or vice
versa may cause tmux to crash or hang - tmux should be completely exited before
upgrading.
@
text
@d1 1
a1 1
/* $OpenBSD: tmux.h,v 1.74 2009/08/11 12:53:37 nicm Exp $ */
d871 1
d1168 2
a1169 2
void	tty_close(struct tty *, int);
void	tty_free(struct tty *, int);
@


1.74
log
@Add flags for 1+2 and 2 arguments to the generic target code, use it for
cmd-set-environment/option/window-option and remove the generic options
parsing.
@
text
@d1 1
a1 1
/* $OpenBSD: tmux.h,v 1.73 2009/08/08 21:52:43 nicm Exp $ */
d22 1
a22 1
#define PROTOCOL_VERSION -15
d28 1
d41 1
d308 1
d314 1
a314 1
 * Message header and data. 
a316 3
 *
 * Changing sizeof (struct hdr) or sizeof (struct msg_identify_data) will make
 * the tmux client hang even if the protocol version is bumped.
a317 5
struct hdr {
	enum msgtype	type;
	size_t		size;
};

a331 1
	int	        version;
d905 1
a905 3
	int		 fd;
	struct buffer	*in;
	struct buffer	*out;
d953 1
a953 3
	int		 srv_fd;
	struct buffer	*srv_in;
	struct buffer	*srv_out;
@


1.73
log
@Infrastructure and commands to manage the environment for processes started
within tmux.

There is a global environment, copied from the external environment when the
server is started and each sesssion has an (initially empty) session
environment which overrides it.

New commands set-environment and show-environment manipulate or display the
environments.

A new session option, update-environment, is a space-separated list of
variables which are updated from the external environment into the session
environment every time a new session is created - the default is DISPLAY.
@
text
@d1 1
a1 1
/* $OpenBSD: tmux.h,v 1.72 2009/08/08 15:57:49 nicm Exp $ */
d1013 5
a1017 3
#define CMD_ARG1 0x4
#define CMD_ARG01 0x8
#define CMD_SENDENVIRON 0x10
d1037 1
d1045 1
d1053 1
a1053 7
};

struct cmd_option_data {
	uint64_t chflags;
	char	*target;
	char	*option;
	char	*value;
a1373 8
#define CMD_OPTION_PANE_USAGE "[-t target-pane] option [value]"
#define CMD_OPTION_WINDOW_USAGE "[-t target-window] option [value]"
#define CMD_OPTION_SESSION_USAGE "[-t target-session] option [value]"
#define CMD_OPTION_CLIENT_USAGE "[-t target-client] option [value]"
void	cmd_option_init(struct cmd *, int);
int	cmd_option_parse(struct cmd *, int, char **, char **);
void	cmd_option_free(struct cmd *);
size_t	cmd_option_print(struct cmd *, char *, size_t);
@


1.72
log
@Add a flags member to the grid_line struct and use it to differentiate lines
wrapped at the screen edge from those terminated by a newline. Then use this
when copying to combine wrapped lines together into one.
@
text
@d1 1
a1 1
/* $OpenBSD: tmux.h,v 1.71 2009/08/08 13:29:27 nicm Exp $ */
d42 1
d73 1
d307 1
d362 4
d775 9
d811 2
d915 2
d1015 1
d1098 1
d1148 12
d1322 1
d1327 1
d1423 1
a1423 1
const char **server_fill_environ(struct session *);
d1593 2
a1594 2
struct window	*window_create(const char *, const char *,
		     const char *, const char **, u_int, u_int, u_int, char **);
d1607 1
a1607 1
		     const char *, const char *, const char **, char **);
d1687 1
a1687 1
    		     const char *, u_int, u_int, char **);
@


1.71
log
@Change the way the grid is stored, previously it was:

- a two-dimensional array of cells;
- a two-dimensional array of utf8 data;
- an array of line lengths.

Now it is a single array of a new struct grid_line each of which represents a
line and containts the length and an array of cells and an array of utf8 data.

This will make it easier to add additional per-line members, such as flags.
@
text
@d1 1
a1 1
/* $OpenBSD: tmux.h,v 1.70 2009/08/07 15:39:10 nicm Exp $ */
d487 3
d513 2
d1512 1
a1512 1
void	 screen_write_linefeed(struct screen_write_ctx *);
@


1.70
log
@If there is an error in the configuration file, don't just exit(1) as this can
cause the client to hang. Instead, send the error message, then mark the client
as bad and start a normal shutdown so the server exits once the error is
written.

This also allows some code duplicating daemon(3) to be trimmed and logging to
begin earlier.

Prompted by Theo noticing the behaviour on error wasn't documented.
@
text
@d1 1
a1 1
/* $OpenBSD: tmux.h,v 1.69 2009/08/07 00:12:13 nicm Exp $ */
d503 9
d523 1
a523 5
	u_int  *size;
	struct grid_cell **data;

	u_int  *usize;
 	struct grid_utf8 **udata;
@


1.69
log
@Using the alternative screen (smcup/rmcup) should also preserve the current
colours and attributes. Found thanks to a report from Taylor Venable.

While here also nuke a couple of extra blank lines.
@
text
@d1 1
a1 1
/* $OpenBSD: tmux.h,v 1.68 2009/08/04 18:45:57 nicm Exp $ */
d903 1
@


1.68
log
@Add a -a flag to set-option and set-window-option to append to an existing
string value, useful for terminal-overrides.
@
text
@d1 1
a1 1
/* $OpenBSD: tmux.h,v 1.67 2009/08/03 14:10:54 nicm Exp $ */
a604 1

d676 1
@


1.67
log
@Add a terminal-overrides session option allowing individual terminfo(5) entries
to be overridden. The 88col/256col checks are now moved into the default
setting and out of the code.

Also remove a couple of old workarounds for xterm and rxvt which are no longer
necessary (tmux can emulate them if missing).
@
text
@d1 1
a1 1
/* $OpenBSD: tmux.h,v 1.66 2009/07/30 16:32:12 nicm Exp $ */
d1175 1
a1175 1
	    struct options *, const struct set_option_entry *, char *);
d1329 4
a1332 4
#define CMD_OPTION_PANE_USAGE "[-gu] [-t target-pane] option [value]"
#define CMD_OPTION_WINDOW_USAGE "[-gu] [-t target-window] option [value]"
#define CMD_OPTION_SESSION_USAGE "[-gu] [-t target-session] option [value]"
#define CMD_OPTION_CLIENT_USAGE "[-gu] [-t target-client] option [value]"
@


1.66
log
@There aren't many client message types or code to handle them so get rid of the
lookup table and use a switch, merge the tiny handler functions into it, and
move the whole lot to client.c.

Also change client_msg_dispatch to consume as many messages as possible and
move the call to it to the right place so it checks for signals afterwards.

Prompted by suggestions from eric@@.
@
text
@d1 1
a1 1
/* $OpenBSD: tmux.h,v 1.65 2009/07/30 13:45:56 nicm Exp $ */
d1133 1
a1133 1
int	tty_open(struct tty *, char **);
d1156 1
a1156 1
struct tty_term *tty_term_find(char *, int, char **);
@


1.65
log
@Merge pane number into the target specification for pane commands. Instead of
using -p index, a target pane is now addressed with the normal -t window form
but suffixed with a period and a pane index, for example :0.2 or
mysess:mywin.1. An unadorned number such as -t 1 is tried as a pane index in
the current window, if that fails the same rules are followed as for a target
window and the current pane in that window used.

As a side-effect this now means that swap-pane can swap panes between different
windows.

Note that this changes the syntax of the break-pane, clear-history, kill-pane,
resize-pane, select-pane and swap-pane commands.
@
text
@d1 1
a1 1
/* $OpenBSD: tmux.h,v 1.64 2009/07/29 14:17:26 nicm Exp $ */
a1340 2

/* client-msg.c */
d1346 1
@


1.64
log
@Rename struct hdrtype to msgtype which is a better name and can be used even
when struct hdr disappears.
@
text
@d1 1
a1 1
/* $OpenBSD: tmux.h,v 1.63 2009/07/28 17:05:10 nicm Exp $ */
a1025 7
struct cmd_pane_data {
	uint64_t chflags;
	char	*target;
	char	*arg;
	int	 pane;
};

d1218 2
d1305 1
d1313 1
d1321 1
d1329 1
a1336 7
#define CMD_PANE_WINDOW_USAGE "[-t target-window] [-p pane-index]"
#define CMD_PANE_SESSION_USAGE "[-t target-session] [-p pane-index]"
#define CMD_PANE_CLIENT_USAGE "[-t target-client] [-p pane-index]"
void	cmd_pane_init(struct cmd *, int);
int	cmd_pane_parse(struct cmd *, int, char **, char **);
void	cmd_pane_free(struct cmd *);
size_t	cmd_pane_print(struct cmd *, char *, size_t);
@


1.63
log
@Final pieces of mode key rebinding: bind-key and unbind-key now accept a -t
argument to modify a table.
@
text
@d1 1
a1 1
/* $OpenBSD: tmux.h,v 1.62 2009/07/28 07:03:32 nicm Exp $ */
d290 1
a290 1
enum hdrtype {
d316 1
a316 1
	enum hdrtype	type;
d1354 1
a1354 1
void	 client_write_server(struct client_ctx *, enum hdrtype, void *, size_t);
d1388 1
a1388 1
             struct client *, enum hdrtype, const void *, size_t);
d1390 1
a1390 1
             struct session *, enum hdrtype, const void *, size_t);
@


1.62
log
@Next step towards customisable mode keys: build each default table of keys into
a named tree on start and use that for lookups. Also add command to string
translation tables and modify list-keys to show the the mode key bindings (new
-t argument).
@
text
@d1 1
a1 1
/* $OpenBSD: tmux.h,v 1.61 2009/07/28 06:48:44 nicm Exp $ */
d1101 2
@


1.61
log
@If select-layout is not given an argument, repply the last layout used in the
window, if any.
@
text
@d1 1
a1 1
/* $OpenBSD: tmux.h,v 1.60 2009/07/27 20:36:13 nicm Exp $ */
d359 1
a359 1
/* Editing keys. */
d407 1
a417 1

d420 2
d423 2
a424 2
	const struct mode_key_entry *table;
	int	mode;
d429 25
d1091 13
a1103 8
extern const struct mode_key_entry mode_key_vi_edit[];
extern const struct mode_key_entry mode_key_vi_choice[];
extern const struct mode_key_entry mode_key_vi_copy[];
extern const struct mode_key_entry mode_key_emacs_edit[];
extern const struct mode_key_entry mode_key_emacs_choice[];
extern const struct mode_key_entry mode_key_emacs_copy[];
void		 mode_key_init(
    		     struct mode_key_data *, const struct mode_key_entry *);
@


1.60
log
@Remove an unused entry in the mode keys command enum and rename
MODEKEYCOPY_QUIT to _CANCEL to match the others.
@
text
@d1 1
a1 1
/* $OpenBSD: tmux.h,v 1.59 2009/07/27 19:29:35 nicm Exp $ */
d666 1
a666 1
	u_int		 layout;
@


1.59
log
@Change mode key bindings from big switches into a set of tables. Rather than
lumping them all together, split editing keys from those used in choice/more
mode and those for copy/scroll mode.

Tidier and clearer, and the first step towards customisable mode keys.
@
text
@d1 1
a1 1
/* $OpenBSD: tmux.h,v 1.58 2009/07/27 18:51:46 nicm Exp $ */
a398 1
	MODEKEYCOPY_NONE,
a400 1
	MODEKEYCOPY_QUIT,
@


1.58
log
@Get rid of empty mode_key_free function.
@
text
@d1 1
a1 1
/* $OpenBSD: tmux.h,v 1.57 2009/07/27 12:11:11 nicm Exp $ */
d361 46
a406 23
	MODEKEYCMD_BACKSPACE = 0x1000,
	MODEKEYCMD_BACKTOINDENTATION,
	MODEKEYCMD_CHOOSE,
	MODEKEYCMD_CLEARSELECTION,
	MODEKEYCMD_COMPLETE,
	MODEKEYCMD_COPYSELECTION,
	MODEKEYCMD_DELETE,
	MODEKEYCMD_DELETETOENDOFLINE,
	MODEKEYCMD_DOWN,
	MODEKEYCMD_ENDOFLINE,
	MODEKEYCMD_LEFT,
	MODEKEYCMD_NEXTPAGE,
	MODEKEYCMD_NEXTWORD,
	MODEKEYCMD_NONE,
	MODEKEYCMD_OTHERKEY,
	MODEKEYCMD_PASTE,
	MODEKEYCMD_PREVIOUSPAGE,
	MODEKEYCMD_PREVIOUSWORD,
	MODEKEYCMD_QUIT,
	MODEKEYCMD_RIGHT,
	MODEKEYCMD_STARTOFLINE,
	MODEKEYCMD_STARTSELECTION,
	MODEKEYCMD_UP,
d409 13
d423 2
a424 6
	int			 type;

	int			 flags;
#define MODEKEY_EDITMODE 0x1
#define MODEKEY_CANEDIT 0x2
#define MODEKEY_CHOOSEMODE 0x4
a425 1

d1066 8
a1073 1
void		 mode_key_init(struct mode_key_data *, int, int);
@


1.57
log
@Add a key to delete to end of line at the prompt (^K in emacs mode, C/D in vi).

From Kalle Olavi Niemitalo.
@
text
@d1 1
a1 1
/* $OpenBSD: tmux.h,v 1.56 2009/07/26 21:42:08 nicm Exp $ */
a1035 1
void		 mode_key_free(struct mode_key_data *);
@


1.56
log
@Detect backspace by looking at termios VERASE and translate it into \177 (which
matches screen's behaviour if not its termcap/terminfo entry). The terminfo kbs
cap is often wrong or missing so it can't be used, and just assuming \177 may
be wrong.
@
text
@d1 1
a1 1
/* $OpenBSD: tmux.h,v 1.55 2009/07/26 12:58:44 nicm Exp $ */
d368 1
@


1.55
log
@Make all messages sent between the client and server fixed size.

This is the first of two changes to make the protocol more resilient and less
sensitive to other changes in the code, particularly with commands. The client
now packs argv into a buffer and sends it to the server for parsing, rather
than doing it itself and sending the parsed command data.

As a side-effect this also removes a lot of now-unused command marshalling
code.

Mixing a server without this change and a client with or vice versa will cause
tmux to hang or crash, please ensure that tmux is entirely killed before
upgrading.
@
text
@d1 1
a1 1
/* $OpenBSD: tmux.h,v 1.54 2009/07/24 14:52:47 nicm Exp $ */
d123 3
@


1.54
log
@Permit commands to be bound to key presses without the prefix key first. The
new -n flag to bind-key and unbind-key sets or removes these bindings, and
list-key shows them in []s.
@
text
@d1 1
a1 1
/* $OpenBSD: tmux.h,v 1.53 2009/07/23 20:24:27 nicm Exp $ */
d22 1
a22 1
#define PROTOCOL_VERSION -14
d65 8
d304 8
a311 1
/* Message header structure. */
d317 4
d325 2
a326 1
	size_t		namelen;
d335 2
a344 2

	size_t		termlen;
d352 4
a933 2
	void		 (*send)(struct cmd *, struct buffer *);
	void	         (*recv)(struct cmd *, struct buffer *);
d1138 3
a1142 2
void		 cmd_send(struct cmd *, struct buffer *);
struct cmd	*cmd_recv(struct buffer *);
a1144 2
void		 cmd_send_string(struct buffer *, const char *);
char		*cmd_recv_string(struct buffer *);
a1228 2
void		 cmd_list_send(struct cmd_list *, struct buffer *);
struct cmd_list	*cmd_list_recv(struct buffer *);
a1241 2
void	cmd_target_send(struct cmd *, struct buffer *);
void	cmd_target_recv(struct cmd *, struct buffer *);
a1248 2
void	cmd_srcdst_send(struct cmd *, struct buffer *);
void	cmd_srcdst_recv(struct cmd *, struct buffer *);
a1255 2
void	cmd_buffer_send(struct cmd *, struct buffer *);
void	cmd_buffer_recv(struct cmd *, struct buffer *);
a1262 2
void	cmd_option_send(struct cmd *, struct buffer *);
void	cmd_option_recv(struct cmd *, struct buffer *);
a1269 2
void	cmd_pane_send(struct cmd *, struct buffer *);
void	cmd_pane_recv(struct cmd *, struct buffer *);
a1281 2
void	 client_write_server2(
    	     struct client_ctx *, enum hdrtype, void *, size_t, void *, size_t);
d1313 1
@


1.53
log
@Tidy client message return slightly: convert flags into an enum, and merge
error string into struct client_ctx as well.
@
text
@d1 1
a1 1
/* $OpenBSD: tmux.h,v 1.52 2009/07/23 12:33:48 nicm Exp $ */
d105 6
a110 4
#define KEYC_NONE    0x0fff
#define KEYC_ESCAPE  0x2000
#define KEYC_CTRL    0x4000
#define KEYC_SHIFT   0x8000
a860 2
	struct client  *cmdclient;

d872 2
@


1.52
log
@Both of cmdclient and curclient CAN be NULL - if the command is executed from
the configuration file. In this case, attach-session can't do much, and
new-session should just assume -d.
@
text
@d1 1
a1 1
/* $OpenBSD: tmux.h,v 1.51 2009/07/22 21:34:36 nicm Exp $ */
d848 7
a854 4
#define CCTX_DETACH 0x1
#define CCTX_EXIT 0x2
#define CCTX_SHUTDOWN 0x4
	int 		 flags;
d1267 1
a1267 1
int	 client_msg_dispatch(struct client_ctx *, char **);
@


1.51
log
@window_add_pane cannot fail, so remove the unused cause argument and don't
bother to check for a NULL return.
@
text
@d1 1
a1 1
/* $OpenBSD: tmux.h,v 1.50 2009/07/22 20:56:58 nicm Exp $ */
d865 2
a866 1
	 * One of curclient or cmdclient is always NULL and the other not.
@


1.50
log
@tty_write is relatively short and the only function left in tty-write.c so move
it into tty.c.
@
text
@d1 1
a1 1
/* $OpenBSD: tmux.h,v 1.49 2009/07/22 20:53:38 nicm Exp $ */
d1472 1
a1472 1
struct window_pane *window_add_pane(struct window *, u_int, char **);
@


1.49
log
@More tty code tidying: move the saved cursor/region position (from before the
screen was updated) out of struct screen and into struct tty_ctx.
@
text
@d1 1
a1 1
/* $OpenBSD: tmux.h,v 1.48 2009/07/22 18:06:58 nicm Exp $ */
a793 1
typedef void tty_cmd_func(struct tty *, struct tty_ctx *);
a1077 3

/* tty-write.c */
void	tty_write(tty_cmd_func *, struct tty_ctx *);
@


1.48
log
@log_debug3 no longer exists, change the sole use in GRID_DEBUG to log_debug2.
@
text
@d1 1
a1 1
/* $OpenBSD: tmux.h,v 1.47 2009/07/22 18:02:23 nicm Exp $ */
a479 3
	u_int		 old_cx;
	u_int		 old_cy;

a482 3
	u_int		 old_rupper;
	u_int		 old_rlower;

d780 13
a792 2
	u_int		    num;
	void		   *ptr; 
a1039 1
void	tty_redraw_region(struct tty *, struct window_pane *);
d1043 1
a1080 3
void	tty_write0(struct window_pane *, tty_cmd_func *);
void	tty_writenum(struct window_pane *, tty_cmd_func *, u_int);
void	tty_writeptr(struct window_pane *, tty_cmd_func *, void *);
@


1.47
log
@enum tty_cmd is only used as an index into the array of command function
pointers, so remove it and use the function pointers directly to represent
themselves.
@
text
@d1 1
a1 1
/* $OpenBSD: tmux.h,v 1.46 2009/07/22 16:45:31 nicm Exp $ */
d379 1
a379 1
#define GRID_DEBUG(gd, fmt, ...) log_debug3("%s: (sx=%u, sy=%u, hsize=%u) " \
@


1.46
log
@There are relatively few arguments to tty_cmd_* functions now, so tidy them up
by using a struct rather than hiding everything with varargs.
@
text
@d1 1
a1 1
/* $OpenBSD: tmux.h,v 1.45 2009/07/22 15:55:32 nicm Exp $ */
a275 29
/* Output commands. */
enum tty_cmd {
	TTY_ALIGNMENTTEST,
	TTY_CELL,
	TTY_CLEARENDOFLINE,
	TTY_CLEARENDOFSCREEN,
	TTY_CLEARLINE,
	TTY_CLEARSCREEN,
	TTY_CLEARSTARTOFLINE,
	TTY_CLEARSTARTOFSCREEN,
	TTY_DELETECHARACTER,
	TTY_DELETELINE,
	TTY_INSERTCHARACTER,
	TTY_INSERTLINE,
	TTY_LINEFEED,
	TTY_UTF8CHARACTER,
	TTY_REVERSEINDEX,
};

struct tty_ctx {
	struct window_pane *wp;

	const struct grid_cell *cell;
	const struct grid_utf8 *utf8;

	u_int		    num;
	void		   *ptr; 
};

d779 12
d1018 36
a1053 27
u_char		 tty_get_acs(struct tty *, u_char);
void		 tty_emulate_repeat(struct tty *,
    		     enum tty_code_code, enum tty_code_code, u_int);
void		 tty_reset(struct tty *);
void		 tty_region(struct tty *, u_int, u_int, u_int);
void		 tty_cursor(struct tty *, u_int, u_int, u_int, u_int);
void		 tty_cell(struct tty *,
    		     const struct grid_cell *, const struct grid_utf8 *);
void		 tty_putcode(struct tty *, enum tty_code_code);
void		 tty_putcode1(struct tty *, enum tty_code_code, int);
void		 tty_putcode2(struct tty *, enum tty_code_code, int, int);
void		 tty_puts(struct tty *, const char *);
void		 tty_putc(struct tty *, u_char);
void		 tty_pututf8(struct tty *, const struct grid_utf8 *);
void		 tty_init(struct tty *, char *, char *);
void		 tty_start_tty(struct tty *);
void		 tty_stop_tty(struct tty *);
void		 tty_detect_utf8(struct tty *);
void		 tty_set_title(struct tty *, const char *);
void		 tty_update_mode(struct tty *, int);
void		 tty_draw_line(
    		     struct tty *, struct screen *, u_int, u_int, u_int);
void		 tty_redraw_region(struct tty *, struct window_pane *);
int		 tty_open(struct tty *, char **);
void		 tty_close(struct tty *, int);
void		 tty_free(struct tty *, int);
void		 tty_write(struct tty *, enum tty_cmd, struct tty_ctx *);
d1069 1
a1069 1
int		 tty_keys_cmp(struct tty_key *, struct tty_key *);
d1071 3
a1073 3
void		 tty_keys_init(struct tty *);
void		 tty_keys_free(struct tty *);
int		 tty_keys_next(struct tty *, int *, u_char *);
d1076 4
a1079 4
void		 tty_write0(struct window_pane *, enum tty_cmd);
void		 tty_writenum(struct window_pane *, enum tty_cmd, u_int);
void		 tty_writeptr(struct window_pane *, enum tty_cmd, void *);
void		 tty_write_cmd(enum tty_cmd, struct tty_ctx *);
@


1.45
log
@tty_cmd_raw is only used once, for raw UTF-8 output, so rename it to
tty_cmd_utf8character and eliminate the size argument.
@
text
@d1 1
a1 1
/* $OpenBSD: tmux.h,v 1.44 2009/07/21 19:54:22 nicm Exp $ */
d295 10
d1061 1
a1061 2
void		 tty_vwrite(
    		     struct tty *, struct window_pane *, enum tty_cmd, va_list);
d1084 4
a1087 1
void		 tty_write_cmd(struct window_pane *, enum tty_cmd, ...);
@


1.44
log
@Make some functions which return unused values void (mostly found by lint) and
tweak a redundant expression in window_pane_set_mode.
@
text
@d1 1
a1 1
/* $OpenBSD: tmux.h,v 1.43 2009/07/21 18:40:30 nicm Exp $ */
d291 1
a291 1
	TTY_RAW,
@


1.43
log
@Remove a couple of unused functions and fix a type ("FALLTHOUGH"), found by
lint.
@
text
@d1 1
a1 1
/* $OpenBSD: tmux.h,v 1.42 2009/07/21 18:38:52 nicm Exp $ */
d1017 1
a1017 1
int	options_remove(struct options *, const char *);
a1289 1
struct client *server_create_client(int);
a1468 1
int		 window_resize(struct window *, u_int, u_int);
d1471 1
d1481 1
a1481 1
int		 window_pane_resize(struct window_pane *, u_int, u_int);
@


1.42
log
@__progname is not const, pointed out by deraadt.
@
text
@d1 1
a1 1
/* $OpenBSD: tmux.h,v 1.41 2009/07/21 17:57:29 nicm Exp $ */
a1351 1
void	 grid_reduce_line(struct grid *, u_int, u_int);
a1604 1
void printflike1 log_debug3(const char *, ...);
@


1.41
log
@Tidy up keys: use an enum for the key codes, and remove the macros which just
wrap flag sets/clears/tests.
@
text
@d1 1
a1 1
/* $OpenBSD: tmux.h,v 1.40 2009/07/20 14:37:51 nicm Exp $ */
d41 1
a41 1
extern const char    *__progname;
@


1.40
log
@Display the number of failed password attempts (if any) when the server is
locked. From Tom Doherty.
@
text
@d1 1
a1 1
/* $OpenBSD: tmux.h,v 1.39 2009/07/19 13:21:40 nicm Exp $ */
d105 62
a166 73
#define KEYC_NONE    0x00ffff
#define KEYC_OFFSET  0x010000
#define KEYC_ESCAPE  0x020000
#define KEYC_CONTROL 0x080000
#define KEYC_SHIFT   0x100000

#define KEYC_ADDESC(k) ((k) | KEYC_ESCAPE)
#define KEYC_REMOVEESC(k) ((k) & ~KEYC_ESCAPE)
#define KEYC_ISESC(k) ((k) != KEYC_NONE && ((k) & KEYC_ESCAPE))

#define KEYC_ADDCTL(k) ((k) | KEYC_CONTROL)
#define KEYC_REMOVECTL(k) ((k) & ~KEYC_CONTROL)
#define KEYC_ISCTL(k) ((k) != KEYC_NONE && ((k) & KEYC_CONTROL))

#define KEYC_ADDSFT(k) ((k) | KEYC_SHIFT)
#define KEYC_REMOVESFT(k) ((k) & ~KEYC_SHIFT)
#define KEYC_ISSFT(k) ((k) != KEYC_NONE && ((k) & KEYC_SHIFT))

/* Mouse key. */
#define KEYC_MOUSE (KEYC_OFFSET + 0x00)

/* Function keys. */
#define KEYC_F1 (KEYC_OFFSET + 0x01)
#define KEYC_F2 (KEYC_OFFSET + 0x02)
#define KEYC_F3 (KEYC_OFFSET + 0x03)
#define KEYC_F4 (KEYC_OFFSET + 0x04)
#define KEYC_F5 (KEYC_OFFSET + 0x05)
#define KEYC_F6 (KEYC_OFFSET + 0x06)
#define KEYC_F7 (KEYC_OFFSET + 0x07)
#define KEYC_F8 (KEYC_OFFSET + 0x08)
#define KEYC_F9 (KEYC_OFFSET + 0x09)
#define KEYC_F10 (KEYC_OFFSET + 0x10)
#define KEYC_F11 (KEYC_OFFSET + 0x11)
#define KEYC_F12 (KEYC_OFFSET + 0x12)
#define KEYC_F13 (KEYC_OFFSET + 0x13)
#define KEYC_F14 (KEYC_OFFSET + 0x14)
#define KEYC_F15 (KEYC_OFFSET + 0x15)
#define KEYC_F16 (KEYC_OFFSET + 0x16)
#define KEYC_F17 (KEYC_OFFSET + 0x17)
#define KEYC_F18 (KEYC_OFFSET + 0x18)
#define KEYC_F19 (KEYC_OFFSET + 0x19)
#define KEYC_F20 (KEYC_OFFSET + 0x1a)
#define KEYC_IC (KEYC_OFFSET + 0x1b)
#define KEYC_DC (KEYC_OFFSET + 0x1c)
#define KEYC_HOME (KEYC_OFFSET + 0x1d)
#define KEYC_END (KEYC_OFFSET + 0x1e)
#define KEYC_NPAGE (KEYC_OFFSET + 0x1f)
#define KEYC_PPAGE (KEYC_OFFSET + 0x20)
#define KEYC_BTAB (KEYC_OFFSET + 0x21)

/* Arrow keys. */
#define KEYC_UP (KEYC_OFFSET + 0x50)
#define KEYC_DOWN (KEYC_OFFSET + 0x51)
#define KEYC_LEFT (KEYC_OFFSET + 0x52)
#define KEYC_RIGHT (KEYC_OFFSET + 0x53)

/* Numeric keypad. Numbered from top-left, KPY_X. */
#define KEYC_KP0_1 (KEYC_OFFSET + 0x100)
#define KEYC_KP0_2 (KEYC_OFFSET + 0x101)
#define KEYC_KP0_3 (KEYC_OFFSET + 0x102)
#define KEYC_KP1_0 (KEYC_OFFSET + 0x103)
#define KEYC_KP1_1 (KEYC_OFFSET + 0x104)
#define KEYC_KP1_2 (KEYC_OFFSET + 0x105)
#define KEYC_KP1_3 (KEYC_OFFSET + 0x106)
#define KEYC_KP2_0 (KEYC_OFFSET + 0x107)
#define KEYC_KP2_1 (KEYC_OFFSET + 0x108)
#define KEYC_KP2_2 (KEYC_OFFSET + 0x109)
#define KEYC_KP3_0 (KEYC_OFFSET + 0x10a)
#define KEYC_KP3_1 (KEYC_OFFSET + 0x10b)
#define KEYC_KP3_2 (KEYC_OFFSET + 0x10c)
#define KEYC_KP3_3 (KEYC_OFFSET + 0x10d)
#define KEYC_KP4_0 (KEYC_OFFSET + 0x10e)
#define KEYC_KP4_2 (KEYC_OFFSET + 0x10f)
@


1.39
log
@Improved layout code.

Each window now has a tree of layout cells associated with it. In this tree,
each node is either a horizontal or vertical cell containing a list of other
cells running from left-to-right or top-to-bottom, or a leaf cell which is
associated with a pane.

The major functional changes are:

- panes may now be split arbitrarily both horizontally (splitw -h, C-b %) and
  vertically (splitw -v, C-b ");
- panes may be resized both horizontally and vertically (resizep -L/-R/-U/-D,
  bound to C-b left/right/up/down and C-b M-left/right/up/down);
- layouts are now applied and then may be modified by resizing or splitting
  panes, rather than being fixed and reapplied when the window is resized or
  panes are added;
- manual-vertical layout is no longer necessary, and active-only layout is gone
  (but may return in future);
- the main-pane layouts now reduce the size of the main pane to fit all panes
  if possible.

Thanks to all who tested.
@
text
@d1 1
a1 1
/* $OpenBSD: tmux.h,v 1.38 2009/07/18 14:59:25 nicm Exp $ */
d1001 1
@


1.38
log
@Add three new session options: visual-activity, visual-bell, visual-content. If
these are enabled (and the monitor-activity, bell-actio and monitor-content
options are configurated appropriately), when activity, a bell, or content is
detected, a message is shown.

Also tidy up the bell/activity/content code in server.c slightly and fix a
couple of errors.
@
text
@d1 1
a1 1
/* $OpenBSD: tmux.h,v 1.37 2009/07/17 20:37:03 nicm Exp $ */
d50 5
a54 2
/* Minimum pane size. */
#define PANE_MINIMUM 5	/* includes separator line */
d598 1
d642 1
d644 1
d673 28
d1483 1
a1483 2
struct window_pane *window_add_pane(struct window *, int,
		     const char *, const char *, const char **, u_int, char **);
d1503 1
a1503 1
		     struct window_pane *, const char *, u_int *);
d1506 29
a1534 11
const char * 	 layout_name(struct window *);
int		 layout_lookup(const char *);
void		 layout_refresh(struct window *, int);
int		 layout_resize(struct window_pane *, int);
int		 layout_select(struct window *, u_int);
void		 layout_next(struct window *);
void		 layout_previous(struct window *);

/* layout-manual.c */
void		 layout_manual_v_refresh(struct window *, int);
void		 layout_manual_v_resize(struct window_pane *, int);
@


1.37
log
@Make it so using kill-pane to destroy the last pane in a window destroys the
window instead of being an error.
@
text
@d1 1
a1 1
/* $OpenBSD: tmux.h,v 1.36 2009/07/17 18:45:08 nicm Exp $ */
d647 2
a648 2
#define WINDOW_CONTENT 0x6
#define WINDOW_REDRAW 0x8
@


1.36
log
@- New command display-message (alias display) to display a message in the
  status line (bound to "i" and displays the current window and time by
  default). The same substitutions are applied as for status-left/right.
- Add support for including the window index (#I), pane index (#P) and window
  name (#W) in the message, and status-left or status-right.
- Bump protocol version.

From Tiago Cunha, thanks!
@
text
@d1 1
a1 1
/* $OpenBSD: tmux.h,v 1.35 2009/07/17 15:03:11 nicm Exp $ */
d1287 1
@


1.35
log
@Tidy up new-session and attach-session and change them to work from inside
tmux, switching the current client to the new or requested session.

Written with Josh Elsasser.
@
text
@d1 1
a1 1
/* $OpenBSD: tmux.h,v 1.34 2009/07/17 07:05:58 nicm Exp $ */
d22 1
a22 1
#define PROTOCOL_VERSION -13
d1113 1
d1290 1
d1452 1
@


1.34
log
@A similar for fix for window_choose: don't rely on the callback always being
called to free data, have a separate free callback and call it from the mode
cleanup code.
@
text
@d1 1
a1 1
/* $OpenBSD: tmux.h,v 1.33 2009/07/17 06:13:27 nicm Exp $ */
d838 9
d849 1
@


1.33
log
@Memory could be leaked if a second prompt or message appeared while another was
still present, so add a separate prompt free callback and make the _clear
function responsible for calling it if necessary (rather than the individual
prompt callbacks). Also make both messages and prompts clear any existing when
a new is set.

In addition, the screen could be modified while the prompt is there, restore
the redraw-entire-screen behaviour on prompt clear; add a comment as a
reminder.
@
text
@d1 1
a1 1
/* $OpenBSD: tmux.h,v 1.32 2009/07/15 17:39:00 nicm Exp $ */
d1493 1
a1493 1
		     u_int, void (*)(void *, int), void *);
@


1.32
log
@Make status_message_set a variadic printf-like function. No functional change -
helpful for a couple of things coming soon.
@
text
@d1 1
a1 1
/* $OpenBSD: tmux.h,v 1.31 2009/07/15 07:50:34 nicm Exp $ */
d805 2
a806 1
	int		 (*prompt_callback)(void *, const char *);
d1282 2
a1283 2
void	 status_prompt_set(struct client *,
	     const char *, int (*)(void *, const char *), void *, int);
@


1.31
log
@Having to update NSETOPTION/NSETWINDOWOPTION when adding new options is a bit
annoying and it is only use for iterating, so use a sentinel to mark the end of
each array instead. Different fix for a problem pointed out by Kalle Olavi
Niemitalo.
@
text
@d1 1
a1 1
/* $OpenBSD: tmux.h,v 1.30 2009/07/14 20:20:04 nicm Exp $ */
d1278 1
a1278 1
void	 status_message_set(struct client *, const char *);
@


1.30
log
@Add main-pane-height to the options list (was missed before).
@
text
@d1 1
a1 1
/* $OpenBSD: tmux.h,v 1.29 2009/07/14 19:03:16 nicm Exp $ */
a943 2
#define NSETOPTION 26
#define NSETWINDOWOPTION 20
@


1.29
log
@Instead of faking up a status line in status_redraw, use the same code to
redraw it as to draw the entire screen, just skip all lines but the last.

This makes horizontal split redraw properly when the status line is off.
@
text
@d1 1
a1 1
/* $OpenBSD: tmux.h,v 1.28 2009/07/14 07:23:36 nicm Exp $ */
d945 1
a945 1
#define NSETWINDOWOPTION 19
@


1.28
log
@Get rid of the PANE_HIDDEN flag in favour of a function, and moving the
decision for whether or not a pane should be drawn out of the layout code and
into the redraw code.

This is needed for the new layout design, getting it in now to make that easier
to work on.
@
text
@d1 1
a1 1
/* $OpenBSD: tmux.h,v 1.27 2009/07/13 23:11:35 nicm Exp $ */
d1398 1
a1398 1
void	 screen_redraw_screen(struct client *);
a1399 1
void	 screen_redraw_status(struct client *);
@


1.27
log
@Having fixed flags for single-character getopt options is a bit hard to
maintain and is only going to get worse as more are used. So instead, add a new
uint64_t member to cmd_entry which is a bitmask of upper and lowercase options
accepted by the command.

This means new single character options can be used without the need to add it
explicitly to the list.
@
text
@d1 1
a1 1
/* $OpenBSD: tmux.h,v 1.26 2009/07/13 17:47:46 nicm Exp $ */
d51 1
a51 1
#define PANE_MINIMUM 4	/* includes separator line */
d603 1
a603 2
#define PANE_HIDDEN 0x1
#define PANE_REDRAW 0x2
d1456 1
@


1.26
log
@Tidy up and improve target (-t) argument parsing:

- move the code back into cmd.c and merge with the existing functions where
  possible;
- accept "-tttyp0" as well as "-t/dev/ttyp0" for clients;
- when looking up session names, try an exact match first, and if that fails
  look for it as an fnmatch pattern and then as the start of a name - if more
  that one session matches an error is given; so if there is one session called
  "mysession", -tmysession, -tmysess, -tmysess* are equivalent but if there
  is also "mysession2", the last two are errors;
- similarly for windows, if the argument is not a valid index or exact window
  name match, try it against the window names as an fnmatch pattern and a
  prefix.
@
text
@d1 1
a1 1
/* $OpenBSD: tmux.h,v 1.25 2009/07/13 10:43:52 nicm Exp $ */
d864 1
a864 8
#define CMD_AFLAG 0x10
#define CMD_DFLAG 0x20
#define CMD_GFLAG 0x40
#define CMD_KFLAG 0x80
#define CMD_UFLAG 0x100
#define CMD_BIGDFLAG 0x200
#define CMD_BIGUFLAG 0x400
#define CMD_RFLAG 0x800
d866 4
a869 1
	int		 flags;
d882 1
a882 1
	int	 flags;
d888 1
a888 1
	int	 flags;
d895 1
a895 1
	int	 flags;
d902 1
a902 1
	int	 flags;
d909 1
a909 1
	int	 flags;
@


1.25
log
@Support "alternate screen" mode (terminfo smcup/rmcup) typically used by full
screen interactive programs to preserve the screen contents. When activated, it
saves a copy of the visible grid and disables scrolling into and resizing out
of the history; when deactivated the visible data is restored and the history
reenabled.
@
text
@d1 1
a1 1
/* $OpenBSD: tmux.h,v 1.24 2009/07/12 23:46:49 nicm Exp $ */
a1078 5
/* arg.c */
struct client 	*arg_parse_client(const char *);
struct session 	*arg_parse_session(const char *);
int		 arg_parse_window(const char *, struct session **, int *);

d1092 3
a1094 1
    		     struct cmd_ctx *, const char *, struct session **);
@


1.24
log
@Missed this declaration in key bindings change. Whoops.
@
text
@d1 1
a1 1
/* $OpenBSD: tmux.h,v 1.23 2009/07/12 16:15:34 nicm Exp $ */
d446 3
d620 5
d1339 2
@


1.23
log
@Add a "back to indentation" key in copy mode to move the cursor to the first
non-whitespace character. ^ with vi and M-m with emacs key bindings. Another
from Kalle Olavi Niemitalo, thanks.
@
text
@d1 1
a1 1
/* $OpenBSD: tmux.h,v 1.22 2009/07/12 16:07:56 nicm Exp $ */
d1242 1
@


1.22
log
@If it exist, load a system-wide configuration file /etc/tmux.conf before any
user-specified one.
@
text
@d1 1
a1 1
/* $OpenBSD: tmux.h,v 1.21 2009/07/11 19:14:56 nicm Exp $ */
d360 1
@


1.21
log
@When pasting, translate \n into \r. This matches xterm and putty's behaviour,
and makes emacs happy when pasting into some modes. A new -r (raw) flag to
paste-buffer pastes without the translation.

From Kalle Olavi Niemitalo, thanks!
@
text
@d1 1
a1 1
/* $OpenBSD: tmux.h,v 1.20 2009/07/10 05:50:54 nicm Exp $ */
d43 1
a43 1
/* Default configuration file. */
d45 1
@


1.20
log
@Add a default-terminal option to set the starting value of $TERM in new
windows.

This is "screen" by default and must be either that or something closely
related. This does makes it easier to customise it if necessary.
@
text
@d1 1
a1 1
/* $OpenBSD: tmux.h,v 1.19 2009/07/09 15:47:49 nicm Exp $ */
d861 1
@


1.19
log
@New command, if-shell (alias if). Executes the tmux command in the second
argument if the shell command in the first succeeds, for example:

       if "[ -e ~/.tmux.conf.alt ]" "source .tmux.conf.alt"

Written by Tiago Cunha, many thanks.
@
text
@d1 1
a1 1
/* $OpenBSD: tmux.h,v 1.18 2009/07/09 00:29:32 nicm Exp $ */
d938 1
a938 1
#define NSETOPTION 25
@


1.18
log
@Tidy by removing unused argument from grid_view_{insert,delete}_line_region
functions (currently don't fully work, this is to make fix easier).
@
text
@d1 1
a1 1
/* $OpenBSD: tmux.h,v 1.17 2009/07/08 05:26:45 nicm Exp $ */
d1104 1
@


1.17
log
@Just appending -l to $SHELL to create a login shell is wrong: -l is not POSIX,
and some people may use shells which do not support it. Instead, make an empty
default-command option mean a login shell, and fork it with a - in argv[0]
which is the method used by login(1).

Also fix the automatic-rename code to handle this correctly and to strip a
leading - if present.
@
text
@d1 1
a1 1
/* $OpenBSD: tmux.h,v 1.16 2009/07/07 19:49:19 nicm Exp $ */
d1340 1
a1340 2
void	 grid_view_insert_lines_region(
    	     struct grid *, u_int, u_int, u_int, u_int);
d1342 1
a1342 2
void	 grid_view_delete_lines_region(
    	     struct grid *, u_int, u_int, u_int, u_int);
@


1.16
log
@Rename the global options variables to be shorter and to make session options
clear. No functional change, getting this out of the way to make later options
changes easier.
@
text
@d1 1
a1 1
/* $OpenBSD: tmux.h,v 1.15 2009/06/26 19:44:36 nicm Exp $ */
d1411 1
@


1.15
log
@Remove some unused function declarations; no binary change.
@
text
@d1 1
a1 1
/* $OpenBSD: tmux.h,v 1.14 2009/06/25 22:08:15 nicm Exp $ */
d948 2
a949 2
extern struct options global_options;
extern struct options global_window_options;
@


1.14
log
@#ifndef nitems to avoid redefining it if it is already in a header.
@
text
@d1 1
a1 1
/* $OpenBSD: tmux.h,v 1.13 2009/06/25 06:23:10 nicm Exp $ */
a1219 1
int	 client_flush(struct client_ctx *);
a1407 2
void	 screen_display_copy_area(struct screen *, struct screen *,
    	     u_int, u_int, u_int, u_int, u_int, u_int);
a1442 1
void		 window_calculate_sizes(struct window *);
a1559 1
int printflike3	 printpath(char *, size_t, const char *, ...);
@


1.13
log
@tmux doesn't and won't need syslog logging, so remove it and some other unused
functions found by lint.

Also move a couple of internal function declarations into file scope.
@
text
@d1 1
a1 1
/* $OpenBSD: tmux.h,v 1.12 2009/06/25 06:15:04 nicm Exp $ */
d76 1
d78 1
@


1.12
log
@Miscellaneous unused functions, including one which was basically a
duplicate. Found by lint.
@
text
@d1 1
a1 1
/* $OpenBSD: tmux.h,v 1.11 2009/06/25 06:05:47 nicm Exp $ */
a1539 2
#define LOG_FACILITY LOG_DAEMON
void		 log_open_syslog(int);
a1542 2
void		 log_vwrite(int, const char *, va_list);
void		 log_write(int, const char *, ...);
a1548 1
__dead void	 log_vfatal(const char *, va_list);
@


1.11
log
@Nuke unused buffer functions. Found by lint.

Also remove some old debug output which was #if 0.
@
text
@d1 1
a1 1
/* $OpenBSD: tmux.h,v 1.10 2009/06/24 22:49:56 nicm Exp $ */
a1009 2
void		 tty_write(
		     struct tty *, struct window_pane *, enum tty_cmd, ...);
a1034 1
void		 tty_write_mode(struct window_pane *, int);
a1262 2
void	 server_write_window(
	     struct window *, enum hdrtype, const void *, size_t);
a1322 1
void	 grid_clear_cells(struct grid *, u_int, u_int, u_int);
a1435 1
u_int		 window_index_of_pane(struct window *, struct window_pane *);
a1481 1
void printflike2 window_more_add(struct window_pane *, const char *, ...);
@


1.10
log
@Change find-window and monitor-content to use fnmatch(3). For convenience and
compatibility, *s are implicitly added at the start and end of the pattern.

Also display the line number and the entire line in the results, and lose the
nasty section_string function and the now empty util.c file.

Initially from Tiago Cunha.
@
text
@d1 1
a1 1
/* $OpenBSD: tmux.h,v 1.9 2009/06/24 22:04:18 nicm Exp $ */
a1535 1
void		 buffer_clear(struct buffer *);
a1537 1
void		 buffer_reverse_add(struct buffer *, size_t);
a1538 3
void		 buffer_reverse_remove(struct buffer *, size_t);
void		 buffer_insert_range(struct buffer *, size_t, size_t);
void		 buffer_delete_range(struct buffer *, size_t, size_t);
a1541 1
void	 	 buffer_write16(struct buffer *, uint16_t);
a1542 1
uint16_t 	 buffer_read16(struct buffer *);
a1544 2
void		 buffer_set(
		     struct pollfd *, int, struct buffer *, struct buffer *);
a1545 1
void		 buffer_flush(int, struct buffer *n, struct buffer *);
@


1.9
log
@Add a dedicated function to convert a line into a string and use it to simplify the search window function.
@
text
@d1 1
a1 1
/* $OpenBSD: tmux.h,v 1.8 2009/06/24 16:01:02 nicm Exp $ */
d1459 2
a1460 1
char		*window_pane_search(struct window_pane *, const char *);
a1528 4

/* util.c */
char   *section_string(char *, size_t, size_t, size_t);
void	clean_string(const char *, char *, size_t);
@


1.8
log
@Trying to predict the cursor position for UTF-8 output in the same way as for
normal eight-bit output is wrong, separate it into a different function. Fixes
spacing when mixing UTF-8 with some escape sequences, notably the way w3m does
it.
@
text
@d1 1
a1 1
/* $OpenBSD: tmux.h,v 1.7 2009/06/24 05:35:07 nicm Exp $ */
d1330 1
d1352 1
@


1.7
log
@Constify utf8_width() function argument.
@
text
@d1 1
a1 1
/* $OpenBSD: tmux.h,v 1.6 2009/06/04 18:48:24 nicm Exp $ */
d997 1
@


1.6
log
@Proper support for tab stops (\033H etc), using a bitstring(3). Makes another
vttest test happy.
@
text
@d1 1
a1 1
/* $OpenBSD: tmux.h,v 1.5 2009/06/03 23:30:40 nicm Exp $ */
d1524 1
a1524 1
int	utf8_width(u_char *);
@


1.5
log
@Implement the DEC alignment test. With the last change this is enough for the
first cursor test in vttest (in ports) to pass; it still shops a few more
problems though.
@
text
@d1 1
a1 1
/* $OpenBSD: tmux.h,v 1.4 2009/06/03 16:54:26 nicm Exp $ */
d29 1
d511 2
d1403 1
@


1.4
log
@New session option, status-utf8, to control the interpretation of top-bit-set
characters in status-left and status-right (if on, they are treated as UTF-8;
otherwise passed through).
@
text
@d1 1
a1 1
/* $OpenBSD: tmux.h,v 1.3 2009/06/03 16:05:46 nicm Exp $ */
d282 1
d1367 1
@


1.3
log
@Add a UTF-8 aware string length function and make UTF-8 in
status-left/status-right work properly. At the moment any top-bit-set
characters are assumed to be UTF-8: a status-utf8 option to configure this will
come shortly.
@
text
@d1 1
a1 1
/* $OpenBSD: tmux.h,v 1.2 2009/06/03 07:51:24 nicm Exp $ */
d72 1
d932 1
a932 1
#define NSETOPTION 24
d1351 1
a1351 1
size_t printflike1 screen_write_strlen(const char *, ...);
d1354 2
a1355 2
void printflike4 screen_write_nputs(struct screen_write_ctx *,
    	     ssize_t, struct grid_cell *, const char *, ...);
d1357 1
a1357 1
    	     ssize_t, struct grid_cell *, const char *, va_list);
@


1.2
log
@When swapping pane positions, swap the PANE_HIDDEN flag as well, otherwise tmux
crashes when trying to find the new active pane.

While here, nuke an unused pane flag.

Fixes PR 6160, reported by and a slightly different version of diff tested by
ralf.horstmann at gmx.de.
@
text
@d1 1
a1 1
/* $OpenBSD: tmux.h,v 1.1 2009/06/01 22:58:49 nicm Exp $ */
d1350 7
a1356 2
void printflike3 screen_write_puts(
	     struct screen_write_ctx *, struct grid_cell *, const char *, ...);
@


1.1
log
@Import tmux, a terminal multiplexor allowing (among other things) a single
terminal to be switched between several different windows and programs
displayed on one terminal be detached from one terminal and moved to another.

ok deraadt pirofti
@
text
@d1 1
a1 1
/* $OpenBSD$ */
d592 1
a592 2
#define PANE_RESTART 0x2
#define PANE_REDRAW 0x4
@

