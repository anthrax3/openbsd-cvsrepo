head	1.73;
access;
symbols
	OPENBSD_6_1:1.73.0.2
	OPENBSD_6_1_BASE:1.73
	OPENBSD_6_0:1.57.0.2
	OPENBSD_6_0_BASE:1.57
	OPENBSD_5_9:1.56.0.2
	OPENBSD_5_9_BASE:1.56
	OPENBSD_5_8:1.50.0.4
	OPENBSD_5_8_BASE:1.50
	OPENBSD_5_7:1.43.0.2
	OPENBSD_5_7_BASE:1.43
	OPENBSD_5_6:1.41.0.4
	OPENBSD_5_6_BASE:1.41
	OPENBSD_5_5:1.39.0.6
	OPENBSD_5_5_BASE:1.39
	OPENBSD_5_4:1.39.0.2
	OPENBSD_5_4_BASE:1.39
	OPENBSD_5_3:1.34.0.2
	OPENBSD_5_3_BASE:1.34
	OPENBSD_5_2:1.33.0.2
	OPENBSD_5_2_BASE:1.33
	OPENBSD_5_1_BASE:1.29
	OPENBSD_5_1:1.29.0.2
	OPENBSD_5_0:1.28.0.2
	OPENBSD_5_0_BASE:1.28
	OPENBSD_4_9:1.27.0.2
	OPENBSD_4_9_BASE:1.27
	OPENBSD_4_8:1.23.0.2
	OPENBSD_4_8_BASE:1.23
	OPENBSD_4_7:1.17.0.2
	OPENBSD_4_7_BASE:1.17
	OPENBSD_4_6:1.1.0.4
	OPENBSD_4_6_BASE:1.1;
locks; strict;
comment	@ * @;


1.73
date	2017.02.06.15.00.41;	author nicm;	state Exp;
branches;
next	1.72;
commitid	2TKl6DV1kcWaPxr9;

1.72
date	2017.01.24.19.53.37;	author nicm;	state Exp;
branches;
next	1.71;
commitid	APEyI6NiCN6S4KhZ;

1.71
date	2017.01.16.14.52.25;	author nicm;	state Exp;
branches;
next	1.70;
commitid	DhrjePH0tXykfoeE;

1.70
date	2017.01.16.14.49.14;	author nicm;	state Exp;
branches;
next	1.69;
commitid	4TgBXjnsq23XHMH4;

1.69
date	2017.01.15.22.00.56;	author nicm;	state Exp;
branches;
next	1.68;
commitid	P8Zuj7wnJMd8B8vz;

1.68
date	2017.01.06.11.57.03;	author nicm;	state Exp;
branches;
next	1.67;
commitid	m6HBAjiRCa66sywZ;

1.67
date	2016.12.07.09.16.13;	author nicm;	state Exp;
branches;
next	1.66;
commitid	0eoQrc7lxznhLrSz;

1.66
date	2016.11.24.13.46.50;	author nicm;	state Exp;
branches;
next	1.65;
commitid	AE4rxCQLpL805vhq;

1.65
date	2016.11.23.17.01.24;	author nicm;	state Exp;
branches;
next	1.64;
commitid	MqQ1xWjJDuKsBsyT;

1.64
date	2016.10.21.13.51.59;	author nicm;	state Exp;
branches;
next	1.63;
commitid	wdi3gMqHqz7D96vm;

1.63
date	2016.10.19.09.24.57;	author nicm;	state Exp;
branches;
next	1.62;
commitid	dMpTuNcqi7DXWkT6;

1.62
date	2016.10.16.19.04.05;	author nicm;	state Exp;
branches;
next	1.61;
commitid	pxm6osuE99zELpkU;

1.61
date	2016.10.16.17.55.14;	author nicm;	state Exp;
branches;
next	1.60;
commitid	1xIYFpLYkPIXNEvU;

1.60
date	2016.10.12.13.03.27;	author nicm;	state Exp;
branches;
next	1.59;
commitid	eul7q5vzLp6bFmDk;

1.59
date	2016.10.11.09.30.36;	author nicm;	state Exp;
branches;
next	1.58;
commitid	OThpNjT1frpnaa0G;

1.58
date	2016.10.11.07.23.34;	author nicm;	state Exp;
branches;
next	1.57;
commitid	leUN1UeapgUoieJj;

1.57
date	2016.03.01.12.06.07;	author nicm;	state Exp;
branches;
next	1.56;
commitid	gWWSXkaHYCnCm5SK;

1.56
date	2016.01.19.15.59.12;	author nicm;	state Exp;
branches;
next	1.55;
commitid	P3qmSOx6KrDBsb0c;

1.55
date	2015.11.12.11.05.34;	author nicm;	state Exp;
branches;
next	1.54;
commitid	Ih1tdqtjpnEyfE8x;

1.54
date	2015.11.05.11.05.30;	author nicm;	state Exp;
branches;
next	1.53;
commitid	ANFJ4tFKwAUfAjuH;

1.53
date	2015.10.27.09.15.21;	author nicm;	state Exp;
branches;
next	1.52;
commitid	oGUQ7OvByCioKm94;

1.52
date	2015.10.26.23.06.18;	author nicm;	state Exp;
branches;
next	1.51;
commitid	jLiV69NaXFJoZPd7;

1.51
date	2015.10.21.11.13.47;	author nicm;	state Exp;
branches;
next	1.50;
commitid	61RSHQTJtgSY71K5;

1.50
date	2015.06.05.08.14.16;	author nicm;	state Exp;
branches;
next	1.49;
commitid	FezlkQJJMDFfG1I5;

1.49
date	2015.06.04.11.43.51;	author nicm;	state Exp;
branches;
next	1.48;
commitid	rAvOUA4CI6VK3gQ6;

1.48
date	2015.05.07.11.42.56;	author nicm;	state Exp;
branches;
next	1.47;
commitid	aHjVLgOHz1Tie9FQ;

1.47
date	2015.04.25.18.49.01;	author nicm;	state Exp;
branches;
next	1.46;
commitid	OvVP75Ylb5es4t32;

1.46
date	2015.04.21.15.34.32;	author nicm;	state Exp;
branches;
next	1.45;
commitid	SK2kadfuuczuuafv;

1.45
date	2015.04.20.15.34.56;	author nicm;	state Exp;
branches;
next	1.44;
commitid	1fc4pMkRD7YjyQWP;

1.44
date	2015.04.19.21.34.21;	author nicm;	state Exp;
branches;
next	1.43;
commitid	wug6ctIOfhVMeWQp;

1.43
date	2014.10.22.23.18.53;	author nicm;	state Exp;
branches;
next	1.42;
commitid	eFDptKeckheZa4ap;

1.42
date	2014.10.20.22.29.25;	author nicm;	state Exp;
branches;
next	1.41;
commitid	Gq8hgMoG3t1Wy1Zv;

1.41
date	2014.05.14.06.21.19;	author nicm;	state Exp;
branches;
next	1.40;

1.40
date	2014.04.17.07.55.43;	author nicm;	state Exp;
branches;
next	1.39;

1.39
date	2013.03.24.09.57.59;	author nicm;	state Exp;
branches;
next	1.38;

1.38
date	2013.03.24.09.54.10;	author nicm;	state Exp;
branches;
next	1.37;

1.37
date	2013.03.22.15.54.29;	author nicm;	state Exp;
branches;
next	1.36;

1.36
date	2013.03.22.15.50.42;	author nicm;	state Exp;
branches;
next	1.35;

1.35
date	2013.03.22.15.49.55;	author nicm;	state Exp;
branches;
next	1.34;

1.34
date	2013.01.17.00.11.22;	author nicm;	state Exp;
branches;
next	1.33;

1.33
date	2012.07.10.11.53.01;	author nicm;	state Exp;
branches;
next	1.32;

1.32
date	2012.07.08.16.04.38;	author nicm;	state Exp;
branches;
next	1.31;

1.31
date	2012.06.18.09.58.02;	author nicm;	state Exp;
branches;
next	1.30;

1.30
date	2012.04.01.13.18.38;	author nicm;	state Exp;
branches;
next	1.29;

1.29
date	2012.01.21.11.12.13;	author nicm;	state Exp;
branches;
next	1.28;

1.28
date	2011.07.03.18.18.15;	author nicm;	state Exp;
branches;
next	1.27;

1.27
date	2011.01.04.00.42.47;	author nicm;	state Exp;
branches;
next	1.26;

1.26
date	2010.12.11.18.39.25;	author nicm;	state Exp;
branches;
next	1.25;

1.25
date	2010.10.23.13.04.34;	author nicm;	state Exp;
branches;
next	1.24;

1.24
date	2010.09.08.22.02.28;	author nicm;	state Exp;
branches;
next	1.23;

1.23
date	2010.06.26.18.20.53;	author nicm;	state Exp;
branches;
next	1.22;

1.22
date	2010.06.21.21.44.09;	author nicm;	state Exp;
branches;
next	1.21;

1.21
date	2010.05.05.23.24.23;	author nicm;	state Exp;
branches;
next	1.20;

1.20
date	2010.04.25.20.28.13;	author nicm;	state Exp;
branches;
next	1.19;

1.19
date	2010.04.06.21.35.44;	author nicm;	state Exp;
branches;
next	1.18;

1.18
date	2010.03.22.19.07.52;	author nicm;	state Exp;
branches;
next	1.17;

1.17
date	2010.02.06.22.55.31;	author nicm;	state Exp;
branches;
next	1.16;

1.16
date	2009.12.10.09.16.52;	author nicm;	state Exp;
branches;
next	1.15;

1.15
date	2009.12.03.22.50.10;	author nicm;	state Exp;
branches;
next	1.14;

1.14
date	2009.11.18.13.16.33;	author nicm;	state Exp;
branches;
next	1.13;

1.13
date	2009.11.13.07.00.54;	author nicm;	state Exp;
branches;
next	1.12;

1.12
date	2009.10.06.07.19.32;	author nicm;	state Exp;
branches;
next	1.11;

1.11
date	2009.08.31.20.46.19;	author nicm;	state Exp;
branches;
next	1.10;

1.10
date	2009.08.25.12.18.51;	author nicm;	state Exp;
branches;
next	1.9;

1.9
date	2009.08.23.16.45.00;	author nicm;	state Exp;
branches;
next	1.8;

1.8
date	2009.07.24.14.52.47;	author nicm;	state Exp;
branches;
next	1.7;

1.7
date	2009.07.21.17.57.29;	author nicm;	state Exp;
branches;
next	1.6;

1.6
date	2009.07.19.13.21.40;	author nicm;	state Exp;
branches;
next	1.5;

1.5
date	2009.07.17.18.45.08;	author nicm;	state Exp;
branches;
next	1.4;

1.4
date	2009.07.17.13.43.07;	author nicm;	state Exp;
branches;
next	1.3;

1.3
date	2009.07.15.17.39.00;	author nicm;	state Exp;
branches;
next	1.2;

1.2
date	2009.07.12.17.33.18;	author nicm;	state Exp;
branches;
next	1.1;

1.1
date	2009.06.01.22.58.49;	author nicm;	state Exp;
branches;
next	;


desc
@@


1.73
log
@Cancel key table when switching session, unless the key is going to
repeat. Reported by Amos Bird.
@
text
@/* $OpenBSD: key-bindings.c,v 1.72 2017/01/24 19:53:37 nicm Exp $ */

/*
 * Copyright (c) 2007 Nicholas Marriott <nicholas.marriott@@gmail.com>
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF MIND, USE, DATA OR PROFITS, WHETHER
 * IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING
 * OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */

#include <sys/types.h>

#include <ctype.h>
#include <stdlib.h>
#include <string.h>

#include "tmux.h"

RB_GENERATE(key_bindings, key_binding, entry, key_bindings_cmp);
RB_GENERATE(key_tables, key_table, entry, key_table_cmp);
struct key_tables key_tables = RB_INITIALIZER(&key_tables);

int
key_table_cmp(struct key_table *e1, struct key_table *e2)
{
	return (strcmp(e1->name, e2->name));
}

int
key_bindings_cmp(struct key_binding *bd1, struct key_binding *bd2)
{
	if (bd1->key < bd2->key)
		return (-1);
	if (bd1->key > bd2->key)
		return (1);
	return (0);
}

struct key_table *
key_bindings_get_table(const char *name, int create)
{
	struct key_table	table_find, *table;

	table_find.name = name;
	table = RB_FIND(key_tables, &key_tables, &table_find);
	if (table != NULL || !create)
		return (table);

	table = xmalloc(sizeof *table);
	table->name = xstrdup(name);
	RB_INIT(&table->key_bindings);

	table->references = 1; /* one reference in key_tables */
	RB_INSERT(key_tables, &key_tables, table);

	return (table);
}

void
key_bindings_unref_table(struct key_table *table)
{
	struct key_binding	*bd;
	struct key_binding	*bd1;

	if (--table->references != 0)
		return;

	RB_FOREACH_SAFE(bd, key_bindings, &table->key_bindings, bd1) {
		RB_REMOVE(key_bindings, &table->key_bindings, bd);
		cmd_list_free(bd->cmdlist);
		free(bd);
	}

	free((void *)table->name);
	free(table);
}

void
key_bindings_add(const char *name, key_code key, int can_repeat,
    struct cmd_list *cmdlist)
{
	struct key_table	*table;
	struct key_binding	 bd_find, *bd;

	table = key_bindings_get_table(name, 1);

	bd_find.key = key;
	bd = RB_FIND(key_bindings, &table->key_bindings, &bd_find);
	if (bd != NULL) {
		RB_REMOVE(key_bindings, &table->key_bindings, bd);
		cmd_list_free(bd->cmdlist);
		free(bd);
	}

	bd = xmalloc(sizeof *bd);
	bd->key = key;
	RB_INSERT(key_bindings, &table->key_bindings, bd);

	bd->can_repeat = can_repeat;
	bd->cmdlist = cmdlist;
}

void
key_bindings_remove(const char *name, key_code key)
{
	struct key_table	*table;
	struct key_binding	 bd_find, *bd;

	table = key_bindings_get_table(name, 0);
	if (table == NULL)
		return;

	bd_find.key = key;
	bd = RB_FIND(key_bindings, &table->key_bindings, &bd_find);
	if (bd == NULL)
		return;

	RB_REMOVE(key_bindings, &table->key_bindings, bd);
	cmd_list_free(bd->cmdlist);
	free(bd);

	if (RB_EMPTY(&table->key_bindings)) {
		RB_REMOVE(key_tables, &key_tables, table);
		key_bindings_unref_table(table);
	}
}

void
key_bindings_remove_table(const char *name)
{
	struct key_table	*table;

	table = key_bindings_get_table(name, 0);
	if (table != NULL) {
		RB_REMOVE(key_tables, &key_tables, table);
		key_bindings_unref_table(table);
	}
}

void
key_bindings_init(void)
{
	static const char *defaults[] = {
		"bind C-b send-prefix",
		"bind C-o rotate-window",
		"bind C-z suspend-client",
		"bind Space next-layout",
		"bind ! break-pane",
		"bind '\"' split-window",
		"bind '#' list-buffers",
		"bind '$' command-prompt -I'#S' \"rename-session '%%'\"",
		"bind % split-window -h",
		"bind & confirm-before -p\"kill-window #W? (y/n)\" kill-window",
		"bind \"'\" command-prompt -pindex \"select-window -t ':%%'\"",
		"bind ( switch-client -p",
		"bind ) switch-client -n",
		"bind , command-prompt -I'#W' \"rename-window '%%'\"",
		"bind - delete-buffer",
		"bind . command-prompt \"move-window -t '%%'\"",
		"bind 0 select-window -t:=0",
		"bind 1 select-window -t:=1",
		"bind 2 select-window -t:=2",
		"bind 3 select-window -t:=3",
		"bind 4 select-window -t:=4",
		"bind 5 select-window -t:=5",
		"bind 6 select-window -t:=6",
		"bind 7 select-window -t:=7",
		"bind 8 select-window -t:=8",
		"bind 9 select-window -t:=9",
		"bind : command-prompt",
		"bind \\; last-pane",
		"bind = choose-buffer",
		"bind ? list-keys",
		"bind D choose-client",
		"bind L switch-client -l",
		"bind M select-pane -M",
		"bind [ copy-mode",
		"bind ] paste-buffer",
		"bind c new-window",
		"bind d detach-client",
		"bind f command-prompt \"find-window '%%'\"",
		"bind i display-message",
		"bind l last-window",
		"bind m select-pane -m",
		"bind n next-window",
		"bind o select-pane -t:.+",
		"bind p previous-window",
		"bind q display-panes",
		"bind r refresh-client",
		"bind s choose-tree",
		"bind t clock-mode",
		"bind w choose-window",
		"bind x confirm-before -p\"kill-pane #P? (y/n)\" kill-pane",
		"bind z resize-pane -Z",
		"bind { swap-pane -U",
		"bind } swap-pane -D",
		"bind '~' show-messages",
		"bind PPage copy-mode -u",
		"bind -r Up select-pane -U",
		"bind -r Down select-pane -D",
		"bind -r Left select-pane -L",
		"bind -r Right select-pane -R",
		"bind M-1 select-layout even-horizontal",
		"bind M-2 select-layout even-vertical",
		"bind M-3 select-layout main-horizontal",
		"bind M-4 select-layout main-vertical",
		"bind M-5 select-layout tiled",
		"bind M-n next-window -a",
		"bind M-o rotate-window -D",
		"bind M-p previous-window -a",
		"bind -r M-Up resize-pane -U 5",
		"bind -r M-Down resize-pane -D 5",
		"bind -r M-Left resize-pane -L 5",
		"bind -r M-Right resize-pane -R 5",
		"bind -r C-Up resize-pane -U",
		"bind -r C-Down resize-pane -D",
		"bind -r C-Left resize-pane -L",
		"bind -r C-Right resize-pane -R",
		"bind -n MouseDown1Pane select-pane -t=\\; send-keys -M",
		"bind -n MouseDrag1Border resize-pane -M",
		"bind -n MouseDown1Status select-window -t=",
		"bind -n WheelDownStatus next-window",
		"bind -n WheelUpStatus previous-window",
		"bind -n MouseDrag1Pane if -Ft= '#{mouse_any_flag}' 'if -Ft= \"#{pane_in_mode}\" \"copy-mode -M\" \"send-keys -M\"' 'copy-mode -M'",
		"bind -n MouseDown3Pane if-shell -Ft= '#{mouse_any_flag}' 'select-pane -t=; send-keys -M' 'select-pane -mt='",
		"bind -n WheelUpPane if-shell -Ft= '#{mouse_any_flag}' 'send-keys -M' 'if -Ft= \"#{pane_in_mode}\" \"send-keys -M\" \"copy-mode -et=\"'",

		"bind -Tcopy-mode C-Space send -X begin-selection",
		"bind -Tcopy-mode C-a send -X start-of-line",
		"bind -Tcopy-mode C-c send -X cancel",
		"bind -Tcopy-mode C-e send -X end-of-line",
		"bind -Tcopy-mode C-f send -X cursor-right",
		"bind -Tcopy-mode C-b send -X cursor-left",
		"bind -Tcopy-mode C-g send -X clear-selection",
		"bind -Tcopy-mode C-k send -X copy-end-of-line",
		"bind -Tcopy-mode C-n send -X cursor-down",
		"bind -Tcopy-mode C-p send -X cursor-up",
		"bind -Tcopy-mode C-r command-prompt -ip'search up' 'send -X search-backward-incremental \"%%%\"'",
		"bind -Tcopy-mode C-s command-prompt -ip'search down' 'send -X search-forward-incremental \"%%%\"'",
		"bind -Tcopy-mode C-v send -X page-down",
		"bind -Tcopy-mode C-w send -X copy-selection-and-cancel",
		"bind -Tcopy-mode Escape send -X cancel",
		"bind -Tcopy-mode Space send -X page-down",
		"bind -Tcopy-mode , send -X jump-reverse",
		"bind -Tcopy-mode \\; send -X jump-again",
		"bind -Tcopy-mode F command-prompt -1p'jump backward' 'send -X jump-backward \"%%%\"'",
		"bind -Tcopy-mode N send -X search-reverse",
		"bind -Tcopy-mode R send -X rectangle-toggle",
		"bind -Tcopy-mode T command-prompt -1p'jump to backward' 'send -X jump-to-backward \"%%%\"'",
		"bind -Tcopy-mode f command-prompt -1p'jump forward' 'send -X jump-forward \"%%%\"'",
		"bind -Tcopy-mode g command-prompt -p'goto line' 'send -X goto-line \"%%%\"'",
		"bind -Tcopy-mode n send -X search-again",
		"bind -Tcopy-mode q send -X cancel",
		"bind -Tcopy-mode t command-prompt -1p'jump to forward' 'send -X jump-to-forward \"%%%\"'",
		"bind -Tcopy-mode MouseDown1Pane select-pane",
		"bind -Tcopy-mode MouseDrag1Pane select-pane\\; send -X begin-selection",
		"bind -Tcopy-mode MouseDragEnd1Pane send -X copy-selection-and-cancel",
		"bind -Tcopy-mode WheelUpPane select-pane\\; send -N5 -X scroll-up",
		"bind -Tcopy-mode WheelDownPane select-pane\\; send -N5 -X scroll-down",
		"bind -Tcopy-mode DoubleClick1Pane select-pane\\; send -X select-word",
		"bind -Tcopy-mode TripleClick1Pane select-pane\\; send -X select-line",
		"bind -Tcopy-mode NPage send -X page-down",
		"bind -Tcopy-mode PPage send -X page-up",
		"bind -Tcopy-mode Up send -X cursor-up",
		"bind -Tcopy-mode Down send -X cursor-down",
		"bind -Tcopy-mode Left send -X cursor-left",
		"bind -Tcopy-mode Right send -X cursor-right",
		"bind -Tcopy-mode M-1 command-prompt -Np'repeat' -I1 'send -N \"%%%\"'",
		"bind -Tcopy-mode M-2 command-prompt -Np'repeat' -I2 'send -N \"%%%\"'",
		"bind -Tcopy-mode M-3 command-prompt -Np'repeat' -I3 'send -N \"%%%\"'",
		"bind -Tcopy-mode M-4 command-prompt -Np'repeat' -I4 'send -N \"%%%\"'",
		"bind -Tcopy-mode M-5 command-prompt -Np'repeat' -I5 'send -N \"%%%\"'",
		"bind -Tcopy-mode M-6 command-prompt -Np'repeat' -I6 'send -N \"%%%\"'",
		"bind -Tcopy-mode M-7 command-prompt -Np'repeat' -I7 'send -N \"%%%\"'",
		"bind -Tcopy-mode M-8 command-prompt -Np'repeat' -I8 'send -N \"%%%\"'",
		"bind -Tcopy-mode M-9 command-prompt -Np'repeat' -I9 'send -N \"%%%\"'",
		"bind -Tcopy-mode M-< send -X history-top",
		"bind -Tcopy-mode M-> send -X history-bottom",
		"bind -Tcopy-mode M-R send -X top-line",
		"bind -Tcopy-mode M-b send -X previous-word",
		"bind -Tcopy-mode M-f send -X next-word-end",
		"bind -Tcopy-mode M-m send -X back-to-indentation",
		"bind -Tcopy-mode M-r send -X middle-line",
		"bind -Tcopy-mode M-v send -X page-up",
		"bind -Tcopy-mode M-w send -X copy-selection-and-cancel",
		"bind -Tcopy-mode M-{ send -X previous-paragraph",
		"bind -Tcopy-mode M-} send -X next-paragraph",
		"bind -Tcopy-mode M-Up send -X halfpage-up",
		"bind -Tcopy-mode M-Down send -X halfpage-down",
		"bind -Tcopy-mode C-Up send -X scroll-up",
		"bind -Tcopy-mode C-Down send -X scroll-down",

		"bind -Tcopy-mode-vi C-c send -X cancel",
		"bind -Tcopy-mode-vi C-d send -X halfpage-down",
		"bind -Tcopy-mode-vi C-e send -X scroll-down",
		"bind -Tcopy-mode-vi C-b send -X page-up",
		"bind -Tcopy-mode-vi C-f send -X page-down",
		"bind -Tcopy-mode-vi C-h send -X cursor-left",
		"bind -Tcopy-mode-vi C-j send -X copy-selection-and-cancel",
		"bind -Tcopy-mode-vi Enter send -X copy-selection-and-cancel",
		"bind -Tcopy-mode-vi C-u send -X halfpage-up",
		"bind -Tcopy-mode-vi C-v send -X rectangle-toggle",
		"bind -Tcopy-mode-vi C-y send -X scroll-up",
		"bind -Tcopy-mode-vi Escape send -X clear-selection",
		"bind -Tcopy-mode-vi Space send -X begin-selection",
		"bind -Tcopy-mode-vi '$' send -X end-of-line",
		"bind -Tcopy-mode-vi , send -X jump-reverse",
		"bind -Tcopy-mode-vi / command-prompt -p'search down' 'send -X search-forward \"%%%\"'",
		"bind -Tcopy-mode-vi 0 send -X start-of-line",
		"bind -Tcopy-mode-vi 1 command-prompt -Np'repeat' -I1 'send -N \"%%%\"'",
		"bind -Tcopy-mode-vi 2 command-prompt -Np'repeat' -I2 'send -N \"%%%\"'",
		"bind -Tcopy-mode-vi 3 command-prompt -Np'repeat' -I3 'send -N \"%%%\"'",
		"bind -Tcopy-mode-vi 4 command-prompt -Np'repeat' -I4 'send -N \"%%%\"'",
		"bind -Tcopy-mode-vi 5 command-prompt -Np'repeat' -I5 'send -N \"%%%\"'",
		"bind -Tcopy-mode-vi 6 command-prompt -Np'repeat' -I6 'send -N \"%%%\"'",
		"bind -Tcopy-mode-vi 7 command-prompt -Np'repeat' -I7 'send -N \"%%%\"'",
		"bind -Tcopy-mode-vi 8 command-prompt -Np'repeat' -I8 'send -N \"%%%\"'",
		"bind -Tcopy-mode-vi 9 command-prompt -Np'repeat' -I9 'send -N \"%%%\"'",
		"bind -Tcopy-mode-vi : command-prompt -p'goto line' 'send -X goto-line \"%%%\"'",
		"bind -Tcopy-mode-vi \\; send -X jump-again",
		"bind -Tcopy-mode-vi ? command-prompt -p'search up' 'send -X search-backward \"%%%\"'",
		"bind -Tcopy-mode-vi A send -X append-selection-and-cancel",
		"bind -Tcopy-mode-vi B send -X previous-space",
		"bind -Tcopy-mode-vi D send -X copy-end-of-line",
		"bind -Tcopy-mode-vi E send -X next-space-end",
		"bind -Tcopy-mode-vi F command-prompt -1p'jump backward' 'send -X jump-backward \"%%%\"'",
		"bind -Tcopy-mode-vi G send -X history-bottom",
		"bind -Tcopy-mode-vi H send -X top-line",
		"bind -Tcopy-mode-vi J send -X scroll-down",
		"bind -Tcopy-mode-vi K send -X scroll-up",
		"bind -Tcopy-mode-vi L send -X bottom-line",
		"bind -Tcopy-mode-vi M send -X middle-line",
		"bind -Tcopy-mode-vi N send -X search-reverse",
		"bind -Tcopy-mode-vi T command-prompt -1p'jump to backward' 'send -X jump-to-backward \"%%%\"'",
		"bind -Tcopy-mode-vi V send -X select-line",
		"bind -Tcopy-mode-vi W send -X next-space",
		"bind -Tcopy-mode-vi ^ send -X back-to-indentation",
		"bind -Tcopy-mode-vi b send -X previous-word",
		"bind -Tcopy-mode-vi e send -X next-word-end",
		"bind -Tcopy-mode-vi f command-prompt -1p'jump forward' 'send -X jump-forward \"%%%\"'",
		"bind -Tcopy-mode-vi g send -X history-top",
		"bind -Tcopy-mode-vi h send -X cursor-left",
		"bind -Tcopy-mode-vi j send -X cursor-down",
		"bind -Tcopy-mode-vi k send -X cursor-up",
		"bind -Tcopy-mode-vi l send -X cursor-right",
		"bind -Tcopy-mode-vi n send -X search-again",
		"bind -Tcopy-mode-vi o send -X other-end",
		"bind -Tcopy-mode-vi q send -X cancel",
		"bind -Tcopy-mode-vi t command-prompt -1p'jump to forward' 'send -X jump-to-forward \"%%%\"'",
		"bind -Tcopy-mode-vi v send -X rectangle-toggle",
		"bind -Tcopy-mode-vi w send -X next-word",
		"bind -Tcopy-mode-vi { send -X previous-paragraph",
		"bind -Tcopy-mode-vi } send -X next-paragraph",
		"bind -Tcopy-mode-vi MouseDown1Pane select-pane",
		"bind -Tcopy-mode-vi MouseDrag1Pane select-pane\\; send -X begin-selection",
		"bind -Tcopy-mode-vi MouseDragEnd1Pane send -X copy-selection-and-cancel",
		"bind -Tcopy-mode-vi WheelUpPane select-pane\\; send -N5 -X scroll-up",
		"bind -Tcopy-mode-vi WheelDownPane select-pane\\; send -N5 -X scroll-down",
		"bind -Tcopy-mode-vi DoubleClick1Pane select-pane\\; send -X select-word",
		"bind -Tcopy-mode-vi TripleClick1Pane select-pane\\; send -X select-line",
		"bind -Tcopy-mode-vi BSpace send -X cursor-left",
		"bind -Tcopy-mode-vi NPage send -X page-down",
		"bind -Tcopy-mode-vi PPage send -X page-up",
		"bind -Tcopy-mode-vi Up send -X cursor-up",
		"bind -Tcopy-mode-vi Down send -X cursor-down",
		"bind -Tcopy-mode-vi Left send -X cursor-left",
		"bind -Tcopy-mode-vi Right send -X cursor-right",
		"bind -Tcopy-mode-vi C-Up send -X scroll-up",
		"bind -Tcopy-mode-vi C-Down send -X scroll-down",
	};
	u_int		 i;
	struct cmd_list	*cmdlist;
	char		*cause;

	for (i = 0; i < nitems(defaults); i++) {
		cmdlist = cmd_string_parse(defaults[i], "<default>", i, &cause);
		if (cmdlist == NULL)
			fatalx("bad default key: %s", defaults[i]);
		cmdq_append(NULL, cmdq_get_command(cmdlist, NULL, NULL, 0));
		cmd_list_free(cmdlist);
	}
}

static enum cmd_retval
key_bindings_read_only(struct cmdq_item *item, __unused void *data)
{
	cmdq_error(item, "client is read-only");
	return (CMD_RETURN_ERROR);
}

void
key_bindings_dispatch(struct key_binding *bd, struct client *c,
    struct mouse_event *m, struct cmd_find_state *fs)
{
	struct cmd		*cmd;
	struct cmdq_item	*item;
	int			 readonly;

	readonly = 1;
	TAILQ_FOREACH(cmd, &bd->cmdlist->list, qentry) {
		if (!(cmd->entry->flags & CMD_READONLY))
			readonly = 0;
	}
	if (!readonly && (c->flags & CLIENT_READONLY))
		cmdq_append(c, cmdq_get_callback(key_bindings_read_only, NULL));
	else {
		item = cmdq_get_command(bd->cmdlist, fs, m, 0);
		item->repeat = bd->can_repeat;
		cmdq_append(c, item);
	}
}
@


1.72
log
@Add support for custom command aliases, this is an array option which
contains items of the form "alias=command". This is consulted when an
unknown command is parsed.
@
text
@d1 1
a1 1
/* $OpenBSD: key-bindings.c,v 1.71 2017/01/16 14:52:25 nicm Exp $ */
d403 3
a405 2
	struct cmd	*cmd;
	int		 readonly;
d414 5
a418 2
	else
		cmdq_append(c, cmdq_get_command(bd->cmdlist, fs, m, 0));
@


1.71
log
@Revert WIP parts of previous I didn't mean to commit yet.
@
text
@d1 1
a1 1
/* $OpenBSD: key-bindings.c,v 1.69 2017/01/15 22:00:56 nicm Exp $ */
d386 1
a386 1
			fatalx("bad default key");
@


1.70
log
@getopt() has a struct option so just return to using options_entry.
@
text
@d386 1
a386 1
			fatalx("bad default key: %s", defaults[i]);
@


1.69
log
@It is silly for cmd_list_parse to return an integer error when it could
just return NULL.
@
text
@d1 1
a1 1
/* $OpenBSD: key-bindings.c,v 1.68 2017/01/06 11:57:03 nicm Exp $ */
d386 1
a386 1
			fatalx("bad default key");
@


1.68
log
@Incremental search in copy mode (on for emacs keys by default) - much
the same as normal searching but updates the cursor position and marked
search terms as you type. C-r and C-s in the prompt repeat the search,
once finished searching (with Enter), N and n work as before.
@
text
@d1 1
a1 1
/* $OpenBSD: key-bindings.c,v 1.67 2016/12/07 09:16:13 nicm Exp $ */
a381 1
	int		 error;
d384 2
a385 3
		error = cmd_string_parse(defaults[i], &cmdlist,
		    "<default-keys>", i, &cause);
		if (error != 0)
@


1.67
log
@Make prefix work in all tables (except the prefix table). Users who want
to avoid this can set prefix to "none" and bind send-prefix
themselves. Allows C-b t be bound in the copy mode tables again, pointed
out by millert@@.
@
text
@d1 1
a1 1
/* $OpenBSD: key-bindings.c,v 1.66 2016/11/24 13:46:50 nicm Exp $ */
d246 2
a247 2
		"bind -Tcopy-mode C-r command-prompt -p'search up' \"send -X search-backward \\\"%%%\\\"\"",
		"bind -Tcopy-mode C-s command-prompt -p'search down' \"send -X search-forward \\\"%%%\\\"\"",
d254 1
a254 1
		"bind -Tcopy-mode F command-prompt -1p'jump backward' \"send -X jump-backward \\\"%%%\\\"\"",
d257 3
a259 3
		"bind -Tcopy-mode T command-prompt -1p'jump to backward' \"send -X jump-to-backward \\\"%%%\\\"\"",
		"bind -Tcopy-mode f command-prompt -1p'jump forward' \"send -X jump-forward \\\"%%%\\\"\"",
		"bind -Tcopy-mode g command-prompt -p'goto line' \"send -X goto-line '%%'\"",
d262 1
a262 1
		"bind -Tcopy-mode t command-prompt -1p'jump to forward' \"send -X jump-to-forward \\\"%%%\\\"\"",
d276 9
a284 9
		"bind -Tcopy-mode M-1 command-prompt -Np'repeat' -I1 \"send -N '%%'\"",
		"bind -Tcopy-mode M-2 command-prompt -Np'repeat' -I2 \"send -N '%%'\"",
		"bind -Tcopy-mode M-3 command-prompt -Np'repeat' -I3 \"send -N '%%'\"",
		"bind -Tcopy-mode M-4 command-prompt -Np'repeat' -I4 \"send -N '%%'\"",
		"bind -Tcopy-mode M-5 command-prompt -Np'repeat' -I5 \"send -N '%%'\"",
		"bind -Tcopy-mode M-6 command-prompt -Np'repeat' -I6 \"send -N '%%'\"",
		"bind -Tcopy-mode M-7 command-prompt -Np'repeat' -I7 \"send -N '%%'\"",
		"bind -Tcopy-mode M-8 command-prompt -Np'repeat' -I8 \"send -N '%%'\"",
		"bind -Tcopy-mode M-9 command-prompt -Np'repeat' -I9 \"send -N '%%'\"",
d316 1
a316 1
		"bind -Tcopy-mode-vi / command-prompt -p'search down' \"send -X search-forward \\\"%%%\\\"\"",
d318 10
a327 10
		"bind -Tcopy-mode-vi 1 command-prompt -Np'repeat' -I1 \"send -N '%%'\"",
		"bind -Tcopy-mode-vi 2 command-prompt -Np'repeat' -I2 \"send -N '%%'\"",
		"bind -Tcopy-mode-vi 3 command-prompt -Np'repeat' -I3 \"send -N '%%'\"",
		"bind -Tcopy-mode-vi 4 command-prompt -Np'repeat' -I4 \"send -N '%%'\"",
		"bind -Tcopy-mode-vi 5 command-prompt -Np'repeat' -I5 \"send -N '%%'\"",
		"bind -Tcopy-mode-vi 6 command-prompt -Np'repeat' -I6 \"send -N '%%'\"",
		"bind -Tcopy-mode-vi 7 command-prompt -Np'repeat' -I7 \"send -N '%%'\"",
		"bind -Tcopy-mode-vi 8 command-prompt -Np'repeat' -I8 \"send -N '%%'\"",
		"bind -Tcopy-mode-vi 9 command-prompt -Np'repeat' -I9 \"send -N '%%'\"",
		"bind -Tcopy-mode-vi : command-prompt -p'goto line' \"send -X goto-line '%%'\"",
d329 1
a329 1
		"bind -Tcopy-mode-vi ? command-prompt -p'search up' \"send -X search-backward \\\"%%%\\\"\"",
d334 1
a334 1
		"bind -Tcopy-mode-vi F command-prompt -1p'jump backward' \"send -X jump-backward \\\"%%%\\\"\"",
d342 1
a342 1
		"bind -Tcopy-mode-vi T command-prompt -1p'jump to backward' \"send -X jump-to-backward \\\"%%%\\\"\"",
d348 1
a348 1
		"bind -Tcopy-mode-vi f command-prompt -1p'jump forward' \"send -X jump-forward \\\"%%%\\\"\"",
d357 1
a357 1
		"bind -Tcopy-mode-vi t command-prompt -1p'jump to forward' \"send -X jump-to-forward \\\"%%%\\\"\"",
@


1.66
log
@Fix so that we work out the right pane from mouse events - we were doing
so too early, before the mouse event was necessarily valid, so could end
up using the pane from the previous mouse event, or the active pane.

It is important that we use the right pane now that different panes can
have different key tables (for copy mode).

Fixes problem reported by Greg Hurrell.
@
text
@d1 1
a1 1
/* $OpenBSD: key-bindings.c,v 1.65 2016/11/23 17:01:24 nicm Exp $ */
d241 1
d304 1
@


1.65
log
@For mouse keys, use the mouse pane as the default current pane.
@
text
@d1 1
a1 1
/* $OpenBSD: key-bindings.c,v 1.64 2016/10/21 13:51:59 nicm Exp $ */
d262 2
a263 1
		"bind -Tcopy-mode MouseDrag1Pane send -X begin-selection",
d265 4
a268 4
		"bind -Tcopy-mode WheelUpPane send -N5 -X scroll-up",
		"bind -Tcopy-mode WheelDownPane send -N5 -X scroll-down",
		"bind -Tcopy-mode DoubleClick1Pane send -X select-word",
		"bind -Tcopy-mode TripleClick1Pane send -X select-line",
d360 2
a361 1
		"bind -Tcopy-mode-vi MouseDrag1Pane send -X begin-selection",
d363 4
a366 4
		"bind -Tcopy-mode-vi WheelUpPane send -N5 -X scroll-up",
		"bind -Tcopy-mode-vi WheelDownPane send -N5 -X scroll-down",
		"bind -Tcopy-mode-vi DoubleClick1Pane send -X select-word",
		"bind -Tcopy-mode-vi TripleClick1Pane send -X select-line",
@


1.64
log
@Add %%% to substitute with quotes escaped (convert " to \"). Use this
for the prompts in copy mode. Fixes problems with jumping to ' reported
by Theo Buehler.
@
text
@d1 1
a1 1
/* $OpenBSD: key-bindings.c,v 1.63 2016/10/19 09:24:57 nicm Exp $ */
d399 1
a399 1
    struct mouse_event *m)
d412 1
a412 1
		cmdq_append(c, cmdq_get_command(bd->cmdlist, NULL, m, 0));
@


1.63
log
@Do not have a default binding for C-b in copy-mode-vi or it conflicts
with the default prefix. Reported by natano@@.
@
text
@d1 1
a1 1
/* $OpenBSD: key-bindings.c,v 1.62 2016/10/16 19:04:05 nicm Exp $ */
d245 2
a246 2
		"bind -Tcopy-mode C-r command-prompt -p'search up' \"send -X search-backward '%%'\"",
		"bind -Tcopy-mode C-s command-prompt -p'search down' \"send -X search-forward '%%'\"",
d253 1
a253 1
		"bind -Tcopy-mode F command-prompt -1p'jump backward' \"send -X jump-backward '%%'\"",
d256 2
a257 2
		"bind -Tcopy-mode T command-prompt -1p'jump to backward' \"send -X jump-to-backward '%%'\"",
		"bind -Tcopy-mode f command-prompt -1p'jump forward' \"send -X jump-forward '%%'\"",
d261 1
a261 1
		"bind -Tcopy-mode t command-prompt -1p'jump to forward' \"send -X jump-to-forward '%%'\"",
d313 1
a313 1
		"bind -Tcopy-mode-vi / command-prompt -p'search down' \"send -X search-forward '%%'\"",
d326 1
a326 1
		"bind -Tcopy-mode-vi ? command-prompt -p'search up' \"send -X search-backward '%%'\"",
d331 1
a331 1
		"bind -Tcopy-mode-vi F command-prompt -1p'jump backward' \"send -X jump-backward '%%'\"",
d339 1
a339 1
		"bind -Tcopy-mode-vi T command-prompt -1p'jump to backward' \"send -X jump-to-backward '%%'\"",
d345 1
a345 1
		"bind -Tcopy-mode-vi f command-prompt -1p'jump forward' \"send -X jump-forward '%%'\"",
d354 1
a354 1
		"bind -Tcopy-mode-vi t command-prompt -1p'jump to forward' \"send -X jump-to-forward '%%'\"",
@


1.62
log
@Mass rename struct cmd_q to struct cmdq_item and related.
@
text
@d1 1
a1 1
/* $OpenBSD: key-bindings.c,v 1.61 2016/10/16 17:55:14 nicm Exp $ */
a298 1
		"bind -Tcopy-mode-vi C-b send -X page-up",
@


1.61
log
@Rewrite command queue handling. Each client still has a command queue,
but there is also now a global command queue. Instead of command queues
being dispatched on demand from wherever the command happens to be
added, they are now all dispatched from the top level server
loop. Command queues may now also include callbacks as well as commands,
and items may be inserted after the current command as well as at the end.

This all makes command queues significantly more predictable and easier
to use, and avoids the complex multiple nested command queues used by
source-file, if-shell and friends.

A mass rename of struct cmdq to a better name (cmdq_item probably) is
coming.
@
text
@d1 1
a1 1
/* $OpenBSD: key-bindings.c,v 1.60 2016/10/12 13:03:27 nicm Exp $ */
d392 1
a392 1
key_bindings_read_only(struct cmd_q *cmdq, __unused void *data)
d394 1
a394 1
	cmdq_error(cmdq, "client is read-only");
@


1.60
log
@The repeat prompt in both emacs and vi (and the old one in tmux) doesn't
support line editing and instead executes a command as soon as a
non-number key is pressed. Add a -N flag to command-prompt for the same
in copy mode. Reported by Theo Buehler.
@
text
@d1 1
a1 1
/* $OpenBSD: key-bindings.c,v 1.59 2016/10/11 09:30:36 nicm Exp $ */
a379 1
	struct cmd_q	*cmdq;
a380 1
	cmdq = cmdq_new(NULL);
d386 1
a386 1
		cmdq_run(cmdq, cmdlist, NULL);
d389 7
a395 1
	cmdq_free(cmdq);
d410 4
a413 6
	if (!readonly && (c->flags & CLIENT_READONLY)) {
		cmdq_error(c->cmdq, "client is read-only");
		return;
	}

	cmdq_run(c->cmdq, bd->cmdlist, m);
@


1.59
log
@Support double and triple clicks (they are cumulative, so double is
fired then triple), and use for select-word and select-line in copy
mode. Inspired by a different solution from Omar Sandoval.
@
text
@d1 1
a1 1
/* $OpenBSD: key-bindings.c,v 1.58 2016/10/11 07:23:34 nicm Exp $ */
d274 9
a282 9
		"bind -Tcopy-mode M-1 command-prompt -p'repeat' -I1 \"send -N '%%'\"",
		"bind -Tcopy-mode M-2 command-prompt -p'repeat' -I2 \"send -N '%%'\"",
		"bind -Tcopy-mode M-3 command-prompt -p'repeat' -I3 \"send -N '%%'\"",
		"bind -Tcopy-mode M-4 command-prompt -p'repeat' -I4 \"send -N '%%'\"",
		"bind -Tcopy-mode M-5 command-prompt -p'repeat' -I5 \"send -N '%%'\"",
		"bind -Tcopy-mode M-6 command-prompt -p'repeat' -I6 \"send -N '%%'\"",
		"bind -Tcopy-mode M-7 command-prompt -p'repeat' -I7 \"send -N '%%'\"",
		"bind -Tcopy-mode M-8 command-prompt -p'repeat' -I8 \"send -N '%%'\"",
		"bind -Tcopy-mode M-9 command-prompt -p'repeat' -I9 \"send -N '%%'\"",
d316 9
a324 9
		"bind -Tcopy-mode-vi 1 command-prompt -p'repeat' -I1 \"send -N '%%'\"",
		"bind -Tcopy-mode-vi 2 command-prompt -p'repeat' -I2 \"send -N '%%'\"",
		"bind -Tcopy-mode-vi 3 command-prompt -p'repeat' -I3 \"send -N '%%'\"",
		"bind -Tcopy-mode-vi 4 command-prompt -p'repeat' -I4 \"send -N '%%'\"",
		"bind -Tcopy-mode-vi 5 command-prompt -p'repeat' -I5 \"send -N '%%'\"",
		"bind -Tcopy-mode-vi 6 command-prompt -p'repeat' -I6 \"send -N '%%'\"",
		"bind -Tcopy-mode-vi 7 command-prompt -p'repeat' -I7 \"send -N '%%'\"",
		"bind -Tcopy-mode-vi 8 command-prompt -p'repeat' -I8 \"send -N '%%'\"",
		"bind -Tcopy-mode-vi 9 command-prompt -p'repeat' -I9 \"send -N '%%'\"",
d326 1
a326 1
		"bind -Tcopy-mode-vi \\; send -X jump-again"
@


1.58
log
@Fundamental change to how copy mode key bindings work:

The vi-copy and emacs-copy mode key tables are gone, and instead copy
mode commands are bound in one of two normal key tables ("copy-mode" or
"copy-mode-vi"). Keys are bound to "send-keys -X copy-mode-command". So:

    bind -temacs-copy C-Up scroll-up
    bind -temacs-copy -R5 WheelUpPane scroll-up

Becomes:

    bind -Tcopy-mode C-Up send -X scroll-up
    bind -Tcopy-mode WheelUpPane send -N5 -X scroll-up

This allows the full command parser and command set to be used - for
example, we can use the normal command prompt for searching, jumping,
and so on instead of a custom one:

    bind -Tcopy-mode C-r command-prompt -p'search up' "send -X search-backward '%%'"

command-prompt also gets a -1 option to only require on key press, which
is needed for jumping.

The plan is to get rid of mode keys entirely, so more to come eventually.
@
text
@d1 1
a1 1
/* $OpenBSD: key-bindings.c,v 1.57 2016/03/01 12:06:07 nicm Exp $ */
d266 2
d364 2
@


1.57
log
@Remove some more unused variables, and use RB_FOREACH_SAFE in
key_bindings_unref_table.
@
text
@d1 1
a1 1
/* $OpenBSD: key-bindings.c,v 1.56 2016/01/19 15:59:12 nicm Exp $ */
d235 136
@


1.56
log
@I no longer use my SourceForge address so replace it.
@
text
@d1 1
a1 1
/* $OpenBSD: key-bindings.c,v 1.55 2015/11/12 11:05:34 nicm Exp $ */
d71 1
d76 1
a76 2
	while (!RB_EMPTY(&table->key_bindings)) {
		bd = RB_ROOT(&table->key_bindings);
@


1.55
log
@Support UTF-8 key bindings by expanding the key type from int to
uint64_t and converting UTF-8 to Unicode on input and the reverse on
output. (This allows key bindings, there are still omissions - the
largest being that the various prompts do not accept UTF-8.)
@
text
@d1 1
a1 1
/* $OpenBSD: key-bindings.c,v 1.54 2015/11/05 11:05:30 nicm Exp $ */
d4 1
a4 1
 * Copyright (c) 2007 Nicholas Marriott <nicm@@users.sourceforge.net>
@


1.54
log
@Pass through right click if mouse is on, from Patrick Palka.
@
text
@d1 1
a1 1
/* $OpenBSD: key-bindings.c,v 1.53 2015/10/27 09:15:21 nicm Exp $ */
d40 5
a44 1
	return (bd1->key - bd2->key);
d87 1
a87 1
key_bindings_add(const char *name, int key, int can_repeat,
d112 1
a112 1
key_bindings_remove(const char *name, int key)
@


1.53
log
@Use copy-mode -et= in WheelUpPane binding, from Patrick Palka.
@
text
@d1 1
a1 1
/* $OpenBSD: key-bindings.c,v 1.52 2015/10/26 23:06:18 nicm Exp $ */
d229 1
a229 1
		"bind -n MouseDown3Pane select-pane -mt=",
@


1.52
log
@Default bindings for mouse wheel on status line to change window (like
we had before), from Patrick Palka.
@
text
@d1 1
a1 1
/* $OpenBSD: key-bindings.c,v 1.51 2015/10/21 11:13:47 nicm Exp $ */
d230 1
a230 1
		"bind -n WheelUpPane if-shell -Ft= '#{mouse_any_flag}' 'send-keys -M' 'if -Ft= \"#{pane_in_mode}\" \"send-keys -M\" \"copy-mode -e\"'",
@


1.51
log
@By popular demand add a default binding for mouse wheel up to scroll
into history (if the mouse is, on of course).
@
text
@d1 1
a1 1
/* $OpenBSD: key-bindings.c,v 1.50 2015/06/05 08:14:16 nicm Exp $ */
d226 2
@


1.50
log
@Make it so that if a window or session target is prefixed with an =,
only an exact name or index match is accepted, no special character,
prefix match, or fnmatch.
@
text
@d1 1
a1 1
/* $OpenBSD: key-bindings.c,v 1.49 2015/06/04 11:43:51 nicm Exp $ */
d228 1
@


1.49
log
@Add support for a single "marked pane". There is one marked pane in the
server at a time; it may be toggled or cleared with select-pane -m and
-M (the border is highlighted). A new target '~' or '{marked}' specifies
the marked pane to commands and it is the default target for the
swap-pane and join-pane -s flag (this makes them much simpler to use -
mark the source pane and then change to the target pane to run swapp or
joinp).
@
text
@d1 1
a1 1
/* $OpenBSD: key-bindings.c,v 1.48 2015/05/07 11:42:56 nicm Exp $ */
d164 10
a173 10
		"bind 0 select-window -t:0",
		"bind 1 select-window -t:1",
		"bind 2 select-window -t:2",
		"bind 3 select-window -t:3",
		"bind 4 select-window -t:4",
		"bind 5 select-window -t:5",
		"bind 6 select-window -t:6",
		"bind 7 select-window -t:7",
		"bind 8 select-window -t:8",
		"bind 9 select-window -t:9",
@


1.48
log
@Style spacing nits.
@
text
@d1 1
a1 1
/* $OpenBSD: key-bindings.c,v 1.47 2015/04/25 18:49:01 nicm Exp $ */
d180 1
d188 1
d227 1
@


1.47
log
@Fix some char* -> char *.
@
text
@d1 1
a1 1
/* $OpenBSD: key-bindings.c,v 1.46 2015/04/21 15:34:32 nicm Exp $ */
d239 1
a239 1
		cmd_list_free (cmdlist);
@


1.46
log
@Bind mouse dragging so that it is passed through to applications if they
want it rather than entering copy mode.
@
text
@d1 1
a1 1
/* $OpenBSD: key-bindings.c,v 1.45 2015/04/20 15:34:56 nicm Exp $ */
d147 1
a147 1
	static const char* defaults[] = {
d228 1
a228 1
	char*            cause;
@


1.45
log
@Support for multiple key tables to commands to be bound to sequences of
keys. The default key bindings become the "prefix" table and -n the
"root" table. Keys may be bound in new tables with bind -T and
switch-client -T used to specify the table in which the next key should
be looked up. Based on a diff from Keith Amling.
@
text
@d1 1
a1 1
/* $OpenBSD: key-bindings.c,v 1.44 2015/04/19 21:34:21 nicm Exp $ */
d224 1
a224 1
		"bind -n MouseDrag1Pane copy-mode -M",
@


1.44
log
@Rewrite of tmux mouse support which was a mess. Instead of having
options for "mouse-this" and "mouse-that", mouse events may be bound as
keys and there is one option "mouse" that turns on mouse support
entirely (set -g mouse on).

See the new MOUSE SUPPORT section of the man page for description of the
key names and new flags (-t= to specify the pane or window under mouse
as a target, and send-keys -M to pass through a mouse event).

The default builtin bindings for the mouse are:

    bind -n   MouseDown1Pane select-pane -t=; send-keys -M
    bind -n MouseDown1Status select-window -t=
    bind -n   MouseDrag1Pane copy-mode -M
    bind -n MouseDrag1Border resize-pane -M

To get the effect of turning mode-mouse off, do:

    unbind -n MouseDrag1Pane
    unbind -temacs-copy MouseDrag1Pane

The old mouse options are now gone, set-option -q may be used to
suppress warnings if mixing configuration files.
@
text
@d1 1
a1 1
/* $OpenBSD: key-bindings.c,v 1.43 2014/10/22 23:18:53 nicm Exp $ */
d28 2
d31 5
a35 1
struct key_bindings	key_bindings;
d40 12
a51 1
	int	key1, key2;
d53 3
a55 4
	key1 = bd1->key & ~KEYC_PREFIX;
	key2 = bd2->key & ~KEYC_PREFIX;
	if (key1 != key2)
		return (key1 - key2);
d57 4
a60 5
	if (bd1->key & KEYC_PREFIX && !(bd2->key & KEYC_PREFIX))
		return (-1);
	if (bd2->key & KEYC_PREFIX && !(bd1->key & KEYC_PREFIX))
		return (1);
	return (0);
d63 2
a64 2
struct key_binding *
key_bindings_lookup(int key)
d66 11
a76 1
	struct key_binding	bd;
d78 2
a79 2
	bd.key = key;
	return (RB_FIND(key_bindings, &key_bindings, &bd));
d83 2
a84 1
key_bindings_add(int key, int can_repeat, struct cmd_list *cmdlist)
d86 4
a89 1
	struct key_binding	*bd;
d91 7
a97 1
	key_bindings_remove(key);
d101 1
a101 1
	RB_INSERT(key_bindings, &key_bindings, bd);
d108 1
a108 1
key_bindings_remove(int key)
d110 6
a115 1
	struct key_binding	*bd;
d117 3
a119 1
	if ((bd = key_bindings_lookup(key)) == NULL)
d121 2
a122 1
	RB_REMOVE(key_bindings, &key_bindings, bd);
d125 17
a230 2

	RB_INIT(&key_bindings);
@


1.43
log
@Fix some spacing nits.
@
text
@d1 1
a1 1
/* $OpenBSD: key-bindings.c,v 1.42 2014/10/20 22:29:25 nicm Exp $ */
d161 4
d180 2
a181 2
		cmdq_run(cmdq, cmdlist);
		cmd_list_free(cmdlist);
d187 2
a188 1
key_bindings_dispatch(struct key_binding *bd, struct client *c)
d203 1
a203 1
	cmdq_run(c->cmdq, bd->cmdlist);
@


1.42
log
@Instead of setting up the default keys by building the key struct
directly with a helper function in the cmd_entry, include a table of
bind-key commands and pass them through the command parser and a
temporary cmd_q.

As well as being smaller, this will allow default bindings to be command
sequences which will probably be needed soon.
@
text
@d1 1
a1 1
/* $OpenBSD: key-bindings.c,v 1.41 2014/05/14 06:21:19 nicm Exp $ */
d170 1
a170 1
	cmdq = cmdq_new (NULL);
d176 2
a177 2
		cmdq_run (cmdq, cmdlist);
		cmd_list_free (cmdlist);
d179 1
a179 1
	cmdq_free (cmdq);
@


1.41
log
@Now that cmdlists are reference counted, there is no need for two-step
deletion via the dead_key_bindings tree. From Keith Amling.
@
text
@d1 1
a1 1
/* $OpenBSD: key-bindings.c,v 1.40 2014/04/17 07:55:43 nicm Exp $ */
d87 74
a160 78
	static const struct {
		int			 key;
		int			 can_repeat;
		const struct cmd_entry	*entry;
	} table[] = {
		{ ' ',			  0, &cmd_next_layout_entry },
		{ '!', 			  0, &cmd_break_pane_entry },
		{ '"', 			  0, &cmd_split_window_entry },
		{ '#', 			  0, &cmd_list_buffers_entry },
		{ '$',			  0, &cmd_command_prompt_entry },
		{ '%', 			  0, &cmd_split_window_entry },
		{ '&', 			  0, &cmd_confirm_before_entry },
		{ '(',                    0, &cmd_switch_client_entry },
		{ ')',                    0, &cmd_switch_client_entry },
		{ ',', 			  0, &cmd_command_prompt_entry },
		{ '-', 			  0, &cmd_delete_buffer_entry },
		{ '.', 			  0, &cmd_command_prompt_entry },
		{ '0', 			  0, &cmd_select_window_entry },
		{ '1', 			  0, &cmd_select_window_entry },
		{ '2', 			  0, &cmd_select_window_entry },
		{ '3', 			  0, &cmd_select_window_entry },
		{ '4', 			  0, &cmd_select_window_entry },
		{ '5', 			  0, &cmd_select_window_entry },
		{ '6', 			  0, &cmd_select_window_entry },
		{ '7', 			  0, &cmd_select_window_entry },
		{ '8', 			  0, &cmd_select_window_entry },
		{ '9', 			  0, &cmd_select_window_entry },
		{ ':', 			  0, &cmd_command_prompt_entry },
		{ ';', 			  0, &cmd_last_pane_entry },
		{ '=', 			  0, &cmd_choose_buffer_entry },
		{ '?', 			  0, &cmd_list_keys_entry },
		{ 'D',			  0, &cmd_choose_client_entry },
		{ 'L',			  0, &cmd_switch_client_entry },
		{ '[', 			  0, &cmd_copy_mode_entry },
		{ '\'',			  0, &cmd_command_prompt_entry },
		{ '\002', /* C-b */	  0, &cmd_send_prefix_entry },
		{ '\017', /* C-o */	  0, &cmd_rotate_window_entry },
		{ '\032', /* C-z */	  0, &cmd_suspend_client_entry },
		{ ']', 			  0, &cmd_paste_buffer_entry },
		{ 'c', 			  0, &cmd_new_window_entry },
		{ 'd', 			  0, &cmd_detach_client_entry },
		{ 'f', 			  0, &cmd_command_prompt_entry },
		{ 'i',			  0, &cmd_display_message_entry },
		{ 'l', 			  0, &cmd_last_window_entry },
		{ 'n', 			  0, &cmd_next_window_entry },
		{ 'o', 			  0, &cmd_select_pane_entry },
		{ 'p', 			  0, &cmd_previous_window_entry },
		{ 'q',			  0, &cmd_display_panes_entry },
		{ 'r', 			  0, &cmd_refresh_client_entry },
		{ 's', 			  0, &cmd_choose_tree_entry },
		{ 't', 			  0, &cmd_clock_mode_entry },
		{ 'w', 			  0, &cmd_choose_window_entry },
		{ 'x', 			  0, &cmd_confirm_before_entry },
		{ 'z',			  0, &cmd_resize_pane_entry },
		{ '{',			  0, &cmd_swap_pane_entry },
		{ '}',			  0, &cmd_swap_pane_entry },
		{ '~',			  0, &cmd_show_messages_entry },
		{ '1' | KEYC_ESCAPE,	  0, &cmd_select_layout_entry },
		{ '2' | KEYC_ESCAPE,	  0, &cmd_select_layout_entry },
		{ '3' | KEYC_ESCAPE,	  0, &cmd_select_layout_entry },
		{ '4' | KEYC_ESCAPE,	  0, &cmd_select_layout_entry },
		{ '5' | KEYC_ESCAPE,	  0, &cmd_select_layout_entry },
		{ KEYC_PPAGE, 		  0, &cmd_copy_mode_entry },
		{ 'n' | KEYC_ESCAPE, 	  0, &cmd_next_window_entry },
		{ 'o' | KEYC_ESCAPE,	  0, &cmd_rotate_window_entry },
		{ 'p' | KEYC_ESCAPE, 	  0, &cmd_previous_window_entry },
		{ KEYC_UP, 		  1, &cmd_select_pane_entry },
		{ KEYC_DOWN, 		  1, &cmd_select_pane_entry },
		{ KEYC_LEFT, 		  1, &cmd_select_pane_entry },
		{ KEYC_RIGHT, 		  1, &cmd_select_pane_entry },
		{ KEYC_UP | KEYC_ESCAPE,  1, &cmd_resize_pane_entry },
		{ KEYC_DOWN | KEYC_ESCAPE,  1, &cmd_resize_pane_entry },
		{ KEYC_LEFT | KEYC_ESCAPE,  1, &cmd_resize_pane_entry },
		{ KEYC_RIGHT | KEYC_ESCAPE, 1, &cmd_resize_pane_entry },
		{ KEYC_UP | KEYC_CTRL,    1, &cmd_resize_pane_entry },
		{ KEYC_DOWN | KEYC_CTRL,  1, &cmd_resize_pane_entry },
		{ KEYC_LEFT | KEYC_CTRL,  1, &cmd_resize_pane_entry },
		{ KEYC_RIGHT | KEYC_CTRL, 1, &cmd_resize_pane_entry },
a162 1
	struct cmd	*cmd;
d164 3
d170 8
a177 15
	for (i = 0; i < nitems(table); i++) {
		cmdlist = xcalloc(1, sizeof *cmdlist);
		cmdlist->references = 1;
		TAILQ_INIT(&cmdlist->list);

		cmd = xcalloc(1, sizeof *cmd);
		cmd->entry = table[i].entry;
		if (cmd->entry->key_binding != NULL)
			cmd->entry->key_binding(cmd, table[i].key);
		else
			cmd->args = args_create(0);
		TAILQ_INSERT_HEAD(&cmdlist->list, cmd, qentry);

		key_bindings_add(
		    table[i].key | KEYC_PREFIX, table[i].can_repeat, cmdlist);
d179 1
@


1.40
log
@Remove the "info" message mechanism, this was only used for about five
mostly useless and annoying messages. Change those commands to silence
on success like all the others. Still accept the -q command line flag
and "quiet" server option for now.
@
text
@d1 1
a1 1
/* $OpenBSD: key-bindings.c,v 1.39 2013/03/24 09:57:59 nicm Exp $ */
a29 1
struct key_bindings	dead_key_bindings;
d80 2
a81 14
	RB_INSERT(key_bindings, &dead_key_bindings, bd);
}

void
key_bindings_clean(void)
{
	struct key_binding	*bd;

	while (!RB_EMPTY(&dead_key_bindings)) {
		bd = RB_ROOT(&dead_key_bindings);
		RB_REMOVE(key_bindings, &dead_key_bindings, bd);
		cmd_list_free(bd->cmdlist);
		free(bd);
	}
@


1.39
log
@Add resize-pane -Z to temporary zoom the active pane to occupy the full
window or unzoom (restored to the normal layout) if it already zoomed,
bound to C-b z by default. The pane is unzoomed on pretty much any
excuse whatsoever.

We considered making this a new layout but the requirements are quite
different from layouts so decided it is better as a special case. Each
current layout cell is saved, a temporary one-cell layout generated and
all except the active pane set to NULL.

Prompted by suggestions and scripts from several. Thanks to Aaron Jensen
and Thiago Padilha for testing an earlier version.
@
text
@d1 1
a1 1
/* $OpenBSD: key-bindings.c,v 1.38 2013/03/24 09:54:10 nicm Exp $ */
d215 1
a215 1
		cmdq_info(c->cmdq, "client is read-only");
@


1.38
log
@Add a command queue to standardize and simplify commands that call other
commands and allow a command to block execution of subsequent
commands. This allows run-shell and if-shell to be synchronous which has
been much requested.

Each client has a default command queue and commands are consumed one at
a time from it. A command may suspend execution from the queue by
returning CMD_RETURN_WAIT and then resume it by calling cmd_continue() -
for example run-shell does this from the callback that is fired after
the job is freed.

When the command queue becomes empty, command clients are automatically
exited (unless attaching). A callback is also fired - this is used for
nested commands in, for example, if-shell which can block execution of
the client's cmdq until a new cmdq becomes empty.

Also merge all the old error/info/print functions together and lose the
old curclient/cmdclient distinction - a cmdq is bound to one client (or
none if in the configuration file), this is a command client if
c->session is NULL otherwise an attached client.
@
text
@d1 1
a1 1
/* $OpenBSD: key-bindings.c,v 1.37 2013/03/22 15:54:29 nicm Exp $ */
d153 1
@


1.37
log
@Need to set clients in context before changing their reference count.
@
text
@d1 1
a1 1
/* $OpenBSD: key-bindings.c,v 1.36 2013/03/22 15:50:42 nicm Exp $ */
d185 2
a186 1
		cmdlist = xmalloc(sizeof *cmdlist);
a187 1
		cmdlist->references = 1;
d189 1
a189 1
		cmd = xmalloc(sizeof *cmd);
a201 60
void printflike2
key_bindings_error(struct cmd_ctx *ctx, const char *fmt, ...)
{
	va_list	ap;
	char   *msg;

	if (ctx->curclient->session == NULL)
		return;

	va_start(ap, fmt);
	xvasprintf(&msg, fmt, ap);
	va_end(ap);

	*msg = toupper((u_char) *msg);
	status_message_set(ctx->curclient, "%s", msg);
	free(msg);
}

void printflike2
key_bindings_print(struct cmd_ctx *ctx, const char *fmt, ...)
{
	struct winlink	*wl;
	va_list		 ap;

	if (ctx->curclient->session == NULL)
		return;

	wl = ctx->curclient->session->curw;
	if (wl->window->active->mode != &window_copy_mode) {
		window_pane_reset_mode(wl->window->active);
		window_pane_set_mode(wl->window->active, &window_copy_mode);
		window_copy_init_for_output(wl->window->active);
	}

	va_start(ap, fmt);
	window_copy_vadd(wl->window->active, fmt, ap);
	va_end(ap);
}

void printflike2
key_bindings_info(struct cmd_ctx *ctx, const char *fmt, ...)
{
	va_list	ap;
	char   *msg;

	if (ctx->curclient->session == NULL)
		return;

	if (options_get_number(&global_options, "quiet"))
		return;

	va_start(ap, fmt);
	xvasprintf(&msg, fmt, ap);
	va_end(ap);

	*msg = toupper((u_char) *msg);
	status_message_set(ctx->curclient, "%s", msg);
	free(msg);
}

a204 1
	struct cmd_ctx	*ctx;
a207 5
	ctx = cmd_get_ctx(NULL, c);
	ctx->error = key_bindings_error;
	ctx->print = key_bindings_print;
	ctx->info = key_bindings_info;

d213 2
a214 2
	if (!readonly && c->flags & CLIENT_READONLY) {
		key_bindings_info(ctx, "client is read-only");
d218 1
a218 2
	cmd_list_exec(bd->cmdlist, ctx);
	cmd_free_ctx(ctx);
@


1.36
log
@Remove unnecessary initializers of cmd_ctx.
@
text
@d1 1
a1 1
/* $OpenBSD: key-bindings.c,v 1.35 2013/03/22 15:49:55 nicm Exp $ */
d269 1
a269 2
	ctx = cmd_get_ctx();
	ctx->curclient = c;
@


1.35
log
@Add functions to allocate and free command contexts rather than doing it
all on the stack.
@
text
@d1 1
a1 1
/* $OpenBSD: key-bindings.c,v 1.34 2013/01/17 00:11:22 nicm Exp $ */
a269 2
	ctx->msgdata = NULL;
	ctx->cmdclient = NULL;
a270 1

@


1.34
log
@Remove the layout undo/redo code which never really worked.
@
text
@d1 1
a1 1
/* $OpenBSD: key-bindings.c,v 1.33 2012/07/10 11:53:01 nicm Exp $ */
d265 1
a265 1
	struct cmd_ctx	 ctx;
d269 8
a276 8
	ctx.msgdata = NULL;
	ctx.curclient = c;

	ctx.error = key_bindings_error;
	ctx.print = key_bindings_print;
	ctx.info = key_bindings_info;

	ctx.cmdclient = NULL;
d284 1
a284 1
		key_bindings_info(&ctx, "Client is read-only");
d288 2
a289 1
	cmd_list_exec(bd->cmdlist, &ctx);
@


1.33
log
@xfree is not particularly helpful, remove it. From Thomas Adam.
@
text
@d1 1
a1 1
/* $OpenBSD: key-bindings.c,v 1.32 2012/07/08 16:04:38 nicm Exp $ */
a132 1
		{ 'U',			  1, &cmd_select_layout_entry },
a150 1
		{ 'u',			  1, &cmd_select_layout_entry },
@


1.32
log
@Add choose-tree command to show windows and sessions in the same
list. Change choose-window and -session to use the same code. From
Thomas Adam.
@
text
@d1 1
a1 1
/* $OpenBSD: key-bindings.c,v 1.31 2012/06/18 09:58:02 nicm Exp $ */
d93 1
a93 1
		xfree(bd);
d219 1
a219 1
	xfree(msg);
d261 1
a261 1
	xfree(msg);
@


1.31
log
@Add a couple of NULL pointer checks to key binding functions, from
jspenguin on SF bug 3535531.
@
text
@d1 1
a1 1
/* $OpenBSD: key-bindings.c,v 1.30 2012/04/01 13:18:38 nicm Exp $ */
d150 1
a150 1
		{ 's', 			  0, &cmd_choose_session_entry },
@


1.30
log
@Add a layout history which can be stepped through with select-layout -u
and -U commands (bound to 'u' and 'U' by default).
@
text
@d1 1
a1 1
/* $OpenBSD: key-bindings.c,v 1.29 2012/01/21 11:12:13 nicm Exp $ */
d210 3
d225 1
a225 1
	struct winlink	*wl = ctx->curclient->session->curw;
d228 4
d248 3
@


1.29
log
@Use RB trees not SPLAY.
@
text
@d1 1
a1 1
/* $OpenBSD: key-bindings.c,v 1.28 2011/07/03 18:18:15 nicm Exp $ */
d133 1
d152 1
@


1.28
log
@Include the existing window and session name in the prompt when renaming
and add a new key binding ($) for rename session. From Tiago Cunha.
@
text
@d1 1
a1 1
/* $OpenBSD: key-bindings.c,v 1.27 2011/01/04 00:42:47 nicm Exp $ */
d27 1
a27 1
SPLAY_GENERATE(key_bindings, key_binding, entry, key_bindings_cmp);
d55 1
a55 1
	return (SPLAY_FIND(key_bindings, &key_bindings, &bd));
d67 1
a67 1
	SPLAY_INSERT(key_bindings, &key_bindings, bd);
d80 2
a81 2
	SPLAY_REMOVE(key_bindings, &key_bindings, bd);
	SPLAY_INSERT(key_bindings, &dead_key_bindings, bd);
d89 3
a91 3
	while (!SPLAY_EMPTY(&dead_key_bindings)) {
		bd = SPLAY_ROOT(&dead_key_bindings);
		SPLAY_REMOVE(key_bindings, &dead_key_bindings, bd);
d182 1
a182 1
	SPLAY_INIT(&key_bindings);
@


1.27
log
@Clean up and simplify tmux command argument parsing.

Originally, tmux commands were parsed in the client process into a
struct with the command data which was then serialised and sent to the
server to be executed. The parsing was later moved into the server (an
argv was sent from the client), but the parse step and intermediate
struct was kept.

This change removes that struct and the separate parse step. Argument
parsing and printing is now common to all commands (in arguments.c) with
each command left with just an optional check function (to validate the
arguments at parse time), the exec function and a function to set up any
key bindings (renamed from the old init function).

This is overall more simple and consistent.

There should be no changes to any commands behaviour or syntax although
as this touches every command please watch for any unexpected changes.
@
text
@d1 1
a1 1
/* $OpenBSD: key-bindings.c,v 1.26 2010/12/11 18:39:25 nicm Exp $ */
d109 1
@


1.26
log
@Track the last session for a client and add a flag to switch-client and
a key binding (L) to move a client back to its last session.
@
text
@d1 1
a1 1
/* $OpenBSD: key-bindings.c,v 1.25 2010/10/23 13:04:34 nicm Exp $ */
d190 4
a193 3
		cmd->data = NULL;
		if (cmd->entry->init != NULL)
			cmd->entry->init(cmd, table[i].key);
@


1.25
log
@Add a last-pane command (bound to ; by default). Requested ages ago by
somebody whose name I have forgotten.
@
text
@d1 1
a1 1
/* $OpenBSD: key-bindings.c,v 1.24 2010/09/08 22:02:28 nicm Exp $ */
d131 1
@


1.24
log
@Add -n and -p flags to switch-client to move to the next and previous
session (yes, it doesn't match window/pane, but so what, nor does
switch-client).

Based on a diff long ago from "edsouza".
@
text
@d1 1
a1 1
/* $OpenBSD: key-bindings.c,v 1.23 2010/06/26 18:20:53 nicm Exp $ */
d127 1
@


1.23
log
@Setting the cmdlist pointer in the bind-key to NULL to prevent it being freed
after the command is executing is bogus because it may still be needed if the
same command is going to be executed again (for example if you "bind-key a
bind-key b ..."). Making a copy is hard, so instead add a reference count to
the cmd_list.

While here, also print bind-key -n and the rest of the flags properly.

Fixes problem reported by mcbride@@.
@
text
@d1 1
a1 1
/* $OpenBSD: key-bindings.c,v 1.22 2010/06/21 21:44:09 nicm Exp $ */
d111 2
@


1.22
log
@Add a choose-buffer command for easier use of the paste buffer stack.
@
text
@d1 1
a1 1
/* $OpenBSD: key-bindings.c,v 1.21 2010/05/05 23:24:23 nicm Exp $ */
d181 2
a182 1
		TAILQ_INIT(cmdlist);
d189 1
a189 1
		TAILQ_INSERT_HEAD(cmdlist, cmd, qentry);
d263 1
a263 1
	TAILQ_FOREACH(cmd, bd->cmdlist, qentry) {
@


1.21
log
@Identical behaviour to select-prompt can now be obtained with
command-prompt, so remove select-prompt and change ' to be bound to
command-prompt -p index "select-window -t :%%".
@
text
@d1 1
a1 1
/* $OpenBSD: key-bindings.c,v 1.20 2010/04/25 20:28:13 nicm Exp $ */
d125 1
@


1.20
log
@Add a tiled layout, originally from Liam Bedford a while ago, fixed up
by me.
@
text
@d1 1
a1 1
/* $OpenBSD: key-bindings.c,v 1.19 2010/04/06 21:35:44 nicm Exp $ */
d128 1
a128 1
		{ '\'',			  0, &cmd_select_prompt_entry },
@


1.19
log
@Merge copy mode and output mode, dropping the latter. Idea and code from
Micah Cowan.
@
text
@d1 1
a1 1
/* $OpenBSD: key-bindings.c,v 1.18 2010/03/22 19:07:52 nicm Exp $ */
d154 1
@


1.18
log
@Support up, down, left, right movement through panes with -UDLR flags to
select-pane.

Also REMOVE the up- and down-pane commands: equivalent behaviour is now
available using -t :.+ and -t :.-.
@
text
@d1 1
a1 1
/* $OpenBSD: key-bindings.c,v 1.17 2010/02/06 22:55:31 nicm Exp $ */
d214 1
a214 1
	if (wl->window->active->mode != &window_more_mode)
d216 3
a218 1
	window_pane_set_mode(wl->window->active, &window_more_mode);
d221 1
a221 1
	window_more_vadd(wl->window->active, fmt, ap);
@


1.17
log
@Support attaching a client read-only with a new -r flag to the attach-session
command.
@
text
@d1 1
a1 1
/* $OpenBSD: key-bindings.c,v 1.16 2009/12/10 09:16:52 nicm Exp $ */
d139 1
a139 1
		{ 'o', 			  0, &cmd_down_pane_entry },
d158 4
a161 2
		{ KEYC_UP, 		  0, &cmd_up_pane_entry },
		{ KEYC_DOWN, 		  0, &cmd_down_pane_entry },
@


1.16
log
@Add "server options" which are server-wide and not bound to a session or
window. Set and displayed with "set -s" and "show -s".

Currently the only option is "quiet" (like command-line -q, allowing it to be
set from .tmux.conf), but others will come along.
@
text
@d1 1
a1 1
/* $OpenBSD: key-bindings.c,v 1.15 2009/12/03 22:50:10 nicm Exp $ */
d242 3
a244 1
	struct cmd_ctx	 	 ctx;
d254 10
@


1.15
log
@Massive spaces->tabs and trailing whitespace cleanup, hopefully for the last
time now I've configured emacs to make them displayed in really annoying
colours...
@
text
@d1 1
a1 1
/* $OpenBSD: key-bindings.c,v 1.14 2009/11/18 13:16:33 nicm Exp $ */
d227 1
a227 1
	if (be_quiet)
@


1.14
log
@Add a per-client log of status line messages displayed while that client
exists. A new message-limit session option sets the maximum number of entries
and a command, show-messages, shows the log (bound to ~ by default).

This (and prompt history) might be better as a single global log but until
there are global options it is easier for them to be per client.
@
text
@d1 1
a1 1
/* $OpenBSD: key-bindings.c,v 1.13 2009/11/13 07:00:54 nicm Exp $ */
d64 1
a64 1
		    
d68 1
a68 1
	
d107 1
a107 1
		{ '"', 			  0, &cmd_split_window_entry },	
d109 1
a109 1
		{ '%', 			  0, &cmd_split_window_entry },	
d165 1
a165 1
		{ KEYC_DOWN | KEYC_CTRL,  1, &cmd_resize_pane_entry },	
d202 1
a202 1
 	status_message_set(ctx->curclient, "%s", msg);
d235 1
a235 1
 	status_message_set(ctx->curclient, "%s", msg);
@


1.13
log
@Zap unused functions, prompted by deraadt.
@
text
@d1 1
a1 1
/* $OpenBSD: key-bindings.c,v 1.12 2009/10/06 07:19:32 nicm Exp $ */
d108 1
a109 1
		{ '#', 			  0, &cmd_list_buffers_entry },
d126 1
d129 2
a134 1
		{ 'D',			  0, &cmd_choose_client_entry },
d149 1
a149 1
		{ '\002', /* C-b */	  0, &cmd_send_prefix_entry },
d156 1
a167 2
		{ 'o' | KEYC_ESCAPE,	  0, &cmd_rotate_window_entry },
		{ '\017', /* C-o */	  0, &cmd_rotate_window_entry },
@


1.12
log
@Remove scroll mode which is now redundant, copy mode should be used instead.

The = key binding now does nothing.
@
text
@d1 1
a1 1
/* $OpenBSD: key-bindings.c,v 1.11 2009/08/31 20:46:19 nicm Exp $ */
a186 14
	}
}

void
key_bindings_free(void)
{
	struct key_binding	*bd;

	key_bindings_clean();
	while (!SPLAY_EMPTY(&key_bindings)) {
		bd = SPLAY_ROOT(&key_bindings);
		SPLAY_REMOVE(key_bindings, &key_bindings, bd);
		cmd_list_free(bd->cmdlist);
		xfree(bd);
@


1.11
log
@Add a new display-panes command, with two options (display-panes-colour and
display-panes-time), which displays a visual indication of the number of each
pane.
@
text
@d1 1
a1 1
/* $OpenBSD: key-bindings.c,v 1.10 2009/08/25 12:18:51 nicm Exp $ */
a124 1
		{ '=', 			  0, &cmd_scroll_mode_entry },
d152 1
a152 1
		{ KEYC_PPAGE, 		  0, &cmd_scroll_mode_entry },
@


1.10
log
@Add a choose-client command and extend choose-{session,window} to accept a
template. After a choice is made, %% (or %1) in the template is replaced by the
name of the session, window or client suitable for -t and the result executed
as a command. So, for example, "choose-window "killw -t '%%'"" will kill the
selected window.

The defaults if no template is given are (as now) select-window for
choose-window, switch-client for choose-session, and detach-client for
choose-client (now bound to D).
@
text
@d1 1
a1 1
/* $OpenBSD: key-bindings.c,v 1.9 2009/08/23 16:45:00 nicm Exp $ */
d140 1
@


1.9
log
@The cursession member in struct cmd_ctx is always either curclient->session or
NULL when curclient is also NULL, so just eliminate it.
@
text
@d1 1
a1 1
/* $OpenBSD: key-bindings.c,v 1.8 2009/07/24 14:52:47 nicm Exp $ */
d133 1
d147 1
a147 1
		{ '\002', 		  0, &cmd_send_prefix_entry },
d166 1
a166 1
		{ '\017',	          0, &cmd_rotate_window_entry },
@


1.8
log
@Permit commands to be bound to key presses without the prefix key first. The
new -n flag to bind-key and unbind-key sets or removes these bindings, and
list-key shows them in []s.
@
text
@d1 1
a1 1
/* $OpenBSD: key-bindings.c,v 1.7 2009/07/21 17:57:29 nicm Exp $ */
d221 1
a221 1
	struct winlink	*wl = ctx->cursession->curw;
a256 1
	ctx.cursession = c->session;
@


1.7
log
@Tidy up keys: use an enum for the key codes, and remove the macros which just
wrap flag sets/clears/tests.
@
text
@d1 1
a1 1
/* $OpenBSD: key-bindings.c,v 1.6 2009/07/19 13:21:40 nicm Exp $ */
d35 12
a46 1
	return (bd1->key - bd2->key);
d184 2
a185 1
		key_bindings_add(table[i].key, table[i].can_repeat, cmdlist);
@


1.6
log
@Improved layout code.

Each window now has a tree of layout cells associated with it. In this tree,
each node is either a horizontal or vertical cell containing a list of other
cells running from left-to-right or top-to-bottom, or a leaf cell which is
associated with a pane.

The major functional changes are:

- panes may now be split arbitrarily both horizontally (splitw -h, C-b %) and
  vertically (splitw -v, C-b ");
- panes may be resized both horizontally and vertically (resizep -L/-R/-U/-D,
  bound to C-b left/right/up/down and C-b M-left/right/up/down);
- layouts are now applied and then may be modified by resizing or splitting
  panes, rather than being fixed and reapplied when the window is resized or
  panes are added;
- manual-vertical layout is no longer necessary, and active-only layout is gone
  (but may return in future);
- the main-pane layouts now reduce the size of the main pane to fit all panes
  if possible.

Thanks to all who tested.
@
text
@d1 1
a1 1
/* $OpenBSD: key-bindings.c,v 1.5 2009/07/17 18:45:08 nicm Exp $ */
d136 4
a139 4
		{ KEYC_ADDESC('1'),	  0, &cmd_select_layout_entry },
		{ KEYC_ADDESC('2'),	  0, &cmd_select_layout_entry },
		{ KEYC_ADDESC('3'),	  0, &cmd_select_layout_entry },
		{ KEYC_ADDESC('4'),	  0, &cmd_select_layout_entry },
d141 2
a142 2
		{ KEYC_ADDESC('n'), 	  0, &cmd_next_window_entry },
		{ KEYC_ADDESC('p'), 	  0, &cmd_previous_window_entry },
d145 9
a153 9
		{ KEYC_ADDESC(KEYC_UP),   1, &cmd_resize_pane_entry },
		{ KEYC_ADDESC(KEYC_DOWN), 1, &cmd_resize_pane_entry },
		{ KEYC_ADDESC(KEYC_LEFT), 1, &cmd_resize_pane_entry },
		{ KEYC_ADDESC(KEYC_RIGHT),1, &cmd_resize_pane_entry },
		{ KEYC_ADDCTL(KEYC_UP),   1, &cmd_resize_pane_entry },
		{ KEYC_ADDCTL(KEYC_DOWN), 1, &cmd_resize_pane_entry },	
		{ KEYC_ADDCTL(KEYC_LEFT), 1, &cmd_resize_pane_entry },
		{ KEYC_ADDCTL(KEYC_RIGHT),1, &cmd_resize_pane_entry },
		{ KEYC_ADDESC('o'),	  0, &cmd_rotate_window_entry },
@


1.5
log
@- New command display-message (alias display) to display a message in the
  status line (bound to "i" and displays the current window and time by
  default). The same substitutions are applied as for status-left/right.
- Add support for including the window index (#I), pane index (#P) and window
  name (#W) in the message, and status-left or status-right.
- Bump protocol version.

From Tiago Cunha, thanks!
@
text
@d1 1
a1 1
/* $OpenBSD: key-bindings.c,v 1.4 2009/07/17 13:43:07 nicm Exp $ */
d96 2
a97 1
		{ '"', 			  0, &cmd_split_window_entry },
a135 1
		{ KEYC_ADDESC('0'),	  0, &cmd_select_layout_entry },
d138 2
a139 1
		{ KEYC_ADDESC('9'),	  0, &cmd_select_layout_entry },
d147 2
d150 3
a152 1
		{ KEYC_ADDCTL(KEYC_DOWN), 1, &cmd_resize_pane_entry },
@


1.4
log
@Remove a duplicate key binding, and turn off autorepeat for up/down as it is
kind of annoying by default.
@
text
@d1 1
a1 1
/* $OpenBSD: key-bindings.c,v 1.3 2009/07/15 17:39:00 nicm Exp $ */
d122 1
@


1.3
log
@Make status_message_set a variadic printf-like function. No functional change -
helpful for a couple of things coming soon.
@
text
@d1 1
a1 1
/* $OpenBSD: key-bindings.c,v 1.2 2009/07/12 17:33:18 nicm Exp $ */
a137 1
		{ KEYC_ADDCTL(KEYC_DOWN), 1, &cmd_resize_pane_entry },
d141 2
a142 2
		{ KEYC_UP, 		  1, &cmd_up_pane_entry },
		{ KEYC_DOWN, 		  1, &cmd_down_pane_entry },
@


1.2
log
@Creating a key binding which replaces itself (such as "bind x bind x lsw")
frees the command list bound to the key while it is still being executed,
leading to a use after free. To prevent this, create a dead keys list and defer
freeing replaced or removed key bindings until the main loop when the key
binding will have finished executing.

Found by Johan Friis when creating a key binding to reload his configuration
file.
@
text
@d1 1
a1 1
/* $OpenBSD: key-bindings.c,v 1.1 2009/06/01 22:58:49 nicm Exp $ */
d197 1
a197 1
 	status_message_set(ctx->curclient, msg);
d230 1
a230 1
 	status_message_set(ctx->curclient, msg);
@


1.1
log
@Import tmux, a terminal multiplexor allowing (among other things) a single
terminal to be switched between several different windows and programs
displayed on one terminal be detached from one terminal and moved to another.

ok deraadt pirofti
@
text
@d1 1
a1 1
/* $OpenBSD$ */
d30 1
d52 6
a57 6
	if ((bd = key_bindings_lookup(key)) == NULL) {
		bd = xmalloc(sizeof *bd);
		bd->key = key;
		SPLAY_INSERT(key_bindings, &key_bindings, bd);
	} else
		cmd_list_free(bd->cmdlist);
d70 7
d78 6
a83 2
	cmd_list_free(bd->cmdlist);
	xfree(bd);
d177 1
@

