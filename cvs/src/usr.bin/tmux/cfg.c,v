head	1.54;
access;
symbols
	OPENBSD_6_1:1.54.0.2
	OPENBSD_6_1_BASE:1.54
	OPENBSD_6_0:1.45.0.2
	OPENBSD_6_0_BASE:1.45
	OPENBSD_5_9:1.44.0.2
	OPENBSD_5_9_BASE:1.44
	OPENBSD_5_8:1.39.0.4
	OPENBSD_5_8_BASE:1.39
	OPENBSD_5_7:1.33.0.2
	OPENBSD_5_7_BASE:1.33
	OPENBSD_5_6:1.32.0.4
	OPENBSD_5_6_BASE:1.32
	OPENBSD_5_5:1.30.0.4
	OPENBSD_5_5_BASE:1.30
	OPENBSD_5_4:1.29.0.2
	OPENBSD_5_4_BASE:1.29
	OPENBSD_5_3:1.21.0.2
	OPENBSD_5_3_BASE:1.21
	OPENBSD_5_2:1.16.0.2
	OPENBSD_5_2_BASE:1.16
	OPENBSD_5_1_BASE:1.13
	OPENBSD_5_1:1.13.0.2
	OPENBSD_5_0:1.12.0.4
	OPENBSD_5_0_BASE:1.12
	OPENBSD_4_9:1.12.0.2
	OPENBSD_4_9_BASE:1.12
	OPENBSD_4_8:1.11.0.2
	OPENBSD_4_8_BASE:1.11
	OPENBSD_4_7:1.10.0.2
	OPENBSD_4_7_BASE:1.10
	OPENBSD_4_6:1.2.0.4
	OPENBSD_4_6_BASE:1.2;
locks; strict;
comment	@ * @;


1.54
date	2017.02.03.11.57.27;	author nicm;	state Exp;
branches;
next	1.53;
commitid	BLRh0qXo7OVTPhiT;

1.53
date	2017.01.15.22.00.56;	author nicm;	state Exp;
branches;
next	1.52;
commitid	P8Zuj7wnJMd8B8vz;

1.52
date	2017.01.09.21.28.56;	author nicm;	state Exp;
branches;
next	1.51;
commitid	UDOMieRU3RCD0teg;

1.51
date	2017.01.09.19.27.00;	author nicm;	state Exp;
branches;
next	1.50;
commitid	OxA55NgX2OxpYMnz;

1.50
date	2016.10.16.19.04.05;	author nicm;	state Exp;
branches;
next	1.49;
commitid	pxm6osuE99zELpkU;

1.49
date	2016.10.16.17.55.14;	author nicm;	state Exp;
branches;
next	1.48;
commitid	1xIYFpLYkPIXNEvU;

1.48
date	2016.10.14.18.41.53;	author nicm;	state Exp;
branches;
next	1.47;
commitid	H2ZMHx3pmW6ppdPc;

1.47
date	2016.10.11.13.45.47;	author nicm;	state Exp;
branches;
next	1.46;
commitid	m8cwMB6WuKLMPXh5;

1.46
date	2016.10.10.21.29.23;	author nicm;	state Exp;
branches;
next	1.45;
commitid	z4Hr4PZF7Ev93uEJ;

1.45
date	2016.05.12.16.05.33;	author tim;	state Exp;
branches;
next	1.44;
commitid	T3Sd9myvNE2f79sY;

1.44
date	2016.01.19.15.59.12;	author nicm;	state Exp;
branches;
next	1.43;
commitid	P3qmSOx6KrDBsb0c;

1.43
date	2015.11.18.14.27.44;	author nicm;	state Exp;
branches;
next	1.42;
commitid	RjsAPRkWwvS79w40;

1.42
date	2015.09.09.12.09.21;	author nicm;	state Exp;
branches;
next	1.41;
commitid	yi7yvCISyWrOJyUb;

1.41
date	2015.09.01.10.10.59;	author nicm;	state Exp;
branches;
next	1.40;
commitid	d18I0q3dD3BLOXHE;

1.40
date	2015.09.01.10.01.56;	author nicm;	state Exp;
branches;
next	1.39;
commitid	HiJ8QXCMc25AkMAL;

1.39
date	2015.06.05.18.06.30;	author nicm;	state Exp;
branches;
next	1.38;
commitid	31HWw6xUnTEvtfY4;

1.38
date	2015.05.07.11.42.56;	author nicm;	state Exp;
branches;
next	1.37;
commitid	aHjVLgOHz1Tie9FQ;

1.37
date	2015.04.27.22.50.35;	author nicm;	state Exp;
branches;
next	1.36;
commitid	eksJiABg2wrSfPed;

1.36
date	2015.04.25.18.49.01;	author nicm;	state Exp;
branches;
next	1.35;
commitid	OvVP75Ylb5es4t32;

1.35
date	2015.04.25.18.47.01;	author nicm;	state Exp;
branches;
next	1.34;
commitid	yGJPDoZD5uXakBt5;

1.34
date	2015.04.19.21.34.21;	author nicm;	state Exp;
branches;
next	1.33;
commitid	wug6ctIOfhVMeWQp;

1.33
date	2014.10.27.22.23.47;	author nicm;	state Exp;
branches;
next	1.32;
commitid	lLfuAlkV0hLlHdgD;

1.32
date	2014.06.25.19.17.27;	author tobias;	state Exp;
branches;
next	1.31;
commitid	2TKnrCnezp3tPOyk;

1.31
date	2014.04.17.11.38.35;	author nicm;	state Exp;
branches;
next	1.30;

1.30
date	2013.10.20.17.28.43;	author nicm;	state Exp;
branches;
next	1.29;

1.29
date	2013.03.25.10.06.13;	author nicm;	state Exp;
branches;
next	1.28;

1.28
date	2013.03.24.09.54.10;	author nicm;	state Exp;
branches;
next	1.27;

1.27
date	2013.03.22.15.54.29;	author nicm;	state Exp;
branches;
next	1.26;

1.26
date	2013.03.22.15.50.13;	author nicm;	state Exp;
branches;
next	1.25;

1.25
date	2013.03.22.15.49.55;	author nicm;	state Exp;
branches;
next	1.24;

1.24
date	2013.03.22.10.41.57;	author nicm;	state Exp;
branches;
next	1.23;

1.23
date	2013.03.22.10.31.22;	author nicm;	state Exp;
branches;
next	1.22;

1.22
date	2013.03.21.16.54.37;	author nicm;	state Exp;
branches;
next	1.21;

1.21
date	2012.12.13.15.36.16;	author nicm;	state Exp;
branches;
next	1.20;

1.20
date	2012.12.06.13.06.05;	author nicm;	state Exp;
branches;
next	1.19;

1.19
date	2012.11.27.22.59.34;	author nicm;	state Exp;
branches;
next	1.18;

1.18
date	2012.11.27.16.12.29;	author nicm;	state Exp;
branches;
next	1.17;

1.17
date	2012.11.19.10.38.06;	author nicm;	state Exp;
branches;
next	1.16;

1.16
date	2012.07.11.07.10.15;	author nicm;	state Exp;
branches;
next	1.15;

1.15
date	2012.07.10.11.53.01;	author nicm;	state Exp;
branches;
next	1.14;

1.14
date	2012.05.17.21.21.31;	author nicm;	state Exp;
branches;
next	1.13;

1.13
date	2011.08.24.10.46.01;	author nicm;	state Exp;
branches;
next	1.12;

1.12
date	2010.12.29.21.28.32;	author nicm;	state Exp;
branches;
next	1.11;

1.11
date	2010.05.25.19.47.30;	author nicm;	state Exp;
branches;
next	1.10;

1.10
date	2010.02.06.23.22.27;	author nicm;	state Exp;
branches;
next	1.9;

1.9
date	2010.02.06.17.15.33;	author nicm;	state Exp;
branches;
next	1.8;

1.8
date	2009.11.26.21.37.13;	author nicm;	state Exp;
branches;
next	1.7;

1.7
date	2009.10.26.21.42.04;	author deraadt;	state Exp;
branches;
next	1.6;

1.6
date	2009.08.23.17.29.51;	author nicm;	state Exp;
branches;
next	1.5;

1.5
date	2009.08.23.16.45.00;	author nicm;	state Exp;
branches;
next	1.4;

1.4
date	2009.08.09.08.34.17;	author nicm;	state Exp;
branches;
next	1.3;

1.3
date	2009.07.30.17.46.12;	author nicm;	state Exp;
branches;
next	1.2;

1.2
date	2009.06.25.06.00.45;	author nicm;	state Exp;
branches;
next	1.1;

1.1
date	2009.06.01.22.58.49;	author nicm;	state Exp;
branches;
next	;


desc
@@


1.54
log
@Add a window or pane id "tag" to each format tree and use it to separate
jobs, this means that if the same job is used for different windows or
panes (for example in pane-border-format), it will be run separately for
each pane.
@
text
@/* $OpenBSD: cfg.c,v 1.53 2017/01/15 22:00:56 nicm Exp $ */

/*
 * Copyright (c) 2008 Nicholas Marriott <nicholas.marriott@@gmail.com>
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF MIND, USE, DATA OR PROFITS, WHETHER
 * IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING
 * OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */

#include <sys/types.h>

#include <ctype.h>
#include <errno.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <util.h>

#include "tmux.h"

char		 *cfg_file;
int		  cfg_finished;
static char	**cfg_causes;
static u_int	  cfg_ncauses;
struct client	 *cfg_client;

static enum cmd_retval
cfg_done(__unused struct cmdq_item *item, __unused void *data)
{
	if (cfg_finished)
		return (CMD_RETURN_NORMAL);
	cfg_finished = 1;

	if (!RB_EMPTY(&sessions))
		cfg_show_causes(RB_MIN(sessions, &sessions));

	if (cfg_client != NULL)
		server_client_unref(cfg_client);
	return (CMD_RETURN_NORMAL);
}

void
set_cfg_file(const char *path)
{
	free(cfg_file);
	cfg_file = xstrdup(path);
}

void
start_cfg(void)
{
	const char	*home;
	int		 quiet = 0;

	cfg_client = TAILQ_FIRST(&clients);
	if (cfg_client != NULL)
		cfg_client->references++;

	load_cfg(TMUX_CONF, cfg_client, NULL, 1);

	if (cfg_file == NULL && (home = find_home()) != NULL) {
		xasprintf(&cfg_file, "%s/.tmux.conf", home);
		quiet = 1;
	}
	if (cfg_file != NULL)
		load_cfg(cfg_file, cfg_client, NULL, quiet);

	cmdq_append(cfg_client, cmdq_get_callback(cfg_done, NULL));
}

int
load_cfg(const char *path, struct client *c, struct cmdq_item *item, int quiet)
{
	FILE			*f;
	const char		 delim[3] = { '\\', '\\', '\0' };
	u_int			 found = 0;
	size_t			 line = 0;
	char			*buf, *cause1, *p, *q, *s;
	struct cmd_list		*cmdlist;
	struct cmdq_item	*new_item;
	int			 condition = 0;
	struct format_tree	*ft;

	log_debug("loading %s", path);
	if ((f = fopen(path, "rb")) == NULL) {
		if (errno == ENOENT && quiet)
			return (0);
		cfg_add_cause("%s: %s", path, strerror(errno));
		return (-1);
	}

	while ((buf = fparseln(f, NULL, &line, delim, 0)) != NULL) {
		log_debug("%s: %s", path, buf);

		p = buf;
		while (isspace((u_char)*p))
			p++;
		if (*p == '\0') {
			free(buf);
			continue;
		}
		q = p + strlen(p) - 1;
		while (q != p && isspace((u_char)*q))
			*q-- = '\0';

		if (condition != 0 && strcmp(p, "%endif") == 0) {
			condition = 0;
			continue;
		}
		if (strncmp(p, "%if ", 4) == 0) {
			if (condition != 0) {
				cfg_add_cause("%s:%zu: nested %%if", path,
				    line);
				continue;
			}
			ft = format_create(NULL, FORMAT_NONE, FORMAT_NOJOBS);

			s = p + 3;
			while (isspace((u_char)*s))
				s++;
			s = format_expand(ft, s);
			if (*s != '\0' && (s[0] != '0' || s[1] != '\0'))
				condition = 1;
			else
				condition = -1;
			free(s);

			format_free(ft);
			continue;
		}
		if (condition == -1)
			continue;

		cmdlist = cmd_string_parse(p, path, line, &cause1);
		if (cmdlist == NULL) {
			free(buf);
			if (cause1 == NULL)
				continue;
			cfg_add_cause("%s:%zu: %s", path, line, cause1);
			free(cause1);
			continue;
		}
		free(buf);

		if (cmdlist == NULL)
			continue;
		new_item = cmdq_get_command(cmdlist, NULL, NULL, 0);
		if (item != NULL)
			cmdq_insert_after(item, new_item);
		else
			cmdq_append(c, new_item);
		cmd_list_free(cmdlist);

		found++;
	}
	fclose(f);

	return (found);
}

void
cfg_add_cause(const char *fmt, ...)
{
	va_list	 ap;
	char	*msg;

	va_start(ap, fmt);
	xvasprintf(&msg, fmt, ap);
	va_end(ap);

	cfg_ncauses++;
	cfg_causes = xreallocarray(cfg_causes, cfg_ncauses, sizeof *cfg_causes);
	cfg_causes[cfg_ncauses - 1] = msg;
}

void
cfg_print_causes(struct cmdq_item *item)
{
	u_int	 i;

	for (i = 0; i < cfg_ncauses; i++) {
		cmdq_print(item, "%s", cfg_causes[i]);
		free(cfg_causes[i]);
	}

	free(cfg_causes);
	cfg_causes = NULL;
	cfg_ncauses = 0;
}

void
cfg_show_causes(struct session *s)
{
	struct window_pane	*wp;
	u_int			 i;

	if (s == NULL || cfg_ncauses == 0)
		return;
	wp = s->curw->window->active;

	window_pane_set_mode(wp, &window_copy_mode);
	window_copy_init_for_output(wp);
	for (i = 0; i < cfg_ncauses; i++) {
		window_copy_add(wp, "%s", cfg_causes[i]);
		free(cfg_causes[i]);
	}

	free(cfg_causes);
	cfg_causes = NULL;
	cfg_ncauses = 0;
}
@


1.53
log
@It is silly for cmd_list_parse to return an integer error when it could
just return NULL.
@
text
@d1 1
a1 1
/* $OpenBSD: cfg.c,v 1.52 2017/01/09 21:28:56 nicm Exp $ */
d126 1
a126 1
			ft = format_create(NULL, FORMAT_NOJOBS);
@


1.52
log
@Add %if/%endif for conditionals when parsing configuration files, the
argument is a format (the new == and != are useful).
@
text
@d1 1
a1 1
/* $OpenBSD: cfg.c,v 1.51 2017/01/09 19:27:00 nicm Exp $ */
d144 2
a145 1
		if (cmd_string_parse(p, &cmdlist, path, line, &cause1) != 0) {
@


1.51
log
@Run the source-file pattern through glob(3).
@
text
@d1 1
a1 1
/* $OpenBSD: cfg.c,v 1.50 2016/10/16 19:04:05 nicm Exp $ */
d85 2
a86 2
	char			 delim[3] = { '\\', '\\', '\0' };
	u_int			 found;
d88 1
a88 1
	char			*buf, *cause1, *p;
d91 2
a101 1
	found = 0;
a104 1
		/* Skip empty lines. */
d106 1
a106 1
		while (isspace((u_char) *p))
d112 31
a143 1
		/* Parse and run the command. */
@


1.50
log
@Mass rename struct cmd_q to struct cmdq_item and related.
@
text
@d1 1
a1 1
/* $OpenBSD: cfg.c,v 1.49 2016/10/16 17:55:14 nicm Exp $ */
d31 5
a35 5
char			 *cfg_file;
int			  cfg_finished;
static char		**cfg_causes;
static u_int		  cfg_ncauses;
struct client		 *cfg_client;
@


1.49
log
@Rewrite command queue handling. Each client still has a command queue,
but there is also now a global command queue. Instead of command queues
being dispatched on demand from wherever the command happens to be
added, they are now all dispatched from the top level server
loop. Command queues may now also include callbacks as well as commands,
and items may be inserted after the current command as well as at the end.

This all makes command queues significantly more predictable and easier
to use, and avoids the complex multiple nested command queues used by
source-file, if-shell and friends.

A mass rename of struct cmdq to a better name (cmdq_item probably) is
coming.
@
text
@d1 1
a1 1
/* $OpenBSD: cfg.c,v 1.48 2016/10/14 18:41:53 nicm Exp $ */
d38 1
a38 1
cfg_done(__unused struct cmd_q *cmdq, __unused void *data)
d82 1
a82 1
load_cfg(const char *path, struct client *c, struct cmd_q *cmdq, int quiet)
d84 7
a90 7
	FILE		*f;
	char		 delim[3] = { '\\', '\\', '\0' };
	u_int		 found;
	size_t		 line = 0;
	char		*buf, *cause1, *p;
	struct cmd_list	*cmdlist;
	struct cmd_q	*new_cmdq;
d126 3
a128 3
		new_cmdq = cmdq_get_command(cmdlist, NULL, NULL, 0);
		if (cmdq != NULL)
			cmdq_insert_after(cmdq, new_cmdq);
d130 1
a130 1
			cmdq_append(c, new_cmdq);
d156 1
a156 1
cfg_print_causes(struct cmd_q *cmdq)
d161 1
a161 1
		cmdq_print(cmdq, "%s", cfg_causes[i]);
@


1.48
log
@source-file and some other commands can recurse back into cmdq_continue,
which could potentially free the currently running command, so we need
to take a reference to it in cmdq_continue_one.

Fixes problem reported by Theo Buehler.
@
text
@d1 1
a1 1
/* $OpenBSD: cfg.c,v 1.47 2016/10/11 13:45:47 nicm Exp $ */
a31 1
static struct cmd_q	 *cfg_cmd_q;
a32 1
int			  cfg_references;
d37 14
a50 1
static void	  cfg_default_done(struct cmd_q *);
a64 6
	cfg_cmd_q = cmdq_new(NULL);
	cfg_cmd_q->emptyfn = cfg_default_done;

	cfg_finished = 0;
	cfg_references = 1;

d69 1
a69 1
	load_cfg(TMUX_CONF, cfg_cmd_q, 1);
d76 1
a76 1
		load_cfg(cfg_file, cfg_cmd_q, quiet);
d78 1
a78 1
	cmdq_continue(cfg_cmd_q);
d82 1
a82 1
load_cfg(const char *path, struct cmd_q *cmdq, int quiet)
d90 1
d126 5
a130 1
		cmdq_append(cmdq, cmdlist, NULL);
d132 1
a137 31
}

static void
cfg_default_done(__unused struct cmd_q *cmdq)
{
	log_debug("%s: %u references%s", __func__, cfg_references,
	    cfg_finished ? " (finished)" : "");

	if (cfg_finished || --cfg_references != 0)
		return;
	cfg_finished = 1;

	if (!RB_EMPTY(&sessions))
		cfg_show_causes(RB_MIN(sessions, &sessions));

	cmdq_free(cfg_cmd_q);
	cfg_cmd_q = NULL;

	if (cfg_client != NULL) {
		/*
		 * The client command queue starts with client_exit set to 1 so
		 * only continue if not empty (that is, we have been delayed
		 * during configuration parsing for long enough that the
		 * MSG_COMMAND has arrived), else the client will exit before
		 * the MSG_COMMAND which might tell it not to.
		 */
		if (!TAILQ_EMPTY(&cfg_client->cmdq->queue))
			cmdq_continue(cfg_client->cmdq);
		server_client_unref(cfg_client);
		cfg_client = NULL;
	}
@


1.47
log
@Some other stuff that can be local to one file.
@
text
@d1 1
a1 1
/* $OpenBSD: cfg.c,v 1.46 2016/10/10 21:29:23 nicm Exp $ */
d132 4
a135 1
	if (--cfg_references != 0)
@


1.46
log
@Loads more static, except for cmd-*.c and window-*.c.
@
text
@d1 1
a1 1
/* $OpenBSD: cfg.c,v 1.45 2016/05/12 16:05:33 tim Exp $ */
d31 7
a37 7
char		 *cfg_file;
struct cmd_q	 *cfg_cmd_q;
int		  cfg_finished;
int		  cfg_references;
char		**cfg_causes;
u_int		  cfg_ncauses;
struct client	 *cfg_client;
@


1.45
log
@- Rework load_cfg() error handling a little.
- Add -q to source-file to suppress errors about nonexistent files.

Input and OK nicm@@
@
text
@d1 1
a1 1
/* $OpenBSD: cfg.c,v 1.44 2016/01/19 15:59:12 nicm Exp $ */
d39 1
a39 1
void	cfg_default_done(struct cmd_q *);
d129 1
a129 1
void
@


1.44
log
@I no longer use my SourceForge address so replace it.
@
text
@d1 1
a1 1
/* $OpenBSD: cfg.c,v 1.43 2015/11/18 14:27:44 nicm Exp $ */
a50 1
	char		*cause = NULL;
d52 1
d64 1
a64 5
	if (access(TMUX_CONF, R_OK) == 0) {
		if (load_cfg(TMUX_CONF, cfg_cmd_q, &cause) == -1)
			cfg_add_cause("%s: %s", TMUX_CONF, cause);
	} else if (errno != ENOENT)
		cfg_add_cause("%s: %s", TMUX_CONF, strerror(errno));
d68 1
a68 4
		if (access(cfg_file, R_OK) != 0 && errno == ENOENT) {
			free(cfg_file);
			cfg_file = NULL;
		}
d70 2
a71 3
	if (cfg_file != NULL && load_cfg(cfg_file, cfg_cmd_q, &cause) == -1)
		cfg_add_cause("%s: %s", cfg_file, cause);
	free(cause);
d77 1
a77 1
load_cfg(const char *path, struct cmd_q *cmdq, char **cause)
d88 3
a90 1
		xasprintf(cause, "%s: %s", path, strerror(errno));
@


1.43
log
@Use __unused rather than rolling our own.
@
text
@d1 1
a1 1
/* $OpenBSD: cfg.c,v 1.42 2015/09/09 12:09:21 nicm Exp $ */
d4 1
a4 1
 * Copyright (c) 2008 Nicholas Marriott <nicm@@users.sourceforge.net>
@


1.42
log
@No need to keep global options around for client which doesn't use them.
@
text
@d1 1
a1 1
/* $OpenBSD: cfg.c,v 1.41 2015/09/01 10:10:59 nicm Exp $ */
d136 1
a136 1
cfg_default_done(unused struct cmd_q *cmdq)
@


1.41
log
@Work out config file when needed not at startup.
@
text
@d1 1
a1 1
/* $OpenBSD: cfg.c,v 1.40 2015/09/01 10:01:56 nicm Exp $ */
d101 1
a101 1
	while ((buf = fparseln(f, NULL, &line, delim, 0))) {
@


1.40
log
@Move initial conf load into cfg.c.
@
text
@d1 1
a1 1
/* $OpenBSD: cfg.c,v 1.39 2015/06/05 18:06:30 nicm Exp $ */
d31 1
d42 7
d51 2
a52 1
	char	*cause = NULL;
d70 7
@


1.39
log
@Change deref to the more sensible unref, and add a couple I missed before.
@
text
@d1 1
a1 1
/* $OpenBSD: cfg.c,v 1.38 2015/05/07 11:42:56 nicm Exp $ */
d26 1
d31 36
a66 6
struct cmd_q		 *cfg_cmd_q;
int			  cfg_finished;
int			  cfg_references;
char			**cfg_causes;
u_int			  cfg_ncauses;
struct client		 *cfg_client;
@


1.38
log
@Style spacing nits.
@
text
@d1 1
a1 1
/* $OpenBSD: cfg.c,v 1.37 2015/04/27 22:50:35 nicm Exp $ */
d111 1
a111 1
		cfg_client->references--;
@


1.37
log
@Reset cfg_ncauses to 0 as well or we could allocate the wrong size if
called again.
@
text
@d1 1
a1 1
/* $OpenBSD: cfg.c,v 1.36 2015/04/25 18:49:01 nicm Exp $ */
d124 1
a124 1
	va_end (ap);
@


1.36
log
@Fix some char* -> char *.
@
text
@d1 1
a1 1
/* $OpenBSD: cfg.c,v 1.35 2015/04/25 18:47:01 nicm Exp $ */
d143 1
d165 1
@


1.35
log
@Use a char **,u_int pair for cfg_causes.
@
text
@d1 1
a1 1
/* $OpenBSD: cfg.c,v 1.34 2015/04/19 21:34:21 nicm Exp $ */
d30 6
a35 6
struct cmd_q		*cfg_cmd_q;
int			 cfg_finished;
int			 cfg_references;
char**			 cfg_causes;
u_int			 cfg_ncauses;
struct client		*cfg_client;
d117 1
a117 1
cfg_add_cause(const char* fmt, ...)
d119 2
a120 2
	va_list	ap;
	char*	msg;
@


1.34
log
@Rewrite of tmux mouse support which was a mess. Instead of having
options for "mouse-this" and "mouse-that", mouse events may be bound as
keys and there is one option "mouse" that turns on mouse support
entirely (set -g mouse on).

See the new MOUSE SUPPORT section of the man page for description of the
key names and new flags (-t= to specify the pane or window under mouse
as a target, and send-keys -M to pass through a mouse event).

The default builtin bindings for the mouse are:

    bind -n   MouseDown1Pane select-pane -t=; send-keys -M
    bind -n MouseDown1Status select-window -t=
    bind -n   MouseDrag1Pane copy-mode -M
    bind -n MouseDrag1Border resize-pane -M

To get the effect of turning mode-mouse off, do:

    unbind -n MouseDrag1Pane
    unbind -temacs-copy MouseDrag1Pane

The old mouse options are now gone, set-option -q may be used to
suppress warnings if mixing configuration files.
@
text
@d1 1
a1 1
/* $OpenBSD: cfg.c,v 1.33 2014/10/27 22:23:47 nicm Exp $ */
d33 2
a34 1
ARRAY_DECL (, char *)	 cfg_causes = ARRAY_INITIALIZER;
d126 3
a128 1
	ARRAY_ADD(&cfg_causes, msg);
a133 1
	char	*cause;
d136 3
a138 4
	for (i = 0; i < ARRAY_LENGTH(&cfg_causes); i++) {
		cause = ARRAY_ITEM(&cfg_causes, i);
		cmdq_print(cmdq, "%s", cause);
		free(cause);
d140 3
a142 1
	ARRAY_FREE(&cfg_causes);
a148 1
	char			*cause;
d151 1
a151 1
	if (s == NULL || ARRAY_EMPTY(&cfg_causes))
d157 3
a159 4
	for (i = 0; i < ARRAY_LENGTH(&cfg_causes); i++) {
		cause = ARRAY_ITEM(&cfg_causes, i);
		window_copy_add(wp, "%s", cause);
		free(cause);
d161 3
a163 1
	ARRAY_FREE(&cfg_causes);
@


1.33
log
@Move cfg_causes local into cfg.c and remove struct causelist.
@
text
@d1 1
a1 1
/* $OpenBSD: cfg.c,v 1.32 2014/06/25 19:17:27 tobias Exp $ */
d78 1
a78 1
		cmdq_append(cmdq, cmdlist);
@


1.32
log
@Handle escaped back slashes and missing new lines at end of line by using
fparseln instead of reimplementing it on our own.

with input by and ok nicm@@
@
text
@d1 1
a1 1
/* $OpenBSD: cfg.c,v 1.31 2014/04/17 11:38:35 nicm Exp $ */
d33 1
a33 1
struct causelist	 cfg_causes;
d43 1
a43 1
	char		*buf, *cause1, *msg, *p;
d70 1
a70 2
			xasprintf(&msg, "%s:%zu: %s", path, line, cause1);
			ARRAY_ADD(&cfg_causes, msg);
d113 27
@


1.31
log
@Remove some unnecessary includes and fix a typo.
@
text
@d1 1
a1 1
/* $OpenBSD: cfg.c,v 1.30 2013/10/20 17:28:43 nicm Exp $ */
d26 1
d40 4
a43 3
	u_int		 n, found;
	char		*buf, *copy, *line, *cause1, *msg;
	size_t		 len, oldlen;
d52 3
a54 33
	n = found = 0;
	line = NULL;
	while ((buf = fgetln(f, &len))) {
		/* Trim \n. */
		if (buf[len - 1] == '\n')
			len--;
		log_debug("%s: %.*s", path, (int)len, buf);

		/* Current line is the continuation of the previous one. */
		if (line != NULL) {
			oldlen = strlen(line);
			line = xrealloc(line, 1, oldlen + len + 1);
		} else {
			oldlen = 0;
			line = xmalloc(len + 1);
		}

		/* Append current line to the previous. */
		memcpy(line + oldlen, buf, len);
		line[oldlen + len] = '\0';
		n++;

		/* Continuation: get next line? */
		len = strlen(line);
		if (len > 0 && line[len - 1] == '\\') {
			line[len - 1] = '\0';

			/* Ignore escaped backslash at EOL. */
			if (len > 1 && line[len - 2] != '\\')
				continue;
		}
		copy = line;
		line = NULL;
d57 5
a61 5
		buf = copy;
		while (isspace((u_char)*buf))
			buf++;
		if (*buf == '\0') {
			free(copy);
d66 2
a67 2
		if (cmd_string_parse(buf, &cmdlist, path, n, &cause1) != 0) {
			free(copy);
d70 1
a70 1
			xasprintf(&msg, "%s:%u: %s", path, n, cause1);
d75 1
a75 1
		free(copy);
a82 2
	if (line != NULL)
		free(line);
@


1.30
log
@Do not run any command line command from the client which starts the
server until after the configuration file completes. This prevents it
racing against run-shell or if-shell in .tmux.conf that run in the
background.
@
text
@d1 1
a1 1
/* $OpenBSD: cfg.c,v 1.29 2013/03/25 10:06:13 nicm Exp $ */
a19 1
#include <sys/stat.h>
@


1.29
log
@Add some additional debug logging.
@
text
@d1 1
a1 1
/* $OpenBSD: cfg.c,v 1.28 2013/03/24 09:54:10 nicm Exp $ */
d34 1
d131 14
@


1.28
log
@Add a command queue to standardize and simplify commands that call other
commands and allow a command to block execution of subsequent
commands. This allows run-shell and if-shell to be synchronous which has
been much requested.

Each client has a default command queue and commands are consumed one at
a time from it. A command may suspend execution from the queue by
returning CMD_RETURN_WAIT and then resume it by calling cmd_continue() -
for example run-shell does this from the callback that is fired after
the job is freed.

When the command queue becomes empty, command clients are automatically
exited (unless attaching). A callback is also fired - this is used for
nested commands in, for example, if-shell which can block execution of
the client's cmdq until a new cmdq becomes empty.

Also merge all the old error/info/print functions together and lose the
old curclient/cmdclient distinction - a cmdq is bound to one client (or
none if in the configuration file), this is a command client if
c->session is NULL otherwise an attached client.
@
text
@d1 1
a1 1
/* $OpenBSD: cfg.c,v 1.27 2013/03/22 15:54:29 nicm Exp $ */
d44 1
@


1.27
log
@Need to set clients in context before changing their reference count.
@
text
@d1 1
a1 1
/* $OpenBSD: cfg.c,v 1.26 2013/03/22 15:50:13 nicm Exp $ */
d30 1
a30 9
/*
 * Config file parser. Pretty quick and simple, each line is parsed into a
 * argv array and executed as a command.
 */

void printflike2 cfg_print(struct cmd_ctx *, const char *, ...);
void printflike2 cfg_error(struct cmd_ctx *, const char *, ...);

char			*cfg_cause;
d32 1
a32 1
int	 		 cfg_references;
d35 2
a36 34
void printflike2
cfg_print(unused struct cmd_ctx *ctx, unused const char *fmt, ...)
{
}

void printflike2
cfg_error(unused struct cmd_ctx *ctx, const char *fmt, ...)
{
	va_list	ap;

	va_start(ap, fmt);
	xvasprintf(&cfg_cause, fmt, ap);
	va_end(ap);
}

void printflike2
cfg_add_cause(struct causelist *causes, const char *fmt, ...)
{
	char	*cause;
	va_list	 ap;

	va_start(ap, fmt);
	xvasprintf(&cause, fmt, ap);
	va_end(ap);

	ARRAY_ADD(causes, cause);
}

/*
 * Load configuration file. Returns -1 for an error with a list of messages in
 * causes. Note that causes must be initialised by the caller!
 */
enum cmd_retval
load_cfg(const char *path, struct cmd_ctx *ctx, struct causelist *causes)
d39 2
a40 2
	u_int		 n;
	char		*buf, *copy, *line, *cause;
a42 1
	enum cmd_retval	 retval;
d45 2
a46 13
		cfg_add_cause(causes, "%s: %s", path, strerror(errno));
		return (CMD_RETURN_ERROR);
	}

	cfg_references++;

	if (ctx != NULL)
		cmd_ref_ctx(ctx);
	else {
		ctx = cmd_get_ctx(NULL, NULL);
		ctx->error = cfg_error;
		ctx->print = cfg_print;
		ctx->info = cfg_print;
d49 1
a49 1
	n = 0;
a50 1
	retval = CMD_RETURN_NORMAL;
d92 2
a93 1
		if (cmd_string_parse(buf, &cmdlist, &cause) != 0) {
d95 1
a95 1
			if (cause == NULL)
d97 3
a99 2
			cfg_add_cause(causes, "%s: %u: %s", path, n, cause);
			free(cause);
d103 1
d106 1
a106 14

		cfg_cause = NULL;
		switch (cmd_list_exec(cmdlist, ctx)) {
		case CMD_RETURN_YIELD:
			if (retval != CMD_RETURN_ATTACH)
				retval = CMD_RETURN_YIELD;
			break;
		case CMD_RETURN_ATTACH:
			retval = CMD_RETURN_ATTACH;
			break;
		case CMD_RETURN_ERROR:
		case CMD_RETURN_NORMAL:
			break;
		}
d108 1
a108 4
		if (cfg_cause != NULL) {
			cfg_add_cause(causes, "%s: %d: %s", path, n, cfg_cause);
			free(cfg_cause);
		}
d110 1
a110 3
	if (line != NULL) {
		cfg_add_cause(causes,
		    "%s: %d: line continuation at end of file", path, n);
a111 1
	}
d114 9
a122 1
	cmd_free_ctx(ctx);
d124 2
a125 1
	cfg_references--;
d127 2
a128 1
	return (retval);
d132 1
a132 1
show_cfg_causes(struct session *s)
a139 1

@


1.26
log
@load_cfg can actually use the same context now they are reference counted.
@
text
@d1 1
a1 1
/* $OpenBSD: cfg.c,v 1.25 2013/03/22 15:49:55 nicm Exp $ */
d95 1
a95 1
		ctx = cmd_get_ctx();
@


1.25
log
@Add functions to allocate and free command contexts rather than doing it
all on the stack.
@
text
@d1 1
a1 1
/* $OpenBSD: cfg.c,v 1.24 2013/03/22 10:41:57 nicm Exp $ */
d76 1
a76 1
load_cfg(const char *path, struct cmd_ctx *ctxin, struct causelist *causes)
a82 1
	struct cmd_ctx	*ctx;
d92 7
a98 9
	ctx = cmd_get_ctx();
	if (ctxin == NULL) {
		ctx->msgdata = NULL;
		ctx->curclient = NULL;
		ctx->cmdclient = NULL;
	} else {
		ctx->msgdata = ctxin->msgdata;
		ctx->curclient = ctxin->curclient;
		ctx->cmdclient = ctxin->cmdclient;
a99 4

	ctx->error = cfg_error;
	ctx->print = cfg_print;
	ctx->info = cfg_print;
@


1.24
log
@Don't try to print unterminated strings when loading configuration file.
@
text
@d1 1
a1 1
/* $OpenBSD: cfg.c,v 1.23 2013/03/22 10:31:22 nicm Exp $ */
d83 1
a83 1
	struct cmd_ctx	 ctx;
d93 15
a163 14
		if (ctxin == NULL) {
			ctx.msgdata = NULL;
			ctx.curclient = NULL;
			ctx.cmdclient = NULL;
		} else {
			ctx.msgdata = ctxin->msgdata;
			ctx.curclient = ctxin->curclient;
			ctx.cmdclient = ctxin->cmdclient;
		}

		ctx.error = cfg_error;
		ctx.print = cfg_print;
		ctx.info = cfg_print;

d165 1
a165 1
		switch (cmd_list_exec(cmdlist, &ctx)) {
d189 2
@


1.23
log
@No more lint means no more ARGSUSED.
@
text
@d1 1
a1 1
/* $OpenBSD: cfg.c,v 1.22 2013/03/21 16:54:37 nicm Exp $ */
d100 1
a100 1
		log_debug ("%s: %s", path, buf);
@


1.22
log
@Fix a couple of memory leaks, from Romain Francoise.
@
text
@d1 1
a1 1
/* $OpenBSD: cfg.c,v 1.21 2012/12/13 15:36:16 nicm Exp $ */
a42 1
/* ARGSUSED */
a47 1
/* ARGSUSED */
@


1.21
log
@Change load_cfg to fix a crash reported by jasper.
@
text
@d1 1
a1 1
/* $OpenBSD: cfg.c,v 1.20 2012/12/06 13:06:05 nicm Exp $ */
d134 2
a135 1
		if (*buf == '\0')
d137 1
@


1.20
log
@Use strlcat not strncat in load_cfg and some other trivial tidying from
Tiago Cunha.
@
text
@d1 1
a1 1
/* $OpenBSD: cfg.c,v 1.19 2012/11/27 22:59:34 nicm Exp $ */
d22 1
d82 2
a83 2
	char		*buf, *line, *cause;
	size_t		 len, newlen;
d99 1
d102 1
d106 2
a107 2
			newlen = strlen(line) + len + 1;
			line = xrealloc(line, 1, newlen);
d109 2
a110 3
			newlen = len + 1;
			line = xmalloc(newlen);
			*line = '\0';
d114 2
a115 1
		strlcat(line, buf, newlen);
d127 1
a127 1
		buf = line;
d130 7
d138 1
a138 1
			free(buf);
d145 1
a145 1
		free(buf);
@


1.19
log
@Fix return value of load_cfg, from Thomas Adam.
@
text
@d1 1
a1 1
/* $OpenBSD: cfg.c,v 1.18 2012/11/27 16:12:29 nicm Exp $ */
d82 1
a82 1
	size_t		 len;
a90 1
	n = 0;
d94 1
d101 7
a107 4
		if (line != NULL)
			line = xrealloc(line, 1, strlen(line) + len + 1);
		else {
			line = xmalloc(len + 1);
d111 2
a112 2
		/* Append buffer to line. strncat will terminate. */
		strncat(line, buf, len);
d119 1
d134 2
a135 2
		} else
			free(buf);
a137 1
		cfg_cause = NULL;
d168 1
a168 2
			cfg_add_cause(
			    causes, "%s: %d: %s", path, n, cfg_cause);
@


1.18
log
@Correctly aggregate together errors from nested config files (with
source-file). Fix by Thomas Adam, reported by Sam Livingstone-Gray
@
text
@d1 1
a1 1
/* $OpenBSD: cfg.c,v 1.17 2012/11/19 10:38:06 nicm Exp $ */
d76 1
a76 1
int
d89 1
a89 1
		return (-1);
@


1.17
log
@Use a utility function for common code to show errors in config file,
from Thomas Adam.
@
text
@d1 1
a1 1
/* $OpenBSD: cfg.c,v 1.16 2012/07/11 07:10:15 nicm Exp $ */
d37 4
a40 3
char	 	       *cfg_cause;
int     	 	cfg_finished;
struct causelist	cfg_causes = ARRAY_INITIALIZER;
d93 2
d176 2
@


1.16
log
@Make command exec functions return an enum rather than -1/0/1 values and
add a new value to mean "leave client running but don't attach" to fix
problems with using some commands in a command sequence. Most of the
work by Thomas Adam, problem reported by "jspenguin" on SF bug 3535531.
@
text
@d1 1
a1 1
/* $OpenBSD: cfg.c,v 1.15 2012/07/10 11:53:01 nicm Exp $ */
d175 22
@


1.15
log
@xfree is not particularly helpful, remove it. From Thomas Adam.
@
text
@d1 1
a1 1
/* $OpenBSD: cfg.c,v 1.14 2012/05/17 21:21:31 nicm Exp $ */
d84 1
a84 1
	int		 retval;
d93 1
a93 1
	retval = 0;
d148 12
a159 2
		if (cmd_list_exec(cmdlist, &ctx) == 1)
			retval = 1;
@


1.14
log
@Ignore line continuation when escaped as \\, from Simon Nicolussi.
@
text
@d1 1
a1 1
/* $OpenBSD: cfg.c,v 1.13 2011/08/24 10:46:01 nicm Exp $ */
d24 1
d121 1
a121 1
			xfree(buf);
d125 1
a125 1
			xfree(cause);
d128 1
a128 1
			xfree(buf);
d154 1
a154 1
			xfree(cfg_cause);
d160 1
a160 1
		xfree(line);
@


1.13
log
@Support \ for line continuation in the configuration file, from Julius
Plenz.
@
text
@d1 1
a1 1
/* $OpenBSD: cfg.c,v 1.12 2010/12/29 21:28:32 nicm Exp $ */
d112 3
a114 1
			continue;
@


1.12
log
@Allow the config file parser and source-file to return "don't exit" to
the client to let attach work from configuration files.
@
text
@d1 1
a1 1
/* $OpenBSD: cfg.c,v 1.11 2010/05/25 19:47:30 nicm Exp $ */
d95 4
a98 1
			buf[len - 1] = '\0';
d100 2
a101 4
			line = xrealloc(line, 1, len + 1);
			memcpy(line, buf, len);
			line[len] = '\0';
			buf = line;
d103 3
d108 9
d118 1
d124 2
a125 1
		}
d149 2
a150 1
			cfg_add_cause(causes, "%s: %d: %s", path, n, cfg_cause);
d154 3
a156 1
	if (line != NULL)
d158 1
@


1.11
log
@Fix an out-of-date comment.
@
text
@d1 1
a1 1
/* $OpenBSD: cfg.c,v 1.10 2010/02/06 23:22:27 nicm Exp $ */
d83 1
d92 1
d130 2
a131 1
		cmd_list_exec(cmdlist, &ctx);
a135 1
			continue;
d142 1
a142 3
	if (ARRAY_LENGTH(causes) != 0)
		return (-1);
	return (0);
@


1.10
log
@Use the array.h code for the causes list.
@
text
@d1 1
a1 1
/* $OpenBSD: cfg.c,v 1.9 2010/02/06 17:15:33 nicm Exp $ */
d72 1
a72 1
 * causes. Note that causes and ncauses must be initialised by the caller!
@


1.9
log
@Instead of bailing out on the first configuration file error, carry on,
collecting all the errors, then start with the active window in more mode
displaying them.
@
text
@d1 1
a1 1
/* $OpenBSD: cfg.c,v 1.8 2009/11/26 21:37:13 nicm Exp $ */
d36 3
a38 4
char	 *cfg_cause;
int       cfg_finished;
char    **cfg_causes;
u_int     cfg_ncauses;
d57 2
a58 2
void printflike3
cfg_add_cause(u_int *ncauses, char ***causes, const char *fmt, ...)
d67 1
a67 2
	*causes = xrealloc(*causes, *ncauses + 1, sizeof **causes);
	(*causes)[(*ncauses)++] = cause;
d75 1
a75 2
load_cfg(
    const char *path, struct cmd_ctx *ctxin, u_int *ncauses, char ***causes)
d85 1
a85 1
		cfg_add_cause(ncauses, causes, "%s: %s", path, strerror(errno));
d105 1
a105 2
			cfg_add_cause(
			    ncauses, causes, "%s: %u: %s", path, n, cause);
d131 1
a131 2
			cfg_add_cause(
			    ncauses, causes, "%s: %d: %s", path, n, cfg_cause);
d140 1
a140 1
	if (*ncauses != 0)
@


1.8
log
@Remove a couple of unused arguments where possible, and add /* ARGSUSED */ to
the rest to reduce lint output.
@
text
@d1 1
a1 1
/* $OpenBSD: cfg.c,v 1.7 2009/10/26 21:42:04 deraadt Exp $ */
d37 3
d58 18
d77 2
a78 1
load_cfg(const char *path, struct cmd_ctx *ctxin, char **cause)
d82 1
a82 1
	char		*buf, *line, *ptr;
d88 2
a89 2
		xasprintf(cause, "%s: %s", path, strerror(errno));
		return (1);
d105 2
a106 2
		if (cmd_string_parse(buf, &cmdlist, cause) != 0) {
			if (*cause == NULL)
d108 4
a111 1
			goto error;
d135 4
a138 2
			*cause = cfg_cause;
			goto error;
d145 2
a147 10

error:
	if (line != NULL)
		xfree(line);
	fclose(f);

	xasprintf(&ptr, "%s: %s at line %u", path, *cause, n);
	xfree(*cause);
	*cause = ptr;
	return (1);
@


1.7
log
@tabs are better; ok nicm
@
text
@d1 1
a1 1
/* $OpenBSD: cfg.c,v 1.6 2009/08/23 17:29:51 nicm Exp $ */
d38 1
d44 1
@


1.6
log
@When using source-file, run the commands in the context of the source-file
command rather than with no context. This makes things like attach work from a
file.
@
text
@d1 1
a1 1
/* $OpenBSD: cfg.c,v 1.5 2009/08/23 16:45:00 nicm Exp $ */
d56 1
a56 1
	FILE   	        *f;
d58 1
a58 1
	char	        *buf, *line, *ptr;
@


1.5
log
@The cursession member in struct cmd_ctx is always either curclient->session or
NULL when curclient is also NULL, so just eliminate it.
@
text
@d1 1
a1 1
/* $OpenBSD: cfg.c,v 1.4 2009/08/09 08:34:17 nicm Exp $ */
d54 1
a54 1
load_cfg(const char *path, char **cause)
d90 9
a98 2
		ctx.msgdata = NULL;
		ctx.curclient = NULL;
a102 2

		ctx.cmdclient = NULL;
@


1.4
log
@Don't leak in the (rare) case of an invalid command at the end of a file not
terminated by a \n.
@
text
@d1 1
a1 1
/* $OpenBSD: cfg.c,v 1.3 2009/07/30 17:46:12 nicm Exp $ */
a90 1
		ctx.cursession = NULL;
@


1.3
log
@Don't babysit people and let them try to load /dev/zero or (more useful)
/dev/null if they want.
@
text
@d1 1
a1 1
/* $OpenBSD: cfg.c,v 1.2 2009/06/25 06:00:45 nicm Exp $ */
d115 2
@


1.2
log
@Unused prototypes. Found by lint, no binary change.
@
text
@d1 1
a1 1
/* $OpenBSD: cfg.c,v 1.1 2009/06/01 22:58:49 nicm Exp $ */
a57 1
	struct stat	 sb;
a61 9

	if (stat(path, &sb) != 0) {
		xasprintf(cause, "%s: %s", path, strerror(errno));
		return (-1);
	}
	if (!S_ISREG(sb.st_mode)) {
		xasprintf(cause, "%s: not a regular file", path);
		return (-1);
	}
@


1.1
log
@Import tmux, a terminal multiplexor allowing (among other things) a single
terminal to be switched between several different windows and programs
displayed on one terminal be detached from one terminal and moved to another.

ok deraadt pirofti
@
text
@d1 1
a1 1
/* $OpenBSD$ */
a32 1
char	 *cfg_string(FILE *, char, int);
@

