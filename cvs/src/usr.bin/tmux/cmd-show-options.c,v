head	1.42;
access;
symbols
	OPENBSD_6_1:1.40.0.4
	OPENBSD_6_1_BASE:1.40
	OPENBSD_6_0:1.31.0.2
	OPENBSD_6_0_BASE:1.31
	OPENBSD_5_9:1.30.0.2
	OPENBSD_5_9_BASE:1.30
	OPENBSD_5_8:1.23.0.6
	OPENBSD_5_8_BASE:1.23
	OPENBSD_5_7:1.23.0.2
	OPENBSD_5_7_BASE:1.23
	OPENBSD_5_6:1.22.0.4
	OPENBSD_5_6_BASE:1.22
	OPENBSD_5_5:1.21.0.4
	OPENBSD_5_5_BASE:1.21
	OPENBSD_5_4:1.20.0.2
	OPENBSD_5_4_BASE:1.20
	OPENBSD_5_3:1.16.0.4
	OPENBSD_5_3_BASE:1.16
	OPENBSD_5_2:1.16.0.2
	OPENBSD_5_2_BASE:1.16
	OPENBSD_5_1_BASE:1.14
	OPENBSD_5_1:1.14.0.4
	OPENBSD_5_0:1.14.0.2
	OPENBSD_5_0_BASE:1.14
	OPENBSD_4_9:1.13.0.2
	OPENBSD_4_9_BASE:1.13
	OPENBSD_4_8:1.10.0.4
	OPENBSD_4_8_BASE:1.10
	OPENBSD_4_7:1.10.0.2
	OPENBSD_4_7_BASE:1.10
	OPENBSD_4_6:1.1.0.4
	OPENBSD_4_6_BASE:1.1;
locks; strict;
comment	@ * @;


1.42
date	2017.05.10.13.05.41;	author nicm;	state Exp;
branches;
next	1.41;
commitid	ZutqzMqQdCld09MP;

1.41
date	2017.04.22.10.22.39;	author nicm;	state Exp;
branches;
next	1.40;
commitid	RXMp6wwG5a5Y82bo;

1.40
date	2017.01.30.21.41.17;	author nicm;	state Exp;
branches;
next	1.39;
commitid	2CvN8VpguQcq8POo;

1.39
date	2017.01.24.19.11.46;	author nicm;	state Exp;
branches;
next	1.38;
commitid	kKr1lZUu2NYuA7Hw;

1.38
date	2017.01.18.10.08.05;	author nicm;	state Exp;
branches;
next	1.37;
commitid	xB3kWBq9sJabS6m7;

1.37
date	2017.01.18.08.40.50;	author nicm;	state Exp;
branches;
next	1.36;
commitid	e9LZ8YwZPoG7kBbl;

1.36
date	2017.01.16.14.49.14;	author nicm;	state Exp;
branches;
next	1.35;
commitid	4TgBXjnsq23XHMH4;

1.35
date	2017.01.15.20.48.41;	author nicm;	state Exp;
branches;
next	1.34;
commitid	osUO2wUOqrqm0Q8V;

1.34
date	2016.10.16.19.04.05;	author nicm;	state Exp;
branches;
next	1.33;
commitid	pxm6osuE99zELpkU;

1.33
date	2016.10.14.22.14.22;	author nicm;	state Exp;
branches;
next	1.32;
commitid	S3IpyYTkmviA6lfM;

1.32
date	2016.10.10.21.51.39;	author nicm;	state Exp;
branches;
next	1.31;
commitid	TaZ3kOtGiWwKofka;

1.31
date	2016.03.03.14.15.22;	author nicm;	state Exp;
branches;
next	1.30;
commitid	3WMtbfmTbJwTavl5;

1.30
date	2016.01.19.15.59.12;	author nicm;	state Exp;
branches;
next	1.29;
commitid	P3qmSOx6KrDBsb0c;

1.29
date	2015.12.14.00.31.54;	author nicm;	state Exp;
branches;
next	1.28;
commitid	rE682EC14v4gpeFy;

1.28
date	2015.12.13.21.53.57;	author nicm;	state Exp;
branches;
next	1.27;
commitid	gsQkQsSyBCSmU9ax;

1.27
date	2015.12.13.18.15.13;	author nicm;	state Exp;
branches;
next	1.26;
commitid	E3Pp6iSp9kmoHiIw;

1.26
date	2015.12.13.14.32.38;	author nicm;	state Exp;
branches;
next	1.25;
commitid	uzMkp8Z4FE6WB6s6;

1.25
date	2015.11.20.12.01.19;	author nicm;	state Exp;
branches;
next	1.24;
commitid	qNEZpcD0RcTrAsAp;

1.24
date	2015.10.27.15.58.42;	author nicm;	state Exp;
branches;
next	1.23;
commitid	89xhQafU35Q5MQVC;

1.23
date	2014.10.20.22.29.25;	author nicm;	state Exp;
branches;
next	1.22;
commitid	Gq8hgMoG3t1Wy1Zv;

1.22
date	2014.04.17.07.43.20;	author nicm;	state Exp;
branches;
next	1.21;

1.21
date	2013.10.10.12.00.23;	author nicm;	state Exp;
branches;
next	1.20;

1.20
date	2013.03.25.10.04.04;	author nicm;	state Exp;
branches;
next	1.19;

1.19
date	2013.03.24.09.54.10;	author nicm;	state Exp;
branches;
next	1.18;

1.18
date	2013.03.21.16.17.01;	author nicm;	state Exp;
branches;
next	1.17;

1.17
date	2013.03.21.16.15.52;	author nicm;	state Exp;
branches;
next	1.16;

1.16
date	2012.07.11.07.10.15;	author nicm;	state Exp;
branches;
next	1.15;

1.15
date	2012.02.25.12.57.42;	author nicm;	state Exp;
branches;
next	1.14;

1.14
date	2011.04.05.19.37.01;	author nicm;	state Exp;
branches;
next	1.13;

1.13
date	2011.01.04.02.03.41;	author nicm;	state Exp;
branches;
next	1.12;

1.12
date	2011.01.04.00.42.47;	author nicm;	state Exp;
branches;
next	1.11;

1.11
date	2011.01.01.16.51.21;	author nicm;	state Exp;
branches;
next	1.10;

1.10
date	2009.12.10.09.16.52;	author nicm;	state Exp;
branches;
next	1.9;

1.9
date	2009.12.03.22.50.10;	author nicm;	state Exp;
branches;
next	1.8;

1.8
date	2009.12.03.17.44.02;	author nicm;	state Exp;
branches;
next	1.7;

1.7
date	2009.11.13.19.53.29;	author nicm;	state Exp;
branches;
next	1.6;

1.6
date	2009.09.21.14.46.47;	author nicm;	state Exp;
branches;
next	1.5;

1.5
date	2009.07.26.12.58.44;	author nicm;	state Exp;
branches;
next	1.4;

1.4
date	2009.07.15.07.50.34;	author nicm;	state Exp;
branches;
next	1.3;

1.3
date	2009.07.13.23.11.35;	author nicm;	state Exp;
branches;
next	1.2;

1.2
date	2009.07.07.19.49.19;	author nicm;	state Exp;
branches;
next	1.1;

1.1
date	2009.06.01.22.58.49;	author nicm;	state Exp;
branches;
next	;


desc
@@


1.42
log
@Expand formats in option names and add -F flag to do so in option values as well.
@
text
@/* $OpenBSD: cmd-show-options.c,v 1.41 2017/04/22 10:22:39 nicm Exp $ */

/*
 * Copyright (c) 2007 Nicholas Marriott <nicholas.marriott@@gmail.com>
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF MIND, USE, DATA OR PROFITS, WHETHER
 * IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING
 * OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */

#include <sys/types.h>

#include <stdlib.h>
#include <string.h>
#include <vis.h>

#include "tmux.h"

/*
 * Show options.
 */

static enum cmd_retval	cmd_show_options_exec(struct cmd *, struct cmdq_item *);

static enum cmd_retval	cmd_show_options_one(struct cmd *, struct cmdq_item *,
			    struct options *);
static enum cmd_retval	cmd_show_options_all(struct cmd *, struct cmdq_item *,
		    	    struct options *);

const struct cmd_entry cmd_show_options_entry = {
	.name = "show-options",
	.alias = "show",

	.args = { "gqst:vw", 0, 1 },
	.usage = "[-gqsvw] [-t target-session|target-window] [option]",

	.target = { 't', CMD_FIND_WINDOW, CMD_FIND_CANFAIL },

	.flags = CMD_AFTERHOOK,
	.exec = cmd_show_options_exec
};

const struct cmd_entry cmd_show_window_options_entry = {
	.name = "show-window-options",
	.alias = "showw",

	.args = { "gvt:", 0, 1 },
	.usage = "[-gv] " CMD_TARGET_WINDOW_USAGE " [option]",

	.target = { 't', CMD_FIND_WINDOW, CMD_FIND_CANFAIL },

	.flags = CMD_AFTERHOOK,
	.exec = cmd_show_options_exec
};

static enum cmd_retval
cmd_show_options_exec(struct cmd *self, struct cmdq_item *item)
{
	struct args			*args = self->args;
	struct cmd_find_state		*fs = &item->target;
	struct options			*oo;
	enum options_table_scope	 scope;
	char				*cause;
	int				 window;

	window = (self->entry == &cmd_show_window_options_entry);
	scope = options_scope_from_flags(args, window, fs, &oo, &cause);
	if (scope == OPTIONS_TABLE_NONE) {
		cmdq_error(item, "%s", cause);
		free(cause);
		return (CMD_RETURN_ERROR);
	}

	if (args->argc == 0)
		return (cmd_show_options_all(self, item, oo));
	else
		return (cmd_show_options_one(self, item, oo));
}

static void
cmd_show_options_print(struct cmd *self, struct cmdq_item *item,
    struct options_entry *o, int idx)
{
	const char	*name;
	const char	*value;
	char		*tmp, *escaped;
	u_int		 size, i;

	if (idx != -1) {
		xasprintf(&tmp, "%s[%d]", options_name(o), idx);
		name = tmp;
	} else {
		if (options_array_size(o, &size) != -1) {
			for (i = 0; i < size; i++) {
				if (options_array_get(o, i) == NULL)
					continue;
				cmd_show_options_print(self, item, o, i);
			}
			return;
		}
		tmp = NULL;
		name = options_name(o);
	}

	value = options_tostring(o, idx, 0);
	if (args_has(self->args, 'v'))
		cmdq_print(item, "%s", value);
	else if (options_isstring(o)) {
		utf8_stravis(&escaped, value, VIS_OCTAL|VIS_TAB|VIS_NL|VIS_DQ);
		cmdq_print(item, "%s \"%s\"", name, escaped);
		free(escaped);
	} else
		cmdq_print(item, "%s %s", name, value);

	free(tmp);
}

static enum cmd_retval
cmd_show_options_one(struct cmd *self, struct cmdq_item *item,
    struct options *oo)
{
	struct args		*args = self->args;
	struct client		*c = cmd_find_client(item, NULL, 1);
	struct session		*s = item->target.s;
	struct winlink		*wl = item->target.wl;
	struct options_entry	*o;
	int			 idx, ambiguous;
	char			*name;

	name = format_single(item, args->argv[0], c, s, wl, NULL);
	o = options_match_get(oo, name, &idx, 1, &ambiguous);
	if (o == NULL) {
		if (args_has(args, 'q')) {
			free(name);
			return (CMD_RETURN_NORMAL);
		}
		if (ambiguous) {
			cmdq_error(item, "ambiguous option: %s", name);
			free(name);
			return (CMD_RETURN_ERROR);
		}
		if (*name != '@@' &&
		    options_match_get(oo, name, &idx, 0, &ambiguous) != NULL) {
			free(name);
			return (CMD_RETURN_NORMAL);
		}
		cmdq_error(item, "unknown option: %s", name);
		free(name);
		return (CMD_RETURN_ERROR);
	}
	cmd_show_options_print(self, item, o, idx);
	free(name);
	return (CMD_RETURN_NORMAL);
}

static enum cmd_retval
cmd_show_options_all(struct cmd *self, struct cmdq_item *item,
    struct options *oo)
{
	struct options_entry			 *o;
	const struct options_table_entry	*oe;
	u_int					 size, idx;

	o = options_first(oo);
	while (o != NULL) {
		oe = options_table_entry(o);
		if (oe != NULL && oe->style != NULL) {
			o = options_next(o);
			continue;
		}
		if (options_array_size(o, &size) == -1)
			cmd_show_options_print(self, item, o, -1);
		else {
			for (idx = 0; idx < size; idx++) {
				if (options_array_get(o, idx) == NULL)
					continue;
				cmd_show_options_print(self, item, o, idx);
			}
		}
		o = options_next(o);
	}
	return (CMD_RETURN_NORMAL);
}
@


1.41
log
@Get rid of the extra layer of flags and cmd_prepare() and just store the
CMD_FIND_* flags in the cmd_entry and call it for the command. Commands
with special requirements call it themselves and update the target for
hooks to use.
@
text
@d1 1
a1 1
/* $OpenBSD: cmd-show-options.c,v 1.40 2017/01/30 21:41:17 nicm Exp $ */
d131 3
d136 1
a136 1
	const char		*name = args->argv[0];
d138 1
d141 2
a142 1
		if (args_has(args, 'q'))
d144 1
d147 1
d151 2
a152 1
		    options_match_get(oo, name, &idx, 0, &ambiguous) != NULL)
d154 1
d156 1
d160 1
@


1.40
log
@When a flag option is used in a format, it should use the number form
not string.
@
text
@d1 1
a1 1
/* $OpenBSD: cmd-show-options.c,v 1.39 2017/01/24 19:11:46 nicm Exp $ */
d45 1
a45 1
	.tflag = CMD_WINDOW_CANFAIL,
d58 1
a58 1
	.tflag = CMD_WINDOW_CANFAIL,
d68 1
a68 1
	struct cmd_find_state		*fs = &item->state.tflag;
@


1.39
log
@If given an array option without an index either show or set all items,
and support -a for array options. Allow the separator for set to be
specified in the options table (will be used for backwards compatibility
later).
@
text
@d1 1
a1 1
/* $OpenBSD: cmd-show-options.c,v 1.38 2017/01/18 10:08:05 nicm Exp $ */
d113 1
a113 1
	value = options_tostring(o, idx);
@


1.38
log
@Plain stravis() because it will mangle UTF-8 characters, so add
utf8_stravis() which calls our existing utf8_strvis() and use it instead
@
text
@d1 1
a1 1
/* $OpenBSD: cmd-show-options.c,v 1.37 2017/01/18 08:40:50 nicm Exp $ */
d95 1
d101 8
@


1.37
log
@options_match needs to explicitly check for user options.
@
text
@d1 1
a1 1
/* $OpenBSD: cmd-show-options.c,v 1.36 2017/01/16 14:49:14 nicm Exp $ */
d108 1
a108 1
		stravis(&escaped, value, VIS_OCTAL|VIS_TAB|VIS_NL|VIS_DQ);
@


1.36
log
@getopt() has a struct option so just return to using options_entry.
@
text
@d1 1
a1 1
/* $OpenBSD: cmd-show-options.c,v 1.35 2017/01/15 20:48:41 nicm Exp $ */
d134 2
a135 1
		if (options_match_get(oo, name, &idx, 0, &ambiguous) != NULL)
@


1.35
log
@Major tidy up and rework of options tree and set-option/show-options
commands this pushes more of the code into options.c and ties it more
closely to the options table rather than having an unnecessary
split. Also add support for array options (will be used later). Only
(intentional) user visible change is that show-options output is now
passed through vis(3) with VIS_DQ so quotes are escaped.
@
text
@d1 1
a1 1
/* $OpenBSD: cmd-show-options.c,v 1.34 2016/10/16 19:04:05 nicm Exp $ */
d90 1
a90 1
    struct option *o, int idx)
d121 4
a124 4
	struct args	*args = self->args;
	struct option	*o;
	int		 idx, ambiguous;
	const char	*name = args->argv[0];
d147 3
a149 3
	struct option			 *o;
	const struct options_table_entry *oe;
	u_int			 	 size, idx;
@


1.34
log
@Mass rename struct cmd_q to struct cmdq_item and related.
@
text
@d1 1
a1 1
/* $OpenBSD: cmd-show-options.c,v 1.33 2016/10/14 22:14:22 nicm Exp $ */
d23 1
d34 1
a34 1
			    struct options *, int);
d36 1
a36 1
		    	    struct options *, enum options_table_scope);
d68 1
a68 2
	struct session			*s = item->state.tflag.s;
	struct winlink			*wl = item->state.tflag.wl;
d71 2
a72 2
	int				 quiet;
	const char			*target;
d74 6
a79 30
	if (args_has(self->args, 's')) {
		oo = global_options;
		scope = OPTIONS_TABLE_SERVER;
	} else if (args_has(self->args, 'w') ||
	    self->entry == &cmd_show_window_options_entry) {
		scope = OPTIONS_TABLE_WINDOW;
		if (args_has(self->args, 'g'))
			oo = global_w_options;
		else if (wl == NULL) {
			target = args_get(args, 't');
			if (target != NULL) {
				cmdq_error(item, "no such window: %s", target);
			} else
				cmdq_error(item, "no current window");
			return (CMD_RETURN_ERROR);
		} else
			oo = wl->window->options;
	} else {
		scope = OPTIONS_TABLE_SESSION;
		if (args_has(self->args, 'g'))
			oo = global_s_options;
		else if (s == NULL) {
			target = args_get(args, 't');
			if (target != NULL) {
				cmdq_error(item, "no such session: %s", target);
			} else
				cmdq_error(item, "no current session");
			return (CMD_RETURN_ERROR);
		} else
			oo = s->options;
a81 1
	quiet = args_has(self->args, 'q');
d83 1
a83 1
		return (cmd_show_options_all(self, item, oo, scope));
d85 30
a114 1
		return (cmd_show_options_one(self, item, oo, quiet));
d119 1
a119 1
    struct options *oo, int quiet)
d121 11
a131 12
	struct args				*args = self->args;
	const char				*name = args->argv[0];
	const struct options_table_entry	*oe;
	struct options_entry			*o;
	const char				*optval;

retry:
	if (*name == '@@') {
		if ((o = options_find1(oo, name)) == NULL) {
			if (quiet)
				return (CMD_RETURN_NORMAL);
			cmdq_error(item, "unknown option: %s", name);
d134 1
a134 14
		if (args_has(self->args, 'v'))
			cmdq_print(item, "%s", o->str);
		else
			cmdq_print(item, "%s \"%s\"", o->name, o->str);
		return (CMD_RETURN_NORMAL);
	}

	oe = NULL;
	if (options_table_find(name, &oe) != 0) {
		cmdq_error(item, "ambiguous option: %s", name);
		return (CMD_RETURN_ERROR);
	}
	if (oe == NULL) {
		if (quiet)
d139 1
a139 11
	if (oe->style != NULL) {
		name = oe->style;
		goto retry;
	}
	if ((o = options_find1(oo, oe->name)) == NULL)
		return (CMD_RETURN_NORMAL);
	optval = options_table_print_entry(oe, o, args_has(self->args, 'v'));
	if (args_has(self->args, 'v'))
		cmdq_print(item, "%s", optval);
	else
		cmdq_print(item, "%s %s", oe->name, optval);
d145 1
a145 1
    struct options *oo, enum options_table_scope scope)
d147 3
a149 4
	const struct options_table_entry	*oe;
	struct options_entry			*o;
	const char				*optval;
	int					 vflag;
d153 13
a165 5
		if (*o->name == '@@') {
			if (args_has(self->args, 'v'))
				cmdq_print(item, "%s", o->str);
			else
				cmdq_print(item, "%s \"%s\"", o->name, o->str);
a168 14

	vflag = args_has(self->args, 'v');
	for (oe = options_table; oe->name != NULL; oe++) {
		if (oe->style != NULL || oe->scope != scope)
			continue;
		if ((o = options_find1(oo, oe->name)) == NULL)
			continue;
		optval = options_table_print_entry(oe, o, vflag);
		if (vflag)
			cmdq_print(item, "%s", optval);
		else
			cmdq_print(item, "%s %s", oe->name, optval);
	}

@


1.33
log
@Add CMD_AFTERHOOK flag to the easy commands that don't need any special handling.
@
text
@d1 1
a1 1
/* $OpenBSD: cmd-show-options.c,v 1.32 2016/10/10 21:51:39 nicm Exp $ */
d30 1
a30 1
static enum cmd_retval	cmd_show_options_exec(struct cmd *, struct cmd_q *);
d32 1
a32 1
static enum cmd_retval	cmd_show_options_one(struct cmd *, struct cmd_q *,
d34 1
a34 1
static enum cmd_retval	cmd_show_options_all(struct cmd *, struct cmd_q *,
d64 1
a64 1
cmd_show_options_exec(struct cmd *self, struct cmd_q *cmdq)
d67 2
a68 2
	struct session			*s = cmdq->state.tflag.s;
	struct winlink			*wl = cmdq->state.tflag.wl;
d85 1
a85 1
				cmdq_error(cmdq, "no such window: %s", target);
d87 1
a87 1
				cmdq_error(cmdq, "no current window");
d98 1
a98 1
				cmdq_error(cmdq, "no such session: %s", target);
d100 1
a100 1
				cmdq_error(cmdq, "no current session");
d108 1
a108 1
		return (cmd_show_options_all(self, cmdq, oo, scope));
d110 1
a110 1
		return (cmd_show_options_one(self, cmdq, oo, quiet));
d114 1
a114 1
cmd_show_options_one(struct cmd *self, struct cmd_q *cmdq,
d128 1
a128 1
			cmdq_error(cmdq, "unknown option: %s", name);
d132 1
a132 1
			cmdq_print(cmdq, "%s", o->str);
d134 1
a134 1
			cmdq_print(cmdq, "%s \"%s\"", o->name, o->str);
d140 1
a140 1
		cmdq_error(cmdq, "ambiguous option: %s", name);
d146 1
a146 1
		cmdq_error(cmdq, "unknown option: %s", name);
d157 1
a157 1
		cmdq_print(cmdq, "%s", optval);
d159 1
a159 1
		cmdq_print(cmdq, "%s %s", oe->name, optval);
d164 2
a165 2
cmd_show_options_all(struct cmd *self, struct cmd_q *cmdq, struct options *oo,
    enum options_table_scope scope)
d176 1
a176 1
				cmdq_print(cmdq, "%s", o->str);
d178 1
a178 1
				cmdq_print(cmdq, "%s \"%s\"", o->name, o->str);
d191 1
a191 1
			cmdq_print(cmdq, "%s", optval);
d193 1
a193 1
			cmdq_print(cmdq, "%s %s", oe->name, optval);
@


1.32
log
@Add static in cmd-* and fix a few other nits.
@
text
@d1 1
a1 1
/* $OpenBSD: cmd-show-options.c,v 1.31 2016/03/03 14:15:22 nicm Exp $ */
d46 1
a46 1
	.flags = 0,
d59 1
a59 1
	.flags = 0,
@


1.31
log
@show-* and set-* need to handle a missing target.
@
text
@d1 1
a1 1
/* $OpenBSD: cmd-show-options.c,v 1.30 2016/01/19 15:59:12 nicm Exp $ */
d30 1
a30 1
enum cmd_retval	 cmd_show_options_exec(struct cmd *, struct cmd_q *);
d32 4
a35 4
enum cmd_retval	cmd_show_options_one(struct cmd *, struct cmd_q *,
		    struct options *, int);
enum cmd_retval cmd_show_options_all(struct cmd *, struct cmd_q *,
	    	    struct options *, enum options_table_scope);
d63 1
a63 1
enum cmd_retval
d113 1
a113 1
enum cmd_retval
d163 1
a163 1
enum cmd_retval
@


1.30
log
@I no longer use my SourceForge address so replace it.
@
text
@d1 1
a1 1
/* $OpenBSD: cmd-show-options.c,v 1.29 2015/12/14 00:31:54 nicm Exp $ */
d66 7
a72 6
	struct args				*args = self->args;
	struct session				*s = cmdq->state.tflag.s;
	struct winlink				*wl = cmdq->state.tflag.wl;
	struct options				*oo;
	enum options_table_scope		 scope;
	int					 quiet;
d82 8
a89 1
		else
d95 8
a102 1
		else
@


1.29
log
@Instead of combined flags for -c, -s, -t, split into different sets
using an enum and simplify the parsing code.
@
text
@d1 1
a1 1
/* $OpenBSD: cmd-show-options.c,v 1.28 2015/12/13 21:53:57 nicm Exp $ */
d4 1
a4 1
 * Copyright (c) 2007 Nicholas Marriott <nicm@@users.sourceforge.net>
@


1.28
log
@Use member names in cmd_entry definitions so I stop getting confused
about the order.
@
text
@d1 1
a1 1
/* $OpenBSD: cmd-show-options.c,v 1.27 2015/12/13 18:15:13 nicm Exp $ */
d44 3
a46 1
	.flags = CMD_WINDOW_T|CMD_CANFAIL,
d57 3
a59 1
	.flags = CMD_WINDOW_T|CMD_CANFAIL,
@


1.27
log
@show-options and environment need CANFAIL flag.
@
text
@d1 1
a1 1
/* $OpenBSD: cmd-show-options.c,v 1.26 2015/12/13 14:32:38 nicm Exp $ */
d38 8
a45 5
	"show-options", "show",
	"gqst:vw", 0, 1,
	"[-gqsvw] [-t target-session|target-window] [option]",
	CMD_WINDOW_T|CMD_CANFAIL,
	cmd_show_options_exec
d49 8
a56 5
	"show-window-options", "showw",
	"gvt:", 0, 1,
	"[-gv] " CMD_TARGET_WINDOW_USAGE " [option]",
	CMD_WINDOW_T|CMD_CANFAIL,
	cmd_show_options_exec
@


1.26
log
@Instead of every command resolving the target (-t or -s) itself, prepare
the state (client, session, winlink, pane) for it it before entering the
command. Each command provides some flags that tell the prepare step
what it is expecting.

This is a requirement for having hooks on commands (for example, if you
hook "select-window -t1:2", the hook command should to operate on window
1:2 not whatever it thinks is the current window), and should allow some
other target improvements.

The old cmd_find_* functions remain for the moment but that layer will
be dropped later.

Joint work with Thomas Adam.
@
text
@d1 1
a1 1
/* $OpenBSD: cmd-show-options.c,v 1.25 2015/11/20 12:01:19 nicm Exp $ */
d41 1
a41 1
	CMD_WINDOW_T,
d49 1
a49 1
	CMD_WINDOW_T,
@


1.25
log
@Instead of separate tables for different types of options, give each
option a scope type (server, session, window) in one table.
@
text
@d1 1
a1 1
/* $OpenBSD: cmd-show-options.c,v 1.24 2015/10/27 15:58:42 nicm Exp $ */
d41 1
a41 1
	0,
d49 1
a49 1
	0,
d56 6
a61 6
	struct args		*args = self->args;
	struct session		*s;
	struct winlink		*wl;
	struct options		*oo;
	int			 quiet;
	enum options_table_scope scope;
d71 1
a71 4
		else {
			wl = cmd_find_window(cmdq, args_get(args, 't'), NULL);
			if (wl == NULL)
				return (CMD_RETURN_ERROR);
a72 1
		}
d77 1
a77 4
		else {
			s = cmd_find_session(cmdq, args_get(args, 't'), 0);
			if (s == NULL)
				return (CMD_RETURN_ERROR);
a78 1
		}
@


1.24
log
@Move struct options into options.c.
@
text
@d1 1
a1 1
/* $OpenBSD: cmd-show-options.c,v 1.23 2014/10/20 22:29:25 nicm Exp $ */
d35 1
a35 1
		    const struct options_table_entry *, struct options *);
d56 6
a61 6
	struct args				*args = self->args;
	struct session				*s;
	struct winlink				*wl;
	const struct options_table_entry	*table;
	struct options				*oo;
	int					 quiet;
d65 1
a65 1
		table = server_options_table;
d68 1
a68 1
		table = window_options_table;
d78 1
a78 1
		table = session_options_table;
d91 1
a91 1
		return (cmd_show_options_all(self, cmdq, table, oo));
d102 1
a102 1
	const struct options_table_entry	*table, *oe;
d121 2
a122 2
	table = oe = NULL;
	if (options_table_find(name, &table, &oe) != 0) {
d128 1
a128 1
		    return (CMD_RETURN_NORMAL);
d147 2
a148 2
cmd_show_options_all(struct cmd *self, struct cmd_q *cmdq,
    const struct options_table_entry *table, struct options *oo)
d153 1
d166 3
a168 2
	for (oe = table; oe->name != NULL; oe++) {
		if (oe->style != NULL)
d172 2
a173 3
		optval = options_table_print_entry(oe, o,
		    args_has(self->args, 'v'));
		if (args_has(self->args, 'v'))
@


1.23
log
@Instead of setting up the default keys by building the key struct
directly with a helper function in the cmd_entry, include a table of
bind-key commands and pass them through the command parser and a
temporary cmd_q.

As well as being smaller, this will allow default bindings to be command
sequences which will probably be needed soon.
@
text
@d1 1
a1 1
/* $OpenBSD: cmd-show-options.c,v 1.22 2014/04/17 07:43:20 nicm Exp $ */
d64 1
a64 1
		oo = &global_options;
d70 1
a70 1
			oo = &global_w_options;
d75 1
a75 1
			oo = &wl->window->options;
d80 1
a80 1
			oo = &global_s_options;
d85 1
a85 1
			oo = &s->options;
d154 2
a155 1
	RB_FOREACH(o, options_tree, &oo->tree) {
d162 1
@


1.22
log
@Do not show the -fg, -bg and -attr options. If asked for one explicitly,
show the equivalent -style option instead.
@
text
@d1 1
a1 1
/* $OpenBSD: cmd-show-options.c,v 1.21 2013/10/10 12:00:23 nicm Exp $ */
a41 1
	NULL,
a49 1
	NULL,
@


1.21
log
@Remove the barely-used and unnecessary command check() function.
@
text
@d1 1
a1 1
/* $OpenBSD: cmd-show-options.c,v 1.20 2013/03/25 10:04:04 nicm Exp $ */
d103 1
d108 3
a110 2
	if (*args->argv[0] == '@@') {
		if ((o = options_find1(oo, args->argv[0])) == NULL) {
d113 1
a113 1
			cmdq_error(cmdq, "unknown option: %s", args->argv[0]);
d124 2
a125 2
	if (options_table_find(args->argv[0], &table, &oe) != 0) {
		cmdq_error(cmdq, "ambiguous option: %s", args->argv[0]);
d131 1
a131 1
		cmdq_error(cmdq, "unknown option: %s", args->argv[0]);
d134 4
d166 2
@


1.20
log
@Add -q flags to shut up errors to capture-pane and show-options, from
George Nachman.
@
text
@d1 1
a1 1
/* $OpenBSD: cmd-show-options.c,v 1.19 2013/03/24 09:54:10 nicm Exp $ */
a42 1
	NULL,
a50 1
	NULL,
@


1.19
log
@Add a command queue to standardize and simplify commands that call other
commands and allow a command to block execution of subsequent
commands. This allows run-shell and if-shell to be synchronous which has
been much requested.

Each client has a default command queue and commands are consumed one at
a time from it. A command may suspend execution from the queue by
returning CMD_RETURN_WAIT and then resume it by calling cmd_continue() -
for example run-shell does this from the callback that is fired after
the job is freed.

When the command queue becomes empty, command clients are automatically
exited (unless attaching). A callback is also fired - this is used for
nested commands in, for example, if-shell which can block execution of
the client's cmdq until a new cmdq becomes empty.

Also merge all the old error/info/print functions together and lose the
old curclient/cmdclient distinction - a cmdq is bound to one client (or
none if in the configuration file), this is a command client if
c->session is NULL otherwise an attached client.
@
text
@d1 1
a1 1
/* $OpenBSD: cmd-show-options.c,v 1.18 2013/03/21 16:17:01 nicm Exp $ */
d33 1
a33 1
		    struct options *);
d39 2
a40 2
	"gst:vw", 0, 1,
	"[-gsvw] [-t target-session|target-window] [option]",
d65 1
d93 3
a95 2
	if (args->argc != 0)
		return (cmd_show_options_one(self, cmdq, oo));
d97 1
a97 1
		return (cmd_show_options_all(self, cmdq, table, oo));
d102 1
a102 1
    struct options *oo)
d111 2
d129 2
@


1.18
log
@Add user options, prefixed with @@. May be set to any arbitrary string.
@
text
@d1 1
a1 1
/* $OpenBSD: cmd-show-options.c,v 1.17 2013/03/21 16:15:52 nicm Exp $ */
d30 1
a30 1
enum cmd_retval	 cmd_show_options_exec(struct cmd *, struct cmd_ctx *);
d32 1
a32 1
enum cmd_retval	cmd_show_options_one(struct cmd *, struct cmd_ctx *,
d34 1
a34 1
enum cmd_retval cmd_show_options_all(struct cmd *, struct cmd_ctx *,
d58 1
a58 1
cmd_show_options_exec(struct cmd *self, struct cmd_ctx *ctx)
d75 1
a75 1
			wl = cmd_find_window(ctx, args_get(args, 't'), NULL);
d85 1
a85 1
			s = cmd_find_session(ctx, args_get(args, 't'), 0);
d93 1
a93 1
		return (cmd_show_options_one(self, ctx, oo));
d95 1
a95 1
		return (cmd_show_options_all(self, ctx, table, oo));
d99 1
a99 1
cmd_show_options_one(struct cmd *self, struct cmd_ctx *ctx,
d109 1
a109 1
			ctx->error(ctx, "unknown option: %s", args->argv[0]);
d113 1
a113 1
			ctx->print(ctx, "%s", o->str);
d115 1
a115 1
			ctx->print(ctx, "%s \"%s\"", o->name, o->str);
d121 1
a121 1
		ctx->error(ctx, "ambiguous option: %s", args->argv[0]);
d125 1
a125 1
		ctx->error(ctx, "unknown option: %s", args->argv[0]);
d132 1
a132 1
		ctx->print(ctx, "%s", optval);
d134 1
a134 1
		ctx->print(ctx, "%s %s", oe->name, optval);
d139 1
a139 1
cmd_show_options_all(struct cmd *self, struct cmd_ctx *ctx,
d149 1
a149 1
				ctx->print(ctx, "%s", o->str);
d151 1
a151 1
				ctx->print(ctx, "%s \"%s\"", o->name, o->str);
d161 1
a161 1
			ctx->print(ctx, "%s", optval);
d163 1
a163 1
			ctx->print(ctx, "%s %s", oe->name, optval);
@


1.17
log
@Add -v to set and setw to show only option value.
@
text
@d1 1
a1 1
/* $OpenBSD: cmd-show-options.c,v 1.16 2012/07/11 07:10:15 nicm Exp $ */
d32 5
a60 1
	const struct options_table_entry	*table, *oe;
d63 1
a64 2
	struct options_entry			*o;
	const char				*optval;
d92 18
a109 4
	if (args->argc != 0) {
		table = oe = NULL;
		if (options_table_find(args->argv[0], &table, &oe) != 0) {
			ctx->error(ctx, "ambiguous option: %s", args->argv[0]);
d112 40
a151 3
		if (oe == NULL) {
			ctx->error(ctx, "unknown option: %s", args->argv[0]);
			return (CMD_RETURN_ERROR);
d153 3
d157 1
a157 1
			return (CMD_RETURN_NORMAL);
a163 11
	} else {
		for (oe = table; oe->name != NULL; oe++) {
			if ((o = options_find1(oo, oe->name)) == NULL)
				continue;
			optval = options_table_print_entry(oe, o,
			    args_has(self->args, 'v'));
			if (args_has(self->args, 'v'))
				ctx->print(ctx, "%s", optval);
			else
				ctx->print(ctx, "%s %s", oe->name, optval);
		}
@


1.16
log
@Make command exec functions return an enum rather than -1/0/1 values and
add a new value to mean "leave client running but don't attach" to fix
problems with using some commands in a command sequence. Most of the
work by Thomas Adam, problem reported by "jspenguin" on SF bug 3535531.
@
text
@d1 1
a1 1
/* $OpenBSD: cmd-show-options.c,v 1.15 2012/02/25 12:57:42 nicm Exp $ */
d34 2
a35 2
	"gst:w", 0, 1,
	"[-gsw] [-t target-session|target-window] [option]",
d44 2
a45 2
	"gt:", 0, 1,
	"[-g] " CMD_TARGET_WINDOW_USAGE " [option]",
d101 6
a106 2
		optval = options_table_print_entry(oe, o);
		ctx->print(ctx, "%s %s", oe->name, optval);
d111 6
a116 2
			optval = options_table_print_entry(oe, o);
			ctx->print(ctx, "%s %s", oe->name, optval);
@


1.15
log
@Allow a single option to be specified to show-options to show just that
option.
@
text
@d1 1
a1 1
/* $OpenBSD: cmd-show-options.c,v 1.14 2011/04/05 19:37:01 nicm Exp $ */
d30 1
a30 1
int	cmd_show_options_exec(struct cmd *, struct cmd_ctx *);
d52 1
a52 1
int
d74 1
a74 1
				return (-1);
d84 1
a84 1
				return (-1);
d93 1
a93 1
			return (-1);
d97 1
a97 1
			return (-1);
d100 1
a100 1
			return (0);
d112 1
a112 1
	return (0);
@


1.14
log
@Add a flag to cmd_find_session so that attach-session can prefer
unattached sessions when choosing the most recently used (if -t is not
given). Suggested by claudio@@.
@
text
@d1 1
a1 1
/* $OpenBSD: cmd-show-options.c,v 1.13 2011/01/04 02:03:41 nicm Exp $ */
d34 2
a35 2
	"gst:w", 0, 0,
	"[-gsw] [-t target-session|target-window]",
d44 2
a45 2
	"gt:", 0, 0,
	"[-g] " CMD_TARGET_WINDOW_USAGE,
d89 10
a98 1
	for (oe = table; oe->name != NULL; oe++) {
d100 1
a100 1
			continue;
d103 7
@


1.13
log
@Now that parsing is common, merge some of the small, related commands
together to use the same code.

Also add some arguments (such as -n and -p) to some commands to match
existing commands.
@
text
@d1 1
a1 1
/* $OpenBSD: cmd-show-options.c,v 1.12 2011/01/04 00:42:47 nicm Exp $ */
d82 1
a82 1
			s = cmd_find_session(ctx, args_get(args, 't'));
@


1.12
log
@Clean up and simplify tmux command argument parsing.

Originally, tmux commands were parsed in the client process into a
struct with the command data which was then serialised and sent to the
server to be executed. The parsing was later moved into the server (an
argv was sent from the client), but the parse step and intermediate
struct was kept.

This change removes that struct and the separate parse step. Argument
parsing and printing is now common to all commands (in arguments.c) with
each command left with just an optional check function (to validate the
arguments at parse time), the exec function and a function to set up any
key bindings (renamed from the old init function).

This is overall more simple and consistent.

There should be no changes to any commands behaviour or syntax although
as this touches every command please watch for any unexpected changes.
@
text
@d1 1
a1 1
/* $OpenBSD: cmd-show-options.c,v 1.11 2011/01/01 16:51:21 nicm Exp $ */
d42 10
d66 2
a67 1
	} else if (args_has(self->args, 'w')) {
@


1.11
log
@Move the user-visible parts of all options (names, types, limit, default
values) together into one set of tables in options-table.c. Also clean
up and simplify cmd-set-options.c and move a common print function into
option-table.c.
@
text
@d1 1
a1 1
/* $OpenBSD: cmd-show-options.c,v 1.10 2009/12/10 09:16:52 nicm Exp $ */
d34 1
d36 4
a39 6
	0, "gsw",
	cmd_target_init,
	cmd_target_parse,
	cmd_show_options_exec,
	cmd_target_free,
	cmd_target_print
d45 1
a45 1
	struct cmd_target_data			*data = self->data;
d53 1
a53 1
	if (cmd_check_flag(data->chflags, 's')) {
d56 1
a56 1
	} else if (cmd_check_flag(data->chflags, 'w')) {
d58 1
a58 1
		if (cmd_check_flag(data->chflags, 'g'))
d61 1
a61 1
			wl = cmd_find_window(ctx, data->target, NULL);
d68 1
a68 1
		if (cmd_check_flag(data->chflags, 'g'))
d71 1
a71 1
			s = cmd_find_session(ctx, data->target);
@


1.10
log
@Add "server options" which are server-wide and not bound to a session or
window. Set and displayed with "set -s" and "show -s".

Currently the only option is "quiet" (like command-line -q, allowing it to be
set from .tmux.conf), but others will come along.
@
text
@d1 1
a1 1
/* $OpenBSD: cmd-show-options.c,v 1.9 2009/12/03 22:50:10 nicm Exp $ */
d46 7
a52 8
	struct cmd_target_data		*data = self->data;
	const struct set_option_entry	*table;
	struct session			*s;
	struct winlink			*wl;
	struct options			*oo;
	struct options_entry		*o;
	const struct set_option_entry   *entry;
	const char			*optval;
d56 1
a56 1
		table = set_option_table;
d58 1
a58 1
		table = set_window_option_table;
d68 1
a68 1
		table = set_session_option_table;
d79 2
a80 2
	for (entry = table; entry->name != NULL; entry++) {
		if ((o = options_find1(oo, entry->name)) == NULL)
d82 2
a83 2
		optval = cmd_set_option_print(entry, o);
		ctx->print(ctx, "%s %s", entry->name, optval);
@


1.9
log
@Massive spaces->tabs and trailing whitespace cleanup, hopefully for the last
time now I've configured emacs to make them displayed in really annoying
colours...
@
text
@d1 1
a1 1
/* $OpenBSD: cmd-show-options.c,v 1.8 2009/12/03 17:44:02 nicm Exp $ */
d34 2
a35 2
	"[-gw] [-t target-session|target-window]",
	0, "gw",
d55 4
a58 1
	if (cmd_check_flag(data->chflags, 'w')) {
@


1.8
log
@Eliminate duplicate code and ease the passage for server-wide options by adding
a -w flag to set-option and show-options and making setw and showw aliases to
set -w and show -w.

Note: setw and showw are still there, but now aliases for set -w and show -w.
@
text
@d1 1
a1 1
/* $OpenBSD: cmd-show-options.c,v 1.7 2009/11/13 19:53:29 nicm Exp $ */
d46 1
a46 1
	struct cmd_target_data		*data = self->data;	
@


1.7
log
@Get rid of the ugly CMD_CHFLAG macro and use a const string (eg "dDU") in the
command entry structs and a couple of functions to check/set the flags.
@
text
@d1 1
a1 1
/* $OpenBSD: cmd-show-options.c,v 1.6 2009/09/21 14:46:47 nicm Exp $ */
d34 2
a35 2
	"[-g] " CMD_TARGET_SESSION_USAGE,
	0, "g",
d46 2
a47 1
	struct cmd_target_data		*data = self->data;
d49 1
d55 20
a74 6
	if (cmd_check_flag(data->chflags, 'g'))
		oo = &global_s_options;
	else {
		if ((s = cmd_find_session(ctx, data->target)) == NULL)
			return (-1);
		oo = &s->options;
d77 1
a77 1
	for (entry = set_option_table; entry->name != NULL; entry++) {
d80 1
a80 1
		optval = set_option_print(entry, o);
@


1.6
log
@Move common code from show-options and show-window-options into a function.
@
text
@d1 1
a1 1
/* $OpenBSD: cmd-show-options.c,v 1.5 2009/07/26 12:58:44 nicm Exp $ */
d35 1
a35 1
	0, CMD_CHFLAG('g'),
d53 1
a53 1
	if (data->chflags & CMD_CHFLAG('g'))
@


1.5
log
@Make all messages sent between the client and server fixed size.

This is the first of two changes to make the protocol more resilient and less
sensitive to other changes in the code, particularly with commands. The client
now packs argv into a buffer and sends it to the server for parsing, rather
than doing it itself and sending the parsed command data.

As a side-effect this also removes a lot of now-unused command marshalling
code.

Mixing a server without this change and a client with or vice versa will cause
tmux to hang or crash, please ensure that tmux is entirely killed before
upgrading.
@
text
@d1 1
a1 1
/* $OpenBSD: cmd-show-options.c,v 1.4 2009/07/15 07:50:34 nicm Exp $ */
d49 1
d51 1
a51 2
	char				*vs;
	long long			 vn;
d62 1
a62 1
		if (options_find1(oo, entry->name) == NULL)
d64 2
a65 38

		switch (entry->type) {
		case SET_OPTION_STRING:
			vs = options_get_string(oo, entry->name);
			ctx->print(ctx, "%s \"%s\"", entry->name, vs);
			break;
		case SET_OPTION_NUMBER:
			vn = options_get_number(oo, entry->name);
			ctx->print(ctx, "%s %lld", entry->name, vn);
			break;
		case SET_OPTION_KEY:
			vn = options_get_number(oo, entry->name);
 			ctx->print(ctx, "%s %s",
			    entry->name, key_string_lookup_key(vn));
			break;
		case SET_OPTION_COLOUR:
			vn = options_get_number(oo, entry->name);
 			ctx->print(ctx, "%s %s",
			    entry->name, colour_tostring(vn));
			break;
		case SET_OPTION_ATTRIBUTES:
			vn = options_get_number(oo, entry->name);
 			ctx->print(ctx, "%s %s",
			    entry->name, attributes_tostring(vn));
			break;
		case SET_OPTION_FLAG:
			vn = options_get_number(oo, entry->name);
			if (vn)
				ctx->print(ctx, "%s on", entry->name);
			else
				ctx->print(ctx, "%s off", entry->name);
			break;
		case SET_OPTION_CHOICE:
			vn = options_get_number(oo, entry->name);
			ctx->print(ctx, "%s %s",
			    entry->name, entry->choices[vn]);
			break;
		}
@


1.4
log
@Having to update NSETOPTION/NSETWINDOWOPTION when adding new options is a bit
annoying and it is only use for iterating, so use a sentinel to mark the end of
each array instead. Different fix for a problem pointed out by Kalle Olavi
Niemitalo.
@
text
@d1 1
a1 1
/* $OpenBSD: cmd-show-options.c,v 1.3 2009/07/13 23:11:35 nicm Exp $ */
a38 2
	cmd_target_send,
	cmd_target_recv,
@


1.3
log
@Having fixed flags for single-character getopt options is a bit hard to
maintain and is only going to get worse as more are used. So instead, add a new
uint64_t member to cmd_entry which is a bitmask of upper and lowercase options
accepted by the command.

This means new single character options can be used without the need to add it
explicitly to the list.
@
text
@d1 1
a1 1
/* $OpenBSD: cmd-show-options.c,v 1.2 2009/07/07 19:49:19 nicm Exp $ */
a51 1
	u_int				 i;
d63 1
a63 3
	for (i = 0; i < NSETOPTION; i++) {
		entry = &set_option_table[i];

@


1.2
log
@Rename the global options variables to be shorter and to make session options
clear. No functional change, getting this out of the way to make later options
changes easier.
@
text
@d1 1
a1 1
/* $OpenBSD: cmd-show-options.c,v 1.1 2009/06/01 22:58:49 nicm Exp $ */
d35 1
a35 1
	CMD_GFLAG,
d56 1
a56 1
	if (data->flags & CMD_GFLAG)
@


1.1
log
@Import tmux, a terminal multiplexor allowing (among other things) a single
terminal to be switched between several different windows and programs
displayed on one terminal be detached from one terminal and moved to another.

ok deraadt pirofti
@
text
@d1 1
a1 1
/* $OpenBSD$ */
d57 1
a57 1
		oo = &global_options;
@

