head	1.39;
access;
symbols
	OPENBSD_6_2:1.39.0.2
	OPENBSD_6_2_BASE:1.39
	OPENBSD_6_1:1.39.0.4
	OPENBSD_6_1_BASE:1.39
	OPENBSD_6_0:1.34.0.4
	OPENBSD_6_0_BASE:1.34
	OPENBSD_5_9:1.34.0.2
	OPENBSD_5_9_BASE:1.34
	OPENBSD_5_8:1.27.0.4
	OPENBSD_5_8_BASE:1.27
	OPENBSD_5_7:1.26.0.2
	OPENBSD_5_7_BASE:1.26
	OPENBSD_5_6:1.21.0.4
	OPENBSD_5_6_BASE:1.21
	OPENBSD_5_5:1.15.0.4
	OPENBSD_5_5_BASE:1.15
	OPENBSD_5_4:1.14.0.4
	OPENBSD_5_4_BASE:1.14
	OPENBSD_5_3:1.14.0.2
	OPENBSD_5_3_BASE:1.14
	OPENBSD_5_2:1.12.0.2
	OPENBSD_5_2_BASE:1.12
	OPENBSD_5_1_BASE:1.11
	OPENBSD_5_1:1.11.0.4
	OPENBSD_5_0:1.11.0.2
	OPENBSD_5_0_BASE:1.11
	OPENBSD_4_9:1.10.0.2
	OPENBSD_4_9_BASE:1.10
	OPENBSD_4_8:1.9.0.2
	OPENBSD_4_8_BASE:1.9
	OPENBSD_4_7:1.8.0.2
	OPENBSD_4_7_BASE:1.8
	OPENBSD_4_6:1.2.0.4
	OPENBSD_4_6_BASE:1.2;
locks; strict;
comment	@ * @;


1.39
date	2017.01.24.13.28.33;	author nicm;	state Exp;
branches;
next	1.38;
commitid	o4bx7OSWGDmXTMl6;

1.38
date	2016.10.12.09.07.58;	author nicm;	state Exp;
branches;
next	1.37;
commitid	cT7Nken6nHGGrKeY;

1.37
date	2016.10.11.13.45.47;	author nicm;	state Exp;
branches;
next	1.36;
commitid	m8cwMB6WuKLMPXh5;

1.36
date	2016.10.10.13.54.47;	author nicm;	state Exp;
branches;
next	1.35;
commitid	OFXFRx5WnTtCw3R9;

1.35
date	2016.10.05.12.34.05;	author nicm;	state Exp;
branches;
next	1.34;
commitid	ngPu4hsxEkYwKqTw;

1.34
date	2016.01.19.15.59.12;	author nicm;	state Exp;
branches;
next	1.33;
commitid	P3qmSOx6KrDBsb0c;

1.33
date	2015.11.12.11.09.11;	author nicm;	state Exp;
branches;
next	1.32;
commitid	tEN3cHiOuN3KscbT;

1.32
date	2015.10.27.15.58.42;	author nicm;	state Exp;
branches;
next	1.31;
commitid	89xhQafU35Q5MQVC;

1.31
date	2015.09.14.13.22.02;	author nicm;	state Exp;
branches;
next	1.30;
commitid	kxByHmNsW2wTQbKK;

1.30
date	2015.09.11.14.41.50;	author nicm;	state Exp;
branches;
next	1.29;
commitid	ufD4awhmzmSoxn7X;

1.29
date	2015.08.29.09.36.46;	author nicm;	state Exp;
branches;
next	1.28;
commitid	iO5QEcohpHfgM5Iz;

1.28
date	2015.08.29.09.25.00;	author nicm;	state Exp;
branches;
next	1.27;
commitid	UXoQGD7QOZAJI1XC;

1.27
date	2015.04.07.13.06.22;	author nicm;	state Exp;
branches;
next	1.26;
commitid	BpPQWRQcQST72kb8;

1.26
date	2014.11.05.23.25.02;	author nicm;	state Exp;
branches;
next	1.25;
commitid	HCpksV7mGIomCoEW;

1.25
date	2014.10.08.17.35.58;	author nicm;	state Exp;
branches;
next	1.24;
commitid	mK8z9uVwDZMfiNoM;

1.24
date	2014.10.08.17.14.04;	author nicm;	state Exp;
branches;
next	1.23;
commitid	ulvK817LKj1J8ttJ;

1.23
date	2014.09.01.21.50.18;	author nicm;	state Exp;
branches;
next	1.22;
commitid	yvK8NJvd2XzXhKku;

1.22
date	2014.08.25.13.13.19;	author nicm;	state Exp;
branches;
next	1.21;
commitid	h7PfnqG3LcqpC7uk;

1.21
date	2014.06.20.11.00.19;	author nicm;	state Exp;
branches;
next	1.20;
commitid	RnDDFYCU0WddWpFJ;

1.20
date	2014.05.13.22.54.18;	author nicm;	state Exp;
branches;
next	1.19;

1.19
date	2014.05.13.07.34.35;	author nicm;	state Exp;
branches;
next	1.18;

1.18
date	2014.04.24.09.14.43;	author nicm;	state Exp;
branches;
next	1.17;

1.17
date	2014.04.02.18.12.18;	author nicm;	state Exp;
branches;
next	1.16;

1.16
date	2014.03.31.21.39.31;	author nicm;	state Exp;
branches;
next	1.15;

1.15
date	2014.02.17.23.07.03;	author nicm;	state Exp;
branches;
next	1.14;

1.14
date	2012.11.27.20.22.12;	author nicm;	state Exp;
branches;
next	1.13;

1.13
date	2012.09.04.13.24.50;	author nicm;	state Exp;
branches;
next	1.12;

1.12
date	2012.07.10.11.53.01;	author nicm;	state Exp;
branches;
next	1.11;

1.11
date	2011.03.28.19.44.31;	author nicm;	state Exp;
branches;
next	1.10;

1.10
date	2010.12.30.23.16.18;	author nicm;	state Exp;
branches;
next	1.9;

1.9
date	2010.06.21.21.44.09;	author nicm;	state Exp;
branches;
next	1.8;

1.8
date	2009.12.03.22.50.10;	author nicm;	state Exp;
branches;
next	1.7;

1.7
date	2009.11.26.22.28.24;	author nicm;	state Exp;
branches;
next	1.6;

1.6
date	2009.11.03.17.17.24;	author nicm;	state Exp;
branches;
next	1.5;

1.5
date	2009.09.20.14.58.12;	author nicm;	state Exp;
branches;
next	1.4;

1.4
date	2009.09.07.18.50.45;	author nicm;	state Exp;
branches;
next	1.3;

1.3
date	2009.07.30.20.50.54;	author nicm;	state Exp;
branches;
next	1.2;

1.2
date	2009.07.02.16.15.43;	author nicm;	state Exp;
branches;
next	1.1;

1.1
date	2009.06.01.22.58.49;	author nicm;	state Exp;
branches;
next	;


desc
@@


1.39
log
@Shorten a long line, and don't leak buffer in paste_add if size is zero.
@
text
@/* $OpenBSD: paste.c,v 1.38 2016/10/12 09:07:58 nicm Exp $ */

/*
 * Copyright (c) 2007 Nicholas Marriott <nicholas.marriott@@gmail.com>
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF MIND, USE, DATA OR PROFITS, WHETHER
 * IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING
 * OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */

#include <sys/types.h>

#include <stdlib.h>
#include <string.h>
#include <time.h>
#include <vis.h>

#include "tmux.h"

/*
 * Set of paste buffers. Note that paste buffer data is not necessarily a C
 * string!
 */

struct paste_buffer {
	char		*data;
	size_t		 size;

	char		*name;
	time_t		 created;
	int		 automatic;
	u_int		 order;

	RB_ENTRY(paste_buffer) name_entry;
	RB_ENTRY(paste_buffer) time_entry;
};

static u_int	paste_next_index;
static u_int	paste_next_order;
static u_int	paste_num_automatic;
static RB_HEAD(paste_name_tree, paste_buffer) paste_by_name;
static RB_HEAD(paste_time_tree, paste_buffer) paste_by_time;

static int	paste_cmp_names(const struct paste_buffer *,
		    const struct paste_buffer *);
RB_GENERATE_STATIC(paste_name_tree, paste_buffer, name_entry, paste_cmp_names);

static int	paste_cmp_times(const struct paste_buffer *,
		    const struct paste_buffer *);
RB_GENERATE_STATIC(paste_time_tree, paste_buffer, time_entry, paste_cmp_times);

static int
paste_cmp_names(const struct paste_buffer *a, const struct paste_buffer *b)
{
	return (strcmp(a->name, b->name));
}

static int
paste_cmp_times(const struct paste_buffer *a, const struct paste_buffer *b)
{
	if (a->order > b->order)
		return (-1);
	if (a->order < b->order)
		return (1);
	return (0);
}

/* Get paste buffer name. */
const char *
paste_buffer_name(struct paste_buffer *pb)
{
	return (pb->name);
}

/* Get paste buffer order. */
u_int
paste_buffer_order(struct paste_buffer *pb)
{
	return (pb->order);
}

/* Get paste buffer created. */
time_t
paste_buffer_created(struct paste_buffer *pb)
{
	return (pb->created);
}

/* Get paste buffer data. */
const char *
paste_buffer_data(struct paste_buffer *pb, size_t *size)
{
	if (size != NULL)
		*size = pb->size;
	return (pb->data);
}

/* Walk paste buffers by time. */
struct paste_buffer *
paste_walk(struct paste_buffer *pb)
{
	if (pb == NULL)
		return (RB_MIN(paste_time_tree, &paste_by_time));
	return (RB_NEXT(paste_time_tree, &paste_by_time, pb));
}

/* Get the most recent automatic buffer. */
struct paste_buffer *
paste_get_top(const char **name)
{
	struct paste_buffer	*pb;

	pb = RB_MIN(paste_time_tree, &paste_by_time);
	if (pb == NULL)
		return (NULL);
	if (name != NULL)
		*name = pb->name;
	return (pb);
}

/* Get a paste buffer by name. */
struct paste_buffer *
paste_get_name(const char *name)
{
	struct paste_buffer	pbfind;

	if (name == NULL || *name == '\0')
		return (NULL);

	pbfind.name = (char *)name;
	return (RB_FIND(paste_name_tree, &paste_by_name, &pbfind));
}

/* Free a paste buffer. */
void
paste_free(struct paste_buffer *pb)
{
	RB_REMOVE(paste_name_tree, &paste_by_name, pb);
	RB_REMOVE(paste_time_tree, &paste_by_time, pb);
	if (pb->automatic)
		paste_num_automatic--;

	free(pb->data);
	free(pb->name);
	free(pb);
}

/*
 * Add an automatic buffer, freeing the oldest automatic item if at limit. Note
 * that the caller is responsible for allocating data.
 */
void
paste_add(char *data, size_t size)
{
	struct paste_buffer	*pb, *pb1;
	u_int			 limit;

	if (size == 0) {
		free(data);
		return;
	}

	limit = options_get_number(global_options, "buffer-limit");
	RB_FOREACH_REVERSE_SAFE(pb, paste_time_tree, &paste_by_time, pb1) {
		if (paste_num_automatic < limit)
			break;
		if (pb->automatic)
			paste_free(pb);
	}

	pb = xmalloc(sizeof *pb);

	pb->name = NULL;
	do {
		free(pb->name);
		xasprintf(&pb->name, "buffer%04u", paste_next_index);
		paste_next_index++;
	} while (paste_get_name(pb->name) != NULL);

	pb->data = data;
	pb->size = size;

	pb->automatic = 1;
	paste_num_automatic++;

	pb->created = time(NULL);

	pb->order = paste_next_order++;
	RB_INSERT(paste_name_tree, &paste_by_name, pb);
	RB_INSERT(paste_time_tree, &paste_by_time, pb);
}

/* Rename a paste buffer. */
int
paste_rename(const char *oldname, const char *newname, char **cause)
{
	struct paste_buffer	*pb, *pb_new;

	if (cause != NULL)
		*cause = NULL;

	if (oldname == NULL || *oldname == '\0') {
		if (cause != NULL)
			*cause = xstrdup("no buffer");
		return (-1);
	}
	if (newname == NULL || *newname == '\0') {
		if (cause != NULL)
			*cause = xstrdup("new name is empty");
		return (-1);
	}

	pb = paste_get_name(oldname);
	if (pb == NULL) {
		if (cause != NULL)
			xasprintf(cause, "no buffer %s", oldname);
		return (-1);
	}

	pb_new = paste_get_name(newname);
	if (pb_new != NULL) {
		if (cause != NULL)
			xasprintf(cause, "buffer %s already exists", newname);
		return (-1);
	}

	RB_REMOVE(paste_name_tree, &paste_by_name, pb);

	free(pb->name);
	pb->name = xstrdup(newname);

	if (pb->automatic)
		paste_num_automatic--;
	pb->automatic = 0;

	RB_INSERT(paste_name_tree, &paste_by_name, pb);

	return (0);
}

/*
 * Add or replace an item in the store. Note that the caller is responsible for
 * allocating data.
 */
int
paste_set(char *data, size_t size, const char *name, char **cause)
{
	struct paste_buffer	*pb, *old;

	if (cause != NULL)
		*cause = NULL;

	if (size == 0) {
		free(data);
		return (0);
	}
	if (name == NULL) {
		paste_add(data, size);
		return (0);
	}

	if (*name == '\0') {
		if (cause != NULL)
			*cause = xstrdup("empty buffer name");
		return (-1);
	}

	pb = xmalloc(sizeof *pb);

	pb->name = xstrdup(name);

	pb->data = data;
	pb->size = size;

	pb->automatic = 0;
	pb->order = paste_next_order++;

	pb->created = time(NULL);

	if ((old = paste_get_name(name)) != NULL)
		paste_free(old);

	RB_INSERT(paste_name_tree, &paste_by_name, pb);
	RB_INSERT(paste_time_tree, &paste_by_time, pb);

	return (0);
}

/* Convert start of buffer into a nice string. */
char *
paste_make_sample(struct paste_buffer *pb)
{
	char		*buf;
	size_t		 len, used;
	const int	 flags = VIS_OCTAL|VIS_TAB|VIS_NL;
	const size_t	 width = 200;

	len = pb->size;
	if (len > width)
		len = width;
	buf = xreallocarray(NULL, len, 4 + 4);

	used = utf8_strvis(buf, pb->data, len, flags);
	if (pb->size > width || used > width)
		strlcpy(buf + width, "...", 4);
	return (buf);
}
@


1.38
log
@Unused variable and missing time.h.
@
text
@d1 1
a1 1
/* $OpenBSD: paste.c,v 1.37 2016/10/11 13:45:47 nicm Exp $ */
d166 2
a167 1
	if (size == 0)
d169 1
@


1.37
log
@Some other stuff that can be local to one file.
@
text
@d1 1
a1 1
/* $OpenBSD: paste.c,v 1.36 2016/10/10 13:54:47 nicm Exp $ */
a19 1
#include <sys/time.h>
d23 1
@


1.36
log
@Some more static.
@
text
@d1 1
a1 1
/* $OpenBSD: paste.c,v 1.35 2016/10/05 12:34:05 nicm Exp $ */
d49 2
a50 2
RB_HEAD(paste_name_tree, paste_buffer) paste_by_name;
RB_HEAD(paste_time_tree, paste_buffer) paste_by_time;
@


1.35
log
@Keep buffer creation time and add accessors for it and the order number.
@
text
@d1 1
a1 1
/* $OpenBSD: paste.c,v 1.34 2016/01/19 15:59:12 nicm Exp $ */
d46 3
a48 3
u_int	paste_next_index;
u_int	paste_next_order;
u_int	paste_num_automatic;
d52 7
a58 7
int paste_cmp_names(const struct paste_buffer *, const struct paste_buffer *);
RB_PROTOTYPE(paste_name_tree, paste_buffer, name_entry, paste_cmp_names);
RB_GENERATE(paste_name_tree, paste_buffer, name_entry, paste_cmp_names);

int paste_cmp_times(const struct paste_buffer *, const struct paste_buffer *);
RB_PROTOTYPE(paste_time_tree, paste_buffer, time_entry, paste_cmp_times);
RB_GENERATE(paste_time_tree, paste_buffer, time_entry, paste_cmp_times);
d60 1
a60 1
int
d66 1
a66 1
int
@


1.34
log
@I no longer use my SourceForge address so replace it.
@
text
@d1 1
a1 1
/* $OpenBSD: paste.c,v 1.33 2015/11/12 11:09:11 nicm Exp $ */
d38 1
d83 14
d106 1
a106 1
/* Walk paste buffers by name. */
d192 2
d283 2
@


1.33
log
@Nuke the utf8 and status-utf8 options and make tmux only a UTF-8
terminal. We still support non-UTF-8 terminals outside tmux, but inside
it is always UTF-8 (as when the utf8 and status-utf8 options were on).
@
text
@d1 1
a1 1
/* $OpenBSD: paste.c,v 1.32 2015/10/27 15:58:42 nicm Exp $ */
d4 1
a4 1
 * Copyright (c) 2007 Nicholas Marriott <nicm@@users.sourceforge.net>
@


1.32
log
@Move struct options into options.c.
@
text
@d1 1
a1 1
/* $OpenBSD: paste.c,v 1.31 2015/09/14 13:22:02 nicm Exp $ */
d278 1
a278 1
paste_make_sample(struct paste_buffer *pb, int utf8flag)
d290 1
a290 4
	if (utf8flag)
		used = utf8_strvis(buf, pb->data, len, flags);
	else
		used = strvisx(buf, pb->data, len, flags);
@


1.31
log
@Remove some extra blank lines.
@
text
@d1 1
a1 1
/* $OpenBSD: paste.c,v 1.30 2015/09/11 14:41:50 nicm Exp $ */
d154 1
a154 1
	limit = options_get_number(&global_options, "buffer-limit");
@


1.30
log
@Merge delete-buffer into cmd-set-buffer.c and change the paste buffer
API so it has one paste_free() rather than free_top and free_name
(everywhere that uses it already has the right pointer).
@
text
@d1 1
a1 1
/* $OpenBSD: paste.c,v 1.29 2015/08/29 09:36:46 nicm Exp $ */
a255 1

@


1.29
log
@paste_send_pane can be merged into cmd-paste-buffer.c now.
@
text
@d1 1
a1 1
/* $OpenBSD: paste.c,v 1.28 2015/08/29 09:25:00 nicm Exp $ */
a113 12
/* Free the most recent buffer. */
int
paste_free_top(void)
{
	struct paste_buffer	*pb;

	pb = paste_get_top(NULL);
	if (pb == NULL)
		return (-1);
	return (paste_free_name(pb->name));
}

d127 3
a129 3
/* Free a paste buffer by name. */
int
paste_free_name(const char *name)
a130 10
	struct paste_buffer	*pb, pbfind;

	if (name == NULL || *name == '\0')
		return (-1);

	pbfind.name = (char *)name;
	pb = RB_FIND(paste_name_tree, &paste_by_name, &pbfind);
	if (pb == NULL)
		return (-1);

a138 1
	return (0);
d159 1
a159 1
			paste_free_name(pb->name);
d237 1
a237 1
	struct paste_buffer	*pb;
d268 2
a269 2
	if (paste_get_name(name) != NULL)
		paste_free_name(name);
@


1.28
log
@Move struct paste_buffer out of tmux.h.
@
text
@d1 1
a1 1
/* $OpenBSD: paste.c,v 1.27 2015/04/07 13:06:22 nicm Exp $ */
a320 29
}

/* Paste into a window pane, filtering '\n' according to separator. */
void
paste_send_pane(struct paste_buffer *pb, struct window_pane *wp,
    const char *sep, int bracket)
{
	const char	*data = pb->data, *end = data + pb->size, *lf;
	size_t		 seplen;

	if (wp->flags & PANE_INPUTOFF)
		return;

	if (bracket && (wp->screen->mode & MODE_BRACKETPASTE))
		bufferevent_write(wp->event, "\033[200~", 6);

	seplen = strlen(sep);
	while ((lf = memchr(data, '\n', end - data)) != NULL) {
		if (lf != data)
			bufferevent_write(wp->event, data, lf - data);
		bufferevent_write(wp->event, sep, seplen);
		data = lf + 1;
	}

	if (end != data)
		bufferevent_write(wp->event, data, end - data);

	if (bracket && (wp->screen->mode & MODE_BRACKETPASTE))
		bufferevent_write(wp->event, "\033[201~", 6);
@


1.27
log
@When replacing, don't free the old paste until after the new one's name
has been copied. Fixes a use-after-free in window-copy.c. Bug reported
by J Raynor (who also provided a different fix).
@
text
@d1 1
a1 1
/* $OpenBSD: paste.c,v 1.26 2014/11/05 23:25:02 nicm Exp $ */
d33 12
d75 16
d102 1
a102 1
paste_get_top(void)
d109 2
d120 1
a120 1
	pb = paste_get_top();
@


1.26
log
@Tidy up mode-mouse check.
@
text
@d1 1
a1 1
/* $OpenBSD: paste.c,v 1.25 2014/10/08 17:35:58 nicm Exp $ */
a249 3
	pb = paste_get_name(name);
	if (pb != NULL)
		paste_free_name(name);
d260 3
@


1.25
log
@Add xreallocarray and remove nmemb argument from xrealloc.
@
text
@d1 1
a1 1
/* $OpenBSD: paste.c,v 1.24 2014/10/08 17:14:04 nicm Exp $ */
d304 1
a304 1
	if (bracket)
d318 1
a318 1
	if (bracket)
@


1.24
log
@Use xrealloc(NULL, n, m) instead of xmalloc(n * m) to get overflow
check.
@
text
@d1 1
a1 1
/* $OpenBSD: paste.c,v 1.23 2014/09/01 21:50:18 nicm Exp $ */
d282 1
a282 1
	buf = xrealloc(NULL, len, 4 + 4);
@


1.23
log
@Various minor style and spacing nits.
@
text
@d1 1
a1 1
/* $OpenBSD: paste.c,v 1.22 2014/08/25 13:13:19 nicm Exp $ */
d282 1
a282 1
	buf = xmalloc(len * 4 + 4);
@


1.22
log
@Don't allow pasting into input-disabled panes, from Anish R Athalye.
@
text
@d1 1
a1 1
/* $OpenBSD: paste.c,v 1.21 2014/06/20 11:00:19 nicm Exp $ */
d105 1
a105 1
	pbfind.name = (char*)name;
d118 1
a118 1
	pbfind.name = (char*)name;
@


1.21
log
@Comment style nits.
@
text
@d1 1
a1 1
/* $OpenBSD: paste.c,v 1.20 2014/05/13 22:54:18 nicm Exp $ */
d300 3
@


1.20
log
@Don't allow multiple buffers with the same name, from Thomas Adam.
@
text
@d1 1
a1 1
/* $OpenBSD: paste.c,v 1.19 2014/05/13 07:34:35 nicm Exp $ */
d72 1
a72 1
/* Get the most recent automatic buffer */
d84 1
a84 1
/* Free the most recent buffer */
@


1.19
log
@Add support for named buffers. If you don't name a buffer, things work
much as before - buffers are automatically named "buffer0000",
"buffer0001" and so on and ordered as a stack. Buffers can be named
explicitly when creating ("loadb -b foo" etc) or renamed ("setb -b
buffer0000 -n foo"). If buffers are named explicitly, they are not
deleted when buffer-limit is reached. Diff from J Raynor.
@
text
@d1 1
a1 1
/* $OpenBSD: paste.c,v 1.18 2014/04/24 09:14:43 nicm Exp $ */
d179 1
a179 1
	struct paste_buffer	*pb;
d198 8
a205 1
		    xasprintf(cause, "no buffer %s", oldname);
@


1.18
log
@There is no longer a need for a paste_stack struct or for global_buffers
to be global. Move to paste.c.
@
text
@d1 1
a1 1
/* $OpenBSD: paste.c,v 1.17 2014/04/02 18:12:18 nicm Exp $ */
d29 1
a29 1
 * Stack of paste buffers. Note that paste buffer data is not necessarily a C
d33 13
a45 1
ARRAY_DECL(, struct paste_buffer *) paste_buffers =  ARRAY_INITIALIZER;
d47 2
a48 3
/* Return each item of the stack in turn. */
struct paste_buffer *
paste_walk_stack(u_int *idx)
d50 2
a51 1
	struct paste_buffer	*pb;
d53 8
a60 3
	pb = paste_get_index(*idx);
	(*idx)++;
	return (pb);
d63 1
a63 1
/* Get the top item on the stack. */
d65 1
a65 1
paste_get_top(void)
d67 3
a69 3
	if (ARRAY_LENGTH(&paste_buffers) == 0)
		return (NULL);
	return (ARRAY_FIRST(&paste_buffers));
d72 1
a72 1
/* Get an item by its index. */
d74 1
a74 1
paste_get_index(u_int idx)
d76 4
a79 1
	if (idx >= ARRAY_LENGTH(&paste_buffers))
d81 1
a81 1
	return (ARRAY_ITEM(&paste_buffers, idx));
d84 1
a84 1
/* Free the top item on the stack. */
d90 2
a91 1
	if (ARRAY_LENGTH(&paste_buffers) == 0)
d93 2
d96 5
a100 2
	pb = ARRAY_FIRST(&paste_buffers);
	ARRAY_REMOVE(&paste_buffers, 0);
d102 2
a103 2
	free(pb->data);
	free(pb);
d105 2
a106 1
	return (0);
d109 1
a109 1
/* Free an item by index. */
d111 1
a111 1
paste_free_index(u_int idx)
d113 4
a116 1
	struct paste_buffer	*pb;
d118 3
a120 1
	if (idx >= ARRAY_LENGTH(&paste_buffers))
d123 4
a126 2
	pb = ARRAY_ITEM(&paste_buffers, idx);
	ARRAY_REMOVE(&paste_buffers, idx);
d129 1
a130 1

d135 1
a135 1
 * Add an item onto the top of the stack, freeing the bottom if at limit. Note
d139 1
a139 1
paste_add(char *data, size_t size, u_int limit)
d141 2
a142 1
	struct paste_buffer	*pb;
d147 6
a152 5
	while (ARRAY_LENGTH(&paste_buffers) >= limit) {
		pb = ARRAY_LAST(&paste_buffers);
		free(pb->data);
		free(pb);
		ARRAY_TRUNC(&paste_buffers, 1);
d156 7
a162 1
	ARRAY_INSERT(&paste_buffers, 0, pb);
d166 7
d175 40
d217 1
a217 1
 * Replace an item on the stack. Note that the caller is responsible for
d221 1
a221 1
paste_replace(u_int idx, char *data, size_t size)
d225 3
d232 4
d237 3
a239 1
	if (idx >= ARRAY_LENGTH(&paste_buffers))
d241 7
d249 1
a249 2
	pb = ARRAY_ITEM(&paste_buffers, idx);
	free(pb->data);
d253 6
@


1.17
log
@Support UTF-8 with choose-buffer, from Kosuke ASAMI. Also make
buffer_sample bigger to let it trim at window right edge.
@
text
@d1 1
a1 1
/* $OpenBSD: paste.c,v 1.16 2014/03/31 21:39:31 nicm Exp $ */
d33 2
d37 1
a37 1
paste_walk_stack(struct paste_stack *ps, u_int *idx)
d41 1
a41 1
	pb = paste_get_index(ps, *idx);
d48 1
a48 1
paste_get_top(struct paste_stack *ps)
d50 1
a50 1
	if (ARRAY_LENGTH(ps) == 0)
d52 1
a52 1
	return (ARRAY_FIRST(ps));
d57 1
a57 1
paste_get_index(struct paste_stack *ps, u_int idx)
d59 1
a59 1
	if (idx >= ARRAY_LENGTH(ps))
d61 1
a61 1
	return (ARRAY_ITEM(ps, idx));
d66 1
a66 1
paste_free_top(struct paste_stack *ps)
d70 1
a70 1
	if (ARRAY_LENGTH(ps) == 0)
d73 2
a74 2
	pb = ARRAY_FIRST(ps);
	ARRAY_REMOVE(ps, 0);
d84 1
a84 1
paste_free_index(struct paste_stack *ps, u_int idx)
d88 1
a88 1
	if (idx >= ARRAY_LENGTH(ps))
d91 2
a92 2
	pb = ARRAY_ITEM(ps, idx);
	ARRAY_REMOVE(ps, idx);
d105 1
a105 1
paste_add(struct paste_stack *ps, char *data, size_t size, u_int limit)
d112 2
a113 2
	while (ARRAY_LENGTH(ps) >= limit) {
		pb = ARRAY_LAST(ps);
d116 1
a116 1
		ARRAY_TRUNC(ps, 1);
d120 1
a120 1
	ARRAY_INSERT(ps, 0, pb);
d132 1
a132 1
paste_replace(struct paste_stack *ps, u_int idx, char *data, size_t size)
d141 1
a141 1
	if (idx >= ARRAY_LENGTH(ps))
d144 1
a144 1
	pb = ARRAY_ITEM(ps, idx);
@


1.16
log
@Add setb -a to append and a copy mode append command, from J Raynor with
minor changes.
@
text
@d1 1
a1 1
/* $OpenBSD: paste.c,v 1.15 2014/02/17 23:07:03 nicm Exp $ */
d151 1
a151 1
/* Convert a buffer into a visible string. */
d153 1
a153 1
paste_print(struct paste_buffer *pb, size_t width)
d155 4
a158 6
	char	*buf;
	size_t	 len, used;

	if (width < 3)
		width = 3;
	buf = xmalloc(width * 4 + 1);
d163 1
d165 4
a168 1
	used = strvisx(buf, pb->data, len, VIS_OCTAL|VIS_TAB|VIS_NL);
d170 1
a170 2
		strlcpy(buf + width - 3, "...", 4);

@


1.15
log
@Fix memory leaks with paste_replace, based on changes from J Raynor.
@
text
@d1 1
a1 1
/* $OpenBSD: paste.c,v 1.14 2012/11/27 20:22:12 nicm Exp $ */
d175 1
a175 1
paste_send_pane (struct paste_buffer *pb, struct window_pane *wp,
@


1.14
log
@Support middle-click paste, based on a diff from Ailin Nemui.
@
text
@d1 1
a1 1
/* $OpenBSD: paste.c,v 1.13 2012/09/04 13:24:50 nicm Exp $ */
d134 2
a135 1
	if (size == 0)
d137 1
@


1.13
log
@Trivial code simplification from Tim Ruehsen.
@
text
@d1 1
a1 1
/* $OpenBSD: paste.c,v 1.12 2012/07/10 11:53:01 nicm Exp $ */
d169 26
@


1.12
log
@xfree is not particularly helpful, remove it. From Thomas Adam.
@
text
@d1 1
a1 1
/* $OpenBSD: paste.c,v 1.11 2011/03/28 19:44:31 nicm Exp $ */
d165 2
a166 4
	if (pb->size > width || used > width) {
		buf[width - 3] = '\0';
		strlcat(buf, "...", width);
	}
@


1.11
log
@Style: uint -> u_int and a missing else.
@
text
@d1 1
a1 1
/* $OpenBSD: paste.c,v 1.10 2010/12/30 23:16:18 nicm Exp $ */
d22 1
d74 2
a75 2
	xfree(pb->data);
	xfree(pb);
d92 2
a93 2
	xfree(pb->data);
	xfree(pb);
d112 2
a113 2
		xfree(pb->data);
		xfree(pb);
d141 1
a141 1
	xfree(pb->data);
@


1.10
log
@Change from a per-session stack of buffers to one global stack which is
much more convenient and also simplifies lot of code. This renders
copy-buffer useless and makes buffer-limit now a server option.

By Tiago Cunha.
@
text
@d1 1
a1 1
/* $OpenBSD: paste.c,v 1.9 2010/06/21 21:44:09 nicm Exp $ */
d34 1
a34 1
paste_walk_stack(struct paste_stack *ps, uint *idx)
@


1.9
log
@Add a choose-buffer command for easier use of the paste buffer stack.
@
text
@d1 1
a1 1
/* $OpenBSD: paste.c,v 1.8 2009/12/03 22:50:10 nicm Exp $ */
a30 13

void
paste_init_stack(struct paste_stack *ps)
{
	ARRAY_INIT(ps);
}

void
paste_free_stack(struct paste_stack *ps)
{
	while (paste_free_top(ps) == 0)
		;
}
@


1.8
log
@Massive spaces->tabs and trailing whitespace cleanup, hopefully for the last
time now I've configured emacs to make them displayed in really annoying
colours...
@
text
@d1 1
a1 1
/* $OpenBSD: paste.c,v 1.7 2009/11/26 22:28:24 nicm Exp $ */
d23 1
d159 24
@


1.7
log
@Tidy up various bits of the paste code, make the data buffer char * and add
comments.
@
text
@d1 1
a1 1
/* $OpenBSD: paste.c,v 1.6 2009/11/03 17:17:24 nicm Exp $ */
d109 1
a109 1
/* 
d136 1
a136 1
/* 
@


1.6
log
@tv member of struct paste_buffer is updated but not otherwise used, so remove
it.
@
text
@d1 1
a1 1
/* $OpenBSD: paste.c,v 1.5 2009/09/20 14:58:12 nicm Exp $ */
d26 5
d44 1
d55 1
d64 1
d73 1
d91 1
d109 4
d114 1
a114 1
paste_add(struct paste_stack *ps, u_char *data, size_t size, u_int limit)
d118 1
a118 1
	if (*data == '\0')
d135 5
d141 1
a141 1
paste_replace(struct paste_stack *ps, u_int idx, u_char *data, size_t size)
d144 3
@


1.5
log
@Regularise some fatal messages.
@
text
@d1 1
a1 1
/* $OpenBSD: paste.c,v 1.4 2009/09/07 18:50:45 nicm Exp $ */
a118 2
	if (gettimeofday(&pb->tv, NULL) != 0)
		fatal("gettimeofday failed");
a133 2
	if (gettimeofday(&pb->tv, NULL) != 0)
		fatal("gettimeofday failed");
@


1.4
log
@Give each paste buffer a size member instead of requiring them to be
zero-terminated.
@
text
@d1 1
a1 1
/* $OpenBSD: paste.c,v 1.3 2009/07/30 20:50:54 nicm Exp $ */
d120 1
a120 1
		fatal("gettimeofday");
d137 1
a137 1
		fatal("gettimeofday");
@


1.3
log
@Don't leak when rollling buffers off when the paste buffer limit is reached.
@
text
@d1 1
a1 1
/* $OpenBSD: paste.c,v 1.2 2009/07/02 16:15:43 nicm Exp $ */
d100 1
a100 1
paste_add(struct paste_stack *ps, char *data, u_int limit)
d118 1
d124 1
a124 1
paste_replace(struct paste_stack *ps, u_int idx, char *data)
d135 1
@


1.2
log
@Fix two copy/paste bugs: forbid zero-length buffers to prevent a fatal error
when trying to paste them, found by me, and miscalculation of the start/end
causing random fatal errors when copying in copy-mode, reported by sthen.

ok sthen "put it in" deraadt
@
text
@d1 1
a1 1
/* $OpenBSD: paste.c,v 1.1 2009/06/01 22:58:49 nicm Exp $ */
d107 4
a110 1
	while (ARRAY_LENGTH(ps) >= limit)
d112 1
@


1.1
log
@Import tmux, a terminal multiplexor allowing (among other things) a single
terminal to be switched between several different windows and programs
displayed on one terminal be detached from one terminal and moved to another.

ok deraadt pirofti
@
text
@d1 1
a1 1
/* $OpenBSD$ */
d103 3
@

