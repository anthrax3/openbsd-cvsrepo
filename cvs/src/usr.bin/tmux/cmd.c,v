head	1.137;
access;
symbols
	OPENBSD_6_1:1.136.0.4
	OPENBSD_6_1_BASE:1.136
	OPENBSD_6_0:1.122.0.2
	OPENBSD_6_0_BASE:1.122
	OPENBSD_5_9:1.121.0.2
	OPENBSD_5_9_BASE:1.121
	OPENBSD_5_8:1.104.0.4
	OPENBSD_5_8_BASE:1.104
	OPENBSD_5_7:1.98.0.2
	OPENBSD_5_7_BASE:1.98
	OPENBSD_5_6:1.95.0.4
	OPENBSD_5_6_BASE:1.95
	OPENBSD_5_5:1.90.0.4
	OPENBSD_5_5_BASE:1.90
	OPENBSD_5_4:1.85.0.2
	OPENBSD_5_4_BASE:1.85
	OPENBSD_5_3:1.74.0.2
	OPENBSD_5_3_BASE:1.74
	OPENBSD_5_2:1.69.0.2
	OPENBSD_5_2_BASE:1.69
	OPENBSD_5_1_BASE:1.62
	OPENBSD_5_1:1.62.0.2
	OPENBSD_5_0:1.56.0.2
	OPENBSD_5_0_BASE:1.56
	OPENBSD_4_9:1.50.0.2
	OPENBSD_4_9_BASE:1.50
	OPENBSD_4_8:1.43.0.2
	OPENBSD_4_8_BASE:1.43
	OPENBSD_4_7:1.38.0.2
	OPENBSD_4_7_BASE:1.38
	OPENBSD_4_6:1.2.0.4
	OPENBSD_4_6_BASE:1.2;
locks; strict;
comment	@ * @;


1.137
date	2017.04.21.20.26.34;	author nicm;	state Exp;
branches;
next	1.136;
commitid	utIGVdoSurUxfh14;

1.136
date	2017.01.24.19.59.19;	author nicm;	state Exp;
branches;
next	1.135;
commitid	qkc1IobTNIhHitel;

1.135
date	2017.01.24.19.53.37;	author nicm;	state Exp;
branches;
next	1.134;
commitid	APEyI6NiCN6S4KhZ;

1.134
date	2017.01.16.14.52.25;	author nicm;	state Exp;
branches;
next	1.133;
commitid	DhrjePH0tXykfoeE;

1.133
date	2017.01.16.14.49.14;	author nicm;	state Exp;
branches;
next	1.132;
commitid	4TgBXjnsq23XHMH4;

1.132
date	2017.01.10.18.10.24;	author nicm;	state Exp;
branches;
next	1.131;
commitid	YJaHuRnojeJxXMIo;

1.131
date	2017.01.10.11.58.30;	author nicm;	state Exp;
branches;
next	1.130;
commitid	8dhX7RlrDeCTjNeQ;

1.130
date	2017.01.06.11.57.03;	author nicm;	state Exp;
branches;
next	1.129;
commitid	m6HBAjiRCa66sywZ;

1.129
date	2016.12.28.10.34.34;	author nicm;	state Exp;
branches;
next	1.128;
commitid	LPxrRrTzsBpY7px2;

1.128
date	2016.11.02.13.35.36;	author nicm;	state Exp;
branches;
next	1.127;
commitid	pDeQxVWEAJmXH0xR;

1.127
date	2016.10.21.13.51.59;	author nicm;	state Exp;
branches;
next	1.126;
commitid	wdi3gMqHqz7D96vm;

1.126
date	2016.10.16.19.04.05;	author nicm;	state Exp;
branches;
next	1.125;
commitid	pxm6osuE99zELpkU;

1.125
date	2016.10.16.17.55.14;	author nicm;	state Exp;
branches;
next	1.124;
commitid	1xIYFpLYkPIXNEvU;

1.124
date	2016.10.13.10.01.49;	author nicm;	state Exp;
branches;
next	1.123;
commitid	AFoah05fh4b2e28V;

1.123
date	2016.10.05.12.32.13;	author nicm;	state Exp;
branches;
next	1.122;
commitid	RDRAm8qhXNpPlJsy;

1.122
date	2016.03.01.12.06.07;	author nicm;	state Exp;
branches;
next	1.121;
commitid	gWWSXkaHYCnCm5SK;

1.121
date	2016.01.19.16.01.30;	author nicm;	state Exp;
branches;
next	1.120;
commitid	gdaGX7HuLjiMTGV0;

1.120
date	2016.01.19.15.59.12;	author nicm;	state Exp;
branches;
next	1.119;
commitid	P3qmSOx6KrDBsb0c;

1.119
date	2015.12.14.23.30.58;	author nicm;	state Exp;
branches;
next	1.118;
commitid	Gp2loryMvVho4B6E;

1.118
date	2015.12.14.00.31.54;	author nicm;	state Exp;
branches;
next	1.117;
commitid	rE682EC14v4gpeFy;

1.117
date	2015.12.13.21.53.57;	author nicm;	state Exp;
branches;
next	1.116;
commitid	gsQkQsSyBCSmU9ax;

1.116
date	2015.12.13.21.17.37;	author nicm;	state Exp;
branches;
next	1.115;
commitid	tS4Tb3RexP35sxWv;

1.115
date	2015.12.13.18.31.47;	author nicm;	state Exp;
branches;
next	1.114;
commitid	vOQHO6uiGtto54AC;

1.114
date	2015.12.13.18.27.47;	author nicm;	state Exp;
branches;
next	1.113;
commitid	xmNN9p4xOi07KQyK;

1.113
date	2015.12.13.17.58.26;	author nicm;	state Exp;
branches;
next	1.112;
commitid	yCFkJ2r7PeFYBogr;

1.112
date	2015.12.13.17.55.14;	author nicm;	state Exp;
branches;
next	1.111;
commitid	Fyn4vblJtlp30z7Q;

1.111
date	2015.12.13.16.44.35;	author nicm;	state Exp;
branches;
next	1.110;
commitid	CpoKtPSIEn27BKfz;

1.110
date	2015.12.13.15.32.12;	author nicm;	state Exp;
branches;
next	1.109;
commitid	aaVCH5jHZVqoxGFq;

1.109
date	2015.12.13.15.00.37;	author nicm;	state Exp;
branches;
next	1.108;
commitid	6wGIbv1dZAryRJ3h;

1.108
date	2015.12.13.14.32.38;	author nicm;	state Exp;
branches;
next	1.107;
commitid	uzMkp8Z4FE6WB6s6;

1.107
date	2015.12.08.01.10.31;	author nicm;	state Exp;
branches;
next	1.106;
commitid	Q7y3PTVPjE0eQDqD;

1.106
date	2015.11.27.15.06.43;	author nicm;	state Exp;
branches;
next	1.105;
commitid	UkIx5fVf8smc7ree;

1.105
date	2015.09.01.09.48.34;	author nicm;	state Exp;
branches;
next	1.104;
commitid	pJBAqtVcysxCLBnf;

1.104
date	2015.04.27.16.25.57;	author nicm;	state Exp;
branches;
next	1.103;
commitid	0WBWxxZyxaAFVhmn;

1.103
date	2015.04.25.18.33.59;	author nicm;	state Exp;
branches;
next	1.102;
commitid	R776bB84r7VPzyws;

1.102
date	2015.04.25.18.09.28;	author nicm;	state Exp;
branches;
next	1.101;
commitid	B7W3z8l90mUfy5Jt;

1.101
date	2015.04.24.23.17.11;	author nicm;	state Exp;
branches;
next	1.100;
commitid	iy4fcaIoXzxOx84I;

1.100
date	2015.04.21.22.42.27;	author nicm;	state Exp;
branches;
next	1.99;
commitid	WWrEgyN9yoWaQD8z;

1.99
date	2015.04.19.21.34.21;	author nicm;	state Exp;
branches;
next	1.98;
commitid	wug6ctIOfhVMeWQp;

1.98
date	2014.10.08.17.35.58;	author nicm;	state Exp;
branches;
next	1.97;
commitid	mK8z9uVwDZMfiNoM;

1.97
date	2014.09.25.12.51.40;	author nicm;	state Exp;
branches;
next	1.96;
commitid	jCtj1fHsNKXqgyoN;

1.96
date	2014.09.25.12.45.35;	author nicm;	state Exp;
branches;
next	1.95;
commitid	jQn7YRPsPXCR1h0G;

1.95
date	2014.07.13.20.57.46;	author nicm;	state Exp;
branches;
next	1.94;
commitid	etsJ8Pm2XwpokpMm;

1.94
date	2014.05.13.08.08.32;	author nicm;	state Exp;
branches;
next	1.93;

1.93
date	2014.05.09.09.11.24;	author nicm;	state Exp;
branches;
next	1.92;

1.92
date	2014.04.16.21.02.41;	author nicm;	state Exp;
branches;
next	1.91;

1.91
date	2014.03.31.21.32.31;	author nicm;	state Exp;
branches;
next	1.90;

1.90
date	2014.01.09.14.20.55;	author nicm;	state Exp;
branches;
next	1.89;

1.89
date	2013.10.10.12.29.35;	author nicm;	state Exp;
branches;
next	1.88;

1.88
date	2013.10.10.12.28.56;	author nicm;	state Exp;
branches;
next	1.87;

1.87
date	2013.10.10.12.07.36;	author nicm;	state Exp;
branches;
next	1.86;

1.86
date	2013.10.10.12.00.24;	author nicm;	state Exp;
branches;
next	1.85;

1.85
date	2013.05.15.15.34.09;	author nicm;	state Exp;
branches;
next	1.84;

1.84
date	2013.03.25.11.53.54;	author nicm;	state Exp;
branches;
next	1.83;

1.83
date	2013.03.25.10.11.45;	author nicm;	state Exp;
branches;
next	1.82;

1.82
date	2013.03.25.10.09.05;	author nicm;	state Exp;
branches;
next	1.81;

1.81
date	2013.03.25.10.04.44;	author nicm;	state Exp;
branches;
next	1.80;

1.80
date	2013.03.24.09.54.10;	author nicm;	state Exp;
branches;
next	1.79;

1.79
date	2013.03.24.09.27.20;	author nicm;	state Exp;
branches;
next	1.78;

1.78
date	2013.03.22.15.54.29;	author nicm;	state Exp;
branches;
next	1.77;

1.77
date	2013.03.22.15.49.55;	author nicm;	state Exp;
branches;
next	1.76;

1.76
date	2013.03.21.16.22.48;	author nicm;	state Exp;
branches;
next	1.75;

1.75
date	2013.03.21.16.19.25;	author nicm;	state Exp;
branches;
next	1.74;

1.74
date	2013.01.18.02.10.29;	author nicm;	state Exp;
branches;
next	1.73;

1.73
date	2012.12.24.12.38.57;	author nicm;	state Exp;
branches;
next	1.72;

1.72
date	2012.11.27.09.20.03;	author nicm;	state Exp;
branches;
next	1.71;

1.71
date	2012.09.24.13.05.10;	author nicm;	state Exp;
branches;
next	1.70;

1.70
date	2012.09.03.09.57.57;	author nicm;	state Exp;
branches;
next	1.69;

1.69
date	2012.07.11.07.10.15;	author nicm;	state Exp;
branches;
next	1.68;

1.68
date	2012.07.10.11.53.01;	author nicm;	state Exp;
branches;
next	1.67;

1.67
date	2012.07.08.16.04.38;	author nicm;	state Exp;
branches;
next	1.66;

1.66
date	2012.06.18.09.20.19;	author nicm;	state Exp;
branches;
next	1.65;

1.65
date	2012.04.23.22.43.09;	author nicm;	state Exp;
branches;
next	1.64;

1.64
date	2012.04.22.05.24.05;	author nicm;	state Exp;
branches;
next	1.63;

1.63
date	2012.03.03.08.31.18;	author nicm;	state Exp;
branches;
next	1.62;

1.62
date	2012.02.06.17.29.29;	author nicm;	state Exp;
branches;
next	1.61;

1.61
date	2012.01.31.15.52.21;	author nicm;	state Exp;
branches;
next	1.60;

1.60
date	2012.01.30.09.39.34;	author nicm;	state Exp;
branches;
next	1.59;

1.59
date	2012.01.20.19.54.07;	author nicm;	state Exp;
branches;
next	1.58;

1.58
date	2011.12.27.14.07.20;	author stsp;	state Exp;
branches;
next	1.57;

1.57
date	2011.12.09.16.28.18;	author nicm;	state Exp;
branches;
next	1.56;

1.56
date	2011.06.05.11.19.03;	author nicm;	state Exp;
branches;
next	1.55;

1.55
date	2011.06.05.10.53.05;	author nicm;	state Exp;
branches;
next	1.54;

1.54
date	2011.05.08.20.35.58;	author nicm;	state Exp;
branches;
next	1.53;

1.53
date	2011.04.06.21.51.31;	author nicm;	state Exp;
branches;
next	1.52;

1.52
date	2011.04.05.19.37.01;	author nicm;	state Exp;
branches;
next	1.51;

1.51
date	2011.03.27.20.27.26;	author nicm;	state Exp;
branches;
next	1.50;

1.50
date	2011.01.23.11.03.43;	author nicm;	state Exp;
branches;
next	1.49;

1.49
date	2011.01.04.00.42.47;	author nicm;	state Exp;
branches;
next	1.48;

1.48
date	2010.12.30.23.16.18;	author nicm;	state Exp;
branches;
next	1.47;

1.47
date	2010.12.21.22.37.59;	author nicm;	state Exp;
branches;
next	1.46;

1.46
date	2010.10.29.20.11.57;	author nicm;	state Exp;
branches;
next	1.45;

1.45
date	2010.10.23.13.04.34;	author nicm;	state Exp;
branches;
next	1.44;

1.44
date	2010.10.16.07.57.42;	author nicm;	state Exp;
branches;
next	1.43;

1.43
date	2010.07.14.18.37.49;	author nicm;	state Exp;
branches;
next	1.42;

1.42
date	2010.06.21.21.44.09;	author nicm;	state Exp;
branches;
next	1.41;

1.41
date	2010.06.21.01.46.36;	author nicm;	state Exp;
branches;
next	1.40;

1.40
date	2010.05.05.23.24.23;	author nicm;	state Exp;
branches;
next	1.39;

1.39
date	2010.03.22.19.07.52;	author nicm;	state Exp;
branches;
next	1.38;

1.38
date	2010.01.19.21.27.47;	author nicm;	state Exp;
branches;
next	1.37;

1.37
date	2010.01.07.20.52.18;	author nicm;	state Exp;
branches;
next	1.36;

1.36
date	2009.12.08.07.49.31;	author nicm;	state Exp;
branches;
next	1.35;

1.35
date	2009.12.03.22.50.10;	author nicm;	state Exp;
branches;
next	1.34;

1.34
date	2009.12.01.18.42.38;	author nicm;	state Exp;
branches;
next	1.33;

1.33
date	2009.11.21.17.52.18;	author nicm;	state Exp;
branches;
next	1.32;

1.32
date	2009.11.18.13.16.33;	author nicm;	state Exp;
branches;
next	1.31;

1.31
date	2009.11.03.22.40.40;	author nicm;	state Exp;
branches;
next	1.30;

1.30
date	2009.11.03.20.59.22;	author nicm;	state Exp;
branches;
next	1.29;

1.29
date	2009.11.03.20.29.47;	author nicm;	state Exp;
branches;
next	1.28;

1.28
date	2009.11.02.16.24.29;	author nicm;	state Exp;
branches;
next	1.27;

1.27
date	2009.10.26.21.42.04;	author deraadt;	state Exp;
branches;
next	1.26;

1.26
date	2009.10.14.20.52.28;	author nicm;	state Exp;
branches;
next	1.25;

1.25
date	2009.10.14.09.29.10;	author nicm;	state Exp;
branches;
next	1.24;

1.24
date	2009.10.11.10.04.27;	author nicm;	state Exp;
branches;
next	1.23;

1.23
date	2009.10.10.17.19.38;	author nicm;	state Exp;
branches;
next	1.22;

1.22
date	2009.10.07.07.02.40;	author nicm;	state Exp;
branches;
next	1.21;

1.21
date	2009.10.06.07.19.32;	author nicm;	state Exp;
branches;
next	1.20;

1.20
date	2009.10.05.18.30.54;	author nicm;	state Exp;
branches;
next	1.19;

1.19
date	2009.09.24.14.17.09;	author nicm;	state Exp;
branches;
next	1.18;

1.18
date	2009.09.23.06.18.47;	author nicm;	state Exp;
branches;
next	1.17;

1.17
date	2009.09.20.19.15.01;	author nicm;	state Exp;
branches;
next	1.16;

1.16
date	2009.08.31.20.46.19;	author nicm;	state Exp;
branches;
next	1.15;

1.15
date	2009.08.25.12.18.51;	author nicm;	state Exp;
branches;
next	1.14;

1.14
date	2009.08.23.16.45.00;	author nicm;	state Exp;
branches;
next	1.13;

1.13
date	2009.08.08.21.52.43;	author nicm;	state Exp;
branches;
next	1.12;

1.12
date	2009.07.30.13.45.56;	author nicm;	state Exp;
branches;
next	1.11;

1.11
date	2009.07.29.17.03.16;	author nicm;	state Exp;
branches;
next	1.10;

1.10
date	2009.07.26.12.58.44;	author nicm;	state Exp;
branches;
next	1.9;

1.9
date	2009.07.24.18.46.40;	author nicm;	state Exp;
branches;
next	1.8;

1.8
date	2009.07.22.21.23.29;	author nicm;	state Exp;
branches;
next	1.7;

1.7
date	2009.07.17.18.45.08;	author nicm;	state Exp;
branches;
next	1.6;

1.6
date	2009.07.15.15.09.17;	author nicm;	state Exp;
branches;
next	1.5;

1.5
date	2009.07.13.17.47.46;	author nicm;	state Exp;
branches;
next	1.4;

1.4
date	2009.07.09.15.47.49;	author nicm;	state Exp;
branches;
next	1.3;

1.3
date	2009.07.07.21.23.22;	author nicm;	state Exp;
branches;
next	1.2;

1.2
date	2009.06.04.23.34.32;	author nicm;	state Exp;
branches;
next	1.1;

1.1
date	2009.06.01.22.58.49;	author nicm;	state Exp;
branches;
next	;


desc
@@


1.137
log
@Make the cmd_find_* functions more obvious when looking for a client,
rather than having it inside other functions. Should be no change to the
way targets are resolved just yet.
@
text
@/* $OpenBSD: cmd.c,v 1.136 2017/01/24 19:59:19 nicm Exp $ */

/*
 * Copyright (c) 2007 Nicholas Marriott <nicholas.marriott@@gmail.com>
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF MIND, USE, DATA OR PROFITS, WHETHER
 * IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING
 * OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */

#include <sys/types.h>
#include <sys/time.h>

#include <fnmatch.h>
#include <paths.h>
#include <pwd.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>

#include "tmux.h"

extern const struct cmd_entry cmd_attach_session_entry;
extern const struct cmd_entry cmd_bind_key_entry;
extern const struct cmd_entry cmd_break_pane_entry;
extern const struct cmd_entry cmd_capture_pane_entry;
extern const struct cmd_entry cmd_choose_buffer_entry;
extern const struct cmd_entry cmd_choose_client_entry;
extern const struct cmd_entry cmd_choose_session_entry;
extern const struct cmd_entry cmd_choose_tree_entry;
extern const struct cmd_entry cmd_choose_window_entry;
extern const struct cmd_entry cmd_clear_history_entry;
extern const struct cmd_entry cmd_clock_mode_entry;
extern const struct cmd_entry cmd_command_prompt_entry;
extern const struct cmd_entry cmd_confirm_before_entry;
extern const struct cmd_entry cmd_copy_mode_entry;
extern const struct cmd_entry cmd_delete_buffer_entry;
extern const struct cmd_entry cmd_detach_client_entry;
extern const struct cmd_entry cmd_display_message_entry;
extern const struct cmd_entry cmd_display_panes_entry;
extern const struct cmd_entry cmd_down_pane_entry;
extern const struct cmd_entry cmd_find_window_entry;
extern const struct cmd_entry cmd_has_session_entry;
extern const struct cmd_entry cmd_if_shell_entry;
extern const struct cmd_entry cmd_join_pane_entry;
extern const struct cmd_entry cmd_kill_pane_entry;
extern const struct cmd_entry cmd_kill_server_entry;
extern const struct cmd_entry cmd_kill_session_entry;
extern const struct cmd_entry cmd_kill_window_entry;
extern const struct cmd_entry cmd_last_pane_entry;
extern const struct cmd_entry cmd_last_window_entry;
extern const struct cmd_entry cmd_link_window_entry;
extern const struct cmd_entry cmd_list_buffers_entry;
extern const struct cmd_entry cmd_list_clients_entry;
extern const struct cmd_entry cmd_list_commands_entry;
extern const struct cmd_entry cmd_list_keys_entry;
extern const struct cmd_entry cmd_list_panes_entry;
extern const struct cmd_entry cmd_list_sessions_entry;
extern const struct cmd_entry cmd_list_windows_entry;
extern const struct cmd_entry cmd_load_buffer_entry;
extern const struct cmd_entry cmd_lock_client_entry;
extern const struct cmd_entry cmd_lock_server_entry;
extern const struct cmd_entry cmd_lock_session_entry;
extern const struct cmd_entry cmd_move_pane_entry;
extern const struct cmd_entry cmd_move_window_entry;
extern const struct cmd_entry cmd_new_session_entry;
extern const struct cmd_entry cmd_new_window_entry;
extern const struct cmd_entry cmd_next_layout_entry;
extern const struct cmd_entry cmd_next_window_entry;
extern const struct cmd_entry cmd_paste_buffer_entry;
extern const struct cmd_entry cmd_pipe_pane_entry;
extern const struct cmd_entry cmd_previous_layout_entry;
extern const struct cmd_entry cmd_previous_window_entry;
extern const struct cmd_entry cmd_refresh_client_entry;
extern const struct cmd_entry cmd_rename_session_entry;
extern const struct cmd_entry cmd_rename_window_entry;
extern const struct cmd_entry cmd_resize_pane_entry;
extern const struct cmd_entry cmd_respawn_pane_entry;
extern const struct cmd_entry cmd_respawn_window_entry;
extern const struct cmd_entry cmd_rotate_window_entry;
extern const struct cmd_entry cmd_run_shell_entry;
extern const struct cmd_entry cmd_save_buffer_entry;
extern const struct cmd_entry cmd_select_layout_entry;
extern const struct cmd_entry cmd_select_pane_entry;
extern const struct cmd_entry cmd_select_window_entry;
extern const struct cmd_entry cmd_send_keys_entry;
extern const struct cmd_entry cmd_send_prefix_entry;
extern const struct cmd_entry cmd_set_buffer_entry;
extern const struct cmd_entry cmd_set_environment_entry;
extern const struct cmd_entry cmd_set_hook_entry;
extern const struct cmd_entry cmd_set_option_entry;
extern const struct cmd_entry cmd_set_window_option_entry;
extern const struct cmd_entry cmd_show_buffer_entry;
extern const struct cmd_entry cmd_show_environment_entry;
extern const struct cmd_entry cmd_show_hooks_entry;
extern const struct cmd_entry cmd_show_messages_entry;
extern const struct cmd_entry cmd_show_options_entry;
extern const struct cmd_entry cmd_show_window_options_entry;
extern const struct cmd_entry cmd_source_file_entry;
extern const struct cmd_entry cmd_split_window_entry;
extern const struct cmd_entry cmd_start_server_entry;
extern const struct cmd_entry cmd_suspend_client_entry;
extern const struct cmd_entry cmd_swap_pane_entry;
extern const struct cmd_entry cmd_swap_window_entry;
extern const struct cmd_entry cmd_switch_client_entry;
extern const struct cmd_entry cmd_unbind_key_entry;
extern const struct cmd_entry cmd_unlink_window_entry;
extern const struct cmd_entry cmd_up_pane_entry;
extern const struct cmd_entry cmd_wait_for_entry;

const struct cmd_entry *cmd_table[] = {
	&cmd_attach_session_entry,
	&cmd_bind_key_entry,
	&cmd_break_pane_entry,
	&cmd_capture_pane_entry,
	&cmd_choose_buffer_entry,
	&cmd_choose_client_entry,
	&cmd_choose_session_entry,
	&cmd_choose_tree_entry,
	&cmd_choose_window_entry,
	&cmd_clear_history_entry,
	&cmd_clock_mode_entry,
	&cmd_command_prompt_entry,
	&cmd_confirm_before_entry,
	&cmd_copy_mode_entry,
	&cmd_delete_buffer_entry,
	&cmd_detach_client_entry,
	&cmd_display_message_entry,
	&cmd_display_panes_entry,
	&cmd_find_window_entry,
	&cmd_has_session_entry,
	&cmd_if_shell_entry,
	&cmd_join_pane_entry,
	&cmd_kill_pane_entry,
	&cmd_kill_server_entry,
	&cmd_kill_session_entry,
	&cmd_kill_window_entry,
	&cmd_last_pane_entry,
	&cmd_last_window_entry,
	&cmd_link_window_entry,
	&cmd_list_buffers_entry,
	&cmd_list_clients_entry,
	&cmd_list_commands_entry,
	&cmd_list_keys_entry,
	&cmd_list_panes_entry,
	&cmd_list_sessions_entry,
	&cmd_list_windows_entry,
	&cmd_load_buffer_entry,
	&cmd_lock_client_entry,
	&cmd_lock_server_entry,
	&cmd_lock_session_entry,
	&cmd_move_pane_entry,
	&cmd_move_window_entry,
	&cmd_new_session_entry,
	&cmd_new_window_entry,
	&cmd_next_layout_entry,
	&cmd_next_window_entry,
	&cmd_paste_buffer_entry,
	&cmd_pipe_pane_entry,
	&cmd_previous_layout_entry,
	&cmd_previous_window_entry,
	&cmd_refresh_client_entry,
	&cmd_rename_session_entry,
	&cmd_rename_window_entry,
	&cmd_resize_pane_entry,
	&cmd_respawn_pane_entry,
	&cmd_respawn_window_entry,
	&cmd_rotate_window_entry,
	&cmd_run_shell_entry,
	&cmd_save_buffer_entry,
	&cmd_select_layout_entry,
	&cmd_select_pane_entry,
	&cmd_select_window_entry,
	&cmd_send_keys_entry,
	&cmd_send_prefix_entry,
	&cmd_set_buffer_entry,
	&cmd_set_environment_entry,
	&cmd_set_hook_entry,
	&cmd_set_option_entry,
	&cmd_set_window_option_entry,
	&cmd_show_buffer_entry,
	&cmd_show_environment_entry,
	&cmd_show_hooks_entry,
	&cmd_show_messages_entry,
	&cmd_show_options_entry,
	&cmd_show_window_options_entry,
	&cmd_source_file_entry,
	&cmd_split_window_entry,
	&cmd_start_server_entry,
	&cmd_suspend_client_entry,
	&cmd_swap_pane_entry,
	&cmd_swap_window_entry,
	&cmd_switch_client_entry,
	&cmd_unbind_key_entry,
	&cmd_unlink_window_entry,
	&cmd_wait_for_entry,
	NULL
};

int
cmd_pack_argv(int argc, char **argv, char *buf, size_t len)
{
	size_t	arglen;
	int	i;

	if (argc == 0)
		return (0);

	*buf = '\0';
	for (i = 0; i < argc; i++) {
		if (strlcpy(buf, argv[i], len) >= len)
			return (-1);
		arglen = strlen(argv[i]) + 1;
		buf += arglen;
		len -= arglen;
	}

	return (0);
}

int
cmd_unpack_argv(char *buf, size_t len, int argc, char ***argv)
{
	int	i;
	size_t	arglen;

	if (argc == 0)
		return (0);
	*argv = xcalloc(argc, sizeof **argv);

	buf[len - 1] = '\0';
	for (i = 0; i < argc; i++) {
		if (len == 0) {
			cmd_free_argv(argc, *argv);
			return (-1);
		}

		arglen = strlen(buf) + 1;
		(*argv)[i] = xstrdup(buf);
		buf += arglen;
		len -= arglen;
	}

	return (0);
}

char **
cmd_copy_argv(int argc, char **argv)
{
	char	**new_argv;
	int	  i;

	if (argc == 0)
		return (NULL);
	new_argv = xcalloc(argc + 1, sizeof *new_argv);
	for (i = 0; i < argc; i++) {
		if (argv[i] != NULL)
			new_argv[i] = xstrdup(argv[i]);
	}
	return (new_argv);
}

void
cmd_free_argv(int argc, char **argv)
{
	int	i;

	if (argc == 0)
		return;
	for (i = 0; i < argc; i++)
		free(argv[i]);
	free(argv);
}

char *
cmd_stringify_argv(int argc, char **argv)
{
	char	*buf;
	int	 i;
	size_t	 len;

	if (argc == 0)
		return (xstrdup(""));

	len = 0;
	buf = NULL;

	for (i = 0; i < argc; i++) {
		len += strlen(argv[i]) + 1;
		buf = xrealloc(buf, len);

		if (i == 0)
			*buf = '\0';
		else
			strlcat(buf, " ", len);
		strlcat(buf, argv[i], len);
	}
	return (buf);
}

static int
cmd_try_alias(int *argc, char ***argv)
{
	struct options_entry	 *o;
	int			  old_argc = *argc, new_argc;
	char			**old_argv = *argv, **new_argv;
	u_int			  size, idx;
	int			  i;
	size_t			  wanted;
	const char		 *s, *cp = NULL;

	o = options_get_only(global_options, "command-alias");
	if (o == NULL || options_array_size(o, &size) == -1 || size == 0)
		return (-1);

	wanted = strlen(old_argv[0]);
	for (idx = 0; idx < size; idx++) {
		s = options_array_get(o, idx);
		if (s == NULL)
			continue;

		cp = strchr(s, '=');
		if (cp == NULL || (size_t)(cp - s) != wanted)
			continue;
		if (strncmp(old_argv[0], s, wanted) == 0)
			break;
	}
	if (idx == size)
		return (-1);

	if (cmd_string_split(cp + 1, &new_argc, &new_argv) != 0)
		return (-1);

	*argc = new_argc + old_argc - 1;
	*argv = xcalloc((*argc) + 1, sizeof **argv);

	for (i = 0; i < new_argc; i++)
		(*argv)[i] = xstrdup(new_argv[i]);
	for (i = 1; i < old_argc; i++)
		(*argv)[new_argc + i - 1] = xstrdup(old_argv[i]);

	log_debug("alias: %s=%s", old_argv[0], cp + 1);
	for (i = 0; i < *argc; i++)
		log_debug("alias: argv[%d] = %s", i, (*argv)[i]);

	cmd_free_argv(new_argc, new_argv);
	return (0);
}

struct cmd *
cmd_parse(int argc, char **argv, const char *file, u_int line, char **cause)
{
	const char		*name;
	const struct cmd_entry **entryp, *entry;
	struct cmd		*cmd;
	struct args		*args;
	char			 s[BUFSIZ];
	int			 ambiguous, allocated = 0;

	*cause = NULL;
	if (argc == 0) {
		xasprintf(cause, "no command");
		return (NULL);
	}
	name = argv[0];

retry:
	ambiguous = 0;
	entry = NULL;
	for (entryp = cmd_table; *entryp != NULL; entryp++) {
		if ((*entryp)->alias != NULL &&
		    strcmp((*entryp)->alias, argv[0]) == 0) {
			ambiguous = 0;
			entry = *entryp;
			break;
		}

		if (strncmp((*entryp)->name, argv[0], strlen(argv[0])) != 0)
			continue;
		if (entry != NULL)
			ambiguous = 1;
		entry = *entryp;

		/* Bail now if an exact match. */
		if (strcmp(entry->name, argv[0]) == 0)
			break;
	}
	if ((ambiguous || entry == NULL) &&
	    server_proc != NULL &&
	    !allocated &&
	    cmd_try_alias(&argc, &argv) == 0) {
		allocated = 1;
		goto retry;
	}
	if (ambiguous)
		goto ambiguous;
	if (entry == NULL) {
		xasprintf(cause, "unknown command: %s", name);
		return (NULL);
	}

	args = args_parse(entry->args.template, argc, argv);
	if (args == NULL)
		goto usage;
	if (entry->args.lower != -1 && args->argc < entry->args.lower)
		goto usage;
	if (entry->args.upper != -1 && args->argc > entry->args.upper)
		goto usage;

	cmd = xcalloc(1, sizeof *cmd);
	cmd->entry = entry;
	cmd->args = args;

	if (file != NULL)
		cmd->file = xstrdup(file);
	cmd->line = line;

	if (allocated)
		cmd_free_argv(argc, argv);
	return (cmd);

ambiguous:
	*s = '\0';
	for (entryp = cmd_table; *entryp != NULL; entryp++) {
		if (strncmp((*entryp)->name, argv[0], strlen(argv[0])) != 0)
			continue;
		if (strlcat(s, (*entryp)->name, sizeof s) >= sizeof s)
			break;
		if (strlcat(s, ", ", sizeof s) >= sizeof s)
			break;
	}
	s[strlen(s) - 2] = '\0';
	xasprintf(cause, "ambiguous command: %s, could be: %s", name, s);
	return (NULL);

usage:
	if (args != NULL)
		args_free(args);
	xasprintf(cause, "usage: %s %s", entry->name, entry->usage);
	return (NULL);
}

static int
cmd_prepare_state_flag(char c, const char *target, enum cmd_entry_flag flag,
    struct cmdq_item *item)
{
	int			 targetflags, error;
	struct cmd_find_state	*fs = NULL;

	if (flag == CMD_NONE ||
	    flag == CMD_CLIENT ||
	    flag == CMD_CLIENT_CANFAIL)
		return (0);

	if (c == 't')
		fs = &item->state.tflag;
	else if (c == 's')
		fs = &item->state.sflag;

	if (flag == CMD_SESSION_WITHPANE) {
		if (target != NULL && target[strcspn(target, ":.")] != '\0')
			flag = CMD_PANE;
		else
			flag = CMD_SESSION_PREFERUNATTACHED;
	}

	targetflags = 0;
	switch (flag) {
	case CMD_SESSION:
	case CMD_SESSION_CANFAIL:
	case CMD_SESSION_PREFERUNATTACHED:
	case CMD_SESSION_WITHPANE:
		if (flag == CMD_SESSION_CANFAIL)
			targetflags |= CMD_FIND_QUIET;
		if (flag == CMD_SESSION_PREFERUNATTACHED)
			targetflags |= CMD_FIND_PREFER_UNATTACHED;
		break;
	case CMD_MOVEW_R:
		flag = CMD_WINDOW_INDEX;
		/* FALLTHROUGH */
	case CMD_WINDOW:
	case CMD_WINDOW_CANFAIL:
	case CMD_WINDOW_MARKED:
	case CMD_WINDOW_INDEX:
		if (flag == CMD_WINDOW_CANFAIL)
			targetflags |= CMD_FIND_QUIET;
		if (flag == CMD_WINDOW_MARKED)
			targetflags |= CMD_FIND_DEFAULT_MARKED;
		if (flag == CMD_WINDOW_INDEX)
			targetflags |= CMD_FIND_WINDOW_INDEX;
		break;
	case CMD_PANE:
	case CMD_PANE_CANFAIL:
	case CMD_PANE_MARKED:
		if (flag == CMD_PANE_CANFAIL)
			targetflags |= CMD_FIND_QUIET;
		if (flag == CMD_PANE_MARKED)
			targetflags |= CMD_FIND_DEFAULT_MARKED;
		break;
	default:
		fatalx("unknown %cflag %d", c, flag);
	}
	log_debug("%s: flag %c %d %#x", __func__, c, flag, targetflags);

	switch (flag) {
	case CMD_NONE:
	case CMD_CLIENT:
	case CMD_CLIENT_CANFAIL:
		return (0);
	case CMD_SESSION:
	case CMD_SESSION_CANFAIL:
	case CMD_SESSION_PREFERUNATTACHED:
	case CMD_SESSION_WITHPANE:
		error = cmd_find_target(fs, item, target, CMD_FIND_SESSION,
		    targetflags);
		if (error != 0)
			goto error;
		break;
	case CMD_MOVEW_R:
		error = cmd_find_target(fs, item, target, CMD_FIND_SESSION,
		    CMD_FIND_QUIET);
		if (error == 0)
			break;
		/* FALLTHROUGH */
	case CMD_WINDOW:
	case CMD_WINDOW_CANFAIL:
	case CMD_WINDOW_MARKED:
	case CMD_WINDOW_INDEX:
		error = cmd_find_target(fs, item, target, CMD_FIND_WINDOW,
		    targetflags);
		if (error != 0)
			goto error;
		break;
	case CMD_PANE:
	case CMD_PANE_CANFAIL:
	case CMD_PANE_MARKED:
		error = cmd_find_target(fs, item, target, CMD_FIND_PANE,
		    targetflags);
		if (error != 0)
			goto error;
		break;
	default:
		fatalx("unknown %cflag %d", c, flag);
	}
	return (0);

error:
	if (~targetflags & CMD_FIND_QUIET)
		return (-1);
	cmd_find_clear_state(fs, 0);
	return (0);
}

int
cmd_prepare_state(struct cmd *cmd, struct cmdq_item *item)
{
	const struct cmd_entry	*entry = cmd->entry;
	struct cmd_state	*state = &item->state;
	char			*tmp;
	enum cmd_entry_flag	 flag;
	const char		*s;
	int			 error;

	tmp = cmd_print(cmd);
	log_debug("preparing state for %s (client %p)", tmp, item->client);
	free(tmp);

	state->c = NULL;
	cmd_find_clear_state(&state->tflag, 0);
	cmd_find_clear_state(&state->sflag, 0);

	flag = cmd->entry->cflag;
	if (flag == CMD_NONE) {
		flag = cmd->entry->tflag;
		if (flag == CMD_CLIENT || flag == CMD_CLIENT_CANFAIL)
			s = args_get(cmd->args, 't');
		else
			s = NULL;
	} else
		s = args_get(cmd->args, 'c');
	switch (flag) {
	case CMD_CLIENT:
		state->c = cmd_find_client(item, s, 0);
		if (state->c == NULL)
			return (-1);
		break;
	default:
		state->c = cmd_find_client(item, s, 1);
		break;
	}
	log_debug("using client %p", state->c);

	s = args_get(cmd->args, 't');
	log_debug("preparing -t state: target %s", s == NULL ? "none" : s);

	error = cmd_prepare_state_flag('t', s, entry->tflag, item);
	if (error != 0)
		return (error);

	s = args_get(cmd->args, 's');
	log_debug("preparing -s state: target %s", s == NULL ? "none" : s);

	error = cmd_prepare_state_flag('s', s, entry->sflag, item);
	if (error != 0)
		return (error);

	if (!cmd_find_empty_state(&state->tflag) &&
	    !cmd_find_valid_state(&state->tflag))
		fatalx("invalid -t state");
	if (!cmd_find_empty_state(&state->sflag) &&
	    !cmd_find_valid_state(&state->sflag))
		fatalx("invalid -s state");

	return (0);
}

char *
cmd_print(struct cmd *cmd)
{
	char	*out, *s;

	s = args_print(cmd->args);
	if (*s != '\0')
		xasprintf(&out, "%s %s", cmd->entry->name, s);
	else
		out = xstrdup(cmd->entry->name);
	free(s);

	return (out);
}

/* Adjust current mouse position for a pane. */
int
cmd_mouse_at(struct window_pane *wp, struct mouse_event *m, u_int *xp,
    u_int *yp, int last)
{
	u_int	x, y;

	if (last) {
		x = m->lx;
		y = m->ly;
	} else {
		x = m->x;
		y = m->y;
	}

	if (m->statusat == 0 && y > 0)
		y--;
	else if (m->statusat > 0 && y >= (u_int)m->statusat)
		y = m->statusat - 1;

	if (x < wp->xoff || x >= wp->xoff + wp->sx)
		return (-1);
	if (y < wp->yoff || y >= wp->yoff + wp->sy)
		return (-1);

	if (xp != NULL)
		*xp = x - wp->xoff;
	if (yp != NULL)
		*yp = y - wp->yoff;
	return (0);
}

/* Get current mouse window if any. */
struct winlink *
cmd_mouse_window(struct mouse_event *m, struct session **sp)
{
	struct session	*s;
	struct window	*w;

	if (!m->valid || m->s == -1 || m->w == -1)
		return (NULL);
	if ((s = session_find_by_id(m->s)) == NULL)
		return (NULL);
	if ((w = window_find_by_id(m->w)) == NULL)
		return (NULL);

	if (sp != NULL)
		*sp = s;
	return (winlink_find_by_window(&s->windows, w));
}

/* Get current mouse pane if any. */
struct window_pane *
cmd_mouse_pane(struct mouse_event *m, struct session **sp,
    struct winlink **wlp)
{
	struct winlink		*wl;
	struct window_pane     	*wp;

	if ((wl = cmd_mouse_window(m, sp)) == NULL)
		return (NULL);
	if ((wp = window_pane_find_by_id(m->wp)) == NULL)
		return (NULL);
	if (!window_has_pane(wl->window, wp))
		return (NULL);

	if (wlp != NULL)
		*wlp = wl;
	return (wp);
}

/* Replace the first %% or %idx in template by s. */
char *
cmd_template_replace(const char *template, const char *s, int idx)
{
	char		 ch, *buf;
	const char	*ptr, *cp, quote[] = "\"\\$";
	int		 replaced, quoted;
	size_t		 len;

	if (strchr(template, '%') == NULL)
		return (xstrdup(template));

	buf = xmalloc(1);
	*buf = '\0';
	len = 0;
	replaced = 0;

	ptr = template;
	while (*ptr != '\0') {
		switch (ch = *ptr++) {
		case '%':
			if (*ptr < '1' || *ptr > '9' || *ptr - '0' != idx) {
				if (*ptr != '%' || replaced)
					break;
				replaced = 1;
			}
			ptr++;

			quoted = (*ptr == '%');
			if (quoted)
				ptr++;

			buf = xrealloc(buf, len + (strlen(s) * 3) + 1);
			for (cp = s; *cp != '\0'; cp++) {
				if (quoted && strchr(quote, *cp) != NULL)
					buf[len++] = '\\';
				if (quoted && *cp == ';') {
					buf[len++] = '\\';
					buf[len++] = '\\';
				}
				buf[len++] = *cp;
			}
			buf[len] = '\0';
			continue;
		}
		buf = xrealloc(buf, len + 2);
		buf[len++] = ch;
		buf[len] = '\0';
	}

	return (buf);
}
@


1.136
log
@server-info can become an alias rather than a command.
@
text
@d1 1
a1 1
/* $OpenBSD: cmd.c,v 1.135 2017/01/24 19:53:37 nicm Exp $ */
a456 1
	struct cmd_find_state	 current;
a512 9
	error = cmd_find_current(&current, item, targetflags);
	if (error != 0) {
		if (~targetflags & CMD_FIND_QUIET)
			return (-1);
		cmd_find_clear_state(&current, NULL, 0);
	}
	if (!cmd_find_empty_state(&current) && !cmd_find_valid_state(&current))
		fatalx("invalid current state");

d522 2
a523 2
		error = cmd_find_target(fs, &current, item, target,
		    CMD_FIND_SESSION, targetflags);
d528 2
a529 2
		error = cmd_find_target(fs, &current, item, target,
		    CMD_FIND_SESSION, CMD_FIND_QUIET);
d537 2
a538 2
		error = cmd_find_target(fs, &current, item, target,
		    CMD_FIND_WINDOW, targetflags);
d545 2
a546 2
		error = cmd_find_target(fs, &current, item, target,
		    CMD_FIND_PANE, targetflags);
d558 1
a558 1
	cmd_find_clear_state(fs, NULL, 0);
d577 2
a578 2
	cmd_find_clear_state(&state->tflag, NULL, 0);
	cmd_find_clear_state(&state->sflag, NULL, 0);
@


1.135
log
@Add support for custom command aliases, this is an array option which
contains items of the form "alias=command". This is consulted when an
unknown command is parsed.
@
text
@d1 1
a1 1
/* $OpenBSD: cmd.c,v 1.134 2017/01/16 14:52:25 nicm Exp $ */
a95 1
extern const struct cmd_entry cmd_server_info_entry;
a183 1
	&cmd_server_info_entry,
@


1.134
log
@Revert WIP parts of previous I didn't mean to commit yet.
@
text
@d1 1
a1 1
/* $OpenBSD: cmd.c,v 1.132 2017/01/10 18:10:24 nicm Exp $ */
d311 49
d363 1
d368 1
a368 1
	int			 ambiguous = 0;
d375 1
d377 2
d398 7
d408 1
a408 1
		xasprintf(cause, "unknown command: %s", argv[0]);
d428 2
d443 1
a443 1
	xasprintf(cause, "ambiguous command: %s, could be: %s", argv[0], s);
@


1.133
log
@getopt() has a struct option so just return to using options_entry.
@
text
@a310 49
static int
cmd_try_alias(int *argc, char ***argv)
{
	struct options_entry	 *o;
	int			  old_argc = *argc, new_argc;
	char			**old_argv = *argv, **new_argv;
	u_int			  size, idx;
	int			  i;
	size_t			  wanted;
	const char		 *s, *cp = NULL;

	o = options_get_only(global_options, "command-alias");
	if (o == NULL || options_array_size(o, &size) == -1 || size == 0)
		return (-1);

	wanted = strlen(old_argv[0]);
	for (idx = 0; idx < size; idx++) {
		s = options_array_get(o, idx);
		if (s == NULL)
			continue;

		cp = strchr(s, '=');
		if (cp == NULL || (size_t)(cp - s) != wanted)
			continue;
		if (strncmp(old_argv[0], s, wanted) == 0)
			break;
	}
	if (idx == size)
		return (-1);

	if (cmd_string_split(cp + 1, &new_argc, &new_argv) != 0)
		return (-1);

	*argc = new_argc + old_argc - 1;
	*argv = xcalloc((*argc) + 1, sizeof **argv);

	for (i = 0; i < new_argc; i++)
		(*argv)[i] = xstrdup(new_argv[i]);
	for (i = 1; i < old_argc; i++)
		(*argv)[new_argc + i - 1] = xstrdup(old_argv[i]);

	log_debug("alias: %s=%s", old_argv[0], cp + 1);
	for (i = 0; i < *argc; i++)
		log_debug("alias: argv[%d] = %s", i, (*argv)[i]);

	cmd_free_argv(new_argc, new_argv);
	return (0);
}

a313 1
	const char		*name;
d318 1
a318 1
	int			 ambiguous, allocated = 0;
a324 1
	name = argv[0];
a325 2
retry:
	ambiguous = 0;
a344 7
	if ((ambiguous || entry == NULL) &&
	    server_proc != NULL &&
	    !allocated &&
	    cmd_try_alias(&argc, &argv) == 0) {
		allocated = 1;
		goto retry;
	}
d348 1
a348 1
		xasprintf(cause, "unknown command: %s", name);
a367 2
	if (allocated)
		cmd_free_argv(argc, argv);
d381 1
a381 1
	xasprintf(cause, "ambiguous command: %s, could be: %s", name, s);
@


1.132
log
@Need to escape ; twice because the command list parser will eat one,
reported by Theo Buehler.
@
text
@d1 1
a1 1
/* $OpenBSD: cmd.c,v 1.131 2017/01/10 11:58:30 nicm Exp $ */
d311 49
d363 1
d368 1
a368 1
	int			 ambiguous = 0;
d375 1
d377 2
d398 7
d408 1
a408 1
		xasprintf(cause, "unknown command: %s", argv[0]);
d428 2
d443 1
a443 1
	xasprintf(cause, "ambiguous command: %s, could be: %s", argv[0], s);
@


1.131
log
@Quote backslash as well for %%%.
@
text
@d1 1
a1 1
/* $OpenBSD: cmd.c,v 1.130 2017/01/06 11:57:03 nicm Exp $ */
d693 1
a693 1
			buf = xrealloc(buf, len + (strlen(s) * 2) + 1);
d697 4
@


1.130
log
@Incremental search in copy mode (on for emacs keys by default) - much
the same as normal searching but updates the cursor position and marked
search terms as you type. C-r and C-s in the prompt repeat the search,
once finished searching (with Enter), N and n work as before.
@
text
@d1 1
a1 1
/* $OpenBSD: cmd.c,v 1.129 2016/12/28 10:34:34 nicm Exp $ */
d666 1
a666 1
	const char	*ptr, *cp;
d695 1
a695 1
				if (quoted && (*cp == '"' || *cp == '$'))
@


1.129
log
@Fix the prefer unattached session behaviour of
attach-session/switch-client, reported by Thomas Sattle.
@
text
@d1 1
a1 1
/* $OpenBSD: cmd.c,v 1.128 2016/11/02 13:35:36 nicm Exp $ */
d695 1
a695 1
				if (quoted && *cp == '"')
@


1.128
log
@Make an empty state on error rather than leaving something partially
created (which now is now a fatal() later).
@
text
@d1 1
a1 1
/* $OpenBSD: cmd.c,v 1.127 2016/10/21 13:51:59 nicm Exp $ */
d413 1
a413 1
			flag = CMD_SESSION;
d421 1
@


1.127
log
@Add %%% to substitute with quotes escaped (convert " to \"). Use this
for the prompts in copy mode. Fixes problems with jumping to ' reported
by Theo Buehler.
@
text
@d1 1
a1 1
/* $OpenBSD: cmd.c,v 1.126 2016/10/16 19:04:05 nicm Exp $ */
d454 5
a458 2
	if (error != 0 && ~targetflags & CMD_FIND_QUIET)
		return (-1);
d473 2
a474 2
		if (error != 0 && ~targetflags & CMD_FIND_QUIET)
			return (-1);
d488 2
a489 2
		if (error != 0 && ~targetflags & CMD_FIND_QUIET)
			return (-1);
d496 2
a497 2
		if (error != 0 && ~targetflags & CMD_FIND_QUIET)
			return (-1);
d502 6
@


1.126
log
@Mass rename struct cmd_q to struct cmdq_item and related.
@
text
@d1 1
a1 1
/* $OpenBSD: cmd.c,v 1.125 2016/10/16 17:55:14 nicm Exp $ */
d656 2
a657 2
	const char	*ptr;
	int		 replaced;
d679 11
a689 3
			len += strlen(s);
			buf = xrealloc(buf, len + 1);
			strlcat(buf, s, len + 1);
@


1.125
log
@Rewrite command queue handling. Each client still has a command queue,
but there is also now a global command queue. Instead of command queues
being dispatched on demand from wherever the command happens to be
added, they are now all dispatched from the top level server
loop. Command queues may now also include callbacks as well as commands,
and items may be inserted after the current command as well as at the end.

This all makes command queues significantly more predictable and easier
to use, and avoids the complex multiple nested command queues used by
source-file, if-shell and friends.

A mass rename of struct cmdq to a better name (cmdq_item probably) is
coming.
@
text
@d1 1
a1 1
/* $OpenBSD: cmd.c,v 1.124 2016/10/13 10:01:49 nicm Exp $ */
d393 1
a393 1
    struct cmd_q *cmdq)
d405 1
a405 1
		fs = &cmdq->state.tflag;
d407 1
a407 1
		fs = &cmdq->state.sflag;
d453 1
a453 1
	error = cmd_find_current(&current, cmdq, targetflags);
d468 1
a468 1
		error = cmd_find_target(fs, &current, cmdq, target,
d474 1
a474 1
		error = cmd_find_target(fs, &current, cmdq, target,
d483 1
a483 1
		error = cmd_find_target(fs, &current, cmdq, target,
d491 1
a491 1
		error = cmd_find_target(fs, &current, cmdq, target,
d503 1
a503 1
cmd_prepare_state(struct cmd *cmd, struct cmd_q *cmdq)
d506 1
a506 1
	struct cmd_state	*state = &cmdq->state;
d513 1
a513 1
	log_debug("preparing state for %s (client %p)", tmp, cmdq->client);
d531 1
a531 1
		state->c = cmd_find_client(cmdq, s, 0);
d536 1
a536 1
		state->c = cmd_find_client(cmdq, s, 1);
d544 1
a544 1
	error = cmd_prepare_state_flag('t', s, entry->tflag, cmdq);
d551 1
a551 1
	error = cmd_prepare_state_flag('s', s, entry->sflag, cmdq);
@


1.124
log
@Some improvements and bug fixes for hooks:

- Prepare the state again before the "after" hooks are run, because the
  command may have killed or moved windows.

- Use the hooks list from the newly prepared target, not the old hooks
  list (only matters for new-session really).

- Correctly detect an invalid current state and ignore it in
  cmd_find_target ("killw; swapw").

- Change neww, new, killp, killw, splitw, swapp, swapw to update the
  current state (used if no explicit target is given) to something more
  useful after they have finished. For example, neww changes it to the
  newly created window.

Hooks are still relatively new and primitive so there are likely to be
more changes to come.

Parts based on bug reports from Uwe Werler and Iblis Lin.
@
text
@d1 1
a1 1
/* $OpenBSD: cmd.c,v 1.123 2016/10/05 12:32:13 nicm Exp $ */
d393 1
a393 1
    struct cmd_q *cmdq, struct cmd_q *parent)
d397 1
a397 2
	struct cmd_find_state	*current = NULL;
	struct cmd_find_state	 tmp;
d451 1
d453 4
a456 14
	log_debug("%s: flag %c %d %#x", __func__, c, flag, targetflags);
	if (parent != NULL) {
		if (c == 't')
			current = &parent->state.tflag;
		else if (c == 's')
			current = &parent->state.sflag;
	}
	if (current == NULL || !cmd_find_valid_state(current)) {
		error = cmd_find_current(&tmp, cmdq, targetflags);
		if (error != 0 && ~targetflags & CMD_FIND_QUIET)
			return (-1);
		current = &tmp;
	}
	if (!cmd_find_empty_state(current) && !cmd_find_valid_state(current))
d468 1
a468 1
		error = cmd_find_target(fs, current, cmdq, target,
d474 1
a474 1
		error = cmd_find_target(fs, current, cmdq, target,
d483 1
a483 1
		error = cmd_find_target(fs, current, cmdq, target,
d491 1
a491 1
		error = cmd_find_target(fs, current, cmdq, target,
d503 1
a503 1
cmd_prepare_state(struct cmd *cmd, struct cmd_q *cmdq, struct cmd_q *parent)
d505 6
a510 6
	const struct cmd_entry		*entry = cmd->entry;
	struct cmd_state		*state = &cmdq->state;
	char				*tmp;
	enum cmd_entry_flag		 flag;
	const char			*s;
	int				 error;
d539 1
d544 1
a544 1
	error = cmd_prepare_state_flag('t', s, entry->tflag, cmdq, parent);
d551 1
a551 1
	error = cmd_prepare_state_flag('s', s, entry->sflag, cmdq, parent);
@


1.123
log
@Allow cmd_mouse_at return arguments to be NULL.
@
text
@d1 1
a1 1
/* $OpenBSD: cmd.c,v 1.122 2016/03/01 12:06:07 nicm Exp $ */
d459 2
a460 1
	} else {
d466 2
d563 7
@


1.122
log
@Remove some more unused variables, and use RB_FOREACH_SAFE in
key_bindings_unref_table.
@
text
@d1 1
a1 1
/* $OpenBSD: cmd.c,v 1.121 2016/01/19 16:01:30 nicm Exp $ */
d604 4
a607 2
	*xp = x - wp->xoff;
	*yp = y - wp->yoff;
@


1.121
log
@Split out getting the current state from the target search so it can be
replaced if we already know the current.
@
text
@d1 1
a1 1
/* $OpenBSD: cmd.c,v 1.120 2016/01/19 15:59:12 nicm Exp $ */
a484 1
		flag = CMD_WINDOW_INDEX;
@


1.120
log
@I no longer use my SourceForge address so replace it.
@
text
@d1 1
a1 1
/* $OpenBSD: cmd.c,v 1.119 2015/12/14 23:30:58 nicm Exp $ */
d392 2
a393 2
cmd_prepare_state_flag(struct cmd_find_state *fs, enum cmd_entry_flag flag,
    const char *target, struct cmd_q *cmdq)
d395 14
a408 1
	int	targetflags, error;
d417 1
a418 4
	case CMD_NONE:
	case CMD_CLIENT:
	case CMD_CLIENT_CANFAIL:
		return (0);
a421 2
	case CMD_SESSION_WITHPANE:
		targetflags = 0;
a425 5

		error = cmd_find_target(fs, cmdq, target, CMD_FIND_SESSION,
		    targetflags);
		if (error != 0 && flag != CMD_SESSION_CANFAIL)
			return (-1);
a427 4
		error = cmd_find_target(fs, cmdq, target, CMD_FIND_SESSION,
		    CMD_FIND_QUIET);
		if (error == 0)
			break;
a433 1
		targetflags = 0;
a439 5

		error = cmd_find_target(fs, cmdq, target, CMD_FIND_WINDOW,
		    targetflags);
		if (error != 0 && flag != CMD_WINDOW_CANFAIL)
			return (-1);
a443 1
		targetflags = 0;
d448 4
d453 41
a493 3
		error = cmd_find_target(fs, cmdq, target, CMD_FIND_PANE,
		    targetflags);
		if (error != 0 && flag != CMD_PANE_CANFAIL)
d496 10
d511 1
a511 1
cmd_prepare_state(struct cmd *cmd, struct cmd_q *cmdq)
d551 1
a551 1
	error = cmd_prepare_state_flag(&state->tflag, entry->tflag, s, cmdq);
d558 1
a558 1
	error = cmd_prepare_state_flag(&state->sflag, entry->sflag, s, cmdq);
@


1.119
log
@Use cmd_find_clear_state instead of an extra function doing the same.
@
text
@d1 1
a1 1
/* $OpenBSD: cmd.c,v 1.118 2015/12/14 00:31:54 nicm Exp $ */
d4 1
a4 1
 * Copyright (c) 2007 Nicholas Marriott <nicm@@users.sourceforge.net>
@


1.118
log
@Instead of combined flags for -c, -s, -t, split into different sets
using an enum and simplify the parsing code.
@
text
@d1 1
a1 1
/* $OpenBSD: cmd.c,v 1.117 2015/12/13 21:53:57 nicm Exp $ */
a390 16
static void
cmd_clear_state(struct cmd_state *state)
{
	state->c = NULL;

	state->tflag.s = NULL;
	state->tflag.wl = NULL;
	state->tflag.wp = NULL;
	state->tflag.idx = -1;

	state->sflag.s = NULL;
	state->sflag.wl = NULL;
	state->sflag.wp = NULL;
	state->sflag.idx = -1;
}

d480 3
a482 1
	cmd_clear_state(state);
@


1.117
log
@Use member names in cmd_entry definitions so I stop getting confused
about the order.
@
text
@d1 1
a1 1
/* $OpenBSD: cmd.c,v 1.116 2015/12/13 21:17:37 nicm Exp $ */
a209 4
static void		 cmd_clear_state(struct cmd_state *);
static struct client	*cmd_get_state_client(struct cmd_q *, int);
static int		 cmd_set_state_flag(struct cmd *, struct cmd_q *, char);

d408 2
a409 1
cmd_set_state_flag(struct cmd *cmd, struct cmd_q *cmdq, char c)
d411 18
a428 43
	struct cmd_state	*state = &cmdq->state;
	struct cmd_find_state	*fsf = NULL;
	const char		*flag;
	int			 flags = cmd->entry->flags, everything = 0;
	int			 allflags = 0, targetflags, error;
	struct session		*s;
	struct window		*w;
	struct winlink		*wl;
	struct window_pane	*wp;

	/* Set up state for either -t or -s. */
	if (c == 't') {
		fsf = &cmdq->state.tflag;
		allflags = CMD_ALL_T;
	} else if (c == 's') {
		fsf = &cmdq->state.sflag;
		allflags = CMD_ALL_S;
	}

	/*
	 * If the command wants something and no argument is present, use the
	 * base command instead.
	 */
	flag = args_get(cmd->args, c);
	if (flag == NULL) {
		if ((flags & allflags) == 0)
			return (0); /* doesn't care about flag */
		cmd = cmdq->cmd;
		everything = 1;
		flag = args_get(cmd->args, c);
	}

	/*
	 * If no flag and the current command is allowed to fail, just skip to
	 * fill in as much we can, otherwise continue and fail later if needed.
	 */
	if (flag == NULL && (flags & CMD_CANFAIL))
		goto complete_everything;

	/* Fill in state using command (current or base) flags. */
	if (flags & CMD_PREFERUNATTACHED)
		targetflags = CMD_FIND_PREFER_UNATTACHED;
	else
d430 6
a435 50
	switch (cmd->entry->flags & allflags) {
	case 0:
		break;
	case CMD_SESSION_T|CMD_PANE_T:
	case CMD_SESSION_S|CMD_PANE_S:
		if (flag != NULL && flag[strcspn(flag, ":.")] != '\0') {
			error = cmd_find_target(fsf, cmdq, flag, CMD_FIND_PANE,
			    targetflags);
			if (error != 0)
				return (-1);
		} else {
			error = cmd_find_target(fsf, cmdq, flag,
			    CMD_FIND_SESSION, targetflags);
			if (error != 0)
				return (-1);

			if (flag == NULL) {
				fsf->wl = fsf->s->curw;
				fsf->wp = fsf->s->curw->window->active;
			} else {
				s = fsf->s;
				if ((w = window_find_by_id_str(flag)) != NULL)
					wp = w->active;
				else {
					wp = window_pane_find_by_id_str(flag);
					if (wp != NULL)
						w = wp->window;
				}
				wl = winlink_find_by_window(&s->windows, w);
				if (wl != NULL) {
					fsf->wl = wl;
					fsf->wp = wp;
				}
			}
		}
		break;
	case CMD_MOVEW_R|CMD_INDEX_T:
	case CMD_MOVEW_R|CMD_INDEX_S:
		error = cmd_find_target(fsf, cmdq, flag, CMD_FIND_SESSION,
		    targetflags|CMD_FIND_QUIET);
		if (error != 0) {
			error = cmd_find_target(fsf, cmdq, flag,
			    CMD_FIND_WINDOW, CMD_FIND_WINDOW_INDEX);
			if (error != 0)
				return (-1);
		}
		break;
	case CMD_SESSION_T:
	case CMD_SESSION_S:
		error = cmd_find_target(fsf, cmdq, flag, CMD_FIND_SESSION,
d437 1
a437 1
		if (error != 0)
d440 6
a445 3
	case CMD_WINDOW_MARKED_T:
	case CMD_WINDOW_MARKED_S:
		targetflags |= CMD_FIND_DEFAULT_MARKED;
d447 13
a459 3
	case CMD_WINDOW_T:
	case CMD_WINDOW_S:
		error = cmd_find_target(fsf, cmdq, flag, CMD_FIND_WINDOW,
d461 1
a461 1
		if (error != 0)
d464 10
a473 7
	case CMD_PANE_MARKED_T:
	case CMD_PANE_MARKED_S:
		targetflags |= CMD_FIND_DEFAULT_MARKED;
		/* FALLTHROUGH */
	case CMD_PANE_T:
	case CMD_PANE_S:
		error = cmd_find_target(fsf, cmdq, flag, CMD_FIND_PANE,
d475 1
a475 1
		if (error != 0)
a477 45
	case CMD_INDEX_T:
	case CMD_INDEX_S:
		error = cmd_find_target(fsf, cmdq, flag, CMD_FIND_WINDOW,
		    CMD_FIND_WINDOW_INDEX);
		if (error != 0)
			return (-1);
		break;
	default:
		fatalx("too many -%c for %s", c, cmd->entry->name);
	}

	/*
	 * If this is still the current command, it wants what it asked for and
	 * nothing more. If it's the base command, fill in as much as possible
	 * because the current command may have different flags.
	 */
	if (!everything)
		return (0);

complete_everything:
	if (fsf->s == NULL) {
		if (state->c != NULL)
			fsf->s = state->c->session;
		if (fsf->s == NULL) {
			error = cmd_find_target(fsf, cmdq, NULL,
			    CMD_FIND_SESSION, CMD_FIND_QUIET);
			if (error != 0)
				fsf->s = NULL;
		}
		if (fsf->s == NULL) {
			if (flags & CMD_CANFAIL)
				return (0);
			cmdq_error(cmdq, "no current session");
			return (-1);
		}
	}
	if (fsf->wl == NULL) {
		error = cmd_find_target(fsf, cmdq, flag, CMD_FIND_WINDOW, 0);
		if (error != 0)
			return (-1);
	}
	if (fsf->wp == NULL) {
		error = cmd_find_target(fsf, cmdq, flag, CMD_FIND_PANE, 0);
		if (error != 0)
			return (-1);
a481 18
static struct client *
cmd_get_state_client(struct cmd_q *cmdq, int quiet)
{
	struct cmd	*cmd = cmdq->cmd;
	struct args	*args = cmd->args;

	switch (cmd->entry->flags & (CMD_CLIENT_C|CMD_CLIENT_T)) {
	case 0:
		return (cmd_find_client(cmdq, NULL, 1));
	case CMD_CLIENT_C:
		return (cmd_find_client(cmdq, args_get(args, 'c'), quiet));
	case CMD_CLIENT_T:
		return (cmd_find_client(cmdq, args_get(args, 't'), quiet));
	default:
		fatalx("both -t and -c for %s", cmd->entry->name);
	}
}

d485 6
a490 5
	struct cmd_state	*state = &cmdq->state;
	struct args		*args = cmd->args;
	const char		*cflag, *tflag;
	char			*tmp;
	int			 error, quiet;
d493 1
a493 1
	log_debug("preparing state for: %s (client %p)", tmp, cmdq->client);
a495 1
	/* Start with an empty state. */
d498 5
a502 18
	/* No error messages if can fail. */
	quiet = 0;
	if (cmd->entry->flags & CMD_CLIENT_CANFAIL)
		quiet = 1;

	/*
	 * If the command wants a client and provides -c or -t, use it. If not,
	 * try the base command instead via cmd_get_state_client. No client is
	 * allowed if no flags, otherwise it must be available.
	 */
	switch (cmd->entry->flags & (CMD_CLIENT_C|CMD_CLIENT_T)) {
	case 0:
		state->c = cmd_get_state_client(cmdq, 1);
		break;
	case CMD_CLIENT_C:
		cflag = args_get(args, 'c');
		if (cflag == NULL)
			state->c = cmd_get_state_client(cmdq, quiet);
d504 7
a510 2
			state->c = cmd_find_client(cmdq, cflag, quiet);
		if (!quiet && state->c == NULL)
d513 2
a514 9
	case CMD_CLIENT_T:
		tflag = args_get(args, 't');
		if (tflag == NULL)
			state->c = cmd_get_state_client(cmdq, 0);
		else
			state->c = cmd_find_client(cmdq, tflag, 0);
		state->c = cmd_find_client(cmdq, args_get(args, 't'), quiet);
		if (!quiet && state->c == NULL)
			return (-1);
a515 2
	default:
		fatalx("both -c and -t for %s", cmd->entry->name);
d518 15
a532 4
	error = cmd_set_state_flag(cmd, cmdq, 't');
	if (error == 0)
		error = cmd_set_state_flag(cmd, cmdq, 's');
	return (error);
@


1.116
log
@Actually I thought cmd_get_state_client was unnecessary but it will be
needed.
@
text
@d1 1
a1 1
/* $OpenBSD: cmd.c,v 1.114 2015/12/13 18:27:47 nicm Exp $ */
d356 1
a356 1
	args = args_parse(entry->args_template, argc, argv);
d359 1
a359 1
	if (entry->args_lower != -1 && args->argc < entry->args_lower)
d361 1
a361 1
	if (entry->args_upper != -1 && args->argc > entry->args_upper)
@


1.115
log
@-c needs to be able for fail for display-message.
@
text
@d210 3
a212 2
static void	cmd_clear_state(struct cmd_state *);
static int	cmd_set_state_flag(struct cmd *, struct cmd_q *, char);
d583 18
d606 1
d629 1
a629 1
		state->c = cmd_find_client(cmdq, NULL, 1);
d632 5
a636 1
		state->c = cmd_find_client(cmdq, args_get(args, 'c'), quiet);
d641 5
@


1.114
log
@Remove an unnecessary function.
@
text
@d1 1
a1 1
/* $OpenBSD: cmd.c,v 1.113 2015/12/13 17:58:26 nicm Exp $ */
d588 1
a588 1
	int			 error;
d597 5
d612 2
a613 2
		state->c = cmd_find_client(cmdq, args_get(args, 'c'), 0);
		if (state->c == NULL)
d617 2
a618 2
		state->c = cmd_find_client(cmdq, args_get(args, 't'), 0);
		if (state->c == NULL)
@


1.113
log
@Don't log an error when doing the first check for move-window.
@
text
@d1 1
a1 1
/* $OpenBSD: cmd.c,v 1.112 2015/12/13 17:55:14 nicm Exp $ */
d210 2
a211 3
static void		 cmd_clear_state(struct cmd_state *);
static struct client	*cmd_get_state_client(struct cmd_q *, int);
static int		 cmd_set_state_flag(struct cmd *, struct cmd_q *, char);
a409 18
static struct client *
cmd_get_state_client(struct cmd_q *cmdq, int quiet)
{
	struct cmd	*cmd = cmdq->cmd;
	struct args	*args = cmd->args;

	switch (cmd->entry->flags & (CMD_CLIENT_C|CMD_CLIENT_T)) {
	case 0:
		return (cmd_find_client(cmdq, NULL, 1));
	case CMD_CLIENT_C:
		return (cmd_find_client(cmdq, args_get(args, 'c'), quiet));
	case CMD_CLIENT_T:
		return (cmd_find_client(cmdq, args_get(args, 't'), quiet));
	default:
		fatalx("both -t and -c for %s", cmd->entry->name);
	}
}

a586 1
	const char		*cflag, *tflag;
d604 1
a604 1
		state->c = cmd_get_state_client(cmdq, 1);
d607 1
a607 5
		cflag = args_get(args, 'c');
		if (cflag == NULL)
			state->c = cmd_get_state_client(cmdq, 0);
		else
			state->c = cmd_find_client(cmdq, cflag, 0);
d612 1
a612 5
		tflag = args_get(args, 't');
		if (tflag == NULL)
			state->c = cmd_get_state_client(cmdq, 0);
		else
			state->c = cmd_find_client(cmdq, tflag, 0);
@


1.112
log
@Use struct cmd_find_state directly and remove cmd_state_flag, also
change so that winlink is set even if an index is too.
@
text
@d1 1
a1 1
/* $OpenBSD: cmd.c,v 1.111 2015/12/13 16:44:35 nicm Exp $ */
d515 1
a515 1
		    targetflags);
@


1.111
log
@Change cmd_find_target to use a state struct from the caller.
@
text
@d1 1
a1 1
/* $OpenBSD: cmd.c,v 1.110 2015/12/13 15:32:12 nicm Exp $ */
d433 1
a433 1
	struct cmd_state_flag	*statef = NULL;
a440 1
	struct cmd_find_state	 fs;
d444 1
a444 1
		statef = &cmdq->state.tflag;
d447 1
a447 1
		statef = &cmdq->state.sflag;
d482 1
a482 1
			error = cmd_find_target(&fs, cmdq, flag, CMD_FIND_PANE,
a485 3
			statef->s = fs.s;
			statef->wl = fs.wl;
			statef->wp = fs.wp;
d487 1
a487 1
			error = cmd_find_target(&fs, cmdq, flag,
a490 1
			statef->s = fs.s;
d493 2
a494 2
				statef->wl = statef->s->curw;
				statef->wp = statef->s->curw->window->active;
d496 1
a496 1
				s = statef->s;
d506 2
a507 2
					statef->wl = wl;
					statef->wp = wp;
d514 1
a514 1
		error = cmd_find_target(&fs, cmdq, flag, CMD_FIND_SESSION,
d516 2
a517 4
		if (error == 0)
			statef->s = fs.s;
		else {
			error = cmd_find_target(&fs, cmdq, flag,
a520 2
			statef->s = fs.s;
			statef->idx = fs.idx;
d525 1
a525 1
		error = cmd_find_target(&fs, cmdq, flag, CMD_FIND_SESSION,
a528 1
		statef->s = fs.s;
d536 1
a536 1
		error = cmd_find_target(&fs, cmdq, flag, CMD_FIND_WINDOW,
a539 2
		statef->s = fs.s;
		statef->wl = fs.wl;
d547 1
a547 1
		error = cmd_find_target(&fs, cmdq, flag, CMD_FIND_PANE,
a550 3
		statef->s = fs.s;
		statef->wl = fs.wl;
		statef->wp = fs.wp;
d554 1
a554 1
		error = cmd_find_target(&fs, cmdq, flag, CMD_FIND_WINDOW,
a557 2
		statef->s = fs.s;
		statef->idx = fs.idx;
d572 1
a572 1
	if (statef->s == NULL) {
d574 3
a576 3
			statef->s = state->c->session;
		if (statef->s == NULL) {
			error = cmd_find_target(&fs, cmdq, NULL,
d578 2
a579 2
			if (error == 0)
				statef->s = fs.s;
d581 1
a581 1
		if (statef->s == NULL) {
d588 4
a591 6
	if (statef->wl == NULL) {
		error = cmd_find_target(&fs, cmdq, flag, CMD_FIND_WINDOW, 0);
		if (error != 0) {
			statef->s = fs.s;
			statef->wl = fs.wl;
		}
d593 4
a596 7
	if (statef->wp == NULL) {
		error = cmd_find_target(&fs, cmdq, flag, CMD_FIND_PANE, 0);
		if (error != 0) {
			statef->s = fs.s;
			statef->wl = fs.wl;
			statef->wp = fs.wp;
		}
@


1.110
log
@Remove the cmd_find_{session,window,pane,index} functions (which are
just wrappers around cmd_find_target) and just use cmd_find_target
directly.
@
text
@d1 1
a1 1
/* $OpenBSD: cmd.c,v 1.109 2015/12/13 15:00:37 nicm Exp $ */
d436 1
a436 1
	int			 allflags = 0, targetflags;
d441 1
a441 1
	struct cmd_find_state	*fs;
d483 1
a483 1
			fs = cmd_find_target(cmdq, flag, CMD_FIND_PANE,
d485 1
a485 1
			if (fs == NULL)
d487 3
a489 3
			statef->s = fs->s;
			statef->wl = fs->wl;
			statef->wp = fs->wp;
d491 3
a493 3
			fs = cmd_find_target(cmdq, flag, CMD_FIND_SESSION,
			    targetflags);
			if (fs == NULL)
d495 1
a495 1
			statef->s = fs->s;
d519 4
a522 3
		fs = cmd_find_target(cmdq, flag, CMD_FIND_SESSION, targetflags);
		if (fs != NULL)
			statef->s = fs->s;
d524 3
a526 3
			fs = cmd_find_target(cmdq, flag, CMD_FIND_WINDOW,
			    CMD_FIND_WINDOW_INDEX);
			if (fs == NULL)
d528 2
a529 2
			statef->s = fs->s;
			statef->idx = fs->idx;
d534 3
a536 2
		fs = cmd_find_target(cmdq, flag, CMD_FIND_SESSION, targetflags);
		if (fs == NULL)
d538 1
a538 1
		statef->s = fs->s;
d546 3
a548 2
		fs = cmd_find_target(cmdq, flag, CMD_FIND_WINDOW, targetflags);
		if (fs == NULL)
d550 2
a551 2
		statef->s = fs->s;
		statef->wl = fs->wl;
d559 3
a561 2
		fs = cmd_find_target(cmdq, flag, CMD_FIND_PANE, targetflags);
		if (fs == NULL)
d563 3
a565 3
		statef->s = fs->s;
		statef->wl = fs->wl;
		statef->wp = fs->wp;
d569 1
a569 1
		fs = cmd_find_target(cmdq, flag, CMD_FIND_WINDOW,
d571 1
a571 1
		if (fs == NULL)
d573 2
a574 2
		statef->s = fs->s;
		statef->idx = fs->idx;
d593 4
a596 4
			fs = cmd_find_target(cmdq, NULL, CMD_FIND_SESSION,
			    CMD_FIND_QUIET);
			if (fs != NULL)
				statef->s = fs->s;
d606 4
a609 4
		fs = cmd_find_target(cmdq, flag, CMD_FIND_WINDOW, 0);
		if (fs != NULL) {
			statef->s = fs->s;
			statef->wl = fs->wl;
d613 5
a617 5
		fs = cmd_find_target(cmdq, flag, CMD_FIND_PANE, 0);
		if (fs != NULL) {
			statef->s = fs->s;
			statef->wl = fs->wl;
			statef->wp = fs->wp;
@


1.109
log
@Move logging into cmd_find_target rather than each function.
@
text
@d1 1
a1 1
/* $OpenBSD: cmd.c,v 1.108 2015/12/13 14:32:38 nicm Exp $ */
d436 1
a436 2
	int			 allflags = 0;
	int			 prefer = !!(flags & CMD_PREFERUNATTACHED);
d441 1
d443 1
d473 4
d483 3
a485 3
			statef->wl = cmd_find_pane(cmdq, flag, &statef->s,
			    &statef->wp);
			if (statef->wl == NULL)
d487 3
d491 3
a493 2
			statef->s = cmd_find_session(cmdq, flag, prefer);
			if (statef->s == NULL)
d495 1
a496 1
			s = statef->s;
d498 2
a499 2
				statef->wl = s->curw;
				statef->wp = s->curw->window->active;
d501 1
d519 7
a525 4
		statef->s = cmd_find_session(cmdq, flag, prefer);
		if (statef->s == NULL) {
			statef->idx = cmd_find_index(cmdq, flag, &statef->s);
			if (statef->idx == -2)
d527 2
d533 2
a534 2
		statef->s = cmd_find_session(cmdq, flag, prefer);
		if (statef->s == NULL)
d536 1
d538 4
d544 2
a545 8
		statef->wl = cmd_find_window(cmdq, flag, &statef->s);
		if (statef->wl == NULL)
			return (-1);
		break;
	case CMD_WINDOW_MARKED_T:
	case CMD_WINDOW_MARKED_S:
		statef->wl = cmd_find_window_marked(cmdq, flag, &statef->s);
		if (statef->wl == NULL)
d547 2
d550 4
d556 2
a557 10
		statef->wl = cmd_find_pane(cmdq, flag, &statef->s,
		    &statef->wp);
		if (statef->wl == NULL)
			return (-1);
		break;
	case CMD_PANE_MARKED_T:
	case CMD_PANE_MARKED_S:
		statef->wl = cmd_find_pane_marked(cmdq, flag, &statef->s,
		    &statef->wp);
		if (statef->wl == NULL)
d559 3
d565 3
a567 2
		statef->idx = cmd_find_index(cmdq, flag, &statef->s);
		if (statef->idx == -2)
d569 2
d588 6
a593 2
		if (statef->s == NULL)
			statef->s = cmd_find_current(cmdq);
a596 1

d601 15
a615 5
	if (statef->wl == NULL)
		statef->wl = cmd_find_window(cmdq, flag, &statef->s);
	if (statef->wp == NULL)
		statef->wl = cmd_find_pane(cmdq, flag, &statef->s, &statef->wp);

@


1.108
log
@Instead of every command resolving the target (-t or -s) itself, prepare
the state (client, session, winlink, pane) for it it before entering the
command. Each command provides some flags that tell the prepare step
what it is expecting.

This is a requirement for having hooks on commands (for example, if you
hook "select-window -t1:2", the hook command should to operate on window
1:2 not whatever it thinks is the current window), and should allow some
other target improvements.

The old cmd_find_* functions remain for the moment but that layer will
be dropped later.

Joint work with Thomas Adam.
@
text
@d1 1
a1 1
/* $OpenBSD: cmd.c,v 1.107 2015/12/08 01:10:31 nicm Exp $ */
d541 1
a542 1
	case CMD_PANE_MARKED_T:
d598 1
a598 2
	log_debug("preparing state for: %s (client %d)", tmp,
	    cmdq->client != NULL ? cmdq->client->fd : -1);
@


1.107
log
@Add hooks infrastructure, basic commands (set-hook, show-hooks) and a
couple of not very useful client hooks. This will eventually let
commands be run at various points and on notifications. Joint work with
Thomas Adam.
@
text
@d1 1
a1 1
/* $OpenBSD: cmd.c,v 1.106 2015/11/27 15:06:43 nicm Exp $ */
d210 4
d393 247
@


1.106
log
@Do not set a limit on the length of commands when printing them.
@
text
@d1 1
a1 1
/* $OpenBSD: cmd.c,v 1.105 2015/09/01 09:48:34 nicm Exp $ */
d99 1
d104 1
d188 1
d193 1
@


1.105
log
@All the cmd_*_entry declarations do not need to be in tmux.h.
@
text
@d1 1
a1 1
/* $OpenBSD: cmd.c,v 1.104 2015/04/27 16:25:57 nicm Exp $ */
d387 2
a388 2
size_t
cmd_print(struct cmd *cmd, char *buf, size_t len)
d390 8
a397 1
	size_t	off, used;
d399 1
a399 10
	off = xsnprintf(buf, len, "%s ", cmd->entry->name);
	if (off + 1 < len) {
		used = args_print(cmd->args, buf + off, len - off - 1);
		if (used == 0)
			off--;
		else
			off += used;
		buf[off] = '\0';
	}
	return (off);
@


1.104
log
@Rewrite of the target resolution internals to be simpler and more
consistent but with much less duplication, but keeping the same internal
API. Also adds more readable aliases for some of the special tokens used
in targets (eg "{start}" instead of "^"). Some behaviours may have
changed, for example prefix matches now happen before fnmatch.
@
text
@d1 1
a1 1
/* $OpenBSD: cmd.c,v 1.103 2015/04/25 18:33:59 nicm Exp $ */
d30 87
@


1.103
log
@Make message log a TAILQ.
@
text
@d1 1
a1 1
/* $OpenBSD: cmd.c,v 1.102 2015/04/25 18:09:28 nicm Exp $ */
a118 18
ARRAY_DECL(client_list, struct client *);
ARRAY_DECL(sessionslist, struct session *);

int		 cmd_session_better(struct session *, struct session *, int);
struct session	*cmd_choose_session_list(struct sessionslist *);
struct session	*cmd_choose_session(int);
struct client	*cmd_choose_client(struct client_list *);
struct client	*cmd_lookup_client(const char *);
struct session	*cmd_lookup_session(struct cmd_q *, const char *, int *);
struct winlink	*cmd_lookup_window(struct session *, const char *, int *);
int		 cmd_lookup_index(struct session *, const char *, int *);
struct winlink	*cmd_lookup_winlink_windowid(struct session *, const char *);
struct session	*cmd_window_session(struct cmd_q *, struct window *,
		    struct winlink **);
struct winlink	*cmd_find_window_offset(const char *, struct session *, int *);
int		 cmd_find_index_offset(const char *, struct session *, int *);
struct window_pane *cmd_find_pane_offset(const char *, struct winlink *);

a316 177
/*
 * Figure out the current session. Use: 1) the current session, if the command
 * context has one; 2) the most recently used session containing the pty of the
 * calling client, if any; 3) the session specified in the TMUX variable from
 * the environment (as passed from the client); 4) the most recently used
 * session from all sessions.
 */
struct session *
cmd_current_session(struct cmd_q *cmdq, int prefer_unattached)
{
	struct client		*c = cmdq->client;
	struct session		*s;
	struct sessionslist	 ss;
	struct winlink		*wl;
	struct window_pane	*wp;
	const char		*path;
	int			 found;

	/* Try the queue session. */
	if (c != NULL && c->session != NULL)
		return (c->session);

	/*
	 * If the name of the calling client's pty is known, build a list of
	 * the sessions that contain it and if any choose either the first or
	 * the newest.
	 */
	path = c == NULL ? NULL : c->tty.path;
	if (path != NULL) {
		ARRAY_INIT(&ss);
		RB_FOREACH(s, sessions, &sessions) {
			found = 0;
			RB_FOREACH(wl, winlinks, &s->windows) {
				TAILQ_FOREACH(wp, &wl->window->panes, entry) {
					if (strcmp(wp->tty, path) == 0) {
						found = 1;
						break;
					}
				}
				if (found)
					break;
			}
			if (found)
				ARRAY_ADD(&ss, s);
		}

		s = cmd_choose_session_list(&ss);
		ARRAY_FREE(&ss);
		if (s != NULL)
			return (s);
	}

	return (cmd_choose_session(prefer_unattached));
}

/* Is this session better? */
int
cmd_session_better(struct session *s, struct session *best,
    int prefer_unattached)
{
	if (best == NULL)
		return (1);
	if (prefer_unattached) {
		if (!(best->flags & SESSION_UNATTACHED) &&
		    (s->flags & SESSION_UNATTACHED))
			return (1);
		else if ((best->flags & SESSION_UNATTACHED) &&
		    !(s->flags & SESSION_UNATTACHED))
			return (0);
	}
	return (timercmp(&s->activity_time, &best->activity_time, >));
}

/*
 * Find the most recently used session, preferring unattached if the flag is
 * set.
 */
struct session *
cmd_choose_session(int prefer_unattached)
{
	struct session	*s, *best;

	best = NULL;
	RB_FOREACH(s, sessions, &sessions) {
		if (cmd_session_better(s, best, prefer_unattached))
			best = s;
	}
	return (best);
}

/* Find the most recently used session from a list. */
struct session *
cmd_choose_session_list(struct sessionslist *ss)
{
	struct session	*s, *sbest;
	struct timeval	*tv = NULL;
	u_int		 i;

	sbest = NULL;
	for (i = 0; i < ARRAY_LENGTH(ss); i++) {
		if ((s = ARRAY_ITEM(ss, i)) == NULL)
			continue;

		if (tv == NULL || timercmp(&s->activity_time, tv, >)) {
			sbest = s;
			tv = &s->activity_time;
		}
	}

	return (sbest);
}

/*
 * Find the current client. First try the current client if set, then pick the
 * most recently used of the clients attached to the current session if any,
 * then of all clients.
 */
struct client *
cmd_current_client(struct cmd_q *cmdq)
{
	struct session		*s;
	struct client		*c;
	struct client_list	 cc;

	if (cmdq->client != NULL && cmdq->client->session != NULL)
		return (cmdq->client);

	/*
	 * No current client set. Find the current session and return the
	 * newest of its clients.
	 */
	s = cmd_current_session(cmdq, 0);
	if (s != NULL && !(s->flags & SESSION_UNATTACHED)) {
		ARRAY_INIT(&cc);
		TAILQ_FOREACH(c, &clients, entry) {
			if (s == c->session)
				ARRAY_ADD(&cc, c);
		}

		c = cmd_choose_client(&cc);
		ARRAY_FREE(&cc);
		if (c != NULL)
			return (c);
	}

	ARRAY_INIT(&cc);
	TAILQ_FOREACH(c, &clients, entry)
		ARRAY_ADD(&cc, c);
	c = cmd_choose_client(&cc);
	ARRAY_FREE(&cc);
	return (c);
}

/* Choose the most recently used client from a list. */
struct client *
cmd_choose_client(struct client_list *cc)
{
	struct client	*c, *cbest;
	struct timeval	*tv = NULL;
	u_int		 i;

	cbest = NULL;
	for (i = 0; i < ARRAY_LENGTH(cc); i++) {
		if ((c = ARRAY_ITEM(cc, i)) == NULL)
			continue;
		if (c->session == NULL)
			continue;

		if (tv == NULL || timercmp(&c->activity_time, tv, >)) {
			cbest = c;
			tv = &c->activity_time;
		}
	}

	return (cbest);
}

d368 2
a369 1
cmd_mouse_pane(struct mouse_event *m, struct session **sp, struct winlink **wlp)
a382 739
	return (wp);
}

/* Find the target client or report an error and return NULL. */
struct client *
cmd_find_client(struct cmd_q *cmdq, const char *arg, int quiet)
{
	struct client	*c;
	char		*tmparg;
	size_t		 arglen;

	/* A NULL argument means the current client. */
	if (arg == NULL) {
		c = cmd_current_client(cmdq);
		if (c == NULL && !quiet)
			cmdq_error(cmdq, "no clients");
		return (c);
	}
	tmparg = xstrdup(arg);

	/* Trim a single trailing colon if any. */
	arglen = strlen(tmparg);
	if (arglen != 0 && tmparg[arglen - 1] == ':')
		tmparg[arglen - 1] = '\0';

	/* Find the client, if any. */
	c = cmd_lookup_client(tmparg);

	/* If no client found, report an error. */
	if (c == NULL && !quiet)
		cmdq_error(cmdq, "client not found: %s", tmparg);

	free(tmparg);
	return (c);
}

/*
 * Lookup a client by device path. Either of a full match and a match without a
 * leading _PATH_DEV ("/dev/") is accepted.
 */
struct client *
cmd_lookup_client(const char *name)
{
	struct client	*c;
	const char	*path;

	TAILQ_FOREACH(c, &clients, entry) {
		if (c->session == NULL || c->tty.path == NULL)
			continue;
		path = c->tty.path;

		/* Check for exact matches. */
		if (strcmp(name, path) == 0)
			return (c);

		/* Check without leading /dev if present. */
		if (strncmp(path, _PATH_DEV, (sizeof _PATH_DEV) - 1) != 0)
			continue;
		if (strcmp(name, path + (sizeof _PATH_DEV) - 1) == 0)
			return (c);
	}

	return (NULL);
}

/* Lookup a session by name. If no session is found, NULL is returned. */
struct session *
cmd_lookup_session(struct cmd_q *cmdq, const char *name, int *ambiguous)
{
	struct session		*s, *sfound;
	struct window		*w;
	struct window_pane	*wp;

	*ambiguous = 0;

	/* Look for $id first. */
	if ((s = session_find_by_id_str(name)) != NULL)
		return (s);

	/* Try as pane or window id. */
	if ((wp = window_pane_find_by_id_str(name)) != NULL)
		return (cmd_window_session(cmdq, wp->window, NULL));
	if ((w = window_find_by_id_str(name)) != NULL)
		return (cmd_window_session(cmdq, w, NULL));

	/*
	 * Look for matches. First look for exact matches - session names must
	 * be unique so an exact match can't be ambigious and can just be
	 * returned.
	 */
	if ((s = session_find(name)) != NULL)
		return (s);

	/*
	 * Otherwise look for partial matches, returning early if it is found to
	 * be ambiguous.
	 */
	sfound = NULL;
	RB_FOREACH(s, sessions, &sessions) {
		if (strncmp(name, s->name, strlen(name)) == 0 ||
		    fnmatch(name, s->name, 0) == 0) {
			if (sfound != NULL) {
				*ambiguous = 1;
				return (NULL);
			}
			sfound = s;
		}
	}
	return (sfound);
}

/*
 * Lookup a window or return -1 if not found or ambigious. First try as an
 * index and if invalid, use fnmatch or leading prefix. Return NULL but fill in
 * idx if the window index is a valid number but there is no window with that
 * index.
 */
struct winlink *
cmd_lookup_window(struct session *s, const char *name, int *ambiguous)
{
	struct winlink		*wl, *wlfound;
	struct window		*w;
	struct window_pane	*wp;
	const char		*errstr;
	u_int			 idx;

	*ambiguous = 0;

	/* Try as pane or window id. */
	if ((wl = cmd_lookup_winlink_windowid(s, name)) != NULL)
	    return (wl);

	/* Lookup as pane or window id. */
	if ((wp = window_pane_find_by_id_str(name)) != NULL) {
		wl = winlink_find_by_window(&s->windows, wp->window);
		if (wl != NULL)
			return (wl);
	}
	if ((w = window_find_by_id_str(name)) != NULL) {
		wl = winlink_find_by_window(&s->windows, w);
		if (wl != NULL)
			return (wl);
	}

	/* First see if this is a valid window index in this session. */
	idx = strtonum(name, 0, INT_MAX, &errstr);
	if (errstr == NULL) {
		if ((wl = winlink_find_by_index(&s->windows, idx)) != NULL)
			return (wl);
	}

	/* Look for exact matches, error if more than one. */
	wlfound = NULL;
	RB_FOREACH(wl, winlinks, &s->windows) {
		if (strcmp(name, wl->window->name) == 0) {
			if (wlfound != NULL) {
				*ambiguous = 1;
				return (NULL);
			}
			wlfound = wl;
		}
	}
	if (wlfound != NULL)
		return (wlfound);

	/* Now look for pattern matches, again error if multiple. */
	wlfound = NULL;
	RB_FOREACH(wl, winlinks, &s->windows) {
		if (strncmp(name, wl->window->name, strlen(name)) == 0 ||
		    fnmatch(name, wl->window->name, 0) == 0) {
			if (wlfound != NULL) {
				*ambiguous = 1;
				return (NULL);
			}
			wlfound = wl;
		}
	}
	if (wlfound != NULL)
		return (wlfound);

	return (NULL);
}

/*
 * Find a window index - if the window doesn't exist, check if it is a
 * potential index and return it anyway.
 */
int
cmd_lookup_index(struct session *s, const char *name, int *ambiguous)
{
	struct winlink	*wl;
	const char	*errstr;
	u_int		 idx;

	idx = strtonum(name, 0, INT_MAX, &errstr);
	if (errstr == NULL)
		return (idx);

	if ((wl = cmd_lookup_window(s, name, ambiguous)) != NULL)
		return (wl->idx);
	if (*ambiguous)
		return (-1);

	return (-1);
}

/* Lookup window id in a session. An initial @@ means a window id. */
struct winlink *
cmd_lookup_winlink_windowid(struct session *s, const char *arg)
{
	const char	*errstr;
	u_int		 windowid;

	if (*arg != '@@')
		return (NULL);

	windowid = strtonum(arg + 1, 0, UINT_MAX, &errstr);
	if (errstr != NULL)
		return (NULL);
	return (winlink_find_by_window_id(&s->windows, windowid));
}

/* Find session and winlink for window. */
struct session *
cmd_window_session(struct cmd_q *cmdq, struct window *w, struct winlink **wlp)
{
	struct session		*s;
	struct sessionslist	 ss;
	struct winlink		*wl;

	/* If this window is in the current session, return that winlink. */
	s = cmd_current_session(cmdq, 0);
	if (s != NULL) {
		wl = winlink_find_by_window(&s->windows, w);
		if (wl != NULL) {
			if (wlp != NULL)
				*wlp = wl;
			return (s);
		}
	}

	/* Otherwise choose from all sessions with this window. */
	ARRAY_INIT(&ss);
	RB_FOREACH(s, sessions, &sessions) {
		if (winlink_find_by_window(&s->windows, w) != NULL)
			ARRAY_ADD(&ss, s);
	}
	s = cmd_choose_session_list(&ss);
	ARRAY_FREE(&ss);
	if (wlp != NULL)
		*wlp = winlink_find_by_window(&s->windows, w);
	return (s);
}

/* Find the target session or report an error and return NULL. */
struct session *
cmd_find_session(struct cmd_q *cmdq, const char *arg, int prefer_unattached)
{
	struct session	*s;
	struct client	*c;
	char		*tmparg;
	size_t		 arglen;
	int		 ambiguous;

	/* A NULL argument means the current session. */
	if (arg == NULL) {
		if ((s = cmd_current_session(cmdq, prefer_unattached)) == NULL)
			cmdq_error(cmdq, "can't establish current session");
		return (s);
	}

	/* Trim a single trailing colon if any. */
	tmparg = xstrdup(arg);
	arglen = strlen(tmparg);
	if (arglen != 0 && tmparg[arglen - 1] == ':')
		tmparg[arglen - 1] = '\0';

	/* An empty session name is the current session. */
	if (*tmparg == '\0') {
		free(tmparg);
		if ((s = cmd_current_session(cmdq, prefer_unattached)) == NULL)
			cmdq_error(cmdq, "can't establish current session");
		return (s);
	}

	/* Find the session, if any. */
	s = cmd_lookup_session(cmdq, tmparg, &ambiguous);

	/* If it doesn't, try to match it as a client. */
	if (s == NULL && (c = cmd_lookup_client(tmparg)) != NULL)
		s = c->session;

	/* If no session found, report an error. */
	if (s == NULL) {
		if (ambiguous)
			cmdq_error(cmdq, "more than one session: %s", tmparg);
		else
			cmdq_error(cmdq, "session not found: %s", tmparg);
	}

	free(tmparg);
	return (s);
}

/* Find the target session and window or report an error and return NULL. */
struct winlink *
cmd_find_window(struct cmd_q *cmdq, const char *arg, struct session **sp)
{
	struct session	*s;
	struct winlink	*wl;
	const char	*winptr;
	char		*sessptr = NULL;
	int		 ambiguous = 0;

	/*
	 * Find the current session. There must always be a current session, if
	 * it can't be found, report an error.
	 */
	if ((s = cmd_current_session(cmdq, 0)) == NULL) {
		cmdq_error(cmdq, "can't establish current session");
		return (NULL);
	}

	/* A NULL argument means the current session and window. */
	if (arg == NULL) {
		if (sp != NULL)
			*sp = s;
		return (s->curw);
	}

	/* Time to look at the argument. If it is empty, that is an error. */
	if (*arg == '\0')
		goto not_found;

	/* Find the separating colon and split into window and session. */
	winptr = strchr(arg, ':');
	if (winptr == NULL)
		goto no_colon;
	winptr++;	/* skip : */
	sessptr = xstrdup(arg);
	*strchr(sessptr, ':') = '\0';

	/* Try to lookup the session if present. */
	if (*sessptr != '\0') {
		if ((s = cmd_lookup_session(cmdq, sessptr, &ambiguous)) == NULL)
			goto no_session;
	}
	if (sp != NULL)
		*sp = s;

	/*
	 * Then work out the window. An empty string is the current window,
	 * otherwise try special cases then to look it up in the session.
	 */
	if (*winptr == '\0')
		wl = s->curw;
	else if (winptr[0] == '!' && winptr[1] == '\0')
		wl = TAILQ_FIRST(&s->lastw);
	else if (winptr[0] == '^' && winptr[1] == '\0')
		wl = RB_MIN(winlinks, &s->windows);
	else if (winptr[0] == '$' && winptr[1] == '\0')
		wl = RB_MAX(winlinks, &s->windows);
	else if (winptr[0] == '+' || winptr[0] == '-')
		wl = cmd_find_window_offset(winptr, s, &ambiguous);
	else
		wl = cmd_lookup_window(s, winptr, &ambiguous);
	if (wl == NULL)
		goto not_found;

	if (sessptr != NULL)
		free(sessptr);
	return (wl);

no_colon:
	/*
	 * No colon in the string, first try special cases, then as a window
	 * and lastly as a session.
	 */
	if (arg[0] == '=' && arg[1] == '\0') {
		if ((wl = cmd_mouse_window(&cmdq->item->mouse, &s)) == NULL) {
			cmdq_error(cmdq, "no mouse target");
			goto error;
		}
	} else if (arg[0] == '!' && arg[1] == '\0') {
		if ((wl = TAILQ_FIRST(&s->lastw)) == NULL)
			goto not_found;
	} else if (arg[0] == '+' || arg[0] == '-') {
		if ((wl = cmd_find_window_offset(arg, s, &ambiguous)) == NULL)
			goto lookup_session;
	} else if ((wl = cmd_lookup_window(s, arg, &ambiguous)) == NULL)
		goto lookup_session;

	if (sp != NULL)
		*sp = s;

	return (wl);

lookup_session:
	if (ambiguous)
		goto not_found;
	if (*arg != '\0' &&
	    (s = cmd_lookup_session(cmdq, arg, &ambiguous)) == NULL)
		goto no_session;

	if (sp != NULL)
		*sp = s;

	return (s->curw);

no_session:
	if (ambiguous)
		cmdq_error(cmdq, "multiple sessions: %s", arg);
	else
		cmdq_error(cmdq, "session not found: %s", arg);
	goto error;

not_found:
	if (ambiguous)
		cmdq_error(cmdq, "multiple windows: %s", arg);
	else
		cmdq_error(cmdq, "window not found: %s", arg);
	goto error;

error:
	free(sessptr);
	return (NULL);
}

struct winlink *
cmd_find_window_offset(const char *winptr, struct session *s, int *ambiguous)
{
	struct winlink	*wl;
	int		 offset = 1;

	if (winptr[1] != '\0')
		offset = strtonum(winptr + 1, 1, INT_MAX, NULL);
	if (offset == 0)
		wl = cmd_lookup_window(s, winptr, ambiguous);
	else {
		if (winptr[0] == '+')
			wl = winlink_next_by_number(s->curw, s, offset);
		else
			wl = winlink_previous_by_number(s->curw, s, offset);
	}

	return (wl);
}

/*
 * Find the target session and window index, whether or not it exists in the
 * session. Return -2 on error or -1 if no window index is specified. This is
 * used when parsing an argument for a window target that may not exist (for
 * example if it is going to be created).
 */
int
cmd_find_index(struct cmd_q *cmdq, const char *arg, struct session **sp)
{
	struct session	*s;
	struct winlink	*wl;
	const char	*winptr;
	char		*sessptr = NULL;
	int		 idx, ambiguous = 0;

	/*
	 * Find the current session. There must always be a current session, if
	 * it can't be found, report an error.
	 */
	if ((s = cmd_current_session(cmdq, 0)) == NULL) {
		cmdq_error(cmdq, "can't establish current session");
		return (-2);
	}

	/* A NULL argument means the current session and "no window" (-1). */
	if (arg == NULL) {
		if (sp != NULL)
			*sp = s;
		return (-1);
	}

	/* Time to look at the argument. If it is empty, that is an error. */
	if (*arg == '\0')
		goto not_found;

	/* Find the separating colon. If none, assume the current session. */
	winptr = strchr(arg, ':');
	if (winptr == NULL)
		goto no_colon;
	winptr++;	/* skip : */
	sessptr = xstrdup(arg);
	*strchr(sessptr, ':') = '\0';

	/* Try to lookup the session if present. */
	if (sessptr != NULL && *sessptr != '\0') {
		if ((s = cmd_lookup_session(cmdq, sessptr, &ambiguous)) == NULL)
			goto no_session;
	}
	if (sp != NULL)
		*sp = s;

	/*
	 * Then work out the window. An empty string is a new window otherwise
	 * try to look it up in the session.
	 */
	if (*winptr == '\0')
		idx = -1;
	else if (winptr[0] == '!' && winptr[1] == '\0') {
		if ((wl = TAILQ_FIRST(&s->lastw)) == NULL)
			goto not_found;
		idx = wl->idx;
	} else if (winptr[0] == '+' || winptr[0] == '-') {
		if ((idx = cmd_find_index_offset(winptr, s, &ambiguous)) < 0)
			goto invalid_index;
	} else if ((idx = cmd_lookup_index(s, winptr, &ambiguous)) == -1)
		goto invalid_index;

	free(sessptr);
	return (idx);

no_colon:
	/*
	 * No colon in the string, first try special cases, then as a window
	 * and lastly as a session.
	 */
	if (arg[0] == '!' && arg[1] == '\0') {
		if ((wl = TAILQ_FIRST(&s->lastw)) == NULL)
			goto not_found;
		idx = wl->idx;
	} else if (arg[0] == '+' || arg[0] == '-') {
		if ((idx = cmd_find_index_offset(arg, s, &ambiguous)) < 0)
			goto lookup_session;
	} else if ((idx = cmd_lookup_index(s, arg, &ambiguous)) == -1)
		goto lookup_session;

	if (sp != NULL)
		*sp = s;

	return (idx);

lookup_session:
	if (ambiguous)
		goto not_found;
	if (*arg != '\0' &&
	    (s = cmd_lookup_session(cmdq, arg, &ambiguous)) == NULL)
		goto no_session;

	if (sp != NULL)
		*sp = s;

	return (-1);

no_session:
	if (ambiguous)
		cmdq_error(cmdq, "multiple sessions: %s", arg);
	else
		cmdq_error(cmdq, "session not found: %s", arg);
	free(sessptr);
	return (-2);

invalid_index:
	if (ambiguous)
		goto not_found;
	cmdq_error(cmdq, "invalid index: %s", arg);

	free(sessptr);
	return (-2);

not_found:
	if (ambiguous)
		cmdq_error(cmdq, "multiple windows: %s", arg);
	else
		cmdq_error(cmdq, "window not found: %s", arg);
	free(sessptr);
	return (-2);
}

int
cmd_find_index_offset(const char *winptr, struct session *s, int *ambiguous)
{
	int	idx, offset = 1;

	if (winptr[1] != '\0')
		offset = strtonum(winptr + 1, 1, INT_MAX, NULL);
	if (offset == 0)
		idx = cmd_lookup_index(s, winptr, ambiguous);
	else {
		if (winptr[0] == '+') {
			if (s->curw->idx == INT_MAX)
				idx = cmd_lookup_index(s, winptr, ambiguous);
			else
				idx = s->curw->idx + offset;
		} else {
			if (s->curw->idx == 0)
				idx = cmd_lookup_index(s, winptr, ambiguous);
			else
				idx = s->curw->idx - offset;
		}
	}

	return (idx);
}

/*
 * Find the target session, window and pane number or report an error and
 * return NULL. The pane number is separated from the session:window by a .,
 * such as mysession:mywindow.0.
 */
struct winlink *
cmd_find_pane(struct cmd_q *cmdq,
    const char *arg, struct session **sp, struct window_pane **wpp)
{
	struct session	*s;
	struct winlink	*wl;
	const char	*period, *errstr;
	char		*winptr, *paneptr;
	u_int		 idx;

	/* Get the current session. */
	if ((s = cmd_current_session(cmdq, 0)) == NULL) {
		cmdq_error(cmdq, "can't establish current session");
		return (NULL);
	}
	if (sp != NULL)
		*sp = s;

	/* A NULL argument means the current session, window and pane. */
	if (arg == NULL) {
		*wpp = s->curw->window->active;
		return (s->curw);
	}

	/* Lookup as pane id. */
	if ((*wpp = window_pane_find_by_id_str(arg)) != NULL) {
		s = cmd_window_session(cmdq, (*wpp)->window, &wl);
		if (sp != NULL)
			*sp = s;
		return (wl);
	}

	/* Look for a separating period. */
	if ((period = strrchr(arg, '.')) == NULL)
		goto no_period;

	/* Pull out the window part and parse it. */
	winptr = xstrdup(arg);
	winptr[period - arg] = '\0';
	if (*winptr == '\0')
		wl = s->curw;
	else if ((wl = cmd_find_window(cmdq, winptr, sp)) == NULL)
		goto error;

	/* Find the pane section and look it up. */
	paneptr = winptr + (period - arg) + 1;
	if (*paneptr == '\0')
		*wpp = wl->window->active;
	else if (paneptr[0] == '+' || paneptr[0] == '-')
		*wpp = cmd_find_pane_offset(paneptr, wl);
	else if (paneptr[0] == '!' && paneptr[1] == '\0') {
		if (wl->window->last == NULL) {
			cmdq_error(cmdq, "no last pane");
			goto error;
		}
		*wpp = wl->window->last;
	} else {
		idx = strtonum(paneptr, 0, INT_MAX, &errstr);
		if (errstr != NULL)
			goto lookup_string;
		*wpp = window_pane_at_index(wl->window, idx);
		if (*wpp == NULL)
			goto lookup_string;
	}

	free(winptr);
	return (wl);

lookup_string:
	/* Try pane string description. */
	if ((*wpp = window_find_string(wl->window, paneptr)) == NULL) {
		cmdq_error(cmdq, "can't find pane: %s", paneptr);
		goto error;
	}

	free(winptr);
	return (wl);

no_period:
	/* Check mouse event. */
	if (arg[0] == '=' && arg[1] == '\0') {
		*wpp = cmd_mouse_pane(&cmdq->item->mouse, &s, &wl);
		if (*wpp == NULL) {
			cmdq_error(cmdq, "no mouse target");
			return (NULL);
		}
		if (sp != NULL)
			*sp = s;
		return (wl);
	}

	/* Try as a pane number alone. */
	idx = strtonum(arg, 0, INT_MAX, &errstr);
	if (errstr != NULL)
		goto lookup_window;

	/* Try index in the current session and window. */
	if ((*wpp = window_pane_at_index(s->curw->window, idx)) == NULL)
		goto lookup_window;

	return (s->curw);

lookup_window:
	/* Try pane string description. */
	if ((*wpp = window_find_string(s->curw->window, arg)) != NULL)
		return (s->curw);

	/* Try as a window and use the active pane. */
	if ((wl = cmd_find_window(cmdq, arg, sp)) != NULL)
		*wpp = wl->window->active;
	return (wl);

error:
	free(winptr);
	return (NULL);
}

struct window_pane *
cmd_find_pane_offset(const char *paneptr, struct winlink *wl)
{
	struct window		*w = wl->window;
	struct window_pane	*wp = w->active;
	u_int			 offset = 1;

	if (paneptr[1] != '\0')
		offset = strtonum(paneptr + 1, 1, INT_MAX, NULL);
	if (offset > 0) {
		if (paneptr[0] == '+')
			wp = window_pane_next_by_number(w, wp, offset);
		else
			wp = window_pane_previous_by_number(w, wp, offset);
	}

@


1.102
log
@Move the functions to convert ids from strings into session.c and window.c.
@
text
@d1 1
a1 1
/* $OpenBSD: cmd.c,v 1.101 2015/04/24 23:17:11 nicm Exp $ */
d120 1
@


1.101
log
@Convert clients list into a TAILQ.
@
text
@d1 1
a1 1
/* $OpenBSD: cmd.c,v 1.100 2015/04/21 22:42:27 nicm Exp $ */
a126 1
struct session	*cmd_lookup_session_id(const char *);
a640 15
/* Find the target session or report an error and return NULL. */
struct session *
cmd_lookup_session_id(const char *arg)
{
	char	*endptr;
	long	 id;

	if (arg[0] != '$')
		return (NULL);
	id = strtol(arg + 1, &endptr, 10);
	if (arg[1] != '\0' && *endptr == '\0')
		return (session_find_by_id(id));
	return (NULL);
}

d652 1
a652 1
	if ((s = cmd_lookup_session_id(name)) != NULL)
d656 1
a656 1
	if ((wp = cmd_lookup_paneid(name)) != NULL)
d658 1
a658 1
	if ((w = cmd_lookup_windowid(name)) != NULL)
d709 1
a709 1
	if ((wp = cmd_lookup_paneid(name)) != NULL) {
d714 1
a714 1
	if ((w = cmd_lookup_windowid(name)) != NULL) {
a781 16
/* Lookup pane id. An initial % means a pane id. */
struct window_pane *
cmd_lookup_paneid(const char *arg)
{
	const char	*errstr;
	u_int		 paneid;

	if (*arg != '%')
		return (NULL);

	paneid = strtonum(arg + 1, 0, UINT_MAX, &errstr);
	if (errstr != NULL)
		return (NULL);
	return (window_pane_find_by_id(paneid));
}

a797 16
/* Lookup window id. An initial @@ means a window id. */
struct window *
cmd_lookup_windowid(const char *arg)
{
	const char	*errstr;
	u_int		 windowid;

	if (*arg != '@@')
		return (NULL);

	windowid = strtonum(arg + 1, 0, UINT_MAX, &errstr);
	if (errstr != NULL)
		return (NULL);
	return (window_find_by_id(windowid));
}

d1207 1
a1207 1
	if ((*wpp = cmd_lookup_paneid(arg)) != NULL) {
@


1.100
log
@Look up indexes as number before name, makes more sense if windows are
named starting with numbers. From Thomas Adam.
@
text
@d1 1
a1 1
/* $OpenBSD: cmd.c,v 1.99 2015/04/19 21:34:21 nicm Exp $ */
d119 2
d124 1
a124 1
struct client	*cmd_choose_client(struct clients *);
d457 1
a457 2
	struct clients		 cc;
	u_int			 i;
d469 1
a469 3
		for (i = 0; i < ARRAY_LENGTH(&clients); i++) {
			if ((c = ARRAY_ITEM(&clients, i)) == NULL)
				continue;
d480 6
a485 1
	return (cmd_choose_client(&clients));
d490 1
a490 1
cmd_choose_client(struct clients *cc)
a621 1
	u_int		 i;
d623 2
a624 3
	for (i = 0; i < ARRAY_LENGTH(&clients); i++) {
		c = ARRAY_ITEM(&clients, i);
		if (c == NULL || c->session == NULL || c->tty.path == NULL)
@


1.99
log
@Rewrite of tmux mouse support which was a mess. Instead of having
options for "mouse-this" and "mouse-that", mouse events may be bound as
keys and there is one option "mouse" that turns on mouse support
entirely (set -g mouse on).

See the new MOUSE SUPPORT section of the man page for description of the
key names and new flags (-t= to specify the pane or window under mouse
as a target, and send-keys -M to pass through a mouse event).

The default builtin bindings for the mouse are:

    bind -n   MouseDown1Pane select-pane -t=; send-keys -M
    bind -n MouseDown1Status select-window -t=
    bind -n   MouseDrag1Pane copy-mode -M
    bind -n MouseDrag1Border resize-pane -M

To get the effect of turning mode-mouse off, do:

    unbind -n MouseDrag1Pane
    unbind -temacs-copy MouseDrag1Pane

The old mouse options are now gone, set-option -q may be used to
suppress warnings if mixing configuration files.
@
text
@d1 1
a1 1
/* $OpenBSD: cmd.c,v 1.98 2014/10/08 17:35:58 nicm Exp $ */
d784 4
a791 4

	idx = strtonum(name, 0, INT_MAX, &errstr);
	if (errstr == NULL)
		return (idx);
@


1.98
log
@Add xreallocarray and remove nmemb argument from xrealloc.
@
text
@d1 1
a1 1
/* $OpenBSD: cmd.c,v 1.97 2014/09/25 12:51:40 nicm Exp $ */
d351 1
d508 68
d1000 6
a1005 1
	if (arg[0] == '!' && arg[1] == '\0') {
d1036 1
a1036 2
	free(sessptr);
	return (NULL);
d1043 3
d1307 12
@


1.97
log
@Support using pane id as part of session or window specifier (so %1
means session-of-%1 or window-of-%1) and window id as part of session
(so @@1 means session-of-@@1).
@
text
@d1 1
a1 1
/* $OpenBSD: cmd.c,v 1.96 2014/09/25 12:45:35 nicm Exp $ */
d225 1
a225 1
		buf = xrealloc(buf, 1, len);
d1305 1
a1305 1
			buf = xrealloc(buf, 1, len + 1);
d1309 1
a1309 1
		buf = xrealloc(buf, 1, len + 2);
@


1.96
log
@Support ! for last pane.
@
text
@d1 1
a1 1
/* $OpenBSD: cmd.c,v 1.95 2014/07/13 20:57:46 nicm Exp $ */
d124 1
a124 1
struct session	*cmd_lookup_session(const char *, int *);
d588 1
a588 1
cmd_lookup_session(const char *name, int *ambiguous)
d590 3
a592 1
	struct session	*s, *sfound;
d600 6
d641 5
a645 3
	struct winlink	*wl, *wlfound;
	const char	*errstr;
	u_int		 idx;
d649 1
a649 1
	/* Try as a window id. */
d653 12
d811 5
a815 7
	struct session		*s;
	struct window_pane	*wp;
	struct window		*w;
	struct client		*c;
	char			*tmparg;
	size_t			 arglen;
	int			 ambiguous;
a823 6
	/* Lookup as pane id or window id. */
	if ((wp = cmd_lookup_paneid(arg)) != NULL)
		return (cmd_window_session(cmdq, wp->window, NULL));
	if ((w = cmd_lookup_windowid(arg)) != NULL)
		return (cmd_window_session(cmdq, w, NULL));

d839 1
a839 1
	s = cmd_lookup_session(tmparg, &ambiguous);
d861 5
a865 6
	struct session		*s;
	struct winlink		*wl;
	struct window_pane	*wp;
	const char		*winptr;
	char			*sessptr = NULL;
	int			 ambiguous = 0;
a882 8
	/* Lookup as pane id. */
	if ((wp = cmd_lookup_paneid(arg)) != NULL) {
		s = cmd_window_session(cmdq, wp->window, &wl);
		if (sp != NULL)
			*sp = s;
		return (wl);
	}

d897 1
a897 1
		if ((s = cmd_lookup_session(sessptr, &ambiguous)) == NULL)
d948 2
a949 1
	if (*arg != '\0' && (s = cmd_lookup_session(arg, &ambiguous)) == NULL)
d1039 1
a1039 1
		if ((s = cmd_lookup_session(sessptr, &ambiguous)) == NULL)
d1087 2
a1088 1
	if (*arg != '\0' && (s = cmd_lookup_session(arg, &ambiguous)) == NULL)
@


1.95
log
@Show an error if cmd_find_session can't find the current session, like
the other functions.
@
text
@d1 1
a1 1
/* $OpenBSD: cmd.c,v 1.94 2014/05/13 08:08:32 nicm Exp $ */
d1195 7
a1201 1
	else {
@


1.94
log
@If multiple arguments are given to new-session, new-window,
split-window, respawn-window or respawn-pane, pass them directly to
execvp() to help avoid quoting problems. One argument still goes to "sh
-c" like before. Requested by many over the years. Patch from J Raynor.
@
text
@d1 1
a1 1
/* $OpenBSD: cmd.c,v 1.93 2014/05/09 09:11:24 nicm Exp $ */
d798 5
a802 2
	if (arg == NULL)
		return (cmd_current_session(cmdq, prefer_unattached));
d819 3
a821 1
		return (cmd_current_session(cmdq, prefer_unattached));
@


1.93
log
@Just use char ** for argv like normal people, not char *const *.
@
text
@d1 1
a1 1
/* $OpenBSD: cmd.c,v 1.92 2014/04/16 21:02:41 nicm Exp $ */
d190 1
a190 1
	new_argv = xcalloc(argc, sizeof *new_argv);
d208 26
@


1.92
log
@Remove the choose-list command to prepare for some later choose-* work.
@
text
@d1 1
a1 1
/* $OpenBSD: cmd.c,v 1.91 2014/03/31 21:32:31 nicm Exp $ */
d183 1
a183 1
cmd_copy_argv(int argc, char *const *argv)
@


1.91
log
@Don't write into buffer if no arguments, reported by Filipe Rosset.
@
text
@d1 1
a1 1
/* $OpenBSD: cmd.c,v 1.90 2014/01/09 14:20:55 nicm Exp $ */
a37 1
	&cmd_choose_list_entry,
@


1.90
log
@Allow attach-session -t to accept a window and pane to select them on
attach. Based on a diff from J Raynor.
@
text
@d1 1
a1 1
/* $OpenBSD: cmd.c,v 1.89 2013/10/10 12:29:35 nicm Exp $ */
d141 3
@


1.89
log
@We accidentally haven't been using $TMUX to work out the session for a
while and in fact it is less useful that using the client ttyname. So
don't bother and don't pass it from the client. If we need it in future
it is in c->environ.
@
text
@d1 1
a1 1
/* $OpenBSD: cmd.c,v 1.88 2013/10/10 12:28:56 nicm Exp $ */
a128 1
struct window_pane *cmd_lookup_paneid(const char *);
a129 1
struct window	*cmd_lookup_windowid(const char *);
@


1.88
log
@Remove now unused cmd_get_default_path.
@
text
@d1 1
a1 1
/* $OpenBSD: cmd.c,v 1.87 2013/10/10 12:07:36 nicm Exp $ */
a316 1
	struct msg_command_data	*data = cmdq->msgdata;
a353 7
		if (s != NULL)
			return (s);
	}

	/* Use the session from the TMUX environment variable. */
	if (data != NULL && data->pid == getpid() && data->session_id != -1) {
		s = session_find_by_id(data->session_id);
@


1.87
log
@Support -c for new-session, based on code from J Raynor.
@
text
@d1 1
a1 1
/* $OpenBSD: cmd.c,v 1.86 2013/10/10 12:00:24 nicm Exp $ */
a1278 71
}

/*
 * Return the default path for a new pane. Several special values are accepted:
 * the empty string or relative path for the current working directory,
 * ~ for the user's home, - for the base working directory, . for the server
 * working directory.
 */
const char *
cmd_default_path(const char *base, const char *current, const char *in)
{
	const char		*root;
	struct environ_entry	*envent;
	char			 tmp[MAXPATHLEN];
	struct passwd		*pw;
	int			 n;
	size_t			 skip;
	static char		 path[MAXPATHLEN];

	skip = 1;
	if (strcmp(in, "$HOME") == 0 || strncmp(in, "$HOME/", 6) == 0) {
		/* User's home directory - $HOME. */
		skip = 5;
		goto find_home;
	} else if (in[0] == '~' && (in[1] == '\0' || in[1] == '/')) {
		/* User's home directory - ~. */
		goto find_home;
	} else if (in[0] == '-' && (in[1] == '\0' || in[1] == '/')) {
		/* Base working directory. */
		root = base;
		goto complete_path;
	} else if (in[0] == '.' && (in[1] == '\0' || in[1] == '/')) {
		/* Server working directory. */
		if (getcwd(tmp, sizeof tmp) != NULL) {
			root = tmp;
			goto complete_path;
		}
		return ("/");
	} else if (*in == '/') {
		/* Absolute path. */
		return (in);
	} else {
		/* Empty or relative path. */
		if (current != NULL)
			root = current;
		else
			return (base);
		skip = 0;
		goto complete_path;
	}

	return (base);

find_home:
	envent = environ_find(&global_environ, "HOME");
	if (envent != NULL && *envent->value != '\0')
		root = envent->value;
	else if ((pw = getpwuid(getuid())) != NULL)
		root = pw->pw_dir;
	else
		return (base);

complete_path:
	if (root[skip] == '\0') {
		strlcpy(path, root, sizeof path);
		return (path);
	}
	n = snprintf(path, sizeof path, "%s/%s", root, in + skip);
	if (n > 0 && (size_t)n < sizeof path)
		return (path);
	return (base);
@


1.86
log
@Remove the barely-used and unnecessary command check() function.
@
text
@d1 1
a1 1
/* $OpenBSD: cmd.c,v 1.85 2013/05/15 15:34:09 nicm Exp $ */
d1282 4
a1285 6
 * Return the default path for a new pane, using the given path or the
 * default-path option if it is NULL. Several special values are accepted: the
 * empty string or relative path for the current pane's working directory, ~
 * for the user's home, - for the session working directory, . for the tmux
 * server's working directory. The default on failure is the session's working
 * directory.
d1288 1
a1288 1
cmd_get_default_path(struct cmd_q *cmdq, const char *cwd)
d1290 1
a1290 2
	struct client		*c = cmdq->client;
	struct session		*s;
a1291 1
	const char		*root;
a1297 6
	if ((s = cmd_current_session(cmdq, 0)) == NULL)
		return (NULL);

	if (cwd == NULL)
		cwd = options_get_string(&s->options, "default-path");

d1299 1
a1299 1
	if (strcmp(cwd, "$HOME") == 0 || strncmp(cwd, "$HOME/", 6) == 0) {
d1303 1
a1303 1
	} else if (cwd[0] == '~' && (cwd[1] == '\0' || cwd[1] == '/')) {
d1306 3
a1308 3
	} else if (cwd[0] == '-' && (cwd[1] == '\0' || cwd[1] == '/')) {
		/* Session working directory. */
		root = s->cwd;
d1310 1
a1310 1
	} else if (cwd[0] == '.' && (cwd[1] == '\0' || cwd[1] == '/')) {
d1316 2
a1317 2
		return (s->cwd);
	} else if (*cwd == '/') {
d1319 1
a1319 1
		return (cwd);
d1322 2
a1323 4
		if (c != NULL && c->session == NULL && c->cwd != NULL)
			root = c->cwd;
		else if (s->curw != NULL)
			root = get_proc_cwd(s->curw->window->active->fd);
d1325 1
a1325 1
			return (s->cwd);
d1327 1
a1327 2
		if (root != NULL)
			goto complete_path;
d1330 1
a1330 1
	return (s->cwd);
d1339 1
a1339 1
		return (s->cwd);
d1346 1
a1346 1
	n = snprintf(path, sizeof path, "%s/%s", root, cwd + skip);
d1349 1
a1349 1
	return (s->cwd);
@


1.85
log
@Reserve space for \0 in cmd_print, from George Nachman.
@
text
@d1 1
a1 1
/* $OpenBSD: cmd.c,v 1.84 2013/03/25 11:53:54 nicm Exp $ */
a256 2
		goto usage;
	if (entry->check != NULL && entry->check(args) != 0)
@


1.84
log
@Sort includes and fix spaces.
@
text
@d1 1
a1 1
/* $OpenBSD: cmd.c,v 1.83 2013/03/25 10:11:45 nicm Exp $ */
d298 2
a299 2
	if (off < len) {
		used = args_print(cmd->args, buf + off, len - off);
@


1.83
log
@Rename session idx to session id throughout and add $ prefix to targets
to use it, extended from a diff from George Nachman.
@
text
@d1 1
a1 1
/* $OpenBSD: cmd.c,v 1.82 2013/03/25 10:09:05 nicm Exp $ */
d1248 2
a1249 2
	int	 	 replaced;
	size_t	 	 len;
@


1.82
log
@Add a wait-for command which blocks a client on a named channel until it
is woken up again (with wait-for -S). From Thiago Padilha.
@
text
@d1 1
a1 1
/* $OpenBSD: cmd.c,v 1.81 2013/03/25 10:04:44 nicm Exp $ */
d126 1
d362 2
a363 2
	if (data != NULL && data->pid == getpid() && data->idx != -1) {
		s = session_find_by_index(data->idx);
d555 15
d577 4
@


1.81
log
@tty.path can be NULL, don't dereference it. From George Nachman.
@
text
@d1 1
a1 1
/* $OpenBSD: cmd.c,v 1.80 2013/03/24 09:54:10 nicm Exp $ */
d116 1
@


1.80
log
@Add a command queue to standardize and simplify commands that call other
commands and allow a command to block execution of subsequent
commands. This allows run-shell and if-shell to be synchronous which has
been much requested.

Each client has a default command queue and commands are consumed one at
a time from it. A command may suspend execution from the queue by
returning CMD_RETURN_WAIT and then resume it by calling cmd_continue() -
for example run-shell does this from the callback that is fired after
the job is freed.

When the command queue becomes empty, command clients are automatically
exited (unless attaching). A callback is also fired - this is used for
nested commands in, for example, if-shell which can block execution of
the client's cmdq until a new cmdq becomes empty.

Also merge all the old error/info/print functions together and lose the
old curclient/cmdclient distinction - a cmdq is bound to one client (or
none if in the configuration file), this is a command client if
c->session is NULL otherwise an attached client.
@
text
@d1 1
a1 1
/* $OpenBSD: cmd.c,v 1.79 2013/03/24 09:27:20 nicm Exp $ */
d330 3
a332 3
	 * If the name of the calling client's pty is know, build a list of the
	 * sessions that contain it and if any choose either the first or the
	 * newest.
d535 1
a535 1
		if (c == NULL || c->session == NULL)
@


1.79
log
@Fix error reporting for client commands by adding a flag to
cmd_find_client to tell it whether or not to show errors, sometimes it's
needed and sometimes not.
@
text
@d1 1
a1 1
/* $OpenBSD: cmd.c,v 1.78 2013/03/22 15:54:29 nicm Exp $ */
d130 2
a131 2
struct session	*cmd_window_session(struct cmd_ctx *,
		    struct window *, struct winlink **);
a135 36
struct cmd_ctx *
cmd_get_ctx(struct client *cmdclient, struct client *curclient)
{
	struct cmd_ctx	*ctx;

	ctx = xcalloc(1, sizeof *ctx);
	ctx->references = 0;

	ctx->cmdclient = cmdclient;
	ctx->curclient = curclient;

	cmd_ref_ctx(ctx);
	return (ctx);
}

void
cmd_free_ctx(struct cmd_ctx *ctx)
{
	if (ctx->cmdclient != NULL)
		ctx->cmdclient->references--;
	if (ctx->curclient != NULL)
		ctx->curclient->references--;
	if (--ctx->references == 0)
		free(ctx);
}

void
cmd_ref_ctx(struct cmd_ctx *ctx)
{
	ctx->references++;
	if (ctx->cmdclient != NULL)
		ctx->cmdclient->references++;
	if (ctx->curclient != NULL)
		ctx->curclient->references++;
}

d209 1
a209 1
cmd_parse(int argc, char **argv, char **cause)
d259 1
a259 1
	cmd = xmalloc(sizeof *cmd);
d262 5
d315 1
a315 1
cmd_current_session(struct cmd_ctx *ctx, int prefer_unattached)
d317 2
a318 2
	struct msg_command_data	*data = ctx->msgdata;
	struct client		*c = ctx->cmdclient;
d323 1
d326 2
a327 2
	if (ctx->curclient != NULL && ctx->curclient->session != NULL)
		return (ctx->curclient->session);
d334 2
a335 1
	if (c != NULL && c->tty.path != NULL) {
d341 1
a341 1
					if (strcmp(wp->tty, c->tty.path) == 0) {
d432 1
a432 1
cmd_current_client(struct cmd_ctx *ctx)
d439 2
a440 2
	if (ctx->curclient != NULL)
		return (ctx->curclient);
d446 1
a446 1
	s = cmd_current_session(ctx, 0);
d491 1
a491 1
cmd_find_client(struct cmd_ctx *ctx, const char *arg, int quiet)
d499 1
a499 1
		c = cmd_current_client(ctx);
d501 1
a501 1
			ctx->error(ctx, "no clients");
d516 1
a516 1
		ctx->error(ctx, "client not found: %s", tmparg);
d718 1
a718 1
cmd_window_session(struct cmd_ctx *ctx, struct window *w, struct winlink **wlp)
d725 1
a725 1
	s = cmd_current_session(ctx, 0);
d750 1
a750 1
cmd_find_session(struct cmd_ctx *ctx, const char *arg, int prefer_unattached)
d762 1
a762 1
		return (cmd_current_session(ctx, prefer_unattached));
d766 1
a766 1
		return (cmd_window_session(ctx, wp->window, NULL));
d768 1
a768 1
		return (cmd_window_session(ctx, w, NULL));
d779 1
a779 1
		return (cmd_current_session(ctx, prefer_unattached));
d792 1
a792 1
			ctx->error(ctx, "more than one session: %s", tmparg);
d794 1
a794 1
			ctx->error(ctx, "session not found: %s", tmparg);
d803 1
a803 1
cmd_find_window(struct cmd_ctx *ctx, const char *arg, struct session **sp)
d816 2
a817 2
	if ((s = cmd_current_session(ctx, 0)) == NULL) {
		ctx->error(ctx, "can't establish current session");
d830 1
a830 1
		s = cmd_window_session(ctx, wp->window, &wl);
d911 1
a911 1
		ctx->error(ctx, "multiple sessions: %s", arg);
d913 1
a913 1
		ctx->error(ctx, "session not found: %s", arg);
d919 1
a919 1
		ctx->error(ctx, "multiple windows: %s", arg);
d921 1
a921 1
		ctx->error(ctx, "window not found: %s", arg);
d953 1
a953 1
cmd_find_index(struct cmd_ctx *ctx, const char *arg, struct session **sp)
d965 2
a966 2
	if ((s = cmd_current_session(ctx, 0)) == NULL) {
		ctx->error(ctx, "can't establish current session");
d1049 1
a1049 1
		ctx->error(ctx, "multiple sessions: %s", arg);
d1051 1
a1051 1
		ctx->error(ctx, "session not found: %s", arg);
d1058 1
a1058 1
	ctx->error(ctx, "invalid index: %s", arg);
d1065 1
a1065 1
		ctx->error(ctx, "multiple windows: %s", arg);
d1067 1
a1067 1
		ctx->error(ctx, "window not found: %s", arg);
d1104 1
a1104 1
cmd_find_pane(struct cmd_ctx *ctx,
d1114 2
a1115 2
	if ((s = cmd_current_session(ctx, 0)) == NULL) {
		ctx->error(ctx, "can't establish current session");
d1129 1
a1129 1
		s = cmd_window_session(ctx, (*wpp)->window, &wl);
d1144 1
a1144 1
	else if ((wl = cmd_find_window(ctx, winptr, sp)) == NULL)
d1168 1
a1168 1
		ctx->error(ctx, "can't find pane: %s", paneptr);
d1193 1
a1193 1
	if ((wl = cmd_find_window(ctx, arg, sp)) != NULL)
d1271 1
a1271 1
cmd_get_default_path(struct cmd_ctx *ctx, const char *cwd)
d1273 1
d1283 1
a1283 1
	if ((s = cmd_current_session(ctx, 0)) == NULL)
d1313 3
a1315 3
		if (ctx->cmdclient != NULL && ctx->cmdclient->cwd != NULL)
			root = ctx->cmdclient->cwd;
		else if (ctx->curclient != NULL && s->curw != NULL)
@


1.78
log
@Need to set clients in context before changing their reference count.
@
text
@d1 1
a1 1
/* $OpenBSD: cmd.c,v 1.77 2013/03/22 15:49:55 nicm Exp $ */
d520 1
a520 1
cmd_find_client(struct cmd_ctx *ctx, const char *arg)
d527 6
a532 2
	if (arg == NULL)
		return (cmd_current_client(ctx));
d544 1
a544 1
	if (c == NULL)
@


1.77
log
@Add functions to allocate and free command contexts rather than doing it
all on the stack.
@
text
@d1 1
a1 1
/* $OpenBSD: cmd.c,v 1.76 2013/03/21 16:22:48 nicm Exp $ */
d137 1
a137 1
cmd_get_ctx(void)
d143 3
@


1.76
log
@Do not crash when calling choose-tree with a command that changes the mode.
@
text
@d1 1
a1 1
/* $OpenBSD: cmd.c,v 1.75 2013/03/21 16:19:25 nicm Exp $ */
d136 33
a315 13
}

enum cmd_retval
cmd_exec(struct cmd *cmd, struct cmd_ctx *ctx)
{
	return (cmd->entry->exec(cmd, ctx));
}

void
cmd_free(struct cmd *cmd)
{
	args_free(cmd->args);
	free(cmd);
@


1.75
log
@Fix constness of cmd_template_replace, window_choose_add_item and
window_choose_add_window.
@
text
@d1 1
a1 1
/* $OpenBSD: cmd.c,v 1.74 2013/01/18 02:10:29 nicm Exp $ */
d1232 1
a1232 1
	if (strstr(template, "%") == NULL)
@


1.74
log
@Style nits - return (x) not return x.
@
text
@d1 1
a1 1
/* $OpenBSD: cmd.c,v 1.73 2012/12/24 12:38:57 nicm Exp $ */
d1225 1
a1225 1
cmd_template_replace(char *template, const char *s, int idx)
d1227 4
a1230 4
	char	 ch;
	char	*buf, *ptr;
	int	 replaced;
	size_t	 len;
@


1.73
log
@Add ^ and $ special command targets to select lowest and highest
numbered windows, from Raghavendra D Prabhu.
@
text
@d1 1
a1 1
/* $OpenBSD: cmd.c,v 1.72 2012/11/27 09:20:03 nicm Exp $ */
d381 1
a381 1
		return 1;
d385 1
a385 1
			return 1;
d388 1
a388 1
			return 0;
@


1.72
log
@Fix session choice so that preferring unattached sessions actually
works, reported by Drew Frank.
@
text
@d1 1
a1 1
/* $OpenBSD: cmd.c,v 1.71 2012/09/24 13:05:10 nicm Exp $ */
d866 4
@


1.71
log
@Use pgrp of pty fd not pid of immediate child when recovering current
working directory (like current process). From Marcel Partap.
@
text
@d1 1
a1 1
/* $OpenBSD: cmd.c,v 1.70 2012/09/03 09:57:57 nicm Exp $ */
d119 1
d375 18
d400 1
a400 2
	struct session	*s, *sbest;
	struct timeval	*tv = NULL;
d402 1
a402 1
	sbest = NULL;
d404 2
a405 7
		if (tv == NULL || timercmp(&s->activity_time, tv, >) ||
		    (prefer_unattached &&
		    !(sbest->flags & SESSION_UNATTACHED) &&
		    (s->flags & SESSION_UNATTACHED))) {
			sbest = s;
			tv = &s->activity_time;
		}
d407 1
a407 2

	return (sbest);
@


1.70
log
@add cmd-choose-list to allow arbitrary options to be selected. From
Thomas Adam.
@
text
@d1 1
a1 1
/* $OpenBSD: cmd.c,v 1.69 2012/07/11 07:10:15 nicm Exp $ */
d1301 1
a1301 1
			root = get_proc_cwd(s->curw->window->active->pid);
@


1.69
log
@Make command exec functions return an enum rather than -1/0/1 values and
add a new value to mean "leave client running but don't attach" to fix
problems with using some commands in a command sequence. Most of the
work by Thomas Adam, problem reported by "jspenguin" on SF bug 3535531.
@
text
@d1 1
a1 1
/* $OpenBSD: cmd.c,v 1.68 2012/07/10 11:53:01 nicm Exp $ */
d38 1
@


1.68
log
@xfree is not particularly helpful, remove it. From Thomas Adam.
@
text
@d1 1
a1 1
/* $OpenBSD: cmd.c,v 1.67 2012/07/08 16:04:38 nicm Exp $ */
d283 1
a283 1
int
@


1.67
log
@Add choose-tree command to show windows and sessions in the same
list. Change choose-window and -session to use the same code. From
Thomas Adam.
@
text
@d1 1
a1 1
/* $OpenBSD: cmd.c,v 1.66 2012/06/18 09:20:19 nicm Exp $ */
d201 3
a203 5
	for (i = 0; i < argc; i++) {
		if (argv[i] != NULL)
			xfree(argv[i]);
	}
	xfree(argv);
d292 2
a293 3
	if (cmd->args != NULL)
		args_free(cmd->args);
	xfree(cmd);
d507 1
a507 1
	xfree(tmparg);
d767 1
a767 1
		xfree(tmparg);
d786 1
a786 1
	xfree(tmparg);
d861 1
a861 1
		xfree(sessptr);
d899 1
a899 2
	if (sessptr != NULL)
		xfree(sessptr);
d907 1
a907 2
	if (sessptr != NULL)
		xfree(sessptr);
d998 1
a998 2
	if (sessptr != NULL)
		xfree(sessptr);
d1037 1
a1037 2
	if (sessptr != NULL)
		xfree(sessptr);
d1045 1
a1045 2
	if (sessptr != NULL)
		xfree(sessptr);
d1053 1
a1053 2
	if (sessptr != NULL)
		xfree(sessptr);
d1147 1
a1147 1
	xfree(winptr);
d1157 1
a1157 1
	xfree(winptr);
d1183 1
a1183 1
	xfree(winptr);
@


1.66
log
@Do not crash when the current session has no window, fixes a bug
reported by Giorgio Lando. Fix from Thomas Adam.
@
text
@d1 1
a1 1
/* $OpenBSD: cmd.c,v 1.65 2012/04/23 22:43:09 nicm Exp $ */
d39 1
@


1.65
log
@Do not return a buffer on the stack, mentioned by jsg a while ago.
@
text
@d1 1
a1 1
/* $OpenBSD: cmd.c,v 1.64 2012/04/22 05:24:05 nicm Exp $ */
d1293 1
a1293 1
	} else if (cwd[0] == '.' && (cwd[1] == '\0' || cwd[1] == '/')){
d1307 1
a1307 1
		else if (ctx->curclient != NULL)
@


1.64
log
@Fix printing commands with no arguments, from Benjamin Poirier.
@
text
@d1 1
a1 1
/* $OpenBSD: cmd.c,v 1.63 2012/03/03 08:31:18 nicm Exp $ */
d1328 4
a1331 2
	if (root[skip] == '\0')
		return (root);
@


1.63
log
@Add move-pane command (like join-pane but allows the same window). Also
-b flag to join-pane and move-pane to place the pane to the left or
above. From George Nachman.
@
text
@d1 1
a1 1
/* $OpenBSD: cmd.c,v 1.62 2012/02/06 17:29:29 nicm Exp $ */
d307 2
a308 2
			buf[off - 1] = '\0';
		else {
d310 1
a310 2
			buf[off] = '\0';
		}
@


1.62
log
@Don't die if fail to get root directory, from Ben Boeckel.
@
text
@d1 1
a1 1
/* $OpenBSD: cmd.c,v 1.61 2012/01/31 15:52:21 nicm Exp $ */
d71 1
@


1.61
log
@Provide defined ways to set the various default-path possibilities: ~
for home directory, . for server start directory, - for session start
directory and empty for the pane's working directory (the default). All
can also be used as part of a relative path (eg -/foo). Also provide -c
flags to neww and splitw to override default-path setting.

Based on a diff from sthen. ok sthen
@
text
@d1 1
a1 1
/* $OpenBSD: cmd.c,v 1.60 2012/01/30 09:39:34 nicm Exp $ */
d1312 2
a1313 1
		goto complete_path;
@


1.60
log
@Give each window a unique id, like panes but prefixed with @@. Based on
work from George Nachman.
@
text
@d1 1
a1 1
/* $OpenBSD: cmd.c,v 1.59 2012/01/20 19:54:07 nicm Exp $ */
d24 1
d1255 8
a1262 1
/* Return the default path for a new pane. */
d1264 1
a1264 1
cmd_get_default_path(struct cmd_ctx *ctx)
a1265 1
	const char		*cwd;
a1266 1
	struct window_pane	*wp;
d1268 6
d1278 20
a1297 14
	cwd = options_get_string(&s->options, "default-path");
	if ((cwd[0] == '~' && cwd[1] == '\0') || !strcmp(cwd, "$HOME")) {
		envent = environ_find(&global_environ, "HOME");
		if (envent != NULL && *envent->value != '\0')
			return envent->value;
		cwd = "";
	}
	if (*cwd == '\0') {
		if (ctx->cmdclient != NULL && ctx->cmdclient->cwd != NULL)
			return (ctx->cmdclient->cwd);
		if (ctx->curclient != NULL) {
			wp = s->curw->window->active;
			if ((cwd = get_proc_cwd(wp->pid)) != NULL)
				return (cwd);
d1300 13
d1314 19
a1332 1
	return (cwd);
@


1.59
log
@Add some const and fix a warning.
@
text
@d1 1
a1 1
/* $OpenBSD: cmd.c,v 1.58 2011/12/27 14:07:20 stsp Exp $ */
d123 4
a126 2
struct session	*cmd_pane_session(struct cmd_ctx *,
		    struct window_pane *, struct winlink **);
d592 4
d658 1
a658 4
/*
 * Lookup pane id. An initial % means a pane id. sp must already point to the
 * current session.
 */
d674 33
a706 1
/* Find session and winlink for pane. */
d708 1
a708 2
cmd_pane_session(struct cmd_ctx *ctx, struct window_pane *wp,
    struct winlink **wlp)
d714 1
a714 1
	/* If this pane is in the current session, return that winlink. */
d717 1
a717 1
		wl = winlink_find_by_window(&s->windows, wp->window);
d725 1
a725 1
	/* Otherwise choose from all sessions with this pane. */
d728 1
a728 1
		if (winlink_find_by_window(&s->windows, wp->window) != NULL)
d734 1
a734 1
		*wlp = winlink_find_by_window(&s->windows, wp->window);
d744 1
d754 1
a754 1
	/* Lookup as pane id. */
d756 3
a758 1
		return (cmd_pane_session(ctx, wp, NULL));
d820 1
a820 1
		s = cmd_pane_session(ctx, wp, &wl);
d1121 1
a1121 1
		s = cmd_pane_session(ctx, *wpp, &wl);
@


1.58
log
@Allow $HOME as default-path in tmux.conf so the same config file can be used
on different machines regardless of where the user's home directory is.
ok nicm
@
text
@d1 1
a1 1
/* $OpenBSD: cmd.c,v 1.57 2011/12/09 16:28:18 nicm Exp $ */
d1218 1
a1218 1
char *
d1221 1
a1221 1
	char			*cwd;
@


1.57
log
@Change the way the working directory for new processes is discovered. If
default-path isn't empty, it is used. Otherwise:

1) If tmux neww is run from the command line, the working directory of the
   client is used.

2) Otherwise sysctl KERN_PROC_CWD is used to retrieve the current
   working directory of the process in the active pane.

3) If that fails, the directory where the session was created is used.

Support code by Romain Francois, OpenBSD specific bits by me.

Note this requires a recent userland and kernel with KERN_PROC_CWD.
@
text
@d1 1
a1 1
/* $OpenBSD: cmd.c,v 1.56 2011/06/05 11:19:03 nicm Exp $ */
d1224 1
d1230 6
@


1.56
log
@Add a respawn-pane command, from Marcel Partap.
@
text
@d1 1
a1 1
/* $OpenBSD: cmd.c,v 1.55 2011/06/05 10:53:05 nicm Exp $ */
d1215 25
@


1.55
log
@Get rid of the layout string code which tries to walk through the layout
hierarchy and instead just look at what panes are actually in the window.
@
text
@d1 1
a1 1
/* $OpenBSD: cmd.c,v 1.54 2011/05/08 20:35:58 nicm Exp $ */
d83 1
@


1.54
log
@Fix a memory leak if cmd_pane_session succeeds, from Tiago Cunha.
@
text
@d1 1
a1 1
/* $OpenBSD: cmd.c,v 1.53 2011/04/06 21:51:31 nicm Exp $ */
d1061 5
a1065 6
	struct session		*s;
	struct winlink		*wl;
	struct layout_cell	*lc;
	const char		*period, *errstr;
	char			*winptr, *paneptr;
	u_int			 idx;
d1121 1
a1121 1
	if ((lc = layout_find_string(wl->window, paneptr)) == NULL) {
a1124 1
	*wpp = lc->wp;
d1143 1
a1143 2
	if ((lc = layout_find_string(s->curw->window, arg)) != NULL) {
		*wpp = lc->wp;
a1144 1
	}
@


1.53
log
@Change so that an empty session name always means the current sessions
even if given with, for example, -t '', and explicitly forbid empty
session names and those containing a : when they are created.
@
text
@d1 1
a1 1
/* $OpenBSD: cmd.c,v 1.52 2011/04/05 19:37:01 nicm Exp $ */
a716 1
	tmparg = xstrdup(arg);
d723 1
d730 1
a730 1
		xfree (tmparg);
@


1.52
log
@Add a flag to cmd_find_session so that attach-session can prefer
unattached sessions when choosing the most recently used (if -t is not
given). Suggested by claudio@@.
@
text
@d1 1
a1 1
/* $OpenBSD: cmd.c,v 1.51 2011/03/27 20:27:26 nicm Exp $ */
d728 6
d849 1
a849 1
	if ((s = cmd_lookup_session(arg, &ambiguous)) == NULL)
d990 1
a990 1
	if ((s = cmd_lookup_session(arg, &ambiguous)) == NULL)
@


1.51
log
@Give each pane created in a tmux server a unique id (starting from 0),
put it in the TMUX_PANE environment variable and accept it as a
target. Suggested by and with testing and tweaks from Ben Boeckel.
@
text
@d1 1
a1 1
/* $OpenBSD: cmd.c,v 1.50 2011/01/23 11:03:43 nicm Exp $ */
d115 1
a115 1
struct session	*cmd_choose_session(void);
d319 1
a319 1
cmd_current_session(struct cmd_ctx *ctx)
d368 1
a368 1
	return (cmd_choose_session());
d371 4
a374 1
/* Find the most recently used session. */
d376 1
a376 1
cmd_choose_session(void)
d383 4
a386 1
		if (tv == NULL || timercmp(&s->activity_time, tv, >)) {
d437 1
a437 1
	s = cmd_current_session(ctx);
d680 1
a680 1
	s = cmd_current_session(ctx);
d705 1
a705 1
cmd_find_session(struct cmd_ctx *ctx, const char *arg)
d716 1
a716 1
		return (cmd_current_session(ctx));
d762 1
a762 1
	if ((s = cmd_current_session(ctx)) == NULL) {
d909 1
a909 1
	if ((s = cmd_current_session(ctx)) == NULL) {
d1063 1
a1063 1
	if ((s = cmd_current_session(ctx)) == NULL) {
@


1.50
log
@Set $TMUX without the session when background jobs are run.
@
text
@d1 1
a1 1
/* $OpenBSD: cmd.c,v 1.49 2011/01/04 00:42:47 nicm Exp $ */
d121 3
d126 1
a126 1
struct window_pane	*cmd_find_pane_offset(const char *, struct winlink *);
d645 52
d701 6
a706 5
	struct session	*s;
	struct client	*c;
	char		*tmparg;
	size_t		 arglen;
	int		 ambiguous;
d713 4
d745 6
a750 5
	struct session	*s;
	struct winlink	*wl;
	const char	*winptr;
	char		*sessptr = NULL;
	int		 ambiguous = 0;
d768 8
d1068 8
@


1.49
log
@Clean up and simplify tmux command argument parsing.

Originally, tmux commands were parsed in the client process into a
struct with the command data which was then serialised and sent to the
server to be executed. The parsing was later moved into the server (an
argv was sent from the client), but the parse step and intermediate
struct was kept.

This change removes that struct and the separate parse step. Argument
parsing and printing is now common to all commands (in arguments.c) with
each command left with just an optional check function (to validate the
arguments at parse time), the exec function and a function to set up any
key bindings (renamed from the old init function).

This is overall more simple and consistent.

There should be no changes to any commands behaviour or syntax although
as this touches every command please watch for any unexpected changes.
@
text
@d1 1
a1 1
/* $OpenBSD: cmd.c,v 1.48 2010/12/30 23:16:18 nicm Exp $ */
d359 1
a359 1
	if (data != NULL && data->pid == getpid()) {
@


1.48
log
@Change from a per-session stack of buffers to one global stack which is
much more convenient and also simplifies lot of code. This renders
copy-buffer useless and makes buffer-limit now a server option.

By Tiago Cunha.
@
text
@d1 1
a1 1
/* $OpenBSD: cmd.c,v 1.47 2010/12/21 22:37:59 nicm Exp $ */
d170 1
a170 1
cmd_copy_argv(int argc, char **argv)
d204 1
d206 1
a206 1
	int			 opt, ambiguous = 0;
d240 9
a248 14
	optreset = 1;
	optind = 1;
	if (entry->parse == NULL) {
		while ((opt = getopt(argc, argv, "")) != -1) {
			switch (opt) {
			default:
				goto usage;
			}
		}
		argc -= optind;
		argv += optind;
		if (argc != 0)
			goto usage;
	}
d252 1
a252 7
	cmd->data = NULL;
	if (entry->parse != NULL) {
		if (entry->parse(cmd, argc, argv, cause) != 0) {
			xfree(cmd);
			return (NULL);
		}
	}
d270 2
d285 2
a286 2
	if (cmd->data != NULL && cmd->entry->free != NULL)
		cmd->entry->free(cmd);
d293 13
a305 3
	if (cmd->entry->print == NULL)
		return (xsnprintf(buf, len, "%s", cmd->entry->name));
	return (cmd->entry->print(cmd, buf, len));
@


1.47
log
@Store sessions in an RB tree by name rather than a list, this is tidier
and allows them to easily be shown sorted in various lists
(list-sessions/choose-sessions).

Keep a session index which is used in a couple of places internally but
make it an ever-increasing number rather than filling in gaps with new
sessions.
@
text
@d1 1
a1 1
/* $OpenBSD: cmd.c,v 1.46 2010/10/29 20:11:57 nicm Exp $ */
a42 1
	&cmd_copy_buffer_entry,
@


1.46
log
@We now send argv to the server after parsing it in the client to get the
command, so the client should not modify it. Instead, take a copy. Fixes
parsing command lists, reported by mcbride@@.
@
text
@d1 1
a1 1
/* $OpenBSD: cmd.c,v 1.45 2010/10/23 13:04:34 nicm Exp $ */
d115 2
a116 1
struct session	*cmd_choose_session(struct sessions *);
d320 1
a320 1
	struct sessions		 ss;
a322 1
	u_int			 i;
d335 1
a335 3
		for (i = 0; i < ARRAY_LENGTH(&sessions); i++) {
			if ((s = ARRAY_ITEM(&sessions, i)) == NULL)
				continue;
d351 1
a351 1
		s = cmd_choose_session(&ss);
d358 23
a380 5
	if (data != NULL &&
	    data->pid == getpid() &&
	    data->idx <= ARRAY_LENGTH(&sessions) &&
	    (s = ARRAY_ITEM(&sessions, data->idx)) != NULL)
		return (s);
d382 1
a382 1
	return (cmd_choose_session(&sessions));
d387 1
a387 1
cmd_choose_session(struct sessions *ss)
a534 1
	u_int		 i;
d543 2
a544 6
	for (i = 0; i < ARRAY_LENGTH(&sessions); i++) {
		if ((s = ARRAY_ITEM(&sessions, i)) == NULL)
			continue;
		if (strcmp(name, s->name) == 0)
			return (s);
	}
d551 1
a551 3
	for (i = 0; i < ARRAY_LENGTH(&sessions); i++) {
		if ((s = ARRAY_ITEM(&sessions, i)) == NULL)
			continue;
@


1.45
log
@Add a last-pane command (bound to ; by default). Requested ages ago by
somebody whose name I have forgotten.
@
text
@d1 1
a1 1
/* $OpenBSD: cmd.c,v 1.44 2010/10/16 07:57:42 nicm Exp $ */
d167 16
@


1.44
log
@Fall back on normal session choice method if $TMUX exists but is invalid
rather than rejecting.
@
text
@d1 1
a1 1
/* $OpenBSD: cmd.c,v 1.43 2010/07/14 18:37:49 nicm Exp $ */
d57 1
@


1.43
log
@Make pane/window wrapping more logical (so with 10 windows, +10 from
window 5 stays in the same place), and tidy the code. From Tiago Cunha.
@
text
@d1 1
a1 1
/* $OpenBSD: cmd.c,v 1.42 2010/06/21 21:44:09 nicm Exp $ */
d343 4
a346 7
	if (data != NULL && data->pid != -1) {
		if (data->pid != getpid())
			return (NULL);
		if (data->idx > ARRAY_LENGTH(&sessions))
			return (NULL);
		if ((s = ARRAY_ITEM(&sessions, data->idx)) == NULL)
			return (NULL);
a347 1
	}
@


1.42
log
@Add a choose-buffer command for easier use of the paste buffer stack.
@
text
@d1 1
a1 1
/* $OpenBSD: cmd.c,v 1.41 2010/06/21 01:46:36 nicm Exp $ */
d120 3
a666 1
	int		 n = 1;
d712 3
a714 15
	else if (winptr[0] == '+' || winptr[0] == '-') {
		if (winptr[1] != '\0')
			n = strtonum(winptr + 1, 1, INT_MAX, NULL);
		if (n == 0)
			wl = cmd_lookup_window(s, winptr, &ambiguous);
		else {
			if (winptr[0] == '+')
				wl = winlink_next_by_number(s->curw, n);
			else
				wl = winlink_previous_by_number(s->curw, n);
			/* Search by name before giving up. */
			if (wl == NULL)
				wl = cmd_lookup_window(s, winptr, &ambiguous);
		}
	} else
d732 1
a732 14
		if (arg[1] != '\0')
			n = strtonum(arg + 1, 1, INT_MAX, NULL);
		if (n == 0)
			wl = cmd_lookup_window(s, arg, &ambiguous);
		else {
			if (arg[0] == '+')
				wl = winlink_next_by_number(s->curw, n);
			else
				wl = winlink_previous_by_number(s->curw, n);
			/* Search by name before giving up. */
			if (wl == NULL)
				wl = cmd_lookup_window(s, arg, &ambiguous);
		}
		if (wl == NULL)
d772 20
a805 1
	int		 n = 1;
d854 1
a854 13
		if (winptr[1] != '\0')
			n = strtonum(winptr + 1, 1, INT_MAX, NULL);
		if (winptr[0] == '+' && s->curw->idx == INT_MAX)
			idx = cmd_lookup_index(s, winptr, &ambiguous);
		else if (winptr[0] == '-' && s->curw->idx == 0)
			idx = cmd_lookup_index(s, winptr, &ambiguous);
		else if (n == 0)
			idx = cmd_lookup_index(s, winptr, &ambiguous);
		else if (winptr[0] == '+')
			idx = s->curw->idx + n;
		else
			idx = s->curw->idx - n;
		if (idx < 0)
d873 1
a873 13
		if (arg[1] != '\0')
			n = strtonum(arg + 1, 1, INT_MAX, NULL);
		if (arg[0] == '+' && s->curw->idx == INT_MAX)
			idx = cmd_lookup_index(s, arg, &ambiguous);
		else if (arg[0] == '-' && s->curw->idx == 0)
			idx = cmd_lookup_index(s, arg, &ambiguous);
		else if (n == 0)
			idx = cmd_lookup_index(s, arg, &ambiguous);
		else if (arg[0] == '+')
			idx = s->curw->idx + n;
		else
			idx = s->curw->idx - n;
		if (idx < 0)
d922 26
d962 1
a962 1
	u_int			 idx, n = 1;
d994 3
a996 21
	else if (paneptr[0] == '+' || paneptr[0] == '-') {
		if (paneptr[1] != '\0')
			n = strtonum(paneptr + 1, 1, INT_MAX, NULL);
		idx = window_pane_index(wl->window, wl->window->active);
		if (paneptr[0] == '+' && idx == INT_MAX)
			*wpp = TAILQ_FIRST(&wl->window->panes);
		else if (paneptr[0] == '-' && idx == 0)
			*wpp = TAILQ_LAST(&wl->window->panes, window_panes);
		else if (n == 0)
			*wpp = wl->window->active;
		else if (paneptr[0] == '+')
			*wpp = window_pane_at_index(wl->window, idx + n);
		else
			*wpp = window_pane_at_index(wl->window, idx - n);
		if (paneptr[0] == '+' && *wpp == NULL)
			*wpp = TAILQ_FIRST(&wl->window->panes);
		else if (paneptr[0] == '-' && *wpp == NULL)
			*wpp = TAILQ_LAST(&wl->window->panes, window_panes);
		else if (*wpp == NULL)
			goto error;
	} else {
d1046 19
@


1.41
log
@Extend the -t:+ and -t:- window targets for next and previous window to
accept an offset such as -t:+2. From Tiago Cunha.
@
text
@d1 1
a1 1
/* $OpenBSD: cmd.c,v 1.40 2010/05/05 23:24:23 nicm Exp $ */
d35 1
@


1.40
log
@Identical behaviour to select-prompt can now be obtained with
command-prompt, so remove select-prompt and change ' to be bound to
command-prompt -p index "select-window -t :%%".
@
text
@d1 1
a1 1
/* $OpenBSD: cmd.c,v 1.39 2010/03/22 19:07:52 nicm Exp $ */
d541 1
a541 1
 * idx if the window index is a valid number but there is now window with that
d663 1
d709 15
a723 5
	else if (winptr[0] == '+' && winptr[1] == '\0')
		wl = winlink_next(s->curw);
	else if (winptr[0] == '-' && winptr[1] == '\0')
		wl = winlink_previous(s->curw);
	else
d740 18
a757 13
	} else if (arg[0] == '+' && arg[1] == '\0') {
		if ((wl = winlink_next(s->curw)) == NULL)
			goto not_found;
	} else if (arg[0] == '-' && arg[1] == '\0') {
		if ((wl = winlink_previous(s->curw)) == NULL)
			goto not_found;
	} else if ((wl = cmd_lookup_window(s, arg, &ambiguous)) == NULL) {
		if (ambiguous)
			goto not_found;
		if ((s = cmd_lookup_session(arg, &ambiguous)) == NULL)
			goto no_session;
		wl = s->curw;
	}
d764 11
d808 1
d856 17
a872 14
	} else if (winptr[0] == '+' && winptr[1] == '\0') {
		if (s->curw->idx == INT_MAX)
			goto not_found;
		idx = s->curw->idx + 1;
	} else if (winptr[0] == '-' && winptr[1] == '\0') {
		if (s->curw->idx == 0)
			goto not_found;
		idx = s->curw->idx - 1;
	} else if ((idx = cmd_lookup_index(s, winptr, &ambiguous)) == -1) {
		if (ambiguous)
			goto not_found;
		ctx->error(ctx, "invalid index: %s", arg);
		idx = -2;
	}
d887 17
a903 15
	} else if (arg[0] == '+' && arg[1] == '\0') {
		if (s->curw->idx == INT_MAX)
			goto not_found;
		idx = s->curw->idx + 1;
	} else if (arg[0] == '-' && arg[1] == '\0') {
		if (s->curw->idx == 0)
			goto not_found;
		idx = s->curw->idx - 1;
	} else if ((idx = cmd_lookup_index(s, arg, &ambiguous)) == -1) {
		if (ambiguous)
			goto not_found;
		if ((s = cmd_lookup_session(arg, &ambiguous)) == NULL)
			goto no_session;
		idx = -1;
	}
d910 11
d930 9
d963 1
a963 1
	u_int			 idx;
d995 21
a1015 1
	else {
a1027 14
	/* Try as next or previous pane. */
	if (paneptr[0] == '+' && paneptr[1] == '\0') {
		*wpp = TAILQ_NEXT(wl->window->active, entry);
		if (*wpp == NULL)
			*wpp = TAILQ_FIRST(&wl->window->panes);
		return (wl);
	}
	if (paneptr[0] == '-' && paneptr[1] == '\0') {
		*wpp = TAILQ_PREV(wl->window->active, window_panes, entry);
		if (*wpp == NULL)
			*wpp = TAILQ_LAST(&wl->window->panes, window_panes);
		return (wl);
	}

@


1.39
log
@Support up, down, left, right movement through panes with -UDLR flags to
select-pane.

Also REMOVE the up- and down-pane commands: equivalent behaviour is now
available using -t :.+ and -t :.-.
@
text
@d1 1
a1 1
/* $OpenBSD: cmd.c,v 1.38 2010/01/19 21:27:47 nicm Exp $ */
a87 1
	&cmd_select_prompt_entry,
@


1.38
log
@Permit !, + and - to be used for window targets to specify last window (!), or
next and previous window by number (+ and -).

Also tidy an if in cmd-new-window.c.
@
text
@d1 1
a1 1
/* $OpenBSD: cmd.c,v 1.37 2010/01/07 20:52:18 nicm Exp $ */
a47 1
	&cmd_down_pane_entry,
a110 1
	&cmd_up_pane_entry,
d956 14
d971 1
a971 1
	if ((lc = layout_find_string(s->curw->window, paneptr)) == NULL) {
d978 1
a978 1
	return (s->curw);
@


1.37
log
@New command, join-pane, to split and move an existing pane into the space (like
splitw then movep, or the reverse of breakp).
@
text
@d1 1
a1 1
/* $OpenBSD: cmd.c,v 1.36 2009/12/08 07:49:31 nicm Exp $ */
d705 1
a705 1
	 * otherwise try to look it up in the session.
d709 9
a717 1
	else if ((wl = cmd_lookup_window(s, winptr, &ambiguous)) == NULL)
d725 14
a738 2
	/* No colon in the string, first try as a window then as a session. */
	if ((wl = cmd_lookup_window(s, arg, &ambiguous)) == NULL) {
d780 1
d826 14
a839 2
		 idx = -1;
	else if ((idx = cmd_lookup_index(s, winptr, &ambiguous)) == -1) {
d851 17
a867 2
	/* No colon in the string, first try as a window then as a session. */
	if ((idx = cmd_lookup_index(s, arg, &ambiguous)) == -1) {
@


1.36
log
@Permit panes to be referred to as "top", "bottom", "top-left" etc, if the right
pane can be identified.
@
text
@d1 1
a1 1
/* $OpenBSD: cmd.c,v 1.35 2009/12/03 22:50:10 nicm Exp $ */
d52 1
@


1.35
log
@Massive spaces->tabs and trailing whitespace cleanup, hopefully for the last
time now I've configured emacs to make them displayed in really annoying
colours...
@
text
@d1 1
a1 1
/* $OpenBSD: cmd.c,v 1.34 2009/12/01 18:42:38 nicm Exp $ */
d859 6
a864 6
	struct session	*s;
	struct winlink	*wl;
	const char	*period;
	char		*winptr, *paneptr;
	const char	*errstr;
	u_int		 idx;
d898 2
a899 4
		if (errstr != NULL) {
			ctx->error(ctx, "pane %s: %s", errstr, paneptr);
			goto error;
		}
d901 2
a902 4
		if (*wpp == NULL) {
			ctx->error(ctx, "no such pane: %u", idx);
			goto error;
		}
d908 11
d932 6
@


1.34
log
@New command, capture-pane, which copies the entire pane contents to a paste
buffer. From Jonathan Alvarado.
@
text
@d1 1
a1 1
/* $OpenBSD: cmd.c,v 1.33 2009/11/21 17:52:18 nicm Exp $ */
d172 1
a172 1
		return; 
d513 1
a513 1
	for (i = 0; i < ARRAY_LENGTH(&sessions); i++) {	
d525 1
a525 1
	for (i = 0; i < ARRAY_LENGTH(&sessions); i++) {	
d537 1
a537 1
 	return (sfound);
d561 1
a561 1
		
d587 1
a587 1
	}	
d710 1
a710 1
	
d811 1
a811 1
	
d833 1
a833 1
 		ctx->error(ctx, "multiple sessions: %s", arg);
d921 1
a921 1
	
d929 1
a929 1
	
@


1.33
log
@Use home from struct passwd if HOME is empty as well as if it is NULL, and fix
a style nit. Both from Tiago Cunha.
@
text
@d1 1
a1 1
/* $OpenBSD: cmd.c,v 1.32 2009/11/18 13:16:33 nicm Exp $ */
d34 1
@


1.32
log
@Add a per-client log of status line messages displayed while that client
exists. A new message-limit session option sets the maximum number of entries
and a command, show-messages, shows the log (bound to ~ by default).

This (and prompt history) might be better as a single global log but until
there are global options it is easier for them to be per client.
@
text
@d1 1
a1 1
/* $OpenBSD: cmd.c,v 1.31 2009/11/03 22:40:40 nicm Exp $ */
d281 1
a281 1
	if (cmd->entry->print == NULL) {
a282 1
	}
@


1.31
log
@Add an activity time for clients, like for sessions, and change session and
client lookup to pick the most recently used rather than the most recently
created - this is much more useful when used interactively and (because the
activity time is set at creation) should have no effect on source-file.

Based on a problem reported by Jan Johansson.
@
text
@d1 1
a1 1
/* $OpenBSD: cmd.c,v 1.30 2009/11/03 20:59:22 nicm Exp $ */
d98 1
@


1.30
log
@If it isn't available explicitly, work out the current client in a similar way
to the current session - build a list of the possibilities then pick the
newest.
@
text
@d1 1
a1 1
/* $OpenBSD: cmd.c,v 1.29 2009/11/03 20:29:47 nicm Exp $ */
d113 2
a114 2
struct session	*cmd_newest_session(struct sessions *);
struct client	*cmd_newest_client(struct clients *);
d288 4
a291 3
 * context has one; 2) the session containing the pty of the calling client, if
 * any 3) the session specified in the TMUX variable from the environment (as
 * passed from the client); 3) the newest session.
d333 1
a333 1
		s = cmd_newest_session(&ss);
d350 1
a350 1
	return (cmd_newest_session(&sessions));
d353 1
a353 1
/* Find the newest session. */
d355 1
a355 1
cmd_newest_session(struct sessions *ss)
d357 1
a357 1
	struct session	*s, *snewest;
d361 1
a361 1
	snewest = NULL;
d366 3
a368 3
		if (tv == NULL || timercmp(&s->creation_time, tv, >)) {
			snewest = s;
			tv = &s->creation_time;
d372 1
a372 1
	return (snewest);
d377 2
a378 2
 * newest of the clients attached to the current session if any, then the
 * newest client.
d405 1
a405 1
		c = cmd_newest_client(&cc);
d411 1
a411 1
	return (cmd_newest_client(&clients));
d414 1
a414 1
/* Find the newest client. */
d416 1
a416 1
cmd_newest_client(struct clients *cc)
d418 1
a418 1
	struct client	*c, *cnewest;
d422 1
a422 1
	cnewest = NULL;
d429 3
a431 3
		if (tv == NULL || timercmp(&c->creation_time, tv, >)) {
			cnewest = c;
			tv = &c->creation_time;
d435 1
a435 1
	return (cnewest);
@


1.29
log
@Change session and client activity and creation time members to have more
meaningful names.

Also, remove the code to try and update the session activity time for the
command client when a command message is received as is pointless because it
des not have a session.
@
text
@d1 1
a1 1
/* $OpenBSD: cmd.c,v 1.28 2009/11/02 16:24:29 nicm Exp $ */
d114 1
a114 1
struct client	*cmd_newest_client(void);
d374 39
d415 1
a415 1
cmd_newest_client(void)
d422 2
a423 2
	for (i = 0; i < ARRAY_LENGTH(&clients); i++) {
		if ((c = ARRAY_ITEM(&clients, i)) == NULL)
d441 1
a441 2
	struct client	*c, *lastc;
	struct session	*s;
a443 1
	u_int		 i;
d446 2
a447 23
	if (arg == NULL) {
		if (ctx->curclient != NULL)
			return (ctx->curclient);
		/*
		 * No current client set. Find the current session and see if
		 * it has only one client.
		 */
		s = cmd_current_session(ctx);
		if (s != NULL) {
			lastc = NULL;
			for (i = 0; i < ARRAY_LENGTH(&clients); i++) {
				c = ARRAY_ITEM(&clients, i);
				if (c != NULL && c->session == s) {
					if (lastc != NULL)
						break;
					lastc = c;
				}
			}
			if (i == ARRAY_LENGTH(&clients) && lastc != NULL)
				return (lastc);
		}
		return (cmd_newest_client());
	}
@


1.28
log
@When matching the session names with -t, look for exact matches first before
trying partial matches.

Avoids problems where two ambiguous matches are present before an exact match
(eg foo1, foo2, foo would give an error on trying -tfoo), reported by Natacha
Port? natbsd at instinctive dot eu.
@
text
@d1 1
a1 1
/* $OpenBSD: cmd.c,v 1.27 2009/10/26 21:42:04 deraadt Exp $ */
d365 1
a365 1
		if (tv == NULL || timercmp(&s->tv, tv, >)) {
d367 1
a367 1
			tv = &s->tv;
d389 1
a389 1
		if (tv == NULL || timercmp(&c->tv, tv, >)) {
d391 1
a391 1
			tv = &c->tv;
@


1.27
log
@tabs are better; ok nicm
@
text
@d1 1
a1 1
/* $OpenBSD: cmd.c,v 1.26 2009/10/14 20:52:28 nicm Exp $ */
d491 3
a493 2
	 * Look for matches. Session names must be unique so an exact match
	 * can't be ambigious and can just be returned.
a494 1
	sfound = NULL;
a497 2

		/* Check for an exact match and return it if found. */
d500 10
a509 2
		
		/* Then check for pattern matches. */
a518 1
		
@


1.26
log
@cmd_find_client shouldn't die when there is an empty slot in the clients
array. DOH.
@
text
@d1 1
a1 1
/* $OpenBSD: cmd.c,v 1.25 2009/10/14 09:29:10 nicm Exp $ */
d182 1
a182 1
	struct cmd	        *cmd;
d845 1
a845 1
       		ctx->error(ctx, "can't establish current session");
@


1.25
log
@Don't allow cmd_lookup_client to test clients without a session.
@
text
@d1 1
a1 1
/* $OpenBSD: cmd.c,v 1.24 2009/10/11 10:04:27 nicm Exp $ */
d402 1
a402 1
	struct client	*c;
d418 1
a418 1
			c = NULL;
d420 3
a422 2
				if (ARRAY_ITEM(&clients, i)->session == s) {
					if (c != NULL)
d424 1
a424 1
					c = ARRAY_ITEM(&clients, i);
d427 2
a428 2
			if (i == ARRAY_LENGTH(&clients) && c != NULL)
				return (c);
@


1.24
log
@Add a pipe-pane command to allow a pane to be piped to a shell command, for
example:

	pipe-pane 'cat >~/out'

No arguments stops outputing and closes the pipe; the -o flag toggles a pipe
and on and off (useful for key bindings).

Suggested by espie@@.
@
text
@d1 1
a1 1
/* $OpenBSD: cmd.c,v 1.23 2009/10/10 17:19:38 nicm Exp $ */
d461 2
a462 1
		if ((c = ARRAY_ITEM(&clients, i)) == NULL)
@


1.23
log
@Split list-panes off from list-windows.
@
text
@d1 1
a1 1
/* $OpenBSD: cmd.c,v 1.22 2009/10/07 07:02:40 nicm Exp $ */
d74 1
@


1.22
log
@Fix comment.
@
text
@d1 1
a1 1
/* $OpenBSD: cmd.c,v 1.21 2009/10/06 07:19:32 nicm Exp $ */
d61 1
@


1.21
log
@Remove scroll mode which is now redundant, copy mode should be used instead.

The = key binding now does nothing.
@
text
@d1 1
a1 1
/* $OpenBSD: cmd.c,v 1.20 2009/10/05 18:30:54 nicm Exp $ */
d412 1
a412 1
		 * it has only has one client.
@


1.20
log
@If no target client is specified to commands which accept one, try to guess the
current client, in a similar manner to how sessions already work: if the
current session can be established and has only one client, use that; otherwise
use the most recently created client.
@
text
@d1 1
a1 1
/* $OpenBSD: cmd.c,v 1.19 2009/09/24 14:17:09 nicm Exp $ */
a82 1
	&cmd_scroll_mode_entry,
@


1.19
log
@New lock-client and lock-session commands to lock an individual client or all
clients attached to a session respectively.
@
text
@d1 1
a1 1
/* $OpenBSD: cmd.c,v 1.18 2009/09/23 06:18:47 nicm Exp $ */
d113 1
d373 24
d402 1
d405 1
d408 22
a429 2
	if (arg == NULL)
		return (ctx->curclient);
@


1.18
log
@Remove the internal tmux locking and instead detach each client and run the
command specified by a new option "lock-command" (by default "lock -np") in
each client.

This means each terminal has to be unlocked individually but simplifies the
code and allows the system password to be used to unlock.

Note that the set-password command is gone, so it will need to be removed from
configuration files, and the -U command line flag has been removed.

This is the third protocol version change so again it is best to stop the tmux
server before upgrading.
@
text
@d1 1
a1 1
/* $OpenBSD: cmd.c,v 1.17 2009/09/20 19:15:01 nicm Exp $ */
d64 1
d66 1
@


1.17
log
@run-shell command to run a shell command without opening a window, sending
stdout to output mode.
@
text
@d1 1
a1 1
/* $OpenBSD: cmd.c,v 1.16 2009/08/31 20:46:19 nicm Exp $ */
a91 1
	&cmd_set_password_entry,
a261 4
	if (server_locked) {
		ctx->error(ctx, "server is locked");
		return (-1);
	}
@


1.16
log
@Add a new display-panes command, with two options (display-panes-colour and
display-panes-time), which displays a visual indication of the number of each
pane.
@
text
@d1 1
a1 1
/* $OpenBSD: cmd.c,v 1.15 2009/08/25 12:18:51 nicm Exp $ */
d79 1
@


1.15
log
@Add a choose-client command and extend choose-{session,window} to accept a
template. After a choice is made, %% (or %1) in the template is replaced by the
name of the session, window or client suitable for -t and the result executed
as a command. So, for example, "choose-window "killw -t '%%'"" will kill the
selected window.

The defaults if no template is given are (as now) select-window for
choose-window, switch-client for choose-session, and detach-client for
choose-client (now bound to D).
@
text
@d1 1
a1 1
/* $OpenBSD: cmd.c,v 1.14 2009/08/23 16:45:00 nicm Exp $ */
d46 1
@


1.14
log
@The cursession member in struct cmd_ctx is always either curclient->session or
NULL when curclient is also NULL, so just eliminate it.
@
text
@d1 1
a1 1
/* $OpenBSD: cmd.c,v 1.13 2009/08/08 21:52:43 nicm Exp $ */
d34 1
d861 41
@


1.13
log
@Infrastructure and commands to manage the environment for processes started
within tmux.

There is a global environment, copied from the external environment when the
server is started and each sesssion has an (initially empty) session
environment which overrides it.

New commands set-environment and show-environment manipulate or display the
environments.

A new session option, update-environment, is a space-separated list of
variables which are updated from the external environment into the session
environment every time a new session is created - the default is DISPLAY.
@
text
@d1 1
a1 1
/* $OpenBSD: cmd.c,v 1.12 2009/07/30 13:45:56 nicm Exp $ */
d302 2
a303 2
	if (ctx->cursession != NULL)
		return (ctx->cursession);
@


1.12
log
@Merge pane number into the target specification for pane commands. Instead of
using -p index, a target pane is now addressed with the normal -t window form
but suffixed with a period and a pane index, for example :0.2 or
mysess:mywin.1. An unadorned number such as -t 1 is tried as a pane index in
the current window, if that fails the same rules are followed as for a target
window and the current pane in that window used.

As a side-effect this now means that swap-pane can swap panes between different
windows.

Note that this changes the syntax of the break-pane, clear-history, kill-pane,
resize-pane, select-pane and swap-pane commands.
@
text
@d1 1
a1 1
/* $OpenBSD: cmd.c,v 1.11 2009/07/29 17:03:16 nicm Exp $ */
d87 1
d92 1
@


1.11
log
@Add an additional heuristic to work out the current session when run from the
command line. The name of all slave ptys in the server is known, so if the
client was run on a tty, look for any sessions containing that tty and use the
most recently created.

This is more reliable than looking at $TMUX if windows have been moved or
linked between sessions.
@
text
@d1 1
a1 1
/* $OpenBSD: cmd.c,v 1.10 2009/07/26 12:58:44 nicm Exp $ */
d773 85
@


1.10
log
@Make all messages sent between the client and server fixed size.

This is the first of two changes to make the protocol more resilient and less
sensitive to other changes in the code, particularly with commands. The client
now packs argv into a buffer and sends it to the server for parsing, rather
than doing it itself and sending the parsed command data.

As a side-effect this also removes a lot of now-unused command marshalling
code.

Mixing a server without this change and a client with or vice versa will cause
tmux to hang or crash, please ensure that tmux is entirely killed before
upgrading.
@
text
@d1 1
a1 1
/* $OpenBSD: cmd.c,v 1.9 2009/07/24 18:46:40 nicm Exp $ */
d106 1
a106 1
struct session	*cmd_newest_session(void);
d284 3
a286 2
 * context has one; 2) the session specified in the TMUX variable from the
 * environment (as passed from the client); 3) the newest session.
d292 1
d294 5
d303 32
d345 1
a345 1
	return (cmd_newest_session());
d350 1
a350 1
cmd_newest_session(void)
d357 2
a358 2
	for (i = 0; i < ARRAY_LENGTH(&sessions); i++) {
		if ((s = ARRAY_ITEM(&sessions, i)) == NULL)
@


1.9
log
@cmd_find_index should return -2 on error.
@
text
@d1 1
a1 1
/* $OpenBSD: cmd.c,v 1.8 2009/07/22 21:23:29 nicm Exp $ */
d112 58
a265 47
cmd_send(struct cmd *cmd, struct buffer *b)
{
	const struct cmd_entry **entryp;
	u_int			 n;

	n = 0;
	for (entryp = cmd_table; *entryp != NULL; entryp++) {
		if (*entryp == cmd->entry)
			break;
		n++;
	}
	if (*entryp == NULL)
		fatalx("command not found");

	buffer_write(b, &n, sizeof n);

	if (cmd->entry->send != NULL)
		cmd->entry->send(cmd, b);
}

struct cmd *
cmd_recv(struct buffer *b)
{
	const struct cmd_entry **entryp;
	struct cmd   	        *cmd;
	u_int			 m, n;

	buffer_read(b, &m, sizeof m);

	n = 0;
	for (entryp = cmd_table; *entryp != NULL; entryp++) {
		if (n == m)
			break;
		n++;
	}
	if (*entryp == NULL)
		fatalx("command not found");

	cmd = xmalloc(sizeof *cmd);
	cmd->entry = *entryp;

	if (cmd->entry->recv != NULL)
		cmd->entry->recv(cmd, b);
	return (cmd);
}

void
a279 35
}

void
cmd_send_string(struct buffer *b, const char *s)
{
	size_t	n;

	if (s == NULL) {
		n = 0;
		buffer_write(b, &n, sizeof n);
		return;
	}

	n = strlen(s) + 1;
	buffer_write(b, &n, sizeof n);

	buffer_write(b, s, n);
}

char *
cmd_recv_string(struct buffer *b)
{
	char   *s;
	size_t	n;

	buffer_read(b, &n, sizeof n);

	if (n == 0)
		return (NULL);

	s = xmalloc(n);
	buffer_read(b, s, n);
	s[n - 1] = '\0';

	return (s);
@


1.8
log
@Tidy the target parsing code a bit and correct the behaviour so that as before
a string with no colon as a target window is first looked up as a window then
as a session, noted by Iain Morgan.

Also attempt to clarify the description of the target specification in the man
page.
@
text
@d1 1
a1 1
/* $OpenBSD: cmd.c,v 1.7 2009/07/17 18:45:08 nicm Exp $ */
d679 1
a679 1
		return (-1);
@


1.7
log
@- New command display-message (alias display) to display a message in the
  status line (bound to "i" and displays the current window and time by
  default). The same substitutions are applied as for status-left/right.
- Add support for including the window index (#I), pane index (#P) and window
  name (#W) in the message, and status-left or status-right.
- Bump protocol version.

From Tiago Cunha, thanks!
@
text
@d1 1
a1 1
/* $OpenBSD: cmd.c,v 1.6 2009/07/15 15:09:17 nicm Exp $ */
d110 1
d451 4
a454 2
 * Lookup a window or return -1 if not found or ambigious. First try as an index
 * and if invalid, use fnmatch or leading prefix.
a459 1
	struct window	*w;
d475 1
a475 2
		w = wl->window;
		if (strcmp(name, w->name) == 0) {
d489 2
a490 3
		w = wl->window;
		if (strncmp(name, w->name, strlen(name)) == 0 ||
		    fnmatch(name, w->name, 0) == 0) {
d504 23
d596 1
a596 1
	/* Find the separating colon. If none, assume the current session. */
d599 4
a602 8
		winptr = xstrdup(arg);
	else {
		winptr++;	/* skip : */
		sessptr = xstrdup(arg);
		*strchr(sessptr, ':') = '\0';
	}

	log_debug("%s: winptr=%s, sessptr=%s", __func__, winptr, sessptr);
d605 2
a606 2
	if (sessptr != NULL && *sessptr != '\0') {
		if  ((s = cmd_lookup_session(sessptr, &ambiguous)) == NULL)
d616 1
a616 1
	if (winptr == NULL || *winptr == '\0')
d625 15
d642 1
a642 1
		ctx->error(ctx, "multiple sessions: %s", sessptr);
d644 1
a644 1
		ctx->error(ctx, "session not found: %s", sessptr);
d662 2
a663 2
 * used when parsing an argument for a window target that may not be exist (for
 * example it is going to be created).
d669 1
a669 2
	struct winlink	*wl;
	const char	*winptr, *errstr;
d696 4
a699 8
		winptr = xstrdup(arg);
	else {
		winptr++;	/* skip : */
		sessptr = xstrdup(arg);
		*strchr(sessptr, ':') = '\0';
	}

	log_debug("%s: winptr=%s, sessptr=%s", __func__, winptr, sessptr);
d703 1
a703 1
		if  ((s = cmd_lookup_session(sessptr, &ambiguous)) == NULL)
d710 2
a711 3
	 * Then work out the window. No : means "no window" (-1), an empty
	 * string is the current window, otherwise try to look it up in the
	 * session.
d713 3
a715 5
	if (winptr == NULL)
		idx = -1;
	else if (*winptr == '\0')
		idx = s->curw->idx;
	else if ((wl = cmd_lookup_window(s, winptr, &ambiguous)) == NULL) {
d718 3
a720 8
		/* Don't care it doesn't exist if this is a valid index. */
		idx = strtonum(winptr, 0, INT_MAX, &errstr);
		if (errstr != NULL)  {
			ctx->error(ctx, "index %s: %s", errstr, winptr);
			idx = -2;
		}
	} else
		idx = wl->idx;
d726 15
d743 1
a743 1
 		ctx->error(ctx, "multiple sessions: %s", sessptr);
d745 1
a745 1
		ctx->error(ctx, "session not found: %s", sessptr);
@


1.6
log
@Return -1 not NULL on error, pointed out by Roy Marples.
@
text
@d1 1
a1 1
/* $OpenBSD: cmd.c,v 1.5 2009/07/13 17:47:46 nicm Exp $ */
d44 1
@


1.5
log
@Tidy up and improve target (-t) argument parsing:

- move the code back into cmd.c and merge with the existing functions where
  possible;
- accept "-tttyp0" as well as "-t/dev/ttyp0" for clients;
- when looking up session names, try an exact match first, and if that fails
  look for it as an fnmatch pattern and then as the start of a name - if more
  that one session matches an error is given; so if there is one session called
  "mysession", -tmysession, -tmysess, -tmysess* are equivalent but if there
  is also "mysession2", the last two are errors;
- similarly for windows, if the argument is not a valid index or exact window
  name match, try it against the window names as an fnmatch pattern and a
  prefix.
@
text
@d1 1
a1 1
/* $OpenBSD: cmd.c,v 1.4 2009/07/09 15:47:49 nicm Exp $ */
d645 1
a645 1
		return (NULL);
@


1.4
log
@New command, if-shell (alias if). Executes the tmux command in the second
argument if the shell command in the first succeeds, for example:

       if "[ -e ~/.tmux.conf.alt ]" "source .tmux.conf.alt"

Written by Tiago Cunha, many thanks.
@
text
@d1 1
a1 1
/* $OpenBSD: cmd.c,v 1.3 2009/07/07 21:23:22 nicm Exp $ */
d22 2
d105 5
d304 5
d313 1
a313 3
	struct timeval		*tv;
	struct session		*s, *newest = NULL;
	u_int			 i;
d319 1
a319 2
		if (data->pid != getpid()) {
			ctx->error(ctx, "wrong server: %ld", (long) data->pid);
d321 1
a321 3
		}
		if (data->idx > ARRAY_LENGTH(&sessions)) {
			ctx->error(ctx, "index out of range: %d", data->idx);
d323 1
a323 3
		}
		if ((s = ARRAY_ITEM(&sessions, data->idx)) == NULL) {
			ctx->error(ctx, "session doesn't exist: %u", data->idx);
a324 1
		}
d328 12
a339 1
	tv = NULL;
d341 5
a345 3
		s = ARRAY_ITEM(&sessions, i);
		if (s != NULL && (tv == NULL || timercmp(&s->tv, tv, >))) {
			newest = ARRAY_ITEM(&sessions, i);
d349 2
a350 1
	return (newest);
d353 1
d358 2
d361 1
d363 116
a478 7
		c = ctx->curclient;
	else {
		if ((c = arg_parse_client(arg)) == NULL) {
			if (arg != NULL)
				ctx->error(ctx, "client not found: %s", arg);
			else
				ctx->error(ctx, "no client found");
d481 20
a500 1
	return (c);
d503 1
d508 4
d513 1
d515 21
a535 8
		s = cmd_current_session(ctx);
	else {
		if ((s = arg_parse_session(arg)) == NULL) {
			if (arg != NULL)
				ctx->error(ctx, "session not found: %s", arg);
			else
				ctx->error(ctx, "no session found");
		}
d537 2
d542 1
d548 75
a622 1
	int		 idx;
d624 21
a644 3
	wl = NULL;
	if (arg_parse_window(arg, &s, &idx) != 0) {
		ctx->error(ctx, "bad window: %s", arg);
d647 29
a675 6
	if (s == NULL)
		s = ctx->cursession;
	if (s == NULL)
		s = cmd_current_session(ctx);
	if (s == NULL)
		return (NULL);
d679 37
a715 2
	if (idx == -1)
		wl = s->curw;
d717 4
a720 4
		wl = winlink_find_by_index(&s->windows, idx);
	if (wl == NULL)
		ctx->error(ctx, "window not found: %s:%d", s->name, idx);
	return (wl);
@


1.3
log
@Don't let ambiguous commands override an exact alias match: eg if commands
"abc-1", "abc-2", "abc-3" exist and "abc-3" has the alias "abc", "tmux abc"
should execute abc-3, not complain about the command being ambiguous.

Not a problem at the moment but will be soon.
@
text
@d1 1
a1 1
/* $OpenBSD: cmd.c,v 1.2 2009/06/04 23:34:32 nicm Exp $ */
d45 1
@


1.2
log
@Print a better message than '(null)' if no command is specified ("tmux \;").
@
text
@d1 1
a1 1
/* $OpenBSD: cmd.c,v 1.1 2009/06/01 22:58:49 nicm Exp $ */
d108 1
a108 1
	int			 opt;
d120 1
d128 1
a128 1
			goto ambiguous;
d135 2
@


1.1
log
@Import tmux, a terminal multiplexor allowing (among other things) a single
terminal to be switched between several different windows and programs
displayed on one terminal be detached from one terminal and moved to another.

ok deraadt pirofti
@
text
@d1 1
a1 1
/* $OpenBSD$ */
d111 2
a112 1
	if (argc == 0)
d114 1
@

