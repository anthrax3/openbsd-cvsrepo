head	1.41;
access;
symbols
	OPENBSD_6_2:1.41.0.2
	OPENBSD_6_2_BASE:1.41
	OPENBSD_6_1:1.39.0.4
	OPENBSD_6_1_BASE:1.39
	OPENBSD_6_0:1.35.0.2
	OPENBSD_6_0_BASE:1.35
	OPENBSD_5_9:1.34.0.2
	OPENBSD_5_9_BASE:1.34
	OPENBSD_5_8:1.24.0.6
	OPENBSD_5_8_BASE:1.24
	OPENBSD_5_7:1.24.0.2
	OPENBSD_5_7_BASE:1.24
	OPENBSD_5_6:1.23.0.4
	OPENBSD_5_6_BASE:1.23
	OPENBSD_5_5:1.22.0.4
	OPENBSD_5_5_BASE:1.22
	OPENBSD_5_4:1.21.0.2
	OPENBSD_5_4_BASE:1.21
	OPENBSD_5_3:1.18.0.2
	OPENBSD_5_3_BASE:1.18
	OPENBSD_5_2:1.16.0.2
	OPENBSD_5_2_BASE:1.16
	OPENBSD_5_1_BASE:1.11
	OPENBSD_5_1:1.11.0.10
	OPENBSD_5_0:1.11.0.8
	OPENBSD_5_0_BASE:1.11
	OPENBSD_4_9:1.11.0.6
	OPENBSD_4_9_BASE:1.11
	OPENBSD_4_8:1.11.0.4
	OPENBSD_4_8_BASE:1.11
	OPENBSD_4_7:1.11.0.2
	OPENBSD_4_7_BASE:1.11
	OPENBSD_4_6:1.3.0.4
	OPENBSD_4_6_BASE:1.3;
locks; strict;
comment	@ * @;


1.41
date	2017.07.21.12.58.02;	author nicm;	state Exp;
branches;
next	1.40;
commitid	u0jF0Zc7O6OnkfcN;

1.40
date	2017.05.01.12.20.55;	author nicm;	state Exp;
branches;
next	1.39;
commitid	sAXCoXWmq7A1UnAP;

1.39
date	2017.02.03.11.57.27;	author nicm;	state Exp;
branches;
next	1.38;
commitid	BLRh0qXo7OVTPhiT;

1.38
date	2017.01.13.11.56.43;	author nicm;	state Exp;
branches;
next	1.37;
commitid	ue6KcgTetKiECTMk;

1.37
date	2016.10.11.13.21.59;	author nicm;	state Exp;
branches;
next	1.36;
commitid	80rgEIPcNpyBnf95;

1.36
date	2016.10.10.21.29.23;	author nicm;	state Exp;
branches;
next	1.35;
commitid	z4Hr4PZF7Ev93uEJ;

1.35
date	2016.07.15.09.27.35;	author nicm;	state Exp;
branches;
next	1.34;
commitid	7le1ML1qK7W85UOt;

1.34
date	2016.01.19.15.59.12;	author nicm;	state Exp;
branches;
next	1.33;
commitid	P3qmSOx6KrDBsb0c;

1.33
date	2015.12.11.12.27.36;	author nicm;	state Exp;
branches;
next	1.32;
commitid	ns7JfXpW9TsHrnT3;

1.32
date	2015.12.08.08.34.18;	author nicm;	state Exp;
branches;
next	1.31;
commitid	MRfGAYPLeVqV46rT;

1.31
date	2015.11.18.14.27.44;	author nicm;	state Exp;
branches;
next	1.30;
commitid	RjsAPRkWwvS79w40;

1.30
date	2015.10.27.15.58.42;	author nicm;	state Exp;
branches;
next	1.29;
commitid	89xhQafU35Q5MQVC;

1.29
date	2015.08.29.00.29.15;	author nicm;	state Exp;
branches;
next	1.28;
commitid	jhCDxn7bTHMNE4FM;

1.28
date	2015.08.28.16.10.46;	author nicm;	state Exp;
branches;
next	1.27;
commitid	5Oy3Fyd66jXdISPs;

1.27
date	2015.08.28.15.51.48;	author nicm;	state Exp;
branches;
next	1.26;
commitid	blWK8QcMFPW3AUtZ;

1.26
date	2015.08.28.13.26.41;	author nicm;	state Exp;
branches;
next	1.25;
commitid	rfNdbG1WKJb1AUxa;

1.25
date	2015.08.28.07.49.24;	author nicm;	state Exp;
branches;
next	1.24;
commitid	0EjAW6v3xnwJqHbL;

1.24
date	2015.02.05.10.29.43;	author nicm;	state Exp;
branches;
next	1.23;
commitid	b1G1TVWY7l4KyoY6;

1.23
date	2014.05.13.08.08.32;	author nicm;	state Exp;
branches;
next	1.22;

1.22
date	2013.10.10.11.56.50;	author nicm;	state Exp;
branches;
next	1.21;

1.21
date	2013.03.25.15.59.57;	author nicm;	state Exp;
branches;
next	1.20;

1.20
date	2013.03.24.09.21.27;	author nicm;	state Exp;
branches;
next	1.19;

1.19
date	2013.03.22.10.31.22;	author nicm;	state Exp;
branches;
next	1.18;

1.18
date	2012.11.27.09.20.03;	author nicm;	state Exp;
branches;
next	1.17;

1.17
date	2012.08.21.10.00.33;	author nicm;	state Exp;
branches;
next	1.16;

1.16
date	2012.07.10.11.53.01;	author nicm;	state Exp;
branches;
next	1.15;

1.15
date	2012.04.11.07.45.30;	author nicm;	state Exp;
branches;
next	1.14;

1.14
date	2012.04.08.06.47.26;	author nicm;	state Exp;
branches;
next	1.13;

1.13
date	2012.03.17.18.24.07;	author nicm;	state Exp;
branches;
next	1.12;

1.12
date	2012.03.09.21.11.28;	author nicm;	state Exp;
branches;
next	1.11;

1.11
date	2009.12.03.22.50.10;	author nicm;	state Exp;
branches;
next	1.10;

1.10
date	2009.11.26.21.37.13;	author nicm;	state Exp;
branches;
next	1.9;

1.9
date	2009.11.04.23.54.57;	author nicm;	state Exp;
branches;
next	1.8;

1.8
date	2009.10.10.15.23.13;	author nicm;	state Exp;
branches;
next	1.7;

1.7
date	2009.09.20.14.58.12;	author nicm;	state Exp;
branches;
next	1.6;

1.6
date	2009.09.01.13.09.49;	author nicm;	state Exp;
branches;
next	1.5;

1.5
date	2009.08.18.21.18.20;	author nicm;	state Exp;
branches;
next	1.4;

1.4
date	2009.07.08.05.26.45;	author nicm;	state Exp;
branches;
next	1.3;

1.3
date	2009.06.05.03.13.16;	author ray;	state Exp;
branches;
next	1.2;

1.2
date	2009.06.03.04.03.16;	author ray;	state Exp;
branches;
next	1.1;

1.1
date	2009.06.01.22.58.49;	author nicm;	state Exp;
branches;
next	;


desc
@@


1.41
log
@Allow ispunct() as well as isalnum() when parsing initial window names.
@
text
@/* $OpenBSD: names.c,v 1.40 2017/05/01 12:20:55 nicm Exp $ */

/*
 * Copyright (c) 2009 Nicholas Marriott <nicholas.marriott@@gmail.com>
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF MIND, USE, DATA OR PROFITS, WHETHER
 * IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING
 * OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */

#include <sys/types.h>

#include <ctype.h>
#include <libgen.h>
#include <stdlib.h>
#include <string.h>

#include "tmux.h"

static void	 name_time_callback(int, short, void *);
static int	 name_time_expired(struct window *, struct timeval *);

static char	*format_window_name(struct window *);

static void
name_time_callback(__unused int fd, __unused short events, void *arg)
{
	struct window	*w = arg;

	/* The event loop will call check_window_name for us on the way out. */
	log_debug("@@%u name timer expired", w->id);
}

static int
name_time_expired(struct window *w, struct timeval *tv)
{
	struct timeval	offset;

	timersub(tv, &w->name_time, &offset);
	if (offset.tv_sec != 0 || offset.tv_usec > NAME_INTERVAL)
		return (0);
	return (NAME_INTERVAL - offset.tv_usec);
}

void
check_window_name(struct window *w)
{
	struct timeval	 tv, next;
	char		*name;
	int		 left;

	if (w->active == NULL)
		return;

	if (!options_get_number(w->options, "automatic-rename"))
		return;

	if (~w->active->flags & PANE_CHANGED) {
		log_debug("@@%u active pane not changed", w->id);
		return;
	}
	log_debug("@@%u active pane changed", w->id);

	gettimeofday(&tv, NULL);
	left = name_time_expired(w, &tv);
	if (left != 0) {
		if (!event_initialized(&w->name_event))
			evtimer_set(&w->name_event, name_time_callback, w);
		if (!evtimer_pending(&w->name_event, NULL)) {
			log_debug("@@%u name timer queued (%d left)", w->id,
			    left);
			timerclear(&next);
			next.tv_usec = left;
			event_add(&w->name_event, &next);
		} else {
			log_debug("@@%u name timer already queued (%d left)",
			    w->id, left);
		}
		return;
	}
	memcpy(&w->name_time, &tv, sizeof w->name_time);
	if (event_initialized(&w->name_event))
		evtimer_del(&w->name_event);

	w->active->flags &= ~PANE_CHANGED;

	name = format_window_name(w);
	if (strcmp(name, w->name) != 0) {
		log_debug("@@%u new name %s (was %s)", w->id, name, w->name);
		window_set_name(w, name);
		server_status_window(w);
	} else
		log_debug("@@%u name not changed (still %s)", w->id, w->name);

	free(name);
}

char *
default_window_name(struct window *w)
{
	char    *cmd, *s;

	cmd = cmd_stringify_argv(w->active->argc, w->active->argv);
	if (cmd != NULL && *cmd != '\0')
		s = parse_window_name(cmd);
	else
		s = parse_window_name(w->active->shell);
	free(cmd);
	return (s);
}

static char *
format_window_name(struct window *w)
{
	struct format_tree	*ft;
	const char		*fmt;
	char			*name;

	ft = format_create(NULL, NULL, FORMAT_WINDOW|w->id, 0);
	format_defaults_window(ft, w);
	format_defaults_pane(ft, w->active);

	fmt = options_get_string(w->options, "automatic-rename-format");
	name = format_expand(ft, fmt);

	format_free(ft);
	return (name);
}

char *
parse_window_name(const char *in)
{
	char	*copy, *name, *ptr;

	name = copy = xstrdup(in);
	if (strncmp(name, "exec ", (sizeof "exec ") - 1) == 0)
		name = name + (sizeof "exec ") - 1;

	while (*name == ' ' || *name == '-')
		name++;
	if ((ptr = strchr(name, ' ')) != NULL)
		*ptr = '\0';

	if (*name != '\0') {
		ptr = name + strlen(name) - 1;
		while (ptr > name &&
		    !isalnum((u_char)*ptr) &&
		    !ispunct((u_char)*ptr))
			*ptr-- = '\0';
	}

	if (*name == '/')
		name = basename(name);
	name = xstrdup(name);
	free(copy);
	return (name);
}
@


1.40
log
@In order that people can use formats like #D in #() in the status line
and not have to wait for an update when they change pane, we allow
commands to run more than once a second if the expanded form
changes. Unfortunately this can mean them being run far too often
(pretty much continually) when multiple clients exist, because some
formats (including #D) will always differ between clients.

To avoid this, give each client its own tree of jobs which means that
the same command will be different instances for each client - similar
to how we have the tag to separate commands for different panes.

GitHub issue 889; test case reported by Paul Johnson.
@
text
@d1 1
a1 1
/* $OpenBSD: names.c,v 1.39 2017/02/03 11:57:27 nicm Exp $ */
d154 3
a156 1
		while (ptr > name && !isalnum((u_char)*ptr))
@


1.39
log
@Add a window or pane id "tag" to each format tree and use it to separate
jobs, this means that if the same job is used for different windows or
panes (for example in pane-border-format), it will be run separately for
each pane.
@
text
@d1 1
a1 1
/* $OpenBSD: names.c,v 1.38 2017/01/13 11:56:43 nicm Exp $ */
d127 1
a127 1
	ft = format_create(NULL, FORMAT_WINDOW|w->id, 0);
@


1.38
log
@Make options_get_string return const string.
@
text
@d1 1
a1 1
/* $OpenBSD: names.c,v 1.37 2016/10/11 13:21:59 nicm Exp $ */
d127 1
a127 1
	ft = format_create(NULL, 0);
@


1.37
log
@Add static in window-*.c and move some internal functions out of tmux.h.
@
text
@d1 1
a1 1
/* $OpenBSD: names.c,v 1.36 2016/10/10 21:29:23 nicm Exp $ */
d124 2
a125 1
	char			*fmt, *name;
@


1.36
log
@Loads more static, except for cmd-*.c and window-*.c.
@
text
@d1 1
a1 1
/* $OpenBSD: names.c,v 1.35 2016/07/15 09:27:35 nicm Exp $ */
d28 4
a31 2
static void	name_time_callback(int, short, void *);
static int	name_time_expired(struct window *, struct timeval *);
d120 1
a120 1
char *
@


1.35
log
@Wrap some long lines and apply some static.
@
text
@d1 1
a1 1
/* $OpenBSD: names.c,v 1.34 2016/01/19 15:59:12 nicm Exp $ */
d28 2
a29 2
void	name_time_callback(int, short, void *);
int	name_time_expired(struct window *, struct timeval *);
d31 1
a31 1
void
d40 1
a40 1
int
@


1.34
log
@I no longer use my SourceForge address so replace it.
@
text
@d1 1
a1 1
/* $OpenBSD: names.c,v 1.33 2015/12/11 12:27:36 nicm Exp $ */
d76 2
a77 1
			log_debug("@@%u name timer queued (%d left)", w->id, left);
d81 4
a84 2
		} else
			log_debug("@@%u name timer already queued (%d left)", w->id, left);
@


1.33
log
@Add cmdq as an argument to format_create and add a format for the
command name (will also be used for more later).
@
text
@d1 1
a1 1
/* $OpenBSD: names.c,v 1.32 2015/12/08 08:34:18 nicm Exp $ */
d4 1
a4 1
 * Copyright (c) 2009 Nicholas Marriott <nicm@@users.sourceforge.net>
@


1.32
log
@Remove format_create_flags and just pass flags to format_create.
@
text
@d1 1
a1 1
/* $OpenBSD: names.c,v 1.31 2015/11/18 14:27:44 nicm Exp $ */
d121 1
a121 1
	ft = format_create(0);
@


1.31
log
@Use __unused rather than rolling our own.
@
text
@d1 1
a1 1
/* $OpenBSD: names.c,v 1.30 2015/10/27 15:58:42 nicm Exp $ */
d121 1
a121 1
	ft = format_create();
@


1.30
log
@Move struct options into options.c.
@
text
@d1 1
a1 1
/* $OpenBSD: names.c,v 1.29 2015/08/29 00:29:15 nicm Exp $ */
d32 1
a32 1
name_time_callback(unused int fd, unused short events, void *arg)
@


1.29
log
@Better take on reducing the name timer. Again check for name changes in
the main loop after events that may have changed the pane, but do so at
most once every 500 millis. If the pane changed too soon, use a timer to
ensure that a check happens later.
@
text
@d1 1
a1 1
/* $OpenBSD: names.c,v 1.27 2015/08/28 15:51:48 nicm Exp $ */
d61 1
a61 1
	if (!options_get_number(&w->options, "automatic-rename"))
d125 1
a125 1
	fmt = options_get_string(&w->options, "automatic-rename-format");
@


1.28
log
@Revert previous; we do need a timer, until I have a better idea. We
can't do the name check every loop, because that is too expensive, and
we can't make sure it only happens infrequently because we have no idea
when the next change will happen.
@
text
@d1 1
a1 1
/* $OpenBSD: names.c,v 1.26 2015/08/28 13:26:41 nicm Exp $ */
d28 2
a29 1
void	 window_name_callback(unused int, unused short, void *);
d32 1
a32 1
queue_window_name(struct window *w)
d34 1
a34 1
	struct timeval	tv;
d36 8
a43 2
	tv.tv_sec = 0;
	tv.tv_usec = NAME_INTERVAL * 1000L;
d45 4
a48 4
	if (event_initialized(&w->name_timer))
		evtimer_del(&w->name_timer);
	evtimer_set(&w->name_timer, window_name_callback, w);
	evtimer_add(&w->name_timer, &tv);
d52 1
a52 1
window_name_callback(unused int fd, unused short events, void *data)
d54 1
a54 1
	struct window	*w = data;
d56 1
d61 5
a65 3
	if (!options_get_number(&w->options, "automatic-rename")) {
		if (event_initialized(&w->name_timer))
			event_del(&w->name_timer);
d68 1
a68 1
	queue_window_name(w);
d70 12
a81 1
	if (~w->active->flags & PANE_CHANGED)
d83 5
d92 1
d95 3
a97 1
	}
@


1.27
log
@We now only checking for name changes when the active pane has changed,
but that can only happen when we have already been woken up by a read
event, so there is no need for a timer, we can just check the changed
flag on the end of that read event (we already loop over the windows to
check for bells etc anyway).
@
text
@d28 2
d31 1
a31 1
check_window_name(struct window *w)
d33 16
a48 1
	char	*name;
d53 3
a55 1
	if (!options_get_number(&w->options, "automatic-rename"))
d57 2
a65 1
		log_debug("@@%u new name %s (was %s)", w->id, name, w->name);
d68 1
a68 3
	} else
		log_debug("@@%u name not changed (still %s)", w->id, w->name);

@


1.26
log
@Check changed flag after restarting timer.
@
text
@d1 1
a1 1
/* $OpenBSD: names.c,v 1.25 2015/08/28 07:49:24 nicm Exp $ */
a27 2
void	 window_name_callback(unused int, unused short, void *);

d29 1
a29 1
queue_window_name(struct window *w)
d31 1
a31 16
	struct timeval	tv;

	tv.tv_sec = 0;
	tv.tv_usec = NAME_INTERVAL * 1000L;

	if (event_initialized(&w->name_timer))
		evtimer_del(&w->name_timer);
	evtimer_set(&w->name_timer, window_name_callback, w);
	evtimer_add(&w->name_timer, &tv);
}

void
window_name_callback(unused int fd, unused short events, void *data)
{
	struct window	*w = data;
	char		*name;
d36 1
a36 3
	if (!options_get_number(&w->options, "automatic-rename")) {
		if (event_initialized(&w->name_timer))
			event_del(&w->name_timer);
a37 2
	}
	queue_window_name(w);
d45 1
d48 3
a50 1
	}
@


1.25
log
@Only do the automatic-rename dance if the pane has changed (seen output,
or new active pane).
@
text
@d1 1
a1 1
/* $OpenBSD: names.c,v 1.24 2015/02/05 10:29:43 nicm Exp $ */
a52 4
	if (~w->active->flags & PANE_CHANGED)
		return;
	w->active->flags &= ~PANE_CHANGED;

d59 4
@


1.24
log
@Wrap all the individual format_* calls in a single format_defaults
functions.
@
text
@d1 1
a1 1
/* $OpenBSD: names.c,v 1.23 2014/05/13 08:08:32 nicm Exp $ */
d52 4
@


1.23
log
@If multiple arguments are given to new-session, new-window,
split-window, respawn-window or respawn-pane, pass them directly to
execvp() to help avoid quoting problems. One argument still goes to "sh
-c" like before. Requested by many over the years. Patch from J Raynor.
@
text
@d1 1
a1 1
/* $OpenBSD: names.c,v 1.22 2013/10/10 11:56:50 nicm Exp $ */
d89 2
a90 2
	format_window(ft, w);
	format_window_pane(ft, w->active);
@


1.22
log
@Add automatic-rename-format option allowing automatic rename to use
something other than pane_current_command.
@
text
@d1 1
a1 1
/* $OpenBSD: names.c,v 1.21 2013/03/25 15:59:57 nicm Exp $ */
d71 9
a79 3
	if (w->active->cmd != NULL && *w->active->cmd != '\0')
		return (parse_window_name(w->active->cmd));
	return (parse_window_name(w->active->shell));
@


1.21
log
@Revert the command-prefix change which breaks sequences of commands.
@
text
@d1 1
a1 1
/* $OpenBSD: names.c,v 1.20 2013/03/24 09:21:27 nicm Exp $ */
a24 1
#include <unistd.h>
a28 1
char	*parse_window_name(const char *);
d48 1
a48 1
	char		*name, *wname;
d60 3
a62 28
	if (w->active->screen != &w->active->base)
		name = NULL;
	else
		name = get_proc_name(w->active->fd, w->active->tty);
	if (name == NULL)
		wname = default_window_name(w);
	else {
		/*
		 * If tmux is using the default command, it will be a login
		 * shell and argv[0] may have a - prefix. Remove this if it is
		 * present. Ick.
		 */
		if (w->active->cmd != NULL && *w->active->cmd == '\0' &&
		    name != NULL && name[0] == '-' && name[1] != '\0')
			wname = parse_window_name(name + 1);
		else
			wname = parse_window_name(name);
		free(name);
	}

	if (w->active->fd == -1) {
		xasprintf(&name, "%s[dead]", wname);
		free(wname);
		wname = name;
	}

	if (strcmp(wname, w->name)) {
		window_set_name(w, wname);
d65 1
a65 1
	free(wname);
a70 2
	if (w->active->screen != &w->active->base)
		return (xstrdup("[tmux]"));
d77 17
d102 1
a102 1
	while (*name == ' ')
@


1.20
log
@Add option command-prefix which is automatically prepended to any
command (apart from a naked default-shell). The default is "exec ".
@
text
@d1 1
a1 1
/* $OpenBSD: names.c,v 1.19 2013/03/22 10:31:22 nicm Exp $ */
d29 2
a30 2
void	 window_name_callback(int, short, void *);
char	*parse_window_name(struct window *, const char *);
d76 1
a76 1
			wname = parse_window_name(w, name + 1);
d78 1
a78 1
			wname = parse_window_name(w, name);
d101 2
a102 2
		return (parse_window_name(w, w->active->cmd));
	return (parse_window_name(w, w->active->shell));
d106 1
a106 1
parse_window_name(struct window *w, const char *in)
d108 1
a108 5
	char	*copy, *name, *ptr, *prefix;
	size_t	 prefixlen;

	prefix = options_get_string(&w->options, "command-prefix");
	prefixlen = strlen(prefix);
d111 2
a112 2
	if (strncmp(name, prefix, prefixlen) == 0)
		name = name + prefixlen;
@


1.19
log
@No more lint means no more ARGSUSED.
@
text
@d1 1
a1 1
/* $OpenBSD: names.c,v 1.18 2012/11/27 09:20:03 nicm Exp $ */
d29 2
a30 2
void	 window_name_callback(unused int, unused short, void *);
char	*parse_window_name(const char *);
d76 1
a76 1
			wname = parse_window_name(name + 1);
d78 1
a78 1
			wname = parse_window_name(name);
d101 2
a102 2
		return (parse_window_name(w->active->cmd));
	return (parse_window_name(w->active->shell));
d106 1
a106 1
parse_window_name(const char *in)
d108 5
a112 1
	char	*copy, *name, *ptr;
d115 2
a116 2
	if (strncmp(name, "exec ", (sizeof "exec ") - 1) == 0)
		name = name + (sizeof "exec ") - 1;
@


1.18
log
@Fix session choice so that preferring unattached sessions actually
works, reported by Drew Frank.
@
text
@d1 1
a1 1
/* $OpenBSD: names.c,v 1.17 2012/08/21 10:00:33 nicm Exp $ */
a45 1
/* ARGSUSED */
@


1.17
log
@Fix up window reference counting and don't crash if the rename timer
fires while the window is dead but still referenced. Fixes problem
reported by Michael Scholz.
@
text
@d1 1
a1 1
/* $OpenBSD: names.c,v 1.16 2012/07/10 11:53:01 nicm Exp $ */
d79 1
a79 1
				wname = parse_window_name(name);
@


1.16
log
@xfree is not particularly helpful, remove it. From Thomas Adam.
@
text
@d1 1
a1 1
/* $OpenBSD: names.c,v 1.15 2012/04/11 07:45:30 nicm Exp $ */
d52 3
@


1.15
log
@Turn automatic-rename off properly if turned off by renaming a
window. Reported by Romain Francoise.
@
text
@d1 1
a1 1
/* $OpenBSD: names.c,v 1.14 2012/04/08 06:47:26 nicm Exp $ */
d23 1
d77 1
a77 1
		xfree(name);
d82 1
a82 1
		xfree(wname);
d90 1
a90 1
	xfree(wname);
d126 1
a126 1
	xfree(copy);
@


1.14
log
@Do not fire name timer when automatic-rename is off, from Tim Ruehsen a
while ago.
@
text
@d1 1
a1 1
/* $OpenBSD: names.c,v 1.13 2012/03/17 18:24:07 nicm Exp $ */
d52 6
a57 1
	queue_window_name(w); /* stopped when option turned off */
@


1.13
log
@Check event_initialized before event_del if event may not have been set
up; libevent2 complains about this. Reported by Moriyoshi Koizumi.
@
text
@d1 1
a1 1
/* $OpenBSD: names.c,v 1.12 2012/03/09 21:11:28 nicm Exp $ */
d52 1
a52 3
	queue_window_name(w);	/* XXX even if the option is off? */
	if (!options_get_number(&w->options, "automatic-rename"))
		return;
@


1.12
log
@Add a missing call to window_set_name, from George Nachman.
@
text
@d1 1
a1 1
/* $OpenBSD: names.c,v 1.11 2009/12/03 22:50:10 nicm Exp $ */
d39 2
a40 1
	evtimer_del(&w->name_timer);
@


1.11
log
@Massive spaces->tabs and trailing whitespace cleanup, hopefully for the last
time now I've configured emacs to make them displayed in really annoying
colours...
@
text
@d1 1
a1 1
/* $OpenBSD: names.c,v 1.10 2009/11/26 21:37:13 nicm Exp $ */
d81 2
a82 5
	if (strcmp(wname, w->name) == 0)
		xfree(wname);
	else {
		xfree(w->name);
		w->name = wname;
d85 1
@


1.10
log
@Remove a couple of unused arguments where possible, and add /* ARGSUSED */ to
the rest to reduce lint output.
@
text
@d1 1
a1 1
/* $OpenBSD: names.c,v 1.9 2009/11/04 23:54:57 nicm Exp $ */
d62 1
a62 1
		/* 
d74 1
a74 1
	
d80 1
a80 1
	
@


1.9
log
@Change window name change to use a timer event rather than a gettimeofday()
check every loop.
@
text
@d1 1
a1 1
/* $OpenBSD: names.c,v 1.8 2009/10/10 15:23:13 nicm Exp $ */
d44 1
@


1.8
log
@When a window is zombified and automatic-rename is on, append [dead] to the
name.
@
text
@d1 1
a1 1
/* $OpenBSD: names.c,v 1.7 2009/09/20 14:58:12 nicm Exp $ */
d28 1
d32 1
a32 1
set_window_names(void)
d34 1
a34 4
	struct window	*w;
	u_int		 i;
	char		*name, *wname;
	struct timeval	 tv, tv2;
d36 2
a37 2
	if (gettimeofday(&tv, NULL) != 0)
		fatal("gettimeofday failed");
d39 4
a42 11
	for (i = 0; i < ARRAY_LENGTH(&windows); i++) {
		w = ARRAY_ITEM(&windows, i);
		if (w == NULL || w->active == NULL)
			continue;

		if (timercmp(&tv, &w->name_timer, <))
			continue;
		memcpy(&w->name_timer, &tv, sizeof w->name_timer);
		tv2.tv_sec = 0;
		tv2.tv_usec = NAME_INTERVAL * 1000L;
		timeradd(&w->name_timer, &tv2, &w->name_timer);
d44 5
a48 2
		if (!options_get_number(&w->options, "automatic-rename"))
			continue;
d50 19
a68 2
		if (w->active->screen != &w->active->base)
			name = NULL;
a69 13
			name = get_proc_name(w->active->fd, w->active->tty);
		if (name == NULL)
			wname = default_window_name(w);
		else {
			/* 
			 * If tmux is using the default command, it will be a
			 * login shell and argv[0] may have a - prefix. Remove
			 * this if it is present. Ick.
			 */
			if (w->active->cmd != NULL && *w->active->cmd == '\0' &&
			    name != NULL && name[0] == '-' && name[1] != '\0')
				wname = parse_window_name(name + 1);
			else
d71 15
a85 16
			xfree(name);
		}

		if (w->active->fd == -1) {
			xasprintf(&name, "%s[dead]", wname);
			xfree(wname);
			wname = name;
		}

		if (strcmp(wname, w->name) == 0)
			xfree(wname);
		else {
			xfree(w->name);
			w->name = wname;
			server_status_window(w);
		}
@


1.7
log
@Regularise some fatal messages.
@
text
@d1 1
a1 1
/* $OpenBSD: names.c,v 1.6 2009/09/01 13:09:49 nicm Exp $ */
d74 6
@


1.6
log
@When using tmux as a login shell, there is currently no way to specify a shell
to be used as a login shell inside tmux, so add a default-shell session option.
This sets the shell invoked as a login shell when the default-command option is
empty.

The default option value is whichever of $SHELL, getpwuid(getuid())'s pw_shell
or /bin/sh is valid first.

Based on a diff from martynas@@, changed by me to be a session option rather
than a window option.
@
text
@d1 1
a1 1
/* $OpenBSD: names.c,v 1.5 2009/08/18 21:18:20 nicm Exp $ */
d39 1
a39 1
		fatal("gettimeofday");
@


1.5
log
@Move another expensive options test to after a cheaper timer check/update.
@
text
@d1 1
a1 1
/* $OpenBSD: names.c,v 1.4 2009/07/08 05:26:45 nicm Exp $ */
d93 1
a93 1
	return (parse_window_name(window_default_command()));
@


1.4
log
@Just appending -l to $SHELL to create a login shell is wrong: -l is not POSIX,
and some people may use shells which do not support it. Instead, make an empty
default-command option mean a login shell, and fork it with a - in argv[0]
which is the method used by login(1).

Also fix the automatic-rename code to handle this correctly and to strip a
leading - if present.
@
text
@d1 1
a1 1
/* $OpenBSD: names.c,v 1.3 2009/06/05 03:13:16 ray Exp $ */
a44 2
		if (!options_get_number(&w->options, "automatic-rename"))
			continue;
d52 3
@


1.3
log
@Remove trailing newlines, spaces, and tabs.

No binary change.
@
text
@d1 1
a1 1
/* $OpenBSD: names.c,v 1.2 2009/06/03 04:03:16 ray Exp $ */
d62 10
a71 1
			wname = parse_window_name(name);
d90 3
a92 1
	return (parse_window_name(w->active->cmd));
@


1.2
log
@Cast char to u_char before passing to isalnum().

OK nicm@@
@
text
@d1 1
a1 1
/* $OpenBSD: names.c,v 1.1 2009/06/01 22:58:49 nicm Exp $ */
a109 1

@


1.1
log
@Import tmux, a terminal multiplexor allowing (among other things) a single
terminal to be switched between several different windows and programs
displayed on one terminal be detached from one terminal and moved to another.

ok deraadt pirofti
@
text
@d1 1
a1 1
/* $OpenBSD$ */
d100 1
a100 1
		while (ptr > name && !isalnum(*ptr))
@

