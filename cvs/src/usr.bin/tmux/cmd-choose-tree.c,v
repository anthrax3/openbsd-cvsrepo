head	1.33;
access;
symbols
	OPENBSD_6_1:1.33.0.2
	OPENBSD_6_1_BASE:1.33
	OPENBSD_6_0:1.31.0.4
	OPENBSD_6_0_BASE:1.31
	OPENBSD_5_9:1.31.0.2
	OPENBSD_5_9_BASE:1.31
	OPENBSD_5_8:1.28.0.4
	OPENBSD_5_8_BASE:1.28
	OPENBSD_5_7:1.27.0.2
	OPENBSD_5_7_BASE:1.27
	OPENBSD_5_6:1.25.0.6
	OPENBSD_5_6_BASE:1.25
	OPENBSD_5_5:1.25.0.4
	OPENBSD_5_5_BASE:1.25
	OPENBSD_5_4:1.23.0.2
	OPENBSD_5_4_BASE:1.23
	OPENBSD_5_3:1.13.0.2
	OPENBSD_5_3_BASE:1.13
	OPENBSD_5_2:1.5.0.2
	OPENBSD_5_2_BASE:1.5;
locks; strict;
comment	@ * @;


1.33
date	2016.10.16.19.04.05;	author nicm;	state Exp;
branches;
next	1.32;
commitid	pxm6osuE99zELpkU;

1.32
date	2016.10.10.21.51.39;	author nicm;	state Exp;
branches;
next	1.31;
commitid	TaZ3kOtGiWwKofka;

1.31
date	2015.12.14.00.31.54;	author nicm;	state Exp;
branches;
next	1.30;
commitid	rE682EC14v4gpeFy;

1.30
date	2015.12.13.21.53.57;	author nicm;	state Exp;
branches;
next	1.29;
commitid	gsQkQsSyBCSmU9ax;

1.29
date	2015.12.13.14.32.38;	author nicm;	state Exp;
branches;
next	1.28;
commitid	uzMkp8Z4FE6WB6s6;

1.28
date	2015.04.27.16.25.57;	author nicm;	state Exp;
branches;
next	1.27;
commitid	0WBWxxZyxaAFVhmn;

1.27
date	2014.10.20.23.35.28;	author nicm;	state Exp;
branches;
next	1.26;
commitid	RV1NOSXD1mUR8LDP;

1.26
date	2014.10.20.22.29.25;	author nicm;	state Exp;
branches;
next	1.25;
commitid	Gq8hgMoG3t1Wy1Zv;

1.25
date	2013.10.10.12.00.18;	author nicm;	state Exp;
branches;
next	1.24;

1.24
date	2013.10.10.11.58.52;	author nicm;	state Exp;
branches;
next	1.23;

1.23
date	2013.04.22.22.17.29;	author nicm;	state Exp;
branches;
next	1.22;

1.22
date	2013.04.22.16.34.53;	author nicm;	state Exp;
branches;
next	1.21;

1.21
date	2013.03.24.09.54.10;	author nicm;	state Exp;
branches;
next	1.20;

1.20
date	2013.03.21.16.53.12;	author nicm;	state Exp;
branches;
next	1.19;

1.19
date	2013.03.21.16.23.07;	author nicm;	state Exp;
branches;
next	1.18;

1.18
date	2013.03.21.16.19.25;	author nicm;	state Exp;
branches;
next	1.17;

1.17
date	2013.03.21.16.17.35;	author nicm;	state Exp;
branches;
next	1.16;

1.16
date	2013.03.21.16.09.59;	author nicm;	state Exp;
branches;
next	1.15;

1.15
date	2013.03.21.16.09.17;	author nicm;	state Exp;
branches;
next	1.14;

1.14
date	2013.03.21.16.08.24;	author nicm;	state Exp;
branches;
next	1.13;

1.13
date	2013.01.17.03.51.21;	author nicm;	state Exp;
branches;
next	1.12;

1.12
date	2012.12.24.12.25.52;	author nicm;	state Exp;
branches;
next	1.11;

1.11
date	2012.09.24.12.53.55;	author nicm;	state Exp;
branches;
next	1.10;

1.10
date	2012.09.03.12.24.25;	author nicm;	state Exp;
branches;
next	1.9;

1.9
date	2012.09.03.09.36.07;	author nicm;	state Exp;
branches;
next	1.8;

1.8
date	2012.09.03.09.01.16;	author nicm;	state Exp;
branches;
next	1.7;

1.7
date	2012.08.14.08.51.53;	author nicm;	state Exp;
branches;
next	1.6;

1.6
date	2012.08.11.06.46.47;	author nicm;	state Exp;
branches;
next	1.5;

1.5
date	2012.07.12.13.03.42;	author nicm;	state Exp;
branches;
next	1.4;

1.4
date	2012.07.11.07.10.15;	author nicm;	state Exp;
branches;
next	1.3;

1.3
date	2012.07.10.11.53.01;	author nicm;	state Exp;
branches;
next	1.2;

1.2
date	2012.07.09.07.08.03;	author nicm;	state Exp;
branches;
next	1.1;

1.1
date	2012.07.08.16.04.38;	author nicm;	state Exp;
branches;
next	;


desc
@@


1.33
log
@Mass rename struct cmd_q to struct cmdq_item and related.
@
text
@/* $OpenBSD: cmd-choose-tree.c,v 1.32 2016/10/10 21:51:39 nicm Exp $ */

/*
 * Copyright (c) 2012 Thomas Adam <thomas@@xteddy.org>
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF MIND, USE, DATA OR PROFITS, WHETHER
 * IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING
 * OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */

#include <sys/types.h>

#include <ctype.h>
#include <stdlib.h>

#include <string.h>

#include "tmux.h"

#define CMD_CHOOSE_TREE_WINDOW_ACTION "select-window -t '%%'"
#define CMD_CHOOSE_TREE_SESSION_ACTION "switch-client -t '%%'"

/*
 * Enter choice mode to choose a session and/or window.
 */

#define CHOOSE_TREE_SESSION_TEMPLATE				\
	"#{session_name}: #{session_windows} windows"		\
	"#{?session_grouped, (group ,}"				\
	"#{session_group}#{?session_grouped,),}"		\
	"#{?session_attached, (attached),}"
#define CHOOSE_TREE_WINDOW_TEMPLATE				\
	"#{window_index}: #{window_name}#{window_flags} "	\
	"\"#{pane_title}\""

static enum cmd_retval	cmd_choose_tree_exec(struct cmd *, struct cmdq_item *);

const struct cmd_entry cmd_choose_tree_entry = {
	.name = "choose-tree",
	.alias = NULL,

	.args = { "S:W:swub:c:t:", 0, 1 },
	.usage = "[-suw] [-b session-template] [-c window template] "
		 "[-S format] [-W format] " CMD_TARGET_WINDOW_USAGE,

	.tflag = CMD_WINDOW,

	.flags = 0,
	.exec = cmd_choose_tree_exec
};

const struct cmd_entry cmd_choose_session_entry = {
	.name = "choose-session",
	.alias = NULL,

	.args = { "F:t:", 0, 1 },
	.usage = CMD_TARGET_WINDOW_USAGE " [-F format] [template]",

	.tflag = CMD_WINDOW,

	.flags = 0,
	.exec = cmd_choose_tree_exec
};

const struct cmd_entry cmd_choose_window_entry = {
	.name = "choose-window",
	.alias = NULL,

	.args = { "F:t:", 0, 1 },
	.usage = CMD_TARGET_WINDOW_USAGE "[-F format] [template]",

	.tflag = CMD_WINDOW,

	.flags = 0,
	.exec = cmd_choose_tree_exec
};

static enum cmd_retval
cmd_choose_tree_exec(struct cmd *self, struct cmdq_item *item)
{
	struct args			*args = self->args;
	struct client			*c = item->state.c;
	struct winlink			*wl = item->state.tflag.wl, *wm;
	struct session			*s = item->state.tflag.s, *s2;
	struct window_choose_data	*wcd = NULL;
	const char			*ses_template, *win_template;
	char				*final_win_action, *cur_win_template;
	char				*final_win_template_middle;
	char				*final_win_template_last;
	const char			*ses_action, *win_action;
	u_int				 cur_win, idx_ses, win_ses, win_max;
	u_int				 wflag, sflag;

	ses_template = win_template = NULL;
	ses_action = win_action = NULL;

	if (c == NULL) {
		cmdq_error(item, "no client available");
		return (CMD_RETURN_ERROR);
	}

	if (window_pane_set_mode(wl->window->active, &window_choose_mode) != 0)
		return (CMD_RETURN_NORMAL);

	/* Sort out which command this is. */
	wflag = sflag = 0;
	if (self->entry == &cmd_choose_session_entry) {
		sflag = 1;
		if ((ses_template = args_get(args, 'F')) == NULL)
			ses_template = CHOOSE_TREE_SESSION_TEMPLATE;

		if (args->argc != 0)
			ses_action = args->argv[0];
		else
			ses_action = CMD_CHOOSE_TREE_SESSION_ACTION;
	} else if (self->entry == &cmd_choose_window_entry) {
		wflag = 1;
		if ((win_template = args_get(args, 'F')) == NULL)
			win_template = CHOOSE_TREE_WINDOW_TEMPLATE;

		if (args->argc != 0)
			win_action = args->argv[0];
		else
			win_action = CMD_CHOOSE_TREE_WINDOW_ACTION;
	} else {
		wflag = args_has(args, 'w');
		sflag = args_has(args, 's');

		if ((ses_action = args_get(args, 'b')) == NULL)
			ses_action = CMD_CHOOSE_TREE_SESSION_ACTION;

		if ((win_action = args_get(args, 'c')) == NULL)
			win_action = CMD_CHOOSE_TREE_WINDOW_ACTION;

		if ((ses_template = args_get(args, 'S')) == NULL)
			ses_template = CHOOSE_TREE_SESSION_TEMPLATE;

		if ((win_template = args_get(args, 'W')) == NULL)
			win_template = CHOOSE_TREE_WINDOW_TEMPLATE;
	}

	/*
	 * If not asking for windows and sessions, assume no "-ws" given and
	 * hence display the entire tree outright.
	 */
	if (!wflag && !sflag)
		wflag = sflag = 1;

	/*
	 * If we're drawing in tree mode, including sessions, then pad the
	 * window template, otherwise just render the windows as a flat list
	 * without any padding.
	 */
	if (wflag && sflag) {
		xasprintf(&final_win_template_middle,
		    " \001tq\001> %s", win_template);
		xasprintf(&final_win_template_last,
		    " \001mq\001> %s", win_template);
	} else if (wflag) {
		final_win_template_middle = xstrdup(win_template);
		final_win_template_last = xstrdup(win_template);
	} else
		final_win_template_middle = final_win_template_last = NULL;

	idx_ses = cur_win = -1;
	RB_FOREACH(s2, sessions, &sessions) {
		idx_ses++;

		/*
		 * If we're just choosing windows, jump straight there. Note
		 * that this implies the current session, so only choose
		 * windows when the session matches this one.
		 */
		if (wflag && !sflag) {
			if (s != s2)
				continue;
			goto windows_only;
		}

		wcd = window_choose_add_session(wl->window->active,
		    c, s2, ses_template, ses_action, idx_ses);

		/* If we're just choosing sessions, skip choosing windows. */
		if (sflag && !wflag) {
			if (s == s2)
				cur_win = idx_ses;
			continue;
		}
windows_only:
		win_ses = win_max = -1;
		RB_FOREACH(wm, winlinks, &s2->windows)
			win_max++;
		RB_FOREACH(wm, winlinks, &s2->windows) {
			win_ses++;
			if (sflag && wflag)
				idx_ses++;

			if (wm == s2->curw && s == s2) {
				if (wflag && !sflag) {
					/*
					 * Then we're only counting windows.
					 * So remember which is the current
					 * window in the list.
					 */
					cur_win = win_ses;
				} else
					cur_win = idx_ses;
			}

			xasprintf(&final_win_action, "%s %s %s",
			    wcd != NULL ? wcd->command : "",
			    wcd != NULL ? ";" : "", win_action);

			if (win_ses != win_max)
				cur_win_template = final_win_template_middle;
			else
				cur_win_template = final_win_template_last;

			window_choose_add_window(wl->window->active,
			    c, s2, wm, cur_win_template,
			    final_win_action,
			    (wflag && !sflag) ? win_ses : idx_ses);

			free(final_win_action);
		}

		/*
		 * If we're just drawing windows, don't consider moving on to
		 * other sessions as we only list windows in this session.
		 */
		if (wflag && !sflag)
			break;
	}
	free(final_win_template_middle);
	free(final_win_template_last);

	window_choose_ready(wl->window->active, cur_win, NULL);

	if (args_has(args, 'u')) {
		window_choose_expand_all(wl->window->active);
		window_choose_set_current(wl->window->active, cur_win);
	}

	return (CMD_RETURN_NORMAL);
}
@


1.32
log
@Add static in cmd-* and fix a few other nits.
@
text
@d1 1
a1 1
/* $OpenBSD: cmd-choose-tree.c,v 1.31 2015/12/14 00:31:54 nicm Exp $ */
d44 1
a44 1
static enum cmd_retval	cmd_choose_tree_exec(struct cmd *, struct cmd_q *);
d87 1
a87 1
cmd_choose_tree_exec(struct cmd *self, struct cmd_q *cmdq)
d90 3
a92 3
	struct client			*c = cmdq->state.c;
	struct winlink			*wl = cmdq->state.tflag.wl, *wm;
	struct session			*s = cmdq->state.tflag.s, *s2;
d106 1
a106 1
		cmdq_error(cmdq, "no client available");
@


1.31
log
@Instead of combined flags for -c, -s, -t, split into different sets
using an enum and simplify the parsing code.
@
text
@d1 1
a1 1
/* $OpenBSD: cmd-choose-tree.c,v 1.30 2015/12/13 21:53:57 nicm Exp $ */
d44 1
a44 1
enum cmd_retval	cmd_choose_tree_exec(struct cmd *, struct cmd_q *);
d86 1
a86 1
enum cmd_retval
@


1.30
log
@Use member names in cmd_entry definitions so I stop getting confused
about the order.
@
text
@d1 1
a1 1
/* $OpenBSD: cmd-choose-tree.c,v 1.29 2015/12/13 14:32:38 nicm Exp $ */
d54 3
a56 1
	.flags = CMD_WINDOW_T,
d65 1
d67 1
a67 2
	.usage = CMD_TARGET_WINDOW_USAGE " [-F format] [template]",
	.flags = CMD_WINDOW_T,
d69 1
d80 3
a82 1
	.flags = CMD_WINDOW_T,
@


1.29
log
@Instead of every command resolving the target (-t or -s) itself, prepare
the state (client, session, winlink, pane) for it it before entering the
command. Each command provides some flags that tell the prepare step
what it is expecting.

This is a requirement for having hooks on commands (for example, if you
hook "select-window -t1:2", the hook command should to operate on window
1:2 not whatever it thinks is the current window), and should allow some
other target improvements.

The old cmd_find_* functions remain for the moment but that layer will
be dropped later.

Joint work with Thomas Adam.
@
text
@d1 1
a1 1
/* $OpenBSD: cmd-choose-tree.c,v 1.28 2015/04/27 16:25:57 nicm Exp $ */
d47 9
a55 6
	"choose-tree", NULL,
	"S:W:swub:c:t:", 0, 1,
	"[-suw] [-b session-template] [-c window template] [-S format] " \
	"[-W format] " CMD_TARGET_WINDOW_USAGE,
	CMD_WINDOW_T,
	cmd_choose_tree_exec
d59 9
a67 5
	"choose-session", NULL,
	"F:t:", 0, 1,
	CMD_TARGET_WINDOW_USAGE " [-F format] [template]",
	CMD_WINDOW_T,
	cmd_choose_tree_exec
d71 8
a78 5
	"choose-window", NULL,
	"F:t:", 0, 1,
	CMD_TARGET_WINDOW_USAGE "[-F format] [template]",
	CMD_WINDOW_T,
	cmd_choose_tree_exec
@


1.28
log
@Rewrite of the target resolution internals to be simpler and more
consistent but with much less duplication, but keeping the same internal
API. Also adds more readable aliases for some of the special tokens used
in targets (eg "{start}" instead of "^"). Some behaviours may have
changed, for example prefix matches now happen before fnmatch.
@
text
@d1 1
a1 1
/* $OpenBSD: cmd-choose-tree.c,v 1.27 2014/10/20 23:35:28 nicm Exp $ */
d51 1
a51 1
	0,
d59 1
a59 1
	0,
d67 1
a67 1
	0,
d75 3
a77 3
	struct winlink			*wl, *wm;
	struct session			*s, *s2;
	struct client			*c;
d90 1
a90 1
	if ((c = cmd_find_client(cmdq, NULL, 1)) == NULL) {
a93 3

	if ((wl = cmd_find_window(cmdq, args_get(args, 't'), &s)) == NULL)
		return (CMD_RETURN_ERROR);
@


1.27
log
@Move template defines back into .c files.
@
text
@d1 1
a1 1
/* $OpenBSD: cmd-choose-tree.c,v 1.26 2014/10/20 22:29:25 nicm Exp $ */
d90 1
a90 1
	if ((c = cmd_current_client(cmdq)) == NULL) {
@


1.26
log
@Instead of setting up the default keys by building the key struct
directly with a helper function in the cmd_entry, include a table of
bind-key commands and pass them through the command parser and a
temporary cmd_q.

As well as being smaller, this will allow default bindings to be command
sequences which will probably be needed soon.
@
text
@d1 1
a1 1
/* $OpenBSD: cmd-choose-tree.c,v 1.25 2013/10/10 12:00:18 nicm Exp $ */
d34 9
@


1.25
log
@Remove the barely-used and unnecessary command check() function.
@
text
@d1 1
a1 1
/* $OpenBSD: cmd-choose-tree.c,v 1.24 2013/10/10 11:58:52 nicm Exp $ */
a42 1
	NULL,
a50 1
	NULL,
a58 1
	NULL,
@


1.24
log
@choose-tree: Reset top when toggling items

When choose-tree is told to expand/collapse items (especially when first
rendering collapsed to just show sessions), ensure that in addition to
setting the selected item, that the item itself appears on the bottom of
the screen, rather than off screen.

This was causing rendering glitches when a very small tmux window tried
to render a list of items in choose-tree much larger than itself, and
the selected item appeared off screen, and didn't show the selection
until the selection had wrapped around to the top of the screen.
@
text
@d1 1
a1 1
/* $OpenBSD: cmd-choose-tree.c,v 1.23 2013/04/22 22:17:29 nicm Exp $ */
a43 1
	NULL,
a52 1
	NULL,
a60 1
	NULL,
@


1.23
log
@When using choose-tree -u, start with the current window
highlighted. From Thomas Adam.
@
text
@d1 1
a1 1
/* $OpenBSD: cmd-choose-tree.c,v 1.22 2013/04/22 16:34:53 nicm Exp $ */
a230 1
	window_choose_collapse_all(wl->window->active);
@


1.22
log
@Get session of -t window rather than client's window.
@
text
@d1 1
a1 1
/* $OpenBSD: cmd-choose-tree.c,v 1.21 2013/03/24 09:54:10 nicm Exp $ */
d231 1
d233 1
a233 1
	if (args_has(args, 'u'))
d235 2
@


1.21
log
@Add a command queue to standardize and simplify commands that call other
commands and allow a command to block execution of subsequent
commands. This allows run-shell and if-shell to be synchronous which has
been much requested.

Each client has a default command queue and commands are consumed one at
a time from it. A command may suspend execution from the queue by
returning CMD_RETURN_WAIT and then resume it by calling cmd_continue() -
for example run-shell does this from the callback that is fired after
the job is freed.

When the command queue becomes empty, command clients are automatically
exited (unless attaching). A callback is also fired - this is used for
nested commands in, for example, if-shell which can block execution of
the client's cmdq until a new cmdq becomes empty.

Also merge all the old error/info/print functions together and lose the
old curclient/cmdclient distinction - a cmdq is bound to one client (or
none if in the configuration file), this is a command client if
c->session is NULL otherwise an attached client.
@
text
@d1 1
a1 1
/* $OpenBSD: cmd-choose-tree.c,v 1.20 2013/03/21 16:53:12 nicm Exp $ */
d92 1
a92 4
	if ((s = c->session) == NULL)
		return (CMD_RETURN_ERROR);

	if ((wl = cmd_find_window(cmdq, args_get(args, 't'), NULL)) == NULL)
@


1.20
log
@Make choose-tree actually work again.
@
text
@d1 1
a1 1
/* $OpenBSD: cmd-choose-tree.c,v 1.19 2013/03/21 16:23:07 nicm Exp $ */
d35 1
a35 1
enum cmd_retval	cmd_choose_tree_exec(struct cmd *, struct cmd_ctx *);
d69 1
a69 1
cmd_choose_tree_exec(struct cmd *self, struct cmd_ctx *ctx)
d87 2
a88 2
	if ((c = cmd_current_client(ctx)) == NULL) {
		ctx->error(ctx, "no client available");
d95 1
a95 1
	if ((wl = cmd_find_window(ctx, args_get(args, 't'), NULL)) == NULL)
@


1.19
log
@Run session command before window in choose-tree.
@
text
@d1 1
a1 1
/* $OpenBSD: cmd-choose-tree.c,v 1.18 2013/03/21 16:19:25 nicm Exp $ */
d206 3
a208 2
			xasprintf(&final_win_action, "%s ; %s",
			    wcd ? wcd->command : "",  win_action);
@


1.18
log
@Fix constness of cmd_template_replace, window_choose_add_item and
window_choose_add_window.
@
text
@d1 1
a1 1
/* $OpenBSD: cmd-choose-tree.c,v 1.17 2013/03/21 16:17:35 nicm Exp $ */
d206 2
a207 2
			xasprintf(&final_win_action, "%s ; %s", win_action,
			    wcd ? wcd->command : "");
@


1.17
log
@Fix choose-tree usage.
@
text
@d1 1
a1 1
/* $OpenBSD: cmd-choose-tree.c,v 1.16 2013/03/21 16:09:59 nicm Exp $ */
d177 1
a177 1
		    c, s2, ses_template, (char *)ses_action, idx_ses);
@


1.16
log
@Allow choose commands to be used outside tmux, so long as at least one
client is attached.
@
text
@d1 1
a1 1
/* $OpenBSD: cmd-choose-tree.c,v 1.15 2013/03/21 16:09:17 nicm Exp $ */
d40 1
a40 1
	"[-swu] [-b session-template] [-c window template] [-S format] " \
@


1.15
log
@Remove free callback for window_choose_data objects.
@
text
@d1 1
a1 1
/* $OpenBSD: cmd-choose-tree.c,v 1.14 2013/03/21 16:08:24 nicm Exp $ */
d74 1
d87 2
a88 2
	if (ctx->curclient == NULL) {
		ctx->error(ctx, "must be run interactively");
d92 2
a93 1
	s = ctx->curclient->session;
d177 1
a177 1
		    ctx, s2, ses_template, (char *)ses_action, idx_ses);
d215 1
a215 1
			    ctx, s2, wm, cur_win_template,
@


1.14
log
@Miscellaneous tidying of choose API, including:

- rename client and session to start_client and start_session in
  window_choose_data struct. also add TREE_OTHER define and reorder
  the struct
- rename window_choose_ctx to window_choose_data_run
- don't pass a cmd_ctx into window_choose_create (will let it use a
  different client later). instead take type, session, client
- add window_choose_data_free and use it to dispose of wcd rather than
  each cmd-*.c doing it individually
- change so ref counting is done by wcd_add and wcd_free rather than
  callers
- also add a ref to tree_session
- all the callbacks except choose-client and find-window are the same so
  remove them and add window_choose_default_callback
- reorder/rename some other bits and pieces for tidyness
@
text
@d1 1
a1 1
/* $OpenBSD: cmd-choose-tree.c,v 1.13 2013/01/17 03:51:21 nicm Exp $ */
d230 1
a230 1
	window_choose_ready(wl->window->active, cur_win, NULL, NULL);
@


1.13
log
@Fix some blank line nits.
@
text
@d1 1
a1 1
/* $OpenBSD: cmd-choose-tree.c,v 1.12 2012/12/24 12:25:52 nicm Exp $ */
a36 3
void	cmd_choose_tree_callback(struct window_choose_data *);
void	cmd_choose_tree_free(struct window_choose_data *);

d230 1
a230 2
	window_choose_ready(wl->window->active, cur_win,
		cmd_choose_tree_callback, cmd_choose_tree_free);
a235 24
}

void
cmd_choose_tree_callback(struct window_choose_data *cdata)
{
	if (cdata == NULL)
		return;

	if (cdata->client->flags & CLIENT_DEAD)
		return;

	window_choose_ctx(cdata);
}

void
cmd_choose_tree_free(struct window_choose_data *cdata)
{
	cdata->session->references--;
	cdata->client->references--;

	free(cdata->ft_template);
	free(cdata->command);
	format_free(cdata->ft);
	free(cdata);
@


1.12
log
@Add a -u flag to choose-tree to start uncollapsed, from Raghavendra D
Prabhu.
@
text
@d1 1
a1 1
/* $OpenBSD: cmd-choose-tree.c,v 1.11 2012/09/24 12:53:55 nicm Exp $ */
d222 1
a263 1

@


1.11
log
@Use ACS characters for choose-tree arrows based on diff from Romain
Francoise.
@
text
@d1 1
a1 1
/* $OpenBSD: cmd-choose-tree.c,v 1.10 2012/09/03 12:24:25 nicm Exp $ */
d42 2
a43 2
	"S:W:swb:c:t:", 0, 1,
	"[-sw] [-b session-template] [-c window template] [-S format] " \
d234 3
@


1.10
log
@Use the right index when adding item in choose-tree, from Thomas Adam.
@
text
@d1 1
a1 1
/* $OpenBSD: cmd-choose-tree.c,v 1.9 2012/09/03 09:36:07 nicm Exp $ */
d152 4
a155 2
		xasprintf(&final_win_template_middle, " |-> %s", win_template);
		xasprintf(&final_win_template_last, " \\-> %s", win_template);
@


1.9
log
@Remove an unused variable.
@
text
@d1 1
a1 1
/* $OpenBSD: cmd-choose-tree.c,v 1.8 2012/09/03 09:01:16 nicm Exp $ */
d215 2
a216 1
			    final_win_action, idx_ses);
@


1.8
log
@Change format of choose-tree arrows slightly, from Romain Francoise.
@
text
@d1 1
a1 1
/* $OpenBSD: cmd-choose-tree.c,v 1.7 2012/08/14 08:51:53 nicm Exp $ */
a76 1
	struct tty			*tty;
a94 1
	tty = &ctx->curclient->tty;
@


1.7
log
@Use a separate define for each default format template and strip clutter
from the choose-tree defaults.
@
text
@d1 1
a1 1
/* $OpenBSD: cmd-choose-tree.c,v 1.6 2012/08/11 06:46:47 nicm Exp $ */
d77 1
d80 3
a82 1
	char				*final_win_action, *final_win_template;
d84 1
a84 1
	u_int				 cur_win, idx_ses, win_ses;
d96 1
d153 8
a160 6
	if (wflag && sflag)
		xasprintf(&final_win_template, "    --> %s", win_template);
	else if (wflag)
		final_win_template = xstrdup(win_template);
	else
		final_win_template = NULL;
d178 1
a178 1
			ctx, s2, ses_template, (char *)ses_action, idx_ses);
d187 3
a189 1
		win_ses = -1;
d208 6
a213 1
				wcd ? wcd->command : "");
d216 2
a217 2
				ctx, s2, wm, final_win_template,
				final_win_action, idx_ses);
d228 2
a229 1
	free(final_win_template);
@


1.6
log
@Fix a return type.
@
text
@d1 1
a1 1
/* $OpenBSD: cmd-choose-tree.c,v 1.5 2012/07/12 13:03:42 nicm Exp $ */
a29 2
#define CMD_CHOOSE_TREE_WINDOW_TEMPLATE \
    DEFAULT_WINDOW_TEMPLATE " \"#{pane_title}\""
d105 1
a105 1
			ses_template = DEFAULT_SESSION_TEMPLATE;
d114 1
a114 1
			win_template = CMD_CHOOSE_TREE_WINDOW_TEMPLATE;
d131 1
a131 1
			ses_template = DEFAULT_SESSION_TEMPLATE;
d134 1
a134 1
			win_template = CMD_CHOOSE_TREE_WINDOW_TEMPLATE;
@


1.5
log
@Nuke unused variable from Thomas Adam.
@
text
@d1 1
a1 1
/* $OpenBSD: cmd-choose-tree.c,v 1.4 2012/07/11 07:10:15 nicm Exp $ */
d37 1
a37 1
int	cmd_choose_tree_exec(struct cmd *, struct cmd_ctx *);
@


1.4
log
@Make command exec functions return an enum rather than -1/0/1 values and
add a new value to mean "leave client running but don't attach" to fix
problems with using some commands in a command sequence. Most of the
work by Thomas Adam, problem reported by "jspenguin" on SF bug 3535531.
@
text
@d1 1
a1 1
/* $OpenBSD: cmd-choose-tree.c,v 1.3 2012/07/10 11:53:01 nicm Exp $ */
a78 1
	struct tty			*tty;
a94 1
	tty = &ctx->curclient->tty;
@


1.3
log
@xfree is not particularly helpful, remove it. From Thomas Adam.
@
text
@d1 1
a1 1
/* $OpenBSD: cmd-choose-tree.c,v 1.2 2012/07/09 07:08:03 nicm Exp $ */
d73 1
a73 1
int
d92 1
a92 1
		return (-1);
d99 1
a99 1
		return (-1);
d102 1
a102 1
		return (0);
d224 1
a224 1
	return (0);
a250 1

@


1.2
log
@Fix choose-tree usage string.
@
text
@d1 1
a1 1
/* $OpenBSD: cmd-choose-tree.c,v 1.1 2012/07/08 16:04:38 nicm Exp $ */
d22 1
d210 1
a210 1
			xfree(final_win_action);
d219 1
a219 2
	if (final_win_template != NULL)
		xfree(final_win_template);
d245 2
a246 2
	xfree(cdata->ft_template);
	xfree(cdata->command);
d248 1
a248 1
	xfree(cdata);
@


1.1
log
@Add choose-tree command to show windows and sessions in the same
list. Change choose-window and -session to use the same code. From
Thomas Adam.
@
text
@d1 1
a1 1
/* $OpenBSD$ */
d44 2
a45 2
	"[-SW] [-s format] [-w format ] [-b session template] " \
	"[-c window template] " CMD_TARGET_WINDOW_USAGE,
@

