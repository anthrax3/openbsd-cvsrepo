head	1.184;
access;
symbols
	OPENBSD_6_2:1.184.0.2
	OPENBSD_6_2_BASE:1.184
	OPENBSD_6_1:1.178.0.4
	OPENBSD_6_1_BASE:1.178
	OPENBSD_6_0:1.170.0.2
	OPENBSD_6_0_BASE:1.170
	OPENBSD_5_9:1.164.0.2
	OPENBSD_5_9_BASE:1.164
	OPENBSD_5_8:1.137.0.4
	OPENBSD_5_8_BASE:1.137
	OPENBSD_5_7:1.135.0.2
	OPENBSD_5_7_BASE:1.135
	OPENBSD_5_6:1.131.0.4
	OPENBSD_5_6_BASE:1.131
	OPENBSD_5_5:1.129.0.4
	OPENBSD_5_5_BASE:1.129
	OPENBSD_5_4:1.120.0.2
	OPENBSD_5_4_BASE:1.120
	OPENBSD_5_3:1.114.0.2
	OPENBSD_5_3_BASE:1.114
	OPENBSD_5_2:1.112.0.2
	OPENBSD_5_2_BASE:1.112
	OPENBSD_5_1_BASE:1.108
	OPENBSD_5_1:1.108.0.2
	OPENBSD_5_0:1.104.0.2
	OPENBSD_5_0_BASE:1.104
	OPENBSD_4_9:1.103.0.2
	OPENBSD_4_9_BASE:1.103
	OPENBSD_4_8:1.86.0.2
	OPENBSD_4_8_BASE:1.86
	OPENBSD_4_7:1.73.0.2
	OPENBSD_4_7_BASE:1.73
	OPENBSD_4_6:1.11.0.4
	OPENBSD_4_6_BASE:1.11;
locks; strict;
comment	@ * @;


1.184
date	2017.07.12.09.21.25;	author nicm;	state Exp;
branches;
next	1.183;
commitid	1yAGUDv9FQeUA9gG;

1.183
date	2017.07.03.08.08.30;	author nicm;	state Exp;
branches;
next	1.182;
commitid	xcZSUlm2aZLRHnBn;

1.182
date	2017.04.22.12.08.41;	author nicm;	state Exp;
branches;
next	1.181;
commitid	nT0YDSWP4lX6n1AT;

1.181
date	2017.04.20.17.49.26;	author nicm;	state Exp;
branches;
next	1.180;
commitid	OfL2Obmz7xdpsjZq;

1.180
date	2017.04.19.12.44.29;	author nicm;	state Exp;
branches;
next	1.179;
commitid	Ec8oUUgNbkWjai5b;

1.179
date	2017.04.16.20.33.46;	author nicm;	state Exp;
branches;
next	1.178;
commitid	vP9rrhD1Gq8vmtPr;

1.178
date	2017.03.21.19.28.03;	author nicm;	state Exp;
branches;
next	1.177;
commitid	qkqkuMtu1wkBgoN5;

1.177
date	2017.02.16.10.53.25;	author nicm;	state Exp;
branches;
next	1.176;
commitid	LqXOE9qmWQgnS4l6;

1.176
date	2017.01.23.10.09.43;	author nicm;	state Exp;
branches;
next	1.175;
commitid	anZBbATBZNigju2F;

1.175
date	2017.01.15.20.48.41;	author nicm;	state Exp;
branches;
next	1.174;
commitid	osUO2wUOqrqm0Q8V;

1.174
date	2017.01.12.15.36.35;	author nicm;	state Exp;
branches;
next	1.173;
commitid	TxelVequscBivd6R;

1.173
date	2016.12.09.21.39.27;	author nicm;	state Exp;
branches;
next	1.172;
commitid	bj3djzEC5gw7ET61;

1.172
date	2016.10.11.13.21.59;	author nicm;	state Exp;
branches;
next	1.171;
commitid	80rgEIPcNpyBnf95;

1.171
date	2016.10.10.21.29.23;	author nicm;	state Exp;
branches;
next	1.170;
commitid	z4Hr4PZF7Ev93uEJ;

1.170
date	2016.05.27.17.05.42;	author nicm;	state Exp;
branches;
next	1.169;
commitid	1MCy1pI3Tx6IhcqA;

1.169
date	2016.05.04.21.29.47;	author nicm;	state Exp;
branches;
next	1.168;
commitid	JcCWCLGZfhLngRPL;

1.168
date	2016.03.05.16.08.38;	author nicm;	state Exp;
branches;
next	1.167;
commitid	XDN7g1ZfFs63rnAZ;

1.167
date	2016.03.05.07.44.31;	author nicm;	state Exp;
branches;
next	1.166;
commitid	mvfthabu4XhsMndH;

1.166
date	2016.03.01.12.02.54;	author nicm;	state Exp;
branches;
next	1.165;
commitid	DNRtqSE6EwQYHJix;

1.165
date	2016.03.01.12.02.08;	author nicm;	state Exp;
branches;
next	1.164;
commitid	waz0Ov6Cd4sWsxcD;

1.164
date	2016.01.19.15.59.12;	author nicm;	state Exp;
branches;
next	1.163;
commitid	P3qmSOx6KrDBsb0c;

1.163
date	2015.12.08.01.10.31;	author nicm;	state Exp;
branches;
next	1.162;
commitid	Q7y3PTVPjE0eQDqD;

1.162
date	2015.11.24.23.46.15;	author nicm;	state Exp;
branches;
next	1.161;
commitid	0H2a77mNskMnXKL5;

1.161
date	2015.11.24.23.22.51;	author nicm;	state Exp;
branches;
next	1.160;
commitid	GfId0ZOaXFcgaWPG;

1.160
date	2015.11.24.22.27.22;	author nicm;	state Exp;
branches;
next	1.159;
commitid	h20Fi6Gop7tu9Q4A;

1.159
date	2015.11.24.22.09.53;	author nicm;	state Exp;
branches;
next	1.158;
commitid	LFqJCh5yf7fWQiQg;

1.158
date	2015.11.24.21.52.06;	author nicm;	state Exp;
branches;
next	1.157;
commitid	Wy0S0Ml5dOX2TIOy;

1.157
date	2015.11.24.21.19.46;	author nicm;	state Exp;
branches;
next	1.156;
commitid	WYqwkdfYHZzn9ayb;

1.156
date	2015.11.22.19.41.19;	author nicm;	state Exp;
branches;
next	1.155;
commitid	eQiXkQ2tR16i0GKB;

1.155
date	2015.11.20.12.01.19;	author nicm;	state Exp;
branches;
next	1.154;
commitid	qNEZpcD0RcTrAsAp;

1.154
date	2015.11.15.14.32.48;	author nicm;	state Exp;
branches;
next	1.153;
commitid	Vya5bw5HIjQNToOw;

1.153
date	2015.11.14.09.41.07;	author nicm;	state Exp;
branches;
next	1.152;
commitid	FQoND7M2BC89FZoU;

1.152
date	2015.11.12.11.24.08;	author nicm;	state Exp;
branches;
next	1.151;
commitid	2KnweJiuCnHkEJNY;

1.151
date	2015.11.12.11.09.11;	author nicm;	state Exp;
branches;
next	1.150;
commitid	tEN3cHiOuN3KscbT;

1.150
date	2015.11.11.23.23.33;	author nicm;	state Exp;
branches;
next	1.149;
commitid	UDT9ROGWpISBYjbt;

1.149
date	2015.10.28.09.51.55;	author nicm;	state Exp;
branches;
next	1.148;
commitid	eGVGKzVVYKHFvkn4;

1.148
date	2015.10.27.15.58.42;	author nicm;	state Exp;
branches;
next	1.147;
commitid	89xhQafU35Q5MQVC;

1.147
date	2015.10.27.13.23.24;	author nicm;	state Exp;
branches;
next	1.146;
commitid	g6GdEJXfBNprXHEK;

1.146
date	2015.10.25.07.48.16;	author deraadt;	state Exp;
branches;
next	1.145;
commitid	hFK6bPWkftGm5Y8j;

1.145
date	2015.10.23.16.07.29;	author nicm;	state Exp;
branches;
next	1.144;
commitid	xGflsqvIYR0qhE2C;

1.144
date	2015.09.14.12.12.24;	author nicm;	state Exp;
branches;
next	1.143;
commitid	xVCL5voCgiBYCoIy;

1.143
date	2015.09.03.14.30.23;	author nicm;	state Exp;
branches;
next	1.142;
commitid	bw4E49eG9lQRqXVw;

1.142
date	2015.09.01.10.10.59;	author nicm;	state Exp;
branches;
next	1.141;
commitid	d18I0q3dD3BLOXHE;

1.141
date	2015.08.30.22.56.36;	author nicm;	state Exp;
branches;
next	1.140;
commitid	xUatsx2gIvYjL0KZ;

1.140
date	2015.08.30.22.40.25;	author nicm;	state Exp;
branches;
next	1.139;
commitid	O1jOOL2q5ONABWr1;

1.139
date	2015.08.30.22.19.07;	author nicm;	state Exp;
branches;
next	1.138;
commitid	nMCE84XHv5ujel0H;

1.138
date	2015.08.30.15.43.40;	author nicm;	state Exp;
branches;
next	1.137;
commitid	uXV0qaBWQpBShfys;

1.137
date	2015.07.20.15.50.04;	author nicm;	state Exp;
branches;
next	1.136;
commitid	XjcnBmI1AcHx5t2a;

1.136
date	2015.06.04.20.34.22;	author jmc;	state Exp;
branches;
next	1.135;
commitid	bT7B3nzhy22zfVcE;

1.135
date	2015.01.19.09.58.34;	author nicm;	state Exp;
branches;
next	1.134;
commitid	dIxvlTxY2Q5dA2Ry;

1.134
date	2015.01.19.09.57.33;	author nicm;	state Exp;
branches;
next	1.133;
commitid	uK2IovZlLITGTAQH;

1.133
date	2015.01.19.09.53.15;	author nicm;	state Exp;
branches;
next	1.132;
commitid	Sat6oDhDLtl1o3x6;

1.132
date	2014.10.20.23.27.14;	author nicm;	state Exp;
branches;
next	1.131;
commitid	BAMrPS0saBiCc8HD;

1.131
date	2014.04.17.07.55.43;	author nicm;	state Exp;
branches;
next	1.130;

1.130
date	2014.03.31.21.42.45;	author nicm;	state Exp;
branches;
next	1.129;

1.129
date	2014.02.16.12.45.17;	author nicm;	state Exp;
branches;
next	1.128;

1.128
date	2014.01.15.11.46.28;	author nicm;	state Exp;
branches;
next	1.127;

1.127
date	2014.01.09.14.05.55;	author nicm;	state Exp;
branches;
next	1.126;

1.126
date	2013.10.10.12.29.35;	author nicm;	state Exp;
branches;
next	1.125;

1.125
date	2013.10.10.12.26.36;	author nicm;	state Exp;
branches;
next	1.124;

1.124
date	2013.10.10.12.12.08;	author nicm;	state Exp;
branches;
next	1.123;

1.123
date	2013.10.10.12.03.22;	author nicm;	state Exp;
branches;
next	1.122;

1.122
date	2013.10.05.10.40.49;	author nicm;	state Exp;
branches;
next	1.121;

1.121
date	2013.10.05.08.12.39;	author nicm;	state Exp;
branches;
next	1.120;

1.120
date	2013.04.24.10.01.32;	author nicm;	state Exp;
branches;
next	1.119;

1.119
date	2013.04.11.21.52.18;	author nicm;	state Exp;
branches;
next	1.118;

1.118
date	2013.03.27.11.24.18;	author nicm;	state Exp;
branches;
next	1.117;

1.117
date	2013.03.27.11.17.12;	author nicm;	state Exp;
branches;
next	1.116;

1.116
date	2013.03.25.10.11.45;	author nicm;	state Exp;
branches;
next	1.115;

1.115
date	2013.03.24.09.54.10;	author nicm;	state Exp;
branches;
next	1.114;

1.114
date	2012.11.27.16.12.29;	author nicm;	state Exp;
branches;
next	1.113;

1.113
date	2012.11.26.11.35.28;	author nicm;	state Exp;
branches;
next	1.112;

1.112
date	2012.07.10.11.53.01;	author nicm;	state Exp;
branches;
next	1.111;

1.111
date	2012.06.18.13.16.42;	author nicm;	state Exp;
branches;
next	1.110;

1.110
date	2012.05.30.15.01.21;	author nicm;	state Exp;
branches;
next	1.109;

1.109
date	2012.05.25.08.28.10;	author nicm;	state Exp;
branches;
next	1.108;

1.108
date	2012.01.21.08.40.09;	author nicm;	state Exp;
branches;
next	1.107;

1.107
date	2011.10.23.08.34.01;	author nicm;	state Exp;
branches;
next	1.106;

1.106
date	2011.10.23.08.03.27;	author nicm;	state Exp;
branches;
next	1.105;

1.105
date	2011.09.25.18.53.04;	author nicm;	state Exp;
branches;
next	1.104;

1.104
date	2011.03.04.23.26.44;	author nicm;	state Exp;
branches;
next	1.103;

1.103
date	2011.01.23.11.03.43;	author nicm;	state Exp;
branches;
next	1.102;

1.102
date	2011.01.12.22.23.58;	author nicm;	state Exp;
branches;
next	1.101;

1.101
date	2011.01.08.01.52.37;	author nicm;	state Exp;
branches;
next	1.100;

1.100
date	2011.01.03.23.35.21;	author nicm;	state Exp;
branches;
next	1.99;

1.99
date	2011.01.01.16.51.21;	author nicm;	state Exp;
branches;
next	1.98;

1.98
date	2010.12.30.23.16.18;	author nicm;	state Exp;
branches;
next	1.97;

1.97
date	2010.12.19.18.35.08;	author nicm;	state Exp;
branches;
next	1.96;

1.96
date	2010.12.08.19.57.03;	author nicm;	state Exp;
branches;
next	1.95;

1.95
date	2010.12.06.22.51.02;	author nicm;	state Exp;
branches;
next	1.94;

1.94
date	2010.11.29.19.45.58;	author nicm;	state Exp;
branches;
next	1.93;

1.93
date	2010.11.11.21.06.09;	author nicm;	state Exp;
branches;
next	1.92;

1.92
date	2010.10.18.20.00.03;	author nicm;	state Exp;
branches;
next	1.91;

1.91
date	2010.10.16.08.42.35;	author nicm;	state Exp;
branches;
next	1.90;

1.90
date	2010.10.16.08.31.55;	author nicm;	state Exp;
branches;
next	1.89;

1.89
date	2010.10.14.17.38.39;	author nicm;	state Exp;
branches;
next	1.88;

1.88
date	2010.09.26.20.43.30;	author nicm;	state Exp;
branches;
next	1.87;

1.87
date	2010.08.19.18.29.01;	author nicm;	state Exp;
branches;
next	1.86;

1.86
date	2010.08.04.19.46.13;	author deraadt;	state Exp;
branches;
next	1.85;

1.85
date	2010.07.24.19.25.31;	author nicm;	state Exp;
branches;
next	1.84;

1.84
date	2010.07.11.17.06.45;	author nicm;	state Exp;
branches;
next	1.83;

1.83
date	2010.06.28.22.10.42;	author nicm;	state Exp;
branches;
next	1.82;

1.82
date	2010.06.27.02.56.59;	author nicm;	state Exp;
branches;
next	1.81;

1.81
date	2010.06.27.00.22.22;	author nicm;	state Exp;
branches;
next	1.80;

1.80
date	2010.06.26.18.20.53;	author nicm;	state Exp;
branches;
next	1.79;

1.79
date	2010.05.14.19.03.09;	author nicm;	state Exp;
branches;
next	1.78;

1.78
date	2010.05.04.17.28.16;	author nicm;	state Exp;
branches;
next	1.77;

1.77
date	2010.05.04.08.48.06;	author nicm;	state Exp;
branches;
next	1.76;

1.76
date	2010.05.03.16.06.32;	author nicm;	state Exp;
branches;
next	1.75;

1.75
date	2010.04.28.18.22.32;	author nicm;	state Exp;
branches;
next	1.74;

1.74
date	2010.04.18.13.41.29;	author nicm;	state Exp;
branches;
next	1.73;

1.73
date	2010.02.22.20.41.16;	author nicm;	state Exp;
branches;
next	1.72;

1.72
date	2010.02.08.00.14.38;	author nicm;	state Exp;
branches;
next	1.71;

1.71
date	2010.02.06.18.47.41;	author nicm;	state Exp;
branches;
next	1.70;

1.70
date	2010.02.06.18.29.15;	author nicm;	state Exp;
branches;
next	1.69;

1.69
date	2010.02.06.17.15.33;	author nicm;	state Exp;
branches;
next	1.68;

1.68
date	2010.02.04.18.27.06;	author nicm;	state Exp;
branches;
next	1.67;

1.67
date	2010.02.04.18.20.16;	author nicm;	state Exp;
branches;
next	1.66;

1.66
date	2010.01.03.12.51.05;	author nicm;	state Exp;
branches;
next	1.65;

1.65
date	2009.12.14.10.43.41;	author nicm;	state Exp;
branches;
next	1.64;

1.64
date	2009.12.11.13.58.48;	author nicm;	state Exp;
branches;
next	1.63;

1.63
date	2009.12.10.09.16.52;	author nicm;	state Exp;
branches;
next	1.62;

1.62
date	2009.12.03.22.50.10;	author nicm;	state Exp;
branches;
next	1.61;

1.61
date	2009.11.26.21.37.13;	author nicm;	state Exp;
branches;
next	1.60;

1.60
date	2009.11.19.16.22.10;	author nicm;	state Exp;
branches;
next	1.59;

1.59
date	2009.11.19.14.06.34;	author nicm;	state Exp;
branches;
next	1.58;

1.58
date	2009.11.18.13.16.33;	author nicm;	state Exp;
branches;
next	1.57;

1.57
date	2009.11.10.18.53.11;	author nicm;	state Exp;
branches;
next	1.56;

1.56
date	2009.11.04.20.59.22;	author nicm;	state Exp;
branches;
next	1.55;

1.55
date	2009.11.04.20.50.11;	author nicm;	state Exp;
branches;
next	1.54;

1.54
date	2009.11.04.12.41.43;	author nicm;	state Exp;
branches;
next	1.53;

1.53
date	2009.10.26.21.42.04;	author deraadt;	state Exp;
branches;
next	1.52;

1.52
date	2009.10.25.21.11.21;	author nicm;	state Exp;
branches;
next	1.51;

1.51
date	2009.10.22.10.04.07;	author nicm;	state Exp;
branches;
next	1.50;

1.50
date	2009.10.21.20.11.47;	author nicm;	state Exp;
branches;
next	1.49;

1.49
date	2009.10.10.14.51.16;	author nicm;	state Exp;
branches;
next	1.48;

1.48
date	2009.10.10.09.46.11;	author nicm;	state Exp;
branches;
next	1.47;

1.47
date	2009.10.09.07.27.00;	author nicm;	state Exp;
branches;
next	1.46;

1.46
date	2009.09.23.12.03.31;	author nicm;	state Exp;
branches;
next	1.45;

1.45
date	2009.09.23.06.18.48;	author nicm;	state Exp;
branches;
next	1.44;

1.44
date	2009.09.22.12.38.10;	author nicm;	state Exp;
branches;
next	1.43;

1.43
date	2009.09.18.15.19.27;	author nicm;	state Exp;
branches;
next	1.42;

1.42
date	2009.09.04.15.15.24;	author nicm;	state Exp;
branches;
next	1.41;

1.41
date	2009.09.02.17.34.57;	author nicm;	state Exp;
branches;
next	1.40;

1.40
date	2009.09.02.16.38.35;	author nicm;	state Exp;
branches;
next	1.39;

1.39
date	2009.09.01.13.09.50;	author nicm;	state Exp;
branches;
next	1.38;

1.38
date	2009.09.01.09.11.05;	author nicm;	state Exp;
branches;
next	1.37;

1.37
date	2009.09.01.09.00.54;	author nicm;	state Exp;
branches;
next	1.36;

1.36
date	2009.08.31.20.46.19;	author nicm;	state Exp;
branches;
next	1.35;

1.35
date	2009.08.23.18.21.02;	author nicm;	state Exp;
branches;
next	1.34;

1.34
date	2009.08.13.21.56.14;	author nicm;	state Exp;
branches;
next	1.33;

1.33
date	2009.08.13.20.11.58;	author nicm;	state Exp;
branches;
next	1.32;

1.32
date	2009.08.12.09.14.25;	author nicm;	state Exp;
branches;
next	1.31;

1.31
date	2009.08.11.17.18.35;	author nicm;	state Exp;
branches;
next	1.30;

1.30
date	2009.08.10.20.51.29;	author nicm;	state Exp;
branches;
next	1.29;

1.29
date	2009.08.08.21.52.43;	author nicm;	state Exp;
branches;
next	1.28;

1.28
date	2009.08.08.20.36.42;	author nicm;	state Exp;
branches;
next	1.27;

1.27
date	2009.08.05.16.26.38;	author nicm;	state Exp;
branches;
next	1.26;

1.26
date	2009.08.04.10.31.28;	author nicm;	state Exp;
branches;
next	1.25;

1.25
date	2009.08.03.14.10.54;	author nicm;	state Exp;
branches;
next	1.24;

1.24
date	2009.07.30.07.04.50;	author nicm;	state Exp;
branches;
next	1.23;

1.23
date	2009.07.29.14.17.26;	author nicm;	state Exp;
branches;
next	1.22;

1.22
date	2009.07.29.05.36.53;	author nicm;	state Exp;
branches;
next	1.21;

1.21
date	2009.07.26.12.58.44;	author nicm;	state Exp;
branches;
next	1.20;

1.20
date	2009.07.22.21.58.56;	author nicm;	state Exp;
branches;
next	1.19;

1.19
date	2009.07.20.14.37.51;	author nicm;	state Exp;
branches;
next	1.18;

1.18
date	2009.07.20.14.32.09;	author nicm;	state Exp;
branches;
next	1.17;

1.17
date	2009.07.20.09.15.18;	author nicm;	state Exp;
branches;
next	1.16;

1.16
date	2009.07.18.14.59.25;	author nicm;	state Exp;
branches;
next	1.15;

1.15
date	2009.07.17.13.38.03;	author nicm;	state Exp;
branches;
next	1.14;

1.14
date	2009.07.10.05.50.54;	author nicm;	state Exp;
branches;
next	1.13;

1.13
date	2009.07.08.05.26.45;	author nicm;	state Exp;
branches;
next	1.12;

1.12
date	2009.07.07.19.49.19;	author nicm;	state Exp;
branches;
next	1.11;

1.11
date	2009.06.25.06.54.32;	author nicm;	state Exp;
branches;
next	1.10;

1.10
date	2009.06.25.06.40.25;	author nicm;	state Exp;
branches;
next	1.9;

1.9
date	2009.06.23.18.27.40;	author nicm;	state Exp;
branches;
next	1.8;

1.8
date	2009.06.05.07.22.23;	author nicm;	state Exp;
branches;
next	1.7;

1.7
date	2009.06.04.21.56.14;	author nicm;	state Exp;
branches;
next	1.6;

1.6
date	2009.06.03.17.04.16;	author nicm;	state Exp;
branches;
next	1.5;

1.5
date	2009.06.03.16.54.26;	author nicm;	state Exp;
branches;
next	1.4;

1.4
date	2009.06.02.16.53.20;	author sobrado;	state Exp;
branches;
next	1.3;

1.3
date	2009.06.02.15.55.32;	author pyr;	state Exp;
branches;
next	1.2;

1.2
date	2009.06.02.10.49.40;	author ray;	state Exp;
branches;
next	1.1;

1.1
date	2009.06.01.22.58.49;	author nicm;	state Exp;
branches;
next	;


desc
@@


1.184
log
@Make shell_command a global like other stuff rather than making it an
exception and using callback argument.
@
text
@/* $OpenBSD: tmux.c,v 1.183 2017/07/03 08:08:30 nicm Exp $ */

/*
 * Copyright (c) 2007 Nicholas Marriott <nicholas.marriott@@gmail.com>
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF MIND, USE, DATA OR PROFITS, WHETHER
 * IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING
 * OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */

#include <sys/types.h>
#include <sys/stat.h>

#include <err.h>
#include <errno.h>
#include <event.h>
#include <fcntl.h>
#include <langinfo.h>
#include <locale.h>
#include <paths.h>
#include <pwd.h>
#include <stdlib.h>
#include <string.h>
#include <time.h>
#include <unistd.h>
#include <util.h>

#include "tmux.h"

struct options	*global_options;	/* server options */
struct options	*global_s_options;	/* session options */
struct options	*global_w_options;	/* window options */
struct environ	*global_environ;
struct hooks	*global_hooks;

struct timeval	 start_time;
const char	*socket_path;
int		 ptm_fd = -1;
const char	*shell_command;

static __dead void	 usage(void);
static char		*make_label(const char *);

static const char	*getshell(void);
static int		 checkshell(const char *);

static __dead void
usage(void)
{
	fprintf(stderr,
	    "usage: %s [-2Cluv] [-c shell-command] [-f file] [-L socket-name]\n"
	    "            [-S socket-path] [command [flags]]\n",
	    getprogname());
	exit(1);
}

static const char *
getshell(void)
{
	struct passwd	*pw;
	const char	*shell;

	shell = getenv("SHELL");
	if (checkshell(shell))
		return (shell);

	pw = getpwuid(getuid());
	if (pw != NULL && checkshell(pw->pw_shell))
		return (pw->pw_shell);

	return (_PATH_BSHELL);
}

static int
checkshell(const char *shell)
{
	if (shell == NULL || *shell != '/')
		return (0);
	if (areshell(shell))
		return (0);
	if (access(shell, X_OK) != 0)
		return (0);
	return (1);
}

int
areshell(const char *shell)
{
	const char	*progname, *ptr;

	if ((ptr = strrchr(shell, '/')) != NULL)
		ptr++;
	else
		ptr = shell;
	progname = getprogname();
	if (*progname == '-')
		progname++;
	if (strcmp(ptr, progname) == 0)
		return (1);
	return (0);
}

static char *
make_label(const char *label)
{
	char		*base, resolved[PATH_MAX], *path, *s;
	struct stat	 sb;
	uid_t		 uid;
	int		 saved_errno;

	if (label == NULL)
		label = "default";
	uid = getuid();

	if ((s = getenv("TMUX_TMPDIR")) != NULL && *s != '\0')
		xasprintf(&base, "%s/tmux-%ld", s, (long)uid);
	else
		xasprintf(&base, "%s/tmux-%ld", _PATH_TMP, (long)uid);

	if (mkdir(base, S_IRWXU) != 0 && errno != EEXIST)
		goto fail;

	if (lstat(base, &sb) != 0)
		goto fail;
	if (!S_ISDIR(sb.st_mode)) {
		errno = ENOTDIR;
		goto fail;
	}
	if (sb.st_uid != uid || (sb.st_mode & S_IRWXO) != 0) {
		errno = EACCES;
		goto fail;
	}

	if (realpath(base, resolved) == NULL)
		strlcpy(resolved, base, sizeof resolved);
	xasprintf(&path, "%s/%s", resolved, label);

	free(base);
	return (path);

fail:
	saved_errno = errno;
	free(base);
	errno = saved_errno;
	return (NULL);
}

void
setblocking(int fd, int state)
{
	int mode;

	if ((mode = fcntl(fd, F_GETFL)) != -1) {
		if (!state)
			mode |= O_NONBLOCK;
		else
			mode &= ~O_NONBLOCK;
		fcntl(fd, F_SETFL, mode);
	}
}

const char *
find_home(void)
{
	struct passwd		*pw;
	static const char	*home;

	if (home != NULL)
		return (home);

	home = getenv("HOME");
	if (home == NULL || *home == '\0') {
		pw = getpwuid(getuid());
		if (pw != NULL)
			home = pw->pw_dir;
		else
			home = NULL;
	}

	return (home);
}

int
main(int argc, char **argv)
{
	char					*path, *label, **var;
	char					 tmp[PATH_MAX];
	const char				*s, *shell;
	int					 opt, flags, keys;
	const struct options_table_entry	*oe;

	if (setlocale(LC_CTYPE, "en_US.UTF-8") == NULL &&
	    setlocale(LC_CTYPE, "C.UTF-8") == NULL) {
		if (setlocale(LC_CTYPE, "") == NULL)
			errx(1, "invalid LC_ALL, LC_CTYPE or LANG");
		s = nl_langinfo(CODESET);
		if (strcasecmp(s, "UTF-8") != 0 && strcasecmp(s, "UTF8") != 0)
			errx(1, "need UTF-8 locale (LC_CTYPE) but have %s", s);
	}

	setlocale(LC_TIME, "");
	tzset();

	if (**argv == '-')
		flags = CLIENT_LOGIN;
	else
		flags = 0;

	label = path = NULL;
	while ((opt = getopt(argc, argv, "2c:Cdf:lL:qS:uUv")) != -1) {
		switch (opt) {
		case '2':
			flags |= CLIENT_256COLOURS;
			break;
		case 'c':
			shell_command = optarg;
			break;
		case 'C':
			if (flags & CLIENT_CONTROL)
				flags |= CLIENT_CONTROLCONTROL;
			else
				flags |= CLIENT_CONTROL;
			break;
		case 'f':
			set_cfg_file(optarg);
			break;
		case 'l':
			flags |= CLIENT_LOGIN;
			break;
		case 'L':
			free(label);
			label = xstrdup(optarg);
			break;
		case 'q':
			break;
		case 'S':
			free(path);
			path = xstrdup(optarg);
			break;
		case 'u':
			flags |= CLIENT_UTF8;
			break;
		case 'v':
			log_add_level();
			break;
		default:
			usage();
		}
	}
	argc -= optind;
	argv += optind;

	if (shell_command != NULL && argc != 0)
		usage();

	if ((ptm_fd = getptmfd()) == -1)
		err(1, "getptmfd");
	if (pledge("stdio rpath wpath cpath flock fattr unix getpw sendfd "
	    "recvfd proc exec tty ps", NULL) != 0)
		err(1, "pledge");

	/*
	 * tmux is a UTF-8 terminal, so if TMUX is set, assume UTF-8.
	 * Otherwise, if the user has set LC_ALL, LC_CTYPE or LANG to contain
	 * UTF-8, it is a safe assumption that either they are using a UTF-8
	 * terminal, or if not they know that output from UTF-8-capable
	 * programs may be wrong.
	 */
	if (getenv("TMUX") != NULL)
		flags |= CLIENT_UTF8;
	else {
		s = getenv("LC_ALL");
		if (s == NULL || *s == '\0')
			s = getenv("LC_CTYPE");
		if (s == NULL || *s == '\0')
			s = getenv("LANG");
		if (s == NULL || *s == '\0')
			s = "";
		if (strcasestr(s, "UTF-8") != NULL ||
		    strcasestr(s, "UTF8") != NULL)
			flags |= CLIENT_UTF8;
	}

	global_hooks = hooks_create(NULL);

	global_environ = environ_create();
	for (var = environ; *var != NULL; var++)
		environ_put(global_environ, *var);
	if (getcwd(tmp, sizeof tmp) != NULL)
		environ_set(global_environ, "PWD", "%s", tmp);

	global_options = options_create(NULL);
	global_s_options = options_create(NULL);
	global_w_options = options_create(NULL);
	for (oe = options_table; oe->name != NULL; oe++) {
		if (oe->scope == OPTIONS_TABLE_SERVER)
			options_default(global_options, oe);
		if (oe->scope == OPTIONS_TABLE_SESSION)
			options_default(global_s_options, oe);
		if (oe->scope == OPTIONS_TABLE_WINDOW)
			options_default(global_w_options, oe);
	}

	/*
	 * The default shell comes from SHELL or from the user's passwd entry
	 * if available.
	 */
	shell = getshell();
	options_set_string(global_s_options, "default-shell", 0, "%s", shell);

	/* Override keys to vi if VISUAL or EDITOR are set. */
	if ((s = getenv("VISUAL")) != NULL || (s = getenv("EDITOR")) != NULL) {
		if (strrchr(s, '/') != NULL)
			s = strrchr(s, '/') + 1;
		if (strstr(s, "vi") != NULL)
			keys = MODEKEY_VI;
		else
			keys = MODEKEY_EMACS;
		options_set_number(global_s_options, "status-keys", keys);
		options_set_number(global_w_options, "mode-keys", keys);
	}

	/*
	 * If socket is specified on the command-line with -S or -L, it is
	 * used. Otherwise, $TMUX is checked and if that fails "default" is
	 * used.
	 */
	if (path == NULL && label == NULL) {
		s = getenv("TMUX");
		if (s != NULL && *s != '\0' && *s != ',') {
			path = xstrdup(s);
			path[strcspn(path, ",")] = '\0';
		}
	}
	if (path == NULL && (path = make_label(label)) == NULL) {
		fprintf(stderr, "can't create socket: %s\n", strerror(errno));
		exit(1);
	}
	socket_path = path;
	free(label);

	/* Pass control to the client. */
	exit(client_main(event_init(), argc, argv, flags));
}
@


1.183
log
@Try C.UTF-8 which is also a commonly useful locale on some platforms,
from Romain Francoise.
@
text
@d1 1
a1 1
/* $OpenBSD: tmux.c,v 1.182 2017/04/22 12:08:41 nicm Exp $ */
d47 1
d194 2
a195 2
	char					*path, *label, tmp[PATH_MAX];
	char					*shellcmd = NULL, **var;
d224 1
a224 2
			free(shellcmd);
			shellcmd = xstrdup(optarg);
d261 1
a261 1
	if (shellcmd != NULL && argc != 0)
d351 1
a351 1
	exit(client_main(event_init(), argc, argv, flags, shellcmd));
@


1.182
log
@Do not need getopt.h.
@
text
@d1 1
a1 1
/* $OpenBSD: tmux.c,v 1.181 2017/04/20 17:49:26 nicm Exp $ */
d199 2
a200 1
	if (setlocale(LC_CTYPE, "en_US.UTF-8") == NULL) {
@


1.181
log
@Use fdforkpty() instead of our own unwrapped versions.
@
text
@d1 1
a1 1
/* $OpenBSD: tmux.c,v 1.180 2017/04/19 12:44:29 nicm Exp $ */
a25 1
#include <getopt.h>
@


1.180
log
@Style nits and a missing cast.
@
text
@d1 1
a1 1
/* $OpenBSD: tmux.c,v 1.179 2017/04/16 20:33:46 nicm Exp $ */
d35 1
d264 2
a265 2
	if (pty_open(&ptm_fd) != 0)
		errx(1, "open(\"/dev/ptm\"");
@


1.179
log
@Memory leak, from David CARLIER.
@
text
@d1 1
a1 1
/* $OpenBSD: tmux.c,v 1.178 2017/03/21 19:28:03 nicm Exp $ */
d123 1
a123 1
		xasprintf(&base, "%s/tmux-%u", s, uid);
@


1.178
log
@Use uid_t for UID not u_int.
@
text
@d1 1
a1 1
/* $OpenBSD: tmux.c,v 1.177 2017/02/16 10:53:25 nicm Exp $ */
d144 2
@


1.177
log
@Style nits.
@
text
@d1 1
a1 1
/* $OpenBSD: tmux.c,v 1.176 2017/01/23 10:09:43 nicm Exp $ */
d115 1
a115 1
	u_int		 uid;
a119 1

d125 1
a125 1
		xasprintf(&base, "%s/tmux-%u", _PATH_TMP, uid);
@


1.176
log
@Open /dev/ptm before pledge() and save it to be used for PTMGET later
(this means inlining forkpty()).

ok deraadt
@
text
@d1 1
a1 1
/* $OpenBSD: tmux.c,v 1.175 2017/01/15 20:48:41 nicm Exp $ */
d84 1
a84 1
	if (shell == NULL || *shell == '\0' || *shell != '/')
@


1.175
log
@Major tidy up and rework of options tree and set-option/show-options
commands this pushes more of the code into options.c and ties it more
closely to the options table rather than having an unnecessary
split. Also add support for array options (will be used later). Only
(intentional) user visible change is that show-options output is now
passed through vis(3) with VIS_DQ so quotes are escaped.
@
text
@d1 1
a1 1
/* $OpenBSD: tmux.c,v 1.174 2017/01/12 15:36:35 nicm Exp $ */
d46 1
d262 2
@


1.174
log
@Simplify appending to string options.
@
text
@d1 1
a1 1
/* $OpenBSD: tmux.c,v 1.173 2016/12/09 21:39:27 nicm Exp $ */
d191 5
a195 3
	char		*path, *label, **var, tmp[PATH_MAX], *shellcmd = NULL;
	const char	*s;
	int		 opt, flags, keys;
a295 2
	options_table_populate_tree(OPTIONS_TABLE_SERVER, global_options);

d297 9
a305 3
	options_table_populate_tree(OPTIONS_TABLE_SESSION, global_s_options);
	options_set_string(global_s_options, "default-shell", 0, "%s",
	    getshell());
d307 6
a312 2
	global_w_options = options_create(NULL);
	options_table_populate_tree(OPTIONS_TABLE_WINDOW, global_w_options);
@


1.173
log
@Spacing nits.
@
text
@d1 1
a1 1
/* $OpenBSD: tmux.c,v 1.172 2016/10/11 13:21:59 nicm Exp $ */
d298 2
a299 1
	options_set_string(global_s_options, "default-shell", "%s", getshell());
@


1.172
log
@Add static in window-*.c and move some internal functions out of tmux.h.
@
text
@d1 1
a1 1
/* $OpenBSD: tmux.c,v 1.171 2016/10/10 21:29:23 nicm Exp $ */
d324 1
a324 1
			path[strcspn (path, ",")] = '\0';
@


1.171
log
@Loads more static, except for cmd-*.c and window-*.c.
@
text
@d1 1
a1 1
/* $OpenBSD: tmux.c,v 1.170 2016/05/27 17:05:42 nicm Exp $ */
d50 3
d63 1
a63 1
const char *
d80 1
a80 1
int
@


1.170
log
@Use getprogname() instead of __progname to make portability easier.
@
text
@d1 1
a1 1
/* $OpenBSD: tmux.c,v 1.169 2016/05/04 21:29:47 nicm Exp $ */
d47 2
a48 2
__dead void	 usage(void);
static char	*make_label(const char *);
d50 1
a50 1
__dead void
@


1.169
log
@Fix up a couple of long lines.
@
text
@d1 1
a1 1
/* $OpenBSD: tmux.c,v 1.168 2016/03/05 16:08:38 nicm Exp $ */
d56 1
a56 1
	    __progname);
d98 1
a98 1
	progname = __progname;
@


1.168
log
@If setlocale("en_US.UTF-8") succeeds, then don't do the check for UTF-8
locale since if it isn't UTF-8 the system is broken anyway. If it fails,
try "" and check for UTF-8 with nl_langinfo(CODESET) rather than
wcwidth(). Based on a diff from schwarze@@, nl_langinfo also suggested by
stsp@@.
@
text
@d1 1
a1 1
/* $OpenBSD: tmux.c,v 1.167 2016/03/05 07:44:31 nicm Exp $ */
d196 1
a196 2
		if (strcasecmp(s, "UTF-8") != 0 &&
		    strcasecmp(s, "UTF8") != 0)
@


1.167
log
@Although we always have en_US.UTF-8 on OpenBSD, some platforms do not,
so fall back to setlocale(LC_CTYPE, ""). tmux requires a UTF-8 locale,
so check with wcwidth() on a UTF-8 character after setlocale().
@
text
@d1 1
a1 1
/* $OpenBSD: tmux.c,v 1.166 2016/03/01 12:02:54 nicm Exp $ */
d27 1
d192 8
a199 4
	if (setlocale(LC_CTYPE, "en_US.UTF-8") == NULL)
		setlocale(LC_CTYPE, "");
	if (wcwidth(0xfffd) != 1)
		errx(1, "no UTF-8 locale; please set LC_CTYPE");
@


1.166
log
@Remove unused variables, from Michal Mazurek.
@
text
@d1 1
a1 1
/* $OpenBSD: tmux.c,v 1.165 2016/03/01 12:02:08 nicm Exp $ */
d191 5
a195 1
	setlocale(LC_CTYPE, "en_US.UTF-8");
a196 1

@


1.165
log
@Use system wcwidth() instead of carrying around UTF-8 width tables.
@
text
@d1 1
a1 1
/* $OpenBSD: tmux.c,v 1.164 2016/01/19 15:59:12 nicm Exp $ */
a189 1

@


1.164
log
@I no longer use my SourceForge address so replace it.
@
text
@d1 1
a1 1
/* $OpenBSD: tmux.c,v 1.163 2015/12/08 01:10:31 nicm Exp $ */
d191 2
d194 1
@


1.163
log
@Add hooks infrastructure, basic commands (set-hook, show-hooks) and a
couple of not very useful client hooks. This will eventually let
commands be run at various points and on notifications. Joint work with
Thomas Adam.
@
text
@d1 1
a1 1
/* $OpenBSD: tmux.c,v 1.162 2015/11/24 23:46:15 nicm Exp $ */
d4 1
a4 1
 * Copyright (c) 2007 Nicholas Marriott <nicm@@users.sourceforge.net>
@


1.162
log
@Make environ_set va_args and use it to tidy up some calls. Also add a
missing word in manpage (from jmc).
@
text
@d1 1
a1 1
/* $OpenBSD: tmux.c,v 1.161 2015/11/24 23:22:51 nicm Exp $ */
d41 1
d272 2
@


1.161
log
@Shell command from -c doesn't have to be global, pass it as an argument.
@
text
@d1 1
a1 1
/* $OpenBSD: tmux.c,v 1.160 2015/11/24 22:27:22 nicm Exp $ */
d276 1
a276 1
		environ_set(global_environ, "PWD", tmp);
@


1.160
log
@Tidy the code that works out the socket path, and just use the full path
in the global socket_path rather than copying it.
@
text
@d1 1
a1 1
/* $OpenBSD: tmux.c,v 1.159 2015/11/24 22:09:53 nicm Exp $ */
a41 1
char		*shell_cmd;
d186 1
a186 1
	char		*path, *label, **var, tmp[PATH_MAX];
d205 2
a206 2
			free(shell_cmd);
			shell_cmd = xstrdup(optarg);
d243 1
a243 1
	if (shell_cmd != NULL && argc != 0)
d320 1
a320 1
	exit(client_main(event_init(), argc, argv, flags));
@


1.159
log
@Remove malloc_options DEBUG bit.
@
text
@d1 1
a1 1
/* $OpenBSD: tmux.c,v 1.158 2015/11/24 21:52:06 nicm Exp $ */
d44 1
a44 1
char		 socket_path[PATH_MAX];
d47 1
a47 1
char 		*makesocketpath(const char *);
d105 2
a106 2
char *
makesocketpath(const char *label)
d108 7
a114 3
	char		base[PATH_MAX], realbase[PATH_MAX], *path, *s;
	struct stat	sb;
	u_int		uid;
d117 1
d119 1
a119 1
		xsnprintf(base, sizeof base, "%s/tmux-%u", s, uid);
d121 1
a121 1
		xsnprintf(base, sizeof base, "%s/tmux-%u", _PATH_TMP, uid);
d124 1
a124 1
		return (NULL);
d127 1
a127 1
		return (NULL);
d130 1
a130 1
		return (NULL);
d134 1
a134 1
		return (NULL);
d137 4
a140 2
	if (realpath(base, realbase) == NULL)
		strlcpy(realbase, base, sizeof realbase);
d142 5
a146 2
	xasprintf(&path, "%s/%s", realbase, label);
	return (path);
d302 3
a304 2
	 * Figure out the socket path. If specified on the command-line with -S
	 * or -L, use it, otherwise try $TMUX or assume -L default.
d306 5
a310 22
	if (path == NULL) {
		/* If no -L, use the environment. */
		if (label == NULL) {
			s = getenv("TMUX");
			if (s != NULL) {
				path = xstrdup(s);
				path[strcspn (path, ",")] = '\0';
				if (*path == '\0') {
					free(path);
					label = xstrdup("default");
				}
			} else
				label = xstrdup("default");
		}

		/* -L or default set. */
		if (label != NULL) {
			if ((path = makesocketpath(label)) == NULL) {
				fprintf(stderr, "can't create socket: %s\n",
				    strerror(errno));
				exit(1);
			}
d313 2
a314 5
	free(label);

	if (strlcpy(socket_path, path, sizeof socket_path) >=
	    sizeof socket_path) {
		fprintf(stderr, "socket path too long: %s\n", path);
d317 2
a318 1
	free(path);
@


1.158
log
@Remove the -I part of show-messages which isn't really that useful; the
server start time can now be accessed with a new start_time format (use:
tmux display -p '#{t:start_time}')
@
text
@d1 1
a1 1
/* $OpenBSD: tmux.c,v 1.157 2015/11/24 21:19:46 nicm Exp $ */
a36 4
#ifdef DEBUG
extern char	*malloc_options;
#endif

a179 4

#ifdef DEBUG
	malloc_options = (char *) "AFGJPX";
#endif
@


1.157
log
@Make the log stuff a bit tidier with some helper functions.
@
text
@d1 1
a1 1
/* $OpenBSD: tmux.c,v 1.156 2015/11/22 19:41:19 nicm Exp $ */
d47 1
a47 1
time_t		 start_time;
@


1.156
log
@Add getpw to pledge, makes tmux work in YP environments, discovered by
matthieu, ok deraadt
@
text
@d1 1
a1 1
/* $OpenBSD: tmux.c,v 1.155 2015/11/20 12:01:19 nicm Exp $ */
a46 1
int		 debug_level;
a62 12
void
logfile(const char *name)
{
	char	*path;

	if (debug_level > 0) {
		xasprintf(&path, "tmux-%s-%ld.log", name, (long) getpid());
		log_open(path);
		free(path);
	}
}

d233 1
a233 1
			debug_level++;
@


1.155
log
@Instead of separate tables for different types of options, give each
option a scope type (server, session, window) in one table.
@
text
@d1 1
a1 1
/* $OpenBSD: tmux.c,v 1.154 2015/11/15 14:32:48 nicm Exp $ */
d258 2
a259 2
	if (pledge("stdio rpath wpath cpath flock fattr unix sendfd recvfd "
	    "proc exec tty ps", NULL) != 0)
@


1.154
log
@Accidentally turned off pledge, turn it back on.
@
text
@d1 1
a1 1
/* $OpenBSD: tmux.c,v 1.153 2015/11/14 09:41:07 nicm Exp $ */
d291 1
a291 1
	options_table_populate_tree(server_options_table, global_options);
d294 1
a294 1
	options_table_populate_tree(session_options_table, global_s_options);
d298 1
a298 1
	options_table_populate_tree(window_options_table, global_w_options);
@


1.153
log
@Push stdout and stderr to clients more aggressively, and add an event to
continue if the send fails.
@
text
@d1 1
a1 1
/* $OpenBSD: tmux.c,v 1.152 2015/11/12 11:24:08 nicm Exp $ */
d258 1
a258 1
	if (0 && pledge("stdio rpath wpath cpath flock fattr unix sendfd recvfd "
@


1.152
log
@tmux is UTF-8, so if $TMUX is set (tmux running in tmux), the client is
UTF-8. Also try to make the existing checks more readable.
@
text
@d1 1
a1 1
/* $OpenBSD: tmux.c,v 1.151 2015/11/12 11:09:11 nicm Exp $ */
d258 1
a258 1
	if (pledge("stdio rpath wpath cpath flock fattr unix sendfd recvfd "
@


1.151
log
@Nuke the utf8 and status-utf8 options and make tmux only a UTF-8
terminal. We still support non-UTF-8 terminals outside tmux, but inside
it is always UTF-8 (as when the utf8 and status-utf8 options were on).
@
text
@d1 1
a1 1
/* $OpenBSD: tmux.c,v 1.150 2015/11/11 23:23:33 nicm Exp $ */
d194 3
a196 2
	char	*s, *path, *label, **var, tmp[PATH_MAX];
	int	 opt, flags, keys;
d262 19
a280 14
	if (!(flags & CLIENT_UTF8)) {
		/*
		 * If the user has set whichever of LC_ALL, LC_CTYPE or LANG
		 * exist (in that order) to contain UTF-8, it is a safe
		 * assumption that either they are using a UTF-8 terminal, or
		 * if not they know that output from UTF-8-capable programs may
		 * be wrong.
		 */
		if ((s = getenv("LC_ALL")) == NULL || *s == '\0') {
			if ((s = getenv("LC_CTYPE")) == NULL || *s == '\0')
				s = getenv("LANG");
		}
		if (s != NULL && (strcasestr(s, "UTF-8") != NULL ||
		    strcasestr(s, "UTF8") != NULL))
@


1.150
log
@Drop mouse-utf8 option and always turn on UTF-8 mouse if the client says
it supports UTF-8.
@
text
@d1 1
a1 1
/* $OpenBSD: tmux.c,v 1.149 2015/10/28 09:51:55 nicm Exp $ */
a292 6

	/* Enable UTF-8 if the first client is on UTF-8 terminal. */
	if (flags & CLIENT_UTF8) {
		options_set_number(global_s_options, "status-utf8", 1);
		options_set_number(global_w_options, "utf8", 1);
	}
@


1.149
log
@Like options, move the environ struct into environ.c.
@
text
@d1 1
a1 1
/* $OpenBSD: tmux.c,v 1.148 2015/10/27 15:58:42 nicm Exp $ */
a296 1
		options_set_number(global_s_options, "mouse-utf8", 1);
@


1.148
log
@Move struct options into options.c.
@
text
@d1 1
a1 1
/* $OpenBSD: tmux.c,v 1.147 2015/10/27 13:23:24 nicm Exp $ */
d44 1
a44 1
struct environ	 global_environ;
d278 1
a278 1
	environ_init(&global_environ);
d280 1
a280 1
		environ_put(&global_environ, *var);
d282 1
a282 1
		environ_set(&global_environ, "PWD", tmp);
@


1.147
log
@Break the common process set up, event loop and imsg dispatch code
between server and client out into a separate internal API. This will
make it easier to add another process.
@
text
@d1 1
a1 1
/* $OpenBSD: tmux.c,v 1.146 2015/10/25 07:48:16 deraadt Exp $ */
d41 3
a43 3
struct options	 global_options;	/* server options */
struct options	 global_s_options;	/* session options */
struct options	 global_w_options;	/* window options */
d284 2
a285 2
	options_init(&global_options, NULL);
	options_table_populate_tree(server_options_table, &global_options);
d287 3
a289 4
	options_init(&global_s_options, NULL);
	options_table_populate_tree(session_options_table, &global_s_options);
	options_set_string(&global_s_options, "default-shell", "%s",
	    getshell());
d291 2
a292 2
	options_init(&global_w_options, NULL);
	options_table_populate_tree(window_options_table, &global_w_options);
d296 3
a298 3
		options_set_number(&global_s_options, "status-utf8", 1);
		options_set_number(&global_s_options, "mouse-utf8", 1);
		options_set_number(&global_w_options, "utf8", 1);
d309 2
a310 2
		options_set_number(&global_s_options, "status-keys", keys);
		options_set_number(&global_w_options, "mode-keys", keys);
@


1.146
log
@Let's see if anyone screams about not being able to specify $TMPDIR
for their tmux sockets.

(Over the years, I have seen $TMPDIR set up worse than /tmp many times,
and don't know how this practice infected other parts of the system.
Nothing uses tmpdir(3), nor a huge-temporary-file program like sort.)
ok nicm
@
text
@d1 1
a1 1
/* $OpenBSD: tmux.c,v 1.145 2015/10/23 16:07:29 nicm Exp $ */
d32 1
a349 3

	/* Set process title. */
	setproctitle("%s (%s)", __progname, socket_path);
@


1.145
log
@tmux can call pledge() in main with large set and then reduce it
slightly in the server to "stdio rpath wpath cpath fattr unix recvfd
proc exec tty ps".
@
text
@d1 1
a1 1
/* $OpenBSD: tmux.c,v 1.144 2015/09/14 12:12:24 nicm Exp $ */
a129 2
		xsnprintf(base, sizeof base, "%s/tmux-%u", s, uid);
	else if ((s = getenv("TMPDIR")) != NULL && *s != '\0')
@


1.144
log
@Move tzset() from log_open to main.
@
text
@d1 1
a1 1
/* $OpenBSD: tmux.c,v 1.143 2015/09/03 14:30:23 nicm Exp $ */
d22 1
d257 4
@


1.143
log
@A couple of style nits.
@
text
@d1 1
a1 1
/* $OpenBSD: tmux.c,v 1.142 2015/09/01 10:10:59 nicm Exp $ */
d202 1
@


1.142
log
@Work out config file when needed not at startup.
@
text
@d1 1
a1 1
/* $OpenBSD: tmux.c,v 1.141 2015/08/30 22:56:36 nicm Exp $ */
d324 1
a324 2
			}
			else
@


1.141
log
@Path from $TMUX does not need to be global anymore.
@
text
@d1 1
a1 1
/* $OpenBSD: tmux.c,v 1.140 2015/08/30 22:40:25 nicm Exp $ */
a43 1
char		*cfg_file;
d173 5
a177 2
	struct passwd	*pw;
	const char	*home;
d194 2
a195 3
	char		*s, *path, *label, **var, tmp[PATH_MAX];
	const char	*home;
	int	 	 opt, flags, keys;
d225 1
a225 2
			free(cfg_file);
			cfg_file = xstrdup(optarg);
a306 12
	}

	/* Locate the configuration file. */
	if (cfg_file == NULL) {
		home = find_home();
		if (home != NULL) {
			xasprintf(&cfg_file, "%s/.tmux.conf", home);
			if (access(cfg_file, R_OK) != 0 && errno == ENOENT) {
				free(cfg_file);
				cfg_file = NULL;
			}
		}
@


1.140
log
@Login shell can be a client flag, and move the exec code into client.c.
@
text
@d1 1
a1 1
/* $OpenBSD: tmux.c,v 1.139 2015/08/30 22:19:07 nicm Exp $ */
a48 1
char		*environ_path;
a192 1
	char		 in[256];
d194 1
a194 2
	long long	 pid;
	int	 	 opt, flags, keys, session;
a320 5
	/* Get path from environment. */
	s = getenv("TMUX");
	if (s != NULL && sscanf(s, "%255[^,],%lld,%d", in, &pid, &session) == 3)
		environ_path = xstrdup(in);

d328 9
a336 2
			if (environ_path != NULL)
				path = xstrdup(environ_path);
d345 1
a345 1
					strerror(errno));
d352 2
a353 1
	if (strlcpy(socket_path, path, sizeof socket_path) >= sizeof socket_path) {
@


1.139
log
@Event base does not need to be global.
@
text
@d1 1
a1 1
/* $OpenBSD: tmux.c,v 1.138 2015/08/30 15:43:40 nicm Exp $ */
a48 1
int		 login_shell;
a171 26
__dead void
shell_exec(const char *shell, const char *shellcmd)
{
	const char	*shellname, *ptr;
	char		*argv0;

	ptr = strrchr(shell, '/');
	if (ptr != NULL && *(ptr + 1) != '\0')
		shellname = ptr + 1;
	else
		shellname = shell;
	if (login_shell)
		xasprintf(&argv0, "-%s", shellname);
	else
		xasprintf(&argv0, "%s", shellname);
	setenv("SHELL", shell, 1);

	setblocking(STDIN_FILENO, 1);
	setblocking(STDOUT_FILENO, 1);
	setblocking(STDERR_FILENO, 1);
	closefrom(STDERR_FILENO + 1);

	execl(shell, argv0, "-c", shellcmd, (char *) NULL);
	fatal("execl failed");
}

d205 5
a209 1
	flags = 0;
a210 1
	login_shell = (**argv == '-');
d231 1
a231 1
			login_shell = 1;
@


1.138
log
@Some style nits and dead assignments.
@
text
@d1 1
a1 1
/* $OpenBSD: tmux.c,v 1.137 2015/07/20 15:50:04 nicm Exp $ */
a43 2
struct event_base *ev_base;

d387 1
a387 2
	ev_base = event_init();
	exit(client_main(argc, argv, flags));
@


1.137
log
@Add an option (history-file) for a file to save/restore command prompt
history, from Olof-Joachim Frahm.
@
text
@d1 1
a1 1
/* $OpenBSD: tmux.c,v 1.136 2015/06/04 20:34:22 jmc Exp $ */
d201 1
a201 1
const char*
d216 1
a216 1
	return home;
@


1.136
log
@tweak SYNOPSIS and usage();
@
text
@d1 1
a1 1
/* $OpenBSD: tmux.c,v 1.135 2015/01/19 09:58:34 nicm Exp $ */
d201 18
a221 1
	struct passwd	*pw;
d340 1
a340 8
		home = getenv("HOME");
		if (home == NULL || *home == '\0') {
			pw = getpwuid(getuid());
			if (pw != NULL)
				home = pw->pw_dir;
			else
				home = NULL;
		}
@


1.135
log
@Make a tmux-%u directory under TMUX_TMPDIR, like TMPDIR.
@
text
@d1 1
a1 1
/* $OpenBSD: tmux.c,v 1.134 2015/01/19 09:57:33 nicm Exp $ */
d61 1
a61 1
	    "usage: %s [-2lquv] [-c shell-command] [-f file] [-L socket-name]\n"
@


1.134
log
@Only care about other permissions, allow group to be set.
@
text
@d1 1
a1 1
/* $OpenBSD: tmux.c,v 1.133 2015/01/19 09:53:15 nicm Exp $ */
d134 1
a134 1
		xsnprintf(base, sizeof base, "%s/", s);
@


1.133
log
@Remove unnecessary duplicate S_ISDIR check, from Dmitri Paduchikh.
@
text
@d1 1
a1 1
/* $OpenBSD: tmux.c,v 1.132 2014/10/20 23:27:14 nicm Exp $ */
d149 1
a149 1
	if (sb.st_uid != uid || (sb.st_mode & (S_IRWXG|S_IRWXO)) != 0) {
@


1.132
log
@Tidy up some includes.
@
text
@d1 1
a1 1
/* $OpenBSD: tmux.c,v 1.131 2014/04/17 07:55:43 nicm Exp $ */
d149 1
a149 2
	if (sb.st_uid != uid || (!S_ISDIR(sb.st_mode) &&
		sb.st_mode & (S_IRWXG|S_IRWXO)) != 0) {
@


1.131
log
@Remove the "info" message mechanism, this was only used for about five
mostly useless and annoying messages. Change those commands to silence
on success like all the others. Still accept the -q command line flag
and "quiet" server option for now.
@
text
@d1 1
a1 1
/* $OpenBSD: tmux.c,v 1.130 2014/03/31 21:42:45 nicm Exp $ */
d25 1
d50 1
a50 1
char		 socket_path[MAXPATHLEN];
d128 1
a128 1
	char		base[MAXPATHLEN], realbase[MAXPATHLEN], *path, *s;
d206 1
a206 1
	char		*s, *path, *label, **var, tmp[MAXPATHLEN];
@


1.130
log
@Remove log_debug2 as well and simplify log.c.
@
text
@d1 1
a1 1
/* $OpenBSD: tmux.c,v 1.129 2014/02/16 12:45:17 nicm Exp $ */
d209 1
a209 1
	int	 	 opt, flags, quiet, keys, session;
d217 1
a217 1
	quiet = flags = 0;
a246 1
			quiet = 1;
a292 1
	options_set_number(&global_options, "quiet", quiet);
d296 2
a297 1
	options_set_string(&global_s_options, "default-shell", "%s", getshell());
@


1.129
log
@Leftovers from removing 88 colour support, from Theo Buehler.
@
text
@d1 1
a1 1
/* $OpenBSD: tmux.c,v 1.128 2014/01/15 11:46:28 nicm Exp $ */
d73 1
a73 1
		log_open(debug_level, path);
@


1.128
log
@Do not attempt to read .tmux.conf if we can't figure out a home
directory, from Tiago Cunha.
@
text
@d1 1
a1 1
/* $OpenBSD: tmux.c,v 1.127 2014/01/09 14:05:55 nicm Exp $ */
d60 1
a60 1
	    "usage: %s [-28lquv] [-c shell-command] [-f file] [-L socket-name]\n"
@


1.127
log
@Three small changes from Tiago Cunha:

- Check for truncation when copying path.
- Don't need to use a temporary buffer in screen_set_title.
- Include strerror in output when connecting to server fails.
@
text
@d1 1
a1 1
/* $OpenBSD: tmux.c,v 1.126 2013/10/10 12:29:35 nicm Exp $ */
d205 1
a205 1
	char		*s, *path, *label, *home, **var, tmp[MAXPATHLEN];
d207 1
d329 2
d332 6
a337 4
		xasprintf(&cfg_file, "%s/.tmux.conf", home);
		if (access(cfg_file, R_OK) != 0 && errno == ENOENT) {
			free(cfg_file);
			cfg_file = NULL;
@


1.126
log
@We accidentally haven't been using $TMUX to work out the session for a
while and in fact it is less useful that using the client ttyname. So
don't bother and don't pass it from the client. If we need it in future
it is in c->environ.
@
text
@d1 1
a1 1
/* $OpenBSD: tmux.c,v 1.125 2013/10/10 12:26:36 nicm Exp $ */
d364 5
a368 1
	strlcpy(socket_path, path, sizeof socket_path);
@


1.125
log
@Alter how tmux handles the working directory to internally use file
descriptors rather than strings.

- Each session still has a current working directory.

- New sessions still get their working directory from the client that
  created them or its attached session if any.

- New windows are created by default in the session working directory.

- The -c flag to new, neww, splitw allows the working directory to be
  overridden.

- The -c flag to attach let's the session working directory be changed.

- The default-path option has been removed.

To get the equivalent to default-path '.', do:

        bind c neww -c $PWD

To get the equivalent of default-path '~', do:

        bind c neww -c ~

This also changes the client identify protocol to be a set of messages rather
than one as well as some other changes that should make it easier to make
backwards-compatible protocol changes in future.
@
text
@d1 1
a1 1
/* $OpenBSD: tmux.c,v 1.124 2013/10/10 12:12:08 nicm Exp $ */
a51 2
pid_t		 environ_pid = -1;
int		 environ_session_id = -1;
a53 1
void	 	 parseenvironment(void);
a123 17
void
parseenvironment(void)
{
	char	*env, path[256];
	long	 pid;
	int	 id;

	if ((env = getenv("TMUX")) == NULL)
		return;

	if (sscanf(env, "%255[^,],%ld,%d", path, &pid, &id) != 3)
		return;
	environ_path = xstrdup(path);
	environ_pid = pid;
	environ_session_id = id;
}

d206 3
a208 1
	int	 	 opt, flags, quiet, keys;
d336 5
a344 1
	parseenvironment();
@


1.124
log
@Merge IDENTIFY_* flags with CLIENT_* flags.
@
text
@d1 1
a1 1
/* $OpenBSD: tmux.c,v 1.123 2013/10/10 12:03:22 nicm Exp $ */
a126 24
const char*
get_full_path(const char *wd, const char *path)
{
	int		 fd;
	static char	 newpath[MAXPATHLEN];
	const char	*retval;

	fd = open(".", O_RDONLY);
	if (fd == -1)
		return (NULL);

	retval = NULL;
	if (chdir(wd) == 0) {
		if (realpath(path, newpath) == 0)
			retval = newpath;
	}

	if (fchdir(fd) != 0)
		chdir("/");
	close(fd);

	return (retval);
}

d225 1
a225 1
	char		*s, *path, *label, *home, **var;
d306 2
@


1.123
log
@Don't treat TMUX_TMPDIR as a potential file

The point of setting TMUX_TMPDIR is to then make any labels from -L go
to that directory.  In the case of makesocketpath() with no TMUX_TMPDIR
set, would set both the path and the default socket to a file.  The
checking of the permissions on the file worked fine in that case, but
when TMUX_TMPDIR is set, won't work on a directory.

This fixes the problem by ensuring the check on the permissions is
performed on directories only.

By Thomas Adam.
@
text
@d1 1
a1 1
/* $OpenBSD: tmux.c,v 1.122 2013/10/05 10:40:49 nicm Exp $ */
d264 1
a264 1
			flags |= IDENTIFY_256COLOURS;
d271 2
a272 2
			if (flags & IDENTIFY_CONTROL)
				flags |= IDENTIFY_TERMIOS;
d274 1
a274 1
				flags |= IDENTIFY_CONTROL;
d295 1
a295 1
			flags |= IDENTIFY_UTF8;
d310 1
a310 1
	if (!(flags & IDENTIFY_UTF8)) {
d324 1
a324 1
			flags |= IDENTIFY_UTF8;
d343 1
a343 1
	if (flags & IDENTIFY_UTF8) {
@


1.122
log
@Fix previous not to leak fd on failure, whoops.
@
text
@d1 1
a1 1
/* $OpenBSD: tmux.c,v 1.121 2013/10/05 08:12:39 nicm Exp $ */
d192 2
a193 1
	if (sb.st_uid != uid || (sb.st_mode & (S_IRWXG|S_IRWXO)) != 0) {
d393 2
a394 1
				fprintf(stderr, "can't create socket\n");
@


1.121
log
@Use open(".")/fchdir() to save and restore current directory rather than
getcwd()/chdir().
@
text
@d1 1
a1 1
/* $OpenBSD: tmux.c,v 1.120 2013/04/24 10:01:32 nicm Exp $ */
d130 3
a132 2
	int		fd;
	static char	newpath[MAXPATHLEN];
d138 5
a142 4
	if (chdir(wd) != 0)
		return (NULL);
	if (realpath(path, newpath) != 0)
		return (NULL);
d148 1
a148 1
	return (newpath);
@


1.120
log
@Rename global configuration define.
@
text
@d1 1
a1 1
/* $OpenBSD: tmux.c,v 1.119 2013/04/11 21:52:18 nicm Exp $ */
d130 1
a131 1
	char		oldpath[MAXPATHLEN];
d133 2
a134 1
	if (getcwd(oldpath, sizeof oldpath) == NULL)
d136 1
d141 5
a145 1
	chdir(oldpath);
@


1.119
log
@Call setlocale(LC_TIME) at startup.
@
text
@d1 1
a1 1
/* $OpenBSD: tmux.c,v 1.118 2013/03/27 11:24:18 nicm Exp $ */
d360 1
a360 1
		xasprintf(&cfg_file, "%s/%s", home, DEFAULT_CFG);
@


1.118
log
@Add TMUX_TMPDIR variable to put the socket directory outside
TMPDIR. From Ben Boeckel.
@
text
@d1 1
a1 1
/* $OpenBSD: tmux.c,v 1.117 2013/03/27 11:17:12 nicm Exp $ */
d25 1
d246 2
@


1.117
log
@Remove tmux's (already minimal) 88 colour support. Such terminals are
few and unnecessary.
@
text
@d1 1
a1 1
/* $OpenBSD: tmux.c,v 1.116 2013/03/25 10:11:45 nicm Exp $ */
d167 5
a171 1
	if ((s = getenv("TMPDIR")) == NULL || *s == '\0')
a172 2
	else
		xsnprintf(base, sizeof base, "%s/tmux-%u", s, uid);
@


1.116
log
@Rename session idx to session id throughout and add $ prefix to targets
to use it, extended from a diff from George Nachman.
@
text
@d1 1
a1 1
/* $OpenBSD: tmux.c,v 1.115 2013/03/24 09:54:10 nicm Exp $ */
d247 1
a247 1
	while ((opt = getopt(argc, argv, "28c:Cdf:lL:qS:uUv")) != -1) {
a250 5
			flags &= ~IDENTIFY_88COLOURS;
			break;
		case '8':
			flags |= IDENTIFY_88COLOURS;
			flags &= ~IDENTIFY_256COLOURS;
@


1.115
log
@Add a command queue to standardize and simplify commands that call other
commands and allow a command to block execution of subsequent
commands. This allows run-shell and if-shell to be synchronous which has
been much requested.

Each client has a default command queue and commands are consumed one at
a time from it. A command may suspend execution from the queue by
returning CMD_RETURN_WAIT and then resume it by calling cmd_continue() -
for example run-shell does this from the callback that is fired after
the job is freed.

When the command queue becomes empty, command clients are automatically
exited (unless attaching). A callback is also fired - this is used for
nested commands in, for example, if-shell which can block execution of
the client's cmdq until a new cmdq becomes empty.

Also merge all the old error/info/print functions together and lose the
old curclient/cmdclient distinction - a cmdq is bound to one client (or
none if in the configuration file), this is a command client if
c->session is NULL otherwise an attached client.
@
text
@d1 1
a1 1
/* $OpenBSD: tmux.c,v 1.114 2012/11/27 16:12:29 nicm Exp $ */
d52 1
a52 1
int		 environ_idx = -1;
d147 1
a147 1
	int	 idx;
d152 1
a152 1
	if (sscanf(env, "%255[^,],%ld,%d", path, &pid, &idx) != 3)
d156 1
a156 1
	environ_idx = idx;
@


1.114
log
@Correctly aggregate together errors from nested config files (with
source-file). Fix by Thomas Adam, reported by Sam Livingstone-Gray
@
text
@d1 1
a1 1
/* $OpenBSD: tmux.c,v 1.113 2012/11/26 11:35:28 nicm Exp $ */
a331 2

	ARRAY_INIT(&cfg_causes);
@


1.113
log
@Call realpath earlier on the socket directory path rather than on the
socket file path because the latter may not exist yet and in that case
realpath is allowed to fail. From Romain Francoise.
@
text
@d1 1
a1 1
/* $OpenBSD: tmux.c,v 1.112 2012/07/10 11:53:01 nicm Exp $ */
d332 2
@


1.112
log
@xfree is not particularly helpful, remove it. From Thomas Adam.
@
text
@d1 1
a1 1
/* $OpenBSD: tmux.c,v 1.111 2012/06/18 13:16:42 nicm Exp $ */
d162 1
a162 1
	char		base[MAXPATHLEN], *path, *s;
d186 4
a189 1
	xasprintf(&path, "%s/%s", base, label);
d390 1
a390 2
	if (realpath(path, socket_path) == NULL)
		strlcpy(socket_path, path, sizeof socket_path);
@


1.111
log
@Add a skeleton mode to tmux (called "control mode") that let's tmux
commands be sent and output received on stdout. This can be used to
integrate with other terminal emulators and should allow some other
things to be made simpler later. More to come so doesn't do much yet and
deliberately not documented.
@
text
@d1 1
a1 1
/* $OpenBSD: tmux.c,v 1.110 2012/05/30 15:01:21 nicm Exp $ */
d76 1
a76 1
		xfree(path);
d255 1
a255 2
			if (shell_cmd != NULL)
				xfree(shell_cmd);
d265 1
a265 2
			if (cfg_file != NULL)
				xfree(cfg_file);
d272 1
a272 2
			if (label != NULL)
				xfree(label);
d279 1
a279 2
			if (path != NULL)
				xfree(path);
d359 1
a359 1
			xfree(cfg_file);
d386 1
a386 2
	if (label != NULL)
		xfree(label);
d389 1
a389 1
	xfree(path);
@


1.110
log
@Do not use stderr for log file and don't call log_close when not needed.
@
text
@d1 1
a1 1
/* $OpenBSD: tmux.c,v 1.109 2012/05/25 08:28:10 nicm Exp $ */
d244 1
a244 1
	while ((opt = getopt(argc, argv, "28c:df:lL:qS:uUv")) != -1) {
d258 6
@


1.109
log
@Simplify logging and just fprintf(stderr, ...) for early errors.
@
text
@d1 1
a1 1
/* $OpenBSD: tmux.c,v 1.108 2012/01/21 08:40:09 nicm Exp $ */
a72 1
	log_close();
@


1.108
log
@Drop the ability to have a list of keys in the prefix in favour of two
separate options, prefix and prefix2. This simplifies the code and gets
rid the data options type which was only used for this one option.

Also add a -2 flag to send-prefix to send the secondary prefix key,
fixing a cause of minor irritation.

People who want three prefix keys are out of luck :-).
@
text
@d1 1
a1 1
/* $OpenBSD: tmux.c,v 1.107 2011/10/23 08:34:01 nicm Exp $ */
d76 1
a76 1
		log_open_file(debug_level, path);
a296 2
	log_open_tty(debug_level);

d380 1
a380 1
				log_warn("can't create socket");
@


1.107
log
@Try to resolve relative paths for loadb and saveb (first using client
working directory if any then default-path or session wd).
@
text
@d1 1
a1 1
/* $OpenBSD: tmux.c,v 1.106 2011/10/23 08:03:27 nicm Exp $ */
a234 1
	struct keylist	*keylist;
a329 6

	/* Set the prefix option (its a list, so not in the table). */
	keylist = xmalloc(sizeof *keylist);
	ARRAY_INIT(keylist);
	ARRAY_ADD(keylist, '\002');
	options_set_data(&global_s_options, "prefix", keylist, xfree);
@


1.106
log
@Ignore LC_ALL and LC_CTYPE if they are empty as well as unset.
@
text
@d1 1
a1 1
/* $OpenBSD: tmux.c,v 1.105 2011/09/25 18:53:04 nicm Exp $ */
d125 16
@


1.105
log
@Reject $SHELL if it is not a full path.
@
text
@d1 1
a1 1
/* $OpenBSD: tmux.c,v 1.104 2011/03/04 23:26:44 nicm Exp $ */
d292 2
a293 2
		if ((s = getenv("LC_ALL")) == NULL) {
			if ((s = getenv("LC_CTYPE")) == NULL)
@


1.104
log
@Two fixes by Micah Cowan: make mouse work properly beyond >127 on signed
char architectures and properly parse $TMUX by stopping the socket path
at the first comma.
@
text
@d1 1
a1 1
/* $OpenBSD: tmux.c,v 1.103 2011/01/23 11:03:43 nicm Exp $ */
d101 3
a103 1
	if (shell == NULL || *shell == '\0' || areshell(shell))
@


1.103
log
@Set $TMUX without the session when background jobs are run.
@
text
@d1 1
a1 1
/* $OpenBSD: tmux.c,v 1.102 2011/01/12 22:23:58 nicm Exp $ */
d135 1
a135 1
	if (sscanf(env, "%255s,%ld,%d", path, &pid, &idx) != 3)
@


1.102
log
@Use TMPDIR if set, from Han Boetes.
@
text
@d1 1
a1 1
/* $OpenBSD: tmux.c,v 1.101 2011/01/08 01:52:37 nicm Exp $ */
d51 2
a52 2
pid_t		 environ_pid;
u_int		 environ_idx;
d128 3
a130 4
	char		*env, *path_pid, *pid_idx, buf[256];
	size_t		 len;
	const char	*errstr;
	long long	 ll;
a131 1
	environ_pid = -1;
d135 1
a135 1
	if ((path_pid = strchr(env, ',')) == NULL || path_pid == env)
d137 3
a139 28
	if ((pid_idx = strchr(path_pid + 1, ',')) == NULL)
		return;
	if ((pid_idx == path_pid + 1 || pid_idx[1] == '\0'))
		return;

	/* path */
	len = path_pid - env;
	environ_path = xmalloc(len + 1);
	memcpy(environ_path, env, len);
	environ_path[len] = '\0';

	/* pid */
	len = pid_idx - path_pid - 1;
	if (len > (sizeof buf) - 1)
		return;
	memcpy(buf, path_pid + 1, len);
	buf[len] = '\0';

	ll = strtonum(buf, 0, LONG_MAX, &errstr);
	if (errstr != NULL)
		return;
	environ_pid = ll;

	/* idx */
	ll = strtonum(pid_idx + 1, 0, UINT_MAX, &errstr);
	if (errstr != NULL)
		return;
	environ_idx = ll;
@


1.101
log
@Move all calls to fcntl(...O_NONBLOCK) into a function and clear the
flag on the stdio file descriptors before closing them (fixes things
like "tmux ls && cat").
@
text
@d1 1
a1 1
/* $OpenBSD: tmux.c,v 1.100 2011/01/03 23:35:21 nicm Exp $ */
d172 1
a172 1
	char		base[MAXPATHLEN], *path;
d177 4
a180 1
	xsnprintf(base, MAXPATHLEN, "%s/tmux-%d", _PATH_TMP, uid);
@


1.100
log
@Support for UTF-8 mouse input (\033[1005h). This was added in xterm 262
and supports larger terminals than the older way.

If the new mouse-utf8 option is on, UTF-8 mouse input is enabled for all
UTF-8 terminals. The option defaults to on if LANG etc are set in the
same manner as the utf8 option.

With help and based on code from hsim at gmx.li.
@
text
@d1 1
a1 1
/* $OpenBSD: tmux.c,v 1.99 2011/01/01 16:51:21 nicm Exp $ */
d197 14
a215 1
	int		 mode;
d228 3
a230 6
	if ((mode = fcntl(STDIN_FILENO, F_GETFL)) != -1)
		fcntl(STDIN_FILENO, F_SETFL, mode & ~O_NONBLOCK);
	if ((mode = fcntl(STDOUT_FILENO, F_GETFL)) != -1)
		fcntl(STDOUT_FILENO, F_SETFL, mode & ~O_NONBLOCK);
	if ((mode = fcntl(STDERR_FILENO, F_GETFL)) != -1)
		fcntl(STDERR_FILENO, F_SETFL, mode & ~O_NONBLOCK);
@


1.99
log
@Move the user-visible parts of all options (names, types, limit, default
values) together into one set of tables in options-table.c. Also clean
up and simplify cmd-set-options.c and move a common print function into
option-table.c.
@
text
@d1 1
a1 1
/* $OpenBSD: tmux.c,v 1.98 2010/12/30 23:16:18 nicm Exp $ */
d337 1
@


1.98
log
@Change from a per-session stack of buffers to one global stack which is
much more convenient and also simplifies lot of code. This renders
copy-buffer useless and makes buffer-limit now a server option.

By Tiago Cunha.
@
text
@d1 1
a1 1
/* $OpenBSD: tmux.c,v 1.97 2010/12/19 18:35:08 nicm Exp $ */
a230 1
	struct options	*oo, *so, *wo;
d318 2
a319 5
	oo = &global_options;
	options_set_number(oo, "quiet", quiet);
	options_set_number(oo, "escape-time", 500);
	options_set_number(oo, "exit-unattached", 0);
	options_set_number(oo, "buffer-limit", 9);
d322 2
a323 57
	so = &global_s_options;
	options_set_number(so, "base-index", 0);
	options_set_number(so, "bell-action", BELL_ANY);
	options_set_string(so, "default-command", "%s", "");
	options_set_string(so, "default-path", "%s", "");
	options_set_string(so, "default-shell", "%s", getshell());
	options_set_string(so, "default-terminal", "screen");
	options_set_number(so, "destroy-unattached", 0);
	options_set_number(so, "detach-on-destroy", 1);
	options_set_number(so, "display-panes-active-colour", 1);
	options_set_number(so, "display-panes-colour", 4);
	options_set_number(so, "display-panes-time", 1000);
	options_set_number(so, "display-time", 750);
	options_set_number(so, "history-limit", 2000);
	options_set_number(so, "lock-after-time", 0);
	options_set_string(so, "lock-command", "lock -np");
	options_set_number(so, "lock-server", 1);
	options_set_number(so, "message-attr", 0);
	options_set_number(so, "message-bg", 3);
	options_set_number(so, "message-fg", 0);
	options_set_number(so, "message-limit", 20);
	options_set_number(so, "mouse-select-pane", 0);
	options_set_number(so, "pane-active-border-bg", 8);
	options_set_number(so, "pane-active-border-fg", 2);
	options_set_number(so, "pane-border-bg", 8);
	options_set_number(so, "pane-border-fg", 8);
	options_set_number(so, "repeat-time", 500);
	options_set_number(so, "set-remain-on-exit", 0);
	options_set_number(so, "set-titles", 0);
	options_set_string(so, "set-titles-string", "#S:#I:#W - \"#T\"");
	options_set_number(so, "status", 1);
	options_set_number(so, "status-attr", 0);
	options_set_number(so, "status-bg", 2);
	options_set_number(so, "status-fg", 0);
	options_set_number(so, "status-interval", 15);
	options_set_number(so, "status-justify", 0);
	options_set_string(so, "status-left", "[#S]");
	options_set_number(so, "status-left-attr", 0);
	options_set_number(so, "status-left-bg", 8);
	options_set_number(so, "status-left-fg", 8);
	options_set_number(so, "status-left-length", 10);
	options_set_string(so, "status-right", "\"#22T\" %%H:%%M %%d-%%b-%%y");
	options_set_number(so, "status-right-attr", 0);
	options_set_number(so, "status-right-bg", 8);
	options_set_number(so, "status-right-fg", 8);
	options_set_number(so, "status-right-length", 40);
	options_set_string(so, "terminal-overrides",
	    "*88col*:colors=88,*256col*:colors=256");
	options_set_string(so, "update-environment",
	    "DISPLAY "
	    "SSH_ASKPASS SSH_AUTH_SOCK SSH_AGENT_PID SSH_CONNECTION "
	    "WINDOWID "
	    "XAUTHORITY");
	options_set_number(so, "visual-activity", 0);
	options_set_number(so, "visual-bell", 0);
	options_set_number(so, "visual-content", 0);
	options_set_number(so, "visual-silence", 0);
d325 4
d332 1
a332 37
	options_set_data(so, "prefix", keylist, xfree);

	options_init(&global_w_options, NULL);
	wo = &global_w_options;
	options_set_number(wo, "aggressive-resize", 0);
	options_set_number(wo, "alternate-screen", 1);
	options_set_number(wo, "automatic-rename", 1);
	options_set_number(wo, "clock-mode-colour", 4);
	options_set_number(wo, "clock-mode-style", 1);
	options_set_number(wo, "force-height", 0);
	options_set_number(wo, "force-width", 0);
	options_set_number(wo, "main-pane-height", 24);
	options_set_number(wo, "main-pane-width", 80);
	options_set_number(wo, "mode-attr", 0);
	options_set_number(wo, "mode-bg", 3);
	options_set_number(wo, "mode-fg", 0);
	options_set_number(wo, "mode-mouse", 0);
	options_set_number(wo, "monitor-activity", 0);
	options_set_string(wo, "monitor-content", "%s", "");
	options_set_number(wo, "monitor-silence", 0);
	options_set_number(wo, "other-pane-height", 0);
	options_set_number(wo, "other-pane-width", 0);
	options_set_number(wo, "window-status-attr", 0);
	options_set_number(wo, "window-status-bg", 8);
	options_set_number(wo, "window-status-current-attr", 0);
	options_set_number(wo, "window-status-current-bg", 8);
	options_set_number(wo, "window-status-current-fg", 8);
	options_set_number(wo, "window-status-fg", 8);
	options_set_number(wo, "window-status-alert-attr", GRID_ATTR_REVERSE);
	options_set_number(wo, "window-status-alert-bg", 8);
	options_set_number(wo, "window-status-alert-fg", 8);
	options_set_string(wo, "window-status-format", "#I:#W#F");
	options_set_string(wo, "window-status-current-format", "#I:#W#F");
	options_set_string(wo, "word-separators", " -_@@");
	options_set_number(wo, "xterm-keys", 0);
	options_set_number(wo, "remain-on-exit", 0);
	options_set_number(wo, "synchronize-panes", 0);
d334 1
d336 2
a337 5
		options_set_number(so, "status-utf8", 1);
		options_set_number(wo, "utf8", 1);
	} else {
		options_set_number(so, "status-utf8", 0);
		options_set_number(wo, "utf8", 0);
d340 1
a340 1
	keys = MODEKEY_EMACS;
d346 4
a350 2
	options_set_number(so, "status-keys", keys);
	options_set_number(wo, "mode-keys", keys);
@


1.97
log
@Add other-pane-height and other-pane-width options, allowing the width
or height of the smaller panes in the main-horizontal and main-vertical
layouts to be set. Mostly from David Goodlad.
@
text
@d1 1
a1 1
/* $OpenBSD: tmux.c,v 1.96 2010/12/08 19:57:03 nicm Exp $ */
d323 1
a328 1
	options_set_number(so, "buffer-limit", 9);
@


1.96
log
@In the built-in layouts, distribute the panes more evenly. Set the
default value of main-pane-width to 80, rather than 81. By Micah Cowan.
@
text
@d1 1
a1 1
/* $OpenBSD: tmux.c,v 1.95 2010/12/06 22:51:02 nicm Exp $ */
d407 2
@


1.95
log
@Add an option to alert (monitor) for silence (lack of activity) in a
window. From Thomas Adam.
@
text
@d1 1
a1 1
/* $OpenBSD: tmux.c,v 1.94 2010/11/29 19:45:58 nicm Exp $ */
d399 1
a399 1
	options_set_number(wo, "main-pane-width", 81);
@


1.94
log
@If VISUAL or EDITOR contains "vi", configure mode-keys and status-keys
to vi.

Based on a diff from martynas@@, previously requested by a couple of
other people.
@
text
@d1 1
a1 1
/* $OpenBSD: tmux.c,v 1.93 2010/11/11 21:06:09 nicm Exp $ */
d382 1
d406 1
@


1.93
log
@Add XAUTHORITY to update-environment, requested by Andreas Kloeckner.
@
text
@d1 1
a1 1
/* $OpenBSD: tmux.c,v 1.92 2010/10/18 20:00:03 nicm Exp $ */
d234 1
a234 1
	int	 	 opt, flags, quiet = 0;
d240 1
a240 1
	flags = 0;
a361 1
	options_set_number(so, "status-keys", MODEKEY_EMACS);
a401 1
	options_set_number(wo, "mode-keys", MODEKEY_EMACS);
d428 10
@


1.92
log
@Merge the before and after attach client code into one in client.c
(instead of two in tmux.c and client.c).
@
text
@d1 1
a1 1
/* $OpenBSD: tmux.c,v 1.91 2010/10/16 08:42:35 nicm Exp $ */
d375 5
a379 2
	options_set_string(so, "update-environment", "DISPLAY "
	    "WINDOWID SSH_ASKPASS SSH_AUTH_SOCK SSH_AGENT_PID SSH_CONNECTION");
@


1.91
log
@Make stdio blocking again before calling shell command with -c.
@
text
@d1 1
a1 1
/* $OpenBSD: tmux.c,v 1.90 2010/10/16 08:31:55 nicm Exp $ */
a20 1
#include <sys/wait.h>
a26 1
#include <signal.h>
a28 1
#include <syslog.h>
a36 1
char		*cfg_file;
d44 2
d48 1
a48 1
char		*socket_path;
d50 3
a52 6

struct env_data {
	char	*path;
	pid_t	 pid;
	u_int	 idx;
};
d55 2
a56 10
void	 	 parse_env(struct env_data *);
char 		*makesockpath(const char *);
__dead void	 shell_exec(const char *, const char *);

struct imsgbuf	*main_ibuf;
struct event	 main_event;

void		 main_signal(int, short, unused void *);
void		 main_callback(int, short, void *);
void		 main_dispatch(const char *);
d126 1
a126 1
parse_env(struct env_data *data)
d133 1
a133 1
	data->pid = -1;
d146 3
a148 3
	data->path = xmalloc (len + 1);
	memcpy(data->path, env, len);
	data->path[len] = '\0';
d160 1
a160 1
	data->pid = ll;
d163 1
a163 1
	ll = strtonum(pid_idx+1, 0, UINT_MAX, &errstr);
d166 1
a166 1
	data->idx = ll;
d170 1
a170 1
makesockpath(const char *label)
d230 5
a234 14
	struct cmd_list		*cmdlist;
	struct cmd		*cmd;
	enum msgtype		 msg;
	struct passwd		*pw;
	struct options		*oo, *so, *wo;
	struct keylist		*keylist;
	struct env_data		 envdata;
	struct msg_command_data	 cmddata;
	char			*s, *shellcmd, *path, *label, *home, *cause;
	char		       **var;
	void			*buf;
	size_t			 len;
	int	 		 opt, flags, quiet = 0, cmdflags = 0;
	short		 	 events;
d241 1
a241 2
	shellcmd = label = path = NULL;
	envdata.path = NULL;
d254 3
a256 3
			if (shellcmd != NULL)
				xfree(shellcmd);
			shellcmd = xstrdup(optarg);
d292 1
a292 1
	if (shellcmd != NULL && argc != 0)
d428 1
d444 2
a445 2
	 * Figure out the socket path. If specified on the command-line with
	 * -S or -L, use it, otherwise try $TMUX or assume -L default.
d447 1
a447 1
	parse_env(&envdata);
d449 1
a449 1
		/* No -L. Try $TMUX, or default. */
d451 3
a453 2
			path = envdata.path;
			if (path == NULL)
d459 1
a459 1
			if ((path = makesockpath(label)) == NULL) {
d467 3
d471 2
a472 58
	if (shellcmd != NULL) {
		msg = MSG_SHELL;
		buf = NULL;
		len = 0;
	} else {
		cmddata.pid = envdata.pid;
		cmddata.idx = envdata.idx;

		/* Prepare command for server. */
		cmddata.argc = argc;
		if (cmd_pack_argv(
		    argc, argv, cmddata.argv, sizeof cmddata.argv) != 0) {
			log_warnx("command too long");
			exit(1);
		}

		msg = MSG_COMMAND;
		buf = &cmddata;
		len = sizeof cmddata;
	}

	if (shellcmd != NULL)
		cmdflags |= CMD_STARTSERVER;
	else if (argc == 0)	/* new-session is the default */
		cmdflags |= CMD_STARTSERVER|CMD_SENDENVIRON|CMD_CANTNEST;
	else {
		/*
		 * It sucks parsing the command string twice (in client and
		 * later in server) but it is necessary to get the start server
		 * flag.
		 */
		if ((cmdlist = cmd_list_parse(argc, argv, &cause)) == NULL) {
			log_warnx("%s", cause);
			exit(1);
		}
		cmdflags &= ~CMD_STARTSERVER;
		TAILQ_FOREACH(cmd, &cmdlist->list, qentry) {
			if (cmd->entry->flags & CMD_STARTSERVER)
				cmdflags |= CMD_STARTSERVER;
			if (cmd->entry->flags & CMD_SENDENVIRON)
				cmdflags |= CMD_SENDENVIRON;
			if (cmd->entry->flags & CMD_CANTNEST)
				cmdflags |= CMD_CANTNEST;
		}
		cmd_list_free(cmdlist);
	}

	/*
	 * Check if this could be a nested session, if the command can't nest:
	 * if the socket path matches $TMUX, this is probably the same server.
	 */
	if (shellcmd == NULL && envdata.path != NULL &&
	    cmdflags & CMD_CANTNEST &&
	    (path == envdata.path || strcmp(path, envdata.path) == 0)) {
		log_warnx("sessions should be nested with care. "
		    "unset $TMUX to force.");
		exit(1);
	}
d474 1
d476 1
a476 116
	set_signals(main_signal);

	/* Initialise the client socket/start the server. */
	if ((main_ibuf = client_init(path, cmdflags, flags)) == NULL)
		exit(1);
	xfree(path);

	imsg_compose(main_ibuf, msg, PROTOCOL_VERSION, -1, -1, buf, len);

	events = EV_READ;
	if (main_ibuf->w.queued > 0)
		events |= EV_WRITE;
	event_set(&main_event, main_ibuf->fd, events, main_callback, shellcmd);
	event_add(&main_event, NULL);

	event_dispatch();

	event_del(&main_event);

	clear_signals(0);
	client_main();	/* doesn't return */
}

/* ARGSUSED */
void
main_signal(int sig, unused short events, unused void *data)
{
	int	status;

	switch (sig) {
	case SIGTERM:
		exit(1);
	case SIGCHLD:
		waitpid(WAIT_ANY, &status, WNOHANG);
		break;
	}
}

/* ARGSUSED */
void
main_callback(unused int fd, short events, void *data)
{
	char	*shellcmd = data;

	if (events & EV_READ)
		main_dispatch(shellcmd);

	if (events & EV_WRITE) {
		if (msgbuf_write(&main_ibuf->w) < 0)
			fatalx("msgbuf_write failed");
	}

	event_del(&main_event);
	events = EV_READ;
	if (main_ibuf->w.queued > 0)
		events |= EV_WRITE;
	event_set(&main_event, main_ibuf->fd, events, main_callback, shellcmd);
	event_add(&main_event, NULL);
}

void
main_dispatch(const char *shellcmd)
{
	struct imsg		imsg;
	ssize_t			n, datalen;
	struct msg_shell_data	shelldata;
	struct msg_exit_data	exitdata;

	if ((n = imsg_read(main_ibuf)) == -1 || n == 0)
		fatalx("imsg_read failed");

	for (;;) {
		if ((n = imsg_get(main_ibuf, &imsg)) == -1)
			fatalx("imsg_get failed");
		if (n == 0)
			return;
		datalen = imsg.hdr.len - IMSG_HEADER_SIZE;

		switch (imsg.hdr.type) {
		case MSG_EXIT:
		case MSG_SHUTDOWN:
			if (datalen != sizeof exitdata) {
				if (datalen != 0)
					fatalx("bad MSG_EXIT size");
				exit(0);
			}
			memcpy(&exitdata, imsg.data, sizeof exitdata);
			exit(exitdata.retcode);
		case MSG_READY:
			if (datalen != 0)
				fatalx("bad MSG_READY size");

			event_loopexit(NULL);	/* move to client_main() */
			break;
		case MSG_VERSION:
			if (datalen != 0)
				fatalx("bad MSG_VERSION size");

			log_warnx("protocol version mismatch (client %u, "
			    "server %u)", PROTOCOL_VERSION, imsg.hdr.peerid);
			exit(1);
		case MSG_SHELL:
			if (datalen != sizeof shelldata)
				fatalx("bad MSG_SHELL size");
			memcpy(&shelldata, imsg.data, sizeof shelldata);
			shelldata.shell[(sizeof shelldata.shell) - 1] = '\0';

			clear_signals(0);

			shell_exec(shelldata.shell, shellcmd);
		default:
			fatalx("unexpected message");
		}

		imsg_free(&imsg);
	}
@


1.90
log
@Trying to set FD_CLOEXEC on every fd is a lost cause, just use
closefrom() before exec.
@
text
@d1 1
a1 1
/* $OpenBSD: tmux.c,v 1.89 2010/10/14 17:38:39 nicm Exp $ */
d25 1
d215 1
d228 6
@


1.89
log
@Use an explicit event rather than event_once for the main event so it
can be removed when the client becomes ready.
@
text
@d1 1
a1 1
/* $OpenBSD: tmux.c,v 1.88 2010/09/26 20:43:30 nicm Exp $ */
d225 2
@


1.88
log
@Two new options:

- server option "exit-unattached" makes the server exit when no clients
  are attached, even if sessions are present;

- session option "destroy-unattached" destroys a session once no clients
  are attached to it.

These are useful for preventing tmux remaining in the background where
it is undesirable and when using tmux as a login shell to keep a limit
on new sessions.
@
text
@d1 1
a1 1
/* $OpenBSD: tmux.c,v 1.87 2010/08/19 18:29:01 nicm Exp $ */
d64 1
d551 2
a552 1
	event_once(main_ibuf->fd, events, main_callback, shellcmd, NULL);
d556 2
a558 1

d591 1
d595 2
a596 1
	event_once(main_ibuf->fd, events, main_callback, shellcmd, NULL);
@


1.87
log
@Do not call event_del() for signals after fork(), just use sigaction()
directly instead - calling libevent functions after fork() w/o
event_reinit() is a bad idea, even if in this case it was harmless.
@
text
@d1 1
a1 1
/* $OpenBSD: tmux.c,v 1.86 2010/08/04 19:46:13 deraadt Exp $ */
d334 1
d345 1
@


1.86
log
@switch back to kqueue for now, since (a) kqueue has been fixed to deal
with strange devices and (b) since there appears to be a bull in the
poll code in libevent as well...
requested by nicm who is away
@
text
@d1 1
a1 1
/* $OpenBSD: tmux.c,v 1.85 2010/07/24 19:25:31 nicm Exp $ */
d552 1
a552 1
	clear_signals();
d639 1
a639 1
			clear_signals();
@


1.85
log
@kqueue(2) is currently broken when used with /dev/null and a few other
devices.

An upcoming fix for some problems with the client stdout/stderr handling
relies on it working, so make tmux force libevent to use poll(2) via
EVENT_NOKQUEUE, until we have fixed kqueue.
@
text
@d1 1
a1 1
/* $OpenBSD: tmux.c,v 1.84 2010/07/11 17:06:45 nicm Exp $ */
a534 2
	if (setenv("EVENT_NOKQUEUE", "1", 1) != 0)
		fatal("setenv");
a535 1
	unsetenv("EVENT_NOKQUEUE");
@


1.84
log
@Return the command client return code with MSG_EXIT now that MSG_ERROR and
MSG_PRINT are unused.

New clients should be compatible with old tmux servers but vice versa may print
an error.
@
text
@d1 1
a1 1
/* $OpenBSD: tmux.c,v 1.83 2010/06/28 22:10:42 nicm Exp $ */
d535 2
d538 1
@


1.83
log
@Send all three of stdin, stdout, stderr from the client to the server, so that
commands can directly make use of them. This means that load-buffer and
save-buffer can have "-" as the file to read from stdin or write to stdout.

This is a protocol version bump so the tmux server will need to be restarted
after upgrade (or an older client used).
@
text
@d1 1
a1 1
/* $OpenBSD: tmux.c,v 1.82 2010/06/27 02:56:59 nicm Exp $ */
a63 1
int	         main_exitval;
a549 1
	main_exitval = 0;
d598 1
d613 7
a619 4
			if (datalen != 0)
				fatalx("bad MSG_EXIT size");

			exit(main_exitval);
@


1.82
log
@Store the current working directory in the session, change the default-path
option to default to empty and make that mean that the stored session CWD is
used.
@
text
@d1 1
a1 1
/* $OpenBSD: tmux.c,v 1.81 2010/06/27 00:22:22 nicm Exp $ */
a598 1
	struct msg_print_data	printdata;
a617 11
		case MSG_ERROR:
		case MSG_PRINT:
			if (datalen != sizeof printdata)
				fatalx("bad MSG_PRINT size");
			memcpy(&printdata, imsg.data, sizeof printdata);
			printdata.msg[(sizeof printdata.msg) - 1] = '\0';

			log_info("%s", printdata.msg);
			if (imsg.hdr.type == MSG_ERROR)
				main_exitval = 1;
			break;
@


1.81
log
@New option, detach-on-destroy, to set what happens to a client when the session
it is attached to is destroyed. If on (the default), it is detached; if off, it
is switched to the most recently active session.
@
text
@d1 1
a1 1
/* $OpenBSD: tmux.c,v 1.80 2010/06/26 18:20:53 nicm Exp $ */
d242 1
a242 1
	char			 cwd[MAXPATHLEN], **var;
d342 1
a437 9

	if (getcwd(cwd, sizeof cwd) == NULL) {
		pw = getpwuid(getuid());
		if (pw->pw_dir != NULL && *pw->pw_dir != '\0')
			strlcpy(cwd, pw->pw_dir, sizeof cwd);
		else
			strlcpy(cwd, "/", sizeof cwd);
	}
	options_set_string(so, "default-path", "%s", cwd);
@


1.80
log
@Setting the cmdlist pointer in the bind-key to NULL to prevent it being freed
after the command is executing is bogus because it may still be needed if the
same command is going to be executed again (for example if you "bind-key a
bind-key b ..."). Making a copy is hard, so instead add a reference count to
the cmd_list.

While here, also print bind-key -n and the rest of the flags properly.

Fixes problem reported by mcbride@@.
@
text
@d1 1
a1 1
/* $OpenBSD: tmux.c,v 1.79 2010/05/14 19:03:09 nicm Exp $ */
d344 2
a346 1
	options_set_number(so, "display-panes-active-colour", 1);
@


1.79
log
@Colour+attribute options for status line alerts, from Alex Alexander.
@
text
@d1 1
a1 1
/* $OpenBSD: tmux.c,v 1.78 2010/05/04 17:28:16 nicm Exp $ */
d520 1
a520 1
		TAILQ_FOREACH(cmd, cmdlist, qentry) {
@


1.78
log
@Put this back in with the initialisation in the right order.
@
text
@d1 1
a1 1
/* $OpenBSD: tmux.c,v 1.77 2010/05/04 08:48:06 nicm Exp $ */
d419 3
@


1.77
log
@Revert last change, it appears to be broken somehow.
@
text
@d1 1
a1 1
/* $OpenBSD: tmux.c,v 1.75 2010/04/28 18:22:32 nicm Exp $ */
d21 1
d45 2
a63 1
struct event	 main_ev_sigterm;
a65 2
void		 main_set_signals(void);
void		 main_clear_signals(void);
a240 1
	struct sigaction	 sigact;
d540 2
a541 6
	/* Catch SIGCHLD to avoid a zombie when starting the server. */
	memset(&sigact, 0, sizeof sigact);
	sigemptyset(&sigact.sa_mask);
	sigact.sa_handler = SIG_IGN;
	if (sigaction(SIGCHLD, &sigact, NULL) != 0)
		fatal("sigaction failed");
a547 2
	event_init();

a549 2
	main_set_signals();

d558 1
a558 1
	main_clear_signals();
a562 47
void
main_set_signals(void)
{
	struct sigaction	sigact;

	memset(&sigact, 0, sizeof sigact);
	sigemptyset(&sigact.sa_mask);
	sigact.sa_flags = SA_RESTART;
	sigact.sa_handler = SIG_IGN;
	if (sigaction(SIGINT, &sigact, NULL) != 0)
		fatal("sigaction failed");
	if (sigaction(SIGPIPE, &sigact, NULL) != 0)
		fatal("sigaction failed");
	if (sigaction(SIGUSR1, &sigact, NULL) != 0)
		fatal("sigaction failed");
	if (sigaction(SIGUSR2, &sigact, NULL) != 0)
		fatal("sigaction failed");
	if (sigaction(SIGTSTP, &sigact, NULL) != 0)
		fatal("sigaction failed");

	signal_set(&main_ev_sigterm, SIGTERM, main_signal, NULL);
	signal_add(&main_ev_sigterm, NULL);
}

void
main_clear_signals(void)
{
	struct sigaction	sigact;

	memset(&sigact, 0, sizeof sigact);
	sigemptyset(&sigact.sa_mask);
	sigact.sa_flags = SA_RESTART;
	sigact.sa_handler = SIG_DFL;
	if (sigaction(SIGINT, &sigact, NULL) != 0)
		fatal("sigaction failed");
	if (sigaction(SIGPIPE, &sigact, NULL) != 0)
		fatal("sigaction failed");
	if (sigaction(SIGUSR1, &sigact, NULL) != 0)
		fatal("sigaction failed");
	if (sigaction(SIGUSR2, &sigact, NULL) != 0)
		fatal("sigaction failed");
	if (sigaction(SIGTSTP, &sigact, NULL) != 0)
		fatal("sigaction failed");

	event_del(&main_ev_sigterm);
}

d567 2
d572 3
d653 1
a653 1
			main_clear_signals();
@


1.76
log
@Make signal handler setup/teardown two common functions instead of six,
and reset SIGCHLD after fork to fix problems with some shells. From
Romain Francois.
@
text
@a20 1
#include <sys/wait.h>
a43 2
struct event_base *ev_base;

d61 1
d64 2
d241 1
d541 7
d553 1
a553 1
	ev_base = event_init();
d555 1
a555 1
	set_signals(main_signal);
d557 1
a557 6
	/* Initialise the client socket/start the server. */
	if ((main_ibuf = client_init(path, cmdflags, flags)) == NULL)
		exit(1);
	xfree(path);

	imsg_compose(main_ibuf, msg, PROTOCOL_VERSION, -1, -1, buf, len);
d567 1
a567 1
	clear_signals();
d572 47
a625 3
	case SIGCHLD:
		waitpid(WAIT_ANY, NULL, WNOHANG);
		break;
d704 1
a704 1
			clear_signals();
@


1.75
log
@Make the active pane border have a green foreground instead of
background by default.
@
text
@d1 1
a1 1
/* $OpenBSD: tmux.c,v 1.74 2010/04/18 13:41:29 nicm Exp $ */
d21 1
d45 2
a63 1
struct event	 main_ev_sigterm;
a65 2
void		 main_set_signals(void);
void		 main_clear_signals(void);
a240 1
	struct sigaction	 sigact;
d540 8
a547 6
	/* Catch SIGCHLD to avoid a zombie when starting the server. */
	memset(&sigact, 0, sizeof sigact);
	sigemptyset(&sigact.sa_mask);
	sigact.sa_handler = SIG_IGN;
	if (sigaction(SIGCHLD, &sigact, NULL) != 0)
		fatal("sigaction failed");
a553 2
	event_init();

a555 2
	main_set_signals();

d564 1
a564 1
	main_clear_signals();
a568 47
void
main_set_signals(void)
{
	struct sigaction	sigact;

	memset(&sigact, 0, sizeof sigact);
	sigemptyset(&sigact.sa_mask);
	sigact.sa_flags = SA_RESTART;
	sigact.sa_handler = SIG_IGN;
	if (sigaction(SIGINT, &sigact, NULL) != 0)
		fatal("sigaction failed");
	if (sigaction(SIGPIPE, &sigact, NULL) != 0)
		fatal("sigaction failed");
	if (sigaction(SIGUSR1, &sigact, NULL) != 0)
		fatal("sigaction failed");
	if (sigaction(SIGUSR2, &sigact, NULL) != 0)
		fatal("sigaction failed");
	if (sigaction(SIGTSTP, &sigact, NULL) != 0)
		fatal("sigaction failed");

	signal_set(&main_ev_sigterm, SIGTERM, main_signal, NULL);
	signal_add(&main_ev_sigterm, NULL);
}

void
main_clear_signals(void)
{
	struct sigaction	sigact;

	memset(&sigact, 0, sizeof sigact);
	sigemptyset(&sigact.sa_mask);
	sigact.sa_flags = SA_RESTART;
	sigact.sa_handler = SIG_DFL;
	if (sigaction(SIGINT, &sigact, NULL) != 0)
		fatal("sigaction failed");
	if (sigaction(SIGPIPE, &sigact, NULL) != 0)
		fatal("sigaction failed");
	if (sigaction(SIGUSR1, &sigact, NULL) != 0)
		fatal("sigaction failed");
	if (sigaction(SIGUSR2, &sigact, NULL) != 0)
		fatal("sigaction failed");
	if (sigaction(SIGTSTP, &sigact, NULL) != 0)
		fatal("sigaction failed");

	event_del(&main_ev_sigterm);
}

d576 3
d657 1
a657 1
			main_clear_signals();
@


1.74
log
@Catch SIGCHLD to avoid a zombie, from patrick keshishian.
@
text
@d1 1
a1 1
/* $OpenBSD: tmux.c,v 1.73 2010/02/22 20:41:16 nicm Exp $ */
d358 2
a359 2
	options_set_number(so, "pane-active-border-bg", 2);
	options_set_number(so, "pane-active-border-fg", 8);
@


1.73
log
@Option to set the characters considered word separators in copy mode, from
Micah Cowan.
@
text
@d1 1
a1 1
/* $OpenBSD: tmux.c,v 1.72 2010/02/08 00:14:38 nicm Exp $ */
d241 1
d541 8
@


1.72
log
@Add an option to disable the smcup/rmcup alternate screen behaviour inside
tmux. From clemens fischer.
@
text
@d1 1
a1 1
/* $OpenBSD: tmux.c,v 1.71 2010/02/06 18:47:41 nicm Exp $ */
d421 1
@


1.71
log
@Change nested check to compare server socket path rather than just assuming
that if $TMUX is set it is nested. From Micah Cowan.
@
text
@d1 1
a1 1
/* $OpenBSD: tmux.c,v 1.70 2010/02/06 18:29:15 nicm Exp $ */
d398 1
@


1.70
log
@Clean up $TMUX parsing, from Micah Cowan, tweaked by me.
@
text
@d1 1
a1 1
/* $OpenBSD: tmux.c,v 1.69 2010/02/06 17:15:33 nicm Exp $ */
d487 1
d503 1
a503 1
		cmdflags |= CMD_STARTSERVER|CMD_SENDENVIRON;
d520 2
d524 12
@


1.69
log
@Instead of bailing out on the first configuration file error, carry on,
collecting all the errors, then start with the active window in more mode
displaying them.
@
text
@d1 1
a1 1
/* $OpenBSD: tmux.c,v 1.68 2010/02/04 18:27:06 nicm Exp $ */
d49 6
d56 1
a56 1
void	 	 fill_session(struct msg_command_data *);
d138 1
a138 1
fill_session(struct msg_command_data *data)
d140 1
a140 1
	char		*env, *ptr1, *ptr2, buf[256];
d149 1
a149 1
	if ((ptr2 = strrchr(env, ',')) == NULL || ptr2 == env)
d151 1
a151 3
	for (ptr1 = ptr2 - 1; ptr1 > env && *ptr1 != ','; ptr1--)
		;
	if (*ptr1 != ',')
d153 8
a160 2
	ptr1++;
	ptr2++;
d162 2
a163 1
	len = ptr2 - ptr1 - 1;
d166 1
a166 1
	memcpy(buf, ptr1, len);
d174 2
a175 1
	ll = strtonum(ptr2, 0, UINT_MAX, &errstr);
d239 1
d254 1
d459 1
d463 2
a464 4
			if ((path = getenv("TMUX")) != NULL) {
				path = xstrdup(path);
				path[strcspn(path, ",")] = '\0';
			} else
d484 2
a485 1
		fill_session(&cmddata);
@


1.68
log
@Read the path from $TMUX if it is present and -L and -S are not given. Based on
a diff from Micah Cowan.
@
text
@d1 1
a1 1
/* $OpenBSD: tmux.c,v 1.67 2010/02/04 18:20:16 nicm Exp $ */
d435 1
a435 1
		if (access(cfg_file, R_OK) != 0) {
a437 5
		}
	} else {
		if (access(cfg_file, R_OK) != 0) {
			log_warn("%s", cfg_file);
			exit(1);
@


1.67
log
@Option to display the active pane in a different colour with the display-panes
command. From Paul Hoffman, thanks.
@
text
@d1 1
a1 1
/* $OpenBSD: tmux.c,v 1.66 2010/01/03 12:51:05 nicm Exp $ */
d446 21
a466 5
	if (label == NULL)
		label = xstrdup("default");
	if (path == NULL && (path = makesockpath(label)) == NULL) {
		log_warn("can't create socket");
		exit(1);
d468 2
a469 1
	xfree(label);
@


1.66
log
@Options to set the colour of the pane borders, with different colours for the
active pane.
@
text
@d1 1
a1 1
/* $OpenBSD: tmux.c,v 1.65 2009/12/14 10:43:41 nicm Exp $ */
d331 1
@


1.65
log
@New server option, escape-time, to set the timeout used to detect if escapes
are alone or part of a function key or meta sequence.
@
text
@d1 1
a1 1
/* $OpenBSD: tmux.c,v 1.64 2009/12/11 13:58:48 nicm Exp $ */
d342 4
@


1.64
log
@Use quiet variable, and add missing sentinel to options array.
@
text
@d1 1
a1 1
/* $OpenBSD: tmux.c,v 1.63 2009/12/10 09:16:52 nicm Exp $ */
d320 1
@


1.63
log
@Add "server options" which are server-wide and not bound to a session or
window. Set and displayed with "set -s" and "show -s".

Currently the only option is "quiet" (like command-line -q, allowing it to be
set from .tmux.conf), but others will come along.
@
text
@d1 1
a1 1
/* $OpenBSD: tmux.c,v 1.62 2009/12/03 22:50:10 nicm Exp $ */
d232 1
a232 1
	int	 		 opt, flags, quiet, cmdflags = 0;
d319 1
a319 1
	options_set_number(oo, "quiet", 0);
@


1.62
log
@Massive spaces->tabs and trailing whitespace cleanup, hopefully for the last
time now I've configured emacs to make them displayed in really annoying
colours...
@
text
@d1 1
a1 1
/* $OpenBSD: tmux.c,v 1.61 2009/11/26 21:37:13 nicm Exp $ */
d39 1
a44 1
int		 be_quiet;
d225 1
a225 1
	struct options		*so, *wo;
d232 1
a232 1
	int	 		 opt, flags, cmdflags = 0;
d271 1
a271 1
			be_quiet = 1;
d316 4
@


1.61
log
@Remove a couple of unused arguments where possible, and add /* ARGSUSED */ to
the rest to reduce lint output.
@
text
@d1 1
a1 1
/* $OpenBSD: tmux.c,v 1.60 2009/11/19 16:22:10 nicm Exp $ */
d222 1
a222 1
 	struct cmd		*cmd;
d314 1
a314 1
 	for (var = environ; *var != NULL; var++)
d397 1
a397 1
 	options_set_number(wo, "remain-on-exit", 0);
d400 1
a400 1
 	if (flags & IDENTIFY_UTF8) {
d435 1
a435 1
	
d450 1
a450 1
	
d457 1
a457 1
		
d493 1
a493 1
 	imsg_compose(main_ibuf, msg, PROTOCOL_VERSION, -1, -1, buf, len);
d529 1
a529 1
	
d553 1
a553 1
	
d575 1
a575 1
	
@


1.60
log
@Two new options, window-status-format and window-status-current-format, which
allow the format of each window in the status line window list to be controlled
using similar # sequences as status-left/right.

This diff also moves part of the way towards UTF-8 support in window names but
it isn't quite there yet.
@
text
@d1 1
a1 1
/* $OpenBSD: tmux.c,v 1.59 2009/11/19 14:06:34 nicm Exp $ */
d557 1
d567 1
@


1.59
log
@Revert to xterm-keys off by default. It was on as an experiment to see if the
option could be removed, but it affects vi, so we have to keep the option, and
a conservative default is better.
@
text
@d1 1
a1 1
/* $OpenBSD: tmux.c,v 1.58 2009/11/18 13:16:33 nicm Exp $ */
d394 2
@


1.58
log
@Add a per-client log of status line messages displayed while that client
exists. A new message-limit session option sets the maximum number of entries
and a command, show-messages, shows the log (bound to ~ by default).

This (and prompt history) might be better as a single global log but until
there are global options it is easier for them to be per client.
@
text
@d1 1
a1 1
/* $OpenBSD: tmux.c,v 1.57 2009/11/10 18:53:11 nicm Exp $ */
d394 1
a394 1
	options_set_number(wo, "xterm-keys", 1);
@


1.57
log
@There is no real standard for modifier plus function keys. Previously, tmux
output some from rxvt but in other ways did the same as xterm or other
terminals, but this is a bit inconsistent.

xterm's method is fairly sensible and we already support it (xterm-keys), so
enable it by default instead.
@
text
@d1 1
a1 1
/* $OpenBSD: tmux.c,v 1.56 2009/11/04 20:59:22 nicm Exp $ */
d335 1
@


1.56
log
@A couple of minor cosmetic changes.
@
text
@d1 1
a1 1
/* $OpenBSD: tmux.c,v 1.55 2009/11/04 20:50:11 nicm Exp $ */
d393 1
a393 1
	options_set_number(wo, "xterm-keys", 0);
@


1.55
log
@Initial changes to move tmux to libevent.

This moves the client-side loops are pretty much fully over to event-based only
(tmux.c and client.c) but server-side (server.c and friends) treats libevent as
a sort of clever poll, waking up after every event to run various things.

Moving the server stuff over to bufferevents and timers and so on will come
later.
@
text
@d1 1
a1 1
/* $OpenBSD: tmux.c,v 1.54 2009/11/04 12:41:43 nicm Exp $ */
a505 1

@


1.54
log
@Change declaration and use of malloc_options to be more standard, from Tim van
der Molen.
@
text
@d1 1
a1 1
/* $OpenBSD: tmux.c,v 1.53 2009/10/26 21:42:04 deraadt Exp $ */
d23 1
a37 7
volatile sig_atomic_t sigwinch;
volatile sig_atomic_t sigterm;
volatile sig_atomic_t sigcont;
volatile sig_atomic_t sigchld;
volatile sig_atomic_t sigusr1;
volatile sig_atomic_t sigusr2;

a51 1
int		 dispatch_imsg(struct imsgbuf *, const char *, int *);
d54 10
a86 90
void
sighandler(int sig)
{
	int	saved_errno;

	saved_errno = errno;
	switch (sig) {
	case SIGWINCH:
		sigwinch = 1;
		break;
	case SIGTERM:
		sigterm = 1;
		break;
	case SIGCHLD:
		sigchld = 1;
		break;
	case SIGCONT:
		sigcont = 1;
		break;
	case SIGUSR1:
		sigusr1 = 1;
		break;
	case SIGUSR2:
		sigusr2 = 1;
		break;
	}
	errno = saved_errno;
}

void
siginit(void)
{
	struct sigaction	 act;

	memset(&act, 0, sizeof act);
	sigemptyset(&act.sa_mask);
	act.sa_flags = SA_RESTART;

	act.sa_handler = SIG_IGN;
	if (sigaction(SIGPIPE, &act, NULL) != 0)
		fatal("sigaction failed");
	if (sigaction(SIGINT, &act, NULL) != 0)
		fatal("sigaction failed");
	if (sigaction(SIGTSTP, &act, NULL) != 0)
		fatal("sigaction failed");
	if (sigaction(SIGQUIT, &act, NULL) != 0)
		fatal("sigaction failed");

	act.sa_handler = sighandler;
	if (sigaction(SIGWINCH, &act, NULL) != 0)
		fatal("sigaction failed");
	if (sigaction(SIGTERM, &act, NULL) != 0)
		fatal("sigaction failed");
	if (sigaction(SIGCHLD, &act, NULL) != 0)
		fatal("sigaction failed");
	if (sigaction(SIGUSR1, &act, NULL) != 0)
		fatal("sigaction failed");
	if (sigaction(SIGUSR2, &act, NULL) != 0)
		fatal("sigaction failed");
}

void
sigreset(void)
{
	struct sigaction act;

	memset(&act, 0, sizeof act);
	sigemptyset(&act.sa_mask);

	act.sa_handler = SIG_DFL;
	if (sigaction(SIGPIPE, &act, NULL) != 0)
		fatal("sigaction failed");
	if (sigaction(SIGUSR1, &act, NULL) != 0)
		fatal("sigaction failed");
	if (sigaction(SIGUSR2, &act, NULL) != 0)
		fatal("sigaction failed");
	if (sigaction(SIGINT, &act, NULL) != 0)
		fatal("sigaction failed");
	if (sigaction(SIGTSTP, &act, NULL) != 0)
		fatal("sigaction failed");
	if (sigaction(SIGQUIT, &act, NULL) != 0)
		fatal("sigaction failed");
	if (sigaction(SIGWINCH, &act, NULL) != 0)
		fatal("sigaction failed");
	if (sigaction(SIGTERM, &act, NULL) != 0)
		fatal("sigaction failed");
	if (sigaction(SIGCHLD, &act, NULL) != 0)
		fatal("sigaction failed");
}

d197 21
a222 1
	struct pollfd		 pfd;
a226 1
	struct imsgbuf		*ibuf;
d232 2
a233 1
	int	 		 nfds, retcode, opt, flags, cmdflags = 0;
a294 1
	siginit();
d484 1
a484 1
	if ((ibuf = client_init(path, cmdflags, flags)) == NULL)
d488 13
a500 1
 	imsg_compose(ibuf, msg, PROTOCOL_VERSION, -1, -1, buf, len);
d502 4
a505 14
	retcode = 0;
	for (;;) {
		pfd.fd = ibuf->fd;
		pfd.events = POLLIN;
		if (ibuf->w.queued != 0)
			pfd.events |= POLLOUT;

		if ((nfds = poll(&pfd, 1, INFTIM)) == -1) {
			if (errno == EAGAIN || errno == EINTR)
				continue;
			fatal("poll failed");
		}
		if (nfds == 0)
			continue;
a506 2
		if (pfd.revents & (POLLERR|POLLHUP|POLLNVAL))
			fatalx("socket error");
d508 46
a553 4
		if (pfd.revents & POLLIN) {
			if (dispatch_imsg(ibuf, shellcmd, &retcode) != 0)
				break;
		}
d555 6
a560 4
		if (pfd.revents & POLLOUT) {
			if (msgbuf_write(&ibuf->w) < 0)
				fatalx("msgbuf_write failed");
		}
d562 1
d564 12
a575 2
	options_free(&global_s_options);
	options_free(&global_w_options);
d577 4
a580 1
	return (retcode);
d583 2
a584 2
int
dispatch_imsg(struct imsgbuf *ibuf, const char *shellcmd, int *retcode)
d591 1
a591 1
	if ((n = imsg_read(ibuf)) == -1 || n == 0)
d595 1
a595 1
		if ((n = imsg_get(ibuf, &imsg)) == -1)
d598 1
a598 1
			return (0);
d607 1
a607 1
			return (-1);
a608 2
			*retcode = 1;
			/* FALLTHROUGH */
d616 2
d623 2
a624 1
			client_main();	/* doesn't return */
d631 1
a631 2
			*retcode = 1;
			return (-1);
d637 3
a639 1
			
a646 23
}

__dead void
shell_exec(const char *shell, const char *shellcmd)
{
	const char	*shellname, *ptr;
	char		*argv0;

	sigreset();
				
	ptr = strrchr(shell, '/');
	if (ptr != NULL && *(ptr + 1) != '\0')
		shellname = ptr + 1;
	else
		shellname = shell;
	if (login_shell)
		xasprintf(&argv0, "-%s", shellname);
	else
		xasprintf(&argv0, "%s", shellname);
	setenv("SHELL", shell, 1);

	execl(shell, argv0, "-c", shellcmd, (char *) NULL);
	fatal("execl failed");
@


1.53
log
@tabs are better; ok nicm
@
text
@d1 1
a1 1
/* $OpenBSD: tmux.c,v 1.52 2009/10/25 21:11:21 nicm Exp $ */
d34 1
a34 1
const char	*malloc_options = "AFGJPX";
d301 4
@


1.52
log
@Remove the -d flag to tmux and just use op/AX to detect default colours.

Irritatingly, although op can be used to tell if a terminal supports default
colours, it can't be used to set them because in some terminfo descriptions it
resets attributes as a side-effect (acts as sgr0) and in others it doesn't, so
it is not possible to determine reliably what the terminal state will be
afterwards. So if AX is missing and op is present, tmux just sends sgr0.

Anyone using -d for a terminal who finds they actually needed it can replace it
using terminal-overrides, but please let me know as it is probably an omission
from terminfo.
@
text
@d1 1
a1 1
/* $OpenBSD: tmux.c,v 1.51 2009/10/22 10:04:07 nicm Exp $ */
d347 1
a347 1
                default:
d349 2
a350 2
                }
        }
d572 1
a572 1
                if (pfd.revents & POLLIN) {
d597 1
a597 1
        if ((n = imsg_read(ibuf)) == -1 || n == 0)
@


1.51
log
@Merge prepare_cmd into main as it is short and only called once.
@
text
@d1 1
a1 1
/* $OpenBSD: tmux.c,v 1.50 2009/10/21 20:11:47 nicm Exp $ */
d65 1
a65 1
	    "usage: %s [-28dlquv] [-c shell-command] [-f file] [-L socket-name]\n"
a318 3
			break;
		case 'd':
			flags |= IDENTIFY_HASDEFAULTS;
@


1.50
log
@Client tidying: get rid of client_ctx struct in favour of two variables in
client.c, and move the functions in client-fn.c into other files.
@
text
@d1 1
a1 1
/* $OpenBSD: tmux.c,v 1.49 2009/10/10 14:51:16 nicm Exp $ */
a57 1
int		 prepare_cmd(enum msgtype *, void **, size_t *, int, char **);
a284 20
prepare_cmd(enum msgtype *msg, void **buf, size_t *len, int argc, char **argv)
{
	static struct msg_command_data	 cmddata;

	fill_session(&cmddata);
	
	cmddata.argc = argc;
	if (cmd_pack_argv(argc, argv, cmddata.argv, sizeof cmddata.argv) != 0) {
		log_warnx("command too long");
		return (-1);
	}

	*buf = &cmddata;
	*len = sizeof cmddata;

	*msg = MSG_COMMAND;
	return (0);
}

int
d287 14
a300 13
	struct cmd_list	*cmdlist;
 	struct cmd	*cmd;
	struct pollfd	 pfd;
	enum msgtype	 msg;
	struct passwd	*pw;
	struct options	*so, *wo;
	struct keylist	*keylist;
	struct imsgbuf	*ibuf;
	char		*s, *shellcmd, *path, *label, *home, *cause;
	char		 cwd[MAXPATHLEN], **var;
	void		*buf;
	size_t		 len;
	int	 	 nfds, retcode, opt, flags, cmdflags = 0;
d512 14
a525 2
	} else if (prepare_cmd(&msg, &buf, &len, argc, argv) != 0)
		exit(1);
@


1.49
log
@New option, mouse-select-pane. If on, the mouse may be used to select the
current pane.

Suggested by sthen@@ and also by someone else ages ago who I have forgotten.
@
text
@d1 1
a1 1
/* $OpenBSD: tmux.c,v 1.48 2009/10/10 09:46:11 nicm Exp $ */
d56 1
d59 1
a59 1
int		 dispatch_imsg(struct client_ctx *, const char *, int *);
d219 38
d290 1
a290 1
	client_fill_session(&cmddata);
d308 13
a320 14
	struct client_ctx	 cctx;
	struct cmd_list		*cmdlist;
 	struct cmd		*cmd;
	struct pollfd	 	 pfd;
	enum msgtype		 msg;
	struct passwd		*pw;
	struct options		*so, *wo;
	struct keylist		*keylist;
	char			*s, *shellcmd, *path, *label, *home, *cause;
	char			 cwd[MAXPATHLEN], **var;
	void			*buf;
	size_t			 len;
	int	 		 retcode, opt, flags, cmdflags = 0;
	int			 nfds;
d559 1
a559 2
 	memset(&cctx, 0, sizeof cctx);
	if (client_init(path, &cctx, cmdflags, flags) != 0)
d563 1
a563 2
	client_write_server(&cctx, msg, buf, len);
	memset(buf, 0, len);
d567 1
a567 1
		pfd.fd = cctx.ibuf.fd;
d569 1
a569 1
		if (cctx.ibuf.w.queued != 0)
d584 1
a584 1
			if (dispatch_imsg(&cctx, shellcmd, &retcode) != 0)
d589 1
a589 1
			if (msgbuf_write(&cctx.ibuf.w) < 0)
d601 1
a601 1
dispatch_imsg(struct client_ctx *cctx, const char *shellcmd, int *retcode)
d608 1
a608 1
        if ((n = imsg_read(&cctx->ibuf)) == -1 || n == 0)
d612 1
a612 1
		if ((n = imsg_get(&cctx->ibuf, &imsg)) == -1)
d640 1
a640 2
			*retcode = client_main(cctx);
			return (-1);
@


1.48
log
@Support for individual session idle time locking. May be enabled by turning off
the lock-server option (it is on by default). When this is off, each session
locks when it has been idle for the lock-after-time setting. When on, the
entire server locks when ALL sessions have been idle for their individual
lock-after-time settings.

This replaces one global-only option (lock-after-time) with another
(lock-server), but the default behaviour is usually preferable so there don't
seem to be many alternatives.

Diff/idea largely from Thomas Adam, tweaked by me.
@
text
@d1 1
a1 1
/* $OpenBSD: tmux.c,v 1.47 2009/10/09 07:27:00 nicm Exp $ */
d384 1
@


1.47
log
@Add a simple synchronize-panes window option: when set, all input to any pane
that is part of the window is also sent to all other panes in the same
window. Suggested by several, most recently Tomasz Pajor.
@
text
@d1 1
a1 1
/* $OpenBSD: tmux.c,v 1.46 2009/09/23 12:03:31 nicm Exp $ */
a48 2
time_t		 server_activity;

d380 1
@


1.46
log
@Support -c like sh(1) to execute a command, useful when tmux is a login
shell. Suggested by halex@@.

This includes another protocol version increase (the last for now) so again
restart the tmux server before upgrading.
@
text
@d1 1
a1 1
/* $OpenBSD: tmux.c,v 1.45 2009/09/23 06:18:48 nicm Exp $ */
d444 1
@


1.45
log
@Remove the internal tmux locking and instead detach each client and run the
command specified by a new option "lock-command" (by default "lock -np") in
each client.

This means each terminal has to be unlocked individually but simplifies the
code and allows the system password to be used to unlock.

Note that the set-password command is gone, so it will need to be removed from
configuration files, and the -U command line flag has been removed.

This is the third protocol version change so again it is best to stop the tmux
server before upgrading.
@
text
@d1 1
a1 1
/* $OpenBSD: tmux.c,v 1.44 2009/09/22 12:38:10 nicm Exp $ */
d60 2
a61 1
int		 dispatch_imsg(struct client_ctx *, int *);
d67 1
a67 1
	    "usage: %s [-28dlquv] [-f file] [-L socket-name]\n"
d279 2
a280 2
	char			*s, *path, *label, *home, *cause, **var;
	char			 cwd[MAXPATHLEN];
d287 1
a287 1
	label = path = NULL;
d289 1
a289 1
	while ((opt = getopt(argc, argv, "28df:lL:qS:uUv")) != -1) {
d299 5
d341 3
d489 5
a493 1
	if (prepare_cmd(&msg, &buf, &len, argc, argv) != 0)
d496 3
a498 1
	if (argc == 0)	/* new-session is the default */
d547 1
a547 1
			if (dispatch_imsg(&cctx, &retcode) != 0)
d564 1
a564 1
dispatch_imsg(struct client_ctx *cctx, int *retcode)
d569 1
d613 7
d626 23
@


1.44
log
@Permit multiple prefix keys to be defined, separated by commas, for example:

set -g prefix ^a,^b

Any key in the list acts as the prefix. The send-prefix command always sends
the first key in the list.
@
text
@d1 1
a1 1
/* $OpenBSD: tmux.c,v 1.43 2009/09/18 15:19:27 nicm Exp $ */
a48 5
int		 server_locked;
struct passwd	*server_locked_pw;
u_int		 password_failures;
time_t		 password_backoff;
char		*server_password;
a58 1
int		 prepare_unlock(enum msgtype *, void **, size_t *, int);
d66 1
a66 1
	    "usage: %s [-28dlqUuv] [-f file] [-L socket-name]\n"
a247 29
prepare_unlock(enum msgtype *msg, void **buf, size_t *len, int argc)
{
	static struct msg_unlock_data	 unlockdata;
	char				*pass;

	if (argc != 0) {
		log_warnx("can't specify a command when unlocking");
		return (-1);
	}
	
	if ((pass = getpass("Password:")) == NULL)
		return (-1);

	if (strlen(pass) >= sizeof unlockdata.pass) {
		log_warnx("password too long");
		return (-1);
	}
		
	strlcpy(unlockdata.pass, pass, sizeof unlockdata.pass);
	memset(pass, 0, strlen(pass));

	*buf = &unlockdata;
	*len = sizeof unlockdata;

	*msg = MSG_UNLOCK;
	return (0);
}

int
d282 1
a282 1
	int	 		 retcode, opt, flags, unlock, cmdflags = 0;
d285 1
a285 1
	unlock = flags = 0;
a324 3
		case 'U':
			unlock = 1;
			break;
d372 1
d480 2
a481 7
	if (unlock) {
		if (prepare_unlock(&msg, &buf, &len, argc) != 0)
			exit(1);
	} else {
		if (prepare_cmd(&msg, &buf, &len, argc, argv) != 0)
			exit(1);
	}
d483 1
a483 3
	if (unlock)
		cmdflags &= ~CMD_STARTSERVER;
	else if (argc == 0)	/* new-session is the default */
@


1.43
log
@New option, set-titles-string, to allow the window title to be specified (as
for status-left/right) if set-titles is on. Also only update the title when the
status line is being redrawn.
@
text
@d1 1
a1 1
/* $OpenBSD: tmux.c,v 1.42 2009/09/04 15:15:24 nicm Exp $ */
d312 1
a412 1
	options_set_number(so, "prefix", '\002');
d441 5
@


1.42
log
@Tidy main and make it a bit easier to read.
@
text
@d1 1
a1 1
/* $OpenBSD: tmux.c,v 1.41 2009/09/02 17:34:57 nicm Exp $ */
d416 1
@


1.41
log
@Accept -l to make it easier for people who use tmux as a login shell to use
$SHELL. Originally from martynas@@, tweaked by me.
@
text
@d1 1
a1 1
/* $OpenBSD: tmux.c,v 1.40 2009/09/02 16:38:35 nicm Exp $ */
d311 1
d336 1
a336 1
			if (cfg_file)
a374 4
	environ_init(&global_environ);
 	for (var = environ; *var != NULL; var++)
		environ_put(&global_environ, *var);

d392 4
d397 39
a435 44
	options_set_number(&global_s_options, "base-index", 0);
	options_set_number(&global_s_options, "bell-action", BELL_ANY);
	options_set_number(&global_s_options, "buffer-limit", 9);
	options_set_string(&global_s_options, "default-command", "%s", "");
	options_set_string(
	    &global_s_options, "default-shell", "%s", getshell());
	options_set_string(&global_s_options, "default-terminal", "screen");
	options_set_number(&global_s_options, "display-panes-colour", 4);
	options_set_number(&global_s_options, "display-panes-time", 1000);
	options_set_number(&global_s_options, "display-time", 750);
	options_set_number(&global_s_options, "history-limit", 2000);
	options_set_number(&global_s_options, "lock-after-time", 0);
	options_set_number(&global_s_options, "message-attr", 0);
	options_set_number(&global_s_options, "message-bg", 3);
	options_set_number(&global_s_options, "message-fg", 0);
	options_set_number(&global_s_options, "prefix", '\002');
	options_set_number(&global_s_options, "repeat-time", 500);
	options_set_number(&global_s_options, "set-remain-on-exit", 0);
	options_set_number(&global_s_options, "set-titles", 0);
	options_set_number(&global_s_options, "status", 1);
	options_set_number(&global_s_options, "status-attr", 0);
	options_set_number(&global_s_options, "status-bg", 2);
	options_set_number(&global_s_options, "status-fg", 0);
	options_set_number(&global_s_options, "status-interval", 15);
	options_set_number(&global_s_options, "status-keys", MODEKEY_EMACS);
	options_set_number(&global_s_options, "status-justify", 0);
	options_set_string(&global_s_options, "status-left", "[#S]");
	options_set_number(&global_s_options, "status-left-attr", 0);
	options_set_number(&global_s_options, "status-left-fg", 8);
	options_set_number(&global_s_options, "status-left-bg", 8);
	options_set_number(&global_s_options, "status-left-length", 10);
	options_set_string(
	    &global_s_options, "status-right", "\"#22T\" %%H:%%M %%d-%%b-%%y");
	options_set_number(&global_s_options, "status-right-attr", 0);
	options_set_number(&global_s_options, "status-right-fg", 8);
	options_set_number(&global_s_options, "status-right-bg", 8);
	options_set_number(&global_s_options, "status-right-length", 40);
	if (flags & IDENTIFY_UTF8)
		options_set_number(&global_s_options, "status-utf8", 1);
	else
		options_set_number(&global_s_options, "status-utf8", 0);
	options_set_string(&global_s_options,
	    "terminal-overrides", "*88col*:colors=88,*256col*:colors=256");
	options_set_string(&global_s_options, "update-environment", "DISPLAY "
d437 3
a439 3
	options_set_number(&global_s_options, "visual-activity", 0);
	options_set_number(&global_s_options, "visual-bell", 0);
	options_set_number(&global_s_options, "visual-content", 0);
d442 41
a482 27
	options_set_number(&global_w_options, "aggressive-resize", 0);
	options_set_number(&global_w_options, "automatic-rename", 1);
	options_set_number(&global_w_options, "clock-mode-colour", 4);
	options_set_number(&global_w_options, "clock-mode-style", 1);
	options_set_number(&global_w_options, "force-height", 0);
	options_set_number(&global_w_options, "force-width", 0);
	options_set_number(&global_w_options, "main-pane-width", 81);
	options_set_number(&global_w_options, "main-pane-height", 24);
	options_set_number(&global_w_options, "mode-attr", 0);
	options_set_number(&global_w_options, "mode-bg", 3);
	options_set_number(&global_w_options, "mode-fg", 0);
	options_set_number(&global_w_options, "mode-keys", MODEKEY_EMACS);
	options_set_number(&global_w_options, "mode-mouse", 0);
	options_set_number(&global_w_options, "monitor-activity", 0);
	options_set_string(&global_w_options, "monitor-content", "%s", "");
	if (flags & IDENTIFY_UTF8)
		options_set_number(&global_w_options, "utf8", 1);
	else
		options_set_number(&global_w_options, "utf8", 0);
	options_set_number(&global_w_options, "window-status-attr", 0);
	options_set_number(&global_w_options, "window-status-bg", 8);
	options_set_number(&global_w_options, "window-status-fg", 8);
	options_set_number(&global_w_options, "window-status-current-attr", 0);
	options_set_number(&global_w_options, "window-status-current-bg", 8);
	options_set_number(&global_w_options, "window-status-current-fg", 8);
	options_set_number(&global_w_options, "xterm-keys", 0);
 	options_set_number(&global_w_options, "remain-on-exit", 0);
a510 9
	if (getcwd(cwd, sizeof cwd) == NULL) {
		pw = getpwuid(getuid());
		if (pw->pw_dir != NULL && *pw->pw_dir != '\0')
			strlcpy(cwd, pw->pw_dir, sizeof cwd);
		else
			strlcpy(cwd, "/", sizeof cwd);
	}
	options_set_string(&global_s_options, "default-path", "%s", cwd);

d521 1
a521 1
	else if (argc == 0)
@


1.40
log
@When incorrect passwords are entered, behave similarly to login(1) and backoff
for a bit. Based on a diff from martynas@@.
@
text
@d1 1
a1 1
/* $OpenBSD: tmux.c,v 1.39 2009/09/01 13:09:50 nicm Exp $ */
d60 1
d72 2
a73 2
	    "usage: %s [-28dqUuv] [-f file] [-L socket-name] [-S socket-path]\n"
	    "            [command [flags]]\n",
d320 3
a322 2
        while ((opt = getopt(argc, argv, "28df:L:qS:uUv")) != -1) {
                switch (opt) {
d338 3
@


1.39
log
@When using tmux as a login shell, there is currently no way to specify a shell
to be used as a login shell inside tmux, so add a default-shell session option.
This sets the shell invoked as a login shell when the default-command option is
empty.

The default option value is whichever of $SHELL, getpwuid(getuid())'s pw_shell
or /bin/sh is valid first.

Based on a diff from martynas@@, changed by me to be a session option rather
than a window option.
@
text
@d1 1
a1 1
/* $OpenBSD: tmux.c,v 1.38 2009/09/01 09:11:05 nicm Exp $ */
d50 1
d52 1
@


1.38
log
@Use "Password:" with no space for password prompts and don't display a *s for
the password, like pretty much everything else. From martynas@@ with minor
tweaks by me.
@
text
@d1 1
a1 1
/* $OpenBSD: tmux.c,v 1.37 2009/09/01 09:00:54 nicm Exp $ */
d178 44
d393 2
@


1.37
log
@Sort cases same as getopt argument, from martynas.
@
text
@d1 1
a1 1
/* $OpenBSD: tmux.c,v 1.36 2009/08/31 20:46:19 nicm Exp $ */
d217 1
a217 1
	if ((pass = getpass("Password: ")) == NULL)
@


1.36
log
@Add a new display-panes command, with two options (display-panes-colour and
display-panes-time), which displays a visual indication of the number of each
pane.
@
text
@d1 1
a1 1
/* $OpenBSD: tmux.c,v 1.35 2009/08/23 18:21:02 nicm Exp $ */
d283 3
d296 3
a303 3
		case 'q':
			be_quiet = 1;
			break;
a308 3
			break;
		case 'd':
			flags |= IDENTIFY_HASDEFAULTS;
@


1.35
log
@Add some other obvious variables to update-environment (WINDOWID SSH_ASKPASS
SSH_AUTH_SOCK SSH_AGENT_PID SSH_CONNECTION) so they are updated in the session
environment on new/attach.
@
text
@d1 1
a1 1
/* $OpenBSD: tmux.c,v 1.34 2009/08/13 21:56:14 nicm Exp $ */
d350 2
@


1.34
log
@Disable mode-mouse (mouse in copy/choice mode) by default as it isn't very
useful at the moment and causes confusion.
@
text
@d1 1
a1 1
/* $OpenBSD: tmux.c,v 1.33 2009/08/13 20:11:58 nicm Exp $ */
d384 2
a385 1
	options_set_string(&global_s_options, "update-environment", "DISPLAY");
@


1.33
log
@Add a base-index session option to specify the first index checked when looking
for an index for a new window.
@
text
@d1 1
a1 1
/* $OpenBSD: tmux.c,v 1.32 2009/08/12 09:14:25 nicm Exp $ */
d402 1
a402 1
	options_set_number(&global_w_options, "mode-mouse", 1);
@


1.32
log
@When started as the shell, __progname contains a leading -, so hardcode "tmux"
for socket path and log files, and strip it when working out the shell.
@
text
@d1 1
a1 1
/* $OpenBSD: tmux.c,v 1.31 2009/08/11 17:18:35 nicm Exp $ */
d345 1
@


1.31
log
@Switch tmux to use imsg. This is the last major change to make the
client-server protocol more resilient and make the protocol versioning work
properly. In future, the only things requiring a protocol version bump will be
changes in the message structs, and (when both client and server have this
change) mixing different versions should nicely report an error message.

As a side effect this also makes the code tidier, fixes a problem with the way
errors reported during server startup were handled, and supports fd passing
(which will be used in future).

Looked over by eric@@, thanks.

Please note that mixing a client with this change with an older server or vice
versa may cause tmux to crash or hang - tmux should be completely exited before
upgrading.
@
text
@d1 1
a1 1
/* $OpenBSD: tmux.c,v 1.30 2009/08/10 20:51:29 nicm Exp $ */
d82 1
a82 2
		xasprintf(
		    &path, "%s-%s-%ld.log", __progname, name, (long) getpid());
d186 1
a186 1
	xsnprintf(base, MAXPATHLEN, "%s/%s-%d", _PATH_TMP, __progname, uid);
@


1.30
log
@No arguments are the same as new-session and this requires the environment to
be sent, so set that flag too when argc == 0.
@
text
@d1 1
a1 1
/* $OpenBSD: tmux.c,v 1.29 2009/08/08 21:52:43 nicm Exp $ */
d63 1
a263 1
	struct hdr	 	 hdr;
a264 1
	struct msg_print_data	 printdata;
d270 1
d496 1
a496 1
		pfd.fd = cctx.srv_fd;
d498 1
a498 1
		if (BUFFER_USED(cctx.srv_out) > 0)
d501 1
a501 1
		if (poll(&pfd, 1, INFTIM) == -1) {
d506 29
d536 2
a537 2
		if (buffer_poll(&pfd, cctx.srv_in, cctx.srv_out) != 0)
			goto out;
d539 6
a544 7
	restart:
		if (BUFFER_USED(cctx.srv_in) < sizeof hdr)
			continue;
		memcpy(&hdr, BUFFER_OUT(cctx.srv_in), sizeof hdr);
		if (BUFFER_USED(cctx.srv_in) < (sizeof hdr) + hdr.size)
			continue;
		buffer_remove(cctx.srv_in, sizeof hdr);
d546 1
a546 1
		switch (hdr.type) {
d549 4
a552 1
			goto out;
d554 1
a554 1
			retcode = 1;
d557 1
a557 1
			if (hdr.size < sizeof printdata)
d559 2
a560 1
			buffer_read(cctx.srv_in, &printdata, sizeof printdata);
a561 1
			printdata.msg[(sizeof printdata.msg) - 1] = '\0';
d563 1
a563 1
			goto restart;
d565 13
a577 2
			retcode = client_main(&cctx);
			goto out;
d579 1
a579 1
			fatalx("unexpected command");
d581 2
a583 10

out:
	options_free(&global_s_options);
	options_free(&global_w_options);

	close(cctx.srv_fd);
	buffer_destroy(cctx.srv_in);
	buffer_destroy(cctx.srv_out);

	return (retcode);
@


1.29
log
@Infrastructure and commands to manage the environment for processes started
within tmux.

There is a global environment, copied from the external environment when the
server is started and each sesssion has an (initially empty) session
environment which overrides it.

New commands set-environment and show-environment manipulate or display the
environments.

A new session option, update-environment, is a space-separated list of
variables which are updated from the external environment into the session
environment every time a new session is created - the default is DISPLAY.
@
text
@d1 1
a1 1
/* $OpenBSD: tmux.c,v 1.28 2009/08/08 20:36:42 nicm Exp $ */
d465 1
a465 1
		cmdflags |= CMD_STARTSERVER;
@


1.28
log
@Options to set the colours and attributes for status-left/-right. From Thomas
Adam, thanks.
@
text
@d1 1
a1 1
/* $OpenBSD: tmux.c,v 1.27 2009/08/05 16:26:38 nicm Exp $ */
d47 1
d266 1
a266 1
	char			*s, *path, *label, *home, *cause;
d324 4
d384 1
d478 1
a478 1
			if (cmd->entry->flags & CMD_STARTSERVER) {
d480 2
a481 2
				break;
			}
@


1.27
log
@If colours are not supported by the terminal, try to emulate a coloured
background by setting or clearing the reverse attribute.

This makes a few applications which don't use the reverse attribute themselves
a little happier, and allows the status, message and mode options to have
default attributes and fg/bg options that work as expected when set as reverse.
@
text
@d1 1
a1 1
/* $OpenBSD: tmux.c,v 1.26 2009/08/04 10:31:28 nicm Exp $ */
d362 4
a366 2
	options_set_number(&global_s_options, "status-right-length", 40);
	options_set_string(&global_s_options, "status-left", "[#S]");
d369 4
@


1.26
log
@Check for "UTF8" as well as "UTF-8" in LANG etc as it seems this may also
appear.
@
text
@d1 1
a1 1
/* $OpenBSD: tmux.c,v 1.25 2009/08/03 14:10:54 nicm Exp $ */
d348 1
a348 1
	options_set_number(&global_s_options, "message-attr", GRID_ATTR_REVERSE);
d356 1
a356 1
	options_set_number(&global_s_options, "status-attr", GRID_ATTR_REVERSE);
d386 1
a386 1
	options_set_number(&global_w_options, "mode-attr", GRID_ATTR_REVERSE);
@


1.25
log
@Add a terminal-overrides session option allowing individual terminfo(5) entries
to be overridden. The 88col/256col checks are now moved into the default
setting and out of the code.

Also remove a couple of old workarounds for xterm and rxvt which are no longer
necessary (tmux can emulate them if missing).
@
text
@d1 1
a1 1
/* $OpenBSD: tmux.c,v 1.24 2009/07/30 07:04:50 nicm Exp $ */
d335 2
a336 1
		if (s != NULL && strcasestr(s, "UTF-8") != NULL)
@


1.24
log
@Add a mode-mouse option to prevent tmux taking over the mouse in choice or copy
modes.
@
text
@d1 1
a1 1
/* $OpenBSD: tmux.c,v 1.23 2009/07/29 14:17:26 nicm Exp $ */
d370 2
@


1.23
log
@Rename struct hdrtype to msgtype which is a better name and can be used even
when struct hdr disappears.
@
text
@d1 1
a1 1
/* $OpenBSD: tmux.c,v 1.22 2009/07/29 05:36:53 nicm Exp $ */
a380 1
	options_set_number(&global_w_options, "mode-attr", GRID_ATTR_REVERSE);
d383 1
d387 1
@


1.22
log
@Taking account of the "s, 22 not 24 is the maximum length of #T in status-right
to prevent the date being cut off.
@
text
@d1 1
a1 1
/* $OpenBSD: tmux.c,v 1.21 2009/07/26 12:58:44 nicm Exp $ */
d60 2
a61 2
int		 prepare_unlock(enum hdrtype *, void **, size_t *, int);
int		 prepare_cmd(enum hdrtype *, void **, size_t *, int, char **);
d206 1
a206 1
prepare_unlock(enum hdrtype *msg, void **buf, size_t *len, int argc)
d235 1
a235 1
prepare_cmd(enum hdrtype *msg, void **buf, size_t *len, int argc, char **argv)
d261 1
a261 1
	enum hdrtype		 msg;
@


1.21
log
@Make all messages sent between the client and server fixed size.

This is the first of two changes to make the protocol more resilient and less
sensitive to other changes in the code, particularly with commands. The client
now packs argv into a buffer and sends it to the server for parsing, rather
than doing it itself and sending the parsed command data.

As a side-effect this also removes a lot of now-unused command marshalling
code.

Mixing a server without this change and a client with or vice versa will cause
tmux to hang or crash, please ensure that tmux is entirely killed before
upgrading.
@
text
@d1 1
a1 1
/* $OpenBSD: tmux.c,v 1.20 2009/07/22 21:58:56 nicm Exp $ */
d365 1
a365 1
	    &global_s_options, "status-right", "\"#24T\" %%H:%%M %%d-%%b-%%y");
@


1.20
log
@Pass a set of flags into client_init rather than just a start_server
variable. Only one flag now but more to come later.
@
text
@d1 1
a1 1
/* $OpenBSD: tmux.c,v 1.19 2009/07/20 14:37:51 nicm Exp $ */
d60 2
d206 49
a257 2
	struct msg_command_data	 cmddata;
	struct buffer		*b;
d261 1
d264 2
a265 1
	char			*s, *path, *label, *cause, *home, *pass = NULL;
d267 2
d420 1
a420 1

d439 1
a439 2
		if (argc != 0) {
			log_warnx("can't specify a command when unlocking");
d441 2
a442 3
		}
		cmdlist = NULL;
		if ((pass = getpass("Password: ")) == NULL)
d444 3
d448 11
a458 15
	} else {
		if (argc == 0) {
			cmd = xmalloc(sizeof *cmd);
			cmd->entry = &cmd_new_session_entry;
			cmd->entry->init(cmd, 0);

			cmdlist = xmalloc(sizeof *cmdlist);
			TAILQ_INIT(cmdlist);
			TAILQ_INSERT_HEAD(cmdlist, cmd, qentry);
		} else {
			cmdlist = cmd_list_parse(argc, argv, &cause);
			if (cmdlist == NULL) {
				log_warnx("%s", cause);
				exit(1);
			}
d460 1
d467 1
d475 2
a476 14
	b = buffer_create(BUFSIZ);
	if (unlock) {
		cmd_send_string(b, pass);
		memset(pass, 0, strlen(pass));
		client_write_server(
		    &cctx, MSG_UNLOCK, BUFFER_OUT(b), BUFFER_USED(b));
	} else {
		cmd_list_send(cmdlist, b);
		cmd_list_free(cmdlist);
		client_fill_session(&cmddata);
		client_write_server2(&cctx, MSG_COMMAND,
		    &cmddata, sizeof cmddata, BUFFER_OUT(b), BUFFER_USED(b));
	}
	buffer_destroy(b);
d510 1
a510 1
			if (hdr.size > INT_MAX - 1)
d512 4
a515 4
			log_info("%.*s",
			    (int) hdr.size, BUFFER_OUT(cctx.srv_in));
			if (hdr.size != 0)
				buffer_remove(cctx.srv_in, hdr.size);
@


1.19
log
@Display the number of failed password attempts (if any) when the server is
locked. From Tom Doherty.
@
text
@d1 1
a1 1
/* $OpenBSD: tmux.c,v 1.18 2009/07/20 14:32:09 nicm Exp $ */
d216 1
a216 1
	int	 		 retcode, opt, flags, unlock, start_server;
d393 1
a393 1
		start_server = 0;
a409 1
		start_server = 0;
d412 1
a412 1
				start_server = 1;
d419 1
a419 1
	if (client_init(path, &cctx, start_server, flags) != 0)
@


1.18
log
@Add a status-justify option to allow the window list in the status line to be
positioned at the left, centre, or right.
@
text
@d1 1
a1 1
/* $OpenBSD: tmux.c,v 1.17 2009/07/20 09:15:18 nicm Exp $ */
d49 1
@


1.17
log
@New options, window-status-current-{fg,bg,attr}, to set the fg, bg and
attributes with which the current window is shown in the status line. From
Johan Friis, thanks.
@
text
@d1 1
a1 1
/* $OpenBSD: tmux.c,v 1.16 2009/07/18 14:59:25 nicm Exp $ */
d306 1
@


1.16
log
@Add three new session options: visual-activity, visual-bell, visual-content. If
these are enabled (and the monitor-activity, bell-actio and monitor-content
options are configurated appropriately), when activity, a bell, or content is
detected, a message is shown.

Also tidy up the bell/activity/content code in server.c slightly and fix a
couple of errors.
@
text
@d1 1
a1 1
/* $OpenBSD: tmux.c,v 1.15 2009/07/17 13:38:03 nicm Exp $ */
d341 3
@


1.15
log
@If -u is specified or UTF-8 is otherwise detected when the server is started,
enable the utf8 and status-utf8 optons. While here, note in the man page that
the server is started with the first session and exits when none remain.
@
text
@d1 1
a1 1
/* $OpenBSD: tmux.c,v 1.14 2009/07/10 05:50:54 nicm Exp $ */
d315 3
@


1.14
log
@Add a default-terminal option to set the starting value of $TERM in new
windows.

This is "screen" by default and must be either that or something closely
related. This does makes it easier to customise it if necessary.
@
text
@d1 1
a1 1
/* $OpenBSD: tmux.c,v 1.13 2009/07/08 05:26:45 nicm Exp $ */
d269 16
d311 4
a314 1
	options_set_number(&global_s_options, "status-utf8", 0);
d331 4
a334 1
	options_set_number(&global_w_options, "utf8", 0);
a339 16

	if (!(flags & IDENTIFY_UTF8)) {
		/*
		 * If the user has set whichever of LC_ALL, LC_CTYPE or LANG
		 * exist (in that order) to contain UTF-8, it is a safe
		 * assumption that either they are using a UTF-8 terminal, or
		 * if not they know that output from UTF-8-capable programs may
		 * be wrong.
		 */
		if ((s = getenv("LC_ALL")) == NULL) {
			if ((s = getenv("LC_CTYPE")) == NULL)
				s = getenv("LANG");
		}
		if (s != NULL && strcasestr(s, "UTF-8") != NULL)
			flags |= IDENTIFY_UTF8;
	}
@


1.13
log
@Just appending -l to $SHELL to create a login shell is wrong: -l is not POSIX,
and some people may use shells which do not support it. Instead, make an empty
default-command option mean a login shell, and fork it with a - in argv[0]
which is the method used by login(1).

Also fix the automatic-rename code to handle this correctly and to strip a
leading - if present.
@
text
@d1 1
a1 1
/* $OpenBSD: tmux.c,v 1.12 2009/07/07 19:49:19 nicm Exp $ */
d273 1
@


1.12
log
@Rename the global options variables to be shorter and to make session options
clear. No functional change, getting this out of the way to make later options
changes easier.
@
text
@d1 1
a1 1
/* $OpenBSD: tmux.c,v 1.11 2009/06/25 06:54:32 nicm Exp $ */
a211 1
	const char		*shell;
d272 1
a359 11

	shell = getenv("SHELL");
	if (shell == NULL || *shell == '\0') {
		pw = getpwuid(getuid());
		if (pw != NULL)
			shell = pw->pw_shell;
		if (shell == NULL || *shell == '\0')
			shell = _PATH_BSHELL;
	}
	options_set_string(
	    &global_s_options, "default-command", "exec %s -l", shell);
@


1.11
log
@If getcwd() fails, use the user's home directory, or /, instead of failing with
an error.
@
text
@d1 1
a1 1
/* $OpenBSD: tmux.c,v 1.10 2009/06/25 06:40:25 nicm Exp $ */
d45 2
a46 2
struct options	 global_options;
struct options	 global_window_options;
d270 22
a291 22
	options_init(&global_options, NULL);
	options_set_number(&global_options, "bell-action", BELL_ANY);
	options_set_number(&global_options, "buffer-limit", 9);
	options_set_number(&global_options, "display-time", 750);
	options_set_number(&global_options, "history-limit", 2000);
	options_set_number(&global_options, "lock-after-time", 0);
	options_set_number(&global_options, "message-attr", GRID_ATTR_REVERSE);
	options_set_number(&global_options, "message-bg", 3);
	options_set_number(&global_options, "message-fg", 0);
	options_set_number(&global_options, "prefix", '\002');
	options_set_number(&global_options, "repeat-time", 500);
	options_set_number(&global_options, "set-remain-on-exit", 0);
	options_set_number(&global_options, "set-titles", 0);
	options_set_number(&global_options, "status", 1);
	options_set_number(&global_options, "status-attr", GRID_ATTR_REVERSE);
	options_set_number(&global_options, "status-bg", 2);
	options_set_number(&global_options, "status-fg", 0);
	options_set_number(&global_options, "status-interval", 15);
	options_set_number(&global_options, "status-keys", MODEKEY_EMACS);
	options_set_number(&global_options, "status-left-length", 10);
	options_set_number(&global_options, "status-right-length", 40);
	options_set_string(&global_options, "status-left", "[#S]");
d293 2
a294 2
	    &global_options, "status-right", "\"#24T\" %%H:%%M %%d-%%b-%%y");
	options_set_number(&global_options, "status-utf8", 0);
d296 21
a316 22
	options_init(&global_window_options, NULL);
	options_set_number(&global_window_options, "aggressive-resize", 0);
	options_set_number(&global_window_options, "automatic-rename", 1);
	options_set_number(&global_window_options, "clock-mode-colour", 4);
	options_set_number(&global_window_options, "clock-mode-style", 1);
	options_set_number(&global_window_options, "force-height", 0);
	options_set_number(&global_window_options, "force-width", 0);
	options_set_number(
	    &global_window_options, "mode-attr", GRID_ATTR_REVERSE);
	options_set_number(&global_window_options, "main-pane-width", 81);
	options_set_number(&global_window_options, "main-pane-height", 24);
	options_set_number(&global_window_options, "mode-bg", 3);
	options_set_number(&global_window_options, "mode-fg", 0);
	options_set_number(&global_window_options, "mode-keys", MODEKEY_EMACS);
	options_set_number(&global_window_options, "monitor-activity", 0);
	options_set_string(&global_window_options, "monitor-content", "%s", "");
	options_set_number(&global_window_options, "utf8", 0);
	options_set_number(&global_window_options, "window-status-attr", 0);
	options_set_number(&global_window_options, "window-status-bg", 8);
	options_set_number(&global_window_options, "window-status-fg", 8);
	options_set_number(&global_window_options, "xterm-keys", 0);
 	options_set_number(&global_window_options, "remain-on-exit", 0);
d370 1
a370 1
	    &global_options, "default-command", "exec %s -l", shell);
d379 1
a379 1
	options_set_string(&global_options, "default-path", "%s", cwd);
d483 2
a484 2
	options_free(&global_options);
	options_free(&global_window_options);
@


1.10
log
@Remove error about using -L and -S together which was never displayed as
logging wasn't yet enabled, was unnecessary, and contradicted the man page
which says using -S will cause -L to be ignored.
@
text
@d1 1
a1 1
/* $OpenBSD: tmux.c,v 1.9 2009/06/23 18:27:40 nicm Exp $ */
d374 5
a378 2
		log_warn("getcwd");
		exit(1);
@


1.9
log
@LC_ALL overrides LC_CTYPE and LANG. Comment was correct but the code
wrong. Pointed out by Hannah Schroeter, thanks.
@
text
@d1 1
a1 1
/* $OpenBSD: tmux.c,v 1.8 2009/06/05 07:22:23 nicm Exp $ */
a235 4
			if (path != NULL) {
				log_warnx("-L and -S cannot be used together");
				exit(1);
			}
a240 4
			if (label != NULL) {
				log_warnx("-L and -S cannot be used together");
				exit(1);
			}
@


1.8
log
@Check the first of LC_CTYPE, LC_ALL and LANG, rather than just the last, when
trying to decide about UTF-8, and use strcasestr. Reported by Geert Hendrickx.
@
text
@d1 1
a1 1
/* $OpenBSD: tmux.c,v 1.7 2009/06/04 21:56:14 nicm Exp $ */
d335 2
a336 2
		if ((s = getenv("LC_CTYPE")) == NULL) {
			if ((s = getenv("LC_ALL")) == NULL)
@


1.7
log
@Zero the password given to -U in the client as well.
@
text
@d1 1
a1 1
/* $OpenBSD: tmux.c,v 1.6 2009/06/03 17:04:16 nicm Exp $ */
d329 2
a330 1
		 * If the user has set LANG to contain UTF-8, it is a safe
d335 5
a339 1
		if ((s = getenv("LANG")) != NULL && strstr(s, "UTF-8") != NULL)
@


1.6
log
@Do not set the window title by default (make set-titles option default to off),
wiping over the title is rude and annoying. Agreed by several.
@
text
@d1 1
a1 1
/* $OpenBSD: tmux.c,v 1.5 2009/06/03 16:54:26 nicm Exp $ */
d424 1
@


1.5
log
@New session option, status-utf8, to control the interpretation of top-bit-set
characters in status-left and status-right (if on, they are treated as UTF-8;
otherwise passed through).
@
text
@d1 1
a1 1
/* $OpenBSD: tmux.c,v 1.4 2009/06/02 16:53:20 sobrado Exp $ */
d290 1
a290 1
	options_set_number(&global_options, "set-titles", 1);
@


1.4
log
@remove unused flag; while here, make usage's output fit on 80-column displays.
@
text
@d1 1
a1 1
/* $OpenBSD: tmux.c,v 1.3 2009/06/02 15:55:32 pyr Exp $ */
d302 1
@


1.3
log
@spawn login shells by default, adapt manpage bits as well.
ok nicm@@
@
text
@d1 1
a1 1
/* $OpenBSD: tmux.c,v 1.2 2009/06/02 10:49:40 ray Exp $ */
d63 3
a65 2
	fprintf(stderr, "usage: %s [-28dqUuVv] [-f file] "
	    "[-L socket-name] [-S socket-path] [command [flags]]\n",
@


1.2
log
@Don't leak memory if multiple -f flags are given.

OK nicm@@
@
text
@d1 1
a1 1
/* $OpenBSD: tmux.c,v 1.1 2009/06/01 22:58:49 nicm Exp $ */
d372 1
a372 1
	    &global_options, "default-command", "exec %s", shell);
@


1.1
log
@Import tmux, a terminal multiplexor allowing (among other things) a single
terminal to be switched between several different windows and programs
displayed on one terminal be detached from one terminal and moved to another.

ok deraadt pirofti
@
text
@d1 1
a1 1
/* $OpenBSD$ */
d230 2
@

