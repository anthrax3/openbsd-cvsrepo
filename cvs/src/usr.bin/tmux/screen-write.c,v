head	1.121;
access;
symbols
	OPENBSD_6_1:1.116.0.4
	OPENBSD_6_1_BASE:1.116
	OPENBSD_6_0:1.92.0.2
	OPENBSD_6_0_BASE:1.92
	OPENBSD_5_9:1.85.0.2
	OPENBSD_5_9_BASE:1.85
	OPENBSD_5_8:1.73.0.4
	OPENBSD_5_8_BASE:1.73
	OPENBSD_5_7:1.72.0.2
	OPENBSD_5_7_BASE:1.72
	OPENBSD_5_6:1.69.0.4
	OPENBSD_5_6_BASE:1.69
	OPENBSD_5_5:1.68.0.4
	OPENBSD_5_5_BASE:1.68
	OPENBSD_5_4:1.67.0.2
	OPENBSD_5_4_BASE:1.67
	OPENBSD_5_3:1.60.0.2
	OPENBSD_5_3_BASE:1.60
	OPENBSD_5_2:1.56.0.2
	OPENBSD_5_2_BASE:1.56
	OPENBSD_5_1_BASE:1.52
	OPENBSD_5_1:1.52.0.2
	OPENBSD_5_0:1.50.0.2
	OPENBSD_5_0_BASE:1.50
	OPENBSD_4_9:1.46.0.2
	OPENBSD_4_9_BASE:1.46
	OPENBSD_4_8:1.43.0.2
	OPENBSD_4_8_BASE:1.43
	OPENBSD_4_7:1.41.0.2
	OPENBSD_4_7_BASE:1.41
	OPENBSD_4_6:1.9.0.4
	OPENBSD_4_6_BASE:1.9;
locks; strict;
comment	@ * @;


1.121
date	2017.05.12.10.50.11;	author nicm;	state Exp;
branches;
next	1.120;
commitid	NrV8qEjGzQCLtssv;

1.120
date	2017.05.11.11.39.30;	author nicm;	state Exp;
branches;
next	1.119;
commitid	Jf8hXcqwk3vMnHcd;

1.119
date	2017.04.29.21.27.46;	author nicm;	state Exp;
branches;
next	1.118;
commitid	8ixxCqGxy3TDwrp0;

1.118
date	2017.04.25.18.30.29;	author nicm;	state Exp;
branches;
next	1.117;
commitid	nqUaGBE0wtGMeCFj;

1.117
date	2017.04.22.10.30.56;	author nicm;	state Exp;
branches;
next	1.116;
commitid	yeGdY0mdM33mlawi;

1.116
date	2017.03.07.13.48.28;	author nicm;	state Exp;
branches;
next	1.115;
commitid	usxbWjwQQwOMZu3R;

1.115
date	2017.03.06.09.02.36;	author nicm;	state Exp;
branches;
next	1.114;
commitid	5fzOtYKh7MKbhTa8;

1.114
date	2017.02.21.10.30.15;	author nicm;	state Exp;
branches;
next	1.113;
commitid	c5xRE4XTbqCQcM6c;

1.113
date	2017.02.16.12.43.08;	author nicm;	state Exp;
branches;
next	1.112;
commitid	GSXBUYuB7NfRr3J3;

1.112
date	2017.02.09.10.09.14;	author nicm;	state Exp;
branches;
next	1.111;
commitid	bW3tsAsOs6b24fl9;

1.111
date	2017.02.09.09.33.15;	author nicm;	state Exp;
branches;
next	1.110;
commitid	zDTCvM7Slf0TU9mM;

1.110
date	2017.02.08.17.31.09;	author nicm;	state Exp;
branches;
next	1.109;
commitid	AzNCw8YfPlNCzX1E;

1.109
date	2017.02.08.16.45.18;	author nicm;	state Exp;
branches;
next	1.108;
commitid	ZNCPaF6tGzHeJGxd;

1.108
date	2017.02.08.15.49.29;	author nicm;	state Exp;
branches;
next	1.107;
commitid	9p1dhEKzsTLyX59I;

1.107
date	2017.02.08.15.41.41;	author nicm;	state Exp;
branches;
next	1.106;
commitid	0JCt4hH6x9rwToOE;

1.106
date	2017.02.08.08.50.10;	author nicm;	state Exp;
branches;
next	1.105;
commitid	5cRmkTFFolQ68i4L;

1.105
date	2017.02.06.19.26.49;	author nicm;	state Exp;
branches;
next	1.104;
commitid	Rhdtq12XKh2I54nR;

1.104
date	2017.02.06.13.23.00;	author nicm;	state Exp;
branches;
next	1.103;
commitid	qejB8XDaRPwhZhRq;

1.103
date	2017.01.12.00.19.32;	author nicm;	state Exp;
branches;
next	1.102;
commitid	5Rj7IbEXrGVYho74;

1.102
date	2017.01.05.09.07.16;	author nicm;	state Exp;
branches;
next	1.101;
commitid	al9tcSDvFKlm4Qpq;

1.101
date	2016.12.09.21.39.27;	author nicm;	state Exp;
branches;
next	1.100;
commitid	bj3djzEC5gw7ET61;

1.100
date	2016.10.18.08.39.18;	author nicm;	state Exp;
branches;
next	1.99;
commitid	5T1y99Ycy3Qpfoun;

1.99
date	2016.10.13.20.27.27;	author nicm;	state Exp;
branches;
next	1.98;
commitid	txCyQ5BkKJtZRzfT;

1.98
date	2016.10.12.15.43.51;	author nicm;	state Exp;
branches;
next	1.97;
commitid	4NQncIarrK44peBa;

1.97
date	2016.10.12.13.24.07;	author nicm;	state Exp;
branches;
next	1.96;
commitid	qR81tw3cGEFCEM0c;

1.96
date	2016.10.05.22.00.29;	author nicm;	state Exp;
branches;
next	1.95;
commitid	IWBUHL3LahIFScJW;

1.95
date	2016.10.05.12.36.36;	author nicm;	state Exp;
branches;
next	1.94;
commitid	cvr9q2HomdmGpU9F;

1.94
date	2016.09.29.08.50.43;	author nicm;	state Exp;
branches;
next	1.93;
commitid	RgUeRcNTAAeA0uT6;

1.93
date	2016.09.02.20.57.20;	author nicm;	state Exp;
branches;
next	1.92;
commitid	KNa3UznuiHkLoVpf;

1.92
date	2016.07.15.00.49.08;	author nicm;	state Exp;
branches;
next	1.91;
commitid	4uHSvNNDvwUmOB9Y;

1.91
date	2016.07.15.00.42.56;	author nicm;	state Exp;
branches;
next	1.90;
commitid	EramuEV0ciOaJqkF;

1.90
date	2016.06.06.07.28.52;	author nicm;	state Exp;
branches;
next	1.89;
commitid	SyahRiFMqLwjdSRW;

1.89
date	2016.05.30.09.32.24;	author nicm;	state Exp;
branches;
next	1.88;
commitid	14zEbZuuirCyz38L;

1.88
date	2016.05.27.23.06.12;	author nicm;	state Exp;
branches;
next	1.87;
commitid	tmlU4gyr8DBrZGly;

1.87
date	2016.05.27.23.02.17;	author nicm;	state Exp;
branches;
next	1.86;
commitid	1m4zXWRrCSzyHLdS;

1.86
date	2016.04.29.13.21.33;	author nicm;	state Exp;
branches;
next	1.85;
commitid	KGWNr1jgb560pkTW;

1.85
date	2016.01.31.14.11.49;	author nicm;	state Exp;
branches;
next	1.84;
commitid	sInCcflJbsAoJHEs;

1.84
date	2016.01.19.15.59.12;	author nicm;	state Exp;
branches;
next	1.83;
commitid	P3qmSOx6KrDBsb0c;

1.83
date	2015.12.11.16.37.21;	author nicm;	state Exp;
branches;
next	1.82;
commitid	pfV7j8HdB7hdHnZm;

1.82
date	2015.11.23.23.47.57;	author nicm;	state Exp;
branches;
next	1.81;
commitid	il6j3tv774whObqw;

1.81
date	2015.11.23.20.53.09;	author nicm;	state Exp;
branches;
next	1.80;
commitid	erDJx2JIDZWB55Vj;

1.80
date	2015.11.18.14.27.44;	author nicm;	state Exp;
branches;
next	1.79;
commitid	RjsAPRkWwvS79w40;

1.79
date	2015.11.14.11.45.43;	author nicm;	state Exp;
branches;
next	1.78;
commitid	gUJFVlXRAaRAnDSU;

1.78
date	2015.11.14.10.56.31;	author nicm;	state Exp;
branches;
next	1.77;
commitid	7oTEXFUYU5F7v5X1;

1.77
date	2015.11.13.08.09.28;	author nicm;	state Exp;
branches;
next	1.76;
commitid	3vFd8TIqn7NVGuk0;

1.76
date	2015.11.12.22.04.37;	author nicm;	state Exp;
branches;
next	1.75;
commitid	fGCLUB4poNC6IhUT;

1.75
date	2015.11.12.11.09.11;	author nicm;	state Exp;
branches;
next	1.74;
commitid	tEN3cHiOuN3KscbT;

1.74
date	2015.09.14.13.22.02;	author nicm;	state Exp;
branches;
next	1.73;
commitid	kxByHmNsW2wTQbKK;

1.73
date	2015.07.13.13.28.50;	author nicm;	state Exp;
branches;
next	1.72;
commitid	2T0y9eUlEubBUnTa;

1.72
date	2014.11.08.12.58.31;	author nicm;	state Exp;
branches;
next	1.71;
commitid	4AXMKGfY67pUX35V;

1.71
date	2014.10.20.23.57.14;	author nicm;	state Exp;
branches;
next	1.70;
commitid	PTykIJGtZncJPE4a;

1.70
date	2014.10.02.08.36.26;	author nicm;	state Exp;
branches;
next	1.69;
commitid	GtxJuJKVNnFOgxeQ;

1.69
date	2014.04.17.14.45.49;	author nicm;	state Exp;
branches;
next	1.68;

1.68
date	2014.01.28.23.07.09;	author nicm;	state Exp;
branches;
next	1.67;

1.67
date	2013.05.15.15.32.14;	author nicm;	state Exp;
branches;
next	1.66;

1.66
date	2013.03.27.11.19.19;	author nicm;	state Exp;
branches;
next	1.65;

1.65
date	2013.03.22.10.41.01;	author nicm;	state Exp;
branches;
next	1.64;

1.64
date	2013.03.22.10.36.54;	author nicm;	state Exp;
branches;
next	1.63;

1.63
date	2013.03.22.10.33.50;	author nicm;	state Exp;
branches;
next	1.62;

1.62
date	2013.03.22.10.31.22;	author nicm;	state Exp;
branches;
next	1.61;

1.61
date	2013.03.21.18.47.56;	author nicm;	state Exp;
branches;
next	1.60;

1.60
date	2013.01.18.02.16.21;	author nicm;	state Exp;
branches;
next	1.59;

1.59
date	2013.01.15.23.18.55;	author nicm;	state Exp;
branches;
next	1.58;

1.58
date	2012.12.08.17.05.57;	author nicm;	state Exp;
branches;
next	1.57;

1.57
date	2012.09.24.12.53.55;	author nicm;	state Exp;
branches;
next	1.56;

1.56
date	2012.07.10.11.53.01;	author nicm;	state Exp;
branches;
next	1.55;

1.55
date	2012.03.17.17.36.03;	author nicm;	state Exp;
branches;
next	1.54;

1.54
date	2012.03.14.23.29.07;	author nicm;	state Exp;
branches;
next	1.53;

1.53
date	2012.03.03.09.43.22;	author nicm;	state Exp;
branches;
next	1.52;

1.52
date	2012.01.21.08.10.21;	author nicm;	state Exp;
branches;
next	1.51;

1.51
date	2011.10.23.10.16.14;	author nicm;	state Exp;
branches;
next	1.50;

1.50
date	2011.05.18.20.24.29;	author nicm;	state Exp;
branches;
next	1.49;

1.49
date	2011.04.17.19.21.19;	author nicm;	state Exp;
branches;
next	1.48;

1.48
date	2011.03.26.19.07.33;	author nicm;	state Exp;
branches;
next	1.47;

1.47
date	2011.03.07.23.46.27;	author nicm;	state Exp;
branches;
next	1.46;

1.46
date	2011.01.25.23.40.26;	author nicm;	state Exp;
branches;
next	1.45;

1.45
date	2011.01.03.23.35.21;	author nicm;	state Exp;
branches;
next	1.44;

1.44
date	2010.12.29.21.49.06;	author nicm;	state Exp;
branches;
next	1.43;

1.43
date	2010.06.21.00.11.12;	author nicm;	state Exp;
branches;
next	1.42;

1.42
date	2010.04.06.21.35.44;	author nicm;	state Exp;
branches;
next	1.41;

1.41
date	2009.12.03.22.50.10;	author nicm;	state Exp;
branches;
next	1.40;

1.40
date	2009.11.26.21.37.13;	author nicm;	state Exp;
branches;
next	1.39;

1.39
date	2009.11.18.17.02.17;	author nicm;	state Exp;
branches;
next	1.38;

1.38
date	2009.11.16.13.40.45;	author nicm;	state Exp;
branches;
next	1.37;

1.37
date	2009.11.11.18.53.21;	author nicm;	state Exp;
branches;
next	1.36;

1.36
date	2009.10.20.19.18.28;	author nicm;	state Exp;
branches;
next	1.35;

1.35
date	2009.10.20.17.33.33;	author nicm;	state Exp;
branches;
next	1.34;

1.34
date	2009.10.20.16.32.23;	author nicm;	state Exp;
branches;
next	1.33;

1.33
date	2009.10.17.08.35.38;	author nicm;	state Exp;
branches;
next	1.32;

1.32
date	2009.10.17.08.32.18;	author nicm;	state Exp;
branches;
next	1.31;

1.31
date	2009.10.17.08.24.46;	author nicm;	state Exp;
branches;
next	1.30;

1.30
date	2009.10.12.17.19.47;	author nicm;	state Exp;
branches;
next	1.29;

1.29
date	2009.10.12.16.59.55;	author nicm;	state Exp;
branches;
next	1.28;

1.28
date	2009.10.12.16.33.39;	author nicm;	state Exp;
branches;
next	1.27;

1.27
date	2009.10.12.11.08.02;	author nicm;	state Exp;
branches;
next	1.26;

1.26
date	2009.09.15.15.14.09;	author nicm;	state Exp;
branches;
next	1.25;

1.25
date	2009.09.10.17.16.24;	author nicm;	state Exp;
branches;
next	1.24;

1.24
date	2009.09.07.10.49.32;	author nicm;	state Exp;
branches;
next	1.23;

1.23
date	2009.08.21.08.12.05;	author nicm;	state Exp;
branches;
next	1.22;

1.22
date	2009.08.20.19.14.42;	author nicm;	state Exp;
branches;
next	1.21;

1.21
date	2009.08.13.16.24.33;	author nicm;	state Exp;
branches;
next	1.20;

1.20
date	2009.08.08.15.57.49;	author nicm;	state Exp;
branches;
next	1.19;

1.19
date	2009.07.30.20.41.48;	author nicm;	state Exp;
branches;
next	1.18;

1.18
date	2009.07.27.11.33.21;	author nicm;	state Exp;
branches;
next	1.17;

1.17
date	2009.07.22.20.53.38;	author nicm;	state Exp;
branches;
next	1.16;

1.16
date	2009.07.22.18.02.23;	author nicm;	state Exp;
branches;
next	1.15;

1.15
date	2009.07.22.16.45.31;	author nicm;	state Exp;
branches;
next	1.14;

1.14
date	2009.07.22.15.55.32;	author nicm;	state Exp;
branches;
next	1.13;

1.13
date	2009.07.14.14.47.32;	author nicm;	state Exp;
branches;
next	1.12;

1.12
date	2009.07.09.17.57.11;	author nicm;	state Exp;
branches;
next	1.11;

1.11
date	2009.07.09.07.58.14;	author nicm;	state Exp;
branches;
next	1.10;

1.10
date	2009.07.09.00.29.32;	author nicm;	state Exp;
branches;
next	1.9;

1.9
date	2009.06.29.21.30.50;	author nicm;	state Exp;
branches;
next	1.8;

1.8
date	2009.06.26.15.13.39;	author nicm;	state Exp;
branches;
next	1.7;

1.7
date	2009.06.05.03.13.16;	author ray;	state Exp;
branches;
next	1.6;

1.6
date	2009.06.03.23.37.30;	author nicm;	state Exp;
branches;
next	1.5;

1.5
date	2009.06.03.23.30.40;	author nicm;	state Exp;
branches;
next	1.4;

1.4
date	2009.06.03.23.26.56;	author nicm;	state Exp;
branches;
next	1.3;

1.3
date	2009.06.03.16.54.26;	author nicm;	state Exp;
branches;
next	1.2;

1.2
date	2009.06.03.16.05.46;	author nicm;	state Exp;
branches;
next	1.1;

1.1
date	2009.06.01.22.58.49;	author nicm;	state Exp;
branches;
next	;


desc
@@


1.121
log
@ECH needs to use background colour.
@
text
@/* $OpenBSD: screen-write.c,v 1.120 2017/05/11 11:39:30 nicm Exp $ */

/*
 * Copyright (c) 2007 Nicholas Marriott <nicholas.marriott@@gmail.com>
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF MIND, USE, DATA OR PROFITS, WHETHER
 * IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING
 * OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */

#include <sys/types.h>

#include <stdlib.h>
#include <string.h>

#include "tmux.h"

static void	screen_write_initctx(struct screen_write_ctx *,
		    struct tty_ctx *);
static void	screen_write_collect_clear(struct screen_write_ctx *, u_int,
		    u_int);
static void	screen_write_collect_scroll(struct screen_write_ctx *);
static void	screen_write_collect_flush(struct screen_write_ctx *, int);

static int	screen_write_overwrite(struct screen_write_ctx *,
		    struct grid_cell *, u_int);
static const struct grid_cell *screen_write_combine(struct screen_write_ctx *,
		    const struct utf8_data *, u_int *);

static const struct grid_cell screen_write_pad_cell = {
	GRID_FLAG_PADDING, 0, 8, 8, { { 0 }, 0, 0, 0 }
};

struct screen_write_collect_item {
	u_int			 x;
	int			 wrapped;

	u_int			 used;
	char			 data[256];

	struct grid_cell	 gc;

	TAILQ_ENTRY (screen_write_collect_item) entry;
};
struct screen_write_collect_line {
	TAILQ_HEAD(, screen_write_collect_item) items;
};

/* Initialize writing with a window. */
void
screen_write_start(struct screen_write_ctx *ctx, struct window_pane *wp,
    struct screen *s)
{
	char	tmp[16];
	u_int	y;

	memset(ctx, 0, sizeof *ctx);

	ctx->wp = wp;
	if (wp != NULL && s == NULL)
		ctx->s = wp->screen;
	else
		ctx->s = s;

	ctx->list = xcalloc(screen_size_y(ctx->s), sizeof *ctx->list);
	for (y = 0; y < screen_size_y(ctx->s); y++)
		TAILQ_INIT(&ctx->list[y].items);
	ctx->item = xcalloc(1, sizeof *ctx->item);

	if (wp != NULL)
		snprintf(tmp, sizeof tmp, "pane %%%u", wp->id);
	log_debug("%s: size %ux%u, %s", __func__, screen_size_x(ctx->s),
	    screen_size_y(ctx->s), wp == NULL ? "no pane" : tmp);
}

/* Finish writing. */
void
screen_write_stop(struct screen_write_ctx *ctx)
{
	screen_write_collect_end(ctx);
	screen_write_collect_flush(ctx, 0);

	log_debug("%s: %u cells (%u written, %u skipped)", __func__,
	    ctx->cells, ctx->written, ctx->skipped);

	free(ctx->item);
	free(ctx->list); /* flush will have emptied */
}

/* Reset screen state. */
void
screen_write_reset(struct screen_write_ctx *ctx)
{
	struct screen	*s = ctx->s;

	screen_reset_tabs(s);
	screen_write_scrollregion(ctx, 0, screen_size_y(s) - 1);

	s->mode &= ~(MODE_INSERT|MODE_KCURSOR|MODE_KKEYPAD|MODE_FOCUSON);
	s->mode &= ~(ALL_MOUSE_MODES|MODE_MOUSE_UTF8|MODE_MOUSE_SGR);

	screen_write_clearscreen(ctx, 8);
	screen_write_cursormove(ctx, 0, 0);
}

/* Write character. */
void
screen_write_putc(struct screen_write_ctx *ctx, const struct grid_cell *gcp,
    u_char ch)
{
	struct grid_cell	gc;

	memcpy(&gc, gcp, sizeof gc);

	utf8_set(&gc.data, ch);
	screen_write_cell(ctx, &gc);
}

/* Calculate string length, with embedded formatting. */
size_t
screen_write_cstrlen(const char *fmt, ...)
{
	va_list	ap;
	char   *msg, *msg2, *ptr, *ptr2;
	size_t	size;

	va_start(ap, fmt);
	xvasprintf(&msg, fmt, ap);
	va_end(ap);
	msg2 = xmalloc(strlen(msg) + 1);

	ptr = msg;
	ptr2 = msg2;
	while (*ptr != '\0') {
		if (ptr[0] == '#' && ptr[1] == '[') {
			while (*ptr != ']' && *ptr != '\0')
				ptr++;
			if (*ptr == ']')
				ptr++;
			continue;
		}
		*ptr2++ = *ptr++;
	}
	*ptr2 = '\0';

	size = screen_write_strlen("%s", msg2);

	free(msg);
	free(msg2);

	return (size);
}

/* Calculate string length. */
size_t
screen_write_strlen(const char *fmt, ...)
{
	va_list			ap;
	char   	       	       *msg;
	struct utf8_data	ud;
	u_char 	      	       *ptr;
	size_t			left, size = 0;
	enum utf8_state		more;

	va_start(ap, fmt);
	xvasprintf(&msg, fmt, ap);
	va_end(ap);

	ptr = msg;
	while (*ptr != '\0') {
		if (*ptr > 0x7f && utf8_open(&ud, *ptr) == UTF8_MORE) {
			ptr++;

			left = strlen(ptr);
			if (left < (size_t)ud.size - 1)
				break;
			while ((more = utf8_append(&ud, *ptr)) == UTF8_MORE)
				ptr++;
			ptr++;

			if (more == UTF8_DONE)
				size += ud.width;
		} else {
			if (*ptr > 0x1f && *ptr < 0x7f)
				size++;
			ptr++;
		}
	}

	free(msg);
	return (size);
}

/* Write simple string (no UTF-8 or maximum length). */
void
screen_write_puts(struct screen_write_ctx *ctx, const struct grid_cell *gcp,
    const char *fmt, ...)
{
	va_list	ap;

	va_start(ap, fmt);
	screen_write_vnputs(ctx, -1, gcp, fmt, ap);
	va_end(ap);
}

/* Write string with length limit (-1 for unlimited). */
void
screen_write_nputs(struct screen_write_ctx *ctx, ssize_t maxlen,
    const struct grid_cell *gcp, const char *fmt, ...)
{
	va_list	ap;

	va_start(ap, fmt);
	screen_write_vnputs(ctx, maxlen, gcp, fmt, ap);
	va_end(ap);
}

void
screen_write_vnputs(struct screen_write_ctx *ctx, ssize_t maxlen,
    const struct grid_cell *gcp, const char *fmt, va_list ap)
{
	struct grid_cell	gc;
	struct utf8_data       *ud = &gc.data;
	char   		       *msg;
	u_char 		       *ptr;
	size_t		 	left, size = 0;
	enum utf8_state		more;

	memcpy(&gc, gcp, sizeof gc);
	xvasprintf(&msg, fmt, ap);

	ptr = msg;
	while (*ptr != '\0') {
		if (*ptr > 0x7f && utf8_open(ud, *ptr) == UTF8_MORE) {
			ptr++;

			left = strlen(ptr);
			if (left < (size_t)ud->size - 1)
				break;
			while ((more = utf8_append(ud, *ptr)) == UTF8_MORE)
				ptr++;
			ptr++;

			if (more != UTF8_DONE)
				continue;
			if (maxlen > 0 && size + ud->width > (size_t)maxlen) {
				while (size < (size_t)maxlen) {
					screen_write_putc(ctx, &gc, ' ');
					size++;
				}
				break;
			}
			size += ud->width;
			screen_write_cell(ctx, &gc);
		} else {
			if (maxlen > 0 && size + 1 > (size_t)maxlen)
				break;

			if (*ptr == '\001')
				gc.attr ^= GRID_ATTR_CHARSET;
			else if (*ptr > 0x1f && *ptr < 0x7f) {
				size++;
				screen_write_putc(ctx, &gc, *ptr);
			}
			ptr++;
		}
	}

	free(msg);
}

/* Write string, similar to nputs, but with embedded formatting (#[]). */
void
screen_write_cnputs(struct screen_write_ctx *ctx, ssize_t maxlen,
    const struct grid_cell *gcp, const char *fmt, ...)
{
	struct grid_cell	 gc;
	struct utf8_data	*ud = &gc.data;
	va_list			 ap;
	char			*msg;
	u_char 			*ptr, *last;
	size_t			 left, size = 0;
	enum utf8_state		 more;

	memcpy(&gc, gcp, sizeof gc);

	va_start(ap, fmt);
	xvasprintf(&msg, fmt, ap);
	va_end(ap);

	ptr = msg;
	while (*ptr != '\0') {
		if (ptr[0] == '#' && ptr[1] == '[') {
			ptr += 2;
			last = ptr + strcspn(ptr, "]");
			if (*last == '\0') {
				/* No ]. Not much point in doing anything. */
				break;
			}
			*last = '\0';

			style_parse(gcp, &gc, ptr);
			ptr = last + 1;
			continue;
		}

		if (*ptr > 0x7f && utf8_open(ud, *ptr) == UTF8_MORE) {
			ptr++;

			left = strlen(ptr);
			if (left < (size_t)ud->size - 1)
				break;
			while ((more = utf8_append(ud, *ptr)) == UTF8_MORE)
				ptr++;
			ptr++;

			if (more != UTF8_DONE)
				continue;
			if (maxlen > 0 && size + ud->width > (size_t)maxlen) {
				while (size < (size_t)maxlen) {
					screen_write_putc(ctx, &gc, ' ');
					size++;
				}
				break;
			}
			size += ud->width;
			screen_write_cell(ctx, &gc);
		} else {
			if (maxlen > 0 && size + 1 > (size_t)maxlen)
				break;

			if (*ptr > 0x1f && *ptr < 0x7f) {
				size++;
				screen_write_putc(ctx, &gc, *ptr);
			}
			ptr++;
		}
	}

	free(msg);
}

/* Copy from another screen. */
void
screen_write_copy(struct screen_write_ctx *ctx, struct screen *src, u_int px,
    u_int py, u_int nx, u_int ny, bitstr_t *markbs,
    const struct grid_cell *markgc)
{
	struct screen		*s = ctx->s;
	struct grid		*gd = src->grid;
	struct grid_cell	 gc;
	u_int		 	 xx, yy, cx, cy, b;

	cx = s->cx;
	cy = s->cy;

	for (yy = py; yy < py + ny; yy++) {
		for (xx = px; xx < px + nx; xx++) {
			grid_get_cell(gd, xx, yy, &gc);
			if (markbs != NULL) {
				b = (yy * screen_size_x(src)) + xx;
				if (bit_test(markbs, b)) {
					gc.attr = markgc->attr;
					gc.fg = markgc->fg;
					gc.bg = markgc->bg;
				}
			}
			screen_write_cell(ctx, &gc);
		}

		cy++;
		screen_write_cursormove(ctx, cx, cy);
	}
}

/* Set up context for TTY command. */
static void
screen_write_initctx(struct screen_write_ctx *ctx, struct tty_ctx *ttyctx)
{
	struct screen	*s = ctx->s;

	ttyctx->wp = ctx->wp;

	ttyctx->ocx = s->cx;
	ttyctx->ocy = s->cy;

	ttyctx->orlower = s->rlower;
	ttyctx->orupper = s->rupper;
}

/* Set a mode. */
void
screen_write_mode_set(struct screen_write_ctx *ctx, int mode)
{
	struct screen	*s = ctx->s;

	s->mode |= mode;
}

/* Clear a mode. */
void
screen_write_mode_clear(struct screen_write_ctx *ctx, int mode)
{
	struct screen	*s = ctx->s;

	s->mode &= ~mode;
}

/* Cursor up by ny. */
void
screen_write_cursorup(struct screen_write_ctx *ctx, u_int ny)
{
	struct screen	*s = ctx->s;

	if (ny == 0)
		ny = 1;

	if (s->cy < s->rupper) {
		/* Above region. */
		if (ny > s->cy)
			ny = s->cy;
	} else {
		/* Below region. */
		if (ny > s->cy - s->rupper)
			ny = s->cy - s->rupper;
	}
	if (s->cx == screen_size_x(s))
	    s->cx--;
	if (ny == 0)
		return;

	s->cy -= ny;
}

/* Cursor down by ny. */
void
screen_write_cursordown(struct screen_write_ctx *ctx, u_int ny)
{
	struct screen	*s = ctx->s;

	if (ny == 0)
		ny = 1;

	if (s->cy > s->rlower) {
		/* Below region. */
		if (ny > screen_size_y(s) - 1 - s->cy)
			ny = screen_size_y(s) - 1 - s->cy;
	} else {
		/* Above region. */
		if (ny > s->rlower - s->cy)
			ny = s->rlower - s->cy;
	}
	if (s->cx == screen_size_x(s))
	    s->cx--;
	if (ny == 0)
		return;

	s->cy += ny;
}

/* Cursor right by nx. */
void
screen_write_cursorright(struct screen_write_ctx *ctx, u_int nx)
{
	struct screen	*s = ctx->s;

	if (nx == 0)
		nx = 1;

	if (nx > screen_size_x(s) - 1 - s->cx)
		nx = screen_size_x(s) - 1 - s->cx;
	if (nx == 0)
		return;

	s->cx += nx;
}

/* Cursor left by nx. */
void
screen_write_cursorleft(struct screen_write_ctx *ctx, u_int nx)
{
	struct screen	*s = ctx->s;

	if (nx == 0)
		nx = 1;

	if (nx > s->cx)
		nx = s->cx;
	if (nx == 0)
		return;

	s->cx -= nx;
}

/* Backspace; cursor left unless at start of wrapped line when can move up. */
void
screen_write_backspace(struct screen_write_ctx *ctx)
{
	struct screen		*s = ctx->s;
	struct grid_line	*gl;

	if (s->cx == 0) {
		if (s->cy == 0)
			return;
		gl = &s->grid->linedata[s->grid->hsize + s->cy - 1];
		if (gl->flags & GRID_LINE_WRAPPED) {
			s->cy--;
			s->cx = screen_size_x(s) - 1;
		}
	} else
		s->cx--;
}

/* VT100 alignment test. */
void
screen_write_alignmenttest(struct screen_write_ctx *ctx)
{
	struct screen		*s = ctx->s;
	struct tty_ctx	 	 ttyctx;
	struct grid_cell       	 gc;
	u_int			 xx, yy;

	screen_write_initctx(ctx, &ttyctx);

	memcpy(&gc, &grid_default_cell, sizeof gc);
	utf8_set(&gc.data, 'E');

	for (yy = 0; yy < screen_size_y(s); yy++) {
		for (xx = 0; xx < screen_size_x(s); xx++)
			grid_view_set_cell(s->grid, xx, yy, &gc);
	}

	s->cx = 0;
	s->cy = 0;

	s->rupper = 0;
	s->rlower = screen_size_y(s) - 1;

	screen_write_collect_clear(ctx, 0, screen_size_y(s) - 1);
	tty_write(tty_cmd_alignmenttest, &ttyctx);
}

/* Insert nx characters. */
void
screen_write_insertcharacter(struct screen_write_ctx *ctx, u_int nx, u_int bg)
{
	struct screen	*s = ctx->s;
	struct tty_ctx	 ttyctx;

	if (nx == 0)
		nx = 1;

	if (nx > screen_size_x(s) - s->cx)
		nx = screen_size_x(s) - s->cx;
	if (nx == 0)
		return;

	if (s->cx > screen_size_x(s) - 1)
		return;

	screen_write_initctx(ctx, &ttyctx);
	ttyctx.bg = bg;

	grid_view_insert_cells(s->grid, s->cx, s->cy, nx, bg);

	screen_write_collect_flush(ctx, 0);
	ttyctx.num = nx;
	tty_write(tty_cmd_insertcharacter, &ttyctx);
}

/* Delete nx characters. */
void
screen_write_deletecharacter(struct screen_write_ctx *ctx, u_int nx, u_int bg)
{
	struct screen	*s = ctx->s;
	struct tty_ctx	 ttyctx;

	if (nx == 0)
		nx = 1;

	if (nx > screen_size_x(s) - s->cx)
		nx = screen_size_x(s) - s->cx;
	if (nx == 0)
		return;

	if (s->cx > screen_size_x(s) - 1)
		return;

	screen_write_initctx(ctx, &ttyctx);
	ttyctx.bg = bg;

	grid_view_delete_cells(s->grid, s->cx, s->cy, nx, bg);

	screen_write_collect_flush(ctx, 0);
	ttyctx.num = nx;
	tty_write(tty_cmd_deletecharacter, &ttyctx);
}

/* Clear nx characters. */
void
screen_write_clearcharacter(struct screen_write_ctx *ctx, u_int nx, u_int bg)
{
	struct screen	*s = ctx->s;
	struct tty_ctx	 ttyctx;

	if (nx == 0)
		nx = 1;

	if (nx > screen_size_x(s) - s->cx)
		nx = screen_size_x(s) - s->cx;
	if (nx == 0)
		return;

	if (s->cx > screen_size_x(s) - 1)
		return;

	screen_write_initctx(ctx, &ttyctx);
	ttyctx.bg = bg;

	grid_view_clear(s->grid, s->cx, s->cy, nx, 1, 8);

	screen_write_collect_flush(ctx, 0);
	ttyctx.num = nx;
	tty_write(tty_cmd_clearcharacter, &ttyctx);
}

/* Insert ny lines. */
void
screen_write_insertline(struct screen_write_ctx *ctx, u_int ny, u_int bg)
{
	struct screen	*s = ctx->s;
	struct grid	*gd = s->grid;
	struct tty_ctx	 ttyctx;

	if (ny == 0)
		ny = 1;

	if (s->cy < s->rupper || s->cy > s->rlower) {
		if (ny > screen_size_y(s) - s->cy)
			ny = screen_size_y(s) - s->cy;
		if (ny == 0)
			return;

		screen_write_initctx(ctx, &ttyctx);
		ttyctx.bg = bg;

		grid_view_insert_lines(gd, s->cy, ny, bg);

		screen_write_collect_flush(ctx, 0);
		ttyctx.num = ny;
		tty_write(tty_cmd_insertline, &ttyctx);
		return;
	}

	if (ny > s->rlower + 1 - s->cy)
		ny = s->rlower + 1 - s->cy;
	if (ny == 0)
		return;

	screen_write_initctx(ctx, &ttyctx);
	ttyctx.bg = bg;

	if (s->cy < s->rupper || s->cy > s->rlower)
		grid_view_insert_lines(gd, s->cy, ny, bg);
	else
		grid_view_insert_lines_region(gd, s->rlower, s->cy, ny, bg);

	screen_write_collect_flush(ctx, 0);
	ttyctx.num = ny;
	tty_write(tty_cmd_insertline, &ttyctx);
}

/* Delete ny lines. */
void
screen_write_deleteline(struct screen_write_ctx *ctx, u_int ny, u_int bg)
{
	struct screen	*s = ctx->s;
	struct grid	*gd = s->grid;
	struct tty_ctx	 ttyctx;

	if (ny == 0)
		ny = 1;

	if (s->cy < s->rupper || s->cy > s->rlower) {
		if (ny > screen_size_y(s) - s->cy)
			ny = screen_size_y(s) - s->cy;
		if (ny == 0)
			return;

		screen_write_initctx(ctx, &ttyctx);
		ttyctx.bg = bg;

		grid_view_delete_lines(gd, s->cy, ny, bg);

		screen_write_collect_flush(ctx, 0);
		ttyctx.num = ny;
		tty_write(tty_cmd_deleteline, &ttyctx);
		return;
	}

	if (ny > s->rlower + 1 - s->cy)
		ny = s->rlower + 1 - s->cy;
	if (ny == 0)
		return;

	screen_write_initctx(ctx, &ttyctx);
	ttyctx.bg = bg;

	if (s->cy < s->rupper || s->cy > s->rlower)
		grid_view_delete_lines(gd, s->cy, ny, bg);
	else
		grid_view_delete_lines_region(gd, s->rlower, s->cy, ny, bg);

	screen_write_collect_flush(ctx, 0);
	ttyctx.num = ny;
	tty_write(tty_cmd_deleteline, &ttyctx);
}

/* Clear line at cursor. */
void
screen_write_clearline(struct screen_write_ctx *ctx, u_int bg)
{
	struct screen		*s = ctx->s;
	struct grid_line	*gl;
	struct tty_ctx		 ttyctx;
	u_int			 sx = screen_size_x(s);

	gl = &s->grid->linedata[s->grid->hsize + s->cy];
	if (gl->cellsize == 0 && bg == 8)
		return;

	screen_write_initctx(ctx, &ttyctx);
	ttyctx.bg = bg;

	grid_view_clear(s->grid, 0, s->cy, sx, 1, bg);

	screen_write_collect_clear(ctx, s->cy, 1);
	screen_write_collect_flush(ctx, 0);
	tty_write(tty_cmd_clearline, &ttyctx);
}

/* Clear to end of line from cursor. */
void
screen_write_clearendofline(struct screen_write_ctx *ctx, u_int bg)
{
	struct screen		*s = ctx->s;
	struct grid_line	*gl;
	struct tty_ctx		 ttyctx;
	u_int			 sx = screen_size_x(s);

	gl = &s->grid->linedata[s->grid->hsize + s->cy];
	if (s->cx > sx - 1 || (s->cx >= gl->cellsize && bg == 8))
		return;

	screen_write_initctx(ctx, &ttyctx);
	ttyctx.bg = bg;

	grid_view_clear(s->grid, s->cx, s->cy, sx - s->cx, 1, bg);

	if (s->cx == 0)
		screen_write_collect_clear(ctx, s->cy, 1);
	screen_write_collect_flush(ctx, 0);
	tty_write(tty_cmd_clearendofline, &ttyctx);
}

/* Clear to start of line from cursor. */
void
screen_write_clearstartofline(struct screen_write_ctx *ctx, u_int bg)
{
	struct screen	*s = ctx->s;
	struct tty_ctx	 ttyctx;
	u_int		 sx = screen_size_x(s);

	screen_write_initctx(ctx, &ttyctx);
	ttyctx.bg = bg;

	if (s->cx > sx - 1)
		grid_view_clear(s->grid, 0, s->cy, sx, 1, bg);
	else
		grid_view_clear(s->grid, 0, s->cy, s->cx + 1, 1, bg);

	if (s->cx > sx - 1)
		screen_write_collect_clear(ctx, s->cy, 1);
	screen_write_collect_flush(ctx, 0);
	tty_write(tty_cmd_clearstartofline, &ttyctx);
}

/* Move cursor to px,py. */
void
screen_write_cursormove(struct screen_write_ctx *ctx, u_int px, u_int py)
{
	struct screen	*s = ctx->s;

	if (px > screen_size_x(s) - 1)
		px = screen_size_x(s) - 1;
	if (py > screen_size_y(s) - 1)
		py = screen_size_y(s) - 1;

	s->cx = px;
	s->cy = py;
}

/* Reverse index (up with scroll). */
void
screen_write_reverseindex(struct screen_write_ctx *ctx)
{
	struct screen	*s = ctx->s;
	struct tty_ctx	 ttyctx;

	screen_write_initctx(ctx, &ttyctx);

	if (s->cy == s->rupper)
		grid_view_scroll_region_down(s->grid, s->rupper, s->rlower);
	else if (s->cy > 0)
		s->cy--;

	screen_write_collect_flush(ctx, 0);
	tty_write(tty_cmd_reverseindex, &ttyctx);
}

/* Set scroll region. */
void
screen_write_scrollregion(struct screen_write_ctx *ctx, u_int rupper,
    u_int rlower)
{
	struct screen	*s = ctx->s;

	if (rupper > screen_size_y(s) - 1)
		rupper = screen_size_y(s) - 1;
	if (rlower > screen_size_y(s) - 1)
		rlower = screen_size_y(s) - 1;
	if (rupper >= rlower)	/* cannot be one line */
		return;

	screen_write_collect_flush(ctx, 0);

	/* Cursor moves to top-left. */
	s->cx = 0;
	s->cy = 0;

	s->rupper = rupper;
	s->rlower = rlower;
}

/* Line feed. */
void
screen_write_linefeed(struct screen_write_ctx *ctx, int wrapped)
{
	struct screen		*s = ctx->s;
	struct grid		*gd = s->grid;
	struct grid_line	*gl;

	gl = &gd->linedata[gd->hsize + s->cy];
	if (wrapped)
		gl->flags |= GRID_LINE_WRAPPED;
	else
		gl->flags &= ~GRID_LINE_WRAPPED;

	log_debug("%s: at %u,%u (region %u-%u)", __func__, s->cx, s->cy,
	    s->rupper, s->rlower);

	if (s->cy == s->rlower) {
		grid_view_scroll_region_up(gd, s->rupper, s->rlower);
		screen_write_collect_scroll(ctx);
		ctx->scrolled++;
	} else if (s->cy < screen_size_y(s) - 1)
		s->cy++;
}

/* Scroll up. */
void
screen_write_scrollup(struct screen_write_ctx *ctx, u_int lines)
{
	struct screen	*s = ctx->s;
	struct grid	*gd = s->grid;
	u_int		 i;

	if (lines == 0)
		lines = 1;
	else if (lines > s->rlower - s->rupper + 1)
		lines = s->rlower - s->rupper + 1;

	for (i = 0; i < lines; i++) {
		grid_view_scroll_region_up(gd, s->rupper, s->rlower);
		screen_write_collect_scroll(ctx);
	}
	ctx->scrolled += lines;
}

/* Carriage return (cursor to start of line). */
void
screen_write_carriagereturn(struct screen_write_ctx *ctx)
{
	struct screen	*s = ctx->s;

	s->cx = 0;
}

/* Clear to end of screen from cursor. */
void
screen_write_clearendofscreen(struct screen_write_ctx *ctx, u_int bg)
{
	struct screen	*s = ctx->s;
	struct grid	*gd = s->grid;
	struct tty_ctx	 ttyctx;
	u_int		 sx = screen_size_x(s), sy = screen_size_y(s);

	screen_write_initctx(ctx, &ttyctx);
	ttyctx.bg = bg;

	/* Scroll into history if it is enabled and clearing entire screen. */
	if (s->cx == 0 && s->cy == 0 && (gd->flags & GRID_HISTORY))
		grid_view_clear_history(gd, bg);
	else {
		if (s->cx <= sx - 1)
			grid_view_clear(gd, s->cx, s->cy, sx - s->cx, 1, bg);
		grid_view_clear(gd, 0, s->cy + 1, sx, sy - (s->cy + 1), bg);
	}

	screen_write_collect_clear(ctx, s->cy + 1, sy - (s->cy + 1));
	screen_write_collect_flush(ctx, 0);
	tty_write(tty_cmd_clearendofscreen, &ttyctx);
}

/* Clear to start of screen. */
void
screen_write_clearstartofscreen(struct screen_write_ctx *ctx, u_int bg)
{
	struct screen	*s = ctx->s;
	struct tty_ctx	 ttyctx;
	u_int		 sx = screen_size_x(s);

	screen_write_initctx(ctx, &ttyctx);
	ttyctx.bg = bg;

	if (s->cy > 0)
		grid_view_clear(s->grid, 0, 0, sx, s->cy, bg);
	if (s->cx > sx - 1)
		grid_view_clear(s->grid, 0, s->cy, sx, 1, bg);
	else
		grid_view_clear(s->grid, 0, s->cy, s->cx + 1, 1, bg);

	screen_write_collect_clear(ctx, 0, s->cy);
	screen_write_collect_flush(ctx, 0);
	tty_write(tty_cmd_clearstartofscreen, &ttyctx);
}

/* Clear entire screen. */
void
screen_write_clearscreen(struct screen_write_ctx *ctx, u_int bg)
{
	struct screen	*s = ctx->s;
	struct tty_ctx	 ttyctx;
	u_int		 sx = screen_size_x(s), sy = screen_size_y(s);

	screen_write_initctx(ctx, &ttyctx);
	ttyctx.bg = bg;

	/* Scroll into history if it is enabled. */
	if (s->grid->flags & GRID_HISTORY)
		grid_view_clear_history(s->grid, bg);
	else
		grid_view_clear(s->grid, 0, 0, sx, sy, bg);

	screen_write_collect_clear(ctx, 0, sy);
	tty_write(tty_cmd_clearscreen, &ttyctx);
}

/* Clear entire history. */
void
screen_write_clearhistory(struct screen_write_ctx *ctx)
{
	struct screen	*s = ctx->s;
	struct grid	*gd = s->grid;

	grid_move_lines(gd, 0, gd->hsize, gd->sy, 8);
	gd->hscrolled = gd->hsize = 0;
}

/* Clear a collected line. */
static void
screen_write_collect_clear(struct screen_write_ctx *ctx, u_int y, u_int n)
{
	struct screen_write_collect_item	*ci, *tmp;
	u_int					 i;
	size_t					 size;

	for (i = y ; i < y + n; i++) {
		if (TAILQ_EMPTY(&ctx->list[i].items))
			continue;
		size = 0;
		TAILQ_FOREACH_SAFE(ci, &ctx->list[i].items, entry, tmp) {
			size += ci->used;
			TAILQ_REMOVE(&ctx->list[i].items, ci, entry);
			free(ci);
		}
		ctx->skipped += size;
		log_debug("%s: dropped %zu bytes (line %u)", __func__, size, i);
	}
}

/* Scroll collected lines up. */
static void
screen_write_collect_scroll(struct screen_write_ctx *ctx)
{
	struct screen				*s = ctx->s;
	struct screen_write_collect_line	*cl;
	u_int					 y;

	log_debug("%s: at %u,%u (region %u-%u)", __func__, s->cx, s->cy,
	    s->rupper, s->rlower);

	screen_write_collect_clear(ctx, s->rupper, 1);
	for (y = s->rupper; y < s->rlower; y++) {
		cl = &ctx->list[y + 1];
		TAILQ_CONCAT(&ctx->list[y].items, &cl->items, entry);
		TAILQ_INIT(&cl->items);
	}
}

/* Flush collected lines. */
static void
screen_write_collect_flush(struct screen_write_ctx *ctx, int scroll_only)
{
	struct screen				*s = ctx->s;
	struct screen_write_collect_item	*ci, *tmp;
	u_int					 y, cx, cy, items = 0;
	struct tty_ctx				 ttyctx;
	size_t					 written = 0;

	if (ctx->scrolled != 0) {
		log_debug("%s: scrolled %u (region %u-%u)", __func__,
		    ctx->scrolled, s->rupper, s->rlower);
		if (ctx->scrolled > s->rlower - s->rupper + 1)
			ctx->scrolled = s->rlower - s->rupper + 1;

		screen_write_initctx(ctx, &ttyctx);
		ttyctx.num = ctx->scrolled;
		tty_write(tty_cmd_scrollup, &ttyctx);
	}
	ctx->scrolled = 0;
	if (scroll_only)
		return;

	cx = s->cx; cy = s->cy;
	for (y = 0; y < screen_size_y(s); y++) {
		TAILQ_FOREACH_SAFE(ci, &ctx->list[y].items, entry, tmp) {
			screen_write_cursormove(ctx, ci->x, y);
			screen_write_initctx(ctx, &ttyctx);
			ttyctx.cell = &ci->gc;
			ttyctx.wrapped = ci->wrapped;
			ttyctx.ptr = ci->data;
			ttyctx.num = ci->used;
			tty_write(tty_cmd_cells, &ttyctx);

			items++;
			written += ci->used;

			TAILQ_REMOVE(&ctx->list[y].items, ci, entry);
			free(ci);
		}
	}
	s->cx = cx; s->cy = cy;

	log_debug("%s: flushed %u items (%zu bytes)", __func__, items, written);
	ctx->written += written;
}

/* Finish and store collected cells. */
void
screen_write_collect_end(struct screen_write_ctx *ctx)
{
	struct screen				*s = ctx->s;
	struct screen_write_collect_item	*ci = ctx->item;
	struct grid_cell			 gc;

	if (ci->used == 0)
		return;
	ci->data[ci->used] = '\0';

	ci->x = s->cx;
	TAILQ_INSERT_TAIL(&ctx->list[s->cy].items, ci, entry);
	ctx->item = xcalloc(1, sizeof *ctx->item);

	log_debug("%s: %u %s (at %u,%u)", __func__, ci->used, ci->data, s->cx,
	    s->cy);

	memcpy(&gc, &ci->gc, sizeof gc);
	grid_view_set_cells(s->grid, s->cx, s->cy, &gc, ci->data, ci->used);
	s->cx += ci->used;
}

/* Write cell data, collecting if necessary. */
void
screen_write_collect_add(struct screen_write_ctx *ctx,
    const struct grid_cell *gc)
{
	struct screen				*s = ctx->s;
	struct screen_write_collect_item	*ci;
	u_int					 sx = screen_size_x(s);
	int					 collect;

	/*
	 * Don't need to check that the attributes and whatnot are still the
	 * same - input_parse will end the collection when anything that isn't
	 * a plain character is encountered. Also nothing should make it here
	 * that isn't a single ASCII character.
	 */

	collect = 1;
	if (gc->data.width != 1 || gc->data.size != 1)
		collect = 0;
	else if (gc->attr & GRID_ATTR_CHARSET)
		collect = 0;
	else if (~s->mode & MODE_WRAP)
		collect = 0;
	else if (s->mode & MODE_INSERT)
		collect = 0;
	else if (s->sel.flag)
		collect = 0;
	if (!collect) {
		screen_write_collect_end(ctx);
		screen_write_collect_flush(ctx, 0);
		screen_write_cell(ctx, gc);
		return;
	}
	ctx->cells++;

	if (s->cx > sx - 1 || ctx->item->used > sx - 1 - s->cx)
		screen_write_collect_end(ctx);
	ci = ctx->item; /* may have changed */

	if (s->cx > sx - 1) {
		log_debug("%s: wrapped at %u,%u", __func__, s->cx, s->cy);
		ci->wrapped = 1;
		screen_write_linefeed(ctx, 1);
		s->cx = 0;
	}

	if (ci->used == 0)
		memcpy(&ci->gc, gc, sizeof ci->gc);
	ci->data[ci->used++] = gc->data.data[0];
	if (ci->used == (sizeof ci->data) - 1)
		screen_write_collect_end(ctx);
}

/* Write cell data. */
void
screen_write_cell(struct screen_write_ctx *ctx, const struct grid_cell *gc)
{
	struct screen		*s = ctx->s;
	struct grid		*gd = s->grid;
	struct grid_line	*gl;
	struct grid_cell_entry	*gce;
	struct grid_cell 	 tmp_gc, now_gc;
	struct tty_ctx		 ttyctx;
	u_int			 sx = screen_size_x(s), sy = screen_size_y(s);
	u_int		 	 width = gc->data.width, xx, last, cx, cy;
	int			 selected, skip = 1;

	/* Ignore padding cells. */
	if (gc->flags & GRID_FLAG_PADDING)
		return;
	ctx->cells++;

	/* If the width is zero, combine onto the previous character. */
	if (width == 0) {
		screen_write_collect_flush(ctx, 0);
		if ((gc = screen_write_combine(ctx, &gc->data, &xx)) != 0) {
			cx = s->cx; cy = s->cy;
			screen_write_cursormove(ctx, xx, s->cy);
			screen_write_initctx(ctx, &ttyctx);
			ttyctx.cell = gc;
			tty_write(tty_cmd_cell, &ttyctx);
			s->cx = cx; s->cy = cy;
		}
		return;
	}

	/* Flush any existing scrolling. */
	screen_write_collect_flush(ctx, 1);

	/* If this character doesn't fit, ignore it. */
	if ((~s->mode & MODE_WRAP) &&
	    width > 1 &&
	    (width > sx || (s->cx != sx && s->cx > sx - width)))
		return;

	/* If in insert mode, make space for the cells. */
	if (s->mode & MODE_INSERT) {
		grid_view_insert_cells(s->grid, s->cx, s->cy, width, 8);
		skip = 0;
	}

	/* Check this will fit on the current line and wrap if not. */
	if ((s->mode & MODE_WRAP) && s->cx > sx - width) {
		screen_write_linefeed(ctx, 1);
		s->cx = 0;
	}

	/* Sanity check cursor position. */
	if (s->cx > sx - width || s->cy > sy - 1)
		return;
	screen_write_initctx(ctx, &ttyctx);

	/* Handle overwriting of UTF-8 characters. */
	gl = &s->grid->linedata[s->grid->hsize + s->cy];
	if (gl->flags & GRID_LINE_EXTENDED) {
		grid_view_get_cell(gd, s->cx, s->cy, &now_gc);
		if (screen_write_overwrite(ctx, &now_gc, width))
			skip = 0;
	}

	/*
	 * If the new character is UTF-8 wide, fill in padding cells. Have
	 * already ensured there is enough room.
	 */
	for (xx = s->cx + 1; xx < s->cx + width; xx++) {
		grid_view_set_cell(gd, xx, s->cy, &screen_write_pad_cell);
		skip = 0;
	}

	/* If no change, do not draw. */
	if (skip) {
		if (s->cx >= gl->cellsize)
			skip = grid_cells_equal(gc, &grid_default_cell);
		else {
			gce = &gl->celldata[s->cx];
			if (gce->flags & GRID_FLAG_EXTENDED)
				skip = 0;
			else if (gc->flags != gce->flags)
				skip = 0;
			else if (gc->attr != gce->data.attr)
				skip = 0;
			else if (gc->fg != gce->data.fg)
				skip = 0;
			else if (gc->bg != gce->data.bg)
				skip = 0;
			else if (gc->data.width != 1)
				skip = 0;
			else if (gc->data.size != 1)
				skip = 0;
			else if (gce->data.data != gc->data.data[0])
				skip = 0;
		}
	}

	/* Update the selection the flag and set the cell. */
	selected = screen_check_selection(s, s->cx, s->cy);
	if (selected && (~gc->flags & GRID_FLAG_SELECTED)) {
		memcpy(&tmp_gc, gc, sizeof tmp_gc);
		tmp_gc.flags |= GRID_FLAG_SELECTED;
		grid_view_set_cell(gd, s->cx, s->cy, &tmp_gc);
	} else if (!selected && (gc->flags & GRID_FLAG_SELECTED)) {
		memcpy(&tmp_gc, gc, sizeof tmp_gc);
		tmp_gc.flags &= ~GRID_FLAG_SELECTED;
		grid_view_set_cell(gd, s->cx, s->cy, &tmp_gc);
	} else if (!skip)
		grid_view_set_cell(gd, s->cx, s->cy, gc);
	if (selected)
		skip = 0;

	/*
	 * Move the cursor. If not wrapping, stick at the last character and
	 * replace it.
	 */
	last = !(s->mode & MODE_WRAP);
	if (s->cx <= sx - last - width)
		s->cx += width;
	else
		s->cx = sx - last;

	/* Create space for character in insert mode. */
	if (s->mode & MODE_INSERT) {
		screen_write_collect_flush(ctx, 0);
		ttyctx.num = width;
		tty_write(tty_cmd_insertcharacter, &ttyctx);
	}

	/* Write to the screen. */
	if (!skip) {
		if (selected) {
			screen_select_cell(s, &tmp_gc, gc);
			ttyctx.cell = &tmp_gc;
		} else
			ttyctx.cell = gc;
		tty_write(tty_cmd_cell, &ttyctx);
		ctx->written++;
	} else
		ctx->skipped++;
}

/* Combine a UTF-8 zero-width character onto the previous. */
static const struct grid_cell *
screen_write_combine(struct screen_write_ctx *ctx, const struct utf8_data *ud,
    u_int *xx)
{
	struct screen		*s = ctx->s;
	struct grid		*gd = s->grid;
	static struct grid_cell	 gc;
	u_int			 n;

	/* Can't combine if at 0. */
	if (s->cx == 0)
		return (NULL);

	/* Empty data is out. */
	if (ud->size == 0)
		fatalx("UTF-8 data empty");

	/* Retrieve the previous cell. */
	for (n = 1; n <= s->cx; n++) {
		grid_view_get_cell(gd, s->cx - n, s->cy, &gc);
		if (~gc.flags & GRID_FLAG_PADDING)
			break;
	}
	if (n > s->cx)
		return (NULL);
	*xx = s->cx - n;

	/* Check there is enough space. */
	if (gc.data.size + ud->size > sizeof gc.data.data)
		return (NULL);

	log_debug("%s: %.*s onto %.*s at %u,%u", __func__, (int)ud->size,
	    ud->data, (int)gc.data.size, gc.data.data, *xx, s->cy);

	/* Append the data. */
	memcpy(gc.data.data + gc.data.size, ud->data, ud->size);
	gc.data.size += ud->size;

	/* Set the new cell. */
	grid_view_set_cell(gd, *xx, s->cy, &gc);

	return (&gc);
}

/*
 * UTF-8 wide characters are a bit of an annoyance. They take up more than one
 * cell on the screen, so following cells must not be drawn by marking them as
 * padding.
 *
 * So far, so good. The problem is, when overwriting a padding cell, or a UTF-8
 * character, it is necessary to also overwrite any other cells which covered
 * by the same character.
 */
static int
screen_write_overwrite(struct screen_write_ctx *ctx, struct grid_cell *gc,
    u_int width)
{
	struct screen		*s = ctx->s;
	struct grid		*gd = s->grid;
	struct grid_cell	 tmp_gc;
	u_int			 xx;
	int			 done = 0;

	if (gc->flags & GRID_FLAG_PADDING) {
		/*
		 * A padding cell, so clear any following and leading padding
		 * cells back to the character. Don't overwrite the current
		 * cell as that happens later anyway.
		 */
		xx = s->cx + 1;
		while (--xx > 0) {
			grid_view_get_cell(gd, xx, s->cy, &tmp_gc);
			if (~tmp_gc.flags & GRID_FLAG_PADDING)
				break;
			grid_view_set_cell(gd, xx, s->cy, &grid_default_cell);
		}

		/* Overwrite the character at the start of this padding. */
		grid_view_set_cell(gd, xx, s->cy, &grid_default_cell);
		done = 1;
	}

	/*
	 * Overwrite any padding cells that belong to any UTF-8 characters
	 * we'll be overwriting with the current character.
	 */
	if (width != 1 ||
	    gc->data.width != 1 ||
	    gc->flags & GRID_FLAG_PADDING) {
		xx = s->cx + width - 1;
		while (++xx < screen_size_x(s)) {
			grid_view_get_cell(gd, xx, s->cy, &tmp_gc);
			if (~tmp_gc.flags & GRID_FLAG_PADDING)
				break;
			grid_view_set_cell(gd, xx, s->cy, &grid_default_cell);
			done = 1;
		}
	}

	return (done);
}

/* Set external clipboard. */
void
screen_write_setselection(struct screen_write_ctx *ctx, u_char *str, u_int len)
{
	struct tty_ctx	ttyctx;

	screen_write_initctx(ctx, &ttyctx);
	ttyctx.ptr = str;
	ttyctx.num = len;

	tty_write(tty_cmd_setselection, &ttyctx);
}

/* Write unmodified string. */
void
screen_write_rawstring(struct screen_write_ctx *ctx, u_char *str, u_int len)
{
	struct tty_ctx	ttyctx;

	screen_write_initctx(ctx, &ttyctx);
	ttyctx.ptr = str;
	ttyctx.num = len;

	tty_write(tty_cmd_rawstring, &ttyctx);
}
@


1.120
log
@Clear to start of screen needs to use background colour.
@
text
@d1 1
a1 1
/* $OpenBSD: screen-write.c,v 1.119 2017/04/29 21:27:46 nicm Exp $ */
d609 1
a609 1
screen_write_clearcharacter(struct screen_write_ctx *ctx, u_int nx)
d626 1
@


1.119
log
@Fix UTF-8 combining characters in column 0, based on a diff from Keith
Winstein.
@
text
@d1 1
a1 1
/* $OpenBSD: screen-write.c,v 1.118 2017/04/25 18:30:29 nicm Exp $ */
d946 1
a946 1
		grid_view_clear(s->grid, 0, s->cy, sx, 1, 8);
d948 1
a948 1
		grid_view_clear(s->grid, 0, s->cy, s->cx + 1, 1, 8);
@


1.118
log
@Make full width panes try to play more nicely with terminal copy and
paste by avoiding explicit line wraps if we think the terminal will wrap
anyway.
@
text
@d1 1
a1 1
/* $OpenBSD: screen-write.c,v 1.117 2017/04/22 10:30:56 nicm Exp $ */
d1319 1
a1319 1
	for (n = 1; n < s->cx; n++) {
d1324 1
a1324 1
	if (n == s->cx)
@


1.117
log
@Can't collect UTF-8 characters of more than one byte at the moment.
@
text
@d1 1
a1 1
/* $OpenBSD: screen-write.c,v 1.116 2017/03/07 13:48:28 nicm Exp $ */
d44 1
d1058 1
d1138 2
d1142 1
a1146 1
	ci = ctx->item; /* may have changed */
@


1.116
log
@Need to flush before writing out cells we are not collecting, also add
some extra logging.
@
text
@d1 1
a1 1
/* $OpenBSD: screen-write.c,v 1.115 2017/03/06 09:02:36 nicm Exp $ */
d1116 1
a1116 1
	if (gc->data.width != 1)
@


1.115
log
@When redrawing a combined UTF-8 characters in its existing position,
need to save and restore the cursor so that the next character goes into
the right place.
@
text
@d1 1
a1 1
/* $OpenBSD: screen-write.c,v 1.114 2017/02/21 10:30:15 nicm Exp $ */
d1033 1
a1033 1
	u_int					 y, cx, cy;
d1035 1
d1060 3
a1062 1
			ctx->written += ci->used;
d1069 3
d1110 3
a1112 3
	 * same - input_parse will do a flush when anything that isn't a plain
	 * character is encountered. Also nothing should make it here that
	 * isn't a single ASCII character.
d1128 1
@


1.114
log
@Scrolling at least needs to be flushed before sending EL to the terminal
(but it is simpler to flush everything, so do that instead).
@
text
@d1 1
a1 1
/* $OpenBSD: screen-write.c,v 1.113 2017/02/16 12:43:08 nicm Exp $ */
d1154 1
a1154 1
	u_int		 	 width = gc->data.width, xx, last;
d1166 1
d1171 1
@


1.113
log
@Handle insert cells when cursor at edge of screen correctly, and do a
full flush before insert.
@
text
@d1 1
a1 1
/* $OpenBSD: screen-write.c,v 1.112 2017/02/09 10:09:14 nicm Exp $ */
d744 1
d768 1
a768 2
	else
		screen_write_collect_flush(ctx, 0);
d790 1
a790 2
	else
		screen_write_collect_flush(ctx, 0);
d865 3
d1004 1
a1004 1
		log_debug("discarding %zu bytes on line %u", size, i);
d1016 3
d1130 1
@


1.112
log
@Combining characters need a full flush.
@
text
@d1 1
a1 1
/* $OpenBSD: screen-write.c,v 1.111 2017/02/09 09:33:15 nicm Exp $ */
d1263 1
@


1.111
log
@When an ordinary (not collected) cell is received, we need to flush any
delayed scrolling before drawing it.
@
text
@d1 1
a1 1
/* $OpenBSD: screen-write.c,v 1.110 2017/02/08 17:31:09 nicm Exp $ */
a1155 3
	/* Flush any existing scrolling. */
	screen_write_collect_flush(ctx, 1);

d1158 1
d1167 3
@


1.110
log
@Add support for scroll up escape sequence (CSI S) and use it when
possible instead of sending individual line feeds.
@
text
@d1 1
a1 1
/* $OpenBSD: screen-write.c,v 1.109 2017/02/08 16:45:18 nicm Exp $ */
d31 1
a31 1
static void	screen_write_collect_flush(struct screen_write_ctx *);
d88 1
a88 1
	screen_write_collect_flush(ctx);
d573 1
a573 1
	screen_write_collect_flush(ctx);
d601 1
a601 1
	screen_write_collect_flush(ctx);
d628 1
a628 1
	screen_write_collect_flush(ctx);
d655 1
a655 1
		screen_write_collect_flush(ctx);
d674 1
a674 1
	screen_write_collect_flush(ctx);
d701 1
a701 1
		screen_write_collect_flush(ctx);
d720 1
a720 1
	screen_write_collect_flush(ctx);
d768 1
a768 1
		screen_write_collect_flush(ctx);
d791 1
a791 1
		screen_write_collect_flush(ctx);
d824 1
a824 1
	screen_write_collect_flush(ctx);
d842 1
a842 1
	screen_write_collect_flush(ctx);
d925 1
a925 1
	screen_write_collect_flush(ctx);
d948 1
a948 1
	screen_write_collect_flush(ctx);
d1024 1
a1024 1
screen_write_collect_flush(struct screen_write_ctx *ctx)
d1042 2
d1156 3
a1261 1
		screen_write_collect_flush(ctx);
@


1.109
log
@Collect sequences of printable ASCII characters and process them
together instead of handling them one by one. This is significantly
faster. Sequences are terminated when we reach the end of the line, fill
the internal buffer, or a different character is seen by the input
parser (an escape sequence, or UTF-8).

Rather than writing collected sequences out immediately, hold them until
it is necessary (another screen modification, or we consume all
available data). This means we can discard changes that would have no
effect (for example, lines that would just be scrolled off the screen or
cleared). This reduces the total amount of data we write out to the
terminal - not important for fast terminals, but a big help with slow
(like xterm).
@
text
@d1 1
a1 1
/* $OpenBSD: screen-write.c,v 1.108 2017/02/08 15:49:29 nicm Exp $ */
d842 2
a858 1
	struct tty_ctx		 ttyctx;
a867 1

d869 1
a869 2
		screen_write_initctx(ctx, &ttyctx);
		tty_write(tty_cmd_linefeed, &ttyctx);
d874 20
d1030 12
@


1.108
log
@Some other tidying bits.
@
text
@d1 1
a1 1
/* $OpenBSD: screen-write.c,v 1.107 2017/02/08 15:41:41 nicm Exp $ */
d28 4
a31 1
static void	screen_write_flush(struct screen_write_ctx *);
d42 13
a54 9
#define screen_dirty_bit(s, x, y) (((y) * screen_size_x(s)) + (x))
#define screen_dirty_clear(s, sx, sy, ex, ey)			\
	do {							\
		if (s->dirty != NULL) {				\
			bit_nclear(s->dirty,			\
			    screen_dirty_bit(s, sx, sy),	\
			    screen_dirty_bit(s, ex, ey));	\
		}						\
	} while (0)
a60 1
	u_int	size;
d62 3
d72 4
a75 9
	size = screen_size_x(ctx->s) * screen_size_y(ctx->s);
	if (ctx->s->dirtysize != size) {
		free(ctx->s->dirty);
		ctx->s->dirty = NULL;
		ctx->s->dirtysize = size;
	}
	ctx->dirty = 0;

	ctx->cells = ctx->written = ctx->skipped = 0;
d87 2
a88 1
	screen_write_flush(ctx);
d90 2
a91 3
	log_debug("%s: %u of %u written (dirty %u, skipped %u)", __func__,
	    ctx->written, ctx->cells, ctx->cells - ctx->written, ctx->skipped);
}
d93 2
a94 43
/* Flush outstanding cell writes. */
static void
screen_write_flush(struct screen_write_ctx *ctx)
{
	struct screen	*s = ctx->s;
	struct tty_ctx	 ttyctx;
	u_int		 x, y, offset, cx, cy, dirty;
	struct grid_cell gc;

	if (ctx->dirty == 0)
		return;
	dirty = 0;
	log_debug("%s: dirty %u", __func__, ctx->dirty);

	cx = s->cx;
	cy = s->cy;

	offset = 0;
	for (y = 0; y < screen_size_y(s); y++) {
		for (x = 0; x < screen_size_x(s); x++) {
			offset++;
			if (!bit_test(s->dirty, offset - 1))
				continue;
			bit_clear(s->dirty, offset - 1);

			screen_write_cursormove(ctx, x, y);
			grid_view_get_cell(s->grid, x, y, &gc);

			screen_write_initctx(ctx, &ttyctx);
			ttyctx.cell = &gc;
			tty_write(tty_cmd_cell, &ttyctx);
			ctx->written++;

			if (++dirty == ctx->dirty)
				break;
		}
		if (dirty == ctx->dirty)
			break;
	}
	ctx->dirty = 0;

	s->cx = cx;
	s->cy = cy;
a528 1
	u_int		 	 sx = screen_size_x(s), sy = screen_size_y(s);
a531 2
	screen_dirty_clear(s, 0, 0, sx - 1, sy  - 1);

d546 1
a567 1
	screen_write_flush(ctx);
d573 1
a595 1
	screen_write_flush(ctx);
d601 1
a625 1
	screen_dirty_clear(s, s->cx, s->cy, s->cx + nx - 1, s->cy);
d628 1
a649 1
		screen_write_flush(ctx);
d655 1
a665 1
	screen_write_flush(ctx);
d674 1
a695 1
		screen_write_flush(ctx);
d701 1
a711 1
	screen_write_flush(ctx);
d720 1
a740 1
	screen_dirty_clear(s, 0, s->cy, sx - 1, s->cy);
d743 1
a762 1
	screen_dirty_clear(s, s->cx, s->cy, sx - 1, s->cy);
d765 4
d783 1
a783 2
	if (s->cx > sx - 1) {
		screen_dirty_clear(s, 0, s->cy, sx - 1, s->cy);
d785 1
a785 2
	} else {
		screen_dirty_clear(s, 0, s->cy, s->cx, s->cy);
a786 1
	}
d788 4
d819 1
a819 2
	if (s->cy == s->rupper) {
		screen_write_flush(ctx);
d821 1
a821 1
	} else if (s->cy > 0)
d824 1
d855 1
d857 1
a857 4
	struct tty_ctx	 	 ttyctx;
	u_int			 sx = screen_size_x(s), sy = screen_size_y(s);

	screen_write_initctx(ctx, &ttyctx);
d859 1
a859 1
	gl = &s->grid->linedata[s->grid->hsize + s->cy];
d866 6
a871 4
		screen_dirty_clear(s, 0, s->rupper, sx - 1, s->rupper);
		screen_write_flush(ctx);
		grid_view_scroll_region_up(s->grid, s->rupper, s->rlower);
	} else if (s->cy < sy - 1)
a872 3

	ttyctx.num = wrapped;
	tty_write(tty_cmd_linefeed, &ttyctx);
d897 1
a897 2
	if (s->cx == 0 && s->cy == 0 && gd->flags & GRID_HISTORY) {
		screen_dirty_clear(s, 0, 0, sx - 1, sy  - 1);
d899 2
a900 3
	} else {
		if (s->cx <= sx - 1) {
			screen_dirty_clear(s, s->cx, s->cy, sx - 1, s->cy);
a901 2
		}
		screen_dirty_clear(s, 0, s->cy + 1, sx - 1, sy - 1);
d905 2
d921 1
a921 2
	if (s->cy > 0) {
		screen_dirty_clear(s, 0, 0, sx - 1, s->cy);
d923 4
a926 8
	}
	if (s->cx > sx - 1) {
		screen_dirty_clear(s, 0, s->cy, sx - 1, s->cy);
		grid_view_clear(s->grid, 0, s->cy, sx, 1, bg);
	} else {
		screen_dirty_clear(s, 0, s->cy, s->cx, s->cy);
		grid_view_clear(s->grid, 0, s->cy, s->cx + 1, 1, bg);
	}
d928 2
a943 2
	screen_dirty_clear(s, 0, 0, sx - 1, sy  - 1);

d950 1
d965 139
d1110 3
a1113 1
	u_int		 	 width, xx, last;
d1115 2
a1116 6
	struct grid_line	*gl;
	struct grid_cell 	 tmp_gc, now_gc;
	struct grid_cell_entry	*gce;
	int			 insert, skip, selected;

	ctx->cells++;
d1118 1
a1118 1
	/* Ignore padding. */
d1121 1
a1121 9
	width = gc->data.width;

	/*
	 * If this is a wide character and there is no room on the screen for
	 * the entire character, don't print it.
	 */
	if (!(s->mode & MODE_WRAP) && (width > 1 &&
	    (width > sx || (s->cx != sx && s->cx > sx - width))))
		return;
d1123 1
a1123 4
	/*
	 * If the width is zero, combine onto the previous character, if
	 * there is space.
	 */
d1134 6
d1142 3
a1144 9
		if (s->cx <= sx - width) {
			screen_write_flush(ctx);
			xx = sx - s->cx - width;
			grid_view_insert_cells(s->grid, s->cx, s->cy, xx, 8);
		}
		insert = 1;
	} else
		insert = 0;
	skip = !insert;
d1149 1
a1149 1
		s->cx = 0;	/* carriage return */
a1154 2

	/* Initialise the redraw context. */
d1192 2
d1201 1
a1201 2
	if (selected && ~gc->flags & GRID_FLAG_SELECTED) {
		skip = 0;
d1205 1
a1205 2
	} else if (!selected && gc->flags & GRID_FLAG_SELECTED) {
		skip = 0;
d1211 2
d1225 2
a1226 1
	if (insert) {
d1232 6
a1237 4
	if (selected) {
		screen_write_flush(ctx);
		screen_select_cell(s, &tmp_gc, gc);
		ttyctx.cell = &tmp_gc;
a1239 16
	} else if (!skip) {
		/*
		 * If wp is NULL, we are not updating the terminal and don't
		 * care about actually writing the cells (tty_write will just
		 * return). So don't even bother allocating the dirty array.
		 */
		if (ctx->wp != NULL && s->dirty == NULL) {
			log_debug("%s: allocating %u bits", __func__,
			    s->dirtysize);
			s->dirty = bit_alloc(s->dirtysize);
		}
		if (s->dirty != NULL) {
			bit_set(s->dirty, screen_dirty_bit(s,
			    ttyctx.ocx, ttyctx.ocy));
			ctx->dirty++;
		}
@


1.107
log
@Add a helper to store a cell, and some tidying.
@
text
@d1 1
a1 1
/* $OpenBSD: screen-write.c,v 1.106 2017/02/08 08:50:10 nicm Exp $ */
d54 2
a55 3
	u_int		 size;
	char		 tmp[16];
	const char	*cp = tmp;
d73 1
a73 3
	if (wp == NULL)
		cp = "no pane";
	else
d76 1
a76 1
	    screen_size_y(ctx->s), cp);
a772 3
	screen_write_initctx(ctx, &ttyctx);
	ttyctx.bg = bg;

d777 3
a794 3
	screen_write_initctx(ctx, &ttyctx);
	ttyctx.bg = bg;

d798 3
@


1.106
log
@Trying to avoid the occasional newline by saving the last cell on screen
is not actually helping us much and just adds complexity, so don't
bother.
@
text
@d1 1
a1 1
/* $OpenBSD: screen-write.c,v 1.105 2017/02/06 19:26:49 nicm Exp $ */
d607 3
d612 1
d614 1
a614 2
	if (s->cx <= screen_size_x(s) - 1)
		grid_view_insert_cells(s->grid, s->cx, s->cy, nx, bg);
a616 1
	ttyctx.bg = bg;
d635 3
d640 1
d642 1
a642 2
	if (s->cx <= screen_size_x(s) - 1)
		grid_view_delete_cells(s->grid, s->cx, s->cy, nx, bg);
a644 1
	ttyctx.bg = bg;
d663 3
d668 2
a669 5
	if (s->cx <= screen_size_x(s) - 1) {
		screen_dirty_clear(s, s->cx, s->cy, s->cx + nx - 1, s->cy);
		grid_view_clear(s->grid, s->cx, s->cy, nx, 1, 8);
	} else
		return;
d680 1
d694 1
d696 1
a696 1
		grid_view_insert_lines(s->grid, s->cy, ny, bg);
a698 1
		ttyctx.bg = bg;
d710 1
d713 3
a715 5
		grid_view_insert_lines(s->grid, s->cy, ny, bg);
	else {
		grid_view_insert_lines_region(s->grid, s->rlower, s->cy, ny,
		    bg);
	}
a717 1
	ttyctx.bg = bg;
d726 1
d740 1
d742 1
a742 1
		grid_view_delete_lines(s->grid, s->cy, ny, bg);
a744 1
		ttyctx.bg = bg;
d756 1
d759 3
a761 5
		grid_view_delete_lines(s->grid, s->cy, ny, bg);
	else {
		grid_view_delete_lines_region(s->grid, s->rlower, s->cy, ny,
		    bg);
	}
a763 1
	ttyctx.bg = bg;
d930 1
d938 1
a938 1
	if (s->cx == 0 && s->cy == 0 && s->grid->flags & GRID_HISTORY) {
d940 1
a940 1
		grid_view_clear_history(s->grid, bg);
d944 1
a944 2
			grid_view_clear(s->grid, s->cx, s->cy, sx - s->cx, 1,
			    bg);
d947 1
a947 2
		grid_view_clear(s->grid, 0, s->cy + 1, sx, sy - (s->cy + 1),
		    bg);
d1281 1
d1294 1
@


1.105
log
@Add BCE for clear to start of screen, which was somehow missed.
@
text
@d1 1
a1 1
/* $OpenBSD: screen-write.c,v 1.104 2017/02/06 13:23:00 nicm Exp $ */
a27 2
static void	screen_write_save_last(struct screen_write_ctx *,
		    struct tty_ctx *);
a437 18
/* Save last cell on screen. */
static void
screen_write_save_last(struct screen_write_ctx *ctx, struct tty_ctx *ttyctx)
{
	struct screen		*s = ctx->s;
	struct grid		*gd = s->grid;
	struct grid_cell	 gc;
	u_int			 xx;

	memcpy(&gc, &grid_default_cell, sizeof gc);
	for (xx = 1; xx <= screen_size_x(s); xx++) {
		grid_view_get_cell(gd, screen_size_x(s) - xx, s->cy, &gc);
		if (~gc.flags & GRID_FLAG_PADDING)
			break;
	}
	memcpy(&ttyctx->last_cell, &gc, sizeof ttyctx->last_cell);
}

d1023 1
a1023 1
	int			 insert, skip, selected, wrapped = 0;
a1053 3
	/* Initialise the redraw context. */
	screen_write_initctx(ctx, &ttyctx);

a1067 2
		screen_write_flush(ctx);
		screen_write_save_last(ctx, &ttyctx);
a1069 2
		skip = 0;
		wrapped = 1;
d1076 3
d1158 14
a1171 21
		if (wrapped) {
			ttyctx.cell = gc;
			tty_write(tty_cmd_cell, &ttyctx);
			ctx->written++;
		} else {
			/*
			 * If wp is NULL, we are not updating the terminal and
			 * don't care about actually writing the cells
			 * (tty_write will just return). So don't even bother
			 * allocating the dirty array.
			 */
			if (ctx->wp != NULL && s->dirty == NULL) {
				log_debug("%s: allocating %u bits", __func__,
				    s->dirtysize);
				s->dirty = bit_alloc(s->dirtysize);
			}
			if (s->dirty != NULL) {
				bit_set(s->dirty, screen_dirty_bit(s,
				    ttyctx.ocx, ttyctx.ocy));
				ctx->dirty++;
			}
@


1.104
log
@Only redraw the modified character when adding combining characters, not
the whole line.
@
text
@d1 1
a1 1
/* $OpenBSD: screen-write.c,v 1.103 2017/01/12 00:19:32 nicm Exp $ */
d974 1
a974 1
screen_write_clearstartofscreen(struct screen_write_ctx *ctx)
d981 1
d985 1
a985 1
		grid_view_clear(s->grid, 0, 0, sx, s->cy, 8);
d989 1
a989 1
		grid_view_clear(s->grid, 0, s->cy, sx, 1, 8);
d992 1
a992 1
		grid_view_clear(s->grid, 0, s->cy, s->cx + 1, 1, 8);
@


1.103
log
@Fix setting the palette of aixterm colours (90-97).
@
text
@d1 1
a1 1
/* $OpenBSD: screen-write.c,v 1.102 2017/01/05 09:07:16 nicm Exp $ */
d34 2
a35 2
static int	screen_write_combine(struct screen_write_ctx *,
		    const struct utf8_data *);
d1064 2
a1065 1
		if (screen_write_combine(ctx, &gc->data) == 0) {
d1067 2
a1068 1
			tty_write(tty_cmd_utf8character, &ttyctx);
d1208 3
a1210 2
static int
screen_write_combine(struct screen_write_ctx *ctx, const struct utf8_data *ud)
d1214 2
a1215 1
	struct grid_cell	 gc;
d1219 1
a1219 1
		return (-1);
d1226 8
a1233 1
	grid_view_get_cell(gd, s->cx - 1, s->cy, &gc);
d1237 4
a1240 1
		return (-1);
d1247 1
a1247 1
	grid_view_set_cell(gd, s->cx - 1, s->cy, &gc);
d1249 1
a1249 1
	return (0);
@


1.102
log
@Highlight all occurrences of search string after searching in copy mode.
@
text
@d1 1
a1 1
/* $OpenBSD: screen-write.c,v 1.101 2016/12/09 21:39:27 nicm Exp $ */
d1052 1
a1052 1
	 * If this is a wide character and there is no room on the screen, for
@


1.101
log
@Spacing nits.
@
text
@d1 1
a1 1
/* $OpenBSD: screen-write.c,v 1.100 2016/10/18 08:39:18 nicm Exp $ */
d395 2
a396 1
    u_int py, u_int nx, u_int ny)
d401 1
a401 1
	u_int		 	 xx, yy, cx, cy;
d409 8
@


1.100
log
@Zero dirty count after flushing.
@
text
@d1 1
a1 1
/* $OpenBSD: screen-write.c,v 1.99 2016/10/13 20:27:27 nicm Exp $ */
d519 1
a519 1
/* Cursor right by nx.  */
d842 1
a842 1
/* Move cursor to px,py.  */
d857 1
a857 1
/* Reverse index (up with scroll).  */
@


1.99
log
@Add support for BCE (background colour erase). This makes various escape
sequences (notable EL and ED but also IL, DL, ICH, DCH) create blank
cells using the current background colour rather than the default
colour.

On modern systems BCE doesn't really have many benefits, but most other
terminals now support it, some (lazy) applications rely on it, and it is
not hard to include now that we have pane background colours anyway.

Mostly written by Sean Haugh.
@
text
@d1 1
a1 1
/* $OpenBSD: screen-write.c,v 1.98 2016/10/12 15:43:51 nicm Exp $ */
d133 1
@


1.98
log
@Fix a couple of problems with insert mode: flush dirty cells before we
modify the screen, not after; and use grid_view_insert_cells to make
space not grid_move_cells.
@
text
@d1 1
a1 1
/* $OpenBSD: screen-write.c,v 1.97 2016/10/12 13:24:07 nicm Exp $ */
d150 1
a150 1
	screen_write_clearscreen(ctx);
d604 1
a604 1
screen_write_insertcharacter(struct screen_write_ctx *ctx, u_int nx)
d621 1
a621 1
		grid_view_insert_cells(s->grid, s->cx, s->cy, nx);
d624 1
d630 1
a630 1
screen_write_deletecharacter(struct screen_write_ctx *ctx, u_int nx)
d647 1
a647 1
		grid_view_delete_cells(s->grid, s->cx, s->cy, nx);
d650 1
d673 1
a673 1
		grid_view_clear(s->grid, s->cx, s->cy, nx, 1);
d683 1
a683 1
screen_write_insertline(struct screen_write_ctx *ctx, u_int ny)
d700 1
a700 1
		grid_view_insert_lines(s->grid, s->cy, ny);
d703 1
d717 5
a721 3
		grid_view_insert_lines(s->grid, s->cy, ny);
	else
		grid_view_insert_lines_region(s->grid, s->rlower, s->cy, ny);
d724 1
d730 1
a730 1
screen_write_deleteline(struct screen_write_ctx *ctx, u_int ny)
d747 1
a747 1
		grid_view_delete_lines(s->grid, s->cy, ny);
d750 1
d764 5
a768 3
		grid_view_delete_lines(s->grid, s->cy, ny);
	else
		grid_view_delete_lines_region(s->grid, s->rlower, s->cy, ny);
d771 1
d777 1
a777 1
screen_write_clearline(struct screen_write_ctx *ctx)
d785 1
d788 1
a788 4
	if (gl->cellsize != 0) {
		screen_dirty_clear(s, 0, s->cy, sx - 1, s->cy);
		grid_view_clear(s->grid, 0, s->cy, sx, 1);
	} else
d791 3
d799 1
a799 1
screen_write_clearendofline(struct screen_write_ctx *ctx)
d807 1
d810 1
a810 4
	if (s->cx <= sx - 1 && s->cx < gl->cellsize) {
		screen_dirty_clear(s, s->cx, s->cy, sx - 1, s->cy);
		grid_view_clear(s->grid, s->cx, s->cy, sx - s->cx, 1);
	} else
d813 3
d821 1
a821 1
screen_write_clearstartofline(struct screen_write_ctx *ctx)
d828 1
d832 1
a832 1
		grid_view_clear(s->grid, 0, s->cy, sx, 1);
d835 1
a835 1
		grid_view_clear(s->grid, 0, s->cy, s->cx + 1, 1);
d935 1
a935 1
screen_write_clearendofscreen(struct screen_write_ctx *ctx)
d942 1
d945 1
a945 1
	if (s->cy == 0 && s->grid->flags & GRID_HISTORY) {
d947 1
a947 1
		grid_view_clear_history(s->grid);
d951 2
a952 1
			grid_view_clear(s->grid, s->cx, s->cy, sx - s->cx, 1);
d955 2
a956 1
		grid_view_clear(s->grid, 0, s->cy + 1, sx, sy - (s->cy + 1));
d974 1
a974 1
		grid_view_clear(s->grid, 0, 0, sx, s->cy);
d978 1
a978 1
		grid_view_clear(s->grid, 0, s->cy, sx, 1);
d981 1
a981 1
		grid_view_clear(s->grid, 0, s->cy, s->cx + 1, 1);
d989 1
a989 1
screen_write_clearscreen(struct screen_write_ctx *ctx)
d996 1
d1002 1
a1002 1
		grid_view_clear_history(s->grid);
d1004 1
a1004 1
		grid_view_clear(s->grid, 0, 0, sx, sy);
d1016 1
a1016 1
	grid_move_lines(gd, 0, gd->hsize, gd->sy);
d1069 1
a1069 1
			grid_view_insert_cells(s->grid, s->cx, s->cy, xx);
@


1.97
log
@Redraw selection in tty_draw_line, so it appears when redrawing whole
pane. Reported by Theo Buehler.
@
text
@d1 1
a1 1
/* $OpenBSD: screen-write.c,v 1.96 2016/10/05 22:00:29 nicm Exp $ */
d106 1
d1048 6
a1053 3
	if ((s->mode & MODE_INSERT) && s->cx <= sx - width) {
		xx = sx - s->cx - width;
		grid_move_cells(s->grid, s->cx + width, s->cx, s->cy, xx);
a1139 2
		if (!wrapped)
			screen_write_flush(ctx);
@


1.96
log
@screen_write_copy tried to be clever and clear the line if it reached
the end of the source, but it was wrong and causes problems that are
only showing up now we are more aggressive about skipping redundant
screen updates. Remove the optimization entirely as more trouble than it
is worth to fix (and it'll have to go when BCE is done anyway).
@
text
@d1 1
a1 1
/* $OpenBSD: screen-write.c,v 1.95 2016/10/05 12:36:36 nicm Exp $ */
a1143 5
		memcpy(&tmp_gc, &s->sel.cell, sizeof tmp_gc);
		utf8_copy(&tmp_gc.data, &gc->data);
		tmp_gc.attr = tmp_gc.attr & ~GRID_ATTR_CHARSET;
		tmp_gc.attr |= gc->attr & GRID_ATTR_CHARSET;
		tmp_gc.flags = gc->flags;
d1145 1
@


1.95
log
@Wrap some long lines in screen-write.c.
@
text
@d1 1
a1 1
/* $OpenBSD: screen-write.c,v 1.94 2016/09/29 08:50:43 nicm Exp $ */
a396 1
	struct grid_line	*gl;
d398 1
a398 1
	u_int		 	 xx, yy, cx, cy, ax, bx;
d402 1
d404 5
a408 25
		gl = &gd->linedata[yy];
		if (yy < gd->hsize + gd->sy) {
			/*
			 * Find start and end position and copy between
			 * them. Limit to the real end of the line then use a
			 * clear EOL only if copying to the end, otherwise
			 * could overwrite whatever is there already.
			 */
			if (px > gl->cellsize)
				ax = gl->cellsize;
			else
				ax = px;
			if (px + nx == gd->sx && px + nx > gl->cellsize)
				bx = gl->cellsize;
			else
				bx = px + nx;

			for (xx = ax; xx < bx; xx++) {
				grid_get_cell(gd, xx, yy, &gc);
				screen_write_cell(ctx, &gc);
			}
			if (px + nx == gd->sx && px + nx > gl->cellsize)
				screen_write_clearendofline(ctx);
		} else
			screen_write_clearline(ctx);
@


1.94
log
@Check padding when writing any character with width > 1, in case they
overlap after the first character (for example with cells xy and ab, y
is replacing a).
@
text
@d1 1
a1 1
/* $OpenBSD: screen-write.c,v 1.93 2016/09/02 20:57:20 nicm Exp $ */
d392 2
a393 2
screen_write_copy(struct screen_write_ctx *ctx,
    struct screen *src, u_int px, u_int py, u_int nx, u_int ny)
d1114 1
a1114 1
			else if (gc->flags != (gce->flags & ~GRID_FLAG_EXTENDED))
d1122 3
a1124 1
			else if (gc->data.width != 1 || gce->data.data != gc->data.data[0])
d1272 2
a1273 2
	 * Overwrite any padding cells that belong to any UTF-8 characters we'll be
	 * overwriting with the current character.
d1275 3
a1277 1
	if (width != 1 || gc->data.width != 1 || gc->flags & GRID_FLAG_PADDING) {
@


1.93
log
@Remember the number of lines scrolled into the history (versus cleared
into the history) and when resizing only use scrolled lines and not
cleared lines (which are probably not intended to reappear). From
Chaoren Lin.
@
text
@d1 1
a1 1
/* $OpenBSD: screen-write.c,v 1.92 2016/07/15 00:49:08 nicm Exp $ */
d1270 2
a1271 2
	 * Overwrite any padding cells that belong to a UTF-8 character
	 * we'll be overwriting with the current character.
d1273 1
a1273 1
	if (gc->data.width != 1 || gc->flags & GRID_FLAG_PADDING) {
@


1.92
log
@Don't update cells in each block of data read from a pane immediately,
instead track them as change (dirty) and update them once at the end,
saves much time if repeatedly writing the same cell. Also fix comparison
of cells being equal in a few places (memcmp is not enough).
@
text
@d1 1
a1 1
/* $OpenBSD: screen-write.c,v 1.91 2016/07/15 00:42:56 nicm Exp $ */
d1019 1
a1019 1
	gd->hsize = 0;
@


1.91
log
@Instead of representing colours in several different forms with various
cell flags, convert to use an int with flags marking 256 or RGB colours
in the top byte (except in cells, which we don't want to make any
bigger). From Brad Town.
@
text
@d1 1
a1 1
/* $OpenBSD: screen-write.c,v 1.90 2016/06/06 07:28:52 nicm Exp $ */
d30 1
d41 11
a51 1
/* Initialise writing with a window. */
d56 4
d65 17
d86 11
a96 1
screen_write_stop(__unused struct screen_write_ctx *ctx)
d98 37
a463 1
	ttyctx->last_width = xx;
d598 1
d602 2
a615 1

d636 1
d661 1
d688 2
a689 1
	if (s->cx <= screen_size_x(s) - 1)
d691 2
d714 1
d729 1
d757 1
d772 1
d788 4
a791 2
	struct screen	*s = ctx->s;
	struct tty_ctx	 ttyctx;
d795 6
a800 1
	grid_view_clear(s->grid, 0, s->cy, screen_size_x(s), 1);
d809 4
a812 3
	struct screen	*s = ctx->s;
	struct tty_ctx	 ttyctx;
	u_int		 sx;
d816 3
a818 3
	sx = screen_size_x(s);

	if (s->cx <= sx - 1)
d820 2
d832 1
a832 1
	u_int		 sx;
d836 2
a837 3
	sx = screen_size_x(s);

	if (s->cx > sx - 1)
d839 2
a840 1
	else
d842 1
d871 2
a872 1
	if (s->cy == s->rupper)
d874 1
a874 1
	else if (s->cy > 0)
d909 1
d919 3
a921 1
	if (s->cy == s->rlower)
d923 1
a923 1
	else if (s->cy < screen_size_y(s) - 1)
d945 1
a945 1
	u_int		 sx, sy;
a948 3
	sx = screen_size_x(s);
	sy = screen_size_y(s);

d950 2
a951 1
	if (s->cy == 0 && s->grid->flags & GRID_HISTORY)
d953 3
a955 2
	else {
		if (s->cx <= sx - 1)
d957 2
d971 1
a971 1
	u_int		 sx;
d975 2
a976 3
	sx = screen_size_x(s);

	if (s->cy > 0)
d978 3
a980 1
	if (s->cx > sx - 1)
d982 2
a983 1
	else
d985 1
d996 1
a996 2
	u_int		 sx = screen_size_x(s);
	u_int		 sy = screen_size_y(s);
d1000 2
d1030 2
d1033 4
a1036 1
	int			 insert, skip, selected;
d1047 2
a1048 4
	if (!(s->mode & MODE_WRAP)
	    && (width > 1 && (width > screen_size_x(s) ||
		(s->cx != screen_size_x(s)
		 && s->cx > screen_size_x(s) - width))))
d1067 2
a1068 2
	if ((s->mode & MODE_INSERT) && s->cx <= screen_size_x(s) - width) {
		xx = screen_size_x(s) - s->cx - width;
d1076 3
a1078 1
	if ((s->mode & MODE_WRAP) && s->cx > screen_size_x(s) - width) {
d1082 1
d1086 1
a1086 1
	if (s->cx > screen_size_x(s) - width || s->cy > screen_size_y(s) - 1)
d1090 6
a1095 3
	grid_view_get_cell(gd, s->cx, s->cy, &now_gc);
	if (screen_write_overwrite(ctx, &now_gc, width))
		skip = 0;
d1107 19
a1125 2
	if (skip)
		skip = (memcmp(&now_gc, gc, sizeof now_gc) == 0);
d1147 1
a1147 1
	if (s->cx <= screen_size_x(s) - last - width)
d1150 1
a1150 1
		s->cx = screen_size_x(s) - last;
d1154 2
a1159 4
	/* Save last cell if it will be needed. */
	if (!skip && ctx->wp != NULL && ttyctx.ocx > ctx->wp->sx - width)
		screen_write_save_last(ctx, &ttyctx);

d1167 1
d1170 1
d1172 24
a1195 3
		ttyctx.cell = gc;
		tty_write(tty_cmd_cell, &ttyctx);
	}
@


1.90
log
@Cache selected state so that cells going from selected to unselected are not
skipped, reported by Omar Sandoval.
@
text
@d1 1
a1 1
/* $OpenBSD: screen-write.c,v 1.89 2016/05/30 09:32:24 nicm Exp $ */
d37 1
a37 1
	GRID_FLAG_PADDING, 0, { .fg = 8 }, { .bg = 8 }, { { 0 }, 0, 0, 0 }
a1033 4
		tmp_gc.flags &= ~(GRID_FLAG_FGRGB|GRID_FLAG_BGRGB);
		tmp_gc.flags &= ~(GRID_FLAG_FG256|GRID_FLAG_BG256);
		tmp_gc.flags |= s->sel.cell.flags &
		    (GRID_FLAG_FG256|GRID_FLAG_BG256);
@


1.89
log
@Do not draw character to screen if it has not changed, and do not save
last character if it won't be used. This (and last few commits) prompted
by a report from Hubert depesz Lubaczewski.
@
text
@d1 1
a1 1
/* $OpenBSD: screen-write.c,v 1.88 2016/05/27 23:06:12 nicm Exp $ */
d992 13
a1004 2
	/* Set the cell. */
	if (!skip)
a1021 5

	/* Check if this is selected. */
	selected = screen_check_selection(s, s->cx - width, s->cy);
	if (selected)
		skip = 0;
@


1.88
log
@Padding cell is always the same so use a static.
@
text
@d1 1
a1 1
/* $OpenBSD: screen-write.c,v 1.87 2016/05/27 23:02:17 nicm Exp $ */
d31 2
a32 1
static void	screen_write_overwrite(struct screen_write_ctx *, u_int);
d921 2
a922 2
	struct grid_cell 	 tmp_gc;
	int			 insert;
d951 1
a951 1
	/* Initialise the redraw context, saving the last cell. */
a952 1
	screen_write_save_last(ctx, &ttyctx);
d961 1
d967 1
d975 3
a977 1
	screen_write_overwrite(ctx, width);
d983 1
a983 1
	for (xx = s->cx + 1; xx < s->cx + width; xx++)
d985 6
d993 2
a994 1
	grid_view_set_cell(gd, s->cx, s->cy, gc);
d1006 1
a1006 1
	/* Draw to the screen if necessary. */
d1011 12
a1022 1
	if (screen_check_selection(s, s->cx - width, s->cy)) {
d1034 1
a1034 1
	} else {
d1082 3
a1084 2
static void
screen_write_overwrite(struct screen_write_ctx *ctx, u_int width)
d1088 1
a1088 1
	struct grid_cell	 gc;
d1090 1
d1092 1
a1092 2
	grid_view_get_cell(gd, s->cx, s->cy, &gc);
	if (gc.flags & GRID_FLAG_PADDING) {
d1100 2
a1101 2
			grid_view_get_cell(gd, xx, s->cy, &gc);
			if (~gc.flags & GRID_FLAG_PADDING)
d1108 1
d1115 9
a1123 6
	xx = s->cx + width - 1;
	while (++xx < screen_size_x(s)) {
		grid_view_get_cell(gd, xx, s->cy, &gc);
		if (~gc.flags & GRID_FLAG_PADDING)
			break;
		grid_view_set_cell(gd, xx, s->cy, &grid_default_cell);
d1125 2
@


1.87
log
@Break the save-last-cell code into a separate function (so it can be
called conditionally later).
@
text
@d1 1
a1 1
/* $OpenBSD: screen-write.c,v 1.86 2016/04/29 13:21:33 nicm Exp $ */
d35 4
a978 3
	memcpy(&tmp_gc, &grid_default_cell, sizeof tmp_gc);
	tmp_gc.flags |= GRID_FLAG_PADDING;
	tmp_gc.data.width = 0;
d980 1
a980 1
		grid_view_set_cell(gd, xx, s->cy, &tmp_gc);
@


1.86
log
@Make the grid_cell passed into screen_write_* const.
@
text
@d1 1
a1 1
/* $OpenBSD: screen-write.c,v 1.85 2016/01/31 14:11:49 nicm Exp $ */
d26 8
a33 4
void	screen_write_initctx(struct screen_write_ctx *, struct tty_ctx *, int);
void	screen_write_overwrite(struct screen_write_ctx *, u_int);
int	screen_write_combine(struct screen_write_ctx *,
	    const struct utf8_data *);
d351 2
a352 3
void
screen_write_initctx(struct screen_write_ctx *ctx, struct tty_ctx *ttyctx,
    int save_last)
d354 1
a354 4
	struct screen		*s = ctx->s;
	struct grid		*gd = s->grid;
	struct grid_cell	 gc;
	u_int			 xx;
d363 1
d365 8
a372 2
	if (!save_last)
		return;
a373 1
	/* Save the last cell on the screen. */
d516 1
a516 1
	screen_write_initctx(ctx, &ttyctx, 0);
d551 1
a551 1
	screen_write_initctx(ctx, &ttyctx, 0);
d575 1
a575 1
	screen_write_initctx(ctx, &ttyctx, 0);
d599 1
a599 1
	screen_write_initctx(ctx, &ttyctx, 0);
d624 1
a624 1
		screen_write_initctx(ctx, &ttyctx, 0);
d638 1
a638 1
	screen_write_initctx(ctx, &ttyctx, 0);
d665 1
a665 1
		screen_write_initctx(ctx, &ttyctx, 0);
d679 1
a679 1
	screen_write_initctx(ctx, &ttyctx, 0);
d697 1
a697 1
	screen_write_initctx(ctx, &ttyctx, 0);
d712 1
a712 1
	screen_write_initctx(ctx, &ttyctx, 0);
d730 1
a730 1
	screen_write_initctx(ctx, &ttyctx, 0);
d764 1
a764 1
	screen_write_initctx(ctx, &ttyctx, 0);
d804 1
a804 1
	screen_write_initctx(ctx, &ttyctx, 0);
d838 1
a838 1
	screen_write_initctx(ctx, &ttyctx, 0);
d863 1
a863 1
	screen_write_initctx(ctx, &ttyctx, 0);
d886 1
a886 1
	screen_write_initctx(ctx, &ttyctx, 0);
d940 1
a940 1
			screen_write_initctx(ctx, &ttyctx, 0);
d947 2
a948 1
	screen_write_initctx(ctx, &ttyctx, 1);
d1018 1
a1018 1
int
d1059 1
a1059 1
void
d1104 1
a1104 1
	screen_write_initctx(ctx, &ttyctx, 0);
d1114 1
a1114 1
	struct tty_ctx		 ttyctx;
d1116 1
a1116 1
	screen_write_initctx(ctx, &ttyctx, 0);
@


1.85
log
@Clear RGB flags during selection.
@
text
@d1 1
a1 1
/* $OpenBSD: screen-write.c,v 1.84 2016/01/19 15:59:12 nicm Exp $ */
d67 1
a67 1
screen_write_putc(struct screen_write_ctx *ctx, struct grid_cell *gc,
d70 6
a75 2
	utf8_set(&gc->data, ch);
	screen_write_cell(ctx, gc);
d155 1
a155 1
screen_write_puts(struct screen_write_ctx *ctx, struct grid_cell *gc,
d161 1
a161 1
	screen_write_vnputs(ctx, -1, gc, fmt, ap);
d168 1
a168 1
    struct grid_cell *gc, const char *fmt, ...)
d173 1
a173 1
	screen_write_vnputs(ctx, maxlen, gc, fmt, ap);
d179 1
a179 1
    struct grid_cell *gc, const char *fmt, va_list ap)
d181 2
a183 1
	struct utf8_data	ud;
d188 1
d193 1
a193 1
		if (*ptr > 0x7f && utf8_open(&ud, *ptr) == UTF8_MORE) {
d197 1
a197 1
			if (left < (size_t)ud.size - 1)
d199 1
a199 1
			while ((more = utf8_append(&ud, *ptr)) == UTF8_MORE)
d203 6
a208 8
			if (more == UTF8_DONE) {
				if (maxlen > 0 &&
				    size + ud.width > (size_t) maxlen) {
					while (size < (size_t) maxlen) {
						screen_write_putc(ctx, gc, ' ');
						size++;
					}
					break;
d210 1
a210 4
				size += ud.width;

				utf8_copy(&gc->data, &ud);
				screen_write_cell(ctx, gc);
d212 2
d215 1
a215 1
			if (maxlen > 0 && size + 1 > (size_t) maxlen)
d219 1
a219 1
				gc->attr ^= GRID_ATTR_CHARSET;
d222 1
a222 1
				screen_write_putc(ctx, gc, *ptr);
d234 1
a234 1
    struct grid_cell *gc, const char *fmt, ...)
d236 2
a237 2
	struct grid_cell	 lgc;
	struct utf8_data	 ud;
d244 2
a249 2
	memcpy(&lgc, gc, sizeof lgc);

d261 1
a261 1
			style_parse(gc, &lgc, ptr);
d266 1
a266 1
		if (*ptr > 0x7f && utf8_open(&ud, *ptr) == UTF8_MORE) {
d270 1
a270 1
			if (left < (size_t)ud.size - 1)
d272 1
a272 1
			while ((more = utf8_append(&ud, *ptr)) == UTF8_MORE)
d276 6
a281 8
			if (more == UTF8_DONE) {
				if (maxlen > 0 &&
				    size + ud.width > (size_t) maxlen) {
					while (size < (size_t) maxlen) {
						screen_write_putc(ctx, gc, ' ');
						size++;
					}
					break;
d283 1
a283 4
				size += ud.width;

				utf8_copy(&lgc.data, &ud);
				screen_write_cell(ctx, &lgc);
d285 2
d288 1
a288 1
			if (maxlen > 0 && size + 1 > (size_t) maxlen)
d293 1
a293 1
				screen_write_putc(ctx, &lgc, *ptr);
@


1.84
log
@I no longer use my SourceForge address so replace it.
@
text
@d1 1
a1 1
/* $OpenBSD: screen-write.c,v 1.83 2015/12/11 16:37:21 nicm Exp $ */
d997 3
a999 1
		tmp_gc.flags = gc->flags & ~(GRID_FLAG_FG256|GRID_FLAG_BG256);
@


1.83
log
@Style nits and line wrapping of function declarations.
@
text
@d1 1
a1 1
/* $OpenBSD: screen-write.c,v 1.82 2015/11/23 23:47:57 nicm Exp $ */
d4 1
a4 1
 * Copyright (c) 2007 Nicholas Marriott <nicm@@users.sourceforge.net>
@


1.82
log
@Partly revert previous, it is harmless to keep support for UTF-8 mouse
mode inside tmux, just no longer support it for tmux itself.
@
text
@d1 1
a1 1
/* $OpenBSD: screen-write.c,v 1.81 2015/11/23 20:53:09 nicm Exp $ */
d770 2
a771 2
screen_write_scrollregion(
    struct screen_write_ctx *ctx, u_int rupper, u_int rlower)
d877 2
d885 2
a886 4
	else {
		grid_view_clear(
		    s->grid, 0, 0, screen_size_x(s), screen_size_y(s));
	}
@


1.81
log
@Remove support for the UTF-8 mouse extension. This was a briefly used,
poor idea that was fairly quickly replaced by SGR mouse input (which is
now widespread). It is impossible to tell the difference between UTF-8
and non-UTF-8 mouse input; since the mouse-utf8 option was removed tmux
has not handled it correctly in any case; and it is ridiculous to have
three different forms of mouse input.
@
text
@d1 1
a1 1
/* $OpenBSD: screen-write.c,v 1.80 2015/11/18 14:27:44 nicm Exp $ */
d59 1
a59 1
	s->mode &= ~(ALL_MOUSE_MODES|MODE_MOUSE_SGR);
@


1.80
log
@Use __unused rather than rolling our own.
@
text
@d1 1
a1 1
/* $OpenBSD: screen-write.c,v 1.79 2015/11/14 11:45:43 nicm Exp $ */
d59 1
a59 1
	s->mode &= ~(ALL_MOUSE_MODES|MODE_MOUSE_UTF8|MODE_MOUSE_SGR);
@


1.79
log
@All these return values from utf8_* are confusing, use an enum.
@
text
@d1 1
a1 1
/* $OpenBSD: screen-write.c,v 1.78 2015/11/14 10:56:31 nicm Exp $ */
d45 1
a45 1
screen_write_stop(unused struct screen_write_ctx *ctx)
@


1.78
log
@Be more strict about invalid UTF-8.
@
text
@d1 1
a1 1
/* $OpenBSD: screen-write.c,v 1.77 2015/11/13 08:09:28 nicm Exp $ */
d118 1
a118 1
	int			more;
d126 1
a126 1
		if (*ptr > 0x7f && utf8_open(&ud, *ptr)) {
d132 1
a132 1
			while ((more = utf8_append(&ud, *ptr)) == 1)
d136 1
a136 1
			if (more == 0)
d181 1
a181 1
	int			more;
d187 1
a187 1
		if (*ptr > 0x7f && utf8_open(&ud, *ptr)) {
d193 1
a193 1
			while ((more = utf8_append(&ud, *ptr)) == 1)
d197 1
a197 1
			if (more == 0) {
d239 1
a239 1
	int			 more;
d263 1
a263 1
		if (*ptr > 0x7f && utf8_open(&ud, *ptr)) {
d269 1
a269 1
			while ((more = utf8_append(&ud, *ptr)) == 1)
d273 1
a273 1
			if (more == 0) {
@


1.77
log
@Long overdue change to the way we store cells in the grid: now, instead
of storing a full grid_cell with UTF-8 data and everything, store a new
type grid_cell_entry. This can either be the cell itself (for ASCII
cells), or an offset into an extended array (per line) for UTF-8
data.

This avoid a large (8 byte) overhead on non-UTF-8 cells (by far the
majority for most users) without the complexity of the shadow array we
had before. Grid memory without any UTF-8 is about half.

The disadvantage that cells can no longer be modified in place and need
to be copied out of the grid and back but it turned out to be lot less
complicated than I expected.
@
text
@d1 1
a1 1
/* $OpenBSD: screen-write.c,v 1.76 2015/11/12 22:04:37 nicm Exp $ */
d118 1
d132 1
a132 1
			while (utf8_append(&ud, *ptr))
d136 2
a137 1
			size += ud.width;
d181 1
d193 1
a193 1
			while (utf8_append(&ud, *ptr))
d197 8
a204 5
			if (maxlen > 0 &&
			    size + ud.width > (size_t) maxlen) {
				while (size < (size_t) maxlen) {
					screen_write_putc(ctx, gc, ' ');
					size++;
d206 4
a209 1
				break;
a210 4
			size += ud.width;

			utf8_copy(&gc->data, &ud);
			screen_write_cell(ctx, gc);
d239 1
d269 1
a269 1
			while (utf8_append(&ud, *ptr))
d273 8
a280 5
			if (maxlen > 0 &&
			    size + ud.width > (size_t) maxlen) {
				while (size < (size_t) maxlen) {
					screen_write_putc(ctx, gc, ' ');
					size++;
d282 4
a285 1
				break;
a286 4
			size += ud.width;

			utf8_copy(&lgc.data, &ud);
			screen_write_cell(ctx, &lgc);
@


1.76
log
@Rename overly-long utf8data to ud throughout.
@
text
@d1 1
a1 1
/* $OpenBSD: screen-write.c,v 1.75 2015/11/12 11:09:11 nicm Exp $ */
d70 1
a70 1
	grid_cell_one(gc, ch);
d129 1
a129 1
			if (left < ud.size - 1)
d188 1
a188 1
			if (left < ud.size - 1)
d204 1
a204 1
			grid_cell_set(gc, &ud);
d261 1
a261 1
			if (left < ud.size - 1)
d277 1
a277 1
			grid_cell_set(&lgc, &ud);
d302 1
a302 2
	const struct grid_cell	*gc;
	struct utf8_data	 ud;
d326 2
a327 6
				if (xx >= gl->cellsize)
					gc = &grid_default_cell;
				else
					gc = &gl->celldata[xx];
				grid_cell_get(gc, &ud);
				screen_write_cell(ctx, gc);
d340 2
a341 2
screen_write_initctx(
    struct screen_write_ctx *ctx, struct tty_ctx *ttyctx, int save_last)
d345 1
a345 1
	const struct grid_cell	*gc;
d360 1
a360 1
	gc = &grid_default_cell;
d362 2
a363 2
		gc = grid_view_peek_cell(gd, screen_size_x(s) - xx, s->cy);
		if (!(gc->flags & GRID_FLAG_PADDING))
d367 1
a367 1
	memcpy(&ttyctx->last_cell, gc, sizeof ttyctx->last_cell);
d505 1
a505 1
	grid_cell_one(&gc, 'E');
d902 1
a902 2
	struct grid_cell 	 tmp_gc, *tmp_gcp;
	struct utf8_data	 ud;
d908 1
a908 1
	width = grid_cell_width(gc);
d925 1
a925 2
		grid_cell_get(gc, &ud);
		if (screen_write_combine(ctx, &ud) == 0) {
d960 5
a964 5
	for (xx = s->cx + 1; xx < s->cx + width; xx++) {
		tmp_gcp = grid_view_get_cell(gd, xx, s->cy);
		if (tmp_gcp != NULL)
			tmp_gcp->flags |= GRID_FLAG_PADDING;
	}
d986 1
a986 2
		grid_cell_get(gc, &ud);
		grid_cell_set(&tmp_gc, &ud);
d1006 1
a1006 2
	struct grid_cell	*gc;
	struct utf8_data	 ud1;
d1017 1
a1017 2
	gc = grid_view_get_cell(gd, s->cx - 1, s->cy);
	grid_cell_get(gc, &ud1);
d1020 1
a1020 1
	if (ud1.size + ud->size > sizeof ud1.data)
d1023 6
a1028 4
	/* Append the data and set the cell. */
	memcpy(ud1.data + ud1.size, ud->data, ud->size);
	ud1.size += ud->size;
	grid_cell_set(gc, &ud1);
d1047 1
a1047 1
	const struct grid_cell	*gc;
d1050 2
a1051 2
	gc = grid_view_peek_cell(gd, s->cx, s->cy);
	if (gc->flags & GRID_FLAG_PADDING) {
d1059 2
a1060 2
			gc = grid_view_peek_cell(gd, xx, s->cy);
			if (!(gc->flags & GRID_FLAG_PADDING))
d1075 2
a1076 2
		gc = grid_view_peek_cell(gd, xx, s->cy);
		if (!(gc->flags & GRID_FLAG_PADDING))
@


1.75
log
@Nuke the utf8 and status-utf8 options and make tmux only a UTF-8
terminal. We still support non-UTF-8 terminals outside tmux, but inside
it is always UTF-8 (as when the utf8 and status-utf8 options were on).
@
text
@d1 1
a1 1
/* $OpenBSD: screen-write.c,v 1.74 2015/09/14 13:22:02 nicm Exp $ */
d115 1
a115 1
	struct utf8_data	utf8data;
d125 1
a125 1
		if (*ptr > 0x7f && utf8_open(&utf8data, *ptr)) {
d129 1
a129 1
			if (left < utf8data.size - 1)
d131 1
a131 1
			while (utf8_append(&utf8data, *ptr))
d135 1
a135 1
			size += utf8data.width;
d176 1
a176 1
	struct utf8_data	utf8data;
d184 1
a184 1
		if (*ptr > 0x7f && utf8_open(&utf8data, *ptr)) {
d188 1
a188 1
			if (left < utf8data.size - 1)
d190 1
a190 1
			while (utf8_append(&utf8data, *ptr))
d195 1
a195 1
			    size + utf8data.width > (size_t) maxlen) {
d202 1
a202 1
			size += utf8data.width;
d204 1
a204 1
			grid_cell_set(gc, &utf8data);
d229 1
a229 1
	struct utf8_data	 utf8data;
d257 1
a257 1
		if (*ptr > 0x7f && utf8_open(&utf8data, *ptr)) {
d261 1
a261 1
			if (left < utf8data.size - 1)
d263 1
a263 1
			while (utf8_append(&utf8data, *ptr))
d268 1
a268 1
			    size + utf8data.width > (size_t) maxlen) {
d275 1
a275 1
			size += utf8data.width;
d277 1
a277 1
			grid_cell_set(&lgc, &utf8data);
@


1.74
log
@Remove some extra blank lines.
@
text
@d1 1
a1 1
/* $OpenBSD: screen-write.c,v 1.73 2015/07/13 13:28:50 nicm Exp $ */
d76 1
a76 1
screen_write_cstrlen(int utf8flag, const char *fmt, ...)
d101 1
a101 1
	size = screen_write_strlen(utf8flag, "%s", msg2);
d111 1
a111 1
screen_write_strlen(int utf8flag, const char *fmt, ...)
d125 1
a125 1
		if (utf8flag && *ptr > 0x7f && utf8_open(&utf8data, *ptr)) {
d137 2
a138 1
			size++;
d155 1
a155 1
	screen_write_vnputs(ctx, -1, gc, 0, fmt, ap);
d162 1
a162 1
    struct grid_cell *gc, int utf8flag, const char *fmt, ...)
d167 1
a167 1
	screen_write_vnputs(ctx, maxlen, gc, utf8flag, fmt, ap);
d173 1
a173 1
    struct grid_cell *gc, int utf8flag, const char *fmt, va_list ap)
d184 1
a184 1
		if (utf8flag && *ptr > 0x7f && utf8_open(&utf8data, *ptr)) {
d212 1
a212 1
			else {
d225 2
a226 2
screen_write_cnputs(struct screen_write_ctx *ctx,
    ssize_t maxlen, struct grid_cell *gc, int utf8flag, const char *fmt, ...)
d257 1
a257 1
		if (utf8flag && *ptr > 0x7f && utf8_open(&utf8data, *ptr)) {
d283 4
a286 2
			size++;
			screen_write_putc(ctx, &lgc, *ptr);
@


1.73
log
@Revert to marking lines as wrapped on newlines, fixes problems with
capturep -J.
@
text
@d1 1
a1 1
/* $OpenBSD: screen-write.c,v 1.72 2014/11/08 12:58:31 nicm Exp $ */
a47 1

@


1.72
log
@Two improvements to reflow from Balazs Kezes:

- Don't extend the line to full width on insert/delete character which
  means leaves extra spaces when reflowing.

- Only mark a line wrapped when the cursor actually goes off the end,
  not on newlines which can be used for positioning.
@
text
@d1 1
a1 1
/* $OpenBSD: screen-write.c,v 1.71 2014/10/20 23:57:14 nicm Exp $ */
d798 2
@


1.71
log
@Better format for printf format attributes.
@
text
@d1 1
a1 1
/* $OpenBSD: screen-write.c,v 1.70 2014/10/02 08:36:26 nicm Exp $ */
a797 2
	else
		gl->flags &= ~GRID_LINE_WRAPPED;
@


1.70
log
@Copy ACS characters as UTF-8, from Balazs Kezes.
@
text
@d1 1
a1 1
/* $OpenBSD: screen-write.c,v 1.69 2014/04/17 14:45:49 nicm Exp $ */
d28 2
a29 2
int	screen_write_combine(
	    struct screen_write_ctx *, const struct utf8_data *);
d33 2
a34 2
screen_write_start(
    struct screen_write_ctx *ctx, struct window_pane *wp, struct screen *s)
d76 1
a76 1
size_t printflike2
d111 1
a111 1
size_t printflike2
d148 3
a150 3
void printflike3
screen_write_puts(
    struct screen_write_ctx *ctx, struct grid_cell *gc, const char *fmt, ...)
d160 3
a162 3
void printflike5
screen_write_nputs(struct screen_write_ctx *ctx,
    ssize_t maxlen, struct grid_cell *gc, int utf8flag, const char *fmt, ...)
d224 1
a224 1
void printflike5
@


1.69
log
@Some more long lines.
@
text
@d1 1
a1 1
/* $OpenBSD: screen-write.c,v 1.68 2014/01/28 23:07:09 nicm Exp $ */
d993 2
@


1.68
log
@Allow replacing each of the many sets of separate foo-{fg,bg,attr}
options with a single foo-style option. For example:

    set -g status-fg yellow
    set -g status-bg red
    set -g status-attr blink

Becomes:

    set -g status-style fg=yellow,bg=red,blink

The -a flag to set can be used to add to rather than replace a style. So:

    set -g status-bg red

Becomes:

    set -ag status-style bg=red

Currently this is fully backwards compatible (all *-{fg,bg,attr} options
remain) but the plan is to deprecate them over time.

From Tiago Cunha.
@
text
@d1 1
a1 1
/* $OpenBSD: screen-write.c,v 1.67 2013/05/15 15:32:14 nicm Exp $ */
d68 2
a69 1
screen_write_putc(struct screen_write_ctx *ctx, struct grid_cell *gc, u_char ch)
@


1.67
log
@RIS should reset focus reporting, from Hayaki Saito.
@
text
@d1 1
a1 1
/* $OpenBSD: screen-write.c,v 1.66 2013/03/27 11:19:19 nicm Exp $ */
d251 1
a251 1
			screen_write_parsestyle(gc, &lgc, ptr);
a288 83
}

/* Parse an embedded style of the form "fg=colour,bg=colour,bright,...". */
void
screen_write_parsestyle(
    struct grid_cell *defgc, struct grid_cell *gc, const char *in)
{
	const char	delimiters[] = " ,";
	char		tmp[32];
	int		val;
	size_t		end;
	u_char		fg, bg, attr, flags;

	if (*in == '\0')
		return;
	if (strchr(delimiters, in[strlen(in) - 1]) != NULL)
		return;

	fg = gc->fg;
	bg = gc->bg;
	attr = gc->attr;
	flags = gc->flags;
	do {
		end = strcspn(in, delimiters);
		if (end > (sizeof tmp) - 1)
			return;
		memcpy(tmp, in, end);
		tmp[end] = '\0';

		if (strcasecmp(tmp, "default") == 0) {
			fg = defgc->fg;
			bg = defgc->bg;
			attr = defgc->attr;
			flags &= ~(GRID_FLAG_FG256|GRID_FLAG_BG256);
			flags |=
			    defgc->flags & (GRID_FLAG_FG256|GRID_FLAG_BG256);
		} else if (end > 3 && strncasecmp(tmp + 1, "g=", 2) == 0) {
			if ((val = colour_fromstring(tmp + 3)) == -1)
				return;
			if (*in == 'f' || *in == 'F') {
				if (val != 8) {
					if (val & 0x100) {
						flags |= GRID_FLAG_FG256;
						val &= ~0x100;
					} else
						flags &= ~GRID_FLAG_FG256;
					fg = val;
				} else {
					fg = defgc->fg;
					flags &= ~GRID_FLAG_FG256;
					flags |= defgc->flags & GRID_FLAG_FG256;
				}
			} else if (*in == 'b' || *in == 'B') {
				if (val != 8) {
					if (val & 0x100) {
						flags |= GRID_FLAG_BG256;
						val &= ~0x100;
					} else
						flags &= ~GRID_FLAG_BG256;
					bg = val;
				} else {
					bg = defgc->bg;
					flags &= ~GRID_FLAG_BG256;
					flags |= defgc->flags & GRID_FLAG_BG256;
				}
			} else
				return;
		} else if (end > 2 && strncasecmp(tmp, "no", 2) == 0) {
			if ((val = attributes_fromstring(tmp + 2)) == -1)
				return;
			attr &= ~val;
		} else {
			if ((val = attributes_fromstring(tmp)) == -1)
				return;
			attr |= val;
		}

		in += end + strspn(in + end, delimiters);
	} while (*in != '\0');
	gc->fg = fg;
	gc->bg = bg;
	gc->attr = attr;
	gc->flags = flags;
@


1.66
log
@Move the cursor back into the last column on CUU/CUD to match xterm
behaviour. From George Nachman.
@
text
@d1 1
a1 1
/* $OpenBSD: screen-write.c,v 1.65 2013/03/22 10:41:01 nicm Exp $ */
d59 1
a59 1
	s->mode &= ~(MODE_INSERT|MODE_KCURSOR|MODE_KKEYPAD);
@


1.65
log
@Unbreak line wrapping.
@
text
@d1 1
a1 1
/* $OpenBSD: screen-write.c,v 1.64 2013/03/22 10:36:54 nicm Exp $ */
d491 2
d517 2
@


1.64
log
@Implement DECAWM (SM/RM 7) using existing MODE_WRAP flag.
@
text
@d1 1
a1 1
/* $OpenBSD: screen-write.c,v 1.63 2013/03/22 10:33:50 nicm Exp $ */
d1056 1
a1056 1
	last = !!(s->mode & MODE_WRAP);
@


1.63
log
@Support the latest theory for mouse input, this is enabled/disabled with
SM/RM 1006 and is similar in style to SGR input: \033[<b;x;yM or
\033[b;x;ym. From Egmont Koblinger.
@
text
@d1 1
a1 1
/* $OpenBSD: screen-write.c,v 1.62 2013/03/22 10:31:22 nicm Exp $ */
d982 1
a982 1
	u_int		 	 width, xx;
d985 1
a985 1
	int			 insert = 0;
d1023 2
a1024 1
	}
d1032 2
a1033 3
	/* Sanity checks. */
	if (((s->mode & MODE_WRAP) && s->cx > screen_size_x(s) - width)
	    || s->cy > screen_size_y(s) - 1)
d1052 9
a1060 2
	/* Move the cursor. */
	s->cx += width;
@


1.62
log
@No more lint means no more ARGSUSED.
@
text
@d1 1
a1 1
/* $OpenBSD: screen-write.c,v 1.61 2013/03/21 18:47:56 nicm Exp $ */
d58 3
a60 1
	s->mode &= ~(MODE_INSERT|MODE_KCURSOR|MODE_KKEYPAD|ALL_MOUSE_MODES);
@


1.61
log
@Instead of loads of little screen_write_*_on and off functions which
just change mode flags, just have screen_write_mode_set and
screen_write_mode_clear.
@
text
@d1 1
a1 1
/* $OpenBSD: screen-write.c,v 1.60 2013/01/18 02:16:21 nicm Exp $ */
a43 1
/* ARGSUSED */
@


1.60
log
@Rather than having two grids for each pane, one for ASCII and one for
UTF-8, collapse the two together. Simplifies the code at the expense of
more memory (which can probably be reduced again later).
@
text
@d1 1
a1 1
/* $OpenBSD: screen-write.c,v 1.59 2013/01/15 23:18:55 nicm Exp $ */
d55 1
a55 3
	screen_reset_tabs(ctx->s);

	screen_write_scrollregion(ctx, 0, screen_size_y(ctx->s) - 1);
d57 3
a59 4
	screen_write_insertmode(ctx, 0);
	screen_write_kcursormode(ctx, 0);
	screen_write_kkeypadmode(ctx, 0);
	screen_write_mousemode_off(ctx);
d454 18
a822 12
/* Set cursor mode. */
void
screen_write_cursormode(struct screen_write_ctx *ctx, int state)
{
	struct screen	*s = ctx->s;

	if (state)
		s->mode |= MODE_CURSOR;
	else
		s->mode &= ~MODE_CURSOR;
}

a861 55
/* Set insert mode. */
void
screen_write_insertmode(struct screen_write_ctx *ctx, int state)
{
	struct screen	*s = ctx->s;

	if (state)
		s->mode |= MODE_INSERT;
	else
		s->mode &= ~MODE_INSERT;
}

/* Set UTF-8 mouse mode.  */
void
screen_write_utf8mousemode(struct screen_write_ctx *ctx, int state)
{
	struct screen	*s = ctx->s;

	if (state)
		s->mode |= MODE_MOUSE_UTF8;
	else
		s->mode &= ~MODE_MOUSE_UTF8;
}

/* Set mouse mode off. */
void
screen_write_mousemode_off(struct screen_write_ctx *ctx)
{
	struct screen	*s = ctx->s;

	s->mode &= ~ALL_MOUSE_MODES;
}

/* Set mouse mode on. */
void
screen_write_mousemode_on(struct screen_write_ctx *ctx, int mode)
{
	struct screen	*s = ctx->s;

	s->mode &= ~ALL_MOUSE_MODES;
	s->mode |= mode;
}

/* Set bracketed paste mode. */
void
screen_write_bracketpaste(struct screen_write_ctx *ctx, int state)
{
	struct screen	*s = ctx->s;

	if (state)
		s->mode |= MODE_BRACKETPASTE;
	else
		s->mode &= ~MODE_BRACKETPASTE;
}

a893 24
}

/* Set keypad cursor keys mode. */
void
screen_write_kcursormode(struct screen_write_ctx *ctx, int state)
{
	struct screen	*s = ctx->s;

	if (state)
		s->mode |= MODE_KCURSOR;
	else
		s->mode &= ~MODE_KCURSOR;
}

/* Set keypad number keys mode. */
void
screen_write_kkeypadmode(struct screen_write_ctx *ctx, int state)
{
	struct screen	*s = ctx->s;

	if (state)
		s->mode |= MODE_KKEYPAD;
	else
		s->mode &= ~MODE_KKEYPAD;
@


1.59
log
@Implement ECH (erase character, CSI X). Reported by Christian Neukirchen.
@
text
@d1 1
a1 1
/* $OpenBSD: screen-write.c,v 1.58 2012/12/08 17:05:57 nicm Exp $ */
d70 1
a70 2
screen_write_putc(
    struct screen_write_ctx *ctx, struct grid_cell *gc, u_char ch)
d72 2
a73 2
	gc->data = ch;
	screen_write_cell(ctx, gc, NULL);
d205 2
a206 3
			gc->flags |= GRID_FLAG_UTF8;
			screen_write_cell(ctx, gc, &utf8data);
			gc->flags &= ~GRID_FLAG_UTF8;
d278 2
a279 3
			lgc.flags |= GRID_FLAG_UTF8;
			screen_write_cell(ctx, &lgc, &utf8data);
			lgc.flags &= ~GRID_FLAG_UTF8;
d385 1
a385 2
	const struct grid_utf8	*gu;
	struct utf8_data	 utf8data;
d413 2
a414 10
				if (!(gc->flags & GRID_FLAG_UTF8)) {
					screen_write_cell(ctx, gc, NULL);
					continue;
				}
				/* Reinject the UTF-8 sequence. */
				gu = &gl->utf8data[xx];
				utf8data.size = grid_utf8_copy(
				    gu, utf8data.data, sizeof utf8data.data);
				utf8data.width = gu->width;
				screen_write_cell(ctx, gc, &utf8data);
a432 1
	const struct grid_utf8	*gu;
a454 4
	if (gc->flags & GRID_FLAG_UTF8) {
		gu = grid_view_peek_utf8(gd, screen_size_x(s) - xx, s->cy);
		memcpy(&ttyctx->last_utf8, gu, sizeof ttyctx->last_utf8);
	}
d570 1
a570 1
	gc.data = 'E';
d1052 1
a1052 2
screen_write_cell(struct screen_write_ctx *ctx,
    const struct grid_cell *gc, const struct utf8_data *utf8data)
a1056 1
	struct grid_utf8	 gu;
d1059 1
d1065 1
a1065 6

	/* Find character width. */
	if (gc->flags & GRID_FLAG_UTF8)
		width = utf8data->width;
	else
		width = 1;
d1082 2
a1083 1
		if (screen_write_combine(ctx, utf8data) == 0) {
a1125 5
	if (gc->flags & GRID_FLAG_UTF8) {
		/* Construct UTF-8 and write it. */
		grid_utf8_set(&gu, utf8data);
		grid_view_set_utf8(gd, s->cx, s->cy, &gu);
	}
a1134 1
	ttyctx.utf8 = &gu;
d1137 3
a1139 3
		tmp_gc.data = gc->data;
		tmp_gc.flags = gc->flags &
		    ~(GRID_FLAG_FG256|GRID_FLAG_BG256);
d1152 1
a1152 2
screen_write_combine(
    struct screen_write_ctx *ctx, const struct utf8_data *utf8data)
d1157 1
a1157 2
	struct grid_utf8	*gu, tmp_gu;
	u_int			 i;
d1163 2
a1164 2
	/* Empty utf8data is out. */
	if (utf8data->size == 0)
d1167 1
a1167 1
	/* Retrieve the previous cell and convert to UTF-8 if not already. */
d1169 1
a1169 4
	if (!(gc->flags & GRID_FLAG_UTF8)) {
		tmp_gu.data[0] = gc->data;
		tmp_gu.data[1] = 0xff;
		tmp_gu.width = 1;
d1171 3
a1173 3
		grid_view_set_utf8(gd, s->cx - 1, s->cy, &tmp_gu);
		gc->flags |= GRID_FLAG_UTF8;
	}
d1175 4
a1178 15
	/* Append the current cell. */
	gu = grid_view_get_utf8(gd, s->cx - 1, s->cy);
	if (grid_utf8_append(gu, utf8data) != 0) {
		/* Failed: scrap this character and replace with underscores. */
		if (gu->width == 1) {
			gc->data = '_';
			gc->flags &= ~GRID_FLAG_UTF8;
		} else {
			for (i = 0; i < gu->width && i != sizeof gu->data; i++)
				gu->data[i] = '_';
			if (i != sizeof gu->data)
				gu->data[i] = 0xff;
			gu->width = i;
		}
	}
@


1.58
log
@Handle resetting 256-colours properly when parsing #[default],
#[fg=default] and #[bg=default] styles.
@
text
@d1 1
a1 1
/* $OpenBSD: screen-write.c,v 1.57 2012/09/24 12:53:55 nicm Exp $ */
d650 24
@


1.57
log
@Use ACS characters for choose-tree arrows based on diff from Romain
Francoise.
@
text
@d1 1
a1 1
/* $OpenBSD: screen-write.c,v 1.56 2012/07/10 11:53:01 nicm Exp $ */
d327 3
d341 1
a341 1
				} else
d343 3
d354 1
a354 1
				} else
d356 3
@


1.56
log
@xfree is not particularly helpful, remove it. From Thomas Adam.
@
text
@d1 1
a1 1
/* $OpenBSD: screen-write.c,v 1.55 2012/03/17 17:36:03 nicm Exp $ */
d213 6
a218 2
			size++;
			screen_write_putc(ctx, gc, *ptr);
@


1.55
log
@Revert screen-write.c r1.54 and fix the bug properly. After wrapping a
line in a pane, the cursor needs to move to the next line unless it
scrolled.
@
text
@d1 1
a1 1
/* $OpenBSD: screen-write.c,v 1.54 2012/03/14 23:29:07 nicm Exp $ */
d21 1
d106 2
a107 2
	xfree(msg);
	xfree(msg2);
d145 1
a145 1
	xfree(msg);
d219 1
a219 1
	xfree(msg);
d289 1
a289 1
	xfree(msg);
@


1.54
log
@Store context off before moving the cursor when wrapping, to fix long
standing bug drawing over the status line.
@
text
@d1 1
a1 1
/* $OpenBSD: screen-write.c,v 1.53 2012/03/03 09:43:22 nicm Exp $ */
d1074 3
d1078 1
a1078 1
	if (s->mode & MODE_INSERT && s->cx <= screen_size_x(s) - width) {
a1088 3

	/* Initialise the redraw context, saving the last cell. */
	screen_write_initctx(ctx, &ttyctx, 1);
@


1.53
log
@Support "bracketed paste" mode. This adds a -p flag to paste-buffer - if
this is used and the application has requested bracketed pastes, then
tmux surrounds the pasted text by \033[200~ and \033[201~. Applications
like vim can (apparently) use this to avoid, for example, indenting the
text. From Ailin Nemui.
@
text
@d1 1
a1 1
/* $OpenBSD: screen-write.c,v 1.52 2012/01/21 08:10:21 nicm Exp $ */
a1073 3
	/* Initialise the redraw context, saving the last cell. */
	screen_write_initctx(ctx, &ttyctx, 1);

d1086 3
@


1.52
log
@Add a -R flag to send-keys to reset the terminal. Written ages ago and
Suggested by someone, I forget who.
@
text
@d1 1
a1 1
/* $OpenBSD: screen-write.c,v 1.51 2011/10/23 10:16:14 nicm Exp $ */
d879 12
@


1.51
log
@Support for \e[3J to clear the history. Also send the corresponding
terminfo code (E3) before locking.
@
text
@d1 1
a1 1
/* $OpenBSD: screen-write.c,v 1.50 2011/05/18 20:24:29 nicm Exp $ */
d47 18
@


1.50
log
@Support setting the xterm clipboard when copying from copy mode using
the xterm escape sequence for the purpose (if xterm is configured to
allow it).

Written by and much discussed Ailin Nemui, guidance on
xterm/termcap/terminfo from Thomas Dickey.
@
text
@d1 1
a1 1
/* $OpenBSD: screen-write.c,v 1.49 2011/04/17 19:21:19 nicm Exp $ */
d986 11
@


1.49
log
@Fix character position check, from Tiago Resende.
@
text
@d1 1
a1 1
/* $OpenBSD: screen-write.c,v 1.48 2011/03/26 19:07:33 nicm Exp $ */
d1195 12
@


1.48
log
@Fix to properly wrap wide characters, from Micah Cowan.
@
text
@d1 1
a1 1
/* $OpenBSD: screen-write.c,v 1.47 2011/03/07 23:46:27 nicm Exp $ */
d1051 1
a1051 1
	    || s->cy > screen_size_y(s) - width)
@


1.47
log
@Support passing through escape sequences to the underlying terminal by
using DCS with a "tmux;" prefix. Escape characters in the sequences must
be doubled. For example:

$ printf '\033Ptmux;\033\033]12;red\007\033\\'

Will pass \033]12;red\007 to the terminal (and change the cursor colour
in xterm). From Kevin Goodsell.
@
text
@d1 1
a1 1
/* $OpenBSD: screen-write.c,v 1.46 2011/01/25 23:40:26 nicm Exp $ */
d1015 4
a1018 2
	if (width > 1 && (width > screen_size_x(s) ||
	    (s->cx != screen_size_x(s) && s->cx > screen_size_x(s) - width)))
d1050 2
a1051 2
	if (((s->mode & MODE_WRAP) && s->cx > screen_size_x(s) - 1)
	    || s->cy > screen_size_y(s) - 1)
@


1.46
log
@When clearing the entire screen, clear lines that are used into the
history like xterm does. Requested ages ago by someone I've forgotten.
@
text
@d1 1
a1 1
/* $OpenBSD: screen-write.c,v 1.45 2011/01/03 23:35:21 nicm Exp $ */
d1193 12
@


1.45
log
@Support for UTF-8 mouse input (\033[1005h). This was added in xterm 262
and supports larger terminals than the older way.

If the new mouse-utf8 option is on, UTF-8 mouse input is enabled for all
UTF-8 terminals. The option defaults to on if LANG etc are set in the
same manner as the utf8 option.

With help and based on code from hsim at gmx.li.
@
text
@d1 1
a1 1
/* $OpenBSD: screen-write.c,v 1.44 2010/12/29 21:49:06 nicm Exp $ */
d934 8
a941 3
	if (s->cx <= sx - 1)
		grid_view_clear(s->grid, s->cx, s->cy, sx - s->cx, 1);
	grid_view_clear(s->grid, 0, s->cy + 1, sx, sy - (s->cy + 1));
d977 7
a983 1
	grid_view_clear(s->grid, 0, 0, screen_size_x(s), screen_size_y(s));
@


1.44
log
@Support all four of the xterm mouse modes. Based on a diff from hsim at
gmx.li.
@
text
@d1 1
a1 1
/* $OpenBSD: screen-write.c,v 1.43 2010/06/21 00:11:12 nicm Exp $ */
d830 12
@


1.43
log
@Ensure we overwrite UTF-8 wide characters properly, and never overwrite
characters we weren't overlapping.  Fixes "disappearing wide characters"
glitch. From Micah Cowan.
@
text
@d1 1
a1 1
/* $OpenBSD: screen-write.c,v 1.42 2010/04/06 21:35:44 nicm Exp $ */
d832 1
a832 1
/* Set mouse mode.  */
d834 1
a834 1
screen_write_mousemode(struct screen_write_ctx *ctx, int state)
d838 11
a848 4
	if (state)
		s->mode |= MODE_MOUSE;
	else
		s->mode &= ~MODE_MOUSE;
@


1.42
log
@Merge copy mode and output mode, dropping the latter. Idea and code from
Micah Cowan.
@
text
@d1 1
a1 1
/* $OpenBSD: screen-write.c,v 1.41 2009/12/03 22:50:10 nicm Exp $ */
d26 1
a26 1
void	screen_write_overwrite(struct screen_write_ctx *);
d1023 1
a1023 1
	screen_write_overwrite(ctx);
d1126 1
a1126 1
screen_write_overwrite(struct screen_write_ctx *ctx)
a1130 1
	const struct grid_utf8	*gu;
d1150 1
d1152 10
a1161 24
		/* Overwrite following padding cells. */
		xx = s->cx;
		while (++xx < screen_size_x(s)) {
			gc = grid_view_peek_cell(gd, xx, s->cy);
			if (!(gc->flags & GRID_FLAG_PADDING))
				break;
			grid_view_set_cell(gd, xx, s->cy, &grid_default_cell);
		}
	} else if (gc->flags & GRID_FLAG_UTF8) {
		gu = grid_view_peek_utf8(gd, s->cx, s->cy);
		if (gu->width > 1) {
			/*
			 * An UTF-8 wide cell; overwrite following padding
			 * cells only.
			 */
			xx = s->cx;
			while (++xx < screen_size_x(s)) {
				gc = grid_view_peek_cell(gd, xx, s->cy);
				if (!(gc->flags & GRID_FLAG_PADDING))
					break;
				grid_view_set_cell(
				    gd, xx, s->cy, &grid_default_cell);
			}
		}
@


1.41
log
@Massive spaces->tabs and trailing whitespace cleanup, hopefully for the last
time now I've configured emacs to make them displayed in really annoying
colours...
@
text
@d1 1
a1 1
/* $OpenBSD: screen-write.c,v 1.40 2009/11/26 21:37:13 nicm Exp $ */
d1012 1
a1012 1
	if (s->cx > screen_size_x(s) - width) {
d1018 2
a1019 1
	if (s->cx > screen_size_x(s) - 1 || s->cy > screen_size_y(s) - 1)
@


1.40
log
@Remove a couple of unused arguments where possible, and add /* ARGSUSED */ to
the rest to reduce lint output.
@
text
@d1 1
a1 1
/* $OpenBSD: screen-write.c,v 1.39 2009/11/18 17:02:17 nicm Exp $ */
d186 1
a186 1
			
d379 1
a379 1
			
d649 1
a649 1
	
d685 1
a685 1
	
d731 1
a731 1
 	tty_write(tty_cmd_clearendofline, &ttyctx);
d866 1
a866 1
 	tty_write(tty_cmd_linefeed, &ttyctx);
d991 1
a991 1
	 * there is space. 
@


1.39
log
@Cleanup by moving various (mostly horrible) little bits handling UTF-8 grid
data into functions in a new file, grid-utf8.c, and use sizeof intead of
UTF8_DATA.

Also nuke trailing whitespace from tmux.1, reminded by jmc.
@
text
@d1 1
a1 1
/* $OpenBSD: screen-write.c,v 1.38 2009/11/16 13:40:45 nicm Exp $ */
d43 1
@


1.38
log
@A screen can be one cell wide; don't crash if that is the case.
@
text
@d1 1
a1 1
/* $OpenBSD: screen-write.c,v 1.37 2009/11/11 18:53:21 nicm Exp $ */
d357 1
a357 1
	u_int		 	 xx, yy, cx, cy, ax, bx, i;
d384 3
a386 11
				if (gc->flags & GRID_FLAG_UTF8) {
					gu = &gl->utf8data[xx]; 
					memcpy(utf8data.data,
					    gu->data, sizeof utf8data.data);
					utf8data.width = gu->width;
					utf8data.size = 0;
					for (i = 0; i < UTF8_SIZE; i++) {
						if (gu->data[i] == 0xff)
							break;
						utf8data.size++;
					}
d388 5
d1037 1
a1037 7
		gu.width = utf8data->width;
		memset(gu.data, 0xff, sizeof gu.data);
		if (utf8data->size == 0)
			fatalx("UTF-8 data empty");
		if (utf8data->size > sizeof gu.data)
			fatalx("UTF-8 data overflow");
		memcpy(gu.data, utf8data->data, utf8data->size);
d1074 1
a1074 1
	u_int			 i, old_size;
d1087 2
a1088 2
		memset(&tmp_gu.data, 0xff, sizeof tmp_gu.data);
		*tmp_gu.data = gc->data;
d1095 1
a1095 1
	/* Get the previous cell's UTF-8 data and its size. */
d1097 12
a1108 13
	for (old_size = 0; old_size < UTF8_SIZE; old_size++) {
		if (gu->data[old_size] == 0xff)
			break;
	}

	/* If there isn't space, scrap this character. */
	if (old_size + utf8data->size > UTF8_SIZE) {
		for (i = 0; i < gu->width && i != UTF8_SIZE; i++)
			gu->data[i] = '_';
		if (i != UTF8_SIZE)
			gu->data[i] = 0xff;
		gu->width = i;
		return (0);
a1110 4
	/* Otherwise save the character. */
	memcpy(gu->data + old_size, utf8data->data, utf8data->size);
	if (old_size + utf8data->size != UTF8_SIZE)
		gu->data[old_size + utf8data->size] = 0xff;
@


1.37
log
@Add an explicit zero-length check for UTF-8 input data, prompted by a report
from parfait via deraadt.

While here, add a statement to set the width when filling with _s if not enough
space (width should never be high enough at the moment anyway), and wrap some
long lines.
@
text
@d1 1
a1 1
/* $OpenBSD: screen-write.c,v 1.36 2009/10/20 19:18:28 nicm Exp $ */
d430 2
a431 2
	gc = NULL;
	for (xx = 1; xx < screen_size_x(s); xx++) {
@


1.36
log
@Try to reduce the UTF-8 mess.

Get rid of passing around u_char[4]s and define a struct utf8_data which has
character data, size (sequence length) and width. Move UTF-8 character
collection into two functions utf8_open/utf8_append in utf8.c which fill in
this struct and use these functions from input.c and the various functions in
screen-write.c.

Space for rather more data than is necessary for one UTF-8 sequence is in the
utf8_data struct because screen_write_copy is still nasty and needs to reinject
the character (after combining) into screen_write_cell.
@
text
@d1 1
a1 1
/* $OpenBSD: screen-write.c,v 1.35 2009/10/20 17:33:33 nicm Exp $ */
d1042 2
d1089 4
d1117 1
d1176 2
a1177 1
			 * An UTF-8 wide cell; overwrite following padding cells only.
d1184 2
a1185 1
				grid_view_set_cell(gd, xx, s->cy, &grid_default_cell);
@


1.35
log
@UTF-8 combined character fixes.

Thai can have treble combinations (1 x width=1 then 2 x width=0) so bump the
UTF-8 cell data size to 9 and alter the code to allow this.

Also break off the combining code into a separate function, handle any further
combining beyond the buffer size by replacing the character with _s, and when
redrawing the UTF-8 character don't assume the first part has just been
printed, redraw the entire line.
@
text
@d1 1
a1 1
/* $OpenBSD: screen-write.c,v 1.34 2009/10/20 16:32:23 nicm Exp $ */
d27 2
a28 1
int	screen_write_combine(struct screen_write_ctx *, u_char *);
d96 5
a100 4
	va_list	ap;
	char   *msg;
	u_char *ptr, utf8buf[4];
	size_t	left, size = 0;
d108 2
a109 2
		if (utf8flag && *ptr > 0x7f) {
			memset(utf8buf, 0xff, sizeof utf8buf);
d112 3
a114 11
			if (*ptr >= 0xc2 && *ptr <= 0xdf && left >= 2) {
				memcpy(utf8buf, ptr, 2);
				ptr += 2;
			} else if (*ptr >= 0xe0 && *ptr <= 0xef && left >= 3) {
				memcpy(utf8buf, ptr, 3);
				ptr += 3;
			} else if (*ptr >= 0xf0 && *ptr <= 0xf4 && left >= 4) {
				memcpy(utf8buf, ptr, 4);
				ptr += 4;
			} else {
				*utf8buf = *ptr;
d116 3
a118 2
			}
			size += utf8_width(utf8buf);
d157 4
a160 4
	char   *msg;
	u_char *ptr, utf8buf[4];
	size_t	left, size = 0;
	int	width;
d166 2
a167 2
		if (utf8flag && *ptr > 0x7f) {
			memset(utf8buf, 0xff, sizeof utf8buf);
d170 3
a172 11
			if (*ptr >= 0xc2 && *ptr <= 0xdf && left >= 2) {
				memcpy(utf8buf, ptr, 2);
				ptr += 2;
			} else if (*ptr >= 0xe0 && *ptr <= 0xef && left >= 3) {
				memcpy(utf8buf, ptr, 3);
				ptr += 3;
			} else if (*ptr >= 0xf0 && *ptr <= 0xf4 && left >= 4) {
				memcpy(utf8buf, ptr, 4);
				ptr += 4;
			} else {
				*utf8buf = *ptr;
d174 1
a174 1
			}
d176 2
a177 2
			width = utf8_width(utf8buf);
			if (maxlen > 0 && size + width > (size_t) maxlen) {
d184 2
a185 2
			size += width;

d187 1
a187 1
			screen_write_cell(ctx, gc, utf8buf);
a188 1

d208 1
d211 1
a211 1
	u_char 			*ptr, *last, utf8buf[4];
a212 1
	int			 width;
d236 2
a237 2
		if (utf8flag && *ptr > 0x7f) {
			memset(utf8buf, 0xff, sizeof utf8buf);
d240 3
a242 11
			if (*ptr >= 0xc2 && *ptr <= 0xdf && left >= 2) {
				memcpy(utf8buf, ptr, 2);
				ptr += 2;
			} else if (*ptr >= 0xe0 && *ptr <= 0xef && left >= 3) {
				memcpy(utf8buf, ptr, 3);
				ptr += 3;
			} else if (*ptr >= 0xf0 && *ptr <= 0xf4 && left >= 4) {
				memcpy(utf8buf, ptr, 4);
				ptr += 4;
			} else {
				*utf8buf = *ptr;
d244 1
a244 1
			}
d246 2
a247 2
			width = utf8_width(utf8buf);
			if (maxlen > 0 && size + width > (size_t) maxlen) {
d254 1
a254 1
			size += width;
d257 1
a257 1
			screen_write_cell(ctx, &lgc, utf8buf);
a258 1

d355 3
a357 2
	u_char			*udata;
	u_int		 	 xx, yy, cx, cy, ax, bx;
d378 1
a379 1
				udata = NULL;
d382 1
a382 1
				else {
d384 11
a394 2
					if (gc->flags & GRID_FLAG_UTF8)
						udata = gl->utf8data[xx].data;
d396 1
a396 1
				screen_write_cell(ctx, gc, udata);
d401 1
a401 1
 			screen_write_clearline(ctx);
d962 2
a963 2
screen_write_cell(
    struct screen_write_ctx *ctx, const struct grid_cell *gc, u_char *udata)
d978 3
a980 6
	if (gc->flags & GRID_FLAG_UTF8) {
		width = utf8_width(udata);

		gu.width = width;
		memcpy(&gu.data, udata, sizeof gu.data);
 	} else
d996 1
a996 1
		if (screen_write_combine(ctx, udata) == 0) {
a1014 5
		/* 
		 * Don't update the terminal now, just update the screen and
		 * leave the cursor to scroll naturally, unless this is only
		 * part of the screen width.
		 */
d1038 7
a1044 1
	if (gc->flags & GRID_FLAG_UTF8)
d1046 1
d1074 2
a1075 1
screen_write_combine(struct screen_write_ctx *ctx, u_char *udata)
d1081 1
a1081 1
	u_int			 i, old_size, new_size;
d1098 1
a1098 1
	/* Get the previous cell's UTF-8 data. */
a1099 8

	/* Find the new size. */
	for (new_size = 0; new_size < UTF8_SIZE; new_size++) {
		if (udata[new_size] == 0xff)
			break;
	}

	/* And the old size. */
d1106 1
a1106 1
	if (old_size + new_size > UTF8_SIZE) {
d1115 3
a1117 3
	memcpy(gu->data + old_size, udata, new_size);
	if (old_size + new_size != UTF8_SIZE)
		gu->data[old_size + new_size] = 0xff;
@


1.34
log
@Move the check for whether to force a line wrapper lower down into the tty code
where it has access to the tty width, which is what should have been checked.
@
text
@d1 1
a1 1
/* $OpenBSD: screen-write.c,v 1.33 2009/10/17 08:35:38 nicm Exp $ */
d27 1
d981 2
a982 2
	struct grid_utf8	 gu, *tmp_gu;
	u_int		 	 width, xx, i;
d1007 4
a1010 1
	/* If the width is zero, combine onto the previous character. */
d1012 3
a1014 9
		if (s->cx == 0)
			return;
		tmp_gcp = grid_view_get_cell(gd, s->cx - 1, s->cy);
		if (!(tmp_gcp->flags & GRID_FLAG_UTF8)) {
			tmp_gcp->flags |= GRID_FLAG_UTF8;
			memset(&gu.data, 0xff, sizeof gu.data);
			*gu.data = tmp_gcp->data;
			gu.width = 1;
			grid_view_set_utf8(gd, s->cx - 1, s->cy, &gu);
a1015 16
		tmp_gu = grid_view_get_utf8(gd, s->cx - 1, s->cy);

		for (i = 0; i < UTF8_SIZE; i++) {
			if (tmp_gu->data[i] == 0xff)
				break;
		}
		memcpy(tmp_gu->data + i, udata, UTF8_SIZE - i);

		/*
		 * Assume the previous character has just been input. 
		 * XXX There is no guarantee this is true, need to redraw
		 * entire line.
		 */
		screen_write_initctx(ctx, &ttyctx, 0);
		ttyctx.ptr = udata;
		tty_write(tty_cmd_utf8character, &ttyctx);
d1084 56
@


1.33
log
@Always move the cursor position on !xenl terminals, since there is no invisible
last cursor position.

Also nuke an unused variable.
@
text
@d1 1
a1 1
/* $OpenBSD: screen-write.c,v 1.32 2009/10/17 08:32:18 nicm Exp $ */
d858 1
a858 4
/*
 * Line feed the screen only (don't update the tty). Used for printing single
 * characters, where might want to let the scroll happen naturally.
 */
d860 1
a860 1
screen_write_linefeedscreen(struct screen_write_ctx *ctx, int wrapped)
d864 3
a877 11
}

/* Line feed (down with scroll). */
void
screen_write_linefeed(struct screen_write_ctx *ctx, int wrapped)
{
	struct tty_ctx	 ttyctx;

	screen_write_initctx(ctx, &ttyctx, 0);

	screen_write_linefeedscreen(ctx, wrapped);
d879 1
a977 1
	struct window_pane	*wp = ctx->wp;
d1054 1
a1054 4
		if (wp->xoff != 0 || wp->sx != screen_size_x(s))
			screen_write_linefeed(ctx, 1);
		else
			screen_write_linefeedscreen(ctx, 1);
@


1.32
log
@Don't print wide characters at screen width - 1. Matches uterm behaviour and
is probably a better idea anyway.
@
text
@d1 1
a1 1
/* $OpenBSD: screen-write.c,v 1.31 2009/10/17 08:24:46 nicm Exp $ */
d993 1
a993 1
	struct grid_cell 	 tmp_gc, tmp_gc2, *tmp_gcp;
d1104 3
a1106 3
		memcpy(&tmp_gc2, &s->sel.cell, sizeof tmp_gc2);
		tmp_gc2.data = gc->data;
		tmp_gc2.flags = gc->flags &
d1108 1
a1108 1
		tmp_gc2.flags |= s->sel.cell.flags &
d1110 1
a1110 1
		ttyctx.cell = &tmp_gc2;
@


1.31
log
@Instead of having a complicated check to see if the cursor is in the last
position to avoid an explicit wrap, actually move it there.

Some UTF-8 fixes to come.
@
text
@d1 1
a1 1
/* $OpenBSD: screen-write.c,v 1.30 2009/10/12 17:19:47 nicm Exp $ */
d1009 8
a1045 8
	}

	/* If the character is wider than the screen, don't print it. */
	if (width > screen_size_x(s)) {
		memcpy(&tmp_gc, gc, sizeof tmp_gc);
		tmp_gc.data = '_';
		width = 1;
		gc = &tmp_gc;
@


1.30
log
@When drawing lines that have wrapped naturally, don't force a newline but
permit them to wrap naturally again. This allows terminals that use this to
guess where lines start and end for eg mouse selecting (like xterm) to work
correctly.

This was another long-standing issue raised by several people over the last
while.

Thanks to martynas@@ for much testing. This was not trivial to get right so
bringing it in for wider testing and adn to fix any further glitches in-tree.
@
text
@d1 1
a1 1
/* $OpenBSD: screen-write.c,v 1.29 2009/10/12 16:59:55 nicm Exp $ */
d25 1
a25 1
void	screen_write_initctx(struct screen_write_ctx *, struct tty_ctx *);
d421 2
a422 1
screen_write_initctx(struct screen_write_ctx *ctx, struct tty_ctx *ttyctx)
d424 5
a428 1
	struct screen	*s = ctx->s;
d437 17
d566 1
a566 1
	screen_write_initctx(ctx, &ttyctx);
d601 1
a601 1
	screen_write_initctx(ctx, &ttyctx);
d625 1
a625 1
	screen_write_initctx(ctx, &ttyctx);
d650 1
a650 1
		screen_write_initctx(ctx, &ttyctx);
d664 1
a664 1
	screen_write_initctx(ctx, &ttyctx);
d691 1
a691 1
		screen_write_initctx(ctx, &ttyctx);
d705 1
a705 1
	screen_write_initctx(ctx, &ttyctx);
d723 1
a723 1
	screen_write_initctx(ctx, &ttyctx);
d738 1
a738 1
	screen_write_initctx(ctx, &ttyctx);
d756 1
a756 1
	screen_write_initctx(ctx, &ttyctx);
d802 1
a802 1
	screen_write_initctx(ctx, &ttyctx);
d886 1
a886 1
	screen_write_initctx(ctx, &ttyctx);
d934 1
a934 1
	screen_write_initctx(ctx, &ttyctx);
d954 1
a954 1
	screen_write_initctx(ctx, &ttyctx);
d975 1
a975 1
	screen_write_initctx(ctx, &ttyctx);
d1029 6
a1034 2
		/* Assume the previous character has just been input. */
		screen_write_initctx(ctx, &ttyctx);
d1048 3
a1094 1
	screen_write_initctx(ctx, &ttyctx);
@


1.29
log
@When backspace is received at the beginning of a line and the previous line was
wrapped, move the cursor back up to the end of the previous line.

Another one of the forgotten persons requested this quite a while ago (I need
to start noting names on todo items...) when it was quite hard to
implement. Now it is easy and I don't see it can do any harm, so hey presto...
@
text
@d1 1
a1 1
/* $OpenBSD: screen-write.c,v 1.28 2009/10/12 16:33:39 nicm Exp $ */
d836 4
a839 1
/* Line feed (down with scroll). */
d841 1
a841 1
screen_write_linefeed(struct screen_write_ctx *ctx, int wrapped)
a844 3
	struct tty_ctx		 ttyctx;

	screen_write_initctx(ctx, &ttyctx);
d856 11
d966 1
d1031 10
a1040 2
		screen_write_carriagereturn(ctx);
		screen_write_linefeed(ctx, 1);
@


1.28
log
@Wrap a couple of long lines.
@
text
@d1 1
a1 1
/* $OpenBSD: screen-write.c,v 1.27 2009/10/12 11:08:02 nicm Exp $ */
d516 19
d558 1
@


1.27
log
@Permit attributes to be turned off in #[] by prefixing with "no", for example
"noblink".
@
text
@d1 1
a1 1
/* $OpenBSD: screen-write.c,v 1.26 2009/09/15 15:14:09 nicm Exp $ */
d1038 4
a1041 2
		tmp_gc2.flags = gc->flags & ~(GRID_FLAG_FG256|GRID_FLAG_BG256);
		tmp_gc2.flags |= s->sel.cell.flags & (GRID_FLAG_FG256|GRID_FLAG_BG256);
@


1.26
log
@Stick line length to what is actually used (removing an optimization that
allowed it to be bigger), and use clear line/EOL sequences rather than spaces
in copy/scroll mode.

This fixes xterm copy/paste from tmux which treats trailing spaces differently
from clearing a line with the escape sequences. Reported by martynas@@.
@
text
@d1 1
a1 1
/* $OpenBSD: screen-write.c,v 1.25 2009/09/10 17:16:24 nicm Exp $ */
d350 4
@


1.25
log
@Permit options such as status-bg to be configured using the entire 256 colour
palette by setting "colour0" to "colour255".
@
text
@d1 1
a1 1
/* $OpenBSD: screen-write.c,v 1.24 2009/09/07 10:49:32 nicm Exp $ */
d374 1
a374 1
	u_int		 	 xx, yy, cx, cy;
d380 25
a404 9
		for (xx = px; xx < px + nx; xx++) {
 			udata = NULL;

			if (xx >= gl->cellsize || yy >= gd->hsize + gd->sy)
				gc = &grid_default_cell;
			else {
				gc = &gl->celldata[xx];
				if (gc->flags & GRID_FLAG_UTF8)
					udata = gl->utf8data[xx].data;
d406 4
a409 3

			screen_write_cell(ctx, gc, udata);
		}
@


1.24
log
@Permit embedded colour and attributes in status-left and status-right using new
#[] special characters, for example #[fg=red,bg=blue,blink].
@
text
@d1 1
a1 1
/* $OpenBSD: screen-write.c,v 1.23 2009/08/21 08:12:05 nicm Exp $ */
d303 1
a303 1
	u_char		fg, bg, attr;
d312 2
a313 1
	attr = 0;
d329 6
a334 1
				if (val != 8)
d336 1
a336 1
				else
d339 6
a344 1
				if (val != 8)
d346 1
a346 1
				else
d361 1
d1017 2
a1018 1
		tmp_gc2.flags = gc->flags;
@


1.23
log
@Ugh, committed the wrong version of this change and got both solutions rather
than just the second. Remove unused assignment.
@
text
@d1 1
a1 1
/* $OpenBSD: screen-write.c,v 1.22 2009/08/20 19:14:42 nicm Exp $ */
d55 35
d213 137
@


1.22
log
@A few trivial optimisations: no need to check for zero size if calling
buffer_ensure in buffer.c; expand grid lines by a greater increase than one
each time; and don't read UTF-8 data unless it actually needs to be checked
when overwriting a cell.
@
text
@d1 1
a1 1
/* $OpenBSD: screen-write.c,v 1.21 2009/08/13 16:24:33 nicm Exp $ */
a860 3
	if (gc->flags & GRID_FLAG_UTF8)
		gu = grid_view_peek_utf8(gd, s->cx, s->cy);

@


1.21
log
@It was originally intended that scroll mode would show content that was
currently off-screen due to resize, but somewhere along the way this got
lost. Restore this behaviour to scroll mode by fixing screen_write_copy to read
up to the saved line length rather than the current screen width. Copy mode
remains unaltered for now.
@
text
@d1 1
a1 1
/* $OpenBSD: screen-write.c,v 1.20 2009/08/08 15:57:49 nicm Exp $ */
d861 2
a862 1
	gu = grid_view_peek_utf8(gd, s->cx, s->cy);
d889 13
a901 10
	} else if (gc->flags & GRID_FLAG_UTF8 && gu->width > 1) {
		/*
		 * An UTF-8 wide cell; overwrite following padding cells only.
		 */
		xx = s->cx;
		while (++xx < screen_size_x(s)) {
			gc = grid_view_peek_cell(gd, xx, s->cy);
			if (!(gc->flags & GRID_FLAG_PADDING))
				break;
			grid_view_set_cell(gd, xx, s->cy, &grid_default_cell);
@


1.20
log
@Add a flags member to the grid_line struct and use it to differentiate lines
wrapped at the screen edge from those terminated by a newline. Then use this
when copying to combine wrapped lines together into one.
@
text
@d1 1
a1 1
/* $OpenBSD: screen-write.c,v 1.19 2009/07/30 20:41:48 nicm Exp $ */
d187 1
a188 1
	struct grid_utf8	*gu;
d195 1
d197 3
a199 1
			if (xx >= gd->sx || yy >= gd->hsize + gd->sy)
d201 4
a204 7
			else
				gc = grid_peek_cell(gd, xx, yy);

			udata = NULL;
			if (gc->flags & GRID_FLAG_UTF8) {
				gu = grid_get_utf8(gd, xx, yy);
				udata = gu->data;
@


1.19
log
@Plug some memory leaks.
@
text
@d1 1
a1 1
/* $OpenBSD: screen-write.c,v 1.18 2009/07/27 11:33:21 nicm Exp $ */
d613 1
a613 1
screen_write_linefeed(struct screen_write_ctx *ctx)
d615 3
a617 2
	struct screen	*s = ctx->s;
	struct tty_ctx	 ttyctx;
d621 6
d792 1
a792 1
	/* Check this will fit on the current line; scroll if not. */
d795 1
a795 1
		screen_write_linefeed(ctx);
@


1.18
log
@Draw UTF-8 characters under the selection correctly.
@
text
@d1 1
a1 1
/* $OpenBSD: screen-write.c,v 1.17 2009/07/22 20:53:38 nicm Exp $ */
d94 1
@


1.17
log
@More tty code tidying: move the saved cursor/region position (from before the
screen was updated) out of struct screen and into struct tty_ctx.
@
text
@d1 1
a1 1
/* $OpenBSD: screen-write.c,v 1.16 2009/07/22 18:02:23 nicm Exp $ */
d726 1
a726 1
	struct grid_cell 	 tmp_gc, *tmp_gc2;
d746 3
a748 3
		tmp_gc2 = grid_view_get_cell(gd, s->cx - 1, s->cy);
		if (!(tmp_gc2->flags & GRID_FLAG_UTF8)) {
			tmp_gc2->flags |= GRID_FLAG_UTF8;
d750 1
a750 1
			*gu.data = tmp_gc2->data;
d802 3
a804 3
		tmp_gc2 = grid_view_get_cell(gd, xx, s->cy);
		if (tmp_gc2 != NULL)
			tmp_gc2->flags |= GRID_FLAG_PADDING;
d823 4
a826 2
		s->sel.cell.data = gc->data;
		ttyctx.cell = &s->sel.cell;
@


1.16
log
@enum tty_cmd is only used as an index into the array of command function
pointers, so remove it and use the function pointers directly to represent
themselves.
@
text
@d1 1
a1 1
/* $OpenBSD: screen-write.c,v 1.15 2009/07/22 16:45:31 nicm Exp $ */
d25 1
a25 1
void	screen_write_save(struct screen_write_ctx *);
d213 1
a213 1
/* Save cursor and region positions. */
d215 1
a215 1
screen_write_save(struct screen_write_ctx *ctx)
d219 1
a219 2
	s->old_cx = s->cx;
	s->old_cy = s->cy;
d221 5
a225 2
	s->old_rlower = s->rlower;
	s->old_rupper = s->rupper;
d315 1
d319 2
d335 1
a335 1
	tty_write0(ctx->wp, tty_cmd_alignmenttest);
d343 1
d353 1
a353 1
	screen_write_save(ctx);
d358 2
a359 1
	tty_writenum(ctx->wp, tty_cmd_insertcharacter, nx);
d367 1
d377 1
a377 1
	screen_write_save(ctx);
d382 2
a383 1
	tty_writenum(ctx->wp, tty_cmd_deletecharacter, nx);
d391 1
d402 1
a402 1
		screen_write_save(ctx);
d406 2
a407 1
		tty_writenum(ctx->wp, tty_cmd_insertline, ny);
d416 1
a416 1
	screen_write_save(ctx);
d423 2
a424 1
	tty_writenum(ctx->wp, tty_cmd_insertline, ny);
d432 1
d443 1
a443 1
		screen_write_save(ctx);
d447 2
a448 1
		tty_writenum(ctx->wp, tty_cmd_deleteline, ny);
d457 1
a457 1
	screen_write_save(ctx);
d464 2
a465 1
	tty_writenum(ctx->wp, tty_cmd_deleteline, ny);
d473 1
d475 1
a475 1
	screen_write_save(ctx);
d479 1
a479 1
	tty_write0(ctx->wp, tty_cmd_clearline);
d487 1
d490 1
a490 1
	screen_write_save(ctx);
d497 1
a497 1
 	tty_write0(ctx->wp, tty_cmd_clearendofline);
d505 1
d508 1
a508 1
	screen_write_save(ctx);
d517 1
a517 1
	tty_write0(ctx->wp, tty_cmd_clearstartofline);
d552 1
d554 1
a554 1
	screen_write_save(ctx);
d561 1
a561 1
	tty_write0(ctx->wp, tty_cmd_reverseindex);
d615 1
d617 1
a617 1
	screen_write_save(ctx);
d624 1
a624 1
 	tty_write0(ctx->wp, tty_cmd_linefeed);
d665 1
d668 1
a668 1
	screen_write_save(ctx);
d677 1
a677 1
	tty_write0(ctx->wp, tty_cmd_clearendofscreen);
d685 1
d688 1
a688 1
	screen_write_save(ctx);
d699 1
a699 1
	tty_write0(ctx->wp, tty_cmd_clearstartofscreen);
d707 1
d709 1
a709 1
	screen_write_save(ctx);
d713 1
a713 1
	tty_write0(ctx->wp, tty_cmd_clearscreen);
d763 3
a765 1
		tty_writeptr(ctx->wp, tty_cmd_utf8character, udata);
d813 1
a813 1
	screen_write_save(ctx);
d817 4
a820 3
	if (insert)
		tty_writenum(ctx->wp, tty_cmd_insertcharacter, width);
	ttyctx.wp = ctx->wp;
@


1.15
log
@There are relatively few arguments to tty_cmd_* functions now, so tidy them up
by using a struct rather than hiding everything with varargs.
@
text
@d1 1
a1 1
/* $OpenBSD: screen-write.c,v 1.14 2009/07/22 15:55:32 nicm Exp $ */
d330 1
a330 1
	tty_write0(ctx->wp, TTY_ALIGNMENTTEST);
d352 1
a352 1
	tty_writenum(ctx->wp, TTY_INSERTCHARACTER, nx);
d374 1
a374 1
	tty_writenum(ctx->wp, TTY_DELETECHARACTER, nx);
d396 1
a396 1
		tty_writenum(ctx->wp, TTY_INSERTLINE, ny);
d412 1
a412 1
	tty_writenum(ctx->wp, TTY_INSERTLINE, ny);
d434 1
a434 1
		tty_writenum(ctx->wp, TTY_DELETELINE, ny);
d450 1
a450 1
	tty_writenum(ctx->wp, TTY_DELETELINE, ny);
d463 1
a463 1
	tty_writenum(ctx->wp, TTY_CLEARLINE, 0);
d480 1
a480 1
 	tty_writenum(ctx->wp, TTY_CLEARENDOFLINE, 0);
d499 1
a499 1
	tty_writenum(ctx->wp, TTY_CLEARSTARTOFLINE, 0);
d542 1
a542 1
	tty_writenum(ctx->wp, TTY_REVERSEINDEX, 0);
d604 1
a604 1
 	tty_writenum(ctx->wp, TTY_LINEFEED, 0);
d656 1
a656 1
	tty_writenum(ctx->wp, TTY_CLEARENDOFSCREEN, 0);
d677 1
a677 1
	tty_writenum(ctx->wp, TTY_CLEARSTARTOFSCREEN, 0);
d690 1
a690 1
	tty_writenum(ctx->wp, TTY_CLEARSCREEN, 0);
d740 1
a740 1
		tty_writeptr(ctx->wp, TTY_UTF8CHARACTER, udata);
d793 1
a793 1
		tty_writenum(ctx->wp, TTY_INSERTCHARACTER, width);
d799 1
a799 1
		tty_write_cmd(TTY_CELL, &ttyctx);
d802 1
a802 1
		tty_write_cmd(TTY_CELL, &ttyctx);
@


1.14
log
@tty_cmd_raw is only used once, for raw UTF-8 output, so rename it to
tty_cmd_utf8character and eliminate the size argument.
@
text
@d1 1
a1 1
/* $OpenBSD: screen-write.c,v 1.13 2009/07/14 14:47:32 nicm Exp $ */
d330 1
a330 1
	tty_write_cmd(ctx->wp, TTY_ALIGNMENTTEST);
d352 1
a352 1
	tty_write_cmd(ctx->wp, TTY_INSERTCHARACTER, nx);
d374 1
a374 1
	tty_write_cmd(ctx->wp, TTY_DELETECHARACTER, nx);
d396 1
a396 1
		tty_write_cmd(ctx->wp, TTY_INSERTLINE, ny);
d412 1
a412 1
	tty_write_cmd(ctx->wp, TTY_INSERTLINE, ny);
d434 1
a434 1
		tty_write_cmd(ctx->wp, TTY_DELETELINE, ny);
d450 1
a450 1
	tty_write_cmd(ctx->wp, TTY_DELETELINE, ny);
d463 1
a463 1
	tty_write_cmd(ctx->wp, TTY_CLEARLINE);
d480 1
a480 1
 	tty_write_cmd(ctx->wp, TTY_CLEARENDOFLINE);
d499 1
a499 1
	tty_write_cmd(ctx->wp, TTY_CLEARSTARTOFLINE);
d542 1
a542 1
	tty_write_cmd(ctx->wp, TTY_REVERSEINDEX);
d604 1
a604 1
 	tty_write_cmd(ctx->wp, TTY_LINEFEED);
d656 1
a656 1
	tty_write_cmd(ctx->wp, TTY_CLEARENDOFSCREEN);
d677 1
a677 1
	tty_write_cmd(ctx->wp, TTY_CLEARSTARTOFSCREEN);
d690 1
a690 1
	tty_write_cmd(ctx->wp, TTY_CLEARSCREEN);
d700 1
d740 1
a740 1
		tty_write_cmd(ctx->wp, TTY_UTF8CHARACTER, udata);
d793 3
a795 1
		tty_write_cmd(ctx->wp, TTY_INSERTCHARACTER, width);
d798 6
a803 3
		tty_write_cmd(ctx->wp, TTY_CELL, &s->sel.cell, &gu);
	} else
		tty_write_cmd(ctx->wp, TTY_CELL, gc, &gu);
@


1.13
log
@The scroll region cannot be one line only, ignore attempts to make it so.
@
text
@d1 1
a1 1
/* $OpenBSD: screen-write.c,v 1.12 2009/07/09 17:57:11 nicm Exp $ */
a702 1
	size_t			 size;
d739 1
a739 5
		for (size = 0; size < UTF8_SIZE; size++) {
			if (udata[size] == 0xff)
				break;
		}
		tty_write_cmd(ctx->wp, TTY_RAW, udata, size);
@


1.12
log
@Cursor up and down should be limited by the scroll region (cuu should stop at
the scroll region top if starting from below it and cud stop at the bottom if
starting from above). Fixes another vttest test.
@
text
@d1 1
a1 1
/* $OpenBSD: screen-write.c,v 1.11 2009/07/09 07:58:14 nicm Exp $ */
d556 1
a556 1
	if (rupper > rlower)
@


1.11
log
@Change inserting and deleting lines inside the scroll region to properly clear
lines that should be inserted/deleted but not moved. Fixes problems with mutt
reported by Brian Lewis, thanks.
@
text
@d1 1
a1 1
/* $OpenBSD: screen-write.c,v 1.10 2009/07/09 00:29:32 nicm Exp $ */
d235 9
a243 2
	if (ny > s->cy)
		ny = s->cy;
d259 9
a267 2
	if (ny > screen_size_y(s) - 1 - s->cy)
		ny = screen_size_y(s) - 1 - s->cy;
@


1.10
log
@Tidy by removing unused argument from grid_view_{insert,delete}_line_region
functions (currently don't fully work, this is to make fix easier).
@
text
@d1 1
a1 1
/* $OpenBSD: screen-write.c,v 1.9 2009/06/29 21:30:50 nicm Exp $ */
d372 16
a387 2
	if (ny > screen_size_y(s) - s->cy)
		ny = screen_size_y(s) - s->cy;
d390 1
a390 1

d410 16
a425 2
	if (ny > screen_size_y(s) - s->cy)
		ny = screen_size_y(s) - s->cy;
@


1.9
log
@Fix two errors with character/line insertion and deletion: the maximum number
of characters which may be inserted or deleted is the screen width, not one
less (and similarly for lines and height); and if characters or lines are
deleted by moving the ones that follow, the space at the end needs to be
cleared.

This appears to solve long-standing redraw issues most visible when using the
force-width option then scrolling in view(1) or unwrapping lines in emacs.
@
text
@d1 1
a1 1
/* $OpenBSD: screen-write.c,v 1.8 2009/06/26 15:13:39 nicm Exp $ */
d381 2
a382 4
	else {
		grid_view_insert_lines_region(
		    s->grid, s->rupper, s->rlower, s->cy, ny);
	}
d405 2
a406 4
	else {
		grid_view_delete_lines_region(
		    s->grid, s->rupper, s->rlower, s->cy, ny);
	}
@


1.8
log
@Status line fixes: don't truncate status-right now the length calculation is
done for UTF-8, limit to the maximum length correctly when printing, and always
print a space even if the left string is longer than the width available.
@
text
@d1 1
a1 1
/* $OpenBSD: screen-write.c,v 1.7 2009/06/05 03:13:16 ray Exp $ */
d328 2
a329 2
	if (nx > screen_size_x(s) - 1 - s->cx)
		nx = screen_size_x(s) - 1 - s->cx;
d350 2
a351 2
	if (nx > screen_size_x(s) - 1 - s->cx)
		nx = screen_size_x(s) - 1 - s->cx;
d372 2
a373 2
	if (ny > screen_size_y(s) - 1 - s->cy)
		ny = screen_size_y(s) - 1 - s->cy;
d398 2
a399 2
	if (ny > screen_size_y(s) - 1 - s->cy)
		ny = screen_size_y(s) - 1 - s->cy;
@


1.7
log
@Remove trailing newlines, spaces, and tabs.

No binary change.
@
text
@d1 1
a1 1
/* $OpenBSD: screen-write.c,v 1.6 2009/06/03 23:37:30 nicm Exp $ */
d167 1
a167 1
			if (maxlen > 0 && size > (size_t) maxlen)
@


1.6
log
@Support insert mode by using insert character to shift the cells before writing
as normal.
@
text
@d1 1
a1 1
/* $OpenBSD: screen-write.c,v 1.5 2009/06/03 23:30:40 nicm Exp $ */
d92 1
a92 1
	}	
d151 1
a151 1
			
d304 1
a304 1
	
d309 1
a309 1
	
@


1.5
log
@Implement the DEC alignment test. With the last change this is enough for the
first cursor test in vttest (in ports) to pass; it still shops a few more
problems though.
@
text
@d1 1
a1 1
/* $OpenBSD: screen-write.c,v 1.4 2009/06/03 23:26:56 nicm Exp $ */
d666 1
d718 7
d758 2
@


1.4
log
@Fix some miscalculations when clearing to start of screen: the number of lines
to the cursor is cy not cy - 1, and the current cursor cell should be included.
@
text
@d1 1
a1 1
/* $OpenBSD: screen-write.c,v 1.3 2009/06/03 16:54:26 nicm Exp $ */
d292 25
@


1.3
log
@New session option, status-utf8, to control the interpretation of top-bit-set
characters in status-left and status-right (if on, they are treated as UTF-8;
otherwise passed through).
@
text
@d1 1
a1 1
/* $OpenBSD: screen-write.c,v 1.2 2009/06/03 16:05:46 nicm Exp $ */
d608 1
a608 1
		grid_view_clear(s->grid, 0, 0, sx, s->cy - 1);
d612 1
a612 1
		grid_view_clear(s->grid, 0, s->cy, s->cx, 1);
@


1.2
log
@Add a UTF-8 aware string length function and make UTF-8 in
status-left/status-right work properly. At the moment any top-bit-set
characters are assumed to be UTF-8: a status-utf8 option to configure this will
come shortly.
@
text
@d1 1
a1 1
/* $OpenBSD: screen-write.c,v 1.1 2009/06/01 22:58:49 nicm Exp $ */
d56 2
a57 2
size_t printflike1
screen_write_strlen(const char *fmt, ...)
d70 1
a70 1
		if (*ptr > 0x7f) {	/* Assume this is UTF-8. */
d97 1
a97 1
/* Write string. */
d105 1
a105 1
	screen_write_vnputs(ctx, -1, gc, fmt, ap);
d110 1
a110 1
void printflike4
d112 1
a112 1
    ssize_t maxlen, struct grid_cell *gc, const char *fmt, ...)
d117 1
a117 1
	screen_write_vnputs(ctx, maxlen, gc, fmt, ap);
d122 2
a123 2
screen_write_vnputs(struct screen_write_ctx *ctx,
    ssize_t maxlen, struct grid_cell *gc, const char *fmt, va_list ap)
d134 1
a134 1
		if (*ptr > 0x7f) {	/* Assume this is UTF-8. */
@


1.1
log
@Import tmux, a terminal multiplexor allowing (among other things) a single
terminal to be switched between several different windows and programs
displayed on one terminal be detached from one terminal and moved to another.

ok deraadt pirofti
@
text
@d1 1
a1 1
/* $OpenBSD$ */
d55 42
a102 1
	char   *msg, *ptr;
d105 25
a130 1
	va_end(ap);
d132 43
a174 2
	for (ptr = msg; *ptr != '\0'; ptr++)
		screen_write_putc(ctx, gc, (u_char) *ptr);
@

