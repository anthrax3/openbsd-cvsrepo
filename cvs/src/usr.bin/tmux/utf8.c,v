head	1.37;
access;
symbols
	OPENBSD_6_1:1.36.0.4
	OPENBSD_6_1_BASE:1.36
	OPENBSD_6_0:1.33.0.2
	OPENBSD_6_0_BASE:1.33
	OPENBSD_5_9:1.27.0.2
	OPENBSD_5_9_BASE:1.27
	OPENBSD_5_8:1.13.0.4
	OPENBSD_5_8_BASE:1.13
	OPENBSD_5_7:1.12.0.2
	OPENBSD_5_7_BASE:1.12
	OPENBSD_5_6:1.11.0.4
	OPENBSD_5_6_BASE:1.11
	OPENBSD_5_5:1.7.0.6
	OPENBSD_5_5_BASE:1.7
	OPENBSD_5_4:1.7.0.2
	OPENBSD_5_4_BASE:1.7
	OPENBSD_5_3:1.6.0.10
	OPENBSD_5_3_BASE:1.6
	OPENBSD_5_2:1.6.0.8
	OPENBSD_5_2_BASE:1.6
	OPENBSD_5_1_BASE:1.6
	OPENBSD_5_1:1.6.0.6
	OPENBSD_5_0:1.6.0.4
	OPENBSD_5_0_BASE:1.6
	OPENBSD_4_9:1.6.0.2
	OPENBSD_4_9_BASE:1.6
	OPENBSD_4_8:1.5.0.4
	OPENBSD_4_8_BASE:1.5
	OPENBSD_4_7:1.5.0.2
	OPENBSD_4_7_BASE:1.5
	OPENBSD_4_6:1.3.0.4
	OPENBSD_4_6_BASE:1.3;
locks; strict;
comment	@ * @;


1.37
date	2017.05.31.17.56.48;	author nicm;	state Exp;
branches;
next	1.36;
commitid	whraM4PaXDvaTw5s;

1.36
date	2017.03.17.14.51.41;	author nicm;	state Exp;
branches;
next	1.35;
commitid	VmkxcKnOD0hvLXmg;

1.35
date	2017.01.18.10.08.05;	author nicm;	state Exp;
branches;
next	1.34;
commitid	xB3kWBq9sJabS6m7;

1.34
date	2016.10.11.07.11.40;	author nicm;	state Exp;
branches;
next	1.33;
commitid	RhjRBUnJaRXbs4fU;

1.33
date	2016.05.27.22.57.27;	author nicm;	state Exp;
branches;
next	1.32;
commitid	tU5xThCZF1coOmnU;

1.32
date	2016.04.29.09.11.19;	author nicm;	state Exp;
branches;
next	1.31;
commitid	xZ7SgCK24OaETfRW;

1.31
date	2016.04.27.09.36.25;	author nicm;	state Exp;
branches;
next	1.30;
commitid	phOPTZOQqYFHVcA8;

1.30
date	2016.04.26.07.33.36;	author nicm;	state Exp;
branches;
next	1.29;
commitid	hdrhaqlFAZABTw8s;

1.29
date	2016.03.02.15.36.03;	author nicm;	state Exp;
branches;
next	1.28;
commitid	NiBVKnSIZN4ztNWB;

1.28
date	2016.03.01.12.02.08;	author nicm;	state Exp;
branches;
next	1.27;
commitid	waz0Ov6Cd4sWsxcD;

1.27
date	2016.01.31.09.57.41;	author nicm;	state Exp;
branches;
next	1.26;
commitid	s3fnPgOt96UPeX6P;

1.26
date	2016.01.19.15.59.12;	author nicm;	state Exp;
branches;
next	1.25;
commitid	P3qmSOx6KrDBsb0c;

1.25
date	2015.11.20.22.02.54;	author nicm;	state Exp;
branches;
next	1.24;
commitid	U2ZeZzlhuEbtOCee;

1.24
date	2015.11.14.12.03.23;	author nicm;	state Exp;
branches;
next	1.23;
commitid	3WNKPsKC6D8Md3CS;

1.23
date	2015.11.14.11.45.43;	author nicm;	state Exp;
branches;
next	1.22;
commitid	gUJFVlXRAaRAnDSU;

1.22
date	2015.11.14.11.13.44;	author nicm;	state Exp;
branches;
next	1.21;
commitid	DpLjjxyrK5AlJKcd;

1.21
date	2015.11.14.10.56.31;	author nicm;	state Exp;
branches;
next	1.20;
commitid	7oTEXFUYU5F7v5X1;

1.20
date	2015.11.13.08.09.28;	author nicm;	state Exp;
branches;
next	1.19;
commitid	3vFd8TIqn7NVGuk0;

1.19
date	2015.11.12.22.04.37;	author nicm;	state Exp;
branches;
next	1.18;
commitid	fGCLUB4poNC6IhUT;

1.18
date	2015.11.12.12.43.36;	author nicm;	state Exp;
branches;
next	1.17;
commitid	dJNPbZGePibWAHfZ;

1.17
date	2015.11.12.12.19.57;	author nicm;	state Exp;
branches;
next	1.16;
commitid	jNkHcPRyvqShNcEt;

1.16
date	2015.11.12.11.10.50;	author nicm;	state Exp;
branches;
next	1.15;
commitid	zq4e90cLboyOw7qA;

1.15
date	2015.11.12.11.05.34;	author nicm;	state Exp;
branches;
next	1.14;
commitid	Ih1tdqtjpnEyfE8x;

1.14
date	2015.11.05.16.44.25;	author schwarze;	state Exp;
branches;
next	1.13;
commitid	Z55cNCaVXspsEliG;

1.13
date	2015.04.20.14.48.55;	author nicm;	state Exp;
branches;
next	1.12;
commitid	HTTZenCXyBCACkeu;

1.12
date	2014.10.08.17.35.58;	author nicm;	state Exp;
branches;
next	1.11;
commitid	mK8z9uVwDZMfiNoM;

1.11
date	2014.04.17.15.37.55;	author nicm;	state Exp;
branches;
next	1.10;

1.10
date	2014.04.17.14.45.49;	author nicm;	state Exp;
branches;
next	1.9;

1.9
date	2014.04.02.18.12.18;	author nicm;	state Exp;
branches;
next	1.8;

1.8
date	2014.03.31.21.43.35;	author nicm;	state Exp;
branches;
next	1.7;

1.7
date	2013.04.12.12.50.36;	author nicm;	state Exp;
branches;
next	1.6;

1.6
date	2011.01.03.23.35.22;	author nicm;	state Exp;
branches;
next	1.5;

1.5
date	2009.10.20.22.17.33;	author nicm;	state Exp;
branches;
next	1.4;

1.4
date	2009.10.20.19.18.28;	author nicm;	state Exp;
branches;
next	1.3;

1.3
date	2009.06.25.06.15.04;	author nicm;	state Exp;
branches;
next	1.2;

1.2
date	2009.06.24.05.35.07;	author nicm;	state Exp;
branches;
next	1.1;

1.1
date	2009.06.01.22.58.49;	author nicm;	state Exp;
branches;
next	;


desc
@@


1.37
log
@Style and spacing nits.
@
text
@/* $OpenBSD: utf8.c,v 1.36 2017/03/17 14:51:41 nicm Exp $ */

/*
 * Copyright (c) 2008 Nicholas Marriott <nicholas.marriott@@gmail.com>
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF MIND, USE, DATA OR PROFITS, WHETHER
 * IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING
 * OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */

#include <sys/types.h>

#include <errno.h>
#include <stdlib.h>
#include <string.h>
#include <vis.h>
#include <wchar.h>

#include "tmux.h"

static int	utf8_width(wchar_t);

/* Set a single character. */
void
utf8_set(struct utf8_data *ud, u_char ch)
{
	static const struct utf8_data empty = { { 0 }, 1, 1, 1 };

	memcpy(ud, &empty, sizeof *ud);
	*ud->data = ch;
}

/* Copy UTF-8 character. */
void
utf8_copy(struct utf8_data *to, const struct utf8_data *from)
{
	u_int	i;

	memcpy(to, from, sizeof *to);

	for (i = to->size; i < sizeof to->data; i++)
		to->data[i] = '\0';
}

/*
 * Open UTF-8 sequence.
 *
 * 11000010-11011111 C2-DF start of 2-byte sequence
 * 11100000-11101111 E0-EF start of 3-byte sequence
 * 11110000-11110100 F0-F4 start of 4-byte sequence
 */
enum utf8_state
utf8_open(struct utf8_data *ud, u_char ch)
{
	memset(ud, 0, sizeof *ud);
	if (ch >= 0xc2 && ch <= 0xdf)
		ud->size = 2;
	else if (ch >= 0xe0 && ch <= 0xef)
		ud->size = 3;
	else if (ch >= 0xf0 && ch <= 0xf4)
		ud->size = 4;
	else
		return (UTF8_ERROR);
	utf8_append(ud, ch);
	return (UTF8_MORE);
}

/* Append character to UTF-8, closing if finished. */
enum utf8_state
utf8_append(struct utf8_data *ud, u_char ch)
{
	wchar_t	wc;
	int	width;

	if (ud->have >= ud->size)
		fatalx("UTF-8 character overflow");
	if (ud->size > sizeof ud->data)
		fatalx("UTF-8 character size too large");

	if (ud->have != 0 && (ch & 0xc0) != 0x80)
		ud->width = 0xff;

	ud->data[ud->have++] = ch;
	if (ud->have != ud->size)
		return (UTF8_MORE);

	if (ud->width == 0xff)
		return (UTF8_ERROR);

	if (utf8_combine(ud, &wc) != UTF8_DONE)
		return (UTF8_ERROR);
	if ((width = utf8_width(wc)) < 0)
		return (UTF8_ERROR);
	ud->width = width;

	return (UTF8_DONE);
}

/* Get width of Unicode character. */
static int
utf8_width(wchar_t wc)
{
	int	width;

	width = wcwidth(wc);
	if (width < 0 || width > 0xff) {
		log_debug("Unicode %04lx, wcwidth() %d", (long)wc, width);
		return (-1);
	}
	return (width);
}

/* Combine UTF-8 into Unicode. */
enum utf8_state
utf8_combine(const struct utf8_data *ud, wchar_t *wc)
{
	switch (mbtowc(wc, ud->data, ud->size)) {
	case -1:
		log_debug("UTF-8 %.*s, mbtowc() %d", (int)ud->size, ud->data,
		    errno);
		mbtowc(NULL, NULL, MB_CUR_MAX);
		return (UTF8_ERROR);
	case 0:
		return (UTF8_ERROR);
	default:
		return (UTF8_DONE);
	}
}

/* Split Unicode into UTF-8. */
enum utf8_state
utf8_split(wchar_t wc, struct utf8_data *ud)
{
	char	s[MB_LEN_MAX];
	int	slen;

	slen = wctomb(s, wc);
	if (slen <= 0 || slen > (int)sizeof ud->data)
		return (UTF8_ERROR);

	memcpy(ud->data, s, slen);
	ud->size = slen;

	ud->width = utf8_width(wc);
	return (UTF8_DONE);
}

/*
 * Encode len characters from src into dst, which is guaranteed to have four
 * bytes available for each character from src (for \abc or UTF-8) plus space
 * for \0.
 */
int
utf8_strvis(char *dst, const char *src, size_t len, int flag)
{
	struct utf8_data	 ud;
	const char		*start, *end;
	enum utf8_state		 more;
	size_t			 i;

	start = dst;
	end = src + len;

	while (src < end) {
		if ((more = utf8_open(&ud, *src)) == UTF8_MORE) {
			while (++src < end && more == UTF8_MORE)
				more = utf8_append(&ud, *src);
			if (more == UTF8_DONE) {
				/* UTF-8 character finished. */
				for (i = 0; i < ud.size; i++)
					*dst++ = ud.data[i];
				continue;
			}
			/* Not a complete, valid UTF-8 character. */
			src -= ud.have;
		}
		if (src < end - 1)
			dst = vis(dst, src[0], flag, src[1]);
		else if (src < end)
			dst = vis(dst, src[0], flag, '\0');
		src++;
	}

	*dst = '\0';
	return (dst - start);
}

/* Same as utf8_strvis but allocate the buffer. */
int
utf8_stravis(char **dst, const char *src, int flag)
{
	char	*buf;
	int	 len;

	buf = xreallocarray(NULL, 4, strlen(src) + 1);
	len = utf8_strvis(buf, src, strlen(src), flag);

	*dst = xrealloc(buf, len + 1);
	return (len);
}

/*
 * Sanitize a string, changing any UTF-8 characters to '_'. Caller should free
 * the returned string. Anything not valid printable ASCII or UTF-8 is
 * stripped.
 */
char *
utf8_sanitize(const char *src)
{
	char			*dst;
	size_t			 n;
	enum utf8_state		 more;
	struct utf8_data	 ud;
	u_int			 i;

	dst = NULL;

	n = 0;
	while (*src != '\0') {
		dst = xreallocarray(dst, n + 1, sizeof *dst);
		if ((more = utf8_open(&ud, *src)) == UTF8_MORE) {
			while (*++src != '\0' && more == UTF8_MORE)
				more = utf8_append(&ud, *src);
			if (more == UTF8_DONE) {
				dst = xreallocarray(dst, n + ud.width,
				    sizeof *dst);
				for (i = 0; i < ud.width; i++)
					dst[n++] = '_';
				continue;
			}
			src -= ud.have;
		}
		if (*src > 0x1f && *src < 0x7f)
			dst[n++] = *src;
		else
			dst[n++] = '_';
		src++;
	}

	dst = xreallocarray(dst, n + 1, sizeof *dst);
	dst[n] = '\0';
	return (dst);
}

/* Get UTF-8 buffer length. */
size_t
utf8_strlen(const struct utf8_data *s)
{
	size_t	i;

	for (i = 0; s[i].size != 0; i++)
		/* nothing */;
	return (i);
}

/* Get UTF-8 string width. */
u_int
utf8_strwidth(const struct utf8_data *s, ssize_t n)
{
	ssize_t	i;
	u_int	width;

	width = 0;
	for (i = 0; s[i].size != 0; i++) {
		if (n != -1 && n == i)
			break;
		width += s[i].width;
	}
	return (width);
}

/*
 * Convert a string into a buffer of UTF-8 characters. Terminated by size == 0.
 * Caller frees.
 */
struct utf8_data *
utf8_fromcstr(const char *src)
{
	struct utf8_data	*dst;
	size_t			 n;
	enum utf8_state		 more;

	dst = NULL;

	n = 0;
	while (*src != '\0') {
		dst = xreallocarray(dst, n + 1, sizeof *dst);
		if ((more = utf8_open(&dst[n], *src)) == UTF8_MORE) {
			while (*++src != '\0' && more == UTF8_MORE)
				more = utf8_append(&dst[n], *src);
			if (more == UTF8_DONE) {
				n++;
				continue;
			}
			src -= dst[n].have;
		}
		utf8_set(&dst[n], *src);
		n++;
		src++;
	}

	dst = xreallocarray(dst, n + 1, sizeof *dst);
	dst[n].size = 0;
	return (dst);
}

/* Convert from a buffer of UTF-8 characters into a string. Caller frees. */
char *
utf8_tocstr(struct utf8_data *src)
{
	char	*dst;
	size_t	 n;

	dst = NULL;

	n = 0;
	for(; src->size != 0; src++) {
		dst = xreallocarray(dst, n + src->size, 1);
		memcpy(dst + n, src->data, src->size);
		n += src->size;
	}

	dst = xreallocarray(dst, n + 1, 1);
	dst[n] = '\0';
	return (dst);
}

/* Get width of UTF-8 string. */
u_int
utf8_cstrwidth(const char *s)
{
	struct utf8_data	tmp;
	u_int			width;
	enum utf8_state		more;

	width = 0;
	while (*s != '\0') {
		if ((more = utf8_open(&tmp, *s)) == UTF8_MORE) {
			while (*++s != '\0' && more == UTF8_MORE)
				more = utf8_append(&tmp, *s);
			if (more == UTF8_DONE) {
				width += tmp.width;
				continue;
			}
			s -= tmp.have;
		}
		if (*s > 0x1f && *s != 0x7f)
			width++;
		s++;
	}
	return (width);
}

/* Trim UTF-8 string to width. Caller frees. */
char *
utf8_trimcstr(const char *s, u_int width)
{
	struct utf8_data	*tmp, *next;
	char			*out;
	u_int			 at;

	tmp = utf8_fromcstr(s);

	at = 0;
	for (next = tmp; next->size != 0; next++) {
		if (at + next->width > width) {
			next->size = 0;
			break;
		}
		at += next->width;
	}

	out = utf8_tocstr(tmp);
	free(tmp);
	return (out);
}

/* Trim UTF-8 string to width. Caller frees. */
char *
utf8_rtrimcstr(const char *s, u_int width)
{
	struct utf8_data	*tmp, *next, *end;
	char			*out;
	u_int			 at;

	tmp = utf8_fromcstr(s);

	for (end = tmp; end->size != 0; end++)
		/* nothing */;
	if (end == tmp) {
		free(tmp);
		return (xstrdup(""));
	}
	next = end - 1;

	at = 0;
	for (;;) {
		if (at + next->width > width) {
			next++;
			break;
		}
		at += next->width;

		if (next == tmp)
			break;
		next--;
	}

	out = utf8_tocstr(next);
	free(tmp);
	return (out);
}

/* Pad UTF-8 string to width. Caller frees. */
char *
utf8_padcstr(const char *s, u_int width)
{
	size_t	 slen;
	char	*out;
	u_int	  n, i;

	n = utf8_cstrwidth(s);
	if (n >= width)
		return (xstrdup(s));

	slen = strlen(s);
	out = xmalloc(slen + 1 + (width - n));
	memcpy(out, s, slen);
	for (i = n; i < width; i++)
		out[slen++] = ' ';
	out[slen] = '\0';
	return (out);
}
@


1.36
log
@Fix a couple of argument types.
@
text
@d1 1
a1 1
/* $OpenBSD: utf8.c,v 1.35 2017/01/18 10:08:05 nicm Exp $ */
d405 1
a405 2
	for (;;)
	{
@


1.35
log
@Plain stravis() because it will mangle UTF-8 characters, so add
utf8_stravis() which calls our existing utf8_strvis() and use it instead
@
text
@d1 1
a1 1
/* $OpenBSD: utf8.c,v 1.34 2016/10/11 07:11:40 nicm Exp $ */
d115 1
a115 1
		log_debug("Unicode %04x, wcwidth() %d", wc, width);
@


1.34
log
@Support UTF-8 entry into the command prompt.
@
text
@d1 1
a1 1
/* $OpenBSD: utf8.c,v 1.33 2016/05/27 22:57:27 nicm Exp $ */
d194 14
@


1.33
log
@Most of the utf8_data is fixed so simplify utf8_set to use a memcpy.
@
text
@d1 1
a1 1
/* $OpenBSD: utf8.c,v 1.32 2016/04/29 09:11:19 nicm Exp $ */
d237 27
@


1.32
log
@OpenBSD wcwidth() is sensible and complete so if it returns -1 it means
that a character is not printable, so return to ignoring such
characters.
@
text
@d1 1
a1 1
/* $OpenBSD: utf8.c,v 1.31 2016/04/27 09:36:25 nicm Exp $ */
d35 1
a35 1
	u_int	i;
d37 1
a38 7
	ud->have = 1;
	ud->size = 1;

	ud->width = 1;

	for (i = ud->size; i < sizeof ud->data; i++)
		ud->data[i] = '\0';
@


1.31
log
@Loads of platforms appear to have old or broken Unicode character type
information and are missing widths for relatively common Unicode
characters (so mbtowc() works, but wcwidth() fails). So if wcwidth()
returns -1, assume a width of 1 instead of ignoring the character.
@
text
@d1 1
a1 1
/* $OpenBSD: utf8.c,v 1.30 2016/04/26 07:33:36 nicm Exp $ */
a121 8

		/*
		 * Many platforms have no width for relatively common
		 * characters (wcwidth() returns -1); assume width 1 in this
		 * case and hope for the best.
		 */
		if (width < 0)
			return (1);
@


1.30
log
@Log wcwidth() and mbtowc() failure to make it easier to debug a Unicode
codepoint not appearing.
@
text
@d1 1
a1 1
/* $OpenBSD: utf8.c,v 1.29 2016/03/02 15:36:03 nicm Exp $ */
d122 8
@


1.29
log
@Handle wcwidth() and mbtowc() failures in better style and drop
characters where we can't find the width (wcwidth() fails) on input, the
same as we drop invalid UTF-8. Suggested by schwarze@@.
@
text
@d1 1
a1 1
/* $OpenBSD: utf8.c,v 1.28 2016/03/01 12:02:08 nicm Exp $ */
d21 1
d120 2
a121 1
	if (width < 0 || width > 0xff)
d123 1
d133 2
@


1.28
log
@Use system wcwidth() instead of carrying around UTF-8 width tables.
@
text
@d1 1
a1 1
/* $OpenBSD: utf8.c,v 1.27 2016/01/31 09:57:41 nicm Exp $ */
d28 2
d85 3
d102 7
a108 1
	ud->width = utf8_width(utf8_combine(ud));
d113 1
a113 1
u_int
d116 1
a116 1
	int width;
d119 2
a120 2
	if (width < 0)
		return (0);
d125 2
a126 2
wchar_t
utf8_combine(const struct utf8_data *ud)
d128 9
a136 5
	wchar_t wc;

	if (mbtowc(&wc, ud->data, ud->size) <= 0)
		return (0xfffd);
	return (wc);
d143 2
a144 2
	char s[MB_CUR_MAX];
	int  slen;
@


1.27
log
@Whoops, need this for the previous reverse trim commit too.
@
text
@d1 1
a1 1
/* $OpenBSD: utf8.c,v 1.26 2016/01/19 15:59:12 nicm Exp $ */
d24 1
a27 324
struct utf8_width_entry {
	u_int	first;
	u_int	last;

	int	width;

	struct utf8_width_entry	*left;
	struct utf8_width_entry	*right;
};

/* Sorted, then repeatedly split in the middle to balance the tree. */
static struct utf8_width_entry utf8_width_table[] = {
	{ 0x00b41, 0x00b44, 0, NULL, NULL },
	{ 0x008e4, 0x00902, 0, NULL, NULL },
	{ 0x006d6, 0x006dd, 0, NULL, NULL },
	{ 0x005c4, 0x005c5, 0, NULL, NULL },
	{ 0x00591, 0x005bd, 0, NULL, NULL },
	{ 0x00300, 0x0036f, 0, NULL, NULL },
	{ 0x00483, 0x00489, 0, NULL, NULL },
	{ 0x005bf, 0x005bf, 0, NULL, NULL },
	{ 0x005c1, 0x005c2, 0, NULL, NULL },
	{ 0x00610, 0x0061a, 0, NULL, NULL },
	{ 0x00600, 0x00605, 0, NULL, NULL },
	{ 0x005c7, 0x005c7, 0, NULL, NULL },
	{ 0x0064b, 0x0065f, 0, NULL, NULL },
	{ 0x0061c, 0x0061c, 0, NULL, NULL },
	{ 0x00670, 0x00670, 0, NULL, NULL },
	{ 0x007a6, 0x007b0, 0, NULL, NULL },
	{ 0x006ea, 0x006ed, 0, NULL, NULL },
	{ 0x006df, 0x006e4, 0, NULL, NULL },
	{ 0x006e7, 0x006e8, 0, NULL, NULL },
	{ 0x00711, 0x00711, 0, NULL, NULL },
	{ 0x0070f, 0x0070f, 0, NULL, NULL },
	{ 0x00730, 0x0074a, 0, NULL, NULL },
	{ 0x0081b, 0x00823, 0, NULL, NULL },
	{ 0x007eb, 0x007f3, 0, NULL, NULL },
	{ 0x00816, 0x00819, 0, NULL, NULL },
	{ 0x00829, 0x0082d, 0, NULL, NULL },
	{ 0x00825, 0x00827, 0, NULL, NULL },
	{ 0x00859, 0x0085b, 0, NULL, NULL },
	{ 0x00a41, 0x00a42, 0, NULL, NULL },
	{ 0x00981, 0x00981, 0, NULL, NULL },
	{ 0x00941, 0x00948, 0, NULL, NULL },
	{ 0x0093a, 0x0093a, 0, NULL, NULL },
	{ 0x0093c, 0x0093c, 0, NULL, NULL },
	{ 0x00951, 0x00957, 0, NULL, NULL },
	{ 0x0094d, 0x0094d, 0, NULL, NULL },
	{ 0x00962, 0x00963, 0, NULL, NULL },
	{ 0x009e2, 0x009e3, 0, NULL, NULL },
	{ 0x009c1, 0x009c4, 0, NULL, NULL },
	{ 0x009bc, 0x009bc, 0, NULL, NULL },
	{ 0x009cd, 0x009cd, 0, NULL, NULL },
	{ 0x00a01, 0x00a02, 0, NULL, NULL },
	{ 0x00a3c, 0x00a3c, 0, NULL, NULL },
	{ 0x00ac1, 0x00ac5, 0, NULL, NULL },
	{ 0x00a70, 0x00a71, 0, NULL, NULL },
	{ 0x00a4b, 0x00a4d, 0, NULL, NULL },
	{ 0x00a47, 0x00a48, 0, NULL, NULL },
	{ 0x00a51, 0x00a51, 0, NULL, NULL },
	{ 0x00a81, 0x00a82, 0, NULL, NULL },
	{ 0x00a75, 0x00a75, 0, NULL, NULL },
	{ 0x00abc, 0x00abc, 0, NULL, NULL },
	{ 0x00ae2, 0x00ae3, 0, NULL, NULL },
	{ 0x00ac7, 0x00ac8, 0, NULL, NULL },
	{ 0x00acd, 0x00acd, 0, NULL, NULL },
	{ 0x00b3c, 0x00b3c, 0, NULL, NULL },
	{ 0x00b01, 0x00b01, 0, NULL, NULL },
	{ 0x00b3f, 0x00b3f, 0, NULL, NULL },
	{ 0x03190, 0x031ba, 2, NULL, NULL },
	{ 0x017c9, 0x017d3, 0, NULL, NULL },
	{ 0x00ec8, 0x00ecd, 0, NULL, NULL },
	{ 0x00cc6, 0x00cc6, 0, NULL, NULL },
	{ 0x00c3e, 0x00c40, 0, NULL, NULL },
	{ 0x00b82, 0x00b82, 0, NULL, NULL },
	{ 0x00b56, 0x00b56, 0, NULL, NULL },
	{ 0x00b4d, 0x00b4d, 0, NULL, NULL },
	{ 0x00b62, 0x00b63, 0, NULL, NULL },
	{ 0x00bcd, 0x00bcd, 0, NULL, NULL },
	{ 0x00bc0, 0x00bc0, 0, NULL, NULL },
	{ 0x00c00, 0x00c00, 0, NULL, NULL },
	{ 0x00c62, 0x00c63, 0, NULL, NULL },
	{ 0x00c4a, 0x00c4d, 0, NULL, NULL },
	{ 0x00c46, 0x00c48, 0, NULL, NULL },
	{ 0x00c55, 0x00c56, 0, NULL, NULL },
	{ 0x00cbc, 0x00cbc, 0, NULL, NULL },
	{ 0x00c81, 0x00c81, 0, NULL, NULL },
	{ 0x00cbf, 0x00cbf, 0, NULL, NULL },
	{ 0x00dd2, 0x00dd4, 0, NULL, NULL },
	{ 0x00d41, 0x00d44, 0, NULL, NULL },
	{ 0x00ce2, 0x00ce3, 0, NULL, NULL },
	{ 0x00ccc, 0x00ccd, 0, NULL, NULL },
	{ 0x00d01, 0x00d01, 0, NULL, NULL },
	{ 0x00d62, 0x00d63, 0, NULL, NULL },
	{ 0x00d4d, 0x00d4d, 0, NULL, NULL },
	{ 0x00dca, 0x00dca, 0, NULL, NULL },
	{ 0x00e47, 0x00e4e, 0, NULL, NULL },
	{ 0x00e31, 0x00e31, 0, NULL, NULL },
	{ 0x00dd6, 0x00dd6, 0, NULL, NULL },
	{ 0x00e34, 0x00e3a, 0, NULL, NULL },
	{ 0x00eb4, 0x00eb9, 0, NULL, NULL },
	{ 0x00eb1, 0x00eb1, 0, NULL, NULL },
	{ 0x00ebb, 0x00ebc, 0, NULL, NULL },
	{ 0x0105e, 0x01060, 0, NULL, NULL },
	{ 0x00f8d, 0x00f97, 0, NULL, NULL },
	{ 0x00f39, 0x00f39, 0, NULL, NULL },
	{ 0x00f35, 0x00f35, 0, NULL, NULL },
	{ 0x00f18, 0x00f19, 0, NULL, NULL },
	{ 0x00f37, 0x00f37, 0, NULL, NULL },
	{ 0x00f80, 0x00f84, 0, NULL, NULL },
	{ 0x00f71, 0x00f7e, 0, NULL, NULL },
	{ 0x00f86, 0x00f87, 0, NULL, NULL },
	{ 0x01032, 0x01037, 0, NULL, NULL },
	{ 0x00fc6, 0x00fc6, 0, NULL, NULL },
	{ 0x00f99, 0x00fbc, 0, NULL, NULL },
	{ 0x0102d, 0x01030, 0, NULL, NULL },
	{ 0x0103d, 0x0103e, 0, NULL, NULL },
	{ 0x01039, 0x0103a, 0, NULL, NULL },
	{ 0x01058, 0x01059, 0, NULL, NULL },
	{ 0x0135d, 0x0135f, 0, NULL, NULL },
	{ 0x01085, 0x01086, 0, NULL, NULL },
	{ 0x01071, 0x01074, 0, NULL, NULL },
	{ 0x01082, 0x01082, 0, NULL, NULL },
	{ 0x0109d, 0x0109d, 0, NULL, NULL },
	{ 0x0108d, 0x0108d, 0, NULL, NULL },
	{ 0x01100, 0x011ff, 2, NULL, NULL },
	{ 0x01772, 0x01773, 0, NULL, NULL },
	{ 0x01732, 0x01734, 0, NULL, NULL },
	{ 0x01712, 0x01714, 0, NULL, NULL },
	{ 0x01752, 0x01753, 0, NULL, NULL },
	{ 0x017b7, 0x017bd, 0, NULL, NULL },
	{ 0x017b4, 0x017b5, 0, NULL, NULL },
	{ 0x017c6, 0x017c6, 0, NULL, NULL },
	{ 0x01c2c, 0x01c33, 0, NULL, NULL },
	{ 0x01a7f, 0x01a7f, 0, NULL, NULL },
	{ 0x01a17, 0x01a18, 0, NULL, NULL },
	{ 0x01920, 0x01922, 0, NULL, NULL },
	{ 0x0180b, 0x0180e, 0, NULL, NULL },
	{ 0x017dd, 0x017dd, 0, NULL, NULL },
	{ 0x018a9, 0x018a9, 0, NULL, NULL },
	{ 0x01932, 0x01932, 0, NULL, NULL },
	{ 0x01927, 0x01928, 0, NULL, NULL },
	{ 0x01939, 0x0193b, 0, NULL, NULL },
	{ 0x01a60, 0x01a60, 0, NULL, NULL },
	{ 0x01a56, 0x01a56, 0, NULL, NULL },
	{ 0x01a1b, 0x01a1b, 0, NULL, NULL },
	{ 0x01a58, 0x01a5e, 0, NULL, NULL },
	{ 0x01a65, 0x01a6c, 0, NULL, NULL },
	{ 0x01a62, 0x01a62, 0, NULL, NULL },
	{ 0x01a73, 0x01a7c, 0, NULL, NULL },
	{ 0x01b80, 0x01b81, 0, NULL, NULL },
	{ 0x01b36, 0x01b3a, 0, NULL, NULL },
	{ 0x01b00, 0x01b03, 0, NULL, NULL },
	{ 0x01ab0, 0x01abe, 0, NULL, NULL },
	{ 0x01b34, 0x01b34, 0, NULL, NULL },
	{ 0x01b42, 0x01b42, 0, NULL, NULL },
	{ 0x01b3c, 0x01b3c, 0, NULL, NULL },
	{ 0x01b6b, 0x01b73, 0, NULL, NULL },
	{ 0x01be6, 0x01be6, 0, NULL, NULL },
	{ 0x01ba8, 0x01ba9, 0, NULL, NULL },
	{ 0x01ba2, 0x01ba5, 0, NULL, NULL },
	{ 0x01bab, 0x01bad, 0, NULL, NULL },
	{ 0x01bed, 0x01bed, 0, NULL, NULL },
	{ 0x01be8, 0x01be9, 0, NULL, NULL },
	{ 0x01bef, 0x01bf1, 0, NULL, NULL },
	{ 0x02329, 0x0232a, 2, NULL, NULL },
	{ 0x01dc0, 0x01df5, 0, NULL, NULL },
	{ 0x01ce2, 0x01ce8, 0, NULL, NULL },
	{ 0x01cd0, 0x01cd2, 0, NULL, NULL },
	{ 0x01c36, 0x01c37, 0, NULL, NULL },
	{ 0x01cd4, 0x01ce0, 0, NULL, NULL },
	{ 0x01cf4, 0x01cf4, 0, NULL, NULL },
	{ 0x01ced, 0x01ced, 0, NULL, NULL },
	{ 0x01cf8, 0x01cf9, 0, NULL, NULL },
	{ 0x02060, 0x02064, 0, NULL, NULL },
	{ 0x0200b, 0x0200f, 0, NULL, NULL },
	{ 0x01dfc, 0x01dff, 0, NULL, NULL },
	{ 0x0202a, 0x0202e, 0, NULL, NULL },
	{ 0x02066, 0x0206f, 0, NULL, NULL },
	{ 0x020d0, 0x020f0, 0, NULL, NULL },
	{ 0x03001, 0x03029, 2, NULL, NULL },
	{ 0x02e80, 0x02e99, 2, NULL, NULL },
	{ 0x02d7f, 0x02d7f, 0, NULL, NULL },
	{ 0x02cef, 0x02cf1, 0, NULL, NULL },
	{ 0x02de0, 0x02dff, 0, NULL, NULL },
	{ 0x02f00, 0x02fd5, 2, NULL, NULL },
	{ 0x02e9b, 0x02ef3, 2, NULL, NULL },
	{ 0x02ff0, 0x02ffb, 2, NULL, NULL },
	{ 0x03099, 0x0309a, 0, NULL, NULL },
	{ 0x0302e, 0x0303e, 2, NULL, NULL },
	{ 0x0302a, 0x0302d, 0, NULL, NULL },
	{ 0x03041, 0x03096, 2, NULL, NULL },
	{ 0x03105, 0x0312d, 2, NULL, NULL },
	{ 0x0309b, 0x030ff, 2, NULL, NULL },
	{ 0x03131, 0x0318e, 2, NULL, NULL },
	{ 0x10a3f, 0x10a3f, 0, NULL, NULL },
	{ 0x0aa4c, 0x0aa4c, 0, NULL, NULL },
	{ 0x0a825, 0x0a826, 0, NULL, NULL },
	{ 0x0a490, 0x0a4c6, 2, NULL, NULL },
	{ 0x03250, 0x032fe, 2, NULL, NULL },
	{ 0x031f0, 0x0321e, 2, NULL, NULL },
	{ 0x031c0, 0x031e3, 2, NULL, NULL },
	{ 0x03220, 0x03247, 2, NULL, NULL },
	{ 0x04e00, 0x09fcc, 2, NULL, NULL },
	{ 0x03300, 0x04db5, 2, NULL, NULL },
	{ 0x0a000, 0x0a48c, 2, NULL, NULL },
	{ 0x0a6f0, 0x0a6f1, 0, NULL, NULL },
	{ 0x0a674, 0x0a67d, 0, NULL, NULL },
	{ 0x0a66f, 0x0a672, 0, NULL, NULL },
	{ 0x0a69f, 0x0a69f, 0, NULL, NULL },
	{ 0x0a806, 0x0a806, 0, NULL, NULL },
	{ 0x0a802, 0x0a802, 0, NULL, NULL },
	{ 0x0a80b, 0x0a80b, 0, NULL, NULL },
	{ 0x0a9b6, 0x0a9b9, 0, NULL, NULL },
	{ 0x0a947, 0x0a951, 0, NULL, NULL },
	{ 0x0a8e0, 0x0a8f1, 0, NULL, NULL },
	{ 0x0a8c4, 0x0a8c4, 0, NULL, NULL },
	{ 0x0a926, 0x0a92d, 0, NULL, NULL },
	{ 0x0a980, 0x0a982, 0, NULL, NULL },
	{ 0x0a960, 0x0a97c, 2, NULL, NULL },
	{ 0x0a9b3, 0x0a9b3, 0, NULL, NULL },
	{ 0x0aa29, 0x0aa2e, 0, NULL, NULL },
	{ 0x0a9bc, 0x0a9bc, 0, NULL, NULL },
	{ 0x0a9e5, 0x0a9e5, 0, NULL, NULL },
	{ 0x0aa35, 0x0aa36, 0, NULL, NULL },
	{ 0x0aa31, 0x0aa32, 0, NULL, NULL },
	{ 0x0aa43, 0x0aa43, 0, NULL, NULL },
	{ 0x0fb1e, 0x0fb1e, 0, NULL, NULL },
	{ 0x0aaf6, 0x0aaf6, 0, NULL, NULL },
	{ 0x0aab7, 0x0aab8, 0, NULL, NULL },
	{ 0x0aab0, 0x0aab0, 0, NULL, NULL },
	{ 0x0aa7c, 0x0aa7c, 0, NULL, NULL },
	{ 0x0aab2, 0x0aab4, 0, NULL, NULL },
	{ 0x0aac1, 0x0aac1, 0, NULL, NULL },
	{ 0x0aabe, 0x0aabf, 0, NULL, NULL },
	{ 0x0aaec, 0x0aaed, 0, NULL, NULL },
	{ 0x0ac00, 0x0d7a3, 2, NULL, NULL },
	{ 0x0abe8, 0x0abe8, 0, NULL, NULL },
	{ 0x0abe5, 0x0abe5, 0, NULL, NULL },
	{ 0x0abed, 0x0abed, 0, NULL, NULL },
	{ 0x0f900, 0x0fa6d, 2, NULL, NULL },
	{ 0x0d800, 0x0dfff, 0, NULL, NULL },
	{ 0x0fa70, 0x0fad9, 2, NULL, NULL },
	{ 0x0fff9, 0x0fffb, 0, NULL, NULL },
	{ 0x0fe30, 0x0fe52, 2, NULL, NULL },
	{ 0x0fe10, 0x0fe19, 2, NULL, NULL },
	{ 0x0fe00, 0x0fe0f, 0, NULL, NULL },
	{ 0x0fe20, 0x0fe2d, 0, NULL, NULL },
	{ 0x0fe68, 0x0fe6b, 2, NULL, NULL },
	{ 0x0fe54, 0x0fe66, 2, NULL, NULL },
	{ 0x0feff, 0x0feff, 0, NULL, NULL },
	{ 0x10a01, 0x10a03, 0, NULL, NULL },
	{ 0x102e0, 0x102e0, 0, NULL, NULL },
	{ 0x101fd, 0x101fd, 0, NULL, NULL },
	{ 0x10376, 0x1037a, 0, NULL, NULL },
	{ 0x10a0c, 0x10a0f, 0, NULL, NULL },
	{ 0x10a05, 0x10a06, 0, NULL, NULL },
	{ 0x10a38, 0x10a3a, 0, NULL, NULL },
	{ 0x11633, 0x1163a, 0, NULL, NULL },
	{ 0x11236, 0x11237, 0, NULL, NULL },
	{ 0x11100, 0x11102, 0, NULL, NULL },
	{ 0x1107f, 0x11081, 0, NULL, NULL },
	{ 0x11001, 0x11001, 0, NULL, NULL },
	{ 0x10ae5, 0x10ae6, 0, NULL, NULL },
	{ 0x11038, 0x11046, 0, NULL, NULL },
	{ 0x110b9, 0x110ba, 0, NULL, NULL },
	{ 0x110b3, 0x110b6, 0, NULL, NULL },
	{ 0x110bd, 0x110bd, 0, NULL, NULL },
	{ 0x11180, 0x11181, 0, NULL, NULL },
	{ 0x1112d, 0x11134, 0, NULL, NULL },
	{ 0x11127, 0x1112b, 0, NULL, NULL },
	{ 0x11173, 0x11173, 0, NULL, NULL },
	{ 0x1122f, 0x11231, 0, NULL, NULL },
	{ 0x111b6, 0x111be, 0, NULL, NULL },
	{ 0x11234, 0x11234, 0, NULL, NULL },
	{ 0x11370, 0x11374, 0, NULL, NULL },
	{ 0x11301, 0x11301, 0, NULL, NULL },
	{ 0x112df, 0x112df, 0, NULL, NULL },
	{ 0x112e3, 0x112ea, 0, NULL, NULL },
	{ 0x11340, 0x11340, 0, NULL, NULL },
	{ 0x1133c, 0x1133c, 0, NULL, NULL },
	{ 0x11366, 0x1136c, 0, NULL, NULL },
	{ 0x114c2, 0x114c3, 0, NULL, NULL },
	{ 0x114ba, 0x114ba, 0, NULL, NULL },
	{ 0x114b3, 0x114b8, 0, NULL, NULL },
	{ 0x114bf, 0x114c0, 0, NULL, NULL },
	{ 0x115bc, 0x115bd, 0, NULL, NULL },
	{ 0x115b2, 0x115b5, 0, NULL, NULL },
	{ 0x115bf, 0x115c0, 0, NULL, NULL },
	{ 0x1d1aa, 0x1d1ad, 0, NULL, NULL },
	{ 0x16b30, 0x16b36, 0, NULL, NULL },
	{ 0x116ad, 0x116ad, 0, NULL, NULL },
	{ 0x1163f, 0x11640, 0, NULL, NULL },
	{ 0x1163d, 0x1163d, 0, NULL, NULL },
	{ 0x116ab, 0x116ab, 0, NULL, NULL },
	{ 0x116b7, 0x116b7, 0, NULL, NULL },
	{ 0x116b0, 0x116b5, 0, NULL, NULL },
	{ 0x16af0, 0x16af4, 0, NULL, NULL },
	{ 0x1bca0, 0x1bca3, 0, NULL, NULL },
	{ 0x1b000, 0x1b001, 2, NULL, NULL },
	{ 0x16f8f, 0x16f92, 0, NULL, NULL },
	{ 0x1bc9d, 0x1bc9e, 0, NULL, NULL },
	{ 0x1d173, 0x1d182, 0, NULL, NULL },
	{ 0x1d167, 0x1d169, 0, NULL, NULL },
	{ 0x1d185, 0x1d18b, 0, NULL, NULL },
	{ 0x2a700, 0x2b734, 2, NULL, NULL },
	{ 0x1f210, 0x1f23a, 2, NULL, NULL },
	{ 0x1e8d0, 0x1e8d6, 0, NULL, NULL },
	{ 0x1d242, 0x1d244, 0, NULL, NULL },
	{ 0x1f200, 0x1f202, 2, NULL, NULL },
	{ 0x1f250, 0x1f251, 2, NULL, NULL },
	{ 0x1f240, 0x1f248, 2, NULL, NULL },
	{ 0x20000, 0x2a6d6, 2, NULL, NULL },
	{ 0xe0020, 0xe007f, 0, NULL, NULL },
	{ 0x2f800, 0x2fa1d, 2, NULL, NULL },
	{ 0x2b740, 0x2b81d, 2, NULL, NULL },
	{ 0xe0001, 0xe0001, 0, NULL, NULL },
	{ 0xf0000, 0xffffd, 0, NULL, NULL },
	{ 0xe0100, 0xe01ef, 0, NULL, NULL },
	{ 0x100000, 0x10fffd, 0, NULL, NULL },
};
static struct utf8_width_entry	*utf8_width_root = NULL;

static void	utf8_build(void);

d101 1
a101 23
/* Build UTF-8 width tree. */
static void
utf8_build(void)
{
	struct utf8_width_entry	**ptr, *item, *node;
	u_int			  i;

	for (i = 0; i < nitems(utf8_width_table); i++) {
		item = &utf8_width_table[i];

		ptr = &utf8_width_root;
		while (*ptr != NULL) {
			node = *ptr;
			if (item->last < node->first)
				ptr = &node->left;
			else if (item->first > node->last)
				ptr = &node->right;
		}
		*ptr = item;
	}
}

/* Lookup width of UTF-8 data in tree. */
d103 1
a103 1
utf8_width(u_int uc)
d105 1
a105 4
	struct utf8_width_entry	*item;

	if (utf8_width_root == NULL)
		utf8_build();
d107 4
a110 10
	item = utf8_width_root;
	while (item != NULL) {
		if (uc < item->first)
			item = item->left;
		else if (uc > item->last)
			item = item->right;
		else
			return (item->width);
	}
	return (1);
d113 2
a114 2
/* Combine UTF-8 into 32-bit Unicode. */
u_int
d117 1
a117 1
	u_int	uc;
d119 3
a121 22
	uc = 0xfffd;
	switch (ud->size) {
	case 1:
		uc = ud->data[0];
		break;
	case 2:
		uc = ud->data[1] & 0x3f;
		uc |= (ud->data[0] & 0x1f) << 6;
		break;
	case 3:
		uc = ud->data[2] & 0x3f;
		uc |= (ud->data[1] & 0x3f) << 6;
		uc |= (ud->data[0] & 0xf) << 12;
		break;
	case 4:
		uc = ud->data[3] & 0x3f;
		uc |= (ud->data[2] & 0x3f) << 6;
		uc |= (ud->data[1] & 0x3f) << 12;
		uc |= (ud->data[0] & 0x7) << 18;
		break;
	}
	return (uc);
d124 1
a124 1
/* Split 32-bit Unicode into UTF-8. */
d126 1
a126 1
utf8_split(u_int uc, struct utf8_data *ud)
d128 5
a132 19
	if (uc < 0x7f) {
		ud->size = 1;
		ud->data[0] = uc;
	} else if (uc < 0x7ff) {
		ud->size = 2;
		ud->data[0] = 0xc0 | ((uc >> 6) & 0x1f);
		ud->data[1] = 0x80 | (uc & 0x3f);
	} else if (uc < 0xffff) {
		ud->size = 3;
		ud->data[0] = 0xe0 | ((uc >> 12) & 0xf);
		ud->data[1] = 0x80 | ((uc >> 6) & 0x3f);
		ud->data[2] = 0x80 | (uc & 0x3f);
	} else if (uc < 0x1fffff) {
		ud->size = 4;
		ud->data[0] = 0xf0 | ((uc >> 18) & 0x7);
		ud->data[1] = 0x80 | ((uc >> 12) & 0x3f);
		ud->data[2] = 0x80 | ((uc >> 6) & 0x3f);
		ud->data[3] = 0x80 | (uc & 0x3f);
	} else
d134 5
a138 1
	ud->width = utf8_width(uc);
a139 13
}

/* Split a two-byte UTF-8 character. */
u_int
utf8_split2(u_int uc, u_char *ptr)
{
	if (uc > 0x7f) {
		ptr[0] = (uc >> 6) | 0xc0;
		ptr[1] = (uc & 0x3f) | 0x80;
		return (2);
	}
	ptr[0] = uc;
	return (1);
@


1.26
log
@I no longer use my SourceForge address so replace it.
@
text
@d1 1
a1 1
/* $OpenBSD: utf8.c,v 1.25 2015/11/20 22:02:54 nicm Exp $ */
d723 37
@


1.25
log
@Memory leaks and an uninitialized part of utf8_data, from Patrick Palka.
@
text
@d1 1
a1 1
/* $OpenBSD: utf8.c,v 1.24 2015/11/14 12:03:23 nicm Exp $ */
d4 1
a4 1
 * Copyright (c) 2008 Nicholas Marriott <nicm@@users.sourceforge.net>
@


1.24
log
@The private use area at U+E000 to U+F8FF is not very useful if it is
width 0, make it width 1 instead.
@
text
@d1 1
a1 1
/* $OpenBSD: utf8.c,v 1.23 2015/11/14 11:45:43 nicm Exp $ */
d358 1
@


1.23
log
@All these return values from utf8_* are confusing, use an enum.
@
text
@d1 1
a1 1
/* $OpenBSD: utf8.c,v 1.22 2015/11/14 11:13:44 nicm Exp $ */
d267 1
a267 1
	{ 0x0d800, 0x0f8ff, 0, NULL, NULL },
@


1.22
log
@Rename a variable in utf8_combine for consistency and use 0xfffd for
unknown Unicode.
@
text
@d1 1
a1 1
/* $OpenBSD: utf8.c,v 1.21 2015/11/14 10:56:31 nicm Exp $ */
a383 2
 *
 * Returns 1 if more UTF-8 to come, 0 if not UTF-8.
d385 1
a385 1
int
d396 1
a396 1
		return (0);
d398 1
a398 1
	return (1);
d401 2
a402 7
/*
 * Append character to UTF-8, closing if finished.
 *
 * Returns 1 if more UTF-8 data to come, 0 if finished and valid, -1 if
 * finished and invalid.
 */
int
d415 1
a415 1
		return (1);
d418 1
a418 1
		return (-1);
d420 1
a420 1
	return (0);
d497 1
a497 1
int
d519 1
a519 1
		return (-1);
d521 1
a521 1
	return (0);
d547 1
a547 1
	int			 more;
d554 2
a555 3
		if (utf8_open(&ud, *src)) {
			more = 1;
			while (++src < end && more == 1)
d557 1
a557 1
			if (more == 0) {
a561 3
			} else if (ud.have > 0) {
				/* Not a complete, valid UTF-8 character. */
				src -= ud.have;
d563 2
d587 1
a587 1
	int			 more;
d596 2
a597 3
		if (utf8_open(&ud, *src)) {
			more = 1;
			while (*++src != '\0' && more == 1)
d599 1
a599 1
			if (more != 1) {
d610 2
d629 1
a629 1
	int			 more;
d636 2
a637 3
		if (utf8_open(&dst[n], *src)) {
			more = 1;
			while (*++src != '\0' && more == 1)
d639 1
a639 1
			if (more != 1) {
d645 2
a646 4
		if (*src > 0x1f && *src < 0x7f) {
			utf8_set(&dst[n], *src);
			n++;
		}
d682 1
a682 1
	int			more;
d686 2
a687 3
		if (utf8_open(&tmp, *s)) {
			more = 1;
			while (*++s != '\0' && more == 1)
d689 1
a689 1
			if (more != 1) {
d695 1
a695 1
		if (*s > 0x1f && *s < 0x7f)
@


1.21
log
@Be more strict about invalid UTF-8.
@
text
@d1 1
a1 1
/* $OpenBSD: utf8.c,v 1.20 2015/11/13 08:09:28 nicm Exp $ */
d477 1
a477 1
	u_int	value;
d479 1
a479 1
	value = 0xff;
d482 1
a482 1
		value = ud->data[0];
d485 2
a486 2
		value = ud->data[1] & 0x3f;
		value |= (ud->data[0] & 0x1f) << 6;
d489 3
a491 3
		value = ud->data[2] & 0x3f;
		value |= (ud->data[1] & 0x3f) << 6;
		value |= (ud->data[0] & 0xf) << 12;
d494 4
a497 4
		value = ud->data[3] & 0x3f;
		value |= (ud->data[2] & 0x3f) << 6;
		value |= (ud->data[1] & 0x3f) << 12;
		value |= (ud->data[0] & 0x7) << 18;
d500 1
a500 1
	return (value);
@


1.20
log
@Long overdue change to the way we store cells in the grid: now, instead
of storing a full grid_cell with UTF-8 data and everything, store a new
type grid_cell_entry. This can either be the cell itself (for ASCII
cells), or an offset into an extended array (per line) for UTF-8
data.

This avoid a large (8 byte) overhead on non-UTF-8 cells (by far the
majority for most users) without the complexity of the shadow array we
had before. Grid memory without any UTF-8 is about half.

The disadvantage that cells can no longer be modified in place and need
to be copied out of the grid and back but it turned out to be lot less
complicated than I expected.
@
text
@d1 1
a1 1
/* $OpenBSD: utf8.c,v 1.19 2015/11/12 22:04:37 nicm Exp $ */
d406 2
a407 1
 * Returns 1 if more UTF-8 data to come, 0 if finished.
a411 2
	/* XXX this should do validity checks too! */

d417 3
d424 2
d563 1
a563 1
			while (++src < end && more)
d565 1
a565 1
			if (!more) {
d571 1
a571 1
				/* Not a complete UTF-8 character. */
d607 1
a607 1
			while (*++src != '\0' && more)
d609 1
a609 1
			if (!more) {
d619 1
a619 1
			dst[n] = *src;
a620 2

		n++;
d646 1
a646 1
			while (*++src != '\0' && more)
d648 1
a648 1
			if (!more) {
d654 4
a657 1
		utf8_set(&dst[n], *src);
a658 2

		n++;
d699 1
a699 1
			while (*++s != '\0' && more)
d701 1
a701 1
			if (!more) {
d707 2
a708 1
		width++;
@


1.19
log
@Rename overly-long utf8data to ud throughout.
@
text
@d1 1
a1 1
/* $OpenBSD: utf8.c,v 1.18 2015/11/12 12:43:36 nicm Exp $ */
d355 2
d361 15
@


1.18
log
@Add utf8_padcstr and use it to align columns in list-keys.
@
text
@d1 1
a1 1
/* $OpenBSD: utf8.c,v 1.17 2015/11/12 12:19:57 nicm Exp $ */
d353 1
a353 1
utf8_set(struct utf8_data *utf8data, u_char ch)
d355 2
a356 2
	*utf8data->data = ch;
	utf8data->size = 1;
d358 1
a358 1
	utf8data->width = 1;
d371 1
a371 1
utf8_open(struct utf8_data *utf8data, u_char ch)
d373 1
a373 1
	memset(utf8data, 0, sizeof *utf8data);
d375 1
a375 1
		utf8data->size = 2;
d377 1
a377 1
		utf8data->size = 3;
d379 1
a379 1
		utf8data->size = 4;
d382 1
a382 1
	utf8_append(utf8data, ch);
d392 1
a392 1
utf8_append(struct utf8_data *utf8data, u_char ch)
d396 1
a396 1
	if (utf8data->have >= utf8data->size)
d398 1
a398 1
	if (utf8data->size > sizeof utf8data->data)
d401 2
a402 2
	utf8data->data[utf8data->have++] = ch;
	if (utf8data->have != utf8data->size)
d405 1
a405 1
	utf8data->width = utf8_width(utf8_combine(utf8data));
d454 1
a454 1
utf8_combine(const struct utf8_data *utf8data)
d459 1
a459 1
	switch (utf8data->size) {
d461 1
a461 1
		value = utf8data->data[0];
d464 2
a465 2
		value = utf8data->data[1] & 0x3f;
		value |= (utf8data->data[0] & 0x1f) << 6;
d468 3
a470 3
		value = utf8data->data[2] & 0x3f;
		value |= (utf8data->data[1] & 0x3f) << 6;
		value |= (utf8data->data[0] & 0xf) << 12;
d473 4
a476 4
		value = utf8data->data[3] & 0x3f;
		value |= (utf8data->data[2] & 0x3f) << 6;
		value |= (utf8data->data[1] & 0x3f) << 12;
		value |= (utf8data->data[0] & 0x7) << 18;
d484 1
a484 1
utf8_split(u_int uc, struct utf8_data *utf8data)
d487 2
a488 2
		utf8data->size = 1;
		utf8data->data[0] = uc;
d490 3
a492 3
		utf8data->size = 2;
		utf8data->data[0] = 0xc0 | ((uc >> 6) & 0x1f);
		utf8data->data[1] = 0x80 | (uc & 0x3f);
d494 4
a497 4
		utf8data->size = 3;
		utf8data->data[0] = 0xe0 | ((uc >> 12) & 0xf);
		utf8data->data[1] = 0x80 | ((uc >> 6) & 0x3f);
		utf8data->data[2] = 0x80 | (uc & 0x3f);
d499 5
a503 5
		utf8data->size = 4;
		utf8data->data[0] = 0xf0 | ((uc >> 18) & 0x7);
		utf8data->data[1] = 0x80 | ((uc >> 12) & 0x3f);
		utf8data->data[2] = 0x80 | ((uc >> 6) & 0x3f);
		utf8data->data[3] = 0x80 | (uc & 0x3f);
d506 1
a506 1
	utf8data->width = utf8_width(uc);
d531 1
a531 1
	struct utf8_data	 utf8data;
d540 1
a540 1
		if (utf8_open(&utf8data, *src)) {
d543 1
a543 1
				more = utf8_append(&utf8data, *src);
d546 2
a547 2
				for (i = 0; i < utf8data.size; i++)
					*dst++ = utf8data.data[i];
d549 1
a549 1
			} else if (utf8data.have > 0) {
d551 1
a551 1
				src -= utf8data.have;
d576 1
a576 1
	struct utf8_data	 utf8data;
d584 1
a584 1
		if (utf8_open(&utf8data, *src)) {
d587 1
a587 1
				more = utf8_append(&utf8data, *src);
d589 1
a589 1
				dst = xreallocarray(dst, n + utf8data.width,
d591 1
a591 1
				for (i = 0; i < utf8data.width; i++)
d595 1
a595 1
			src -= utf8data.have;
@


1.17
log
@Tidy utf8.c a little: build table on first use, and make utf8_width take
a u_int rather than splitting and then combining again in utf8_split.
@
text
@d1 1
a1 1
/* $OpenBSD: utf8.c,v 1.16 2015/11/12 11:10:50 nicm Exp $ */
d714 21
@


1.16
log
@If we know the terminal outside tmux is not UTF-8, replace UTF-8 in
error messages and whatnot with underscores the same as we do when we
draw UTF-8 characters as part of the screen.
@
text
@d1 1
a1 1
/* $OpenBSD: utf8.c,v 1.15 2015/11/12 11:05:34 nicm Exp $ */
d38 1
a38 1
struct utf8_width_entry utf8_width_table[] = {
d347 1
d349 1
a349 5
struct utf8_width_entry	*utf8_width_root = NULL;

int	utf8_overlap(struct utf8_width_entry *, struct utf8_width_entry *);
u_int	utf8_combine(const struct utf8_data *);
u_int	utf8_width(const struct utf8_data *);
d405 1
a405 16
	utf8data->width = utf8_width(utf8data);
	return (0);
}

/* Check if two width tree entries overlap. */
int
utf8_overlap(struct utf8_width_entry *item1, struct utf8_width_entry *item2)
{
	if (item1->first >= item2->first && item1->first <= item2->last)
		return (1);
	if (item1->last >= item2->first && item1->last <= item2->last)
		return (1);
	if (item2->first >= item1->first && item2->first <= item1->last)
		return (1);
	if (item2->last >= item1->first && item2->last <= item1->last)
		return (1);
d410 1
a410 1
void
d414 1
a414 1
	u_int			  i, j;
a418 5
		for (j = 0; j < nitems(utf8_width_table); j++) {
			if (i != j && utf8_overlap(item, &utf8_width_table[j]))
				log_fatalx("utf8 overlap: %u %u", i, j);
		}

d431 21
d482 1
a482 1
/* Split a UTF-8 character. */
d506 1
a506 1
	utf8data->width = utf8_width(utf8data);
a519 21
	return (1);
}

/* Lookup width of UTF-8 data in tree. */
u_int
utf8_width(const struct utf8_data *utf8data)
{
	struct utf8_width_entry	*item;
	u_int			 value;

	value = utf8_combine(utf8data);

	item = utf8_width_root;
	while (item != NULL) {
		if (value < item->first)
			item = item->left;
		else if (value > item->last)
			item = item->right;
		else
			return (item->width);
	}
@


1.15
log
@Support UTF-8 key bindings by expanding the key type from int to
uint64_t and converting UTF-8 to Unicode on input and the reverse on
output. (This allows key bindings, there are still omissions - the
largest being that the various prompts do not accept UTF-8.)
@
text
@d1 1
a1 1
/* $OpenBSD: utf8.c,v 1.14 2015/11/05 16:44:25 schwarze Exp $ */
d586 44
@


1.14
log
@Update the internal wcwidth(3) table of tmux(1) to match the data
in /usr/src/share/locale/ctype/en_US.UTF-8.src, with one single
exception:  Keep U+00AD SOFT HYPHEN at width 1 rather than moving
it to width 0, a tradition already observed in the old
https://www.cl.cam.ac.uk/~mgk25/ucs/wcwidth.c .
While here, manually rebalance the btree for optimal lookup speed.
OK nicm@@
@
text
@d1 1
a1 1
/* $OpenBSD: utf8.c,v 1.13 2015/04/20 14:48:55 nicm Exp $ */
d397 2
d472 1
a472 1
		value |= (utf8data->data[0] & 0x0f) << 12;
d478 1
a478 1
		value |= (utf8data->data[0] & 0x07) << 18;
d482 28
@


1.13
log
@Style nit - unnecessary brackets.
@
text
@d1 1
a1 1
/* $OpenBSD: utf8.c,v 1.12 2014/10/08 17:35:58 nicm Exp $ */
d37 1
a37 1
/* Random order. Not optimal but it'll do for now... */
d39 4
a42 13
	{ 0x00951, 0x00954, 0, NULL, NULL },
	{ 0x00ccc, 0x00ccd, 0, NULL, NULL },
	{ 0x0fff9, 0x0fffb, 0, NULL, NULL },
	{ 0x20000, 0x2fffd, 2, NULL, NULL },
	{ 0x00ebb, 0x00ebc, 0, NULL, NULL },
	{ 0x01932, 0x01932, 0, NULL, NULL },
	{ 0x0070f, 0x0070f, 0, NULL, NULL },
	{ 0x00a70, 0x00a71, 0, NULL, NULL },
	{ 0x02329, 0x02329, 2, NULL, NULL },
	{ 0x00acd, 0x00acd, 0, NULL, NULL },
	{ 0x00ac7, 0x00ac8, 0, NULL, NULL },
	{ 0x00a3c, 0x00a3c, 0, NULL, NULL },
	{ 0x009cd, 0x009cd, 0, NULL, NULL },
d44 2
a45 6
	{ 0x01058, 0x01059, 0, NULL, NULL },
	{ 0x0ffe0, 0x0ffe6, 2, NULL, NULL },
	{ 0x01100, 0x0115f, 2, NULL, NULL },
	{ 0x0fe20, 0x0fe23, 0, NULL, NULL },
	{ 0x0302a, 0x0302f, 0, NULL, NULL },
	{ 0x01772, 0x01773, 0, NULL, NULL },
d47 8
d56 18
a73 1
	{ 0x00bc0, 0x00bc0, 0, NULL, NULL },
d75 18
a92 5
	{ 0x01732, 0x01734, 0, NULL, NULL },
	{ 0x00d41, 0x00d43, 0, NULL, NULL },
	{ 0x01b42, 0x01b42, 0, NULL, NULL },
	{ 0x00a41, 0x00a42, 0, NULL, NULL },
	{ 0x00eb4, 0x00eb9, 0, NULL, NULL },
d94 14
a107 3
	{ 0x00e34, 0x00e3a, 0, NULL, NULL },
	{ 0x03040, 0x03098, 2, NULL, NULL },
	{ 0x0093c, 0x0093c, 0, NULL, NULL },
d109 4
a112 3
	{ 0x01032, 0x01032, 0, NULL, NULL },
	{ 0x00f37, 0x00f37, 0, NULL, NULL },
	{ 0x00901, 0x00902, 0, NULL, NULL },
a113 1
	{ 0x0a806, 0x0a806, 0, NULL, NULL },
d115 21
d137 18
d156 8
a163 4
	{ 0x1d242, 0x1d244, 0, NULL, NULL },
	{ 0x005c1, 0x005c2, 0, NULL, NULL },
	{ 0x0309b, 0x0a4cf, 2, NULL, NULL },
	{ 0xe0100, 0xe01ef, 0, NULL, NULL },
d165 2
a166 15
	{ 0x00600, 0x00603, 0, NULL, NULL },
	{ 0x009e2, 0x009e3, 0, NULL, NULL },
	{ 0x00cc6, 0x00cc6, 0, NULL, NULL },
	{ 0x0a80b, 0x0a80b, 0, NULL, NULL },
	{ 0x01712, 0x01714, 0, NULL, NULL },
	{ 0x00b3c, 0x00b3c, 0, NULL, NULL },
	{ 0x01b00, 0x01b03, 0, NULL, NULL },
	{ 0x007eb, 0x007f3, 0, NULL, NULL },
	{ 0xe0001, 0xe0001, 0, NULL, NULL },
	{ 0x1d185, 0x1d18b, 0, NULL, NULL },
	{ 0x0feff, 0x0feff, 0, NULL, NULL },
	{ 0x01b36, 0x01b3a, 0, NULL, NULL },
	{ 0x01920, 0x01922, 0, NULL, NULL },
	{ 0x00670, 0x00670, 0, NULL, NULL },
	{ 0x00f90, 0x00f97, 0, NULL, NULL },
a167 20
	{ 0x0200b, 0x0200f, 0, NULL, NULL },
	{ 0x0ff00, 0x0ff60, 2, NULL, NULL },
	{ 0x0f900, 0x0faff, 2, NULL, NULL },
	{ 0x0fb1e, 0x0fb1e, 0, NULL, NULL },
	{ 0x00cbc, 0x00cbc, 0, NULL, NULL },
	{ 0x00eb1, 0x00eb1, 0, NULL, NULL },
	{ 0x10a38, 0x10a3a, 0, NULL, NULL },
	{ 0x007a6, 0x007b0, 0, NULL, NULL },
	{ 0x00f80, 0x00f84, 0, NULL, NULL },
	{ 0x005c4, 0x005c5, 0, NULL, NULL },
	{ 0x0ac00, 0x0d7a3, 2, NULL, NULL },
	{ 0x017c9, 0x017d3, 0, NULL, NULL },
	{ 0x00d4d, 0x00d4d, 0, NULL, NULL },
	{ 0x1d167, 0x1d169, 0, NULL, NULL },
	{ 0x01036, 0x01037, 0, NULL, NULL },
	{ 0xe0020, 0xe007f, 0, NULL, NULL },
	{ 0x00f35, 0x00f35, 0, NULL, NULL },
	{ 0x017b4, 0x017b5, 0, NULL, NULL },
	{ 0x0206a, 0x0206f, 0, NULL, NULL },
	{ 0x00c46, 0x00c48, 0, NULL, NULL },
d169 13
a181 10
	{ 0x01dc0, 0x01dca, 0, NULL, NULL },
	{ 0x10a0c, 0x10a0f, 0, NULL, NULL },
	{ 0x0102d, 0x01030, 0, NULL, NULL },
	{ 0x017c6, 0x017c6, 0, NULL, NULL },
	{ 0x00ec8, 0x00ecd, 0, NULL, NULL },
	{ 0x00b41, 0x00b43, 0, NULL, NULL },
	{ 0x017b7, 0x017bd, 0, NULL, NULL },
	{ 0x1d173, 0x1d182, 0, NULL, NULL },
	{ 0x00a47, 0x00a48, 0, NULL, NULL },
	{ 0x0232a, 0x0232a, 2, NULL, NULL },
d183 31
a213 6
	{ 0x10a01, 0x10a03, 0, NULL, NULL },
	{ 0x00ae2, 0x00ae3, 0, NULL, NULL },
	{ 0x00483, 0x00486, 0, NULL, NULL },
	{ 0x0135f, 0x0135f, 0, NULL, NULL },
	{ 0x01a17, 0x01a18, 0, NULL, NULL },
	{ 0x006e7, 0x006e8, 0, NULL, NULL },
d215 6
a220 36
	{ 0x00b4d, 0x00b4d, 0, NULL, NULL },
	{ 0x00ce2, 0x00ce3, 0, NULL, NULL },
	{ 0x00bcd, 0x00bcd, 0, NULL, NULL },
	{ 0x00610, 0x00615, 0, NULL, NULL },
	{ 0x00f99, 0x00fbc, 0, NULL, NULL },
	{ 0x009c1, 0x009c4, 0, NULL, NULL },
	{ 0x00730, 0x0074a, 0, NULL, NULL },
	{ 0x00300, 0x0036f, 0, NULL, NULL },
	{ 0x03030, 0x0303e, 2, NULL, NULL },
	{ 0x01b34, 0x01b34, 0, NULL, NULL },
	{ 0x1d1aa, 0x1d1ad, 0, NULL, NULL },
	{ 0x00dca, 0x00dca, 0, NULL, NULL },
	{ 0x006d6, 0x006e4, 0, NULL, NULL },
	{ 0x00f86, 0x00f87, 0, NULL, NULL },
	{ 0x00b3f, 0x00b3f, 0, NULL, NULL },
	{ 0x0fe30, 0x0fe6f, 2, NULL, NULL },
	{ 0x01039, 0x01039, 0, NULL, NULL },
	{ 0x0094d, 0x0094d, 0, NULL, NULL },
	{ 0x00c55, 0x00c56, 0, NULL, NULL },
	{ 0x00488, 0x00489, 0, NULL, NULL },
	{ 0x00e47, 0x00e4e, 0, NULL, NULL },
	{ 0x00a81, 0x00a82, 0, NULL, NULL },
	{ 0x00ac1, 0x00ac5, 0, NULL, NULL },
	{ 0x0202a, 0x0202e, 0, NULL, NULL },
	{ 0x00dd6, 0x00dd6, 0, NULL, NULL },
	{ 0x018a9, 0x018a9, 0, NULL, NULL },
	{ 0x0064b, 0x0065e, 0, NULL, NULL },
	{ 0x00abc, 0x00abc, 0, NULL, NULL },
	{ 0x00b82, 0x00b82, 0, NULL, NULL },
	{ 0x00f39, 0x00f39, 0, NULL, NULL },
	{ 0x020d0, 0x020ef, 0, NULL, NULL },
	{ 0x01dfe, 0x01dff, 0, NULL, NULL },
	{ 0x30000, 0x3fffd, 2, NULL, NULL },
	{ 0x00711, 0x00711, 0, NULL, NULL },
	{ 0x0fe00, 0x0fe0f, 0, NULL, NULL },
	{ 0x0180b, 0x0180d, 0, NULL, NULL },
d222 1
a222 1
	{ 0x00981, 0x00981, 0, NULL, NULL },
d224 47
a270 3
	{ 0x00941, 0x00948, 0, NULL, NULL },
	{ 0x01b6b, 0x01b73, 0, NULL, NULL },
	{ 0x00e31, 0x00e31, 0, NULL, NULL },
d272 10
a281 10
	{ 0x00a01, 0x00a02, 0, NULL, NULL },
	{ 0x00a4b, 0x00a4d, 0, NULL, NULL },
	{ 0x00f18, 0x00f19, 0, NULL, NULL },
	{ 0x00fc6, 0x00fc6, 0, NULL, NULL },
	{ 0x02e80, 0x03029, 2, NULL, NULL },
	{ 0x00b56, 0x00b56, 0, NULL, NULL },
	{ 0x009bc, 0x009bc, 0, NULL, NULL },
	{ 0x005c7, 0x005c7, 0, NULL, NULL },
	{ 0x02060, 0x02063, 0, NULL, NULL },
	{ 0x00c3e, 0x00c40, 0, NULL, NULL },
d283 63
@


1.12
log
@Add xreallocarray and remove nmemb argument from xrealloc.
@
text
@d1 1
a1 1
/* $OpenBSD: utf8.c,v 1.11 2014/04/17 15:37:55 nicm Exp $ */
d293 1
a293 1
				ptr = &(node->left);
d295 1
a295 1
				ptr = &(node->right);
@


1.11
log
@Add some UTF-8 utility functions and use them to prevent the width limit
on formats from splitting UTF-8 characters improperly.
@
text
@d1 1
a1 1
/* $OpenBSD: utf8.c,v 1.10 2014/04/17 14:45:49 nicm Exp $ */
d422 1
a422 1
		dst = xrealloc(dst, n + 1, sizeof *dst);
d439 1
a439 1
	dst = xrealloc(dst, n + 1, sizeof *dst);
d455 1
a455 1
		dst = xrealloc(dst, n + src->size, 1);
d460 1
a460 1
	dst = xrealloc(dst, n + 1, 1);
@


1.10
log
@Some more long lines.
@
text
@d1 1
a1 1
/* $OpenBSD: utf8.c,v 1.9 2014/04/02 18:12:18 nicm Exp $ */
d21 1
d203 10
d405 108
@


1.9
log
@Support UTF-8 with choose-buffer, from Kosuke ASAMI. Also make
buffer_sample bigger to let it trim at window right edge.
@
text
@d1 1
a1 1
/* $OpenBSD: utf8.c,v 1.8 2014/03/31 21:43:35 nicm Exp $ */
d250 1
a250 2
utf8_overlap(
    struct utf8_width_entry *item1, struct utf8_width_entry *item2)
@


1.8
log
@In four byte UTF-8 sequences, only three bits of the first byte should
be used. Fix from Koga Osamu.
@
text
@d1 1
a1 1
/* $OpenBSD: utf8.c,v 1.7 2013/04/12 12:50:36 nicm Exp $ */
d22 1
d353 42
@


1.7
log
@Remove some Korean characters from the zero-width list that apparently
shouldn't be there, from Jeong Mok Cho.
@
text
@d1 1
a1 1
/* $OpenBSD: utf8.c,v 1.6 2011/01/03 23:35:22 nicm Exp $ */
d314 1
a314 1
		value |= (utf8data->data[0] & 0x3f) << 18;
@


1.6
log
@Support for UTF-8 mouse input (\033[1005h). This was added in xterm 262
and supports larger terminals than the older way.

If the new mouse-utf8 option is on, UTF-8 mouse input is enabled for all
UTF-8 terminals. The option defaults to on if LANG etc are set in the
same manner as the utf8 option.

With help and based on code from hsim at gmx.li.
@
text
@d1 1
a1 1
/* $OpenBSD: utf8.c,v 1.5 2009/10/20 22:17:33 nicm Exp $ */
a173 1
	{ 0x01160, 0x011ff, 0, NULL, NULL },
@


1.5
log
@%zu not %u, doh.
@
text
@d1 1
a1 1
/* $OpenBSD: utf8.c,v 1.4 2009/10/20 19:18:28 nicm Exp $ */
d319 13
@


1.4
log
@Try to reduce the UTF-8 mess.

Get rid of passing around u_char[4]s and define a struct utf8_data which has
character data, size (sequence length) and width. Move UTF-8 character
collection into two functions utf8_open/utf8_append in utf8.c which fill in
this struct and use these functions from input.c and the various functions in
screen-write.c.

Space for rather more data than is necessary for one UTF-8 sequence is in the
utf8_data struct because screen_write_copy is still nasty and needs to reinject
the character (after combining) into screen_write_cell.
@
text
@d1 1
a1 1
/* $OpenBSD: utf8.c,v 1.3 2009/06/25 06:15:04 nicm Exp $ */
d230 1
a230 1
 * Returns 1 if more UTF-8 data to come, 1 if finished.
@


1.3
log
@Miscellaneous unused functions, including one which was basically a
duplicate. Found by lint.
@
text
@d1 1
a1 1
/* $OpenBSD: utf8.c,v 1.2 2009/06/24 05:35:07 nicm Exp $ */
d199 2
a200 2
void	utf8_print(struct utf8_width_entry *, int);
u_int	utf8_combine(const u_char *);
d202 47
d264 1
d291 1
a291 10
void
utf8_print(struct utf8_width_entry *node, int n)
{
	log_debug("%*s%04x -> %04x", n, " ",  node->first, node->last);
	if (node->left != NULL)
		utf8_print(node->left, n + 1);
	if (node->right != NULL)
		utf8_print(node->right, n + 1);
}

d293 1
a293 1
utf8_combine(const u_char *data)
d295 1
a295 1
	u_int	uvalue;
d297 20
a316 14
	if (data[1] == 0xff)
		uvalue = data[0];
	else if (data[2] == 0xff) {
		uvalue = data[1] & 0x3f;
		uvalue |= (data[0] & 0x1f) << 6;
	} else if (data[3] == 0xff) {
		uvalue = data[2] & 0x3f;
		uvalue |= (data[1] & 0x3f) << 6;
		uvalue |= (data[0] & 0x0f) << 12;
	} else {
		uvalue = data[3] & 0x3f;
		uvalue |= (data[2] & 0x3f) << 6;
		uvalue |= (data[1] & 0x3f) << 12;
		uvalue |= (data[0] & 0x3f) << 18;
d318 1
a318 1
	return (uvalue);
d321 3
a323 2
int
utf8_width(const u_char *udata)
d326 1
a326 1
	u_int			 uvalue;
d328 1
a328 1
	uvalue = utf8_combine(udata);
d332 1
a332 1
		if (uvalue < item->first)
d334 1
a334 1
		else if (uvalue > item->last)
@


1.2
log
@Constify utf8_width() function argument.
@
text
@d1 1
a1 1
/* $OpenBSD: utf8.c,v 1.1 2009/06/01 22:58:49 nicm Exp $ */
a200 1
void	utf8_split(u_int, u_char *);
a273 22
}

void
utf8_split(u_int uvalue, u_char *data)
{
	memset(data, 0xff, 4);

	if (uvalue <= 0x7f)
		data[0] = uvalue;
	else if (uvalue > 0x7f && uvalue <= 0x7ff) {
		data[0] = (uvalue >> 6) | 0xc0;
		data[1] = (uvalue & 0x3f) | 0x80;
	} else if (uvalue > 0x7ff && uvalue <= 0xffff) {
		data[0] = (uvalue >> 12) | 0xe0;
		data[1] = ((uvalue >> 6) & 0x3f) | 0x80;
		data[2] = (uvalue & 0x3f) | 0x80;
	} else if (uvalue > 0xffff && uvalue <= 0x10ffff) {
		data[0] = (uvalue >> 18) | 0xf0;
		data[1] = ((uvalue >> 12) & 0x3f) | 0x80;
		data[2] = ((uvalue >> 6) & 0x3f) | 0x80;
		data[3] = (uvalue & 0x3f) | 0x80;
	}
@


1.1
log
@Import tmux, a terminal multiplexor allowing (among other things) a single
terminal to be switched between several different windows and programs
displayed on one terminal be detached from one terminal and moved to another.

ok deraadt pirofti
@
text
@d1 1
a1 1
/* $OpenBSD$ */
d300 1
a300 1
utf8_width(u_char *udata)
@

