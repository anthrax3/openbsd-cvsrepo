head	1.6;
access;
symbols
	OPENBSD_4_6:1.2.0.4
	OPENBSD_4_6_BASE:1.2;
locks; strict;
comment	@ * @;


1.6
date	2009.11.04.22.44.53;	author nicm;	state dead;
branches;
next	1.5;

1.5
date	2009.11.04.20.50.11;	author nicm;	state Exp;
branches;
next	1.4;

1.4
date	2009.10.22.19.41.51;	author nicm;	state Exp;
branches;
next	1.3;

1.3
date	2009.10.10.15.03.01;	author nicm;	state Exp;
branches;
next	1.2;

1.2
date	2009.06.25.06.05.47;	author nicm;	state Exp;
branches;
next	1.1;

1.1
date	2009.06.01.22.58.49;	author nicm;	state Exp;
branches;
next	;


desc
@@


1.6
log
@Bye-bye buffer*.c.
@
text
@/* $OpenBSD: buffer-poll.c,v 1.5 2009/11/04 20:50:11 nicm Exp $ */

/*
 * Copyright (c) 2007 Nicholas Marriott <nicm@@users.sourceforge.net>
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF MIND, USE, DATA OR PROFITS, WHETHER
 * IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING
 * OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */

#include <sys/types.h>

#include <errno.h>
#include <event.h>
#include <unistd.h>

#include "tmux.h"

/* Fill buffers from socket based on poll results. */
int
buffer_poll(int fd, int events, struct buffer *in, struct buffer *out)
{
	ssize_t	n;

	if (in != NULL && events & EV_READ) {
		buffer_ensure(in, BUFSIZ);
		n = read(fd, BUFFER_IN(in), BUFFER_FREE(in));
		if (n == 0)
			return (-1);
		if (n == -1) {
			if (errno != EINTR && errno != EAGAIN)
				return (-1);
		} else
			buffer_add(in, n);
	}
	if (out != NULL && BUFFER_USED(out) > 0 && events & EV_WRITE) {
		n = write(fd, BUFFER_OUT(out), BUFFER_USED(out));
		if (n == -1) {
			if (errno != EINTR && errno != EAGAIN)
				return (-1);
		} else
			buffer_remove(out, n);
	}
	return (0);
}
@


1.5
log
@Initial changes to move tmux to libevent.

This moves the client-side loops are pretty much fully over to event-based only
(tmux.c and client.c) but server-side (server.c and friends) treats libevent as
a sort of clever poll, waking up after every event to run various things.

Moving the server stuff over to bufferevents and timers and so on will come
later.
@
text
@d1 1
a1 1
/* $OpenBSD: buffer-poll.c,v 1.4 2009/10/22 19:41:51 nicm Exp $ */
@


1.4
log
@Split the server code handling clients, jobs and windows off into separate
files from server.c (merging server-msg.c into the client file) and rather than
iterating over each set after poll(), allow a callback to be specified when the
fd is added and just walk once over the returned pollfds calling each callback
where needed.

More to come, getting this in so it is tested.
@
text
@d1 1
a1 1
/* $OpenBSD: buffer-poll.c,v 1.3 2009/10/10 15:03:01 nicm Exp $ */
d22 1
d33 1
a33 3
	if (events & (POLLERR|POLLNVAL))
		return (-1);
	if (in != NULL && events & POLLIN) {
d43 2
a44 3
	} else if (events & POLLHUP)
		return (-1);
	if (out != NULL && BUFFER_USED(out) > 0 && events & POLLOUT) {
@


1.3
log
@Rather than running status-left, status-right and window title #() with popen
immediately every redraw, queue them up and run them in the background,
starting each once every status-interval. The actual status line uses the
output from the last run.

This brings several advantages:

- tmux itself may be called from inside #() without causing the server to hang;
- likewise, sleep or similar doesn't cause the server to block;
- commands aren't run excessively often when redrawing;
- commands shared by status-left and status-right, or used multiple times, will
  only be run once.

run-shell and if-shell still use system()/popen() but will be changed over to
use this too later.
@
text
@d1 1
a1 1
/* $OpenBSD: buffer-poll.c,v 1.2 2009/06/25 06:05:47 nicm Exp $ */
d28 1
a28 1
buffer_poll(struct pollfd *pfd, struct buffer *in, struct buffer *out)
d32 1
a32 1
	if (pfd->revents & (POLLERR|POLLNVAL))
d34 1
a34 1
	if (in != NULL && pfd->revents & POLLIN) {
d36 1
a36 1
		n = read(pfd->fd, BUFFER_IN(in), BUFFER_FREE(in));
d44 1
a44 1
	} else if (pfd->revents & POLLHUP)
d46 2
a47 2
	if (out != NULL && BUFFER_USED(out) > 0 && pfd->revents & POLLOUT) {
		n = write(pfd->fd, BUFFER_OUT(out), BUFFER_USED(out));
@


1.2
log
@Nuke unused buffer functions. Found by lint.

Also remove some old debug output which was #if 0.
@
text
@d1 1
a1 1
/* $OpenBSD: buffer-poll.c,v 1.1 2009/06/01 22:58:49 nicm Exp $ */
d32 1
a32 1
	if (pfd->revents & (POLLERR|POLLNVAL|POLLHUP))
d34 1
a34 1
	if (pfd->revents & POLLIN) {
d44 3
a46 2
	}
	if (BUFFER_USED(out) > 0 && pfd->revents & POLLOUT) {
@


1.1
log
@Import tmux, a terminal multiplexor allowing (among other things) a single
terminal to be switched between several different windows and programs
displayed on one terminal be detached from one terminal and moved to another.

ok deraadt pirofti
@
text
@d1 1
a1 1
/* $OpenBSD$ */
a25 11
/* Set up pollfd for buffers. */
void
buffer_set(
    struct pollfd *pfd, int fd, unused struct buffer *in, struct buffer *out)
{
	pfd->fd = fd;
	pfd->events = POLLIN;
	if (BUFFER_USED(out) > 0)
		pfd->events |= POLLOUT;
}

a31 6
#if 0
	log_debug("buffer_poll (%ld): fd=%d, revents=%d; out=%zu in=%zu",
	    (long) getpid(),
	    pfd->fd, pfd->revents, BUFFER_USED(out), BUFFER_USED(in));
#endif

a36 3
#if 0
		log_debug("buffer_poll: fd=%d, read=%zd", pfd->fd, n);
#endif
a46 3
#if 0
		log_debug("buffer_poll: fd=%d, write=%zd", pfd->fd, n);
#endif
a53 20
}

/* Flush buffer output to socket. */
void
buffer_flush(int fd, struct buffer *in, struct buffer *out)
{
	struct pollfd	pfd;

	while (BUFFER_USED(out) > 0) {
		buffer_set(&pfd, fd, in, out);

		if (poll(&pfd, 1, INFTIM) == -1) {
			if (errno == EAGAIN || errno == EINTR)
				continue;
			fatal("poll failed");
		}

		if (buffer_poll(&pfd, in, out) != 0)
			break;
	}
@

