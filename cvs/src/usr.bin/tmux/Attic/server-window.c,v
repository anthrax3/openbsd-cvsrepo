head	1.40;
access;
symbols
	OPENBSD_5_8:1.35.0.4
	OPENBSD_5_8_BASE:1.35
	OPENBSD_5_7:1.31.0.2
	OPENBSD_5_7_BASE:1.31
	OPENBSD_5_6:1.31.0.4
	OPENBSD_5_6_BASE:1.31
	OPENBSD_5_5:1.29.0.4
	OPENBSD_5_5_BASE:1.29
	OPENBSD_5_4:1.28.0.2
	OPENBSD_5_4_BASE:1.28
	OPENBSD_5_3:1.27.0.2
	OPENBSD_5_3_BASE:1.27
	OPENBSD_5_2:1.26.0.2
	OPENBSD_5_2_BASE:1.26
	OPENBSD_5_1_BASE:1.23
	OPENBSD_5_1:1.23.0.2
	OPENBSD_5_0:1.21.0.2
	OPENBSD_5_0_BASE:1.21
	OPENBSD_4_9:1.20.0.2
	OPENBSD_4_9_BASE:1.20
	OPENBSD_4_8:1.16.0.2
	OPENBSD_4_8_BASE:1.16
	OPENBSD_4_7:1.14.0.2
	OPENBSD_4_7_BASE:1.14;
locks; strict;
comment	@ * @;


1.40
date	2015.08.29.08.30.54;	author nicm;	state dead;
branches;
next	1.39;
commitid	RrlCW4OYH7he0yBf;

1.39
date	2015.08.29.00.29.15;	author nicm;	state Exp;
branches;
next	1.38;
commitid	jhCDxn7bTHMNE4FM;

1.38
date	2015.08.28.16.10.46;	author nicm;	state Exp;
branches;
next	1.37;
commitid	5Oy3Fyd66jXdISPs;

1.37
date	2015.08.28.15.51.48;	author nicm;	state Exp;
branches;
next	1.36;
commitid	blWK8QcMFPW3AUtZ;

1.36
date	2015.08.28.07.55.43;	author nicm;	state Exp;
branches;
next	1.35;
commitid	c8XaDKhVdtv7tEYK;

1.35
date	2015.05.12.15.27.46;	author nicm;	state Exp;
branches;
next	1.34;
commitid	p5bGRCMzjTiUkjhK;

1.34
date	2015.04.24.23.17.11;	author nicm;	state Exp;
branches;
next	1.33;
commitid	iy4fcaIoXzxOx84I;

1.33
date	2015.04.22.15.30.11;	author nicm;	state Exp;
branches;
next	1.32;
commitid	0bmlELm9krdoS6OB;

1.32
date	2015.03.31.17.45.10;	author nicm;	state Exp;
branches;
next	1.31;
commitid	2uQloBaX92ri1PyE;

1.31
date	2014.04.17.07.36.45;	author nicm;	state Exp;
branches;
next	1.30;

1.30
date	2014.04.02.17.14.24;	author nicm;	state Exp;
branches;
next	1.29;

1.29
date	2014.02.14.12.44.45;	author nicm;	state Exp;
branches;
next	1.28;

1.28
date	2013.03.21.18.47.01;	author nicm;	state Exp;
branches;
next	1.27;

1.27
date	2012.10.25.11.16.53;	author nicm;	state Exp;
branches;
next	1.26;

1.26
date	2012.07.10.11.53.01;	author nicm;	state Exp;
branches;
next	1.25;

1.25
date	2012.07.08.07.27.32;	author nicm;	state Exp;
branches;
next	1.24;

1.24
date	2012.06.18.10.58.44;	author nicm;	state Exp;
branches;
next	1.23;

1.23
date	2012.01.21.06.13.16;	author nicm;	state Exp;
branches;
next	1.22;

1.22
date	2011.08.24.09.58.44;	author nicm;	state Exp;
branches;
next	1.21;

1.21
date	2011.07.03.19.07.54;	author nicm;	state Exp;
branches;
next	1.20;

1.20
date	2011.01.26.02.55.34;	author nicm;	state Exp;
branches;
next	1.19;

1.19
date	2010.12.21.22.37.59;	author nicm;	state Exp;
branches;
next	1.18;

1.18
date	2010.12.06.22.51.02;	author nicm;	state Exp;
branches;
next	1.17;

1.17
date	2010.08.11.07.34.43;	author nicm;	state Exp;
branches;
next	1.16;

1.16
date	2010.07.19.21.13.03;	author nicm;	state Exp;
branches;
next	1.15;

1.15
date	2010.06.21.01.27.46;	author nicm;	state Exp;
branches;
next	1.14;

1.14
date	2010.02.19.00.03.21;	author nicm;	state Exp;
branches;
next	1.13;

1.13
date	2009.12.03.22.50.10;	author nicm;	state Exp;
branches;
next	1.12;

1.12
date	2009.11.13.17.33.07;	author nicm;	state Exp;
branches;
next	1.11;

1.11
date	2009.11.06.10.42.06;	author nicm;	state Exp;
branches;
next	1.10;

1.10
date	2009.11.04.23.54.57;	author nicm;	state Exp;
branches;
next	1.9;

1.9
date	2009.11.04.22.43.11;	author nicm;	state Exp;
branches;
next	1.8;

1.8
date	2009.11.04.22.02.38;	author nicm;	state Exp;
branches;
next	1.7;

1.7
date	2009.11.04.21.47.42;	author nicm;	state Exp;
branches;
next	1.6;

1.6
date	2009.11.04.20.59.22;	author nicm;	state Exp;
branches;
next	1.5;

1.5
date	2009.11.04.20.50.11;	author nicm;	state Exp;
branches;
next	1.4;

1.4
date	2009.11.04.08.35.11;	author nicm;	state Exp;
branches;
next	1.3;

1.3
date	2009.10.28.22.53.14;	author nicm;	state Exp;
branches;
next	1.2;

1.2
date	2009.10.27.13.03.33;	author nicm;	state Exp;
branches;
next	1.1;

1.1
date	2009.10.22.19.41.51;	author nicm;	state Exp;
branches;
next	;


desc
@@


1.40
log
@Move alerts onto events rather than checking every loop.
@
text
@/* $OpenBSD: server-window.c,v 1.39 2015/08/29 00:29:15 nicm Exp $ */

/*
 * Copyright (c) 2009 Nicholas Marriott <nicm@@users.sourceforge.net>
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF MIND, USE, DATA OR PROFITS, WHETHER
 * IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING
 * OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */

#include <sys/types.h>

#include <event.h>
#include <stdlib.h>
#include <unistd.h>

#include "tmux.h"

int	server_window_check_bell(struct session *, struct winlink *);
int	server_window_check_activity(struct session *, struct winlink *);
int	server_window_check_silence(struct session *, struct winlink *);
void	ring_bell(struct session *);

/* Window functions that need to happen every loop. */
void
server_window_loop(void)
{
	struct window	*w;
	struct session	*s;
	struct winlink	*wl;

	RB_FOREACH(w, windows, &windows) {
		RB_FOREACH(s, sessions, &sessions) {
			RB_FOREACH(wl, winlinks, &s->windows) {
				if (wl->window != w)
					continue;

				if (server_window_check_bell(s, wl) ||
				    server_window_check_activity(s, wl) ||
				    server_window_check_silence(s, wl))
					server_status_session(s);
			}
		}
		check_window_name(w);
	}
}

/* Check for bell in window. */
int
server_window_check_bell(struct session *s, struct winlink *wl)
{
	struct client	*c;
	struct window	*w = wl->window;
	int		 action, visual;

	if (!(w->flags & WINDOW_BELL) || wl->flags & WINLINK_BELL)
		return (0);
	if (s->curw != wl || s->flags & SESSION_UNATTACHED)
		wl->flags |= WINLINK_BELL;
	if (s->flags & SESSION_UNATTACHED)
		return (0);
	if (s->curw->window == w)
		w->flags &= ~WINDOW_BELL;

	visual = options_get_number(&s->options, "visual-bell");
	action = options_get_number(&s->options, "bell-action");
	if (action == BELL_NONE)
		return (0);
	TAILQ_FOREACH(c, &clients, entry) {
		if (c->session != s || c->flags & CLIENT_CONTROL)
			continue;
		if (!visual) {
			if ((action == BELL_CURRENT &&
			    c->session->curw->window == w) ||
			    (action == BELL_OTHER &&
			    c->session->curw->window != w) ||
			    action == BELL_ANY)
				tty_bell(&c->tty);
			continue;
		}
		if (action == BELL_CURRENT && c->session->curw->window == w)
			status_message_set(c, "Bell in current window");
		else if (action == BELL_ANY || (action == BELL_OTHER &&
		    c->session->curw->window != w))
			status_message_set(c, "Bell in window %d", wl->idx);
	}

	return (1);
}

/* Check for activity in window. */
int
server_window_check_activity(struct session *s, struct winlink *wl)
{
	struct client	*c;
	struct window	*w = wl->window;

	if (s->curw->window == w)
		w->flags &= ~WINDOW_ACTIVITY;

	if (!(w->flags & WINDOW_ACTIVITY) || wl->flags & WINLINK_ACTIVITY)
		return (0);
	if (s->curw == wl && !(s->flags & SESSION_UNATTACHED))
		return (0);

	if (!options_get_number(&w->options, "monitor-activity"))
		return (0);

	if (options_get_number(&s->options, "bell-on-alert"))
		ring_bell(s);
	wl->flags |= WINLINK_ACTIVITY;

	if (options_get_number(&s->options, "visual-activity")) {
		TAILQ_FOREACH(c, &clients, entry) {
			if (c->session != s)
				continue;
			status_message_set(c, "Activity in window %d", wl->idx);
		}
	}

	return (1);
}

/* Check for silence in window. */
int
server_window_check_silence(struct session *s, struct winlink *wl)
{
	struct client	*c;
	struct window	*w = wl->window;
	struct timeval	 timer;
	int		 silence_interval, timer_difference;

	if (!(w->flags & WINDOW_SILENCE) || wl->flags & WINLINK_SILENCE)
		return (0);

	if (s->curw == wl && !(s->flags & SESSION_UNATTACHED)) {
		/*
		 * Reset the timer for this window if we've focused it.  We
		 * don't want the timer tripping as soon as we've switched away
		 * from this window.
		 */
		if (gettimeofday(&w->silence_timer, NULL) != 0)
			fatal("gettimeofday failed");

		return (0);
	}

	silence_interval = options_get_number(&w->options, "monitor-silence");
	if (silence_interval == 0)
		return (0);

	if (gettimeofday(&timer, NULL) != 0)
		fatal("gettimeofday");
	timer_difference = timer.tv_sec - w->silence_timer.tv_sec;
	if (timer_difference <= silence_interval)
		return (0);

	if (options_get_number(&s->options, "bell-on-alert"))
		ring_bell(s);
	wl->flags |= WINLINK_SILENCE;

	if (options_get_number(&s->options, "visual-silence")) {
		TAILQ_FOREACH(c, &clients, entry) {
			if (c->session != s)
				continue;
			status_message_set(c, "Silence in window %d", wl->idx);
		}
	}

	return (1);
}

/* Ring terminal bell. */
void
ring_bell(struct session *s)
{
	struct client	*c;

	TAILQ_FOREACH(c, &clients, entry) {
		if (c->session == s && !(c->flags & CLIENT_CONTROL))
			tty_bell(&c->tty);
	}
}
@


1.39
log
@Better take on reducing the name timer. Again check for name changes in
the main loop after events that may have changed the pane, but do so at
most once every 500 millis. If the pane changed too soon, use a timer to
ensure that a check happens later.
@
text
@d1 1
a1 1
/* $OpenBSD: server-window.c,v 1.37 2015/08/28 15:51:48 nicm Exp $ */
@


1.38
log
@Revert previous; we do need a timer, until I have a better idea. We
can't do the name check every loop, because that is too expensive, and
we can't make sure it only happens infrequently because we have no idea
when the next change will happen.
@
text
@d1 1
a1 1
/* $OpenBSD: server-window.c,v 1.36 2015/08/28 07:55:43 nicm Exp $ */
d52 1
@


1.37
log
@We now only checking for name changes when the active pane has changed,
but that can only happen when we have already been woken up by a read
event, so there is no need for a timer, we can just check the changed
flag on the end of that read event (we already loop over the windows to
check for bells etc anyway).
@
text
@a51 1
		check_window_name(w);
@


1.36
log
@Error messages should not have a trailing period.
@
text
@d1 1
a1 1
/* $OpenBSD: server-window.c,v 1.35 2015/05/12 15:27:46 nicm Exp $ */
d52 1
@


1.35
log
@Add bell-action "other" to pass through bells in all windows except the
current, suggested by Jan ONDREJ.
@
text
@d1 1
a1 1
/* $OpenBSD: server-window.c,v 1.34 2015/04/24 23:17:11 nicm Exp $ */
d150 1
a150 1
			fatal("gettimeofday failed.");
@


1.34
log
@Convert clients list into a TAILQ.
@
text
@d1 1
a1 1
/* $OpenBSD: server-window.c,v 1.33 2015/04/22 15:30:11 nicm Exp $ */
d80 5
a84 1
			if (c->session->curw->window == w || action == BELL_ANY)
d88 1
a88 1
		if (c->session->curw->window == w)
d90 2
a91 1
		else if (action == BELL_ANY)
@


1.33
log
@Change the windows array into an RB tree and fix some places where we
were only looking at the first winlink for a window in a session.
@
text
@d1 1
a1 1
/* $OpenBSD: server-window.c,v 1.32 2015/03/31 17:45:10 nicm Exp $ */
a60 1
	u_int		 i;
d76 2
a77 3
	for (i = 0; i < ARRAY_LENGTH(&clients); i++) {
		c = ARRAY_ITEM(&clients, i);
		if (c == NULL || c->session != s || c->flags & CLIENT_CONTROL)
a98 1
	u_int		 i;
d116 2
a117 3
		for (i = 0; i < ARRAY_LENGTH(&clients); i++) {
			c = ARRAY_ITEM(&clients, i);
			if (c == NULL || c->session != s)
a132 1
	u_int		 i;
d165 2
a166 3
		for (i = 0; i < ARRAY_LENGTH(&clients); i++) {
			c = ARRAY_ITEM(&clients, i);
			if (c == NULL || c->session != s)
a179 1
	u_int		 i;
d181 2
a182 3
	for (i = 0; i < ARRAY_LENGTH(&clients); i++) {
		c = ARRAY_ITEM(&clients, i);
		if (c != NULL && c->session == s && !(c->flags & CLIENT_CONTROL))
@


1.32
log
@Fix some format specifier nits, from Ben Boeckel.
@
text
@d1 1
a1 1
/* $OpenBSD: server-window.c,v 1.31 2014/04/17 07:36:45 nicm Exp $ */
d37 1
a38 7
	struct session	*s;
	u_int		 i;

	for (i = 0; i < ARRAY_LENGTH(&windows); i++) {
		w = ARRAY_ITEM(&windows, i);
		if (w == NULL)
			continue;
d40 1
d42 9
a50 8
			wl = session_has(s, w);
			if (wl == NULL)
				continue;

			if (server_window_check_bell(s, wl) ||
			    server_window_check_activity(s, wl) ||
			    server_window_check_silence(s, wl))
				server_status_session(s);
@


1.31
log
@Remove the monitor-content option and associated bits and bobs. It's
never worked very well. If there is a big demand for it to return, will
consider better ways to do it.
@
text
@d1 1
a1 1
/* $OpenBSD: server-window.c,v 1.30 2014/04/02 17:14:24 nicm Exp $ */
d93 1
a93 1
			status_message_set(c, "Bell in window %u", wl->idx);
d127 1
a127 1
			status_message_set(c, "Activity in window %u", wl->idx);
d178 1
a178 1
			status_message_set(c, "Silence in window %u", wl->idx);
@


1.30
log
@Use the same logic for bell with and without visual-bell, from Filip
Moc.
@
text
@d1 1
a1 1
/* $OpenBSD: server-window.c,v 1.29 2014/02/14 12:44:45 nicm Exp $ */
a29 2
int	server_window_check_content(
	    struct session *, struct winlink *, struct window_pane *);
d36 4
a39 5
	struct window		*w;
	struct winlink		*wl;
	struct window_pane	*wp;
	struct session		*s;
	u_int		 	 i;
a54 2
			TAILQ_FOREACH(wp, &w->panes, entry)
				server_window_check_content(s, wl, wp);
a178 42
		}
	}

	return (1);
}

/* Check for content change in window. */
int
server_window_check_content(
    struct session *s, struct winlink *wl, struct window_pane *wp)
{
	struct client	*c;
	struct window	*w = wl->window;
	u_int		 i;
	char		*found, *ptr;

	/* Activity flag must be set for new content. */
	if (s->curw->window == w)
		w->flags &= ~WINDOW_ACTIVITY;

	if (!(w->flags & WINDOW_ACTIVITY) || wl->flags & WINLINK_CONTENT)
		return (0);
	if (s->curw == wl && !(s->flags & SESSION_UNATTACHED))
		return (0);

	ptr = options_get_string(&w->options, "monitor-content");
	if (ptr == NULL || *ptr == '\0')
		return (0);
	if ((found = window_pane_search(wp, ptr, NULL)) == NULL)
		return (0);
	free(found);

	if (options_get_number(&s->options, "bell-on-alert"))
		ring_bell(s);
	wl->flags |= WINLINK_CONTENT;

	if (options_get_number(&s->options, "visual-content")) {
		for (i = 0; i < ARRAY_LENGTH(&clients); i++) {
			c = ARRAY_ITEM(&clients, i);
			if (c == NULL || c->session != s)
				continue;
			status_message_set(c, "Content in window %u", wl->idx);
@


1.29
log
@Do not need to call winlink_find_by_window, from Filip Moc.
@
text
@d1 1
a1 1
/* $OpenBSD: server-window.c,v 1.28 2013/03/21 18:47:01 nicm Exp $ */
d88 1
a88 1
		if (c == NULL || c->session != s || (c->flags & CLIENT_CONTROL))
d91 2
a92 1
			tty_bell(&c->tty);
@


1.28
log
@Add various checks to turn off bits that can't work in control mode
(such as lock).
@
text
@d1 1
a1 1
/* $OpenBSD: server-window.c,v 1.27 2012/10/25 11:16:53 nicm Exp $ */
d79 1
a79 1
	if (s->curw->window == wl->window)
d96 2
a97 4
		else if (action == BELL_ANY) {
			status_message_set(c, "Bell in window %u",
				winlink_find_by_window(&s->windows, w)->idx);
		}
d111 1
a111 1
	if (s->curw->window == wl->window)
d131 1
a131 2
			status_message_set(c, "Activity in window %u",
			    winlink_find_by_window(&s->windows, w)->idx);
d182 1
a182 2
			status_message_set(c, "Silence in window %u",
			    winlink_find_by_window(&s->windows, w)->idx);
d224 1
a224 2
			status_message_set(c, "Content in window %u",
			    winlink_find_by_window(&s->windows, w)->idx);
@


1.27
log
@Fix BELL_NONE which had been broken in some code reorganisation or other
also don't redraw unnecessarily. From Seiji Ohashi.
@
text
@d1 1
a1 1
/* $OpenBSD: server-window.c,v 1.26 2012/07/10 11:53:01 nicm Exp $ */
d88 1
a88 1
		if (c == NULL || c->session != s)
d245 1
a245 1
		if (c != NULL && c->session == s)
@


1.26
log
@xfree is not particularly helpful, remove it. From Thomas Adam.
@
text
@d1 1
a1 1
/* $OpenBSD: server-window.c,v 1.25 2012/07/08 07:27:32 nicm Exp $ */
d78 1
a78 1
		return (1);
d84 2
@


1.25
log
@Clear flags across all sessions, from Thomas Adam.
@
text
@d1 1
a1 1
/* $OpenBSD: server-window.c,v 1.24 2012/06/18 10:58:44 nicm Exp $ */
d22 1
d215 1
a215 1
	xfree(found);
@


1.24
log
@Tidy up bell code, from Thomas Adam.
@
text
@d1 1
a1 1
/* $OpenBSD: server-window.c,v 1.23 2012/01/21 06:13:16 nicm Exp $ */
a58 3

			if (!(s->flags & SESSION_UNATTACHED))
				w->flags &= ~(WINDOW_BELL|WINDOW_ACTIVITY);
d78 2
d110 3
d201 3
@


1.23
log
@Only hide flags on the current window when the session is attached, from
Roland Walker.
@
text
@d1 1
a1 1
/* $OpenBSD: server-window.c,v 1.22 2011/08/24 09:58:44 nicm Exp $ */
d79 2
d82 1
d84 7
a90 19
	switch (action) {
	case BELL_ANY:
		if (s->flags & SESSION_UNATTACHED)
			break;
		visual = options_get_number(&s->options, "visual-bell");
		for (i = 0; i < ARRAY_LENGTH(&clients); i++) {
			c = ARRAY_ITEM(&clients, i);
			if (c == NULL || c->session != s)
				continue;
			if (!visual) {
				tty_bell(&c->tty);
				continue;
			}
			if (c->session->curw->window == w) {
				status_message_set(c, "Bell in current window");
				continue;
			}
			status_message_set(c, "Bell in window %u",
			    winlink_find_by_window(&s->windows, w)->idx);
d92 1
a92 15
		break;
	case BELL_CURRENT:
		if (s->flags & SESSION_UNATTACHED)
			break;
		visual = options_get_number(&s->options, "visual-bell");
		for (i = 0; i < ARRAY_LENGTH(&clients); i++) {
			c = ARRAY_ITEM(&clients, i);
			if (c == NULL || c->session != s)
				continue;
			if (c->session->curw->window != w)
				continue;
			if (!visual) {
				tty_bell(&c->tty);
				continue;
			}
d94 3
a97 1
		break;
@


1.22
log
@Add a tty_bell wrapper function, from Dylan Alex Simon.
@
text
@d1 1
a1 1
/* $OpenBSD: server-window.c,v 1.21 2011/07/03 19:07:54 nicm Exp $ */
d59 3
a62 1
		w->flags &= ~(WINDOW_BELL|WINDOW_ACTIVITY);
d77 1
a77 1
	if (s->curw != wl)
d134 1
a134 1
	if (s->curw == wl)
d170 1
a170 1
	if (s->curw == wl) {
d222 1
a222 1
	if (s->curw == wl)
@


1.21
log
@Add an option to trigger the terminal bell when there is an alert, from
Marco Beck.
@
text
@d1 1
a1 1
/* $OpenBSD: server-window.c,v 1.20 2011/01/26 02:55:34 nicm Exp $ */
d89 1
a89 1
				tty_putcode(&c->tty, TTYC_BEL);
d111 1
a111 1
				tty_putcode(&c->tty, TTYC_BEL);
d257 1
a257 1
			tty_putcode(&c->tty, TTYC_BEL);
@


1.20
log
@Unused declaration.
@
text
@d1 1
a1 1
/* $OpenBSD: server-window.c,v 1.19 2010/12/21 22:37:59 nicm Exp $ */
d31 1
d138 2
d189 3
d230 2
d245 14
@


1.19
log
@Store sessions in an RB tree by name rather than a list, this is tidier
and allows them to easily be shown sorted in various lists
(list-sessions/choose-sessions).

Keep a session index which is used in a couple of places internally but
make it an ever-increasing number rather than filling in gaps with new
sessions.
@
text
@d1 1
a1 1
/* $OpenBSD: server-window.c,v 1.18 2010/12/06 22:51:02 nicm Exp $ */
a25 1
int	server_window_backoff(struct window_pane *);
@


1.18
log
@Add an option to alert (monitor) for silence (lack of activity) in a
window. From Thomas Adam.
@
text
@d1 1
a1 1
/* $OpenBSD: server-window.c,v 1.17 2010/08/11 07:34:43 nicm Exp $ */
d41 1
a41 1
	u_int		 	 i, j;
d48 1
a48 4
		for (j = 0; j < ARRAY_LENGTH(&sessions); j++) {
			s = ARRAY_ITEM(&sessions, j);
			if (s == NULL)
				continue;
@


1.17
log
@Change the way backoff works. Instead of stopping reading from the pty
when the client tty backs up too much, just stop updating the tty and
only update the internal screen. Then when the tty recovers, force a
redraw.

This prevents a dodgy client from causing other clients to go into
backoff while still allowing tmux to be responsive (locally) when seeing
lots of output.
@
text
@d1 1
a1 1
/* $OpenBSD: server-window.c,v 1.16 2010/07/19 21:13:03 nicm Exp $ */
d29 1
d57 2
a58 1
			    server_window_check_activity(s, wl))
d149 49
@


1.16
log
@Don't return if in the current window since we may want to report a bell
(if bell-action any/current), just clear the flag so the status line
doesn't show the bell.
@
text
@d1 1
a1 1
/* $OpenBSD: server-window.c,v 1.15 2010/06/21 01:27:46 nicm Exp $ */
a31 25
/* Check if this window should suspend reading. */
int
server_window_backoff(struct window_pane *wp)
{
	struct client	*c;
	u_int		 i;

	if (!window_pane_visible(wp))
		return (0);

	for (i = 0; i < ARRAY_LENGTH(&clients); i++) {
		c = ARRAY_ITEM(&clients, i);
		if (c == NULL || c->session == NULL)
			continue;
		if ((c->flags & (CLIENT_SUSPENDED|CLIENT_DEAD)) != 0)
			continue;
		if (c->session->curw->window != wp->window)
			continue;

		if (EVBUFFER_LENGTH(c->tty.event->output) > BACKOFF_THRESHOLD)
			return (1);
	}
	return (0);
}

a45 11

		TAILQ_FOREACH(wp, &w->panes, entry) {
			if (wp->fd == -1)
				continue;
			if (!(wp->flags & PANE_FREEZE)) {
				if (server_window_backoff(wp))
					bufferevent_disable(wp->event, EV_READ);
				else
					bufferevent_enable(wp->event, EV_READ);
			}
		}
@


1.15
log
@Having a list of winlinks->alerts for each session is stupid, just store
the alert flags directly in the winlink itself.
@
text
@d1 1
a1 1
/* $OpenBSD: server-window.c,v 1.14 2010/02/19 00:03:21 nicm Exp $ */
d112 2
a113 4
	if (s->curw == wl)
		return (0);

	wl->flags |= WINLINK_BELL;
@


1.14
log
@copy mode uses the real screen as backing and if it is updated while copying,
strange things can happen. So, freeze reading from the pty while in copy mode.
@
text
@d1 1
a1 1
/* $OpenBSD: server-window.c,v 1.13 2009/12/03 22:50:10 nicm Exp $ */
d27 2
a28 2
int	server_window_check_bell(struct session *, struct window *);
int	server_window_check_activity(struct session *, struct window *);
d30 1
a30 1
	    struct session *, struct window *, struct window_pane *);
d62 1
d85 4
a88 1
			if (s == NULL || !session_has(s, w))
d91 2
a92 2
			if (server_window_check_bell(s, w) ||
			    server_window_check_activity(s, w))
d95 1
a95 1
				server_window_check_content(s, w, wp);
d97 1
a97 1
		w->flags &= ~(WINDOW_BELL|WINDOW_ACTIVITY|WINDOW_CONTENT);
d103 1
a103 1
server_window_check_bell(struct session *s, struct window *w)
d106 1
d110 3
a112 1
	if (!(w->flags & WINDOW_BELL))
d115 1
a115 3
	if (session_alert_has_window(s, w, WINDOW_BELL))
		return (0);
	session_alert_add(s, w, WINDOW_BELL);
d163 1
a163 1
server_window_check_activity(struct session *s, struct window *w)
d166 1
d169 1
a169 1
	if (!(w->flags & WINDOW_ACTIVITY))
d171 1
a171 1
	if (s->curw->window == w)
d177 1
a177 3
	if (session_alert_has_window(s, w, WINDOW_ACTIVITY))
		return (0);
	session_alert_add(s, w, WINDOW_ACTIVITY);
a178 2
	if (s->flags & SESSION_UNATTACHED)
		return (0);
d195 1
a195 1
    struct session *s, struct window *w, struct window_pane *wp)
d198 1
d202 2
a203 1
	if (!(w->flags & WINDOW_ACTIVITY))	/* activity for new content */
d205 1
a205 1
	if (s->curw->window == w)
a210 4

	if (session_alert_has_window(s, w, WINDOW_CONTENT))
		return (0);

d215 2
a216 3
	session_alert_add(s, w, WINDOW_CONTENT);
	if (s->flags & SESSION_UNATTACHED)
		return (0);
@


1.13
log
@Massive spaces->tabs and trailing whitespace cleanup, hopefully for the last
time now I've configured emacs to make them displayed in really annoying
colours...
@
text
@d1 1
a1 1
/* $OpenBSD: server-window.c,v 1.12 2009/11/13 17:33:07 nicm Exp $ */
d72 3
a74 1
			if (wp->fd != -1) {
@


1.12
log
@Destroy panes immediately rather than checking them all every loop.
@
text
@d1 1
a1 1
/* $OpenBSD: server-window.c,v 1.11 2009/11/06 10:42:06 nicm Exp $ */
d84 1
a84 1
			
d124 1
a124 1
 			if (c->session->curw->window == w) {
d140 1
a140 1
 			if (c->session->curw->window != w)
d166 1
a166 1
 	if (!options_get_number(&w->options, "monitor-activity"))
d175 1
a175 1
 	if (options_get_number(&s->options, "visual-activity")) {
d196 1
a196 1
	
d211 1
a211 1
    	xfree(found);
d216 1
a216 1
 	if (options_get_number(&s->options, "visual-content")) {
@


1.11
log
@Don't try enable/disable the event if the window pane is dead (fd == -1), as
the event will have been freed.
@
text
@d1 1
a1 1
/* $OpenBSD: server-window.c,v 1.10 2009/11/04 23:54:57 nicm Exp $ */
a30 1
void	server_window_check_alive(struct window *);
a91 2

		server_window_check_alive(w);
a226 59
}

/* Check if window still exists. */
void
server_window_check_alive(struct window *w)
{
	struct window_pane	*wp, *wq;
	struct options		*oo = &w->options;
	struct session		*s;
	struct winlink		*wl;
	u_int		 	 i;
	int		 	 destroyed;

	destroyed = 1;

	wp = TAILQ_FIRST(&w->panes);
	while (wp != NULL) {
		wq = TAILQ_NEXT(wp, entry);
		/*
		 * If the pane has died and the remain-on-exit flag is not set,
		 * remove the pane; otherwise, if the flag is set, don't allow
		 * the window to be destroyed (or it'll close when the last
		 * pane dies).
		 */
		if (wp->fd == -1 && !options_get_number(oo, "remain-on-exit")) {
			layout_close_pane(wp);
			window_remove_pane(w, wp);
			server_redraw_window(w);
		} else 
			destroyed = 0;
		wp = wq;
	}

	if (!destroyed)
		return;

	for (i = 0; i < ARRAY_LENGTH(&sessions); i++) {
		s = ARRAY_ITEM(&sessions, i);
		if (s == NULL)
			continue;
		if (!session_has(s, w))
			continue;

	restart:
		/* Detach window and either redraw or kill clients. */
		RB_FOREACH(wl, winlinks, &s->windows) {
			if (wl->window != w)
				continue;
			if (session_detach(s, wl)) {
				server_destroy_session_group(s);
				break;
			}
			server_redraw_session(s);
			server_status_session_group(s);
			goto restart;
		}
	}

	recalculate_sizes();
@


1.10
log
@Change window name change to use a timer event rather than a gettimeofday()
check every loop.
@
text
@d1 1
a1 1
/* $OpenBSD: server-window.c,v 1.9 2009/11/04 22:43:11 nicm Exp $ */
d73 6
a78 4
			if (server_window_backoff(wp))
				bufferevent_disable(wp->event, EV_READ);
			else
				bufferevent_enable(wp->event, EV_READ);
@


1.9
log
@Convert the window pane (pty master side) fd over to use a bufferevent.

The evbuffer API is very similar to the existing tmux buffer API so this was
remarkably painless. Not many possible ways to do it, I suppose.
@
text
@d1 1
a1 1
/* $OpenBSD: server-window.c,v 1.8 2009/11/04 22:02:38 nicm Exp $ */
a93 2

	set_window_names();
@


1.8
log
@Switch window pane pipe redirect fd over to a bufferevent.
@
text
@d1 1
a1 1
/* $OpenBSD: server-window.c,v 1.7 2009/11/04 21:47:42 nicm Exp $ */
a32 29
/* Register windows for poll. */
void
server_window_prepare(void)
{
	struct window		*w;
	struct window_pane	*wp;
	u_int		 	 i;
	int			 events;

	for (i = 0; i < ARRAY_LENGTH(&windows); i++) {
		if ((w = ARRAY_ITEM(&windows, i)) == NULL)
			continue;

		TAILQ_FOREACH(wp, &w->panes, entry) {	
			if (wp->fd == -1)
				continue;
			events = 0;
			if (!server_window_backoff(wp))
				events |= EV_READ;
			if (BUFFER_USED(wp->out) > 0)
				events |= EV_WRITE;
			event_del(&wp->event);
			event_set(&wp->event,
			    wp->fd, events, server_window_callback, wp);
			event_add(&wp->event, NULL);
		}
	}
}

a57 18
/* Process a single window pane event. */
void
server_window_callback(int fd, short events, void *data)
{
	struct window_pane	*wp = data;

	if (wp->fd == -1)
		return;

	if (fd == wp->fd) {
		if (buffer_poll(fd, events, wp->in, wp->out) != 0) {
			close(wp->fd);
			wp->fd = -1;
		} else
			window_pane_parse(wp);
	}
}

d71 7
@


1.7
log
@Switch tty fds over to a bufferevent.
@
text
@d1 1
a1 1
/* $OpenBSD: server-window.c,v 1.6 2009/11/04 20:59:22 nicm Exp $ */
a57 10

			if (wp->pipe_fd == -1)
				continue;
			events = 0;
			if (BUFFER_USED(wp->pipe_buf) > 0)
				events |= EV_WRITE;
			event_del(&wp->pipe_event);
			event_set(&wp->pipe_event,
			    wp->pipe_fd, events, server_window_callback, wp);
			event_add(&wp->pipe_event, NULL);
a101 8
	}

	if (fd == wp->pipe_fd) {
		if (buffer_poll(fd, events, NULL, wp->pipe_buf) != 0) {
			buffer_destroy(wp->pipe_buf);
			close(wp->pipe_fd);
			wp->pipe_fd = -1;
		}
@


1.6
log
@A couple of minor cosmetic changes.
@
text
@d1 1
a1 1
/* $OpenBSD: server-window.c,v 1.5 2009/11/04 20:50:11 nicm Exp $ */
d90 2
a91 1
		if (BUFFER_USED(c->tty.out) > BACKOFF_THRESHOLD)
@


1.5
log
@Initial changes to move tmux to libevent.

This moves the client-side loops are pretty much fully over to event-based only
(tmux.c and client.c) but server-side (server.c and friends) treats libevent as
a sort of clever poll, waking up after every event to run various things.

Moving the server stuff over to bufferevents and timers and so on will come
later.
@
text
@d1 1
a1 1
/* $OpenBSD: server-window.c,v 1.4 2009/11/04 08:35:11 nicm Exp $ */
d51 1
a51 1
				events = EV_READ;
@


1.4
log
@Don't backoff based on suspended or deda clients as they are always likely to
have data backed up.
@
text
@d1 1
a1 1
/* $OpenBSD: server-window.c,v 1.3 2009/10/28 22:53:14 nicm Exp $ */
d21 1
d51 1
a51 1
				events |= POLLIN;
d53 3
a55 2
				events |= POLLOUT;
			server_poll_add(
d57 1
d63 3
a65 2
				events |= POLLOUT;
			server_poll_add(
d67 1
d98 1
a98 1
server_window_callback(int fd, int events, void *data)
@


1.3
log
@If any client currently displaying a window pane has more than 1 KB of output
buffered, don't accept any further data from the process running in the pane.

This makes tmux much more responsive when flooded with output, although other
buffers can still have an impact when running remotely.

Prompted by a query from Ranganathan Sankaralingam.
@
text
@d1 1
a1 1
/* $OpenBSD: server-window.c,v 1.2 2009/10/27 13:03:33 nicm Exp $ */
d80 2
@


1.2
log
@Move the poll registration functions into the server-*.c files.
@
text
@d1 1
a1 1
/* $OpenBSD: server-window.c,v 1.1 2009/10/22 19:41:51 nicm Exp $ */
d25 1
d48 3
a50 1
			events = POLLIN;
d65 22
@


1.1
log
@Split the server code handling clients, jobs and windows off into separate
files from server.c (merging server-msg.c into the client file) and rather than
iterating over each set after poll(), allow a callback to be specified when the
fd is added and just walk once over the returned pollfds calling each callback
where needed.

More to come, getting this in so it is tested.
@
text
@d1 1
a1 1
/* $OpenBSD: tmux.h,v 1.145 2009/10/21 20:11:47 nicm Exp $ */
d30 33
@

