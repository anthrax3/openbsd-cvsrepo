head	1.6;
access;
symbols
	OPENBSD_4_6:1.1.0.4
	OPENBSD_4_6_BASE:1.1;
locks; strict;
comment	@ * @;


1.6
date	2009.12.03.17.44.02;	author nicm;	state dead;
branches;
next	1.5;

1.5
date	2009.09.22.12.38.10;	author nicm;	state Exp;
branches;
next	1.4;

1.4
date	2009.09.21.14.56.03;	author nicm;	state Exp;
branches;
next	1.3;

1.3
date	2009.09.21.14.46.47;	author nicm;	state Exp;
branches;
next	1.2;

1.2
date	2009.08.04.18.45.57;	author nicm;	state Exp;
branches;
next	1.1;

1.1
date	2009.06.01.22.58.49;	author nicm;	state Exp;
branches;
next	;


desc
@@


1.6
log
@Eliminate duplicate code and ease the passage for server-wide options by adding
a -w flag to set-option and show-options and making setw and showw aliases to
set -w and show -w.

Note: setw and showw are still there, but now aliases for set -w and show -w.
@
text
@/* $OpenBSD: options-cmd.c,v 1.5 2009/09/22 12:38:10 nicm Exp $ */

/*
 * Copyright (c) 2008 Nicholas Marriott <nicm@@users.sourceforge.net>
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF MIND, USE, DATA OR PROFITS, WHETHER
 * IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING
 * OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */

#include <sys/types.h>

#include <stdlib.h>
#include <string.h>

#include "tmux.h"

const char *
set_option_print(const struct set_option_entry *entry, struct options_entry *o)
{
	static char	out[BUFSIZ];
	const char     *s;
	struct keylist *keylist;
	u_int		i;

	*out = '\0';
	switch (entry->type) {
		case SET_OPTION_STRING:
			xsnprintf(out, sizeof out, "\"%s\"", o->str);
			break;
		case SET_OPTION_NUMBER:
			xsnprintf(out, sizeof out, "%lld", o->num);
			break;
		case SET_OPTION_KEYS:
			keylist = o->data;
			for (i = 0; i < ARRAY_LENGTH(keylist); i++) {
				strlcat(out, key_string_lookup_key(
				    ARRAY_ITEM(keylist, i)), sizeof out);
				if (i != ARRAY_LENGTH(keylist) - 1)
					strlcat(out, ",", sizeof out);
			}
			break;
		case SET_OPTION_COLOUR:
			s = colour_tostring(o->num);
			xsnprintf(out, sizeof out, "%s", s);
			break;
		case SET_OPTION_ATTRIBUTES:
			s = attributes_tostring(o->num);
			xsnprintf(out, sizeof out, "%s", s);
			break;
		case SET_OPTION_FLAG:
			if (o->num)
				strlcpy(out, "on", sizeof out);
			else
				strlcpy(out, "off", sizeof out);
			break;
		case SET_OPTION_CHOICE:
			s = entry->choices[o->num];
			xsnprintf(out, sizeof out, "%s", s);
			break;
	}
	return (out);
}

void
set_option_string(struct cmd_ctx *ctx, struct options *oo,
    const struct set_option_entry *entry, char *value, int append)
{
	struct options_entry	*o;
	char			*oldvalue, *newvalue;

	if (value == NULL) {
		ctx->error(ctx, "empty value");
		return;
	}

	if (append) {
		oldvalue = options_get_string(oo, entry->name);
		xasprintf(&newvalue, "%s%s", oldvalue, value);
	} else
		newvalue = value;
		
	o = options_set_string(oo, entry->name, "%s", newvalue);
	ctx->info(
	    ctx, "set option: %s -> %s", o->name, set_option_print(entry, o));

	if (newvalue != value)
		xfree(newvalue);
}

void
set_option_number(struct cmd_ctx *ctx, struct options *oo,
    const struct set_option_entry *entry, char *value)
{
	struct options_entry	*o;
	long long		 number;
	const char     		*errstr;

	if (value == NULL) {
		ctx->error(ctx, "empty value");
		return;
	}

	number = strtonum(value, entry->minimum, entry->maximum, &errstr);
	if (errstr != NULL) {
		ctx->error(ctx, "value is %s: %s", errstr, value);
		return;
	}

	o = options_set_number(oo, entry->name, number);
	ctx->info(
	    ctx, "set option: %s -> %s", o->name, set_option_print(entry, o));
}

void
set_option_keys(struct cmd_ctx *ctx, struct options *oo,
    const struct set_option_entry *entry, char *value)
{
	struct options_entry	*o;
	struct keylist		*keylist;
	char			*copyvalue, *ptr, *str;
	int		 	 key;

	if (value == NULL) {
		ctx->error(ctx, "empty value");
		return;
	}

	keylist = xmalloc(sizeof *keylist);
	ARRAY_INIT(keylist);

	ptr = copyvalue = xstrdup(value);
	while ((str = strsep(&ptr, ",")) != NULL) {
		if ((key = key_string_lookup_string(str)) == KEYC_NONE) {
			xfree(keylist);
			ctx->error(ctx, "unknown key: %s", str);
			xfree(copyvalue);
			return;
		}
		ARRAY_ADD(keylist, key);
	}
	xfree(copyvalue);

	o = options_set_data(oo, entry->name, keylist, xfree);
	ctx->info(
	    ctx, "set option: %s -> %s", o->name, set_option_print(entry, o));
}

void
set_option_colour(struct cmd_ctx *ctx, struct options *oo,
    const struct set_option_entry *entry, char *value)
{
	struct options_entry	*o;
	int			 colour;

	if (value == NULL) {
		ctx->error(ctx, "empty value");
		return;
	}

	if ((colour = colour_fromstring(value)) == -1) {
		ctx->error(ctx, "bad colour: %s", value);
		return;
	}

	o = options_set_number(oo, entry->name, colour);
	ctx->info(
	    ctx, "set option: %s -> %s", o->name, set_option_print(entry, o));
}

void
set_option_attributes(struct cmd_ctx *ctx, struct options *oo,
    const struct set_option_entry *entry, char *value)
{
	struct options_entry	*o;
	int			 attr;

	if (value == NULL) {
		ctx->error(ctx, "empty value");
		return;
	}

	if ((attr = attributes_fromstring(value)) == -1) {
		ctx->error(ctx, "bad attributes: %s", value);
		return;
	}

	o = options_set_number(oo, entry->name, attr);
	ctx->info(
	    ctx, "set option: %s -> %s", o->name, set_option_print(entry, o));
}

void
set_option_flag(struct cmd_ctx *ctx, struct options *oo,
    const struct set_option_entry *entry, char *value)
{
	struct options_entry	*o;
	int			 flag;

	if (value == NULL || *value == '\0')
		flag = !options_get_number(oo, entry->name);
	else {
		if ((value[0] == '1' && value[1] == '\0') ||
		    strcasecmp(value, "on") == 0 ||
		    strcasecmp(value, "yes") == 0)
			flag = 1;
		else if ((value[0] == '0' && value[1] == '\0') ||
		    strcasecmp(value, "off") == 0 ||
		    strcasecmp(value, "no") == 0)
			flag = 0;
		else {
			ctx->error(ctx, "bad value: %s", value);
			return;
		}
	}

	o = options_set_number(oo, entry->name, flag);
	ctx->info(
	    ctx, "set option: %s -> %s", o->name, set_option_print(entry, o));
}

void
set_option_choice(struct cmd_ctx *ctx, struct options *oo,
    const struct set_option_entry *entry, char *value)
{
	struct options_entry	*o;
	const char     	       **choicep;
	int		 	 n, choice = -1;

	if (value == NULL) {
		ctx->error(ctx, "empty value");
		return;
	}

	n = 0;
	for (choicep = entry->choices; *choicep != NULL; choicep++) {
		n++;
		if (strncmp(*choicep, value, strlen(value)) != 0)
			continue;

		if (choice != -1) {
			ctx->error(ctx, "ambiguous option: %s", value);
			return;
		}
		choice = n - 1;
	}
	if (choice == -1) {
		ctx->error(ctx, "unknown option: %s", value);
		return;
	}

	o = options_set_number(oo, entry->name, choice);
	ctx->info(
	    ctx, "set option: %s -> %s", o->name, set_option_print(entry, o));
}
@


1.5
log
@Permit multiple prefix keys to be defined, separated by commas, for example:

set -g prefix ^a,^b

Any key in the list acts as the prefix. The send-prefix command always sends
the first key in the list.
@
text
@d1 1
a1 1
/* $OpenBSD: options-cmd.c,v 1.4 2009/09/21 14:56:03 nicm Exp $ */
@


1.4
log
@Use option print function for info messages as well.
@
text
@d1 1
a1 1
/* $OpenBSD: options-cmd.c,v 1.3 2009/09/21 14:46:47 nicm Exp $ */
d31 2
d42 8
a49 3
		case SET_OPTION_KEY:
			s = key_string_lookup_key(o->num);
			xsnprintf(out, sizeof out, "%s", s);
d124 1
a124 1
set_option_key(struct cmd_ctx *ctx, struct options *oo,
d128 3
a130 1
	int			 key;
d137 12
a148 3
	if ((key = key_string_lookup_string(value)) == KEYC_NONE) {
		ctx->error(ctx, "unknown key: %s", value);
		return;
d150 1
d152 1
a152 1
	o = options_set_number(oo, entry->name, key);
@


1.3
log
@Move common code from show-options and show-window-options into a function.
@
text
@d1 1
a1 1
/* $OpenBSD: options-cmd.c,v 1.2 2009/08/04 18:45:57 nicm Exp $ */
d70 2
a71 1
	char	*oldvalue, *newvalue;
d84 3
a86 2
	options_set_string(oo, entry->name, "%s", newvalue);
	ctx->info(ctx, "set option: %s -> %s", entry->name, newvalue);
d96 3
a98 2
	long long	number;
	const char     *errstr;
d110 4
a113 2
	options_set_number(oo, entry->name, number);
	ctx->info(ctx, "set option: %s -> %lld", entry->name, number);
d120 2
a121 1
	int	key;
d132 4
a135 3
	options_set_number(oo, entry->name, key);
	ctx->info(ctx,
	    "set option: %s -> %s", entry->name, key_string_lookup_key(key));
d142 2
a143 1
	int	colour;
d155 3
a157 3
	options_set_number(oo, entry->name, colour);
	ctx->info(ctx,
	    "set option: %s -> %s", entry->name, colour_tostring(colour));
d164 2
a165 1
	int	attr;
d177 3
a179 3
	options_set_number(oo, entry->name, attr);
	ctx->info(ctx,
	    "set option: %s -> %s", entry->name, attributes_tostring(attr));
d186 2
a187 1
	int	flag;
d206 3
a208 3
	options_set_number(oo, entry->name, flag);
	ctx->info(ctx,
	    "set option: %s -> %s", entry->name, flag ? "on" : "off");
d215 3
a217 2
	const char     **choicep;
	int		 n, choice = -1;
d241 3
a243 3
	options_set_number(oo, entry->name, choice);
	ctx->info(ctx,
	    "set option: %s -> %s", entry->name, entry->choices[choice]);
@


1.2
log
@Add a -a flag to set-option and set-window-option to append to an existing
string value, useful for terminal-overrides.
@
text
@d1 1
a1 1
/* $OpenBSD: options-cmd.c,v 1.1 2009/06/01 22:58:49 nicm Exp $ */
d25 40
@


1.1
log
@Import tmux, a terminal multiplexor allowing (among other things) a single
terminal to be switched between several different windows and programs
displayed on one terminal be detached from one terminal and moved to another.

ok deraadt pirofti
@
text
@d1 1
a1 1
/* $OpenBSD$ */
d28 1
a28 1
    const struct set_option_entry *entry, char *value)
d30 2
d37 11
a47 2
	options_set_string(oo, entry->name, "%s", value);
	ctx->info(ctx, "set option: %s -> %s", entry->name, value);
@

