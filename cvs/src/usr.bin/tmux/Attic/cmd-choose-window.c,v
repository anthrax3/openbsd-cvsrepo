head	1.23;
access;
symbols
	OPENBSD_5_1_BASE:1.18
	OPENBSD_5_1:1.18.0.6
	OPENBSD_5_0:1.18.0.4
	OPENBSD_5_0_BASE:1.18
	OPENBSD_4_9:1.18.0.2
	OPENBSD_4_9_BASE:1.18
	OPENBSD_4_8:1.14.0.2
	OPENBSD_4_8_BASE:1.14
	OPENBSD_4_7:1.12.0.2
	OPENBSD_4_7_BASE:1.12
	OPENBSD_4_6:1.1.0.4
	OPENBSD_4_6_BASE:1.1;
locks; strict;
comment	@ * @;


1.23
date	2012.07.08.16.04.38;	author nicm;	state dead;
branches;
next	1.22;

1.22
date	2012.06.25.14.27.25;	author nicm;	state Exp;
branches;
next	1.21;

1.21
date	2012.06.25.14.08.55;	author nicm;	state Exp;
branches;
next	1.20;

1.20
date	2012.05.29.08.15.45;	author nicm;	state Exp;
branches;
next	1.19;

1.19
date	2012.05.22.11.35.37;	author nicm;	state Exp;
branches;
next	1.18;

1.18
date	2011.01.04.00.42.46;	author nicm;	state Exp;
branches;
next	1.17;

1.17
date	2010.12.30.21.35.17;	author nicm;	state Exp;
branches;
next	1.16;

1.16
date	2010.12.20.00.03.55;	author nicm;	state Exp;
branches;
next	1.15;

1.15
date	2010.12.06.22.51.02;	author nicm;	state Exp;
branches;
next	1.14;

1.14
date	2010.06.21.01.27.46;	author nicm;	state Exp;
branches;
next	1.13;

1.13
date	2010.04.21.21.41.21;	author nicm;	state Exp;
branches;
next	1.12;

1.12
date	2009.12.03.22.50.10;	author nicm;	state Exp;
branches;
next	1.11;

1.11
date	2009.11.13.19.53.28;	author nicm;	state Exp;
branches;
next	1.10;

1.10
date	2009.10.10.10.02.48;	author nicm;	state Exp;
branches;
next	1.9;

1.9
date	2009.09.07.21.01.50;	author nicm;	state Exp;
branches;
next	1.8;

1.8
date	2009.08.25.13.32.14;	author nicm;	state Exp;
branches;
next	1.7;

1.7
date	2009.08.25.12.18.51;	author nicm;	state Exp;
branches;
next	1.6;

1.6
date	2009.08.04.14.28.23;	author nicm;	state Exp;
branches;
next	1.5;

1.5
date	2009.07.26.12.58.44;	author nicm;	state Exp;
branches;
next	1.4;

1.4
date	2009.07.19.13.21.40;	author nicm;	state Exp;
branches;
next	1.3;

1.3
date	2009.07.17.07.05.58;	author nicm;	state Exp;
branches;
next	1.2;

1.2
date	2009.07.13.23.11.35;	author nicm;	state Exp;
branches;
next	1.1;

1.1
date	2009.06.01.22.58.49;	author nicm;	state Exp;
branches;
next	;


desc
@@


1.23
log
@Add choose-tree command to show windows and sessions in the same
list. Change choose-window and -session to use the same code. From
Thomas Adam.
@
text
@/* $OpenBSD: cmd-choose-window.c,v 1.22 2012/06/25 14:27:25 nicm Exp $ */

/*
 * Copyright (c) 2009 Nicholas Marriott <nicm@@users.sourceforge.net>
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF MIND, USE, DATA OR PROFITS, WHETHER
 * IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING
 * OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */

#include <sys/types.h>

#include <ctype.h>

#include "tmux.h"

/*
 * Enter choice mode to choose a window.
 */

int	cmd_choose_window_exec(struct cmd *, struct cmd_ctx *);

void	cmd_choose_window_callback(struct window_choose_data *);
void	cmd_choose_window_free(struct window_choose_data *);

const struct cmd_entry cmd_choose_window_entry = {
	"choose-window", NULL,
	"F:t:", 0, 1,
	CMD_TARGET_WINDOW_USAGE " [-F format] [template]",
	0,
	NULL,
	NULL,
	cmd_choose_window_exec
};

int
cmd_choose_window_exec(struct cmd *self, struct cmd_ctx *ctx)
{
	struct args			*args = self->args;
	struct session			*s;
	struct winlink			*wl, *wm;
	const char			*template;
	char				*action;
	u_int			 	 idx, cur;

	if (ctx->curclient == NULL) {
		ctx->error(ctx, "must be run interactively");
		return (-1);
	}
	s = ctx->curclient->session;

	if ((wl = cmd_find_window(ctx, args_get(args, 't'), NULL)) == NULL)
		return (-1);

	if (window_pane_set_mode(wl->window->active, &window_choose_mode) != 0)
		return (0);

	if ((template = args_get(args, 'F')) == NULL)
		template = DEFAULT_WINDOW_TEMPLATE " \"#{pane_title}\"";

	if (args->argc != 0)
		action = xstrdup(args->argv[0]);
	else
		action = xstrdup("select-window -t '%%'");

	cur = idx = 0;
	RB_FOREACH(wm, winlinks, &s->windows) {
		if (wm == s->curw)
			cur = idx;
		idx++;

		window_choose_add_window(wl->window->active, ctx, s, wm,
		    template, action, idx);
	}
	xfree(action);

	window_choose_ready(wl->window->active,
	    cur, cmd_choose_window_callback, cmd_choose_window_free);

	return (0);
}

void
cmd_choose_window_callback(struct window_choose_data *cdata)
{
	struct session	*s;

	if (cdata == NULL)
		return;
	if (cdata->client->flags & CLIENT_DEAD)
		return;

	s = cdata->session;
	if (!session_alive(s))
		return;

	window_choose_ctx(cdata);
}

void
cmd_choose_window_free(struct window_choose_data *cdata)
{
	if (cdata == NULL)
		return;

	cdata->session->references--;
	cdata->client->references--;

	xfree(cdata->ft_template);
	xfree(cdata->command);
	format_free(cdata->ft);
	xfree(cdata);
}
@


1.22
log
@Provide common helper function for adding windows and sessions to choose
lists and expand %% in command before using it rather than at callback
time. From Thomas Adam.
@
text
@d1 1
a1 1
/* $OpenBSD: cmd-choose-window.c,v 1.21 2012/06/25 14:08:55 nicm Exp $ */
@


1.21
log
@Clean up and simplify the choose mode code, from Thomas Adam.
@
text
@d1 1
a1 1
/* $OpenBSD: cmd-choose-window.c,v 1.20 2012/05/29 08:15:45 nicm Exp $ */
a47 1
	struct window_choose_data	*cdata;
d51 1
d69 5
d80 4
a83 15
		cdata = window_choose_data_create(ctx);
		if (args->argc != 0)
			cdata->action = xstrdup(args->argv[0]);
		else
			cdata->action = xstrdup("select-window -t '%%'");

		cdata->idx = wm->idx;
		cdata->client->references++;
		cdata->session->references++;

		cdata->ft_template = xstrdup(template);
		format_add(cdata->ft, "line", "%u", idx);
		format_session(cdata->ft, s);
		format_winlink(cdata->ft, s, wm);
		format_window_pane(cdata->ft, wm->window->active);
a84 2
		window_choose_add(wl->window->active, cdata);
	}
a104 1
	xasprintf(&cdata->raw_format, "%s:%u", s->name, cdata->idx);
d118 1
a118 1
	xfree(cdata->action);
@


1.20
log
@Add pane title to choose-window template and use the right index for the
pane, from Romain Francoise.
@
text
@d1 1
a1 1
/* $OpenBSD: cmd-choose-window.c,v 1.19 2012/05/22 11:35:37 nicm Exp $ */
d31 2
a32 2
void	cmd_choose_window_callback(void *, int);
void	cmd_choose_window_free(void *);
a43 6
struct cmd_choose_window_data {
	struct client	*client;
	struct session	*session;
	char   		*template;
};

d48 1
a48 1
	struct cmd_choose_window_data	*cdata;
a50 1
	struct format_tree		*ft;
a51 1
	char				*line;
d75 15
a89 5
		ft = format_create();
		format_add(ft, "line", "%u", idx);
		format_session(ft, s);
		format_winlink(ft, s, wm);
		format_window_pane(ft, wm->window->active);
d91 1
a91 5
		line = format_expand(ft, template);
		window_choose_add(wl->window->active, wm->idx, "%s", line);

		xfree(line);
		format_free(ft);
a92 11

	cdata = xmalloc(sizeof *cdata);
	if (args->argc != 0)
		cdata->template = xstrdup(args->argv[0]);
	else
		cdata->template = xstrdup("select-window -t '%%'");
	cdata->session = s;
	cdata->session->references++;
	cdata->client = ctx->curclient;
	cdata->client->references++;

d94 1
a94 1
	    cur, cmd_choose_window_callback, cmd_choose_window_free, cdata);
d100 1
a100 1
cmd_choose_window_callback(void *data, int idx)
d102 1
a102 5
	struct cmd_choose_window_data	*cdata = data;
	struct session			*s = cdata->session;
	struct cmd_list			*cmdlist;
	struct cmd_ctx			 ctx;
	char				*target, *template, *cause;
d104 1
a104 3
	if (idx == -1)
		return;
	if (!session_alive(s))
d109 2
a110 11
	xasprintf(&target, "%s:%d", s->name, idx);
	template = cmd_template_replace(cdata->template, target, 1);
	xfree(target);

	if (cmd_string_parse(template, &cmdlist, &cause) != 0) {
		if (cause != NULL) {
			*cause = toupper((u_char) *cause);
			status_message_set(cdata->client, "%s", cause);
			xfree(cause);
		}
		xfree(template);
a111 9
	}
	xfree(template);

	ctx.msgdata = NULL;
	ctx.curclient = cdata->client;

	ctx.error = key_bindings_error;
	ctx.print = key_bindings_print;
	ctx.info = key_bindings_info;
d113 2
a114 4
	ctx.cmdclient = NULL;

	cmd_list_exec(cmdlist, &ctx);
	cmd_list_free(cmdlist);
d118 1
a118 1
cmd_choose_window_free(void *data)
d120 2
a121 1
	struct cmd_choose_window_data	*cdata = data;
d125 4
a128 1
	xfree(cdata->template);
@


1.19
log
@Switch all of the various choose- and list- commands over to the format
infrastructure, from Thomas Adam.
@
text
@d1 1
a1 1
/* $OpenBSD: cmd-choose-window.c,v 1.18 2011/01/04 00:42:46 nicm Exp $ */
d75 1
a75 1
		template = DEFAULT_WINDOW_TEMPLATE;
d87 1
d90 1
a90 1
		window_choose_add(wl->window->active, idx, "%s", line);
@


1.18
log
@Clean up and simplify tmux command argument parsing.

Originally, tmux commands were parsed in the client process into a
struct with the command data which was then serialised and sent to the
server to be executed. The parsing was later moved into the server (an
argv was sent from the client), but the parse step and intermediate
struct was kept.

This change removes that struct and the separate parse step. Argument
parsing and printing is now common to all commands (in arguments.c) with
each command left with just an optional check function (to validate the
arguments at parse time), the exec function and a function to set up any
key bindings (renamed from the old init function).

This is overall more simple and consistent.

There should be no changes to any commands behaviour or syntax although
as this touches every command please watch for any unexpected changes.
@
text
@d1 1
a1 1
/* $OpenBSD: cmd-choose-window.c,v 1.17 2010/12/30 21:35:17 nicm Exp $ */
d36 2
a37 2
	"t:", 0, 1,
	CMD_TARGET_WINDOW_USAGE " [template]",
d57 3
a59 1
	struct window			*w;
a60 2
	char				*flags, *title;
	const char			*left, *right;
d74 3
a78 2
		w = wm->window;

d83 7
a89 14
		flags = window_printable_flags(s, wm);
		title = w->active->screen->title;
		if (wm == wl)
			title = w->active->base.title;
		left = " \"";
		right = "\"";
		if (*title == '\0')
			left = right = "";

		window_choose_add(wl->window->active,
		    wm->idx, "%3d: %s%s [%ux%u] (%u panes%s)%s%s%s",
		    wm->idx, w->name, flags, w->sx, w->sy, window_count_panes(w),
		    w->active->fd == -1 ? ", dead" : "",
		    left, title, right);
d91 2
a92 1
		xfree(flags);
@


1.17
log
@Add a function to create window flags rather than doing the same thing
in two places. From Thomas Adam.
@
text
@d1 1
a1 1
/* $OpenBSD: cmd-choose-window.c,v 1.16 2010/12/20 00:03:55 nicm Exp $ */
d36 1
d38 4
a41 6
	CMD_ARG01, "",
	cmd_target_init,
	cmd_target_parse,
	cmd_choose_window_exec,
	cmd_target_free,
	cmd_target_print
d53 1
a53 1
	struct cmd_target_data		*data = self->data;
d68 1
a68 1
	if ((wl = cmd_find_window(ctx, data->target, NULL)) == NULL)
d101 2
a102 2
	if (data->arg != NULL)
		cdata->template = xstrdup(data->arg);
@


1.16
log
@Unify the way sessions are used by callbacks - store the address and use
the reference count, then check it is still on the global sessions list
in the callback.
@
text
@d1 1
a1 1
/* $OpenBSD: cmd-choose-window.c,v 1.15 2010/12/06 22:51:02 nicm Exp $ */
d60 1
a60 1
	char				 flag, *title;
d83 1
a83 14
		flag = ' ';
		if (wm->flags & WINLINK_ACTIVITY)
			flag = '#';
		else if (wm->flags & WINLINK_BELL)
			flag = '!';
		else if (wm->flags & WINLINK_CONTENT)
			flag = '+';
		else if (wm->flags & WINLINK_SILENCE)
			flag = '~';
		else if (wm == s->curw)
			flag = '*';
		else if (wm == TAILQ_FIRST(&s->lastw))
			flag = '-';

d93 2
a94 2
		    wm->idx, "%3d: %s%c [%ux%u] (%u panes%s)%s%s%s",
		    wm->idx, w->name, flag, w->sx, w->sy, window_count_panes(w),
d97 2
@


1.15
log
@Add an option to alert (monitor) for silence (lack of activity) in a
window. From Thomas Adam.
@
text
@d1 1
a1 1
/* $OpenBSD: cmd-choose-window.c,v 1.14 2010/06/21 01:27:46 nicm Exp $ */
d132 1
d139 2
a142 4
	if (cdata->session->flags & SESSION_DEAD)
		return;
	if (cdata->client->session != cdata->session)
		return;
d144 1
a144 1
	xasprintf(&target, "%s:%d", cdata->session->name, idx);
@


1.14
log
@Having a list of winlinks->alerts for each session is stupid, just store
the alert flags directly in the winlink itself.
@
text
@d1 1
a1 1
/* $OpenBSD: cmd-choose-window.c,v 1.13 2010/04/21 21:41:21 nicm Exp $ */
d90 2
@


1.13
log
@Mark zombie windows as dead in choose-window list, from Romain Francoise.
@
text
@d1 1
a1 1
/* $OpenBSD: cmd-choose-window.c,v 1.12 2009/12/03 22:50:10 nicm Exp $ */
d84 1
a84 1
		if (session_alert_has(s, wm, WINDOW_ACTIVITY))
d86 1
a86 1
		else if (session_alert_has(s, wm, WINDOW_BELL))
d88 1
a88 1
		else if (session_alert_has(s, wm, WINDOW_CONTENT))
@


1.12
log
@Massive spaces->tabs and trailing whitespace cleanup, hopefully for the last
time now I've configured emacs to make them displayed in really annoying
colours...
@
text
@d1 1
a1 1
/* $OpenBSD: cmd-choose-window.c,v 1.11 2009/11/13 19:53:28 nicm Exp $ */
d104 1
a104 1
		    wm->idx, "%3d: %s%c [%ux%u] (%u panes)%s%s%s",
d106 1
@


1.11
log
@Get rid of the ugly CMD_CHFLAG macro and use a const string (eg "dDU") in the
command entry structs and a couple of functions to check/set the flags.
@
text
@d1 1
a1 1
/* $OpenBSD: cmd-choose-window.c,v 1.10 2009/10/10 10:02:48 nicm Exp $ */
d119 1
a119 1
	window_choose_ready(wl->window->active, 
d122 1
a122 1
 	return (0);
d136 1
a136 1
		return;	
@


1.10
log
@Add "grouped sessions" which have independent name, options, current window and
so on but where the linked windows are synchronized (ie creating, killing
windows and so on are mirrored between the sessions). A grouped session may be
created by passing -t to new-session.

Had this around for a while, tested by a couple of people.
@
text
@d1 1
a1 1
/* $OpenBSD: cmd-choose-window.c,v 1.9 2009/09/07 21:01:50 nicm Exp $ */
d37 1
a37 1
	CMD_ARG01, 0,
@


1.9
log
@Reference count clients and sessions rather than relying on a saved index for
cmd-choose-*.
@
text
@d1 1
a1 1
/* $OpenBSD: cmd-choose-window.c,v 1.8 2009/08/25 13:32:14 nicm Exp $ */
d92 1
a92 1
		else if (wm == SLIST_FIRST(&s->lastw))
@


1.8
log
@These should #include <ctype.h>.
@
text
@d1 1
a1 1
/* $OpenBSD: cmd-choose-window.c,v 1.7 2009/08/25 12:18:51 nicm Exp $ */
d46 2
a47 2
	u_int		 client;
	u_int		 session;
a109 2
	if (session_index(s, &cdata->session) != 0)
		fatalx("session not found");
d114 4
a117 1
	cdata->client = server_client_index(ctx->curclient);
a128 2
	struct client			*c;
	struct session			*s;
d135 3
a137 4
	if (cdata->client > ARRAY_LENGTH(&clients) - 1)
		return;
	c = ARRAY_ITEM(&clients, cdata->client);
	if (cdata->session > ARRAY_LENGTH(&sessions) - 1)
d139 1
a139 2
	s = ARRAY_ITEM(&sessions, cdata->session);
	if (c->session != s)
d142 1
a142 1
	xasprintf(&target, "%s:%d", s->name, idx);
d149 1
a149 1
			status_message_set(c, "%s", cause);
d158 1
a158 1
	ctx.curclient = c;
d175 2
@


1.7
log
@Add a choose-client command and extend choose-{session,window} to accept a
template. After a choice is made, %% (or %1) in the template is replaced by the
name of the session, window or client suitable for -t and the result executed
as a command. So, for example, "choose-window "killw -t '%%'"" will kill the
selected window.

The defaults if no template is given are (as now) select-window for
choose-window, switch-client for choose-session, and detach-client for
choose-client (now bound to D).
@
text
@d1 1
a1 1
/* $OpenBSD: cmd-choose-window.c,v 1.6 2009/08/04 14:28:23 nicm Exp $ */
d20 2
@


1.6
log
@Show the bell/activity/current status and the window title in the choice list.
@
text
@d1 1
a1 1
/* $OpenBSD: cmd-choose-window.c,v 1.5 2009/07/26 12:58:44 nicm Exp $ */
d30 1
d34 2
a35 2
	CMD_TARGET_WINDOW_USAGE,
	0, 0,
d44 3
a46 1
	u_int	session;
d110 5
d116 2
a117 2
	window_choose_ready(
	    wl->window->active, cur, cmd_choose_window_callback, xfree, cdata);
d126 1
d128 42
d171 7
a177 6
	if (idx != -1 && cdata->session <= ARRAY_LENGTH(&sessions) - 1) {
		s = ARRAY_ITEM(&sessions, cdata->session);
		if (s != NULL && session_select(s, idx) == 0)
			server_redraw_session(s);
		recalculate_sizes();
	}
@


1.5
log
@Make all messages sent between the client and server fixed size.

This is the first of two changes to make the protocol more resilient and less
sensitive to other changes in the code, particularly with commands. The client
now packs argv into a buffer and sends it to the server for parsing, rather
than doing it itself and sending the parsed command data.

As a side-effect this also removes a lot of now-unused command marshalling
code.

Mixing a server without this change and a client with or vice versa will cause
tmux to hang or crash, please ensure that tmux is entirely killed before
upgrading.
@
text
@d1 1
a1 1
/* $OpenBSD: cmd-choose-window.c,v 1.4 2009/07/19 13:21:40 nicm Exp $ */
d55 2
d78 20
d99 3
a101 2
		    wm->idx, "%3d: %s [%ux%u] (%u panes)",
		    wm->idx, w->name, w->sx, w->sy, window_count_panes(w));
@


1.4
log
@Improved layout code.

Each window now has a tree of layout cells associated with it. In this tree,
each node is either a horizontal or vertical cell containing a list of other
cells running from left-to-right or top-to-bottom, or a leaf cell which is
associated with a pane.

The major functional changes are:

- panes may now be split arbitrarily both horizontally (splitw -h, C-b %) and
  vertically (splitw -v, C-b ");
- panes may be resized both horizontally and vertically (resizep -L/-R/-U/-D,
  bound to C-b left/right/up/down and C-b M-left/right/up/down);
- layouts are now applied and then may be modified by resizing or splitting
  panes, rather than being fixed and reapplied when the window is resized or
  panes are added;
- manual-vertical layout is no longer necessary, and active-only layout is gone
  (but may return in future);
- the main-pane layouts now reduce the size of the main pane to fit all panes
  if possible.

Thanks to all who tested.
@
text
@d1 1
a1 1
/* $OpenBSD: cmd-choose-window.c,v 1.3 2009/07/17 07:05:58 nicm Exp $ */
a37 2
	cmd_target_send,
	cmd_target_recv,
@


1.3
log
@A similar for fix for window_choose: don't rely on the callback always being
called to free data, have a separate free callback and call it from the mode
cleanup code.
@
text
@d1 1
a1 1
/* $OpenBSD: cmd-choose-window.c,v 1.2 2009/07/13 23:11:35 nicm Exp $ */
d79 2
a80 2
		    wm->idx, "%3d: %s [%ux%u %s] (%u panes)", wm->idx, w->name,
		    w->sx, w->sy, layout_name(w), window_count_panes(w));
@


1.2
log
@Having fixed flags for single-character getopt options is a bit hard to
maintain and is only going to get worse as more are used. So instead, add a new
uint64_t member to cmd_entry which is a bitmask of upper and lowercase options
accepted by the command.

This means new single character options can be used without the need to add it
explicitly to the list.
@
text
@d1 1
a1 1
/* $OpenBSD: cmd-choose-window.c,v 1.1 2009/06/01 22:58:49 nicm Exp $ */
d88 1
a88 1
	    wl->window->active, cur, cmd_choose_window_callback, cdata);
a104 1
	xfree(cdata);
@


1.1
log
@Import tmux, a terminal multiplexor allowing (among other things) a single
terminal to be switched between several different windows and programs
displayed on one terminal be detached from one terminal and moved to another.

ok deraadt pirofti
@
text
@d1 1
a1 1
/* $OpenBSD$ */
d34 1
a34 1
	0,
@

