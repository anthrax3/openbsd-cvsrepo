head	1.16;
access;
symbols
	OPENBSD_5_1_BASE:1.12
	OPENBSD_5_1:1.12.0.6
	OPENBSD_5_0:1.12.0.4
	OPENBSD_5_0_BASE:1.12
	OPENBSD_4_9:1.12.0.2
	OPENBSD_4_9_BASE:1.12
	OPENBSD_4_8:1.9.0.4
	OPENBSD_4_8_BASE:1.9
	OPENBSD_4_7:1.9.0.2
	OPENBSD_4_7_BASE:1.9
	OPENBSD_4_6:1.1.0.4
	OPENBSD_4_6_BASE:1.1;
locks; strict;
comment	@ * @;


1.16
date	2012.07.08.16.04.38;	author nicm;	state dead;
branches;
next	1.15;

1.15
date	2012.06.25.14.27.25;	author nicm;	state Exp;
branches;
next	1.14;

1.14
date	2012.06.25.14.08.55;	author nicm;	state Exp;
branches;
next	1.13;

1.13
date	2012.05.22.11.35.37;	author nicm;	state Exp;
branches;
next	1.12;

1.12
date	2011.01.04.00.42.46;	author nicm;	state Exp;
branches;
next	1.11;

1.11
date	2010.12.21.22.37.59;	author nicm;	state Exp;
branches;
next	1.10;

1.10
date	2010.12.19.22.35.54;	author nicm;	state Exp;
branches;
next	1.9;

1.9
date	2009.11.13.19.53.28;	author nicm;	state Exp;
branches;
next	1.8;

1.8
date	2009.10.10.10.02.48;	author nicm;	state Exp;
branches;
next	1.7;

1.7
date	2009.09.07.21.01.50;	author nicm;	state Exp;
branches;
next	1.6;

1.6
date	2009.08.25.13.32.14;	author nicm;	state Exp;
branches;
next	1.5;

1.5
date	2009.08.25.12.18.51;	author nicm;	state Exp;
branches;
next	1.4;

1.4
date	2009.07.26.12.58.44;	author nicm;	state Exp;
branches;
next	1.3;

1.3
date	2009.07.17.07.05.58;	author nicm;	state Exp;
branches;
next	1.2;

1.2
date	2009.07.13.23.11.35;	author nicm;	state Exp;
branches;
next	1.1;

1.1
date	2009.06.01.22.58.49;	author nicm;	state Exp;
branches;
next	;


desc
@@


1.16
log
@Add choose-tree command to show windows and sessions in the same
list. Change choose-window and -session to use the same code. From
Thomas Adam.
@
text
@/* $OpenBSD: cmd-choose-session.c,v 1.15 2012/06/25 14:27:25 nicm Exp $ */

/*
 * Copyright (c) 2009 Nicholas Marriott <nicm@@users.sourceforge.net>
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF MIND, USE, DATA OR PROFITS, WHETHER
 * IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING
 * OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */

#include <sys/types.h>

#include <ctype.h>

#include "tmux.h"

/*
 * Enter choice mode to choose a session.
 */

int	cmd_choose_session_exec(struct cmd *, struct cmd_ctx *);

void	cmd_choose_session_callback(struct window_choose_data *);
void	cmd_choose_session_free(struct window_choose_data *);

const struct cmd_entry cmd_choose_session_entry = {
	"choose-session", NULL,
	"F:t:", 0, 1,
	CMD_TARGET_WINDOW_USAGE " [-F format] [template]",
	0,
	NULL,
	NULL,
	cmd_choose_session_exec
};

int
cmd_choose_session_exec(struct cmd *self, struct cmd_ctx *ctx)
{
	struct args			*args = self->args;
	struct winlink			*wl;
	struct session			*s;
	char				*action;
	const char			*template;
	u_int			 	 idx, cur;

	if (ctx->curclient == NULL) {
		ctx->error(ctx, "must be run interactively");
		return (-1);
	}

	if ((wl = cmd_find_window(ctx, args_get(args, 't'), NULL)) == NULL)
		return (-1);

	if (window_pane_set_mode(wl->window->active, &window_choose_mode) != 0)
		return (0);

	if ((template = args_get(args, 'F')) == NULL)
		template = DEFAULT_SESSION_TEMPLATE;

	if (args->argc != 0)
		action = xstrdup(args->argv[0]);
	else
		action = xstrdup("switch-client -t '%%'");

	cur = idx = 0;
	RB_FOREACH(s, sessions, &sessions) {
		if (s == ctx->curclient->session)
			cur = idx;
		idx++;

		window_choose_add_session(wl->window->active,
		    ctx, s, template, action, idx);
	}
	xfree(action);

	window_choose_ready(wl->window->active,
	    cur, cmd_choose_session_callback, cmd_choose_session_free);

	return (0);
}

void
cmd_choose_session_callback(struct window_choose_data *cdata)
{
	if (cdata == NULL)
		return;
	if (cdata->client->flags & CLIENT_DEAD)
		return;

	window_choose_ctx(cdata);
}

void
cmd_choose_session_free(struct window_choose_data *cdata)
{
	if (cdata == NULL)
		return;

	cdata->client->references--;
	cdata->session->references--;

	xfree(cdata->command);
	xfree(cdata->ft_template);
	format_free(cdata->ft);
	xfree(cdata);
}
@


1.15
log
@Provide common helper function for adding windows and sessions to choose
lists and expand %% in command before using it rather than at callback
time. From Thomas Adam.
@
text
@d1 1
a1 1
/* $OpenBSD: cmd-choose-session.c,v 1.14 2012/06/25 14:08:55 nicm Exp $ */
@


1.14
log
@Clean up and simplify the choose mode code, from Thomas Adam.
@
text
@d1 1
a1 1
/* $OpenBSD: cmd-choose-session.c,v 1.13 2012/05/22 11:35:37 nicm Exp $ */
a47 1
	struct window_choose_data	*cdata;
d50 1
d68 5
d79 2
a80 15
		cdata = window_choose_data_create(ctx);
		if (args->argc != 0)
			cdata->action = xstrdup(args->argv[0]);
		else
			cdata->action = xstrdup("switch-client -t '%%'");
		cdata->idx = s->idx;

		cdata->client->references++;
		cdata->session->references++;

		cdata->ft_template = xstrdup(template);
		format_add(cdata->ft, "line", "%u", idx);
		format_session(cdata->ft, s);

		window_choose_add(wl->window->active, cdata);
d82 1
a92 2
	struct session	*s;

a97 5
	s = session_find_by_index(cdata->idx);
	if (s == NULL)
		return;

	cdata->raw_format = xstrdup(s->name);
d110 1
a111 1
	xfree(cdata->action);
@


1.13
log
@Switch all of the various choose- and list- commands over to the format
infrastructure, from Thomas Adam.
@
text
@d1 1
a1 1
/* $OpenBSD: cmd-choose-session.c,v 1.12 2011/01/04 00:42:46 nicm Exp $ */
d31 2
a32 2
void	cmd_choose_session_callback(void *, int);
void	cmd_choose_session_free(void *);
a43 5
struct cmd_choose_session_data {
	struct client	*client;
	char   		*template;
};

d48 1
a48 1
	struct cmd_choose_session_data	*cdata;
a50 1
	struct format_tree		*ft;
a51 1
	char				*line;
d74 13
a86 7
		ft = format_create();
		format_add(ft, "line", "%u", idx);
		format_session(ft, s);

		line = format_expand(ft, template);
		window_choose_add(wl->window->active, s->idx, "%s", line);
		xfree(line);
d88 1
a88 1
		format_free(ft);
a90 8
	cdata = xmalloc(sizeof *cdata);
	if (args->argc != 0)
		cdata->template = xstrdup(args->argv[0]);
	else
		cdata->template = xstrdup("switch-client -t '%%'");
	cdata->client = ctx->curclient;
	cdata->client->references++;

d92 1
a92 1
	    cur, cmd_choose_session_callback, cmd_choose_session_free, cdata);
d98 1
a98 1
cmd_choose_session_callback(void *data, int idx)
d100 1
a100 5
	struct cmd_choose_session_data	*cdata = data;
	struct session			*s;
	struct cmd_list			*cmdlist;
	struct cmd_ctx			 ctx;
	char				*template, *cause;
d102 1
a102 1
	if (idx == -1)
d107 1
a107 1
	s = session_find_by_index(idx);
a109 19
	template = cmd_template_replace(cdata->template, s->name, 1);

	if (cmd_string_parse(template, &cmdlist, &cause) != 0) {
		if (cause != NULL) {
			*cause = toupper((u_char) *cause);
			status_message_set(cdata->client, "%s", cause);
			xfree(cause);
		}
		xfree(template);
		return;
	}
	xfree(template);

	ctx.msgdata = NULL;
	ctx.curclient = cdata->client;

	ctx.error = key_bindings_error;
	ctx.print = key_bindings_print;
	ctx.info = key_bindings_info;
d111 2
a112 4
	ctx.cmdclient = NULL;

	cmd_list_exec(cmdlist, &ctx);
	cmd_list_free(cmdlist);
d116 1
a116 1
cmd_choose_session_free(void *data)
d118 2
a119 1
	struct cmd_choose_session_data	*cdata = data;
d122 5
a126 1
	xfree(cdata->template);
@


1.12
log
@Clean up and simplify tmux command argument parsing.

Originally, tmux commands were parsed in the client process into a
struct with the command data which was then serialised and sent to the
server to be executed. The parsing was later moved into the server (an
argv was sent from the client), but the parse step and intermediate
struct was kept.

This change removes that struct and the separate parse step. Argument
parsing and printing is now common to all commands (in arguments.c) with
each command left with just an optional check function (to validate the
arguments at parse time), the exec function and a function to set up any
key bindings (renamed from the old init function).

This is overall more simple and consistent.

There should be no changes to any commands behaviour or syntax although
as this touches every command please watch for any unexpected changes.
@
text
@d1 1
a1 1
/* $OpenBSD: cmd-choose-session.c,v 1.11 2010/12/21 22:37:59 nicm Exp $ */
d36 2
a37 2
	"t:", 0, 1,
	CMD_TARGET_WINDOW_USAGE " [template]",
d56 4
a59 3
	struct session_group		*sg;
	u_int			 	 idx, sgidx, cur;
	char				 tmp[64];
d72 3
d81 9
a89 12
		sg = session_group_find(s);
		if (sg == NULL)
			*tmp = '\0';
		else {
			sgidx = session_group_index(sg);
			xsnprintf(tmp, sizeof tmp, " (group %u)", sgidx);
		}

		window_choose_add(wl->window->active, s->idx,
		    "%s: %u windows [%ux%u]%s%s", s->name,
		    winlink_count(&s->windows), s->sx, s->sy,
		    tmp, s->flags & SESSION_UNATTACHED ? "" : " (attached)");
@


1.11
log
@Store sessions in an RB tree by name rather than a list, this is tidier
and allows them to easily be shown sorted in various lists
(list-sessions/choose-sessions).

Keep a session index which is used in a couple of places internally but
make it an ever-increasing number rather than filling in gaps with new
sessions.
@
text
@d1 1
a1 1
/* $OpenBSD: cmd-choose-session.c,v 1.10 2010/12/19 22:35:54 nicm Exp $ */
d36 1
d38 4
a41 6
	CMD_ARG01, "",
	cmd_target_init,
	cmd_target_parse,
	cmd_choose_session_exec,
	cmd_target_free,
	cmd_target_print
d52 1
a52 1
	struct cmd_target_data		*data = self->data;
d65 1
a65 1
	if ((wl = cmd_find_window(ctx, data->target, NULL)) == NULL)
d92 2
a93 2
	if (data->arg != NULL)
		cdata->template = xstrdup(data->arg);
@


1.10
log
@Don't nuke the index counter when a session group comes up.
@
text
@d1 1
a1 1
/* $OpenBSD: cmd-choose-session.c,v 1.9 2009/11/13 19:53:28 nicm Exp $ */
d58 1
a58 1
	u_int			 	 i, idx, sgidx, cur;
d73 1
a73 4
	for (i = 0; i < ARRAY_LENGTH(&sessions); i++) {
		s = ARRAY_ITEM(&sessions, i);
		if (s == NULL)
			continue;
d86 1
a86 1
		window_choose_add(wl->window->active, i,
d120 1
a120 3
	if ((u_int) idx > ARRAY_LENGTH(&sessions) - 1)
		return;
	s = ARRAY_ITEM(&sessions, idx);
@


1.9
log
@Get rid of the ugly CMD_CHFLAG macro and use a const string (eg "dDU") in the
command entry structs and a couple of functions to check/set the flags.
@
text
@d1 1
a1 1
/* $OpenBSD: cmd-choose-session.c,v 1.8 2009/10/10 10:02:48 nicm Exp $ */
d58 1
a58 1
	u_int			 	 i, idx, cur;
d85 2
a86 2
			idx = session_group_index(sg);
			xsnprintf(tmp, sizeof tmp, " (group %u)", idx);
@


1.8
log
@Add "grouped sessions" which have independent name, options, current window and
so on but where the linked windows are synchronized (ie creating, killing
windows and so on are mirrored between the sessions). A grouped session may be
created by passing -t to new-session.

Had this around for a while, tested by a couple of people.
@
text
@d1 1
a1 1
/* $OpenBSD: cmd-choose-session.c,v 1.7 2009/09/07 21:01:50 nicm Exp $ */
d37 1
a37 1
	CMD_ARG01, 0,
@


1.7
log
@Reference count clients and sessions rather than relying on a saved index for
cmd-choose-*.
@
text
@d1 1
a1 1
/* $OpenBSD: cmd-choose-session.c,v 1.6 2009/08/25 13:32:14 nicm Exp $ */
d57 1
d59 1
d81 8
d90 1
a90 1
		    "%s: %u windows [%ux%u]%s", s->name,
d92 1
a92 1
		    s->flags & SESSION_UNATTACHED ? "" : " (attached)");
@


1.6
log
@These should #include <ctype.h>.
@
text
@d1 1
a1 1
/* $OpenBSD: cmd-choose-session.c,v 1.5 2009/08/25 12:18:51 nicm Exp $ */
d46 1
a46 1
	u_int		 client;
d90 2
a91 1
	cdata->client = server_client_index(ctx->curclient);
a102 1
	struct client  			*c;
d110 1
a110 1
	if (cdata->client > ARRAY_LENGTH(&clients) - 1)
a111 1
	c = ARRAY_ITEM(&clients, cdata->client);
d123 1
a123 1
			status_message_set(c, "%s", cause);
d132 1
a132 1
	ctx.curclient = c;
d149 1
@


1.5
log
@Add a choose-client command and extend choose-{session,window} to accept a
template. After a choice is made, %% (or %1) in the template is replaced by the
name of the session, window or client suitable for -t and the result executed
as a command. So, for example, "choose-window "killw -t '%%'"" will kill the
selected window.

The defaults if no template is given are (as now) select-window for
choose-window, switch-client for choose-session, and detach-client for
choose-client (now bound to D).
@
text
@d1 1
a1 1
/* $OpenBSD: cmd-choose-session.c,v 1.4 2009/07/26 12:58:44 nicm Exp $ */
d20 2
@


1.4
log
@Make all messages sent between the client and server fixed size.

This is the first of two changes to make the protocol more resilient and less
sensitive to other changes in the code, particularly with commands. The client
now packs argv into a buffer and sends it to the server for parsing, rather
than doing it itself and sending the parsed command data.

As a side-effect this also removes a lot of now-unused command marshalling
code.

Mixing a server without this change and a client with or vice versa will cause
tmux to hang or crash, please ensure that tmux is entirely killed before
upgrading.
@
text
@d1 1
a1 1
/* $OpenBSD: cmd-choose-session.c,v 1.3 2009/07/17 07:05:58 nicm Exp $ */
d30 1
d34 2
a35 2
	CMD_TARGET_WINDOW_USAGE,
	0, 0,
d44 2
a45 1
	u_int	client;
d84 4
d90 2
a91 2
	window_choose_ready(
	    wl->window->active, cur, cmd_choose_session_callback, xfree, cdata);
d101 23
a123 7

	if (idx != -1 && cdata->client <= ARRAY_LENGTH(&clients) - 1) {
		c = ARRAY_ITEM(&clients, cdata->client);
		if (c != NULL && (u_int) idx <= ARRAY_LENGTH(&sessions) - 1) {
			c->session = ARRAY_ITEM(&sessions, idx);
			recalculate_sizes();
			server_redraw_client(c);
d125 2
d128 22
@


1.3
log
@A similar for fix for window_choose: don't rely on the callback always being
called to free data, have a separate free callback and call it from the mode
cleanup code.
@
text
@d1 1
a1 1
/* $OpenBSD: cmd-choose-session.c,v 1.2 2009/07/13 23:11:35 nicm Exp $ */
a37 2
	cmd_target_send,
	cmd_target_recv,
@


1.2
log
@Having fixed flags for single-character getopt options is a bit hard to
maintain and is only going to get worse as more are used. So instead, add a new
uint64_t member to cmd_entry which is a bitmask of upper and lowercase options
accepted by the command.

This means new single character options can be used without the need to add it
explicitly to the list.
@
text
@d1 1
a1 1
/* $OpenBSD: cmd-choose-session.c,v 1.1 2009/06/01 22:58:49 nicm Exp $ */
d87 1
a87 1
	    wl->window->active, cur, cmd_choose_session_callback, cdata);
a105 1
	xfree(cdata);
@


1.1
log
@Import tmux, a terminal multiplexor allowing (among other things) a single
terminal to be switched between several different windows and programs
displayed on one terminal be detached from one terminal and moved to another.

ok deraadt pirofti
@
text
@d1 1
a1 1
/* $OpenBSD$ */
d34 1
a34 1
	0,
@

