head	1.6;
access;
symbols
	OPENBSD_4_9:1.5.0.4
	OPENBSD_4_9_BASE:1.5
	OPENBSD_4_8:1.5.0.2
	OPENBSD_4_8_BASE:1.5
	OPENBSD_4_7:1.4.0.2
	OPENBSD_4_7_BASE:1.4;
locks; strict;
comment	@ * @;


1.6
date	2011.06.05.10.53.05;	author nicm;	state dead;
branches;
next	1.5;

1.5
date	2010.06.29.03.30.14;	author nicm;	state Exp;
branches;
next	1.4;

1.4
date	2010.01.08.17.44.27;	author nicm;	state Exp;
branches;
next	1.3;

1.3
date	2010.01.07.20.30.02;	author nicm;	state Exp;
branches;
next	1.2;

1.2
date	2010.01.07.20.28.01;	author nicm;	state Exp;
branches;
next	1.1;

1.1
date	2009.12.08.07.49.31;	author nicm;	state Exp;
branches;
next	;


desc
@@


1.6
log
@Get rid of the layout string code which tries to walk through the layout
hierarchy and instead just look at what panes are actually in the window.
@
text
@/* $OpenBSD: layout-string.c,v 1.5 2010/06/29 03:30:14 nicm Exp $ */

/*
 * Copyright (c) 2009 Nicholas Marriott <nicm@@users.sourceforge.net>
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF MIND, USE, DATA OR PROFITS, WHETHER
 * IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING
 * OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */

#include <sys/types.h>

#include <stdlib.h>
#include <string.h>

#include "tmux.h"

/*
 * Figure out the pane position based on a description. Fairly simple right
 * now, just understands a set of strings: left, right, top, bottom, top-left
 * top-right, bottom-left, bottom-right.
 */

struct layout_cell *layout_find_top(struct layout_cell *);
struct layout_cell *layout_find_bottom(struct layout_cell *);
struct layout_cell *layout_find_left(struct layout_cell *);
struct layout_cell *layout_find_right(struct layout_cell *);
struct layout_cell *layout_find_topleft(struct layout_cell *);
struct layout_cell *layout_find_topright(struct layout_cell *);
struct layout_cell *layout_find_bottomleft(struct layout_cell *);

/* Find the cell; returns NULL if string not understood. */
struct layout_cell *
layout_find_string(struct window *w, const char *s)
{
	struct layout_cell	*lc;

	lc = NULL;

	if (strcasecmp(s, "top") == 0)
		lc = layout_find_top(w->layout_root);
	else if (strcasecmp(s, "bottom") == 0)
		lc = layout_find_bottom(w->layout_root);
	else if (strcasecmp(s, "left") == 0)
		lc = layout_find_left(w->layout_root);
	else if (strcasecmp(s, "right") == 0)
		lc = layout_find_right(w->layout_root);
	else if (strcasecmp(s, "top-left") == 0)
		lc = layout_find_topleft(w->layout_root);
	else if (strcasecmp(s, "top-right") == 0)
		lc = layout_find_topright(w->layout_root);
	else if (strcasecmp(s, "bottom-left") == 0)
		lc = layout_find_bottomleft(w->layout_root);
	else if (strcasecmp(s, "bottom-right") == 0)
		lc = layout_find_bottomright(w->layout_root);

	if (lc == NULL || lc->type != LAYOUT_WINDOWPANE)
		return (NULL);
	return (lc);
}

/*
 * Find the top cell. Because splits in the same direction are stored as a
 * list, this is just the first in the list. Return NULL if no topmost cell.
 * For an unnested cell (not split), the top cell is always itself.
 */
struct layout_cell *
layout_find_top(struct layout_cell *lc)
{
	if (lc->type == LAYOUT_WINDOWPANE)
		return (lc);
	else if (lc->type == LAYOUT_TOPBOTTOM)
		return (TAILQ_FIRST(&lc->cells));
	return (NULL);
}

/*
 * Find the bottom cell. Similarly to the top cell, this is just the last in
 * the list.
 */
struct layout_cell *
layout_find_bottom(struct layout_cell *lc)
{
	if (lc->type == LAYOUT_WINDOWPANE)
		return (lc);
	else if (lc->type == LAYOUT_TOPBOTTOM)
		return (TAILQ_LAST(&lc->cells, layout_cells));
	return (NULL);
}

/* Find the left cell. */
struct layout_cell *
layout_find_left(struct layout_cell *lc)
{
	if (lc->type == LAYOUT_WINDOWPANE)
		return (lc);
	else if (lc->type == LAYOUT_LEFTRIGHT)
		return (TAILQ_FIRST(&lc->cells));
	return (NULL);
}

/* Find the right cell. */
struct layout_cell *
layout_find_right(struct layout_cell *lc)
{
	if (lc->type == LAYOUT_WINDOWPANE)
		return (lc);
	else if (lc->type == LAYOUT_LEFTRIGHT)
		return (TAILQ_LAST(&lc->cells, layout_cells));
	return (NULL);
}

/*
 * Find the top-left cell. This means recursing until there are no more moves
 * to be made.
 */
struct layout_cell *
layout_find_topleft(struct layout_cell *lc)
{
	if (lc->type == LAYOUT_WINDOWPANE)
		return (lc);
	lc = TAILQ_FIRST(&lc->cells);
	return (layout_find_topleft(lc));
}

/* Find the top-right cell. */
struct layout_cell *
layout_find_topright(struct layout_cell *lc)
{
	if (lc->type == LAYOUT_WINDOWPANE)
		return (lc);
	if (lc->type == LAYOUT_LEFTRIGHT)
		lc = TAILQ_LAST(&lc->cells, layout_cells);
	else
		lc = TAILQ_FIRST(&lc->cells);
	return (layout_find_topright(lc));
}

/* Find the bottom-left cell. */
struct layout_cell *
layout_find_bottomleft(struct layout_cell *lc)
{
	if (lc->type == LAYOUT_WINDOWPANE)
		return (lc);
	if (lc->type == LAYOUT_LEFTRIGHT)
		lc = TAILQ_FIRST(&lc->cells);
	else
		lc = TAILQ_LAST(&lc->cells, layout_cells);
	return (layout_find_bottomleft(lc));
}

/* Find the bottom-right cell. */
struct layout_cell *
layout_find_bottomright(struct layout_cell *lc)
{
	if (lc->type == LAYOUT_WINDOWPANE)
		return (lc);
	lc = TAILQ_LAST(&lc->cells, layout_cells);
	return (layout_find_bottomright(lc));
}
@


1.5
log
@Custom layouts. list-windows command displays the layout as a string (such as
"bb62,159x48,0,0{79x48,0,0,79x48,80,0}") and it can be applied to another
window (with the same number of panes or fewer) using select-layout.
@
text
@d1 1
a1 1
/* $OpenBSD: layout-string.c,v 1.4 2010/01/08 17:44:27 nicm Exp $ */
@


1.4
log
@$OpenBSD$ not $Id$
@
text
@d1 1
a1 1
/* $OpenBSD$ */
a38 1
struct layout_cell *layout_find_bottomright(struct layout_cell *);
@


1.3
log
@Fix this properly.
@
text
@d1 1
a1 1
/* $Id: layout-string.c,v 1.2 2010/01/07 20:28:01 nicm Exp $ */
@


1.2
log
@Don't return the root cell if the string doesn't match.
@
text
@d1 1
a1 1
/* $Id: layout-string.c,v 1.1 2009/12/08 07:49:31 nicm Exp $ */
d50 1
a50 1
		lc = layout_find_top(lc);
d52 1
a52 1
		lc = layout_find_bottom(lc);
d54 1
a54 1
		lc = layout_find_left(lc);
d56 1
a56 1
		lc = layout_find_right(lc);
d58 1
a58 1
		lc = layout_find_topleft(lc);
d60 1
a60 1
		lc = layout_find_topright(lc);
d62 1
a62 1
		lc = layout_find_bottomleft(lc);
d64 1
a64 1
		lc = layout_find_bottomright(lc);
@


1.1
log
@Permit panes to be referred to as "top", "bottom", "top-left" etc, if the right
pane can be identified.
@
text
@d1 1
a1 1
/* $Id: layout.c,v 1.17 2009/12/04 22:14:47 tcunha Exp $ */
d45 3
a47 1
	struct layout_cell	*lc = w->layout_root;
@

