head	1.10;
access;
symbols
	OPENBSD_4_6:1.1.0.4
	OPENBSD_4_6_BASE:1.1;
locks; strict;
comment	@ * @;


1.10
date	2009.10.06.07.19.32;	author nicm;	state dead;
branches;
next	1.9;

1.9
date	2009.09.10.17.16.24;	author nicm;	state Exp;
branches;
next	1.8;

1.8
date	2009.08.13.22.32.18;	author nicm;	state Exp;
branches;
next	1.7;

1.7
date	2009.08.13.22.11.43;	author nicm;	state Exp;
branches;
next	1.6;

1.6
date	2009.08.05.16.26.38;	author nicm;	state Exp;
branches;
next	1.5;

1.5
date	2009.07.28.07.03.32;	author nicm;	state Exp;
branches;
next	1.4;

1.4
date	2009.07.27.20.36.13;	author nicm;	state Exp;
branches;
next	1.3;

1.3
date	2009.07.27.19.29.35;	author nicm;	state Exp;
branches;
next	1.2;

1.2
date	2009.07.27.18.51.46;	author nicm;	state Exp;
branches;
next	1.1;

1.1
date	2009.06.01.22.58.49;	author nicm;	state Exp;
branches;
next	;


desc
@@


1.10
log
@Remove scroll mode which is now redundant, copy mode should be used instead.

The = key binding now does nothing.
@
text
@/* $OpenBSD: window-scroll.c,v 1.9 2009/09/10 17:16:24 nicm Exp $ */

/*
 * Copyright (c) 2007 Nicholas Marriott <nicm@@users.sourceforge.net>
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF MIND, USE, DATA OR PROFITS, WHETHER
 * IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING
 * OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */

#include <sys/types.h>

#include <string.h>

#include "tmux.h"

struct screen *window_scroll_init(struct window_pane *);
void	window_scroll_free(struct window_pane *);
void	window_scroll_resize(struct window_pane *, u_int, u_int);
void	window_scroll_key(struct window_pane *, struct client *, int);

void	window_scroll_redraw_screen(struct window_pane *);
void	window_scroll_write_line(
    	    struct window_pane *, struct screen_write_ctx *, u_int);
void	window_scroll_write_column(
    	    struct window_pane *, struct screen_write_ctx *, u_int);

void	window_scroll_scroll_up(struct window_pane *);
void	window_scroll_scroll_down(struct window_pane *);
void	window_scroll_scroll_left(struct window_pane *);
void	window_scroll_scroll_right(struct window_pane *);

const struct window_mode window_scroll_mode = {
	window_scroll_init,
	window_scroll_free,
	window_scroll_resize,
	window_scroll_key,
	NULL,
	NULL,
};

struct window_scroll_mode_data {
	struct screen	screen;

	struct mode_key_data	mdata;

	u_int		ox;
	u_int		oy;
};

struct screen *
window_scroll_init(struct window_pane *wp)
{
	struct window_scroll_mode_data	*data;
	struct screen			*s;
	struct screen_write_ctx	 	 ctx;
	u_int				 i;
	int				 keys;

	wp->modedata = data = xmalloc(sizeof *data);
	data->ox = 0;
	data->oy = 0;

	s = &data->screen;
	screen_init(s, screen_size_x(&wp->base), screen_size_y(&wp->base), 0);
	s->mode &= ~MODE_CURSOR;

	keys = options_get_number(&wp->window->options, "mode-keys");
	if (keys == MODEKEY_EMACS)
		mode_key_init(&data->mdata, &mode_key_tree_emacs_copy);
	else
		mode_key_init(&data->mdata, &mode_key_tree_vi_copy);

	screen_write_start(&ctx, NULL, s);
	for (i = 0; i < screen_size_y(s); i++)
		window_scroll_write_line(wp, &ctx, i);
	screen_write_stop(&ctx);

	return (s);
}

void
window_scroll_free(struct window_pane *wp)
{
	struct window_scroll_mode_data	*data = wp->modedata;

	screen_free(&data->screen);
	xfree(data);
}

void
window_scroll_pageup(struct window_pane *wp)
{
	struct window_scroll_mode_data	*data = wp->modedata;
	struct screen			*s = &data->screen;
	u_int				 n;

	n = 1;
	if (screen_size_y(s) > 2)
		n = screen_size_y(s) - 2;
	if (data->oy + n > screen_hsize(&wp->base))
		data->oy = screen_hsize(&wp->base);
	else
		data->oy += n;

	window_scroll_redraw_screen(wp);
}

void
window_scroll_resize(struct window_pane *wp, u_int sx, u_int sy)
{
	struct window_scroll_mode_data	*data = wp->modedata;
	struct screen			*s = &data->screen;
	struct screen_write_ctx	 	 ctx;
	u_int				 i;

	screen_resize(s, sx, sy);
	screen_write_start(&ctx, NULL, s);
	for (i = 0; i < screen_size_y(s); i++)
		window_scroll_write_line(wp, &ctx, i);
	screen_write_stop(&ctx);
}

void
window_scroll_key(struct window_pane *wp, unused struct client *c, int key)
{
	struct window_scroll_mode_data	*data = wp->modedata;
	struct screen			*s = &data->screen;
	u_int				 n;

	switch (mode_key_lookup(&data->mdata, key)) {
	case MODEKEYCOPY_CANCEL:
		window_pane_reset_mode(wp);
		break;
	case MODEKEYCOPY_LEFT:
		window_scroll_scroll_left(wp);
		break;
	case MODEKEYCOPY_RIGHT:
		window_scroll_scroll_right(wp);
		break;
	case MODEKEYCOPY_UP:
		window_scroll_scroll_up(wp);
		break;
	case MODEKEYCOPY_DOWN:
		window_scroll_scroll_down(wp);
		break;
	case MODEKEYCOPY_PREVIOUSPAGE:
		window_scroll_pageup(wp);
		break;
	case MODEKEYCOPY_NEXTPAGE:
		n = 1;
		if (screen_size_y(s) > 2)
			n = screen_size_y(s) - 2;
		if (data->oy < n)
			data->oy = 0;
		else
			data->oy -= n;
		window_scroll_redraw_screen(wp);
		break;
	case MODEKEYCOPY_HALFPAGEUP:
		n = screen_size_y(s) / 2;
		if (data->oy + n > screen_hsize(&wp->base))
			data->oy = screen_hsize(&wp->base);
		else
			data->oy += n;
		window_scroll_redraw_screen(wp);
		break;
	case MODEKEYCOPY_HALFPAGEDOWN:
		n = screen_size_y(s) / 2;
		if (data->oy < n)
			data->oy = 0;
		else
			data->oy -= n;
		window_scroll_redraw_screen(wp);
		break;
	default:
		break;
	}
}

void
window_scroll_write_line(
    struct window_pane *wp, struct screen_write_ctx *ctx, u_int py)
{
	struct window_scroll_mode_data	*data = wp->modedata;
	struct screen			*s = &data->screen;
	struct options			*oo = &wp->window->options;
	struct grid_cell		 gc;
	char				 hdr[32];
	size_t	 			 size;

	if (py == 0) {
		memcpy(&gc, &grid_default_cell, sizeof gc);
		size = xsnprintf(hdr, sizeof hdr,
		    "[%u,%u/%u]", data->ox, data->oy, screen_hsize(&wp->base));
		colour_set_fg(&gc, options_get_number(oo, "mode-fg"));
		colour_set_bg(&gc, options_get_number(oo, "mode-bg"));
		gc.attr |= options_get_number(oo, "mode-attr");
		screen_write_cursormove(ctx, screen_size_x(s) - size, 0);
		screen_write_puts(ctx, &gc, "%s", hdr);
		memcpy(&gc, &grid_default_cell, sizeof gc);
	} else
		size = 0;

	screen_write_cursormove(ctx, 0, py);
	screen_write_copy(ctx, &wp->base, data->ox, (screen_hsize(&wp->base) -
	    data->oy) + py, screen_size_x(s) - size, 1);
}

void
window_scroll_write_column(
    struct window_pane *wp, struct screen_write_ctx *ctx, u_int px)
{
	struct window_scroll_mode_data	*data = wp->modedata;
	struct screen			*s = &data->screen;

	screen_write_cursormove(ctx, px, 0);
	screen_write_copy(ctx, &wp->base, data->ox + px,
	    screen_hsize(&wp->base) - data->oy, 1, screen_size_y(s));
}

void
window_scroll_redraw_screen(struct window_pane *wp)
{
	struct window_scroll_mode_data	*data = wp->modedata;
	struct screen			*s = &data->screen;
	struct screen_write_ctx	 	 ctx;
	u_int				 i;

	screen_write_start(&ctx, wp, NULL);
	for (i = 0; i < screen_size_y(s); i++)
		window_scroll_write_line(wp, &ctx, i);
	screen_write_stop(&ctx);
}

void
window_scroll_scroll_up(struct window_pane *wp)
{
	struct window_scroll_mode_data	*data = wp->modedata;
	struct screen_write_ctx		 ctx;

	if (data->oy >= screen_hsize(&wp->base))
		return;
	data->oy++;

	screen_write_start(&ctx, wp, NULL);
	screen_write_cursormove(&ctx, 0, 0);
	screen_write_insertline(&ctx, 1);
	window_scroll_write_line(wp, &ctx, 0);
	window_scroll_write_line(wp, &ctx, 1);
	screen_write_stop(&ctx);
}

void
window_scroll_scroll_down(struct window_pane *wp)
{
	struct window_scroll_mode_data	*data = wp->modedata;
	struct screen			*s = &data->screen;
	struct screen_write_ctx		 ctx;

	if (data->oy == 0)
		return;
	data->oy--;

	screen_write_start(&ctx, wp, NULL);
	screen_write_cursormove(&ctx, 0, 0);
	screen_write_deleteline(&ctx, 1);
	window_scroll_write_line(wp, &ctx, screen_size_y(s) - 1);
	window_scroll_write_line(wp, &ctx, 0);
	screen_write_stop(&ctx);
}

void
window_scroll_scroll_right(struct window_pane *wp)
{
	struct window_scroll_mode_data	*data = wp->modedata;
	struct screen			*s = &data->screen;
	struct screen_write_ctx		 ctx;
	u_int		 		 i;

	if (data->ox >= SHRT_MAX)
		return;
	data->ox++;

	screen_write_start(&ctx, wp, NULL);
	for (i = 1; i < screen_size_y(s); i++) {
		screen_write_cursormove(&ctx, 0, i);
		screen_write_deletecharacter(&ctx, 1);
	}
	window_scroll_write_column(wp, &ctx, screen_size_x(s) - 1);
	window_scroll_write_line(wp, &ctx, 0);
	screen_write_stop(&ctx);
}

void
window_scroll_scroll_left(struct window_pane *wp)
{
	struct window_scroll_mode_data	*data = wp->modedata;
	struct screen			*s = &data->screen;
	struct screen_write_ctx		 ctx;
	u_int		 		 i;

	if (data->ox == 0)
		return;
	data->ox--;

	screen_write_start(&ctx, wp, NULL);
	for (i = 1; i < screen_size_y(s); i++) {
		screen_write_cursormove(&ctx, 0, i);
		screen_write_insertcharacter(&ctx, 1);
	}
	window_scroll_write_column(wp, &ctx, 0);
	window_scroll_write_line(wp, &ctx, 0);
	screen_write_stop(&ctx);
}
@


1.9
log
@Permit options such as status-bg to be configured using the entire 256 colour
palette by setting "colour0" to "colour255".
@
text
@d1 1
a1 1
/* $OpenBSD: window-scroll.c,v 1.8 2009/08/13 22:32:18 nicm Exp $ */
@


1.8
log
@vi(1)-style half page scroll in copy and scroll modes. Move the vi full page
scroll key to C-b instead of C-u and use C-u/C-d for half page scrolling with
vi keys. In emacs mode, half page scrolling is bound to M-Up and M-Down.

Suggested by merdely (about a year ago :-)).
@
text
@d1 1
a1 1
/* $OpenBSD: window-scroll.c,v 1.7 2009/08/13 22:11:43 nicm Exp $ */
d195 1
d204 3
a206 3
		gc.fg = options_get_number(&wp->window->options, "mode-fg");
		gc.bg = options_get_number(&wp->window->options, "mode-bg");
		gc.attr |= options_get_number(&wp->window->options, "mode-attr");
@


1.7
log
@Scroll by two less than the number of lines in the screen, like emacs, rather
than by the entire screen, to make it easier to pull things out from under the
line indicator. Suggested by claudio.
@
text
@d1 1
a1 1
/* $OpenBSD: window-scroll.c,v 1.6 2009/08/05 16:26:38 nicm Exp $ */
d162 16
@


1.6
log
@If colours are not supported by the terminal, try to emulate a coloured
background by setting or clearing the reverse attribute.

This makes a few applications which don't use the reverse attribute themselves
a little happier, and allows the status, message and mode options to have
default attributes and fg/bg options that work as expected when set as reverse.
@
text
@d1 1
a1 1
/* $OpenBSD: window-scroll.c,v 1.5 2009/07/28 07:03:32 nicm Exp $ */
d104 1
d106 4
a109 1
	if (data->oy + screen_size_y(s) > screen_hsize(&wp->base))
d112 1
a112 1
		data->oy += screen_size_y(s);
d137 1
d159 4
a162 1
		if (data->oy < screen_size_y(s))
d165 1
a165 1
			data->oy -= screen_size_y(s);
@


1.5
log
@Next step towards customisable mode keys: build each default table of keys into
a named tree on start and use that for lookups. Also add command to string
translation tables and modify list-keys to show the the mode key bindings (new
-t argument).
@
text
@d1 1
a1 1
/* $OpenBSD: window-scroll.c,v 1.4 2009/07/27 20:36:13 nicm Exp $ */
d179 2
a180 2
		gc.bg = options_get_number(&wp->window->options, "mode-fg");
		gc.fg = options_get_number(&wp->window->options, "mode-bg");
@


1.4
log
@Remove an unused entry in the mode keys command enum and rename
MODEKEYCOPY_QUIT to _CANCEL to match the others.
@
text
@d1 1
a1 1
/* $OpenBSD: window-scroll.c,v 1.3 2009/07/27 19:29:35 nicm Exp $ */
d78 1
a78 1
		mode_key_init(&data->mdata, mode_key_emacs_copy);
d80 1
a80 1
		mode_key_init(&data->mdata, mode_key_vi_copy);
@


1.3
log
@Change mode key bindings from big switches into a set of tables. Rather than
lumping them all together, split editing keys from those used in choice/more
mode and those for copy/scroll mode.

Tidier and clearer, and the first step towards customisable mode keys.
@
text
@d1 1
a1 1
/* $OpenBSD: window-scroll.c,v 1.2 2009/07/27 18:51:46 nicm Exp $ */
d135 1
a135 1
	case MODEKEYCOPY_QUIT:
@


1.2
log
@Get rid of empty mode_key_free function.
@
text
@d1 1
a1 1
/* $OpenBSD: window-scroll.c,v 1.1 2009/06/01 22:58:49 nicm Exp $ */
d66 1
d76 5
a80 2
	mode_key_init(&data->mdata,
	    options_get_number(&wp->window->options, "mode-keys"), 0);
d135 1
a135 1
	case MODEKEYCMD_QUIT:
d138 1
a138 1
	case MODEKEYCMD_LEFT:
d141 1
a141 1
	case MODEKEYCMD_RIGHT:
d144 1
a144 1
	case MODEKEYCMD_UP:
d147 1
a147 1
	case MODEKEYCMD_DOWN:
d150 1
a150 1
	case MODEKEYCMD_PREVIOUSPAGE:
d153 1
a153 1
	case MODEKEYCMD_NEXTPAGE:
@


1.1
log
@Import tmux, a terminal multiplexor allowing (among other things) a single
terminal to be switched between several different windows and programs
displayed on one terminal be detached from one terminal and moved to another.

ok deraadt pirofti
@
text
@d1 1
a1 1
/* $OpenBSD$ */
a89 2

	mode_key_free(&data->mdata);
@

