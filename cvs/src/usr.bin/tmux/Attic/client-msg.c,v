head	1.7;
access;
symbols
	OPENBSD_4_6:1.2.0.4
	OPENBSD_4_6_BASE:1.2;
locks; strict;
comment	@ * @;


1.7
date	2009.07.30.16.32.12;	author nicm;	state dead;
branches;
next	1.6;

1.6
date	2009.07.29.14.17.26;	author nicm;	state Exp;
branches;
next	1.5;

1.5
date	2009.07.26.12.58.44;	author nicm;	state Exp;
branches;
next	1.4;

1.4
date	2009.07.23.20.24.27;	author nicm;	state Exp;
branches;
next	1.3;

1.3
date	2009.07.21.18.52.03;	author nicm;	state Exp;
branches;
next	1.2;

1.2
date	2009.06.02.11.17.03;	author ray;	state Exp;
branches;
next	1.1;

1.1
date	2009.06.01.22.58.49;	author nicm;	state Exp;
branches;
next	;


desc
@@


1.7
log
@There aren't many client message types or code to handle them so get rid of the
lookup table and use a switch, merge the tiny handler functions into it, and
move the whole lot to client.c.

Also change client_msg_dispatch to consume as many messages as possible and
move the call to it to the right place so it checks for signals afterwards.

Prompted by suggestions from eric@@.
@
text
@/* $OpenBSD: client-msg.c,v 1.6 2009/07/29 14:17:26 nicm Exp $ */

/*
 * Copyright (c) 2007 Nicholas Marriott <nicm@@users.sourceforge.net>
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF MIND, USE, DATA OR PROFITS, WHETHER
 * IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING
 * OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */

#include <sys/types.h>

#include <stdint.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>

#include "tmux.h"

int	client_msg_fn_detach(struct hdr *, struct client_ctx *);
int	client_msg_fn_error(struct hdr *, struct client_ctx *);
int	client_msg_fn_shutdown(struct hdr *, struct client_ctx *);
int	client_msg_fn_exit(struct hdr *, struct client_ctx *);
int	client_msg_fn_exited(struct hdr *, struct client_ctx *);
int	client_msg_fn_suspend(struct hdr *, struct client_ctx *);

struct client_msg {
	enum msgtype   type;
	int	       (*fn)(struct hdr *, struct client_ctx *);
};
struct client_msg client_msg_table[] = {
	{ MSG_DETACH, client_msg_fn_detach },
	{ MSG_ERROR, client_msg_fn_error },
	{ MSG_EXIT, client_msg_fn_exit },
	{ MSG_EXITED, client_msg_fn_exited },
	{ MSG_SHUTDOWN, client_msg_fn_shutdown },
	{ MSG_SUSPEND, client_msg_fn_suspend },
};

int
client_msg_dispatch(struct client_ctx *cctx)
{
	struct hdr		 hdr;
	struct client_msg	*msg;
	u_int		 	 i;

	if (BUFFER_USED(cctx->srv_in) < sizeof hdr)
		return (1);
	memcpy(&hdr, BUFFER_OUT(cctx->srv_in), sizeof hdr);
	if (BUFFER_USED(cctx->srv_in) < (sizeof hdr) + hdr.size)
		return (1);
	buffer_remove(cctx->srv_in, sizeof hdr);

	for (i = 0; i < nitems(client_msg_table); i++) {
		msg = client_msg_table + i;
		if (msg->type == hdr.type)
			return (msg->fn(&hdr, cctx));
	}
	fatalx("unexpected message");
}

int
client_msg_fn_error(struct hdr *hdr, struct client_ctx *cctx)
{
	struct msg_print_data	data;

	if (hdr->size < sizeof data)
		fatalx("bad MSG_PRINT size");
	buffer_read(cctx->srv_in, &data, sizeof data);

	data.msg[(sizeof data.msg) - 1] = '\0';
	cctx->errstr = xstrdup(data.msg);

	return (-1);
}

int
client_msg_fn_detach(struct hdr *hdr, struct client_ctx *cctx)
{
	if (hdr->size != 0)
		fatalx("bad MSG_DETACH size");

	client_write_server(cctx, MSG_EXITING, NULL, 0);
	cctx->exittype = CCTX_DETACH;

	return (0);
}

int
client_msg_fn_shutdown(
    struct hdr *hdr, struct client_ctx *cctx)
{
	if (hdr->size != 0)
		fatalx("bad MSG_SHUTDOWN size");

	client_write_server(cctx, MSG_EXITING, NULL, 0);
	cctx->exittype = CCTX_SHUTDOWN;

	return (0);
}

int
client_msg_fn_exit(struct hdr *hdr, struct client_ctx *cctx)
{
	if (hdr->size != 0)
		fatalx("bad MSG_EXIT size");

	client_write_server(cctx, MSG_EXITING, NULL, 0);
	cctx->exittype = CCTX_EXIT;

	return (0);
}

int
client_msg_fn_exited(struct hdr *hdr, unused struct client_ctx *cctx)
{
	if (hdr->size != 0)
		fatalx("bad MSG_EXITED size");

	return (-1);
}

int
client_msg_fn_suspend(struct hdr *hdr, unused struct client_ctx *cctx)
{
	struct sigaction	 act;

	if (hdr->size != 0)
		fatalx("bad MSG_SUSPEND size");

	memset(&act, 0, sizeof act);
	sigemptyset(&act.sa_mask);
	act.sa_flags = SA_RESTART;

	act.sa_handler = SIG_DFL;
	if (sigaction(SIGTSTP, &act, NULL) != 0)
		fatal("sigaction failed");

	act.sa_handler = sighandler;
	if (sigaction(SIGCONT, &act, NULL) != 0)
		fatal("sigaction failed");

	kill(getpid(), SIGTSTP);

	return (0);
}
@


1.6
log
@Rename struct hdrtype to msgtype which is a better name and can be used even
when struct hdr disappears.
@
text
@d1 1
a1 1
/* $OpenBSD: client-msg.c,v 1.5 2009/07/26 12:58:44 nicm Exp $ */
@


1.5
log
@Make all messages sent between the client and server fixed size.

This is the first of two changes to make the protocol more resilient and less
sensitive to other changes in the code, particularly with commands. The client
now packs argv into a buffer and sends it to the server for parsing, rather
than doing it itself and sending the parsed command data.

As a side-effect this also removes a lot of now-unused command marshalling
code.

Mixing a server without this change and a client with or vice versa will cause
tmux to hang or crash, please ensure that tmux is entirely killed before
upgrading.
@
text
@d1 1
a1 1
/* $OpenBSD: client-msg.c,v 1.4 2009/07/23 20:24:27 nicm Exp $ */
d36 1
a36 1
	enum hdrtype   type;
@


1.4
log
@Tidy client message return slightly: convert flags into an enum, and merge
error string into struct client_ctx as well.
@
text
@d1 1
a1 1
/* $OpenBSD: client-msg.c,v 1.3 2009/07/21 18:52:03 nicm Exp $ */
d73 1
a73 1
	char	*errstr;
d75 3
a77 2
	if (hdr->size == SIZE_MAX)
		fatalx("bad MSG_ERROR size");
d79 2
a80 3
	errstr = xmalloc(hdr->size + 1);
	buffer_read(cctx->srv_in, errstr, hdr->size);
	errstr[hdr->size] = '\0';
a81 1
	cctx->errstr = errstr;
@


1.3
log
@Nix a few unused attributes on arguments which are no longer unused.
@
text
@d1 1
a1 1
/* $OpenBSD: client-msg.c,v 1.2 2009/06/02 11:17:03 ray Exp $ */
d28 6
a33 6
int	client_msg_fn_detach(struct hdr *, struct client_ctx *, char **);
int	client_msg_fn_error(struct hdr *, struct client_ctx *, char **);
int	client_msg_fn_shutdown(struct hdr *, struct client_ctx *, char **);
int	client_msg_fn_exit(struct hdr *, struct client_ctx *, char **);
int	client_msg_fn_exited(struct hdr *, struct client_ctx *, char **);
int	client_msg_fn_suspend(struct hdr *, struct client_ctx *, char **);
d37 1
a37 1
	int	       (*fn)(struct hdr *, struct client_ctx *, char **);
d49 1
a49 1
client_msg_dispatch(struct client_ctx *cctx, char **error)
d64 2
a65 5
		if (msg->type == hdr.type) {
			if (msg->fn(&hdr, cctx, error) != 0)
				return (-1);
			return (0);
		}
d71 1
a71 1
client_msg_fn_error(struct hdr *hdr, struct client_ctx *cctx, char **error)
d73 2
d78 3
a80 3
	*error = xmalloc(hdr->size + 1);
	buffer_read(cctx->srv_in, *error, hdr->size);
	(*error)[hdr->size] = '\0';
d82 1
d87 1
a87 2
client_msg_fn_detach(
    struct hdr *hdr, struct client_ctx *cctx, unused char **error)
d93 1
a93 1
	cctx->flags |= CCTX_DETACH;
d100 1
a100 1
    struct hdr *hdr, struct client_ctx *cctx, unused char **error)
d106 1
a106 1
	cctx->flags |= CCTX_SHUTDOWN;
d112 1
a112 2
client_msg_fn_exit(
    struct hdr *hdr, struct client_ctx *cctx, unused char **error)
d118 1
a118 1
	cctx->flags |= CCTX_EXIT;
d124 1
a124 2
client_msg_fn_exited(
    struct hdr *hdr, unused struct client_ctx *cctx, unused char **error)
d133 1
a133 2
client_msg_fn_suspend(
    struct hdr *hdr, unused struct client_ctx *cctx, unused char **error)
@


1.2
log
@Make code clearer:
-       if (hdr->size > SIZE_MAX - 1)
+       if (hdr->size == SIZE_MAX)

OK nicm@@
@
text
@d1 1
a1 1
/* $OpenBSD: client-msg.c,v 1.1 2009/06/01 22:58:49 nicm Exp $ */
d88 1
a88 1
    struct hdr *hdr, unused struct client_ctx *cctx, unused char **error)
d101 1
a101 1
    struct hdr *hdr, unused struct client_ctx *cctx, unused char **error)
d114 1
a114 1
    struct hdr *hdr, unused struct client_ctx *cctx, unused char **error)
@


1.1
log
@Import tmux, a terminal multiplexor allowing (among other things) a single
terminal to be switched between several different windows and programs
displayed on one terminal be detached from one terminal and moved to another.

ok deraadt pirofti
@
text
@d1 1
a1 1
/* $OpenBSD$ */
d76 1
a76 1
	if (hdr->size > SIZE_MAX - 1)
@

