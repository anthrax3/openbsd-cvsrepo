head	1.28;
access;
symbols
	OPENBSD_6_0:1.24.0.4
	OPENBSD_6_0_BASE:1.24
	OPENBSD_5_9:1.24.0.2
	OPENBSD_5_9_BASE:1.24
	OPENBSD_5_8:1.21.0.6
	OPENBSD_5_8_BASE:1.21
	OPENBSD_5_7:1.21.0.2
	OPENBSD_5_7_BASE:1.21
	OPENBSD_5_6:1.16.0.4
	OPENBSD_5_6_BASE:1.16
	OPENBSD_5_5:1.14.0.6
	OPENBSD_5_5_BASE:1.14
	OPENBSD_5_4:1.14.0.2
	OPENBSD_5_4_BASE:1.14
	OPENBSD_5_3:1.11.0.2
	OPENBSD_5_3_BASE:1.11
	OPENBSD_5_2:1.10.0.4
	OPENBSD_5_2_BASE:1.10
	OPENBSD_5_1_BASE:1.10
	OPENBSD_5_1:1.10.0.2
	OPENBSD_5_0:1.9.0.4
	OPENBSD_5_0_BASE:1.9
	OPENBSD_4_9:1.9.0.2
	OPENBSD_4_9_BASE:1.9
	OPENBSD_4_8:1.8.0.4
	OPENBSD_4_8_BASE:1.8
	OPENBSD_4_7:1.8.0.2
	OPENBSD_4_7_BASE:1.8
	OPENBSD_4_6:1.3.0.4
	OPENBSD_4_6_BASE:1.3;
locks; strict;
comment	@ * @;


1.28
date	2017.02.16.12.43.08;	author nicm;	state Exp;
branches;
next	1.27;
commitid	GSXBUYuB7NfRr3J3;

1.27
date	2017.02.08.16.45.18;	author nicm;	state Exp;
branches;
next	1.26;
commitid	ZNCPaF6tGzHeJGxd;

1.26
date	2016.10.13.20.27.27;	author nicm;	state Exp;
branches;
next	1.25;
commitid	txCyQ5BkKJtZRzfT;

1.25
date	2016.09.02.20.57.20;	author nicm;	state Exp;
branches;
next	1.24;
commitid	KNa3UznuiHkLoVpf;

1.24
date	2016.01.19.15.59.12;	author nicm;	state Exp;
branches;
next	1.23;
commitid	P3qmSOx6KrDBsb0c;

1.23
date	2015.11.13.12.18.52;	author nicm;	state Exp;
branches;
next	1.22;
commitid	3DFPxebuSqPBSCxc;

1.22
date	2015.11.13.08.09.28;	author nicm;	state Exp;
branches;
next	1.21;
commitid	3vFd8TIqn7NVGuk0;

1.21
date	2015.01.06.21.14.42;	author nicm;	state Exp;
branches;
next	1.20;
commitid	RNgfBTDVKGhXBFjs;

1.20
date	2014.12.01.22.22.14;	author nicm;	state Exp;
branches;
next	1.19;
commitid	hev6lHE9hYwACchm;

1.19
date	2014.11.12.22.59.45;	author nicm;	state Exp;
branches;
next	1.18;
commitid	2lKlMaJ0BoDl2RoZ;

1.18
date	2014.11.10.19.53.32;	author nicm;	state Exp;
branches;
next	1.17;
commitid	gFBLdG8vj0FhdFel;

1.17
date	2014.11.08.12.58.31;	author nicm;	state Exp;
branches;
next	1.16;
commitid	4AXMKGfY67pUX35V;

1.16
date	2014.04.17.14.45.49;	author nicm;	state Exp;
branches;
next	1.15;

1.15
date	2014.03.31.21.42.27;	author nicm;	state Exp;
branches;
next	1.14;

1.14
date	2013.03.25.10.05.35;	author nicm;	state Exp;
branches;
next	1.13;

1.13
date	2013.03.22.15.56.11;	author nicm;	state Exp;
branches;
next	1.12;

1.12
date	2013.03.22.15.51.54;	author nicm;	state Exp;
branches;
next	1.11;

1.11
date	2013.01.18.02.16.21;	author nicm;	state Exp;
branches;
next	1.10;

1.10
date	2012.01.29.21.31.11;	author nicm;	state Exp;
branches;
next	1.9;

1.9
date	2011.01.25.23.40.26;	author nicm;	state Exp;
branches;
next	1.8;

1.8
date	2009.12.03.22.50.10;	author nicm;	state Exp;
branches;
next	1.7;

1.7
date	2009.10.13.15.38.37;	author nicm;	state Exp;
branches;
next	1.6;

1.6
date	2009.07.13.10.43.52;	author nicm;	state Exp;
branches;
next	1.5;

1.5
date	2009.07.09.07.58.14;	author nicm;	state Exp;
branches;
next	1.4;

1.4
date	2009.07.09.00.29.32;	author nicm;	state Exp;
branches;
next	1.3;

1.3
date	2009.06.29.21.30.50;	author nicm;	state Exp;
branches;
next	1.2;

1.2
date	2009.06.24.22.04.18;	author nicm;	state Exp;
branches;
next	1.1;

1.1
date	2009.06.01.22.58.49;	author nicm;	state Exp;
branches;
next	;


desc
@@


1.28
log
@Handle insert cells when cursor at edge of screen correctly, and do a
full flush before insert.
@
text
@/* $OpenBSD: grid-view.c,v 1.27 2017/02/08 16:45:18 nicm Exp $ */

/*
 * Copyright (c) 2008 Nicholas Marriott <nicholas.marriott@@gmail.com>
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF MIND, USE, DATA OR PROFITS, WHETHER
 * IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING
 * OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */

#include <sys/types.h>

#include <string.h>

#include "tmux.h"

/*
 * Grid view functions. These work using coordinates relative to the visible
 * screen area.
 */

#define grid_view_x(gd, x) (x)
#define grid_view_y(gd, y) ((gd)->hsize + (y))

/* Get cell. */
void
grid_view_get_cell(struct grid *gd, u_int px, u_int py, struct grid_cell *gc)
{
	grid_get_cell(gd, grid_view_x(gd, px), grid_view_y(gd, py), gc);
}

/* Set cell. */
void
grid_view_set_cell(struct grid *gd, u_int px, u_int py,
    const struct grid_cell *gc)
{
	grid_set_cell(gd, grid_view_x(gd, px), grid_view_y(gd, py), gc);
}

/* Set cells. */
void
grid_view_set_cells(struct grid *gd, u_int px, u_int py,
    const struct grid_cell *gc, const char *s, size_t slen)
{
	grid_set_cells(gd, grid_view_x(gd, px), grid_view_y(gd, py), gc, s,
	    slen);
}

/* Clear into history. */
void
grid_view_clear_history(struct grid *gd, u_int bg)
{
	struct grid_line	*gl;
	u_int			 yy, last;

	/* Find the last used line. */
	last = 0;
	for (yy = 0; yy < gd->sy; yy++) {
		gl = &gd->linedata[grid_view_y(gd, yy)];
		if (gl->cellused != 0)
			last = yy + 1;
	}
	if (last == 0) {
		grid_view_clear(gd, 0, 0, gd->sx, gd->sy, bg);
		return;
	}

	/* Scroll the lines into the history. */
	for (yy = 0; yy < last; yy++) {
		grid_collect_history(gd, bg);
		grid_scroll_history(gd, bg);
	}
	if (last < gd->sy)
		grid_view_clear(gd, 0, 0, gd->sx, gd->sy - last, bg);
	gd->hscrolled = 0;
}

/* Clear area. */
void
grid_view_clear(struct grid *gd, u_int px, u_int py, u_int nx, u_int ny,
    u_int bg)
{
	px = grid_view_x(gd, px);
	py = grid_view_y(gd, py);

	grid_clear(gd, px, py, nx, ny, bg);
}

/* Scroll region up. */
void
grid_view_scroll_region_up(struct grid *gd, u_int rupper, u_int rlower)
{
	if (gd->flags & GRID_HISTORY) {
		grid_collect_history(gd, 8);
		if (rupper == 0 && rlower == gd->sy - 1)
			grid_scroll_history(gd, 8);
		else {
			rupper = grid_view_y(gd, rupper);
			rlower = grid_view_y(gd, rlower);
			grid_scroll_history_region(gd, rupper, rlower);
		}
	} else {
		rupper = grid_view_y(gd, rupper);
		rlower = grid_view_y(gd, rlower);
		grid_move_lines(gd, rupper, rupper + 1, rlower - rupper, 8);
	}
}

/* Scroll region down. */
void
grid_view_scroll_region_down(struct grid *gd, u_int rupper, u_int rlower)
{
	rupper = grid_view_y(gd, rupper);
	rlower = grid_view_y(gd, rlower);

	grid_move_lines(gd, rupper + 1, rupper, rlower - rupper, 8);
}

/* Insert lines. */
void
grid_view_insert_lines(struct grid *gd, u_int py, u_int ny, u_int bg)
{
	u_int	sy;

	py = grid_view_y(gd, py);

	sy = grid_view_y(gd, gd->sy);

	grid_move_lines(gd, py + ny, py, sy - py - ny, bg);
}

/* Insert lines in region. */
void
grid_view_insert_lines_region(struct grid *gd, u_int rlower, u_int py,
    u_int ny, u_int bg)
{
	u_int	ny2;

	rlower = grid_view_y(gd, rlower);

	py = grid_view_y(gd, py);

	ny2 = rlower + 1 - py - ny;
	grid_move_lines(gd, rlower + 1 - ny2, py, ny2, bg);
	grid_clear(gd, 0, py + ny2, gd->sx, ny - ny2, bg);
}

/* Delete lines. */
void
grid_view_delete_lines(struct grid *gd, u_int py, u_int ny, u_int bg)
{
	u_int	sy;

	py = grid_view_y(gd, py);

	sy = grid_view_y(gd, gd->sy);

	grid_move_lines(gd, py, py + ny, sy - py - ny, bg);
	grid_clear(gd, 0, sy - ny, gd->sx, py + ny - (sy - ny), bg);
}

/* Delete lines inside scroll region. */
void
grid_view_delete_lines_region(struct grid *gd, u_int rlower, u_int py,
    u_int ny, u_int bg)
{
	u_int	ny2;

	rlower = grid_view_y(gd, rlower);

	py = grid_view_y(gd, py);

	ny2 = rlower + 1 - py - ny;
	grid_move_lines(gd, py, py + ny, ny2, bg);
	grid_clear(gd, 0, py + ny2, gd->sx, ny - ny2, bg);
}

/* Insert characters. */
void
grid_view_insert_cells(struct grid *gd, u_int px, u_int py, u_int nx, u_int bg)
{
	u_int	sx;

	px = grid_view_x(gd, px);
	py = grid_view_y(gd, py);

	sx = grid_view_x(gd, gd->sx);

	if (px >= sx - 1)
		grid_clear(gd, px, py, 1, 1, bg);
	else
		grid_move_cells(gd, px + nx, px, py, sx - px - nx, bg);
}

/* Delete characters. */
void
grid_view_delete_cells(struct grid *gd, u_int px, u_int py, u_int nx, u_int bg)
{
	u_int	sx;

	px = grid_view_x(gd, px);
	py = grid_view_y(gd, py);

	sx = grid_view_x(gd, gd->sx);

	grid_move_cells(gd, px, px + nx, py, sx - px - nx, bg);
	grid_clear(gd, sx - nx, py, px + nx - (sx - nx), 1, bg);
}

/* Convert cells into a string. */
char *
grid_view_string_cells(struct grid *gd, u_int px, u_int py, u_int nx)
{
	px = grid_view_x(gd, px);
	py = grid_view_y(gd, py);

	return (grid_string_cells(gd, px, py, nx, NULL, 0, 0, 0));
}
@


1.27
log
@Collect sequences of printable ASCII characters and process them
together instead of handling them one by one. This is significantly
faster. Sequences are terminated when we reach the end of the line, fill
the internal buffer, or a different character is seen by the input
parser (an escape sequence, or UTF-8).

Rather than writing collected sequences out immediately, hold them until
it is necessary (another screen modification, or we consume all
available data). This means we can discard changes that would have no
effect (for example, lines that would just be scrolled off the screen or
cleared). This reduces the total amount of data we write out to the
terminal - not important for fast terminals, but a big help with slow
(like xterm).
@
text
@d1 1
a1 1
/* $OpenBSD: grid-view.c,v 1.26 2016/10/13 20:27:27 nicm Exp $ */
d197 1
a197 1
	if (px == sx - 1)
@


1.26
log
@Add support for BCE (background colour erase). This makes various escape
sequences (notable EL and ED but also IL, DL, ICH, DCH) create blank
cells using the current background colour rather than the default
colour.

On modern systems BCE doesn't really have many benefits, but most other
terminals now support it, some (lazy) applications rely on it, and it is
not hard to include now that we have pane background colours anyway.

Mostly written by Sean Haugh.
@
text
@d1 1
a1 1
/* $OpenBSD: grid-view.c,v 1.25 2016/09/02 20:57:20 nicm Exp $ */
d46 9
@


1.25
log
@Remember the number of lines scrolled into the history (versus cleared
into the history) and when resizing only use scrolled lines and not
cleared lines (which are probably not intended to reappear). From
Chaoren Lin.
@
text
@d1 1
a1 1
/* $OpenBSD: grid-view.c,v 1.24 2016/01/19 15:59:12 nicm Exp $ */
d50 1
a50 1
grid_view_clear_history(struct grid *gd)
d59 1
a59 1
		if (gl->cellsize != 0)
d62 2
a63 1
	if (last == 0)
d65 1
d69 2
a70 2
		grid_collect_history(gd);
		grid_scroll_history(gd);
d72 2
d79 2
a80 1
grid_view_clear(struct grid *gd, u_int px, u_int py, u_int nx, u_int ny)
d85 1
a85 1
	grid_clear(gd, px, py, nx, ny);
d93 1
a93 1
		grid_collect_history(gd);
d95 1
a95 1
			grid_scroll_history(gd);
d104 1
a104 1
		grid_move_lines(gd, rupper, rupper + 1, rlower - rupper);
d115 1
a115 1
	grid_move_lines(gd, rupper + 1, rupper, rlower - rupper);
d120 1
a120 1
grid_view_insert_lines(struct grid *gd, u_int py, u_int ny)
d128 1
a128 1
	grid_move_lines(gd, py + ny, py, sy - py - ny);
d134 1
a134 1
    u_int ny)
d143 2
a144 2
	grid_move_lines(gd, rlower + 1 - ny2, py, ny2);
	grid_clear(gd, 0, py + ny2, gd->sx, ny - ny2);
d149 1
a149 1
grid_view_delete_lines(struct grid *gd, u_int py, u_int ny)
d157 2
a158 2
	grid_move_lines(gd, py, py + ny, sy - py - ny);
	grid_clear(gd, 0, sy - ny, gd->sx, py + ny - (sy - ny));
d164 1
a164 1
    u_int ny)
d173 2
a174 2
	grid_move_lines(gd, py, py + ny, ny2);
	grid_clear(gd, 0, py + ny2, gd->sx, ny - ny2);
d179 1
a179 1
grid_view_insert_cells(struct grid *gd, u_int px, u_int py, u_int nx)
d189 1
a189 1
		grid_clear(gd, px, py, 1, 1);
d191 1
a191 1
		grid_move_cells(gd, px + nx, px, py, sx - px - nx);
d196 1
a196 1
grid_view_delete_cells(struct grid *gd, u_int px, u_int py, u_int nx)
d205 2
a206 2
	grid_move_cells(gd, px, px + nx, py, sx - px - nx);
	grid_clear(gd, sx - nx, py, px + nx - (sx - nx), 1);
@


1.24
log
@I no longer use my SourceForge address so replace it.
@
text
@d1 1
a1 1
/* $OpenBSD: grid-view.c,v 1.23 2015/11/13 12:18:52 nicm Exp $ */
d70 1
@


1.23
log
@Two spacing and spelling nits.
@
text
@d1 1
a1 1
/* $OpenBSD: grid-view.c,v 1.22 2015/11/13 08:09:28 nicm Exp $ */
d4 1
a4 1
 * Copyright (c) 2008 Nicholas Marriott <nicm@@users.sourceforge.net>
@


1.22
log
@Long overdue change to the way we store cells in the grid: now, instead
of storing a full grid_cell with UTF-8 data and everything, store a new
type grid_cell_entry. This can either be the cell itself (for ASCII
cells), or an offset into an extended array (per line) for UTF-8
data.

This avoid a large (8 byte) overhead on non-UTF-8 cells (by far the
majority for most users) without the complexity of the shadow array we
had before. Grid memory without any UTF-8 is about half.

The disadvantage that cells can no longer be modified in place and need
to be copied out of the grid and back but it turned out to be lot less
complicated than I expected.
@
text
@d1 1
a1 1
/* $OpenBSD: grid-view.c,v 1.21 2015/01/06 21:14:42 nicm Exp $ */
d33 1
a33 1
/* Get cel. */
@


1.21
log
@Revert to r1.16 since this is still clearly broken and I can't see how
right now.
@
text
@d1 1
a1 1
/* $OpenBSD: grid-view.c,v 1.16 2014/04/17 14:45:49 nicm Exp $ */
d33 3
a35 10
/* Get cell for reading. */
const struct grid_cell *
grid_view_peek_cell(struct grid *gd, u_int px, u_int py)
{
	return (grid_peek_cell(gd, grid_view_x(gd, px), grid_view_y(gd, py)));
}

/* Get cell for writing. */
struct grid_cell *
grid_view_get_cell(struct grid *gd, u_int px, u_int py)
d37 1
a37 1
	return (grid_get_cell(gd, grid_view_x(gd, px), grid_view_y(gd, py)));
d42 2
a43 2
grid_view_set_cell(
    struct grid *gd, u_int px, u_int py, const struct grid_cell *gc)
@


1.20
log
@Another fix for insertion from Balazs Kezes. On insertion, size the line
just enough for the inserted characters.
@
text
@d1 1
a1 1
/* $OpenBSD: grid-view.c,v 1.19 2014/11/12 22:59:45 nicm Exp $ */
d187 1
a187 4
	if (gd->linedata[py].cellsize + nx < gd->sx)
		sx = grid_view_x(gd, gd->linedata[py].cellsize + nx);
	else
		sx = grid_view_x(gd, gd->sx);
d204 1
a204 3
	sx = grid_view_x(gd, gd->linedata[py].cellsize);
	if (sx < px + nx)
		sx = px + nx;
@


1.19
log
@Restore change in r1.17 but add checks to prevent the line length
overflowing, from Balazs Kezes.
@
text
@d1 1
a1 1
/* $OpenBSD: grid-view.c,v 1.17 2014/11/08 12:58:31 nicm Exp $ */
d187 4
a190 3
	sx = grid_view_x(gd, gd->linedata[py].cellsize);
	if (sx < px + nx)
		sx = px + nx;
@


1.18
log
@Revert r1.17 as it breaks inserting in some cases.
@
text
@d1 1
a1 1
/* $OpenBSD: grid-view.c,v 1.16 2014/04/17 14:45:49 nicm Exp $ */
d187 3
a189 1
	sx = grid_view_x(gd, gd->sx);
d206 3
a208 1
	sx = grid_view_x(gd, gd->sx);
@


1.17
log
@Two improvements to reflow from Balazs Kezes:

- Don't extend the line to full width on insert/delete character which
  means leaves extra spaces when reflowing.

- Only mark a line wrapped when the cursor actually goes off the end,
  not on newlines which can be used for positioning.
@
text
@d187 1
a187 1
	sx = grid_view_x(gd, gd->linedata[py].cellsize);
d204 1
a204 1
	sx = grid_view_x(gd, gd->linedata[py].cellsize);
@


1.16
log
@Some more long lines.
@
text
@d1 1
a1 1
/* $OpenBSD: grid-view.c,v 1.15 2014/03/31 21:42:27 nicm Exp $ */
d187 1
a187 1
	sx = grid_view_x(gd, gd->sx);
d204 1
a204 1
	sx = grid_view_x(gd, gd->sx);
@


1.15
log
@GRID_DEBUG is no longer needed.
@
text
@d1 1
a1 1
/* $OpenBSD: grid-view.c,v 1.14 2013/03/25 10:05:35 nicm Exp $ */
d134 2
a135 1
grid_view_insert_lines_region(struct grid *gd, u_int rlower, u_int py, u_int ny)
d164 2
a165 1
grid_view_delete_lines_region(struct grid *gd, u_int rlower, u_int py, u_int ny)
@


1.14
log
@Preserve trailing spaces with capture-pane -J, from George Nachman.
@
text
@d1 1
a1 1
/* $OpenBSD: grid-view.c,v 1.13 2013/03/22 15:56:11 nicm Exp $ */
a61 2
	GRID_DEBUG(gd, "");

a82 2
	GRID_DEBUG(gd, "px=%u, py=%u, nx=%u, ny=%u", px, py, nx, ny);

a92 2
	GRID_DEBUG(gd, "rupper=%u, rlower=%u", rupper, rlower);

a112 2
	GRID_DEBUG(gd, "rupper=%u, rlower=%u", rupper, rlower);

a124 2
	GRID_DEBUG(gd, "py=%u, ny=%u", py, ny);

a137 2
	GRID_DEBUG(gd, "rlower=%u, py=%u, ny=%u", rlower, py, ny);

a152 2
	GRID_DEBUG(gd, "py=%u, ny=%u", py, ny);

a166 2
	GRID_DEBUG(gd, "rlower=%u, py=%u, ny=%u", rlower, py, ny);

a181 2
	GRID_DEBUG(gd, "px=%u, py=%u, nx=%u", px, py, nx);

a198 2
	GRID_DEBUG(gd, "px=%u, py=%u, nx=%u", px, py, nx);

a211 2
	GRID_DEBUG(gd, "px=%u, py=%u, nx=%u", px, py, nx);

@


1.13
log
@Add -C and -J to capture pane to escape control sequences and to join
wrapped line, based on a diff from George Nachman.
@
text
@d1 1
a1 1
/* $OpenBSD: grid-view.c,v 1.12 2013/03/22 15:51:54 nicm Exp $ */
d237 1
a237 1
	return (grid_string_cells(gd, px, py, nx, NULL, 0, 0));
@


1.12
log
@Add -e flag to capture-pane to include embedded ANSI SGR escape
sequences, from George Nachman.
@
text
@d1 1
a1 1
/* $OpenBSD: grid-view.c,v 1.11 2013/01/18 02:16:21 nicm Exp $ */
d237 1
a237 1
	return (grid_string_cells(gd, px, py, nx, NULL, 0));
@


1.11
log
@Rather than having two grids for each pane, one for ASCII and one for
UTF-8, collapse the two together. Simplifies the code at the expense of
more memory (which can probably be reduced again later).
@
text
@d1 1
a1 1
/* $OpenBSD: grid-view.c,v 1.10 2012/01/29 21:31:11 nicm Exp $ */
d237 1
a237 1
	return (grid_string_cells(gd, px, py, nx));
@


1.10
log
@Enforce history-limit option when clearing the screen, memory leak
spotted by R I Pienaar.
@
text
@d1 1
a1 1
/* $OpenBSD: grid-view.c,v 1.9 2011/01/25 23:40:26 nicm Exp $ */
a54 22
/* Get UTF-8 for reading. */
const struct grid_utf8 *
grid_view_peek_utf8(struct grid *gd, u_int px, u_int py)
{
	return (grid_peek_utf8(gd, grid_view_x(gd, px), grid_view_y(gd, py)));
}

/* Get UTF-8 for writing. */
struct grid_utf8 *
grid_view_get_utf8(struct grid *gd, u_int px, u_int py)
{
	return (grid_get_utf8(gd, grid_view_x(gd, px), grid_view_y(gd, py)));
}

/* Set UTF-8. */
void
grid_view_set_utf8(
    struct grid *gd, u_int px, u_int py, const struct grid_utf8 *gu)
{
	grid_set_utf8(gd, grid_view_x(gd, px), grid_view_y(gd, py), gu);
}

d68 1
a68 1
		if (gl->cellsize != 0 || gl->utf8size != 0)
@


1.9
log
@When clearing the entire screen, clear lines that are used into the
history like xterm does. Requested ages ago by someone I've forgotten.
@
text
@d1 1
a1 1
/* $OpenBSD: grid-view.c,v 1.8 2009/12/03 22:50:10 nicm Exp $ */
d97 2
a98 1
	for (yy = 0; yy < last; yy++)
d100 1
@


1.8
log
@Massive spaces->tabs and trailing whitespace cleanup, hopefully for the last
time now I've configured emacs to make them displayed in really annoying
colours...
@
text
@d1 1
a1 1
/* $OpenBSD: grid-view.c,v 1.7 2009/10/13 15:38:37 nicm Exp $ */
d75 24
@


1.7
log
@Move lines into the history when scrolling even if the scroll region is not
the entire screen.

Allows ircII users to see history, prompted by naddy.
@
text
@d1 1
a1 1
/* $OpenBSD: grid-view.c,v 1.6 2009/07/13 10:43:52 nicm Exp $ */
d152 1
a152 1
 	grid_clear(gd, 0, py + ny2, gd->sx, ny - ny2);
d168 1
a168 1
 	grid_clear(gd, 0, sy - ny, gd->sx, py + ny - (sy - ny));
d185 1
a185 1
 	grid_clear(gd, 0, py + ny2, gd->sx, ny - ny2);
@


1.6
log
@Support "alternate screen" mode (terminfo smcup/rmcup) typically used by full
screen interactive programs to preserve the screen contents. When activated, it
saves a copy of the visible grid and disables scrolling into and resizing out
of the history; when deactivated the visible data is restored and the history
reenabled.
@
text
@d1 1
a1 1
/* $OpenBSD: grid-view.c,v 1.5 2009/07/09 07:58:14 nicm Exp $ */
d95 13
a107 3
	if (gd->flags & GRID_HISTORY && rupper == 0 && rlower == gd->sy - 1) {
		grid_scroll_line(gd);
		return;
a108 5

	rupper = grid_view_y(gd, rupper);
	rlower = grid_view_y(gd, rlower);

	grid_move_lines(gd, rupper, rupper + 1, rlower - rupper);
@


1.5
log
@Change inserting and deleting lines inside the scroll region to properly clear
lines that should be inserted/deleted but not moved. Fixes problems with mutt
reported by Brian Lewis, thanks.
@
text
@d1 1
a1 1
/* $OpenBSD: grid-view.c,v 1.4 2009/07/09 00:29:32 nicm Exp $ */
d95 1
a95 1
	if (rupper == 0 && rlower == gd->sy - 1) {
@


1.4
log
@Tidy by removing unused argument from grid_view_{insert,delete}_line_region
functions (currently don't fully work, this is to make fix easier).
@
text
@d1 1
a1 1
/* $OpenBSD: grid-view.c,v 1.3 2009/06/29 21:30:50 nicm Exp $ */
d137 2
d145 3
a147 1
	grid_move_lines(gd, py + ny, py, (rlower + 1) - py - ny);
d163 1
a163 1
	grid_clear(gd, 0, sy - ny, gd->sx, py + ny - (sy - ny));
d170 2
d178 3
a180 1
	grid_move_lines(gd, py, py + ny, (rlower + 1) - py - ny);
@


1.3
log
@Fix two errors with character/line insertion and deletion: the maximum number
of characters which may be inserted or deleted is the screen width, not one
less (and similarly for lines and height); and if characters or lines are
deleted by moving the ones that follow, the space at the end needs to be
cleared.

This appears to solve long-standing redraw issues most visible when using the
force-width option then scrolling in view(1) or unwrapping lines in emacs.
@
text
@d1 1
a1 1
/* $OpenBSD: grid-view.c,v 1.2 2009/06/24 22:04:18 nicm Exp $ */
d135 1
a135 2
grid_view_insert_lines_region(
    struct grid *gd, unused u_int rupper, u_int rlower, u_int py, u_int ny)
d137 1
a137 2
	GRID_DEBUG(
	    gd, "rupper=%u, rlower=%u, py=%u, ny=%u", rupper, rlower, py, ny);
d164 1
a164 2
grid_view_delete_lines_region(
    struct grid *gd, unused u_int rupper, u_int rlower, u_int py, u_int ny)
d166 1
a166 2
	GRID_DEBUG(
	    gd, "rupper=%u, rlower=%u, py=%u, ny=%u", rupper, rlower, py, ny);
@


1.2
log
@Add a dedicated function to convert a line into a string and use it to simplify the search window function.
@
text
@d1 1
a1 1
/* $OpenBSD: grid-view.c,v 1.1 2009/06/01 22:58:49 nicm Exp $ */
d161 1
d195 1
a195 1
		grid_move_cells(gd, px + nx, px, py, (sx - 1) - (px + nx));
d211 2
a212 1
	grid_move_cells(gd, px, px + nx, py, (sx - 1) - (px + nx));
@


1.1
log
@Import tmux, a terminal multiplexor allowing (among other things) a single
terminal to be switched between several different windows and programs
displayed on one terminal be detached from one terminal and moved to another.

ok deraadt pirofti
@
text
@d1 1
a1 1
/* $OpenBSD$ */
d211 12
@

