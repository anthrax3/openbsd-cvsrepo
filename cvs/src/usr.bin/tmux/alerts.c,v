head	1.16;
access;
symbols
	OPENBSD_6_1:1.16.0.2
	OPENBSD_6_1_BASE:1.16
	OPENBSD_6_0:1.11.0.2
	OPENBSD_6_0_BASE:1.11
	OPENBSD_5_9:1.10.0.2
	OPENBSD_5_9_BASE:1.10;
locks; strict;
comment	@ * @;


1.16
date	2016.11.01.09.07.18;	author nicm;	state Exp;
branches;
next	1.15;
commitid	xLYCiotT7JMMAXZf;

1.15
date	2016.10.25.07.24.10;	author nicm;	state Exp;
branches;
next	1.14;
commitid	Q0S16grB7yH4fPXf;

1.14
date	2016.10.19.09.22.07;	author nicm;	state Exp;
branches;
next	1.13;
commitid	leRKiNVAXYb2Wrn1;

1.13
date	2016.10.16.22.18.04;	author nicm;	state Exp;
branches;
next	1.12;
commitid	hN37jNkXLWeSlPkK;

1.12
date	2016.10.03.22.52.11;	author nicm;	state Exp;
branches;
next	1.11;
commitid	brRovAmeQVyBbZ4S;

1.11
date	2016.05.11.20.56.58;	author nicm;	state Exp;
branches;
next	1.10;
commitid	k3sdUig4m5BnsxCI;

1.10
date	2016.01.19.15.59.12;	author nicm;	state Exp;
branches;
next	1.9;
commitid	P3qmSOx6KrDBsb0c;

1.9
date	2016.01.16.00.36.53;	author nicm;	state Exp;
branches;
next	1.8;
commitid	416B5CZCT2xuRFOv;

1.8
date	2015.12.07.09.47.41;	author nicm;	state Exp;
branches;
next	1.7;
commitid	DEG5t4Tpp1OvTShQ;

1.7
date	2015.11.20.16.33.46;	author nicm;	state Exp;
branches;
next	1.6;
commitid	18a8FvlIuCdt0X5F;

1.6
date	2015.11.19.14.55.25;	author nicm;	state Exp;
branches;
next	1.5;
commitid	B2J9Pe6hbjf9HoV1;

1.5
date	2015.11.18.14.27.44;	author nicm;	state Exp;
branches;
next	1.4;
commitid	RjsAPRkWwvS79w40;

1.4
date	2015.10.27.15.58.42;	author nicm;	state Exp;
branches;
next	1.3;
commitid	89xhQafU35Q5MQVC;

1.3
date	2015.09.21.09.34.52;	author nicm;	state Exp;
branches;
next	1.2;
commitid	6x8xXQJrstCSMjic;

1.2
date	2015.09.02.17.43.25;	author nicm;	state Exp;
branches;
next	1.1;
commitid	xHcEu21xENWEDDuX;

1.1
date	2015.08.29.08.30.54;	author nicm;	state Exp;
branches;
next	;
commitid	RrlCW4OYH7he0yBf;


desc
@@


1.16
log
@Clear window alert flags after setting winlink alert flags, fixes problem
reported by Tommy Allen.
@
text
@/* $OpenBSD: alerts.c,v 1.15 2016/10/25 07:24:10 nicm Exp $ */

/*
 * Copyright (c) 2015 Nicholas Marriott <nicholas.marriott@@gmail.com>
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF MIND, USE, DATA OR PROFITS, WHETHER
 * IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING
 * OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */

#include <sys/types.h>

#include <event.h>
#include <stdlib.h>

#include "tmux.h"

static int	alerts_fired;

static void	alerts_timer(int, short, void *);
static int	alerts_enabled(struct window *, int);
static void	alerts_callback(int, short, void *);
static void	alerts_reset(struct window *);

static int	alerts_check_all(struct window *);
static int	alerts_check_bell(struct window *);
static int	alerts_check_activity(struct window *);
static int	alerts_check_silence(struct window *);
static void printflike(2, 3) alerts_set_message(struct session *, const char *,
		    ...);
static void	alerts_ring_bell(struct session *);

static TAILQ_HEAD(, window) alerts_list = TAILQ_HEAD_INITIALIZER(alerts_list);

static void
alerts_timer(__unused int fd, __unused short events, void *arg)
{
	struct window	*w = arg;

	log_debug("@@%u alerts timer expired", w->id);
	alerts_reset(w);
	alerts_queue(w, WINDOW_SILENCE);
}

static void
alerts_callback(__unused int fd, __unused short events, __unused void *arg)
{
	struct window	*w, *w1;
	int		 alerts;

	TAILQ_FOREACH_SAFE(w, &alerts_list, alerts_entry, w1) {
		alerts = alerts_check_all(w);
		log_debug("@@%u alerts check, alerts %#x", w->id, alerts);

		w->alerts_queued = 0;
		TAILQ_REMOVE(&alerts_list, w, alerts_entry);

		w->flags &= ~WINDOW_ALERTFLAGS;
		window_remove_ref(w);
	}
	alerts_fired = 0;
}

static int
alerts_check_all(struct window *w)
{
	int	alerts;

	alerts  = alerts_check_bell(w);
	alerts |= alerts_check_activity(w);
	alerts |= alerts_check_silence(w);
	return (alerts);
}

void
alerts_check_session(struct session *s)
{
	struct winlink	*wl;

	RB_FOREACH(wl, winlinks, &s->windows)
		alerts_check_all(wl->window);
}

static int
alerts_enabled(struct window *w, int flags)
{
	if (flags & WINDOW_BELL)
		return (1);
	if (flags & WINDOW_ACTIVITY) {
		if (options_get_number(w->options, "monitor-activity"))
			return (1);
	}
	if (flags & WINDOW_SILENCE) {
		if (options_get_number(w->options, "monitor-silence") != 0)
			return (1);
	}
	return (0);
}

void
alerts_reset_all(void)
{
	struct window	*w;

	RB_FOREACH(w, windows, &windows)
		alerts_reset(w);
}

static void
alerts_reset(struct window *w)
{
	struct timeval	tv;

	w->flags &= ~WINDOW_SILENCE;
	event_del(&w->alerts_timer);

	timerclear(&tv);
	tv.tv_sec = options_get_number(w->options, "monitor-silence");

	log_debug("@@%u alerts timer reset %u", w->id, (u_int)tv.tv_sec);
	if (tv.tv_sec != 0)
		event_add(&w->alerts_timer, &tv);
}

void
alerts_queue(struct window *w, int flags)
{
	if (w->flags & WINDOW_ACTIVITY)
		alerts_reset(w);

	if (!event_initialized(&w->alerts_timer))
		evtimer_set(&w->alerts_timer, alerts_timer, w);

	if ((w->flags & flags) != flags) {
		w->flags |= flags;
		log_debug("@@%u alerts flags added %#x", w->id, flags);
	}

	if (!w->alerts_queued) {
		w->alerts_queued = 1;
		TAILQ_INSERT_TAIL(&alerts_list, w, alerts_entry);
		w->references++;
	}

	if (!alerts_fired && alerts_enabled(w, flags)) {
		log_debug("alerts check queued (by @@%u)", w->id);
		event_once(-1, EV_TIMEOUT, alerts_callback, NULL, NULL);
		alerts_fired = 1;
	}
}

static int
alerts_check_bell(struct window *w)
{
	struct window	*ws;
	struct winlink	*wl;
	struct session	*s;
	struct client	*c;
	int		 action, visual;

	if (~w->flags & WINDOW_BELL)
		return (0);

	TAILQ_FOREACH(wl, &w->winlinks, wentry)
		wl->session->flags &= ~SESSION_ALERTED;

	TAILQ_FOREACH(wl, &w->winlinks, wentry) {
		if (wl->flags & WINLINK_BELL)
			continue;
		s = wl->session;
		if (s->curw != wl) {
			wl->flags |= WINLINK_BELL;
			notify_winlink("alert-bell", s, wl);
		}

		if (s->flags & SESSION_ALERTED)
			continue;
		s->flags |= SESSION_ALERTED;

		action = options_get_number(s->options, "bell-action");
		if (action == BELL_NONE)
			return (0);

		visual = options_get_number(s->options, "visual-bell");
		TAILQ_FOREACH(c, &clients, entry) {
			if (c->session != s || c->flags & CLIENT_CONTROL)
				continue;
			ws = c->session->curw->window;

			if (action == BELL_CURRENT && ws != w)
				action = BELL_NONE;
			if (action == BELL_OTHER && ws != w)
				action = BELL_NONE;

			if (!visual) {
				if (action != BELL_NONE)
					tty_putcode(&c->tty, TTYC_BEL);
				continue;
			}
			if (action == BELL_CURRENT)
				status_message_set(c, "Bell in current window");
			else if (action != BELL_NONE) {
				status_message_set(c, "Bell in window %d",
				    wl->idx);
			}
		}
	}

	return (WINDOW_BELL);
}

static int
alerts_check_activity(struct window *w)
{
	struct winlink	*wl;
	struct session	*s;

	if (~w->flags & WINDOW_ACTIVITY)
		return (0);
	if (!options_get_number(w->options, "monitor-activity"))
		return (0);

	TAILQ_FOREACH(wl, &w->winlinks, wentry)
		wl->session->flags &= ~SESSION_ALERTED;

	TAILQ_FOREACH(wl, &w->winlinks, wentry) {
		if (wl->flags & WINLINK_ACTIVITY)
			continue;
		s = wl->session;
		if (s->curw == wl)
			continue;

		wl->flags |= WINLINK_ACTIVITY;
		notify_winlink("alert-activity", s, wl);

		if (s->flags & SESSION_ALERTED)
			continue;
		s->flags |= SESSION_ALERTED;

		if (options_get_number(s->options, "bell-on-alert"))
			alerts_ring_bell(s);
		if (options_get_number(s->options, "visual-activity"))
			alerts_set_message(s, "Activity in window %d", wl->idx);
	}

	return (WINDOW_ACTIVITY);
}

static int
alerts_check_silence(struct window *w)
{
	struct winlink	*wl;
	struct session	*s;

	if (~w->flags & WINDOW_SILENCE)
		return (0);
	if (!options_get_number(w->options, "monitor-silence"))
		return (0);

	TAILQ_FOREACH(wl, &w->winlinks, wentry)
		wl->session->flags &= ~SESSION_ALERTED;

	TAILQ_FOREACH(wl, &w->winlinks, wentry) {
		if (wl->flags & WINLINK_SILENCE)
			continue;
		s = wl->session;
		if (s->curw == wl)
			continue;
		wl->flags |= WINLINK_SILENCE;
		notify_winlink("alert-silence", s, wl);

		if (s->flags & SESSION_ALERTED)
			continue;
		s->flags |= SESSION_ALERTED;

		if (options_get_number(s->options, "bell-on-alert"))
			alerts_ring_bell(s);

		if (!options_get_number(s->options, "visual-silence"))
			alerts_set_message(s, "Silence in window %d", wl->idx);
	}

	return (WINDOW_SILENCE);
}

static void
alerts_set_message(struct session *s, const char *fmt, ...)
{
	struct client	*c;
	va_list		 ap;
	char		*message;

	va_start(ap, fmt);
	xvasprintf(&message, fmt, ap);
	va_end(ap);

	TAILQ_FOREACH(c, &clients, entry) {
		if (c->session == s)
			status_message_set(c, "%s", message);
	}

	free(message);
}

static void
alerts_ring_bell(struct session *s)
{
	struct client	*c;

	TAILQ_FOREACH(c, &clients, entry) {
		if (c->session == s && !(c->flags & CLIENT_CONTROL))
			tty_putcode(&c->tty, TTYC_BEL);
	}
}
@


1.15
log
@Do not handle activity or silence alerts in the current window, reported
by jasper@@.
@
text
@d1 1
a1 1
/* $OpenBSD: alerts.c,v 1.14 2016/10/19 09:22:07 nicm Exp $ */
d65 2
@


1.14
log
@Alerts are too slow, so rather than walking all sessions and windows,
add a link of winlinks to each window and a pointer to the session to
each winlink. Also rewrite the alerts processing to return to the old
behaviour (alert in any window sets the flag on any winlink).
@
text
@d1 1
a1 1
/* $OpenBSD: alerts.c,v 1.13 2016/10/16 22:18:04 nicm Exp $ */
d236 5
a240 4
		if (s->curw != wl) {
			wl->flags |= WINLINK_ACTIVITY;
			notify_winlink("alert-activity", s, wl);
		}
d273 4
a276 4
		if (s->curw != wl) {
			wl->flags |= WINLINK_SILENCE;
			notify_winlink("alert-silence", s, wl);
		}
@


1.13
log
@Use notifys for alerts too.
@
text
@d1 1
a1 1
/* $OpenBSD: alerts.c,v 1.12 2016/10/03 22:52:11 nicm Exp $ */
d22 1
d33 6
a38 5
static void	alerts_run_hook(struct session *, struct winlink *, int);
static int	alerts_check_all(struct session *, struct winlink *);
static int	alerts_check_bell(struct session *, struct winlink *);
static int	alerts_check_activity(struct session *, struct winlink *);
static int	alerts_check_silence(struct session *, struct winlink *);
d41 2
d56 2
a57 4
	struct window	*w;
	struct session	*s;
	struct winlink	*wl;
	int		 flags, alerts;
d59 7
a65 14
	RB_FOREACH(w, windows, &windows) {
		RB_FOREACH(s, sessions, &sessions) {
			RB_FOREACH(wl, winlinks, &s->windows) {
				if (wl->window != w)
					continue;
				flags = w->flags;

				alerts = alerts_check_all(s, wl);

				log_debug("%s:%d @@%u alerts check, alerts %#x, "
				    "flags %#x", s->name, wl->idx, w->id,
				    alerts, flags);
			}
		}
a69 11
static void
alerts_run_hook(struct session *s, struct winlink *wl, int flags)
{
	if (flags & WINDOW_BELL)
		notify_winlink("alert-bell", s, wl);
	if (flags & WINDOW_SILENCE)
		notify_winlink("alert-silence", s, wl);
	if (flags & WINDOW_ACTIVITY)
		notify_winlink("alert-activity", s, wl);
}

d71 1
a71 1
alerts_check_all(struct session *s, struct winlink *wl)
d75 3
a77 8
	alerts  = alerts_check_bell(s, wl);
	alerts |= alerts_check_activity(s, wl);
	alerts |= alerts_check_silence(s, wl);
	if (alerts != 0) {
		alerts_run_hook(s, wl, alerts);
		server_status_session(s);
	}

d87 1
a87 1
		alerts_check_all(s, wl);
d145 6
d159 1
a159 1
alerts_check_bell(struct session *s, struct winlink *wl)
d161 3
a164 1
	struct window	*w = wl->window;
d167 1
a167 1
	if (!(w->flags & WINDOW_BELL))
a168 6
	if (s->curw != wl) {
		wl->flags |= WINLINK_BELL;
		w->flags &= ~WINDOW_BELL;
	}
	if (s->curw->window == w)
		w->flags &= ~WINDOW_BELL;
d170 2
a171 3
	action = options_get_number(s->options, "bell-action");
	if (action == BELL_NONE)
		return (0);
d173 2
a174 3
	visual = options_get_number(s->options, "visual-bell");
	TAILQ_FOREACH(c, &clients, entry) {
		if (c->session != s || c->flags & CLIENT_CONTROL)
d176 7
a182 7
		if (!visual) {
			if ((action == BELL_CURRENT &&
			    c->session->curw->window == w) ||
			    (action == BELL_OTHER &&
			    c->session->curw->window != w) ||
			    action == BELL_ANY)
				tty_putcode(&c->tty, TTYC_BEL);
d184 28
a212 5
		if (action == BELL_CURRENT && c->session->curw->window == w)
			status_message_set(c, "Bell in current window");
		else if (action == BELL_ANY || (action == BELL_OTHER &&
		    c->session->curw->window != w))
			status_message_set(c, "Bell in window %d", wl->idx);
d219 1
a219 1
alerts_check_activity(struct session *s, struct winlink *wl)
d221 2
a222 2
	struct client	*c;
	struct window	*w = wl->window;
d224 1
a224 6
	if (s->curw->window == w)
		w->flags &= ~WINDOW_ACTIVITY;

	if (!(w->flags & WINDOW_ACTIVITY) || wl->flags & WINLINK_ACTIVITY)
		return (0);
	if (s->curw == wl)
a225 1

d229 2
a230 3
	if (options_get_number(s->options, "bell-on-alert"))
		alerts_ring_bell(s);
	wl->flags |= WINLINK_ACTIVITY;
d232 7
a238 5
	if (options_get_number(s->options, "visual-activity")) {
		TAILQ_FOREACH(c, &clients, entry) {
			if (c->session != s)
				continue;
			status_message_set(c, "Activity in window %d", wl->idx);
d240 9
d255 1
a255 1
alerts_check_silence(struct session *s, struct winlink *wl)
d257 2
a258 2
	struct client	*c;
	struct window	*w = wl->window;
d260 1
a260 4
	if (s->curw->window == w)
		w->flags &= ~WINDOW_SILENCE;

	if (!(w->flags & WINDOW_SILENCE) || wl->flags & WINLINK_SILENCE)
d262 1
a262 1
	if (s->curw == wl)
d265 15
a279 2
	if (options_get_number(w->options, "monitor-silence") == 0)
		return (0);
d281 2
a282 3
	if (options_get_number(s->options, "bell-on-alert"))
		alerts_ring_bell(s);
	wl->flags |= WINLINK_SILENCE;
d284 2
a285 6
	if (options_get_number(s->options, "visual-silence")) {
		TAILQ_FOREACH(c, &clients, entry) {
			if (c->session != s)
				continue;
			status_message_set(c, "Silence in window %d", wl->idx);
		}
d289 19
@


1.12
log
@Remove some dead code in cmd-move-window.c and make a load of local
functions static.
@
text
@d1 1
a1 1
/* $OpenBSD: alerts.c,v 1.11 2016/05/11 20:56:58 nicm Exp $ */
a77 5
	struct cmd_find_state	 fs;

	if (cmd_find_from_winlink(&fs, s, wl) != 0)
		return;

d79 1
a79 1
		hooks_run(s->hooks, NULL, &fs, "alert-bell");
d81 1
a81 1
		hooks_run(s->hooks, NULL, &fs, "alert-silence");
d83 1
a83 1
		hooks_run(s->hooks, NULL, &fs, "alert-activity");
@


1.11
log
@Add on alerts rather than ignoring them if the event has already been
queued, for example bell and activity together. From Marcel Lippmann via
Romain Francoise.
@
text
@d1 1
a1 1
/* $OpenBSD: alerts.c,v 1.10 2016/01/19 15:59:12 nicm Exp $ */
d25 1
a25 1
int	alerts_fired;
d27 11
a37 11
void	alerts_timer(int, short, void *);
int	alerts_enabled(struct window *, int);
void	alerts_callback(int, short, void *);
void	alerts_reset(struct window *);

void	alerts_run_hook(struct session *, struct winlink *, int);
int	alerts_check_all(struct session *, struct winlink *);
int	alerts_check_bell(struct session *, struct winlink *);
int	alerts_check_activity(struct session *, struct winlink *);
int	alerts_check_silence(struct session *, struct winlink *);
void	alerts_ring_bell(struct session *);
d39 1
a39 1
void
d49 1
a49 1
void
d75 1
a75 1
void
d91 1
a91 1
int
d116 1
a116 1
int
d141 1
a141 1
void
d178 1
a178 1
int
d221 1
a221 1
int
d253 1
a253 1
int
d285 1
a285 1
void
@


1.10
log
@I no longer use my SourceForge address so replace it.
@
text
@d1 1
a1 1
/* $OpenBSD: alerts.c,v 1.9 2016/01/16 00:36:53 nicm Exp $ */
d166 1
a166 1
	if (!alerts_fired) {
d169 1
d171 4
a174 5
		if (alerts_enabled(w, flags)) {
			log_debug("alerts check queued (by @@%u)", w->id);
			event_once(-1, EV_TIMEOUT, alerts_callback, NULL, NULL);
			alerts_fired = 1;
		}
@


1.9
log
@Add hooks for alerts (bell, silence, activity), from Thomas Adam.
@
text
@d1 1
a1 1
/* $OpenBSD: alerts.c,v 1.8 2015/12/07 09:47:41 nicm Exp $ */
d4 1
a4 1
 * Copyright (c) 2015 Nicholas Marriott <nicm@@users.sourceforge.net>
@


1.8
log
@Fix bell indicators across detach, reported by Torbjorn Lonnemark, diff
from Thomas Adam.
@
text
@d1 1
a1 1
/* $OpenBSD: alerts.c,v 1.7 2015/11/20 16:33:46 nicm Exp $ */
d32 1
a58 2
			if (s->flags & SESSION_UNATTACHED)
				continue;
d75 16
d99 2
a100 1
	if (alerts != 0)
d102 1
@


1.7
log
@The alerts callback should be fired for bells even if bell-action is
none because it also affects the status line bell indicator (and
bell-action does not). Fixes a problem reported by tim@@.
@
text
@d1 1
a1 1
/* $OpenBSD: alerts.c,v 1.6 2015/11/19 14:55:25 nicm Exp $ */
d32 1
d58 2
d65 1
a65 5
				alerts  = alerts_check_bell(s, wl);
				alerts |= alerts_check_activity(s, wl);
				alerts |= alerts_check_silence(s, wl);
				if (alerts != 0)
					server_status_session(s);
d77 23
d168 1
a168 1
	if (!(w->flags & WINDOW_BELL) || wl->flags & WINLINK_BELL)
d170 1
a170 1
	if (s->curw != wl || s->flags & SESSION_UNATTACHED)
d172 2
a173 2
	if (s->flags & SESSION_UNATTACHED)
		return (0);
d215 1
a215 1
	if (s->curw == wl && !(s->flags & SESSION_UNATTACHED))
d247 1
a247 1
	if (s->curw == wl && !(s->flags & SESSION_UNATTACHED))
@


1.6
log
@The activity flag could already be set, so queue the callback always (if
not already queued) rather than only if the flag is being added. Fixes a
problem reported by tim@@
@
text
@d1 1
a1 1
/* $OpenBSD: alerts.c,v 1.5 2015/11/18 14:27:44 nicm Exp $ */
d80 2
a81 2
	struct session	*s;

a87 8
			return (1);
	}
	if (~flags & WINDOW_BELL)
		return (0);
	RB_FOREACH(s, sessions, &sessions) {
		if (!session_has(s, w))
			continue;
		if (options_get_number(s->options, "bell-action") != BELL_NONE)
@


1.5
log
@Use __unused rather than rolling our own.
@
text
@d1 1
a1 1
/* $OpenBSD: alerts.c,v 1.4 2015/10/27 15:58:42 nicm Exp $ */
d135 9
a143 9
	if (w->flags & flags)
		return;
	w->flags |= flags;
	log_debug("@@%u alerts flags added %#x", w->id, flags);

	if (!alerts_fired && alerts_enabled(w, flags)) {
		log_debug("alerts check queued (by @@%u)", w->id);
		event_once(-1, EV_TIMEOUT, alerts_callback, NULL, NULL);
		alerts_fired = 1;
@


1.4
log
@Move struct options into options.c.
@
text
@d1 1
a1 1
/* $OpenBSD: alerts.c,v 1.3 2015/09/21 09:34:52 nicm Exp $ */
d38 1
a38 1
alerts_timer(unused int fd, unused short events, void *arg)
d48 1
a48 1
alerts_callback(unused int fd, unused short events, unused void *arg)
@


1.3
log
@Reset the alerts timer always on activity, from Thomas Adam.
@
text
@d1 1
a1 1
/* $OpenBSD: alerts.c,v 1.2 2015/09/02 17:43:25 nicm Exp $ */
d83 1
a83 1
		if (options_get_number(&w->options, "monitor-activity"))
d87 1
a87 1
		if (options_get_number(&w->options, "monitor-silence") != 0)
d95 1
a95 1
		if (options_get_number(&s->options, "bell-action") != BELL_NONE)
d119 1
a119 1
	tv.tv_sec = options_get_number(&w->options, "monitor-silence");
d163 1
a163 1
	action = options_get_number(&s->options, "bell-action");
d167 1
a167 1
	visual = options_get_number(&s->options, "visual-bell");
d204 1
a204 1
	if (!options_get_number(&w->options, "monitor-activity"))
d207 1
a207 1
	if (options_get_number(&s->options, "bell-on-alert"))
d211 1
a211 1
	if (options_get_number(&s->options, "visual-activity")) {
d236 1
a236 1
	if (options_get_number(&w->options, "monitor-silence") == 0)
d239 1
a239 1
	if (options_get_number(&s->options, "bell-on-alert"))
d243 1
a243 1
	if (options_get_number(&s->options, "visual-silence")) {
@


1.2
log
@A one line helper function is a little silly.
@
text
@d1 1
a1 1
/* $OpenBSD: alerts.c,v 1.1 2015/08/29 08:30:54 nicm Exp $ */
d129 3
a144 3

	if (flags & WINDOW_ACTIVITY)
		alerts_reset(w);
@


1.1
log
@Move alerts onto events rather than checking every loop.
@
text
@d1 1
a1 1
/* $OpenBSD: server-window.c,v 1.39 2015/08/29 00:29:15 nicm Exp $ */
d177 1
a177 1
				tty_bell(&c->tty);
d261 1
a261 1
			tty_bell(&c->tty);
@

