head	1.203;
access;
symbols
	OPENBSD_6_1:1.187.0.4
	OPENBSD_6_1_BASE:1.187
	OPENBSD_6_0:1.165.0.2
	OPENBSD_6_0_BASE:1.165
	OPENBSD_5_9:1.156.0.2
	OPENBSD_5_9_BASE:1.156
	OPENBSD_5_8:1.135.0.4
	OPENBSD_5_8_BASE:1.135
	OPENBSD_5_7:1.116.0.2
	OPENBSD_5_7_BASE:1.116
	OPENBSD_5_6:1.112.0.4
	OPENBSD_5_6_BASE:1.112
	OPENBSD_5_5:1.102.0.4
	OPENBSD_5_5_BASE:1.102
	OPENBSD_5_4:1.97.0.2
	OPENBSD_5_4_BASE:1.97
	OPENBSD_5_3:1.89.0.2
	OPENBSD_5_3_BASE:1.89
	OPENBSD_5_2:1.82.0.2
	OPENBSD_5_2_BASE:1.82
	OPENBSD_5_1_BASE:1.72
	OPENBSD_5_1:1.72.0.2
	OPENBSD_5_0:1.66.0.2
	OPENBSD_5_0_BASE:1.66
	OPENBSD_4_9:1.63.0.2
	OPENBSD_4_9_BASE:1.63
	OPENBSD_4_8:1.53.0.2
	OPENBSD_4_8_BASE:1.53
	OPENBSD_4_7:1.43.0.2
	OPENBSD_4_7_BASE:1.43
	OPENBSD_4_6:1.6.0.4
	OPENBSD_4_6_BASE:1.6;
locks; strict;
comment	@ * @;


1.203
date	2017.07.12.10.04.51;	author nicm;	state Exp;
branches;
next	1.202;
commitid	AQOFbEqorBS7o8Il;

1.202
date	2017.07.12.09.24.17;	author nicm;	state Exp;
branches;
next	1.201;
commitid	GhkQsamphQVs3LP1;

1.201
date	2017.07.03.12.38.50;	author nicm;	state Exp;
branches;
next	1.200;
commitid	PWqN64KUXeQJhx9K;

1.200
date	2017.07.03.08.16.03;	author nicm;	state Exp;
branches;
next	1.199;
commitid	3rK8y6YdEO1TozsR;

1.199
date	2017.06.28.11.36.40;	author nicm;	state Exp;
branches;
next	1.198;
commitid	z6XCHRBq9DeWsQAl;

1.198
date	2017.06.04.09.02.36;	author nicm;	state Exp;
branches;
next	1.197;
commitid	j9IbC5EkkPNg7bcv;

1.197
date	2017.05.31.10.15.51;	author nicm;	state Exp;
branches;
next	1.196;
commitid	z4nG3H73FMfSbirM;

1.196
date	2017.05.30.21.44.59;	author nicm;	state Exp;
branches;
next	1.195;
commitid	ai2b3hkAsUowPSMm;

1.195
date	2017.05.29.18.06.34;	author nicm;	state Exp;
branches;
next	1.194;
commitid	728WJnnykoH2198t;

1.194
date	2017.05.12.10.45.38;	author nicm;	state Exp;
branches;
next	1.193;
commitid	jng8rFxtzJgvDp1f;

1.193
date	2017.05.04.07.16.43;	author nicm;	state Exp;
branches;
next	1.192;
commitid	LkEFVZkMwx5R0ZCg;

1.192
date	2017.04.28.19.13.55;	author nicm;	state Exp;
branches;
next	1.191;
commitid	hywgbleVzGuc1NGQ;

1.191
date	2017.04.28.19.12.15;	author nicm;	state Exp;
branches;
next	1.190;
commitid	mStgYkIqBNjD7or1;

1.190
date	2017.04.20.17.49.26;	author nicm;	state Exp;
branches;
next	1.189;
commitid	OfL2Obmz7xdpsjZq;

1.189
date	2017.04.20.09.43.45;	author nicm;	state Exp;
branches;
next	1.188;
commitid	wTqD4LJDLZSJgn81;

1.188
date	2017.04.20.09.39.07;	author nicm;	state Exp;
branches;
next	1.187;
commitid	UvG2E3PZHiLbgCmS;

1.187
date	2017.03.21.09.49.10;	author nicm;	state Exp;
branches;
next	1.186;
commitid	4FGkaF282p4iaSFm;

1.186
date	2017.03.13.17.20.11;	author nicm;	state Exp;
branches;
next	1.185;
commitid	YkFFAuMc91SPYj5O;

1.185
date	2017.02.27.13.07.57;	author nicm;	state Exp;
branches;
next	1.184;
commitid	xaSatUk82c2wHmar;

1.184
date	2017.02.22.09.01.32;	author nicm;	state Exp;
branches;
next	1.183;
commitid	SKmqCZ6GhGllt9ad;

1.183
date	2017.02.08.08.25.12;	author nicm;	state Exp;
branches;
next	1.182;
commitid	rYBoJWPEuxHYqS9Q;

1.182
date	2017.01.24.13.28.33;	author nicm;	state Exp;
branches;
next	1.181;
commitid	o4bx7OSWGDmXTMl6;

1.181
date	2017.01.23.10.09.43;	author nicm;	state Exp;
branches;
next	1.180;
commitid	anZBbATBZNigju2F;

1.180
date	2017.01.12.10.15.55;	author nicm;	state Exp;
branches;
next	1.179;
commitid	tR9p5bWPfvbLb8Sj;

1.179
date	2017.01.12.00.24.28;	author nicm;	state Exp;
branches;
next	1.178;
commitid	IkdNvNyd0BzyibTJ;

1.178
date	2017.01.12.00.19.32;	author nicm;	state Exp;
branches;
next	1.177;
commitid	5Rj7IbEXrGVYho74;

1.177
date	2017.01.07.15.28.13;	author nicm;	state Exp;
branches;
next	1.176;
commitid	llgkTzvAhxXuSWDB;

1.176
date	2016.11.16.09.22.16;	author nicm;	state Exp;
branches;
next	1.175;
commitid	9XpIyqdZHYVHsntZ;

1.175
date	2016.11.16.00.24.03;	author nicm;	state Exp;
branches;
next	1.174;
commitid	ZQAQdE9Fy4gBpQvj;

1.174
date	2016.10.19.09.22.07;	author nicm;	state Exp;
branches;
next	1.173;
commitid	leRKiNVAXYb2Wrn1;

1.173
date	2016.10.18.07.38.16;	author nicm;	state Exp;
branches;
next	1.172;
commitid	HhOwLgv44exX8sUE;

1.172
date	2016.10.16.22.06.40;	author nicm;	state Exp;
branches;
next	1.171;
commitid	j0FZs70gSPCmpqWI;

1.171
date	2016.10.15.09.27.52;	author nicm;	state Exp;
branches;
next	1.170;
commitid	3LOsIpF6UVTyfOf3;

1.170
date	2016.10.13.20.27.27;	author nicm;	state Exp;
branches;
next	1.169;
commitid	txCyQ5BkKJtZRzfT;

1.169
date	2016.10.11.13.21.59;	author nicm;	state Exp;
branches;
next	1.168;
commitid	80rgEIPcNpyBnf95;

1.168
date	2016.10.11.07.23.34;	author nicm;	state Exp;
branches;
next	1.167;
commitid	leUN1UeapgUoieJj;

1.167
date	2016.09.28.08.30.44;	author nicm;	state Exp;
branches;
next	1.166;
commitid	l0DpFzkilFIpFuoD;

1.166
date	2016.09.16.13.43.41;	author nicm;	state Exp;
branches;
next	1.165;
commitid	ykp4HhimaTwh0QYH;

1.165
date	2016.07.15.09.52.34;	author nicm;	state Exp;
branches;
next	1.164;
commitid	GqpJHQB3A3bbJxMc;

1.164
date	2016.07.15.09.28.32;	author nicm;	state Exp;
branches;
next	1.163;
commitid	Bi60xSMBeQjDRMSa;

1.163
date	2016.06.16.10.55.47;	author nicm;	state Exp;
branches;
next	1.162;
commitid	iwpkepU9NO5jIk1m;

1.162
date	2016.06.15.09.13.46;	author nicm;	state Exp;
branches;
next	1.161;
commitid	qFQIj3KrXkLdlwNy;

1.161
date	2016.06.06.07.24.31;	author nicm;	state Exp;
branches;
next	1.160;
commitid	E78aCj5t0oSJORb6;

1.160
date	2016.05.30.09.50.21;	author nicm;	state Exp;
branches;
next	1.159;
commitid	6UcyBBKbI1JUqfYo;

1.159
date	2016.04.29.15.00.48;	author nicm;	state Exp;
branches;
next	1.158;
commitid	z5NrpOKjZoYhx6Qr;

1.158
date	2016.04.29.13.36.11;	author nicm;	state Exp;
branches;
next	1.157;
commitid	7Lz69alYJZN2W8qc;

1.157
date	2016.03.01.12.05.15;	author nicm;	state Exp;
branches;
next	1.156;
commitid	MOocELdZbG8uzTEb;

1.156
date	2016.01.19.15.59.12;	author nicm;	state Exp;
branches;
next	1.155;
commitid	P3qmSOx6KrDBsb0c;

1.155
date	2015.12.31.18.14.13;	author nicm;	state Exp;
branches;
next	1.154;
commitid	SjSfvkdOY0ScglOl;

1.154
date	2015.12.19.08.43.04;	author nicm;	state Exp;
branches;
next	1.153;
commitid	Onfwi6uOmPcFRmBg;

1.153
date	2015.12.16.21.50.38;	author nicm;	state Exp;
branches;
next	1.152;
commitid	Bam1GajuDZzmKjyE;

1.152
date	2015.12.15.00.00.01;	author nicm;	state Exp;
branches;
next	1.151;
commitid	yMmY7FLVcToE15ZM;

1.151
date	2015.12.02.23.09.22;	author nicm;	state Exp;
branches;
next	1.150;
commitid	8rSzLuAv4WWqWJEe;

1.150
date	2015.11.24.23.46.16;	author nicm;	state Exp;
branches;
next	1.149;
commitid	0H2a77mNskMnXKL5;

1.149
date	2015.11.18.14.27.44;	author nicm;	state Exp;
branches;
next	1.148;
commitid	RjsAPRkWwvS79w40;

1.148
date	2015.11.12.11.05.34;	author nicm;	state Exp;
branches;
next	1.147;
commitid	Ih1tdqtjpnEyfE8x;

1.147
date	2015.10.31.08.13.58;	author nicm;	state Exp;
branches;
next	1.146;
commitid	B5GekkO0CdWpFMrz;

1.146
date	2015.10.27.15.58.43;	author nicm;	state Exp;
branches;
next	1.145;
commitid	89xhQafU35Q5MQVC;

1.145
date	2015.09.14.11.34.50;	author nicm;	state Exp;
branches;
next	1.144;
commitid	jBSEJQfSIiCoo49j;

1.144
date	2015.08.29.23.55.55;	author nicm;	state Exp;
branches;
next	1.143;
commitid	30I1jbL0UB55CZIu;

1.143
date	2015.08.29.08.30.54;	author nicm;	state Exp;
branches;
next	1.142;
commitid	RrlCW4OYH7he0yBf;

1.142
date	2015.08.29.00.39.18;	author nicm;	state Exp;
branches;
next	1.141;
commitid	OMd2z8Z9QKsUDlXZ;

1.141
date	2015.08.29.00.29.15;	author nicm;	state Exp;
branches;
next	1.140;
commitid	jhCDxn7bTHMNE4FM;

1.140
date	2015.08.28.17.11.12;	author nicm;	state Exp;
branches;
next	1.139;
commitid	ZZR0Fn1BgOb3h3mP;

1.139
date	2015.08.28.16.10.46;	author nicm;	state Exp;
branches;
next	1.138;
commitid	5Oy3Fyd66jXdISPs;

1.138
date	2015.08.28.15.51.48;	author nicm;	state Exp;
branches;
next	1.137;
commitid	blWK8QcMFPW3AUtZ;

1.137
date	2015.08.28.07.55.43;	author nicm;	state Exp;
branches;
next	1.136;
commitid	c8XaDKhVdtv7tEYK;

1.136
date	2015.08.28.07.49.24;	author nicm;	state Exp;
branches;
next	1.135;
commitid	0EjAW6v3xnwJqHbL;

1.135
date	2015.07.17.13.09.07;	author nicm;	state Exp;
branches;
next	1.134;
commitid	YSMVGChGs6jTXtCV;

1.134
date	2015.06.17.16.50.28;	author nicm;	state Exp;
branches;
next	1.133;
commitid	zbvekK98PFlsEYIW;

1.133
date	2015.06.15.10.58.01;	author nicm;	state Exp;
branches;
next	1.132;
commitid	HBSnpNJTrYXYaYTN;

1.132
date	2015.06.04.11.43.51;	author nicm;	state Exp;
branches;
next	1.131;
commitid	rAvOUA4CI6VK3gQ6;

1.131
date	2015.05.12.22.40.38;	author nicm;	state Exp;
branches;
next	1.130;
commitid	sxqWZ5H5R3E3KABV;

1.130
date	2015.05.11.10.10.16;	author nicm;	state Exp;
branches;
next	1.129;
commitid	yarRVqbIkdPvB3jr;

1.129
date	2015.05.07.11.42.56;	author nicm;	state Exp;
branches;
next	1.128;
commitid	aHjVLgOHz1Tie9FQ;

1.128
date	2015.05.06.08.35.39;	author nicm;	state Exp;
branches;
next	1.127;
commitid	7XqxdN1FHegvjfQk;

1.127
date	2015.04.28.10.43.14;	author nicm;	state Exp;
branches;
next	1.126;
commitid	S1rOdgmrftCOUlG6;

1.126
date	2015.04.25.18.56.05;	author nicm;	state Exp;
branches;
next	1.125;
commitid	aY1U5pEynDDO64Pm;

1.125
date	2015.04.25.18.49.01;	author nicm;	state Exp;
branches;
next	1.124;
commitid	OvVP75Ylb5es4t32;

1.124
date	2015.04.25.18.33.59;	author nicm;	state Exp;
branches;
next	1.123;
commitid	R776bB84r7VPzyws;

1.123
date	2015.04.25.18.09.28;	author nicm;	state Exp;
branches;
next	1.122;
commitid	B7W3z8l90mUfy5Jt;

1.122
date	2015.04.22.15.30.11;	author nicm;	state Exp;
branches;
next	1.121;
commitid	0bmlELm9krdoS6OB;

1.121
date	2015.04.22.15.05.03;	author nicm;	state Exp;
branches;
next	1.120;
commitid	NOv4t3Ada2mtdBzi;

1.120
date	2015.04.21.22.38.50;	author nicm;	state Exp;
branches;
next	1.119;
commitid	MULQMBCHDfIGQ0ED;

1.119
date	2015.04.20.07.50.49;	author nicm;	state Exp;
branches;
next	1.118;
commitid	Zopwh7L0bLUv2CH9;

1.118
date	2015.04.19.21.34.21;	author nicm;	state Exp;
branches;
next	1.117;
commitid	wug6ctIOfhVMeWQp;

1.117
date	2015.04.19.21.05.27;	author nicm;	state Exp;
branches;
next	1.116;
commitid	ksfuI8mTVk7XPyr3;

1.116
date	2015.02.09.12.47.18;	author nicm;	state Exp;
branches;
next	1.115;
commitid	8TmCS4WVBeMFdrUA;

1.115
date	2014.12.15.10.04.18;	author nicm;	state Exp;
branches;
next	1.114;
commitid	oVNkhUvNHElmCbSX;

1.114
date	2014.10.21.22.22.04;	author nicm;	state Exp;
branches;
next	1.113;
commitid	65v69dyr6BLoa8kb;

1.113
date	2014.08.11.22.14.30;	author nicm;	state Exp;
branches;
next	1.112;
commitid	whaUj6ycByfMr14q;

1.112
date	2014.06.23.10.27.05;	author nicm;	state Exp;
branches;
next	1.111;
commitid	kUevmpneWHZDEcRR;

1.111
date	2014.06.05.22.14.29;	author nicm;	state Exp;
branches;
next	1.110;
commitid	XzlpCYVOCrD8k1IS;

1.110
date	2014.05.13.08.08.32;	author nicm;	state Exp;
branches;
next	1.109;

1.109
date	2014.05.08.06.03.30;	author nicm;	state Exp;
branches;
next	1.108;

1.108
date	2014.04.17.14.45.49;	author nicm;	state Exp;
branches;
next	1.107;

1.107
date	2014.04.17.13.02.59;	author nicm;	state Exp;
branches;
next	1.106;

1.106
date	2014.04.17.11.38.35;	author nicm;	state Exp;
branches;
next	1.105;

1.105
date	2014.04.17.09.13.13;	author nicm;	state Exp;
branches;
next	1.104;

1.104
date	2014.04.17.07.36.45;	author nicm;	state Exp;
branches;
next	1.103;

1.103
date	2014.03.31.21.41.07;	author nicm;	state Exp;
branches;
next	1.102;

1.102
date	2014.02.22.18.01.10;	author nicm;	state Exp;
branches;
next	1.101;

1.101
date	2014.01.28.23.07.09;	author nicm;	state Exp;
branches;
next	1.100;

1.100
date	2014.01.28.22.19.17;	author nicm;	state Exp;
branches;
next	1.99;

1.99
date	2013.10.10.12.26.37;	author nicm;	state Exp;
branches;
next	1.98;

1.98
date	2013.10.10.11.59.23;	author nicm;	state Exp;
branches;
next	1.97;

1.97
date	2013.03.26.10.54.48;	author nicm;	state Exp;
branches;
next	1.96;

1.96
date	2013.03.25.15.59.57;	author nicm;	state Exp;
branches;
next	1.95;

1.95
date	2013.03.25.11.55.01;	author nicm;	state Exp;
branches;
next	1.94;

1.94
date	2013.03.25.11.39.11;	author nicm;	state Exp;
branches;
next	1.93;

1.93
date	2013.03.24.09.57.59;	author nicm;	state Exp;
branches;
next	1.92;

1.92
date	2013.03.24.09.25.04;	author nicm;	state Exp;
branches;
next	1.91;

1.91
date	2013.03.24.09.21.27;	author nicm;	state Exp;
branches;
next	1.90;

1.90
date	2013.03.22.10.31.22;	author nicm;	state Exp;
branches;
next	1.89;

1.89
date	2013.02.05.11.08.59;	author nicm;	state Exp;
branches;
next	1.88;

1.88
date	2013.01.17.00.11.22;	author nicm;	state Exp;
branches;
next	1.87;

1.87
date	2012.11.27.20.08.42;	author nicm;	state Exp;
branches;
next	1.86;

1.86
date	2012.10.26.14.35.42;	author nicm;	state Exp;
branches;
next	1.85;

1.85
date	2012.10.25.11.14.46;	author nicm;	state Exp;
branches;
next	1.84;

1.84
date	2012.08.21.10.00.33;	author nicm;	state Exp;
branches;
next	1.83;

1.83
date	2012.08.11.06.45.33;	author nicm;	state Exp;
branches;
next	1.82;

1.82
date	2012.07.10.11.53.01;	author nicm;	state Exp;
branches;
next	1.81;

1.81
date	2012.07.08.07.27.32;	author nicm;	state Exp;
branches;
next	1.80;

1.80
date	2012.05.28.08.55.43;	author nicm;	state Exp;
branches;
next	1.79;

1.79
date	2012.04.08.06.47.26;	author nicm;	state Exp;
branches;
next	1.78;

1.78
date	2012.04.01.20.53.47;	author nicm;	state Exp;
branches;
next	1.77;

1.77
date	2012.04.01.13.18.38;	author nicm;	state Exp;
branches;
next	1.76;

1.76
date	2012.03.20.14.06.44;	author nicm;	state Exp;
branches;
next	1.75;

1.75
date	2012.03.20.11.01.00;	author nicm;	state Exp;
branches;
next	1.74;

1.74
date	2012.03.17.22.35.09;	author nicm;	state Exp;
branches;
next	1.73;

1.73
date	2012.03.17.18.24.07;	author nicm;	state Exp;
branches;
next	1.72;

1.72
date	2012.02.02.00.10.12;	author nicm;	state Exp;
branches;
next	1.71;

1.71
date	2012.01.30.09.39.34;	author nicm;	state Exp;
branches;
next	1.70;

1.70
date	2012.01.29.02.22.11;	author nicm;	state Exp;
branches;
next	1.69;

1.69
date	2011.11.15.23.19.51;	author nicm;	state Exp;
branches;
next	1.68;

1.68
date	2011.09.25.18.53.04;	author nicm;	state Exp;
branches;
next	1.67;

1.67
date	2011.08.24.10.29.57;	author nicm;	state Exp;
branches;
next	1.66;

1.66
date	2011.06.05.10.53.05;	author nicm;	state Exp;
branches;
next	1.65;

1.65
date	2011.04.18.20.57.16;	author nicm;	state Exp;
branches;
next	1.64;

1.64
date	2011.03.27.20.27.27;	author nicm;	state Exp;
branches;
next	1.63;

1.63
date	2011.01.25.22.31.50;	author nicm;	state Exp;
branches;
next	1.62;

1.62
date	2011.01.08.01.52.37;	author nicm;	state Exp;
branches;
next	1.61;

1.61
date	2010.12.30.21.35.17;	author nicm;	state Exp;
branches;
next	1.60;

1.60
date	2010.12.06.22.51.02;	author nicm;	state Exp;
branches;
next	1.59;

1.59
date	2010.11.14.08.58.25;	author nicm;	state Exp;
branches;
next	1.58;

1.58
date	2010.10.23.13.04.34;	author nicm;	state Exp;
branches;
next	1.57;

1.57
date	2010.10.23.12.51.51;	author nicm;	state Exp;
branches;
next	1.56;

1.56
date	2010.10.16.08.31.55;	author nicm;	state Exp;
branches;
next	1.55;

1.55
date	2010.08.25.19.19.43;	author nicm;	state Exp;
branches;
next	1.54;

1.54
date	2010.08.19.18.29.01;	author nicm;	state Exp;
branches;
next	1.53;

1.53
date	2010.07.14.18.37.49;	author nicm;	state Exp;
branches;
next	1.52;

1.52
date	2010.06.21.01.46.36;	author nicm;	state Exp;
branches;
next	1.51;

1.51
date	2010.05.23.19.42.19;	author nicm;	state Exp;
branches;
next	1.50;

1.50
date	2010.05.04.17.28.16;	author nicm;	state Exp;
branches;
next	1.49;

1.49
date	2010.05.04.08.48.06;	author nicm;	state Exp;
branches;
next	1.48;

1.48
date	2010.05.03.16.06.32;	author nicm;	state Exp;
branches;
next	1.47;

1.47
date	2010.04.04.19.02.09;	author nicm;	state Exp;
branches;
next	1.46;

1.46
date	2010.04.04.18.48.37;	author nicm;	state Exp;
branches;
next	1.45;

1.45
date	2010.03.22.19.07.52;	author nicm;	state Exp;
branches;
next	1.44;

1.44
date	2010.03.22.19.02.54;	author nicm;	state Exp;
branches;
next	1.43;

1.43
date	2010.02.06.17.15.33;	author nicm;	state Exp;
branches;
next	1.42;

1.42
date	2009.12.03.22.50.10;	author nicm;	state Exp;
branches;
next	1.41;

1.41
date	2009.11.26.21.37.13;	author nicm;	state Exp;
branches;
next	1.40;

1.40
date	2009.11.19.19.47.28;	author nicm;	state Exp;
branches;
next	1.39;

1.39
date	2009.11.13.17.33.07;	author nicm;	state Exp;
branches;
next	1.38;

1.38
date	2009.11.04.23.54.57;	author nicm;	state Exp;
branches;
next	1.37;

1.37
date	2009.11.04.22.43.11;	author nicm;	state Exp;
branches;
next	1.36;

1.36
date	2009.11.04.22.02.38;	author nicm;	state Exp;
branches;
next	1.35;

1.35
date	2009.11.04.20.50.11;	author nicm;	state Exp;
branches;
next	1.34;

1.34
date	2009.10.22.12.30.00;	author nicm;	state Exp;
branches;
next	1.33;

1.33
date	2009.10.19.13.18.13;	author nicm;	state Exp;
branches;
next	1.32;

1.32
date	2009.10.11.10.04.27;	author nicm;	state Exp;
branches;
next	1.31;

1.31
date	2009.10.11.07.01.10;	author nicm;	state Exp;
branches;
next	1.30;

1.30
date	2009.10.10.15.29.34;	author nicm;	state Exp;
branches;
next	1.29;

1.29
date	2009.10.10.14.51.16;	author nicm;	state Exp;
branches;
next	1.28;

1.28
date	2009.10.10.10.02.48;	author nicm;	state Exp;
branches;
next	1.27;

1.27
date	2009.10.09.07.27.00;	author nicm;	state Exp;
branches;
next	1.26;

1.26
date	2009.09.20.14.58.12;	author nicm;	state Exp;
branches;
next	1.25;

1.25
date	2009.09.16.12.35.04;	author nicm;	state Exp;
branches;
next	1.24;

1.24
date	2009.09.01.14.40.33;	author nicm;	state Exp;
branches;
next	1.23;

1.23
date	2009.09.01.13.09.50;	author nicm;	state Exp;
branches;
next	1.22;

1.22
date	2009.08.13.20.11.58;	author nicm;	state Exp;
branches;
next	1.21;

1.21
date	2009.08.13.19.04.00;	author nicm;	state Exp;
branches;
next	1.20;

1.20
date	2009.08.12.09.14.25;	author nicm;	state Exp;
branches;
next	1.19;

1.19
date	2009.08.11.21.28.11;	author nicm;	state Exp;
branches;
next	1.18;

1.18
date	2009.08.08.21.52.43;	author nicm;	state Exp;
branches;
next	1.17;

1.17
date	2009.07.28.06.48.44;	author nicm;	state Exp;
branches;
next	1.16;

1.16
date	2009.07.22.21.34.36;	author nicm;	state Exp;
branches;
next	1.15;

1.15
date	2009.07.21.19.54.22;	author nicm;	state Exp;
branches;
next	1.14;

1.14
date	2009.07.19.13.21.40;	author nicm;	state Exp;
branches;
next	1.13;

1.13
date	2009.07.17.18.45.08;	author nicm;	state Exp;
branches;
next	1.12;

1.12
date	2009.07.15.08.00.49;	author nicm;	state Exp;
branches;
next	1.11;

1.11
date	2009.07.14.16.52.50;	author nicm;	state Exp;
branches;
next	1.10;

1.10
date	2009.07.14.07.23.36;	author nicm;	state Exp;
branches;
next	1.9;

1.9
date	2009.07.13.10.43.52;	author nicm;	state Exp;
branches;
next	1.8;

1.8
date	2009.07.08.05.26.45;	author nicm;	state Exp;
branches;
next	1.7;

1.7
date	2009.07.07.19.49.19;	author nicm;	state Exp;
branches;
next	1.6;

1.6
date	2009.06.25.06.15.04;	author nicm;	state Exp;
branches;
next	1.5;

1.5
date	2009.06.24.22.49.56;	author nicm;	state Exp;
branches;
next	1.4;

1.4
date	2009.06.24.22.04.18;	author nicm;	state Exp;
branches;
next	1.3;

1.3
date	2009.06.23.20.17.30;	author nicm;	state Exp;
branches;
next	1.2;

1.2
date	2009.06.05.07.18.37;	author nicm;	state Exp;
branches;
next	1.1;

1.1
date	2009.06.01.22.58.49;	author nicm;	state Exp;
branches;
next	;


desc
@@


1.203
log
@Block signals between forking and clearing signal handlers (or calling
event_reinit) - if the child gets a signal and fires the libevent signal
handler during this period it could write a signal into the parent's
signal pipe. GitHub issue 1001 from Aaron van Geffen.
@
text
@/* $OpenBSD: window.c,v 1.202 2017/07/12 09:24:17 nicm Exp $ */

/*
 * Copyright (c) 2007 Nicholas Marriott <nicholas.marriott@@gmail.com>
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF MIND, USE, DATA OR PROFITS, WHETHER
 * IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING
 * OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */

#include <sys/types.h>
#include <sys/ioctl.h>

#include <errno.h>
#include <fcntl.h>
#include <fnmatch.h>
#include <signal.h>
#include <stdint.h>
#include <stdlib.h>
#include <string.h>
#include <termios.h>
#include <time.h>
#include <unistd.h>
#include <util.h>
#include <vis.h>

#include "tmux.h"

/*
 * Each window is attached to a number of panes, each of which is a pty. This
 * file contains code to handle them.
 *
 * A pane has two buffers attached, these are filled and emptied by the main
 * server poll loop. Output data is received from pty's in screen format,
 * translated and returned as a series of escape sequences and strings via
 * input_parse (in input.c). Input data is received as key codes and written
 * directly via input_key.
 *
 * Each pane also has a "virtual" screen (screen.c) which contains the current
 * state and is redisplayed when the window is reattached to a client.
 *
 * Windows are stored directly on a global array and wrapped in any number of
 * winlink structs to be linked onto local session RB trees. A reference count
 * is maintained and a window removed from the global list and destroyed when
 * it reaches zero.
 */

/* Global window list. */
struct windows windows;

/* Global panes tree. */
struct window_pane_tree all_window_panes;
static u_int	next_window_pane_id;
static u_int	next_window_id;
static u_int	next_active_point;

static void	window_destroy(struct window *);

static struct window_pane *window_pane_create(struct window *, u_int, u_int,
		    u_int);
static void	window_pane_destroy(struct window_pane *);

static void	window_pane_read_callback(struct bufferevent *, void *);
static void	window_pane_error_callback(struct bufferevent *, short, void *);

static int	winlink_next_index(struct winlinks *, int);

static struct window_pane *window_pane_choose_best(struct window_pane **,
		    u_int);

RB_GENERATE(windows, window, entry, window_cmp);
RB_GENERATE(winlinks, winlink, entry, winlink_cmp);
RB_GENERATE(window_pane_tree, window_pane, tree_entry, window_pane_cmp);

int
window_cmp(struct window *w1, struct window *w2)
{
	return (w1->id - w2->id);
}

int
winlink_cmp(struct winlink *wl1, struct winlink *wl2)
{
	return (wl1->idx - wl2->idx);
}

int
window_pane_cmp(struct window_pane *wp1, struct window_pane *wp2)
{
	return (wp1->id - wp2->id);
}

struct winlink *
winlink_find_by_window(struct winlinks *wwl, struct window *w)
{
	struct winlink	*wl;

	RB_FOREACH(wl, winlinks, wwl) {
		if (wl->window == w)
			return (wl);
	}

	return (NULL);
}

struct winlink *
winlink_find_by_index(struct winlinks *wwl, int idx)
{
	struct winlink	wl;

	if (idx < 0)
		fatalx("bad index");

	wl.idx = idx;
	return (RB_FIND(winlinks, wwl, &wl));
}

struct winlink *
winlink_find_by_window_id(struct winlinks *wwl, u_int id)
{
	struct winlink *wl;

	RB_FOREACH(wl, winlinks, wwl) {
		if (wl->window->id == id)
			return (wl);
	}
	return (NULL);
}

static int
winlink_next_index(struct winlinks *wwl, int idx)
{
	int	i;

	i = idx;
	do {
		if (winlink_find_by_index(wwl, i) == NULL)
			return (i);
		if (i == INT_MAX)
			i = 0;
		else
			i++;
	} while (i != idx);
	return (-1);
}

u_int
winlink_count(struct winlinks *wwl)
{
	struct winlink	*wl;
	u_int		 n;

	n = 0;
	RB_FOREACH(wl, winlinks, wwl)
		n++;

	return (n);
}

struct winlink *
winlink_add(struct winlinks *wwl, int idx)
{
	struct winlink	*wl;

	if (idx < 0) {
		if ((idx = winlink_next_index(wwl, -idx - 1)) == -1)
			return (NULL);
	} else if (winlink_find_by_index(wwl, idx) != NULL)
		return (NULL);

	wl = xcalloc(1, sizeof *wl);
	wl->idx = idx;
	RB_INSERT(winlinks, wwl, wl);

	return (wl);
}

void
winlink_set_window(struct winlink *wl, struct window *w)
{
	if (wl->window != NULL) {
		TAILQ_REMOVE(&wl->window->winlinks, wl, wentry);
		window_remove_ref(wl->window, __func__);
	}
	TAILQ_INSERT_TAIL(&w->winlinks, wl, wentry);
	wl->window = w;
	window_add_ref(w, __func__);
}

void
winlink_remove(struct winlinks *wwl, struct winlink *wl)
{
	struct window	*w = wl->window;

	if (w != NULL) {
		TAILQ_REMOVE(&w->winlinks, wl, wentry);
		window_remove_ref(w, __func__);
	}

	RB_REMOVE(winlinks, wwl, wl);
	free(wl->status_text);
	free(wl);
}

struct winlink *
winlink_next(struct winlink *wl)
{
	return (RB_NEXT(winlinks, wwl, wl));
}

struct winlink *
winlink_previous(struct winlink *wl)
{
	return (RB_PREV(winlinks, wwl, wl));
}

struct winlink *
winlink_next_by_number(struct winlink *wl, struct session *s, int n)
{
	for (; n > 0; n--) {
		if ((wl = RB_NEXT(winlinks, wwl, wl)) == NULL)
			wl = RB_MIN(winlinks, &s->windows);
	}

	return (wl);
}

struct winlink *
winlink_previous_by_number(struct winlink *wl, struct session *s, int n)
{
	for (; n > 0; n--) {
		if ((wl = RB_PREV(winlinks, wwl, wl)) == NULL)
			wl = RB_MAX(winlinks, &s->windows);
	}

	return (wl);
}

void
winlink_stack_push(struct winlink_stack *stack, struct winlink *wl)
{
	if (wl == NULL)
		return;

	winlink_stack_remove(stack, wl);
	TAILQ_INSERT_HEAD(stack, wl, sentry);
}

void
winlink_stack_remove(struct winlink_stack *stack, struct winlink *wl)
{
	struct winlink	*wl2;

	if (wl == NULL)
		return;

	TAILQ_FOREACH(wl2, stack, sentry) {
		if (wl2 == wl) {
			TAILQ_REMOVE(stack, wl, sentry);
			return;
		}
	}
}

struct window *
window_find_by_id_str(const char *s)
{
	const char	*errstr;
	u_int		 id;

	if (*s != '@@')
		return (NULL);

	id = strtonum(s + 1, 0, UINT_MAX, &errstr);
	if (errstr != NULL)
		return (NULL);
	return (window_find_by_id(id));
}

struct window *
window_find_by_id(u_int id)
{
	struct window	w;

	w.id = id;
	return (RB_FIND(windows, &windows, &w));
}

void
window_update_activity(struct window *w)
{
	gettimeofday(&w->activity_time, NULL);
	alerts_queue(w, WINDOW_ACTIVITY);
}

struct window *
window_create(u_int sx, u_int sy)
{
	struct window	*w;

	w = xcalloc(1, sizeof *w);
	w->name = NULL;
	w->flags = WINDOW_STYLECHANGED;

	TAILQ_INIT(&w->panes);
	w->active = NULL;

	w->lastlayout = -1;
	w->layout_root = NULL;

	w->sx = sx;
	w->sy = sy;

	w->options = options_create(global_w_options);

	w->references = 0;
	TAILQ_INIT(&w->winlinks);

	w->id = next_window_id++;
	RB_INSERT(windows, &windows, w);

	window_update_activity(w);

	return (w);
}

struct window *
window_create_spawn(const char *name, int argc, char **argv, const char *path,
    const char *shell, const char *cwd, struct environ *env,
    struct termios *tio, u_int sx, u_int sy, u_int hlimit, char **cause)
{
	struct window		*w;
	struct window_pane	*wp;

	w = window_create(sx, sy);
	wp = window_add_pane(w, NULL, 0, hlimit);
	layout_init(w, wp);

	if (window_pane_spawn(wp, argc, argv, path, shell, cwd,
	    env, tio, cause) != 0) {
		window_destroy(w);
		return (NULL);
	}

	w->active = TAILQ_FIRST(&w->panes);
	if (name != NULL) {
		w->name = xstrdup(name);
		options_set_number(w->options, "automatic-rename", 0);
	} else
		w->name = default_window_name(w);

	notify_window("window-pane-changed", w);

	return (w);
}

static void
window_destroy(struct window *w)
{
	log_debug("window @@%u destroyed (%d references)", w->id, w->references);

	RB_REMOVE(windows, &windows, w);

	if (w->layout_root != NULL)
		layout_free_cell(w->layout_root);
	if (w->saved_layout_root != NULL)
		layout_free_cell(w->saved_layout_root);
	free(w->old_layout);

	if (event_initialized(&w->name_event))
		evtimer_del(&w->name_event);

	if (event_initialized(&w->alerts_timer))
		evtimer_del(&w->alerts_timer);

	options_free(w->options);

	window_destroy_panes(w);

	free(w->name);
	free(w);
}

int
window_pane_destroy_ready(struct window_pane *wp)
{
	int	n;

	if (wp->pipe_fd != -1) {
		if (EVBUFFER_LENGTH(wp->pipe_event->output) != 0)
			return (0);
		if (ioctl(wp->fd, FIONREAD, &n) != -1 && n > 0)
			return (0);
	}

	if (~wp->flags & PANE_EXITED)
		return (0);
	return (1);
}

void
window_add_ref(struct window *w, const char *from)
{
	w->references++;
	log_debug("%s: @@%u %s, now %d", __func__, w->id, from, w->references);
}

void
window_remove_ref(struct window *w, const char *from)
{
	w->references--;
	log_debug("%s: @@%u %s, now %d", __func__, w->id, from, w->references);

	if (w->references == 0)
		window_destroy(w);
}

void
window_set_name(struct window *w, const char *new_name)
{
	free(w->name);
	utf8_stravis(&w->name, new_name, VIS_OCTAL|VIS_CSTYLE|VIS_TAB|VIS_NL);
	notify_window("window-renamed", w);
}

void
window_resize(struct window *w, u_int sx, u_int sy)
{
	w->sx = sx;
	w->sy = sy;
}

int
window_has_pane(struct window *w, struct window_pane *wp)
{
	struct window_pane	*wp1;

	TAILQ_FOREACH(wp1, &w->panes, entry) {
		if (wp1 == wp)
			return (1);
	}
	return (0);
}

int
window_set_active_pane(struct window *w, struct window_pane *wp)
{
	log_debug("%s: pane %%%u (was %%%u)", __func__, wp->id, w->active->id);
	if (wp == w->active)
		return (0);
	w->last = w->active;
	w->active = wp;
	while (!window_pane_visible(w->active)) {
		w->active = TAILQ_PREV(w->active, window_panes, entry);
		if (w->active == NULL)
			w->active = TAILQ_LAST(&w->panes, window_panes);
		if (w->active == wp) {
			notify_window("window-pane-changed", w);
			return (1);
		}
	}
	w->active->active_point = next_active_point++;
	w->active->flags |= PANE_CHANGED;
	notify_window("window-pane-changed", w);
	return (1);
}

void
window_redraw_active_switch(struct window *w, struct window_pane *wp)
{
	const struct grid_cell	*gc;

	if (wp == w->active)
		return;

	/*
	 * If window-style and window-active-style are the same, we don't need
	 * to redraw panes when switching active panes.
	 */
	gc = options_get_style(w->options, "window-active-style");
	if (style_equal(gc, options_get_style(w->options, "window-style")))
		return;

	/*
	 * If the now active or inactive pane do not have a custom style or if
	 * the palette is different, they need to be redrawn.
	 */
	if (window_pane_get_palette(w->active, w->active->colgc.fg) != -1 ||
	    window_pane_get_palette(w->active, w->active->colgc.bg) != -1 ||
	    style_equal(&grid_default_cell, &w->active->colgc))
		w->active->flags |= PANE_REDRAW;
	if (window_pane_get_palette(wp, wp->colgc.fg) != -1 ||
	    window_pane_get_palette(wp, wp->colgc.bg) != -1 ||
	    style_equal(&grid_default_cell, &wp->colgc))
		wp->flags |= PANE_REDRAW;
}

struct window_pane *
window_get_active_at(struct window *w, u_int x, u_int y)
{
	struct window_pane	*wp;

	TAILQ_FOREACH(wp, &w->panes, entry) {
		if (!window_pane_visible(wp))
			continue;
		if (x < wp->xoff || x > wp->xoff + wp->sx)
			continue;
		if (y < wp->yoff || y > wp->yoff + wp->sy)
			continue;
		return (wp);
	}
	return (NULL);
}

struct window_pane *
window_find_string(struct window *w, const char *s)
{
	u_int	x, y;

	x = w->sx / 2;
	y = w->sy / 2;

	if (strcasecmp(s, "top") == 0)
		y = 0;
	else if (strcasecmp(s, "bottom") == 0)
		y = w->sy - 1;
	else if (strcasecmp(s, "left") == 0)
		x = 0;
	else if (strcasecmp(s, "right") == 0)
		x = w->sx - 1;
	else if (strcasecmp(s, "top-left") == 0) {
		x = 0;
		y = 0;
	} else if (strcasecmp(s, "top-right") == 0) {
		x = w->sx - 1;
		y = 0;
	} else if (strcasecmp(s, "bottom-left") == 0) {
		x = 0;
		y = w->sy - 1;
	} else if (strcasecmp(s, "bottom-right") == 0) {
		x = w->sx - 1;
		y = w->sy - 1;
	} else
		return (NULL);

	return (window_get_active_at(w, x, y));
}

int
window_zoom(struct window_pane *wp)
{
	struct window		*w = wp->window;
	struct window_pane	*wp1;

	if (w->flags & WINDOW_ZOOMED)
		return (-1);

	if (!window_pane_visible(wp))
		return (-1);

	if (window_count_panes(w) == 1)
		return (-1);

	if (w->active != wp)
		window_set_active_pane(w, wp);

	TAILQ_FOREACH(wp1, &w->panes, entry) {
		wp1->saved_layout_cell = wp1->layout_cell;
		wp1->layout_cell = NULL;
	}

	w->saved_layout_root = w->layout_root;
	layout_init(w, wp);
	w->flags |= WINDOW_ZOOMED;
	notify_window("window-layout-changed", w);

	return (0);
}

int
window_unzoom(struct window *w)
{
	struct window_pane	*wp;

	if (!(w->flags & WINDOW_ZOOMED))
		return (-1);

	w->flags &= ~WINDOW_ZOOMED;
	layout_free(w);
	w->layout_root = w->saved_layout_root;
	w->saved_layout_root = NULL;

	TAILQ_FOREACH(wp, &w->panes, entry) {
		wp->layout_cell = wp->saved_layout_cell;
		wp->saved_layout_cell = NULL;
	}
	layout_fix_panes(w, w->sx, w->sy);
	notify_window("window-layout-changed", w);

	return (0);
}

struct window_pane *
window_add_pane(struct window *w, struct window_pane *other, int before,
    u_int hlimit)
{
	struct window_pane	*wp;

	if (other == NULL)
		other = w->active;

	wp = window_pane_create(w, w->sx, w->sy, hlimit);
	if (TAILQ_EMPTY(&w->panes)) {
		log_debug("%s: @@%u at start", __func__, w->id);
		TAILQ_INSERT_HEAD(&w->panes, wp, entry);
	} else if (before) {
		log_debug("%s: @@%u before %%%u", __func__, w->id, wp->id);
		TAILQ_INSERT_BEFORE(other, wp, entry);
	} else {
		log_debug("%s: @@%u after %%%u", __func__, w->id, wp->id);
		TAILQ_INSERT_AFTER(&w->panes, other, wp, entry);
	}
	return (wp);
}

void
window_lost_pane(struct window *w, struct window_pane *wp)
{
	if (wp == marked_pane.wp)
		server_clear_marked();

	if (wp == w->active) {
		w->active = w->last;
		w->last = NULL;
		if (w->active == NULL) {
			w->active = TAILQ_PREV(wp, window_panes, entry);
			if (w->active == NULL)
				w->active = TAILQ_NEXT(wp, entry);
		}
		if (w->active != NULL) {
			w->active->flags |= PANE_CHANGED;
			notify_window("window-pane-changed", w);
		}
	} else if (wp == w->last)
		w->last = NULL;
}

void
window_remove_pane(struct window *w, struct window_pane *wp)
{
	window_lost_pane(w, wp);

	TAILQ_REMOVE(&w->panes, wp, entry);
	window_pane_destroy(wp);
}

struct window_pane *
window_pane_at_index(struct window *w, u_int idx)
{
	struct window_pane	*wp;
	u_int			 n;

	n = options_get_number(w->options, "pane-base-index");
	TAILQ_FOREACH(wp, &w->panes, entry) {
		if (n == idx)
			return (wp);
		n++;
	}
	return (NULL);
}

struct window_pane *
window_pane_next_by_number(struct window *w, struct window_pane *wp, u_int n)
{
	for (; n > 0; n--) {
		if ((wp = TAILQ_NEXT(wp, entry)) == NULL)
			wp = TAILQ_FIRST(&w->panes);
	}

	return (wp);
}

struct window_pane *
window_pane_previous_by_number(struct window *w, struct window_pane *wp,
    u_int n)
{
	for (; n > 0; n--) {
		if ((wp = TAILQ_PREV(wp, window_panes, entry)) == NULL)
			wp = TAILQ_LAST(&w->panes, window_panes);
	}

	return (wp);
}

int
window_pane_index(struct window_pane *wp, u_int *i)
{
	struct window_pane	*wq;
	struct window		*w = wp->window;

	*i = options_get_number(w->options, "pane-base-index");
	TAILQ_FOREACH(wq, &w->panes, entry) {
		if (wp == wq) {
			return (0);
		}
		(*i)++;
	}

	return (-1);
}

u_int
window_count_panes(struct window *w)
{
	struct window_pane	*wp;
	u_int			 n;

	n = 0;
	TAILQ_FOREACH(wp, &w->panes, entry)
		n++;
	return (n);
}

void
window_destroy_panes(struct window *w)
{
	struct window_pane	*wp;

	while (!TAILQ_EMPTY(&w->panes)) {
		wp = TAILQ_FIRST(&w->panes);
		TAILQ_REMOVE(&w->panes, wp, entry);
		window_pane_destroy(wp);
	}
}

const char *
window_printable_flags(struct winlink *wl)
{
	struct session	*s = wl->session;
	static char	 flags[32];
	int		 pos;

	pos = 0;
	if (wl->flags & WINLINK_ACTIVITY)
		flags[pos++] = '#';
	if (wl->flags & WINLINK_BELL)
		flags[pos++] = '!';
	if (wl->flags & WINLINK_SILENCE)
		flags[pos++] = '~';
	if (wl == s->curw)
		flags[pos++] = '*';
	if (wl == TAILQ_FIRST(&s->lastw))
		flags[pos++] = '-';
	if (server_check_marked() && wl == marked_pane.wl)
		flags[pos++] = 'M';
	if (wl->window->flags & WINDOW_ZOOMED)
		flags[pos++] = 'Z';
	flags[pos] = '\0';
	return (flags);
}

struct window_pane *
window_pane_find_by_id_str(const char *s)
{
	const char	*errstr;
	u_int		 id;

	if (*s != '%')
		return (NULL);

	id = strtonum(s + 1, 0, UINT_MAX, &errstr);
	if (errstr != NULL)
		return (NULL);
	return (window_pane_find_by_id(id));
}

struct window_pane *
window_pane_find_by_id(u_int id)
{
	struct window_pane	wp;

	wp.id = id;
	return (RB_FIND(window_pane_tree, &all_window_panes, &wp));
}

static struct window_pane *
window_pane_create(struct window *w, u_int sx, u_int sy, u_int hlimit)
{
	struct window_pane	*wp;
	char			 host[HOST_NAME_MAX + 1];

	wp = xcalloc(1, sizeof *wp);
	wp->window = w;

	wp->id = next_window_pane_id++;
	RB_INSERT(window_pane_tree, &all_window_panes, wp);

	wp->argc = 0;
	wp->argv = NULL;
	wp->shell = NULL;
	wp->cwd = NULL;

	wp->fd = -1;
	wp->event = NULL;

	wp->mode = NULL;
	wp->modeprefix = 1;

	wp->layout_cell = NULL;

	wp->xoff = 0;
	wp->yoff = 0;

	wp->sx = wp->osx = sx;
	wp->sy = wp->osx = sy;

	wp->pipe_fd = -1;
	wp->pipe_off = 0;
	wp->pipe_event = NULL;

	wp->saved_grid = NULL;

	memcpy(&wp->colgc, &grid_default_cell, sizeof wp->colgc);

	screen_init(&wp->base, sx, sy, hlimit);
	wp->screen = &wp->base;

	screen_init(&wp->status_screen, 1, 1, 0);

	if (gethostname(host, sizeof host) == 0)
		screen_set_title(&wp->base, host);

	input_init(wp);

	return (wp);
}

static void
window_pane_destroy(struct window_pane *wp)
{
	window_pane_reset_mode(wp);
	free(wp->searchstr);

	if (wp->fd != -1) {
		bufferevent_free(wp->event);
		close(wp->fd);
	}

	input_free(wp);

	screen_free(&wp->base);
	if (wp->saved_grid != NULL)
		grid_destroy(wp->saved_grid);

	if (wp->pipe_fd != -1) {
		bufferevent_free(wp->pipe_event);
		close(wp->pipe_fd);
	}

	if (event_initialized(&wp->resize_timer))
		event_del(&wp->resize_timer);

	RB_REMOVE(window_pane_tree, &all_window_panes, wp);

	free((void *)wp->cwd);
	free(wp->shell);
	cmd_free_argv(wp->argc, wp->argv);
	free(wp->palette);
	free(wp);
}

int
window_pane_spawn(struct window_pane *wp, int argc, char **argv,
    const char *path, const char *shell, const char *cwd, struct environ *env,
    struct termios *tio, char **cause)
{
	struct winsize	 ws;
	char		*argv0, *cmd, **argvp;
	const char	*ptr, *first, *home;
	struct termios	 tio2;
	int		 i;
	sigset_t	 set, oldset;

	if (wp->fd != -1) {
		bufferevent_free(wp->event);
		close(wp->fd);
	}
	if (argc > 0) {
		cmd_free_argv(wp->argc, wp->argv);
		wp->argc = argc;
		wp->argv = cmd_copy_argv(argc, argv);
	}
	if (shell != NULL) {
		free(wp->shell);
		wp->shell = xstrdup(shell);
	}
	if (cwd != NULL) {
		free((void *)wp->cwd);
		wp->cwd = xstrdup(cwd);
	}

	cmd = cmd_stringify_argv(wp->argc, wp->argv);
	log_debug("spawn: %s -- %s", wp->shell, cmd);
	for (i = 0; i < wp->argc; i++)
		log_debug("spawn: argv[%d] = %s", i, wp->argv[i]);
	environ_log(env, "spawn: ");

	memset(&ws, 0, sizeof ws);
	ws.ws_col = screen_size_x(&wp->base);
	ws.ws_row = screen_size_y(&wp->base);

	sigfillset(&set);
	sigprocmask(SIG_BLOCK, &set, &oldset);
	switch (wp->pid = fdforkpty(ptm_fd, &wp->fd, wp->tty, NULL, &ws)) {
	case -1:
		wp->fd = -1;

		xasprintf(cause, "%s: %s", cmd, strerror(errno));
		free(cmd);

		sigprocmask(SIG_SETMASK, &oldset, NULL);
		return (-1);
	case 0:
		proc_clear_signals(server_proc);
		sigprocmask(SIG_SETMASK, &oldset, NULL);

		if (chdir(wp->cwd) != 0) {
			if ((home = find_home()) == NULL || chdir(home) != 0)
				chdir("/");
		}

		if (tcgetattr(STDIN_FILENO, &tio2) != 0)
			fatal("tcgetattr failed");
		if (tio != NULL)
			memcpy(tio2.c_cc, tio->c_cc, sizeof tio2.c_cc);
		tio2.c_cc[VERASE] = '\177';
		if (tcsetattr(STDIN_FILENO, TCSANOW, &tio2) != 0)
			fatal("tcgetattr failed");

		log_close();
		closefrom(STDERR_FILENO + 1);

		if (path != NULL)
			environ_set(env, "PATH", "%s", path);
		environ_set(env, "TMUX_PANE", "%%%u", wp->id);
		environ_push(env);

		setenv("SHELL", wp->shell, 1);
		ptr = strrchr(wp->shell, '/');

		/*
		 * If given one argument, assume it should be passed to sh -c;
		 * with more than one argument, use execvp(). If there is no
		 * arguments, create a login shell.
		 */
		if (wp->argc > 0) {
			if (wp->argc != 1) {
				/* Copy to ensure argv ends in NULL. */
				argvp = cmd_copy_argv(wp->argc, wp->argv);
				execvp(argvp[0], argvp);
				fatal("execvp failed");
			}
			first = wp->argv[0];

			if (ptr != NULL && *(ptr + 1) != '\0')
				xasprintf(&argv0, "%s", ptr + 1);
			else
				xasprintf(&argv0, "%s", wp->shell);
			execl(wp->shell, argv0, "-c", first, (char *)NULL);
			fatal("execl failed");
		}
		if (ptr != NULL && *(ptr + 1) != '\0')
			xasprintf(&argv0, "-%s", ptr + 1);
		else
			xasprintf(&argv0, "-%s", wp->shell);
		execl(wp->shell, argv0, (char *)NULL);
		fatal("execl failed");
	}

	sigprocmask(SIG_SETMASK, &oldset, NULL);
	setblocking(wp->fd, 0);

	wp->event = bufferevent_new(wp->fd, window_pane_read_callback, NULL,
	    window_pane_error_callback, wp);

	bufferevent_setwatermark(wp->event, EV_READ, 0, READ_SIZE);
	bufferevent_enable(wp->event, EV_READ|EV_WRITE);

	free(cmd);
	return (0);
}

static void
window_pane_read_callback(__unused struct bufferevent *bufev, void *data)
{
	struct window_pane	*wp = data;
	struct evbuffer		*evb = wp->event->input;
	size_t			 size = EVBUFFER_LENGTH(evb);
	char			*new_data;
	size_t			 new_size;

	new_size = size - wp->pipe_off;
	if (wp->pipe_fd != -1 && new_size > 0) {
		new_data = EVBUFFER_DATA(evb) + wp->pipe_off;
		bufferevent_write(wp->pipe_event, new_data, new_size);
	}

	log_debug("%%%u has %zu bytes", wp->id, size);
	input_parse(wp);

	wp->pipe_off = EVBUFFER_LENGTH(evb);
}

static void
window_pane_error_callback(__unused struct bufferevent *bufev,
    __unused short what, void *data)
{
	struct window_pane *wp = data;

	log_debug("%%%u error", wp->id);
	wp->flags |= PANE_EXITED;

	if (window_pane_destroy_ready(wp))
		server_destroy_pane(wp, 1);
}

void
window_pane_resize(struct window_pane *wp, u_int sx, u_int sy)
{
	if (sx == wp->sx && sy == wp->sy)
		return;
	wp->sx = sx;
	wp->sy = sy;

	screen_resize(&wp->base, sx, sy, wp->saved_grid == NULL);
	if (wp->mode != NULL)
		wp->mode->resize(wp, sx, sy);

	wp->flags |= PANE_RESIZE;
}

/*
 * Enter alternative screen mode. A copy of the visible screen is saved and the
 * history is not updated
 */
void
window_pane_alternate_on(struct window_pane *wp, struct grid_cell *gc,
    int cursor)
{
	struct screen	*s = &wp->base;
	u_int		 sx, sy;

	if (wp->saved_grid != NULL)
		return;
	if (!options_get_number(wp->window->options, "alternate-screen"))
		return;
	sx = screen_size_x(s);
	sy = screen_size_y(s);

	wp->saved_grid = grid_create(sx, sy, 0);
	grid_duplicate_lines(wp->saved_grid, 0, s->grid, screen_hsize(s), sy);
	if (cursor) {
		wp->saved_cx = s->cx;
		wp->saved_cy = s->cy;
	}
	memcpy(&wp->saved_cell, gc, sizeof wp->saved_cell);

	grid_view_clear(s->grid, 0, 0, sx, sy, 8);

	wp->base.grid->flags &= ~GRID_HISTORY;

	wp->flags |= PANE_REDRAW;
}

/* Exit alternate screen mode and restore the copied grid. */
void
window_pane_alternate_off(struct window_pane *wp, struct grid_cell *gc,
    int cursor)
{
	struct screen	*s = &wp->base;
	u_int		 sx, sy;

	if (wp->saved_grid == NULL)
		return;
	if (!options_get_number(wp->window->options, "alternate-screen"))
		return;
	sx = screen_size_x(s);
	sy = screen_size_y(s);

	/*
	 * If the current size is bigger, temporarily resize to the old size
	 * before copying back.
	 */
	if (sy > wp->saved_grid->sy)
		screen_resize(s, sx, wp->saved_grid->sy, 1);

	/* Restore the grid, cursor position and cell. */
	grid_duplicate_lines(s->grid, screen_hsize(s), wp->saved_grid, 0, sy);
	if (cursor)
		s->cx = wp->saved_cx;
	if (s->cx > screen_size_x(s) - 1)
		s->cx = screen_size_x(s) - 1;
	if (cursor)
		s->cy = wp->saved_cy;
	if (s->cy > screen_size_y(s) - 1)
		s->cy = screen_size_y(s) - 1;
	memcpy(gc, &wp->saved_cell, sizeof *gc);

	/*
	 * Turn history back on (so resize can use it) and then resize back to
	 * the current size.
	 */
	wp->base.grid->flags |= GRID_HISTORY;
	if (sy > wp->saved_grid->sy || sx != wp->saved_grid->sx)
		screen_resize(s, sx, sy, 1);

	grid_destroy(wp->saved_grid);
	wp->saved_grid = NULL;

	wp->flags |= PANE_REDRAW;
}

void
window_pane_set_palette(struct window_pane *wp, u_int n, int colour)
{
	if (n > 0xff)
		return;

	if (wp->palette == NULL)
		wp->palette = xcalloc(0x100, sizeof *wp->palette);

	wp->palette[n] = colour;
	wp->flags |= PANE_REDRAW;
}

void
window_pane_unset_palette(struct window_pane *wp, u_int n)
{
	if (n > 0xff || wp->palette == NULL)
		return;

	wp->palette[n] = 0;
	wp->flags |= PANE_REDRAW;
}

void
window_pane_reset_palette(struct window_pane *wp)
{
	if (wp->palette == NULL)
		return;

	free(wp->palette);
	wp->palette = NULL;
	wp->flags |= PANE_REDRAW;
}

int
window_pane_get_palette(const struct window_pane *wp, int c)
{
	int	new;

	if (wp == NULL || wp->palette == NULL)
		return (-1);

	new = -1;
	if (c < 8)
		new = wp->palette[c];
	else if (c >= 90 && c <= 97)
		new = wp->palette[8 + c - 90];
	else if (c & COLOUR_FLAG_256)
		new = wp->palette[c & ~COLOUR_FLAG_256];
	if (new == 0)
		return (-1);
	return (new);
}

static void
window_pane_mode_timer(__unused int fd, __unused short events, void *arg)
{
	struct window_pane	*wp = arg;
	struct timeval		 tv = { .tv_sec = 10 };
	int			 n = 0;

	evtimer_del(&wp->modetimer);
	evtimer_add(&wp->modetimer, &tv);

	log_debug("%%%u in mode: last=%ld", wp->id, (long)wp->modelast);

	if (wp->modelast < time(NULL) - WINDOW_MODE_TIMEOUT) {
		if (ioctl(wp->fd, FIONREAD, &n) == -1 || n > 0)
			window_pane_reset_mode(wp);
	}
}

int
window_pane_set_mode(struct window_pane *wp, const struct window_mode *mode,
    struct cmd_find_state *fs, struct args *args)
{
	struct screen	*s;
	struct timeval	 tv = { .tv_sec = 10 };

	if (wp->mode != NULL)
		return (1);
	wp->mode = mode;

	wp->modelast = time(NULL);
	evtimer_set(&wp->modetimer, window_pane_mode_timer, wp);
	evtimer_add(&wp->modetimer, &tv);

	if ((s = wp->mode->init(wp, fs, args)) != NULL)
		wp->screen = s;
	wp->flags |= (PANE_REDRAW|PANE_CHANGED);

	server_status_window(wp->window);
	notify_pane("pane-mode-changed", wp);
	return (0);
}

void
window_pane_reset_mode(struct window_pane *wp)
{
	if (wp->mode == NULL)
		return;

	evtimer_del(&wp->modetimer);

	wp->mode->free(wp);
	wp->mode = NULL;
	wp->modeprefix = 1;

	wp->screen = &wp->base;
	wp->flags |= (PANE_REDRAW|PANE_CHANGED);

	server_status_window(wp->window);
	notify_pane("pane-mode-changed", wp);
}

void
window_pane_key(struct window_pane *wp, struct client *c, struct session *s,
    key_code key, struct mouse_event *m)
{
	struct window_pane	*wp2;

	if (KEYC_IS_MOUSE(key) && m == NULL)
		return;

	if (wp->mode != NULL) {
		wp->modelast = time(NULL);
		if (wp->mode->key != NULL)
			wp->mode->key(wp, c, s, (key & ~KEYC_XTERM), m);
		return;
	}

	if (wp->fd == -1 || wp->flags & PANE_INPUTOFF)
		return;

	input_key(wp, key, m);

	if (KEYC_IS_MOUSE(key))
		return;
	if (options_get_number(wp->window->options, "synchronize-panes")) {
		TAILQ_FOREACH(wp2, &wp->window->panes, entry) {
			if (wp2 == wp || wp2->mode != NULL)
				continue;
			if (wp2->fd == -1 || wp2->flags & PANE_INPUTOFF)
				continue;
			if (window_pane_visible(wp2))
				input_key(wp2, key, NULL);
		}
	}
}

int
window_pane_outside(struct window_pane *wp)
{
	struct window	*w = wp->window;

	if (wp->xoff >= w->sx || wp->yoff >= w->sy)
		return (1);
	if (wp->xoff + wp->sx > w->sx || wp->yoff + wp->sy > w->sy)
		return (1);
	return (0);
}

int
window_pane_visible(struct window_pane *wp)
{
	if (wp->layout_cell == NULL)
		return (0);
	return (!window_pane_outside(wp));
}

u_int
window_pane_search(struct window_pane *wp, const char *searchstr)
{
	struct screen	*s = &wp->base;
	char		*newsearchstr, *line;
	u_int		 i;

	xasprintf(&newsearchstr, "*%s*", searchstr);

	for (i = 0; i < screen_size_y(s); i++) {
		line = grid_view_string_cells(s->grid, 0, i, screen_size_x(s));
		if (fnmatch(newsearchstr, line, 0) == 0) {
			free(line);
			break;
		}
		free(line);
	}

	free(newsearchstr);
	if (i == screen_size_y(s))
		return (0);
	return (i + 1);
}

/* Get MRU pane from a list. */
static struct window_pane *
window_pane_choose_best(struct window_pane **list, u_int size)
{
	struct window_pane	*next, *best;
	u_int			 i;

	if (size == 0)
		return (NULL);

	best = list[0];
	for (i = 1; i < size; i++) {
		next = list[i];
		if (next->active_point > best->active_point)
			best = next;
	}
	return (best);
}

/*
 * Find the pane directly above another. We build a list of those adjacent to
 * top edge and then choose the best.
 */
struct window_pane *
window_pane_find_up(struct window_pane *wp)
{
	struct window_pane	*next, *best, **list;
	u_int			 edge, left, right, end, size;
	int			 status, found;

	if (wp == NULL || !window_pane_visible(wp))
		return (NULL);
	status = options_get_number(wp->window->options, "pane-border-status");

	list = NULL;
	size = 0;

	edge = wp->yoff;
	if (edge == (status == 1 ? 1 : 0))
		edge = wp->window->sy + 1 - (status == 2 ? 1 : 0);

	left = wp->xoff;
	right = wp->xoff + wp->sx;

	TAILQ_FOREACH(next, &wp->window->panes, entry) {
		if (next == wp || !window_pane_visible(next))
			continue;
		if (next->yoff + next->sy + 1 != edge)
			continue;
		end = next->xoff + next->sx - 1;

		found = 0;
		if (next->xoff < left && end > right)
			found = 1;
		else if (next->xoff >= left && next->xoff <= right)
			found = 1;
		else if (end >= left && end <= right)
			found = 1;
		if (!found)
			continue;
		list = xreallocarray(list, size + 1, sizeof *list);
		list[size++] = next;
	}

	best = window_pane_choose_best(list, size);
	free(list);
	return (best);
}

/* Find the pane directly below another. */
struct window_pane *
window_pane_find_down(struct window_pane *wp)
{
	struct window_pane	*next, *best, **list;
	u_int			 edge, left, right, end, size;
	int			 status, found;

	if (wp == NULL || !window_pane_visible(wp))
		return (NULL);
	status = options_get_number(wp->window->options, "pane-border-status");

	list = NULL;
	size = 0;

	edge = wp->yoff + wp->sy + 1;
	if (edge >= wp->window->sy - (status == 2 ? 1 : 0))
		edge = (status == 1 ? 1 : 0);

	left = wp->xoff;
	right = wp->xoff + wp->sx;

	TAILQ_FOREACH(next, &wp->window->panes, entry) {
		if (next == wp || !window_pane_visible(next))
			continue;
		if (next->yoff != edge)
			continue;
		end = next->xoff + next->sx - 1;

		found = 0;
		if (next->xoff < left && end > right)
			found = 1;
		else if (next->xoff >= left && next->xoff <= right)
			found = 1;
		else if (end >= left && end <= right)
			found = 1;
		if (!found)
			continue;
		list = xreallocarray(list, size + 1, sizeof *list);
		list[size++] = next;
	}

	best = window_pane_choose_best(list, size);
	free(list);
	return (best);
}

/* Find the pane directly to the left of another. */
struct window_pane *
window_pane_find_left(struct window_pane *wp)
{
	struct window_pane	*next, *best, **list;
	u_int			 edge, top, bottom, end, size;
	int			 found;

	if (wp == NULL || !window_pane_visible(wp))
		return (NULL);

	list = NULL;
	size = 0;

	edge = wp->xoff;
	if (edge == 0)
		edge = wp->window->sx + 1;

	top = wp->yoff;
	bottom = wp->yoff + wp->sy;

	TAILQ_FOREACH(next, &wp->window->panes, entry) {
		if (next == wp || !window_pane_visible(next))
			continue;
		if (next->xoff + next->sx + 1 != edge)
			continue;
		end = next->yoff + next->sy - 1;

		found = 0;
		if (next->yoff < top && end > bottom)
			found = 1;
		else if (next->yoff >= top && next->yoff <= bottom)
			found = 1;
		else if (end >= top && end <= bottom)
			found = 1;
		if (!found)
			continue;
		list = xreallocarray(list, size + 1, sizeof *list);
		list[size++] = next;
	}

	best = window_pane_choose_best(list, size);
	free(list);
	return (best);
}

/* Find the pane directly to the right of another. */
struct window_pane *
window_pane_find_right(struct window_pane *wp)
{
	struct window_pane	*next, *best, **list;
	u_int			 edge, top, bottom, end, size;
	int			 found;

	if (wp == NULL || !window_pane_visible(wp))
		return (NULL);

	list = NULL;
	size = 0;

	edge = wp->xoff + wp->sx + 1;
	if (edge >= wp->window->sx)
		edge = 0;

	top = wp->yoff;
	bottom = wp->yoff + wp->sy;

	TAILQ_FOREACH(next, &wp->window->panes, entry) {
		if (next == wp || !window_pane_visible(next))
			continue;
		if (next->xoff != edge)
			continue;
		end = next->yoff + next->sy - 1;

		found = 0;
		if (next->yoff < top && end > bottom)
			found = 1;
		else if (next->yoff >= top && next->yoff <= bottom)
			found = 1;
		else if (end >= top && end <= bottom)
			found = 1;
		if (!found)
			continue;
		list = xreallocarray(list, size + 1, sizeof *list);
		list[size++] = next;
	}

	best = window_pane_choose_best(list, size);
	free(list);
	return (best);
}

/* Clear alert flags for a winlink */
void
winlink_clear_flags(struct winlink *wl)
{
	struct winlink	*loop;

	wl->window->flags &= ~WINDOW_ALERTFLAGS;
	TAILQ_FOREACH(loop, &wl->window->winlinks, wentry) {
		if ((loop->flags & WINLINK_ALERTFLAGS) != 0) {
			loop->flags &= ~WINLINK_ALERTFLAGS;
			server_status_session(loop->session);
		}
	}
}

/* Shuffle window indexes up. */
int
winlink_shuffle_up(struct session *s, struct winlink *wl)
{
	int	 idx, last;

	idx = wl->idx + 1;

	/* Find the next free index. */
	for (last = idx; last < INT_MAX; last++) {
		if (winlink_find_by_index(&s->windows, last) == NULL)
			break;
	}
	if (last == INT_MAX)
		return (-1);

	/* Move everything from last - 1 to idx up a bit. */
	for (; last > idx; last--) {
		wl = winlink_find_by_index(&s->windows, last - 1);
		server_link_window(s, wl, s, last, 0, 0, NULL);
		server_unlink_window(s, wl);
	}

	return (idx);
}
@


1.202
log
@Move signal code into proc.c.
@
text
@d1 1
a1 1
/* $OpenBSD: window.c,v 1.201 2017/07/03 12:38:50 nicm Exp $ */
d25 1
d890 1
d920 3
a922 2
	wp->pid = fdforkpty(ptm_fd, &wp->fd, wp->tty, NULL, &ws);
	switch (wp->pid) {
d925 1
d928 2
d932 3
d948 1
a955 3
		proc_clear_signals(server_proc);
		log_close();

d988 1
@


1.201
log
@Change previous to not wait for both process exit and pty close -
instead if there is a pipe-pane active, do not exit until all data is
read (including any libevent hasn't seen yet). Fixes problem reported by
Theo Buehler and still seems to solve the original issue.
@
text
@d1 1
a1 1
/* $OpenBSD: window.c,v 1.200 2017/07/03 08:16:03 nicm Exp $ */
d946 1
a946 1
		clear_signals(1);
@


1.200
log
@Do not close panes until process has exited and any outstanding data
has been written to the pipe-pane event if there is one. GitHub issue 991.
@
text
@d1 1
a1 1
/* $OpenBSD: window.c,v 1.199 2017/06/28 11:36:40 nicm Exp $ */
d394 8
a401 2
	if (wp->pipe_fd != -1 && EVBUFFER_LENGTH(wp->pipe_event->output) != 0)
		return (0);
a404 2
	if (~wp->flags & PANE_ERROR)
		return (0);
d1021 1
a1021 1
	wp->flags |= PANE_ERROR;
@


1.199
log
@Apply the xterm key flag when needed for send-keys, fixes problem
reported by Franky Spamschleuder.
@
text
@d1 1
a1 1
/* $OpenBSD: window.c,v 1.198 2017/06/04 09:02:36 nicm Exp $ */
d391 13
d1016 5
a1020 1
	server_destroy_pane(wp, 1);
@


1.198
log
@Be more strict about escape sequences that rename windows or set titles:
ignore any that not valid UTF-8 outright, and for good measure pass the
result through our UTF-8-aware vis(3).
@
text
@d1 1
a1 1
/* $OpenBSD: window.c,v 1.197 2017/05/31 10:15:51 nicm Exp $ */
d1229 1
a1229 1
			wp->mode->key(wp, c, s, key, m);
@


1.197
log
@Because we defer actually resizing applications (calling TIOCSWINSZ)
until the end of the server loop, tmux may have gone through several
internal resizes in between. This can be a problem if the final size is
the same as the initial size (what the application things it currently
is), because the application may choose not to redraw, assuming the
screen state is unchanged, when in fact tmux has thrown away parts of
the screen, assuming the application will redraw them.

To avoid this, do an extra resize if the new size is the same size as
the initial size. This should force the application to redraw when tmux
needs it to, while retaining the benefits of deferring (so we now resize
at most two times instead of at most one - and only two very rarely).

Fixes a problem with break-pane and zoomed panes reported by Michal
Mazurek.
@
text
@d1 1
a1 1
/* $OpenBSD: window.c,v 1.196 2017/05/30 21:44:59 nicm Exp $ */
d32 1
d412 1
a412 1
	w->name = xstrdup(new_name);
@


1.196
log
@Rewrite of choose mode, both to simplify and tidy the code and to add
some modern features.

Now the common code is in mode-tree.c, which provides an API used by the
three modes now separated into window-{buffer,client,tree}.c. Buffer
mode shows buffers, client mode clients and tree mode a tree of
sessions, windows and panes.

Each mode has a common set of key bindings plus a few that are specific
to the mode. Other changes are:

- each mode has a preview pane: for buffers this is the buffer content
  (very useful), for others it is a preview of the pane;

- items may be sorted in different ways ('O' key);

- multiple items may be tagged and an operation applied to all of them
  (for example, to delete multiple buffers at once);

- in tree mode a command may be run on the selected item (session,
  window, pane) or on tagged items (key ':');

- displayed items may be filtered in tree mode by using a format (this
  is used to implement find-window) (key 'f');

- the custom format (-F) for the display is no longer available;

- shortcut keys change from 0-9, a-z, A-Z which was always a bit weird
  with keys used for other uses to 0-9, M-a to M-z.

Now that the code is simpler, other improvements will come later.

Primary key bindings for each mode are documented under the commands in
the man page (choose-buffer, choose-client, choose-tree).

Parts written by Thomas Adam.
@
text
@d1 1
a1 1
/* $OpenBSD: window.c,v 1.195 2017/05/29 18:06:34 nicm Exp $ */
d803 2
a804 2
	wp->sx = sx;
	wp->sy = sy;
@


1.195
log
@Add ||, && format operators and C: to search pane content.
@
text
@d1 1
a1 1
/* $OpenBSD: window.c,v 1.194 2017/05/12 10:45:38 nicm Exp $ */
d1174 2
a1175 1
window_pane_set_mode(struct window_pane *wp, const struct window_mode *mode)
d1188 1
a1188 1
	if ((s = wp->mode->init(wp)) != NULL)
a1292 26
}

char *
window_pane_search_old(struct window_pane *wp, const char *searchstr,
    u_int *lineno)
{
	struct screen	*s = &wp->base;
	char		*newsearchstr, *line, *msg;
	u_int		 i;

	msg = NULL;
	xasprintf(&newsearchstr, "*%s*", searchstr);

	for (i = 0; i < screen_size_y(s); i++) {
		line = grid_view_string_cells(s->grid, 0, i, screen_size_x(s));
		if (fnmatch(newsearchstr, line, 0) == 0) {
			msg = line;
			if (lineno != NULL)
				*lineno = i;
			break;
		}
		free(line);
	}

	free(newsearchstr);
	return (msg);
@


1.194
log
@Store copy mode search string in pane so search-again command works even
if you exit and reenter copy mode (it doesn't remember the position,
just the search string), suggested by espie@@.
@
text
@d1 1
a1 1
/* $OpenBSD: window.c,v 1.193 2017/05/04 07:16:43 nicm Exp $ */
d1270 24
d1295 1
a1295 1
window_pane_search(struct window_pane *wp, const char *searchstr,
@


1.193
log
@Some new notifications, mainly for active pane and current window and
session:

    pane-mode-changed
    window-pane-changed
    client-session-changed
    session-window-changed

From Joshua Brot.
@
text
@d1 1
a1 1
/* $OpenBSD: window.c,v 1.192 2017/04/28 19:13:55 nicm Exp $ */
d831 1
@


1.192
log
@Log what is happening with window and session reference counts much more
obviously.
@
text
@d1 1
a1 1
/* $OpenBSD: window.c,v 1.191 2017/04/28 19:12:15 nicm Exp $ */
d358 2
d446 2
a447 1
		if (w->active == wp)
d449 1
d453 1
d629 1
a629 1
		if (w->active != NULL)
d631 2
d1191 1
d1211 1
@


1.191
log
@Remove a reference from the right window when removing from a winlink's
list.
@
text
@d1 1
a1 1
/* $OpenBSD: window.c,v 1.190 2017/04/20 17:49:26 nicm Exp $ */
d189 1
a189 1
		window_remove_ref(wl->window);
d193 1
a193 1
	w->references++;
d203 1
a203 1
		window_remove_ref(w);
d364 1
a364 2
	if (!TAILQ_EMPTY(&w->winlinks))
		fatalx("window destroyed with winlinks");
d389 8
a396 1
window_remove_ref(struct window *w)
a397 2
	if (w->references == 0)
		fatal("bad reference count");
d399 2
@


1.190
log
@Use fdforkpty() instead of our own unwrapped versions.
@
text
@d1 1
a1 1
/* $OpenBSD: window.c,v 1.189 2017/04/20 09:43:45 nicm Exp $ */
d189 1
a189 1
		window_remove_ref(w);
@


1.189
log
@Now that struct winlink has a session pointer, can remove some arguments.
@
text
@d1 1
a1 1
/* $OpenBSD: window.c,v 1.188 2017/04/20 09:39:07 nicm Exp $ */
d886 1
a886 1
	wp->pid = pty_fork(ptm_fd, &wp->fd, wp->tty, sizeof wp->tty, &ws);
@


1.188
log
@There is no real need for window_printable_flags to allocate, make it
return a buffer from the stack.
@
text
@d1 1
a1 1
/* $OpenBSD: window.c,v 1.187 2017/03/21 09:49:10 nicm Exp $ */
a711 1
/* Retuns the printable flags on a window, empty string if no flags set. */
d713 1
a713 1
window_printable_flags(struct session *s, struct winlink *wl)
d715 3
a717 2
	static char	flags[32];
	int		pos;
@


1.187
log
@Fix pane movement by direction (up, down, left, right) when
pane-border-status is set, from KOIE Hidetaka.
@
text
@d1 1
a1 1
/* $OpenBSD: window.c,v 1.186 2017/03/13 17:20:11 nicm Exp $ */
d713 1
a713 1
char *
d716 2
a717 2
	char	flags[32];
	int	pos;
d735 1
a735 1
	return (xstrdup(flags));
@


1.186
log
@Log where panes are created.
@
text
@d1 1
a1 1
/* $OpenBSD: window.c,v 1.185 2017/02/27 13:07:57 nicm Exp $ */
d1260 1
a1260 1
	u_int	 	 i;
d1308 1
a1308 1
	int			 found;
d1312 1
d1318 2
a1319 2
	if (edge == 0)
		edge = wp->window->sy + 1;
d1355 1
a1355 1
	int			 found;
d1359 1
d1365 2
a1366 2
	if (edge >= wp->window->sy)
		edge = 0;
@


1.185
log
@If splitw -b is used, insert the new pane before the current one in the
pane list. This means the numbering is in order (for example for
display-panes) and fixes a problem with redrawing the active pane
borders.
@
text
@d1 1
a1 1
/* $OpenBSD: window.c,v 1.184 2017/02/22 09:01:32 nicm Exp $ */
d591 2
a592 1
	if (TAILQ_EMPTY(&w->panes))
d594 2
a595 1
	else if (before)
d597 2
a598 1
	else
d600 1
@


1.184
log
@Minor bits: fix an array size, add comment, make grid_cell_entry static.
@
text
@d1 1
a1 1
/* $OpenBSD: window.c,v 1.183 2017/02/08 08:25:12 nicm Exp $ */
d342 1
a342 1
	wp = window_add_pane(w, NULL, hlimit);
d429 1
d582 2
a583 1
window_add_pane(struct window *w, struct window_pane *after, u_int hlimit)
d587 3
d593 4
a596 6
	else {
		if (after == NULL)
			TAILQ_INSERT_AFTER(&w->panes, w->active, wp, entry);
		else
			TAILQ_INSERT_AFTER(&w->panes, after, wp, entry);
	}
@


1.183
log
@Remove event watermarks, don't work well enough to be worth it.
@
text
@d1 1
a1 1
/* $OpenBSD: window.c,v 1.182 2017/01/24 13:28:33 nicm Exp $ */
d1494 1
@


1.182
log
@Shorten a long line, and don't leak buffer in paste_add if size is zero.
@
text
@d1 1
a1 1
/* $OpenBSD: window.c,v 1.181 2017/01/23 10:09:43 nicm Exp $ */
a68 2
static void	window_pane_set_watermark(struct window_pane *, size_t);

a839 8
static void
window_pane_set_watermark(struct window_pane *wp, size_t size)
{
	wp->wmark_hits = 0;
	wp->wmark_size = size;
	bufferevent_setwatermark(wp->event, EV_READ, 0, size);
}

d947 1
a947 1
	window_pane_set_watermark(wp, READ_FAST_SIZE);
a962 14
	if (wp->wmark_size == READ_FAST_SIZE) {
		if (size > READ_FULL_SIZE)
			wp->wmark_hits++;
		if (wp->wmark_hits == READ_CHANGE_HITS)
			window_pane_set_watermark(wp, READ_SLOW_SIZE);
	} else if (wp->wmark_size == READ_SLOW_SIZE) {
		if (size < READ_EMPTY_SIZE)
			wp->wmark_hits++;
		if (wp->wmark_hits == READ_CHANGE_HITS)
			window_pane_set_watermark(wp, READ_FAST_SIZE);
	}
	log_debug("%%%u has %zu bytes (of %u, %u hits)", wp->id, size,
	    wp->wmark_size, wp->wmark_hits);

d969 1
@


1.181
log
@Open /dev/ptm before pledge() and save it to be used for PTMGET later
(this means inlining forkpty()).

ok deraadt
@
text
@d1 1
a1 1
/* $OpenBSD: window.c,v 1.180 2017/01/12 10:15:55 nicm Exp $ */
d889 2
a890 1
	switch (wp->pid = pty_fork(ptm_fd, &wp->fd, wp->tty, sizeof wp->tty, &ws)) {
@


1.180
log
@Put all palette functions together in the file.
@
text
@d1 1
a1 1
/* $OpenBSD: window.c,v 1.179 2017/01/12 00:24:28 nicm Exp $ */
d889 1
a889 1
	switch (wp->pid = forkpty(&wp->fd, wp->tty, NULL, &ws)) {
@


1.179
log
@Erm the aixterm colours should start at 8, not 7.
@
text
@d1 1
a1 1
/* $OpenBSD: window.c,v 1.178 2017/01/12 00:19:32 nicm Exp $ */
d1136 20
a1538 20
}

int
window_pane_get_palette(const struct window_pane *wp, int c)
{
	int	new;

	if (wp == NULL || wp->palette == NULL)
		return (-1);

	new = -1;
	if (c < 8)
		new = wp->palette[c];
	else if (c >= 90 && c <= 97)
		new = wp->palette[8 + c - 90];
	else if (c & COLOUR_FLAG_256)
		new = wp->palette[c & ~COLOUR_FLAG_256];
	if (new == 0)
		return (-1);
	return (new);
@


1.178
log
@Fix setting the palette of aixterm colours (90-97).
@
text
@d1 1
a1 1
/* $OpenBSD: window.c,v 1.177 2017/01/07 15:28:13 nicm Exp $ */
d1533 1
a1533 1
		new = wp->palette[7 + c - 90];
@


1.177
log
@Add support for the OSC 4 and OSC 104 palette setting escape sequences,
from S Gilles.
@
text
@d1 1
a1 1
/* $OpenBSD: window.c,v 1.176 2016/11/16 09:22:16 nicm Exp $ */
d467 2
a468 2
	if (WINDOW_PANE_PALETTE_HAS(w->active, w->active->colgc.fg) ||
	    WINDOW_PANE_PALETTE_HAS(w->active, w->active->colgc.bg) ||
d471 2
a472 2
	if (WINDOW_PANE_PALETTE_HAS(wp, wp->colgc.fg) ||
	    WINDOW_PANE_PALETTE_HAS(wp, wp->colgc.bg) ||
d1519 20
@


1.176
log
@Initialize modeprefix to 1 properly in window_pane_create, from Artem Fokin.
@
text
@d1 1
a1 1
/* $OpenBSD: window.c,v 1.175 2016/11/16 00:24:03 nicm Exp $ */
d450 1
a450 1
	const struct grid_cell	*agc, *wgc;
d457 1
a457 3
	 * to redraw panes when switching active panes. Otherwise, if the
	 * active or inactive pane do not have a custom style, they will need
	 * to be redrawn.
d459 2
a460 3
	agc = options_get_style(w->options, "window-active-style");
	wgc = options_get_style(w->options, "window-style");
	if (style_equal(agc, wgc))
d462 8
a469 1
	if (style_equal(&grid_default_cell, &w->active->colgc))
d471 3
a473 1
	if (style_equal(&grid_default_cell, &wp->colgc))
d838 1
d1099 34
@


1.175
log
@The target validity check used window_pane_visible but that may be false
if the pane is zoomed, so instead add a new function to just check if
the pane is actually on screen (most commands still want to accept panes
invisible by zoom). Also reject panes outside the window for various
special targets. Problem reported by Sean Haugh.
@
text
@d1 1
a1 1
/* $OpenBSD: window.c,v 1.174 2016/10/19 09:22:07 nicm Exp $ */
d772 1
@


1.174
log
@Alerts are too slow, so rather than walking all sessions and windows,
add a link of winlinks to each window and a pointer to the session to
each winlink. Also rewrite the alerts processing to return to the old
behaviour (alert in any window sets the flag on any winlink).
@
text
@d1 1
a1 1
/* $OpenBSD: window.c,v 1.173 2016/10/18 07:38:16 nicm Exp $ */
d1188 1
a1188 1
window_pane_visible(struct window_pane *wp)
a1191 2
	if (wp->layout_cell == NULL)
		return (0);
d1193 1
a1193 1
		return (0);
d1195 8
d1204 1
a1204 1
	return (1);
@


1.173
log
@Store the right size in the pipe offset for pipe-pane.
@
text
@d1 1
a1 1
/* $OpenBSD: window.c,v 1.172 2016/10/16 22:06:40 nicm Exp $ */
d63 2
d189 5
d203 5
a210 3

	if (w != NULL)
		window_remove_ref(w);
d325 1
d363 1
a363 1
void
d366 3
d1437 1
a1437 9
	struct session	*s;
	struct winlink	*wl_loop;

	RB_FOREACH(s, sessions, &sessions) {
		RB_FOREACH(wl_loop, winlinks, &s->windows) {
			if (wl_loop->window != wl->window)
				continue;
			if ((wl_loop->flags & WINLINK_ALERTFLAGS) == 0)
				continue;
d1439 5
a1443 3
			wl_loop->flags &= ~WINLINK_ALERTFLAGS;
			wl_loop->window->flags &= ~WINDOW_ALERTFLAGS;
			server_status_session(s);
@


1.172
log
@Use the notify name string instead of going via an enum and change
existing hooks to use notifys instead.
@
text
@d1 1
a1 1
/* $OpenBSD: window.c,v 1.171 2016/10/15 09:27:52 nicm Exp $ */
d973 1
a973 1
	wp->pipe_off = size;
@


1.171
log
@Give window_create and window_create1 better names.
@
text
@d1 1
a1 1
/* $OpenBSD: window.c,v 1.170 2016/10/13 20:27:27 nicm Exp $ */
d393 1
a393 1
	notify_window_renamed(w);
d535 1
a535 1
	notify_window_layout_changed(w);
d558 1
a558 1
	notify_window_layout_changed(w);
@


1.170
log
@Add support for BCE (background colour erase). This makes various escape
sequences (notable EL and ED but also IL, DL, ICH, DCH) create blank
cells using the current background colour rather than the default
colour.

On modern systems BCE doesn't really have many benefits, but most other
terminals now support it, some (lazy) applications rely on it, and it is
not hard to include now that we have pane background colours anyway.

Mostly written by Sean Haugh.
@
text
@d1 1
a1 1
/* $OpenBSD: window.c,v 1.169 2016/10/11 13:21:59 nicm Exp $ */
d296 1
a296 1
window_create1(u_int sx, u_int sy)
d326 1
a326 1
window_create(const char *name, int argc, char **argv, const char *path,
d333 1
a333 1
	w = window_create1(sx, sy);
d337 2
a338 2
	if (window_pane_spawn(wp, argc, argv, path, shell, cwd, env, tio,
	    cause) != 0) {
@


1.169
log
@Add static in window-*.c and move some internal functions out of tmux.h.
@
text
@d1 1
a1 1
/* $OpenBSD: window.c,v 1.168 2016/10/11 07:23:34 nicm Exp $ */
d1026 1
a1026 1
	grid_view_clear(s->grid, 0, 0, sx, sy);
@


1.168
log
@Fundamental change to how copy mode key bindings work:

The vi-copy and emacs-copy mode key tables are gone, and instead copy
mode commands are bound in one of two normal key tables ("copy-mode" or
"copy-mode-vi"). Keys are bound to "send-keys -X copy-mode-command". So:

    bind -temacs-copy C-Up scroll-up
    bind -temacs-copy -R5 WheelUpPane scroll-up

Becomes:

    bind -Tcopy-mode C-Up send -X scroll-up
    bind -Tcopy-mode WheelUpPane send -N5 -X scroll-up

This allows the full command parser and command set to be used - for
example, we can use the normal command prompt for searching, jumping,
and so on instead of a custom one:

    bind -Tcopy-mode C-r command-prompt -p'search up' "send -X search-backward '%%'"

command-prompt also gets a -1 option to only require on key press, which
is needed for jumping.

The plan is to get rid of mode keys entirely, so more to come eventually.
@
text
@d1 1
a1 1
/* $OpenBSD: window.c,v 1.167 2016/09/28 08:30:44 nicm Exp $ */
d63 4
d72 2
d78 2
a86 2
RB_GENERATE(winlinks, winlink, entry, winlink_cmp);

a92 2
RB_GENERATE(window_pane_tree, window_pane, tree_entry, window_pane_cmp);

d136 1
a136 1
int
d738 1
a738 1
struct window_pane *
d789 1
a789 1
void
@


1.167
log
@Rate limit TIOCSWINSZ on a timer to avoid programs getting hammered with
SIGWINCH when the size changes rapidly. To help a problem reported by
Rui Pinheiro.
@
text
@d1 1
a1 1
/* $OpenBSD: window.c,v 1.166 2016/09/16 13:43:41 nicm Exp $ */
d1127 1
@


1.166
log
@Swap watermarks from high (4096) to low (128) when we get full buffers
into the read callback several times in succession; swap back when we
see empty buffers several times. This hopefully limits how much programs
that print a lot for a long period can monopolize tmux (like large, fast
compiling), without penalizing programs that print a lot briefly (like
most curses applications). Helps a lot for me, the actual numbers may
need tweaking later.
@
text
@d1 1
a1 1
/* $OpenBSD: window.c,v 1.165 2016/07/15 09:52:34 nicm Exp $ */
d805 3
@


1.165
log
@Tweak output of environment logging.
@
text
@d1 1
a1 1
/* $OpenBSD: window.c,v 1.164 2016/07/15 09:28:32 nicm Exp $ */
d59 3
a61 7
u_int	next_window_pane_id;
u_int	next_window_id;
u_int	next_active_point;

void	window_pane_timer_callback(int, short, void *);
void	window_pane_read_callback(struct bufferevent *, void *);
void	window_pane_error_callback(struct bufferevent *, short, void *);
d63 7
a69 1
struct window_pane *window_pane_choose_best(struct window_pane **, u_int);
d814 8
d928 1
a928 1
	bufferevent_setwatermark(wp->event, EV_READ, 0, READ_SIZE);
d935 1
a935 1
void
d940 1
d944 13
a956 2
	log_debug("%%%u has %zu bytes (of %zu)", wp->id, EVBUFFER_LENGTH(evb),
	    (size_t)READ_SIZE);
d958 1
a958 1
	new_size = EVBUFFER_LENGTH(evb) - wp->pipe_off;
d966 1
a966 1
	wp->pipe_off = EVBUFFER_LENGTH(evb);
d969 1
a969 1
void
d1207 1
a1207 1
struct window_pane *
@


1.164
log
@Log environment to new panes.
@
text
@d1 1
a1 1
/* $OpenBSD: window.c,v 1.163 2016/06/16 10:55:47 nicm Exp $ */
d845 1
a845 1
	environ_log(env);
@


1.163
log
@Allow a command to be specified to display-panes, similar to
command-prompt, rather than always just selecting the pane.
@
text
@d1 1
a1 1
/* $OpenBSD: window.c,v 1.162 2016/06/15 09:13:46 nicm Exp $ */
d845 1
@


1.162
log
@Copy mode needs to keep the original grid intact so it can copy from it
if needed, so it disables reading from the pane. This can be problem
with some programs. So make tmux automatically exit all modes after 180
seconds of inactivity and if there is pending output.
@
text
@d1 1
a1 1
/* $OpenBSD: window.c,v 1.161 2016/06/06 07:24:31 nicm Exp $ */
d29 1
@


1.161
log
@Insert new panes after the pane being split in the list rather than
always after the active pane. This is more sensible when doing it with
commands rather than keys.
@
text
@d1 1
a1 1
/* $OpenBSD: window.c,v 1.160 2016/05/30 09:50:21 nicm Exp $ */
d20 1
d1050 18
d1072 1
d1078 4
d1096 2
d1117 1
@


1.160
log
@Cache the window styles and do not look up the window-style options
unless they have changed.
@
text
@d1 1
a1 1
/* $OpenBSD: window.c,v 1.159 2016/04/29 15:00:48 nicm Exp $ */
d326 1
a326 1
	wp = window_add_pane(w, hlimit);
d556 1
a556 1
window_add_pane(struct window *w, u_int hlimit)
d563 6
a568 2
	else
		TAILQ_INSERT_AFTER(&w->panes, w->active, wp, entry);
@


1.159
log
@Add option to include status text in the pane borders. If
pane-border-status is set to "top" or "bottom" (rather than "off"),
every pane has a permanent top or bottom border containing the text from
pane-border-format.

Based on a diff sent long ago by Jonathan Slenders, mostly rewritten and
simplified by me.
@
text
@d1 1
a1 1
/* $OpenBSD: window.c,v 1.158 2016/04/29 13:36:11 nicm Exp $ */
d294 1
a294 1
	w->flags = 0;
@


1.158
log
@The backoff timer is causing no end of trouble with disconnected clients
stopping data in attached ones. So get rid of it and see how we get on
with just a high watermark on each pane.
@
text
@d1 1
a1 1
/* $OpenBSD: window.c,v 1.157 2016/03/01 12:05:15 nicm Exp $ */
d766 2
@


1.157
log
@Redraw status on mode entry and exit.
@
text
@d1 1
a1 1
/* $OpenBSD: window.c,v 1.156 2016/01/19 15:59:12 nicm Exp $ */
a779 3
	if (event_initialized(&wp->timer))
		evtimer_del(&wp->timer);

a916 6
window_pane_timer_callback(__unused int fd, __unused short events, void *data)
{
	window_pane_read_callback(NULL, data);
}

void
d922 1
a922 6
	size_t			 new_size, available;
	struct client		*c;
	struct timeval		 tv;

	if (event_initialized(&wp->timer))
		evtimer_del(&wp->timer);
d924 2
a925 10
	log_debug("%%%u has %zu bytes", wp->id, EVBUFFER_LENGTH(evb));

	TAILQ_FOREACH(c, &clients, entry) {
		if (!tty_client_ready(c, wp))
			continue;

		available = EVBUFFER_LENGTH(c->tty.event->output);
		if (available > READ_BACKOFF)
			goto start_timer;
	}
a935 11
	return;

start_timer:
	log_debug("%%%u backing off (%s %zu > %d)", wp->id, c->ttyname,
	    available, READ_BACKOFF);

	tv.tv_sec = 0;
	tv.tv_usec = READ_TIME;

	evtimer_set(&wp->timer, window_pane_timer_callback, wp);
	evtimer_add(&wp->timer, &tv);
@


1.156
log
@I no longer use my SourceForge address so replace it.
@
text
@d1 1
a1 1
/* $OpenBSD: window.c,v 1.155 2015/12/31 18:14:13 nicm Exp $ */
d1088 2
d1104 2
@


1.155
log
@Use saved pipe buffer offset when writing to pipe, from Nicolas Viennot.
@
text
@d1 1
a1 1
/* $OpenBSD: window.c,v 1.154 2015/12/19 08:43:04 nicm Exp $ */
d4 1
a4 1
 * Copyright (c) 2007 Nicholas Marriott <nicm@@users.sourceforge.net>
@


1.154
log
@Make input off flag (selectp -d) apply to synchronize-panes too.
@
text
@d1 1
a1 1
/* $OpenBSD: window.c,v 1.153 2015/12/16 21:50:38 nicm Exp $ */
d951 1
a951 1
		new_data = EVBUFFER_DATA(evb);
@


1.153
log
@Add infrastructure to work out the best target given a pane or window
alone and use it to add pane_died and pane_exited hooks.
@
text
@d1 1
a1 1
/* $OpenBSD: window.c,v 1.152 2015/12/15 00:00:01 nicm Exp $ */
d1130 3
a1132 1
			if (wp2->fd != -1 && window_pane_visible(wp2))
@


1.152
log
@Make the marked pane a cmd_find_state.
@
text
@d1 1
a1 1
/* $OpenBSD: window.c,v 1.151 2015/12/02 23:09:22 nicm Exp $ */
d977 1
a977 1
	server_destroy_pane(wp);
@


1.151
log
@Mark new active pane changed after pane lost in window, and after
break-pane. Reported by tim@@.
@
text
@d1 1
a1 1
/* $OpenBSD: window.c,v 1.150 2015/11/24 23:46:16 nicm Exp $ */
d571 1
a571 1
	if (wp == marked_window_pane)
d694 1
a694 1
	if (server_check_marked() && wl == marked_winlink)
@


1.150
log
@Make environ_set va_args and use it to tidy up some calls. Also add a
missing word in manpage (from jmc).
@
text
@d1 1
a1 1
/* $OpenBSD: window.c,v 1.149 2015/11/18 14:27:44 nicm Exp $ */
d582 2
@


1.149
log
@Use __unused rather than rolling our own.
@
text
@d1 1
a1 1
/* $OpenBSD: window.c,v 1.148 2015/11/12 11:05:34 nicm Exp $ */
d811 1
a811 1
	char		*argv0, *cmd, **argvp, paneid[16];
d866 2
a867 3
			environ_set(env, "PATH", path);
		xsnprintf(paneid, sizeof paneid, "%%%u", wp->id);
		environ_set(env, "TMUX_PANE", paneid);
@


1.148
log
@Support UTF-8 key bindings by expanding the key type from int to
uint64_t and converting UTF-8 to Unicode on input and the reverse on
output. (This allows key bindings, there are still omissions - the
largest being that the various prompts do not accept UTF-8.)
@
text
@d1 1
a1 1
/* $OpenBSD: window.c,v 1.147 2015/10/31 08:13:58 nicm Exp $ */
d919 1
a919 1
window_pane_timer_callback(unused int fd, unused short events, void *data)
d925 1
a925 1
window_pane_read_callback(unused struct bufferevent *bufev, void *data)
d971 2
a972 2
window_pane_error_callback(unused struct bufferevent *bufev, unused short what,
    void *data)
@


1.147
log
@Because pledge(2) does not allow us to pass directory file descriptors
around, we can't use file descriptors for the working directory because
we will be unable to pass it to a privileged process to tell it where to
read or write files or spawn children. So move tmux back to using
strings for the current working directory. We try to check it exists
with access() when it is set but ultimately fall back to ~ if it fails
at time of use (or / if that fails too).
@
text
@d1 1
a1 1
/* $OpenBSD: window.c,v 1.146 2015/10/27 15:58:43 nicm Exp $ */
d1105 1
a1105 1
    int key, struct mouse_event *m)
@


1.146
log
@Move struct options into options.c.
@
text
@d1 1
a1 1
/* $OpenBSD: window.c,v 1.145 2015/09/14 11:34:50 nicm Exp $ */
d319 2
a320 2
    const char *shell, int cwd, struct environ *env, struct termios *tio,
    u_int sx, u_int sy, u_int hlimit, char **cause)
d739 1
a739 1
	wp->cwd = -1;
d799 1
a799 1
	close(wp->cwd);
d807 1
a807 1
    const char *path, const char *shell, int cwd, struct environ *env,
d812 1
a812 1
	const char	*ptr, *first;
d829 3
a831 3
	if (cwd != -1) {
		close(wp->cwd);
		wp->cwd = dup(cwd);
d850 4
a853 2
		if (fchdir(wp->cwd) != 0)
			chdir("/");
@


1.145
log
@When the active pane changes, redraw panes if the style has
changed. From Cam Hutchison.
@
text
@d1 1
a1 1
/* $OpenBSD: window.c,v 1.144 2015/08/29 23:55:55 nicm Exp $ */
d305 1
a305 1
	options_init(&w->options, &global_w_options);
d338 1
a338 1
		options_set_number(&w->options, "automatic-rename", 0);
d362 1
a362 1
	options_free(&w->options);
d440 2
a441 2
	agc = options_get_style(&w->options, "window-active-style");
	wgc = options_get_style(&w->options, "window-style");
d601 1
a601 1
	n = options_get_number(&w->options, "pane-base-index");
d639 1
a639 1
	*i = options_get_number(&w->options, "pane-base-index");
d1005 1
a1005 1
	if (!options_get_number(&wp->window->options, "alternate-screen"))
d1035 1
a1035 1
	if (!options_get_number(&wp->window->options, "alternate-screen"))
d1123 1
a1123 1
	if (options_get_number(&wp->window->options, "synchronize-panes")) {
@


1.144
log
@Remove some old prototypes and unused functions.
@
text
@d1 1
a1 1
/* $OpenBSD: window.c,v 1.143 2015/08/29 08:30:54 nicm Exp $ */
d424 24
@


1.143
log
@Move alerts onto events rather than checking every loop.
@
text
@d1 1
a1 1
/* $OpenBSD: window.c,v 1.142 2015/08/29 00:39:18 nicm Exp $ */
a440 10
}

void
window_set_active_at(struct window *w, u_int x, u_int y)
{
	struct window_pane	*wp;

	wp = window_get_active_at(w, x, y);
	if (wp != NULL && wp != w->active)
		window_set_active_pane(w, wp);
@


1.142
log
@Treat entering or leaving a mode as pane changed.
@
text
@d1 1
a1 1
/* $OpenBSD: window.c,v 1.141 2015/08/29 00:29:15 nicm Exp $ */
d280 7
a304 3
	if (gettimeofday(&w->activity_time, NULL) != 0)
		fatal("gettimeofday failed");

d312 2
d359 3
a940 8

	/*
	 * If we get here, we're not outputting anymore, so set the silence
	 * flag on the window.
	 */
	wp->window->flags |= WINDOW_SILENCE;
	if (gettimeofday(&wp->window->silence_timer, NULL) != 0)
		fatal("gettimeofday failed");
@


1.141
log
@Better take on reducing the name timer. Again check for name changes in
the main loop after events that may have changed the pane, but do so at
most once every 500 millis. If the pane changed too soon, use a timer to
ensure that a check happens later.
@
text
@d1 1
a1 1
/* $OpenBSD: window.c,v 1.138 2015/08/28 15:51:48 nicm Exp $ */
d1069 1
a1069 1
	wp->flags |= PANE_REDRAW;
d1083 1
a1083 1
	wp->flags |= PANE_REDRAW;
@


1.140
log
@Only set default title to hostname on screens that are being used for a
window pane, no point in calling gethostname() for temporary screens.
@
text
@d1 1
a1 1
/* $OpenBSD: window.c,v 1.139 2015/08/28 16:10:46 nicm Exp $ */
a301 2
	if (options_get_number(&w->options, "automatic-rename"))
		queue_window_name(w);
d350 2
a351 2
	if (event_initialized(&w->name_timer))
		evtimer_del(&w->name_timer);
@


1.139
log
@Revert previous; we do need a timer, until I have a better idea. We
can't do the name check every loop, because that is too expensive, and
we can't make sure it only happens infrequently because we have no idea
when the next change will happen.
@
text
@d1 1
a1 1
/* $OpenBSD: window.c,v 1.137 2015/08/28 07:55:43 nicm Exp $ */
d707 1
d743 3
@


1.138
log
@We now only checking for name changes when the active pane has changed,
but that can only happen when we have already been woken up by a read
event, so there is no need for a timer, we can just check the changed
flag on the end of that read event (we already loop over the windows to
check for bells etc anyway).
@
text
@d302 2
d351 3
@


1.137
log
@Error messages should not have a trailing period.
@
text
@d1 1
a1 1
/* $OpenBSD: window.c,v 1.136 2015/08/28 07:49:24 nicm Exp $ */
a301 2
	if (options_get_number(&w->options, "automatic-rename"))
		queue_window_name(w);
a348 3

	if (event_initialized(&w->name_timer))
		evtimer_del(&w->name_timer);
@


1.136
log
@Only do the automatic-rename dance if the pane has changed (seen output,
or new active pane).
@
text
@d1 1
a1 1
/* $OpenBSD: window.c,v 1.135 2015/07/17 13:09:07 nicm Exp $ */
d937 1
a937 1
		fatal("gettimeofday failed.");
@


1.135
log
@Do not call window_unzoom from window_destroy because it will try to add
a notification which will get confused because the reference count is
already zero and end up back in window_destroy and a double
free. Instead, just destroy the layouts directly. Noticed by Thomas
Adam.
@
text
@d1 1
a1 1
/* $OpenBSD: window.c,v 1.134 2015/06/17 16:50:28 nicm Exp $ */
d415 1
@


1.134
log
@Move the shuffle code from new-window -a into a function and add a -a
flag for move-window too. From Thomas Adam.
@
text
@d1 1
a1 1
/* $OpenBSD: window.c,v 1.133 2015/06/15 10:58:01 nicm Exp $ */
a343 2
	window_unzoom(w);

d347 3
a349 1
		layout_free(w);
@


1.133
log
@Add window_activity format, from Thomas Adam based on a diff originally
from propos6 at gmail dot com.
@
text
@d1 1
a1 1
/* $OpenBSD: window.c,v 1.132 2015/06/04 11:43:51 nicm Exp $ */
d1380 25
@


1.132
log
@Add support for a single "marked pane". There is one marked pane in the
server at a time; it may be toggled or cleared with select-pane -m and
-M (the border is highlighted). A new target '~' or '{marked}' specifies
the marked pane to commands and it is the default target for the
swap-pane and join-pane -s flag (this makes them much simpler to use -
mark the source pane and then change to the target pane to run swapp or
joinp).
@
text
@d1 1
a1 1
/* $OpenBSD: window.c,v 1.131 2015/05/12 22:40:38 nicm Exp $ */
d297 3
@


1.131
log
@To replace c0-*, add a high watermark to the pty event, and also backoff
when the any of the ttys the pane is going to write to has buffered
enough data.
@
text
@d1 1
a1 1
/* $OpenBSD: window.c,v 1.130 2015/05/11 10:10:16 nicm Exp $ */
d546 3
d667 2
@


1.130
log
@Remove the c0-* options which never really worked satisfactorily. Going
to try something else...
@
text
@d1 1
a1 1
/* $OpenBSD: window.c,v 1.129 2015/05/07 11:42:56 nicm Exp $ */
d61 1
d744 3
d874 2
d883 6
d891 11
a901 3
	struct window_pane     *wp = data;
	char   		       *new_data;
	size_t			new_size;
d903 10
a912 1
	new_size = EVBUFFER_LENGTH(wp->event->input) - wp->pipe_off;
d914 1
a914 1
		new_data = EVBUFFER_DATA(wp->event->input);
d920 1
a920 1
	wp->pipe_off = EVBUFFER_LENGTH(wp->event->input);
d929 11
d943 2
a944 2
window_pane_error_callback(
    unused struct bufferevent *bufev, unused short what, void *data)
@


1.129
log
@Style spacing nits.
@
text
@d1 1
a1 1
/* $OpenBSD: window.c,v 1.128 2015/05/06 08:35:39 nicm Exp $ */
a60 1
void	window_pane_timer_callback(int, short, void *);
a742 3
	if (event_initialized(&wp->changes_timer))
		evtimer_del(&wp->changes_timer);

a873 36
}

void
window_pane_timer_start(struct window_pane *wp)
{
	struct timeval	tv;

	tv.tv_sec = 0;
	tv.tv_usec = 1000;

	evtimer_del(&wp->changes_timer);
	evtimer_set(&wp->changes_timer, window_pane_timer_callback, wp);
	evtimer_add(&wp->changes_timer, &tv);
}

void
window_pane_timer_callback(unused int fd, unused short events, void *data)
{
	struct window_pane	*wp = data;
	struct window		*w = wp->window;
	u_int			 interval, trigger;

	interval = options_get_number(&w->options, "c0-change-interval");
	trigger = options_get_number(&w->options, "c0-change-trigger");

	if (wp->changes_redraw++ == interval) {
		wp->flags |= PANE_REDRAW;
		wp->changes_redraw = 0;
	}

	if (trigger == 0 || wp->changes < trigger) {
		wp->flags |= PANE_REDRAW;
		wp->flags &= ~PANE_DROP;
	} else
		window_pane_timer_start(wp);
	wp->changes = 0;
@


1.128
log
@Add a format window_linked which is 1 if a window has been linked
multiple times, also remove the default space in window_flags and use a
conditional to add it in window-status-format (this means additional
flags can be added in the option without extra spaces). From Thomas Adam
with tweaks by me.
@
text
@d1 1
a1 1
/* $OpenBSD: window.c,v 1.127 2015/04/28 10:43:14 nicm Exp $ */
d305 1
a305 1
	RB_INSERT (windows, &windows, w);
@


1.127
log
@Add select-layout -o to undo the last layout change (apply the previously
set layout).
@
text
@d1 1
a1 1
/* $OpenBSD: window.c,v 1.126 2015/04/25 18:56:05 nicm Exp $ */
d646 1
a646 1
/* Return list of printable window flag symbols. No flags is just a space. */
a665 2
	if (pos == 0)
		flags[pos++] = ' ';
@


1.126
log
@Get rid of window_choose_list type.
@
text
@d1 1
a1 1
/* $OpenBSD: window.c,v 1.125 2015/04/25 18:49:01 nicm Exp $ */
d347 1
@


1.125
log
@Fix some char* -> char *.
@
text
@d1 1
a1 1
/* $OpenBSD: window.c,v 1.124 2015/04/25 18:33:59 nicm Exp $ */
a51 2
ARRAY_DECL(window_pane_list, struct window_pane *);

d65 1
a65 1
struct window_pane *window_pane_choose_best(struct window_pane_list *);
d1150 1
a1150 1
window_pane_choose_best(struct window_pane_list *list)
d1155 1
a1155 1
	if (ARRAY_LENGTH(list) == 0)
d1158 3
a1160 3
	best = ARRAY_FIRST(list);
	for (i = 1; i < ARRAY_LENGTH(list); i++) {
		next = ARRAY_ITEM(list, i);
d1174 2
a1175 3
	struct window_pane	*next, *best;
	u_int			 edge, left, right, end;
	struct window_pane_list	 list;
d1180 3
a1182 1
	ARRAY_INIT(&list);
d1205 4
a1208 2
		if (found)
			ARRAY_ADD(&list, next);
d1211 2
a1212 2
	best = window_pane_choose_best(&list);
	ARRAY_FREE(&list);
d1220 2
a1221 3
	struct window_pane	*next, *best;
	u_int			 edge, left, right, end;
	struct window_pane_list	 list;
d1226 3
a1228 1
	ARRAY_INIT(&list);
d1251 4
a1254 2
		if (found)
			ARRAY_ADD(&list, next);
d1257 2
a1258 2
	best = window_pane_choose_best(&list);
	ARRAY_FREE(&list);
d1266 2
a1267 3
	struct window_pane	*next, *best;
	u_int			 edge, top, bottom, end;
	struct window_pane_list	 list;
d1272 3
a1274 1
	ARRAY_INIT(&list);
d1297 4
a1300 2
		if (found)
			ARRAY_ADD(&list, next);
d1303 2
a1304 2
	best = window_pane_choose_best(&list);
	ARRAY_FREE(&list);
d1312 2
a1313 3
	struct window_pane	*next, *best;
	u_int			 edge, top, bottom, end;
	struct window_pane_list	 list;
d1318 3
a1320 1
	ARRAY_INIT(&list);
d1343 4
a1346 2
		if (found)
			ARRAY_ADD(&list, next);
d1349 2
a1350 2
	best = window_pane_choose_best(&list);
	ARRAY_FREE(&list);
@


1.124
log
@Make message log a TAILQ.
@
text
@d1 1
a1 1
/* $OpenBSD: window.c,v 1.123 2015/04/25 18:09:28 nicm Exp $ */
d259 1
a259 1
window_find_by_id_str(const char* s)
@


1.123
log
@Move the functions to convert ids from strings into session.c and window.c.
@
text
@d1 1
a1 1
/* $OpenBSD: window.c,v 1.122 2015/04/22 15:30:11 nicm Exp $ */
d51 2
@


1.122
log
@Change the windows array into an RB tree and fix some places where we
were only looking at the first winlink for a window in a session.
@
text
@d1 1
a1 1
/* $OpenBSD: window.c,v 1.121 2015/04/22 15:05:03 nicm Exp $ */
d257 15
d671 15
a685 1
/* Find pane in global tree by id. */
@


1.121
log
@window_index is only used in one place (window_destroy) so inline it there.
@
text
@d1 1
a1 1
/* $OpenBSD: window.c,v 1.120 2015/04/21 22:38:50 nicm Exp $ */
d67 8
d259 1
a259 2
	struct window	*w;
	u_int		 i;
d261 2
a262 6
	for (i = 0; i < ARRAY_LENGTH(&windows); i++) {
		w = ARRAY_ITEM(&windows, i);
		if (w != NULL && w->id == id)
			return (w);
	}
	return (NULL);
a268 1
	u_int		 i;
a270 1
	w->id = next_window_id++;
a286 8
	for (i = 0; i < ARRAY_LENGTH(&windows); i++) {
		if (ARRAY_ITEM(&windows, i) == NULL) {
			ARRAY_SET(&windows, i, w);
			break;
		}
	}
	if (i == ARRAY_LENGTH(&windows))
		ARRAY_ADD(&windows, w);
d289 3
a325 2
	u_int	i;

d328 1
a328 9
	for (i = 0; i < ARRAY_LENGTH(&windows); i++) {
		if (w == ARRAY_ITEM(&windows, i))
			break;
	}
	if (i == ARRAY_LENGTH(&windows))
		fatalx("index not found");
	ARRAY_SET(&windows, i, NULL);
	while (!ARRAY_EMPTY(&windows) && ARRAY_LAST(&windows) == NULL)
		ARRAY_TRUNC(&windows, 1);
a1316 1
	struct winlink	*wm;
d1318 1
a1318 10
	struct window	*w;
	u_int		 i;

	for (i = 0; i < ARRAY_LENGTH(&windows); i++) {
		if ((w = ARRAY_ITEM(&windows, i)) == NULL)
			continue;

		RB_FOREACH(s, sessions, &sessions) {
			if ((wm = session_has(s, w)) == NULL)
				continue;
d1320 3
a1322 1
			if (wm->window != wl->window)
d1324 1
a1324 1
			if ((wm->flags & WINLINK_ALERTFLAGS) == 0)
d1327 2
a1328 2
			wm->flags &= ~WINLINK_ALERTFLAGS;
			wm->window->flags &= ~WINDOW_ALERTFLAGS;
@


1.120
log
@Always format real layout even when zoomed.
@
text
@d1 1
a1 1
/* $OpenBSD: window.c,v 1.119 2015/04/20 07:50:49 nicm Exp $ */
a247 10
int
window_index(struct window *s, u_int *i)
{
	for (*i = 0; *i < ARRAY_LENGTH(&windows); (*i)++) {
		if (s == ARRAY_ITEM(&windows, *i))
			return (0);
	}
	return (-1);
}

d334 5
a338 1
	if (window_index(w, &i) != 0)
@


1.119
log
@Use a more sensible buffer size for flags string.
@
text
@d1 1
a1 1
/* $OpenBSD: window.c,v 1.118 2015/04/19 21:34:21 nicm Exp $ */
d522 1
@


1.118
log
@Rewrite of tmux mouse support which was a mess. Instead of having
options for "mouse-this" and "mouse-that", mouse events may be bound as
keys and there is one option "mouse" that turns on mouse support
entirely (set -g mouse on).

See the new MOUSE SUPPORT section of the man page for description of the
key names and new flags (-t= to specify the pane or window under mouse
as a target, and send-keys -M to pass through a mouse event).

The default builtin bindings for the mouse are:

    bind -n   MouseDown1Pane select-pane -t=; send-keys -M
    bind -n MouseDown1Status select-window -t=
    bind -n   MouseDrag1Pane copy-mode -M
    bind -n MouseDrag1Border resize-pane -M

To get the effect of turning mode-mouse off, do:

    unbind -n MouseDrag1Pane
    unbind -temacs-copy MouseDrag1Pane

The old mouse options are now gone, set-option -q may be used to
suppress warnings if mixing configuration files.
@
text
@d1 1
a1 1
/* $OpenBSD: window.c,v 1.117 2015/04/19 21:05:27 nicm Exp $ */
d653 1
a653 1
	char	flags[BUFSIZ];
@


1.117
log
@Support setting the default window and pane background colours (window
and active pane via window-style and window-active-style options, an
individual pane by a new select-pane -P flag). From J Raynor.
@
text
@d1 1
a1 1
/* $OpenBSD: window.c,v 1.116 2015/02/09 12:47:18 nicm Exp $ */
d390 12
d1067 2
a1068 1
window_pane_key(struct window_pane *wp, struct session *sess, int key)
d1072 3
d1077 1
a1077 1
			wp->mode->key(wp, sess, key);
d1084 4
a1087 1
	input_key(wp, key);
d1093 1
a1093 1
				input_key(wp2, key);
a1095 22
}

void
window_pane_mouse(struct window_pane *wp, struct session *sess,
    struct mouse_event *m)
{
	if (!window_pane_visible(wp))
		return;

	if (m->x < wp->xoff || m->x >= wp->xoff + wp->sx)
		return;
	if (m->y < wp->yoff || m->y >= wp->yoff + wp->sy)
		return;
	m->x -= wp->xoff;
	m->y -= wp->yoff;

	if (wp->mode != NULL) {
		if (wp->mode->mouse != NULL &&
		    options_get_number(&wp->window->options, "mode-mouse"))
			wp->mode->mouse(wp, sess, m);
	} else if (wp->fd != -1)
		input_mouse(wp, sess, m);
@


1.116
log
@Entries in the window list can be NULL, prompted by a crash seen by Ben
Boeckel.
@
text
@d1 1
a1 1
/* $OpenBSD: window.c,v 1.115 2014/12/15 10:04:18 nicm Exp $ */
d707 2
@


1.115
log
@Notify on zoom/unzoom, from George Nachmann.
@
text
@d1 1
a1 1
/* $OpenBSD: window.c,v 1.114 2014/10/21 22:22:04 nicm Exp $ */
d266 1
a266 1
		if (w->id == id)
@


1.114
log
@Only redraw pane when it has actually changed.
@
text
@d1 1
a1 1
/* $OpenBSD: window.c,v 1.113 2014/08/11 22:14:30 nicm Exp $ */
d494 1
d516 1
@


1.113
log
@Add flags to selectp to enable and disable input to a pane, from Anish
Athalye.
@
text
@d1 1
a1 1
/* $OpenBSD: window.c,v 1.112 2014/06/23 10:27:05 nicm Exp $ */
d389 1
a389 1
void
d393 1
a393 1
		return;
d401 1
a401 1
			return;
d404 1
@


1.112
log
@Allow keys and send-keys to invisible panes, from saggy-kun at users dot
sf dot net.
@
text
@d1 1
a1 1
/* $OpenBSD: window.c,v 1.111 2014/06/05 22:14:29 nicm Exp $ */
d1060 1
a1060 1
	if (wp->fd == -1)
d1062 1
d1075 2
a1076 2
window_pane_mouse(
    struct window_pane *wp, struct session *sess, struct mouse_event *m)
@


1.111
log
@Reset properly when c0-change-trigger is increased from zero so panes
don't get stuck.
@
text
@d1 1
a1 1
/* $OpenBSD: window.c,v 1.110 2014/05/13 08:08:32 nicm Exp $ */
a1052 3

	if (!window_pane_visible(wp))
		return;
@


1.110
log
@If multiple arguments are given to new-session, new-window,
split-window, respawn-window or respawn-pane, pass them directly to
execvp() to help avoid quoting problems. One argument still goes to "sh
-c" like before. Requested by many over the years. Patch from J Raynor.
@
text
@d1 1
a1 1
/* $OpenBSD: window.c,v 1.109 2014/05/08 06:03:30 nicm Exp $ */
a879 1

@


1.109
log
@Both the two previous ways of navigating panes by direction have
irritating flaws:

a) The old way of always using the top or left if the choice is
ambiguous is annoying when the layout is unbalanced.

b) The new way of remembering the last used pane is annoying if the
layout is balanced and the leftmost is obvious to the user (because
clearly if we go right from the top-left in a tiled set of four we want
to end up in top-right, even if we were last using the bottom-right).

So instead, use a combination of both: if there is only one possible
pane alongside the current pane, move to it, otherwise choose the most
recently used of the choice.
@
text
@d1 1
a1 1
/* $OpenBSD: window.c,v 1.108 2014/04/17 14:45:49 nicm Exp $ */
d310 1
a310 1
window_create(const char *name, const char *cmd, const char *path,
d321 1
a321 1
	if (window_pane_spawn(wp, cmd, path, shell, cwd, env, tio,
d681 2
a682 1
	wp->cmd = NULL;
d741 1
a741 1
	free(wp->cmd);
d746 3
a748 3
window_pane_spawn(struct window_pane *wp, const char *cmd, const char *path,
    const char *shell, int cwd, struct environ *env, struct termios *tio,
    char **cause)
d751 2
a752 2
	char		*argv0, paneid[16];
	const char	*ptr;
d754 1
d760 4
a763 3
	if (cmd != NULL) {
		free(wp->cmd);
		wp->cmd = xstrdup(cmd);
d774 4
a777 1
	log_debug("spawn: %s -- %s", wp->shell, wp->cmd);
d787 1
d815 14
a828 2
		if (*wp->cmd != '\0') {
			/* Use the command. */
d833 1
a833 1
			execl(wp->shell, argv0, "-c", wp->cmd, (char *) NULL);
a835 2

		/* No command; fork a login shell. */
d840 1
a840 1
		execl(wp->shell, argv0, (char *) NULL);
d846 2
a847 2
	wp->event = bufferevent_new(wp->fd,
	    window_pane_read_callback, NULL, window_pane_error_callback, wp);
d850 1
@


1.108
log
@Some more long lines.
@
text
@d1 1
a1 1
/* $OpenBSD: window.c,v 1.107 2014/04/17 13:02:59 nicm Exp $ */
d59 1
a59 4

struct window_pane *window_pane_active_set(struct window_pane *,
	    struct window_pane *);
void	window_pane_active_lost(struct window_pane *, struct window_pane *);
d65 2
a388 58
/*
 * Restore previously active pane when changing from wp to nextwp. The intended
 * pane is in nextwp and it returns the previously focused pane.
 */
struct window_pane *
window_pane_active_set(struct window_pane *wp, struct window_pane *nextwp)
{
	struct layout_cell	*lc;
	struct window_pane	*lastwp;

	/* Target pane's parent must not be an ancestor of source pane. */
	for (lc = wp->layout_cell->parent; lc != NULL; lc = lc->parent) {
		if (lc == nextwp->layout_cell->parent)
			return (nextwp);
	}

	/*
	 * Previously active pane, if any, must not be the same as the source
	 * pane.
	 */
	lc = nextwp->layout_cell->parent;
	if (lc != NULL && lc->lastwp != NULL) {
		lastwp = lc->lastwp;
		if (lastwp != wp && window_pane_visible(lastwp))
			return (lastwp);
	}
	return (nextwp);
}

/* Remember previously active pane when changing from wp to nextwp. */
void
window_pane_active_lost(struct window_pane *wp, struct window_pane *nextwp)
{
	struct layout_cell	*lc, *lc2, *lcparent;

	/* Get the parent cell. */
	lcparent = nextwp->layout_cell->parent;
	if (lcparent == NULL)
		return;

	/* Save the target pane in its parent. */
	lcparent->lastwp = nextwp;

	/*
	 * Save the source pane in all of its parents up to, but not including,
	 * the common ancestor of itself and the target panes.
	 */
	if (wp == NULL)
		return;
	for (lc = wp->layout_cell->parent; lc != NULL; lc = lc->parent) {
		for (lc2 = lcparent; lc2 != NULL; lc2 = lc2->parent) {
			if (lc == lc2)
				return;
		}
		lc->lastwp = wp;
	}
}

a395 1
	window_pane_active_lost(w->last, wp);
d403 1
a714 10
	struct window_pane	*wp2;

	/* Forget removed pane in all layout cells that remember it. */
	RB_FOREACH(wp2, window_pane_tree, &all_window_panes) {
		if (wp2->layout_cell != NULL &&
		    wp2->layout_cell->parent != NULL &&
		    wp2->layout_cell->parent->lastwp == wp)
			wp2->layout_cell->parent->lastwp = NULL;
	}

d1121 23
a1143 1
/* Find the pane directly above another. */
d1147 4
a1150 2
	struct window_pane     *wp2;
	u_int			left, top;
d1154 5
a1159 3
	top = wp->yoff;
	if (top == 0)
		top = wp->window->sy + 1;
d1161 1
d1163 2
a1164 2
	TAILQ_FOREACH(wp2, &wp->window->panes, entry) {
		if (!window_pane_visible(wp2))
d1166 1
a1166 1
		if (wp2->yoff + wp2->sy + 1 != top)
d1168 16
a1183 4
		if (left >= wp2->xoff && left <= wp2->xoff + wp2->sx)
			return (window_pane_active_set(wp, wp2));
	}
	return (NULL);
d1190 4
a1193 2
	struct window_pane     *wp2;
	u_int			left, bottom;
d1197 5
a1202 3
	bottom = wp->yoff + wp->sy + 1;
	if (bottom >= wp->window->sy)
		bottom = 0;
d1204 1
d1206 2
a1207 2
	TAILQ_FOREACH(wp2, &wp->window->panes, entry) {
		if (!window_pane_visible(wp2))
d1209 1
a1209 1
		if (wp2->yoff != bottom)
d1211 11
a1221 2
		if (left >= wp2->xoff && left <= wp2->xoff + wp2->sx)
			return (window_pane_active_set(wp, wp2));
d1223 4
a1226 1
	return (NULL);
d1229 1
a1229 4
/*
 * Find the pane directly to the left of another, adjacent to the left side and
 * containing the top edge.
 */
d1233 4
a1236 2
	struct window_pane     *wp2;
	u_int			left, top;
d1240 5
a1245 3
	left = wp->xoff;
	if (left == 0)
		left = wp->window->sx + 1;
d1247 1
d1249 2
a1250 2
	TAILQ_FOREACH(wp2, &wp->window->panes, entry) {
		if (!window_pane_visible(wp2))
d1252 1
a1252 1
		if (wp2->xoff + wp2->sx + 1 != left)
d1254 11
a1264 2
		if (top >= wp2->yoff && top <= wp2->yoff + wp2->sy)
			return (window_pane_active_set(wp, wp2));
d1266 4
a1269 1
	return (NULL);
d1272 1
a1272 4
/*
 * Find the pane directly to the right of another, that is adjacent to the
 * right edge and including the top edge.
 */
d1276 4
a1279 2
	struct window_pane     *wp2;
	u_int			right, top;
d1283 5
a1288 3
	right = wp->xoff + wp->sx + 1;
	if (right >= wp->window->sx)
		right = 0;
d1290 1
d1292 2
a1293 2
	TAILQ_FOREACH(wp2, &wp->window->panes, entry) {
		if (!window_pane_visible(wp2))
d1295 1
a1295 1
		if (wp2->xoff != right)
d1297 16
a1312 4
		if (top >= wp2->yoff && top <= wp2->yoff + wp2->sy)
			return (window_pane_active_set(wp, wp2));
	}
	return (NULL);
@


1.107
log
@Set PATH explicitly, either from client or session
environment. Previously it came from the session environment. From J
Raynor.
@
text
@d1 1
a1 1
/* $OpenBSD: window.c,v 1.106 2014/04/17 11:38:35 nicm Exp $ */
d1165 2
a1166 1
window_pane_search(struct window_pane *wp, const char *searchstr, u_int *lineno)
@


1.106
log
@Remove some unnecessary includes and fix a typo.
@
text
@d1 1
a1 1
/* $OpenBSD: window.c,v 1.105 2014/04/17 09:13:13 nicm Exp $ */
d311 2
a312 2
window_create(const char *name, const char *cmd, const char *shell,
    int cwd, struct environ *env, struct termios *tio,
d322 2
a323 1
	if (window_pane_spawn(wp, cmd, shell, cwd, env, tio, cause) != 0) {
d814 3
a816 2
window_pane_spawn(struct window_pane *wp, const char *cmd, const char *shell,
    int cwd, struct environ *env, struct termios *tio, char **cause)
d865 2
@


1.105
log
@Correct the dance to fix the active pane in join-pane by pulling the
(right) code from break-pane and window_remove_pane into a helper
function.
@
text
@d1 1
a1 1
/* $OpenBSD: window.c,v 1.104 2014/04/17 07:36:45 nicm Exp $ */
a19 1
#include <sys/ioctl.h>
a23 3
#include <paths.h>
#include <pwd.h>
#include <signal.h>
@


1.104
log
@Remove the monitor-content option and associated bits and bobs. It's
never worked very well. If there is a big demand for it to return, will
consider better ways to do it.
@
text
@d1 1
a1 1
/* $OpenBSD: window.c,v 1.103 2014/03/31 21:41:07 nicm Exp $ */
d594 1
a594 1
window_remove_pane(struct window *w, struct window_pane *wp)
d606 6
@


1.103
log
@Don't segfaut when the parent of the layout cell is NULL, from Thomas Adam.
@
text
@d1 1
a1 1
/* $OpenBSD: window.c,v 1.102 2014/02/22 18:01:10 nicm Exp $ */
a701 2
	if (wl->flags & WINLINK_CONTENT)
		flags[pos++] = '+';
@


1.102
log
@Fix crash due to uninitialized lastwp member of layout_cell, reported by
Balazs Kezes.
@
text
@d1 1
a1 1
/* $OpenBSD: window.c,v 1.101 2014/01/28 23:07:09 nicm Exp $ */
d426 6
a431 1
	struct layout_cell	*lc, *lc2;
d434 1
a434 1
	nextwp->layout_cell->parent->lastwp = nextwp;
d443 1
a443 2
		lc2 = nextwp->layout_cell->parent;
		for (; lc2 != NULL; lc2 = lc2->parent) {
@


1.101
log
@Allow replacing each of the many sets of separate foo-{fg,bg,attr}
options with a single foo-style option. For example:

    set -g status-fg yellow
    set -g status-bg red
    set -g status-attr blink

Becomes:

    set -g status-style fg=yellow,bg=red,blink

The -a flag to set can be used to add to rather than replace a style. So:

    set -g status-bg red

Becomes:

    set -ag status-style bg=red

Currently this is fully backwards compatible (all *-{fg,bg,attr} options
remain) but the plan is to deprecate them over time.

From Tiago Cunha.
@
text
@d1 1
a1 1
/* $OpenBSD: window.c,v 1.100 2014/01/28 22:19:17 nicm Exp $ */
d413 3
a415 2
	if (nextwp->layout_cell->parent != NULL) {
		lastwp = nextwp->layout_cell->parent->lastwp;
@


1.100
log
@Remember the last active pane in the top-bottom or left-right cell so
that it can be restored when moving back to that cell with selectp
-L/-R/etc. From Suraj N Kurapati.
@
text
@d1 1
a1 1
/* $OpenBSD: window.c,v 1.99 2013/10/10 12:26:37 nicm Exp $ */
a1316 10
}

/* Set the grid_cell with fg/bg/attr information when window is in a mode. */
void
window_mode_attrs(struct grid_cell *gc, struct options *oo)
{
	memcpy(gc, &grid_default_cell, sizeof *gc);
	colour_set_fg(gc, options_get_number(oo, "mode-fg"));
	colour_set_bg(gc, options_get_number(oo, "mode-bg"));
	gc->attr |= options_get_number(oo, "mode-attr");
@


1.99
log
@Alter how tmux handles the working directory to internally use file
descriptors rather than strings.

- Each session still has a current working directory.

- New sessions still get their working directory from the client that
  created them or its attached session if any.

- New windows are created by default in the session working directory.

- The -c flag to new, neww, splitw allows the working directory to be
  overridden.

- The -c flag to attach let's the session working directory be changed.

- The default-path option has been removed.

To get the equivalent to default-path '.', do:

        bind c neww -c $PWD

To get the equivalent of default-path '~', do:

        bind c neww -c ~

This also changes the client identify protocol to be a set of messages rather
than one as well as some other changes that should make it easier to make
backwards-compatible protocol changes in future.
@
text
@d1 1
a1 1
/* $OpenBSD: window.c,v 1.98 2013/10/10 11:59:23 nicm Exp $ */
d64 4
d393 53
d453 1
d768 10
d1201 1
a1201 1
			return (wp2);
d1227 1
a1227 1
			return (wp2);
d1256 1
a1256 1
			return (wp2);
d1285 1
a1285 1
			return (wp2);
@


1.98
log
@Clear window->flags when clearing winlinks

When clearing WINLINK_ALERTFLAGS for all sessions, we must also, for
that window, clear the window->flags as well, otherwise sessions may
well still see flags for winlinks long since cleared.

This therefore introduces WINDOW_ALERTFLAGS to help with this.
@
text
@d1 1
a1 1
/* $OpenBSD: window.c,v 1.97 2013/03/26 10:54:48 nicm Exp $ */
d312 1
a312 1
    const char *cwd, struct environ *env, struct termios *tio,
d678 1
a678 1
	wp->cwd = NULL;
d733 1
a733 1
	free(wp->cwd);
d741 1
a741 1
    const char *cwd, struct environ *env, struct termios *tio, char **cause)
d760 3
a762 3
	if (cwd != NULL) {
		free(wp->cwd);
		wp->cwd = xstrdup(cwd);
d777 1
a777 1
		if (chdir(wp->cwd) != 0)
@


1.97
log
@Fix compiler warnings, missing #include. From Thomas Adam.
@
text
@d1 1
a1 1
/* $OpenBSD: window.c,v 1.96 2013/03/25 15:59:57 nicm Exp $ */
d1245 1
@


1.96
log
@Revert the command-prefix change which breaks sequences of commands.
@
text
@d1 1
a1 1
/* $OpenBSD: window.c,v 1.95 2013/03/25 11:55:01 nicm Exp $ */
d499 1
a499 1
	struct window_pane	*wp, *wp1;
a502 1
	wp = w->active;
d508 3
a510 3
	TAILQ_FOREACH(wp1, &w->panes, entry) {
		wp1->layout_cell = wp1->saved_layout_cell;
		wp1->saved_layout_cell = NULL;
@


1.95
log
@Set pane resize flag when needed.
@
text
@d1 1
a1 1
/* $OpenBSD: window.c,v 1.94 2013/03/25 11:39:11 nicm Exp $ */
a316 2
	const char		*prefix;
	char			*cmd1;
d322 1
a322 6
	if (*cmd != '\0') {
		prefix = options_get_string(&w->options, "command-prefix");
		xasprintf(&cmd1, "%s%s", prefix, cmd);
	} else
		cmd1 = xstrdup("");
	if (window_pane_spawn(wp, cmd1, shell, cwd, env, tio, cause) != 0) {
a323 1
		free(cmd1);
a325 1
	free(cmd1);
@


1.94
log
@Don't zoom windows with one pane, from Romain Francoise.
@
text
@d1 1
a1 1
/* $OpenBSD: window.c,v 1.93 2013/03/24 09:57:59 nicm Exp $ */
d921 2
@


1.93
log
@Add resize-pane -Z to temporary zoom the active pane to occupy the full
window or unzoom (restored to the normal layout) if it already zoomed,
bound to C-b z by default. The pane is unzoomed on pretty much any
excuse whatsoever.

We considered making this a new layout but the requirements are quite
different from layouts so decided it is better as a special case. Each
current layout cell is saved, a temporary one-cell layout generated and
all except the active pane set to NULL.

Prompted by suggestions and scripts from several. Thanks to Aaron Jensen
and Thiago Padilha for testing an earlier version.
@
text
@d1 1
a1 1
/* $OpenBSD: window.c,v 1.92 2013/03/24 09:25:04 nicm Exp $ */
d486 4
@


1.92
log
@Do pane resize ioctls once at the end of the server loop rather than
immediately.
@
text
@d1 1
a1 1
/* $OpenBSD: window.c,v 1.91 2013/03/24 09:21:27 nicm Exp $ */
d322 1
a322 1
	layout_init(w);
d351 2
d475 48
d653 2
d1082 2
@


1.91
log
@Add option command-prefix which is automatically prepended to any
command (apart from a naked default-shell). The default is "exec ".
@
text
@d1 1
a1 1
/* $OpenBSD: window.c,v 1.90 2013/03/22 10:31:22 nicm Exp $ */
a856 2
	struct winsize	ws;

a861 4
	memset(&ws, 0, sizeof ws);
	ws.ws_col = sx;
	ws.ws_row = sy;

a864 3

	if (wp->fd != -1 && ioctl(wp->fd, TIOCSWINSZ, &ws) == -1)
		fatal("ioctl failed");
@


1.90
log
@No more lint means no more ARGSUSED.
@
text
@d1 1
a1 1
/* $OpenBSD: window.c,v 1.89 2013/02/05 11:08:59 nicm Exp $ */
d313 1
a313 1
    u_int sx, u_int sy, u_int hlimit,char **cause)
d317 2
d323 7
a329 1
	if (window_pane_spawn(wp, cmd, shell, cwd, env, tio, cause) != 0) {
d331 1
d334 2
d342 1
d718 2
@


1.89
log
@Automatically reflow wrapped lines when a pane is resized, requested by
many over the years and finally implemented by Richard Woodbury.
@
text
@d1 1
a1 1
/* $OpenBSD: window.c,v 1.88 2013/01/17 00:11:22 nicm Exp $ */
a804 1
/* ARGSUSED */
a830 1
/* ARGSUSED */
@


1.88
log
@Remove the layout undo/redo code which never really worked.
@
text
@d1 1
a1 1
/* $OpenBSD: window.c,v 1.87 2012/11/27 20:08:42 nicm Exp $ */
d856 1
a856 1
	screen_resize(&wp->base, sx, sy);
d917 1
a917 1
		screen_resize(s, sx, wp->saved_grid->sy);
d936 2
a937 2
	if (sy > wp->saved_grid->sy)
		screen_resize(s, sx, sy);
@


1.87
log
@Support the 47 and 1047 SM and RM sequences (alternate screen without
cursor), requested by I forget who ages ago.
@
text
@d1 1
a1 1
/* $OpenBSD: window.c,v 1.86 2012/10/26 14:35:42 nicm Exp $ */
a288 1
	TAILQ_INIT(&w->layout_list);
@


1.86
log
@Make mouse event structure clearer by defining events (up, click, drag)
and simplifying how buttons and wheels are represented, from Ailin
Nemui. Should be no functional changes.
@
text
@d1 1
a1 1
/* $OpenBSD: window.c,v 1.85 2012/10/25 11:14:46 nicm Exp $ */
d870 2
a871 1
window_pane_alternate_on(struct window_pane *wp, struct grid_cell *gc)
d885 4
a888 2
	wp->saved_cx = s->cx;
	wp->saved_cy = s->cy;
d900 2
a901 1
window_pane_alternate_off(struct window_pane *wp, struct grid_cell *gc)
d922 2
a923 1
	s->cx = wp->saved_cx;
d926 2
a927 1
	s->cy = wp->saved_cy;
@


1.85
log
@Fix bad size in memcpy from Romain Francoise.
@
text
@d1 1
a1 1
/* $OpenBSD: window.c,v 1.84 2012/08/21 10:00:33 nicm Exp $ */
d1014 1
a1014 1
		input_mouse(wp, m);
@


1.84
log
@Fix up window reference counting and don't crash if the rename timer
fires while the window is dead but still referenced. Fixes problem
reported by Michael Scholz.
@
text
@d1 1
a1 1
/* $OpenBSD: window.c,v 1.83 2012/08/11 06:45:33 nicm Exp $ */
d1196 1
a1196 1
	memcpy(gc, &grid_default_cell, sizeof gc);
@


1.83
log
@Instead of numbering choose mode items 0-9a-z and then nothing, number
them all and if there are more than 10 use a prompt when 0-9 is
pressed. From Thomas Adam.
@
text
@d1 1
a1 1
/* $OpenBSD: window.c,v 1.82 2012/07/10 11:53:01 nicm Exp $ */
d185 2
a186 7
	if (w != NULL) {
		if (w->references == 0)
			fatal("bad reference count");
		w->references--;
		if (w->references == 0)
			window_destroy(w);
	}
d358 10
@


1.82
log
@xfree is not particularly helpful, remove it. From Thomas Adam.
@
text
@d1 1
a1 1
/* $OpenBSD: window.c,v 1.81 2012/07/08 07:27:32 nicm Exp $ */
d1185 10
@


1.81
log
@Clear flags across all sessions, from Thomas Adam.
@
text
@d1 1
a1 1
/* $OpenBSD: window.c,v 1.80 2012/05/28 08:55:43 nicm Exp $ */
d182 2
a183 3
	if (wl->status_text != NULL)
		xfree(wl->status_text);
	xfree(wl);
d361 2
a362 3
	if (w->name != NULL)
		xfree(w->name);
	xfree(w);
d368 1
a368 2
	if (w->name != NULL)
		xfree(w->name);
d671 4
a674 7
	if (wp->cwd != NULL)
		xfree(wp->cwd);
	if (wp->shell != NULL)
		xfree(wp->shell);
	if (wp->cmd != NULL)
		xfree(wp->cmd);
	xfree(wp);
d691 1
a691 2
		if (wp->cmd != NULL)
			xfree(wp->cmd);
d695 1
a695 2
		if (wp->shell != NULL)
			xfree(wp->shell);
d699 1
a699 2
		if (wp->cwd != NULL)
			xfree(wp->cwd);
d1042 1
a1042 1
		xfree(line);
d1045 1
a1045 1
	xfree(newsearchstr);
@


1.80
log
@Use default-shell not _PATH_BSHELL to spawn commands, pointed out by
Dennis G?nnewig and Thomas Adam.
@
text
@d1 1
a1 1
/* $OpenBSD: window.c,v 1.79 2012/04/08 06:47:26 nicm Exp $ */
d1166 28
@


1.79
log
@Do not fire name timer when automatic-rename is off, from Tim Ruehsen a
while ago.
@
text
@d1 1
a1 1
/* $OpenBSD: window.c,v 1.78 2012/04/01 20:53:47 nicm Exp $ */
d742 3
d746 6
a751 6
			/* Set SHELL but only if it is currently not useful. */
			shell = getenv("SHELL");
			if (checkshell(shell))
				setenv("SHELL", wp->shell, 1);

			execl(_PATH_BSHELL, "sh", "-c", wp->cmd, (char *) NULL);
a755 1
		ptr = strrchr(wp->shell, '/');
a759 1
		setenv("SHELL", wp->shell, 1);
@


1.78
log
@Minor style nits - return ().
@
text
@d1 1
a1 1
/* $OpenBSD: window.c,v 1.77 2012/04/01 13:18:38 nicm Exp $ */
a299 2
	queue_window_name(w);

d301 2
@


1.77
log
@Add a layout history which can be stepped through with select-layout -u
and -U commands (bound to 'u' and 'U' by default).
@
text
@d1 1
a1 1
/* $OpenBSD: window.c,v 1.76 2012/03/20 14:06:44 nicm Exp $ */
d118 1
a118 1
	return NULL;
d276 1
a276 1
	return NULL;
@


1.76
log
@Check changes_timer with event_initialized before event_del.
@
text
@d1 1
a1 1
/* $OpenBSD: window.c,v 1.75 2012/03/20 11:01:00 nicm Exp $ */
d295 1
@


1.75
log
@Add a simple form of output rate limiting by counting the number of
certain C0 sequences (linefeeds, backspaces, carriage returns) and if it
exceeds a threshold (current default 50/millisecond), start to redraw
the pane every 100 milliseconds instead of making each change as it
comes. Two configuration options - c0-change-trigger and
c0-change-interval.

This makes tmux much more responsive under very fast output (for example
yes(1) or accidentally cat'ing a large file) but may not be perfect on
all terminals and connections - feedback very welcome, particularly
where this change has a negative rather than positive effect (making it
off by default is a possibility).

After much experimentation based originally on a request Robin Lee
Powell (which ended with a completely different solution), this idea
from discussion with Ailin Nemui.
@
text
@d1 1
a1 1
/* $OpenBSD: window.c,v 1.74 2012/03/17 22:35:09 nicm Exp $ */
d652 2
a653 1
	event_del(&wp->changes_timer);
@


1.74
log
@Add notify hooks for various events, the functions are currently empty
stubs but will be filled in for control mode later. From George Nachman.
@
text
@d1 1
a1 1
/* $OpenBSD: window.c,v 1.73 2012/03/17 18:24:07 nicm Exp $ */
d64 1
d652 2
d768 37
@


1.73
log
@Check event_initialized before event_del if event may not have been set
up; libevent2 complains about this. Reported by Moriyoshi Koizumi.
@
text
@d1 1
a1 1
/* $OpenBSD: window.c,v 1.72 2012/02/02 00:10:12 nicm Exp $ */
d371 1
@


1.72
log
@Move window name changes into wrapper function window_set_name, from
George Nachman.
@
text
@d1 1
a1 1
/* $OpenBSD: window.c,v 1.71 2012/01/30 09:39:34 nicm Exp $ */
d353 2
a354 1
	evtimer_del(&w->name_timer);
@


1.71
log
@Give each window a unique id, like panes but prefixed with @@. Based on
work from George Nachman.
@
text
@d1 1
a1 1
/* $OpenBSD: window.c,v 1.70 2012/01/29 02:22:11 nicm Exp $ */
d362 8
@


1.70
log
@Call bufferevent_free before closing file descriptor associated with it
or bugs in $EventMechanism on $OtherOS makes libevent get it's knickers
in a twist. From Dylan Alex Simon.
@
text
@d1 1
a1 1
/* $OpenBSD: window.c,v 1.69 2011/11/15 23:19:51 nicm Exp $ */
d61 2
a62 1
u_int	next_window_pane;
d108 12
d265 14
d285 1
d602 1
a602 1
	wp->id = next_window_pane++;
@


1.69
log
@Make window_pane_index work the same as window_index, from Ben Boeckel.
@
text
@d1 1
a1 1
/* $OpenBSD: window.c,v 1.68 2011/09/25 18:53:04 nicm Exp $ */
d614 1
a615 1
		bufferevent_free(wp->event);
d625 1
a626 1
		bufferevent_free(wp->pipe_event);
d650 1
a651 1
		bufferevent_free(wp->event);
@


1.68
log
@Reject $SHELL if it is not a full path.
@
text
@d1 1
a1 1
/* $OpenBSD: window.c,v 1.67 2011/08/24 10:29:57 nicm Exp $ */
d489 2
a490 2
u_int
window_pane_index(struct window *w, struct window_pane *wp)
d493 1
a493 1
	u_int			 n;
d495 1
a495 1
	n = options_get_number(&w->options, "pane-base-index");
d497 4
a500 3
		if (wp == wq)
			break;
		n++;
d502 2
a503 1
	return (n);
@


1.67
log
@Add pane-base-index option, from Ben Barbour.
@
text
@d1 1
a1 1
/* $OpenBSD: window.c,v 1.66 2011/06/05 10:53:05 nicm Exp $ */
d700 1
a700 1
			if (shell == NULL || *shell == '\0' || areshell(shell))
@


1.66
log
@Get rid of the layout string code which tries to walk through the layout
hierarchy and instead just look at what panes are actually in the window.
@
text
@d1 1
a1 1
/* $OpenBSD: window.c,v 1.65 2011/04/18 20:57:16 nicm Exp $ */
d457 1
a457 1
	n = 0;
d495 1
a495 1
	n = 0;
@


1.65
log
@The mouse should only work in copy mode if mode-mouse is set, not just
mouse-select-pane.
@
text
@d1 1
a1 1
/* $OpenBSD: window.c,v 1.64 2011/03/27 20:27:27 nicm Exp $ */
d359 2
a360 2
void
window_set_active_at(struct window *w, u_int x, u_int y)
d365 1
a365 1
		if (wp == w->active || !window_pane_visible(wp))
d367 1
a367 1
		if (x < wp->xoff || x >= wp->xoff + wp->sx)
d369 1
a369 1
		if (y < wp->yoff || y >= wp->yoff + wp->sy)
d371 12
d384 34
a417 2
		break;
	}
@


1.64
log
@Give each pane created in a tmux server a unique id (starting from 0),
put it in the TMUX_PANE environment variable and accept it as a
target. Suggested by and with testing and tweaks from Ben Boeckel.
@
text
@d1 1
a1 1
/* $OpenBSD: window.c,v 1.63 2011/01/25 22:31:50 nicm Exp $ */
d887 2
a888 1
		if (wp->mode->mouse != NULL)
@


1.63
log
@Check if the index is in use and fail before creating the child process,
rather than leaving a stray child on failure.
@
text
@d1 1
a1 1
/* $OpenBSD: window.c,v 1.62 2011/01/08 01:52:37 nicm Exp $ */
d59 4
d74 8
d510 10
d528 3
d583 2
d599 1
a599 1
	char		*argv0;
d646 2
@


1.62
log
@Move all calls to fcntl(...O_NONBLOCK) into a function and clear the
flag on the stdio file descriptors before closing them (fixes things
like "tmux ls && cat").
@
text
@d1 1
a1 1
/* $OpenBSD: window.c,v 1.61 2010/12/30 21:35:17 nicm Exp $ */
d126 1
a126 1
winlink_add(struct winlinks *wwl, struct window *w, int idx)
a137 1
	wl->window = w;
d140 7
a147 2

	return (wl);
d160 7
a166 5
	if (w->references == 0)
		fatal("bad reference count");
	w->references--;
	if (w->references == 0)
		window_destroy(w);
@


1.61
log
@Add a function to create window flags rather than doing the same thing
in two places. From Thomas Adam.
@
text
@d1 1
a1 1
/* $OpenBSD: window.c,v 1.60 2010/12/06 22:51:02 nicm Exp $ */
a565 1
	int		 mode;
d639 2
a640 4
	if ((mode = fcntl(wp->fd, F_GETFL)) == -1)
		fatal("fcntl failed");
	if (fcntl(wp->fd, F_SETFL, mode|O_NONBLOCK) == -1)
		fatal("fcntl failed");
@


1.60
log
@Add an option to alert (monitor) for silence (lack of activity) in a
window. From Thomas Adam.
@
text
@d1 1
a1 1
/* $OpenBSD: window.c,v 1.59 2010/11/14 08:58:25 nicm Exp $ */
d464 26
@


1.59
log
@Don't allow last and active window to become the same - a very bad move
when the active window is closed and freed. Reported by sthen@@.
@
text
@d1 1
a1 1
/* $OpenBSD: window.c,v 1.58 2010/10/23 13:04:34 nicm Exp $ */
d642 8
@


1.58
log
@Add a last-pane command (bound to ; by default). Requested ages ago by
somebody whose name I have forgotten.
@
text
@d1 1
a1 1
/* $OpenBSD: window.c,v 1.57 2010/10/23 12:51:51 nicm Exp $ */
d328 2
d347 1
a347 1
		if (!window_pane_visible(wp))
@


1.57
log
@When removing a pane, don't change the active pane unless the active
pane is actually the one being removed.
@
text
@d1 1
a1 1
/* $OpenBSD: window.c,v 1.56 2010/10/16 08:31:55 nicm Exp $ */
d328 1
d373 9
a381 4
		w->active = TAILQ_PREV(wp, window_panes, entry);
		if (w->active == NULL)
			w->active = TAILQ_NEXT(wp, entry);
	}
@


1.56
log
@Trying to set FD_CLOEXEC on every fd is a lost cause, just use
closefrom() before exec.
@
text
@d1 1
a1 1
/* $OpenBSD: window.c,v 1.55 2010/08/25 19:19:43 nicm Exp $ */
d371 5
a375 3
	w->active = TAILQ_PREV(wp, window_panes, entry);
	if (w->active == NULL)
		w->active = TAILQ_NEXT(wp, entry);
@


1.55
log
@When destroying a pane, reset any mode (which reenables pane
bufferevent) before freeing the bufferevent.
@
text
@d1 1
a1 1
/* $OpenBSD: window.c,v 1.54 2010/08/19 18:29:01 nicm Exp $ */
d576 2
a606 2
		fatal("fcntl failed");
	if (fcntl(wp->fd, F_SETFD, FD_CLOEXEC) == -1)
@


1.54
log
@Do not call event_del() for signals after fork(), just use sigaction()
directly instead - calling libevent functions after fork() w/o
event_reinit() is a bad idea, even if in this case it was harmless.
@
text
@d1 1
a1 1
/* $OpenBSD: window.c,v 1.53 2010/07/14 18:37:49 nicm Exp $ */
d498 2
a506 1
	window_pane_reset_mode(wp);
@


1.53
log
@Make pane/window wrapping more logical (so with 10 windows, +10 from
window 5 stays in the same place), and tidy the code. From Tiago Cunha.
@
text
@d1 1
a1 1
/* $OpenBSD: window.c,v 1.52 2010/06/21 01:46:36 nicm Exp $ */
d577 1
a577 1
		clear_signals();
@


1.52
log
@Extend the -t:+ and -t:- window targets for next and previous window to
accept an offset such as -t:+2. From Tiago Cunha.
@
text
@d1 1
a1 1
/* $OpenBSD: window.c,v 1.51 2010/05/23 19:42:19 nicm Exp $ */
d176 1
a176 1
winlink_next_by_number(struct winlink *wl, int n)
d180 1
a180 1
			break;
d187 1
a187 1
winlink_previous_by_number(struct winlink *wl, int n)
d191 1
a191 1
			break;
d392 23
@


1.51
log
@Pass in the session, rather than the client, to window modes' key()
function. We were only ever using the client to find the session anyway.

This allows send-key to work properly for manipulating copy mode from
outside tmux.

From Micah Cowan.
@
text
@d1 1
a1 1
/* $OpenBSD: window.c,v 1.50 2010/05/04 17:28:16 nicm Exp $ */
d173 22
@


1.50
log
@Put this back in with the initialisation in the right order.
@
text
@d1 1
a1 1
/* $OpenBSD: window.c,v 1.49 2010/05/04 08:48:06 nicm Exp $ */
d724 1
a724 1
window_pane_key(struct window_pane *wp, struct client *c, int key)
d733 1
a733 1
			wp->mode->key(wp, c, key);
d752 1
a752 1
    struct window_pane *wp, struct client *c, struct mouse_event *m)
d766 1
a766 1
			wp->mode->mouse(wp, c, m);
@


1.49
log
@Revert last change, it appears to be broken somehow.
@
text
@d1 1
a1 1
/* $OpenBSD: window.c,v 1.47 2010/04/04 19:02:09 nicm Exp $ */
d532 1
a532 1
		server_signal_clear();
@


1.48
log
@Make signal handler setup/teardown two common functions instead of six,
and reset SIGCHLD after fork to fix problems with some shells. From
Romain Francois.
@
text
@d532 1
a532 1
		clear_signals();
@


1.47
log
@Run job commands explicitly in the global enviroment (which can be
modified with setenv -g) rather than with the environment tmux started
with.
@
text
@d1 1
a1 1
/* $OpenBSD: window.c,v 1.46 2010/04/04 18:48:37 nicm Exp $ */
d532 1
a532 1
		server_signal_clear();
@


1.46
log
@Squash a function that is only called in a callback into the callback
function.
@
text
@d1 1
a1 1
/* $OpenBSD: window.c,v 1.45 2010/03/22 19:07:52 nicm Exp $ */
d483 5
a487 8
	struct winsize	 	 ws;
	int		 	 mode;
	char			*argv0, **varp, *var;
	ARRAY_DECL(, char *)	 varlist;
	struct environ_entry	*envent;
	const char		*ptr;
	struct termios		 tio2;
	u_int		 	 i;
d530 1
a530 14
		ARRAY_INIT(&varlist);
		for (varp = environ; *varp != NULL; varp++) {
			var = xstrdup(*varp);
			var[strcspn(var, "=")] = '\0';
			ARRAY_ADD(&varlist, var);
		}
		for (i = 0; i < ARRAY_LENGTH(&varlist); i++) {
			var = ARRAY_ITEM(&varlist, i);
			unsetenv(var);
		}
		RB_FOREACH(envent, environ, env) {
			if (envent->value != NULL)
				setenv(envent->name, envent->value, 1);
		}
@


1.45
log
@Support up, down, left, right movement through panes with -UDLR flags to
select-pane.

Also REMOVE the up- and down-pane commands: equivalent behaviour is now
available using -t :.+ and -t :.-.
@
text
@d1 1
a1 1
/* $OpenBSD: window.c,v 1.44 2010/03/22 19:02:54 nicm Exp $ */
d589 11
a599 1
	struct window_pane *wp = data;
d601 1
a601 1
	window_pane_parse(wp);
a736 17
}

void
window_pane_parse(struct window_pane *wp)
{
	char   *data;
	size_t	new_size;

	new_size = EVBUFFER_LENGTH(wp->event->input) - wp->pipe_off;
	if (wp->pipe_fd != -1 && new_size > 0) {
		data = EVBUFFER_DATA(wp->event->input);
		bufferevent_write(wp->pipe_event, data, new_size);
	}

	input_parse(wp);

	wp->pipe_off = EVBUFFER_LENGTH(wp->event->input);
@


1.44
log
@New input parser based on http://vt100.net/emu/dec_ansi_parser.
@
text
@d1 1
a1 1
/* $OpenBSD$ */
d829 110
@


1.43
log
@Instead of bailing out on the first configuration file error, carry on,
collecting all the errors, then start with the active window in more mode
displaying them.
@
text
@d1 1
a1 1
/* $OpenBSD: window.c,v 1.42 2009/12/03 22:50:10 nicm Exp $ */
d624 75
@


1.42
log
@Massive spaces->tabs and trailing whitespace cleanup, hopefully for the last
time now I've configured emacs to make them displayed in really annoying
colours...
@
text
@d1 1
a1 1
/* $OpenBSD: window.c,v 1.41 2009/11/26 21:37:13 nicm Exp $ */
a658 3

	if (wp->mode != NULL)
		return;
@


1.41
log
@Remove a couple of unused arguments where possible, and add /* ARGSUSED */ to
the rest to reduce lint output.
@
text
@d1 1
a1 1
/* $OpenBSD: window.c,v 1.40 2009/11/19 19:47:28 nicm Exp $ */
d192 1
a192 1
	
d226 1
a226 1
	
d431 1
a431 1
 	wp->yoff = 0;
d516 1
a516 1
 	switch (wp->pid = forkpty(&wp->fd, wp->tty, NULL, &ws)) {
d668 1
a668 1
	
@


1.40
log
@Change status line drawing to create the window list in a separate screen and
then copy it into the status line screen. This allows UTF-8 in window names and
fixes some problems with #[] in window-status-format.
@
text
@d1 1
a1 1
/* $OpenBSD: window.c,v 1.39 2009/11/13 17:33:07 nicm Exp $ */
d164 1
a164 1
winlink_next(unused struct winlinks *wwl, struct winlink *wl)
d170 1
a170 1
winlink_previous(unused struct winlinks *wwl, struct winlink *wl)
d585 1
d594 1
@


1.39
log
@Destroy panes immediately rather than checking them all every loop.
@
text
@d1 1
a1 1
/* $OpenBSD: window.c,v 1.38 2009/11/04 23:54:57 nicm Exp $ */
d152 2
@


1.38
log
@Change window name change to use a timer event rather than a gettimeofday()
check every loop.
@
text
@d1 1
a1 1
/* $OpenBSD: window.c,v 1.37 2009/11/04 22:43:11 nicm Exp $ */
d597 1
a597 3
	close(wp->fd);
	bufferevent_free(wp->event);
	wp->fd = -1;
@


1.37
log
@Convert the window pane (pty master side) fd over to use a bufferevent.

The evbuffer API is very similar to the existing tmux buffer API so this was
remarkably painless. Not many possible ways to do it, I suppose.
@
text
@d1 1
a1 1
/* $OpenBSD: window.c,v 1.36 2009/11/04 22:02:38 nicm Exp $ */
d215 1
a215 1
	w = xmalloc(sizeof *w);
d228 2
d283 2
a486 1
	struct timeval	 	 tv;
a512 6

	if (gettimeofday(&wp->window->name_timer, NULL) != 0)
		fatal("gettimeofday failed");
	tv.tv_sec = 0;
	tv.tv_usec = NAME_INTERVAL * 1000L;
	timeradd(&wp->window->name_timer, &tv, &wp->window->name_timer);
@


1.36
log
@Switch window pane pipe redirect fd over to a bufferevent.
@
text
@d1 1
a1 1
/* $OpenBSD: window.c,v 1.35 2009/11/04 20:50:11 nicm Exp $ */
d59 3
d418 1
a418 2
	wp->in = buffer_create(BUFSIZ);
	wp->out = buffer_create(BUFSIZ);
d447 1
a447 1
	if (wp->fd != -1)
d449 2
a463 4
	buffer_destroy(wp->in);
	buffer_destroy(wp->out);
	event_del(&wp->event);

d487 1
a487 1
	if (wp->fd != -1)
d489 2
d579 3
d587 19
d658 1
d664 5
a668 3
	new_size = BUFFER_USED(wp->in) - wp->pipe_off;
	if (wp->pipe_fd != -1 && new_size > 0)
		bufferevent_write(wp->pipe_event, BUFFER_OUT(wp->in), new_size);
d672 1
a672 1
	wp->pipe_off = BUFFER_USED(wp->in);
@


1.35
log
@Initial changes to move tmux to libevent.

This moves the client-side loops are pretty much fully over to event-based only
(tmux.c and client.c) but server-side (server.c and friends) treats libevent as
a sort of clever poll, waking up after every event to run various things.

Moving the server stuff over to bufferevents and timers and so on will come
later.
@
text
@d1 1
a1 1
/* $OpenBSD: window.c,v 1.34 2009/10/22 12:30:00 nicm Exp $ */
a428 1
	wp->pipe_buf = NULL;
d430 1
a455 1
		buffer_destroy(wp->pipe_buf);
d457 1
a457 1
		event_del(&wp->pipe_event);
d641 1
a641 1
		buffer_write(wp->pipe_buf, BUFFER_OUT(wp->in), new_size);
@


1.34
log
@Only redraw the pane when changing mode, not the entire window.
@
text
@d1 1
a1 1
/* $OpenBSD: window.c,v 1.33 2009/10/19 13:18:13 nicm Exp $ */
d458 1
d463 1
d548 1
a548 1
		sigreset();
@


1.33
log
@Stop updating the screen when not in output mode, stops copy mode getting
confused.
@
text
@d1 1
a1 1
/* $OpenBSD: window.c,v 1.32 2009/10/11 10:04:27 nicm Exp $ */
d613 1
a613 1
	server_redraw_window(wp->window);
d627 1
a627 1
	server_redraw_window(wp->window);
@


1.32
log
@Add a pipe-pane command to allow a pane to be piped to a shell command, for
example:

	pipe-pane 'cat >~/out'

No arguments stops outputing and closes the pipe; the -o flag toggles a pipe
and on and off (useful for key bindings).

Suggested by espie@@.
@
text
@d1 1
a1 1
/* $OpenBSD: window.c,v 1.31 2009/10/11 07:01:10 nicm Exp $ */
d634 3
@


1.31
log
@Clean up by introducing a wrapper struct for mouse clicks rather than passing
three u_chars around.

As a side-effect this fixes incorrectly rejecting high cursor positions
(because it was comparing them as signed char), reported by Tom Doherty.
@
text
@d1 1
a1 1
/* $OpenBSD: window.c,v 1.30 2009/10/10 15:29:34 nicm Exp $ */
d428 4
d455 5
d633 6
d640 2
@


1.30
log
@Accept key and mouse input for keys in zombified windows if they are in a mode..
@
text
@d1 1
a1 1
/* $OpenBSD: window.c,v 1.29 2009/10/10 14:51:16 nicm Exp $ */
d656 1
a656 1
    struct window_pane *wp, struct client *c, u_char b, u_char x, u_char y)
d661 1
a661 3
	/* XXX convert from 1-based? */

	if (x < wp->xoff || x >= wp->xoff + wp->sx)
d663 1
a663 1
	if (y < wp->yoff || y >= wp->yoff + wp->sy)
d665 2
a666 2
	x -= wp->xoff;
	y -= wp->yoff;
d670 1
a670 1
			wp->mode->mouse(wp, c, b, x, y);
d672 1
a672 1
		input_mouse(wp, b, x, y);
@


1.29
log
@New option, mouse-select-pane. If on, the mouse may be used to select the
current pane.

Suggested by sthen@@ and also by someone else ages ago who I have forgotten.
@
text
@d1 1
a1 1
/* $OpenBSD: window.c,v 1.28 2009/10/10 10:02:48 nicm Exp $ */
d632 1
a632 1
	if (wp->fd == -1 || !window_pane_visible(wp))
d639 1
a639 1
	} 
d641 2
d658 1
a658 1
	if (wp->fd == -1 || !window_pane_visible(wp))
d673 1
a673 1
	} else
@


1.28
log
@Add "grouped sessions" which have independent name, options, current window and
so on but where the linked windows are synchronized (ie creating, killing
windows and so on are mirrored between the sessions). A grouped session may be
created by passing -t to new-session.

Had this around for a while, tested by a couple of people.
@
text
@d1 1
a1 1
/* $OpenBSD: window.c,v 1.27 2009/10/09 07:27:00 nicm Exp $ */
d304 17
@


1.27
log
@Add a simple synchronize-panes window option: when set, all input to any pane
that is part of the window is also sent to all other panes in the same
window. Suggested by several, most recently Tomasz Pajor.
@
text
@d1 1
a1 1
/* $OpenBSD: window.c,v 1.26 2009/09/20 14:58:12 nicm Exp $ */
d177 1
a177 1
	SLIST_INSERT_HEAD(stack, wl, sentry);
d187 2
a188 2

	SLIST_FOREACH(wl2, stack, sentry) {
d190 1
a190 1
			SLIST_REMOVE(stack, wl, winlink, sentry);
@


1.26
log
@Regularise some fatal messages.
@
text
@d1 1
a1 1
/* $OpenBSD: window.c,v 1.25 2009/09/16 12:35:04 nicm Exp $ */
d613 2
d621 12
a632 2
	} else
		input_key(wp, key);
@


1.25
log
@Rather than constructing an entire termios struct from ttydefaults.h, just let
forkpty do it and then alter the bits that should be changed after fork. A
little neater and more portable.
@
text
@d1 1
a1 1
/* $OpenBSD: window.c,v 1.24 2009/09/01 14:40:33 nicm Exp $ */
d483 1
a483 1
		fatal("gettimeofday");
@


1.24
log
@If forking a login shell or if SHELL is otherwise not useful, set it to the
default shell. Based on a diff from martynas@@.
@
text
@d1 1
a1 1
/* $OpenBSD: window.c,v 1.23 2009/09/01 13:09:50 nicm Exp $ */
d457 1
d488 1
a488 1
 	switch (wp->pid = forkpty(&wp->fd, wp->tty, tio, &ws)) {
d496 8
@


1.23
log
@When using tmux as a login shell, there is currently no way to specify a shell
to be used as a login shell inside tmux, so add a default-shell session option.
This sets the shell invoked as a login shell when the default-command option is
empty.

The default option value is whichever of $SHELL, getpwuid(getuid())'s pw_shell
or /bin/sh is valid first.

Based on a diff from martynas@@, changed by me to be a session option rather
than a window option.
@
text
@d1 1
a1 1
/* $OpenBSD: window.c,v 1.22 2009/08/13 20:11:58 nicm Exp $ */
d515 5
d530 1
@


1.22
log
@Add a base-index session option to specify the first index checked when looking
for an index for a new window.
@
text
@d1 1
a1 1
/* $OpenBSD: window.c,v 1.21 2009/08/13 19:04:00 nicm Exp $ */
a60 32
const char *
window_default_command(void)
{
	const char	*shell, *ptr;
	char		*progname;
	struct passwd	*pw;

	shell = getenv("SHELL");
	if (shell != NULL && *shell != '\0')
		goto found;

	pw = getpwuid(getuid());
	if (pw != NULL && pw->pw_shell != NULL && *pw->pw_shell != '\0') {
		shell = pw->pw_shell;
		goto found;
	}

	return (_PATH_BSHELL);

found:
	if ((ptr = strrchr(shell, '/')) != NULL)
		ptr++;
	else
		ptr = shell;
	progname = __progname;
	if (*progname == '-')
		progname++;
	if (strcmp(ptr, progname) == 0)
		return (_PATH_BSHELL);
	return (shell);
}

d241 3
a243 3
window_create(const char *name, const char *cmd, const char *cwd,
    struct environ *env, struct termios *tio, u_int sx, u_int sy, u_int hlimit,
    char **cause)
d251 1
a251 1
	if (window_pane_spawn(wp, cmd, cwd, env, tio, cause) != 0) {
d394 1
d439 2
d447 1
a447 1
window_pane_spawn(struct window_pane *wp, const char *cmd,
d466 5
d520 2
a521 2
		cmd = window_default_command();
		if ((ptr = strrchr(cmd, '/')) != NULL && *(ptr + 1) != '\0')
d524 2
a525 2
			xasprintf(&argv0, "-%s", cmd);
		execl(cmd, argv0, (char *) NULL);
@


1.21
log
@When creating a new session from the command-line where there is an external
terminal, copy the termios(4) special characters and use them for new windows
created in the new session. Suggested by Theo.
@
text
@d1 1
a1 1
/* $OpenBSD: window.c,v 1.20 2009/08/12 09:14:25 nicm Exp $ */
d125 1
a125 1
winlink_next_index(struct winlinks *wwl)
d127 1
a127 1
	u_int	i;
d129 2
a130 1
	for (i = 0; i < INT_MAX; i++) {
d133 6
a138 3
	}

	fatalx("no free indexes");
d159 4
a162 3
	if (idx == -1)
		idx = winlink_next_index(wwl);
	else if (winlink_find_by_index(wwl, idx) != NULL)
a163 3

	if (idx < 0)
		fatalx("bad index");
@


1.20
log
@When started as the shell, __progname contains a leading -, so hardcode "tmux"
for socket path and log files, and strip it when working out the shell.
@
text
@d1 1
a1 1
/* $OpenBSD: window.c,v 1.19 2009/08/11 21:28:11 nicm Exp $ */
d272 2
a273 1
    struct environ *env, u_int sx, u_int sy, u_int hlimit, char **cause)
d281 1
a281 1
	if (window_pane_spawn(wp, cmd, cwd, env, cause) != 0) {
d474 2
a475 2
window_pane_spawn(struct window_pane *wp,
    const char *cmd, const char *cwd, struct environ *env, char **cause)
d509 1
a509 1
 	switch (wp->pid = forkpty(&wp->fd, wp->tty, NULL, &ws)) {
@


1.19
log
@Have the client pass its stdin fd to the server when identifying itself and
have the server use that rather than reopening the tty. If the fd isn't given,
use the old behaviour (so no need for a version change).

This allows tmux to be used as the shell, so also change so that when working
out the command to execute if default-command is empty (the default), tmux will
try not execute itself.
@
text
@d1 1
a1 1
/* $OpenBSD: window.c,v 1.18 2009/08/08 21:52:43 nicm Exp $ */
d65 1
d85 4
a88 1
	if (strcmp(ptr, __progname) == 0)
@


1.18
log
@Infrastructure and commands to manage the environment for processes started
within tmux.

There is a global environment, copied from the external environment when the
server is started and each sesssion has an (initially empty) session
environment which overrides it.

New commands set-environment and show-environment manipulate or display the
environments.

A new session option, update-environment, is a space-separated list of
variables which are updated from the external environment into the session
environment every time a new session is created - the default is DISPLAY.
@
text
@d1 1
a1 1
/* $OpenBSD: window.c,v 1.17 2009/07/28 06:48:44 nicm Exp $ */
d64 1
a64 1
	const char	*shell;
d69 1
a69 1
		return (shell);
d72 4
a75 2
	if (pw != NULL && pw->pw_shell != NULL && *pw->pw_shell != '\0')
		return (pw->pw_shell);
d78 9
@


1.17
log
@If select-layout is not given an argument, repply the last layout used in the
window, if any.
@
text
@d1 1
a1 1
/* $OpenBSD: window.c,v 1.16 2009/07/22 21:34:36 nicm Exp $ */
d257 1
a257 1
    const char **envp, u_int sx, u_int sy, u_int hlimit, char **cause)
d265 1
a265 1
	if (window_pane_spawn(wp, cmd, cwd, envp, cause) != 0) {
d459 1
a459 1
    const char *cmd, const char *cwd, const char **envp, char **cause)
d461 8
a468 5
	struct winsize	 ws;
	int		 mode;
	const char     **envq, *ptr;
	char		*argv0;
	struct timeval	 tv;
d501 10
a510 3
		for (envq = envp; *envq != NULL; envq++) {
			if (putenv(xstrdup(*envq)) != 0)
				fatal("putenv failed");
d512 5
@


1.16
log
@window_add_pane cannot fail, so remove the unused cause argument and don't
bother to check for a NULL return.
@
text
@d1 1
a1 1
/* $OpenBSD: window.c,v 1.15 2009/07/21 19:54:22 nicm Exp $ */
d234 1
a234 1
	w->layout = 0;
@


1.15
log
@Make some functions which return unused values void (mostly found by lint) and
tweak a redundant expression in window_pane_set_mode.
@
text
@d1 1
a1 1
/* $OpenBSD: window.c,v 1.14 2009/07/19 13:21:40 nicm Exp $ */
d263 1
a263 4
	if ((wp = window_add_pane(w, hlimit, cause)) == NULL) {
		window_destroy(w);
		return (NULL);
	}
d322 1
a322 1
window_add_pane(struct window *w, u_int hlimit, unused char **cause)
@


1.14
log
@Improved layout code.

Each window now has a tree of layout cells associated with it. In this tree,
each node is either a horizontal or vertical cell containing a list of other
cells running from left-to-right or top-to-bottom, or a leaf cell which is
associated with a pane.

The major functional changes are:

- panes may now be split arbitrarily both horizontally (splitw -h, C-b %) and
  vertically (splitw -v, C-b ");
- panes may be resized both horizontally and vertically (resizep -L/-R/-U/-D,
  bound to C-b left/right/up/down and C-b M-left/right/up/down);
- layouts are now applied and then may be modified by resizing or splitting
  panes, rather than being fixed and reapplied when the window is resized or
  panes are added;
- manual-vertical layout is no longer necessary, and active-only layout is gone
  (but may return in future);
- the main-pane layouts now reduce the size of the main pane to fit all panes
  if possible.

Thanks to all who tested.
@
text
@d1 1
a1 1
/* $OpenBSD: window.c,v 1.13 2009/07/17 18:45:08 nicm Exp $ */
d304 1
a304 1
int
a308 2

	return (0);
d533 1
a533 1
int
d539 1
a539 1
		return (-1);
a552 1
	return (0);
d560 1
a560 1
	if (wp->mode != NULL || wp->mode == mode)
a561 1

@


1.13
log
@- New command display-message (alias display) to display a message in the
  status line (bound to "i" and displays the current window and time by
  default). The same substitutions are applied as for status-left/right.
- Add support for including the window index (#I), pane index (#P) and window
  name (#W) in the message, and status-left or status-right.
- Bump protocol version.

From Tiago Cunha, thanks!
@
text
@d1 1
a1 1
/* $OpenBSD: window.c,v 1.12 2009/07/15 08:00:49 nicm Exp $ */
d38 1
a38 1
 * Each window is attached to one or two panes, each of which is a pty. This
d233 1
d235 2
a236 1

d259 2
a260 1
	struct window	*w;
d263 6
a268 1
	if (window_add_pane(w, -1, cmd, cwd, envp, hlimit, cause) == NULL) {
a272 1

d292 3
a316 1

d327 1
a327 2
window_add_pane(struct window *w, int wanty, const char *cmd,
    const char *cwd, const char **envp, u_int hlimit, char **cause)
a329 1
	u_int			 sizey;
d331 1
a331 21
	if (TAILQ_EMPTY(&w->panes))
		wanty = w->sy;
	else {
		sizey = w->active->sy - 1; /* for separator */
		if (sizey < PANE_MINIMUM * 2) {
			*cause = xstrdup("pane too small");
			return (NULL);
		}

  		if (wanty == -1)
			wanty = sizey / 2;

		if (wanty < PANE_MINIMUM)
			wanty = PANE_MINIMUM;
		if ((u_int) wanty > sizey - PANE_MINIMUM)
			wanty = sizey - PANE_MINIMUM;

		window_pane_resize(w->active, w->sx, sizey - wanty);
	}

	wp = window_pane_create(w, w->sx, wanty, hlimit);
a335 4
	if (window_pane_spawn(wp, cmd, cwd, envp, cause) != 0) {
		window_remove_pane(w, wp);
		return (NULL);
	}
d420 2
@


1.12
log
@The man page says that kill-window removes the window entirely, unlinking it
from any sessions. In fact the implementation only affected the current
session, making it the same as unlink-window but destroying the window if it
was linked into only one session (unlinkw gives an error). Change the behaviour
to match what it documented and was originally intended.
@
text
@d1 1
a1 1
/* $OpenBSD: window.c,v 1.11 2009/07/14 16:52:50 nicm Exp $ */
d380 15
@


1.11
log
@Don't accept input to a window if it not visible.
@
text
@d1 1
a1 1
/* $OpenBSD: window.c,v 1.10 2009/07/14 07:23:36 nicm Exp $ */
d82 13
@


1.10
log
@Get rid of the PANE_HIDDEN flag in favour of a function, and moving the
decision for whether or not a pane should be drawn out of the layout code and
into the redraw code.

This is needed for the new layout design, getting it in now to make that easier
to work on.
@
text
@d1 1
a1 1
/* $OpenBSD: window.c,v 1.9 2009/07/13 10:43:52 nicm Exp $ */
d583 1
a583 1
 	if (wp->fd == -1)
d597 1
a597 1
 	if (wp->fd == -1)
@


1.9
log
@Support "alternate screen" mode (terminfo smcup/rmcup) typically used by full
screen interactive programs to preserve the screen contents. When activated, it
saves a copy of the visible grid and disables scrolling into and resizing out
of the history; when deactivated the visible data is restored and the history
reenabled.
@
text
@d1 1
a1 1
/* $OpenBSD: window.c,v 1.8 2009/07/08 05:26:45 nicm Exp $ */
d294 2
a295 1
	while (w->active->flags & PANE_HIDDEN)
d297 5
d614 12
@


1.8
log
@Just appending -l to $SHELL to create a login shell is wrong: -l is not POSIX,
and some people may use shells which do not support it. Instead, make an empty
default-command option mean a login shell, and fork it with a - in argv[0]
which is the method used by login(1).

Also fix the automatic-rename code to handle this correctly and to strip a
leading - if present.
@
text
@d1 1
a1 1
/* $OpenBSD: window.c,v 1.7 2009/07/07 19:49:19 nicm Exp $ */
d410 2
d430 2
@


1.7
log
@Rename the global options variables to be shorter and to make session options
clear. No functional change, getting this out of the way to make later options
changes easier.
@
text
@d1 1
a1 1
/* $OpenBSD: window.c,v 1.6 2009/06/25 06:15:04 nicm Exp $ */
d26 1
d61 17
d445 2
a446 1
	const char     **envq;
d487 12
a498 1
		execl(_PATH_BSHELL, "sh", "-c", wp->cmd, (char *) NULL);
@


1.6
log
@Miscellaneous unused functions, including one which was basically a
duplicate. Found by lint.
@
text
@d1 1
a1 1
/* $OpenBSD: window.c,v 1.5 2009/06/24 22:49:56 nicm Exp $ */
d207 1
a207 1
	options_init(&w->options, &global_window_options);
@


1.5
log
@Change find-window and monitor-content to use fnmatch(3). For convenience and
compatibility, *s are implicitly added at the start and end of the pattern.

Also display the line number and the entire line in the results, and lose the
nasty section_string function and the now empty util.c file.

Initially from Tiago Cunha.
@
text
@d1 1
a1 1
/* $OpenBSD: window.c,v 1.4 2009/06/24 22:04:18 nicm Exp $ */
a327 15
}

u_int
window_index_of_pane(struct window *w, struct window_pane *find)
{
	struct window_pane	*wp;
	u_int			 n;

	n = 0;
	TAILQ_FOREACH(wp, &w->panes, entry) {
		if (wp == find)
			return (n);
		n++;
	}
	fatalx("unknown pane");
@


1.4
log
@Add a dedicated function to convert a line into a string and use it to simplify the search window function.
@
text
@d1 1
a1 1
/* $OpenBSD: window.c,v 1.3 2009/06/23 20:17:30 nicm Exp $ */
d24 1
d592 1
a592 1
window_pane_search(struct window_pane *wp, const char *searchstr)
d595 1
a595 1
	char		*line, *ptr;
d598 3
a600 1
	ptr = NULL;
d603 6
a608 3
		log_debug("XXX %s", line);
		if ((ptr = strstr(line, searchstr)) != NULL)
			break;		
d611 3
a613 5
	if (ptr != NULL) {
		ptr = section_string(line, strlen(ptr), ptr - line, 40);
		xfree(line);
	}
	return (ptr);
@


1.3
log
@If a pane is "zombified" (remain-on-exit flag), don't continue to queue key and
mouse input for it (otherwise they are processed after respawn).
@
text
@d1 1
a1 1
/* $OpenBSD: window.c,v 1.2 2009/06/05 07:18:37 nicm Exp $ */
d593 15
a607 34
	const struct grid_cell	*gc;
	const struct grid_utf8	*gu;
	char			*buf, *s;
	size_t	 		 off;
	u_int	 		 i, j, k;

	buf = xmalloc(1);

	for (j = 0; j < screen_size_y(&wp->base); j++) {
		off = 0;
		for (i = 0; i < screen_size_x(&wp->base); i++) {
			gc = grid_view_peek_cell(wp->base.grid, i, j);
			if (gc->flags & GRID_FLAG_UTF8) {
				gu = grid_view_peek_utf8(wp->base.grid, i, j);
				buf = xrealloc(buf, 1, off + 8);
				for (k = 0; k < UTF8_SIZE; k++) {
					if (gu->data[k] == 0xff)
						break;
					buf[off++] = gu->data[k];
				}
			} else {
				buf = xrealloc(buf, 1, off + 1);
				buf[off++] = gc->data;
			}
		}
		while (off > 0 && buf[off - 1] == ' ')
			off--;
		buf[off] = '\0';

		if ((s = strstr(buf, searchstr)) != NULL) {
			s = section_string(buf, off, s - buf, 40);
			xfree(buf);
			return (s);
		}
d609 1
a609 3

	xfree(buf);
	return (NULL);
@


1.2
log
@strdup the input to putenv to avoid in one case passing a string that is later
freed and in the other const strings.

looks sane to millert, ok ray
@
text
@d1 1
a1 1
/* $OpenBSD: window.c,v 1.1 2009/06/01 22:58:49 nicm Exp $ */
d557 3
d571 3
@


1.1
log
@Import tmux, a terminal multiplexor allowing (among other things) a single
terminal to be switched between several different windows and programs
displayed on one terminal be detached from one terminal and moved to another.

ok deraadt pirofti
@
text
@d1 1
a1 1
/* $OpenBSD$ */
d476 1
a476 1
			if (putenv((char *) *envq) != 0)
@

