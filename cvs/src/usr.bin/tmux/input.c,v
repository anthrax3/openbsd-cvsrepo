head	1.122;
access;
symbols
	OPENBSD_6_1:1.118.0.4
	OPENBSD_6_1_BASE:1.118
	OPENBSD_6_0:1.102.0.2
	OPENBSD_6_0_BASE:1.102
	OPENBSD_5_9:1.100.0.2
	OPENBSD_5_9_BASE:1.100
	OPENBSD_5_8:1.80.0.4
	OPENBSD_5_8_BASE:1.80
	OPENBSD_5_7:1.72.0.2
	OPENBSD_5_7_BASE:1.72
	OPENBSD_5_6:1.69.0.4
	OPENBSD_5_6_BASE:1.69
	OPENBSD_5_5:1.65.0.4
	OPENBSD_5_5_BASE:1.65
	OPENBSD_5_4:1.63.0.2
	OPENBSD_5_4_BASE:1.63
	OPENBSD_5_3:1.58.0.2
	OPENBSD_5_3_BASE:1.58
	OPENBSD_5_2:1.53.0.2
	OPENBSD_5_2_BASE:1.53
	OPENBSD_5_1_BASE:1.48
	OPENBSD_5_1:1.48.0.2
	OPENBSD_5_0:1.40.0.2
	OPENBSD_5_0_BASE:1.40
	OPENBSD_4_9:1.35.0.2
	OPENBSD_4_9_BASE:1.35
	OPENBSD_4_8:1.29.0.2
	OPENBSD_4_8_BASE:1.29
	OPENBSD_4_7:1.27.0.2
	OPENBSD_4_7_BASE:1.27
	OPENBSD_4_6:1.8.0.4
	OPENBSD_4_6_BASE:1.8;
locks; strict;
comment	@ * @;


1.122
date	2017.05.28.23.23.40;	author nicm;	state Exp;
branches;
next	1.121;
commitid	d9vWy3VqWO1fwvIC;

1.121
date	2017.05.12.13.00.56;	author nicm;	state Exp;
branches;
next	1.120;
commitid	1bIKLBYAOfKIM4e4;

1.120
date	2017.05.12.10.50.11;	author nicm;	state Exp;
branches;
next	1.119;
commitid	NrV8qEjGzQCLtssv;

1.119
date	2017.04.22.08.33.28;	author nicm;	state Exp;
branches;
next	1.118;
commitid	r5ToPxEnU3NlzzYz;

1.118
date	2017.03.22.07.16.54;	author nicm;	state Exp;
branches;
next	1.117;
commitid	YlKgZy2nlCejSvNQ;

1.117
date	2017.02.19.07.55.11;	author nicm;	state Exp;
branches;
next	1.116;
commitid	mglLE5UIZSOzYvzn;

1.116
date	2017.02.16.12.56.01;	author nicm;	state Exp;
branches;
next	1.115;
commitid	DHL5GKmdVY8CDJYy;

1.115
date	2017.02.08.17.31.09;	author nicm;	state Exp;
branches;
next	1.114;
commitid	AzNCw8YfPlNCzX1E;

1.114
date	2017.02.08.16.45.18;	author nicm;	state Exp;
branches;
next	1.113;
commitid	ZNCPaF6tGzHeJGxd;

1.113
date	2017.02.08.15.49.29;	author nicm;	state Exp;
branches;
next	1.112;
commitid	9p1dhEKzsTLyX59I;

1.112
date	2017.02.06.22.05.11;	author nicm;	state Exp;
branches;
next	1.111;
commitid	EudrDiTB8CsH17qW;

1.111
date	2017.02.06.19.26.49;	author nicm;	state Exp;
branches;
next	1.110;
commitid	Rhdtq12XKh2I54nR;

1.110
date	2017.02.06.13.25.15;	author nicm;	state Exp;
branches;
next	1.109;
commitid	hjsr5Yv2X0ytLH8Y;

1.109
date	2017.02.01.09.55.07;	author nicm;	state Exp;
branches;
next	1.108;
commitid	FpFenXzt7GohJ3lb;

1.108
date	2017.01.22.19.00.01;	author nicm;	state Exp;
branches;
next	1.107;
commitid	bd6MzhLA4vwFqJy3;

1.107
date	2017.01.07.15.28.13;	author nicm;	state Exp;
branches;
next	1.106;
commitid	llgkTzvAhxXuSWDB;

1.106
date	2016.12.09.21.39.27;	author nicm;	state Exp;
branches;
next	1.105;
commitid	bj3djzEC5gw7ET61;

1.105
date	2016.10.13.20.27.27;	author nicm;	state Exp;
branches;
next	1.104;
commitid	txCyQ5BkKJtZRzfT;

1.104
date	2016.10.03.22.52.11;	author nicm;	state Exp;
branches;
next	1.103;
commitid	brRovAmeQVyBbZ4S;

1.103
date	2016.09.28.14.40.07;	author nicm;	state Exp;
branches;
next	1.102;
commitid	7T1ym5uQRUPhCpw8;

1.102
date	2016.07.15.00.42.56;	author nicm;	state Exp;
branches;
next	1.101;
commitid	EramuEV0ciOaJqkF;

1.101
date	2016.03.02.15.36.02;	author nicm;	state Exp;
branches;
next	1.100;
commitid	NiBVKnSIZN4ztNWB;

1.100
date	2016.01.29.11.13.56;	author nicm;	state Exp;
branches;
next	1.99;
commitid	Rew2ppunRTmAT23L;

1.99
date	2016.01.19.15.59.12;	author nicm;	state Exp;
branches;
next	1.98;
commitid	P3qmSOx6KrDBsb0c;

1.98
date	2016.01.15.11.31.47;	author nicm;	state Exp;
branches;
next	1.97;
commitid	tQD3qrBCJTPkSPCm;

1.97
date	2015.12.16.22.05.35;	author nicm;	state Exp;
branches;
next	1.96;
commitid	6LxvgMFtrwxMsdPn;

1.96
date	2015.11.23.23.47.57;	author nicm;	state Exp;
branches;
next	1.95;
commitid	il6j3tv774whObqw;

1.95
date	2015.11.23.20.53.09;	author nicm;	state Exp;
branches;
next	1.94;
commitid	erDJx2JIDZWB55Vj;

1.94
date	2015.11.18.13.06.54;	author nicm;	state Exp;
branches;
next	1.93;
commitid	xAU2oIxJB0E2UZoZ;

1.93
date	2015.11.14.12.20.19;	author nicm;	state Exp;
branches;
next	1.92;
commitid	PMRQ9uLAjZPSdZnj;

1.92
date	2015.11.14.11.45.43;	author nicm;	state Exp;
branches;
next	1.91;
commitid	gUJFVlXRAaRAnDSU;

1.91
date	2015.11.14.10.56.31;	author nicm;	state Exp;
branches;
next	1.90;
commitid	7oTEXFUYU5F7v5X1;

1.90
date	2015.11.14.08.25.12;	author nicm;	state Exp;
branches;
next	1.89;
commitid	wKJKTi4ptgzXqkHn;

1.89
date	2015.11.13.08.09.28;	author nicm;	state Exp;
branches;
next	1.88;
commitid	3vFd8TIqn7NVGuk0;

1.88
date	2015.11.12.11.09.11;	author nicm;	state Exp;
branches;
next	1.87;
commitid	tEN3cHiOuN3KscbT;

1.87
date	2015.10.27.15.58.42;	author nicm;	state Exp;
branches;
next	1.86;
commitid	89xhQafU35Q5MQVC;

1.86
date	2015.09.02.17.52.57;	author nicm;	state Exp;
branches;
next	1.85;
commitid	njUaDvP1w7ShITLz;

1.85
date	2015.09.01.19.50.09;	author nicm;	state Exp;
branches;
next	1.84;
commitid	qHFBNmcomtnWOK72;

1.84
date	2015.09.01.19.16.00;	author nicm;	state Exp;
branches;
next	1.83;
commitid	RkxeJoMQJwPnhuzy;

1.83
date	2015.08.29.08.30.54;	author nicm;	state Exp;
branches;
next	1.82;
commitid	RrlCW4OYH7he0yBf;

1.82
date	2015.08.28.07.49.24;	author nicm;	state Exp;
branches;
next	1.81;
commitid	0EjAW6v3xnwJqHbL;

1.81
date	2015.08.25.15.00.05;	author nicm;	state Exp;
branches;
next	1.80;
commitid	iFn1a0VURoLJXV3E;

1.80
date	2015.07.13.18.45.18;	author nicm;	state Exp;
branches;
next	1.79;
commitid	043ZGxAN6XVTQhI0;

1.79
date	2015.06.15.10.58.01;	author nicm;	state Exp;
branches;
next	1.78;
commitid	HBSnpNJTrYXYaYTN;

1.78
date	2015.06.05.22.33.39;	author nicm;	state Exp;
branches;
next	1.77;
commitid	bhwpTfoxc2Bk5WKg;

1.77
date	2015.06.04.09.42.29;	author nicm;	state Exp;
branches;
next	1.76;
commitid	3PudyeQlB56tK98d;

1.76
date	2015.06.01.13.59.57;	author nicm;	state Exp;
branches;
next	1.75;
commitid	h4qYzUzQuo1MOeOZ;

1.75
date	2015.05.11.10.10.16;	author nicm;	state Exp;
branches;
next	1.74;
commitid	yarRVqbIkdPvB3jr;

1.74
date	2015.05.08.16.18.04;	author nicm;	state Exp;
branches;
next	1.73;
commitid	jGuK9ADiqvyOz7AE;

1.73
date	2015.03.31.17.45.10;	author nicm;	state Exp;
branches;
next	1.72;
commitid	2uQloBaX92ri1PyE;

1.72
date	2015.01.20.08.18.04;	author nicm;	state Exp;
branches;
next	1.71;
commitid	rWJzz3mLtR2DyuLJ;

1.71
date	2014.10.08.17.35.58;	author nicm;	state Exp;
branches;
next	1.70;
commitid	mK8z9uVwDZMfiNoM;

1.70
date	2014.08.09.07.33.37;	author nicm;	state Exp;
branches;
next	1.69;
commitid	EaH1ezsTMWHeIyGh;

1.69
date	2014.06.06.13.21.41;	author nicm;	state Exp;
branches;
next	1.68;
commitid	n10vUmd4HT5z6ANF;

1.68
date	2014.06.05.22.14.29;	author nicm;	state Exp;
branches;
next	1.67;
commitid	XzlpCYVOCrD8k1IS;

1.67
date	2014.04.17.12.43.38;	author nicm;	state Exp;
branches;
next	1.66;

1.66
date	2014.03.31.21.32.00;	author nicm;	state Exp;
branches;
next	1.65;

1.65
date	2014.01.31.11.17.20;	author nicm;	state Exp;
branches;
next	1.64;

1.64
date	2013.10.10.11.57.14;	author nicm;	state Exp;
branches;
next	1.63;

1.63
date	2013.06.23.12.51.28;	author nicm;	state Exp;
branches;
next	1.62;

1.62
date	2013.03.24.09.18.16;	author nicm;	state Exp;
branches;
next	1.61;

1.61
date	2013.03.22.10.36.53;	author nicm;	state Exp;
branches;
next	1.60;

1.60
date	2013.03.22.10.33.50;	author nicm;	state Exp;
branches;
next	1.59;

1.59
date	2013.03.21.18.47.56;	author nicm;	state Exp;
branches;
next	1.58;

1.58
date	2013.01.18.02.16.21;	author nicm;	state Exp;
branches;
next	1.57;

1.57
date	2013.01.17.20.30.43;	author nicm;	state Exp;
branches;
next	1.56;

1.56
date	2013.01.15.23.18.55;	author nicm;	state Exp;
branches;
next	1.55;

1.55
date	2012.11.27.20.08.42;	author nicm;	state Exp;
branches;
next	1.54;

1.54
date	2012.09.25.07.41.22;	author nicm;	state Exp;
branches;
next	1.53;

1.53
date	2012.07.10.11.53.01;	author nicm;	state Exp;
branches;
next	1.52;

1.52
date	2012.04.25.21.12.49;	author nicm;	state Exp;
branches;
next	1.51;

1.51
date	2012.03.20.11.01.00;	author nicm;	state Exp;
branches;
next	1.50;

1.50
date	2012.03.15.10.05.49;	author nicm;	state Exp;
branches;
next	1.49;

1.49
date	2012.03.03.09.43.22;	author nicm;	state Exp;
branches;
next	1.48;

1.48
date	2012.02.02.00.10.12;	author nicm;	state Exp;
branches;
next	1.47;

1.47
date	2012.01.21.08.23.12;	author nicm;	state Exp;
branches;
next	1.46;

1.46
date	2012.01.21.08.12.03;	author nicm;	state Exp;
branches;
next	1.45;

1.45
date	2012.01.21.08.10.21;	author nicm;	state Exp;
branches;
next	1.44;

1.44
date	2012.01.20.19.15.40;	author nicm;	state Exp;
branches;
next	1.43;

1.43
date	2011.12.29.08.06.24;	author nicm;	state Exp;
branches;
next	1.42;

1.42
date	2011.12.27.14.06.19;	author nicm;	state Exp;
branches;
next	1.41;

1.41
date	2011.10.23.10.16.14;	author nicm;	state Exp;
branches;
next	1.40;

1.40
date	2011.07.08.06.28.05;	author nicm;	state Exp;
branches;
next	1.39;

1.39
date	2011.05.20.19.17.39;	author nicm;	state Exp;
branches;
next	1.38;

1.38
date	2011.05.20.19.03.58;	author nicm;	state Exp;
branches;
next	1.37;

1.37
date	2011.03.07.23.46.27;	author nicm;	state Exp;
branches;
next	1.36;

1.36
date	2011.03.03.08.53.14;	author nicm;	state Exp;
branches;
next	1.35;

1.35
date	2011.01.28.20.39.22;	author nicm;	state Exp;
branches;
next	1.34;

1.34
date	2011.01.15.00.16.00;	author nicm;	state Exp;
branches;
next	1.33;

1.33
date	2011.01.03.23.35.21;	author nicm;	state Exp;
branches;
next	1.32;

1.32
date	2010.12.29.21.49.06;	author nicm;	state Exp;
branches;
next	1.31;

1.31
date	2010.12.23.20.18.39;	author nicm;	state Exp;
branches;
next	1.30;

1.30
date	2010.12.06.22.51.02;	author nicm;	state Exp;
branches;
next	1.29;

1.29
date	2010.04.17.23.31.09;	author nicm;	state Exp;
branches;
next	1.28;

1.28
date	2010.03.22.19.02.54;	author nicm;	state Exp;
branches;
next	1.27;

1.27
date	2010.02.08.00.14.38;	author nicm;	state Exp;
branches;
next	1.26;

1.26
date	2010.01.06.23.13.52;	author nicm;	state Exp;
branches;
next	1.25;

1.25
date	2009.12.14.21.33.38;	author nicm;	state Exp;
branches;
next	1.24;

1.24
date	2009.12.03.22.50.10;	author nicm;	state Exp;
branches;
next	1.23;

1.23
date	2009.11.27.09.41.03;	author nicm;	state Exp;
branches;
next	1.22;

1.22
date	2009.11.04.22.43.11;	author nicm;	state Exp;
branches;
next	1.21;

1.21
date	2009.10.26.21.42.04;	author deraadt;	state Exp;
branches;
next	1.20;

1.20
date	2009.10.23.15.48.39;	author nicm;	state Exp;
branches;
next	1.19;

1.19
date	2009.10.20.22.17.33;	author nicm;	state Exp;
branches;
next	1.18;

1.18
date	2009.10.20.19.18.28;	author nicm;	state Exp;
branches;
next	1.17;

1.17
date	2009.10.13.15.23.13;	author nicm;	state Exp;
branches;
next	1.16;

1.16
date	2009.10.12.16.59.55;	author nicm;	state Exp;
branches;
next	1.15;

1.15
date	2009.08.20.10.48.25;	author nicm;	state Exp;
branches;
next	1.14;

1.14
date	2009.08.19.17.00.31;	author nicm;	state Exp;
branches;
next	1.13;

1.13
date	2009.08.18.21.41.13;	author nicm;	state Exp;
branches;
next	1.12;

1.12
date	2009.08.08.15.57.49;	author nicm;	state Exp;
branches;
next	1.11;

1.11
date	2009.08.07.00.12.13;	author nicm;	state Exp;
branches;
next	1.10;

1.10
date	2009.07.21.19.54.22;	author nicm;	state Exp;
branches;
next	1.9;

1.9
date	2009.07.13.10.43.52;	author nicm;	state Exp;
branches;
next	1.8;

1.8
date	2009.06.04.21.02.21;	author nicm;	state Exp;
branches;
next	1.7;

1.7
date	2009.06.04.18.48.24;	author nicm;	state Exp;
branches;
next	1.6;

1.6
date	2009.06.04.14.42.14;	author nicm;	state Exp;
branches;
next	1.5;

1.5
date	2009.06.04.14.24.49;	author nicm;	state Exp;
branches;
next	1.4;

1.4
date	2009.06.04.14.15.50;	author nicm;	state Exp;
branches;
next	1.3;

1.3
date	2009.06.03.23.30.40;	author nicm;	state Exp;
branches;
next	1.2;

1.2
date	2009.06.03.19.33.04;	author nicm;	state Exp;
branches;
next	1.1;

1.1
date	2009.06.01.22.58.49;	author nicm;	state Exp;
branches;
next	;


desc
@@


1.122
log
@Support OSC 10 and 11 to set foreground and background colours, from
"bertnp" in GitHub issue 942.
@
text
@/* $OpenBSD: input.c,v 1.121 2017/05/12 13:00:56 nicm Exp $ */

/*
 * Copyright (c) 2007 Nicholas Marriott <nicholas.marriott@@gmail.com>
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF MIND, USE, DATA OR PROFITS, WHETHER
 * IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING
 * OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */

#include <sys/types.h>

#include <netinet/in.h>

#include <resolv.h>
#include <stdlib.h>
#include <string.h>
#include <time.h>

#include "tmux.h"

/*
 * Based on the description by Paul Williams at:
 *
 * http://vt100.net/emu/dec_ansi_parser
 *
 * With the following changes:
 *
 * - 7-bit only.
 *
 * - Support for UTF-8.
 *
 * - OSC (but not APC) may be terminated by \007 as well as ST.
 *
 * - A state for APC similar to OSC. Some terminals appear to use this to set
 *   the title.
 *
 * - A state for the screen \033k...\033\\ sequence to rename a window. This is
 *   pretty stupid but not supporting it is more trouble than it is worth.
 *
 * - Special handling for ESC inside a DCS to allow arbitrary byte sequences to
 *   be passed to the underlying terminals.
 */

/* Input parser cell. */
struct input_cell {
	struct grid_cell	cell;
	int			set;
	int			g0set;	/* 1 if ACS */
	int			g1set;	/* 1 if ACS */
};

/* Input parser context. */
struct input_ctx {
	struct window_pane     *wp;
	struct screen_write_ctx ctx;

	struct input_cell	cell;

	struct input_cell	old_cell;
	u_int 			old_cx;
	u_int			old_cy;

	u_char			interm_buf[4];
	size_t			interm_len;

	u_char			param_buf[64];
	size_t			param_len;

#define INPUT_BUF_START 32
#define INPUT_BUF_LIMIT 1048576
	u_char		       *input_buf;
	size_t			input_len;
	size_t			input_space;

	int			param_list[24];	/* -1 not present */
	u_int			param_list_len;

	struct utf8_data	utf8data;

	int			ch;

	int			flags;
#define INPUT_DISCARD 0x1

	const struct input_state *state;

	/*
	 * All input received since we were last in the ground state. Sent to
	 * control clients on connection.
	 */
	struct evbuffer	 	*since_ground;
};

/* Helper functions. */
struct input_transition;
static int	input_split(struct input_ctx *);
static int	input_get(struct input_ctx *, u_int, int, int);
static void printflike(2, 3) input_reply(struct input_ctx *, const char *, ...);
static void	input_set_state(struct window_pane *,
		    const struct input_transition *);
static void	input_reset_cell(struct input_ctx *);

static void	input_osc_4(struct window_pane *, const char *);
static void	input_osc_10(struct window_pane *, const char *);
static void	input_osc_11(struct window_pane *, const char *);
static void	input_osc_52(struct window_pane *, const char *);
static void	input_osc_104(struct window_pane *, const char *);

/* Transition entry/exit handlers. */
static void	input_clear(struct input_ctx *);
static void	input_ground(struct input_ctx *);
static void	input_enter_osc(struct input_ctx *);
static void	input_exit_osc(struct input_ctx *);
static void	input_enter_apc(struct input_ctx *);
static void	input_exit_apc(struct input_ctx *);
static void	input_enter_rename(struct input_ctx *);
static void	input_exit_rename(struct input_ctx *);

/* Input state handlers. */
static int	input_print(struct input_ctx *);
static int	input_intermediate(struct input_ctx *);
static int	input_parameter(struct input_ctx *);
static int	input_input(struct input_ctx *);
static int	input_c0_dispatch(struct input_ctx *);
static int	input_esc_dispatch(struct input_ctx *);
static int	input_csi_dispatch(struct input_ctx *);
static void	input_csi_dispatch_rm(struct input_ctx *);
static void	input_csi_dispatch_rm_private(struct input_ctx *);
static void	input_csi_dispatch_sm(struct input_ctx *);
static void	input_csi_dispatch_sm_private(struct input_ctx *);
static void	input_csi_dispatch_winops(struct input_ctx *);
static void	input_csi_dispatch_sgr_256(struct input_ctx *, int, u_int *);
static void	input_csi_dispatch_sgr_rgb(struct input_ctx *, int, u_int *);
static void	input_csi_dispatch_sgr(struct input_ctx *);
static int	input_dcs_dispatch(struct input_ctx *);
static int	input_utf8_open(struct input_ctx *);
static int	input_utf8_add(struct input_ctx *);
static int	input_utf8_close(struct input_ctx *);

/* Command table comparison function. */
static int	input_table_compare(const void *, const void *);

/* Command table entry. */
struct input_table_entry {
	int		ch;
	const char     *interm;
	int		type;
};

/* Escape commands. */
enum input_esc_type {
	INPUT_ESC_DECALN,
	INPUT_ESC_DECKPAM,
	INPUT_ESC_DECKPNM,
	INPUT_ESC_DECRC,
	INPUT_ESC_DECSC,
	INPUT_ESC_HTS,
	INPUT_ESC_IND,
	INPUT_ESC_NEL,
	INPUT_ESC_RI,
	INPUT_ESC_RIS,
	INPUT_ESC_SCSG0_OFF,
	INPUT_ESC_SCSG0_ON,
	INPUT_ESC_SCSG1_OFF,
	INPUT_ESC_SCSG1_ON,
	INPUT_ESC_ST,
};

/* Escape command table. */
static const struct input_table_entry input_esc_table[] = {
	{ '0', "(", INPUT_ESC_SCSG0_ON },
	{ '0', ")", INPUT_ESC_SCSG1_ON },
	{ '7', "",  INPUT_ESC_DECSC },
	{ '8', "",  INPUT_ESC_DECRC },
	{ '8', "#", INPUT_ESC_DECALN },
	{ '=', "",  INPUT_ESC_DECKPAM },
	{ '>', "",  INPUT_ESC_DECKPNM },
	{ 'B', "(", INPUT_ESC_SCSG0_OFF },
	{ 'B', ")", INPUT_ESC_SCSG1_OFF },
	{ 'D', "",  INPUT_ESC_IND },
	{ 'E', "",  INPUT_ESC_NEL },
	{ 'H', "",  INPUT_ESC_HTS },
	{ 'M', "",  INPUT_ESC_RI },
	{ '\\', "", INPUT_ESC_ST },
	{ 'c', "",  INPUT_ESC_RIS },
};

/* Control (CSI) commands. */
enum input_csi_type {
	INPUT_CSI_CBT,
	INPUT_CSI_CNL,
	INPUT_CSI_CPL,
	INPUT_CSI_CUB,
	INPUT_CSI_CUD,
	INPUT_CSI_CUF,
	INPUT_CSI_CUP,
	INPUT_CSI_CUU,
	INPUT_CSI_DA,
	INPUT_CSI_DA_TWO,
	INPUT_CSI_DCH,
	INPUT_CSI_DECSCUSR,
	INPUT_CSI_DECSTBM,
	INPUT_CSI_DL,
	INPUT_CSI_DSR,
	INPUT_CSI_ECH,
	INPUT_CSI_ED,
	INPUT_CSI_EL,
	INPUT_CSI_HPA,
	INPUT_CSI_ICH,
	INPUT_CSI_IL,
	INPUT_CSI_RCP,
	INPUT_CSI_RM,
	INPUT_CSI_RM_PRIVATE,
	INPUT_CSI_SCP,
	INPUT_CSI_SGR,
	INPUT_CSI_SM,
	INPUT_CSI_SM_PRIVATE,
	INPUT_CSI_SU,
	INPUT_CSI_TBC,
	INPUT_CSI_VPA,
	INPUT_CSI_WINOPS,
};

/* Control (CSI) command table. */
static const struct input_table_entry input_csi_table[] = {
	{ '@@', "",  INPUT_CSI_ICH },
	{ 'A', "",  INPUT_CSI_CUU },
	{ 'B', "",  INPUT_CSI_CUD },
	{ 'C', "",  INPUT_CSI_CUF },
	{ 'D', "",  INPUT_CSI_CUB },
	{ 'E', "",  INPUT_CSI_CNL },
	{ 'F', "",  INPUT_CSI_CPL },
	{ 'G', "",  INPUT_CSI_HPA },
	{ 'H', "",  INPUT_CSI_CUP },
	{ 'J', "",  INPUT_CSI_ED },
	{ 'K', "",  INPUT_CSI_EL },
	{ 'L', "",  INPUT_CSI_IL },
	{ 'M', "",  INPUT_CSI_DL },
	{ 'P', "",  INPUT_CSI_DCH },
	{ 'S', "",  INPUT_CSI_SU },
	{ 'X', "",  INPUT_CSI_ECH },
	{ 'Z', "",  INPUT_CSI_CBT },
	{ 'c', "",  INPUT_CSI_DA },
	{ 'c', ">", INPUT_CSI_DA_TWO },
	{ 'd', "",  INPUT_CSI_VPA },
	{ 'f', "",  INPUT_CSI_CUP },
	{ 'g', "",  INPUT_CSI_TBC },
	{ 'h', "",  INPUT_CSI_SM },
	{ 'h', "?", INPUT_CSI_SM_PRIVATE },
	{ 'l', "",  INPUT_CSI_RM },
	{ 'l', "?", INPUT_CSI_RM_PRIVATE },
	{ 'm', "",  INPUT_CSI_SGR },
	{ 'n', "",  INPUT_CSI_DSR },
	{ 'q', " ", INPUT_CSI_DECSCUSR },
	{ 'r', "",  INPUT_CSI_DECSTBM },
	{ 's', "",  INPUT_CSI_SCP },
	{ 't', "",  INPUT_CSI_WINOPS },
	{ 'u', "",  INPUT_CSI_RCP },
};

/* Input transition. */
struct input_transition {
	int				first;
	int				last;

	int				(*handler)(struct input_ctx *);
	const struct input_state       *state;
};

/* Input state. */
struct input_state {
	const char			*name;
	void				(*enter)(struct input_ctx *);
	void				(*exit)(struct input_ctx *);
	const struct input_transition	*transitions;
};

/* State transitions available from all states. */
#define INPUT_STATE_ANYWHERE \
	{ 0x18, 0x18, input_c0_dispatch, &input_state_ground }, \
	{ 0x1a, 0x1a, input_c0_dispatch, &input_state_ground }, \
	{ 0x1b, 0x1b, NULL,		 &input_state_esc_enter }

/* Forward declarations of state tables. */
static const struct input_transition input_state_ground_table[];
static const struct input_transition input_state_esc_enter_table[];
static const struct input_transition input_state_esc_intermediate_table[];
static const struct input_transition input_state_csi_enter_table[];
static const struct input_transition input_state_csi_parameter_table[];
static const struct input_transition input_state_csi_intermediate_table[];
static const struct input_transition input_state_csi_ignore_table[];
static const struct input_transition input_state_dcs_enter_table[];
static const struct input_transition input_state_dcs_parameter_table[];
static const struct input_transition input_state_dcs_intermediate_table[];
static const struct input_transition input_state_dcs_handler_table[];
static const struct input_transition input_state_dcs_escape_table[];
static const struct input_transition input_state_dcs_ignore_table[];
static const struct input_transition input_state_osc_string_table[];
static const struct input_transition input_state_apc_string_table[];
static const struct input_transition input_state_rename_string_table[];
static const struct input_transition input_state_consume_st_table[];
static const struct input_transition input_state_utf8_three_table[];
static const struct input_transition input_state_utf8_two_table[];
static const struct input_transition input_state_utf8_one_table[];

/* ground state definition. */
static const struct input_state input_state_ground = {
	"ground",
	input_ground, NULL,
	input_state_ground_table
};

/* esc_enter state definition. */
static const struct input_state input_state_esc_enter = {
	"esc_enter",
	input_clear, NULL,
	input_state_esc_enter_table
};

/* esc_intermediate state definition. */
static const struct input_state input_state_esc_intermediate = {
	"esc_intermediate",
	NULL, NULL,
	input_state_esc_intermediate_table
};

/* csi_enter state definition. */
static const struct input_state input_state_csi_enter = {
	"csi_enter",
	input_clear, NULL,
	input_state_csi_enter_table
};

/* csi_parameter state definition. */
static const struct input_state input_state_csi_parameter = {
	"csi_parameter",
	NULL, NULL,
	input_state_csi_parameter_table
};

/* csi_intermediate state definition. */
static const struct input_state input_state_csi_intermediate = {
	"csi_intermediate",
	NULL, NULL,
	input_state_csi_intermediate_table
};

/* csi_ignore state definition. */
static const struct input_state input_state_csi_ignore = {
	"csi_ignore",
	NULL, NULL,
	input_state_csi_ignore_table
};

/* dcs_enter state definition. */
static const struct input_state input_state_dcs_enter = {
	"dcs_enter",
	input_clear, NULL,
	input_state_dcs_enter_table
};

/* dcs_parameter state definition. */
static const struct input_state input_state_dcs_parameter = {
	"dcs_parameter",
	NULL, NULL,
	input_state_dcs_parameter_table
};

/* dcs_intermediate state definition. */
static const struct input_state input_state_dcs_intermediate = {
	"dcs_intermediate",
	NULL, NULL,
	input_state_dcs_intermediate_table
};

/* dcs_handler state definition. */
static const struct input_state input_state_dcs_handler = {
	"dcs_handler",
	NULL, NULL,
	input_state_dcs_handler_table
};

/* dcs_escape state definition. */
static const struct input_state input_state_dcs_escape = {
	"dcs_escape",
	NULL, NULL,
	input_state_dcs_escape_table
};

/* dcs_ignore state definition. */
static const struct input_state input_state_dcs_ignore = {
	"dcs_ignore",
	NULL, NULL,
	input_state_dcs_ignore_table
};

/* osc_string state definition. */
static const struct input_state input_state_osc_string = {
	"osc_string",
	input_enter_osc, input_exit_osc,
	input_state_osc_string_table
};

/* apc_string state definition. */
static const struct input_state input_state_apc_string = {
	"apc_string",
	input_enter_apc, input_exit_apc,
	input_state_apc_string_table
};

/* rename_string state definition. */
static const struct input_state input_state_rename_string = {
	"rename_string",
	input_enter_rename, input_exit_rename,
	input_state_rename_string_table
};

/* consume_st state definition. */
static const struct input_state input_state_consume_st = {
	"consume_st",
	NULL, NULL,
	input_state_consume_st_table
};

/* utf8_three state definition. */
static const struct input_state input_state_utf8_three = {
	"utf8_three",
	NULL, NULL,
	input_state_utf8_three_table
};

/* utf8_two state definition. */
static const struct input_state input_state_utf8_two = {
	"utf8_two",
	NULL, NULL,
	input_state_utf8_two_table
};

/* utf8_one state definition. */
static const struct input_state input_state_utf8_one = {
	"utf8_one",
	NULL, NULL,
	input_state_utf8_one_table
};

/* ground state table. */
static const struct input_transition input_state_ground_table[] = {
	INPUT_STATE_ANYWHERE,

	{ 0x00, 0x17, input_c0_dispatch, NULL },
	{ 0x19, 0x19, input_c0_dispatch, NULL },
	{ 0x1c, 0x1f, input_c0_dispatch, NULL },
	{ 0x20, 0x7e, input_print,	 NULL },
	{ 0x7f, 0x7f, NULL,		 NULL },
	{ 0x80, 0xc1, NULL,		 NULL },
	{ 0xc2, 0xdf, input_utf8_open,	 &input_state_utf8_one },
	{ 0xe0, 0xef, input_utf8_open,	 &input_state_utf8_two },
	{ 0xf0, 0xf4, input_utf8_open,	 &input_state_utf8_three },
	{ 0xf5, 0xff, NULL,		 NULL },

	{ -1, -1, NULL, NULL }
};

/* esc_enter state table. */
static const struct input_transition input_state_esc_enter_table[] = {
	INPUT_STATE_ANYWHERE,

	{ 0x00, 0x17, input_c0_dispatch,  NULL },
	{ 0x19, 0x19, input_c0_dispatch,  NULL },
	{ 0x1c, 0x1f, input_c0_dispatch,  NULL },
	{ 0x20, 0x2f, input_intermediate, &input_state_esc_intermediate },
	{ 0x30, 0x4f, input_esc_dispatch, &input_state_ground },
	{ 0x50, 0x50, NULL,		  &input_state_dcs_enter },
	{ 0x51, 0x57, input_esc_dispatch, &input_state_ground },
	{ 0x58, 0x58, NULL,		  &input_state_consume_st },
	{ 0x59, 0x59, input_esc_dispatch, &input_state_ground },
	{ 0x5a, 0x5a, input_esc_dispatch, &input_state_ground },
	{ 0x5b, 0x5b, NULL,		  &input_state_csi_enter },
	{ 0x5c, 0x5c, input_esc_dispatch, &input_state_ground },
	{ 0x5d, 0x5d, NULL,		  &input_state_osc_string },
	{ 0x5e, 0x5e, NULL,		  &input_state_consume_st },
	{ 0x5f, 0x5f, NULL,		  &input_state_apc_string },
	{ 0x60, 0x6a, input_esc_dispatch, &input_state_ground },
	{ 0x6b, 0x6b, NULL,		  &input_state_rename_string },
	{ 0x6c, 0x7e, input_esc_dispatch, &input_state_ground },
	{ 0x7f, 0xff, NULL,		  NULL },

	{ -1, -1, NULL, NULL }
};

/* esc_interm state table. */
static const struct input_transition input_state_esc_intermediate_table[] = {
	INPUT_STATE_ANYWHERE,

	{ 0x00, 0x17, input_c0_dispatch,  NULL },
	{ 0x19, 0x19, input_c0_dispatch,  NULL },
	{ 0x1c, 0x1f, input_c0_dispatch,  NULL },
	{ 0x20, 0x2f, input_intermediate, NULL },
	{ 0x30, 0x7e, input_esc_dispatch, &input_state_ground },
	{ 0x7f, 0xff, NULL,		  NULL },

	{ -1, -1, NULL, NULL }
};

/* csi_enter state table. */
static const struct input_transition input_state_csi_enter_table[] = {
	INPUT_STATE_ANYWHERE,

	{ 0x00, 0x17, input_c0_dispatch,  NULL },
	{ 0x19, 0x19, input_c0_dispatch,  NULL },
	{ 0x1c, 0x1f, input_c0_dispatch,  NULL },
	{ 0x20, 0x2f, input_intermediate, &input_state_csi_intermediate },
	{ 0x30, 0x39, input_parameter,	  &input_state_csi_parameter },
	{ 0x3a, 0x3a, NULL,		  &input_state_csi_ignore },
	{ 0x3b, 0x3b, input_parameter,	  &input_state_csi_parameter },
	{ 0x3c, 0x3f, input_intermediate, &input_state_csi_parameter },
	{ 0x40, 0x7e, input_csi_dispatch, &input_state_ground },
	{ 0x7f, 0xff, NULL,		  NULL },

	{ -1, -1, NULL, NULL }
};

/* csi_parameter state table. */
static const struct input_transition input_state_csi_parameter_table[] = {
	INPUT_STATE_ANYWHERE,

	{ 0x00, 0x17, input_c0_dispatch,  NULL },
	{ 0x19, 0x19, input_c0_dispatch,  NULL },
	{ 0x1c, 0x1f, input_c0_dispatch,  NULL },
	{ 0x20, 0x2f, input_intermediate, &input_state_csi_intermediate },
	{ 0x30, 0x39, input_parameter,	  NULL },
	{ 0x3a, 0x3a, NULL,		  &input_state_csi_ignore },
	{ 0x3b, 0x3b, input_parameter,	  NULL },
	{ 0x3c, 0x3f, NULL,		  &input_state_csi_ignore },
	{ 0x40, 0x7e, input_csi_dispatch, &input_state_ground },
	{ 0x7f, 0xff, NULL,		  NULL },

	{ -1, -1, NULL, NULL }
};

/* csi_intermediate state table. */
static const struct input_transition input_state_csi_intermediate_table[] = {
	INPUT_STATE_ANYWHERE,

	{ 0x00, 0x17, input_c0_dispatch,  NULL },
	{ 0x19, 0x19, input_c0_dispatch,  NULL },
	{ 0x1c, 0x1f, input_c0_dispatch,  NULL },
	{ 0x20, 0x2f, input_intermediate, NULL },
	{ 0x30, 0x3f, NULL,		  &input_state_csi_ignore },
	{ 0x40, 0x7e, input_csi_dispatch, &input_state_ground },
	{ 0x7f, 0xff, NULL,		  NULL },

	{ -1, -1, NULL, NULL }
};

/* csi_ignore state table. */
static const struct input_transition input_state_csi_ignore_table[] = {
	INPUT_STATE_ANYWHERE,

	{ 0x00, 0x17, input_c0_dispatch, NULL },
	{ 0x19, 0x19, input_c0_dispatch, NULL },
	{ 0x1c, 0x1f, input_c0_dispatch, NULL },
	{ 0x20, 0x3f, NULL,		 NULL },
	{ 0x40, 0x7e, NULL,		 &input_state_ground },
	{ 0x7f, 0xff, NULL,		 NULL },

	{ -1, -1, NULL, NULL }
};

/* dcs_enter state table. */
static const struct input_transition input_state_dcs_enter_table[] = {
	INPUT_STATE_ANYWHERE,

	{ 0x00, 0x17, NULL,		  NULL },
	{ 0x19, 0x19, NULL,		  NULL },
	{ 0x1c, 0x1f, NULL,		  NULL },
	{ 0x20, 0x2f, input_intermediate, &input_state_dcs_intermediate },
	{ 0x30, 0x39, input_parameter,	  &input_state_dcs_parameter },
	{ 0x3a, 0x3a, NULL,		  &input_state_dcs_ignore },
	{ 0x3b, 0x3b, input_parameter,	  &input_state_dcs_parameter },
	{ 0x3c, 0x3f, input_intermediate, &input_state_dcs_parameter },
	{ 0x40, 0x7e, input_input,	  &input_state_dcs_handler },
	{ 0x7f, 0xff, NULL,		  NULL },

	{ -1, -1, NULL, NULL }
};

/* dcs_parameter state table. */
static const struct input_transition input_state_dcs_parameter_table[] = {
	INPUT_STATE_ANYWHERE,

	{ 0x00, 0x17, NULL,		  NULL },
	{ 0x19, 0x19, NULL,		  NULL },
	{ 0x1c, 0x1f, NULL,		  NULL },
	{ 0x20, 0x2f, input_intermediate, &input_state_dcs_intermediate },
	{ 0x30, 0x39, input_parameter,	  NULL },
	{ 0x3a, 0x3a, NULL,		  &input_state_dcs_ignore },
	{ 0x3b, 0x3b, input_parameter,	  NULL },
	{ 0x3c, 0x3f, NULL,		  &input_state_dcs_ignore },
	{ 0x40, 0x7e, input_input,	  &input_state_dcs_handler },
	{ 0x7f, 0xff, NULL,		  NULL },

	{ -1, -1, NULL, NULL }
};

/* dcs_interm state table. */
static const struct input_transition input_state_dcs_intermediate_table[] = {
	INPUT_STATE_ANYWHERE,

	{ 0x00, 0x17, NULL,		  NULL },
	{ 0x19, 0x19, NULL,		  NULL },
	{ 0x1c, 0x1f, NULL,		  NULL },
	{ 0x20, 0x2f, input_intermediate, NULL },
	{ 0x30, 0x3f, NULL,		  &input_state_dcs_ignore },
	{ 0x40, 0x7e, input_input,	  &input_state_dcs_handler },
	{ 0x7f, 0xff, NULL,		  NULL },

	{ -1, -1, NULL, NULL }
};

/* dcs_handler state table. */
static const struct input_transition input_state_dcs_handler_table[] = {
	/* No INPUT_STATE_ANYWHERE */

	{ 0x00, 0x1a, input_input,  NULL },
	{ 0x1b, 0x1b, NULL,	    &input_state_dcs_escape },
	{ 0x1c, 0xff, input_input,  NULL },

	{ -1, -1, NULL, NULL }
};

/* dcs_escape state table. */
static const struct input_transition input_state_dcs_escape_table[] = {
	/* No INPUT_STATE_ANYWHERE */

	{ 0x00, 0x5b, input_input,	  &input_state_dcs_handler },
	{ 0x5c, 0x5c, input_dcs_dispatch, &input_state_ground },
	{ 0x5d, 0xff, input_input,	  &input_state_dcs_handler },

	{ -1, -1, NULL, NULL }
};

/* dcs_ignore state table. */
static const struct input_transition input_state_dcs_ignore_table[] = {
	INPUT_STATE_ANYWHERE,

	{ 0x00, 0x17, NULL,	    NULL },
	{ 0x19, 0x19, NULL,	    NULL },
	{ 0x1c, 0x1f, NULL,	    NULL },
	{ 0x20, 0xff, NULL,	    NULL },

	{ -1, -1, NULL, NULL }
};

/* osc_string state table. */
static const struct input_transition input_state_osc_string_table[] = {
	INPUT_STATE_ANYWHERE,

	{ 0x00, 0x06, NULL,	    NULL },
	{ 0x07, 0x07, NULL,	    &input_state_ground },
	{ 0x08, 0x17, NULL,	    NULL },
	{ 0x19, 0x19, NULL,	    NULL },
	{ 0x1c, 0x1f, NULL,	    NULL },
	{ 0x20, 0xff, input_input,  NULL },

	{ -1, -1, NULL, NULL }
};

/* apc_string state table. */
static const struct input_transition input_state_apc_string_table[] = {
	INPUT_STATE_ANYWHERE,

	{ 0x00, 0x17, NULL,	    NULL },
	{ 0x19, 0x19, NULL,	    NULL },
	{ 0x1c, 0x1f, NULL,	    NULL },
	{ 0x20, 0xff, input_input,  NULL },

	{ -1, -1, NULL, NULL }
};

/* rename_string state table. */
static const struct input_transition input_state_rename_string_table[] = {
	INPUT_STATE_ANYWHERE,

	{ 0x00, 0x17, NULL,	    NULL },
	{ 0x19, 0x19, NULL,	    NULL },
	{ 0x1c, 0x1f, NULL,	    NULL },
	{ 0x20, 0xff, input_input,  NULL },

	{ -1, -1, NULL, NULL }
};

/* consume_st state table. */
static const struct input_transition input_state_consume_st_table[] = {
	INPUT_STATE_ANYWHERE,

	{ 0x00, 0x17, NULL,	    NULL },
	{ 0x19, 0x19, NULL,	    NULL },
	{ 0x1c, 0x1f, NULL,	    NULL },
	{ 0x20, 0xff, NULL,	    NULL },

	{ -1, -1, NULL, NULL }
};

/* utf8_three state table. */
static const struct input_transition input_state_utf8_three_table[] = {
	/* No INPUT_STATE_ANYWHERE */

	{ 0x00, 0x7f, NULL,		&input_state_ground },
	{ 0x80, 0xbf, input_utf8_add,	&input_state_utf8_two },
	{ 0xc0, 0xff, NULL,		&input_state_ground },

	{ -1, -1, NULL, NULL }
};

/* utf8_two state table. */
static const struct input_transition input_state_utf8_two_table[] = {
	/* No INPUT_STATE_ANYWHERE */

	{ 0x00, 0x7f, NULL,	      &input_state_ground },
	{ 0x80, 0xbf, input_utf8_add, &input_state_utf8_one },
	{ 0xc0, 0xff, NULL,	      &input_state_ground },

	{ -1, -1, NULL, NULL }
};

/* utf8_one state table. */
static const struct input_transition input_state_utf8_one_table[] = {
	/* No INPUT_STATE_ANYWHERE */

	{ 0x00, 0x7f, NULL,		&input_state_ground },
	{ 0x80, 0xbf, input_utf8_close, &input_state_ground },
	{ 0xc0, 0xff, NULL,		&input_state_ground },

	{ -1, -1, NULL, NULL }
};

/* Input table compare. */
static int
input_table_compare(const void *key, const void *value)
{
	const struct input_ctx		*ictx = key;
	const struct input_table_entry	*entry = value;

	if (ictx->ch != entry->ch)
		return (ictx->ch - entry->ch);
	return (strcmp(ictx->interm_buf, entry->interm));
}

/* Reset cell state to default. */
static void
input_reset_cell(struct input_ctx *ictx)
{
	memcpy(&ictx->cell.cell, &grid_default_cell, sizeof ictx->cell.cell);
	ictx->cell.set = 0;
	ictx->cell.g0set = ictx->cell.g1set = 0;

	memcpy(&ictx->old_cell, &ictx->cell, sizeof ictx->old_cell);
	ictx->old_cx = 0;
	ictx->old_cy = 0;
}

/* Initialise input parser. */
void
input_init(struct window_pane *wp)
{
	struct input_ctx	*ictx;

	ictx = wp->ictx = xcalloc(1, sizeof *ictx);

	ictx->input_space = INPUT_BUF_START;
	ictx->input_buf = xmalloc(INPUT_BUF_START);

	ictx->since_ground = evbuffer_new();

	input_reset(wp, 0);
}

/* Destroy input parser. */
void
input_free(struct window_pane *wp)
{
	struct input_ctx	*ictx = wp->ictx;

	free(ictx->input_buf);
	evbuffer_free(ictx->since_ground);

	free(ictx);
	wp->ictx = NULL;
}

/* Reset input state and clear screen. */
void
input_reset(struct window_pane *wp, int clear)
{
	struct input_ctx	*ictx = wp->ictx;

	input_reset_cell(ictx);

	if (clear) {
		if (wp->mode == NULL)
			screen_write_start(&ictx->ctx, wp, &wp->base);
		else
			screen_write_start(&ictx->ctx, NULL, &wp->base);
		screen_write_reset(&ictx->ctx);
		screen_write_stop(&ictx->ctx);
	}

	*ictx->interm_buf = '\0';
	ictx->interm_len = 0;

	*ictx->param_buf = '\0';
	ictx->param_len = 0;

	*ictx->input_buf = '\0';
	ictx->input_len = 0;

	ictx->state = &input_state_ground;
	ictx->flags = 0;
}

/* Return pending data. */
struct evbuffer *
input_pending(struct window_pane *wp)
{
	return (wp->ictx->since_ground);
}

/* Change input state. */
static void
input_set_state(struct window_pane *wp, const struct input_transition *itr)
{
	struct input_ctx	*ictx = wp->ictx;

	if (ictx->state->exit != NULL)
		ictx->state->exit(ictx);
	ictx->state = itr->state;
	if (ictx->state->enter != NULL)
		ictx->state->enter(ictx);
}

/* Parse input. */
void
input_parse(struct window_pane *wp)
{
	struct input_ctx		*ictx = wp->ictx;
	const struct input_transition	*itr;
	struct evbuffer			*evb = wp->event->input;
	u_char				*buf;
	size_t				 len, off;

	if (EVBUFFER_LENGTH(evb) == 0)
		return;

	window_update_activity(wp->window);
	wp->flags |= PANE_CHANGED;

	/*
	 * Open the screen. Use NULL wp if there is a mode set as don't want to
	 * update the tty.
	 */
	if (wp->mode == NULL)
		screen_write_start(&ictx->ctx, wp, &wp->base);
	else
		screen_write_start(&ictx->ctx, NULL, &wp->base);
	ictx->wp = wp;

	buf = EVBUFFER_DATA(evb);
	len = EVBUFFER_LENGTH(evb);
	off = 0;

	notify_input(wp, evb);

	log_debug("%s: %%%u %s, %zu bytes: %.*s", __func__, wp->id,
	    ictx->state->name, len, (int)len, buf);

	/* Parse the input. */
	while (off < len) {
		ictx->ch = buf[off++];

		/* Find the transition. */
		itr = ictx->state->transitions;
		while (itr->first != -1 && itr->last != -1) {
			if (ictx->ch >= itr->first && ictx->ch <= itr->last)
				break;
			itr++;
		}
		if (itr->first == -1 || itr->last == -1) {
			/* No transition? Eh? */
			fatalx("no transition from state");
		}

		/*
		 * Any state except print stops the current collection. This is
		 * an optimization to avoid checking if the attributes have
		 * changed for every character. It will stop unnecessarily for
		 * sequences that don't make a terminal change, but they should
		 * be the minority.
		 */
		if (itr->handler != input_print)
			screen_write_collect_end(&ictx->ctx);

		/*
		 * Execute the handler, if any. Don't switch state if it
		 * returns non-zero.
		 */
		if (itr->handler != NULL && itr->handler(ictx) != 0)
			continue;

		/* And switch state, if necessary. */
		if (itr->state != NULL)
			input_set_state(wp, itr);

		/* If not in ground state, save input. */
		if (ictx->state != &input_state_ground)
			evbuffer_add(ictx->since_ground, &ictx->ch, 1);
	}

	/* Close the screen. */
	screen_write_stop(&ictx->ctx);

	evbuffer_drain(evb, len);
}

/* Split the parameter list (if any). */
static int
input_split(struct input_ctx *ictx)
{
	const char	*errstr;
	char		*ptr, *out;
	int		 n;

	ictx->param_list_len = 0;
	if (ictx->param_len == 0)
		return (0);

	ptr = ictx->param_buf;
	while ((out = strsep(&ptr, ";")) != NULL) {
		if (*out == '\0')
			n = -1;
		else {
			n = strtonum(out, 0, INT_MAX, &errstr);
			if (errstr != NULL)
				return (-1);
		}

		ictx->param_list[ictx->param_list_len++] = n;
		if (ictx->param_list_len == nitems(ictx->param_list))
			return (-1);
	}

	return (0);
}

/* Get an argument or return default value. */
static int
input_get(struct input_ctx *ictx, u_int validx, int minval, int defval)
{
	int	retval;

	if (validx >= ictx->param_list_len)
	    return (defval);

	retval = ictx->param_list[validx];
	if (retval == -1)
		return (defval);
	if (retval < minval)
		return (minval);
	return (retval);
}

/* Reply to terminal query. */
static void
input_reply(struct input_ctx *ictx, const char *fmt, ...)
{
	va_list	ap;
	char   *reply;

	va_start(ap, fmt);
	xvasprintf(&reply, fmt, ap);
	va_end(ap);

	bufferevent_write(ictx->wp->event, reply, strlen(reply));
	free(reply);
}

/* Clear saved state. */
static void
input_clear(struct input_ctx *ictx)
{
	*ictx->interm_buf = '\0';
	ictx->interm_len = 0;

	*ictx->param_buf = '\0';
	ictx->param_len = 0;

	*ictx->input_buf = '\0';
	ictx->input_len = 0;

	ictx->flags &= ~INPUT_DISCARD;
}

/* Reset for ground state. */
static void
input_ground(struct input_ctx *ictx)
{
	evbuffer_drain(ictx->since_ground, EVBUFFER_LENGTH(ictx->since_ground));

	if (ictx->input_space > INPUT_BUF_START) {
		ictx->input_space = INPUT_BUF_START;
		ictx->input_buf = xrealloc(ictx->input_buf, INPUT_BUF_START);
	}
}

/* Output this character to the screen. */
static int
input_print(struct input_ctx *ictx)
{
	int	set;

	set = ictx->cell.set == 0 ? ictx->cell.g0set : ictx->cell.g1set;
	if (set == 1)
		ictx->cell.cell.attr |= GRID_ATTR_CHARSET;
	else
		ictx->cell.cell.attr &= ~GRID_ATTR_CHARSET;

	utf8_set(&ictx->cell.cell.data, ictx->ch);
	screen_write_collect_add(&ictx->ctx, &ictx->cell.cell);

	ictx->cell.cell.attr &= ~GRID_ATTR_CHARSET;

	return (0);
}

/* Collect intermediate string. */
static int
input_intermediate(struct input_ctx *ictx)
{
	if (ictx->interm_len == (sizeof ictx->interm_buf) - 1)
		ictx->flags |= INPUT_DISCARD;
	else {
		ictx->interm_buf[ictx->interm_len++] = ictx->ch;
		ictx->interm_buf[ictx->interm_len] = '\0';
	}

	return (0);
}

/* Collect parameter string. */
static int
input_parameter(struct input_ctx *ictx)
{
	if (ictx->param_len == (sizeof ictx->param_buf) - 1)
		ictx->flags |= INPUT_DISCARD;
	else {
		ictx->param_buf[ictx->param_len++] = ictx->ch;
		ictx->param_buf[ictx->param_len] = '\0';
	}

	return (0);
}

/* Collect input string. */
static int
input_input(struct input_ctx *ictx)
{
	size_t available;

	available = ictx->input_space;
	while (ictx->input_len + 1 >= available) {
		available *= 2;
		if (available > INPUT_BUF_LIMIT) {
			ictx->flags |= INPUT_DISCARD;
			return (0);
		}
		ictx->input_buf = xrealloc(ictx->input_buf, available);
		ictx->input_space = available;
	}
	ictx->input_buf[ictx->input_len++] = ictx->ch;
	ictx->input_buf[ictx->input_len] = '\0';

	return (0);
}

/* Execute C0 control sequence. */
static int
input_c0_dispatch(struct input_ctx *ictx)
{
	struct screen_write_ctx	*sctx = &ictx->ctx;
	struct window_pane	*wp = ictx->wp;
	struct screen		*s = sctx->s;

	log_debug("%s: '%c'", __func__, ictx->ch);

	switch (ictx->ch) {
	case '\000':	/* NUL */
		break;
	case '\007':	/* BEL */
		alerts_queue(wp->window, WINDOW_BELL);
		break;
	case '\010':	/* BS */
		screen_write_backspace(sctx);
		break;
	case '\011':	/* HT */
		/* Don't tab beyond the end of the line. */
		if (s->cx >= screen_size_x(s) - 1)
			break;

		/* Find the next tab point, or use the last column if none. */
		do {
			s->cx++;
			if (bit_test(s->tabs, s->cx))
				break;
		} while (s->cx < screen_size_x(s) - 1);
		break;
	case '\012':	/* LF */
	case '\013':	/* VT */
	case '\014':	/* FF */
		screen_write_linefeed(sctx, 0, ictx->cell.cell.bg);
		break;
	case '\015':	/* CR */
		screen_write_carriagereturn(sctx);
		break;
	case '\016':	/* SO */
		ictx->cell.set = 1;
		break;
	case '\017':	/* SI */
		ictx->cell.set = 0;
		break;
	default:
		log_debug("%s: unknown '%c'", __func__, ictx->ch);
		break;
	}

	return (0);
}

/* Execute escape sequence. */
static int
input_esc_dispatch(struct input_ctx *ictx)
{
	struct screen_write_ctx		*sctx = &ictx->ctx;
	struct screen			*s = sctx->s;
	struct input_table_entry	*entry;

	if (ictx->flags & INPUT_DISCARD)
		return (0);
	log_debug("%s: '%c', %s", __func__, ictx->ch, ictx->interm_buf);

	entry = bsearch(ictx, input_esc_table, nitems(input_esc_table),
	    sizeof input_esc_table[0], input_table_compare);
	if (entry == NULL) {
		log_debug("%s: unknown '%c'", __func__, ictx->ch);
		return (0);
	}

	switch (entry->type) {
	case INPUT_ESC_RIS:
		window_pane_reset_palette(ictx->wp);
		input_reset_cell(ictx);
		screen_write_reset(sctx);
		break;
	case INPUT_ESC_IND:
		screen_write_linefeed(sctx, 0, ictx->cell.cell.bg);
		break;
	case INPUT_ESC_NEL:
		screen_write_carriagereturn(sctx);
		screen_write_linefeed(sctx, 0, ictx->cell.cell.bg);
		break;
	case INPUT_ESC_HTS:
		if (s->cx < screen_size_x(s))
			bit_set(s->tabs, s->cx);
		break;
	case INPUT_ESC_RI:
		screen_write_reverseindex(sctx, ictx->cell.cell.bg);
		break;
	case INPUT_ESC_DECKPAM:
		screen_write_mode_set(sctx, MODE_KKEYPAD);
		break;
	case INPUT_ESC_DECKPNM:
		screen_write_mode_clear(sctx, MODE_KKEYPAD);
		break;
	case INPUT_ESC_DECSC:
		memcpy(&ictx->old_cell, &ictx->cell, sizeof ictx->old_cell);
		ictx->old_cx = s->cx;
		ictx->old_cy = s->cy;
		break;
	case INPUT_ESC_DECRC:
		memcpy(&ictx->cell, &ictx->old_cell, sizeof ictx->cell);
		screen_write_cursormove(sctx, ictx->old_cx, ictx->old_cy);
		break;
	case INPUT_ESC_DECALN:
		screen_write_alignmenttest(sctx);
		break;
	case INPUT_ESC_SCSG0_ON:
		ictx->cell.g0set = 1;
		break;
	case INPUT_ESC_SCSG0_OFF:
		ictx->cell.g0set = 0;
		break;
	case INPUT_ESC_SCSG1_ON:
		ictx->cell.g1set = 1;
		break;
	case INPUT_ESC_SCSG1_OFF:
		ictx->cell.g1set = 0;
		break;
	case INPUT_ESC_ST:
		/* ST terminates OSC but the state transition already did it. */
		break;
	}

	return (0);
}

/* Execute control sequence. */
static int
input_csi_dispatch(struct input_ctx *ictx)
{
	struct screen_write_ctx	       *sctx = &ictx->ctx;
	struct screen		       *s = sctx->s;
	struct input_table_entry       *entry;
	int				n, m;
	u_int				cx;

	if (ictx->flags & INPUT_DISCARD)
		return (0);

	log_debug("%s: '%c' \"%s\" \"%s\"",
	    __func__, ictx->ch, ictx->interm_buf, ictx->param_buf);

	if (input_split(ictx) != 0)
		return (0);

	entry = bsearch(ictx, input_csi_table, nitems(input_csi_table),
	    sizeof input_csi_table[0], input_table_compare);
	if (entry == NULL) {
		log_debug("%s: unknown '%c'", __func__, ictx->ch);
		return (0);
	}

	switch (entry->type) {
	case INPUT_CSI_CBT:
		/* Find the previous tab point, n times. */
		cx = s->cx;
		if (cx > screen_size_x(s) - 1)
			cx = screen_size_x(s) - 1;
		n = input_get(ictx, 0, 1, 1);
		while (cx > 0 && n-- > 0) {
			do
				cx--;
			while (cx > 0 && !bit_test(s->tabs, cx));
		}
		s->cx = cx;
		break;
	case INPUT_CSI_CUB:
		screen_write_cursorleft(sctx, input_get(ictx, 0, 1, 1));
		break;
	case INPUT_CSI_CUD:
		screen_write_cursordown(sctx, input_get(ictx, 0, 1, 1));
		break;
	case INPUT_CSI_CUF:
		screen_write_cursorright(sctx, input_get(ictx, 0, 1, 1));
		break;
	case INPUT_CSI_CUP:
		n = input_get(ictx, 0, 1, 1);
		m = input_get(ictx, 1, 1, 1);
		screen_write_cursormove(sctx, m - 1, n - 1);
		break;
	case INPUT_CSI_WINOPS:
		input_csi_dispatch_winops(ictx);
		break;
	case INPUT_CSI_CUU:
		screen_write_cursorup(sctx, input_get(ictx, 0, 1, 1));
		break;
	case INPUT_CSI_CNL:
		screen_write_carriagereturn(sctx);
		screen_write_cursordown(sctx, input_get(ictx, 0, 1, 1));
		break;
	case INPUT_CSI_CPL:
		screen_write_carriagereturn(sctx);
		screen_write_cursorup(sctx, input_get(ictx, 0, 1, 1));
		break;
	case INPUT_CSI_DA:
		switch (input_get(ictx, 0, 0, 0)) {
		case 0:
			input_reply(ictx, "\033[?1;2c");
			break;
		default:
			log_debug("%s: unknown '%c'", __func__, ictx->ch);
			break;
		}
		break;
	case INPUT_CSI_DA_TWO:
		switch (input_get(ictx, 0, 0, 0)) {
		case 0:
			input_reply(ictx, "\033[>84;0;0c");
			break;
		default:
			log_debug("%s: unknown '%c'", __func__, ictx->ch);
			break;
		}
		break;
	case INPUT_CSI_ECH:
		screen_write_clearcharacter(sctx, input_get(ictx, 0, 1, 1),
		    ictx->cell.cell.bg);
		break;
	case INPUT_CSI_DCH:
		screen_write_deletecharacter(sctx, input_get(ictx, 0, 1, 1),
		    ictx->cell.cell.bg);
		break;
	case INPUT_CSI_DECSTBM:
		n = input_get(ictx, 0, 1, 1);
		m = input_get(ictx, 1, 1, screen_size_y(s));
		screen_write_scrollregion(sctx, n - 1, m - 1);
		break;
	case INPUT_CSI_DL:
		screen_write_deleteline(sctx, input_get(ictx, 0, 1, 1),
		    ictx->cell.cell.bg);
		break;
	case INPUT_CSI_DSR:
		switch (input_get(ictx, 0, 0, 0)) {
		case 5:
			input_reply(ictx, "\033[0n");
			break;
		case 6:
			input_reply(ictx, "\033[%u;%uR", s->cy + 1, s->cx + 1);
			break;
		default:
			log_debug("%s: unknown '%c'", __func__, ictx->ch);
			break;
		}
		break;
	case INPUT_CSI_ED:
		switch (input_get(ictx, 0, 0, 0)) {
		case 0:
			screen_write_clearendofscreen(sctx, ictx->cell.cell.bg);
			break;
		case 1:
			screen_write_clearstartofscreen(sctx, ictx->cell.cell.bg);
			break;
		case 2:
			screen_write_clearscreen(sctx, ictx->cell.cell.bg);
			break;
		case 3:
			switch (input_get(ictx, 1, 0, 0)) {
			case 0:
				/*
				 * Linux console extension to clear history
				 * (for example before locking the screen).
				 */
				screen_write_clearhistory(sctx);
				break;
			}
			break;
		default:
			log_debug("%s: unknown '%c'", __func__, ictx->ch);
			break;
		}
		break;
	case INPUT_CSI_EL:
		switch (input_get(ictx, 0, 0, 0)) {
		case 0:
			screen_write_clearendofline(sctx, ictx->cell.cell.bg);
			break;
		case 1:
			screen_write_clearstartofline(sctx, ictx->cell.cell.bg);
			break;
		case 2:
			screen_write_clearline(sctx, ictx->cell.cell.bg);
			break;
		default:
			log_debug("%s: unknown '%c'", __func__, ictx->ch);
			break;
		}
		break;
	case INPUT_CSI_HPA:
		n = input_get(ictx, 0, 1, 1);
		screen_write_cursormove(sctx, n - 1, s->cy);
		break;
	case INPUT_CSI_ICH:
		screen_write_insertcharacter(sctx, input_get(ictx, 0, 1, 1),
		    ictx->cell.cell.bg);
		break;
	case INPUT_CSI_IL:
		screen_write_insertline(sctx, input_get(ictx, 0, 1, 1),
		    ictx->cell.cell.bg);
		break;
	case INPUT_CSI_RCP:
		memcpy(&ictx->cell, &ictx->old_cell, sizeof ictx->cell);
		screen_write_cursormove(sctx, ictx->old_cx, ictx->old_cy);
		break;
	case INPUT_CSI_RM:
		input_csi_dispatch_rm(ictx);
		break;
	case INPUT_CSI_RM_PRIVATE:
		input_csi_dispatch_rm_private(ictx);
		break;
	case INPUT_CSI_SCP:
		memcpy(&ictx->old_cell, &ictx->cell, sizeof ictx->old_cell);
		ictx->old_cx = s->cx;
		ictx->old_cy = s->cy;
		break;
	case INPUT_CSI_SGR:
		input_csi_dispatch_sgr(ictx);
		break;
	case INPUT_CSI_SM:
		input_csi_dispatch_sm(ictx);
		break;
	case INPUT_CSI_SM_PRIVATE:
		input_csi_dispatch_sm_private(ictx);
		break;
	case INPUT_CSI_SU:
		screen_write_scrollup(sctx, input_get(ictx, 0, 1, 1),
		    ictx->cell.cell.bg);
		break;
	case INPUT_CSI_TBC:
		switch (input_get(ictx, 0, 0, 0)) {
		case 0:
			if (s->cx < screen_size_x(s))
				bit_clear(s->tabs, s->cx);
			break;
		case 3:
			bit_nclear(s->tabs, 0, screen_size_x(s) - 1);
			break;
		default:
			log_debug("%s: unknown '%c'", __func__, ictx->ch);
			break;
		}
		break;
	case INPUT_CSI_VPA:
		n = input_get(ictx, 0, 1, 1);
		screen_write_cursormove(sctx, s->cx, n - 1);
		break;
	case INPUT_CSI_DECSCUSR:
		n = input_get(ictx, 0, 0, 0);
		screen_set_cursor_style(s, n);
		break;
	}

	return (0);
}

/* Handle CSI RM. */
static void
input_csi_dispatch_rm(struct input_ctx *ictx)
{
	u_int	i;

	for (i = 0; i < ictx->param_list_len; i++) {
		switch (input_get(ictx, i, 0, -1)) {
		case 4:		/* IRM */
			screen_write_mode_clear(&ictx->ctx, MODE_INSERT);
			break;
		case 34:
			screen_write_mode_set(&ictx->ctx, MODE_BLINKING);
			break;
		default:
			log_debug("%s: unknown '%c'", __func__, ictx->ch);
			break;
		}
	}
}

/* Handle CSI private RM. */
static void
input_csi_dispatch_rm_private(struct input_ctx *ictx)
{
	struct window_pane	*wp = ictx->wp;
	u_int			 i;

	for (i = 0; i < ictx->param_list_len; i++) {
		switch (input_get(ictx, i, 0, -1)) {
		case 1:		/* DECCKM */
			screen_write_mode_clear(&ictx->ctx, MODE_KCURSOR);
			break;
		case 3:		/* DECCOLM */
			screen_write_cursormove(&ictx->ctx, 0, 0);
			screen_write_clearscreen(&ictx->ctx,
			    ictx->cell.cell.bg);
			break;
		case 7:		/* DECAWM */
			screen_write_mode_clear(&ictx->ctx, MODE_WRAP);
			break;
		case 12:
			screen_write_mode_clear(&ictx->ctx, MODE_BLINKING);
			break;
		case 25:	/* TCEM */
			screen_write_mode_clear(&ictx->ctx, MODE_CURSOR);
			break;
		case 1000:
		case 1001:
		case 1002:
		case 1003:
			screen_write_mode_clear(&ictx->ctx, ALL_MOUSE_MODES);
			break;
		case 1004:
			screen_write_mode_clear(&ictx->ctx, MODE_FOCUSON);
			break;
		case 1005:
			screen_write_mode_clear(&ictx->ctx, MODE_MOUSE_UTF8);
			break;
		case 1006:
			screen_write_mode_clear(&ictx->ctx, MODE_MOUSE_SGR);
			break;
		case 47:
		case 1047:
			window_pane_alternate_off(wp, &ictx->cell.cell, 0);
			break;
		case 1049:
			window_pane_alternate_off(wp, &ictx->cell.cell, 1);
			break;
		case 2004:
			screen_write_mode_clear(&ictx->ctx, MODE_BRACKETPASTE);
			break;
		default:
			log_debug("%s: unknown '%c'", __func__, ictx->ch);
			break;
		}
	}
}

/* Handle CSI SM. */
static void
input_csi_dispatch_sm(struct input_ctx *ictx)
{
	u_int	i;

	for (i = 0; i < ictx->param_list_len; i++) {
		switch (input_get(ictx, i, 0, -1)) {
		case 4:		/* IRM */
			screen_write_mode_set(&ictx->ctx, MODE_INSERT);
			break;
		case 34:
			screen_write_mode_clear(&ictx->ctx, MODE_BLINKING);
			break;
		default:
			log_debug("%s: unknown '%c'", __func__, ictx->ch);
			break;
		}
	}
}

/* Handle CSI private SM. */
static void
input_csi_dispatch_sm_private(struct input_ctx *ictx)
{
	struct window_pane	*wp = ictx->wp;
	u_int			 i;

	for (i = 0; i < ictx->param_list_len; i++) {
		switch (input_get(ictx, i, 0, -1)) {
		case 1:		/* DECCKM */
			screen_write_mode_set(&ictx->ctx, MODE_KCURSOR);
			break;
		case 3:		/* DECCOLM */
			screen_write_cursormove(&ictx->ctx, 0, 0);
			screen_write_clearscreen(&ictx->ctx,
			    ictx->cell.cell.bg);
			break;
		case 7:		/* DECAWM */
			screen_write_mode_set(&ictx->ctx, MODE_WRAP);
			break;
		case 12:
			screen_write_mode_set(&ictx->ctx, MODE_BLINKING);
			break;
		case 25:	/* TCEM */
			screen_write_mode_set(&ictx->ctx, MODE_CURSOR);
			break;
		case 1000:
			screen_write_mode_clear(&ictx->ctx, ALL_MOUSE_MODES);
			screen_write_mode_set(&ictx->ctx, MODE_MOUSE_STANDARD);
			break;
		case 1002:
			screen_write_mode_clear(&ictx->ctx, ALL_MOUSE_MODES);
			screen_write_mode_set(&ictx->ctx, MODE_MOUSE_BUTTON);
			break;
		case 1003:
			screen_write_mode_clear(&ictx->ctx, ALL_MOUSE_MODES);
			screen_write_mode_set(&ictx->ctx, MODE_MOUSE_ALL);
			break;
		case 1004:
			if (ictx->ctx.s->mode & MODE_FOCUSON)
				break;
			screen_write_mode_set(&ictx->ctx, MODE_FOCUSON);
			wp->flags |= PANE_FOCUSPUSH; /* force update */
			break;
		case 1005:
			screen_write_mode_set(&ictx->ctx, MODE_MOUSE_UTF8);
			break;
		case 1006:
			screen_write_mode_set(&ictx->ctx, MODE_MOUSE_SGR);
			break;
		case 47:
		case 1047:
			window_pane_alternate_on(wp, &ictx->cell.cell, 0);
			break;
		case 1049:
			window_pane_alternate_on(wp, &ictx->cell.cell, 1);
			break;
		case 2004:
			screen_write_mode_set(&ictx->ctx, MODE_BRACKETPASTE);
			break;
		default:
			log_debug("%s: unknown '%c'", __func__, ictx->ch);
			break;
		}
	}
}

/* Handle CSI window operations. */
static void
input_csi_dispatch_winops(struct input_ctx *ictx)
{
	struct window_pane	*wp = ictx->wp;
	int			 n, m;

	m = 0;
	while ((n = input_get(ictx, m, 0, -1)) != -1) {
		switch (n) {
		case 1:
		case 2:
		case 5:
		case 6:
		case 7:
		case 11:
		case 13:
		case 14:
		case 19:
		case 20:
		case 21:
		case 24:
			break;
		case 3:
		case 4:
		case 8:
			m++;
			if (input_get(ictx, m, 0, -1) == -1)
				return;
			/* FALLTHROUGH */
		case 9:
		case 10:
		case 22:
		case 23:
			m++;
			if (input_get(ictx, m, 0, -1) == -1)
				return;
			break;
		case 18:
			input_reply(ictx, "\033[8;%u;%ut", wp->sy, wp->sx);
			break;
		default:
			log_debug("%s: unknown '%c'", __func__, ictx->ch);
			break;
		}
		m++;
	}
}

/* Handle CSI SGR for 256 colours. */
static void
input_csi_dispatch_sgr_256(struct input_ctx *ictx, int fgbg, u_int *i)
{
	struct grid_cell	*gc = &ictx->cell.cell;
	int			 c;

	(*i)++;
	c = input_get(ictx, *i, 0, -1);
	if (c == -1) {
		if (fgbg == 38)
			gc->fg = 8;
		else if (fgbg == 48)
			gc->bg = 8;
	} else {
		if (fgbg == 38)
			gc->fg = c | COLOUR_FLAG_256;
		else if (fgbg == 48)
			gc->bg = c | COLOUR_FLAG_256;
	}
}

/* Handle CSI SGR for RGB colours. */
static void
input_csi_dispatch_sgr_rgb(struct input_ctx *ictx, int fgbg, u_int *i)
{
	struct grid_cell	*gc = &ictx->cell.cell;
	int			 r, g, b;

	(*i)++;
	r = input_get(ictx, *i, 0, -1);
	if (r == -1 || r > 255)
		return;
	(*i)++;
	g = input_get(ictx, *i, 0, -1);
	if (g == -1 || g > 255)
		return;
	(*i)++;
	b = input_get(ictx, *i, 0, -1);
	if (b == -1 || b > 255)
		return;

	if (fgbg == 38)
		gc->fg = colour_join_rgb(r, g, b);
	else if (fgbg == 48)
		gc->bg = colour_join_rgb(r, g, b);
}

/* Handle CSI SGR. */
static void
input_csi_dispatch_sgr(struct input_ctx *ictx)
{
	struct grid_cell	*gc = &ictx->cell.cell;
	u_int			 i;
	int			 n;

	if (ictx->param_list_len == 0) {
		memcpy(gc, &grid_default_cell, sizeof *gc);
		return;
	}

	for (i = 0; i < ictx->param_list_len; i++) {
		n = input_get(ictx, i, 0, 0);

		if (n == 38 || n == 48) {
			i++;
			switch (input_get(ictx, i, 0, -1)) {
			case 2:
				input_csi_dispatch_sgr_rgb(ictx, n, &i);
				break;
			case 5:
				input_csi_dispatch_sgr_256(ictx, n, &i);
				break;
			}
			continue;
		}

		switch (n) {
		case 0:
		case 10:
			memcpy(gc, &grid_default_cell, sizeof *gc);
			break;
		case 1:
			gc->attr |= GRID_ATTR_BRIGHT;
			break;
		case 2:
			gc->attr |= GRID_ATTR_DIM;
			break;
		case 3:
			gc->attr |= GRID_ATTR_ITALICS;
			break;
		case 4:
			gc->attr |= GRID_ATTR_UNDERSCORE;
			break;
		case 5:
			gc->attr |= GRID_ATTR_BLINK;
			break;
		case 7:
			gc->attr |= GRID_ATTR_REVERSE;
			break;
		case 8:
			gc->attr |= GRID_ATTR_HIDDEN;
			break;
		case 9:
			gc->attr |= GRID_ATTR_STRIKETHROUGH;
			break;
		case 22:
			gc->attr &= ~(GRID_ATTR_BRIGHT|GRID_ATTR_DIM);
			break;
		case 23:
			gc->attr &= ~GRID_ATTR_ITALICS;
			break;
		case 24:
			gc->attr &= ~GRID_ATTR_UNDERSCORE;
			break;
		case 25:
			gc->attr &= ~GRID_ATTR_BLINK;
			break;
		case 27:
			gc->attr &= ~GRID_ATTR_REVERSE;
			break;
		case 28:
			gc->attr &= ~GRID_ATTR_HIDDEN;
			break;
		case 29:
			gc->attr &= ~GRID_ATTR_STRIKETHROUGH;
			break;
		case 30:
		case 31:
		case 32:
		case 33:
		case 34:
		case 35:
		case 36:
		case 37:
			gc->fg = n - 30;
			break;
		case 39:
			gc->fg = 8;
			break;
		case 40:
		case 41:
		case 42:
		case 43:
		case 44:
		case 45:
		case 46:
		case 47:
			gc->bg = n - 40;
			break;
		case 49:
			gc->bg = 8;
			break;
		case 90:
		case 91:
		case 92:
		case 93:
		case 94:
		case 95:
		case 96:
		case 97:
			gc->fg = n;
			break;
		case 100:
		case 101:
		case 102:
		case 103:
		case 104:
		case 105:
		case 106:
		case 107:
			gc->bg = n - 10;
			break;
		}
	}
}

/* DCS terminator (ST) received. */
static int
input_dcs_dispatch(struct input_ctx *ictx)
{
	const char	prefix[] = "tmux;";
	const u_int	prefix_len = (sizeof prefix) - 1;

	if (ictx->flags & INPUT_DISCARD)
		return (0);

	log_debug("%s: \"%s\"", __func__, ictx->input_buf);

	/* Check for tmux prefix. */
	if (ictx->input_len >= prefix_len &&
	    strncmp(ictx->input_buf, prefix, prefix_len) == 0) {
		screen_write_rawstring(&ictx->ctx,
		    ictx->input_buf + prefix_len, ictx->input_len - prefix_len);
	}

	return (0);
}

/* OSC string started. */
static void
input_enter_osc(struct input_ctx *ictx)
{
	log_debug("%s", __func__);

	input_clear(ictx);
}

/* OSC terminator (ST) received. */
static void
input_exit_osc(struct input_ctx *ictx)
{
	u_char	*p = ictx->input_buf;
	u_int	 option;

	if (ictx->flags & INPUT_DISCARD)
		return;
	if (ictx->input_len < 1 || *p < '0' || *p > '9')
		return;

	log_debug("%s: \"%s\"", __func__, p);

	option = 0;
	while (*p >= '0' && *p <= '9')
		option = option * 10 + *p++ - '0';
	if (*p == ';')
		p++;

	switch (option) {
	case 0:
	case 2:
		screen_set_title(ictx->ctx.s, p);
		server_status_window(ictx->wp->window);
		break;
	case 4:
		input_osc_4(ictx->wp, p);
		break;
	case 10:
		input_osc_10(ictx->wp, p);
		break;
	case 11:
		input_osc_11(ictx->wp, p);
		break;
	case 12:
		if (*p != '?') /* ? is colour request */
			screen_set_cursor_colour(ictx->ctx.s, p);
		break;
	case 52:
		input_osc_52(ictx->wp, p);
		break;
	case 104:
		input_osc_104(ictx->wp, p);
		break;
	case 112:
		if (*p == '\0') /* no arguments allowed */
			screen_set_cursor_colour(ictx->ctx.s, "");
		break;
	default:
		log_debug("%s: unknown '%u'", __func__, option);
		break;
	}
}

/* APC string started. */
static void
input_enter_apc(struct input_ctx *ictx)
{
	log_debug("%s", __func__);

	input_clear(ictx);
}

/* APC terminator (ST) received. */
static void
input_exit_apc(struct input_ctx *ictx)
{
	if (ictx->flags & INPUT_DISCARD)
		return;
	log_debug("%s: \"%s\"", __func__, ictx->input_buf);

	screen_set_title(ictx->ctx.s, ictx->input_buf);
	server_status_window(ictx->wp->window);
}

/* Rename string started. */
static void
input_enter_rename(struct input_ctx *ictx)
{
	log_debug("%s", __func__);

	input_clear(ictx);
}

/* Rename terminator (ST) received. */
static void
input_exit_rename(struct input_ctx *ictx)
{
	if (ictx->flags & INPUT_DISCARD)
		return;
	if (!options_get_number(ictx->wp->window->options, "allow-rename"))
		return;
	log_debug("%s: \"%s\"", __func__, ictx->input_buf);

	window_set_name(ictx->wp->window, ictx->input_buf);
	options_set_number(ictx->wp->window->options, "automatic-rename", 0);

	server_status_window(ictx->wp->window);
}

/* Open UTF-8 character. */
static int
input_utf8_open(struct input_ctx *ictx)
{
	struct utf8_data	*ud = &ictx->utf8data;

	if (utf8_open(ud, ictx->ch) != UTF8_MORE)
		fatalx("UTF-8 open invalid %#x", ictx->ch);

	log_debug("%s %hhu", __func__, ud->size);

	return (0);
}

/* Append to UTF-8 character. */
static int
input_utf8_add(struct input_ctx *ictx)
{
	struct utf8_data	*ud = &ictx->utf8data;

	if (utf8_append(ud, ictx->ch) != UTF8_MORE)
		fatalx("UTF-8 add invalid %#x", ictx->ch);

	log_debug("%s", __func__);

	return (0);
}

/* Close UTF-8 string. */
static int
input_utf8_close(struct input_ctx *ictx)
{
	struct utf8_data	*ud = &ictx->utf8data;

	if (utf8_append(ud, ictx->ch) != UTF8_DONE) {
		/*
		 * An error here could be invalid UTF-8 or it could be a
		 * nonprintable character for which we can't get the
		 * width. Drop it.
		 */
		return (0);
	}

	log_debug("%s %hhu '%*s' (width %hhu)", __func__, ud->size,
	    (int)ud->size, ud->data, ud->width);

	utf8_copy(&ictx->cell.cell.data, ud);
	screen_write_collect_add(&ictx->ctx, &ictx->cell.cell);

	return (0);
}

/* Handle the OSC 4 sequence for setting (multiple) palette entries. */
static void
input_osc_4(struct window_pane *wp, const char *p)
{
	char	*copy, *s, *next = NULL;
	long	 idx;
	u_int	 r, g, b;

	copy = s = xstrdup(p);
	while (s != NULL && *s != '\0') {
		idx = strtol(s, &next, 10);
		if (*next++ != ';')
			goto bad;
		if (idx < 0 || idx >= 0x100)
			goto bad;

		s = strsep(&next, ";");
		if (sscanf(s, "rgb:%2x/%2x/%2x", &r, &g, &b) != 3) {
			s = next;
			continue;
		}

		window_pane_set_palette(wp, idx, colour_join_rgb(r, g, b));
		s = next;
	}

	free(copy);
	return;

bad:
	log_debug("bad OSC 4: %s", p);
	free(copy);
}

/* Handle the OSC 10 sequence for setting background colour. */
static void
input_osc_10(struct window_pane *wp, const char *p)
{
	u_int	 r, g, b;

	if (sscanf(p, "rgb:%2x/%2x/%2x", &r, &g, &b) != 3)
	    goto bad;

	wp->colgc.fg = colour_join_rgb(r, g, b);
	wp->flags |= PANE_REDRAW;

	return;

bad:
	log_debug("bad OSC 10: %s", p);
}

/* Handle the OSC 11 sequence for setting background colour. */
static void
input_osc_11(struct window_pane *wp, const char *p)
{
	u_int	 r, g, b;

	if (sscanf(p, "rgb:%2x/%2x/%2x", &r, &g, &b) != 3)
	    goto bad;

	wp->colgc.bg = colour_join_rgb(r, g, b);
	wp->flags |= PANE_REDRAW;

	return;

bad:
	log_debug("bad OSC 11: %s", p);
}

/* Handle the OSC 52 sequence for setting the clipboard. */
static void
input_osc_52(struct window_pane *wp, const char *p)
{
	char			*end;
	size_t			 len;
	u_char			*out;
	int			 outlen;
	struct screen_write_ctx	 ctx;

	if ((end = strchr(p, ';')) == NULL)
		return;
	end++;
	if (*end == '\0')
		return;

	len = (strlen(end) / 4) * 3;
	if (len == 0)
		return;

	out = xmalloc(len);
	if ((outlen = b64_pton(end, out, len)) == -1) {
		free(out);
		return;
	}

	if (options_get_number(global_options, "set-clipboard")) {
		screen_write_start(&ctx, wp, NULL);
		screen_write_setselection(&ctx, out, outlen);
		screen_write_stop(&ctx);
	}
	paste_add(out, outlen);
}

/* Handle the OSC 104 sequence for unsetting (multiple) palette entries. */
static void
input_osc_104(struct window_pane *wp, const char *p)
{
	char	*copy, *s;
	long	idx;

	if (*p == '\0') {
		window_pane_reset_palette(wp);
		return;
	}

	copy = s = xstrdup(p);
	while (*s != '\0') {
		idx = strtol(s, &s, 10);
		if (*s != '\0' && *s != ';')
			goto bad;
		if (idx < 0 || idx >= 0x100)
			goto bad;

		window_pane_unset_palette(wp, idx);
		if (*s == ';')
			s++;
	}
	free(copy);
	return;

bad:
	log_debug("bad OSC 104: %s", p);
	free(copy);
}
@


1.121
log
@Scrolling needs to use background colour.
@
text
@d1 1
a1 1
/* $OpenBSD: input.c,v 1.120 2017/05/12 10:50:11 nicm Exp $ */
d113 2
d1905 5
a1909 2
	case 52:
		input_osc_52(ictx->wp, p);
d1915 3
d2061 36
@


1.120
log
@ECH needs to use background colour.
@
text
@d1 1
a1 1
/* $OpenBSD: input.c,v 1.119 2017/04/22 08:33:28 nicm Exp $ */
d1126 1
a1126 1
		screen_write_linefeed(sctx, 0);
d1171 1
a1171 1
		screen_write_linefeed(sctx, 0);
d1175 1
a1175 1
		screen_write_linefeed(sctx, 0);
d1182 1
a1182 1
		screen_write_reverseindex(sctx);
d1420 2
a1421 1
		screen_write_scrollup(sctx, input_get(ictx, 0, 1, 1));
@


1.119
log
@We need to collect UTF-8 characters so that width != 1 characters are
correctly flushed.
@
text
@d1 1
a1 1
/* $OpenBSD: input.c,v 1.118 2017/03/22 07:16:54 nicm Exp $ */
d1311 2
a1312 1
		screen_write_clearcharacter(sctx, input_get(ictx, 0, 1, 1));
@


1.118
log
@Add support for the strikethrough attribute (SGR 9), using the new smxx
terminfo capability. This means there are now nine attribute bits, so
anything above 0xff uses an extended cell.
@
text
@d1 1
a1 1
/* $OpenBSD: input.c,v 1.117 2017/02/19 07:55:11 nicm Exp $ */
d2014 1
a2014 1
	screen_write_cell(&ictx->ctx, &ictx->cell.cell);
@


1.117
log
@Add SGR 28 to clear hidden flag.
@
text
@d1 1
a1 1
/* $OpenBSD: input.c,v 1.116 2017/02/16 12:56:01 nicm Exp $ */
d1767 3
d1787 3
@


1.116
log
@There are buggy terminals out there that do not move the cursor to 0,0
after CSR, so invalidate the cursor position rather than assuming 0,0.
@
text
@d1 1
a1 1
/* $OpenBSD: input.c,v 1.115 2017/02/08 17:31:09 nicm Exp $ */
d1781 3
@


1.115
log
@Add support for scroll up escape sequence (CSI S) and use it when
possible instead of sending individual line feeds.
@
text
@d1 1
a1 1
/* $OpenBSD: input.c,v 1.114 2017/02/08 16:45:18 nicm Exp $ */
d1392 1
a1392 1
			ictx->cell.cell.bg);
@


1.114
log
@Collect sequences of printable ASCII characters and process them
together instead of handling them one by one. This is significantly
faster. Sequences are terminated when we reach the end of the line, fill
the internal buffer, or a different character is seen by the input
parser (an escape sequence, or UTF-8).

Rather than writing collected sequences out immediately, hold them until
it is necessary (another screen modification, or we consume all
available data). This means we can discard changes that would have no
effect (for example, lines that would just be scrolled off the screen or
cleared). This reduces the total amount of data we write out to the
terminal - not important for fast terminals, but a big help with slow
(like xterm).
@
text
@d1 1
a1 1
/* $OpenBSD: input.c,v 1.113 2017/02/08 15:49:29 nicm Exp $ */
d225 1
d247 1
d1417 3
@


1.113
log
@Some other tidying bits.
@
text
@d1 1
a1 1
/* $OpenBSD: input.c,v 1.112 2017/02/06 22:05:11 nicm Exp $ */
d899 10
d1033 1
a1033 1
	screen_write_cell(&ictx->ctx, &ictx->cell.cell);
@


1.112
log
@Use DECFRA on VT420 compatible terminals (so, xterm) and ED on all
others for clearing panes.
@
text
@d1 1
a1 1
/* $OpenBSD: input.c,v 1.111 2017/02/06 19:26:49 nicm Exp $ */
a922 1

@


1.111
log
@Add BCE for clear to start of screen, which was somehow missed.
@
text
@d1 1
a1 1
/* $OpenBSD: input.c,v 1.110 2017/02/06 13:25:15 nicm Exp $ */
d90 1
@


1.110
log
@Fix logging of CSI parameters.
@
text
@d1 1
a1 1
/* $OpenBSD: input.c,v 1.109 2017/02/01 09:55:07 nicm Exp $ */
d1333 1
a1333 1
			screen_write_clearstartofscreen(sctx);
@


1.109
log
@Implement "all event" (1003) mouse mode but in a way that works. The
main issue is that if we have two panes, A with 1002 and B with 1003, we
need to set 1003 outside tmux in order to get all the mouse events, but
then we need to suppress the ones that pane A doesn't want. This is easy
in SGR mouse mode, because buttons == 3 is only used for movement events
(for other events the trailing m/M marks a release instead), but in
normal mouse mode we can't tell so easily. So for that, look at the
previous event instead - if it is drag+release as well, then the current
event is a movement event.
@
text
@d1 1
a1 1
/* $OpenBSD: input.c,v 1.108 2017/01/22 19:00:01 nicm Exp $ */
d874 2
a876 1
	off = 0;
d1222 4
a1227 2
	log_debug("%s: '%c' \"%s\" \"%s\"",
	    __func__, ictx->ch, ictx->interm_buf, ictx->param_buf);
@


1.108
log
@Accept the OSC 52 escape sequence inside tmux to add a new buffer, from
harry dot gindi at live dot com.
@
text
@d1 1
a1 1
/* $OpenBSD: input.c,v 1.107 2017/01/07 15:28:13 nicm Exp $ */
d1480 1
d1563 4
@


1.107
log
@Add support for the OSC 4 and OSC 104 palette setting escape sequences,
from S Gilles.
@
text
@d1 1
a1 1
/* $OpenBSD: input.c,v 1.106 2016/12/09 21:39:27 nicm Exp $ */
d21 3
d112 1
d1869 3
d2019 34
@


1.106
log
@Spacing nits.
@
text
@d1 1
a1 1
/* $OpenBSD: input.c,v 1.105 2016/10/13 20:27:27 nicm Exp $ */
d108 3
d168 1
d186 1
d1149 1
d1197 3
d1862 3
d1869 3
d1978 66
@


1.105
log
@Add support for BCE (background colour erase). This makes various escape
sequences (notable EL and ED but also IL, DL, ICH, DCH) create blank
cells using the current background colour rather than the default
colour.

On modern systems BCE doesn't really have many benefits, but most other
terminals now support it, some (lazy) applications rely on it, and it is
not hard to include now that we have pane background colours anyway.

Mostly written by Sean Haugh.
@
text
@d1 1
a1 1
/* $OpenBSD: input.c,v 1.104 2016/10/03 22:52:11 nicm Exp $ */
d783 1
a783 1
	free (ictx);
@


1.104
log
@Remove some dead code in cmd-move-window.c and make a load of local
functions static.
@
text
@d1 1
a1 1
/* $OpenBSD: input.c,v 1.103 2016/09/28 14:40:07 nicm Exp $ */
d1286 2
a1287 1
		screen_write_deletecharacter(sctx, input_get(ictx, 0, 1, 1));
d1295 2
a1296 1
		screen_write_deleteline(sctx, input_get(ictx, 0, 1, 1));
d1314 1
a1314 1
			screen_write_clearendofscreen(sctx);
d1320 1
a1320 1
			screen_write_clearscreen(sctx);
d1341 1
a1341 1
			screen_write_clearendofline(sctx);
d1344 1
a1344 1
			screen_write_clearstartofline(sctx);
d1347 1
a1347 1
			screen_write_clearline(sctx);
d1359 2
a1360 1
		screen_write_insertcharacter(sctx, input_get(ictx, 0, 1, 1));
d1363 2
a1364 1
		screen_write_insertline(sctx, input_get(ictx, 0, 1, 1));
d1452 2
a1453 1
			screen_write_clearscreen(&ictx->ctx);
d1530 2
a1531 1
			screen_write_clearscreen(&ictx->ctx);
@


1.103
log
@Couple of vasprintf -> xvasprintf.
@
text
@d1 1
a1 1
/* $OpenBSD: input.c,v 1.102 2016/07/15 00:42:56 nicm Exp $ */
d101 6
a106 5
int	input_split(struct input_ctx *);
int	input_get(struct input_ctx *, u_int, int, int);
void printflike(2, 3) input_reply(struct input_ctx *, const char *, ...);
void	input_set_state(struct window_pane *, const struct input_transition *);
void	input_reset_cell(struct input_ctx *);
d109 8
a116 8
void	input_clear(struct input_ctx *);
void	input_ground(struct input_ctx *);
void	input_enter_osc(struct input_ctx *);
void	input_exit_osc(struct input_ctx *);
void	input_enter_apc(struct input_ctx *);
void	input_exit_apc(struct input_ctx *);
void	input_enter_rename(struct input_ctx *);
void	input_exit_rename(struct input_ctx *);
d119 19
a137 19
int	input_print(struct input_ctx *);
int	input_intermediate(struct input_ctx *);
int	input_parameter(struct input_ctx *);
int	input_input(struct input_ctx *);
int	input_c0_dispatch(struct input_ctx *);
int	input_esc_dispatch(struct input_ctx *);
int	input_csi_dispatch(struct input_ctx *);
void	input_csi_dispatch_rm(struct input_ctx *);
void	input_csi_dispatch_rm_private(struct input_ctx *);
void	input_csi_dispatch_sm(struct input_ctx *);
void	input_csi_dispatch_sm_private(struct input_ctx *);
void	input_csi_dispatch_winops(struct input_ctx *);
void	input_csi_dispatch_sgr_256(struct input_ctx *, int, u_int *);
void	input_csi_dispatch_sgr_rgb(struct input_ctx *, int, u_int *);
void	input_csi_dispatch_sgr(struct input_ctx *);
int	input_dcs_dispatch(struct input_ctx *);
int	input_utf8_open(struct input_ctx *);
int	input_utf8_add(struct input_ctx *);
int	input_utf8_close(struct input_ctx *);
d140 1
a140 1
int	input_table_compare(const void *, const void *);
d168 1
a168 1
const struct input_table_entry input_esc_table[] = {
d221 1
a221 1
const struct input_table_entry input_csi_table[] = {
d280 20
a299 20
const struct input_transition input_state_ground_table[];
const struct input_transition input_state_esc_enter_table[];
const struct input_transition input_state_esc_intermediate_table[];
const struct input_transition input_state_csi_enter_table[];
const struct input_transition input_state_csi_parameter_table[];
const struct input_transition input_state_csi_intermediate_table[];
const struct input_transition input_state_csi_ignore_table[];
const struct input_transition input_state_dcs_enter_table[];
const struct input_transition input_state_dcs_parameter_table[];
const struct input_transition input_state_dcs_intermediate_table[];
const struct input_transition input_state_dcs_handler_table[];
const struct input_transition input_state_dcs_escape_table[];
const struct input_transition input_state_dcs_ignore_table[];
const struct input_transition input_state_osc_string_table[];
const struct input_transition input_state_apc_string_table[];
const struct input_transition input_state_rename_string_table[];
const struct input_transition input_state_consume_st_table[];
const struct input_transition input_state_utf8_three_table[];
const struct input_transition input_state_utf8_two_table[];
const struct input_transition input_state_utf8_one_table[];
d302 1
a302 1
const struct input_state input_state_ground = {
d309 1
a309 1
const struct input_state input_state_esc_enter = {
d316 1
a316 1
const struct input_state input_state_esc_intermediate = {
d323 1
a323 1
const struct input_state input_state_csi_enter = {
d330 1
a330 1
const struct input_state input_state_csi_parameter = {
d337 1
a337 1
const struct input_state input_state_csi_intermediate = {
d344 1
a344 1
const struct input_state input_state_csi_ignore = {
d351 1
a351 1
const struct input_state input_state_dcs_enter = {
d358 1
a358 1
const struct input_state input_state_dcs_parameter = {
d365 1
a365 1
const struct input_state input_state_dcs_intermediate = {
d372 1
a372 1
const struct input_state input_state_dcs_handler = {
d379 1
a379 1
const struct input_state input_state_dcs_escape = {
d386 1
a386 1
const struct input_state input_state_dcs_ignore = {
d393 1
a393 1
const struct input_state input_state_osc_string = {
d400 1
a400 1
const struct input_state input_state_apc_string = {
d407 1
a407 1
const struct input_state input_state_rename_string = {
d414 1
a414 1
const struct input_state input_state_consume_st = {
d421 1
a421 1
const struct input_state input_state_utf8_three = {
d428 1
a428 1
const struct input_state input_state_utf8_two = {
d435 1
a435 1
const struct input_state input_state_utf8_one = {
d442 1
a442 1
const struct input_transition input_state_ground_table[] = {
d460 1
a460 1
const struct input_transition input_state_esc_enter_table[] = {
d487 1
a487 1
const struct input_transition input_state_esc_intermediate_table[] = {
d501 1
a501 1
const struct input_transition input_state_csi_enter_table[] = {
d519 1
a519 1
const struct input_transition input_state_csi_parameter_table[] = {
d537 1
a537 1
const struct input_transition input_state_csi_intermediate_table[] = {
d552 1
a552 1
const struct input_transition input_state_csi_ignore_table[] = {
d566 1
a566 1
const struct input_transition input_state_dcs_enter_table[] = {
d584 1
a584 1
const struct input_transition input_state_dcs_parameter_table[] = {
d602 1
a602 1
const struct input_transition input_state_dcs_intermediate_table[] = {
d617 1
a617 1
const struct input_transition input_state_dcs_handler_table[] = {
d628 1
a628 1
const struct input_transition input_state_dcs_escape_table[] = {
d639 1
a639 1
const struct input_transition input_state_dcs_ignore_table[] = {
d651 1
a651 1
const struct input_transition input_state_osc_string_table[] = {
d665 1
a665 1
const struct input_transition input_state_apc_string_table[] = {
d677 1
a677 1
const struct input_transition input_state_rename_string_table[] = {
d689 1
a689 1
const struct input_transition input_state_consume_st_table[] = {
d701 1
a701 1
const struct input_transition input_state_utf8_three_table[] = {
d712 1
a712 1
const struct input_transition input_state_utf8_two_table[] = {
d723 1
a723 1
const struct input_transition input_state_utf8_one_table[] = {
d734 1
a734 1
int
d746 1
a746 1
void
d825 1
a825 1
void
d910 1
a910 1
int
d941 1
a941 1
int
d958 1
a958 1
void
d973 1
a973 1
void
d989 1
a989 1
void
d1001 1
a1001 1
int
d1021 1
a1021 1
int
d1035 1
a1035 1
int
d1049 1
a1049 1
int
d1071 1
a1071 1
int
d1124 1
a1124 1
int
d1197 1
a1197 1
int
d1414 1
a1414 1
void
d1435 1
a1435 1
void
d1491 1
a1491 1
void
d1512 1
a1512 1
void
d1574 1
a1574 1
void
d1623 1
a1623 1
void
d1645 1
a1645 1
void
d1671 1
a1671 1
void
d1791 1
a1791 1
int
d1813 1
a1813 1
void
d1822 1
a1822 1
void
d1862 1
a1862 1
void
d1871 1
a1871 1
void
d1883 1
a1883 1
void
d1892 1
a1892 1
void
d1908 1
a1908 1
int
d1922 1
a1922 1
int
d1936 1
a1936 1
int
@


1.102
log
@Instead of representing colours in several different forms with various
cell flags, convert to use an int with flags marking 256 or RGB colours
in the top byte (except in cells, which we don't want to make any
bigger). From Brad Town.
@
text
@d1 1
a1 1
/* $OpenBSD: input.c,v 1.101 2016/03/02 15:36:02 nicm Exp $ */
d964 1
a964 1
	vasprintf(&reply, fmt, ap);
@


1.101
log
@Handle wcwidth() and mbtowc() failures in better style and drop
characters where we can't find the width (wcwidth() fails) on input, the
same as we drop invalid UTF-8. Suggested by schwarze@@.
@
text
@d1 1
a1 1
/* $OpenBSD: input.c,v 1.100 2016/01/29 11:13:56 nicm Exp $ */
d1631 1
a1631 2
		if (fgbg == 38) {
			gc->flags &= ~(GRID_FLAG_FG256|GRID_FLAG_FGRGB);
d1633 1
a1633 2
		} else if (fgbg == 48) {
			gc->flags &= ~(GRID_FLAG_BG256|GRID_FLAG_BGRGB);
a1634 1
		}
d1636 4
a1639 9
		if (fgbg == 38) {
			gc->flags |= GRID_FLAG_FG256;
			gc->flags &= ~GRID_FLAG_FGRGB;
			gc->fg = c;
		} else if (fgbg == 48) {
			gc->flags |= GRID_FLAG_BG256;
			gc->flags &= ~GRID_FLAG_BGRGB;
			gc->bg = c;
		}
d1663 4
a1666 13
	if (fgbg == 38) {
		gc->flags &= ~GRID_FLAG_FG256;
		gc->flags |= GRID_FLAG_FGRGB;
		gc->fg_rgb.r = r;
		gc->fg_rgb.g = g;
		gc->fg_rgb.b = b;
	} else if (fgbg == 48) {
		gc->flags &= ~GRID_FLAG_BG256;
		gc->flags |= GRID_FLAG_BGRGB;
		gc->bg_rgb.r = r;
		gc->bg_rgb.g = g;
		gc->bg_rgb.b = b;
	}
a1746 1
			gc->flags &= ~(GRID_FLAG_FG256|GRID_FLAG_FGRGB);
a1749 1
			gc->flags &= ~(GRID_FLAG_FG256|GRID_FLAG_FGRGB);
a1759 1
			gc->flags &= ~(GRID_FLAG_BG256|GRID_FLAG_BGRGB);
a1762 1
			gc->flags &= ~(GRID_FLAG_BG256|GRID_FLAG_BGRGB);
a1772 1
			gc->flags &= ~(GRID_FLAG_FG256|GRID_FLAG_FGRGB);
a1782 1
			gc->flags &= ~(GRID_FLAG_BG256|GRID_FLAG_BGRGB);
@


1.100
log
@Support for RGB colour, using the extended cell mechanism to avoid
wasting unnecessary space. The 'Tc' flag must be set in the external
TERM entry (using terminal-overrides or a custom terminfo entry), if not
tmux will map to the closest of the 256 or 16 colour palettes.

Mostly from Suraj N Kurapati, based on a diff originally by someone else.
@
text
@d1 1
a1 1
/* $OpenBSD: input.c,v 1.99 2016/01/19 15:59:12 nicm Exp $ */
d1963 8
a1970 2
	if (utf8_append(ud, ictx->ch) != UTF8_DONE)
		fatalx("UTF-8 close invalid %#x", ictx->ch);
@


1.99
log
@I no longer use my SourceForge address so replace it.
@
text
@d1 1
a1 1
/* $OpenBSD: input.c,v 1.98 2016/01/15 11:31:47 nicm Exp $ */
d1632 1
a1632 1
			gc->flags &= ~GRID_FLAG_FG256;
d1635 1
a1635 1
			gc->flags &= ~GRID_FLAG_BG256;
d1641 1
d1645 1
d1656 1
a1656 1
	int			 c, r, g, b;
a1670 1
	c = colour_find_rgb(r, g, b);
d1672 5
a1676 2
		gc->flags |= GRID_FLAG_FG256;
		gc->fg = c;
d1678 5
a1682 2
		gc->flags |= GRID_FLAG_BG256;
		gc->bg = c;
d1764 1
a1764 1
			gc->flags &= ~GRID_FLAG_FG256;
d1768 1
a1768 1
			gc->flags &= ~GRID_FLAG_FG256;
d1779 1
a1779 1
			gc->flags &= ~GRID_FLAG_BG256;
d1783 1
a1783 1
			gc->flags &= ~GRID_FLAG_BG256;
d1794 1
a1794 1
			gc->flags &= ~GRID_FLAG_FG256;
d1805 1
a1805 1
			gc->flags &= ~GRID_FLAG_BG256;
@


1.98
log
@A couple of missing printflike attributes, from Andrey Starodubtsev.
@
text
@d1 1
a1 1
/* $OpenBSD: input.c,v 1.97 2015/12/16 22:05:35 nicm Exp $ */
d4 1
a4 1
 * Copyright (c) 2007 Nicholas Marriott <nicm@@users.sourceforge.net>
@


1.97
log
@send-keys -R should reset the input parser to ground state (so it can be
used to escape from, for example, printf '\033]2;').
@
text
@d1 1
a1 1
/* $OpenBSD: input.c,v 1.96 2015/11/23 23:47:57 nicm Exp $ */
d103 1
a103 1
void	input_reply(struct input_ctx *, const char *, ...);
@


1.96
log
@Partly revert previous, it is harmless to keep support for UTF-8 mouse
mode inside tmux, just no longer support it for tmux itself.
@
text
@d1 1
a1 1
/* $OpenBSD: input.c,v 1.95 2015/11/23 20:53:09 nicm Exp $ */
a764 8
	input_reset_cell(ictx);

	*ictx->interm_buf = '\0';
	ictx->interm_len = 0;

	*ictx->param_buf = '\0';
	ictx->param_len = 0;

d768 1
a768 5
	*ictx->input_buf = '\0';
	ictx->input_len = 0;

	ictx->state = &input_state_ground;
	ictx->flags = 0;
d770 1
a770 1
	ictx->since_ground = evbuffer_new();
d788 1
a788 1
input_reset(struct window_pane *wp)
d794 20
a813 6
	if (wp->mode == NULL)
		screen_write_start(&ictx->ctx, wp, &wp->base);
	else
		screen_write_start(&ictx->ctx, NULL, &wp->base);
	screen_write_reset(&ictx->ctx);
	screen_write_stop(&ictx->ctx);
@


1.95
log
@Remove support for the UTF-8 mouse extension. This was a briefly used,
poor idea that was fairly quickly replaced by SGR mouse input (which is
now widespread). It is impossible to tell the difference between UTF-8
and non-UTF-8 mouse input; since the mouse-utf8 option was removed tmux
has not handled it correctly in any case; and it is ridiculous to have
three different forms of mouse input.
@
text
@d1 1
a1 1
/* $OpenBSD: input.c,v 1.94 2015/11/18 13:06:54 nicm Exp $ */
d1464 3
d1546 3
@


1.94
log
@Sync the entire xmalloc.[ch] with the other users, but with the addition
of xrealloc, xvasprintf, xvsnprintf.
@
text
@d1 1
a1 1
/* $OpenBSD: input.c,v 1.93 2015/11/14 12:20:19 nicm Exp $ */
a1463 3
		case 1005:
			screen_write_mode_clear(&ictx->ctx, MODE_MOUSE_UTF8);
			break;
a1542 3
			break;
		case 1005:
			screen_write_mode_set(&ictx->ctx, MODE_MOUSE_UTF8);
@


1.93
log
@The character is an int so use %x not %hhx.
@
text
@d1 1
a1 1
/* $OpenBSD: input.c,v 1.92 2015/11/14 11:45:43 nicm Exp $ */
d1927 1
a1927 1
		log_fatalx("UTF-8 open invalid %#x", ictx->ch);
d1941 1
a1941 1
		log_fatalx("UTF-8 add invalid %#x", ictx->ch);
d1955 1
a1955 1
		log_fatalx("UTF-8 close invalid %#x", ictx->ch);
@


1.92
log
@All these return values from utf8_* are confusing, use an enum.
@
text
@d1 1
a1 1
/* $OpenBSD: input.c,v 1.91 2015/11/14 10:56:31 nicm Exp $ */
d1927 1
a1927 1
		log_fatalx("UTF-8 open invalid %#hhx", ictx->ch);
d1941 1
a1941 1
		log_fatalx("UTF-8 add invalid %#hhx", ictx->ch);
d1955 1
a1955 1
		log_fatalx("UTF-8 close invalid %#hhx", ictx->ch);
@


1.91
log
@Be more strict about invalid UTF-8.
@
text
@d1 1
a1 1
/* $OpenBSD: input.c,v 1.90 2015/11/14 08:25:12 nicm Exp $ */
d1926 1
a1926 1
	if (!utf8_open(ud, ictx->ch))
d1940 1
a1940 1
	if (utf8_append(ud, ictx->ch) != 1)
d1954 1
a1954 1
	if (utf8_append(ud, ictx->ch) != 0)
@


1.90
log
@Log more of UTF-8 input.
@
text
@d1 1
a1 1
/* $OpenBSD: input.c,v 1.89 2015/11/13 08:09:28 nicm Exp $ */
d449 1
a449 1
	{ 0x80, 0xc1, input_print,	 NULL },
d453 1
a453 1
	{ 0xf5, 0xff, input_print,	 NULL },
d1926 2
a1927 1
	utf8_open(ud, ictx->ch);
d1940 2
a1941 1
	utf8_append(ud, ictx->ch);
d1954 2
a1955 1
	utf8_append(ud, ictx->ch);
@


1.89
log
@Long overdue change to the way we store cells in the grid: now, instead
of storing a full grid_cell with UTF-8 data and everything, store a new
type grid_cell_entry. This can either be the cell itself (for ASCII
cells), or an offset into an extended array (per line) for UTF-8
data.

This avoid a large (8 byte) overhead on non-UTF-8 cells (by far the
majority for most users) without the complexity of the shadow array we
had before. Grid memory without any UTF-8 is about half.

The disadvantage that cells can no longer be modified in place and need
to be copied out of the grid and back but it turned out to be lot less
complicated than I expected.
@
text
@d1 1
a1 1
/* $OpenBSD: input.c,v 1.88 2015/11/12 11:09:11 nicm Exp $ */
d1924 5
a1928 1
	log_debug("%s", __func__);
a1929 1
	utf8_open(&ictx->utf8data, ictx->ch);
d1937 4
a1942 1
	utf8_append(&ictx->utf8data, ictx->ch);
d1950 3
a1952 1
	log_debug("%s", __func__);
d1954 2
a1955 1
	utf8_append(&ictx->utf8data, ictx->ch);
d1957 1
a1957 1
	utf8_copy(&ictx->cell.cell.data, &ictx->utf8data);
@


1.88
log
@Nuke the utf8 and status-utf8 options and make tmux only a UTF-8
terminal. We still support non-UTF-8 terminals outside tmux, but inside
it is always UTF-8 (as when the utf8 and status-utf8 options were on).
@
text
@d1 1
a1 1
/* $OpenBSD: input.c,v 1.87 2015/10/27 15:58:42 nicm Exp $ */
d1009 1
a1009 1
	grid_cell_one(&ictx->cell.cell, ictx->ch);
d1948 1
a1948 1
	grid_cell_set(&ictx->cell.cell, &ictx->utf8data);
@


1.87
log
@Move struct options into options.c.
@
text
@d1 1
a1 1
/* $OpenBSD: input.c,v 1.86 2015/09/02 17:52:57 nicm Exp $ */
a1923 5
	if (!options_get_number(ictx->wp->window->options, "utf8")) {
		/* Print, and do not switch state. */
		input_print(ictx);
		return (-1);
	}
@


1.86
log
@Log pane which received input data.
@
text
@d1 1
a1 1
/* $OpenBSD: input.c,v 1.85 2015/09/01 19:50:09 nicm Exp $ */
d1910 1
a1910 1
	if (!options_get_number(&ictx->wp->window->options, "allow-rename"))
d1915 1
a1915 1
	options_set_number(&ictx->wp->window->options, "automatic-rename", 0);
d1924 1
a1924 1
	if (!options_get_number(&ictx->wp->window->options, "utf8")) {
@


1.85
log
@Tweak some error messages/comments.
@
text
@d1 1
a1 1
/* $OpenBSD: input.c,v 1.84 2015/09/01 19:16:00 nicm Exp $ */
d865 2
a866 2
	log_debug("%s: %s, %zu bytes: %.*s", __func__, ictx->state->name, len,
	    (int)len, buf);
@


1.84
log
@Log the whole new input buffer once rather than each byte.
@
text
@d1 1
a1 1
/* $OpenBSD: input.c,v 1.83 2015/08/29 08:30:54 nicm Exp $ */
d881 1
a881 1
			fatalx("No transition from state!");
@


1.83
log
@Move alerts onto events rather than checking every loop.
@
text
@d1 1
a1 1
/* $OpenBSD: input.c,v 1.82 2015/08/28 07:49:24 nicm Exp $ */
d865 3
a870 1
		log_debug("%s: '%c' %s", __func__, ictx->ch, ictx->state->name);
d1075 1
a1075 1
	log_debug("%s: '%c", __func__, ictx->ch);
@


1.82
log
@Only do the automatic-rename dance if the pane has changed (seen output,
or new active pane).
@
text
@d1 1
a1 1
/* $OpenBSD: input.c,v 1.81 2015/08/25 15:00:05 nicm Exp $ */
d847 1
a849 6
	wp->window->flags |= WINDOW_ACTIVITY;
	wp->window->flags &= ~WINDOW_SILENCE;

	if (gettimeofday(&wp->window->activity_time, NULL) != 0)
		fatal("gettimeofday failed");

d1079 1
a1079 1
		wp->window->flags |= WINDOW_BELL;
@


1.81
log
@When searching for tabs, start from screen width, fixes out-of-bounds
read found by Kuang-che Wu.
@
text
@d1 1
a1 1
/* $OpenBSD: input.c,v 1.80 2015/07/13 18:45:18 nicm Exp $ */
d846 2
@


1.80
log
@Reset G0/G1 state when resetting everything else with send-keys -R.
@
text
@d1 1
a1 1
/* $OpenBSD: input.c,v 1.79 2015/06/15 10:58:01 nicm Exp $ */
d1202 1
d1221 3
d1225 1
a1225 1
		while (s->cx > 0 && n-- > 0) {
d1227 2
a1228 2
				s->cx--;
			while (s->cx > 0 && !bit_test(s->tabs, s->cx));
d1230 1
@


1.79
log
@Add window_activity format, from Thomas Adam based on a diff originally
from propos6 at gmail dot com.
@
text
@d1 1
a1 1
/* $OpenBSD: input.c,v 1.78 2015/06/05 22:33:39 nicm Exp $ */
d804 1
a804 4
	memcpy(&ictx->cell, &grid_default_cell, sizeof ictx->cell);
	memcpy(&ictx->old_cell, &ictx->cell, sizeof ictx->old_cell);
	ictx->old_cx = 0;
	ictx->old_cy = 0;
@


1.78
log
@Handle the RGB colour escape sequence (\033[38;2;<r>;<g>;<b>m and 48;2)
like xterm(1) does, by mapping to the nearest in the 256 colour palette.
@
text
@d1 1
a1 1
/* $OpenBSD: input.c,v 1.77 2015/06/04 09:42:29 nicm Exp $ */
d23 1
d852 3
@


1.77
log
@teminal -> terminal, from Corey Farwell.
@
text
@d1 1
a1 1
/* $OpenBSD: input.c,v 1.76 2015/06/01 13:59:57 nicm Exp $ */
d129 2
d1614 58
d1678 1
a1678 1
	int			 n, m;
d1690 7
a1696 22
			if (input_get(ictx, i, 0, -1) != 5)
				continue;

			i++;
			m = input_get(ictx, i, 0, -1);
			if (m == -1) {
				if (n == 38) {
					gc->flags &= ~GRID_FLAG_FG256;
					gc->fg = 8;
				} else if (n == 48) {
					gc->flags &= ~GRID_FLAG_BG256;
					gc->bg = 8;
				}

			} else {
				if (n == 38) {
					gc->flags |= GRID_FLAG_FG256;
					gc->fg = m;
				} else if (n == 48) {
					gc->flags |= GRID_FLAG_BG256;
					gc->bg = m;
				}
@


1.76
log
@Missing t at end of response, from Vincent Bernat.
@
text
@d1 1
a1 1
/* $OpenBSD: input.c,v 1.75 2015/05/11 10:10:16 nicm Exp $ */
d46 1
a46 1
 *   be passed to the underlying teminal(s).
@


1.75
log
@Remove the c0-* options which never really worked satisfactorily. Going
to try something else...
@
text
@d1 1
a1 1
/* $OpenBSD: input.c,v 1.74 2015/05/08 16:18:04 nicm Exp $ */
d1602 1
a1602 1
			input_reply(ictx, "\033[8;%u;%u", wp->sy, wp->sx);
@


1.74
log
@Move input parser structs into input.c (removing fairly useless
saved_cursor_[xy] formats as a side-effect).
@
text
@d1 1
a1 1
/* $OpenBSD: input.c,v 1.73 2015/03/31 17:45:10 nicm Exp $ */
a1071 1
	u_int			 trigger;
d1083 1
a1083 1
		goto count_c0;
d1100 1
a1100 1
		goto count_c0;
d1103 1
a1103 1
		goto count_c0;
a1112 9
	}

	return (0);

count_c0:
	trigger = options_get_number(&wp->window->options, "c0-change-trigger");
	if (trigger != 0 && ++wp->changes >= trigger) {
		wp->flags |= PANE_DROP;
		window_pane_timer_start(wp);
@


1.73
log
@Fix some format specifier nits, from Ben Boeckel.
@
text
@d1 1
a1 1
/* $OpenBSD: input.c,v 1.72 2015/01/20 08:18:04 nicm Exp $ */
d49 49
d758 3
a760 1
	struct input_ctx	*ictx = &wp->ictx;
d786 14
a799 2
	if (wp == NULL)
		return;
d801 18
a818 2
	free(wp->ictx.input_buf);
	evbuffer_free(wp->ictx.since_ground);
d825 1
a825 1
	struct input_ctx	*ictx = &wp->ictx;
d838 1
a838 1
	struct input_ctx		*ictx = &wp->ictx;
@


1.72
log
@Support blinking cursor mode, both the xterm CSI ?12 h/l and (the
backwards) screen CSI 34 h/l. From Guanpeng Xu.
@
text
@d1 1
a1 1
/* $OpenBSD: input.c,v 1.71 2014/10/08 17:35:58 nicm Exp $ */
d1720 1
a1720 1
	int	 option;
@


1.71
log
@Add xreallocarray and remove nmemb argument from xrealloc.
@
text
@d1 1
a1 1
/* $OpenBSD: input.c,v 1.70 2014/08/09 07:33:37 nicm Exp $ */
d1345 3
d1374 3
d1422 3
d1450 3
@


1.70
log
@Remove support for the continuous reporting "any" mouse mode which never
really worked properly and is rarely used.
@
text
@d1 1
a1 1
/* $OpenBSD: input.c,v 1.69 2014/06/06 13:21:41 nicm Exp $ */
d912 1
a912 1
		ictx->input_buf = xrealloc(ictx->input_buf, 1, INPUT_BUF_START);
d977 1
a977 1
		ictx->input_buf = xrealloc(ictx->input_buf, 1, available);
@


1.69
log
@Properly track switching G0 and G1 modes between US-ASCII and VT100 line
drawing rather than just treating them as SO and SI.
@
text
@d1 1
a1 1
/* $OpenBSD: input.c,v 1.68 2014/06/05 22:14:29 nicm Exp $ */
a1376 1
		case 1003:
a1451 4
			break;
		case 1003:
			screen_write_mode_clear(&ictx->ctx, ALL_MOUSE_MODES);
			screen_write_mode_set(&ictx->ctx, MODE_MOUSE_ANY);
@


1.68
log
@Reset properly when c0-change-trigger is increased from zero so panes
don't get stuck.
@
text
@d1 1
a1 1
/* $OpenBSD: input.c,v 1.67 2014/04/17 12:43:38 nicm Exp $ */
d55 1
d108 4
a111 2
	INPUT_ESC_SCSOFF_G0,
	INPUT_ESC_SCSON_G0,
d116 2
a117 1
	{ '0', "(", INPUT_ESC_SCSOFF_G0 },
d123 2
a124 1
	{ 'B', "(", INPUT_ESC_SCSON_G0 },
d692 13
d711 1
a711 5
	memcpy(&ictx->cell, &grid_default_cell, sizeof ictx->cell);

	memcpy(&ictx->old_cell, &grid_default_cell, sizeof ictx->old_cell);
	ictx->old_cx = 0;
	ictx->old_cy = 0;
d920 12
a931 2
	grid_cell_one(&ictx->cell, ictx->ch);
	screen_write_cell(&ictx->ctx, &ictx->cell);
d1027 1
a1027 1
		ictx->cell.attr |= GRID_ATTR_CHARSET;
d1030 1
a1030 1
		ictx->cell.attr &= ~GRID_ATTR_CHARSET;
d1070 1
a1070 5
		memcpy(&ictx->cell, &grid_default_cell, sizeof ictx->cell);
		memcpy(&ictx->old_cell, &ictx->cell, sizeof ictx->old_cell);
		ictx->old_cx = 0;
		ictx->old_cy = 0;

d1105 8
a1112 7
	case INPUT_ESC_SCSON_G0:
		/*
		 * Not really supported, but fake it up enough for those that
		 * use it to switch character sets (by redefining G0 to
		 * graphics set, rather than switching to G1).
		 */
		ictx->cell.attr &= ~GRID_ATTR_CHARSET;
d1114 2
a1115 2
	case INPUT_ESC_SCSOFF_G0:
		ictx->cell.attr |= GRID_ATTR_CHARSET;
d1356 2
a1357 1
	u_int	i;
d1391 1
a1391 1
			window_pane_alternate_off(ictx->wp, &ictx->cell, 0);
d1394 1
a1394 1
			window_pane_alternate_off(ictx->wp, &ictx->cell, 1);
d1428 2
a1429 1
	u_int	i;
d1462 1
a1462 1
			ictx->wp->flags |= PANE_FOCUSPUSH; /* force update */
d1472 1
a1472 1
			window_pane_alternate_on(ictx->wp, &ictx->cell, 0);
d1475 1
a1475 1
			window_pane_alternate_on(ictx->wp, &ictx->cell, 1);
d1540 1
a1540 1
	struct grid_cell	*gc = &ictx->cell;
a1542 1
	u_char			 attr;
a1544 1
		attr = gc->attr;
a1545 1
		gc->attr |= (attr & GRID_ATTR_CHARSET);
a1582 1
			attr = gc->attr;
a1583 1
			gc->attr |= (attr & GRID_ATTR_CHARSET);
d1827 2
a1828 2
	grid_cell_set(&ictx->cell, &ictx->utf8data);
	screen_write_cell(&ictx->ctx, &ictx->cell);
@


1.67
log
@Don't limit the DCS buffer to 256 bytes, expand it as needed. Requested
by Suraj Kurapati.
@
text
@d1 1
a1 1
/* $OpenBSD: input.c,v 1.66 2014/03/31 21:32:00 nicm Exp $ */
d1017 1
a1017 1
	if (++wp->changes == trigger) {
@


1.66
log
@Change secondary device attributes response to \033[>84;0;0c which is
unique for tmux.
@
text
@d1 1
a1 1
/* $OpenBSD: input.c,v 1.65 2014/01/31 11:17:20 nicm Exp $ */
d58 1
d246 1
a246 1
	NULL, NULL,
d705 6
d721 5
a725 2
	if (wp != NULL)
		evbuffer_free(wp->ictx.since_ground);
a732 1
	struct evbuffer		*ground_evb = ictx->since_ground;
a735 4

	if (itr->state == &input_state_ground)
		evbuffer_drain(ground_evb, EVBUFFER_LENGTH(ground_evb));

d890 12
d944 11
a954 5
	if (ictx->input_len == (sizeof ictx->input_buf) - 1)
		ictx->flags |= INPUT_DISCARD;
	else {
		ictx->input_buf[ictx->input_len++] = ictx->ch;
		ictx->input_buf[ictx->input_len] = '\0';
d956 2
d1694 2
a1695 2
	u_char *p = ictx->input_buf;
	int	option;
@


1.65
log
@Add \033[18t window operations from J Raynor.
@
text
@d1 1
a1 1
/* $OpenBSD: input.c,v 1.64 2013/10/10 11:57:14 nicm Exp $ */
d1150 1
a1150 1
			input_reply(ictx, "\033[>0;95;0c");
@


1.64
log
@Accept multiple parameters to SM/RM/DECSET/DECRST, based on a diff from
Hayaki Saito.
@
text
@d1 1
a1 1
/* $OpenBSD: input.c,v 1.63 2013/06/23 12:51:28 nicm Exp $ */
d77 1
d158 1
d193 1
d1083 1
a1083 1
	int			 	n, m;
d1123 3
d1436 49
@


1.63
log
@Always push a focus event when the application turns it on, prompted by
discussion with Hayaki Saito a while ago.
@
text
@d1 1
a1 1
/* $OpenBSD: input.c,v 1.62 2013/03/24 09:18:16 nicm Exp $ */
d73 4
a1077 1
	struct window_pane	       *wp = ictx->wp;
d1236 54
a1289 1
		switch (input_get(ictx, 0, 0, -1)) {
d1297 12
a1308 4
		break;
	case INPUT_CSI_RM_PRIVATE:
		switch (input_get(ictx, 0, 0, -1)) {
		case 1:		/* GATM */
d1338 1
a1338 1
			window_pane_alternate_off(wp, &ictx->cell, 0);
d1341 1
a1341 1
			window_pane_alternate_off(wp, &ictx->cell, 1);
d1350 11
a1360 11
		break;
	case INPUT_CSI_SCP:
		memcpy(&ictx->old_cell, &ictx->cell, sizeof ictx->old_cell);
		ictx->old_cx = s->cx;
		ictx->old_cy = s->cy;
		break;
	case INPUT_CSI_SGR:
		input_csi_dispatch_sgr(ictx);
		break;
	case INPUT_CSI_SM:
		switch (input_get(ictx, 0, 0, -1)) {
d1368 12
a1379 4
		break;
	case INPUT_CSI_SM_PRIVATE:
		switch (input_get(ictx, 0, 0, -1)) {
		case 1:		/* GATM */
d1405 1
a1405 1
			if (s->mode & MODE_FOCUSON)
d1408 1
a1408 1
			wp->flags |= PANE_FOCUSPUSH; /* force update */
d1418 1
a1418 1
			window_pane_alternate_on(wp, &ictx->cell, 0);
d1421 1
a1421 1
			window_pane_alternate_on(wp, &ictx->cell, 1);
a1429 23
		break;
	case INPUT_CSI_TBC:
		switch (input_get(ictx, 0, 0, 0)) {
		case 0:
			if (s->cx < screen_size_x(s))
				bit_clear(s->tabs, s->cx);
			break;
		case 3:
			bit_nclear(s->tabs, 0, screen_size_x(s) - 1);
			break;
		default:
			log_debug("%s: unknown '%c'", __func__, ictx->ch);
			break;
		}
		break;
	case INPUT_CSI_VPA:
		n = input_get(ictx, 0, 1, 1);
		screen_write_cursormove(sctx, s->cx, n - 1);
		break;
	case INPUT_CSI_DECSCUSR:
		n = input_get(ictx, 0, 0, 0);
		screen_set_cursor_style(s, n);
		break;
a1430 2

	return (0);
@


1.62
log
@Add support for focus notifications when tmux pane changes, based on
work by Aaron Jensen.
@
text
@d1 1
a1 1
/* $OpenBSD: input.c,v 1.61 2013/03/22 10:36:53 nicm Exp $ */
d1336 1
a1336 1
			wp->flags &= ~PANE_FOCUSED; /* force update if needed */
@


1.61
log
@Implement DECAWM (SM/RM 7) using existing MODE_WRAP flag.
@
text
@d1 1
a1 1
/* $OpenBSD: input.c,v 1.60 2013/03/22 10:33:50 nicm Exp $ */
d1263 3
d1331 6
@


1.60
log
@Support the latest theory for mouse input, this is enabled/disabled with
SM/RM 1006 and is similar in style to SGR input: \033[<b;x;yM or
\033[b;x;ym. From Egmont Koblinger.
@
text
@d1 1
a1 1
/* $OpenBSD: input.c,v 1.59 2013/03/21 18:47:56 nicm Exp $ */
d1251 3
d1310 3
@


1.59
log
@Instead of loads of little screen_write_*_on and off functions which
just change mode flags, just have screen_write_mode_set and
screen_write_mode_clear.
@
text
@d1 1
a1 1
/* $OpenBSD: input.c,v 1.58 2013/01/18 02:16:21 nicm Exp $ */
d1263 3
d1325 3
@


1.58
log
@Rather than having two grids for each pane, one for ASCII and one for
UTF-8, collapse the two together. Simplifies the code at the expense of
more memory (which can probably be reduced again later).
@
text
@d1 1
a1 1
/* $OpenBSD: input.c,v 1.57 2013/01/17 20:30:43 nicm Exp $ */
d1036 1
a1036 1
		screen_write_kkeypadmode(sctx, 1);
d1039 1
a1039 1
		screen_write_kkeypadmode(sctx, 0);
d1235 1
a1235 1
			screen_write_insertmode(&ictx->ctx, 0);
d1245 1
a1245 1
			screen_write_kcursormode(&ictx->ctx, 0);
d1252 1
a1252 1
			screen_write_cursormode(&ictx->ctx, 0);
d1258 1
a1258 1
			screen_write_mousemode_off(&ictx->ctx);
d1261 1
a1261 1
			screen_write_utf8mousemode(&ictx->ctx, 0);
d1271 1
a1271 1
			screen_write_bracketpaste(&ictx->ctx, 0);
d1289 1
a1289 1
			screen_write_insertmode(&ictx->ctx, 1);
d1299 1
a1299 1
			screen_write_kcursormode(&ictx->ctx, 1);
d1306 1
a1306 1
			screen_write_cursormode(&ictx->ctx, 1);
d1309 2
a1310 2
			screen_write_mousemode_on(
			    &ictx->ctx, MODE_MOUSE_STANDARD);
d1313 2
a1314 2
			screen_write_mousemode_on(
			    &ictx->ctx, MODE_MOUSE_BUTTON);
d1317 2
a1318 1
			screen_write_mousemode_on(&ictx->ctx, MODE_MOUSE_ANY);
d1321 1
a1321 1
			screen_write_utf8mousemode(&ictx->ctx, 1);
d1331 1
a1331 1
			screen_write_bracketpaste(&ictx->ctx, 1);
@


1.57
log
@Do not allow cursor colours to be set beginning with ? as that will
report the colour, from Hayaki Saito.
@
text
@d1 1
a1 1
/* $OpenBSD: input.c,v 1.56 2013/01/15 23:18:55 nicm Exp $ */
d882 2
a883 2
	ictx->cell.data = ictx->ch;
	screen_write_cell(&ictx->ctx, &ictx->cell, NULL);
d1660 2
a1661 3
	ictx->cell.flags |= GRID_FLAG_UTF8;
	screen_write_cell(&ictx->ctx, &ictx->cell, &ictx->utf8data);
	ictx->cell.flags &= ~GRID_FLAG_UTF8;
@


1.56
log
@Implement ECH (erase character, CSI X). Reported by Christian Neukirchen.
@
text
@d1 1
a1 1
/* $OpenBSD: input.c,v 1.55 2012/11/27 20:08:42 nicm Exp $ */
d1568 2
a1569 1
		screen_set_cursor_colour(ictx->ctx.s, p);
d1572 1
a1572 1
		if (*p == '\0') /* No arguments allowed. */
@


1.55
log
@Support the 47 and 1047 SM and RM sequences (alternate screen without
cursor), requested by I forget who ages ago.
@
text
@d1 1
a1 1
/* $OpenBSD: input.c,v 1.54 2012/09/25 07:41:22 nicm Exp $ */
d138 1
d171 1
d1147 3
@


1.54
log
@Add notification for input from a pane, from George Nachman.
@
text
@d1 1
a1 1
/* $OpenBSD: input.c,v 1.53 2012/07/10 11:53:01 nicm Exp $ */
d1258 4
d1263 1
a1263 1
			window_pane_alternate_off(wp, &ictx->cell);
d1317 4
d1322 1
a1322 1
			window_pane_alternate_on(wp, &ictx->cell);
@


1.53
log
@xfree is not particularly helpful, remove it. From Thomas Adam.
@
text
@d1 1
a1 1
/* $OpenBSD: input.c,v 1.52 2012/04/25 21:12:49 nicm Exp $ */
d755 1
@


1.52
log
@Add a buffer with all input from last ground state, will be used for
control mode. From George Nachman.
@
text
@d1 1
a1 1
/* $OpenBSD: input.c,v 1.51 2012/03/20 11:01:00 nicm Exp $ */
d856 1
a856 1
	xfree(reply);
@


1.51
log
@Add a simple form of output rate limiting by counting the number of
certain C0 sequences (linefeeds, backspaces, carriage returns) and if it
exceeds a threshold (current default 50/millisecond), start to redraw
the pane every 100 milliseconds instead of making each change as it
comes. Two configuration options - c0-change-trigger and
c0-change-interval.

This makes tmux much more responsive under very fast output (for example
yes(1) or accidentally cat'ing a large file) but may not be perfect on
all terminals and connections - feedback very welcome, particularly
where this change has a negative rather than positive effect (making it
off by default is a possibility).

After much experimentation based originally on a request Robin Lee
Powell (which ended with a completely different solution), this idea
from discussion with Ailin Nemui.
@
text
@d1 1
a1 1
/* $OpenBSD: input.c,v 1.50 2012/03/15 10:05:49 nicm Exp $ */
d50 1
d54 1
d697 2
d703 1
a703 1
input_free(unused struct window_pane *wp)
d705 20
d782 6
a787 7
		if (itr->state != NULL) {
			if (ictx->state->exit != NULL)
				ictx->state->exit(ictx);
			ictx->state = itr->state;
			if (ictx->state->enter != NULL)
				ictx->state->enter(ictx);
		}
@


1.50
log
@Respond to secondary DA requests.
@
text
@d1 1
a1 1
/* $OpenBSD: input.c,v 1.49 2012/03/03 09:43:22 nicm Exp $ */
d911 1
d923 1
a923 1
		break;
d940 1
a940 1
		break;
d943 1
a943 1
		break;
d953 9
@


1.49
log
@Support "bracketed paste" mode. This adds a -p flag to paste-buffer - if
this is used and the application has requested bracketed pastes, then
tmux surrounds the pasted text by \033[200~ and \033[201~. Applications
like vim can (apparently) use this to avoid, for example, indenting the
text. From Ailin Nemui.
@
text
@d1 1
a1 1
/* $OpenBSD: input.c,v 1.48 2012/02/02 00:10:12 nicm Exp $ */
d130 1
d170 1
d1096 10
@


1.48
log
@Move window name changes into wrapper function window_set_name, from
George Nachman.
@
text
@d1 1
a1 1
/* $OpenBSD: input.c,v 1.47 2012/01/21 08:23:12 nicm Exp $ */
d1215 3
d1269 3
@


1.47
log
@Add strings to allow the aixterm bright colours to be used when
configuring colours, requested by Elliott Cable a few months ago.
@
text
@d1 1
a1 1
/* $OpenBSD: input.c,v 1.46 2012/01/21 08:12:03 nicm Exp $ */
d1555 1
a1555 2
	xfree(ictx->wp->window->name);
	ictx->wp->window->name = xstrdup(ictx->input_buf);
@


1.46
log
@One day I will actually fix ALL the warnings before I commit...
@
text
@d1 1
a1 1
/* $OpenBSD: input.c,v 1.45 2012/01/21 08:10:21 nicm Exp $ */
d1439 1
a1439 1
			gc->bg = n;
@


1.45
log
@Add a -R flag to send-keys to reset the terminal. Written ages ago and
Suggested by someone, I forget who.
@
text
@d1 1
a1 1
/* $OpenBSD: input.c,v 1.44 2012/01/20 19:15:40 nicm Exp $ */
d981 1
a981 1
		screen_write_reset(sctx->s);
@


1.44
log
@Add an option to disable the window rename escape sequence, from Romain
Francoise.
@
text
@d1 1
a1 1
/* $OpenBSD: input.c,v 1.43 2011/12/29 08:06:24 nicm Exp $ */
d981 1
a981 11
		screen_reset_tabs(sctx->s);

		screen_write_scrollregion(sctx, 0, screen_size_y(sctx->s) - 1);

		screen_write_insertmode(sctx, 0);
		screen_write_kcursormode(sctx, 0);
		screen_write_kkeypadmode(sctx, 0);
		screen_write_mousemode_off(sctx);

		screen_write_clearscreen(sctx);
		screen_write_cursormove(sctx, 0, 0);
@


1.43
log
@Add CNL and CPL escape sequences.
@
text
@d1 1
a1 1
/* $OpenBSD: input.c,v 1.42 2011/12/27 14:06:19 nicm Exp $ */
d1560 2
@


1.42
log
@Add \033[s and \033[u to save and restore cursor position.
@
text
@d1 1
a1 1
/* $OpenBSD: input.c,v 1.41 2011/10/23 10:16:14 nicm Exp $ */
d122 2
d158 2
d1090 8
@


1.41
log
@Support for \e[3J to clear the history. Also send the corresponding
terminfo code (E3) before locking.
@
text
@d1 1
a1 1
/* $OpenBSD: input.c,v 1.40 2011/07/08 06:28:05 nicm Exp $ */
d138 1
d141 1
d176 2
d1175 4
d1217 5
@


1.40
log
@Fix a couple of comments.
@
text
@d1 1
a1 1
/* $OpenBSD: input.c,v 1.39 2011/05/20 19:17:39 nicm Exp $ */
d1128 11
@


1.39
log
@Support DECSCUSR sequence to set the cursor style with two new
terminfo(5) extensions, Cs and Csr. Written by Ailin Nemui.
@
text
@d1 1
a1 1
/* $OpenBSD: input.c,v 1.38 2011/05/20 19:03:58 nicm Exp $ */
d558 1
a558 1
/* device_ignore state table. */
d794 1
a794 1
/* Get an argument or return default value..*/
@


1.38
log
@Support xterm(1) cursor colour change sequences through terminfo(5) Cc
(set) and Cr (reset) extensions. Originally by Sean Estabrooks, tweaked
by me and Ailin Nemui.
@
text
@d1 1
a1 1
/* $OpenBSD: input.c,v 1.37 2011/03/07 23:46:27 nicm Exp $ */
d129 1
d172 1
d1263 4
@


1.37
log
@Support passing through escape sequences to the underlying terminal by
using DCS with a "tmux;" prefix. Escape characters in the sequences must
be doubled. For example:

$ printf '\033Ptmux;\033\033]12;red\007\033\\'

Will pass \033]12;red\007 to the terminal (and change the cursor colour
in xterm). From Kevin Goodsell.
@
text
@d1 1
a1 1
/* $OpenBSD: input.c,v 1.36 2011/03/03 08:53:14 nicm Exp $ */
d1448 3
d1453 2
a1454 1
	log_debug("%s: \"%s\"", __func__, ictx->input_buf);
d1456 1
a1456 4
	if (ictx->input_len < 2 || ictx->input_buf[1] != ';')
		return;
	if (ictx->input_buf[0] != '0' && ictx->input_buf[0] != '2')
		return;
d1458 23
a1480 2
	screen_set_title(ictx->ctx.s, ictx->input_buf + 2);
	server_status_window(ictx->wp->window);
@


1.36
log
@Fix a typo that meant we did not reset the background colour when it was
omitted in a 256-colour SGR ([48;5m). From Yusuke ENDOH.
@
text
@d1 1
a1 1
/* $OpenBSD: input.c,v 1.35 2011/01/28 20:39:22 nicm Exp $ */
d44 3
a55 2
void	input_enter_dcs(struct input_ctx *);
void	input_exit_dcs(struct input_ctx *);
d72 1
d209 1
d292 1
a292 1
	input_enter_dcs, input_exit_dcs,
d296 7
d495 1
a495 1
	{ 0x40, 0x7e, NULL,		  &input_state_dcs_handler },
d513 1
a513 1
	{ 0x40, 0x7e, NULL,		  &input_state_dcs_handler },
d528 1
a528 1
	{ 0x40, 0x7e, NULL,		  &input_state_dcs_handler },
d536 12
a547 1
	INPUT_STATE_ANYWHERE,
d549 3
a551 5
	{ 0x00, 0x17, NULL,	    NULL },
	{ 0x19, 0x19, input_input,  NULL },
	{ 0x1c, 0x1f, input_input,  NULL },
	{ 0x20, 0x7e, input_input,  NULL },
	{ 0x7f, 0xff, NULL,	    NULL },
d1413 3
a1415 3
/* DCS string started. */
void
input_enter_dcs(struct input_ctx *ictx)
d1417 7
a1423 1
	log_debug("%s", __func__);
d1425 6
a1430 2
	input_clear(ictx);
}
d1432 1
a1432 5
/* DCS terminator (ST) received. */
void
input_exit_dcs(unused struct input_ctx *ictx)
{
	log_debug("%s", __func__);
@


1.35
log
@Use input_clear to reset the APC, DCS, OSC state or it could be reused
improperly by a later state. From Kevin Goodsell.
@
text
@d1 1
a1 1
/* $OpenBSD: input.c,v 1.34 2011/01/15 00:16:00 nicm Exp $ */
d1280 1
a1280 1
					gc->fg = 8;
@


1.34
log
@Mouse highlight mode (1001) requires a program to cooperate so
supporting it through tmux is not as easy as this, remove it for now.
@
text
@d1 1
a1 1
/* $OpenBSD: input.c,v 1.33 2011/01/03 23:35:21 nicm Exp $ */
d815 3
d1400 1
a1400 1
	ictx->input_len = 0;
d1416 1
a1416 1
	ictx->input_len = 0;
d1442 1
a1442 1
	ictx->input_len = 0;
d1463 1
a1463 1
	ictx->input_len = 0;
@


1.33
log
@Support for UTF-8 mouse input (\033[1005h). This was added in xterm 262
and supports larger terminals than the older way.

If the new mouse-utf8 option is on, UTF-8 mouse input is enabled for all
UTF-8 terminals. The option defaults to on if LANG etc are set in the
same manner as the utf8 option.

With help and based on code from hsim at gmx.li.
@
text
@d1 1
a1 1
/* $OpenBSD: input.c,v 1.32 2010/12/29 21:49:06 nicm Exp $ */
a1202 4
			break;
		case 1001:
			screen_write_mousemode_on(
			    &ictx->ctx, MODE_MOUSE_HIGHLIGHT);
@


1.32
log
@Support all four of the xterm mouse modes. Based on a diff from hsim at
gmx.li.
@
text
@d1 1
a1 1
/* $OpenBSD: input.c,v 1.31 2010/12/23 20:18:39 nicm Exp $ */
d1164 3
d1214 3
@


1.31
log
@Style tweaks.
@
text
@d1 1
a1 1
/* $OpenBSD: input.c,v 1.30 2010/12/06 22:51:02 nicm Exp $ */
d956 1
a956 1
		screen_write_mousemode(sctx, 0);
d1159 4
a1162 1
			screen_write_mousemode(&ictx->ctx, 0);
d1198 13
a1210 1
			screen_write_mousemode(&ictx->ctx, 1);
@


1.30
log
@Add an option to alert (monitor) for silence (lack of activity) in a
window. From Thomas Adam.
@
text
@d1 1
a1 1
/* $OpenBSD: input.c,v 1.29 2010/04/17 23:31:09 nicm Exp $ */
d723 1
a723 1
		if (itr->handler && itr->handler(ictx) != 0)
d727 1
a727 1
		if (itr->state) {
d927 3
a929 3
	struct screen_write_ctx	*sctx = &ictx->ctx;
	struct screen		*s = sctx->s;
	struct input_table_entry       *entry;
@


1.29
log
@Fix typo in escape state table leading to fatal() when \033} or \033~
was entered, from Chris Johnsen.
@
text
@d1 1
a1 1
/* $OpenBSD: input.c,v 1.28 2010/03/22 19:02:54 nicm Exp $ */
d684 1
d686 1
@


1.28
log
@New input parser based on http://vt100.net/emu/dec_ansi_parser.
@
text
@d1 1
a1 1
/* $OpenBSD$ */
d388 1
a388 1
	{ 0x6c, 0x7c, input_esc_dispatch, &input_state_ground },
@


1.27
log
@Add an option to disable the smcup/rmcup alternate screen behaviour inside
tmux. From clemens fischer.
@
text
@d1 1
a1 1
/* $OpenBSD: input.c,v 1.26 2010/01/06 23:13:52 nicm Exp $ */
a20 1
#include <stdint.h>
d26 57
a82 90
#define INPUT_C0CONTROL(ch) 	(ch <= 0x1f)
#define INPUT_INTERMEDIATE(ch)	(ch == 0xa0 || (ch >= 0x20 && ch <= 0x2f))
#define INPUT_PARAMETER(ch)	(ch >= 0x30 && ch <= 0x3f)
#define INPUT_UPPERCASE(ch)	(ch >= 0x40 && ch <= 0x5f)
#define INPUT_LOWERCASE(ch)	(ch >= 0x60 && ch <= 0x7e)
#define INPUT_DELETE(ch)	(ch == 0x7f)
#define INPUT_C1CONTROL(ch)	(ch >= 0x80 && ch <= 0x9f)
#define INPUT_G1DISPLAYABLE(ch)	(ch >= 0xa1 && ch <= 0xfe)
#define INPUT_SPECIAL(ch)	(ch == 0xff)

int	 input_get_argument(struct input_ctx *, u_int, uint16_t *, uint16_t);
void	 input_new_argument(struct input_ctx *);
int	 input_add_argument(struct input_ctx *, u_char);

void	 input_start_string(struct input_ctx *, int);
void	 input_abort_string(struct input_ctx *);
int	 input_add_string(struct input_ctx *, u_char);
char	*input_get_string(struct input_ctx *);

void	 input_state(struct input_ctx *, void *);

void	 input_state_first(u_char, struct input_ctx *);
void	 input_state_escape(u_char, struct input_ctx *);
void	 input_state_intermediate(u_char, struct input_ctx *);
void	 input_state_sequence_first(u_char, struct input_ctx *);
void	 input_state_sequence_next(u_char, struct input_ctx *);
void	 input_state_sequence_intermediate(u_char, struct input_ctx *);
void	 input_state_string_next(u_char, struct input_ctx *);
void	 input_state_string_escape(u_char, struct input_ctx *);
void	 input_state_utf8(u_char, struct input_ctx *);

void	 input_handle_character(u_char, struct input_ctx *);
void	 input_handle_c0_control(u_char, struct input_ctx *);
void	 input_handle_c1_control(u_char, struct input_ctx *);
void	 input_handle_private_two(u_char, struct input_ctx *);
void	 input_handle_standard_two(u_char, struct input_ctx *);
void	 input_handle_sequence(u_char, struct input_ctx *);

void	 input_handle_sequence_cuu(struct input_ctx *);
void	 input_handle_sequence_cud(struct input_ctx *);
void	 input_handle_sequence_cuf(struct input_ctx *);
void	 input_handle_sequence_cub(struct input_ctx *);
void	 input_handle_sequence_dch(struct input_ctx *);
void	 input_handle_sequence_cbt(struct input_ctx *);
void	 input_handle_sequence_da(struct input_ctx *);
void	 input_handle_sequence_dl(struct input_ctx *);
void	 input_handle_sequence_ich(struct input_ctx *);
void	 input_handle_sequence_il(struct input_ctx *);
void	 input_handle_sequence_vpa(struct input_ctx *);
void	 input_handle_sequence_hpa(struct input_ctx *);
void	 input_handle_sequence_cup(struct input_ctx *);
void	 input_handle_sequence_cup(struct input_ctx *);
void	 input_handle_sequence_tbc(struct input_ctx *);
void	 input_handle_sequence_ed(struct input_ctx *);
void	 input_handle_sequence_el(struct input_ctx *);
void	 input_handle_sequence_sm(struct input_ctx *);
void	 input_handle_sequence_rm(struct input_ctx *);
void	 input_handle_sequence_decstbm(struct input_ctx *);
void	 input_handle_sequence_sgr(struct input_ctx *);
void	 input_handle_sequence_dsr(struct input_ctx *);

int	 input_sequence_cmp(const void *, const void *);

struct input_sequence_entry {
	u_char	ch;
	void	(*fn)(struct input_ctx *);
};
const struct input_sequence_entry input_sequence_table[] = {
	{ '@@', input_handle_sequence_ich },
	{ 'A', input_handle_sequence_cuu },
	{ 'B', input_handle_sequence_cud },
	{ 'C', input_handle_sequence_cuf },
	{ 'D', input_handle_sequence_cub },
	{ 'G', input_handle_sequence_hpa },
	{ 'H', input_handle_sequence_cup },
	{ 'J', input_handle_sequence_ed },
	{ 'K', input_handle_sequence_el },
	{ 'L', input_handle_sequence_il },
	{ 'M', input_handle_sequence_dl },
	{ 'P', input_handle_sequence_dch },
	{ 'Z', input_handle_sequence_cbt },
	{ 'c', input_handle_sequence_da },
	{ 'd', input_handle_sequence_vpa },
	{ 'f', input_handle_sequence_cup },
	{ 'g', input_handle_sequence_tbc },
	{ 'h', input_handle_sequence_sm },
	{ 'l', input_handle_sequence_rm },
	{ 'm', input_handle_sequence_sgr },
	{ 'n', input_handle_sequence_dsr },
	{ 'r', input_handle_sequence_decstbm },
d85 15
a99 5
int
input_sequence_cmp(const void *a, const void *b)
{
	int	ai = ((const struct input_sequence_entry *) a)->ch;
	int	bi = ((const struct input_sequence_entry *) b)->ch;
d101 15
a115 2
	return (ai - bi);
}
d117 26
a142 4
void
input_new_argument(struct input_ctx *ictx)
{
	struct input_arg	*arg;
d144 27
a170 1
	ARRAY_EXPAND(&ictx->args, 1);
d172 4
a175 3
	arg = &ARRAY_LAST(&ictx->args);
	arg->used = 0;
}
d177 3
a179 4
int
input_add_argument(struct input_ctx *ictx, u_char ch)
{
	struct input_arg	*arg;
d181 7
a187 2
	if (ARRAY_LENGTH(&ictx->args) == 0)
		return (0);
d189 33
a221 4
	arg = &ARRAY_LAST(&ictx->args);
	if (arg->used > (sizeof arg->data) - 1)
		return (-1);
	arg->data[arg->used++] = ch;
d223 6
a228 2
	return (0);
}
d230 6
a235 5
int
input_get_argument(struct input_ctx *ictx, u_int i, uint16_t *n, uint16_t d)
{
	struct input_arg	*arg;
	const char		*errstr;
d237 6
a242 3
	*n = d;
	if (i >= ARRAY_LENGTH(&ictx->args))
		return (0);
d244 6
a249 3
	arg = &ARRAY_ITEM(&ictx->args, i);
	if (*arg->data == '\0')
		return (0);
d251 6
a256 5
	*n = strtonum(arg->data, 0, UINT16_MAX, &errstr);
	if (errstr != NULL)
		return (-1);
	return (0);
}
d258 6
a263 6
void
input_start_string(struct input_ctx *ictx, int type)
{
	ictx->string_type = type;
	ictx->string_len = 0;
}
d265 6
a270 7
void
input_abort_string(struct input_ctx *ictx)
{
	if (ictx->string_buf != NULL)
		xfree(ictx->string_buf);
	ictx->string_buf = NULL;
}
d272 6
a277 5
int
input_add_string(struct input_ctx *ictx, u_char ch)
{
	ictx->string_buf = xrealloc(ictx->string_buf, 1, ictx->string_len + 1);
	ictx->string_buf[ictx->string_len++] = ch;
d279 6
a284 4
	if (ictx->string_len >= MAXSTRINGLEN) {
		input_abort_string(ictx);
		return (1);
	}
d286 6
a291 2
	return (0);
}
d293 6
a298 4
char *
input_get_string(struct input_ctx *ictx)
{
	char	*s;
d300 6
a305 2
	if (ictx->string_buf == NULL || input_add_string(ictx, '\0') != 0)
		return (xstrdup(""));
d307 6
a312 4
	s = ictx->string_buf;
	ictx->string_buf = NULL;
	return (s);
}
d314 6
a319 5
void
input_state(struct input_ctx *ictx, void *state)
{
	ictx->state = state;
}
d321 6
a326 4
void
input_init(struct window_pane *wp)
{
	struct input_ctx	*ictx = &wp->ictx;
d328 6
a333 1
	ARRAY_INIT(&ictx->args);
d335 6
a340 2
	ictx->string_len = 0;
	ictx->string_buf = NULL;
d342 6
a347 1
	memcpy(&ictx->cell, &grid_default_cell, sizeof ictx->cell);
d349 14
a362 3
	memcpy(&ictx->saved_cell, &grid_default_cell, sizeof ictx->saved_cell);
	ictx->saved_cx = 0;
	ictx->saved_cy = 0;
d364 2
a365 1
	input_state(ictx, input_state_first);
d367 23
a389 2
	ictx->was = 0;
}
d391 2
a392 5
void
input_free(struct window_pane *wp)
{
	if (wp->ictx.string_buf != NULL)
		xfree(wp->ictx.string_buf);
d394 10
a403 2
	ARRAY_FREE(&wp->ictx.args);
}
d405 2
a406 5
void
input_parse(struct window_pane *wp)
{
	struct input_ctx	*ictx = &wp->ictx;
	u_char			 ch;
d408 14
a421 3
	if (EVBUFFER_LENGTH(wp->event->input) == ictx->was)
		return;
	wp->window->flags |= WINDOW_ACTIVITY;
d423 2
a424 3
	ictx->buf = EVBUFFER_DATA(wp->event->input);
	ictx->len = EVBUFFER_LENGTH(wp->event->input);
	ictx->off = 0;
d426 14
a439 1
	ictx->wp = wp;
d441 2
a442 5
	/* If there is a mode set, don't want to update the screen. */
	if (wp->mode == NULL)
		screen_write_start(&ictx->ctx, wp, &wp->base);
	else
		screen_write_start(&ictx->ctx, NULL, &wp->base);
d444 11
a454 4
	while (ictx->off < ictx->len) {
		ch = ictx->buf[ictx->off++];
		ictx->state(ch, ictx);
	}
d456 2
a457 1
	screen_write_stop(&ictx->ctx);
d459 10
a468 3
	evbuffer_drain(wp->event->input, ictx->len);
	ictx->was = EVBUFFER_LENGTH(wp->event->input);
}
d470 2
a471 4
void
input_state_first(u_char ch, struct input_ctx *ictx)
{
	ictx->intermediate = '\0';
d473 14
a486 7
	if (INPUT_C0CONTROL(ch)) {
		if (ch == 0x1b)
			input_state(ictx, input_state_escape);
		else
			input_handle_c0_control(ch, ictx);
		return;
	}
d488 2
a489 16
#if 0
	if (INPUT_C1CONTROL(ch)) {
		ch -= 0x40;
		if (ch == '[')
			input_state(ictx, input_state_sequence_first);
		else if (ch == ']') {
			input_start_string(ictx, STRING_SYSTEM);
			input_state(ictx, input_state_string_next);
		} else if (ch == '_') {
			input_start_string(ictx, STRING_APPLICATION);
			input_state(ictx, input_state_string_next);
		} else
			input_handle_c1_control(ch, ictx);
		return;
	}
#endif
d491 14
a504 2
	if (INPUT_DELETE(ch))
		return;
d506 2
a507 2
	input_handle_character(ch, ictx);
}
d509 11
a519 6
void
input_state_escape(u_char ch, struct input_ctx *ictx)
{
	/* Treat C1 control and G1 displayable as 7-bit equivalent. */
	if (INPUT_C1CONTROL(ch) || INPUT_G1DISPLAYABLE(ch))
		ch &= 0x7f;
d521 2
a522 4
	if (INPUT_C0CONTROL(ch)) {
		input_handle_c0_control(ch, ictx);
		return;
	}
d524 9
a532 6
	if (INPUT_INTERMEDIATE(ch)) {
		log_debug2(":: in1 %zu: %hhu (%c)", ictx->off, ch, ch);
		ictx->intermediate = ch;
		input_state(ictx, input_state_intermediate);
		return;
	}
d534 2
a535 5
	if (INPUT_PARAMETER(ch)) {
		input_state(ictx, input_state_first);
		input_handle_private_two(ch, ictx);
		return;
	}
d537 8
a544 15
	if (INPUT_UPPERCASE(ch)) {
		if (ch == '[')
			input_state(ictx, input_state_sequence_first);
		else if (ch == ']') {
			input_start_string(ictx, STRING_SYSTEM);
			input_state(ictx, input_state_string_next);
		} else if (ch == '_') {
			input_start_string(ictx, STRING_APPLICATION);
			input_state(ictx, input_state_string_next);
		} else {
			input_state(ictx, input_state_first);
			input_handle_c1_control(ch, ictx);
		}
		return;
	}
d546 2
a547 5
	if (INPUT_LOWERCASE(ch)) {
		input_state(ictx, input_state_first);
		input_handle_standard_two(ch, ictx);
		return;
	}
d549 10
a558 2
	input_state(ictx, input_state_first);
}
d560 2
a561 8
void
input_state_intermediate(u_char ch, struct input_ctx *ictx)
{
	if (INPUT_INTERMEDIATE(ch)) {
		/* Multiple intermediates currently ignored. */
		log_debug2(":: in2 %zu: %hhu (%c)", ictx->off, ch, ch);
		return;
	}
d563 8
a570 5
	if (INPUT_PARAMETER(ch)) {
		input_state(ictx, input_state_first);
		input_handle_private_two(ch, ictx);
		return;
	}
d572 2
a573 5
	if (INPUT_UPPERCASE(ch) || INPUT_LOWERCASE(ch)) {
		input_state(ictx, input_state_first);
		input_handle_standard_two(ch, ictx);
		return;
	}
d575 8
a582 2
	input_state(ictx, input_state_first);
}
d584 2
a585 5
void
input_state_sequence_first(u_char ch, struct input_ctx *ictx)
{
	ictx->private = '\0';
	ARRAY_CLEAR(&ictx->args);
d587 8
a594 11
	/* Most C0 control are accepted within CSI. */
	if (INPUT_C0CONTROL(ch)) {
		if (ch == 0x1b) {			/* ESC */
			/* Abort sequence and begin with new. */
			input_state(ictx, input_state_escape);
			return;
		} else if (ch == 0x18 || ch == 0x1a) {	/* CAN and SUB */
			/* Abort sequence. */
			input_state(ictx, input_state_first);
			return;
		}
d596 2
a597 2
		/* Handle C0 immediately. */
		input_handle_c0_control(ch, ictx);
d599 7
a605 6
		/*
		 * Just come back to this state, in case the next character
		 * is the start of a private sequence.
		 */
		return;
	}
d607 2
a608 1
	input_state(ictx, input_state_sequence_next);
d610 7
a616 5
	/* Private sequence: always the first character. */
	if (ch >= 0x3c && ch <= 0x3f) {
		ictx->private = ch;
		return;
	}
d618 2
a619 3
	/* Pass character on directly. */
	input_state_sequence_next(ch, ictx);
}
d621 7
a627 12
void
input_state_sequence_next(u_char ch, struct input_ctx *ictx)
{
	if (INPUT_INTERMEDIATE(ch)) {
		if (input_add_argument(ictx, '\0') != 0)
			input_state(ictx, input_state_first);
		else {
			log_debug2(":: si1 %zu: %hhu (%c)", ictx->off, ch, ch);
			input_state(ictx, input_state_sequence_intermediate);
		}
		return;
	}
d629 2
a630 13
	if (INPUT_PARAMETER(ch)) {
		if (ARRAY_EMPTY(&ictx->args))
			input_new_argument(ictx);

		if (ch == ';') {
			if (input_add_argument(ictx, '\0') != 0)
				input_state(ictx, input_state_first);
			else
				input_new_argument(ictx);
		} else if (input_add_argument(ictx, ch) != 0)
			input_state(ictx, input_state_first);
		return;
	}
d632 3
a634 33
	if (INPUT_UPPERCASE(ch) || INPUT_LOWERCASE(ch)) {
		if (input_add_argument(ictx, '\0') != 0)
			input_state(ictx, input_state_first);
		else {
			input_state(ictx, input_state_first);
			input_handle_sequence(ch, ictx);
		}
		return;
	}

	/* Most C0 control are accepted within CSI. */
	if (INPUT_C0CONTROL(ch)) {
		if (ch == 0x1b) {			/* ESC */
			/* Abort sequence and begin with new. */
			input_state(ictx, input_state_escape);
			return;
		} else if (ch == 0x18 || ch == 0x1a) {	/* CAN and SUB */
			/* Abort sequence. */
			input_state(ictx, input_state_first);
			return;
		}

		/* Handle C0 immediately. */
		input_handle_c0_control(ch, ictx);

		return;
	}

	input_state(ictx, input_state_first);
}

void
input_state_sequence_intermediate(u_char ch, struct input_ctx *ictx)
d636 2
a637 4
	if (INPUT_INTERMEDIATE(ch)) {
		log_debug2(":: si2 %zu: %hhu (%c)", ictx->off, ch, ch);
		return;
	}
d639 3
a641 7
	if (INPUT_UPPERCASE(ch) || INPUT_LOWERCASE(ch)) {
		input_state(ictx, input_state_first);
		input_handle_sequence(ch, ictx);
		return;
	}

	input_state(ictx, input_state_first);
d644 1
d646 1
a646 1
input_state_string_next(u_char ch, struct input_ctx *ictx)
d648 1
a648 8
	if (ch == 0x1b) {
		input_state(ictx, input_state_string_escape);
		return;
	}
	if (ch == 0x07) {
		input_state_string_escape(ch, ictx);
		return;
	}
d650 1
a650 45
	if (ch >= 0x20) {
		if (input_add_string(ictx, ch) != 0)
			input_state(ictx, input_state_first);
		return;
	}
}

void
input_state_string_escape(u_char ch, struct input_ctx *ictx)
{
	char	*s;

	if (ch == '\007' || ch == '\\') {
		input_state(ictx, input_state_first);
		switch (ictx->string_type) {
		case STRING_SYSTEM:
			if (ch != '\007')
				return;
			s = input_get_string(ictx);
			if ((s[0] != '0' && s[0] != '2') || s[1] != ';') {
				xfree(s);
				return;
			}
			screen_set_title(ictx->ctx.s, s + 2);
			server_status_window(ictx->wp->window);
			xfree(s);
			break;
		case STRING_APPLICATION:
			if (ch != '\\')
				return;
			s = input_get_string(ictx);
			screen_set_title(ictx->ctx.s, s);
			server_status_window(ictx->wp->window);
			xfree(s);
			break;
		case STRING_NAME:
			if (ch != '\\')
				return;
			xfree(ictx->wp->window->name);
			ictx->wp->window->name = input_get_string(ictx);
			server_status_window(ictx->wp->window);
			break;
		}
		return;
	}
d652 3
a654 3
	input_state(ictx, input_state_string_next);
	input_state_string_next(ch, ictx);
}
d656 2
a657 4
void
input_state_utf8(u_char ch, struct input_ctx *ictx)
{
	log_debug2("-- utf8 next: %zu: %hhu (%c)", ictx->off, ch, ch);
d659 2
a660 3
	if (utf8_append(&ictx->utf8data, ch))
		return;		/* more to come */
	input_state(ictx, input_state_first);
d662 2
a663 3
	ictx->cell.flags |= GRID_FLAG_UTF8;
	screen_write_cell(&ictx->ctx, &ictx->cell, &ictx->utf8data);
	ictx->cell.flags &= ~GRID_FLAG_UTF8;
d666 1
d668 1
a668 1
input_handle_character(u_char ch, struct input_ctx *ictx)
a669 14
	struct window_pane	*wp = ictx->wp;

	if (ch > 0x7f && options_get_number(&wp->window->options, "utf8")) {
		if (utf8_open(&ictx->utf8data, ch)) {
			log_debug2("-- utf8 size %zu: %zu: %hhu (%c)",
			    ictx->utf8data.size, ictx->off, ch, ch);
			input_state(ictx, input_state_utf8);
			return;
		}
	}
	log_debug2("-- ch %zu: %hhu (%c)", ictx->off, ch, ch);

	ictx->cell.data = ch;
	screen_write_cell(&ictx->ctx, &ictx->cell, NULL);
d672 1
d674 1
a674 1
input_handle_c0_control(u_char ch, struct input_ctx *ictx)
d676 5
a680 1
	struct screen	*s = ictx->ctx.s;
d682 3
a684 1
	log_debug2("-- c0 %zu: %hhu", ictx->off, ch);
d686 9
a694 19
	switch (ch) {
	case '\0':	/* NUL */
		break;
	case '\n':	/* LF */
		screen_write_linefeed(&ictx->ctx, 0);
		break;
	case '\r':	/* CR */
		screen_write_carriagereturn(&ictx->ctx);
		break;
	case '\007':	/* BELL */
		ictx->wp->window->flags |= WINDOW_BELL;
		break;
	case '\010': 	/* BS */
		screen_write_backspace(&ictx->ctx);
		break;
	case '\011': 	/* TAB */
		/* Don't tab beyond the end of the line. */
		if (s->cx >= screen_size_x(s) - 1)
			break;
d696 13
a708 4
		/* Find the next tab point, or use the last column if none. */
		do {
			s->cx++;
			if (bit_test(s->tabs, s->cx))
d710 1
a710 64
		} while (s->cx < screen_size_x(s) - 1);
		break;
	case '\013':	/* VT */
		screen_write_linefeed(&ictx->ctx, 0);
		break;
	case '\016':	/* SO */
		ictx->cell.attr |= GRID_ATTR_CHARSET;
		break;
	case '\017':	/* SI */
		ictx->cell.attr &= ~GRID_ATTR_CHARSET;
		break;
	default:
		log_debug("unknown c0: %hhu", ch);
		break;
	}
}

void
input_handle_c1_control(u_char ch, struct input_ctx *ictx)
{
	struct screen  *s = ictx->ctx.s;

	log_debug2("-- c1 %zu: %hhu (%c)", ictx->off, ch, ch);

	switch (ch) {
	case 'D':	/* IND */
		screen_write_linefeed(&ictx->ctx, 0);
		break;
	case 'E': 	/* NEL */
		screen_write_carriagereturn(&ictx->ctx);
		screen_write_linefeed(&ictx->ctx, 0);
		break;
	case 'H':	/* HTS */
		if (s->cx < screen_size_x(s))
			bit_set(s->tabs, s->cx);
		break;
	case 'M':	/* RI */
		screen_write_reverseindex(&ictx->ctx);
		break;
	default:
		log_debug("unknown c1: %hhu", ch);
		break;
	}
}

void
input_handle_private_two(u_char ch, struct input_ctx *ictx)
{
	struct screen	*s = ictx->ctx.s;

	log_debug2(
	    "-- p2 %zu: %hhu (%c) %hhu", ictx->off, ch, ch, ictx->intermediate);

	switch (ch) {
	case '0':	/* SCS */
		/*
		 * Not really supported, but fake it up enough for those that
		 * use it to switch character sets (by redefining G0 to
		 * graphics set, rather than switching to G1).
		 */
		switch (ictx->intermediate) {
		case '(':	/* G0 */
			ictx->cell.attr |= GRID_ATTR_CHARSET;
			break;
d712 3
a714 31
		break;
	case '=':	/* DECKPAM */
		if (ictx->intermediate != '\0')
			break;
		screen_write_kkeypadmode(&ictx->ctx, 1);
		log_debug("kkeypad on (application mode)");
		break;
	case '>':	/* DECKPNM */
		if (ictx->intermediate != '\0')
			break;
		screen_write_kkeypadmode(&ictx->ctx, 0);
		log_debug("kkeypad off (number mode)");
		break;
	case '7':	/* DECSC */
		if (ictx->intermediate != '\0')
			break;
		memcpy(&ictx->saved_cell, &ictx->cell, sizeof ictx->saved_cell);
		ictx->saved_cx = s->cx;
		ictx->saved_cy = s->cy;
		break;
	case '8':
		switch (ictx->intermediate) {
		case '\0':	/* DECRC */
			memcpy(
			    &ictx->cell, &ictx->saved_cell, sizeof ictx->cell);
			screen_write_cursormove(
			    &ictx->ctx, ictx->saved_cx, ictx->saved_cy);
			break;
		case '#':	/* DECALN */
			screen_write_alignmenttest(&ictx->ctx);
			break;
a715 6
		break;
	default:
		log_debug("unknown p2: %hhu", ch);
		break;
	}
}
a716 8
void
input_handle_standard_two(u_char ch, struct input_ctx *ictx)
{
	log_debug2(
	    "-- s2 %zu: %hhu (%c) %hhu", ictx->off, ch, ch, ictx->intermediate);

	switch (ch) {
	case 'B':	/* SCS */
d718 2
a719 3
		 * Not really supported, but fake it up enough for those that
		 * use it to switch character sets (by redefining G0 to
		 * graphics set, rather than switching to G1).
d721 10
a730 4
		switch (ictx->intermediate) {
		case '(':	/* G0 */
			ictx->cell.attr &= ~GRID_ATTR_CHARSET;
			break;
a731 28
		break;
	case 'c':	/* RIS */
		memcpy(&ictx->cell, &grid_default_cell, sizeof ictx->cell);

		memcpy(&ictx->saved_cell, &ictx->cell, sizeof ictx->saved_cell);
		ictx->saved_cx = 0;
		ictx->saved_cy = 0;

		screen_reset_tabs(ictx->ctx.s);

		screen_write_scrollregion(
		    &ictx->ctx, 0, screen_size_y(ictx->ctx.s) - 1);

		screen_write_insertmode(&ictx->ctx, 0);
		screen_write_kcursormode(&ictx->ctx, 0);
		screen_write_kkeypadmode(&ictx->ctx, 0);
		screen_write_mousemode(&ictx->ctx, 0);

		screen_write_clearscreen(&ictx->ctx);
		screen_write_cursormove(&ictx->ctx, 0, 0);
		break;
	case 'k':
		input_start_string(ictx, STRING_NAME);
		input_state(ictx, input_state_string_next);
		break;
	default:
		log_debug("unknown s2: %hhu", ch);
		break;
a732 1
}
d734 2
a735 17
void
input_handle_sequence(u_char ch, struct input_ctx *ictx)
{
	struct input_sequence_entry	*entry, find;
	struct screen	 		*s = ictx->ctx.s;
	u_int				 i;
	struct input_arg 		*iarg;

	log_debug2("-- sq %zu: %hhu (%c): %u [sx=%u, sy=%u, cx=%u, cy=%u, "
	    "ru=%u, rl=%u]", ictx->off, ch, ch, ARRAY_LENGTH(&ictx->args),
	    screen_size_x(s), screen_size_y(s), s->cx, s->cy, s->rupper,
	    s->rlower);
	for (i = 0; i < ARRAY_LENGTH(&ictx->args); i++) {
		iarg = &ARRAY_ITEM(&ictx->args, i);
		if (*iarg->data != '\0')
			log_debug2("      ++ %u: %s", i, iarg->data);
	}
d737 1
a737 8
	find.ch = ch;
	entry = bsearch(&find,
	    input_sequence_table, nitems(input_sequence_table),
	    sizeof input_sequence_table[0], input_sequence_cmp);
	if (entry != NULL)
		entry->fn(ictx);
	else
		log_debug("unknown sq: %c (%hhu %hhu)", ch, ch, ictx->private);
d740 3
a742 14
void
input_handle_sequence_cuu(struct input_ctx *ictx)
{
	uint16_t	n;

	if (ictx->private != '\0')
		return;

	if (ARRAY_LENGTH(&ictx->args) > 1)
		return;
	if (input_get_argument(ictx, 0, &n, 1) != 0)
		return;
	if (n == 0)
		n = 1;
a743 5
	screen_write_cursorup(&ictx->ctx, n);
}

void
input_handle_sequence_cud(struct input_ctx *ictx)
d745 3
a747 1
	uint16_t	n;
d749 3
a751 2
	if (ictx->private != '\0')
		return;
d753 9
a761 6
	if (ARRAY_LENGTH(&ictx->args) > 1)
		return;
	if (input_get_argument(ictx, 0, &n, 1) != 0)
		return;
	if (n == 0)
		n = 1;
d763 4
a766 2
	screen_write_cursordown(&ictx->ctx, n);
}
d768 1
a768 16
void
input_handle_sequence_cuf(struct input_ctx *ictx)
{
	uint16_t n;

	if (ictx->private != '\0')
		return;

	if (ARRAY_LENGTH(&ictx->args) > 1)
		return;
	if (input_get_argument(ictx, 0, &n, 1) != 0)
		return;
	if (n == 0)
		n = 1;

	screen_write_cursorright(&ictx->ctx, n);
d771 3
a773 2
void
input_handle_sequence_cub(struct input_ctx *ictx)
d775 1
a775 4
	uint16_t	n;

	if (ictx->private != '\0')
		return;
d777 2
a778 6
	if (ARRAY_LENGTH(&ictx->args) > 1)
		return;
	if (input_get_argument(ictx, 0, &n, 1) != 0)
		return;
	if (n == 0)
		n = 1;
d780 6
a785 1
	screen_write_cursorleft(&ictx->ctx, n);
d788 1
d790 1
a790 1
input_handle_sequence_dch(struct input_ctx *ictx)
d792 2
a793 1
	uint16_t	n;
d795 3
a797 9
	if (ictx->private != '\0')
		return;

	if (ARRAY_LENGTH(&ictx->args) > 1)
		return;
	if (input_get_argument(ictx, 0, &n, 1) != 0)
		return;
	if (n == 0)
		n = 1;
d799 2
a800 1
	screen_write_deletecharacter(&ictx->ctx, n);
d803 1
d805 1
a805 1
input_handle_sequence_cbt(struct input_ctx *ictx)
d807 2
a808 2
	struct screen  *s = ictx->ctx.s;
	uint16_t	n;
d810 2
a811 9
	if (ictx->private != '\0')
		return;

	if (ARRAY_LENGTH(&ictx->args) > 1)
		return;
	if (input_get_argument(ictx, 0, &n, 1) != 0)
		return;
	if (n == 0)
		n = 1;
d813 1
a813 6
	/* Find the previous tab point, n times. */
	while (s->cx > 0 && n-- > 0) {
		do
			s->cx--;
		while (s->cx > 0 && !bit_test(s->tabs, s->cx));
	}
d816 3
a818 2
void
input_handle_sequence_da(struct input_ctx *ictx)
d820 2
a821 2
	struct window_pane	*wp = ictx->wp;
	uint16_t		 n;
d823 1
a823 11
	if (ictx->private != '\0')
		return;

	if (ARRAY_LENGTH(&ictx->args) > 1)
		return;
	if (input_get_argument(ictx, 0, &n, 0) != 0)
		return;
	if (n != 0)
		return;

	bufferevent_write(wp->event, "\033[?1;2c", (sizeof "\033[?1;2c") - 1);
d826 3
a828 2
void
input_handle_sequence_dl(struct input_ctx *ictx)
d830 6
a835 1
	uint16_t	n;
d837 1
a837 11
	if (ictx->private != '\0')
		return;

	if (ARRAY_LENGTH(&ictx->args) > 1)
		return;
	if (input_get_argument(ictx, 0, &n, 1) != 0)
		return;
	if (n == 0)
		n = 1;

	screen_write_deleteline(&ictx->ctx, n);
d840 3
a842 2
void
input_handle_sequence_ich(struct input_ctx *ictx)
d844 6
a849 1
	uint16_t	n;
d851 1
a851 11
	if (ictx->private != '\0')
		return;

	if (ARRAY_LENGTH(&ictx->args) > 1)
		return;
	if (input_get_argument(ictx, 0, &n, 1) != 0)
		return;
	if (n == 0)
		n = 1;

	screen_write_insertcharacter(&ictx->ctx, n);
d854 3
a856 2
void
input_handle_sequence_il(struct input_ctx *ictx)
d858 6
a863 1
	uint16_t	n;
d865 1
a865 11
	if (ictx->private != '\0')
		return;

	if (ARRAY_LENGTH(&ictx->args) > 1)
		return;
	if (input_get_argument(ictx, 0, &n, 1) != 0)
		return;
	if (n == 0)
		n = 1;

	screen_write_insertline(&ictx->ctx, n);
d868 3
a870 2
void
input_handle_sequence_vpa(struct input_ctx *ictx)
d872 3
a874 2
	struct screen  *s = ictx->ctx.s;
	uint16_t	n;
d876 1
a876 2
	if (ictx->private != '\0')
		return;
d878 13
a890 6
	if (ARRAY_LENGTH(&ictx->args) > 1)
		return;
	if (input_get_argument(ictx, 0, &n, 1) != 0)
		return;
	if (n == 0)
		n = 1;
d892 25
a916 2
	screen_write_cursormove(&ictx->ctx, s->cx, n - 1);
}
d918 1
a918 39
void
input_handle_sequence_hpa(struct input_ctx *ictx)
{
	struct screen  *s = ictx->ctx.s;
	uint16_t	n;

	if (ictx->private != '\0')
		return;

	if (ARRAY_LENGTH(&ictx->args) > 1)
		return;
	if (input_get_argument(ictx, 0, &n, 1) != 0)
		return;
	if (n == 0)
		n = 1;

	screen_write_cursormove(&ictx->ctx, n - 1, s->cy);
}

void
input_handle_sequence_cup(struct input_ctx *ictx)
{
	uint16_t	n, m;

	if (ictx->private != '\0')
		return;

	if (ARRAY_LENGTH(&ictx->args) > 2)
		return;
	if (input_get_argument(ictx, 0, &n, 1) != 0)
		return;
	if (input_get_argument(ictx, 1, &m, 1) != 0)
		return;
	if (n == 0)
		n = 1;
	if (m == 0)
		m = 1;

	screen_write_cursormove(&ictx->ctx, m - 1, n - 1);
d921 3
a923 2
void
input_handle_sequence_tbc(struct input_ctx *ictx)
d925 3
a927 2
	struct screen  *s = ictx->ctx.s;
	uint16_t	n;
d929 3
a931 2
	if (ictx->private != '\0')
		return;
d933 6
a938 4
	if (ARRAY_LENGTH(&ictx->args) > 1)
		return;
	if (input_get_argument(ictx, 0, &n, 1) != 0)
		return;
d940 6
a945 10
	switch (n) {
	case 0:
		if (s->cx < screen_size_x(s))
			bit_clear(s->tabs, s->cx);
		break;
	case 3:
		bit_nclear(s->tabs, 0, screen_size_x(s) - 1);
		break;
	}
}
d947 1
a947 4
void
input_handle_sequence_ed(struct input_ctx *ictx)
{
	uint16_t	n;
d949 1
a949 2
	if (ictx->private != '\0')
		return;
d951 4
a954 6
	if (ARRAY_LENGTH(&ictx->args) > 1)
		return;
	if (input_get_argument(ictx, 0, &n, 0) != 0)
		return;
	if (n > 2)
		return;
d956 22
a977 3
	switch (n) {
	case 0:
		screen_write_clearendofscreen(&ictx->ctx);
d979 19
a997 2
	case 1:
		screen_write_clearstartofscreen(&ictx->ctx);
d999 2
a1000 2
	case 2:
		screen_write_clearscreen(&ictx->ctx);
d1003 2
d1007 3
a1009 2
void
input_handle_sequence_el(struct input_ctx *ictx)
d1011 5
a1015 1
	uint16_t	n;
d1017 6
a1022 2
	if (ictx->private != '\0')
		return;
d1024 6
a1029 6
	if (ARRAY_LENGTH(&ictx->args) > 1)
		return;
	if (input_get_argument(ictx, 0, &n, 0) != 0)
		return;
	if (n > 2)
		return;
d1031 44
a1074 3
	switch (n) {
	case 0:
		screen_write_clearendofline(&ictx->ctx);
d1076 2
a1077 2
	case 1:
		screen_write_clearstartofline(&ictx->ctx);
d1079 64
a1142 2
	case 2:
		screen_write_clearline(&ictx->ctx);
d1144 2
a1145 19
	}
}

void
input_handle_sequence_sm(struct input_ctx *ictx)
{
	struct window_pane	*wp = ictx->wp;
	struct options		*oo = &wp->window->options;
	struct screen		*s = &wp->base;
	u_int			 sx, sy;
	uint16_t		 n;

	if (ARRAY_LENGTH(&ictx->args) > 1)
		return;
	if (input_get_argument(ictx, 0, &n, 0) != 0)
		return;

	if (ictx->private == '?') {
		switch (n) {
d1147 1
a1147 2
			screen_write_kcursormode(&ictx->ctx, 1);
			log_debug("kcursor on");
d1154 1
a1154 2
			screen_write_cursormode(&ictx->ctx, 1);
			log_debug("cursor on");
d1157 1
a1157 2
			screen_write_mousemode(&ictx->ctx, 1);
			log_debug("mouse on");
d1160 1
a1160 25
			if (wp->saved_grid != NULL)
				break;
			if (!options_get_number(oo, "alternate-screen"))
				break;
			sx = screen_size_x(s);
			sy = screen_size_y(s);

			/*
			 * Enter alternative screen mode. A copy of the visible
			 * screen is saved and the history is not updated
			 */

			wp->saved_grid = grid_create(sx, sy, 0);
			grid_duplicate_lines(
			    wp->saved_grid, 0, s->grid, screen_hsize(s), sy);
			wp->saved_cx = s->cx;
			wp->saved_cy = s->cy;
			memcpy(&wp->saved_cell,
			    &ictx->cell, sizeof wp->saved_cell);

			grid_view_clear(s->grid, 0, 0, sx, sy);

			wp->base.grid->flags &= ~GRID_HISTORY;

			wp->flags |= PANE_REDRAW;
d1163 1
a1163 1
			log_debug("unknown SM [%hhu]: %u", ictx->private, n);
d1166 6
a1171 2
	} else {
		switch (n) {
a1173 4
			log_debug("insert on");
			break;
		case 34:
			/* Cursor high visibility not supported. */
d1176 1
a1176 1
			log_debug("unknown SM [%hhu]: %u", ictx->private, n);
d1179 3
a1181 19
	}
}

void
input_handle_sequence_rm(struct input_ctx *ictx)
{
	struct window_pane	*wp = ictx->wp;
	struct options		*oo = &wp->window->options;
	struct screen		*s = &wp->base;
	u_int			 sx, sy;
	uint16_t		 n;

	if (ARRAY_LENGTH(&ictx->args) > 1)
		return;
	if (input_get_argument(ictx, 0, &n, 0) != 0)
		return;

	if (ictx->private == '?') {
		switch (n) {
d1183 1
a1183 2
			screen_write_kcursormode(&ictx->ctx, 0);
			log_debug("kcursor off");
d1190 1
a1190 2
			screen_write_cursormode(&ictx->ctx, 0);
			log_debug("cursor off");
d1193 1
a1193 2
			screen_write_mousemode(&ictx->ctx, 0);
			log_debug("mouse off");
d1196 1
a1196 42
			if (wp->saved_grid == NULL)
				break;
			if (!options_get_number(oo, "alternate-screen"))
				break;
			sx = screen_size_x(s);
			sy = screen_size_y(s);

			/*
			 * Exit alternative screen mode and restore the copied
			 * grid.
			 */

			/*
			 * If the current size is bigger, temporarily resize
			 * to the old size before copying back.
			 */
			if (sy > wp->saved_grid->sy)
				screen_resize(s, sx, wp->saved_grid->sy);

			/* Restore the grid, cursor position and cell. */
			grid_duplicate_lines(
			    s->grid, screen_hsize(s), wp->saved_grid, 0, sy);
			s->cx = wp->saved_cx;
			if (s->cx > screen_size_x(s) - 1)
				s->cx = screen_size_x(s) - 1;
			s->cy = wp->saved_cy;
			if (s->cy > screen_size_y(s) - 1)
				s->cy = screen_size_y(s) - 1;
			memcpy(&ictx->cell, &wp->saved_cell, sizeof ictx->cell);

			/*
			 * Turn history back on (so resize can use it) and then
			 * resize back to the current size.
			 */
			wp->base.grid->flags |= GRID_HISTORY;
			if (sy > wp->saved_grid->sy)
				screen_resize(s, sx, sy);

			grid_destroy(wp->saved_grid);
			wp->saved_grid = NULL;

			wp->flags |= PANE_REDRAW;
d1199 1
a1199 1
			log_debug("unknown RM [%hhu]: %u", ictx->private, n);
d1202 6
a1207 5
	} else if (ictx->private == '\0') {
		switch (n) {
		case 4:		/* IRM */
			screen_write_insertmode(&ictx->ctx, 0);
			log_debug("insert off");
d1209 2
a1210 2
		case 34:
			/* Cursor high visibility not supported. */
d1213 1
a1213 1
			log_debug("unknown RM [%hhu]: %u", ictx->private, n);
d1216 5
a1221 1
}
d1223 1
a1223 46
void
input_handle_sequence_dsr(struct input_ctx *ictx)
{
	struct window_pane	*wp = ictx->wp;
	struct screen		*s = ictx->ctx.s;
	uint16_t		 n;
	char			reply[32];

	if (ARRAY_LENGTH(&ictx->args) > 1)
		return;
	if (input_get_argument(ictx, 0, &n, 0) != 0)
		return;

	if (ictx->private == '\0') {
		switch (n) {
		case 6:	/* cursor position */
			xsnprintf(reply, sizeof reply,
			    "\033[%u;%uR", s->cy + 1, s->cx + 1);
			log_debug("cursor request, reply: %s", reply);
			bufferevent_write(wp->event, reply, strlen(reply));
			break;
		}
	}
}

void
input_handle_sequence_decstbm(struct input_ctx *ictx)
{
	struct screen  *s = ictx->ctx.s;
	uint16_t	n, m;

	if (ictx->private != '\0')
		return;

	if (ARRAY_LENGTH(&ictx->args) > 2)
		return;
	if (input_get_argument(ictx, 0, &n, 0) != 0)
		return;
	if (input_get_argument(ictx, 1, &m, 0) != 0)
		return;
	if (n == 0)
		n = 1;
	if (m == 0)
		m = screen_size_y(s);

	screen_write_scrollregion(&ictx->ctx, n - 1, m - 1);
d1226 1
d1228 1
a1228 1
input_handle_sequence_sgr(struct input_ctx *ictx)
d1230 4
a1233 4
	struct grid_cell       *gc = &ictx->cell;
	u_int			i;
	uint16_t		m, o;
	u_char			attr;
d1235 1
a1235 1
	if (ARRAY_LENGTH(&ictx->args) == 0) {
d1242 2
a1243 3
	for (i = 0; i < ARRAY_LENGTH(&ictx->args); i++) {
		if (input_get_argument(ictx, i, &m, 0) != 0)
			return;
d1245 1
a1245 1
		if (m == 38 || m == 48) {
d1247 1
a1247 3
			if (input_get_argument(ictx, i, &o, 0) != 0)
				return;
			if (o != 5)
d1251 18
a1268 8
			if (input_get_argument(ictx, i, &o, 0) != 0)
				return;
			if (m == 38) {
				gc->flags |= GRID_FLAG_FG256;
				gc->fg = o;
			} else if (m == 48) {
				gc->flags |= GRID_FLAG_BG256;
				gc->bg = o;
d1273 1
a1273 1
		switch (m) {
d1325 1
a1325 1
			gc->fg = m - 30;
d1340 1
a1340 1
			gc->bg = m - 40;
d1355 1
a1355 1
			gc->fg = m;
d1366 1
a1366 1
			gc->bg = m;
d1370 127
@


1.26
log
@Correctly clear 256-colour flag for aixterm colours.
@
text
@d1 1
a1 1
/* $OpenBSD: input.c,v 1.25 2009/12/14 21:33:38 nicm Exp $ */
d1151 1
d1182 2
d1230 1
d1260 2
@


1.25
log
@Pass through the aixterm bright colours if the terminal supports them (>= 16
colours).
@
text
@d1 1
a1 1
/* $OpenBSD: input.c,v 1.24 2009/12/03 22:50:10 nicm Exp $ */
d1484 1
d1495 1
@


1.24
log
@Massive spaces->tabs and trailing whitespace cleanup, hopefully for the last
time now I've configured emacs to make them displayed in really annoying
colours...
@
text
@d1 1
a1 1
/* $OpenBSD: input.c,v 1.23 2009/11/27 09:41:03 nicm Exp $ */
d1484 1
a1484 2
			gc->flags |= GRID_FLAG_FG256;
			gc->fg = m - 82;
d1494 1
a1494 2
			gc->flags |= GRID_FLAG_BG256;
			gc->bg = m - 92;
@


1.23
log
@Add a couple of comments.
@
text
@d1 1
a1 1
/* $OpenBSD: input.c,v 1.22 2009/11/04 22:43:11 nicm Exp $ */
d233 1
a233 1
 	memcpy(&ictx->cell, &grid_default_cell, sizeof ictx->cell);
d300 1
a300 1
  	if (INPUT_C1CONTROL(ch)) {
d594 1
a594 1
			log_debug2("-- utf8 size %zu: %zu: %hhu (%c)", 
d948 1
a948 1
	
d1167 1
a1167 1
			screen_write_cursormove(&ictx->ctx, 0, 0);			
d1243 1
a1243 1
			screen_write_cursormove(&ictx->ctx, 0, 0);			
d1260 1
a1260 1
			/* 
d1287 1
a1287 1
  			wp->base.grid->flags |= GRID_HISTORY;
d1375 1
a1375 1
 		gc->attr |= (attr & GRID_ATTR_CHARSET);
@


1.22
log
@Convert the window pane (pty master side) fd over to use a bufferevent.

The evbuffer API is very similar to the existing tmux buffer API so this was
remarkably painless. Not many possible ways to do it, I suppose.
@
text
@d1 1
a1 1
/* $OpenBSD: input.c,v 1.21 2009/10/26 21:42:04 deraadt Exp $ */
d269 1
@


1.21
log
@tabs are better; ok nicm
@
text
@d1 1
a1 1
/* $OpenBSD: input.c,v 1.20 2009/10/23 15:48:39 nicm Exp $ */
d259 1
a259 1
	if (BUFFER_USED(wp->in) == ictx->was)
d263 2
a264 2
	ictx->buf = BUFFER_OUT(wp->in);
	ictx->len = BUFFER_USED(wp->in);
d281 2
a282 2
	buffer_remove(wp->in, ictx->len);
	ictx->was = BUFFER_USED(wp->in);
d935 2
a936 1
	uint16_t	n;
d948 1
a948 1
	buffer_write(ictx->wp->out, "\033[?1;2c", (sizeof "\033[?1;2c") - 1);
d1318 4
a1321 3
	struct screen  *s = ictx->ctx.s;
	uint16_t	n;
	char		reply[32];
d1334 1
a1334 1
			buffer_write(ictx->wp->out, reply, strlen(reply));
@


1.20
log
@Support the bright fg/bg colour SGR 90-97 and 100-107.

Reported by Tim Allen.
@
text
@d1 1
a1 1
/* $OpenBSD: input.c,v 1.19 2009/10/20 22:17:33 nicm Exp $ */
d131 1
a131 1
	struct input_arg       *arg;
d142 1
a142 1
	struct input_arg       *arg;
d795 1
a795 1
	u_int			         i;
@


1.19
log
@%zu not %u, doh.
@
text
@d1 1
a1 1
/* $OpenBSD: input.c,v 1.18 2009/10/20 19:18:28 nicm Exp $ */
d1472 22
@


1.18
log
@Try to reduce the UTF-8 mess.

Get rid of passing around u_char[4]s and define a struct utf8_data which has
character data, size (sequence length) and width. Move UTF-8 character
collection into two functions utf8_open/utf8_append in utf8.c which fill in
this struct and use these functions from input.c and the various functions in
screen-write.c.

Space for rather more data than is necessary for one UTF-8 sequence is in the
utf8_data struct because screen_write_copy is still nasty and needs to reinject
the character (after combining) into screen_write_cell.
@
text
@d1 1
a1 1
/* $OpenBSD: input.c,v 1.17 2009/10/13 15:23:13 nicm Exp $ */
d593 1
a593 1
			log_debug2("-- utf8 size %u: %zu: %hhu (%c)", 
@


1.17
log
@Handle DECCOLM by just emulating its side-effect of clearing the screen.
@
text
@d1 1
a1 1
/* $OpenBSD: input.c,v 1.16 2009/10/12 16:59:55 nicm Exp $ */
d575 1
a575 1
	log_debug2("-- un %zu: %hhu (%c)", ictx->off, ch, ch);
d577 2
a578 3
	ictx->utf8_buf[ictx->utf8_off++] = ch;
	if (--ictx->utf8_len != 0)
		return;
d582 1
a582 1
	screen_write_cell(&ictx->ctx, &ictx->cell, ictx->utf8_buf);
d592 3
a594 25
		/*
		 * UTF-8 sequence.
		 *
		 * 11000010-11011111 C2-DF start of 2-byte sequence
		 * 11100000-11101111 E0-EF start of 3-byte sequence
		 * 11110000-11110100 F0-F4 start of 4-byte sequence
		 */
		memset(ictx->utf8_buf, 0xff, sizeof ictx->utf8_buf);
		ictx->utf8_buf[0] = ch;
		ictx->utf8_off = 1;

		if (ch >= 0xc2 && ch <= 0xdf) {
			log_debug2("-- u2 %zu: %hhu (%c)", ictx->off, ch, ch);
			input_state(ictx, input_state_utf8);
			ictx->utf8_len = 1;
			return;
		}
		if (ch >= 0xe0 && ch <= 0xef) {
			log_debug2("-- u3 %zu: %hhu (%c)", ictx->off, ch, ch);
			input_state(ictx, input_state_utf8);
			ictx->utf8_len = 2;
			return;
		}
		if (ch >= 0xf0 && ch <= 0xf4) {
			log_debug2("-- u4 %zu: %hhu (%c)", ictx->off, ch, ch);
a595 1
			ictx->utf8_len = 3;
d602 1
a602 1
	screen_write_cell(&ictx->ctx, &ictx->cell, ictx->utf8_buf);
@


1.16
log
@When backspace is received at the beginning of a line and the previous line was
wrapped, move the cursor back up to the end of the previous line.

Another one of the forgotten persons requested this quite a while ago (I need
to start noting names on todo items...) when it was quite hard to
implement. Now it is easy and I don't see it can do any harm, so hey presto...
@
text
@d1 1
a1 1
/* $OpenBSD: input.c,v 1.15 2009/08/20 10:48:25 nicm Exp $ */
d1188 4
d1263 4
@


1.15
log
@Nuke unused variable.
@
text
@d1 1
a1 1
/* $OpenBSD: input.c,v 1.14 2009/08/19 17:00:31 nicm Exp $ */
d649 1
a649 1
		screen_write_cursorleft(&ictx->ctx, 1);
@


1.14
log
@Handle the device attributes (DA) escape sequence.
@
text
@d1 1
a1 1
/* $OpenBSD: input.c,v 1.13 2009/08/18 21:41:13 nicm Exp $ */
a958 1
	struct screen  *s = ictx->ctx.s;
@


1.13
log
@Instead of just checking for an empty buffer, which may not be the case if
there is unconsumed data, save the previous size and use it instead. This means
that activity monitoring should work in this (unlikely) event.

Also remove a debugging statement that no longer seems necessary.
@
text
@d1 1
a1 1
/* $OpenBSD: input.c,v 1.12 2009/08/08 15:57:49 nicm Exp $ */
d71 1
d108 1
d954 19
@


1.12
log
@Add a flags member to the grid_line struct and use it to differentiate lines
wrapped at the screen edge from those terminated by a newline. Then use this
when copying to combine wrapped lines together into one.
@
text
@d1 1
a1 1
/* $OpenBSD: input.c,v 1.11 2009/08/07 00:12:13 nicm Exp $ */
d238 2
d257 1
a257 1
	if (BUFFER_USED(wp->in) == 0)
d259 1
a266 2
	log_debug2("entry; buffer=%zu", ictx->len);

a271 2
	if (ictx->off != ictx->len)
		wp->window->flags |= WINDOW_ACTIVITY;
d280 1
@


1.11
log
@Using the alternative screen (smcup/rmcup) should also preserve the current
colours and attributes. Found thanks to a report from Taylor Venable.

While here also nuke a couple of extra blank lines.
@
text
@d1 1
a1 1
/* $OpenBSD: input.c,v 1.10 2009/07/21 19:54:22 nicm Exp $ */
d638 1
a638 1
		screen_write_linefeed(&ictx->ctx);
d662 1
a662 1
		screen_write_linefeed(&ictx->ctx);
d685 1
a685 1
		screen_write_linefeed(&ictx->ctx);
d689 1
a689 1
		screen_write_linefeed(&ictx->ctx);
@


1.10
log
@Make some functions which return unused values void (mostly found by lint) and
tweak a redundant expression in window_pane_set_mode.
@
text
@d1 1
a1 1
/* $OpenBSD: input.c,v 1.9 2009/07/13 10:43:52 nicm Exp $ */
d1192 3
a1194 1
			
d1266 1
a1266 1
			/* Restore the grid and cursor position. */
d1275 1
a1331 1

@


1.9
log
@Support "alternate screen" mode (terminfo smcup/rmcup) typically used by full
screen interactive programs to preserve the screen contents. When activated, it
saves a copy of the visible grid and disables scrolling into and resizing out
of the history; when deactivated the visible data is restored and the history
reenabled.
@
text
@d1 1
a1 1
/* $OpenBSD: input.c,v 1.8 2009/06/04 21:02:21 nicm Exp $ */
d38 1
a38 1
int	 input_new_argument(struct input_ctx *);
d126 1
a126 1
int
a134 2

	return (0);
@


1.8
log
@Implement the CBT (backward tab) sequence (\033[Z).
@
text
@d1 1
a1 1
/* $OpenBSD: input.c,v 1.7 2009/06/04 18:48:24 nicm Exp $ */
d1154 4
a1157 1
	uint16_t	n;
d1178 23
d1224 4
a1227 1
	uint16_t	 n;
d1247 41
@


1.7
log
@Proper support for tab stops (\033H etc), using a bitstring(3). Makes another
vttest test happy.
@
text
@d1 1
a1 1
/* $OpenBSD: input.c,v 1.6 2009/06/04 14:42:14 nicm Exp $ */
d70 1
d106 1
d930 24
@


1.6
log
@Okay, so I screwed up when testing this, doh. Unbreak so that CAN/SUB actually
do cancel the sequence, and tweak to make the code more clear.
@
text
@d1 1
a1 1
/* $OpenBSD: input.c,v 1.5 2009/06/04 14:24:49 nicm Exp $ */
d77 1
d107 1
d650 10
a659 6
		s->cx = ((s->cx / 8) * 8) + 8;
		if (s->cx > screen_size_x(s) - 1) {
			s->cx = 0;
			screen_write_cursordown(&ictx->ctx, 1);
		}
		screen_write_cursormove(&ictx->ctx, s->cx, s->cy);
d679 2
d691 4
d770 1
a770 1
	case 'B':	/* Dscs (ASCII) */
d789 2
d1042 25
@


1.5
log
@Oops, CAN and SUB should abort the sequence (return to first state), not remain
in the same state.
@
text
@d1 1
a1 1
/* $OpenBSD: input.c,v 1.4 2009/06/04 14:15:50 nicm Exp $ */
d402 2
a403 1
		} else if (ch != 0x18 && ch != 0x1a) {	/* CAN and SUB */
d406 1
a406 3
		} else {
			/* Handle C0 immediately. */
			input_handle_c0_control(ch, ictx);
d408 4
d473 2
a474 1
		} else if (ch != 0x18 && ch != 0x1a) {	/* CAN and SUB */
d477 1
a477 3
		} else  {
			/* Handle C0 immediately. */
			input_handle_c0_control(ch, ictx);
d479 4
@


1.4
log
@More input compatibility love. Support C0 within escape sequences, and the C0
control character VT (vertical tab, \013), which is treated as LF like
VT102. Makes another vttest happy.
@
text
@d1 1
a1 1
/* $OpenBSD: input.c,v 1.3 2009/06/03 23:30:40 nicm Exp $ */
d403 3
d471 3
@


1.3
log
@Implement the DEC alignment test. With the last change this is enough for the
first cursor test in vttest (in ports) to pass; it still shops a few more
problems though.
@
text
@d1 1
a1 1
/* $OpenBSD: input.c,v 1.2 2009/06/03 19:33:04 nicm Exp $ */
d397 16
d415 4
a418 7
	if (INPUT_PARAMETER(ch)) {
		input_new_argument(ictx);
		if (ch >= 0x3c && ch <= 0x3f) {
			/* Private control sequence. */
			ictx->private = ch;
			return;
		}
d439 3
d462 12
d642 3
@


1.2
log
@Pass window titles through vis(1). <0x20 is dropped anyway by the input state
machine but top-bit-set nonprintables could cause trouble, and they are neater
like this anyway.

Suggested by deraadt a few days ago.
@
text
@d1 1
a1 1
/* $OpenBSD: input.c,v 1.1 2009/06/01 22:58:49 nicm Exp $ */
d633 3
d658 1
a658 1
	case '0':	/* Dscs (graphics) */
d671 2
d677 2
d683 2
d689 12
a700 4
	case '8':	/* DECRC */
		memcpy(&ictx->cell, &ictx->saved_cell, sizeof ictx->cell);
		screen_write_cursormove(
		    &ictx->ctx, ictx->saved_cx, ictx->saved_cy);
@


1.1
log
@Import tmux, a terminal multiplexor allowing (among other things) a single
terminal to be switched between several different windows and programs
displayed on one terminal be detached from one terminal and moved to another.

ok deraadt pirofti
@
text
@d1 1
a1 1
/* $OpenBSD$ */
d478 1
a478 1
	if (ch >= 0x20 && ch != 0x7f) {
@

