head	1.88;
access;
symbols
	OPENBSD_6_0:1.76.0.2
	OPENBSD_6_0_BASE:1.76
	OPENBSD_5_9:1.74.0.2
	OPENBSD_5_9_BASE:1.74
	OPENBSD_5_8:1.65.0.4
	OPENBSD_5_8_BASE:1.65
	OPENBSD_5_7:1.59.0.2
	OPENBSD_5_7_BASE:1.59
	OPENBSD_5_6:1.54.0.4
	OPENBSD_5_6_BASE:1.54
	OPENBSD_5_5:1.50.0.4
	OPENBSD_5_5_BASE:1.50
	OPENBSD_5_4:1.47.0.2
	OPENBSD_5_4_BASE:1.47
	OPENBSD_5_3:1.32.0.2
	OPENBSD_5_3_BASE:1.32
	OPENBSD_5_2:1.21.0.2
	OPENBSD_5_2_BASE:1.21
	OPENBSD_5_1_BASE:1.17
	OPENBSD_5_1:1.17.0.6
	OPENBSD_5_0:1.17.0.4
	OPENBSD_5_0_BASE:1.17
	OPENBSD_4_9:1.17.0.2
	OPENBSD_4_9_BASE:1.17
	OPENBSD_4_8:1.16.0.2
	OPENBSD_4_8_BASE:1.16
	OPENBSD_4_7:1.15.0.2
	OPENBSD_4_7_BASE:1.15
	OPENBSD_4_6:1.2.0.4
	OPENBSD_4_6_BASE:1.2;
locks; strict;
comment	@ * @;


1.88
date	2017.03.17.14.41.54;	author nicm;	state Exp;
branches;
next	1.87;
commitid	Jktu3tM06rv7V4ip;

1.87
date	2017.02.16.10.53.25;	author nicm;	state Exp;
branches;
next	1.86;
commitid	LqXOE9qmWQgnS4l6;

1.86
date	2017.02.03.11.57.28;	author nicm;	state Exp;
branches;
next	1.85;
commitid	BLRh0qXo7OVTPhiT;

1.85
date	2017.01.24.21.50.23;	author nicm;	state Exp;
branches;
next	1.84;
commitid	RhpGrb29XR7z4pyo;

1.84
date	2017.01.15.22.00.56;	author nicm;	state Exp;
branches;
next	1.83;
commitid	P8Zuj7wnJMd8B8vz;

1.83
date	2017.01.07.15.28.13;	author nicm;	state Exp;
branches;
next	1.82;
commitid	llgkTzvAhxXuSWDB;

1.82
date	2016.10.16.19.04.05;	author nicm;	state Exp;
branches;
next	1.81;
commitid	pxm6osuE99zELpkU;

1.81
date	2016.10.16.17.55.14;	author nicm;	state Exp;
branches;
next	1.80;
commitid	1xIYFpLYkPIXNEvU;

1.80
date	2016.10.13.20.27.27;	author nicm;	state Exp;
branches;
next	1.79;
commitid	txCyQ5BkKJtZRzfT;

1.79
date	2016.10.11.13.21.59;	author nicm;	state Exp;
branches;
next	1.78;
commitid	80rgEIPcNpyBnf95;

1.78
date	2016.10.11.07.23.34;	author nicm;	state Exp;
branches;
next	1.77;
commitid	leUN1UeapgUoieJj;

1.77
date	2016.09.12.15.40.58;	author nicm;	state Exp;
branches;
next	1.76;
commitid	FmdCsJJj2mhuDrZn;

1.76
date	2016.04.28.07.20.26;	author nicm;	state Exp;
branches;
next	1.75;
commitid	xj45RT4P4E2ho911;

1.75
date	2016.04.26.10.18.57;	author nicm;	state Exp;
branches;
next	1.74;
commitid	BxjorjSOAut2qPDG;

1.74
date	2016.01.19.15.59.12;	author nicm;	state Exp;
branches;
next	1.73;
commitid	P3qmSOx6KrDBsb0c;

1.73
date	2015.12.11.16.37.21;	author nicm;	state Exp;
branches;
next	1.72;
commitid	pfV7j8HdB7hdHnZm;

1.72
date	2015.12.11.12.27.36;	author nicm;	state Exp;
branches;
next	1.71;
commitid	ns7JfXpW9TsHrnT3;

1.71
date	2015.12.08.08.34.18;	author nicm;	state Exp;
branches;
next	1.70;
commitid	MRfGAYPLeVqV46rT;

1.70
date	2015.11.18.14.27.44;	author nicm;	state Exp;
branches;
next	1.69;
commitid	RjsAPRkWwvS79w40;

1.69
date	2015.11.12.11.09.11;	author nicm;	state Exp;
branches;
next	1.68;
commitid	tEN3cHiOuN3KscbT;

1.68
date	2015.11.12.11.05.34;	author nicm;	state Exp;
branches;
next	1.67;
commitid	Ih1tdqtjpnEyfE8x;

1.67
date	2015.10.27.15.58.43;	author nicm;	state Exp;
branches;
next	1.66;
commitid	89xhQafU35Q5MQVC;

1.66
date	2015.08.28.12.25.42;	author nicm;	state Exp;
branches;
next	1.65;
commitid	6bG4Sc33YFhgSCnx;

1.65
date	2015.06.05.18.18.32;	author nicm;	state Exp;
branches;
next	1.64;
commitid	ZQGnMCbBqbBRSCmt;

1.64
date	2015.05.08.16.23.34;	author nicm;	state Exp;
branches;
next	1.63;
commitid	liqxkhz3VaAx6PRF;

1.63
date	2015.05.07.08.08.54;	author nicm;	state Exp;
branches;
next	1.62;
commitid	w1QdYIaJj92r1JR4;

1.62
date	2015.05.04.13.04.10;	author nicm;	state Exp;
branches;
next	1.61;
commitid	NFTo4g6dXUhbX38D;

1.61
date	2015.04.19.21.34.21;	author nicm;	state Exp;
branches;
next	1.60;
commitid	wug6ctIOfhVMeWQp;

1.60
date	2015.03.31.17.45.10;	author nicm;	state Exp;
branches;
next	1.59;
commitid	2uQloBaX92ri1PyE;

1.59
date	2015.02.05.10.29.43;	author nicm;	state Exp;
branches;
next	1.58;
commitid	b1G1TVWY7l4KyoY6;

1.58
date	2015.01.15.13.43.13;	author nicm;	state Exp;
branches;
next	1.57;
commitid	uBlD4Vjxm2jNWcC2;

1.57
date	2014.11.30.08.03.29;	author nicm;	state Exp;
branches;
next	1.56;
commitid	0xxsJuH6TmmoEwPt;

1.56
date	2014.10.22.23.18.53;	author nicm;	state Exp;
branches;
next	1.55;
commitid	eFDptKeckheZa4ap;

1.55
date	2014.10.08.17.35.58;	author nicm;	state Exp;
branches;
next	1.54;
commitid	mK8z9uVwDZMfiNoM;

1.54
date	2014.05.08.07.54.47;	author nicm;	state Exp;
branches;
next	1.53;

1.53
date	2014.04.17.14.13.59;	author nicm;	state Exp;
branches;
next	1.52;

1.52
date	2014.04.03.08.20.29;	author nicm;	state Exp;
branches;
next	1.51;

1.51
date	2014.03.31.21.36.43;	author nicm;	state Exp;
branches;
next	1.50;

1.50
date	2014.01.28.23.07.09;	author nicm;	state Exp;
branches;
next	1.49;

1.49
date	2014.01.09.13.58.06;	author nicm;	state Exp;
branches;
next	1.48;

1.48
date	2013.10.10.11.58.52;	author nicm;	state Exp;
branches;
next	1.47;

1.47
date	2013.04.22.22.17.29;	author nicm;	state Exp;
branches;
next	1.46;

1.46
date	2013.03.25.10.11.45;	author nicm;	state Exp;
branches;
next	1.45;

1.45
date	2013.03.24.09.54.10;	author nicm;	state Exp;
branches;
next	1.44;

1.44
date	2013.03.22.15.54.29;	author nicm;	state Exp;
branches;
next	1.43;

1.43
date	2013.03.22.15.52.42;	author nicm;	state Exp;
branches;
next	1.42;

1.42
date	2013.03.22.15.50.42;	author nicm;	state Exp;
branches;
next	1.41;

1.41
date	2013.03.22.15.49.55;	author nicm;	state Exp;
branches;
next	1.40;

1.40
date	2013.03.22.10.38.33;	author nicm;	state Exp;
branches;
next	1.39;

1.39
date	2013.03.22.10.31.22;	author nicm;	state Exp;
branches;
next	1.38;

1.38
date	2013.03.21.16.22.48;	author nicm;	state Exp;
branches;
next	1.37;

1.37
date	2013.03.21.16.20.26;	author nicm;	state Exp;
branches;
next	1.36;

1.36
date	2013.03.21.16.19.25;	author nicm;	state Exp;
branches;
next	1.35;

1.35
date	2013.03.21.16.09.59;	author nicm;	state Exp;
branches;
next	1.34;

1.34
date	2013.03.21.16.09.17;	author nicm;	state Exp;
branches;
next	1.33;

1.33
date	2013.03.21.16.08.25;	author nicm;	state Exp;
branches;
next	1.32;

1.32
date	2013.02.05.11.08.59;	author nicm;	state Exp;
branches;
next	1.31;

1.31
date	2012.12.24.12.34.32;	author nicm;	state Exp;
branches;
next	1.30;

1.30
date	2012.12.24.12.24.21;	author nicm;	state Exp;
branches;
next	1.29;

1.29
date	2012.10.26.14.35.42;	author nicm;	state Exp;
branches;
next	1.28;

1.28
date	2012.10.11.08.53.50;	author nicm;	state Exp;
branches;
next	1.27;

1.27
date	2012.10.02.08.16.28;	author nicm;	state Exp;
branches;
next	1.26;

1.26
date	2012.09.03.09.57.57;	author nicm;	state Exp;
branches;
next	1.25;

1.25
date	2012.08.27.21.29.23;	author nicm;	state Exp;
branches;
next	1.24;

1.24
date	2012.08.14.09.17.14;	author nicm;	state Exp;
branches;
next	1.23;

1.23
date	2012.08.12.06.22.26;	author nicm;	state Exp;
branches;
next	1.22;

1.22
date	2012.08.11.06.45.33;	author nicm;	state Exp;
branches;
next	1.21;

1.21
date	2012.07.10.11.53.01;	author nicm;	state Exp;
branches;
next	1.20;

1.20
date	2012.06.25.14.27.25;	author nicm;	state Exp;
branches;
next	1.19;

1.19
date	2012.06.25.14.08.55;	author nicm;	state Exp;
branches;
next	1.18;

1.18
date	2012.04.23.22.40.47;	author nicm;	state Exp;
branches;
next	1.17;

1.17
date	2010.12.29.21.49.06;	author nicm;	state Exp;
branches;
next	1.16;

1.16
date	2010.05.23.19.42.19;	author nicm;	state Exp;
branches;
next	1.15;

1.15
date	2010.02.01.22.15.51;	author nicm;	state Exp;
branches;
next	1.14;

1.14
date	2010.01.11.23.46.22;	author nicm;	state Exp;
branches;
next	1.13;

1.13
date	2009.12.03.22.50.10;	author nicm;	state Exp;
branches;
next	1.12;

1.12
date	2009.11.26.21.37.13;	author nicm;	state Exp;
branches;
next	1.11;

1.11
date	2009.11.17.13.06.11;	author nicm;	state Exp;
branches;
next	1.10;

1.10
date	2009.10.11.07.01.10;	author nicm;	state Exp;
branches;
next	1.9;

1.9
date	2009.09.10.17.16.24;	author nicm;	state Exp;
branches;
next	1.8;

1.8
date	2009.08.05.16.26.38;	author nicm;	state Exp;
branches;
next	1.7;

1.7
date	2009.07.30.07.04.50;	author nicm;	state Exp;
branches;
next	1.6;

1.6
date	2009.07.28.07.03.32;	author nicm;	state Exp;
branches;
next	1.5;

1.5
date	2009.07.27.19.29.35;	author nicm;	state Exp;
branches;
next	1.4;

1.4
date	2009.07.27.18.51.46;	author nicm;	state Exp;
branches;
next	1.3;

1.3
date	2009.07.17.07.05.58;	author nicm;	state Exp;
branches;
next	1.2;

1.2
date	2009.06.24.23.00.31;	author nicm;	state Exp;
branches;
next	1.1;

1.1
date	2009.06.01.22.58.49;	author nicm;	state Exp;
branches;
next	;


desc
@@


1.88
log
@Add h and l for collapse and expand in choose mode with vi(1) keys, from
Gregory Pakosz.
@
text
@/* $OpenBSD: window-choose.c,v 1.87 2017/02/16 10:53:25 nicm Exp $ */

/*
 * Copyright (c) 2009 Nicholas Marriott <nicholas.marriott@@gmail.com>
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF MIND, USE, DATA OR PROFITS, WHETHER
 * IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING
 * OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */

#include <sys/types.h>

#include <ctype.h>
#include <stdlib.h>
#include <string.h>

#include "tmux.h"

static struct screen *window_choose_init(struct window_pane *);
static void	window_choose_free(struct window_pane *);
static void	window_choose_resize(struct window_pane *, u_int, u_int);
static void	window_choose_key(struct window_pane *, struct client *,
		    struct session *, key_code, struct mouse_event *);

static void	window_choose_default_callback(struct window_choose_data *);
static struct window_choose_mode_item *window_choose_get_item(
		    struct window_pane *, key_code, struct mouse_event *);

static void	window_choose_fire_callback(struct window_pane *,
		    struct window_choose_data *);
static void	window_choose_redraw_screen(struct window_pane *);
static void	window_choose_write_line(struct window_pane *,
		    struct screen_write_ctx *, u_int);

static void	window_choose_scroll_up(struct window_pane *);
static void	window_choose_scroll_down(struct window_pane *);

static void	window_choose_collapse(struct window_pane *, struct session *,
		    u_int);
static void	window_choose_expand(struct window_pane *, struct session *,
		    u_int);
static void	window_choose_collapse_all(struct window_pane *);

static void	window_choose_data_free(struct window_choose_data *);

enum window_choose_input_type {
	WINDOW_CHOOSE_NORMAL = -1,
	WINDOW_CHOOSE_GOTO_ITEM,
};

const struct window_mode window_choose_mode = {
	.init = window_choose_init,
	.free = window_choose_free,
	.resize = window_choose_resize,
	.key = window_choose_key,
};

struct window_choose_mode_item {
	struct window_choose_data	*wcd;
	char				*name;
	int				 pos;
	int				 state;
#define TREE_EXPANDED 0x1
};

struct window_choose_mode_data {
	struct screen	        screen;

	struct window_choose_mode_item *list;
	u_int			list_size;
	struct window_choose_mode_item *old_list;
	u_int			old_list_size;

	int			width;
	u_int			top;
	u_int			selected;
	enum window_choose_input_type input_type;
	const char		*input_prompt;
	char			*input_str;

	void 			(*callbackfn)(struct window_choose_data *);
};

static const char window_choose_keys_emacs[] = "0123456789"
	                                       "abcdefghijklmnoprstuvwxyz"
	                                       "ABCDEFGHIJKLMNOPQRSTUVWXYZ";
static const char window_choose_keys_vi[] = "0123456789"
	                                    "abcdefimnoprstuvwxyz"
	                                    "ABCDEFIJKMNOPQRSTUVWXYZ";

static void	window_choose_free1(struct window_choose_mode_data *);
static int	window_choose_key_index(struct window_pane *, u_int);
static int	window_choose_index_key(struct window_pane *, key_code);
static void	window_choose_prompt_input(enum window_choose_input_type,
		    const char *, struct window_pane *, key_code);
static void	window_choose_reset_top(struct window_pane *, u_int);

void
window_choose_add(struct window_pane *wp, struct window_choose_data *wcd)
{
	struct window_choose_mode_data	*data = wp->modedata;
	struct window_choose_mode_item	*item;
	char				 tmp[11];

	data->list = xreallocarray(data->list, data->list_size + 1,
	    sizeof *data->list);
	item = &data->list[data->list_size++];

	item->name = format_expand(wcd->ft, wcd->ft_template);
	item->wcd = wcd;
	item->pos = data->list_size - 1;
	item->state = 0;

	data->width = xsnprintf(tmp, sizeof tmp, "%d", item->pos);
}

void
window_choose_set_current(struct window_pane *wp, u_int cur)
{
	struct window_choose_mode_data	*data = wp->modedata;
	struct screen			*s = &data->screen;

	data->selected = cur;
	window_choose_reset_top(wp, screen_size_y(s));
}

static void
window_choose_reset_top(struct window_pane *wp, u_int sy)
{
	struct window_choose_mode_data	*data = wp->modedata;

	data->top = 0;
	if (data->selected > sy - 1)
		data->top = data->selected - (sy - 1);

	window_choose_redraw_screen(wp);
}

void
window_choose_ready(struct window_pane *wp, u_int cur,
    void (*callbackfn)(struct window_choose_data *))
{
	struct window_choose_mode_data	*data = wp->modedata;
	u_int				 size;

	data->callbackfn = callbackfn;
	if (data->callbackfn == NULL)
		data->callbackfn = window_choose_default_callback;

	size = data->old_list_size;
	data->old_list_size += data->list_size;
	data->old_list = xreallocarray(data->old_list, data->old_list_size,
	    sizeof *data->old_list);
	memcpy(data->old_list + size, data->list, data->list_size *
	    sizeof *data->list);

	window_choose_set_current(wp, cur);
	window_choose_collapse_all(wp);
}

static struct screen *
window_choose_init(struct window_pane *wp)
{
	struct window_choose_mode_data	*data;
	struct screen			*s;

	wp->modedata = data = xcalloc(1, sizeof *data);

	data->callbackfn = NULL;
	data->input_type = WINDOW_CHOOSE_NORMAL;
	data->input_str = xstrdup("");
	data->input_prompt = NULL;

	data->list = NULL;
	data->list_size = 0;

	data->old_list = NULL;
	data->old_list_size = 0;

	data->top = 0;

	s = &data->screen;
	screen_init(s, screen_size_x(&wp->base), screen_size_y(&wp->base), 0);
	s->mode &= ~MODE_CURSOR;

	return (s);
}

struct window_choose_data *
window_choose_data_create(int type, struct client *c, struct session *s)
{
	struct window_choose_data	*wcd;

	wcd = xmalloc(sizeof *wcd);
	wcd->type = type;

	wcd->ft = format_create(NULL, FORMAT_NONE, 0);
	wcd->ft_template = NULL;

	wcd->command = NULL;

	wcd->wl = NULL;
	wcd->pane_id = -1;
	wcd->idx = -1;

	wcd->tree_session = NULL;

	wcd->start_client = c;
	wcd->start_client->references++;
	wcd->start_session = s;
	wcd->start_session->references++;

	return (wcd);
}

static void
window_choose_data_free(struct window_choose_data *wcd)
{
	server_client_unref(wcd->start_client);
	session_unref(wcd->start_session);

	if (wcd->tree_session != NULL)
		session_unref(wcd->tree_session);

	free(wcd->ft_template);
	format_free(wcd->ft);

	free(wcd->command);
	free(wcd);
}

void
window_choose_data_run(struct window_choose_data *cdata)
{
	struct cmd_list		*cmdlist;
	char			*cause;
	struct cmdq_item	*item;

	/*
	 * The command template will have already been replaced. But if it's
	 * NULL, bail here.
	 */
	if (cdata->command == NULL)
		return;

	cmdlist = cmd_string_parse(cdata->command, NULL, 0, &cause);
	if (cmdlist == NULL) {
		if (cause != NULL) {
			*cause = toupper((u_char) *cause);
			status_message_set(cdata->start_client, "%s", cause);
			free(cause);
		}
		return;
	}

	item = cmdq_get_command(cmdlist, NULL, NULL, 0);
	cmdq_append(cdata->start_client, item);
	cmd_list_free(cmdlist);
}

static void
window_choose_default_callback(struct window_choose_data *wcd)
{
	if (wcd == NULL)
		return;
	if (wcd->start_client->flags & CLIENT_DEAD)
		return;

	window_choose_data_run(wcd);
}

static void
window_choose_free(struct window_pane *wp)
{
	if (wp->modedata != NULL)
		window_choose_free1(wp->modedata);
}

static void
window_choose_free1(struct window_choose_mode_data *data)
{
	struct window_choose_mode_item	*item;
	u_int				 i;

	if (data == NULL)
		return;

	for (i = 0; i < data->old_list_size; i++) {
		item = &data->old_list[i];
		window_choose_data_free(item->wcd);
		free(item->name);
	}
	free(data->list);
	free(data->old_list);

	free(data->input_str);

	screen_free(&data->screen);
	free(data);
}

static void
window_choose_resize(struct window_pane *wp, u_int sx, u_int sy)
{
	struct window_choose_mode_data	*data = wp->modedata;
	struct screen			*s = &data->screen;

	window_choose_reset_top(wp, sy);
	screen_resize(s, sx, sy, 0);
	window_choose_redraw_screen(wp);
}

static void
window_choose_fire_callback(struct window_pane *wp,
    struct window_choose_data *wcd)
{
	struct window_choose_mode_data	*data = wp->modedata;

	wp->modedata = NULL;
	window_pane_reset_mode(wp);

	data->callbackfn(wcd);

	window_choose_free1(data);
}

static void
window_choose_prompt_input(enum window_choose_input_type input_type,
    const char *prompt, struct window_pane *wp, key_code key)
{
	struct window_choose_mode_data	*data = wp->modedata;
	size_t				 input_len;

	data->input_type = input_type;
	data->input_prompt = prompt;
	input_len = strlen(data->input_str) + 2;

	data->input_str = xrealloc(data->input_str, input_len);
	data->input_str[input_len - 2] = key;
	data->input_str[input_len - 1] = '\0';

	window_choose_redraw_screen(wp);
}

static void
window_choose_collapse(struct window_pane *wp, struct session *s, u_int pos)
{
	struct window_choose_mode_data	*data = wp->modedata;
	struct window_choose_mode_item	*item, *chosen, *copy = NULL;
	struct window_choose_data	*wcd;
	u_int				 i, copy_size = 0;

	chosen = &data->list[pos];
	chosen->state &= ~TREE_EXPANDED;

	/*
	 * Trying to mangle the &data->list in-place has lots of problems, so
	 * assign the actual result we want to render and copy the new one over
	 * the top of it.
	 */
	for (i = 0; i < data->list_size; i++) {
		item = &data->list[i];
		wcd = item->wcd;

		if (s == wcd->tree_session) {
			/* We only show the session when collapsed. */
			if (wcd->type & TREE_SESSION) {
				item->state &= ~TREE_EXPANDED;

				copy = xreallocarray(copy, copy_size + 1,
				    sizeof *copy);
				memcpy(&copy[copy_size], item, sizeof *copy);
				copy_size++;

				/*
				 * Update the selection to this session item so
				 * we don't end up highlighting a non-existent
				 * item.
				 */
				data->selected = i;
			}
		} else {
			copy = xreallocarray(copy, copy_size + 1, sizeof *copy);
			memcpy(&copy[copy_size], item, sizeof *copy);
			copy_size++;
		}
	}

	if (copy_size != 0) {
		free(data->list);
		data->list = copy;
		data->list_size = copy_size;
	}
}

static void
window_choose_collapse_all(struct window_pane *wp)
{
	struct window_choose_mode_data	*data = wp->modedata;
	struct window_choose_mode_item	*item;
	struct screen			*scr = &data->screen;
	struct session			*s, *chosen;
	u_int				 i;

	chosen = data->list[data->selected].wcd->start_session;

	RB_FOREACH(s, sessions, &sessions)
		window_choose_collapse(wp, s, data->selected);

	/* Reset the selection back to the starting session. */
	for (i = 0; i < data->list_size; i++) {
		item = &data->list[i];

		if (chosen != item->wcd->tree_session)
			continue;

		if (item->wcd->type & TREE_SESSION)
			data->selected = i;
	}
	window_choose_reset_top(wp, screen_size_y(scr));
}

void
window_choose_expand_all(struct window_pane *wp)
{
	struct window_choose_mode_data	*data = wp->modedata;
	struct window_choose_mode_item	*item;
	struct screen			*scr = &data->screen;
	struct session			*s;
	u_int				 i;

	RB_FOREACH(s, sessions, &sessions) {
		for (i = 0; i < data->list_size; i++) {
			item = &data->list[i];

			if (s != item->wcd->tree_session)
				continue;

			if (item->wcd->type & TREE_SESSION)
				window_choose_expand(wp, s, i);
		}
	}

	window_choose_reset_top(wp, screen_size_y(scr));
}

static void
window_choose_expand(struct window_pane *wp, struct session *s, u_int pos)
{
	struct window_choose_mode_data	*data = wp->modedata;
	struct window_choose_mode_item	*item, *chosen;
	struct window_choose_data	*wcd;
	u_int				 i, items;

	chosen = &data->list[pos];
	items = data->old_list_size - 1;

	/* It's not possible to expand anything other than sessions. */
	if (!(chosen->wcd->type & TREE_SESSION))
		return;

	/* Don't re-expand a session which is already expanded. */
	if (chosen->state & TREE_EXPANDED)
		return;

	/* Mark the session entry as expanded. */
	chosen->state |= TREE_EXPANDED;

	/*
	 * Go back through the original list of all sessions and windows, and
	 * pull out the windows where the session matches the selection chosen
	 * to expand.
	 */
	for (i = items; i > 0; i--) {
		item = &data->old_list[i];
		item->state |= TREE_EXPANDED;
		wcd = item->wcd;

		if (s == wcd->tree_session) {
			/*
			 * Since the session is already displayed, we only care
			 * to add back in window for it.
			 */
			if (wcd->type & TREE_WINDOW) {
				/*
				 * If the insertion point for adding the
				 * windows to the session falls inside the
				 * range of the list, then we insert these
				 * entries in order *AFTER* the selected
				 * session.
				 */
				if (pos < i) {
					data->list = xreallocarray(data->list,
					    data->list_size + 1,
					    sizeof *data->list);
					memmove(&data->list[pos + 2],
					    &data->list[pos + 1],
					    (data->list_size - (pos + 1)) *
					    sizeof *data->list);
					memcpy(&data->list[pos + 1],
					    &data->old_list[i],
					    sizeof *data->list);
					data->list_size++;
				} else {
					/* Ran out of room, add to the end. */
					data->list = xreallocarray(data->list,
					    data->list_size + 1,
					    sizeof *data->list);
					memcpy(&data->list[data->list_size],
					    &data->old_list[i],
					    sizeof *data->list);
					data->list_size++;
				}
			}
		}
	}
}

static struct window_choose_mode_item *
window_choose_get_item(struct window_pane *wp, key_code key,
    struct mouse_event *m)
{
	struct window_choose_mode_data	*data = wp->modedata;
	u_int				 x, y, idx;

	if (!KEYC_IS_MOUSE(key))
		return (&data->list[data->selected]);

	if (cmd_mouse_at(wp, m, &x, &y, 0) != 0)
		return (NULL);

	idx = data->top + y;
	if (idx >= data->list_size)
		return (NULL);
	return (&data->list[idx]);
}

static key_code
window_choose_translate_key(key_code key)
{
	switch (key) {
	case '0'|KEYC_ESCAPE:
	case '1'|KEYC_ESCAPE:
	case '2'|KEYC_ESCAPE:
	case '3'|KEYC_ESCAPE:
	case '4'|KEYC_ESCAPE:
	case '5'|KEYC_ESCAPE:
	case '6'|KEYC_ESCAPE:
	case '7'|KEYC_ESCAPE:
	case '8'|KEYC_ESCAPE:
	case '9'|KEYC_ESCAPE:
	case '\003': /* C-c */
	case 'q':
	case '\n':
	case '\r':
	case KEYC_BSPACE:
	case ' ':
	case KEYC_LEFT|KEYC_CTRL:
	case KEYC_RIGHT|KEYC_CTRL:
	case KEYC_MOUSEDOWN1_PANE:
	case KEYC_MOUSEDOWN3_PANE:
	case KEYC_WHEELUP_PANE:
	case KEYC_WHEELDOWN_PANE:
		return (key);
	case '\031': /* C-y */
	case KEYC_UP|KEYC_CTRL:
		return (KEYC_UP|KEYC_CTRL);
	case '\002': /* C-b */
	case KEYC_PPAGE:
		return (KEYC_PPAGE);
	case '\005': /* C-e */
	case KEYC_DOWN|KEYC_CTRL:
		return (KEYC_DOWN|KEYC_CTRL);
	case '\006': /* C-f */
	case KEYC_NPAGE:
		return (KEYC_NPAGE);
	case 'h':
	case KEYC_LEFT:
		return (KEYC_LEFT);
	case 'j':
	case KEYC_DOWN:
		return (KEYC_DOWN);
	case 'k':
	case KEYC_UP:
		return (KEYC_UP);
	case 'l':
	case KEYC_RIGHT:
		return (KEYC_RIGHT);
	case 'g':
	case KEYC_HOME:
		return (KEYC_HOME);
	case 'G':
	case KEYC_END:
		return (KEYC_END);
	case 'H':
		return ('R'|KEYC_ESCAPE);
	case 'L':
		return ('r'|KEYC_ESCAPE);
	}
	if ((key >= '0' && key <= '9') ||
	    (key >= 'a' && key <= 'z') ||
	    (key >= 'A' && key <= 'Z'))
		return (key);
	return (KEYC_NONE);
}

static void
window_choose_key(struct window_pane *wp, __unused struct client *c,
    __unused struct session *sp, key_code key, struct mouse_event *m)
{
	struct window_choose_mode_data	*data = wp->modedata;
	struct screen			*s = &data->screen;
	struct screen_write_ctx		 ctx;
	struct window_choose_mode_item	*item;
	size_t				 input_len;
	u_int				 items, n;
	int				 idx, keys;

	keys = options_get_number(wp->window->options, "mode-keys");
	if (keys == MODEKEY_VI) {
		key = window_choose_translate_key(key);
		if (key == KEYC_NONE)
			return;
	}
	items = data->list_size;

	if (data->input_type == WINDOW_CHOOSE_GOTO_ITEM) {
		switch (key) {
		case '\003': /* C-c */
		case '\033': /* Escape */
		case 'q':
			data->input_type = WINDOW_CHOOSE_NORMAL;
			window_choose_redraw_screen(wp);
			break;
		case '\n':
		case '\r':
			n = strtonum(data->input_str, 0, INT_MAX, NULL);
			if (n > items - 1) {
				data->input_type = WINDOW_CHOOSE_NORMAL;
				window_choose_redraw_screen(wp);
				break;
			}
			window_choose_fire_callback(wp, data->list[n].wcd);
			break;
		case KEYC_BSPACE:
			input_len = strlen(data->input_str);
			if (input_len > 0)
				data->input_str[input_len - 1] = '\0';
			window_choose_redraw_screen(wp);
			break;
		default:
			if (key < '0' || key > '9')
				break;
			window_choose_prompt_input(WINDOW_CHOOSE_GOTO_ITEM,
			    "Goto Item", wp, key);
			break;
		}
		return;
	}

	switch (key) {
	case '\003': /* C-c */
	case '\033': /* Escape */
	case 'q':
		window_choose_fire_callback(wp, NULL);
		break;
	case '\n':
	case '\r':
	case KEYC_MOUSEDOWN1_PANE:
		if ((item = window_choose_get_item(wp, key, m)) == NULL)
			break;
		window_choose_fire_callback(wp, item->wcd);
		break;
	case ' ':
	case KEYC_MOUSEDOWN3_PANE:
		if ((item = window_choose_get_item(wp, key, m)) == NULL)
			break;
		if (item->state & TREE_EXPANDED) {
			window_choose_collapse(wp, item->wcd->tree_session,
			    data->selected);
		} else {
			window_choose_expand(wp, item->wcd->tree_session,
			    data->selected);
		}
		window_choose_redraw_screen(wp);
		break;
	case KEYC_LEFT:
		if ((item = window_choose_get_item(wp, key, m)) == NULL)
			break;
		if (item->state & TREE_EXPANDED) {
			window_choose_collapse(wp, item->wcd->tree_session,
			    data->selected);
			window_choose_redraw_screen(wp);
		}
		break;
	case KEYC_LEFT|KEYC_CTRL:
		window_choose_collapse_all(wp);
		break;
	case KEYC_RIGHT:
		if ((item = window_choose_get_item(wp, key, m)) == NULL)
			break;
		if (!(item->state & TREE_EXPANDED)) {
			window_choose_expand(wp, item->wcd->tree_session,
			    data->selected);
			window_choose_redraw_screen(wp);
		}
		break;
	case KEYC_RIGHT|KEYC_CTRL:
		window_choose_expand_all(wp);
		break;
	case '\020': /* C-p */
	case KEYC_UP:
	case KEYC_WHEELUP_PANE:
		if (items == 0)
			break;
		if (data->selected == 0) {
			data->selected = items - 1;
			if (data->selected > screen_size_y(s) - 1)
				data->top = items - screen_size_y(s);
			window_choose_redraw_screen(wp);
			break;
		}
		data->selected--;
		if (data->selected < data->top)
			window_choose_scroll_up(wp);
		else {
			screen_write_start(&ctx, wp, NULL);
			window_choose_write_line(wp, &ctx,
			    data->selected - data->top);
			window_choose_write_line(wp, &ctx,
			    data->selected + 1 - data->top);
			screen_write_stop(&ctx);
		}
		break;
	case '\016': /* C-n */
	case KEYC_DOWN:
	case KEYC_WHEELDOWN_PANE:
		if (items == 0)
			break;
		if (data->selected == items - 1) {
			data->selected = 0;
			data->top = 0;
			window_choose_redraw_screen(wp);
			break;
		}
		data->selected++;

		if (data->selected < data->top + screen_size_y(s)) {
			screen_write_start(&ctx, wp, NULL);
			window_choose_write_line(wp, &ctx,
			    data->selected - data->top);
			window_choose_write_line(wp, &ctx,
			    data->selected - 1 - data->top);
			screen_write_stop(&ctx);
		} else
			window_choose_scroll_down(wp);
		break;
	case KEYC_UP|KEYC_CTRL:
		if (items == 0 || data->top == 0)
			break;
		if (data->selected == data->top + screen_size_y(s) - 1) {
			data->selected--;
			window_choose_scroll_up(wp);
			screen_write_start(&ctx, wp, NULL);
			window_choose_write_line(wp, &ctx,
			    screen_size_y(s) - 1);
			screen_write_stop(&ctx);
		} else
			window_choose_scroll_up(wp);
		break;
	case KEYC_DOWN|KEYC_CTRL:
		if (items == 0 ||
		    data->top + screen_size_y(&data->screen) >= items)
			break;
		if (data->selected == data->top) {
			data->selected++;
			window_choose_scroll_down(wp);
			screen_write_start(&ctx, wp, NULL);
			window_choose_write_line(wp, &ctx, 0);
			screen_write_stop(&ctx);
		} else
			window_choose_scroll_down(wp);
		break;
	case KEYC_PPAGE:
		if (data->selected < screen_size_y(s)) {
			data->selected = 0;
			data->top = 0;
		} else {
			data->selected -= screen_size_y(s);
			if (data->top < screen_size_y(s))
				data->top = 0;
			else
				data->top -= screen_size_y(s);
		}
		window_choose_redraw_screen(wp);
		break;
	case KEYC_NPAGE:
		data->selected += screen_size_y(s);
		if (data->selected > items - 1)
			data->selected = items - 1;
		data->top += screen_size_y(s);
		if (screen_size_y(s) < items) {
			if (data->top + screen_size_y(s) > items)
				data->top = items - screen_size_y(s);
		} else
			data->top = 0;
		if (data->selected < data->top)
			data->top = data->selected;
		window_choose_redraw_screen(wp);
		break;
	case KEYC_BSPACE:
		input_len = strlen(data->input_str);
		if (input_len > 0)
			data->input_str[input_len - 1] = '\0';
		window_choose_redraw_screen(wp);
		break;
	case '0'|KEYC_ESCAPE:
	case '1'|KEYC_ESCAPE:
	case '2'|KEYC_ESCAPE:
	case '3'|KEYC_ESCAPE:
	case '4'|KEYC_ESCAPE:
	case '5'|KEYC_ESCAPE:
	case '6'|KEYC_ESCAPE:
	case '7'|KEYC_ESCAPE:
	case '8'|KEYC_ESCAPE:
	case '9'|KEYC_ESCAPE:
		key &= KEYC_MASK_KEY;
		if (key < '0' || key > '9')
			break;
		window_choose_prompt_input(WINDOW_CHOOSE_GOTO_ITEM,
		    "Goto Item", wp, key);
		break;
	case KEYC_HOME:
	case '<'|KEYC_ESCAPE:
		data->selected = 0;
		data->top = 0;
		window_choose_redraw_screen(wp);
		break;
	case 'R'|KEYC_ESCAPE:
		data->selected = data->top;
		window_choose_redraw_screen(wp);
		break;
	case 'r'|KEYC_ESCAPE:
		data->selected = data->top + screen_size_y(s) - 1;
		if (data->selected > items - 1)
			data->selected = items - 1;
		window_choose_redraw_screen(wp);
		break;
	case KEYC_END:
	case '>'|KEYC_ESCAPE:
		data->selected = items - 1;
		if (screen_size_y(s) < items)
			data->top = items - screen_size_y(s);
		else
			data->top = 0;
		window_choose_redraw_screen(wp);
		break;
	default:
		idx = window_choose_index_key(wp, key);
		if (idx < 0 || (u_int) idx >= data->list_size)
			break;
		data->selected = idx;
		window_choose_fire_callback(wp, data->list[idx].wcd);
		break;
	}
}

static void
window_choose_write_line(struct window_pane *wp, struct screen_write_ctx *ctx,
    u_int py)
{
	struct window_choose_mode_data	*data = wp->modedata;
	struct window_choose_mode_item	*item;
	struct options			*oo = wp->window->options;
	struct screen			*s = &data->screen;
	struct grid_cell		 gc;
	size_t				 last, xoff = 0;
	char				 hdr[32], label[32];
	int				 key;

	if (data->callbackfn == NULL)
		fatalx("called before callback assigned");

	last = screen_size_y(s) - 1;
	memcpy(&gc, &grid_default_cell, sizeof gc);
	gc.flags |= GRID_FLAG_NOPALETTE;
	if (data->selected == data->top + py)
		style_apply(&gc, oo, "mode-style");

	screen_write_cursormove(ctx, 0, py);
	if (data->top + py  < data->list_size) {
		item = &data->list[data->top + py];
		if (item->wcd->wl != NULL &&
		    item->wcd->wl->flags & WINLINK_ALERTFLAGS)
			gc.attr |= GRID_ATTR_BRIGHT;

		key = window_choose_key_index(wp, data->top + py);
		if (key != -1)
			xsnprintf(label, sizeof label, "(%c)", key);
		else
			xsnprintf(label, sizeof label, "(%d)", item->pos);
		screen_write_nputs(ctx, screen_size_x(s) - 1, &gc,
		    "%*s %s %s", data->width + 2, label,
		    /*
		     * Add indication to tree if necessary about whether it's
		     * expanded or not.
		     */
		    (item->wcd->type & TREE_SESSION) ?
		    ((item->state & TREE_EXPANDED) ? "-" : "+") : "", item->name);
	}
	while (s->cx < screen_size_x(s) - 1)
		screen_write_putc(ctx, &gc, ' ');

	if (data->input_type != WINDOW_CHOOSE_NORMAL) {
		style_apply(&gc, oo, "mode-style");

		xoff = xsnprintf(hdr, sizeof hdr,
			"%s: %s", data->input_prompt, data->input_str);
		screen_write_cursormove(ctx, 0, last);
		screen_write_puts(ctx, &gc, "%s", hdr);
		screen_write_cursormove(ctx, xoff, py);
		memcpy(&gc, &grid_default_cell, sizeof gc);
	}

}

static int
window_choose_key_index(struct window_pane *wp, u_int idx)
{
	const char	*ptr;
	int		 keys;

	keys = options_get_number(wp->window->options, "mode-keys");
	if (keys == MODEKEY_VI)
		ptr = window_choose_keys_vi;
	else
		ptr = window_choose_keys_emacs;
	for (; *ptr != '\0'; ptr++) {
		if (idx-- == 0)
			return (*ptr);
	}
	return (-1);
}

static int
window_choose_index_key(struct window_pane *wp, key_code key)
{
	const char	*ptr;
	int		 keys;
	u_int		 idx = 0;

	keys = options_get_number(wp->window->options, "mode-keys");
	if (keys == MODEKEY_VI)
		ptr = window_choose_keys_vi;
	else
		ptr = window_choose_keys_emacs;
	for (; *ptr != '\0'; ptr++) {
		if (key == (key_code)*ptr)
			return (idx);
		idx++;
	}
	return (-1);
}

static void
window_choose_redraw_screen(struct window_pane *wp)
{
	struct window_choose_mode_data	*data = wp->modedata;
	struct screen			*s = &data->screen;
	struct screen_write_ctx	 	 ctx;
	u_int				 i;

	screen_write_start(&ctx, wp, NULL);
	for (i = 0; i < screen_size_y(s); i++)
		window_choose_write_line(wp, &ctx, i);
	screen_write_stop(&ctx);
}

static void
window_choose_scroll_up(struct window_pane *wp)
{
	struct window_choose_mode_data	*data = wp->modedata;
	struct screen_write_ctx		 ctx;

	if (data->top == 0)
		return;
	data->top--;

	screen_write_start(&ctx, wp, NULL);
	screen_write_cursormove(&ctx, 0, 0);
	screen_write_insertline(&ctx, 1, 8);
	window_choose_write_line(wp, &ctx, 0);
	if (screen_size_y(&data->screen) > 1)
		window_choose_write_line(wp, &ctx, 1);
	screen_write_stop(&ctx);
}

static void
window_choose_scroll_down(struct window_pane *wp)
{
	struct window_choose_mode_data	*data = wp->modedata;
	struct screen			*s = &data->screen;
	struct screen_write_ctx		 ctx;

	if (data->top >= data->list_size)
		return;
	data->top++;

	screen_write_start(&ctx, wp, NULL);
	screen_write_cursormove(&ctx, 0, 0);
	screen_write_deleteline(&ctx, 1, 8);
	window_choose_write_line(wp, &ctx, screen_size_y(s) - 1);
	if (screen_size_y(&data->screen) > 1)
		window_choose_write_line(wp, &ctx, screen_size_y(s) - 2);
	screen_write_stop(&ctx);
}

struct window_choose_data *
window_choose_add_session(struct window_pane *wp, struct client *c,
    struct session *s, const char *template, const char *action, u_int idx)
{
	struct window_choose_data	*wcd;

	wcd = window_choose_data_create(TREE_SESSION, c, c->session);
	wcd->idx = s->id;

	wcd->tree_session = s;
	wcd->tree_session->references++;

	wcd->ft_template = xstrdup(template);
	format_add(wcd->ft, "line", "%u", idx);
	format_defaults(wcd->ft, NULL, s, NULL, NULL);

	wcd->command = cmd_template_replace(action, s->name, 1);

	window_choose_add(wp, wcd);

	return (wcd);
}

struct window_choose_data *
window_choose_add_window(struct window_pane *wp, struct client *c,
    struct session *s, struct winlink *wl, const char *template,
    const char *action, u_int idx)
{
	struct window_choose_data	*wcd;
	char				*expanded;

	wcd = window_choose_data_create(TREE_WINDOW, c, c->session);
	wcd->idx = wl->idx;

	wcd->wl = wl;

	wcd->tree_session = s;
	wcd->tree_session->references++;

	wcd->ft_template = xstrdup(template);
	format_add(wcd->ft, "line", "%u", idx);
	format_defaults(wcd->ft, NULL, s, wl, NULL);

	xasprintf(&expanded, "%s:%d", s->name, wl->idx);
	wcd->command = cmd_template_replace(action, expanded, 1);
	free(expanded);

	window_choose_add(wp, wcd);

	return (wcd);
}
@


1.87
log
@Style nits.
@
text
@d1 1
a1 1
/* $OpenBSD: window-choose.c,v 1.86 2017/02/03 11:57:28 nicm Exp $ */
d96 1
a96 1
	                                    "abcdefhilmnoprstuvwxyz"
a565 2
	case KEYC_LEFT:
	case KEYC_RIGHT:
d585 3
d594 3
@


1.86
log
@Add a window or pane id "tag" to each format tree and use it to separate
jobs, this means that if the same job is used for different windows or
panes (for example in pane-border-format), it will be run separately for
each pane.
@
text
@d1 1
a1 1
/* $OpenBSD: window-choose.c,v 1.85 2017/01/24 21:50:23 nicm Exp $ */
d913 1
a913 1
		    (item->state & TREE_EXPANDED ? "-" : "+") : "", item->name);
@


1.85
log
@Fixed keys for choose mode, and remove the last mode keys bits.
@
text
@d1 1
a1 1
/* $OpenBSD: window-choose.c,v 1.84 2017/01/15 22:00:56 nicm Exp $ */
d205 1
a205 1
	wcd->ft = format_create(NULL, 0);
@


1.84
log
@It is silly for cmd_list_parse to return an integer error when it could
just return NULL.
@
text
@d1 1
a1 1
/* $OpenBSD: window-choose.c,v 1.83 2017/01/07 15:28:13 nicm Exp $ */
a76 2
	struct mode_key_data	mdata;

d92 7
d100 2
a101 4
static int	window_choose_key_index(struct window_choose_mode_data *,
		    u_int);
static int	window_choose_index_key(struct window_choose_mode_data *,
		    key_code);
a173 1
	int				 keys;
a193 6
	keys = options_get_number(wp->window->options, "mode-keys");
	if (keys == MODEKEY_EMACS)
		mode_key_init(&data->mdata, &mode_key_tree_emacs_choice);
	else
		mode_key_init(&data->mdata, &mode_key_tree_vi_choice);

d546 65
d613 1
a613 1
    __unused struct session *sess, key_code key, struct mouse_event *m)
d621 1
a621 1
	int				 idx;
d623 6
d632 4
a635 2
		switch (mode_key_lookup(&data->mdata, key)) {
		case MODEKEYCHOICE_CANCEL:
d639 2
a640 1
		case MODEKEYCHOICE_CHOOSE:
d649 1
a649 1
		case MODEKEYCHOICE_BACKSPACE:
d665 4
a668 2
	switch (mode_key_lookup(&data->mdata, key)) {
	case MODEKEYCHOICE_CANCEL:
d671 3
a673 1
	case MODEKEYCHOICE_CHOOSE:
d678 2
a679 1
	case MODEKEYCHOICE_TREE_TOGGLE:
d691 1
a691 1
	case MODEKEYCHOICE_TREE_COLLAPSE:
d700 1
a700 1
	case MODEKEYCHOICE_TREE_COLLAPSE_ALL:
d703 1
a703 1
	case MODEKEYCHOICE_TREE_EXPAND:
d712 1
a712 1
	case MODEKEYCHOICE_TREE_EXPAND_ALL:
d715 3
a717 1
	case MODEKEYCHOICE_UP:
d739 3
a741 1
	case MODEKEYCHOICE_DOWN:
d762 1
a762 1
	case MODEKEYCHOICE_SCROLLUP:
d775 1
a775 1
	case MODEKEYCHOICE_SCROLLDOWN:
d788 1
a788 1
	case MODEKEYCHOICE_PAGEUP:
d801 1
a801 1
	case MODEKEYCHOICE_PAGEDOWN:
d815 1
a815 1
	case MODEKEYCHOICE_BACKSPACE:
d821 10
a830 1
	case MODEKEYCHOICE_STARTNUMBERPREFIX:
d837 2
a838 1
	case MODEKEYCHOICE_STARTOFLIST:
d843 1
a843 1
	case MODEKEYCHOICE_TOPLINE:
d847 1
a847 1
	case MODEKEYCHOICE_BOTTOMLINE:
d853 2
a854 1
	case MODEKEYCHOICE_ENDOFLIST:
d863 1
a863 1
		idx = window_choose_index_key(data, key);
d901 1
a901 1
		key = window_choose_key_index(data, data->top + py);
d932 1
a932 1
window_choose_key_index(struct window_choose_mode_data *data, u_int idx)
d934 9
a942 10
	static const char	keys[] = "0123456789"
	                                 "abcdefghijklmnopqrstuvwxyz"
	                                 "ABCDEFGHIJKLMNOPQRSTUVWXYZ";
	const char	       *ptr;
	int			mkey;

	for (ptr = keys; *ptr != '\0'; ptr++) {
		mkey = mode_key_lookup(&data->mdata, *ptr);
		if (mkey != MODEKEY_NONE && mkey != MODEKEY_OTHER)
			continue;
d950 1
a950 1
window_choose_index_key(struct window_choose_mode_data *data, key_code key)
d952 10
a961 11
	static const char	keys[] = "0123456789"
	                                 "abcdefghijklmnopqrstuvwxyz"
	                                 "ABCDEFGHIJKLMNOPQRSTUVWXYZ";
	const char	       *ptr;
	int			mkey;
	u_int			idx = 0;

	for (ptr = keys; *ptr != '\0'; ptr++) {
		mkey = mode_key_lookup(&data->mdata, *ptr);
		if (mkey != MODEKEY_NONE && mkey != MODEKEY_OTHER)
			continue;
@


1.83
log
@Add support for the OSC 4 and OSC 104 palette setting escape sequences,
from S Gilles.
@
text
@d1 1
a1 1
/* $OpenBSD: window-choose.c,v 1.82 2016/10/16 19:04:05 nicm Exp $ */
d258 2
a259 1
	if (cmd_string_parse(cdata->command, &cmdlist, NULL, 0, &cause) != 0) {
@


1.82
log
@Mass rename struct cmd_q to struct cmdq_item and related.
@
text
@d1 1
a1 1
/* $OpenBSD: window-choose.c,v 1.81 2016/10/16 17:55:14 nicm Exp $ */
d799 1
@


1.81
log
@Rewrite command queue handling. Each client still has a command queue,
but there is also now a global command queue. Instead of command queues
being dispatched on demand from wherever the command happens to be
added, they are now all dispatched from the top level server
loop. Command queues may now also include callbacks as well as commands,
and items may be inserted after the current command as well as at the end.

This all makes command queues significantly more predictable and easier
to use, and avoids the complex multiple nested command queues used by
source-file, if-shell and friends.

A mass rename of struct cmdq to a better name (cmdq_item probably) is
coming.
@
text
@d1 1
a1 1
/* $OpenBSD: window-choose.c,v 1.80 2016/10/13 20:27:27 nicm Exp $ */
d247 3
a249 3
	struct cmd_list	*cmdlist;
	char		*cause;
	struct cmd_q	*cmdq;
d267 2
a268 2
	cmdq = cmdq_get_command(cmdlist, NULL, NULL, 0);
	cmdq_append(cdata->start_client, cmdq);
@


1.80
log
@Add support for BCE (background colour erase). This makes various escape
sequences (notable EL and ED but also IL, DL, ICH, DCH) create blank
cells using the current background colour rather than the default
colour.

On modern systems BCE doesn't really have many benefits, but most other
terminals now support it, some (lazy) applications rely on it, and it is
not hard to include now that we have pane background colours anyway.

Mostly written by Sean Haugh.
@
text
@d1 1
a1 1
/* $OpenBSD: window-choose.c,v 1.79 2016/10/11 13:21:59 nicm Exp $ */
d249 1
d267 2
a268 1
	cmdq_run(cdata->start_client->cmdq, cmdlist, NULL);
@


1.79
log
@Add static in window-*.c and move some internal functions out of tmux.h.
@
text
@d1 1
a1 1
/* $OpenBSD: window-choose.c,v 1.78 2016/10/11 07:23:34 nicm Exp $ */
d903 1
a903 1
	screen_write_insertline(&ctx, 1);
d923 1
a923 1
	screen_write_deleteline(&ctx, 1);
@


1.78
log
@Fundamental change to how copy mode key bindings work:

The vi-copy and emacs-copy mode key tables are gone, and instead copy
mode commands are bound in one of two normal key tables ("copy-mode" or
"copy-mode-vi"). Keys are bound to "send-keys -X copy-mode-command". So:

    bind -temacs-copy C-Up scroll-up
    bind -temacs-copy -R5 WheelUpPane scroll-up

Becomes:

    bind -Tcopy-mode C-Up send -X scroll-up
    bind -Tcopy-mode WheelUpPane send -N5 -X scroll-up

This allows the full command parser and command set to be used - for
example, we can use the normal command prompt for searching, jumping,
and so on instead of a custom one:

    bind -Tcopy-mode C-r command-prompt -p'search up' "send -X search-backward '%%'"

command-prompt also gets a -1 option to only require on key press, which
is needed for jumping.

The plan is to get rid of mode keys entirely, so more to come eventually.
@
text
@d1 1
a1 1
/* $OpenBSD: window-choose.c,v 1.77 2016/09/12 15:40:58 nicm Exp $ */
d27 24
a50 15
struct screen *window_choose_init(struct window_pane *);
void	window_choose_free(struct window_pane *);
void	window_choose_resize(struct window_pane *, u_int, u_int);
void	window_choose_key(struct window_pane *, struct client *,
	    struct session *, key_code, struct mouse_event *);

void	window_choose_default_callback(struct window_choose_data *);
struct window_choose_mode_item *window_choose_get_item(struct window_pane *,
	    key_code, struct mouse_event *);

void	window_choose_fire_callback(struct window_pane *,
	    struct window_choose_data *);
void	window_choose_redraw_screen(struct window_pane *);
void	window_choose_write_line(struct window_pane *,
	    struct screen_write_ctx *, u_int);
d52 1
a52 5
void	window_choose_scroll_up(struct window_pane *);
void	window_choose_scroll_down(struct window_pane *);

void	window_choose_collapse(struct window_pane *, struct session *, u_int);
void	window_choose_expand(struct window_pane *, struct session *, u_int);
d94 8
a101 6
void	window_choose_free1(struct window_choose_mode_data *);
int     window_choose_key_index(struct window_choose_mode_data *, u_int);
int     window_choose_index_key(struct window_choose_mode_data *, key_code);
void	window_choose_prompt_input(enum window_choose_input_type,
	    const char *, struct window_pane *, key_code);
void	window_choose_reset_top(struct window_pane *, u_int);
d132 1
a132 1
void
d166 1
a166 1
struct screen *
d228 1
a228 1
void
d270 1
a270 1
void
d281 1
a281 1
void
d288 1
a288 1
void
d311 1
a311 1
void
d322 1
a322 1
void
d336 1
a336 1
void
d354 1
a354 1
void
d405 1
a405 1
void
d456 1
a456 1
void
d528 1
a528 1
struct window_choose_mode_item *
d547 1
a547 1
void
d779 1
a779 1
void
d837 1
a837 1
int
d856 1
a856 1
int
d877 1
a877 1
void
d891 1
a891 1
void
d910 1
a910 1
void
@


1.77
log
@Allow repeat count to be specified in mode key tables with bind-key -R,
and set the default repeat count to 5 for WheelUp and WheelDown in
copy-mode.
@
text
@d1 1
a1 1
/* $OpenBSD: window-choose.c,v 1.76 2016/04/28 07:20:26 nicm Exp $ */
d55 4
a58 4
	window_choose_init,
	window_choose_free,
	window_choose_resize,
	window_choose_key,
d555 1
a555 1
		switch (mode_key_lookup(&data->mdata, key, NULL, NULL)) {
d585 1
a585 1
	switch (mode_key_lookup(&data->mdata, key, NULL, NULL)) {
d840 1
a840 1
		mkey = mode_key_lookup(&data->mdata, *ptr, NULL, NULL);
d860 1
a860 1
		mkey = mode_key_lookup(&data->mdata, *ptr, NULL, NULL);
@


1.76
log
@memmove() the right size when expanding tree.
@
text
@d1 1
a1 1
/* $OpenBSD: window-choose.c,v 1.75 2016/04/26 10:18:57 nicm Exp $ */
d555 1
a555 1
		switch (mode_key_lookup(&data->mdata, key, NULL)) {
d585 1
a585 1
	switch (mode_key_lookup(&data->mdata, key, NULL)) {
d840 1
a840 1
		mkey = mode_key_lookup(&data->mdata, *ptr, NULL);
d860 1
a860 1
		mkey = mode_key_lookup(&data->mdata, *ptr, NULL);
@


1.75
log
@Remove last uses of array.h.
@
text
@d1 1
a1 1
/* $OpenBSD: window-choose.c,v 1.74 2016/01/19 15:59:12 nicm Exp $ */
d500 1
a500 1
					    (data->list_size - pos) *
@


1.74
log
@I no longer use my SourceForge address so replace it.
@
text
@d1 1
a1 1
/* $OpenBSD: window-choose.c,v 1.73 2015/12/11 16:37:21 nicm Exp $ */
a24 1
#include "array.h"
d74 5
a78 2
	ARRAY_DECL(, struct window_choose_mode_item) list;
	ARRAY_DECL(, struct window_choose_mode_item) old_list;
d101 1
a101 1
	char				 tmp[10];
d103 3
a105 2
	ARRAY_EXPAND(&data->list, 1);
	item = &ARRAY_LAST(&data->list);
d109 1
a109 1
	item->pos = ARRAY_LENGTH(&data->list) - 1;
d112 1
a112 1
	data->width = xsnprintf(tmp, sizeof tmp , "%d", item->pos);
d142 1
d148 6
a153 1
	ARRAY_CONCAT(&data->old_list, &data->list);
d166 1
a166 1
	wp->modedata = data = xmalloc(sizeof *data);
d173 6
a178 2
	ARRAY_INIT(&data->list);
	ARRAY_INIT(&data->old_list);
d290 2
a291 2
	for (i = 0; i < ARRAY_LENGTH(&data->old_list); i++) {
		item = &ARRAY_ITEM(&data->old_list, i);
d295 3
a297 2
	ARRAY_FREE(&data->list);
	ARRAY_FREE(&data->old_list);
d351 1
a351 1
	struct window_choose_mode_item	*item, *chosen;
d353 1
a353 4
	u_int				 i;

	ARRAY_DECL(, struct window_choose_mode_item) list_copy;
	ARRAY_INIT(&list_copy);
d355 1
a355 1
	chosen = &ARRAY_ITEM(&data->list, pos);
d363 2
a364 2
	for (i = 0; i < ARRAY_LENGTH(&data->list); i++) {
		item = &ARRAY_ITEM(&data->list, i);
d371 5
a375 1
				ARRAY_ADD(&list_copy, *item);
d384 5
a388 2
		} else
			ARRAY_ADD(&list_copy, ARRAY_ITEM(&data->list, i));
d391 4
a394 4
	if (!ARRAY_EMPTY(&list_copy)) {
		ARRAY_FREE(&data->list);
		ARRAY_CONCAT(&data->list, &list_copy);
		ARRAY_FREE(&list_copy);
d407 1
a407 1
	chosen = ARRAY_ITEM(&data->list, data->selected).wcd->start_session;
d413 2
a414 2
	for (i = 0; i < ARRAY_LENGTH(&data->list); i++) {
		item = &ARRAY_ITEM(&data->list, i);
d435 2
a436 2
		for (i = 0; i < ARRAY_LENGTH(&data->list); i++) {
			item = &ARRAY_ITEM(&data->list, i);
d457 2
a458 2
	chosen = &ARRAY_ITEM(&data->list, pos);
	items = ARRAY_LENGTH(&data->old_list) - 1;
d477 1
a477 1
		item = &ARRAY_ITEM(&data->old_list, i);
d494 12
a505 5
				if (pos < i ) {
					ARRAY_INSERT(&data->list,
					    pos + 1,
					    ARRAY_ITEM(&data->old_list,
					    i));
d508 7
a514 3
					ARRAY_ADD(&data->list,
					    ARRAY_ITEM(&data->old_list,
					    i));
d529 1
a529 1
		return (&ARRAY_ITEM(&data->list, data->selected));
d535 1
a535 1
	if (idx >= ARRAY_LENGTH(&data->list))
d537 1
a537 1
	return (&ARRAY_ITEM(&data->list, idx));
d552 1
a552 1
	items = ARRAY_LENGTH(&data->list);
d567 1
a567 2
			item = &ARRAY_ITEM(&data->list, n);
			window_choose_fire_callback(wp, item->wcd);
d764 1
a764 1
		if (idx < 0 || (u_int) idx >= ARRAY_LENGTH(&data->list))
d767 1
a767 3

		item = &ARRAY_ITEM(&data->list, data->selected);
		window_choose_fire_callback(wp, item->wcd);
d794 2
a795 2
	if (data->top + py  < ARRAY_LENGTH(&data->list)) {
		item = &ARRAY_ITEM(&data->list, data->top + py);
d910 1
a910 1
	if (data->top >= ARRAY_LENGTH(&data->list))
@


1.73
log
@Style nits and line wrapping of function declarations.
@
text
@d1 1
a1 1
/* $OpenBSD: window-choose.c,v 1.72 2015/12/11 12:27:36 nicm Exp $ */
d4 1
a4 1
 * Copyright (c) 2009 Nicholas Marriott <nicm@@users.sourceforge.net>
@


1.72
log
@Add cmdq as an argument to format_create and add a format for the
command name (will also be used for more later).
@
text
@d1 1
a1 1
/* $OpenBSD: window-choose.c,v 1.71 2015/12/08 08:34:18 nicm Exp $ */
d38 2
a39 2
void	window_choose_fire_callback(
	    struct window_pane *, struct window_choose_data *);
d41 2
a42 2
void	window_choose_write_line(
	    struct window_pane *, struct screen_write_ctx *, u_int);
d302 2
a303 2
window_choose_fire_callback(
    struct window_pane *wp, struct window_choose_data *wcd)
d617 4
a620 4
			window_choose_write_line(
			    wp, &ctx, data->selected - data->top);
			window_choose_write_line(
			    wp, &ctx, data->selected + 1 - data->top);
d637 4
a640 4
			window_choose_write_line(
			    wp, &ctx, data->selected - data->top);
			window_choose_write_line(
			    wp, &ctx, data->selected - 1 - data->top);
d652 2
a653 2
			window_choose_write_line(
			    wp, &ctx, screen_size_y(s) - 1);
@


1.71
log
@Remove format_create_flags and just pass flags to format_create.
@
text
@d1 1
a1 1
/* $OpenBSD: window-choose.c,v 1.70 2015/11/18 14:27:44 nicm Exp $ */
d189 1
a189 1
	wcd->ft = format_create(0);
@


1.70
log
@Use __unused rather than rolling our own.
@
text
@d1 1
a1 1
/* $OpenBSD: window-choose.c,v 1.69 2015/11/12 11:09:11 nicm Exp $ */
d189 1
a189 1
	wcd->ft = format_create();
@


1.69
log
@Nuke the utf8 and status-utf8 options and make tmux only a UTF-8
terminal. We still support non-UTF-8 terminals outside tmux, but inside
it is always UTF-8 (as when the utf8 and status-utf8 options were on).
@
text
@d1 1
a1 1
/* $OpenBSD: window-choose.c,v 1.68 2015/11/12 11:05:34 nicm Exp $ */
d512 2
a513 2
window_choose_key(struct window_pane *wp, unused struct client *c,
    unused struct session *sess, key_code key, struct mouse_event *m)
@


1.68
log
@Support UTF-8 key bindings by expanding the key type from int to
uint64_t and converting UTF-8 to Unicode on input and the reverse on
output. (This allows key bindings, there are still omissions - the
largest being that the various prompts do not accept UTF-8.)
@
text
@d1 1
a1 1
/* $OpenBSD: window-choose.c,v 1.67 2015/10/27 15:58:43 nicm Exp $ */
d757 1
a757 1
	int				 utf8flag, key;
a762 1
	utf8flag = options_get_number(wp->window->options, "utf8");
d779 1
a779 1
		screen_write_nputs(ctx, screen_size_x(s) - 1, &gc, utf8flag,
@


1.67
log
@Move struct options into options.c.
@
text
@d1 1
a1 1
/* $OpenBSD: window-choose.c,v 1.66 2015/08/28 12:25:42 nicm Exp $ */
d32 1
a32 1
	    struct session *, int, struct mouse_event *);
d36 1
a36 1
	    int, struct mouse_event *);
d89 1
a89 1
int     window_choose_index_key(struct window_choose_mode_data *, int);
d91 1
a91 1
	    const char *, struct window_pane *, int);
d317 1
a317 1
    const char *prompt, struct window_pane *wp, int key)
d493 2
a494 1
window_choose_get_item(struct window_pane *wp, int key, struct mouse_event *m)
d513 1
a513 1
    unused struct session *sess, int key, struct mouse_event *m)
d747 2
a748 2
window_choose_write_line(
    struct window_pane *wp, struct screen_write_ctx *ctx, u_int py)
d825 1
a825 1
window_choose_index_key(struct window_choose_mode_data *data, int key)
d838 1
a838 1
		if (key == *ptr)
@


1.66
log
@Give clock mode its own timer.
@
text
@d1 1
a1 1
/* $OpenBSD: window-choose.c,v 1.65 2015/06/05 18:18:32 nicm Exp $ */
d172 1
a172 1
	keys = options_get_number(&wp->window->options, "mode-keys");
d751 1
a751 1
	struct options			*oo = &wp->window->options;
d762 1
a762 1
	utf8flag = options_get_number(&wp->window->options, "utf8");
@


1.65
log
@Similarly, for sessions use a callback to free rather than checking
every loop.
@
text
@d1 1
a1 1
/* $OpenBSD: window-choose.c,v 1.64 2015/05/08 16:23:34 nicm Exp $ */
a59 1
	NULL,
@


1.64
log
@window_choose_mode_item can move into window-choose.c.
@
text
@d1 1
a1 1
/* $OpenBSD: window-choose.c,v 1.63 2015/05/07 08:08:54 nicm Exp $ */
d212 2
a213 2
	wcd->start_client->references--;
	wcd->start_session->references--;
d216 1
a216 1
		wcd->tree_session->references--;
@


1.63
log
@array.h can be local to window-choose.c now.
@
text
@d1 1
a1 1
/* $OpenBSD: window-choose.c,v 1.62 2015/05/04 13:04:10 nicm Exp $ */
d61 8
@


1.62
log
@Use the right index when expanding/collapsing tree, from Thomas Adam.
@
text
@d1 1
a1 1
/* $OpenBSD: window-choose.c,v 1.61 2015/04/19 21:34:21 nicm Exp $ */
d25 1
@


1.61
log
@Rewrite of tmux mouse support which was a mess. Instead of having
options for "mouse-this" and "mouse-that", mouse events may be bound as
keys and there is one option "mouse" that turns on mouse support
entirely (set -g mouse on).

See the new MOUSE SUPPORT section of the man page for description of the
key names and new flags (-t= to specify the pane or window under mouse
as a target, and send-keys -M to pass through a mouse event).

The default builtin bindings for the mouse are:

    bind -n   MouseDown1Pane select-pane -t=; send-keys -M
    bind -n MouseDown1Status select-window -t=
    bind -n   MouseDrag1Pane copy-mode -M
    bind -n MouseDrag1Border resize-pane -M

To get the effect of turning mode-mouse off, do:

    unbind -n MouseDrag1Pane
    unbind -temacs-copy MouseDrag1Pane

The old mouse options are now gone, set-option -q may be used to
suppress warnings if mixing configuration files.
@
text
@d1 1
a1 1
/* $OpenBSD: window-choose.c,v 1.60 2015/03/31 17:45:10 nicm Exp $ */
d562 1
a562 1
			    item->wcd->idx);
d565 1
a565 1
			    item->wcd->idx);
@


1.60
log
@Fix some format specifier nits, from Ben Boeckel.
@
text
@d1 1
a1 1
/* $OpenBSD: window-choose.c,v 1.59 2015/02/05 10:29:43 nicm Exp $ */
d30 2
a31 3
void	window_choose_key(struct window_pane *, struct session *, int);
void	window_choose_mouse(
	    struct window_pane *, struct session *, struct mouse_event *);
d34 2
d46 1
a46 1
void	window_choose_collapse(struct window_pane *, struct session *);
a58 1
	window_choose_mouse,
a162 2
	if (options_get_number(&wp->window->options, "mode-mouse"))
		s->mode |= MODE_MOUSE_STANDARD;
d238 1
a238 1
	cmdq_run(cdata->start_client->cmdq, cmdlist);
d326 1
a326 1
window_choose_collapse(struct window_pane *wp, struct session *s)
d336 1
a336 1
	chosen = &ARRAY_ITEM(&data->list, data->selected);
d384 1
a384 1
		window_choose_collapse(wp, s);
d484 18
d503 2
a504 1
window_choose_key(struct window_pane *wp, unused struct session *sess, int key)
d553 2
a554 1
		item = &ARRAY_ITEM(&data->list, data->selected);
d558 6
a563 4
		item = &ARRAY_ITEM(&data->list, data->selected);
		if (item->state & TREE_EXPANDED)
			window_choose_collapse(wp, item->wcd->tree_session);
		else {
d565 1
a565 1
			    data->selected);
d570 2
a571 1
		item = &ARRAY_ITEM(&data->list, data->selected);
d573 2
a574 1
			window_choose_collapse(wp, item->wcd->tree_session);
d582 2
a583 1
		item = &ARRAY_ITEM(&data->list, data->selected);
a734 42
}

void
window_choose_mouse(struct window_pane *wp, struct session *sess,
    struct mouse_event *m)
{
	struct window_choose_mode_data	*data = wp->modedata;
	struct screen			*s = &data->screen;
	struct window_choose_mode_item	*item;
	u_int				 idx, i, n;

	if (m->event == MOUSE_EVENT_WHEEL) {
		/*
		 * Multiple line scrolling by default is annoying, so scale
		 * m->scroll back down.
		 */
		n = m->scroll;
		if (n >= MOUSE_WHEEL_SCALE)
			n /= MOUSE_WHEEL_SCALE;
		for (i = 0; i < n; i++) {
			if (m->wheel == MOUSE_WHEEL_UP)
				window_choose_key(wp, sess, KEYC_UP);
			else
				window_choose_key(wp, sess, KEYC_DOWN);
		}
		return;
	}

	if (~m->event & MOUSE_EVENT_CLICK)
		return;
	if (m->x >= screen_size_x(s))
		return;
	if (m->y >= screen_size_y(s))
		return;

	idx = data->top + m->y;
	if (idx >= ARRAY_LENGTH(&data->list))
		return;
	data->selected = idx;

	item = &ARRAY_ITEM(&data->list, data->selected);
	window_choose_fire_callback(wp, item->wcd);
@


1.59
log
@Wrap all the individual format_* calls in a single format_defaults
functions.
@
text
@d1 1
a1 1
/* $OpenBSD: window-choose.c,v 1.58 2015/01/15 13:43:13 nicm Exp $ */
d101 1
a101 1
	data->width = xsnprintf(tmp, sizeof tmp , "%u", item->pos);
@


1.58
log
@Remove an unnecessary variable and shorten a line.
@
text
@d1 1
a1 1
/* $OpenBSD: window-choose.c,v 1.57 2014/11/30 08:03:29 nicm Exp $ */
d922 1
a922 1
	format_session(wcd->ft, s);
d949 1
a949 3
	format_session(wcd->ft, s);
	format_winlink(wcd->ft, s, wl);
	format_window_pane(wcd->ft, wl->window->active);
@


1.57
log
@Remove dead code, from Thomas Adam.
@
text
@d1 1
a1 1
/* $OpenBSD: window-choose.c,v 1.56 2014/10/22 23:18:53 nicm Exp $ */
d333 1
a333 1
	u_int				 i, pos;
d338 1
a338 3
	pos = data->selected;

	chosen = &ARRAY_ITEM(&data->list, pos);
d354 1
a355 2
				ARRAY_ADD(&list_copy,
						ARRAY_ITEM(&data->list, i));
@


1.56
log
@Fix some spacing nits.
@
text
@d1 1
a1 1
/* $OpenBSD: window-choose.c,v 1.55 2014/10/08 17:35:58 nicm Exp $ */
a931 30
}

struct window_choose_data *
window_choose_add_item(struct window_pane *wp, struct client *c,
    struct winlink *wl, const char *template, const char *action, u_int idx)
{
	struct window_choose_data	*wcd;
	char				*expanded;

	wcd = window_choose_data_create(TREE_OTHER, c, c->session);
	wcd->idx = wl->idx;

	wcd->ft_template = xstrdup(template);
	format_add(wcd->ft, "line", "%u", idx);
	format_session(wcd->ft, wcd->start_session);
	format_winlink(wcd->ft, wcd->start_session, wl);
	format_window_pane(wcd->ft, wl->window->active);

	/*
	 * Interpolate action here, since the data we pass back is the expanded
	 * template itself.
	 */
	xasprintf(&expanded, "%s", format_expand(wcd->ft, wcd->ft_template));
	wcd->command = cmd_template_replace(action, expanded, 1);
	free(expanded);

	window_choose_add(wp, wcd);

	return (wcd);

@


1.55
log
@Add xreallocarray and remove nmemb argument from xrealloc.
@
text
@d1 1
a1 1
/* $OpenBSD: window-choose.c,v 1.54 2014/05/08 07:54:47 nicm Exp $ */
d101 1
a101 1
	data->width = xsnprintf (tmp, sizeof tmp , "%u", item->pos);
d790 1
a790 1
			xsnprintf (label, sizeof label, "(%c)", key);
d792 1
a792 1
			xsnprintf (label, sizeof label, "(%d)", item->pos);
@


1.54
log
@Instead of forcing mouse scroll to 1 in choose mode, scale it down
instead. Means modifier keys still increase the line count, just not as
much. Based on a diff from Marcel Partap.
@
text
@d1 1
a1 1
/* $OpenBSD: window-choose.c,v 1.53 2014/04/17 14:13:59 nicm Exp $ */
d320 1
a320 1
	data->input_str = xrealloc(data->input_str, 1, input_len);
@


1.53
log
@Only scroll by one line at a time in choose mode, lists are generally
pretty small.
@
text
@d1 1
a1 1
/* $OpenBSD: window-choose.c,v 1.52 2014/04/03 08:20:29 nicm Exp $ */
d724 1
a724 1
	u_int				 idx;
d728 2
a729 2
		 * Don't use m->scroll and just move line-by-line or it's
		 * annoying.
d731 9
a739 4
		if (m->wheel == MOUSE_WHEEL_UP)
			window_choose_key(wp, sess, KEYC_UP);
		else
			window_choose_key(wp, sess, KEYC_DOWN);
@


1.52
log
@Work out mouse scroll wheel effect when the mouse is first detected and
store it in struct mouse_event, reduce the scroll size the 3 but allow
shift to reduce it to 1 and meta and ctrl to multiply by 3 if the
terminal supports them, also support wheel in choose mode. From Marcel
Partap.
@
text
@d1 1
a1 1
/* $OpenBSD: window-choose.c,v 1.51 2014/03/31 21:36:43 nicm Exp $ */
d718 2
a719 2
window_choose_mouse(
    struct window_pane *wp, unused struct session *sess, struct mouse_event *m)
d724 1
a724 1
	u_int				 i, idx;
d727 8
a734 6
		for (i = 0; i < m->scroll; i++) {
			if (m->wheel == MOUSE_WHEEL_UP)
				window_choose_key(wp, sess, KEYC_UP);
			else
				window_choose_key(wp, sess, KEYC_DOWN);
		}
@


1.51
log
@Add start-of-list, end-of-list, top-line and bottom-line in choice mode,
from madmaverick9 at roxxmail dot eu, similar diff a few days later from
Marcel Partap.
@
text
@d1 1
a1 1
/* $OpenBSD: window-choose.c,v 1.50 2014/01/28 23:07:09 nicm Exp $ */
d724 11
a734 1
	u_int				 idx;
@


1.50
log
@Allow replacing each of the many sets of separate foo-{fg,bg,attr}
options with a single foo-style option. For example:

    set -g status-fg yellow
    set -g status-bg red
    set -g status-attr blink

Becomes:

    set -g status-style fg=yellow,bg=red,blink

The -a flag to set can be used to add to rather than replace a style. So:

    set -g status-bg red

Becomes:

    set -ag status-style bg=red

Currently this is fully backwards compatible (all *-{fg,bg,attr} options
remain) but the plan is to deprecate them over time.

From Tiago Cunha.
@
text
@d1 1
a1 1
/* $OpenBSD: window-choose.c,v 1.49 2014/01/09 13:58:06 nicm Exp $ */
d681 23
@


1.49
log
@Style and comment fixes from Tiago Cunha.
@
text
@d1 1
a1 1
/* $OpenBSD: window-choose.c,v 1.48 2013/10/10 11:58:52 nicm Exp $ */
d739 1
a739 1
		window_mode_attrs(&gc, oo);
d766 1
a766 1
		window_mode_attrs(&gc, oo);
@


1.48
log
@choose-tree: Reset top when toggling items

When choose-tree is told to expand/collapse items (especially when first
rendering collapsed to just show sessions), ensure that in addition to
setting the selected item, that the item itself appears on the bottom of
the screen, rather than off screen.

This was causing rendering glitches when a very small tmux window tried
to render a list of items in choose-tree much larger than itself, and
the selected item appeared off screen, and didn't show the selection
until the selection had wrapped around to the top of the screen.
@
text
@d1 1
a1 1
/* $OpenBSD: window-choose.c,v 1.47 2013/04/22 22:17:29 nicm Exp $ */
d348 1
a348 2
	for (i = 0; i < ARRAY_LENGTH(&data->list); i++)
	{
@


1.47
log
@When using choose-tree -u, start with the current window
highlighted. From Thomas Adam.
@
text
@d1 1
a1 1
/* $OpenBSD: window-choose.c,v 1.46 2013/03/25 10:11:45 nicm Exp $ */
d84 1
d111 11
a121 2
	if (data->selected > screen_size_y(s) - 1)
		data->top = ARRAY_LENGTH(&data->list) - screen_size_y(s);
d290 1
a290 4
	data->top = 0;
	if (data->selected > sy - 1)
		data->top = data->selected - (sy - 1);

d383 1
d402 1
a402 1
	window_choose_redraw_screen(wp);
d410 1
d426 1
a426 1
	window_choose_redraw_screen(wp);
@


1.46
log
@Rename session idx to session id throughout and add $ prefix to targets
to use it, extended from a diff from George Nachman.
@
text
@d1 1
a1 1
/* $OpenBSD: window-choose.c,v 1.45 2013/03/24 09:54:10 nicm Exp $ */
a46 1
void	window_choose_collapse_all(struct window_pane *);
d104 1
a104 2
window_choose_ready(struct window_pane *wp, u_int cur,
    void (*callbackfn)(struct window_choose_data *))
d113 9
d128 1
@


1.45
log
@Add a command queue to standardize and simplify commands that call other
commands and allow a command to block execution of subsequent
commands. This allows run-shell and if-shell to be synchronous which has
been much requested.

Each client has a default command queue and commands are consumed one at
a time from it. A command may suspend execution from the queue by
returning CMD_RETURN_WAIT and then resume it by calling cmd_continue() -
for example run-shell does this from the callback that is fired after
the job is freed.

When the command queue becomes empty, command clients are automatically
exited (unless attaching). A callback is also fired - this is used for
nested commands in, for example, if-shell which can block execution of
the client's cmdq until a new cmdq becomes empty.

Also merge all the old error/info/print functions together and lose the
old curclient/cmdclient distinction - a cmdq is bound to one client (or
none if in the configuration file), this is a command client if
c->session is NULL otherwise an attached client.
@
text
@d1 1
a1 1
/* $OpenBSD: window-choose.c,v 1.44 2013/03/22 15:54:29 nicm Exp $ */
d862 1
a862 1
	wcd->idx = s->idx;
@


1.44
log
@Need to set clients in context before changing their reference count.
@
text
@d1 1
a1 1
/* $OpenBSD: window-choose.c,v 1.43 2013/03/22 15:52:42 nicm Exp $ */
d203 2
a204 3
	struct cmd_ctx		*ctx;
	struct cmd_list		*cmdlist;
	char			*cause;
d213 1
a213 1
	if (cmd_string_parse(cdata->command, &cmdlist, &cause) != 0) {
d222 1
a222 6
	ctx = cmd_get_ctx(NULL, cdata->start_client);
	ctx->error = key_bindings_error;
	ctx->print = key_bindings_print;
	ctx->info = key_bindings_info;

	cmd_list_exec(cmdlist, ctx);
a223 1
	cmd_free_ctx(ctx);
@


1.43
log
@Add copy-pipe mode command to copy selection and also pipe to a command.
@
text
@d1 1
a1 1
/* $OpenBSD: window-choose.c,v 1.42 2013/03/22 15:50:42 nicm Exp $ */
d223 1
a223 2
	ctx = cmd_get_ctx();
	ctx->curclient = cdata->start_client;
@


1.42
log
@Remove unnecessary initializers of cmd_ctx.
@
text
@d1 1
a1 1
/* $OpenBSD: window-choose.c,v 1.41 2013/03/22 15:49:55 nicm Exp $ */
d495 1
a495 1
		switch (mode_key_lookup(&data->mdata, key)) {
d526 1
a526 1
	switch (mode_key_lookup(&data->mdata, key)) {
d780 1
a780 1
		mkey = mode_key_lookup(&data->mdata, *ptr);
d800 1
a800 1
		mkey = mode_key_lookup(&data->mdata, *ptr);
@


1.41
log
@Add functions to allocate and free command contexts rather than doing it
all on the stack.
@
text
@d1 1
a1 1
/* $OpenBSD: window-choose.c,v 1.40 2013/03/22 10:38:33 nicm Exp $ */
a223 1
	ctx->msgdata = NULL;
a224 2
	ctx->cmdclient = NULL;

@


1.40
log
@Don't hang when clearing line in choose mode now that the cursor stays
at the end with wrap.
@
text
@d1 1
a1 1
/* $OpenBSD: window-choose.c,v 1.39 2013/03/22 10:31:22 nicm Exp $ */
d203 1
a203 1
	struct cmd_ctx		 ctx;
d223 8
a230 2
	ctx.msgdata = NULL;
	ctx.curclient = cdata->start_client;
d232 1
a232 7
	ctx.error = key_bindings_error;
	ctx.print = key_bindings_print;
	ctx.info = key_bindings_info;

	ctx.cmdclient = NULL;

	cmd_list_exec(cmdlist, &ctx);
d234 1
@


1.39
log
@No more lint means no more ARGSUSED.
@
text
@d1 1
a1 1
/* $OpenBSD: window-choose.c,v 1.38 2013/03/21 16:22:48 nicm Exp $ */
d756 1
a756 1
	while (s->cx < screen_size_x(s))
@


1.38
log
@Do not crash when calling choose-tree with a command that changes the mode.
@
text
@d1 1
a1 1
/* $OpenBSD: window-choose.c,v 1.37 2013/03/21 16:20:26 nicm Exp $ */
a482 1
/* ARGSUSED */
a687 1
/* ARGSUSED */
@


1.37
log
@No more need for freefn.
@
text
@d1 1
a1 1
/* $OpenBSD: window-choose.c,v 1.36 2013/03/21 16:19:25 nicm Exp $ */
d80 1
d250 7
a256 1
	struct window_choose_mode_data	*data = wp->modedata;
d260 3
a294 1
	const struct window_mode	*oldmode;
d296 2
a297 2
	oldmode = wp->mode;
	wp->mode = NULL;
d301 1
a301 1
	wp->mode = oldmode;
a511 1
			window_pane_reset_mode(wp);
a531 1
		window_pane_reset_mode(wp);
a535 1
		window_pane_reset_mode(wp);
a684 1
		window_pane_reset_mode(wp);
a712 1
	window_pane_reset_mode(wp);
@


1.36
log
@Fix constness of cmd_template_replace, window_choose_add_item and
window_choose_add_window.
@
text
@d1 1
a1 1
/* $OpenBSD: window-choose.c,v 1.35 2013/03/21 16:09:59 nicm Exp $ */
a77 1
	void			(*freefn)(struct window_choose_data *);
a132 1
	data->freefn = NULL;
@


1.35
log
@Allow choose commands to be used outside tmux, so long as at least one
client is attached.
@
text
@d1 1
a1 1
/* $OpenBSD: window-choose.c,v 1.34 2013/03/21 16:09:17 nicm Exp $ */
d867 1
a867 1
    struct session *s, const char *template, char *action, u_int idx)
d890 1
a890 1
    struct winlink *wl, const char *template, char *action, u_int idx)
d921 1
a921 1
    char *action, u_int idx)
@


1.34
log
@Remove free callback for window_choose_data objects.
@
text
@d1 1
a1 1
/* $OpenBSD: window-choose.c,v 1.33 2013/03/21 16:08:25 nicm Exp $ */
d866 1
a866 1
window_choose_add_session(struct window_pane *wp, struct cmd_ctx *ctx,
a869 1
	struct client			*c = ctx->curclient;
d889 1
a889 1
window_choose_add_item(struct window_pane *wp, struct cmd_ctx *ctx,
a892 1
	struct client			*c = ctx->curclient;
d919 1
a919 1
window_choose_add_window(struct window_pane *wp, struct cmd_ctx *ctx,
a923 1
	struct client			*c = ctx->curclient;
@


1.33
log
@Miscellaneous tidying of choose API, including:

- rename client and session to start_client and start_session in
  window_choose_data struct. also add TREE_OTHER define and reorder
  the struct
- rename window_choose_ctx to window_choose_data_run
- don't pass a cmd_ctx into window_choose_create (will let it use a
  different client later). instead take type, session, client
- add window_choose_data_free and use it to dispose of wcd rather than
  each cmd-*.c doing it individually
- change so ref counting is done by wcd_add and wcd_free rather than
  callers
- also add a ref to tree_session
- all the callbacks except choose-client and find-window are the same so
  remove them and add window_choose_default_callback
- reorder/rename some other bits and pieces for tidyness
@
text
@d1 1
a1 1
/* $OpenBSD: window-choose.c,v 1.32 2013/02/05 11:08:59 nicm Exp $ */
d106 1
a106 2
    void (*callbackfn)(struct window_choose_data *),
    void (*freefn)(struct window_choose_data *))
a117 1
	data->freefn = freefn;
a256 2
		if (data->freefn != NULL && item->wcd != NULL)
			data->freefn(item->wcd);
@


1.32
log
@Automatically reflow wrapped lines when a pane is resized, requested by
many over the years and finally implemented by Richard Woodbury.
@
text
@d1 1
a1 1
/* $OpenBSD: window-choose.c,v 1.31 2012/12/24 12:34:32 nicm Exp $ */
d34 2
d117 2
d161 1
a161 1
window_choose_data_create(struct cmd_ctx *ctx)
d166 2
d170 1
d172 1
d174 3
d178 5
a182 4
	wcd->client = ctx->curclient;
	wcd->session = ctx->curclient->session;
	wcd->idx = -1;
	wcd->type = 0;
d188 63
d261 1
d288 1
a288 1
	struct window_pane *wp, struct window_choose_data *wcd)
d378 1
a378 1
	chosen = ARRAY_ITEM(&data->list, data->selected).wcd->session;
a868 35
void
window_choose_ctx(struct window_choose_data *cdata)
{
	struct cmd_ctx		 ctx;
	struct cmd_list		*cmdlist;
	char			*cause;

	/* The command template will have already been replaced.  But if it's
	 * NULL, bail here.
	 */
	if (cdata->command == NULL)
		return;

	if (cmd_string_parse(cdata->command, &cmdlist, &cause) != 0) {
		if (cause != NULL) {
			*cause = toupper((u_char) *cause);
			status_message_set(cdata->client, "%s", cause);
			free(cause);
		}
		return;
	}

	ctx.msgdata = NULL;
	ctx.curclient = cdata->client;

	ctx.error = key_bindings_error;
	ctx.print = key_bindings_print;
	ctx.info = key_bindings_info;

	ctx.cmdclient = NULL;

	cmd_list_exec(cmdlist, &ctx);
	cmd_list_free(cmdlist);
}

d874 1
d876 1
a876 1
	wcd = window_choose_data_create(ctx);
d878 1
d880 2
a881 2
	wcd->type = TREE_SESSION;
	wcd->command = cmd_template_replace(action, s->name, 1);
d886 1
a886 2
	wcd->client->references++;
	wcd->session->references++;
d898 2
a899 1
	char				*action_data;
d901 1
a901 1
	wcd = window_choose_data_create(ctx);
d903 1
d906 2
a907 2
	format_session(wcd->ft, wcd->session);
	format_winlink(wcd->ft, wcd->session, wl);
d910 7
a916 2
	wcd->client->references++;
	wcd->session->references++;
a919 8
	/*
	 * Interpolate action_data here, since the data we pass back is the
	 * expanded template itself.
	 */
	xasprintf(&action_data, "%s", format_expand(wcd->ft, wcd->ft_template));
	wcd->command = cmd_template_replace(action, action_data, 1);
	free(action_data);

d930 2
a931 1
	char				*action_data;
d933 2
a934 1
	wcd = window_choose_data_create(ctx);
d936 1
a936 3
	xasprintf(&action_data, "%s:%d", s->name, wl->idx);
	wcd->command = cmd_template_replace(action, action_data, 1);
	free(action_data);
a937 2
	wcd->idx = wl->idx;
	wcd->wl = wl;
d939 2
a940 1
	wcd->type = TREE_WINDOW;
d947 3
a949 2
	wcd->client->references++;
	wcd->session->references++;
@


1.31
log
@Add -T option to select-window to toggle to last window if already
current, from Raghavendra D Prabhu.
@
text
@d1 1
a1 1
/* $OpenBSD: window-choose.c,v 1.30 2012/12/24 12:24:21 nicm Exp $ */
d206 1
a206 1
	screen_resize(s, sx, sy);
@


1.30
log
@Remove an unnecessary redraw, from Raghavendra D Prabhu.
@
text
@d1 1
a1 1
/* $OpenBSD: window-choose.c,v 1.29 2012/10/26 14:35:42 nicm Exp $ */
a45 1
void	window_choose_expand_all(struct window_pane *);
@


1.29
log
@Make mouse event structure clearer by defining events (up, click, drag)
and simplifying how buttons and wheels are represented, from Ailin
Nemui. Should be no functional changes.
@
text
@d1 1
a1 1
/* $OpenBSD: window-choose.c,v 1.28 2012/10/11 08:53:50 nicm Exp $ */
a120 1
	window_choose_redraw_screen(wp);
@


1.28
log
@Fix a use-after-free when collapsing the tree in choose mode, from
Carl Henrik Lunde.
@
text
@d1 1
a1 1
/* $OpenBSD: window-choose.c,v 1.27 2012/10/02 08:16:28 nicm Exp $ */
d626 1
a626 1
	if ((m->b & 3) == 3)
@


1.27
log
@Allow session tree (C-b s) to expand and collapse sessions with
left/right/space keys. From Thomas Adam.
@
text
@d1 1
a1 1
/* $OpenBSD: window-choose.c,v 1.26 2012/09/03 09:57:57 nicm Exp $ */
d184 2
a185 2
	for (i = 0; i < ARRAY_LENGTH(&data->list); i++) {
		item = &ARRAY_ITEM(&data->list, i);
d292 1
d300 2
a301 2
	struct window_choose_mode_item	*item, *chosen;
	struct session			*s;
d304 1
a304 1
	chosen = &ARRAY_ITEM(&data->list, data->selected);
d313 1
a313 1
		if (chosen->wcd->session != item->wcd->tree_session)
@


1.26
log
@add cmd-choose-list to allow arbitrary options to be selected. From
Thomas Adam.
@
text
@d1 1
a1 1
/* $OpenBSD: window-choose.c,v 1.25 2012/08/27 21:29:23 nicm Exp $ */
d43 5
d68 1
d98 1
d118 3
d140 1
d168 1
d172 1
d191 1
d245 160
d414 1
a414 1
	u_int		       		 items, n;
d462 31
d677 7
a683 1
		    "%*s %s", data->width + 2, label, item->name);
d837 2
d900 2
@


1.25
log
@Instead of requiring a prompt to enter all numbers >10, go back to
0-9a-z and add A-Z and enter the prompt when M-0 to M-9 are pressed
(like in copy mode). Prompted by request from mcbride@@, help from Thomas
Adam.
@
text
@d1 1
a1 1
/* $OpenBSD: window-choose.c,v 1.24 2012/08/14 09:17:14 nicm Exp $ */
d637 32
@


1.24
log
@Boldify windows with alerts in choose-* list.
@
text
@d1 1
a1 1
/* $OpenBSD: window-choose.c,v 1.23 2012/08/12 06:22:26 nicm Exp $ */
d74 2
a75 1
int	window_choose_index_key(int);
d93 1
a93 1
	data->width = snprintf (tmp, sizeof tmp , "%u", item->pos);
d245 5
a249 11
	switch (mode_key_lookup(&data->mdata, key)) {
	case MODEKEYCHOICE_CANCEL:
		window_choose_fire_callback(wp, NULL);
		window_pane_reset_mode(wp);
		break;
	case MODEKEYCHOICE_CHOOSE:
		switch (data->input_type) {
		case WINDOW_CHOOSE_NORMAL:
			item = &ARRAY_ITEM(&data->list, data->selected);
			window_choose_fire_callback(wp, item->wcd);
			window_pane_reset_mode(wp);
d251 1
a251 1
		case WINDOW_CHOOSE_GOTO_ITEM:
d253 3
a255 1
			if (n > items - 1)
d257 1
d262 12
d275 12
d391 2
a392 1
		if (key < '0' && key > '9')
d394 2
a395 19

		/*
		 * If there's less than ten items (0-9) then pressing a number
		 * will automatically select that item; otherwise, prompt for
		 * the item to go to.
		 */
		if (ARRAY_LENGTH(&data->list) - 1 <= 9) {
			idx = window_choose_index_key(key);
			if (idx < 0 || (u_int) idx >= ARRAY_LENGTH(&data->list))
				break;
			data->selected = idx;

			item = &ARRAY_ITEM(&data->list, data->selected);
			window_choose_fire_callback(wp, item->wcd);
			window_pane_reset_mode(wp);
		} else {
			window_choose_prompt_input(
			    WINDOW_CHOOSE_GOTO_ITEM, "Goto item", wp, key);
		}
d398 8
d447 2
a448 2
	char				 hdr[32];
	int				 utf8flag;
a464 3
		screen_write_nputs(ctx, screen_size_x(s) - 1,
		    &gc, utf8flag, "(%*d) %s", data->width,
		    item->pos, item->name);
d466 7
d491 20
a510 1
window_choose_index_key(int key)
d512 3
a514 1
	static const char	keys[] = "0123456789";
d516 1
d520 3
@


1.23
log
@Simplify width calculation (all numbers always sequential) and don't
rely on uninitialized data, from Thomas Adam.
@
text
@d1 1
a1 1
/* $OpenBSD: window-choose.c,v 1.22 2012/08/11 06:45:33 nicm Exp $ */
d155 1
d448 3
d611 1
@


1.22
log
@Instead of numbering choose mode items 0-9a-z and then nothing, number
them all and if there are more than 10 use a prompt when 0-9 is
pressed. From Thomas Adam.
@
text
@d1 1
a1 1
/* $OpenBSD: window-choose.c,v 1.21 2012/07/10 11:53:01 nicm Exp $ */
a82 1
	int				 width;
d92 1
a92 3
	width = snprintf (tmp, sizeof tmp, "%u", item->pos);
	if (width > data->width)
		data->width = width;
@


1.21
log
@xfree is not particularly helpful, remove it. From Thomas Adam.
@
text
@d1 1
a1 1
/* $OpenBSD: window-choose.c,v 1.20 2012/06/25 14:27:25 nicm Exp $ */
d43 5
d63 1
d66 3
d74 3
a76 2
int	window_choose_key_index(struct window_choose_mode_data *, u_int);
int	window_choose_index_key(struct window_choose_mode_data *, int);
d83 2
d91 5
d127 3
d179 1
d214 18
d240 2
a241 1
	u_int		       		 items;
d252 15
a266 3
		item = &ARRAY_ITEM(&data->list, data->selected);
		window_choose_fire_callback(wp, item->wcd);
		window_pane_reset_mode(wp);
d364 8
a371 3
	default:
		idx = window_choose_index_key(data, key);
		if (idx < 0 || (u_int) idx >= ARRAY_LENGTH(&data->list))
a372 1
		data->selected = idx;
d374 20
a393 3
		item = &ARRAY_ITEM(&data->list, data->selected);
		window_choose_fire_callback(wp, item->wcd);
		window_pane_reset_mode(wp);
d434 3
a436 1
	int				 utf8flag, key;
d441 1
d444 2
a445 5
	if (data->selected == data->top + py) {
		colour_set_fg(&gc, options_get_number(oo, "mode-fg"));
		colour_set_bg(&gc, options_get_number(oo, "mode-bg"));
		gc.attr |= options_get_number(oo, "mode-attr");
	}
d450 3
a452 8
		key = window_choose_key_index(data, data->top + py);
		if (key != -1) {
			screen_write_nputs(ctx, screen_size_x(s) - 1,
			    &gc, utf8flag, "(%c) %s", key, item->name);
		} else {
			screen_write_nputs(ctx, screen_size_x(s) - 1,
			    &gc, utf8flag, "    %s", item->name);
		}
a456 1
}
d458 2
a459 6
int
window_choose_key_index(struct window_choose_mode_data *data, u_int idx)
{
	static const char	keys[] = "0123456789abcdefghijklmnopqrstuvwxyz";
	const char	       *ptr;
	int			mkey;
d461 6
a466 6
	for (ptr = keys; *ptr != '\0'; ptr++) {
		mkey = mode_key_lookup(&data->mdata, *ptr);
		if (mkey != MODEKEY_NONE && mkey != MODEKEY_OTHER)
			continue;
		if (idx-- == 0)
			return (*ptr);
d468 1
a468 1
	return (-1);
d472 1
a472 1
window_choose_index_key(struct window_choose_mode_data *data, int key)
d474 1
a474 1
	static const char	keys[] = "0123456789abcdefghijklmnopqrstuvwxyz";
a475 1
	int			mkey;
a478 3
		mkey = mode_key_lookup(&data->mdata, *ptr);
		if (mkey != MODEKEY_NONE && mkey != MODEKEY_OTHER)
			continue;
d576 1
a576 1
	struct session *s, const char *template, char *action, u_int idx)
d597 2
a598 2
	struct session *s, struct winlink *wl, const char *template,
	char *action, u_int idx)
@


1.20
log
@Provide common helper function for adding windows and sessions to choose
lists and expand %% in command before using it rather than at callback
time. From Thomas Adam.
@
text
@d1 1
a1 1
/* $OpenBSD: window-choose.c,v 1.19 2012/06/25 14:08:55 nicm Exp $ */
d22 1
d156 1
a156 1
		xfree(item->name);
d161 1
a161 1
	xfree(data);
d497 1
a497 1
			xfree(cause);
d548 1
a548 1
	xfree(action_data);
@


1.19
log
@Clean up and simplify the choose mode code, from Thomas Adam.
@
text
@d1 1
a1 1
/* $OpenBSD: window-choose.c,v 1.18 2012/04/23 22:40:47 nicm Exp $ */
d136 1
a136 2
	wcd->action = NULL;
	wcd->raw_format = NULL;
d484 1
a484 1
	char			*template, *cause;
d486 5
a490 2
	template = cmd_template_replace(cdata->action,
			cdata->raw_format, 1);
d492 1
a492 1
	if (cmd_string_parse(template, &cmdlist, &cause) != 0) {
a497 1
		xfree(template);
a499 1
	xfree(template);
d512 50
@


1.18
log
@Use a helper function to fire choose callback.
@
text
@d1 1
a1 1
/* $OpenBSD: window-choose.c,v 1.17 2010/12/29 21:49:06 nicm Exp $ */
d21 1
d33 2
a34 1
void	window_choose_fire_callback(struct window_pane *, int);
a50 5
struct window_choose_mode_item {
	char		       *name;
	int			idx;
};

d60 2
a61 3
	void 			(*callbackfn)(void *, int);
	void			(*freefn)(void *);
	void		       *data;
d68 1
a68 1
window_choose_vadd(struct window_pane *wp, int idx, const char *fmt, va_list ap)
a74 3
	xvasprintf(&item->name, fmt, ap);
	item->idx = idx;
}
d76 2
a77 8
void printflike3
window_choose_add(struct window_pane *wp, int idx, const char *fmt, ...)
{
	va_list	ap;

	va_start(ap, fmt);
	window_choose_vadd(wp, idx, fmt, ap);
	va_end(ap);
d82 2
a83 1
    void (*callbackfn)(void *, int), void (*freefn)(void *), void *cdata)
a93 1
	data->data = cdata;
a108 1
	data->data = NULL;
d128 17
d149 1
d152 6
a157 5
	if (data->freefn != NULL && data->data != NULL)
		data->freefn(data->data);

	for (i = 0; i < ARRAY_LENGTH(&data->list); i++)
		xfree(ARRAY_ITEM(&data->list, i).name);
d179 2
a180 1
window_choose_fire_callback(struct window_pane *wp, int idx)
d188 1
a188 1
	data->callbackfn(data->data, idx);
d208 1
a208 1
		window_choose_fire_callback(wp, -1);
d213 1
a213 1
		window_choose_fire_callback(wp, item->idx);
d319 1
a319 1
		window_choose_fire_callback(wp, item->idx);
d348 1
a348 1
	window_choose_fire_callback(wp, item->idx);
d478 34
@


1.17
log
@Support all four of the xterm mouse modes. Based on a diff from hsim at
gmx.li.
@
text
@d1 1
a1 1
/* $OpenBSD: window-choose.c,v 1.16 2010/05/23 19:42:19 nicm Exp $ */
d32 1
d173 14
d202 1
a202 1
		data->callbackfn(data->data, -1);
d207 1
a207 1
		data->callbackfn(data->data, item->idx);
d313 1
a313 1
		data->callbackfn(data->data, item->idx);
d342 1
a342 1
	data->callbackfn(data->data, item->idx);
@


1.16
log
@Pass in the session, rather than the client, to window modes' key()
function. We were only ever using the client to find the session anyway.

This allows send-key to work properly for manipulating copy mode from
outside tmux.

From Micah Cowan.
@
text
@d1 1
a1 1
/* $OpenBSD: window-choose.c,v 1.15 2010/02/01 22:15:51 nicm Exp $ */
d130 1
a130 1
		s->mode |= MODE_MOUSE;
@


1.15
log
@Add scroll-up/scroll-down for choose/more mode, from Micah Cowan.
@
text
@d1 1
a1 1
/* $OpenBSD: window-choose.c,v 1.14 2010/01/11 23:46:22 nicm Exp $ */
d28 1
a28 1
void	window_choose_key(struct window_pane *, struct client *, int);
d30 1
a30 1
	    struct window_pane *, struct client *, struct mouse_event *);
d174 1
a174 1
window_choose_key(struct window_pane *wp, unused struct client *c, int key)
d307 1
a307 1
    struct window_pane *wp, unused struct client *c, struct mouse_event *m)
@


1.14
log
@key should be an int not a char.
@
text
@d1 1
a1 1
/* $OpenBSD: window-choose.c,v 1.13 2009/12/03 22:50:10 nicm Exp $ */
d228 1
a228 3
		if (data->selected >= data->top + screen_size_y(&data->screen))
			window_choose_scroll_down(wp);
		else {
d235 28
a262 1
		}
@


1.13
log
@Massive spaces->tabs and trailing whitespace cleanup, hopefully for the last
time now I've configured emacs to make them displayed in really annoying
colours...
@
text
@d1 1
a1 1
/* $OpenBSD: window-choose.c,v 1.12 2009/11/26 21:37:13 nicm Exp $ */
d315 1
a315 2
	int				 utf8flag;
	char				 key;
@


1.12
log
@Remove a couple of unused arguments where possible, and add /* ARGSUSED */ to
the rest to reduce lint output.
@
text
@d1 1
a1 1
/* $OpenBSD: window-choose.c,v 1.11 2009/11/17 13:06:11 nicm Exp $ */
d30 1
a30 1
    	    struct window_pane *, struct client *, struct mouse_event *);
d34 1
a34 1
    	    struct window_pane *, struct screen_write_ctx *, u_int);
d250 1
a250 1
 		window_choose_redraw_screen(wp);
d271 1
a271 1
		
d315 1
a315 1
 	int				 utf8flag;
@


1.11
log
@In choose mode, assign each item a number or lowercase letter from those
available and accept that as a shortcut key for the item.
@
text
@d1 1
a1 1
/* $OpenBSD: window-choose.c,v 1.10 2009/10/11 07:01:10 nicm Exp $ */
d172 1
d279 1
@


1.10
log
@Clean up by introducing a wrapper struct for mouse clicks rather than passing
three u_chars around.

As a side-effect this fixes incorrectly rejecting high cursor positions
(because it was comparing them as signed char), reported by Tom Doherty.
@
text
@d1 1
a1 1
/* $OpenBSD: window-choose.c,v 1.9 2009/09/10 17:16:24 nicm Exp $ */
d67 3
d179 2
a180 1
	u_int				 items;
d266 8
d314 1
d330 9
a338 2
		screen_write_nputs(
		    ctx, screen_size_x(s) - 1, &gc, utf8flag, "%s", item->name);
d342 36
@


1.9
log
@Permit options such as status-bg to be configured using the entire 256 colour
palette by setting "colour0" to "colour255".
@
text
@d1 1
a1 1
/* $OpenBSD: window-choose.c,v 1.8 2009/08/05 16:26:38 nicm Exp $ */
d30 1
a30 1
    	    struct window_pane *, struct client *, u_char, u_char, u_char);
d267 2
a268 2
window_choose_mouse(struct window_pane *wp,
    unused struct client *c, u_char b, u_char x, u_char y)
d275 1
a275 1
	if ((b & 3) == 3)
d277 1
a277 1
	if (x >= screen_size_x(s))
d279 1
a279 1
	if (y >= screen_size_y(s))
d282 1
a282 1
	idx = data->top + y;
@


1.8
log
@If colours are not supported by the terminal, try to emulate a coloured
background by setting or clearing the reverse attribute.

This makes a few applications which don't use the reverse attribute themselves
a little happier, and allows the status, message and mode options to have
default attributes and fg/bg options that work as expected when set as reverse.
@
text
@d1 1
a1 1
/* $OpenBSD: window-choose.c,v 1.7 2009/07/30 07:04:50 nicm Exp $ */
d298 1
d309 3
a311 3
		gc.fg = options_get_number(&wp->window->options, "mode-fg");
		gc.bg = options_get_number(&wp->window->options, "mode-bg");
		gc.attr |= options_get_number(&wp->window->options, "mode-attr");
@


1.7
log
@Add a mode-mouse option to prevent tmux taking over the mouse in choice or copy
modes.
@
text
@d1 1
a1 1
/* $OpenBSD: window-choose.c,v 1.6 2009/07/28 07:03:32 nicm Exp $ */
d308 2
a309 2
		gc.fg = options_get_number(&wp->window->options, "mode-bg");
		gc.bg = options_get_number(&wp->window->options, "mode-fg");
@


1.6
log
@Next step towards customisable mode keys: build each default table of keys into
a named tree on start and use that for lookups. Also add command to string
translation tables and modify list-keys to show the the mode key bindings (new
-t argument).
@
text
@d1 1
a1 1
/* $OpenBSD: window-choose.c,v 1.5 2009/07/27 19:29:35 nicm Exp $ */
d126 2
a127 1
	s->mode |= MODE_MOUSE;
@


1.5
log
@Change mode key bindings from big switches into a set of tables. Rather than
lumping them all together, split editing keys from those used in choice/more
mode and those for copy/scroll mode.

Tidier and clearer, and the first step towards customisable mode keys.
@
text
@d1 1
a1 1
/* $OpenBSD: window-choose.c,v 1.4 2009/07/27 18:51:46 nicm Exp $ */
d130 1
a130 1
		mode_key_init(&data->mdata, mode_key_emacs_choice);
d132 1
a132 1
		mode_key_init(&data->mdata, mode_key_vi_choice);
@


1.4
log
@Get rid of empty mode_key_free function.
@
text
@d1 1
a1 1
/* $OpenBSD: window-choose.c,v 1.3 2009/07/17 07:05:58 nicm Exp $ */
d112 1
d128 5
a132 3
	mode_key_init(&data->mdata,
	    options_get_number(&wp->window->options, "mode-keys"),
	    MODEKEY_CHOOSEMODE);
d180 1
a180 1
	case MODEKEYCMD_QUIT:
d184 1
a184 1
	case MODEKEYCMD_CHOOSE:
d189 1
a189 1
	case MODEKEYCMD_UP:
d211 1
a211 1
	case MODEKEYCMD_DOWN:
d221 1
d233 1
a233 1
	case MODEKEYCMD_PREVIOUSPAGE:
d246 1
a246 1
	case MODEKEYCMD_NEXTPAGE:
@


1.3
log
@A similar for fix for window_choose: don't rely on the callback always being
called to free data, have a separate free callback and call it from the mode
cleanup code.
@
text
@d1 1
a1 1
/* $OpenBSD: window-choose.c,v 1.2 2009/06/24 23:00:31 nicm Exp $ */
a141 2

 	mode_key_free(&data->mdata);
@


1.2
log
@Now that a UTF-8-capable puts function exists, use it for printing strings in
choice/more modes - lines with UTF-8 now display properly in find-window
results.
@
text
@d1 1
a1 1
/* $OpenBSD: window-choose.c,v 1.1 2009/06/01 22:58:49 nicm Exp $ */
d62 2
a63 1
	void 			(*callback)(void *, int);
d90 2
a91 2
window_choose_ready(struct window_pane *wp,
    u_int cur, void (*callback)(void *, int), void *cdata)
d100 2
a101 1
	data->callback = callback;
d114 5
a118 1
	data->callback = NULL;
d140 3
d180 1
a180 1
		data->callback(data->data, -1);
d185 1
a185 1
		data->callback(data->data, item->idx);
d285 1
a285 1
	data->callback(data->data, item->idx);
d299 1
a299 1
	if (data->callback == NULL)
@


1.1
log
@Import tmux, a terminal multiplexor allowing (among other things) a single
terminal to be switched between several different windows and programs
displayed on one terminal be detached from one terminal and moved to another.

ok deraadt pirofti
@
text
@d1 1
a1 1
/* $OpenBSD$ */
d288 1
d293 1
d304 2
a305 2
		screen_write_puts(
		    ctx, &gc, "%.*s", (int) screen_size_x(s), item->name);
a308 1

@

