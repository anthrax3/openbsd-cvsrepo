head	1.45;
access;
symbols
	OPENBSD_6_1:1.45.0.4
	OPENBSD_6_1_BASE:1.45
	OPENBSD_6_0:1.42.0.4
	OPENBSD_6_0_BASE:1.42
	OPENBSD_5_9:1.42.0.2
	OPENBSD_5_9_BASE:1.42
	OPENBSD_5_8:1.40.0.6
	OPENBSD_5_8_BASE:1.40
	OPENBSD_5_7:1.40.0.2
	OPENBSD_5_7_BASE:1.40
	OPENBSD_5_6:1.30.0.6
	OPENBSD_5_6_BASE:1.30
	OPENBSD_5_5:1.30.0.4
	OPENBSD_5_5_BASE:1.30
	OPENBSD_5_4:1.29.0.2
	OPENBSD_5_4_BASE:1.29
	OPENBSD_5_3:1.28.0.24
	OPENBSD_5_3_BASE:1.28
	OPENBSD_5_2:1.28.0.22
	OPENBSD_5_2_BASE:1.28
	OPENBSD_5_1_BASE:1.28
	OPENBSD_5_1:1.28.0.20
	OPENBSD_5_0:1.28.0.18
	OPENBSD_5_0_BASE:1.28
	OPENBSD_4_9:1.28.0.16
	OPENBSD_4_9_BASE:1.28
	OPENBSD_4_8:1.28.0.14
	OPENBSD_4_8_BASE:1.28
	OPENBSD_4_7:1.28.0.10
	OPENBSD_4_7_BASE:1.28
	OPENBSD_4_6:1.28.0.12
	OPENBSD_4_6_BASE:1.28
	OPENBSD_4_5:1.28.0.8
	OPENBSD_4_5_BASE:1.28
	OPENBSD_4_4:1.28.0.6
	OPENBSD_4_4_BASE:1.28
	OPENBSD_4_3:1.28.0.4
	OPENBSD_4_3_BASE:1.28
	OPENBSD_4_2:1.28.0.2
	OPENBSD_4_2_BASE:1.28
	OPENBSD_4_1:1.25.0.2
	OPENBSD_4_1_BASE:1.25
	OPENBSD_4_0:1.23.0.2
	OPENBSD_4_0_BASE:1.23
	OPENBSD_3_9:1.21.0.8
	OPENBSD_3_9_BASE:1.21
	OPENBSD_3_8:1.21.0.6
	OPENBSD_3_8_BASE:1.21
	OPENBSD_3_7:1.21.0.4
	OPENBSD_3_7_BASE:1.21
	OPENBSD_3_6:1.21.0.2
	OPENBSD_3_6_BASE:1.21
	OPENBSD_3_5:1.20.0.2
	OPENBSD_3_5_BASE:1.20
	OPENBSD_3_4:1.19.0.2
	OPENBSD_3_4_BASE:1.19
	OPENBSD_3_3:1.16.0.6
	OPENBSD_3_3_BASE:1.16
	OPENBSD_3_2:1.16.0.4
	OPENBSD_3_2_BASE:1.16
	OPENBSD_3_1:1.16.0.2
	OPENBSD_3_1_BASE:1.16
	OPENBSD_3_0:1.15.0.2
	OPENBSD_3_0_BASE:1.15
	OPENBSD_2_9_BASE:1.13
	OPENBSD_2_9:1.13.0.2
	OPENBSD_2_8:1.11.0.6
	OPENBSD_2_8_BASE:1.11
	OPENBSD_2_7:1.11.0.4
	OPENBSD_2_7_BASE:1.11
	OPENBSD_2_6:1.11.0.2
	OPENBSD_2_6_BASE:1.11
	OPENBSD_2_5:1.7.0.8
	OPENBSD_2_5_BASE:1.7
	OPENBSD_2_4:1.7.0.6
	OPENBSD_2_4_BASE:1.7
	OPENBSD_2_3:1.7.0.4
	OPENBSD_2_3_BASE:1.7
	OPENBSD_2_2:1.7.0.2
	OPENBSD_2_2_BASE:1.7
	OPENBSD_2_1:1.5.0.2
	OPENBSD_2_1_BASE:1.5
	OPENBSD_2_0:1.3.0.2
	OPENBSD_2_0_BASE:1.3;
locks; strict;
comment	@ * @;


1.45
date	2016.09.04.15.36.13;	author tb;	state Exp;
branches;
next	1.44;
commitid	jhtDEBDLL74d54eY;

1.44
date	2016.09.02.18.06.43;	author tedu;	state Exp;
branches;
next	1.43;
commitid	r8vIJFz95usZVwYa;

1.43
date	2016.09.02.17.06.59;	author tedu;	state Exp;
branches;
next	1.42;
commitid	7taVFoQ2FF3xBxvV;

1.42
date	2015.10.10.18.14.20;	author doug;	state Exp;
branches;
next	1.41;
commitid	BoswISZOUEEGRkO3;

1.41
date	2015.10.10.17.59.15;	author deraadt;	state Exp;
branches;
next	1.40;
commitid	E3U7LqCXFuD3p6Sz;

1.40
date	2015.02.26.17.46.15;	author tedu;	state Exp;
branches;
next	1.39;
commitid	o6BTnMJsbDAzFugK;

1.39
date	2015.02.24.18.45.51;	author tedu;	state Exp;
branches;
next	1.38;
commitid	IfWMrXYrQs9iNgq2;

1.38
date	2015.01.15.17.34.15;	author chl;	state Exp;
branches;
next	1.37;
commitid	pfUM0oE99kKAAT3M;

1.37
date	2015.01.05.14.07.12;	author tedu;	state Exp;
branches;
next	1.36;
commitid	rlqNH1kWHdjpd1Sd;

1.36
date	2015.01.04.02.28.26;	author deraadt;	state Exp;
branches;
next	1.35;
commitid	uDfX9ohJznhHKttv;

1.35
date	2014.12.29.17.07.17;	author tedu;	state Exp;
branches;
next	1.34;
commitid	q04mccYQUONTTwpj;

1.34
date	2014.12.24.22.04.26;	author tedu;	state Exp;
branches;
next	1.33;
commitid	uAPf8D4uFK9xi1nc;

1.33
date	2014.11.03.16.47.55;	author tedu;	state Exp;
branches;
next	1.32;
commitid	dapw4TfjliJJPe4m;

1.32
date	2014.09.03.08.26.00;	author jmc;	state Exp;
branches;
next	1.31;
commitid	xiK6COKhmP5vIVp2;

1.31
date	2014.09.03.07.47.50;	author giovanni;	state Exp;
branches;
next	1.30;
commitid	woS7CB2nP6IaJEYM;

1.30
date	2013.11.12.13.54.51;	author deraadt;	state Exp;
branches;
next	1.29;

1.29
date	2013.05.23.01.33.08;	author tedu;	state Exp;
branches;
next	1.28;

1.28
date	2007.07.14.21.26.38;	author krw;	state Exp;
branches;
next	1.27;

1.27
date	2007.05.01.01.26.25;	author jdixon;	state Exp;
branches;
next	1.26;

1.26
date	2007.03.20.03.50.39;	author tedu;	state Exp;
branches;
next	1.25;

1.25
date	2007.03.06.11.16.55;	author jmc;	state Exp;
branches;
next	1.24;

1.24
date	2006.11.02.18.02.16;	author ray;	state Exp;
branches;
next	1.23;

1.23
date	2006.05.27.23.42.08;	author moritz;	state Exp;
branches;
next	1.22;

1.22
date	2006.04.02.04.13.07;	author deraadt;	state Exp;
branches;
next	1.21;

1.21
date	2004.07.13.21.09.48;	author millert;	state Exp;
branches;
next	1.20;

1.20
date	2003.11.23.19.00.27;	author otto;	state Exp;
branches;
next	1.19;

1.19
date	2003.07.02.21.04.09;	author deraadt;	state Exp;
branches;
next	1.18;

1.18
date	2003.06.14.23.19.18;	author millert;	state Exp;
branches;
next	1.17;

1.17
date	2003.04.06.21.22.31;	author deraadt;	state Exp;
branches;
next	1.16;

1.16
date	2002.02.16.21.27.45;	author millert;	state Exp;
branches;
next	1.15;

1.15
date	2001.07.31.18.30.38;	author millert;	state Exp;
branches;
next	1.14;

1.14
date	2001.07.31.18.12.02;	author millert;	state Exp;
branches;
next	1.13;

1.13
date	2000.11.11.15.34.25;	author provos;	state Exp;
branches;
next	1.12;

1.12
date	2000.11.10.15.33.12;	author provos;	state Exp;
branches;
next	1.11;

1.11
date	99.09.03.18.13.37;	author deraadt;	state Exp;
branches;
next	1.10;

1.10
date	99.08.16.19.46.38;	author art;	state Exp;
branches;
next	1.9;

1.9
date	99.05.20.00.05.39;	author alex;	state Exp;
branches;
next	1.8;

1.8
date	99.05.19.03.17.15;	author alex;	state Exp;
branches;
next	1.7;

1.7
date	97.06.17.21.03.40;	author kstailey;	state Exp;
branches;
next	1.6;

1.6
date	97.06.17.21.01.01;	author kstailey;	state Exp;
branches;
next	1.5;

1.5
date	97.03.30.19.22.46;	author provos;	state Exp;
branches;
next	1.4;

1.4
date	97.03.27.23.43.36;	author downsj;	state Exp;
branches;
next	1.3;

1.3
date	96.08.26.08.41.26;	author downsj;	state Exp;
branches;
next	1.2;

1.2
date	96.08.08.04.37.02;	author downsj;	state Exp;
branches;
next	1.1;

1.1
date	96.08.08.02.07.22;	author downsj;	state Exp;
branches;
next	;


desc
@@


1.45
log
@usage() is static and __dead; add prototype for print_passwd;
return instead of exit from main
@
text
@/*	$OpenBSD: encrypt.c,v 1.44 2016/09/02 18:06:43 tedu Exp $	*/

/*
 * Copyright (c) 1996, Jason Downs.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR(S) ``AS IS'' AND ANY EXPRESS
 * OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR(S) BE LIABLE FOR ANY DIRECT,
 * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
 * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */

#include <sys/types.h>
#include <ctype.h>
#include <err.h>
#include <errno.h>
#include <pwd.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <login_cap.h>
#include <limits.h>
#include <readpassphrase.h>

/*
 * Very simple little program, for encrypting passwords from the command
 * line.  Useful for scripts and such.
 */

extern char *__progname;

static void __dead	usage(void);
static void		print_passwd(char *, int, char *);

#define DO_BLF		0

static void __dead
usage(void)
{

	(void)fprintf(stderr,
	    "usage: %s [-b rounds] [-c class] [-p | string]\n",
	    __progname);
	exit(1);
}

static void
print_passwd(char *string, int operation, char *extra)
{
	char buffer[_PASSWORD_LEN];
	const char *pref;
	char prefbuf[64];

	if (operation == DO_BLF) {
		if (snprintf(prefbuf, sizeof(prefbuf), "blowfish,%s", extra) >=
		    sizeof(prefbuf))
			errx(1, "pref too long");
		pref = prefbuf;
	} else {
		login_cap_t *lc;

		if ((lc = login_getclass(extra)) == NULL)
			errx(1, "unable to get login class `%s'",
			    extra ? (char *)extra : "default");
		pref = login_getcapstr(lc, "localcipher", NULL, NULL);
	}
	if (crypt_newhash(string, pref, buffer, sizeof(buffer)) != 0)
		err(1, "can't generate hash");

	fputs(buffer, stdout);
}

int
main(int argc, char **argv)
{
	int opt;
	int operation = -1;
	int prompt = 0;
	char *extra = NULL;	/* Store login class or number of rounds */
	const char *errstr;

	if (pledge("stdio rpath wpath tty", NULL) == -1)
		err(1, "pledge");

	while ((opt = getopt(argc, argv, "pb:c:")) != -1) {
		switch (opt) {
		case 'p':
			prompt = 1;
			break;
		case 'b':                       /* Blowfish password hash */
			if (operation != -1)
				usage();
			operation = DO_BLF;
			if (strcmp(optarg, "a") != 0) {
				(void)strtonum(optarg, 4, 31, &errstr);
				if (errstr != NULL)
					errx(1, "rounds is %s: %s", errstr,
					    optarg);
			}
			extra = optarg;
			break;
		case 'c':                       /* user login class */
			extra = optarg;
			operation = -1;
			break;
		default:
			usage();
		}
	}

	if (((argc - optind) < 1)) {
		char line[BUFSIZ];
		char string[1024];

		if (prompt) {
			if (readpassphrase("Enter string: ", string,
			    sizeof(string), RPP_ECHO_OFF) == NULL)
				err(1, "readpassphrase");
			print_passwd(string, operation, extra);
			(void)fputc('\n', stdout);
		} else {
			size_t len;
			/* Encrypt stdin to stdout. */
			while (!feof(stdin) &&
			    (fgets(line, sizeof(line), stdin) != NULL)) {
			    	len = strlen(line);
				if (len == 0 || line[0] == '\n')
					continue;
				if (line[len - 1] == '\n')
                     			line[len - 1] = '\0';

				print_passwd(line, operation, extra);

				(void)fputc('\n', stdout);
			}
		}
	} else {
		char *string;

		/* can't combine -p with a supplied string */
		if (prompt)
			usage();

		/* Perhaps it isn't worth worrying about, but... */
		if ((string = strdup(argv[optind])) == NULL)
			err(1, NULL);
		/* Wipe the argument. */
		explicit_bzero(argv[optind], strlen(argv[optind]));

		print_passwd(string, operation, extra);

		(void)fputc('\n', stdout);

		/* Wipe our copy, before we free it. */
		explicit_bzero(string, strlen(string));
		free(string);
	}
	return 0;
}
@


1.44
log
@_PASSWORD_LEN is length that comes out of crypt(), not a meaningful
length for user entered passwords. And the +1 is just superstitious
nonsense inherited from getpass() guts.
Switch to a pleasing fixed size of 1024.
ok millert
@
text
@d1 1
a1 1
/*	$OpenBSD: encrypt.c,v 1.43 2016/09/02 17:06:59 tedu Exp $	*/
d48 2
a49 1
void	usage(void);
d53 1
a53 1
void
d174 1
a174 1
	exit(0);
@


1.43
log
@convert getpass to readpassphrase. from Dimitris Papastamos
@
text
@d1 1
a1 1
/*	$OpenBSD: encrypt.c,v 1.42 2015/10/10 18:14:20 doug Exp $	*/
d128 1
a128 1
		char string[_PASSWORD_LEN + 1];
@


1.42
log
@encrypt(1) also needs to pledge "wpath" for getpass().

getpass() opens /dev/tty RW so it can write the prompt.

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: encrypt.c,v 1.41 2015/10/10 17:59:15 deraadt Exp $	*/
d39 1
d127 2
a128 1
		char line[BUFSIZ], *string;
d131 3
a133 2
			if ((string = getpass("Enter string: ")) == NULL)
				err(1, "getpass");
@


1.41
log
@pledge "stdio rpath tty".  rpath for the configuration reading done by
login* subsystem, tty for readpassphase()
ok beck
@
text
@d1 1
a1 1
/*	$OpenBSD: encrypt.c,v 1.40 2015/02/26 17:46:15 tedu Exp $	*/
d96 1
a96 1
	if (pledge("stdio rpath tty", NULL) == -1)
@


1.40
log
@Wrap a long line.  Use explicit_bzero.  Fix comment describing extra.
From Andre Smagin
Also, should be safe to print errno from newhash() now.
ok millert
@
text
@d1 1
a1 1
/*	$OpenBSD: encrypt.c,v 1.39 2015/02/24 18:45:51 tedu Exp $	*/
d95 3
@


1.39
log
@increase prefbuf size so that 'encrypt -b 000000000000000000000012' works.
noticed by Andre Smagin.
also check snprintf for overflow so we get better error messages if
somebody decides to pad with even more zeroes, and avoid possible
truncations.
@
text
@d1 1
a1 1
/*	$OpenBSD: encrypt.c,v 1.38 2015/01/15 17:34:15 chl Exp $	*/
d82 1
a82 1
		errx(1, "can't generate hash");
d93 1
a93 1
	char *extra = NULL;		/* Store salt or number of rounds */
d108 2
a109 1
					errx(1, "rounds is %s: %s", errstr, optarg);
d157 1
a157 1
		memset(argv[optind], 0, strlen(argv[optind]));
d164 1
a164 1
		memset(string, 0, strlen(string));
@


1.38
log
@remove unused variable

ok tedu@@
@
text
@d1 1
a1 1
/*	$OpenBSD: encrypt.c,v 1.37 2015/01/05 14:07:12 tedu Exp $	*/
d66 1
a66 1
	char prefbuf[16];
d69 3
a71 1
		snprintf(prefbuf, sizeof(prefbuf), "blowfish,%s", extra);
@


1.37
log
@encrypt can use the scrypt scaling code in libc now via crypt_newhash
@
text
@d1 1
a1 1
/*	$OpenBSD: encrypt.c,v 1.36 2015/01/04 02:28:26 deraadt Exp $	*/
a90 1
	int rounds;
@


1.36
log
@fix -b a mode, spotted by rpe
@
text
@d1 1
a1 1
/*	$OpenBSD: encrypt.c,v 1.35 2014/12/29 17:07:17 tedu Exp $	*/
a47 2
int	ideal_rounds(void);
void	print_passwd(char *, int, void *);
d61 2
a62 36
/*
 * Time how long 8 rounds takes to measure this system's performance.
 * We are aiming for something that takes between 0.25 and 0.5 seconds.
 */
int
ideal_rounds(void)
{
	clock_t before, after;
	int r = 8;
	char buf[_PASSWORD_LEN];
	int duration;

	strlcpy(buf, bcrypt_gensalt(r), _PASSWORD_LEN);
	before = clock();
	crypt("testpassword", buf);
	after = clock();

	duration = after - before;

	/* too quick? slow it down. */
	while (r < 16 && duration <= CLOCKS_PER_SEC / 4) {
		r += 1;
		duration *= 2;
	}
	/* too slow? speed it up. */
	while (r > 4 && duration > CLOCKS_PER_SEC / 2) {
		r -= 1;
		duration /= 2;
	}

	return r;
}


void
print_passwd(char *string, int operation, void *extra)
d65 2
d69 2
a70 5
		int rounds = *(int *)extra;
		if (bcrypt_newhash(string, rounds, buffer, sizeof(buffer)) != 0)
			errx(1, "bcrypt newhash failed");
		fputs(buffer, stdout);
		return;
a72 1
		const char *pref;
a77 2
		if (crypt_newhash(string, pref, buffer, sizeof(buffer)) != 0)
			errx(1, "can't generate hash");
d79 2
d92 1
a92 1
	void *extra = NULL;		/* Store salt or number of rounds */
d104 2
a105 4
			if (strcmp(optarg, "a") == 0)
				rounds = ideal_rounds();
			else {
				rounds = strtonum(optarg, 1, INT_MAX, &errstr);
d107 1
a107 1
					errx(1, "%s: %s", errstr, optarg);
d109 1
a109 1
			extra = &rounds;
@


1.35
log
@impose some limits on the ideal rounds so nothing too crazy happens when
the clock results are weird
@
text
@d1 1
a1 1
/*	$OpenBSD: encrypt.c,v 1.34 2014/12/24 22:04:26 tedu Exp $	*/
d144 1
a144 1
			else
d146 3
a148 2
			if (errstr != NULL)
				errx(1, "%s: %s", errstr, optarg);
@


1.34
log
@simplify. bcrypt only support and use newer libc APIs. no makekey emul.
ok deraadt
schwarze is a little sad to see the last 1/8 shared man page go, but we
have a support program in place, called the attic.
@
text
@d1 1
a1 1
/*	$OpenBSD: encrypt.c,v 1.33 2014/11/03 16:47:55 tedu Exp $	*/
d83 1
a83 1
	while (duration <= CLOCKS_PER_SEC / 4) {
d88 1
a88 1
	while (duration > CLOCKS_PER_SEC / 2) {
@


1.33
log
@hoist blowfish up and use bcrypt_newhash directly
@
text
@d1 1
a1 1
/*	$OpenBSD: encrypt.c,v 1.32 2014/09/03 08:26:00 jmc Exp $	*/
a44 4
#define DO_MAKEKEY 0
#define DO_DES     1
#define DO_BLF     2

a45 1
char buffer[_PASSWORD_LEN];
d51 2
d58 1
a58 1
	    "usage: %s [-k] [-b rounds] [-c class] [-p | string] [-s salt]\n",
d100 1
a100 4
	char msalt[3], *salt, *cryptstr;
	login_cap_t *lc;
	int pwd_gensalt(char *, int, login_cap_t *, char);
	void to64(char *, u_int32_t, int n);
d103 2
a104 2
		if (bcrypt_newhash(string, *(int *)extra, buffer,
		    sizeof(buffer)) != 0)
d108 3
a110 18
	}

	switch(operation) {
	case DO_MAKEKEY:
		/*
		 * makekey mode: parse string into separate DES key and salt.
		 */
		if (strlen(string) != 10) {
			/* To be compatible... */
			errx(1, "%s", strerror(EFTYPE));
		}
		strlcpy(msalt, &string[8], sizeof msalt);
		salt = msalt;
		break;

	case DO_DES:
		salt = extra;
		break;
a111 1
	default:
d115 3
a117 4
		if (!pwd_gensalt(buffer, _PASSWORD_LEN, lc, 'l'))
			errx(1, "can't generate salt");
		salt = buffer;
		break;
d120 1
a120 3
	if ((cryptstr = crypt(string, salt)) == NULL)
		errx(1, "crypt failed");
	fputs(cryptstr, stdout);
d133 1
a133 4
	if (strcmp(__progname, "makekey") == 0)
		operation = DO_MAKEKEY;

	while ((opt = getopt(argc, argv, "kps:b:c:")) != -1) {
a134 6
		case 'k':                       /* Stdin/Stdout Unix crypt */
			if (operation != -1 || prompt)
				usage();
			operation = DO_MAKEKEY;
			break;

a135 2
			if (operation == DO_MAKEKEY)
				usage();
a137 8

		case 's':                       /* Unix crypt (DES) */
			if (operation != -1 || optarg[0] == '$')
				usage();
			operation = DO_DES;
			extra = optarg;
			break;

a149 1

a153 1

d159 1
a159 1
	if (((argc - optind) < 1) || operation == DO_MAKEKEY) {
a179 4
				if (operation == DO_MAKEKEY) {
					fflush(stdout);
					break;
				}
@


1.32
log
@remove -m from usage();
@
text
@d1 1
a1 1
/*	$OpenBSD: encrypt.c,v 1.31 2014/09/03 07:47:50 giovanni Exp $	*/
d108 8
a126 5
		break;

	case DO_BLF:
		strlcpy(buffer, bcrypt_gensalt(*(int *)extra), _PASSWORD_LEN);
		salt = buffer;
@


1.31
log
@
kill md5 support, broken since May
ok tedu@@
@
text
@d1 1
a1 1
/*	$OpenBSD: encrypt.c,v 1.30 2013/11/12 13:54:51 deraadt Exp $	*/
d61 1
a61 1
	    "usage: %s [-km] [-b rounds] [-c class] [-p | string] [-s salt]\n",
@


1.30
log
@simpler prototype repairs
@
text
@d1 1
a1 1
/*	$OpenBSD: encrypt.c,v 1.29 2013/05/23 01:33:08 tedu Exp $	*/
d47 1
a47 2
#define DO_MD5     2
#define DO_BLF     3
a120 8
	case DO_MD5:
		strlcpy(buffer, "$1$", sizeof buffer);
		to64(&buffer[3], arc4random(), 4);
		to64(&buffer[7], arc4random(), 4);
		strlcpy(buffer + 11, "$", sizeof buffer - 11);
		salt = buffer;
		break;

d158 1
a158 1
	while ((opt = getopt(argc, argv, "kmps:b:c:")) != -1) {
a163 6
			break;

		case 'm':                       /* MD5 password hash */
			if (operation != -1)
				usage();
			operation = DO_MD5;
@


1.29
log
@allow auto scaling bcrypt rounds by CPU power.
ok deraadt jmc sthen
@
text
@d1 1
a1 1
/*	$OpenBSD: encrypt.c,v 1.28 2007/07/14 21:26:38 krw Exp $	*/
d54 1
d72 1
a72 1
ideal_rounds()
@


1.28
log
@Don't trim whitespace from stdin. Encrypt it the same as other
input sources. Feedback and fixes from ray@@ and fgsch@@.

ok millert@@ (six years ago) ray@@ fgsch@@
@
text
@d1 1
a1 1
/*	$OpenBSD: encrypt.c,v 1.27 2007/05/01 01:26:25 jdixon Exp $	*/
d66 34
d197 4
a200 1
			rounds = strtonum(optarg, 1, INT_MAX, &errstr);
@


1.27
log
@use strtonum; ok millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: encrypt.c,v 1.26 2007/03/20 03:50:39 tedu Exp $	*/
a53 1
char	*trim(char *);
a65 20
char *
trim(char *line)
{
	char *ptr;

	if (line[0] == '\0')
		return (line);

	for (ptr = &line[strlen(line)-1]; ptr > line; ptr--) {
		if (!isspace(*ptr))
			break;
	}
	ptr[1] = '\0';

	for (ptr = line; isspace(*ptr); ptr++)
		;

	return(ptr);
}

d188 1
d192 2
a193 3
				/* Kill the whitesapce. */
				string = trim(line);
				if (*string == '\0')
d195 4
a198 2
				
				print_passwd(string, operation, extra);
@


1.26
log
@remove some bogus *p tests from charles longeau
ok deraadt millert
@
text
@d1 1
a1 1
/*	$OpenBSD: encrypt.c,v 1.25 2007/03/06 11:16:55 jmc Exp $	*/
d38 1
d148 1
d184 3
a186 1
			rounds = atoi(optarg);
@


1.25
log
@tidy up synopsis and usage(); from Igor Sobrado
@
text
@d1 1
a1 1
/*	$OpenBSD: encrypt.c,v 1.24 2006/11/02 18:02:16 ray Exp $	*/
d80 1
a80 1
	for (ptr = line; *ptr && isspace(*ptr); ptr++)
@


1.24
log
@There is no need to trim an empty string any further, just return
it.

OK moritz@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: encrypt.c,v 1.23 2006/05/27 23:42:08 moritz Exp $	*/
d61 1
a61 1
	    "usage: %s [-k] [-b rounds] [-c class] [-m] [-s salt] [-p | string]\n",
@


1.23
log
@Handle crypt(3) returning NULL. Found by Gustavo C. Pereira.

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: encrypt.c,v 1.22 2006/04/02 04:13:07 deraadt Exp $	*/
d70 3
@


1.22
log
@oops, to64() is shared.
@
text
@d1 1
a1 1
/*	$OpenBSD: encrypt.c,v 1.21 2004/07/13 21:09:48 millert Exp $	*/
d86 1
a86 1
	char msalt[3], *salt;
d131 3
a133 1
	(void)fputs(crypt(string, salt), stdout);
@


1.21
log
@passwd.conf has been deprecated since login.conf was imported.
Today it finally dies.  Based on a diff from Gabriel Kihlman.
@
text
@d1 1
a1 1
/*	$OpenBSD: encrypt.c,v 1.20 2003/11/23 19:00:27 otto Exp $	*/
d89 1
a89 1
	void to64(char *, int32_t, int n);
@


1.20
log
@Check getpass(3) return value. From Jared Yanovich <jjy2+ at pitt dot edu>

ok henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: encrypt.c,v 1.19 2003/07/02 21:04:09 deraadt Exp $	*/
a86 1
	struct passwd pwd;
d88 1
a88 1
	int pwd_gensalt(char *, int, struct passwd *, login_cap_t *, char);
a121 1
		pwd.pw_name = "default";
d125 1
a125 1
		if (!pwd_gensalt(buffer, _PASSWORD_LEN, &pwd, lc, 'l'))
@


1.19
log
@protos
@
text
@d1 1
a1 1
/*	$OpenBSD: encrypt.c,v 1.18 2003/06/14 23:19:18 millert Exp $	*/
d197 2
a198 1
			string = getpass("Enter string: ");
@


1.18
log
@Add a "-c class" option to specify that the given login class should
be used to find the cipher to user.
@
text
@d1 1
a1 1
/*	$OpenBSD: encrypt.c,v 1.17 2003/04/06 21:22:31 deraadt Exp $	*/
d51 4
@


1.17
log
@strlcpy
@
text
@d1 1
a1 1
/*	$OpenBSD: encrypt.c,v 1.16 2002/02/16 21:27:45 millert Exp $	*/
d57 1
a57 1
	    "usage: %s [-k] [-b rounds] [-m] [-s salt] [-p | string]\n",
d120 3
a122 2
		if ((lc = login_getclass(NULL)) == NULL)
			errx(1, "unable to get default login class.");
d139 1
a139 1
	void *extra;                       /* Store salt or number of rounds */
d144 1
a144 1
	while ((opt = getopt(argc, argv, "kmps:b:")) != -1) {
d177 5
@


1.16
log
@Part one of userland __P removal.  Done with a simple regexp with some minor hand editing to make comments line up correctly.  Another pass is forthcoming that handles the cases that could not be done automatically.
@
text
@d1 1
a1 1
/*	$OpenBSD: encrypt.c,v 1.15 2001/07/31 18:30:38 millert Exp $	*/
d97 1
a97 1
		strcpy(msalt, &string[8]);
d102 1
a102 1
		strcpy(buffer, "$1$");
d105 1
a105 1
		strcpy(buffer + 11, "$");
@


1.15
log
@KNF + some ANSIfication
@
text
@d1 1
a1 1
/*	$OpenBSD: encrypt.c,v 1.14 2001/07/31 18:12:02 millert Exp $	*/
d85 2
a86 2
	int pwd_gensalt __P((char *, int, struct passwd *, login_cap_t *, char));
	void to64 __P((char *, int32_t, int n));
@


1.14
log
@Call pwd_gensalt() with the correct args and reference login.conf
in man page; hideishi@@magisystem.net
@
text
@d1 1
a1 1
/*	$OpenBSD: encrypt.c,v 1.13 2000/11/11 15:34:25 provos Exp $	*/
a27 1
#include <stdio.h>
d29 1
d32 2
a36 2
#include <pwd.h>
#include <ctype.h>
d49 1
a49 4
extern char *optarg;
extern int optind;

char *progname;
d52 2
a53 1
void usage()
d55 5
a59 3
    fprintf(stderr, "usage: %s [-k] [-b rounds] [-m] [-s salt] [-p | string]\n",
	progname);
    exit(1);
d62 2
a63 2
char *trim(line)
    char *line;
d65 1
a65 1
    char *ptr;
d67 5
a71 5
    for (ptr = &line[strlen(line)-1]; ptr > line; ptr--) {
        if (!isspace(*ptr))
	    break;
    }
    ptr[1] = '\0';
d73 2
a74 1
    for (ptr = line; *ptr && isspace(*ptr); ptr++);
d76 1
a76 1
    return(ptr);
d79 2
a80 1
void print_passwd(char *string, int operation, void *extra)
d82 47
a128 50
     char msalt[3], *salt;
     struct passwd pwd;
     login_cap_t *lc;
     extern int pwd_gensalt __P((char *, int, struct passwd *, login_cap_t *, char));
     extern void to64 __P((char *, int32_t, int n));

     switch(operation) {
     case DO_MAKEKEY:
	  /*
	   * makekey mode: parse string into separate DES key and salt.
	   */
	  if (strlen(string) != 10) {
	       /* To be compatible... */
	       fprintf (stderr, "%s: %s\n", progname, strerror(EFTYPE));
	       exit (1);
	  }
	  strcpy(msalt, &string[8]);
	  salt = msalt;
	  break;
     case DO_MD5:
	  strcpy(buffer, "$1$");
	  to64(&buffer[3], arc4random(), 4);
	  to64(&buffer[7], arc4random(), 4);
	  strcpy(buffer+11, "$");
	  salt = buffer;
	  break;
     case DO_BLF:
	  strncpy(buffer, bcrypt_gensalt(*(int *)extra), _PASSWORD_LEN - 1);
	  buffer[_PASSWORD_LEN-1] = 0;
	  salt = buffer;
	  break;
     case DO_DES:
	  salt = extra;
	  break;
     default:
	  pwd.pw_name = "default";
	  if ((lc = login_getclass(NULL)) == NULL) {
	       fprintf(stderr, "%s: unable to get default login class.\n",
		    progname);
	       exit (1);
	  }
	  if (!pwd_gensalt(buffer, _PASSWORD_LEN, &pwd, lc, 'l')) {
	       fprintf (stderr, "%s: Can't generate salt\n", progname);
	       exit (1);
	  }
	  salt = buffer;
	  break;
     }
     
     fputs(crypt(string, salt), stdout);
d131 2
a132 3
int main(argc, argv)
    int argc;
    char *argv[];
d134 47
a180 48
    int opt;
    int operation = -1;
    int prompt = 0;
    int rounds;
    void *extra;                       /* Store salt or number of rounds */

    if ((progname = strrchr(argv[0], '/')))
	progname++;
    else
	progname = argv[0];

    if (strcmp(progname, "makekey") == 0)
	 operation = DO_MAKEKEY;

    while ((opt = getopt(argc, argv, "kmps:b:")) != -1) {
    	switch (opt) {
	case 'k':                       /* Stdin/Stdout Unix crypt */
	    if (operation != -1 || prompt)
		 usage();
	    operation = DO_MAKEKEY;
	    break;
	case 'm':                       /* MD5 password hash */
	    if (operation != -1)
		 usage();
	    operation = DO_MD5;
	    break;
	case 'p':
	    if (operation == DO_MAKEKEY)
		 usage();
	    prompt = 1;
	    break;
	case 's':                       /* Unix crypt (DES) */
	    if (operation != -1)
		 usage();
	    operation = DO_DES;
	    if (optarg[0] == '$')	/* -s is only for DES. */
		usage();
	    extra = optarg;
	    break;
	case 'b':                       /* Blowfish password hash */
	    if (operation != -1)
		 usage();
	     operation = DO_BLF;
	     rounds = atoi(optarg);
	     extra = &rounds;
	     break;
	default:
	    usage();
a181 1
    }
d183 2
a184 2
    if (((argc - optind) < 1) || operation == DO_MAKEKEY) {
    	char line[BUFSIZ], *string;
d186 22
a207 4
	if (prompt) {
	    string = getpass("Enter string: ");
	    print_passwd(string, operation, extra);
	    fputc('\n', stdout);
d209 12
a220 7
	    /* Encrypt stdin to stdout. */
	    while (!feof(stdin) && (fgets(line, sizeof(line), stdin) != NULL)) {
		/* Kill the whitesapce. */
		string = trim(line);
		if (*string == '\0')
		    continue;
		
d223 5
a227 6
		if (operation == DO_MAKEKEY) {
		    fflush(stdout);
		    break;
		}
		fputc('\n', stdout);
	    }
d229 1
a229 23
    } else {
    	char *string;

	/* can't combine -p with a supplied string */
	if (prompt)
	    usage();

    	/* Perhaps it isn't worth worrying about, but... */
    	string = strdup(argv[optind]);
    	if (string == NULL)
    	    err(1, NULL);
    	/* Wipe the argument. */
    	bzero(argv[optind], strlen(argv[optind]));

	print_passwd(string, operation, extra);

    	fputc('\n', stdout);

    	/* Wipe our copy, before we free it. */
    	bzero(string, strlen(string));
    	free(string);
    }
    exit(0);
@


1.13
log
@allow prompt to be specified anywhere on the command line, make it work
with md5.  prohibit makekey mode and prompt.
@
text
@d1 1
a1 1
/*	$OpenBSD: encrypt.c,v 1.12 2000/11/10 15:33:12 provos Exp $	*/
d37 1
d82 2
a83 1
     extern int pwd_gensalt __P((char *, int, struct passwd *, char));
d116 6
a121 1
	  if (!pwd_gensalt(buffer, _PASSWORD_LEN, &pwd, 'l')) {
@


1.12
log
@seperate -> separate, okay aaron@@
@
text
@d1 1
a1 1
/*	$OpenBSD: encrypt.c,v 1.11 1999/09/03 18:13:37 deraadt Exp $	*/
d146 1
a146 1
	    if (operation != -1)
d151 1
a151 1
	    if (operation != -1 || prompt)
d156 1
a156 1
	    if (operation != -1)
@


1.11
log
@proto bcrypt_gensalt()
@
text
@d1 1
a1 1
/*	$OpenBSD: encrypt.c,v 1.10 1999/08/16 19:46:38 art Exp $	*/
d87 1
a87 1
	   * makekey mode: parse string into seperate DES key and salt.
@


1.10
log
@include ctype.h for isspace() and fix some declarations
@
text
@d1 1
a1 1
/*	$OpenBSD: encrypt.c,v 1.9 1999/05/20 00:05:39 alex Exp $	*/
a80 1
     extern char *bcrypt_gensalt __P((int));
@


1.9
log
@Add -p flag, prompt for a string with echo off.
@
text
@d1 1
a1 1
/*	$OpenBSD: encrypt.c,v 1.8 1999/05/19 03:17:15 alex Exp $	*/
d36 1
d82 2
a83 1
     extern pwd_gensalt __P((char *, int, struct passwd *, char));
@


1.8
log
@Use fprintf/exit in place of errx for usage display.
@
text
@d1 1
a1 1
/*	$OpenBSD: encrypt.c,v 1.7 1997/06/17 21:03:40 kstailey Exp $	*/
d55 1
a55 1
    fprintf(stderr, "usage: %s [-k] [-b rounds] [-m] [-s salt] [string]\n",
d130 1
d142 1
a142 1
    while ((opt = getopt(argc, argv, "kms:b:")) != -1) {
d150 5
d157 1
a157 1
	    operation = DO_MD5;
d182 2
a183 7
    	/* Encrypt stdin to stdout. */
	while (!feof(stdin) && (fgets(line, sizeof(line), stdin) != NULL)) {
	    /* Kill the whitesapce. */
	    string = trim(line);
	    if (*string == '\0')
	    	continue;
	    
d185 16
a200 4

	    if (operation == DO_MAKEKEY) {
	        fflush(stdout);
		break;
a201 1
	    fputc('\n', stdout);
d205 4
@


1.7
log
@add <stdlib.h> for atoi(), free(), etc.
@
text
@d1 1
a1 1
/*	$OpenBSD: encrypt.c,v 1.6 1997/06/17 21:01:01 kstailey Exp $	*/
d55 3
a57 1
    errx(1, "usage: %s [-k] [-b rounds] [-m] [-s salt] [string]", progname);
@


1.6
log
@(foo *)NULL -> NULL
@
text
@d1 1
a1 1
/*	$OpenBSD: encrypt.c,v 1.5 1997/03/30 19:22:46 provos Exp $	*/
d32 1
@


1.5
log
@blowfish + passwd.conf support. fixed md5 salt.
@
text
@d1 1
a1 1
/*	$OpenBSD: encrypt.c,v 1.4 1997/03/27 23:43:36 downsj Exp $	*/
d193 1
a193 1
    	if (string == (char *)NULL)
@


1.4
log
@Fix core dump.
@
text
@d1 1
a1 1
/*	$OpenBSD: encrypt.c,v 1.3 1996/08/26 08:41:26 downsj Exp $	*/
d34 1
d41 5
d50 1
d54 1
a54 1
    errx(1, "usage: %s [-k] [-m] [-s salt] [string]", progname);
d73 48
d126 3
a128 3
    int do_md5 = 0;
    int do_makekey = 0;
    char *salt = (char *)NULL;
d136 1
a136 1
    	do_makekey = 1;
d138 1
a138 1
    while ((opt = getopt(argc, argv, "kms:")) != -1) {
d140 4
a143 2
	case 'k':
	    do_makekey = 1;
d145 4
a148 2
	case 'm':
	    do_md5 = 1;
d150 5
a154 3
	case 's':
	    salt = optarg;
	    if (salt[0] == '$')		/* -s is only for DES. */
d156 1
d158 7
d170 2
a171 11
    if (do_md5 && !do_makekey && (salt != (char *)NULL))
	usage();

    if (!do_md5 && !do_makekey && (salt == (char *)NULL))
	usage();

    if (do_makekey && (do_md5 || (salt != (char *)NULL)))
        usage();

    if (((argc - optind) < 1) || do_makekey) {
    	char line[BUFSIZ], *string, msalt[3];
d179 2
a180 12
	    if (do_makekey) {
	    	/*
		 * makekey mode: parse string into seperate DES key and salt.
		 */
		if (strlen(string) != 10) {
		    /* To be compatible... */
		    fprintf (stderr, "%s: %s\n", progname, strerror(EFTYPE));
		    exit (1);
		}
		strcpy(msalt, &string[8]);
		salt = msalt;
	    }
d182 1
a182 2
	    fputs(crypt(string, (do_md5 ? "$1$" : salt)), stdout);
	    if (do_makekey) {
d198 2
a199 1
    	fputs(crypt(string, (do_md5 ? "$1$" : salt)), stdout);
@


1.3
log
@Add an old makekey(8) mode.
@
text
@d1 1
a1 1
/*	$OpenBSD: encrypt.c,v 1.2 1996/08/08 04:37:02 downsj Exp $	*/
d93 2
d110 1
a110 1
    if ((argc - optind) < 1) {
@


1.2
log
@Slightly cleaner.
@
text
@d1 1
a1 1
/*	$OpenBSD: encrypt.c,v 1.1 1996/08/08 02:07:22 downsj Exp $	*/
d31 1
a39 1
extern char *__progname;
d43 2
d47 1
a47 1
    errx(1, "usage: %s [-m] [-s salt] [string]", __progname);
d72 1
d75 9
a83 1
    while ((opt = getopt(argc, argv, "ms:")) != -1) {
d85 3
d99 1
a99 1
    if (do_md5 && (salt != (char *)NULL))
d102 1
a102 1
    if (!do_md5 && (salt == (char *)NULL))
d105 3
d109 1
a109 1
    	char line[BUFSIZ], *string;
d117 12
d131 4
@


1.1
log
@encrypt(1), little utility for encrypting passwords from the command line.
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d48 16
d92 1
a92 1
    	char line[BUFSIZ];
d96 3
a98 1
	    if ((line[0] == '\0') || (line[0] == '\n'))
d101 1
a101 5
	    /* Kill the newline. */
	    if (line[strlen(line)] == '\n')
	    	line[strlen(line)] = '\0';

	    fputs(crypt(line, (do_md5 ? "$1$" : salt)), stdout);
@
