head	1.23;
access;
symbols
	OPENBSD_6_2_BASE:1.23
	OPENBSD_6_1:1.23.0.6
	OPENBSD_6_1_BASE:1.23
	OPENBSD_6_0:1.23.0.2
	OPENBSD_6_0_BASE:1.23
	OPENBSD_5_9:1.22.0.2
	OPENBSD_5_9_BASE:1.22
	OPENBSD_5_8:1.21.0.6
	OPENBSD_5_8_BASE:1.21
	OPENBSD_5_7:1.21.0.2
	OPENBSD_5_7_BASE:1.21
	OPENBSD_5_6:1.20.0.22
	OPENBSD_5_6_BASE:1.20
	OPENBSD_5_5:1.20.0.20
	OPENBSD_5_5_BASE:1.20
	OPENBSD_5_4:1.20.0.16
	OPENBSD_5_4_BASE:1.20
	OPENBSD_5_3:1.20.0.14
	OPENBSD_5_3_BASE:1.20
	OPENBSD_5_2:1.20.0.12
	OPENBSD_5_2_BASE:1.20
	OPENBSD_5_1_BASE:1.20
	OPENBSD_5_1:1.20.0.10
	OPENBSD_5_0:1.20.0.8
	OPENBSD_5_0_BASE:1.20
	OPENBSD_4_9:1.20.0.6
	OPENBSD_4_9_BASE:1.20
	OPENBSD_4_8:1.20.0.4
	OPENBSD_4_8_BASE:1.20
	OPENBSD_4_7:1.20.0.2
	OPENBSD_4_7_BASE:1.20
	OPENBSD_4_6:1.19.0.10
	OPENBSD_4_6_BASE:1.19
	OPENBSD_4_5:1.19.0.6
	OPENBSD_4_5_BASE:1.19
	OPENBSD_4_4:1.19.0.4
	OPENBSD_4_4_BASE:1.19
	OPENBSD_4_3:1.19.0.2
	OPENBSD_4_3_BASE:1.19
	OPENBSD_4_2:1.18.0.8
	OPENBSD_4_2_BASE:1.18
	OPENBSD_4_1:1.18.0.6
	OPENBSD_4_1_BASE:1.18
	OPENBSD_4_0:1.18.0.4
	OPENBSD_4_0_BASE:1.18
	OPENBSD_3_9:1.18.0.2
	OPENBSD_3_9_BASE:1.18
	OPENBSD_3_8:1.17.0.10
	OPENBSD_3_8_BASE:1.17
	OPENBSD_3_7:1.17.0.8
	OPENBSD_3_7_BASE:1.17
	OPENBSD_3_6:1.17.0.6
	OPENBSD_3_6_BASE:1.17
	OPENBSD_3_5:1.17.0.4
	OPENBSD_3_5_BASE:1.17
	OPENBSD_3_4:1.17.0.2
	OPENBSD_3_4_BASE:1.17
	OPENBSD_3_3:1.16.0.6
	OPENBSD_3_3_BASE:1.16
	OPENBSD_3_2:1.16.0.4
	OPENBSD_3_2_BASE:1.16
	OPENBSD_3_1:1.16.0.2
	OPENBSD_3_1_BASE:1.16
	OPENBSD_3_0:1.14.0.4
	OPENBSD_3_0_BASE:1.14
	OPENBSD_2_9_BASE:1.14
	OPENBSD_2_9:1.14.0.2
	OPENBSD_2_8:1.13.0.2
	OPENBSD_2_8_BASE:1.13
	OPENBSD_2_7:1.12.0.2
	OPENBSD_2_7_BASE:1.12
	OPENBSD_2_6:1.11.0.6
	OPENBSD_2_6_BASE:1.11
	OPENBSD_2_5:1.11.0.4
	OPENBSD_2_5_BASE:1.11
	OPENBSD_2_4:1.11.0.2
	OPENBSD_2_4_BASE:1.11
	OPENBSD_2_3:1.9.0.2
	OPENBSD_2_3_BASE:1.9
	OPENBSD_2_2:1.8.0.2
	OPENBSD_2_2_BASE:1.8
	OPENBSD_2_1:1.3.0.2
	OPENBSD_2_1_BASE:1.3
	OPENBSD_2_0:1.2.0.2
	OPENBSD_2_0_BASE:1.2
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.23
date	2016.07.19.06.43.27;	author deraadt;	state Exp;
branches;
next	1.22;
commitid	B2XC0go4gk9SNttR;

1.22
date	2015.11.11.01.12.10;	author deraadt;	state Exp;
branches;
next	1.21;
commitid	nVtGolYSsQ6VkRrW;

1.21
date	2014.11.24.20.01.43;	author millert;	state Exp;
branches;
next	1.20;
commitid	LJSWmbXLAaCRa2Mq;

1.20
date	2009.10.27.23.59.40;	author deraadt;	state Exp;
branches;
next	1.19;

1.19
date	2007.09.10.14.29.53;	author tobias;	state Exp;
branches;
next	1.18;

1.18
date	2006.02.01.19.01.35;	author otto;	state Exp;
branches;
next	1.17;

1.17
date	2003.06.03.02.56.11;	author millert;	state Exp;
branches;
next	1.16;

1.16
date	2001.11.21.15.26.39;	author millert;	state Exp;
branches;
next	1.15;

1.15
date	2001.11.20.20.50.00;	author millert;	state Exp;
branches;
next	1.14;

1.14
date	2001.01.16.05.36.09;	author millert;	state Exp;
branches;
next	1.13;

1.13
date	2000.06.30.16.00.18;	author millert;	state Exp;
branches;
next	1.12;

1.12
date	2000.04.26.15.47.31;	author millert;	state Exp;
branches
	1.12.2.1;
next	1.11;

1.11
date	98.09.10.16.18.37;	author millert;	state Exp;
branches;
next	1.10;

1.10
date	98.06.12.17.51.52;	author millert;	state Exp;
branches;
next	1.9;

1.9
date	97.11.14.00.23.55;	author millert;	state Exp;
branches;
next	1.8;

1.8
date	97.07.24.17.27.12;	author millert;	state Exp;
branches;
next	1.7;

1.7
date	97.07.24.16.23.39;	author millert;	state Exp;
branches;
next	1.6;

1.6
date	97.07.14.00.24.29;	author millert;	state Exp;
branches;
next	1.5;

1.5
date	97.07.13.23.54.02;	author millert;	state Exp;
branches;
next	1.4;

1.4
date	97.07.13.21.21.16;	author millert;	state Exp;
branches;
next	1.3;

1.3
date	97.03.29.03.01.47;	author millert;	state Exp;
branches;
next	1.2;

1.2
date	96.06.11.12.53.48;	author deraadt;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.45.39;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.45.39;	author deraadt;	state Exp;
branches;
next	;

1.12.2.1
date	2000.10.06.21.16.15;	author jason;	state Exp;
branches;
next	;


desc
@@


1.23
log
@Cleanup close(open idioms.
ok krw
@
text
@/*	$OpenBSD: quit.c,v 1.22 2015/11/11 01:12:10 deraadt Exp $	*/
/*	$NetBSD: quit.c,v 1.6 1996/12/28 07:11:07 tls Exp $	*/

/*
 * Copyright (c) 1980, 1993
 *	The Regents of the University of California.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */

#include "rcv.h"
#include <fcntl.h>
#include "extern.h"

/*
 * Rcv -- receive mail rationally.
 *
 * Termination processing.
 */

/*
 * The "quit" command.
 */
int
quitcmd(void *v)
{
	/*
	 * If we are sourcing, then return 1 so execute() can handle it.
	 * Otherwise, return -1 to abort command loop.
	 */
	if (sourcing)
		return(1);
	return(-1);
}

/*
 * Save all of the undetermined messages at the top of "mbox"
 * Save all untouched messages back in the system mailbox.
 * Remove the system mailbox, if none saved there.
 */
int
quit(void)
{
	int mcount, p, modify, autohold, anystat, holdbit, nohold;
	FILE *ibuf = NULL, *obuf, *fbuf, *rbuf, *abuf;
	struct message *mp;
	int c, fd;
	struct stat minfo;
	char *mbox, tempname[PATHSIZE];

	/*
	 * If we are read only, we can't do anything,
	 * so just return quickly.
	 */
	if (readonly)
		return(0);

	/*
	 * If editing (not reading system mail box), then do the work
	 * in edstop()
	 */
	if (edit)
		return(edstop());

	/*
	 * See if there any messages to save in mbox.  If no, we
	 * can save copying mbox to /tmp and back.
	 *
	 * Check also to see if any files need to be preserved.
	 * Delete all untouched messages to keep them out of mbox.
	 * If all the messages are to be preserved, just exit with
	 * a message.
	 */
	fbuf = Fopen(mailname, "r+");
	if (fbuf == NULL)
		goto newmail;
	if (flock(fileno(fbuf), LOCK_EX) == -1) {
		warn("Unable to lock mailbox");
		(void)Fclose(fbuf);
		return(-1);
	}
	if (!spool_lock()) {
		(void)Fclose(fbuf);
		return(-1);		/* lockspool printed the error for us */
	}
	rbuf = NULL;
	if (fstat(fileno(fbuf), &minfo) >= 0 && minfo.st_size > mailsize) {
		puts("New mail has arrived.");
		(void)snprintf(tempname, sizeof(tempname),
		    "%s/mail.RqXXXXXXXXXX", tmpdir);
		if ((fd = mkstemp(tempname)) == -1 ||
		    (rbuf = Fdopen(fd, "w")) == NULL)
			goto newmail;
#ifdef APPEND
		fseek(fbuf, (long)mailsize, SEEK_SET);
		while ((c = getc(fbuf)) != EOF)
			(void)putc(c, rbuf);
#else
		p = minfo.st_size - mailsize;
		while (p-- > 0) {
			c = getc(fbuf);
			if (c == EOF)
				goto newmail;
			(void)putc(c, rbuf);
		}
#endif
		(void)Fclose(rbuf);
		if ((rbuf = Fopen(tempname, "r")) == NULL)
			goto newmail;
		(void)rm(tempname);
	}

	/*
	 * Adjust the message flags in each message.
	 */
	anystat = 0;
	autohold = value("hold") != NULL;
	holdbit = autohold ? MPRESERVE : MBOX;
	nohold = MBOX|MSAVED|MDELETED|MPRESERVE;
	if (value("keepsave") != NULL)
		nohold &= ~MSAVED;
	for (mp = &message[0]; mp < &message[msgCount]; mp++) {
		if (mp->m_flag & MNEW) {
			mp->m_flag &= ~MNEW;
			mp->m_flag |= MSTATUS;
		}
		if (mp->m_flag & MSTATUS)
			anystat++;
		if ((mp->m_flag & MTOUCH) == 0)
			mp->m_flag |= MPRESERVE;
		if ((mp->m_flag & nohold) == 0)
			mp->m_flag |= holdbit;
	}
	modify = 0;
	for (c = 0, p = 0, mp = &message[0]; mp < &message[msgCount]; mp++) {
		if (mp->m_flag & MBOX)
			c++;
		if (mp->m_flag & MPRESERVE)
			p++;
		if (mp->m_flag & MODIFY)
			modify++;
	}
	if (p == msgCount && !modify && !anystat) {
		printf("Held %d message%s in %s\n",
			p, p == 1 ? "" : "s", mailname);
		(void)Fclose(fbuf);
		spool_unlock();
		return(0);
	}
	if (c == 0) {
		if (p != 0) {
			writeback(rbuf);
			(void)Fclose(fbuf);
			spool_unlock();
			return(0);
		}
		goto cream;
	}

	/*
	 * Create another temporary file and copy user's mbox file
	 * darin.  If there is no mbox, copy nothing.
	 * If he has specified "append" don't copy his mailbox,
	 * just copy saveable entries at the end.
	 */
	mbox = expand("&");
	mcount = c;
	if (value("append") == NULL) {
		int fdx;

		(void)snprintf(tempname, sizeof(tempname),
		    "%s/mail.RmXXXXXXXXXX", tmpdir);
		if ((fd = mkstemp(tempname)) == -1 ||
		    (obuf = Fdopen(fd, "w")) == NULL) {
			warn("%s", tempname);
			(void)Fclose(fbuf);
			spool_unlock();
			return(-1);
		}
		if ((ibuf = Fopen(tempname, "r")) == NULL) {
			warn("%s", tempname);
			(void)rm(tempname);
			(void)Fclose(obuf);
			(void)Fclose(fbuf);
			spool_unlock();
			return(-1);
		}
		(void)rm(tempname);
		if ((abuf = Fopen(mbox, "r")) != NULL) {
			while ((c = getc(abuf)) != EOF)
				(void)putc(c, obuf);
			(void)Fclose(abuf);
		}
		if (ferror(obuf)) {
			warn("%s", tempname);
			(void)Fclose(ibuf);
			(void)Fclose(obuf);
			(void)Fclose(fbuf);
			spool_unlock();
			return(-1);
		}
		(void)Fclose(obuf);
		if ((fdx = open(mbox, O_CREAT | O_TRUNC | O_WRONLY, 0600)) != -1)
			close(fdx);
		if ((obuf = Fopen(mbox, "r+")) == NULL) {
			warn("%s", mbox);
			(void)Fclose(ibuf);
			(void)Fclose(fbuf);
			spool_unlock();
			return(-1);
		}
	} else {
		if ((obuf = Fopen(mbox, "a")) == NULL) {
			warn("%s", mbox);
			(void)Fclose(fbuf);
			spool_unlock();
			return(-1);
		}
		fchmod(fileno(obuf), 0600);
	}
	for (mp = &message[0]; mp < &message[msgCount]; mp++)
		if (mp->m_flag & MBOX)
			if (sendmessage(mp, obuf, saveignore, NULL) < 0) {
				warn("%s", mbox);
				(void)Fclose(ibuf);
				(void)Fclose(obuf);
				(void)Fclose(fbuf);
				spool_unlock();
				return(-1);
			}

	/*
	 * Copy the user's old mbox contents back
	 * to the end of the stuff we just saved.
	 * If we are appending, this is unnecessary.
	 */
	if (value("append") == NULL) {
		rewind(ibuf);
		c = getc(ibuf);
		while (c != EOF) {
			(void)putc(c, obuf);
			if (ferror(obuf))
				break;
			c = getc(ibuf);
		}
		(void)Fclose(ibuf);
		fflush(obuf);
	}
	trunc(obuf);
	if (ferror(obuf)) {
		warn("%s", mbox);
		(void)Fclose(obuf);
		(void)Fclose(fbuf);
		spool_unlock();
		return(-1);
	}
	(void)Fclose(obuf);
	if (mcount == 1)
		puts("Saved 1 message in mbox");
	else
		printf("Saved %d messages in mbox\n", mcount);

	/*
	 * Now we are ready to copy back preserved files to
	 * the system mailbox, if any were requested.
	 */
	if (p != 0) {
		writeback(rbuf);
		(void)Fclose(fbuf);
		spool_unlock();
		return(0);
	}

	/*
	 * Finally, remove his /var/mail file.
	 * If new mail has arrived, copy it back.
	 */
cream:
	if (rbuf != NULL) {
		abuf = Fopen(mailname, "r+");
		if (abuf == NULL)
			goto newmail;
		while ((c = getc(rbuf)) != EOF)
			(void)putc(c, abuf);
		(void)Fclose(rbuf);
		trunc(abuf);
		(void)Fclose(abuf);
		alter(mailname);
		(void)Fclose(fbuf);
		spool_unlock();
		return(0);
	}
	demail();
	(void)Fclose(fbuf);
	spool_unlock();
	return(0);

newmail:
	puts("Thou hast new mail.");
	if (fbuf != NULL) {
		(void)Fclose(fbuf);
		spool_unlock();
	}
	return(0);
}

/*
 * Preserve all the appropriate messages back in the system
 * mailbox, and print a nice message indicated how many were
 * saved.  On any error, just return -1.  Else return 0.
 * Incorporate the any new mail that we found.
 */
int
writeback(FILE *res)
{
	struct message *mp;
	int p, c;
	FILE *obuf;

	p = 0;
	if ((obuf = Fopen(mailname, "r+")) == NULL) {
		warn("%s", mailname);
		return(-1);
	}
#ifndef APPEND
	if (res != NULL)
		while ((c = getc(res)) != EOF)
			(void)putc(c, obuf);
#endif
	for (mp = &message[0]; mp < &message[msgCount]; mp++)
		if ((mp->m_flag&MPRESERVE)||(mp->m_flag&MTOUCH)==0) {
			p++;
			if (sendmessage(mp, obuf, NULL, NULL) < 0) {
				warn("%s", mailname);
				(void)Fclose(obuf);
				return(-1);
			}
		}
#ifdef APPEND
	if (res != NULL)
		while ((c = getc(res)) != EOF)
			(void)putc(c, obuf);
#endif
	fflush(obuf);
	trunc(obuf);
	if (ferror(obuf)) {
		warn("%s", mailname);
		(void)Fclose(obuf);
		return(-1);
	}
	if (res != NULL)
		(void)Fclose(res);
	(void)Fclose(obuf);
	alter(mailname);
	if (p == 1)
		printf("Held 1 message in %s\n", mailname);
	else
		printf("Held %d messages in %s\n", p, mailname);
	return(0);
}

/*
 * Terminate an editing session by attempting to write out the user's
 * file from the temporary.  Save any new stuff appended to the file.
 */
int
edstop(void)
{
	int gotcha, c;
	struct message *mp;
	FILE *obuf, *ibuf;
	struct stat statb;
	char tempname[PATHSIZE];

	if (readonly)
		return(0);
	holdsigs();
	for (mp = &message[0], gotcha = 0; mp < &message[msgCount]; mp++) {
		if (mp->m_flag & MNEW) {
			mp->m_flag &= ~MNEW;
			mp->m_flag |= MSTATUS;
		}
		if (mp->m_flag & (MODIFY|MDELETED|MSTATUS))
			gotcha++;
	}
	if (!gotcha)
		goto done;
	ibuf = NULL;
	if (stat(mailname, &statb) >= 0 && statb.st_size > mailsize) {
		int fd;

		(void)snprintf(tempname, sizeof(tempname), "%s/mbox.XXXXXXXXXX",
		    tmpdir);
		if ((fd = mkstemp(tempname)) == -1 ||
		    (obuf = Fdopen(fd, "w")) == NULL) {
			warn("%s", tempname);
			if (fd != -1)
				close(fd);
			relsesigs();
			return(-1);
		}
		if ((ibuf = Fopen(mailname, "r")) == NULL) {
			warn("%s", mailname);
			(void)Fclose(obuf);
			(void)rm(tempname);
			relsesigs();
			return(-1);
		}
		fseek(ibuf, (long)mailsize, SEEK_SET);
		while ((c = getc(ibuf)) != EOF)
			(void)putc(c, obuf);
		(void)Fclose(ibuf);
		(void)Fclose(obuf);
		if ((ibuf = Fopen(tempname, "r")) == NULL) {
			warn("%s", tempname);
			(void)rm(tempname);
			relsesigs();
			return(-1);
		}
		(void)rm(tempname);
	}
	printf("\"%s\" ", mailname);
	fflush(stdout);
	if ((obuf = Fopen(mailname, "r+")) == NULL) {
		warn("%s", mailname);
		relsesigs();
		return(-1);
	}
	trunc(obuf);
	c = 0;
	for (mp = &message[0]; mp < &message[msgCount]; mp++) {
		if ((mp->m_flag & MDELETED) != 0)
			continue;
		c++;
		if (sendmessage(mp, obuf, NULL, NULL) < 0) {
			warn("%s", mailname);
			relsesigs();
			return(-1);
		}
	}
	gotcha = (c == 0 && ibuf == NULL);
	if (ibuf != NULL) {
		while ((c = getc(ibuf)) != EOF)
			(void)putc(c, obuf);
		(void)Fclose(ibuf);
	}
	fflush(obuf);
	if (ferror(obuf)) {
		warn("%s", mailname);
		relsesigs();
		return(-1);
	}
	(void)Fclose(obuf);
	if (gotcha) {
		(void)rm(mailname);
		puts("removed");
	} else
		puts("complete");
	fflush(stdout);

done:
	relsesigs();
	return(0);
}
@


1.22
log
@creat() -> open equiv; from Frederic Nowak
@
text
@d1 1
a1 1
/*	$OpenBSD: quit.c,v 1.21 2014/11/24 20:01:43 millert Exp $	*/
d191 2
d225 2
a226 1
		(void)close(open(mbox, O_CREAT | O_TRUNC | O_WRONLY, 0600));
@


1.21
log
@Remove undocumented and obsolete -T option.  It was intended for
use with old netnews.  OK sobrado@@ tobias@@
@
text
@d1 1
a1 1
/*	$OpenBSD: quit.c,v 1.20 2009/10/27 23:59:40 deraadt Exp $	*/
d223 1
a223 1
		(void)close(creat(mbox, 0600));
@


1.20
log
@rcsid[] and sccsid[] and copyright[] are essentially unmaintained (and
unmaintainable).  these days, people use source.  these id's do not provide
any benefit, and do hurt the small install media
(the 33,000 line diff is essentially mechanical)
ok with the idea millert, ok dms
@
text
@d1 1
a1 1
/*	$OpenBSD: quit.c,v 1.19 2007/09/10 14:29:53 tobias Exp $	*/
d67 1
a67 1
	FILE *ibuf = NULL, *obuf, *fbuf, *rbuf, *readstat = NULL, *abuf;
a156 4
	if (Tflag != NULL) {
		if ((readstat = Fopen(Tflag, "w")) == NULL)
			Tflag = NULL;
	}
a163 6
		if (Tflag != NULL && (mp->m_flag & (MREAD|MDELETED)) != 0) {
			char *id;

			if ((id = hfield("article-id", mp)) != NULL)
				fprintf(readstat, "%s\n", id);
		}
a164 2
	if (Tflag != NULL)
		(void)Fclose(readstat);
d390 1
a390 1
	FILE *obuf, *ibuf, *readstat = NULL;
a396 4
	if (Tflag != NULL) {
		if ((readstat = Fopen(Tflag, "w")) == NULL)
			Tflag = NULL;
	}
a403 6
		if (Tflag != NULL && (mp->m_flag & (MREAD|MDELETED)) != 0) {
			char *id;

			if ((id = hfield("article-id", mp)) != NULL)
				fprintf(readstat, "%s\n", id);
		}
d405 1
a405 3
	if (Tflag != NULL)
		(void)Fclose(readstat);
	if (!gotcha || Tflag != NULL)
@


1.19
log
@Proper use of fseek/fseeko macros.

OK joris@@, otto@@
@
text
@d1 1
a1 1
/*	$OpenBSD: quit.c,v 1.18 2006/02/01 19:01:35 otto Exp $	*/
a31 8

#ifndef lint
#if 0
static const char sccsid[] = "@@(#)quit.c	8.2 (Berkeley) 4/28/95";
#else
static const char rcsid[] = "$OpenBSD: quit.c,v 1.18 2006/02/01 19:01:35 otto Exp $";
#endif
#endif /* not lint */
@


1.18
log
@double semicolon; from Daniel Matic in PR 4929
@
text
@d1 1
a1 1
/*	$OpenBSD: quit.c,v 1.17 2003/06/03 02:56:11 millert Exp $	*/
d37 1
a37 1
static const char rcsid[] = "$OpenBSD: quit.c,v 1.17 2003/06/03 02:56:11 millert Exp $";
d125 1
a125 1
		fseek(fbuf, (long)mailsize, 0);
d460 1
a460 1
		fseek(ibuf, (long)mailsize, 0);
@


1.17
log
@Remove the advertising clause in the UCB license which Berkeley
rescinded 22 July 1999.  Proofed by myself and Theo.
@
text
@d1 1
a1 1
/*	$OpenBSD: quit.c,v 1.16 2001/11/21 15:26:39 millert Exp $	*/
d37 1
a37 1
static const char rcsid[] = "$OpenBSD: quit.c,v 1.16 2001/11/21 15:26:39 millert Exp $";
d335 1
a335 1
	return(0);;
@


1.16
log
@o ANSIfy
o Style nits
o Use const to silent stupid -Wall warnings
o strnc{py,at} -> strlc{py,at}
o Use strpbrk() instead of homegrown anyof()
o Use NULL instead of #defines with 0 cast to a pointer
This still could use a proper audit
@
text
@d1 1
a1 1
/*	$OpenBSD: quit.c,v 1.15 2001/11/20 20:50:00 millert Exp $	*/
d16 1
a16 5
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
d37 1
a37 1
static const char rcsid[] = "$OpenBSD: quit.c,v 1.15 2001/11/20 20:50:00 millert Exp $";
@


1.15
log
@Major signal overhaul.  We no longer longjmp all over the place.
Instead, routines responsible to gathering user input (or in some
cases outputting data) catch the signals and set flags as needed.
Because of this some handlers are install without the SA_RESTART
flag so syscalls are not restarted and we can check the flag.  All
signal handlers are now safe.

This should make the flow of control a bit more grokable but the
code is still ugly.
@
text
@d1 1
a1 1
/*	$OpenBSD: quit.c,v 1.14 2001/01/16 05:36:09 millert Exp $	*/
d39 1
a39 1
static char sccsid[] = "@@(#)quit.c	8.2 (Berkeley) 4/28/95";
d41 1
a41 1
static char rcsid[] = "$OpenBSD: quit.c,v 1.14 2001/01/16 05:36:09 millert Exp $";
d59 1
a59 2
quitcmd(v)
	void *v;
d76 1
a76 1
quit()
d91 1
a107 1

d118 1
a118 1
		return(-1);			/* lockspool printed error for us */
a149 1

a211 1

a279 1

a309 1

a320 1

d357 1
a357 2
writeback(res)
	FILE *res;
d410 1
a410 1
edstop()
d452 2
@


1.14
log
@Changes from Don Beusee:
o escape From line with a leading '>' when needed
o only print To: address and Subject lines if actually present
o new variable 'allnet' to treat user@@foo and user@@bar as the same "user"
o folders command now takes an optional argument like ls.
o new "pipe" (|) command to pipe the message through an arbitrary command
o make header display format the same as SunOS 4.1.3 /usr/ucb/mail
o tilde commands work regardless of interactive mode.
o fix "read: Interrupted system call" error by retrying if EINTR
o expanded help file
Changes by me:
o read the help file via the PAGER as it is now more than 24 lines long
@
text
@d1 1
a1 1
/*	$OpenBSD: quit.c,v 1.13 2000/06/30 16:00:18 millert Exp $	*/
d41 1
a41 1
static char rcsid[] = "$OpenBSD: quit.c,v 1.13 2000/06/30 16:00:18 millert Exp $";
d76 1
a76 1
void
d91 1
a91 1
		return;
d96 2
a97 4
	if (edit) {
		edstop();
		return;
	}
d115 1
a115 1
		return;
d119 1
a119 1
		return;			/* lockspool printed error for us */
d196 1
a196 1
		return;
d203 1
a203 1
			return;
d225 1
a225 1
			return;
d233 1
a233 1
			return;
d247 1
a247 1
			return;
d256 1
a256 1
			return;
d258 1
a258 2
	}
	else {
d263 1
a263 1
			return;
d275 1
a275 1
				return;
d302 1
a302 1
		return;
d319 1
a319 1
		return;
d340 1
a340 1
		return;
d345 1
a345 1
	return;
d353 1
d416 1
a416 1
void
d426 1
a426 1
		return;
d460 1
a460 1
			reset(0);
d467 1
a467 1
			reset(0);
d478 1
a478 1
			reset(0);
d487 1
a487 1
		reset(0);
d498 1
a498 1
			reset(0);
d511 1
a511 1
		reset(0);
d523 1
@


1.13
log
@warnx?/errx? paranoia (use "%s" not a bare string unless it is a
constant).  These are not security holes but it is worth fixing
them anyway both for robustness and so folks looking for examples
in the tree are not misled into doing something potentially dangerous.
Furthermore, it is a bad idea to assume that pathnames will not
include '%' in them and that error routines don't return strings
with '%' in them (especially in light of the possibility of locales).
@
text
@d1 1
a1 1
/*	$OpenBSD: quit.c,v 1.12 2000/04/26 15:47:31 millert Exp $	*/
d41 1
a41 1
static char rcsid[] = "$OpenBSD: quit.c,v 1.12 2000/04/26 15:47:31 millert Exp $";
d111 1
a111 1
	fbuf = Fopen(mailname, "r");
@


1.12
log
@Change the name of mail's send() function to sendmessages() to
avoid shadowing the libc send(2); gadams@@avernus.com
@
text
@d1 1
a1 1
/*	$OpenBSD: quit.c,v 1.11 1998/09/10 16:18:37 millert Exp $	*/
d41 1
a41 1
static char rcsid[] = "$OpenBSD: quit.c,v 1.11 1998/09/10 16:18:37 millert Exp $";
d224 1
a224 1
			warn(tempname);
d230 1
a230 1
			warn(tempname);
d244 1
a244 1
			warn(tempname);
d254 1
a254 1
			warn(mbox);
d263 1
a263 1
			warn(mbox);
d273 1
a273 1
				warn(mbox);
d301 1
a301 1
		warn(mbox);
d374 1
a374 1
		warn(mailname);
d386 1
a386 1
				warn(mailname);
d399 1
a399 1
		warn(mailname);
d460 1
a460 1
			warn(tempname);
d465 1
a465 1
			warn(mailname);
d477 1
a477 1
			warn(tempname);
d487 1
a487 1
		warn(mailname);
d498 1
a498 1
			warn(mailname);
d511 1
a511 1
		warn(mailname);
@


1.12.2.1
log
@Pull in patch from current (even more to come):
Fix (millert):
warnx?/errx? paranoia (use "%s" not a bare string unless it is a
constant).  These are not security holes but it is worth fixing
them anyway both for robustness and so folks looking for examples
in the tree are not misled into doing something potentially dangerous.
Furthermore, it is a bad idea to assume that pathnames will not
include '%' in them and that error routines don't return strings
with '%' in them (especially in light of the possibility of locales).
@
text
@d1 1
a1 1
/*	$OpenBSD: quit.c,v 1.13 2000/06/30 16:00:18 millert Exp $	*/
d41 1
a41 1
static char rcsid[] = "$OpenBSD: quit.c,v 1.13 2000/06/30 16:00:18 millert Exp $";
d224 1
a224 1
			warn("%s", tempname);
d230 1
a230 1
			warn("%s", tempname);
d244 1
a244 1
			warn("%s", tempname);
d254 1
a254 1
			warn("%s", mbox);
d263 1
a263 1
			warn("%s", mbox);
d273 1
a273 1
				warn("%s", mbox);
d301 1
a301 1
		warn("%s", mbox);
d374 1
a374 1
		warn("%s", mailname);
d386 1
a386 1
				warn("%s", mailname);
d399 1
a399 1
		warn("%s", mailname);
d460 1
a460 1
			warn("%s", tempname);
d465 1
a465 1
			warn("%s", mailname);
d477 1
a477 1
			warn("%s", tempname);
d487 1
a487 1
		warn("%s", mailname);
d498 1
a498 1
			warn("%s", mailname);
d511 1
a511 1
		warn("%s", mailname);
@


1.11
log
@Fix comments
@
text
@d1 1
a1 1
/*	$OpenBSD: quit.c,v 1.10 1998/06/12 17:51:52 millert Exp $	*/
d41 1
a41 1
static char rcsid[] = "$OpenBSD: quit.c,v 1.10 1998/06/12 17:51:52 millert Exp $";
d272 1
a272 1
			if (send(mp, obuf, saveignore, NULL) < 0) {
d385 1
a385 1
			if (send(mp, obuf, (struct ignoretab *)0, NULL) < 0) {
d497 1
a497 1
		if (send(mp, obuf, (struct ignoretab *) NULL, NULL) < 0) {
@


1.10
log
@Don't call truncate() directly; have rm() do it if we get EPERM on unlink()
In popen.c, findchild() may return NULL so catch that case.
@
text
@d1 1
a1 1
/*	$OpenBSD: quit.c,v 1.9 1997/11/14 00:23:55 millert Exp $	*/
d41 1
a41 1
static char rcsid[] = "$OpenBSD: quit.c,v 1.9 1997/11/14 00:23:55 millert Exp $";
d121 1
a121 1
		return;			/* mail.local printed error for us */
@


1.9
log
@NetBSD changes (mostly comsmetic):
    replace panic() with calls to err()/errx()
    use S_IS* instead of doing by hand with S_IF*.
    Use TIMESPEC_TO_TIMEVAL() and gettimeofday instead of time(2)
    Use _POSIX_VDISABLE, not 0
    Kill register
@
text
@d1 1
a1 1
/*	$OpenBSD: quit.c,v 1.8 1997/07/24 17:27:12 millert Exp $	*/
d41 1
a41 1
static char rcsid[] = "$OpenBSD: quit.c,v 1.8 1997/07/24 17:27:12 millert Exp $";
d326 1
a326 1
	 * Finally, remove his /usr/mail file.
@


1.8
log
@tempnam(3) goes bye bye.
@
text
@d1 1
a1 1
/*	$OpenBSD: quit.c,v 1.7 1997/07/24 16:23:39 millert Exp $	*/
d41 1
a41 1
static char rcsid[] = "$OpenBSD: quit.c,v 1.7 1997/07/24 16:23:39 millert Exp $";
d81 1
a81 1
	register struct message *mp;
d366 1
a366 1
	register FILE *res;
d368 2
a369 2
	register struct message *mp;
	register int p, c;
d421 2
a422 2
	register int gotcha, c;
	register struct message *mp;
@


1.7
log
@Replace 3 tempnam()'s with mkstemp.  The two left look tricky.
@
text
@d1 1
a1 1
/*	$OpenBSD: quit.c,v 1.6 1997/07/14 00:24:29 millert Exp $	*/
d41 1
a41 1
static char rcsid[] = "$OpenBSD: quit.c,v 1.6 1997/07/14 00:24:29 millert Exp $";
d84 1
a84 1
	char *mbox, tempname[MAXPATHLEN];
d147 1
a147 1
		rm(tempname);
d231 1
a231 1
			rm(tempname);
d237 1
a237 1
		rm(tempname);
d425 1
a425 1
	char tempname[MAXPATHLEN];
d456 1
a456 1
		snprintf(tempname, sizeof(tempname), "%s/mbox.XXXXXXXXXX",
d467 1
a467 1
			rm(tempname);
d478 1
a478 1
			rm(tempname);
d482 1
a482 1
		rm(tempname);
d517 1
a517 1
		rm(mailname);
@


1.6
log
@NOSTR -> NULL
Use sigsetjmp/siglongjmp instead of sigjmp/longjmp for portability.
@
text
@d1 1
a1 1
/*	$OpenBSD: quit.c,v 1.5 1997/07/13 23:54:02 millert Exp $	*/
d41 1
a41 1
static char rcsid[] = "$OpenBSD: quit.c,v 1.5 1997/07/13 23:54:02 millert Exp $";
d82 1
a82 2
	register int c;
	extern char *tempQuit, *tempResid;
d84 1
a84 1
	char *mbox;
d126 4
a129 2
		rbuf = Fopen(tempResid, "w");
		if (rbuf == NULL || fbuf == NULL)
d145 1
a145 1
		if ((rbuf = Fopen(tempResid, "r")) == NULL)
d147 1
a147 1
		rm(tempResid);
d220 5
a224 2
		if ((obuf = Fopen(tempQuit, "w")) == NULL) {
			warn(tempQuit);
d229 3
a231 3
		if ((ibuf = Fopen(tempQuit, "r")) == NULL) {
			warn(tempQuit);
			rm(tempQuit);
d237 1
a237 1
		rm(tempQuit);
d244 1
a244 1
			warn(tempQuit);
a420 1
	extern char *tmpdir;
d456 2
a457 2
		snprintf(tempname, sizeof(tempname), "%s/%s", tmpdir,
		    "mboxXXXXXXXXXX");
@


1.5
log
@bcopy() -> memcpy() and fix some casts.
@
text
@d1 1
a1 1
/*	$OpenBSD: quit.c,v 1.4 1997/07/13 21:21:16 millert Exp $	*/
d41 1
a41 1
static char rcsid[] = "$OpenBSD: quit.c,v 1.4 1997/07/13 21:21:16 millert Exp $";
d154 1
a154 1
	autohold = value("hold") != NOSTR;
d157 1
a157 1
	if (value("keepsave") != NOSTR)
d172 1
a172 1
	if (Tflag != NOSTR) {
d174 1
a174 1
			Tflag = NOSTR;
d183 1
a183 1
		if (Tflag != NOSTR && (mp->m_flag & (MREAD|MDELETED)) != 0) {
d186 1
a186 1
			if ((id = hfield("article-id", mp)) != NOSTR)
d190 1
a190 1
	if (Tflag != NOSTR)
d218 1
a218 1
	if (value("append") == NOSTR) {
d268 1
a268 1
			if (send(mp, obuf, saveignore, NOSTR) < 0) {
d283 1
a283 1
	if (value("append") == NOSTR) {
d381 1
a381 1
			if (send(mp, obuf, (struct ignoretab *)0, NOSTR) < 0) {
d427 1
a427 1
	if (Tflag != NOSTR) {
d429 1
a429 1
			Tflag = NOSTR;
d438 1
a438 1
		if (Tflag != NOSTR && (mp->m_flag & (MREAD|MDELETED)) != 0) {
d441 1
a441 1
			if ((id = hfield("article-id", mp)) != NOSTR)
d445 1
a445 1
	if (Tflag != NOSTR)
d447 1
a447 1
	if (!gotcha || Tflag != NOSTR)
d494 1
a494 1
		if (send(mp, obuf, (struct ignoretab *) NULL, NOSTR) < 0) {
@


1.4
log
@Merge in NetBSD and 4.4BSD-lite2 changes as well as some of my own.
 - handle long lines safely (from NetBSD)
 - use puts/fputs and putchar/putc when it makes sense
 - use err/errx and warn/warnx when it makes sense
 - make return() and sizeof() style consisten
 - some more buffer safety
@
text
@d1 1
a1 1
/*	$OpenBSD: quit.c,v 1.3 1997/03/29 03:01:47 millert Exp $	*/
d41 1
a41 1
static char rcsid[] = "$OpenBSD: quit.c,v 1.3 1997/03/29 03:01:47 millert Exp $";
d133 1
a133 1
			(void) putc(c, rbuf);
d140 1
a140 1
			(void) putc(c, rbuf);
d236 1
a236 1
				(void) putc(c, obuf);
d287 1
a287 1
			(void) putc(c, obuf);
d332 1
a332 1
			(void) putc(c, abuf);
d376 1
a376 1
			(void) putc(c, obuf);
d390 1
a390 1
			(void) putc(c, obuf);
d470 1
a470 1
			(void) putc(c, obuf);
d503 1
a503 1
			(void) putc(c, obuf);
@


1.3
log
@Use ``mail.local -H'' to do dot locking so we can have mode 755 mail
spool, change an occurrence of tempnam() to mkstemp(), change some
longs and shorts to ints.  Mail is now usable again.
@
text
@d1 2
a2 2
/*	$OpenBSD: quit.c,v 1.2 1996/06/11 12:53:48 deraadt Exp $	*/
/*	$NetBSD: quit.c,v 1.5 1996/06/08 19:48:37 christos Exp $	*/
d39 1
a39 1
static char sccsid[] = "@@(#)quit.c	8.1 (Berkeley) 6/6/93";
d41 1
a41 1
static char rcsid[] = "$OpenBSD: quit.c,v 1.2 1996/06/11 12:53:48 deraadt Exp $";
d67 2
a68 2
		return 1;
	return -1;
d116 2
a117 2
		perror("Unable to lock mailbox");
		Fclose(fbuf);
d121 1
a121 1
		Fclose(fbuf);
d126 1
a126 1
		printf("New mail has arrived.\n");
d143 1
a143 1
		Fclose(rbuf);
d191 1
a191 1
		Fclose(readstat);
d195 1
a195 1
		Fclose(fbuf);
d202 1
a202 1
			Fclose(fbuf);
d220 2
a221 2
			perror(tempQuit);
			Fclose(fbuf);
d226 1
a226 1
			perror(tempQuit);
d228 2
a229 2
			Fclose(obuf);
			Fclose(fbuf);
d237 1
a237 1
			Fclose(abuf);
d240 4
a243 4
			perror(tempQuit);
			Fclose(ibuf);
			Fclose(obuf);
			Fclose(fbuf);
d247 2
a248 2
		Fclose(obuf);
		close(creat(mbox, 0600));
d250 3
a252 3
			perror(mbox);
			Fclose(ibuf);
			Fclose(fbuf);
d259 2
a260 2
			perror(mbox);
			Fclose(fbuf);
d269 4
a272 4
				perror(mbox);
				Fclose(ibuf);
				Fclose(obuf);
				Fclose(fbuf);
d292 1
a292 1
		Fclose(ibuf);
d297 3
a299 3
		perror(mbox);
		Fclose(obuf);
		Fclose(fbuf);
d303 1
a303 1
	Fclose(obuf);
d305 1
a305 1
		printf("Saved 1 message in mbox\n");
d316 1
a316 1
		Fclose(fbuf);
d333 1
a333 1
		Fclose(rbuf);
d335 1
a335 1
		Fclose(abuf);
d337 1
a337 1
		Fclose(fbuf);
d342 1
a342 1
	Fclose(fbuf);
d347 1
a347 1
	printf("Thou hast new mail.\n");
d349 1
a349 1
		Fclose(fbuf);
d370 1
a370 1
		perror(mailname);
d382 2
a383 2
				perror(mailname);
				Fclose(obuf);
d395 2
a396 2
		perror(mailname);
		Fclose(obuf);
d400 2
a401 2
		Fclose(res);
	Fclose(obuf);
d446 1
a446 1
		Fclose(readstat);
d457 1
a457 1
			perror(tempname);
d462 2
a463 2
			perror(mailname);
			Fclose(obuf);
d471 2
a472 2
		Fclose(ibuf);
		Fclose(obuf);
d474 1
a474 1
			perror(tempname);
d484 1
a484 1
		perror(mailname);
d495 1
a495 1
			perror(mailname);
d504 1
a504 1
		Fclose(ibuf);
d508 1
a508 1
		perror(mailname);
d512 1
a512 1
	Fclose(obuf);
d515 1
a515 1
		printf("removed\n");
d517 1
a517 1
		printf("complete\n");
@


1.2
log
@from christos;
- Fix PR/105: Implement dot locking protocol and check return value of flock.
- Fix PR/2247: Don't call unknown users "ubluit". Issue an error message.
- Fix/add prototypes.
- Fix warnings.
- Use POSIX signal mask calls.
@
text
@d1 1
a1 1
/*	$OpenBSD: quit.c,v 1.5 1996/06/08 19:48:37 christos Exp $	*/
d41 1
a41 1
static char rcsid[] = "$OpenBSD: quit.c,v 1.5 1996/06/08 19:48:37 christos Exp $";
a115 1
nolock:
d120 4
a123 2
	if (dot_lock(mailname, 1, stdout, ".") == -1)
		goto nolock;
d196 1
a196 1
		dot_unlock(mailname);
d203 1
a203 1
			dot_unlock(mailname);
d222 1
a222 1
			dot_unlock(mailname);
d230 1
a230 1
			dot_unlock(mailname);
d244 1
a244 1
			dot_unlock(mailname);
d253 1
a253 1
			dot_unlock(mailname);
d261 1
a261 1
			dot_unlock(mailname);
d273 1
a273 1
				dot_unlock(mailname);
d300 1
a300 1
		dot_unlock(mailname);
d317 1
a317 1
		dot_unlock(mailname);
d338 1
a338 1
		dot_unlock(mailname);
d343 1
a343 1
	dot_unlock(mailname);
d350 1
a350 1
		dot_unlock(mailname);
d422 1
a422 1
	char *tempname;
d451 1
a451 1
		tempname = tempnam(tmpdir, "mbox");
d453 4
a456 1
		if ((obuf = Fopen(tempname, "w")) == NULL) {
a479 1
		free(tempname);
@


1.1
log
@Initial revision
@
text
@d1 3
d38 5
a42 2
static char sccsid[] = "from: @@(#)quit.c	8.1 (Berkeley) 6/6/93";
static char rcsid[] = "$Id: quit.c,v 1.4 1994/11/28 20:03:37 jtc Exp $";
d59 2
a60 1
quitcmd()
d80 1
a80 1
	FILE *ibuf, *obuf, *fbuf, *rbuf, *readstat, *abuf;
d115 8
a122 1
	flock(fileno(fbuf), LOCK_EX);
d195 1
d202 1
d221 1
d229 1
d243 1
d252 1
d256 1
a256 1
	if (value("append") != NOSTR) {
d260 1
d272 1
d299 1
d316 1
d337 1
d342 1
d347 1
a347 1
	if (fbuf != NULL)
d349 2
d419 1
a419 1
	FILE *obuf, *ibuf, *readstat;
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@
