head	1.38;
access;
symbols
	OPENBSD_6_2:1.38.0.6
	OPENBSD_6_2_BASE:1.38
	OPENBSD_6_1:1.38.0.8
	OPENBSD_6_1_BASE:1.38
	OPENBSD_6_0:1.38.0.4
	OPENBSD_6_0_BASE:1.38
	OPENBSD_5_9:1.38.0.2
	OPENBSD_5_9_BASE:1.38
	OPENBSD_5_8:1.37.0.6
	OPENBSD_5_8_BASE:1.37
	OPENBSD_5_7:1.37.0.2
	OPENBSD_5_7_BASE:1.37
	OPENBSD_5_6:1.36.0.8
	OPENBSD_5_6_BASE:1.36
	OPENBSD_5_5:1.36.0.6
	OPENBSD_5_5_BASE:1.36
	OPENBSD_5_4:1.36.0.2
	OPENBSD_5_4_BASE:1.36
	OPENBSD_5_3:1.35.0.14
	OPENBSD_5_3_BASE:1.35
	OPENBSD_5_2:1.35.0.12
	OPENBSD_5_2_BASE:1.35
	OPENBSD_5_1_BASE:1.35
	OPENBSD_5_1:1.35.0.10
	OPENBSD_5_0:1.35.0.8
	OPENBSD_5_0_BASE:1.35
	OPENBSD_4_9:1.35.0.6
	OPENBSD_4_9_BASE:1.35
	OPENBSD_4_8:1.35.0.4
	OPENBSD_4_8_BASE:1.35
	OPENBSD_4_7:1.35.0.2
	OPENBSD_4_7_BASE:1.35
	OPENBSD_4_6:1.34.0.22
	OPENBSD_4_6_BASE:1.34
	OPENBSD_4_5:1.34.0.18
	OPENBSD_4_5_BASE:1.34
	OPENBSD_4_4:1.34.0.16
	OPENBSD_4_4_BASE:1.34
	OPENBSD_4_3:1.34.0.14
	OPENBSD_4_3_BASE:1.34
	OPENBSD_4_2:1.34.0.12
	OPENBSD_4_2_BASE:1.34
	OPENBSD_4_1:1.34.0.10
	OPENBSD_4_1_BASE:1.34
	OPENBSD_4_0:1.34.0.8
	OPENBSD_4_0_BASE:1.34
	OPENBSD_3_9:1.34.0.6
	OPENBSD_3_9_BASE:1.34
	OPENBSD_3_8:1.34.0.4
	OPENBSD_3_8_BASE:1.34
	OPENBSD_3_7:1.34.0.2
	OPENBSD_3_7_BASE:1.34
	OPENBSD_3_6:1.33.0.6
	OPENBSD_3_6_BASE:1.33
	OPENBSD_3_5:1.33.0.4
	OPENBSD_3_5_BASE:1.33
	OPENBSD_3_4:1.33.0.2
	OPENBSD_3_4_BASE:1.33
	OPENBSD_3_3:1.32.0.4
	OPENBSD_3_3_BASE:1.32
	OPENBSD_3_2:1.32.0.2
	OPENBSD_3_2_BASE:1.32
	OPENBSD_3_1:1.31.0.2
	OPENBSD_3_1_BASE:1.31
	OPENBSD_3_0:1.27.0.2
	OPENBSD_3_0_BASE:1.27
	OPENBSD_2_9_BASE:1.26
	OPENBSD_2_9:1.26.0.2
	OPENBSD_2_8:1.24.0.2
	OPENBSD_2_8_BASE:1.24
	OPENBSD_2_7:1.23.0.8
	OPENBSD_2_7_BASE:1.23
	OPENBSD_2_6:1.23.0.6
	OPENBSD_2_6_BASE:1.23
	OPENBSD_2_5:1.23.0.4
	OPENBSD_2_5_BASE:1.23
	OPENBSD_2_4:1.23.0.2
	OPENBSD_2_4_BASE:1.23
	OPENBSD_2_3:1.15.0.2
	OPENBSD_2_3_BASE:1.15
	OPENBSD_2_2:1.13.0.2
	OPENBSD_2_2_BASE:1.13
	OPENBSD_2_1:1.4.0.2
	OPENBSD_2_1_BASE:1.4
	OPENBSD_2_0:1.3.0.2
	OPENBSD_2_0_BASE:1.3
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.38
date	2015.10.16.17.56.07;	author mmcc;	state Exp;
branches;
next	1.37;
commitid	y3aqfd1wS5RZj9kl;

1.37
date	2015.01.16.06.40.09;	author deraadt;	state Exp;
branches;
next	1.36;
commitid	Uu5nFG3wCl0LACBb;

1.36
date	2013.04.29.00.28.23;	author okan;	state Exp;
branches;
next	1.35;

1.35
date	2009.10.27.23.59.40;	author deraadt;	state Exp;
branches;
next	1.34;

1.34
date	2004.09.15.22.21.11;	author deraadt;	state Exp;
branches;
next	1.33;

1.33
date	2003.06.03.02.56.11;	author millert;	state Exp;
branches;
next	1.32;

1.32
date	2002.06.12.06.07.15;	author mpech;	state Exp;
branches;
next	1.31;

1.31
date	2001.11.23.00.03.24;	author millert;	state Exp;
branches;
next	1.30;

1.30
date	2001.11.21.20.41.55;	author millert;	state Exp;
branches;
next	1.29;

1.29
date	2001.11.21.15.26.39;	author millert;	state Exp;
branches;
next	1.28;

1.28
date	2001.11.20.23.19.44;	author millert;	state Exp;
branches;
next	1.27;

1.27
date	2001.09.04.23.16.11;	author millert;	state Exp;
branches;
next	1.26;

1.26
date	2001.01.19.04.11.29;	author millert;	state Exp;
branches;
next	1.25;

1.25
date	2001.01.16.05.36.08;	author millert;	state Exp;
branches;
next	1.24;

1.24
date	2000.06.30.16.00.18;	author millert;	state Exp;
branches;
next	1.23;

1.23
date	98.09.27.21.16.42;	author millert;	state Exp;
branches
	1.23.8.1;
next	1.22;

1.22
date	98.09.10.16.18.37;	author millert;	state Exp;
branches;
next	1.21;

1.21
date	98.09.10.16.06.40;	author millert;	state Exp;
branches;
next	1.20;

1.20
date	98.09.08.15.24.38;	author millert;	state Exp;
branches;
next	1.19;

1.19
date	98.08.15.23.17.24;	author millert;	state Exp;
branches;
next	1.18;

1.18
date	98.06.12.18.07.58;	author millert;	state Exp;
branches;
next	1.17;

1.17
date	98.06.12.17.51.53;	author millert;	state Exp;
branches;
next	1.16;

1.16
date	98.05.04.05.37.52;	author millert;	state Exp;
branches;
next	1.15;

1.15
date	98.02.15.21.20.02;	author niklas;	state Exp;
branches;
next	1.14;

1.14
date	97.11.14.00.23.54;	author millert;	state Exp;
branches;
next	1.13;

1.13
date	97.08.31.14.32.14;	author millert;	state Exp;
branches;
next	1.12;

1.12
date	97.08.05.04.00.00;	author deraadt;	state Exp;
branches;
next	1.11;

1.11
date	97.08.04.19.25.50;	author deraadt;	state Exp;
branches;
next	1.10;

1.10
date	97.07.14.16.09.07;	author millert;	state Exp;
branches;
next	1.9;

1.9
date	97.07.14.15.56.24;	author millert;	state Exp;
branches;
next	1.8;

1.8
date	97.07.14.00.24.29;	author millert;	state Exp;
branches;
next	1.7;

1.7
date	97.07.13.23.54.01;	author millert;	state Exp;
branches;
next	1.6;

1.6
date	97.07.13.21.21.15;	author millert;	state Exp;
branches;
next	1.5;

1.5
date	97.05.30.08.51.43;	author deraadt;	state Exp;
branches;
next	1.4;

1.4
date	97.03.29.03.01.47;	author millert;	state Exp;
branches;
next	1.3;

1.3
date	96.06.26.21.22.34;	author dm;	state Exp;
branches;
next	1.2;

1.2
date	96.06.11.12.53.47;	author deraadt;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.45.39;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.45.39;	author deraadt;	state Exp;
branches;
next	;

1.23.8.1
date	2000.10.06.21.16.14;	author jason;	state Exp;
branches;
next	;


desc
@@


1.38
log
@Modernize allocation by:

 * removing unneeded casts of void* return values
 * replacing varied and creative error messages with the allocation
   function's name
 * replacing errx() with err() so that the errno string is reported

ok beck@@, jung@@, millert@@
@
text
@/*	$OpenBSD: popen.c,v 1.37 2015/01/16 06:40:09 deraadt Exp $	*/
/*	$NetBSD: popen.c,v 1.6 1997/05/13 06:48:42 mikel Exp $	*/

/*
 * Copyright (c) 1980, 1993
 *	The Regents of the University of California.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */

#include "rcv.h"
#include <sys/wait.h>
#include <fcntl.h>
#include <errno.h>
#include <stdarg.h>
#include "extern.h"

#define READ 0
#define WRITE 1

struct fp {
	FILE *fp;
	int pipe;
	pid_t pid;
	struct fp *link;
};
static struct fp *fp_head;

struct child {
	pid_t pid;
	char done;
	char free;
	int status;
	struct child *link;
};
static struct child *child, *child_freelist = NULL;

static struct child *findchild(pid_t, int);
static void delchild(struct child *);
static pid_t file_pid(FILE *);
static int handle_spool_locks(int);

FILE *
Fopen(char *file, char *mode)
{
	FILE *fp;

	if ((fp = fopen(file, mode)) != NULL) {
		register_file(fp, 0, 0);
		(void)fcntl(fileno(fp), F_SETFD, FD_CLOEXEC);
	}
	return(fp);
}

FILE *
Fdopen(int fd, char *mode)
{
	FILE *fp;

	if ((fp = fdopen(fd, mode)) != NULL) {
		register_file(fp, 0, 0);
		(void)fcntl(fileno(fp), F_SETFD, FD_CLOEXEC);
	}
	return(fp);
}

int
Fclose(FILE *fp)
{

	unregister_file(fp);
	return(fclose(fp));
}

FILE *
Popen(char *cmd, char *mode)
{
	int p[2];
	int myside, hisside, fd0, fd1;
	pid_t pid;
	sigset_t nset;
	FILE *fp;

	if (pipe(p) < 0)
		return(NULL);
	(void)fcntl(p[READ], F_SETFD, FD_CLOEXEC);
	(void)fcntl(p[WRITE], F_SETFD, FD_CLOEXEC);
	if (*mode == 'r') {
		myside = p[READ];
		hisside = fd0 = fd1 = p[WRITE];
	} else {
		myside = p[WRITE];
		hisside = fd0 = p[READ];
		fd1 = -1;
	}
	sigemptyset(&nset);
	pid = start_command(value("SHELL"), &nset, fd0, fd1, "-c", cmd, NULL);
	if (pid < 0) {
		(void)close(p[READ]);
		(void)close(p[WRITE]);
		return(NULL);
	}
	(void)close(hisside);
	if ((fp = fdopen(myside, mode)) != NULL)
		register_file(fp, 1, pid);
	return(fp);
}

int
Pclose(FILE *ptr)
{
	int i;
	sigset_t nset, oset;

	i = file_pid(ptr);
	unregister_file(ptr);
	(void)fclose(ptr);
	sigemptyset(&nset);
	sigaddset(&nset, SIGINT);
	sigaddset(&nset, SIGHUP);
	sigprocmask(SIG_BLOCK, &nset, &oset);
	i = wait_child(i);
	sigprocmask(SIG_SETMASK, &oset, NULL);
	return(i);
}

void
close_all_files(void)
{

	while (fp_head)
		if (fp_head->pipe)
			(void)Pclose(fp_head->fp);
		else
			(void)Fclose(fp_head->fp);
}

void
register_file(FILE *fp, int pipe, pid_t pid)
{
	struct fp *fpp;

	if ((fpp = malloc(sizeof(*fpp))) == NULL)
		err(1, "malloc");
	fpp->fp = fp;
	fpp->pipe = pipe;
	fpp->pid = pid;
	fpp->link = fp_head;
	fp_head = fpp;
}

void
unregister_file(FILE *fp)
{
	struct fp **pp, *p;

	for (pp = &fp_head; (p = *pp) != NULL; pp = &p->link)
		if (p->fp == fp) {
			*pp = p->link;
			(void)free(p);
			return;
		}
	errx(1, "Invalid file pointer");
}

static pid_t
file_pid(FILE *fp)
{
	struct fp *p;

	for (p = fp_head; p; p = p->link)
		if (p->fp == fp)
			return(p->pid);
	errx(1, "Invalid file pointer");
	/*NOTREACHED*/
}

/*
 * Run a command without a shell, with optional arguments and splicing
 * of stdin (-1 means none) and stdout.  The command name can be a sequence
 * of words.
 * Signals must be handled by the caller.
 * "nset" contains the signals to ignore in the new process.
 * SIGINT is enabled unless it's in "nset".
 */
pid_t
start_commandv(char *cmd, sigset_t *nset, int infd, int outfd, va_list args)
{
	pid_t pid;

	if ((pid = fork()) < 0) {
		warn("fork");
		return(-1);
	}
	if (pid == 0) {
		char *argv[100];
		int i = getrawlist(cmd, argv, sizeof(argv)/ sizeof(*argv));

		while ((argv[i++] = va_arg(args, char *)))
			;
		argv[i] = NULL;
		prepare_child(nset, infd, outfd);
		execvp(argv[0], argv);
		warn("%s", argv[0]);
		_exit(1);
	}
	return(pid);
}

int
run_command(char *cmd, sigset_t *nset, int infd, int outfd, ...)
{
	pid_t pid;
	va_list args;

	va_start(args, outfd);
	pid = start_commandv(cmd, nset, infd, outfd, args);
	va_end(args);
	if (pid < 0)
		return(-1);
	return(wait_command(pid));
}

int
start_command(char *cmd, sigset_t *nset, int infd, int outfd, ...)
{
	va_list args;
	int r;

	va_start(args, outfd);
	r = start_commandv(cmd, nset, infd, outfd, args);
	va_end(args);
	return(r);
}

void
prepare_child(sigset_t *nset, int infd, int outfd)
{
	int i;
	sigset_t eset;

	/*
	 * All file descriptors other than 0, 1, and 2 are supposed to be
	 * close-on-exec.
	 */
	if (infd > 0) {
		dup2(infd, 0);
	} else if (infd != 0) {
		/* we don't want the child stealing my stdin input */
		close(0);
		open(_PATH_DEVNULL, O_RDONLY, 0);
	}
	if (outfd >= 0 && outfd != 1)
		dup2(outfd, 1);
	if (nset == NULL)
		return;
	if (nset != NULL) {
		for (i = 1; i < NSIG; i++)
			if (sigismember(nset, i))
				(void)signal(i, SIG_IGN);
	}
	if (nset == NULL || !sigismember(nset, SIGINT))
		(void)signal(SIGINT, SIG_DFL);
	sigemptyset(&eset);
	(void)sigprocmask(SIG_SETMASK, &eset, NULL);
}

int
wait_command(pid_t pid)
{

	if (wait_child(pid) < 0) {
		puts("Fatal error in process.");
		return(-1);
	}
	return(0);
}

static struct child *
findchild(pid_t pid, int dont_alloc)
{
	struct child **cpp;

	for (cpp = &child; *cpp != NULL && (*cpp)->pid != pid;
	     cpp = &(*cpp)->link)
			;
	if (*cpp == NULL) {
		if (dont_alloc)
			return(NULL);
		if (child_freelist) {
			*cpp = child_freelist;
			child_freelist = (*cpp)->link;
		} else {
			*cpp = malloc(sizeof(struct child));
			if (*cpp == NULL)
				err(1, "malloc");
		}
		(*cpp)->pid = pid;
		(*cpp)->done = (*cpp)->free = 0;
		(*cpp)->link = NULL;
	}
	return(*cpp);
}

static void
delchild(struct child *cp)
{
	struct child **cpp;

	for (cpp = &child; *cpp != cp; cpp = &(*cpp)->link)
		;
	*cpp = cp->link;
	cp->link = child_freelist;
	child_freelist = cp;
}

/* ARGSUSED */
void
sigchild(int signo)
{
	pid_t pid;
	int status;
	struct child *cp;
	int save_errno = errno;

	while ((pid = waitpid((pid_t)-1, &status, WNOHANG)) > 0) {
		cp = findchild(pid, 1);
		if (!cp)
			continue;
		if (cp->free)
			delchild(cp);
		else {
			cp->done = 1;
			cp->status = status;
		}
	}
	errno = save_errno;
}

int wait_status;

/*
 * Wait for a specific child to die.
 */
int
wait_child(pid_t pid)
{
	struct child *cp;
	sigset_t nset, oset;
	pid_t rv = 0;

	sigemptyset(&nset);
	sigaddset(&nset, SIGCHLD);
	sigprocmask(SIG_BLOCK, &nset, &oset);
	/*
	 * If we have not already waited on the pid (via sigchild)
	 * wait on it now.  Otherwise, use the wait status stashed
	 * by sigchild.
	 */
	cp = findchild(pid, 1);
	if (cp == NULL || !cp->done)
		rv = waitpid(pid, &wait_status, 0);
	else
		wait_status = cp->status;
	if (cp != NULL)
		delchild(cp);
	sigprocmask(SIG_SETMASK, &oset, NULL);
	if (rv == -1 || (WIFEXITED(wait_status) && WEXITSTATUS(wait_status)))
		return(-1);
	else
		return(0);
}

/*
 * Mark a child as don't care.
 */
void
free_child(pid_t pid)
{
	struct child *cp;
	sigset_t nset, oset;

	sigemptyset(&nset);
	sigaddset(&nset, SIGCHLD);
	sigprocmask(SIG_BLOCK, &nset, &oset);
	if ((cp = findchild(pid, 0)) != NULL) {
		if (cp->done)
			delchild(cp);
		else
			cp->free = 1;
	}
	sigprocmask(SIG_SETMASK, &oset, NULL);
}

/*
 * Lock(1)/unlock(0) mail spool using lockspool(1).
 * Returns 1 for success, 0 for failure, -1 for bad usage.
 */
static int
handle_spool_locks(int action)
{
	static FILE *lockfp = NULL;

	if (action == 0) {
		/* Clear the lock */
		if (lockfp == NULL) {
			fputs("handle_spool_locks: no spool lock to remove.\n",
			    stderr);
			return(-1);
		}
		(void)Pclose(lockfp);
		lockfp = NULL;
	} else if (action == 1) {
		char *cmd;
		char buf[sizeof(_PATH_LOCKSPOOL) + LOGIN_NAME_MAX + 1];

		/* XXX - lockspool requires root for user arg, we do not */
		if (uflag) {
			snprintf(buf, sizeof(buf), "%s %s", _PATH_LOCKSPOOL,
			    myname);
			cmd = buf;
		} else
			cmd = _PATH_LOCKSPOOL;

		/* Create the lock */
		lockfp = Popen(cmd, "r");
		if (lockfp == NULL)
			return(0);
		if (getc(lockfp) != '1') {
			Pclose(lockfp);
			lockfp = NULL;
			return(0);
		}
	} else {
		(void)fprintf(stderr, "handle_spool_locks: unknown action %d\n",
		    action);
		return(-1);
	}

	return(1);
}

int
spool_lock(void)
{

	return(handle_spool_locks(1));
}

int
spool_unlock(void)
{

	return(handle_spool_locks(0));
}
@


1.37
log
@Replace <sys/param.h> with <limits.h> and other less dirty headers where
possible.  Annotate <sys/param.h> lines with their current reasons.  Switch
to PATH_MAX, NGROUPS_MAX, HOST_NAME_MAX+1, LOGIN_NAME_MAX, etc.  Change
MIN() and MAX() to local definitions of MINIMUM() and MAXIMUM() where
sensible to avoid pulling in the pollution.  These are the files confirmed
through binary verification.
ok guenther, millert, doug (helped with the verification protocol)
@
text
@d1 1
a1 1
/*	$OpenBSD: popen.c,v 1.36 2013/04/29 00:28:23 okan Exp $	*/
d165 2
a166 2
	if ((fpp = (struct fp *)malloc(sizeof(*fpp))) == NULL)
		errx(1, "Out of memory");
d316 1
a316 1
			*cpp = (struct child *)malloc(sizeof(struct child));
d318 1
a318 1
				errx(1, "Out of memory");
@


1.36
log
@use FD_CLOEXEC instead of 1; from David Hill

ok otto
@
text
@d1 1
a1 1
/*	$OpenBSD: popen.c,v 1.35 2009/10/27 23:59:40 deraadt Exp $	*/
d437 1
a437 1
		char buf[sizeof(_PATH_LOCKSPOOL) + MAXLOGNAME + 1];
@


1.35
log
@rcsid[] and sccsid[] and copyright[] are essentially unmaintained (and
unmaintainable).  these days, people use source.  these id's do not provide
any benefit, and do hurt the small install media
(the 33,000 line diff is essentially mechanical)
ok with the idea millert, ok dms
@
text
@d1 1
a1 1
/*	$OpenBSD: popen.c,v 1.34 2004/09/15 22:21:11 deraadt Exp $	*/
d72 1
a72 1
		(void)fcntl(fileno(fp), F_SETFD, 1);
d84 1
a84 1
		(void)fcntl(fileno(fp), F_SETFD, 1);
d108 2
a109 2
	(void)fcntl(p[READ], F_SETFD, 1);
	(void)fcntl(p[WRITE], F_SETFD, 1);
@


1.34
log
@unused variable
@
text
@d1 1
a1 1
/*	$OpenBSD: popen.c,v 1.33 2003/06/03 02:56:11 millert Exp $	*/
a31 8

#ifndef lint
#if 0
static const char sccsid[] = "@@(#)popen.c	8.1 (Berkeley) 6/6/93";
#else
static const char rcsid[] = "$OpenBSD: popen.c,v 1.33 2003/06/03 02:56:11 millert Exp $";
#endif
#endif /* not lint */
@


1.33
log
@Remove the advertising clause in the UCB license which Berkeley
rescinded 22 July 1999.  Proofed by myself and Theo.
@
text
@d1 1
a1 1
/*	$OpenBSD: popen.c,v 1.32 2002/06/12 06:07:15 mpech Exp $	*/
d37 1
a37 1
static const char rcsid[] = "$OpenBSD: popen.c,v 1.32 2002/06/12 06:07:15 mpech Exp $";
d347 1
d356 1
a356 2
	while ((pid =
	    waitpid((pid_t)-1, &status, WNOHANG)) > 0) {
a432 1
	static pid_t lock_pid;
a463 1
		lock_pid = fp_head->pid;	/* new entries added at head */
@


1.32
log
@a real pid_t cleanup.

espie@@ ok for make/,
deraadt@@ one extra eye,
millert@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: popen.c,v 1.31 2001/11/23 00:03:24 millert Exp $	*/
d16 1
a16 5
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
d37 1
a37 1
static const char rcsid[] = "$OpenBSD: popen.c,v 1.31 2001/11/23 00:03:24 millert Exp $";
@


1.31
log
@Revert change to Popen() to only wrap command in a shell if it
contains meta characters since people may expect their aliases to
work.
Instead, just remove the "kill(lock_pid, SIGTERM);" since lockspool
now does the right thing when the pipe is closed.
@
text
@d1 1
a1 1
/*	$OpenBSD: popen.c,v 1.30 2001/11/21 20:41:55 millert Exp $	*/
d41 1
a41 1
static const char rcsid[] = "$OpenBSD: popen.c,v 1.30 2001/11/21 20:41:55 millert Exp $";
d384 1
a384 1
	int rv = 0;
@


1.30
log
@o kill strcpy()
o check return values of malloc and friends
o use strdup() when sensible
@
text
@d1 1
a1 1
/*	$OpenBSD: popen.c,v 1.29 2001/11/21 15:26:39 millert Exp $	*/
d41 1
a41 1
static const char rcsid[] = "$OpenBSD: popen.c,v 1.29 2001/11/21 15:26:39 millert Exp $";
d131 1
a131 8
	/*
	 * If cmd contains meta chars wrap it in a shell.
	 */
	if (strpbrk(cmd, "$&*(){}[]'\";\\|?<>~`"))
		pid = start_command(value("SHELL"), &nset, fd0, fd1,
		    "-c", cmd, NULL);
	else
		pid = start_command(cmd, &nset, fd0, fd1, NULL);
a445 1
		(void)kill(lock_pid, SIGTERM);
@


1.29
log
@o ANSIfy
o Style nits
o Use const to silent stupid -Wall warnings
o strnc{py,at} -> strlc{py,at}
o Use strpbrk() instead of homegrown anyof()
o Use NULL instead of #defines with 0 cast to a pointer
This still could use a proper audit
@
text
@d1 1
a1 1
/*	$OpenBSD: popen.c,v 1.28 2001/11/20 23:19:44 millert Exp $	*/
d41 1
a41 1
static const char rcsid[] = "$OpenBSD: popen.c,v 1.28 2001/11/20 23:19:44 millert Exp $";
d334 1
a334 1
		} else
d336 3
@


1.28
log
@In private version of popen(), only wrap a command to be run in a
shell if it contains meta chars.  Sneaky hack to work around a ksh
bug.
@
text
@d1 1
a1 1
/*	$OpenBSD: popen.c,v 1.27 2001/09/04 23:16:11 millert Exp $	*/
d39 1
a39 1
static char sccsid[] = "@@(#)popen.c	8.1 (Berkeley) 6/6/93";
d41 1
a41 1
static char rcsid[] = "$OpenBSD: popen.c,v 1.27 2001/09/04 23:16:11 millert Exp $";
a48 1
#ifdef __STDC__
a49 3
#else
#include <varargs.h>
#endif
d58 1
a58 1
	int pid;
d64 1
a64 1
	int pid;
d71 5
a75 4
static struct child *findchild __P((int, int));
static void delchild __P((struct child *));
static int file_pid __P((FILE *));
static int handle_spool_locks __P((int));
d78 1
a78 2
Fopen(file, mode)
	char *file, *mode;
d90 1
a90 3
Fdopen(fd, mode)
	int fd;
	char *mode;
d102 1
a102 2
Fclose(fp)
	FILE *fp;
d104 1
d110 1
a110 3
Popen(cmd, mode)
	char *cmd;
	char *mode;
d114 1
a114 1
	int pid;
d151 1
a151 2
Pclose(ptr)
	FILE *ptr;
d169 1
a169 1
close_all_files()
d180 1
a180 3
register_file(fp, pipe, pid)
	FILE *fp;
	int pipe, pid;
d194 1
a194 2
unregister_file(fp)
	FILE *fp;
d207 2
a208 3
static int
file_pid(fp)
	FILE *fp;
d227 2
a228 6
int
start_commandv(cmd, nset, infd, outfd, args)
	char *cmd;
	sigset_t *nset;
	int infd, outfd;
	va_list args;
d230 1
a230 1
	int pid;
a251 1
#ifdef __STDC__
a252 8
#else
run_command(cmd, nset, infd, outfd, va_alist)
	char *cmd;
	sigset_t *nset;
	int infd;
	int outfd;
	va_dcl
#endif
d254 1
a254 1
	int pid;
a256 1
#ifdef __STDC__
a257 3
#else
	va_start(args);
#endif
a265 1
#ifdef __STDC__
a266 8
#else
start_command(cmd, nset, infd, outfd, va_alist)
	char *cmd;
	sigset_t *nset;
	int infd;
	int outfd;
	va_dcl
#endif
a270 1
#ifdef __STDC__
a271 3
#else
	va_start(args);
#endif
d278 1
a278 3
prepare_child(nset, infd, outfd)
	sigset_t *nset;
	int infd, outfd;
d310 1
a310 2
wait_command(pid)
	int pid;
d321 1
a321 3
findchild(pid, dont_alloc)
	int pid;
	int dont_alloc;
d344 1
a344 2
delchild(cp)
	struct child *cp;
d356 1
a356 2
sigchild(signo)
	int signo;
d358 1
a358 1
	int pid;
d384 1
a384 2
wait_child(pid)
	int pid;
d416 1
a416 2
free_child(pid)
	int pid;
d438 1
a438 2
handle_spool_locks(action)
	int action;
d441 1
a441 1
	static int lock_pid;
d485 1
a485 1
spool_lock()
d487 1
d492 1
a492 1
spool_unlock()
d494 1
@


1.27
log
@Fix bogus use of snprintf return value.  Since we know the max
length of a username we can use that as part of the buffer size.
@
text
@d1 1
a1 1
/*	$OpenBSD: popen.c,v 1.26 2001/01/19 04:11:29 millert Exp $	*/
d41 1
a41 1
static char rcsid[] = "$OpenBSD: popen.c,v 1.26 2001/01/19 04:11:29 millert Exp $";
d139 9
a147 2
	if ((pid = start_command(value("SHELL"), &nset, fd0, fd1,
						"-c", cmd, NULL)) < 0) {
@


1.26
log
@More fixes from Don Beusee:
- edit and other interactive commands have no stdin (making the
  command completely broken).
- messages with "From " line having date format with -0800 type of timezone
  are not recognized correctly.
@
text
@d1 1
a1 1
/*	$OpenBSD: popen.c,v 1.25 2001/01/16 05:36:08 millert Exp $	*/
d41 1
a41 1
static char rcsid[] = "$OpenBSD: popen.c,v 1.25 2001/01/16 05:36:08 millert Exp $";
d500 2
a501 1
		char cmd[128];
d504 6
a509 2
		if (snprintf(cmd, sizeof(cmd), "%s %s", _PATH_LOCKSPOOL, uflag ? myname : "") < 0)
			errx(1, "Out of memory");
@


1.25
log
@Changes from Don Beusee:
o escape From line with a leading '>' when needed
o only print To: address and Subject lines if actually present
o new variable 'allnet' to treat user@@foo and user@@bar as the same "user"
o folders command now takes an optional argument like ls.
o new "pipe" (|) command to pipe the message through an arbitrary command
o make header display format the same as SunOS 4.1.3 /usr/ucb/mail
o tilde commands work regardless of interactive mode.
o fix "read: Interrupted system call" error by retrying if EINTR
o expanded help file
Changes by me:
o read the help file via the PAGER as it is now more than 24 lines long
@
text
@d1 1
a1 1
/*	$OpenBSD: popen.c,v 1.24 2000/06/30 16:00:18 millert Exp $	*/
d41 1
a41 1
static char rcsid[] = "$OpenBSD: popen.c,v 1.24 2000/06/30 16:00:18 millert Exp $";
d227 2
a228 1
 * of stdin and stdout.  The command name can be a sequence of words.
d325 1
a325 1
	if (infd >= 0) {
d327 1
a327 1
	} else {
d332 1
a332 1
	if (outfd >= 0)
@


1.24
log
@warnx?/errx? paranoia (use "%s" not a bare string unless it is a
constant).  These are not security holes but it is worth fixing
them anyway both for robustness and so folks looking for examples
in the tree are not misled into doing something potentially dangerous.
Furthermore, it is a bad idea to assume that pathnames will not
include '%' in them and that error routines don't return strings
with '%' in them (especially in light of the possibility of locales).
@
text
@d1 1
a1 1
/*	$OpenBSD: popen.c,v 1.23 1998/09/27 21:16:42 millert Exp $	*/
d41 1
a41 1
static char rcsid[] = "$OpenBSD: popen.c,v 1.23 1998/09/27 21:16:42 millert Exp $";
d49 5
d132 1
a132 2
		fd0 = -1;
		hisside = fd1 = p[WRITE];
d139 2
a140 1
	if ((pid = start_command(cmd, &nset, fd0, fd1, NULL, NULL, NULL)) < 0) {
a231 1
/*VARARGS4*/
d233 1
a233 1
run_command(cmd, nset, infd, outfd, a0, a1, a2)
d237 1
a237 1
	char *a0, *a1, *a2;
d241 1
a241 16
	if ((pid = start_command(cmd, nset, infd, outfd, a0, a1, a2)) < 0)
		return(-1);
	return(wait_command(pid));
}

/*VARARGS4*/
int
start_command(cmd, nset, infd, outfd, a0, a1, a2)
	char *cmd;
	sigset_t *nset;
	int infd, outfd;
	char *a0, *a1, *a2;
{
	int pid;

	if ((pid = vfork()) < 0) {
d249 3
a251 4
		if ((argv[i++] = a0) != NULL &&
		    (argv[i++] = a1) != NULL &&
		    (argv[i++] = a2) != NULL)
			argv[i] = NULL;
d260 52
d324 1
a324 1
	if (infd >= 0)
d326 5
d499 1
a499 1
		char *cmd = _PATH_LOCKSPOOL;
d502 1
a502 2
		if (uflag && asprintf(&cmd, "%s %s", _PATH_LOCKSPOOL,
		    myname) == -1)
d507 4
a510 3
		if (uflag)
			free(cmd);
		if (lockfp == NULL || getc(lockfp) != '1') {
@


1.23
log
@Use new username option to lockspool for 'mail -u'.
@
text
@d1 1
a1 1
/*	$OpenBSD: popen.c,v 1.22 1998/09/10 16:18:37 millert Exp $	*/
d41 1
a41 1
static char rcsid[] = "$OpenBSD: popen.c,v 1.22 1998/09/10 16:18:37 millert Exp $";
d266 1
a266 1
		warn(argv[0]);
@


1.23.8.1
log
@Pull in patch from current (even more to come):
Fix (millert):
warnx?/errx? paranoia (use "%s" not a bare string unless it is a
constant).  These are not security holes but it is worth fixing
them anyway both for robustness and so folks looking for examples
in the tree are not misled into doing something potentially dangerous.
Furthermore, it is a bad idea to assume that pathnames will not
include '%' in them and that error routines don't return strings
with '%' in them (especially in light of the possibility of locales).
@
text
@d1 1
a1 1
/*	$OpenBSD: popen.c,v 1.24 2000/06/30 16:00:18 millert Exp $	*/
d41 1
a41 1
static char rcsid[] = "$OpenBSD: popen.c,v 1.24 2000/06/30 16:00:18 millert Exp $";
d266 1
a266 1
		warn("%s", argv[0]);
@


1.22
log
@Fix comments
@
text
@d1 1
a1 1
/*	$OpenBSD: popen.c,v 1.21 1998/09/10 16:06:40 millert Exp $	*/
d41 1
a41 1
static char rcsid[] = "$OpenBSD: popen.c,v 1.21 1998/09/10 16:06:40 millert Exp $";
d454 7
d462 4
a465 2
		if ((lockfp = Popen(_PATH_LOCKSPOOL, "r")) == NULL ||
		    getc(lockfp) != '1') {
a468 1

@


1.21
log
@If a child has not been waited on via the SIGCHLD handler, wait for it
ourselves instead of playing games with sigsuspend.  This may fix PR 588.
@
text
@d1 1
a1 1
/*	$OpenBSD: popen.c,v 1.20 1998/09/08 15:24:38 millert Exp $	*/
d41 1
a41 1
static char rcsid[] = "$OpenBSD: popen.c,v 1.20 1998/09/08 15:24:38 millert Exp $";
d433 1
a433 1
 * Lock(1)/unlock(0) mail spool using mail.local's -H flag.
@


1.20
log
@repair order of signal blocking that got changed in conversion to POSIX signals
@
text
@d1 1
a1 1
/*	$OpenBSD: popen.c,v 1.19 1998/08/15 23:17:24 millert Exp $	*/
d41 1
a41 1
static char rcsid[] = "$OpenBSD: popen.c,v 1.19 1998/08/15 23:17:24 millert Exp $";
d386 1
d391 14
a404 2

	if ((cp = findchild(pid, 0)) == NULL)
d406 2
a407 7

	while (!cp->done)
		sigsuspend(&oset);
	wait_status = cp->status;
	delchild(cp);
	sigprocmask(SIG_SETMASK, &oset, NULL);
	return((WIFEXITED(wait_status) && WEXITSTATUS(wait_status)) ? -1 : 0);
d423 6
a428 8

	if ((cp = findchild(pid, 0)) == NULL)
		return;

	if (cp->done)
		delchild(cp);
	else
		cp->free = 1;
@


1.19
log
@use lockspool for locking, not 'mail.local -H'
@
text
@d1 1
a1 1
/*	$OpenBSD: popen.c,v 1.18 1998/06/12 18:07:58 millert Exp $	*/
d41 1
a41 1
static char rcsid[] = "$OpenBSD: popen.c,v 1.18 1998/06/12 18:07:58 millert Exp $";
d224 2
a225 2
 * "Mask" contains the signals to ignore in the new process.
 * SIGINT is enabled unless it's in the mask.
d384 1
a384 1
	struct child *cp = findchild(pid, 0);
a386 3
	if (cp == NULL)
		return(-1);

d391 3
d409 1
a409 1
	struct child *cp = findchild(pid, 0);
a411 3
	if (cp == NULL)
		return;

d415 3
@


1.18
log
@back out some signal changes that can cause mail to hang when quitting due to SIGCHLD blockage
@
text
@d1 1
a1 1
/*	$OpenBSD: popen.c,v 1.17 1998/06/12 17:51:53 millert Exp $	*/
d41 1
a41 1
static char rcsid[] = "$OpenBSD: popen.c,v 1.17 1998/06/12 17:51:53 millert Exp $";
a433 1
	char *cmd;
d449 2
a450 4
		if ((cmd = (char *)malloc(sizeof(_PATH_MAIL_LOCAL) + 3)) == NULL)
			errx(1, "Out of memory");
		sprintf(cmd, "%s -H", _PATH_MAIL_LOCAL);
		if ((lockfp = Popen(cmd, "r")) == NULL || getc(lockfp) != '1') {
a451 1
			(void)free(cmd);
a455 1
		(void)free(cmd);
d457 1
a457 1
		fprintf(stderr, "handle_spool_locks: unknown action %d\n",
@


1.17
log
@Don't call truncate() directly; have rm() do it if we get EPERM on unlink()
In popen.c, findchild() may return NULL so catch that case.
@
text
@d1 1
a1 1
/*	$OpenBSD: popen.c,v 1.16 1998/05/04 05:37:52 millert Exp $	*/
d41 1
a41 1
static char rcsid[] = "$OpenBSD: popen.c,v 1.16 1998/05/04 05:37:52 millert Exp $";
a358 1
	sigset_t set, oset;
a359 2
	(void)sigfillset(&set);
	(void)sigprocmask(SIG_BLOCK, &set, &oset);
a371 1
	(void)sigprocmask(SIG_SETMASK, &oset, NULL);
@


1.16
log
@Never remove a mail spool, as we may not have proper prics, just truncate.  Also block signals in a few critical areas
@
text
@d1 1
a1 1
/*	$OpenBSD: popen.c,v 1.15 1998/02/15 21:20:02 niklas Exp $	*/
d41 1
a41 1
static char rcsid[] = "$OpenBSD: popen.c,v 1.15 1998/02/15 21:20:02 niklas Exp $";
d391 3
d415 3
@


1.15
log
@Remove one case of malloc call from sighandler
@
text
@d1 1
a1 1
/*	$OpenBSD: popen.c,v 1.14 1997/11/14 00:23:54 millert Exp $	*/
d41 1
a41 1
static char rcsid[] = "$OpenBSD: popen.c,v 1.14 1997/11/14 00:23:54 millert Exp $";
d359 1
d361 2
d375 1
@


1.14
log
@NetBSD changes (mostly comsmetic):
    replace panic() with calls to err()/errx()
    use S_IS* instead of doing by hand with S_IF*.
    Use TIMESPEC_TO_TIMEVAL() and gettimeofday instead of time(2)
    Use _POSIX_VDISABLE, not 0
    Kill register
@
text
@d1 1
a1 1
/*	$OpenBSD: popen.c,v 1.13 1997/08/31 14:32:14 millert Exp $	*/
d41 1
a41 1
static char rcsid[] = "$OpenBSD: popen.c,v 1.13 1997/08/31 14:32:14 millert Exp $";
d69 2
a70 2
static struct child *child;
static struct child *findchild __P((int));
d314 1
a314 1
findchild(pid)
d316 1
d324 7
a330 1
		*cpp = (struct child *)malloc(sizeof(struct child));
d347 2
a348 1
	(void)free(cp);
d362 3
a364 1
		cp = findchild(pid);
d384 1
a384 1
	struct child *cp = findchild(pid);
d406 1
a406 1
	struct child *cp = findchild(pid);
@


1.13
log
@Kill union wait.
@
text
@d1 1
a1 1
/*	$OpenBSD: popen.c,v 1.12 1997/08/05 04:00:00 deraadt Exp $	*/
d41 1
a41 1
static char rcsid[] = "$OpenBSD: popen.c,v 1.12 1997/08/05 04:00:00 deraadt Exp $";
d184 1
a184 1
		panic("Out of memory");
d204 1
a204 1
	panic("Invalid file pointer");
d216 1
a216 1
	panic("Invalid file pointer");
d317 1
a317 1
	register struct child **cpp;
d333 1
a333 1
	register struct child *cp;
d335 1
a335 1
	register struct child **cpp;
d349 1
a349 1
	register struct child *cp;
d374 1
a374 1
	register struct child *cp = findchild(pid);
d396 1
a396 1
	register struct child *cp = findchild(pid);
d435 1
a435 1
			panic("Out of memory");
@


1.12
log
@pull errno.h in
@
text
@d1 1
a1 1
/*	$OpenBSD: popen.c,v 1.11 1997/08/04 19:25:50 deraadt Exp $	*/
d41 1
a41 1
static char rcsid[] = "$OpenBSD: popen.c,v 1.11 1997/08/04 19:25:50 deraadt Exp $";
d66 1
a66 1
	union wait status;
d348 1
a348 1
	union wait status;
d353 1
a353 1
	    wait3((int *)&status, WNOHANG, (struct rusage *)0)) > 0) {
d365 1
a365 1
union wait wait_status;
d386 1
a386 1
	return(wait_status.w_status ? -1 : 0);
@


1.11
log
@save errno in sigchld handlers
@
text
@d1 1
a1 1
/*	$OpenBSD: popen.c,v 1.10 1997/07/14 16:09:07 millert Exp $	*/
d41 1
a41 1
static char rcsid[] = "$OpenBSD: popen.c,v 1.10 1997/07/14 16:09:07 millert Exp $";
d48 1
@


1.10
log
@Don't call it a mask when it is a sigset_t (cosmetic changes only).
@
text
@d1 1
a1 1
/*	$OpenBSD: popen.c,v 1.9 1997/07/14 15:56:24 millert Exp $	*/
d41 1
a41 1
static char rcsid[] = "$OpenBSD: popen.c,v 1.9 1997/07/14 15:56:24 millert Exp $";
d349 1
d361 1
@


1.9
log
@Convert remaining sigsetmask() -> sigprocmask() (POSIX style)
in collect.c and fix up some signal botches elsewhere.
@
text
@d1 1
a1 1
/*	$OpenBSD: popen.c,v 1.8 1997/07/14 00:24:29 millert Exp $	*/
d41 1
a41 1
static char rcsid[] = "$OpenBSD: popen.c,v 1.8 1997/07/14 00:24:29 millert Exp $";
d228 1
a228 1
run_command(cmd, mask, infd, outfd, a0, a1, a2)
d230 1
a230 1
	sigset_t *mask;
d236 1
a236 1
	if ((pid = start_command(cmd, mask, infd, outfd, a0, a1, a2)) < 0)
d243 1
a243 1
start_command(cmd, mask, infd, outfd, a0, a1, a2)
d245 1
a245 1
	sigset_t *mask;
d263 1
a263 1
		prepare_child(mask, infd, outfd);
d371 1
a372 1
	register struct child *cp = findchild(pid);
d393 1
a394 1
	register struct child *cp = findchild(pid);
@


1.8
log
@NOSTR -> NULL
Use sigsetjmp/siglongjmp instead of sigjmp/longjmp for portability.
@
text
@d1 1
a1 1
/*	$OpenBSD: popen.c,v 1.7 1997/07/13 23:54:01 millert Exp $	*/
d41 1
a41 1
static char rcsid[] = "$OpenBSD: popen.c,v 1.7 1997/07/13 23:54:01 millert Exp $";
d277 1
a277 1
	sigset_t fset;
d296 2
a297 2
	sigfillset(&fset);
	(void)sigprocmask(SIG_UNBLOCK, &fset, NULL);
d373 1
d395 1
@


1.7
log
@bcopy() -> memcpy() and fix some casts.
@
text
@d1 1
a1 1
/*	$OpenBSD: popen.c,v 1.6 1997/07/13 21:21:15 millert Exp $	*/
d41 1
a41 1
static char rcsid[] = "$OpenBSD: popen.c,v 1.6 1997/07/13 21:21:15 millert Exp $";
d134 1
a134 1
	if ((pid = start_command(cmd, &nset, fd0, fd1, NOSTR, NOSTR, NOSTR)) < 0) {
d259 4
a262 4
		if ((argv[i++] = a0) != NOSTR &&
		    (argv[i++] = a1) != NOSTR &&
		    (argv[i++] = a2) != NOSTR)
			argv[i] = NOSTR;
@


1.6
log
@Merge in NetBSD and 4.4BSD-lite2 changes as well as some of my own.
 - handle long lines safely (from NetBSD)
 - use puts/fputs and putchar/putc when it makes sense
 - use err/errx and warn/warnx when it makes sense
 - make return() and sizeof() style consisten
 - some more buffer safety
@
text
@d1 1
a1 1
/*	$OpenBSD: popen.c,v 1.5 1997/05/30 08:51:43 deraadt Exp $	*/
d41 1
a41 1
static char rcsid[] = "$OpenBSD: popen.c,v 1.5 1997/05/30 08:51:43 deraadt Exp $";
d82 1
a82 1
		(void) fcntl(fileno(fp), F_SETFD, 1);
d96 1
a96 1
		(void) fcntl(fileno(fp), F_SETFD, 1);
d122 2
a123 2
	(void) fcntl(p[READ], F_SETFD, 1);
	(void) fcntl(p[WRITE], F_SETFD, 1);
d182 1
a182 1
	if ((fpp = (struct fp *) malloc(sizeof(*fpp))) == NULL)
d200 1
a200 1
			free((char *) p);
d292 1
a292 1
				(void) signal(i, SIG_IGN);
d295 1
a295 1
		(void) signal(SIGINT, SIG_DFL);
d297 1
a297 1
	(void) sigprocmask(SIG_UNBLOCK, &fset, NULL);
d322 1
a322 1
		*cpp = (struct child *) malloc(sizeof(struct child));
d339 1
a339 1
	free((char *) cp);
d429 1
a429 1
		if ((cmd = (char *) malloc(sizeof(_PATH_MAIL_LOCAL) + 3)) == NULL)
d434 1
a434 1
			free(cmd);
d439 1
a439 1
		free(cmd);
@


1.5
log
@overflows abound
@
text
@d1 2
a2 2
/*	$OpenBSD: popen.c,v 1.4 1997/03/29 03:01:47 millert Exp $	*/
/*	$NetBSD: popen.c,v 1.4 1996/06/08 19:48:35 christos Exp $	*/
d41 1
a41 1
static char rcsid[] = "$OpenBSD: popen.c,v 1.4 1997/03/29 03:01:47 millert Exp $";
d84 1
a84 1
	return fp;
d98 1
a98 1
	return fp;
d106 1
a106 1
	return fclose(fp);
d121 1
a121 1
		return NULL;
d135 3
a137 3
		close(p[READ]);
		close(p[WRITE]);
		return NULL;
d139 1
a139 1
	(void) close(hisside);
d142 1
a142 1
	return fp;
d154 1
a154 1
	(void) fclose(ptr);
d161 1
a161 1
	return i;
d170 1
a170 1
			(void) Pclose(fp_head->fp);
d172 1
a172 1
			(void) Fclose(fp_head->fp);
d182 1
a182 1
	if ((fpp = (struct fp *) malloc(sizeof *fpp)) == NULL)
d214 1
a214 1
			return (p->pid);
d237 2
a238 2
		return -1;
	return wait_command(pid);
d252 2
a253 2
		perror("fork");
		return -1;
d257 1
a257 1
		int i = getrawlist(cmd, argv, sizeof argv / sizeof *argv);
d265 1
a265 1
		perror(argv[0]);
d268 1
a268 1
	return pid;
d287 3
a289 1
	if (nset) {
a292 2
		if (!sigismember(nset, SIGINT))
			(void) signal(SIGINT, SIG_DFL);
d294 2
d306 2
a307 2
		printf("Fatal error in process.\n");
		return -1;
d309 1
a309 1
	return 0;
d322 1
a322 1
		*cpp = (struct child *) malloc(sizeof (struct child));
d327 1
a327 1
	return *cpp;
d382 1
a382 1
	return wait_status.w_status ? -1 : 0;
d420 3
a422 3
			fprintf(stderr,
			    "handle_spool_locks: no spool lock to remove.\n");
			return (-1);
d425 1
a425 1
		Pclose(lockfp);
d435 1
a435 1
			return (0);
d443 1
a443 1
		return (-1);
d446 1
a446 1
	return (1);
@


1.4
log
@Use ``mail.local -H'' to do dot locking so we can have mode 755 mail
spool, change an occurrence of tempnam() to mkstemp(), change some
longs and shorts to ints.  Mail is now usable again.
@
text
@d1 1
a1 1
/*	$OpenBSD: popen.c,v 1.3 1996/06/26 21:22:34 dm Exp $	*/
d41 1
a41 1
static char rcsid[] = "$OpenBSD: popen.c,v 1.3 1996/06/26 21:22:34 dm Exp $";
d288 1
a288 1
		for (i = 1; i <= NSIG; i++)
@


1.3
log
@Accept NULL nset in prepare child (as run_editor will try to use one).
@
text
@d1 1
a1 1
/*	$OpenBSD: popen.c,v 1.2 1996/06/11 12:53:47 deraadt Exp $	*/
d41 1
a41 1
static char rcsid[] = "$OpenBSD: popen.c,v 1.2 1996/06/11 12:53:47 deraadt Exp $";
d72 1
d401 56
@


1.2
log
@from christos;
- Fix PR/105: Implement dot locking protocol and check return value of flock.
- Fix PR/2247: Don't call unknown users "ubluit". Issue an error message.
- Fix/add prototypes.
- Fix warnings.
- Use POSIX signal mask calls.
@
text
@d1 1
a1 1
/*	$OpenBSD: popen.c,v 1.4 1996/06/08 19:48:35 christos Exp $	*/
d41 1
a41 1
static char rcsid[] = "$OpenBSD: popen.c,v 1.4 1996/06/08 19:48:35 christos Exp $";
d286 7
a292 5
	for (i = 1; i <= NSIG; i++)
		if (sigismember(nset, i))
			(void) signal(i, SIG_IGN);
	if (!sigismember(nset, SIGINT))
		(void) signal(SIGINT, SIG_DFL);
@


1.1
log
@Initial revision
@
text
@d1 3
d38 5
a42 2
static char sccsid[] = "from: @@(#)popen.c	8.1 (Berkeley) 6/6/93";
static char rcsid[] = "$Id: popen.c,v 1.3 1994/06/29 05:09:38 deraadt Exp $";
d71 1
d116 1
d132 2
a133 1
	if ((pid = start_command(cmd, 0, fd0, fd1, NOSTR, NOSTR, NOSTR)) < 0) {
d149 1
a149 1
	int omask;
d154 4
a157 1
	omask = sigblock(sigmask(SIGINT)|sigmask(SIGHUP));
d159 1
a159 1
	sigsetmask(omask);
d196 1
a196 1
	for (pp = &fp_head; p = *pp; pp = &p->link)
d205 1
d229 2
a230 1
	int mask, infd, outfd;
d244 2
a245 1
	int mask, infd, outfd;
d271 3
a273 2
prepare_child(mask, infd, outfd)
	int mask, infd, outfd;
d276 1
d287 1
a287 1
		if (mask & sigmask(i))
d289 1
a289 1
	if ((mask & sigmask(SIGINT)) == 0)
d291 2
a292 1
	(void) sigsetmask(0);
d366 1
a366 1
	int mask = sigblock(sigmask(SIGCHLD));
d368 3
d373 1
a373 1
		sigpause(mask);
d376 1
a376 1
	sigsetmask(mask);
d387 1
a387 1
	int mask = sigblock(sigmask(SIGCHLD));
d389 3
d397 1
a397 1
	sigsetmask(mask);
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@
