head	1.27;
access;
symbols
	OPENBSD_6_2:1.27.0.10
	OPENBSD_6_2_BASE:1.27
	OPENBSD_6_1:1.27.0.8
	OPENBSD_6_1_BASE:1.27
	OPENBSD_6_0:1.27.0.4
	OPENBSD_6_0_BASE:1.27
	OPENBSD_5_9:1.27.0.2
	OPENBSD_5_9_BASE:1.27
	OPENBSD_5_8:1.26.0.6
	OPENBSD_5_8_BASE:1.26
	OPENBSD_5_7:1.26.0.2
	OPENBSD_5_7_BASE:1.26
	OPENBSD_5_6:1.25.0.16
	OPENBSD_5_6_BASE:1.25
	OPENBSD_5_5:1.25.0.14
	OPENBSD_5_5_BASE:1.25
	OPENBSD_5_4:1.25.0.10
	OPENBSD_5_4_BASE:1.25
	OPENBSD_5_3:1.25.0.8
	OPENBSD_5_3_BASE:1.25
	OPENBSD_5_2:1.25.0.6
	OPENBSD_5_2_BASE:1.25
	OPENBSD_5_1_BASE:1.25
	OPENBSD_5_1:1.25.0.4
	OPENBSD_5_0:1.25.0.2
	OPENBSD_5_0_BASE:1.25
	OPENBSD_4_9:1.24.0.6
	OPENBSD_4_9_BASE:1.24
	OPENBSD_4_8:1.24.0.4
	OPENBSD_4_8_BASE:1.24
	OPENBSD_4_7:1.24.0.2
	OPENBSD_4_7_BASE:1.24
	OPENBSD_4_6:1.21.0.8
	OPENBSD_4_6_BASE:1.21
	OPENBSD_4_5:1.21.0.4
	OPENBSD_4_5_BASE:1.21
	OPENBSD_4_4:1.21.0.2
	OPENBSD_4_4_BASE:1.21
	OPENBSD_4_3:1.20.0.20
	OPENBSD_4_3_BASE:1.20
	OPENBSD_4_2:1.20.0.18
	OPENBSD_4_2_BASE:1.20
	OPENBSD_4_1:1.20.0.16
	OPENBSD_4_1_BASE:1.20
	OPENBSD_4_0:1.20.0.14
	OPENBSD_4_0_BASE:1.20
	OPENBSD_3_9:1.20.0.12
	OPENBSD_3_9_BASE:1.20
	OPENBSD_3_8:1.20.0.10
	OPENBSD_3_8_BASE:1.20
	OPENBSD_3_7:1.20.0.8
	OPENBSD_3_7_BASE:1.20
	OPENBSD_3_6:1.20.0.6
	OPENBSD_3_6_BASE:1.20
	OPENBSD_3_5:1.20.0.4
	OPENBSD_3_5_BASE:1.20
	OPENBSD_3_4:1.20.0.2
	OPENBSD_3_4_BASE:1.20
	OPENBSD_3_3:1.19.0.4
	OPENBSD_3_3_BASE:1.19
	OPENBSD_3_2:1.19.0.2
	OPENBSD_3_2_BASE:1.19
	OPENBSD_3_1:1.18.0.2
	OPENBSD_3_1_BASE:1.18
	OPENBSD_3_0:1.15.0.4
	OPENBSD_3_0_BASE:1.15
	OPENBSD_2_9_BASE:1.15
	OPENBSD_2_9:1.15.0.2
	OPENBSD_2_8:1.13.0.2
	OPENBSD_2_8_BASE:1.13
	OPENBSD_2_7:1.11.0.2
	OPENBSD_2_7_BASE:1.11
	OPENBSD_2_6:1.10.0.8
	OPENBSD_2_6_BASE:1.10
	OPENBSD_2_5:1.10.0.6
	OPENBSD_2_5_BASE:1.10
	OPENBSD_2_4:1.10.0.4
	OPENBSD_2_4_BASE:1.10
	OPENBSD_2_3:1.10.0.2
	OPENBSD_2_3_BASE:1.10
	OPENBSD_2_2:1.9.0.2
	OPENBSD_2_2_BASE:1.9
	OPENBSD_2_1:1.3.0.2
	OPENBSD_2_1_BASE:1.3
	OPENBSD_2_0:1.2.0.2
	OPENBSD_2_0_BASE:1.2
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.27
date	2015.10.16.17.56.07;	author mmcc;	state Exp;
branches;
next	1.26;
commitid	y3aqfd1wS5RZj9kl;

1.26
date	2015.01.20.16.59.07;	author millert;	state Exp;
branches;
next	1.25;
commitid	92usC3cTTCZG2qZC;

1.25
date	2011.04.06.11.36.26;	author miod;	state Exp;
branches;
next	1.24;

1.24
date	2009.10.27.23.59.40;	author deraadt;	state Exp;
branches;
next	1.23;

1.23
date	2009.09.05.10.49.45;	author tobias;	state Exp;
branches;
next	1.22;

1.22
date	2009.07.23.20.06.03;	author martynas;	state Exp;
branches;
next	1.21;

1.21
date	2008.07.16.14.53.41;	author martynas;	state Exp;
branches;
next	1.20;

1.20
date	2003.06.03.02.56.11;	author millert;	state Exp;
branches;
next	1.19;

1.19
date	2002.08.12.00.42.56;	author aaron;	state Exp;
branches;
next	1.18;

1.18
date	2001.11.21.20.41.55;	author millert;	state Exp;
branches;
next	1.17;

1.17
date	2001.11.21.15.26.39;	author millert;	state Exp;
branches;
next	1.16;

1.16
date	2001.11.20.20.50.00;	author millert;	state Exp;
branches;
next	1.15;

1.15
date	2001.01.19.04.11.28;	author millert;	state Exp;
branches;
next	1.14;

1.14
date	2001.01.16.05.36.08;	author millert;	state Exp;
branches;
next	1.13;

1.13
date	2000.08.02.04.10.48;	author millert;	state Exp;
branches;
next	1.12;

1.12
date	2000.06.30.16.00.16;	author millert;	state Exp;
branches;
next	1.11;

1.11
date	2000.04.25.16.42.22;	author millert;	state Exp;
branches
	1.11.2.1;
next	1.10;

1.10
date	97.11.14.00.23.44;	author millert;	state Exp;
branches;
next	1.9;

1.9
date	97.07.30.07.19.30;	author millert;	state Exp;
branches;
next	1.8;

1.8
date	97.07.30.06.32.38;	author millert;	state Exp;
branches;
next	1.7;

1.7
date	97.07.14.00.24.25;	author millert;	state Exp;
branches;
next	1.6;

1.6
date	97.07.13.23.53.58;	author millert;	state Exp;
branches;
next	1.5;

1.5
date	97.07.13.21.21.09;	author millert;	state Exp;
branches;
next	1.4;

1.4
date	97.05.30.08.51.35;	author deraadt;	state Exp;
branches;
next	1.3;

1.3
date	97.03.29.03.01.44;	author millert;	state Exp;
branches;
next	1.2;

1.2
date	96.06.11.12.53.34;	author deraadt;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.45.38;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.45.38;	author deraadt;	state Exp;
branches;
next	;

1.11.2.1
date	2000.10.06.21.16.14;	author jason;	state Exp;
branches;
next	;


desc
@@


1.27
log
@Modernize allocation by:

 * removing unneeded casts of void* return values
 * replacing varied and creative error messages with the allocation
   function's name
 * replacing errx() with err() so that the errno string is reported

ok beck@@, jung@@, millert@@
@
text
@/*	$OpenBSD: cmd3.c,v 1.26 2015/01/20 16:59:07 millert Exp $	*/
/*	$NetBSD: cmd3.c,v 1.8 1997/07/09 05:29:49 mikel Exp $	*/

/*
 * Copyright (c) 1980, 1993
 *	The Regents of the University of California.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */

#include "rcv.h"
#include "extern.h"

/*
 * Mail -- a mail program
 *
 * Still more user commands.
 */
static int diction(const void *, const void *);

/*
 * Process a shell escape by saving signals, ignoring signals,
 * and forking a sh -c
 */
int
shell(void *v)
{
	char *str = v;
	char *shell;
	char cmd[BUFSIZ];
	struct sigaction oact;
	sigset_t oset;

	(void)ignoresig(SIGINT, &oact, &oset);
	(void)strlcpy(cmd, str, sizeof(cmd));
	if (bangexp(cmd, sizeof(cmd)) < 0)
		return(1);
	shell = value("SHELL");
	(void)run_command(shell, 0, 0, -1, "-c", cmd, NULL);
	(void)sigprocmask(SIG_SETMASK, &oset, NULL);
	(void)sigaction(SIGINT, &oact, NULL);
	puts("!");
	return(0);
}

/*
 * Fork an interactive shell.
 */
/*ARGSUSED*/
int
dosh(void *v)
{
	char *shell;
	struct sigaction oact;
	sigset_t oset;

	shell = value("SHELL");
	(void)ignoresig(SIGINT, &oact, &oset);
	(void)run_command(shell, 0, 0, -1, NULL, NULL, NULL);
	(void)sigprocmask(SIG_SETMASK, &oset, NULL);
	(void)sigaction(SIGINT, &oact, NULL);
	putchar('\n');
	return(0);
}

/*
 * Expand the shell escape by expanding unescaped !'s into the
 * last issued command where possible.
 */
int
bangexp(char *str, size_t strsize)
{
	char bangbuf[BUFSIZ];
	static char lastbang[BUFSIZ];
	char *cp, *cp2;
	int n, changed = 0;

	cp = str;
	cp2 = bangbuf;
	n = BUFSIZ;
	while (*cp) {
		if (*cp == '!') {
			if (n < strlen(lastbang)) {
overf:
				puts("Command buffer overflow");
				return(-1);
			}
			changed++;
			strlcpy(cp2, lastbang, sizeof(bangbuf) - (cp2 - bangbuf));
			cp2 += strlen(lastbang);
			n -= strlen(lastbang);
			cp++;
			continue;
		}
		if (*cp == '\\' && cp[1] == '!') {
			if (--n <= 1)
				goto overf;
			*cp2++ = '!';
			cp += 2;
			changed++;
		}
		if (--n <= 1)
			goto overf;
		*cp2++ = *cp++;
	}
	*cp2 = 0;
	if (changed) {
		(void)printf("!%s\n", bangbuf);
		(void)fflush(stdout);
	}
	(void)strlcpy(str, bangbuf, strsize);
	(void)strlcpy(lastbang, bangbuf, sizeof(lastbang));
	return(0);
}

/*
 * Print out a nice help message from some file or another.
 */
int
help(void *v)
{

	(void)run_command(value("PAGER"), 0, -1, -1, _PATH_HELP, NULL);
	return(0);
}

/*
 * Change user's working directory.
 */
int
schdir(void *v)
{
	char **arglist = v;
	char *cp;

	if (*arglist == NULL) {
		if (homedir == NULL)
			return(1);
		cp = homedir;
	} else {
		if ((cp = expand(*arglist)) == NULL)
			return(1);
	}
	if (chdir(cp) < 0) {
		warn("%s", cp);
		return(1);
	}
	return(0);
}

int
respond(void *v)
{
	int *msgvec = v;

	if (value("Replyall") == NULL)
		return(_respond(msgvec));
	else
		return(_Respond(msgvec));
}

/*
 * Reply to a list of messages.  Extract each name from the
 * message header and send them off to mail1()
 */
int
_respond(msgvec)
	int *msgvec;
{
	struct message *mp;
	char *cp, *rcv, *replyto;
	char **ap;
	struct name *np;
	struct header head;

	if (msgvec[1] != 0) {
		puts("Sorry, can't reply to multiple messages at once");
		return(1);
	}
	mp = &message[msgvec[0] - 1];
	touch(mp);
	dot = mp;
	if ((rcv = skin(hfield("from", mp))) == NULL)
		rcv = skin(nameof(mp, 1));
	if ((replyto = skin(hfield("reply-to", mp))) != NULL)
		np = extract(replyto, GTO);
	else if ((cp = skin(hfield("to", mp))) != NULL)
		np = extract(cp, GTO);
	else
		np = NULL;
	/*
	 * Delete my name from the reply list,
	 * and with it, all my alternate names.
	 */
	np = delname(np, myname);
	if (altnames)
		for (ap = altnames; *ap; ap++)
			np = delname(np, *ap);
	if (np != NULL && replyto == NULL)
		np = cat(np, extract(rcv, GTO));
	else if (np == NULL) {
		if (replyto != NULL)
			puts("Empty reply-to field -- replying to author");
		np = extract(rcv, GTO);
	}
	np = elide(np);
	head.h_to = np;
	head.h_from = NULL;
	if ((head.h_subject = hfield("subject", mp)) == NULL)
		head.h_subject = hfield("subj", mp);
	head.h_subject = reedit(head.h_subject);
	if (replyto == NULL && (cp = skin(hfield("cc", mp))) != NULL) {
		np = elide(extract(cp, GCC));
		np = delname(np, myname);
		if (altnames != 0)
			for (ap = altnames; *ap; ap++)
				np = delname(np, *ap);
		head.h_cc = np;
	} else
		head.h_cc = NULL;
	head.h_bcc = NULL;
	head.h_smopts = NULL;
	mail1(&head, 1);
	return(0);
}

/*
 * Modify the subject we are replying to to begin with Re: if
 * it does not already.
 */
char *
reedit(char *subj)
{
	char *newsubj;
	size_t len;

	if (subj == NULL)
		return(NULL);
	if (strncasecmp(subj, "re:", 3) == 0)
		return(subj);
	len = strlen(subj) + 5;
	newsubj = salloc(len);
	strlcpy(newsubj, "Re: ", len);
	strlcat(newsubj, subj, len);
	return(newsubj);
}

/*
 * Mark new the named messages, so that they will be left in the system
 * mailbox as unread.
 */
int
marknew(void *v)
{
	int *msgvec = v;
	int *ip;

	for (ip = msgvec; *ip != 0; ip++) {
		dot = &message[*ip-1];
		dot->m_flag &= ~(MBOX|MREAD|MTOUCH);
		dot->m_flag |= MNEW|MSTATUS;
	}
	return(0);
}

/*
 * Preserve the named messages, so that they will be sent
 * back to the system mailbox.
 */
int
preserve(void *v)
{
	int *msgvec = v;
	int *ip, mesg;
	struct message *mp;

	if (edit) {
		puts("Cannot \"preserve\" in edit mode");
		return(1);
	}
	for (ip = msgvec; *ip != 0; ip++) {
		mesg = *ip;
		mp = &message[mesg-1];
		mp->m_flag |= MPRESERVE;
		mp->m_flag &= ~MBOX;
		dot = mp;
	}
	return(0);
}

/*
 * Mark all given messages as unread.
 */
int
unread(void *v)
{
	int *msgvec = v;
	int *ip;

	for (ip = msgvec; *ip != 0; ip++) {
		dot = &message[*ip-1];
		dot->m_flag &= ~(MREAD|MTOUCH);
		dot->m_flag |= MSTATUS;
	}
	return(0);
}

/*
 * Print the size of each message.
 */
int
messize(void *v)
{
	int *msgvec = v;
	struct message *mp;
	int *ip, mesg;

	for (ip = msgvec; *ip != 0; ip++) {
		mesg = *ip;
		mp = &message[mesg-1];
		printf("%d: %d/%d\n", mesg, mp->m_lines, mp->m_size);
	}
	return(0);
}

/*
 * Quit quickly.  If we are sourcing, just pop the input level
 * by returning an error.
 */
int
rexit(void *v)
{

	if (sourcing)
		return(1);
	exit(0);
	/*NOTREACHED*/
}

/*
 * Set or display a variable value.  Syntax is similar to that
 * of csh.
 */
int
set(void *v)
{
	char **arglist = v;
	struct var *vp;
	char *cp, *cp2;
	char varbuf[BUFSIZ], **ap, **p;
	int errs, h, s;

	if (*arglist == NULL) {
		for (h = 0, s = 1; h < HSHSIZE; h++)
			for (vp = variables[h]; vp != NULL; vp = vp->v_link)
				s++;
		ap = (char **)salloc(s * sizeof(*ap));
		for (h = 0, p = ap; h < HSHSIZE; h++)
			for (vp = variables[h]; vp != NULL; vp = vp->v_link)
				*p++ = vp->v_name;
		*p = NULL;
		sort(ap);
		for (p = ap; *p != NULL; p++)
			printf("%s\t%s\n", *p, value(*p));
		return(0);
	}
	errs = 0;
	for (ap = arglist; *ap != NULL; ap++) {
		cp = *ap;
		cp2 = varbuf;
		while (*cp != '=' && *cp != '\0')
			*cp2++ = *cp++;
		*cp2 = '\0';
		if (*cp == '\0')
			cp = "";
		else
			cp++;
		if (equal(varbuf, "")) {
			puts("Non-null variable name required");
			errs++;
			continue;
		}
		assign(varbuf, cp);
	}
	return(errs);
}

/*
 * Unset a bunch of variable values.
 */
int
unset(void *v)
{
	char **arglist = v;
	struct var *vp, *vp2;
	int errs, h;
	char **ap;

	errs = 0;
	for (ap = arglist; *ap != NULL; ap++) {
		if ((vp2 = lookup(*ap)) == NULL) {
			if (!sourcing) {
				printf("\"%s\": undefined variable\n", *ap);
				errs++;
			}
			continue;
		}
		h = hash(*ap);
		if (vp2 == variables[h]) {
			variables[h] = variables[h]->v_link;
			vfree(vp2->v_name);
			vfree(vp2->v_value);
			(void)free(vp2);
			continue;
		}
		for (vp = variables[h]; vp->v_link != vp2; vp = vp->v_link)
			;
		vp->v_link = vp2->v_link;
		vfree(vp2->v_name);
		vfree(vp2->v_value);
		(void)free(vp2);
	}
	return(errs);
}

/*
 * Put add users to a group.
 */
int
group(void *v)
{
	char **argv = v;
	struct grouphead *gh;
	struct group *gp;
	char **ap, *gname, **p;
	int h, s;

	if (*argv == NULL) {
		for (h = 0, s = 1; h < HSHSIZE; h++)
			for (gh = groups[h]; gh != NULL; gh = gh->g_link)
				s++;
		ap = (char **)salloc(s * sizeof(*ap));
		for (h = 0, p = ap; h < HSHSIZE; h++)
			for (gh = groups[h]; gh != NULL; gh = gh->g_link)
				*p++ = gh->g_name;
		*p = NULL;
		sort(ap);
		for (p = ap; *p != NULL; p++)
			printgroup(*p);
		return(0);
	}
	if (argv[1] == NULL) {
		printgroup(*argv);
		return(0);
	}
	gname = *argv;
	h = hash(gname);
	if ((gh = findgroup(gname)) == NULL) {
		if ((gh = calloc(1, sizeof(*gh))) == NULL)
			err(1, "calloc");
		gh->g_name = vcopy(gname);
		gh->g_list = NULL;
		gh->g_link = groups[h];
		groups[h] = gh;
	}

	/*
	 * Insert names from the command list into the group.
	 * Who cares if there are duplicates?  They get tossed
	 * later anyway.
	 */

	for (ap = argv+1; *ap != NULL; ap++) {
		if ((gp = calloc(1, sizeof(*gp))) == NULL)
			err(1, "calloc");
		gp->ge_name = vcopy(*ap);
		gp->ge_link = gh->g_list;
		gh->g_list = gp;
	}
	return(0);
}

/*
 * Sort the passed string vector into ascending dictionary
 * order.
 */
void
sort(char **list)
{
	char **ap;

	for (ap = list; *ap != NULL; ap++)
		;
	if (ap-list < 2)
		return;
	qsort(list, ap-list, sizeof(*list), diction);
}

/*
 * Do a dictionary order comparison of the arguments from
 * qsort.
 */
static int
diction(const void *a, const void *b)
{

	return(strcmp(*(char **)a, *(char **)b));
}

/*
 * The do nothing command for comments.
 */
/*ARGSUSED*/
int
null(void *v)
{

	return(0);
}

/*
 * Change to another file.  With no argument, print information about
 * the current file.
 */
int
file(void *v)
{
	char **argv = v;

	if (argv[0] == NULL) {
		newfileinfo(0);
		clearnew();
		return(0);
	}
	if (setfile(*argv) < 0)
		return(1);
	announce();
	return(0);
}

/*
 * Expand file names like echo
 */
int
echo(void *v)
{
	char **argv = v;
	char **ap, *cp;

	for (ap = argv; *ap != NULL; ap++) {
		cp = *ap;
		if ((cp = expand(cp)) != NULL) {
			if (ap != argv)
				putchar(' ');
			fputs(cp, stdout);
		}
	}
	putchar('\n');
	return(0);
}

int
Respond(void *v)
{
	int *msgvec = v;

	if (value("Replyall") == NULL)
		return(_Respond(msgvec));
	else
		return(_respond(msgvec));
}

/*
 * Reply to a series of messages by simply mailing to the senders
 * and not messing around with the To: and Cc: lists as in normal
 * reply.
 */
int
_Respond(int *msgvec)
{
	struct header head;
	struct message *mp;
	int *ap;
	char *cp;

	head.h_to = NULL;
	for (ap = msgvec; *ap != 0; ap++) {
		mp = &message[*ap - 1];
		touch(mp);
		dot = mp;
		if ((cp = skin(hfield("from", mp))) == NULL)
			cp = skin(nameof(mp, 2));
		head.h_to = cat(head.h_to, extract(cp, GTO));
	}
	if (head.h_to == NULL)
		return(0);
	mp = &message[msgvec[0] - 1];
	if ((head.h_subject = hfield("subject", mp)) == NULL)
		head.h_subject = hfield("subj", mp);
	head.h_subject = reedit(head.h_subject);
	head.h_from = NULL;
	head.h_cc = NULL;
	head.h_bcc = NULL;
	head.h_smopts = NULL;
	mail1(&head, 1);
	return(0);
}

/*
 * Conditional commands.  These allow one to parameterize one's
 * .mailrc and do some things if sending, others if receiving.
 */
int
ifcmd(void *v)
{
	char **argv = v;
	char *cp;

	if (cond != CANY) {
		puts("Illegal nested \"if\"");
		return(1);
	}
	cond = CANY;
	cp = argv[0];
	switch (*cp) {
	case 'r': case 'R':
		cond = CRCV;
		break;

	case 's': case 'S':
		cond = CSEND;
		break;

	default:
		printf("Unrecognized if-keyword: \"%s\"\n", cp);
		return(1);
	}
	return(0);
}

/*
 * Implement 'else'.  This is pretty simple -- we just
 * flip over the conditional flag.
 */
int
elsecmd(void *v)
{

	switch (cond) {
	case CANY:
		puts("\"Else\" without matching \"if\"");
		return(1);

	case CSEND:
		cond = CRCV;
		break;

	case CRCV:
		cond = CSEND;
		break;

	default:
		puts("mail's idea of conditions is screwed up");
		cond = CANY;
		break;
	}
	return(0);
}

/*
 * End of if statement.  Just set cond back to anything.
 */
int
endifcmd(void *v)
{

	if (cond == CANY) {
		puts("\"Endif\" without matching \"if\"");
		return(1);
	}
	cond = CANY;
	return(0);
}

/*
 * Set the list of alternate names.
 */
int
alternates(void *v)
{
	char **namelist = v;
	char **ap, **ap2;
	int c;

	c = argcount(namelist) + 1;
	if (c == 1) {
		if (altnames == 0)
			return(0);
		for (ap = altnames; *ap; ap++)
			printf("%s ", *ap);
		putchar('\n');
		return(0);
	}
	if (altnames != 0)
		(void)free(altnames);
	if ((altnames = calloc(c, sizeof(char *))) == NULL)
		err(1, "calloc");
	for (ap = namelist, ap2 = altnames; *ap; ap++, ap2++) {
		if ((*ap2 = strdup(*ap)) == NULL)
			err(1, "strdup");
	}
	*ap2 = 0;
	return(0);
}
@


1.26
log
@Add support for the "-r fromaddr" flag now that we don't support
sendmail flags on the command line.
Also allow "from" to be set in mailrc.
Use sendmail's "-t" flag when executing sendmail instead of specifying
the list of recipients in argv.  The "-f" flag will be used to set
the from address if specified.
@
text
@d1 1
a1 1
/*	$OpenBSD: cmd3.c,v 1.25 2011/04/06 11:36:26 miod Exp $	*/
d481 2
a482 2
		if ((gh = (struct grouphead *)calloc(1, sizeof(*gh))) == NULL)
			errx(1, "Out of memory");
d496 2
a497 2
		if ((gp = (struct group *)calloc(1, sizeof(*gp))) == NULL)
			errx(1, "Out of memory");
d728 2
a729 2
	if ((altnames = (char **)calloc(c, sizeof(char *))) == NULL)
		errx(1, "Out of memory");
d732 1
a732 1
			errx(1, "Out of memory");
@


1.25
log
@Avoid using NULL in non-pointer contexts: use 0 for integer values and '\0'
for chars.
@
text
@d1 1
a1 1
/*	$OpenBSD: cmd3.c,v 1.24 2009/10/27 23:59:40 deraadt Exp $	*/
d230 1
d623 1
@


1.24
log
@rcsid[] and sccsid[] and copyright[] are essentially unmaintained (and
unmaintainable).  these days, people use source.  these id's do not provide
any benefit, and do hurt the small install media
(the 33,000 line diff is essentially mechanical)
ok with the idea millert, ok dms
@
text
@d1 1
a1 1
/*	$OpenBSD: cmd3.c,v 1.23 2009/09/05 10:49:45 tobias Exp $	*/
d279 1
a279 1
	for (ip = msgvec; *ip != NULL; ip++) {
d302 1
a302 1
	for (ip = msgvec; *ip != NULL; ip++) {
d321 1
a321 1
	for (ip = msgvec; *ip != NULL; ip++) {
d339 1
a339 1
	for (ip = msgvec; *ip != NULL; ip++) {
@


1.23
log
@Fixed typo in comment.

ok millert
@
text
@d1 1
a1 1
/*	$OpenBSD: cmd3.c,v 1.22 2009/07/23 20:06:03 martynas Exp $	*/
a31 8

#ifndef lint
#if 0
static const char sccsid[] = "@@(#)cmd3.c	8.2 (Berkeley) 4/20/95";
#else
static const char rcsid[] = "$OpenBSD: cmd3.c,v 1.22 2009/07/23 20:06:03 martynas Exp $";
#endif
#endif /* not lint */
@


1.22
log
@elide a little bit later, the final list, after From has been
appended.  properly removes if there's a dup in from & to.
ok millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: cmd3.c,v 1.21 2008/07/16 14:53:41 martynas Exp $	*/
d37 1
a37 1
static const char rcsid[] = "$OpenBSD: cmd3.c,v 1.21 2008/07/16 14:53:41 martynas Exp $";
d513 1
a513 1
 * Sort the passed string vecotor into ascending dictionary
@


1.21
log
@- use strncmp/strncasecmp instead of comparing by character
- simplify istrlcpy, no need to check for isupper
- line[0] is redundant, because strcasecmp will take care of it
ok millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: cmd3.c,v 1.20 2003/06/03 02:56:11 millert Exp $	*/
d37 1
a37 1
static const char rcsid[] = "$OpenBSD: cmd3.c,v 1.20 2003/06/03 02:56:11 millert Exp $";
a220 1
	np = elide(np);
d236 1
@


1.20
log
@Remove the advertising clause in the UCB license which Berkeley
rescinded 22 July 1999.  Proofed by myself and Theo.
@
text
@d1 1
a1 1
/*	$OpenBSD: cmd3.c,v 1.19 2002/08/12 00:42:56 aaron Exp $	*/
d37 1
a37 1
static const char rcsid[] = "$OpenBSD: cmd3.c,v 1.19 2002/08/12 00:42:56 aaron Exp $";
d268 1
a268 3
	if ((subj[0] == 'r' || subj[0] == 'R') &&
	    (subj[1] == 'e' || subj[1] == 'E') &&
	    subj[2] == ':')
@


1.19
log
@Swap args to calloc(3) so they are in the correct order; art@@ ok.
@
text
@d1 1
a1 1
/*	$OpenBSD: cmd3.c,v 1.18 2001/11/21 20:41:55 millert Exp $	*/
d16 1
a16 5
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
d37 1
a37 1
static const char rcsid[] = "$OpenBSD: cmd3.c,v 1.18 2001/11/21 20:41:55 millert Exp $";
@


1.18
log
@o kill strcpy()
o check return values of malloc and friends
o use strdup() when sensible
@
text
@d1 1
a1 1
/*	$OpenBSD: cmd3.c,v 1.17 2001/11/21 15:26:39 millert Exp $	*/
d41 1
a41 1
static const char rcsid[] = "$OpenBSD: cmd3.c,v 1.17 2001/11/21 15:26:39 millert Exp $";
d494 1
a494 1
		if ((gh = (struct grouphead *)calloc(sizeof(*gh), 1)) == NULL)
d509 1
a509 1
		if ((gp = (struct group *)calloc(sizeof(*gp), 1)) == NULL)
@


1.17
log
@o ANSIfy
o Style nits
o Use const to silent stupid -Wall warnings
o strnc{py,at} -> strlc{py,at}
o Use strpbrk() instead of homegrown anyof()
o Use NULL instead of #defines with 0 cast to a pointer
This still could use a proper audit
@
text
@d1 1
a1 1
/*	$OpenBSD: cmd3.c,v 1.16 2001/11/20 20:50:00 millert Exp $	*/
d41 1
a41 1
static const char rcsid[] = "$OpenBSD: cmd3.c,v 1.16 2001/11/20 20:50:00 millert Exp $";
d268 1
d276 4
a279 3
	newsubj = salloc(strlen(subj) + 5);
	strcpy(newsubj, "Re: ");
	strcpy(newsubj + 4, subj);
d494 2
a495 1
		gh = (struct grouphead *)calloc(sizeof(*gh), 1);
d509 2
a510 1
		gp = (struct group *)calloc(sizeof(*gp), 1);
d726 1
a726 1
	char **ap, **ap2, *cp;
d740 2
a741 1
	altnames = (char **)calloc(c, sizeof(char *));
d743 2
a744 3
		cp = (char *)calloc(strlen(*ap) + 1, sizeof(char));
		strcpy(cp, *ap);
		*ap2 = cp;
@


1.16
log
@Major signal overhaul.  We no longer longjmp all over the place.
Instead, routines responsible to gathering user input (or in some
cases outputting data) catch the signals and set flags as needed.
Because of this some handlers are install without the SA_RESTART
flag so syscalls are not restarted and we can check the flag.  All
signal handlers are now safe.

This should make the flow of control a bit more grokable but the
code is still ugly.
@
text
@d1 1
a1 1
/*	$OpenBSD: cmd3.c,v 1.15 2001/01/19 04:11:28 millert Exp $	*/
d39 1
a39 1
static char sccsid[] = "@@(#)cmd3.c	8.2 (Berkeley) 4/20/95";
d41 1
a41 1
static char rcsid[] = "$OpenBSD: cmd3.c,v 1.15 2001/01/19 04:11:28 millert Exp $";
d53 1
a53 1
static int diction __P((const void *, const void *));
d60 1
a60 2
shell(v)
	void *v;
d85 1
a85 2
dosh(v)
	void *v;
d105 1
a105 3
bangexp(str, strsize)
	char *str;
	size_t strsize;
d123 1
a123 2
			strncpy(cp2, lastbang, sizeof(bangbuf) - (cp2 - bangbuf) - 1);
			bangbuf[sizeof(bangbuf) - 1] = '\0';
d145 2
a146 4
	(void)strncpy(str, bangbuf, strsize - 1);
	str[strsize - 1]  = '\0';
	(void)strncpy(lastbang, bangbuf, sizeof(lastbang) - 1);
	lastbang[sizeof(lastbang) - 1] = '\0';
d154 1
a154 2
help(v)
	void *v;
d165 1
a165 2
schdir(v)
	void *v;
d186 1
a186 2
respond(v)
	void *v;
d189 1
d224 1
a224 1
		np = NIL;
d234 1
a234 1
	if (np != NIL && replyto == NULL)
d236 1
a236 1
	else if (np == NIL) {
d253 3
a255 3
		head.h_cc = NIL;
	head.h_bcc = NIL;
	head.h_smopts = NIL;
d265 1
a265 2
reedit(subj)
	char *subj;
d286 1
a286 2
marknew(v)
	void *v;
d304 1
a304 2
preserve(v)
	void *v;
d328 1
a328 2
unread(v)
	void *v;
d345 1
a345 2
messize(v)
	void *v;
d364 1
a364 2
rexit(v)
	void *v;
d366 1
d378 1
a378 2
set(v)
	void *v;
d388 1
a388 1
			for (vp = variables[h]; vp != NOVAR; vp = vp->v_link)
d392 1
a392 1
			for (vp = variables[h]; vp != NOVAR; vp = vp->v_link)
d425 1
a425 2
unset(v)
	void *v;
d434 1
a434 1
		if ((vp2 = lookup(*ap)) == NOVAR) {
d463 1
a463 2
group(v)
	void *v;
d473 1
a473 1
			for (gh = groups[h]; gh != NOGRP; gh = gh->g_link)
d477 1
a477 1
			for (gh = groups[h]; gh != NOGRP; gh = gh->g_link)
d491 1
a491 1
	if ((gh = findgroup(gname)) == NOGRP) {
d494 1
a494 1
		gh->g_list = NOGE;
d519 1
a519 2
sort(list)
	char **list;
d535 1
a535 2
diction(a, b)
	const void *a, *b;
d537 1
a543 1

d546 1
a546 2
null(v)
	void *v;
d548 1
d557 1
a557 2
file(v)
	void *v;
d576 1
a576 2
echo(v)
	void *v;
d594 1
a594 2
Respond(v)
	void *v;
d597 1
d610 1
a610 2
_Respond(msgvec)
	int msgvec[];
d617 1
a617 1
	head.h_to = NIL;
d626 1
a626 1
	if (head.h_to == NIL)
d632 3
a634 3
	head.h_cc = NIL;
	head.h_bcc = NIL;
	head.h_smopts = NIL;
d644 1
a644 2
ifcmd(v)
	void *v;
d676 1
a676 2
elsecmd(v)
	void *v;
d704 1
a704 2
endifcmd(v)
	void *v;
d719 1
a719 2
alternates(v)
	void *v;
@


1.15
log
@More fixes from Don Beusee:
- edit and other interactive commands have no stdin (making the
  command completely broken).
- messages with "From " line having date format with -0800 type of timezone
  are not recognized correctly.
@
text
@d1 1
a1 1
/*	$OpenBSD: cmd3.c,v 1.14 2001/01/16 05:36:08 millert Exp $	*/
d41 1
a41 1
static char rcsid[] = "$OpenBSD: cmd3.c,v 1.14 2001/01/16 05:36:08 millert Exp $";
a63 1
	sig_t sigint = signal(SIGINT, SIG_IGN);
d66 2
d69 2
a70 2
	(void)strncpy(cmd, str, sizeof(cmd) - 1);
	cmd[sizeof(cmd) - 1] = '\0';
d75 2
a76 1
	(void)signal(SIGINT, sigint);
a88 1
	sig_t sigint = signal(SIGINT, SIG_IGN);
d90 2
d94 1
d96 2
a97 1
	(void)signal(SIGINT, sigint);
@


1.14
log
@Changes from Don Beusee:
o escape From line with a leading '>' when needed
o only print To: address and Subject lines if actually present
o new variable 'allnet' to treat user@@foo and user@@bar as the same "user"
o folders command now takes an optional argument like ls.
o new "pipe" (|) command to pipe the message through an arbitrary command
o make header display format the same as SunOS 4.1.3 /usr/ucb/mail
o tilde commands work regardless of interactive mode.
o fix "read: Interrupted system call" error by retrying if EINTR
o expanded help file
Changes by me:
o read the help file via the PAGER as it is now more than 24 lines long
@
text
@d1 1
a1 1
/*	$OpenBSD: cmd3.c,v 1.13 2000/08/02 04:10:48 millert Exp $	*/
d41 1
a41 1
static char rcsid[] = "$OpenBSD: cmd3.c,v 1.13 2000/08/02 04:10:48 millert Exp $";
d73 1
a73 1
	(void)run_command(shell, 0, -1, -1, "-c", cmd, NULL);
d91 1
a91 1
	(void)run_command(shell, 0, -1, -1, NULL, NULL, NULL);
@


1.13
log
@$HOME paranoia: never use getenv("HOME") w/o checking for NULL and non-zero
@
text
@d1 1
a1 1
/*	$OpenBSD: cmd3.c,v 1.12 2000/06/30 16:00:16 millert Exp $	*/
d41 1
a41 1
static char rcsid[] = "$OpenBSD: cmd3.c,v 1.12 2000/06/30 16:00:16 millert Exp $";
d72 1
a72 2
	if ((shell = value("SHELL")) == NULL)
		shell = _PATH_CSHELL;
d90 1
a90 2
	if ((shell = value("SHELL")) == NULL)
		shell = _PATH_CSHELL;
a154 1

a158 2
	int c;
	FILE *f;
d160 1
a160 7
	if ((f = Fopen(_PATH_HELP, "r")) == NULL) {
		warn(_PATH_HELP);
		return(1);
	}
	while ((c = getc(f)) != EOF)
		putchar(c);
	(void)Fclose(f);
d287 19
d338 1
a338 1
	int	*msgvec = v;
@


1.12
log
@warnx?/errx? paranoia (use "%s" not a bare string unless it is a
constant).  These are not security holes but it is worth fixing
them anyway both for robustness and so folks looking for examples
in the tree are not misled into doing something potentially dangerous.
Furthermore, it is a bad idea to assume that pathnames will not
include '%' in them and that error routines don't return strings
with '%' in them (especially in light of the possibility of locales).
@
text
@d1 1
a1 1
/*	$OpenBSD: cmd3.c,v 1.11 2000/04/25 16:42:22 millert Exp $	*/
d41 1
a41 1
static char rcsid[] = "$OpenBSD: cmd3.c,v 1.11 2000/04/25 16:42:22 millert Exp $";
d185 3
a187 1
	if (*arglist == NULL)
d189 1
a189 1
	else
d192 1
@


1.11
log
@When incorporating new messages, clear the "new" count before the
inc so the count of new messages is useful afterwards.  This makes
mail behave more like the SunOS version in this respect.
@
text
@d1 1
a1 1
/*	$OpenBSD: cmd3.c,v 1.10 1997/11/14 00:23:44 millert Exp $	*/
d41 1
a41 1
static char rcsid[] = "$OpenBSD: cmd3.c,v 1.10 1997/11/14 00:23:44 millert Exp $";
d191 1
a191 1
		warn(cp);
@


1.11.2.1
log
@Pull in patch from current (even more to come):
Fix (millert):
warnx?/errx? paranoia (use "%s" not a bare string unless it is a
constant).  These are not security holes but it is worth fixing
them anyway both for robustness and so folks looking for examples
in the tree are not misled into doing something potentially dangerous.
Furthermore, it is a bad idea to assume that pathnames will not
include '%' in them and that error routines don't return strings
with '%' in them (especially in light of the possibility of locales).
@
text
@d1 1
a1 1
/*	$OpenBSD: cmd3.c,v 1.12 2000/06/30 16:00:16 millert Exp $	*/
d41 1
a41 1
static char rcsid[] = "$OpenBSD: cmd3.c,v 1.12 2000/06/30 16:00:16 millert Exp $";
d191 1
a191 1
		warn("%s", cp);
@


1.10
log
@NetBSD changes (mostly comsmetic):
    replace panic() with calls to err()/errx()
    use S_IS* instead of doing by hand with S_IF*.
    Use TIMESPEC_TO_TIMEVAL() and gettimeofday instead of time(2)
    Use _POSIX_VDISABLE, not 0
    Kill register
@
text
@d1 1
a1 1
/*	$OpenBSD: cmd3.c,v 1.9 1997/07/30 07:19:30 millert Exp $	*/
d41 1
a41 1
static char rcsid[] = "$OpenBSD: cmd3.c,v 1.9 1997/07/30 07:19:30 millert Exp $";
d567 1
@


1.9
log
@Make istrcpy() take a size (not length) field, now called istrncpy().
Change some strcpy() -> strncpy() out of paranoia.
@
text
@d1 1
a1 1
/*	$OpenBSD: cmd3.c,v 1.8 1997/07/30 06:32:38 millert Exp $	*/
d41 1
a41 1
static char rcsid[] = "$OpenBSD: cmd3.c,v 1.8 1997/07/30 06:32:38 millert Exp $";
d110 2
a111 3
	register char *cp, *cp2;
	register int n;
	int changed = 0;
d162 2
a163 2
	register c;
	register FILE *f;
d278 1
a278 1
	register char *subj;
d303 2
a304 2
	register struct message *mp;
	register int *ip, mesg;
d328 1
a328 1
	register int *ip;
d346 2
a347 2
	register struct message *mp;
	register int *ip, mesg;
d380 2
a381 2
	register struct var *vp;
	register char *cp, *cp2;
d428 1
a428 1
	register struct var *vp, *vp2;
d467 2
a468 4
	register struct grouphead *gh;
	register struct group *gp;
	register int h;
	int s;
d470 1
d523 1
a523 1
	register char **ap;
d583 1
a583 2
	register char **ap;
	register char *cp;
d619 2
a620 2
	register int *ap;
	register char *cp;
d653 1
a653 1
	register char *cp;
d731 2
a732 2
	register int c;
	register char **ap, **ap2, *cp;
@


1.8
log
@Fix one possible oflow (not exploitable) and do a wee bit of KNF.
Much more remains to be done.
@
text
@d1 1
a1 1
/*	$OpenBSD: cmd3.c,v 1.7 1997/07/14 00:24:25 millert Exp $	*/
d41 1
a41 1
static char rcsid[] = "$OpenBSD: cmd3.c,v 1.7 1997/07/14 00:24:25 millert Exp $";
d125 2
a126 1
			strcpy(cp2, lastbang);
@


1.7
log
@NOSTR -> NULL
Use sigsetjmp/siglongjmp instead of sigjmp/longjmp for portability.
@
text
@d1 1
a1 1
/*	$OpenBSD: cmd3.c,v 1.6 1997/07/13 23:53:58 millert Exp $	*/
d41 1
a41 1
static char rcsid[] = "$OpenBSD: cmd3.c,v 1.6 1997/07/13 23:53:58 millert Exp $";
d68 3
a70 2
	(void)strcpy(cmd, str);
	if (bangexp(cmd) < 0)
a102 3

char	lastbang[128];

d104 1
a104 1
bangexp(str)
d106 1
d109 1
d144 2
a145 2
		printf("!%s\n", bangbuf);
		fflush(stdout);
d147 3
a149 2
	strcpy(str, bangbuf);
	strncpy(lastbang, bangbuf, sizeof(lastbang) - 1);
@


1.6
log
@bcopy() -> memcpy() and fix some casts.
@
text
@d1 1
a1 1
/*	$OpenBSD: cmd3.c,v 1.5 1997/07/13 21:21:09 millert Exp $	*/
d41 1
a41 1
static char rcsid[] = "$OpenBSD: cmd3.c,v 1.5 1997/07/13 21:21:09 millert Exp $";
d71 1
a71 1
	if ((shell = value("SHELL")) == NOSTR)
d73 1
a73 1
	(void)run_command(shell, 0, -1, -1, "-c", cmd, NOSTR);
d90 1
a90 1
	if ((shell = value("SHELL")) == NOSTR)
d92 1
a92 1
	(void)run_command(shell, 0, -1, -1, NOSTR, NOSTR, NOSTR);
d184 1
a184 1
	if (*arglist == NOSTR)
d187 1
a187 1
		if ((cp = expand(*arglist)) == NOSTR)
d201 1
a201 1
	if (value("Replyall") == NOSTR)
d228 1
a228 1
	if ((rcv = skin(hfield("from", mp))) == NOSTR)
d230 1
a230 1
	if ((replyto = skin(hfield("reply-to", mp))) != NOSTR)
d232 1
a232 1
	else if ((cp = skin(hfield("to", mp))) != NOSTR)
d245 1
a245 1
	if (np != NIL && replyto == NOSTR)
d248 1
a248 1
		if (replyto != NOSTR)
d253 1
a253 1
	if ((head.h_subject = hfield("subject", mp)) == NOSTR)
d256 1
a256 1
	if (replyto == NOSTR && (cp = skin(hfield("cc", mp))) != NOSTR) {
d281 2
a282 2
	if (subj == NOSTR)
		return(NOSTR);
d384 1
a384 1
	if (*arglist == NOSTR) {
d392 1
a392 1
		*p = NOSTR;
d394 1
a394 1
		for (p = ap; *p != NOSTR; p++)
d399 1
a399 1
	for (ap = arglist; *ap != NOSTR; ap++) {
d432 1
a432 1
	for (ap = arglist; *ap != NOSTR; ap++) {
d472 1
a472 1
	if (*argv == NOSTR) {
d480 1
a480 1
		*p = NOSTR;
d482 1
a482 1
		for (p = ap; *p != NOSTR; p++)
d486 1
a486 1
	if (argv[1] == NOSTR) {
d506 1
a506 1
	for (ap = argv+1; *ap != NOSTR; ap++) {
d525 1
a525 1
	for (ap = list; *ap != NOSTR; ap++)
d565 1
a565 1
	if (argv[0] == NOSTR) {
d586 1
a586 1
	for (ap = argv; *ap != NOSTR; ap++) {
d588 1
a588 1
		if ((cp = expand(cp)) != NOSTR) {
d603 1
a603 1
	if (value("Replyall") == NOSTR)
d628 1
a628 1
		if ((cp = skin(hfield("from", mp))) == NOSTR)
d635 1
a635 1
	if ((head.h_subject = hfield("subject", mp)) == NOSTR)
@


1.5
log
@Merge in NetBSD and 4.4BSD-lite2 changes as well as some of my own.
 - handle long lines safely (from NetBSD)
 - use puts/fputs and putchar/putc when it makes sense
 - use err/errx and warn/warnx when it makes sense
 - make return() and sizeof() style consisten
 - some more buffer safety
@
text
@d1 1
a1 1
/*	$OpenBSD: cmd3.c,v 1.4 1997/05/30 08:51:35 deraadt Exp $	*/
d41 1
a41 1
static char rcsid[] = "$OpenBSD: cmd3.c,v 1.4 1997/05/30 08:51:35 deraadt Exp $";
d68 1
a68 1
	(void) strcpy(cmd, str);
d73 2
a74 2
	(void) run_command(shell, 0, -1, -1, "-c", cmd, NOSTR);
	(void) signal(SIGINT, sigint);
d92 2
a93 2
	(void) run_command(shell, 0, -1, -1, NOSTR, NOSTR, NOSTR);
	(void) signal(SIGINT, sigint);
d388 1
a388 1
		ap = (char **) salloc(s * sizeof(*ap));
d445 1
a445 1
			free((char *)vp2);
d453 1
a453 1
		free((char *) vp2);
d476 1
a476 1
		ap = (char **) salloc(s * sizeof(*ap));
d493 1
a493 1
		gh = (struct grouphead *) calloc(sizeof(*gh), 1);
d507 1
a507 1
		gp = (struct group *) calloc(sizeof(*gp), 1);
d745 2
a746 2
		free((char *) altnames);
	altnames = (char **) calloc((unsigned) c, sizeof(char *));
d748 1
a748 1
		cp = (char *) calloc((unsigned) strlen(*ap) + 1, sizeof(char));
@


1.4
log
@overflows abound
@
text
@d1 2
a2 2
/*	$OpenBSD: cmd3.c,v 1.3 1997/03/29 03:01:44 millert Exp $	*/
/*	$NetBSD: cmd3.c,v 1.5 1996/06/08 19:48:14 christos Exp $	*/
d39 1
a39 1
static char sccsid[] = "@@(#)cmd3.c	8.1 (Berkeley) 6/6/93";
d41 1
a41 1
static char rcsid[] = "$OpenBSD: cmd3.c,v 1.3 1997/03/29 03:01:44 millert Exp $";
d70 1
a70 1
		return 1;
d75 2
a76 2
	printf("!\n");
	return 0;
d95 1
a95 1
	return 0;
d121 1
a121 1
				printf("Command buffer overflow\n");
d148 2
a149 2
	strncpy(lastbang, bangbuf, 128);
	lastbang[128-1] = 0;
d165 1
a165 1
		perror(_PATH_HELP);
d170 1
a170 1
	Fclose(f);
d190 1
a190 1
		perror(cp);
d193 1
a193 1
	return 0;
d202 1
a202 1
		return (_respond(msgvec));
d204 1
a204 1
		return (_Respond(msgvec));
d222 1
a222 1
		printf("Sorry, can't reply to multiple messages at once\n");
d249 1
a249 1
			printf("Empty reply-to field -- replying to author\n");
d282 1
a282 1
		return NOSTR;
d286 1
a286 1
		return subj;
d290 1
a290 1
	return newsubj;
d306 1
a306 1
		printf("Cannot \"preserve\" in edit mode\n");
d388 1
a388 1
		ap = (char **) salloc(s * sizeof *ap);
d410 1
a410 1
			printf("Non-null variable name required\n");
d476 1
a476 1
		ap = (char **) salloc(s * sizeof *ap);
d493 1
a493 1
		gh = (struct grouphead *) calloc(sizeof *gh, 1);
d507 1
a507 1
		gp = (struct group *) calloc(sizeof *gp, 1);
d552 1
a552 1
	return 0;
d566 2
a567 2
		newfileinfo();
		return 0;
d570 1
a570 1
		return 1;
d572 1
a572 1
	return 0;
d591 1
a591 1
			printf("%s", cp);
d595 1
a595 1
	return 0;
d604 1
a604 1
		return (_Respond(msgvec));
d606 1
a606 1
		return (_respond(msgvec));
d633 1
a633 1
		return 0;
d642 1
a642 1
	return 0;
d657 1
a657 1
		printf("Illegal nested \"if\"\n");
d689 1
a689 1
		printf("\"Else\" without matching \"if\"\n");
d701 1
a701 1
		printf("Mail's idea of conditions is screwed up\n");
d717 1
a717 1
		printf("\"Endif\" without matching \"if\"\n");
d741 1
a741 1
		printf("\n");
d746 1
a746 1
	altnames = (char **) calloc((unsigned) c, sizeof (char *));
d748 1
a748 1
		cp = (char *) calloc((unsigned) strlen(*ap) + 1, sizeof (char));
@


1.3
log
@Use ``mail.local -H'' to do dot locking so we can have mode 755 mail
spool, change an occurrence of tempnam() to mkstemp(), change some
longs and shorts to ints.  Mail is now usable again.
@
text
@d1 1
a1 1
/*	$OpenBSD: cmd3.c,v 1.2 1996/06/11 12:53:34 deraadt Exp $	*/
d41 1
a41 1
static char rcsid[] = "$OpenBSD: cmd3.c,v 1.2 1996/06/11 12:53:34 deraadt Exp $";
d149 1
a149 1
	lastbang[127] = 0;
@


1.2
log
@from christos;
- Fix PR/105: Implement dot locking protocol and check return value of flock.
- Fix PR/2247: Don't call unknown users "ubluit". Issue an error message.
- Fix/add prototypes.
- Fix warnings.
- Use POSIX signal mask calls.
@
text
@d1 1
a1 1
/*	$OpenBSD: cmd3.c,v 1.5 1996/06/08 19:48:14 christos Exp $	*/
d41 1
a41 1
static char rcsid[] = "$OpenBSD: cmd3.c,v 1.5 1996/06/08 19:48:14 christos Exp $";
d351 1
a351 1
		printf("%d: %d/%ld\n", mesg, mp->m_lines, mp->m_size);
@


1.1
log
@Initial revision
@
text
@d1 3
d38 1
d40 3
a42 1
static char rcsid[] = "$Id: cmd3.c,v 1.4 1994/06/29 05:09:11 deraadt Exp $";
d53 1
d60 2
a61 2
shell(str)
	char *str;
d63 1
d84 2
a85 2
dosh(str)
	char *str;
d158 2
a159 1
help()
d178 2
a179 2
schdir(arglist)
	char **arglist;
d181 1
d197 2
a198 2
respond(msgvec)
	int *msgvec;
d200 1
d298 2
a299 2
preserve(msgvec)
	int *msgvec;
d301 1
d323 2
a324 2
unread(msgvec)
	int	msgvec[];
d326 1
d341 2
a342 2
messize(msgvec)
	int *msgvec;
d344 1
d361 2
a362 2
rexit(e)
	int e;
d366 1
a366 1
	exit(e);
d375 2
a376 2
set(arglist)
	char **arglist;
d378 1
d423 2
a424 2
unset(arglist)
	char **arglist;
d426 1
d462 2
a463 2
group(argv)
	char **argv;
d465 1
a523 1
	int diction();
d536 1
a536 1
int
d549 2
a550 2
null(e)
	int e;
d560 2
a561 2
file(argv)
	register char **argv;
d563 1
d579 2
a580 2
echo(argv)
	char **argv;
d582 1
d599 2
a600 2
Respond(msgvec)
	int *msgvec;
d602 1
d650 2
a651 2
ifcmd(argv)
	char **argv;
d653 1
d683 2
a684 1
elsecmd()
d712 2
a713 1
endifcmd()
d728 2
a729 2
alternates(namelist)
	char **namelist;
d731 1
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@
