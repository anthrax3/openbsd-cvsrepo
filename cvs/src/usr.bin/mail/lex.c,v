head	1.39;
access;
symbols
	OPENBSD_6_2:1.39.0.10
	OPENBSD_6_2_BASE:1.39
	OPENBSD_6_1:1.39.0.8
	OPENBSD_6_1_BASE:1.39
	OPENBSD_6_0:1.39.0.4
	OPENBSD_6_0_BASE:1.39
	OPENBSD_5_9:1.39.0.2
	OPENBSD_5_9_BASE:1.39
	OPENBSD_5_8:1.38.0.6
	OPENBSD_5_8_BASE:1.38
	OPENBSD_5_7:1.38.0.2
	OPENBSD_5_7_BASE:1.38
	OPENBSD_5_6:1.37.0.4
	OPENBSD_5_6_BASE:1.37
	OPENBSD_5_5:1.36.0.4
	OPENBSD_5_5_BASE:1.36
	OPENBSD_5_4:1.35.0.2
	OPENBSD_5_4_BASE:1.35
	OPENBSD_5_3:1.34.0.8
	OPENBSD_5_3_BASE:1.34
	OPENBSD_5_2:1.34.0.6
	OPENBSD_5_2_BASE:1.34
	OPENBSD_5_1_BASE:1.34
	OPENBSD_5_1:1.34.0.4
	OPENBSD_5_0:1.34.0.2
	OPENBSD_5_0_BASE:1.34
	OPENBSD_4_9:1.33.0.6
	OPENBSD_4_9_BASE:1.33
	OPENBSD_4_8:1.33.0.4
	OPENBSD_4_8_BASE:1.33
	OPENBSD_4_7:1.33.0.2
	OPENBSD_4_7_BASE:1.33
	OPENBSD_4_6:1.32.0.24
	OPENBSD_4_6_BASE:1.32
	OPENBSD_4_5:1.32.0.20
	OPENBSD_4_5_BASE:1.32
	OPENBSD_4_4:1.32.0.18
	OPENBSD_4_4_BASE:1.32
	OPENBSD_4_3:1.32.0.16
	OPENBSD_4_3_BASE:1.32
	OPENBSD_4_2:1.32.0.14
	OPENBSD_4_2_BASE:1.32
	OPENBSD_4_1:1.32.0.12
	OPENBSD_4_1_BASE:1.32
	OPENBSD_4_0:1.32.0.10
	OPENBSD_4_0_BASE:1.32
	OPENBSD_3_9:1.32.0.8
	OPENBSD_3_9_BASE:1.32
	OPENBSD_3_8:1.32.0.6
	OPENBSD_3_8_BASE:1.32
	OPENBSD_3_7:1.32.0.4
	OPENBSD_3_7_BASE:1.32
	OPENBSD_3_6:1.32.0.2
	OPENBSD_3_6_BASE:1.32
	OPENBSD_3_5:1.30.0.2
	OPENBSD_3_5_BASE:1.30
	OPENBSD_3_4:1.28.0.2
	OPENBSD_3_4_BASE:1.28
	OPENBSD_3_3:1.27.0.6
	OPENBSD_3_3_BASE:1.27
	OPENBSD_3_2:1.27.0.4
	OPENBSD_3_2_BASE:1.27
	OPENBSD_3_1:1.27.0.2
	OPENBSD_3_1_BASE:1.27
	OPENBSD_3_0:1.23.0.2
	OPENBSD_3_0_BASE:1.23
	OPENBSD_2_9_BASE:1.22
	OPENBSD_2_9:1.22.0.2
	OPENBSD_2_8:1.21.0.2
	OPENBSD_2_8_BASE:1.21
	OPENBSD_2_7:1.19.0.2
	OPENBSD_2_7_BASE:1.19
	OPENBSD_2_6:1.18.0.6
	OPENBSD_2_6_BASE:1.18
	OPENBSD_2_5:1.18.0.4
	OPENBSD_2_5_BASE:1.18
	OPENBSD_2_4:1.18.0.2
	OPENBSD_2_4_BASE:1.18
	OPENBSD_2_3:1.15.0.2
	OPENBSD_2_3_BASE:1.15
	OPENBSD_2_2:1.14.0.2
	OPENBSD_2_2_BASE:1.14
	OPENBSD_2_1:1.4.0.2
	OPENBSD_2_1_BASE:1.4
	OPENBSD_2_0:1.3.0.2
	OPENBSD_2_0_BASE:1.3
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.39
date	2015.10.16.17.56.07;	author mmcc;	state Exp;
branches;
next	1.38;
commitid	y3aqfd1wS5RZj9kl;

1.38
date	2014.10.26.20.38.13;	author guenther;	state Exp;
branches;
next	1.37;
commitid	kIglsEMRWqE0Zw0s;

1.37
date	2014.05.20.01.25.23;	author guenther;	state Exp;
branches;
next	1.36;

1.36
date	2014.01.17.18.42.30;	author okan;	state Exp;
branches;
next	1.35;

1.35
date	2013.04.29.00.28.23;	author okan;	state Exp;
branches;
next	1.34;

1.34
date	2011.04.06.11.36.26;	author miod;	state Exp;
branches;
next	1.33;

1.33
date	2009.10.27.23.59.40;	author deraadt;	state Exp;
branches;
next	1.32;

1.32
date	2004.05.10.15.25.51;	author deraadt;	state Exp;
branches;
next	1.31;

1.31
date	2004.05.10.12.10.50;	author millert;	state Exp;
branches;
next	1.30;

1.30
date	2003.10.24.20.32.06;	author avsm;	state Exp;
branches;
next	1.29;

1.29
date	2003.10.13.00.46.08;	author tedu;	state Exp;
branches;
next	1.28;

1.28
date	2003.06.03.02.56.11;	author millert;	state Exp;
branches;
next	1.27;

1.27
date	2001.11.21.20.41.55;	author millert;	state Exp;
branches;
next	1.26;

1.26
date	2001.11.21.15.26.39;	author millert;	state Exp;
branches;
next	1.25;

1.25
date	2001.11.20.20.50.00;	author millert;	state Exp;
branches;
next	1.24;

1.24
date	2001.11.17.19.10.25;	author deraadt;	state Exp;
branches;
next	1.23;

1.23
date	2001.06.23.23.04.23;	author millert;	state Exp;
branches;
next	1.22;

1.22
date	2001.01.16.05.36.08;	author millert;	state Exp;
branches;
next	1.21;

1.21
date	2000.07.06.06.24.21;	author deraadt;	state Exp;
branches;
next	1.20;

1.20
date	2000.06.30.16.00.19;	author millert;	state Exp;
branches;
next	1.19;

1.19
date	2000.04.25.16.42.22;	author millert;	state Exp;
branches
	1.19.2.1;
next	1.18;

1.18
date	98.09.08.14.59.12;	author millert;	state Exp;
branches;
next	1.17;

1.17
date	98.06.12.18.07.57;	author millert;	state Exp;
branches;
next	1.16;

1.16
date	98.05.04.05.37.49;	author millert;	state Exp;
branches;
next	1.15;

1.15
date	97.11.14.00.23.48;	author millert;	state Exp;
branches;
next	1.14;

1.14
date	97.07.30.07.19.31;	author millert;	state Exp;
branches;
next	1.13;

1.13
date	97.07.30.06.32.40;	author millert;	state Exp;
branches;
next	1.12;

1.12
date	97.07.24.17.27.11;	author millert;	state Exp;
branches;
next	1.11;

1.11
date	97.07.24.16.23.38;	author millert;	state Exp;
branches;
next	1.10;

1.10
date	97.07.22.19.13.25;	author millert;	state Exp;
branches;
next	1.9;

1.9
date	97.07.22.06.46.20;	author millert;	state Exp;
branches;
next	1.8;

1.8
date	97.07.14.00.24.27;	author millert;	state Exp;
branches;
next	1.7;

1.7
date	97.07.13.23.54.00;	author millert;	state Exp;
branches;
next	1.6;

1.6
date	97.07.13.21.21.13;	author millert;	state Exp;
branches;
next	1.5;

1.5
date	97.05.30.08.51.40;	author deraadt;	state Exp;
branches;
next	1.4;

1.4
date	97.01.17.07.12.47;	author millert;	state Exp;
branches;
next	1.3;

1.3
date	96.06.11.12.53.42;	author deraadt;	state Exp;
branches;
next	1.2;

1.2
date	96.03.27.19.32.33;	author niklas;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.45.39;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.45.39;	author deraadt;	state Exp;
branches;
next	;

1.19.2.1
date	2000.10.06.21.16.15;	author jason;	state Exp;
branches;
next	;


desc
@@


1.39
log
@Modernize allocation by:

 * removing unneeded casts of void* return values
 * replacing varied and creative error messages with the allocation
   function's name
 * replacing errx() with err() so that the errno string is reported

ok beck@@, jung@@, millert@@
@
text
@/*	$OpenBSD: lex.c,v 1.38 2014/10/26 20:38:13 guenther Exp $	*/
/*	$NetBSD: lex.c,v 1.10 1997/05/17 19:55:13 pk Exp $	*/

/*
 * Copyright (c) 1980, 1993
 *	The Regents of the University of California.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */

#include "rcv.h"
#include <errno.h>
#include <fcntl.h>
#include "extern.h"

/*
 * Mail -- a mail program
 *
 * Lexical processing of commands.
 */

char	*prompt = "& ";

const struct cmd *com;	/* command we are running */

/*
 * Set up editing on the given file name.
 * If the first character of name is %, we are considered to be
 * editing the file, otherwise we are reading our mail which has
 * signficance for mbox and so forth.
 */
int
setfile(char *name)
{
	FILE *ibuf;
	int i, fd;
	struct stat stb;
	char isedit = *name != '%';
	char *who = name[1] ? name + 1 : myname;
	char tempname[PATHSIZE];
	static int shudclob;

	if ((name = expand(name)) == NULL)
		return(-1);

	if ((ibuf = Fopen(name, "r")) == NULL) {
		if (!isedit && errno == ENOENT)
			goto nomail;
		warn("%s", name);
		return(-1);
	}

	if (fstat(fileno(ibuf), &stb) < 0) {
		warn("fstat");
		(void)Fclose(ibuf);
		return(-1);
	}

	switch (stb.st_mode & S_IFMT) {
	case S_IFDIR:
		(void)Fclose(ibuf);
		warnc(EISDIR, "%s", name);
		return(-1);

	case S_IFREG:
		break;

	default:
		(void)Fclose(ibuf);
		warnc(EINVAL, "%s", name);
		return(-1);
	}

	/*
	 * Looks like all will be well.  We must now relinquish our
	 * hold on the current set of stuff.  Must hold signals
	 * while we are reading the new file, else we will ruin
	 * the message[] data structure.
	 */
	holdsigs();
	if (shudclob)
		quit();

	/*
	 * Copy the messages into /tmp
	 * and set pointers.
	 */
	readonly = 0;
	if ((i = open(name, O_WRONLY, 0)) < 0)
		readonly++;
	else
		(void)close(i);
	if (shudclob) {
		(void)fclose(itf);
		(void)fclose(otf);
	}
	shudclob = 1;
	edit = isedit;
	strlcpy(prevfile, mailname, PATHSIZE);
	if (name != mailname)
		strlcpy(mailname, name, sizeof(mailname));
	mailsize = fsize(ibuf);
	(void)snprintf(tempname, sizeof(tempname),
	    "%s/mail.RxXXXXXXXXXX", tmpdir);
	if ((fd = mkostemp(tempname, O_CLOEXEC)) == -1 ||
	    (otf = fdopen(fd, "w")) == NULL)
		err(1, "%s", tempname);
	if ((itf = fopen(tempname, "re")) == NULL)
		err(1, "%s", tempname);
	(void)rm(tempname);
	setptr(ibuf, (off_t)0);
	setmsize(msgCount);
	/*
	 * New mail may have arrived while we were reading
	 * the mail file, so reset mailsize to be where
	 * we really are in the file...
	 */
	mailsize = ftell(ibuf);
	(void)Fclose(ibuf);
	relsesigs();
	sawcom = 0;
	if (!edit && msgCount == 0) {
nomail:
		fprintf(stderr, "No mail for %s\n", who);
		return(-1);
	}
	return(0);
}

/*
 * Incorporate any new mail that has arrived since we first
 * started reading mail.
 */
int
incfile(void)
{
	int newsize;
	int omsgCount = msgCount;
	FILE *ibuf;

	ibuf = Fopen(mailname, "r");
	if (ibuf == NULL)
		return(-1);
	holdsigs();
	if (!spool_lock()) {
		(void)Fclose(ibuf);
		relsesigs();
		return(-1);
	}
	newsize = fsize(ibuf);
	/* make sure mail box has grown and is non-empty */
	if (newsize == 0 || newsize <= mailsize) {
		(void)Fclose(ibuf);
		spool_unlock();
		relsesigs();
		return(newsize == mailsize ? 0 : -1);
	}
	setptr(ibuf, mailsize);
	setmsize(msgCount);
	mailsize = ftell(ibuf);
	(void)Fclose(ibuf);
	spool_unlock();
	relsesigs();
	return(msgCount - omsgCount);
}


int	*msgvec;
int	reset_on_stop;			/* reset prompt if stopped */

/*
 * Interpret user commands one by one.  If standard input is not a tty,
 * print no prompt.
 */
void
commands(void)
{
	int n, sig, *sigp;
	int eofloop = 0;
	char linebuf[LINESIZE];

	prompt:
	for (;;) {
		/*
		 * Print the prompt, if needed.  Clear out
		 * string space, and flush the output.
		 */
		if (!sourcing && value("interactive") != NULL) {
			if ((value("autoinc") != NULL) && (incfile() > 0))
				puts("New mail has arrived.");
			reset_on_stop = 1;
			printf("%s", prompt);
		}
		fflush(stdout);
		sreset();
		/*
		 * Read a line of commands from the current input
		 * and handle end of file specially.
		 */
		n = 0;
		sig = 0;
		sigp = sourcing ? NULL : &sig;
		for (;;) {
			if (readline(input, &linebuf[n], LINESIZE - n, sigp) < 0) {
				if (sig) {
					if (sig == SIGINT)
						dointr();
					else if (sig == SIGHUP)
						/* nothing to do? */
						exit(1);
					else {
						/* Stopped by job control */
						(void)kill(0, sig);
						if (reset_on_stop)
							reset_on_stop = 0;
					}
					goto prompt;
				}
				if (n == 0)
					n = -1;
				break;
			}
			if ((n = strlen(linebuf)) == 0)
				break;
			n--;
			if (linebuf[n] != '\\')
				break;
			linebuf[n++] = ' ';
		}
		reset_on_stop = 0;
		if (n < 0) {
				/* eof */
			if (loading)
				break;
			if (sourcing) {
				unstack();
				continue;
			}
			if (value("interactive") != NULL &&
			    value("ignoreeof") != NULL &&
			    ++eofloop < 25) {
				puts("Use \"quit\" to quit.");
				continue;
			}
			break;
		}
		eofloop = 0;
		if (execute(linebuf, 0))
			break;
	}
}

/*
 * Execute a single command.
 * Command functions return 0 for success, 1 for error, and -1
 * for abort.  A 1 or -1 aborts a load or source.  A -1 aborts
 * the interactive command loop.
 * Contxt is non-zero if called while composing mail.
 */
int
execute(char *linebuf, int contxt)
{
	char word[LINESIZE];
	char *arglist[MAXARGC];
	char *cp, *cp2;
	int c, muvec[2];
	int e = 1;

	com = NULL;

	/*
	 * Strip the white space away from the beginning
	 * of the command, then scan out a word, which
	 * consists of anything except digits and white space.
	 *
	 * Handle ! escapes differently to get the correct
	 * lexical conventions.
	 */
	for (cp = linebuf; isspace((unsigned char)*cp); cp++)
		;
	if (*cp == '!') {
		if (sourcing) {
			puts("Can't \"!\" while sourcing");
			goto out;
		}
		shell(cp+1);
		return(0);
	}
	cp2 = word;
	while (*cp &&
	        strchr(" \t0123456789$^.:/-+*'\"", (unsigned char)*cp) == NULL)
		*cp2++ = *cp++;
	*cp2 = '\0';

	/*
	 * Look up the command; if not found, bitch.
	 * Normally, a blank command would map to the
	 * first command in the table; while sourcing,
	 * however, we ignore blank lines to eliminate
	 * confusion.
	 */
	if (sourcing && *word == '\0')
		return(0);
	com = lex(word);
	if (com == NULL) {
		printf("Unknown command: \"%s\"\n", word);
		goto out;
	}

	/*
	 * See if we should execute the command -- if a conditional
	 * we always execute it, otherwise, check the state of cond.
	 */
	if ((com->c_argtype & F) == 0)
		if ((cond == CRCV && !rcvmode) || (cond == CSEND && rcvmode))
			return(0);

	/*
	 * Process the arguments to the command, depending
	 * on the type he expects.  Default to an error.
	 * If we are sourcing an interactive command, it's
	 * an error.
	 */
	if (!rcvmode && (com->c_argtype & M) == 0) {
		printf("May not execute \"%s\" while sending\n",
		    com->c_name);
		goto out;
	}
	if (sourcing && com->c_argtype & I) {
		printf("May not execute \"%s\" while sourcing\n",
		    com->c_name);
		goto out;
	}
	if (readonly && com->c_argtype & W) {
		printf("May not execute \"%s\" -- message file is read only\n",
		   com->c_name);
		goto out;
	}
	if (contxt && com->c_argtype & R) {
		printf("Cannot recursively invoke \"%s\"\n", com->c_name);
		goto out;
	}
	switch (com->c_argtype & ~(F|P|I|M|T|W|R)) {
	case MSGLIST|STRLIST:
		/*
		 * A message list defaulting to nearest forward
		 * legal message.
		 */
		if (msgvec == 0) {
			puts("Illegal use of \"message list\"");
			break;
		}
		/*
		 * remove leading blanks.
		 */
		while (isspace((unsigned char)*cp))
			cp++;

		if (isdigit((unsigned char)*cp) || *cp == ':') {
			if ((c = getmsglist(cp, msgvec, com->c_msgflag)) < 0)
				break;
			/* position to next space - past the message list */
			while (!isspace((unsigned char)*cp))
				cp++;
			/* position to next non-space */
			while (isspace((unsigned char)*cp))
				cp++;
		} else {
			c = 0; /* no message list */
		}

		if (c  == 0) {
			*msgvec = first(com->c_msgflag,
				com->c_msgmask);
			msgvec[1] = 0;
		}
		if (*msgvec == 0) {
			puts("No applicable messages");
			break;
		}
		/*
		 * Just the straight string, with
		 * leading blanks removed.
		 */
		while (isspace((unsigned char)*cp))
			cp++;

		e = (*com->c_func2)(msgvec, cp);
		break;

	case MSGLIST:
		/*
		 * A message list defaulting to nearest forward
		 * legal message.
		 */
		if (msgvec == NULL) {
			puts("Illegal use of \"message list\"");
			break;
		}
		if ((c = getmsglist(cp, msgvec, com->c_msgflag)) < 0)
			break;
		if (c  == 0) {
			*msgvec = first(com->c_msgflag,
				com->c_msgmask);
			msgvec[1] = 0;
		}
		if (*msgvec == 0) {
			puts("No applicable messages");
			break;
		}
		e = (*com->c_func)(msgvec);
		break;

	case NDMLIST:
		/*
		 * A message list with no defaults, but no error
		 * if none exist.
		 */
		if (msgvec == 0) {
			puts("Illegal use of \"message list\"");
			break;
		}
		if (getmsglist(cp, msgvec, com->c_msgflag) < 0)
			break;
		e = (*com->c_func)(msgvec);
		break;

	case STRLIST:
		/*
		 * Just the straight string, with
		 * leading blanks removed.
		 */
		while (isspace((unsigned char)*cp))
			cp++;
		e = (*com->c_func)(cp);
		break;

	case RAWLIST:
		/*
		 * A vector of strings, in shell style.
		 */
		if ((c = getrawlist(cp, arglist,
				sizeof(arglist) / sizeof(*arglist))) < 0)
			break;
		if (c < com->c_minargs) {
			printf("%s requires at least %d arg(s)\n",
				com->c_name, com->c_minargs);
			break;
		}
		if (c > com->c_maxargs) {
			printf("%s takes no more than %d arg(s)\n",
				com->c_name, com->c_maxargs);
			break;
		}
		e = (*com->c_func)(arglist);
		break;

	case NOLIST:
		/*
		 * Just the constant zero, for exiting,
		 * eg.
		 */
		e = (*com->c_func)(0);
		break;

	default:
		errx(1, "Unknown argtype");
	}

out:
	/*
	 * Exit the current source file on
	 * error.
	 */
	if (e) {
		if (e < 0)
			return(1);
		if (loading)
			return(1);
		if (sourcing)
			unstack();
		return(0);
	}
	if (com == NULL)
		return(0);
	if (value("autoprint") != NULL && com->c_argtype & P)
		if ((dot->m_flag & MDELETED) == 0) {
			muvec[0] = dot - &message[0] + 1;
			muvec[1] = 0;
			type(muvec);
		}
	if (!sourcing && (com->c_argtype & T) == 0)
		sawcom = 1;
	return(0);
}

/*
 * Set the size of the message vector used to construct argument
 * lists to message list functions.
 */
void
setmsize(int n)
{
	int *msgvec2;
	size_t msize;

	msize = (n + 1) * sizeof(*msgvec);
	if ((msgvec2 = realloc(msgvec, msize)) == NULL)
		err(1, "realloc");
	msgvec = msgvec2;
	memset(msgvec, 0, msize);
}

/*
 * Find the correct command in the command table corresponding
 * to the passed command "word"
 */

const struct cmd *
lex(char *word)
{
	extern const struct cmd cmdtab[];
	const struct cmd *cp;

	if (word[0] == '#')
		word = "#";
	for (cp = &cmdtab[0]; cp->c_name != NULL; cp++)
		if (isprefix(word, cp->c_name))
			return(cp);
	return(NULL);
}

/*
 * Determine if as1 is a valid prefix of as2.
 * Return true if yep.
 */
int
isprefix(char *as1, char *as2)
{
	char *s1, *s2;

	s1 = as1;
	s2 = as2;
	while (*s1++ == *s2)
		if (*s2++ == '\0')
			return(1);
	return(*--s1 == '\0');
}

/*
 * The following gets called on receipt of an interrupt.  This is
 * to abort printout of a command, mainly.
 * Dispatching here when command() is inactive crashes rcv.
 * Close all open files except 0, 1, 2, and the temporary.
 * Also, unstack all source files.
 */
int	inithdr;			/* am printing startup headers */

void
dointr(void)
{

	noreset = 0;
	if (!inithdr)
		sawcom++;
	inithdr = 0;
	while (sourcing)
		unstack();

	close_all_files();

	if (image >= 0) {
		(void)close(image);
		image = -1;
	}
	fputs("Interrupt\n", stderr);
}

/*
 * Announce the presence of the current Mail version,
 * give the message count, and print a header listing.
 */
void
announce(void)
{
	int vec[2], mdot;

	mdot = newfileinfo(0);
	vec[0] = mdot;
	vec[1] = 0;
	dot = &message[mdot - 1];
	if (msgCount > 0 && value("noheader") == NULL) {
		inithdr++;
		headers(vec);
		inithdr = 0;
	}
}

/*
 * Announce information about the file we are editing.
 * Return a likely place to set dot.
 */
int
newfileinfo(int omsgCount)
{
	struct message *mp;
	int u, n, mdot, d, s;
	char fname[PATHSIZE], zname[PATHSIZE], *ename;

	for (mp = &message[omsgCount]; mp < &message[msgCount]; mp++)
		if (mp->m_flag & MNEW)
			break;
	if (mp >= &message[msgCount])
		for (mp = &message[omsgCount]; mp < &message[msgCount]; mp++)
			if ((mp->m_flag & MREAD) == 0)
				break;
	if (mp < &message[msgCount])
		mdot = mp - &message[0] + 1;
	else
		mdot = omsgCount + 1;
	s = d = 0;
	for (mp = &message[0], n = 0, u = 0; mp < &message[msgCount]; mp++) {
		if (mp->m_flag & MNEW)
			n++;
		if ((mp->m_flag & MREAD) == 0)
			u++;
		if (mp->m_flag & MDELETED)
			d++;
		if (mp->m_flag & MSAVED)
			s++;
	}
	ename = mailname;
	if (getfold(fname, sizeof(fname)) >= 0) {
		strlcat(fname, "/", sizeof(fname));
		if (strncmp(fname, mailname, strlen(fname)) == 0) {
			(void)snprintf(zname, sizeof(zname), "+%s",
			    mailname + strlen(fname));
			ename = zname;
		}
	}
	printf("\"%s\": ", ename);
	if (msgCount == 1)
		fputs("1 message", stdout);
	else
		printf("%d messages", msgCount);
	if (n > 0)
		printf(" %d new", n);
	if (u-n > 0)
		printf(" %d unread", u);
	if (d > 0)
		printf(" %d deleted", d);
	if (s > 0)
		printf(" %d saved", s);
	if (readonly)
		fputs(" [Read only]", stdout);
	putchar('\n');
	return(mdot);
}

/*
 * Print the current version number.
 */
/*ARGSUSED*/
int
pversion(void *v)
{
	extern const char version[];

	printf("Version %s\n", version);
	return(0);
}

/*
 * Load a file of user definitions.
 */
void
load(char *name)
{
	FILE *in, *oldin;

	if ((in = Fopen(name, "r")) == NULL)
		return;
	oldin = input;
	input = in;
	loading = 1;
	sourcing = 1;
	commands();
	loading = 0;
	sourcing = 0;
	input = oldin;
	(void)Fclose(in);
}
@


1.38
log
@Prefer mkostemp(O_CLOEXEC) over mkstemp()+fcntl(F_SETFD)
Prefer fopen("re") over fopen("r")+fcntl(F_SETFD)

ok otto@@ millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: lex.c,v 1.37 2014/05/20 01:25:23 guenther Exp $	*/
d531 1
a531 1
		errx(1, "Out of memory");
@


1.37
log
@Use errc/warnc to simplify code.
Also, in 'ftp', always put the error message last, after the hostname/ipaddr.

ok jsing@@ krw@@ millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: lex.c,v 1.36 2014/01/17 18:42:30 okan Exp $	*/
d127 1
a127 1
	if ((fd = mkstemp(tempname)) == -1 ||
d130 1
a130 2
	(void)fcntl(fileno(otf), F_SETFD, FD_CLOEXEC);
	if ((itf = fopen(tempname, "r")) == NULL)
a131 1
	(void)fcntl(fileno(itf), F_SETFD, FD_CLOEXEC);
@


1.36
log
@ctype and other sign extension fixes.

with deraadt and millert, ok millert
@
text
@d1 1
a1 1
/*	$OpenBSD: lex.c,v 1.35 2013/04/29 00:28:23 okan Exp $	*/
d84 1
a84 2
		errno = EISDIR;
		warn("%s", name);
d92 1
a92 2
		errno = EINVAL;
		warn("%s", name);
@


1.35
log
@use FD_CLOEXEC instead of 1; from David Hill

ok otto
@
text
@d1 1
a1 1
/*	$OpenBSD: lex.c,v 1.34 2011/04/06 11:36:26 miod Exp $	*/
d305 1
a305 1
	for (cp = linebuf; isspace(*cp); cp++)
d316 2
a317 1
	while (*cp && strchr(" \t0123456789$^.:/-+*'\"", *cp) == NULL)
d382 1
a382 1
		while (isspace(*cp))
d385 1
a385 1
		if (isdigit(*cp) || *cp == ':') {
d389 1
a389 1
			while (!isspace(*cp))
d392 1
a392 1
			while (isspace(*cp))
d411 1
a411 1
		while (isspace(*cp))
d459 1
a459 1
		while (isspace(*cp))
@


1.34
log
@Avoid using NULL in non-pointer contexts: use 0 for integer values and '\0'
for chars.
@
text
@d1 1
a1 1
/*	$OpenBSD: lex.c,v 1.33 2009/10/27 23:59:40 deraadt Exp $	*/
d132 1
a132 1
	(void)fcntl(fileno(otf), F_SETFD, 1);
d135 1
a135 1
	(void)fcntl(fileno(itf), F_SETFD, 1);
@


1.33
log
@rcsid[] and sccsid[] and copyright[] are essentially unmaintained (and
unmaintainable).  these days, people use source.  these id's do not provide
any benefit, and do hurt the small install media
(the 33,000 line diff is essentially mechanical)
ok with the idea millert, ok dms
@
text
@d1 1
a1 1
/*	$OpenBSD: lex.c,v 1.32 2004/05/10 15:25:51 deraadt Exp $	*/
d400 1
a400 1
			msgvec[1] = NULL;
d430 1
a430 1
			msgvec[1] = NULL;
@


1.32
log
@delint; millert ok
@
text
@d1 1
a1 1
/*	$OpenBSD: lex.c,v 1.31 2004/05/10 12:10:50 millert Exp $	*/
a31 8

#ifndef lint
#if 0
static const char sccsid[] = "@@(#)lex.c	8.2 (Berkeley) 4/20/95";
#else
static const char rcsid[] = "$OpenBSD: lex.c,v 1.31 2004/05/10 12:10:50 millert Exp $";
#endif
#endif /* not lint */
@


1.31
log
@Get rid of the ancient "clobber" command.  It was really only for debugging
purposes.  Noticed and OK by deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: lex.c,v 1.30 2003/10/24 20:32:06 avsm Exp $	*/
d37 1
a37 1
static const char rcsid[] = "$OpenBSD: lex.c,v 1.30 2003/10/24 20:32:06 avsm Exp $";
d145 1
a145 1
	setptr(ibuf, 0);
@


1.30
log
@dont compare int to NULL, millert@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: lex.c,v 1.29 2003/10/13 00:46:08 tedu Exp $	*/
d37 1
a37 1
static const char rcsid[] = "$OpenBSD: lex.c,v 1.29 2003/10/13 00:46:08 tedu Exp $";
d429 1
a429 1
		if (msgvec == 0) {
@


1.29
log
@better realloc. ok deraadt jose
@
text
@d1 1
a1 1
/*	$OpenBSD: lex.c,v 1.28 2003/06/03 02:56:11 millert Exp $	*/
d37 1
a37 1
static const char rcsid[] = "$OpenBSD: lex.c,v 1.28 2003/06/03 02:56:11 millert Exp $";
d410 1
a410 1
		if (*msgvec == NULL) {
d440 1
a440 1
		if (*msgvec == NULL) {
@


1.28
log
@Remove the advertising clause in the UCB license which Berkeley
rescinded 22 July 1999.  Proofed by myself and Theo.
@
text
@d1 1
a1 1
/*	$OpenBSD: lex.c,v 1.27 2001/11/21 20:41:55 millert Exp $	*/
d37 1
a37 1
static const char rcsid[] = "$OpenBSD: lex.c,v 1.27 2001/11/21 20:41:55 millert Exp $";
d537 1
d541 1
a541 1
	if ((msgvec = realloc(msgvec, msize)) == NULL)
d543 1
@


1.27
log
@o kill strcpy()
o check return values of malloc and friends
o use strdup() when sensible
@
text
@d1 1
a1 1
/*	$OpenBSD: lex.c,v 1.26 2001/11/21 15:26:39 millert Exp $	*/
d16 1
a16 5
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
d37 1
a37 1
static const char rcsid[] = "$OpenBSD: lex.c,v 1.26 2001/11/21 15:26:39 millert Exp $";
@


1.26
log
@o ANSIfy
o Style nits
o Use const to silent stupid -Wall warnings
o strnc{py,at} -> strlc{py,at}
o Use strpbrk() instead of homegrown anyof()
o Use NULL instead of #defines with 0 cast to a pointer
This still could use a proper audit
@
text
@d1 1
a1 1
/*	$OpenBSD: lex.c,v 1.25 2001/11/20 20:50:00 millert Exp $	*/
d41 1
a41 1
static const char rcsid[] = "$OpenBSD: lex.c,v 1.25 2001/11/20 20:50:00 millert Exp $";
d135 1
a135 1
	strcpy(prevfile, mailname);
d539 1
a539 1
setmsize(int sz)
d541 1
d543 4
a546 3
	if (msgvec != 0)
		(void)free(msgvec);
	msgvec = (int *)calloc(sz + 1, sizeof(*msgvec));
@


1.25
log
@Major signal overhaul.  We no longer longjmp all over the place.
Instead, routines responsible to gathering user input (or in some
cases outputting data) catch the signals and set flags as needed.
Because of this some handlers are install without the SA_RESTART
flag so syscalls are not restarted and we can check the flag.  All
signal handlers are now safe.

This should make the flow of control a bit more grokable but the
code is still ugly.
@
text
@d1 1
a1 1
/*	$OpenBSD: lex.c,v 1.24 2001/11/17 19:10:25 deraadt Exp $	*/
d39 1
a39 1
static char sccsid[] = "@@(#)lex.c	8.2 (Berkeley) 4/20/95";
d41 1
a41 1
static char rcsid[] = "$OpenBSD: lex.c,v 1.24 2001/11/17 19:10:25 deraadt Exp $";
d67 1
a67 2
setfile(name)
	char *name;
a115 1

a123 1

d125 1
a125 1
	if ((i = open(name, 1)) < 0)
d136 2
a137 4
	if (name != mailname) {
		strncpy(mailname, name, sizeof(mailname) - 1);
		mailname[sizeof(mailname) - 1] = '\0';
	}
d173 1
a173 1
incfile()
d214 1
a214 1
commands()
d299 1
a299 3
execute(linebuf, contxt)
	char linebuf[];
	int contxt;
a316 1

a338 1

d342 1
a342 1
	if (com == NONE) {
a350 1

a360 1

d539 1
a539 2
setmsize(sz)
	int sz;
d553 1
a553 2
lex(word)
	char word[];
d563 1
a563 1
	return(NONE);
d571 1
a571 2
isprefix(as1, as2)
	char *as1, *as2;
a589 1

d593 1
a593 1
dointr()
d617 1
a617 1
announce()
d637 1
a637 2
newfileinfo(omsgCount)
	int omsgCount;
d667 1
a667 1
		strncat(fname, "/", sizeof(fname) - strlen(fname) - 1);
a695 1

d698 1
a698 2
pversion(v)
	void *v;
d700 1
a700 1
	extern char *version;
d710 1
a710 2
load(name)
	char *name;
@


1.24
log
@properly bail out of incfile(); millert ok
@
text
@d1 1
a1 1
/*	$OpenBSD: lex.c,v 1.23 2001/06/23 23:04:23 millert Exp $	*/
d41 1
a41 1
static char rcsid[] = "$OpenBSD: lex.c,v 1.23 2001/06/23 23:04:23 millert Exp $";
d212 1
a212 1
int	reset_on_stop;			/* do a reset() if stopped */
d221 2
a222 2
	int n;
	volatile int eofloop = 0;
d225 1
a225 10
	if (!sourcing) {
		if (signal(SIGINT, SIG_IGN) != SIG_IGN)
			(void)signal(SIGINT, intr);
		if (signal(SIGHUP, SIG_IGN) != SIG_IGN)
			(void)signal(SIGHUP, hangup);
		(void)signal(SIGTSTP, stop);
		(void)signal(SIGTTOU, stop);
		(void)signal(SIGTTIN, stop);
	}
	setexit();
d244 2
d247 15
a261 1
			if (readline(input, &linebuf[n], LINESIZE - n) < 0) {
a606 1
/*ARGSUSED*/
d608 1
a608 2
intr(s)
	int s;
a624 36
	reset(0);
}

/*
 * When we wake up after ^Z, reprint the prompt.
 */
void
stop(s)
	int s;
{
	sig_t old_action = signal(s, SIG_DFL);
	sigset_t nset;

	(void)sigemptyset(&nset);
	(void)sigaddset(&nset, s);
	(void)sigprocmask(SIG_UNBLOCK, &nset, NULL);
	(void)kill(0, s);
	(void)sigprocmask(SIG_BLOCK, &nset, NULL);
	(void)signal(s, old_action);
	if (reset_on_stop) {
		reset_on_stop = 0;
		reset(0);
	}
}

/*
 * Branch here on hangup signal and simulate "exit".
 */
/*ARGSUSED*/
void
hangup(s)
	int s;
{

	/* nothing to do? */
	exit(1);
@


1.23
log
@Remove evil #ifdef __GNUC__ garbage to avoid longjmp clobbering and
use volatile instead.
@
text
@d1 1
a1 1
/*	$OpenBSD: lex.c,v 1.22 2001/01/16 05:36:08 millert Exp $	*/
d41 1
a41 1
static char rcsid[] = "$OpenBSD: lex.c,v 1.22 2001/01/16 05:36:08 millert Exp $";
d188 3
a190 1
	if (!spool_lock())
d192 1
d196 1
@


1.22
log
@Changes from Don Beusee:
o escape From line with a leading '>' when needed
o only print To: address and Subject lines if actually present
o new variable 'allnet' to treat user@@foo and user@@bar as the same "user"
o folders command now takes an optional argument like ls.
o new "pipe" (|) command to pipe the message through an arbitrary command
o make header display format the same as SunOS 4.1.3 /usr/ucb/mail
o tilde commands work regardless of interactive mode.
o fix "read: Interrupted system call" error by retrying if EINTR
o expanded help file
Changes by me:
o read the help file via the PAGER as it is now more than 24 lines long
@
text
@d1 1
a1 1
/*	$OpenBSD: lex.c,v 1.21 2000/07/06 06:24:21 deraadt Exp $	*/
d41 1
a41 1
static char rcsid[] = "$OpenBSD: lex.c,v 1.21 2000/07/06 06:24:21 deraadt Exp $";
d217 2
a218 1
	int n, eofloop = 0;
a219 4
#if __GNUC__
	/* Avoid siglongjmp clobbering */
	(void)&eofloop;
#endif
@


1.21
log
@printf with % for the prompt
@
text
@d1 1
a1 1
/*	$OpenBSD: lex.c,v 1.20 2000/06/30 16:00:19 millert Exp $	*/
d41 1
a41 1
static char rcsid[] = "$OpenBSD: lex.c,v 1.20 2000/06/30 16:00:19 millert Exp $";
d58 2
a301 1
	const struct cmd *com = NULL;
d306 2
d384 47
a666 1
	clearnew();
@


1.20
log
@warnx?/errx? paranoia (use "%s" not a bare string unless it is a
constant).  These are not security holes but it is worth fixing
them anyway both for robustness and so folks looking for examples
in the tree are not misled into doing something potentially dangerous.
Furthermore, it is a bad idea to assume that pathnames will not
include '%' in them and that error routines don't return strings
with '%' in them (especially in light of the possibility of locales).
@
text
@d1 1
a1 1
/*	$OpenBSD: lex.c,v 1.19 2000/04/25 16:42:22 millert Exp $	*/
d41 1
a41 1
static char rcsid[] = "$OpenBSD: lex.c,v 1.19 2000/04/25 16:42:22 millert Exp $";
d241 1
a241 1
			printf(prompt);
@


1.19
log
@When incorporating new messages, clear the "new" count before the
inc so the count of new messages is useful afterwards.  This makes
mail behave more like the SunOS version in this respect.
@
text
@d1 1
a1 1
/*	$OpenBSD: lex.c,v 1.18 1998/09/08 14:59:12 millert Exp $	*/
d41 1
a41 1
static char rcsid[] = "$OpenBSD: lex.c,v 1.18 1998/09/08 14:59:12 millert Exp $";
d82 1
a82 1
		warn(name);
d96 1
a96 1
		warn(name);
d105 1
a105 1
		warn(name);
d146 1
a146 1
		err(1, tempname);
d149 1
a149 1
		err(1, tempname);
@


1.19.2.1
log
@Pull in patch from current (even more to come):
Fix (millert):
warnx?/errx? paranoia (use "%s" not a bare string unless it is a
constant).  These are not security holes but it is worth fixing
them anyway both for robustness and so folks looking for examples
in the tree are not misled into doing something potentially dangerous.
Furthermore, it is a bad idea to assume that pathnames will not
include '%' in them and that error routines don't return strings
with '%' in them (especially in light of the possibility of locales).
@
text
@d1 1
a1 1
/*	$OpenBSD: lex.c,v 1.20 2000/06/30 16:00:19 millert Exp $	*/
d41 1
a41 1
static char rcsid[] = "$OpenBSD: lex.c,v 1.20 2000/06/30 16:00:19 millert Exp $";
d82 1
a82 1
		warn("%s", name);
d96 1
a96 1
		warn("%s", name);
d105 1
a105 1
		warn("%s", name);
d146 1
a146 1
		err(1, "%s", tempname);
d149 1
a149 1
		err(1, "%s", tempname);
@


1.18
log
@Fix comments in .mailrc where there is no space after the hash (#).  Noted by pjanzen@@foatdi.harvard.edu
@
text
@d1 1
a1 1
/*	$OpenBSD: lex.c,v 1.17 1998/06/12 18:07:57 millert Exp $	*/
d41 1
a41 1
static char rcsid[] = "$OpenBSD: lex.c,v 1.17 1998/06/12 18:07:57 millert Exp $";
d617 1
@


1.17
log
@back out some signal changes that can cause mail to hang when quitting due to SIGCHLD blockage
@
text
@d1 1
a1 1
/*	$OpenBSD: lex.c,v 1.16 1998/05/04 05:37:49 millert Exp $	*/
d41 1
a41 1
static char rcsid[] = "$OpenBSD: lex.c,v 1.16 1998/05/04 05:37:49 millert Exp $";
d513 2
@


1.16
log
@Never remove a mail spool, as we may not have proper prics, just truncate.  Also block signals in a few critical areas
@
text
@d1 1
a1 1
/*	$OpenBSD: lex.c,v 1.15 1997/11/14 00:23:48 millert Exp $	*/
d41 1
a41 1
static char rcsid[] = "$OpenBSD: lex.c,v 1.15 1997/11/14 00:23:48 millert Exp $";
a551 1
	sigset_t set, oset;
a552 2
	(void)sigfillset(&set);
	(void)sigprocmask(SIG_BLOCK, &set, &oset);
a567 1
	(void)sigprocmask(SIG_SETMASK, &oset, NULL);
@


1.15
log
@NetBSD changes (mostly comsmetic):
    replace panic() with calls to err()/errx()
    use S_IS* instead of doing by hand with S_IF*.
    Use TIMESPEC_TO_TIMEVAL() and gettimeofday instead of time(2)
    Use _POSIX_VDISABLE, not 0
    Kill register
@
text
@d1 1
a1 1
/*	$OpenBSD: lex.c,v 1.14 1997/07/30 07:19:31 millert Exp $	*/
d41 1
a41 1
static char rcsid[] = "$OpenBSD: lex.c,v 1.14 1997/07/30 07:19:31 millert Exp $";
d552 1
d554 2
d571 1
@


1.14
log
@Make istrcpy() take a size (not length) field, now called istrncpy().
Change some strcpy() -> strncpy() out of paranoia.
@
text
@d1 1
a1 1
/*	$OpenBSD: lex.c,v 1.13 1997/07/30 06:32:40 millert Exp $	*/
d41 1
a41 1
static char rcsid[] = "$OpenBSD: lex.c,v 1.13 1997/07/30 06:32:40 millert Exp $";
d215 1
a215 2
	int eofloop = 0;
	register int n;
d301 2
a302 3
	register char *cp, *cp2;
	register int c;
	int muvec[2];
d457 1
a457 1
		panic("Unknown argtype");
d511 1
a511 1
	register const struct cmd *cp;
d527 1
a527 1
	register char *s1, *s2;
d633 2
a634 2
	register struct message *mp;
	register int u, n, mdot, d, s;
d709 1
a709 1
	register FILE *in, *oldin;
@


1.13
log
@Fix one possible oflow (not exploitable) and do a wee bit of KNF.
Much more remains to be done.
@
text
@d1 1
a1 1
/*	$OpenBSD: lex.c,v 1.12 1997/07/24 17:27:11 millert Exp $	*/
d41 1
a41 1
static char rcsid[] = "$OpenBSD: lex.c,v 1.12 1997/07/24 17:27:11 millert Exp $";
d137 4
a140 2
	if (name != mailname)
		strcpy(mailname, name);
@


1.12
log
@tempnam(3) goes bye bye.
@
text
@d1 1
a1 1
/*	$OpenBSD: lex.c,v 1.11 1997/07/24 16:23:38 millert Exp $	*/
d41 1
a41 1
static char rcsid[] = "$OpenBSD: lex.c,v 1.11 1997/07/24 16:23:38 millert Exp $";
d223 1
a223 1
			signal(SIGINT, intr);
d225 4
a228 4
			signal(SIGHUP, hangup);
		signal(SIGTSTP, stop);
		signal(SIGTTOU, stop);
		signal(SIGTTIN, stop);
d580 6
a585 6
	sigemptyset(&nset);
	sigaddset(&nset, s);
	sigprocmask(SIG_UNBLOCK, &nset, NULL);
	kill(0, s);
	sigprocmask(SIG_BLOCK, &nset, NULL);
	signal(s, old_action);
@


1.11
log
@Replace 3 tempnam()'s with mkstemp.  The two left look tricky.
@
text
@d1 1
a1 1
/*	$OpenBSD: lex.c,v 1.10 1997/07/22 19:13:25 millert Exp $	*/
d41 1
a41 1
static char rcsid[] = "$OpenBSD: lex.c,v 1.10 1997/07/22 19:13:25 millert Exp $";
d73 1
a73 1
	char tempname[MAXPATHLEN];
d149 1
a149 1
	rm(tempname);
d663 1
a663 1
			snprintf(zname, sizeof(zname), "+%s",
@


1.10
log
@incfile() needs to lock the mail spool so it doesn't get partial messages.
Noticed by Theo.
@
text
@d1 1
a1 1
/*	$OpenBSD: lex.c,v 1.9 1997/07/22 06:46:20 millert Exp $	*/
d41 1
a41 1
static char rcsid[] = "$OpenBSD: lex.c,v 1.9 1997/07/22 06:46:20 millert Exp $";
d69 1
a69 1
	int i;
d73 1
a74 1
	extern char *tempMesg;
d140 5
a144 2
	if ((otf = fopen(tempMesg, "w")) == NULL)
		err(1, tempMesg);
d146 2
a147 2
	if ((itf = fopen(tempMesg, "r")) == NULL)
		err(1, tempMesg);
d149 1
a149 1
	rm(tempMesg);
@


1.9
log
@Release signals when we get an error condition in incfile().
@
text
@d1 1
a1 1
/*	$OpenBSD: lex.c,v 1.8 1997/07/14 00:24:27 millert Exp $	*/
d41 1
a41 1
static char rcsid[] = "$OpenBSD: lex.c,v 1.8 1997/07/14 00:24:27 millert Exp $";
d181 2
d186 1
d194 1
@


1.8
log
@NOSTR -> NULL
Use sigsetjmp/siglongjmp instead of sigjmp/longjmp for portability.
@
text
@d1 1
a1 1
/*	$OpenBSD: lex.c,v 1.7 1997/07/13 23:54:00 millert Exp $	*/
d41 1
a41 1
static char rcsid[] = "$OpenBSD: lex.c,v 1.7 1997/07/13 23:54:00 millert Exp $";
a74 1
	extern int errno;
d182 5
a186 6
	if (newsize == 0)
		return(-1);		/* mail box is now empty??? */
	if (newsize < mailsize)
		return(-1);		/* mail box has shrunk??? */
	if (newsize == mailsize)
		return(0);		/* no new mail */
@


1.7
log
@bcopy() -> memcpy() and fix some casts.
@
text
@d1 1
a1 1
/*	$OpenBSD: lex.c,v 1.6 1997/07/13 21:21:13 millert Exp $	*/
d41 1
a41 1
static char rcsid[] = "$OpenBSD: lex.c,v 1.6 1997/07/13 21:21:13 millert Exp $";
d77 1
a77 1
	if ((name = expand(name)) == NOSTR)
d212 1
a212 1
	/* Avoid longjmp clobbering */
d231 2
a232 2
		if (!sourcing && value("interactive") != NOSTR) {
			if ((value("autoinc") != NOSTR) && (incfile() > 0))
d266 2
a267 2
			if (value("interactive") != NOSTR &&
			    value("ignoreeof") != NOSTR &&
d320 1
a320 1
	while (*cp && strchr(" \t0123456789$^.:/-+*'\"", *cp) == NOSTR)
d471 1
a471 1
	if (value("autoprint") != NOSTR && com->c_argtype & P)
d508 1
a508 1
	for (cp = &cmdtab[0]; cp->c_name != NOSTR; cp++)
d613 1
a613 1
	if (msgCount > 0 && value("noheader") == NOSTR) {
@


1.6
log
@Merge in NetBSD and 4.4BSD-lite2 changes as well as some of my own.
 - handle long lines safely (from NetBSD)
 - use puts/fputs and putchar/putc when it makes sense
 - use err/errx and warn/warnx when it makes sense
 - make return() and sizeof() style consisten
 - some more buffer safety
@
text
@d1 1
a1 1
/*	$OpenBSD: lex.c,v 1.5 1997/05/30 08:51:40 deraadt Exp $	*/
d41 1
a41 1
static char rcsid[] = "$OpenBSD: lex.c,v 1.5 1997/05/30 08:51:40 deraadt Exp $";
d143 1
a143 1
	(void) fcntl(fileno(otf), F_SETFD, 1);
d146 1
a146 1
	(void) fcntl(fileno(itf), F_SETFD, 1);
d213 1
a213 1
	(void) &eofloop;
d492 2
a493 2
		free((char *) msgvec);
	msgvec = (int *) calloc((unsigned) (sz + 1), sizeof(*msgvec));
@


1.5
log
@overflows abound
@
text
@d1 2
a2 2
/*	$OpenBSD: lex.c,v 1.4 1997/01/17 07:12:47 millert Exp $	*/
/*	$NetBSD: lex.c,v 1.7 1996/06/08 19:48:28 christos Exp $	*/
d39 1
a39 1
static char sccsid[] = "@@(#)lex.c	8.1 (Berkeley) 6/6/93";
d41 1
a41 1
static char rcsid[] = "$OpenBSD: lex.c,v 1.4 1997/01/17 07:12:47 millert Exp $";
d78 1
a78 1
		return -1;
d83 1
a83 1
		perror(name);
d88 3
a90 3
		perror("fstat");
		Fclose(ibuf);
		return (-1);
d95 1
a95 1
		Fclose(ibuf);
d97 2
a98 2
		perror(name);
		return (-1);
d104 1
a104 1
		Fclose(ibuf);
d106 2
a107 2
		perror(name);
		return (-1);
d130 1
a130 1
		close(i);
d132 2
a133 2
		fclose(itf);
		fclose(otf);
d141 2
a142 4
	if ((otf = fopen(tempMesg, "w")) == NULL) {
		perror(tempMesg);
		exit(1);
	}
d144 2
a145 4
	if ((itf = fopen(tempMesg, "r")) == NULL) {
		perror(tempMesg);
		exit(1);
	}
d148 1
a148 1
	setptr(ibuf);
d150 7
a156 1
	Fclose(ibuf);
d162 1
a162 1
		return -1;
d167 31
d232 2
d269 1
a269 1
				printf("Use \"quit\" to quit.\n");
d313 1
a313 1
			printf("Can't \"!\" while sourcing\n");
d382 1
a382 1
			printf("Illegal use of \"message list\"\n");
d393 1
a393 1
			printf("No applicable messages\n");
d405 1
a405 1
			printf("Illegal use of \"message list\"\n");
d428 1
a428 1
				sizeof arglist / sizeof *arglist)) < 0)
d462 1
a462 1
			return 1;
d464 1
a464 1
			return 1;
d467 1
a467 1
		return 0;
d493 1
a493 1
	msgvec = (int *) calloc((unsigned) (sz + 1), sizeof *msgvec);
d558 1
a558 1
		close(image);
d561 1
a561 1
	fprintf(stderr, "Interrupt\n");
d609 1
a609 1
	mdot = newfileinfo();
d625 2
a626 1
newfileinfo()
d630 1
a630 1
	char fname[PATHSIZE+1], zname[PATHSIZE+1], *ename;
d632 1
a632 1
	for (mp = &message[0]; mp < &message[msgCount]; mp++)
d636 1
a636 1
		for (mp = &message[0]; mp < &message[msgCount]; mp++)
d642 1
a642 1
		mdot = 1;
d655 2
a656 2
	if (getfold(fname, sizeof fname) >= 0) {
		strcat(fname, "/");
d658 2
a659 1
			snprintf(zname, sizeof zname, "+%s", mailname + strlen(fname));
d665 1
a665 1
		printf("1 message");
d677 2
a678 2
		printf(" [Read only]");
	printf("\n");
d716 1
a716 1
	Fclose(in);
@


1.4
log
@r?index -> strr?chr
@
text
@d1 1
a1 1
/*	$OpenBSD: lex.c,v 1.3 1996/06/11 12:53:42 deraadt Exp $	*/
d41 1
a41 1
static char rcsid[] = "$OpenBSD: lex.c,v 1.3 1996/06/11 12:53:42 deraadt Exp $";
d594 1
a594 1
	char fname[BUFSIZ], zname[BUFSIZ], *ename;
d619 1
a619 1
	if (getfold(fname) >= 0) {
d622 1
a622 1
			sprintf(zname, "+%s", mailname + strlen(fname));
@


1.3
log
@from christos;
- Fix PR/105: Implement dot locking protocol and check return value of flock.
- Fix PR/2247: Don't call unknown users "ubluit". Issue an error message.
- Fix/add prototypes.
- Fix warnings.
- Use POSIX signal mask calls.
@
text
@d1 1
a1 1
/*	$OpenBSD: lex.c,v 1.7 1996/06/08 19:48:28 christos Exp $	*/
d41 1
a41 1
static char rcsid[] = "$OpenBSD: lex.c,v 1.7 1996/06/08 19:48:28 christos Exp $";
d285 1
a285 1
	while (*cp && index(" \t0123456789$^.:/-+*'\"", *cp) == NOSTR)
@


1.2
log
@From NetBSD: merge of 960317
@
text
@d1 2
a2 1
/*	$OpenBSD$	*/
d38 5
a42 2
static char sccsid[] = "from: @@(#)lex.c	8.1 (Berkeley) 6/6/93";
static char rcsid[] = "$OpenBSD$";
d178 4
a181 1
	void intr(), stop(), hangup();
d259 1
a259 1
	const struct cmd *com;
d311 1
a311 1
		if (cond == CRCV && !rcvmode || cond == CSEND && rcvmode)
d434 2
d538 1
d540 3
a542 1
	sigsetmask(sigblock(0) & ~sigmask(s));
d544 1
a544 1
	sigblock(sigmask(s));
d651 2
a652 2
pversion(e)
	int e;
@


1.1
log
@Initial revision
@
text
@d1 2
d38 1
a38 1
static char rcsid[] = "$Id: lex.c,v 1.5 1994/11/28 20:03:33 jtc Exp $";
d252 1
a252 1
	struct cmd *com;
d457 1
a457 1
struct cmd *
d461 2
a462 2
	register struct cmd *cp;
	extern struct cmd cmdtab[];
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@
