head	1.20;
access;
symbols
	OPENBSD_6_1_BASE:1.20
	OPENBSD_6_0:1.20.0.4
	OPENBSD_6_0_BASE:1.20
	OPENBSD_5_9:1.20.0.2
	OPENBSD_5_9_BASE:1.20
	OPENBSD_5_8:1.19.0.10
	OPENBSD_5_8_BASE:1.19
	OPENBSD_5_7:1.19.0.2
	OPENBSD_5_7_BASE:1.19
	OPENBSD_5_6:1.19.0.6
	OPENBSD_5_6_BASE:1.19
	OPENBSD_5_5:1.19.0.4
	OPENBSD_5_5_BASE:1.19
	OPENBSD_5_4:1.18.0.16
	OPENBSD_5_4_BASE:1.18
	OPENBSD_5_3:1.18.0.14
	OPENBSD_5_3_BASE:1.18
	OPENBSD_5_2:1.18.0.12
	OPENBSD_5_2_BASE:1.18
	OPENBSD_5_1_BASE:1.18
	OPENBSD_5_1:1.18.0.10
	OPENBSD_5_0:1.18.0.8
	OPENBSD_5_0_BASE:1.18
	OPENBSD_4_9:1.18.0.6
	OPENBSD_4_9_BASE:1.18
	OPENBSD_4_8:1.18.0.4
	OPENBSD_4_8_BASE:1.18
	OPENBSD_4_7:1.18.0.2
	OPENBSD_4_7_BASE:1.18
	OPENBSD_4_6:1.17.0.8
	OPENBSD_4_6_BASE:1.17
	OPENBSD_4_5:1.17.0.4
	OPENBSD_4_5_BASE:1.17
	OPENBSD_4_4:1.17.0.2
	OPENBSD_4_4_BASE:1.17
	OPENBSD_4_3:1.16.0.12
	OPENBSD_4_3_BASE:1.16
	OPENBSD_4_2:1.16.0.10
	OPENBSD_4_2_BASE:1.16
	OPENBSD_4_1:1.16.0.8
	OPENBSD_4_1_BASE:1.16
	OPENBSD_4_0:1.16.0.6
	OPENBSD_4_0_BASE:1.16
	OPENBSD_3_9:1.16.0.4
	OPENBSD_3_9_BASE:1.16
	OPENBSD_3_8:1.16.0.2
	OPENBSD_3_8_BASE:1.16
	OPENBSD_3_7:1.15.0.2
	OPENBSD_3_7_BASE:1.15
	OPENBSD_3_6:1.14.0.4
	OPENBSD_3_6_BASE:1.14
	OPENBSD_3_5:1.14.0.2
	OPENBSD_3_5_BASE:1.14
	OPENBSD_3_4:1.13.0.2
	OPENBSD_3_4_BASE:1.13
	OPENBSD_3_3:1.12.0.6
	OPENBSD_3_3_BASE:1.12
	OPENBSD_3_2:1.12.0.4
	OPENBSD_3_2_BASE:1.12
	OPENBSD_3_1:1.12.0.2
	OPENBSD_3_1_BASE:1.12
	OPENBSD_3_0:1.10.0.4
	OPENBSD_3_0_BASE:1.10
	OPENBSD_2_9_BASE:1.10
	OPENBSD_2_9:1.10.0.2
	OPENBSD_2_8:1.9.0.12
	OPENBSD_2_8_BASE:1.9
	OPENBSD_2_7:1.9.0.10
	OPENBSD_2_7_BASE:1.9
	OPENBSD_2_6:1.9.0.8
	OPENBSD_2_6_BASE:1.9
	OPENBSD_2_5:1.9.0.6
	OPENBSD_2_5_BASE:1.9
	OPENBSD_2_4:1.9.0.4
	OPENBSD_2_4_BASE:1.9
	OPENBSD_2_3:1.9.0.2
	OPENBSD_2_3_BASE:1.9
	OPENBSD_2_2:1.8.0.2
	OPENBSD_2_2_BASE:1.8
	OPENBSD_2_1:1.3.0.2
	OPENBSD_2_1_BASE:1.3
	OPENBSD_2_0:1.2.0.2
	OPENBSD_2_0_BASE:1.2
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.20
date	2015.10.16.17.56.07;	author mmcc;	state Exp;
branches;
next	1.19;
commitid	y3aqfd1wS5RZj9kl;

1.19
date	2014.01.17.18.42.30;	author okan;	state Exp;
branches;
next	1.18;

1.18
date	2009.10.27.23.59.40;	author deraadt;	state Exp;
branches;
next	1.17;

1.17
date	2008.07.15.19.23.26;	author martynas;	state Exp;
branches;
next	1.16;

1.16
date	2005.07.11.14.08.23;	author millert;	state Exp;
branches;
next	1.15;

1.15
date	2004.09.15.22.21.40;	author deraadt;	state Exp;
branches;
next	1.14;

1.14
date	2003.10.13.00.46.08;	author tedu;	state Exp;
branches;
next	1.13;

1.13
date	2003.06.03.02.56.11;	author millert;	state Exp;
branches;
next	1.12;

1.12
date	2001.11.21.20.41.55;	author millert;	state Exp;
branches;
next	1.11;

1.11
date	2001.11.21.15.26.39;	author millert;	state Exp;
branches;
next	1.10;

1.10
date	2001.01.16.05.36.08;	author millert;	state Exp;
branches;
next	1.9;

1.9
date	97.11.14.00.23.49;	author millert;	state Exp;
branches;
next	1.8;

1.8
date	97.08.04.17.30.22;	author millert;	state Exp;
branches;
next	1.7;

1.7
date	97.07.31.02.36.33;	author millert;	state Exp;
branches;
next	1.6;

1.6
date	97.07.14.00.24.28;	author millert;	state Exp;
branches;
next	1.5;

1.5
date	97.07.13.21.21.14;	author millert;	state Exp;
branches;
next	1.4;

1.4
date	97.05.30.08.51.42;	author deraadt;	state Exp;
branches;
next	1.3;

1.3
date	97.01.17.07.12.49;	author millert;	state Exp;
branches;
next	1.2;

1.2
date	96.06.11.12.53.43;	author deraadt;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.45.39;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.45.39;	author deraadt;	state Exp;
branches;
next	;


desc
@@


1.20
log
@Modernize allocation by:

 * removing unneeded casts of void* return values
 * replacing varied and creative error messages with the allocation
   function's name
 * replacing errx() with err() so that the errno string is reported

ok beck@@, jung@@, millert@@
@
text
@/*	$OpenBSD: list.c,v 1.19 2014/01/17 18:42:30 okan Exp $	*/
/*	$NetBSD: list.c,v 1.7 1997/07/09 05:23:36 mikel Exp $	*/

/*
 * Copyright (c) 1980, 1993
 *	The Regents of the University of California.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */

#include "rcv.h"
#include <ctype.h>
#include "extern.h"

int matchto(char *, int);

/*
 * Mail -- a mail program
 *
 * Message list handling.
 */

/*
 * Convert the user string of message numbers and
 * store the numbers into vector.
 *
 * Returns the count of messages picked up or -1 on error.
 */
int
getmsglist(char *buf, int *vector, int flags)
{
	int *ip;
	struct message *mp;

	if (msgCount == 0) {
		*vector = 0;
		return(0);
	}
	if (markall(buf, flags) < 0)
		return(-1);
	ip = vector;
	for (mp = &message[0]; mp < &message[msgCount]; mp++)
		if (mp->m_flag & MMARK)
			*ip++ = mp - &message[0] + 1;
	*ip = 0;
	return(ip - vector);
}

/*
 * Mark all messages that the user wanted from the command
 * line in the message structure.  Return 0 on success, -1
 * on error.
 */

/*
 * Bit values for colon modifiers.
 */
#define	CMNEW		01		/* New messages */
#define	CMOLD		02		/* Old messages */
#define	CMUNREAD	04		/* Unread messages */
#define	CMDELETED	010		/* Deleted messages */
#define	CMREAD		020		/* Read messages */

/*
 * The following table describes the letters which can follow
 * the colon and gives the corresponding modifier bit.
 */
struct coltab {
	char	co_char;		/* What to find past : */
	int	co_bit;			/* Associated modifier bit */
	int	co_mask;		/* m_status bits to mask */
	int	co_equal;		/* ... must equal this */
} coltab[] = {
	{ 'n',		CMNEW,		MNEW,		MNEW },
	{ 'o',		CMOLD,		MNEW,		0 },
	{ 'u',		CMUNREAD,	MREAD,		0 },
	{ 'd',		CMDELETED,	MDELETED,	MDELETED },
	{ 'r',		CMREAD,		MREAD,		MREAD },
	{ 0,		0,		0,		0 }
};

static int lastcolmod;

int
markall(char *buf, int f)
{
	char **np;
	int i;
	struct message *mp;
	char *namelist[NMLSIZE], *bufp;
	int tok, beg, mc, star, other, valdot, colmod, colresult;

	valdot = dot - &message[0] + 1;
	colmod = 0;
	for (i = 1; i <= msgCount; i++)
		unmark(i);
	bufp = buf;
	mc = 0;
	np = &namelist[0];
	scaninit();
	tok = scan(&bufp);
	star = 0;
	other = 0;
	beg = 0;
	while (tok != TEOL) {
		switch (tok) {
		case TNUMBER:
number:
			if (star) {
				puts("No numbers mixed with *");
				return(-1);
			}
			mc++;
			other++;
			if (beg != 0) {
				if (check(lexnumber, f))
					return(-1);
				for (i = beg; i <= lexnumber; i++)
					if (f == MDELETED || (message[i - 1].m_flag & MDELETED) == 0)
						mark(i);
				beg = 0;
				break;
			}
			beg = lexnumber;
			if (check(beg, f))
				return(-1);
			tok = scan(&bufp);
			regret(tok);
			if (tok != TDASH) {
				mark(beg);
				beg = 0;
			}
			break;

		case TPLUS:
			if (beg != 0) {
				puts("Non-numeric second argument");
				return(-1);
			}
			i = valdot;
			do {
				i++;
				if (i > msgCount) {
					puts("Referencing beyond EOF");
					return(-1);
				}
			} while ((message[i - 1].m_flag & MDELETED) != f);
			mark(i);
			break;

		case TDASH:
			if (beg == 0) {
				i = valdot;
				do {
					i--;
					if (i <= 0) {
						puts("Referencing before 1");
						return(-1);
					}
				} while ((message[i - 1].m_flag & MDELETED) != f);
				mark(i);
			}
			break;

		case TSTRING:
			if (beg != 0) {
				puts("Non-numeric second argument");
				return(-1);
			}
			other++;
			if (lexstring[0] == ':') {
				colresult = evalcol(lexstring[1]);
				if (colresult == 0) {
					printf("Unknown colon modifier \"%s\"\n",
					    lexstring);
					return(-1);
				}
				colmod |= colresult;
			} else {
				if ((com->c_argtype & ~(F|P|I|M|T|W|R))
							!= (MSGLIST|STRLIST))
					*np++ = savestr(lexstring);
			}
			break;

		case TDOLLAR:
		case TUP:
		case TDOT:
			lexnumber = metamess(lexstring[0], f);
			if (lexnumber == -1)
				return(-1);
			goto number;

		case TSTAR:
			if (other) {
				puts("Can't mix \"*\" with anything");
				return(-1);
			}
			star++;
			break;

		case TERROR:
			return(-1);
		}
		tok = scan(&bufp);
	}
	lastcolmod = colmod;
	*np = NULL;
	mc = 0;
	if (star) {
		for (i = 0; i < msgCount; i++)
			if ((message[i].m_flag & MDELETED) == f) {
				mark(i+1);
				mc++;
			}
		if (mc == 0) {
			puts("No applicable messages.");
			return(-1);
		}
		return(0);
	}

	/*
	 * If no numbers were given, mark all of the messages,
	 * so that we can unmark any whose sender was not selected
	 * if any user names were given.
	 */
	if ((np > namelist || colmod != 0) && mc == 0)
		for (i = 1; i <= msgCount; i++)
			if ((message[i-1].m_flag & MDELETED) == f)
				mark(i);

	/*
	 * If any names were given, go through and eliminate any
	 * messages whose senders were not requested.
	 */
	if (np > namelist) {
		for (i = 1; i <= msgCount; i++) {
			for (mc = 0, np = &namelist[0]; *np != NULL; np++)
				if (**np == '/') {
					if (matchsubj(*np, i)) {
						mc++;
						break;
					}
				}
				else {
					if (matchsender(*np, i)) {
						mc++;
						break;
					}
				}
			if (mc == 0)
				unmark(i);
		}

		/*
		 * Make sure we got some decent messages.
		 */
		mc = 0;
		for (i = 1; i <= msgCount; i++)
			if (message[i-1].m_flag & MMARK) {
				mc++;
				break;
			}
		if (mc == 0) {
			printf("No applicable messages from {%s",
				namelist[0]);
			for (np = &namelist[1]; *np != NULL; np++)
				printf(", %s", *np);
			puts("}");
			return(-1);
		}
	}

	/*
	 * If any colon modifiers were given, go through and
	 * unmark any messages which do not satisfy the modifiers.
	 */
	if (colmod != 0) {
		for (i = 1; i <= msgCount; i++) {
			struct coltab *colp;

			mp = &message[i - 1];
			for (colp = &coltab[0]; colp->co_char; colp++)
				if (colp->co_bit & colmod)
					if ((mp->m_flag & colp->co_mask)
					    != colp->co_equal)
						unmark(i);
		}
		for (mp = &message[0]; mp < &message[msgCount]; mp++)
			if (mp->m_flag & MMARK)
				break;
		if (mp >= &message[msgCount]) {
			struct coltab *colp;

			fputs("No messages satisfy", stdout);
			for (colp = &coltab[0]; colp->co_char; colp++)
				if (colp->co_bit & colmod)
					printf(" :%c", colp->co_char);
			putchar('\n');
			return(-1);
		}
	}
	return(0);
}

/*
 * Turn the character after a colon modifier into a bit
 * value.
 */
int
evalcol(int col)
{
	struct coltab *colp;

	if (col == 0)
		return(lastcolmod);
	for (colp = &coltab[0]; colp->co_char; colp++)
		if (colp->co_char == col)
			return(colp->co_bit);
	return(0);
}

/*
 * Check the passed message number for legality and proper flags.
 * If f is MDELETED, then either kind will do.  Otherwise, the message
 * has to be undeleted.
 */
int
check(int mesg, int f)
{
	struct message *mp;

	if (mesg < 1 || mesg > msgCount) {
		printf("%d: Invalid message number\n", mesg);
		return(-1);
	}
	mp = &message[mesg-1];
	if (f != MDELETED && (mp->m_flag & MDELETED) != 0) {
		printf("%d: Inappropriate message\n", mesg);
		return(-1);
	}
	return(0);
}

/*
 * Scan out the list of string arguments, shell style
 * for a RAWLIST.
 */
int
getrawlist(char *line, char **argv, int argc)
{
	char c, *cp, *cp2, quotec;
	int argn;
	char *linebuf, *linebuf2;
	size_t newsize, linebufsize = BUFSIZ;

	if ((linebuf = malloc(linebufsize)) == NULL)
		err(1, "malloc");

	argn = 0;
	cp = line;
	for (;;) {
		for (; *cp == ' ' || *cp == '\t'; cp++)
			;
		if (*cp == '\0')
			break;
		if (argn >= argc - 1) {
			puts("Too many elements in the list; excess discarded.");
			break;
		}
		cp2 = linebuf;
		quotec = '\0';
		while ((c = *cp) != '\0') {
			/* Alloc more space if necessary */
			if (cp2 - linebuf == linebufsize - 1) {
				newsize = linebufsize + BUFSIZ;
				linebuf2 = realloc(linebuf, newsize);
				if (linebuf2 == NULL)
					err(1, "realloc");
				linebuf = linebuf2;
				linebufsize = newsize;
				cp2 = linebuf + linebufsize - BUFSIZ - 1;
			}
			cp++;
			if (quotec != '\0') {
				if (c == quotec)
					quotec = '\0';
				else if (c == '\\')
					switch (c = *cp++) {
					case '\0':
						*cp2++ = '\\';
						cp--;
						break;
					case '0': case '1': case '2': case '3':
					case '4': case '5': case '6': case '7':
						c -= '0';
						if (*cp >= '0' && *cp <= '7')
							c = c * 8 + *cp++ - '0';
						if (*cp >= '0' && *cp <= '7')
							c = c * 8 + *cp++ - '0';
						*cp2++ = c;
						break;
					case 'b':
						*cp2++ = '\b';
						break;
					case 'f':
						*cp2++ = '\f';
						break;
					case 'n':
						*cp2++ = '\n';
						break;
					case 'r':
						*cp2++ = '\r';
						break;
					case 't':
						*cp2++ = '\t';
						break;
					case 'v':
						*cp2++ = '\v';
						break;
					default:
						*cp2++ = c;
					}
				else if (c == '^') {
					c = *cp++;
					if (c == '?')
						*cp2++ = '\177';
					/* null doesn't show up anyway */
					else if ((c >= 'A' && c <= '_') ||
						 (c >= 'a' && c <= 'z'))
						*cp2++ = c & 037;
					else {
						*cp2++ = '^';
						cp--;
					}
				} else
					*cp2++ = c;
			} else if (c == '"' || c == '\'')
				quotec = c;
			else if (c == ' ' || c == '\t')
				break;
			else
				*cp2++ = c;
		}
		*cp2 = '\0';
		argv[argn++] = savestr(linebuf);
	}
	argv[argn] = NULL;
	(void)free(linebuf);
	return(argn);
}

/*
 * Scan out a single lexical item and return its token number,
 * updating the string pointer passed **p.  Also, store the value
 * of the number or string scanned in lexnumber or lexstring as
 * appropriate.  In any event, store the scanned `thing' in lexstring.
 */
struct lex {
	char	l_char;
	char	l_token;
} singles[] = {
	{ '$',	TDOLLAR },
	{ '.',	TDOT },
	{ '^',	TUP },
	{ '*',	TSTAR },
	{ '-',	TDASH },
	{ '+',	TPLUS },
	{ '(',	TOPEN },
	{ ')',	TCLOSE },
	{ 0,	0 }
};

int
scan(char **sp)
{
	char *cp, *cp2;
	int c;
	struct lex *lp;
	int quotec;

	if (regretp >= 0) {
		strlcpy(lexstring, string_stack[regretp], STRINGLEN);
		lexnumber = numberstack[regretp];
		return(regretstack[regretp--]);
	}
	cp = *sp;
	cp2 = lexstring;
	c = (unsigned char)*cp++;

	/*
	 * strip away leading white space.
	 */
	while (c == ' ' || c == '\t')
		c = (unsigned char)*cp++;

	/*
	 * If no characters remain, we are at end of line,
	 * so report that.
	 */
	if (c == '\0') {
		*sp = --cp;
		return(TEOL);
	}

	/*
	 * If the leading character is a digit, scan
	 * the number and convert it on the fly.
	 * Return TNUMBER when done.
	 */
	if (isdigit(c)) {
		lexnumber = 0;
		while (isdigit(c)) {
			lexnumber = lexnumber*10 + c - '0';
			if (cp2 - lexstring < STRINGLEN - 1)
				*cp2++ = c;
			c = (unsigned char)*cp++;
		}
		*cp2 = '\0';
		*sp = --cp;
		return(TNUMBER);
	}

	/*
	 * Check for single character tokens; return such
	 * if found.
	 */
	for (lp = &singles[0]; lp->l_char != 0; lp++)
		if (c == lp->l_char) {
			lexstring[0] = c;
			lexstring[1] = '\0';
			*sp = cp;
			return(lp->l_token);
		}

	/*
	 * We've got a string!  Copy all the characters
	 * of the string into lexstring, until we see
	 * a null, space, or tab.
	 * If the lead character is a " or ', save it
	 * and scan until you get another.
	 */
	quotec = 0;
	if (c == '\'' || c == '"') {
		quotec = c;
		c = (unsigned char)*cp++;
	}
	while (c != '\0') {
		if (c == quotec) {
			cp++;
			break;
		}
		if (quotec == 0 && (c == ' ' || c == '\t'))
			break;
		if (cp2 - lexstring < STRINGLEN-1)
			*cp2++ = c;
		c = (unsigned char)*cp++;
	}
	if (quotec && c == 0) {
		fprintf(stderr, "Missing %c\n", quotec);
		return(TERROR);
	}
	*sp = --cp;
	*cp2 = '\0';
	return(TSTRING);
}

/*
 * Unscan the named token by pushing it onto the regret stack.
 */
void
regret(int token)
{

	if (++regretp >= REGDEP)
		errx(1, "Too many regrets");
	regretstack[regretp] = token;
	lexstring[STRINGLEN-1] = '\0';
	string_stack[regretp] = savestr(lexstring);
	numberstack[regretp] = lexnumber;
}

/*
 * Reset all the scanner global variables.
 */
void
scaninit(void)
{

	regretp = -1;
}

/*
 * Find the first message whose flags & m == f  and return
 * its message number.
 */
int
first(int f, int m)
{
	struct message *mp;

	if (msgCount == 0)
		return(0);
	f &= MDELETED;
	m &= MDELETED;
	for (mp = dot; mp < &message[msgCount]; mp++)
		if ((mp->m_flag & m) == f)
			return(mp - message + 1);
	for (mp = dot-1; mp >= &message[0]; mp--)
		if ((mp->m_flag & m) == f)
			return(mp - message + 1);
	return(0);
}

/*
 * See if the passed name sent the passed message number.  Return true
 * if so.
 */
int
matchsender(char *str, int mesg)
{
	char *cp;

	if (!*str)	/* null string matches nothing instead of everything */
		return(0);
	cp = nameof(&message[mesg - 1], 0);
	return (strcasestr(cp, str) != NULL);
}

/*
 * See if the passed name received the passed message number.  Return true
 * if so.
 */
static char *to_fields[] = { "to", "cc", "bcc", NULL };

int
matchto(char *str, int mesg)
{
	struct message *mp;
	char *cp, **to;

	str++;

	if (*str == 0)	/* null string matches nothing instead of everything */
		return(0);

	mp = &message[mesg-1];

	for (to = to_fields; *to; to++) {
		cp = hfield(*to, mp);
		if (cp != NULL && strcasestr(cp, str) != NULL)
			return(1);
	}
	return(0);
}

/*
 * See if the given string matches inside the subject field of the
 * given message.  For the purpose of the scan, we ignore case differences.
 * If it does, return true.  The string search argument is assumed to
 * have the form "/search-string."  If it is of the form "/," we use the
 * previous search string.
 */
char lastscan[STRINGLEN];

int
matchsubj(char *str, int mesg)
{
	struct message *mp;
	char *cp, *cp2;

	str++;
	if (*str == '\0')
		str = lastscan;
	else
		strlcpy(lastscan, str, sizeof(lastscan));
	mp = &message[mesg-1];
	
	/*
	 * Now look, ignoring case, for the word in the string.
	 */
	if (value("searchheaders") && (cp = strchr(str, ':'))) {
		/* Check for special case "/To:" */
		if (strncasecmp(str, "to:", 3) == 0)
			return(matchto(cp, mesg));
		*cp++ = '\0';
		cp2 = hfield(*str ? str : "subject", mp);
		cp[-1] = ':';
		str = cp;
		cp = cp2;
	} else {
		cp = hfield("subject", mp);
	}
	if (cp == NULL)
		return(0);

	return (strcasestr(cp, str) != NULL);
}

/*
 * Mark the named message by setting its mark bit.
 */
void
mark(int mesg)
{
	int i;

	i = mesg;
	if (i < 1 || i > msgCount)
		errx(1, "Bad message number to mark");
	message[i-1].m_flag |= MMARK;
}

/*
 * Unmark the named message.
 */
void
unmark(int mesg)
{
	int i;

	i = mesg;
	if (i < 1 || i > msgCount)
		errx(1, "Bad message number to unmark");
	message[i-1].m_flag &= ~MMARK;
}

/*
 * Return the message number corresponding to the passed meta character.
 */
int
metamess(int meta, int f)
{
	int c, m;
	struct message *mp;

	c = meta;
	switch (c) {
	case '^':
		/*
		 * First 'good' message left.
		 */
		for (mp = &message[0]; mp < &message[msgCount]; mp++)
			if ((mp->m_flag & MDELETED) == f)
				return(mp - &message[0] + 1);
		puts("No applicable messages");
		return(-1);

	case '$':
		/*
		 * Last 'good message left.
		 */
		for (mp = &message[msgCount-1]; mp >= &message[0]; mp--)
			if ((mp->m_flag & MDELETED) == f)
				return(mp - &message[0] + 1);
		puts("No applicable messages");
		return(-1);

	case '.':
		/*
		 * Current message.
		 */
		m = dot - &message[0] + 1;
		if ((dot->m_flag & MDELETED) != f) {
			printf("%d: Inappropriate message\n", m);
			return(-1);
		}
		return(m);

	default:
		printf("Unknown metachar (%c)\n", c);
		return(-1);
	}
}
@


1.19
log
@ctype and other sign extension fixes.

with deraadt and millert, ok millert
@
text
@d1 1
a1 1
/*	$OpenBSD: list.c,v 1.18 2009/10/27 23:59:40 deraadt Exp $	*/
d380 2
a381 2
	if ((linebuf = (char *)malloc(linebufsize)) == NULL)
		errx(1, "Out of memory");
d402 1
a402 1
					errx(1, "Out of memory");
@


1.18
log
@rcsid[] and sccsid[] and copyright[] are essentially unmaintained (and
unmaintainable).  these days, people use source.  these id's do not provide
any benefit, and do hurt the small install media
(the 33,000 line diff is essentially mechanical)
ok with the idea millert, ok dms
@
text
@d1 1
a1 1
/*	$OpenBSD: list.c,v 1.17 2008/07/15 19:23:26 martynas Exp $	*/
d512 1
a512 1
	c = *cp++;
d518 1
a518 1
		c = *cp++;
d540 1
a540 1
			c = *cp++;
d569 1
a569 1
		c = *cp++;
d580 1
a580 1
		c = *cp++;
@


1.17
log
@- chraise can be replaced with toupper;  no need to check for islower
- remove quite some code, use strcasestr instead of reimplementing
it each time
- use strncasecmp, instead of comparing through each character
"looks fine" millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: list.c,v 1.16 2005/07/11 14:08:23 millert Exp $	*/
a31 8

#ifndef lint
#if 0
static const char sccsid[] = "@@(#)list.c	8.4 (Berkeley) 5/1/95";
#else
static const char rcsid[] = "$OpenBSD: list.c,v 1.16 2005/07/11 14:08:23 millert Exp $";
#endif
#endif /* not lint */
@


1.16
log
@Fix off-by-one bug in readtty() and don't assume BUFSIZ == 1024.
Based on a patch from Ulf Harnhammar.
@
text
@d1 1
a1 1
/*	$OpenBSD: list.c,v 1.15 2004/09/15 22:21:40 deraadt Exp $	*/
d37 1
a37 1
static const char rcsid[] = "$OpenBSD: list.c,v 1.15 2004/09/15 22:21:40 deraadt Exp $";
d653 1
a653 1
	char *cp, *cp2, *backup;
d657 2
a658 11
	backup = cp2 = nameof(&message[mesg - 1], 0);
	cp = str;
	while (*cp2) {
		if (*cp == 0)
			return(1);
		if (chraise(*cp++) != chraise(*cp2++)) {
			cp2 = ++backup;
			cp = str;
		}
	}
	return(*cp == 0);
d671 1
a671 1
	char *cp, *cp2, *backup, **to;
d681 3
a683 15
		cp = str;
		cp2 = hfield(*to, mp);
		if (cp2 != NULL) {
			backup = cp2;
			while (*cp2) {
				if (*cp == 0)
					return(1);
				if (chraise(*cp++) != chraise(*cp2++)) {
					cp2 = ++backup;
					cp = str;
				}
			}
			if (*cp == 0)
				return(1);
		}
d701 1
a701 1
	char *cp, *cp2, *backup;
d715 1
a715 2
		if (chraise(str[0]) == 'T' && chraise(str[1]) == 'O' &&
		    str[2] == ':')
d721 1
d723 1
a723 2
		cp = str;
		cp2 = hfield("subject", mp);
d725 1
a725 1
	if (cp2 == NULL)
d727 2
a728 10
	backup = cp2;
	while (*cp2) {
		if (*cp == 0)
			return(1);
		if (chraise(*cp++) != chraise(*cp2++)) {
			cp2 = ++backup;
			cp = str;
		}
	}
	return(*cp == 0);
@


1.15
log
@avoid aliasing against libc symbols
@
text
@d1 1
a1 1
/*	$OpenBSD: list.c,v 1.14 2003/10/13 00:46:08 tedu Exp $	*/
d37 1
a37 1
static const char rcsid[] = "$OpenBSD: list.c,v 1.14 2003/10/13 00:46:08 tedu Exp $";
d546 2
a547 1
			*cp2++ = c;
@


1.14
log
@better realloc. ok deraadt jose
@
text
@d1 1
a1 1
/*	$OpenBSD: list.c,v 1.13 2003/06/03 02:56:11 millert Exp $	*/
d37 1
a37 1
static const char rcsid[] = "$OpenBSD: list.c,v 1.13 2003/06/03 02:56:11 millert Exp $";
d661 1
a661 1
		if (raise(*cp++) != raise(*cp2++)) {
d696 1
a696 1
				if (raise(*cp++) != raise(*cp2++)) {
d735 1
a735 1
		if (raise(str[0]) == 'T' && raise(str[1]) == 'O' &&
d752 1
a752 1
		if (raise(*cp++) != raise(*cp2++)) {
@


1.13
log
@Remove the advertising clause in the UCB license which Berkeley
rescinded 22 July 1999.  Proofed by myself and Theo.
@
text
@d1 1
a1 1
/*	$OpenBSD: list.c,v 1.12 2001/11/21 20:41:55 millert Exp $	*/
d37 1
a37 1
static const char rcsid[] = "$OpenBSD: list.c,v 1.12 2001/11/21 20:41:55 millert Exp $";
d385 2
a386 2
	char *linebuf;
	size_t linebufsize = BUFSIZ;
d407 3
a409 3
				linebufsize += BUFSIZ;
				linebuf = (char *)realloc(linebuf, linebufsize);
				if (linebuf == NULL)
d411 2
@


1.12
log
@o kill strcpy()
o check return values of malloc and friends
o use strdup() when sensible
@
text
@d1 1
a1 1
/*	$OpenBSD: list.c,v 1.11 2001/11/21 15:26:39 millert Exp $	*/
d16 1
a16 5
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
d37 1
a37 1
static const char rcsid[] = "$OpenBSD: list.c,v 1.11 2001/11/21 15:26:39 millert Exp $";
@


1.11
log
@o ANSIfy
o Style nits
o Use const to silent stupid -Wall warnings
o strnc{py,at} -> strlc{py,at}
o Use strpbrk() instead of homegrown anyof()
o Use NULL instead of #defines with 0 cast to a pointer
This still could use a proper audit
@
text
@d1 1
a1 1
/*	$OpenBSD: list.c,v 1.10 2001/01/16 05:36:08 millert Exp $	*/
d41 1
a41 1
static const char rcsid[] = "$OpenBSD: list.c,v 1.10 2001/01/16 05:36:08 millert Exp $";
d516 1
a516 1
		strcpy(lexstring, string_stack[regretp]);
@


1.10
log
@Changes from Don Beusee:
o escape From line with a leading '>' when needed
o only print To: address and Subject lines if actually present
o new variable 'allnet' to treat user@@foo and user@@bar as the same "user"
o folders command now takes an optional argument like ls.
o new "pipe" (|) command to pipe the message through an arbitrary command
o make header display format the same as SunOS 4.1.3 /usr/ucb/mail
o tilde commands work regardless of interactive mode.
o fix "read: Interrupted system call" error by retrying if EINTR
o expanded help file
Changes by me:
o read the help file via the PAGER as it is now more than 24 lines long
@
text
@d1 1
a1 1
/*	$OpenBSD: list.c,v 1.9 1997/11/14 00:23:49 millert Exp $	*/
d39 1
a39 1
static char sccsid[] = "@@(#)list.c	8.4 (Berkeley) 5/1/95";
d41 1
a41 1
static char rcsid[] = "$OpenBSD: list.c,v 1.9 1997/11/14 00:23:49 millert Exp $";
d49 1
a49 1
int	matchto __P((char *, int));
d64 1
a64 3
getmsglist(buf, vector, flags)
	char *buf;
	int *vector, flags;
a91 1

a101 1

d116 1
a116 1
static	int	lastcolmod;
d119 1
a119 3
markall(buf, f)
	char buf[];
	int f;
a261 1

a270 1

a292 1

a312 1

a322 1
			
d346 1
a346 2
evalcol(col)
	int col;
d364 1
a364 2
check(mesg, f)
	int mesg, f;
d385 1
a385 4
getrawlist(line, argv, argc)
	char line[];
	char **argv;
	int  argc;
d487 1
a487 1
 * scan out a single lexical item and return its token number,
a491 1

d508 1
a508 2
scan(sp)
	char **sp;
a526 1

a533 1

a543 1

a559 1

a574 1

d604 1
a604 2
regret(token)
	int token;
d606 1
d619 1
a619 1
scaninit()
d621 1
d630 1
a630 2
first(f, m)
	int f, m;
d652 1
a652 3
matchsender(str, mesg)
	char *str;
	int mesg;
a674 1

d678 1
a678 2
matchto(str, mesg)
	char *str;
d717 1
a718 1
char lastscan[STRINGLEN];
d720 1
a720 3
matchsubj(str, mesg)
	char *str;
	int mesg;
d728 2
a729 4
	else {
		strncpy(lastscan, str, sizeof(lastscan) - 1);
		lastscan[sizeof(lastscan) - 1] = '\0';
	}
a734 1

d766 1
a766 2
mark(mesg)
	int mesg;
d780 1
a780 2
unmark(mesg)
	int mesg;
d794 1
a794 2
metamess(meta, f)
	int meta, f;
@


1.9
log
@NetBSD changes (mostly comsmetic):
    replace panic() with calls to err()/errx()
    use S_IS* instead of doing by hand with S_IF*.
    Use TIMESPEC_TO_TIMEVAL() and gettimeofday instead of time(2)
    Use _POSIX_VDISABLE, not 0
    Kill register
@
text
@d1 1
a1 1
/*	$OpenBSD: list.c,v 1.8 1997/08/04 17:30:22 millert Exp $	*/
d41 1
a41 1
static char rcsid[] = "$OpenBSD: list.c,v 1.8 1997/08/04 17:30:22 millert Exp $";
d219 4
a223 2
			else
				*np++ = savestr(lexstring);
@


1.8
log
@Fix a problem in skin() that was introduced with the buffer oflow
fix.  Could end up realloc'ing the wrong thing.
@
text
@d1 1
a1 1
/*	$OpenBSD: list.c,v 1.7 1997/07/31 02:36:33 millert Exp $	*/
d41 1
a41 1
static char rcsid[] = "$OpenBSD: list.c,v 1.7 1997/07/31 02:36:33 millert Exp $";
d49 2
d68 2
a69 2
	register int *ip;
	register struct message *mp;
d127 3
a129 3
	register char **np;
	register int i;
	register struct message *mp;
d323 1
a323 1
			register struct coltab *colp;
d337 1
a337 1
			register struct coltab *colp;
d358 1
a358 1
	register struct coltab *colp;
d377 1
a377 1
	register struct message *mp;
d401 1
a401 1
	register char c, *cp, *cp2, quotec;
d407 1
a407 1
		panic("Out of memory");
d428 1
a428 1
					panic("Out of memory");
d526 3
a528 3
	register char *cp, *cp2;
	register int c;
	register struct lex *lp;
d629 1
a629 1
		panic("Too many regrets");
d653 1
a653 1
	register struct message *mp;
d677 1
a677 1
	register char *cp, *cp2, *backup;
d705 2
a706 2
	register struct message *mp;
	register char *cp, *cp2, *backup, **to;
d749 2
a750 2
	register struct message *mp;
	register char *cp, *cp2, *backup;
d799 1
a799 1
	register int i;
d803 1
a803 1
		panic("Bad message number to mark");
d814 1
a814 1
	register int i;
d818 1
a818 1
		panic("Bad message number to unmark");
d829 2
a830 2
	register int c, m;
	register struct message *mp;
@


1.7
log
@Document an assumption and kill a static buffer.
@
text
@d1 1
a1 1
/*	$OpenBSD: list.c,v 1.6 1997/07/14 00:24:28 millert Exp $	*/
d41 1
a41 1
static char rcsid[] = "$OpenBSD: list.c,v 1.6 1997/07/14 00:24:28 millert Exp $";
d424 2
a425 1
				if (!(linebuf = realloc(linebuf, linebufsize)))
d427 1
a427 1
				cp2 = linebuf + (linebufsize - BUFSIZ) - 1;
@


1.6
log
@NOSTR -> NULL
Use sigsetjmp/siglongjmp instead of sigjmp/longjmp for portability.
@
text
@d1 1
a1 1
/*	$OpenBSD: list.c,v 1.5 1997/07/13 21:21:14 millert Exp $	*/
d41 1
a41 1
static char rcsid[] = "$OpenBSD: list.c,v 1.5 1997/07/13 21:21:14 millert Exp $";
d401 5
a405 1
	char linebuf[BUFSIZ];
d421 7
d493 1
@


1.5
log
@Merge in NetBSD and 4.4BSD-lite2 changes as well as some of my own.
 - handle long lines safely (from NetBSD)
 - use puts/fputs and putchar/putc when it makes sense
 - use err/errx and warn/warnx when it makes sense
 - make return() and sizeof() style consisten
 - some more buffer safety
@
text
@d1 1
a1 1
/*	$OpenBSD: list.c,v 1.4 1997/05/30 08:51:42 deraadt Exp $	*/
d41 1
a41 1
static char rcsid[] = "$OpenBSD: list.c,v 1.4 1997/05/30 08:51:42 deraadt Exp $";
d244 1
a244 1
	*np = NOSTR;
d277 1
a277 1
			for (mc = 0, np = &namelist[0]; *np != NOSTR; np++)
d307 1
a307 1
			for (np = &namelist[1]; *np != NOSTR; np++)
d481 1
a481 1
	argv[argn] = NOSTR;
d703 1
a703 1
		if (cp2 != NOSTR) {
d763 1
a763 1
	if (cp2 == NOSTR)
@


1.4
log
@overflows abound
@
text
@d1 2
a2 2
/*	$OpenBSD: list.c,v 1.3 1997/01/17 07:12:49 millert Exp $	*/
/*	$NetBSD: list.c,v 1.4 1996/06/08 19:48:30 christos Exp $	*/
d39 1
a39 1
static char sccsid[] = "@@(#)list.c	8.2 (Berkeley) 4/19/94";
d41 1
a41 1
static char rcsid[] = "$OpenBSD: list.c,v 1.3 1997/01/17 07:12:49 millert Exp $";
d71 1
a71 1
		return 0;
d148 1
a148 1
				printf("No numbers mixed with *\n");
d175 1
a175 1
				printf("Non-numeric second argument\n");
d182 1
a182 1
					printf("Referencing beyond EOF\n");
d195 1
a195 1
						printf("Referencing before 1\n");
d205 1
a205 1
				printf("Non-numeric second argument\n");
d232 1
a232 1
				printf("Can't mix \"*\" with anything\n");
d239 1
a239 1
			return -1;
d253 1
a253 1
			printf("No applicable messages.\n");
d309 1
a309 1
			printf("}\n");
d337 1
a337 1
			printf("No messages satisfy");
d341 1
a341 1
			printf("\n");
d411 1
a411 2
			printf(
			"Too many elements in the list; excess discarded.\n");
d482 1
a482 1
	return argn;
d599 1
a599 1
		return TERROR;
d641 1
a641 1
		return 0;
d646 1
a646 1
			return mp - message + 1;
d649 2
a650 2
			return mp - message + 1;
	return 0;
d665 1
a665 1
		return 0;
d680 41
d738 1
a738 1
	if (strlen(str) == 0)
d741 2
a742 2
		strncpy(lastscan, str, sizeof lastscan-1);
		lastscan[sizeof lastscan-1] = '\0';
a743 1

d751 4
d756 1
a756 1
		cp2 = hfield(str, mp);
d826 1
a826 1
		printf("No applicable messages\n");
d836 1
a836 1
		printf("No applicable messages\n");
d840 1
a840 1
		/* 
@


1.3
log
@r?index -> strr?chr
@
text
@d1 1
a1 1
/*	$OpenBSD: list.c,v 1.2 1996/06/11 12:53:43 deraadt Exp $	*/
d41 1
a41 1
static char rcsid[] = "$OpenBSD: list.c,v 1.2 1996/06/11 12:53:43 deraadt Exp $";
d688 1
a688 1
char lastscan[128];
d700 5
a704 2
	else
		strcpy(lastscan, str);
@


1.2
log
@from christos;
- Fix PR/105: Implement dot locking protocol and check return value of flock.
- Fix PR/2247: Don't call unknown users "ubluit". Issue an error message.
- Fix/add prototypes.
- Fix warnings.
- Use POSIX signal mask calls.
@
text
@d1 1
a1 1
/*	$OpenBSD: list.c,v 1.4 1996/06/08 19:48:30 christos Exp $	*/
d41 1
a41 1
static char rcsid[] = "$OpenBSD: list.c,v 1.4 1996/06/08 19:48:30 christos Exp $";
d708 1
a708 1
	if (value("searchheaders") && (cp = index(str, ':'))) {
@


1.1
log
@Initial revision
@
text
@d1 3
d38 5
a42 2
static char sccsid[] = "from: @@(#)list.c	8.2 (Berkeley) 4/19/94";
static char rcsid[] = "$Id: list.c,v 1.3 1994/06/29 05:09:30 deraadt Exp $";
d110 6
a115 6
	'n',		CMNEW,		MNEW,		MNEW,
	'o',		CMOLD,		MNEW,		0,
	'u',		CMUNREAD,	MREAD,		0,
	'd',		CMDELETED,	MDELETED,	MDELETED,
	'r',		CMREAD,		MREAD,		MREAD,
	0,		0,		0,		0
d463 2
a464 2
					else if (c >= 'A' && c <= '_' ||
						 c >= 'a' && c <= 'z')
d497 9
a505 9
	'$',	TDOLLAR,
	'.',	TDOT,
	'^',	TUP,
	'*',	TSTAR,
	'-',	TDASH,
	'+',	TPLUS,
	'(',	TOPEN,
	')',	TCLOSE,
	0,	0
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@
