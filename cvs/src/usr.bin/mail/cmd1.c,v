head	1.29;
access;
symbols
	OPENBSD_6_0:1.29.0.22
	OPENBSD_6_0_BASE:1.29
	OPENBSD_5_9:1.29.0.18
	OPENBSD_5_9_BASE:1.29
	OPENBSD_5_8:1.29.0.20
	OPENBSD_5_8_BASE:1.29
	OPENBSD_5_7:1.29.0.12
	OPENBSD_5_7_BASE:1.29
	OPENBSD_5_6:1.29.0.16
	OPENBSD_5_6_BASE:1.29
	OPENBSD_5_5:1.29.0.14
	OPENBSD_5_5_BASE:1.29
	OPENBSD_5_4:1.29.0.10
	OPENBSD_5_4_BASE:1.29
	OPENBSD_5_3:1.29.0.8
	OPENBSD_5_3_BASE:1.29
	OPENBSD_5_2:1.29.0.6
	OPENBSD_5_2_BASE:1.29
	OPENBSD_5_1_BASE:1.29
	OPENBSD_5_1:1.29.0.4
	OPENBSD_5_0:1.29.0.2
	OPENBSD_5_0_BASE:1.29
	OPENBSD_4_9:1.28.0.6
	OPENBSD_4_9_BASE:1.28
	OPENBSD_4_8:1.28.0.4
	OPENBSD_4_8_BASE:1.28
	OPENBSD_4_7:1.28.0.2
	OPENBSD_4_7_BASE:1.28
	OPENBSD_4_6:1.27.0.8
	OPENBSD_4_6_BASE:1.27
	OPENBSD_4_5:1.27.0.4
	OPENBSD_4_5_BASE:1.27
	OPENBSD_4_4:1.27.0.2
	OPENBSD_4_4_BASE:1.27
	OPENBSD_4_3:1.26.0.4
	OPENBSD_4_3_BASE:1.26
	OPENBSD_4_2:1.26.0.2
	OPENBSD_4_2_BASE:1.26
	OPENBSD_4_1:1.25.0.14
	OPENBSD_4_1_BASE:1.25
	OPENBSD_4_0:1.25.0.12
	OPENBSD_4_0_BASE:1.25
	OPENBSD_3_9:1.25.0.10
	OPENBSD_3_9_BASE:1.25
	OPENBSD_3_8:1.25.0.8
	OPENBSD_3_8_BASE:1.25
	OPENBSD_3_7:1.25.0.6
	OPENBSD_3_7_BASE:1.25
	OPENBSD_3_6:1.25.0.4
	OPENBSD_3_6_BASE:1.25
	OPENBSD_3_5:1.25.0.2
	OPENBSD_3_5_BASE:1.25
	OPENBSD_3_4:1.24.0.2
	OPENBSD_3_4_BASE:1.24
	OPENBSD_3_3:1.22.0.6
	OPENBSD_3_3_BASE:1.22
	OPENBSD_3_2:1.22.0.4
	OPENBSD_3_2_BASE:1.22
	OPENBSD_3_1:1.22.0.2
	OPENBSD_3_1_BASE:1.22
	OPENBSD_3_0:1.18.0.2
	OPENBSD_3_0_BASE:1.18
	OPENBSD_2_9_BASE:1.17
	OPENBSD_2_9:1.17.0.2
	OPENBSD_2_8:1.16.0.2
	OPENBSD_2_8_BASE:1.16
	OPENBSD_2_7:1.15.0.2
	OPENBSD_2_7_BASE:1.15
	OPENBSD_2_6:1.13.0.6
	OPENBSD_2_6_BASE:1.13
	OPENBSD_2_5:1.13.0.4
	OPENBSD_2_5_BASE:1.13
	OPENBSD_2_4:1.13.0.2
	OPENBSD_2_4_BASE:1.13
	OPENBSD_2_3:1.12.0.2
	OPENBSD_2_3_BASE:1.12
	OPENBSD_2_2:1.11.0.2
	OPENBSD_2_2_BASE:1.11
	OPENBSD_2_1:1.4.0.2
	OPENBSD_2_1_BASE:1.4
	OPENBSD_2_0:1.3.0.2
	OPENBSD_2_0_BASE:1.3
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.29
date	2011.04.06.11.36.26;	author miod;	state Exp;
branches;
next	1.28;

1.28
date	2009.10.27.23.59.40;	author deraadt;	state Exp;
branches;
next	1.27;

1.27
date	2008.07.15.19.13.25;	author martynas;	state Exp;
branches;
next	1.26;

1.26
date	2007.04.03.18.01.49;	author martynas;	state Exp;
branches;
next	1.25;

1.25
date	2003.12.03.20.59.45;	author millert;	state Exp;
branches;
next	1.24;

1.24
date	2003.06.03.02.56.11;	author millert;	state Exp;
branches;
next	1.23;

1.23
date	2003.05.15.02.47.47;	author pjanzen;	state Exp;
branches;
next	1.22;

1.22
date	2001.11.21.20.41.55;	author millert;	state Exp;
branches;
next	1.21;

1.21
date	2001.11.21.15.26.39;	author millert;	state Exp;
branches;
next	1.20;

1.20
date	2001.11.20.20.50.00;	author millert;	state Exp;
branches;
next	1.19;

1.19
date	2001.11.16.17.10.06;	author millert;	state Exp;
branches;
next	1.18;

1.18
date	2001.06.23.23.04.21;	author millert;	state Exp;
branches;
next	1.17;

1.17
date	2001.01.16.05.36.08;	author millert;	state Exp;
branches;
next	1.16;

1.16
date	2000.06.30.16.00.18;	author millert;	state Exp;
branches;
next	1.15;

1.15
date	2000.04.26.15.47.29;	author millert;	state Exp;
branches
	1.15.2.1;
next	1.14;

1.14
date	2000.04.25.16.42.22;	author millert;	state Exp;
branches;
next	1.13;

1.13
date	98.05.11.04.15.24;	author millert;	state Exp;
branches;
next	1.12;

1.12
date	97.11.14.00.23.42;	author millert;	state Exp;
branches;
next	1.11;

1.11
date	97.07.30.06.32.38;	author millert;	state Exp;
branches;
next	1.10;

1.10
date	97.07.24.17.27.09;	author millert;	state Exp;
branches;
next	1.9;

1.9
date	97.07.22.18.54.34;	author millert;	state Exp;
branches;
next	1.8;

1.8
date	97.07.14.00.24.24;	author millert;	state Exp;
branches;
next	1.7;

1.7
date	97.07.13.23.53.57;	author millert;	state Exp;
branches;
next	1.6;

1.6
date	97.07.13.21.21.08;	author millert;	state Exp;
branches;
next	1.5;

1.5
date	97.05.30.08.51.34;	author deraadt;	state Exp;
branches;
next	1.4;

1.4
date	97.03.29.03.01.44;	author millert;	state Exp;
branches;
next	1.3;

1.3
date	96.06.11.12.53.32;	author deraadt;	state Exp;
branches;
next	1.2;

1.2
date	96.03.27.19.32.30;	author niklas;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.45.38;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.45.38;	author deraadt;	state Exp;
branches;
next	;

1.15.2.1
date	2000.10.06.21.16.14;	author jason;	state Exp;
branches;
next	;


desc
@@


1.29
log
@Avoid using NULL in non-pointer contexts: use 0 for integer values and '\0'
for chars.
@
text
@/*	$OpenBSD: cmd1.c,v 1.28 2009/10/27 23:59:40 deraadt Exp $	*/
/*	$NetBSD: cmd1.c,v 1.9 1997/07/09 05:29:48 mikel Exp $	*/

/*-
 * Copyright (c) 1980, 1993
 *	The Regents of the University of California.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */

#include "rcv.h"
#include "extern.h"

/*
 * Mail -- a mail program
 *
 * User commands.
 */

/*
 * Print the current active headings.
 * Don't change dot if invoker didn't give an argument.
 */

static int screen;
static volatile sig_atomic_t gothdrint;

int
headers(void *v)
{
	int *msgvec = v;
	int n, mesg, flag, size;
	struct message *mp;
	struct sigaction act, oact;
	sigset_t oset;

	size = screensize();
	n = msgvec[0];
	if (n != 0 && size > 0)
		screen = (n-1)/size;
	if (screen < 0)
		screen = 0;
	mp = &message[screen * size];
	if (mp >= &message[msgCount])
		mp = &message[msgCount - size];
	if (mp < &message[0])
		mp = &message[0];
	flag = 0;
	mesg = mp - &message[0];
	if (dot != &message[n-1])
		dot = mp;
	sigemptyset(&act.sa_mask);
	act.sa_flags = SA_RESTART;
	act.sa_handler = hdrint;
	if (sigaction(SIGINT, NULL, &oact) == 0 &&
	    oact.sa_handler != SIG_IGN) {
		(void)sigaction(SIGINT, &act, &oact);
		(void)sigprocmask(SIG_UNBLOCK, &intset, &oset);
	}
	for (gothdrint = 0; !gothdrint && mp < &message[msgCount]; mp++) {
		mesg++;
		if (mp->m_flag & MDELETED)
			continue;
		if (flag++ >= size)
			break;
		printhead(mesg);
	}
	if (gothdrint) {
		fflush(stdout);
		fputs("\nInterrupt\n", stderr);
	}
	if (oact.sa_handler != SIG_IGN) {
		(void)sigprocmask(SIG_SETMASK, &oset, NULL);
		(void)sigaction(SIGINT, &oact, NULL);
	}
	if (flag == 0) {
		puts("No more mail.");
		return(1);
	}
	return(0);
}

/*
 * Scroll to the next/previous screen
 */
int
scroll(void *v)
{
	char *arg = v;
	int size, maxscreen;
	int cur[1];

	cur[0] = 0;
	size = screensize();
	maxscreen = 0;
	if (size > 0)
		maxscreen = (msgCount - 1) / size;
	switch (*arg) {
	case 0:
	case '+':
		if (screen >= maxscreen) {
			puts("On last screenful of messages");
			return(0);
		}
		screen++;
		break;

	case '-':
		if (screen <= 0) {
			puts("On first screenful of messages");
			return(0);
		}
		screen--;
		break;

	default:
		printf("Unrecognized scrolling command \"%s\"\n", arg);
		return(1);
	}
	return(headers(cur));
}

/*
 * Compute screen size.
 */
int
screensize(void)
{
	int s;
	char *cp;

	if ((cp = value("screen")) != NULL && (s = atoi(cp)) > 0)
		return(s);
	return(screenheight - 4);
}

/*
 * Print out the headlines for each message
 * in the passed message list.
 */
int
from(void *v)
{
	int *msgvec = v;
	int *ip;

	for (ip = msgvec; *ip != 0; ip++)
		printhead(*ip);
	if (--ip >= msgvec)
		dot = &message[*ip - 1];
	return(0);
}

/*
 * Print out the header of a specific message.
 * This is a slight improvement to the standard one.
 */
void
printhead(int mesg)
{
	struct message *mp;
	char headline[LINESIZE], *subjline, dispc, curind;
	char visname[LINESIZE], vissub[LINESIZE];
	char pbuf[LINESIZE];
	char fmtline[LINESIZE];
	const char *fmt;
	struct headline hl;
	char *name;
	char *to, *from;
	struct name *np;
	char **ap;

	mp = &message[mesg-1];
	(void)readline(setinput(mp), headline, LINESIZE, NULL);
	if ((subjline = hfield("subject", mp)) == NULL &&
	    (subjline = hfield("subj", mp)) == NULL)
		subjline = "";
	/*
	 * Bletch!
	 */
	curind = dot == mp ? '>' : ' ';
	dispc = ' ';
	if (mp->m_flag & MSAVED)
		dispc = '*';
	if (mp->m_flag & MPRESERVE)
		dispc = 'P';
	if ((mp->m_flag & (MREAD|MNEW)) == MNEW)
		dispc = 'N';
	if ((mp->m_flag & (MREAD|MNEW)) == 0)
		dispc = 'U';
	if (mp->m_flag & MBOX)
		dispc = 'M';
	parse(headline, &hl, pbuf);
	from = nameof(mp, 0);
	to = skin(hfield("to", mp));
	np = extract(from, GTO);
	np = delname(np, myname);
	if (altnames)
		for (ap = altnames; *ap; ap++)
			np = delname(np, *ap);
	if (np)
		/* not from me */
		name = value("show-rcpt") != NULL && to ? to : from;
	else
		/* from me - show TO */
		name = value("showto") != NULL && to ? to : from;
	strnvis(visname, name, sizeof(visname), VIS_SAFE|VIS_NOSLASH);
	if (name == to)
		fmt = "%c%c%3d TO %-14.14s  %16.16s %4d/%-5d %s";
	else
		fmt = "%c%c%3d %-17.17s  %16.16s %4d/%-5d %s";
	strnvis(vissub, subjline, sizeof(vissub), VIS_SAFE|VIS_NOSLASH);
	/* hl.l_date was sanity-checked when read in.  */
	snprintf(fmtline, sizeof(fmtline), fmt, curind, dispc, mesg, visname,
	    hl.l_date, mp->m_lines, mp->m_size, vissub);
	printf("%.*s\n", screenwidth, fmtline);
}

/*
 * Print out the value of dot.
 */
int
pdot(void *v)
{
	printf("%d\n", (int)(dot - &message[0] + 1));
	return(0);
}

/*
 * Print out all the possible commands.
 */
int
pcmdlist(void *v)
{
	extern const struct cmd cmdtab[];
	const struct cmd *cp;
	int cc;

	puts("Commands are:");
	for (cc = 0, cp = cmdtab; cp->c_name != NULL; cp++) {
		cc += strlen(cp->c_name) + 2;
		if (cc > 72) {
			putchar('\n');
			cc = strlen(cp->c_name) + 2;
		}
		if ((cp+1)->c_name != NULL)
			printf("%s, ", cp->c_name);
		else
			puts(cp->c_name);
	}
	return(0);
}

/*
 * Pipe message to command
 */
int
pipeit(void *ml, void *sl)
{
	int  *msgvec = ml;
	char *cmd    = sl;

	return(type1(msgvec, cmd, 0, 0));
}

/*
 * Paginate messages, honor ignored fields.
 */
int
more(void *v)
{
	int *msgvec = v;
	return(type1(msgvec, NULL, 1, 1));
}

/*
 * Paginate messages, even printing ignored fields.
 */
int
More(void *v)
{
	int *msgvec = v;

	return(type1(msgvec, NULL, 0, 1));
}

/*
 * Type out messages, honor ignored fields.
 */
int
type(void *v)
{
	int *msgvec = v;

	return(type1(msgvec, NULL, 1, 0));
}

/*
 * Type out messages, even printing ignored fields.
 */
int
Type(void *v)
{
	int *msgvec = v;

	return(type1(msgvec, NULL, 0, 0));
}

/*
 * Type out the messages requested.
 */
int
type1(int *msgvec, char *cmd, int doign, int page)
{
	int nlines, *ip, restoreterm;
	struct message *mp;
	struct termios tbuf;
	char *cp;
	FILE *obuf;

	obuf = stdout;
	restoreterm = 0;

	/*
	 * start a pipe if needed.
	 */
	if (cmd) {
		restoreterm = (tcgetattr(fileno(stdin), &tbuf) == 0);
		obuf = Popen(cmd, "w");
		if (obuf == NULL) {
			warn("%s", cmd);
			obuf = stdout;
		}
	} else if (value("interactive") != NULL &&
	         (page || (cp = value("crt")) != NULL)) {
		nlines = 0;
		if (!page) {
			for (ip = msgvec; *ip && ip-msgvec < msgCount; ip++)
				nlines += message[*ip - 1].m_lines;
		}
		if (page || nlines > (*cp ? atoi(cp) : realscreenheight)) {
			restoreterm = (tcgetattr(fileno(stdin), &tbuf) == 0);
			cp = value("PAGER");
			obuf = Popen(cp, "w");
			if (obuf == NULL) {
				warn("%s", cp);
				obuf = stdout;
			}
		}
	}

	/*
	 * Send messages to the output.
	 */
	for (ip = msgvec; *ip && ip - msgvec < msgCount; ip++) {
		mp = &message[*ip - 1];
		touch(mp);
		dot = mp;
		if (cmd == NULL && value("quiet") == NULL)
			fprintf(obuf, "Message %d:\n", *ip);
		if (sendmessage(mp, obuf, doign ? ignore : 0, NULL) == -1)
			break;
	}

	if (obuf != stdout) {
		(void)Pclose(obuf);
		if (restoreterm)
			(void)tcsetattr(fileno(stdin), TCSADRAIN, &tbuf);
	}
	return(0);
}

/*
 * Print the top so many lines of each desired message.
 * The number of lines is taken from the variable "toplines"
 * and defaults to 5.
 */
int
top(void * v)
{
	int *msgvec = v;
	int *ip;
	struct message *mp;
	int c, topl, lines, lineb;
	char *valtop, linebuf[LINESIZE];
	FILE *ibuf;

	topl = 5;
	valtop = value("toplines");
	if (valtop != NULL) {
		topl = atoi(valtop);
		if (topl < 0 || topl > 10000)
			topl = 5;
	}
	lineb = 1;
	for (ip = msgvec; *ip && ip-msgvec < msgCount; ip++) {
		mp = &message[*ip - 1];
		touch(mp);
		dot = mp;
		if (value("quiet") == NULL)
			printf("Message %d:\n", *ip);
		ibuf = setinput(mp);
		c = mp->m_lines;
		if (!lineb)
			putchar('\n');
		for (lines = 0; lines < c && lines <= topl; lines++) {
			if (readline(ibuf, linebuf, sizeof(linebuf), NULL) < 0)
				break;
			puts(linebuf);
			lineb = blankline(linebuf);
		}
	}
	return(0);
}

/*
 * Touch all the given messages so that they will
 * get mboxed.
 */
int
stouch(void *v)
{
	int *msgvec = v;
	int *ip;

	for (ip = msgvec; *ip != 0; ip++) {
		dot = &message[*ip-1];
		dot->m_flag |= MTOUCH;
		dot->m_flag &= ~MPRESERVE;
	}
	return(0);
}

/*
 * Make sure all passed messages get mboxed.
 */
int
mboxit(void *v)
{
	int *msgvec = v;
	int *ip;

	for (ip = msgvec; *ip != 0; ip++) {
		dot = &message[*ip-1];
		dot->m_flag |= MTOUCH|MBOX;
		dot->m_flag &= ~MPRESERVE;
	}
	return(0);
}

/*
 * List the folders the user currently has.
 */
int
folders(void *v)
{
	char *files = (char *)v;
	char dirname[PATHSIZE];
	char cmd[BUFSIZ];

	if (getfold(dirname, sizeof(dirname)) < 0)
		strlcpy(dirname, "$HOME", sizeof(dirname));

	snprintf(cmd, sizeof(cmd), "cd %s; %s %s", dirname, value("LISTER"),
		files && *files ? files : "");

	(void)run_command(value("SHELL"), 0, -1, -1, "-c", cmd, NULL);
	return(0);
}

/*
 * Update the mail file with any new messages that have
 * come in since we started reading mail.
 */
int
inc(void *v)
{
	int nmsg, mdot;

	nmsg = incfile();

	if (nmsg == 0) {
		puts("No new mail.");
	} else if (nmsg > 0) {
		mdot = newfileinfo(msgCount - nmsg);
		dot = &message[mdot - 1];
	} else {
		puts("\"inc\" command failed...");
	}

	return(0);
}

/*
 * User hit ^C while printing the headers.
 */
void
hdrint(int s)
{

	gothdrint = 1;
}
@


1.28
log
@rcsid[] and sccsid[] and copyright[] are essentially unmaintained (and
unmaintainable).  these days, people use source.  these id's do not provide
any benefit, and do hurt the small install media
(the 33,000 line diff is essentially mechanical)
ok with the idea millert, ok dms
@
text
@d1 1
a1 1
/*	$OpenBSD: cmd1.c,v 1.27 2008/07/15 19:13:25 martynas Exp $	*/
d169 1
a169 1
	for (ip = msgvec; *ip != NULL; ip++)
@


1.27
log
@set cp to the value of PAGER, so that type1 doesn't try to use it
uninitialized (page=1), or use wrong previously-set value of crt
(page=0).  ok millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: cmd1.c,v 1.26 2007/04/03 18:01:49 martynas Exp $	*/
a31 8

#ifndef lint
#if 0
static const char sccsid[] = "@@(#)cmd1.c	8.2 (Berkeley) 4/20/95";
#else
static const char rcsid[] = "$OpenBSD: cmd1.c,v 1.26 2007/04/03 18:01:49 martynas Exp $";
#endif
#endif /* not lint */
@


1.26
log
@make it work with height 4 (division by zero)
ok millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: cmd1.c,v 1.25 2003/12/03 20:59:45 millert Exp $	*/
d37 1
a37 1
static const char rcsid[] = "$OpenBSD: cmd1.c,v 1.25 2003/12/03 20:59:45 millert Exp $";
d373 2
a374 1
			obuf = Popen(value("PAGER"), "w");
@


1.25
log
@Change how the line output from the 'h' command is formatted.
Previously if you had an ungodly number of messages the line could
wrap the screen.  We now format the line in a buffer and then only
print as many characters as will fit instead of printing the parts
piecemeal.
@
text
@d1 1
a1 1
/*	$OpenBSD: cmd1.c,v 1.24 2003/06/03 02:56:11 millert Exp $	*/
d37 1
a37 1
static const char rcsid[] = "$OpenBSD: cmd1.c,v 1.24 2003/06/03 02:56:11 millert Exp $";
d69 1
a69 1
	if (n != 0)
d125 3
a127 1
	maxscreen = (msgCount - 1) / size;
@


1.24
log
@Remove the advertising clause in the UCB license which Berkeley
rescinded 22 July 1999.  Proofed by myself and Theo.
@
text
@d1 1
a1 1
/*	$OpenBSD: cmd1.c,v 1.23 2003/05/15 02:47:47 pjanzen Exp $	*/
d37 1
a37 1
static const char rcsid[] = "$OpenBSD: cmd1.c,v 1.23 2003/05/15 02:47:47 pjanzen Exp $";
d190 5
a194 3
	char headline[LINESIZE], wcount[LINESIZE], *subjline, dispc, curind;
	char visline[LINESIZE];
	char pbuf[BUFSIZ];
a195 1
	int subjlen;
d203 3
a205 2
	if ((subjline = hfield("subject", mp)) == NULL)
		subjline = hfield("subj", mp);
a221 3
	(void)snprintf(wcount, sizeof(wcount), "%4d/%-5d", mp->m_lines,
	    mp->m_size);
	subjlen = screenwidth - 44 - strlen(wcount);
d235 1
a235 6
	if (subjline == NULL || subjlen < 0) { /* pretty pathetic */
		subjline="";
		subjlen=0;
	}
	printf("%c%c%3d ", curind, dispc, mesg);
	strnvis(visline, name, sizeof(visline), VIS_SAFE|VIS_NOSLASH);
d237 1
a237 1
		printf("TO %-14.14s", visline);
d239 6
a244 4
		printf("%-17.17s", visline);
	/* hl.l_date was sanity-checked when read in.  wcount we just made. */
	strnvis(visline, subjline, sizeof(visline), VIS_SAFE|VIS_NOSLASH);
	printf("  %16.16s %s %.*s\n", hl.l_date, wcount, subjlen, visline);
@


1.23
log
@Use vis() on any remotely created input before displaying it on a screen.
deraadt@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: cmd1.c,v 1.22 2001/11/21 20:41:55 millert Exp $	*/
d16 1
a16 5
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
d37 1
a37 1
static const char rcsid[] = "$OpenBSD: cmd1.c,v 1.22 2001/11/21 20:41:55 millert Exp $";
@


1.22
log
@o kill strcpy()
o check return values of malloc and friends
o use strdup() when sensible
@
text
@d1 1
a1 1
/*	$OpenBSD: cmd1.c,v 1.21 2001/11/21 15:26:39 millert Exp $	*/
d41 1
a41 1
static const char rcsid[] = "$OpenBSD: cmd1.c,v 1.21 2001/11/21 15:26:39 millert Exp $";
d195 1
d244 2
d247 1
a247 3
		printf("%c%c%3d TO %-14.14s  %16.16s %s %.*s\n",
			curind, dispc, mesg, name, hl.l_date, wcount,
			subjlen, subjline);
d249 4
a252 3
		printf("%c%c%3d %-17.17s  %16.16s %s %.*s\n",
			curind, dispc, mesg, name, hl.l_date, wcount,
			subjlen, subjline);
@


1.21
log
@o ANSIfy
o Style nits
o Use const to silent stupid -Wall warnings
o strnc{py,at} -> strlc{py,at}
o Use strpbrk() instead of homegrown anyof()
o Use NULL instead of #defines with 0 cast to a pointer
This still could use a proper audit
@
text
@d1 1
a1 1
/*	$OpenBSD: cmd1.c,v 1.20 2001/11/20 20:50:00 millert Exp $	*/
d41 1
a41 1
static const char rcsid[] = "$OpenBSD: cmd1.c,v 1.20 2001/11/20 20:50:00 millert Exp $";
d494 2
a495 3
	if (getfold(dirname, sizeof(dirname)) < 0) {
		strcpy(dirname, "$HOME");
	}
@


1.20
log
@Major signal overhaul.  We no longer longjmp all over the place.
Instead, routines responsible to gathering user input (or in some
cases outputting data) catch the signals and set flags as needed.
Because of this some handlers are install without the SA_RESTART
flag so syscalls are not restarted and we can check the flag.  All
signal handlers are now safe.

This should make the flow of control a bit more grokable but the
code is still ugly.
@
text
@d1 1
a1 1
/*	$OpenBSD: cmd1.c,v 1.19 2001/11/16 17:10:06 millert Exp $	*/
d39 1
a39 1
static char sccsid[] = "@@(#)cmd1.c	8.2 (Berkeley) 4/20/95";
d41 1
a41 1
static char rcsid[] = "$OpenBSD: cmd1.c,v 1.19 2001/11/16 17:10:06 millert Exp $";
d63 1
a63 2
headers(v)
	void *v;
d121 1
a121 2
scroll(v)
	void *v;
d159 1
a159 1
screensize()
d174 1
a174 2
from(v)
	void *v;
d191 1
a191 2
printhead(mesg)
	int mesg;
d257 1
a257 2
pdot(v)
	void *v;
d267 1
a267 2
pcmdlist(v)
	void *v;
d292 1
a292 2
pipeit(ml, sl)
	void *ml, *sl;
d304 1
a304 2
more(v)
	void *v;
d314 1
a314 2
More(v)
	void *v;
d325 1
a325 2
type(v)
	void *v;
d336 1
a336 2
Type(v)
	void *v;
d347 1
a347 4
type1(msgvec, cmd, doign, page)
	int *msgvec;
	char *cmd;
	int doign, page;
d386 1
a386 1
	 * send messages to the output.
d412 1
a412 2
top(v)
	void *v;
d454 1
a454 2
stouch(v)
	void *v;
d471 1
a471 2
mboxit(v)
	void *v;
d488 1
a488 2
folders(v)
	void *v;
d510 1
a510 2
inc(v)
	void *v;
d532 1
a532 2
hdrint(s)
	int s;
@


1.19
log
@Instead of using a longjmp to catch SIGPIPE, just set to SIG_IGN and
check the return value on writes for error.

Save and restore terminal modes when piping to a command so we end
up with a known good state if the command terminates uncleanly.
@
text
@d1 1
a1 1
/*	$OpenBSD: cmd1.c,v 1.18 2001/06/23 23:04:21 millert Exp $	*/
d41 1
a41 1
static char rcsid[] = "$OpenBSD: cmd1.c,v 1.18 2001/06/23 23:04:21 millert Exp $";
d60 1
d69 2
d87 9
a95 1
	for (; mp < &message[msgCount]; mp++) {
d103 8
d208 1
a208 1
	(void)readline(setinput(mp), headline, LINESIZE);
d366 2
a367 2
	char * volatile cp;
	FILE * volatile obuf;
d379 1
a379 1
			warn("%s", cp);
a380 2
		} else {
			(void)signal(SIGPIPE, SIG_IGN);
d395 1
a395 2
			} else
				(void)signal(SIGPIPE, SIG_IGN);
a413 1
		(void)signal(SIGPIPE, SIG_DFL);
d455 1
a455 1
			if (readline(ibuf, linebuf, sizeof(linebuf)) < 0)
d545 11
@


1.18
log
@Remove evil #ifdef __GNUC__ garbage to avoid longjmp clobbering and
use volatile instead.
@
text
@d1 1
a1 1
/*	$OpenBSD: cmd1.c,v 1.17 2001/01/16 05:36:08 millert Exp $	*/
d41 1
a41 1
static char rcsid[] = "$OpenBSD: cmd1.c,v 1.17 2001/01/16 05:36:08 millert Exp $";
a337 1
sigjmp_buf	pipestop;
d344 1
a344 1
	int nlines, *ip;
d346 1
d351 1
a351 2
	if (sigsetjmp(pipestop, 1))
		goto close_pipe;
d357 1
d363 1
a363 1
			(void)signal(SIGPIPE, brokpipe);
d373 1
d379 1
a379 1
				(void)signal(SIGPIPE, brokpipe);
d392 2
a393 1
		(void)sendmessage(mp, obuf, doign ? ignore : 0, NULL);
a395 1
close_pipe:
a396 4
		/*
		 * Ignore SIGPIPE so it can't cause a duplicate close.
		 */
		(void)signal(SIGPIPE, SIG_IGN);
d399 2
a402 11
}

/*
 * Respond to a broken pipe signal --
 * probably caused by quitting more.
 */
void
brokpipe(signo)
	int signo;
{
	siglongjmp(pipestop, 1);
@


1.17
log
@Changes from Don Beusee:
o escape From line with a leading '>' when needed
o only print To: address and Subject lines if actually present
o new variable 'allnet' to treat user@@foo and user@@bar as the same "user"
o folders command now takes an optional argument like ls.
o new "pipe" (|) command to pipe the message through an arbitrary command
o make header display format the same as SunOS 4.1.3 /usr/ucb/mail
o tilde commands work regardless of interactive mode.
o fix "read: Interrupted system call" error by retrying if EINTR
o expanded help file
Changes by me:
o read the help file via the PAGER as it is now more than 24 lines long
@
text
@d1 1
a1 1
/*	$OpenBSD: cmd1.c,v 1.16 2000/06/30 16:00:18 millert Exp $	*/
d41 1
a41 1
static char rcsid[] = "$OpenBSD: cmd1.c,v 1.16 2000/06/30 16:00:18 millert Exp $";
d347 2
a348 8
	char *cp;
	FILE *obuf;

#if __GNUC__
	/* Avoid siglongjmp clobbering */
	(void)&cp;
	(void)&obuf;
#endif
@


1.16
log
@warnx?/errx? paranoia (use "%s" not a bare string unless it is a
constant).  These are not security holes but it is worth fixing
them anyway both for robustness and so folks looking for examples
in the tree are not misled into doing something potentially dangerous.
Furthermore, it is a bad idea to assume that pathnames will not
include '%' in them and that error routines don't return strings
with '%' in them (especially in light of the possibility of locales).
@
text
@d1 1
a1 1
/*	$OpenBSD: cmd1.c,v 1.15 2000/04/26 15:47:29 millert Exp $	*/
d41 1
a41 1
static char rcsid[] = "$OpenBSD: cmd1.c,v 1.15 2000/04/26 15:47:29 millert Exp $";
d184 3
d208 1
a208 1
	(void)snprintf(wcount, sizeof(wcount), "%3d/%-5d", mp->m_lines,
d210 11
a220 6
	subjlen = screenwidth - 50 - strlen(wcount);
	name = value("show-rcpt") != NULL ?
		skin(hfield("to", mp)) : nameof(mp, 0);
	if (subjline == NULL || subjlen < 0)		/* pretty pathetic */
		printf("%c%c%3d %-20.20s  %16.16s %s\n",
			curind, dispc, mesg, name, hl.l_date, wcount);
d222 12
a233 1
		printf("%c%c%3d %-20.20s  %16.16s %s \"%.*s\"\n",
d276 13
d296 1
a296 1
	return(type1(msgvec, 1, 1));
d308 1
a308 1
	return(type1(msgvec, 0, 1));
d320 1
a320 1
	return(type1(msgvec, 1, 0));
d332 1
a332 1
	return(type1(msgvec, 0, 0));
d340 1
a340 1
type1(msgvec, doign, page)
d342 1
d349 1
d359 14
a372 2
	if (value("interactive") != NULL &&
	    (page || (cp = value("crt")) != NULL)) {
d379 1
a379 4
			cp = value("PAGER");
			if (cp == NULL || *cp == '\0')
				cp = _PATH_MORE;
			obuf = Popen(cp, "w");
d387 4
d395 1
a395 1
		if (value("quiet") == NULL)
d399 1
d511 1
d513 1
a513 1
	char *cmd;
d516 1
a516 2
		puts("No value set for \"folder\"");
		return(1);
d518 5
a522 3
	if ((cmd = value("LISTER")) == NULL)
		cmd = "ls";
	(void)run_command(cmd, 0, -1, -1, dirname, NULL, NULL);
a542 1
		clearnew();
@


1.15
log
@Change the name of mail's send() function to sendmessages() to
avoid shadowing the libc send(2); gadams@@avernus.com
@
text
@d1 1
a1 1
/*	$OpenBSD: cmd1.c,v 1.14 2000/04/25 16:42:22 millert Exp $	*/
d41 1
a41 1
static char rcsid[] = "$OpenBSD: cmd1.c,v 1.14 2000/04/25 16:42:22 millert Exp $";
d338 1
a338 1
				warn(cp);
@


1.15.2.1
log
@Pull in patch from current (even more to come):
Fix (millert):
warnx?/errx? paranoia (use "%s" not a bare string unless it is a
constant).  These are not security holes but it is worth fixing
them anyway both for robustness and so folks looking for examples
in the tree are not misled into doing something potentially dangerous.
Furthermore, it is a bad idea to assume that pathnames will not
include '%' in them and that error routines don't return strings
with '%' in them (especially in light of the possibility of locales).
@
text
@d1 1
a1 1
/*	$OpenBSD: cmd1.c,v 1.16 2000/06/30 16:00:18 millert Exp $	*/
d41 1
a41 1
static char rcsid[] = "$OpenBSD: cmd1.c,v 1.16 2000/06/30 16:00:18 millert Exp $";
d338 1
a338 1
				warn("%s", cp);
@


1.14
log
@When incorporating new messages, clear the "new" count before the
inc so the count of new messages is useful afterwards.  This makes
mail behave more like the SunOS version in this respect.
@
text
@d1 1
a1 1
/*	$OpenBSD: cmd1.c,v 1.13 1998/05/11 04:15:24 millert Exp $	*/
d41 1
a41 1
static char rcsid[] = "$OpenBSD: cmd1.c,v 1.13 1998/05/11 04:15:24 millert Exp $";
d350 1
a350 1
		(void)send(mp, obuf, doign ? ignore : 0, NULL);
@


1.13
log
@fix scrolling and 'z' command; matt debergalis <deberg@@mit.edu>
@
text
@d1 1
a1 1
/*	$OpenBSD: cmd1.c,v 1.12 1997/11/14 00:23:42 millert Exp $	*/
d41 1
a41 1
static char rcsid[] = "$OpenBSD: cmd1.c,v 1.12 1997/11/14 00:23:42 millert Exp $";
d493 1
@


1.12
log
@NetBSD changes (mostly comsmetic):
    replace panic() with calls to err()/errx()
    use S_IS* instead of doing by hand with S_IF*.
    Use TIMESPEC_TO_TIMEVAL() and gettimeofday instead of time(2)
    Use _POSIX_VDISABLE, not 0
    Kill register
@
text
@d1 1
a1 1
/*	$OpenBSD: cmd1.c,v 1.11 1997/07/30 06:32:38 millert Exp $	*/
d41 1
a41 1
static char rcsid[] = "$OpenBSD: cmd1.c,v 1.11 1997/07/30 06:32:38 millert Exp $";
d107 1
a107 1
	int s, size;
d112 1
a112 1
	s = screen;
d116 1
a116 2
		s++;
		if (s * size > msgCount) {
d120 1
a120 1
		screen = s;
d124 1
a124 1
		if (--s < 0) {
d128 1
a128 1
		screen = s;
@


1.11
log
@Fix one possible oflow (not exploitable) and do a wee bit of KNF.
Much more remains to be done.
@
text
@d1 1
a1 1
/*	$OpenBSD: cmd1.c,v 1.10 1997/07/24 17:27:09 millert Exp $	*/
d41 1
a41 1
static char rcsid[] = "$OpenBSD: cmd1.c,v 1.10 1997/07/24 17:27:09 millert Exp $";
d66 2
a67 3
	register int n, mesg, flag;
	register struct message *mp;
	int size;
d107 1
a107 1
	register int s, size;
d162 1
a162 1
	register int *ip;
d227 1
a227 1
	printf("%d\n", dot - &message[0] + 1);
d239 2
a240 2
	register const struct cmd *cp;
	register int cc;
d313 1
a313 1
	register *ip;
a315 1
	int nlines;
d386 2
a387 2
	register int *ip;
	register struct message *mp;
d429 1
a429 1
	register int *ip;
d447 1
a447 1
	register int *ip;
@


1.10
log
@tempnam(3) goes bye bye.
@
text
@d1 1
a1 1
/*	$OpenBSD: cmd1.c,v 1.9 1997/07/22 18:54:34 millert Exp $	*/
d41 1
a41 1
static char rcsid[] = "$OpenBSD: cmd1.c,v 1.9 1997/07/22 18:54:34 millert Exp $";
d344 1
a344 1
				signal(SIGPIPE, brokpipe);
d360 1
a360 1
		signal(SIGPIPE, SIG_IGN);
d362 1
a362 1
		signal(SIGPIPE, SIG_DFL);
@


1.9
log
@grabh() now returns SIGINT if it was interrupted (previously always
    returned 0 and the return val was always ignored).
Add gethfromtty() to get a header (using grabh) from the tty and
    quit on two ^C's.
Use gethfromtty() when getting Subject, Cc, and Bcc headers so
    we can quit nicely.  Closes PR #291.
Don't use longs where it doesn't make sense.
@
text
@d1 1
a1 1
/*	$OpenBSD: cmd1.c,v 1.8 1997/07/14 00:24:24 millert Exp $	*/
d41 1
a41 1
static char rcsid[] = "$OpenBSD: cmd1.c,v 1.8 1997/07/14 00:24:24 millert Exp $";
d207 2
a208 1
	snprintf(wcount, sizeof(wcount), "%3d/%-5d", mp->m_lines, mp->m_size);
@


1.8
log
@NOSTR -> NULL
Use sigsetjmp/siglongjmp instead of sigjmp/longjmp for portability.
@
text
@d1 1
a1 1
/*	$OpenBSD: cmd1.c,v 1.7 1997/07/13 23:53:57 millert Exp $	*/
d41 1
a41 1
static char rcsid[] = "$OpenBSD: cmd1.c,v 1.7 1997/07/13 23:53:57 millert Exp $";
d412 1
a412 1
			if (readline(ibuf, linebuf, LINESIZE) < 0)
@


1.7
log
@bcopy() -> memcpy() and fix some casts.
@
text
@d1 1
a1 1
/*	$OpenBSD: cmd1.c,v 1.6 1997/07/13 21:21:08 millert Exp $	*/
d41 1
a41 1
static char rcsid[] = "$OpenBSD: cmd1.c,v 1.6 1997/07/13 21:21:08 millert Exp $";
d149 1
a149 1
	if ((cp = value("screen")) != NOSTR && (s = atoi(cp)) > 0)
d189 1
a189 1
	if ((subjline = hfield("subject", mp)) == NOSTR)
d209 1
a209 1
	name = value("show-rcpt") != NOSTR ?
d211 1
a211 1
	if (subjline == NOSTR || subjlen < 0)		/* pretty pathetic */
d249 1
a249 1
		if ((cp+1)->c_name != NOSTR)
d307 1
a307 1
jmp_buf	pipestop;
d319 1
a319 1
	/* Avoid longjmp clobbering */
d325 1
a325 1
	if (setjmp(pipestop))
d327 2
a328 2
	if (value("interactive") != NOSTR &&
	    (page || (cp = value("crt")) != NOSTR)) {
d350 1
a350 1
		if (value("quiet") == NOSTR)
d352 1
a352 1
		(void)send(mp, obuf, doign ? ignore : 0, NOSTR);
d374 1
a374 1
	longjmp(pipestop, 1);
d395 1
a395 1
	if (valtop != NOSTR) {
d405 1
a405 1
		if (value("quiet") == NOSTR)
d472 1
a472 1
	if ((cmd = value("LISTER")) == NOSTR)
d474 1
a474 1
	(void)run_command(cmd, 0, -1, -1, dirname, NOSTR, NOSTR);
@


1.6
log
@Merge in NetBSD and 4.4BSD-lite2 changes as well as some of my own.
 - handle long lines safely (from NetBSD)
 - use puts/fputs and putchar/putc when it makes sense
 - use err/errx and warn/warnx when it makes sense
 - make return() and sizeof() style consisten
 - some more buffer safety
@
text
@d1 1
a1 1
/*	$OpenBSD: cmd1.c,v 1.5 1997/05/30 08:51:34 deraadt Exp $	*/
d41 1
a41 1
static char rcsid[] = "$OpenBSD: cmd1.c,v 1.5 1997/05/30 08:51:34 deraadt Exp $";
d188 1
a188 1
	(void) readline(setinput(mp), headline, LINESIZE);
d320 2
a321 2
	(void) &cp;
	(void) &obuf;
d352 1
a352 1
		(void) send(mp, obuf, doign ? ignore : 0, NOSTR);
d474 1
a474 1
	(void) run_command(cmd, 0, -1, -1, dirname, NOSTR, NOSTR);
@


1.5
log
@overflows abound
@
text
@d1 2
a2 2
/*	$OpenBSD: cmd1.c,v 1.4 1997/03/29 03:01:44 millert Exp $	*/
/*	$NetBSD: cmd1.c,v 1.5 1996/06/08 19:48:11 christos Exp $	*/
d39 1
a39 1
static char sccsid[] = "@@(#)cmd1.c	8.1 (Berkeley) 6/6/93";
d41 1
a41 1
static char rcsid[] = "$OpenBSD: cmd1.c,v 1.4 1997/03/29 03:01:44 millert Exp $";
d94 1
a94 1
		printf("No more mail.\n");
d119 1
a119 1
			printf("On last screenful of messages\n");
d127 1
a127 1
			printf("On first screenful of messages\n");
d150 2
a151 2
		return s;
	return screenheight - 4;
d207 1
a207 1
	sprintf(wcount, "%3d/%-5d", mp->m_lines, mp->m_size);
d242 1
a242 1
	printf("Commands are:\n");
d246 1
a246 1
			printf("\n");
d252 1
a252 1
			printf("%s\n", cp->c_name);
d265 1
a265 1
	return (type1(msgvec, 1, 1));
d277 1
a277 1
	return (type1(msgvec, 0, 1));
d340 1
a340 1
				perror(cp);
d360 1
a360 1
		Pclose(obuf);
d410 1
a410 1
			printf("\n");
d468 3
a470 3
	if (getfold(dirname, sizeof dirname) < 0) {
		printf("No value set for \"folder\"\n");
		return 1;
d475 25
a499 1
	return 0;
@


1.4
log
@Use ``mail.local -H'' to do dot locking so we can have mode 755 mail
spool, change an occurrence of tempnam() to mkstemp(), change some
longs and shorts to ints.  Mail is now usable again.
@
text
@d1 1
a1 1
/*	$OpenBSD: cmd1.c,v 1.3 1996/06/11 12:53:32 deraadt Exp $	*/
d41 1
a41 1
static char rcsid[] = "$OpenBSD: cmd1.c,v 1.3 1996/06/11 12:53:32 deraadt Exp $";
d465 1
a465 1
	char dirname[BUFSIZ];
d468 1
a468 1
	if (getfold(dirname) < 0) {
@


1.3
log
@from christos;
- Fix PR/105: Implement dot locking protocol and check return value of flock.
- Fix PR/2247: Don't call unknown users "ubluit". Issue an error message.
- Fix/add prototypes.
- Fix warnings.
- Use POSIX signal mask calls.
@
text
@d1 1
a1 1
/*	$OpenBSD: cmd1.c,v 1.5 1996/06/08 19:48:11 christos Exp $	*/
d41 1
a41 1
static char rcsid[] = "$OpenBSD: cmd1.c,v 1.5 1996/06/08 19:48:11 christos Exp $";
d207 1
a207 1
	sprintf(wcount, "%3d/%-5ld", mp->m_lines, mp->m_size);
@


1.2
log
@From NetBSD: merge of 960317
@
text
@d1 2
a2 1
/*	$OpenBSD$	*/
d38 5
a42 2
static char sccsid[] = "from: @@(#)cmd1.c	8.1 (Berkeley) 6/6/93";
static char rcsid[] = "$OpenBSD$";
d62 2
a63 2
headers(msgvec)
	int *msgvec;
d65 1
d104 2
a105 2
scroll(arg)
	char arg[];
d107 1
d159 2
a160 2
from(msgvec)
	int *msgvec;
d162 1
d224 2
a225 1
pdot()
d235 2
a236 1
pcmdlist()
d261 2
a262 2
more(msgvec)
	int *msgvec;
d264 1
d272 2
a273 2
More(msgvec)
	int *msgvec;
d275 1
d284 2
a285 2
type(msgvec)
	int *msgvec;
d287 1
d296 2
a297 2
Type(msgvec)
	int *msgvec;
d299 1
d314 2
a315 2
	register struct message *mp;
	register char *cp;
d318 5
d383 2
a384 2
top(msgvec)
	int *msgvec;
d386 1
d426 2
a427 2
stouch(msgvec)
	int msgvec[];
d429 1
d444 2
a445 2
mboxit(msgvec)
	int msgvec[];
d447 1
d462 2
a463 1
folders()
@


1.1
log
@Initial revision
@
text
@d1 2
d38 1
a38 1
static char rcsid[] = "$Id: cmd1.c,v 1.3 1994/06/29 05:09:07 deraadt Exp $";
d229 2
a230 1
	register struct cmd *cp;
a231 1
	extern struct cmd cmdtab[];
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@
