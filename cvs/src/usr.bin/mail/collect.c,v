head	1.34;
access;
symbols
	OPENBSD_6_1_BASE:1.34
	OPENBSD_6_0:1.34.0.12
	OPENBSD_6_0_BASE:1.34
	OPENBSD_5_9:1.34.0.8
	OPENBSD_5_9_BASE:1.34
	OPENBSD_5_8:1.34.0.10
	OPENBSD_5_8_BASE:1.34
	OPENBSD_5_7:1.34.0.2
	OPENBSD_5_7_BASE:1.34
	OPENBSD_5_6:1.34.0.6
	OPENBSD_5_6_BASE:1.34
	OPENBSD_5_5:1.34.0.4
	OPENBSD_5_5_BASE:1.34
	OPENBSD_5_4:1.33.0.10
	OPENBSD_5_4_BASE:1.33
	OPENBSD_5_3:1.33.0.8
	OPENBSD_5_3_BASE:1.33
	OPENBSD_5_2:1.33.0.6
	OPENBSD_5_2_BASE:1.33
	OPENBSD_5_1_BASE:1.33
	OPENBSD_5_1:1.33.0.4
	OPENBSD_5_0:1.33.0.2
	OPENBSD_5_0_BASE:1.33
	OPENBSD_4_9:1.32.0.6
	OPENBSD_4_9_BASE:1.32
	OPENBSD_4_8:1.32.0.4
	OPENBSD_4_8_BASE:1.32
	OPENBSD_4_7:1.32.0.2
	OPENBSD_4_7_BASE:1.32
	OPENBSD_4_6:1.30.0.6
	OPENBSD_4_6_BASE:1.30
	OPENBSD_4_5:1.30.0.2
	OPENBSD_4_5_BASE:1.30
	OPENBSD_4_4:1.29.0.2
	OPENBSD_4_4_BASE:1.29
	OPENBSD_4_3:1.28.0.2
	OPENBSD_4_3_BASE:1.28
	OPENBSD_4_2:1.27.0.16
	OPENBSD_4_2_BASE:1.27
	OPENBSD_4_1:1.27.0.14
	OPENBSD_4_1_BASE:1.27
	OPENBSD_4_0:1.27.0.12
	OPENBSD_4_0_BASE:1.27
	OPENBSD_3_9:1.27.0.10
	OPENBSD_3_9_BASE:1.27
	OPENBSD_3_8:1.27.0.8
	OPENBSD_3_8_BASE:1.27
	OPENBSD_3_7:1.27.0.6
	OPENBSD_3_7_BASE:1.27
	OPENBSD_3_6:1.27.0.4
	OPENBSD_3_6_BASE:1.27
	OPENBSD_3_5:1.27.0.2
	OPENBSD_3_5_BASE:1.27
	OPENBSD_3_4:1.25.0.2
	OPENBSD_3_4_BASE:1.25
	OPENBSD_3_3:1.24.0.6
	OPENBSD_3_3_BASE:1.24
	OPENBSD_3_2:1.24.0.4
	OPENBSD_3_2_BASE:1.24
	OPENBSD_3_1:1.24.0.2
	OPENBSD_3_1_BASE:1.24
	OPENBSD_3_0:1.21.0.2
	OPENBSD_3_0_BASE:1.21
	OPENBSD_2_9_BASE:1.20
	OPENBSD_2_9:1.20.0.2
	OPENBSD_2_8:1.19.0.2
	OPENBSD_2_8_BASE:1.19
	OPENBSD_2_7:1.18.0.2
	OPENBSD_2_7_BASE:1.18
	OPENBSD_2_6:1.17.0.6
	OPENBSD_2_6_BASE:1.17
	OPENBSD_2_5:1.17.0.4
	OPENBSD_2_5_BASE:1.17
	OPENBSD_2_4:1.17.0.2
	OPENBSD_2_4_BASE:1.17
	OPENBSD_2_3:1.15.0.2
	OPENBSD_2_3_BASE:1.15
	OPENBSD_2_2:1.14.0.2
	OPENBSD_2_2_BASE:1.14
	OPENBSD_2_1:1.5.0.2
	OPENBSD_2_1_BASE:1.5
	OPENBSD_2_0:1.2.0.2
	OPENBSD_2_0_BASE:1.2
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.34
date	2014.01.17.18.42.30;	author okan;	state Exp;
branches;
next	1.33;

1.33
date	2011.04.06.11.36.26;	author miod;	state Exp;
branches;
next	1.32;

1.32
date	2009.10.27.23.59.40;	author deraadt;	state Exp;
branches;
next	1.31;

1.31
date	2009.07.28.16.05.04;	author martynas;	state Exp;
branches;
next	1.30;

1.30
date	2008.11.03.15.42.35;	author martynas;	state Exp;
branches;
next	1.29;

1.29
date	2008.07.16.14.53.41;	author martynas;	state Exp;
branches;
next	1.28;

1.28
date	2007.09.10.14.29.53;	author tobias;	state Exp;
branches;
next	1.27;

1.27
date	2004.01.03.20.06.59;	author millert;	state Exp;
branches;
next	1.26;

1.26
date	2003.10.24.20.32.06;	author avsm;	state Exp;
branches;
next	1.25;

1.25
date	2003.06.03.02.56.11;	author millert;	state Exp;
branches;
next	1.24;

1.24
date	2002.04.08.20.27.17;	author millert;	state Exp;
branches;
next	1.23;

1.23
date	2001.11.21.15.26.39;	author millert;	state Exp;
branches;
next	1.22;

1.22
date	2001.11.20.20.50.00;	author millert;	state Exp;
branches;
next	1.21;

1.21
date	2001.06.23.23.04.21;	author millert;	state Exp;
branches
	1.21.2.1;
next	1.20;

1.20
date	2001.01.16.05.36.08;	author millert;	state Exp;
branches
	1.20.2.1;
next	1.19;

1.19
date	2000.06.30.16.00.17;	author millert;	state Exp;
branches;
next	1.18;

1.18
date	2000.04.26.15.47.30;	author millert;	state Exp;
branches
	1.18.2.1;
next	1.17;

1.17
date	98.06.12.18.07.54;	author millert;	state Exp;
branches;
next	1.16;

1.16
date	98.05.04.05.37.47;	author millert;	state Exp;
branches;
next	1.15;

1.15
date	97.11.14.00.23.45;	author millert;	state Exp;
branches;
next	1.14;

1.14
date	97.07.30.07.19.30;	author millert;	state Exp;
branches;
next	1.13;

1.13
date	97.07.30.06.32.39;	author millert;	state Exp;
branches;
next	1.12;

1.12
date	97.07.24.17.27.10;	author millert;	state Exp;
branches;
next	1.11;

1.11
date	97.07.22.18.54.36;	author millert;	state Exp;
branches;
next	1.10;

1.10
date	97.07.22.18.26.24;	author millert;	state Exp;
branches;
next	1.9;

1.9
date	97.07.14.15.56.23;	author millert;	state Exp;
branches;
next	1.8;

1.8
date	97.07.14.00.24.25;	author millert;	state Exp;
branches;
next	1.7;

1.7
date	97.07.13.23.53.58;	author millert;	state Exp;
branches;
next	1.6;

1.6
date	97.07.13.21.21.10;	author millert;	state Exp;
branches;
next	1.5;

1.5
date	97.04.13.20.32.06;	author deraadt;	state Exp;
branches;
next	1.4;

1.4
date	97.04.13.20.22.39;	author deraadt;	state Exp;
branches;
next	1.3;

1.3
date	97.04.10.15.33.50;	author deraadt;	state Exp;
branches;
next	1.2;

1.2
date	96.06.11.12.53.35;	author deraadt;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.45.38;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.45.38;	author deraadt;	state Exp;
branches;
next	;

1.18.2.1
date	2000.10.06.21.16.14;	author jason;	state Exp;
branches;
next	;

1.20.2.1
date	2002.04.11.23.33.29;	author miod;	state Exp;
branches;
next	;

1.21.2.1
date	2002.04.13.19.09.48;	author millert;	state Exp;
branches;
next	;


desc
@@


1.34
log
@ctype and other sign extension fixes.

with deraadt and millert, ok millert
@
text
@/*	$OpenBSD: collect.c,v 1.33 2011/04/06 11:36:26 miod Exp $	*/
/*	$NetBSD: collect.c,v 1.9 1997/07/09 05:25:45 mikel Exp $	*/

/*
 * Copyright (c) 1980, 1993
 *	The Regents of the University of California.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */

/*
 * Mail -- a mail program
 *
 * Collect input from standard input, handling
 * ~ escapes.
 */

#include "rcv.h"
#include "extern.h"

/*
 * Read a message from standard output and return a read file to it
 * or NULL on error.
 */

/*
 * The following hokiness with global variables is so that on
 * receipt of an interrupt signal, the partial message can be salted
 * away on dead.letter.
 */
static	FILE	*collf;			/* File for saving away */
static	int	hadintr;		/* Have seen one SIGINT so far */

FILE *
collect(struct header *hp, int printheaders)
{
	FILE *fbuf;
	int lc, cc, fd, c, t, lastlong, rc, sig;
	int escape, eofcount, longline;
	char getsub;
	char linebuf[LINESIZE], tempname[PATHSIZE], *cp;

	collf = NULL;
	eofcount = 0;
	hadintr = 0;
	lastlong = 0;
	longline = 0;
	if ((cp = value("escape")) != NULL)
		escape = *cp;
	else
		escape = ESCAPE;
	noreset++;

	(void)snprintf(tempname, sizeof(tempname),
	    "%s/mail.RsXXXXXXXXXX", tmpdir);
	if ((fd = mkstemp(tempname)) == -1 ||
	    (collf = Fdopen(fd, "w+")) == NULL) {
		warn("%s", tempname);
		goto err;
	}
	(void)rm(tempname);

	/*
	 * If we are going to prompt for a subject,
	 * refrain from printing a newline after
	 * the headers (since some people mind).
	 */
	t = GTO|GSUBJECT|GCC|GNL;
	getsub = 0;
	if (hp->h_subject == NULL && value("interactive") != NULL &&
	    (value("ask") != NULL || value("asksub") != NULL))
		t &= ~GNL, getsub++;
	if (printheaders) {
		puthead(hp, stdout, t);
		fflush(stdout);
	}
	if (getsub && gethfromtty(hp, GSUBJECT) == -1)
		goto err;

	if (0) {
cont:
		/* Come here for printing the after-suspend message. */
		if (isatty(0)) {
			puts("(continue)");
			fflush(stdout);
		}
	}
	for (;;) {
		c = readline(stdin, linebuf, LINESIZE, &sig);

		/* Act on any signal caught during readline() ignoring 'c' */
		switch (sig) {
		case 0:
			break;
		case SIGINT:
			if (collabort())
				goto err;
			continue;
		case SIGHUP:
			rewind(collf);
			savedeadletter(collf);
			/*
			 * Let's pretend nobody else wants to clean up,
			 * a true statement at this time.
			 */
			exit(1);
		default:
			/* Stopped due to job control */
			(void)kill(0, sig);
			goto cont;
		}

		/* No signal, check for error */
		if (c < 0) {
			if (value("interactive") != NULL &&
			    value("ignoreeof") != NULL && ++eofcount < 25) {
				puts("Use \".\" to terminate letter");
				continue;
			}
			break;
		}
		lastlong = longline;
		longline = (c == LINESIZE - 1);
		eofcount = 0;
		hadintr = 0;
		if (linebuf[0] == '.' && linebuf[1] == '\0' &&
		    value("interactive") != NULL && !lastlong &&
		    (value("dot") != NULL || value("ignoreeof") != NULL))
			break;
		if (linebuf[0] != escape || value("interactive") == NULL ||
		    lastlong) {
			if (putline(collf, linebuf, !longline) < 0)
				goto err;
			continue;
		}
		c = (unsigned char)linebuf[1];
		switch (c) {
		default:
			/*
			 * On double escape, just send the single one.
			 * Otherwise, it's an error.
			 */
			if (c == escape) {
				if (putline(collf, &linebuf[1], !longline) < 0)
					goto err;
				else
					break;
			}
			puts("Unknown tilde escape.");
			break;
		case '!':
			/*
			 * Shell escape, send the balance of the
			 * line to sh -c.
			 */
			shell(&linebuf[2]);
			break;
		case ':':
		case '_':
			/*
			 * Escape to command mode, but be nice!
			 */
			execute(&linebuf[2], 1);
			goto cont;
		case '.':
			/*
			 * Simulate end of file on input.
			 */
			goto out;
		case 'q':
			/*
			 * Force a quit of sending mail.
			 * Act like an interrupt happened.
			 */
			hadintr++;
			collabort();
			fputs("Interrupt\n", stderr);
			goto err;
		case 'x':
			/*
			 * Force a quit of sending mail.
			 * Do not save the message.
			 */
			goto err;
		case 'h':
			/*
			 * Grab a bunch of headers.
			 */
			grabh(hp, GTO|GSUBJECT|GCC|GBCC);
			goto cont;
		case 't':
			/*
			 * Add to the To list.
			 */
			hp->h_to = cat(hp->h_to, extract(&linebuf[2], GTO));
			break;
		case 's':
			/*
			 * Set the Subject list.
			 */
			cp = &linebuf[2];
			while (isspace((unsigned char)*cp))
				cp++;
			hp->h_subject = savestr(cp);
			break;
		case 'c':
			/*
			 * Add to the CC list.
			 */
			hp->h_cc = cat(hp->h_cc, extract(&linebuf[2], GCC));
			break;
		case 'b':
			/*
			 * Add stuff to blind carbon copies list.
			 */
			hp->h_bcc = cat(hp->h_bcc, extract(&linebuf[2], GBCC));
			break;
		case 'd':
			linebuf[2] = '\0';
			strlcat(linebuf, getdeadletter(), sizeof(linebuf));
			/* fall into . . . */
		case 'r':
		case '<':
			/*
			 * Invoke a file:
			 * Search for the file name,
			 * then open it and copy the contents to collf.
			 */
			cp = &linebuf[2];
			while (isspace((unsigned char)*cp))
				cp++;
			if (*cp == '\0') {
				puts("Interpolate what file?");
				break;
			}
			cp = expand(cp);
			if (cp == NULL)
				break;
			if (isdir(cp)) {
				printf("%s: Directory\n", cp);
				break;
			}
			if ((fbuf = Fopen(cp, "r")) == NULL) {
				warn("%s", cp);
				break;
			}
			printf("\"%s\" ", cp);
			fflush(stdout);
			lc = 0;
			cc = 0;
			while ((rc = readline(fbuf, linebuf, LINESIZE, NULL)) >= 0) {
				if (rc != LINESIZE - 1)
					lc++;
				if ((t = putline(collf, linebuf,
						 rc != LINESIZE-1)) < 0) {
					(void)Fclose(fbuf);
					goto err;
				}
				cc += t;
			}
			(void)Fclose(fbuf);
			printf("%d/%d\n", lc, cc);
			break;
		case 'w':
			/*
			 * Write the message on a file.
			 */
			cp = &linebuf[2];
			while (*cp == ' ' || *cp == '\t')
				cp++;
			if (*cp == '\0') {
				fputs("Write what file!?\n", stderr);
				break;
			}
			if ((cp = expand(cp)) == NULL)
				break;
			rewind(collf);
			exwrite(cp, collf, 1);
			break;
		case 'm':
		case 'M':
		case 'f':
		case 'F':
			/*
			 * Interpolate the named messages, if we
			 * are in receiving mail mode.  Does the
			 * standard list processing garbage.
			 * If ~f is given, we don't shift over.
			 */
			if (forward(linebuf + 2, collf, tempname, c) < 0)
				goto err;
			goto cont;
		case '?':
			if ((fbuf = Fopen(_PATH_TILDE, "r")) == NULL) {
				warn(_PATH_TILDE);
				break;
			}
			while ((t = getc(fbuf)) != EOF)
				(void)putchar(t);
			(void)Fclose(fbuf);
			break;
		case 'p':
			/*
			 * Print out the current state of the
			 * message without altering anything.
			 */
			rewind(collf);
			puts("-------\nMessage contains:");
			puthead(hp, stdout, GTO|GSUBJECT|GCC|GBCC|GNL);
			while ((t = getc(collf)) != EOF)
				(void)putchar(t);
			goto cont;
		case '|':
			/*
			 * Pipe message through command.
			 * Collect output as new message.
			 */
			rewind(collf);
			mespipe(collf, &linebuf[2]);
			goto cont;
		case 'v':
		case 'e':
			/*
			 * Edit the current message.
			 * 'e' means to use EDITOR
			 * 'v' means to use VISUAL
			 */
			rewind(collf);
			mesedit(collf, c);
			goto cont;
		}
	}

	if (value("interactive") != NULL) {
		if (value("askcc") != NULL || value("askbcc") != NULL) {
			if (value("askcc") != NULL) {
				if (gethfromtty(hp, GCC) == -1)
					goto err;
			}
			if (value("askbcc") != NULL) {
				if (gethfromtty(hp, GBCC) == -1)
					goto err;
			}
		} else {
			puts("EOT");
			(void)fflush(stdout);
		}
	}
	goto out;
err:
	if (collf != NULL) {
		(void)Fclose(collf);
		collf = NULL;
	}
out:
	if (collf != NULL)
		rewind(collf);
	noreset--;
	return(collf);
}

/*
 * Write a file, ex-like if f set.
 */
int
exwrite(char *name, FILE *fp, int f)
{
	FILE *of;
	int c;
	ssize_t cc, lc;
	struct stat junk;

	if (f) {
		printf("\"%s\" ", name);
		fflush(stdout);
	}
	if (stat(name, &junk) >= 0 && S_ISREG(junk.st_mode)) {
		if (!f)
			fprintf(stderr, "%s: ", name);
		fputs("File exists\n", stderr);
		return(-1);
	}
	if ((of = Fopen(name, "w")) == NULL) {
		warn(NULL);
		return(-1);
	}
	lc = 0;
	cc = 0;
	while ((c = getc(fp)) != EOF) {
		cc++;
		if (c == '\n')
			lc++;
		(void)putc(c, of);
		if (ferror(of)) {
			warn("%s", name);
			(void)Fclose(of);
			return(-1);
		}
	}
	(void)Fclose(of);
	printf("%lld/%lld\n", (long long)lc, (long long)cc);
	fflush(stdout);
	return(0);
}

/*
 * Edit the message being collected on fp.
 * On return, make the edit file the new temp file.
 */
void
mesedit(FILE *fp, int c)
{
	FILE *nf;
	struct sigaction oact;
	sigset_t oset;

	(void)ignoresig(SIGINT, &oact, &oset);
	nf = run_editor(fp, (off_t)-1, c, 0);
	if (nf != NULL) {
		fseek(nf, 0L, SEEK_END);
		collf = nf;
		(void)Fclose(fp);
	}
	(void)sigprocmask(SIG_SETMASK, &oset, NULL);
	(void)sigaction(SIGINT, &oact, NULL);
}

/*
 * Pipe the message through the command.
 * Old message is on stdin of command;
 * New message collected from stdout.
 * Sh -c must return 0 to accept the new message.
 */
void
mespipe(FILE *fp, char *cmd)
{
	FILE *nf;
	int fd;
	char *shell, tempname[PATHSIZE];
	struct sigaction oact;
	sigset_t oset;

	(void)ignoresig(SIGINT, &oact, &oset);
	(void)snprintf(tempname, sizeof(tempname),
	    "%s/mail.ReXXXXXXXXXX", tmpdir);
	if ((fd = mkstemp(tempname)) == -1 ||
	    (nf = Fdopen(fd, "w+")) == NULL) {
		warn("%s", tempname);
		goto out;
	}
	(void)rm(tempname);
	/*
	 * stdin = current message.
	 * stdout = new message.
	 */
	shell = value("SHELL");
	if (run_command(shell,
	    0, fileno(fp), fileno(nf), "-c", cmd, NULL) < 0) {
		(void)Fclose(nf);
		goto out;
	}
	if (fsize(nf) == 0) {
		fprintf(stderr, "No bytes from \"%s\" !?\n", cmd);
		(void)Fclose(nf);
		goto out;
	}
	/*
	 * Take new files.
	 */
	(void)fseek(nf, 0L, SEEK_END);
	collf = nf;
	(void)Fclose(fp);
out:
	(void)sigprocmask(SIG_SETMASK, &oset, NULL);
	(void)sigaction(SIGINT, &oact, NULL);
}

/*
 * Interpolate the named messages into the current
 * message, preceding each line with a tab.
 * Return a count of the number of characters now in
 * the message, or -1 if an error is encountered writing
 * the message temporary.  The flag argument is 'm' if we
 * should shift over and 'f' if not.
 */
int
forward(char *ms, FILE *fp, char *fn, int f)
{
	int *msgvec;
	struct ignoretab *ig;
	char *tabst;

	msgvec = (int *)salloc((msgCount+1) * sizeof(*msgvec));
	if (msgvec == NULL)
		return(0);
	if (getmsglist(ms, msgvec, 0) < 0)
		return(0);
	if (*msgvec == 0) {
		*msgvec = first(0, MMNORM);
		if (*msgvec == 0) {
			puts("No appropriate messages");
			return(0);
		}
		msgvec[1] = 0;
	}
	if (tolower(f) == 'f')
		tabst = NULL;
	else if ((tabst = value("indentprefix")) == NULL)
		tabst = "\t";
	ig = isupper(f) ? NULL : ignore;
	fputs("Interpolating:", stdout);
	for (; *msgvec != 0; msgvec++) {
		struct message *mp = message + *msgvec - 1;

		touch(mp);
		printf(" %d", *msgvec);
		if (sendmessage(mp, fp, ig, tabst) < 0) {
			warn("%s", fn);
			return(-1);
		}
	}
	putchar('\n');
	return(0);
}

/*
 * User aborted during message composition.
 * Save the partial message in ~/dead.letter.
 */
int
collabort(void)
{
	/*
	 * the control flow is subtle, because we can be called from ~q.
	 */
	if (hadintr == 0 && isatty(0)) {
		if (value("ignore") != NULL) {
			puts("@@");
			fflush(stdout);
			clearerr(stdin);
		} else {
			fflush(stdout);
			fputs("\n(Interrupt -- one more to kill letter)\n",
			    stderr);
			hadintr++;
		}
		return(0);
	}
	fflush(stdout);
	rewind(collf);
	if (value("nosave") == NULL)
		savedeadletter(collf);
	return(1);
}

void
savedeadletter(FILE *fp)
{
	FILE *dbuf;
	int c;
	char *cp;

	if (fsize(fp) == 0)
		return;
	cp = getdeadletter();
	c = umask(077);
	dbuf = Fopen(cp, "a");
	(void)umask(c);
	if (dbuf == NULL)
		return;
	while ((c = getc(fp)) != EOF)
		(void)putc(c, dbuf);
	(void)Fclose(dbuf);
	rewind(fp);
}

int
gethfromtty(struct header *hp, int gflags)
{

	hadintr = 0;
	while (grabh(hp, gflags) != 0) {
		if (collabort())
			return(-1);
	}
	return(0);
}
@


1.33
log
@Avoid using NULL in non-pointer contexts: use 0 for integer values and '\0'
for chars.
@
text
@d1 1
a1 1
/*	$OpenBSD: collect.c,v 1.32 2009/10/27 23:59:40 deraadt Exp $	*/
d158 1
a158 1
		c = linebuf[1];
d224 1
a224 1
			while (isspace(*cp))
d252 1
a252 1
			while (isspace(*cp))
@


1.32
log
@rcsid[] and sccsid[] and copyright[] are essentially unmaintained (and
unmaintainable).  these days, people use source.  these id's do not provide
any benefit, and do hurt the small install media
(the 33,000 line diff is essentially mechanical)
ok with the idea millert, ok dms
@
text
@d1 1
a1 1
/*	$OpenBSD: collect.c,v 1.31 2009/07/28 16:05:04 martynas Exp $	*/
d526 1
a526 1
		msgvec[1] = NULL;
@


1.31
log
@remove core / tilde C.  it's useless, doesn't work, never has been
documented, ^\ should be used instead.  ok millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: collect.c,v 1.30 2008/11/03 15:42:35 martynas Exp $	*/
a31 8

#ifndef lint
#if 0
static const char sccsid[] = "@@(#)collect.c	8.2 (Berkeley) 4/19/94";
#else
static const char rcsid[] = "$OpenBSD: collect.c,v 1.30 2008/11/03 15:42:35 martynas Exp $";
#endif
#endif /* not lint */
@


1.30
log
@add ~x;  which is quite handy sometimes.  per posix
man page tweak&ok jmc@@.  ok millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: collect.c,v 1.29 2008/07/16 14:53:41 martynas Exp $	*/
d37 1
a37 1
static const char rcsid[] = "$OpenBSD: collect.c,v 1.29 2008/07/16 14:53:41 martynas Exp $";
a179 6
			break;
		case 'C':
			/*
			 * Dump core.
			 */
			core(NULL);
@


1.29
log
@- use strncmp/strncasecmp instead of comparing by character
- simplify istrlcpy, no need to check for isupper
- line[0] is redundant, because strcasecmp will take care of it
ok millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: collect.c,v 1.28 2007/09/10 14:29:53 tobias Exp $	*/
d37 1
a37 1
static const char rcsid[] = "$OpenBSD: collect.c,v 1.28 2007/09/10 14:29:53 tobias Exp $";
d214 6
@


1.28
log
@Proper use of fseek/fseeko macros.

OK joris@@, otto@@
@
text
@d1 1
a1 1
/*	$OpenBSD: collect.c,v 1.27 2004/01/03 20:06:59 millert Exp $	*/
d37 1
a37 1
static const char rcsid[] = "$OpenBSD: collect.c,v 1.27 2004/01/03 20:06:59 millert Exp $";
d536 1
a536 1
	if (f == 'f' || f == 'F')
@


1.27
log
@Fix format type mismatch (int vs. ssize_t).
@
text
@d1 1
a1 1
/*	$OpenBSD: collect.c,v 1.26 2003/10/24 20:32:06 avsm Exp $	*/
d37 1
a37 1
static const char rcsid[] = "$OpenBSD: collect.c,v 1.26 2003/10/24 20:32:06 avsm Exp $";
d450 1
a450 1
		fseek(nf, 0L, 2);
d500 1
a500 1
	(void)fseek(nf, 0L, 2);
@


1.26
log
@dont compare int to NULL, millert@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: collect.c,v 1.25 2003/06/03 02:56:11 millert Exp $	*/
d37 1
a37 1
static const char rcsid[] = "$OpenBSD: collect.c,v 1.25 2003/06/03 02:56:11 millert Exp $";
d431 1
a431 1
	printf("%d/%d\n", lc, cc);
@


1.25
log
@Remove the advertising clause in the UCB license which Berkeley
rescinded 22 July 1999.  Proofed by myself and Theo.
@
text
@d1 1
a1 1
/*	$OpenBSD: collect.c,v 1.24 2002/04/08 20:27:17 millert Exp $	*/
d37 1
a37 1
static const char rcsid[] = "$OpenBSD: collect.c,v 1.24 2002/04/08 20:27:17 millert Exp $";
d530 1
a530 1
		if (*msgvec == NULL) {
@


1.24
log
@Don't do tilde escapes unless we are in interactive mode.  Now the
behavior matches the man page...
@
text
@d1 1
a1 1
/*	$OpenBSD: collect.c,v 1.23 2001/11/21 15:26:39 millert Exp $	*/
d16 1
a16 5
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
d37 1
a37 1
static const char rcsid[] = "$OpenBSD: collect.c,v 1.23 2001/11/21 15:26:39 millert Exp $";
@


1.23
log
@o ANSIfy
o Style nits
o Use const to silent stupid -Wall warnings
o strnc{py,at} -> strlc{py,at}
o Use strpbrk() instead of homegrown anyof()
o Use NULL instead of #defines with 0 cast to a pointer
This still could use a proper audit
@
text
@d1 1
a1 1
/*	$OpenBSD: collect.c,v 1.22 2001/11/20 20:50:00 millert Exp $	*/
d41 1
a41 1
static const char rcsid[] = "$OpenBSD: collect.c,v 1.22 2001/11/20 20:50:00 millert Exp $";
d164 2
a165 1
		if (linebuf[0] != escape || lastlong) {
@


1.22
log
@Major signal overhaul.  We no longer longjmp all over the place.
Instead, routines responsible to gathering user input (or in some
cases outputting data) catch the signals and set flags as needed.
Because of this some handlers are install without the SA_RESTART
flag so syscalls are not restarted and we can check the flag.  All
signal handlers are now safe.

This should make the flow of control a bit more grokable but the
code is still ugly.
@
text
@d1 1
a1 1
/*	$OpenBSD: collect.c,v 1.21 2001/06/23 23:04:21 millert Exp $	*/
d39 1
a39 1
static char sccsid[] = "@@(#)collect.c	8.2 (Berkeley) 4/19/94";
d41 1
a41 1
static char rcsid[] = "$OpenBSD: collect.c,v 1.21 2001/06/23 23:04:21 millert Exp $";
a64 1

d69 1
a69 3
collect(hp, printheaders)
	struct header *hp;
	int printheaders;
d252 2
a253 2
			strncpy(linebuf + 2, getdeadletter(), sizeof(linebuf) - 3);
			linebuf[sizeof(linebuf) - 1] = '\0';
d399 1
a399 4
exwrite(name, fp, f)
	char name[];
	FILE *fp;
	int f;
d444 1
a444 3
mesedit(fp, c)
	FILE *fp;
	int c;
d468 1
a468 3
mespipe(fp, cmd)
	FILE *fp;
	char cmd[];
d520 1
a520 5
forward(ms, fp, fn, f)
	char ms[];
	FILE *fp;
	char *fn;
	int f;
d564 1
a564 1
collabort()
d590 1
a590 2
savedeadletter(fp)
	FILE *fp;
d611 1
a611 3
gethfromtty(hp, gflags)
	struct header *hp;
	int gflags;
@


1.21
log
@Remove evil #ifdef __GNUC__ garbage to avoid longjmp clobbering and
use volatile instead.
@
text
@d1 1
a1 1
/*	$OpenBSD: collect.c,v 1.20 2001/01/16 05:36:08 millert Exp $	*/
d41 1
a41 1
static char rcsid[] = "$OpenBSD: collect.c,v 1.20 2001/01/16 05:36:08 millert Exp $";
a65 5
static	sig_t	saveint;		/* Previous SIGINT value */
static	sig_t	savehup;		/* Previous SIGHUP value */
static	sig_t	savetstp;		/* Previous SIGTSTP value */
static	sig_t	savettou;		/* Previous SIGTTOU value */
static	sig_t	savettin;		/* Previous SIGTTIN value */
a68 4
static	sigjmp_buf	colljmp;	/* To get back to work */
static	int		colljmp_p;	/* whether to long jump */
static	sigjmp_buf	collabort;	/* To end collection with error */

d75 3
a77 3
	int lc, cc, fd, c, t, lastlong, rc;
	volatile int escape, eofcount, longline;
	volatile char getsub;
a78 1
	sigset_t oset, nset;
d81 9
a89 22
	/*
	 * Start catching signals from here, but we're still die on interrupts
	 * until we're in the main loop.
	 */
	sigemptyset(&nset);
	sigaddset(&nset, SIGINT);
	sigaddset(&nset, SIGHUP);
	sigprocmask(SIG_BLOCK, &nset, &oset);
	if ((saveint = signal(SIGINT, SIG_IGN)) != SIG_IGN)
		(void)signal(SIGINT, collint);
	if ((savehup = signal(SIGHUP, SIG_IGN)) != SIG_IGN)
		(void)signal(SIGHUP, collhup);
	savetstp = signal(SIGTSTP, collstop);
	savettou = signal(SIGTTOU, collstop);
	savettin = signal(SIGTTIN, collstop);
	if (sigsetjmp(collabort, 1) || sigsetjmp(colljmp, 1)) {
		(void)rm(tempname);
		goto err;
	}
	sigdelset(&oset, SIGINT);
	sigdelset(&oset, SIGHUP);
	sigprocmask(SIG_SETMASK, &oset, NULL);
a90 1
	noreset++;
d114 2
a115 8
	if ((cp = value("escape")) != NULL)
		escape = *cp;
	else
		escape = ESCAPE;
	eofcount = 0;
	hadintr = 0;
	lastlong = 0;
	longline = 0;
d117 1
a117 9
	if (!sigsetjmp(colljmp, 1)) {
		if (getsub)
			gethfromtty(hp, GSUBJECT);
	} else {
		/*
		 * Come here for printing the after-signal message.
		 * Duplicate messages won't be printed because
		 * the write is aborted if we get a SIGTTOU.
		 */
d119 3
a121 1
		if (hadintr) {
a122 7
			fputs("\n(Interrupt -- one more to kill letter)\n",
			    stderr);
		} else {
			if (isatty(0)) {
				puts("(continue)");
				fflush(stdout);
			}
d126 25
a150 3
		colljmp_p = 1;
		c = readline(stdin, linebuf, LINESIZE);
		colljmp_p = 0;
d218 3
a220 2
			collint(SIGINT);
			exit(1);
d287 1
a287 1
			while ((rc = readline(fbuf, linebuf, LINESIZE)) >= 0) {
d372 8
a379 4
			if (value("askcc") != NULL)
				gethfromtty(hp, GCC);
			if (value("askbcc") != NULL)
				gethfromtty(hp, GBCC);
a394 10
	(void)sigemptyset(&nset);
	(void)sigaddset(&nset, SIGINT);
	(void)sigaddset(&nset, SIGHUP);
	(void)sigprocmask(SIG_BLOCK, &nset, &oset);
	(void)signal(SIGINT, saveint);
	(void)signal(SIGHUP, savehup);
	(void)signal(SIGTSTP, savetstp);
	(void)signal(SIGTTOU, savettou);
	(void)signal(SIGTTIN, savettin);
	(void)sigprocmask(SIG_SETMASK, &oset, NULL);
d454 3
a456 2
	sig_t sigint = signal(SIGINT, SIG_IGN);
	FILE *nf = run_editor(fp, (off_t)-1, c, 0);
d458 2
d465 2
a466 1
	(void)signal(SIGINT, sigint);
a481 1
	sig_t sigint = signal(SIGINT, SIG_IGN);
d483 2
d486 1
d517 2
a518 1
	(void)signal(SIGINT, sigint);
d574 2
a575 1
 * Print (continue) when continued after ^Z.
d577 2
a578 29
/*ARGSUSED*/
void
collstop(s)
	int s;
{
	sig_t old_action = signal(s, SIG_DFL);
	sigset_t nset;

	(void)sigemptyset(&nset);
	(void)sigaddset(&nset, s);
	(void)sigprocmask(SIG_UNBLOCK, &nset, NULL);
	(void)kill(0, s);
	(void)sigprocmask(SIG_BLOCK, &nset, NULL);
	(void)signal(s, old_action);
	if (colljmp_p) {
		colljmp_p = 0;
		hadintr = 0;
		siglongjmp(colljmp, 1);
	}
}

/*
 * On interrupt, come here to save the partial message in ~/dead.letter.
 * Then jump out of the collection loop.
 */
/*ARGSUSED*/
void
collint(s)
	int s;
d588 5
a592 1
			return;
d594 1
a594 2
		hadintr = 1;
		siglongjmp(colljmp, 1);
d596 1
d600 1
a600 15
	siglongjmp(collabort, 1);
}

/*ARGSUSED*/
void
collhup(s)
	int s;
{
	rewind(collf);
	savedeadletter(collf);
	/*
	 * Let's pretend nobody else wants to clean up,
	 * a true statement at this time.
	 */
	exit(1);
d625 1
a625 1
void
d630 5
a634 9
	if (grabh(hp, gflags) == SIGINT) {
		fflush(stdout);
		fputs("\n(Interrupt -- one more to kill letter)\n",
		    stderr);
		if (grabh(hp, gflags) == SIGINT) {
			hadintr++;
			collint(SIGINT);
			exit(1);
		}
d636 1
@


1.21.2.1
log
@Errata #23:
mail(1) will process tilde escapes even in non-interactive
mode. This can lead to a local root compromise.
Don't do tilde escapes unless we are in interactive mode.  Now the
behavior matches the man page...
@
text
@d1 1
a1 1
/*	$OpenBSD: collect.c,v 1.21 2001/06/23 23:04:21 millert Exp $	*/
d41 1
a41 1
static char rcsid[] = "$OpenBSD: collect.c,v 1.21 2001/06/23 23:04:21 millert Exp $";
d188 1
a188 2
		if (linebuf[0] != escape || value("interactive") == NULL ||
		    lastlong) {
@


1.20
log
@Changes from Don Beusee:
o escape From line with a leading '>' when needed
o only print To: address and Subject lines if actually present
o new variable 'allnet' to treat user@@foo and user@@bar as the same "user"
o folders command now takes an optional argument like ls.
o new "pipe" (|) command to pipe the message through an arbitrary command
o make header display format the same as SunOS 4.1.3 /usr/ucb/mail
o tilde commands work regardless of interactive mode.
o fix "read: Interrupted system call" error by retrying if EINTR
o expanded help file
Changes by me:
o read the help file via the PAGER as it is now more than 24 lines long
@
text
@d1 1
a1 1
/*	$OpenBSD: collect.c,v 1.19 2000/06/30 16:00:17 millert Exp $	*/
d41 1
a41 1
static char rcsid[] = "$OpenBSD: collect.c,v 1.19 2000/06/30 16:00:17 millert Exp $";
d84 4
a87 2
	int lc, cc, escape, eofcount, fd, c, t;
	char linebuf[LINESIZE], tempname[PATHSIZE], *cp, getsub;
a88 9
	int longline, lastlong, rc;	/* Can deal with lines > LINESIZE */

#if __GNUC__
	/* Avoid siglongjmp clobbering */
	(void)&escape;
	(void)&eofcount;
	(void)&getsub;
	(void)&longline;
#endif
@


1.20.2.1
log
@Errata #23:
mail(1) will process tilde escapes even in non-interactive
mode. This can lead to a local root compromise.
Fix (millert):
Don't do tilde escapes unless we are in interactive mode.  Now the
behavior matches the man page...
@
text
@d1 1
a1 1
/*	$OpenBSD: collect.c,v 1.20 2001/01/16 05:36:08 millert Exp $	*/
d41 1
a41 1
static char rcsid[] = "$OpenBSD: collect.c,v 1.20 2001/01/16 05:36:08 millert Exp $";
d195 1
a195 2
		if (linebuf[0] != escape || value("interactive") == NULL ||
		    lastlong) {
@


1.19
log
@warnx?/errx? paranoia (use "%s" not a bare string unless it is a
constant).  These are not security holes but it is worth fixing
them anyway both for robustness and so folks looking for examples
in the tree are not misled into doing something potentially dangerous.
Furthermore, it is a bad idea to assume that pathnames will not
include '%' in them and that error routines don't return strings
with '%' in them (especially in light of the possibility of locales).
@
text
@d1 1
a1 1
/*	$OpenBSD: collect.c,v 1.18 2000/04/26 15:47:30 millert Exp $	*/
d41 1
a41 1
static char rcsid[] = "$OpenBSD: collect.c,v 1.18 2000/04/26 15:47:30 millert Exp $";
d195 1
a195 2
		if (linebuf[0] != escape || value("interactive") == NULL ||
		    lastlong) {
d526 1
a526 2
	if ((shell = value("SHELL")) == NULL)
		shell = _PATH_CSHELL;
@


1.18
log
@Change the name of mail's send() function to sendmessages() to
avoid shadowing the libc send(2); gadams@@avernus.com
@
text
@d1 1
a1 1
/*	$OpenBSD: collect.c,v 1.17 1998/06/12 18:07:54 millert Exp $	*/
d41 1
a41 1
static char rcsid[] = "$OpenBSD: collect.c,v 1.17 1998/06/12 18:07:54 millert Exp $";
d126 1
a126 1
		warn(tempname);
d308 1
a308 1
				warn(cp);
d468 1
a468 1
			warn(name);
d519 1
a519 1
		warn(tempname);
d593 1
a593 1
			warn(fn);
@


1.18.2.1
log
@Pull in patch from current (even more to come):
Fix (millert):
warnx?/errx? paranoia (use "%s" not a bare string unless it is a
constant).  These are not security holes but it is worth fixing
them anyway both for robustness and so folks looking for examples
in the tree are not misled into doing something potentially dangerous.
Furthermore, it is a bad idea to assume that pathnames will not
include '%' in them and that error routines don't return strings
with '%' in them (especially in light of the possibility of locales).
@
text
@d1 1
a1 1
/*	$OpenBSD: collect.c,v 1.19 2000/06/30 16:00:17 millert Exp $	*/
d41 1
a41 1
static char rcsid[] = "$OpenBSD: collect.c,v 1.19 2000/06/30 16:00:17 millert Exp $";
d126 1
a126 1
		warn("%s", tempname);
d308 1
a308 1
				warn("%s", cp);
d468 1
a468 1
			warn("%s", name);
d519 1
a519 1
		warn("%s", tempname);
d593 1
a593 1
			warn("%s", fn);
@


1.17
log
@back out some signal changes that can cause mail to hang when quitting due to SIGCHLD blockage
@
text
@d1 1
a1 1
/*	$OpenBSD: collect.c,v 1.16 1998/05/04 05:37:47 millert Exp $	*/
d41 1
a41 1
static char rcsid[] = "$OpenBSD: collect.c,v 1.16 1998/05/04 05:37:47 millert Exp $";
d592 1
a592 1
		if (send(mp, fp, ig, tabst) < 0) {
@


1.16
log
@Never remove a mail spool, as we may not have proper prics, just truncate.  Also block signals in a few critical areas
@
text
@d1 1
a1 1
/*	$OpenBSD: collect.c,v 1.15 1997/11/14 00:23:45 millert Exp $	*/
d41 1
a41 1
static char rcsid[] = "$OpenBSD: collect.c,v 1.15 1997/11/14 00:23:45 millert Exp $";
a633 2
	sigset_t set, oset;

a636 2
	(void)sigfillset(&set);
	(void)sigprocmask(SIG_BLOCK, &set, &oset);
a641 1
			(void)sigprocmask(SIG_SETMASK, &oset, NULL);
a644 1
		(void)sigprocmask(SIG_SETMASK, &oset, NULL);
a649 1
	(void)sigprocmask(SIG_SETMASK, &oset, NULL);
a657 4
	sigset_t set;

	(void)sigfillset(&set);
	(void)sigprocmask(SIG_BLOCK, &set, NULL);
@


1.15
log
@NetBSD changes (mostly comsmetic):
    replace panic() with calls to err()/errx()
    use S_IS* instead of doing by hand with S_IF*.
    Use TIMESPEC_TO_TIMEVAL() and gettimeofday instead of time(2)
    Use _POSIX_VDISABLE, not 0
    Kill register
@
text
@d1 1
a1 1
/*	$OpenBSD: collect.c,v 1.14 1997/07/30 07:19:30 millert Exp $	*/
d41 1
a41 1
static char rcsid[] = "$OpenBSD: collect.c,v 1.14 1997/07/30 07:19:30 millert Exp $";
d634 2
d639 2
d646 1
d650 1
d656 1
d665 4
@


1.14
log
@Make istrcpy() take a size (not length) field, now called istrncpy().
Change some strcpy() -> strncpy() out of paranoia.
@
text
@d1 1
a1 1
/*	$OpenBSD: collect.c,v 1.13 1997/07/30 06:32:39 millert Exp $	*/
d41 1
a41 1
static char rcsid[] = "$OpenBSD: collect.c,v 1.13 1997/07/30 06:32:39 millert Exp $";
d84 2
a85 4
	int lc, cc, escape, eofcount, fd;
	register int c, t;
	char linebuf[LINESIZE], tempname[PATHSIZE], *cp;
	char getsub;
d441 2
a442 2
	register FILE *of;
	register int c;
d450 1
a450 1
	if (stat(name, &junk) >= 0 && (junk.st_mode & S_IFMT) == S_IFREG) {
d564 1
a564 1
	register int *msgvec;
d669 1
a669 1
	register FILE *fp;
d671 2
a672 2
	register FILE *dbuf;
	register int c;
@


1.13
log
@Fix one possible oflow (not exploitable) and do a wee bit of KNF.
Much more remains to be done.
@
text
@d1 1
a1 1
/*	$OpenBSD: collect.c,v 1.12 1997/07/24 17:27:10 millert Exp $	*/
d41 1
a41 1
static char rcsid[] = "$OpenBSD: collect.c,v 1.12 1997/07/24 17:27:10 millert Exp $";
d285 2
a286 1
			strcpy(linebuf + 2, getdeadletter());
@


1.12
log
@tempnam(3) goes bye bye.
@
text
@d1 1
a1 1
/*	$OpenBSD: collect.c,v 1.11 1997/07/22 18:54:36 millert Exp $	*/
d41 1
a41 1
static char rcsid[] = "$OpenBSD: collect.c,v 1.11 1997/07/22 18:54:36 millert Exp $";
d109 1
a109 1
		signal(SIGINT, collint);
d111 1
a111 1
		signal(SIGHUP, collhup);
d420 10
a429 10
	sigemptyset(&nset);
	sigaddset(&nset, SIGINT);
	sigaddset(&nset, SIGHUP);
	sigprocmask(SIG_BLOCK, &nset, &oset);
	signal(SIGINT, saveint);
	signal(SIGHUP, savehup);
	signal(SIGTSTP, savetstp);
	signal(SIGTTOU, savettou);
	signal(SIGTTIN, savettin);
	sigprocmask(SIG_SETMASK, &oset, NULL);
d613 6
a618 6
	sigemptyset(&nset);
	sigaddset(&nset, s);
	sigprocmask(SIG_UNBLOCK, &nset, NULL);
	kill(0, s);
	sigprocmask(SIG_BLOCK, &nset, NULL);
	signal(s, old_action);
@


1.11
log
@grabh() now returns SIGINT if it was interrupted (previously always
    returned 0 and the return val was always ignored).
Add gethfromtty() to get a header (using grabh) from the tty and
    quit on two ^C's.
Use gethfromtty() when getting Subject, Cc, and Bcc headers so
    we can quit nicely.  Closes PR #291.
Don't use longs where it doesn't make sense.
@
text
@d1 1
a1 1
/*	$OpenBSD: collect.c,v 1.10 1997/07/22 18:26:24 millert Exp $	*/
d41 1
a41 1
static char rcsid[] = "$OpenBSD: collect.c,v 1.10 1997/07/22 18:26:24 millert Exp $";
d84 1
a84 1
	int lc, cc, escape, eofcount;
d86 1
a86 2
	char linebuf[LINESIZE], *cp;
	extern char *tempMail;
d116 1
a116 1
		rm(tempMail);
d124 5
a128 2
	if ((collf = Fopen(tempMail, "w+")) == NULL) {
		warn(tempMail);
d131 1
a131 1
	unlink(tempMail);
d355 1
a355 1
			if (forward(linebuf + 2, collf, c) < 0)
d512 1
d514 1
a514 2
	extern char *tempEdit;
	char *shell;
d516 5
a520 2
	if ((nf = Fopen(tempEdit, "w+")) == NULL) {
		warn(tempEdit);
d523 1
a523 1
	(void)unlink(tempEdit);
d559 1
a559 1
forward(ms, fp, f)
d562 1
a565 1
	extern char *tempMail;
d594 1
a594 1
			warn(tempMail);
@


1.10
log
@Only require 2 ^C's at Subject: prompt to quit as it is supposed to.
Also in Subject: prompt, when we get that first ^C re-prompt for
the Subject: like SunOS does so the user knows what is going on.
@
text
@d1 1
a1 1
/*	$OpenBSD: collect.c,v 1.9 1997/07/14 15:56:23 millert Exp $	*/
d41 1
a41 1
static char rcsid[] = "$OpenBSD: collect.c,v 1.9 1997/07/14 15:56:23 millert Exp $";
d155 2
a156 10
		if (getsub && grabh(hp, GSUBJECT) == SIGINT) {
			fflush(stdout);
			fputs("\n(Interrupt -- one more to kill letter)\n",
			    stderr);
			if (grabh(hp, GSUBJECT) == SIGINT) {
				hadintr++;
				collint(SIGINT);
				exit(1);
			}
		}
d396 12
d442 1
a442 2
	long cc;
	int lc;
d473 1
a473 1
	printf("%d/%ld\n", lc, cc);
d683 17
@


1.9
log
@Convert remaining sigsetmask() -> sigprocmask() (POSIX style)
in collect.c and fix up some signal botches elsewhere.
@
text
@d1 1
a1 1
/*	$OpenBSD: collect.c,v 1.8 1997/07/14 00:24:25 millert Exp $	*/
d41 1
a41 1
static char rcsid[] = "$OpenBSD: collect.c,v 1.8 1997/07/14 00:24:25 millert Exp $";
d155 10
a164 2
		if (getsub)
			grabh(hp, GSUBJECT);
@


1.8
log
@NOSTR -> NULL
Use sigsetjmp/siglongjmp instead of sigjmp/longjmp for portability.
@
text
@d1 1
a1 1
/*	$OpenBSD: collect.c,v 1.7 1997/07/13 23:53:58 millert Exp $	*/
d41 1
a41 1
static char rcsid[] = "$OpenBSD: collect.c,v 1.7 1997/07/13 23:53:58 millert Exp $";
d89 1
a89 1
	int omask;
d105 4
a108 1
	omask = sigblock(sigmask(SIGINT) | sigmask(SIGHUP));
d120 3
a122 1
	sigsetmask(omask & ~(sigmask(SIGINT) | sigmask(SIGHUP)));
d406 4
a409 1
	sigblock(sigmask(SIGINT) | sigmask(SIGHUP));
d415 1
a415 1
	sigsetmask(omask);
@


1.7
log
@bcopy() -> memcpy() and fix some casts.
@
text
@d1 1
a1 1
/*	$OpenBSD: collect.c,v 1.6 1997/07/13 21:21:10 millert Exp $	*/
d41 1
a41 1
static char rcsid[] = "$OpenBSD: collect.c,v 1.6 1997/07/13 21:21:10 millert Exp $";
d74 3
a76 3
static	jmp_buf	colljmp;		/* To get back to work */
static	int	colljmp_p;		/* whether to long jump */
static	jmp_buf	collabort;		/* To end collection with error */
d93 1
a93 1
	/* Avoid longjmp clobbering */
d113 1
a113 1
	if (setjmp(collabort) || setjmp(colljmp)) {
d133 2
a134 2
	if (hp->h_subject == NOSTR && value("interactive") != NOSTR &&
	    (value("ask") != NOSTR || value("asksub") != NOSTR))
d140 1
a140 1
	if ((cp = value("escape")) != NOSTR)
d149 1
a149 1
	if (!setjmp(colljmp)) {
d175 2
a176 2
			if (value("interactive") != NOSTR &&
			    value("ignoreeof") != NOSTR && ++eofcount < 25) {
d187 2
a188 2
		    value("interactive") != NOSTR && !lastlong &&
		    (value("dot") != NOSTR || value("ignoreeof") != NOSTR))
d190 1
a190 1
		if (linebuf[0] != escape || value("interactive") == NOSTR ||
d295 1
a295 1
			if (cp == NOSTR)
d333 1
a333 1
			if ((cp = expand(cp)) == NOSTR)
d437 1
a437 1
		warn(NOSTR);
d504 1
a504 1
	if ((shell = value("SHELL")) == NOSTR)
d507 1
a507 1
	    0, fileno(fp), fileno(nf), "-c", cmd, NOSTR) < 0) {
d546 1
a546 1
	if (msgvec == (int *)NOSTR)
d559 2
a560 2
		tabst = NOSTR;
	else if ((tabst = value("indentprefix")) == NOSTR)
d598 1
a598 1
		longjmp(colljmp, 1);
d615 1
a615 1
		if (value("ignore") != NOSTR) {
d622 1
a622 1
		longjmp(colljmp, 1);
d625 1
a625 1
	if (value("nosave") == NOSTR)
d627 1
a627 1
	longjmp(collabort, 1);
@


1.6
log
@Merge in NetBSD and 4.4BSD-lite2 changes as well as some of my own.
 - handle long lines safely (from NetBSD)
 - use puts/fputs and putchar/putc when it makes sense
 - use err/errx and warn/warnx when it makes sense
 - make return() and sizeof() style consisten
 - some more buffer safety
@
text
@d1 1
a1 1
/*	$OpenBSD: collect.c,v 1.5 1997/04/13 20:32:06 deraadt Exp $	*/
d41 1
a41 1
static char rcsid[] = "$OpenBSD: collect.c,v 1.5 1997/04/13 20:32:06 deraadt Exp $";
d94 4
a97 4
	(void) &escape;
	(void) &eofcount;
	(void) &getsub;
	(void) &longline;
d357 1
a357 1
				(void) putchar(t);
d369 1
a369 1
				(void) putchar(t);
d446 1
a446 1
		(void) putc(c, of);
d476 1
a476 1
	(void) signal(SIGINT, sigint);
d499 1
a499 1
	(void) unlink(tempEdit);
d519 1
a519 1
	(void) fseek(nf, 0L, 2);
d523 1
a523 1
	(void) signal(SIGINT, sigint);
d545 2
a546 2
	msgvec = (int *) salloc((msgCount+1) * sizeof(*msgvec));
	if (msgvec == (int *) NOSTR)
d657 1
a657 1
	(void) umask(c);
d661 1
a661 1
		(void) putc(c, dbuf);
@


1.5
log
@single ^C on a pipe
@
text
@d1 2
a2 2
/*	$OpenBSD: collect.c,v 1.4 1997/04/13 20:22:39 deraadt Exp $	*/
/*	$NetBSD: collect.c,v 1.6 1996/06/08 19:48:16 christos Exp $	*/
d41 1
a41 1
static char rcsid[] = "$OpenBSD: collect.c,v 1.4 1997/04/13 20:22:39 deraadt Exp $";
d90 2
d97 1
d121 1
a121 1
		perror(tempMail);
d146 2
d161 2
a162 2
			fprintf(stderr,
			    "\n(Interrupt -- one more to kill letter)\n");
d165 1
a165 1
				printf("(continue)\n");
d177 1
a177 1
				printf("Use \".\" to terminate letter\n");
d182 2
d187 1
a187 1
		    value("interactive") != NOSTR &&
d190 3
a192 2
		if (linebuf[0] != escape || value("interactive") == NOSTR) {
			if (putline(collf, linebuf) < 0)
d204 1
a204 1
				if (putline(collf, &linebuf[1]) < 0)
d209 1
a209 1
			printf("Unknown tilde escape.\n");
d291 1
a291 1
				printf("Interpolate what file?\n");
d302 1
a302 1
				perror(cp);
d309 6
a314 4
			while (readline(fbuf, linebuf, LINESIZE) >= 0) {
				lc++;
				if ((t = putline(collf, linebuf)) < 0) {
					Fclose(fbuf);
d319 1
a319 1
			Fclose(fbuf);
d330 1
a330 1
				fprintf(stderr, "Write what file!?\n");
d353 1
a353 1
				perror(_PATH_TILDE);
d358 1
a358 1
			Fclose(fbuf);
d366 1
a366 1
			printf("-------\nMessage contains:\n");
d394 1
a394 1
		Fclose(collf);
d408 1
a408 1
	return collf;
d433 1
a433 1
		fprintf(stderr, "File exists\n");
d437 1
a437 1
		perror(NOSTR);
d448 2
a449 2
			perror(name);
			Fclose(of);
d453 1
a453 1
	Fclose(of);
d474 1
a474 1
		Fclose(fp);
d496 1
a496 1
		perror(tempEdit);
d508 1
a508 1
		(void) Fclose(nf);
d513 1
a513 1
		(void) Fclose(nf);
d521 1
a521 1
	(void) Fclose(fp);
d545 1
a545 1
	msgvec = (int *) salloc((msgCount+1) * sizeof *msgvec);
d553 1
a553 1
			printf("No appropriate messages\n");
d563 1
a563 1
	printf("Interpolating:");
d570 1
a570 1
			perror(tempMail);
d574 1
a574 1
	printf("\n");
d662 1
a662 1
	Fclose(dbuf);
@


1.4
log
@do not (continue) on a stdin pipe
@
text
@d1 1
a1 1
/*	$OpenBSD: collect.c,v 1.3 1997/04/10 15:33:50 deraadt Exp $	*/
d41 1
a41 1
static char rcsid[] = "$OpenBSD: collect.c,v 1.3 1997/04/10 15:33:50 deraadt Exp $";
d157 1
a157 1
			"\n(Interrupt -- one more to kill letter)\n");
d604 1
a604 1
	if (!hadintr) {
@


1.3
log
@how is this for fast bug fixing response! revert to sigblock() since the
sigprocmask() code was not equivelant. report from grr@@shandakor.tharsis.com,
PR#154
@
text
@d1 1
a1 1
/*	$OpenBSD: collect.c,v 1.2 1996/06/11 12:53:35 deraadt Exp $	*/
d41 1
a41 1
static char rcsid[] = "$OpenBSD: collect.c,v 1.2 1996/06/11 12:53:35 deraadt Exp $";
d159 4
a162 2
			printf("(continue)\n");
			fflush(stdout);
@


1.2
log
@from christos;
- Fix PR/105: Implement dot locking protocol and check return value of flock.
- Fix PR/2247: Don't call unknown users "ubluit". Issue an error message.
- Fix/add prototypes.
- Fix warnings.
- Use POSIX signal mask calls.
@
text
@d1 1
a1 1
/*	$OpenBSD: collect.c,v 1.6 1996/06/08 19:48:16 christos Exp $	*/
d41 1
a41 1
static char rcsid[] = "$OpenBSD: collect.c,v 1.6 1996/06/08 19:48:16 christos Exp $";
d89 1
a89 1
	sigset_t oset, nset;
d102 1
a102 4
	sigemptyset(&nset);
	sigaddset(&nset, SIGINT);
	sigaddset(&nset, SIGHUP);
	sigprocmask(SIG_BLOCK, &nset, &oset);
d114 1
a114 1
	sigprocmask(SIG_SETMASK, &oset, NULL);
d389 1
a389 4
	sigemptyset(&nset);
	sigaddset(&nset, SIGINT);
	sigaddset(&nset, SIGHUP);
	sigprocmask(SIG_BLOCK, &nset, &oset);
d395 1
a395 1
	sigprocmask(SIG_SETMASK, &oset, NULL);
@


1.1
log
@Initial revision
@
text
@d1 3
d38 5
a42 2
static char sccsid[] = "from: @@(#)collect.c	8.2 (Berkeley) 4/19/94";
static char rcsid[] = "$Id: collect.c,v 1.5 1995/02/08 16:15:52 jtc Exp $";
d89 7
a95 2
	int omask;
	void collint(), collhup(), collstop();
d102 4
a105 1
	omask = sigblock(sigmask(SIGINT) | sigmask(SIGHUP));
d117 1
a117 1
	sigsetmask(omask & ~(sigmask(SIGINT) | sigmask(SIGHUP)));
d208 1
a208 1
			core();
d392 4
a395 1
	sigblock(sigmask(SIGINT) | sigmask(SIGHUP));
d401 1
a401 1
	sigsetmask(omask);
d581 1
d583 3
a585 1
	sigsetmask(sigblock(0) & ~sigmask(s));
d587 1
a587 1
	sigblock(sigmask(s));
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@
