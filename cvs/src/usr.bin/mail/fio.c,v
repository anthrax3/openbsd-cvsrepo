head	1.36;
access;
symbols
	OPENBSD_6_1:1.36.0.6
	OPENBSD_6_1_BASE:1.36
	OPENBSD_6_0:1.36.0.4
	OPENBSD_6_0_BASE:1.36
	OPENBSD_5_9:1.36.0.2
	OPENBSD_5_9_BASE:1.36
	OPENBSD_5_8:1.34.0.6
	OPENBSD_5_8_BASE:1.34
	OPENBSD_5_7:1.34.0.2
	OPENBSD_5_7_BASE:1.34
	OPENBSD_5_6:1.33.0.6
	OPENBSD_5_6_BASE:1.33
	OPENBSD_5_5:1.33.0.4
	OPENBSD_5_5_BASE:1.33
	OPENBSD_5_4:1.32.0.16
	OPENBSD_5_4_BASE:1.32
	OPENBSD_5_3:1.32.0.14
	OPENBSD_5_3_BASE:1.32
	OPENBSD_5_2:1.32.0.12
	OPENBSD_5_2_BASE:1.32
	OPENBSD_5_1_BASE:1.32
	OPENBSD_5_1:1.32.0.10
	OPENBSD_5_0:1.32.0.8
	OPENBSD_5_0_BASE:1.32
	OPENBSD_4_9:1.32.0.6
	OPENBSD_4_9_BASE:1.32
	OPENBSD_4_8:1.32.0.4
	OPENBSD_4_8_BASE:1.32
	OPENBSD_4_7:1.32.0.2
	OPENBSD_4_7_BASE:1.32
	OPENBSD_4_6:1.31.0.8
	OPENBSD_4_6_BASE:1.31
	OPENBSD_4_5:1.31.0.4
	OPENBSD_4_5_BASE:1.31
	OPENBSD_4_4:1.31.0.2
	OPENBSD_4_4_BASE:1.31
	OPENBSD_4_3:1.30.0.2
	OPENBSD_4_3_BASE:1.30
	OPENBSD_4_2:1.28.0.2
	OPENBSD_4_2_BASE:1.28
	OPENBSD_4_1:1.27.0.2
	OPENBSD_4_1_BASE:1.27
	OPENBSD_4_0:1.26.0.2
	OPENBSD_4_0_BASE:1.26
	OPENBSD_3_9:1.25.0.8
	OPENBSD_3_9_BASE:1.25
	OPENBSD_3_8:1.25.0.6
	OPENBSD_3_8_BASE:1.25
	OPENBSD_3_7:1.25.0.4
	OPENBSD_3_7_BASE:1.25
	OPENBSD_3_6:1.25.0.2
	OPENBSD_3_6_BASE:1.25
	OPENBSD_3_5:1.24.0.4
	OPENBSD_3_5_BASE:1.24
	OPENBSD_3_4:1.24.0.2
	OPENBSD_3_4_BASE:1.24
	OPENBSD_3_3:1.22.0.6
	OPENBSD_3_3_BASE:1.22
	OPENBSD_3_2:1.22.0.4
	OPENBSD_3_2_BASE:1.22
	OPENBSD_3_1:1.22.0.2
	OPENBSD_3_1_BASE:1.22
	OPENBSD_3_0:1.18.0.4
	OPENBSD_3_0_BASE:1.18
	OPENBSD_2_9_BASE:1.18
	OPENBSD_2_9:1.18.0.2
	OPENBSD_2_8:1.17.0.2
	OPENBSD_2_8_BASE:1.17
	OPENBSD_2_7:1.16.0.8
	OPENBSD_2_7_BASE:1.16
	OPENBSD_2_6:1.16.0.6
	OPENBSD_2_6_BASE:1.16
	OPENBSD_2_5:1.16.0.4
	OPENBSD_2_5_BASE:1.16
	OPENBSD_2_4:1.16.0.2
	OPENBSD_2_4_BASE:1.16
	OPENBSD_2_3:1.14.0.2
	OPENBSD_2_3_BASE:1.14
	OPENBSD_2_2:1.13.0.2
	OPENBSD_2_2_BASE:1.13
	OPENBSD_2_1:1.4.0.2
	OPENBSD_2_1_BASE:1.4
	OPENBSD_2_0:1.2.0.2
	OPENBSD_2_0_BASE:1.2
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.36
date	2015.10.16.18.21.43;	author mmcc;	state Exp;
branches;
next	1.35;
commitid	Td7tacw7HKigE3xK;

1.35
date	2015.10.16.17.56.07;	author mmcc;	state Exp;
branches;
next	1.34;
commitid	y3aqfd1wS5RZj9kl;

1.34
date	2014.12.16.18.31.06;	author millert;	state Exp;
branches;
next	1.33;
commitid	Phm8vWT4LhRkP3MY;

1.33
date	2014.01.17.18.42.30;	author okan;	state Exp;
branches;
next	1.32;

1.32
date	2009.10.27.23.59.40;	author deraadt;	state Exp;
branches;
next	1.31;

1.31
date	2008.07.16.14.49.09;	author martynas;	state Exp;
branches;
next	1.30;

1.30
date	2007.10.05.14.39.39;	author chl;	state Exp;
branches;
next	1.29;

1.29
date	2007.09.10.14.29.53;	author tobias;	state Exp;
branches;
next	1.28;

1.28
date	2007.05.25.21.27.16;	author krw;	state Exp;
branches;
next	1.27;

1.27
date	2006.11.16.00.16.29;	author ray;	state Exp;
branches;
next	1.26;

1.26
date	2006.04.02.00.51.37;	author deraadt;	state Exp;
branches;
next	1.25;

1.25
date	2004.05.10.15.25.51;	author deraadt;	state Exp;
branches;
next	1.24;

1.24
date	2003.07.07.21.36.51;	author deraadt;	state Exp;
branches;
next	1.23;

1.23
date	2003.06.03.02.56.11;	author millert;	state Exp;
branches;
next	1.22;

1.22
date	2002.03.14.06.51.42;	author mpech;	state Exp;
branches;
next	1.21;

1.21
date	2001.12.18.16.55.06;	author millert;	state Exp;
branches;
next	1.20;

1.20
date	2001.11.21.15.26.39;	author millert;	state Exp;
branches;
next	1.19;

1.19
date	2001.11.20.20.50.00;	author millert;	state Exp;
branches;
next	1.18;

1.18
date	2001.01.16.05.36.08;	author millert;	state Exp;
branches;
next	1.17;

1.17
date	2000.08.02.04.10.48;	author millert;	state Exp;
branches;
next	1.16;

1.16
date	98.06.12.17.51.51;	author millert;	state Exp;
branches;
next	1.15;

1.15
date	98.06.11.06.20.18;	author deraadt;	state Exp;
branches;
next	1.14;

1.14
date	97.11.14.00.23.47;	author millert;	state Exp;
branches;
next	1.13;

1.13
date	97.09.04.20.44.04;	author millert;	state Exp;
branches;
next	1.12;

1.12
date	97.08.31.14.32.13;	author millert;	state Exp;
branches;
next	1.11;

1.11
date	97.07.28.15.20.30;	author millert;	state Exp;
branches;
next	1.10;

1.10
date	97.07.24.17.27.11;	author millert;	state Exp;
branches;
next	1.9;

1.9
date	97.07.24.16.23.37;	author millert;	state Exp;
branches;
next	1.8;

1.8
date	97.07.14.00.24.26;	author millert;	state Exp;
branches;
next	1.7;

1.7
date	97.07.13.23.53.59;	author millert;	state Exp;
branches;
next	1.6;

1.6
date	97.07.13.21.21.12;	author millert;	state Exp;
branches;
next	1.5;

1.5
date	97.05.30.08.51.39;	author deraadt;	state Exp;
branches;
next	1.4;

1.4
date	97.03.29.03.01.46;	author millert;	state Exp;
branches;
next	1.3;

1.3
date	97.01.17.07.12.46;	author millert;	state Exp;
branches;
next	1.2;

1.2
date	96.06.11.12.53.39;	author deraadt;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.45.38;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.45.38;	author deraadt;	state Exp;
branches;
next	;


desc
@@


1.36
log
@Cast isspace() argument to unsigned char.

ok jca@@
@
text
@/*	$OpenBSD: fio.c,v 1.35 2015/10/16 17:56:07 mmcc Exp $	*/
/*	$NetBSD: fio.c,v 1.8 1997/07/07 22:57:55 phil Exp $	*/

/*
 * Copyright (c) 1980, 1993
 *	The Regents of the University of California.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */

#include "rcv.h"
#include <sys/file.h>
#include <sys/wait.h>

#include <unistd.h>
#include <paths.h>
#include <errno.h>
#include <glob.h>
#include "extern.h"

/*
 * Mail -- a mail program
 *
 * File I/O.
 */

static volatile sig_atomic_t fiosignal;

/*
 * Wrapper for read() to catch EINTR.
 */
static ssize_t
myread(int fd, char *buf, int len)
{
	ssize_t nread;

	while ((nread = read(fd, buf, len)) == -1 && errno == EINTR)
		;
	return(nread);
}

/*
 * Set up the input pointers while copying the mail file into /tmp.
 */
void
setptr(FILE *ibuf, off_t offset)
{
	int c, count;
	char *cp, *cp2;
	struct message this;
	FILE *mestmp;
	int maybe, inhead, omsgCount;
	char linebuf[LINESIZE], pathbuf[PATHSIZE];

	/* Get temporary file. */
	(void)snprintf(pathbuf, sizeof(pathbuf), "%s/mail.XXXXXXXXXX", tmpdir);
	if ((c = mkstemp(pathbuf)) == -1 || (mestmp = Fdopen(c, "r+")) == NULL)
		err(1, "can't open %s", pathbuf);
	(void)rm(pathbuf);

	if (offset == 0) {
		msgCount = 0;
	} else {
		/* Seek into the file to get to the new messages */
		(void)fseeko(ibuf, offset, SEEK_SET);
		/*
		 * We need to make "offset" a pointer to the end of
		 * the temp file that has the copy of the mail file.
		 * If any messages have been edited, this will be
		 * different from the offset into the mail file.
		 */
		(void)fseeko(otf, (off_t)0, SEEK_END);
		offset = ftell(otf);
	}
	omsgCount = msgCount;
	maybe = 1;
	inhead = 0;
	this.m_flag = MUSED|MNEW;
	this.m_size = 0;
	this.m_lines = 0;
	this.m_block = 0;
	this.m_offset = 0;
	for (;;) {
		if (fgets(linebuf, sizeof(linebuf), ibuf) == NULL) {
			if (append(&this, mestmp))
				err(1, "temporary file");
			makemessage(mestmp, omsgCount);
			return;
		}
		count = strlen(linebuf);
		/*
		 * Transforms lines ending in <CR><LF> to just <LF>.
		 * This allows mail to be able to read Eudora mailboxes
		 * that reside on a DOS partition.
		 */
		if (count >= 2 && linebuf[count-1] == '\n' &&
		    linebuf[count - 2] == '\r') {
			linebuf[count - 2] = '\n';
			linebuf[count - 1] = '\0';
			count--;
		}

		(void)fwrite(linebuf, sizeof(*linebuf), count, otf);
		if (ferror(otf))
			err(1, "%s", pathbuf);
		if (count && linebuf[count - 1] == '\n')
			linebuf[count - 1] = '\0';
		if (maybe && linebuf[0] == 'F' && ishead(linebuf)) {
			msgCount++;
			if (append(&this, mestmp))
				err(1, "temporary file");
			this.m_flag = MUSED|MNEW;
			this.m_size = 0;
			this.m_lines = 0;
			this.m_block = blockof(offset);
			this.m_offset = offsetof(offset);
			inhead = 1;
		} else if (linebuf[0] == 0) {
			inhead = 0;
		} else if (inhead) {
			for (cp = linebuf, cp2 = "status";; cp++) {
				if ((c = (unsigned char)*cp2++) == 0) {
					while (isspace((unsigned char)*cp++))
						;
					if (cp[-1] != ':')
						break;
					while ((c = (unsigned char)*cp++) != '\0')
						if (c == 'R')
							this.m_flag |= MREAD;
						else if (c == 'O')
							this.m_flag &= ~MNEW;
					inhead = 0;
					break;
				}
				if (*cp != c && *cp != toupper(c))
					break;
			}
		}
		offset += count;
		this.m_size += count;
		this.m_lines++;
		maybe = linebuf[0] == 0;
	}
}

/*
 * Drop the passed line onto the passed output buffer.
 * If a write error occurs, return -1, else the count of
 * characters written, including the newline if requested.
 */
int
putline(FILE *obuf, char *linebuf, int outlf)
{
	int c;

	c = strlen(linebuf);
	(void)fwrite(linebuf, sizeof(*linebuf), c, obuf);
	if (outlf) {
		(void)putc('\n', obuf);
		c++;
	}
	if (ferror(obuf))
		return(-1);
	return(c);
}

/*
 * Read up a line from the specified input into the line
 * buffer.  Return the number of characters read.  Do not
 * include the newline (or carriage return) at the end.
 */
int
readline(FILE *ibuf, char *linebuf, int linesize, int *signo)
{
	struct sigaction act;
	struct sigaction savetstp;
	struct sigaction savettou;
	struct sigaction savettin;
	struct sigaction saveint;
	struct sigaction savehup;
	sigset_t oset;
	int n;

	/*
	 * Setup signal handlers if the caller asked us to catch signals.
	 * Note that we do not restart system calls since we need the
	 * read to be interruptible.
	 */
	if (signo) {
		fiosignal = 0;
		sigemptyset(&act.sa_mask);
		act.sa_flags = 0;
		act.sa_handler = fioint;
		if (sigaction(SIGINT, NULL, &saveint) == 0 &&
		    saveint.sa_handler != SIG_IGN) {
			(void)sigaction(SIGINT, &act, &saveint);
			(void)sigprocmask(SIG_UNBLOCK, &intset, &oset);
		}
		if (sigaction(SIGHUP, NULL, &savehup) == 0 &&
		    savehup.sa_handler != SIG_IGN)
			(void)sigaction(SIGHUP, &act, &savehup);
		(void)sigaction(SIGTSTP, &act, &savetstp);
		(void)sigaction(SIGTTOU, &act, &savettou);
		(void)sigaction(SIGTTIN, &act, &savettin);
	}

	clearerr(ibuf);
	if (fgets(linebuf, linesize, ibuf) == NULL) {
		if (ferror(ibuf))
			clearerr(ibuf);
		n = -1;
	} else {
		n = strlen(linebuf);
		if (n > 0 && linebuf[n - 1] == '\n')
			linebuf[--n] = '\0';
		if (n > 0 && linebuf[n - 1] == '\r')
			linebuf[--n] = '\0';
	}

	if (signo) {
		(void)sigprocmask(SIG_SETMASK, &oset, NULL);
		(void)sigaction(SIGINT, &saveint, NULL);
		(void)sigaction(SIGHUP, &savehup, NULL);
		(void)sigaction(SIGTSTP, &savetstp, NULL);
		(void)sigaction(SIGTTOU, &savettou, NULL);
		(void)sigaction(SIGTTIN, &savettin, NULL);
		*signo = fiosignal;
	}

	return(n);
}

/*
 * Return a file buffer all ready to read up the
 * passed message pointer.
 */
FILE *
setinput(struct message *mp)
{

	fflush(otf);
	if (fseek(itf, (long)positionof(mp->m_block, mp->m_offset), SEEK_SET)
	    < 0)
		err(1, "fseek");
	return(itf);
}

/*
 * Take the data out of the passed ghost file and toss it into
 * a dynamically allocated message structure.
 */
void
makemessage(FILE *f, int omsgCount)
{
	size_t size;
	struct message *nmessage;

	size = (msgCount + 1) * sizeof(struct message);
	nmessage = realloc(message, size);
	if (nmessage == 0)
		err(1, "realloc");
	if (omsgCount == 0 || message == NULL)
		dot = nmessage;
	else
		dot = nmessage + (dot - message);
	message = nmessage;
	size -= (omsgCount + 1) * sizeof(struct message);
	fflush(f);
	(void)lseek(fileno(f), (off_t)sizeof(*message), SEEK_SET);
	if (myread(fileno(f), (void *) &message[omsgCount], size) != size)
		errx(1, "Message temporary file corrupted");
	message[msgCount].m_size = 0;
	message[msgCount].m_lines = 0;
	(void)Fclose(f);
}

/*
 * Append the passed message descriptor onto the temp file.
 * If the write fails, return 1, else 0
 */
int
append(struct message *mp, FILE *f)
{

	return(fwrite((char *) mp, sizeof(*mp), 1, f) != 1);
}

/*
 * Delete or truncate a file, but only if the file is a plain file.
 */
int
rm(char *name)
{
	struct stat sb;

	if (stat(name, &sb) < 0)
		return(-1);
	if (!S_ISREG(sb.st_mode)) {
		errno = EISDIR;
		return(-1);
	}
	if (unlink(name) == -1) {
		if (errno == EPERM)
			return(truncate(name, (off_t)0));
		else
			return(-1);
	}
	return(0);
}

static int sigdepth;		/* depth of holdsigs() */
static sigset_t nset, oset;
/*
 * Hold signals SIGHUP, SIGINT, and SIGQUIT.
 */
void
holdsigs(void)
{

	if (sigdepth++ == 0) {
		sigemptyset(&nset);
		sigaddset(&nset, SIGHUP);
		sigaddset(&nset, SIGINT);
		sigaddset(&nset, SIGQUIT);
		sigprocmask(SIG_BLOCK, &nset, &oset);
	}
}

/*
 * Release signals SIGHUP, SIGINT, and SIGQUIT.
 */
void
relsesigs(void)
{

	if (--sigdepth == 0)
		sigprocmask(SIG_SETMASK, &oset, NULL);
}

/*
 * Unblock and ignore a signal
 */
int
ignoresig(int sig, struct sigaction *oact, sigset_t *oset)
{
	struct sigaction act;
	sigset_t nset;
	int error;

	sigemptyset(&act.sa_mask);
	act.sa_flags = SA_RESTART;
	act.sa_handler = SIG_IGN;
	error = sigaction(sig, &act, oact);

	if (error == 0) {
		sigemptyset(&nset);
		sigaddset(&nset, sig);
		(void)sigprocmask(SIG_UNBLOCK, &nset, oset);
	} else if (oset != NULL)
		(void)sigprocmask(SIG_BLOCK, NULL, oset);

	return(error);
}

/*
 * Determine the size of the file possessed by
 * the passed buffer.
 */
off_t
fsize(FILE *iob)
{
	struct stat sbuf;

	if (fstat(fileno(iob), &sbuf) < 0)
		return(0);
	return(sbuf.st_size);
}

/*
 * Evaluate the string given as a new mailbox name.
 * Supported meta characters:
 *	%	for my system mail box
 *	%user	for user's system mail box
 *	#	for previous file
 *	&	invoker's mbox file
 *	+file	file in folder directory
 *	any shell meta character
 * Return the file name as a dynamic string.
 */
char *
expand(char *name)
{
	const int flags = GLOB_BRACE|GLOB_TILDE|GLOB_NOSORT;
	char xname[PATHSIZE];
	char cmdbuf[PATHSIZE];		/* also used for file names */
	char *match = NULL;
	glob_t names;

	/*
	 * The order of evaluation is "%" and "#" expand into constants.
	 * "&" can expand into "+".  "+" can expand into shell meta characters.
	 * Shell meta characters expand into constants.
	 * This way, we make no recursive expansion.
	 */
	switch (*name) {
	case '%':
		findmail(name[1] ? name + 1 : myname, xname, sizeof(xname));
		return(savestr(xname));
	case '#':
		if (name[1] != 0)
			break;
		if (prevfile[0] == 0) {
			puts("No previous file");
			return(NULL);
		}
		return(savestr(prevfile));
	case '&':
		if (name[1] == 0 && (name = value("MBOX")) == NULL)
			name = "~/mbox";
		/* fall through */
	}
	if (name[0] == '+' && getfold(cmdbuf, sizeof(cmdbuf)) >= 0) {
		(void)snprintf(xname, sizeof(xname), "%s/%s", cmdbuf, name + 1);
		name = savestr(xname);
	}
	/* catch the most common shell meta character */
	if (name[0] == '~' && homedir && (name[1] == '/' || name[1] == '\0')) {
		(void)snprintf(xname, sizeof(xname), "%s%s", homedir, name + 1);
		name = savestr(xname);
	}
	if (strpbrk(name, "~{[*?\\") == NULL)
		return(savestr(name));

	/* XXX - does not expand enviroment variables. */
	switch (glob(name, flags, NULL, &names)) {
	case 0:
		if (names.gl_pathc == 1)
			match = savestr(names.gl_pathv[0]);
		else
			fprintf(stderr, "\"%s\": Ambiguous.\n", name);
		break;
	case GLOB_NOSPACE:
		fprintf(stderr, "\"%s\": Out of memory.\n", name);
		break;
	case GLOB_NOMATCH:
		fprintf(stderr, "\"%s\": No match.\n", name);
		break;
	default:
		fprintf(stderr, "\"%s\": Expansion failed.\n", name);
		break;
	}
	globfree(&names);
	return(match);
}

/*
 * Determine the current folder directory name.
 */
int
getfold(char *name, int namelen)
{
	char *folder;

	if ((folder = value("folder")) == NULL)
		return(-1);
	if (*folder == '/')
		strlcpy(name, folder, namelen);
	else
		(void)snprintf(name, namelen, "%s/%s", homedir ? homedir : ".",
		    folder);
	return(0);
}

/*
 * Return the name of the dead.letter file.
 */
char *
getdeadletter(void)
{
	char *cp;

	if ((cp = value("DEAD")) == NULL || (cp = expand(cp)) == NULL)
		cp = expand("~/dead.letter");
	else if (*cp != '/') {
		char buf[PATHSIZE];

		(void)snprintf(buf, sizeof(buf), "~/%s", cp);
		cp = expand(buf);
	}
	return(cp);
}

/*
 * Signal handler used by readline() to catch SIGINT, SIGHUP, SIGTSTP,
 * SIGTTOU, SIGTTIN.
 */
void
fioint(int s)
{

	fiosignal = s;
}
@


1.35
log
@Modernize allocation by:

 * removing unneeded casts of void* return values
 * replacing varied and creative error messages with the allocation
   function's name
 * replacing errx() with err() so that the errno string is reported

ok beck@@, jung@@, millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: fio.c,v 1.34 2014/12/16 18:31:06 millert Exp $	*/
d145 1
a145 1
					while (isspace(*cp++))
@


1.34
log
@Use glob() to expand filenames instead of passing it to the shell's
echo command for expansion which could result in arbitrary command
execution.  CVE-2004-2771
@
text
@d1 1
a1 1
/*	$OpenBSD: fio.c,v 1.33 2014/01/17 18:42:30 okan Exp $	*/
d281 1
a281 1
	nmessage = (struct message *)realloc(message, size);
d283 1
a283 2
		errx(1, "Insufficient memory for %d messages",
		    msgCount);
@


1.33
log
@ctype and other sign extension fixes.

with deraadt and millert, ok millert
@
text
@d1 1
a1 1
/*	$OpenBSD: fio.c,v 1.32 2009/10/27 23:59:40 deraadt Exp $	*/
d40 1
d416 1
d419 2
a420 6
	pid_t pid;
	int l;
	char *cp, *shell;
	int pivec[2];
	struct stat sbuf;
	extern int wait_status;
d454 18
a471 22
	if (strpbrk(name, "~{[*?$`'\"\\") == NULL)
		return(name);
	/* XXX - just use glob(3) and env expansion instead? */
	if (pipe(pivec) < 0) {
		warn("pipe");
		return(name);
	}
	(void)snprintf(cmdbuf, sizeof(cmdbuf), "echo %s", name);
	shell = value("SHELL");
	pid = start_command(shell, 0, -1, pivec[1], "-c", cmdbuf, NULL);
	if (pid < 0) {
		(void)close(pivec[0]);
		(void)close(pivec[1]);
		return(NULL);
	}
	(void)close(pivec[1]);
	l = myread(pivec[0], xname, PATHSIZE);
	if (l < 0)
		warn("read"); /* report error before errno changes */
	(void)close(pivec[0]);
	if (wait_child(pid) < 0 && WIFSIGNALED(wait_status) &&
	    WTERMSIG(wait_status) != SIGPIPE) {
d473 1
a473 19
		return(NULL);
	}
	if (l < 0)
		return(NULL);
	if (l == 0) {
		fprintf(stderr, "\"%s\": No match.\n", name);
		return(NULL);
	}
	if (l == PATHSIZE) {
		fprintf(stderr, "\"%s\": Expansion buffer overflow.\n", name);
		return(NULL);
	}
	xname[l] = '\0';
	for (cp = &xname[l-1]; *cp == '\n' && cp > xname; cp--)
		;
	cp[1] = '\0';
	if (strchr(xname, ' ') && stat(xname, &sbuf) < 0) {
		fprintf(stderr, "\"%s\": Ambiguous.\n", name);
		return(NULL);
d475 2
a476 1
	return(savestr(xname));
@


1.32
log
@rcsid[] and sccsid[] and copyright[] are essentially unmaintained (and
unmaintainable).  these days, people use source.  these id's do not provide
any benefit, and do hurt the small install media
(the 33,000 line diff is essentially mechanical)
ok with the idea millert, ok dms
@
text
@d1 1
a1 1
/*	$OpenBSD: fio.c,v 1.31 2008/07/16 14:49:09 martynas Exp $	*/
d143 1
a143 1
				if ((c = *cp2++) == 0) {
d148 1
a148 1
					while ((c = *cp++) != '\0')
@


1.31
log
@- err with the pathbuf, if we know it
- use tmpdir instead of /tmp
ok millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: fio.c,v 1.30 2007/10/05 14:39:39 chl Exp $	*/
a31 8

#ifndef lint
#if 0
static const char sccsid[] = "@@(#)fio.c	8.2 (Berkeley) 4/20/95";
#else
static const char rcsid[] = "$OpenBSD: fio.c,v 1.30 2007/10/05 14:39:39 chl Exp $";
#endif
#endif /* not lint */
@


1.30
log
@check if it's really a newline before removing it

with the help of ray@@ "Looks OK" millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: fio.c,v 1.29 2007/09/10 14:29:53 tobias Exp $	*/
d37 1
a37 1
static const char rcsid[] = "$OpenBSD: fio.c,v 1.29 2007/09/10 14:29:53 tobias Exp $";
d134 1
a134 1
			err(1, "/tmp");
@


1.29
log
@Proper use of fseek/fseeko macros.

OK joris@@, otto@@
@
text
@d1 1
a1 1
/*	$OpenBSD: fio.c,v 1.28 2007/05/25 21:27:16 krw Exp $	*/
d37 1
a37 1
static const char rcsid[] = "$OpenBSD: fio.c,v 1.28 2007/05/25 21:27:16 krw Exp $";
d135 1
a135 1
		if (count)
@


1.28
log
@"interupt" -> "interrupt" in various comments. Mostly from Diego Casati.
@
text
@d1 1
a1 1
/*	$OpenBSD: fio.c,v 1.27 2006/11/16 00:16:29 ray Exp $	*/
d37 1
a37 1
static const char rcsid[] = "$OpenBSD: fio.c,v 1.27 2006/11/16 00:16:29 ray Exp $";
d94 1
a94 1
		(void)fseeko(ibuf, offset, 0);
d271 2
a272 1
	if (fseek(itf, (long)positionof(mp->m_block, mp->m_offset), 0) < 0)
@


1.27
log
@Fix undefined behavior (var = --var).

From Alexey Dobriyan <adobriyan at gmail dot com>.

OK moritz@@ and jaredy@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: fio.c,v 1.26 2006/04/02 00:51:37 deraadt Exp $	*/
d37 1
a37 1
static const char rcsid[] = "$OpenBSD: fio.c,v 1.26 2006/04/02 00:51:37 deraadt Exp $";
d216 1
a216 1
	 * read to be interuptible.
@


1.26
log
@use SEEK_* for lseek()
@
text
@d1 1
a1 1
/*	$OpenBSD: fio.c,v 1.25 2004/05/10 15:25:51 deraadt Exp $	*/
d37 1
a37 1
static const char rcsid[] = "$OpenBSD: fio.c,v 1.25 2004/05/10 15:25:51 deraadt Exp $";
d126 5
a130 2
		    linebuf[count - 2] == '\r')
			linebuf[count - 2] = linebuf[--count];
@


1.25
log
@delint; millert ok
@
text
@d1 1
a1 1
/*	$OpenBSD: fio.c,v 1.24 2003/07/07 21:36:51 deraadt Exp $	*/
d37 1
a37 1
static const char rcsid[] = "$OpenBSD: fio.c,v 1.24 2003/07/07 21:36:51 deraadt Exp $";
d295 1
a295 1
	(void)lseek(fileno(f), (off_t)sizeof(*message), 0);
@


1.24
log
@protos
@
text
@d1 1
a1 1
/*	$OpenBSD: fio.c,v 1.23 2003/06/03 02:56:11 millert Exp $	*/
d37 1
a37 1
static const char rcsid[] = "$OpenBSD: fio.c,v 1.23 2003/06/03 02:56:11 millert Exp $";
d94 1
a94 1
		(void)fseek(ibuf, offset, 0);
d101 1
a101 1
		(void)fseek(otf, 0L, SEEK_END);
d330 1
a330 1
			return(truncate(name, 0));
@


1.23
log
@Remove the advertising clause in the UCB license which Berkeley
rescinded 22 July 1999.  Proofed by myself and Theo.
@
text
@d1 1
a1 1
/*	$OpenBSD: fio.c,v 1.22 2002/03/14 06:51:42 mpech Exp $	*/
d37 1
a37 1
static const char rcsid[] = "$OpenBSD: fio.c,v 1.22 2002/03/14 06:51:42 mpech Exp $";
d61 1
a61 1
ssize_t
@


1.22
log
@Remove \n from err/errx/warn/warnx().

millert@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: fio.c,v 1.21 2001/12/18 16:55:06 millert Exp $	*/
d16 1
a16 5
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
d37 1
a37 1
static const char rcsid[] = "$OpenBSD: fio.c,v 1.21 2001/12/18 16:55:06 millert Exp $";
@


1.21
log
@We need to adjust where "dot" points when we realloc(message).
Problem found by Mike Heffner of the FreeBSD project.
@
text
@d1 1
a1 1
/*	$OpenBSD: fio.c,v 1.20 2001/11/21 15:26:39 millert Exp $	*/
d41 1
a41 1
static const char rcsid[] = "$OpenBSD: fio.c,v 1.20 2001/11/21 15:26:39 millert Exp $";
d290 1
a290 1
		errx(1, "Insufficient memory for %d messages\n",
@


1.20
log
@o ANSIfy
o Style nits
o Use const to silent stupid -Wall warnings
o strnc{py,at} -> strlc{py,at}
o Use strpbrk() instead of homegrown anyof()
o Use NULL instead of #defines with 0 cast to a pointer
This still could use a proper audit
@
text
@d1 1
a1 1
/*	$OpenBSD: fio.c,v 1.19 2001/11/20 20:50:00 millert Exp $	*/
d41 1
a41 1
static const char rcsid[] = "$OpenBSD: fio.c,v 1.19 2001/11/20 20:50:00 millert Exp $";
d284 2
a285 1
	size_t size = (msgCount + 1) * sizeof(struct message);
d287 10
a296 13
	if (omsgCount) {
		message = (struct message *)realloc(message, size);
		if (message == 0)
			errx(1, "Insufficient memory for %d messages\n",
			    msgCount);
	} else {
		if (message != 0)
			(void)free(message);
		if ((message = (struct message *)malloc(size)) == NULL)
			errx(1, "Insufficient memory for %d messages",
			    msgCount);
		dot = message;
	}
@


1.19
log
@Major signal overhaul.  We no longer longjmp all over the place.
Instead, routines responsible to gathering user input (or in some
cases outputting data) catch the signals and set flags as needed.
Because of this some handlers are install without the SA_RESTART
flag so syscalls are not restarted and we can check the flag.  All
signal handlers are now safe.

This should make the flow of control a bit more grokable but the
code is still ugly.
@
text
@d1 1
a1 1
/*	$OpenBSD: fio.c,v 1.18 2001/01/16 05:36:08 millert Exp $	*/
d39 1
a39 1
static char sccsid[] = "@@(#)fio.c	8.2 (Berkeley) 4/20/95";
d41 1
a41 1
static char rcsid[] = "$OpenBSD: fio.c,v 1.18 2001/01/16 05:36:08 millert Exp $";
d66 1
a66 4
myread(fd, buf, len)
	int fd;
	char *buf;
	int len;
d79 1
a79 3
setptr(ibuf, offset)
	FILE *ibuf;
	off_t offset;
d182 1
a182 4
putline(obuf, linebuf, outlf)
	FILE *obuf;
	char *linebuf;
	int   outlf;
d203 1
a203 5
readline(ibuf, linebuf, linesize, signo)
	FILE *ibuf;
	char *linebuf;
	int linesize;
	int *signo;
d268 1
a268 2
setinput(mp)
	struct message *mp;
d282 1
a282 3
makemessage(f, omsgCount)
	FILE *f;
	int omsgCount;
d314 1
a314 3
append(mp, f)
	struct message *mp;
	FILE *f;
d316 1
d324 1
a324 2
rm(name)
	char *name;
d349 1
a349 1
holdsigs()
d365 1
a365 1
relsesigs()
d376 1
a376 4
ignoresig(sig, oact, oset)
	int sig;
	struct sigaction *oact;
	sigset_t *oset;
d402 1
a402 2
fsize(iob)
	FILE *iob;
d423 1
a423 2
expand(name)
	char *name;
d427 2
a428 1
	int pid, l;
d466 1
a466 1
	if (!anyof(name, "~{[*?$`'\"\\"))
d468 1
d516 1
a516 3
getfold(name, namelen)
	char *name;
	int namelen;
d522 3
a524 4
	if (*folder == '/') {
		strncpy(name, folder, namelen-1);
		name[namelen-1] = '\0';
	} else
d534 1
a534 1
getdeadletter()
d554 1
a554 2
fioint(s)
	int s;
@


1.18
log
@Changes from Don Beusee:
o escape From line with a leading '>' when needed
o only print To: address and Subject lines if actually present
o new variable 'allnet' to treat user@@foo and user@@bar as the same "user"
o folders command now takes an optional argument like ls.
o new "pipe" (|) command to pipe the message through an arbitrary command
o make header display format the same as SunOS 4.1.3 /usr/ucb/mail
o tilde commands work regardless of interactive mode.
o fix "read: Interrupted system call" error by retrying if EINTR
o expanded help file
Changes by me:
o read the help file via the PAGER as it is now more than 24 lines long
@
text
@d1 1
a1 1
/*	$OpenBSD: fio.c,v 1.17 2000/08/02 04:10:48 millert Exp $	*/
d41 1
a41 1
static char rcsid[] = "$OpenBSD: fio.c,v 1.17 2000/08/02 04:10:48 millert Exp $";
d60 2
d211 1
a211 1
readline(ibuf, linebuf, linesize)
d215 1
d217 7
d226 23
d250 21
a270 2
	if (fgets(linebuf, linesize, ibuf) == NULL)
		return(-1);
a271 5
	n = strlen(linebuf);
	if (n > 0 && linebuf[n - 1] == '\n')
		linebuf[--n] = '\0';
	if (n > 0 && linebuf[n - 1] == '\r')
		linebuf[--n] = '\0';
d390 28
d570 12
@


1.17
log
@$HOME paranoia: never use getenv("HOME") w/o checking for NULL and non-zero
@
text
@d1 1
a1 1
/*	$OpenBSD: fio.c,v 1.16 1998/06/12 17:51:51 millert Exp $	*/
d41 1
a41 1
static char rcsid[] = "$OpenBSD: fio.c,v 1.16 1998/06/12 17:51:51 millert Exp $";
d61 16
d270 1
a270 1
	if (read(fileno(f), (void *) &message[omsgCount], size) != size)
d419 1
a419 2
	if ((shell = value("SHELL")) == NULL)
		shell = _PATH_CSHELL;
d427 3
a429 1
	l = read(pivec[0], xname, PATHSIZE);
d436 1
a436 2
	if (l < 0) {
		warn("read");
a437 1
	}
@


1.16
log
@Don't call truncate() directly; have rm() do it if we get EPERM on unlink()
In popen.c, findchild() may return NULL so catch that case.
@
text
@d1 1
a1 1
/*	$OpenBSD: fio.c,v 1.15 1998/06/11 06:20:18 deraadt Exp $	*/
d41 1
a41 1
static char rcsid[] = "$OpenBSD: fio.c,v 1.15 1998/06/11 06:20:18 deraadt Exp $";
d392 1
a392 1
	if (name[0] == '~' && (name[1] == '/' || name[1] == '\0')) {
d458 2
a459 1
		(void)snprintf(name, namelen, "%s/%s", homedir, folder);
@


1.15
log
@Don't segfault just because a line starts with NUL; ross
@
text
@d1 1
a1 1
/*	$OpenBSD: fio.c,v 1.14 1997/11/14 00:23:47 millert Exp $	*/
d41 1
a41 1
static char rcsid[] = "$OpenBSD: fio.c,v 1.14 1997/11/14 00:23:47 millert Exp $";
d274 1
a274 1
 * Delete a file, but only if the file is a plain file.
d288 7
a294 1
	return(unlink(name));
@


1.14
log
@NetBSD changes (mostly comsmetic):
    replace panic() with calls to err()/errx()
    use S_IS* instead of doing by hand with S_IF*.
    Use TIMESPEC_TO_TIMEVAL() and gettimeofday instead of time(2)
    Use _POSIX_VDISABLE, not 0
    Kill register
@
text
@d1 1
a1 1
/*	$OpenBSD: fio.c,v 1.13 1997/09/04 20:44:04 millert Exp $	*/
d41 1
a41 1
static char rcsid[] = "$OpenBSD: fio.c,v 1.13 1997/09/04 20:44:04 millert Exp $";
d123 2
a124 1
		linebuf[count - 1] = '\0';
@


1.13
log
@Deal with <CR><LF> pairs in mailboxes so we can work with eudora mail
spools mounted from DOS/Windoze.  From Matt Thomas <matt@@3am-software.com>.
@
text
@d1 1
a1 1
/*	$OpenBSD: fio.c,v 1.12 1997/08/31 14:32:13 millert Exp $	*/
d41 1
a41 1
static char rcsid[] = "$OpenBSD: fio.c,v 1.12 1997/08/31 14:32:13 millert Exp $";
d65 1
a65 1
	register FILE *ibuf;
d68 2
a69 2
	register int c, count;
	register char *cp, *cp2;
d72 1
a72 1
	int maybe, inhead;
a73 1
	int omsgCount;
d173 1
a173 1
	register int c;
d197 1
a197 1
	register int n;
d217 1
a217 1
	register struct message *mp;
d221 2
a222 4
	if (fseek(itf, (long)positionof(mp->m_block, mp->m_offset), 0) < 0) {
		warn("fseek");
		panic("temporary file seek");
	}
d235 1
a235 1
	register size_t size = (msgCount + 1) * sizeof(struct message);
d240 2
a241 1
			panic("Insufficient memory for %d messages\n", msgCount);
d246 2
a247 1
			panic("Insufficient memory for %d messages", msgCount);
d254 1
a254 1
		panic("Message temporary file corrupted");
d347 1
a347 1
	register char *name;
d351 2
a352 2
	register int pid, l;
	register char *cp, *shell;
d461 1
a461 1
	register char *cp;
@


1.12
log
@Kill union wait.
@
text
@d1 1
a1 1
/*	$OpenBSD: fio.c,v 1.11 1997/07/28 15:20:30 millert Exp $	*/
d41 1
a41 1
static char rcsid[] = "$OpenBSD: fio.c,v 1.11 1997/07/28 15:20:30 millert Exp $";
d112 9
d190 1
a190 1
 * include the newline at the end.
d206 2
@


1.11
log
@Dynamically allocate space for addr header strings instead of using
BUFSIZ.  We know that the end size will be <= to the start size
so it is simple to preallocate enough space.  Fixes NetBSD PR#3028
@
text
@d1 1
a1 1
/*	$OpenBSD: fio.c,v 1.10 1997/07/24 17:27:11 millert Exp $	*/
d41 1
a41 1
static char rcsid[] = "$OpenBSD: fio.c,v 1.10 1997/07/24 17:27:11 millert Exp $";
d345 1
a345 1
	extern union wait wait_status;
d397 2
a398 1
	if (wait_child(pid) < 0 && wait_status.w_termsig != SIGPIPE) {
@


1.10
log
@tempnam(3) goes bye bye.
@
text
@d1 1
a1 1
/*	$OpenBSD: fio.c,v 1.9 1997/07/24 16:23:37 millert Exp $	*/
d41 1
a41 1
static char rcsid[] = "$OpenBSD: fio.c,v 1.9 1997/07/24 16:23:37 millert Exp $";
d236 1
a236 1
		if ((message = (struct message *)malloc(size)) == 0)
@


1.9
log
@Replace 3 tempnam()'s with mkstemp.  The two left look tricky.
@
text
@d1 1
a1 1
/*	$OpenBSD: fio.c,v 1.8 1997/07/14 00:24:26 millert Exp $	*/
d41 1
a41 1
static char rcsid[] = "$OpenBSD: fio.c,v 1.8 1997/07/14 00:24:26 millert Exp $";
d80 1
a80 1
	(void)unlink(pathbuf);
d371 1
a371 1
		snprintf(xname, sizeof(xname), "%s/%s", cmdbuf, name + 1);
d376 1
a376 1
		snprintf(xname, sizeof(xname), "%s%s", homedir, name + 1);
d385 1
a385 1
	snprintf(cmdbuf, sizeof(cmdbuf), "echo %s", name);
d440 1
a440 1
		snprintf(name, namelen, "%s/%s", homedir, folder);
@


1.8
log
@NOSTR -> NULL
Use sigsetjmp/siglongjmp instead of sigjmp/longjmp for portability.
@
text
@d1 1
a1 1
/*	$OpenBSD: fio.c,v 1.7 1997/07/13 23:53:59 millert Exp $	*/
d41 1
a41 1
static char rcsid[] = "$OpenBSD: fio.c,v 1.7 1997/07/13 23:53:59 millert Exp $";
a67 1
	extern char *tmpdir;
@


1.7
log
@bcopy() -> memcpy() and fix some casts.
@
text
@d1 1
a1 1
/*	$OpenBSD: fio.c,v 1.6 1997/07/13 21:21:12 millert Exp $	*/
d41 1
a41 1
static char rcsid[] = "$OpenBSD: fio.c,v 1.6 1997/07/13 21:21:12 millert Exp $";
d363 1
a363 1
			return(NOSTR);
d367 1
a367 1
		if (name[1] == 0 && (name = value("MBOX")) == NOSTR)
d387 1
a387 1
	if ((shell = value("SHELL")) == NOSTR)
d389 1
a389 1
	pid = start_command(shell, 0, -1, pivec[1], "-c", cmdbuf, NOSTR);
d393 1
a393 1
		return(NOSTR);
d400 1
a400 1
		return(NOSTR);
d404 1
a404 1
		return(NOSTR);
d408 1
a408 1
		return(NOSTR);
d412 1
a412 1
		return(NOSTR);
d420 1
a420 1
		return(NOSTR);
d435 1
a435 1
	if ((folder = value("folder")) == NOSTR)
d453 1
a453 1
	if ((cp = value("DEAD")) == NOSTR || (cp = expand(cp)) == NOSTR)
@


1.6
log
@Merge in NetBSD and 4.4BSD-lite2 changes as well as some of my own.
 - handle long lines safely (from NetBSD)
 - use puts/fputs and putchar/putc when it makes sense
 - use err/errx and warn/warnx when it makes sense
 - make return() and sizeof() style consisten
 - some more buffer safety
@
text
@d1 1
a1 1
/*	$OpenBSD: fio.c,v 1.5 1997/05/30 08:51:39 deraadt Exp $	*/
d41 1
a41 1
static char rcsid[] = "$OpenBSD: fio.c,v 1.5 1997/05/30 08:51:39 deraadt Exp $";
d87 1
a87 1
		(void) fseek(ibuf, offset, 0);
d94 1
a94 1
		(void) fseek(otf, 0L, SEEK_END);
d113 1
a113 1
		(void) fwrite(linebuf, sizeof(*linebuf), count, otf);
d169 1
a169 1
	(void) fwrite(linebuf, sizeof(*linebuf), c, obuf);
d171 1
a171 1
		(void) putc('\n', obuf);
d228 1
a228 1
	register size = (msgCount + 1) * sizeof(struct message);
d231 1
a231 1
		message = (struct message *)realloc(message, (unsigned) size);
d236 2
a237 2
			free((char *) message);
		if ((message = (struct message *) malloc((unsigned) size)) == 0)
d243 1
a243 1
	(void) lseek(fileno(f), (off_t)sizeof(*message), 0);
d458 1
a458 1
		(void) snprintf(buf, sizeof(buf), "~/%s", cp);
@


1.5
log
@overflows abound
@
text
@d1 2
a2 2
/*	$OpenBSD: fio.c,v 1.4 1997/03/29 03:01:46 millert Exp $	*/
/*	$NetBSD: fio.c,v 1.5 1996/06/08 19:48:22 christos Exp $	*/
d39 1
a39 1
static char sccsid[] = "@@(#)fio.c	8.1 (Berkeley) 6/6/93";
d41 1
a41 1
static char rcsid[] = "$OpenBSD: fio.c,v 1.4 1997/03/29 03:01:46 millert Exp $";
d64 1
a64 1
setptr(ibuf)
d66 1
a72 1
	off_t offset;
d75 1
d78 3
a80 6
	(void)snprintf(pathbuf, sizeof pathbuf, "%s/mail.XXXXXXXXXX", tmpdir);
	if ((c = mkstemp(pathbuf)) == -1 ||
	    (mestmp = Fdopen(c, "r+")) == NULL) {
		(void)fprintf(stderr, "mail: can't open %s\n", pathbuf);
		exit(1);
	}
d83 15
a97 1
	msgCount = 0;
a99 1
	offset = 0;
d106 4
a109 6
		if (fgets(linebuf, LINESIZE, ibuf) == NULL) {
			if (append(&this, mestmp)) {
				perror("temporary file");
				exit(1);
			}
			makemessage(mestmp);
d113 4
a116 6
		(void) fwrite(linebuf, sizeof *linebuf, count, otf);
		if (ferror(otf)) {
			perror("/tmp");
			exit(1);
		}
		linebuf[count - 1] = 0;
d119 2
a120 4
			if (append(&this, mestmp)) {
				perror("temporary file");
				exit(1);
			}
d158 1
a158 1
 * characters written, including the newline.
d161 1
a161 1
putline(obuf, linebuf)
d164 1
d169 5
a173 2
	(void) fwrite(linebuf, sizeof *linebuf, c, obuf);
	(void) putc('\n', obuf);
d175 2
a176 2
		return (-1);
	return (c + 1);
d194 2
a195 1
		return -1;
d199 1
a199 1
	return n;
d213 1
a213 1
		perror("fseek");
d216 1
a216 1
	return (itf);
d224 1
a224 1
makemessage(f)
d226 1
d228 1
a228 1
	register size = (msgCount + 1) * sizeof (struct message);
d230 12
a241 6
	if (message != 0)
		free((char *) message);
	if ((message = (struct message *) malloc((unsigned) size)) == 0)
		panic("Insufficient memory for %d messages", msgCount);
	dot = message;
	size -= sizeof (struct message);
d243 2
a244 2
	(void) lseek(fileno(f), (off_t)sizeof *message, 0);
	if (read(fileno(f), (char *) message, size) != size)
d248 1
a248 1
	Fclose(f);
d260 1
a260 1
	return fwrite((char *) mp, sizeof *mp, 1, f) != 1;
d321 2
a322 2
		return 0;
	return sbuf.st_size;
d356 2
a357 2
		findmail(name[1] ? name + 1 : myname, xname, sizeof xname);
		return savestr(xname);
d362 2
a363 2
			printf("No previous file\n");
			return NOSTR;
d365 1
a365 1
		return savestr(prevfile);
d371 2
a372 2
	if (name[0] == '+' && getfold(cmdbuf, sizeof cmdbuf) >= 0) {
		snprintf(xname, sizeof xname, "%s/%s", cmdbuf, name + 1);
d377 1
a377 1
		snprintf(xname, sizeof xname, "%s%s", homedir, name + 1);
d381 1
a381 1
		return name;
d383 2
a384 2
		perror("pipe");
		return name;
d386 1
a386 1
	snprintf(cmdbuf, sizeof cmdbuf, "echo %s", name);
d391 7
a397 7
		close(pivec[0]);
		close(pivec[1]);
		return NOSTR;
	}
	close(pivec[1]);
	l = read(pivec[0], xname, BUFSIZ);
	close(pivec[0]);
d400 1
a400 1
		return NOSTR;
d403 2
a404 2
		perror("read");
		return NOSTR;
d408 1
a408 1
		return NOSTR;
d410 1
a410 1
	if (l == BUFSIZ) {
d412 1
a412 1
		return NOSTR;
d414 1
a414 1
	xname[l] = 0;
d420 1
a420 1
		return NOSTR;
d422 1
a422 1
	return savestr(xname);
d436 1
a436 1
		return (-1);
d442 1
a442 1
	return (0);
d458 1
a458 1
		(void) snprintf(buf, sizeof buf, "~/%s", cp);
d461 1
a461 1
	return cp;
@


1.4
log
@Use ``mail.local -H'' to do dot locking so we can have mode 755 mail
spool, change an occurrence of tempnam() to mkstemp(), change some
longs and shorts to ints.  Mail is now usable again.
@
text
@d1 1
a1 1
/*	$OpenBSD: fio.c,v 1.3 1997/01/17 07:12:46 millert Exp $	*/
d41 1
a41 1
static char rcsid[] = "$OpenBSD: fio.c,v 1.3 1997/01/17 07:12:46 millert Exp $";
d74 1
a74 1
	char linebuf[LINESIZE];
d77 2
a78 2
	(void)sprintf(linebuf, "%s/mail.XXXXXXXXXX", tmpdir);
	if ((c = mkstemp(linebuf)) == -1 ||
d80 1
a80 1
		(void)fprintf(stderr, "mail: can't open %s\n", linebuf);
d83 1
a83 1
	(void)unlink(linebuf);
d339 1
a339 1
		findmail(name[1] ? name + 1 : myname, xname);
d354 2
a355 2
	if (name[0] == '+' && getfold(cmdbuf) >= 0) {
		sprintf(xname, "%s/%s", cmdbuf, name + 1);
d360 1
a360 1
		sprintf(xname, "%s%s", homedir, name + 1);
d369 1
a369 1
	sprintf(cmdbuf, "echo %s", name);
d412 1
a412 1
getfold(name)
d414 1
d420 5
a424 4
	if (*folder == '/')
		strcpy(name, folder);
	else
		sprintf(name, "%s/%s", homedir, folder);
d441 1
a441 1
		(void) sprintf(buf, "~/%s", cp);
@


1.3
log
@r?index -> strr?chr
@
text
@d1 1
a1 1
/*	$OpenBSD: fio.c,v 1.2 1996/06/11 12:53:39 deraadt Exp $	*/
d41 1
a41 1
static char rcsid[] = "$OpenBSD: fio.c,v 1.2 1996/06/11 12:53:39 deraadt Exp $";
d77 1
a77 1
	(void)sprintf(linebuf, "%s/mail.XXXXXX", tmpdir);
@


1.2
log
@from christos;
- Fix PR/105: Implement dot locking protocol and check return value of flock.
- Fix PR/2247: Don't call unknown users "ubluit". Issue an error message.
- Fix/add prototypes.
- Fix warnings.
- Use POSIX signal mask calls.
@
text
@d1 1
a1 1
/*	$OpenBSD: fio.c,v 1.5 1996/06/08 19:48:22 christos Exp $	*/
d41 1
a41 1
static char rcsid[] = "$OpenBSD: fio.c,v 1.5 1996/06/08 19:48:22 christos Exp $";
d401 1
a401 1
	if (index(xname, ' ') && stat(xname, &sbuf) < 0) {
@


1.1
log
@Initial revision
@
text
@d1 3
d38 5
a42 2
static char sccsid[] = "from: @@(#)fio.c	8.1 (Berkeley) 6/6/93";
static char rcsid[] = "$Id: fio.c,v 1.4 1994/06/29 05:09:22 deraadt Exp $";
d131 1
a131 1
					while (c = *cp++)
d265 1
a265 1
static int omask;
d273 7
a279 2
	if (sigdepth++ == 0)
		omask = sigblock(sigmask(SIGHUP)|sigmask(SIGINT)|sigmask(SIGQUIT));
d290 1
a290 1
		sigsetmask(omask);
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@
