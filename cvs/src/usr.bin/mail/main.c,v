head	1.33;
access;
symbols
	OPENBSD_6_1:1.33.0.6
	OPENBSD_6_1_BASE:1.33
	OPENBSD_6_0:1.33.0.4
	OPENBSD_6_0_BASE:1.33
	OPENBSD_5_9:1.33.0.2
	OPENBSD_5_9_BASE:1.33
	OPENBSD_5_8:1.31.0.6
	OPENBSD_5_8_BASE:1.31
	OPENBSD_5_7:1.31.0.2
	OPENBSD_5_7_BASE:1.31
	OPENBSD_5_6:1.23.0.22
	OPENBSD_5_6_BASE:1.23
	OPENBSD_5_5:1.23.0.20
	OPENBSD_5_5_BASE:1.23
	OPENBSD_5_4:1.23.0.16
	OPENBSD_5_4_BASE:1.23
	OPENBSD_5_3:1.23.0.14
	OPENBSD_5_3_BASE:1.23
	OPENBSD_5_2:1.23.0.12
	OPENBSD_5_2_BASE:1.23
	OPENBSD_5_1_BASE:1.23
	OPENBSD_5_1:1.23.0.10
	OPENBSD_5_0:1.23.0.8
	OPENBSD_5_0_BASE:1.23
	OPENBSD_4_9:1.23.0.6
	OPENBSD_4_9_BASE:1.23
	OPENBSD_4_8:1.23.0.4
	OPENBSD_4_8_BASE:1.23
	OPENBSD_4_7:1.23.0.2
	OPENBSD_4_7_BASE:1.23
	OPENBSD_4_6:1.22.0.6
	OPENBSD_4_6_BASE:1.22
	OPENBSD_4_5:1.22.0.2
	OPENBSD_4_5_BASE:1.22
	OPENBSD_4_4:1.21.0.2
	OPENBSD_4_4_BASE:1.21
	OPENBSD_4_3:1.20.0.4
	OPENBSD_4_3_BASE:1.20
	OPENBSD_4_2:1.20.0.2
	OPENBSD_4_2_BASE:1.20
	OPENBSD_4_1:1.19.0.12
	OPENBSD_4_1_BASE:1.19
	OPENBSD_4_0:1.19.0.10
	OPENBSD_4_0_BASE:1.19
	OPENBSD_3_9:1.19.0.8
	OPENBSD_3_9_BASE:1.19
	OPENBSD_3_8:1.19.0.6
	OPENBSD_3_8_BASE:1.19
	OPENBSD_3_7:1.19.0.4
	OPENBSD_3_7_BASE:1.19
	OPENBSD_3_6:1.19.0.2
	OPENBSD_3_6_BASE:1.19
	OPENBSD_3_5:1.18.0.4
	OPENBSD_3_5_BASE:1.18
	OPENBSD_3_4:1.18.0.2
	OPENBSD_3_4_BASE:1.18
	OPENBSD_3_3:1.17.0.6
	OPENBSD_3_3_BASE:1.17
	OPENBSD_3_2:1.17.0.4
	OPENBSD_3_2_BASE:1.17
	OPENBSD_3_1:1.17.0.2
	OPENBSD_3_1_BASE:1.17
	OPENBSD_3_0:1.14.0.2
	OPENBSD_3_0_BASE:1.14
	OPENBSD_2_9_BASE:1.12
	OPENBSD_2_9:1.12.0.4
	OPENBSD_2_8:1.12.0.2
	OPENBSD_2_8_BASE:1.12
	OPENBSD_2_7:1.11.0.8
	OPENBSD_2_7_BASE:1.11
	OPENBSD_2_6:1.11.0.6
	OPENBSD_2_6_BASE:1.11
	OPENBSD_2_5:1.11.0.4
	OPENBSD_2_5_BASE:1.11
	OPENBSD_2_4:1.11.0.2
	OPENBSD_2_4_BASE:1.11
	OPENBSD_2_3:1.10.0.2
	OPENBSD_2_3_BASE:1.10
	OPENBSD_2_2:1.9.0.2
	OPENBSD_2_2_BASE:1.9
	OPENBSD_2_1:1.4.0.2
	OPENBSD_2_1_BASE:1.4
	OPENBSD_2_0:1.3.0.2
	OPENBSD_2_0_BASE:1.3
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.33
date	2015.11.24.00.08.27;	author deraadt;	state Exp;
branches;
next	1.32;
commitid	bv2s69mgFfIbu3OJ;

1.32
date	2015.11.16.21.20.40;	author deraadt;	state Exp;
branches;
next	1.31;
commitid	okxkp9ZL2EiR73n3;

1.31
date	2015.02.08.23.40.34;	author deraadt;	state Exp;
branches;
next	1.30;
commitid	yGZX28AeTChVE8eY;

1.30
date	2015.01.24.20.32.46;	author millert;	state Exp;
branches;
next	1.29;
commitid	wYOxnxUV7lXvK5YZ;

1.29
date	2015.01.22.16.25.07;	author millert;	state Exp;
branches;
next	1.28;
commitid	HXg8bdmRkuk7fvTP;

1.28
date	2015.01.20.16.59.07;	author millert;	state Exp;
branches;
next	1.27;
commitid	92usC3cTTCZG2qZC;

1.27
date	2015.01.16.06.40.09;	author deraadt;	state Exp;
branches;
next	1.26;
commitid	Uu5nFG3wCl0LACBb;

1.26
date	2014.12.16.18.37.17;	author millert;	state Exp;
branches;
next	1.25;
commitid	5pfJtSG0aRpBbeHu;

1.25
date	2014.11.24.20.03.33;	author millert;	state Exp;
branches;
next	1.24;
commitid	BYsKGcOwt27tJQkY;

1.24
date	2014.11.24.20.01.43;	author millert;	state Exp;
branches;
next	1.23;
commitid	LJSWmbXLAaCRa2Mq;

1.23
date	2009.10.27.23.59.40;	author deraadt;	state Exp;
branches;
next	1.22;

1.22
date	2008.10.09.06.48.11;	author jmc;	state Exp;
branches;
next	1.21;

1.21
date	2008.07.16.15.11.16;	author martynas;	state Exp;
branches;
next	1.20;

1.20
date	2007.08.06.19.16.06;	author sobrado;	state Exp;
branches;
next	1.19;

1.19
date	2004.04.19.10.17.18;	author jmc;	state Exp;
branches;
next	1.18;

1.18
date	2003.06.03.02.56.11;	author millert;	state Exp;
branches;
next	1.17;

1.17
date	2001.11.21.15.28.25;	author millert;	state Exp;
branches;
next	1.16;

1.16
date	2001.11.21.15.26.39;	author millert;	state Exp;
branches;
next	1.15;

1.15
date	2001.11.20.20.50.00;	author millert;	state Exp;
branches;
next	1.14;

1.14
date	2001.10.11.20.59.46;	author millert;	state Exp;
branches;
next	1.13;

1.13
date	2001.09.07.01.19.15;	author millert;	state Exp;
branches;
next	1.12;

1.12
date	2000.06.30.16.00.19;	author millert;	state Exp;
branches;
next	1.11;

1.11
date	98.09.27.21.16.42;	author millert;	state Exp;
branches
	1.11.8.1;
next	1.10;

1.10
date	97.11.14.00.23.52;	author millert;	state Exp;
branches;
next	1.9;

1.9
date	97.07.30.06.32.40;	author millert;	state Exp;
branches;
next	1.8;

1.8
date	97.07.14.15.56.24;	author millert;	state Exp;
branches;
next	1.7;

1.7
date	97.07.14.00.24.28;	author millert;	state Exp;
branches;
next	1.6;

1.6
date	97.07.13.23.54.00;	author millert;	state Exp;
branches;
next	1.5;

1.5
date	97.07.13.21.21.15;	author millert;	state Exp;
branches;
next	1.4;

1.4
date	97.01.15.23.42.50;	author millert;	state Exp;
branches;
next	1.3;

1.3
date	96.09.16.02.26.09;	author deraadt;	state Exp;
branches;
next	1.2;

1.2
date	96.06.11.12.53.45;	author deraadt;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.45.39;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.45.39;	author deraadt;	state Exp;
branches;
next	;

1.11.8.1
date	2000.10.06.21.16.15;	author jason;	state Exp;
branches;
next	;


desc
@@


1.33
log
@missing pledge "getpw"
@
text
@/*	$OpenBSD: main.c,v 1.32 2015/11/16 21:20:40 deraadt Exp $	*/
/*	$NetBSD: main.c,v 1.7 1997/05/13 06:15:57 mikel Exp $	*/

/*
 * Copyright (c) 1980, 1993
 *	The Regents of the University of California.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */

#include "rcv.h"
#include <fcntl.h>
#include <sys/ioctl.h>
#include "extern.h"

__dead	void	usage(void);
	int	main(int, char **);

/*
 * Mail -- a mail program
 *
 * Startup -- interface with user.
 */

int
main(int argc, char **argv)
{
	int i;
	struct name *to, *cc, *bcc, *smopts;
	char *fromaddr;
	char *subject;
	char *ef;
	char nosrc = 0;
	char *rc;
	extern const char version[];

	if (pledge("stdio rpath wpath cpath getpw tmppath fattr tty flock proc exec",
	    NULL) == -1)
		err(1, "pledge");

	/*
	 * Set up a reasonable environment.
	 * Figure out whether we are being run interactively,
	 * start the SIGCHLD catcher, and so forth.
	 */
	(void)signal(SIGCHLD, sigchild);
	(void)signal(SIGPIPE, SIG_IGN);
	if (isatty(0))
		assign("interactive", "");
	image = -1;
	/*
	 * Now, determine how we are being used.
	 * We successively pick off - flags.
	 * If there is anything left, it is the base of the list
	 * of users to mail to.  Argp will be set to point to the
	 * first of these users.
	 */
	ef = NULL;
	to = NULL;
	cc = NULL;
	bcc = NULL;
	smopts = NULL;
	fromaddr = NULL;
	subject = NULL;
	while ((i = getopt(argc, argv, "EINb:c:dfinr:s:u:v")) != -1) {
		switch (i) {
		case 'u':
			/*
			 * Next argument is person to pretend to be.
			 */
			if (strlen(optarg) >= LOGIN_NAME_MAX)
				errx(1, "username `%s' too long", optarg);
			unsetenv("MAIL");
			myname = optarg;
			uflag = 1;
			break;
		case 'i':
			/*
			 * User wants to ignore interrupts.
			 * Set the variable "ignore"
			 */
			assign("ignore", "");
			break;
		case 'd':
			debug++;
			break;
		case 'r':
			/*
			 * Set From: address
			 */
			fromaddr = optarg;
			break;
		case 's':
			/*
			 * Give a subject field for sending from
			 * non terminal
			 */
			subject = optarg;
			break;
		case 'f':
			/*
			 * User is specifying file to "edit" with Mail,
			 * as opposed to reading system mailbox.
			 * We read his mbox file unless another file
			 * is specified after the arguments.
			 */
			ef = "&";
			break;
		case 'n':
			/*
			 * User doesn't want to source /usr/lib/Mail.rc
			 */
			nosrc = 1;
			break;
		case 'N':
			/*
			 * Avoid initial header printing.
			 */
			assign("noheader", "");
			break;
		case 'v':
			/*
			 * Send mailer verbose flag
			 */
			assign("verbose", "");
			break;
		case 'I':
			/*
			 * We're interactive
			 */
			assign("interactive", "");
			break;
		case 'c':
			/*
			 * Get Carbon Copy Recipient list
			 */
			cc = cat(cc, nalloc(optarg, GCC));
			break;
		case 'b':
			/*
			 * Get Blind Carbon Copy Recipient list
			 */
			bcc = cat(bcc, nalloc(optarg, GBCC));
			break;
		case 'E':
			/*
			 * Don't send messages with an empty body.
			 */
			assign("skipempty", "");
			break;
		default:
			usage();
			/*NOTREACHED*/
		}
	}
	if (ef != NULL) {
		/* Check for optional mailbox file name. */
		if (optind < argc) {
			ef = argv[optind++];
			if (optind < argc)
			    errx(1, "Cannot give -f and people to send to");
		}
	} else {
		for (i = optind; argv[i]; i++)
			to = cat(to, nalloc(argv[i], GTO));
	}
	/*
	 * Check for inconsistent arguments.
	 */
	if (to == NULL && (subject != NULL || cc != NULL || bcc != NULL ||
	    fromaddr != NULL))
		errx(1, "You must specify direct recipients with -s, -c, -b, "
		    "or -r");
	/*
	 * Block SIGINT except where we install an explicit handler for it.
	 */
	sigemptyset(&intset);
	sigaddset(&intset, SIGINT);
	(void)sigprocmask(SIG_BLOCK, &intset, NULL);
	/*
	 * Initialization.
	 */
	tinit();
	setscreensize();
	input = stdin;
	rcvmode = !to;
	spreserve();
	if (!nosrc)
		load(_PATH_MASTER_RC);
	/*
	 * Expand returns a savestr, but load only uses the file name
	 * for fopen, so it's safe to do this.
	 */
	if ((rc = getenv("MAILRC")) == 0)
		rc = "~/.mailrc";
	load(expand(rc));
	if (!rcvmode) {
		mail(to, cc, bcc, smopts, fromaddr, subject);
		/*
		 * why wait?
		 */
		exit(senderr);
	}
	/*
	 * Ok, we are reading mail.
	 * Decide whether we are editing a mailbox or reading
	 * the system mailbox, and open up the right stuff.
	 */
	if (ef == NULL)
		ef = "%";
	if (setfile(ef) < 0)
		exit(1);		/* error already reported */

	if (value("quiet") == NULL)
		(void)printf("Mail version %s.  Type ? for help.\n",
			version);
	announce();
	(void)fflush(stdout);
	commands();
	(void)ignoresig(SIGHUP, NULL, NULL);
	(void)ignoresig(SIGINT, NULL, NULL);
	(void)ignoresig(SIGQUIT, NULL, NULL);
	quit();
	exit(0);
}

/*
 * Compute what the screen size for printing headers should be.
 * We use the following algorithm for the height:
 *	If baud rate < 1200, use  9
 *	If baud rate = 1200, use 14
 *	If baud rate > 1200, use 24 or ws_row
 * Width is either 80 or ws_col;
 */
void
setscreensize(void)
{
	struct termios tbuf;
	struct winsize ws;
	speed_t ospeed;

	if (ioctl(1, TIOCGWINSZ, (char *) &ws) < 0)
		ws.ws_col = ws.ws_row = 0;
	if (tcgetattr(1, &tbuf) < 0)
		ospeed = 9600;
	else
		ospeed = cfgetospeed(&tbuf);
	if (ospeed < B1200)
		screenheight = 9;
	else if (ospeed == B1200)
		screenheight = 14;
	else if (ws.ws_row != 0)
		screenheight = ws.ws_row;
	else
		screenheight = 24;
	if ((realscreenheight = ws.ws_row) == 0)
		realscreenheight = 24;
	if ((screenwidth = ws.ws_col) == 0)
		screenwidth = 80;
}

__dead void
usage(void)
{

	fprintf(stderr, "usage: %s [-dEIinv] [-b list] [-c list] "
	    "[-r from-addr] [-s subject] to-addr ...\n", __progname);
	fprintf(stderr, "       %s [-dEIiNnv] -f [file]\n", __progname);
	fprintf(stderr, "       %s [-dEIiNnv] [-u user]\n", __progname);
	exit(1);
}
@


1.32
log
@pledge "stdio rpath wpath cpath tmppath fattr tty flock proc exec"
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.31 2015/02/08 23:40:34 deraadt Exp $	*/
d59 1
a59 1
	if (pledge("stdio rpath wpath cpath tmppath fattr tty flock proc exec",
@


1.31
log
@in getopt() blocks, stop incrementing flag variable which are supposed
to just be 0/1
ok miod florian
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.30 2015/01/24 20:32:46 millert Exp $	*/
d58 4
@


1.30
log
@Fix getopt string; the -N flag doesn't take an argument.
From Matthew Clarke
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.29 2015/01/22 16:25:07 millert Exp $	*/
d131 1
a131 1
			nosrc++;
@


1.29
log
@Only allow the -r flag when sending a message; from Martin Brandenburg
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.28 2015/01/20 16:59:07 millert Exp $	*/
d83 1
a83 1
	while ((i = getopt(argc, argv, "EIN:b:c:dfinr:s:u:v")) != -1) {
@


1.28
log
@Add support for the "-r fromaddr" flag now that we don't support
sendmail flags on the command line.
Also allow "from" to be set in mailrc.
Use sendmail's "-t" flag when executing sendmail instead of specifying
the list of recipients in argv.  The "-f" flag will be used to set
the from address if specified.
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.27 2015/01/16 06:40:09 deraadt Exp $	*/
d188 4
a191 2
	if (to == NULL && (subject != NULL || cc != NULL || bcc != NULL))
		errx(1, "You must specify direct recipients with -s, -c, or -b");
@


1.27
log
@Replace <sys/param.h> with <limits.h> and other less dirty headers where
possible.  Annotate <sys/param.h> lines with their current reasons.  Switch
to PATH_MAX, NGROUPS_MAX, HOST_NAME_MAX+1, LOGIN_NAME_MAX, etc.  Change
MIN() and MAX() to local definitions of MINIMUM() and MAXIMUM() where
sensible to avoid pulling in the pollution.  These are the files confirmed
through binary verification.
ok guenther, millert, doug (helped with the verification protocol)
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.26 2014/12/16 18:37:17 millert Exp $	*/
d52 1
d81 1
d83 1
a83 1
	while ((i = getopt(argc, argv, "EIN:b:c:dfins:u:v")) != -1) {
d105 6
d214 1
a214 1
		mail(to, cc, bcc, smopts, subject);
d283 1
a283 1
	    "[-s subject] to-addr ...\n", __progname);
@


1.26
log
@Don't pass options after the to address to sendmail.  The only
legitiate use of this is to set the sender name which should be
handled specifically by a different option.
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.25 2014/11/24 20:03:33 millert Exp $	*/
d87 1
a87 1
			if (strlen(optarg) >= MAXLOGNAME)
@


1.25
log
@The handling of the -f option is a hack.  Instead of fooling around
with argv behind getopt()'s back we can just treat the remainder
of argv[] after option processing as the file name for -f.  It is
not possible to use -f in sending mode so there is no ambiguity.
OK tobias@@
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.24 2014/11/24 20:01:43 millert Exp $	*/
d174 1
a174 1
		for (i = optind; (argv[i]) && (*argv[i] != '-'); i++)
a175 2
		for (; argv[i]; i++)
			smopts = cat(smopts, nalloc(argv[i], 0));
a275 2
	fprintf(stderr, "       %*s [-sendmail-options ...]\n",
	    (int)strlen(__progname), "");
@


1.24
log
@Remove undocumented and obsolete -T option.  It was intended for
use with old netnews.  OK sobrado@@ tobias@@
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.23 2009/10/27 23:59:40 deraadt Exp $	*/
d114 4
a117 10
			 * If no argument is given after -f, we read his
			 * mbox file.
			 *
			 * getopt() can't handle optional arguments, so here
			 * is an ugly hack to get around it.
			 */
			if ((argv[optind]) && (argv[optind][0] != '-'))
				ef = argv[optind++];
			else
				ef = "&";
d166 13
a178 4
	for (i = optind; (argv[i]) && (*argv[i] != '-'); i++)
		to = cat(to, nalloc(argv[i], GTO));
	for (; argv[i]; i++)
		smopts = cat(smopts, nalloc(argv[i], 0));
a183 2
	if (ef != NULL && to != NULL)
		errx(1, "Cannot give -f and people to send to");
@


1.23
log
@rcsid[] and sccsid[] and copyright[] are essentially unmaintained (and
unmaintainable).  these days, people use source.  these id's do not provide
any benefit, and do hurt the small install media
(the 33,000 line diff is essentially mechanical)
ok with the idea millert, ok dms
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.22 2008/10/09 06:48:11 jmc Exp $	*/
d81 1
a81 1
	while ((i = getopt(argc, argv, "EINT:b:c:dfins:u:v")) != -1) {
a82 10
		case 'T':
			/*
			 * Next argument is temp file to write which
			 * articles have been read/deleted for netnews.
			 */
			Tflag = optarg;
			if ((i = creat(Tflag, 0600)) < 0)
				err(1, "%s", Tflag);
			(void)close(i);
			break;
@


1.22
log
@- add -d to usage
- sync -f arg name with man page synopsis
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.21 2008/07/16 15:11:16 martynas Exp $	*/
a31 14

#ifndef lint
static const char copyright[] =
"@@(#) Copyright (c) 1980, 1993\n\
	The Regents of the University of California.  All rights reserved.\n";
#endif /* not lint */

#ifndef lint
#if 0
static const char sccsid[] = "@@(#)main.c	8.2 (Berkeley) 4/20/95";
#else
static const char rcsid[] = "$OpenBSD: main.c,v 1.21 2008/07/16 15:11:16 martynas Exp $";
#endif
#endif /* not lint */
@


1.21
log
@add -E flag and 'skipempty' option to skip sending messages with
empty bodies.  useful for sending mails from crontabs.
from rivo nurges <rix at estpak dot ee>, with missing 'skipempty'
documentation and usage update from me
ok millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.20 2007/08/06 19:16:06 sobrado Exp $	*/
d43 1
a43 1
static const char rcsid[] = "$OpenBSD: main.c,v 1.20 2007/08/06 19:16:06 sobrado Exp $";
d299 1
a299 1
	fprintf(stderr, "usage: %s [-EIinv] [-b list] [-c list] "
d303 2
a304 2
	fprintf(stderr, "       %s [-EIiNnv] -f [name]\n", __progname);
	fprintf(stderr, "       %s [-EIiNnv] [-u user]\n", __progname);
@


1.20
log
@the ellipsis is not an optional argument; while here, sync the usage
and synopsis of commands

lots of good ideas by jmc@@

ok jmc@@
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.19 2004/04/19 10:17:18 jmc Exp $	*/
d43 1
a43 1
static const char rcsid[] = "$OpenBSD: main.c,v 1.19 2004/04/19 10:17:18 jmc Exp $";
d95 1
a95 1
	while ((i = getopt(argc, argv, "INT:b:c:dfins:u:v")) != -1) {
d185 6
d299 1
a299 1
	fprintf(stderr, "usage: %s [-Iinv] [-b list] [-c list] "
d303 2
a304 2
	fprintf(stderr, "       %s [-IiNnv] -f [name]\n", __progname);
	fprintf(stderr, "       %s [-IiNnv] [-u user]\n", __progname);
@


1.19
log
@- sort SYNOPSIS
- remove a load of unnecessary quoting and some groff cruft
- sort options list
- add usd doc to SEE ALSO
- sync usage()
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.18 2003/06/03 02:56:11 millert Exp $	*/
d43 1
a43 1
static const char rcsid[] = "$OpenBSD: main.c,v 1.18 2003/06/03 02:56:11 millert Exp $";
d294 2
a295 2
	    "[-s subject] to-addr [...]\n", __progname);
	fprintf(stderr, "       %*s [-sendmail-options [...]]\n",
@


1.18
log
@Remove the advertising clause in the UCB license which Berkeley
rescinded 22 July 1999.  Proofed by myself and Theo.
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.17 2001/11/21 15:28:25 millert Exp $	*/
d43 1
a43 1
static const char rcsid[] = "$OpenBSD: main.c,v 1.17 2001/11/21 15:28:25 millert Exp $";
d293 3
a295 3
	fprintf(stderr, "usage: %s [-iInv] [-s subject] [-c cc-addr] "
	    "[-b bcc-addr] to-addr ...\n", __progname);
	fprintf(stderr, "       %*s [- sendmail-options ...]\n",
d297 2
a298 2
	fprintf(stderr, "       %s [-iInNv] -f [name]\n", __progname);
	fprintf(stderr, "       %s [-iInNv] [-u user]\n", __progname);
@


1.17
log
@Fix extern decl of version missed in previous commit.
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.16 2001/11/21 15:26:39 millert Exp $	*/
d16 1
a16 5
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
d43 1
a43 1
static const char rcsid[] = "$OpenBSD: main.c,v 1.16 2001/11/21 15:26:39 millert Exp $";
@


1.16
log
@o ANSIfy
o Style nits
o Use const to silent stupid -Wall warnings
o strnc{py,at} -> strlc{py,at}
o Use strpbrk() instead of homegrown anyof()
o Use NULL instead of #defines with 0 cast to a pointer
This still could use a proper audit
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.15 2001/11/20 20:50:00 millert Exp $	*/
d47 1
a47 1
static const char rcsid[] = "$OpenBSD: main.c,v 1.15 2001/11/20 20:50:00 millert Exp $";
d74 1
a74 1
	extern char *version;
@


1.15
log
@Major signal overhaul.  We no longer longjmp all over the place.
Instead, routines responsible to gathering user input (or in some
cases outputting data) catch the signals and set flags as needed.
Because of this some handlers are install without the SA_RESTART
flag so syscalls are not restarted and we can check the flag.  All
signal handlers are now safe.

This should make the flow of control a bit more grokable but the
code is still ugly.
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.14 2001/10/11 20:59:46 millert Exp $	*/
d38 1
a38 1
static char copyright[] =
d45 1
a45 1
static char sccsid[] = "@@(#)main.c	8.2 (Berkeley) 4/20/95";
d47 1
a47 1
static char rcsid[] = "$OpenBSD: main.c,v 1.14 2001/10/11 20:59:46 millert Exp $";
d56 2
a57 2
int	main __P((int, char **));
__dead void usage __P((void));
d66 1
a66 3
main(argc, argv)
	int argc;
	char *argv[];
d94 4
a97 4
	to = NIL;
	cc = NIL;
	bcc = NIL;
	smopts = NIL;
d201 1
a201 1
	if (to == NIL && (subject != NULL || cc != NIL || bcc != NIL))
d203 1
a203 1
	if (ef != NULL && to != NIL)
d267 1
a267 1
setscreensize()
d294 1
a294 1
usage()
@


1.14
log
@missing arg to errx
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.13 2001/09/07 01:19:15 millert Exp $	*/
d47 1
a47 1
static char rcsid[] = "$OpenBSD: main.c,v 1.13 2001/09/07 01:19:15 millert Exp $";
d57 1
a64 2
sigjmp_buf	hdrjmp;

a74 1
	sig_t prevint;
d76 1
d84 1
d191 3
a193 7
		case '?':
			fprintf(stderr, "\
Usage: %s [-iInv] [-s subject] [-c cc-addr] [-b bcc-addr] to-addr ...\n\
            [- sendmail-options ...]\n\
       %s [-iInNv] -f [name]\n\
       %s [-iInNv] [-u user]\n", __progname, __progname, __progname);
			exit(1);
d207 9
a245 2
	if (sigsetjmp(hdrjmp, 1) == 0) {
		extern char *version;
d247 5
a251 9
		if ((prevint = signal(SIGINT, SIG_IGN)) != SIG_IGN)
			(void)signal(SIGINT, hdrstop);
		if (value("quiet") == NULL)
			(void)printf("Mail version %s.  Type ? for help.\n",
				version);
		announce();
		(void)fflush(stdout);
		(void)signal(SIGINT, prevint);
	}
d253 3
a255 3
	(void)signal(SIGHUP, SIG_IGN);
	(void)signal(SIGINT, SIG_IGN);
	(void)signal(SIGQUIT, SIG_IGN);
a260 13
 * Interrupt printing of the headers.
 */
void
hdrstop(signo)
	int signo;
{

	fflush(stdout);
	fputs("\nInterrupt\n", stderr);
	siglongjmp(hdrjmp, 1);
}

/*
d293 13
@


1.13
log
@Sanity check length of -u argument to avoid truncation later on.
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.12 2000/06/30 16:00:19 millert Exp $	*/
d47 1
a47 1
static char rcsid[] = "$OpenBSD: main.c,v 1.12 2000/06/30 16:00:19 millert Exp $";
d118 1
a118 1
				errx(1, "username `%s' too long");
@


1.12
log
@warnx?/errx? paranoia (use "%s" not a bare string unless it is a
constant).  These are not security holes but it is worth fixing
them anyway both for robustness and so folks looking for examples
in the tree are not misled into doing something potentially dangerous.
Furthermore, it is a bad idea to assume that pathnames will not
include '%' in them and that error routines don't return strings
with '%' in them (especially in light of the possibility of locales).
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.11 1998/09/27 21:16:42 millert Exp $	*/
d47 1
a47 1
static char rcsid[] = "$OpenBSD: main.c,v 1.11 1998/09/27 21:16:42 millert Exp $";
d117 2
@


1.11
log
@Use new username option to lockspool for 'mail -u'.
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.10 1997/11/14 00:23:52 millert Exp $	*/
d47 1
a47 1
static char rcsid[] = "$OpenBSD: main.c,v 1.10 1997/11/14 00:23:52 millert Exp $";
d110 1
a110 1
				err(1, Tflag);
@


1.11.8.1
log
@Pull in patch from current (even more to come):
Fix (millert):
warnx?/errx? paranoia (use "%s" not a bare string unless it is a
constant).  These are not security holes but it is worth fixing
them anyway both for robustness and so folks looking for examples
in the tree are not misled into doing something potentially dangerous.
Furthermore, it is a bad idea to assume that pathnames will not
include '%' in them and that error routines don't return strings
with '%' in them (especially in light of the possibility of locales).
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.12 2000/06/30 16:00:19 millert Exp $	*/
d47 1
a47 1
static char rcsid[] = "$OpenBSD: main.c,v 1.12 2000/06/30 16:00:19 millert Exp $";
d110 1
a110 1
				err(1, "%s", Tflag);
@


1.10
log
@NetBSD changes (mostly comsmetic):
    replace panic() with calls to err()/errx()
    use S_IS* instead of doing by hand with S_IF*.
    Use TIMESPEC_TO_TIMEVAL() and gettimeofday instead of time(2)
    Use _POSIX_VDISABLE, not 0
    Kill register
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.9 1997/07/30 06:32:40 millert Exp $	*/
d47 1
a47 1
static char rcsid[] = "$OpenBSD: main.c,v 1.9 1997/07/30 06:32:40 millert Exp $";
d119 1
@


1.9
log
@Fix one possible oflow (not exploitable) and do a wee bit of KNF.
Much more remains to be done.
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.8 1997/07/14 15:56:24 millert Exp $	*/
d47 1
a47 1
static char rcsid[] = "$OpenBSD: main.c,v 1.8 1997/07/14 15:56:24 millert Exp $";
d56 2
d71 1
a71 1
	register int i;
@


1.8
log
@Convert remaining sigsetmask() -> sigprocmask() (POSIX style)
in collect.c and fix up some signal botches elsewhere.
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.7 1997/07/14 00:24:28 millert Exp $	*/
d47 1
a47 1
static char rcsid[] = "$OpenBSD: main.c,v 1.7 1997/07/14 00:24:28 millert Exp $";
d240 1
a240 1
			signal(SIGINT, hdrstop);
d242 1
a242 1
			printf("Mail version %s.  Type ? for help.\n",
d245 2
a246 2
		fflush(stdout);
		signal(SIGINT, prevint);
d249 3
a251 3
	signal(SIGHUP, SIG_IGN);
	signal(SIGINT, SIG_IGN);
	signal(SIGQUIT, SIG_IGN);
@


1.7
log
@NOSTR -> NULL
Use sigsetjmp/siglongjmp instead of sigjmp/longjmp for portability.
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.6 1997/07/13 23:54:00 millert Exp $	*/
d47 1
a47 1
static char rcsid[] = "$OpenBSD: main.c,v 1.6 1997/07/13 23:54:00 millert Exp $";
d290 1
a290 1
	if (ospeed < 1200)
d292 1
a292 1
	else if (ospeed == 1200)
@


1.6
log
@bcopy() -> memcpy() and fix some casts.
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.5 1997/07/13 21:21:15 millert Exp $	*/
d47 1
a47 1
static char rcsid[] = "$OpenBSD: main.c,v 1.5 1997/07/13 21:21:15 millert Exp $";
d62 1
a62 1
jmp_buf	hdrjmp;
d93 1
a93 1
	ef = NOSTR;
d98 1
a98 1
	subject = NOSTR;
d202 1
a202 1
	if (to == NIL && (subject != NOSTR || cc != NIL || bcc != NIL))
d204 1
a204 1
	if (ef != NOSTR && to != NIL)
d232 1
a232 1
	if (ef == NOSTR)
d236 1
a236 1
	if (setjmp(hdrjmp) == 0) {
d241 1
a241 1
		if (value("quiet") == NOSTR)
d266 1
a266 1
	longjmp(hdrjmp, 1);
@


1.5
log
@Merge in NetBSD and 4.4BSD-lite2 changes as well as some of my own.
 - handle long lines safely (from NetBSD)
 - use puts/fputs and putchar/putc when it makes sense
 - use err/errx and warn/warnx when it makes sense
 - make return() and sizeof() style consisten
 - some more buffer safety
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.4 1997/01/15 23:42:50 millert Exp $	*/
d47 1
a47 1
static char rcsid[] = "$OpenBSD: main.c,v 1.4 1997/01/15 23:42:50 millert Exp $";
d82 1
a82 1
	(void) signal(SIGCHLD, sigchild);
@


1.4
log
@getopt(3) returns -1 when out of args, not EOF, whee!
@
text
@d1 2
a2 2
/*	$OpenBSD: main.c,v 1.3 1996/09/16 02:26:09 deraadt Exp $	*/
/*	$NetBSD: main.c,v 1.5 1996/06/08 19:48:31 christos Exp $	*/
d45 1
a45 1
static char sccsid[] = "@@(#)main.c	8.1 (Berkeley) 6/6/93";
d47 1
a47 1
static char rcsid[] = "$OpenBSD: main.c,v 1.3 1996/09/16 02:26:09 deraadt Exp $";
d75 1
d107 3
a109 5
			if ((i = creat(Tflag, 0600)) < 0) {
				perror(Tflag);
				exit(1);
			}
			close(i);
d187 2
a188 2
			fputs("\
Usage: mail [-iInv] [-s subject] [-c cc-addr] [-b bcc-addr] to-addr ...\n\
d190 2
a191 3
       mail [-iInNv] -f [name]\n\
       mail [-iInNv] [-u user]\n",
				stderr);
d202 4
a205 8
	if (to == NIL && (subject != NOSTR || cc != NIL || bcc != NIL)) {
		fputs("You must specify direct recipients with -s, -c, or -b.\n", stderr);
		exit(1);
	}
	if (ef != NOSTR && to != NIL) {
		fprintf(stderr, "Cannot give -f and people to send to.\n");
		exit(1);
	}
d217 3
a219 1
	load(expand("~/.mailrc"));
d265 1
a265 1
	fprintf(stderr, "\nInterrupt\n");
@


1.3
log
@_PATH_TMP -> _PATH_TMPFILE; avoid /tmp//fooXXXX where possible too
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.2 1996/06/11 12:53:45 deraadt Exp $	*/
d47 1
a47 1
static char rcsid[] = "$OpenBSD: main.c,v 1.2 1996/06/11 12:53:45 deraadt Exp $";
d98 1
a98 1
	while ((i = getopt(argc, argv, "INT:b:c:dfins:u:v")) != EOF) {
@


1.2
log
@from christos;
- Fix PR/105: Implement dot locking protocol and check return value of flock.
- Fix PR/2247: Don't call unknown users "ubluit". Issue an error message.
- Fix/add prototypes.
- Fix warnings.
- Use POSIX signal mask calls.
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.5 1996/06/08 19:48:31 christos Exp $	*/
d47 1
a47 1
static char rcsid[] = "$OpenBSD: main.c,v 1.5 1996/06/08 19:48:31 christos Exp $";
d116 1
@


1.1
log
@Initial revision
@
text
@d1 3
d44 5
a48 2
static char sccsid[] = "from: @@(#)main.c	8.1 (Berkeley) 6/6/93";
static char rcsid[] = "$Id: main.c,v 1.4 1995/05/02 01:40:16 mycroft Exp $";
d53 1
a73 1
	void hdrstop();
a74 1
	void sigchild();
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@
