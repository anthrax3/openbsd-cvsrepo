head	1.28;
access;
symbols
	OPENBSD_6_2_BASE:1.28
	OPENBSD_6_1:1.28.0.12
	OPENBSD_6_1_BASE:1.28
	OPENBSD_6_0:1.28.0.8
	OPENBSD_6_0_BASE:1.28
	OPENBSD_5_9:1.28.0.4
	OPENBSD_5_9_BASE:1.28
	OPENBSD_5_8:1.28.0.6
	OPENBSD_5_8_BASE:1.28
	OPENBSD_5_7:1.28.0.2
	OPENBSD_5_7_BASE:1.28
	OPENBSD_5_6:1.27.0.22
	OPENBSD_5_6_BASE:1.27
	OPENBSD_5_5:1.27.0.20
	OPENBSD_5_5_BASE:1.27
	OPENBSD_5_4:1.27.0.16
	OPENBSD_5_4_BASE:1.27
	OPENBSD_5_3:1.27.0.14
	OPENBSD_5_3_BASE:1.27
	OPENBSD_5_2:1.27.0.12
	OPENBSD_5_2_BASE:1.27
	OPENBSD_5_1_BASE:1.27
	OPENBSD_5_1:1.27.0.10
	OPENBSD_5_0:1.27.0.8
	OPENBSD_5_0_BASE:1.27
	OPENBSD_4_9:1.27.0.6
	OPENBSD_4_9_BASE:1.27
	OPENBSD_4_8:1.27.0.4
	OPENBSD_4_8_BASE:1.27
	OPENBSD_4_7:1.27.0.2
	OPENBSD_4_7_BASE:1.27
	OPENBSD_4_6:1.26.0.8
	OPENBSD_4_6_BASE:1.26
	OPENBSD_4_5:1.26.0.4
	OPENBSD_4_5_BASE:1.26
	OPENBSD_4_4:1.26.0.2
	OPENBSD_4_4_BASE:1.26
	OPENBSD_4_3:1.25.0.8
	OPENBSD_4_3_BASE:1.25
	OPENBSD_4_2:1.25.0.6
	OPENBSD_4_2_BASE:1.25
	OPENBSD_4_1:1.25.0.4
	OPENBSD_4_1_BASE:1.25
	OPENBSD_4_0:1.25.0.2
	OPENBSD_4_0_BASE:1.25
	OPENBSD_3_9:1.24.0.2
	OPENBSD_3_9_BASE:1.24
	OPENBSD_3_8:1.23.0.4
	OPENBSD_3_8_BASE:1.23
	OPENBSD_3_7:1.23.0.2
	OPENBSD_3_7_BASE:1.23
	OPENBSD_3_6:1.22.0.2
	OPENBSD_3_6_BASE:1.22
	OPENBSD_3_5:1.21.0.4
	OPENBSD_3_5_BASE:1.21
	OPENBSD_3_4:1.21.0.2
	OPENBSD_3_4_BASE:1.21
	OPENBSD_3_3:1.20.0.6
	OPENBSD_3_3_BASE:1.20
	OPENBSD_3_2:1.20.0.4
	OPENBSD_3_2_BASE:1.20
	OPENBSD_3_1:1.20.0.2
	OPENBSD_3_1_BASE:1.20
	OPENBSD_3_0:1.16.0.4
	OPENBSD_3_0_BASE:1.16
	OPENBSD_2_9_BASE:1.16
	OPENBSD_2_9:1.16.0.2
	OPENBSD_2_8:1.15.0.2
	OPENBSD_2_8_BASE:1.15
	OPENBSD_2_7:1.14.0.2
	OPENBSD_2_7_BASE:1.14
	OPENBSD_2_6:1.12.0.8
	OPENBSD_2_6_BASE:1.12
	OPENBSD_2_5:1.12.0.6
	OPENBSD_2_5_BASE:1.12
	OPENBSD_2_4:1.12.0.4
	OPENBSD_2_4_BASE:1.12
	OPENBSD_2_3:1.12.0.2
	OPENBSD_2_3_BASE:1.12
	OPENBSD_2_2:1.11.0.2
	OPENBSD_2_2_BASE:1.11
	OPENBSD_2_1:1.4.0.2
	OPENBSD_2_1_BASE:1.4
	OPENBSD_2_0:1.3.0.2
	OPENBSD_2_0_BASE:1.3
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.28
date	2015.01.20.16.59.07;	author millert;	state Exp;
branches;
next	1.27;
commitid	92usC3cTTCZG2qZC;

1.27
date	2009.07.28.16.05.04;	author martynas;	state Exp;
branches;
next	1.26;

1.26
date	2008.07.15.19.23.26;	author martynas;	state Exp;
branches;
next	1.25;

1.25
date	2006.05.02.05.28.07;	author hugh;	state Exp;
branches;
next	1.24;

1.24
date	2006.01.06.18.53.06;	author millert;	state Exp;
branches;
next	1.23;

1.23
date	2004.09.15.22.21.40;	author deraadt;	state Exp;
branches;
next	1.22;

1.22
date	2004.05.10.12.10.50;	author millert;	state Exp;
branches;
next	1.21;

1.21
date	2003.06.03.02.56.11;	author millert;	state Exp;
branches;
next	1.20;

1.20
date	2001.11.28.01.26.35;	author millert;	state Exp;
branches;
next	1.19;

1.19
date	2001.11.21.15.26.39;	author millert;	state Exp;
branches;
next	1.18;

1.18
date	2001.11.20.20.50.00;	author millert;	state Exp;
branches;
next	1.17;

1.17
date	2001.11.16.17.10.06;	author millert;	state Exp;
branches;
next	1.16;

1.16
date	2001.01.16.05.36.08;	author millert;	state Exp;
branches;
next	1.15;

1.15
date	2000.08.23.21.24.08;	author mickey;	state Exp;
branches;
next	1.14;

1.14
date	2000.04.26.15.47.31;	author millert;	state Exp;
branches;
next	1.13;

1.13
date	2000.04.25.16.42.22;	author millert;	state Exp;
branches;
next	1.12;

1.12
date	97.11.14.00.23.46;	author millert;	state Exp;
branches;
next	1.11;

1.11
date	97.07.30.07.19.30;	author millert;	state Exp;
branches;
next	1.10;

1.10
date	97.07.30.06.32.39;	author millert;	state Exp;
branches;
next	1.9;

1.9
date	97.07.24.17.27.10;	author millert;	state Exp;
branches;
next	1.8;

1.8
date	97.07.24.16.23.36;	author millert;	state Exp;
branches;
next	1.7;

1.7
date	97.07.22.18.54.38;	author millert;	state Exp;
branches;
next	1.6;

1.6
date	97.07.13.21.21.12;	author millert;	state Exp;
branches;
next	1.5;

1.5
date	97.05.30.08.51.37;	author deraadt;	state Exp;
branches;
next	1.4;

1.4
date	97.03.29.03.01.45;	author millert;	state Exp;
branches;
next	1.3;

1.3
date	96.06.11.12.53.39;	author deraadt;	state Exp;
branches;
next	1.2;

1.2
date	96.03.27.19.32.32;	author niklas;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.45.38;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.45.38;	author deraadt;	state Exp;
branches;
next	;


desc
@@


1.28
log
@Add support for the "-r fromaddr" flag now that we don't support
sendmail flags on the command line.
Also allow "from" to be set in mailrc.
Use sendmail's "-t" flag when executing sendmail instead of specifying
the list of recipients in argv.  The "-f" flag will be used to set
the from address if specified.
@
text
@/*	$OpenBSD: extern.h,v 1.27 2009/07/28 16:05:04 martynas Exp $	*/
/*	$NetBSD: extern.h,v 1.7 1997/07/09 05:22:00 mikel Exp $	*/

/*-
 * Copyright (c) 1992, 1993
 *	The Regents of the University of California.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 *	@@(#)extern.h	8.2 (Berkeley) 4/20/95
 *	$OpenBSD: extern.h,v 1.27 2009/07/28 16:05:04 martynas Exp $
 */

struct name;
struct name *cat(struct name *, struct name *);
struct name *delname(struct name *, char *);
struct name *elide(struct name *);
struct name *extract(char *, int);
struct grouphead;
struct name *gexpand(struct name *, struct grouphead *, int, int);
struct name *nalloc(char *, int);
struct header;
struct name *outof(struct name *, FILE *, struct header *);
struct name *put(struct name *, struct name *);
struct name *tailof(struct name *);
struct name *usermap(struct name *);
FILE	*Fdopen(int, char *);
FILE	*Fopen(char *, char *);
FILE	*Popen(char *, char *);
FILE	*collect(struct header *, int);
char	*copy(char *, char *);
char	*copyin(char *, char **);
char	*detract(struct name *, int);
char	*expand(char *);
char	*getdeadletter(void);
char	*getname(uid_t);
struct message;
char	*hfield(char *, struct message *);
FILE	*infix(struct header *, FILE *);
char	*ishfield(char *, char *, char *);
char	*name1(struct message *, int);
char	*nameof(struct message *, int);
char	*nextword(char *, char *);
char	*readtty(char *, char *);
char 	*reedit(char *);
FILE	*run_editor(FILE *, off_t, int, int);
char	*salloc(int);
char	*savestr(char *);
FILE	*setinput(struct message *);
char	*skin(char *);
char	*skip_comment(char *);
char	*snarf(char *, int *);
char	*username(void);
char	*value(char *);
char	*vcopy(char *);
char	*yankword(char *, char *);
int	 Fclose(FILE *);
int	 More(void *);
int	 Pclose(FILE *);
int	 Respond(void *);
int	 Type(void *);
int	 _Respond(int *);
int	 _respond(int *);
void	 alter(char *);
int	 alternates(void *);
void	 announce(void);
int	 append(struct message *, FILE *);
int	 argcount(char **);
void	 assign(char *, char *);
int	 bangexp(char *, size_t);
int	 blankline(char *);
int	 charcount(char *, int);
int	 check(int, int);
void	 clearnew(void);
void	 close_all_files(void);
int	 cmatch(char *, char *);
int	 collabort(void);
void	 commands(void);
int	 copycmd(void *);
int	 count(struct name *);
int	 deletecmd(void *);
int	 delm(int *);
int	 deltype(void *);
void	 demail(void);
void	 dointr(void);
int	 dosh(void *);
int	 echo(void *);
int	 edit1(int *, int);
int	 editor(void *);
int	 edstop(void);
int	 elsecmd(void *);
int	 endifcmd(void *);
int	 evalcol(int);
int	 execute(char *, int);
int	 exwrite(char *, FILE *, int);
void	 fail(char *, char *);
int	 file(void *);
struct grouphead *
	 findgroup(char *);
void	 findmail(char *, char *, int);
void	 fioint(int);
int	 first(int, int);
void	 fixhead(struct header *, struct name *);
void	 fmt(char *, struct name *, FILE *, int);
int	 folders(void *);
int	 forward(char *, FILE *, char *, int);
void	 free_child(pid_t);
int	 from(void *);
off_t	 fsize(FILE *);
int	 getfold(char *, int);
int	 gethfield(FILE *, char *, int, char **);
int	 gethfromtty(struct header *, int);
int	 getmsglist(char *, int *, int);
int	 getrawlist(char *, char **, int);
uid_t	 getuserid(char *);
int	 grabh(struct header *, int);
int	 group(void *);
int	 hash(char *);
void	 hdrint(int);
int	 headers(void *);
int	 help(void *);
void	 holdsigs(void);
int	 ifcmd(void *);
int	 igfield(void *);
struct ignoretab;
int	 ignore1(char **, struct ignoretab *, char *);
int	 ignoresig(int, struct sigaction *, sigset_t *);
int	 igshow(struct ignoretab *, char *);
void	 intr(int);
int	 inc(void *);
int	 incfile(void);
int	 isdate(char *);
int	 isdir(char *);
int	 isfileaddr(char *);
int	 ishead(char *);
int	 isign(char *, struct ignoretab *);
int	 isprefix(char *, char *);
size_t	 istrlcpy(char *, const char *, size_t);
const struct cmd *
	 lex(char *);
void	 load(char *);
struct var *
	 lookup(char *);
int	 mail(struct name *, struct name *, struct name *, struct name *,
	       char *, char *);
void	 mail1(struct header *, int);
void	 makemessage(FILE *, int);
void	 mark(int);
int	 markall(char *, int);
int	 marknew(void *);
int	 matchsender(char *, int);
int	 matchsubj(char *, int);
int	 mboxit(void *);
int	 member(char *, struct ignoretab *);
void	 mesedit(FILE *, int);
void	 mespipe(FILE *, char *);
int	 messize(void *);
int	 metamess(int, int);
int	 more(void *);
int	 newfileinfo(int);
int	 next(void *);
int	 null(void *);
struct headline;
void	 parse(char *, struct headline *, char *);
int	 pcmdlist(void *);
int	 pdot(void *);
int	 pipeit(void *, void *);
void	 prepare_child(sigset_t *, int, int);
int	 preserve(void *);
void	 prettyprint(struct name *);
void	 printgroup(char *);
void	 printhead(int);
int	 puthead(struct header *, FILE *, int);
int	 putline(FILE *, char *, int);
int	 pversion(void *);
int	 quit(void);
int	 quitcmd(void *);
int	 readline(FILE *, char *, int, int *);
void	 register_file(FILE *, int, pid_t);
void	 regret(int);
void	 relsesigs(void);
int	 respond(void *);
int	 retfield(void *);
int	 rexit(void *);
int	 rm(char *);
int	 run_command(char *cmd, sigset_t *nset, int infd, int outfd, ...);
int	 save(void *);
int	 save1(char *, int, char *, struct ignoretab *);
void	 savedeadletter(FILE *);
int	 saveigfield(void *);
int	 savemail(char *, FILE *);
int	 saveretfield(void *);
int	 scan(char **);
void	 scaninit(void);
int	 schdir(void *);
int	 screensize(void);
int	 scroll(void *);
void	 sendint(int);
int	 sendmessage(struct message *, FILE *, struct ignoretab *, char *);
int	 sendmail(void *);
int	 set(void *);
int	 setfile(char *);
void	 setmsize(int);
void	 setptr(FILE *, off_t);
void	 setscreensize(void);
int	 shell(void *);
void	 sigchild(int);
void	 sort(char **);
int	 source(void *);
int	 spool_lock(void);
int	 spool_unlock(void);
void	 spreserve(void);
void	 sreset(void);
pid_t	 start_command(char *cmd, sigset_t *nset, int infd, int outfd, ...);
pid_t	 start_commandv(char *, sigset_t *, int, int, __va_list);
int	 statusput(struct message *, FILE *, char *);
void	 stop(int);
int	 stouch(void *);
int	 swrite(void *);
void	 tinit(void);
int	 top(void *);
void	 touch(struct message *);
void	 ttyint(int);
void	 ttystop(int);
int	 type(void *);
int	 type1(int *, char *, int, int);
int	 undeletecmd(void *);
void	 unmark(int);
char	**unpack(struct name *, struct name *);
int	 unread(void *);
void	 unregister_file(FILE *);
int	 unset(void *);
int	 unstack(void);
void	 vfree(char *);
int	 visual(void *);
int	 wait_child(pid_t);
int	 wait_command(int);
int	 writeback(FILE *);

extern char *__progname;
extern char *tmpdir;
extern const struct cmd *com; /* command we are running */
@


1.27
log
@remove core / tilde C.  it's useless, doesn't work, never has been
documented, ^\ should be used instead.  ok millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: extern.h,v 1.26 2008/07/15 19:23:26 martynas Exp $	*/
d33 1
a33 1
 *	$OpenBSD: extern.h,v 1.26 2008/07/15 19:23:26 martynas Exp $
d166 2
a167 2
int	 mail (struct name *, struct name *, struct name *, struct name *,
	       char *);
@


1.26
log
@- chraise can be replaced with toupper;  no need to check for islower
- remove quite some code, use strcasestr instead of reimplementing
it each time
- use strncasecmp, instead of comparing through each character
"looks fine" millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: extern.h,v 1.25 2006/05/02 05:28:07 hugh Exp $	*/
d33 1
a33 1
 *	$OpenBSD: extern.h,v 1.25 2006/05/02 05:28:07 hugh Exp $
a101 1
int	 core(void *);
@


1.25
log
@Nuke a couple orphaned prototypes.
quoth deraadt: no problem
@
text
@d1 1
a1 1
/*	$OpenBSD: extern.h,v 1.24 2006/01/06 18:53:06 millert Exp $	*/
d33 1
a33 1
 *	$OpenBSD: extern.h,v 1.24 2006/01/06 18:53:06 millert Exp $
a200 1
int	 chraise(int);
@


1.24
log
@Adapt things to use __type_t instead of _BSD_TYPE_T_
Add new sys/_types.h header
Include machine/_types.h or sys/_types.h where applicable
@
text
@d1 1
a1 1
/*	$OpenBSD: extern.h,v 1.23 2004/09/15 22:21:40 deraadt Exp $	*/
d33 1
a33 1
 *	$OpenBSD: extern.h,v 1.23 2004/09/15 22:21:40 deraadt Exp $
a109 2
int	 dot_lock(const char *, int, FILE *, const char *);
void	 dot_unlock(const char *);
@


1.23
log
@avoid aliasing against libc symbols
@
text
@d1 1
a1 1
/*	$OpenBSD: extern.h,v 1.22 2004/05/10 12:10:50 millert Exp $	*/
d33 1
a33 1
 *	$OpenBSD: extern.h,v 1.22 2004/05/10 12:10:50 millert Exp $
d241 1
a241 1
pid_t	 start_commandv(char *, sigset_t *, int, int, _BSD_VA_LIST_);
@


1.22
log
@Get rid of the ancient "clobber" command.  It was really only for debugging
purposes.  Noticed and OK by deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: extern.h,v 1.21 2003/06/03 02:56:11 millert Exp $	*/
d33 1
a33 1
 *	$OpenBSD: extern.h,v 1.21 2003/06/03 02:56:11 millert Exp $
d104 1
a104 1
int	 delete(void *);
d203 1
a203 1
int	 raise(int);
@


1.21
log
@Remove the advertising clause in the UCB license which Berkeley
rescinded 22 July 1999.  Proofed by myself and Theo.
@
text
@d1 1
a1 1
/*	$OpenBSD: extern.h,v 1.20 2001/11/28 01:26:35 millert Exp $	*/
d33 1
a33 1
 *	$OpenBSD: extern.h,v 1.20 2001/11/28 01:26:35 millert Exp $
a96 2
void	 clob1(int);
int	 clobber(void *);
@


1.20
log
@Catch SIGINT in sendmessage() so user can interupt a long message
that is being output.

Make statusput() return an int and return -1 if ferror()
@
text
@d1 1
a1 1
/*	$OpenBSD: extern.h,v 1.19 2001/11/21 15:26:39 millert Exp $	*/
d16 1
a16 5
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
d33 1
a33 1
 *	$OpenBSD: extern.h,v 1.19 2001/11/21 15:26:39 millert Exp $
@


1.19
log
@o ANSIfy
o Style nits
o Use const to silent stupid -Wall warnings
o strnc{py,at} -> strlc{py,at}
o Use strpbrk() instead of homegrown anyof()
o Use NULL instead of #defines with 0 cast to a pointer
This still could use a proper audit
@
text
@d1 1
a1 1
/*	$OpenBSD: extern.h,v 1.18 2001/11/20 20:50:00 millert Exp $	*/
d37 1
a37 1
 *	$OpenBSD: extern.h,v 1.18 2001/11/20 20:50:00 millert Exp $
d230 1
d248 1
a248 1
void	 statusput(struct message *, FILE *, char *);
@


1.18
log
@Major signal overhaul.  We no longer longjmp all over the place.
Instead, routines responsible to gathering user input (or in some
cases outputting data) catch the signals and set flags as needed.
Because of this some handlers are install without the SA_RESTART
flag so syscalls are not restarted and we can check the flag.  All
signal handlers are now safe.

This should make the flow of control a bit more grokable but the
code is still ugly.
@
text
@d1 1
a1 1
/*	$OpenBSD: extern.h,v 1.17 2001/11/16 17:10:06 millert Exp $	*/
d37 1
a37 1
 *	$OpenBSD: extern.h,v 1.17 2001/11/16 17:10:06 millert Exp $
d41 4
a44 4
struct name *cat __P((struct name *, struct name *));
struct name *delname __P((struct name *, char []));
struct name *elide __P((struct name *));
struct name *extract __P((char [], int));
d46 2
a47 2
struct name *gexpand __P((struct name *, struct grouphead *, int, int));
struct name *nalloc __P((char [], int));
d49 14
a62 14
struct name *outof __P((struct name *, FILE *, struct header *));
struct name *put __P((struct name *, struct name *));
struct name *tailof __P((struct name *));
struct name *usermap __P((struct name *));
FILE	*Fdopen __P((int, char *));
FILE	*Fopen __P((char *, char *));
FILE	*Popen __P((char *, char *));
FILE	*collect __P((struct header *, int));
char	*copy __P((char *, char *));
char	*copyin __P((char *, char **));
char	*detract __P((struct name *, int));
char	*expand __P((char *));
char	*getdeadletter __P((void));
char	*getname __P((int));
d64 65
a128 66
char	*hfield __P((char [], struct message *));
FILE	*infix __P((struct header *, FILE *));
char	*ishfield __P((char [], char[], char *));
char	*name1 __P((struct message *, int));
char	*nameof __P((struct message *, int));
char	*nextword __P((char *, char *));
char	*readtty __P((char [], char []));
char 	*reedit __P((char *));
FILE	*run_editor __P((FILE *, off_t, int, int));
char	*salloc __P((int));
char	*savestr __P((char *));
FILE	*setinput __P((struct message *));
char	*skin __P((char *));
char	*skip_comment __P((char *));
char	*snarf __P((char [], int *));
char	*username __P((void));
char	*value __P((char []));
char	*vcopy __P((char []));
char	*yankword __P((char *, char []));
int	 Fclose __P((FILE *));
int	 More __P((void *));
int	 Pclose __P((FILE *));
int	 Respond __P((void *));
int	 Type __P((void *));
int	 _Respond __P((int []));
int	 _respond __P((int *));
void	 alter __P((char *));
int	 alternates __P((void *));
void	 announce __P((void));
int	 anyof __P((char *, char *));
int	 append __P((struct message *, FILE *));
int	 argcount __P((char **));
void	 assign __P((char [], char []));
int	 bangexp __P((char *, size_t));
int	 blankline __P((char []));
int	 charcount __P((char *, int));
int	 check __P((int, int));
void	 clearnew __P((void));
void	 clob1 __P((int));
int	 clobber __P((void *));
void	 close_all_files __P((void));
int	 cmatch __P((char *, char *));
int	 collabort __P((void));
void	 commands __P((void));
int	 copycmd __P((void *));
int	 core __P((void *));
int	 count __P((struct name *));
int	 delete __P((void *));
int	 delm __P((int []));
int	 deltype __P((void *));
void	 demail __P((void));
void	 dointr __P((void));
int	 dosh __P((void *));
int	 dot_lock __P((const char *, int, FILE *, const char *));
void	 dot_unlock __P((const char *));
int	 echo __P((void *));
int	 edit1 __P((int *, int));
int	 editor __P((void *));
int	 edstop __P((void));
int	 elsecmd __P((void *));
int	 endifcmd __P((void *));
int	 evalcol __P((int));
int	 execute __P((char [], int));
int	 exwrite __P((char [], FILE *, int));
void	 fail __P((char [], char []));
int	 file __P((void *));
d130 26
a155 26
	 findgroup __P((char []));
void	 findmail __P((char *, char *, int));
void	 fioint __P((int));
int	 first __P((int, int));
void	 fixhead __P((struct header *, struct name *));
void	 fmt __P((char *, struct name *, FILE *, int));
int	 folders __P((void *));
int	 forward __P((char [], FILE *, char *, int));
void	 free_child __P((int));
int	 from __P((void *));
off_t	 fsize __P((FILE *));
int	 getfold __P((char *, int));
int	 gethfield __P((FILE *, char [], int, char **));
int	 gethfromtty __P((struct header *, int));
int	 getmsglist __P((char *, int *, int));
int	 getrawlist __P((char [], char **, int));
int	 getuserid __P((char []));
int	 grabh __P((struct header *, int));
int	 group __P((void *));
int	 hash __P((char *));
void	 hdrint __P((int));
int	 headers __P((void *));
int	 help __P((void *));
void	 holdsigs __P((void));
int	 ifcmd __P((void *));
int	 igfield __P((void *));
d157 13
a169 13
int	 ignore1 __P((char *[], struct ignoretab *, char *));
int	 ignoresig __P((int, struct sigaction *, sigset_t *));
int	 igshow __P((struct ignoretab *, char *));
void	 intr __P((int));
int	 inc __P((void *));
int	 incfile __P((void));
int	 isdate __P((char []));
int	 isdir __P((char []));
int	 isfileaddr __P((char *));
int	 ishead __P((char []));
int	 isign __P((char *, struct ignoretab []));
int	 isprefix __P((char *, char *));
void	 istrncpy __P((char *, char *, size_t));
d171 2
a172 2
	 lex __P((char []));
void	 load __P((char *));
d174 20
a193 20
	 lookup __P((char []));
int	 mail __P((struct name *,
	    struct name *, struct name *, struct name *, char *));
void	 mail1 __P((struct header *, int));
void	 makemessage __P((FILE *, int));
void	 mark __P((int));
int	 markall __P((char [], int));
int	 marknew __P((void *));
int	 matchsender __P((char *, int));
int	 matchsubj __P((char *, int));
int	 mboxit __P((void *));
int	 member __P((char *, struct ignoretab *));
void	 mesedit __P((FILE *, int));
void	 mespipe __P((FILE *, char []));
int	 messize __P((void *));
int	 metamess __P((int, int));
int	 more __P((void *));
int	 newfileinfo __P((int));
int	 next __P((void *));
int	 null __P((void *));
d195 75
a269 75
void	 parse __P((char [], struct headline *, char []));
int	 pcmdlist __P((void *));
int	 pdot __P((void *));
int	 pipeit __P((void *, void *));
void	 prepare_child __P((sigset_t *, int, int));
int	 preserve __P((void *));
void	 prettyprint __P((struct name *));
void	 printgroup __P((char []));
void	 printhead __P((int));
int	 puthead __P((struct header *, FILE *, int));
int	 putline __P((FILE *, char *, int));
int	 pversion __P((void *));
int	 quit __P((void));
int	 quitcmd __P((void *));
int	 raise __P((int));
int	 readline __P((FILE *, char *, int, int *));
void	 register_file __P((FILE *, int, int));
void	 regret __P((int));
void	 relsesigs __P((void));
int	 respond __P((void *));
int	 retfield __P((void *));
int	 rexit __P((void *));
int	 rm __P((char *));
int	 run_command __P((char *cmd, sigset_t *nset, int infd, int outfd, ...));
int	 save __P((void *));
int	 save1 __P((char [], int, char *, struct ignoretab *));
void	 savedeadletter __P((FILE *));
int	 saveigfield __P((void *));
int	 savemail __P((char [], FILE *));
int	 saveretfield __P((void *));
int	 scan __P((char **));
void	 scaninit __P((void));
int	 schdir __P((void *));
int	 screensize __P((void));
int	 scroll __P((void *));
int	 sendmessage __P((struct message *, FILE *, struct ignoretab *, char *));
int	 sendmail __P((void *));
int	 set __P((void *));
int	 setfile __P((char *));
void	 setmsize __P((int));
void	 setptr __P((FILE *, off_t));
void	 setscreensize __P((void));
int	 shell __P((void *));
void	 sigchild __P((int));
void	 sort __P((char **));
int	 source __P((void *));
int	 spool_lock __P((void));
int	 spool_unlock __P((void));
void	 spreserve __P((void));
void	 sreset __P((void));
int	 start_command __P((char *cmd, sigset_t *nset, int infd, int outfd, ...));
int	 start_commandv __P((char *, sigset_t *, int, int, _BSD_VA_LIST_));
void	 statusput __P((struct message *, FILE *, char *));
void	 stop __P((int));
int	 stouch __P((void *));
int	 swrite __P((void *));
void	 tinit __P((void));
int	 top __P((void *));
void	 touch __P((struct message *));
void	 ttyint __P((int));
void	 ttystop __P((int));
int	 type __P((void *));
int	 type1 __P((int *, char *, int, int));
int	 undeletecmd __P((void *));
void	 unmark __P((int));
char	**unpack __P((struct name *, struct name *));
int	 unread __P((void *));
void	 unregister_file __P((FILE *));
int	 unset __P((void *));
int	 unstack __P((void));
void	 vfree __P((char *));
int	 visual __P((void *));
int	 wait_child __P((int));
int	 wait_command __P((int));
int	 writeback __P((FILE *));
@


1.17
log
@Instead of using a longjmp to catch SIGPIPE, just set to SIG_IGN and
check the return value on writes for error.

Save and restore terminal modes when piping to a command so we end
up with a known good state if the command terminates uncleanly.
@
text
@d1 1
a1 1
/*	$OpenBSD: extern.h,v 1.16 2001/01/16 05:36:08 millert Exp $	*/
d37 1
a37 1
 *	$OpenBSD: extern.h,v 1.16 2001/01/16 05:36:08 millert Exp $
d106 1
a106 3
void	 collhup __P((int));
void	 collint __P((int));
void	 collstop __P((int));
d115 1
d122 1
a122 1
void	 edstop __P((void));
d133 1
d144 1
a144 1
void	 gethfromtty __P((struct header *, int));
a149 1
void	 hangup __P((int));
d151 1
a151 1
void	 hdrstop __P((int));
d159 1
d208 1
a208 1
void	 quit __P((void));
d211 1
a211 1
int	 readline __P((FILE *, char *, int));
@


1.16
log
@Changes from Don Beusee:
o escape From line with a leading '>' when needed
o only print To: address and Subject lines if actually present
o new variable 'allnet' to treat user@@foo and user@@bar as the same "user"
o folders command now takes an optional argument like ls.
o new "pipe" (|) command to pipe the message through an arbitrary command
o make header display format the same as SunOS 4.1.3 /usr/ucb/mail
o tilde commands work regardless of interactive mode.
o fix "read: Interrupted system call" error by retrying if EINTR
o expanded help file
Changes by me:
o read the help file via the PAGER as it is now more than 24 lines long
@
text
@d1 1
a1 1
/*	$OpenBSD: extern.h,v 1.15 2000/08/23 21:24:08 mickey Exp $	*/
d37 1
a37 1
 *	$OpenBSD: extern.h,v 1.15 2000/08/23 21:24:08 mickey Exp $
a98 1
void	 brokpipe __P((int));
@


1.15
log
@repair sendmail options handling
@
text
@d1 1
a1 1
/*	$OpenBSD: extern.h,v 1.14 2000/04/26 15:47:31 millert Exp $	*/
d37 1
a37 1
 *	$OpenBSD: extern.h,v 1.14 2000/04/26 15:47:31 millert Exp $
d183 1
d200 1
d220 1
a220 1
int	 run_command __P((char *, sigset_t *, int, int, char *, char *, char *));
d247 2
a248 1
int	 start_command __P((char *, sigset_t *, int, int, char *, char *, char *));
d259 1
a259 1
int	 type1 __P((int *, int, int));
d275 1
@


1.14
log
@Change the name of mail's send() function to sendmessages() to
avoid shadowing the libc send(2); gadams@@avernus.com
@
text
@d1 1
a1 1
/*	$OpenBSD: extern.h,v 1.13 2000/04/25 16:42:22 millert Exp $	*/
d37 1
a37 1
 *	$OpenBSD: extern.h,v 1.13 2000/04/25 16:42:22 millert Exp $
d259 1
a259 1
char	**unpack __P((struct name *));
@


1.13
log
@When incorporating new messages, clear the "new" count before the
inc so the count of new messages is useful afterwards.  This makes
mail behave more like the SunOS version in this respect.
@
text
@d1 1
a1 1
/*	$OpenBSD: extern.h,v 1.12 1997/11/14 00:23:46 millert Exp $	*/
d37 1
a37 1
 *	$OpenBSD: extern.h,v 1.12 1997/11/14 00:23:46 millert Exp $
d230 1
a230 1
int	 send __P((struct message *, FILE *, struct ignoretab *, char *));
@


1.12
log
@NetBSD changes (mostly comsmetic):
    replace panic() with calls to err()/errx()
    use S_IS* instead of doing by hand with S_IF*.
    Use TIMESPEC_TO_TIMEVAL() and gettimeofday instead of time(2)
    Use _POSIX_VDISABLE, not 0
    Kill register
@
text
@d1 1
a1 1
/*	$OpenBSD: extern.h,v 1.11 1997/07/30 07:19:30 millert Exp $	*/
d37 1
a37 1
 *	$OpenBSD: extern.h,v 1.11 1997/07/30 07:19:30 millert Exp $
d102 1
@


1.11
log
@Make istrcpy() take a size (not length) field, now called istrncpy().
Change some strcpy() -> strncpy() out of paranoia.
@
text
@d1 1
a1 1
/*	$OpenBSD: extern.h,v 1.10 1997/07/30 06:32:39 millert Exp $	*/
d37 1
a37 1
 *	$OpenBSD: extern.h,v 1.10 1997/07/30 06:32:39 millert Exp $
a193 2
void	 panic __P((const char *, ...))
    __attribute__((__format__(__printf__,1,2),__noreturn__));
@


1.10
log
@Fix one possible oflow (not exploitable) and do a wee bit of KNF.
Much more remains to be done.
@
text
@d1 1
a1 1
/*	$OpenBSD: extern.h,v 1.9 1997/07/24 17:27:10 millert Exp $	*/
d37 1
a37 1
 *	$OpenBSD: extern.h,v 1.9 1997/07/24 17:27:10 millert Exp $
d170 1
a170 1
void	 istrcpy __P((char *, char *));
@


1.9
log
@tempnam(3) goes bye bye.
@
text
@d1 1
a1 1
/*	$OpenBSD: extern.h,v 1.8 1997/07/24 16:23:36 millert Exp $	*/
d37 1
a37 1
 *	$OpenBSD: extern.h,v 1.8 1997/07/24 16:23:36 millert Exp $
d97 1
a97 1
int	 bangexp __P((char *));
@


1.8
log
@Replace 3 tempnam()'s with mkstemp.  The two left look tricky.
@
text
@d1 1
a1 1
/*	$OpenBSD: extern.h,v 1.7 1997/07/22 18:54:38 millert Exp $	*/
d37 1
a37 1
 *	$OpenBSD: extern.h,v 1.7 1997/07/22 18:54:38 millert Exp $
d138 1
a138 1
int	 forward __P((char [], FILE *, int));
@


1.7
log
@grabh() now returns SIGINT if it was interrupted (previously always
    returned 0 and the return val was always ignored).
Add gethfromtty() to get a header (using grabh) from the tty and
    quit on two ^C's.
Use gethfromtty() when getting Subject, Cc, and Bcc headers so
    we can quit nicely.  Closes PR #291.
Don't use longs where it doesn't make sense.
@
text
@d1 1
a1 1
/*	$OpenBSD: extern.h,v 1.6 1997/07/13 21:21:12 millert Exp $	*/
d37 1
a37 1
 *	$OpenBSD: extern.h,v 1.6 1997/07/13 21:21:12 millert Exp $
d272 1
@


1.6
log
@Merge in NetBSD and 4.4BSD-lite2 changes as well as some of my own.
 - handle long lines safely (from NetBSD)
 - use puts/fputs and putchar/putc when it makes sense
 - use err/errx and warn/warnx when it makes sense
 - make return() and sizeof() style consisten
 - some more buffer safety
@
text
@d1 1
a1 1
/*	$OpenBSD: extern.h,v 1.5 1997/05/30 08:51:37 deraadt Exp $	*/
d37 1
a37 1
 *	$OpenBSD$
d144 1
@


1.5
log
@overflows abound
@
text
@d1 2
a2 2
/*	$OpenBSD: extern.h,v 1.4 1997/03/29 03:01:45 millert Exp $	*/
/*	$NetBSD: extern.h,v 1.4 1996/06/08 19:48:21 christos Exp $	*/
d36 2
a37 2
 *	@@(#)extern.h	8.1 (Berkeley) 6/6/93
 *	$NetBSD: extern.h,v 1.4 1996/06/08 19:48:21 christos Exp $
d161 2
d178 1
a178 1
void	 makemessage __P((FILE *));
d190 1
a190 1
int	 newfileinfo __P((void));
d205 1
a205 1
int	 putline __P((FILE *, char *));
d235 1
a235 1
void	 setptr __P((FILE *));
d269 2
@


1.4
log
@Use ``mail.local -H'' to do dot locking so we can have mode 755 mail
spool, change an occurrence of tempnam() to mkstemp(), change some
longs and shorts to ints.  Mail is now usable again.
@
text
@d1 1
a1 1
/*	$OpenBSD: extern.h,v 1.3 1996/06/11 12:53:39 deraadt Exp $	*/
d133 1
a133 1
void	 findmail __P((char *, char *));
d142 1
a142 1
int	 getfold __P((char *));
@


1.3
log
@from christos;
- Fix PR/105: Implement dot locking protocol and check return value of flock.
- Fix PR/2247: Don't call unknown users "ubluit". Issue an error message.
- Fix/add prototypes.
- Fix warnings.
- Use POSIX signal mask calls.
@
text
@d1 1
a1 1
/*	$OpenBSD: extern.h,v 1.4 1996/06/08 19:48:21 christos Exp $	*/
d239 2
@


1.2
log
@From NetBSD: merge of 960317
@
text
@d1 2
a2 1
/*	$OpenBSD$	*/
d37 1
d40 1
d45 1
d48 1
d63 1
d84 1
a84 1
int	 More __P((int *));
d86 2
a87 2
int	 Respond __P((int *));
int	 Type __P((int *));
d91 1
a91 1
int	 alternates __P((char **));
d103 1
a103 1
int	 clobber __P((char **));
d110 2
a111 2
int	 copycmd __P((char []));
int	 core __P((void));
d113 1
a113 1
int	 delete __P((int []));
d115 1
a115 1
int	 deltype __P((int []));
d117 4
a120 3
int	 diction __P((const void *, const void *));
int	 dosh __P((char *));
int	 echo __P((char **));
d122 1
a122 1
int	 editor __P((int *));
d124 2
a125 2
int	 elsecmd __P((void));
int	 endifcmd __P((void));
d130 1
a130 1
int	 file __P((char **));
d137 1
a137 1
int	 folders __P((void));
d140 1
a140 1
int	 from __P((int *));
d148 1
a148 1
int	 group __P((char **));
d152 2
a153 2
int	 headers __P((int *));
int	 help __P((void));
d155 3
a157 3
int	 ifcmd __P((char **));
int	 igcomp __P((const void *, const void *));
int	 igfield __P((char *[]));
d181 1
a181 1
int	 mboxit __P((int []));
d185 1
a185 1
int	 messize __P((int *));
d187 1
a187 1
int	 more __P((int *));
d189 5
a193 3
int	 next __P((int *));
int	 null __P((int));
void	 panic __P((const char *, ...));
d195 4
a198 4
int	 pcmdlist __P((void));
int	 pdot __P((void));
void	 prepare_child __P((int, int, int));
int	 preserve __P((int *));
d204 1
a204 1
int	 pversion __P((int));
d206 1
a206 1
int	 quitcmd __P((void));
d212 3
a214 3
int	 respond __P((int *));
int	 retfield __P((char *[]));
int	 rexit __P((int));
d216 2
a217 2
int	 run_command __P((char *, int, int, int, char *, char *, char *));
int	 save __P((char []));
d220 1
a220 1
int	 saveigfield __P((char *[]));
d222 1
a222 1
int	 saveretfield __P((char *[]));
d225 1
a225 1
int	 schdir __P((char **));
d227 1
a227 1
int	 scroll __P((char []));
d229 2
a230 2
int	 sendmail __P((char *));
int	 set __P((char **));
d235 1
a235 1
int	 shell __P((char *));
d238 1
a238 1
int	 source __P((char **));
d241 1
a241 1
int	 start_command __P((char *, int, int, int, char *, char *, char *));
d244 2
a245 2
int	 stouch __P((int []));
int	 swrite __P((char []));
d247 1
a247 1
int	 top __P((int *));
d251 1
a251 1
int	 type __P((int *));
d253 1
a253 1
int	 undeletecmd __P((int *));
d256 1
a256 1
int	 unread __P((int []));
d258 1
a258 1
int	 unset __P((char **));
d261 1
a261 1
int	 visual __P((int *));
@


1.1
log
@Initial revision
@
text
@d1 2
d161 1
a161 1
struct cmd *
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@
