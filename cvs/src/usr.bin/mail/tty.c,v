head	1.20;
access;
symbols
	OPENBSD_6_0:1.20.0.12
	OPENBSD_6_0_BASE:1.20
	OPENBSD_5_9:1.20.0.8
	OPENBSD_5_9_BASE:1.20
	OPENBSD_5_8:1.20.0.10
	OPENBSD_5_8_BASE:1.20
	OPENBSD_5_7:1.20.0.2
	OPENBSD_5_7_BASE:1.20
	OPENBSD_5_6:1.20.0.6
	OPENBSD_5_6_BASE:1.20
	OPENBSD_5_5:1.20.0.4
	OPENBSD_5_5_BASE:1.20
	OPENBSD_5_4:1.19.0.16
	OPENBSD_5_4_BASE:1.19
	OPENBSD_5_3:1.19.0.14
	OPENBSD_5_3_BASE:1.19
	OPENBSD_5_2:1.19.0.12
	OPENBSD_5_2_BASE:1.19
	OPENBSD_5_1_BASE:1.19
	OPENBSD_5_1:1.19.0.10
	OPENBSD_5_0:1.19.0.8
	OPENBSD_5_0_BASE:1.19
	OPENBSD_4_9:1.19.0.6
	OPENBSD_4_9_BASE:1.19
	OPENBSD_4_8:1.19.0.4
	OPENBSD_4_8_BASE:1.19
	OPENBSD_4_7:1.19.0.2
	OPENBSD_4_7_BASE:1.19
	OPENBSD_4_6:1.18.0.20
	OPENBSD_4_6_BASE:1.18
	OPENBSD_4_5:1.18.0.16
	OPENBSD_4_5_BASE:1.18
	OPENBSD_4_4:1.18.0.14
	OPENBSD_4_4_BASE:1.18
	OPENBSD_4_3:1.18.0.12
	OPENBSD_4_3_BASE:1.18
	OPENBSD_4_2:1.18.0.10
	OPENBSD_4_2_BASE:1.18
	OPENBSD_4_1:1.18.0.8
	OPENBSD_4_1_BASE:1.18
	OPENBSD_4_0:1.18.0.6
	OPENBSD_4_0_BASE:1.18
	OPENBSD_3_9:1.18.0.4
	OPENBSD_3_9_BASE:1.18
	OPENBSD_3_8:1.18.0.2
	OPENBSD_3_8_BASE:1.18
	OPENBSD_3_7:1.17.0.8
	OPENBSD_3_7_BASE:1.17
	OPENBSD_3_6:1.17.0.6
	OPENBSD_3_6_BASE:1.17
	OPENBSD_3_5:1.17.0.4
	OPENBSD_3_5_BASE:1.17
	OPENBSD_3_4:1.17.0.2
	OPENBSD_3_4_BASE:1.17
	OPENBSD_3_3:1.16.0.6
	OPENBSD_3_3_BASE:1.16
	OPENBSD_3_2:1.16.0.4
	OPENBSD_3_2_BASE:1.16
	OPENBSD_3_1:1.16.0.2
	OPENBSD_3_1_BASE:1.16
	OPENBSD_3_0:1.12.0.2
	OPENBSD_3_0_BASE:1.12
	OPENBSD_2_9_BASE:1.11
	OPENBSD_2_9:1.11.0.14
	OPENBSD_2_8:1.11.0.12
	OPENBSD_2_8_BASE:1.11
	OPENBSD_2_7:1.11.0.10
	OPENBSD_2_7_BASE:1.11
	OPENBSD_2_6:1.11.0.8
	OPENBSD_2_6_BASE:1.11
	OPENBSD_2_5:1.11.0.6
	OPENBSD_2_5_BASE:1.11
	OPENBSD_2_4:1.11.0.4
	OPENBSD_2_4_BASE:1.11
	OPENBSD_2_3:1.11.0.2
	OPENBSD_2_3_BASE:1.11
	OPENBSD_2_2:1.9.0.2
	OPENBSD_2_2_BASE:1.9
	OPENBSD_2_1:1.2.0.4
	OPENBSD_2_1_BASE:1.2
	OPENBSD_2_0:1.2.0.2
	OPENBSD_2_0_BASE:1.2
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.20
date	2014.01.17.18.42.30;	author okan;	state Exp;
branches;
next	1.19;

1.19
date	2009.10.27.23.59.40;	author deraadt;	state Exp;
branches;
next	1.18;

1.18
date	2005.07.11.14.08.23;	author millert;	state Exp;
branches;
next	1.17;

1.17
date	2003.06.03.02.56.11;	author millert;	state Exp;
branches;
next	1.16;

1.16
date	2001.11.28.01.04.34;	author millert;	state Exp;
branches;
next	1.15;

1.15
date	2001.11.21.20.41.56;	author millert;	state Exp;
branches;
next	1.14;

1.14
date	2001.11.21.15.26.39;	author millert;	state Exp;
branches;
next	1.13;

1.13
date	2001.11.20.20.50.00;	author millert;	state Exp;
branches;
next	1.12;

1.12
date	2001.06.23.23.04.23;	author millert;	state Exp;
branches;
next	1.11;

1.11
date	97.11.14.00.24.00;	author millert;	state Exp;
branches;
next	1.10;

1.10
date	97.11.13.03.30.21;	author millert;	state Exp;
branches;
next	1.9;

1.9
date	97.07.31.17.55.16;	author millert;	state Exp;
branches;
next	1.8;

1.8
date	97.07.30.06.32.41;	author millert;	state Exp;
branches;
next	1.7;

1.7
date	97.07.22.18.54.45;	author millert;	state Exp;
branches;
next	1.6;

1.6
date	97.07.14.15.56.25;	author millert;	state Exp;
branches;
next	1.5;

1.5
date	97.07.14.00.24.31;	author millert;	state Exp;
branches;
next	1.4;

1.4
date	97.07.13.23.54.03;	author millert;	state Exp;
branches;
next	1.3;

1.3
date	97.07.13.21.21.17;	author millert;	state Exp;
branches;
next	1.2;

1.2
date	96.06.11.12.53.52;	author deraadt;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.45.39;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.45.39;	author deraadt;	state Exp;
branches;
next	;


desc
@@


1.20
log
@ctype and other sign extension fixes.

with deraadt and millert, ok millert
@
text
@/*	$OpenBSD: tty.c,v 1.19 2009/10/27 23:59:40 deraadt Exp $	*/
/*	$NetBSD: tty.c,v 1.7 1997/07/09 05:25:46 mikel Exp $	*/

/*
 * Copyright (c) 1980, 1993
 *	The Regents of the University of California.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */

/*
 * Mail -- a mail program
 *
 * Generally useful tty stuff.
 */

#include "rcv.h"
#include "extern.h"
#include <sys/ioctl.h>
#include <errno.h>

static	cc_t		c_erase;	/* Current erase char */
static	cc_t		c_kill;		/* Current kill char */
#ifndef TIOCSTI
static	int		ttyset;		/* We must now do erase/kill */
#endif
static	volatile sig_atomic_t	ttysignal;	/* Interrupted by a signal? */

/*
 * Read all relevant header fields.
 */
int
grabh(struct header *hp, int gflags)
{
	struct termios ttybuf;
#ifndef TIOCSTI
	struct sigaction savequit;
#else
# ifdef	TIOCEXT
	int extproc;
	int flag;
# endif /* TIOCEXT */
#endif
	struct sigaction savetstp;
	struct sigaction savettou;
	struct sigaction savettin;
	struct sigaction act;
	char *s;
	int error;

	sigemptyset(&act.sa_mask);
	act.sa_flags = SA_RESTART;
	act.sa_handler = SIG_DFL;
	(void)sigaction(SIGTSTP, &act, &savetstp);
	(void)sigaction(SIGTTOU, &act, &savettou);
	(void)sigaction(SIGTTIN, &act, &savettin);
	error = 1;
#ifndef TIOCSTI
	ttyset = 0;
#endif
	if (tcgetattr(fileno(stdin), &ttybuf) < 0) {
		warn("tcgetattr");
		return(-1);
	}
	c_erase = ttybuf.c_cc[VERASE];
	c_kill = ttybuf.c_cc[VKILL];
#ifndef TIOCSTI
	ttybuf.c_cc[VERASE] = 0;
	ttybuf.c_cc[VKILL] = 0;
	act.sa_handler = SIG_IGN;
	if (sigaction(SIGQUIT, &act, &savequit) == 0 &&
	    savequit.sa_handler == SIG_DFL)
		(void)sigaction(SIGQUIT, &savequit, NULL);
#else
# ifdef	TIOCEXT
	extproc = ((ttybuf.c_lflag & EXTPROC) ? 1 : 0);
	if (extproc) {
		flag = 0;
		if (ioctl(fileno(stdin), TIOCEXT, &flag) < 0)
			warn("TIOCEXT: off");
	}
# endif /* TIOCEXT */
#endif
	if (gflags & GTO) {
#ifndef TIOCSTI
		if (!ttyset && hp->h_to != NULL)
			ttyset++, tcsetattr(fileno(stdin), TCSADRAIN, &ttybuf);
#endif
		s = readtty("To: ", detract(hp->h_to, 0));
		if (s == NULL)
			goto out;
		hp->h_to = extract(s, GTO);
	}
	if (gflags & GSUBJECT) {
#ifndef TIOCSTI
		if (!ttyset && hp->h_subject != NULL)
			ttyset++, tcsetattr(fileno(stdin), TCSADRAIN, &ttybuf);
#endif
		s = readtty("Subject: ", hp->h_subject);
		if (s == NULL)
			goto out;
		hp->h_subject = s;
	}
	if (gflags & GCC) {
#ifndef TIOCSTI
		if (!ttyset && hp->h_cc != NULL)
			ttyset++, tcsetattr(fileno(stdin), TCSADRAIN, &ttybuf);
#endif
		s = readtty("Cc: ", detract(hp->h_cc, 0));
		if (s == NULL)
			goto out;
		hp->h_cc = extract(s, GCC);
	}
	if (gflags & GBCC) {
#ifndef TIOCSTI
		if (!ttyset && hp->h_bcc != NULL)
			ttyset++, tcsetattr(fileno(stdin), TCSADRAIN, &ttybuf);
#endif
		s = readtty("Bcc: ", detract(hp->h_bcc, 0));
		if (s == NULL)
			goto out;
		hp->h_bcc = extract(s, GBCC);
	}
	error = 0;
out:
	(void)sigaction(SIGTSTP, &savetstp, NULL);
	(void)sigaction(SIGTTOU, &savettou, NULL);
	(void)sigaction(SIGTTIN, &savettin, NULL);
#ifndef TIOCSTI
	ttybuf.c_cc[VERASE] = c_erase;
	ttybuf.c_cc[VKILL] = c_kill;
	if (ttyset)
		tcsetattr(fileno(stdin), TCSADRAIN, &ttybuf);
	(void)sigaction(SIGQUIT, &savequit, NULL);
#else
# ifdef	TIOCEXT
	if (extproc) {
		flag = 1;
		if (ioctl(fileno(stdin), TIOCEXT, &flag) < 0)
			warn("TIOCEXT: on");
	}
# endif /* TIOCEXT */
#endif
	return(error);
}

/*
 * Read up a header from standard input.
 * The source string has the preliminary contents to
 * be read.
 *
 */
char *
readtty(char *pr, char *src)
{
	struct sigaction act, saveint;
	char ch, canonb[BUFSIZ];
	char *cp, *cp2;
	sigset_t oset;
	int c;

	fputs(pr, stdout);
	fflush(stdout);
	if (src != NULL && strlen(src) > sizeof(canonb) - 2) {
		puts("too long to edit");
		return(src);
	}
#ifndef TIOCSTI
	if (src != NULL)
		cp = copy(src, canonb);	/* safe, bounds checked above */
	else
		cp = copy("", canonb);
	fputs(canonb, stdout);
	fflush(stdout);
#else
	cp = src == NULL ? "" : src;
	while ((c = (unsigned char)*cp++) != '\0') {
		if ((c_erase != _POSIX_VDISABLE && c == c_erase) ||
		    (c_kill != _POSIX_VDISABLE && c == c_kill)) {
			ch = '\\';
			ioctl(0, TIOCSTI, &ch);
		}
		ch = c;
		ioctl(0, TIOCSTI, &ch);
	}
	cp = canonb;
	*cp = 0;
#endif
	sigemptyset(&act.sa_mask);
	act.sa_flags = 0;		/* Note: will not restart syscalls */
	act.sa_handler = ttyint;
	(void)sigaction(SIGINT, &act, &saveint);
	act.sa_handler = ttystop;
	(void)sigaction(SIGTSTP, &act, NULL);
	(void)sigaction(SIGTTOU, &act, NULL);
	(void)sigaction(SIGTTIN, &act, NULL);
	(void)sigprocmask(SIG_UNBLOCK, &intset, &oset);
	clearerr(stdin);
	memset(cp, 0, canonb + sizeof(canonb) - cp);
	for (cp2 = cp; cp2 < canonb + sizeof(canonb) - 1; ) {
		c = getc(stdin);
		switch (ttysignal) {
			case SIGINT:
				ttysignal = 0;
				cp2 = NULL;
				c = EOF;
				/* FALLTHROUGH */
			case 0:
				break;
			default:
				ttysignal = 0;
				goto redo;
		}
		if (c == EOF || c == '\n')
			break;
		*cp2++ = c;
	}
	act.sa_handler = SIG_DFL;
	sigemptyset(&act.sa_mask);
	act.sa_flags = SA_RESTART;
	(void)sigprocmask(SIG_SETMASK, &oset, NULL);
	(void)sigaction(SIGTSTP, &act, NULL);
	(void)sigaction(SIGTTOU, &act, NULL);
	(void)sigaction(SIGTTIN, &act, NULL);
	(void)sigaction(SIGINT, &saveint, NULL);
	if (cp2 == NULL)
		return(NULL);			/* user hit ^C */
	*cp2 = '\0';
	if (c == EOF && ferror(stdin)) {
redo:
		cp = strlen(canonb) > 0 ? canonb : NULL;
		clearerr(stdin);
		/* XXX - make iterative, not recursive */
		return(readtty(pr, cp));
	}
#ifndef TIOCSTI
	if (cp == NULL || *cp == '\0')
		return(src);
	cp2 = cp;
	if (!ttyset)
		return(strlen(canonb) > 0 ? savestr(canonb) : NULL);
	while (*cp != '\0') {
		c = (unsigned char)*cp++;
		if (c_erase != _POSIX_VDISABLE && c == c_erase) {
			if (cp2 == canonb)
				continue;
			if (cp2[-1] == '\\') {
				cp2[-1] = c;
				continue;
			}
			cp2--;
			continue;
		}
		if (c_kill != _POSIX_VDISABLE && c == c_kill) {
			if (cp2 == canonb)
				continue;
			if (cp2[-1] == '\\') {
				cp2[-1] = c;
				continue;
			}
			cp2 = canonb;
			continue;
		}
		*cp2++ = c;
	}
	*cp2 = '\0';
#endif
	if (equal("", canonb))
		return("");
	return(savestr(canonb));
}

/*
 * Receipt continuation.
 */
void
ttystop(int s)
{
	struct sigaction act, oact;
	sigset_t nset;
	int save_errno;

	/*
	 * Save old handler and set to default.
	 * Unblock receipt of 's' and then resend it.
	 */
	save_errno = errno;
	(void)sigemptyset(&act.sa_mask);
	act.sa_flags = SA_RESTART;
	act.sa_handler = SIG_DFL;
	(void)sigaction(s, &act, &oact);
	(void)sigemptyset(&nset);
	(void)sigaddset(&nset, s);
	(void)sigprocmask(SIG_UNBLOCK, &nset, NULL);
	(void)kill(0, s);
	(void)sigprocmask(SIG_BLOCK, &nset, NULL);
	(void)sigaction(s, &oact, NULL);
	ttysignal = s;
	errno = save_errno;
}

/*ARGSUSED*/
void
ttyint(int s)
{

	ttysignal = s;
}
@


1.19
log
@rcsid[] and sccsid[] and copyright[] are essentially unmaintained (and
unmaintainable).  these days, people use source.  these id's do not provide
any benefit, and do hurt the small install media
(the 33,000 line diff is essentially mechanical)
ok with the idea millert, ok dms
@
text
@d1 1
a1 1
/*	$OpenBSD: tty.c,v 1.18 2005/07/11 14:08:23 millert Exp $	*/
d199 1
a199 1
	while ((c = *cp++) != '\0') {
d265 1
a265 1
		c = *cp++;
@


1.18
log
@Fix off-by-one bug in readtty() and don't assume BUFSIZ == 1024.
Based on a patch from Ulf Harnhammar.
@
text
@d1 1
a1 1
/*	$OpenBSD: tty.c,v 1.17 2003/06/03 02:56:11 millert Exp $	*/
a31 8

#ifndef lint
#if 0
static const char sccsid[] = "@@(#)tty.c	8.2 (Berkeley) 4/20/95";
#else
static const char rcsid[] = "$OpenBSD: tty.c,v 1.17 2003/06/03 02:56:11 millert Exp $";
#endif
#endif /* not lint */
@


1.17
log
@Remove the advertising clause in the UCB license which Berkeley
rescinded 22 July 1999.  Proofed by myself and Theo.
@
text
@d1 1
a1 1
/*	$OpenBSD: tty.c,v 1.16 2001/11/28 01:04:34 millert Exp $	*/
d37 1
a37 1
static const char rcsid[] = "$OpenBSD: tty.c,v 1.16 2001/11/28 01:04:34 millert Exp $";
d194 1
a194 1
	if (src != NULL && strlen(src) > BUFSIZ - 2) {
a218 4
	cp2 = cp;
	while (cp2 < canonb + BUFSIZ)
		*cp2++ = 0;
	cp2 = cp;
d229 2
a230 1
	while (cp2 < canonb + BUFSIZ) {
@


1.16
log
@Fix typo; SIGTTIN where SIGINT meant and rename a variable for clarity.
@
text
@d1 1
a1 1
/*	$OpenBSD: tty.c,v 1.15 2001/11/21 20:41:56 millert Exp $	*/
d16 1
a16 5
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
d37 1
a37 1
static const char rcsid[] = "$OpenBSD: tty.c,v 1.15 2001/11/21 20:41:56 millert Exp $";
@


1.15
log
@o kill strcpy()
o check return values of malloc and friends
o use strdup() when sensible
@
text
@d1 1
a1 1
/*	$OpenBSD: tty.c,v 1.14 2001/11/21 15:26:39 millert Exp $	*/
d41 1
a41 1
static const char rcsid[] = "$OpenBSD: tty.c,v 1.14 2001/11/21 15:26:39 millert Exp $";
d190 1
a190 1
	struct sigaction act, oact;
d230 1
a230 1
	(void)sigaction(SIGINT, &act, &oact);
d262 1
a262 1
	(void)sigaction(SIGTTIN, &oact, NULL);
@


1.14
log
@o ANSIfy
o Style nits
o Use const to silent stupid -Wall warnings
o strnc{py,at} -> strlc{py,at}
o Use strpbrk() instead of homegrown anyof()
o Use NULL instead of #defines with 0 cast to a pointer
This still could use a proper audit
@
text
@d1 1
a1 1
/*	$OpenBSD: tty.c,v 1.13 2001/11/20 20:50:00 millert Exp $	*/
d41 1
a41 1
static const char rcsid[] = "$OpenBSD: tty.c,v 1.13 2001/11/20 20:50:00 millert Exp $";
d204 1
a204 1
		cp = copy(src, canonb);
@


1.13
log
@Major signal overhaul.  We no longer longjmp all over the place.
Instead, routines responsible to gathering user input (or in some
cases outputting data) catch the signals and set flags as needed.
Because of this some handlers are install without the SA_RESTART
flag so syscalls are not restarted and we can check the flag.  All
signal handlers are now safe.

This should make the flow of control a bit more grokable but the
code is still ugly.
@
text
@d1 1
a1 1
/*	$OpenBSD: tty.c,v 1.12 2001/06/23 23:04:23 millert Exp $	*/
d39 1
a39 1
static char sccsid[] = "@@(#)tty.c	8.2 (Berkeley) 4/20/95";
d41 1
a41 1
static char rcsid[] = "$OpenBSD: tty.c,v 1.12 2001/06/23 23:04:23 millert Exp $";
a65 1

d67 1
a67 3
grabh(hp, gflags)
	struct header *hp;
	int gflags;
d120 1
a120 1
		if (!ttyset && hp->h_to != NIL)
d140 1
a140 1
		if (!ttyset && hp->h_cc != NIL)
d150 1
a150 1
		if (!ttyset && hp->h_bcc != NIL)
a186 1

d188 1
a188 2
readtty(pr, src)
	char pr[], src[];
a190 1
	sigset_t oset;
d193 1
d314 1
a314 2
ttystop(s)
	int s;
d341 1
a341 2
ttyint(s)
	int s;
@


1.12
log
@Remove evil #ifdef __GNUC__ garbage to avoid longjmp clobbering and
use volatile instead.
@
text
@d1 1
a1 1
/*	$OpenBSD: tty.c,v 1.11 1997/11/14 00:24:00 millert Exp $	*/
d41 1
a41 1
static char rcsid[] = "$OpenBSD: tty.c,v 1.11 1997/11/14 00:24:00 millert Exp $";
d54 1
a57 2
static	sigjmp_buf	rewrite;	/* Place to go when continued */
static	sigjmp_buf	intjmp;		/* Place to go when interrupted */
d61 1
a72 1
	volatile sig_t saveint;
d74 1
a74 1
	sig_t savequit;
d77 1
a77 1
	volatile int extproc;
d81 14
a94 9
	sig_t savetstp;
	sig_t savettou;
	sig_t savettin;
	volatile int errs = 0;

	savetstp = signal(SIGTSTP, SIG_DFL);
	savettou = signal(SIGTTOU, SIG_DFL);
	savettin = signal(SIGTTIN, SIG_DFL);
	errs = 0;
d107 4
a110 4
	if ((saveint = signal(SIGINT, SIG_IGN)) == SIG_DFL)
		(void)signal(SIGINT, SIG_DFL);
	if ((savequit = signal(SIGQUIT, SIG_IGN)) == SIG_DFL)
		(void)signal(SIGQUIT, SIG_DFL);
a119 5
	if (sigsetjmp(intjmp, 1)) {
		errs = SIGINT;
		goto out;
	}
	saveint = signal(SIGINT, ttyint);
d126 4
a129 2
		hp->h_to =
			extract(readtty("To: ", detract(hp->h_to, 0)), GTO);
d136 4
a139 1
		hp->h_subject = readtty("Subject: ", hp->h_subject);
d146 4
a149 2
		hp->h_cc =
			extract(readtty("Cc: ", detract(hp->h_cc, 0)), GCC);
d156 4
a159 2
		hp->h_bcc =
			extract(readtty("Bcc: ", detract(hp->h_bcc, 0)), GBCC);
d161 1
d163 3
a165 3
	(void)signal(SIGTSTP, savetstp);
	(void)signal(SIGTTOU, savettou);
	(void)signal(SIGTTIN, savettin);
d171 1
a171 1
	(void)signal(SIGQUIT, savequit);
d181 1
a181 2
	(void)signal(SIGINT, saveint);
	return(errs);
d195 2
d198 2
a199 2
	volatile int c;
	char *cp, * volatile cp2;
d232 9
a240 5
	if (sigsetjmp(rewrite, 1))
		goto redo;
	(void)signal(SIGTSTP, ttystop);
	(void)signal(SIGTTOU, ttystop);
	(void)signal(SIGTTIN, ttystop);
d244 12
d260 11
a270 4
	*cp2 = 0;
	(void)signal(SIGTSTP, SIG_DFL);
	(void)signal(SIGTTOU, SIG_DFL);
	(void)signal(SIGTTIN, SIG_DFL);
d275 1
d311 1
a311 1
		return(NULL);
d322 1
a322 1
	sig_t old_action = signal(s, SIG_DFL);
d324 1
d326 9
d340 3
a342 2
	(void)signal(s, old_action);
	siglongjmp(rewrite, 1);
d350 2
a351 1
	siglongjmp(intjmp, 1);
@


1.11
log
@NetBSD changes (mostly comsmetic):
    replace panic() with calls to err()/errx()
    use S_IS* instead of doing by hand with S_IF*.
    Use TIMESPEC_TO_TIMEVAL() and gettimeofday instead of time(2)
    Use _POSIX_VDISABLE, not 0
    Kill register
@
text
@d1 1
a1 1
/*	$OpenBSD: tty.c,v 1.10 1997/11/13 03:30:21 millert Exp $	*/
d41 1
a41 1
static char rcsid[] = "$OpenBSD: tty.c,v 1.10 1997/11/13 03:30:21 millert Exp $";
d73 1
a73 1
	sig_t saveint;
d78 3
a80 2
	int extproc, flag;
#endif /* TIOCEXT */
d85 1
a85 9
	int errs = 0;
#ifdef __GNUC__
	/* Avoid siglongjmp clobbering */
	(void)&saveint;
	(void)&errs;
# ifdef	TIOCEXT
	(void)&extproc;
#endif /* TIOCEXT */
#endif
d188 2
a189 7
	int c;
	char *cp, *cp2;
#if __GNUC__
	/* Avoid siglongjmp clobbering */
	(void)&c;
	(void)&cp2;
#endif
@


1.10
log
@Add back EXTPROC code now that tty_pty.c has the lite2 fix.
@
text
@d1 1
a1 1
/*	$OpenBSD: tty.c,v 1.9 1997/07/31 17:55:16 millert Exp $	*/
d41 1
a41 1
static char rcsid[] = "$OpenBSD: tty.c,v 1.9 1997/07/31 17:55:16 millert Exp $";
d89 3
@


1.9
log
@Remove TIOCEXT added in lite2 merge for now.  Causes problems when
mail(1) is used over a telnet session.
@
text
@d1 1
a1 1
/*	$OpenBSD: tty.c,v 1.8 1997/07/30 06:32:41 millert Exp $	*/
d41 1
a41 1
static char rcsid[] = "$OpenBSD: tty.c,v 1.8 1997/07/30 06:32:41 millert Exp $";
d76 4
d112 8
d167 8
@


1.8
log
@Fix one possible oflow (not exploitable) and do a wee bit of KNF.
Much more remains to be done.
@
text
@d1 1
a1 1
/*	$OpenBSD: tty.c,v 1.7 1997/07/22 18:54:45 millert Exp $	*/
d41 1
a41 1
static char rcsid[] = "$OpenBSD: tty.c,v 1.7 1997/07/22 18:54:45 millert Exp $";
a75 2
#else
	int extproc, flag;
a82 3
#ifdef TIOCSTI
	(void)&extproc;
#endif
a107 8
# ifdef	TIOCEXT
	extproc = ((ttybuf.c_lflag & EXTPROC) ? 1 : 0);
	if (extproc) {
		flag = 0;
		if (ioctl(fileno(stdin), TIOCEXT, &flag) < 0)
			warn("TIOCEXT: off");
	}
# endif	/* TIOCEXT */
a154 8
#else
# ifdef	TIOCEXT
	if (extproc) {
		flag = 1;
		if (ioctl(fileno(stdin), TIOCEXT, &flag) < 0)
			warn("TIOCEXT: on");
	}
# endif	/* TIOCEXT */
@


1.7
log
@grabh() now returns SIGINT if it was interrupted (previously always
    returned 0 and the return val was always ignored).
Add gethfromtty() to get a header (using grabh) from the tty and
    quit on two ^C's.
Use gethfromtty() when getting Subject, Cc, and Bcc headers so
    we can quit nicely.  Closes PR #291.
Don't use longs where it doesn't make sense.
@
text
@d1 1
a1 1
/*	$OpenBSD: tty.c,v 1.6 1997/07/14 15:56:25 millert Exp $	*/
d41 1
a41 1
static char rcsid[] = "$OpenBSD: tty.c,v 1.6 1997/07/14 15:56:25 millert Exp $";
d109 1
a109 1
		signal(SIGINT, SIG_DFL);
d111 1
a111 1
		signal(SIGQUIT, SIG_DFL);
d159 3
a161 3
	signal(SIGTSTP, savetstp);
	signal(SIGTTOU, savettou);
	signal(SIGTTIN, savettin);
d167 1
a167 1
	signal(SIGQUIT, savequit);
d177 1
a177 1
	signal(SIGINT, saveint);
d234 3
a236 3
	signal(SIGTSTP, ttystop);
	signal(SIGTTOU, ttystop);
	signal(SIGTTIN, ttystop);
d245 3
a247 3
	signal(SIGTSTP, SIG_DFL);
	signal(SIGTTOU, SIG_DFL);
	signal(SIGTTIN, SIG_DFL);
d301 6
a306 6
	sigemptyset(&nset);
	sigaddset(&nset, s);
	sigprocmask(SIG_UNBLOCK, &nset, NULL);
	kill(0, s);
	sigprocmask(SIG_BLOCK, &nset, NULL);
	signal(s, old_action);
@


1.6
log
@Convert remaining sigsetmask() -> sigprocmask() (POSIX style)
in collect.c and fix up some signal botches elsewhere.
@
text
@d1 1
a1 1
/*	$OpenBSD: tty.c,v 1.5 1997/07/14 00:24:31 millert Exp $	*/
d41 1
a41 1
static char rcsid[] = "$OpenBSD: tty.c,v 1.5 1997/07/14 00:24:31 millert Exp $";
d82 1
a82 1
	int errs;
d89 1
d121 2
a122 1
	if (sigsetjmp(intjmp, 1))
d124 1
@


1.5
log
@NOSTR -> NULL
Use sigsetjmp/siglongjmp instead of sigjmp/longjmp for portability.
@
text
@d1 1
a1 1
/*	$OpenBSD: tty.c,v 1.4 1997/07/13 23:54:03 millert Exp $	*/
d41 1
a41 1
static char rcsid[] = "$OpenBSD: tty.c,v 1.4 1997/07/13 23:54:03 millert Exp $";
d300 2
a302 2
	kill(0, s);
	sigprocmask(SIG_UNBLOCK, &nset, NULL);
@


1.4
log
@bcopy() -> memcpy() and fix some casts.
@
text
@d1 1
a1 1
/*	$OpenBSD: tty.c,v 1.3 1997/07/13 21:21:17 millert Exp $	*/
d41 1
a41 1
static char rcsid[] = "$OpenBSD: tty.c,v 1.3 1997/07/13 21:21:17 millert Exp $";
d55 4
a58 4
static	cc_t	c_erase;		/* Current erase char */
static	cc_t	c_kill;			/* Current kill char */
static	jmp_buf	rewrite;		/* Place to go when continued */
static	jmp_buf	intjmp;			/* Place to go when interrupted */
d60 1
a60 1
static	int	ttyset;			/* We must now do erase/kill */
d84 1
a84 1
	/* Avoid longjmp clobbering */
d120 1
a120 1
	if (setjmp(intjmp))
d134 1
a134 1
		if (!ttyset && hp->h_subject != NOSTR)
d193 1
a193 1
	/* Avoid longjmp clobbering */
d200 1
a200 1
	if (src != NOSTR && strlen(src) > BUFSIZ - 2) {
d205 1
a205 1
	if (src != NOSTR)
d212 1
a212 1
	cp = src == NOSTR ? "" : src;
d229 1
a229 1
	if (setjmp(rewrite))
d247 1
a247 1
		cp = strlen(canonb) > 0 ? canonb : NOSTR;
d252 1
a252 1
	if (cp == NOSTR || *cp == '\0')
d256 1
a256 1
		return(strlen(canonb) > 0 ? savestr(canonb) : NOSTR);
d284 1
a284 1
		return(NOSTR);
d304 1
a304 1
	longjmp(rewrite, 1);
d312 1
a312 1
	longjmp(intjmp, 1);
@


1.3
log
@Merge in NetBSD and 4.4BSD-lite2 changes as well as some of my own.
 - handle long lines safely (from NetBSD)
 - use puts/fputs and putchar/putc when it makes sense
 - use err/errx and warn/warnx when it makes sense
 - make return() and sizeof() style consisten
 - some more buffer safety
@
text
@d1 1
a1 1
/*	$OpenBSD: tty.c,v 1.2 1996/06/11 12:53:52 deraadt Exp $	*/
d41 1
a41 1
static char rcsid[] = "$OpenBSD: tty.c,v 1.2 1996/06/11 12:53:52 deraadt Exp $";
d86 1
a86 1
	(void) &extproc;
d88 1
a88 1
	(void) &saveint;
d194 2
a195 2
	(void) &c;
	(void) &cp2;
@


1.2
log
@from christos;
- Fix PR/105: Implement dot locking protocol and check return value of flock.
- Fix PR/2247: Don't call unknown users "ubluit". Issue an error message.
- Fix/add prototypes.
- Fix warnings.
- Use POSIX signal mask calls.
@
text
@d1 2
a2 2
/*	$OpenBSD: tty.c,v 1.5 1996/06/08 19:48:43 christos Exp $	*/
/*	$NetBSD: tty.c,v 1.5 1996/06/08 19:48:43 christos Exp $	*/
d39 1
a39 1
static char sccsid[] = "@@(#)tty.c	8.1 (Berkeley) 6/6/93";
d41 1
a41 1
static char rcsid[] = "$OpenBSD: tty.c,v 1.5 1996/06/08 19:48:43 christos Exp $";
d76 2
d85 3
d99 1
a99 1
		perror("tcgetattr");
d112 8
d165 8
d201 1
a201 1
		printf("too long to edit\n");
@


1.1
log
@Initial revision
@
text
@d1 3
d38 5
a42 2
static char sccsid[] = "from: @@(#)tty.c	8.1 (Berkeley) 6/6/93";
static char rcsid[] = "$Id: tty.c,v 1.4 1995/05/02 01:40:17 mycroft Exp $";
d53 1
d81 4
a84 1
	void ttyint();
d170 6
a175 2
	register char *cp, *cp2;
	void ttystop();
d192 1
a192 1
	while (c = *cp++) {
d275 1
d277 3
a279 1
	sigsetmask(sigblock(0) & ~sigmask(s));
d281 1
a281 1
	sigblock(sigmask(s));
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@
