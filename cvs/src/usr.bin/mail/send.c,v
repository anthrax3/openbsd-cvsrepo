head	1.24;
access;
symbols
	OPENBSD_6_2_BASE:1.24
	OPENBSD_6_1:1.24.0.12
	OPENBSD_6_1_BASE:1.24
	OPENBSD_6_0:1.24.0.8
	OPENBSD_6_0_BASE:1.24
	OPENBSD_5_9:1.24.0.4
	OPENBSD_5_9_BASE:1.24
	OPENBSD_5_8:1.24.0.6
	OPENBSD_5_8_BASE:1.24
	OPENBSD_5_7:1.24.0.2
	OPENBSD_5_7_BASE:1.24
	OPENBSD_5_6:1.23.0.6
	OPENBSD_5_6_BASE:1.23
	OPENBSD_5_5:1.23.0.4
	OPENBSD_5_5_BASE:1.23
	OPENBSD_5_4:1.22.0.16
	OPENBSD_5_4_BASE:1.22
	OPENBSD_5_3:1.22.0.14
	OPENBSD_5_3_BASE:1.22
	OPENBSD_5_2:1.22.0.12
	OPENBSD_5_2_BASE:1.22
	OPENBSD_5_1_BASE:1.22
	OPENBSD_5_1:1.22.0.10
	OPENBSD_5_0:1.22.0.8
	OPENBSD_5_0_BASE:1.22
	OPENBSD_4_9:1.22.0.6
	OPENBSD_4_9_BASE:1.22
	OPENBSD_4_8:1.22.0.4
	OPENBSD_4_8_BASE:1.22
	OPENBSD_4_7:1.22.0.2
	OPENBSD_4_7_BASE:1.22
	OPENBSD_4_6:1.21.0.8
	OPENBSD_4_6_BASE:1.21
	OPENBSD_4_5:1.21.0.4
	OPENBSD_4_5_BASE:1.21
	OPENBSD_4_4:1.21.0.2
	OPENBSD_4_4_BASE:1.21
	OPENBSD_4_3:1.18.0.4
	OPENBSD_4_3_BASE:1.18
	OPENBSD_4_2:1.18.0.2
	OPENBSD_4_2_BASE:1.18
	OPENBSD_4_1:1.17.0.16
	OPENBSD_4_1_BASE:1.17
	OPENBSD_4_0:1.17.0.14
	OPENBSD_4_0_BASE:1.17
	OPENBSD_3_9:1.17.0.12
	OPENBSD_3_9_BASE:1.17
	OPENBSD_3_8:1.17.0.10
	OPENBSD_3_8_BASE:1.17
	OPENBSD_3_7:1.17.0.8
	OPENBSD_3_7_BASE:1.17
	OPENBSD_3_6:1.17.0.6
	OPENBSD_3_6_BASE:1.17
	OPENBSD_3_5:1.17.0.4
	OPENBSD_3_5_BASE:1.17
	OPENBSD_3_4:1.17.0.2
	OPENBSD_3_4_BASE:1.17
	OPENBSD_3_3:1.15.0.6
	OPENBSD_3_3_BASE:1.15
	OPENBSD_3_2:1.15.0.4
	OPENBSD_3_2_BASE:1.15
	OPENBSD_3_1:1.15.0.2
	OPENBSD_3_1_BASE:1.15
	OPENBSD_3_0:1.13.0.4
	OPENBSD_3_0_BASE:1.13
	OPENBSD_2_9_BASE:1.13
	OPENBSD_2_9:1.13.0.2
	OPENBSD_2_8:1.12.0.2
	OPENBSD_2_8_BASE:1.12
	OPENBSD_2_7:1.10.0.2
	OPENBSD_2_7_BASE:1.10
	OPENBSD_2_6:1.9.0.8
	OPENBSD_2_6_BASE:1.9
	OPENBSD_2_5:1.9.0.6
	OPENBSD_2_5_BASE:1.9
	OPENBSD_2_4:1.9.0.4
	OPENBSD_2_4_BASE:1.9
	OPENBSD_2_3:1.9.0.2
	OPENBSD_2_3_BASE:1.9
	OPENBSD_2_2:1.8.0.2
	OPENBSD_2_2_BASE:1.8
	OPENBSD_2_1:1.2.0.4
	OPENBSD_2_1_BASE:1.2
	OPENBSD_2_0:1.2.0.2
	OPENBSD_2_0_BASE:1.2
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.24
date	2015.01.20.16.59.07;	author millert;	state Exp;
branches;
next	1.23;
commitid	92usC3cTTCZG2qZC;

1.23
date	2014.01.17.18.42.30;	author okan;	state Exp;
branches;
next	1.22;

1.22
date	2009.10.27.23.59.40;	author deraadt;	state Exp;
branches;
next	1.21;

1.21
date	2008.07.16.15.14.33;	author martynas;	state Exp;
branches;
next	1.20;

1.20
date	2008.07.16.15.11.16;	author martynas;	state Exp;
branches;
next	1.19;

1.19
date	2008.07.16.14.53.41;	author martynas;	state Exp;
branches;
next	1.18;

1.18
date	2007.03.20.21.01.08;	author millert;	state Exp;
branches;
next	1.17;

1.17
date	2003.06.03.02.56.11;	author millert;	state Exp;
branches;
next	1.16;

1.16
date	2003.05.15.02.47.47;	author pjanzen;	state Exp;
branches;
next	1.15;

1.15
date	2001.11.28.01.26.35;	author millert;	state Exp;
branches;
next	1.14;

1.14
date	2001.11.21.15.26.39;	author millert;	state Exp;
branches;
next	1.13;

1.13
date	2001.01.16.05.36.09;	author millert;	state Exp;
branches;
next	1.12;

1.12
date	2000.08.23.21.24.08;	author mickey;	state Exp;
branches;
next	1.11;

1.11
date	2000.06.30.16.00.18;	author millert;	state Exp;
branches;
next	1.10;

1.10
date	2000.04.26.15.47.31;	author millert;	state Exp;
branches
	1.10.2.1;
next	1.9;

1.9
date	97.11.14.00.23.57;	author millert;	state Exp;
branches;
next	1.8;

1.8
date	97.07.24.17.27.13;	author millert;	state Exp;
branches;
next	1.7;

1.7
date	97.07.22.18.54.41;	author millert;	state Exp;
branches;
next	1.6;

1.6
date	97.07.14.15.56.25;	author millert;	state Exp;
branches;
next	1.5;

1.5
date	97.07.14.00.24.30;	author millert;	state Exp;
branches;
next	1.4;

1.4
date	97.07.13.23.54.02;	author millert;	state Exp;
branches;
next	1.3;

1.3
date	97.07.13.21.21.16;	author millert;	state Exp;
branches;
next	1.2;

1.2
date	96.06.11.12.53.50;	author deraadt;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.45.39;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.45.39;	author deraadt;	state Exp;
branches;
next	;

1.10.2.1
date	2000.10.06.21.16.15;	author jason;	state Exp;
branches;
next	;


desc
@@


1.24
log
@Add support for the "-r fromaddr" flag now that we don't support
sendmail flags on the command line.
Also allow "from" to be set in mailrc.
Use sendmail's "-t" flag when executing sendmail instead of specifying
the list of recipients in argv.  The "-f" flag will be used to set
the from address if specified.
@
text
@/*	$OpenBSD: send.c,v 1.23 2014/01/17 18:42:30 okan Exp $	*/
/*	$NetBSD: send.c,v 1.6 1996/06/08 19:48:39 christos Exp $	*/

/*
 * Copyright (c) 1980, 1993
 *	The Regents of the University of California.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */

#include "rcv.h"
#include "extern.h"

static volatile sig_atomic_t sendsignal;	/* Interrupted by a signal? */

/*
 * Mail -- a mail program
 *
 * Mail to others.
 */

/*
 * Send message described by the passed pointer to the
 * passed output buffer.  Return -1 on error.
 * Adjust the status: field if need be.
 * If doign is given, suppress ignored header fields.
 * prefix is a string to prepend to each output line.
 */
int
sendmessage(struct message *mp, FILE *obuf, struct ignoretab *doign,
	    char *prefix)
{
	int count;
	FILE *ibuf;
	char line[LINESIZE];
	char visline[4 * LINESIZE - 3];
	int ishead, infld, ignoring = 0, dostat, firstline;
	char *cp, *cp2;
	int c = 0;
	int length;
	int prefixlen = 0;
	int rval;
	int dovis;
	struct sigaction act, saveint;
	sigset_t oset;

	sendsignal = 0;
	rval = -1;
	dovis = isatty(fileno(obuf));
	sigemptyset(&act.sa_mask);
	act.sa_flags = SA_RESTART;
	act.sa_handler = sendint;
	(void)sigaction(SIGINT, &act, &saveint);
	(void)sigprocmask(SIG_UNBLOCK, &intset, &oset);

	/*
	 * Compute the prefix string, without trailing whitespace
	 */
	if (prefix != NULL) {
		cp2 = 0;
		for (cp = prefix; *cp; cp++)
			if (*cp != ' ' && *cp != '\t')
				cp2 = cp;
		prefixlen = cp2 == 0 ? 0 : cp2 - prefix + 1;
	}
	ibuf = setinput(mp);
	count = mp->m_size;
	ishead = 1;
	dostat = doign == 0 || !isign("status", doign);
	infld = 0;
	firstline = 1;
	/*
	 * Process headers first
	 */
	while (count > 0 && ishead) {
		if (fgets(line, sizeof(line), ibuf) == NULL)
			break;
		count -= length = strlen(line);
		if (firstline) {
			/*
			 * First line is the From line, so no headers
			 * there to worry about
			 */
			firstline = 0;
			ignoring = doign == ignoreall;
		} else if (line[0] == '\n') {
			/*
			 * If line is blank, we've reached end of
			 * headers, so force out status: field
			 * and note that we are no longer in header
			 * fields
			 */
			if (dostat) {
				if (statusput(mp, obuf, prefix) == -1)
					goto out;
				dostat = 0;
			}
			ishead = 0;
			ignoring = doign == ignoreall;
		} else if (infld && (line[0] == ' ' || line[0] == '\t')) {
			/*
			 * If this line is a continuation (via space or tab)
			 * of a previous header field, just echo it
			 * (unless the field should be ignored).
			 * In other words, nothing to do.
			 */
		} else {
			/*
			 * Pick up the header field if we have one.
			 */
			for (cp = line;
			    (c = (unsigned char)*cp++) && c != ':' && !isspace(c); )
				;
			cp2 = --cp;
			while (isspace((unsigned char)*cp++))
				;
			if (cp[-1] != ':') {
				/*
				 * Not a header line, force out status:
				 * This happens in uucp style mail where
				 * there are no headers at all.
				 */
				if (dostat) {
					if (statusput(mp, obuf, prefix) == -1)
						goto out;
					dostat = 0;
				}
				if (doign != ignoreall)
					/* add blank line */
					(void)putc('\n', obuf);
				ishead = 0;
				ignoring = 0;
			} else {
				/*
				 * If it is an ignored field and
				 * we care about such things, skip it.
				 */
				*cp2 = 0;	/* temporarily null terminate */
				if (doign && isign(line, doign))
					ignoring = 1;
				else if (strcasecmp(line, "status") == 0) {
					/*
					 * If the field is "status," go compute
					 * and print the real Status: field
					 */
					if (dostat) {
						if (statusput(mp, obuf, prefix) == -1)
							goto out;
						dostat = 0;
					}
					ignoring = 1;
				} else {
					ignoring = 0;
					*cp2 = c;	/* restore */
				}
				infld = 1;
			}
		}
		if (!ignoring) {
			/*
			 * Strip trailing whitespace from prefix
			 * if line is blank.
			 */
			if (prefix != NULL) {
				if (length > 1)
					fputs(prefix, obuf);
				else
					(void)fwrite(prefix, sizeof(*prefix),
							prefixlen, obuf);
			}
			if (dovis) {
				length = strvis(visline, line, VIS_SAFE|VIS_NOSLASH);
				(void)fwrite(visline, sizeof(*visline), length, obuf);
			} else
				(void)fwrite(line, sizeof(*line), length, obuf);
			if (ferror(obuf))
				goto out;
		}
		if (sendsignal == SIGINT)
			goto out;
	}
	/*
	 * Copy out message body
	 */
	if (doign == ignoreall)
		count--;		/* skip final blank line */
	while (count > 0) {
		if (fgets(line, sizeof(line), ibuf) == NULL) {
			c = 0;
			break;
		}
		count -= c = strlen(line);
		if (prefix != NULL) {
			/*
			 * Strip trailing whitespace from prefix
			 * if line is blank.
			 */
			if (c > 1)
				fputs(prefix, obuf);
			else
				(void)fwrite(prefix, sizeof(*prefix),
						prefixlen, obuf);
		}
		/*
		 * We can't read the record file (or inbox for recipient)
		 * properly with 'From ' lines in the message body (from
		 * forwarded messages or sentences starting with "From "),
		 * so we will prepend those lines with a '>'.
		 */
		if (strncmp(line, "From ", 5) == 0)
			(void)fwrite(">", 1, 1, obuf); /* '>' before 'From ' */
		if (dovis) {
			length = strvis(visline, line, VIS_SAFE|VIS_NOSLASH);
			(void)fwrite(visline, sizeof(*visline), length, obuf);
		} else
			(void)fwrite(line, sizeof(*line), c, obuf);
		if (ferror(obuf) || sendsignal == SIGINT)
			goto out;
	}
	if (doign == ignoreall && c > 0 && line[c - 1] != '\n')
		/* no final blank line */
		if ((c = getc(ibuf)) != EOF && putc(c, obuf) == EOF)
			goto out;
	rval = 0;
out:
	sendsignal = 0;
	(void)sigprocmask(SIG_SETMASK, &oset, NULL);
	(void)sigaction(SIGINT, &saveint, NULL);
	return(rval);
}

/*
 * Output a reasonable looking status field.
 */
int
statusput(struct message *mp, FILE *obuf, char *prefix)
{
	char statout[3];
	char *cp = statout;

	if (mp->m_flag & MREAD)
		*cp++ = 'R';
	if ((mp->m_flag & MNEW) == 0)
		*cp++ = 'O';
	*cp = 0;
	if (statout[0]) {
		fprintf(obuf, "%sStatus: %s\n",
			prefix == NULL ? "" : prefix, statout);
		return(ferror(obuf) ? -1 : 0);
	}
	return(0);
}

/*
 * Interface between the argument list and the mail1 routine
 * which does all the dirty work.
 */
int
mail(struct name *to, struct name *cc, struct name *bcc, struct name *smopts,
     char *fromaddr, char *subject)
{
	struct header head;

	head.h_to = to;
	head.h_from = fromaddr;
	head.h_subject = subject;
	head.h_cc = cc;
	head.h_bcc = bcc;
	head.h_smopts = smopts;
	mail1(&head, 0);
	return(0);
}

/*
 * Send mail to a bunch of user names.  The interface is through
 * the mail routine below.
 */
int
sendmail(void *v)
{
	char *str = v;
	struct header head;

	head.h_to = extract(str, GTO);
	head.h_from = NULL;
	head.h_subject = NULL;
	head.h_cc = NULL;
	head.h_bcc = NULL;
	head.h_smopts = NULL;
	mail1(&head, 0);
	return(0);
}

/*
 * Mail a message on standard input to the people indicated
 * in the passed header.  (Internal interface).
 */
void
mail1(struct header *hp, int printheaders)
{
	char *cp, *envfrom = NULL;
	char *argv[8];
	char **ap = argv;
	pid_t pid;
	struct name *to;
	FILE *mtf;

	/*
	 * Collect user's mail from standard input.
	 * Get the result as mtf.
	 */
	if ((mtf = collect(hp, printheaders)) == NULL)
		return;
	if (fsize(mtf) == 0) {
		if (value("skipempty") != NULL)
			goto out;
		if (hp->h_subject == NULL || *hp->h_subject == '\0')
			puts("No message, no subject; hope that's ok");
		else
			puts("Null message body; hope that's ok");
	}
	/*
	 * Now, take the user names from the combined
	 * to and cc lists and do all the alias
	 * processing.
	 */
	senderr = 0;
	to = usermap(cat(hp->h_bcc, cat(hp->h_to, hp->h_cc)));
	if (to == NULL) {
		puts("No recipients specified");
		senderr++;
	}
	/*
	 * Look through the recipient list for names with /'s
	 * in them which we write to as files directly.
	 */
	to = outof(to, mtf, hp);
	if (senderr)
		savedeadletter(mtf);
	to = elide(to);
	if (count(to) == 0)
		goto out;
	fixhead(hp, to);
	if ((mtf = infix(hp, mtf)) == NULL) {
		fputs(". . . message lost, sorry.\n", stderr);
		return;
	}
	if ((cp = value("record")) != NULL)
		(void)savemail(expand(cp), mtf);
	
	/* Setup sendmail arguments. */
        *ap++ = "send-mail";
        *ap++ = "-i";
        *ap++ = "-t";
	cp = hp->h_from ? hp->h_from : value("from");
	if (cp != NULL) {
		envfrom = skin(cp);
		*ap++ = "-f";
		*ap++ = envfrom;
		if (envfrom == cp)
			envfrom = NULL;
	}
	if (value("metoo") != NULL)
                *ap++ = "-m";
	if (value("verbose") != NULL)
                *ap++ = "-v";
	*ap = NULL;
	if (debug) {
		fputs("Sendmail arguments:", stdout);
		for (ap = argv; *ap != NULL; ap++)
			printf(" \"%s\"", *ap);
		putchar('\n');
		goto out;
	}
	/*
	 * Fork, set up the temporary mail file as standard
	 * input for "mail", and exec with the user list we generated
	 * far above.
	 */
	pid = fork();
	if (pid == -1) {
		warn("fork");
		savedeadletter(mtf);
		goto out;
	}
	if (pid == 0) {
		sigset_t nset;

		sigemptyset(&nset);
		sigaddset(&nset, SIGHUP);
		sigaddset(&nset, SIGINT);
		sigaddset(&nset, SIGQUIT);
		sigaddset(&nset, SIGTSTP);
		sigaddset(&nset, SIGTTIN);
		sigaddset(&nset, SIGTTOU);
		prepare_child(&nset, fileno(mtf), -1);
		if ((cp = value("sendmail")) != NULL)
			cp = expand(cp);
		else
			cp = _PATH_SENDMAIL;
		execv(cp, argv);
		warn("%s", cp);
		_exit(1);
	}
	free(envfrom);
	if (value("verbose") != NULL)
		(void)wait_child(pid);
	else
		free_child(pid);
out:
	(void)Fclose(mtf);
}

/*
 * Fix the header by glopping all of the expanded names from
 * the distribution list into the appropriate fields.
 */
void
fixhead(struct header *hp, struct name *tolist)
{
	struct name *np;

	hp->h_to = NULL;
	hp->h_cc = NULL;
	hp->h_bcc = NULL;
	for (np = tolist; np != NULL; np = np->n_flink)
		if ((np->n_type & GMASK) == GTO)
			hp->h_to =
				cat(hp->h_to, nalloc(np->n_name, np->n_type));
		else if ((np->n_type & GMASK) == GCC)
			hp->h_cc =
				cat(hp->h_cc, nalloc(np->n_name, np->n_type));
		else if ((np->n_type & GMASK) == GBCC)
			hp->h_bcc =
				cat(hp->h_bcc, nalloc(np->n_name, np->n_type));
}

/*
 * Prepend a header in front of the collected stuff
 * and return the new file.
 */
FILE *
infix(struct header *hp, FILE *fi)
{
	FILE *nfo, *nfi;
	int c, fd;
	char tempname[PATHSIZE];

	(void)snprintf(tempname, sizeof(tempname),
	    "%s/mail.RsXXXXXXXXXX", tmpdir);
	if ((fd = mkstemp(tempname)) == -1 ||
	    (nfo = Fdopen(fd, "w")) == NULL) {
		warn("%s", tempname);
		return(fi);
	}
	if ((nfi = Fopen(tempname, "r")) == NULL) {
		warn("%s", tempname);
		(void)Fclose(nfo);
		(void)rm(tempname);
		return(fi);
	}
	(void)rm(tempname);
	(void)puthead(hp, nfo, GTO|GSUBJECT|GCC|GBCC|GNL|GCOMMA);
	c = getc(fi);
	while (c != EOF) {
		(void)putc(c, nfo);
		c = getc(fi);
	}
	if (ferror(fi)) {
		warn("read");
		rewind(fi);
		return(fi);
	}
	(void)fflush(nfo);
	if (ferror(nfo)) {
		warn("%s", tempname);
		(void)Fclose(nfo);
		(void)Fclose(nfi);
		rewind(fi);
		return(fi);
	}
	(void)Fclose(nfo);
	(void)Fclose(fi);
	rewind(nfi);
	return(nfi);
}

/*
 * Dump the to, subject, cc header on the
 * passed file buffer.
 */
int
puthead(struct header *hp, FILE *fo, int w)
{
	int gotcha;
	char *from;

	gotcha = 0;
	from = hp->h_from ? hp->h_from : value("from");
	if (from != NULL)
		fprintf(fo, "From: %s\n", from), gotcha++;
	if (hp->h_to != NULL && w & GTO)
		fmt("To:", hp->h_to, fo, w&GCOMMA), gotcha++;
	if (hp->h_subject != NULL && w & GSUBJECT)
		fprintf(fo, "Subject: %s\n", hp->h_subject), gotcha++;
	if (hp->h_cc != NULL && w & GCC)
		fmt("Cc:", hp->h_cc, fo, w&GCOMMA), gotcha++;
	if (hp->h_bcc != NULL && w & GBCC)
		fmt("Bcc:", hp->h_bcc, fo, w&GCOMMA), gotcha++;
	if (gotcha && w & GNL)
		(void)putc('\n', fo);
	return(0);
}

/*
 * Format the given header line to not exceed 72 characters.
 */
void
fmt(char *str, struct name *np, FILE *fo, int comma)
{
	int col, len;

	comma = comma ? 1 : 0;
	col = strlen(str);
	if (col)
		fputs(str, fo);
	for (; np != NULL; np = np->n_flink) {
		if (np->n_flink == NULL)
			comma = 0;
		len = strlen(np->n_name);
		col++;		/* for the space */
		if (col + len + comma > 72 && col > 4) {
			fputs("\n    ", fo);
			col = 4;
		} else
			putc(' ', fo);
		fputs(np->n_name, fo);
		if (comma)
			putc(',', fo);
		col += len + comma;
	}
	putc('\n', fo);
}

/*
 * Save the outgoing mail on the passed file.
 */
/*ARGSUSED*/
int
savemail(char *name, FILE *fi)
{
	FILE *fo;
	char buf[BUFSIZ];
	time_t now;
	mode_t m;

	m = umask(077);
	fo = Fopen(name, "a");
	(void)umask(m);
	if (fo == NULL) {
		warn("%s", name);
		return(-1);
	}
	(void)time(&now);
	fprintf(fo, "From %s %s", myname, ctime(&now));
	while (fgets(buf, sizeof(buf), fi) == buf) {
		/*
		 * We can't read the record file (or inbox for recipient)
		 * in the message body (from forwarded messages or sentences
		 * starting with "From "), so we will prepend those lines with
		 * a '>'.
		 */
		if (strncmp(buf, "From ", 5) == 0)
			(void)fwrite(">", 1, 1, fo);   /* '>' before 'From ' */
		(void)fwrite(buf, 1, strlen(buf), fo);
	}
	(void)putc('\n', fo);
	(void)fflush(fo);
	if (ferror(fo))
		warn("%s", name);
	(void)Fclose(fo);
	rewind(fi);
	return(0);
}

/*ARGSUSED*/
void
sendint(int s)
{

	sendsignal = s;
}
@


1.23
log
@ctype and other sign extension fixes.

with deraadt and millert, ok millert
@
text
@d1 1
a1 1
/*	$OpenBSD: send.c,v 1.22 2009/10/27 23:59:40 deraadt Exp $	*/
d282 1
a282 1
     char *subject)
d287 1
a295 1

d307 1
d323 3
a325 1
	char *cp;
a326 1
	char **namelist;
d370 20
a389 1
	namelist = unpack(hp->h_smopts, to);
a390 2
		char **t;

d392 2
a393 2
		for (t = namelist; *t != NULL; t++)
			printf(" \"%s\"", *t);
a396 2
	if ((cp = value("record")) != NULL)
		(void)savemail(expand(cp), mtf);
d423 1
a423 1
		execv(cp, namelist);
d427 1
d518 1
d521 3
@


1.22
log
@rcsid[] and sccsid[] and copyright[] are essentially unmaintained (and
unmaintainable).  these days, people use source.  these id's do not provide
any benefit, and do hurt the small install media
(the 33,000 line diff is essentially mechanical)
ok with the idea millert, ok dms
@
text
@d1 1
a1 1
/*	$OpenBSD: send.c,v 1.21 2008/07/16 15:14:33 martynas Exp $	*/
d133 2
a134 1
			for (cp = line; (c = *cp++) && c != ':' && !isspace(c);)
d137 1
a137 1
			while (isspace(*cp++))
@


1.21
log
@'no subject' check is never triggered.  check if it's actually empty
ok millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: send.c,v 1.20 2008/07/16 15:11:16 martynas Exp $	*/
a31 8

#ifndef lint
#if 0
static const char sccsid[] = "@@(#)send.c	8.1 (Berkeley) 6/6/93";
#else
static const char rcsid[] = "$OpenBSD: send.c,v 1.20 2008/07/16 15:11:16 martynas Exp $";
#endif
#endif /* not lint */
@


1.20
log
@add -E flag and 'skipempty' option to skip sending messages with
empty bodies.  useful for sending mails from crontabs.
from rivo nurges <rix at estpak dot ee>, with missing 'skipempty'
documentation and usage update from me
ok millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: send.c,v 1.19 2008/07/16 14:53:41 martynas Exp $	*/
d37 1
a37 1
static const char rcsid[] = "$OpenBSD: send.c,v 1.19 2008/07/16 14:53:41 martynas Exp $";
d344 1
a344 1
		if (hp->h_subject == NULL)
@


1.19
log
@- use strncmp/strncasecmp instead of comparing by character
- simplify istrlcpy, no need to check for isupper
- line[0] is redundant, because strcasecmp will take care of it
ok millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: send.c,v 1.18 2007/03/20 21:01:08 millert Exp $	*/
d37 1
a37 1
static const char rcsid[] = "$OpenBSD: send.c,v 1.18 2007/03/20 21:01:08 millert Exp $";
d342 2
@


1.18
log
@Set umask to 077 when saving messages in the outbox (not enabled
by default).  From veenhuizen at users dot sourceforge dot net
@
text
@d1 1
a1 1
/*	$OpenBSD: send.c,v 1.17 2003/06/03 02:56:11 millert Exp $	*/
d37 1
a37 1
static const char rcsid[] = "$OpenBSD: send.c,v 1.17 2003/06/03 02:56:11 millert Exp $";
d170 1
a170 2
				else if ((line[0] == 's' || line[0] == 'S') &&
					 strcasecmp(line, "status") == 0) {
@


1.17
log
@Remove the advertising clause in the UCB license which Berkeley
rescinded 22 July 1999.  Proofed by myself and Theo.
@
text
@d1 1
a1 1
/*	$OpenBSD: send.c,v 1.16 2003/05/15 02:47:47 pjanzen Exp $	*/
d37 1
a37 1
static const char rcsid[] = "$OpenBSD: send.c,v 1.16 2003/05/15 02:47:47 pjanzen Exp $";
d561 1
d563 4
a566 1
	if ((fo = Fopen(name, "a")) == NULL) {
@


1.16
log
@Use vis() on any remotely created input before displaying it on a screen.
deraadt@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: send.c,v 1.15 2001/11/28 01:26:35 millert Exp $	*/
d16 1
a16 5
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
d37 1
a37 1
static const char rcsid[] = "$OpenBSD: send.c,v 1.15 2001/11/28 01:26:35 millert Exp $";
@


1.15
log
@Catch SIGINT in sendmessage() so user can interupt a long message
that is being output.

Make statusput() return an int and return -1 if ferror()
@
text
@d1 1
a1 1
/*	$OpenBSD: send.c,v 1.14 2001/11/21 15:26:39 millert Exp $	*/
d41 1
a41 1
static const char rcsid[] = "$OpenBSD: send.c,v 1.14 2001/11/21 15:26:39 millert Exp $";
d70 1
d77 1
d83 1
d205 5
a209 1
			(void)fwrite(line, sizeof(*line), length, obuf);
d246 5
a250 1
		(void)fwrite(line, sizeof(*line), c, obuf);
@


1.14
log
@o ANSIfy
o Style nits
o Use const to silent stupid -Wall warnings
o strnc{py,at} -> strlc{py,at}
o Use strpbrk() instead of homegrown anyof()
o Use NULL instead of #defines with 0 cast to a pointer
This still could use a proper audit
@
text
@d1 1
a1 1
/*	$OpenBSD: send.c,v 1.13 2001/01/16 05:36:09 millert Exp $	*/
d41 1
a41 1
static const char rcsid[] = "$OpenBSD: send.c,v 1.13 2001/01/16 05:36:09 millert Exp $";
d48 2
d75 11
d125 2
a126 1
				statusput(mp, obuf, prefix);
d154 2
a155 1
					statusput(mp, obuf, prefix);
d178 2
a179 1
						statusput(mp, obuf, prefix);
d204 1
a204 1
				return(-1);
d206 2
d240 2
a241 2
		if (ferror(obuf))
			return(-1);
d246 7
a252 2
			return(-1);
	return(0);
d258 1
a258 1
void
d269 1
a269 1
	if (statout[0])
d272 3
d579 8
@


1.13
log
@Changes from Don Beusee:
o escape From line with a leading '>' when needed
o only print To: address and Subject lines if actually present
o new variable 'allnet' to treat user@@foo and user@@bar as the same "user"
o folders command now takes an optional argument like ls.
o new "pipe" (|) command to pipe the message through an arbitrary command
o make header display format the same as SunOS 4.1.3 /usr/ucb/mail
o tilde commands work regardless of interactive mode.
o fix "read: Interrupted system call" error by retrying if EINTR
o expanded help file
Changes by me:
o read the help file via the PAGER as it is now more than 24 lines long
@
text
@d1 1
a1 1
/*	$OpenBSD: send.c,v 1.12 2000/08/23 21:24:08 mickey Exp $	*/
d39 1
a39 1
static char sccsid[] = "@@(#)send.c	8.1 (Berkeley) 6/6/93";
d41 1
a41 1
static char rcsid[] = "$OpenBSD: send.c,v 1.12 2000/08/23 21:24:08 mickey Exp $";
d62 2
a63 5
sendmessage(mp, obuf, doign, prefix)
	struct message *mp;
	FILE *obuf;
	struct ignoretab *doign;
	char *prefix;
d236 1
a236 4
statusput(mp, obuf, prefix)
	struct message *mp;
	FILE *obuf;
	char *prefix;
d256 2
a257 3
mail(to, cc, bcc, smopts, subject)
	struct name *to, *cc, *bcc, *smopts;
	char *subject;
d276 1
a276 2
sendmail(v)
	void *v;
d283 3
a285 3
	head.h_cc = NIL;
	head.h_bcc = NIL;
	head.h_smopts = NIL;
d295 1
a295 3
mail1(hp, printheaders)
	struct header *hp;
	int printheaders;
d298 1
a298 1
	int pid;
d322 1
a322 1
	if (to == NIL) {
d396 1
a396 3
fixhead(hp, tolist)
	struct header *hp;
	struct name *tolist;
d400 4
a403 4
	hp->h_to = NIL;
	hp->h_cc = NIL;
	hp->h_bcc = NIL;
	for (np = tolist; np != NIL; np = np->n_flink)
d420 1
a420 3
infix(hp, fi)
	struct header *hp;
	FILE *fi;
d470 1
a470 4
puthead(hp, fo, w)
	struct header *hp;
	FILE *fo;
	int w;
d475 1
a475 1
	if (hp->h_to != NIL && w & GTO)
d479 1
a479 1
	if (hp->h_cc != NIL && w & GCC)
d481 1
a481 1
	if (hp->h_bcc != NIL && w & GBCC)
d492 1
a492 5
fmt(str, np, fo, comma)
	char *str;
	struct name *np;
	FILE *fo;
	int comma;
d500 2
a501 2
	for (; np != NIL; np = np->n_flink) {
		if (np->n_flink == NIL)
a520 1

d523 1
a523 3
savemail(name, fi)
	char name[];
	FILE *fi;
@


1.12
log
@repair sendmail options handling
@
text
@d1 1
a1 1
/*	$OpenBSD: send.c,v 1.11 2000/06/30 16:00:18 millert Exp $	*/
d41 1
a41 1
static char rcsid[] = "$OpenBSD: send.c,v 1.11 2000/06/30 16:00:18 millert Exp $";
d182 1
a182 1
			if (prefix != NULL)
d188 1
d199 7
a205 7
	if (prefix != NULL)
		while (count > 0) {
			if (fgets(line, sizeof(line), ibuf) == NULL) {
				c = 0;
				break;
			}
			count -= c = strlen(line);
a214 12
			(void)fwrite(line, sizeof(*line), c, obuf);
			if (ferror(obuf))
				return(-1);
		}
	else
		while (count > 0) {
			c = count < LINESIZE ? count : LINESIZE;
			if ((c = fread(line, sizeof(*line), c, ibuf)) <= 0)
				break;
			count -= c;
			if (fwrite(line, sizeof(*line), c, obuf) != c)
				return(-1);
d216 12
d319 1
a319 1
	if (fsize(mtf) == 0)
d324 1
a550 1
	int i;
d559 11
a569 2
	while ((i = fread(buf, 1, sizeof(buf), fi)) > 0)
		(void)fwrite(buf, 1, i, fo);
@


1.11
log
@warnx?/errx? paranoia (use "%s" not a bare string unless it is a
constant).  These are not security holes but it is worth fixing
them anyway both for robustness and so folks looking for examples
in the tree are not misled into doing something potentially dangerous.
Furthermore, it is a bad idea to assume that pathnames will not
include '%' in them and that error routines don't return strings
with '%' in them (especially in light of the possibility of locales).
@
text
@d1 1
a1 1
/*	$OpenBSD: send.c,v 1.10 2000/04/26 15:47:31 millert Exp $	*/
d41 1
a41 1
static char rcsid[] = "$OpenBSD: send.c,v 1.10 2000/04/26 15:47:31 millert Exp $";
d349 1
a349 1
	namelist = unpack(cat(hp->h_smopts, to));
@


1.10
log
@Change the name of mail's send() function to sendmessages() to
avoid shadowing the libc send(2); gadams@@avernus.com
@
text
@d1 1
a1 1
/*	$OpenBSD: send.c,v 1.9 1997/11/14 00:23:57 millert Exp $	*/
d41 1
a41 1
static char rcsid[] = "$OpenBSD: send.c,v 1.9 1997/11/14 00:23:57 millert Exp $";
d388 1
a388 1
		warn(cp);
d442 1
a442 1
		warn(tempname);
d446 1
a446 1
		warn(tempname);
d465 1
a465 1
		warn(tempname);
d553 1
a553 1
		warn(name);
d563 1
a563 1
		warn(name);
@


1.10.2.1
log
@Pull in patch from current (even more to come):
Fix (millert):
warnx?/errx? paranoia (use "%s" not a bare string unless it is a
constant).  These are not security holes but it is worth fixing
them anyway both for robustness and so folks looking for examples
in the tree are not misled into doing something potentially dangerous.
Furthermore, it is a bad idea to assume that pathnames will not
include '%' in them and that error routines don't return strings
with '%' in them (especially in light of the possibility of locales).
@
text
@d1 1
a1 1
/*	$OpenBSD: send.c,v 1.11 2000/06/30 16:00:18 millert Exp $	*/
d41 1
a41 1
static char rcsid[] = "$OpenBSD: send.c,v 1.11 2000/06/30 16:00:18 millert Exp $";
d388 1
a388 1
		warn("%s", cp);
d442 1
a442 1
		warn("%s", tempname);
d446 1
a446 1
		warn("%s", tempname);
d465 1
a465 1
		warn("%s", tempname);
d553 1
a553 1
		warn("%s", name);
d563 1
a563 1
		warn("%s", name);
@


1.9
log
@NetBSD changes (mostly comsmetic):
    replace panic() with calls to err()/errx()
    use S_IS* instead of doing by hand with S_IF*.
    Use TIMESPEC_TO_TIMEVAL() and gettimeofday instead of time(2)
    Use _POSIX_VDISABLE, not 0
    Kill register
@
text
@d1 1
a1 1
/*	$OpenBSD: send.c,v 1.8 1997/07/24 17:27:13 millert Exp $	*/
d41 1
a41 1
static char rcsid[] = "$OpenBSD: send.c,v 1.8 1997/07/24 17:27:13 millert Exp $";
d62 1
a62 1
send(mp, obuf, doign, prefix)
@


1.8
log
@tempnam(3) goes bye bye.
@
text
@d1 1
a1 1
/*	$OpenBSD: send.c,v 1.7 1997/07/22 18:54:41 millert Exp $	*/
d41 1
a41 1
static char rcsid[] = "$OpenBSD: send.c,v 1.7 1997/07/22 18:54:41 millert Exp $";
d63 1
a63 1
	register struct message *mp;
d69 1
a69 1
	register FILE *ibuf;
d72 2
a73 2
	register char *cp, *cp2;
	register int c = 0;
d239 1
a239 1
	register struct message *mp;
d244 1
a244 1
	register char *cp = statout;
d408 1
a408 1
	register struct name *np;
d434 1
a434 1
	register FILE *nfo, *nfi;
d487 1
a487 1
	register int gotcha;
d509 1
a509 1
	register struct name *np;
d513 1
a513 1
	register col, len;
d545 1
a545 1
	register FILE *fi;
d547 1
a547 1
	register FILE *fo;
d549 1
a549 1
	register i;
@


1.7
log
@grabh() now returns SIGINT if it was interrupted (previously always
    returned 0 and the return val was always ignored).
Add gethfromtty() to get a header (using grabh) from the tty and
    quit on two ^C's.
Use gethfromtty() when getting Subject, Cc, and Bcc headers so
    we can quit nicely.  Closes PR #291.
Don't use longs where it doesn't make sense.
@
text
@d1 1
a1 1
/*	$OpenBSD: send.c,v 1.6 1997/07/14 15:56:25 millert Exp $	*/
d41 1
a41 1
static char rcsid[] = "$OpenBSD: send.c,v 1.6 1997/07/14 15:56:25 millert Exp $";
a433 1
	extern char *tempMail;
d435 2
a436 1
	register int c;
d438 5
a442 2
	if ((nfo = Fopen(tempMail, "w")) == NULL) {
		warn(tempMail);
d445 2
a446 2
	if ((nfi = Fopen(tempMail, "r")) == NULL) {
		warn(tempMail);
d448 1
d451 1
a451 1
	(void)rm(tempMail);
d465 1
a465 1
		warn(tempMail);
@


1.6
log
@Convert remaining sigsetmask() -> sigprocmask() (POSIX style)
in collect.c and fix up some signal botches elsewhere.
@
text
@d1 1
a1 1
/*	$OpenBSD: send.c,v 1.5 1997/07/14 00:24:30 millert Exp $	*/
d41 1
a41 1
static char rcsid[] = "$OpenBSD: send.c,v 1.5 1997/07/14 00:24:30 millert Exp $";
d68 1
a68 1
	long count;
a317 10
	if (value("interactive") != NULL)
		if (value("askcc") != NULL || value("askbcc") != NULL) {
			if (value("askcc") != NULL)
				grabh(hp, GCC);
			if (value("askbcc") != NULL)
				grabh(hp, GBCC);
		} else {
			puts("EOT");
			(void)fflush(stdout);
		}
@


1.5
log
@NOSTR -> NULL
Use sigsetjmp/siglongjmp instead of sigjmp/longjmp for portability.
@
text
@d1 1
a1 1
/*	$OpenBSD: send.c,v 1.4 1997/07/13 23:54:02 millert Exp $	*/
d41 1
a41 1
static char rcsid[] = "$OpenBSD: send.c,v 1.4 1997/07/13 23:54:02 millert Exp $";
d384 1
@


1.4
log
@bcopy() -> memcpy() and fix some casts.
@
text
@d1 1
a1 1
/*	$OpenBSD: send.c,v 1.3 1997/07/13 21:21:16 millert Exp $	*/
d41 1
a41 1
static char rcsid[] = "$OpenBSD: send.c,v 1.3 1997/07/13 21:21:16 millert Exp $";
d80 1
a80 1
	if (prefix != NOSTR) {
d182 1
a182 1
			if (prefix != NOSTR)
d198 1
a198 1
	if (prefix != NOSTR)
d253 1
a253 1
			prefix == NOSTR ? "" : prefix, statout);
d289 1
a289 1
	head.h_subject = NOSTR;
d318 3
a320 3
	if (value("interactive") != NOSTR)
		if (value("askcc") != NOSTR || value("askbcc") != NOSTR) {
			if (value("askcc") != NOSTR)
d322 1
a322 1
			if (value("askbcc") != NOSTR)
d329 1
a329 1
		if (hp->h_subject == NOSTR)
d364 1
a364 1
		for (t = namelist; *t != NOSTR; t++)
d369 1
a369 1
	if ((cp = value("record")) != NOSTR)
d392 1
a392 1
		if ((cp = value("sendmail")) != NOSTR)
d400 1
a400 1
	if (value("verbose") != NOSTR)
d497 1
a497 1
	if (hp->h_subject != NOSTR && w & GSUBJECT)
@


1.3
log
@Merge in NetBSD and 4.4BSD-lite2 changes as well as some of my own.
 - handle long lines safely (from NetBSD)
 - use puts/fputs and putchar/putc when it makes sense
 - use err/errx and warn/warnx when it makes sense
 - make return() and sizeof() style consisten
 - some more buffer safety
@
text
@d1 1
a1 1
/*	$OpenBSD: send.c,v 1.2 1996/06/11 12:53:50 deraadt Exp $	*/
d41 1
a41 1
static char rcsid[] = "$OpenBSD: send.c,v 1.2 1996/06/11 12:53:50 deraadt Exp $";
d148 1
a148 1
					(void) putc('\n', obuf);
d186 1
a186 1
					(void) fwrite(prefix, sizeof(*prefix),
d188 1
a188 1
			(void) fwrite(line, sizeof(*line), length, obuf);
d212 1
a212 1
				(void) fwrite(prefix, sizeof(*prefix),
d214 1
a214 1
			(void) fwrite(line, sizeof(*line), c, obuf);
d326 1
a326 1
			(void) fflush(stdout);
d370 1
a370 1
		(void) savemail(expand(cp), mtf);
d401 1
a401 1
		(void) wait_child(pid);
d456 2
a457 2
	(void) rm(tempMail);
	(void) puthead(hp, nfo, GTO|GSUBJECT|GCC|GBCC|GNL|GCOMMA);
d460 1
a460 1
		(void) putc(c, nfo);
d468 1
a468 1
	(void) fflush(nfo);
d504 1
a504 1
		(void) putc('\n', fo);
d561 1
a561 1
	(void) time(&now);
d564 3
a566 3
		(void) fwrite(buf, 1, i, fo);
	(void) putc('\n', fo);
	(void) fflush(fo);
@


1.2
log
@from christos;
- Fix PR/105: Implement dot locking protocol and check return value of flock.
- Fix PR/2247: Don't call unknown users "ubluit". Issue an error message.
- Fix/add prototypes.
- Fix warnings.
- Use POSIX signal mask calls.
@
text
@d1 1
a1 1
/*	$OpenBSD: send.c,v 1.6 1996/06/08 19:48:39 christos Exp $	*/
d41 1
a41 1
static char rcsid[] = "$OpenBSD: send.c,v 1.6 1996/06/08 19:48:39 christos Exp $";
d97 1
a97 1
		if (fgets(line, LINESIZE, ibuf) == NULL)
d101 1
a101 1
			/* 
d186 1
a186 1
					(void) fwrite(prefix, sizeof *prefix,
d188 1
a188 1
			(void) fwrite(line, sizeof *line, length, obuf);
d190 1
a190 1
				return -1;
d200 1
a200 1
			if (fgets(line, LINESIZE, ibuf) == NULL) {
d212 1
a212 1
				(void) fwrite(prefix, sizeof *prefix,
d214 1
a214 1
			(void) fwrite(line, sizeof *line, c, obuf);
d216 1
a216 1
				return -1;
d221 1
a221 1
			if ((c = fread(line, sizeof *line, c, ibuf)) <= 0)
d224 2
a225 2
			if (fwrite(line, sizeof *line, c, obuf) != c)
				return -1;
d230 2
a231 2
			return -1;
	return 0;
d325 1
a325 1
			printf("EOT\n");
d330 1
a330 1
			printf("No message, no subject; hope that's ok\n");
d332 1
a332 1
			printf("Null message body; hope that's ok\n");
d341 1
a341 1
		printf("No recipients specified\n");
d356 1
a356 1
		fprintf(stderr, ". . . message lost, sorry.\n");
d363 1
a363 1
		printf("Sendmail arguments:");
d366 1
a366 1
		printf("\n");
d378 1
a378 1
		perror("fork");
d397 1
a397 1
		perror(cp);
d405 1
a405 1
	(void) Fclose(mtf);
d448 1
a448 1
		perror(tempMail);
d452 2
a453 2
		perror(tempMail);
		(void) Fclose(nfo);
d464 1
a464 1
		perror("read");
d470 3
a472 3
		perror(tempMail);
		(void) Fclose(nfo);
		(void) Fclose(nfi);
d476 2
a477 2
	(void) Fclose(nfo);
	(void) Fclose(fi);
d558 2
a559 2
		perror(name);
		return (-1);
d563 1
a563 1
	while ((i = fread(buf, 1, sizeof buf, fi)) > 0)
d568 2
a569 2
		perror(name);
	(void) Fclose(fo);
d571 1
a571 1
	return (0);
@


1.1
log
@Initial revision
@
text
@d1 3
d38 5
a42 2
static char sccsid[] = "from: @@(#)send.c	8.1 (Berkeley) 6/6/93";
static char rcsid[] = "$Id: send.c,v 1.5 1994/11/28 20:03:38 jtc Exp $";
d71 1
a71 1
	int ishead, infld, ignoring, dostat, firstline;
d73 1
a73 1
	register int c;
d75 1
a75 1
	int prefixlen;
d282 2
a283 2
sendmail(str)
	char *str;
d285 1
d383 9
a391 3
		prepare_child(sigmask(SIGHUP)|sigmask(SIGINT)|sigmask(SIGQUIT)|
			sigmask(SIGTSTP)|sigmask(SIGTTIN)|sigmask(SIGTTOU),
			fileno(mtf), -1);
d555 1
a555 2
	time_t now, time();
	char *ctime();
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@
