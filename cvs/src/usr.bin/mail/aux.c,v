head	1.29;
access;
symbols
	OPENBSD_6_2_BASE:1.29
	OPENBSD_6_1:1.29.0.8
	OPENBSD_6_1_BASE:1.29
	OPENBSD_6_0:1.29.0.4
	OPENBSD_6_0_BASE:1.29
	OPENBSD_5_9:1.29.0.2
	OPENBSD_5_9_BASE:1.29
	OPENBSD_5_8:1.27.0.6
	OPENBSD_5_8_BASE:1.27
	OPENBSD_5_7:1.27.0.2
	OPENBSD_5_7_BASE:1.27
	OPENBSD_5_6:1.26.0.6
	OPENBSD_5_6_BASE:1.26
	OPENBSD_5_5:1.26.0.4
	OPENBSD_5_5_BASE:1.26
	OPENBSD_5_4:1.25.0.16
	OPENBSD_5_4_BASE:1.25
	OPENBSD_5_3:1.25.0.14
	OPENBSD_5_3_BASE:1.25
	OPENBSD_5_2:1.25.0.12
	OPENBSD_5_2_BASE:1.25
	OPENBSD_5_1_BASE:1.25
	OPENBSD_5_1:1.25.0.10
	OPENBSD_5_0:1.25.0.8
	OPENBSD_5_0_BASE:1.25
	OPENBSD_4_9:1.25.0.6
	OPENBSD_4_9_BASE:1.25
	OPENBSD_4_8:1.25.0.4
	OPENBSD_4_8_BASE:1.25
	OPENBSD_4_7:1.25.0.2
	OPENBSD_4_7_BASE:1.25
	OPENBSD_4_6:1.24.0.8
	OPENBSD_4_6_BASE:1.24
	OPENBSD_4_5:1.24.0.4
	OPENBSD_4_5_BASE:1.24
	OPENBSD_4_4:1.24.0.2
	OPENBSD_4_4_BASE:1.24
	OPENBSD_4_3:1.22.0.14
	OPENBSD_4_3_BASE:1.22
	OPENBSD_4_2:1.22.0.12
	OPENBSD_4_2_BASE:1.22
	OPENBSD_4_1:1.22.0.10
	OPENBSD_4_1_BASE:1.22
	OPENBSD_4_0:1.22.0.8
	OPENBSD_4_0_BASE:1.22
	OPENBSD_3_9:1.22.0.6
	OPENBSD_3_9_BASE:1.22
	OPENBSD_3_8:1.22.0.4
	OPENBSD_3_8_BASE:1.22
	OPENBSD_3_7:1.22.0.2
	OPENBSD_3_7_BASE:1.22
	OPENBSD_3_6:1.21.0.6
	OPENBSD_3_6_BASE:1.21
	OPENBSD_3_5:1.21.0.4
	OPENBSD_3_5_BASE:1.21
	OPENBSD_3_4:1.21.0.2
	OPENBSD_3_4_BASE:1.21
	OPENBSD_3_3:1.20.0.6
	OPENBSD_3_3_BASE:1.20
	OPENBSD_3_2:1.20.0.4
	OPENBSD_3_2_BASE:1.20
	OPENBSD_3_1:1.20.0.2
	OPENBSD_3_1_BASE:1.20
	OPENBSD_3_0:1.18.0.2
	OPENBSD_3_0_BASE:1.18
	OPENBSD_2_9_BASE:1.16
	OPENBSD_2_9:1.16.0.2
	OPENBSD_2_8:1.15.0.2
	OPENBSD_2_8_BASE:1.15
	OPENBSD_2_7:1.14.0.2
	OPENBSD_2_7_BASE:1.14
	OPENBSD_2_6:1.13.0.8
	OPENBSD_2_6_BASE:1.13
	OPENBSD_2_5:1.13.0.6
	OPENBSD_2_5_BASE:1.13
	OPENBSD_2_4:1.13.0.4
	OPENBSD_2_4_BASE:1.13
	OPENBSD_2_3:1.13.0.2
	OPENBSD_2_3_BASE:1.13
	OPENBSD_2_2:1.12.0.2
	OPENBSD_2_2_BASE:1.12
	OPENBSD_2_1:1.3.0.2
	OPENBSD_2_1_BASE:1.3
	OPENBSD_2_0:1.2.0.2
	OPENBSD_2_0_BASE:1.2
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.29
date	2015.10.16.17.56.07;	author mmcc;	state Exp;
branches;
next	1.28;
commitid	y3aqfd1wS5RZj9kl;

1.28
date	2015.10.13.08.49.51;	author guenther;	state Exp;
branches;
next	1.27;
commitid	V0DBtEuIAZDZl3vX;

1.27
date	2015.01.16.06.40.09;	author deraadt;	state Exp;
branches;
next	1.26;
commitid	Uu5nFG3wCl0LACBb;

1.26
date	2014.01.17.18.42.30;	author okan;	state Exp;
branches;
next	1.25;

1.25
date	2009.10.27.23.59.40;	author deraadt;	state Exp;
branches;
next	1.24;

1.24
date	2008.07.16.14.53.41;	author martynas;	state Exp;
branches;
next	1.23;

1.23
date	2008.07.15.19.23.26;	author martynas;	state Exp;
branches;
next	1.22;

1.22
date	2004.09.15.22.21.40;	author deraadt;	state Exp;
branches;
next	1.21;

1.21
date	2003.06.03.02.56.11;	author millert;	state Exp;
branches;
next	1.20;

1.20
date	2001.11.21.15.26.39;	author millert;	state Exp;
branches;
next	1.19;

1.19
date	2001.11.20.20.50.00;	author millert;	state Exp;
branches;
next	1.18;

1.18
date	2001.09.16.16.12.56;	author millert;	state Exp;
branches;
next	1.17;

1.17
date	2001.09.16.15.27.32;	author millert;	state Exp;
branches;
next	1.16;

1.16
date	2001.01.16.05.36.08;	author millert;	state Exp;
branches;
next	1.15;

1.15
date	2000.06.30.16.00.18;	author millert;	state Exp;
branches;
next	1.14;

1.14
date	2000.04.25.16.42.22;	author millert;	state Exp;
branches
	1.14.2.1;
next	1.13;

1.13
date	97.11.14.00.23.41;	author millert;	state Exp;
branches;
next	1.12;

1.12
date	97.08.04.17.30.22;	author millert;	state Exp;
branches;
next	1.11;

1.11
date	97.07.31.02.36.32;	author millert;	state Exp;
branches;
next	1.10;

1.10
date	97.07.30.07.19.29;	author millert;	state Exp;
branches;
next	1.9;

1.9
date	97.07.28.15.20.28;	author millert;	state Exp;
branches;
next	1.8;

1.8
date	97.07.25.21.05.33;	author mickey;	state Exp;
branches;
next	1.7;

1.7
date	97.07.14.00.24.24;	author millert;	state Exp;
branches;
next	1.6;

1.6
date	97.07.13.23.53.56;	author millert;	state Exp;
branches;
next	1.5;

1.5
date	97.07.13.21.21.08;	author millert;	state Exp;
branches;
next	1.4;

1.4
date	97.05.30.08.51.32;	author deraadt;	state Exp;
branches;
next	1.3;

1.3
date	97.01.17.07.12.44;	author millert;	state Exp;
branches;
next	1.2;

1.2
date	96.06.11.12.53.32;	author deraadt;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.45.37;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.45.37;	author deraadt;	state Exp;
branches;
next	;

1.14.2.1
date	2000.10.06.21.16.15;	author jason;	state Exp;
branches;
next	;


desc
@@


1.29
log
@Modernize allocation by:

 * removing unneeded casts of void* return values
 * replacing varied and creative error messages with the allocation
   function's name
 * replacing errx() with err() so that the errno string is reported

ok beck@@, jung@@, millert@@
@
text
@/*	$OpenBSD: aux.c,v 1.28 2015/10/13 08:49:51 guenther Exp $	*/
/*	$NetBSD: aux.c,v 1.5 1997/05/13 06:15:52 mikel Exp $	*/

/*
 * Copyright (c) 1980, 1993
 *	The Regents of the University of California.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */

#include "rcv.h"
#include <fcntl.h>
#include "extern.h"

/*
 * Mail -- a mail program
 *
 * Auxiliary functions.
 */
static char *save2str(char *, char *);

/*
 * Return a pointer to a dynamic copy of the argument.
 */
char *
savestr(char *str)
{
	char *new;
	int size = strlen(str) + 1;

	if ((new = salloc(size)) != NULL)
		(void)memcpy(new, str, size);
	return(new);
}

/*
 * Make a copy of new argument incorporating old one.
 */
static char *
save2str(char *str, char *old)
{
	char *new;
	int newsize = strlen(str) + 1;
	int oldsize = old ? strlen(old) + 1 : 0;

	if ((new = salloc(newsize + oldsize)) != NULL) {
		if (oldsize) {
			(void)memcpy(new, old, oldsize);
			new[oldsize - 1] = ' ';
		}
		(void)memcpy(new + oldsize, str, newsize);
	}
	return(new);
}

/*
 * Touch the named message by setting its MTOUCH flag.
 * Touched messages have the effect of not being sent
 * back to the system mailbox on exit.
 */
void
touch(struct message *mp)
{

	mp->m_flag |= MTOUCH;
	if ((mp->m_flag & MREAD) == 0)
		mp->m_flag |= MREAD|MSTATUS;
}

/*
 * Test to see if the passed file name is a directory.
 * Return true if it is.
 */
int
isdir(char *name)
{
	struct stat sbuf;

	if (stat(name, &sbuf) < 0)
		return(0);
	return(S_ISDIR(sbuf.st_mode));
}

/*
 * Count the number of arguments in the given string raw list.
 */
int
argcount(char **argv)
{
	char **ap;

	for (ap = argv; *ap++ != NULL;)
		;	
	return(ap - argv - 1);
}

/*
 * Return the desired header line from the passed message
 * pointer (or NULL if the desired header field is not available).
 */
char *
hfield(char *field, struct message *mp)
{
	FILE *ibuf;
	char linebuf[LINESIZE];
	int lc;
	char *hfield;
	char *colon, *oldhfield = NULL;

	ibuf = setinput(mp);
	if ((lc = mp->m_lines - 1) < 0)
		return(NULL);
	if (readline(ibuf, linebuf, LINESIZE, NULL) < 0)
		return(NULL);
	while (lc > 0) {
		if ((lc = gethfield(ibuf, linebuf, lc, &colon)) < 0)
			return(oldhfield);
		if ((hfield = ishfield(linebuf, colon, field)) != NULL)
			oldhfield = save2str(hfield, oldhfield);
	}
	return(oldhfield);
}

/*
 * Return the next header field found in the given message.
 * Return >= 0 if something found, < 0 elsewise.
 * "colon" is set to point to the colon in the header.
 * Must deal with \ continuations & other such fraud.
 */
int
gethfield(FILE *f, char *linebuf, int rem, char **colon)
{
	char line2[LINESIZE];
	char *cp, *cp2;
	int c;

	for (;;) {
		if (--rem < 0)
			return(-1);
		if ((c = readline(f, linebuf, LINESIZE, NULL)) <= 0)
			return(-1);
		for (cp = linebuf;
		    isprint((unsigned char)*cp) && *cp != ' ' && *cp != ':';
		    cp++)
			;
		if (*cp != ':' || cp == linebuf)
			continue;
		/*
		 * I guess we got a headline.
		 * Handle wraparounding
		 */
		*colon = cp;
		cp = linebuf + c;
		for (;;) {
			while (--cp >= linebuf && (*cp == ' ' || *cp == '\t'))
				;
			cp++;
			if (rem <= 0)
				break;
			ungetc(c = getc(f), f);
			if (c != ' ' && c != '\t')
				break;
			if ((c = readline(f, line2, LINESIZE, NULL)) < 0)
				break;
			rem--;
			for (cp2 = line2; *cp2 == ' ' || *cp2 == '\t'; cp2++)
				;
			c -= cp2 - line2;
			if (cp + c >= linebuf + LINESIZE - 2)
				break;
			*cp++ = ' ';
			(void)memcpy(cp, cp2, c);
			cp += c;
		}
		*cp = 0;
		return(rem);
	}
	/* NOTREACHED */
}

/*
 * Check whether the passed line is a header line of
 * the desired breed.  Return the field body, or 0.
 */

char*
ishfield(char *linebuf, char *colon, char *field)
{
	char *cp = colon;

	*cp = 0;
	if (strcasecmp(linebuf, field) != 0) {
		*cp = ':';
		return(0);
	}
	*cp = ':';
	for (cp++; *cp == ' ' || *cp == '\t'; cp++)
		;
	return(cp);
}

/*
 * Copy a string, lowercasing it as we go.  ``dsize'' should be
 * the real size (not len) of the dest string (guarantee NUL term).
 */
size_t
istrlcpy(char *dst, const char *src, size_t dsize)
{
	char *d = dst;
	const char *s = src;
	size_t n = dsize;

	/* Copy as many bytes as will fit */
	if (n != 0 && --n != 0) {
		do {
			if ((*d++ = tolower((unsigned char)*s++)) == 0)
				break;
		} while (--n != 0);
	}

	/* Not enough room in dst, add NUL and traverse rest of src */
	if (n == 0) {
		if (dsize != 0)
			*d = '\0';		/* NUL-terminate dst */
		while (*s++)
			;
	}

	return(s - src - 1);	/* count does not include NUL */
}

/*
 * The following code deals with input stacking to do source
 * commands.  All but the current file pointer are saved on
 * the stack.
 */
static	int	ssp;			/* Top of file stack */
struct sstack {
	FILE	*s_file;		/* File we were in. */
	int	s_cond;			/* Saved state of conditionals */
	int	s_loading;		/* Loading .mailrc, etc. */
} sstack[OPEN_MAX];

/*
 * Pushdown current input file and switch to a new one.
 * Set the global flag "sourcing" so that others will realize
 * that they are no longer reading from a tty (in all probability).
 */
int
source(void *v)
{
	char **arglist = v;
	FILE *fi;
	char *cp;

	if ((cp = expand(*arglist)) == NULL)
		return(1);
	if ((fi = Fopen(cp, "r")) == NULL) {
		warn("%s", cp);
		return(1);
	}
	if (ssp >= OPEN_MAX - 1) {
		puts("Too much \"sourcing\" going on.");
		(void)Fclose(fi);
		return(1);
	}
	sstack[ssp].s_file = input;
	sstack[ssp].s_cond = cond;
	sstack[ssp].s_loading = loading;
	ssp++;
	loading = 0;
	cond = CANY;
	input = fi;
	sourcing++;
	return(0);
}

/*
 * Pop the current input back to the previous level.
 * Update the "sourcing" flag as appropriate.
 */
int
unstack(void)
{

	if (ssp <= 0) {
		puts("\"Source\" stack over-pop.");
		sourcing = 0;
		return(1);
	}
	(void)Fclose(input);
	if (cond != CANY)
		puts("Unmatched \"if\"");
	ssp--;
	cond = sstack[ssp].s_cond;
	loading = sstack[ssp].s_loading;
	input = sstack[ssp].s_file;
	if (ssp == 0)
		sourcing = loading;
	return(0);
}

/*
 * Touch the indicated file.
 * This is nifty for the shell.
 */
void
alter(char *name)
{
	struct timespec ts[2];

	clock_gettime(CLOCK_REALTIME, &ts[0]);
	ts[0].tv_sec++;
	ts[1].tv_nsec = UTIME_OMIT;
	(void)utimensat(AT_FDCWD, name, ts, 0);
}

/*
 * Examine the passed line buffer and
 * return true if it is all blanks and tabs.
 */
int
blankline(char *linebuf)
{
	char *cp;

	for (cp = linebuf; *cp; cp++)
		if (*cp != ' ' && *cp != '\t')
			return(0);
	return(1);
}

/*
 * Get sender's name from this message.  If the message has
 * a bunch of arpanet stuff in it, we may have to skin the name
 * before returning it.
 */
char *
nameof(struct message *mp, int reptype)
{
	char *cp, *cp2;

	cp = skin(name1(mp, reptype));
	if (reptype != 0 || charcount(cp, '!') < 2)
		return(cp);
	cp2 = strrchr(cp, '!');
	cp2--;
	while (cp2 > cp && *cp2 != '!')
		cp2--;
	if (*cp2 == '!')
		return(cp2 + 1);
	return(cp);
}

/*
 * Start of a "comment".
 * Ignore it.
 */
char *
skip_comment(char *cp)
{
	int nesting = 1;

	for (; nesting > 0 && *cp; cp++) {
		switch (*cp) {
		case '\\':
			if (cp[1])
				cp++;
			break;
		case '(':
			nesting++;
			break;
		case ')':
			nesting--;
			break;
		}
	}
	return(cp);
}

/*
 * Skin an arpa net address according to the RFC 822 interpretation
 * of "host-phrase."
 */
char *
skin(char *name)
{
	char *nbuf, *bufend, *cp, *cp2;
	int c, gotlt, lastsp;

	if (name == NULL)
		return(NULL);
	if (strchr(name, '(') == NULL && strchr(name, '<') == NULL
	    && strchr(name, ' ') == NULL)
		return(name);

	/* We assume that length(input) <= length(output) */
	if ((nbuf = malloc(strlen(name) + 1)) == NULL)
		err(1, "malloc");
	gotlt = 0;
	lastsp = 0;
	bufend = nbuf;
	for (cp = name, cp2 = bufend; (c = (unsigned char)*cp++) != '\0'; ) {
		switch (c) {
		case '(':
			cp = skip_comment(cp);
			lastsp = 0;
			break;

		case '"':
			/*
			 * Start of a "quoted-string".
			 * Copy it in its entirety.
			 */
			while ((c = (unsigned char)*cp) != '\0') {
				cp++;
				if (c == '"')
					break;
				if (c != '\\')
					*cp2++ = c;
				else if ((c = (unsigned char)*cp) != '\0') {
					*cp2++ = c;
					cp++;
				}
			}
			lastsp = 0;
			break;

		case ' ':
			if (strncmp(cp, "at ", 3) == 0)
				cp += 3, *cp2++ = '@@';
			else
			if (strncmp(cp, "@@ ", 2) == 0)
				cp += 2, *cp2++ = '@@';
			else
				lastsp = 1;
			break;

		case '<':
			cp2 = bufend;
			gotlt++;
			lastsp = 0;
			break;

		case '>':
			if (gotlt) {
				gotlt = 0;
				while ((c = (unsigned char)*cp) && c != ',') {
					cp++;
					if (c == '(')
						cp = skip_comment(cp);
					else if (c == '"')
						while ((c = (unsigned char)*cp) != '\0') {
							cp++;
							if (c == '"')
								break;
							if (c == '\\' && *cp)
								cp++;
						}
				}
				lastsp = 0;
				break;
			}
			/* Fall into . . . */

		default:
			if (lastsp) {
				lastsp = 0;
				*cp2++ = ' ';
			}
			*cp2++ = c;
			if (c == ',' && *cp == ' ' && !gotlt) {
				*cp2++ = ' ';
				while (*++cp == ' ')
					;
				lastsp = 0;
				bufend = cp2;
			}
		}
	}
	*cp2 = 0;

	if ((cp = realloc(nbuf, strlen(nbuf) + 1)) != NULL)
		nbuf = cp;
	return(nbuf);
}

/*
 * Fetch the sender's name from the passed message.
 * Reptype can be
 *	0 -- get sender's name for display purposes
 *	1 -- get sender's name for reply
 *	2 -- get sender's name for Reply
 */
char *
name1(struct message *mp, int reptype)
{
	char namebuf[LINESIZE];
	char linebuf[LINESIZE];
	char *cp, *cp2;
	FILE *ibuf;
	int first = 1;

	if ((cp = hfield("from", mp)) != NULL)
		return(cp);
	if (reptype == 0 && (cp = hfield("sender", mp)) != NULL)
		return(cp);
	ibuf = setinput(mp);
	namebuf[0] = '\0';
	if (readline(ibuf, linebuf, LINESIZE, NULL) < 0)
		return(savestr(namebuf));
newname:
	for (cp = linebuf; *cp && *cp != ' '; cp++)
		;
	for (; *cp == ' ' || *cp == '\t'; cp++)
		;
	for (cp2 = &namebuf[strlen(namebuf)];
	     *cp && *cp != ' ' && *cp != '\t' && cp2 < namebuf + LINESIZE - 1;)
		*cp2++ = *cp++;
	*cp2 = '\0';
	if (readline(ibuf, linebuf, LINESIZE, NULL) < 0)
		return(savestr(namebuf));
	if ((cp = strchr(linebuf, 'F')) == NULL)
		return(savestr(namebuf));
	if (strncmp(cp, "From", 4) != 0)
		return(savestr(namebuf));
	while ((cp = strchr(cp, 'r')) != NULL) {
		if (strncmp(cp, "remote", 6) == 0) {
			if ((cp = strchr(cp, 'f')) == NULL)
				break;
			if (strncmp(cp, "from", 4) != 0)
				break;
			if ((cp = strchr(cp, ' ')) == NULL)
				break;
			cp++;
			if (first) {
				cp2 = namebuf;
				first = 0;
			} else
				cp2 = strrchr(namebuf, '!') + 1;
			strlcpy(cp2, cp, sizeof(namebuf) - (cp2 - namebuf) - 1);
			strlcat(namebuf, "!", sizeof(namebuf));
			goto newname;
		}
		cp++;
	}
	return(savestr(namebuf));
}

/*
 * Count the occurances of c in str
 */
int
charcount(char *str, int c)
{
	char *cp;
	int i;

	for (i = 0, cp = str; *cp; cp++)
		if (*cp == c)
			i++;
	return(i);
}

/*
 * Copy s1 to s2, return pointer to null in s2.
 */
char *
copy(char *s1, char *s2)
{

	while ((*s2++ = *s1++) != '\0')
		;
	return(s2 - 1);
}

/*
 * See if the given header field is supposed to be ignored.
 */
int
isign(char *field, struct ignoretab ignore[2])
{
	char realfld[LINESIZE];

	if (ignore == ignoreall)
		return(1);
	/*
	 * Lower-case the string, so that "Status" and "status"
	 * will hash to the same place.
	 */
	istrlcpy(realfld, field, sizeof(realfld));
	if (ignore[1].i_count > 0)
		return(!member(realfld, ignore + 1));
	else
		return(member(realfld, ignore));
}

int
member(char *realfield, struct ignoretab *table)
{
	struct ignore *igp;

	for (igp = table->i_head[hash(realfield)]; igp != 0; igp = igp->i_link)
		if (*igp->i_field == *realfield &&
		    equal(igp->i_field, realfield))
			return(1);
	return(0);
}

void
clearnew(void)
{
	struct message *mp;

	for (mp = &message[0]; mp < &message[msgCount]; mp++) {
		if (mp->m_flag & MNEW) {
			mp->m_flag &= ~MNEW;
			mp->m_flag |= MSTATUS;
		}
	}
}
@


1.28
log
@To alter just the atime of the mailspool, use utimensat()+UTIME_OMIT instead
of stat()+utimes().  Prefer clock_gettime() over gettimeofday() to avoid
timeval->timespec conversion

ok millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: aux.c,v 1.27 2015/01/16 06:40:09 deraadt Exp $	*/
d420 2
a421 2
	if ((nbuf = (char *)malloc(strlen(name) + 1)) == NULL)
		errx(1, "Out of memory");
d505 1
a505 1
	if ((cp = (char *)realloc(nbuf, strlen(nbuf) + 1)) != NULL)
@


1.27
log
@Replace <sys/param.h> with <limits.h> and other less dirty headers where
possible.  Annotate <sys/param.h> lines with their current reasons.  Switch
to PATH_MAX, NGROUPS_MAX, HOST_NAME_MAX+1, LOGIN_NAME_MAX, etc.  Change
MIN() and MAX() to local definitions of MINIMUM() and MAXIMUM() where
sensible to avoid pulling in the pollution.  These are the files confirmed
through binary verification.
ok guenther, millert, doug (helped with the verification protocol)
@
text
@d1 1
a1 1
/*	$OpenBSD: aux.c,v 1.26 2014/01/17 18:42:30 okan Exp $	*/
d34 1
d332 1
a332 2
	struct stat sb;
	struct timeval tv[2];
d334 4
a337 10
	if (stat(name, &sb))
		return;
	(void) gettimeofday(&tv[0], (struct timezone *)0);
	tv[0].tv_sec++;
#ifdef TIMESPEC_TO_TIMEVAL
	TIMESPEC_TO_TIMEVAL(&tv[1], &sb.st_mtimespec);
#else
	tv[1].tv_sec = sb.st_mtime;
#endif
	(void)utimes(name, tv);
@


1.26
log
@ctype and other sign extension fixes.

with deraadt and millert, ok millert
@
text
@d1 1
a1 1
/*	$OpenBSD: aux.c,v 1.25 2009/10/27 23:59:40 deraadt Exp $	*/
d263 1
a263 1
} sstack[NOFILE];
d283 1
a283 1
	if (ssp >= NOFILE - 1) {
@


1.25
log
@rcsid[] and sccsid[] and copyright[] are essentially unmaintained (and
unmaintainable).  these days, people use source.  these id's do not provide
any benefit, and do hurt the small install media
(the 33,000 line diff is essentially mechanical)
ok with the idea millert, ok dms
@
text
@d1 1
a1 1
/*	$OpenBSD: aux.c,v 1.24 2008/07/16 14:53:41 martynas Exp $	*/
d163 3
a165 2
		for (cp = linebuf; isprint(*cp) && *cp != ' ' && *cp != ':';
		     cp++)
d237 1
a237 1
			if ((*d++ = tolower(*s++)) == 0)
d431 1
a431 1
	for (cp = name, cp2 = bufend; (c = *cp++) != '\0'; ) {
d443 1
a443 1
			while ((c = *cp) != '\0') {
d449 1
a449 1
				else if ((c = *cp) != '\0') {
d476 1
a476 1
				while ((c = *cp) && c != ',') {
d481 1
a481 1
						while ((c = *cp) != '\0') {
@


1.24
log
@- use strncmp/strncasecmp instead of comparing by character
- simplify istrlcpy, no need to check for isupper
- line[0] is redundant, because strcasecmp will take care of it
ok millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: aux.c,v 1.23 2008/07/15 19:23:26 martynas Exp $	*/
a31 8

#ifndef lint
#if 0
static const char sccsid[] = "@@(#)aux.c	8.1 (Berkeley) 6/6/93";
#else
static const char rcsid[] = "$OpenBSD: aux.c,v 1.23 2008/07/15 19:23:26 martynas Exp $";
#endif
#endif /* not lint */
@


1.23
log
@- chraise can be replaced with toupper;  no need to check for islower
- remove quite some code, use strcasestr instead of reimplementing
it each time
- use strncasecmp, instead of comparing through each character
"looks fine" millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: aux.c,v 1.22 2004/09/15 22:21:40 deraadt Exp $	*/
d37 1
a37 1
static const char rcsid[] = "$OpenBSD: aux.c,v 1.22 2004/09/15 22:21:40 deraadt Exp $";
d244 1
a244 3
			if (isupper(*s))
				*d++ = tolower(*s++);
			else if ((*d++ = *s++) == 0)
d465 1
a465 1
			if (cp[0] == 'a' && cp[1] == 't' && cp[2] == ' ')
d468 1
a468 1
			if (cp[0] == '@@' && cp[1] == ' ')
@


1.22
log
@avoid aliasing against libc symbols
@
text
@d1 1
a1 1
/*	$OpenBSD: aux.c,v 1.21 2003/06/03 02:56:11 millert Exp $	*/
d37 1
a37 1
static const char rcsid[] = "$OpenBSD: aux.c,v 1.21 2003/06/03 02:56:11 millert Exp $";
a599 12
}

/*
 * Convert c to upper case
 */
int
chraise(int c)
{

	if (islower(c))
		return(toupper(c));
	return(c);
@


1.21
log
@Remove the advertising clause in the UCB license which Berkeley
rescinded 22 July 1999.  Proofed by myself and Theo.
@
text
@d1 1
a1 1
/*	$OpenBSD: aux.c,v 1.20 2001/11/21 15:26:39 millert Exp $	*/
d37 1
a37 1
static const char rcsid[] = "$OpenBSD: aux.c,v 1.20 2001/11/21 15:26:39 millert Exp $";
d606 1
a606 1
raise(int c)
@


1.20
log
@o ANSIfy
o Style nits
o Use const to silent stupid -Wall warnings
o strnc{py,at} -> strlc{py,at}
o Use strpbrk() instead of homegrown anyof()
o Use NULL instead of #defines with 0 cast to a pointer
This still could use a proper audit
@
text
@d1 1
a1 1
/*	$OpenBSD: aux.c,v 1.19 2001/11/20 20:50:00 millert Exp $	*/
d16 1
a16 5
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
d37 1
a37 1
static const char rcsid[] = "$OpenBSD: aux.c,v 1.19 2001/11/20 20:50:00 millert Exp $";
@


1.19
log
@Major signal overhaul.  We no longer longjmp all over the place.
Instead, routines responsible to gathering user input (or in some
cases outputting data) catch the signals and set flags as needed.
Because of this some handlers are install without the SA_RESTART
flag so syscalls are not restarted and we can check the flag.  All
signal handlers are now safe.

This should make the flow of control a bit more grokable but the
code is still ugly.
@
text
@d1 1
a1 1
/*	$OpenBSD: aux.c,v 1.18 2001/09/16 16:12:56 millert Exp $	*/
d39 1
a39 1
static char sccsid[] = "@@(#)aux.c	8.1 (Berkeley) 6/6/93";
d41 1
a41 1
static char rcsid[] = "$OpenBSD: aux.c,v 1.18 2001/09/16 16:12:56 millert Exp $";
d53 1
a53 1
static char *save2str __P((char *, char *));
d59 1
a59 2
savestr(str)
	char *str;
d73 1
a73 2
save2str(str, old)
	char *str, *old;
d95 1
a95 2
touch(mp)
	struct message *mp;
d108 1
a108 2
isdir(name)
	char name[];
d121 1
a121 2
argcount(argv)
	char **argv;
d135 1
a135 3
hfield(field, mp)
	char field[];
	struct message *mp;
d164 1
a164 5
gethfield(f, linebuf, rem, colon)
	FILE *f;
	char linebuf[];
	int rem;
	char **colon;
d219 1
a219 3
ishfield(linebuf, colon, field)
	char linebuf[], field[];
	char *colon;
d236 1
a236 1
 * the real size (not len) of the dest string (guarantee NULL term).
d238 2
a239 4
void
istrncpy(dest, src, dsize)
	char *dest, *src;
	size_t dsize;
d241 13
d255 6
a260 8
	if (dsize != 0) {
		while (--dsize != 0 && *src != '\0') {
			if (isupper(*src))
				*dest++ = tolower(*src++);
			else
				*dest++ = *src++;
		}
		*dest = '\0';
d262 2
a270 1

d284 1
a284 2
source(v)
	void *v;
d317 1
a317 1
unstack()
d319 1
d342 1
a342 2
alter(name)
	char *name;
d364 1
a364 2
blankline(linebuf)
	char linebuf[];
d380 1
a380 3
nameof(mp, reptype)
	struct message *mp;
	int reptype;
d401 1
a401 2
skip_comment(cp)
	char *cp;
d427 1
a427 2
skin(name)
	char *name;
d537 1
a537 3
name1(mp, reptype)
	struct message *mp;
	int reptype;
d582 2
a583 3
			strncpy(cp2, cp, sizeof(namebuf) - (cp2 - namebuf) - 2);
			namebuf[sizeof(namebuf) - 2] = '\0';
			strcat(namebuf, "!");
d595 1
a595 3
charcount(str, c)
	char *str;
	int c;
a606 14
 * Are any of the characters in the two strings the same?
 */
int
anyof(s1, s2)
	char *s1, *s2;
{

	while (*s1)
		if (strchr(s2, *s1++))
			return(1);
	return(0);
}

/*
d610 1
a610 2
raise(c)
	int c;
d622 1
a622 2
copy(s1, s2)
	char *s1, *s2;
d634 1
a634 3
isign(field, ignore)
	char *field;
	struct ignoretab ignore[2];
d644 1
a644 1
	istrncpy(realfld, field, sizeof(realfld));
d652 1
a652 3
member(realfield, table)
	char *realfield;
	struct ignoretab *table;
d664 1
a664 1
clearnew()
@


1.18
log
@Optimize space-eating loop since we've already checked that the
first char is a space.  Patch from sacrificial-spam-address@@horizon.com
@
text
@d1 1
a1 1
/*	$OpenBSD: aux.c,v 1.17 2001/09/16 15:27:32 millert Exp $	*/
d41 1
a41 1
static char rcsid[] = "$OpenBSD: aux.c,v 1.17 2001/09/16 15:27:32 millert Exp $";
d153 1
a153 1
	if (readline(ibuf, linebuf, LINESIZE) < 0)
d184 1
a184 1
		if ((c = readline(f, linebuf, LINESIZE)) <= 0)
d206 1
a206 1
			if ((c = readline(f, line2, LINESIZE)) < 0)
d562 1
a562 1
	if (readline(ibuf, linebuf, LINESIZE) < 0)
d573 1
a573 1
	if (readline(ibuf, linebuf, LINESIZE) < 0)
@


1.17
log
@1) In skin(), only add a space after a comma if there is actually a space
in the input buffer.  This prevents a rare buffer overflow on very long
header lines where one or more entries has a comment in it but the
entries have no space after the comma *and* the amount of extra space
needed to add a space after each comma is greater than the length of
the comments that will be removed.  This is debian bug #108677

2) In skin(), use a temporary variable in the realloc() and don't
die if realloc() fails since its only purpose is to shrink the
buffer, not expand it (and thus is not fatal).
@
text
@d1 1
a1 1
/*	$OpenBSD: aux.c,v 1.16 2001/01/16 05:36:08 millert Exp $	*/
d41 1
a41 1
static char rcsid[] = "$OpenBSD: aux.c,v 1.16 2001/01/16 05:36:08 millert Exp $";
d524 1
a524 1
				for (; *cp == ' '; cp++)
@


1.16
log
@Changes from Don Beusee:
o escape From line with a leading '>' when needed
o only print To: address and Subject lines if actually present
o new variable 'allnet' to treat user@@foo and user@@bar as the same "user"
o folders command now takes an optional argument like ls.
o new "pipe" (|) command to pipe the message through an arbitrary command
o make header display format the same as SunOS 4.1.3 /usr/ucb/mail
o tilde commands work regardless of interactive mode.
o fix "read: Interrupted system call" error by retrying if EINTR
o expanded help file
Changes by me:
o read the help file via the PAGER as it is now more than 24 lines long
@
text
@d1 1
a1 1
/*	$OpenBSD: aux.c,v 1.15 2000/06/30 16:00:18 millert Exp $	*/
d41 1
a41 1
static char rcsid[] = "$OpenBSD: aux.c,v 1.15 2000/06/30 16:00:18 millert Exp $";
d522 1
a522 1
			if (c == ',' && !gotlt) {
d533 2
a534 2
	if ((nbuf = (char *)realloc(nbuf, strlen(nbuf) + 1)) == NULL)
		errx(1, "Out of memory");
@


1.15
log
@warnx?/errx? paranoia (use "%s" not a bare string unless it is a
constant).  These are not security holes but it is worth fixing
them anyway both for robustness and so folks looking for examples
in the tree are not misled into doing something potentially dangerous.
Furthermore, it is a bad idea to assume that pathnames will not
include '%' in them and that error routines don't return strings
with '%' in them (especially in light of the possibility of locales).
@
text
@d1 1
a1 1
/*	$OpenBSD: aux.c,v 1.14 2000/04/25 16:42:22 millert Exp $	*/
d41 1
a41 1
static char rcsid[] = "$OpenBSD: aux.c,v 1.14 2000/04/25 16:42:22 millert Exp $";
d118 1
a118 1
	return (S_ISDIR(sbuf.st_mode));
d355 1
d357 3
@


1.14
log
@When incorporating new messages, clear the "new" count before the
inc so the count of new messages is useful afterwards.  This makes
mail behave more like the SunOS version in this respect.
@
text
@d1 1
a1 1
/*	$OpenBSD: aux.c,v 1.13 1997/11/14 00:23:41 millert Exp $	*/
d41 1
a41 1
static char rcsid[] = "$OpenBSD: aux.c,v 1.13 1997/11/14 00:23:41 millert Exp $";
d297 1
a297 1
		warn(cp);
@


1.14.2.1
log
@Pull in patch from current (even more to come):
Fix (millert):
warnx?/errx? paranoia (use "%s" not a bare string unless it is a
constant).  These are not security holes but it is worth fixing
them anyway both for robustness and so folks looking for examples
in the tree are not misled into doing something potentially dangerous.
Furthermore, it is a bad idea to assume that pathnames will not
include '%' in them and that error routines don't return strings
with '%' in them (especially in light of the possibility of locales).
@
text
@d1 1
a1 1
/*	$OpenBSD: aux.c,v 1.15 2000/06/30 16:00:18 millert Exp $	*/
d41 1
a41 1
static char rcsid[] = "$OpenBSD: aux.c,v 1.15 2000/06/30 16:00:18 millert Exp $";
d297 1
a297 1
		warn("%s", cp);
@


1.13
log
@NetBSD changes (mostly comsmetic):
    replace panic() with calls to err()/errx()
    use S_IS* instead of doing by hand with S_IF*.
    Use TIMESPEC_TO_TIMEVAL() and gettimeofday instead of time(2)
    Use _POSIX_VDISABLE, not 0
    Kill register
@
text
@d1 1
a1 1
/*	$OpenBSD: aux.c,v 1.12 1997/08/04 17:30:22 millert Exp $	*/
d41 1
a41 1
static char rcsid[] = "$OpenBSD: aux.c,v 1.12 1997/08/04 17:30:22 millert Exp $";
d691 13
@


1.12
log
@Fix a problem in skin() that was introduced with the buffer oflow
fix.  Could end up realloc'ing the wrong thing.
@
text
@d1 1
a1 1
/*	$OpenBSD: aux.c,v 1.11 1997/07/31 02:36:32 millert Exp $	*/
d41 1
a41 1
static char rcsid[] = "$OpenBSD: aux.c,v 1.11 1997/07/31 02:36:32 millert Exp $";
a91 32
 * Announce a fatal error and die.
 */
#ifdef __STDC__
#include <stdarg.h>
#else
#include <varargs.h>
#endif

void
#ifdef __STDC__
panic(const char *fmt, ...)
#else
panic(fmt, va_alist)
	char *fmt;
        va_dcl
#endif
{
	va_list ap;
#ifdef __STDC__
	va_start(ap, fmt);
#else
	va_start(ap);
#endif
	(void)fprintf(stderr, "panic: ");
	vfprintf(stderr, fmt, ap);
	va_end(ap);
	(void)putc('\n', stderr);
	fflush(stderr);
	abort();
}

/*
d98 1
a98 1
	register struct message *mp;
d118 1
a118 1
	return((sbuf.st_mode & S_IFMT) == S_IFDIR);
d128 1
a128 1
	register char **ap;
d144 1
a144 1
	register FILE *ibuf;
d146 2
a147 2
	register int lc;
	register char *hfield;
d172 1
a172 1
	register FILE *f;
d174 1
a174 1
	register int rem;
d178 2
a179 2
	register char *cp, *cp2;
	register int c;
d234 1
a234 1
	register char *cp = colon;
d253 2
a254 2
	register char *dest, *src;
	register size_t dsize;
d353 3
a355 3
	tv[0].tv_sec = time((time_t *)0) + 1;
	tv[1].tv_sec = sb.st_mtime;
	tv[0].tv_usec = tv[1].tv_usec = 0;
d367 1
a367 1
	register char *cp;
d382 1
a382 1
	register struct message *mp;
d385 1
a385 1
	register char *cp, *cp2;
d405 1
a405 1
	register char *cp;
d407 1
a407 1
	register nesting = 1;
d434 2
a435 4
	register int c;
	register char *cp, *cp2;
	int gotlt, lastsp;
	char *nbuf, *bufend;
d445 1
a445 1
		panic("Out of memory");
d530 1
a530 1
		panic("Out of memory");
d543 1
a543 1
	register struct message *mp;
d548 2
a549 2
	register char *cp, *cp2;
	register FILE *ibuf;
d607 2
a608 2
	register char *cp;
	register int i;
d621 1
a621 1
	register char *s1, *s2;
d635 1
a635 1
	register int c;
d648 1
a648 1
	register char *s1, *s2;
d681 1
a681 1
	register char *realfield;
d684 1
a684 1
	register struct ignore *igp;
@


1.11
log
@Document an assumption and kill a static buffer.
@
text
@d1 1
a1 1
/*	$OpenBSD: aux.c,v 1.10 1997/07/30 07:19:29 millert Exp $	*/
d41 1
a41 1
static char rcsid[] = "$OpenBSD: aux.c,v 1.10 1997/07/30 07:19:29 millert Exp $";
a467 1
	char *bufend;
d469 1
d478 1
a478 1
	if ((bufend = (char *)malloc(strlen(name) + 1)) == NULL)
d482 1
d563 1
a563 1
	if ((bufend = realloc(bufend, strlen(bufend) + 1)) == NULL)
d565 1
a565 1
	return(bufend);
@


1.10
log
@Make istrcpy() take a size (not length) field, now called istrncpy().
Change some strcpy() -> strncpy() out of paranoia.
@
text
@d1 1
a1 1
/*	$OpenBSD: aux.c,v 1.9 1997/07/28 15:20:28 millert Exp $	*/
d41 1
a41 1
static char rcsid[] = "$OpenBSD: aux.c,v 1.9 1997/07/28 15:20:28 millert Exp $";
d476 2
@


1.9
log
@Dynamically allocate space for addr header strings instead of using
BUFSIZ.  We know that the end size will be <= to the start size
so it is simple to preallocate enough space.  Fixes NetBSD PR#3028
@
text
@d1 1
a1 1
/*	$OpenBSD: aux.c,v 1.8 1997/07/25 21:05:33 mickey Exp $	*/
d41 1
a41 1
static char rcsid[] = "$OpenBSD: aux.c,v 1.8 1997/07/25 21:05:33 mickey Exp $";
d280 2
a281 1
 * Copy a string, lowercasing it as we go.
d284 1
a284 1
istrcpy(dest, src)
d286 1
d289 9
a297 6
	do {
		if (isupper(*src))
			*dest++ = tolower(*src);
		else
			*dest++ = *src;
	} while (*src++ != 0);
d703 1
a703 1
	istrcpy(realfld, field);
@


1.8
log
@#if __STDC__ --> #ifdef __STDC__
@
text
@d1 1
a1 1
/*	$OpenBSD: aux.c,v 1.7 1997/07/14 00:24:24 millert Exp $	*/
d41 1
a41 1
static char rcsid[] = "$OpenBSD: aux.c,v 1.7 1997/07/14 00:24:24 millert Exp $";
a464 1
	char nbuf[BUFSIZ];
d471 2
a474 1
	bufend = nbuf;
d555 3
a557 1
	return(savestr(nbuf));
@


1.7
log
@NOSTR -> NULL
Use sigsetjmp/siglongjmp instead of sigjmp/longjmp for portability.
@
text
@d1 1
a1 1
/*	$OpenBSD: aux.c,v 1.6 1997/07/13 23:53:56 millert Exp $	*/
d41 1
a41 1
static char rcsid[] = "$OpenBSD: aux.c,v 1.6 1997/07/13 23:53:56 millert Exp $";
d94 1
a94 1
#if __STDC__
d101 1
a101 1
#if __STDC__
d110 1
a110 1
#if __STDC__
@


1.6
log
@bcopy() -> memcpy() and fix some casts.
@
text
@d1 1
a1 1
/*	$OpenBSD: aux.c,v 1.5 1997/07/13 21:21:08 millert Exp $	*/
d41 1
a41 1
static char rcsid[] = "$OpenBSD: aux.c,v 1.5 1997/07/13 21:21:08 millert Exp $";
d65 1
a65 1
	if ((new = salloc(size)) != NOSTR)
d81 1
a81 1
	if ((new = salloc(newsize + oldsize)) != NOSTR) {
d162 1
a162 1
	for (ap = argv; *ap++ != NOSTR;)
d169 1
a169 1
 * pointer (or NOSTR if the desired header field is not available).
d180 1
a180 1
	char *colon, *oldhfield = NOSTR;
d184 1
a184 1
		return(NOSTR);
d186 1
a186 1
		return(NOSTR);
d321 1
a321 1
	if ((cp = expand(*arglist)) == NOSTR)
d467 4
a470 4
	if (name == NOSTR)
		return(NOSTR);
	if (strchr(name, '(') == NOSTR && strchr(name, '<') == NOSTR
	    && strchr(name, ' ') == NOSTR)
d576 1
a576 1
	if ((cp = hfield("from", mp)) != NOSTR)
d578 1
a578 1
	if (reptype == 0 && (cp = hfield("sender", mp)) != NOSTR)
@


1.5
log
@Merge in NetBSD and 4.4BSD-lite2 changes as well as some of my own.
 - handle long lines safely (from NetBSD)
 - use puts/fputs and putchar/putc when it makes sense
 - use err/errx and warn/warnx when it makes sense
 - make return() and sizeof() style consisten
 - some more buffer safety
@
text
@d1 1
a1 1
/*	$OpenBSD: aux.c,v 1.4 1997/05/30 08:51:32 deraadt Exp $	*/
d41 1
a41 1
static char rcsid[] = "$OpenBSD: aux.c,v 1.4 1997/05/30 08:51:32 deraadt Exp $";
d66 1
a66 1
		bcopy(str, new, size);
d83 1
a83 1
			bcopy(old, new, oldsize);
d86 1
a86 1
		bcopy(str, new + oldsize, newsize);
d247 1
a247 1
			bcopy(cp2, cp, c);
@


1.4
log
@overflows abound
@
text
@d1 2
a2 2
/*	$OpenBSD: aux.c,v 1.3 1997/01/17 07:12:44 millert Exp $	*/
/*	$NetBSD: aux.c,v 1.4 1996/06/08 19:48:10 christos Exp $	*/
d41 1
a41 1
static char rcsid[] = "$OpenBSD: aux.c,v 1.3 1997/01/17 07:12:44 millert Exp $";
d67 1
a67 1
	return new;
d88 1
a88 1
	return new;
d118 1
a118 1
	(void)fprintf(stderr, "\n");
d164 1
a164 1
	return ap - argv - 1;
d184 1
a184 1
		return NOSTR;
d186 1
a186 1
		return NOSTR;
d189 1
a189 1
			return oldhfield;
d193 1
a193 1
	return oldhfield;
d215 1
a215 1
			return -1;
d217 1
a217 1
			return -1;
d251 1
a251 1
		return rem;
d271 1
a271 1
		return 0;
d276 1
a276 1
	return cp;
d324 1
a324 1
		perror(cp);
d328 2
a329 2
		printf("Too much \"sourcing\" going on.\n");
		Fclose(fi);
d351 1
a351 1
		printf("\"Source\" stack over-pop.\n");
d355 1
a355 1
	Fclose(input);
d357 1
a357 1
		printf("Unmatched \"if\"\n");
d450 1
a450 1
	return cp;
d577 1
a577 1
		return cp;
d579 1
a579 1
		return cp;
d609 1
a609 1
				strcpy(namebuf, cp);
d612 3
a614 1
				strcpy(strrchr(namebuf, '!')+1, cp);
d650 2
a651 2
			return 1;
	return 0;
d663 2
a664 2
		return toupper(c);
	return c;
d677 1
a677 1
	return s2 - 1;
d688 1
a688 1
	char realfld[BUFSIZ];
d691 1
a691 1
		return 1;
d698 1
a698 1
		return (!member(realfld, ignore + 1));
d700 1
a700 1
		return (member(realfld, ignore));
d713 2
a714 2
			return (1);
	return (0);
@


1.3
log
@r?index -> strr?chr
@
text
@d1 1
a1 1
/*	$OpenBSD: aux.c,v 1.2 1996/06/11 12:53:32 deraadt Exp $	*/
d41 1
a41 1
static char rcsid[] = "$OpenBSD: aux.c,v 1.2 1996/06/11 12:53:32 deraadt Exp $";
d581 1
a581 1
	namebuf[0] = 0;
@


1.2
log
@from christos;
- Fix PR/105: Implement dot locking protocol and check return value of flock.
- Fix PR/2247: Don't call unknown users "ubluit". Issue an error message.
- Fix/add prototypes.
- Fix warnings.
- Use POSIX signal mask calls.
@
text
@d1 1
a1 1
/*	$OpenBSD: aux.c,v 1.4 1996/06/08 19:48:10 christos Exp $	*/
d41 1
a41 1
static char rcsid[] = "$OpenBSD: aux.c,v 1.4 1996/06/08 19:48:10 christos Exp $";
d417 1
a417 1
	cp2 = rindex(cp, '!');
d469 2
a470 2
	if (index(name, '(') == NOSTR && index(name, '<') == NOSTR
	    && index(name, ' ') == NOSTR)
d595 1
a595 1
	if ((cp = index(linebuf, 'F')) == NULL)
d599 1
a599 1
	while ((cp = index(cp, 'r')) != NULL) {
d601 1
a601 1
			if ((cp = index(cp, 'f')) == NULL)
d605 1
a605 1
			if ((cp = index(cp, ' ')) == NULL)
d612 1
a612 1
				strcpy(rindex(namebuf, '!')+1, cp);
d647 1
a647 1
		if (index(s2, *s1++))
@


1.1
log
@Initial revision
@
text
@d1 3
d38 5
a42 2
static char sccsid[] = "from: @@(#)aux.c	8.1 (Berkeley) 6/6/93";
static char rcsid[] = "$Id: aux.c,v 1.3 1994/06/29 05:09:05 deraadt Exp $";
d53 1
d73 1
a73 1
char *
d190 1
a190 1
		if (hfield = ishfield(linebuf, colon, field))
d314 2
a315 2
source(arglist)
	char **arglist;
d317 1
a376 1
	time_t time();
d475 1
a475 1
	for (cp = name, cp2 = bufend; c = *cp++; ) {
d487 1
a487 1
			while (c = *cp) {
d493 1
a493 1
				else if (c = *cp) {
d525 1
a525 1
						while (c = *cp) {
d673 1
a673 1
	while (*s2++ = *s1++)
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@
