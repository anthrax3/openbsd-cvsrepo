head	1.30;
access;
symbols
	OPENBSD_6_1:1.30.0.8
	OPENBSD_6_1_BASE:1.30
	OPENBSD_6_0:1.30.0.4
	OPENBSD_6_0_BASE:1.30
	OPENBSD_5_9:1.30.0.2
	OPENBSD_5_9_BASE:1.30
	OPENBSD_5_8:1.28.0.4
	OPENBSD_5_8_BASE:1.28
	OPENBSD_5_7:1.26.0.2
	OPENBSD_5_7_BASE:1.26
	OPENBSD_5_6:1.26.0.6
	OPENBSD_5_6_BASE:1.26
	OPENBSD_5_5:1.26.0.4
	OPENBSD_5_5_BASE:1.26
	OPENBSD_5_4:1.25.0.16
	OPENBSD_5_4_BASE:1.25
	OPENBSD_5_3:1.25.0.14
	OPENBSD_5_3_BASE:1.25
	OPENBSD_5_2:1.25.0.12
	OPENBSD_5_2_BASE:1.25
	OPENBSD_5_1_BASE:1.25
	OPENBSD_5_1:1.25.0.10
	OPENBSD_5_0:1.25.0.8
	OPENBSD_5_0_BASE:1.25
	OPENBSD_4_9:1.25.0.6
	OPENBSD_4_9_BASE:1.25
	OPENBSD_4_8:1.25.0.4
	OPENBSD_4_8_BASE:1.25
	OPENBSD_4_7:1.25.0.2
	OPENBSD_4_7_BASE:1.25
	OPENBSD_4_6:1.24.0.6
	OPENBSD_4_6_BASE:1.24
	OPENBSD_4_5:1.24.0.2
	OPENBSD_4_5_BASE:1.24
	OPENBSD_4_4:1.23.0.2
	OPENBSD_4_4_BASE:1.23
	OPENBSD_4_3:1.21.0.6
	OPENBSD_4_3_BASE:1.21
	OPENBSD_4_2:1.21.0.4
	OPENBSD_4_2_BASE:1.21
	OPENBSD_4_1:1.21.0.2
	OPENBSD_4_1_BASE:1.21
	OPENBSD_4_0:1.20.0.2
	OPENBSD_4_0_BASE:1.20
	OPENBSD_3_9:1.18.0.2
	OPENBSD_3_9_BASE:1.18
	OPENBSD_3_8:1.15.0.2
	OPENBSD_3_8_BASE:1.15
	OPENBSD_3_7:1.10.0.8
	OPENBSD_3_7_BASE:1.10
	OPENBSD_3_6:1.10.0.6
	OPENBSD_3_6_BASE:1.10
	OPENBSD_3_5:1.10.0.4
	OPENBSD_3_5_BASE:1.10
	OPENBSD_3_4:1.10.0.2
	OPENBSD_3_4_BASE:1.10
	OPENBSD_3_3:1.8.0.4
	OPENBSD_3_3_BASE:1.8
	OPENBSD_3_2:1.8.0.2
	OPENBSD_3_2_BASE:1.8
	OPENBSD_3_1:1.7.0.2
	OPENBSD_3_1_BASE:1.7
	OPENBSD_3_0:1.6.0.14
	OPENBSD_3_0_BASE:1.6
	OPENBSD_2_9_BASE:1.6
	OPENBSD_2_9:1.6.0.12
	OPENBSD_2_8:1.6.0.10
	OPENBSD_2_8_BASE:1.6
	OPENBSD_2_7:1.6.0.8
	OPENBSD_2_7_BASE:1.6
	OPENBSD_2_6:1.6.0.6
	OPENBSD_2_6_BASE:1.6
	OPENBSD_2_5:1.6.0.4
	OPENBSD_2_5_BASE:1.6
	OPENBSD_2_4:1.6.0.2
	OPENBSD_2_4_BASE:1.6
	OPENBSD_2_3:1.5.0.2
	OPENBSD_2_3_BASE:1.5
	OPENBSD_2_2:1.4.0.4
	OPENBSD_2_2_BASE:1.4
	OPENBSD_2_1:1.4.0.2
	OPENBSD_2_1_BASE:1.4
	OPENBSD_2_0:1.3.0.2
	OPENBSD_2_0_BASE:1.3
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.30
date	2015.10.09.01.37.06;	author deraadt;	state Exp;
branches;
next	1.29;
commitid	sbrB3Q5CNxcwZpfU;

1.29
date	2015.10.05.13.30.30;	author deraadt;	state Exp;
branches;
next	1.28;
commitid	rSXobTeKTvip1j7I;

1.28
date	2015.03.17.19.31.30;	author millert;	state Exp;
branches;
next	1.27;
commitid	0y5bUkEOUrNvvJEO;

1.27
date	2015.03.15.00.41.27;	author millert;	state Exp;
branches;
next	1.26;
commitid	IbVxlqGw2UipKdDr;

1.26
date	2013.11.20.21.33.17;	author deraadt;	state Exp;
branches;
next	1.25;

1.25
date	2009.10.27.23.59.36;	author deraadt;	state Exp;
branches;
next	1.24;

1.24
date	2009.01.01.21.07.17;	author otto;	state Exp;
branches;
next	1.23;

1.23
date	2008.04.18.14.41.04;	author pyr;	state Exp;
branches;
next	1.22;

1.22
date	2008.04.10.15.07.04;	author pyr;	state Exp;
branches;
next	1.21;

1.21
date	2006.10.29.22.51.09;	author tom;	state Exp;
branches;
next	1.20;

1.20
date	2006.04.25.05.18.26;	author tedu;	state Exp;
branches;
next	1.19;

1.19
date	2006.03.24.03.44.14;	author ray;	state Exp;
branches;
next	1.18;

1.18
date	2005.12.08.14.54.30;	author jmc;	state Exp;
branches;
next	1.17;

1.17
date	2005.12.07.12.31.05;	author tom;	state Exp;
branches;
next	1.16;

1.16
date	2005.09.25.21.05.04;	author jmc;	state Exp;
branches;
next	1.15;

1.15
date	2005.08.24.05.19.41;	author deraadt;	state Exp;
branches;
next	1.14;

1.14
date	2005.07.06.06.45.58;	author deraadt;	state Exp;
branches;
next	1.13;

1.13
date	2005.07.06.05.31.08;	author tedu;	state Exp;
branches;
next	1.12;

1.12
date	2005.07.06.05.24.30;	author tedu;	state Exp;
branches;
next	1.11;

1.11
date	2005.04.13.18.52.59;	author deraadt;	state Exp;
branches;
next	1.10;

1.10
date	2003.06.10.22.20.45;	author deraadt;	state Exp;
branches;
next	1.9;

1.9
date	2003.06.03.02.56.06;	author millert;	state Exp;
branches;
next	1.8;

1.8
date	2002.05.29.09.23.25;	author deraadt;	state Exp;
branches;
next	1.7;

1.7
date	2002.02.16.21.27.44;	author millert;	state Exp;
branches;
next	1.6;

1.6
date	98.04.25.01.09.15;	author deraadt;	state Exp;
branches;
next	1.5;

1.5
date	98.03.30.06.59.23;	author deraadt;	state Exp;
branches;
next	1.4;

1.4
date	97.01.15.23.42.15;	author millert;	state Exp;
branches;
next	1.3;

1.3
date	96.08.11.00.46.44;	author deraadt;	state Exp;
branches;
next	1.2;

1.2
date	96.06.26.05.31.43;	author deraadt;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.44.56;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.44.56;	author deraadt;	state Exp;
branches;
next	;


desc
@@


1.30
log
@Change all tame callers to namechange to pledge(2).
@
text
@/*	$OpenBSD: cal.c,v 1.29 2015/10/05 13:30:30 deraadt Exp $	*/
/*	$NetBSD: cal.c,v 1.6 1995/03/26 03:10:24 glass Exp $	*/

/*
 * Copyright (c) 1989, 1993, 1994
 *	The Regents of the University of California.  All rights reserved.
 *
 * This code is derived from software contributed to Berkeley by
 * Kim Letkeman.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */

#include <sys/types.h>

#include <ctype.h>
#include <err.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <time.h>
#include <unistd.h>

#define	THURSDAY		4		/* for reformation */
#define	SATURDAY		6		/* 1 Jan 1 was a Saturday */

#define	FIRST_MISSING_DAY	639799		/* 3 Sep 1752 */
#define	NUMBER_MISSING_DAYS	11		/* 11 day correction */

#define	MAXDAYS			42		/* max slots in a month array */
#define	SPACE			-1		/* used in day array */

static const int days_in_month[2][13] = {
	{0, 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31},
	{0, 31, 29, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31},
};

const int sep1752s[MAXDAYS] = {
	SPACE,	SPACE,	1,	2,	14,	15,	16,
	17,	18,	19,	20,	21,	22,	23,
	24,	25,	26,	27,	28,	29,	30,
	SPACE,	SPACE,	SPACE,	SPACE,	SPACE,	SPACE,	SPACE,
	SPACE,	SPACE,	SPACE,	SPACE,	SPACE,	SPACE,	SPACE,
	SPACE,	SPACE,	SPACE,	SPACE,	SPACE,	SPACE,	SPACE,
}, sep1752m[MAXDAYS] = {
	SPACE,	1,	2,	14,	15,	16,	17,
	18,	19,	20,	21,	22,	23,	24,
	25,	26,	27,	28,	29,	30,	SPACE,
	SPACE,	SPACE,	SPACE,	SPACE,	SPACE,	SPACE,	SPACE,
	SPACE,	SPACE,	SPACE,	SPACE,	SPACE,	SPACE,	SPACE,
	SPACE,	SPACE,	SPACE,	SPACE,	SPACE,	SPACE,	SPACE,
}, sep1752js[MAXDAYS] = {
	SPACE,	SPACE,	245,	246,	258,	259,	260,
	261,	262,	263,	264,	265,	266,	267,
	268,	269,	270,	271,	272,	273,	274,
	SPACE,	SPACE,	SPACE,	SPACE,	SPACE,	SPACE,	SPACE,
	SPACE,	SPACE,	SPACE,	SPACE,	SPACE,	SPACE,	SPACE,
	SPACE,	SPACE,	SPACE,	SPACE,	SPACE,	SPACE,	SPACE,
}, sep1752jm[MAXDAYS] = {
	SPACE,	245,	246,	258,	259,	260,	261,
	262,	263,	264,	265,	266,	267,	268,
	269,	270,	271,	272,	273,	274,	SPACE,
	SPACE,	SPACE,	SPACE,	SPACE,	SPACE,	SPACE,	SPACE,
	SPACE,	SPACE,	SPACE,	SPACE,	SPACE,	SPACE,	SPACE,
	SPACE,	SPACE,	SPACE,	SPACE,	SPACE,	SPACE,	SPACE,
}, empty[MAXDAYS] = {
	SPACE,	SPACE,	SPACE,	SPACE,	SPACE,	SPACE,	SPACE,
	SPACE,	SPACE,	SPACE,	SPACE,	SPACE,	SPACE,	SPACE,
	SPACE,	SPACE,	SPACE,	SPACE,	SPACE,	SPACE,	SPACE,
	SPACE,	SPACE,	SPACE,	SPACE,	SPACE,	SPACE,	SPACE,
	SPACE,	SPACE,	SPACE,	SPACE,	SPACE,	SPACE,	SPACE,
	SPACE,	SPACE,	SPACE,	SPACE,	SPACE,	SPACE,	SPACE,
};

const char *month_names[12] = {
	"January", "February", "March", "April", "May", "June",
	"July", "August", "September", "October", "November", "December",
};

#define	DAY_HEADINGS_S	"Su Mo Tu We Th Fr Sa"
#define	DAY_HEADINGS_M	"Mo Tu We Th Fr Sa Su"
#define	DAY_HEADINGS_JS	" Su  Mo  Tu  We  Th  Fr  Sa"
#define	DAY_HEADINGS_JM	" Mo  Tu  We  Th  Fr  Sa  Su"

const int	*sep1752 = NULL;
const char	*day_headings = NULL;

/* leap year -- account for gregorian reformation in 1752 */
#define	leap_year(yr) \
	((yr) <= 1752 ? !((yr) % 4) : \
	(!((yr) % 4) && ((yr) % 100)) || !((yr) % 400))

/* number of centuries since 1700, not inclusive */
#define	centuries_since_1700(yr) \
	((yr) > 1700 ? (yr) / 100 - 17 : 0)

/* number of centuries since 1700 whose modulo of 400 is 0 */
#define	quad_centuries_since_1700(yr) \
	((yr) > 1600 ? ((yr) - 1600) / 400 : 0)

/* number of leap years between year 1 and this year, not inclusive */
#define	leap_years_since_year_1(yr) \
	((yr) / 4 - centuries_since_1700(yr) + quad_centuries_since_1700(yr))

int julian;
int mflag = 0;
int wflag = 0;

void	ascii_day(char *, int);
void	center(const char *, int, int);
void	day_array(int, int, int *);
int	day_in_week(int, int, int);
int	day_in_year(int, int, int);
int	week(int, int, int);
int	isoweek(int, int, int);
void	j_yearly(int);
void	monthly(int, int);
void	trim_trailing_spaces(char *);
void	usage(void);
void	yearly(int);
int	parsemonth(const char *);

int
main(int argc, char *argv[])
{
	struct tm *local_time;
	time_t now;
	int ch, month, year, yflag;
	const char *errstr;

	if (pledge("stdio", NULL) == -1)
		err(1, "pledge");

	yflag = year = 0;
	while ((ch = getopt(argc, argv, "jmwy")) != -1)
		switch(ch) {
		case 'j':
			julian = 1;
			break;
		case 'm':
			mflag = 1;
			break;
		case 'w':
			wflag = 1;
			break;
		case 'y':
			yflag = 1;
			break;
		case '?':
		default:
			usage();
		}
	argc -= optind;
	argv += optind;

	if (julian && wflag)
		usage();

	day_headings = DAY_HEADINGS_S;
	sep1752 = sep1752s;
	if (mflag && julian) {
		sep1752 = sep1752jm;
		day_headings = DAY_HEADINGS_JM;
	} else if (mflag) {
		sep1752 = sep1752m;
		day_headings = DAY_HEADINGS_M;
	} else if (julian) {
		sep1752 = sep1752js;
		day_headings = DAY_HEADINGS_JS;
	}

	month = 0;
	switch(argc) {
	case 2:
		month = parsemonth(*argv++);
		if (!month)
			errx(1, "Unable to parse month");
		/* FALLTHROUGH */
	case 1:
		if (argc == 1 && !isdigit((unsigned char)*argv[0])) {
			month = parsemonth(*argv);
			if (!month)
				errx(1, "illegal year value: use 1-9999");
			(void)time(&now);
			local_time = localtime(&now);
			year = local_time->tm_year + 1900;
		} else {
			year = strtonum(*argv, 1, 9999, &errstr);
			if (errstr)
				errx(1, "illegal year value: use 1-9999");
		}
		break;
	case 0:
		(void)time(&now);
		local_time = localtime(&now);
		year = local_time->tm_year + 1900;
		if (!yflag)
			month = local_time->tm_mon + 1;
		break;
	default:
		usage();
	}

	if (month)
		monthly(month, year);
	else if (julian)
		j_yearly(year);
	else
		yearly(year);
	exit(0);
}

#define	DAY_LEN		3		/* 3 spaces per day */
#define	J_DAY_LEN	4		/* 4 spaces per day */
#define	WEEK_LEN	20		/* 7 * 3 - one space at the end */
#define WEEKNUMBER_LEN	5		/* 5 spaces per week number */
#define	J_WEEK_LEN	27		/* 7 * 4 - one space at the end */
#define	HEAD_SEP	2		/* spaces between day headings */
#define	J_HEAD_SEP	2

int
week(int day, int month, int year)
{
	int	yearday;
	int	firstweekday;
	int	weekday;
	int	firstday;
	int	firstsunday;
	int	shift;
	
	if (mflag)
		return isoweek(day, month, year);

	yearday = day_in_year(day, month, year);
	firstweekday = day_in_week(1, 1, year) + 1;
	weekday = day_in_week(day, month, year) + 1;
	firstday = day_in_year(1, 1, year);
	firstsunday = firstday + (8 - firstweekday);

	shift = 1;
	if (yearday < firstsunday)
		return (1);
	if (firstweekday > THURSDAY - 1) 
		shift = 2;
	return ((((yearday + 1) - (weekday - 1)) / 7) + shift);
}

int
isoweek(int day, int month, int year)
{
	/* http://www.tondering.dk/claus/cal/node8.html */
	int a, b, c, s, e, f, g, d, n;

	a = month <= 2 ? year - 1 : year;
	b = a/4 - a/100 + a/400;
	c = (a-1)/4 - (a-1)/100 + (a-1)/400;
	s = b - c;
	if (month <= 2) {
		e = 0;
		f = day - 1 + 31 * (month-1);
	} else {
		e = s + 1;
		f = day + ((153 * (month-3) + 2) / 5) + 58 + s;
	}
	g = (a + b) % 7;
	d = (f + g - e) % 7;
	n = f + 3 - d;

	if (n < 0)
		return 53 - (g - s) / 5;
	else if (n > 364 + s)
		return 1;
	else 
		return n/7 + 1;
}

void
monthly(int month, int year)
{
	int col, row, len, days[MAXDAYS], firstday;
	char *p, lineout[30];

	day_array(month, year, days);
	(void)snprintf(lineout, sizeof(lineout), "%s %d",
	    month_names[month - 1], year);
	len = strlen(lineout);
	(void)printf("%*s%s\n%s\n",
	    ((julian ? J_WEEK_LEN : WEEK_LEN) - len) / 2, "",
	    lineout, day_headings);
	for (row = 0; row < 6; row++) {
		firstday = SPACE;
		for (col = 0, p = lineout; col < 7; col++,
		    p += julian ? J_DAY_LEN : DAY_LEN) {
			if (firstday == SPACE && days[row * 7 + col] != SPACE)
				firstday = days[row * 7 + col];
			ascii_day(p, days[row * 7 + col]);
		}
		*p = '\0';
		trim_trailing_spaces(lineout);
		(void)printf("%-20s", lineout);
		if (wflag && firstday != SPACE)
			printf(" [%2d]", week(firstday, month, year));
		printf("\n");
	}
}

void
j_yearly(int year)
{
	int col, *dp, i, month, row, which_cal;
	int days[12][MAXDAYS];
	char *p, lineout[80];

	(void)snprintf(lineout, sizeof(lineout), "%d", year);
	center(lineout, J_WEEK_LEN * 2 + J_HEAD_SEP, 0);
	(void)printf("\n\n");
	for (i = 0; i < 12; i++)
		day_array(i + 1, year, days[i]);
	(void)memset(lineout, ' ', sizeof(lineout) - 1);
	lineout[sizeof(lineout) - 1] = '\0';
	for (month = 0; month < 12; month += 2) {
		center(month_names[month], J_WEEK_LEN, J_HEAD_SEP);
		center(month_names[month + 1], J_WEEK_LEN, 0);
		(void)printf("\n%s%*s%s\n", day_headings,
		    J_HEAD_SEP, "", day_headings);

		for (row = 0; row < 6; row++) {
			for (which_cal = 0; which_cal < 2; which_cal++) {
				p = lineout + which_cal * (J_WEEK_LEN + 2);
				dp = &days[month + which_cal][row * 7];
				for (col = 0; col < 7; col++, p += J_DAY_LEN)
					ascii_day(p, *dp++);
			}
			*p = '\0';
			trim_trailing_spaces(lineout);
			(void)printf("%s\n", lineout);
		}
	}
	(void)printf("\n");
}

void
yearly(int year)
{
	int col, *dp, i, month, row, which_cal, week_len, wn, firstday;
	int days[12][MAXDAYS];
	char *p, lineout[81];

	week_len = WEEK_LEN;
	if (wflag)
		week_len += WEEKNUMBER_LEN;
	(void)snprintf(lineout, sizeof(lineout), "%d", year);
	center(lineout, week_len * 3 + HEAD_SEP * 2, 0);
	(void)printf("\n\n");
	for (i = 0; i < 12; i++)
		day_array(i + 1, year, days[i]);
	(void)memset(lineout, ' ', sizeof(lineout) - 1);
	lineout[sizeof(lineout) - 1] = '\0';
	for (month = 0; month < 12; month += 3) {
		center(month_names[month], week_len, HEAD_SEP);
		center(month_names[month + 1], week_len, HEAD_SEP);
		center(month_names[month + 2], week_len, 0);
		(void)printf("\n%s%*s%s%*s%s\n", day_headings,
		    HEAD_SEP + (wflag ? WEEKNUMBER_LEN : 0), "", day_headings,
		    HEAD_SEP + (wflag ? WEEKNUMBER_LEN : 0), "", day_headings);

		for (row = 0; row < 6; row++) {
			for (which_cal = 0; which_cal < 3; which_cal++) {
				p = lineout + which_cal * (week_len + 2);
				
				dp = &days[month + which_cal][row * 7];
				firstday = SPACE;
				for (col = 0; col < 7; col++, p += DAY_LEN) {
					if (firstday == SPACE && *dp != SPACE)
						firstday = *dp;
					ascii_day(p, *dp++);
				}
				if (wflag && firstday != SPACE) {
					wn = week(firstday,
					    month + which_cal + 1, year);
					(void)snprintf(p, 5, "[%2d]", wn);
					p += strlen(p);
					*p = ' ';
				} else
					memset(p, ' ', 4);
			}
			*p = '\0';
			trim_trailing_spaces(lineout);
			(void)printf("%s\n", lineout);
		}
	}
	(void)printf("\n");
}

/*
 * day_array --
 *	Fill in an array of 42 integers with a calendar.  Assume for a moment
 *	that you took the (maximum) 6 rows in a calendar and stretched them
 *	out end to end.  You would have 42 numbers or spaces.  This routine
 *	builds that array for any month from Jan. 1 through Dec. 9999.
 */
void
day_array(int month, int year, int *days)
{
	int day, dw, dm;

	if (month == 9 && year == 1752) {
		memmove(days, sep1752, MAXDAYS * sizeof(int));
		return;
	}
	memmove(days, empty, MAXDAYS * sizeof(int));
	dm = days_in_month[leap_year(year)][month];
	dw = day_in_week(mflag?0:1, month, year);
	day = julian ? day_in_year(1, month, year) : 1;
	while (dm--)
		days[dw++] = day++;
}

/*
 * day_in_year --
 *	return the 1 based day number within the year
 */
int
day_in_year(int day, int month, int year)
{
	int i, leap;

	leap = leap_year(year);
	for (i = 1; i < month; i++)
		day += days_in_month[leap][i];
	return (day);
}

/*
 * day_in_week
 *	return the 0 based day number for any date from 1 Jan. 1 to
 *	31 Dec. 9999.  Assumes the Gregorian reformation eliminates
 *	3 Sep. 1752 through 13 Sep. 1752.  Returns Thursday for all
 *	missing days.
 */
int
day_in_week(int day, int month, int year)
{
	long temp;

	temp = (long)(year - 1) * 365 + leap_years_since_year_1(year - 1)
	    + day_in_year(day, month, year);
	if (temp < FIRST_MISSING_DAY)
		return ((temp - 1 + SATURDAY) % 7);
	if (temp >= (FIRST_MISSING_DAY + NUMBER_MISSING_DAYS))
		return (((temp - 1 + SATURDAY) - NUMBER_MISSING_DAYS) % 7);
	return (THURSDAY);
}

void
ascii_day(char *p, int day)
{
	int display, val;
	static const char *aday[] = {
		"",
		" 1", " 2", " 3", " 4", " 5", " 6", " 7",
		" 8", " 9", "10", "11", "12", "13", "14",
		"15", "16", "17", "18", "19", "20", "21",
		"22", "23", "24", "25", "26", "27", "28",
		"29", "30", "31",
	};

	if (day == SPACE) {
		memset(p, ' ', julian ? J_DAY_LEN : DAY_LEN);
		return;
	}
	if (julian) {
		val = day / 100;
		if (val) {
			day %= 100;
			*p++ = val + '0';
			display = 1;
		} else {
			*p++ = ' ';
			display = 0;
		}
		val = day / 10;
		if (val || display)
			*p++ = val + '0';
		else
			*p++ = ' ';
		*p++ = day % 10 + '0';
	} else {
		*p++ = aday[day][0];
		*p++ = aday[day][1];
	}
	*p = ' ';
}

void
trim_trailing_spaces(char *s)
{
	char *p;

	for (p = s; *p; ++p)
		continue;
	while (p > s && isspace((unsigned char)*--p))
		continue;
	if (p > s)
		++p;
	*p = '\0';
}

void
center(const char *str, int len, int separate)
{

	len -= strlen(str);
	(void)printf("%*s%s%*s", len / 2, "", str,
	    len / 2 + len % 2 + separate, "");
}

void
usage(void)
{

	(void)fprintf(stderr, "usage: cal [-jmwy] [month] [year]\n");
	exit(1);
}

int
parsemonth(const char *s)
{
	struct tm tm;
	char *cp;
	int v;

	v = (int)strtol(s, &cp, 10);
	if (*cp != '\0') {		/* s wasn't purely numeric */
		v = 0;
		if ((cp = strptime(s, "%b", &tm)) != NULL && *cp == '\0')
			v = tm.tm_mon + 1;
	}
	if (v <= 0 || v > 12)
		errx(1, "invalid month: use 1-12 or a name");
	return (v);
}
@


1.29
log
@tame "stdio rpath" or tame "stdio" suffices for all of these programs.
fairly easy to audit by running nm and noticing nothing beyond base
stdio except for fopen/freopen.  Then review all callpaths to those
functions, and place the tame() calls.
ok sthen
@
text
@d1 1
a1 1
/*	$OpenBSD: cal.c,v 1.28 2015/03/17 19:31:30 millert Exp $	*/
d153 2
a154 2
	if (tame("stdio", NULL) == -1)
		err(1, "tame");
@


1.28
log
@Eliminate use of TM_YEAR_BASE.  OK guenther@@ deraadt@@ miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: cal.c,v 1.27 2015/03/15 00:41:27 millert Exp $	*/
d152 3
@


1.27
log
@tzfile.h is an internal header that should never have been installed.
What's worse, the tzfile.h that gets installed is over 20 years old
and doesn't match the real tzfile.h in libc/time.  This makes the
tree safe for /usr/include/tzfile.h removal.  The TM_YEAR_BASE
define has been moved to time.h temporarily until its usage is
replaced by 1900 in the tree.  Actual removal of tzfile.h is pending
a ports build.  Based on a diff from deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: cal.c,v 1.26 2013/11/20 21:33:17 deraadt Exp $	*/
d205 1
a205 1
			year = local_time->tm_year + TM_YEAR_BASE;
d215 1
a215 1
		year = local_time->tm_year + TM_YEAR_BASE;
@


1.26
log
@unsigned char casts are needed for these isdigit & isprint calls
ok benno
@
text
@d1 1
a1 1
/*	$OpenBSD: cal.c,v 1.25 2009/10/27 23:59:36 deraadt Exp $	*/
a43 1
#include <tzfile.h>
@


1.25
log
@rcsid[] and sccsid[] and copyright[] are essentially unmaintained (and
unmaintainable).  these days, people use source.  these id's do not provide
any benefit, and do hurt the small install media
(the 33,000 line diff is essentially mechanical)
ok with the idea millert, ok dms
@
text
@d1 1
a1 1
/*	$OpenBSD: cal.c,v 1.24 2009/01/01 21:07:17 otto Exp $	*/
d200 1
a200 1
		if (argc == 1 && !isdigit(*argv[0])) {
d522 1
a522 1
	while (p > s && isspace(*--p))
@


1.24
log
@Fix iso weekno calculation by using a different algorithm. Still hard
to follow, but this one has a documented origin at least; ok pyr@@
jasper@@
@
text
@d1 1
a1 1
/*	$OpenBSD: cal.c,v 1.23 2008/04/18 14:41:04 pyr Exp $	*/
a34 11

#ifndef lint
static const char copyright[] =
"@@(#) Copyright (c) 1989, 1993, 1994\n\
	The Regents of the University of California.  All rights reserved.\n";
#if 0
static char sccsid[] = "@@(#)cal.c	8.4 (Berkeley) 4/2/94";
#else
static const char rcsid[] = "$OpenBSD: cal.c,v 1.23 2008/04/18 14:41:04 pyr Exp $";
#endif
#endif /* not lint */
@


1.23
log
@Allow cal to show week numbers. Switch between sunday based week numbering
and ISO 8601 monday based week numbering with overlapping weeks if the -m
flag is present.

many positive feedback received.
ok mbalmer@@, jasper@@, simon@@
input from todd@@
@
text
@d1 1
a1 1
/*	$OpenBSD: cal.c,v 1.22 2008/04/10 15:07:04 pyr Exp $	*/
d43 1
a43 1
static const char rcsid[] = "$OpenBSD: cal.c,v 1.22 2008/04/10 15:07:04 pyr Exp $";
d149 1
a254 2
	int	leap;
	int	prevleap;
d261 3
d268 1
a268 3
	leap = leap_year(year);
	prevleap = leap_year(year - 1);
	firstday = firstsunday = day_in_year(1, 1, year);
a270 16
	if (!mflag)
		goto sunbased;

	if (yearday <= (8 - firstweekday) && firstweekday > 4) {
		if (firstweekday == 5 || (firstweekday == 6 && prevleap))
			return (53);
		return (52);
	}

	if (((leap ? 366 : 365) - yearday) < (4 - weekday))
		return (1);

	return (((yearday + (7 - weekday) + (firstweekday - 1)) / 7)
	    - (firstweekday > 4));

sunbased:
d279 29
d333 1
a333 1
			printf(" [%2d]", week(firstday - mflag, month, year));
d410 1
a410 1
					wn = week(firstday - mflag,
@


1.22
log
@Introduce the -m flag which shows weeks as starting on mondays.
input from tom@@ through markus@@
ok henning@@, mbalmer@@ and jmc@@
@
text
@d1 1
a1 1
/*	$OpenBSD: cal.c,v 1.21 2006/10/29 22:51:09 tom Exp $	*/
d43 1
a43 1
static const char rcsid[] = "$OpenBSD: cal.c,v 1.21 2006/10/29 22:51:09 tom Exp $";
d141 1
d148 1
d165 1
a165 1
	while ((ch = getopt(argc, argv, "jmy")) != -1)
d173 3
d186 3
d246 1
d251 44
d298 1
a298 1
	int col, row, len, days[MAXDAYS];
d309 1
d311 3
a313 1
		    p += julian ? J_DAY_LEN : DAY_LEN)
d315 1
d318 4
a321 1
		(void)printf("%s\n", lineout);
d363 1
a363 1
	int col, *dp, i, month, row, which_cal;
d365 1
a365 1
	char *p, lineout[80];
d367 3
d371 1
a371 1
	center(lineout, WEEK_LEN * 3 + HEAD_SEP * 2, 0);
d378 3
a380 3
		center(month_names[month], WEEK_LEN, HEAD_SEP);
		center(month_names[month + 1], WEEK_LEN, HEAD_SEP);
		center(month_names[month + 2], WEEK_LEN, 0);
d382 2
a383 1
		    HEAD_SEP, "", day_headings, HEAD_SEP, "", day_headings);
d387 2
a388 1
				p = lineout + which_cal * (WEEK_LEN + 2);
d390 4
a393 1
				for (col = 0; col < 7; col++, p += DAY_LEN)
d395 9
d540 1
a540 1
	(void)fprintf(stderr, "usage: cal [-jmy] [month] [year]\n");
@


1.21
log
@Optimise a couple of printf()s; originally from Han Boetes.

Reminded by, and ok, otto@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: cal.c,v 1.20 2006/04/25 05:18:26 tedu Exp $	*/
d43 1
a43 1
static const char rcsid[] = "$OpenBSD: cal.c,v 1.20 2006/04/25 05:18:26 tedu Exp $";
d72 1
a72 1
const int sep1752[MAXDAYS] = {
d79 8
a86 1
}, j_sep1752[MAXDAYS] = {
d93 7
d114 7
a120 2
const char *day_headings = "Su Mo Tu We Th Fr Sa";
const char *j_day_headings = " Su  Mo  Tu  We  Th  Fr  Sa";
d140 1
d163 1
a163 1
	while ((ch = getopt(argc, argv, "jy")) != -1)
d168 3
d181 13
d254 1
a254 1
	    lineout, julian ? j_day_headings : day_headings);
d282 3
a284 2
		(void)printf("\n%s%*s%s\n", j_day_headings, J_HEAD_SEP, "",
		    j_day_headings);
d318 3
a320 2
		(void)printf("\n%s%*s%s%*s%s\n", day_headings, HEAD_SEP,
		    "", day_headings, HEAD_SEP, "", day_headings);
d349 1
a349 2
		memmove(days,
		    julian ? j_sep1752 : sep1752, MAXDAYS * sizeof(int));
d354 1
a354 1
	dw = day_in_week(1, month, year);
d463 1
a463 1
	(void)fprintf(stderr, "usage: cal [-jy] [month] [year]\n");
@


1.20
log
@atoi/strtonum from han boetes
@
text
@d1 1
a1 1
/*	$OpenBSD: cal.c,v 1.19 2006/03/24 03:44:14 ray Exp $	*/
d43 1
a43 1
static const char rcsid[] = "$OpenBSD: cal.c,v 1.19 2006/03/24 03:44:14 ray Exp $";
d418 2
a419 3
	(void)printf("%*s%s%*s", len / 2, "", str, len / 2 + len % 2, "");
	if (separate)
		(void)printf("%*s", separate, "");
@


1.19
log
@KNF, no binary change.

From Han Boetes.
@
text
@d1 1
a1 1
/*	$OpenBSD: cal.c,v 1.18 2005/12/08 14:54:30 jmc Exp $	*/
d43 1
a43 1
static const char rcsid[] = "$OpenBSD: cal.c,v 1.18 2005/12/08 14:54:30 jmc Exp $";
d140 1
d174 2
a175 1
			if ((year = atoi(*argv)) < 1 || year > 9999)
@


1.18
log
@oops - forgot to remind tom to update usage();
@
text
@d1 1
a1 1
/*	$OpenBSD: cal.c,v 1.17 2005/12/07 12:31:05 tom Exp $	*/
d43 1
a43 1
static const char rcsid[] = "$OpenBSD: cal.c,v 1.17 2005/12/07 12:31:05 tom Exp $";
d211 1
a211 1
	(void)snprintf(lineout, sizeof lineout, "%s %d",
d234 1
a234 1
	(void)snprintf(lineout, sizeof lineout, "%d", year);
d268 1
a268 1
	(void)snprintf(lineout, sizeof lineout, "%d", year);
@


1.17
log
@Tidy up month parsing: don't accept "mayor" for "may", or "4x" for "4".
And strptime(3) %b and %B conversions are the same, so don't bother
trying both.

ok otto@@
@
text
@d1 1
a1 1
/*	$OpenBSD: cal.c,v 1.16 2005/09/25 21:05:04 jmc Exp $	*/
d43 1
a43 1
static const char rcsid[] = "$OpenBSD: cal.c,v 1.16 2005/09/25 21:05:04 jmc Exp $";
d425 1
a425 1
	(void)fprintf(stderr, "usage: cal [-jy] [month year]\n");
@


1.16
log
@cal now (well, has done for a while) accepts a single argument
of the abbreviated month name: update SYNOPSIS, usage(), and
DESCRIPTION to reflect this;

remove a sentence that was repeated in the text - replace it with
something marginally more useful;

be clear that both numerical and string arguments are now accepted;

escape some hyphens whilst here;
@
text
@d1 1
a1 1
/*	$OpenBSD: cal.c,v 1.15 2005/08/24 05:19:41 deraadt Exp $	*/
d43 1
a43 1
static const char rcsid[] = "$OpenBSD: cal.c,v 1.15 2005/08/24 05:19:41 deraadt Exp $";
d437 5
a441 6
	if (cp != s)
		;
	else if (strptime(s, "%B", &tm) != NULL)
		v = tm.tm_mon + 1;
	else if (strptime(s, "%b", &tm) != NULL)
		v = tm.tm_mon + 1;
d443 1
a443 1
		errx(1, "illegal month value: use 1-12");
@


1.15
log
@range check months 1-12; ok tedu millert others
@
text
@d1 1
a1 1
/*	$OpenBSD: cal.c,v 1.14 2005/07/06 06:45:58 deraadt Exp $	*/
d43 1
a43 1
static const char rcsid[] = "$OpenBSD: cal.c,v 1.14 2005/07/06 06:45:58 deraadt Exp $";
d425 1
a425 1
	(void)fprintf(stderr, "usage: cal [-jy] [[month] year]\n");
@


1.14
log
@spacing
@
text
@d1 1
a1 1
/*	$OpenBSD: cal.c,v 1.13 2005/07/06 05:31:08 tedu Exp $	*/
d43 1
a43 1
static const char rcsid[] = "$OpenBSD: cal.c,v 1.13 2005/07/06 05:31:08 tedu Exp $";
d432 2
a434 2
	char *cp;
	struct tm tm;
d438 8
a445 6
		return (v);
	if (strptime(s, "%B", &tm) != NULL)
		return (tm.tm_mon + 1);
	if (strptime(s, "%b", &tm) != NULL)
		return (tm.tm_mon + 1);
	return (0);
@


1.13
log
@warning clean and constiness
@
text
@d1 1
a1 1
/*	$OpenBSD: cal.c,v 1.12 2005/07/06 05:24:30 tedu Exp $	*/
d43 1
a43 1
static const char rcsid[] = "$OpenBSD: cal.c,v 1.12 2005/07/06 05:24:30 tedu Exp $";
d59 1
a59 1
#define	SATURDAY 		6		/* 1 Jan 1 was a Saturday */
d61 2
a62 2
#define	FIRST_MISSING_DAY 	639799		/* 3 Sep 1752 */
#define	NUMBER_MISSING_DAYS 	11		/* 11 day correction */
@


1.12
log
@drop in parsemonth from freebsd.
use it to parse month, so "cal june 2005" works as expected.
if only one arg is given, see if it could be a month
ok deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: cal.c,v 1.11 2005/04/13 18:52:59 deraadt Exp $	*/
d37 1
a37 1
static char copyright[] =
a39 3
#endif /* not lint */

#ifndef lint
d43 1
a43 1
static char rcsid[] = "$OpenBSD: cal.c,v 1.11 2005/04/13 18:52:59 deraadt Exp $";
d67 1
a67 1
static int days_in_month[2][13] = {
d72 1
a72 1
int sep1752[MAXDAYS] = {
d95 1
a95 1
char *month_names[12] = {
d100 2
a101 2
char *day_headings = "Su Mo Tu We Th Fr Sa";
char *j_day_headings = " Su  Mo  Tu  We  Th  Fr  Sa";
d123 1
a123 1
void	center(char *, int, int);
d132 1
d211 1
a211 1
	(void) snprintf(lineout, sizeof lineout, "%s %d",
d310 1
a310 1
			julian ? j_sep1752 : sep1752, MAXDAYS * sizeof(int));
d361 1
a361 1
	static char *aday[] = {
d412 1
a412 1
center(char *str, int len, int separate)
@


1.11
log
@do not trust snprintf return value; ok otto mickey
@
text
@d1 1
a1 1
/*	$OpenBSD: cal.c,v 1.10 2003/06/10 22:20:45 deraadt Exp $	*/
d46 1
a46 1
static char rcsid[] = "$OpenBSD: cal.c,v 1.10 2003/06/10 22:20:45 deraadt Exp $";
d162 3
a164 2
		if ((month = atoi(*argv++)) < 1 || month > 12)
			errx(1, "illegal month value: use 1-12");
d167 11
a177 2
		if ((year = atoi(*argv)) < 1 || year > 9999)
			errx(1, "illegal year value: use 1-9999");
d429 17
@


1.10
log
@mostly ansi cleanup; pval ok
@
text
@d1 1
a1 1
/*	$OpenBSD: cal.c,v 1.9 2003/06/03 02:56:06 millert Exp $	*/
d46 1
a46 1
static char rcsid[] = "$OpenBSD: cal.c,v 1.9 2003/06/03 02:56:06 millert Exp $";
d203 1
a203 1
	len = snprintf(lineout, sizeof lineout, "%s %d",
d205 1
@


1.9
log
@Remove the advertising clause in the UCB license which Berkeley
rescinded 22 July 1999.  Proofed by myself and Theo.
@
text
@d1 1
a1 1
/*	$OpenBSD: cal.c,v 1.8 2002/05/29 09:23:25 deraadt Exp $	*/
d46 1
a46 1
static char rcsid[] = "$OpenBSD: cal.c,v 1.8 2002/05/29 09:23:25 deraadt Exp $";
d137 1
a137 3
main(argc, argv)
	int argc;
	char **argv;
d197 1
a197 2
monthly(month, year)
	int month, year;
d219 1
a219 2
j_yearly(year)
	int year;
d253 1
a253 2
yearly(year)
	int year;
d295 1
a295 3
day_array(month, year, days)
	int month, year;
	int *days;
d317 1
a317 2
day_in_year(day, month, year)
	int day, month, year;
d335 1
a335 2
day_in_week(day, month, year)
	int day, month, year;
d349 1
a349 3
ascii_day(p, day)
	char *p;
	int day;
d389 1
a389 2
trim_trailing_spaces(s)
	char *s;
d403 1
a403 4
center(str, len, separate)
	char *str;
	int len;
	int separate;
d413 1
a413 1
usage()
@


1.8
log
@more snprintf
@
text
@d1 1
a1 1
/*	$OpenBSD: cal.c,v 1.7 2002/02/16 21:27:44 millert Exp $	*/
d19 1
a19 5
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
d46 1
a46 1
static char rcsid[] = "$OpenBSD: cal.c,v 1.7 2002/02/16 21:27:44 millert Exp $";
@


1.7
log
@Part one of userland __P removal.  Done with a simple regexp with some minor hand editing to make comments line up correctly.  Another pass is forthcoming that handles the cases that could not be done automatically.
@
text
@d1 1
a1 1
/*	$OpenBSD: cal.c,v 1.6 1998/04/25 01:09:15 deraadt Exp $	*/
d50 1
a50 1
static char rcsid[] = "$OpenBSD: cal.c,v 1.6 1998/04/25 01:09:15 deraadt Exp $";
d210 2
a211 1
	len = sprintf(lineout, "%s %d", month_names[month - 1], year);
d233 1
a233 1
	(void)sprintf(lineout, "%d", year);
d268 1
a268 1
	(void)sprintf(lineout, "%d", year);
@


1.6
log
@nothing important...
@
text
@d1 1
a1 1
/*	$OpenBSD: cal.c,v 1.5 1998/03/30 06:59:23 deraadt Exp $	*/
d50 1
a50 1
static char rcsid[] = "$OpenBSD: cal.c,v 1.5 1998/03/30 06:59:23 deraadt Exp $";
d129 10
a138 10
void	ascii_day __P((char *, int));
void	center __P((char *, int, int));
void	day_array __P((int, int, int *));
int	day_in_week __P((int, int, int));
int	day_in_year __P((int, int, int));
void	j_yearly __P((int));
void	monthly __P((int, int));
void	trim_trailing_spaces __P((char *));
void	usage __P((void));
void	yearly __P((int));
@


1.5
log
@Y2K fixes from Andreas.Gunnarsson@@emw.ericsson.se; culled from various places
@
text
@d1 1
a1 1
/*	$OpenBSD: cal.c,v 1.4 1997/01/15 23:42:15 millert Exp $	*/
d50 1
a50 1
static char rcsid[] = "$OpenBSD: cal.c,v 1.4 1997/01/15 23:42:15 millert Exp $";
d149 1
a149 1
	yflag = 0;
@


1.4
log
@getopt(3) returns -1 when out of args, not EOF, whee!
@
text
@d1 1
a1 1
/*	$OpenBSD: cal.c,v 1.3 1996/08/11 00:46:44 deraadt Exp $	*/
d50 1
a50 1
static char rcsid[] = "$OpenBSD: cal.c,v 1.3 1996/08/11 00:46:44 deraadt Exp $";
d62 1
d113 1
a113 1
	!((yr) % 4) && ((yr) % 100) || !((yr) % 400))
d178 1
a178 1
		year = local_time->tm_year + 1900;
d380 2
a381 1
		if (val = day / 100) {
@


1.3
log
@use 2-char day names; from wosch@@cs.tu-berlin.de
@
text
@d1 1
a1 1
/*	$OpenBSD: cal.c,v 1.2 1996/06/26 05:31:43 deraadt Exp $	*/
d50 1
a50 1
static char rcsid[] = "$OpenBSD: cal.c,v 1.2 1996/06/26 05:31:43 deraadt Exp $";
d149 1
a149 1
	while ((ch = getopt(argc, argv, "jy")) != EOF)
@


1.2
log
@rcsid
@
text
@d1 1
a1 1
/*	$OpenBSD: cal.c,v 1.6 1995/03/26 03:10:24 glass Exp $	*/
d50 1
a50 1
static char rcsid[] = "$OpenBSD: cal.c,v 1.6 1995/03/26 03:10:24 glass Exp $";
d106 2
a107 2
char *day_headings = " S  M Tu  W Th  F  S";
char *j_day_headings = "  S   M  Tu   W  Th   F   S";
@


1.1
log
@Initial revision
@
text
@d1 1
d50 1
a50 1
static char rcsid[] = "$NetBSD: cal.c,v 1.6 1995/03/26 03:10:24 glass Exp $";
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@
