head	1.141;
access;
symbols
	OPENBSD_6_1:1.141.0.2
	OPENBSD_6_1_BASE:1.141
	OPENBSD_6_0:1.139.0.4
	OPENBSD_6_0_BASE:1.139
	OPENBSD_5_9:1.139.0.2
	OPENBSD_5_9_BASE:1.139
	OPENBSD_5_8:1.138.0.4
	OPENBSD_5_8_BASE:1.138
	OPENBSD_5_7:1.137.0.2
	OPENBSD_5_7_BASE:1.137
	OPENBSD_5_6:1.132.0.4
	OPENBSD_5_6_BASE:1.132
	OPENBSD_5_5:1.127.0.4
	OPENBSD_5_5_BASE:1.127
	OPENBSD_5_4:1.122.0.2
	OPENBSD_5_4_BASE:1.122
	OPENBSD_5_3:1.119.0.4
	OPENBSD_5_3_BASE:1.119
	OPENBSD_5_2:1.119.0.2
	OPENBSD_5_2_BASE:1.119
	OPENBSD_5_1_BASE:1.118
	OPENBSD_5_1:1.118.0.6
	OPENBSD_5_0:1.118.0.4
	OPENBSD_5_0_BASE:1.118
	OPENBSD_4_9:1.118.0.2
	OPENBSD_4_9_BASE:1.118
	OPENBSD_4_8:1.117.0.2
	OPENBSD_4_8_BASE:1.117
	OPENBSD_4_7:1.114.0.2
	OPENBSD_4_7_BASE:1.114
	OPENBSD_4_6:1.111.0.6
	OPENBSD_4_6_BASE:1.111
	OPENBSD_4_5:1.111.0.2
	OPENBSD_4_5_BASE:1.111
	OPENBSD_4_4:1.109.0.2
	OPENBSD_4_4_BASE:1.109
	OPENBSD_4_3:1.108.0.2
	OPENBSD_4_3_BASE:1.108
	OPENBSD_4_2:1.104.0.4
	OPENBSD_4_2_BASE:1.104
	OPENBSD_4_1:1.104.0.2
	OPENBSD_4_1_BASE:1.104
	OPENBSD_4_0:1.103.0.2
	OPENBSD_4_0_BASE:1.103
	OPENBSD_3_9:1.100.0.2
	OPENBSD_3_9_BASE:1.100
	OPENBSD_3_8:1.96.0.2
	OPENBSD_3_8_BASE:1.96
	OPENBSD_3_7:1.94.0.2
	OPENBSD_3_7_BASE:1.94
	OPENBSD_3_6:1.89.0.2
	OPENBSD_3_6_BASE:1.89
	OPENBSD_3_5:1.82.0.2
	OPENBSD_3_5_BASE:1.82
	OPENBSD_3_4:1.80.0.2
	OPENBSD_3_4_BASE:1.80
	OPENBSD_3_3:1.75.0.2
	OPENBSD_3_3_BASE:1.75
	OPENBSD_3_2:1.72.0.2
	OPENBSD_3_2_BASE:1.72
	OPENBSD_3_1:1.68.0.2
	OPENBSD_3_1_BASE:1.68
	OPENBSD_3_0:1.60.0.2
	OPENBSD_3_0_BASE:1.60
	OPENBSD_2_9_BASE:1.48
	OPENBSD_2_9:1.48.0.2
	OPENBSD_2_8:1.38.0.2
	OPENBSD_2_8_BASE:1.38
	OPENBSD_2_7:1.35.0.2
	OPENBSD_2_7_BASE:1.35
	OPENBSD_2_6:1.34.0.2
	OPENBSD_2_6_BASE:1.34
	OPENBSD_2_5:1.26.0.2
	OPENBSD_2_5_BASE:1.26
	OPENBSD_2_4:1.25.0.2
	OPENBSD_2_4_BASE:1.25
	OPENBSD_2_3:1.23.0.2
	OPENBSD_2_3_BASE:1.23
	OPENBSD_2_2:1.20.0.2
	OPENBSD_2_2_BASE:1.20
	OPENBSD_2_1:1.18.0.2
	OPENBSD_2_1_BASE:1.18
	OPENBSD_2_0:1.13.0.2
	OPENBSD_2_0_BASE:1.13
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.141
date	2016.08.14.22.47.26;	author guenther;	state Exp;
branches;
next	1.140;
commitid	FtUeHnQb6FbNlF9B;

1.140
date	2016.07.27.14.44.59;	author tedu;	state Exp;
branches;
next	1.139;
commitid	XAdC1jj6KiTyzPFD;

1.139
date	2015.12.24.03.25.08;	author mmcc;	state Exp;
branches;
next	1.138;
commitid	OWtyoadomW7Iu1Ji;

1.138
date	2015.04.18.18.28.38;	author deraadt;	state Exp;
branches;
next	1.137;
commitid	6b2lLILbgCR1fvia;

1.137
date	2015.01.30.19.00.56;	author tedu;	state Exp;
branches;
next	1.136;
commitid	MxP0Os17hjXMHgU0;

1.136
date	2015.01.16.06.40.14;	author deraadt;	state Exp;
branches;
next	1.135;
commitid	Uu5nFG3wCl0LACBb;

1.135
date	2014.12.19.20.18.15;	author tedu;	state Exp;
branches;
next	1.134;
commitid	r11giNKqncEaASmL;

1.134
date	2014.11.23.04.34.48;	author guenther;	state Exp;
branches;
next	1.133;
commitid	LIj2x3qvN0HcH7BW;

1.133
date	2014.09.15.19.08.22;	author miod;	state Exp;
branches;
next	1.132;
commitid	uuiU9j2I8AUx0fez;

1.132
date	2014.07.13.21.13.51;	author kettenis;	state Exp;
branches;
next	1.131;
commitid	Pin2Jh1Vnx93IVyS;

1.131
date	2014.07.08.17.19.26;	author deraadt;	state Exp;
branches;
next	1.130;
commitid	EF98ch02VpFassUi;

1.130
date	2014.07.02.07.16.29;	author dlg;	state Exp;
branches;
next	1.129;
commitid	evailyxyH3ucvRgd;

1.129
date	2014.07.02.00.12.34;	author dlg;	state Exp;
branches;
next	1.128;
commitid	zNbAzxmEBZMksTSx;

1.128
date	2014.04.08.14.04.11;	author mpi;	state Exp;
branches;
next	1.127;

1.127
date	2013.11.26.21.08.12;	author deraadt;	state Exp;
branches;
next	1.126;

1.126
date	2013.11.13.22.26.02;	author chl;	state Exp;
branches;
next	1.125;

1.125
date	2013.10.31.02.00.11;	author deraadt;	state Exp;
branches;
next	1.124;

1.124
date	2013.10.08.03.04.17;	author guenther;	state Exp;
branches;
next	1.123;

1.123
date	2013.08.22.04.43.40;	author guenther;	state Exp;
branches;
next	1.122;

1.122
date	2013.07.18.08.42.50;	author bluhm;	state Exp;
branches;
next	1.121;

1.121
date	2013.05.14.20.39.25;	author miod;	state Exp;
branches;
next	1.120;

1.120
date	2013.03.26.21.13.55;	author tedu;	state Exp;
branches;
next	1.119;

1.119
date	2012.04.12.12.33.04;	author deraadt;	state Exp;
branches;
next	1.118;

1.118
date	2010.11.19.18.35.16;	author mikeb;	state Exp;
branches;
next	1.117;

1.117
date	2010.08.01.02.51.03;	author chl;	state Exp;
branches;
next	1.116;

1.116
date	2010.07.22.17.31.39;	author thib;	state Exp;
branches;
next	1.115;

1.115
date	2010.07.20.19.43.19;	author lum;	state Exp;
branches;
next	1.114;

1.114
date	2009.11.22.22.22.14;	author tedu;	state Exp;
branches;
next	1.113;

1.113
date	2009.10.27.23.59.49;	author deraadt;	state Exp;
branches;
next	1.112;

1.112
date	2009.09.30.19.39.34;	author naddy;	state Exp;
branches;
next	1.111;

1.111
date	2008.10.08.17.47.28;	author deraadt;	state Exp;
branches;
next	1.110;

1.110
date	2008.09.08.09.06.25;	author otto;	state Exp;
branches;
next	1.109;

1.109
date	2008.03.16.11.11.59;	author sobrado;	state Exp;
branches;
next	1.108;

1.108
date	2007.12.30.13.29.52;	author sobrado;	state Exp;
branches;
next	1.107;

1.107
date	2007.12.15.03.43.41;	author deraadt;	state Exp;
branches;
next	1.106;

1.106
date	2007.10.26.14.15.25;	author sobrado;	state Exp;
branches;
next	1.105;

1.105
date	2007.09.13.22.30.51;	author cloder;	state Exp;
branches;
next	1.104;

1.104
date	2006.10.02.23.03.56;	author pedro;	state Exp;
branches;
next	1.103;

1.103
date	2006.03.31.18.19.38;	author deraadt;	state Exp;
branches;
next	1.102;

1.102
date	2006.03.31.04.06.13;	author deraadt;	state Exp;
branches;
next	1.101;

1.101
date	2006.03.13.19.29.26;	author otto;	state Exp;
branches;
next	1.100;

1.100
date	2006.02.23.06.32.11;	author martin;	state Exp;
branches;
next	1.99;

1.99
date	2006.02.11.16.46.59;	author martin;	state Exp;
branches;
next	1.98;

1.98
date	2006.01.31.18.24.56;	author mickey;	state Exp;
branches;
next	1.97;

1.97
date	2005.09.28.00.54.05;	author pedro;	state Exp;
branches;
next	1.96;

1.96
date	2005.07.04.01.54.10;	author djm;	state Exp;
branches;
next	1.95;

1.95
date	2005.04.21.04.42.56;	author mickey;	state Exp;
branches;
next	1.94;

1.94
date	2004.12.24.22.38.22;	author miod;	state Exp;
branches;
next	1.93;

1.93
date	2004.11.28.14.05.24;	author miod;	state Exp;
branches;
next	1.92;

1.92
date	2004.11.09.23.20.18;	author pedro;	state Exp;
branches;
next	1.91;

1.91
date	2004.09.23.22.55.06;	author deraadt;	state Exp;
branches;
next	1.90;

1.90
date	2004.09.23.21.09.39;	author deraadt;	state Exp;
branches;
next	1.89;

1.89
date	2004.07.02.09.12.37;	author miod;	state Exp;
branches;
next	1.88;

1.88
date	2004.06.28.21.49.35;	author jmc;	state Exp;
branches;
next	1.87;

1.87
date	2004.06.28.01.45.51;	author aaron;	state Exp;
branches;
next	1.86;

1.86
date	2004.06.14.00.39.33;	author deraadt;	state Exp;
branches;
next	1.85;

1.85
date	2004.06.14.00.38.02;	author deraadt;	state Exp;
branches;
next	1.84;

1.84
date	2004.06.11.16.09.08;	author deraadt;	state Exp;
branches;
next	1.83;

1.83
date	2004.06.11.05.54.55;	author deraadt;	state Exp;
branches;
next	1.82;

1.82
date	2004.02.15.02.45.47;	author tedu;	state Exp;
branches;
next	1.81;

1.81
date	2004.01.15.20.39.33;	author otto;	state Exp;
branches;
next	1.80;

1.80
date	2003.07.28.06.16.35;	author tedu;	state Exp;
branches;
next	1.79;

1.79
date	2003.07.25.21.25.29;	author tedu;	state Exp;
branches;
next	1.78;

1.78
date	2003.06.25.21.18.08;	author deraadt;	state Exp;
branches;
next	1.77;

1.77
date	2003.06.03.02.56.22;	author millert;	state Exp;
branches;
next	1.76;

1.76
date	2003.05.19.05.17.21;	author art;	state Exp;
branches;
next	1.75;

1.75
date	2003.02.24.00.28.37;	author grange;	state Exp;
branches;
next	1.74;

1.74
date	2003.01.13.06.06.13;	author art;	state Exp;
branches;
next	1.73;

1.73
date	2002.12.16.01.57.04;	author tdeval;	state Exp;
branches;
next	1.72;

1.72
date	2002.09.17.19.37.40;	author deraadt;	state Exp;
branches;
next	1.71;

1.71
date	2002.09.05.04.05.53;	author art;	state Exp;
branches;
next	1.70;

1.70
date	2002.06.19.08.45.52;	author deraadt;	state Exp;
branches;
next	1.69;

1.69
date	2002.05.29.09.23.25;	author deraadt;	state Exp;
branches;
next	1.68;

1.68
date	2002.03.15.19.11.01;	author art;	state Exp;
branches;
next	1.67;

1.67
date	2002.03.12.00.59.48;	author ho;	state Exp;
branches;
next	1.66;

1.66
date	2002.02.16.21.27.58;	author millert;	state Exp;
branches;
next	1.65;

1.65
date	2002.02.01.14.31.19;	author art;	state Exp;
branches;
next	1.64;

1.64
date	2002.01.21.17.30.38;	author deraadt;	state Exp;
branches;
next	1.63;

1.63
date	2002.01.15.22.40.38;	author art;	state Exp;
branches;
next	1.62;

1.62
date	2001.11.19.19.02.17;	author mpech;	state Exp;
branches;
next	1.61;

1.61
date	2001.11.06.19.20.15;	author art;	state Exp;
branches;
next	1.60;

1.60
date	2001.09.16.01.27.55;	author art;	state Exp;
branches;
next	1.59;

1.59
date	2001.08.12.12.03.03;	author heko;	state Exp;
branches;
next	1.58;

1.58
date	2001.07.28.05.36.18;	author pvalchev;	state Exp;
branches;
next	1.57;

1.57
date	2001.06.27.06.16.50;	author art;	state Exp;
branches;
next	1.56;

1.56
date	2001.06.24.20.30.52;	author angelos;	state Exp;
branches;
next	1.55;

1.55
date	2001.06.24.16.05.33;	author art;	state Exp;
branches;
next	1.54;

1.54
date	2001.06.23.21.59.44;	author art;	state Exp;
branches;
next	1.53;

1.53
date	2001.05.11.14.35.29;	author deraadt;	state Exp;
branches;
next	1.52;

1.52
date	2001.05.11.06.46.40;	author angelos;	state Exp;
branches;
next	1.51;

1.51
date	2001.04.30.13.54.51;	author art;	state Exp;
branches;
next	1.50;

1.50
date	2001.04.30.12.07.30;	author art;	state Exp;
branches;
next	1.49;

1.49
date	2001.04.30.09.39.27;	author art;	state Exp;
branches;
next	1.48;

1.48
date	2001.03.21.23.51.47;	author art;	state Exp;
branches;
next	1.47;

1.47
date	2001.01.04.17.40.26;	author angelos;	state Exp;
branches;
next	1.46;

1.46
date	2001.01.04.07.58.06;	author angelos;	state Exp;
branches;
next	1.45;

1.45
date	2001.01.04.07.08.18;	author angelos;	state Exp;
branches;
next	1.44;

1.44
date	2001.01.04.06.50.21;	author angelos;	state Exp;
branches;
next	1.43;

1.43
date	2001.01.04.06.26.49;	author angelos;	state Exp;
branches;
next	1.42;

1.42
date	2001.01.03.19.24.04;	author angelos;	state Exp;
branches;
next	1.41;

1.41
date	2001.01.02.17.51.11;	author mickey;	state Exp;
branches;
next	1.40;

1.40
date	2001.01.02.17.27.29;	author angelos;	state Exp;
branches;
next	1.39;

1.39
date	2000.11.26.02.30.30;	author art;	state Exp;
branches;
next	1.38;

1.38
date	2000.10.25.16.49.32;	author mickey;	state Exp;
branches;
next	1.37;

1.37
date	2000.06.27.18.11.48;	author art;	state Exp;
branches;
next	1.36;

1.36
date	2000.06.18.17.59.56;	author niklas;	state Exp;
branches;
next	1.35;

1.35
date	99.12.12.00.52.21;	author hugh;	state Exp;
branches;
next	1.34;

1.34
date	99.09.02.01.23.30;	author deraadt;	state Exp;
branches;
next	1.33;

1.33
date	99.08.16.19.06.15;	author art;	state Exp;
branches;
next	1.32;

1.32
date	99.07.17.22.11.15;	author art;	state Exp;
branches;
next	1.31;

1.31
date	99.06.24.12.36.17;	author art;	state Exp;
branches;
next	1.30;

1.30
date	99.06.23.19.25.56;	author art;	state Exp;
branches;
next	1.29;

1.29
date	99.06.23.18.48.12;	author art;	state Exp;
branches;
next	1.28;

1.28
date	99.06.11.23.10.52;	author espie;	state Exp;
branches;
next	1.27;

1.27
date	99.05.13.22.12.50;	author alex;	state Exp;
branches;
next	1.26;

1.26
date	99.03.15.15.38.48;	author deraadt;	state Exp;
branches;
next	1.25;

1.25
date	98.07.08.22.14.18;	author deraadt;	state Exp;
branches;
next	1.24;

1.24
date	98.05.19.17.38.20;	author mickey;	state Exp;
branches;
next	1.23;

1.23
date	97.11.30.09.18.25;	author deraadt;	state Exp;
branches;
next	1.22;

1.22
date	97.11.09.22.13.49;	author millert;	state Exp;
branches;
next	1.21;

1.21
date	97.11.07.18.45.29;	author millert;	state Exp;
branches;
next	1.20;

1.20
date	97.06.30.07.04.08;	author deraadt;	state Exp;
branches;
next	1.19;

1.19
date	97.06.30.07.03.06;	author deraadt;	state Exp;
branches;
next	1.18;

1.18
date	97.02.22.17.20.30;	author kstailey;	state Exp;
branches;
next	1.17;

1.17
date	97.02.13.20.17.16;	author kstailey;	state Exp;
branches;
next	1.16;

1.16
date	97.01.15.23.43.34;	author millert;	state Exp;
branches;
next	1.15;

1.15
date	96.12.22.03.26.09;	author tholo;	state Exp;
branches;
next	1.14;

1.14
date	96.12.04.10.04.44;	author deraadt;	state Exp;
branches;
next	1.13;

1.13
date	96.06.24.23.51.59;	author tholo;	state Exp;
branches;
next	1.12;

1.12
date	96.06.22.17.38.14;	author tholo;	state Exp;
branches;
next	1.11;

1.11
date	96.06.10.07.49.16;	author deraadt;	state Exp;
branches;
next	1.10;

1.10
date	96.05.22.11.35.45;	author deraadt;	state Exp;
branches;
next	1.9;

1.9
date	96.04.21.23.44.44;	author deraadt;	state Exp;
branches;
next	1.8;

1.8
date	96.04.18.12.00.05;	author mickey;	state Exp;
branches;
next	1.7;

1.7
date	96.04.18.10.57.19;	author mickey;	state Exp;
branches;
next	1.6;

1.6
date	96.03.03.02.51.24;	author tholo;	state Exp;
branches;
next	1.5;

1.5
date	96.03.01.07.35.40;	author tholo;	state Exp;
branches;
next	1.4;

1.4
date	96.02.20.04.48.36;	author tholo;	state Exp;
branches;
next	1.3;

1.3
date	95.10.28.04.41.40;	author deraadt;	state Exp;
branches;
next	1.2;

1.2
date	95.10.18.17.28.55;	author deraadt;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.46.50;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.46.50;	author deraadt;	state Exp;
branches;
next	;


desc
@@


1.141
log
@Convert %q to %ll and cast opaque system values to long long.
Use uint64_t for the KERN_INTRCNT_CNT sysctl()

ok krw@@
@
text
@/*	$NetBSD: vmstat.c,v 1.29.4.1 1996/06/05 00:21:05 cgd Exp $	*/
/*	$OpenBSD: vmstat.c,v 1.140 2016/07/27 14:44:59 tedu Exp $	*/

/*
 * Copyright (c) 1980, 1986, 1991, 1993
 *	The Regents of the University of California.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */

#include <sys/param.h>	/* MAXCOMLEN */
#include <sys/time.h>
#include <sys/proc.h>
#include <sys/namei.h>
#include <sys/malloc.h>
#include <sys/fcntl.h>
#include <sys/ioctl.h>
#include <sys/sysctl.h>
#include <sys/device.h>
#include <sys/pool.h>
#include <sys/sched.h>
#include <sys/vmmeter.h>

#include <time.h>
#include <nlist.h>
#include <kvm.h>
#include <err.h>
#include <errno.h>
#include <unistd.h>
#include <signal.h>
#include <stdio.h>
#include <ctype.h>
#include <stdlib.h>
#include <string.h>
#include <paths.h>
#include <limits.h>
#include "dkstats.h"

struct nlist namelist[] = {
#define X_UVMEXP	0		/* sysctl */
	{ "_uvmexp" },
#define	X_TIME_UPTIME	1
	{ "_time_uptime" },
#define X_NCHSTATS	2		/* sysctl */
	{ "_nchstats" },
#define	X_KMEMSTAT	3		/* sysctl */
	{ "_kmemstats" },
#define	X_KMEMBUCKETS	4		/* sysctl */
	{ "_bucket" },
#define	X_FORKSTAT	5		/* sysctl */
	{ "_forkstat" },
#define X_NSELCOLL	6		/* sysctl */
	{ "_nselcoll" },
#define X_POOLHEAD	7		/* sysctl */
	{ "_pool_head" },
#define	X_NAPTIME	8
	{ "_naptime" },
	{ "" },
};

/* Objects defined in dkstats.c */
extern struct _disk	cur, last;
extern char	**dr_name;
extern int	*dk_select, dk_ndrive;

struct	uvmexp uvmexp, ouvmexp;
int		ndrives;

int	winlines = 20;

kvm_t *kd;

#define	FORKSTAT	0x01
#define	INTRSTAT	0x02
#define	MEMSTAT		0x04
#define	SUMSTAT		0x08
#define	TIMESTAT	0x10
#define	VMSTAT		0x20

void	cpustats(void);
time_t	getuptime(void);
void	dkstats(void);
void	dointr(void);
void	domem(void);
void	dopool(void);
void	dosum(void);
void	dovmstat(u_int, int);
void	kread(int, void *, size_t);
void	usage(void);
void	dotimes(void);
void	doforkst(void);
void	needhdr(int);
int	pct(int64_t, int64_t);
void	printhdr(void);

char	**choosedrives(char **);

/* Namelist and memory file names. */
char	*nlistf, *memf;

extern char *__progname;

int verbose = 0;
int zflag = 0;

int
main(int argc, char *argv[])
{
	char errbuf[_POSIX2_LINE_MAX];
	int c, todo = 0, reps = 0;
	const char *errstr;
	u_int interval = 0;

	while ((c = getopt(argc, argv, "c:fiM:mN:stw:vz")) != -1) {
		switch (c) {
		case 'c':
			reps = strtonum(optarg, 0, INT_MAX, &errstr);
			if (errstr)
				errx(1, "-c %s: %s", optarg, errstr);
			break;
		case 'f':
			todo |= FORKSTAT;
			break;
		case 'i':
			todo |= INTRSTAT;
			break;
		case 'M':
			memf = optarg;
			break;
		case 'm':
			todo |= MEMSTAT;
			break;
		case 'N':
			nlistf = optarg;
			break;
		case 's':
			todo |= SUMSTAT;
			break;
		case 't':
			todo |= TIMESTAT;
			break;
		case 'w':
			interval = (u_int)strtonum(optarg, 0, 1000, &errstr);
			if (errstr)
				errx(1, "-w %s: %s", optarg, errstr);
			break;
		case 'v':
			verbose = 1;
			break;
		case 'z':
			zflag = 1;
			break;
		case '?':
		default:
			usage();
		}
	}
	argc -= optind;
	argv += optind;

	if (todo == 0)
		todo = VMSTAT;

	if (nlistf != NULL || memf != NULL) {

		kd = kvm_openfiles(nlistf, memf, NULL, O_RDONLY, errbuf);
		if (kd == 0)
			errx(1, "kvm_openfiles: %s", errbuf);

		if ((c = kvm_nlist(kd, namelist)) != 0) {

			if (c > 0) {
				(void)fprintf(stderr,
				    "%s: undefined symbols:", __progname);
				for (c = 0;
				    c < sizeof(namelist)/sizeof(namelist[0]);
				    c++)
					if (namelist[c].n_type == 0)
						fprintf(stderr, " %s",
						    namelist[c].n_name);
				(void)fputc('\n', stderr);
				exit(1);
			} else
				errx(1, "kvm_nlist: %s", kvm_geterr(kd));
		}
	}

	if (todo & VMSTAT) {
		struct winsize winsize;

		dkinit(0);	/* Initialize disk stats, no disks selected. */
		argv = choosedrives(argv);	/* Select disks. */
		winsize.ws_row = 0;
		(void) ioctl(STDOUT_FILENO, TIOCGWINSZ, &winsize);
		if (winsize.ws_row > 0)
			winlines = winsize.ws_row;

	}

#define	BACKWARD_COMPATIBILITY
#ifdef	BACKWARD_COMPATIBILITY
	if (*argv) {
		interval = (u_int)strtonum(*argv, 0, 1000, &errstr);
		if (errstr)
			errx(1, "interval %s: %s", *argv, errstr);

		if (*++argv) {
			reps = strtonum(*argv, 0, INT_MAX, &errstr);
			if (errstr)
				errx(1, "reps %s: %s", *argv, errstr);
		}
	}
#endif

	if (interval) {
		if (!reps)
			reps = -1;
	} else if (reps)
		interval = 1;

	if (todo & FORKSTAT)
		doforkst();
	if (todo & MEMSTAT) {
		domem();
		dopool();
	}
	if (todo & SUMSTAT)
		dosum();
	if (todo & TIMESTAT)
		dotimes();
	if (todo & INTRSTAT)
		dointr();
	if (todo & VMSTAT)
		dovmstat(interval, reps);
	exit(0);
}

char **
choosedrives(char **argv)
{
	int i;

	/*
	 * Choose drives to be displayed.  Priority goes to (in order) drives
	 * supplied as arguments, default drives.  If everything isn't filled
	 * in and there are drives not taken care of, display the first few
	 * that fit.
	 */
#define BACKWARD_COMPATIBILITY
	for (ndrives = 0; *argv; ++argv) {
#ifdef	BACKWARD_COMPATIBILITY
		if (isdigit((unsigned char)**argv))
			break;
#endif
		for (i = 0; i < dk_ndrive; i++) {
			if (strcmp(dr_name[i], *argv))
				continue;
			dk_select[i] = 1;
			++ndrives;
			break;
		}
		if (i == dk_ndrive)
			errx(1, "invalid interval or drive name: %s", *argv);
	}
	for (i = 0; i < dk_ndrive && ndrives < 2; i++) {
		if (dk_select[i])
			continue;
		dk_select[i] = 1;
		++ndrives;
	}
	return(argv);
}

time_t
getuptime(void)
{
	struct timespec uptime;
	time_t time_uptime, naptime;

	if (nlistf == NULL && memf == NULL) {
		if (clock_gettime(CLOCK_UPTIME, &uptime) == -1)
			err(1, "clock_gettime");
		return (uptime.tv_sec);
	}

	kread(X_NAPTIME, &naptime, sizeof(naptime));
	kread(X_TIME_UPTIME, &time_uptime, sizeof(time_uptime));
	return (time_uptime - naptime);
}

int	hz;
volatile sig_atomic_t hdrcnt;

void
dovmstat(u_int interval, int reps)
{
	time_t uptime, halfuptime;
	struct clockinfo clkinfo;
	struct vmtotal total;
	size_t size;
	int mib[2];

	uptime = getuptime();
	halfuptime = uptime / 2;
	(void)signal(SIGCONT, needhdr);

	mib[0] = CTL_KERN;
	mib[1] = KERN_CLOCKRATE;
	size = sizeof(clkinfo);
	if (sysctl(mib, 2, &clkinfo, &size, NULL, 0) < 0) {
		warn("could not read kern.clockrate");
		return;
	}
	hz = clkinfo.stathz;

	for (hdrcnt = 1;;) {
		/* Read new disk statistics */
		dkreadstats();
		if (!--hdrcnt || last.dk_ndrive != cur.dk_ndrive)
			printhdr();
		if (nlistf == NULL && memf == NULL) {
			size = sizeof(struct uvmexp);
			mib[0] = CTL_VM;
			mib[1] = VM_UVMEXP;
			if (sysctl(mib, 2, &uvmexp, &size, NULL, 0) < 0) {
				warn("could not get vm.uvmexp");
				memset(&uvmexp, 0, sizeof(struct uvmexp));
			}
		} else {
			kread(X_UVMEXP, &uvmexp, sizeof(struct uvmexp));
		}
		size = sizeof(total);
		mib[0] = CTL_VM;
		mib[1] = VM_METER;
		if (sysctl(mib, 2, &total, &size, NULL, 0) < 0) {
			warn("could not read vm.vmmeter");
			memset(&total, 0, sizeof(total));
		}
		(void)printf(" %u %u %u ",
		    total.t_rq - 1, total.t_dw + total.t_pw, total.t_sw);
#define	rate(x)	((unsigned)((((unsigned)x) + halfuptime) / uptime)) /* round */
#define pgtok(a) ((a) * ((unsigned int)uvmexp.pagesize >> 10))
		(void)printf("%6u %7u ",
		    pgtok(uvmexp.active + uvmexp.swpginuse),
		    pgtok(uvmexp.free));
		(void)printf("%4u ", rate(uvmexp.faults - ouvmexp.faults));
		(void)printf("%3u ", rate(uvmexp.pdreact - ouvmexp.pdreact));
		(void)printf("%3u ", rate(uvmexp.pageins - ouvmexp.pageins));
		(void)printf("%3u %3u ",
		    rate(uvmexp.pdpageouts - ouvmexp.pdpageouts), 0);
		(void)printf("%3u ", rate(uvmexp.pdscans - ouvmexp.pdscans));
		dkstats();
		(void)printf("%4u %5u %4u ",
		    rate(uvmexp.intrs - ouvmexp.intrs),
		    rate(uvmexp.syscalls - ouvmexp.syscalls),
		    rate(uvmexp.swtch - ouvmexp.swtch));
		cpustats();
		(void)printf("\n");
		(void)fflush(stdout);
		if (reps >= 0 && --reps <= 0)
			break;
		ouvmexp = uvmexp;
		uptime = interval;
		/*
		 * We round upward to avoid losing low-frequency events
		 * (i.e., >= 1 per interval but < 1 per second).
		 */
		halfuptime = uptime == 1 ? 0 : (uptime + 1) / 2;
		(void)sleep(interval);
	}
}

void
printhdr(void)
{
	int i;
	static int printedhdr;

	if (printedhdr && !isatty(STDOUT_FILENO))
		return;

	(void)printf(" procs    memory       page%*s", 20, "");
	if (ndrives > 0)
		(void)printf("%s %*straps          cpu\n",
		   ((ndrives > 1) ? "disks" : "disk"),
		   ((ndrives > 1) ? ndrives * 4 - 5 : 0), "");
	else
		(void)printf("%*s  traps           cpu\n",
		   ndrives * 3, "");

	(void)printf(" r b w    avm     fre  flt  re  pi  po  fr  sr ");
	for (i = 0; i < dk_ndrive; i++)
		if (dk_select[i])
			(void)printf("%c%c%c ", dr_name[i][0],
			    dr_name[i][1],
			    dr_name[i][strlen(dr_name[i]) - 1]);
	(void)printf(" int   sys   cs us sy id\n");
	hdrcnt = winlines - 2;
	printedhdr = 1;
}

/*
 * Force a header to be prepended to the next output.
 */
void
needhdr(__unused int signo)
{

	hdrcnt = 1;
}

void
dotimes(void)
{
	u_int pgintime, rectime;
	size_t size;
	int mib[2];

	/* XXX Why are these set to 0 ? This doesn't look right. */
	pgintime = 0;
	rectime = 0;

	if (nlistf == NULL && memf == NULL) {
		size = sizeof(struct uvmexp);
		mib[0] = CTL_VM;
		mib[1] = VM_UVMEXP;
		if (sysctl(mib, 2, &uvmexp, &size, NULL, 0) < 0) {
			warn("could not read vm.uvmexp");
			memset(&uvmexp, 0, sizeof(struct uvmexp));
		}
	} else {
		kread(X_UVMEXP, &uvmexp, sizeof(struct uvmexp));
	}

	(void)printf("%u reactivates, %u total time (usec)\n",
	    uvmexp.pdreact, rectime);
	if (uvmexp.pdreact != 0)
		(void)printf("average: %u usec / reclaim\n",
		    rectime / uvmexp.pdreact);
	(void)printf("\n");
	(void)printf("%u page ins, %u total time (msec)\n",
	    uvmexp.pageins, pgintime / 10);
	if (uvmexp.pageins != 0)
		(void)printf("average: %8.1f msec / page in\n",
		    pgintime / (uvmexp.pageins * 10.0));
}

int
pct(int64_t top, int64_t bot)
{
	int ans;

	if (bot == 0)
		return(0);
	ans = top * 100 / bot;
	return (ans);
}

void
dosum(void)
{
	struct nchstats nchstats;
	int mib[2], nselcoll;
	long long nchtotal;
	size_t size;

	if (nlistf == NULL && memf == NULL) {
		size = sizeof(struct uvmexp);
		mib[0] = CTL_VM;
		mib[1] = VM_UVMEXP;
		if (sysctl(mib, 2, &uvmexp, &size, NULL, 0) < 0) {
			warn("could not read vm.uvmexp");
			memset(&uvmexp, 0, sizeof(struct uvmexp));
		}
	} else {
		kread(X_UVMEXP, &uvmexp, sizeof(struct uvmexp));
	}

	/* vm_page constants */
	(void)printf("%11u bytes per page\n", uvmexp.pagesize);

	/* vm_page counters */
	(void)printf("%11u pages managed\n", uvmexp.npages);
	(void)printf("%11u pages free\n", uvmexp.free);
	(void)printf("%11u pages active\n", uvmexp.active);
	(void)printf("%11u pages inactive\n", uvmexp.inactive);
	(void)printf("%11u pages being paged out\n", uvmexp.paging);
	(void)printf("%11u pages wired\n", uvmexp.wired);
	(void)printf("%11u pages zeroed\n", uvmexp.zeropages);
	(void)printf("%11u pages reserved for pagedaemon\n",
		     uvmexp.reserve_pagedaemon);
	(void)printf("%11u pages reserved for kernel\n",
		     uvmexp.reserve_kernel);

	/* swap */
	(void)printf("%11u swap pages\n", uvmexp.swpages);
	(void)printf("%11u swap pages in use\n", uvmexp.swpginuse);
	(void)printf("%11u total anon's in system\n", uvmexp.nanon);
	(void)printf("%11u free anon's\n", uvmexp.nfreeanon);

	/* stat counters */
	(void)printf("%11u page faults\n", uvmexp.faults);
	(void)printf("%11u traps\n", uvmexp.traps);
	(void)printf("%11u interrupts\n", uvmexp.intrs);
	(void)printf("%11u cpu context switches\n", uvmexp.swtch);
	(void)printf("%11u fpu context switches\n", uvmexp.fpswtch);
	(void)printf("%11u software interrupts\n", uvmexp.softs);
	(void)printf("%11u syscalls\n", uvmexp.syscalls);
	(void)printf("%11u pagein operations\n", uvmexp.pageins);
	(void)printf("%11u forks\n", uvmexp.forks);
	(void)printf("%11u forks where vmspace is shared\n",
		     uvmexp.forks_sharevm);
	(void)printf("%11u kernel map entries\n", uvmexp.kmapent);
	(void)printf("%11u zeroed page hits\n", uvmexp.pga_zerohit);
	(void)printf("%11u zeroed page misses\n", uvmexp.pga_zeromiss);

	/* daemon counters */
	(void)printf("%11u number of times the pagedaemon woke up\n",
		     uvmexp.pdwoke);
	(void)printf("%11u revolutions of the clock hand\n", uvmexp.pdrevs);
	(void)printf("%11u pages freed by pagedaemon\n", uvmexp.pdfreed);
	(void)printf("%11u pages scanned by pagedaemon\n", uvmexp.pdscans);
	(void)printf("%11u pages reactivated by pagedaemon\n", uvmexp.pdreact);
	(void)printf("%11u busy pages found by pagedaemon\n", uvmexp.pdbusy);

	if (nlistf == NULL && memf == NULL) {
		size = sizeof(nchstats);
		mib[0] = CTL_KERN;
		mib[1] = KERN_NCHSTATS;
		if (sysctl(mib, 2, &nchstats, &size, NULL, 0) < 0) {
			warn("could not read kern.nchstats");
			memset(&nchstats, 0, sizeof(nchstats));
		}
	} else {
		kread(X_NCHSTATS, &nchstats, sizeof(nchstats));
	}

	nchtotal = nchstats.ncs_goodhits + nchstats.ncs_neghits +
	    nchstats.ncs_badhits + nchstats.ncs_falsehits +
	    nchstats.ncs_miss + nchstats.ncs_long;
	(void)printf("%11lld total name lookups\n", nchtotal);
	(void)printf("%11s cache hits (%d%% pos + %d%% neg) system %d%% "
	    "per-directory\n",
	    "", pct(nchstats.ncs_goodhits, nchtotal),
	    pct(nchstats.ncs_neghits, nchtotal),
	    pct(nchstats.ncs_pass2, nchtotal));
	(void)printf("%11s deletions %d%%, falsehits %d%%, toolong %d%%\n", "",
	    pct(nchstats.ncs_badhits, nchtotal),
	    pct(nchstats.ncs_falsehits, nchtotal),
	    pct(nchstats.ncs_long, nchtotal));

	if (nlistf == NULL && memf == NULL) {
		size = sizeof(nselcoll);
		mib[0] = CTL_KERN;
		mib[1] = KERN_NSELCOLL;
		if (sysctl(mib, 2, &nselcoll, &size, NULL, 0) < 0) {
			warn("could not read kern.nselcoll");
			nselcoll = 0;
		}
	} else {
		kread(X_NSELCOLL, &nselcoll, sizeof(nselcoll));
	}
	(void)printf("%11d select collisions\n", nselcoll);
}

void
doforkst(void)
{
	struct forkstat fks;
	size_t size;
	int mib[2];

	if (nlistf == NULL && memf == NULL) {
		size = sizeof(struct forkstat);
		mib[0] = CTL_KERN;
		mib[1] = KERN_FORKSTAT;
		if (sysctl(mib, 2, &fks, &size, NULL, 0) < 0) {
			warn("could not read kern.forkstat");
			memset(&fks, 0, sizeof(struct forkstat));
		}
	} else {
		kread(X_FORKSTAT, &fks, sizeof(struct forkstat));
	}

	(void)printf("%u forks, %llu pages, average %.2f\n",
	    fks.cntfork, fks.sizfork, (double)fks.sizfork / fks.cntfork);
	(void)printf("%u vforks, %llu pages, average %.2f\n",
	    fks.cntvfork, fks.sizvfork,
	    (double)fks.sizvfork / (fks.cntvfork ? fks.cntvfork : 1));
	(void)printf("%u __tforks, %llu pages, average %.2f\n",
	    fks.cnttfork, fks.siztfork,
	    (double)fks.siztfork / (fks.cnttfork ? fks.cnttfork : 1));
	(void)printf("%u kthread creations, %llu pages, average %.2f\n",
	    fks.cntkthread, fks.sizkthread,
	    (double)fks.sizkthread / (fks.cntkthread ? fks.cntkthread : 1));
}

void
dkstats(void)
{
	int dn, state;
	double etime;

	/* Calculate disk stat deltas. */
	dkswap();
	etime = 0;
	for (state = 0; state < CPUSTATES; ++state) {
		etime += cur.cp_time[state];
	}
	if (etime == 0)
		etime = 1;
	etime /= hz;
	for (dn = 0; dn < dk_ndrive; ++dn) {
		if (!dk_select[dn])
			continue;
		(void)printf("%3.0f ",
		    (cur.dk_rxfer[dn] + cur.dk_rxfer[dn]) / etime);
	}
}

void
cpustats(void)
{
	double percent, total;
	int state;

	total = 0;
	for (state = 0; state < CPUSTATES; ++state)
		total += cur.cp_time[state];
	if (total)
		percent = 100 / total;
	else
		percent = 0;
	(void)printf("%2.0f ", (cur.cp_time[CP_USER] + cur.cp_time[CP_NICE]) * percent);
	(void)printf("%2.0f ", (cur.cp_time[CP_SYS] + cur.cp_time[CP_INTR]) * percent);
	(void)printf("%2.0f", cur.cp_time[CP_IDLE] * percent);
}

void
dointr(void)
{
	int nintr, mib[4], i;
	char intrname[128];
	u_int64_t inttotal;
	time_t uptime;
	size_t siz;

	if (nlistf != NULL || memf != NULL) {
		errx(1,
		    "interrupt statistics are only available on live kernels");
	}

	uptime = getuptime();

	mib[0] = CTL_KERN;
	mib[1] = KERN_INTRCNT;
	mib[2] = KERN_INTRCNT_NUM;
	siz = sizeof(nintr);
	if (sysctl(mib, 3, &nintr, &siz, NULL, 0) < 0) {
		warnx("could not read kern.intrcnt.nintrcnt");
		return;
	}

	(void)printf("%-16s %20s %8s\n", "interrupt", "total", "rate");

	inttotal = 0;
	for (i = 0; i < nintr; i++) {
		char name[128];
		uint64_t cnt;
		int vector;

		mib[0] = CTL_KERN;
		mib[1] = KERN_INTRCNT;
		mib[2] = KERN_INTRCNT_NAME;
		mib[3] = i;
		siz = sizeof(name);
		if (sysctl(mib, 4, name, &siz, NULL, 0) < 0) {
			warnx("could not read kern.intrcnt.name.%d", i);
			return;
		}

		mib[0] = CTL_KERN;
		mib[1] = KERN_INTRCNT;
		mib[2] = KERN_INTRCNT_VECTOR;
		mib[3] = i;
		siz = sizeof(vector);
		if (sysctl(mib, 4, &vector, &siz, NULL, 0) < 0) {
			strlcpy(intrname, name, sizeof(intrname));
		} else {
			snprintf(intrname, sizeof(intrname), "irq%d/%s",
			    vector, name);
		}

		mib[0] = CTL_KERN;
		mib[1] = KERN_INTRCNT;
		mib[2] = KERN_INTRCNT_CNT;
		mib[3] = i;
		siz = sizeof(cnt);
		if (sysctl(mib, 4, &cnt, &siz, NULL, 0) < 0) {
			warnx("could not read kern.intrcnt.cnt.%d", i);
			return;
		}

		if (cnt || zflag)
			(void)printf("%-16.16s %20llu %8llu\n", intrname,
			    cnt, cnt / uptime);
		inttotal += cnt;
	}

	(void)printf("%-16s %20llu %8llu\n", "Total", inttotal,
	    inttotal / uptime);
}

/*
 * These names are defined in <sys/malloc.h>.
 */
const char *kmemnames[] = INITKMEMNAMES;

void
domem(void)
{
	struct kmembuckets buckets[MINBUCKET + 16], *kp;
	struct kmemstats kmemstats[M_LAST], *ks;
	int i, j, len, size, first, mib[4];
	u_long totuse = 0, totfree = 0;
	char buf[BUFSIZ], *bufp, *ap;
	unsigned long long totreq = 0;
	const char *name;
	size_t siz;

	if (memf == NULL && nlistf == NULL) {
		mib[0] = CTL_KERN;
		mib[1] = KERN_MALLOCSTATS;
		mib[2] = KERN_MALLOC_BUCKETS;
		siz = sizeof(buf);
		if (sysctl(mib, 3, buf, &siz, NULL, 0) < 0) {
			warnx("could not read kern.malloc.buckets");
			return;
		}

		bufp = buf;
		mib[2] = KERN_MALLOC_BUCKET;
		siz = sizeof(struct kmembuckets);
		i = 0;
		while ((ap = strsep(&bufp, ",")) != NULL) {
			const char *errstr;

			mib[3] = strtonum(ap, 0, INT_MAX, &errstr);
			if (errstr) {
				warnx("kernel lied about %d being a number", mib[3]);
				return;
			}

			if (sysctl(mib, 4, &buckets[MINBUCKET + i], &siz,
			    NULL, 0) < 0) {
				warn("could not read kern.malloc.bucket.%d", mib[3]);
				return;
			}
			i++;
		}
	} else {
		kread(X_KMEMBUCKETS, buckets, sizeof(buckets));
	}

	for (first = 1, i = MINBUCKET, kp = &buckets[i]; i < MINBUCKET + 16;
	     i++, kp++) {
		if (kp->kb_calls == 0 && !verbose)
			continue;
		if (first) {
			(void)printf("Memory statistics by bucket size\n");
			(void)printf(
		"    Size   In Use   Free           Requests  HighWater  Couldfree\n");
			first = 0;
		}
		size = 1 << i;
		(void)printf("%8d %8llu %6llu %18llu %7llu %10llu\n", size,
			(unsigned long long)(kp->kb_total - kp->kb_totalfree),
			(unsigned long long)kp->kb_totalfree,
			(unsigned long long)kp->kb_calls,
			(unsigned long long)kp->kb_highwat,
			(unsigned long long)kp->kb_couldfree);
		totfree += size * kp->kb_totalfree;
	}

	/*
	 * If kmem statistics are not being gathered by the kernel,
	 * first will still be 1.
	 */
	if (first) {
		printf(
		    "Kmem statistics are not being gathered by the kernel.\n");
		return;
	}

	if (memf == NULL && nlistf == NULL) {
		memset(kmemstats, 0, sizeof(kmemstats));
		for (i = 0; i < M_LAST; i++) {
			mib[0] = CTL_KERN;
			mib[1] = KERN_MALLOCSTATS;
			mib[2] = KERN_MALLOC_KMEMSTATS;
			mib[3] = i;
			siz = sizeof(struct kmemstats);

			/*
			 * Skip errors -- these are presumed to be unallocated
			 * entries.
			 */
			if (sysctl(mib, 4, &kmemstats[i], &siz, NULL, 0) < 0)
				continue;
		}
	} else {
		kread(X_KMEMSTAT, kmemstats, sizeof(kmemstats));
	}

	(void)printf("\nMemory usage type by bucket size\n");
	(void)printf("    Size  Type(s)\n");
	kp = &buckets[MINBUCKET];
	for (j =  1 << MINBUCKET; j < 1 << (MINBUCKET + 16); j <<= 1, kp++) {
		if (kp->kb_calls == 0)
			continue;
		first = 1;
		len = 8;
		for (i = 0, ks = &kmemstats[0]; i < M_LAST; i++, ks++) {
			if (ks->ks_calls == 0)
				continue;
			if ((ks->ks_size & j) == 0)
				continue;
			name = kmemnames[i] ? kmemnames[i] : "undefined";
			len += 2 + strlen(name);
			if (first)
				printf("%8d  %s", j, name);
			else
				printf(",");
			if (len >= 80) {
				printf("\n\t ");
				len = 10 + strlen(name);
			}
			if (!first)
				printf(" %s", name);
			first = 0;
		}
		printf("\n");
	}

	(void)printf(
	   "\nMemory statistics by type                           Type  Kern\n");
	(void)printf(
"          Type InUse MemUse HighUse  Limit Requests Limit Limit Size(s)\n");
	for (i = 0, ks = &kmemstats[0]; i < M_LAST; i++, ks++) {
		if (ks->ks_calls == 0)
			continue;
		(void)printf("%14s%6ld%6ldK%7ldK%6ldK%9ld%5u%6u",
		    kmemnames[i] ? kmemnames[i] : "undefined",
		    ks->ks_inuse, (ks->ks_memuse + 1023) / 1024,
		    (ks->ks_maxused + 1023) / 1024,
		    (ks->ks_limit + 1023) / 1024, ks->ks_calls,
		    ks->ks_limblocks, ks->ks_mapblocks);
		first = 1;
		for (j =  1 << MINBUCKET; j < 1 << (MINBUCKET + 16); j <<= 1) {
			if ((ks->ks_size & j) == 0)
				continue;
			if (first)
				printf("  %d", j);
			else
				printf(",%d", j);
			first = 0;
		}
		printf("\n");
		totuse += ks->ks_memuse;
		totreq += ks->ks_calls;
	}
	(void)printf("\nMemory Totals:  In Use    Free    Requests\n");
	(void)printf("              %7luK %6luK    %8llu\n",
	     (totuse + 1023) / 1024, (totfree + 1023) / 1024, totreq);
}

static void
print_pool(struct kinfo_pool *pp, char *name)
{
	static int first = 1;
	char maxp[32];
	int ovflw;

	if (first) {
		(void)printf("Memory resource pool statistics\n");
		(void)printf(
		    "%-11s%5s%9s%5s%9s%6s%6s%6s%6s%6s%6s%5s\n",
		    "Name",
		    "Size",
		    "Requests",
		    "Fail",
		    "InUse",
		    "Pgreq",
		    "Pgrel",
		    "Npage",
		    "Hiwat",
		    "Minpg",
		    "Maxpg",
		    "Idle");
		first = 0;
	}

	/* Skip unused pools unless verbose output. */
	if (pp->pr_nget == 0 && !verbose)
		return;

	if (pp->pr_maxpages == UINT_MAX)
		snprintf(maxp, sizeof maxp, "inf");
	else
		snprintf(maxp, sizeof maxp, "%u", pp->pr_maxpages);
/*
 * Print single word.  `ovflow' is number of characters didn't fit
 * on the last word.  `fmt' is a format string to print this word.
 * It must contain asterisk for field width.  `width' is a width
 * occupied by this word.  `fixed' is a number of constant chars in
 * `fmt'.  `val' is a value to be printed using format string `fmt'.
 */
#define	PRWORD(ovflw, fmt, width, fixed, val) do {	\
	(ovflw) += printf((fmt),			\
	    (width) - (fixed) - (ovflw) > 0 ?		\
	    (width) - (fixed) - (ovflw) : 0,		\
	    (val)) - (width);				\
	if ((ovflw) < 0)				\
		(ovflw) = 0;				\
} while (/* CONSTCOND */0)

	ovflw = 0;
	PRWORD(ovflw, "%-*s", 11, 0, name);
	PRWORD(ovflw, " %*u", 5, 1, pp->pr_size);
	PRWORD(ovflw, " %*lu", 9, 1, pp->pr_nget);
	PRWORD(ovflw, " %*lu", 5, 1, pp->pr_nfail);
	PRWORD(ovflw, " %*lu", 9, 1, pp->pr_nget - pp->pr_nput);
	PRWORD(ovflw, " %*lu", 6, 1, pp->pr_npagealloc);
	PRWORD(ovflw, " %*lu", 6, 1, pp->pr_npagefree);
	PRWORD(ovflw, " %*d", 6, 1, pp->pr_npages);
	PRWORD(ovflw, " %*d", 6, 1, pp->pr_hiwat);
	PRWORD(ovflw, " %*d", 6, 1, pp->pr_minpages);
	PRWORD(ovflw, " %*s", 6, 1, maxp);
	PRWORD(ovflw, " %*lu\n", 5, 1, pp->pr_nidle);
}

static void dopool_kvm(void);
static void dopool_sysctl(void);

void
dopool(void)
{
	if (nlistf == NULL && memf == NULL)
		dopool_sysctl();
	else
		dopool_kvm();
}

void
dopool_sysctl(void)
{
	int mib[4], npools, i;
	long total = 0, inuse = 0;
	struct kinfo_pool pool;
	size_t size;

	mib[0] = CTL_KERN;
	mib[1] = KERN_POOL;
	mib[2] = KERN_POOL_NPOOLS;
	size = sizeof(npools);
	if (sysctl(mib, 3, &npools, &size, NULL, 0) < 0) {
		warn("can't figure out number of pools in kernel");
		return;
	}

	for (i = 1; npools; i++) {
		char name[32];

		mib[0] = CTL_KERN;
		mib[1] = KERN_POOL;
		mib[2] = KERN_POOL_POOL;
		mib[3] = i;
		size = sizeof(pool);
		if (sysctl(mib, 4, &pool, &size, NULL, 0) < 0) {
			if (errno == ENOENT)
				continue;
			warn("error getting pool");
			return;
		}
		npools--;
		mib[2] = KERN_POOL_NAME;
		size = sizeof(name);
		if (sysctl(mib, 4, &name, &size, NULL, 0) < 0) {
			warn("error getting pool name");
			return;
		}
		print_pool(&pool, name);

		inuse += (pool.pr_nget - pool.pr_nput) * pool.pr_size;
		total += pool.pr_npages * pool.pr_pgsize;
	}

	inuse /= 1024;
	total /= 1024;
	printf("\nIn use %ldK, total allocated %ldK; utilization %.1f%%\n",
	    inuse, total, (double)(100 * inuse) / total);
}

void
dopool_kvm(void)
{
	SIMPLEQ_HEAD(,pool) pool_head;
	struct pool pool, *pp = &pool;
	struct kinfo_pool pi;
	long total = 0, inuse = 0;
	u_long addr;

	kread(X_POOLHEAD, &pool_head, sizeof(pool_head));
	addr = (u_long)SIMPLEQ_FIRST(&pool_head);

	while (addr != 0) {
		char name[32];

		if (kvm_read(kd, addr, (void *)pp, sizeof *pp) != sizeof *pp) {
			(void)fprintf(stderr,
			    "vmstat: pool chain trashed: %s\n",
			    kvm_geterr(kd));
			exit(1);
		}
		if (kvm_read(kd, (u_long)pp->pr_wchan, name, sizeof name) < 0) {
			(void)fprintf(stderr,
			    "vmstat: pool name trashed: %s\n",
			    kvm_geterr(kd));
			exit(1);
		}
		name[31] = '\0';

		memset(&pi, 0, sizeof(pi));
		pi.pr_size = pp->pr_size;
		pi.pr_pgsize = pp->pr_pgsize;
		pi.pr_itemsperpage = pp->pr_itemsperpage;
		pi.pr_npages = pp->pr_npages;
		pi.pr_minpages = pp->pr_minpages;
		pi.pr_maxpages = pp->pr_maxpages;
		pi.pr_hardlimit = pp->pr_hardlimit;
		pi.pr_nout = pp->pr_nout;
		pi.pr_nitems = pp->pr_nitems;
		pi.pr_nget = pp->pr_nget;
		pi.pr_nput = pp->pr_nput;
		pi.pr_nfail = pp->pr_nfail;
		pi.pr_npagealloc = pp->pr_npagealloc;
		pi.pr_npagefree = pp->pr_npagefree;
		pi.pr_hiwat = pp->pr_hiwat;
		pi.pr_nidle = pp->pr_nidle;

		print_pool(&pi, name);

		inuse += (pi.pr_nget - pi.pr_nput) * pi.pr_size;
		total += pi.pr_npages * pi.pr_pgsize;

		addr = (u_long)SIMPLEQ_NEXT(pp, pr_poollist);
	}

	inuse /= 1024;
	total /= 1024;
	printf("\nIn use %ldK, total allocated %ldK; utilization %.1f%%\n",
	    inuse, total, (double)(100 * inuse) / total);
}

/*
 * kread reads something from the kernel, given its nlist index.
 */
void
kread(int nlx, void *addr, size_t size)
{
	char *sym;

	if (namelist[nlx].n_type == 0 || namelist[nlx].n_value == 0) {
		sym = namelist[nlx].n_name;
		if (*sym == '_')
			++sym;
		errx(1, "symbol %s not defined", sym);
	}
	if (kvm_read(kd, namelist[nlx].n_value, addr, size) != size) {
		sym = namelist[nlx].n_name;
		if (*sym == '_')
			++sym;
		errx(1, "%s: %s", sym, kvm_geterr(kd));
	}
}

void
usage(void)
{
	(void)fprintf(stderr, "usage: %s [-fimstvz] [-c count] [-M core] "
	    "[-N system] [-w wait] [disk ...]\n", __progname);
	exit(1);
}
@


1.140
log
@increase the size of forkstat fields to accomodate large values
@
text
@d2 1
a2 1
/*	$OpenBSD: vmstat.c,v 1.139 2015/12/24 03:25:08 mmcc Exp $	*/
a426 1
/* ARGSUSED */
d428 1
a428 1
needhdr(int signo)
d691 1
a691 1
		u_quad_t cnt;
d749 1
a749 1
	quad_t totreq = 0;
d895 1
a895 1
	(void)printf("              %7luK %6luK    %8qu\n",
@


1.139
log
@Replace bzero with memset. No binary change.

ok tb@@
@
text
@d2 1
a2 1
/*	$OpenBSD: vmstat.c,v 1.138 2015/04/18 18:28:38 deraadt Exp $	*/
d608 1
a608 1
	(void)printf("%d forks, %d pages, average %.2f\n",
d610 1
a610 1
	(void)printf("%d vforks, %d pages, average %.2f\n",
d613 1
a613 1
	(void)printf("%d __tforks, %d pages, average %.2f\n",
d616 1
a616 1
	(void)printf("%d kthread creations, %d pages, average %.2f\n",
@


1.138
log
@Convert many atoi() calls to strtonum(), adding range checks and failure
handling along the way.
Reviews by Brendan MacDonell, Jeremy Devenport, florian, doug, millert
@
text
@d2 1
a2 1
/*	$OpenBSD: vmstat.c,v 1.137 2015/01/30 19:00:56 tedu Exp $	*/
d349 1
a349 1
				bzero(&uvmexp, sizeof(struct uvmexp));
d359 1
a359 1
			bzero(&total, sizeof(total));
d452 1
a452 1
			bzero(&uvmexp, sizeof(struct uvmexp));
d496 1
a496 1
			bzero(&uvmexp, sizeof(struct uvmexp));
d555 1
a555 1
			bzero(&nchstats, sizeof(nchstats));
d602 1
a602 1
			bzero(&fks, sizeof(struct forkstat));
d819 1
a819 1
		bzero(kmemstats, sizeof(kmemstats));
@


1.137
log
@improve argv checking. drive name, if given, must match something.
convert atoi to strtonum.
ok deraadt
@
text
@d2 1
a2 1
/*	$OpenBSD: vmstat.c,v 1.136 2015/01/16 06:40:14 deraadt Exp $	*/
d769 7
a775 1
			mib[3] = atoi(ap);
@


1.136
log
@Replace <sys/param.h> with <limits.h> and other less dirty headers where
possible.  Annotate <sys/param.h> lines with their current reasons.  Switch
to PATH_MAX, NGROUPS_MAX, HOST_NAME_MAX+1, LOGIN_NAME_MAX, etc.  Change
MIN() and MAX() to local definitions of MINIMUM() and MAXIMUM() where
sensible to avoid pulling in the pollution.  These are the files confirmed
through binary verification.
ok guenther, millert, doug (helped with the verification protocol)
@
text
@d2 1
a2 1
/*	$OpenBSD: vmstat.c,v 1.135 2014/12/19 20:18:15 tedu Exp $	*/
d139 3
a141 1
			reps = atoi(optarg);
d227 1
a227 1
			errx(1, "%s: %s", *argv, errstr);
d229 5
a233 2
		if (*++argv)
			reps = atoi(*argv);
d284 2
@


1.135
log
@no need to kvm the palloc. the pgsize is more correctly accessed via pool.
@
text
@d2 1
a2 1
/*	$OpenBSD: vmstat.c,v 1.134 2014/11/23 04:34:48 guenther Exp $	*/
d33 1
a33 1
#include <sys/param.h>
@


1.134
log
@<sys/buf.h> isn't actually needed here

ok tedu@@
@
text
@d2 1
a2 1
/*	$OpenBSD: vmstat.c,v 1.133 2014/09/15 19:08:22 miod Exp $	*/
a1018 1
	struct pool_allocator palloc;
a1040 8
		if (kvm_read(kd, (u_long)pp->pr_alloc,
		    &palloc, sizeof(palloc)) < 0) {
			(void)fprintf(stderr,
			    "vmstat: pool allocator trashed: %s\n",
			    kvm_geterr(kd));
			exit(1);
		}

d1045 1
a1045 1
		pi.pr_pgsize = palloc.pa_pagesz;
@


1.133
log
@Remove non-standard <sys/dkstat.h> header. It has not contained anything
related to disk stastics for almost 17 years, and the remaining
userland-visible defines duplicate those found in <sys/sched.h>.

Move the remaining _KERNEL defines to <sys/tty.h> where they belong, and
update all users to cope with this.

ok kettenis@@
@
text
@d2 1
a2 1
/*	$OpenBSD: vmstat.c,v 1.132 2014/07/13 21:13:51 kettenis Exp $	*/
a35 1
#include <sys/buf.h>
@


1.132
log
@Display zero page hit and miss counters in vmstat -s.

ok deraadt@@
@
text
@d2 1
a2 1
/*	$OpenBSD: vmstat.c,v 1.131 2014/07/08 17:19:26 deraadt Exp $	*/
a35 1
#include <sys/dkstat.h>
d44 1
@


1.131
log
@decouple struct uvmexp into a new file, so that uvm_extern.h and sysctl.h
don't need to be married.
ok guenther miod beck jsing kettenis
@
text
@d2 1
a2 1
/*	$OpenBSD: vmstat.c,v 1.130 2014/07/02 07:16:29 dlg Exp $	*/
d531 2
@


1.130
log
@populate pool npages, as per src/sys/kern/subr_pool.c r1.135
@
text
@d2 1
a2 1
/*	$OpenBSD: vmstat.c,v 1.129 2014/07/02 00:12:34 dlg Exp $	*/
a60 3

#include <uvm/uvm_object.h>
#include <uvm/uvm_extern.h>
@


1.129
log
@info about pools is currently given to userland by copying each
pools struct out. however, struct pool in the kernel contains lots
of things that userland probably isnt interested in, like actual
mutexes, and probably shouldnt get easy access to, like pointers
to kernel memory via all the lists/trees.

this implements a kinfo_pool structure that has only the data that
userland needs to know about. it cuts the sysctl code over to
building it from struct pool as required and copying that out
instead, and cuts userland over to only handling kinfo_pool.

the only problem with this is vmstat, which can read kernel images
via kvm, which needs some understanding of struct pool. to cope,
the struct pool definition is guarded by if defined(_KERNEL) ||
defined(_LIBKVM) as inspired by sysctl which needs to do the same
thing sometimes. struct pool itself is generally not visible to
userland though, which is good.

matthew@@ suggested struct kinfo_pool instead of struct pool_info.
the kinfo prefix has precedent.
lots of people liked this.
@
text
@d2 1
a2 1
/*	$OpenBSD: vmstat.c,v 1.128 2014/04/08 14:04:11 mpi Exp $	*/
d1058 1
@


1.128
log
@Use VM_UVMEXP instead of VM_METER for memory usages and directly
include <sys/vmmeter.h> where it is needed instead of relying on
it being included by <uvm/uvm_extern.h>.

miod@@ likes it, ok guenther@@
@
text
@d2 1
a2 1
/*	$OpenBSD: vmstat.c,v 1.127 2013/11/26 21:08:12 deraadt Exp $	*/
d890 1
a890 1
print_pool(struct pool *pp, char *name)
d971 1
a971 1
	struct pool pool;
d990 1
a990 1
		size = sizeof(struct pool);
d1007 1
a1007 1
		total += pool.pr_npages * getpagesize();	/* XXX */
d1021 2
d1044 7
d1054 18
a1071 1
		print_pool(pp, name);
d1073 2
a1074 2
		inuse += (pp->pr_nget - pp->pr_nput) * pp->pr_size;
		total += pp->pr_npages * getpagesize();	/* XXX */
@


1.127
log
@unsigned char casts for ctype
ok okan
@
text
@d2 1
a2 1
/*	$OpenBSD: vmstat.c,v 1.126 2013/11/13 22:26:02 chl Exp $	*/
d45 2
d363 2
a364 1
		    pgtok(total.t_avm), pgtok(total.t_free));
@


1.126
log
@remove unused variables

ok mikeb@@ bluhm@@
@
text
@d2 1
a2 1
/*	$OpenBSD: vmstat.c,v 1.125 2013/10/31 02:00:11 deraadt Exp $	*/
d271 1
a271 1
		if (isdigit(**argv))
@


1.125
log
@sometimes we find .h we no longer need
@
text
@d2 1
a2 1
/*	$OpenBSD: vmstat.c,v 1.124 2013/10/08 03:04:17 guenther Exp $	*/
d134 1
a134 1
	int c, todo = 0, reps = 0, mib[2];
a136 1
	size_t size;
a1019 1
	int kmfp;
@


1.124
log
@Obtain the uptime of the running system using the new CLOCK_UPTIME,
so that averages/rates are over the actual time-running-not-suspended.
For kernel cores, peek at the 'time_uptime' and 'naptime' variables.

original report by and ok mlarkin@@
@
text
@d2 1
a2 1
/*	$OpenBSD: vmstat.c,v 1.123 2013/08/22 04:43:40 guenther Exp $	*/
a35 1
#include <sys/user.h>
@


1.123
log
@Correct format string mismatches turned up by -Wformat=2

suggestions and ok millert@@
@
text
@d2 1
a2 1
/*	$OpenBSD: vmstat.c,v 1.122 2013/07/18 08:42:50 bluhm Exp $	*/
d67 2
a68 2
#define	X_BOOTTIME	1		/* sysctl */
	{ "_boottime" },
d81 2
d296 2
a297 5
	static struct timeval boottime;
	static time_t now;
	time_t uptime;
	size_t size;
	int mib[2];
d299 4
a302 12
	if (boottime.tv_sec == 0) {
		if (nlistf == NULL && memf == NULL) {
			size = sizeof(boottime);
			mib[0] = CTL_KERN;
			mib[1] = KERN_BOOTTIME;
			if (sysctl(mib, 2, &boottime, &size, NULL, 0) < 0) {
				warn("could not get kern.boottime");
				bzero(&boottime, sizeof(boottime));
			}
		} else {
			kread(X_BOOTTIME, &boottime, sizeof(boottime));
		}
a303 4
	(void)time(&now);
	uptime = now - boottime.tv_sec;
	if (uptime <= 0 || uptime > 60*60*24*365*10)
		errx(1, "time makes no sense; namelist must be wrong");
d305 3
a307 1
	return(uptime);
@


1.122
log
@There is no uvm_km_pages_free in our kernel anymore.  The corresponding
lines in dopool_sysctl() have been removed from vmstat.c revision
1.116.  Remove uvm_km_pages_free from dopool_kvm() to allow analysing
a core dump.
OK guenther@@ miod@@
@
text
@d2 1
a2 1
/*	$OpenBSD: vmstat.c,v 1.121 2013/05/14 20:39:25 miod Exp $	*/
d371 1
a371 1
#define	rate(x)	((((unsigned)x) + halfuptime) / uptime)	/* round */
@


1.121
log
@Don't display swapin/swapout uvmexp fields
@
text
@d2 1
a2 1
/*	$OpenBSD: vmstat.c,v 1.120 2013/03/26 21:13:55 tedu Exp $	*/
a80 2
#define X_KMPAGESFREE	8		/* sysctl */
	{ "_uvm_km_pages_free" },
a1065 2
	kread(X_KMPAGESFREE, &kmfp, sizeof(kmfp));
	total += kmfp * (getpagesize() / 1024);
@


1.120
log
@i broke it. tailq is now simpleq in pool.
found the hard way by otto.
@
text
@d2 1
a2 1
/*	$OpenBSD: vmstat.c,v 1.119 2012/04/12 12:33:04 deraadt Exp $	*/
a541 2
	(void)printf("%11u swap ins\n", uvmexp.swapins);
	(void)printf("%11u swap outs\n", uvmexp.swapouts);
@


1.119
log
@remove rfork(); ok guenther miod
@
text
@d2 1
a2 1
/*	$OpenBSD: vmstat.c,v 1.118 2010/11/19 18:35:16 mikeb Exp $	*/
d1033 1
a1033 1
	TAILQ_HEAD(,pool) pool_head;
d1040 1
a1040 1
	addr = (u_long)TAILQ_FIRST(&pool_head);
d1065 1
a1065 1
		addr = (u_long)TAILQ_NEXT(pp, pr_poollist);
@


1.118
log
@Make KERN_CPTIME return an avarage number of ticks across all CPUs
tedu agreed with an idea, tested by Luis Useche and me; ok deraadt
@
text
@d2 1
a2 1
/*	$OpenBSD: vmstat.c,v 1.117 2010/08/01 02:51:03 chl Exp $	*/
d622 3
a624 3
	(void)printf("%d rforks, %d pages, average %.2f\n",
	    fks.cntrfork, fks.sizrfork,
	    (double)fks.sizrfork / (fks.cntrfork ? fks.cntrfork : 1));
@


1.117
log
@remove unused variable

ok thib@@
@
text
@d2 1
a2 1
/*	$OpenBSD: vmstat.c,v 1.116 2010/07/22 17:31:39 thib Exp $	*/
a130 2
int ncpu;

a211 5
	mib[0] = CTL_HW;
	mib[1] = HW_NCPU;
	size = sizeof(ncpu);
	(void) sysctl(mib, 2, &ncpu, &size, NULL, 0);

a644 1
	etime /= ncpu;
@


1.116
log
@Remove the VM_KMPAGESFREE sysctl. After the pmemrange
changes it was returing a constant 0, changing to cope
with those changes makes less sense then just removing
as it provides the user with no usefull information.

sthen@@ grepped the port's tree for me and found not hits,
thanks!

OK deraadt@@, matthew@@
@
text
@d2 1
a2 1
/*	$OpenBSD: vmstat.c,v 1.115 2010/07/20 19:43:19 lum Exp $	*/
d991 1
a991 1
	int mib[4], npools, i, kmfp;
@


1.115
log
@Remove setresguid since it is no longer needed.
ok matthew@@ millert@@ deraadt@@
@
text
@d2 1
a2 1
/*	$OpenBSD: vmstat.c,v 1.114 2009/11/22 22:22:14 tedu Exp $	*/
a1033 12
	if (nlistf == NULL && memf == NULL) {
		int mib[] = { CTL_VM, VM_KMPAGESFREE };
		size_t size = sizeof(kmfp);

		if (sysctl(mib, 2, &kmfp, &size, NULL, 0) < 0) {
			warn("could not read uvm.kmpagesfree");
			return;
		}
	} else {
		kread(X_KMPAGESFREE, &kmfp, sizeof(kmfp));
	}
	total += kmfp * (getpagesize() / 1024);
@


1.114
log
@don't repeat the banner if not a tty.
add a -c count option to netstat.
tweak spacing to not smear fields in vmstat.
ok deraadt sthen
@
text
@d2 1
a2 1
/*	$OpenBSD: vmstat.c,v 1.113 2009/10/27 23:59:49 deraadt Exp $	*/
a140 1
	gid_t gid;
a189 1
	gid = getgid();
a190 3
		if (setresgid(gid, gid, gid) == -1)
			err(1, "setresgid");
	}
a191 5
	/*
	 * Discard setgid privileges if not the running kernel so that bad
	 * guys can't print interesting stuff from kernel memory.
	 */
	if (nlistf != NULL || memf != NULL) {
a195 4
		if (nlistf == NULL && memf == NULL)
			if (setresgid(gid, gid, gid) == -1)
				err(1, "setresgid");

d212 1
a212 2
	} else if (setresgid(gid, gid, gid) == -1)
		err(1, "setresgid");
@


1.113
log
@rcsid[] and sccsid[] and copyright[] are essentially unmaintained (and
unmaintainable).  these days, people use source.  these id's do not provide
any benefit, and do hurt the small install media
(the 33,000 line diff is essentially mechanical)
ok with the idea millert, ok dms
@
text
@d2 1
a2 1
/*	$OpenBSD: vmstat.c,v 1.112 2009/09/30 19:39:34 naddy Exp $	*/
d393 1
a393 1
		(void)printf("%2u%2u%2u",
d397 1
a397 1
		(void)printf("%7u %7u ",
d430 4
d452 1
@


1.112
log
@Use guaranteed 64-bit arithmetic for the name lookup statistics and
zap the PCT() macro that was a holdover from before we had prototypes.
ok gilles@@, deraadt@@
@
text
@d2 1
a2 1
/*	$OpenBSD: vmstat.c,v 1.111 2008/10/08 17:47:28 deraadt Exp $	*/
a31 14

#ifndef lint
static char copyright[] =
"@@(#) Copyright (c) 1980, 1986, 1991, 1993\n\
	The Regents of the University of California.  All rights reserved.\n";
#endif /* not lint */

#ifndef lint
#if 0
static char sccsid[] = "@@(#)vmstat.c	8.1 (Berkeley) 6/6/93";
#else
static const char rcsid[] = "$OpenBSD: vmstat.c,v 1.111 2008/10/08 17:47:28 deraadt Exp $";
#endif
#endif /* not lint */
@


1.111
log
@use (unsigned) in rate calculation for > 2 billion interrupts.  This will
do until when we tweak struct uvmexp to have unsigned 64 bit counters,
and when we do, it will not break.
from PR 4046, ok millert
@
text
@d2 1
a2 1
/*	$OpenBSD: vmstat.c,v 1.110 2008/09/08 09:06:25 otto Exp $	*/
d43 1
a43 1
static const char rcsid[] = "$OpenBSD: vmstat.c,v 1.110 2008/09/08 09:06:25 otto Exp $";
d132 1
a132 1
int	pct(long, long);
d512 1
a512 1
pct(long top, long bot)
d518 1
a518 1
	ans = (quad_t)top * 100 / bot;
a521 2
#define	PCT(top, bot) pct((long)(top), (long)(bot))

d527 1
a527 1
	long nchtotal;
d604 1
a604 1
	(void)printf("%11ld total name lookups\n", nchtotal);
d607 3
a609 3
	    "", PCT(nchstats.ncs_goodhits, nchtotal),
	    PCT(nchstats.ncs_neghits, nchtotal),
	    PCT(nchstats.ncs_pass2, nchtotal));
d611 3
a613 3
	    PCT(nchstats.ncs_badhits, nchtotal),
	    PCT(nchstats.ncs_falsehits, nchtotal),
	    PCT(nchstats.ncs_long, nchtotal));
@


1.110
log
@"InUse" is much more interesting than "Releases" for pools. ok beck@@
deraadt@@ art@@
@
text
@d2 1
a2 1
/*	$OpenBSD: vmstat.c,v 1.110 2008/09/08 09:05:02 otto Exp $	*/
d43 1
a43 1
static const char rcsid[] = "$OpenBSD: vmstat.c,v 1.110 2008/09/08 09:05:02 otto Exp $";
d409 1
a409 1
#define	rate(x)	(((x) + halfuptime) / uptime)	/* round */
@


1.109
log
@use ellipsis to show that more than one disk is allowed

ok jmc@@
@
text
@d2 1
a2 1
/*	$OpenBSD: vmstat.c,v 1.108 2007/12/30 13:29:52 sobrado Exp $	*/
d43 1
a43 1
static const char rcsid[] = "$OpenBSD: vmstat.c,v 1.108 2007/12/30 13:29:52 sobrado Exp $";
d952 1
a952 1
		    "Releases",
d992 1
a992 1
	PRWORD(ovflw, " %*lu", 9, 1, pp->pr_nput);
@


1.108
log
@minor improvement on the diff to r1.106

ok jsing@@
@
text
@d2 1
a2 1
/*	$OpenBSD: vmstat.c,v 1.107 2007/12/15 03:43:41 deraadt Exp $	*/
d43 1
a43 1
static const char rcsid[] = "$OpenBSD: vmstat.c,v 1.107 2007/12/15 03:43:41 deraadt Exp $";
d1148 1
a1148 1
	    "[-N system] [-w wait] [disks]\n", __progname);
@


1.107
log
@change over last few bits to use sysctl(3) if possible, and make this
not setgid kmem (hurray!)
ok tedu, tested jsg
@
text
@d2 1
a2 1
/*	$OpenBSD: vmstat.c,v 1.106 2007/10/26 14:15:25 sobrado Exp $	*/
d43 1
a43 1
static const char rcsid[] = "$OpenBSD: vmstat.c,v 1.106 2007/10/26 14:15:25 sobrado Exp $";
d445 1
a445 1
	(void)printf(" procs  memory         page%*s", 20, "");
@


1.106
log
@patch to improve vmstat(8) output:
  - the "fre" column width is increased
  - adds a whitespace between the "avm" and "fre" columns
  - aligns the "memory" and "traps" labels with their column sets

ok millert@@
@
text
@d2 1
a2 1
/*	$OpenBSD: vmstat.c,v 1.105 2007/09/13 22:30:51 cloder Exp $	*/
d43 1
a43 1
static const char rcsid[] = "$OpenBSD: vmstat.c,v 1.105 2007/09/13 22:30:51 cloder Exp $";
d95 1
a95 4
	{ "" },
};

struct nlist namelist2[] = {
a127 1
int	kreado(struct nlist *, void *, size_t);
a214 1
#if notyet
a215 1
#endif
a239 1
#ifdef notyet
a241 1
#endif /* notyet */
d1060 12
a1071 2
	if (!kreado(namelist2, &kmfp, sizeof(kmfp)))
		total += kmfp * (getpagesize() / 1024);
d1116 2
a1117 2
	if (!kreado(namelist2, &kmfp, sizeof(kmfp)))
		total += kmfp * (getpagesize() / 1024);
a1141 20
}

/*
 * kreado reads something from the kernel, given its nlist index.
 */
int
kreado(struct nlist *nl, void *addr, size_t size)
{
	int c;

	if ((c = kvm_nlist(kd, nl)) != 0)
		return (c);

	if (nl->n_type == 0 || nl->n_value == 0)
		return (-1);

	if (kvm_read(kd, nl->n_value, addr, size) != size)
		return (-1);

	return (0);
@


1.105
log
@Use a sig_atomic_t instead of an int when setting it from a signal handler
@
text
@d2 1
a2 1
/*	$OpenBSD: vmstat.c,v 1.104 2006/10/02 23:03:56 pedro Exp $	*/
d43 1
a43 1
static const char rcsid[] = "$OpenBSD: vmstat.c,v 1.104 2006/10/02 23:03:56 pedro Exp $";
d419 1
a419 1
		(void)printf("%7u%7u ",
d421 1
a421 1
		(void)printf("%5u ", rate(uvmexp.faults - ouvmexp.faults));
d453 1
a453 1
	(void)printf(" procs   memory        page%*s", 20, "");
d455 1
a455 1
		(void)printf("%s %*straps         cpu\n",
d457 1
a457 1
		   ((ndrives > 1) ? ndrives * 4 - 4 : 0), "");
d459 1
a459 1
		(void)printf("%*s  traps          cpu\n",
d462 1
a462 1
	(void)printf(" r b w    avm    fre   flt  re  pi  po  fr  sr ");
@


1.104
log
@Fix error messages, okay ray@@ deraadt@@
@
text
@d2 1
a2 1
/*	$OpenBSD: vmstat.c,v 1.103 2006/03/31 18:19:38 deraadt Exp $	*/
d43 1
a43 1
static const char rcsid[] = "$OpenBSD: vmstat.c,v 1.103 2006/03/31 18:19:38 deraadt Exp $";
d367 2
a368 1
int	hz, hdrcnt;
@


1.103
log
@spacing
@
text
@d2 1
a2 1
/*	$OpenBSD: vmstat.c,v 1.102 2006/03/31 04:06:13 deraadt Exp $	*/
d43 1
a43 1
static const char rcsid[] = "$OpenBSD: vmstat.c,v 1.102 2006/03/31 04:06:13 deraadt Exp $";
d190 1
a190 1
				err(1, "-w %s: %s\n", optarg, errstr);
d273 1
a273 1
			err(1, "-w %s: %s\n", optarg, errstr);
@


1.102
log
@lint-driven cleanup.  nothing too scary in this diff.
@
text
@d2 1
a2 1
/*	$OpenBSD: vmstat.c,v 1.101 2006/03/13 19:29:26 otto Exp $	*/
d43 1
a43 1
static const char rcsid[] = "$OpenBSD: vmstat.c,v 1.101 2006/03/13 19:29:26 otto Exp $";
d274 1
a274 1
		
d515 1
a515 1
	    	    pgintime / (uvmexp.pageins * 10.0));
d871 1
a871 1
			/* 
d1006 1
a1006 1
	PRWORD(ovflw, " %*lu\n", 5, 1, pp->pr_nidle);	
@


1.101
log
@delint; from David Hill
@
text
@d2 1
a2 1
/*	$OpenBSD: vmstat.c,v 1.100 2006/02/23 06:32:11 martin Exp $	*/
d43 1
a43 1
static const char rcsid[] = "$OpenBSD: vmstat.c,v 1.100 2006/02/23 06:32:11 martin Exp $";
d154 4
a157 1
	int mib[2];
a158 4
	int c, todo;
	u_int interval;
	int reps;
	char errbuf[_POSIX2_LINE_MAX];
a160 1
	interval = reps = todo = 0;
d188 3
a190 1
			interval = atoi(optarg);
d262 1
a262 1
		(void) ioctl(STDOUT_FILENO, TIOCGWINSZ, (char *)&winsize);
d271 4
a274 1
		interval = atoi(*argv);
d340 1
a341 1
	static struct timeval boottime;
d343 1
a344 1
	size_t size;
a371 1
	struct vmtotal total;
a372 1
	int mib[2];
d374 1
d376 1
d417 1
a417 1
#define pgtok(a) ((a) * ((int)uvmexp.pagesize >> 10))
d486 1
a487 1
	size_t size;
d521 1
a521 1
	long ans;
d535 1
a537 1
	int mib[2], nselcoll;
d697 1
a698 1
	double percent, total;
d715 3
a718 4
	u_int64_t inttotal;
	int nintr;
	char intrname[128];
	int mib[4];
a719 1
	int i;
d795 3
a797 4
	struct kmembuckets *kp;
	struct kmemstats *ks;
	int i, j;
	int len, size, first;
d799 1
a801 3
	struct kmemstats kmemstats[M_LAST];
	struct kmembuckets buckets[MINBUCKET + 16];
	int mib[4];
a802 1
	char buf[BUFSIZ], *bufp, *ap;
d948 1
a949 1
	char maxp[32];
d1024 1
a1027 2
	int mib[4];
	int npools, i, kmfp;
a1075 2
	long addr;
	long total = 0, inuse = 0;
d1078 2
d1083 1
a1083 1
	addr = (long)TAILQ_FIRST(&pool_head);
d1094 1
a1094 1
		if (kvm_read(kd, (long)pp->pr_wchan, name, sizeof name) < 0) {
d1108 1
a1108 1
		addr = (long)TAILQ_NEXT(pp, pr_poollist);
@


1.100
log
@remove unused variable
@
text
@d2 1
a2 1
/*	$OpenBSD: vmstat.c,v 1.99 2006/02/11 16:46:59 martin Exp $	*/
d43 1
a43 1
static const char rcsid[] = "$OpenBSD: vmstat.c,v 1.99 2006/02/11 16:46:59 martin Exp $";
d123 1
d135 2
a153 2
	extern int optind;
	extern char *optarg;
a370 1
	void needhdr(int);
d695 1
a695 1
	double pct, total;
d701 1
a701 1
		pct = 100 / total;
d703 4
a706 4
		pct = 0;
	(void)printf("%2.0f ", (cur.cp_time[CP_USER] + cur.cp_time[CP_NICE]) * pct);
	(void)printf("%2.0f ", (cur.cp_time[CP_SYS] + cur.cp_time[CP_INTR]) * pct);
	(void)printf("%2.0f", cur.cp_time[CP_IDLE] * pct);
d789 1
a789 1
char *kmemnames[] = INITKMEMNAMES;
d800 1
a800 1
	char *name;
@


1.99
log
@namelist must be NULL terminated, plus some cleanup after mickey

ok mickey@@
@
text
@d2 1
a2 1
/*	$OpenBSD: vmstat.c,v 1.98 2006/01/31 18:24:56 mickey Exp $	*/
d43 1
a43 1
static const char rcsid[] = "$OpenBSD: vmstat.c,v 1.98 2006/01/31 18:24:56 mickey Exp $";
a711 2
	struct device dev;

@


1.98
log
@include uvm_km_pages_free into the pool accounting as it is the main consumer of it; feedback from millert@@ and tedu@@ ok
@
text
@d2 1
a2 1
/*	$OpenBSD: vmstat.c,v 1.97 2005/09/28 00:54:05 pedro Exp $	*/
d43 1
a43 1
static const char rcsid[] = "$OpenBSD: vmstat.c,v 1.97 2005/09/28 00:54:05 pedro Exp $";
d95 1
d1148 1
a1148 1
 * kread reads something from the kernel, given its nlist index.
a1152 1
	char *sym;
@


1.97
log
@make -s print information about kmapent as well, reminded by deraadt@@
@
text
@d2 1
a2 1
/*	$OpenBSD: vmstat.c,v 1.96 2005/07/04 01:54:10 djm Exp $	*/
d43 1
a43 1
static const char rcsid[] = "$OpenBSD: vmstat.c,v 1.96 2005/07/04 01:54:10 djm Exp $";
d95 4
a98 1
#define X_END		8
d129 1
d1032 1
a1032 1
	int npools, i;
d1072 2
d1085 1
d1118 2
d1144 21
@


1.96
log
@make these use setres[ug]id for simple privilege dropping;
ok deraadt@@ millert@@ moritz@@
@
text
@d2 1
a2 1
/*	$OpenBSD: vmstat.c,v 1.95 2005/04/21 04:42:56 mickey Exp $	*/
d43 1
a43 1
static const char rcsid[] = "$OpenBSD: vmstat.c,v 1.95 2005/04/21 04:42:56 mickey Exp $";
d579 1
@


1.95
log
@print out fpu ctx switches count
@
text
@d2 1
a2 1
/*	$OpenBSD: vmstat.c,v 1.94 2004/12/24 22:38:22 miod Exp $	*/
d43 1
a43 1
static const char rcsid[] = "$OpenBSD: vmstat.c,v 1.94 2004/12/24 22:38:22 miod Exp $";
d154 1
d203 1
d205 2
a206 2
		setegid(getgid());
		setgid(getgid());
d220 4
a224 2
			setgid(getgid());
			setegid(getegid());
d241 2
a242 1
	}
a243 3

	setegid(getegid());
	setgid(getgid());
@


1.94
log
@In vmstat -i, stop walking the kernel "allevents" evcnt chain, as they are
not incremented anymore. Kernel-side code will be removed in a few weeks.
@
text
@d2 1
a2 1
/*	$OpenBSD: vmstat.c,v 1.93 2004/11/28 14:05:24 miod Exp $	*/
d43 1
a43 1
static const char rcsid[] = "$OpenBSD: vmstat.c,v 1.93 2004/11/28 14:05:24 miod Exp $";
d568 1
@


1.93
log
@Stop looking at intrcnt[] for vmstat -i; this means vmstat -i only works
on live kernels now, though.
ok deraadt@@
@
text
@d2 1
a2 1
/*	$OpenBSD: vmstat.c,v 1.92 2004/11/09 23:20:18 pedro Exp $	*/
d43 1
a43 1
static const char rcsid[] = "$OpenBSD: vmstat.c,v 1.92 2004/11/09 23:20:18 pedro Exp $";
d95 1
a95 3
#define X_ALLEVENTS	8		/* no sysctl */
	{ "_allevents" },
#define X_END		9		/* no sysctl */
a702 2
	struct evcntlist allevents;
	struct evcnt evcnt, *evptr;
a774 18
	kread(X_ALLEVENTS, &allevents, sizeof allevents);
	evptr = allevents.tqh_first;
	while (evptr) {
		if (kvm_read(kd, (long)evptr, (void *)&evcnt,
		    sizeof evcnt) != sizeof evcnt)
			errx(1, "event chain trashed: %s", kvm_geterr(kd));
		if (strcmp(evcnt.ev_name, "intr") == 0) {
			if (kvm_read(kd, (long)evcnt.ev_dev, (void *)&dev,
			    sizeof dev) != sizeof dev)
				errx(1, "event chain trashed: %s", kvm_geterr(kd));
			if (evcnt.ev_count)
				(void)printf("%-16.16s %20llu %8llu\n",
				    dev.dv_xname,
				    evcnt.ev_count, evcnt.ev_count / uptime);
			inttotal += evcnt.ev_count;
		}
		evptr = evcnt.ev_list.tqe_next;
	}
@


1.92
log
@use warn() instead of printf() + strerror()
ok hshoexer@@ jaredy@@ deraadt@@
@
text
@d2 1
a2 1
/*	$OpenBSD: vmstat.c,v 1.91 2004/09/23 22:55:06 deraadt Exp $	*/
d43 1
a43 1
static const char rcsid[] = "$OpenBSD: vmstat.c,v 1.91 2004/09/23 22:55:06 deraadt Exp $";
d97 1
a97 9
#define	X_INTRNAMES	9		/* no sysctl */
	{ "_intrnames" },
#define	X_EINTRNAMES	10		/* no sysctl */
	{ "_eintrnames" },
#define	X_INTRCNT	11		/* no sysctl */
	{ "_intrcnt" },
#define	X_EINTRCNT	12		/* no sysctl */
	{ "_eintrcnt" },
#define X_END		13		/* no sysctl */
a701 3
static void dointr_sysctl(void);
static void dointr_kvm(void);

a704 9
	if (nlistf == NULL && memf == NULL)
		dointr_sysctl();
	else
		dointr_kvm();
}

static void
dointr_sysctl(void)
{
d717 5
a791 53
				    evcnt.ev_count, evcnt.ev_count / uptime);
			inttotal += evcnt.ev_count;
		}
		evptr = evcnt.ev_list.tqe_next;
	}
	(void)printf("%-16s %20llu %8llu\n", "Total", inttotal,
	    inttotal / uptime);
}

static void
dointr_kvm(void)
{
	long *intrcnt;
	u_int64_t inttotal;
	time_t uptime;
	int nintr, inamlen;
	char *intrname;
	struct evcntlist allevents;
	struct evcnt evcnt, *evptr;
	struct device dev;

	uptime = getuptime();
	nintr = namelist[X_EINTRCNT].n_value - namelist[X_INTRCNT].n_value;
	inamlen =
	    namelist[X_EINTRNAMES].n_value - namelist[X_INTRNAMES].n_value;
	intrcnt = malloc((size_t)nintr);
	intrname = malloc((size_t)inamlen);
	if (intrcnt == NULL || intrname == NULL)
		err(1, "malloc");
	kread(X_INTRCNT, intrcnt, (size_t)nintr);
	kread(X_INTRNAMES, intrname, (size_t)inamlen);
	(void)printf("%-16s %20s %8s\n", "interrupt", "total", "rate");
	inttotal = 0;
	nintr /= sizeof(long);
	while (--nintr >= 0) {
		if (*intrcnt)
			(void)printf("%-16.16s %20lu %8lu\n", intrname,
			    *intrcnt, *intrcnt / uptime);
		intrname += strlen(intrname) + 1;
		inttotal += *intrcnt++;
	}
	kread(X_ALLEVENTS, &allevents, sizeof allevents);
	evptr = allevents.tqh_first;
	while (evptr) {
		if (kvm_read(kd, (long)evptr, (void *)&evcnt,
		    sizeof evcnt) != sizeof evcnt)
			errx(1, "event chain trashed: %s", kvm_geterr(kd));
		if (strcmp(evcnt.ev_name, "intr") == 0) {
			if (kvm_read(kd, (long)evcnt.ev_dev, (void *)&dev,
			    sizeof dev) != sizeof dev)
				errx(1, "event chain trashed: %s", kvm_geterr(kd));
			if (evcnt.ev_count)
				(void)printf("%-16.16s %20lu %8lu\n", dev.dv_xname,
@


1.91
log
@do not shrink the field width...
@
text
@d2 1
a2 1
/*	$OpenBSD: vmstat.c,v 1.90 2004/09/23 21:09:39 deraadt Exp $	*/
d43 1
a43 1
static const char rcsid[] = "$OpenBSD: vmstat.c,v 1.90 2004/09/23 21:09:39 deraadt Exp $";
d1121 1
a1121 2
		printf("Can't figure out number of pools in kernel: %s\n",
			strerror(errno));
d1136 1
a1136 1
			printf("error getting pool: %s\n", strerror(errno));
d1143 1
a1143 2
			printf("error getting pool name: %s\n",
				strerror(errno));
@


1.90
log
@adapt to KERN_INTRCNT_CNT becoming a quad; ok tedu, and pulling in some
changes written by danh
@
text
@d2 1
a2 1
/*	$OpenBSD: vmstat.c,v 1.89 2004/07/02 09:12:37 miod Exp $	*/
d43 1
a43 1
static const char rcsid[] = "$OpenBSD: vmstat.c,v 1.89 2004/07/02 09:12:37 miod Exp $";
d748 1
a748 1
	(void)printf("%-12s %20s %8s\n", "interrupt", "total", "rate");
d789 1
a789 1
			(void)printf("%-12.12s %20llu %8llu\n", intrname,
d805 1
a805 1
				(void)printf("%-12.12s %20llu %8llu\n",
d812 1
a812 1
	(void)printf("%-12s %20llu %8llu\n", "Total", inttotal,
d838 1
a838 1
	(void)printf("%-12s %20s %8s\n", "interrupt", "total", "rate");
d843 1
a843 1
			(void)printf("%-12.12s %20lu %8lu\n", intrname,
d859 1
a859 1
				(void)printf("%-12.12s %20lu %8lu\n", dev.dv_xname,
d865 1
a865 1
	(void)printf("%-12s %20llu %8llu\n", "Total", inttotal,
@


1.89
log
@Do not divide by zero in vmstat -t; Nikos Ntarmos.
@
text
@d2 1
a2 1
/*	$OpenBSD: vmstat.c,v 1.88 2004/06/28 21:49:35 jmc Exp $	*/
d43 1
a43 1
static const char rcsid[] = "$OpenBSD: vmstat.c,v 1.88 2004/06/28 21:49:35 jmc Exp $";
d474 1
d730 1
a730 1
	long inttotal;
d748 1
a748 1
	(void)printf("interrupt               total     rate\n");
d753 1
a753 1
		int cnt;
d785 1
a785 1
			return ;
d787 1
d789 2
a790 2
			(void)printf("%-16.16s %12d %8ld\n", intrname,
			    cnt, (long)cnt / uptime);
d805 4
a808 3
				(void)printf("%-14s %12d %8ld\n", dev.dv_xname,
				    evcnt.ev_count, (long)(evcnt.ev_count / uptime));
			inttotal += evcnt.ev_count++;
d812 2
a813 1
	(void)printf("Total            %12ld %8ld\n", inttotal, inttotal / uptime);
d819 2
a820 1
	long *intrcnt, inttotal;
d838 1
a838 1
	(void)printf("interrupt             total     rate\n");
d843 1
a843 1
			(void)printf("%-14s %12ld %8ld\n", intrname,
d859 3
a861 3
				(void)printf("%-14s %12d %8ld\n", dev.dv_xname,
				    evcnt.ev_count, (long)(evcnt.ev_count / uptime));
			inttotal += evcnt.ev_count++;
d865 2
a866 1
	(void)printf("Total          %12ld %8ld\n", inttotal, inttotal / uptime);
@


1.88
log
@add -vz to usage();
@
text
@d2 1
a2 1
/*	$OpenBSD: vmstat.c,v 1.87 2004/06/28 01:45:51 aaron Exp $	*/
d43 1
a43 1
static const char rcsid[] = "$OpenBSD: vmstat.c,v 1.87 2004/06/28 01:45:51 aaron Exp $";
d506 3
a508 1
	(void)printf("average: %u usec / reclaim\n", rectime / uvmexp.pdreact);
d512 3
a514 2
	(void)printf("average: %8.1f msec / page in\n",
	    pgintime / (uvmexp.pageins * 10.0));
@


1.87
log
@Remove special #if defined(__i386__) code from systat and vmstat.  We now use
sysctl to fetch interrupt counters on all architectures.  Also add new '-z'
flag to vmstat which means show all devices, even those that have not yet
generated an interrupt.  deraadt@@ tholo@@ drahn@@ millert@@ ok
@
text
@d2 1
a2 1
/*	$OpenBSD: vmstat.c,v 1.86 2004/06/14 00:39:33 deraadt Exp $	*/
d43 1
a43 1
static const char rcsid[] = "$OpenBSD: vmstat.c,v 1.86 2004/06/14 00:39:33 deraadt Exp $";
d1219 1
a1219 1
	(void)fprintf(stderr, "usage: %s [-fimst] [-c count] [-M core] "
@


1.86
log
@remove debug message
@
text
@d2 1
a2 1
/*	$OpenBSD: vmstat.c,v 1.85 2004/06/14 00:38:02 deraadt Exp $	*/
d43 1
a43 1
static const char rcsid[] = "$OpenBSD: vmstat.c,v 1.85 2004/06/14 00:38:02 deraadt Exp $";
a105 8
#if defined(__i386__)
#define	X_INTRHAND	(X_END)		/* no sysctl */
	{ "_intrhand" },
#define	X_APICINTRHAND	(X_END+1)		/* no sysctl */
	{ "_apic_intrhand" },
#define	X_INTRSTRAY	(X_END+2)	/* no sysctl */
	{ "_intrstray" },
#endif
d149 1
d166 1
a166 1
	while ((c = getopt(argc, argv, "c:fiM:mN:stw:v")) != -1) {
d198 3
a231 5
#ifdef __i386__
			if (c == 1 && namelist[X_APICINTRHAND].n_value == 0)
				;
			else
#endif
a705 77
#if defined(__i386__)
/* To get struct intrhand */
#define _KERNEL
#include <machine/psl.h>
#include <machine/cpu.h>
#undef _KERNEL
void
dointr(void)
{
	struct intrhand *intrhand[16], *ihp, ih;
	struct intrhand *apicintrhand[256];
	u_long inttotal = 0;
	time_t uptime;
	u_long intrstray[16];
	char iname[17], fname[31];
	int i;

	iname[16] = '\0';
	uptime = getuptime();

	(void)printf("interrupt             total     rate\n");

	kread(X_INTRHAND, intrhand, sizeof(intrhand));
	kread(X_INTRSTRAY, intrstray, sizeof(intrstray));

	for (i = 0; i < 16; i++) {
		ihp = intrhand[i];
		while (ihp) {
			if (kvm_read(kd, (u_long)ihp, &ih,
			    sizeof(ih)) != sizeof(ih))
				errx(1, "vmstat: ih: %s",
				    kvm_geterr(kd));
			if (kvm_read(kd, (u_long)ih.ih_what, iname,
			    16) != 16)
				errx(1, "vmstat: ih_what: %s",
				    kvm_geterr(kd));
			snprintf(fname, sizeof fname, "irq%d/%s", i,
			    iname);
			printf("%-16.16s %10lu %8lu\n", fname,
			    ih.ih_count, ih.ih_count / uptime);
			inttotal += ih.ih_count;
			ihp = ih.ih_next;
		}
	}
	if (namelist[X_APICINTRHAND].n_value) {
		kread(X_APICINTRHAND, apicintrhand, sizeof(apicintrhand));

		for (i = 0; i < 256; i++) {
			ihp = apicintrhand[i];
			while (ihp) {
				if (kvm_read(kd, (u_long)ihp, &ih,
				    sizeof(ih)) != sizeof(ih))
					errx(1, "vmstat: ih: %s",
					    kvm_geterr(kd));
				if (kvm_read(kd, (u_long)ih.ih_what, iname,
				    16) != 16)
					errx(1, "vmstat: ih_what: %s",
					    kvm_geterr(kd));
				snprintf(fname, sizeof fname, "irq%d/%s", i,
				    iname);
				printf("%-16.16s %10lu %8lu\n", fname,
				    ih.ih_count, ih.ih_count / uptime);
				inttotal += ih.ih_count;
				ihp = ih.ih_next;
			}
		}
	}

	for (i = 0; i < 16; i++)
		if (intrstray[i]) {
			printf("Stray irq %-2d     %10lu %8lu\n",
			    i, intrstray[i], intrstray[i] / uptime);
			inttotal += intrstray[i];
		}
	printf("Total            %10lu %8lu\n", inttotal, inttotal / uptime);
}
#else
d744 2
d748 1
d750 1
d756 2
a757 2
		siz = sizeof(intrname);
		if (sysctl(mib, 4, intrname, &siz, NULL, 0) < 0) {
d759 13
a771 1
			return ;
d783 2
a784 2
		if (cnt)
			(void)printf("%-14s %12d %8ld\n", intrname,
d806 1
a806 1
	(void)printf("Total          %12ld %8ld\n", inttotal, inttotal / uptime);
a858 1
#endif
@


1.85
log
@let vmstat -i still work on older kernels; spotted by tholo
@
text
@d2 1
a2 1
/*	$OpenBSD: vmstat.c,v 1.84 2004/06/11 16:09:08 deraadt Exp $	*/
d43 1
a43 1
static const char rcsid[] = "$OpenBSD: vmstat.c,v 1.84 2004/06/11 16:09:08 deraadt Exp $";
d238 1
a238 1
				printf("huh\n");
@


1.84
log
@div etime by ncpu
@
text
@d2 1
a2 1
/*	$OpenBSD: vmstat.c,v 1.83 2004/06/11 05:54:55 deraadt Exp $	*/
d43 1
a43 1
static const char rcsid[] = "$OpenBSD: vmstat.c,v 1.83 2004/06/11 05:54:55 deraadt Exp $";
d236 5
d737 20
a756 22
	{
		kread(X_INTRHAND, intrhand, sizeof(intrhand));
		kread(X_INTRSTRAY, intrstray, sizeof(intrstray));

		for (i = 0; i < 16; i++) {
			ihp = intrhand[i];
			while (ihp) {
				if (kvm_read(kd, (u_long)ihp, &ih,
				    sizeof(ih)) != sizeof(ih))
					errx(1, "vmstat: ih: %s",
					    kvm_geterr(kd));
				if (kvm_read(kd, (u_long)ih.ih_what, iname,
				    16) != 16)
					errx(1, "vmstat: ih_what: %s",
					    kvm_geterr(kd));
				snprintf(fname, sizeof fname, "irq%d/%s", i,
				    iname);
				printf("%-16.16s %10lu %8lu\n", fname,
				    ih.ih_count, ih.ih_count / uptime);
				inttotal += ih.ih_count;
				ihp = ih.ih_next;
			}
d759 1
a759 1
	{
@


1.83
log
@on i386 machines, attempt to peek inside apic_intrhand[] as well, so that
MP machines get interrupt counters.  will be replaced by a MI subsystem
one day.  most code from drahn, few final bugs fixed by me
@
text
@d2 1
a2 1
/*	$OpenBSD: vmstat.c,v 1.82 2004/02/15 02:45:47 tedu Exp $	*/
d43 1
a43 1
static const char rcsid[] = "$OpenBSD: vmstat.c,v 1.82 2004/02/15 02:45:47 tedu Exp $";
d158 2
d165 2
d257 5
d683 1
@


1.82
log
@new arg to disk_unbusy, to record separate read/write statistics.
looked at by various, testing henning@@ mcbride@@ dan weeks
mostly from netbsd via Pedro Martelletto <pbastos@@rdc.puc-rio.br>
@
text
@d2 1
a2 1
/*	$OpenBSD: vmstat.c,v 1.81 2004/01/15 20:39:33 otto Exp $	*/
d43 1
a43 1
static const char rcsid[] = "$OpenBSD: vmstat.c,v 1.81 2004/01/15 20:39:33 otto Exp $";
d109 3
a111 1
#define	X_INTRSTRAY	(X_END+1)	/* no sysctl */
d710 1
d730 1
a730 1
					     sizeof(ih)) != sizeof(ih))
d732 1
a732 1
					     kvm_geterr(kd));
d734 1
a734 1
					     16) != 16)
d736 1
a736 1
					     kvm_geterr(kd));
d738 1
a738 1
					 iname);
d740 24
a763 1
				       ih.ih_count, ih.ih_count / uptime);
@


1.81
log
@Fix printf format string. ok tedu@@
@
text
@d2 1
a2 1
/*	$OpenBSD: vmstat.c,v 1.80 2003/07/28 06:16:35 tedu Exp $	*/
d43 1
a43 1
static const char rcsid[] = "$OpenBSD: vmstat.c,v 1.80 2003/07/28 06:16:35 tedu Exp $";
d675 2
a676 1
		(void)printf("%3.0f ", cur.dk_xfer[dn] / etime);
@


1.80
log
@fix rcsid
@
text
@d2 1
a2 1
/*	$OpenBSD: vmstat.c,v 1.79 2003/07/25 21:25:29 tedu Exp $	*/
d43 1
a43 1
static const char rcsid[] = "$OpenBSD$";
d814 2
a815 2
			(void)printf("%-14s %12ld %8ld\n", intrname,
			    cnt, cnt / uptime);
@


1.79
log
@context switches and interrupts are traps, not faults.  align cpu field a
little better.  some man page pretty from jmc@@ and ok millert@@
@
text
@d2 1
a2 1
/*	$OpenBSD: vmstat.c,v 1.78 2003/06/25 21:18:08 deraadt Exp $	*/
d43 1
a43 1
static char rcsid[] = "$NetBSD: vmstat.c,v 1.29.4.1 1996/06/05 00:21:05 cgd Exp $";
@


1.78
log
@protos
@
text
@d2 1
a2 1
/*	$OpenBSD: vmstat.c,v 1.77 2003/06/03 02:56:22 millert Exp $	*/
d447 1
a447 1
		(void)printf("%s %*sfaults     cpu\n",
d451 1
a451 1
		(void)printf("%*s  faults     cpu\n",
d460 1
a460 1
	(void)printf("  in    sy   cs us sy id\n");
@


1.77
log
@Remove the advertising clause in the UCB license which Berkeley
rescinded 22 July 1999.  Proofed by myself and Theo.
@
text
@d2 1
a2 1
/*	$OpenBSD: vmstat.c,v 1.76 2003/05/19 05:17:21 art Exp $	*/
d366 1
a366 1
	void needhdr();
d468 1
a468 1
needhdr(void)
@


1.76
log
@kill dead (if 0) code.
@
text
@d2 1
a2 1
/*	$OpenBSD: vmstat.c,v 1.75 2003/02/24 00:28:37 grange Exp $	*/
d16 1
a16 5
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
@


1.75
log
@Fix copy/paste typo
art@@ ok
@
text
@d2 1
a2 1
/*	$OpenBSD: vmstat.c,v 1.74 2003/01/13 06:06:13 art Exp $	*/
a715 5
#if 0
	int mib[2], l, incflag;
	size_t size;
	char *intrnames, *intrcount, *intrn, *intrc, *buf1, *buf2;
#endif
a721 72
#if 0  /* XXX Something else is needed here....get on with it Theo! */
	if (nlistf == NULL && memf == NULL) {
	 	mib[0] = CTL_MACHDEP;
		mib[1] = CPU_INTRNAMES;
		size = 0;
		if (sysctl(mib, 2, NULL, &size, NULL, 0) < 0)
			err(1, "could not get machdep.intrnames");
		intrnames = calloc(size, sizeof(char));
		if (intrnames == NULL)
			err(1,
			    "could not allocate memory for interrupt names");
		if (sysctl(mib, 2, intrnames, &size, NULL, 0) < 0)
			err(1, "could not get machdep.intrnames");

		mib[1] = CPU_INTRCOUNT;
		size = 0;
		if (sysctl(mib, 2, NULL, &size, NULL, 0) < 0)
			err(1, "could not get machdep.intrcount");
		intrcount = calloc(size, sizeof(char));
		if (intrcount == NULL)
			err(1,
			    "could not allocate memory for interrupt count");
		if (sysctl(mib, 2, intrcount, &size, NULL, 0) < 0)
			err(1, "could not get machdep.intrcount");

		mib[1] = CPU_INTRSTRAY;
		size = sizeof(intrstray);
		if (sysctl(mib, 2, intrstray, &size, NULL, 0) < 0) {
			warn("could not get machdep.intrstray");
			bzero(intrstray, sizeof(intrstray));
		}

		buf1 = intrnames;
		buf2 = intrcount;
		i = 0;
		while ((intrn = strsep(&buf1, ",/")) != NULL) {
			/* Find what the next delimiter is */
			for (l = 0; buf2[l] != '\0'; l++) {
				if (buf2[l] == '/') {
					/* Don't increase the irq count */
					incflag = 0;
					break;
				} else if (buf2[l] == ',') {
					incflag = 1;
					break;
				}
			}

			if ((intrc = strsep(&buf2, ",/")) == NULL)
				errx(1, "unexpected failure matching interrupts with usage counters");

			/* Unused interrupt ? If so, skip this entry */
			if (intrn[0] == '\0')	{
				if (incflag)
					i++;
				continue;
			}

			snprintf(fname, sizeof fname, "irq%d/%s", i, intrn);
			printf("%-16.16s %10lu %8lu\n", fname,
			       strtoul(intrc, NULL, 10),
			       strtoul(intrc, NULL, 10) / uptime);
			inttotal += strtoul(intrc, NULL, 10);

			if (incflag)
				i++;
		}

		free(intrnames);
		free(intrcount);
	} else
#endif /* 0 */
@


1.74
log
@Half-done conversion of vmstat -i to sysctls.
The evcnt stuff is left just like in the kvm version.
@
text
@d2 1
a2 1
/*	$OpenBSD: vmstat.c,v 1.73 2002/12/16 01:57:04 tdeval Exp $	*/
d891 1
a891 1
			warnx("could not read kern.intrcnt.name.%d", i);
@


1.73
log
@Make systat(1), iostat(8) and vmstat(8) automatically update their disk
statistics when a device is added/removed.  ok deraadt@@
@
text
@d2 1
a2 1
/*	$OpenBSD: vmstat.c,v 1.72 2002/09/17 19:37:40 deraadt Exp $	*/
d833 3
d838 84
@


1.72
log
@ansi
@
text
@d2 1
a2 1
/*	$OpenBSD: vmstat.c,v 1.71 2002/09/05 04:05:53 art Exp $	*/
d120 1
a120 1
extern struct _disk	cur;
a388 2
		if (!--hdrcnt)
			printhdr();
d391 2
@


1.71
log
@Print uvmexp.zeropages.
@
text
@d2 1
a2 1
/*	$OpenBSD: vmstat.c,v 1.70 2002/06/19 08:45:52 deraadt Exp $	*/
d161 1
a161 3
main(argc, argv)
	int argc;
	char **argv;
d300 1
a300 2
choosedrives(argv)
	char **argv;
d334 1
a334 1
getuptime()
d366 1
a366 3
dovmstat(interval, reps)
	u_int interval;
	int reps;
d445 1
a445 1
printhdr()
d472 1
a472 1
needhdr()
d479 1
a479 1
dotimes()
d512 1
a512 2
pct(top, bot)
	long top, bot;
d525 1
a525 1
dosum()
d630 1
a630 1
doforkst()
d651 2
a652 1
	    fks.cntvfork, fks.sizvfork, (double)fks.sizvfork / (fks.cntvfork ? fks.cntvfork : 1));
d654 2
a655 1
	    fks.cntrfork, fks.sizrfork, (double)fks.sizrfork / (fks.cntrfork ? fks.cntrfork : 1));
d657 2
a658 1
	    fks.cntkthread, fks.sizkthread, (double)fks.sizkthread / (fks.cntkthread ? fks.cntkthread : 1));
d662 1
a662 1
dkstats()
d684 1
a684 1
cpustats()
d708 1
a708 1
dointr()
d834 1
a834 1
dointr()
d891 1
a891 1
domem()
d1223 1
a1223 4
kread(nlx, addr, size)
	int nlx;
	void *addr;
	size_t size;
d1242 1
a1242 1
usage()
@


1.70
log
@mark which nlist[] kmem entries are not needed in the sysctl case, and which are
@
text
@d2 1
a2 1
/*	$OpenBSD: vmstat.c,v 1.69 2002/05/29 09:23:25 deraadt Exp $	*/
d560 1
@


1.69
log
@more snprintf
@
text
@d2 1
a2 1
/*	$OpenBSD: vmstat.c,v 1.68 2002/03/15 19:11:01 art Exp $	*/
d83 1
a83 1
#define X_UVMEXP	0
d85 1
a85 1
#define	X_BOOTTIME	1
d87 1
a87 1
#define X_NCHSTATS	2
d89 13
a101 1
#define	X_INTRNAMES	3
d103 1
a103 1
#define	X_EINTRNAMES	4
d105 1
a105 1
#define	X_INTRCNT	5
d107 1
a107 1
#define	X_EINTRCNT	6
d109 1
a109 13
#define	X_KMEMSTAT	7
	{ "_kmemstats" },
#define	X_KMEMBUCKETS	8
	{ "_bucket" },
#define X_ALLEVENTS	9
	{ "_allevents" },
#define	X_FORKSTAT	10
	{ "_forkstat" },
#define X_POOLHEAD	11
	{ "_pool_head" },
#define X_NSELCOLL	12
	{ "_nselcoll" },
#define X_END		13
d111 1
a111 1
#define	X_INTRHAND	(X_END)
d113 1
a113 1
#define	X_INTRSTRAY	(X_END+1)
@


1.68
log
@No more need to define __POOL_EXPOSE
@
text
@d2 1
a2 1
/*	$OpenBSD: vmstat.c,v 1.67 2002/03/12 00:59:48 ho Exp $	*/
d1079 1
a1079 1
		sprintf(maxp, "inf");
d1081 1
a1081 1
		sprintf(maxp, "%u", pp->pr_maxpages);
@


1.67
log
@This makes things line up better. millert@@ concurs.
@
text
@d2 1
a2 1
/*	$OpenBSD: vmstat.c,v 1.66 2002/02/16 21:27:58 millert Exp $	*/
a49 2

#define __POOL_EXPOSE
@


1.66
log
@Part one of userland __P removal.  Done with a simple regexp with some minor hand editing to make comments line up correctly.  Another pass is forthcoming that handles the cases that could not be done automatically.
@
text
@d2 1
a2 1
/*	$OpenBSD: vmstat.c,v 1.65 2002/02/01 14:31:19 art Exp $	*/
d456 1
a456 1
	(void)printf(" procs   memory       page%*s", 20, "");
d458 1
a458 1
		(void)printf("%s %*sfaults      cpu\n",
d462 1
a462 1
		(void)printf("%*s  faults      cpu\n",
d468 1
a468 1
			(void)printf("%c%c%c", dr_name[i][0],
d471 1
a471 1
	(void)printf("   in    sy   cs us sy id\n");
@


1.65
log
@Add a verbose flag. Print unused memory types when verbose.
Don't print unused pools when not verbose.
@
text
@d2 1
a2 1
/*	$OpenBSD: vmstat.c,v 1.64 2002/01/21 17:30:38 deraadt Exp $	*/
d140 12
a151 12
void	cpustats __P((void));
void	dkstats __P((void));
void	dointr __P((void));
void	domem __P((void));
void	dopool __P((void));
void	dosum __P((void));
void	dovmstat __P((u_int, int));
void	kread __P((int, void *, size_t));
void	usage __P((void));
void	dotimes __P((void));
void	doforkst __P((void));
void	printhdr __P((void));
d153 1
a153 1
char	**choosedrives __P((char **));
@


1.64
log
@s/deamon/daemon/
@
text
@d2 1
a2 1
/*	$OpenBSD: vmstat.c,v 1.63 2002/01/15 22:40:38 art Exp $	*/
d160 2
d175 1
a175 1
	while ((c = getopt(argc, argv, "c:fiM:mN:stw:")) != -1) {
d204 3
d940 1
a940 1
		if (kp->kb_calls == 0)
d1075 5
@


1.63
log
@Make vmstat -m output the same for both sysctl and kvm versions.
Plus a minor simplification in preparation for a future change.
@
text
@d2 1
a2 1
/*	$OpenBSD: vmstat.c,v 1.62 2001/11/19 19:02:17 mpech Exp $	*/
d324 1
a324 1
	for (i = 0; i < dk_ndrive && ndrives < 4; i++) {
d419 1
a419 1
		(void)printf("%4u ", rate(uvmexp.faults - ouvmexp.faults));
d426 1
a426 1
		(void)printf("%4u %4u %3u ",
d453 1
a453 1
		(void)printf("%s %*sfaults   cpu\n",
d455 1
a455 1
		   ((ndrives > 1) ? ndrives * 3 - 4 : 0), "");
d457 1
a457 1
		(void)printf("%*s  faults   cpu\n",
d460 1
a460 1
	(void)printf(" r b w    avm    fre  flt  re  pi  po  fr  sr ");
d463 2
a464 1
			(void)printf("%c%c ", dr_name[i][0],
d466 1
a466 1
	(void)printf("  in   sy  cs us sy id\n");
d583 1
a583 1
	(void)printf("%11u number of times the pagedeamon woke up\n",
d678 1
a678 1
		(void)printf("%2.0f ", cur.dk_xfer[dn] / etime);
@


1.62
log
@kill more registers

millert@@ ok
@
text
@d2 1
a2 1
/*	$OpenBSD: vmstat.c,v 1.61 2001/11/06 19:20:15 art Exp $	*/
d1119 1
d1158 3
d1162 5
d1201 1
a1201 1
		total += pp->pr_npages * pp->pr_pagesz;
@


1.61
log
@New vm includes.
@
text
@d2 1
a2 1
/*	$OpenBSD: vmstat.c,v 1.60 2001/09/16 01:27:55 art Exp $	*/
d162 2
a163 2
	register int argc;
	register char **argv;
d167 1
a167 1
	register int c, todo;
d302 1
a302 1
	register int i;
d449 1
a449 1
	register int i;
d662 1
a662 1
	register int dn, state;
d684 1
a684 1
	register int state;
d834 1
a834 1
	register long *intrcnt, inttotal;
d836 2
a837 2
	register int nintr, inamlen;
	register char *intrname;
d891 3
a893 3
	register struct kmembuckets *kp;
	register struct kmemstats *ks;
	register int i, j;
@


1.60
log
@%llu instead of %qu and explicit casts.
@
text
@d2 1
a2 1
/*	$OpenBSD: vmstat.c,v 1.59 2001/08/12 12:03:03 heko Exp $	*/
a65 1
#include <vm/vm.h>
@


1.59
log
@#(endif|else) foo is incorrect, make it #endif /* foo */
deraadt@@ ok
@
text
@d2 1
a2 1
/*	$OpenBSD: vmstat.c,v 1.58 2001/07/28 05:36:18 pvalchev Exp $	*/
d944 6
a949 4
		(void)printf("%8d %8qu %6qu %18qu %7qu %10qu\n", size,
			kp->kb_total - kp->kb_totalfree,
			kp->kb_totalfree, kp->kb_calls,
			kp->kb_highwat, kp->kb_couldfree);
@


1.58
log
@Wall cleanup
@
text
@d2 1
a2 1
/*	$OpenBSD: vmstat.c,v 1.57 2001/06/27 06:16:50 art Exp $	*/
d250 1
a250 1
#endif notyet
@


1.57
log
@UVM is no longer an option
@
text
@d2 1
a2 1
/*	$OpenBSD: vmstat.c,v 1.56 2001/06/24 20:30:52 angelos Exp $	*/
d714 3
a716 1
	int i, mib[2], l, incflag;
d719 1
@


1.56
log
@Fix logic, add some more sysctl stuff. The only reason vmstat is still
setgid is because of the -i information (Theo needs to fix that for
all archs).
@
text
@d2 1
a2 1
/*	$OpenBSD: vmstat.c,v 1.55 2001/06/24 16:05:33 art Exp $	*/
a81 1
#ifdef UVM
a83 1
#endif
a85 1
#if defined(UVM)
a87 4
#else
#define X_SUM		0
	{ "_cnt" },
#endif
a126 1
#ifdef UVM
a127 3
#else
struct	vmmeter sum, osum;
#endif
a395 1
#ifdef UVM
a406 3
#else
		kread(X_SUM, &sum, sizeof(sum));
#endif
a416 1
#ifdef UVM
a417 3
#else
#define pgtok(a) ((a) * ((int)sum.v_page_size >> 10))
#endif
a419 1
#ifdef UVM
a430 14
#else
		(void)printf("%4u ", rate(sum.v_faults - osum.v_faults));
		(void)printf("%3u ",
		    rate(sum.v_reactivated - osum.v_reactivated));
		(void)printf("%3u ", rate(sum.v_pageins - osum.v_pageins));
		(void)printf("%3u %3u ",
		    rate(sum.v_pageouts - osum.v_pageouts), 0);
		(void)printf("%3u ", rate(sum.v_scan - osum.v_scan));
		dkstats();
		(void)printf("%4u %4u %3u ",
		    rate(sum.v_intr - osum.v_intr),
		    rate(sum.v_syscall - osum.v_syscall),
		    rate(sum.v_swtch - osum.v_swtch));
#endif
a435 1
#ifdef UVM
a436 3
#else
		osum = sum;
#endif
a490 1
#ifdef UVM
a510 11
#else
	kread(X_SUM, &sum, sizeof(sum));
	(void)printf("%u reactivates, %u total time (usec)\n",
	    sum.v_reactivated, rectime);
	(void)printf("average: %u usec / reclaim\n", rectime / sum.v_reactivated);
	(void)printf("\n");
	(void)printf("%u page ins, %u total time (msec)\n",
	    sum.v_pageins, pgintime / 10);
	(void)printf("average: %8.1f msec / page in\n",
	    pgintime / (sum.v_pageins * 10.0));
#endif
a534 1
#ifdef UVM
a589 34
#else
	kread(X_SUM, &sum, sizeof(sum));
	(void)printf("%11u cpu context switches\n", sum.v_swtch);
	(void)printf("%11u device interrupts\n", sum.v_intr);
	(void)printf("%11u software interrupts\n", sum.v_soft);
	(void)printf("%11u traps\n", sum.v_trap);
	(void)printf("%11u system calls\n", sum.v_syscall);
	(void)printf("%11u total faults taken\n", sum.v_faults);
	(void)printf("%11u swap ins\n", sum.v_swpin);
	(void)printf("%11u swap outs\n", sum.v_swpout);
	(void)printf("%11u pages swapped in\n", sum.v_pswpin);
	(void)printf("%11u pages swapped out\n", sum.v_pswpout);
	(void)printf("%11u page ins\n", sum.v_pageins);
	(void)printf("%11u page outs\n", sum.v_pageouts);
	(void)printf("%11u pages paged in\n", sum.v_pgpgin);
	(void)printf("%11u pages paged out\n", sum.v_pgpgout);
	(void)printf("%11u pages reactivated\n", sum.v_reactivated);
	(void)printf("%11u intransit blocking page faults\n", sum.v_intrans);
	(void)printf("%11u zero fill pages created\n", sum.v_nzfod);
	(void)printf("%11u zero fill page faults\n", sum.v_zfod);
	(void)printf("%11u pages examined by the clock daemon\n", sum.v_scan);
	(void)printf("%11u revolutions of the clock hand\n", sum.v_rev);
	(void)printf("%11u VM object cache lookups\n", sum.v_lookups);
	(void)printf("%11u VM object hits\n", sum.v_hits);
	(void)printf("%11u total VM faults taken\n", sum.v_vm_faults);
	(void)printf("%11u copy-on-write faults\n", sum.v_cow_faults);
	(void)printf("%11u pages freed by daemon\n", sum.v_dfree);
	(void)printf("%11u pages freed by exiting processes\n", sum.v_pfree);
	(void)printf("%11u pages free\n", sum.v_free_count);
	(void)printf("%11u pages wired down\n", sum.v_wire_count);
	(void)printf("%11u pages active\n", sum.v_active_count);
	(void)printf("%11u pages inactive\n", sum.v_inactive_count);
	(void)printf("%11u bytes per page\n", sum.v_page_size);
#endif
@


1.55
log
@Use sysctl for pool data.
@
text
@d2 1
a2 1
/*	$OpenBSD: vmstat.c,v 1.54 2001/06/23 21:59:44 art Exp $	*/
d83 1
a183 1
	memf = nlistf = NULL;
d225 5
d234 1
d236 24
a259 2
		setegid(getgid());
		setgid(getgid());
d261 1
d263 2
a264 22
	kd = kvm_openfiles(nlistf, memf, NULL, O_RDONLY, errbuf);
	if (kd == 0)
		errx(1, "kvm_openfiles: %s", errbuf);

	if ((c = kvm_nlist(kd, namelist)) != 0) {

		setegid(getgid());
		setgid(getgid());

		if (c > 0) {
			(void)fprintf(stderr,
			    "%s: undefined symbols:", __progname);
			for (c = 0;
			    c < sizeof(namelist)/sizeof(namelist[0]); c++)
				if (namelist[c].n_type == 0)
					fprintf(stderr, " %s",
					    namelist[c].n_name);
			(void)fputc('\n', stderr);
			exit(1);
		} else
			errx(1, "kvm_nlist: %s", kvm_geterr(kd));
	}
a277 3
	setegid(getgid());
	setgid(getgid());

d355 1
a355 3
		if (nlist == NULL && memf == NULL) {
			kread(X_BOOTTIME, &boottime, sizeof(boottime));
		} else {
d360 1
a360 2
				printf("Can't get kerninfo: %s\n",
				    strerror(errno));
d363 2
d397 1
a397 1
		printf("Can't get kerninfo: %s\n", strerror(errno));
d408 2
a409 4
		if (nlist == NULL && memf == NULL) {
			kread(X_UVMEXP, &uvmexp, sizeof(uvmexp));
		} else {
			size = sizeof(uvmexp);
d413 2
a414 3
				printf("Can't get kerninfo: %s\n",
				    strerror(errno));
				bzero(&uvmexp, sizeof(uvmexp));
d416 2
d426 1
a426 1
			printf("Can't get kerninfo: %s\n", strerror(errno));
d525 1
d528 1
d530 2
a531 4
	if (nlist == NULL && memf == NULL) {
		kread(X_UVMEXP, &uvmexp, sizeof(uvmexp));
	} else {
		size = sizeof(uvmexp);
d535 2
a536 2
			printf("Can't get kerninfo: %s\n", strerror(errno));
			bzero(&uvmexp, sizeof(uvmexp));
d538 2
d586 2
a587 4
	if (nlist == NULL && memf == NULL) {
		kread(X_UVMEXP, &nchstats, sizeof(uvmexp));
	} else {
		size = sizeof(uvmexp);
d591 2
a592 2
			printf("Can't get kerninfo: %s\n", strerror(errno));
			bzero(&uvmexp, sizeof(uvmexp));
d594 2
d676 1
a676 3
	if (nlist == NULL && memf == NULL) {
		kread(X_NCHSTATS, &nchstats, sizeof(nchstats));
	} else {
d681 1
a681 1
		    	printf("Can't get kerninfo: %s\n", strerror(errno));
d684 2
d702 1
a702 3
	if (nlist == NULL && memf == NULL) {
		kread(X_NSELCOLL, &nselcoll, sizeof(nselcoll));
	} else {
d707 1
a707 1
		    	printf("Can't get kerninfo: %s\n", strerror(errno));
d710 2
d723 1
a723 3
	if (nlist == NULL && memf == NULL) {
		kread(X_FORKSTAT, &fks, sizeof(struct forkstat));
	} else {
d728 1
a728 1
		    	printf("Can't get kerninfo: %s\n", strerror(errno));
d731 2
d789 1
d795 1
a795 1
	u_long inttotal;
d799 3
a801 1
	int i;
a804 2
	kread(X_INTRHAND, intrhand, sizeof(intrhand));
	kread(X_INTRSTRAY, intrstray, sizeof(intrstray));
d807 95
a901 13
	inttotal = 0;
	for (i = 0; i < 16; i++) {
		ihp = intrhand[i];
		while (ihp) {
			if (kvm_read(kd, (u_long)ihp, &ih, sizeof(ih)) != sizeof(ih))
				errx(1, "vmstat: ih: %s", kvm_geterr(kd));
			if (kvm_read(kd, (u_long)ih.ih_what, iname, 16) != 16)
				errx(1, "vmstat: ih_what: %s", kvm_geterr(kd));
			snprintf(fname, sizeof fname, "irq%d/%s", i, iname);
			printf("%-16.16s %10lu %8lu\n", fname, ih.ih_count,
			    ih.ih_count / uptime);
			inttotal += ih.ih_count;
			ihp = ih.ih_next;
d904 1
d993 1
a993 1
			printf("Could not acquire information on kernel memory bucket sizes.\n");
d1006 1
a1006 2
				printf("Failed to read statistics for bucket %d.\n",
				    mib[3]);
d1254 1
d1267 1
d1274 1
a1315 1

@


1.54
log
@Break out pool printing into a separate function.
@
text
@d2 1
a2 1
/*	$OpenBSD: vmstat.c,v 1.53 2001/05/11 14:35:29 deraadt Exp $	*/
d1096 3
d1102 53
a1154 1
	int first;
a1158 5
	int dosysctl, numpools;
	int mib[4];
	size_t size;

	dosysctl = (nlist != NULL || memf != NULL);
d1163 1
a1163 1
	for (first = 1; addr != 0; ) {
@


1.53
log
@cleanup
@
text
@d2 1
a2 1
/*	$OpenBSD: vmstat.c,v 1.52 2001/05/11 06:46:40 angelos Exp $	*/
d1036 60
d1099 1
a1099 1
	int first, ovflw;
d1104 5
d1114 1
a1114 1
		char name[32], maxp[32];
d1129 1
a1129 50
		if (first) {
			(void)printf("Memory resource pool statistics\n");
			(void)printf(
			    "%-11s%5s%9s%5s%9s%6s%6s%6s%6s%6s%6s%5s\n",
			    "Name",
			    "Size",
			    "Requests",
			    "Fail",
			    "Releases",
			    "Pgreq",
			    "Pgrel",
			    "Npage",
			    "Hiwat",
			    "Minpg",
			    "Maxpg",
			    "Idle");
			first = 0;
		}
		if (pp->pr_maxpages == UINT_MAX)
			sprintf(maxp, "inf");
		else
			sprintf(maxp, "%u", pp->pr_maxpages);
/*
 * Print single word.  `ovflow' is number of characters didn't fit
 * on the last word.  `fmt' is a format string to print this word.
 * It must contain asterisk for field width.  `width' is a width
 * occupied by this word.  `fixed' is a number of constant chars in
 * `fmt'.  `val' is a value to be printed using format string `fmt'.
 */
#define	PRWORD(ovflw, fmt, width, fixed, val) do {	\
	(ovflw) += printf((fmt),			\
	    (width) - (fixed) - (ovflw) > 0 ?		\
	    (width) - (fixed) - (ovflw) : 0,		\
	    (val)) - (width);				\
	if ((ovflw) < 0)				\
		(ovflw) = 0;				\
} while (/* CONSTCOND */0)
		ovflw = 0;
		PRWORD(ovflw, "%-*s", 11, 0, name);
		PRWORD(ovflw, " %*u", 5, 1, pp->pr_size);
		PRWORD(ovflw, " %*lu", 9, 1, pp->pr_nget);
		PRWORD(ovflw, " %*lu", 5, 1, pp->pr_nfail);
		PRWORD(ovflw, " %*lu", 9, 1, pp->pr_nput);
		PRWORD(ovflw, " %*lu", 6, 1, pp->pr_npagealloc);
		PRWORD(ovflw, " %*lu", 6, 1, pp->pr_npagefree);
		PRWORD(ovflw, " %*d", 6, 1, pp->pr_npages);
		PRWORD(ovflw, " %*d", 6, 1, pp->pr_hiwat);
		PRWORD(ovflw, " %*d", 6, 1, pp->pr_minpages);
		PRWORD(ovflw, " %*s", 6, 1, maxp);
		PRWORD(ovflw, " %*lu\n", 5, 1, pp->pr_nidle);
@


1.52
log
@Use sysctl(3) to retrieve nchstats, forkstat, nselcoll, and kmemstats
if the "default" files (running system) were specified for the ksyms
and memory dump. Eventually, it won't be necessary for vmstat to be
privileged.
@
text
@d2 1
a2 1
/*	$OpenBSD: vmstat.c,v 1.51 2001/04/30 13:54:51 art Exp $	*/
a86 2
#define	X_CPTIME	0
	{ "_cp_time" },
d88 1
a88 1
#define X_UVMEXP	1
d91 1
a91 1
#define X_SUM		1
d94 1
a94 1
#define	X_BOOTTIME	2
d96 1
a96 5
#define X_HZ		3
	{ "_hz" },
#define X_STATHZ	4
	{ "_stathz" },
#define X_NCHSTATS	5
d98 1
a98 1
#define	X_INTRNAMES	6
d100 1
a100 1
#define	X_EINTRNAMES	7
d102 1
a102 1
#define	X_INTRCNT	8
d104 1
a104 1
#define	X_EINTRCNT	9
d106 1
a106 1
#define	X_KMEMSTAT	10
d108 1
a108 1
#define	X_KMEMBUCKETS	11
d110 1
a110 1
#define X_ALLEVENTS	12
d112 1
a112 1
#define	X_FORKSTAT	13
d114 1
a114 1
#define X_POOLHEAD	14
d116 1
a116 1
#define X_NSELCOLL	15
d118 1
a118 5
#define X_END		16
#if defined(__pc532__)
#define	X_IVT		(X_END)
	{ "_ivt" },
#endif
d357 1
a357 1
				       strerror(errno));
d411 1
a411 1
				       strerror(errno));
d779 1
a779 36
#if defined(__pc532__)
/* To get struct iv ...*/
#define _KERNEL
#include <machine/psl.h>
#undef _KERNEL
void
dointr()
{
	register long i, j, inttotal;
	time_t uptime;
	static char iname[64];
	struct iv ivt[32], *ivp = ivt;

	iname[63] = '\0';
	uptime = getuptime();
	kread(X_IVT, ivp, sizeof(ivt));

	for (i = 0; i < 2; i++) {
		(void)printf("%sware interrupts:\n", i ? "\nsoft" : "hard");
		(void)printf("interrupt         total     rate\n");
		inttotal = 0;
		for (j = 0; j < 16; j++, ivp++) {
			if (ivp->iv_vec && ivp->iv_use && ivp->iv_cnt) {
				if (kvm_read(kd, (u_long)ivp->iv_use, iname, 63) != 63) {
					errx(1, "iv_use: %s", kvm_geterr(kd));
				}
				(void)printf("%-12s %10ld %8ld\n", iname,
				    ivp->iv_cnt, ivp->iv_cnt / uptime);
				inttotal += ivp->iv_cnt;
			}
		}
		(void)printf("Total        %10ld %8ld\n",
		    inttotal, inttotal / uptime);
	}
}
#elif defined(__i386__)
d818 1
a818 1
			       i, intrstray[i], intrstray[i] / uptime);
d898 1
a898 1
	        mib[0] = CTL_KERN;
d903 1
a903 1
		        printf("Could not acquire information on kernel memory bucket sizes.\n");
d912 1
a912 1
		        mib[3] = atoi(ap);
d915 3
a917 2
				   NULL, 0) < 0) {
			        printf("Failed to read statistics for bucket %d.\n", mib[3]);
d923 1
a923 1
	        kread(X_KMEMBUCKETS, buckets, sizeof(buckets));
d957 1
a957 1
	        	mib[0] = CTL_KERN;
@


1.51
log
@right value for X_NSELCOLL
@
text
@d2 1
a2 1
/*	$OpenBSD: vmstat.c,v 1.50 2001/04/30 12:07:30 art Exp $	*/
d413 12
a424 1
		kread(X_UVMEXP, &uvmexp, sizeof(uvmexp));
d528 2
d534 12
a545 1
	kread(X_UVMEXP, &uvmexp, sizeof(uvmexp));
d586 2
a587 1
	int nselcoll;
d590 12
a601 1
	kread(X_UVMEXP, &uvmexp, sizeof(uvmexp));
d680 12
a691 1
	kread(X_NCHSTATS, &nchstats, sizeof(nchstats));
d696 2
a697 2
	(void)printf(
	    "%11s cache hits (%d%% pos + %d%% neg) system %d%% per-directory\n",
d705 12
a716 1
	kread(X_NSELCOLL, &nselcoll, sizeof(nselcoll));
d724 14
a738 1
	kread(X_FORKSTAT, &fks, sizeof(struct forkstat));
d998 20
a1017 1
	kread(X_KMEMSTAT, kmemstats, sizeof(kmemstats));
@


1.50
log
@Ooops! Undo breakage I introduced in 1.48.
@
text
@d2 1
a2 1
/*	$OpenBSD: vmstat.c,v 1.49 2001/04/30 09:39:27 art Exp $	*/
d122 1
a122 1
#define X_NSELCOLL	16
@


1.49
log
@CLSIZE is 1 on all archs and will go away soon.
@
text
@d2 1
a2 1
/*	$OpenBSD: vmstat.c,v 1.48 2001/03/21 23:51:47 art Exp $	*/
d122 3
a124 1
#define X_END		15
d179 2
d245 2
a246 5
	if (kd == 0) {
		(void)fprintf(stderr,
		    "vmstat: kvm_openfiles: %s\n", errbuf);
		exit(1);
	}
d255 1
a255 1
			    "vmstat: undefined symbols:");
d262 1
d264 1
a264 3
			(void)fprintf(stderr, "vmstat: kvm_nlist: %s\n",
			    kvm_geterr(kd));
		exit(1);
d355 2
d358 14
a371 2
	if (boottime.tv_sec == 0)
		kread(X_BOOTTIME, &boottime, sizeof(boottime));
d374 3
a376 5
	if (uptime <= 0 || uptime > 60*60*24*365*10) {
		(void)fprintf(stderr,
		    "vmstat: time makes no sense; namelist must be wrong.\n");
		exit(1);
	}
d391 1
d398 8
a405 4
	if (namelist[X_STATHZ].n_type != 0 && namelist[X_STATHZ].n_value != 0)
		kread(X_STATHZ, &hz, sizeof(hz));
	if (!hz)
		kread(X_HZ, &hz, sizeof(hz));
d562 1
d658 2
d742 1
a742 3
					(void)fprintf(stderr, "vmstat: iv_use: %s\n",
					    kvm_geterr(kd));
					exit(1);
d762 1
a762 1
	long inttotal;
d764 1
a764 1
	int intrstray[16];
d783 1
a783 1
			printf("%-16.16s %10ld %8ld\n", fname, ih.ih_count,
d791 1
a791 1
			printf("Stray irq %-2d     %10d %8d\n",
d795 1
a795 1
	printf("Total            %10ld %8ld\n", inttotal, inttotal / uptime);
d815 2
a816 4
	if (intrcnt == NULL || intrname == NULL) {
		(void)fprintf(stderr, "vmstat: %s.\n", strerror(errno));
		exit(1);
	}
d833 2
a834 5
		    sizeof evcnt) != sizeof evcnt) {
			(void)fprintf(stderr, "vmstat: event chain trashed: %s\n",
			    kvm_geterr(kd));
			exit(1);
		}
d837 2
a838 5
			    sizeof dev) != sizeof dev) {
				(void)fprintf(stderr, "vmstat: event chain trashed: %s\n",
				    kvm_geterr(kd));
				exit(1);
			}
d862 2
a863 1
	long totuse = 0, totfree = 0, totreq = 0;
d867 31
a898 1
	kread(X_KMEMBUCKETS, buckets, sizeof(buckets));
d906 1
a906 1
	    	"    Size   In Use   Free   Requests  HighWater  Couldfree\n");
d910 1
a910 1
		(void)printf("%8d %8ld %6ld %10ld %7ld %10ld\n", size, 
d986 1
a986 1
	(void)printf("              %7ldK %6ldK    %8ld\n",
d1095 1
a1095 3
		(void)fprintf(stderr,
		    "vmstat: symbol %s not defined\n", sym);
		exit(1);
d1101 1
a1101 2
		(void)fprintf(stderr, "vmstat: %s: %s\n", sym, kvm_geterr(kd));
		exit(1);
d1108 2
a1109 3
	(void)fprintf(stderr,
	    "usage: vmstat [-fimst] [-c count] [-M core] \
[-N system] [-w wait] [disks]\n");
@


1.48
log
@Add printing of pool statistics for -m.
From NetBSD.
@
text
@d2 1
a2 1
/*	$OpenBSD: vmstat.c,v 1.37 2000/06/27 18:11:48 art Exp $	*/
d601 2
a602 2
	(void)printf("%11u pages swapped in\n", sum.v_pswpin / CLSIZE);
	(void)printf("%11u pages swapped out\n", sum.v_pswpout / CLSIZE);
d609 2
a610 2
	(void)printf("%11u zero fill pages created\n", sum.v_nzfod / CLSIZE);
	(void)printf("%11u zero fill page faults\n", sum.v_zfod / CLSIZE);
@


1.47
log
@Only use the sysctl interface if it's the running kernel we're getting
information from.
@
text
@d2 1
a2 1
/*	$OpenBSD: vmstat.c,v 1.46 2001/01/04 07:58:06 angelos Exp $	*/
d51 2
d65 1
d120 2
a121 2
#define X_NSELCOLL	14
	{ "_nselcoll" },
d163 1
a176 2
extern char *__progname;

d241 5
a245 2
	if (kd == 0)
		errx(1, "kvm_openfiles: %s", errbuf);
d254 1
a254 1
			    "%s: undefined symbols:", __progname);
a260 1
			exit(1);
d262 3
a264 1
			errx(1, "kvm_nlist: %s", kvm_geterr(kd));
d299 1
a299 1
	if (todo & MEMSTAT)
d301 2
a354 2
	int mib[2];
	size_t size;
d356 2
a357 14
	if (boottime.tv_sec == 0) {
	        if (nlist == NULL && memf == NULL) {
		        kread(X_BOOTTIME, &boottime, sizeof(boottime));
		} else {
		        size = sizeof(boottime);
			mib[0] = CTL_KERN;
			mib[1] = KERN_BOOTTIME;
			if (sysctl(mib, 2, &boottime, &size, NULL, 0) < 0) {
			        printf("Can't get kerninfo: %s\n",
				       strerror(errno));
				bzero(&boottime, sizeof(boottime));
			}
		}
	}
d360 5
a364 2
	if (uptime <= 0 || uptime > 60*60*24*365*10)
		errx(1, "time makes no sense; namelist must be wrong");
a378 1
        struct clockinfo clkinfo;
d385 4
a388 8
	mib[0] = CTL_KERN;
	mib[1] = KERN_CLOCKRATE;
	size = sizeof(clkinfo);
	if (sysctl(mib, 2, &clkinfo, &size, NULL, 0) < 0) {
		printf("Can't get kerninfo: %s\n", strerror(errno));
		return;
	}
	hz = clkinfo.stathz;
a544 1
	int nselcoll;
d559 1
a559 1
	    uvmexp.reserve_pagedaemon);
d561 1
a561 1
	    uvmexp.reserve_kernel);
d581 1
a581 1
	    uvmexp.forks_sharevm);
d585 1
a585 1
	    uvmexp.pdwoke);
a639 2
	kread(X_NSELCOLL, &nselcoll, sizeof(nselcoll));
	(void)printf("%11d select collisions\n", nselcoll);
d722 1
a722 1
					errx(1, "iv_use: %s", kvm_geterr(kd));
d744 1
a744 1
	u_long inttotal;
d746 1
a746 1
	u_long intrstray[16];
d765 1
a765 1
			printf("%-16.16s %10lu %8lu\n", fname, ih.ih_count,
d773 1
a773 1
			printf("Stray irq %-2d     %10lu %8lu\n",
d777 1
a777 1
	printf("Total            %10lu %8lu\n", inttotal, inttotal / uptime);
d797 4
a800 2
	if (intrcnt == NULL || intrname == NULL)
		err(1, "malloc");
d817 5
a821 2
		    sizeof evcnt) != sizeof evcnt)
			errx(1, "event chain trashed: %s", kvm_geterr(kd));
d824 5
a828 2
			    sizeof dev) != sizeof dev)
				errx(1, "event chain trashed: %s", kvm_geterr(kd));
d852 1
a852 2
	u_long totuse = 0, totfree = 0;
	quad_t totreq = 0;
a855 31
	int mib[4];
	size_t siz;
	char buf[BUFSIZ], *bufp, *ap;

	if (memf == NULL && nlistf == NULL) {
	        mib[0] = CTL_KERN;
		mib[1] = KERN_MALLOCSTATS;
		mib[2] = KERN_MALLOC_BUCKETS;
		siz = sizeof(buf);
		if (sysctl(mib, 3, buf, &siz, NULL, 0) < 0) {
		        printf("Could not acquire information on kernel memory bucket sizes.\n");
			return;
		}

		bufp = buf;
		mib[2] = KERN_MALLOC_BUCKET;
		siz = sizeof(struct kmembuckets);
		i = 0;
		while ((ap = strsep(&bufp, ",")) != NULL) {
		        mib[3] = atoi(ap);

			if (sysctl(mib, 4, &buckets[MINBUCKET + i], &siz,
				   NULL, 0) < 0) {
			        printf("Failed to read statistics for bucket %d.\n", mib[3]);
				return;
			}
			i++;
		}
	} else {
	        kread(X_KMEMBUCKETS, buckets, sizeof(buckets));
	}
d857 1
d865 1
a865 1
		"    Size   In Use   Free           Requests  HighWater  Couldfree\n");
d869 1
a869 1
		(void)printf("%8d %8qu %6qu %18qu %7qu %10qu\n", size,
d945 1
a945 1
	(void)printf("              %7luK %6luK    %8qu\n",
d949 90
d1054 3
a1056 1
		errx(1, "symbol %s not defined", sym);
d1062 2
a1063 1
		errx(1, "%s: %s", sym, kvm_geterr(kd));
d1070 3
a1072 2
	(void)fprintf(stderr, "usage: %s [-fimst] [-c count] [-M core] "
	    "[-N system] [-w wait] [disks]\n", __progname);
@


1.46
log
@Update to use the new sysctl return value for kmembuckets. That's it
for tonight.
@
text
@d2 1
a2 1
/*	$OpenBSD: vmstat.c,v 1.45 2001/01/04 07:08:18 angelos Exp $	*/
d351 11
a361 6
		size = sizeof(boottime);
		mib[0] = CTL_KERN;
		mib[1] = KERN_BOOTTIME;
		if (sysctl(mib, 2, &boottime, &size, NULL, 0) < 0) {
			printf("Can't get kerninfo: %s\n", strerror(errno));
			bzero(&boottime, sizeof(boottime));
d864 9
a872 9
	mib[0] = CTL_KERN;
	mib[1] = KERN_MALLOCSTATS;
	mib[2] = KERN_MALLOC_BUCKETS;
	siz = sizeof(buf);
	if (sysctl(mib, 3, buf, &siz, NULL, 0) < 0) {
		printf(
		    "Could not acquire information on kernel memory bucket sizes.\n");
		return;
	}
d874 13
a886 12
	bufp = buf;
	mib[2] = KERN_MALLOC_BUCKET;
	siz = sizeof(struct kmembuckets);
	i = 0;
	while ((ap = strsep(&bufp, ",")) != NULL) {
	        mib[3] = atoi(ap);

		if (sysctl(mib, 4, &buckets[MINBUCKET + i], &siz,
			   NULL, 0) < 0) {
		        printf("Failed to read statistics for bucket %d.\n",
			       mib[3]);
			return;
d888 2
a889 1
		i++;
@


1.45
log
@Use sysctl(3) to get clock information as well.
@
text
@d2 1
a2 1
/*	$OpenBSD: vmstat.c,v 1.44 2001/01/04 06:50:21 angelos Exp $	*/
d855 1
a855 1
	int mib[5];
d871 1
a874 1
		siz = sizeof(u_int64_t);
d876 1
a876 2
		mib[4] = KERN_MALLOC_CALLS;
		if (sysctl(mib, 5, &buckets[MINBUCKET + i].kb_calls, &siz,
a881 41

		mib[4] = KERN_MALLOC_ALLOC;
		if (sysctl(mib, 5, &buckets[MINBUCKET + i].kb_total, &siz,
			   NULL, 0) < 0) {
		        printf("Failed to read statistics for bucket %d.\n",
			       mib[3]);
			return;
		}

		mib[4] = KERN_MALLOC_FREE;
		if (sysctl(mib, 5, &buckets[MINBUCKET + i].kb_totalfree, &siz,
			   NULL, 0) < 0) {
		        printf("Failed to read statistics for bucket %d.\n",
			       mib[3]);
			return;
		}

		mib[4] = KERN_MALLOC_ELEMENTS;
		if (sysctl(mib, 5, &buckets[MINBUCKET + i].kb_elmpercl, &siz,
			   NULL, 0) < 0) {
		        printf("Failed to read statistics for bucket %d.\n",
			       mib[3]);
			return;
		}

		mib[4] = KERN_MALLOC_HIWAT;
		if (sysctl(mib, 5, &buckets[MINBUCKET + i].kb_highwat, &siz,
			   NULL, 0) < 0) {
		        printf("Failed to read statistics for bucket %d.\n",
			       mib[3]);
			return;
		}

		mib[4] = KERN_MALLOC_COULDFREE;
		if (sysctl(mib, 5, &buckets[MINBUCKET + i].kb_couldfree, &siz,
			   NULL, 0) < 0) {
		        printf("Failed to read statistics for bucket %d.\n",
			       mib[3]);
			return;
		}

@


1.44
log
@Use the new sysctl(3) interface for the kernel memory bucket statistics.
@
text
@d2 1
a2 1
/*	$OpenBSD: vmstat.c,v 1.43 2001/01/04 06:26:49 angelos Exp $	*/
d377 1
d384 8
a391 4
	if (namelist[X_STATHZ].n_type != 0 && namelist[X_STATHZ].n_value != 0)
		kread(X_STATHZ, &hz, sizeof(hz));
	if (!hz)
		kread(X_HZ, &hz, sizeof(hz));
@


1.43
log
@Use sysctl(3) to get the boottime, rather than kread()
@
text
@d2 1
a2 1
/*	$OpenBSD: vmstat.c,v 1.42 2001/01/03 19:24:04 angelos Exp $	*/
d850 71
a921 1
	kread(X_KMEMBUCKETS, buckets, sizeof(buckets));
@


1.42
log
@New length of kmembuckets counters; we don't really take advantage of
the full length, since that would bring us way beyond typical terminal
size (~20 digits per field). Still, this should be enough for a while.
@
text
@d2 1
a2 1
/*	$OpenBSD: vmstat.c,v 1.41 2001/01/02 17:51:11 mickey Exp $	*/
d347 2
d350 9
a358 2
	if (boottime.tv_sec == 0)
		kread(X_BOOTTIME, &boottime, sizeof(boottime));
@


1.41
log
@accumulate memory total requests in quad
@
text
@d2 1
a2 1
/*	$OpenBSD: vmstat.c,v 1.40 2001/01/02 17:27:29 angelos Exp $	*/
d850 1
a850 1
		"    Size   In Use   Free     Requests  HighWater  Couldfree\n");
d854 1
a854 1
		(void)printf("%8d %8ld %6ld %12lu %7ld %10ld\n", size,
@


1.40
log
@A bit more space to accomodate u_long for kb_calls (Requests column)
@
text
@d2 1
a2 1
/*	$OpenBSD: vmstat.c,v 1.39 2000/11/26 02:30:30 art Exp $	*/
d836 2
a837 1
	long totuse = 0, totfree = 0, totreq = 0;
d930 1
a930 1
	(void)printf("              %7ldK %6ldK    %8ld\n",
@


1.39
log
@Print select collisions in the vmstat -s output.
(XXX - I couldn't find a better place to put it.).
@
text
@d2 1
a2 1
/*	$OpenBSD: vmstat.c,v 1.38 2000/10/25 16:49:32 mickey Exp $	*/
d849 1
a849 1
		"    Size   In Use   Free   Requests  HighWater  Couldfree\n");
d853 1
a853 1
		(void)printf("%8d %8ld %6ld %10ld %7ld %10ld\n", size,
@


1.38
log
@i386's interrupt counters are u_long, adjust printf formats.
use err/errx instead of fprintf+exit.
deraadt@@ ok
@
text
@d2 1
a2 1
/*	$OpenBSD: vmstat.c,v 1.37 2000/06/27 18:11:48 art Exp $	*/
d117 3
a119 13
#ifdef notdef
#define	X_DEFICIT	14
	{ "_deficit" },
#define X_REC		15
	{ "_rectime" },
#define X_PGIN		16
	{ "_pgintime" },
#define	X_XSTATS	17
	{ "_xstats" },
#define X_END		28
#else
#define X_END		14
#endif
d534 1
d630 2
@


1.37
log
@Tyop
@
text
@d2 1
a2 1
/*	$OpenBSD: vmstat.c,v 1.36 2000/06/18 17:59:56 niklas Exp $	*/
d183 2
d249 2
a250 5
	if (kd == 0) {
		(void)fprintf(stderr,
		    "vmstat: kvm_openfiles: %s\n", errbuf);
		exit(1);
	}
d259 1
a259 1
			    "vmstat: undefined symbols:");
d266 1
d268 1
a268 3
			(void)fprintf(stderr, "vmstat: kvm_nlist: %s\n",
			    kvm_geterr(kd));
		exit(1);
d362 2
a363 5
	if (uptime <= 0 || uptime > 60*60*24*365*10) {
		(void)fprintf(stderr,
		    "vmstat: time makes no sense; namelist must be wrong.\n");
		exit(1);
	}
d558 1
a558 1
		     uvmexp.reserve_pagedaemon);
d560 1
a560 1
		     uvmexp.reserve_kernel);
d580 1
a580 1
		     uvmexp.forks_sharevm);
d584 1
a584 1
		     uvmexp.pdwoke);
d721 1
a721 1
					(void)fprintf(stderr, "vmstat: iv_use: %s\n",
d743 1
a743 1
	long inttotal;
d745 1
a745 1
	int intrstray[16];
d764 1
a764 1
			printf("%-16.16s %10ld %8ld\n", fname, ih.ih_count,
d772 1
a772 1
			printf("Stray irq %-2d     %10d %8d\n",
d776 1
a776 1
	printf("Total            %10ld %8ld\n", inttotal, inttotal / uptime);
d796 2
a797 4
	if (intrcnt == NULL || intrname == NULL) {
		(void)fprintf(stderr, "vmstat: %s.\n", strerror(errno));
		exit(1);
	}
d814 2
a815 5
		    sizeof evcnt) != sizeof evcnt) {
			(void)fprintf(stderr, "vmstat: event chain trashed: %s\n",
			    kvm_geterr(kd));
			exit(1);
		}
d818 2
a819 5
			    sizeof dev) != sizeof dev) {
				(void)fprintf(stderr, "vmstat: event chain trashed: %s\n",
				    kvm_geterr(kd));
				exit(1);
			}
d856 1
a856 1
	    	"    Size   In Use   Free   Requests  HighWater  Couldfree\n");
d860 1
a860 1
		(void)printf("%8d %8ld %6ld %10ld %7ld %10ld\n", size, 
d955 1
a955 3
		(void)fprintf(stderr,
		    "vmstat: symbol %s not defined\n", sym);
		exit(1);
d961 1
a961 2
		(void)fprintf(stderr, "vmstat: %s: %s\n", sym, kvm_geterr(kd));
		exit(1);
d968 2
a969 3
	(void)fprintf(stderr,
	    "usage: vmstat [-fimst] [-c count] [-M core] \
[-N system] [-w wait] [disks]\n");
@


1.36
log
@Mark kernel threads as system processes.  Make ps hide them by default,
show them with -k.  Do not try to show RSS based values for them as they
mess up column alignment.  vmstat -f now shows kernel threads separately
from rforks too.
@
text
@d2 1
a2 1
/*	$OpenBSD: vmstat.c,v 1.35 1999/12/12 00:52:21 hugh Exp $	*/
d588 1
a588 1
	(void)printf("%11u number of times the pagedamoen woke up\n",
@


1.35
log
@widen output formatting a bit
@
text
@d2 1
a2 1
/*	$OpenBSD: vmstat.c,v 1.34 1999/09/02 01:23:30 deraadt Exp $	*/
d658 2
@


1.34
log
@print i386 irqs nicer, so that sharing is more obvious
@
text
@d2 1
a2 1
/*	$OpenBSD: vmstat.c,v 1.33 1999/08/16 19:06:15 art Exp $	*/
d419 1
a419 1
		(void)printf("%6u%6u ",
d472 1
a472 1
	(void)printf(" procs   memory     page%*s", 20, "");
d481 1
a481 1
	(void)printf(" r b w   avm   fre  flt  re  pi  po  fr  sr ");
d553 1
a553 1
	(void)printf("%9u bytes per page\n", uvmexp.pagesize);
d556 7
a562 7
	(void)printf("%9u pages managed\n", uvmexp.npages);
	(void)printf("%9u pages free\n", uvmexp.free);
	(void)printf("%9u pages active\n", uvmexp.active);
	(void)printf("%9u pages inactive\n", uvmexp.inactive);
	(void)printf("%9u pages being paged out\n", uvmexp.paging);
	(void)printf("%9u pages wired\n", uvmexp.wired);
	(void)printf("%9u pages reserved for pagedaemon\n",
d564 1
a564 1
	(void)printf("%9u pages reserved for kernel\n",
d568 4
a571 4
	(void)printf("%9u swap pages\n", uvmexp.swpages);
	(void)printf("%9u swap pages in use\n", uvmexp.swpginuse);
	(void)printf("%9u total anon's in system\n", uvmexp.nanon);
	(void)printf("%9u free anon's\n", uvmexp.nfreeanon);
d574 11
a584 11
	(void)printf("%9u page faults\n", uvmexp.faults);
	(void)printf("%9u traps\n", uvmexp.traps);
	(void)printf("%9u interrupts\n", uvmexp.intrs);
	(void)printf("%9u cpu context switches\n", uvmexp.swtch);
	(void)printf("%9u software interrupts\n", uvmexp.softs);
	(void)printf("%9u syscalls\n", uvmexp.syscalls);
	(void)printf("%9u pagein operations\n", uvmexp.pageins);
	(void)printf("%9u swap ins\n", uvmexp.swapins);
	(void)printf("%9u swap outs\n", uvmexp.swapouts);
	(void)printf("%9u forks\n", uvmexp.forks);
	(void)printf("%9u forks where vmspace is shared\n",
d588 1
a588 1
	(void)printf("%9u number of times the pagedamoen woke up\n",
d590 5
a594 5
	(void)printf("%9u revolutions of the clock hand\n", uvmexp.pdrevs);
	(void)printf("%9u pages freed by pagedaemon\n", uvmexp.pdfreed);
	(void)printf("%9u pages scanned by pagedaemon\n", uvmexp.pdscans);
	(void)printf("%9u pages reactivated by pagedaemon\n", uvmexp.pdreact);
	(void)printf("%9u busy pages found by pagedaemon\n", uvmexp.pdbusy);
d597 31
a627 31
	(void)printf("%9u cpu context switches\n", sum.v_swtch);
	(void)printf("%9u device interrupts\n", sum.v_intr);
	(void)printf("%9u software interrupts\n", sum.v_soft);
	(void)printf("%9u traps\n", sum.v_trap);
	(void)printf("%9u system calls\n", sum.v_syscall);
	(void)printf("%9u total faults taken\n", sum.v_faults);
	(void)printf("%9u swap ins\n", sum.v_swpin);
	(void)printf("%9u swap outs\n", sum.v_swpout);
	(void)printf("%9u pages swapped in\n", sum.v_pswpin / CLSIZE);
	(void)printf("%9u pages swapped out\n", sum.v_pswpout / CLSIZE);
	(void)printf("%9u page ins\n", sum.v_pageins);
	(void)printf("%9u page outs\n", sum.v_pageouts);
	(void)printf("%9u pages paged in\n", sum.v_pgpgin);
	(void)printf("%9u pages paged out\n", sum.v_pgpgout);
	(void)printf("%9u pages reactivated\n", sum.v_reactivated);
	(void)printf("%9u intransit blocking page faults\n", sum.v_intrans);
	(void)printf("%9u zero fill pages created\n", sum.v_nzfod / CLSIZE);
	(void)printf("%9u zero fill page faults\n", sum.v_zfod / CLSIZE);
	(void)printf("%9u pages examined by the clock daemon\n", sum.v_scan);
	(void)printf("%9u revolutions of the clock hand\n", sum.v_rev);
	(void)printf("%9u VM object cache lookups\n", sum.v_lookups);
	(void)printf("%9u VM object hits\n", sum.v_hits);
	(void)printf("%9u total VM faults taken\n", sum.v_vm_faults);
	(void)printf("%9u copy-on-write faults\n", sum.v_cow_faults);
	(void)printf("%9u pages freed by daemon\n", sum.v_dfree);
	(void)printf("%9u pages freed by exiting processes\n", sum.v_pfree);
	(void)printf("%9u pages free\n", sum.v_free_count);
	(void)printf("%9u pages wired down\n", sum.v_wire_count);
	(void)printf("%9u pages active\n", sum.v_active_count);
	(void)printf("%9u pages inactive\n", sum.v_inactive_count);
	(void)printf("%9u bytes per page\n", sum.v_page_size);
d634 1
a634 1
	(void)printf("%9ld total name lookups\n", nchtotal);
d636 1
a636 1
	    "%9s cache hits (%d%% pos + %d%% neg) system %d%% per-directory\n",
d640 1
a640 1
	(void)printf("%9s deletions %d%%, falsehits %d%%, toolong %d%%\n", "",
@


1.33
log
@printf format fixes
@
text
@d2 1
a2 1
/*	$OpenBSD: vmstat.c,v 1.32 1999/07/17 22:11:15 art Exp $	*/
d749 1
a749 1
	char iname[17];
d766 3
a768 1
			printf("%-16.16s %10ld %8ld\n", iname, ih.ih_count, ih.ih_count / uptime);
@


1.32
log
@nice printing of sum^H^H^Huvmexp for uvm
@
text
@d2 1
a2 1
/*	$OpenBSD: vmstat.c,v 1.31 1999/06/24 12:36:17 art Exp $	*/
d818 1
a818 1
			(void)fprintf(stderr, "vmstat: event chain trashed\n",
d825 1
a825 1
				(void)fprintf(stderr, "vmstat: event chain trashed\n",
d830 2
a831 2
				(void)printf("%-14s %12ld %8ld\n", dev.dv_xname,
				    evcnt.ev_count, evcnt.ev_count / uptime);
@


1.31
log
@Ooops! Make this work without uvm
@
text
@d2 1
a2 1
/*	$OpenBSD: vmstat.c,v 1.30 1999/06/23 19:25:56 art Exp $	*/
a550 5
	/*
	 * XXXART - We probably don't want to look like the old vmstat,
	 * The best would be just to print out everything in uvmexp
	 * XXXART - Just make it work now. Do it right later.
	 */
d552 25
a577 1
	(void)printf("%9u device interrupts\n", uvmexp.intrs);
d579 2
a580 3
	(void)printf("%9u traps\n", uvmexp.traps);
	(void)printf("%9u system calls\n", uvmexp.syscalls);
	(void)printf("%9u total faults taken\n", uvmexp.faults);
d583 7
a589 7
	(void)printf("%9u pages swapped in\n", uvmexp.pgswapin);
	(void)printf("%9u pages swapped out\n", uvmexp.pgswapout);
	(void)printf("%9u page ins\n", uvmexp.pageins);
	(void)printf("%9u page outs\n", uvmexp.pdpageouts);
	(void)printf("%9u pages reactivated\n", uvmexp.pdreact);
	(void)printf("%9u zero fill pages created\n", uvmexp.flt_przero);
	(void)printf("%9u pages examined by the clock daemon\n", uvmexp.pdscans);
d591 4
a594 10
#if 0
	(void)printf("%9u total VM faults taken\n", uvmexp.vm_faults);
#endif
	(void)printf("%9u copy-on-write faults\n", uvmexp.flt_acow);
	(void)printf("%9u pages freed by daemon\n", uvmexp.pdfreed);
	(void)printf("%9u pages free\n", uvmexp.free);
	(void)printf("%9u pages wired down\n", uvmexp.wired);
	(void)printf("%9u pages active\n", uvmexp.active);
	(void)printf("%9u pages inactive\n", uvmexp.inactive);
	(void)printf("%9u bytes per page\n", uvmexp.pagesize);
@


1.30
log
@kill old tahoe code
@
text
@d2 1
a2 1
/*	$OpenBSD: vmstat.c,v 1.29 1999/06/23 18:48:12 art Exp $	*/
d452 1
d454 3
@


1.29
log
@make it work with UVM. XXX - not done yet.
@
text
@d2 1
a2 1
/*	$OpenBSD: vmstat.c,v 1.28 1999/06/11 23:10:52 espie Exp $	*/
a129 8
#ifdef tahoe
#define	X_VBDINIT	(X_END)
	{ "_vbdinit" },
#define	X_CKEYSTATS	(X_END+1)
	{ "_ckeystats" },
#define	X_DKEYSTATS	(X_END+2)
	{ "_dkeystats" },
#endif
a539 4
#if defined(tahoe)
#include <machine/cpu.h>
#endif

a544 3
#if defined(tahoe)
	struct keystats keystats;
#endif
a627 16
#if defined(tahoe)
	kread(X_CKEYSTATS, &keystats, sizeof(keystats));
	(void)printf("%9d %s (free %d%% norefs %d%% taken %d%% shared %d%%)\n",
	    keystats.ks_allocs, "code cache keys allocated",
	    PCT(keystats.ks_allocfree, keystats.ks_allocs),
	    PCT(keystats.ks_norefs, keystats.ks_allocs),
	    PCT(keystats.ks_taken, keystats.ks_allocs),
	    PCT(keystats.ks_shared, keystats.ks_allocs));
	kread(X_DKEYSTATS, &keystats, sizeof(keystats));
	(void)printf("%9d %s (free %d%% norefs %d%% taken %d%% shared %d%%)\n",
	    keystats.ks_allocs, "data cache keys allocated",
	    PCT(keystats.ks_allocfree, keystats.ks_allocs),
	    PCT(keystats.ks_norefs, keystats.ks_allocs),
	    PCT(keystats.ks_taken, keystats.ks_allocs),
	    PCT(keystats.ks_shared, keystats.ks_allocs));
#endif
@


1.28
log
@Some stray i386 -> __i386__ that only trigger for vmstat -i.
pc532 -> __pc532__ as well.

Reported & diagnosed by ficus.
@
text
@d2 1
a2 1
/*	$OpenBSD: vmstat.c,v 1.27 1999/05/13 22:12:50 alex Exp $	*/
d79 4
d86 4
d92 1
d156 3
d160 1
d407 3
d411 1
d421 4
d426 1
a426 1
#define	rate(x)	(((x) + halfuptime) / uptime)	/* round */
d429 13
d454 1
d460 1
a460 1
		osum = sum;
d511 11
d531 1
d561 34
d627 2
@


1.27
log
@vmstat -i: Increase width of interrupt count column.
@
text
@d2 1
a2 1
/*	$OpenBSD: vmstat.c,v 1.26 1999/03/15 15:38:48 deraadt Exp $	*/
d129 1
a129 1
#if defined(pc532)
d133 1
a133 1
#if defined(i386)
d632 1
a632 1
#if defined(pc532)
d669 1
a669 1
#elif defined(i386)
@


1.26
log
@re-indent; nash@@mcs.net
@
text
@d2 1
a2 1
/*	$OpenBSD: vmstat.c,v 1.25 1998/07/08 22:14:18 deraadt Exp $	*/
d651 1
a651 1
		(void)printf("interrupt       total     rate\n");
d660 1
a660 1
				(void)printf("%-12s %8ld %8ld\n", iname,
d665 1
a665 1
		(void)printf("Total        %8ld %8ld\n",
d689 1
a689 1
	(void)printf("interrupt           total     rate\n");
d698 1
a698 1
			printf("%-16.16s %8ld %8ld\n", iname, ih.ih_count, ih.ih_count / uptime);
d705 1
a705 1
			printf("Stray irq %-2d     %8d %8d\n",
d709 1
a709 1
	printf("Total            %8ld %8ld\n", inttotal, inttotal / uptime);
d735 1
a735 1
	(void)printf("interrupt         total     rate\n");
d740 1
a740 1
			(void)printf("%-14s %8ld %8ld\n", intrname,
d762 1
a762 1
				(void)printf("%-14s %8ld %8ld\n", dev.dv_xname,
d768 1
a768 1
	(void)printf("Total          %8ld %8ld\n", inttotal, inttotal / uptime);
@


1.25
log
@whack kmem gid after kvm_openfiles()
@
text
@d2 1
a2 1
/*	$OpenBSD: vmstat.c,v 1.24 1998/05/19 17:38:20 mickey Exp $	*/
d850 1
a850 1
	   "\nMemory statistics by type                          Type  Kern\n");
d852 1
a852 1
"         Type InUse MemUse HighUse  Limit Requests Limit Limit Size(s)\n");
@


1.24
log
@14 for a type field to accomodate 'VM page bucket'
@
text
@d2 1
a2 1
/*	$OpenBSD: vmstat.c,v 1.23 1997/11/30 09:18:25 deraadt Exp $	*/
d188 1
a188 1
        char errbuf[_POSIX2_LINE_MAX];
d241 1
a241 1
        kd = kvm_openfiles(nlistf, memf, NULL, O_RDONLY, errbuf);
d249 4
d279 3
@


1.23
log
@remove dk_* use; kstailey/mickey please finish this correctly
@
text
@d2 1
a2 1
/*	$OpenBSD: vmstat.c,v 1.22 1997/11/09 22:13:49 millert Exp $	*/
d849 1
a849 1
		(void)printf("%13s%6ld%6ldK%7ldK%6ldK%9ld%5u%6u",
@


1.22
log
@struct vmtotal contains unsigned vars.
@
text
@d2 1
a2 1
/*	$OpenBSD: vmstat.c,v 1.21 1997/11/07 18:45:29 millert Exp $	*/
d82 1
a82 3
#define	X_DK_NDRIVE	1
	{ "_dk_ndrive" },
#define X_SUM		2
d84 1
a84 1
#define	X_BOOTTIME	3
d86 1
a86 3
#define	X_DKXFER	4
	{ "_dk_xfer" },
#define X_HZ		5
d88 1
a88 1
#define X_STATHZ	6
d90 1
a90 1
#define X_NCHSTATS	7
d92 1
a92 1
#define	X_INTRNAMES	8
d94 1
a94 1
#define	X_EINTRNAMES	9
d96 1
a96 1
#define	X_INTRCNT	10
d98 1
a98 1
#define	X_EINTRCNT	11
d100 1
a100 1
#define	X_KMEMSTAT	12
d102 1
a102 1
#define	X_KMEMBUCKETS	13
d104 1
a104 1
#define X_ALLEVENTS	14
d106 1
a106 1
#define	X_FORKSTAT	15
d109 1
a109 1
#define	X_DEFICIT	16
d111 1
a111 1
#define X_REC		17
d113 1
a113 1
#define X_PGIN		18
d115 1
a115 1
#define	X_XSTATS	19
d117 1
a117 1
#define X_END		20
d119 1
a119 1
#define X_END		16
@


1.21
log
@-Wall and remove old vm stuff.
@
text
@d2 1
a2 1
/*	$OpenBSD: vmstat.c,v 1.20 1997/06/30 07:04:08 deraadt Exp $	*/
d399 1
a399 1
		(void)printf("%2d%2d%2d",
d401 1
a401 1
#define pgtok(a) ((a) * (sum.v_page_size >> 10))
d403 1
a403 1
		(void)printf("%6d%6d ",
@


1.20
log
@-f and -t are supported...
@
text
@d2 1
a2 1
/*	$OpenBSD: vmstat.c,v 1.19 1997/06/30 07:03:06 deraadt Exp $	*/
d67 1
a78 1
#define NEWVM			/* XXX till old has been updated or purged */
d175 1
d182 1
a314 2
	register char **cp;
	char buf[30];
d403 1
a403 1
		(void)printf("%6ld%6ld ",
d405 2
a406 3
#ifdef NEWVM
		(void)printf("%4lu ", rate(sum.v_faults - osum.v_faults));
		(void)printf("%3lu ",
d408 2
a409 2
		(void)printf("%3lu ", rate(sum.v_pageins - osum.v_pageins));
		(void)printf("%3lu %3lu ",
d411 1
a411 14
#else
		(void)printf("%3lu %2lu ",
		    rate(sum.v_pgrec - (sum.v_xsfrec+sum.v_xifrec) -
		    (osum.v_pgrec - (osum.v_xsfrec+osum.v_xifrec))),
		    rate(sum.v_xsfrec + sum.v_xifrec -
		    osum.v_xsfrec - osum.v_xifrec));
		(void)printf("%3lu ",
		    rate(pgtok(sum.v_pgpgin - osum.v_pgpgin)));
		(void)printf("%3lu %3lu ",
		    rate(pgtok(sum.v_pgpgout - osum.v_pgpgout)),
		    rate(pgtok(sum.v_dfree - osum.v_dfree)));
		(void)printf("%3d ", pgtok(deficit));
#endif
		(void)printf("%3lu ", rate(sum.v_scan - osum.v_scan));
d413 1
a413 1
		(void)printf("%4lu %4lu %3lu ",
d433 1
a439 1
#ifdef NEWVM
a441 3
#else
		(void)printf("disks %*sfaults      cpu\n",
#endif
a443 1
#ifdef NEWVM
a444 3
#else
		(void)printf("%*s  faults      cpu\n",
#endif
a446 1
#ifdef NEWVM
a447 3
#else
	(void)printf(" r b w   avm   fre  re at  pi  po  fr  de  sr ");
#endif
a470 1
#ifdef NEWVM
a472 4
#else
	kread(X_REC, &rectime, sizeof(rectime));
	kread(X_PGIN, &pgintime, sizeof(pgintime));
#endif
d484 1
a505 3
#ifndef NEWVM
	struct xstats xstats;
#endif
a531 1
#ifdef NEWVM
a542 18
#else
	(void)printf("%9u sequential process pages freed\n", sum.v_seqfree);
	(void)printf("%9u total reclaims (%d%% fast)\n", sum.v_pgrec,
	    PCT(sum.v_fastpgrec, sum.v_pgrec));
	(void)printf("%9u reclaims from free list\n", sum.v_pgfrec);
	(void)printf("%9u executable fill pages created\n",
	    sum.v_nexfod / CLSIZE);
	(void)printf("%9u executable fill page faults\n",
	    sum.v_exfod / CLSIZE);
	(void)printf("%9u swap text pages found in free list\n",
	    sum.v_xsfrec);
	(void)printf("%9u inode text pages found in free list\n",
	    sum.v_xifrec);
	(void)printf("%9u file fill pages created\n", sum.v_nvrfod / CLSIZE);
	(void)printf("%9u file fill page faults\n", sum.v_vrfod / CLSIZE);
	(void)printf("%9u pages freed by the clock daemon\n",
	    sum.v_dfree / CLSIZE);
#endif
a556 10
#ifndef NEWVM
	kread(X_XSTATS, &xstats, sizeof(xstats));
	(void)printf("%9lu total calls to xalloc (cache hits %d%%)\n",
	    xstats.alloc, PCT(xstats.alloc_cachehit, xstats.alloc));
	(void)printf("%9s sticky %lu flushed %lu unused %lu\n", "",
	    xstats.alloc_inuse, xstats.alloc_cacheflush, xstats.alloc_unused);
	(void)printf("%9lu total calls to xfree", xstats.free);
	(void)printf(" (sticky %lu cached %lu swapped %lu)\n",
	    xstats.free_inuse, xstats.free_cache, xstats.free_cacheswap);
#endif
a593 1
	long tmp;
d702 1
a702 1
			printf("Stray irq %-2d     %8ld %8ld\n",
@


1.19
log
@fix time_t vs long issues
@
text
@d2 1
a2 1
/*	$OpenBSD: vmstat.c,v 1.18 1997/02/22 17:20:30 kstailey Exp $	*/
a971 1
#ifndef NEWVM
a973 4
#else
	    "usage: vmstat [-ims] [-c count] [-M core] \
[-N system] [-w wait] [disks]\n");
#endif
@


1.18
log
@if sys/kern/malloc.c does not #define KMEMSTATS (and DIAGNOSTIC is also
not #defined) then vmstat should not try to print kernel memory stats.

Fixes NetBSD PR #3187.
@
text
@d2 1
a2 1
/*	$OpenBSD: vmstat.c,v 1.17 1997/02/13 20:17:16 kstailey Exp $	*/
d345 1
a345 1
long
d699 2
a700 1
	register long i, j, inttotal, uptime;
d737 2
a738 1
	long inttotal, uptime;
d774 2
a775 1
	register long *intrcnt, inttotal, uptime;
@


1.17
log
@enlarged vmstat -m "Type" column to accomodate "MSDOSFS mount"
@
text
@d2 1
a2 1
/*	$OpenBSD: vmstat.c,v 1.16 1997/01/15 23:43:34 millert Exp $	*/
d846 2
a847 4
	(void)printf("Memory statistics by bucket size\n");
	(void)printf(
	    "    Size   In Use   Free   Requests  HighWater  Couldfree\n");
	for (i = MINBUCKET, kp = &buckets[i]; i < MINBUCKET + 16; i++, kp++) {
d850 6
d862 10
@


1.16
log
@getopt(3) returns -1 when out of args, not EOF, whee!
@
text
@d2 1
a2 1
/*	$OpenBSD: vmstat.c,v 1.15 1996/12/22 03:26:09 tholo Exp $	*/
d892 1
a892 1
	    "\nMemory statistics by type                        Type  Kern\n");
d894 1
a894 1
"       Type  InUse MemUse HighUse  Limit Requests Limit Limit Size(s)\n");
d898 1
a898 1
		(void)printf("%12s%6ld%6ldK%7ldK%6ldK%9ld%5u%6u",
@


1.15
log
@Deal with _POSIX_SAVED_IDS when relinquishing privileges
@
text
@d2 1
a2 1
/*	$OpenBSD: vmstat.c,v 1.14 1996/12/04 10:04:44 deraadt Exp $	*/
d194 1
a194 1
	while ((c = getopt(argc, argv, "c:fiM:mN:stw:")) != EOF) {
@


1.14
log
@roundup error; netbsd pr#2944, augustss@@cs.chalmers.se
@
text
@d2 1
a2 1
/*	$OpenBSD: vmstat.c,v 1.13 1996/06/24 23:51:59 tholo Exp $	*/
d238 2
a239 1
	if (nlistf != NULL || memf != NULL)
d241 1
@


1.13
log
@struct intrhand protected by _KERNEL; some user-mode assembly code
can't deal with the file without this
@
text
@d2 1
a2 1
/*	$OpenBSD: vmstat.c,v 1.12 1996/06/22 17:38:14 tholo Exp $	*/
d440 1
a440 1
		halfuptime = (uptime + 1) / 2;
@


1.12
log
@Restore code to show interrupt counts on i386
@
text
@d2 1
a2 1
/*	$OpenBSD$	*/
d727 1
d729 1
@


1.11
log
@boottime is a timeval
@
text
@d2 1
d110 2
d113 1
a113 1
#define	X_DEFICIT	15
a114 2
#define	X_FORKSTAT	16
	{ "_forkstat" },
d123 1
a123 1
#define X_END		15
d137 6
a172 1
#ifdef notdef
a174 1
#endif
a198 1
#ifndef notdef
a201 1
#endif
a216 1
#ifndef notdef
a219 1
#endif
a290 1
#ifdef notdef
a292 1
#endif
a296 1
#ifdef notdef
a298 1
#endif
a488 1
#ifdef notdef
d494 4
d500 1
d502 3
a504 3
	(void)printf("%u reclaims, %u total time (usec)\n",
	    sum.v_pgrec, rectime);
	(void)printf("average: %u usec / reclaim\n", rectime / sum.v_pgrec);
d507 1
a507 1
	    sum.v_pgin, pgintime / 10);
d509 1
a509 1
	    pgintime / (sum.v_pgin * 10.0));
a510 1
#endif
d598 1
a598 1
	    "%9s cache hits (%d%% pos + %d%% neg) system %d%% per-process\n",
a633 1
#ifdef notdef
d643 3
a645 1
	    fks.cntvfork, fks.sizvfork, (double)fks.sizvfork / fks.cntvfork);
a646 1
#endif
d724 39
@


1.10
log
@libutil
@
text
@d1 1
a1 1
/*	$NetBSD: vmstat.c,v 1.29 1996/05/10 23:19:32 thorpej Exp $	*/
d46 1
a46 1
static char rcsid[] = "$NetBSD: vmstat.c,v 1.29 1996/05/10 23:19:32 thorpej Exp $";
d349 2
a350 1
	static time_t now, boottime;
d353 1
a353 1
	if (boottime == 0)
d356 1
a356 1
	uptime = now - boottime;
@


1.9
log
@sync to netbsd 960418
@
text
@d1 1
a1 2
/*	$OpenBSD: vmstat.c,v 1.6 1996/03/03 02:51:24 tholo Exp $	*/
/*	$NetBSD: vmstat.c,v 1.28 1996/04/04 00:27:50 cgd Exp $	*/
d46 1
a46 1
static char rcsid[] = "$NetBSD: vmstat.c,v 1.28 1996/04/04 00:27:50 cgd Exp $";
a108 2
#define	X_FORKSTAT	15
	{ "_forkstat" },
d110 1
a110 1
#define	X_DEFICIT	16
d112 2
d122 1
a122 9
#define X_END		16
#endif
#if defined(hp300) || defined(luna68k)
#define	X_HPDINIT	(X_END)
	{ "_hp_dinit" },
#endif
#ifdef mips
#define	X_SCSI_DINIT	(X_END)
	{ "_scsi_dinit" },
a135 6
#if defined(i386)
#define	X_INTRHAND	(X_END)
	{ "_intrhand" },
#define	X_INTRSTRAY	(X_END+1)
	{ "_intrstray" },
#endif
d141 2
a142 2
extern char		**dr_name;
extern int		*dk_select, dk_ndrive;
d158 12
a169 3
void	cpustats(), dkstats(), dointr(), domem(), dosum();
void	dovmstat(), kread(), usage();
void	dotimes(), doforkst();
d171 4
a174 2
char *nlistf = NULL;
char *memf = NULL;
a184 1
	char *memf, *nlistf;
d194 1
d198 1
d214 1
d218 1
a263 1
		char **choosedrives();
d290 1
d293 1
d298 1
d301 1
d491 1
a496 4
#ifdef NEWVM
	pgintime = 0;
	rectime = 0;
#else
a498 1
#endif
d500 3
a502 3
	(void)printf("%u reactivates, %u total time (usec)\n",
	    sum.v_reactivated, rectime);
	(void)printf("average: %u usec / reclaim\n", rectime / sum.v_reactivated);
d505 1
a505 1
	    sum.v_pageins, pgintime / 10);
d507 1
a507 1
	    pgintime / (sum.v_pageins * 10.0));
d509 1
d597 1
a597 1
	    "%9s cache hits (%d%% pos + %d%% neg) system %d%% per-directory\n",
d633 1
d643 1
a643 3
	    fks.cntvfork, fks.sizvfork, (double)fks.sizvfork / (fks.cntvfork ? fks.cntvfork : 1));
	(void)printf("%d rforks, %d pages, average %.2f\n",
	    fks.cntrfork, fks.sizrfork, (double)fks.sizrfork / (fks.cntrfork ? fks.cntrfork : 1));
d645 1
a722 41
}
#elif defined(i386)
/* To get struct intrhand */
#define _KERNEL
#include <i386/isa/isa_machdep.h>
#undef _KERNEL
void
dointr()
{
	struct intrhand *intrhand[16], *ihp, ih;
	u_long inttotal, uptime;
	u_long intrstray[16];
	char iname[17];
	int i;

	iname[16] = '\0';
	uptime = getuptime();
	kread(X_INTRHAND, intrhand, sizeof(intrhand));
	kread(X_INTRSTRAY, intrstray, sizeof(intrstray));

	(void)printf("interrupt           total     rate\n");
	inttotal = 0;
	for (i = 0; i < 16; i++) {
		ihp = intrhand[i];
		while (ihp) {
			if (kvm_read(kd, (u_long)ihp, &ih, sizeof(ih)) != sizeof(ih))
				errx(1, "vmstat: ih: %s", kvm_geterr(kd));
			if (kvm_read(kd, (u_long)ih.ih_what, iname, 16) != 16)
				errx(1, "vmstat: ih_what: %s", kvm_geterr(kd));
			printf("%-16.16s %8lu %8lu\n", iname, ih.ih_count, ih.ih_count / uptime);
			inttotal += ih.ih_count;
			ihp = ih.ih_next;
		}
	}
	for (i = 0; i < 16; i++)
		if (intrstray[i]) {
			printf("Stray irq %-2d     %8ld %8ld\n",
			       i, intrstray[i], intrstray[i] / uptime);
			inttotal += intrstray[i];
		}
	printf("Total            %8lu %8lu\n", inttotal, inttotal / uptime);
@


1.8
log
@Fix format strings in printfs.
Sync w/ recent kernel changes.
@
text
@a0 1
/*	$NetBSD: vmstat.c,v 1.27 1995/10/10 01:17:35 cgd Exp $	*/
d2 1
d47 1
a47 1
static char rcsid[] = "$NetBSD: vmstat.c,v 1.27 1995/10/10 01:17:35 cgd Exp $";
d773 2
a774 1
	struct evcnt evcnt, *allevents;
d800 3
a802 2
	while (allevents) {
		if (kvm_read(kd, (long)allevents, (void *)&evcnt,
d820 1
a820 1
		allevents = evcnt.ev_next;
@


1.7
log
@Fixed according to the latest i386 changes.
@
text
@d149 1
a149 1
	{ "_isa_strayintr" },
d734 2
a735 2
	long inttotal, uptime;
	int intrstray[16];
d753 1
a753 1
			printf("%-16.16s %8ld %8ld\n", iname, ih.ih_count, ih.ih_count / uptime);
d764 1
a764 1
	printf("Total            %8ld %8ld\n", inttotal, inttotal / uptime);
@


1.6
log
@Working disk statistics; NetBSD PR 2160
@
text
@d2 1
a2 1
/*	$OpenBSD: vmstat.c,v 1.5 1996/03/01 07:35:40 tholo Exp $	*/
d149 1
a149 1
	{ "_intrstray" },
d728 1
a728 1
#include <machine/psl.h>
@


1.5
log
@Secondary name cache is per-directory now, not per-process.
@
text
@d2 1
a2 1
/*	$OpenBSD$	*/
d76 1
d154 4
a157 4
struct _disk {
	long time[CPUSTATES];
	long *xfer;
} cur, last;
d160 1
a160 2
char	**dr_name;
int	*dr_select, dk_ndrive, ndrives;
a172 2
#include "names.c"			/* disk names -- machine dependent */

d177 3
a198 1
#ifndef notdef
a201 1
#endif
d265 1
a265 1
		char **getdrivedata();
d268 2
a269 1
		argv = getdrivedata(argv);
d308 1
a308 1
getdrivedata(argv)
a314 19
	kread(X_DK_NDRIVE, &dk_ndrive, sizeof(dk_ndrive));
	if (dk_ndrive <= 0) {
		(void)fprintf(stderr, "vmstat: dk_ndrive %d\n", dk_ndrive);
		exit(1);
	}
	dr_select = calloc((size_t)dk_ndrive, sizeof(int));
	dr_name = calloc((size_t)dk_ndrive, sizeof(char *));
	for (i = 0; i < dk_ndrive; i++)
		dr_name[i] = NULL;
	cur.xfer = calloc((size_t)dk_ndrive, sizeof(long));
	last.xfer = calloc((size_t)dk_ndrive, sizeof(long));
	if (!read_names())
		exit (1);
	for (i = 0; i < dk_ndrive; i++)
		if (dr_name[i] == NULL) {
			(void)sprintf(buf, "??%d", i);
			dr_name[i] = strdup(buf);
		}

d330 1
a330 1
			dr_select[i] = 1;
d336 1
a336 11
		if (dr_select[i])
			continue;
		for (cp = defdrives; *cp; cp++)
			if (strcmp(dr_name[i], *cp) == 0) {
				dr_select[i] = 1;
				++ndrives;
				break;
			}
	}
	for (i = 0; i < dk_ndrive && ndrives < 4; i++) {
		if (dr_select[i])
d338 1
a338 1
		dr_select[i] = 1;
d387 2
a388 2
		kread(X_CPTIME, cur.time, sizeof(cur.time));
		kread(X_DKXFER, cur.xfer, sizeof(*cur.xfer) * dk_ndrive);
d399 1
a399 1
#define pgtok(a) ((a) * sum.v_page_size >> 10)
d450 8
a457 3
	if (ndrives > 1)
		(void)printf("disks %*s  faults      cpu\n",
		   ndrives * 3 - 6, "");
d459 2
a460 3
		(void)printf("%*s  faults      cpu\n", ndrives * 3, "");
#ifndef NEWVM
	(void)printf(" r b w   avm   fre  re at  pi  po  fr  de  sr ");
d462 5
d468 2
d472 1
a472 1
		if (dr_select[i])
d655 2
a656 5
	for (dn = 0; dn < dk_ndrive; ++dn) {
		tmp = cur.xfer[dn];
		cur.xfer[dn] -= last.xfer[dn];
		last.xfer[dn] = tmp;
	}
d659 1
a659 4
		tmp = cur.time[state];
		cur.time[state] -= last.time[state];
		last.time[state] = tmp;
		etime += cur.time[state];
d665 1
a665 1
		if (!dr_select[dn])
d667 1
a667 1
		(void)printf("%2.0f ", cur.xfer[dn] / etime);
d679 1
a679 1
		total += cur.time[state];
d684 3
a686 3
	(void)printf("%2.0f ", (cur.time[CP_USER] + cur.time[CP_NICE]) * pct);
	(void)printf("%2.0f ", (cur.time[CP_SYS] + cur.time[CP_INTR]) * pct);
	(void)printf("%2.0f", cur.time[CP_IDLE] * pct);
@


1.4
log
@Support getting interrupts per device on the i386 platform, similar to
implementation on pc532
@
text
@d2 1
d616 1
a616 1
	    "%9s cache hits (%d%% pos + %d%% neg) system %d%% per-process\n",
@


1.3
log
@column expansion from NetBSD
@
text
@d108 2
d111 1
a111 1
#define	X_DEFICIT	15
a112 2
#define	X_FORKSTAT	16
	{ "_forkstat" },
d121 1
a121 1
#define X_END		15
d143 6
a175 1
#ifdef notdef
a176 1
#endif
a216 1
#ifndef notdef
a219 1
#endif
a290 1
#ifdef notdef
a292 1
#endif
a296 1
#ifdef notdef
a298 1
#endif
a505 1
#ifdef notdef
d511 4
d517 1
d519 3
a521 3
	(void)printf("%u reclaims, %u total time (usec)\n",
	    sum.v_pgrec, rectime);
	(void)printf("average: %u usec / reclaim\n", rectime / sum.v_pgrec);
d524 1
a524 1
	    sum.v_pgin, pgintime / 10);
d526 1
a526 1
	    pgintime / (sum.v_pgin * 10.0));
a527 1
#endif
a650 1
#ifdef notdef
d660 3
a662 1
	    fks.cntvfork, fks.sizvfork, (double)fks.sizvfork / fks.cntvfork);
a663 1
#endif
d747 41
@


1.2
log
@irq count field widened
@
text
@d743 1
a743 1
		(void)printf("Total        %10ld %8ld\n",
@


1.1
log
@Initial revision
@
text
@d743 1
a743 1
		(void)printf("Total        %8ld %8ld\n",
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@
