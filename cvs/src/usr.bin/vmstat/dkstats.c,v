head	1.39;
access;
symbols
	OPENBSD_6_1:1.39.0.2
	OPENBSD_6_1_BASE:1.39
	OPENBSD_6_0:1.38.0.4
	OPENBSD_6_0_BASE:1.38
	OPENBSD_5_9:1.38.0.2
	OPENBSD_5_9_BASE:1.38
	OPENBSD_5_8:1.37.0.6
	OPENBSD_5_8_BASE:1.37
	OPENBSD_5_7:1.37.0.2
	OPENBSD_5_7_BASE:1.37
	OPENBSD_5_6:1.35.0.18
	OPENBSD_5_6_BASE:1.35
	OPENBSD_5_5:1.35.0.16
	OPENBSD_5_5_BASE:1.35
	OPENBSD_5_4:1.35.0.12
	OPENBSD_5_4_BASE:1.35
	OPENBSD_5_3:1.35.0.10
	OPENBSD_5_3_BASE:1.35
	OPENBSD_5_2:1.35.0.8
	OPENBSD_5_2_BASE:1.35
	OPENBSD_5_1_BASE:1.35
	OPENBSD_5_1:1.35.0.6
	OPENBSD_5_0:1.35.0.4
	OPENBSD_5_0_BASE:1.35
	OPENBSD_4_9:1.35.0.2
	OPENBSD_4_9_BASE:1.35
	OPENBSD_4_8:1.34.0.2
	OPENBSD_4_8_BASE:1.34
	OPENBSD_4_7:1.33.0.8
	OPENBSD_4_7_BASE:1.33
	OPENBSD_4_6:1.33.0.10
	OPENBSD_4_6_BASE:1.33
	OPENBSD_4_5:1.33.0.6
	OPENBSD_4_5_BASE:1.33
	OPENBSD_4_4:1.33.0.4
	OPENBSD_4_4_BASE:1.33
	OPENBSD_4_3:1.33.0.2
	OPENBSD_4_3_BASE:1.33
	OPENBSD_4_2:1.30.0.6
	OPENBSD_4_2_BASE:1.30
	OPENBSD_4_1:1.30.0.4
	OPENBSD_4_1_BASE:1.30
	OPENBSD_4_0:1.30.0.2
	OPENBSD_4_0_BASE:1.30
	OPENBSD_3_9:1.27.0.2
	OPENBSD_3_9_BASE:1.27
	OPENBSD_3_8:1.26.0.2
	OPENBSD_3_8_BASE:1.26
	OPENBSD_3_7:1.25.0.4
	OPENBSD_3_7_BASE:1.25
	OPENBSD_3_6:1.25.0.2
	OPENBSD_3_6_BASE:1.25
	OPENBSD_3_5:1.24.0.2
	OPENBSD_3_5_BASE:1.24
	OPENBSD_3_4:1.23.0.2
	OPENBSD_3_4_BASE:1.23
	OPENBSD_3_3:1.22.0.2
	OPENBSD_3_3_BASE:1.22
	OPENBSD_3_2:1.21.0.2
	OPENBSD_3_2_BASE:1.21
	OPENBSD_3_1:1.15.0.2
	OPENBSD_3_1_BASE:1.15
	OPENBSD_3_0:1.14.0.2
	OPENBSD_3_0_BASE:1.14
	OPENBSD_2_9_BASE:1.9
	OPENBSD_2_9:1.9.0.2
	OPENBSD_2_8:1.8.0.2
	OPENBSD_2_8_BASE:1.8
	OPENBSD_2_7:1.6.0.4
	OPENBSD_2_7_BASE:1.6
	OPENBSD_2_6:1.6.0.2
	OPENBSD_2_6_BASE:1.6
	OPENBSD_2_5:1.5.0.8
	OPENBSD_2_5_BASE:1.5
	OPENBSD_2_4:1.5.0.6
	OPENBSD_2_4_BASE:1.5
	OPENBSD_2_3:1.5.0.4
	OPENBSD_2_3_BASE:1.5
	OPENBSD_2_2:1.5.0.2
	OPENBSD_2_2_BASE:1.5
	OPENBSD_2_1:1.4.0.2
	OPENBSD_2_1_BASE:1.4
	OPENBSD_2_0:1.3.0.2
	OPENBSD_2_0_BASE:1.3;
locks; strict;
comment	@ * @;


1.39
date	2016.09.04.14.21.05;	author tb;	state Exp;
branches;
next	1.38;
commitid	JS5AEKsX0b3aPyfH;

1.38
date	2015.12.24.03.25.08;	author mmcc;	state Exp;
branches;
next	1.37;
commitid	OWtyoadomW7Iu1Ji;

1.37
date	2015.01.16.06.40.14;	author deraadt;	state Exp;
branches;
next	1.36;
commitid	Uu5nFG3wCl0LACBb;

1.36
date	2014.09.15.19.08.22;	author miod;	state Exp;
branches;
next	1.35;
commitid	uuiU9j2I8AUx0fez;

1.35
date	2010.09.24.00.11.15;	author deraadt;	state Exp;
branches;
next	1.34;

1.34
date	2010.07.20.19.43.19;	author lum;	state Exp;
branches;
next	1.33;

1.33
date	2007.11.26.09.28.34;	author martynas;	state Exp;
branches;
next	1.32;

1.32
date	2007.10.24.20.15.43;	author chl;	state Exp;
branches;
next	1.31;

1.31
date	2007.10.23.07.35.58;	author chl;	state Exp;
branches;
next	1.30;

1.30
date	2006.03.31.18.19.38;	author deraadt;	state Exp;
branches;
next	1.29;

1.29
date	2006.03.31.04.06.13;	author deraadt;	state Exp;
branches;
next	1.28;

1.28
date	2006.03.13.19.29.26;	author otto;	state Exp;
branches;
next	1.27;

1.27
date	2005.10.17.19.04.20;	author otto;	state Exp;
branches;
next	1.26;

1.26
date	2005.07.04.01.54.10;	author djm;	state Exp;
branches;
next	1.25;

1.25
date	2004.04.22.22.28.37;	author millert;	state Exp;
branches;
next	1.24;

1.24
date	2004.02.15.02.45.47;	author tedu;	state Exp;
branches;
next	1.23;

1.23
date	2003.06.18.04.13.10;	author millert;	state Exp;
branches;
next	1.22;

1.22
date	2002.12.16.01.57.04;	author tdeval;	state Exp;
branches;
next	1.21;

1.21
date	2002.09.17.19.37.40;	author deraadt;	state Exp;
branches;
next	1.20;

1.20
date	2002.08.04.00.51.01;	author deraadt;	state Exp;
branches;
next	1.19;

1.19
date	2002.06.28.22.40.53;	author deraadt;	state Exp;
branches;
next	1.18;

1.18
date	2002.06.19.08.45.52;	author deraadt;	state Exp;
branches;
next	1.17;

1.17
date	2002.06.08.02.33.32;	author drahn;	state Exp;
branches;
next	1.16;

1.16
date	2002.05.23.10.35.07;	author deraadt;	state Exp;
branches;
next	1.15;

1.15
date	2002.02.16.21.27.58;	author millert;	state Exp;
branches;
next	1.14;

1.14
date	2001.07.21.09.21.56;	author deraadt;	state Exp;
branches;
next	1.13;

1.13
date	2001.06.03.03.31.30;	author angelos;	state Exp;
branches;
next	1.12;

1.12
date	2001.05.14.07.40.39;	author angelos;	state Exp;
branches;
next	1.11;

1.11
date	2001.05.14.07.24.12;	author angelos;	state Exp;
branches;
next	1.10;

1.10
date	2001.05.14.07.20.50;	author angelos;	state Exp;
branches;
next	1.9;

1.9
date	2001.01.02.20.09.02;	author deraadt;	state Exp;
branches;
next	1.8;

1.8
date	2000.10.03.03.12.16;	author aaron;	state Exp;
branches;
next	1.7;

1.7
date	2000.06.30.16.00.22;	author millert;	state Exp;
branches;
next	1.6;

1.6
date	99.06.21.20.48.01;	author art;	state Exp;
branches
	1.6.4.1;
next	1.5;

1.5
date	97.06.23.22.11.07;	author millert;	state Exp;
branches;
next	1.4;

1.4
date	97.02.04.04.51.20;	author kstailey;	state Exp;
branches;
next	1.3;

1.3
date	96.06.26.05.42.40;	author deraadt;	state Exp;
branches;
next	1.2;

1.2
date	96.05.22.11.35.42;	author deraadt;	state Exp;
branches;
next	1.1;

1.1
date	96.03.03.02.51.20;	author tholo;	state Exp;
branches;
next	;

1.6.4.1
date	2000.10.06.21.16.17;	author jason;	state Exp;
branches;
next	;


desc
@@


1.39
log
@straightforward realloc -> reallocarray conversion

ok deraadt, guenther, tedu
@
text
@/*	$OpenBSD: dkstats.c,v 1.38 2015/12/24 03:25:08 mmcc Exp $	*/
/*	$NetBSD: dkstats.c,v 1.1 1996/05/10 23:19:27 thorpej Exp $	*/

/*
 * Copyright (c) 1996 John M. Vinopal
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *      This product includes software developed for the NetBSD Project
 *      by John M. Vinopal.
 * 4. The name of the author may not be used to endorse or promote products
 *    derived from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
 * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
 * BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED
 * AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */

#include <sys/time.h>
#include <sys/disk.h>
#include <sys/sched.h>
#include <sys/sysctl.h>
#include <sys/tty.h>

#include <err.h>
#include <fcntl.h>
#include <kvm.h>
#include <limits.h>
#include <nlist.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include "dkstats.h"

#if !defined(NOKVM)
static struct nlist namelist[] = {
#define	X_TK_NIN	0		/* sysctl */
	{ "_tk_nin" },
#define	X_TK_NOUT	1		/* sysctl */
	{ "_tk_nout" },
#define	X_CP_TIME	2		/* sysctl */
	{ "_cp_time" },
#define	X_HZ		3		/* sysctl */
	{ "_hz" },
#define	X_STATHZ	4		/* sysctl */
	{ "_stathz" },
#define X_DISK_COUNT	5		/* sysctl */
	{ "_disk_count" },
#define X_DISKLIST	6		/* sysctl */
	{ "_disklist" },
	{ NULL },
};
#define	KVM_ERROR(_string) {						\
	warnx("%s", (_string));						\
	errx(1, "%s", kvm_geterr(kd));					\
}

/*
 * Dereference the namelist pointer `v' and fill in the local copy
 * 'p' which is of size 's'.
 */
#define deref_nl(v, p, s) deref_kptr((void *)namelist[(v)].n_value, (p), (s));
static void deref_kptr(void *, void *, size_t);
#endif /* !defined(NOKVM) */

/* Structures to hold the statistics. */
struct _disk	cur, last;

/* Kernel pointers: nlistf and memf defined in calling program. */
#if !defined(NOKVM)
extern kvm_t	*kd;
#endif
extern char	*nlistf;
extern char	*memf;

#if !defined(NOKVM)
/* Pointer to list of disks. */
static struct disk	*dk_drivehead = NULL;
#endif

/* Backward compatibility references. */
int		dk_ndrive = 0;
int		*dk_select;
char		**dr_name;

/* Missing from <sys/time.h> */
#define timerset(tvp, uvp) \
	((uvp)->tv_sec = (tvp)->tv_sec);		\
	((uvp)->tv_usec = (tvp)->tv_usec)

#define SWAP(fld)	tmp = cur.fld;				\
			cur.fld -= last.fld;			\
			last.fld = tmp

/*
 * Take the delta between the present values and the last recorded
 * values, storing the present values in the 'last' structure, and
 * the delta values in the 'cur' structure.
 */
void
dkswap(void)
{
	u_int64_t tmp;
	int	i;

	for (i = 0; i < cur.dk_ndrive; i++) {
		struct timeval	tmp_timer;

		if (!cur.dk_select[i])
			continue;

		/* Delta Values. */
		SWAP(dk_rxfer[i]);
		SWAP(dk_wxfer[i]);
		SWAP(dk_seek[i]);
		SWAP(dk_rbytes[i]);
		SWAP(dk_wbytes[i]);

		/* Delta Time. */
		timerclear(&tmp_timer);
		timerset(&(cur.dk_time[i]), &tmp_timer);
		timersub(&tmp_timer, &(last.dk_time[i]), &(cur.dk_time[i]));
		timerclear(&(last.dk_time[i]));
		timerset(&tmp_timer, &(last.dk_time[i]));
	}
	for (i = 0; i < CPUSTATES; i++) {
		long ltmp;

		ltmp = cur.cp_time[i];
		cur.cp_time[i] -= last.cp_time[i];
		last.cp_time[i] = ltmp;
	}
	SWAP(tk_nin);
	SWAP(tk_nout);

#undef SWAP
}

/*
 * Read the disk statistics for each disk in the disk list.
 * Also collect statistics for tty i/o and cpu ticks.
 */
void
dkreadstats(void)
{
#if !defined(NOKVM)
	struct disk	cur_disk, *p;
#endif
	int		i, j, mib[3];
	size_t		size;
	char		*disknames, *name, *bufpp, **dk_name;
	struct diskstats *q;

	last.dk_ndrive = cur.dk_ndrive;

	if (nlistf == NULL && memf == NULL) {
		/* Get the number of attached drives. */
		mib[0] = CTL_HW;
		mib[1] = HW_DISKCOUNT;
		size = sizeof(dk_ndrive);
		if (sysctl(mib, 2, &dk_ndrive, &size, NULL, 0) < 0 ) {
			warn("could not read hw.diskcount");
			dk_ndrive = 0;
		}

		if (cur.dk_ndrive != dk_ndrive) {
			/* Re-read the disk names. */
			dk_name = calloc((size_t)dk_ndrive, sizeof(char *));
			if (dk_name == NULL)
				err(1, NULL);
			mib[0] = CTL_HW;
			mib[1] = HW_DISKNAMES;
			size = 0;
			if (sysctl(mib, 2, NULL, &size, NULL, 0) < 0)
				err(1, "can't get hw.disknames");
			disknames = malloc(size);
			if (disknames == NULL)
				err(1, NULL);
			if (sysctl(mib, 2, disknames, &size, NULL, 0) < 0)
				err(1, "can't get hw.disknames");
			bufpp = disknames;
			for (i = 0; i < dk_ndrive &&
			    (name = strsep(&bufpp, ",")) != NULL; i++)
				dk_name[i] = name;
			for (i = 0; i < dk_ndrive; i++) {
				char *p = strchr(dk_name[i], ':');
				if (p)
					*p = '\0';
			}
			disknames = cur.dk_name[0];	/* To free old names. */

			if (dk_ndrive < cur.dk_ndrive) {
				for (i = 0, j = 0; i < dk_ndrive; i++, j++) {
					while (j < cur.dk_ndrive &&
					    strcmp(cur.dk_name[j], dk_name[i]))
						j++;
					if (i == j) continue;

					if (j >= cur.dk_ndrive) {
						cur.dk_select[i] = 1;
						last.dk_rxfer[i] = 0;
						last.dk_wxfer[i] = 0;
						last.dk_seek[i] = 0;
						last.dk_rbytes[i] = 0;
						last.dk_wbytes[i] = 0;
						memset(&last.dk_time[i], 0,
						    sizeof(struct timeval));
						continue;
					}

					cur.dk_select[i] = cur.dk_select[j];
					last.dk_rxfer[i] = last.dk_rxfer[j];
					last.dk_wxfer[i] = last.dk_wxfer[j];
					last.dk_seek[i] = last.dk_seek[j];
					last.dk_rbytes[i] = last.dk_rbytes[j];
					last.dk_wbytes[i] = last.dk_wbytes[j];
					last.dk_time[i] = last.dk_time[j];
				}

				cur.dk_select = reallocarray(cur.dk_select,
				    dk_ndrive, sizeof(*cur.dk_select));
				cur.dk_rxfer = reallocarray(cur.dk_rxfer,
				    dk_ndrive, sizeof(*cur.dk_rxfer));
				cur.dk_wxfer = reallocarray(cur.dk_wxfer,
				    dk_ndrive, sizeof(*cur.dk_wxfer));
				cur.dk_seek = reallocarray(cur.dk_seek,
				    dk_ndrive, sizeof(*cur.dk_seek));
				cur.dk_rbytes = reallocarray(cur.dk_rbytes,
				    dk_ndrive, sizeof(*cur.dk_rbytes));
				cur.dk_wbytes = reallocarray(cur.dk_wbytes,
				    dk_ndrive, sizeof(*cur.dk_wbytes));
				cur.dk_time = reallocarray(cur.dk_time,
				    dk_ndrive, sizeof(*cur.dk_time));
				last.dk_rxfer = reallocarray(last.dk_rxfer,
				    dk_ndrive, sizeof(*last.dk_rxfer));
				last.dk_wxfer = reallocarray(last.dk_wxfer,
				    dk_ndrive, sizeof(*last.dk_wxfer));
				last.dk_seek = reallocarray(last.dk_seek,
				    dk_ndrive, sizeof(*last.dk_seek));
				last.dk_rbytes = reallocarray(last.dk_rbytes,
				    dk_ndrive, sizeof(*last.dk_rbytes));
				last.dk_wbytes = reallocarray(last.dk_wbytes,
				    dk_ndrive, sizeof(*last.dk_wbytes));
				last.dk_time = reallocarray(last.dk_time,
				    dk_ndrive, sizeof(*last.dk_time));

				if (!cur.dk_select || !cur.dk_rxfer ||
				    !cur.dk_wxfer || !cur.dk_seek ||
				    !cur.dk_rbytes || !cur.dk_wbytes ||
				    !cur.dk_time || !last.dk_rxfer ||
				    !last.dk_wxfer || !last.dk_seek ||
				    !last.dk_rbytes || !last.dk_wbytes ||
				    !last.dk_time)
					errx(1, "Memory allocation failure.");
			} else {
				cur.dk_select = reallocarray(cur.dk_select,
				    dk_ndrive, sizeof(*cur.dk_select));
				cur.dk_rxfer = reallocarray(cur.dk_rxfer,
				    dk_ndrive, sizeof(*cur.dk_rxfer));
				cur.dk_wxfer = reallocarray(cur.dk_wxfer,
				    dk_ndrive, sizeof(*cur.dk_wxfer));
				cur.dk_seek = reallocarray(cur.dk_seek,
				    dk_ndrive, sizeof(*cur.dk_seek));
				cur.dk_rbytes = reallocarray(cur.dk_rbytes,
				    dk_ndrive, sizeof(*cur.dk_rbytes));
				cur.dk_wbytes = reallocarray(cur.dk_wbytes,
				    dk_ndrive, sizeof(*cur.dk_wbytes));
				cur.dk_time = reallocarray(cur.dk_time,
				    dk_ndrive, sizeof(*cur.dk_time));
				last.dk_rxfer = reallocarray(last.dk_rxfer,
				    dk_ndrive, sizeof(*last.dk_rxfer));
				last.dk_wxfer = reallocarray(last.dk_wxfer,
				    dk_ndrive, sizeof(*last.dk_wxfer));
				last.dk_seek = reallocarray(last.dk_seek,
				    dk_ndrive, sizeof(*last.dk_seek));
				last.dk_rbytes = reallocarray(last.dk_rbytes,
				    dk_ndrive, sizeof(*last.dk_rbytes));
				last.dk_wbytes = reallocarray(last.dk_wbytes,
				    dk_ndrive, sizeof(*last.dk_wbytes));
				last.dk_time = reallocarray(last.dk_time,
				    dk_ndrive, sizeof(*last.dk_time));

				if (!cur.dk_select || !cur.dk_rxfer ||
				    !cur.dk_wxfer || !cur.dk_seek ||
				    !cur.dk_rbytes || !cur.dk_wbytes ||
				    !cur.dk_time || !last.dk_rxfer ||
				    !last.dk_wxfer || !last.dk_seek ||
				    !last.dk_rbytes || !last.dk_wbytes ||
				    !last.dk_time)
					errx(1, "Memory allocation failure.");

				for (i = dk_ndrive - 1, j = cur.dk_ndrive - 1;
				     i >= 0; i--) {

					if (j < 0 ||
					    strcmp(cur.dk_name[j], dk_name[i]))
					{
						cur.dk_select[i] = 1;
						last.dk_rxfer[i] = 0;
						last.dk_wxfer[i] = 0;
						last.dk_seek[i] = 0;
						last.dk_rbytes[i] = 0;
						last.dk_wbytes[i] = 0;
						memset(&last.dk_time[i], 0,
						    sizeof(struct timeval));
						continue;
					}

					if (i > j) {
						cur.dk_select[i] =
						    cur.dk_select[j];
						last.dk_rxfer[i] =
						    last.dk_rxfer[j];
						last.dk_wxfer[i] =
						    last.dk_wxfer[j];
						last.dk_seek[i] =
						    last.dk_seek[j];
						last.dk_rbytes[i] =
						    last.dk_rbytes[j];
						last.dk_wbytes[i] =
						    last.dk_wbytes[j];
						last.dk_time[i] =
						    last.dk_time[j];
					}
					j--;
				}
			}

			cur.dk_ndrive = dk_ndrive;
			free(disknames);
			cur.dk_name = dk_name;
			dr_name = cur.dk_name;
			dk_select = cur.dk_select;
		}

		size = cur.dk_ndrive * sizeof(struct diskstats);
		mib[0] = CTL_HW;
		mib[1] = HW_DISKSTATS;
		q = malloc(size);
		if (q == NULL)
			err(1, NULL);
		if (sysctl(mib, 2, q, &size, NULL, 0) < 0) {
#ifdef	DEBUG
			warn("could not read hw.diskstats");
#endif	/* DEBUG */
			memset(q, 0, cur.dk_ndrive * sizeof(struct diskstats));
		}

		for (i = 0; i < cur.dk_ndrive; i++)	{
			cur.dk_rxfer[i] = q[i].ds_rxfer;
			cur.dk_wxfer[i] = q[i].ds_wxfer;
			cur.dk_seek[i] = q[i].ds_seek;
			cur.dk_rbytes[i] = q[i].ds_rbytes;
			cur.dk_wbytes[i] = q[i].ds_wbytes;
			timerset(&(q[i].ds_time), &(cur.dk_time[i]));
		}
		free(q);

		size = sizeof(cur.cp_time);
		mib[0] = CTL_KERN;
		mib[1] = KERN_CPTIME;
		if (sysctl(mib, 2, cur.cp_time, &size, NULL, 0) < 0) {
			warn("could not read kern.cp_time");
			memset(cur.cp_time, 0, sizeof(cur.cp_time));
		}
		size = sizeof(cur.tk_nin);
		mib[0] = CTL_KERN;
		mib[1] = KERN_TTY;
		mib[2] = KERN_TTY_TKNIN;
		if (sysctl(mib, 3, &cur.tk_nin, &size, NULL, 0) < 0) {
			warn("could not read kern.tty.tk_nin");
			cur.tk_nin = 0;
		}
		size = sizeof(cur.tk_nin);
		mib[0] = CTL_KERN;
		mib[1] = KERN_TTY;
		mib[2] = KERN_TTY_TKNOUT;
		if (sysctl(mib, 3, &cur.tk_nout, &size, NULL, 0) < 0) {
			warn("could not read kern.tty.tk_nout");
			cur.tk_nout = 0;
		}
	} else {
#if !defined(NOKVM)
		p = dk_drivehead;

		for (i = 0; i < cur.dk_ndrive; i++) {
			deref_kptr(p, &cur_disk, sizeof(cur_disk));
			cur.dk_rxfer[i] = cur_disk.dk_rxfer;
			cur.dk_wxfer[i] = cur_disk.dk_wxfer;
			cur.dk_seek[i] = cur_disk.dk_seek;
			cur.dk_rbytes[i] = cur_disk.dk_rbytes;
			cur.dk_wbytes[i] = cur_disk.dk_wbytes;
			timerset(&(cur_disk.dk_time), &(cur.dk_time[i]));
			p = TAILQ_NEXT(&cur_disk, dk_link);
		}
		deref_nl(X_CP_TIME, cur.cp_time, sizeof(cur.cp_time));
		deref_nl(X_TK_NIN, &cur.tk_nin, sizeof(cur.tk_nin));
		deref_nl(X_TK_NOUT, &cur.tk_nout, sizeof(cur.tk_nout));
#endif /* !defined(NOKVM) */
	}
}

/*
 * Perform all of the initialization and memory allocation needed to
 * track disk statistics.
 */
int
dkinit(int sel)
{
#if !defined(NOKVM)
	struct disklist_head disk_head;
	struct disk	cur_disk, *p;
        char		errbuf[_POSIX2_LINE_MAX];
#endif
	static int	once = 0;
	extern int	hz;
	int		i, mib[2];
	size_t		size;
	struct clockinfo clkinfo;
	char		*disknames, *name, *bufpp;

	if (once)
		return(1);

	if (nlistf != NULL || memf != NULL) {
#if !defined(NOKVM)
		/* Open the kernel. */
		if (kd == NULL &&
		    (kd = kvm_openfiles(nlistf, memf, NULL, O_RDONLY,
		    errbuf)) == NULL)
			errx(1, "kvm_openfiles: %s", errbuf);

		/* Obtain the namelist symbols from the kernel. */
		if (kvm_nlist(kd, namelist))
			KVM_ERROR("kvm_nlist failed to read symbols.");

		/* Get the number of attached drives. */
		deref_nl(X_DISK_COUNT, &cur.dk_ndrive, sizeof(cur.dk_ndrive));

		if (cur.dk_ndrive < 0)
			errx(1, "invalid _disk_count %d.", cur.dk_ndrive);

		/* Get a pointer to the first disk. */
		deref_nl(X_DISKLIST, &disk_head, sizeof(disk_head));
		dk_drivehead = TAILQ_FIRST(&disk_head);

		/* Get ticks per second. */
		deref_nl(X_STATHZ, &hz, sizeof(hz));
		if (!hz)
		  deref_nl(X_HZ, &hz, sizeof(hz));
#endif /* !defined(NOKVM) */
	} else {
		/* Get the number of attached drives. */
		mib[0] = CTL_HW;
		mib[1] = HW_DISKCOUNT;
		size = sizeof(cur.dk_ndrive);
		if (sysctl(mib, 2, &cur.dk_ndrive, &size, NULL, 0) < 0 ) {
			warn("could not read hw.diskcount");
			cur.dk_ndrive = 0;
		}

		/* Get ticks per second. */
		mib[0] = CTL_KERN;
		mib[1] = KERN_CLOCKRATE;
		size = sizeof(clkinfo);
		if (sysctl(mib, 2, &clkinfo, &size, NULL, 0) < 0) {
			warn("could not read kern.clockrate");
			hz = 0;
		} else
			hz = clkinfo.stathz;
	}

	/* allocate space for the statistics */
	cur.dk_time = calloc((size_t)cur.dk_ndrive, sizeof(struct timeval));
	cur.dk_rxfer = calloc((size_t)cur.dk_ndrive, sizeof(u_int64_t));
	cur.dk_wxfer = calloc((size_t)cur.dk_ndrive, sizeof(u_int64_t));
	cur.dk_seek = calloc((size_t)cur.dk_ndrive, sizeof(u_int64_t));
	cur.dk_rbytes = calloc((size_t)cur.dk_ndrive, sizeof(u_int64_t));
	cur.dk_wbytes = calloc((size_t)cur.dk_ndrive, sizeof(u_int64_t));
	cur.dk_select = calloc((size_t)cur.dk_ndrive, sizeof(int));
	cur.dk_name = calloc((size_t)cur.dk_ndrive, sizeof(char *));
	last.dk_time = calloc((size_t)cur.dk_ndrive, sizeof(struct timeval));
	last.dk_rxfer = calloc((size_t)cur.dk_ndrive, sizeof(u_int64_t));
	last.dk_wxfer = calloc((size_t)cur.dk_ndrive, sizeof(u_int64_t));
	last.dk_seek = calloc((size_t)cur.dk_ndrive, sizeof(u_int64_t));
	last.dk_rbytes = calloc((size_t)cur.dk_ndrive, sizeof(u_int64_t));
	last.dk_wbytes = calloc((size_t)cur.dk_ndrive, sizeof(u_int64_t));

	if (!cur.dk_time || !cur.dk_rxfer || !cur.dk_wxfer || !cur.dk_seek ||
	    !cur.dk_rbytes || !cur.dk_wbytes || !cur.dk_select ||
	    !cur.dk_name || !last.dk_time || !last.dk_rxfer ||
	    !last.dk_wxfer || !last.dk_seek || !last.dk_rbytes ||
	    !last.dk_wbytes)
		errx(1, "Memory allocation failure.");

	/* Set up the compatibility interfaces. */
	dk_ndrive = cur.dk_ndrive;
	dk_select = cur.dk_select;
	dr_name = cur.dk_name;

	/* Read the disk names and set initial selection. */
	if (nlistf == NULL && memf == NULL) {
		mib[0] = CTL_HW;
		mib[1] = HW_DISKNAMES;
		size = 0;
		if (sysctl(mib, 2, NULL, &size, NULL, 0) < 0)
			err(1, "can't get hw.disknames");
		disknames = malloc(size);
		if (disknames == NULL)
			err(1, NULL);
		if (sysctl(mib, 2, disknames, &size, NULL, 0) < 0)
			err(1, "can't get hw.disknames");
		bufpp = disknames;
		for (i = 0; i < dk_ndrive && (name = strsep(&bufpp, ",")) != NULL; i++) {
			cur.dk_name[i] = name;
			cur.dk_select[i] = sel;
		}
		for (i = 0; i < dk_ndrive; i++) {
			char *p = strchr(cur.dk_name[i], ':');
			if (p)
				*p = '\0';
		}
	} else {
#if !defined(NOKVM)
		p = dk_drivehead;
		for (i = 0; i < cur.dk_ndrive; i++) {
			char	buf[10];

			deref_kptr(p, &cur_disk, sizeof(cur_disk));
			deref_kptr(cur_disk.dk_name, buf, sizeof(buf));
			cur.dk_name[i] = strdup(buf);
			if (!cur.dk_name[i])
				errx(1, "Memory allocation failure.");
			cur.dk_select[i] = sel;

			p = TAILQ_NEXT(&cur_disk, dk_link);
		}
#endif /* !defined(NOKVM) */
	}

	/* Never do this initialization again. */
	once = 1;
	return(1);
}

#if !defined(NOKVM)
/*
 * Dereference the kernel pointer `kptr' and fill in the local copy
 * pointed to by `ptr'.  The storage space must be pre-allocated,
 * and the size of the copy passed in `len'.
 */
static void
deref_kptr(void *kptr, void *ptr, size_t len)
{
	char buf[128];

	if (kvm_read(kd, (u_long)kptr, ptr, len) != len) {
		memset(buf, 0, sizeof(buf));
		snprintf(buf, (sizeof(buf) - 1),
		     "can't dereference kptr 0x%lx", (u_long)kptr);
		KVM_ERROR(buf);
	}
}
#endif /* !defined(NOKVM) */
@


1.38
log
@Replace bzero with memset. No binary change.

ok tb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: dkstats.c,v 1.37 2015/01/16 06:40:14 deraadt Exp $	*/
d238 26
a263 26
				cur.dk_select = realloc(cur.dk_select,
				    dk_ndrive * sizeof(*cur.dk_select));
				cur.dk_rxfer = realloc(cur.dk_rxfer,
				    dk_ndrive * sizeof(*cur.dk_rxfer));
				cur.dk_wxfer = realloc(cur.dk_wxfer,
				    dk_ndrive * sizeof(*cur.dk_wxfer));
				cur.dk_seek = realloc(cur.dk_seek,
				    dk_ndrive * sizeof(*cur.dk_seek));
				cur.dk_rbytes = realloc(cur.dk_rbytes,
				    dk_ndrive * sizeof(*cur.dk_rbytes));
				cur.dk_wbytes = realloc(cur.dk_wbytes,
				    dk_ndrive * sizeof(*cur.dk_wbytes));
				cur.dk_time = realloc(cur.dk_time,
				    dk_ndrive * sizeof(*cur.dk_time));
				last.dk_rxfer = realloc(last.dk_rxfer,
				    dk_ndrive * sizeof(*last.dk_rxfer));
				last.dk_wxfer = realloc(last.dk_wxfer,
				    dk_ndrive * sizeof(*last.dk_wxfer));
				last.dk_seek = realloc(last.dk_seek,
				    dk_ndrive * sizeof(*last.dk_seek));
				last.dk_rbytes = realloc(last.dk_rbytes,
				    dk_ndrive * sizeof(*last.dk_rbytes));
				last.dk_wbytes = realloc(last.dk_wbytes,
				    dk_ndrive * sizeof(*last.dk_wbytes));
				last.dk_time = realloc(last.dk_time,
				    dk_ndrive * sizeof(*last.dk_time));
d274 26
a299 26
				cur.dk_select = realloc(cur.dk_select,
				    dk_ndrive * sizeof(*cur.dk_select));
				cur.dk_rxfer = realloc(cur.dk_rxfer,
				    dk_ndrive * sizeof(*cur.dk_rxfer));
				cur.dk_wxfer = realloc(cur.dk_wxfer,
				    dk_ndrive * sizeof(*cur.dk_wxfer));
				cur.dk_seek = realloc(cur.dk_seek,
				    dk_ndrive * sizeof(*cur.dk_seek));
				cur.dk_rbytes = realloc(cur.dk_rbytes,
				    dk_ndrive * sizeof(*cur.dk_rbytes));
				cur.dk_wbytes = realloc(cur.dk_wbytes,
				    dk_ndrive * sizeof(*cur.dk_wbytes));
				cur.dk_time = realloc(cur.dk_time,
				    dk_ndrive * sizeof(*cur.dk_time));
				last.dk_rxfer = realloc(last.dk_rxfer,
				    dk_ndrive * sizeof(*last.dk_rxfer));
				last.dk_wxfer = realloc(last.dk_wxfer,
				    dk_ndrive * sizeof(*last.dk_wxfer));
				last.dk_seek = realloc(last.dk_seek,
				    dk_ndrive * sizeof(*last.dk_seek));
				last.dk_rbytes = realloc(last.dk_rbytes,
				    dk_ndrive * sizeof(*last.dk_rbytes));
				last.dk_wbytes = realloc(last.dk_wbytes,
				    dk_ndrive * sizeof(*last.dk_wbytes));
				last.dk_time = realloc(last.dk_time,
				    dk_ndrive * sizeof(*last.dk_time));
@


1.37
log
@Replace <sys/param.h> with <limits.h> and other less dirty headers where
possible.  Annotate <sys/param.h> lines with their current reasons.  Switch
to PATH_MAX, NGROUPS_MAX, HOST_NAME_MAX+1, LOGIN_NAME_MAX, etc.  Change
MIN() and MAX() to local definitions of MINIMUM() and MAXIMUM() where
sensible to avoid pulling in the pollution.  These are the files confirmed
through binary verification.
ok guenther, millert, doug (helped with the verification protocol)
@
text
@d1 1
a1 1
/*	$OpenBSD: dkstats.c,v 1.36 2014/09/15 19:08:22 miod Exp $	*/
d224 1
a224 1
						bzero(&last.dk_time[i],
d322 1
a322 1
						bzero(&last.dk_time[i],
d364 1
a364 1
			bzero(q, cur.dk_ndrive * sizeof(struct diskstats));
d382 1
a382 1
			bzero(cur.cp_time, sizeof(cur.cp_time));
d576 1
a576 1
		bzero(buf, sizeof(buf));
@


1.36
log
@Remove non-standard <sys/dkstat.h> header. It has not contained anything
related to disk stastics for almost 17 years, and the remaining
userland-visible defines duplicate those found in <sys/sched.h>.

Move the remaining _KERNEL defines to <sys/tty.h> where they belong, and
update all users to cope with this.

ok kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: dkstats.c,v 1.35 2010/09/24 00:11:15 deraadt Exp $	*/
a35 1
#include <sys/param.h>
@


1.35
log
@Now that HW_DISKNAMES returns xx0: or xx0:uid entries, we must truncate
the : and uid components out -- otherwise these two programs will work
poorly.
@
text
@d1 1
a1 1
/*	$OpenBSD: dkstats.c,v 1.34 2010/07/20 19:43:19 lum Exp $	*/
a36 1
#include <sys/dkstat.h>
d39 1
@


1.34
log
@Remove setresguid since it is no longer needed.
ok matthew@@ millert@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: dkstats.c,v 1.33 2007/11/26 09:28:34 martynas Exp $	*/
d201 2
a202 1
			for (i = 0; i < dk_ndrive && (name = strsep(&bufpp, ",")) != NULL; i++)
d204 5
d536 5
@


1.33
log
@typos;  ok jmc@@
sys/netinet/in_pcb.c and sys/net/bridgestp.c ok henning@@
sys/dev/pci/bktr/* ok jakemsr@@
@
text
@d1 1
a1 1
/*	$OpenBSD: dkstats.c,v 1.32 2007/10/24 20:15:43 chl Exp $	*/
a433 1
	gid_t		gid;
a437 1
	gid = getgid();
a439 4
		if (memf != NULL)
			if (setresgid(gid, gid, gid) == -1)
				err(1, "setresgid");

a444 4

		if (memf == NULL)
			if (setresgid(gid, gid, gid) == -1)
				err(1, "setresgid");
@


1.32
log
@add missing checks against NULL after realloc calls

Ok gilles@@ moritz@@
@
text
@d1 1
a1 1
/*	$OpenBSD: dkstats.c,v 1.31 2007/10/23 07:35:58 chl Exp $	*/
d559 1
a559 1
	/* Never do this initalization again. */
@


1.31
log
@add missing checks against NULL on last.dk_rbytes and last.dk_wbytes
reorder operations to make it easier to read and check

From Igor Zinovik <zinovik@@cs.karelia.ru>

"looks ok" otto@@ "looks correct" ray@@ ok gilles@@ "looks fine" moritz@@
@
text
@d1 1
a1 1
/*	$OpenBSD: dkstats.c,v 1.30 2006/03/31 18:19:38 deraadt Exp $	*/
d259 9
d295 9
@


1.30
log
@spacing
@
text
@d1 1
a1 1
/*	$OpenBSD: dkstats.c,v 1.29 2006/03/31 04:06:13 deraadt Exp $	*/
d485 2
a492 2
	cur.dk_select = calloc((size_t)cur.dk_ndrive, sizeof(int));
	cur.dk_name = calloc((size_t)cur.dk_ndrive, sizeof(char *));
d495 4
a498 3
	    !cur.dk_rbytes || !cur.dk_wbytes || !last.dk_time ||
	    !last.dk_rxfer || !last.dk_wxfer || !last.dk_seek ||
	    !cur.dk_select || !cur.dk_name)
@


1.29
log
@lint-driven cleanup.  nothing too scary in this diff.
@
text
@d1 1
a1 1
/*	$OpenBSD: dkstats.c,v 1.28 2006/03/13 19:29:26 otto Exp $	*/
d78 1
a78 1
 * Dereference the namelist pointer `v' and fill in the local copy 
d101 1
a101 1
int	  	dk_ndrive = 0;
d159 1
a159 1
 * Read the disk statistics for each disk in the disk list. 
d354 1
a354 1
	 	size = sizeof(cur.cp_time);
d493 1
a493 1
	
d547 1
a547 1
 * Dereference the kernel pointer `kptr' and fill in the local copy 
@


1.28
log
@delint; from David Hill
@
text
@d1 1
a1 1
/*	$OpenBSD: dkstats.c,v 1.27 2005/10/17 19:04:20 otto Exp $	*/
d146 5
a150 1
		SWAP(cp_time[i]);
d187 1
a187 1
			dk_name = calloc(dk_ndrive, sizeof(char *));
d479 14
a492 14
	cur.dk_time = calloc(cur.dk_ndrive, sizeof(struct timeval));
	cur.dk_rxfer = calloc(cur.dk_ndrive, sizeof(u_int64_t));
	cur.dk_wxfer = calloc(cur.dk_ndrive, sizeof(u_int64_t));
	cur.dk_seek = calloc(cur.dk_ndrive, sizeof(u_int64_t));
	cur.dk_rbytes = calloc(cur.dk_ndrive, sizeof(u_int64_t));
	cur.dk_wbytes = calloc(cur.dk_ndrive, sizeof(u_int64_t));
	last.dk_time = calloc(cur.dk_ndrive, sizeof(struct timeval));
	last.dk_rxfer = calloc(cur.dk_ndrive, sizeof(u_int64_t));
	last.dk_wxfer = calloc(cur.dk_ndrive, sizeof(u_int64_t));
	last.dk_seek = calloc(cur.dk_ndrive, sizeof(u_int64_t));
	last.dk_rbytes = calloc(cur.dk_ndrive, sizeof(u_int64_t));
	last.dk_wbytes = calloc(cur.dk_ndrive, sizeof(u_int64_t));
	cur.dk_select = calloc(cur.dk_ndrive, sizeof(int));
	cur.dk_name = calloc(cur.dk_ndrive, sizeof(char *));
@


1.27
log
@Use queue macros instead of directly accessing fields. ok pat@@ "put it
in" deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: dkstats.c,v 1.26 2005/07/04 01:54:10 djm Exp $	*/
d399 1
a399 1
dkinit(int select)
d516 1
a516 1
			cur.dk_select[i] = select;
d529 1
a529 1
			cur.dk_select[i] = select;
@


1.26
log
@make these use setres[ug]id for simple privilege dropping;
ok deraadt@@ millert@@ moritz@@
@
text
@d1 1
a1 1
/*	$OpenBSD: dkstats.c,v 1.25 2004/04/22 22:28:37 millert Exp $	*/
d385 1
a385 1
			p = cur_disk.dk_link.tqe_next;
d446 1
a446 1
		dk_drivehead = disk_head.tqh_first;
d531 1
a531 1
			p = cur_disk.dk_link.tqe_next;
@


1.25
log
@Fix pasto in realloc portion of dkreadstats; from Pedro Martelletto
OK drahn@@
@
text
@d1 1
a1 1
/*	$OpenBSD: dkstats.c,v 1.24 2004/02/15 02:45:47 tedu Exp $	*/
d412 1
d417 1
d420 3
a422 4
		if (memf != NULL) {
			setegid(getgid());
			setgid(getgid());
		}
d430 3
a432 2
		setegid(getgid());
		setgid(getgid());
@


1.24
log
@new arg to disk_unbusy, to record separate read/write statistics.
looked at by various, testing henning@@ mcbride@@ dan weeks
mostly from netbsd via Pedro Martelletto <pbastos@@rdc.puc-rio.br>
@
text
@d1 1
a1 1
/*	$OpenBSD: dkstats.c,v 1.23 2003/06/18 04:13:10 millert Exp $	*/
d245 2
a246 2
				last.dk_wxfer = realloc(last.dk_rxfer,
				    dk_ndrive * sizeof(*last.dk_rxfer));
@


1.23
log
@Add missing check for i < dk_ndrive in 2 loops; closes PR 3322
@
text
@d1 1
a1 1
/*	$OpenBSD: dkstats.c,v 1.22 2002/12/16 01:57:04 tdeval Exp $	*/
d132 2
a133 1
		SWAP(dk_xfer[i]);
d135 2
a136 1
		SWAP(dk_bytes[i]);
d210 2
a211 1
						last.dk_xfer[i] = 0;
d213 2
a214 1
						last.dk_bytes[i] = 0;
d221 2
a222 1
					last.dk_xfer[i] = last.dk_xfer[j];
d224 2
a225 1
					last.dk_bytes[i] = last.dk_bytes[j];
d231 4
a234 2
				cur.dk_xfer = realloc(cur.dk_xfer,
				    dk_ndrive * sizeof(*cur.dk_xfer));
d237 4
a240 2
				cur.dk_bytes = realloc(cur.dk_bytes,
				    dk_ndrive * sizeof(*cur.dk_bytes));
d243 4
a246 2
				last.dk_xfer = realloc(last.dk_xfer,
				    dk_ndrive * sizeof(*last.dk_xfer));
d249 4
a252 2
				last.dk_bytes = realloc(last.dk_bytes,
				    dk_ndrive * sizeof(*last.dk_bytes));
d258 4
a261 2
				cur.dk_xfer = realloc(cur.dk_xfer,
				    dk_ndrive * sizeof(*cur.dk_xfer));
d264 4
a267 2
				cur.dk_bytes = realloc(cur.dk_bytes,
				    dk_ndrive * sizeof(*cur.dk_bytes));
d270 4
a273 2
				last.dk_xfer = realloc(last.dk_xfer,
				    dk_ndrive * sizeof(*last.dk_xfer));
d276 4
a279 2
				last.dk_bytes = realloc(last.dk_bytes,
				    dk_ndrive * sizeof(*last.dk_bytes));
d290 2
a291 1
						last.dk_xfer[i] = 0;
d293 2
a294 1
						last.dk_bytes[i] = 0;
d303 4
a306 2
						last.dk_xfer[i] =
						    last.dk_xfer[j];
d309 4
a312 2
						last.dk_bytes[i] =
						    last.dk_bytes[j];
d341 2
a342 1
			cur.dk_xfer[i] = q[i].ds_xfer;
d344 2
a345 1
			cur.dk_bytes[i] = q[i].ds_bytes;
d379 2
a380 1
			cur.dk_xfer[i] = cur_disk.dk_xfer;
d382 2
a383 1
			cur.dk_bytes[i] = cur_disk.dk_bytes;
d474 2
a475 1
	cur.dk_xfer = calloc(cur.dk_ndrive, sizeof(u_int64_t));
d477 2
a478 1
	cur.dk_bytes = calloc(cur.dk_ndrive, sizeof(u_int64_t));
d480 2
a481 1
	last.dk_xfer = calloc(cur.dk_ndrive, sizeof(u_int64_t));
d483 2
a484 1
	last.dk_bytes = calloc(cur.dk_ndrive, sizeof(u_int64_t));
d488 4
a491 3
	if (!cur.dk_time || !cur.dk_xfer || !cur.dk_seek || !cur.dk_bytes ||
	    !last.dk_time || !last.dk_xfer || !last.dk_seek ||
	    !last.dk_bytes || !cur.dk_select || !cur.dk_name)
@


1.22
log
@Make systat(1), iostat(8) and vmstat(8) automatically update their disk
statistics when a device is added/removed.  ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: dkstats.c,v 1.21 2002/09/17 19:37:40 deraadt Exp $	*/
d195 2
a196 4
			i = 0;
			while ((name = strsep(&bufpp, ",")) != NULL) {
			    dk_name[i++] = name;
			}
d475 3
a477 4
		i = 0;
		while ((name = strsep(&bufpp, ",")) != NULL) {
		    cur.dk_name[i] = name;
		    cur.dk_select[i++] = select;
@


1.21
log
@ansi
@
text
@d1 1
a1 1
/*	$OpenBSD: dkstats.c,v 1.20 2002/08/04 00:51:01 deraadt Exp $	*/
d125 1
a125 1
	for (i = 0; i < dk_ndrive; i++) {
d162 1
a162 1
	int		i, mib[3];
d164 1
d167 2
d170 132
a301 1
		size = dk_ndrive * sizeof(struct diskstats);
d308 1
d310 2
a311 1
			bzero(q, dk_ndrive * sizeof(struct diskstats));
d314 1
a314 1
		for (i = 0; i < dk_ndrive; i++)	{
d349 1
a349 1
		for (i = 0; i < dk_ndrive; i++) {
d407 1
a407 1
		deref_nl(X_DISK_COUNT, &dk_ndrive, sizeof(dk_ndrive));
d409 2
a410 2
		if (dk_ndrive < 0)
			errx(1, "invalid _disk_count %d.", dk_ndrive);
d425 2
a426 2
		size = sizeof(dk_ndrive);
		if (sysctl(mib, 2, &dk_ndrive, &size, NULL, 0) < 0 ) {
d428 1
a428 1
			dk_ndrive = 0;
d443 10
a452 10
	cur.dk_time = calloc(dk_ndrive, sizeof(struct timeval));
	cur.dk_xfer = calloc(dk_ndrive, sizeof(u_int64_t));
	cur.dk_seek = calloc(dk_ndrive, sizeof(u_int64_t));
	cur.dk_bytes = calloc(dk_ndrive, sizeof(u_int64_t));
	last.dk_time = calloc(dk_ndrive, sizeof(struct timeval));
	last.dk_xfer = calloc(dk_ndrive, sizeof(u_int64_t));
	last.dk_seek = calloc(dk_ndrive, sizeof(u_int64_t));
	last.dk_bytes = calloc(dk_ndrive, sizeof(u_int64_t));
	cur.dk_select = calloc(dk_ndrive, sizeof(int));
	cur.dk_name = calloc(dk_ndrive, sizeof(char *));
d460 1
d464 1
a464 1
	/* Read the disk names and set intial selection. */
d485 1
a485 1
		for (i = 0; i < dk_ndrive; i++) {
@


1.20
log
@only open kvm once between these two
@
text
@d1 1
a1 1
/*	$OpenBSD: dkstats.c,v 1.19 2002/06/28 22:40:53 deraadt Exp $	*/
d120 1
a120 1
dkswap()
d157 1
a157 1
dkreadstats()
d233 1
a233 2
dkinit(select)
int	select;
d375 1
a375 3
deref_kptr(kptr, ptr, len)
	void *kptr, *ptr;
	size_t len;
@


1.19
log
@wrap NOKVM variables too
@
text
@d1 1
a1 1
/*	$OpenBSD: dkstats.c,v 1.18 2002/06/19 08:45:52 deraadt Exp $	*/
d90 1
a90 1
static kvm_t	*kd = NULL;
d253 5
d259 2
a260 1
		if ((kd = kvm_openfiles(nlistf, memf, NULL, O_RDONLY,
d263 3
@


1.18
log
@mark which nlist[] kmem entries are not needed in the sysctl case, and which are
@
text
@d1 1
a1 1
/*	$OpenBSD: dkstats.c,v 1.17 2002/06/08 02:33:32 drahn Exp $	*/
d89 1
d91 1
d95 1
d98 1
d159 1
d161 1
d236 1
d240 1
@


1.17
log
@Missing newline at end of file. from krause
@
text
@d1 1
a1 1
/*	$OpenBSD: dkstats.c,v 1.16 2002/05/23 10:35:07 deraadt Exp $	*/
d56 9
a64 9
#define	X_TK_NIN	0
	{ "_tk_nin" },		/* tty characters in */
#define	X_TK_NOUT	1
	{ "_tk_nout" },		/* tty characters out */
#define	X_CP_TIME	2
	{ "_cp_time" },		/* system timer ticks */
#define	X_HZ		3
	{ "_hz" },		/* ticks per second */
#define	X_STATHZ	4
d66 4
a69 4
#define X_DISK_COUNT	5
	{ "_disk_count" },	/* number of disks */
#define X_DISKLIST	6
	{ "_disklist" },	/* TAILQ of disks */
@


1.16
log
@if NOKVM is defined, do not do the KVM stuff at all
@
text
@d1 1
a1 1
/*	$OpenBSD: dkstats.c,v 1.15 2002/02/16 21:27:58 millert Exp $	*/
d372 1
a372 1
#endif /* !defined(NOKVM) */@


1.15
log
@Part one of userland __P removal.  Done with a simple regexp with some minor hand editing to make comments line up correctly.  Another pass is forthcoming that handles the cases that could not be done automatically.
@
text
@d1 1
a1 1
/*	$OpenBSD: dkstats.c,v 1.14 2001/07/21 09:21:56 deraadt Exp $	*/
d54 1
d72 12
a100 11
#define	KVM_ERROR(_string) {						\
	warnx("%s", (_string));						\
	errx(1, "%s", kvm_geterr(kd));					\
}

/*
 * Dereference the namelist pointer `v' and fill in the local copy 
 * 'p' which is of size 's'.
 */
#define deref_nl(v, p, s) deref_kptr((void *)namelist[(v)].n_value, (p), (s));

d102 7
a108 4
#define timerset(tvp, uvp) ((uvp)->tv_sec = (tvp)->tv_sec);		\
			   ((uvp)->tv_usec = (tvp)->tv_usec)

static void deref_kptr(void *, void *, size_t);
a117 3
#define SWAP(fld)		tmp = cur.fld;				\
				cur.fld -= last.fld;			\
				last.fld = tmp
d204 1
a214 1

d218 1
d244 1
d268 1
d330 1
d334 1
d344 1
d352 1
d372 1
@


1.14
log
@plug mem leak; zero right amount of mem
@
text
@d1 1
a1 1
/*	$OpenBSD: dkstats.c,v 1.13 2001/06/03 03:31:30 angelos Exp $	*/
d103 1
a103 1
static void deref_kptr __P((void *, void *, size_t));
@


1.13
log
@Read struct diskstats from the kernel.
@
text
@d1 1
a1 1
/*	$OpenBSD: dkstats.c,v 1.12 2001/05/14 07:40:39 angelos Exp $	*/
d167 1
a167 1
			bzero(q, dk_ndrive * sizeof(struct disk));
d176 1
@


1.12
log
@No need to use calloc gratuitously.
@
text
@d1 1
a1 1
/*	$OpenBSD: dkstats.c,v 1.11 2001/05/14 07:24:12 angelos Exp $	*/
d156 1
d159 1
a159 1
		size = dk_ndrive * sizeof(struct disk);
d162 2
a163 2
		p = malloc(size);
		if (p == NULL)
d165 1
a165 1
		if (sysctl(mib, 2, p, &size, NULL, 0) < 0) {
d167 1
a167 1
			bzero(p, dk_ndrive * sizeof(struct disk));
d171 4
a174 4
			cur.dk_xfer[i] = p[i].dk_xfer;
			cur.dk_seek[i] = p[i].dk_seek;
			cur.dk_bytes[i] = p[i].dk_bytes;
			timerset(&(p[i].dk_time), &(cur.dk_time[i]));
@


1.11
log
@Use warn() consistently.
@
text
@d1 1
a1 1
/*	$OpenBSD: dkstats.c,v 1.10 2001/05/14 07:20:50 angelos Exp $	*/
d161 1
a161 1
		p = calloc(size, sizeof(char));
d311 1
a311 1
		disknames = calloc(size, sizeof(char));
@


1.10
log
@Use the sysctl-based diskstats for live kernels. deraadt@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: dkstats.c,v 1.9 2001/01/02 20:09:02 deraadt Exp $	*/
d180 1
a180 1
			warnx("could not read kern.cp_time");
d188 1
a188 1
			warnx("could not read kern.tty.tk_nin");
d196 1
a196 1
			warnx("could not read kern.tty.tk_nout");
d268 1
a268 1
			warnx("could not read hw.diskcount");
d277 1
a277 1
			warnx("could not read kern.clockrate");
@


1.9
log
@check for another allocation failure
@
text
@d1 1
a1 1
/*	$OpenBSD: dkstats.c,v 1.8 2000/10/03 03:12:16 aaron Exp $	*/
d36 1
d40 2
d154 2
a155 1
	int		i;
d157 57
a213 9
	p = dk_drivehead;

	for (i = 0; i < dk_ndrive; i++) {
		deref_kptr(p, &cur_disk, sizeof(cur_disk));
		cur.dk_xfer[i] = cur_disk.dk_xfer;
		cur.dk_seek[i] = cur_disk.dk_seek;
		cur.dk_bytes[i] = cur_disk.dk_bytes;
		timerset(&(cur_disk.dk_time), &(cur.dk_time[i]));
		p = cur_disk.dk_link.tqe_next;
a214 3
	deref_nl(X_CP_TIME, cur.cp_time, sizeof(cur.cp_time));
	deref_nl(X_TK_NIN, &cur.tk_nin, sizeof(cur.tk_nin));
	deref_nl(X_TK_NOUT, &cur.tk_nout, sizeof(cur.tk_nout));
d230 4
a233 1
	int		i;
d238 16
a253 14
	/* Open the kernel. */
        if ((kd = kvm_openfiles(nlistf, memf, NULL, O_RDONLY, errbuf)) == NULL)
		errx(1, "kvm_openfiles: %s", errbuf);

	/* Obtain the namelist symbols from the kernel. */
	if (kvm_nlist(kd, namelist))
		KVM_ERROR("kvm_nlist failed to read symbols.");

	/* Get the number of attached drives. */
	deref_nl(X_DISK_COUNT, &dk_ndrive, sizeof(dk_ndrive));

	if (dk_ndrive < 0)
		errx(1, "invalid _disk_count %d.", dk_ndrive);
	else {
d257 24
a282 5
	/* Get ticks per second. */
	deref_nl(X_STATHZ, &hz, sizeof(hz));
	if (!hz)
		deref_nl(X_HZ, &hz, sizeof(hz));

d305 27
a331 9
	p = dk_drivehead;
	for (i = 0; i < dk_ndrive; i++) {
		char	buf[10];
		deref_kptr(p, &cur_disk, sizeof(cur_disk));
		deref_kptr(cur_disk.dk_name, buf, sizeof(buf));
		cur.dk_name[i] = strdup(buf);
		if (!cur.dk_name[i])
			errx(1, "Memory allocation failure.");
		cur.dk_select[i] = select;
d333 2
a334 1
		p = cur_disk.dk_link.tqe_next;
@


1.8
log
@More format string paranoia; deraadt@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: dkstats.c,v 1.7 2000/06/30 16:00:22 millert Exp $	*/
d222 3
a224 3
	if (!cur.dk_time || !cur.dk_xfer || !cur.dk_seek || !cur.dk_bytes
	    || !last.dk_time || !last.dk_xfer || !last.dk_seek || !last.dk_bytes
	    || !cur.dk_select || !cur.dk_name)
d238 2
@


1.7
log
@warnx?/errx? paranoia (use "%s" not a bare string unless it is a
constant).  These are not security holes but it is worth fixing
them anyway both for robustness and so folks looking for examples
in the tree are not misled into doing something potentially dangerous.
Furthermore, it is a bad idea to assume that pathnames will not
include '%' in them and that error routines don't return strings
with '%' in them (especially in light of the possibility of locales).
@
text
@d1 1
a1 1
/*	$OpenBSD: dkstats.c,v 1.6 1999/06/21 20:48:01 art Exp $	*/
d86 1
a86 1
	warnx((_string));						\
@


1.6
log
@stop casting the third argument to kvm_read to char *. it is a void *.
@
text
@d1 1
a1 1
/*	$OpenBSD: dkstats.c,v 1.5 1997/06/23 22:11:07 millert Exp $	*/
d87 1
a87 1
	errx(1, kvm_geterr(kd));					\
@


1.6.4.1
log
@Pull in patch from current (even more to come):
Fix (millert):
warnx?/errx? paranoia (use "%s" not a bare string unless it is a
constant).  These are not security holes but it is worth fixing
them anyway both for robustness and so folks looking for examples
in the tree are not misled into doing something potentially dangerous.
Furthermore, it is a bad idea to assume that pathnames will not
include '%' in them and that error routines don't return strings
with '%' in them (especially in light of the possibility of locales).
@
text
@d1 1
a1 1
/*	$OpenBSD: dkstats.c,v 1.7 2000/06/30 16:00:22 millert Exp $	*/
d87 1
a87 1
	errx(1, "%s", kvm_geterr(kd));					\
@


1.5
log
@Move prototypes into dkstats.h so systat can get at them.
@
text
@d1 1
a1 1
/*	$OpenBSD: dkstats.c,v 1.4 1997/02/04 04:51:20 kstailey Exp $	*/
d260 1
a260 1
	if (kvm_read(kd, (u_long)kptr, (char *)ptr, len) != len) {
@


1.4
log
@deleted warnx() about "no drives attached" since dkinit() is used in curses apps like systat
@
text
@d1 1
a1 1
/*	$OpenBSD: dkstats.c,v 1.1 1996/05/10 23:19:27 thorpej Exp $	*/
a99 3
void dkswap __P((void));
void dkreadstats __P((void));
int dkinit __P((int));
@


1.3
log
@rcsid
@
text
@a201 3
	else if (dk_ndrive == 0) {
		warnx("No drives attached.");
	}
@


1.2
log
@libutil
@
text
@d1 1
@


1.1
log
@Working disk statistics; NetBSD PR 2160
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d4 1
a4 1
 * Copyright (c) 1996 John M. Vinopal (banshee@@resort.com)
d102 1
a102 1
static void deref_kptr __P(( void *, void *, size_t));
d268 1
a268 1
		     "can't dereference kptr 0x%x", (uint)kptr);
@
