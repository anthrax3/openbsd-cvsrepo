head	1.90;
access;
symbols
	OPENBSD_6_2_BASE:1.90
	OPENBSD_6_1:1.87.0.4
	OPENBSD_6_1_BASE:1.87
	OPENBSD_6_0:1.86.0.4
	OPENBSD_6_0_BASE:1.86
	OPENBSD_5_9:1.86.0.2
	OPENBSD_5_9_BASE:1.86
	OPENBSD_5_8:1.85.0.6
	OPENBSD_5_8_BASE:1.85
	OPENBSD_5_7:1.85.0.2
	OPENBSD_5_7_BASE:1.85
	OPENBSD_5_6:1.82.0.4
	OPENBSD_5_6_BASE:1.82
	OPENBSD_5_5:1.80.0.6
	OPENBSD_5_5_BASE:1.80
	OPENBSD_5_4:1.80.0.2
	OPENBSD_5_4_BASE:1.80
	OPENBSD_5_3:1.77.0.2
	OPENBSD_5_3_BASE:1.77
	OPENBSD_5_2:1.72.0.2
	OPENBSD_5_2_BASE:1.72
	OPENBSD_5_1_BASE:1.70
	OPENBSD_5_1:1.70.0.2
	OPENBSD_5_0:1.69.0.2
	OPENBSD_5_0_BASE:1.69
	OPENBSD_4_9:1.27.0.2
	OPENBSD_4_9_BASE:1.27
	OPENBSD_4_8:1.24.0.6
	OPENBSD_4_8_BASE:1.24
	OPENBSD_4_7:1.24.0.2
	OPENBSD_4_7_BASE:1.24
	OPENBSD_4_6:1.24.0.4
	OPENBSD_4_6_BASE:1.24
	OPENBSD_4_5:1.23.0.2
	OPENBSD_4_5_BASE:1.23
	OPENBSD_4_4:1.20.0.8
	OPENBSD_4_4_BASE:1.20
	OPENBSD_4_3:1.20.0.6
	OPENBSD_4_3_BASE:1.20
	OPENBSD_4_2:1.20.0.4
	OPENBSD_4_2_BASE:1.20
	OPENBSD_4_1:1.20.0.2
	OPENBSD_4_1_BASE:1.20;
locks; strict;
comment	@# @;


1.90
date	2017.08.26.09.03.51;	author jsg;	state Exp;
branches;
next	1.89;
commitid	GPpQ4XG7O80RkIZF;

1.89
date	2017.08.15.01.29.23;	author jasper;	state Exp;
branches;
next	1.88;
commitid	qYijFIR6dwq83NoK;

1.88
date	2017.08.15.00.26.09;	author jasper;	state Exp;
branches;
next	1.87;
commitid	5jnpBFgqeWeQ5xTH;

1.87
date	2016.08.07.08.59.25;	author tb;	state Exp;
branches;
next	1.86;
commitid	GeFwgeisGuVDktlM;

1.86
date	2015.10.11.11.48.46;	author jasper;	state Exp;
branches;
next	1.85;
commitid	XdYhfMkpj1pddPR4;

1.85
date	2014.11.17.22.16.23;	author jca;	state Exp;
branches;
next	1.84;
commitid	BWFdrvt6KQZIgKPR;

1.84
date	2014.11.02.13.28.50;	author jasper;	state Exp;
branches;
next	1.83;
commitid	N7pc1i8KYoByoLBd;

1.83
date	2014.11.02.01.11.47;	author jca;	state Exp;
branches;
next	1.82;
commitid	hwGksrMlOTZb3YK9;

1.82
date	2014.07.10.08.20.13;	author jasper;	state Exp;
branches;
next	1.81;
commitid	TzkcJ73dc7p7OK98;

1.81
date	2014.07.09.23.03.51;	author jasper;	state Exp;
branches;
next	1.80;
commitid	TCn3JBzw7txshu1p;

1.80
date	2013.05.30.00.02.02;	author jasper;	state Exp;
branches;
next	1.79;

1.79
date	2013.03.31.13.58.01;	author brad;	state Exp;
branches;
next	1.78;

1.78
date	2013.03.28.22.00.02;	author jasper;	state Exp;
branches;
next	1.77;

1.77
date	2012.12.10.10.12.12;	author jasper;	state Exp;
branches;
next	1.76;

1.76
date	2012.12.08.18.50.05;	author jasper;	state Exp;
branches;
next	1.75;

1.75
date	2012.10.09.10.22.37;	author jasper;	state Exp;
branches;
next	1.74;

1.74
date	2012.10.09.09.58.59;	author jasper;	state Exp;
branches;
next	1.73;

1.73
date	2012.07.28.08.50.06;	author jasper;	state Exp;
branches;
next	1.72;

1.72
date	2012.07.04.08.44.07;	author espie;	state Exp;
branches;
next	1.71;

1.71
date	2012.03.19.10.25.17;	author ajacoutot;	state Exp;
branches;
next	1.70;

1.70
date	2011.11.17.11.37.16;	author jasper;	state Exp;
branches;
next	1.69;

1.69
date	2011.07.08.18.57.41;	author jasper;	state Exp;
branches;
next	1.68;

1.68
date	2011.06.20.12.11.27;	author jasper;	state Exp;
branches;
next	1.67;

1.67
date	2011.06.20.12.10.17;	author jasper;	state Exp;
branches;
next	1.66;

1.66
date	2011.06.16.08.38.30;	author jasper;	state Exp;
branches;
next	1.65;

1.65
date	2011.06.16.08.33.54;	author jasper;	state Exp;
branches;
next	1.64;

1.64
date	2011.06.15.11.54.03;	author jasper;	state Exp;
branches;
next	1.63;

1.63
date	2011.06.12.21.33.49;	author jasper;	state Exp;
branches;
next	1.62;

1.62
date	2011.06.12.18.16.25;	author jasper;	state Exp;
branches;
next	1.61;

1.61
date	2011.06.12.17.13.17;	author jasper;	state Exp;
branches;
next	1.60;

1.60
date	2011.06.12.17.11.01;	author jasper;	state Exp;
branches;
next	1.59;

1.59
date	2011.06.12.17.08.44;	author jasper;	state Exp;
branches;
next	1.58;

1.58
date	2011.06.11.12.09.06;	author jasper;	state Exp;
branches;
next	1.57;

1.57
date	2011.06.09.12.32.30;	author jasper;	state Exp;
branches;
next	1.56;

1.56
date	2011.06.09.12.28.03;	author jasper;	state Exp;
branches;
next	1.55;

1.55
date	2011.06.09.10.43.28;	author jasper;	state Exp;
branches;
next	1.54;

1.54
date	2011.06.07.18.42.30;	author jasper;	state Exp;
branches;
next	1.53;

1.53
date	2011.06.07.12.22.46;	author jasper;	state Exp;
branches;
next	1.52;

1.52
date	2011.06.07.06.42.19;	author jasper;	state Exp;
branches;
next	1.51;

1.51
date	2011.06.06.17.49.37;	author jasper;	state Exp;
branches;
next	1.50;

1.50
date	2011.06.06.17.10.43;	author jasper;	state Exp;
branches;
next	1.49;

1.49
date	2011.06.06.12.32.17;	author jasper;	state Exp;
branches;
next	1.48;

1.48
date	2011.06.06.11.18.55;	author jasper;	state Exp;
branches;
next	1.47;

1.47
date	2011.06.06.11.16.59;	author jasper;	state Exp;
branches;
next	1.46;

1.46
date	2011.06.06.07.57.07;	author jasper;	state Exp;
branches;
next	1.45;

1.45
date	2011.06.02.12.46.03;	author sthen;	state Exp;
branches;
next	1.44;

1.44
date	2011.05.25.12.16.34;	author jasper;	state Exp;
branches;
next	1.43;

1.43
date	2011.05.18.11.12.13;	author jasper;	state Exp;
branches;
next	1.42;

1.42
date	2011.03.21.13.28.06;	author espie;	state Exp;
branches;
next	1.41;

1.41
date	2011.03.18.18.21.40;	author jasper;	state Exp;
branches;
next	1.40;

1.40
date	2011.03.18.15.26.11;	author jasper;	state Exp;
branches;
next	1.39;

1.39
date	2011.03.18.15.20.22;	author jasper;	state Exp;
branches;
next	1.38;

1.38
date	2011.03.18.15.18.13;	author jasper;	state Exp;
branches;
next	1.37;

1.37
date	2011.03.18.15.14.59;	author jasper;	state Exp;
branches;
next	1.36;

1.36
date	2011.03.18.15.13.33;	author jasper;	state Exp;
branches;
next	1.35;

1.35
date	2011.03.18.14.55.32;	author espie;	state Exp;
branches;
next	1.34;

1.34
date	2011.03.14.08.43.59;	author jasper;	state Exp;
branches;
next	1.33;

1.33
date	2011.03.14.08.40.13;	author jasper;	state Exp;
branches;
next	1.32;

1.32
date	2011.03.14.08.35.08;	author jasper;	state Exp;
branches;
next	1.31;

1.31
date	2011.03.10.19.15.55;	author jasper;	state Exp;
branches;
next	1.30;

1.30
date	2011.03.10.19.13.14;	author jasper;	state Exp;
branches;
next	1.29;

1.29
date	2011.03.10.19.06.30;	author jasper;	state Exp;
branches;
next	1.28;

1.28
date	2011.03.07.22.21.50;	author jasper;	state Exp;
branches;
next	1.27;

1.27
date	2010.12.28.14.31.38;	author jasper;	state Exp;
branches;
next	1.26;

1.26
date	2010.09.29.16.48.41;	author jasper;	state Exp;
branches;
next	1.25;

1.25
date	2010.09.18.09.27.51;	author sthen;	state Exp;
branches;
next	1.24;

1.24
date	2009.06.21.21.30.46;	author ckuethe;	state Exp;
branches;
next	1.23;

1.23
date	2008.10.26.23.56.37;	author jasper;	state Exp;
branches;
next	1.22;

1.22
date	2008.09.06.10.49.28;	author simon;	state Exp;
branches;
next	1.21;

1.21
date	2008.08.21.21.57.45;	author simon;	state Exp;
branches;
next	1.20;

1.20
date	2007.02.01.16.38.21;	author espie;	state Exp;
branches;
next	1.19;

1.19
date	2006.12.16.17.14.34;	author espie;	state Exp;
branches;
next	1.18;

1.18
date	2006.12.16.11.14.24;	author espie;	state Exp;
branches;
next	1.17;

1.17
date	2006.12.14.22.45.21;	author espie;	state Exp;
branches;
next	1.16;

1.16
date	2006.12.14.10.23.34;	author espie;	state Exp;
branches;
next	1.15;

1.15
date	2006.12.10.10.58.41;	author espie;	state Exp;
branches;
next	1.14;

1.14
date	2006.12.09.17.16.06;	author espie;	state Exp;
branches;
next	1.13;

1.13
date	2006.12.04.22.05.41;	author espie;	state Exp;
branches;
next	1.12;

1.12
date	2006.12.02.18.58.46;	author espie;	state Exp;
branches;
next	1.11;

1.11
date	2006.12.02.18.28.22;	author espie;	state Exp;
branches;
next	1.10;

1.10
date	2006.12.01.19.32.31;	author espie;	state Exp;
branches;
next	1.9;

1.9
date	2006.11.28.03.30.28;	author ckuethe;	state Exp;
branches;
next	1.8;

1.8
date	2006.11.28.01.59.42;	author ckuethe;	state Exp;
branches;
next	1.7;

1.7
date	2006.11.28.01.54.14;	author ckuethe;	state Exp;
branches;
next	1.6;

1.6
date	2006.11.28.01.36.17;	author ckuethe;	state Exp;
branches;
next	1.5;

1.5
date	2006.11.27.23.57.51;	author ckuethe;	state Exp;
branches;
next	1.4;

1.4
date	2006.11.27.23.52.18;	author espie;	state Exp;
branches;
next	1.3;

1.3
date	2006.11.27.22.50.31;	author ckuethe;	state Exp;
branches;
next	1.2;

1.2
date	2006.11.27.16.57.27;	author ckuethe;	state Exp;
branches;
next	1.1;

1.1
date	2006.11.27.16.49.13;	author ckuethe;	state Exp;
branches;
next	;


desc
@@


1.90
log
@Don't remove subpaths of /usr/include or /usr/lib from the output of
--cflags and --libs.

ok jasper@@
@
text
@#!/usr/bin/perl
# $OpenBSD: pkg-config,v 1.89 2017/08/15 01:29:23 jasper Exp $
# $CSK: pkgconfig.pl,v 1.39 2006/11/27 16:26:20 ckuethe Exp $

# Copyright (c) 2006 Chris Kuethe <ckuethe@@openbsd.org>
# Copyright (c) 2011 Jasper Lievisse Adriaanse <jasper@@openbsd.org>
#
# Permission to use, copy, modify, and distribute this software for any
# purpose with or without fee is hereby granted, provided that the above
# copyright notice and this permission notice appear in all copies.
#
# THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
# WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
# MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
# ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
# WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
# ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
# OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.

use strict;
use warnings;
use Config;
use Getopt::Long;
use File::Basename;
use File::stat;
use OpenBSD::PkgConfig;

my @@PKGPATH = qw(/usr/lib/pkgconfig
		 /usr/local/lib/pkgconfig
		 /usr/local/share/pkgconfig
		 /usr/X11R6/lib/pkgconfig
		 /usr/X11R6/share/pkgconfig);

if (defined($ENV{PKG_CONFIG_LIBDIR}) && $ENV{PKG_CONFIG_LIBDIR}) {
	@@PKGPATH = split(/:/, $ENV{PKG_CONFIG_LIBDIR});
} elsif (defined($ENV{PKG_CONFIG_PATH}) && $ENV{PKG_CONFIG_PATH}) {
	unshift(@@PKGPATH, split(/:/, $ENV{PKG_CONFIG_PATH}));
}

my $logfile = '';
if (defined($ENV{PKG_CONFIG_LOG}) && $ENV{PKG_CONFIG_LOG}) {
	$logfile = $ENV{PKG_CONFIG_LOG};
}

my $allow_uninstalled =
	defined $ENV{PKG_CONFIG_DISABLE_UNINSTALLED} ? 0 : 1;
my $found_uninstalled = 0;

my $version = '0.27.1'; # pretend to be this version of pkgconfig

my %configs = ();
setup_self();

my %mode = ();
my $variables = {};

$variables->{pc_top_builddir} = $ENV{PKG_CONFIG_TOP_BUILD_DIR} //
	'$(top_builddir)';

$variables->{pc_sysrootdir} //= $ENV{PKG_CONFIG_SYSROOT_DIR};
# The default '/' is implied.

defined $ENV{PKG_CONFIG_DEBUG_SPEW} ? $mode{debug} = 1 : $mode{debug} = 0;

if ($logfile) {
	open my $L, ">>" , $logfile or die;
	print $L beautify_list($0, @@ARGV), "\n";
	close $L;
}

# combo arg-parsing and dependency resolution loop. Hopefully when the loop
# terminates, we have a full list of packages upon which we depend, and the
# right set of compiler and linker flags to use them.
#
# as each .pc file is loaded, it is stored in %configs, indexed by package
# name. this makes it possible to then pull out flags or do substitutions
# without having to go back and reload the files from disk.

Getopt::Long::Configure('no_ignore_case');
GetOptions(	'debug' 		=> \$mode{debug},
		'help' 			=> \&help, #does not return
		'usage' 		=> \&help, #does not return
		'list-all' 		=> \$mode{list},
		'version' 		=> sub { print "$version\n" ; exit(0);} ,
		'errors-to-stdout' 	=> sub { $mode{estdout} = 1},
		'print-errors' 		=> sub { $mode{printerr} = 1},
		'silence-errors' 	=> sub { $mode{printerr} = 0},
		'short-errors' 		=> sub { $mode{printerr} = 0},
		'atleast-pkgconfig-version=s' => \$mode{myminvers},
		'print-provides' 	=> \$mode{printprovides},
		'print-requires' 	=> \$mode{printrequires},
		'print-requires-private' => \$mode{printrequiresprivate},

		'cflags'		=> sub { $mode{cflags} = 3},
		'cflags-only-I'		=> sub { $mode{cflags} |= 1},
		'cflags-only-other'	=> sub { $mode{cflags} |= 2},
		'libs'			=> sub { $mode{libs} = 7},
		'libs-only-l'		=> sub { $mode{libs} |= 1},
		'libs-only-L' 		=> sub { $mode{libs} |= 2},
		'libs-only-other' 	=> sub { $mode{libs} |= 4},
		'exists' 		=> sub { $mode{exists} = 1} ,
		'static' 		=> sub { $mode{static} = 1},
		'uninstalled' 		=> sub { $mode{uninstalled} = 1},
		'atleast-version=s' 	=> \$mode{minversion},
		'exact-version=s' 	=> \$mode{exactversion},
		'max-version=s' 	=> \$mode{maxversion},
		'modversion' 		=> \$mode{modversion},
		'variable=s' 		=> \$mode{variable},
		'define-variable=s' 	=> $variables,
	);

# Unconditionally switch to static mode on static arches as --static
# may not have been passed explicitly, but we don't want to re-order
# and simplify the libs like we do for shared architectures.
{
	my @@static_archs = qw();
	my $machine_arch = $Config{'ARCH'};
	if (grep { $_ eq $machine_arch } @@static_archs){
		$mode{static} = 1;
	}
}

# Initial value of printerr depends on the options...
if (!defined $mode{printerr}) {
	if (defined $mode{libs}
	    or defined $mode{cflags}
	    or defined $mode{version}
	    or defined $mode{list}) {
		$mode{printerr} = 1;
	} else {
		$mode{printerr} = 0;
	}
}

say_debug("\n" . beautify_list($0, @@ARGV));

my $rc = 0;

# XXX pkg-config is a bit weird
{
my $p = join(' ', @@ARGV);
$p =~ s/^\s+//;
@@ARGV = split(/\,?\s+/, $p);
}

if ($mode{myminvers}) {
	exit self_version($mode{myminvers});
}

if ($mode{list}) {
	exit do_list();
}

my $cfg_full_list = [];
my $top_config = [];

# When we got here we're supposed to have had at least one
# package as argument.
if (!@@ARGV){
	say_error("No package name(s) specified.");
	exit 1;
}

# Return the next module from @@ARGV, if it turns out to be a comma separated
# module list, take the first one and put the rest back to the front.
sub get_next_module {
	my $module = shift @@ARGV;
	my $m;
	if ($module =~ m/,/) {
	    	my @@ms = split(/,/, $module);
		$m = shift @@ms;
	    	unshift(@@ARGV, @@ms) if (scalar(@@ms) > 0);
	} else {
	    return $module;
	}

	return $m;
}

while (@@ARGV){
	my $p = get_next_module();
	my $op = undef;
	my $v = undef;
	if (@@ARGV >= 2  && $ARGV[0] =~ /^[<=>!]+$/ &&
	    $ARGV[1] =~ /^[\d\.]+[\w\.]*$/) {
	    	$op = shift @@ARGV;
		$v = shift @@ARGV;
	}
	# For these modes we just need some meta-information and
	# parsing the requirements is not needed.
	if (!($mode{modversion} || $mode{printprovides})) {
		handle_config($p, $op, $v, $cfg_full_list);
	}
	push(@@$top_config, $p);
}

if ($mode{exists}) {
	exit $rc;
}

if ($mode{uninstalled}) {
	$rc = 1 unless $found_uninstalled;
	exit $rc;
}

if ($mode{modversion} || $mode{printprovides}) {
	for my $pkg (@@$top_config) {
		do_modversion($pkg);
	}
}

if ($mode{printrequires} || $mode{printrequiresprivate}) {
	for my $pkg (@@$top_config) {
		print_requires($pkg);
	}
}

if ($mode{minversion}) {
	my $v = $mode{minversion};
	for my $pkg (@@$top_config) {
		$rc = 1 unless versionmatch($configs{$pkg}, '>=', $v);
	}
	exit $rc;
}

if ($mode{exactversion}) {
	my $v = $mode{exactversion};
	for my $pkg (@@$top_config) {
		$rc = 1 unless versionmatch($configs{$pkg}, '=', $v);
	}
	exit $rc;
}

if ($mode{maxversion}) {
	my $v = $mode{maxversion};
	for my $pkg (@@$top_config) {
		$rc = 1 unless versionmatch($configs{$pkg}, '<=', $v);
	}
	exit $rc;
}

my @@vlist = ();

if ($mode{variable}) {
	for my $pkg (@@$top_config) {
		do_variable($pkg, $mode{variable});
	}
}

my $dep_cfg_list = $cfg_full_list;

if ($mode{static}){
	$dep_cfg_list = [reverse(@@$cfg_full_list)];
} else {
	$dep_cfg_list = simplify_and_reverse($cfg_full_list);
}

if ($mode{cflags} || $mode{libs} || $mode{variable}) {
	push @@vlist, do_cflags($dep_cfg_list) if $mode{cflags};
	push @@vlist, do_libs($dep_cfg_list) if $mode{libs};
	print join(' ', @@vlist), "\n" if $rc == 0;
}

exit $rc;

###########################################################################

sub handle_config
{
	my ($p, $op, $v, $list) = @@_;
	my $cfg = cache_find_config($p);

	unshift @@$list, $p if defined $cfg;

	if (!defined $cfg) {
		$rc = 1;
		return undef;
	}

	if (defined $op) {
		if (!versionmatch($cfg, $op, $v)) {
			mismatch($p, $cfg, $op, $v) if $mode{printerr};
			$rc = 1;
			return undef;
		}
	}

	my $get_props = sub {
		my $property = shift;

		my $deps = $cfg->get_property($property, $variables);
		if (defined $deps) {
			for my $dep (@@$deps) {
				if ($dep =~ m/^(.*?)\s*([<=>]+)\s*([\d\.]+|[\d\.]+[\w]*[\d]+)$/) {
					handle_config($1, $2, $3, $list);
				} else {
					handle_config($dep, undef, undef, $list);
				}
			}
			say_debug("package $p " . lc($property) . " " . join(',', @@$deps));
		}
	};

	if (defined $mode{cflags}
	    or ($mode{static} && $mode{libs})
	    or $mode{printrequiresprivate}
    	    or $mode{exists}) {
		&$get_props("Requires.private");
	}
	&$get_props("Requires");

}

# look for the .pc file in each of the PKGPATH elements. Return the path or
# undef if it's not there
sub pathresolve
{
	my ($p) = @@_;

	if ($allow_uninstalled && $p !~ m/\-uninstalled$/) {
		foreach my $d (@@PKGPATH) {
			my $f = "$d/$p-uninstalled.pc";
			say_debug("pathresolve($p) looking in $f");
			if (-f $f) {
				$found_uninstalled = 1;
				return $f;
			}
		}
	}

	foreach my $d (@@PKGPATH) {
		my $f = "$d/$p.pc";
		say_debug("pathresolve($p) looking in $f");
		return $f if -f $f;
	}
	return undef;
}

sub get_config
{
	my ($f) = @@_;

	my $cfg;
	eval {
	    $cfg = OpenBSD::PkgConfig->read_file($f);
	};
	if (!$@@) {
		return validate_config($f, $cfg);
	} else {
		say_debug($@@);
	}
	return undef;
}

sub cache_find_config
{
	my $name = shift;

	say_debug("processing $name");

	if (exists $configs{$name}) {
		return $configs{$name};
	} else {
	    	return $configs{$name} = find_config($name);
	}
}

# Required elements for a valid .pc file: Name, Description, Version
sub validate_config
{
	my ($f, $cfg) = @@_;
	my @@required_elems = ('Name', 'Description', 'Version');

	# Check if we're dealing with an empty file, but don't error out just
	# yet, we'll do that when we realize there's no Name field.
	if (stat($f)->size == 0) {
		say_error("Package file '$f' appears to be empty");
	}

	foreach (@@required_elems) {
		my $e = $cfg->get_property($_, $variables);
		if (!defined $e) {
			$f =~ s/(^.*\/)(.*?)\.pc$/$2/g;
			say_error("Package '$f' has no $_: field");
			return undef;
		}
	}

	return $cfg;
}

# pkg-config won't install a pkg-config.pc file itself, but it may be
# listed as a dependency in other files. so prime the cache with self.
sub setup_self
{
	my $pkg_pc = OpenBSD::PkgConfig->new;
	$pkg_pc->add_property('Version', $version);
	$pkg_pc->add_variable('pc_path', join(":", @@PKGPATH));
	$pkg_pc->add_property('URL', "http://man.openbsd.org/pkg-config");
	$pkg_pc->add_property('Description', "fetch metadata about installed software packages");
	$configs{'pkg-config'} = $pkg_pc;
}

sub find_config
{
	my ($p) = @@_;

	# Differentiate between getting a full path and just the module name.
	my $f = ($p =~ m/\.pc$/ ? $p : pathresolve($p));

	return get_config($f) if defined($f);

	say_error("Package $p was not found in the pkg-config search path");

	return undef;
}

sub stringize
{
	my $list = shift;
	my $sep = shift || ',';

	if (defined $list) {
		return join($sep, @@$list)
	} else {
		return '';
	}
}

#if the variable option is set, pull out the named variable
sub do_variable
{
	my ($p, $v) = @@_;

	my $cfg = cache_find_config($p);

	if (defined $cfg) {
		my $value = $cfg->get_variable($v, $variables);
		if (defined $value) {
			push(@@vlist, $value);
		}
		return undef;
	}
	$rc = 1;
}

#if the modversion or print-provides options are set,
#pull out the compiler flags
sub do_modversion
{
	my ($p) = @@_;

	my $cfg = cache_find_config($p);

	if (defined $cfg) {
		my $value = $cfg->get_property('Version', $variables);
		if (defined $value) {
			if (defined($mode{printprovides})){
				print "$p = " . stringize($value) . "\n";
				return undef;
			} else {
				print stringize($value), "\n";
				return undef;
			}
		}
	}
	$rc = 1;
}

#if the cflags option is set, pull out the compiler flags
sub do_cflags
{
	my $list = shift;

	my $cflags = [];

	foreach my $pkg (@@$list) {
		my $l = $configs{$pkg}->get_property('Cflags', $variables);
		foreach (@@$l) {
			unless ($_ =~ /-I\/usr\/include\/*$/) {
				push(@@$cflags, $_);
			}
		}
	}
	my $a = OpenBSD::PkgConfig->compress($cflags,
		sub {
			local $_ = shift;
			if (($mode{cflags} & 1) && /^-I/ ||
			    ($mode{cflags} & 2) && !/^-I/) {
			    return 1;
			} else {
			    return 0;
			}
		});
	if (defined($a) && defined($variables->{pc_sysrootdir})){
		$a =~ s/[\w]?-I/$&$variables->{pc_sysrootdir}/g;
	}

	return $a;
}

#if the lib option is set, pull out the linker flags
sub do_libs
{
	my $list = shift;

	my $libs = [];

	# In static mode, we have to make sure we discover the libs in dependency
	# order, not in search order. Ordering matters for static linking:
	# Start with Libs (first our own, then dependencies), and append
	# Libs.private (same order as for Libs).
	foreach my $pkg (@@$list) {
		my $l = $configs{$pkg}->get_property('Libs', $variables);
		foreach (@@$l) {
			unless ($_ =~ /-L\/usr\/lib\/*$/) {
				push(@@$libs, $_);
			}
		}
		if ($mode{static}) {
			my $lp = $configs{$pkg}->get_property('Libs.private', $variables);
			foreach (@@$lp) {
				unless ($_ =~ /-L\/usr\/lib\/*/) {
			   		push(@@$libs, $_);
				}
			}
		}
	}

	# Get the linker path directives (-L) and store it in $a.
	# $b will be the actual libraries.
	my $a = OpenBSD::PkgConfig->compress($libs,
		sub {
			local $_ = shift;
			if (($mode{libs} & 2) && /^-L/ ||
			    ($mode{libs} & 4) && !/^-[lL]/) {
			    return 1;
			} else {
			    return 0;
			}
		});

	if (defined($variables->{pc_sysrootdir})){
		$a =~ s/[\w]?-[lL]/$&$variables->{pc_sysrootdir}/g;
	}

	if ($mode{libs} & 1) {
		my $b = OpenBSD::PkgConfig->rcompress($libs,
			    sub { shift =~ m/^-l/; });
		return ($a, $b);
	} else {
		return $a;
	}
}

#list all packages
sub do_list
{
	my ($p, $x, $y, @@files, $fname, $name);
	my $error = 0;

	foreach my $p (@@PKGPATH) {
		push(@@files, <$p/*.pc>);
	}

	# Scan the lengths of the package names so I can make a format
	# string to line the list up just like the real pkgconfig does.
	$x = 0;
	foreach my $f (@@files) {
		$fname = basename($f, '.pc');
		$y = length $fname;
		$x = (($y > $x) ? $y : $x);
	}
	$x *= -1;

	foreach my $f (@@files) {
		my $cfg = get_config($f);
		if (!defined $cfg) {
			say_warning("Problem reading file $f");
			$error = 1;
			next;
		}
		$fname = basename($f, '.pc');
		printf("%${x}s %s - %s\n", $fname,
		    stringize($cfg->get_property('Name', $variables), ' '),
		    stringize($cfg->get_property('Description', $variables),
		    ' '));
	}
	return $error;
}

sub help
{
	print <<EOF
Usage: $0 [options]
--debug	- turn on debugging output
--help - this message
--usage - this message
--list-all - show all packages that $0 can find
--version - print version of pkgconfig
--errors-to-stdout - direct error messages to stdout rather than stderr
--print-errors - print error messages in case of error
--print-provides - print all the modules the given package provides
--print-requires - print all the modules the given package requires
--print-requires-private - print all the private modules the given package requires
--silence-errors - don\'t print error messages in case of error
--atleast-pkgconfig-version [version] - require a certain version of pkgconfig
--cflags package [versionspec] [package [versionspec]]
--cflags-only-I - only output -Iincludepath flags
--cflags-only-other - only output flags that are not -I
--define-variable=NAME=VALUE - define variables
--libs package [versionspec] [package [versionspec]]
--libs-only-l - only output -llib flags
--libs-only-L - only output -Llibpath flags
--libs-only-other - only output flags that are not -l or -L
--exists package [versionspec] [package [versionspec]]
--uninstalled - allow for uninstalled versions to be used
--static - adjust output for static linking
--atleast-version [version] - require a certain version of a package
--exact-version [version] - require exactly the specified version of a package
--max-version [version] - require at most a certain version of a package
--modversion [package] - query the version of a package
--variable var package - return the definition of <var> in <package>
EOF
;
	exit 0;
}

# do we meet/beat the version the caller requested?
sub self_version
{
	my ($v) = @@_;
	my (@@a, @@b);

	@@a = split(/\./, $v);
	@@b = split(/\./, $version);

	if (($b[0] >= $a[0]) && ($b[1] >= $a[1])) {
		return 0;
	} else {
		return 1;
	}
}

sub compare
{
	my ($a, $b) = @@_;
	my ($full_a, $full_b) = ($a, $b);
	my (@@suffix_a, @@suffix_b);

	return 0 if ($a eq $b);

	# is there a valid non-numeric suffix to deal with later?
	# accepted are (in order): a(lpha) < b(eta) < rc < ' '.
	# suffix[0] is the 'alpha' part, suffix[1] is the '1' part in 'alpha1'.
	if ($a =~ s/(rc|beta|b|alpha|a)(\d+)$//) {
		say_debug("valid suffix $1$2 found in $a$1$2.");
		$suffix_a[0] = $1;
		$suffix_a[1] = $2;
	}

	if ($b =~ s/(rc|beta|b|alpha|a)(\d+)$//) {
		say_debug("valid suffix $1$2 found in $b$1$2.");
		$suffix_b[0] = $1;
		$suffix_b[1] = $2;
	}

	# The above are standard suffixes; deal with single alphabetical
	# suffixes too, e.g. 1.0.1h
	if ($a =~ s/([a-zA-Z]){1}$//) {
	    say_debug("valid suffix $1 found in $a$1.");
	    $suffix_a[0] = $1;
	}

	if ($b =~ s/([a-zA-Z]){1}$//) {
	    say_debug("valid suffix $1 found in $b$1.");
	    $suffix_b[0] = $1;
	}

	my @@a = split(/\./, $a);
	my @@b = split(/\./, $b);

	while (@@a && @@b) { #so long as both lists have something
		if (!(@@suffix_a || @@suffix_b)) {
			# simple comparison when no suffixes are in the game.
			my $rc = compare_numeric($a[0], $b[0], 0);
			return $rc if defined($rc);
		} else {
			# extended comparison.
			if (((@@a == 1) || (@@b == 1)) &&
			    ($a[0] == $b[0])){
				# one of the arrays has reached the last element,
				# compare the suffix.

				# directly compare suffixes, provided both suffixes
				# are present.
				if (@@suffix_a && @@suffix_b) {
					my $first_char = sub {
						return substr(shift, 0, 1);
					};

					# suffixes are equal, compare on numeric
					if (&$first_char($suffix_a[0]) eq
					    &$first_char($suffix_b[0])) {
					    	return compare_numeric($suffix_a[1], $suffix_b[1], 1);
					}

					# rc beats beta beats alpha
					if (&$first_char($suffix_a[0]) lt &$first_char($suffix_b[0])) {
						say_debug("$full_a (installed) < $full_b (wanted)");
						return -1;
					} else {
						say_debug("$full_a (installed) > $full_b (wanted)");
						return 1;
					}

				} else {
					# one of either is lacking a suffix,
					# thereby beating the other.
					# e.g.: 1.02 > 1.02b1
					if (@@suffix_a) { # a is older
						say_debug("$full_a (installed) < $full_b (wanted)");
						return 1;
					}

					if (@@suffix_b) { # b is older
						say_debug("$full_a (installed) > $full_b (wanted)");
						return -1;
					}
				}
			} else {
				my $rc = compare_numeric($a[0], $b[0], 0);
				return $rc if defined($rc);
			}
		}
		shift @@a; shift @@b;
	}
	return 1 if @@a;
	return -1 if @@b;
	return 0;
}

# simple numeric comparison, with optional equality test.
sub compare_numeric
{
	my ($x, $y, $eq) = @@_;

	return  1 if $x > $y;
	return -1 if $x < $y;
	return  0 if (($x == $y) and ($eq == 1));
	return undef;
}

# got a package meeting the requested specific version?
sub versionmatch
{
	my ($cfg, $op, $want) = @@_;

	# can't possibly match if we can't find the file
	return 0 if !defined $cfg;

	my $inst = stringize($cfg->get_property('Version', $variables));

	# can't possibly match if we can't find the version string
	return 0 if $inst eq '';

	say_debug("comparing $want (wanted) to $inst (installed)");
	my $value = compare($inst, $want);
	if    ($op eq '>=') { return $value >= 0; }
	elsif ($op eq '=')  { return $value == 0; }
	elsif ($op eq '!=') { return $value != 0; }
	elsif ($op eq '<')  { return $value < 0; }
	elsif ($op eq '>')  { return $value > 0; }
	elsif ($op eq '<=') { return $value <= 0; }
}

sub mismatch
{
	my ($p, $cfg, $op, $v) = @@_;
	my $name = stringize($cfg->get_property('Name'), ' ');
	my $version = stringize($cfg->get_property('Version'));
	my $url = stringize($cfg->get_property('URL'));

	say_warning("Requested '$p $op $v' but version of $name is $version");
	say_warning("You may find new versions of $name at $url") if $url;
}

sub simplify_and_reverse
{
	my $reqlist = shift;
	my $dejavu = {};
	my $result = [];

	for my $item (@@$reqlist) {
		if (!$dejavu->{$item}) {
			unshift @@$result, $item;
			$dejavu->{$item} = 1;
		}
	}
	return $result;
}

# retrieve and print Requires(.private)
sub print_requires
{
	my ($p) = @@_;

	my $cfg = cache_find_config($p);

	if (defined($cfg)) {
		my $value;

		if (defined($mode{printrequires})) {
			$value = $cfg->get_property('Requires', $variables);
		} elsif (defined($mode{printrequiresprivate})) {
			$value = $cfg->get_property('Requires.private', $variables);
		} else {
			say_debug("Unknown mode for print_requires.");
			return 1;
		}

		if (defined($value)) {
			print "$_\n" foreach (@@$value);
			return undef;
		}
	}

	$rc = 1;
}

sub beautify_list
{
	return join(' ', map {"[$_]"} @@_);
}

sub say_debug
{
	say_msg(shift) if $mode{debug};
}

sub say_error
{
	say_msg(shift) if $mode{printerr}
}

sub say_warning
{
	say_msg(shift);
}

sub say_msg
{
	my $str = shift;

	# If --errors-to-stdout was given, close STDERR (to be safe),
	# then dup the output to STDOUT and delete the key from %mode so we
	# won't keep checking it. STDERR stays dup'ed.
	if ($mode{estdout}) {
		close(STDERR);
		open(STDERR, ">&STDOUT") or die "Can't dup STDOUT: $!";
		delete($mode{estdout});
	}

	print STDERR $str . "\n";
}
@


1.89
log
@Strip out -I/usr/include and -L/usr/lib from the --cflags/--libs output.

fd.o pkg-config doesn't emit them either, and libpng now exposed the issue
as tracked down by naddy@@
@
text
@d2 1
a2 1
# $OpenBSD: pkg-config,v 1.88 2017/08/15 00:26:09 jasper Exp $
d480 1
a480 1
			unless ($_ =~ /-I\/usr\/include/) {
d516 1
a516 1
			unless ($_ =~ /-L\/usr\/lib/) {
d523 1
a523 1
				unless ($_ =~ /-L\/usr\/lib/) {
@


1.88
log
@remove vax leftover
@
text
@d2 1
a2 1
# $OpenBSD: pkg-config,v 1.87 2016/08/07 08:59:25 tb Exp $
d479 5
a483 1
		push(@@$cflags, @@$l) if defined $l;
d515 5
a519 1
		push(@@$libs, @@$l) if defined $l;
d522 5
a526 1
			push(@@$libs, @@$lp) if defined $lp;
@


1.87
log
@Update online manual path to man.openbsd.org.

ok espie
@
text
@d2 1
a2 1
# $OpenBSD: pkg-config,v 1.86 2015/10/11 11:48:46 jasper Exp $
d116 1
a116 1
	my @@static_archs = qw(vax);
@


1.86
log
@handle comma separated list of arguments, i.e. pkg-config --exists gcr-3,gcr-base-3
@
text
@d2 1
a2 1
# $OpenBSD: pkg-config,v 1.85 2014/11/17 22:16:23 jca Exp $
d399 1
a399 1
	$pkg_pc->add_property('URL', "http://www.openbsd.org/cgi-bin/man.cgi?query=pkg-config");
@


1.85
log
@Activate support for "package != version" requests, this time with
jasper's proper ok. Tested with i386/amd64 xenocara builds, plus bulk
ports builds on amd64 (thx landry@@).
@
text
@d2 1
a2 1
# $OpenBSD: pkg-config,v 1.84 2014/11/02 13:28:50 jasper Exp $
d164 16
d181 1
a181 1
	my $p = shift @@ARGV;
@


1.84
log
@revert, i did NOT ok this diff which bears no proof of testing in a bulk or xenocara
@
text
@d2 1
a2 1
# $OpenBSD: pkg-config,v 1.82 2014/07/10 08:20:13 jasper Exp $
d168 1
a168 1
	if (@@ARGV >= 2  && $ARGV[0] =~ /^[<=>]+$/ &&
@


1.83
log
@Allow for requests such as "foo != some.version".

The code was already there but unreachable.  ok jasper@@
@
text
@d168 1
a168 1
	if (@@ARGV >= 2  && $ARGV[0] =~ /^[<=>!]+$/ &&
@


1.82
log
@fix version comparison for openssl-like versions (1.0.1g etc)

found, tested and OK sthen@@
@
text
@d2 1
a2 1
# $OpenBSD: pkg-config,v 1.81 2014/07/09 23:03:51 jasper Exp $
d168 1
a168 1
	if (@@ARGV >= 2  && $ARGV[0] =~ /^[<=>]+$/ &&
@


1.81
log
@small alignment tweak
@
text
@d2 1
a2 1
# $OpenBSD: pkg-config,v 1.80 2013/05/30 00:02:02 jasper Exp $
d638 12
@


1.80
log
@adjust error message for empty files to display the full path to the file,
helps in case the file exists in multiple locations. this also matches fd.o.
@
text
@d2 1
a2 1
# $OpenBSD: pkg-config,v 1.79 2013/03/31 13:58:01 brad Exp $
d708 1
a708 1
	return 1 if $x > $y;
d710 1
a710 1
	return 0 if (($x == $y) and ($eq == 1));
@


1.79
log
@m88k has shared libs now.

ok jasper@@
@
text
@d2 1
a2 1
# $OpenBSD: pkg-config,v 1.78 2013/03/28 22:00:02 jasper Exp $
d361 1
a361 3
		my $p = $f;
		$p =~ s/(^.*\/)(.*?)$/$2/g;
		say_error("Package file '$p' appears to be empty");
@


1.78
log
@allow passing a full path to a .pc file, instead of just the module name.
fd.o pkg-config allows this and some ports landry's working on depend on it.

tested in a bulk by landry@@, thanks
@
text
@d2 1
a2 1
# $OpenBSD: pkg-config,v 1.77 2012/12/10 10:12:12 jasper Exp $
d116 1
a116 1
	my @@static_archs = qw(m88k vax);
@


1.77
log
@Document --{exact,max}-version
@
text
@d2 1
a2 1
# $OpenBSD: pkg-config,v 1.76 2012/12/08 18:50:05 jasper Exp $
d393 3
a395 1
	my $f = pathresolve($p);
@


1.76
log
@fix a pasto which broke (or rather, disabled) --max-version

from Brian Manning (upstream ExtUtils::PkgConfig maintainer)
@
text
@d2 1
a2 1
# $OpenBSD: pkg-config,v 1.75 2012/10/09 10:22:37 jasper Exp $
d592 2
@


1.75
log
@- bump the version to match fd.o's 0.27.1 release.
@
text
@d2 1
a2 1
# $OpenBSD: pkg-config,v 1.74 2012/10/09 09:58:59 jasper Exp $
d218 1
a218 1
if ($mode{minversion}) {
@


1.74
log
@- also check Requires.private for --exists.
@
text
@d2 1
a2 1
# $OpenBSD: pkg-config,v 1.73 2012/07/28 08:50:06 jasper Exp $
d49 1
a49 1
my $version = 0.26; # pretend to be this version of pkgconfig
@


1.73
log
@Return a proper error message when we end up needed to parse
packages, but none were provided. Similar to what fd.o does.
@
text
@d2 1
a2 1
# $OpenBSD: pkg-config,v 1.72 2012/07/04 08:44:07 espie Exp $
d290 2
a291 1
	    or $mode{printrequiresprivate}) {
@


1.72
log
@fix the static arch fix. don't remove duplicates, but don't forget to
reverse either !

okay jasper@@
@
text
@d2 1
a2 1
# $OpenBSD: pkg-config,v 1.71 2012/03/19 10:25:17 ajacoutot Exp $
d156 7
@


1.71
log
@GNU's pkg-config added PREFIX/share/pkgconfig/ as a search path 4 years
ago. It is mostly used to store arch-independant dot.pc files (although
not always); so add this directory to our search path as well (will ease
porters' work).

While here, also add X11BASE/share/pkgconfig since X.org seems to do the
same (req. by matthieu@@)

ok dcoppa@@ fgsch@@ phessler@@
@
text
@d2 1
a2 1
# $OpenBSD: pkg-config,v 1.70 2011/11/17 11:37:16 jasper Exp $
d229 3
a231 1
if (!$mode{static}){
@


1.70
log
@    - Fix parts of xenocara on static arches such as vax.

    reported by todd@@ and sebastia@@
    tested by sebastia@@ with xdm on vax.
@
text
@d2 1
a2 1
# $OpenBSD: pkg-config,v 1.69 2011/07/08 18:57:41 jasper Exp $
d28 5
a32 1
my @@PKGPATH = qw(/usr/lib/pkgconfig /usr/local/lib/pkgconfig /usr/X11R6/lib/pkgconfig);
@


1.69
log
@- pretend we're 0.26. there were no changes in 0.26 that
would remotely apply to us
@
text
@d2 1
a2 1
# $OpenBSD: pkg-config,v 1.68 2011/06/20 12:11:27 jasper Exp $
d22 1
d108 11
d223 5
a227 1
my $dep_cfg_list = simplify_and_reverse($cfg_full_list);
@


1.68
log
@- Adjust Getopts() hash to align options with values.
- Tweak comment about static libs.
@
text
@d2 1
a2 1
# $OpenBSD: pkg-config,v 1.67 2011/06/20 12:10:17 jasper Exp $
d44 1
a44 1
my $version = 0.25; # pretend to be this version of pkgconfig
@


1.67
log
@- implement --static, and preserve dependency order,
 instead of search order when printing the libraries required for linking.

this now passes our --static regress tests and matches fd.o
@
text
@d2 1
a2 1
# $OpenBSD: pkg-config,v 1.66 2011/06/16 08:38:30 jasper Exp $
d75 9
a83 9
GetOptions(	'debug' => \$mode{debug},
		'help' => \&help, #does not return
		'usage' => \&help, #does not return
		'list-all' => \$mode{list},
		'version' => sub { print "$version\n" ; exit(0);} ,
		'errors-to-stdout' => sub { $mode{estdout} = 1},
		'print-errors' => sub { $mode{printerr} = 1},
		'silence-errors' => sub { $mode{printerr} = 0},
		'short-errors' => sub { $mode{printerr} = 0},
d85 2
a86 2
		'print-provides' => \$mode{printprovides},
		'print-requires' => \$mode{printrequires},
d89 16
a104 16
		'cflags' => sub { $mode{cflags} = 3},
		'cflags-only-I' => sub { $mode{cflags} |= 1},
		'cflags-only-other' => sub { $mode{cflags} |= 2},
		'libs' => sub { $mode{libs} = 7},
		'libs-only-l' => sub { $mode{libs} |= 1},
		'libs-only-L' => sub { $mode{libs} |= 2},
		'libs-only-other' => sub { $mode{libs} |= 4},
		'exists' => sub { $mode{exists} = 1} ,
		'static' => sub { $mode{static} = 1},
		'uninstalled' => sub { $mode{uninstalled} = 1},
		'atleast-version=s' => \$mode{minversion},
		'exact-version=s' => \$mode{exactversion},
		'max-version=s' => \$mode{maxversion},
		'modversion' => \$mode{modversion},
		'variable=s' => \$mode{variable},
		'define-variable=s' => $variables,
d459 4
a462 2
	# In static mode, we have to make sure we print the libs in dependency
	# order, not in search order. Ordering matters for static linking.
d472 2
a473 1
	# Get the linker path directives (-L).
@


1.66
log
@- finally unconfuse emacs by using parentheses for split()
@
text
@d2 1
a2 1
# $OpenBSD: pkg-config,v 1.65 2011/06/16 08:33:54 jasper Exp $
d459 2
d464 4
@


1.65
log
@fix printrequiresprivate-mode name in a test
@
text
@d2 1
a2 1
# $OpenBSD: pkg-config,v 1.64 2011/06/15 11:54:03 jasper Exp $
d30 1
a30 1
	@@PKGPATH = split /:/, $ENV{PKG_CONFIG_LIBDIR};
d32 1
a32 1
	unshift(@@PKGPATH, split /:/, $ENV{PKG_CONFIG_PATH});
d127 1
a127 1
@@ARGV = split /\,?\s+/, $p;
d214 3
a216 3
    push @@vlist, do_cflags($dep_cfg_list) if $mode{cflags};
    push @@vlist, do_libs($dep_cfg_list) if $mode{libs};
    print join(' ', @@vlist), "\n" if $rc == 0;
d259 3
a261 1
	if (defined $mode{cflags} or $mode{static} or $mode{printrequiresprivate}) {
d463 2
a464 1
	
d482 1
a482 1
			sub { shift =~ m/^-l/; });
d539 1
a539 1
--silence-errors - don't print error messages in case of error
d566 2
a567 2
	@@a = split /\./, $v;
	@@b = split /\./, $version;
d599 2
a600 2
	my @@a = split /\./, $a;
	my @@b = split /\./, $b;
@


1.64
log
@- only process Requires.private if needed (--cflags, --static or --print-requires-private)
- process Requires.private before processing Requires, order matters

these are first steps towards a working --static. static doesn't work yet as
libraries get re-ordered in a funky way.
@
text
@d2 1
a2 1
# $OpenBSD: pkg-config,v 1.63 2011/06/12 21:33:49 jasper Exp $
d259 1
a259 1
	if (defined $mode{cflags} or $mode{static} or $mode{printreqprivate}) {
@


1.63
log
@tweak the virtual pkg-config config
@
text
@d2 1
a2 1
# $OpenBSD: pkg-config,v 1.62 2011/06/12 18:16:25 jasper Exp $
d259 3
a262 1
	&$get_props("Requires.private");
d362 3
a364 3
	if (defined $f) {
		return get_config($f);
	}
d461 1
@


1.62
log
@- rename pr_* to say_* to be consistent with perl (prompted by espie@@)
- move actual printing to STDERR to one place, this makes it easier to:
- honor $mode{estdout} (--errors-to-stdout) which was silently ignored untill now
@
text
@d2 1
a2 1
# $OpenBSD: pkg-config,v 1.61 2011/06/12 17:13:17 jasper Exp $
d345 1
a345 3

# listed as a dependency in other files.
# so, prime the cache with self
d351 2
d766 1
a766 1
	my ($str) = shift;
@


1.61
log
@- Rename $D to $mode{debug} for consistency.
-  Factorize lots of prints into a common debug/error subroutine.
   This reduces unneeded clutter when testing for $mode{printerr}
   or $mode{debug}. Will be adjusted further when fixing --errors-to-stdout
@
text
@d2 1
a2 1
# $OpenBSD: pkg-config,v 1.58 2011/06/11 12:09:06 jasper Exp $
d119 1
a119 1
pr_debug("\n" . beautify_list($0, @@ARGV));
d255 1
a255 1
			pr_debug("package $p " . lc($property) . " " . join(',', @@$deps));
d273 1
a273 1
			pr_debug("pathresolve($p) looking in $f");
d283 1
a283 1
		pr_debug("pathresolve($p) looking in $f");
d300 1
a300 1
		pr_debug($@@);
d309 1
a309 1
	pr_debug("processing $name");
d329 1
a329 1
		pr_error("Package file '$p' appears to be empty");
d336 1
a336 1
			pr_error("Package '$f' has no $_: field");
d363 1
a363 1
	pr_error("Package $p was not found in the pkg-config search path");
d506 1
a506 1
			print STDERR "Problem reading file $f\n";
d582 1
a582 1
		pr_debug("valid suffix $1$2 found in $a$1$2.");
d588 1
a588 1
		pr_debug("valid suffix $1$2 found in $b$1$2.");
d623 1
a623 1
						pr_debug("$full_a (installed) < $full_b (wanted)");
d626 1
a626 1
						pr_debug("$full_a (installed) > $full_b (wanted)");
d635 1
a635 1
						pr_debug("$full_a (installed) < $full_b (wanted)");
d640 1
a640 1
						pr_debug("$full_a (installed) > $full_b (wanted)");
d680 1
a680 1
	pr_debug("comparing $want (wanted) to $inst (installed)");
d697 2
a698 2
	print STDERR "Requested '$p $op $v' but version of $name is $version\n";
	print STDERR "You may find new versions of $name at $url\n" if $url;
d731 1
a731 1
			pr_debug("Unknown mode for print_requires.");
d749 1
a749 1
sub pr_debug
d751 1
a751 2
	my $str = shift;
	print STDERR $str . "\n" if $mode{debug};
d754 1
a754 1
sub pr_error
d756 22
a777 2
	my $str = shift;
	print STDERR $str . "\n" if $mode{printerr};
@


1.60
log
@- fix comment
- style nit
@
text
@d2 1
a2 1
# $OpenBSD: pkg-config,v 1.59 2011/06/12 17:08:44 jasper Exp $
d58 1
a58 2
my $D;
defined $ENV{PKG_CONFIG_DEBUG_SPEW} ? $D = 1 : $D = 0;
d75 1
a75 1
GetOptions(	'debug' => \$D,
d109 4
a112 2
	if (defined $mode{libs} || defined $mode{cflags}
	    || defined $mode{version} || defined $mode{list}) {
d119 1
a119 1
print STDERR "\n", beautify_list($0, @@ARGV), "\n" if $D;
d255 1
a255 2
			print STDERR "package $p ", lc($property), " ",
			    join(',', @@$deps), "\n" if $D;
d273 1
a273 1
			print STDERR "pathresolve($p) looking in $f\n" if $D;
d283 1
a283 1
		print STDERR "pathresolve($p) looking in $f\n" if $D;
d300 1
a300 1
		print STDERR $@@, "\n" if $D;
d309 1
a309 1
	print STDERR "processing $name\n" if $D;
d326 1
a326 1
	if ((stat($f)->size == 0) && $mode{printerr}) {
d329 1
a329 1
		print STDERR "Package file '$p' appears to be empty\n";
d336 1
a336 3
			if ($mode{printerr}) {
				print STDERR "Package '$f' has no $_: field\n";
			}
d363 2
a364 4
	if ($mode{printerr}) {
	    print STDERR
	    	"Package $p was not found in the pkg-config search path\n";
	}
d582 1
a582 1
		print STDERR "valid suffix $1$2 found in $a$1$2.\n" if $D;
d588 1
a588 1
		print STDERR "valid suffix $1$2 found in $b$1$2.\n" if $D;
d623 1
a623 1
						print STDERR "$full_a (installed) < $full_b (wanted)\n" if $D;
d626 1
a626 1
						print STDERR "$full_a (installed) > $full_b (wanted)\n" if $D;
d635 1
a635 1
						print STDERR "$full_a (installed) < $full_b (wanted)\n" if $D;
d640 1
a640 1
						print STDERR "$full_a (installed) > $full_b (wanted)\n" if $D;
d680 1
a680 1
	print "comparing $want (wanted) to $inst (installed)\n" if $D;
d731 1
a731 1
			print STDERR "Unknown mode for print_requires.\n" if $D;
d747 12
@


1.59
log
@- fix version comparison by adjusting the regex which decides about
    what is an operator and what is a valid version.
  (all version comparison regress tests pass now)
- add back 'rc' support

ok sthen@@
@
text
@d2 1
a2 1
# $OpenBSD: pkg-config,v 1.58 2011/06/11 12:09:06 jasper Exp $
d412 2
a413 2
			if (!defined($mode{printprovides})){
				print stringize($value), "\n";
d416 1
a416 1
				print "$p = " . stringize($value) . "\n";
a584 1
	# XXX: add back 'rc'
@


1.58
log
@- add check for empty files
- only do the above check, and print an error if we lack a required field
      if $mode{printerr}.
- put code setting $D together
@
text
@d2 1
a2 1
# $OpenBSD: pkg-config,v 1.57 2011/06/09 12:32:30 jasper Exp $
d145 1
a145 1
	    $ARGV[1] =~ /^[\d\.]+\w?$/) {
d586 1
a586 1
	if ($a =~ s/(beta|b|alpha|a)(\d+)$//) {
d592 1
a592 1
	if ($b =~ s/(beta|b|alpha|a)(\d+)$//) {
@


1.57
log
@*** empty log message ***
@
text
@d2 1
a2 1
# $OpenBSD: pkg-config,v 1.56 2011/06/09 12:28:03 jasper Exp $
d24 1
a50 1
my $D = 0; # debug flag
d58 2
a59 1
$D = 1 if defined $ENV{PKG_CONFIG_DEBUG_SPEW};
d323 8
a330 1
	my $e;
d333 1
a333 1
		$e = $cfg->get_property($_, $variables);
d336 3
a338 1
			print STDERR "Package '$f' has no $_: field\n";
d583 1
a583 1
	# accepter are (in order): a(lpha) < b(eta) < rc < ' '.
d585 1
a585 1
	# XXX: add back 'rc'.
@


1.56
log
@whitespace cleanup
@
text
@d2 1
a2 1
# $OpenBSD: pkg-config,v 1.55 2011/06/09 10:43:28 jasper Exp $
d577 1
a577 1
		print STDERR "valid suffix $1$2 found in $a.\n" if $D;
d583 1
a583 1
		print STDERR "valid suffix $1$2 found in $b.\n" if $D;
@


1.55
log
@fix version comparison when we ask for "alpha > 0.1.0" and the version of
alpha is 0.1.0alpha2.

doing "alpha > 0.1.0alpha2" doesn't work yet.
@
text
@d2 1
a2 1
# $OpenBSD: pkg-config,v 1.54 2011/06/07 18:42:30 jasper Exp $
d52 1
a52 1
$variables->{pc_top_builddir} = $ENV{PKG_CONFIG_TOP_BUILD_DIR} // 
d598 1
a598 1
			if (((@@a == 1) || (@@b == 1)) && 
a638 1
				
a642 1
				
@


1.54
log
@revert 'rc' handling for now, as it breaks iaxclient.
the underlying issue will be dealt with soon.

discussed with and ok sthen@@
@
text
@d2 1
a2 1
# $OpenBSD: pkg-config,v 1.53 2011/06/07 12:22:46 jasper Exp $
d631 1
a631 1
						return -1;
d636 1
a636 1
						return 1;
@


1.53
log
@prevent stringize from messing up the Name field
@
text
@d2 1
a2 1
# $OpenBSD: pkg-config,v 1.52 2011/06/07 06:42:19 jasper Exp $
d575 2
a576 1
	if ($a =~ s/(rc|beta|b|alpha|a)(\d+)$//) {
d582 1
a582 1
	if ($b =~ s/(rc|beta|b|alpha|a)(\d+)$//) {
@


1.52
log
@Don't try to parse the requirements for a module if only modversion or
printprovides are requested.
@
text
@d2 1
a2 1
# $OpenBSD: pkg-config,v 1.51 2011/06/06 17:49:37 jasper Exp $
d506 1
a506 1
		    stringize($cfg->get_property('Name', $variables)),
d689 1
a689 1
	my $name = stringize($cfg->get_property('Name'));
@


1.51
log
@fix PKG_CONFIG_LOG as the first argument to beautify_list() was incorrect
@
text
@d2 1
a2 1
# $OpenBSD: pkg-config,v 1.50 2011/06/06 17:10:43 jasper Exp $
d148 5
a152 1
	handle_config($p, $op, $v, $cfg_full_list);
@


1.50
log
@rename PKG_CONFIG_LOGFILE to PKG_CONFIG_LOG to match fd.o
@
text
@d2 1
a2 1
# $OpenBSD: pkg-config,v 1.49 2011/06/06 12:32:17 jasper Exp $
d62 1
a62 1
	print $L beautify_list($_, @@ARGV), "\n";
@


1.49
log
@- style tweaks by espie@@
- bump version to 0.25
@
text
@d2 1
a2 1
# $OpenBSD: pkg-config,v 1.48 2011/06/06 11:18:55 jasper Exp $
d35 2
a36 2
if (defined($ENV{PKG_CONFIG_LOGFILE}) && $ENV{PKG_CONFIG_LOGFILE}) {
	$logfile = $ENV{PKG_CONFIG_LOGFILE};
@


1.48
log
@move simple numeric comparison to a single routine, instead of duplicating it
@
text
@d2 1
a2 1
# $OpenBSD: pkg-config,v 1.46 2011/06/06 07:57:07 jasper Exp $
d43 1
a43 1
my $version = 0.23; # pretend to be this version of pkgconfig
d571 1
a571 1
	if ($a =~ m/(rc|beta|b|alpha|a)([\d]+)$/) {
a574 1
		$a =~ s/$suffix_a[0]$suffix_a[1]//g;
d577 1
a577 1
	if ($b =~ m/(rc|beta|b|alpha|a)([\d]+)$/) {
a580 1
		$b =~ s/$suffix_b[0]$suffix_b[1]//g;
d593 1
a593 1
			if (((scalar(@@a) == 1) || (scalar(@@b) == 1)) && 
@


1.47
log
@also handle the 'rc' suffix
@
text
@d591 2
a592 2
			return 1 if $a[0] > $b[0];
			return -1 if $a[0] < $b[0];
d610 1
a610 3
						return 0 if ($suffix_a[1] == $suffix_b[1]);
						return 1 if ($suffix_a[1] > $suffix_b[1]);
						return -1 if ($suffix_a[1] < $suffix_b[1]);
d638 2
a639 2
				return 1 if $a[0] > $b[0];
				return -1 if $a[0] < $b[0];
d648 11
@


1.46
log
@First steps of teaching pkg-config about 'alpha' and 'beta' versions.
The order is 'alpha' < 'beta' < ' ' , and the common shorts 'a' and 'b'
are also accepted.
It may have some rought edges, but they will be dealt with later.

tested in a full bulk by me,
reads good to landry@@
@
text
@d2 1
a2 1
# $OpenBSD: pkg-config,v 1.45 2011/06/02 12:46:03 sthen Exp $
d569 1
a569 1
	# only a(lpha) and b(eta) are allowed for now (do pre and rc later).
d571 1
a571 1
	if ($a =~ m/(beta|b|alpha|a)([\d]+)$/) {
d578 1
a578 1
	if ($b =~ m/(beta|b|alpha|a)([\d]+)$/) {
d615 1
a615 1
					# beta beats alpha
@


1.45
log
@Revert previous; changes linking order for pkg-config --libs, breaking X on VAX.
Found by matthieu@@
@
text
@d2 1
a2 1
# $OpenBSD: pkg-config,v 1.43 2011/05/18 11:12:13 jasper Exp $
d243 1
a243 1
				if ($dep =~ m/^(.*?)\s*([<=>]+)\s*([\d\.]+)$/) {
d563 2
d568 17
d589 56
a644 2
		return 1 if $a[0] > $b[0];
		return -1 if $a[0] < $b[0];
@


1.44
log
@memoize handle_config; is not a slow routine per se, but we spend
a lot of time in it, so cache the return values. The most gain
is from configure scripts/build commands which query several modules
at the same time. this results in as much as a 40% speedup for
those pkg-config invocations.

tested in a bulk/ok landry@@
@
text
@a23 1
use Memoize;
a105 6

# handle_config() is not a slow routine per se, but we spend
# a lot of time in it, so cache the return values. The most gain
# is from configure scripts/build commands which query several modules
# at the same time.
memoize('handle_config');
@


1.43
log
@Simplify code in handle_config() by folding two almost identical
blocks into an anonymous sub.
@
text
@d2 1
a2 1
# $OpenBSD: pkg-config,v 1.42 2011/03/21 13:28:06 espie Exp $
d24 1
d107 6
@


1.42
log
@fix audacity. Make specs like >= 0.14.2b kosher
(missed by landry's bulk, obviously).
@
text
@d2 1
a2 1
# $OpenBSD: pkg-config,v 1.41 2011/03/18 18:21:40 jasper Exp $
d237 11
a247 7
	my $deps = $cfg->get_property('Requires', $variables);
	if (defined $deps) {
		for my $dep (@@$deps) {
			if ($dep =~ m/^(.*?)\s*([<=>]+)\s*([\d\.]+)$/) {
				handle_config($1, $2, $3, $list);
			} else {
				handle_config($dep, undef, undef, $list);
d249 2
d252 4
a255 3
		print STDERR "package $p requires ",
		    join(',', @@$deps), "\n" if $D;
	}
a256 12
	$deps = $cfg->get_property('Requires.private', $variables);
	if (defined $deps) {
		for my $dep (@@$deps) {
			if ($dep =~ m/^(.*?)\s*([<=>]+)\s*([\d\.]+)$/) {
				handle_config($1, $2, $3, $list);
			} else {
				handle_config($dep, undef, undef, $list);
			}
		}
		print STDERR "package $p requires (private)",
		    join(',', @@$deps), "\n" if $D;
	}
@


1.41
log
@- when a newer version of an installed package is requested, print the URL
where to find a newer version, if possible. matches fd.o pkg-config.
@
text
@d2 1
a2 1
# $OpenBSD: pkg-config,v 1.40 2011/03/18 15:26:11 jasper Exp $
d144 1
a144 1
	    $ARGV[1] =~ /^[\d\.]+$/) {
@


1.40
log
@- assert copyright
ok ckuethe@@
@
text
@d2 1
a2 1
# $OpenBSD: pkg-config,v 1.39 2011/03/18 15:20:22 jasper Exp $
d610 6
a615 3
	print STDERR "Requested '$p $op $v' but version of ",
	    stringize($cfg->get_property('Name')), " is ",
	    stringize($cfg->get_property('Version')), "\n";
@


1.39
log
@format the message when a module doesn't validate more like fd.o pkg-config, which will
also be printed when PKG_CONFIG_DEBUG_SPEW isn't set.
@
text
@d2 2
a3 1
# $OpenBSD: pkg-config,v 1.38 2011/03/18 15:18:13 jasper Exp $
a4 1
#$CSK: pkgconfig.pl,v 1.39 2006/11/27 16:26:20 ckuethe Exp $
d6 1
@


1.38
log
@add a 'pc_path' variable to the pkg-config.pc cache entry.
this variable will return the paths where pkg-config searches for .pc files, when queried.
@
text
@d2 1
a2 1
# $OpenBSD: pkg-config,v 1.37 2011/03/18 15:14:59 jasper Exp $
d327 2
a328 1
			print STDERR "incomplete or corrupt file: $f\n" if $D;
@


1.37
log
@- add basic validation for .pc files, at least Name, Description and Version have to be
set. this is what fd.o pkg-config requires at least.
@
text
@d2 1
a2 1
# $OpenBSD: pkg-config,v 1.36 2011/03/18 15:13:33 jasper Exp $
d343 1
@


1.36
log
@fix a small buglet when PKG_CONFIG_SYSROOT_DIR was set, it only handled the first occurence
of -I/-L correctly but didn't prepend the sysroot to later occurences, now it does.

no functional change when PKG_CONFIG_SYSROOT_DIR wasn't set.
@
text
@d2 1
a2 1
# $OpenBSD: pkg-config,v 1.35 2011/03/18 14:55:32 espie Exp $
d297 1
a297 1
		return $cfg;
d315 18
@


1.35
log
@minor related tweaks:
- use //=  instead of if (!defined)
- don't special-case code for pkg-config itself, prime cache with versioning
info.
- more accurate regexps for parsing arguments
- don't use join() when we mean map()

leads to:
- fix bug in argument splitting, zap ", " used as argument separation.

okay jasper@@, tested by landry@@
@
text
@d2 1
a2 1
# $OpenBSD: pkg-config,v 1.34 2011/03/14 08:43:59 jasper Exp $
d416 1
a416 1
		$a =~ s/^-I/$&$variables->{pc_sysrootdir}/g;
d445 1
a445 1
		$a =~ s/^-[lL]/$&$variables->{pc_sysrootdir}/g;
@


1.34
log
@- sync help() after recent additions
@
text
@d2 1
a2 1
# $OpenBSD: pkg-config,v 1.33 2011/03/14 08:40:13 jasper Exp $
d45 2
d51 5
a55 14
{
    my $d = $ENV{PKG_CONFIG_TOP_BUILD_DIR};
    if (defined $d) {
	    $variables->{pc_top_builddir} = $d;
    } else {
	    $variables->{pc_top_builddir} = '$(top_builddir)';
    }

    my $s = $ENV{PKG_CONFIG_SYSROOT_DIR};
    if (defined $s) {
	    $variables->{pc_sysrootdir} = $s;
    }
    # The default '/' is implied.
}
d57 1
a57 1
$D = 1 if defined($ENV{PKG_CONFIG_DEBUG_SPEW});
d60 2
a61 2
	open my $L, ">>" . $logfile;
	print $L '[' . join('] [', $0, @@ARGV) . "]\n";
d116 1
a116 1
print STDERR "\n[" . join('] [', $0, @@ARGV) . "]\n" if $D;
d124 1
a124 1
@@ARGV = split /\s+/, $p;
d142 2
a143 2
	if (@@ARGV >= 2  && $ARGV[0] =~ /[<=>]+/ &&
	    $ARGV[1] =~ /[0-9\.]+/) {
a146 1
	$p =~ s/,//g;
d219 1
a219 1
	my $cfg;
d221 1
a221 12
	# pkg-config won't install a pkg-config.pc file itself, but it may be
	# listed as a dependency in other files.
	# If we encounter a dependency on pkg-config, check if our version
	# is sufficient and error out if not.
	if ($p eq "pkg-config"){
		if ($v > $version) {
			print STDERR "pkg-config version $version too old, $v required.\n" if $D;
			$rc = 1;
			return undef;
		}
	} else {
		$cfg = cache_find_config($p);
d223 4
a226 1
		unshift @@$list, $p if defined $cfg;
d228 3
a230 1
		if (!defined $cfg) {
d234 1
d236 7
a242 5
		if (defined $op) {
			if (!versionmatch($cfg, $op, $v)) {
				mismatch($p, $cfg, $op, $v) if $mode{printerr};
				$rc = 1;
				return undef;
d245 3
d249 7
a255 21
		my $deps = $cfg->get_property('Requires', $variables);
		if (defined $deps) {
			for my $dep (@@$deps) {
				if ($dep =~ m/^(.*?)\s*([<=>]+)\s*([\d\.]+)$/) {
					handle_config($1, $2, $3, $list);
				} else {
					handle_config($dep, undef, undef, $list);
				}
			}
			print STDERR "package $p requires ",
			    join(',', @@$deps), "\n" if $D;
		}

		$deps = $cfg->get_property('Requires.private', $variables);
		if (defined $deps) {
			for my $dep (@@$deps) {
				if ($dep =~ m/^(.*?)\s*([<=>]+)\s*([\d\.]+)$/) {
					handle_config($1, $2, $3, $list);
				} else {
					handle_config($dep, undef, undef, $list);
				}
a256 2
			print STDERR "package $p requires (private)",
			    join(',', @@$deps), "\n" if $D;
d258 2
d317 11
d635 5
@


1.33
log
@whitespace cleanup
@
text
@d2 1
a2 1
# $OpenBSD: pkg-config,v 1.32 2011/03/14 08:35:08 jasper Exp $
d78 1
a78 1
# without having to go back and reload the files from disk
d515 3
@


1.32
log
@- implement PKG_CONFIG_SYSROOT_DIR
- bump version to 0.23
@
text
@d2 1
a2 1
# $OpenBSD: pkg-config,v 1.31 2011/03/10 19:15:55 jasper Exp $
d38 1
a38 1
my $allow_uninstalled = 
d115 1
a115 1
	if (defined $mode{libs} || defined $mode{cflags} 
d315 1
a315 1
	eval { 
d347 1
a347 1
	    print STDERR 
d474 2
a475 2
	foreach my $p (@@PKGPATH) { 
		push(@@files, <$p/*.pc>); 
d496 2
a497 2
		printf("%${x}s %s - %s\n", $fname, 
		    stringize($cfg->get_property('Name', $variables)), 
d575 1
a575 1
	
@


1.31
log
@- make this easier to read
@
text
@d2 1
a2 1
# $OpenBSD: pkg-config,v 1.30 2011/03/10 19:13:14 jasper Exp $
d42 1
a42 1
my $version = 0.22; # pretend to be this version of pkgconfig
d56 6
d416 1
a416 1
	return OpenBSD::PkgConfig->compress($cflags,
d426 5
a430 1
	return undef;
d454 5
@


1.30
log
@- implement several more options that will be needed to bump to 0.24
(--print-provides, --print-requires and --print-requires-private)

ok ckuethe@@
@
text
@d2 1
a2 1
# $OpenBSD: pkg-config,v 1.29 2011/03/10 19:06:30 jasper Exp $
d571 6
a576 13
	if ($op eq '>=') {
		return $value >= 0;
	} elsif ($op eq '=') {
		return $value == 0;
	} elsif ($op eq '!=') {
		return $value != 0;
	} elsif ($op eq '<') {
		return $value < 0;
	} elsif ($op eq '>') {
		return $value > 0;
	} elsif ($op eq '<=') {
		return $value <= 0;
	}
@


1.29
log
@honor PKG_CONFIG_DEBUG_SPEW, which is like our --debug option

ok ckuethe@@
@
text
@d2 1
a2 1
# $OpenBSD: pkg-config,v 1.28 2011/03/07 22:21:50 jasper Exp $
d85 3
d162 1
a162 1
if ($mode{modversion}) {
d168 6
d376 2
a377 1
#if the modversion option is set, pull out the compiler flags
d387 7
a393 2
			print stringize($value), "\n";
			return undef;
d607 28
@


1.28
log
@- style consistency

ok ckuethe@@
@
text
@d2 1
a2 1
# $OpenBSD: pkg-config,v 1.27 2010/12/28 14:31:38 jasper Exp $
d57 2
@


1.27
log
@- add /usr/lib/pkgconfig/ to the paths to look for .pc files, and search
  there first (as the original pkgconfig does too).
@
text
@d2 1
a2 1
# $OpenBSD: pkg-config,v 1.26 2010/09/29 16:48:41 jasper Exp $
d524 1
a524 3
	if ($a eq $b) {
		return 0;
	}
d556 1
a556 2
	}
	elsif ($op eq '=') {
@


1.26
log
@it's valid syntax for .pc files to have:
Requires: pkg-config >= 0.21
out pkg-config couldn't handle it, as pkg-config(1) doesn't install a .pc file
to check this dependency against. fd.o pkg-config deals with this by
treating this as a special case; adapt ours to do the same.

tested in a ports bulk build and xenocara build
ok ckuethe@@ sthen@@
@
text
@d2 1
a2 1
# $OpenBSD: pkg-config,v 1.25 2010/09/18 09:27:51 sthen Exp $
d25 1
a25 1
my @@PKGPATH = qw(/usr/local/lib/pkgconfig /usr/X11R6/lib/pkgconfig );
@


1.25
log
@claim that we are pkg-config 0.22; ok ajacoutot@@ ckuethe@@
@
text
@d2 1
a2 1
# $OpenBSD: pkg-config,v 1.24 2009/06/21 21:30:46 ckuethe Exp $
d210 1
d212 12
d225 1
a225 8
	my $cfg = cache_find_config($p);

	unshift @@$list, $p if defined $cfg;

	if (!defined $cfg) {
		$rc = 1;
		return undef;
	}
d227 1
a227 3
	if (defined $op) {
		if (!versionmatch($cfg, $op, $v)) {
			mismatch($p, $cfg, $op, $v) if $mode{printerr};
a230 1
	}
d232 16
a247 7
	my $deps = $cfg->get_property('Requires', $variables);
	if (defined $deps) {
		for my $dep (@@$deps) {
			if ($dep =~ m/^(.*?)\s*([<=>]+)\s*([\d\.]+)$/) {
				handle_config($1, $2, $3, $list);
			} else {
				handle_config($dep, undef, undef, $list);
d249 2
a251 3
		print STDERR "package $p requires ",
		    join(',', @@$deps), "\n" if $D;
	}
d253 8
a260 7
	$deps = $cfg->get_property('Requires.private', $variables);
	if (defined $deps) {
		for my $dep (@@$deps) {
			if ($dep =~ m/^(.*?)\s*([<=>]+)\s*([\d\.]+)$/) {
				handle_config($1, $2, $3, $list);
			} else {
				handle_config($dep, undef, undef, $list);
d262 2
a264 2
		print STDERR "package $p requires (private)",
			join(',', @@$deps), "\n" if $D;
@


1.24
log
@fix PKG_CONFIG_PATH handling per system/6174. tested with xenocara build
and a bunch of ports
@
text
@d2 1
a2 1
# $OpenBSD: pkg-config,v 1.23 2008/10/26 23:56:37 jasper Exp $
d42 1
a42 1
my $version = 0.21; # pretend to be this version of pkgconfig
@


1.23
log
@- make pkg-config recognize --short-errors
- bump the version we're pretending to be to 0.21

ok ckuethe@@ ajacoutot@@
@
text
@d2 1
a2 1
# $OpenBSD: pkg-config,v 1.22 2008/09/06 10:49:28 simon Exp $
d30 1
a30 1
	push(@@PKGPATH, split /:/, $ENV{PKG_CONFIG_PATH});
@


1.22
log
@Calling --help shouldn't be an error condition, so exit with status 0
instead of 1, and make it consistent with gnu.

ok ckuethe@@
@
text
@d2 1
a2 1
# $OpenBSD: pkg-config,v 1.21 2008/08/21 21:57:45 simon Exp $
d42 1
a42 1
my $version = 0.19; # pretend to be this version of pkgconfig
d81 1
@


1.21
log
@Add an optional separator to stringize() and use it from do_list() to
match the GNU pkg-config --list-all output.

ok ckuethe@@
@
text
@d2 1
a2 1
# $OpenBSD: pkg-config,v 1.20 2007/02/01 16:38:21 espie Exp $
d488 1
a488 1
	exit 1;
@


1.20
log
@handle errors reading .pc files in --list gracefully.
@
text
@d2 1
a2 1
# $OpenBSD: pkg-config,v 1.19 2006/12/16 17:14:34 espie Exp $
d326 1
d329 1
a329 1
		return join(',', @@$list)
d453 2
a454 1
		    stringize($cfg->get_property('Description', $variables)));
@


1.19
log
@tweak slightly: not having the variable is okay, not finding the package
is still an error.
@
text
@d2 1
a2 1
# $OpenBSD: pkg-config,v 1.18 2006/12/16 11:14:24 espie Exp $
d426 2
d444 5
d454 1
a454 1
	return 0;
@


1.18
log
@it's not an error for a variable not to be defined for some/all of the
*.pc files, see x11/gnome/yelp.
@
text
@d2 1
a2 1
# $OpenBSD: pkg-config,v 1.17 2006/12/14 22:45:21 espie Exp $
d346 1
d348 1
a348 1
	return undef;
@


1.17
log
@do not display result if $rc != 0, fixes cases like
LIBS=`pkg-config --libs foo`, like in net/ekg
@
text
@d2 1
a2 1
# $OpenBSD: pkg-config,v 1.16 2006/12/14 10:23:34 espie Exp $
a344 1
			return undef;
d347 1
a347 1
	$rc = 1;
@


1.16
log
@add PKG_CONFIG_LIBDIR, okay bernd@@
@
text
@d2 1
a2 1
# $OpenBSD: pkg-config,v 1.15 2006/12/10 10:58:41 espie Exp $
d199 1
a199 1
    print join(' ', @@vlist), "\n";
@


1.15
log
@trivial change: comparing versions on a non-existent config is not a good
idea...
@
text
@d2 1
a2 1
# $OpenBSD: pkg-config,v 1.14 2006/12/09 17:16:06 espie Exp $
d27 4
a30 2
if (defined($ENV{'PKG_CONFIG_PATH'}) && $ENV{'PKG_CONFIG_PATH'}) {
	push(@@PKGPATH, split /:/, $ENV{'PKG_CONFIG_PATH'});
d34 2
a35 2
if (defined($ENV{'PKG_CONFIG_LOGFILE'}) && $ENV{'PKG_CONFIG_LOGFILE'}) {
	$logfile = $ENV{'PKG_CONFIG_LOGFILE'};
d39 1
a39 1
	defined $ENV{'PKG_CONFIG_DISABLE_UNINSTALLED'} ? 0 : 1;
d50 1
a50 1
    my $d = $ENV{'PKG_CONFIG_TOP_BUILD_DIR'};
@


1.14
log
@reorg code some more:
- handle most version number requirements.
- handle uninstalled packages correctly.
- process options in the same order as the gnu pkg-config.
- sanitize status code returns.
- set up printerr the same way gnu pkg-config does.

tested on xenocara by matthieu@@

Still missing: actual --static implementation, and possibly some other
details...
@
text
@d2 1
a2 1
# $OpenBSD: pkg-config,v 1.13 2006/12/04 22:05:41 espie Exp $
d213 5
a223 5
	}

	if (!defined $cfg) {
		$rc = 1;
		return undef;
@


1.13
log
@do the proper dance to order libary dependencies, let modversion do
what it should, start at proper version checking.

Also displays more diagnostic messages like the real pkg-config does.

okay ckuethe@@, matthieu@@, fries

(and a small extra addition of a mismatch diagnostic).

Make sure PkgConfig.pm is synch'ed! won't work otherwise.
@
text
@d2 1
a2 1
# $OpenBSD: pkg-config,v 1.12 2006/12/02 18:58:46 espie Exp $
d36 4
d47 8
a54 2
# defaults
$mode{printerr} = 1;
d74 1
a74 1
		'list-all' => \&do_list, #does not return
d79 1
a79 1
		'atleast-pkgconfig-version=s' => \$mode{minvers},
d91 3
a93 1
		'atleast-version=s' => \$mode{'atleast-version'},
d99 10
a109 1
self_version($mode{minvers}) if $mode{minvers}; #does not return
d113 1
d116 1
a116 2
$p =~ s/\s+/ /g;
$p =~ s/^\s//g;
d120 6
a125 12
if (defined $mode{exists}) {
	while (@@ARGV) {
		my $p = shift @@ARGV;
		my $cfg = cache_find_config($p);
		exit 1 if !defined $cfg;
		if (@@ARGV >= 2  && $ARGV[0] =~ /[<=>]+/ &&
		    $ARGV[1] =~ /[0-9\.]+/) {
			$rc = 1 unless versionmatch($cfg, @@ARGV);
			shift @@ARGV; shift @@ARGV;
		}
	}
	exit $rc;
d129 1
a129 1
my @@vlist = ();
d142 10
a151 2
	do_modversion($p) if defined $mode{modversion};
	do_variable($p, $mode{variable}) if $mode{variable};
d154 5
a158 1
my $cfg_list = simplify_and_reverse($cfg_full_list);
d160 37
a196 3
if ($mode{cflags} || $mode{libs}|| $mode{variable}) {
    push @@vlist, do_cflags() if $mode{cflags};
    push @@vlist, do_libs() if $mode{libs};
d221 4
a224 1
	return undef if !defined $cfg;
d259 11
d369 2
d373 1
a373 1
	foreach my $pkg (@@$cfg_list) {
d387 1
d393 2
d397 1
a397 1
	foreach my $pkg (@@$cfg_list) {
d445 1
a445 1
	exit 0;
d490 1
a490 1
		exit 0;
d492 10
a501 1
		exit 1;
d503 12
d520 1
a520 1
	my ($cfg, $op, $ver) = @@_;
a521 2
	# XXX assumes op is >= for now.

d525 1
a525 1
	my $v = stringize($cfg->get_property('Version', $variables));
d528 1
a528 1
	return 0 if $v eq '';
d530 16
a545 16
	print "comparing $ver (wanted) to $v (installed)\n" if $D;
	my @@inst = split /\./, $v;
	my @@want = split /\./, $ver;

	while (@@inst && @@want) { #so long as both lists have something
		# bail if the requested version element beats existing
		return 1 if $inst[0] > $want[0];
		return 0 if $inst[0] < $want[0];
		shift @@inst; shift @@want;
	}
	# the version at least equals the requested. if the requested
	# version has some micropatchlevel beyond the existing version,
	# return failure
	return 0 if @@want;
	# and after all that, the version is good enough
	return 1;
@


1.12
log
@typo in error message
@
text
@d2 1
a2 1
# $OpenBSD: pkg-config,v 1.11 2006/12/02 18:28:22 espie Exp $
a38 1
my $cfg_list = [];
d82 1
a82 1
		'modversion:s' => \$mode{modversion},
d89 2
a90 8
if (defined $mode{modversion}) {
	if ($mode{modversion}) {
		do_modversion($mode{modversion}) ; #does not return
	} else {
		print $version . "\n";
		exit 0;
	}
}
d101 7
a107 7
		if ((@@ARGV >= 2)  && ($ARGV[1] =~ /[<=>]+/) &&
		    ($ARGV[2] =~ /[0-9\.]+/)) {
			exit 1 unless versionmatch(@@ARGV);
			shift @@ARGV; shift @@ARGV; shift @@ARGV;
		} else {
			exit 1 unless pathresolve($ARGV[0]);
			shift @@ARGV;
d110 1
a110 1
	exit 0;
d113 2
a114 1
do_variable($ARGV[0], $mode{variable}) if $mode{variable};
d117 7
a123 5
	my $p = $ARGV[0];
	if ((@@ARGV >= 2)  && ($ARGV[1] =~ /[<=>]+/) &&
	    ($ARGV[2] =~ /[0-9\.]+/)) {
		shift @@ARGV;
		shift @@ARGV;
a124 1
	shift @@ARGV;
d126 3
a128 1
	handle_config($p);
d131 6
a136 5
if ($mode{cflags} || $mode{libs}) {
    my @@l = ();
    push @@l, do_cflags() if $mode{cflags};
    push @@l, do_libs() if $mode{libs};
    print join(' ', @@l), "\n";
d139 1
a139 1
exit 0;
d145 2
a146 1
	my $p = shift;
d148 1
a148 1
	return if $configs{$p};
d150 1
a150 2
	print STDERR "processing $p\n" if $D;
	my $cfg = find_config($p);
d152 6
a157 3
	if (!defined $cfg) {
		warn "can't find $p\n" if $mode{printerr};
		exit 1;
a158 1
	return undef if defined $mode{exists};
d160 1
a160 2
	push(@@$cfg_list, $p);
	$configs{$p} = $cfg;
d164 7
a170 2
		# XXX don't handle version yet
		map { s/\s*[<=>]+\s*[\d\.]+//; handle_config($_) } @@$deps;
d177 7
a183 2
		# XXX don't handle version yet
		map { s/\s*[<=>]+\s*[\d\.]+//; handle_config($_) } @@$deps;
d219 13
d239 4
d262 3
a264 1
	if (my $cfg = find_config($p)) {
d267 2
a268 2
			print $value, "\n";
			exit 1;
d271 1
a271 1
	exit 0;
d279 3
a281 1
	if (my $cfg = find_config($p)) {
d285 1
a285 1
			exit 1;
d288 1
a288 1
	exit 0;
d321 1
a321 1
	return OpenBSD::PkgConfig->compress($libs,
d324 1
a324 2
			if (($mode{libs} & 1) && /^-l/ ||
			    ($mode{libs} & 2) && /^-L/ ||
d331 7
d419 1
a419 1
	my ($pname, $op, $ver) = @@_;
d421 2
a422 2
	print STDERR "pname = '$pname'\n" if  $D;
	my $cfg = find_config($pname);
a425 2
	$configs{$pname} = $cfg;

d447 23
@


1.11
log
@rely on PkgConfig.pm, and so really parse the *.pc files.

handle --define-variable

handle multiple dependencies in the correct order, so that linking will
work with complex requirements.

okay ckuethe@@, matthieu@@
@
text
@d2 1
a2 1
# $OpenBSD: pkg-config,v 1.10 2006/12/01 19:32:31 espie Exp $
d205 1
a205 1
		print STDERR $@@, "\n" if $@@;
@


1.10
log
@make things vaguely declared where they belong
@
text
@d2 1
a2 1
# $OpenBSD: pkg-config,v 1.9 2006/11/28 03:30:28 ckuethe Exp $
d23 1
d39 1
d41 1
d45 1
a45 1
$mode{'printerr'} = 1;
d67 15
a81 15
		'errors-to-stdout' => sub { $mode{'estdout'} = 1},
		'print-errors' => sub { $mode{'printerr'} = 1},
		'silence-errors' => sub { $mode{'printerr'} = 0},
		'atleast-pkgconfig-version=s' => \$mode{'minvers'},

		'cflags' => sub { $mode{'cflags'} = 3},
		'cflags-only-I' => sub { $mode{'cflags'} |= 1},
		'cflags-only-other' => sub { $mode{'cflags'} |= 2},
		'libs' => sub { $mode{'libs'} = 7},
		'libs-only-l' => sub { $mode{'libs'} |= 1},
		'libs-only-L' => sub { $mode{'libs'} |= 2},
		'libs-only-other' => sub { $mode{'libs'} |= 4},
		'exists' => sub { $mode{'exists'} = 1} ,
		'static' => sub { $mode{'static'} = 1},
		'uninstalled' => sub { $mode{'uninstalled'} = 1},
d83 3
a85 2
		'modversion:s' => \$mode{'modversion'},
		'variable=s' => \$mode{'variable'}
d89 4
a92 4
self_version($mode{'minvers'}) if $mode{'minvers'}; #does not return
if (defined $mode{'modversion'}) {
	if ($mode{'modversion'}) {
		do_modversion($mode{'modversion'}) ; #does not return
d106 1
a106 1
if (defined $mode{'exists'}) {
d120 1
a120 1
do_variable($ARGV[0], $mode{'variable'}) if $mode{'variable'};
d131 2
a132 26
	unless ($configs{$p}) { # don't reprocess things we've seen
		print STDERR "processing $p\n" if $D;
		if (my $f = pathresolve($p)) { # locate the .pc file
			exit 0 if defined $mode{'exists'};
	
			$configs{$p} = slurp($f); # load the config
			my $deps = '';
			if ($configs{$p} =~ /\bRequires: +(\w.+?)\n/) {
				$deps = $1;
				# XXX how should i handle versions?
				$deps =~ s/[<>=]+\s*[0-9\.]+\s*//;
				$deps =~ tr/,/ /;
			}
			print STDERR "package $p requires '$deps'\n"
			    if $D && $deps;
			push(@@ARGV, split /\s+/, $deps) if $deps;

			my $privdeps = '';
			if ($configs{$p} =~ /\bRequires\.private: +(\w.+?)\n/) {
				$privdeps = $1;
				# XXX how should i handle versions?
				$privdeps =~ s/[<>=]+\s*[0-9\.]+\s*//;
			}
			print STDERR "package $p requires (private) '" .
			    $privdeps . "'\n" if $D && $privdeps;
			push(@@ARGV, split /\s+/, $privdeps) if $privdeps;
d134 5
a138 5
		} else {
			warn "can't find $p\n" if $mode{'printerr'};
			exit 1;
		}
	}
a140 3
do_cflags() if $mode{'cflags'};
do_libs() if $mode{'libs'};

d145 35
d194 25
d220 1
a220 2
# Given a filename, return its contents. Also do variable substitutions.
sub slurp
d222 1
a222 1
	my ($f) = @@_;
d224 4
a227 23
	local $/ = undef;
	open my $F, '<', $f or return undef;
	print STDERR "slurp($f) OK\n" if $D;
	$f = <$F>;
	close $F;
	$f = varsub($f);
	return $f;
}

# Do variable substitutions, so if "target=x11" is present (for example),
# any lines referring to $target are filled in properly.
sub varsub
{
	my ($buf) = @@_;

	my ($var, $val);

	while ($buf =~ /\${(\w+)}/gsm) {
		$var = $1;
		if ($buf =~ /${var}=(.+?)\n/s) {
			$val = $1;
			$buf =~ s/\${$var}/$val/g;
		}
a228 1
	return $buf;
d234 1
a234 2
	my ($p, $v, undef) = @@_;
	my ($f);
d236 7
a242 5
	exit 1 unless $f = pathresolve($p);
	exit 1 unless $f = slurp($f);

	exit 1 unless $f =~ /\b${v}=(.+?)\n/;
	print "$1\n";
d249 1
a249 2
	my ($p, undef) = @@_;
	my ($f);
d251 7
a257 5
	exit 1 unless $f = pathresolve($p);
	exit 1 unless $f = slurp($f);

	exit 1 unless $f =~ /\bVersion:\s+(.+?)\n/;
	print "$1\n";
d264 1
a264 2
	my %words; # store them as a hash to get de-duplicating
	my @@out;
d266 12
a277 4
	foreach my $p (keys %configs) {
		if ($configs{$p} =~ /\bCflags:\s+(.+?)\n/) {
			foreach my $q (split /\s+/, $1) { 
				$words{$q}=1;
d279 1
a279 8
		}
	}
	foreach my $k (sort keys %words) {
		push(@@out, $k) if $k =~ /^-I/ && ($mode{'cflags'} & 1);
		push(@@out, $k) if $k =~ /^-[^I]/ && ($mode{'cflags'} & 2);
	}
	print join(' ', @@out), "\n";
	return undef;
d285 1
a285 2
	my %words; # store them as a hash to get de-duplicating
	my @@out;
d287 13
a299 4
	foreach my $p (keys %configs) {
		if ($configs{$p} =~ /\bLibs:\s+(.+?)\n/) {
			foreach my $q (split /\s+/, $1) { 
				$words{$q}=1;
d301 1
a301 9
		}
	}
	foreach my $k (sort keys %words) {
		push(@@out, $k) if $k =~ /^-l/ && ($mode{'libs'} & 1);
		push(@@out, $k) if $k =~ /^-L/ && ($mode{'libs'} & 2);
		push(@@out, $k) if $k =~ /^-[^lL]/ && ($mode{'libs'} & 4);
	}
	print join(' ', @@out), "\n";
	return undef;
d323 1
a323 1
		$p = slurp($f);
d325 3
a327 6
		if ($p =~ /Name: (\w[^\n]+)\n/gm) {
			$name = $1;
			if ($p =~ /Description:\s+(\w[^\n]+)\n/gm) {
				printf("%${x}s %s - %s\n", $fname, $name, $1);
			}
		}
d348 1
d383 1
a383 2
	my ($pname, $op, $ver, undef) = @@_;
	my (@@want, @@inst, $m, $f);
d386 1
d388 6
a393 3
	return 0 unless $f = pathresolve($pname);
	# load the file
	$configs{$pname} = slurp($f);
d395 1
a395 1
	return 0 unless $configs{$pname} =~ /Version: ([0-9\.]+)\n/gm;
d397 3
a399 3
	print "comparing $ver (wanted) to $1 (installed)\n" if $D;
	@@inst = split /\./, $1;
	@@want = split /\./, $ver;
@


1.9
log
@Remove a debug print i accidentally left behind
@
text
@d2 1
a2 1
# $OpenBSD: pkg-config,v 1.8 2006/11/28 01:59:42 ckuethe Exp $
d35 5
a39 7
our $version = 0.19; # pretend to be this version of pkgconfig
my $parse_args = 1;
my ($deps, $privdeps, $var, $val, $p, $f);

our %configs = ();
our %mode = ();
our $D = 0; # debug flag
a43 1
$/ = undef;
d95 2
a96 1
$p = join(' ', @@ARGV);
d100 1
d119 1
a119 1
	$p = $ARGV[0];
d129 1
a129 1
		if ($f = pathresolve($p)) { # locate the .pc file
d133 1
a133 1
			$deps = '';
d144 1
a144 1
			$privdeps = '';
d175 1
a175 1
		$f = "$d/$p.pc";
d177 1
a177 2
		last if -f $f;
		$f = undef;
d179 1
a179 1
	return $f;
d188 1
@


1.8
log
@Sync usage with manpage
@
text
@d2 1
a2 1
# $OpenBSD: pkg-config,v 1.7 2006/11/28 01:54:14 ckuethe Exp $
a234 2

	print "\$p ='$p'\n";
@


1.7
log
@Add the --silence-errors option. Found by naddy@@
@
text
@d2 1
a2 1
# $OpenBSD: pkg-config,v 1.6 2006/11/28 01:36:17 ckuethe Exp $
d328 4
a332 1
--variable var package - return the definition of <var> in <package>
d342 4
@


1.6
log
@Allow "pkg-config --modversion" to work. Reported by naddy@@
@
text
@d2 1
a2 1
# $OpenBSD: pkg-config,v 1.5 2006/11/27 23:57:51 ckuethe Exp $
d43 3
d69 1
d156 1
a156 1
			warn "can't find $p\n";
@


1.5
log
@$OpenBSD$ tag
@
text
@d2 1
a2 1
# $OpenBSD$
d79 1
a79 1
		'modversion=s' => \$mode{'modversion'},
d85 8
a92 1
do_modversion($mode{'modversion'}) if $mode{'modversion'}; #does not return
d231 2
@


1.4
log
@stylistic clean-ups.
look more like BSD style, open files correctly, remove lots of
extra parenthesis, do not depend on $_
@
text
@d2 1
@


1.3
log
@When a package is not found, exit with an error code. Allows things like
neon and subversion to build.
@
text
@d21 1
d25 2
a26 2
if (defined($ENV{'PKG_CONFIG_PATH'}) && $ENV{'PKG_CONFIG_PATH'}){
	push(@@PKGPATH, split(/:/,$ENV{'PKG_CONFIG_PATH'}));
d30 1
a30 1
if (defined($ENV{'PKG_CONFIG_LOGFILE'}) && $ENV{'PKG_CONFIG_LOGFILE'}){
d43 4
a46 4
if ($logfile){
	open (L, ">>" . $logfile);
	print L '[' . join('] [', $0, @@ARGV) . "]\n";
	close(L);
d82 3
a84 3
print STDERR "\n[" . join('] [', $0, @@ARGV) . "]\n" if ($D);
self_version($mode{'minvers'}) if ($mode{'minvers'}); #does not return
do_modversion($mode{'modversion'}) if ($mode{'modversion'}); #does not return
d89 1
a89 1
@@ARGV = split(/\s+/, $p);
d91 2
a92 2
if (defined($mode{'exists'})){
	while (@@ARGV){
d94 3
a96 3
		    ($ARGV[2] =~ /[0-9\.]+/)){
			exit 1 unless (versionmatch(@@ARGV));
			shift(@@ARGV); shift(@@ARGV); shift(@@ARGV);
d98 2
a99 2
			exit 1 unless (pathresolve($ARGV[0]));
			shift(@@ARGV);
d102 1
a102 1
	exit(0);
d105 1
a105 1
do_variable($ARGV[0],$mode{'variable'}) if ($mode{'variable'});
d110 3
a112 3
	    ($ARGV[2] =~ /[0-9\.]+/)){
		shift(@@ARGV);
		shift(@@ARGV);
d114 1
a114 1
	shift(@@ARGV);
d116 4
a119 4
	unless ($configs{$p}){ # don't reprocess things we've seen
		print STDERR "processing $p\n" if ($D);
		if ($f = pathresolve($p)){ # locate the .pc file
			exit(0) if (defined($mode{'exists'}));
d123 1
a123 1
			if ($configs{$p} =~ /\bRequires: +(\w.+?)\n/){
d130 2
a131 2
			    if ($D && $deps);
			push(@@ARGV, split(/\s+/,$deps)) if ($deps);
d134 1
a134 1
			if ($configs{$p} =~ /\bRequires\.private: +(\w.+?)\n/){
d140 2
a141 2
			    $privdeps . "'\n" if ($D && $privdeps);
			push(@@ARGV, split(/\s+/,$privdeps)) if ($privdeps);
d144 2
a145 2
			warn("can't find $p\n");
			exit(1);
d150 2
a151 2
do_cflags() if ($mode{'cflags'});
do_libs() if ($mode{'libs'});
d153 1
a153 1
exit(0);
d159 8
a166 8
sub pathresolve{
	my ($p);

	$p = shift;
	foreach (@@PKGPATH){
		$f = $_ . '/' . ${p} . '.pc';
		print STDERR "pathresolve($p) looking in $f\n" if ($D);
		last if (-f $f);
d174 8
a181 8
sub slurp{
	my ($f);

	$f = shift;
	open(F, $f) or return undef;
	print STDERR "slurp($f) OK\n" if ($D);
	$f = <F>;
	close(F);
d188 4
a191 1
sub varsub{
d194 1
a194 2
	my $buf = shift;
	while ($buf =~ /\${(\w+)}/gsm){
d196 1
a196 1
		if ($buf =~ /${var}=(.+?)\n/s){
d205 2
a206 1
sub do_variable{
d210 2
a211 2
	exit(1) unless ($f = pathresolve($p));
	exit(1) unless ($f = slurp($f));
d213 1
a213 1
	exit(1) unless ($f =~ /\b${v}=(.+?)\n/);
d215 1
a215 1
	exit(0);
d219 2
a220 1
sub do_modversion{
d224 2
a225 2
	exit(1) unless ($f = pathresolve($p));
	exit(1) unless ($f = slurp($f));
d227 1
a227 1
	exit(1) unless ($f =~ /\bVersion:\s+(.+?)\n/);
d229 1
a229 1
	exit(0);
d233 2
a234 1
sub do_cflags{
d238 5
a242 3
	foreach my $p (keys %configs){
		if ($configs{$p} =~ /\bCflags:\s+(.+?)\n/){
			foreach (split(/\s+/, $1)){ $words{$_}=1; }
d245 3
a247 3
	foreach (sort keys %words){
		push(@@out, $_) if (/^-I/ && ($mode{'cflags'} & 1));
		push(@@out, $_) if (/^-[^I]/ && ($mode{'cflags'} & 2));
d249 2
a250 1
	printf("%s\n", join(' ', @@out));
d254 2
a255 1
sub do_libs{
d259 5
a263 3
	foreach my $p (keys %configs){
		if ($configs{$p} =~ /\bLibs:\s+(.+?)\n/){
			foreach (split(/\s+/, $1)){ $words{$_}=1; }
d266 4
a269 4
	foreach (sort keys %words){
		push(@@out, $_) if (/^-l/ && ($mode{'libs'} & 1));
		push(@@out, $_) if (/^-L/ && ($mode{'libs'} & 2));
		push(@@out, $_) if (/^-[^lL]/ && ($mode{'libs'} & 4));
d271 2
a272 1
	printf("%s\n", join(' ', @@out));
d276 2
a277 1
sub do_list{
d279 3
a281 1
	foreach (@@PKGPATH){ push(@@files, <$_/*.pc>); }
d286 3
a288 4
	foreach (@@files){
		$fname = (split(/\//, $_))[-1];
		$fname =~ s/\.pc$//;
		$y = length($fname);
d293 4
a296 5
	foreach (@@files){
		$p = slurp($_);
		$fname = (split(/\//, $_))[-1];
		$fname =~ s/\.pc$//;
		if ($p =~ /Name: (\w[^\n]+)\n/gm){
d298 1
a298 1
			if ($p =~ /Description:\s+(\w[^\n]+)\n/gm){
d303 1
a303 1
	exit(0);
d306 2
a307 2
sub help{
	my ($unused);
d327 1
a327 1
	exit(1);
d331 7
a337 5
sub self_version{
	my (@@a, @@b, $v);
	$v = shift;
	@@a = split(/\./, $v);
	@@b = split(/\./, $version);
d339 2
a340 2
	if (($b[0] >= $a[0]) && ($b[1] >= $a[1])){
		exit(0);
d342 1
a342 1
		exit(1);
d347 2
a348 1
sub versionmatch{
d352 1
a352 1
	print STDERR "pname = '$pname'\n" if ($D);
d354 1
a354 1
	return 0 unless ($f = pathresolve($pname));
d358 1
a358 1
	return 0 unless ($configs{$pname} =~ /Version: ([0-9\.]+)\n/gm);
d360 3
a362 3
	print "comparing $ver (wanted) to $1 (installed)\n" if ($D);
	@@inst = split(/\./, $1);
	@@want = split(/\./, $ver);
d364 1
a364 1
	while (@@inst && @@want){ #so long as both lists have something
d366 3
a368 3
		return 1 if ($inst[0] > $want[0]);
		return 0 if ($inst[0] < $want[0]);
		shift(@@inst); shift(@@want);
d373 1
a373 1
	return 0 if (@@want);
@


1.2
log
@Don't search in non-openbsd-default paths - that's what PKG_CONFIG_PATH
is for.
@
text
@a142 1
			exit(1) if (defined($mode{'exists'}));
d144 1
@


1.1
log
@Yet Another pkg-config program, this time as a perl script.

Not all flags and options are implemented yet, but it works well enough
to build a bunch of ports and xenocara (which requires pkg-config).

It is not yet activated in the build; I'm committing to allow for in-tree
development (including a man page).

ok espie, matthieu
@
text
@a22 1
push(@@PKGPATH, '/usr/local/libdata/pkgconfig', '/usr/X11R6/libdata/pkgconfig');
@

