head	1.22;
access;
symbols
	OPENBSD_6_1:1.22.0.6
	OPENBSD_6_1_BASE:1.22
	OPENBSD_6_0:1.22.0.4
	OPENBSD_6_0_BASE:1.22
	OPENBSD_5_9:1.22.0.2
	OPENBSD_5_9_BASE:1.22
	OPENBSD_5_8:1.19.0.6
	OPENBSD_5_8_BASE:1.19
	OPENBSD_5_7:1.19.0.2
	OPENBSD_5_7_BASE:1.19
	OPENBSD_5_6:1.18.0.18
	OPENBSD_5_6_BASE:1.18
	OPENBSD_5_5:1.18.0.16
	OPENBSD_5_5_BASE:1.18
	OPENBSD_5_4:1.18.0.12
	OPENBSD_5_4_BASE:1.18
	OPENBSD_5_3:1.18.0.10
	OPENBSD_5_3_BASE:1.18
	OPENBSD_5_2:1.18.0.8
	OPENBSD_5_2_BASE:1.18
	OPENBSD_5_1_BASE:1.18
	OPENBSD_5_1:1.18.0.6
	OPENBSD_5_0:1.18.0.4
	OPENBSD_5_0_BASE:1.18
	OPENBSD_4_9:1.18.0.2
	OPENBSD_4_9_BASE:1.18
	OPENBSD_4_8:1.17.0.4
	OPENBSD_4_8_BASE:1.17
	OPENBSD_4_7:1.17.0.2
	OPENBSD_4_7_BASE:1.17
	OPENBSD_4_6:1.16.0.12
	OPENBSD_4_6_BASE:1.16
	OPENBSD_4_5:1.16.0.8
	OPENBSD_4_5_BASE:1.16
	OPENBSD_4_4:1.16.0.6
	OPENBSD_4_4_BASE:1.16
	OPENBSD_4_3:1.16.0.4
	OPENBSD_4_3_BASE:1.16
	OPENBSD_4_2:1.16.0.2
	OPENBSD_4_2_BASE:1.16
	OPENBSD_4_1:1.15.0.4
	OPENBSD_4_1_BASE:1.15
	OPENBSD_4_0:1.15.0.2
	OPENBSD_4_0_BASE:1.15
	OPENBSD_3_9:1.14.0.6
	OPENBSD_3_9_BASE:1.14
	OPENBSD_3_8:1.14.0.4
	OPENBSD_3_8_BASE:1.14
	OPENBSD_3_7:1.14.0.2
	OPENBSD_3_7_BASE:1.14
	OPENBSD_3_6:1.13.0.6
	OPENBSD_3_6_BASE:1.13
	OPENBSD_3_5:1.13.0.4
	OPENBSD_3_5_BASE:1.13
	OPENBSD_3_4:1.13.0.2
	OPENBSD_3_4_BASE:1.13
	OPENBSD_3_3:1.10.0.6
	OPENBSD_3_3_BASE:1.10
	OPENBSD_3_2:1.10.0.4
	OPENBSD_3_2_BASE:1.10
	OPENBSD_3_1:1.10.0.2
	OPENBSD_3_1_BASE:1.10
	OPENBSD_3_0:1.8.0.6
	OPENBSD_3_0_BASE:1.8
	OPENBSD_2_9_BASE:1.8
	OPENBSD_2_9:1.8.0.4
	OPENBSD_2_8:1.8.0.2
	OPENBSD_2_8_BASE:1.8
	OPENBSD_2_7:1.7.0.4
	OPENBSD_2_7_BASE:1.7
	OPENBSD_2_6:1.7.0.2
	OPENBSD_2_6_BASE:1.7
	OPENBSD_2_5:1.5.0.2
	OPENBSD_2_5_BASE:1.5
	OPENBSD_2_4:1.4.0.8
	OPENBSD_2_4_BASE:1.4
	OPENBSD_2_3:1.4.0.6
	OPENBSD_2_3_BASE:1.4
	OPENBSD_2_2:1.4.0.4
	OPENBSD_2_2_BASE:1.4
	OPENBSD_2_1:1.4.0.2
	OPENBSD_2_1_BASE:1.4
	OPENBSD_2_0:1.2.0.2
	OPENBSD_2_0_BASE:1.2
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.22
date	2015.12.09.19.39.10;	author mmcc;	state Exp;
branches;
next	1.21;
commitid	vYfMHQk0uPOMI7wA;

1.21
date	2015.10.09.01.37.08;	author deraadt;	state Exp;
branches;
next	1.20;
commitid	sbrB3Q5CNxcwZpfU;

1.20
date	2015.10.07.14.12.42;	author deraadt;	state Exp;
branches;
next	1.19;
commitid	AB7wgrUfn7UclTwo;

1.19
date	2014.11.25.10.20.24;	author tobias;	state Exp;
branches;
next	1.18;
commitid	VBrLCVulh6nFPEfA;

1.18
date	2010.08.12.05.02.52;	author tedu;	state Exp;
branches;
next	1.17;

1.17
date	2009.10.27.23.59.41;	author deraadt;	state Exp;
branches;
next	1.16;

1.16
date	2007.08.06.19.16.06;	author sobrado;	state Exp;
branches;
next	1.15;

1.15
date	2006.05.04.05.55.33;	author ray;	state Exp;
branches;
next	1.14;

1.14
date	2004.10.10.03.29.29;	author mickey;	state Exp;
branches;
next	1.13;

1.13
date	2003.07.10.00.06.51;	author david;	state Exp;
branches;
next	1.12;

1.12
date	2003.06.10.22.20.49;	author deraadt;	state Exp;
branches;
next	1.11;

1.11
date	2003.06.03.02.56.14;	author millert;	state Exp;
branches;
next	1.10;

1.10
date	2002.02.16.21.27.51;	author millert;	state Exp;
branches;
next	1.9;

1.9
date	2001.11.19.19.02.15;	author mpech;	state Exp;
branches;
next	1.8;

1.8
date	2000.06.07.14.20.15;	author aaron;	state Exp;
branches;
next	1.7;

1.7
date	99.08.24.18.49.45;	author aaron;	state Exp;
branches;
next	1.6;

1.6
date	99.08.23.23.58.23;	author aaron;	state Exp;
branches;
next	1.5;

1.5
date	98.11.16.06.09.12;	author deraadt;	state Exp;
branches;
next	1.4;

1.4
date	97.01.17.07.13.02;	author millert;	state Exp;
branches;
next	1.3;

1.3
date	97.01.15.23.43.02;	author millert;	state Exp;
branches;
next	1.2;

1.2
date	96.06.26.05.37.50;	author deraadt;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.45.54;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.45.54;	author deraadt;	state Exp;
branches;
next	;


desc
@@


1.22
log
@Remove NULL-checks before free(). ok tb@@
@
text
@/*	$OpenBSD: paste.c,v 1.21 2015/10/09 01:37:08 deraadt Exp $	*/

/*
 * Copyright (c) 1989 The Regents of the University of California.
 * All rights reserved.
 *
 * This code is derived from software contributed to Berkeley by
 * Adam S. Moskowitz of Menlo Consulting.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */

#include <sys/queue.h>
#include <sys/types.h>
#include <err.h>
#include <errno.h>
#include <limits.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>

char *delim;
int delimcnt;

int	tr(char *);
void	usage(void);
void	parallel(char **);
void	sequential(char **);

int
main(int argc, char *argv[])
{
	extern char *optarg;
	extern int optind;
	int ch, seq;

	if (pledge("stdio rpath", NULL) == -1)
		err(1, "pledge");

	seq = 0;
	while ((ch = getopt(argc, argv, "d:s")) != -1) {
		switch (ch) {
		case 'd':
			delimcnt = tr(delim = optarg);
			break;
		case 's':
			seq = 1;
			break;
		case '?':
		default:
			usage();
		}
	}
	argc -= optind;
	argv += optind;

	if (!delim) {
		delimcnt = 1;
		delim = "\t";
	}

	if (seq)
		sequential(argv);
	else
		parallel(argv);
	exit(0);
}

struct list {
	SIMPLEQ_ENTRY(list) entries;
	FILE *fp;
	int cnt;
	char *name;
};

void
parallel(char **argv)
{
	SIMPLEQ_HEAD(, list) head = SIMPLEQ_HEAD_INITIALIZER(head);
	struct list *lp;
	int cnt;
	char ch, *p;
	int opencnt, output;
	char *buf, *lbuf;
	size_t len;

	for (cnt = 0; (p = *argv); ++argv, ++cnt) {
		if (!(lp = malloc(sizeof(struct list))))
			err(1, "malloc");

		if (p[0] == '-' && !p[1])
			lp->fp = stdin;
		else if (!(lp->fp = fopen(p, "r")))
			err(1, "%s", p);
		lp->cnt = cnt;
		lp->name = p;
		SIMPLEQ_INSERT_TAIL(&head, lp, entries);
	}

	for (opencnt = cnt; opencnt;) {
		output = 0;
		SIMPLEQ_FOREACH(lp, &head, entries) {
			lbuf = NULL;
			if (!lp->fp) {
				if (output && lp->cnt &&
				    (ch = delim[(lp->cnt - 1) % delimcnt]))
					putchar(ch);
				continue;
			}
			if (!(buf = fgetln(lp->fp, &len))) {
				if (!--opencnt)
					break;
				if (lp->fp != stdin)
					(void)fclose(lp->fp);
				lp->fp = NULL;
				if (output && lp->cnt &&
				    (ch = delim[(lp->cnt - 1) % delimcnt]))
					putchar(ch);
				continue;
			}
			if (buf[len - 1] == '\n')
				buf[len - 1] = '\0';
			else {
				if ((lbuf = malloc(len + 1)) == NULL)
					err(1, "malloc");
				memcpy(lbuf, buf, len);
				lbuf[len] = '\0';
				buf = lbuf;
			}
			/*
			 * make sure that we don't print any delimiters
			 * unless there's a non-empty file.
			 */
			if (!output) {
				output = 1;
				for (cnt = 0; cnt < lp->cnt; ++cnt)
					if ((ch = delim[cnt % delimcnt]))
						putchar(ch);
			} else if ((ch = delim[(lp->cnt - 1) % delimcnt]))
				putchar(ch);
			(void)printf("%s", buf);
			if (lbuf)
				free(lbuf);
		}
		if (output)
			putchar('\n');
	}
}

void
sequential(char **argv)
{
	FILE *fp;
	int cnt;
	char ch, *p, *dp;
	char *buf, *lbuf;
	size_t len;

	for (; (p = *argv); ++argv) {
		lbuf = NULL;
		if (p[0] == '-' && !p[1])
			fp = stdin;
		else if (!(fp = fopen(p, "r"))) {
			warn("%s", p);
			continue;
		}
		if ((buf = fgetln(fp, &len))) {
			for (cnt = 0, dp = delim;;) {
				if (buf[len - 1] == '\n')
					buf[len - 1] = '\0';
				else {
					if ((lbuf = malloc(len + 1)) == NULL)
						err(1, "malloc");
					memcpy(lbuf, buf, len);
					lbuf[len] = '\0';
					buf = lbuf;
				}
				(void)printf("%s", buf);
				if (!(buf = fgetln(fp, &len)))
					break;
				if ((ch = *dp++))
					putchar(ch);
				if (++cnt == delimcnt) {
					dp = delim;
					cnt = 0;
				}
			}
			putchar('\n');
		}
		if (fp != stdin)
			(void)fclose(fp);
		free(lbuf);
	}
}

int
tr(char *arg)
{
	int cnt;
	char ch, *p;

	for (p = arg, cnt = 0; (ch = *p++); ++arg, ++cnt) {
		if (ch == '\\') {
			switch (ch = *p++) {
			case 'n':
				*arg = '\n';
				break;
			case 't':
				*arg = '\t';
				break;
			case '0':
				*arg = '\0';
				break;
			default:
				*arg = ch;
				break;
			}
		} else
			*arg = ch;
	}

	if (!cnt)
		errx(1, "no delimiters specified");
	return (cnt);
}

void
usage(void)
{
	extern char *__progname;
	(void)fprintf(stderr, "usage: %s [-s] [-d list] file ...\n",
	    __progname);
	exit(1);
}
@


1.21
log
@Change all tame callers to namechange to pledge(2).
@
text
@d1 1
a1 1
/*	$OpenBSD: paste.c,v 1.20 2015/10/07 14:12:42 deraadt Exp $	*/
d215 1
a215 2
		if (lbuf)
			free(lbuf);
@


1.20
log
@tame "stdio rpath", satisfies the fopen cases
ok semarie
@
text
@d1 1
a1 1
/*	$OpenBSD: paste.c,v 1.19 2014/11/25 10:20:24 tobias Exp $	*/
d60 2
a61 2
	if (tame("stdio rpath", NULL) == -1)
		err(1, "tame");
@


1.19
log
@Release file descriptors as soon as they are not needed anymore.

ok millert
@
text
@d1 1
a1 1
/*	$OpenBSD: paste.c,v 1.18 2010/08/12 05:02:52 tedu Exp $	*/
d59 3
@


1.18
log
@make fgetln fixups look like the man page.  correct a pair of brances and
some other style tweaks
@
text
@d1 1
a1 1
/*	$OpenBSD: paste.c,v 1.17 2009/10/27 23:59:41 deraadt Exp $	*/
d133 2
@


1.17
log
@rcsid[] and sccsid[] and copyright[] are essentially unmaintained (and
unmaintainable).  these days, people use source.  these id's do not provide
any benefit, and do hurt the small install media
(the 33,000 line diff is essentially mechanical)
ok with the idea millert, ok dms
@
text
@d1 1
a1 1
/*	$OpenBSD: paste.c,v 1.16 2007/08/06 19:16:06 sobrado Exp $	*/
d61 2
a62 2
	while ((ch = getopt(argc, argv, "d:s")) != -1)
		switch(ch) {
d73 1
d139 2
a140 2
			if (*(buf + len - 1) == '\n')
				*(buf + len - 1) = '\0';
d187 2
a188 2
				if (*(buf + len - 1) == '\n')
					*(buf + len - 1) = '\0';
d221 3
a223 3
	for (p = arg, cnt = 0; (ch = *p++); ++arg, ++cnt)
		if (ch == '\\')
			switch(ch = *p++) {
d236 1
d239 1
d243 1
a243 1
	return(cnt);
@


1.16
log
@the ellipsis is not an optional argument; while here, sync the usage
and synopsis of commands

lots of good ideas by jmc@@

ok jmc@@
@
text
@d1 1
a1 1
/*	$OpenBSD: paste.c,v 1.15 2006/05/04 05:55:33 ray Exp $	*/
a33 11

#ifndef lint
char copyright[] =
"@@(#) Copyright (c) 1989 The Regents of the University of California.\n\
 All rights reserved.\n";
#endif /* not lint */

#ifndef lint
/*static char sccsid[] = "from: @@(#)paste.c	5.7 (Berkeley) 10/30/90";*/
static char rcsid[] = "$OpenBSD: paste.c,v 1.15 2006/05/04 05:55:33 ray Exp $";
#endif /* not lint */
@


1.15
log
@Use queue(3) macros instead of custom queue.

OK beck@@
@
text
@d1 1
a1 1
/*	$OpenBSD: paste.c,v 1.14 2004/10/10 03:29:29 mickey Exp $	*/
d43 1
a43 1
static char rcsid[] = "$OpenBSD: paste.c,v 1.14 2004/10/10 03:29:29 mickey Exp $";
d258 2
a259 2
	(void)fprintf(stderr, "usage: %s [-s] [-d delimiters] file ...\n",
		      __progname);
@


1.14
log
@use err/warn
@
text
@d1 1
a1 1
/*	$OpenBSD: paste.c,v 1.13 2003/07/10 00:06:51 david Exp $	*/
d43 1
a43 1
static char rcsid[] = "$OpenBSD: paste.c,v 1.13 2003/07/10 00:06:51 david Exp $";
d46 1
d99 2
a100 2
typedef struct _list {
	struct _list *next;
d104 1
a104 1
} LIST;
d109 2
a110 1
	LIST *lp;
a112 1
	LIST *head, *tmp;
d117 2
a118 2
	for (cnt = 0, head = NULL; (p = *argv); ++argv, ++cnt) {
		if (!(lp = (LIST *)malloc((u_int)sizeof(LIST))))
a124 1
		lp->next = NULL;
d127 1
a127 6
		if (!head)
			head = tmp = lp;
		else {
			tmp->next = lp;
			tmp = lp;
		}
d131 2
a132 1
		for (output = 0, lp = head; lp; lp = lp->next) {
@


1.13
log
@add missing includes
ok deraadt@@ tedu@@
@
text
@d1 1
a1 1
/*	$OpenBSD: paste.c,v 1.12 2003/06/10 22:20:49 deraadt Exp $	*/
d43 1
a43 1
static char rcsid[] = "$OpenBSD: paste.c,v 1.12 2003/06/10 22:20:49 deraadt Exp $";
d117 3
a119 4
		if (!(lp = (LIST *)malloc((u_int)sizeof(LIST)))) {
			(void)fprintf(stderr, "paste: %s.\n", strerror(ENOMEM));
			exit(1);
		}
d122 2
a123 5
		else if (!(lp->fp = fopen(p, "r"))) {
			(void)fprintf(stderr, "paste: %s: %s.\n", p,
			    strerror(errno));
			exit(1);
		}
d157 1
a157 1
					err(1, NULL);
d196 1
a196 2
			(void)fprintf(stderr, "paste: %s: %s.\n", p,
			    strerror(errno));
d205 1
a205 1
						err(1, NULL);
d253 2
a254 4
	if (!cnt) {
		(void)fprintf(stderr, "paste: no delimiters specified.\n");
		exit(1);
	}
d261 3
a263 1
	(void)fprintf(stderr, "paste: [-s] [-d delimiters] file ...\n");
@


1.12
log
@mostly ansi cleanup; pval ok
@
text
@d1 1
a1 1
/*	$OpenBSD: paste.c,v 1.11 2003/06/03 02:56:14 millert Exp $	*/
d43 1
a43 1
static char rcsid[] = "$OpenBSD: paste.c,v 1.11 2003/06/03 02:56:14 millert Exp $";
d47 1
@


1.11
log
@Remove the advertising clause in the UCB license which Berkeley
rescinded 22 July 1999.  Proofed by myself and Theo.
@
text
@d1 1
a1 1
/*	$OpenBSD: paste.c,v 1.10 2002/02/16 21:27:51 millert Exp $	*/
d43 1
a43 1
static char rcsid[] = "$OpenBSD: paste.c,v 1.10 2002/02/16 21:27:51 millert Exp $";
d63 1
a63 3
main(argc, argv)
	int argc;
	char **argv;
d105 1
a105 2
parallel(argv)
	char **argv;
d186 1
a186 2
sequential(argv)
	char **argv;
d234 1
a234 2
tr(arg)
	char *arg;
d265 1
a265 1
usage()
@


1.10
log
@Part one of userland __P removal.  Done with a simple regexp with some minor hand editing to make comments line up correctly.  Another pass is forthcoming that handles the cases that could not be done automatically.
@
text
@d1 1
a1 1
/*	$OpenBSD: paste.c,v 1.9 2001/11/19 19:02:15 mpech Exp $	*/
d18 1
a18 5
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
d43 1
a43 1
static char rcsid[] = "$OpenBSD: paste.c,v 1.9 2001/11/19 19:02:15 mpech Exp $";
@


1.9
log
@kill more registers

millert@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: paste.c,v 1.8 2000/06/07 14:20:15 aaron Exp $	*/
d47 1
a47 1
static char rcsid[] = "$OpenBSD: paste.c,v 1.8 2000/06/07 14:20:15 aaron Exp $";
d61 4
a64 4
int	tr __P((char *));
void	usage __P((void));
void	parallel __P((char **));
void	sequential __P((char **));
@


1.8
log
@Check return value of malloc(). Also make the code clearer with respect to
setting lbuf = NULL; millert@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: paste.c,v 1.7 1999/08/24 18:49:45 aaron Exp $	*/
d47 1
a47 1
static char rcsid[] = "$OpenBSD: paste.c,v 1.7 1999/08/24 18:49:45 aaron Exp $";
d114 3
a116 3
	register LIST *lp;
	register int cnt;
	register char ch, *p;
d196 3
a198 3
	register FILE *fp;
	register int cnt;
	register char ch, *p, *dp;
d245 2
a246 2
	register int cnt;
	register char ch, *p;
@


1.7
log
@better fix; now if the last line in a file stream does not contain a newline,
construct a null-terminated copy of the buffer returned by fgetln() and process
it as normal
@
text
@d1 1
a1 1
/*	$OpenBSD: paste.c,v 1.6 1999/08/23 23:58:23 aaron Exp $	*/
d47 1
a47 1
static char rcsid[] = "$OpenBSD: paste.c,v 1.6 1999/08/23 23:58:23 aaron Exp $";
a145 1
		lbuf = NULL;
d147 1
d166 2
a167 1
				lbuf = (char *)malloc(len + 1);
d184 1
a184 1
			if (lbuf != NULL) {
a185 2
				lbuf = NULL;
			}
a201 1
	lbuf = NULL;
d203 1
d216 2
a217 1
					lbuf = (char *)malloc(len + 1);
d236 1
a236 1
		if (lbuf != NULL) {
a237 2
			lbuf = NULL;
		}
@


1.6
log
@fgets() -> fgetln(). When reading files like this, the notion of a `line' is
more appropriate than C strings. Now paste won't die if it encounters null
characters. If the last line in the stream does not contain a newline, we now
say "incomplete line" instead of lying about "line too long". fgetln() uses
realloc, so now we're not limited to POSIX_LINE_MAX.
@
text
@d1 1
a1 1
/*	$OpenBSD: paste.c,v 1.5 1998/11/16 06:09:12 deraadt Exp $	*/
d47 1
a47 1
static char rcsid[] = "$OpenBSD: paste.c,v 1.5 1998/11/16 06:09:12 deraadt Exp $";
d119 1
d146 1
d154 1
a154 1
			if (!(p = fgetln(lp->fp, &len))) {
d163 2
a164 2
			if (*(p + len - 1) == '\n')
				*(p + len - 1) = '\0';
d166 4
a169 4
				(void)fprintf(stderr,
				    "paste: %s: incomplete line.\n",
				    lp->name);
				exit(1);
d182 5
a186 1
			(void)printf("%s", p);
d200 2
a201 1
	char buf[_POSIX2_LINE_MAX + 1];
d203 1
d212 1
a212 1
		if (fgets(buf, sizeof(buf), fp)) {
d214 7
a220 5
				if (!(p = strchr(buf, '\n'))) {
					(void)fprintf(stderr,
					    "paste: %s: input line too long.\n",
					    *argv);
					exit(1);
a221 1
				*p = '\0';
d223 1
a223 1
				if (!fgets(buf, sizeof(buf), fp))
d236 4
@


1.5
log
@more -Wall
@
text
@d1 1
a1 1
/*	$OpenBSD: paste.c,v 1.4 1997/01/17 07:13:02 millert Exp $	*/
d47 1
a47 1
static char rcsid[] = "$OpenBSD: paste.c,v 1.4 1997/01/17 07:13:02 millert Exp $";
a50 1
#include <unistd.h>
d54 1
d56 1
d119 1
a119 1
	char buf[_POSIX2_LINE_MAX + 1], *malloc();
d152 1
a152 1
			if (!fgets(buf, sizeof(buf), lp->fp)) {
d161 3
a163 1
			if (!(p = strchr(buf, '\n'))) {
d165 1
a165 1
				    "paste: %s: input line too long.\n",
a168 1
			*p = '\0';
d180 1
a180 1
			(void)printf("%s", buf);
@


1.4
log
@r?index -> strr?chr
@
text
@d1 1
a1 1
/*	$OpenBSD: paste.c,v 1.3 1997/01/15 23:43:02 millert Exp $	*/
d47 1
a47 1
static char rcsid[] = "$OpenBSD: paste.c,v 1.3 1997/01/15 23:43:02 millert Exp $";
d51 1
d60 6
d109 1
d120 1
a120 1
	for (cnt = 0, head = NULL; p = *argv; ++argv, ++cnt) {
d174 1
a174 1
					if (ch = delim[cnt % delimcnt])
d176 1
a176 1
			} else if (ch = delim[(lp->cnt - 1) % delimcnt])
d185 1
d194 1
a194 1
	for (; p = *argv; ++argv) {
d214 1
a214 1
				if (ch = *dp++)
d228 1
d260 1
@


1.3
log
@getopt(3) returns -1 when out of args, not EOF, whee!
@
text
@d1 1
a1 1
/*	$OpenBSD: paste.c,v 1.2 1996/06/26 05:37:50 deraadt Exp $	*/
d47 1
a47 1
static char rcsid[] = "$OpenBSD: paste.c,v 1.2 1996/06/26 05:37:50 deraadt Exp $";
d152 1
a152 1
			if (!(p = index(buf, '\n'))) {
d195 1
a195 1
				if (!(p = index(buf, '\n'))) {
@


1.2
log
@rcsid
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d47 1
a47 1
static char rcsid[] = "$OpenBSD: paste.c,v 1.1.1.1 1995/10/18 08:45:54 deraadt Exp $";
d68 1
a68 1
	while ((ch = getopt(argc, argv, "d:s")) != EOF)
@


1.1
log
@Initial revision
@
text
@d1 2
d47 1
a47 1
static char rcsid[] = "$Id: paste.c,v 1.2 1993/08/01 18:10:14 mycroft Exp $";
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@
