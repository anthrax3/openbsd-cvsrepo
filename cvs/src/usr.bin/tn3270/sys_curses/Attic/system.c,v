head	1.19;
access;
symbols
	OPENBSD_4_8:1.18.0.4
	OPENBSD_4_8_BASE:1.18
	OPENBSD_4_7:1.18.0.2
	OPENBSD_4_7_BASE:1.18
	OPENBSD_4_6:1.17.0.26
	OPENBSD_4_6_BASE:1.17
	OPENBSD_4_5:1.17.0.22
	OPENBSD_4_5_BASE:1.17
	OPENBSD_4_4:1.17.0.20
	OPENBSD_4_4_BASE:1.17
	OPENBSD_4_3:1.17.0.18
	OPENBSD_4_3_BASE:1.17
	OPENBSD_4_2:1.17.0.16
	OPENBSD_4_2_BASE:1.17
	OPENBSD_4_1:1.17.0.14
	OPENBSD_4_1_BASE:1.17
	OPENBSD_4_0:1.17.0.12
	OPENBSD_4_0_BASE:1.17
	OPENBSD_3_9:1.17.0.10
	OPENBSD_3_9_BASE:1.17
	OPENBSD_3_8:1.17.0.8
	OPENBSD_3_8_BASE:1.17
	OPENBSD_3_7:1.17.0.6
	OPENBSD_3_7_BASE:1.17
	OPENBSD_3_6:1.17.0.4
	OPENBSD_3_6_BASE:1.17
	OPENBSD_3_5:1.17.0.2
	OPENBSD_3_5_BASE:1.17
	OPENBSD_3_4:1.15.0.2
	OPENBSD_3_4_BASE:1.15
	OPENBSD_3_3:1.11.0.4
	OPENBSD_3_3_BASE:1.11
	OPENBSD_3_2:1.11.0.2
	OPENBSD_3_2_BASE:1.11
	OPENBSD_3_1:1.10.0.2
	OPENBSD_3_1_BASE:1.10
	OPENBSD_3_0:1.9.0.2
	OPENBSD_3_0_BASE:1.9
	OPENBSD_2_9_BASE:1.8
	OPENBSD_2_9:1.8.0.6
	OPENBSD_2_8:1.8.0.4
	OPENBSD_2_8_BASE:1.8
	OPENBSD_2_7:1.8.0.2
	OPENBSD_2_7_BASE:1.8
	OPENBSD_2_6:1.7.0.6
	OPENBSD_2_6_BASE:1.7
	OPENBSD_2_5:1.7.0.4
	OPENBSD_2_5_BASE:1.7
	OPENBSD_2_4:1.7.0.2
	OPENBSD_2_4_BASE:1.7
	OPENBSD_2_3:1.6.0.4
	OPENBSD_2_3_BASE:1.6
	OPENBSD_2_2:1.6.0.2
	OPENBSD_2_2_BASE:1.6
	OPENBSD_2_1:1.5.0.2
	OPENBSD_2_1_BASE:1.5
	OPENBSD_2_0:1.2.0.2
	OPENBSD_2_0_BASE:1.2
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.19
date	2010.09.23.18.59.34;	author pirofti;	state dead;
branches;
next	1.18;

1.18
date	2009.10.27.23.59.45;	author deraadt;	state Exp;
branches;
next	1.17;

1.17
date	2004.03.20.04.28.51;	author aaron;	state Exp;
branches;
next	1.16;

1.16
date	2003.10.22.23.05.11;	author tedu;	state Exp;
branches;
next	1.15;

1.15
date	2003.07.10.00.06.51;	author david;	state Exp;
branches;
next	1.14;

1.14
date	2003.06.03.02.56.19;	author millert;	state Exp;
branches;
next	1.13;

1.13
date	2003.04.06.22.02.05;	author tedu;	state Exp;
branches;
next	1.12;

1.12
date	2003.04.04.22.13.10;	author deraadt;	state Exp;
branches;
next	1.11;

1.11
date	2002.06.12.06.07.16;	author mpech;	state Exp;
branches;
next	1.10;

1.10
date	2001.11.19.19.02.17;	author mpech;	state Exp;
branches;
next	1.9;

1.9
date	2001.07.09.07.04.55;	author deraadt;	state Exp;
branches;
next	1.8;

1.8
date	2000.02.01.03.23.44;	author deraadt;	state Exp;
branches;
next	1.7;

1.7
date	98.07.12.08.54.29;	author deraadt;	state Exp;
branches;
next	1.6;

1.6
date	97.08.04.19.25.59;	author deraadt;	state Exp;
branches;
next	1.5;

1.5
date	97.04.19.20.53.46;	author deraadt;	state Exp;
branches;
next	1.4;

1.4
date	97.04.04.18.41.33;	author deraadt;	state Exp;
branches;
next	1.3;

1.3
date	96.12.06.02.09.04;	author deraadt;	state Exp;
branches;
next	1.2;

1.2
date	96.06.26.05.41.31;	author deraadt;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.46.22;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.46.22;	author deraadt;	state Exp;
branches;
next	;


desc
@@


1.19
log
@Kill tn3270.

Okay deraadt@@, millert@@ and all around general approval.
@
text
@/*	$OpenBSD: system.c,v 1.18 2009/10/27 23:59:45 deraadt Exp $	*/

/*-
 * Copyright (c) 1988 The Regents of the University of California.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */

#include <sys/types.h>

#if     defined(pyr)
#define fd_set fdset_t
#endif  /* defined(pyr) */

/*
 * Wouldn't it be nice if these REALLY were in <sys/inode.h>?  Or,
 * equivalently, if <sys/inode.h> REALLY existed?
 */
#define	IREAD	00400
#define	IWRITE	00200

#include <sys/file.h>
#include <sys/time.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <sys/wait.h>

#include <errno.h>

#include <netdb.h>
#include <signal.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <pwd.h>
#include <unistd.h>

#include "../general/general.h"
#include "../ctlr/api.h"
#include "../api/api_exch.h"

#include "../general/globals.h"

#ifndef	FD_SETSIZE
/*
 * The following is defined just in case someone should want to run
 * this telnet on a 4.2 system.
 *
 */

#define	FD_SET(n, p)	((p)->fds_bits[0] |= (1<<(n)))
#define	FD_CLR(n, p)	((p)->fds_bits[0] &= ~(1<<(n)))
#define	FD_ISSET(n, p)	((p)->fds_bits[0] & (1<<(n)))
#define FD_ZERO(p)	((p)->fds_bits[0] = 0)

#endif

static pid_t shell_pid = 0;
static char key[50];			/* Actual key */
static char *keyname;			/* Name of file with key in it */

static char *ourENVlist[200];		/* Lots of room */

static int
    sock = -1,				/* Connected socket */
    serversock;				/* Server (listening) socket */

static enum { DEAD, UNCONNECTED, CONNECTED } state;

static long
    storage_location;		/* Address we have */
static short
    storage_length = 0;		/* Length we have */
static int
    storage_must_send = 0,	/* Storage belongs on other side of wire */
    storage_accessed = 0;	/* The storage is accessed (so leave alone)! */

static long storage[1000];

static union REGS inputRegs;
static struct SREGS inputSregs;

extern int apitrace;

static void
kill_connection()
{
    state = UNCONNECTED;
    if (sock != -1) {
	(void) close(sock);
	sock = -1;
    }
}


static int
nextstore()
{
    struct storage_descriptor sd;

    if (api_exch_intype(EXCH_TYPE_STORE_DESC, sizeof sd, (char *)&sd) == -1) {
	storage_length = 0;
	return -1;
    }
    storage_length = sd.length;
    storage_location = sd.location;
    if (storage_length > sizeof storage) {
	fprintf(stderr, "API client tried to send too much storage (%d).\n",
		storage_length);
	storage_length = 0;
	return -1;
    }
    if (api_exch_intype(EXCH_TYPE_BYTES, storage_length, (char *)storage)
							== -1) {
	storage_length = 0;
	return -1;
    }
    return 0;
}


static int
doreject(message)
char	*message;
{
    struct storage_descriptor sd;
    int length = strlen(message);

    if (api_exch_outcommand(EXCH_CMD_REJECTED) == -1) {
	return -1;
    }
    sd.length = length;
    if (api_exch_outtype(EXCH_TYPE_STORE_DESC, sizeof sd, (char *)&sd) == -1) {
	return -1;
    }
    if (api_exch_outtype(EXCH_TYPE_BYTES, length, message) == -1) {
	return -1;
    }
    return 0;
}


/*
 * doassociate()
 *
 * Negotiate with the other side and try to do something.
 *
 * Returns:
 *
 *	-1:	Error in processing
 *	 0:	Invalid password entered
 *	 1:	Association OK
 */

static int
doassociate()
{
    struct passwd *pwent;
    char
	promptbuf[100],
	buffer[200];
    struct storage_descriptor sd;
    extern char *crypt();

    if (api_exch_intype(EXCH_TYPE_STORE_DESC, sizeof sd, (char *)&sd) == -1) {
	return -1;
    }
    sd.length = sd.length;
    if (sd.length > sizeof buffer) {
	doreject("(internal error) Authentication key too long");
	return -1;
    }
    if (api_exch_intype(EXCH_TYPE_BYTES, sd.length, buffer) == -1) {
	return -1;
    }
    buffer[sd.length] = 0;

    if (strcmp(buffer, key) != 0) {
#if	(!defined(sun)) || defined(BSD) && (BSD >= 43)
	extern uid_t geteuid();
#endif	/* (!defined(sun)) || defined(BSD) && (BSD >= 43) */

	if ((pwent = getpwuid((int)geteuid())) == 0) {
	    return -1;
	}
	snprintf(promptbuf, sizeof promptbuf,
		"Enter password for user %s:", pwent->pw_name);
	if (api_exch_outcommand(EXCH_CMD_SEND_AUTH) == -1) {
	    return -1;
	}
	sd.length = strlen(promptbuf);
	if (api_exch_outtype(EXCH_TYPE_STORE_DESC, sizeof sd, (char *)&sd)
									== -1) {
	    return -1;
	}
	if (api_exch_outtype(EXCH_TYPE_BYTES, strlen(promptbuf), promptbuf)
									== -1) {
	    return -1;
	}
	sd.length = strlen(pwent->pw_name);
	if (api_exch_outtype(EXCH_TYPE_STORE_DESC, sizeof sd, (char *)&sd)
									== -1) {
	    return -1;
	}
	if (api_exch_outtype(EXCH_TYPE_BYTES,
			    strlen(pwent->pw_name), pwent->pw_name) == -1) {
	    return -1;
	}
	if (api_exch_incommand(EXCH_CMD_AUTH) == -1) {
	    return -1;
	}
	if (api_exch_intype(EXCH_TYPE_STORE_DESC, sizeof sd, (char *)&sd)
									== -1) {
	    return -1;
	}
	sd.length = sd.length;
	if (sd.length > sizeof buffer) {
	    doreject("Password entered was too long");
	    return -1;
	}
	if (api_exch_intype(EXCH_TYPE_BYTES, sd.length, buffer) == -1) {
	    return -1;
	}
	buffer[sd.length] = 0;

	/* Is this the correct password? */
	if (strlen(pwent->pw_name)) {
	    char *ptr;
	    int i;

	    ptr = pwent->pw_name;
	    i = 0;
	    while (i < sd.length) {
		buffer[i++] ^= *ptr++;
		if (*ptr == 0) {
		    ptr = pwent->pw_name;
		}
	    }
	}
	if (strcmp(crypt(buffer, pwent->pw_passwd), pwent->pw_passwd) != 0) {
	    doreject("Invalid password");
	    sleep(10);		/* Don't let us do too many of these */
	    return 0;
	}
    }
    if (api_exch_outcommand(EXCH_CMD_ASSOCIATED) == -1) {
	return -1;
    } else {
	return 1;
    }
}


void
freestorage()
{
    struct storage_descriptor sd;

    if (storage_accessed) {
	fprintf(stderr, "Internal error - attempt to free accessed storage.\n");
	fprintf(stderr, "(Encountered in file %s at line %d.)\n",
			__FILE__, __LINE__);
	quit();
    }
    if (storage_must_send == 0) {
	return;
    }
    storage_must_send = 0;
    if (api_exch_outcommand(EXCH_CMD_HEREIS) == -1) {
	kill_connection();
	return;
    }
    sd.length = storage_length;
    sd.location = storage_location;
    if (api_exch_outtype(EXCH_TYPE_STORE_DESC, sizeof sd, (char *)&sd) == -1) {
	kill_connection();
	return;
    }
    if (api_exch_outtype(EXCH_TYPE_BYTES, storage_length, (char *)storage)
							    == -1) {
	kill_connection();
	return;
    }
}


static int
getstorage(address, length, copyin)
long
    address;
int
    length,
    copyin;
{
    struct storage_descriptor sd;

    freestorage();
    if (storage_accessed) {
	fprintf(stderr,
		"Internal error - attempt to get while storage accessed.\n");
	fprintf(stderr, "(Encountered in file %s at line %d.)\n",
			__FILE__, __LINE__);
	quit();
    }
    storage_must_send = 0;
    if (api_exch_outcommand(EXCH_CMD_GIMME) == -1) {
	kill_connection();
	return -1;
    }
    storage_location = address;
    storage_length = length;
    if (copyin) {
	sd.location = (long)storage_location;
	sd.length = storage_length;
	if (api_exch_outtype(EXCH_TYPE_STORE_DESC,
					sizeof sd, (char *)&sd) == -1) {
	    kill_connection();
	    return -1;
	}
	if (api_exch_incommand(EXCH_CMD_HEREIS) == -1) {
	    fprintf(stderr, "Bad data from other side.\n");
	    fprintf(stderr, "(Encountered at %s, %d.)\n", __FILE__, __LINE__);
	    return -1;
	}
	if (nextstore() == -1) {
	    kill_connection();
	    return -1;
	}
    }
    return 0;
}

/*ARGSUSED*/
void
movetous(local, es, di, length)
char
    *local;
unsigned int
    es,
    di;
int
    length;
{
    long where = SEG_OFF_BACK(es, di);

    if (length > sizeof storage) {
	fprintf(stderr, "Internal API error - movetous() length too long.\n");
	fprintf(stderr, "(detected in file %s, line %d)\n", __FILE__, __LINE__);
	quit();
    } else if (length == 0) {
	return;
    }
    getstorage(where, length, 1);
    memcpy(local, (char *)(storage+((where-storage_location))), length);
    if (apitrace) {
	Dump('(', local, length);
    }
}

/*ARGSUSED*/
void
movetothem(es, di, local, length)
unsigned int
    es,
    di;
char
    *local;
int
    length;
{
    long where = SEG_OFF_BACK(es, di);

    if (length > sizeof storage) {
	fprintf(stderr, "Internal API error - movetothem() length too long.\n");
	fprintf(stderr, "(detected in file %s, line %d)\n", __FILE__, __LINE__);
	quit();
    } else if (length == 0) {
	return;
    }
    freestorage();
    memcpy((char *)storage, local, length);
    if (apitrace) {
	Dump(')', local, length);
    }
    storage_length = length;
    storage_location = where;
    storage_must_send = 1;
}


char *
access_api(location, length, copyin)
char *
    location;
int
    length,
    copyin;			/* Do we need to copy in initially? */
{
    if (storage_accessed) {
	fprintf(stderr, "Internal error - storage accessed twice\n");
	fprintf(stderr, "(Encountered in file %s, line %d.)\n",
				__FILE__, __LINE__);
	quit();
    } else if (length != 0) {
	freestorage();
	getstorage((long)location, length, copyin);
	storage_accessed = 1;
    }
    return (char *) storage;
}

/*ARGSUSED*/
void
unaccess_api(location, local, length, copyout)
char 	*location;
char	*local;
int	length;
int	copyout;
{
    if (storage_accessed == 0) {
	fprintf(stderr, "Internal error - unnecessary unaccess_api call.\n");
	fprintf(stderr, "(Encountered in file %s, line %d.)\n",
			__FILE__, __LINE__);
	quit();
    }
    storage_accessed = 0;
    storage_must_send = copyout;	/* if needs to go back */
}

/*
 * Accept a connection from an API client, aborting if the child dies.
 */

static int
doconnect()
{
    fd_set fdset;
    int i;

    sock = -1;
    FD_ZERO(&fdset);
    while (shell_active && (sock == -1)) {
	FD_SET(serversock, &fdset);
	if ((i = select(serversock+1, &fdset,
		    (fd_set *)0, (fd_set *)0, (struct timeval *)0)) < 0) {
	    if (errno == EINTR) {
		continue;
	    } else {
		perror("in select waiting for API connection");
		return -1;
	    }
	} else {
	    i = accept(serversock, (struct sockaddr *)0, (int *)0);
	    if (i == -1) {
		perror("accepting API connection");
		return -1;
	    }
	    sock = i;
	}
    }
    /* If the process has already exited, we may need to close */
    if ((shell_active == 0) && (sock != -1)) {
	extern void setcommandmode();

	(void) close(sock);
	sock = -1;
	setcommandmode();	/* In case child_died sneaked in */
    }
    return 0;
}

/*
 * shell_continue() actually runs the command, and looks for API
 * requests coming back in.
 *
 * We are called from the main loop in telnet.c.
 */

int
shell_continue()
{
    int i;

    switch (state) {
    case DEAD:
	pause();			/* Nothing to do */
	break;
    case UNCONNECTED:
	if (doconnect() == -1) {
	    kill_connection();
	    return -1;
	}
	/* At this point, it is possible that we've gone away */
	if (shell_active == 0) {
	    kill_connection();
	    return -1;
	}
	if (api_exch_init(sock, "server") == -1) {
	    return -1;
	}
	while (state == UNCONNECTED) {
	    if (api_exch_incommand(EXCH_CMD_ASSOCIATE) == -1) {
		kill_connection();
		return -1;
	    } else {
		switch (doassociate()) {
		case -1:
		    kill_connection();
		    return -1;
		case 0:
		    break;
		case 1:
		    state = CONNECTED;
		}
	    }
	}
	break;
    case CONNECTED:
	switch (i = api_exch_nextcommand()) {
	case EXCH_CMD_REQUEST:
	    if (api_exch_intype(EXCH_TYPE_REGS, sizeof inputRegs,
				    (char *)&inputRegs) == -1) {
		kill_connection();
	    } else if (api_exch_intype(EXCH_TYPE_SREGS, sizeof inputSregs,
				    (char *)&inputSregs) == -1) {
		kill_connection();
	    } else if (nextstore() == -1) {
		kill_connection();
	    } else {
		handle_api(&inputRegs, &inputSregs);
		freestorage();			/* Send any storage back */
		if (api_exch_outcommand(EXCH_CMD_REPLY) == -1) {
		    kill_connection();
		} else if (api_exch_outtype(EXCH_TYPE_REGS, sizeof inputRegs,
				    (char *)&inputRegs) == -1) {
		    kill_connection();
		} else if (api_exch_outtype(EXCH_TYPE_SREGS, sizeof inputSregs,
				    (char *)&inputSregs) == -1) {
		    kill_connection();
		}
		/* Done, and it all worked! */
	    }
	    break;
	case EXCH_CMD_DISASSOCIATE:
	    kill_connection();
	    break;
	default:
	    if (i != -1) {
		fprintf(stderr,
			"Looking for a REQUEST or DISASSOCIATE command\n");
		fprintf(stderr, "\treceived 0x%02x.\n", i);
	    }
	    kill_connection();
	    break;
	}
    }
    return shell_active;
}


static void
child_died(code)
{
    int save_errno = errno;
    union wait status;
    pid_t pid;

    while ((pid = wait3((int *)&status, WNOHANG, (struct rusage *)0)) > 0) {
	if (pid == shell_pid) {
	    char inputbuffer[100];
	    extern void setconnmode();
	    extern void ConnectScreen();

	    shell_active = 0;
	    if (sock != -1) {
		(void) close(sock);
		sock = -1;
	    }
	    printf("[Hit return to continue]");
	    fflush(stdout);
	    (void) fgets(inputbuffer, sizeof(inputbuffer), stdin);
	    setconnmode();
	    ConnectScreen();	/* Turn screen on (if need be) */
	    (void) close(serversock);
	    (void) unlink(keyname);
	}
    }
    signal(SIGCHLD, child_died);
    errno = save_errno;
}


/*
 * Called from telnet.c to fork a lower command.com.  We
 * use the spint... routines so that we can pick up
 * interrupts generated by application programs.
 */


int
shell(argc,argv)
int	argc;
char	*argv[];
{
    int length;
    struct sockaddr_in server;
    char sockNAME[200+MAXHOSTNAMELEN];
    static char **whereAPI = 0;
    int fd;
    struct timeval tv;
    long ikey;

    if ((keyname = strdup("/tmp/apiXXXXXXXXXX")) == NULL)
	    err(1, "strdup");
    if ((fd = mkstemp(keyname)) == -1) {
	perror("open");
	free(keyname);
	return 0;
    }
    if ((keyname = strdup(sockNAME)) == NULL)
	    err(1, "strdup");

    /* Now, get seed for random */

    if (gettimeofday(&tv, (struct timezone *)0) == -1) {
	perror("gettimeofday");
	return 0;
    }
    srandom(tv.tv_usec);		/* seed random number generator */
    do {
	ikey = random();
    } while (ikey == 0);
    snprintf(key, sizeof key, "%lu\n", (unsigned long) ikey);
    if (write(fd, key, strlen(key)) != strlen(key)) {
	perror("write");
	return 0;
    }
    key[strlen(key)-1] = 0;		/* Get rid of newline */

    if (close(fd) == -1) {
	perror("close");
	return 0;
    }

    /* Next, create the socket which will be connected to */
    serversock = socket(AF_INET, SOCK_STREAM, 0);
    if (serversock < 0) {
	perror("opening API socket");
	return 0;
    }
    server.sin_family = AF_INET;
    server.sin_addr.s_addr = INADDR_ANY;
    server.sin_port = 0;
    if (bind(serversock, (struct sockaddr *)&server, sizeof server) < 0) {
	perror("binding API socket");
	return 0;
    }
    length = sizeof server;
    if (getsockname(serversock, (struct sockaddr *)&server, &length) < 0) {
	perror("getting API socket name");
	(void) close(serversock);
    }
    listen(serversock, 1);
    /* Get name to advertise in address list */
    strlcpy(sockNAME, "API3270=", sizeof sockNAME);
    gethostname(sockNAME+strlen(sockNAME), sizeof sockNAME-strlen(sockNAME));
    if (strlen(sockNAME) > (sizeof sockNAME-(10+strlen(keyname)))) {
	fprintf(stderr, "Local hostname too large; using 'localhost'.\n");
	strlcpy(sockNAME, "localhost", sizeof sockNAME);
    }
    snprintf(sockNAME+strlen(sockNAME), sizeof(sockNAME) - strlen(sockNAME),
	":%u", ntohs(server.sin_port));
    snprintf(sockNAME+strlen(sockNAME), sizeof(sockNAME) - strlen(sockNAME),
	":%s", keyname);

    if (whereAPI == 0) {
	char **ptr, **nextenv;
	extern char **environ;

	ptr = environ;
	nextenv = ourENVlist;
	while (*ptr) {
	    if (nextenv >= &ourENVlist[highestof(ourENVlist)-1]) {
		fprintf(stderr, "Too many environmental variables\n");
		break;
	    }
	    *nextenv++ = *ptr++;
	}
	whereAPI = nextenv++;
	*nextenv++ = 0;
	environ = ourENVlist;		/* New environment */
    }
    *whereAPI = sockNAME;

    child_died();			/* Start up signal handler */
    shell_active = 1;			/* We are running down below */
    if (shell_pid = vfork()) {
	if (shell_pid == -1) {
	    perror("vfork");
	    (void) close(serversock);
	} else {
	    state = UNCONNECTED;
	}
    } else {				/* New process */
	int i;

	for (i = 3; i < 30; i++) {
	    (void) close(i);
	}
	if (argc == 1) {		/* Just get a shell */
	    char *cmdname;
	    extern char *getenv();

	    cmdname = getenv("SHELL");
	    execlp(cmdname, cmdname, (char *)NULL);
	    perror("Exec'ing new shell...\n");
	    _exit(1);
	} else {
	    execvp(argv[1], &argv[1]);
	    perror("Exec'ing command.\n");
	    _exit(1);
	}
	/*NOTREACHED*/
    }
    return shell_active;		/* Go back to main loop */
}
@


1.18
log
@rcsid[] and sccsid[] and copyright[] are essentially unmaintained (and
unmaintainable).  these days, people use source.  these id's do not provide
any benefit, and do hurt the small install media
(the 33,000 line diff is essentially mechanical)
ok with the idea millert, ok dms
@
text
@d1 1
a1 1
/*	$OpenBSD: system.c,v 1.17 2004/03/20 04:28:51 aaron Exp $	*/
@


1.17
log
@Fix bad errno check. deraadt@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: system.c,v 1.16 2003/10/22 23:05:11 tedu Exp $	*/
a30 5

#ifndef lint
/*static char sccsid[] = "from: @@(#)system.c	4.5 (Berkeley) 4/26/91";*/
static char rcsid[] = "$OpenBSD: system.c,v 1.16 2003/10/22 23:05:11 tedu Exp $";
#endif /* not lint */
@


1.16
log
@err on strdup failure.  from vink joris.
@
text
@d1 1
a1 1
/*	$OpenBSD: system.c,v 1.15 2003/07/10 00:06:51 david Exp $	*/
d34 1
a34 1
static char rcsid[] = "$OpenBSD: system.c,v 1.15 2003/07/10 00:06:51 david Exp $";
d474 1
a474 1
	    if (errno = EINTR) {
@


1.15
log
@add missing includes
ok deraadt@@ tedu@@
@
text
@d1 1
a1 1
/*	$OpenBSD: system.c,v 1.14 2003/06/03 02:56:19 millert Exp $	*/
d34 1
a34 1
static char rcsid[] = "$OpenBSD: system.c,v 1.14 2003/06/03 02:56:19 millert Exp $";
d641 2
a642 1
    keyname = strdup("/tmp/apiXXXXXXXXXX");
d648 2
a649 1
    keyname = strdup(sockNAME);
@


1.14
log
@Remove the advertising clause in the UCB license which Berkeley
rescinded 22 July 1999.  Proofed by myself and Theo.
@
text
@d1 1
a1 1
/*	$OpenBSD: system.c,v 1.13 2003/04/06 22:02:05 tedu Exp $	*/
d34 1
a34 1
static char rcsid[] = "$OpenBSD: system.c,v 1.13 2003/04/06 22:02:05 tedu Exp $";
d64 1
@


1.13
log
@no strcpy.  no strcat.  no sprintf.  some from deraadt@@
prototype for malloc from stdlib.h, not our own wrong one (in each function!).
use strdup, don't roll our own.  this program is a real piece of work.
@
text
@d1 1
a1 1
/*	$OpenBSD: system.c,v 1.12 2003/04/04 22:13:10 deraadt Exp $	*/
d15 1
a15 5
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
d34 1
a34 1
static char rcsid[] = "$OpenBSD: system.c,v 1.12 2003/04/04 22:13:10 deraadt Exp $";
@


1.12
log
@simple string stuff; ok matthieu tdeval
@
text
@d1 1
a1 1
/*	$OpenBSD: system.c,v 1.11 2002/06/12 06:07:16 mpech Exp $	*/
d38 1
a38 1
static char rcsid[] = "$OpenBSD: system.c,v 1.11 2002/06/12 06:07:16 mpech Exp $";
d700 4
a703 2
    sprintf(sockNAME+strlen(sockNAME), ":%u", ntohs(server.sin_port));
    sprintf(sockNAME+strlen(sockNAME), ":%s", keyname);
@


1.11
log
@a real pid_t cleanup.

espie@@ ok for make/,
deraadt@@ one extra eye,
millert@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: system.c,v 1.10 2001/11/19 19:02:17 mpech Exp $	*/
d38 1
a38 1
static char rcsid[] = "$OpenBSD: system.c,v 1.10 2001/11/19 19:02:17 mpech Exp $";
d217 2
a218 1
	sprintf(promptbuf, "Enter password for user %s:", pwent->pw_name);
d662 1
a662 1
    sprintf(key, "%lu\n", (unsigned long) ikey);
d694 1
a694 1
    strcpy(sockNAME, "API3270=");
d698 1
a698 1
	strcpy(sockNAME, "localhost");
@


1.10
log
@kill more registers

millert@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: system.c,v 1.9 2001/07/09 07:04:55 deraadt Exp $	*/
d38 1
a38 1
static char rcsid[] = "$OpenBSD: system.c,v 1.9 2001/07/09 07:04:55 deraadt Exp $";
d89 1
a89 1
static int shell_pid = 0;
d596 1
a596 1
    int pid;
@


1.9
log
@correct type on last arg to execl(); nordin@@cse.ogi.edu
@
text
@d1 1
a1 1
/*	$OpenBSD: system.c,v 1.8 2000/02/01 03:23:44 deraadt Exp $	*/
d38 1
a38 1
static char rcsid[] = "$OpenBSD: system.c,v 1.8 2000/02/01 03:23:44 deraadt Exp $";
d596 1
a596 1
    register int pid;
d731 1
a731 1
	register int i;
@


1.8
log
@no need to extern int errno if errno.h is included
@
text
@d1 1
a1 1
/*	$OpenBSD: system.c,v 1.7 1998/07/12 08:54:29 deraadt Exp $	*/
d38 1
a38 1
static char rcsid[] = "$OpenBSD: system.c,v 1.7 1998/07/12 08:54:29 deraadt Exp $";
d741 1
a741 1
	    execlp(cmdname, cmdname, 0);
@


1.7
log
@extend a hostname based buffer. This code is a *NIGHTMARE*
@
text
@d1 1
a1 1
/*	$OpenBSD: system.c,v 1.6 1997/08/04 19:25:59 deraadt Exp $	*/
d38 1
a38 1
static char rcsid[] = "$OpenBSD: system.c,v 1.6 1997/08/04 19:25:59 deraadt Exp $";
a60 1
extern int errno;
@


1.6
log
@save errno in sigchld handlers
@
text
@d1 1
a1 1
/*	$OpenBSD: system.c,v 1.5 1997/04/19 20:53:46 deraadt Exp $	*/
d38 1
a38 1
static char rcsid[] = "$OpenBSD: system.c,v 1.5 1997/04/19 20:53:46 deraadt Exp $";
d638 1
a638 1
    char sockNAME[100];
@


1.5
log
@use mkstemp
@
text
@d1 1
a1 1
/*	$OpenBSD: system.c,v 1.4 1997/04/04 18:41:33 deraadt Exp $	*/
d38 1
a38 1
static char rcsid[] = "$OpenBSD: system.c,v 1.4 1997/04/04 18:41:33 deraadt Exp $";
d595 1
d620 1
@


1.4
log
@when mktemp() is hard to fix, use 10 X
@
text
@d1 1
a1 1
/*	$OpenBSD: system.c,v 1.3 1996/12/06 02:09:04 deraadt Exp $	*/
d38 1
a38 1
static char rcsid[] = "$OpenBSD: system.c,v 1.3 1996/12/06 02:09:04 deraadt Exp $";
d66 1
a640 9
    extern long random();
    extern char *mktemp();
    extern char *strcpy();

    /* First, create verification file. */
    do {
	keyname = mktemp(strdup("/tmp/apiXXXXXXXXXX"));
	fd = open(keyname, O_RDWR|O_CREAT|O_EXCL, IREAD|IWRITE);
    } while ((fd == -1) && (errno == EEXIST));
d642 2
a643 1
    if (fd == -1) {
d645 1
d648 1
@


1.3
log
@vfork w/ exit botch
@
text
@d1 1
a1 1
/*	$OpenBSD: system.c,v 1.2 1996/06/26 05:41:31 deraadt Exp $	*/
d38 1
a38 1
static char rcsid[] = "$OpenBSD: system.c,v 1.2 1996/06/26 05:41:31 deraadt Exp $";
d646 1
a646 1
	keyname = mktemp(strdup("/tmp/apiXXXXXX"));
@


1.2
log
@rcsid
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d38 1
a38 1
static char rcsid[] = "$OpenBSD: system.c,v 1.1.1.1 1995/10/18 08:46:22 deraadt Exp $";
d747 1
a747 1
	    exit(1);
d751 1
a751 1
	    exit(1);
@


1.1
log
@Initial revision
@
text
@d1 2
d38 1
a38 1
static char rcsid[] = "$Id: system.c,v 1.3 1994/04/10 07:20:35 cgd Exp $";
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@
