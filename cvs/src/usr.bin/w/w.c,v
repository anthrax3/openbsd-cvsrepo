head	1.61;
access;
symbols
	OPENBSD_6_1_BASE:1.61
	OPENBSD_6_0:1.61.0.2
	OPENBSD_6_0_BASE:1.61
	OPENBSD_5_9:1.60.0.2
	OPENBSD_5_9_BASE:1.60
	OPENBSD_5_8:1.58.0.4
	OPENBSD_5_8_BASE:1.58
	OPENBSD_5_7:1.57.0.2
	OPENBSD_5_7_BASE:1.57
	OPENBSD_5_6:1.56.0.4
	OPENBSD_5_6_BASE:1.56
	OPENBSD_5_5:1.54.0.4
	OPENBSD_5_5_BASE:1.54
	OPENBSD_5_4:1.51.0.6
	OPENBSD_5_4_BASE:1.51
	OPENBSD_5_3:1.51.0.4
	OPENBSD_5_3_BASE:1.51
	OPENBSD_5_2:1.51.0.2
	OPENBSD_5_2_BASE:1.51
	OPENBSD_5_1_BASE:1.50
	OPENBSD_5_1:1.50.0.4
	OPENBSD_5_0:1.50.0.2
	OPENBSD_5_0_BASE:1.50
	OPENBSD_4_9:1.47.0.6
	OPENBSD_4_9_BASE:1.47
	OPENBSD_4_8:1.47.0.4
	OPENBSD_4_8_BASE:1.47
	OPENBSD_4_7:1.47.0.2
	OPENBSD_4_7_BASE:1.47
	OPENBSD_4_6:1.46.0.6
	OPENBSD_4_6_BASE:1.46
	OPENBSD_4_5:1.46.0.2
	OPENBSD_4_5_BASE:1.46
	OPENBSD_4_4:1.45.0.14
	OPENBSD_4_4_BASE:1.45
	OPENBSD_4_3:1.45.0.12
	OPENBSD_4_3_BASE:1.45
	OPENBSD_4_2:1.45.0.10
	OPENBSD_4_2_BASE:1.45
	OPENBSD_4_1:1.45.0.8
	OPENBSD_4_1_BASE:1.45
	OPENBSD_4_0:1.45.0.6
	OPENBSD_4_0_BASE:1.45
	OPENBSD_3_9:1.45.0.4
	OPENBSD_3_9_BASE:1.45
	OPENBSD_3_8:1.45.0.2
	OPENBSD_3_8_BASE:1.45
	OPENBSD_3_7:1.43.0.2
	OPENBSD_3_7_BASE:1.43
	OPENBSD_3_6:1.42.0.2
	OPENBSD_3_6_BASE:1.42
	OPENBSD_3_5:1.41.0.2
	OPENBSD_3_5_BASE:1.41
	OPENBSD_3_4:1.39.0.2
	OPENBSD_3_4_BASE:1.39
	OPENBSD_3_3:1.38.0.4
	OPENBSD_3_3_BASE:1.38
	OPENBSD_3_2:1.38.0.2
	OPENBSD_3_2_BASE:1.38
	OPENBSD_3_1:1.36.0.2
	OPENBSD_3_1_BASE:1.36
	OPENBSD_3_0:1.34.0.2
	OPENBSD_3_0_BASE:1.34
	OPENBSD_2_9_BASE:1.32
	OPENBSD_2_9:1.32.0.2
	OPENBSD_2_8:1.30.0.2
	OPENBSD_2_8_BASE:1.30
	OPENBSD_2_7:1.28.0.4
	OPENBSD_2_7_BASE:1.28
	OPENBSD_2_6:1.28.0.2
	OPENBSD_2_6_BASE:1.28
	OPENBSD_2_5:1.25.0.4
	OPENBSD_2_5_BASE:1.25
	OPENBSD_2_4:1.25.0.2
	OPENBSD_2_4_BASE:1.25
	OPENBSD_2_3:1.24.0.2
	OPENBSD_2_3_BASE:1.24
	OPENBSD_2_2:1.20.0.2
	OPENBSD_2_2_BASE:1.20
	OPENBSD_2_1:1.16.0.2
	OPENBSD_2_1_BASE:1.16
	OPENBSD_2_0:1.10.0.2
	OPENBSD_2_0_BASE:1.10
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.61
date	2016.03.19.00.11.49;	author deraadt;	state Exp;
branches;
next	1.60;
commitid	Y4e4OdKaqGcpPRmu;

1.60
date	2015.10.23.03.26.24;	author deraadt;	state Exp;
branches;
next	1.59;
commitid	7XmiAOXOqUGI0vLc;

1.59
date	2015.08.31.15.49.34;	author deraadt;	state Exp;
branches;
next	1.58;
commitid	g9xS7n2fcElC9Ydd;

1.58
date	2015.03.15.00.41.28;	author millert;	state Exp;
branches;
next	1.57;
commitid	IbVxlqGw2UipKdDr;

1.57
date	2015.01.16.06.40.14;	author deraadt;	state Exp;
branches;
next	1.56;
commitid	Uu5nFG3wCl0LACBb;

1.56
date	2014.07.08.23.24.28;	author deraadt;	state Exp;
branches;
next	1.55;
commitid	Df8NRSKri7CaXJtB;

1.55
date	2014.07.04.05.58.31;	author guenther;	state Exp;
branches;
next	1.54;
commitid	vhXZZxMGVTWiFaF3;

1.54
date	2013.11.20.21.00.33;	author deraadt;	state Exp;
branches;
next	1.53;

1.53
date	2013.10.31.02.00.12;	author deraadt;	state Exp;
branches;
next	1.52;

1.52
date	2013.08.22.04.43.41;	author guenther;	state Exp;
branches;
next	1.51;

1.51
date	2012.06.24.06.34.34;	author guenther;	state Exp;
branches;
next	1.50;

1.50
date	2011.07.28.10.14.00;	author kettenis;	state Exp;
branches;
next	1.49;

1.49
date	2011.04.26.07.29.05;	author jasper;	state Exp;
branches;
next	1.48;

1.48
date	2011.04.10.03.20.59;	author guenther;	state Exp;
branches;
next	1.47;

1.47
date	2009.10.27.23.59.49;	author deraadt;	state Exp;
branches;
next	1.46;

1.46
date	2008.09.30.21.29.58;	author millert;	state Exp;
branches;
next	1.45;

1.45
date	2005.07.20.04.19.08;	author jaredy;	state Exp;
branches;
next	1.44;

1.44
date	2005.04.11.07.04.47;	author deraadt;	state Exp;
branches;
next	1.43;

1.43
date	2004.09.14.22.24.24;	author deraadt;	state Exp;
branches;
next	1.42;

1.42
date	2004.08.18.21.27.20;	author jmc;	state Exp;
branches;
next	1.41;

1.41
date	2004.01.08.18.14.51;	author millert;	state Exp;
branches;
next	1.40;

1.40
date	2003.11.26.00.31.27;	author millert;	state Exp;
branches;
next	1.39;

1.39
date	2003.06.03.02.56.22;	author millert;	state Exp;
branches;
next	1.38;

1.38
date	2002.09.17.19.37.40;	author deraadt;	state Exp;
branches;
next	1.37;

1.37
date	2002.06.08.22.57.34;	author angelos;	state Exp;
branches;
next	1.36;

1.36
date	2002.02.19.18.38.02;	author mpech;	state Exp;
branches;
next	1.35;

1.35
date	2002.02.16.21.27.58;	author millert;	state Exp;
branches;
next	1.34;

1.34
date	2001.07.12.05.17.31;	author deraadt;	state Exp;
branches;
next	1.33;

1.33
date	2001.05.30.20.57.58;	author smart;	state Exp;
branches;
next	1.32;

1.32
date	2001.01.31.17.42.26;	author deraadt;	state Exp;
branches;
next	1.31;

1.31
date	2000.12.23.02.07.49;	author deraadt;	state Exp;
branches;
next	1.30;

1.30
date	2000.07.07.21.09.02;	author deraadt;	state Exp;
branches;
next	1.29;

1.29
date	2000.07.07.21.07.41;	author deraadt;	state Exp;
branches;
next	1.28;

1.28
date	99.08.12.19.26.39;	author millert;	state Exp;
branches;
next	1.27;

1.27
date	99.06.05.17.04.59;	author deraadt;	state Exp;
branches;
next	1.26;

1.26
date	99.04.25.00.33.56;	author millert;	state Exp;
branches;
next	1.25;

1.25
date	98.07.08.22.14.20;	author deraadt;	state Exp;
branches;
next	1.24;

1.24
date	98.02.03.19.18.22;	author deraadt;	state Exp;
branches;
next	1.23;

1.23
date	98.01.16.17.50.43;	author millert;	state Exp;
branches;
next	1.22;

1.22
date	97.12.24.19.57.11;	author deraadt;	state Exp;
branches;
next	1.21;

1.21
date	97.12.24.16.13.25;	author mickey;	state Exp;
branches;
next	1.20;

1.20
date	97.07.25.14.36.24;	author kstailey;	state Exp;
branches;
next	1.19;

1.19
date	97.07.25.05.04.07;	author mickey;	state Exp;
branches;
next	1.18;

1.18
date	97.05.30.18.40.46;	author deraadt;	state Exp;
branches;
next	1.17;

1.17
date	97.05.30.18.39.44;	author deraadt;	state Exp;
branches;
next	1.16;

1.16
date	97.04.01.07.58.40;	author millert;	state Exp;
branches;
next	1.15;

1.15
date	97.03.30.18.16.02;	author millert;	state Exp;
branches;
next	1.14;

1.14
date	97.03.25.21.24.12;	author deraadt;	state Exp;
branches;
next	1.13;

1.13
date	97.02.19.11.16.04;	author angelos;	state Exp;
branches;
next	1.12;

1.12
date	97.01.15.23.43.35;	author millert;	state Exp;
branches;
next	1.11;

1.11
date	96.12.22.03.26.10;	author tholo;	state Exp;
branches;
next	1.10;

1.10
date	96.08.22.09.37.19;	author deraadt;	state Exp;
branches;
next	1.9;

1.9
date	96.08.22.06.46.36;	author deraadt;	state Exp;
branches;
next	1.8;

1.8
date	96.08.22.02.16.01;	author downsj;	state Exp;
branches;
next	1.7;

1.7
date	96.08.22.02.12.33;	author downsj;	state Exp;
branches;
next	1.6;

1.6
date	96.08.12.02.28.43;	author deraadt;	state Exp;
branches;
next	1.5;

1.5
date	96.08.06.20.41.32;	author deraadt;	state Exp;
branches;
next	1.4;

1.4
date	96.06.26.05.42.45;	author deraadt;	state Exp;
branches;
next	1.3;

1.3
date	96.05.30.09.11.27;	author deraadt;	state Exp;
branches;
next	1.2;

1.2
date	96.04.21.23.44.48;	author deraadt;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.46.50;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.46.50;	author deraadt;	state Exp;
branches;
next	;


desc
@@


1.61
log
@if -a is specified, allow "dns" in pledge requests.
problem noticed by Raf Czlonka
@
text
@/*	$OpenBSD: w.c,v 1.60 2015/10/23 03:26:24 deraadt Exp $	*/

/*-
 * Copyright (c) 1980, 1991, 1993, 1994
 *	The Regents of the University of California.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */

/*
 * w - print system status (who and what)
 *
 * This program is similar to the systat command on Tenex/Tops 10/20
 *
 */
#include <sys/param.h>	/* MAXCOMLEN */
#include <sys/time.h>
#include <sys/stat.h>
#include <sys/sysctl.h>
#include <sys/signal.h>
#include <sys/proc.h>
#include <sys/ioctl.h>
#include <sys/socket.h>
#include <sys/tty.h>

#include <netinet/in.h>
#include <arpa/inet.h>

#include <ctype.h>
#include <err.h>
#include <errno.h>
#include <fcntl.h>
#include <kvm.h>
#include <netdb.h>
#include <nlist.h>
#include <paths.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <limits.h>
#include <utmp.h>
#include <vis.h>

#include "extern.h"

struct timeval	boottime;
struct utmp	utmp;
struct winsize	ws;
kvm_t	       *kd;
time_t		now;		/* the current time of day */
int		ttywidth;	/* width of tty */
int		argwidth;	/* width of tty */
int		header = 1;	/* true if -h flag: don't print heading */
int		nflag = 1;	/* true if -n flag: don't convert addrs */
int		sortidle;	/* sort by idle time */
char	       *sel_user;	/* login of particular user selected */
char		domain[HOST_NAME_MAX+1];

#define	NAME_WIDTH	8
#define HOST_WIDTH	16

/*
 * One of these per active utmp entry.
 */
struct	entry {
	struct	entry *next;
	struct	utmp utmp;
	dev_t	tdev;			/* dev_t of terminal */
	time_t	idle;			/* idle time of terminal in seconds */
	struct	kinfo_proc *kp;		/* `most interesting' proc */
} *ep, *ehead = NULL, **nextp = &ehead;

static void	 pr_args(struct kinfo_proc *);
static void	 pr_header(time_t *, int);
static struct stat
		*ttystat(char *);
static void	 usage(int);

int
main(int argc, char *argv[])
{
	extern char *__progname;
	struct kinfo_proc *kp;
	struct hostent *hp;
	struct stat *stp;
	FILE *ut;
	struct in_addr addr;
	int ch, i, nentries, nusers, wcmd;
	char *memf, *nlistf, *p, *x;
	char buf[HOST_NAME_MAX+1], errbuf[_POSIX2_LINE_MAX];

	/* Are we w(1) or uptime(1)? */
	p = __progname;
	if (*p == '-')
		p++;
	if (p[0] == 'w' && p[1] == '\0') {
		wcmd = 1;
		p = "hiflM:N:asuw";
	} else if (!strcmp(p, "uptime")) {
		wcmd = 0;
		p = "";
	} else
		errx(1,
		 "this program should be invoked only as \"w\" or \"uptime\"");

	memf = nlistf = NULL;
	while ((ch = getopt(argc, argv, p)) != -1)
		switch (ch) {
		case 'h':
			header = 0;
			break;
		case 'i':
			sortidle = 1;
			break;
		case 'M':
			header = 0;
			memf = optarg;
			break;
		case 'N':
			nlistf = optarg;
			break;
		case 'a':
			nflag = 0;
			break;
		case 'f': case 'l': case 's': case 'u': case 'w':
			warnx("[-flsuw] no longer supported");
			/* FALLTHROUGH */
		case '?':
		default:
			usage(wcmd);
		}
	argc -= optind;
	argv += optind;

	if (nflag == 0) {
		if (pledge("stdio tty rpath dns ps vminfo", NULL) == -1)
			err(1, "pledge");
	} else {
		if (pledge("stdio tty rpath ps vminfo", NULL) == -1)
			err(1, "pledge");
	}

	if (nlistf == NULL && memf == NULL) {
		if ((kd = kvm_openfiles(nlistf, memf, NULL, KVM_NO_FILES,
		    errbuf)) == NULL)
			errx(1, "%s", errbuf);
	} else {
		if ((kd = kvm_openfiles(nlistf, memf, NULL, O_RDONLY, errbuf)) == NULL)
			errx(1, "%s", errbuf);
	}

	(void)time(&now);
	if ((ut = fopen(_PATH_UTMP, "r")) == NULL)
		err(1, "%s", _PATH_UTMP);

	if (*argv)
		sel_user = *argv;

	for (nusers = 0; fread(&utmp, sizeof(utmp), 1, ut);) {
		if (utmp.ut_name[0] == '\0')
			continue;
		++nusers;
		if (wcmd == 0 || (sel_user &&
		    strncmp(utmp.ut_name, sel_user, UT_NAMESIZE) != 0))
			continue;
		if ((ep = calloc(1, sizeof(*ep))) == NULL)
			err(1, NULL);
		*nextp = ep;
		nextp = &(ep->next);
		memcpy(&(ep->utmp), &utmp, sizeof(utmp));
		if (!(stp = ttystat(ep->utmp.ut_line)))
			continue;
		ep->tdev = stp->st_rdev;

		/*
		 * If this is the console device, attempt to ascertain
		 * the true console device dev_t.
		 */
		if (ep->tdev == 0) {
			int mib[2];
			size_t size;

			mib[0] = CTL_KERN;
			mib[1] = KERN_CONSDEV;
			size = sizeof(dev_t);
			(void) sysctl(mib, 2, &ep->tdev, &size, NULL, 0);
		}

		if ((ep->idle = now - stp->st_atime) < 0)
			ep->idle = 0;
	}
	(void)fclose(ut);

	if (header || wcmd == 0) {
		pr_header(&now, nusers);
		if (wcmd == 0)
			exit (0);
	}

#define HEADER	"USER    TTY FROM              LOGIN@@  IDLE WHAT"
#define WUSED	(sizeof(HEADER) - sizeof("WHAT"))
	(void)puts(HEADER);

	kp = kvm_getprocs(kd, KERN_PROC_ALL, 0, sizeof(*kp), &nentries);
	if (kp == NULL)
		errx(1, "%s", kvm_geterr(kd));

	if ((ioctl(STDOUT_FILENO, TIOCGWINSZ, &ws) == -1 &&
	    ioctl(STDERR_FILENO, TIOCGWINSZ, &ws) == -1 &&
	    ioctl(STDIN_FILENO, TIOCGWINSZ, &ws) == -1) || ws.ws_col == 0)
		ttywidth = 79;
	else
		ttywidth = ws.ws_col - 1;
	argwidth = ttywidth - WUSED;
	if (argwidth < 4)
		argwidth = 8;

	for (i = 0; i < nentries; i++, kp++) {
		if (kp->p_psflags & (PS_EMBRYO | PS_ZOMBIE))
			continue;
		for (ep = ehead; ep != NULL; ep = ep->next) {
			/* ftp is a special case. */
			if (strncmp(ep->utmp.ut_line, "ftp", 3) == 0) {
				char pidstr[UT_LINESIZE-2];
				pid_t fp;

				(void)strncpy(pidstr, &ep->utmp.ut_line[3],
				    sizeof(pidstr) - 1);
				pidstr[sizeof(pidstr) - 1] = '\0';
				fp = (pid_t)strtol(pidstr, NULL, 10);
				if (kp->p_pid == fp) {
					ep->kp = kp;
					break;
				}
			} else if (ep->tdev == kp->p_tdev &&
			    kp->p__pgid == kp->p_tpgid) {
				/*
				 * Proc is in foreground of this terminal
				 */
				if (proc_compare(ep->kp, kp))
					ep->kp = kp;
				break;
			}
		}
	}
	/* sort by idle time */
	if (sortidle && ehead != NULL) {
		struct entry *from = ehead, *save;

		ehead = NULL;
		while (from != NULL) {
			for (nextp = &ehead;
			    (*nextp) && from->idle >= (*nextp)->idle;
			    nextp = &(*nextp)->next)
				continue;
			save = from;
			from = from->next;
			save->next = *nextp;
			*nextp = save;
		}
	}

	if (!nflag) {
		if (gethostname(domain, sizeof(domain)) < 0 ||
		    (p = strchr(domain, '.')) == 0)
			domain[0] = '\0';
		else {
			domain[sizeof(domain) - 1] = '\0';
			memmove(domain, p, strlen(p) + 1);
		}
	}

	for (ep = ehead; ep != NULL; ep = ep->next) {
		p = *ep->utmp.ut_host ? ep->utmp.ut_host : "-";
		for (x = NULL, i = 0; p[i] != '\0' && i < UT_HOSTSIZE; i++)
			if (p[i] == ':') {
				x = &p[i];
				*x++ = '\0';
				break;
			}
		if (!nflag && inet_aton(p, &addr) &&
		    (hp = gethostbyaddr((char *)&addr, sizeof(addr), AF_INET))) {
			if (domain[0] != '\0') {
				p = hp->h_name;
				p += strlen(hp->h_name);
				p -= strlen(domain);
				if (p > hp->h_name &&
				    strcasecmp(p, domain) == 0)
					*p = '\0';
			}
			p = hp->h_name;
		}
		if (x) {
			(void)snprintf(buf, sizeof(buf), "%s:%.*s", p,
			    (int)(ep->utmp.ut_host + UT_HOSTSIZE - x), x);
			p = buf;
		}
		(void)printf("%-*.*s %-2.2s %-*.*s ",
		    NAME_WIDTH, UT_NAMESIZE, ep->utmp.ut_name,
		    strncmp(ep->utmp.ut_line, "tty", 3) ?
		    ep->utmp.ut_line : ep->utmp.ut_line + 3,
		    HOST_WIDTH, HOST_WIDTH, *p ? p : "-");
		pr_attime(&ep->utmp.ut_time, &now);
		pr_idle(ep->idle);
		pr_args(ep->kp);
		printf("\n");
	}
	exit(0);
}

static void
pr_args(struct kinfo_proc *kp)
{
	char **argv, *str;
	int left;

	if (kp == NULL)
		goto nothing;		/* XXX - can this happen? */
	left = argwidth;
	argv = kvm_getargv(kd, kp, argwidth+60);  /* +60 for ftpd snip */
	if (argv == NULL)
		goto nothing;

	if (*argv == NULL || **argv == '\0') {
		/* Process has zeroed argv[0], display executable name. */
		fmt_putc('(', &left);
		fmt_puts(kp->p_comm, &left);
		fmt_putc(')', &left);
	}
	while (*argv) {
		/*
		 * ftp argv[0] is in the following format:
		 * ftpd: HOSTNAME: [USER/PASS: ]CMD args (ftpd)
		 */
		if (strncmp(*argv, "ftpd:", 5) == 0) {
			if ((str = strchr(*argv + 5, ':')) != NULL)
				str = strchr(str + 1, ':');
			if (str != NULL) {
				if ((str[0] == ':') &&
				    isspace((unsigned char)str[1]))
					str += 2;
				fmt_puts(str, &left);
			} else
				fmt_puts(*argv, &left);
		} else
			fmt_puts(*argv, &left);
		argv++;
		fmt_putc(' ', &left);
	}
	return;
nothing:
	putchar('-');
}

static void
pr_header(time_t *nowp, int nusers)
{
	double avenrun[3];
	time_t uptime;
	int days, hrs, i, mins;
	int mib[2];
	size_t size;
	char buf[256];

	/*
	 * Print time of day.
	 */
	(void)strftime(buf, sizeof(buf) - 1, "%l:%M%p", localtime(nowp));
	buf[sizeof(buf) - 1] = '\0';
	(void)printf("%s ", buf);

	/*
	 * Print how long system has been up.
	 * (Found by getting "boottime" from the kernel)
	 */
	mib[0] = CTL_KERN;
	mib[1] = KERN_BOOTTIME;
	size = sizeof(boottime);
	if (sysctl(mib, 2, &boottime, &size, NULL, 0) != -1) {
		uptime = now - boottime.tv_sec;
		if (uptime > 59) {
			uptime += 30;
			days = uptime / SECSPERDAY;
			uptime %= SECSPERDAY;
			hrs = uptime / SECSPERHOUR;
			uptime %= SECSPERHOUR;
			mins = uptime / 60;
			(void)printf(" up");
			if (days > 0)
				(void)printf(" %d day%s,", days,
				    days > 1 ? "s" : "");
			if (hrs > 0 && mins > 0)
				(void)printf(" %2d:%02d,", hrs, mins);
			else {
				if (hrs > 0)
					(void)printf(" %d hr%s,",
					    hrs, hrs > 1 ? "s" : "");
				if (mins > 0 || (days == 0 && hrs == 0))
					(void)printf(" %d min%s,",
					    mins, mins != 1 ? "s" : "");
			}
		} else
			printf(" %d secs,", (int)uptime);
	}

	/* Print number of users logged in to system */
	(void)printf(" %d user%s", nusers, nusers != 1 ? "s" : "");

	/*
	 * Print 1, 5, and 15 minute load averages.
	 */
	if (getloadavg(avenrun, sizeof(avenrun) / sizeof(avenrun[0])) == -1)
		(void)printf(", no load average information available\n");
	else {
		(void)printf(", load averages:");
		for (i = 0; i < (sizeof(avenrun) / sizeof(avenrun[0])); i++) {
			if (i > 0)
				(void)printf(",");
			(void)printf(" %.2f", avenrun[i]);
		}
		(void)printf("\n");
	}
}

static struct stat *
ttystat(char *line)
{
	static struct stat sb;
	char ttybuf[sizeof(_PATH_DEV) + UT_LINESIZE];

	/* Note, line may not be NUL-terminated */
	(void)strlcpy(ttybuf, _PATH_DEV, sizeof(ttybuf));
	(void)strncat(ttybuf, line, sizeof(ttybuf) - 1 - strlen(ttybuf));
	if (stat(ttybuf, &sb))
		return (NULL);
	return (&sb);
}

static void
usage(int wcmd)
{
	if (wcmd)
		(void)fprintf(stderr,
		    "usage: w [-ahi] [-M core] [-N system] [user]\n");
	else
		(void)fprintf(stderr,
		    "usage: uptime\n");
	exit (1);
}
@


1.60
log
@With new pledge "ps" and "vminfo" requests, ps/top/w become possible.
@
text
@d1 1
a1 1
/*	$OpenBSD: w.c,v 1.59 2015/08/31 15:49:34 deraadt Exp $	*/
a114 3
	if (pledge("stdio tty rpath ps vminfo", NULL) == -1)
		err(1, "pledge");

d157 8
@


1.59
log
@calculate screen size way earlier, this will provide some opportunities
for taming the string manipulation in the later half of the program.
@
text
@d1 1
a1 1
/*	$OpenBSD: w.c,v 1.58 2015/03/15 00:41:28 millert Exp $	*/
d114 3
@


1.58
log
@tzfile.h is an internal header that should never have been installed.
What's worse, the tzfile.h that gets installed is over 20 years old
and doesn't match the real tzfile.h in libc/time.  This makes the
tree safe for /usr/include/tzfile.h removal.  The TM_YEAR_BASE
define has been moved to time.h temporarily until its usage is
replaced by 1900 in the tree.  Actual removal of tzfile.h is pending
a ports build.  Based on a diff from deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: w.c,v 1.57 2015/01/16 06:40:14 deraadt Exp $	*/
d222 11
a260 9
	if ((ioctl(STDOUT_FILENO, TIOCGWINSZ, &ws) == -1 &&
	    ioctl(STDERR_FILENO, TIOCGWINSZ, &ws) == -1 &&
	    ioctl(STDIN_FILENO, TIOCGWINSZ, &ws) == -1) || ws.ws_col == 0)
		ttywidth = 79;
	else
		ttywidth = ws.ws_col - 1;
	argwidth = ttywidth - WUSED;
	if (argwidth < 4)
		argwidth = 8;
@


1.57
log
@Replace <sys/param.h> with <limits.h> and other less dirty headers where
possible.  Annotate <sys/param.h> lines with their current reasons.  Switch
to PATH_MAX, NGROUPS_MAX, HOST_NAME_MAX+1, LOGIN_NAME_MAX, etc.  Change
MIN() and MAX() to local definitions of MINIMUM() and MAXIMUM() where
sensible to avoid pulling in the pollution.  These are the files confirmed
through binary verification.
ok guenther, millert, doug (helped with the verification protocol)
@
text
@d1 1
a1 1
/*	$OpenBSD: w.c,v 1.56 2014/07/08 23:24:28 deraadt Exp $	*/
a61 1
#include <tzfile.h>
d400 1
a400 1
			mins = uptime / SECSPERMIN;
@


1.56
log
@Cannot find a reason for this to need machine/cpu.h
@
text
@d1 1
a1 1
/*	$OpenBSD: w.c,v 1.55 2014/07/04 05:58:31 guenther Exp $	*/
d38 1
a38 1
#include <sys/param.h>
d42 1
d81 1
a81 1
char		domain[MAXHOSTNAMELEN];
d114 1
a114 1
	char buf[MAXHOSTNAMELEN], errbuf[_POSIX2_LINE_MAX];
@


1.55
log
@Track whether a process is a zombie or not yet fully built via flags
PS_{ZOMBIE,EMBRYO} on the process instead of peeking into the process's
thread data.  This eliminates the need for the thread-level SDEAD state.

Change kvm_getprocs() (both the sysctl() and kvm backends) to report the
"most active" scheduler state for the process's threads.

tweaks kettenis@@
feedback and ok matthew@@
@
text
@d1 1
a1 1
/*	$OpenBSD: w.c,v 1.54 2013/11/20 21:00:33 deraadt Exp $	*/
a46 1
#include <machine/cpu.h>
@


1.54
log
@str derives from argv; so use an unsigned char cast for isspace()
ok ratchov
@
text
@d1 1
a1 1
/*	$OpenBSD: w.c,v 1.53 2013/10/31 02:00:12 deraadt Exp $	*/
d224 1
a224 1
		if (kp->p_stat == SIDL || kp->p_stat == SZOMB)
@


1.53
log
@sometimes we find .h we no longer need
@
text
@d1 1
a1 1
/*	$OpenBSD: w.c,v 1.52 2013/08/22 04:43:41 guenther Exp $	*/
d353 2
a354 1
				if ((str[0] == ':') && isspace(str[1]))
@


1.52
log
@Correct format string mismatches turned up by -Wformat=2

suggestions and ok millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: w.c,v 1.51 2012/06/24 06:34:34 guenther Exp $	*/
a42 1
#include <sys/user.h>
@


1.51
log
@Fix comment.  Pointed out by Seth Wright (seth at crosse.org)
@
text
@d1 1
a1 1
/*	$OpenBSD: w.c,v 1.50 2011/07/28 10:14:00 kettenis Exp $	*/
d417 1
a417 1
			printf(" %d secs,", uptime);
@


1.50
log
@Adjust for machdep.consdev -> kern.consdev sysctl change.  This should restore
the functionality to figure out the real console device when /dev/console is
used.

ok millert@@, deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: w.c,v 1.49 2011/04/26 07:29:05 jasper Exp $	*/
d388 1
a388 1
	 * (Found by looking getting "boottime" from the kernel)
@


1.49
log
@tyop in comment
@
text
@d1 1
a1 1
/*	$OpenBSD: w.c,v 1.48 2011/04/10 03:20:59 guenther Exp $	*/
d191 1
a191 1
#ifdef CPU_CONSDEV
d200 2
a201 2
			mib[0] = CTL_MACHDEP;
			mib[1] = CPU_CONSDEV;
d205 1
a205 1
#endif
@


1.48
log
@Switch back from KERN_PROC2/kinfo_proc2 to KERN_PROC/kinfo_proc now
that we've got name we want for the API we want

"ZAP!" deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: w.c,v 1.47 2009/10/27 23:59:49 deraadt Exp $	*/
d80 1
a80 1
int		sortidle;	/* sort bu idle time */
@


1.47
log
@rcsid[] and sccsid[] and copyright[] are essentially unmaintained (and
unmaintainable).  these days, people use source.  these id's do not provide
any benefit, and do hurt the small install media
(the 33,000 line diff is essentially mechanical)
ok with the idea millert, ok dms
@
text
@d1 1
a1 1
/*	$OpenBSD: w.c,v 1.46 2008/09/30 21:29:58 millert Exp $	*/
d95 1
a95 1
	struct	kinfo_proc2 *kp;	/* `most interesting' proc */
d98 1
a98 1
static void	 pr_args(struct kinfo_proc2 *);
d108 1
a108 1
	struct kinfo_proc2 *kp;
d221 1
a221 1
	kp = kvm_getproc2(kd, KERN_PROC_ALL, 0, sizeof(*kp), &nentries);
d327 1
a327 1
pr_args(struct kinfo_proc2 *kp)
d335 1
a335 1
	argv = kvm_getargv2(kd, kp, argwidth+60);  /* +60 for ftpd snip */
@


1.46
log
@Properly display files with embedded colons being xferred via ftd.
Closes PR 5119.  OK miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: w.c,v 1.45 2005/07/20 04:19:08 jaredy Exp $	*/
a30 14

#ifndef lint
static char copyright[] =
"@@(#) Copyright (c) 1980, 1991, 1993, 1994\n\
	The Regents of the University of California.  All rights reserved.\n";
#endif /* not lint */

#ifndef lint
#if 0
static char sccsid[] = "@@(#)w.c	8.4 (Berkeley) 4/16/94";
#else
static char *rcsid = "$OpenBSD: w.c,v 1.45 2005/07/20 04:19:08 jaredy Exp $";
#endif
#endif /* not lint */
@


1.45
log
@remove the -M and -N flags to uptime, they do nothing.
w(1) is unaffected by this.

closes PR#4298

ok millert, deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: w.c,v 1.44 2005/04/11 07:04:47 deraadt Exp $	*/
d42 1
a42 1
static char *rcsid = "$OpenBSD: w.c,v 1.44 2005/04/11 07:04:47 deraadt Exp $";
d360 4
a363 1
		/* ftp is a special case... */
d365 3
a367 2
			str = strrchr(*argv, ':');
			if (str != (char *)NULL) {
@


1.44
log
@spacing
@
text
@d1 1
a1 1
/*	$OpenBSD: w.c,v 1.43 2004/09/14 22:24:24 deraadt Exp $	*/
d42 1
a42 1
static char *rcsid = "$OpenBSD: w.c,v 1.43 2004/09/14 22:24:24 deraadt Exp $";
d140 1
a140 1
		p = "M:N:";
d471 1
a471 1
		    "usage: uptime [-M core] [-N system]\n");
@


1.43
log
@delete unused variable
@
text
@d1 1
a1 1
/*	$OpenBSD: w.c,v 1.42 2004/08/18 21:27:20 jmc Exp $	*/
d42 1
a42 1
static char *rcsid = "$OpenBSD: w.c,v 1.42 2004/08/18 21:27:20 jmc Exp $";
d267 5
a271 5
	     ioctl(STDERR_FILENO, TIOCGWINSZ, &ws) == -1 &&
	     ioctl(STDIN_FILENO, TIOCGWINSZ, &ws) == -1) || ws.ws_col == 0)
	       ttywidth = 79;
        else
	       ttywidth = ws.ws_col - 1;
d278 1
a278 1
		
d291 1
a291 1
			
@


1.42
log
@- .Xr utmp 5
- sort options and sync usage()
@
text
@d1 1
a1 1
/*	$OpenBSD: w.c,v 1.41 2004/01/08 18:14:51 millert Exp $	*/
d42 1
a42 1
static char *rcsid = "$OpenBSD: w.c,v 1.41 2004/01/08 18:14:51 millert Exp $";
a89 1
time_t		uptime;		/* time of last reboot & elapsed time since */
@


1.41
log
@Convert to kinfo_proc2; ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: w.c,v 1.40 2003/11/26 00:31:27 millert Exp $	*/
d42 1
a42 1
static char *rcsid = "$OpenBSD: w.c,v 1.40 2003/11/26 00:31:27 millert Exp $";
d469 1
a469 1
		    "usage: w [-hia] [-M core] [-N system] [user]\n");
@


1.40
log
@Minor cleanup.  Remove gratuitous use of __CONCAT that was needed
to avoid SCCS braindamage.  Also use ANSI function headers while
we are here.  Based on a diff from espie@@
@
text
@d1 1
a1 1
/*	$OpenBSD: w.c,v 1.39 2003/06/03 02:56:22 millert Exp $	*/
d42 1
a42 1
static char *rcsid = "$OpenBSD: w.c,v 1.39 2003/06/03 02:56:22 millert Exp $";
d108 3
a110 3
	dev_t	tdev;		/* dev_t of terminal */
	time_t	idle;		/* idle time of terminal in seconds */
	struct	kinfo_proc *kp;	/* `most interesting' proc */
d113 1
a113 1
static void	 pr_args(struct kinfo_proc *);
d123 1
a123 1
	struct kinfo_proc *kp;
d236 2
a237 1
	if ((kp = kvm_getprocs(kd, KERN_PROC_ALL, 0, &nentries)) == NULL)
d240 1
a240 4
		struct proc *p = &kp->kp_proc;
		struct eproc *e;

		if (p->p_stat == SIDL || p->p_stat == SZOMB)
a241 1
		e = &kp->kp_eproc;
d252 1
a252 1
				if (p->p_pid == fp) {
d256 2
a257 2
			} else if (ep->tdev == e->e_tdev &&
			    e->e_pgid == e->e_tpgid) {
d261 1
a261 1
				if (proc_compare(&ep->kp->kp_proc, p))
d342 1
a342 1
pr_args(struct kinfo_proc *kp)
d348 1
a348 1
		goto nothing;
d350 1
a350 1
	argv = kvm_getargv(kd, kp, argwidth+60);  /* +60 for ftpd snip */
d357 1
a357 1
		fmt_puts(kp->kp_proc.p_comm, &left);
@


1.39
log
@Remove the advertising clause in the UCB license which Berkeley
rescinded 22 July 1999.  Proofed by myself and Theo.
@
text
@d1 1
a1 1
/*	$OpenBSD: w.c,v 1.38 2002/09/17 19:37:40 deraadt Exp $	*/
d42 1
a42 1
static char *rcsid = "$OpenBSD: w.c,v 1.38 2002/09/17 19:37:40 deraadt Exp $";
a394 3
	 *
	 * SCCS forces the string manipulation below, as it replaces
	 * %, M, and % in a character string with the file name.
d396 1
a396 2
	(void)strftime(buf, sizeof(buf) - 1,
	    __CONCAT("%l:%","M%p"), localtime(nowp));
@


1.38
log
@ansi
@
text
@d1 1
a1 1
/*	$OpenBSD: w.c,v 1.37 2002/06/08 22:57:34 angelos Exp $	*/
d15 1
a15 5
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
d42 1
a42 1
static char *rcsid = "$OpenBSD: w.c,v 1.37 2002/06/08 22:57:34 angelos Exp $";
@


1.37
log
@No need to be setgid kmem anymore.
@
text
@d1 1
a1 1
/*	$OpenBSD: w.c,v 1.36 2002/02/19 18:38:02 mpech Exp $	*/
d46 1
a46 1
static char *rcsid = "$OpenBSD: w.c,v 1.36 2002/02/19 18:38:02 mpech Exp $";
d124 1
a124 3
main(argc, argv)
	int argc;
	char **argv;
d180 2
a181 1
		if ((kd = kvm_openfiles(nlistf, memf, NULL, KVM_NO_FILES, errbuf)) == NULL)
d349 1
a349 2
pr_args(kp)
	struct kinfo_proc *kp;
d388 1
a388 3
pr_header(nowp, nusers)
	time_t *nowp;
	int nusers;
d462 1
a462 2
ttystat(line)
	char *line;
d476 1
a476 2
usage(wcmd)
	int wcmd;
@


1.36
log
@Fix gethostname() usage.

deraadt@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: w.c,v 1.35 2002/02/16 21:27:58 millert Exp $	*/
d46 1
a46 1
static char *rcsid = "$OpenBSD: w.c,v 1.35 2002/02/16 21:27:58 millert Exp $";
d181 6
a186 7
	/*
	 * Discard setgid privileges if not the running kernel so that bad
	 * guys can't print interesting stuff from kernel memory.
	 */
	if (nlistf != NULL || memf != NULL) {
		setegid(getgid());
		setgid(getgid());
a187 6

	if ((kd = kvm_openfiles(nlistf, memf, NULL, O_RDONLY, errbuf)) == NULL)
		errx(1, "%s", errbuf);

	setegid(getgid());
	setgid(getgid());
@


1.35
log
@Part one of userland __P removal.  Done with a simple regexp with some minor hand editing to make comments line up correctly.  Another pass is forthcoming that handles the cases that could not be done automatically.
@
text
@d1 1
a1 1
/*	$OpenBSD: w.c,v 1.34 2001/07/12 05:17:31 deraadt Exp $	*/
d46 1
a46 1
static char *rcsid = "$OpenBSD: w.c,v 1.34 2001/07/12 05:17:31 deraadt Exp $";
d309 1
a309 1
		if (gethostname(domain, sizeof(domain) - 1) < 0 ||
@


1.34
log
@first pass at a -Wall cleanup
@
text
@d1 1
a1 1
/*	$OpenBSD: w.c,v 1.33 2001/05/30 20:57:58 smart Exp $	*/
d46 1
a46 1
static char *rcsid = "$OpenBSD: w.c,v 1.33 2001/05/30 20:57:58 smart Exp $";
d117 2
a118 2
static void	 pr_args __P((struct kinfo_proc *));
static void	 pr_header __P((time_t *, int));
d120 2
a121 2
		*ttystat __P((char *));
static void	 usage __P((int));
@


1.33
log
@- Fix usage
- Remove an instance of "'buf[sizeof(buf) - 1] = '\0'"
- A few style nits

deraadt@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: w.c,v 1.32 2001/01/31 17:42:26 deraadt Exp $	*/
d46 1
a46 1
static char *rcsid = "$OpenBSD: w.c,v 1.32 2001/01/31 17:42:26 deraadt Exp $";
d308 1
a308 1
	if (!nflag)
d316 1
d340 1
a340 1
			    ep->utmp.ut_host + UT_HOSTSIZE - x, x);
@


1.32
log
@move utmp to large format, usernames to 32 chars; downsj
@
text
@d1 1
a1 1
/*	$OpenBSD: w.c,v 1.31 2000/12/23 02:07:49 deraadt Exp $	*/
d46 1
a46 1
static char *rcsid = "$OpenBSD: w.c,v 1.31 2000/12/23 02:07:49 deraadt Exp $";
d210 1
a210 1
		if ((ep = calloc(1, sizeof(struct entry))) == NULL)
d214 1
a214 1
		memcpy(&(ep->utmp), &utmp, sizeof(struct utmp));
d245 1
a245 1
#define WUSED	(sizeof (HEADER) - sizeof ("WHAT"))
d271 2
a272 2
			} else if (ep->tdev == e->e_tdev
				   && e->e_pgid == e->e_tpgid) {
d415 1
a415 1
	buf[sizeof buf -1] = '\0';
d479 2
a480 3
	(void)strcpy(ttybuf, _PATH_DEV);
	(void)strncpy(ttybuf + sizeof(_PATH_DEV) - 1, line, UT_LINESIZE);
	ttybuf[sizeof(ttybuf) - 1] = '\0';
d492 1
a492 1
		    "usage: w: [-hia] [-M core] [-N system] [user]\n");
d494 2
a495 1
		(void)fprintf(stderr, "usage: uptime\n");
@


1.31
log
@hostnames are case-insensitive; brian
@
text
@d1 1
a1 1
/*	$OpenBSD: w.c,v 1.30 2000/07/07 21:09:02 deraadt Exp $	*/
d46 1
a46 1
static char *rcsid = "$OpenBSD: w.c,v 1.30 2000/07/07 21:09:02 deraadt Exp $";
d103 3
d343 1
a343 1
		    UT_NAMESIZE, UT_NAMESIZE, ep->utmp.ut_name,
d346 1
a346 1
		    UT_HOSTSIZE, UT_HOSTSIZE, *p ? p : "-");
@


1.30
log
@or just use puts() instead
@
text
@d1 1
a1 1
/*	$OpenBSD: w.c,v 1.29 2000/07/07 21:07:41 deraadt Exp $	*/
d46 1
a46 1
static char *rcsid = "$OpenBSD: w.c,v 1.29 2000/07/07 21:07:41 deraadt Exp $";
d328 2
a329 1
				if (p > hp->h_name && strcmp(p, domain) == 0)
@


1.29
log
@heck, be more careful with printf here too
@
text
@d1 1
a1 1
/*	$OpenBSD: w.c,v 1.28 1999/08/12 19:26:39 millert Exp $	*/
d46 1
a46 1
static char *rcsid = "$OpenBSD: w.c,v 1.28 1999/08/12 19:26:39 millert Exp $";
d241 3
a243 3
#define HEADER	"USER    TTY FROM              LOGIN@@  IDLE WHAT\n"
#define WUSED	(sizeof (HEADER) - sizeof ("WHAT\n"))
	(void)printf("%s", HEADER);
@


1.28
log
@Support -M and -N flags in uptime mode too
@
text
@d1 1
a1 1
/*	$OpenBSD: w.c,v 1.27 1999/06/05 17:04:59 deraadt Exp $	*/
d46 1
a46 1
static char *rcsid = "$OpenBSD: w.c,v 1.27 1999/06/05 17:04:59 deraadt Exp $";
d243 1
a243 1
	(void)printf(HEADER);
@


1.27
log
@use inet_aton()
@
text
@d1 1
a1 1
/*	$OpenBSD: w.c,v 1.26 1999/04/25 00:33:56 millert Exp $	*/
d46 1
a46 1
static char *rcsid = "$OpenBSD: w.c,v 1.26 1999/04/25 00:33:56 millert Exp $";
d144 1
a144 1
		p = "";
@


1.26
log
@Make ttystat() work correctly with strings that are not NUL-terminated.
If ut_line begins with "ftp" copy the pid into a temp buffer before
the strol() since ut_line may not be NUL-terminated.
@
text
@d1 1
a1 1
/*	$OpenBSD: w.c,v 1.25 1998/07/08 22:14:20 deraadt Exp $	*/
d46 1
a46 1
static char *rcsid = "$OpenBSD: w.c,v 1.25 1998/07/08 22:14:20 deraadt Exp $";
d130 1
a130 1
	u_long l;
d322 2
a323 3
		if (!nflag && isdigit(*p) &&
		    (long)(l = inet_addr(p)) != -1 &&
		    (hp = gethostbyaddr((char *)&l, sizeof(l), AF_INET))) {
@


1.25
log
@whack kmem gid after kvm_openfiles()
@
text
@d1 1
a1 1
/*	$OpenBSD: w.c,v 1.24 1998/02/03 19:18:22 deraadt Exp $	*/
d46 1
a46 1
static char *rcsid = "$OpenBSD: w.c,v 1.24 1998/02/03 19:18:22 deraadt Exp $";
d211 1
a211 1
		memmove(&(ep->utmp), &utmp, sizeof(struct utmp));
d257 7
a263 2
				pid_t fp = (pid_t)strtol(&ep->utmp.ut_line[3],
							 NULL, 10);
a265 1

d362 1
a362 1
	argv = kvm_getargv(kd, kp, argwidth+60);  /*+60 for ftpd snip */
d473 1
a473 1
	char ttybuf[MAXPATHLEN];
d475 4
a478 1
	(void)snprintf(ttybuf, sizeof(ttybuf), "%s/%s", _PATH_DEV, line);
@


1.24
log
@usage line fix; pjanzen@@foatdi.harvard.edu
@
text
@d1 1
a1 1
/*	$OpenBSD: w.c,v 1.23 1998/01/16 17:50:43 millert Exp $	*/
d46 1
a46 1
static char *rcsid = "$OpenBSD: w.c,v 1.23 1998/01/16 17:50:43 millert Exp $";
d189 3
@


1.23
log
@Add rcsid tags.
If program has set argv[0] or argv[0][0] to NUL, print p->p_comm
instead.  Based on patch from Paul Janzen <pjanzen@@foatdi.harvard.edu>
@
text
@d1 1
a1 1
/*	$OpenBSD: w.c,v 1.22 1997/12/24 19:57:11 deraadt Exp $	*/
d46 1
a46 1
static char *rcsid = "$OpenBSD$";
d482 1
a482 1
		(void)fprintf(stderr, "uptime\n");
@


1.22
log
@No, we are not making our w command incompatible
@
text
@d1 1
a1 1
/*	$OpenBSD: w.c,v 1.20 1997/07/25 14:36:24 kstailey Exp $	*/
d43 1
d45 3
d352 1
a352 1
	if (kp == 0)
d356 1
a356 1
	if (argv == 0)
d359 6
@


1.21
log
@3 letters for tty name; for ftp
@
text
@d234 1
a234 1
#define HEADER	"USER     TTY FROM              LOGIN@@  IDLE WHAT\n"
d328 1
a328 1
		(void)printf("%-*.*s %3.3s %-*.*s ",
@


1.20
log
@more to the point err. msg.
@
text
@d1 1
a1 1
/*	$OpenBSD: w.c,v 1.19 1997/07/25 05:04:07 mickey Exp $	*/
d234 1
a234 1
#define HEADER	"USER    TTY FROM              LOGIN@@  IDLE WHAT\n"
d328 1
a328 1
		(void)printf("%-*.*s %-2.2s %-*.*s ",
@


1.19
log
@proper progname grok
proper printing for uptime < 1min
@
text
@d1 1
a1 1
/*	$OpenBSD: w.c,v 1.18 1997/05/30 18:40:46 deraadt Exp $	*/
d142 2
a143 1
		errx(1, "bad program name");
@


1.18
log
@shorter
@
text
@d1 1
a1 1
/*	$OpenBSD: w.c,v 1.17 1997/05/30 18:39:44 deraadt Exp $	*/
d135 4
a138 1
	if (*p == 'u') {
d141 2
a142 4
	} else {
		wcmd = 1;
		p = "hiflM:N:asuw";
	}
d406 1
a406 1
		if (boottime.tv_sec > 59) {
@


1.17
log
@if less than 60 secs of uptime, say so
@
text
@d1 1
a1 1
/*	$OpenBSD: w.c,v 1.16 1997/04/01 07:58:40 millert Exp $	*/
d427 1
a427 1
			printf(" %d seconds,", uptime);
@


1.16
log
@Slightly better fix.  This one is explicately bounded by UT_HOSTSIZE.
@
text
@d1 1
a1 1
/*	$OpenBSD: w.c,v 1.15 1997/03/30 18:16:02 millert Exp $	*/
d403 1
a403 2
	if (sysctl(mib, 2, &boottime, &size, NULL, 0) != -1 &&
	    boottime.tv_sec != 0) {
d405 23
a427 19
		uptime += 30;
		days = uptime / SECSPERDAY;
		uptime %= SECSPERDAY;
		hrs = uptime / SECSPERHOUR;
		uptime %= SECSPERHOUR;
		mins = uptime / SECSPERMIN;
		(void)printf(" up");
		if (days > 0)
			(void)printf(" %d day%s,", days, days > 1 ? "s" : "");
		if (hrs > 0 && mins > 0)
			(void)printf(" %2d:%02d,", hrs, mins);
		else {
			if (hrs > 0)
				(void)printf(" %d hr%s,",
				    hrs, hrs > 1 ? "s" : "");
			if (mins > 0 || (days == 0 && hrs == 0))
				(void)printf(" %d min%s,",
				    mins, mins != 1 ? "s" : "");
		}
@


1.15
log
@NetBSD PR #3399:  Avoid overflowing in ut_host into ut_time (bounds check).  Fix from Tatoku Ogaito
@
text
@d1 1
a1 1
/*	$OpenBSD: w.c,v 1.14 1997/03/25 21:24:12 deraadt Exp $	*/
d303 6
a308 4
		if ((x = strchr(p, ':')) != NULL && x - p <= UT_HOSTSIZE)
			*x++ = '\0';
		else
			x = NULL;
@


1.14
log
@ensure strftime buf has NUL; yokota@@freebsd
@
text
@d1 1
a1 1
/*	$OpenBSD: w.c,v 1.13 1997/02/19 11:16:04 angelos Exp $	*/
d303 1
a303 1
		if ((x = strchr(p, ':')) != NULL)
d305 2
@


1.13
log
@Change usage() so it shows the right line arguments.
@
text
@d1 1
a1 1
/*	$OpenBSD: w.c,v 1.12 1997/01/15 23:43:35 millert Exp $	*/
d387 1
a387 1
	(void)strftime(buf, sizeof(buf),
d389 1
@


1.12
log
@getopt(3) returns -1 when out of args, not EOF, whee!
@
text
@d1 1
a1 1
/*	$OpenBSD: w.c,v 1.11 1996/12/22 03:26:10 tholo Exp $	*/
d460 1
a460 1
		    "usage: w: [-hin] [-M core] [-N system] [user]\n");
@


1.11
log
@Deal with _POSIX_SAVED_IDS when relinquishing privileges
@
text
@d1 1
a1 1
/*	$OpenBSD: w.c,v 1.10 1996/08/22 09:37:19 deraadt Exp $	*/
d144 1
a144 1
	while ((ch = getopt(argc, argv, p)) != EOF)
@


1.10
log
@header glitch if system up < 1 minute; from mouse@@Collatz.McRCIM.McGill.EDU
@
text
@d1 1
a1 1
/*	$OpenBSD: w.c,v 1.9 1996/08/22 06:46:36 deraadt Exp $	*/
d176 2
a177 1
	if (nlistf != NULL || memf != NULL)
d179 1
@


1.9
log
@deal with argument snip
@
text
@d1 1
a1 1
/*	$OpenBSD: w.c,v 1.8 1996/08/22 02:16:01 downsj Exp $	*/
d414 1
a414 1
			if (mins > 0)
d416 1
a416 1
				    mins, mins > 1 ? "s" : "");
@


1.8
log
@Slightly better.
@
text
@d1 1
a1 1
/*	$OpenBSD: w.c,v 1.7 1996/08/22 02:12:33 downsj Exp $	*/
d343 1
a343 1
	argv = kvm_getargv(kd, kp, argwidth);
@


1.7
log
@Handle ftp entries better.
@
text
@d1 1
a1 1
/*	$OpenBSD: w.c,v 1.6 1996/08/12 02:28:43 deraadt Exp $	*/
d352 1
a352 1
				if (strlen(str) > 2)
@


1.6
log
@invert -n into -a; default is no gethostbyaddr()
@
text
@d1 1
a1 1
/*	$OpenBSD: w.c,v 1.5 1996/08/06 20:41:32 deraadt Exp $	*/
d244 11
a254 1
			if (ep->tdev == e->e_tdev && e->e_pgid == e->e_tpgid) {
d337 1
a337 1
	char **argv;
d346 1
d348 11
a358 1
		fmt_puts(*argv, &left);
@


1.5
log
@_POSIX2_LINE_MAX errbuf for kvm_openfiles()
@
text
@d1 1
a1 1
/*	$OpenBSD: w.c,v 1.4 1996/06/26 05:42:45 deraadt Exp $	*/
d94 1
a94 1
int		nflag;		/* true if -n flag: don't convert addrs */
d140 1
a140 1
		p = "hiflM:N:nsuw";
d159 2
a160 2
		case 'n':
			nflag = 1;
@


1.4
log
@rcsid
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d79 1
d129 1
a129 1
	char buf[MAXHOSTNAMELEN], errbuf[256];
@


1.3
log
@revoke privs before opening kvm if user has specified mem/kernel paths
@
text
@d1 2
@


1.2
log
@sync to netbsd 960418
@
text
@d169 7
@


1.1
log
@Initial revision
@
text
@d225 1
a225 1
		err(1, "%s", kvm_geterr(kd));
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@
