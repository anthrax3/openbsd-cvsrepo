head	1.27;
access;
symbols
	OPENBSD_5_1_BASE:1.26
	OPENBSD_5_1:1.26.0.2
	OPENBSD_5_0:1.25.0.2
	OPENBSD_5_0_BASE:1.25
	OPENBSD_4_9:1.18.0.4
	OPENBSD_4_9_BASE:1.18
	OPENBSD_4_8:1.18.0.2
	OPENBSD_4_8_BASE:1.18
	OPENBSD_4_7:1.16.0.10
	OPENBSD_4_7_BASE:1.16
	OPENBSD_4_6:1.16.0.12
	OPENBSD_4_6_BASE:1.16
	OPENBSD_4_5:1.16.0.8
	OPENBSD_4_5_BASE:1.16
	OPENBSD_4_4:1.16.0.6
	OPENBSD_4_4_BASE:1.16
	OPENBSD_4_3:1.16.0.4
	OPENBSD_4_3_BASE:1.16
	OPENBSD_4_2:1.16.0.2
	OPENBSD_4_2_BASE:1.16
	OPENBSD_4_1:1.15.0.4
	OPENBSD_4_1_BASE:1.15
	OPENBSD_4_0:1.15.0.2
	OPENBSD_4_0_BASE:1.15
	OPENBSD_3_9:1.12.0.2
	OPENBSD_3_9_BASE:1.12
	OPENBSD_3_8:1.8.0.16
	OPENBSD_3_8_BASE:1.8
	OPENBSD_3_7:1.8.0.14
	OPENBSD_3_7_BASE:1.8
	OPENBSD_3_6:1.8.0.12
	OPENBSD_3_6_BASE:1.8
	OPENBSD_3_5:1.8.0.10
	OPENBSD_3_5_BASE:1.8
	OPENBSD_3_4:1.8.0.8
	OPENBSD_3_4_BASE:1.8
	OPENBSD_3_3:1.8.0.6
	OPENBSD_3_3_BASE:1.8
	OPENBSD_3_2:1.8.0.4
	OPENBSD_3_2_BASE:1.8
	OPENBSD_3_1:1.8.0.2
	OPENBSD_3_1_BASE:1.8
	OPENBSD_3_0:1.5.0.14
	OPENBSD_3_0_BASE:1.5
	OPENBSD_2_9_BASE:1.5
	OPENBSD_2_9:1.5.0.12
	OPENBSD_2_8:1.5.0.10
	OPENBSD_2_8_BASE:1.5
	OPENBSD_2_7:1.5.0.8
	OPENBSD_2_7_BASE:1.5
	OPENBSD_2_6:1.5.0.6
	OPENBSD_2_6_BASE:1.5
	OPENBSD_2_5:1.5.0.4
	OPENBSD_2_5_BASE:1.5
	OPENBSD_2_4:1.5.0.2
	OPENBSD_2_4_BASE:1.5
	OPENBSD_2_3:1.3.0.4
	OPENBSD_2_3_BASE:1.3
	OPENBSD_2_2:1.3.0.2
	OPENBSD_2_2_BASE:1.3
	OPENBSD_2_1:1.2.0.4
	OPENBSD_2_1_BASE:1.2
	OPENBSD_2_0:1.2.0.2
	OPENBSD_2_0_BASE:1.2
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.27
date	2012.04.08.16.27.00;	author jsg;	state dead;
branches;
next	1.26;

1.26
date	2011.09.21.18.08.07;	author jsg;	state Exp;
branches;
next	1.25;

1.25
date	2011.07.03.18.15.10;	author martynas;	state Exp;
branches;
next	1.24;

1.24
date	2011.06.20.13.33.47;	author martynas;	state Exp;
branches;
next	1.23;

1.23
date	2011.06.20.13.29.09;	author millert;	state Exp;
branches;
next	1.22;

1.22
date	2011.06.20.13.27.07;	author millert;	state Exp;
branches;
next	1.21;

1.21
date	2011.06.18.22.29.59;	author tedu;	state Exp;
branches;
next	1.20;

1.20
date	2011.05.31.22.27.54;	author martynas;	state Exp;
branches;
next	1.19;

1.19
date	2011.05.31.21.25.30;	author martynas;	state Exp;
branches;
next	1.18;

1.18
date	2010.07.27.20.07.56;	author guenther;	state Exp;
branches;
next	1.17;

1.17
date	2010.07.24.22.17.03;	author guenther;	state Exp;
branches;
next	1.16;

1.16
date	2007.05.26.00.36.04;	author krw;	state Exp;
branches;
next	1.15;

1.15
date	2006.07.09.19.37.00;	author miod;	state Exp;
branches;
next	1.14;

1.14
date	2006.05.29.20.47.22;	author cloder;	state Exp;
branches;
next	1.13;

1.13
date	2006.04.25.01.25.41;	author cloder;	state Exp;
branches;
next	1.12;

1.12
date	2005.12.10.20.26.10;	author cloder;	state Exp;
branches;
next	1.11;

1.11
date	2005.12.01.05.06.40;	author cloder;	state Exp;
branches;
next	1.10;

1.10
date	2005.11.20.17.42.50;	author deraadt;	state Exp;
branches;
next	1.9;

1.9
date	2005.11.20.17.09.55;	author cloder;	state Exp;
branches;
next	1.8;

1.8
date	2002.02.17.19.42.35;	author millert;	state Exp;
branches;
next	1.7;

1.7
date	2002.02.16.21.27.59;	author millert;	state Exp;
branches;
next	1.6;

1.6
date	2001.11.19.19.22.43;	author deraadt;	state Exp;
branches;
next	1.5;

1.5
date	98.07.29.03.14.51;	author millert;	state Exp;
branches;
next	1.4;

1.4
date	98.07.27.16.53.43;	author deraadt;	state Exp;
branches;
next	1.3;

1.3
date	97.09.08.08.43.17;	author deraadt;	state Exp;
branches;
next	1.2;

1.2
date	96.06.26.05.44.21;	author deraadt;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.47.03;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.47.03;	author deraadt;	state Exp;
branches;
next	;


desc
@@


1.27
log
@tedu lint
ok tedu@@ guenther@@ krw@@ espie@@ deraadt@@
@
text
@/*	$OpenBSD: chk.c,v 1.26 2011/09/21 18:08:07 jsg Exp $	*/
/*	$NetBSD: chk.c,v 1.2 1995/07/03 21:24:42 cgd Exp $	*/

/*
 * Copyright (c) 1994, 1995 Jochen Pohl
 * All Rights Reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *      This product includes software developed by Jochen Pohl for
 *	The NetBSD Project.
 * 4. The name of the author may not be used to endorse or promote products
 *    derived from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
 * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
 * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

#include <stdlib.h>
#include <ctype.h>
#include <limits.h>
#include <stdbool.h>
#include <complex.h>
#include <err.h>

#include "lint2.h"

/* various type information */
ttab_t	ttab[NTSPEC];


static	void	chkund(hte_t *);
static	void	chkdnu(hte_t *);
static	void	chkdnud(hte_t *);
static	void	chkmd(hte_t *);
static	void	chkvtui(hte_t *, sym_t *, sym_t *);
static	void	chkvtdi(hte_t *, sym_t *, sym_t *);
static	void	chkfaui(hte_t *, sym_t *, sym_t *);
static	void	chkau(hte_t *, int, sym_t *, sym_t *, pos_t *,
		   fcall_t *, fcall_t *, type_t *, type_t *);
static	void	chkrvu(hte_t *, sym_t *);
static	void	chkadecl(hte_t *, sym_t *, sym_t *);
static	void	printflike(hte_t *,fcall_t *, int, const char *, type_t **);
static	void	scanflike(hte_t *, fcall_t *, int, const char *, type_t **);
static	void	badfmt(hte_t *, fcall_t *);
static	void	inconarg(hte_t *, fcall_t *, int);
static	void	tofewarg(hte_t *, fcall_t *);
static	void	tomanyarg(hte_t *, fcall_t *);
static	int	eqtype(type_t *, type_t *, int, int, int, int *);
static	int	eqargs(type_t *, type_t *, int *);
static	int	mnoarg(type_t *, int *);


void
inittyp(void)
{
	int	i;
	static	struct {
		tspec_t	it_tspec;
		ttab_t	it_ttab;
	} ittab[] = {
		{ SIGNED,   { 0, 0, 0,
				      SIGNED, UNSIGN,
				      0, 0, 0, 0, 0, "signed" } },
		{ UNSIGN,   { 0, 0, 0,
				      SIGNED, UNSIGN,
				      0, 0, 0, 0, 0, "unsigned" } },
		{ BOOL,     { sizeof (_Bool) * CHAR_BIT, CHAR_BIT, 1,
				      BOOL, BOOL,
				      1, 1, 0, 1, 1, "_Bool" } },
		{ CHAR,	    { CHAR_BIT, CHAR_BIT, 20,
				      SCHAR, UCHAR,
				      1, 0, 0, 1, 1, "char" } },
		{ SCHAR,    { CHAR_BIT, CHAR_BIT, 20,
				      SCHAR, UCHAR,
				      1, 0, 0, 1, 1, "signed char" } },
		{ UCHAR,    { CHAR_BIT, CHAR_BIT, 20,
				      SCHAR, UCHAR,
				      1, 1, 0, 1, 1, "unsigned char" } },
		{ SHORT,    { sizeof (short) * CHAR_BIT, 2 * CHAR_BIT, 30,
				      SHORT, USHORT,
				      1, 0, 0, 1, 1, "short" } },
		{ USHORT,   { sizeof (u_short) * CHAR_BIT, 2 * CHAR_BIT, 30,
				      SHORT, USHORT,
				      1, 1, 0, 1, 1, "unsigned short" } },
		{ INT,      { sizeof (int) * CHAR_BIT, 3 * CHAR_BIT, 40,
				      INT, UINT,
				      1, 0, 0, 1, 1, "int" } },
		{ UINT,     { sizeof (u_int) * CHAR_BIT, 3 * CHAR_BIT, 40,
				      INT, UINT,
				      1, 1, 0, 1, 1, "unsigned int" } },
		{ LONG,     { sizeof (long) * CHAR_BIT, 4 * CHAR_BIT, 50,
				      LONG, ULONG,
				      1, 0, 0, 1, 1, "long" } },
		{ ULONG,    { sizeof (u_long) * CHAR_BIT, 4 * CHAR_BIT, 50,
				      LONG, ULONG,
				      1, 1, 0, 1, 1, "unsigned long" } },
		{ QUAD,     { sizeof (quad_t) * CHAR_BIT, 8 * CHAR_BIT, 60,
				      QUAD, UQUAD,
				      1, 0, 0, 1, 1, "long long" } },
		{ UQUAD,    { sizeof (u_quad_t) * CHAR_BIT, 8 * CHAR_BIT, 60,
				      QUAD, UQUAD,
				      1, 1, 0, 1, 1, "unsigned long long" } },
		{ FLOAT,    { sizeof (float) * CHAR_BIT, 4 * CHAR_BIT, -1,
				      FLOAT, FLOAT,
				      0, 0, 1, 1, 1, "float" } },
		{ DOUBLE,   { sizeof (double) * CHAR_BIT, 8 * CHAR_BIT, -1,
				      DOUBLE, DOUBLE,
				      0, 0, 1, 1, 1, "double" } },
		{ LDOUBLE,  { sizeof (ldbl_t) * CHAR_BIT, 16 * CHAR_BIT, -1,
				      LDOUBLE, LDOUBLE,
				      0, 0, 1, 1, 1, "long double" } },
		{ COMPLEX,  { sizeof (float _Complex) * CHAR_BIT,
				      8 * CHAR_BIT, -1,
				      COMPLEX, COMPLEX,
				      0, 0, 1, 1, 3, "float _Complex" } },
		{ DCOMPLEX, { sizeof (double _Complex) * CHAR_BIT,
				      16 * CHAR_BIT, -1,
				      DCOMPLEX, DCOMPLEX,
				      0, 0, 1, 1, 3, "double _Complex" } },
		{ LDCOMPLEX,{ sizeof (long double _Complex) * CHAR_BIT,
				      32 * CHAR_BIT, -1,
				      LDCOMPLEX, LDCOMPLEX,
				      0, 0, 1, 1, 3, "long double _Complex" } },
		{ VOID,     { -1, -1, -1,
				      VOID, VOID,
				      0, 0, 0, 0, 0, "void" } },
		{ STRUCT,   { -1, -1, -1,
				      STRUCT, STRUCT,
				      0, 0, 0, 0, 0, "struct" } },
		{ UNION,    { -1, -1, -1,
				      UNION, UNION,
				      0, 0, 0, 0, 0, "union" } },
		{ ENUM,     { sizeof (int) * CHAR_BIT, 3 * CHAR_BIT, 40,
				      ENUM, ENUM,
				      1, 0, 0, 1, 1, "enum" } },
		{ PTR,      { sizeof (void *) * CHAR_BIT, 4 * CHAR_BIT, -1,
				      PTR, PTR,
				      0, 1, 0, 0, 1, "pointer" } },
		{ ARRAY,    { -1, -1, -1,
				      ARRAY, ARRAY,
				      0, 0, 0, 0, 0, "array" } },
		{ FUNC,     { -1, -1, -1,
				      FUNC, FUNC,
				      0, 0, 0, 0, 0, "function" } },
	};

	for (i = 0; i < sizeof (ittab) / sizeof (ittab[0]); i++)
		STRUCT_ASSIGN(ttab[ittab[i].it_tspec], ittab[i].it_ttab);
	if (!pflag) {
		for (i = 0; i < NTSPEC; i++)
			ttab[i].tt_psz = ttab[i].tt_sz;
	}
}


/*
 * If there is a symbol named "main", mark it as used.
 */
void
mainused(void)
{
	hte_t	*hte;

	if ((hte = hsearch("main", 0)) != NULL)
		hte->h_used = 1;
}

/*
 * Performs all tests for a single name
 */
void
chkname(hte_t *hte)
{
	sym_t	*sym, *def, *pdecl, *decl;

	if (uflag) {
		chkund(hte);
		chkdnu(hte);
		if (xflag)
			chkdnud(hte);
	}
	chkmd(hte);

	/* Get definition, prototype declaration and declaration */
	def = pdecl = decl = NULL;
	for (sym = hte->h_syms; sym != NULL; sym = sym->s_nxt) {
		if (def == NULL && (sym->s_def == DEF || sym->s_def == TDEF))
			def = sym;
		if (pdecl == NULL && sym->s_def == DECL &&
		    TP(sym->s_type)->t_tspec == FUNC &&
		    TP(sym->s_type)->t_proto) {
			pdecl = sym;
		}
		if (decl == NULL && sym->s_def == DECL)
			decl = sym;
	}

	/* A prototype is better than an old style declaration. */
	if (pdecl != NULL)
		decl = pdecl;

	chkvtui(hte, def, decl);

	chkvtdi(hte, def, decl);

	chkfaui(hte, def, decl);

	chkrvu(hte, def);

	chkadecl(hte, def, decl);
}

/*
 * Print a warning if the name has been used, but not defined.
 */
static void
chkund(hte_t *hte)
{
	fcall_t	*fcall;
	usym_t	*usym;

	if (!hte->h_used || hte->h_def)
		return;

	if ((fcall = hte->h_calls) != NULL) {
		/* %s: %s used, but not defined */
		msg(0, mkpos(&fcall->f_pos), hte->h_name);
	} else if ((usym = hte->h_usyms) != NULL) {
		/* %s: %s used, but not defined */
		msg(0, mkpos(&usym->u_pos), hte->h_name);
	}
}

/*
 * Print a warning if the name has been defined, but never used.
 */
static void
chkdnu(hte_t *hte)
{
	sym_t	*sym;

	if (!hte->h_def || hte->h_used)
		return;

	for (sym = hte->h_syms; sym != NULL; sym = sym->s_nxt) {
		if (sym->s_def == DEF || sym->s_def == TDEF) {
			/* %s: %s defined, but never used */
			msg(1, mkpos(&sym->s_pos), hte->h_name);
			break;
		}
	}
}

/*
 * Print a warning if the name has been declared, but is not used
 * or defined.
 */
static void
chkdnud(hte_t *hte)
{
	sym_t	*sym;

	if (hte->h_syms == NULL || hte->h_used || hte->h_def)
		return;

	if ((sym = hte->h_syms) != NULL) {
		if (sym->s_def != DECL)
			errx(1, "internal error: chkdnud() 1");

		/* don't warn if the name was declared in a separate header */
		if (sym->s_pos.p_src != sym->s_pos.p_isrc) {
			return;
		}

		/* %s: %s declared, but never used or defined */
		msg(2, mkpos(&sym->s_pos), hte->h_name);
	}
}

/*
 * Print a warning if there is more than one definition for
 * this name.
 */
static void
chkmd(hte_t *hte)
{
	sym_t	*sym, *def1;
	char	*pos1;

	if (!hte->h_def)
		return;

	def1 = NULL;
	for (sym = hte->h_syms; sym != NULL; sym = sym->s_nxt) {
		/*
		 * ANSI C allows tentative definitions of the same name in
		 * only one compilation unit.
		 */
		if (sym->s_def != DEF && (!sflag || sym->s_def != TDEF))
			continue;
		if (def1 == NULL) {
			def1 = sym;
			continue;
		}
		pos1 = xstrdup(mkpos(&def1->s_pos));
		/* %s: %s multiply defined (%s) */
		msg(3, pos1, hte->h_name, mkpos(&sym->s_pos));
		free(pos1);
	}
}

/*
 * Print a warning if the return value assumed for a function call
 * differs from the return value of the function definition or
 * function declaration.
 *
 * If no definition/declaration can be found, the assumed return values
 * are always int. So there is no need to compare with another function
 * call as it's done for function arguments.
 */
static void
chkvtui(hte_t *hte, sym_t *def, sym_t *decl)
{
	fcall_t	*call;
	char	*pos1;
	type_t	*tp1, *tp2;
	/* LINTED (automatic hides external declaration: warn) */
	int	warn, eq;
	tspec_t	t1;

	if (hte->h_calls == NULL)
		return;

	if (def == NULL)
		def = decl;
	if (def == NULL)
		return;

	t1 = (tp1 = TP(def->s_type)->t_subt)->t_tspec;
	for (call = hte->h_calls; call != NULL; call = call->f_nxt) {
		tp2 = TP(call->f_type)->t_subt;
		eq = eqtype(tp1, tp2, 1, 0, 0, (warn = 0, &warn));
		if (!call->f_rused) {
			/* no return value used */
			if ((t1 == STRUCT || t1 == UNION) && !eq) {
				/*
				 * If a function returns a struct or union it
				 * must be declared to return a struct or
				 * union, also if the return value is ignored.
				 * This is necessary because the caller must
				 * allocate stack space for the return value.
				 * If it does not, the return value would over-
				 * write other data.
				 * XXX Following massage may be confusing
				 * because it appears also if the return value
				 * was declared inconsistently. But this
				 * behaviour matches pcc based lint, so it is
				 * accepted for now.
				 */
				pos1 = xstrdup(mkpos(&def->s_pos));
				/* %s: %s must be decl. before use (%s) */
				msg(17, pos1, hte->h_name,
				    mkpos(&call->f_pos));
				free(pos1);
			}
			continue;
		}
		if (!eq || (sflag && warn)) {
			pos1 = xstrdup(mkpos(&def->s_pos));
			/* %s: %s used inconsistently (%s) */
			msg(4, pos1, hte->h_name, mkpos(&call->f_pos));
			free(pos1);
		}
	}
}

/*
 * Print a warning if a definition/declaration does not match another
 * definition/declaration of the same name. For functions, only the
 * types of return values are tested.
 */
static void
chkvtdi(hte_t *hte, sym_t *def, sym_t *decl)
{
	sym_t	*sym;
	type_t	*tp1, *tp2;
	/* LINTED (automatic hides external declaration: warn) */
	int	eq, warn;
	char	*pos1;

	if (def == NULL)
		def = decl;
	if (def == NULL)
		return;

	tp1 = TP(def->s_type);
	for (sym = hte->h_syms; sym != NULL; sym = sym->s_nxt) {
		if (sym == def)
			continue;
		tp2 = TP(sym->s_type);
		warn = 0;
		if (tp1->t_tspec == FUNC && tp2->t_tspec == FUNC) {
			eq = eqtype(tp1->t_subt, tp2->t_subt, 1, 0, 0, &warn);
		} else {
			eq = eqtype(tp1, tp2, 0, 0, 0, &warn);
		}
		if (!eq || (sflag && warn)) {
			pos1 = xstrdup(mkpos(&def->s_pos));
			/* %s: %s declared inconsistently (%s) */
			msg(5, pos1, hte->h_name, mkpos(&sym->s_pos));
			free(pos1);
		}
	}
}

/*
 * Print a warning if a function is called with arguments which does
 * not match the function definition, declaration or another call
 * of the same function.
 */
static void
chkfaui(hte_t *hte, sym_t *def, sym_t *decl)
{
	type_t	*tp1, *tp2, **ap1, **ap2;
	pos_t	*pos1p;
	fcall_t	*calls, *call, *call1;
	int	n, as;
	char	*pos1;
	arginf_t *ai;

	if ((calls = hte->h_calls) == NULL)
		return;

	/*
	 * If we find a function definition, we use this for comparison,
	 * otherwise the first prototype we can find. If there is no
	 * definition or prototype declaration, the first function call
	 * is used.
	 */
	tp1 = NULL;
	call1 = NULL;
	if (def != NULL) {
		if ((tp1 = TP(def->s_type))->t_tspec != FUNC)
			return;
		pos1p = &def->s_pos;
	} else if (decl != NULL && TP(decl->s_type)->t_proto) {
		if ((tp1 = TP(decl->s_type))->t_tspec != FUNC)
			return;
		pos1p = &decl->s_pos;
	}
	if (tp1 == NULL) {
		call1 = calls;
		calls = calls->f_nxt;
		if ((tp1 = TP(call1->f_type))->t_tspec != FUNC)
			return;
		pos1p = &call1->f_pos;
	}

	n = 1;
	for (call = calls; call != NULL; call = call->f_nxt) {
		if ((tp2 = TP(call->f_type))->t_tspec != FUNC)
			continue;
		ap1 = tp1->t_args;
		ap2 = tp2->t_args;
		n = 0;
		while (*ap1 != NULL && *ap2 != NULL) {
			if (def != NULL && def->s_va && n >= def->s_nva)
				break;
			n++;
			chkau(hte, n, def, decl, pos1p, call1, call,
			      *ap1, *ap2);
			ap1++;
			ap2++;
		}
		if (*ap1 == *ap2) {
			/* equal # of arguments */
		} else if (def != NULL && def->s_va && n >= def->s_nva) {
			/*
			 * function definition with VARARGS; The # of
			 * arguments of the call must be at least as large
			 * as the parameter of VARARGS.
			 */
		} else if (*ap2 != NULL && tp1->t_proto && tp1->t_vararg) {
			/*
			 * prototype with ... and function call with
			 * at least the same # of arguments as declared
			 * in the prototype.
			 */
		} else {
			pos1 = xstrdup(mkpos(pos1p));
			/* %s: %s called with varying # of args (%s) */
			msg(7, pos1, hte->h_name, mkpos(&call->f_pos));
			free(pos1);
			continue;
		}

		/* perform SCANFLIKE/PRINTFLIKE tests */
		if (def == NULL || (!def->s_prfl && !def->s_scfl))
			continue;
		as = def->s_prfl ? def->s_nprfl : def->s_nscfl;
		for (ai = call->f_args; ai != NULL; ai = ai->a_nxt) {
			if (ai->a_num == as)
				break;
		}
		if (ai == NULL || !ai->a_fmt)
			continue;
		if (def->s_prfl) {
			printflike(hte, call, n, ai->a_fstrg, ap2);
		} else {
			scanflike(hte, call, n, ai->a_fstrg, ap2);
		}
	}
}

/*
 * Check a single argument in a function call.
 *
 *  hte		a pointer to the hash table entry of the function
 *  n		the number of the argument (1..)
 *  def		the function definition or NULL
 *  decl	prototype declaration, old style declaration or NULL
 *  pos1p	position of definition, declaration of first call
 *  call1	first call, if both def and decl are old style def/decl
 *  call	checked call
 *  arg1	currently checked argument of def/decl/call1
 *  arg2	currently checked argument of call
 *
 */
static void
chkau(hte_t *hte, int n, sym_t *def, sym_t *decl, pos_t *pos1p,
    fcall_t *call1, fcall_t *call, type_t *arg1, type_t *arg2)
{
	/* LINTED (automatic hides external declaration: warn) */
	int	promote, asgn, warn;
	tspec_t	t1, t2;
	arginf_t *ai, *ai1;
	char	*pos1;

	/*
	 * If a function definition is available (def != NULL), we compair the
	 * function call (call) with the definition. Otherwise, if a function
	 * definition is available and it is not an old style definition
	 * (decl != NULL && TP(decl->s_type)->t_proto), we compair the call
	 * with this declaration. Otherwise we compair it with the first
	 * call we have found (call1).
	 */

	/* arg1 must be promoted if it stems from an old style definition */
	promote = def != NULL && def->s_osdef;

	/*
	 * If we compair with a definition or declaration, we must perform
	 * the same checks for qualifiers in indirected types as in
	 * assignments.
	 */
	asgn = def != NULL || (decl != NULL && TP(decl->s_type)->t_proto);

	warn = 0;
	if (eqtype(arg1, arg2, 1, promote, asgn, &warn) && (!sflag || !warn))
		return;

	/*
	 * Other lint implementations print warnings as soon as the type
	 * of an argument does not match exactly the expected type. The
	 * result are lots of warnings which are really not necessary.
	 * We print a warning only if
	 *   (0) at least one type is not an interger type and types differ
	 *   (1) hflag is set and types differ
	 *   (2) types differ, except in signedness
	 * If the argument is an integer constant whose msb is not set,
	 * signedness is ignored (e.g. 0 matches both signed and unsigned
	 * int). This is with and without hflag.
	 * If the argument is an integer constant with value 0 and the
	 * expected argument is of type pointer and the width of the
	 * interger constant is the same as the width of the pointer,
	 * no warning is printed.
	 */
	t1 = arg1->t_tspec;
	t2 = arg2->t_tspec;
	if (isityp(t1) && isityp(t2) && !arg1->t_isenum && !arg2->t_isenum) {
		if (promote) {
			/*
			 * XXX Here is a problem: Althrough it is possible to
			 * pass an int where a char/short it expected, there
			 * may be loss in significant digits. We should first
			 * check for const arguments if they can be converted
			 * into the original parameter type.
			 */
			if (t1 == FLOAT) {
				t1 = DOUBLE;
			} else if (t1 == CHAR || t1 == SCHAR) {
				t1 = INT;
			} else if (t1 == UCHAR) {
				t1 = INT;
			} else if (t1 == SHORT) {
				t1 = INT;
			} else if (t1 == USHORT) {
				/* CONSTCOND */
				t1 = INT_MAX < USHRT_MAX ? UINT : INT;
			}
		}

		if (styp(t1) == styp(t2)) {

			/*
			 * types differ only in signedness; get information
			 * about arguments
			 */

			/*
			 * treat a definition like a call with variable
			 * arguments
			 */
			ai1 = call1 != NULL ? call1->f_args : NULL;

			/*
			 * if two calls are compared, ai1 is set to the
			 * information for the n-th argument, if this was
			 * a constant, otherwise to NULL
			 */
			for ( ; ai1 != NULL; ai1 = ai1->a_nxt) {
				if (ai1->a_num == n)
					break;
			}
			/*
			 * ai is set to the information of the n-th arg
			 * of the (second) call, if this was a constant,
			 * otherwise to NULL
			 */
			for (ai = call->f_args; ai != NULL; ai = ai->a_nxt) {
				if (ai->a_num == n)
					break;
			}

			if (ai1 == NULL && ai == NULL) {
				/* no constant at all */
				if (!hflag)
					return;
			} else if (ai1 == NULL || ai == NULL) {
				/* one constant */
				if (ai == NULL)
					ai = ai1;
				if (ai->a_zero || ai->a_pcon)
					/* same value in signed and unsigned */
					return;
				/* value (not representation) differently */
			} else {
				/*
				 * two constants, one signed, one unsigned;
				 * if the msb of one of the constants is set,
				 * the argument is used inconsistently.
				 */
				if (!ai1->a_ncon && !ai->a_ncon)
					return;
			}
		}

	} else if (t1 == PTR && isityp(t2) && psize(t1) == psize(t2)) {
		for (ai = call->f_args; ai != NULL; ai = ai->a_nxt) {
			if (ai->a_num == n)
				break;
		}
		if (ai != NULL && ai->a_zero)
			return;
	}

	pos1 = xstrdup(mkpos(pos1p));
	/* %s: %s arg %d used inconsistently (%s) */
	msg(6, pos1, hte->h_name, n, mkpos(&call->f_pos));
	free(pos1);
}

/*
 * Compare the types in the NULL-terminated array ap with the format
 * string fmt.
 */
static void
printflike(hte_t *hte, fcall_t *call, int n, const char *fmt, type_t **ap)
{
	const	char *fp;
	int	fc;
	int	fwidth, prec, left, sign, space, alt, zero;
	tspec_t	sz, t1, t2 = NOTSPEC;
	type_t	*tp;

	fp = fmt;
	fc = *fp++;

	for ( ; ; ) {
		if (fc == '\0') {
			if (*ap != NULL)
				tomanyarg(hte, call);
			break;
		}
		if (fc != '%') {
			badfmt(hte, call);
			break;
		}
		fc = *fp++;
		fwidth = prec = left = sign = space = alt = zero = 0;
		sz = NOTSPEC;

		/* Flags */
		for ( ; ; ) {
			if (fc == '-') {
				if (left)
					break;
				left = 1;
			} else if (fc == '+') {
				if (sign)
					break;
				sign = 1;
			} else if (fc == ' ') {
				if (space)
					break;
				space = 1;
			} else if (fc == '#') {
				if (alt)
					break;
				alt = 1;
			} else if (fc == '0') {
				if (zero)
					break;
				zero = 1;
			} else {
				break;
			}
			fc = *fp++;
		}

		/* field width */
		if (isdigit(fc)) {
			fwidth = 1;
			do { fc = *fp++; } while (isdigit(fc)) ;
		} else if (fc == '*') {
			fwidth = 1;
			fc = *fp++;
			if ((tp = *ap++) == NULL) {
				tofewarg(hte, call);
				break;
			}
			n++;
			if ((t1 = tp->t_tspec) != INT && (hflag || t1 != UINT))
				inconarg(hte, call, n);
		}

		/* precision */
		if (fc == '.') {
			fc = *fp++;
			prec = 1;
			if (isdigit(fc)) {
				do { fc = *fp++; } while (isdigit(fc));
			} else if (fc == '*') {
				fc = *fp++;
				if ((tp = *ap++) == NULL) {
					tofewarg(hte, call);
					break;
				}
				n++;
				if (tp->t_tspec != INT)
					inconarg(hte, call, n);
			} else {
				badfmt(hte, call);
				break;
			}
		}

		if (fc == 'h') {
			sz = SHORT;
		} else if (fc == 'l') {
			sz = LONG;
		} else if (fc == 'q') {
			sz = QUAD;
		} else if (fc == 'L') {
			sz = LDOUBLE;
		}
		if (sz != NOTSPEC)
			fc = *fp++;

		if (fc == '%' || fc == 'm') {
			if (sz != NOTSPEC || left || sign || space ||
			    alt || zero || prec || fwidth) {
				badfmt(hte, call);
			}
			fc = *fp++;
			continue;
		}

		if (fc == '\0') {
			badfmt(hte, call);
			break;
		}

		if ((tp = *ap++) == NULL) {
			tofewarg(hte, call);
			break;
		}
		n++;
		if ((t1 = tp->t_tspec) == PTR)
			t2 = tp->t_subt->t_tspec;

		if (fc == 'd' || fc == 'i') {
			if (alt || sz == LDOUBLE) {
				badfmt(hte, call);
				break;
			}
		int_conv:
			if (sz == LONG) {
				if (t1 != LONG && (hflag || t1 != ULONG))
					inconarg(hte, call, n);
			} else if (sz == QUAD) {
				if (t1 != QUAD && (hflag || t1 != UQUAD))
					inconarg(hte, call, n);
			} else {
				/*
				 * SHORT is always promoted to INT, USHORT
				 * to INT or UINT.
				 */
				if (t1 != INT && (hflag || t1 != UINT))
					inconarg(hte, call, n);
			}
		} else if (fc == 'o' || fc == 'u' || fc == 'x' || fc == 'X') {
			if ((alt && fc == 'u') || sz == LDOUBLE)
				badfmt(hte, call);
		uint_conv:
			if (sz == LONG) {
				if (t1 != ULONG && (hflag || t1 != LONG))
					inconarg(hte, call, n);
			} else if (sz == QUAD) {
				if (t1 != UQUAD && (hflag || t1 != QUAD))
					inconarg(hte, call, n);
			} else if (sz == SHORT) {
				/* USHORT was promoted to INT or UINT */
				if (t1 != UINT && t1 != INT)
					inconarg(hte, call, n);
			} else {
				if (t1 != UINT && (hflag || t1 != INT))
					inconarg(hte, call, n);
			}
		} else if (fc == 'D' || fc == 'O' || fc == 'U') {
			/* DOU are deprecated */
			badfmt(hte, call);
			sz = LONG;
			if (fc == 'D') {
				goto int_conv;
			} else {
				goto uint_conv;
			}
		} else if (fc == 'e' || fc == 'E' ||
			   fc == 'f' || fc == 'F' ||
			   fc == 'g' || fc == 'G' ||
			   fc == 'a' || fc == 'A') {
			if (sz == NOTSPEC)
				sz = DOUBLE;
			if (sz != DOUBLE && sz != LDOUBLE)
				badfmt(hte, call);
			if (t1 != sz)
				inconarg(hte, call, n);
		} else if (fc == 'c') {
			if (sz != NOTSPEC || alt || zero)
				badfmt(hte, call);
			if (t1 != INT)
				inconarg(hte, call, n);
		} else if (fc == 's') {
			if (sz != NOTSPEC || alt || zero)
				badfmt(hte, call);
			if (t1 != PTR ||
			    (t2 != CHAR && t2 != UCHAR && t2 != SCHAR)) {
				inconarg(hte, call, n);
			}
		} else if (fc == 'p') {
			if (fwidth || prec || sz != NOTSPEC || alt || zero)
				badfmt(hte, call);
			if (t1 != PTR || (hflag && t2 != VOID))
				inconarg(hte, call, n);
		} else if (fc == 'n') {
			if (fwidth || prec || alt || zero || sz == LDOUBLE)
				badfmt(hte, call);
			if (t1 != PTR) {
				inconarg(hte, call, n);
			} else if (sz == LONG) {
				if (t2 != LONG && t2 != ULONG)
					inconarg(hte, call, n);
			} else if (sz == SHORT) {
				if (t2 != SHORT && t2 != USHORT)
					inconarg(hte, call, n);
			} else {
				if (t2 != INT && t2 != UINT)
					inconarg(hte, call, n);
			}
		} else {
			badfmt(hte, call);
			break;
		}

		fc = *fp++;
	}
}

/*
 * Compare the types in the NULL-terminated array ap with the format
 * string fmt.
 */
static void
scanflike(hte_t *hte, fcall_t *call, int n, const char *fmt, type_t **ap)
{
	const	char *fp;
	int	fc;
	int	noasgn, fwidth;
	tspec_t	sz, t1 = NOTSPEC, t2 = NOTSPEC;
	type_t	*tp;

	fp = fmt;
	fc = *fp++;

	for ( ; ; ) {
		if (fc == '\0') {
			if (*ap != NULL)
				tomanyarg(hte, call);
			break;
		}
		if (fc != '%') {
			badfmt(hte, call);
			break;
		}
		fc = *fp++;

		noasgn = fwidth = 0;
		sz = NOTSPEC;

		if (fc == '*') {
			noasgn = 1;
			fc = *fp++;
		}

		if (isdigit(fc)) {
			fwidth = 1;
			do { fc = *fp++; } while (isdigit(fc));
		}

		if (fc == 'h') {
			sz = SHORT;
		} else if (fc == 'l') {
			sz = LONG;
		} else if (fc == 'q') {
			sz = QUAD;
		} else if (fc == 'L') {
			sz = LDOUBLE;
		}
		if (sz != NOTSPEC)
			fc = *fp++;

		if (fc == '%') {
			if (sz != NOTSPEC || noasgn || fwidth)
				badfmt(hte, call);
			fc = *fp++;
			continue;
		}

		if (!noasgn) {
			if ((tp = *ap++) == NULL) {
				tofewarg(hte, call);
				break;
			}
			n++;
			if ((t1 = tp->t_tspec) == PTR)
				t2 = tp->t_subt->t_tspec;
		}

		if (fc == 'd' || fc == 'i' || fc == 'n') {
			if (sz == LDOUBLE)
				badfmt(hte, call);
			if (sz != SHORT && sz != LONG && sz != QUAD)
				sz = INT;
		conv:
			if (!noasgn) {
				if (t1 != PTR) {
					inconarg(hte, call, n);
				} else if (t2 != styp(sz)) {
					inconarg(hte, call, n);
				} else if (hflag && t2 != sz) {
					inconarg(hte, call, n);
				} else if (tp->t_subt->t_const) {
					inconarg(hte, call, n);
				}
			}
		} else if (fc == 'o' || fc == 'u' || fc == 'x') {
			if (sz == LDOUBLE)
				badfmt(hte, call);
			if (sz == SHORT) {
				sz = USHORT;
			} else if (sz == LONG) {
				sz = ULONG;
			} else if (sz == QUAD) {
				sz = UQUAD;
			} else {
				sz = UINT;
			}
			goto conv;
		} else if (fc == 'D') {
			badfmt(hte, call);
			sz = LONG;
			goto conv;
		} else if (fc == 'O') {
			badfmt(hte, call);
			sz = ULONG;
			goto conv;
		} else if (fc == 'X') {
			/*
			 * XXX valid in ANSI C, but in NetBSD's libc imple-
			 * mented as "lx". Thats why it should be avoided.
			 */
			badfmt(hte, call);
			sz = ULONG;
			goto conv;
		} else if (fc == 'e' || fc == 'E' ||
			   fc == 'f' || fc == 'F' ||
			   fc == 'g' || fc == 'G' ||
			   fc == 'a' || fc == 'A') {
			if (sz == NOTSPEC) {
				sz = FLOAT;
			} else if (sz == LONG) {
				sz = DOUBLE;
			} else if (sz != LDOUBLE) {
				badfmt(hte, call);
				sz = FLOAT;
			}
			goto conv;
		} else if (fc == 's' || fc == '[' || fc == 'c') {
			if (sz != NOTSPEC)
				badfmt(hte, call);
			if (fc == '[') {
				if ((fc = *fp++) == '-') {
					badfmt(hte, call);
					fc = *fp++;
				}
				if (fc != ']') {
					badfmt(hte, call);
					if (fc == '\0')
						break;
				}
			}
			if (!noasgn) {
				if (t1 != PTR) {
					inconarg(hte, call, n);
				} else if (t2 != CHAR && t2 != UCHAR &&
					   t2 != SCHAR) {
					inconarg(hte, call, n);
				}
			}
		} else if (fc == 'p') {
			if (sz != NOTSPEC)
				badfmt(hte, call);
			if (!noasgn) {
				if (t1 != PTR || t2 != PTR) {
					inconarg(hte, call, n);
				} else if (tp->t_subt->t_subt->t_tspec!=VOID) {
					if (hflag)
						inconarg(hte, call, n);
				}
			}
		} else {
			badfmt(hte, call);
			break;
		}

		fc = *fp++;
	}
}

static void
badfmt(hte_t *hte, fcall_t *call)
{
	/* %s: malformed format string argument to %s */
	msg(13, mkpos(&call->f_pos), hte->h_name);
}

static void
inconarg(hte_t *hte, fcall_t *call, int n)
{
	/* %s: arg %d to %s is inconsistent with format */
	msg(14, mkpos(&call->f_pos), n, hte->h_name);
}

static void
tofewarg(hte_t *hte, fcall_t *call)
{
	/* %s: too few format args to %s */
	msg(15, mkpos(&call->f_pos), hte->h_name);
}

static void
tomanyarg(hte_t *hte, fcall_t *call)
{
	/* %s: too many format args to %s */
	msg(16, mkpos(&call->f_pos), hte->h_name);
}


/*
 * Print warnings for return values which are used, but not returned,
 * or return values which are always or sometimes ignored.
 */
static void
chkrvu(hte_t *hte, sym_t *def)
{
	fcall_t	*call;
	int	used, ignored;

	if (def == NULL)
		/* don't know wheter or not the functions returns a value */
		return;

	if (hte->h_calls == NULL)
		return;

	if (def->s_rval) {
		/* function has return value */
		used = ignored = 0;
		for (call = hte->h_calls; call != NULL; call = call->f_nxt) {
			used |= call->f_rused || call->f_rdisc;
			ignored |= !call->f_rused && !call->f_rdisc;
		}
		/*
		 * XXX as soon as we are able to disable single warnings
		 * the following dependencies from hflag should be removed.
		 * but for now I do'nt want to be botherd by this warnings
		 * which are almost always useless.
		 */
		if (!used && ignored) {
			if (hflag)
				/* %s returns value which is always ignored */
				msg(8, hte->h_name);
		} else if (used && ignored) {
			if (hflag)
				/* %s returns value which is sometimes ign. */
				msg(9, hte->h_name);
		}
	} else {
		/* function has no return value */
		for (call = hte->h_calls; call != NULL; call = call->f_nxt) {
			if (call->f_rused)
				/* %s: return value of %s is used, but none ret. */
				msg(10, mkpos(&call->f_pos), hte->h_name);
		}
	}
}

/*
 * Print warnings for inconsistent argument declarations.
 */
static void
chkadecl(hte_t *hte, sym_t *def, sym_t *decl)
{
	/* LINTED (automatic hides external declaration: warn) */
	int	osdef, eq, warn, n;
	sym_t	*sym1, *sym;
	type_t	**ap1, **ap2, *tp1, *tp2;
	char	*pos1;
	const	char *pos2;

	osdef = 0;
	if (def != NULL) {
		osdef = def->s_osdef;
		sym1 = def;
	} else if (decl != NULL && TP(decl->s_type)->t_proto) {
		sym1 = decl;
	} else {
		return;
	}
	if (TP(sym1->s_type)->t_tspec != FUNC)
		return;

	/*
	 * XXX Prototypes should also be compared with old style function
	 * declarations.
	 */

	for (sym = hte->h_syms; sym != NULL; sym = sym->s_nxt) {
		if (sym == sym1 || !TP(sym->s_type)->t_proto)
			continue;
		ap1 = TP(sym1->s_type)->t_args;
		ap2 = TP(sym->s_type)->t_args;
		n = 0;
		while (*ap1 != NULL && *ap2 != NULL) {
			warn = 0;
			eq = eqtype(*ap1, *ap2, 1, osdef, 0, &warn);
			if (!eq || warn) {
				pos1 = xstrdup(mkpos(&sym1->s_pos));
				pos2 = mkpos(&sym->s_pos);
				/* %s: %s arg %d declared inconsistently ... */
				msg(11, pos1, hte->h_name, n + 1, pos2);
				free(pos1);
			}
			n++;
			ap1++;
			ap2++;
		}
		if (*ap1 == *ap2) {
			tp1 = TP(sym1->s_type);
			tp2 = TP(sym->s_type);
			if (tp1->t_vararg == tp2->t_vararg)
				continue;
			if (tp2->t_vararg &&
			    sym1->s_va && sym1->s_nva == n && !sflag) {
				continue;
			}
		}
		/* %s: %s declared with varying # of args (%s) */
		pos1 = xstrdup(mkpos(&sym1->s_pos));
		msg(12, pos1, hte->h_name, mkpos(&sym->s_pos));
		free(pos1);
	}
}


/*
 * Check compatibility of two types. Returns 1 if types are compatible,
 * otherwise 0.
 *
 * ignqual	if set, ignore qualifiers of outhermost type; used for
 *		function arguments
 * promote	if set, promote left type before comparison; used for
 *		comparisons of arguments with parameters of old style
 *		definitions
 * asgn		left indirected type must have at least the same qualifiers
 *		like right indirected type (for assignments and function
 *		arguments)
 * *warn	set to 1 if an old style declaration was compared with
 *		an incompatible prototype declaration
 */
static int
eqtype(type_t *tp1, type_t *tp2, int ignqual, int promot, int asgn, int *warn)
{
	tspec_t	t, to;
	int	indir;

	to = NOTSPEC;
	indir = 0;

	while (tp1 != NULL && tp2 != NULL) {

		t = tp1->t_tspec;
		if (promot) {
			if (t == FLOAT) {
				t = DOUBLE;
			} else if (t == CHAR || t == SCHAR) {
				t = INT;
			} else if (t == UCHAR) {
				t = INT;
			} else if (t == SHORT) {
				t = INT;
			} else if (t == USHORT) {
				/* CONSTCOND */
				t = INT_MAX < USHRT_MAX ? UINT : INT;
			}
		}

		if (asgn && to == PTR) {
			if (indir == 1 && (t == VOID || tp2->t_tspec == VOID))
				return (1);
		}

		if (t != tp2->t_tspec) {
			/*
			 * Give pointer to types which differ only in
			 * signedness a chance if not sflag and not hflag.
			 */
			if (sflag || hflag || to != PTR)
				return (0);
			if (styp(t) != styp(tp2->t_tspec))
				return (0);
		}

		if (tp1->t_isenum && tp2->t_isenum) {
			if (tp1->t_istag && tp2->t_istag) {
				return (tp1->t_tag == tp2->t_tag);
			} else if (tp1->t_istynam && tp2->t_istynam) {
				return (tp1->t_tynam == tp2->t_tynam);
			} else {
				return (0);
			}
		}

		/*
		 * XXX Handle combinations of enum and int if eflag is set.
		 * But note: enum and 0 should be allowed.
		 */

		if (asgn && indir == 1) {
			if (!tp1->t_const && tp2->t_const)
				return (0);
			if (!tp1->t_volatile && tp2->t_volatile)
				return (0);
		} else if (!ignqual) {
			if (tp1->t_const != tp2->t_const)
				return (0);
			if (tp1->t_const != tp2->t_const)
				return (0);
		}

		if (t == STRUCT || t == UNION) {
			if (tp1->t_istag && tp2->t_istag) {
				return (tp1->t_tag == tp2->t_tag);
			} else if (tp1->t_istynam && tp2->t_istynam) {
				return (tp1->t_tynam == tp2->t_tynam);
			} else {
				return (0);
			}
		}

		if (t == ARRAY && tp1->t_dim != tp2->t_dim) {
			if (tp1->t_dim != 0 && tp2->t_dim != 0)
				return (0);
		}

		if (t == FUNC) {
			if (tp1->t_proto && tp2->t_proto) {
				if (!eqargs(tp1, tp2, warn))
					return (0);
			} else if (tp1->t_proto) {
				if (!mnoarg(tp1, warn))
					return (0);
			} else if (tp2->t_proto) {
				if (!mnoarg(tp2, warn))
					return (0);
			}
		}

		tp1 = tp1->t_subt;
		tp2 = tp2->t_subt;
		ignqual = promot = 0;
		to = t;
		indir++;

	}

	return (tp1 == tp2);
}

/*
 * Compares arguments of two prototypes
 */
static int
eqargs(type_t *tp1, type_t *tp2, int *warn)
{
	type_t	**a1, **a2;

	if (tp1->t_vararg != tp2->t_vararg)
		return (0);

	a1 = tp1->t_args;
	a2 = tp2->t_args;

	while (*a1 != NULL && *a2 != NULL) {

		if (eqtype(*a1, *a2, 1, 0, 0, warn) == 0)
			return (0);

		a1++;
		a2++;

	}

	return (*a1 == *a2);
}

/*
 * mnoarg() (matches functions with no argument type information)
 * returns 1 if all parameters of a prototype are compatible with
 * and old style function declaration.
 * This is the case if following conditions are met:
 *	1. the prototype must have a fixed number of parameters
 *	2. no parameter is of type float
 *	3. no parameter is converted to another type if integer promotion
 *	   is applied on it
 */
static int
mnoarg(type_t *tp, int *warn)
{
	type_t	**arg;
	tspec_t	t;

	if (tp->t_vararg && warn != NULL)
		*warn = 1;
	for (arg = tp->t_args; *arg != NULL; arg++) {
		if ((t = (*arg)->t_tspec) == FLOAT)
			return (0);
		if (t == CHAR || t == SCHAR || t == UCHAR)
			return (0);
		if (t == SHORT || t == USHORT)
			return (0);
	}
	return (1);
}
@


1.26
log
@remove rcsids which escaped the purge of 2009
@
text
@d1 1
a1 1
/*	$OpenBSD: chk.c,v 1.25 2011/07/03 18:15:10 martynas Exp $	*/
@


1.25
log
@Update floating-point format specifier checks;  the situation has
gotten better.  %E, %F, %G are OK to use.  Also recognize %a, %A.
@
text
@d1 1
a1 1
/*	$OpenBSD: chk.c,v 1.24 2011/06/20 13:33:47 martynas Exp $	*/
a33 4

#ifndef lint
static char rcsid[] = "$OpenBSD: chk.c,v 1.24 2011/06/20 13:33:47 martynas Exp $";
#endif
@


1.24
log
@Teach lint about %F, %A, %a format specifiers.
OK millert@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: chk.c,v 1.23 2011/06/20 13:29:09 millert Exp $	*/
d36 1
a36 1
static char rcsid[] = "$OpenBSD: chk.c,v 1.23 2011/06/20 13:29:09 millert Exp $";
d1037 4
a1040 23
		} else if (fc == 'E') {
			/*
			 * XXX valid in ANSI C, but in NetBSD's libc imple-
			 * mented as "lf". Thats why it should be avoided.
			 */
			badfmt(hte, call);
			sz = DOUBLE;
			goto conv;
		} else if (fc == 'F') {
			/* XXX only for backward compatibility */
			badfmt(hte, call);
			sz = DOUBLE;
			goto conv;
		} else if (fc == 'G') {
			/*
			 * XXX valid in ANSI C, but in NetBSD's libc not
			 * implemented
			 */
			if (sz != NOTSPEC && sz != LONG && sz != LDOUBLE)
				badfmt(hte, call);
			goto fconv;
		} else if (fc == 'e' || fc == 'f' || fc == 'g') {
		fconv:
@


1.23
log
@Revert rev 1.21 which is superceded by 1.22
@
text
@d1 1
a1 1
/*	$OpenBSD: chk.c,v 1.20 2011/05/31 22:27:54 martynas Exp $	*/
d36 1
a36 1
static char rcsid[] = "$OpenBSD: chk.c,v 1.22 2011/06/20 13:27:07 millert Exp $";
d870 4
a873 2
		} else if (fc == 'f' || fc == 'e' || fc == 'E' ||
			   fc == 'g' || fc == 'G') {
@


1.22
log
@Prevent lint from warning about %m in C format strings.  Quiets
false positives when check syslog(3) format strings that use %m.
OK tedu@@ martynas@@
@
text
@d1 1
a1 1
/*	$OpenBSD: chk.c,v 1.21 2011/06/18 22:29:59 tedu Exp $	*/
d36 1
a36 1
static char rcsid[] = "$OpenBSD: chk.c,v 1.21 2011/06/18 22:29:59 tedu Exp $";
a812 5
		}

		if (fc == 'm') {
			fc = *fp++;
			continue;
@


1.21
log
@the %m argument as used by syslog does not eat an argument, so skip over it.
ok martynas
@
text
@d1 1
a1 1
/*	$OpenBSD: chk.c,v 1.20 2011/05/31 22:27:54 martynas Exp $	*/
d36 1
a36 1
static char rcsid[] = "$OpenBSD: chk.c,v 1.20 2011/05/31 22:27:54 martynas Exp $";
d801 1
a801 1
		if (fc == '%') {
@


1.20
log
@Lint didn't take into account padding of LDOUBLE, LDCOMPLEX,
LDIMAGINARY, therefore was doing portability checks against a
non-existent architecture.

Make psizes of the mentioned types 128-bits for portability checks.
(since it's rarer).
@
text
@d1 1
a1 1
/*	$OpenBSD: chk.c,v 1.19 2011/05/31 21:25:30 martynas Exp $	*/
d36 1
a36 1
static char rcsid[] = "$OpenBSD: chk.c,v 1.19 2011/05/31 21:25:30 martynas Exp $";
d813 5
@


1.19
log
@Make tt_domain = 3 (complex), not 1 (real) for the complex types
(COMPLEX, DCOMPLEX, LDCOMPLEX).

While at it, _Complex float -> float _Complex since that's the type
defined by C99.

OK millert@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: chk.c,v 1.18 2010/07/27 20:07:56 guenther Exp $	*/
d36 1
a36 1
static char rcsid[] = "$OpenBSD: chk.c,v 1.18 2010/07/27 20:07:56 guenther Exp $";
d130 1
a130 1
		{ LDOUBLE,  { sizeof (ldbl_t) * CHAR_BIT, 10 * CHAR_BIT, -1,
d142 1
a142 1
				      20 * CHAR_BIT, -1,
@


1.18
log
@Fix compilation on gcc2 platforms, where _Bool and _Complex aren't
built into the compiler and instead have to be gotten from stdbool.h
and complex.h

Problem noted by miod@@, fix by deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: chk.c,v 1.17 2010/07/24 22:17:03 guenther Exp $	*/
d36 1
a36 1
static char rcsid[] = "$OpenBSD: chk.c,v 1.17 2010/07/24 22:17:03 guenther Exp $";
d133 1
a133 1
		{ COMPLEX,  { sizeof (_Complex float) * CHAR_BIT,
d136 1
a136 1
				      0, 0, 1, 1, 1, "float _Complex" } },
d140 1
a140 1
				      0, 0, 1, 1, 1, "double _Complex" } },
d144 1
a144 1
				      0, 0, 1, 1, 1, "long double _Complex" } },
@


1.17
log
@Teach lint about C99's _Bool and _Complex, plus some related gcc
extensions: __real__ and __imag__ operators, the use of '~' for
complex conjugation, and 'i' or 'j' as a suffix for complex constants.
While this doesn't handle folding and overflow detection for complex
constants correctly, it's good enough to make it through libm...and
found several bugs once it could do so.

"no objections" miod@@, krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: chk.c,v 1.16 2007/05/26 00:36:04 krw Exp $	*/
d36 1
a36 1
static char rcsid[] = "$OpenBSD: chk.c,v 1.16 2007/05/26 00:36:04 krw Exp $";
d42 2
@


1.16
log
@More comment typos from Diego Casati. Including winners like funtion, allmost,
oustside, seqencer, toghether, nessissary, etc.
@
text
@d1 1
a1 1
/*	$OpenBSD: chk.c,v 1.15 2006/07/09 19:37:00 miod Exp $	*/
d36 1
a36 1
static char rcsid[] = "$OpenBSD: chk.c,v 1.15 2006/07/09 19:37:00 miod Exp $";
d86 3
d131 12
@


1.15
log
@*enty->*ently where applicable
@
text
@d1 1
a1 1
/*	$OpenBSD: chk.c,v 1.14 2006/05/29 20:47:22 cloder Exp $	*/
d36 1
a36 1
static char rcsid[] = "$OpenBSD: chk.c,v 1.14 2006/05/29 20:47:22 cloder Exp $";
d569 1
a569 1
	 * result are lots of warnings which are really not neccessary.
@


1.14
log
@Get rid of -t (traditional C) option. Some corrections by moritz.
@
text
@d1 1
a1 1
/*	$OpenBSD: chk.c,v 1.13 2006/04/25 01:25:41 cloder Exp $	*/
d36 1
a36 1
static char rcsid[] = "$OpenBSD: chk.c,v 1.13 2006/04/25 01:25:41 cloder Exp $";
d374 1
a374 1
			/* %s: %s used inconsistenty (%s) */
@


1.13
log
@Rather than use the psize() macro everywhere (portable size macro which
only makes sense when -p option is specified to lint), add a new concept
and macro called rank(), which corresponds to the C99 definition of rank
for integral types. This has one main benefit, which is that on ILP32
platforms, if -p was not specified, lint did not warn when the code
converted from long to int, because they are the same size. This is
fixed.

While here, get rid of a false positive with warning 259, when converting
from an unsigned char to an int, for example.
@
text
@d1 1
a1 1
/*	$OpenBSD: chk.c,v 1.12 2005/12/10 20:26:10 cloder Exp $	*/
d36 1
a36 1
static char rcsid[] = "$OpenBSD: chk.c,v 1.12 2005/12/10 20:26:10 cloder Exp $";
d598 1
a598 1
				t1 = tflag ? UINT : INT;
d603 1
a603 1
				t1 = INT_MAX < USHRT_MAX || tflag ? UINT : INT;
d845 2
a846 2
			if ((alt && fc != 'O') || sz != NOTSPEC || !tflag)
				badfmt(hte, call);
d1003 1
a1003 2
			if (sz != NOTSPEC || !tflag)
				badfmt(hte, call);
d1007 1
a1007 2
			if (sz != NOTSPEC || !tflag)
				badfmt(hte, call);
d1015 1
a1015 2
			if (sz != NOTSPEC || !tflag)
				badfmt(hte, call);
d1023 1
a1023 2
			if (sz != NOTSPEC || !tflag)
				badfmt(hte, call);
d1028 1
a1028 2
			if (sz != NOTSPEC || !tflag)
				badfmt(hte, call);
d1271 1
a1271 1
				t = tflag ? UINT : INT;
d1276 1
a1276 1
				t = INT_MAX < USHRT_MAX || tflag ? UINT : INT;
d1316 1
a1316 1
		} else if (!ignqual && !tflag) {
@


1.12
log
@Make the style of these messages more like that of gcc messages.
@
text
@d1 1
a1 1
/*	$OpenBSD: chk.c,v 1.11 2005/12/01 05:06:40 cloder Exp $	*/
d36 1
a36 1
static char rcsid[] = "$OpenBSD: chk.c,v 1.11 2005/12/01 05:06:40 cloder Exp $";
d80 1
a80 1
		{ SIGNED,   { 0, 0,
d83 1
a83 1
		{ UNSIGN,   { 0, 0,
d86 1
a86 1
		{ CHAR,	    { CHAR_BIT, CHAR_BIT,
d89 1
a89 1
		{ SCHAR,    { CHAR_BIT, CHAR_BIT,
d92 1
a92 1
		{ UCHAR,    { CHAR_BIT, CHAR_BIT,
d95 1
a95 1
		{ SHORT,    { sizeof (short) * CHAR_BIT, 2 * CHAR_BIT,
d98 1
a98 1
		{ USHORT,   { sizeof (u_short) * CHAR_BIT, 2 * CHAR_BIT,
d101 1
a101 1
		{ INT,      { sizeof (int) * CHAR_BIT, 3 * CHAR_BIT,
d104 1
a104 1
		{ UINT,     { sizeof (u_int) * CHAR_BIT, 3 * CHAR_BIT,
d107 1
a107 1
		{ LONG,     { sizeof (long) * CHAR_BIT, 4 * CHAR_BIT,
d110 1
a110 1
		{ ULONG,    { sizeof (u_long) * CHAR_BIT, 4 * CHAR_BIT,
d113 1
a113 1
		{ QUAD,     { sizeof (quad_t) * CHAR_BIT, 8 * CHAR_BIT,
d116 1
a116 1
		{ UQUAD,    { sizeof (u_quad_t) * CHAR_BIT, 8 * CHAR_BIT,
d119 1
a119 1
		{ FLOAT,    { sizeof (float) * CHAR_BIT, 4 * CHAR_BIT,
d122 1
a122 1
		{ DOUBLE,   { sizeof (double) * CHAR_BIT, 8 * CHAR_BIT,
d125 1
a125 1
		{ LDOUBLE,  { sizeof (ldbl_t) * CHAR_BIT, 10 * CHAR_BIT,
d128 1
a128 1
		{ VOID,     { -1, -1,
d131 1
a131 1
		{ STRUCT,   { -1, -1,
d134 1
a134 1
		{ UNION,    { -1, -1,
d137 1
a137 1
		{ ENUM,     { sizeof (int) * CHAR_BIT, 3 * CHAR_BIT,
d140 1
a140 1
		{ PTR,      { sizeof (void *) * CHAR_BIT, 4 * CHAR_BIT,
d143 1
a143 1
		{ ARRAY,    { -1, -1,
d146 1
a146 1
		{ FUNC,     { -1, -1,
@


1.11
log
@Make lint quieter by only warning on "foo declared but never used or
defined" when foo is declared in the translation unit that lint is working
on.  This means that symbols that are declared in an included header file
don't get this warning, ever.
@
text
@d1 1
a1 1
/*	$OpenBSD: chk.c,v 1.10 2005/11/20 17:42:50 deraadt Exp $	*/
d36 1
a36 1
static char rcsid[] = "$OpenBSD: chk.c,v 1.10 2005/11/20 17:42:50 deraadt Exp $";
d230 2
a231 2
		/* %s used( %s ), but not defined */
		msg(0, hte->h_name, mkpos(&fcall->f_pos));
d233 2
a234 2
		/* %s used( %s ), but not defined */
		msg(0, hte->h_name, mkpos(&usym->u_pos));
d251 2
a252 2
			/* %s defined( %s ), but never used */
			msg(1, hte->h_name, mkpos(&sym->s_pos));
d279 2
a280 2
		/* %s declared( %s ), but never used or defined */
		msg(2, hte->h_name, mkpos(&sym->s_pos));
d310 2
a311 2
		/* %s multiply defined\t%s  ::  %s */
		msg(3, hte->h_name, pos1, mkpos(&sym->s_pos));
d365 3
a367 3
				/* %s value must be decl. before use %s :: %s */
				msg(17, hte->h_name,
				    pos1, mkpos(&call->f_pos));
d374 2
a375 2
			/* %s value used inconsistenty\t%s  ::  %s */
			msg(4, hte->h_name, pos1, mkpos(&call->f_pos));
d413 2
a414 2
			/* %s value declared inconsistently\t%s  ::  %s */
			msg(5, hte->h_name, pos1, mkpos(&sym->s_pos));
d495 2
a496 2
			/* %s: variable # of args\t%s  ::  %s */
			msg(7, hte->h_name, pos1, mkpos(&call->f_pos));
d672 2
a673 2
	/* %s, arg %d used inconsistently\t%s  ::  %s */
	msg(6, hte->h_name, n, pos1, mkpos(&call->f_pos));
d1100 2
a1101 2
	/* %s: malformed format string\t%s */
	msg(13, hte->h_name, mkpos(&call->f_pos));
d1107 2
a1108 2
	/* %s, arg %d inconsistent with format\t%s(%d) */
	msg(14, hte->h_name, n, mkpos(&call->f_pos));
d1114 2
a1115 2
	/* %s: too few args for format  \t%s */
	msg(15, hte->h_name, mkpos(&call->f_pos));
d1121 2
a1122 2
	/* %s: too many args for format  \t%s */
	msg(16, hte->h_name, mkpos(&call->f_pos));
d1169 2
a1170 2
				/* %s value is used( %s ), but none ret. */
				msg(10, hte->h_name, mkpos(&call->f_pos));
d1217 2
a1218 2
				/* %s, arg %d declared inconsistently ... */
				msg(11, hte->h_name, n + 1, pos1, pos2);
d1235 1
a1235 1
		/* %s: variable # of args declared\t%s  ::  %s */
d1237 1
a1237 1
		msg(12, hte->h_name, pos1, mkpos(&sym->s_pos));
@


1.10
log
@spacing
@
text
@d1 1
a1 1
/*	$OpenBSD: chk.c,v 1.9 2005/11/20 17:09:55 cloder Exp $	*/
d36 1
a36 1
static char rcsid[] = "$OpenBSD: chk.c,v 1.9 2005/11/20 17:09:55 cloder Exp $";
d273 6
@


1.9
log
@KNF. OK kjell, millert
@
text
@d1 1
a1 1
/*	$OpenBSD: chk.c,v 1.8 2002/02/17 19:42:35 millert Exp $	*/
d36 1
a36 1
static char rcsid[] = "$OpenBSD: chk.c,v 1.8 2002/02/17 19:42:35 millert Exp $";
d269 1
a269 1
	
d931 1
a931 1
		
d1283 1
a1283 1
		
@


1.8
log
@Manual cleanup of remaining userland __P use (excluding packages maintained outside the tree)
@
text
@d1 1
a1 1
/*	$OpenBSD: chk.c,v 1.7 2002/02/16 21:27:59 millert Exp $	*/
d36 1
a36 1
static char rcsid[] = "$OpenBSD: chk.c,v 1.7 2002/02/16 21:27:59 millert Exp $";
d73 1
a73 1
inittyp()
d164 1
a164 1
mainused()
d176 1
a176 2
chkname(hte)
	hte_t	*hte;
d221 1
a221 2
chkund(hte)
	hte_t	*hte;
d242 1
a242 2
chkdnu(hte)
	hte_t	*hte;
d263 1
a263 2
chkdnud(hte)
	hte_t	*hte;
d283 1
a283 2
chkmd(hte)
	hte_t	*hte;
d320 1
a320 3
chkvtui(hte, def, decl)
	hte_t	*hte;
	sym_t	*def, *decl;
d381 1
a381 3
chkvtdi(hte, def, decl)
	hte_t	*hte;
	sym_t	*def, *decl;
d420 1
a420 3
chkfaui(hte, def, decl)
	hte_t	*hte;
	sym_t	*def, *decl;
d528 2
a529 7
chkau(hte, n, def, decl, pos1p, call1, call, arg1, arg2)
	hte_t	*hte;
	int	n;
	sym_t	*def, *decl;
	pos_t	*pos1p;
	fcall_t	*call1, *call;
	type_t	*arg1, *arg2;
d676 1
a676 6
printflike(hte, call, n, fmt, ap)
	hte_t	*hte;
	fcall_t	*call;
	int	n;
	const	char *fmt;
	type_t	**ap;
d901 1
a901 6
scanflike(hte, call, n, fmt, ap)
	hte_t	*hte;
	fcall_t	*call;
	int	n;
	const	char *fmt;
	type_t	**ap;
d1092 1
a1092 3
badfmt(hte, call)
	hte_t	*hte;
	fcall_t	*call;
d1099 1
a1099 4
inconarg(hte, call, n)
	hte_t	*hte;
	fcall_t	*call;
	int	n;
d1106 1
a1106 3
tofewarg(hte, call)
	hte_t	*hte;
	fcall_t	*call;
d1113 1
a1113 3
tomanyarg(hte, call)
	hte_t	*hte;
	fcall_t	*call;
d1125 1
a1125 3
chkrvu(hte, def)
	hte_t	*hte;
	sym_t	*def;
d1173 1
a1173 3
chkadecl(hte, def, decl)
	hte_t	*hte;
	sym_t	*def, *decl;
d1253 1
a1253 3
eqtype(tp1, tp2, ignqual, promot, asgn, warn)
	type_t	*tp1, *tp2;
	int	ignqual, promot, asgn, *warn;
d1365 1
a1365 3
eqargs(tp1, tp2, warn)
	type_t	*tp1, *tp2;
	int	*warn;
d1399 1
a1399 3
mnoarg(tp, warn)
	type_t	*tp;
	int	*warn;
a1415 1

@


1.7
log
@Part one of userland __P removal.  Done with a simple regexp with some minor hand editing to make comments line up correctly.  Another pass is forthcoming that handles the cases that could not be done automatically.
@
text
@d1 1
a1 1
/*	$OpenBSD: chk.c,v 1.6 2001/11/19 19:22:43 deraadt Exp $	*/
d36 1
a36 1
static char rcsid[] = "$OpenBSD: chk.c,v 1.6 2001/11/19 19:22:43 deraadt Exp $";
d57 2
a58 2
static	void	chkau __P((hte_t *, int, sym_t *, sym_t *, pos_t *,
			   fcall_t *, fcall_t *, type_t *, type_t *));
d61 2
a62 4
static	void	printflike __P((hte_t *,fcall_t *, int,
				const char *, type_t **));
static	void	scanflike __P((hte_t *, fcall_t *, int,
			       const char *, type_t **));
@


1.6
log
@more than typo
@
text
@d1 1
a1 1
/*	$OpenBSD: chk.c,v 1.5 1998/07/29 03:14:51 millert Exp $	*/
d36 1
a36 1
static char rcsid[] = "$OpenBSD: chk.c,v 1.5 1998/07/29 03:14:51 millert Exp $";
d50 7
a56 7
static	void	chkund __P((hte_t *));
static	void	chkdnu __P((hte_t *));
static	void	chkdnud __P((hte_t *));
static	void	chkmd __P((hte_t *));
static	void	chkvtui __P((hte_t *, sym_t *, sym_t *));
static	void	chkvtdi __P((hte_t *, sym_t *, sym_t *));
static	void	chkfaui __P((hte_t *, sym_t *, sym_t *));
d59 2
a60 2
static	void	chkrvu __P((hte_t *, sym_t *));
static	void	chkadecl __P((hte_t *, sym_t *, sym_t *));
d65 7
a71 7
static	void	badfmt __P((hte_t *, fcall_t *));
static	void	inconarg __P((hte_t *, fcall_t *, int));
static	void	tofewarg __P((hte_t *, fcall_t *));
static	void	tomanyarg __P((hte_t *, fcall_t *));
static	int	eqtype __P((type_t *, type_t *, int, int, int, int *));
static	int	eqargs __P((type_t *, type_t *, int *));
static	int	mnoarg __P((type_t *, int *));
@


1.5
log
@fix some initialization; ITOH Yasufumi <yasufu-i@@is.aist-nara.ac.jp>
@
text
@d1 1
a1 1
/*	$OpenBSD: chk.c,v 1.4 1998/07/27 16:53:43 deraadt Exp $	*/
d36 1
a36 1
static char rcsid[] = "$OpenBSD: chk.c,v 1.4 1998/07/27 16:53:43 deraadt Exp $";
d285 1
a285 1
 * Print a warning if there is more then one definition for
@


1.4
log
@s/comparision/comparison/g; netbsd
@
text
@d1 1
a1 1
/*	$OpenBSD: chk.c,v 1.3 1997/09/08 08:43:17 deraadt Exp $	*/
d36 1
a36 1
static char rcsid[] = "$OpenBSD: chk.c,v 1.3 1997/09/08 08:43:17 deraadt Exp $";
d704 1
a704 1
	tspec_t	sz, t1, t2;
d934 1
a934 1
	tspec_t	sz, t1, t2;
@


1.3
log
@fix for sometimes/always ignored status; cato@@ulysses.df.lth.se
@
text
@d1 1
a1 1
/*	$OpenBSD: chk.c,v 1.2 1996/06/26 05:44:21 deraadt Exp $	*/
d36 1
a36 1
static char rcsid[] = "$OpenBSD: chk.c,v 1.2 1996/06/26 05:44:21 deraadt Exp $";
d446 1
a446 1
	 * If we find a function definition, we use this for comparision,
d1284 2
a1285 2
 * promote	if set, promote left type before comparision; used for
 *		comparisions of arguments with parameters of old style
@


1.2
log
@rcsid
@
text
@d1 1
a1 1
/*	$OpenBSD: chk.c,v 1.2 1995/07/03 21:24:42 cgd Exp $	*/
d36 1
a36 1
static char rcsid[] = "$OpenBSD: chk.c,v 1.2 1995/07/03 21:24:42 cgd Exp $";
d1180 1
a1180 1
			used |= call->f_rused;
@


1.1
log
@Initial revision
@
text
@d1 1
d36 1
a36 1
static char rcsid[] = "$NetBSD: chk.c,v 1.2 1995/07/03 21:24:42 cgd Exp $";
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@
