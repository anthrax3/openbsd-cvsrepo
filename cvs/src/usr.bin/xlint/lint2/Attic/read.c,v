head	1.13;
access;
symbols
	OPENBSD_5_1_BASE:1.12
	OPENBSD_5_1:1.12.0.2
	OPENBSD_5_0:1.11.0.2
	OPENBSD_5_0_BASE:1.11
	OPENBSD_4_9:1.10.0.4
	OPENBSD_4_9_BASE:1.10
	OPENBSD_4_8:1.10.0.2
	OPENBSD_4_8_BASE:1.10
	OPENBSD_4_7:1.9.0.16
	OPENBSD_4_7_BASE:1.9
	OPENBSD_4_6:1.9.0.18
	OPENBSD_4_6_BASE:1.9
	OPENBSD_4_5:1.9.0.14
	OPENBSD_4_5_BASE:1.9
	OPENBSD_4_4:1.9.0.12
	OPENBSD_4_4_BASE:1.9
	OPENBSD_4_3:1.9.0.10
	OPENBSD_4_3_BASE:1.9
	OPENBSD_4_2:1.9.0.8
	OPENBSD_4_2_BASE:1.9
	OPENBSD_4_1:1.9.0.6
	OPENBSD_4_1_BASE:1.9
	OPENBSD_4_0:1.9.0.4
	OPENBSD_4_0_BASE:1.9
	OPENBSD_3_9:1.9.0.2
	OPENBSD_3_9_BASE:1.9
	OPENBSD_3_8:1.6.0.8
	OPENBSD_3_8_BASE:1.6
	OPENBSD_3_7:1.6.0.6
	OPENBSD_3_7_BASE:1.6
	OPENBSD_3_6:1.6.0.4
	OPENBSD_3_6_BASE:1.6
	OPENBSD_3_5:1.6.0.2
	OPENBSD_3_5_BASE:1.6
	OPENBSD_3_4:1.5.0.8
	OPENBSD_3_4_BASE:1.5
	OPENBSD_3_3:1.5.0.6
	OPENBSD_3_3_BASE:1.5
	OPENBSD_3_2:1.5.0.4
	OPENBSD_3_2_BASE:1.5
	OPENBSD_3_1:1.5.0.2
	OPENBSD_3_1_BASE:1.5
	OPENBSD_3_0:1.3.0.14
	OPENBSD_3_0_BASE:1.3
	OPENBSD_2_9_BASE:1.3
	OPENBSD_2_9:1.3.0.12
	OPENBSD_2_8:1.3.0.10
	OPENBSD_2_8_BASE:1.3
	OPENBSD_2_7:1.3.0.8
	OPENBSD_2_7_BASE:1.3
	OPENBSD_2_6:1.3.0.6
	OPENBSD_2_6_BASE:1.3
	OPENBSD_2_5:1.3.0.4
	OPENBSD_2_5_BASE:1.3
	OPENBSD_2_4:1.3.0.2
	OPENBSD_2_4_BASE:1.3
	OPENBSD_2_3:1.2.0.8
	OPENBSD_2_3_BASE:1.2
	OPENBSD_2_2:1.2.0.6
	OPENBSD_2_2_BASE:1.2
	OPENBSD_2_1:1.2.0.4
	OPENBSD_2_1_BASE:1.2
	OPENBSD_2_0:1.2.0.2
	OPENBSD_2_0_BASE:1.2
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.13
date	2012.04.08.16.27.00;	author jsg;	state dead;
branches;
next	1.12;

1.12
date	2011.09.21.18.08.07;	author jsg;	state Exp;
branches;
next	1.11;

1.11
date	2011.03.15.21.59.27;	author espie;	state Exp;
branches;
next	1.10;

1.10
date	2010.07.24.22.17.03;	author guenther;	state Exp;
branches;
next	1.9;

1.9
date	2005.12.01.05.06.40;	author cloder;	state Exp;
branches;
next	1.8;

1.8
date	2005.11.30.18.47.10;	author deraadt;	state Exp;
branches;
next	1.7;

1.7
date	2005.11.20.17.09.55;	author cloder;	state Exp;
branches;
next	1.6;

1.6
date	2003.11.08.19.17.29;	author jmc;	state Exp;
branches;
next	1.5;

1.5
date	2002.02.19.19.39.39;	author millert;	state Exp;
branches;
next	1.4;

1.4
date	2002.02.16.21.27.59;	author millert;	state Exp;
branches;
next	1.3;

1.3
date	98.07.29.03.14.54;	author millert;	state Exp;
branches;
next	1.2;

1.2
date	96.06.26.05.44.26;	author deraadt;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.47.04;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.47.04;	author deraadt;	state Exp;
branches;
next	;


desc
@@


1.13
log
@tedu lint
ok tedu@@ guenther@@ krw@@ espie@@ deraadt@@
@
text
@/*	$OpenBSD: read.c,v 1.12 2011/09/21 18:08:07 jsg Exp $	*/
/*	$NetBSD: read.c,v 1.2 1995/07/03 21:24:59 cgd Exp $	*/

/*
 * Copyright (c) 1994, 1995 Jochen Pohl
 * All Rights Reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *      This product includes software developed by Jochen Pohl for
 *	The NetBSD Project.
 * 4. The name of the author may not be used to endorse or promote products
 *    derived from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
 * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
 * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <ctype.h>
#include <limits.h>
#include <err.h>

#include "lint2.h"


/* index of current (included) source file */
static	int	srcfile;

/*
 * The array pointed to by inpfns maps the file name indices of input files
 * to the file name indices used in lint2
 */
static	short	*inpfns;
static	size_t	ninpfns;

/*
 * The array pointed to by *fnames maps file name indizes to file names.
 * Indices of type short are used instead of pointers to save memory.
 */
const	char **fnames;
static	size_t	nfnames;

/*
 * Types are shared (to save memory for the types itself) and accessed
 * via indices (to save memory for references to types (indices are short)).
 * To share types, a equal type must be located fast. This is done by a
 * hash table. Access by indices is done via an array of pointers to the
 * types.
 */
typedef struct thtab {
	const	char *th_name;
	u_short	th_idx;
	struct	thtab *th_nxt;
} thtab_t;
static	thtab_t	**thtab;		/* hash table */
type_t	**tlst;				/* array for indexed access */
static	size_t	tlstlen;		/* length of tlst */

/* index of current C source file (as spezified at the command line) */
int	csrcfile;


static	void	inperr(void);
static	void	setsrc(const char *);
static	void	setfnid(int, const char *);
static	void	funccall(pos_t *, const char *);
static	void	decldef(pos_t *, const char *);
static	void	usedsym(pos_t *, const char *);
static	u_short	inptype(const char *, const char **);
static	int	gettlen(const char *, const char **);
static	u_short	findtype(const char *, size_t, int);
static	u_short	storetyp(type_t *, const char *, size_t, int);
static	int	thash(const char *, size_t);
static	char	*inpqstrg(const char *, const char **);
static	const	char *inpname(const char *, const char **);
static	int	getfnidx(const char *);

void
readfile(const char *name)
{
	FILE	*inp;
	size_t	len;
	const	char *cp;
	char	*line, *eptr, rt;
	int	cline, isrc, iline;
	pos_t	pos;

	if (inpfns == NULL)
		inpfns = xcalloc(ninpfns = 128, sizeof (short));
	if (fnames == NULL)
		fnames = xcalloc(nfnames = 256, sizeof (char *));
	if (tlstlen == 0)
		tlst = xcalloc(tlstlen = 256, sizeof (type_t *));
	if (thtab == NULL)
		thtab = xcalloc(THSHSIZ2, sizeof (thtab_t));

	srcfile = getfnidx(name);

	if ((inp = fopen(name, "r")) == NULL)
		err(1, "cannot open %s", name);

	while ((line = fgetln(inp, &len)) != NULL) {

		if (len == 0 || line[len - 1] != '\n')
			inperr();
		line[len - 1] = '\0';
		cp = line;

		/* line number in csrcfile */
		cline = (int)strtol(cp, &eptr, 10);
		if (cp == eptr) {
			cline = -1;
		} else {
			cp = eptr;
		}

		/* record type */
		if (*cp != '\0') {
			rt = *cp++;
		} else {
			inperr();
		}

		if (rt == 'S') {
			setsrc(cp);
			continue;
		} else if (rt == 's') {
			setfnid(cline, cp);
			continue;
		}

		/*
		 * Index of (included) source file. If this index is
		 * different from csrcfile, it refers to an included
		 * file.
		 */
		isrc = (int)strtol(cp, &eptr, 10);
		if (cp == eptr)
			inperr();
		cp = eptr;
		if (isrc < 0 || isrc >= ninpfns)
			inperr();
		isrc = inpfns[isrc];

		/* line number in isrc */
		if (*cp++ != '.')
			inperr();
		iline = (int)strtol(cp, &eptr, 10);
		if (cp == eptr)
			inperr();
		cp = eptr;

		pos.p_src = (u_short)csrcfile;
		pos.p_line = (u_short)cline;
		pos.p_isrc = (u_short)isrc;
		pos.p_iline = (u_short)iline;

		/* process rest of this record */
		switch (rt) {
		case 'c':
			funccall(&pos, cp);
			break;
		case 'd':
			decldef(&pos, cp);
			break;
		case 'u':
			usedsym(&pos, cp);
			break;
		default:
			inperr();
		}

	}

	if (ferror(inp))
		err(1, "read error on %s", name);

	(void)fclose(inp);
}


static void
inperr(void)
{
	errx(1, "input file error: %s", fnames[srcfile]);
}

/*
 * Set the name of the C source file of the .ln file which is
 * currently read.
 */
static void
setsrc(const char *cp)
{
	csrcfile = getfnidx(cp);
}

/*
 * setfnid() gets as input an index as used in an input file and the
 * associated file name. If necessary, it creates a new lint2 file
 * name index for this file name and creates the mapping of the index
 * as used in the input file to the index used in lint2.
 */
static void
setfnid(int fid, const char *cp)
{
	if (fid == -1)
		inperr();

	if (fid >= ninpfns) {
		inpfns = xrealloc(inpfns, (ninpfns * 2) * sizeof (short));
		(void)memset(inpfns + ninpfns, 0, ninpfns * sizeof (short));
		ninpfns *= 2;
	}
	/*
	 * Should always be true because indices written in the output
	 * file by lint1 are always the previous index + 1.
	 */
	if (fid >= ninpfns)
		errx(1, "internal error: setfnid()");
	inpfns[fid] = (u_short)getfnidx(cp);
}

/*
 * Process a function call record (c-record).
 */
static void
funccall(pos_t *posp, const char *cp)
{
	arginf_t *ai, **lai;
	char	c, *eptr;
	int	rused, rdisc;
	hte_t	*hte;
	fcall_t	*fcall;

	fcall = xalloc(sizeof (fcall_t));
	STRUCT_ASSIGN(fcall->f_pos, *posp);

	/* read flags */
	rused = rdisc = 0;
	lai = &fcall->f_args;
	while ((c = *cp) == 'u' || c == 'i' || c == 'd' ||
	    c == 'z' || c == 'p' || c == 'n' || c == 's') {
		cp++;
		switch (c) {
		case 'u':
			if (rused || rdisc)
				inperr();
			rused = 1;
			break;
		case 'i':
			if (rused || rdisc)
				inperr();
			break;
		case 'd':
			if (rused || rdisc)
				inperr();
			rdisc = 1;
			break;
		case 'z':
		case 'p':
		case 'n':
		case 's':
			ai = xalloc(sizeof (arginf_t));
			ai->a_num = (int)strtol(cp, &eptr, 10);
			if (cp == eptr)
				inperr();
			cp = eptr;
			if (c == 'z') {
				ai->a_pcon = ai->a_zero = 1;
			} else if (c == 'p') {
				ai->a_pcon = 1;
			} else if (c == 'n') {
				ai->a_ncon = 1;
			} else {
				ai->a_fmt = 1;
				ai->a_fstrg = inpqstrg(cp, &cp);
			}
			*lai = ai;
			lai = &ai->a_nxt;
			break;
		}
	}
	fcall->f_rused = rused;
	fcall->f_rdisc = rdisc;

	/* read name of function */
	hte = hsearch(inpname(cp, &cp), 1);
	hte->h_used = 1;

	fcall->f_type = inptype(cp, &cp);

	*hte->h_lcall = fcall;
	hte->h_lcall = &fcall->f_nxt;

	if (*cp != '\0')
		inperr();
}

/*
 * Process a declaration or definition (d-record).
 */
static void
decldef(pos_t *posp, const char *cp)
{
	sym_t	*symp, sym;
	char	c, *ep;
	int	used;
	hte_t	*hte;

	(void)memset(&sym, 0, sizeof (sym));
	STRUCT_ASSIGN(sym.s_pos, *posp);
	sym.s_def = NODECL;

	used = 0;

	while ((c = *cp) == 't' || c == 'd' || c == 'e' || c == 'u' ||
	    c == 'r' || c == 'o' || c == 's' || c == 'v' ||
	    c == 'P' || c == 'S') {
		cp++;
		switch (c) {
		case 't':
			if (sym.s_def != NODECL)
				inperr();
			sym.s_def = TDEF;
			break;
		case 'd':
			if (sym.s_def != NODECL)
				inperr();
			sym.s_def = DEF;
			break;
		case 'e':
			if (sym.s_def != NODECL)
				inperr();
			sym.s_def = DECL;
			break;
		case 'u':
			if (used)
				inperr();
			used = 1;
			break;
		case 'r':
			if (sym.s_rval)
				inperr();
			sym.s_rval = 1;
			break;
		case 'o':
			if (sym.s_osdef)
				inperr();
			sym.s_osdef = 1;
			break;
		case 's':
			if (sym.s_static)
				inperr();
			sym.s_static = 1;
			break;
		case 'v':
			if (sym.s_va)
				inperr();
			sym.s_va = 1;
			sym.s_nva = (short)strtol(cp, &ep, 10);
			if (cp == ep)
				inperr();
			cp = ep;
			break;
		case 'P':
			if (sym.s_prfl)
				inperr();
			sym.s_prfl = 1;
			sym.s_nprfl = (short)strtol(cp, &ep, 10);
			if (cp == ep)
				inperr();
			cp = ep;
			break;
		case 'S':
			if (sym.s_scfl)
				inperr();
			sym.s_scfl = 1;
			sym.s_nscfl = (short)strtol(cp, &ep, 10);
			if (cp == ep)
				inperr();
			cp = ep;
			break;
		}
	}

	/* read symbol name */
	hte = hsearch(inpname(cp, &cp), 1);
	hte->h_used |= used;
	if (sym.s_def == DEF || sym.s_def == TDEF)
		hte->h_def = 1;

	sym.s_type = inptype(cp, &cp);

	/*
	 * Allocate memory for this symbol only if it was not already
	 * declared or tentatively defined at the same location with
	 * the same type. Works only for symbols with external linkage,
	 * because static symbols, tentatively defined at the same location
	 * but in different translation units are really different symbols.
	 */
	for (symp = hte->h_syms; symp != NULL; symp = symp->s_nxt) {
		if (symp->s_pos.p_isrc == sym.s_pos.p_isrc &&
		    symp->s_pos.p_iline == sym.s_pos.p_iline &&
		    symp->s_type == sym.s_type &&
		    ((symp->s_def == DECL && sym.s_def == DECL) ||
		     (!sflag && symp->s_def == TDEF && sym.s_def == TDEF)) &&
		    !symp->s_static && !sym.s_static) {
			break;
		}
	}

	if (symp == NULL) {
		/* allocsym reserviert keinen Platz fuer s_nva */
		if (sym.s_va || sym.s_prfl || sym.s_scfl) {
			symp = xalloc(sizeof (sym_t));
			STRUCT_ASSIGN(*symp, sym);
		} else {
			symp = xalloc(sizeof (symp->s_s));
			STRUCT_ASSIGN(symp->s_s, sym.s_s);
		}
		*hte->h_lsym = symp;
		hte->h_lsym = &symp->s_nxt;
	}

	if (*cp != '\0')
		inperr();
}

/*
 * Read an u-record (emited by lint1 if a symbol was used).
 */
static void
usedsym(pos_t *posp, const char *cp)
{
	usym_t	*usym;
	hte_t	*hte;

	usym = xalloc(sizeof (usym_t));
	STRUCT_ASSIGN(usym->u_pos, *posp);

	/* needed as delimiter between two numbers */
	if (*cp++ != 'x')
		inperr();

	hte = hsearch(inpname(cp, &cp), 1);
	hte->h_used = 1;

	*hte->h_lusym = usym;
	hte->h_lusym = &usym->u_nxt;
}

/*
 * Read a type and return the index of this type.
 */
static u_short
inptype(const char *cp, const char **epp)
{
	char	c, s, *eptr;
	const	char *ep;
	type_t	*tp;
	int	narg, i, osdef;
	size_t	tlen;
	u_short	tidx;
	int	h;

	/* If we have this type already, return it's index. */
	tlen = gettlen(cp, &ep);
	h = thash(cp, tlen);
	if ((tidx = findtype(cp, tlen, h)) != 0) {
		*epp = ep;
		return (tidx);
	}

	/* No, we must create a new type. */
	tp = xalloc(sizeof (type_t));

	tidx = storetyp(tp, cp, tlen, h);

	c = *cp++;

	while (c == 'c' || c == 'v') {
		if (c == 'c') {
			tp->t_const = 1;
		} else {
			tp->t_volatile = 1;
		}
		c = *cp++;
	}

	if (c == 's' || c == 'u' || c == 'l' || c == 'e') {
		s = c;
		c = *cp++;
	} else {
		s = '\0';
	}

	switch (c) {
	case 'B':
		tp->t_tspec = BOOL;
		break;
	case 'C':
		tp->t_tspec = s == 's' ? SCHAR : (s == 'u' ? UCHAR : CHAR);
		break;
	case 'S':
		tp->t_tspec = s == 'u' ? USHORT : SHORT;
		break;
	case 'I':
		tp->t_tspec = s == 'u' ? UINT : INT;
		break;
	case 'L':
		tp->t_tspec = s == 'u' ? ULONG : LONG;
		break;
	case 'Q':
		tp->t_tspec = s == 'u' ? UQUAD : QUAD;
		break;
	case 'D':
		tp->t_tspec = s == 's' ? FLOAT : (s == 'l' ? LDOUBLE : DOUBLE);
		break;
	case 'X':
		tp->t_tspec = s == 's' ? COMPLEX : (s == 'l' ?
		    LDCOMPLEX : DCOMPLEX);
		break;
	case 'J':
		tp->t_tspec = s == 's' ? IMAGINARY : (s == 'l' ?
		    LDIMAGINARY : DIMAGINARY);
		break;
	case 'V':
		tp->t_tspec = VOID;
		break;
	case 'P':
		tp->t_tspec = PTR;
		break;
	case 'A':
		tp->t_tspec = ARRAY;
		break;
	case 'F':
	case 'f':
		osdef = c == 'f';
		tp->t_tspec = FUNC;
		break;
	case 'T':
		tp->t_tspec = s == 'e' ? ENUM : (s == 's' ? STRUCT : UNION);
		break;
	}

	switch (tp->t_tspec) {
	case ARRAY:
		tp->t_dim = (int)strtol(cp, &eptr, 10);
		cp = eptr;
		tp->t_subt = TP(inptype(cp, &cp));
		break;
	case PTR:
		tp->t_subt = TP(inptype(cp, &cp));
		break;
	case FUNC:
		c = *cp;
		if (isdigit((u_char)c)) {
			if (!osdef)
				tp->t_proto = 1;
			narg = (int)strtol(cp, &eptr, 10);
			cp = eptr;
			tp->t_args = xcalloc((size_t)(narg + 1),
					     sizeof (type_t *));
			for (i = 0; i < narg; i++) {
				if (i == narg - 1 && *cp == 'E') {
					tp->t_vararg = 1;
					cp++;
				} else {
					tp->t_args[i] = TP(inptype(cp, &cp));
				}
			}
		}
		tp->t_subt = TP(inptype(cp, &cp));
		break;
	case ENUM:
		tp->t_tspec = INT;
		tp->t_isenum = 1;
		/* FALLTHROUGH */
	case STRUCT:
	case UNION:
		switch (*cp++) {
		case '0':
			break;
		case '1':
			tp->t_istag = 1;
			tp->t_tag = hsearch(inpname(cp, &cp), 1);
			break;
		case '2':
			tp->t_istynam = 1;
			tp->t_tynam = hsearch(inpname(cp, &cp), 1);
			break;
		}
		break;
		/* LINTED (enumeration value(s) not handled in switch) */
	}

	*epp = cp;
	return (tidx);
}

/*
 * Get the length of a type string.
 */
static int
gettlen(const char *cp, const char **epp)
{
	const	char *cp1;
	char	c, s, *eptr;
	tspec_t	t;
	int	narg, i, cm, vm;

	cp1 = cp;

	c = *cp++;

	cm = vm = 0;

	while (c == 'c' || c == 'v') {
		if (c == 'c') {
			if (cm)
				inperr();
			cm = 1;
		} else {
			if (vm)
				inperr();
			vm = 1;
		}
		c = *cp++;
	}

	if (c == 's' || c == 'u' || c == 'l' || c == 'e') {
		s = c;
		c = *cp++;
	} else {
		s = '\0';
	}

	t = NOTSPEC;

	switch (c) {
	case 'B':
		t = BOOL;
		break;
	case 'C':
		if (s == 's') {
			t = SCHAR;
		} else if (s == 'u') {
			t = UCHAR;
		} else if (s == '\0') {
			t = CHAR;
		}
		break;
	case 'S':
		if (s == 'u') {
			t = USHORT;
		} else if (s == '\0') {
			t = SHORT;
		}
		break;
	case 'I':
		if (s == 'u') {
			t = UINT;
		} else if (s == '\0') {
			t = INT;
		}
		break;
	case 'L':
		if (s == 'u') {
			t = ULONG;
		} else if (s == '\0') {
			t = LONG;
		}
		break;
	case 'Q':
		if (s == 'u') {
			t = UQUAD;
		} else if (s == '\0') {
			t = QUAD;
		}
		break;
	case 'D':
		if (s == 's') {
			t = FLOAT;
		} else if (s == 'l') {
			t = LDOUBLE;
		} else if (s == '\0') {
			t = DOUBLE;
		}
		break;
	case 'X':
		if (s == 's') {
			t = COMPLEX;
		} else if (s == 'l') {
			t = LDCOMPLEX;
		} else if (s == '\0') {
			t = DCOMPLEX;
		}
		break;
	case 'J':
		if (s == 's') {
			t = IMAGINARY;
		} else if (s == 'l') {
			t = LDIMAGINARY;
		} else if (s == '\0') {
			t = DIMAGINARY;
		}
		break;
	case 'V':
		if (s == '\0')
			t = VOID;
		break;
	case 'P':
		if (s == '\0')
			t = PTR;
		break;
	case 'A':
		if (s == '\0')
			t = ARRAY;
		break;
	case 'F':
	case 'f':
		if (s == '\0')
			t = FUNC;
		break;
	case 'T':
		if (s == 'e') {
			t = ENUM;
		} else if (s == 's') {
			t = STRUCT;
		} else if (s == 'u') {
			t = UNION;
		}
		break;
	default:
		inperr();
	}

	if (t == NOTSPEC)
		inperr();

	switch (t) {
	case ARRAY:
		(void)strtol(cp, &eptr, 10);
		if (cp == eptr)
			inperr();
		cp = eptr;
		(void)gettlen(cp, &cp);
		break;
	case PTR:
		(void)gettlen(cp, &cp);
		break;
	case FUNC:
		c = *cp;
		if (isdigit((u_char)c)) {
			narg = (int)strtol(cp, &eptr, 10);
			cp = eptr;
			for (i = 0; i < narg; i++) {
				if (i == narg - 1 && *cp == 'E') {
					cp++;
				} else {
					(void)gettlen(cp, &cp);
				}
			}
		}
		(void)gettlen(cp, &cp);
		break;
	case ENUM:
	case STRUCT:
	case UNION:
		switch (*cp++) {
		case '0':
			break;
		case '1':
			(void)inpname(cp, &cp);
			break;
		case '2':
			(void)inpname(cp, &cp);
			break;
		default:
			inperr();
		}
		break;
		/* LINTED (enumeration value(s) not handled in switch) */
	}

	*epp = cp;
	return (cp - cp1);
}

/*
 * Search a type by it's type string.
 */
static u_short
findtype(const char *cp, size_t len, int h)
{
	thtab_t	*thte;

	for (thte = thtab[h]; thte != NULL; thte = thte->th_nxt) {
		if (strncmp(thte->th_name, cp, len) != 0)
			continue;
		if (thte->th_name[len] == '\0')
			return (thte->th_idx);
	}

	return (0);
}

/*
 * Store a type and it's type string so we can later share this type
 * if we read the same type string from the input file.
 */
static u_short
storetyp(type_t *tp, const char *cp, size_t len, int h)
{
	/* 0 ist reserved */
	static	u_int	tidx = 1;
	thtab_t	*thte;
	char	*name;

	if (tidx >= USHRT_MAX)
		errx(1, "sorry, too many types");

	if (tidx == tlstlen - 1) {
		tlst = xrealloc(tlst, (tlstlen * 2) * sizeof (type_t *));
		(void)memset(tlst + tlstlen, 0, tlstlen * sizeof (type_t *));
		tlstlen *= 2;
	}

	tlst[tidx] = tp;

	/* create a hash table entry */
	name = xalloc(len + 1);
	(void)memcpy(name, cp, len);
	name[len] = '\0';

	thte = xalloc(sizeof (thtab_t));
	thte->th_name = name;
	thte->th_idx = tidx;
	thte->th_nxt = thtab[h];
	thtab[h] = thte;

	return ((u_short)tidx++);
}

/*
 * Hash function for types
 */
static int
thash(const char *s, size_t len)
{
	u_int	v;

	v = 0;
	while (len-- != 0) {
		v = (v << sizeof (v)) + (u_char)*s++;
		v ^= v >> (sizeof (v) * CHAR_BIT - sizeof (v));
	}
	return (v % THSHSIZ2);
}

/*
 * Read a string enclosed by "". This string may contain quoted chars.
 */
static char *
inpqstrg(const char *src, const char **epp)
{
	char	*strg, *dst;
	size_t	slen;
	int	c;
	int	v;

	dst = strg = xmalloc(slen = 32);

	if ((c = *src++) != '"')
		inperr();
	if ((c = *src++) == '\0')
		inperr();

	while (c != '"') {
		if (c == '\\') {
			if ((c = *src++) == '\0')
				inperr();
			switch (c) {
			case 'n':
				c = '\n';
				break;
			case 't':
				c = '\t';
				break;
			case 'v':
				c = '\v';
				break;
			case 'b':
				c = '\b';
				break;
			case 'r':
				c = '\r';
				break;
			case 'f':
				c = '\f';
				break;
			case 'a':
				c = '\a';
				break;
			case '\\':
				c = '\\';
				break;
			case '"':
				c = '"';
				break;
			case '\'':
				c = '\'';
				break;
			case '0': case '1': case '2': case '3':
				v = (c - '0') << 6;
				if ((c = *src++) < '0' || c > '7')
					inperr();
				v |= (c - '0') << 3;
				if ((c = *src++) < '0' || c > '7')
					inperr();
				v |= c - '0';
				c = (u_char)v;
				break;
			default:
				inperr();
			}
		}
		/* keep space for trailing '\0' */
		if (dst - strg == slen - 1) {
			strg = xrealloc(strg, slen * 2);
			dst = strg + (slen - 1);
			slen *= 2;
		}
		*dst++ = (char)c;
		if ((c = *src++) == '\0')
			inperr();
	}
	*dst = '\0';

	*epp = src;
	return (strg);
}

/*
 * Read the name of a symbol in static memory.
 */
static const char *
inpname(const char *cp, const char **epp)
{
	static	char	*buf;
	static	size_t	blen = 0;
	size_t	len, i;
	char	*eptr, c;

	len = (int)strtol(cp, &eptr, 10);
	if (cp == eptr)
		inperr();
	cp = eptr;
	if (len + 1 > blen)
		buf = xrealloc(buf, blen = len + 1);
	for (i = 0; i < len; i++) {
		c = *cp++;
		if (!isalnum(c) && c != '_')
			inperr();
		buf[i] = c;
	}
	buf[i] = '\0';

	*epp = cp;
	return (buf);
}

/*
 * Return the index of a file name. If the name cannot be found, create
 * a new entry and return the index of the newly created entry.
 */
static int
getfnidx(const char *fn)
{
	int	i;

	/* 0 ist reserved */
	for (i = 1; fnames[i] != NULL; i++) {
		if (strcmp(fnames[i], fn) == 0)
			break;
	}
	if (fnames[i] != NULL)
		return (i);

	if (i == nfnames - 1) {
		fnames = xrealloc(fnames, (nfnames * 2) * sizeof (char *));
		(void)memset(fnames + nfnames, 0, nfnames * sizeof (char *));
		nfnames *= 2;
	}

	fnames[i] = xstrdup(fn);
	return (i);
}

/*
 * Separate symbols with static and external linkage.
 */
void
mkstatic(hte_t *hte)
{
	sym_t	*sym1, **symp, *sym;
	fcall_t	**callp, *call;
	usym_t	**usymp, *usym;
	hte_t	*nhte;
	int	ofnd;

	/* Look for first static definition */
	for (sym1 = hte->h_syms; sym1 != NULL; sym1 = sym1->s_nxt) {
		if (sym1->s_static)
			break;
	}
	if (sym1 == NULL)
		return;

	/* Do nothing if this name is used only in one translation unit. */
	ofnd = 0;
	for (sym = hte->h_syms; sym != NULL && !ofnd; sym = sym->s_nxt) {
		if (sym->s_pos.p_src != sym1->s_pos.p_src)
			ofnd = 1;
	}
	for (call = hte->h_calls; call != NULL && !ofnd; call = call->f_nxt) {
		if (call->f_pos.p_src != sym1->s_pos.p_src)
			ofnd = 1;
	}
	for (usym = hte->h_usyms; usym != NULL && !ofnd; usym = usym->u_nxt) {
		if (usym->u_pos.p_src != sym1->s_pos.p_src)
			ofnd = 1;
	}
	if (!ofnd) {
		hte->h_used = 1;
		/* errors about undef. static symbols are printed in lint1 */
		hte->h_def = 1;
		hte->h_static = 1;
		return;
	}

	/*
	 * Create a new hash table entry
	 *
	 * XXX this entry should be put at the beginning of the list to
	 * avoid to process the same symbol twice.
	 */
	for (nhte = hte; nhte->h_link != NULL; nhte = nhte->h_link) ;
	nhte->h_link = xalloc(sizeof (hte_t));
	memset(nhte->h_link, 0, sizeof (hte_t));
	nhte = nhte->h_link;
	nhte->h_name = hte->h_name;
	nhte->h_static = 1;
	nhte->h_used = 1;
	nhte->h_def = 1;	/* error in lint1 */
	nhte->h_lsym = &nhte->h_syms;
	nhte->h_lcall = &nhte->h_calls;
	nhte->h_lusym = &nhte->h_usyms;

	/*
	 * move all symbols used in this translation unit into the new
	 * hash table entry.
	 */
	for (symp = &hte->h_syms; (sym = *symp) != NULL; ) {
		if (sym->s_pos.p_src == sym1->s_pos.p_src) {
			sym->s_static = 1;
			(*symp) = sym->s_nxt;
			if (hte->h_lsym == &sym->s_nxt)
				hte->h_lsym = symp;
			sym->s_nxt = NULL;
			*nhte->h_lsym = sym;
			nhte->h_lsym = &sym->s_nxt;
		} else {
			symp = &sym->s_nxt;
		}
	}
	for (callp = &hte->h_calls; (call = *callp) != NULL; ) {
		if (call->f_pos.p_src == sym1->s_pos.p_src) {
			(*callp) = call->f_nxt;
			if (hte->h_lcall == &call->f_nxt)
				hte->h_lcall = callp;
			call->f_nxt = NULL;
			*nhte->h_lcall = call;
			nhte->h_lcall = &call->f_nxt;
		} else {
			callp = &call->f_nxt;
		}
	}
	for (usymp = &hte->h_usyms; (usym = *usymp) != NULL; ) {
		if (usym->u_pos.p_src == sym1->s_pos.p_src) {
			(*usymp) = usym->u_nxt;
			if (hte->h_lusym == &usym->u_nxt)
				hte->h_lusym = usymp;
			usym->u_nxt = NULL;
			*nhte->h_lusym = usym;
			nhte->h_lusym = &usym->u_nxt;
		} else {
			usymp = &usym->u_nxt;
		}
	}

	/* h_def must be recalculated for old hte */
	hte->h_def = nhte->h_def = 0;
	for (sym = hte->h_syms; sym != NULL; sym = sym->s_nxt) {
		if (sym->s_def == DEF || sym->s_def == TDEF) {
			hte->h_def = 1;
			break;
		}
	}

	mkstatic(hte);
}
@


1.12
log
@remove rcsids which escaped the purge of 2009
@
text
@d1 1
a1 1
/*	$OpenBSD: read.c,v 1.11 2011/03/15 21:59:27 espie Exp $	*/
@


1.11
log
@sanity check, prompted by common work with Florent Tribouilloy

ok deraadt@@, millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: read.c,v 1.10 2010/07/24 22:17:03 guenther Exp $	*/
a33 4

#ifndef lint
static char rcsid[] = "$OpenBSD: read.c,v 1.10 2010/07/24 22:17:03 guenther Exp $";
#endif
@


1.10
log
@Teach lint about C99's _Bool and _Complex, plus some related gcc
extensions: __real__ and __imag__ operators, the use of '~' for
complex conjugation, and 'i' or 'j' as a suffix for complex constants.
While this doesn't handle folding and overflow detection for complex
constants correctly, it's good enough to make it through libm...and
found several bugs once it could do so.

"no objections" miod@@, krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: read.c,v 1.9 2005/12/01 05:06:40 cloder Exp $	*/
d36 1
a36 1
static char rcsid[] = "$OpenBSD: read.c,v 1.9 2005/12/01 05:06:40 cloder Exp $";
d164 2
@


1.9
log
@Make lint quieter by only warning on "foo declared but never used or
defined" when foo is declared in the translation unit that lint is working
on.  This means that symbols that are declared in an included header file
don't get this warning, ever.
@
text
@d1 1
a1 1
/*	$OpenBSD: read.c,v 1.8 2005/11/30 18:47:10 deraadt Exp $	*/
d36 1
a36 1
static char rcsid[] = "$OpenBSD: read.c,v 1.8 2005/11/30 18:47:10 deraadt Exp $";
d520 3
d541 8
d663 3
d710 18
@


1.8
log
@spacing
@
text
@d1 1
a1 1
/*	$OpenBSD: read.c,v 1.7 2005/11/20 17:09:55 cloder Exp $	*/
d36 1
a36 1
static char rcsid[] = "$OpenBSD: read.c,v 1.7 2005/11/20 17:09:55 cloder Exp $";
d83 1
a83 1
static	int	csrcfile;
@


1.7
log
@KNF. OK kjell, millert
@
text
@d1 1
a1 1
/*	$OpenBSD: read.c,v 1.6 2003/11/08 19:17:29 jmc Exp $	*/
d36 1
a36 1
static char rcsid[] = "$OpenBSD: read.c,v 1.6 2003/11/08 19:17:29 jmc Exp $";
d135 1
a135 1
		        cline = -1;
d264 1
a264 1
	       c == 'z' || c == 'p' || c == 'n' || c == 's') {
d339 2
a340 2
	       c == 'r' || c == 'o' || c == 's' || c == 'v' ||
	       c == 'P' || c == 'S') {
@


1.6
log
@typos from Jonathon Gray;
@
text
@d1 1
a1 1
/*	$OpenBSD: read.c,v 1.5 2002/02/19 19:39:39 millert Exp $	*/
d36 1
a36 1
static char rcsid[] = "$OpenBSD: read.c,v 1.5 2002/02/19 19:39:39 millert Exp $";
d102 1
a102 2
readfile(name)
	const	char *name;
d204 1
a204 1
inperr()
d214 1
a214 2
setsrc(cp)
	const	char *cp;
d226 1
a226 3
setfnid(fid, cp)
	int	fid;
	const	char *cp;
d249 1
a249 3
funccall(posp, cp)
	pos_t	*posp;
	const	char *cp;
d325 1
a325 3
decldef(posp, cp)
	pos_t	*posp;
	const	char *cp;
d455 1
a455 3
usedsym(posp, cp)
	pos_t	*posp;
	const	char *cp;
d478 1
a478 2
inptype(cp, epp)
	const	char *cp, **epp;
d616 1
a616 2
gettlen(cp, epp)
	const	char *cp, **epp;
d784 1
a784 4
findtype(cp, len, h)
	const	char *cp;
	size_t	len;
	int	h;
d803 1
a803 5
storetyp(tp, cp, len, h)
	type_t	*tp;
	const	char *cp;
	size_t	len;
	int	h;
d839 1
a839 3
thash(s, len)
	const	char *s;
	size_t	len;
d855 1
a855 2
inpqstrg(src, epp)
	const	char *src, **epp;
d938 1
a938 2
inpname(cp, epp)
	const	char *cp, **epp;
d968 1
a968 2
getfnidx(fn)
	const	char *fn;
d994 1
a994 2
mkstatic(hte)
	hte_t	*hte;
@


1.5
log
@We live in an ANSI C world.  Remove lots of gratuitous #ifdef __STDC__ cruft.
@
text
@d1 1
a1 1
/*	$OpenBSD: read.c,v 1.4 2002/02/16 21:27:59 millert Exp $	*/
d36 1
a36 1
static char rcsid[] = "$OpenBSD: read.c,v 1.4 2002/02/16 21:27:59 millert Exp $";
d223 1
a223 1
 * associated file name. If neccessary, it creates a new lint2 file
@


1.4
log
@Part one of userland __P removal.  Done with a simple regexp with some minor hand editing to make comments line up correctly.  Another pass is forthcoming that handles the cases that could not be done automatically.
@
text
@d1 1
a1 1
/*	$OpenBSD: read.c,v 1.3 1998/07/29 03:14:54 millert Exp $	*/
d36 1
a36 1
static char rcsid[] = "$OpenBSD: read.c,v 1.3 1998/07/29 03:14:54 millert Exp $";
a902 1
#ifdef __STDC__
a903 3
#else
				c = '\013';
#endif
a914 1
#ifdef __STDC__
a915 3
#else
				c = '\007';
#endif
@


1.3
log
@fix some initialization; ITOH Yasufumi <yasufu-i@@is.aist-nara.ac.jp>
@
text
@d1 1
a1 1
/*	$OpenBSD: read.c,v 1.2 1996/06/26 05:44:26 deraadt Exp $	*/
d36 1
a36 1
static char rcsid[] = "$OpenBSD: read.c,v 1.2 1996/06/26 05:44:26 deraadt Exp $";
d86 14
a99 14
static	void	inperr __P((void));
static	void	setsrc __P((const char *));
static	void	setfnid __P((int, const char *));
static	void	funccall __P((pos_t *, const char *));
static	void	decldef __P((pos_t *, const char *));
static	void	usedsym __P((pos_t *, const char *));
static	u_short	inptype __P((const char *, const char **));
static	int	gettlen __P((const char *, const char **));
static	u_short	findtype __P((const char *, size_t, int));
static	u_short	storetyp __P((type_t *, const char *, size_t, int));
static	int	thash __P((const char *, size_t));
static	char	*inpqstrg __P((const char *, const char **));
static	const	char *inpname __P((const char *, const char **));
static	int	getfnidx __P((const char *));
@


1.2
log
@rcsid
@
text
@d1 1
a1 1
/*	$OpenBSD: read.c,v 1.2 1995/07/03 21:24:59 cgd Exp $	*/
d36 1
a36 1
static char rcsid[] = "$OpenBSD: read.c,v 1.2 1995/07/03 21:24:59 cgd Exp $";
d1073 1
@


1.1
log
@Initial revision
@
text
@d1 1
d36 1
a36 1
static char rcsid[] = "$NetBSD: read.c,v 1.2 1995/07/03 21:24:59 cgd Exp $";
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@
