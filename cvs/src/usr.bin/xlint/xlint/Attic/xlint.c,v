head	1.37;
access;
symbols
	OPENBSD_5_1_BASE:1.36
	OPENBSD_5_1:1.36.0.2
	OPENBSD_5_0:1.35.0.2
	OPENBSD_5_0_BASE:1.35
	OPENBSD_4_9:1.34.0.6
	OPENBSD_4_9_BASE:1.34
	OPENBSD_4_8:1.34.0.4
	OPENBSD_4_8_BASE:1.34
	OPENBSD_4_7:1.34.0.2
	OPENBSD_4_7_BASE:1.34
	OPENBSD_4_6:1.33.0.12
	OPENBSD_4_6_BASE:1.33
	OPENBSD_4_5:1.33.0.8
	OPENBSD_4_5_BASE:1.33
	OPENBSD_4_4:1.33.0.6
	OPENBSD_4_4_BASE:1.33
	OPENBSD_4_3:1.33.0.4
	OPENBSD_4_3_BASE:1.33
	OPENBSD_4_2:1.33.0.2
	OPENBSD_4_2_BASE:1.33
	OPENBSD_4_1:1.32.0.2
	OPENBSD_4_1_BASE:1.32
	OPENBSD_4_0:1.31.0.2
	OPENBSD_4_0_BASE:1.31
	OPENBSD_3_9:1.25.0.2
	OPENBSD_3_9_BASE:1.25
	OPENBSD_3_8:1.16.0.6
	OPENBSD_3_8_BASE:1.16
	OPENBSD_3_7:1.16.0.4
	OPENBSD_3_7_BASE:1.16
	OPENBSD_3_6:1.16.0.2
	OPENBSD_3_6_BASE:1.16
	OPENBSD_3_5:1.15.0.2
	OPENBSD_3_5_BASE:1.15
	OPENBSD_3_4:1.14.0.2
	OPENBSD_3_4_BASE:1.14
	OPENBSD_3_3:1.12.0.2
	OPENBSD_3_3_BASE:1.12
	OPENBSD_3_2:1.10.0.2
	OPENBSD_3_2_BASE:1.10
	OPENBSD_3_1:1.9.0.2
	OPENBSD_3_1_BASE:1.9
	OPENBSD_3_0:1.6.0.10
	OPENBSD_3_0_BASE:1.6
	OPENBSD_2_9_BASE:1.6
	OPENBSD_2_9:1.6.0.8
	OPENBSD_2_8:1.6.0.6
	OPENBSD_2_8_BASE:1.6
	OPENBSD_2_7:1.6.0.4
	OPENBSD_2_7_BASE:1.6
	OPENBSD_2_6:1.6.0.2
	OPENBSD_2_6_BASE:1.6
	OPENBSD_2_5:1.5.0.10
	OPENBSD_2_5_BASE:1.5
	OPENBSD_2_4:1.5.0.8
	OPENBSD_2_4_BASE:1.5
	OPENBSD_2_3:1.5.0.6
	OPENBSD_2_3_BASE:1.5
	OPENBSD_2_2:1.5.0.4
	OPENBSD_2_2_BASE:1.5
	OPENBSD_2_1:1.5.0.2
	OPENBSD_2_1_BASE:1.5
	OPENBSD_2_0:1.3.0.2
	OPENBSD_2_0_BASE:1.3
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.37
date	2012.04.08.16.27.00;	author jsg;	state dead;
branches;
next	1.36;

1.36
date	2011.09.21.18.08.07;	author jsg;	state Exp;
branches;
next	1.35;

1.35
date	2011.06.09.15.19.03;	author jsg;	state Exp;
branches;
next	1.34;

1.34
date	2010.02.03.20.46.31;	author miod;	state Exp;
branches;
next	1.33;

1.33
date	2007.03.20.16.16.44;	author jmc;	state Exp;
branches;
next	1.32;

1.32
date	2006.11.10.00.54.59;	author deraadt;	state Exp;
branches;
next	1.31;

1.31
date	2006.05.06.20.47.58;	author espie;	state Exp;
branches;
next	1.30;

1.30
date	2006.04.21.18.24.08;	author cloder;	state Exp;
branches;
next	1.29;

1.29
date	2006.04.18.22.34.17;	author cloder;	state Exp;
branches;
next	1.28;

1.28
date	2006.04.17.16.35.05;	author cloder;	state Exp;
branches;
next	1.27;

1.27
date	2006.03.08.07.18.51;	author moritz;	state Exp;
branches;
next	1.26;

1.26
date	2006.03.07.08.24.55;	author moritz;	state Exp;
branches;
next	1.25;

1.25
date	2005.12.10.17.51.50;	author cloder;	state Exp;
branches;
next	1.24;

1.24
date	2005.12.06.01.15.31;	author deraadt;	state Exp;
branches;
next	1.23;

1.23
date	2005.12.02.18.05.52;	author cloder;	state Exp;
branches;
next	1.22;

1.22
date	2005.12.02.09.07.10;	author grunk;	state Exp;
branches;
next	1.21;

1.21
date	2005.11.23.18.21.44;	author deraadt;	state Exp;
branches;
next	1.20;

1.20
date	2005.11.23.08.31.28;	author deraadt;	state Exp;
branches;
next	1.19;

1.19
date	2005.11.20.18.23.59;	author cloder;	state Exp;
branches;
next	1.18;

1.18
date	2005.11.20.17.42.50;	author deraadt;	state Exp;
branches;
next	1.17;

1.17
date	2005.11.20.17.09.55;	author cloder;	state Exp;
branches;
next	1.16;

1.16
date	2004.05.11.02.08.07;	author millert;	state Exp;
branches;
next	1.15;

1.15
date	2004.02.19.21.09.47;	author brad;	state Exp;
branches;
next	1.14;

1.14
date	2003.04.25.23.22.21;	author deraadt;	state Exp;
branches;
next	1.13;

1.13
date	2003.04.14.03.03.53;	author deraadt;	state Exp;
branches;
next	1.12;

1.12
date	2003.01.06.11.33.28;	author miod;	state Exp;
branches;
next	1.11;

1.11
date	2002.12.08.03.14.29;	author millert;	state Exp;
branches;
next	1.10;

1.10
date	2002.06.12.06.07.17;	author mpech;	state Exp;
branches;
next	1.9;

1.9
date	2002.03.14.06.51.42;	author mpech;	state Exp;
branches;
next	1.8;

1.8
date	2002.02.16.21.27.59;	author millert;	state Exp;
branches;
next	1.7;

1.7
date	2001.11.05.09.42.28;	author deraadt;	state Exp;
branches;
next	1.6;

1.6
date	99.05.26.16.04.40;	author espie;	state Exp;
branches;
next	1.5;

1.5
date	97.04.04.18.41.36;	author deraadt;	state Exp;
branches;
next	1.4;

1.4
date	96.11.13.17.43.48;	author michaels;	state Exp;
branches;
next	1.3;

1.3
date	96.06.26.05.44.31;	author deraadt;	state Exp;
branches;
next	1.2;

1.2
date	95.12.14.03.11.42;	author deraadt;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.47.04;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.47.04;	author deraadt;	state Exp;
branches;
next	;


desc
@@


1.37
log
@tedu lint
ok tedu@@ guenther@@ krw@@ espie@@ deraadt@@
@
text
@/*	$OpenBSD: xlint.c,v 1.36 2011/09/21 18:08:07 jsg Exp $	*/
/*	$NetBSD: xlint.c,v 1.3 1995/10/23 14:29:30 jpo Exp $	*/

/*
 * Copyright (c) 1994, 1995 Jochen Pohl
 * All Rights Reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *      This product includes software developed by Jochen Pohl for
 *	The NetBSD Project.
 * 4. The name of the author may not be used to endorse or promote products
 *    derived from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
 * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
 * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

#include <sys/param.h>
#include <sys/wait.h>
#include <sys/stat.h>
#include <sys/utsname.h>
#include <stdio.h>
#include <stdlib.h>
#include <signal.h>
#include <string.h>
#include <unistd.h>
#include <fcntl.h>
#include <err.h>
#include <errno.h>
#include <paths.h>

#include "lint.h"
#include "pathnames.h"

/* directory for temporary files */
static	const	char *tmpdir;

/* path name for cpp output */
static	char	*cppout;

/* files created by 1st pass */
static	char	**p1out;

/* input files for 2nd pass (without libraries) */
static	char	**p2in;

/* library which will be created by 2nd pass */
static	char	*p2out;

/* flags always passed to cpp */
static	char	**cppflags;

/* flags for cpp, controled by sflag/tflag */
static	char	**lcppflgs;

/* flags for lint1 */
static	char	**l1flags;

/* flags for lint2 */
static	char	**l2flags;

/* libraries for lint2 */
static	char	**l2libs;

/* default libraries */
static	char	**deflibs;

/* additional libraries */
static	char	**libs;

/* search path for libraries */
static	char	**libsrchpath;

/* flags */
static	int	iflag, oflag, Cflag, sflag, tflag, Fflag = 1;

/* print the commands executed to run the stages of compilation */
static	int	Vflag;

/* filename for oflag */
static	char	*outputfn;

/* reset after first .c source has been processed */
static	int	first = 1;

/*
 * name of a file which is currently written by a child and should
 * be removed after abnormal termination of the child
 */
static	const	char *currfn;

static	void	appstrg(char ***, char *);
static	void	appcstrg(char ***, const char *);
static	void	applst(char ***, char *const *);
static	void	freelst(char ***);
static	char	*concat2(const char *, const char *);
static	char	*concat3(const char *, const char *, const char *);
static	void	terminate(int);
static	const	char *lbasename(const char *, int);
static	void	appdef(char ***, const char *);
static	void	usage(void);
static	void	fname(const char *);
static	int	runchild(const char *, char *const *, const char *);
static	void	findlibs(char *const *);
static	int	rdok(const char *);
static	void	lint2(void);
static	void	cat(char *const *, const char *);

/*
 * Some functions to deal with lists of strings.
 * Take care that we get no surprises in case of asynchronous signals.
 */
static void
appstrg(char ***lstp, char *s)
{
	char	**lst, **olst;
	int	i;

	olst = *lstp;
	for (i = 0; olst[i] != NULL; i++) ;
	lst = xmalloc((i + 2) * sizeof (char *));
	(void)memcpy(lst, olst, i * sizeof (char *));
	lst[i] = s;
	lst[i + 1] = NULL;
	*lstp = lst;
}

static void
appcstrg(char ***lstp, const char *s)
{
	appstrg(lstp, xstrdup(s));
}

static void
applst(char ***destp, char *const *src)
{
	int	i, k;
	char	**dest, **odest;

	odest = *destp;
	for (i = 0; odest[i] != NULL; i++) ;
	for (k = 0; src[k] != NULL; k++) ;
	dest = xmalloc((i + k + 1) * sizeof (char *));
	(void)memcpy(dest, odest, i * sizeof (char *));
	for (k = 0; src[k] != NULL; k++)
		dest[i + k] = xstrdup(src[k]);
	dest[i + k] = NULL;
	*destp = dest;
	free(odest);
}

static void
freelst(char ***lstp)
{
	char	*s;
	int	i;

	for (i = 0; (*lstp)[i] != NULL; i++) ;
	while (i-- > 0) {
		s = (*lstp)[i];
		(*lstp)[i] = NULL;
		free(s);
	}
}

static char *
concat2(const char *s1, const char *s2)
{
	char	*s;
	size_t len = strlen(s1) + strlen(s2) + 1;

	s = xmalloc(len);
	(void)strlcpy(s, s1, len);
	(void)strlcat(s, s2, len);

	return (s);
}

static char *
concat3(const char *s1, const char *s2, const char *s3)
{
	char	*s;
	size_t len = strlen(s1) + strlen(s2) + strlen(s3) + 1;

	s = xmalloc(len);
	(void)strlcpy(s, s1, len);
	(void)strlcat(s, s2, len);
	(void)strlcat(s, s3, len);

	return (s);
}

/*
 * Clean up after a signal.
 */
static void
terminate(int signo)
{
	int	i;

	if (cppout != NULL)
		(void)remove(cppout);

	if (p1out != NULL) {
		for (i = 0; p1out[i] != NULL; i++)
			(void)remove(p1out[i]);
	}

	if (p2out != NULL)
		(void)remove(p2out);

	if (currfn != NULL)
		(void)remove(currfn);

	_exit(signo != 0 ? 1 : 0);
}

/*
 * Returns a pointer to the last component of strg after delim.
 * Returns strg if the string does not contain delim.
 */
static const char *
lbasename(const char *strg, int delim)
{
	const	char *cp, *cp1, *cp2;

	cp = cp1 = cp2 = strg;
	while (*cp != '\0') {
		if (*cp++ == delim) {
			cp2 = cp1;
			cp1 = cp;
		}
	}
	return (*cp1 == '\0' ? cp2 : cp1);
}

static void
appdef(char ***lstp, const char *def)
{
	appstrg(lstp, concat2("-D__", def));
	appstrg(lstp, concat3("-D__", def, "__"));
}

static void
usage()
{
	(void)printf("usage: lint [-ceFfgHhprsVvxz] [-i | -nu] [-Dname[=def]] [-Idirectory]\n");
	(void)printf("\t[-Ldirectory] [-llibrary] [-ooutputfile] [-MD] [-Uname] file ...\n");
	(void)printf("       lint [-ceFfgHhprsVvz] -Clibrary [-Dname[=def]]\n");
	(void)printf("\t[-Idirectory] [-MD] [-Uname] file ...\n");
	terminate(-1);
}

int
main(int argc, char *argv[])
{
	int	c;
	int	fd;
	char	flgbuf[3], *tmp, *s;
	size_t	len;
	struct	utsname un;

	if ((tmp = getenv("TMPDIR")) == NULL || (len = strlen(tmp)) == 0) {
		tmpdir = xstrdup(_PATH_TMP);
	} else {
		s = xmalloc(len + 2);
		(void)snprintf(s, len + 2, "%s%s",
			tmp, tmp[len - 1] == '/' ? "" : "/");
		tmpdir = s;
	}

	if (asprintf(&cppout, "%slint0.XXXXXXXXXX", tmpdir) == -1)
		err(1, NULL);
	if ((fd = mkstemp(cppout)) == -1) {
		warn("can't make temp");
		terminate(-1);
	}
	close(fd);

	p1out = xcalloc(1, sizeof (char *));
	p2in = xcalloc(1, sizeof (char *));
	cppflags = xcalloc(1, sizeof (char *));
	lcppflgs = xcalloc(1, sizeof (char *));
	l1flags = xcalloc(1, sizeof (char *));
	l2flags = xcalloc(1, sizeof (char *));
	l2libs = xcalloc(1, sizeof (char *));
	deflibs = xcalloc(1, sizeof (char *));
	libs = xcalloc(1, sizeof (char *));
	libsrchpath = xcalloc(1, sizeof (char *));

	appcstrg(&cppflags, "-x");
	appcstrg(&cppflags, "c");
	appcstrg(&cppflags, "-undef");
	/* even with -undef cpp still identifies as GNUC */
	appcstrg(&cppflags, "-U__GNUC__");
#if defined(__GNUC__)
#if __GNUC__ < 3
	appcstrg(&cppflags, "-$");
	appcstrg(&cppflags, "-C");
#else
	appcstrg(&cppflags, "-CC");
#endif
#endif
	appcstrg(&cppflags, "-Wcomment");
	appcstrg(&cppflags, "-D__OpenBSD__");
	appcstrg(&cppflags, "-Dlint");		/* XXX don't def. with -s */
	appdef(&cppflags, "lint");
	appdef(&cppflags, "unix");

	if (uname(&un) == -1)
		err(1, "uname");
	appdef(&cppflags, un.machine);
	appstrg(&lcppflgs, concat2("-D", un.machine));

#ifdef MACHINE_ARCH
#ifdef MACHINE_CPU
	if (strcmp(MACHINE_ARCH, MACHINE_CPU) != 0) {
		appdef(&cppflags, MACHINE_CPU);
		appstrg(&lcppflgs, concat2("-D", MACHINE_CPU));
	}
#endif
	if (strcmp(un.machine, MACHINE_ARCH) != 0) {
		appdef(&cppflags, MACHINE_ARCH);
		appstrg(&lcppflgs, concat2("-D", MACHINE_ARCH));
	}
#endif

	appcstrg(&deflibs, "c");

	if (signal(SIGHUP, terminate) == SIG_IGN)
		(void)signal(SIGHUP, SIG_IGN);
	(void)signal(SIGINT, terminate);
	(void)signal(SIGQUIT, terminate);
	(void)signal(SIGTERM, terminate);

	while (argc > optind) {
		c = getopt(argc, argv, "abcefghil:no:prstuvxyzC:D:FHI:L:M:U:V");

		switch (c) {

		case 'a':
		case 'b':
		case 'c':
		case 'e':
		case 'f':
		case 'g':
		case 'r':
		case 'v':
		case 'y':
		case 'z':
			(void)snprintf(flgbuf, sizeof flgbuf, "-%c", c);
			appcstrg(&l1flags, flgbuf);
			break;

		case 'F':
			Fflag = 1;
			/* FALLTHROUGH */
		case 'u':
		case 'h':
			(void)snprintf(flgbuf, sizeof flgbuf, "-%c", c);
			appcstrg(&l1flags, flgbuf);
			appcstrg(&l2flags, flgbuf);
			break;

		case 'i':
			if (Cflag)
				usage();
			iflag = 1;
			break;

		case 'n':
			freelst(&deflibs);
			break;

		case 'p':
			appcstrg(&l1flags, "-p");
			appcstrg(&l2flags, "-p");
			if (*deflibs != NULL) {
				freelst(&deflibs);
				appcstrg(&deflibs, "c");
			}
			break;

		case 's':
			if (tflag)
				usage();
			freelst(&lcppflgs);
			appcstrg(&lcppflgs, "-trigraphs");
			appcstrg(&lcppflgs, "-Wtrigraphs");
			appcstrg(&lcppflgs, "-pedantic");
			appcstrg(&lcppflgs, "-D__STRICT_ANSI__");
			appcstrg(&l1flags, "-s");
			appcstrg(&l2flags, "-s");
			sflag = 1;
			break;

		case 't':
			if (sflag)
				usage();
			freelst(&lcppflgs);
			appcstrg(&lcppflgs, "-traditional");
			appstrg(&lcppflgs, concat2("-D", MACHINE));
			appstrg(&lcppflgs, concat2("-D", MACHINE_ARCH));
			appcstrg(&l1flags, "-t");
			appcstrg(&l2flags, "-t");
			tflag = 1;
			break;

		case 'x':
			appcstrg(&l2flags, "-x");
			break;

		case 'C':
			if (Cflag || oflag || iflag)
				usage();
			Cflag = 1;
			appstrg(&l2flags, concat2("-C", optarg));
			if (asprintf(&p2out, "llib-l%s.ln", optarg) == -1)
				err(1, NULL);
			freelst(&deflibs);
			break;

		case 'D':
		case 'I':
		case 'U':
			(void)snprintf(flgbuf, sizeof flgbuf, "-%c", c);
			appstrg(&cppflags, concat2(flgbuf, optarg));
			break;

		case 'l':
			appcstrg(&libs, optarg);
			break;

		case 'o':
			if (Cflag || oflag)
				usage();
			oflag = 1;
			outputfn = xstrdup(optarg);
			break;

		case 'L':
			appcstrg(&libsrchpath, optarg);
			break;

		case 'M':
			break;

		case 'H':
			appcstrg(&l2flags, "-H");
			break;

		case 'V':
			Vflag = 1;
			break;

		case '?':
			usage();
			/* NOTREACHED */

		case -1:
			/* filename */
			if (argv[optind] == NULL)
				break;
			fname(argv[optind++]);
			first = 0;
		}

	}
	argc -= optind;
	argv += optind;

	if (first)
		usage();

	if (iflag)
		terminate(0);

	if (!oflag) {
		if ((s = getenv("LIBDIR")) == NULL || strlen(s) == 0)
			s = PATH_LINTLIB;
		appcstrg(&libsrchpath, s);
		findlibs(libs);
		findlibs(deflibs);
	}

	(void)printf("Lint pass2:\n");
	lint2();

	if (oflag)
		cat(p2in, outputfn);

	if (Cflag)
		p2out = NULL;

	terminate(0);
	/* NOTREACHED */
}

/*
 * Read a file name from the command line
 * and pass it through lint1 if it is a C source.
 */
static void
fname(const char *name)
{
	const	char *bn, *suff;
	char	**args, *ofn, *path;
	size_t	len;
	int	error;
	int	fd;

	bn = lbasename(name, '/');
	suff = lbasename(bn, '.');

	if (strcmp(suff, "ln") == 0) {
		/* only for lint2 */
		if (!iflag)
			appcstrg(&p2in, name);
		return;
	}

	if (strcmp(suff, "c") != 0 &&
	    (strncmp(bn, "llib-l", 6) != 0 || bn != suff)) {
		warnx("unknown file type: %s", name);
		return;
	}

	/* build the name of the output file of lint1 */
	if (oflag) {
		ofn = outputfn;
		outputfn = NULL;
		oflag = 0;
	} else if (iflag) {
		len = strlen(bn) + (bn == suff ? 4 : 2);
		ofn = xmalloc(len);
		(void)snprintf(ofn, len, "%.*s",
		    bn == suff ? strlen(bn) : (suff - 1) - bn, bn);
		(void)strlcat(ofn, ".ln", len);
	} else {
		if (asprintf(&ofn, "%slint1.XXXXXXXXXX", tmpdir) == -1)
			err(1, NULL);
		if ((fd  = mkstemp(ofn)) == -1) {
			warn("can't make temp");
			terminate(-1);
		}
		close(fd);
	}
	if (!iflag)
		appcstrg(&p1out, ofn);

	args = xcalloc(1, sizeof (char *));

	/* run cpp */

	if (asprintf(&path, "%s/cpp", PATH_LIBEXEC) == -1)
		err(1, NULL);

	appcstrg(&args, path);
	applst(&args, cppflags);
	applst(&args, lcppflgs);
	appcstrg(&args, name);
	appcstrg(&args, cppout);

	error = runchild(path, args, cppout);
	free(path);
	freelst(&args);
	if (error)
		return;

	/* run lint1 */

	if (asprintf(&path, "%s/lint1", PATH_LIBEXEC) == -1)
		err(1, NULL);

	appcstrg(&args, path);
	applst(&args, l1flags);
	appcstrg(&args, cppout);
	appcstrg(&args, ofn);

	error = runchild(path, args, ofn);
	free(path);
	freelst(&args);
	if (error)
		return;

	appcstrg(&p2in, ofn);
	free(ofn);

	free(args);
}

static int
runchild(const char *path, char *const *args, const char *crfn)
{
	int	status, signo, i;
	pid_t	rv;

	if (Vflag) {
		for (i = 0; args[i] != NULL; i++)
			(void)printf("%s ", args[i]);
		(void)printf("\n");
	}

	currfn = crfn;

	(void)fflush(stdout);

	switch (fork()) {
	case -1:
		warn("cannot fork");
		terminate(-1);
		/* NOTREACHED */
	default:
		/* parent */
		break;
	case 0:
		/* child */
		(void)execv(path, args);
		warn("cannot exec %s", path);
		exit(1);
		/* NOTREACHED */
	}
	currfn = NULL;

	while ((rv = wait(&status)) == -1 && errno == EINTR) ;
	if (rv == -1) {
		warn("wait");
		return(-1);
	}
	if (WIFSIGNALED(status)) {
		signo = WTERMSIG(status);
		warnx("%s got SIG%s", path, sys_signame[signo]);
		return(-1);
	}
	if (WEXITSTATUS(status) != 0)
		return(-1);
	return(0);
}

static void
findlibs(char *const *liblst)
{
	int	i, k;
	const	char *lib, *path;
	char	*lfn;
	size_t	len, l;

	lfn = NULL;

	for (i = 0; (lib = liblst[i]) != NULL; i++) {
		for (k = 0; (path = libsrchpath[k]) != NULL; k++) {
			len = strlen(path) + strlen(lib);
			l = len + sizeof ("/llib-l.ln");
			lfn = xrealloc(lfn, l);
			(void)snprintf(lfn, l, "%s/llib-l%s.ln", path, lib);
			if (rdok(lfn))
				break;
			l = len + sizeof ("/lint/llib-l.ln");
			lfn = xrealloc(lfn, l);
			(void)snprintf(lfn, l, "%s/lint/llib-l%s.ln", path, lib);
			if (rdok(lfn))
				break;
		}
		if (path != NULL) {
			appstrg(&l2libs, concat2("-l", lfn));
		} else {
			warnx("cannot find llib-l%s.ln", lib);
		}
	}

	free(lfn);
}

static int
rdok(const char *path)
{
	struct	stat sbuf;

	if (stat(path, &sbuf) == -1)
		return (0);
	if ((sbuf.st_mode & S_IFMT) != S_IFREG)
		return (0);
	if (access(path, R_OK) == -1)
		return (0);
	return (1);
}

static void
lint2()
{
	char	*path, **args;

	args = xcalloc(1, sizeof (char *));

	if (asprintf(&path, "%s/lint2", PATH_LIBEXEC) == -1)
		err(1, NULL);

	appcstrg(&args, path);
	applst(&args, l2flags);
	applst(&args, l2libs);
	applst(&args, p2in);

	(void)runchild(path, args, p2out);
	free(path);
	freelst(&args);
	free(args);
}

static void
cat(char *const *srcs, const char *dest)
{
	int	ifd, ofd, i;
	char	*src, *buf;
	ssize_t	rlen;

	if ((ofd = open(dest, O_WRONLY | O_CREAT | O_TRUNC, 0666)) == -1) {
		warn("cannot open %s", dest);
		terminate(-1);
	}

	buf = xmalloc(MBLKSIZ);

	for (i = 0; (src = srcs[i]) != NULL; i++) {
		if ((ifd = open(src, O_RDONLY)) == -1) {
			free(buf);
			warn("cannot open %s", src);
			terminate(-1);
		}
		do {
			if ((rlen = read(ifd, buf, MBLKSIZ)) == -1) {
				free(buf);
				warn("read error on %s", src);
				terminate(-1);
			}
			if (write(ofd, buf, (size_t)rlen) == -1) {
				free(buf);
				warn("write error on %s", dest);
				terminate(-1);
			}
		} while (rlen == MBLKSIZ);
		(void)close(ifd);
	}
	(void)close(ofd);
	free(buf);
}

@


1.36
log
@remove rcsids which escaped the purge of 2009
@
text
@d1 1
a1 1
/*	$OpenBSD: xlint.c,v 1.35 2011/06/09 15:19:03 jsg Exp $	*/
@


1.35
log
@Accept and ignore -M so we can pass the same CPPFLAGS to lint and cpp.
Makes the kernel lint target work again.

ok martynas@@, with input from guenther@@
@
text
@d1 1
a1 1
/*	$OpenBSD: xlint.c,v 1.34 2010/02/03 20:46:31 miod Exp $	*/
a33 4

#ifndef lint
static char rcsid[] = "$OpenBSD: xlint.c,v 1.34 2010/02/03 20:46:31 miod Exp $";
#endif
@


1.34
log
@If MACHINE_CPU != MACHINE_ARCH, pass -D__${MACHINE_CPU}__ to the preprocessor.
ok kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: xlint.c,v 1.33 2007/03/20 16:16:44 jmc Exp $	*/
d36 1
a36 1
static char rcsid[] = "$OpenBSD: xlint.c,v 1.33 2007/03/20 16:16:44 jmc Exp $";
d269 1
a269 1
	(void)printf("\t[-Ldirectory] [-llibrary] [-ooutputfile] [-Uname] file ...\n");
d271 1
a271 1
	(void)printf("\t[-Idirectory] [-Uname] file ...\n");
d358 1
a358 1
		c = getopt(argc, argv, "abcefghil:no:prstuvxyzC:D:FHI:L:U:V");
d464 3
@


1.33
log
@sort options; sync synopsis and usage();
from Igor Sobrado
@
text
@d1 1
a1 1
/*	$OpenBSD: xlint.c,v 1.32 2006/11/10 00:54:59 deraadt Exp $	*/
d36 1
a36 1
static char rcsid[] = "$OpenBSD: xlint.c,v 1.32 2006/11/10 00:54:59 deraadt Exp $";
d337 6
@


1.32
log
@fix usage message
@
text
@d1 1
a1 1
/*	$OpenBSD: xlint.c,v 1.31 2006/05/06 20:47:58 espie Exp $	*/
d36 1
a36 1
static char rcsid[] = "$OpenBSD: xlint.c,v 1.31 2006/05/06 20:47:58 espie Exp $";
d268 4
a271 4
	(void)printf("usage: lint [-abceghprvxzHF] [-s|-t] [-i|-nu] [-Dname[=def]] [-Uname]\n");
	(void)printf("            [-Idirectory] [-Ldirectory] [-llibrary] [-ooutputfile] file ...\n");
	(void)printf("       lint [-abceghprvzHF] [-s|-t] -Clibrary [-Dname[=def]]\n");
	(void)printf("            [-Idirectory] [-Uname] file ...\n");
@


1.31
log
@use mkstemp, remove races wrt lint1 and cpp.
(check lint1 and cpp code, they use fopen/freopen to open that temp
file, and thus will happily overwrite a symlink)
okay cloder@@
@
text
@d1 1
a1 1
/*	$OpenBSD: xlint.c,v 1.30 2006/04/21 18:24:08 cloder Exp $	*/
d36 1
a36 1
static char rcsid[] = "$OpenBSD: xlint.c,v 1.30 2006/04/21 18:24:08 cloder Exp $";
d268 4
a271 5
	(void)printf("lint [-abceghprvxzHF] [-s|-t] [-i|-nu] [-Dname[=def]] [-Uname]\n");
	(void)printf("     [-Idirectory] [-Ldirectory] [-llibrary] [-ooutputfile] file ...\n");
	(void)printf("\n");
	(void)printf("lint [-abceghprvzHF] [-s|-t] -Clibrary [-Dname[=def]]\n");
	(void)printf("     [-Idirectory] [-Uname] file ...\n");
@


1.30
log
@On gcc3, specify -CC to the preprocessor (preserve comments even in macro
expansios).  On gcc 2.95, we can't do this yet because the preprocessor
support for -CC is not fully functional yet. OK deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: xlint.c,v 1.29 2006/04/18 22:34:17 cloder Exp $	*/
d36 1
a36 1
static char rcsid[] = "$OpenBSD: xlint.c,v 1.29 2006/04/18 22:34:17 cloder Exp $";
d280 1
d296 1
a296 1
	if (mktemp(cppout) == NULL) {
d300 1
d523 1
d555 1
a555 1
		if (mktemp(ofn) == NULL) {
d559 1
@


1.29
log
@Disable -CC to cpp until cpp 2.95 can handle it properly
@
text
@d1 1
a1 1
/*	$OpenBSD: xlint.c,v 1.28 2006/04/17 16:35:05 cloder Exp $	*/
d36 1
a36 1
static char rcsid[] = "$OpenBSD: xlint.c,v 1.28 2006/04/17 16:35:05 cloder Exp $";
d316 2
a317 1
#if defined(__GNUC__) && __GNUC__ < 3
d319 4
a323 1
	appcstrg(&cppflags, "-C");
@


1.28
log
@Pass -CC to cpp, which preserves comments in macros. This gets us __dead
code detection and later on, other things.
@
text
@d1 1
a1 1
/*	$OpenBSD: xlint.c,v 1.27 2006/03/08 07:18:51 moritz Exp $	*/
d36 1
a36 1
static char rcsid[] = "$OpenBSD: xlint.c,v 1.27 2006/03/08 07:18:51 moritz Exp $";
d319 1
a319 1
	appcstrg(&cppflags, "-CC");
@


1.27
log
@some cleanup including:

o typos in comments
o missing #include
o remove pointless nomem() func
o unused variables
o more use of asprintf(3)

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: xlint.c,v 1.26 2006/03/07 08:24:55 moritz Exp $	*/
d36 1
a36 1
static char rcsid[] = "$OpenBSD: xlint.c,v 1.26 2006/03/07 08:24:55 moritz Exp $";
d319 1
a319 1
	appcstrg(&cppflags, "-C");
@


1.26
log
@Fix NULL deref when doing `lint --'.
Successful build with i386 and sparc64.
@
text
@d1 1
a1 1
/*	$OpenBSD: xlint.c,v 1.25 2005/12/10 17:51:50 cloder Exp $	*/
d36 1
a36 1
static char rcsid[] = "$OpenBSD: xlint.c,v 1.25 2005/12/10 17:51:50 cloder Exp $";
a112 1

d281 1
a281 1
	size_t	len, l;
d293 2
a294 3
	len = strlen(tmpdir) + sizeof ("lint0.XXXXXXXXXX");
	cppout = xmalloc(len);
	(void)snprintf(cppout, len, "%slint0.XXXXXXXXXX", tmpdir);
d428 2
a429 3
			l = sizeof ("llib-l.ln") + strlen(optarg);
			p2out = xmalloc(l);
			(void)snprintf(p2out, l, "llib-l%s.ln", optarg);
d546 2
a547 3
		len = strlen(tmpdir) + sizeof ("lint1.XXXXXXXXXX");
		ofn = xmalloc(len);
		(void)snprintf(ofn, len, "%slint1.XXXXXXXXXX", tmpdir);
d560 2
a561 3
	len = strlen(PATH_LIBEXEC) + sizeof ("/cpp");
	path = xmalloc(len);
	(void)snprintf(path, len, "%s/cpp", PATH_LIBEXEC);
d577 2
a578 3
	len = strlen(PATH_LIBEXEC) + sizeof ("/lint1");
	path = xmalloc(len);
	(void)snprintf(path, len, "%s/lint1", PATH_LIBEXEC);
a696 1
	size_t len;
d700 2
a701 3
	len = strlen(PATH_LIBEXEC) + sizeof ("/lint2");
	path = xmalloc(len);
	(void)snprintf(path, len, "%s/lint2", PATH_LIBEXEC);
@


1.25
log
@Add a new lint flag '-f' which, for each warning or error, prints the
offending line from the corresponding source code file.  The general
idea is OK deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: xlint.c,v 1.24 2005/12/06 01:15:31 deraadt Exp $	*/
d36 1
a36 1
static char rcsid[] = "$OpenBSD: xlint.c,v 1.24 2005/12/06 01:15:31 deraadt Exp $";
d124 1
a124 1
static	void	fname(const char *, int);
d472 3
a474 1
			fname(argv[optind++], argc == 1);
d514 1
a514 1
fname(const char *name, int last)
@


1.24
log
@back out -CC change.  It breaks lint on most of our architectures
because -CC is something that showed up in a later gcc.
This is what happens when a pair of developers do not test on all
our architectures.
@
text
@d1 1
a1 1
/*	$OpenBSD: xlint.c,v 1.21 2005/11/23 18:21:44 deraadt Exp $	*/
d36 1
a36 1
static char rcsid[] = "$OpenBSD: xlint.c,v 1.23 2005/12/02 18:05:52 cloder Exp $";
d349 1
a349 1
		c = getopt(argc, argv, "abceghil:no:prstuvxyzC:D:FHI:L:U:V");
d357 1
@


1.23
log
@Add a -y option, undocumented for now, that tells lint to pass -y to lint1.
The -y option tells lint1 to output yacc debug information (if it was
compiled with YYDEBUG=1).
@
text
@d1 1
a1 1
/*	$OpenBSD: xlint.c,v 1.22 2005/12/02 09:07:10 grunk Exp $	*/
d36 1
a36 1
static char rcsid[] = "$OpenBSD: xlint.c,v 1.22 2005/12/02 09:07:10 grunk Exp $";
d321 1
a321 1
	appcstrg(&cppflags, "-CC");
@


1.22
log
@make lint invoke cpp with -CC instead of -C, which will cause comments
in #define macros to be preserved.  This makes way for addition of lint
statements to a lot of .h files.
ok cloder@@
@
text
@d1 1
a1 1
/*	$OpenBSD: xlint.c,v 1.21 2005/11/23 18:21:44 deraadt Exp $	*/
d36 1
a36 1
static char rcsid[] = "$OpenBSD: xlint.c,v 1.21 2005/11/23 18:21:44 deraadt Exp $";
d349 1
a349 1
		c = getopt(argc, argv, "abceghil:no:prstuvxzC:D:FHI:L:U:V");
d360 1
@


1.21
log
@adjust some default options (mostly, that lint always print full paths
in errors/warnings, so that compiling in dirs controlled by .PATH'd
Makefiles gives useful errors
@
text
@d1 1
a1 1
/*	$OpenBSD: xlint.c,v 1.20 2005/11/23 08:31:28 deraadt Exp $	*/
d36 1
a36 1
static char rcsid[] = "$OpenBSD: xlint.c,v 1.20 2005/11/23 08:31:28 deraadt Exp $";
d321 1
a321 1
	appcstrg(&cppflags, "-C");
@


1.20
log
@Do not pass -Wtraditional to cpp.  If someone wants that, they can
force that in other ways.  We want good lint messages, not cpp moaning
@
text
@d1 1
a1 1
/*	$OpenBSD: xlint.c,v 1.19 2005/11/20 18:23:59 cloder Exp $	*/
d36 1
a36 1
static char rcsid[] = "$OpenBSD: xlint.c,v 1.19 2005/11/20 18:23:59 cloder Exp $";
d96 1
a96 1
static	int	iflag, oflag, Cflag, sflag, tflag, Fflag;
a531 3

	if (!iflag || !first || !last)
		(void)printf("%s:\n", Fflag ? name : bn);
@


1.19
log
@Rename basename() to lbasename() to avoid conflict with basename(3).
@
text
@d1 1
a1 1
/*	$OpenBSD: xlint.c,v 1.18 2005/11/20 17:42:50 deraadt Exp $	*/
d36 1
a36 1
static char rcsid[] = "$OpenBSD: xlint.c,v 1.18 2005/11/20 17:42:50 deraadt Exp $";
a326 2

	appcstrg(&lcppflgs, "-Wtraditional");
@


1.18
log
@spacing
@
text
@d1 1
a1 1
/*	$OpenBSD: xlint.c,v 1.17 2005/11/20 17:09:55 cloder Exp $	*/
d36 1
a36 1
static char rcsid[] = "$OpenBSD: xlint.c,v 1.17 2005/11/20 17:09:55 cloder Exp $";
d121 1
a121 1
static	const	char *basename(const char *, int);
d245 1
a245 1
basename(const char *strg, int delim)
d519 2
a520 2
	bn = basename(name, '/');
	suff = basename(bn, '.');
@


1.17
log
@KNF. OK kjell, millert
@
text
@d1 1
a1 1
/*	$OpenBSD: xlint.c,v 1.16 2004/05/11 02:08:07 millert Exp $	*/
d36 1
a36 1
static char rcsid[] = "$OpenBSD: xlint.c,v 1.16 2004/05/11 02:08:07 millert Exp $";
d148 1
a148 1
}	
d341 1
a341 1
	
d711 1
a711 1
	
@


1.16
log
@Just because we get an error running a command doesn't mean that
lint should exit -- it may have other files to process.  Currently,
the exit code is not propagated up to lint's final call to terminate().
Requested by and OK deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: xlint.c,v 1.15 2004/02/19 21:09:47 brad Exp $	*/
d36 1
a36 1
static char rcsid[] = "$OpenBSD: xlint.c,v 1.15 2004/02/19 21:09:47 brad Exp $";
d136 1
a136 2
appstrg(lstp, s)
	char	***lstp, *s;
d151 1
a151 3
appcstrg(lstp, s)
	char	***lstp;
	const	char *s;
d157 1
a157 3
applst(destp, src)
	char	***destp;
	char	*const *src;
d175 1
a175 2
freelst(lstp)
	char	***lstp;
d189 1
a189 2
concat2(s1, s2)
	const	char *s1, *s2;
d202 1
a202 2
concat3(s1, s2, s3)
	const	char *s1, *s2, *s3;
d219 1
a219 2
terminate(signo)
	int	signo;
d245 1
a245 3
basename(strg, delim)
	const	char *strg;
	int	delim;
d260 1
a260 3
appdef(lstp, def)
	char	***lstp;
	const	char *def;
d278 1
a278 3
main(argc, argv)
	int	argc;
	char	*argv[];
d512 1
a512 3
fname(name, last)
	const	char *name;
	int	last;
d605 1
a605 3
runchild(path, args, crfn)
	const	char *path, *crfn;
	char	*const *args;
d653 1
a653 2
findlibs(liblst)
	char	*const *liblst;
d687 1
a687 2
rdok(path)
	const	char *path;
d724 1
a724 3
cat(srcs, dest)
	char	*const *srcs;
	const	char *dest;
@


1.15
log
@don't use -$ flag for cpp with gcc 3 and up

ok espie@@
@
text
@d1 1
a1 1
/*	$OpenBSD: xlint.c,v 1.14 2003/04/25 23:22:21 deraadt Exp $	*/
d36 1
a36 1
static char rcsid[] = "$OpenBSD: xlint.c,v 1.14 2003/04/25 23:22:21 deraadt Exp $";
d125 1
a125 1
static	void	runchild(const char *, char *const *, const char *);
d534 1
d592 1
a592 1
	runchild(path, args, cppout);
d595 2
d609 1
a609 1
	runchild(path, args, ofn);
d612 2
d621 1
a621 1
static void
d654 1
d659 1
a659 1
		terminate(-1);
d664 1
a664 1
		terminate(-1);
d667 2
a668 2
		terminate(-1);
	currfn = NULL;
d738 1
a738 1
	runchild(path, args, p2out);
@


1.14
log
@sprintf bye bye
@
text
@d1 1
a1 1
/*	$OpenBSD: xlint.c,v 1.13 2003/04/14 03:03:53 deraadt Exp $	*/
d36 1
a36 1
static char rcsid[] = "$OpenBSD: xlint.c,v 1.13 2003/04/14 03:03:53 deraadt Exp $";
d333 1
d335 1
@


1.13
log
@string cleaning; my bugs found by millert and krw
@
text
@d1 1
a1 1
/*	$OpenBSD: xlint.c,v 1.12 2003/01/06 11:33:28 miod Exp $	*/
d36 1
a36 1
static char rcsid[] = "$OpenBSD: xlint.c,v 1.12 2003/01/06 11:33:28 miod Exp $";
d297 1
a297 1
	size_t	len;
d443 3
a445 2
			p2out = xmalloc(sizeof ("llib-l.ln") + strlen(optarg));
			(void)sprintf(p2out, "llib-l%s.ln", optarg);
@


1.12
log
@syncronous -> synchronous
@
text
@d1 1
a1 1
/*	$OpenBSD: xlint.c,v 1.11 2002/12/08 03:14:29 millert Exp $	*/
d36 1
a36 1
static char rcsid[] = "$OpenBSD: xlint.c,v 1.11 2002/12/08 03:14:29 millert Exp $";
d199 1
d201 3
a203 3
	s = xmalloc(strlen(s1) + strlen(s2) + 1);
	(void)strcpy(s, s1);
	(void)strcat(s, s2);
d213 1
d215 4
a218 4
	s = xmalloc(strlen(s1) + strlen(s2) + strlen(s3) + 1);
	(void)strcpy(s, s1);
	(void)strcat(s, s2);
	(void)strcat(s, s3);
d304 2
a305 1
		(void)sprintf(s, "%s%s", tmp, tmp[len - 1] == '/' ? "" : "/");
d309 3
a311 2
	cppout = xmalloc(strlen(tmpdir) + sizeof ("lint0.XXXXXXXXXX"));
	(void)sprintf(cppout, "%slint0.XXXXXXXXXX", tmpdir);
d376 1
a376 1
			(void)sprintf(flgbuf, "-%c", c);
d385 1
a385 1
			(void)sprintf(flgbuf, "-%c", c);
d451 1
a451 1
			(void)sprintf(flgbuf, "-%c", c);
d557 5
a561 4
		ofn = xmalloc(strlen(bn) + (bn == suff ? 4 : 2));
		len = bn == suff ? strlen(bn) : (suff - 1) - bn;
		(void)sprintf(ofn, "%.*s", (int)len, bn);
		(void)strcat(ofn, ".ln");
d563 3
a565 2
		ofn = xmalloc(strlen(tmpdir) + sizeof ("lint1.XXXXXXXXXX"));
		(void)sprintf(ofn, "%slint1.XXXXXXXXXX", tmpdir);
d578 3
a580 2
	path = xmalloc(strlen(PATH_LIBEXEC) + sizeof ("/cpp"));
	(void)sprintf(path, "%s/cpp", PATH_LIBEXEC);
d594 3
a596 2
	path = xmalloc(strlen(PATH_LIBEXEC) + sizeof ("/lint1"));
	(void)sprintf(path, "%s/lint1", PATH_LIBEXEC);
d669 1
a669 1
	size_t	len;
d676 3
a678 2
			lfn = xrealloc(lfn, len + sizeof ("/llib-l.ln"));
			(void)sprintf(lfn, "%s/llib-l%s.ln", path, lib);
d681 3
a683 2
			lfn = xrealloc(lfn, len + sizeof ("/lint/llib-l.ln"));
			(void)sprintf(lfn, "%s/lint/llib-l%s.ln", path, lib);
d716 1
d720 3
a722 2
	path = xmalloc(strlen(PATH_LIBEXEC) + sizeof ("/lint2"));
	(void)sprintf(path, "%s/lint2", PATH_LIBEXEC);
@


1.11
log
@Avoid using "optind = 0" since its meaning to getopt() is implementation
dependent (and there is no good reason to use it in this case anyway).
@
text
@d1 1
a1 1
/*	$OpenBSD: xlint.c,v 1.10 2002/06/12 06:07:17 mpech Exp $	*/
d36 1
a36 1
static char rcsid[] = "$OpenBSD: xlint.c,v 1.10 2002/06/12 06:07:17 mpech Exp $";
d133 1
a133 1
 * Take care that we get no surprises in case of asyncron signals.
@


1.10
log
@a real pid_t cleanup.

espie@@ ok for make/,
deraadt@@ one extra eye,
millert@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: xlint.c,v 1.9 2002/03/14 06:51:42 mpech Exp $	*/
d36 1
a36 1
static char rcsid[] = "$OpenBSD: xlint.c,v 1.9 2002/03/14 06:51:42 mpech Exp $";
a359 5

		argc -= optind;
		argv += optind;
		optind = 0;

d480 1
a480 1
			fname(argv[0], argc == 1);
a481 1
			optind = 1;
d485 2
@


1.9
log
@Remove \n from err/errx/warn/warnx().

millert@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: xlint.c,v 1.8 2002/02/16 21:27:59 millert Exp $	*/
d36 1
a36 1
static char rcsid[] = "$OpenBSD: xlint.c,v 1.8 2002/02/16 21:27:59 millert Exp $";
d614 2
a615 1
	int	status, rv, signo, i;
@


1.8
log
@Part one of userland __P removal.  Done with a simple regexp with some minor hand editing to make comments line up correctly.  Another pass is forthcoming that handles the cases that could not be done automatically.
@
text
@d1 1
a1 1
/*	$OpenBSD: xlint.c,v 1.7 2001/11/05 09:42:28 deraadt Exp $	*/
d36 1
a36 1
static char rcsid[] = "$OpenBSD: xlint.c,v 1.7 2001/11/05 09:42:28 deraadt Exp $";
d544 1
a544 1
		warnx("unknown file type: %s\n", name);
@


1.7
log
@use _exit in signal handler
@
text
@d1 1
a1 1
/*	$OpenBSD: xlint.c,v 1.6 1999/05/26 16:04:40 espie Exp $	*/
d36 1
a36 1
static char rcsid[] = "$OpenBSD: xlint.c,v 1.6 1999/05/26 16:04:40 espie Exp $";
d114 16
a129 16
static	void	appstrg __P((char ***, char *));
static	void	appcstrg __P((char ***, const char *));
static	void	applst __P((char ***, char *const *));
static	void	freelst __P((char ***));
static	char	*concat2 __P((const char *, const char *));
static	char	*concat3 __P((const char *, const char *, const char *));
static	void	terminate __P((int));
static	const	char *basename __P((const char *, int));
static	void	appdef __P((char ***, const char *));
static	void	usage __P((void));
static	void	fname __P((const char *, int));
static	void	runchild __P((const char *, char *const *, const char *));
static	void	findlibs __P((char *const *));
static	int	rdok __P((const char *));
static	void	lint2 __P((void));
static	void	cat __P((char *const *, const char *));
@


1.6
log
@Slight tweaks to account for the new cpp driver.
@
text
@d1 1
a1 1
/*	$OpenBSD: xlint.c,v 1.5 1997/04/04 18:41:36 deraadt Exp $	*/
d36 1
a36 1
static char rcsid[] = "$OpenBSD: xlint.c,v 1.5 1997/04/04 18:41:36 deraadt Exp $";
d244 1
a244 1
	exit(signo != 0 ? 1 : 0);
@


1.5
log
@when mktemp() is hard to fix, use 10 X
@
text
@d1 1
a1 1
/*	$OpenBSD: xlint.c,v 1.4 1996/11/13 17:43:48 michaels Exp $	*/
d36 1
a36 1
static char rcsid[] = "$OpenBSD: xlint.c,v 1.4 1996/11/13 17:43:48 michaels Exp $";
d324 2
a325 1
	appcstrg(&cppflags, "-lang-c");
d327 2
@


1.4
log
@lint should pass on __OpenBSD__ rather than __NetBSD__.
@
text
@d1 1
a1 1
/*	$OpenBSD: xlint.c,v 1.3 1995/10/23 14:29:30 jpo Exp $	*/
d36 1
a36 1
static char rcsid[] = "$OpenBSD: xlint.c,v 1.3 1995/10/23 14:29:30 jpo Exp $";
d306 2
a307 2
	cppout = xmalloc(strlen(tmpdir) + sizeof ("lint0.XXXXXX"));
	(void)sprintf(cppout, "%slint0.XXXXXX", tmpdir);
d559 2
a560 2
		ofn = xmalloc(strlen(tmpdir) + sizeof ("lint1.XXXXXX"));
		(void)sprintf(ofn, "%slint1.XXXXXX", tmpdir);
@


1.3
log
@rcsid
@
text
@d329 1
a329 1
	appcstrg(&cppflags, "-D__NetBSD__");
@


1.2
log
@update from netbsd
@
text
@d1 1
d36 1
a36 1
static char rcsid[] = "$NetBSD: xlint.c,v 1.3 1995/10/23 14:29:30 jpo Exp $";
@


1.1
log
@Initial revision
@
text
@d1 1
a1 1
/*	$NetBSD: xlint.c,v 1.2 1995/07/03 21:25:23 cgd Exp $	*/
d35 1
a35 1
static char rcsid[] = "$NetBSD: xlint.c,v 1.2 1995/07/03 21:25:23 cgd Exp $";
d38 1
a38 1
#include <sys/types.h>
d41 1
d113 2
a114 2
static	void	appstrg __P((char ***, const char *));
static	void	app2strg __P((char ***, const char *, const char *));
d117 2
d121 1
d136 1
a136 2
	char	***lstp;
	const	char *s;
d145 1
a145 1
	lst[i] = xstrdup(s);
d148 1
a148 2
	free(olst);
}
d151 1
a151 1
app2strg(lstp, s1, s2)
d153 1
a153 1
	const	char *s1, *s2;
d155 1
a155 15
	int	i;
	char	*s, **lst, **olst;

	s = xmalloc(strlen(s1) + strlen(s2) + 1);
	(void)strcpy(s, s1);
	(void)strcat(s, s2);

	olst = *lstp;
	for (i = 0; olst[i] != NULL; i++) ;
	lst = xmalloc((i + 2) * sizeof (char *));
	(void)memcpy(lst, olst, i * sizeof (char *));
	lst[i] = s;
	lst[i + 1] = NULL;
	*lstp = lst;
	free(olst);
d193 27
d268 9
d295 1
d323 25
a347 8
	appstrg(&cppflags, "-C");
	appstrg(&cppflags, "-Dlint");
	appstrg(&cppflags, "-U__GNUC__");
	appstrg(&cppflags, "-Wcomment");

	appstrg(&lcppflgs, "-Wtraditional");

	appstrg(&deflibs, "c");
d374 1
a374 1
			appstrg(&l1flags, flgbuf);
d383 2
a384 2
			appstrg(&l1flags, flgbuf);
			appstrg(&l2flags, flgbuf);
d398 2
a399 2
			appstrg(&l1flags, "-p");
			appstrg(&l2flags, "-p");
d402 1
a402 1
				appstrg(&deflibs, "c");
d410 6
a415 5
			appstrg(&lcppflgs, "-trigraphs");
			appstrg(&lcppflgs, "-Wtrigraphs");
			appstrg(&lcppflgs, "-pedantic");
			appstrg(&l1flags, "-s");
			appstrg(&l2flags, "-s");
d423 5
a427 3
			appstrg(&lcppflgs, "-traditional");
			appstrg(&l1flags, "-t");
			appstrg(&l2flags, "-t");
d432 1
a432 1
			appstrg(&l2flags, "-x");
d439 1
a439 1
			app2strg(&l2flags, "-C", optarg);
d449 1
a449 1
			app2strg(&cppflags, flgbuf, optarg);
d453 1
a453 1
			appstrg(&libs, optarg);
d464 1
a464 1
			appstrg(&libsrchpath, optarg);
d468 1
a468 1
			appstrg(&l2flags, "-H");
d497 1
a497 1
		appstrg(&libsrchpath, s);
d534 1
a534 1
			appstrg(&p2in, name);
d566 1
a566 1
		appstrg(&p1out, ofn);
d572 1
a572 1
	path = xmalloc(sizeof (PATH_LIBEXEC) + sizeof ("cpp"));
d575 1
a575 1
	appstrg(&args, path);
d578 2
a579 2
	appstrg(&args, name);
	appstrg(&args, cppout);
d587 1
a587 1
	path = xmalloc(sizeof (PATH_LIBEXEC) + sizeof ("lint1"));
d590 1
a590 1
	appstrg(&args, path);
d592 2
a593 2
	appstrg(&args, cppout);
	appstrg(&args, ofn);
d599 1
a599 1
	appstrg(&p2in, ofn);
d677 1
a677 1
			app2strg(&l2libs, "-l", lfn);
d708 1
a708 1
	path = xmalloc(sizeof (PATH_LIBEXEC) + sizeof ("lint2"));
d711 1
a711 1
	appstrg(&args, path);
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@
