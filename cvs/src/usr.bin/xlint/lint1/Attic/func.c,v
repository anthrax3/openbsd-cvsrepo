head	1.23;
access;
symbols
	OPENBSD_5_1_BASE:1.22
	OPENBSD_5_1:1.22.0.2
	OPENBSD_5_0:1.21.0.2
	OPENBSD_5_0_BASE:1.21
	OPENBSD_4_9:1.20.0.14
	OPENBSD_4_9_BASE:1.20
	OPENBSD_4_8:1.20.0.12
	OPENBSD_4_8_BASE:1.20
	OPENBSD_4_7:1.20.0.8
	OPENBSD_4_7_BASE:1.20
	OPENBSD_4_6:1.20.0.10
	OPENBSD_4_6_BASE:1.20
	OPENBSD_4_5:1.20.0.6
	OPENBSD_4_5_BASE:1.20
	OPENBSD_4_4:1.20.0.4
	OPENBSD_4_4_BASE:1.20
	OPENBSD_4_3:1.20.0.2
	OPENBSD_4_3_BASE:1.20
	OPENBSD_4_2:1.18.0.6
	OPENBSD_4_2_BASE:1.18
	OPENBSD_4_1:1.18.0.4
	OPENBSD_4_1_BASE:1.18
	OPENBSD_4_0:1.18.0.2
	OPENBSD_4_0_BASE:1.18
	OPENBSD_3_9:1.10.0.2
	OPENBSD_3_9_BASE:1.10
	OPENBSD_3_8:1.5.0.6
	OPENBSD_3_8_BASE:1.5
	OPENBSD_3_7:1.5.0.4
	OPENBSD_3_7_BASE:1.5
	OPENBSD_3_6:1.5.0.2
	OPENBSD_3_6_BASE:1.5
	OPENBSD_3_5:1.4.0.10
	OPENBSD_3_5_BASE:1.4
	OPENBSD_3_4:1.4.0.8
	OPENBSD_3_4_BASE:1.4
	OPENBSD_3_3:1.4.0.6
	OPENBSD_3_3_BASE:1.4
	OPENBSD_3_2:1.4.0.4
	OPENBSD_3_2_BASE:1.4
	OPENBSD_3_1:1.4.0.2
	OPENBSD_3_1_BASE:1.4
	OPENBSD_3_0:1.3.0.8
	OPENBSD_3_0_BASE:1.3
	OPENBSD_2_9_BASE:1.3
	OPENBSD_2_9:1.3.0.6
	OPENBSD_2_8:1.3.0.4
	OPENBSD_2_8_BASE:1.3
	OPENBSD_2_7:1.3.0.2
	OPENBSD_2_7_BASE:1.3
	OPENBSD_2_6:1.2.0.14
	OPENBSD_2_6_BASE:1.2
	OPENBSD_2_5:1.2.0.12
	OPENBSD_2_5_BASE:1.2
	OPENBSD_2_4:1.2.0.10
	OPENBSD_2_4_BASE:1.2
	OPENBSD_2_3:1.2.0.8
	OPENBSD_2_3_BASE:1.2
	OPENBSD_2_2:1.2.0.6
	OPENBSD_2_2_BASE:1.2
	OPENBSD_2_1:1.2.0.4
	OPENBSD_2_1_BASE:1.2
	OPENBSD_2_0:1.2.0.2
	OPENBSD_2_0_BASE:1.2
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.23
date	2012.04.08.16.27.00;	author jsg;	state dead;
branches;
next	1.22;

1.22
date	2011.09.21.18.08.07;	author jsg;	state Exp;
branches;
next	1.21;

1.21
date	2011.05.30.15.15.58;	author martynas;	state Exp;
branches;
next	1.20;

1.20
date	2007.10.17.20.10.44;	author chl;	state Exp;
branches;
next	1.19;

1.19
date	2007.09.06.22.02.03;	author cloder;	state Exp;
branches;
next	1.18;

1.18
date	2006.05.29.20.47.22;	author cloder;	state Exp;
branches;
next	1.17;

1.17
date	2006.05.28.23.50.54;	author cloder;	state Exp;
branches;
next	1.16;

1.16
date	2006.04.26.15.57.41;	author cloder;	state Exp;
branches;
next	1.15;

1.15
date	2006.04.21.02.38.36;	author cloder;	state Exp;
branches;
next	1.14;

1.14
date	2006.04.20.16.29.48;	author cloder;	state Exp;
branches;
next	1.13;

1.13
date	2006.04.20.03.40.29;	author cloder;	state Exp;
branches;
next	1.12;

1.12
date	2006.04.18.02.59.40;	author cloder;	state Exp;
branches;
next	1.11;

1.11
date	2006.03.13.21.12.32;	author moritz;	state Exp;
branches;
next	1.10;

1.10
date	2005.12.17.21.08.27;	author cloder;	state Exp;
branches;
next	1.9;

1.9
date	2005.12.17.20.19.46;	author cloder;	state Exp;
branches;
next	1.8;

1.8
date	2005.11.29.19.38.09;	author cloder;	state Exp;
branches;
next	1.7;

1.7
date	2005.11.29.03.40.56;	author cloder;	state Exp;
branches;
next	1.6;

1.6
date	2005.11.19.03.35.27;	author cloder;	state Exp;
branches;
next	1.5;

1.5
date	2004.05.10.15.26.22;	author deraadt;	state Exp;
branches;
next	1.4;

1.4
date	2001.11.18.20.55.42;	author deraadt;	state Exp;
branches;
next	1.3;

1.3
date	99.10.29.09.01.00;	author todd;	state Exp;
branches;
next	1.2;

1.2
date	96.06.26.05.44.13;	author deraadt;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.47.02;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.47.02;	author deraadt;	state Exp;
branches;
next	;


desc
@@


1.23
log
@tedu lint
ok tedu@@ guenther@@ krw@@ espie@@ deraadt@@
@
text
@/*	$OpenBSD: func.c,v 1.22 2011/09/21 18:08:07 jsg Exp $	*/
/*	$NetBSD: func.c,v 1.7 1995/10/02 17:31:40 jpo Exp $	*/

/*
 * Copyright (c) 1994, 1995 Jochen Pohl
 * All Rights Reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *      This product includes software developed by Jochen Pohl for
 *	The NetBSD Project.
 * 4. The name of the author may not be used to endorse or promote products
 *    derived from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
 * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
 * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

#include <stdlib.h>
#include <string.h>

#include "lint1.h"
#include "y.tab.h"

/*
 * Contains a pointer to the symbol table entry of the current function
 * definition.
 */
sym_t	*funcsym;

/* Is set as long as a statement can be reached. Must be set at level 0. */
int	reached = 1;

/*
 * Is set as long as NOTREACHED is in effect.
 * Is reset everywhere where reached can become 0.
 */
int	rchflg;

/*
 * In conjunction with reached controls printing of "fallthrough on ..."
 * warnings.
 * Reset by each statement and set by FALLTHROUGH, switch (switch1())
 * and case (label()).
 *
 * Control statements if, for, while and switch do not reset ftflg because
 * this must be done by the controled statement. At least for if this is
 * important because ** FALLTHROUGH ** after "if (expr) stmnt" is evaluated
 * befor the following token, wich causes reduction of above, is read.
 * This means that ** FALLTHROUGH ** after "if ..." would always be ignored.
 */
int	ftflg;

/* Top element of stack for control statements */
cstk_t	*cstk;

/*
 * Number of arguments which will be checked for usage in following
 * function definition. -1 stands for all arguments.
 *
 * The position of the last ARGSUSED comment is stored in aupos.
 */
int	nargusg = -1;
pos_t	aupos;

/*
 * If the following function has been declared NORETURN, noretflg is set
 * to 1. Otherwise it is set to 0.
 */
int	noretflg = 0;

/*
 * If the following symbol should be marked as having been used, even if
 * lint thinks otherwise, usedflg is set to 1. Otherwise it is set to 0.
 */
int	usedflg = 0;

/*
 * Number of arguments of the following function definition whose types
 * shall be checked by lint2. -1 stands for all arguments.
 *
 * The position of the last VARARGS comment is stored in vapos.
 */
int	nvararg = -1;
pos_t	vapos;

/*
 * Both prflstr and scflstrg contain the number of the argument which
 * shall be used to check the types of remaining arguments (for PRINTFLIKE
 * and SCANFLIKE).
 *
 * prflpos and scflpos are the positions of the last PRINTFLIKE or
 * SCANFLIKE comment.
 */
int	prflstrg = -1;
int	scflstrg = -1;
pos_t	prflpos;
pos_t	scflpos;

/*
 * Are both plibflg and llibflg set, prototypes are written as function
 * definitions to the output file.
 */
int	plibflg;

/*
 * Nonzero means that no warnings about constants in conditional
 * context are printed.
 */
int	ccflg;

/*
 * llibflg is set if a lint library shall be created. The effect of
 * llibflg is that all defined symbols are treated as used.
 * (The LINTLIBRARY comment also resets vflag.)
 */
int	llibflg;

/*
 * Nonzero if warnings are suppressed by a LINTED directive
 */
int	nowarn;

/*
 * Nonzero if complaints about use of "long long" are suppressed in
 * the next statement or declaration.
 */
int	quadflg = 1;

/*
 * Puts a new element at the top of the stack used for control statements.
 */
void
pushctrl(int env)
{
	cstk_t	*ci;

	ci = xcalloc(1, sizeof (cstk_t));
	ci->c_env = env;
	ci->c_nxt = cstk;
	cstk = ci;
}

/*
 * Removes the top element of the stack used for control statements.
 */
void
popctrl(int env)
{
	cstk_t	*ci;
	clst_t	*cl;

	if (cstk == NULL || cstk->c_env != env)
		lerror("popctrl() 1");

	cstk = (ci = cstk)->c_nxt;

	while ((cl = ci->c_clst) != NULL) {
		ci->c_clst = cl->cl_nxt;
		free(cl);
	}

	if (ci->c_swtype != NULL)
		free(ci->c_swtype);

	free(ci);
}

/*
 * Prints a warning if a statement cannot be reached.
 */
void
chkreach(void)
{
	if (!reached && !rchflg) {
		/* statement not reached */
		warning(193);
		reached = 1;
	}
}

/*
 * Called after a function declaration which introduces a function definition
 * and before an (optional) old style argument declaration list.
 *
 * Puts all symbols declared in the prototype or in an old style argument
 * list back to the symbol table.
 *
 * Does the usual checking of storage class, type (return value),
 * redeclaration etc..
 */
void
funcdef(sym_t *fsym)
{
	int	n, warn;
	sym_t	*arg, *sym, *rdsym;

	funcsym = fsym;

	/*
	 * Put all symbols declared in the argument list back to the
	 * symbol table.
	 */
	for (sym = dcs->d_fpsyms; sym != NULL; sym = sym->s_dlnxt) {
		if (sym->s_blklev != -1) {
			if (sym->s_blklev != 1)
				lerror("funcdef() 1");
			inssym(1, sym);
		}
	}

	/*
	 * __func__ is a "predefined identifier" in c99, which means it is a
	 * block-scope variable supplying the name of the enclosing function.
	 * It is defined as:
	 *
	 * static const char __func__[] = "function-name";
	 *
	 */
	sym = getblk(sizeof (sym_t));
	sym->s_name = "__func__";
	sym->s_kind = FVFT;
	sym->s_scl = STATIC;
	sym->s_type = incref(gettyp(CHAR), ARRAY);
	sym->s_blklev = 1;
	sym->s_def = DEF;
	sym->s_type->t_dim = strlen(fsym->s_name) + 1;
	sym->s_type->t_subt = duptyp(gettyp(CHAR));
	sym->s_type->t_subt->t_const = 1;
	inssym(1, sym);

	/*
	 * In osfunc() we did not know whether it is an old style function
	 * definition or only an old style declaration, if there are no
	 * arguments inside the argument list ("f()").
	 */
	if (!fsym->s_type->t_proto && fsym->s_args == NULL)
		fsym->s_osdef = 1;

	chktyp(fsym);

	/*
	 * chktyp() checks for almost all possible errors, but not for
	 * incomplete return values (these are allowed in declarations)
	 */
	if (fsym->s_type->t_subt->t_tspec != VOID &&
	    incompl(fsym->s_type->t_subt)) {
		/* cannot return incomplete type */
		error(67);
	}

	fsym->s_def = DEF;

	if (fsym->s_scl == TYPEDEF) {
		fsym->s_scl = EXTERN;
		/* illegal storage class */
		error(8);
	}

	if (dcs->d_inline)
		fsym->s_inline = 1;

	/*
	 * Arguments in new style function declarations need a name.
	 * (void is already removed from the list of arguments)
	 */
	n = 1;
	for (arg = fsym->s_type->t_args; arg != NULL; arg = arg->s_nxt) {
		if (arg->s_scl == ABSTRACT) {
			if (arg->s_name != unnamed)
				lerror("funcdef() 2");
			/* formal parameter lacks name: param #%d */
			error(59, n);
		} else {
			if (arg->s_name == unnamed)
				lerror("funcdef() 3");
		}
		n++;
	}

	/*
	 * We must also remember the position. s_dpos is overwritten
	 * if this is an old style definition and we had already a
	 * prototype.
	 */
	STRUCT_ASSIGN(dcs->d_fdpos, fsym->s_dpos);

	if ((rdsym = dcs->d_rdcsym) != NULL) {

		if (!isredec(fsym, (warn = 0, &warn))) {

			/*
			 * Print nothing if the newly defined function
			 * is defined in old style. A better warning will
			 * be printed in cluparg().
			 */
			if (warn && !fsym->s_osdef) {
				/* redeclaration of %s */
				(*(sflag ? error : warning))(27, fsym->s_name);
				prevdecl(-1, rdsym);
			}

			/* copy usage information */
			cpuinfo(fsym, rdsym);

			/*
			 * If the old symbol was a prototype and the new
			 * one is none, overtake the position of the
			 * declaration of the prototype.
			 */
			if (fsym->s_osdef && rdsym->s_type->t_proto)
				STRUCT_ASSIGN(fsym->s_dpos, rdsym->s_dpos);

			/* complete the type */
			compltyp(fsym, rdsym);

			/* once a function is inline it remains inline */
			if (rdsym->s_inline)
				fsym->s_inline = 1;

		}

		/* remove the old symbol from the symbol table */
		rmsym(rdsym);

	}

	if (fsym->s_osdef && !fsym->s_type->t_proto) {
		if (sflag && hflag && strcmp(fsym->s_name, "main") != 0)
			/* function definition is not a prototype */
			warning(286);
	}

	if (dcs->d_notyp)
		/* return value is implicitly declared to be int */
		fsym->s_rimpl = 1;

	reached = 1;
}

/*
 * Called at the end of a function definition.
 */
void
funcend(void)
{
	sym_t	*arg;
	int	n;

	if (reached) {
		cstk->c_noretval = 1;
		if (funcsym->s_type->t_subt->t_tspec != VOID &&
		    !funcsym->s_rimpl) {
			/* func. %s falls off bottom without returning value */
			warning(217, funcsym->s_name);
		}
	}

	/*
	 * This warning is printed only if the return value was implicitly
	 * declared to be int. Otherwise the wrong return statement
	 * has already printed a warning.
	 */
	if (cstk->c_noretval && cstk->c_retval && funcsym->s_rimpl)
		/* function %s has return (e); and return; */
		warning(216, funcsym->s_name);

	/* Print warnings for unused arguments */
	arg = dcs->d_fargs;
	n = 0;
	while (arg != NULL && (nargusg == -1 || n < nargusg)) {
		chkusg1(dcs->d_asm, arg);
		arg = arg->s_nxt;
		n++;
	}
	nargusg = -1;

	if (noretflg)
		funcsym->s_noreturn = 1;
	noretflg = 0;

	/*
	 * write the information about the function definition to the
	 * output file
	 * inline functions explicitly declared extern are written as
	 * declarations only.
	 */
	if (dcs->d_scl == EXTERN && funcsym->s_inline) {
		outsym(funcsym, funcsym->s_scl, DECL);
	} else {
		outfdef(funcsym, &dcs->d_fdpos, cstk->c_retval,
			funcsym->s_osdef, dcs->d_fargs);
	}

	/*
	 * remove all symbols declared during argument declaration from
	 * the symbol table
	 */
	if (dcs->d_nxt != NULL || dcs->d_ctx != EXTERN)
		lerror("funcend() 1");
	rmsyms(dcs->d_fpsyms);

	/* must be set on level 0 */
	reached = 1;
}

/*
 * Process a label.
 *
 * typ		type of the label (T_NAME, T_DEFAULT or T_CASE).
 * sym		symbol table entry of label if typ == T_NAME
 * tn		expression if typ == T_CASE
 */
void
label(int typ, sym_t *sym, tnode_t *tn)
{
	cstk_t	*ci;
	clst_t	*cl;
	val_t	*v, *nv;
	tspec_t	t;

	switch (typ) {

	case T_NAME:
		if (sym->s_set) {
			/* label %s redefined */
			error(194, sym->s_name);
		} else {
			setsflg(sym);
		}
		break;

	case T_CASE:

		/* find the stack entry for the innermost switch statement */
		for (ci = cstk; ci != NULL && !ci->c_switch; ci = ci->c_nxt) ;

		if (ci == NULL) {
			/* case not in switch */
			error(195);
			tn = NULL;
		} else if (tn != NULL && tn->tn_op != CON) {
			/* non-constant case expression */
			error(197);
			tn = NULL;
		} else if (tn != NULL && !isityp(tn->tn_type->t_tspec)) {
			/* non-integral case expression */
			error(198);
			tn = NULL;
		}

		if (tn != NULL) {

			if (ci->c_swtype == NULL)
				lerror("label() 1");

			if (reached && !ftflg) {
				if (hflag)
					/* fallthrough on case statement */
					warning(220);
			}

			t = tn->tn_type->t_tspec;

			/*
			 * get the value of the expression and convert it
			 * to the type of the switch expression
			 */
			v = constant(tn);
			nv = xcalloc(1, sizeof (val_t));
			cvtcon(CASE, NULL, ci->c_swtype, nv, v);
			free(v);

			/* look if we had this value already */
			for (cl = ci->c_clst; cl != NULL; cl = cl->cl_nxt) {
				if (cl->cl_val.v_quad == nv->v_quad)
					break;
			}
			if (cl != NULL && isutyp(nv->v_tspec)) {
				/* duplicate case in switch, %lu */
				error(200, (u_long)nv->v_quad);
			} else if (cl != NULL) {
				/* duplicate case in switch, %ld */
				error(199, (long)nv->v_quad);
			} else {
				/*
				 * append the value to the list of
				 * case values
				 */
				cl = xcalloc(1, sizeof (clst_t));
				STRUCT_ASSIGN(cl->cl_val, *nv);
				cl->cl_nxt = ci->c_clst;
				ci->c_clst = cl;
			}
		}
		tfreeblk();
		break;

	case T_DEFAULT:

		/* find the stack entry for the innermost switch statement */
		for (ci = cstk; ci != NULL && !ci->c_switch; ci = ci->c_nxt) ;

		if (ci == NULL) {
			/* default outside switch */
			error(201);
		} else if (ci->c_default) {
			/* duplicate default in switch */
			error(202);
		} else {
			if (reached && !ftflg) {
				if (hflag)
					/* fallthrough on default statement */
					warning(284);
			}
			ci->c_default = 1;
		}
		break;
	};
	reached = 1;
}

/*
 * T_IF T_LPARN expr T_RPARN
 */
void
if1(tnode_t *tn)
{
	if (tn != NULL)
		tn = cconv(tn);
	if (tn != NULL)
		tn = promote(NOOP, 0, tn);
	expr(tn, 0, 1);
	pushctrl(T_IF);
}

/*
 * if_without_else
 * if_without_else T_ELSE
 */
void
if2(void)
{
	cstk->c_rchif = reached ? 1 : 0;
	reached = 1;
}

/*
 * if_without_else
 * if_without_else T_ELSE stmnt
 */
void
if3(int els)
{
	if (els) {
		reached |= cstk->c_rchif;
	} else {
		reached = 1;
	}
	popctrl(T_IF);
}

/*
 * T_SWITCH T_LPARN expr T_RPARN
 */
void
switch1(tnode_t *tn)
{
	type_t	*tp;

	if (tn != NULL)
		tn = cconv(tn);
	if (tn != NULL)
		tn = promote(NOOP, 0, tn);
	if (tn != NULL && !isityp(tn->tn_type->t_tspec)) {
		/* switch expression must have integral type */
		error(205);
		tn = NULL;
	}

	/*
	 * Remember the type of the expression. Because its possible
	 * that (*tp) is allocated on tree memory the type must be
	 * duplicated. This is not too complicated because it is
	 * only an integer type.
	 */
	tp = xcalloc(1, sizeof (type_t));
	if (tn != NULL) {
		tp->t_tspec = tn->tn_type->t_tspec;
		if ((tp->t_isenum = tn->tn_type->t_isenum) != 0)
			tp->t_enum = tn->tn_type->t_enum;
	} else {
		tp->t_tspec = INT;
	}

	expr(tn, 1, 0);

	pushctrl(T_SWITCH);
	cstk->c_switch = 1;
	cstk->c_swtype = tp;

	reached = rchflg = 0;
	ftflg = 1;
}

/*
 * switch_expr stmnt
 */
void
switch2(void)
{
	int	nenum, nclab;
	sym_t	*esym;
	clst_t	*cl;

	if (cstk->c_swtype == NULL)
		lerror("switch2() 1");

	/*
	 * If the switch expression was of type enumeration, count the case
	 * labels and the number of enumerators. If both counts are not
	 * equal print a warning.
	 */
	if (cstk->c_swtype->t_isenum) {
		nenum = nclab = 0;
		if (cstk->c_swtype->t_enum == NULL)
			lerror("switch2() 2");
		for (esym = cstk->c_swtype->t_enum->elem;
		     esym != NULL; esym = esym->s_nxt) {
			nenum++;
		}
		for (cl = cstk->c_clst; cl != NULL; cl = cl->cl_nxt)
			nclab++;
		if (hflag && eflag && nenum != nclab && !cstk->c_default) {
			/* enumeration value(s) not handled in switch */
			warning(206);
		}
	}

	if (cstk->c_break) {
		/*
		 * end of switch always reached (c_break is only set if the
		 * break statement can be reached).
		 */
		reached = 1;
	} else if (!cstk->c_default &&
		   (!hflag || !cstk->c_swtype->t_isenum || nenum != nclab)) {
		/*
		 * there are possible values which are not handled in
		 * switch
		 */
		reached = 1;
	}	/*
		 * otherwise the end of the switch expression is reached
		 * if the end of the last statement inside it is reached.
		 */

	popctrl(T_SWITCH);
}

/*
 * T_WHILE T_LPARN expr T_RPARN
 */
void
while1(tnode_t *tn)
{
	if (!reached) {
		/* loop not entered at top */
		warning(207);
		reached = 1;
	}

	if (tn != NULL)
		tn = cconv(tn);
	if (tn != NULL)
		tn = promote(NOOP, 0, tn);
	if (tn != NULL && !issclt(tn->tn_type->t_tspec)) {
		/* controlling expressions must have scalar type */
		error(204);
		tn = NULL;
	}

	pushctrl(T_WHILE);
	cstk->c_loop = 1;
	if (tn != NULL && tn->tn_op == CON) {
		if (isityp(tn->tn_type->t_tspec)) {
			cstk->c_infinite = tn->tn_val->v_quad != 0;
		} else {
			cstk->c_infinite = tn->tn_val->v_ldbl != 0.0;
		}
	}

	expr(tn, 0, 1);
}

/*
 * while_expr stmnt
 * while_expr error
 */
void
while2(void)
{
	/*
	 * The end of the loop can be reached if it is no endless loop
	 * or there was a break statement which was reached.
	 */
	reached = !cstk->c_infinite || cstk->c_break;
	rchflg = 0;

	popctrl(T_WHILE);
}

/*
 * T_DO
 */
void
do1(void)
{
	if (!reached) {
		/* loop not entered at top */
		warning(207);
		reached = 1;
	}

	pushctrl(T_DO);
	cstk->c_loop = 1;
}

/*
 * do stmnt do_while_expr
 * do error
 */
void
do2(tnode_t *tn)
{
	/*
	 * If there was a continue statement the expression controlling the
	 * loop is reached.
	 */
	if (cstk->c_cont)
		reached = 1;

	if (tn != NULL)
		tn = cconv(tn);
	if (tn != NULL)
		tn = promote(NOOP, 0, tn);
	if (tn != NULL && !issclt(tn->tn_type->t_tspec)) {
		/* controlling expressions must have scalar type */
		error(204);
		tn = NULL;
	}

	if (tn != NULL && tn->tn_op == CON) {
		if (isityp(tn->tn_type->t_tspec)) {
			cstk->c_infinite = tn->tn_val->v_quad != 0;
		} else {
			cstk->c_infinite = tn->tn_val->v_ldbl != 0.0;
		}
	}

	expr(tn, 0, 1);

	/*
	 * The end of the loop is only reached if it is no endless loop
	 * or there was a break statement which could be reached.
	 */
	reached = !cstk->c_infinite || cstk->c_break;
	rchflg = 0;

	popctrl(T_DO);
}

/*
 * T_FOR T_LPARN opt_expr T_SEMI opt_expr T_SEMI opt_expr T_RPARN
 */
void
for1(tnode_t *tn1, tnode_t *tn2, tnode_t *tn3)
{
	/*
	 * If there is no initialisation expression it is possible that
	 * it is intended not to enter the loop at top.
	 */
	if (tn1 != NULL && !reached) {
		/* loop not entered at top */
		warning(207);
		reached = 1;
	}

	pushctrl(T_FOR);
	cstk->c_loop = 1;

	/*
	 * Store the tree memory for the reinitialisation expression.
	 * Also remember this expression itself. We must check it at
	 * the end of the loop to get "used but not set" warnings correct.
	 */
	cstk->c_fexprm = tsave();
	cstk->c_f3expr = tn3;
	STRUCT_ASSIGN(cstk->c_fpos, curr_pos);
	STRUCT_ASSIGN(cstk->c_cfpos, csrc_pos);

	if (tn1 != NULL)
		expr(tn1, 0, 0);

	if (tn2 != NULL)
		tn2 = cconv(tn2);
	if (tn2 != NULL)
		tn2 = promote(NOOP, 0, tn2);
	if (tn2 != NULL && !issclt(tn2->tn_type->t_tspec)) {
		/* controlling expressions must have scalar type */
		error(204);
		tn2 = NULL;
	}
	if (tn2 != NULL)
		expr(tn2, 0, 1);

	if (tn2 == NULL) {
		cstk->c_infinite = 1;
	} else if (tn2->tn_op == CON) {
		if (isityp(tn2->tn_type->t_tspec)) {
			cstk->c_infinite = tn2->tn_val->v_quad != 0;
		} else {
			cstk->c_infinite = tn2->tn_val->v_ldbl != 0.0;
		}
	}

	/* Checking the reinitialisation expression is done in for2() */

	reached = 1;
}

/*
 * for_exprs stmnt
 * for_exprs error
 */
void
for2(void)
{
	pos_t	cpos, cspos;
	tnode_t	*tn3;

	if (cstk->c_cont)
		reached = 1;

	STRUCT_ASSIGN(cpos, curr_pos);
	STRUCT_ASSIGN(cspos, csrc_pos);

	/* Restore the tree memory for the reinitialisation expression */
	trestor(cstk->c_fexprm);
	tn3 = cstk->c_f3expr;
	STRUCT_ASSIGN(curr_pos, cstk->c_fpos);
	STRUCT_ASSIGN(csrc_pos, cstk->c_cfpos);

	/* simply "statement not reached" would be confusing */
	if (!reached && !rchflg) {
		/* end-of-loop code not reached */
		warning(223);
		reached = 1;
	}

	if (tn3 != NULL) {
		expr(tn3, 0, 0);
	} else {
		tfreeblk();
	}

	STRUCT_ASSIGN(curr_pos, cpos);
	STRUCT_ASSIGN(csrc_pos, cspos);

	/* An endless loop without break will never terminate */
	reached = cstk->c_break || !cstk->c_infinite;
	rchflg = 0;

	popctrl(T_FOR);
}

/*
 * T_GOTO identifier T_SEMI
 * T_GOTO error T_SEMI
 */
void
dogoto(sym_t *lab)
{
	setuflg(lab, 0, 0);

	chkreach();

	reached = rchflg = 0;
}

/*
 * T_BREAK T_SEMI
 */
void
dobreak(void)
{
	cstk_t	*ci;

	ci = cstk;
	while (ci != NULL && !ci->c_loop && !ci->c_switch)
		ci = ci->c_nxt;

	if (ci == NULL) {
		/* break outside loop or switch */
		error(208);
	} else {
		if (reached)
			ci->c_break = 1;
	}

	/* Don't warn about unreachable breaks in a switch, e.g.:
	 *
	 * switch (foo) {
	 * case 1:
	 *     return 1;
	 *     break;
	 * case 2:
	 *     // etc...
	 * }
	 */
	if (ci == NULL || !ci->c_switch)
		chkreach();

	reached = rchflg = 0;
}

/*
 * T_CONTINUE T_SEMI
 */
void
docont(void)
{
	cstk_t	*ci;

	for (ci = cstk; ci != NULL && !ci->c_loop; ci = ci->c_nxt) ;

	if (ci == NULL) {
		/* continue outside loop */
		error(209);
	} else {
		ci->c_cont = 1;
	}

	chkreach();

	reached = rchflg = 0;
}

/*
 * T_RETURN T_SEMI
 * T_RETURN expr T_SEMI
 */
void
doreturn(tnode_t *tn)
{
	tnode_t	*ln, *rn;
	cstk_t	*ci;
	op_t	op;

	for (ci = cstk; ci->c_nxt != NULL; ci = ci->c_nxt) ;

	if (tn != NULL) {
		ci->c_retval = 1;
	} else {
		ci->c_noretval = 1;
	}

	if (tn != NULL && funcsym->s_type->t_subt->t_tspec == VOID) {
		/* void function %s cannot return value */
		error(213, funcsym->s_name);
		tfreeblk();
		tn = NULL;
	} else if (tn == NULL && funcsym->s_type->t_subt->t_tspec != VOID) {
		/*
		 * Assume that the function has a return value only if it
		 * is explicitly declared.
		 */
		if (!funcsym->s_rimpl)
			/* function %s expects to return value */
			warning(214, funcsym->s_name);
	}

	if (tn != NULL) {

		/* Create a temporary node for the left side */
		ln = tgetblk(sizeof (tnode_t));
		ln->tn_op = NAME;
		ln->tn_type = tduptyp(funcsym->s_type->t_subt);
		ln->tn_type->t_const = 0;
		ln->tn_lvalue = 1;
		ln->tn_sym = funcsym;		/* better than nothing */

		tn = build(RETURN, ln, tn);

		if (tn != NULL) {
			rn = tn->tn_right;
			while ((op = rn->tn_op) == CVT || op == PLUS)
				rn = rn->tn_left;
			if (rn->tn_op == AMPER && rn->tn_left->tn_op == NAME &&
			    rn->tn_left->tn_sym->s_scl == AUTO) {
				/* %s returns pointer to automatic object */
				warning(302, funcsym->s_name);
			}
		}

		expr(tn, 1, 0);

	} else {

		chkreach();

	}

	reached = rchflg = 0;
}

/*
 * Do some cleanup after a global declaration or definition.
 * Especially remove informations about unused lint comments.
 */
void
glclup(int silent)
{
	pos_t	cpos;

	STRUCT_ASSIGN(cpos, curr_pos);

	if (nargusg != -1) {
		if (!silent) {
			STRUCT_ASSIGN(curr_pos, aupos);
			/* must precede function definition: %s */
			warning(282, "ARGSUSED");
		}
		nargusg = -1;
	}
	if (nvararg != -1) {
		if (!silent) {
			STRUCT_ASSIGN(curr_pos, vapos);
			/* must precede function definition: %s */
			warning(282, "VARARGS");
		}
		nvararg = -1;
	}
	if (prflstrg != -1) {
		if (!silent) {
			STRUCT_ASSIGN(curr_pos, prflpos);
			/* must precede function definition: %s */
			warning(282, "PRINTFLIKE");
		}
		prflstrg = -1;
	}
	if (scflstrg != -1) {
		if (!silent) {
			STRUCT_ASSIGN(curr_pos, scflpos);
			/* must precede function definition: %s */
			warning(282, "SCANFLIKE");
		}
		scflstrg = -1;
	}

	STRUCT_ASSIGN(curr_pos, cpos);

	dcs->d_asm = 0;
}

/*
 * ARGSUSED comment
 *
 * Only the first n arguments of the following function are checked
 * for usage. A missing argument is taken to be 0.
 */
void
argsused(int n)
{
	if (n == -1)
		n = 0;

	if (dcs->d_ctx != EXTERN) {
		/* must be outside function: ** %s ** */
		warning(280, "ARGSUSED");
		return;
	}
	if (nargusg != -1) {
		/* duplicate use of ** %s ** */
		warning(281, "ARGSUSED");
	}
	nargusg = n;
	STRUCT_ASSIGN(aupos, curr_pos);
}

/*
 * NORETURN comment
 *
 * The following function will never return, which means any code
 * following a call to this function is unreachable.
 */
void
noreturn(int n)
{
	noretflg = 1;
}

/*
 * LINTUSED comment
 *
 * Mark a symbol as used, so lint2 does not complain.
 */
void
lintused(int n)
{
	usedflg = 1;
}

/*
 * VARARGS comment
 *
 * Makes that lint2 checks only the first n arguments for compatibility
 * to the function definition. A missing argument is taken to be 0.
 */
void
varargs(int n)
{
	if (n == -1)
		n = 0;

	if (dcs->d_ctx != EXTERN) {
		/* must be outside function: ** %s ** */
		warning(280, "VARARGS");
		return;
	}
	if (nvararg != -1) {
		/* duplicate use of  ** %s ** */
		warning(281, "VARARGS");
	}
	nvararg = n;
	STRUCT_ASSIGN(vapos, curr_pos);
}

/*
 * PRINTFLIKE comment
 *
 * Check all arguments until the (n-1)-th as usual. The n-th argument is
 * used the check the types of remaining arguments.
 */
void
printflike(int n)
{
	if (n == -1)
		n = 0;

	if (dcs->d_ctx != EXTERN) {
		/* must be outside function: ** %s ** */
		warning(280, "PRINTFLIKE");
		return;
	}
	if (prflstrg != -1) {
		/* duplicate use of ** %s ** */
		warning(281, "PRINTFLIKE");
	}
	prflstrg = n;
	STRUCT_ASSIGN(prflpos, curr_pos);
}

/*
 * SCANFLIKE comment
 *
 * Check all arguments until the (n-1)-th as usual. The n-th argument is
 * used the check the types of remaining arguments.
 */
void
scanflike(int n)
{
	if (n == -1)
		n = 0;

	if (dcs->d_ctx != EXTERN) {
		/* must be outside function: ** %s ** */
		warning(280, "SCANFLIKE");
		return;
	}
	if (scflstrg != -1) {
		/* duplicate use of ** %s ** */
		warning(281, "SCANFLIKE");
	}
	scflstrg = n;
	STRUCT_ASSIGN(scflpos, curr_pos);
}

/*
 * Set the linenumber for a CONSTCOND comment. At this and the following
 * line no warnings about constants in conditional contexts are printed.
 */
/* ARGSUSED */
void
constcond(int n)
{
	ccflg = 1;
}

/*
 * Suppress printing of "fallthrough on ..." warnings until next
 * statement.
 */
/* ARGSUSED */
void
fallthru(int n)
{
	ftflg = 1;
}

/*
 * Stop warnings about statements which cannot be reached. Also tells lint
 * that the following statements cannot be reached (e.g. after exit()).
 */
/* ARGSUSED */
void
notreach(int n)
{
	reached = 0;
	rchflg = 1;
}

/* ARGSUSED */
void
lintlib(int n)
{
	if (dcs->d_ctx != EXTERN) {
		/* must be outside function: ** %s ** */
		warning(280, "LINTLIBRARY");
		return;
	}
	llibflg = 1;
	vflag = 0;
}

/*
 * Suppress most warnings at the current and the following line.
 */
/* ARGSUSED */
void
linted(int n)
{
	nowarn = 1;
}

/*
 * PROTOTLIB in conjunction with LINTLIBRARY can be used to handle
 * prototypes like function definitions. This is done if the argument
 * to PROTOLIB is nonzero. Otherwise prototypes are handled normaly.
 */
void
protolib(int n)
{
	if (dcs->d_ctx != EXTERN) {
		/* must be outside function: ** %s ** */
		warning(280, "PROTOLIB");
		return;
	}
	plibflg = n == 0 ? 0 : 1;
}

/*
 * Set quadflg to nonzero which means that the next statement/declaration
 * may use "long long" without an error or warning.
 */
/* ARGSUSED */
void
longlong(int n)
{
	quadflg = 1;
}
@


1.22
log
@remove rcsids which escaped the purge of 2009
@
text
@d1 1
a1 1
/*	$OpenBSD: func.c,v 1.21 2011/05/30 15:15:58 martynas Exp $	*/
@


1.21
log
@Typos: "in in", "prototyp".
@
text
@d1 1
a1 1
/*	$OpenBSD: func.c,v 1.20 2007/10/17 20:10:44 chl Exp $	*/
a33 4

#ifndef lint
static char rcsid[] = "$OpenBSD: func.c,v 1.20 2007/10/17 20:10:44 chl Exp $";
#endif
@


1.20
log
@remove "unused variable" warnings

tested by deraadt@@ on a gcc2 arch

looks ok ray@@ ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: func.c,v 1.19 2007/09/06 22:02:03 cloder Exp $	*/
d36 1
a36 1
static char rcsid[] = "$OpenBSD: func.c,v 1.19 2007/09/06 22:02:03 cloder Exp $";
d350 1
a350 1
			/* function definition is not a prototyp */
@


1.19
log
@Fix typos in comments. No code changes
@
text
@d1 1
a1 1
/*	$OpenBSD: func.c,v 1.18 2006/05/29 20:47:22 cloder Exp $	*/
d36 1
a36 1
static char rcsid[] = "$OpenBSD: func.c,v 1.18 2006/05/29 20:47:22 cloder Exp $";
a588 1
	tspec_t	t;
@


1.18
log
@Get rid of -t (traditional C) option. Some corrections by moritz.
@
text
@d1 1
a1 1
/*	$OpenBSD: func.c,v 1.17 2006/05/28 23:50:54 cloder Exp $	*/
d36 1
a36 1
static char rcsid[] = "$OpenBSD: func.c,v 1.17 2006/05/28 23:50:54 cloder Exp $";
d663 1
a663 1
		 * end of switch alway reached (c_break is only set if the
@


1.17
log
@Kill the bflag, which was really just used to shut up a useless warning
regarding unreachable breaks, we committed a smarter fix for this a while
back, so the flag is not needed anymore. Lint will still accept and
silently ignore this flag for now.
@
text
@d1 1
a1 1
/*	$OpenBSD: func.c,v 1.16 2006/04/26 15:57:41 cloder Exp $	*/
d36 1
a36 1
static char rcsid[] = "$OpenBSD: func.c,v 1.16 2006/04/26 15:57:41 cloder Exp $";
a483 6
			if (t == LONG || t == ULONG ||
			    t == QUAD || t == UQUAD) {
				if (tflag)
					/* case label must be of type ... */
					warning(203);
			}
a599 7
	}
	if (tn != NULL && tflag) {
		t = tn->tn_type->t_tspec;
		if (t == LONG || t == ULONG || t == QUAD || t == UQUAD) {
			/* switch expr. must be of type `int' in trad. C */
			warning(271);
		}
@


1.16
log
@Typos in comments, no code changes
@
text
@d1 1
a1 1
/*	$OpenBSD: func.c,v 1.15 2006/04/21 02:38:36 cloder Exp $	*/
d36 1
a36 1
static char rcsid[] = "$OpenBSD: func.c,v 1.15 2006/04/21 02:38:36 cloder Exp $";
d955 1
a955 1
	if (bflag && (ci == NULL || !ci->c_switch))
@


1.15
log
@Fix crash when lint deals with break statements outside switch or loop.
This defect was introduced by me on my last commit and found by dlg@@
when linting in kernel.
@
text
@d1 1
a1 1
/*	$OpenBSD: func.c,v 1.14 2006/04/20 16:29:48 cloder Exp $	*/
d36 1
a36 1
static char rcsid[] = "$OpenBSD: func.c,v 1.14 2006/04/20 16:29:48 cloder Exp $";
d61 1
a61 1
 * In conjunction with reached ontrols printing of "fallthrough on ..."
d127 1
a127 1
 * Nonzero means that no warnings about constands in conditional
d206 1
a206 1
 * Puts all symbols declared in the Prototype or in an old style argument
@


1.14
log
@Add a LINTUSED special comment which marks the following declared symbol(s)
as used so that lint2 doesn't complain. Prodded by deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: func.c,v 1.13 2006/04/20 03:40:29 cloder Exp $	*/
d36 1
a36 1
static char rcsid[] = "$OpenBSD: func.c,v 1.13 2006/04/20 03:40:29 cloder Exp $";
d955 1
a955 1
	if (bflag && !ci->c_switch)
@


1.13
log
@Do not warn about unreachable breaks in a switch. Prodded by theo, and
this is necessitated by output of lex (thanks a lot).
@
text
@d1 1
a1 1
/*	$OpenBSD: func.c,v 1.12 2006/04/18 02:59:40 cloder Exp $	*/
d36 1
a36 1
static char rcsid[] = "$OpenBSD: func.c,v 1.12 2006/04/18 02:59:40 cloder Exp $";
d93 6
d1135 11
@


1.12
log
@The old way of passing function argument information was to pass an int
which corresponded to the argument # (1-based, with 0 meaning it is not
an argument). This sucked because it is impossible to include the function
name or argument name in warnings when all you have is an argument number.
Introduce a new type farg_t which represents a passed function argument.
struct farg contains argument number, function name, and argument symbol
information from the prototype).
@
text
@d1 1
a1 1
/*	$OpenBSD: func.c,v 1.11 2006/03/13 21:12:32 moritz Exp $	*/
d36 1
a36 1
static char rcsid[] = "$OpenBSD: func.c,v 1.11 2006/03/13 21:12:32 moritz Exp $";
d939 11
a949 1
	if (bflag)
@


1.11
log
@Do not warn for functions declared with ARGSUSED
but having no arguments. ok deraadt@@ cloder@@
@
text
@d1 1
a1 1
/*	$OpenBSD: func.c,v 1.10 2005/12/17 21:08:27 cloder Exp $	*/
d36 1
a36 1
static char rcsid[] = "$OpenBSD: func.c,v 1.10 2005/12/17 21:08:27 cloder Exp $";
d491 1
a491 1
			cvtcon(CASE, 0, ci->c_swtype, nv, v);
@


1.10
log
@Handle __dead functions using lint comments.
@
text
@d1 1
a1 1
/*	$OpenBSD: func.c,v 1.9 2005/12/17 20:19:46 cloder Exp $	*/
d36 1
a36 1
static char rcsid[] = "$OpenBSD: func.c,v 1.9 2005/12/17 20:19:46 cloder Exp $";
a384 4
	if (arg == NULL && nargusg == 0) {
		warning(314, funcsym->s_name, "ARGSUSED");
	}

@


1.9
log
@Check for functions declared with ARGSUSED but having no arguments.
@
text
@d1 1
a1 1
/*	$OpenBSD: func.c,v 1.8 2005/11/29 19:38:09 cloder Exp $	*/
d36 1
a36 1
static char rcsid[] = "$OpenBSD: func.c,v 1.8 2005/11/29 19:38:09 cloder Exp $";
d87 6
d396 4
d1111 12
@


1.8
log
@Typos in comments: explizit and implizit
@
text
@d1 1
a1 1
/*	$OpenBSD: func.c,v 1.7 2005/11/29 03:40:56 cloder Exp $	*/
d36 1
a36 1
static char rcsid[] = "$OpenBSD: func.c,v 1.7 2005/11/29 03:40:56 cloder Exp $";
d379 4
@


1.7
log
@Make lint grok __func__, which in C99 is a predifined identifier that
holds the name of the current function.  Makes thousands of lint warnings
vanish and since lint can now fully parse compound expressions involving
__func__, we see some new interesting warnings instead.
@
text
@d1 1
a1 1
/*	$OpenBSD: func.c,v 1.6 2005/11/19 03:35:27 cloder Exp $	*/
d36 1
a36 1
static char rcsid[] = "$OpenBSD: func.c,v 1.6 2005/11/19 03:35:27 cloder Exp $";
d343 1
a343 1
		/* return value is implizitly declared to be int */
d368 1
a368 1
	 * This warning is printed only if the return value was implizitly
@


1.6
log
@knf. OK kjell, brad
@
text
@d1 1
a1 1
/*	$OpenBSD: func.c,v 1.5 2004/05/10 15:26:22 deraadt Exp $	*/
d36 1
a36 1
static char rcsid[] = "$OpenBSD: func.c,v 1.5 2004/05/10 15:26:22 deraadt Exp $";
d219 20
@


1.5
log
@using a horrid hack: permit long long.  millert ok
@
text
@d1 1
a1 1
/*	$OpenBSD: func.c,v 1.4 2001/11/18 20:55:42 deraadt Exp $	*/
d36 1
a36 1
static char rcsid[] = "$OpenBSD: func.c,v 1.4 2001/11/18 20:55:42 deraadt Exp $";
d142 1
a142 2
pushctrl(env)
	int	env;
d156 1
a156 2
popctrl(env)
	int	env;
d181 1
a181 1
chkreach()
d201 1
a201 2
funcdef(fsym)
	sym_t	*fsym;
d333 1
a333 1
funcend()
d399 1
a399 4
label(typ, sym, tn)
	int	typ;
	sym_t	*sym;
	tnode_t	*tn;
d517 1
a517 2
if1(tn)
	tnode_t	*tn;
d532 1
a532 1
if2()
d543 1
a543 2
if3(els)
	int	els;
d557 1
a557 2
switch1(tn)
	tnode_t	*tn;
d608 1
a608 1
switch2()
d663 1
a663 2
while1(tn)
	tnode_t	*tn;
d699 1
a699 1
while2()
d715 1
a715 1
do1()
d732 1
a732 2
do2(tn)
	tnode_t	*tn;
d775 1
a775 2
for1(tn1, tn2, tn3)
	tnode_t	*tn1, *tn2, *tn3;
d835 1
a835 1
for2()
d880 1
a880 2
dogoto(lab)
	sym_t	*lab;
d893 1
a893 1
dobreak()
d919 1
a919 1
docont()
d942 1
a942 2
doreturn(tn)
	tnode_t	*tn;
d1010 1
a1010 2
glclup(silent)
	int	silent;
d1061 1
a1061 2
argsused(n)
	int	n;
d1086 1
a1086 2
varargs(n)
	int	n;
d1111 1
a1111 2
printflike(n)
	int	n;
d1136 1
a1136 2
scanflike(n)
	int	n;
d1160 1
a1160 2
constcond(n)
	int	n;
d1171 1
a1171 2
fallthru(n)
	int	n;
d1182 1
a1182 2
notreach(n)
	int	n;
d1190 1
a1190 2
lintlib(n)
	int	n;
d1206 1
a1206 2
linted(n)
	int	n;
d1217 1
a1217 2
protolib(n)
	int	n;
d1233 1
a1233 2
longlong(n)
	int	n;
@


1.4
log
@spelling
@
text
@d1 1
a1 1
/*	$OpenBSD: func.c,v 1.3 1999/10/29 09:01:00 todd Exp $	*/
d36 1
a36 1
static char rcsid[] = "$OpenBSD: func.c,v 1.3 1999/10/29 09:01:00 todd Exp $";
d136 1
a136 1
int	quadflg;
@


1.3
log
@writen
@
text
@d1 1
a1 1
/*	$OpenBSD: func.c,v 1.2 1996/06/26 05:44:13 deraadt Exp $	*/
d36 1
a36 1
static char rcsid[] = "$OpenBSD: func.c,v 1.2 1996/06/26 05:44:13 deraadt Exp $";
d372 1
a372 1
	 * inline functions explicitely declared extern are written as
@


1.2
log
@rcsid
@
text
@d1 1
a1 1
/*	$OpenBSD: func.c,v 1.7 1995/10/02 17:31:40 jpo Exp $	*/
d36 1
a36 1
static char rcsid[] = "$OpenBSD: func.c,v 1.7 1995/10/02 17:31:40 jpo Exp $";
d109 1
a109 1
 * Are both plibflg and llibflg set, prototypes are writen as function
@


1.1
log
@Initial revision
@
text
@d1 1
d36 1
a36 1
static char rcsid[] = "$NetBSD: func.c,v 1.7 1995/10/02 17:31:40 jpo Exp $";
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@
