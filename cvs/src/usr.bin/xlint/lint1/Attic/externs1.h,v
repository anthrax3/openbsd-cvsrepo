head	1.17;
access;
symbols
	OPENBSD_5_1_BASE:1.16
	OPENBSD_5_1:1.16.0.8
	OPENBSD_5_0:1.16.0.6
	OPENBSD_5_0_BASE:1.16
	OPENBSD_4_9:1.16.0.4
	OPENBSD_4_9_BASE:1.16
	OPENBSD_4_8:1.16.0.2
	OPENBSD_4_8_BASE:1.16
	OPENBSD_4_7:1.15.0.14
	OPENBSD_4_7_BASE:1.15
	OPENBSD_4_6:1.15.0.16
	OPENBSD_4_6_BASE:1.15
	OPENBSD_4_5:1.15.0.12
	OPENBSD_4_5_BASE:1.15
	OPENBSD_4_4:1.15.0.10
	OPENBSD_4_4_BASE:1.15
	OPENBSD_4_3:1.15.0.8
	OPENBSD_4_3_BASE:1.15
	OPENBSD_4_2:1.15.0.6
	OPENBSD_4_2_BASE:1.15
	OPENBSD_4_1:1.15.0.4
	OPENBSD_4_1_BASE:1.15
	OPENBSD_4_0:1.15.0.2
	OPENBSD_4_0_BASE:1.15
	OPENBSD_3_9:1.10.0.2
	OPENBSD_3_9_BASE:1.10
	OPENBSD_3_8:1.3.0.16
	OPENBSD_3_8_BASE:1.3
	OPENBSD_3_7:1.3.0.14
	OPENBSD_3_7_BASE:1.3
	OPENBSD_3_6:1.3.0.12
	OPENBSD_3_6_BASE:1.3
	OPENBSD_3_5:1.3.0.10
	OPENBSD_3_5_BASE:1.3
	OPENBSD_3_4:1.3.0.8
	OPENBSD_3_4_BASE:1.3
	OPENBSD_3_3:1.3.0.6
	OPENBSD_3_3_BASE:1.3
	OPENBSD_3_2:1.3.0.4
	OPENBSD_3_2_BASE:1.3
	OPENBSD_3_1:1.3.0.2
	OPENBSD_3_1_BASE:1.3
	OPENBSD_3_0:1.2.0.22
	OPENBSD_3_0_BASE:1.2
	OPENBSD_2_9_BASE:1.2
	OPENBSD_2_9:1.2.0.20
	OPENBSD_2_8:1.2.0.18
	OPENBSD_2_8_BASE:1.2
	OPENBSD_2_7:1.2.0.16
	OPENBSD_2_7_BASE:1.2
	OPENBSD_2_6:1.2.0.14
	OPENBSD_2_6_BASE:1.2
	OPENBSD_2_5:1.2.0.12
	OPENBSD_2_5_BASE:1.2
	OPENBSD_2_4:1.2.0.10
	OPENBSD_2_4_BASE:1.2
	OPENBSD_2_3:1.2.0.8
	OPENBSD_2_3_BASE:1.2
	OPENBSD_2_2:1.2.0.6
	OPENBSD_2_2_BASE:1.2
	OPENBSD_2_1:1.2.0.4
	OPENBSD_2_1_BASE:1.2
	OPENBSD_2_0:1.2.0.2
	OPENBSD_2_0_BASE:1.2
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.17
date	2012.04.08.16.27.00;	author jsg;	state dead;
branches;
next	1.16;

1.16
date	2010.07.24.22.17.03;	author guenther;	state Exp;
branches;
next	1.15;

1.15
date	2006.05.29.20.47.22;	author cloder;	state Exp;
branches;
next	1.14;

1.14
date	2006.05.28.23.50.54;	author cloder;	state Exp;
branches;
next	1.13;

1.13
date	2006.05.28.23.42.49;	author cloder;	state Exp;
branches;
next	1.12;

1.12
date	2006.04.20.16.29.48;	author cloder;	state Exp;
branches;
next	1.11;

1.11
date	2006.04.18.02.59.40;	author cloder;	state Exp;
branches;
next	1.10;

1.10
date	2005.12.18.19.21.02;	author cloder;	state Exp;
branches;
next	1.9;

1.9
date	2005.12.17.21.08.27;	author cloder;	state Exp;
branches;
next	1.8;

1.8
date	2005.12.12.23.35.59;	author cloder;	state Exp;
branches;
next	1.7;

1.7
date	2005.12.10.18.42.45;	author cloder;	state Exp;
branches;
next	1.6;

1.6
date	2005.12.10.17.51.49;	author cloder;	state Exp;
branches;
next	1.5;

1.5
date	2005.12.10.17.41.03;	author cloder;	state Exp;
branches;
next	1.4;

1.4
date	2005.12.07.01.55.12;	author cloder;	state Exp;
branches;
next	1.3;

1.3
date	2002.02.16.21.27.59;	author millert;	state Exp;
branches;
next	1.2;

1.2
date	96.06.26.05.44.12;	author deraadt;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.47.02;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.47.02;	author deraadt;	state Exp;
branches;
next	;


desc
@@


1.17
log
@tedu lint
ok tedu@@ guenther@@ krw@@ espie@@ deraadt@@
@
text
@/*	$OpenBSD: externs1.h,v 1.16 2010/07/24 22:17:03 guenther Exp $	*/
/*	$NetBSD: externs1.h,v 1.7 1995/10/02 17:31:39 jpo Exp $	*/

/*
 * Copyright (c) 1994, 1995 Jochen Pohl
 * All Rights Reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *      This product includes software developed by Jochen Pohl for
 *	The NetBSD Project.
 * 4. The name of the author may not be used to endorse or promote products
 *    derived from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
 * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
 * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

/*
 * main.c
 */
extern	int	cflag;
extern	int	dflag;
extern	int	eflag;
extern	int	fflag;
extern	int	Fflag;
extern	int	gflag;
extern	int	hflag;
extern	int	pflag;
extern	int	rflag;
extern	int	sflag;
extern	int	uflag;
extern	int	vflag;
extern	int	yflag;
extern	int	zflag;

extern	void	norecover(void);

/*
 * cgram.y
 */
extern	int	blklev;
extern	int	mblklev;
extern	int	yydebug;

extern	int	yyerror(char *);
extern	int	yyparse(void);

/*
 * scan.l
 */
extern	pos_t	curr_pos;
extern	pos_t	csrc_pos;
extern	symt_t	symtyp;
extern	FILE	*yyin;
extern	u_quad_t qbmasks[], qlmasks[], qumasks[];

extern	void	initscan(void);
extern	int	sign(quad_t, tspec_t, int);
extern	int	msb(quad_t, tspec_t, int);
extern	quad_t	xsign(quad_t, tspec_t, int);
extern	void	clrwflgs(void);
extern	sym_t	*getsym(sbuf_t *);
extern	void	cleanup(void);
extern	sym_t	*pushdown(sym_t *);
extern	void	rmsym(sym_t *);
extern	void	rmsyms(sym_t *);
extern	void	inssym(int, sym_t *);
extern	void	freeyyv(void *, int);
extern	int	yylex(void);

/*
 * mem1.c
 */
extern	const	char *fnalloc(const char *);
extern	const	char *fnnalloc(const char *, size_t);
extern	int	getfnid(const char *);

extern	void	initmem(void);

extern	void	*getblk(size_t);
extern	void	*getlblk(int, size_t);
extern	void	freeblk(void);
extern	void	freelblk(int);

extern	void	*tgetblk(size_t);
extern	tnode_t	*getnode(void);
extern	void	tfreeblk(void);
extern	struct	mbl *tsave(void);
extern	void	trestor(struct mbl *);

/*
 * err.c
 */
extern	int	nerr;
extern	int	sytxerr;
extern	const	char *msgs[];

extern	void	error(int, ...);
extern	void	warning(int, ...);
extern	void	message(int, ...);
extern	int	gnuism(int, ...);
extern	void	lerror(const char *, ...);

/*
 * decl.c
 */
extern	dinfo_t	*dcs;
extern	const	char *unnamed;
extern	int	enumval;

extern	void	initdecl(void);
extern	type_t	*gettyp(tspec_t);
extern	type_t	*duptyp(const type_t *);
extern	type_t	*tduptyp(const type_t *);
extern	int	incompl(type_t *);
extern	void	setcompl(type_t *, int);
extern	void	addscl(scl_t);
extern	void	addtype(type_t *);
extern	void	addqual(tqual_t);
extern	void	pushdecl(scl_t);
extern	void	popdecl(void);
extern	void	setasm(void);
extern	void	clrtyp(void);
extern	int	mergedomain(tspec_t *, tspec_t);
extern	void	deftyp(void);
extern	int	length(type_t *, const char *);
extern	int	getbound(type_t *);
extern	sym_t	*lnklst(sym_t *, sym_t *);
extern	void	chktyp(sym_t *);
extern	sym_t	*decl1str(sym_t *);
extern	sym_t	*bitfield(sym_t *, int);
extern	pqinf_t	*mergepq(pqinf_t *, pqinf_t *);
extern	sym_t	*addptr(sym_t *, pqinf_t *);
extern	sym_t	*addarray(sym_t *, int, int);
extern	sym_t	*addfunc(sym_t *, sym_t *);
extern	void	chkfdef(sym_t *, int);
extern	sym_t	*dname(sym_t *);
extern	sym_t	*iname(sym_t *);
extern	type_t	*mktag(sym_t *, tspec_t, int, int);
extern	const	char *scltoa(scl_t);
extern	type_t	*compltag(type_t *, sym_t *);
extern	sym_t	*ename(sym_t *, int, int);
extern	void	decl1ext(sym_t *, int);
extern	void	cpuinfo(sym_t *, sym_t *);
extern	int	isredec(sym_t *, int *);
extern	int	eqtype(type_t *, type_t *, int, int, int *);
extern	void	compltyp(sym_t *, sym_t *);
extern	sym_t	*decl1arg(sym_t *, int);
extern	void	cluparg(void);
extern	void	decl1loc(sym_t *, int);
extern	sym_t	*aname(void);
extern	void	globclup(void);
extern	sym_t	*decl1abs(sym_t *);
extern	void	chksz(sym_t *);
extern	void	setsflg(sym_t *);
extern	void	setuflg(sym_t *, int, int);
extern	void	chkusage(dinfo_t *);
extern	void	chkusg1(int, sym_t *);
extern	void	chkglsyms(void);
extern	void	prevdecl(int, sym_t *);

/*
 * tree.c
 */
extern	void	initmtab(void);
extern	type_t	*incref(type_t *, tspec_t);
extern	type_t	*tincref(type_t *, tspec_t);
extern	tnode_t	*getcnode(type_t *, val_t *);
extern	tnode_t	*getnnode(sym_t *, int);
extern	tnode_t	*getsnode(strg_t *);
extern	sym_t	*strmemb(tnode_t *, op_t, sym_t *);
extern	tnode_t	*build(op_t, tnode_t *, tnode_t *);
extern	tnode_t	*cconv(tnode_t *);
extern	int	typeok(op_t, farg_t *, tnode_t *, tnode_t *);
extern	tnode_t	*promote(op_t, int, tnode_t *);
extern	tnode_t	*convert(op_t, farg_t *, type_t *, tnode_t *);
extern	void	cvtcon(op_t, farg_t *, type_t *, val_t *, val_t *);
extern	const	char *tyname(type_t *);
extern	tnode_t	*bldszof(type_t *);
extern	tnode_t	*bldszoftrm(tnode_t *);
extern	tnode_t	*cast(tnode_t *, type_t *);
extern	tnode_t	*funcarg(tnode_t *, tnode_t *);
extern	tnode_t	*funccall(tnode_t *, tnode_t *);
extern	val_t	*constant(tnode_t *);
extern	void	expr(tnode_t *, int, int);
extern	void	chkmisc(tnode_t *, int, int, int, int, int, int);
extern	int	conaddr(tnode_t *, sym_t **, ptrdiff_t *);
extern	strg_t	*catstrg(strg_t *, strg_t *);
extern	void	displexpr(tnode_t *, int);

/*
 * func.c
 */
extern	sym_t	*funcsym;
extern	int	reached;
extern	int	rchflg;
extern	int	ftflg;
extern	int	nargusg;
extern	pos_t	aupos;
extern	int	nvararg;
extern	pos_t	vapos;
extern	int	prflstrg;
extern	pos_t	prflpos;
extern	int	scflstrg;
extern	pos_t	scflpos;
extern	int	ccflg;
extern	int	llibflg;
extern	int	nowarn;
extern	int	noretflg;
extern	int	usedflg;
extern	int	plibflg;
extern	int	quadflg;

extern	void	pushctrl(int);
extern	void	popctrl(int);
extern	void	chkreach(void);
extern	void	funcdef(sym_t *);
extern	void	funcend(void);
extern	void	label(int, sym_t *, tnode_t *);
extern	void	if1(tnode_t *);
extern	void	if2(void);
extern	void	if3(int);
extern	void	switch1(tnode_t *);
extern	void	switch2(void);
extern	void	while1(tnode_t *);
extern	void	while2(void);
extern	void	do1(void);
extern	void	do2(tnode_t *);
extern	void	for1(tnode_t *, tnode_t *, tnode_t *);
extern	void	for2(void);
extern	void	dogoto(sym_t *);
extern	void	docont(void);
extern	void	dobreak(void);
extern	void	doreturn(tnode_t *);
extern	void	glclup(int);
extern	void	argsused(int);
extern	void	noreturn(int);
extern	void	lintused(int);
extern	void	constcond(int);
extern	void	fallthru(int);
extern	void	notreach(int);
extern	void	lintlib(int);
extern	void	linted(int);
extern	void	varargs(int);
extern	void	printflike(int);
extern	void	scanflike(int);
extern	void	protolib(int);
extern	void	longlong(int);

/*
 * init.c
 */
extern	int	initerr;
extern	sym_t	*initsym;
extern	int	startinit;

extern	void	prepinit(void);
extern	void	initrbr(void);
extern	void	initlbr(void);
extern	void	mkinit(tnode_t *);

/*
 * emit.c
 */
extern	void	outtype(type_t *);
extern	const	char *ttos(type_t *);
extern	void	outsym(sym_t *, scl_t, def_t);
extern	void	outfdef(sym_t *, pos_t *, int, int, sym_t *);
extern	void	outcall(tnode_t *, int, int);
extern	void	outusg(sym_t *);
@


1.16
log
@Teach lint about C99's _Bool and _Complex, plus some related gcc
extensions: __real__ and __imag__ operators, the use of '~' for
complex conjugation, and 'i' or 'j' as a suffix for complex constants.
While this doesn't handle folding and overflow detection for complex
constants correctly, it's good enough to make it through libm...and
found several bugs once it could do so.

"no objections" miod@@, krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: externs1.h,v 1.15 2006/05/29 20:47:22 cloder Exp $	*/
@


1.15
log
@Get rid of -t (traditional C) option. Some corrections by moritz.
@
text
@d1 1
a1 1
/*	$OpenBSD: externs1.h,v 1.14 2006/05/28 23:50:54 cloder Exp $	*/
d141 1
@


1.14
log
@Kill the bflag, which was really just used to shut up a useless warning
regarding unreachable breaks, we committed a smarter fix for this a while
back, so the flag is not needed anymore. Lint will still accept and
silently ignore this flag for now.
@
text
@d1 1
a1 1
/*	$OpenBSD: externs1.h,v 1.13 2006/05/28 23:42:49 cloder Exp $	*/
a47 1
extern	int	tflag;
@


1.13
log
@Kill the -a option for lint, which controlled (inconsistently) warnings
regarding narrowing conversions. For now, lint still accepts and ignores
the -a option, but soon I will remove it utterly and change the default
LINTFLAGS.
@
text
@d1 1
a1 1
/*	$OpenBSD: externs1.h,v 1.12 2006/04/20 16:29:48 cloder Exp $	*/
a37 1
extern	int	bflag;
@


1.12
log
@Add a LINTUSED special comment which marks the following declared symbol(s)
as used so that lint2 doesn't complain. Prodded by deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: externs1.h,v 1.11 2006/04/18 02:59:40 cloder Exp $	*/
a37 1
extern	int	aflag;
@


1.11
log
@The old way of passing function argument information was to pass an int
which corresponded to the argument # (1-based, with 0 meaning it is not
an argument). This sucked because it is impossible to include the function
name or argument name in warnings when all you have is an argument number.
Introduce a new type farg_t which represents a passed function argument.
struct farg contains argument number, function name, and argument symbol
information from the prototype).
@
text
@d1 1
a1 1
/*	$OpenBSD: externs1.h,v 1.10 2005/12/18 19:21:02 cloder Exp $	*/
d229 1
d257 1
@


1.10
log
@Grok NORETURN function prototypes in addition to NORETURN function
definitions.
@
text
@d1 1
a1 1
/*	$OpenBSD: externs1.h,v 1.9 2005/12/17 21:08:27 cloder Exp $	*/
d193 1
a193 1
extern	int	typeok(op_t, int, tnode_t *, tnode_t *);
d195 2
a196 2
extern	tnode_t	*convert(op_t, int, type_t *, tnode_t *);
extern	void	cvtcon(op_t, int, type_t *, val_t *, val_t *);
@


1.9
log
@Handle __dead functions using lint comments.
@
text
@d1 1
a1 1
/*	$OpenBSD: externs1.h,v 1.8 2005/12/12 23:35:59 cloder Exp $	*/
d228 1
@


1.8
log
@Cut down on extraneous "constant in conditional context" warnings when
lint encounters expressions like do { ... } while (0); and if (1) ...
We use these idioms frequently in our tree for scoping purposes and we
deem them to be safe.  Now lint will not warn if it encounters a constant
in a conditional context when the expression consists only of a constant
(with no operators) and the constant is 0 or 1.  This means that lint
will not warn for "if (1)" but will warn for "if (2)" and will also
continue to warn for "if (foo && 1)".  This cuts down the vast majority
of these warnings while still preserving the ability to catch bugs.
@
text
@d1 1
a1 1
/*	$OpenBSD: externs1.h,v 1.7 2005/12/10 18:42:45 cloder Exp $	*/
d254 1
@


1.7
log
@Lint now warns about sizeof(term) where the operator is anything other
than unary *, ->, a name, or a string.
@
text
@d1 1
a1 1
/*	$OpenBSD: externs1.h,v 1.6 2005/12/10 17:51:49 cloder Exp $	*/
d208 1
@


1.6
log
@Add a new lint flag '-f' which, for each warning or error, prints the
offending line from the corresponding source code file.  The general
idea is OK deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: externs1.h,v 1.5 2005/12/10 17:41:03 cloder Exp $	*/
d199 1
@


1.5
log
@Back out all gcc attribute parsing changes until we can do this the right
way some day.  The effect of __attribute__ on a LALR C grammar is just too
ugly to fix quicklly.
@
text
@d1 1
a1 1
/*	$OpenBSD: externs1.h,v 1.3 2002/02/16 21:27:59 millert Exp $	*/
d43 1
@


1.4
log
@Refactor __attribute__ parsing a bit.  This takes us further to being able
to not only consume, but also make sense of gcc __attribute__ syntax.
@
text
@a74 1
attr_t	getkwattr(int, int);
a260 11

/*
 * attr.c
 */
extern	attr_t		getattr(const char *);
extern	attr_t		getqualattr(tqual_t);
extern	attrnode_t	*newattrnode(attr_t);
extern	void		appendattr(attrnode_t*, attr_t);
extern	void		appendattrnode(attrnode_t*, attrnode_t*);
extern	void		addattr(type_t *, attrnode_t*);
extern	int		hasattr(type_t *, attr_t);
@


1.3
log
@Part one of userland __P removal.  Done with a simple regexp with some minor hand editing to make comments line up correctly.  Another pass is forthcoming that handles the cases that could not be done automatically.
@
text
@d1 1
a1 1
/*	$OpenBSD: externs1.h,v 1.2 1996/06/26 05:44:12 deraadt Exp $	*/
d75 1
d262 11
@


1.2
log
@rcsid
@
text
@d1 1
a1 1
/*	$OpenBSD: externs1.h,v 1.7 1995/10/02 17:31:39 jpo Exp $	*/
d55 1
a55 1
extern	void	norecover __P((void));
d64 2
a65 2
extern	int	yyerror __P((char *));
extern	int	yyparse __P((void));
d76 13
a88 13
extern	void	initscan __P((void));
extern	int	sign __P((quad_t, tspec_t, int));
extern	int	msb __P((quad_t, tspec_t, int));
extern	quad_t	xsign __P((quad_t, tspec_t, int));
extern	void	clrwflgs __P((void));
extern	sym_t	*getsym __P((sbuf_t *));
extern	void	cleanup __P((void));
extern	sym_t	*pushdown __P((sym_t *));
extern	void	rmsym __P((sym_t *));
extern	void	rmsyms __P((sym_t *));
extern	void	inssym __P((int, sym_t *));
extern	void	freeyyv __P((void *, int));
extern	int	yylex __P((void));
d93 16
a108 16
extern	const	char *fnalloc __P((const char *));
extern	const	char *fnnalloc __P((const char *, size_t));
extern	int	getfnid __P((const char *));

extern	void	initmem __P((void));

extern	void	*getblk __P((size_t));
extern	void	*getlblk __P((int, size_t));
extern	void	freeblk __P((void));
extern	void	freelblk __P((int));

extern	void	*tgetblk __P((size_t));
extern	tnode_t	*getnode __P((void));
extern	void	tfreeblk __P((void));
extern	struct	mbl *tsave __P((void));
extern	void	trestor __P((struct mbl *));
d117 5
a121 5
extern	void	error __P((int, ...));
extern	void	warning __P((int, ...));
extern	void	message __P((int, ...));
extern	int	gnuism __P((int, ...));
extern	void	lerror __P((const char *, ...));
d130 49
a178 49
extern	void	initdecl __P((void));
extern	type_t	*gettyp __P((tspec_t));
extern	type_t	*duptyp __P((const type_t *));
extern	type_t	*tduptyp __P((const type_t *));
extern	int	incompl __P((type_t *));
extern	void	setcompl __P((type_t *, int));
extern	void	addscl __P((scl_t));
extern	void	addtype __P((type_t *));
extern	void	addqual	__P((tqual_t));
extern	void	pushdecl __P((scl_t));
extern	void	popdecl __P((void));
extern	void	setasm __P((void));
extern	void	clrtyp __P((void));
extern	void	deftyp __P((void));
extern	int	length __P((type_t *, const char *));
extern	int	getbound __P((type_t *));
extern	sym_t	*lnklst __P((sym_t *, sym_t *));
extern	void	chktyp __P((sym_t *));
extern	sym_t	*decl1str __P((sym_t *));
extern	sym_t	*bitfield __P((sym_t *, int));
extern	pqinf_t	*mergepq __P((pqinf_t *, pqinf_t *));
extern	sym_t	*addptr __P((sym_t *, pqinf_t *));
extern	sym_t	*addarray __P((sym_t *, int, int));
extern	sym_t	*addfunc __P((sym_t *, sym_t *));
extern	void	chkfdef __P((sym_t *, int));
extern	sym_t	*dname __P((sym_t *));
extern	sym_t	*iname __P((sym_t *));
extern	type_t	*mktag __P((sym_t *, tspec_t, int, int));
extern	const	char *scltoa __P((scl_t));
extern	type_t	*compltag __P((type_t *, sym_t *));
extern	sym_t	*ename __P((sym_t *, int, int));
extern	void	decl1ext __P((sym_t *, int));
extern	void	cpuinfo __P((sym_t *, sym_t *));
extern	int	isredec __P((sym_t *, int *));
extern	int	eqtype __P((type_t *, type_t *, int, int, int *));
extern	void	compltyp __P((sym_t *, sym_t *));
extern	sym_t	*decl1arg __P((sym_t *, int));
extern	void	cluparg __P((void));
extern	void	decl1loc __P((sym_t *, int));
extern	sym_t	*aname __P((void));
extern	void	globclup __P((void));
extern	sym_t	*decl1abs __P((sym_t *));
extern	void	chksz __P((sym_t *));
extern	void	setsflg __P((sym_t *));
extern	void	setuflg __P((sym_t *, int, int));
extern	void	chkusage __P((dinfo_t *));
extern	void	chkusg1 __P((int, sym_t *));
extern	void	chkglsyms __P((void));
extern	void	prevdecl __P((int, sym_t *));
d183 23
a205 23
extern	void	initmtab __P((void));
extern	type_t	*incref __P((type_t *, tspec_t));
extern	type_t	*tincref __P((type_t *, tspec_t));
extern	tnode_t	*getcnode __P((type_t *, val_t *));
extern	tnode_t	*getnnode __P((sym_t *, int));
extern	tnode_t	*getsnode __P((strg_t *));
extern	sym_t	*strmemb __P((tnode_t *, op_t, sym_t *));
extern	tnode_t	*build __P((op_t, tnode_t *, tnode_t *));
extern	tnode_t	*cconv __P((tnode_t *));
extern	int	typeok __P((op_t, int, tnode_t *, tnode_t *));
extern	tnode_t	*promote __P((op_t, int, tnode_t *));
extern	tnode_t	*convert __P((op_t, int, type_t *, tnode_t *));
extern	void	cvtcon __P((op_t, int, type_t *, val_t *, val_t *));
extern	const	char *tyname __P((type_t *));
extern	tnode_t	*bldszof __P((type_t *));
extern	tnode_t	*cast __P((tnode_t *, type_t *));
extern	tnode_t	*funcarg __P((tnode_t *, tnode_t *));
extern	tnode_t	*funccall __P((tnode_t *, tnode_t *));
extern	val_t	*constant __P((tnode_t *));
extern	void	expr __P((tnode_t *, int, int));
extern	void	chkmisc __P((tnode_t *, int, int, int, int, int, int));
extern	int	conaddr __P((tnode_t *, sym_t **, ptrdiff_t *));
extern	strg_t	*catstrg __P((strg_t *, strg_t *));
d228 33
a260 33
extern	void	pushctrl __P((int));
extern	void	popctrl __P((int));
extern	void	chkreach __P((void));
extern	void	funcdef __P((sym_t *));
extern	void	funcend __P((void));
extern	void	label __P((int, sym_t *, tnode_t *));
extern	void	if1 __P((tnode_t *));
extern	void	if2 __P((void));
extern	void	if3 __P((int));
extern	void	switch1 __P((tnode_t *));
extern	void	switch2 __P((void));
extern	void	while1 __P((tnode_t *));
extern	void	while2 __P((void));
extern	void	do1 __P((void));
extern	void	do2 __P((tnode_t *));
extern	void	for1 __P((tnode_t *, tnode_t *, tnode_t *));
extern	void	for2 __P((void));
extern	void	dogoto __P((sym_t *));
extern	void	docont __P((void));
extern	void	dobreak __P((void));
extern	void	doreturn __P((tnode_t *));
extern	void	glclup __P((int));
extern	void	argsused __P((int));
extern	void	constcond __P((int));
extern	void	fallthru __P((int));
extern	void	notreach __P((int));
extern	void	lintlib __P((int));
extern	void	linted __P((int));
extern	void	varargs __P((int));
extern	void	printflike __P((int));
extern	void	scanflike __P((int));
extern	void	protolib __P((int));
extern	void	longlong __P((int));
d269 4
a272 4
extern	void	prepinit __P((void));
extern	void	initrbr __P((void));
extern	void	initlbr __P((void));
extern	void	mkinit __P((tnode_t *));
d277 6
a282 6
extern	void	outtype __P((type_t *));
extern	const	char *ttos __P((type_t *));
extern	void	outsym __P((sym_t *, scl_t, def_t));
extern	void	outfdef __P((sym_t *, pos_t *, int, int, sym_t *));
extern	void	outcall __P((tnode_t *, int, int));
extern	void	outusg __P((sym_t *));
@


1.1
log
@Initial revision
@
text
@d1 1
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@
