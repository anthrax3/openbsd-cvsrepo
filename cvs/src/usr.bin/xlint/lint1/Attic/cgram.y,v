head	1.25;
access;
symbols
	OPENBSD_5_1_BASE:1.24
	OPENBSD_5_1:1.24.0.2
	OPENBSD_5_0:1.23.0.2
	OPENBSD_5_0_BASE:1.23
	OPENBSD_4_9:1.22.0.14
	OPENBSD_4_9_BASE:1.22
	OPENBSD_4_8:1.22.0.12
	OPENBSD_4_8_BASE:1.22
	OPENBSD_4_7:1.22.0.8
	OPENBSD_4_7_BASE:1.22
	OPENBSD_4_6:1.22.0.10
	OPENBSD_4_6_BASE:1.22
	OPENBSD_4_5:1.22.0.6
	OPENBSD_4_5_BASE:1.22
	OPENBSD_4_4:1.22.0.4
	OPENBSD_4_4_BASE:1.22
	OPENBSD_4_3:1.22.0.2
	OPENBSD_4_3_BASE:1.22
	OPENBSD_4_2:1.21.0.2
	OPENBSD_4_2_BASE:1.21
	OPENBSD_4_1:1.20.0.4
	OPENBSD_4_1_BASE:1.20
	OPENBSD_4_0:1.20.0.2
	OPENBSD_4_0_BASE:1.20
	OPENBSD_3_9:1.17.0.2
	OPENBSD_3_9_BASE:1.17
	OPENBSD_3_8:1.5.0.8
	OPENBSD_3_8_BASE:1.5
	OPENBSD_3_7:1.5.0.6
	OPENBSD_3_7_BASE:1.5
	OPENBSD_3_6:1.5.0.4
	OPENBSD_3_6_BASE:1.5
	OPENBSD_3_5:1.5.0.2
	OPENBSD_3_5_BASE:1.5
	OPENBSD_3_4:1.4.0.8
	OPENBSD_3_4_BASE:1.4
	OPENBSD_3_3:1.4.0.6
	OPENBSD_3_3_BASE:1.4
	OPENBSD_3_2:1.4.0.4
	OPENBSD_3_2_BASE:1.4
	OPENBSD_3_1:1.4.0.2
	OPENBSD_3_1_BASE:1.4
	OPENBSD_3_0:1.3.0.22
	OPENBSD_3_0_BASE:1.3
	OPENBSD_2_9_BASE:1.3
	OPENBSD_2_9:1.3.0.20
	OPENBSD_2_8:1.3.0.18
	OPENBSD_2_8_BASE:1.3
	OPENBSD_2_7:1.3.0.16
	OPENBSD_2_7_BASE:1.3
	OPENBSD_2_6:1.3.0.14
	OPENBSD_2_6_BASE:1.3
	OPENBSD_2_5:1.3.0.12
	OPENBSD_2_5_BASE:1.3
	OPENBSD_2_4:1.3.0.10
	OPENBSD_2_4_BASE:1.3
	OPENBSD_2_3:1.3.0.8
	OPENBSD_2_3_BASE:1.3
	OPENBSD_2_2:1.3.0.6
	OPENBSD_2_2_BASE:1.3
	OPENBSD_2_1:1.3.0.4
	OPENBSD_2_1_BASE:1.3
	OPENBSD_2_0:1.3.0.2
	OPENBSD_2_0_BASE:1.3
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.25
date	2012.04.08.16.27.00;	author jsg;	state dead;
branches;
next	1.24;

1.24
date	2011.09.21.18.08.07;	author jsg;	state Exp;
branches;
next	1.23;

1.23
date	2011.05.31.22.00.07;	author martynas;	state Exp;
branches;
next	1.22;

1.22
date	2007.09.08.17.49.18;	author cloder;	state Exp;
branches;
next	1.21;

1.21
date	2007.04.24.16.47.36;	author miod;	state Exp;
branches;
next	1.20;

1.20
date	2006.05.29.20.47.22;	author cloder;	state Exp;
branches;
next	1.19;

1.19
date	2006.04.21.23.17.10;	author cloder;	state Exp;
branches;
next	1.18;

1.18
date	2006.04.20.16.29.48;	author cloder;	state Exp;
branches;
next	1.17;

1.17
date	2005.12.10.18.42.45;	author cloder;	state Exp;
branches;
next	1.16;

1.16
date	2005.12.10.17.41.03;	author cloder;	state Exp;
branches;
next	1.15;

1.15
date	2005.12.07.01.55.12;	author cloder;	state Exp;
branches;
next	1.14;

1.14
date	2005.12.03.00.27.54;	author cloder;	state Exp;
branches;
next	1.13;

1.13
date	2005.11.30.18.47.11;	author deraadt;	state Exp;
branches;
next	1.12;

1.12
date	2005.11.30.06.33.49;	author cloder;	state Exp;
branches;
next	1.11;

1.11
date	2005.11.29.19.50.33;	author cloder;	state Exp;
branches;
next	1.10;

1.10
date	2005.11.23.22.57.36;	author cloder;	state Exp;
branches;
next	1.9;

1.9
date	2005.11.23.22.25.36;	author cloder;	state Exp;
branches;
next	1.8;

1.8
date	2005.11.23.18.47.40;	author cloder;	state Exp;
branches;
next	1.7;

1.7
date	2005.11.23.09.05.42;	author deraadt;	state Exp;
branches;
next	1.6;

1.6
date	2005.11.23.08.53.37;	author deraadt;	state Exp;
branches;
next	1.5;

1.5
date	2003.11.08.19.17.29;	author jmc;	state Exp;
branches;
next	1.4;

1.4
date	2002.02.16.21.27.59;	author millert;	state Exp;
branches;
next	1.3;

1.3
date	96.06.26.05.44.08;	author deraadt;	state Exp;
branches;
next	1.2;

1.2
date	96.03.05.08.48.15;	author tholo;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.47.01;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.47.01;	author deraadt;	state Exp;
branches;
next	;


desc
@@


1.25
log
@tedu lint
ok tedu@@ guenther@@ krw@@ espie@@ deraadt@@
@
text
@%{
/*	$OpenBSD: cgram.y,v 1.24 2011/09/21 18:08:07 jsg Exp $	*/
/*	$NetBSD: cgram.y,v 1.8 1995/10/02 17:31:35 jpo Exp $	*/

/*
 * Copyright (c) 1994, 1995 Jochen Pohl
 * All Rights Reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *      This product includes software developed by Jochen Pohl for
 *	The NetBSD Project.
 * 4. The name of the author may not be used to endorse or promote products
 *    derived from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
 * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
 * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

#include <stdlib.h>
#include <limits.h>

#include "lint1.h"

/*
 * Contains the level of current declaration. 0 is extern.
 * Used for symbol table entries.
 */
int	blklev;

/*
 * level for memory allocation. Normaly the same as blklev.
 * An exception is the declaration of arguments in prototypes. Memory
 * for these can't be freed after the declaration, but symbols must
 * be removed from the symbol table after the declaration.
 */
int	mblklev;

/*
 * Is the statement empty?
 */
int	estmnt;

static	int	toicon(tnode_t *);
static	void	idecl(sym_t *, int);
static	void	ignuptorp(void);

%}

%union {
	int	y_int;
	val_t	*y_val;
	sbuf_t	*y_sb;
	sym_t	*y_sym;
	op_t	y_op;
	scl_t	y_scl;
	tspec_t	y_tspec;
	tqual_t	y_tqual;
	type_t	*y_type;
	tnode_t	*y_tnode;
	strg_t	*y_strg;
	pqinf_t	*y_pqinf;
};

%token			T_LBRACE T_RBRACE T_LBRACK T_RBRACK T_LPARN T_RPARN
%token	<y_op>		T_STROP
%token	<y_op>		T_UNOP
%token	<y_op>		T_INCDEC
%token			T_SIZEOF
%token	<y_op>		T_MULT
%token	<y_op>		T_DIVOP
%token	<y_op>		T_ADDOP
%token	<y_op>		T_SHFTOP
%token	<y_op>		T_RELOP
%token	<y_op>		T_EQOP
%token	<y_op>		T_AND
%token	<y_op>		T_XOR
%token	<y_op>		T_OR
%token	<y_op>		T_LOGAND
%token	<y_op>		T_LOGOR
%token			T_QUEST
%token			T_COLON
%token	<y_op>		T_ASSIGN
%token	<y_op>		T_OPASS
%token			T_COMMA
%token			T_SEMI
%token			T_ELLIPSE

/* storage classes (extern, static, auto, register and typedef) */
%token	<y_scl>		T_SCLASS

/* types (char, int, short, long, unsigned, signed, float, double, void) */
%token	<y_tspec>	T_TYPE

/* qualifiers (const, volatile, restrict) */
%token	<y_tqual>	T_QUAL

/* struct or union */
%token	<y_tspec>	T_SOU

/* enum */
%token			T_ENUM

/* remaining keywords */
%token			T_CASE
%token			T_DEFAULT
%token			T_IF
%token			T_ELSE
%token			T_SWITCH
%token			T_DO
%token			T_WHILE
%token			T_FOR
%token			T_GOTO
%token			T_CONTINUE
%token			T_BREAK
%token			T_RETURN
%token			T_ASM
%token			T_LEQUAL
%token			T_ATTRIBUTE

%left	T_COMMA
%right	T_ASSIGN T_OPASS
%right	T_QUEST T_COLON
%left	T_LOGOR
%left	T_LOGAND
%left	T_OR
%left	T_XOR
%left	T_AND
%left	T_EQOP
%left	T_RELOP
%left	T_SHFTOP
%left	T_ADDOP
%left	T_MULT T_DIVOP
%right	T_UNOP T_INCDEC T_SIZEOF
%left	T_LPARN T_LBRACK T_STROP

%token	<y_sb>		T_NAME
%token	<y_sb>		T_TYPENAME
%token	<y_val>		T_CON
%token	<y_strg>	T_STRING

%type	<y_sym>		func_decl
%type	<y_sym>		notype_decl
%type	<y_sym>		type_decl
%type	<y_type>	typespec
%type	<y_type>	clrtyp_typespec
%type	<y_type>	notype_typespec
%type	<y_type>	struct_spec
%type	<y_type>	enum_spec
%type	<y_sym>		struct_tag
%type	<y_sym>		enum_tag
%type	<y_tspec>	struct
%type	<y_sym>		struct_declaration
%type	<y_sb>		identifier
%type	<y_sym>		member_declaration_list_with_rbrace
%type	<y_sym>		member_declaration_list
%type	<y_sym>		member_declaration
%type	<y_sym>		notype_member_decls
%type	<y_sym>		type_member_decls
%type	<y_sym>		notype_member_decl
%type	<y_sym>		type_member_decl
%type	<y_tnode>	constant
%type	<y_sym>		enum_declaration
%type	<y_sym>		enums_with_opt_comma
%type	<y_sym>		enums
%type	<y_sym>		enumerator
%type	<y_sym>		ename
%type	<y_sym>		notype_direct_decl
%type	<y_sym>		type_direct_decl
%type	<y_pqinf>	pointer
%type	<y_pqinf>	asterisk
%type	<y_sym>		param_decl
%type	<y_sym>		param_list
%type	<y_sym>		abs_decl_param_list
%type	<y_sym>		direct_param_decl
%type	<y_sym>		notype_param_decl
%type	<y_sym>		direct_notype_param_decl
%type	<y_pqinf>	type_qualifier_list
%type	<y_pqinf>	type_qualifier
%type	<y_sym>		identifier_list
%type	<y_sym>		abs_decl
%type	<y_sym>		direct_abs_decl
%type	<y_sym>		vararg_parameter_type_list
%type	<y_sym>		parameter_type_list
%type	<y_sym>		parameter_declaration
%type	<y_tnode>	expr
%type	<y_tnode>	term
%type	<y_tnode>	func_arg_list
%type	<y_op>		point_or_arrow
%type	<y_type>	type_name
%type	<y_sym>		abstract_declaration
%type	<y_tnode>	do_while_expr
%type	<y_tnode>	opt_expr
%type	<y_strg>	string
%type	<y_strg>	string2


%%

program:
	  /* empty */ {
		if (sflag) {
			/* empty translation unit */
			error(272);
		} else {
			/* empty translation unit */
			warning(272);
		}
	  }
	| translation_unit
	;

translation_unit:
	  ext_decl
	| translation_unit ext_decl
	;

ext_decl:
	  func_def {
		glclup(0);
		clrwflgs();
	  }
	| data_def {
		glclup(0);
		clrwflgs();
	  }
	| T_LEQUAL T_LPARN identifier T_COMMA identifier T_RPARN T_SEMI {
		sym_t *new, *old;

		if ($5->sb_sym && $3->sb_sym /*== NULL*/) {
			new = getsym($5);
			old = $3->sb_sym;
			new->s_dpos = old->s_dpos;
			new->s_spos = old->s_spos;
			new->s_upos = old->s_upos;
			new->s_kind = old->s_kind;
			new->s_keyw = old->s_keyw;
			new->s_field = old->s_field;
			new->s_set = old->s_set;
			new->s_used = old->s_used;
			new->s_arg = old->s_arg;
			new->s_reg = old->s_reg;
			new->s_defarg = old->s_defarg;
			new->s_rimpl = old->s_rimpl;
			new->s_osdef = old->s_osdef;
			new->s_inline = old->s_inline;
			new->s_noreturn = old->s_noreturn;
			new->s_def = old->s_def;
			new->s_scl = old->s_scl;
			new->s_blklev = old->s_blklev;
			new->s_type = old->s_type;
			new->s_value = old->s_value;
			new->u = old->u;

			/* XXX missing 'r' because do not know return type
			   of parent... */
			/* outsym(new, new->s_scl, DEF); */
			outfdef(new, &csrc_pos,
			    new->s_rimpl || new->s_type->t_subt->t_tspec != VOID,
			    0, NULL);
		}

	  }
	;

data_def: T_SEMI
	| clrtyp deftyp notype_init_decls T_SEMI {
		if (sflag) {
			/* old style declaration; add "int" */
			error(1);
		} else {
			/* old style declaration; add "int" */
			warning(1);
		}
	  }
	| declmods deftyp T_SEMI {
		if (dcs->d_scl == TYPEDEF) {
			/* typedef declares no type name */
			warning(72);
		} else {
			/* empty declaration */
			warning(2);
		}
	  }
	| declmods deftyp notype_init_decls T_SEMI
	| declspecs deftyp T_SEMI {
		if (dcs->d_scl == TYPEDEF) {
			/* typedef declares no type name */
			warning(72);
		} else if (!dcs->d_nedecl) {
			/* empty declaration */
			warning(2);
		}
	  }
	| declspecs deftyp type_init_decls opt_attribute_spec T_SEMI
	| error T_SEMI {
		globclup();
	  }
	| error T_RBRACE {
		globclup();
	  }
	;

func_def:
	  func_decl {
		if ($1->s_type->t_tspec != FUNC) {
			/* syntax error */
			error(249);
			YYERROR;
		}
		if ($1->s_type->t_typedef) {
			/* ()-less function definition */
			error(64);
			YYERROR;
		}
		funcdef($1);
		blklev++;
		pushdecl(ARG);
	  } opt_arg_declaration_list {
		popdecl();
		blklev--;
		cluparg();
		pushctrl(0);
	  } comp_stmnt {
		funcend();
		popctrl(0);
	  }
	;

opt_attribute_spec:
	/* empty */
	| T_ATTRIBUTE T_LPARN T_LPARN read_until_rparn T_RPARN
	;

func_decl:
	  clrtyp deftyp notype_decl {
		$$ = $3;
	  }
	| declmods deftyp notype_decl {
		$$ = $3;
	  }
	| declspecs deftyp type_decl {
		$$ = $3;
	  }
	;

opt_arg_declaration_list:
	  /* empty */
	| arg_declaration_list
	;

arg_declaration_list:
	  arg_declaration
	| arg_declaration_list arg_declaration
	/* XXX or better "arg_declaration error" ? */
	| error
	;

/*
 * "arg_declaration" is separated from "declaration" because it
 * needs other error handling.
 */

arg_declaration:
	  declmods deftyp T_SEMI {
		/* empty declaration */
		warning(2);
	  }
	| declmods deftyp notype_init_decls T_SEMI
	| declspecs deftyp T_SEMI {
		if (!dcs->d_nedecl) {
			/* empty declaration */
			warning(2);
		} else {
			tspec_t	ts = dcs->d_type->t_tspec;
			/* %s declared in argument declaration list */
			warning(3, ts == STRUCT ? "struct" :
				(ts == UNION ? "union" : "enum"));
		}
	  }
	| declspecs deftyp type_init_decls T_SEMI {
		if (dcs->d_nedecl) {
			tspec_t	ts = dcs->d_type->t_tspec;
			/* %s declared in argument declaration list */
			warning(3, ts == STRUCT ? "struct" :
				(ts == UNION ? "union" : "enum"));
		}
	  }
	| declmods error
	| declspecs error
	;

declaration:
	  declmods deftyp T_SEMI {
		if (dcs->d_scl == TYPEDEF) {
			/* typedef declares no type name */
			warning(72);
		} else {
			/* empty declaration */
			warning(2);
		}
	  }
	| declmods deftyp notype_init_decls T_SEMI
	| declspecs deftyp T_SEMI {
		if (dcs->d_scl == TYPEDEF) {
			/* typedef declares no type name */
			warning(72);
		} else if (!dcs->d_nedecl) {
			/* empty declaration */
			warning(2);
		}
	  }
	| declspecs deftyp type_init_decls T_SEMI
	| error T_SEMI
	;

clrtyp:
	  {
		clrtyp();
	  }
	;

deftyp:
	  /* empty */ {
		deftyp();
	  }
	;

declspecs:
	  clrtyp_typespec {
		addtype($1);
	  }
	| declmods typespec {
		addtype($2);
	  }
	| declspecs declmod
	| declspecs notype_typespec {
		addtype($2);
	  }
	;

declmods:
	  clrtyp T_QUAL {
		addqual($2);
	  }
	| clrtyp T_SCLASS {
		addscl($2);
	  }
	| declmods declmod
	;

declmod:
	  T_QUAL {
		addqual($1);
	  }
	| T_SCLASS {
		addscl($1);
	  }
	;

clrtyp_typespec:
	  clrtyp notype_typespec {
		$$ = $2;
	  }
	| T_TYPENAME clrtyp {
		$$ = getsym($1)->s_type;
	  }
	;

typespec:
	  notype_typespec {
		$$ = $1;
	  }
	| T_TYPENAME {
		$$ = getsym($1)->s_type;
	  }
	;

notype_typespec:
	  T_TYPE {
		$$ = gettyp($1);
	  }
	| struct_spec {
		popdecl();
		$$ = $1;
	  }
	| enum_spec {
		popdecl();
		$$ = $1;
	  }
	;

struct_spec:
	  struct struct_tag {
		/*
		 * STDC requires that "struct a;" always introduces
		 * a new tag if "a" is not declared at current level
		 *
		 * yychar is valid because otherwise the parser would
		 * not been able to deceide if he must shift or reduce
		 */
		$$ = mktag($2, $1, 0, yychar == T_SEMI);
	  }
	| struct struct_tag {
		dcs->d_tagtyp = mktag($2, $1, 1, 0);
	  } struct_declaration {
		$$ = compltag(dcs->d_tagtyp, $4);
	  }
	| struct {
		dcs->d_tagtyp = mktag(NULL, $1, 1, 0);
	  } struct_declaration {
		$$ = compltag(dcs->d_tagtyp, $3);
	  }
	| struct error {
		symtyp = FVFT;
		$$ = gettyp(INT);
	  }
	;

struct:
	  T_SOU {
		symtyp = FTAG;
		pushdecl($1 == STRUCT ? MOS : MOU);
		dcs->d_offset = 0;
		dcs->d_stralign = CHAR_BIT;
		$$ = $1;
	  }
	;

struct_tag:
	  identifier {
		$$ = getsym($1);
	  }
	;

struct_declaration:
	  struct_decl_lbrace member_declaration_list_with_rbrace {
		$$ = $2;
	  }
	;

struct_decl_lbrace:
	  T_LBRACE {
		symtyp = FVFT;
	  }
	;

member_declaration_list_with_rbrace:
	  member_declaration_list T_SEMI T_RBRACE {
		$$ = $1;
	  }
	| member_declaration_list T_RBRACE {
		if (sflag) {
			/* syntax req. ";" after last struct/union member */
			error(66);
		} else {
			/* syntax req. ";" after last struct/union member */
			warning(66);
		}
		$$ = $1;
	  }
	| T_RBRACE {
		$$ = NULL;
	  }
	;

member_declaration_list:
	  member_declaration {
		$$ = $1;
	  }
	| member_declaration_list T_SEMI member_declaration {
		$$ = lnklst($1, $3);
	  }
	;

member_declaration:
	  noclass_declmods deftyp {
		/* too late, i know, but getsym() compensates it */
		symtyp = FMOS;
	  } notype_member_decls {
		symtyp = FVFT;
		$$ = $4;
	  }
	| noclass_declspecs deftyp {
		symtyp = FMOS;
	  } type_member_decls {
		symtyp = FVFT;
		$$ = $4;
	  }
	| noclass_declmods deftyp {
		/* struct or union member must be named */
		warning(49);
		$$ = NULL;
	  }
	| noclass_declspecs deftyp {
		/* struct or union member must be named */
		warning(49);
		$$ = NULL;
	  }
	| error {
		symtyp = FVFT;
		$$ = NULL;
	  }
	;

noclass_declspecs:
	  clrtyp_typespec {
		addtype($1);
	  }
	| noclass_declmods typespec {
		addtype($2);
	  }
	| noclass_declspecs T_QUAL {
		addqual($2);
	  }
	| noclass_declspecs notype_typespec {
		addtype($2);
	  }
	;

noclass_declmods:
	  clrtyp T_QUAL {
		addqual($2);
	  }
	| noclass_declmods T_QUAL {
		addqual($2);
	  }
	;

notype_member_decls:
	  notype_member_decl {
		$$ = decl1str($1);
	  }
	| notype_member_decls {
		symtyp = FMOS;
	  } T_COMMA type_member_decl {
		$$ = lnklst($1, decl1str($4));
	  }
	;

type_member_decls:
	  type_member_decl {
		$$ = decl1str($1);
	  }
	| type_member_decls {
		symtyp = FMOS;
	  } T_COMMA type_member_decl {
		$$ = lnklst($1, decl1str($4));
	  }
	;

notype_member_decl:
	  notype_decl {
		$$ = $1;
	  }
	| notype_decl T_COLON constant {
		$$ = bitfield($1, toicon($3));
	  }
	| {
		symtyp = FVFT;
	  } T_COLON constant {
		$$ = bitfield(NULL, toicon($3));
	  }
	;

type_member_decl:
	  type_decl {
		$$ = $1;
	  }
	| type_decl T_COLON constant {
		$$ = bitfield($1, toicon($3));
	  }
	| {
		symtyp = FVFT;
	  } T_COLON constant {
		$$ = bitfield(NULL, toicon($3));
	  }
	;

enum_spec:
	  enum enum_tag {
		$$ = mktag($2, ENUM, 0, 0);
	  }
	| enum enum_tag {
		dcs->d_tagtyp = mktag($2, ENUM, 1, 0);
	  } enum_declaration {
		$$ = compltag(dcs->d_tagtyp, $4);
	  }
	| enum {
		dcs->d_tagtyp = mktag(NULL, ENUM, 1, 0);
	  } enum_declaration {
		$$ = compltag(dcs->d_tagtyp, $3);
	  }
	| enum error {
		symtyp = FVFT;
		$$ = gettyp(INT);
	  }
	;

enum:
	  T_ENUM {
		symtyp = FTAG;
		pushdecl(ENUMCON);
	  }
	;

enum_tag:
	  identifier {
		$$ = getsym($1);
	  }
	;

enum_declaration:
	  enum_decl_lbrace enums_with_opt_comma T_RBRACE {
		$$ = $2;
	  }
	;

enum_decl_lbrace:
	  T_LBRACE {
		symtyp = FVFT;
		enumval = 0;
	  }
	;

enums_with_opt_comma:
	  enums {
		$$ = $1;
	  }
	| enums T_COMMA {
		$$ = $1;
	  }
	;

enums:
	  enumerator {
		$$ = $1;
	  }
	| enums T_COMMA enumerator {
		$$ = lnklst($1, $3);
	  }
	| error {
		$$ = NULL;
	  }
	;

enumerator:
	  ename {
		$$ = ename($1, enumval, 1);
	  }
	| ename T_ASSIGN constant {
		$$ = ename($1, toicon($3), 0);
	  }
	;

ename:
	  identifier {
		$$ = getsym($1);
	  }
	;


notype_init_decls:
	  notype_init_decl
	| notype_init_decls T_COMMA type_init_decl
	;

type_init_decls:
	  type_init_decl
	| type_init_decls T_COMMA type_init_decl
	;

notype_init_decl:
	  notype_decl opt_attribute_spec opt_asm_spec {
		idecl($1, 0);
		chksz($1);
	  }
	| notype_decl opt_asm_spec {
		idecl($1, 1);
	  } T_ASSIGN initializer {
		chksz($1);
	  }
	;

type_init_decl:
	  type_decl opt_asm_spec {
		idecl($1, 0);
		chksz($1);
	  }
	| type_decl opt_asm_spec {
		idecl($1, 1);
	  } T_ASSIGN initializer {
		chksz($1);
	  }
	;

notype_decl:
	  notype_direct_decl {
		$$ = $1;
	  }
	| pointer notype_direct_decl {
		$$ = addptr($2, $1);
	  }
	;

notype_direct_decl:
	  T_NAME {
		$$ = dname(getsym($1));
	  }
	| T_LPARN type_decl T_RPARN {
		$$ = $2;
	  }
	| notype_direct_decl T_LBRACK T_RBRACK {
		$$ = addarray($1, 0, 0);
	  }
	| notype_direct_decl T_LBRACK constant T_RBRACK {
		$$ = addarray($1, 1, toicon($3));
	  }
	| notype_direct_decl param_list {
		$$ = addfunc($1, $2);
		popdecl();
		blklev--;
	  }
	;

type_decl:
	  type_direct_decl {
		$$ = $1;
	  }
	| pointer type_direct_decl {
		$$ = addptr($2, $1);
	  }
	;

type_direct_decl:
	  identifier {
		$$ = dname(getsym($1));
	  }
	| T_LPARN type_decl T_RPARN {
		$$ = $2;
	  }
	| type_direct_decl T_LBRACK T_RBRACK {
		$$ = addarray($1, 0, 0);
	  }
	| type_direct_decl T_LBRACK constant T_RBRACK {
		$$ = addarray($1, 1, toicon($3));
	  }
	| type_direct_decl param_list {
		$$ = addfunc($1, $2);
		popdecl();
		blklev--;
	  }
	;

/*
 * param_decl and notype_param_decl exist to avoid a conflict in
 * argument lists. A typename enclosed in parens should always be
 * treated as a typename, not an argument.
 * "typedef int a; f(int (a));" is  "typedef int a; f(int foo(a));"
 *				not "typedef int a; f(int a);"
 */
param_decl:
	  direct_param_decl {
		$$ = $1;
	  }
	| pointer direct_param_decl {
		$$ = addptr($2, $1);
	  }
	;

direct_param_decl:
	  identifier {
		$$ = dname(getsym($1));
	  }
	| T_LPARN notype_param_decl T_RPARN {
		$$ = $2;
	  }
	| direct_param_decl T_LBRACK T_RBRACK {
		$$ = addarray($1, 0, 0);
	  }
	| direct_param_decl T_LBRACK constant T_RBRACK {
		$$ = addarray($1, 1, toicon($3));
	  }
	| direct_param_decl param_list {
		$$ = addfunc($1, $2);
		popdecl();
		blklev--;
	  }
	;

notype_param_decl:
	  direct_notype_param_decl {
		$$ = $1;
	  }
	| pointer direct_notype_param_decl {
		$$ = addptr($2, $1);
	  }
	;

direct_notype_param_decl:
	  T_NAME {
		$$ = dname(getsym($1));
	  }
	| T_LPARN notype_param_decl T_RPARN {
		$$ = $2;
	  }
	| direct_notype_param_decl T_LBRACK T_RBRACK {
		$$ = addarray($1, 0, 0);
	  }
	| direct_notype_param_decl T_LBRACK constant T_RBRACK {
		$$ = addarray($1, 1, toicon($3));
	  }
	| direct_notype_param_decl param_list {
		$$ = addfunc($1, $2);
		popdecl();
		blklev--;
	  }
	;

pointer:
	  asterisk {
		$$ = $1;
	  }
	| asterisk type_qualifier_list {
		$$ = mergepq($1, $2);
	  }
	| asterisk pointer {
		$$ = mergepq($1, $2);
	  }
	| asterisk type_qualifier_list pointer {
		$$ = mergepq(mergepq($1, $2), $3);
	  }
	;

asterisk:
	  T_MULT {
		$$ = xcalloc(1, sizeof (pqinf_t));
		$$->p_pcnt = 1;
	  }
	;

type_qualifier_list:
	  type_qualifier {
		$$ = $1;
	  }
	| type_qualifier_list type_qualifier {
		$$ = mergepq($1, $2);
	  }
	;

type_qualifier:
	  T_QUAL {
		$$ = xcalloc(1, sizeof (pqinf_t));
		if ($1 == CONST) {
			$$->p_const = 1;
		} else {
			$$->p_volatile = 1;
		}
	  }
	;

param_list:
	  id_list_lparn identifier_list T_RPARN {
		$$ = $2;
	  }
	| abs_decl_param_list {
		$$ = $1;
	  }
	;

id_list_lparn:
	  T_LPARN {
		blklev++;
		pushdecl(PARG);
	  }
	;

identifier_list:
	  T_NAME {
		$$ = iname(getsym($1));
	  }
	| identifier_list T_COMMA T_NAME {
		$$ = lnklst($1, iname(getsym($3)));
	  }
	| identifier_list error {
		$$ = $1;
	  }
	;

abs_decl_param_list:
	  abs_decl_lparn T_RPARN {
		$$ = NULL;
	  }
	| abs_decl_lparn vararg_parameter_type_list T_RPARN {
		dcs->d_proto = 1;
		$$ = $2;
	  }
	| abs_decl_lparn error T_RPARN {
		$$ = NULL;
	  }
	;

abs_decl_lparn:
	  T_LPARN {
		blklev++;
		pushdecl(PARG);
	  }
	;

vararg_parameter_type_list:
	  parameter_type_list {
		$$ = $1;
	  }
	| parameter_type_list T_COMMA T_ELLIPSE {
		dcs->d_vararg = 1;
		$$ = $1;
	  }
	| T_ELLIPSE {
		if (sflag) {
			/* ANSI C requires formal parameter before "..." */
			error(84);
		} else {
			/* ANSI C requires formal parameter before "..." */
			warning(84);
		}
		dcs->d_vararg = 1;
		$$ = NULL;
	  }
	;

parameter_type_list:
	  parameter_declaration opt_asm_spec {
		$$ = $1;
	  }
	| parameter_type_list T_COMMA parameter_declaration opt_asm_spec {
		$$ = lnklst($1, $3);
	  }
	;

parameter_declaration:
	  declmods deftyp {
		$$ = decl1arg(aname(), 0);
	  }
	| declspecs deftyp {
		$$ = decl1arg(aname(), 0);
	  }
	| declmods deftyp notype_param_decl {
		$$ = decl1arg($3, 0);
	  }
	/*
	 * param_decl is needed because of following conflict:
	 * "typedef int a; f(int (a));" could be parsed as
	 * "function with argument a of type int", or
	 * "function with an abstract argument of type function".
	 * This grammar realizes the second case.
	 */
	| declspecs deftyp param_decl {
		$$ = decl1arg($3, 0);
	  }
	| declmods deftyp abs_decl {
		$$ = decl1arg($3, 0);
	  }
	| declspecs deftyp abs_decl {
		$$ = decl1arg($3, 0);
	  }
	;

opt_asm_spec:
	  /* empty */
	| T_ASM T_LPARN read_until_rparn
	;

initializer:
	  init_expr
	;

init_expr:
	  expr				%prec T_COMMA {
		mkinit($1);
	  }
	| init_lbrace init_expr_list init_rbrace
	| init_lbrace init_expr_list T_COMMA init_rbrace
	| init_lbrace init_rbrace
	| error
	;

init_expr_list:
	  init_expr			%prec T_COMMA
	| init_expr_list T_COMMA init_expr
	;

init_lbrace:
	  T_LBRACE {
		initlbr();
	  }
	;

init_rbrace:
	  T_RBRACE {
		initrbr();
	  }
	;

type_name:
	  {
		pushdecl(ABSTRACT);
	  } abstract_declaration {
		popdecl();
		$$ = $2->s_type;
	  }
	;

abstract_declaration:
	  noclass_declmods deftyp {
		$$ = decl1abs(aname());
	  }
	| noclass_declspecs deftyp {
		$$ = decl1abs(aname());
	  }
	| noclass_declmods deftyp abs_decl {
		$$ = decl1abs($3);
	  }
	| noclass_declspecs deftyp abs_decl {
		$$ = decl1abs($3);
	  }
	;

abs_decl:
	  pointer {
		$$ = addptr(aname(), $1);
	  }
	| direct_abs_decl {
		$$ = $1;
	  }
	| pointer direct_abs_decl {
		$$ = addptr($2, $1);
	  }
	;

direct_abs_decl:
	  T_LPARN abs_decl T_RPARN {
		$$ = $2;
	  }
	| T_LBRACK T_RBRACK {
		$$ = addarray(aname(), 0, 0);
	  }
	| T_LBRACK constant T_RBRACK {
		$$ = addarray(aname(), 1, toicon($2));
	  }
	| direct_abs_decl T_LBRACK T_RBRACK {
		$$ = addarray($1, 0, 0);
	  }
	| direct_abs_decl T_LBRACK constant T_RBRACK {
		$$ = addarray($1, 1, toicon($3));
	  }
	| abs_decl_param_list {
		$$ = addfunc(aname(), $1);
		popdecl();
		blklev--;
	  }
	| direct_abs_decl abs_decl_param_list {
		$$ = addfunc($1, $2);
		popdecl();
		blklev--;
	  }
	;

stmnt:
	  labeled_stmnt {
		estmnt = 0;
	  }
	| expr_stmnt
	| comp_stmnt {
		estmnt = 0;
	  }
	| selection_stmnt {
		estmnt = 0;
	  }
	| iteration_stmnt {
		estmnt = 0;
	  }
	| jump_stmnt {
		estmnt = 0;
		ftflg = 0;
	  }
	| asm_stmnt {
		estmnt = 0;
	  }
	;

labeled_stmnt:
	  label stmnt
	;

label:
	  identifier T_COLON {
		symtyp = FLAB;
		label(T_NAME, getsym($1), NULL);
	  }
	| T_CASE constant T_COLON {
		label(T_CASE, NULL, $2);
		ftflg = 1;
	  }
	| T_CASE constant T_ELLIPSE constant T_COLON {
		/* XXX: only using the first value of this gcc-ism */
		label(T_CASE, NULL, $2);
		ftflg = 1;

		if (!gflag)
			gnuism(311);
	  }
	| T_DEFAULT T_COLON {
		label(T_DEFAULT, NULL, NULL);
		ftflg = 1;
	  }
	;

comp_stmnt:
	  compstmnt_lbrace declaration_list opt_stmnt_list compstmnt_rbrace
	| compstmnt_lbrace opt_stmnt_list compstmnt_rbrace
	;

compstmnt_lbrace:
	  T_LBRACE {
		blklev++;
		mblklev++;
		pushdecl(AUTO);
	  }
	;

compstmnt_rbrace:
	  T_RBRACE {
		popdecl();
		freeblk();
		mblklev--;
		blklev--;
		ftflg = 0;
	  }
	;

opt_stmnt_list:
	  /* empty */
	| stmnt_list
	;

stmnt_list:
	  stmnt {
		clrwflgs();
	  }
	| stmnt_list stmnt {
		clrwflgs();
	  }
	| stmnt_list error T_SEMI {
		clrwflgs();
	  }
	;

expr_stmnt:
	  expr T_SEMI {
		expr($1, 0, 0);
		estmnt = 0;
		ftflg = 0;
	  }
	| T_SEMI {
		estmnt = 1;
		ftflg = 0;
	  }
	;

selection_stmnt:
	  if_without_else {
		if2();
		if3(0);
	  }
	| if_without_else T_ELSE {
		if2();
	  } stmnt {
		if (estmnt) {
			/* empty body of the else statement */
			warning(316);
		}

		if3(1);
	  }
	| if_without_else T_ELSE error {
		if3(0);
	  }
	| switch_expr stmnt {
		switch2();
	  }
	| switch_expr error {
		switch2();
	  }
	;

if_without_else:
	  if_expr stmnt {
		if (estmnt) {
			/* empty body of the if statement */
			warning(315);
		}
	  }
	| if_expr error
	;

if_expr:
	  T_IF T_LPARN expr T_RPARN {
		if1($3);
		clrwflgs();
	  }
	;

switch_expr:
	  T_SWITCH T_LPARN expr T_RPARN {
		switch1($3);
		clrwflgs();
	  }
	;

iteration_stmnt:
	  while_expr stmnt {
		while2();
	  }
	| while_expr error {
		while2();
	  }
	| do stmnt do_while_expr {
		do2($3);
		ftflg = 0;
	  }
	| do error {
		do2(NULL);
	  }
	| for_exprs stmnt {
		for2();
	  }
	| for_exprs error {
		for2();
	  }
	;

while_expr:
	  T_WHILE T_LPARN expr T_RPARN {
		while1($3);
		clrwflgs();
	  }
	;

do:
	  T_DO {
		do1();
	  }
	;

do_while_expr:
	  T_WHILE T_LPARN expr T_RPARN T_SEMI {
		$$ = $3;
	  }
	;

for_exprs:
	  T_FOR T_LPARN opt_expr T_SEMI opt_expr T_SEMI opt_expr T_RPARN {
		for1($3, $5, $7);
		clrwflgs();
	  }
	;

opt_expr:
	  /* empty */ {
		$$ = NULL;
	  }
	| expr {
		$$ = $1;
	  }
	;

jump_stmnt:
	  goto identifier T_SEMI {
		dogoto(getsym($2));
	  }
	| goto error T_SEMI {
		symtyp = FVFT;
	  }
	| T_CONTINUE T_SEMI {
		docont();
	  }
	| T_BREAK T_SEMI {
		dobreak();
	  }
	| T_RETURN T_SEMI {
		doreturn(NULL);
	  }
	| T_RETURN expr T_SEMI {
		doreturn($2);
	  }
	;

goto:
	  T_GOTO {
		symtyp = FLAB;
	  }
	;

asm_stmnt:
	  T_ASM T_LPARN read_until_rparn T_SEMI {
		setasm();
	  }
	| T_ASM T_QUAL T_LPARN read_until_rparn T_SEMI {
		setasm();
	  }
	| T_ASM error
	;

read_until_rparn:
	  /* empty */ {
		ignuptorp();
	  }
	;

declaration_list:
	  declaration {
		clrwflgs();
	  }
	| declaration_list declaration {
		clrwflgs();
	  }
	;

constant:
	  expr				%prec T_COMMA {
		  $$ = $1;
	  }
	;

expr:
	  expr T_MULT expr {
		$$ = build(MULT, $1, $3);
	  }
	| expr T_DIVOP expr {
		$$ = build($2, $1, $3);
	  }
	| expr T_ADDOP expr {
		$$ = build($2, $1, $3);
	  }
	| expr T_SHFTOP expr {
		$$ = build($2, $1, $3);
	  }
	| expr T_RELOP expr {
		$$ = build($2, $1, $3);
	  }
	| expr T_EQOP expr {
		$$ = build($2, $1, $3);
	  }
	| expr T_AND expr {
		$$ = build(AND, $1, $3);
	  }
	| expr T_XOR expr {
		$$ = build(XOR, $1, $3);
	  }
	| expr T_OR expr {
		$$ = build(OR, $1, $3);
	  }
	| expr T_LOGAND expr {
		$$ = build(LOGAND, $1, $3);
	  }
	| expr T_LOGOR expr {
		$$ = build(LOGOR, $1, $3);
	  }
	| expr T_QUEST expr T_COLON expr {
		$$ = build(QUEST, $1, build(COLON, $3, $5));
	  }
	| expr T_ASSIGN expr {
		$$ = build(ASSIGN, $1, $3);
	  }
	| expr T_OPASS expr {
		$$ = build($2, $1, $3);
	  }
	| expr T_COMMA expr {
		$$ = build(COMMA, $1, $3);
	  }
	| term {
		$$ = $1;
	  }
	;

term:
	  T_NAME {
		/* XXX really necessary? */
		if (yychar < 0)
			yychar = yylex();
		$$ = getnnode(getsym($1), yychar);
	  }
	| string {
		$$ = getsnode($1);
	  }
	| T_CON {
		$$ = getcnode(gettyp($1->v_tspec), $1);
	  }
	| T_LPARN expr T_RPARN {
		if ($2 != NULL)
			$2->tn_parn = 1;
		$$ = $2;
	  }
	| term T_INCDEC {
		$$ = build($2 == INC ? INCAFT : DECAFT, $1, NULL);
	  }
	| T_INCDEC term {
		$$ = build($1 == INC ? INCBEF : DECBEF, $2, NULL);
	  }
	| T_MULT term {
		$$ = build(STAR, $2, NULL);
	  }
	| T_AND term {
		$$ = build(AMPER, $2, NULL);
	  }
	| T_UNOP term {
		$$ = build($1, $2, NULL);
	  }
	| T_ADDOP term {
		$$ = build($1 == PLUS ? UPLUS : UMINUS, $2, NULL);
	  }
	| term T_LBRACK expr T_RBRACK {
		$$ = build(STAR, build(PLUS, $1, $3), NULL);
	  }
	| term T_LPARN T_RPARN {
		$$ = funccall($1, NULL);
	  }
	| term T_LPARN func_arg_list T_RPARN {
		$$ = funccall($1, $3);
	  }
	| term point_or_arrow T_NAME {
		if ($1 != NULL) {
			sym_t	*msym;
			/* XXX strmemb should be integrated in build() */
			if ($2 == ARROW) {
				/* must to this before strmemb is called */
				$1 = cconv($1);
			}
			msym = strmemb($1, $2, getsym($3));
			$$ = build($2, $1, getnnode(msym, 0));
		} else {
			$$ = NULL;
		}
	  }
	| T_SIZEOF term					%prec T_SIZEOF {
		if (($$ = $2 == NULL ? NULL : bldszoftrm($2)) != NULL)
			chkmisc($2, 0, 0, 0, 0, 0, 1);
	  }
	| T_SIZEOF T_LPARN type_name T_RPARN		%prec T_SIZEOF {
		$$ = bldszof($3);
	  }
	| T_LPARN type_name T_RPARN term		%prec T_UNOP {
		$$ = cast($4, $2);
	  }
	;

string:
	  T_STRING {
		$$ = $1;
	  }
	| T_STRING string2 {
		$$ = catstrg($1, $2);
	  }
	;

string2:
	 T_STRING {
		$$ = $1;
	  }
	| string2 T_STRING {
		$$ = catstrg($1, $2);
	  }
	;

func_arg_list:
	  expr						%prec T_COMMA {
		$$ = funcarg(NULL, $1);
	  }
	| func_arg_list T_COMMA expr {
		$$ = funcarg($1, $3);
	  }
	;

point_or_arrow:
	  T_STROP {
		symtyp = FMOS;
		$$ = $1;
	  }
	;

identifier:
	  T_NAME {
		$$ = $1;
	  }
	| T_TYPENAME {
		$$ = $1;
	  }
	;

%%

/* ARGSUSED */
int
yyerror(char *msg)
{
	error(249);
	if (++sytxerr >= 5)
		norecover();
	return (0);
}

/*
 * Gets a node for a constant and returns the value of this constant
 * as integer.
 * Is the node not constant or too large for int or of type float,
 * a warning will be printed.
 *
 * toicon() should be used only inside declarations. If it is used in
 * expressions, it frees the memory used for the expression.
 */
static int
toicon(tnode_t *tn)
{
	int	i;
	tspec_t	t;
	val_t	*v;

	v = constant(tn);

	/*
	 * Abstract declarations are used inside expression. To free
	 * the memory would be a fatal error.
	 */
	if (dcs->d_ctx != ABSTRACT)
		tfreeblk();

	if ((t = v->v_tspec) == FLOAT || t == DOUBLE || t == LDOUBLE) {
		i = (int)v->v_ldbl;
		/* integral constant expression expected */
		error(55);
	} else {
		i = (int)v->v_quad;
		if (isutyp(t)) {
			if ((u_quad_t)v->v_quad > UINT_MAX) {
				/* integral constant too large */
				warning(56);
			}
		} else {
			if (v->v_quad > INT_MAX || v->v_quad < INT_MIN) {
				/* integral constant too large */
				warning(56);
			}
		}
	}
	free(v);
	return (i);
}

static void
idecl(sym_t *decl, int initflg)
{
	initerr = 0;
	initsym = decl;

	if (usedflg)
		setuflg(decl, 0, 0);

	switch (dcs->d_ctx) {
	case EXTERN:
		decl1ext(decl, initflg);
		break;
	case ARG:
		(void)decl1arg(decl, initflg);
		break;
	case AUTO:
		decl1loc(decl, initflg);
		break;
	default:
		lerror("idecl()");
	}

	if (initflg && !initerr)
		prepinit();
}

/*
 * Discard all input tokens up to and including the next
 * unmatched right paren
 */
void
ignuptorp(void)
{
	int	level;

	if (yychar < 0)
		yychar = yylex();
	freeyyv(&yylval, yychar);

	level = 1;
	while (yychar != T_RPARN || --level > 0) {
		if (yychar == T_LPARN) {
			level++;
		} else if (yychar <= 0) {
			break;
		}
		freeyyv(&yylval, yychar = yylex());
	}

	yyclearin;
}
@


1.24
log
@remove rcsids which escaped the purge of 2009
@
text
@d2 1
a2 1
/*	$OpenBSD: cgram.y,v 1.23 2011/05/31 22:00:07 martynas Exp $	*/
@


1.23
log
@Warn on empty non-compound selection statements, such as "if (foo);".

- "empty body of the if statement",
- "empty body of the else statement".

millert@@ thought it's useful.
@
text
@d2 1
a2 1
/*	$OpenBSD: cgram.y,v 1.22 2007/09/08 17:49:18 cloder Exp $	*/
a34 4

#ifndef lint
static char rcsid[] = "$OpenBSD: cgram.y,v 1.22 2007/09/08 17:49:18 cloder Exp $";
#endif
@


1.22
log
@Fix false negatives in dealing with unreachable code after calls to __dead
functions. Prodded by fgs@@, but a different diff than his.
"Makes sense" fgs@@
@
text
@d2 1
a2 1
/*	$OpenBSD: cgram.y,v 1.21 2007/04/24 16:47:36 miod Exp $	*/
d37 1
a37 1
static char rcsid[] = "$OpenBSD: cgram.y,v 1.21 2007/04/24 16:47:36 miod Exp $";
d59 5
d1189 3
a1191 1
	  labeled_stmnt
d1193 9
a1201 3
	| comp_stmnt
	| selection_stmnt
	| iteration_stmnt
d1203 1
d1206 3
a1208 1
	| asm_stmnt
d1281 1
d1285 1
d1298 5
d1317 6
a1322 1
	  if_expr stmnt
@


1.21
log
@exeption -> exception
@
text
@d2 1
a2 1
/*	$OpenBSD: cgram.y,v 1.20 2006/05/29 20:47:22 cloder Exp $	*/
d37 1
a37 1
static char rcsid[] = "$OpenBSD: cgram.y,v 1.20 2006/05/29 20:47:22 cloder Exp $";
d262 1
@


1.20
log
@Get rid of -t (traditional C) option. Some corrections by moritz.
@
text
@d2 1
a2 1
/*	$OpenBSD: cgram.y,v 1.19 2006/04/21 23:17:10 cloder Exp $	*/
d37 1
a37 1
static char rcsid[] = "$OpenBSD: cgram.y,v 1.19 2006/04/21 23:17:10 cloder Exp $";
d53 1
a53 1
 * An exeption is the declaration of arguments in prototypes. Memory
@


1.19
log
@Kill warning 54, trailing comma in enum, because this is allowed in C99.
@
text
@d2 1
a2 1
/*	$OpenBSD: cgram.y,v 1.18 2006/04/20 16:29:48 cloder Exp $	*/
d37 1
a37 1
static char rcsid[] = "$OpenBSD: cgram.y,v 1.18 2006/04/20 16:29:48 cloder Exp $";
d220 1
a220 1
		} else if (!tflag) {
d285 1
a285 1
		} else if (!tflag) {
d1036 1
a1036 1
		} else if (!tflag) {
a1510 4
		if (tflag && $1 == PLUS) {
			/* unary + is illegal in traditional C */
			warning(100);
		}
a1558 4
		if (tflag) {
			/* concatenated strings are illegal in traditional C */
			warning(219);
		}
@


1.18
log
@Add a LINTUSED special comment which marks the following declared symbol(s)
as used so that lint2 doesn't complain. Prodded by deraadt
@
text
@d2 1
a2 1
/*	$OpenBSD: cgram.y,v 1.17 2005/12/10 18:42:45 cloder Exp $	*/
d37 1
a37 1
static char rcsid[] = "$OpenBSD: cgram.y,v 1.17 2005/12/10 18:42:45 cloder Exp $";
a744 7
		if (sflag) {
			/* trailing "," prohibited in enum declaration */
			error(54);
		} else {
			/* trailing "," prohibited in enum declaration */
			warning(54);
		}
@


1.17
log
@Lint now warns about sizeof(term) where the operator is anything other
than unary *, ->, a name, or a string.
@
text
@d2 1
a2 1
/*	$OpenBSD: cgram.y,v 1.16 2005/12/10 17:41:03 cloder Exp $	*/
d37 1
a37 1
static char rcsid[] = "$OpenBSD: cgram.y,v 1.16 2005/12/10 17:41:03 cloder Exp $";
d1670 3
@


1.16
log
@Back out all gcc attribute parsing changes until we can do this the right
way some day.  The effect of __attribute__ on a LALR C grammar is just too
ugly to fix quicklly.
@
text
@d2 1
a2 1
/*	$OpenBSD: cgram.y,v 1.13 2005/11/30 18:47:11 deraadt Exp $	*/
d37 1
a37 1
static char rcsid[] = "$OpenBSD: cgram.y,v 1.13 2005/11/30 18:47:11 deraadt Exp $";
d1548 1
a1548 1
		if (($$ = $2 == NULL ? NULL : bldszof($2->tn_type)) != NULL)
@


1.15
log
@Refactor __attribute__ parsing a bit.  This takes us further to being able
to not only consume, but also make sense of gcc __attribute__ syntax.
@
text
@d2 1
a2 1
/*	$OpenBSD: cgram.y,v 1.14 2005/12/03 00:27:54 cloder Exp $	*/
d37 1
a37 1
static char rcsid[] = "$OpenBSD: cgram.y,v 1.14 2005/12/03 00:27:54 cloder Exp $";
a73 2
	attr_t	y_attr;
	attrnode_t *y_attrnode;
a112 3
/* attributes (noreturn, format, etc.) */
%token	<y_attr>	T_ATTR

a211 4
%type	<y_attr>        attribute_name
%type	<y_attr>        attribute_spec
%type	<y_attrnode>    attribute_specs
%type	<y_attrnode>    opt_attribute_specs
d309 1
a309 1
	| declspecs deftyp type_init_decls T_SEMI
d344 5
a462 1
	| clrtyp attribute_spec
a472 50
	| attribute_spec
	;

attribute_name:
	  T_QUAL {
		$$ = getkwattr(T_QUAL, $1);
	  }
	| T_SCLASS {
		$$ = getkwattr(T_SCLASS, $1);
	  }
	| T_TYPENAME {
		$$ = getattr($1->sb_name);
	  }
	| T_NAME {
		$$ = getattr($1->sb_name);
	  }
	;

attribute_spec:
	  T_ATTRIBUTE T_LPARN T_LPARN attribute_name T_RPARN T_RPARN {
		$$ = $4;
	  }
	| T_ATTRIBUTE T_LPARN T_LPARN attribute_name T_COMMA read_until_rparn T_RPARN {
		/* some other exotic syntax that we don't understand */
		$$ = AT_UNKNOWN;
	  }
	| T_ATTRIBUTE T_LPARN T_LPARN attribute_name T_LPARN read_until_rparn T_RPARN T_RPARN {
		/* some other exotic syntax that we don't understand */
		$$ = AT_UNKNOWN;
	  }
	;

attribute_specs:
	  attribute_spec {
		/*$$ = newattrnode($1);*/
		$$ = NULL;
          }
	| attribute_specs attribute_spec {
		/*appendattr($1, $2);*/
		$$ = $1;
	  }
	;

opt_attribute_specs:
	  /* EMPTY */ {
		$$ = NULL;
	  }
	| attribute_specs {
		$$ = $1;
	  }
d582 1
a582 1
	  member_declaration opt_attribute_specs {
d585 1
a585 1
	| member_declaration_list T_SEMI member_declaration opt_attribute_specs {
d795 1
a795 1
	  notype_decl opt_asm_spec {
d819 1
a819 1
	  notype_direct_decl opt_attribute_specs {
d822 1
a822 1
	| pointer notype_direct_decl opt_attribute_specs {
d848 1
a848 1
	  type_direct_decl opt_attribute_specs {
d851 1
a851 1
	| pointer type_direct_decl opt_attribute_specs {
d942 1
a942 1
	  asterisk opt_attribute_specs {
d945 2
a946 2
	| asterisk opt_attribute_specs type_qualifier_list {
		$$ = mergepq($1, $3);
d948 2
a949 2
	| asterisk opt_attribute_specs pointer {
		$$ = mergepq($1, $3);
d951 2
a952 2
	| asterisk opt_attribute_specs type_qualifier_list pointer {
		$$ = mergepq(mergepq($1, $3), $4);
d1053 1
a1053 1
	  parameter_declaration opt_attribute_specs opt_asm_spec {
d1056 1
a1056 1
	| parameter_type_list T_COMMA parameter_declaration opt_attribute_specs opt_asm_spec {
@


1.14
log
@Lint can now parse every variation of gcc's __attribute__ that I could find
either in our tree or in the gcc docs.  See regression test 11 for examples
of this.  Right now, our cdefs.h actually defines __attribute__(x) to blank
when lint runs.  We can change this whenever we choose.
@
text
@d2 1
a2 1
/*	$OpenBSD: cgram.y,v 1.13 2005/11/30 18:47:11 deraadt Exp $	*/
d37 1
a37 1
static char rcsid[] = "$OpenBSD: cgram.y,v 1.13 2005/11/30 18:47:11 deraadt Exp $";
d75 1
d217 4
d481 15
d497 10
a506 2
	  T_ATTRIBUTE T_LPARN T_LPARN T_ATTR T_RPARN T_RPARN {
		/* XXX: addattr($4) */
a507 2
	| T_ATTRIBUTE T_LPARN T_LPARN T_NAME read_until_rparn T_RPARN
	| T_ATTRIBUTE T_LPARN T_LPARN T_QUAL read_until_rparn T_RPARN
d511 8
a518 2
	  attribute_spec
	| attribute_specs attribute_spec
d522 6
a527 2
	/* EMPTY */
	| attribute_specs
@


1.13
log
@spacing
@
text
@d2 1
a2 1
/*	$OpenBSD: cgram.y,v 1.12 2005/11/30 06:33:49 cloder Exp $	*/
d37 1
a37 1
static char rcsid[] = "$OpenBSD: cgram.y,v 1.12 2005/11/30 06:33:49 cloder Exp $";
d74 1
d114 3
d313 1
a313 1
	| declspecs deftyp type_init_decls opt_attribute_spec T_SEMI
a347 5
opt_attribute_spec:
	/* empty */
	| T_ATTRIBUTE T_LPARN T_LPARN read_until_rparn T_RPARN
	;

d462 1
d473 19
d601 1
a601 1
	  member_declaration {
d604 1
a604 1
	| member_declaration_list T_SEMI member_declaration {
d814 1
a814 1
	  notype_decl opt_attribute_spec opt_asm_spec {
d838 1
a838 1
	  notype_direct_decl {
d841 1
a841 1
	| pointer notype_direct_decl {
d867 1
a867 1
	  type_direct_decl {
d870 1
a870 1
	| pointer type_direct_decl {
d961 1
a961 1
	  asterisk {
d964 2
a965 2
	| asterisk type_qualifier_list {
		$$ = mergepq($1, $2);
d967 2
a968 2
	| asterisk pointer {
		$$ = mergepq($1, $2);
d970 2
a971 2
	| asterisk type_qualifier_list pointer {
		$$ = mergepq(mergepq($1, $2), $3);
d1072 1
a1072 1
	  parameter_declaration opt_asm_spec {
d1075 1
a1075 1
	| parameter_type_list T_COMMA parameter_declaration opt_asm_spec {
@


1.12
log
@KNF
@
text
@d2 1
a2 1
/*	$OpenBSD: cgram.y,v 1.11 2005/11/29 19:50:33 cloder Exp $	*/
d37 1
a37 1
static char rcsid[] = "$OpenBSD: cgram.y,v 1.11 2005/11/29 19:50:33 cloder Exp $";
d311 1
a311 1
		globclup();		
@


1.11
log
@Remove XXX_BROKEN_GCC ifdefs, which were used to work around an ancient
(from 1995) gcc bug on i386.  From NetBSD.
@
text
@d2 1
a2 1
/*	$OpenBSD: cgram.y,v 1.10 2005/11/23 22:57:36 cloder Exp $	*/
d37 1
a37 1
static char rcsid[] = "$OpenBSD: cgram.y,v 1.10 2005/11/23 22:57:36 cloder Exp $";
d1610 1
a1610 2
yyerror(msg)
	char	*msg;
d1628 1
a1628 2
toicon(tn)
	tnode_t	*tn;
d1666 1
a1666 3
idecl(decl, initflg)
	sym_t	*decl;
	int	initflg;
d1694 1
a1694 1
ignuptorp()
@


1.10
log
@Deal with empty array initializers (a gcc-ism), but warn.
@
text
@d2 1
a2 1
/*	$OpenBSD: cgram.y,v 1.9 2005/11/23 22:25:36 cloder Exp $	*/
d37 1
a37 1
static char rcsid[] = "$OpenBSD: cgram.y,v 1.9 2005/11/23 22:25:36 cloder Exp $";
a1656 10
#ifdef XXX_BROKEN_GCC
			if (v->v_quad > INT_MAX) {
				/* integral constant too large */
				warning(56);
			}
			if (v->v_quad < INT_MIN) {
				/* integral constant too large */
				warning(56);
			}
#else
a1660 1
#endif
@


1.9
log
@Deal somewhat with case ranges, which is a gcc extension.
"fine" deraadt, with his suggested modifications
@
text
@d2 1
a2 1
/*	$OpenBSD: cgram.y,v 1.8 2005/11/23 18:47:40 cloder Exp $	*/
d37 1
a37 1
static char rcsid[] = "$OpenBSD: cgram.y,v 1.8 2005/11/23 18:47:40 cloder Exp $";
d1104 1
@


1.8
log
@Grok __restrict__ and __restrict keywords.  OK deraadt
@
text
@d2 1
a2 1
/*	$OpenBSD: cgram.y,v 1.7 2005/11/23 09:05:42 deraadt Exp $	*/
d37 1
a37 1
static char rcsid[] = "$OpenBSD: cgram.y,v 1.7 2005/11/23 09:05:42 deraadt Exp $";
d1212 8
@


1.7
log
@add a fake C construct __lint_equal__ which will be used to generate
alias entries for weak symbols and such
also let ; at the top scope be legal
@
text
@d2 1
a2 1
/*	$OpenBSD: cgram.y,v 1.5 2003/11/08 19:17:29 jmc Exp $	*/
d37 1
a37 1
static char rcsid[] = "$OpenBSD: cgram.y,v 1.5 2003/11/08 19:17:29 jmc Exp $";
d110 1
a110 1
/* qualifiers (const, volatile) */
@


1.6
log
@support __attribute__
@
text
@d2 1
a2 1
/*	$OpenBSD: cgram.y,v 1.6 2005/11/23 08:36:03 deraadt Exp $	*/
d37 1
a37 1
static char rcsid[] = "$OpenBSD: cgram.y,v 1.6 2005/11/23 08:36:03 deraadt Exp $";
d133 1
d242 2
a243 1
	;
d245 30
a274 8
data_def:
	  T_SEMI {
		if (sflag) {
			/* syntax error: empty declaration */
			error(0);
		} else if (!tflag) {
			/* syntax error: empty declaration */
			warning(0);
d276 1
d278 3
@


1.5
log
@typos from Jonathon Gray;
@
text
@d2 1
a2 1
/*	$OpenBSD: cgram.y,v 1.4 2002/02/16 21:27:59 millert Exp $	*/
d37 1
a37 1
static char rcsid[] = "$OpenBSD: cgram.y,v 1.4 2002/02/16 21:27:59 millert Exp $";
d133 1
d281 1
a281 1
	| declspecs deftyp type_init_decls T_SEMI
d316 5
d767 1
a767 1
	  notype_decl opt_asm_spec {
d1063 1
a1063 3
	| T_ASM T_LPARN T_STRING T_RPARN {
		freeyyv(&$3, T_STRING);
	  }
@


1.4
log
@Part one of userland __P removal.  Done with a simple regexp with some minor hand editing to make comments line up correctly.  Another pass is forthcoming that handles the cases that could not be done automatically.
@
text
@d2 1
a2 1
/*	$OpenBSD: cgram.y,v 1.3 1996/06/26 05:44:08 deraadt Exp $	*/
d37 1
a37 1
static char rcsid[] = "$OpenBSD: cgram.y,v 1.3 1996/06/26 05:44:08 deraadt Exp $";
d1445 1
a1445 1
		/* XXX realy neccessary? */
@


1.3
log
@rcsid
@
text
@d2 1
a2 1
/*	$OpenBSD: cgram.y,v 1.8 1995/10/02 17:31:35 jpo Exp $	*/
d37 1
a37 1
static char rcsid[] = "$OpenBSD: cgram.y,v 1.8 1995/10/02 17:31:35 jpo Exp $";
d59 3
a61 3
static	int	toicon __P((tnode_t *));
static	void	idecl __P((sym_t *, int));
static	void	ignuptorp __P((void));
@


1.2
log
@Work around a GCC code generation bug if XXX_BROKEN_GCC; fixed NetBSD
PR 2097
@
text
@d2 1
d37 1
a37 1
static char rcsid[] = "$NetBSD: cgram.y,v 1.8 1995/10/02 17:31:35 jpo Exp $";
@


1.1
log
@Initial revision
@
text
@d1610 1
a1610 1
			if ((u_quad_t)v->v_quad > INT_MAX) {
d1615 10
d1629 1
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@
