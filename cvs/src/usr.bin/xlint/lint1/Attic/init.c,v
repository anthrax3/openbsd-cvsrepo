head	1.14;
access;
symbols
	OPENBSD_5_1_BASE:1.13
	OPENBSD_5_1:1.13.0.2
	OPENBSD_5_0:1.12.0.4
	OPENBSD_5_0_BASE:1.12
	OPENBSD_4_9:1.12.0.2
	OPENBSD_4_9_BASE:1.12
	OPENBSD_4_8:1.11.0.12
	OPENBSD_4_8_BASE:1.11
	OPENBSD_4_7:1.11.0.8
	OPENBSD_4_7_BASE:1.11
	OPENBSD_4_6:1.11.0.10
	OPENBSD_4_6_BASE:1.11
	OPENBSD_4_5:1.11.0.6
	OPENBSD_4_5_BASE:1.11
	OPENBSD_4_4:1.11.0.4
	OPENBSD_4_4_BASE:1.11
	OPENBSD_4_3:1.11.0.2
	OPENBSD_4_3_BASE:1.11
	OPENBSD_4_2:1.10.0.6
	OPENBSD_4_2_BASE:1.10
	OPENBSD_4_1:1.10.0.4
	OPENBSD_4_1_BASE:1.10
	OPENBSD_4_0:1.10.0.2
	OPENBSD_4_0_BASE:1.10
	OPENBSD_3_9:1.7.0.2
	OPENBSD_3_9_BASE:1.7
	OPENBSD_3_8:1.4.0.16
	OPENBSD_3_8_BASE:1.4
	OPENBSD_3_7:1.4.0.14
	OPENBSD_3_7_BASE:1.4
	OPENBSD_3_6:1.4.0.12
	OPENBSD_3_6_BASE:1.4
	OPENBSD_3_5:1.4.0.10
	OPENBSD_3_5_BASE:1.4
	OPENBSD_3_4:1.4.0.8
	OPENBSD_3_4_BASE:1.4
	OPENBSD_3_3:1.4.0.6
	OPENBSD_3_3_BASE:1.4
	OPENBSD_3_2:1.4.0.4
	OPENBSD_3_2_BASE:1.4
	OPENBSD_3_1:1.4.0.2
	OPENBSD_3_1_BASE:1.4
	OPENBSD_3_0:1.3.0.2
	OPENBSD_3_0_BASE:1.3
	OPENBSD_2_9_BASE:1.2
	OPENBSD_2_9:1.2.0.20
	OPENBSD_2_8:1.2.0.18
	OPENBSD_2_8_BASE:1.2
	OPENBSD_2_7:1.2.0.16
	OPENBSD_2_7_BASE:1.2
	OPENBSD_2_6:1.2.0.14
	OPENBSD_2_6_BASE:1.2
	OPENBSD_2_5:1.2.0.12
	OPENBSD_2_5_BASE:1.2
	OPENBSD_2_4:1.2.0.10
	OPENBSD_2_4_BASE:1.2
	OPENBSD_2_3:1.2.0.8
	OPENBSD_2_3_BASE:1.2
	OPENBSD_2_2:1.2.0.6
	OPENBSD_2_2_BASE:1.2
	OPENBSD_2_1:1.2.0.4
	OPENBSD_2_1_BASE:1.2
	OPENBSD_2_0:1.2.0.2
	OPENBSD_2_0_BASE:1.2
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.14
date	2012.04.08.16.27.00;	author jsg;	state dead;
branches;
next	1.13;

1.13
date	2011.09.21.18.08.07;	author jsg;	state Exp;
branches;
next	1.12;

1.12
date	2010.09.09.11.31.40;	author miod;	state Exp;
branches;
next	1.11;

1.11
date	2007.11.26.09.28.34;	author martynas;	state Exp;
branches;
next	1.10;

1.10
date	2006.05.29.20.47.22;	author cloder;	state Exp;
branches;
next	1.9;

1.9
date	2006.05.05.06.46.17;	author otto;	state Exp;
branches;
next	1.8;

1.8
date	2006.04.18.02.59.40;	author cloder;	state Exp;
branches;
next	1.7;

1.7
date	2005.11.29.20.15.04;	author cloder;	state Exp;
branches;
next	1.6;

1.6
date	2005.11.20.17.42.49;	author deraadt;	state Exp;
branches;
next	1.5;

1.5
date	2005.11.19.03.35.27;	author cloder;	state Exp;
branches;
next	1.4;

1.4
date	2002.02.16.21.27.59;	author millert;	state Exp;
branches;
next	1.3;

1.3
date	2001.09.19.10.58.07;	author mpech;	state Exp;
branches;
next	1.2;

1.2
date	96.06.26.05.44.14;	author deraadt;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.47.02;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.47.02;	author deraadt;	state Exp;
branches;
next	;


desc
@@


1.14
log
@tedu lint
ok tedu@@ guenther@@ krw@@ espie@@ deraadt@@
@
text
@/*	$OpenBSD: init.c,v 1.13 2011/09/21 18:08:07 jsg Exp $	*/
/*	$NetBSD: init.c,v 1.4 1995/10/02 17:21:37 jpo Exp $	*/

/*
 * Copyright (c) 1994, 1995 Jochen Pohl
 * All Rights Reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *      This product includes software developed by Jochen Pohl for
 *	The NetBSD Project.
 * 4. The name of the author may not be used to endorse or promote products
 *    derived from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
 * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
 * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

#include <stdlib.h>

#include "lint1.h"

/*
 * initerr is set as soon as a fatal error occurred in an initialisation.
 * The effect is that the rest of the initialisation is ignored (parsed
 * by yacc, expression trees built, but no initialisation takes place).
 */
int	initerr;

/* Pointer to the symbol which is to be initialized. */
sym_t	*initsym;

/* Points to the top element of the initialisation stack. */
istk_t	*initstk;


static	void	popi2(void);
static	void	popinit(int);
static	void	pushinit(void);
static	void	testinit(void);
static	void	nextinit(int);
static	int	strginit(tnode_t *);


/*
 * Initialize the initialisation stack by putting an entry for the variable
 * which is to be initialized on it.
 */
void
prepinit(void)
{
	istk_t	*istk;

	if (initerr)
		return;

	/* free memory used in last initialisation */
	while ((istk = initstk) != NULL) {
		initstk = istk->i_nxt;
		free(istk);
	}

	/*
	 * If the type which is to be initialized is an incomplete type,
	 * it must be duplicated.
	 */
	if (initsym->s_type->t_tspec == ARRAY && incompl(initsym->s_type))
		initsym->s_type = duptyp(initsym->s_type);

	istk = initstk = xcalloc(1, sizeof (istk_t));
	istk->i_subt = initsym->s_type;
	istk->i_cnt = 1;

}

static void
popi2(void)
{
	istk_t	*istk;
	sym_t	*m;

	initstk = (istk = initstk)->i_nxt;
	if (initstk == NULL)
		lerror("popi2() 1");
	free(istk);

	istk = initstk;

	istk->i_cnt--;
	if (istk->i_cnt < 0)
		lerror("popi2() 3");

	/*
	 * If the removed element was a structure member, we must go
	 * to the next structure member.
	 */
	if (istk->i_cnt > 0 && istk->i_type->t_tspec == STRUCT) {
		do {
			m = istk->i_mem = istk->i_mem->s_nxt;
			if (m == NULL)
				lerror("popi2() 2");
		} while (m->s_field && m->s_name == unnamed);
		istk->i_subt = m->s_type;
	}
}

static void
popinit(int brace)
{
	if (brace) {
		/*
		 * Take all entries, including the first which requires
		 * a closing brace, from the stack.
		 */
		do {
			brace = initstk->i_brace;
			popi2();
		} while (!brace);
	} else {
		/*
		 * Take all entries which cannot be used for further
		 * initializers from the stack, but do this only if
		 * they do not require a closing brace.
		 */
		while (!initstk->i_brace &&
		       initstk->i_cnt == 0 && !initstk->i_nolimit) {
			popi2();
		}
	}
}

static void
pushinit(void)
{
	istk_t	*istk;
	int	cnt;
	sym_t	*m;

	istk = initstk;

	/* Extend an incomplete array type by one element */
	if (istk->i_cnt == 0) {
		/*
		 * Inside of other aggregate types must not be an incomplete
		 * type.
		 */
		if (istk->i_nxt->i_nxt != NULL)
			lerror("pushinit() 1");
		istk->i_cnt = 1;
		if (istk->i_type->t_tspec != ARRAY)
			lerror("pushinit() 2");
		istk->i_type->t_dim++;
		/* from now its an complete type */
		setcompl(istk->i_type, 0);
	}

	if (istk->i_cnt <= 0)
		lerror("pushinit() 3");
	if (istk->i_type != NULL && issclt(istk->i_type->t_tspec))
		lerror("pushinit() 4");

	initstk = xcalloc(1, sizeof (istk_t));
	initstk->i_nxt = istk;
	initstk->i_type = istk->i_subt;
	if (initstk->i_type->t_tspec == FUNC)
		lerror("pushinit() 5");

	istk = initstk;

	switch (istk->i_type->t_tspec) {
	case ARRAY:
		if (incompl(istk->i_type) && istk->i_nxt->i_nxt != NULL) {
			/* initialisation of an incomplete type */
			error(175);
			initerr = 1;
			return;
		}
		istk->i_subt = istk->i_type->t_subt;
		istk->i_nolimit = incompl(istk->i_type);
		istk->i_cnt = istk->i_type->t_dim;
		break;
	case UNION:
		/* FALLTHROUGH */
	case STRUCT:
		if (incompl(istk->i_type)) {
			/* initialisation of an incomplete type */
			error(175);
			initerr = 1;
			return;
		}
		cnt = 0;
		for (m = istk->i_type->t_str->memb; m != NULL; m = m->s_nxt) {
			if (m->s_field && m->s_name == unnamed)
				continue;
			if (++cnt == 1) {
				istk->i_mem = m;
				istk->i_subt = m->s_type;
			}
		}
		if (cnt == 0) {
			/* cannot init. struct/union with no named member */
			error(179);
			initerr = 1;
			return;
		}
		istk->i_cnt = istk->i_type->t_tspec == STRUCT ? cnt : 1;
		break;
	default:
		istk->i_cnt = 1;
		break;
	}
}

static void
testinit(void)
{
	istk_t	*istk;

	istk = initstk;

	/*
	 * If a closing brace is expected we have at least one initializer
	 * too much.
	 */
	if (istk->i_cnt == 0 && !istk->i_nolimit) {
		switch (istk->i_type->t_tspec) {
		case ARRAY:
			/* too many array initializers */
			error(173);
			break;
		case STRUCT:
		case UNION:
			/* too many struct/union initializers */
			error(172);
			break;
		default:
			/* too many initializers */
			error(174);
			break;
		}
		initerr = 1;
	}
}

static void
nextinit(int brace)
{
	if (!brace) {
		if (initstk->i_type == NULL &&
		    !issclt(initstk->i_subt->t_tspec)) {
			/* {}-enclosed initializer required */
			error(181);
		}
		/*
		 * Make sure an entry with a scalar type is at the top
		 * of the stack.
		 */
		if (!initerr)
			testinit();
		while (!initerr && (initstk->i_type == NULL ||
				    !issclt(initstk->i_type->t_tspec))) {
			if (!initerr)
				pushinit();
		}
	} else {
		if (initstk->i_type != NULL &&
		    issclt(initstk->i_type->t_tspec)) {
			/* invalid initializer */
			error(176);
			initerr = 1;
		}
		if (!initerr)
			testinit();
		if (!initerr)
			pushinit();
		if (!initerr)
			initstk->i_brace = 1;
	}
}

void
initlbr(void)
{
	if (initerr)
		return;

	/*
	 * Remove all entries which cannot be used for further initializers
	 * and do not expect a closing brace.
	 */
	popinit(0);

	nextinit(1);
}

void
initrbr(void)
{
	if (initerr)
		return;

	popinit(1);
}

void
mkinit(tnode_t *tn)
{
	ptrdiff_t offs;
	sym_t	*sym;
	tspec_t	lt, rt;
	tnode_t	*ln;
	struct	mbl *tmem;
	scl_t	sc;

	if (initerr || tn == NULL)
		goto end;

	sc = initsym->s_scl;

	/*
	 * Do not test for automatic aggregate initialisation. If the
	 * initializer starts with a brace we have the warning already.
	 * If not, an error will be printed that the initializer must
	 * be enclosed by braces.
	 */

	/*
	 * Local initialisation of non-array-types with only one expression
	 * without braces is done by ASSIGN
	 */
	if ((sc == AUTO || sc == REG) &&
	    initsym->s_type->t_tspec != ARRAY && initstk->i_nxt == NULL) {
		ln = getnnode(initsym, 0);
		ln->tn_type = tduptyp(ln->tn_type);
		ln->tn_type->t_const = 0;
		tn = build(ASSIGN, ln, tn);
		expr(tn, 0, 0);
		goto end;
	}

	/*
	 * Remove all entries which cannot be used for further initializers
	 * and do not require a closing brace.
	 */
	popinit(0);

	/* Initialisations by strings are done in strginit(). */
	if (strginit(tn))
		goto end;

	nextinit(0);
	if (initerr || tn == NULL)
		goto end;

	initstk->i_cnt--;

	/* Create a temporary node for the left side. */
	ln = tgetblk(sizeof (tnode_t));
	ln->tn_op = NAME;
	ln->tn_type = tduptyp(initstk->i_type);
	ln->tn_type->t_const = 0;
	ln->tn_lvalue = 1;
	ln->tn_sym = initsym;		/* better than nothing */

	tn = cconv(tn);

	lt = ln->tn_type->t_tspec;
	rt = tn->tn_type->t_tspec;

	if (!issclt(lt))
		lerror("mkinit() 1");

	if (!typeok(INIT, NULL, ln, tn))
		goto end;

	/*
	 * Store the tree memory. This is necessary because otherwise
	 * expr() would free it.
	 */
	tmem = tsave();
	expr(tn, 1, 0);
	trestor(tmem);

	if (lt != rt || (initstk->i_type->t_isfield && tn->tn_op == CON))
		tn = convert(INIT, NULL, initstk->i_type, tn);

	if (tn != NULL && tn->tn_op != CON) {
		sym = NULL;
		offs = 0;
		if (conaddr(tn, &sym, &offs) == -1) {
			if (sc == AUTO || sc == REG) {
				/* non-constant initializer */
				(void)gnuism(177);
			} else {
				/* non-constant initializer */
				error(177);
			}
		}
	}

 end:
	tfreeblk();
}


static int
strginit(tnode_t *tn)
{
	tspec_t	t;
	istk_t	*istk;
	int	len;
	strg_t	*strg;

	if (tn->tn_op != STRING)
		return (0);

	istk = initstk;
	strg = tn->tn_strg;

	/*
	 * Check if we have an array type which can be initialized by
	 * the string.
	 */
	if (istk->i_subt != NULL && istk->i_subt->t_tspec == ARRAY) {
		t = istk->i_subt->t_subt->t_tspec;
		if (!((strg->st_tspec == CHAR &&
		       (t == CHAR || t == UCHAR || t == SCHAR)) ||
		      (strg->st_tspec == WCHAR && t == WCHAR))) {
			return (0);
		}
		/* Put the array at top of stack */
		pushinit();
		istk = initstk;
	} else if (istk->i_type != NULL && istk->i_type->t_tspec == ARRAY) {
		t = istk->i_type->t_subt->t_tspec;
		if (!((strg->st_tspec == CHAR &&
		       (t == CHAR || t == UCHAR || t == SCHAR)) ||
		      (strg->st_tspec == WCHAR && t == WCHAR))) {
			return (0);
		}
		/*
		 * If the array is already partly initialized, we are
		 * wrong here.
		 */
		if (istk->i_cnt != istk->i_type->t_dim)
			return (0);
	} else {
		return (0);
	}

	/* Get length without trailing NUL character. */
	len = strg->st_len;

	if (istk->i_nolimit) {
		istk->i_nolimit = 0;
		istk->i_type->t_dim = len + 1;
		/* from now complete type */
		setcompl(istk->i_type, 0);
	} else {
		if (istk->i_type->t_dim < len) {
			/* non-null byte ignored in string initializer */
			warning(187);
		}
	}

	/* In every case the array is initialized completely. */
	istk->i_cnt = 0;

	return (1);
}
@


1.13
log
@remove rcsids which escaped the purge of 2009
@
text
@d1 1
a1 1
/*	$OpenBSD: init.c,v 1.12 2010/09/09 11:31:40 miod Exp $	*/
@


1.12
log
@nessesary -> necessary.
@
text
@d1 1
a1 1
/*	$OpenBSD: init.c,v 1.11 2007/11/26 09:28:34 martynas Exp $	*/
a33 4

#ifndef lint
static char rcsid[] = "$OpenBSD: init.c,v 1.11 2007/11/26 09:28:34 martynas Exp $";
#endif
@


1.11
log
@typos;  ok jmc@@
sys/netinet/in_pcb.c and sys/net/bridgestp.c ok henning@@
sys/dev/pci/bktr/* ok jakemsr@@
@
text
@d1 1
a1 1
/*	$OpenBSD: init.c,v 1.10 2006/05/29 20:47:22 cloder Exp $	*/
d36 1
a36 1
static char rcsid[] = "$OpenBSD: init.c,v 1.10 2006/05/29 20:47:22 cloder Exp $";
d397 1
a397 1
	 * Store the tree memory. This is nessesary because otherwise
@


1.10
log
@Get rid of -t (traditional C) option. Some corrections by moritz.
@
text
@d1 1
a1 1
/*	$OpenBSD: init.c,v 1.9 2006/05/05 06:46:17 otto Exp $	*/
d36 1
a36 1
static char rcsid[] = "$OpenBSD: init.c,v 1.9 2006/05/05 06:46:17 otto Exp $";
d342 1
a342 1
	 * initalizer starts with a brace we have the warning already.
@


1.9
log
@Fix SEGV on scalar initialization with braces; also found in NetBSD
rev 1.23 as part of a much larger diff. ok cloder@@
@
text
@d1 1
a1 1
/*	$OpenBSD: init.c,v 1.8 2006/04/18 02:59:40 cloder Exp $	*/
d36 1
a36 1
static char rcsid[] = "$OpenBSD: init.c,v 1.8 2006/04/18 02:59:40 cloder Exp $";
a202 3
		if (tflag)
			/* initialisation of union is illegal in trad. C */
			warning(238);
a306 7
	if ((initsym->s_scl == AUTO || initsym->s_scl == REG) &&
	    initstk->i_nxt == NULL) {
		if (tflag && !issclt(initstk->i_subt->t_tspec))
			/* no automatic aggregate initialization in trad. C*/
			warning(188);
	}

a402 10

	if (isityp(lt) && ln->tn_type->t_isfield && !isityp(rt)) {
		/*
		 * Bit-fields can be initialized in trad. C only by integer
		 * constants.
		 */
		if (tflag)
			/* bit-field initialisation is illegal in trad. C */
			warning(186);
	}
@


1.8
log
@The old way of passing function argument information was to pass an int
which corresponded to the argument # (1-based, with 0 meaning it is not
an argument). This sucked because it is impossible to include the function
name or argument name in warnings when all you have is an argument number.
Introduce a new type farg_t which represents a passed function argument.
struct farg contains argument number, function name, and argument symbol
information from the prototype).
@
text
@d1 1
a1 1
/*	$OpenBSD: init.c,v 1.7 2005/11/29 20:15:04 cloder Exp $	*/
d36 1
a36 1
static char rcsid[] = "$OpenBSD: init.c,v 1.7 2005/11/29 20:15:04 cloder Exp $";
d464 1
a464 1
	if (istk->i_subt->t_tspec == ARRAY) {
@


1.7
log
@Typo
@
text
@d1 1
a1 1
/*	$OpenBSD: init.c,v 1.6 2005/11/20 17:42:49 deraadt Exp $	*/
d36 1
a36 1
static char rcsid[] = "$OpenBSD: init.c,v 1.6 2005/11/20 17:42:49 deraadt Exp $";
d403 1
a403 1
	if (!typeok(INIT, 0, ln, tn))
d425 1
a425 1
		tn = convert(INIT, 0, initstk->i_type, tn);
@


1.6
log
@spacing
@
text
@d1 1
a1 1
/*	$OpenBSD: init.c,v 1.5 2005/11/19 03:35:27 cloder Exp $	*/
d36 1
a36 1
static char rcsid[] = "$OpenBSD: init.c,v 1.5 2005/11/19 03:35:27 cloder Exp $";
d351 1
a351 1
	 * Do not test for automatic aggregat initialisation. If the
@


1.5
log
@knf. OK kjell, brad
@
text
@d1 1
a1 1
/*	$OpenBSD: init.c,v 1.4 2002/02/16 21:27:59 millert Exp $	*/
d36 1
a36 1
static char rcsid[] = "$OpenBSD: init.c,v 1.4 2002/02/16 21:27:59 millert Exp $";
d413 1
a413 1
	
@


1.4
log
@Part one of userland __P removal.  Done with a simple regexp with some minor hand editing to make comments line up correctly.  Another pass is forthcoming that handles the cases that could not be done automatically.
@
text
@d1 1
a1 1
/*	$OpenBSD: init.c,v 1.3 2001/09/19 10:58:07 mpech Exp $	*/
d36 1
a36 1
static char rcsid[] = "$OpenBSD: init.c,v 1.3 2001/09/19 10:58:07 mpech Exp $";
d70 1
a70 1
prepinit()
d97 1
a97 1
popi2()
d128 1
a128 2
popinit(brace)
	int	brace;
d153 1
a153 1
pushinit()
d238 1
a238 1
testinit()
d269 1
a269 2
nextinit(brace)
	int	brace;
d305 1
a305 1
initlbr()
d327 1
a327 1
initrbr()
d336 1
a336 2
mkinit(tn)
	tnode_t	*tn;
d447 1
a447 2
strginit(tn)
	tnode_t	*tn;
@


1.3
log
@occured->occurred

idea from deraadt@@ via NetBSD
millert@@ ok

p.s. Next commit will fix a typo in the sys/
@
text
@d1 1
a1 1
/*	$OpenBSD: init.c,v 1.2 1996/06/26 05:44:14 deraadt Exp $	*/
d36 1
a36 1
static char rcsid[] = "$OpenBSD: init.c,v 1.2 1996/06/26 05:44:14 deraadt Exp $";
d57 6
a62 6
static	void	popi2 __P((void));
static	void	popinit __P((int));
static	void	pushinit __P((void));
static	void	testinit __P((void));
static	void	nextinit __P((int));
static	int	strginit __P((tnode_t *));
@


1.2
log
@rcsid
@
text
@d1 1
a1 1
/*	$OpenBSD: init.c,v 1.4 1995/10/02 17:21:37 jpo Exp $	*/
d36 1
a36 1
static char rcsid[] = "$OpenBSD: init.c,v 1.4 1995/10/02 17:21:37 jpo Exp $";
d44 1
a44 1
 * initerr is set as soon as a fatal error occured in an initialisation.
@


1.1
log
@Initial revision
@
text
@d1 1
d36 1
a36 1
static char rcsid[] = "$NetBSD: init.c,v 1.4 1995/10/02 17:21:37 jpo Exp $";
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@
