head	1.34;
access;
symbols
	OPENBSD_5_1_BASE:1.33
	OPENBSD_5_1:1.33.0.2
	OPENBSD_5_0:1.32.0.6
	OPENBSD_5_0_BASE:1.32
	OPENBSD_4_9:1.32.0.4
	OPENBSD_4_9_BASE:1.32
	OPENBSD_4_8:1.32.0.2
	OPENBSD_4_8_BASE:1.32
	OPENBSD_4_7:1.31.0.8
	OPENBSD_4_7_BASE:1.31
	OPENBSD_4_6:1.31.0.10
	OPENBSD_4_6_BASE:1.31
	OPENBSD_4_5:1.31.0.6
	OPENBSD_4_5_BASE:1.31
	OPENBSD_4_4:1.31.0.4
	OPENBSD_4_4_BASE:1.31
	OPENBSD_4_3:1.31.0.2
	OPENBSD_4_3_BASE:1.31
	OPENBSD_4_2:1.30.0.6
	OPENBSD_4_2_BASE:1.30
	OPENBSD_4_1:1.30.0.4
	OPENBSD_4_1_BASE:1.30
	OPENBSD_4_0:1.30.0.2
	OPENBSD_4_0_BASE:1.30
	OPENBSD_3_9:1.27.0.2
	OPENBSD_3_9_BASE:1.27
	OPENBSD_3_8:1.6.0.6
	OPENBSD_3_8_BASE:1.6
	OPENBSD_3_7:1.6.0.4
	OPENBSD_3_7_BASE:1.6
	OPENBSD_3_6:1.6.0.2
	OPENBSD_3_6_BASE:1.6
	OPENBSD_3_5:1.5.0.10
	OPENBSD_3_5_BASE:1.5
	OPENBSD_3_4:1.5.0.8
	OPENBSD_3_4_BASE:1.5
	OPENBSD_3_3:1.5.0.6
	OPENBSD_3_3_BASE:1.5
	OPENBSD_3_2:1.5.0.4
	OPENBSD_3_2_BASE:1.5
	OPENBSD_3_1:1.5.0.2
	OPENBSD_3_1_BASE:1.5
	OPENBSD_3_0:1.3.0.22
	OPENBSD_3_0_BASE:1.3
	OPENBSD_2_9_BASE:1.3
	OPENBSD_2_9:1.3.0.20
	OPENBSD_2_8:1.3.0.18
	OPENBSD_2_8_BASE:1.3
	OPENBSD_2_7:1.3.0.16
	OPENBSD_2_7_BASE:1.3
	OPENBSD_2_6:1.3.0.14
	OPENBSD_2_6_BASE:1.3
	OPENBSD_2_5:1.3.0.12
	OPENBSD_2_5_BASE:1.3
	OPENBSD_2_4:1.3.0.10
	OPENBSD_2_4_BASE:1.3
	OPENBSD_2_3:1.3.0.8
	OPENBSD_2_3_BASE:1.3
	OPENBSD_2_2:1.3.0.6
	OPENBSD_2_2_BASE:1.3
	OPENBSD_2_1:1.3.0.4
	OPENBSD_2_1_BASE:1.3
	OPENBSD_2_0:1.3.0.2
	OPENBSD_2_0_BASE:1.3
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.34
date	2012.04.08.16.27.00;	author jsg;	state dead;
branches;
next	1.33;

1.33
date	2011.09.21.18.08.07;	author jsg;	state Exp;
branches;
next	1.32;

1.32
date	2010.07.24.22.17.03;	author guenther;	state Exp;
branches;
next	1.31;

1.31
date	2007.09.05.16.32.17;	author fgsch;	state Exp;
branches;
next	1.30;

1.30
date	2006.05.29.20.47.22;	author cloder;	state Exp;
branches;
next	1.29;

1.29
date	2006.04.20.16.29.48;	author cloder;	state Exp;
branches;
next	1.28;

1.28
date	2006.03.13.21.12.32;	author moritz;	state Exp;
branches;
next	1.27;

1.27
date	2006.01.16.22.16.14;	author espie;	state Exp;
branches;
next	1.26;

1.26
date	2005.12.17.21.08.27;	author cloder;	state Exp;
branches;
next	1.25;

1.25
date	2005.12.11.20.02.09;	author deraadt;	state Exp;
branches;
next	1.24;

1.24
date	2005.12.10.18.51.54;	author martin;	state Exp;
branches;
next	1.23;

1.23
date	2005.12.10.17.41.03;	author cloder;	state Exp;
branches;
next	1.22;

1.22
date	2005.12.09.03.13.08;	author cloder;	state Exp;
branches;
next	1.21;

1.21
date	2005.12.07.01.55.12;	author cloder;	state Exp;
branches;
next	1.20;

1.20
date	2005.12.03.01.14.39;	author cloder;	state Exp;
branches;
next	1.19;

1.19
date	2005.12.03.00.27.54;	author cloder;	state Exp;
branches;
next	1.18;

1.18
date	2005.12.02.18.03.09;	author cloder;	state Exp;
branches;
next	1.17;

1.17
date	2005.12.01.03.17.14;	author cloder;	state Exp;
branches;
next	1.16;

1.16
date	2005.11.30.19.42.58;	author cloder;	state Exp;
branches;
next	1.15;

1.15
date	2005.11.30.06.32.00;	author cloder;	state Exp;
branches;
next	1.14;

1.14
date	2005.11.30.06.22.42;	author cloder;	state Exp;
branches;
next	1.13;

1.13
date	2005.11.29.20.47.44;	author cloder;	state Exp;
branches;
next	1.12;

1.12
date	2005.11.24.01.45.28;	author deraadt;	state Exp;
branches;
next	1.11;

1.11
date	2005.11.23.20.36.41;	author cloder;	state Exp;
branches;
next	1.10;

1.10
date	2005.11.23.18.47.41;	author cloder;	state Exp;
branches;
next	1.9;

1.9
date	2005.11.23.09.05.42;	author deraadt;	state Exp;
branches;
next	1.8;

1.8
date	2005.11.23.08.53.37;	author deraadt;	state Exp;
branches;
next	1.7;

1.7
date	2005.11.20.17.42.49;	author deraadt;	state Exp;
branches;
next	1.6;

1.6
date	2004.05.10.15.26.22;	author deraadt;	state Exp;
branches;
next	1.5;

1.5
date	2002.02.19.19.39.39;	author millert;	state Exp;
branches;
next	1.4;

1.4
date	2002.02.16.21.27.59;	author millert;	state Exp;
branches;
next	1.3;

1.3
date	96.06.26.05.44.18;	author deraadt;	state Exp;
branches;
next	1.2;

1.2
date	95.12.14.03.11.40;	author deraadt;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.47.03;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.47.03;	author deraadt;	state Exp;
branches;
next	;


desc
@@


1.34
log
@tedu lint
ok tedu@@ guenther@@ krw@@ espie@@ deraadt@@
@
text
@%{
/*	$OpenBSD: scan.l,v 1.33 2011/09/21 18:08:07 jsg Exp $	*/
/*	$NetBSD: scan.l,v 1.8 1995/10/23 13:38:51 jpo Exp $	*/

/*
 * Copyright (c) 1994, 1995 Jochen Pohl
 * All Rights Reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *      This product includes software developed by Jochen Pohl for
 *      The NetBSD Project.
 * 4. The name of the author may not be used to endorse or promote products
 *    derived from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
 * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
 * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

#include <stdlib.h>
#include <string.h>
#include <limits.h>
#include <float.h>
#include <ctype.h>
#include <errno.h>
#include <math.h>
#include <err.h>

#include "lint1.h"
#include "y.tab.h"

#define CHAR_MASK	(~(~0 << CHAR_BIT))

/* Current position (its also updated when an included file is parsed) */
pos_t	curr_pos = { 1, "" };

/*
 * Current position in C source (not updated when an included file is
 * parsed).
 */
pos_t	csrc_pos = { 1, "" };

static	void	incline(void);
static	void	badchar(int);
static	sbuf_t	*allocsb(void);
static	void	freesb(sbuf_t *);
static	int	inpc(void);
static	int	hash(const char *);
static	sym_t	*search(sbuf_t *);
static	int	name(void);
static	int	keyw(sym_t *);
static	int	icon(int);
static	int	fcon(void);
static  int	fhexcon(void);
static	int	operator(int, op_t);
static	int	ccon(void);
static	int	wccon(void);
static	int	getescc(int);
static	void	directive(void);
static	void	comment(void);
static	void	slashslashcomment(void);
static	int	string(void);
static	int	wcstrg(void);

%}

L	[_A-Za-z]
D	[0-9]
NZD	[1-9]
OD	[0-7]
HD	[0-9A-Fa-f]
EX	([eE][+-]?[0-9]+)
HEX	([pP][+-]?[0-9]+)
FSUFF	([fFlL][iIjJ]?|[iIjJ][fFlL]?)?

%%

{L}({L}|{D})*			return (name());
0{OD}*[lLuU]*			return (icon(8));
{NZD}{D}*[lLuU]*		return (icon(10));
0[xX]{HD}+[lLuU]*		return (icon(16));
{D}+\.{D}*{EX}?{FSUFF}		|
{D}+{EX}{FSUFF}			|
\.{D}+{EX}?{FSUFF}		return (fcon());
0[xX]{HD}+\.{HD}*{HEX}{FSUFF}	|
0[xX]{HD}+{HEX}{FSUFF}		|
0[xX]\.{HD}+{HEX}{FSUFF}	return (fhexcon());
"="				return (operator(T_ASSIGN, ASSIGN));
"*="				return (operator(T_OPASS, MULASS));
"/="				return (operator(T_OPASS, DIVASS));
"%="				return (operator(T_OPASS, MODASS));
"+="				return (operator(T_OPASS, ADDASS));
"-="				return (operator(T_OPASS, SUBASS));
"<<="				return (operator(T_OPASS, SHLASS));
">>="				return (operator(T_OPASS, SHRASS));
"&="				return (operator(T_OPASS, ANDASS));
"^="				return (operator(T_OPASS, XORASS));
"|="				return (operator(T_OPASS, ORASS));
"||"				return (operator(T_LOGOR, LOGOR));
"&&"				return (operator(T_LOGAND, LOGAND));
"|"				return (operator(T_OR, OR));
"&"				return (operator(T_AND, AND));
"^"				return (operator(T_XOR, XOR));
"=="				return (operator(T_EQOP, EQ));
"!="				return (operator(T_EQOP, NE));
"<"				return (operator(T_RELOP, LT));
">"				return (operator(T_RELOP, GT));
"<="				return (operator(T_RELOP, LE));
">="				return (operator(T_RELOP, GE));
"<<"				return (operator(T_SHFTOP, SHL));
">>"				return (operator(T_SHFTOP, SHR));
"++"				return (operator(T_INCDEC, INC));
"--"				return (operator(T_INCDEC, DEC));
"->"				return (operator(T_STROP, ARROW));
"."				return (operator(T_STROP, POINT));
"+"				return (operator(T_ADDOP, PLUS));
"-"				return (operator(T_ADDOP, MINUS));
"*"				return (operator(T_MULT, MULT));
"/"				return (operator(T_DIVOP, DIV));
"%"				return (operator(T_DIVOP, MOD));
"!"				return (operator(T_UNOP, NOT));
"~"				return (operator(T_UNOP, COMPL));
"\""				return (string());
"L\""				return (wcstrg());
";"				return (T_SEMI);
"{"				return (T_LBRACE);
"}"				return (T_RBRACE);
","				return (T_COMMA);
":"				return (T_COLON);
"?"				return (T_QUEST);
"["				return (T_LBRACK);
"]"				return (T_RBRACK);
"("				return (T_LPARN);
")"				return (T_RPARN);
"..."				return (T_ELLIPSE);
"'"				return (ccon());
"L'"				return (wccon());
^#.*$				directive();
\n				incline();
\t|" "|\f|\v			;
"/*"				comment();
"//"				slashslashcomment();
.				badchar(yytext[0]);

%%

static void
incline(void)
{
	curr_pos.p_line++;
	if (curr_pos.p_file == csrc_pos.p_file)
		csrc_pos.p_line++;
}

static void
badchar(int c)
{
	/* unknown character \%o */
	error(250, c);
}

/*
 * Keywords.
 * During initialisation they are written to the symbol table.
 */
static	struct	kwtab {
	const	char *kw_name;	/* keyword */
	int	kw_token;	/* token returned by yylex() */
	union {
		scl_t	kw_scl;		/* storage class if kw_token T_SCLASS */
		tspec_t	kw_tspec;	/* type spec. if kw_token T_TYPE or T_SOU */
		tqual_t	kw_tqual;	/* type qual. if kw_token T_QUAL */
		op_t	kw_op;		/* operator if kw_token T_UNOP */
	} kw_u;
	u_int	kw_stdc : 1;	/* STDC keyword */
	u_int	kw_gcc : 1;	/* GCC keyword */
} kwtab[] = {
	{ "asm",		T_ASM,		{ 0 },		0, 1 },
	{ "__asm",		T_ASM,		{ 0 },		0, 0 },
	{ "__asm__",		T_ASM,		{ 0 },		0, 0 },
	{ "__attribute__",	T_ATTRIBUTE,	{ 0 },		0, 0 },
	{ "auto",		T_SCLASS,	{ AUTO },	0, 0 },
	{ "_Bool",		T_TYPE,		{ BOOL },	1, 0 },
	{ "break",		T_BREAK,	{ 0 },		0, 0 },
	{ "case",		T_CASE,		{ 0 },		0, 0 },
	{ "char",		T_TYPE,		{ CHAR },	0, 0 },
	{ "_Complex",		T_TYPE,		{ COMPLEX },	1, 0 },
	{ "__complex__",	T_TYPE,		{ COMPLEX },	0, 1 },
	{ "const",		T_QUAL,		{ CONST },	1, 0 },
	{ "__const__",		T_QUAL,		{ CONST },	0, 0 },
	{ "__const",		T_QUAL,		{ CONST },	0, 0 },
	{ "continue",		T_CONTINUE,	{ 0 },		0, 0 },
	{ "default",		T_DEFAULT,	{ 0 },		0, 0 },
	{ "do",			T_DO,		{ 0 },		0, 0 },
	{ "double",		T_TYPE,		{ DOUBLE },	0, 0 },
	{ "else",		T_ELSE,		{ 0 },		0, 0 },
	{ "enum",		T_ENUM,		{ 0 },		0, 0 },
	{ "extern",		T_SCLASS,	{ EXTERN },	0, 0 },
	{ "float",		T_TYPE,		{ FLOAT },	0, 0 },
	{ "for",		T_FOR,		{ 0 },		0, 0 },
	{ "goto",		T_GOTO,		{ 0 },		0, 0 },
	{ "if",			T_IF,		{ 0 },		0, 0 },
	{ "__imag__",		T_UNOP,		{ IMAG },	0, 0 /*1*/ },
/*	{ "_Imaginary",		T_TYPE,		{ IMAGINARY },	1, 0 }, */
	{ "inline",		T_SCLASS,	{ INLINE },	1, 0 },
	{ "__inline__",		T_SCLASS,	{ INLINE },	0, 0 },
	{ "__inline",		T_SCLASS,	{ INLINE },	0, 0 },
	{ "int",		T_TYPE,		{ INT },	0, 0 },
	{ "__lint_equal__",	T_LEQUAL,	{ 0 },		0, 0 },
	{ "long",		T_TYPE,		{ LONG },	0, 0 },
	{ "__real__",		T_UNOP,		{ REAL },	0, 0 /*1*/ },
	{ "register",		T_SCLASS,	{ REG },	0, 0 },
	{ "__restrict",		T_QUAL,		{ RESTRICT },	0, 0 },
	{ "__restrict__",	T_QUAL,		{ RESTRICT },	0, 0 },
	{ "return",		T_RETURN,	{ 0 },		0, 0 },
	{ "short",		T_TYPE,		{ SHORT },	0, 0 },
	{ "signed",		T_TYPE,		{ SIGNED },	1, 0 },
	{ "__signed__",		T_TYPE,		{ SIGNED },	0, 0 },
	{ "__signed",		T_TYPE,		{ SIGNED },	0, 0 },
	{ "sizeof",		T_SIZEOF,	{ 0 },		0, 0 },
	{ "static",		T_SCLASS,	{ STATIC },	0, 0 },
	{ "struct",		T_SOU,		{ STRUCT },	0, 0 },
	{ "switch",		T_SWITCH,	{ 0 },		0, 0 },
	{ "typedef",		T_SCLASS,	{ TYPEDEF },	0, 0 },
	{ "union",		T_SOU,		{ UNION },	0, 0 },
	{ "unsigned",		T_TYPE,		{ UNSIGN },	0, 0 },
	{ "void",		T_TYPE,		{ VOID },	0, 0 },
	{ "volatile",		T_QUAL,		{ VOLATILE },	1, 0 },
	{ "__volatile__",	T_QUAL,		{ VOLATILE },	0, 0 },
	{ "__volatile",		T_QUAL,		{ VOLATILE },	0, 0 },
	{ "while",		T_WHILE,	{ 0 },		0, 0 },
	{ NULL,			0,		{ 0 },		0, 0 }
};

#define kw_scl		kw_u.kw_scl
#define kw_tspec	kw_u.kw_tspec
#define kw_tqual	kw_u.kw_tqual
#define kw_op		kw_u.kw_op

/* Symbol table */
static	sym_t	*symtab[HSHSIZ1];

/* bit i of the entry with index i is set */
u_quad_t qbmasks[sizeof(u_quad_t) * CHAR_BIT];

/* least significant i bits are set in the entry with index i */
u_quad_t qlmasks[sizeof(u_quad_t) * CHAR_BIT + 1];

/* least significant i bits are not set in the entry with index i */
u_quad_t qumasks[sizeof(u_quad_t) * CHAR_BIT + 1];

/* free list for sbuf structures */
static	sbuf_t	 *sbfrlst;

/* type of next expected symbol */
symt_t	symtyp;


/*
 * All keywords are written to the symbol table. This saves us looking
 * in a extra table for each name we found.
 */
void
initscan(void)
{
	struct	kwtab *kw;
	sym_t	*sym;
	int	h, i;
	u_quad_t uq;

	for (kw = kwtab; kw->kw_name != NULL; kw++) {
		if (kw->kw_gcc && !gflag)
			continue;
		sym = getblk(sizeof (sym_t));
		sym->s_name = kw->kw_name;
		sym->s_keyw = 1;
		sym->s_value.v_quad = kw->kw_token;
		if (kw->kw_token == T_TYPE || kw->kw_token == T_SOU) {
			sym->s_tspec = kw->kw_tspec;
		} else if (kw->kw_token == T_SCLASS) {
			sym->s_scl = kw->kw_scl;
		} else if (kw->kw_token == T_QUAL) {
			sym->s_tqual = kw->kw_tqual;
		} else if (kw->kw_token == T_UNOP) {
			sym->s_op = kw->kw_op;
		}
		h = hash(sym->s_name);
		if ((sym->s_link = symtab[h]) != NULL)
			symtab[h]->s_rlink = &sym->s_link;
		(symtab[h] = sym)->s_rlink = &symtab[h];
	}

	/* initialize bit-masks for quads */
	for (i = 0; i < sizeof (u_quad_t) * CHAR_BIT; i++) {
		qbmasks[i] = (u_quad_t)1 << i;
		uq = ~(u_quad_t)0 << i;
		qumasks[i] = uq;
		qlmasks[i] = ~uq;
	}
	qumasks[i] = 0;
	qlmasks[i] = ~(u_quad_t)0;
}

/*
 * Get a free sbuf structure, if possible from the free list
 */
static sbuf_t *
allocsb(void)
{
	sbuf_t	*sb;

	if ((sb = sbfrlst) != NULL) {
		sbfrlst = sb->sb_nxt;
	} else {
		sb = xmalloc(sizeof (sbuf_t));
	}
	(void)memset(sb, 0, sizeof (sbuf_t));
	return (sb);
}

/*
 * Put a sbuf structure to the free list
 */
static void
freesb(sbuf_t *sb)
{
	sb->sb_nxt = sbfrlst;
	sbfrlst = sb;
}

/*
 * Read a character and ensure that it is positive (except EOF).
 * Increment line count(s) if necessary.
 */
static int
inpc(void)
{
	int	c;

	if ((c = input()) != EOF && (c &= CHAR_MASK) == '\n')
		incline();
	return (c);
}

static int
hash(const char *s)
{
	u_int	v;
	const	u_char *us;

	v = 0;
	for (us = (const u_char *)s; *us != '\0'; us++) {
		v = (v << sizeof (v)) + *us;
		v ^= v >> (sizeof (v) * CHAR_BIT - sizeof (v));
	}
	return (v % HSHSIZ1);
}

/*
 * Lex has found a letter followed by zero or more letters or digits.
 * It looks for a symbol in the symbol table with the same name. This
 * symbol must either be a keyword or a symbol of the type required by
 * symtyp (label, member, tag, ...).
 *
 * If it is a keyword, the token is returned. In some cases it is described
 * more deeply by data written to yylval.
 *
 * If it is a symbol, T_NAME is returned and the pointer to a sbuf struct
 * is stored in yylval. This struct contains the name of the symbol, it's
 * length and hash value. If there is already a symbol of the same name
 * and type in the symbol table, the sbuf struct also contains a pointer
 * to the symbol table entry.
 */
static int
name(void)
{
	char	*s;
	sbuf_t	*sb;
	sym_t	*sym;
	int	tok;

	sb = allocsb();
	sb->sb_name = yytext;
	sb->sb_len = yyleng;
	sb->sb_hash = hash(yytext);

	if ((sym = search(sb)) != NULL && sym->s_keyw) {
		freesb(sb);
		return (keyw(sym));
	}

	sb->sb_sym = sym;

	if (sym != NULL) {
		if (blklev < sym->s_blklev)
			lerror("name() 1");
		sb->sb_name = sym->s_name;
		sb->sb_len = strlen(sym->s_name);
		tok = sym->s_scl == TYPEDEF ? T_TYPENAME : T_NAME;
	} else {
		s = getblk(yyleng + 1);
		(void)memcpy(s, yytext, yyleng + 1);
		sb->sb_name = s;
		sb->sb_len = yyleng;
		tok = T_NAME;
	}

	yylval.y_sb = sb;
	return (tok);
}

static sym_t *
search(sbuf_t *sb)
{
	sym_t	*sym;

	for (sym = symtab[sb->sb_hash]; sym != NULL; sym = sym->s_link) {
		if (strcmp(sym->s_name, sb->sb_name) == 0) {
			if (sym->s_keyw || sym->s_kind == symtyp)
				return (sym);
		}
	}

	return (NULL);
}

static int
keyw(sym_t *sym)
{
	int	t;

	if ((t = (int)sym->s_value.v_quad) == T_SCLASS) {
		yylval.y_scl = sym->s_scl;
	} else if (t == T_TYPE || t == T_SOU) {
		yylval.y_tspec = sym->s_tspec;
	} else if (t == T_QUAL) {
		yylval.y_tqual = sym->s_tqual;
	} else if (t == T_UNOP) {
		yylval.y_op = sym->s_op;
	}
	return (t);
}

/*
 * Convert a string representing an integer into internal representation.
 * The value is returned in yylval. icon() (and yylex()) returns T_CON.
 */
static int
icon(int base)
{
	int	l_suffix, u_suffix;
	int	len;
	const	char *cp;
	char	c, *eptr;
	tspec_t	typ;
	u_long	ul;
	u_quad_t uq;
	int	ansiu;
	static	tspec_t contypes[2][3] = {
		{ INT,  LONG,  QUAD },
		{ UINT, ULONG, UQUAD }
	};

	cp = yytext;
	len = yyleng;

	/* skip 0x */
	if (base == 16) {
		cp += 2;
		len -= 2;
	}

	/* read suffixes */
	l_suffix = u_suffix = 0;
	for ( ; ; ) {
		if ((c = cp[len - 1]) == 'l' || c == 'L') {
			l_suffix++;
		} else if (c == 'u' || c == 'U') {
			u_suffix++;
		} else {
			break;
		}
		len--;
	}
	if (l_suffix > 2 || u_suffix > 1) {
		/* malformed integer constant */
		warning(251);
		if (l_suffix > 2)
			l_suffix = 2;
		if (u_suffix > 1)
			u_suffix = 1;
	}
	typ = contypes[u_suffix][l_suffix];

	errno = 0;
	if (l_suffix < 2) {
		ul = strtoul(cp, &eptr, base);
	} else {
		uq = strtouq(cp, &eptr, base);
	}
	if (eptr != cp + len)
		lerror("icon() 1");
	if (errno != 0)
		/* integer constant out of range */
		warning(252);

	/*
         * If the value is too big for the current type, we must choose
	 * another type.
	 */
	ansiu = 0;
	switch (typ) {
	case INT:
		if (ul <= INT_MAX) {
			/* ok */
		} else if (ul <= (unsigned)UINT_MAX && base != 10) {
			typ = UINT;
		} else if (ul <= LONG_MAX) {
			typ = LONG;
		} else {
			typ = ULONG;
		}
		if (typ == UINT || typ == ULONG) {
			if (!sflag) {
				/*
				 * Remember that the constant is unsigned
				 * only in ANSI C
				 */
				ansiu = 1;
			}
		}
		break;
	case UINT:
		if (ul > (u_int)UINT_MAX)
			typ = ULONG;
		break;
	case LONG:
		if (ul > LONG_MAX) {
			typ = ULONG;
			if (!sflag)
				ansiu = 1;
		}
		break;
	case QUAD:
		if (uq > QUAD_MAX) {
			typ = UQUAD;
			if (!sflag)
				ansiu = 1;
		}
		break;
		/* LINTED (enumeration values not handled in switch) */
	}

	if (typ != QUAD && typ != UQUAD) {
		if (isutyp(typ)) {
			uq = ul;
		} else {
			uq = (quad_t)(long)ul;
		}
	}

	uq = (u_quad_t)xsign((quad_t)uq, typ, -1);

	(yylval.y_val = xcalloc(1, sizeof (val_t)))->v_tspec = typ;
	yylval.y_val->v_ansiu = ansiu;
	yylval.y_val->v_quad = (quad_t)uq;

	return (T_CON);
}

/*
 * Returns 1 if t is a signed type and the value is negative.
 *
 * len is the number of significant bits. If len is -1, len is set
 * to the width of type t.
 */
int
sign(quad_t q, tspec_t t, int len)
{
	if (t == PTR || isutyp(t))
		return (0);
	return (msb(q, t, len));
}

int
msb(quad_t q, tspec_t t, int len)
{
	if (len <= 0)
		len = size(t);
	return ((q & qbmasks[len - 1]) != 0);
}

/*
 * Extends the sign of q.
 */
quad_t
xsign(quad_t q, tspec_t t, int len)
{
	if (len <= 0)
		len = size(t);

	if (t == PTR || isutyp(t) || !sign(q, t, len)) {
		q &= qlmasks[len];
	} else {
		q |= qumasks[len];
	}
	return (q);
}

/*
 * Convert a string representing a floating point value into its integral
 * representation. Type and value are returned in yylval. fcon()
 * (and yylex()) returns T_CON.
 * XXX Currently it is not possible to convert constants of type
 * long double which are greater then DBL_MAX.
 */
static int
fcon(void)
{
	const	char *cp;
	int	len;
	tspec_t typ;
	tspec_t	domain = NOTSPEC;
	char	c, *eptr;
	double	d;
	float	f;

	cp = yytext;
	len = yyleng;

	c = cp[len - 1];
	if (c == 'i' || c == 'I' || c == 'j' || c == 'J') {
		domain = COMPLEX;		/* XXX should be IMAGINARY */
		len--;
		c = cp[len - 1];
	}
	if (c == 'f' || c == 'F') {
		typ = FLOAT;
		len--;
		c = cp[len - 1];
	} else if (c == 'l' || c == 'L') {
		typ = LDOUBLE;
		len--;
		c = cp[len - 1];
	} else {
		typ = DOUBLE;
	}
	if (c == 'i' || c == 'I' || c == 'j' || c == 'J') {
		if (domain != NOTSPEC)
			lerror("fcon() 2");	/* can't happen */
		domain = COMPLEX;		/* XXX should be IMAGINARY */
		len--;
	}

	errno = 0;
	d = strtod(cp, &eptr);
	if (eptr != cp + len)
		lerror("fcon() 1");
	if (errno != 0)
		/* floating-point constant out of range */
		warning(248);

	if (typ == FLOAT) {
		f = (float)d;
		if (isinf(f)) {
			/* floating-point constant out of range */
			warning(248);
			f = f > 0 ? FLT_MAX : -FLT_MAX;
		}
	}

	yylval.y_val = xcalloc(1, sizeof (val_t));
	if (typ == FLOAT) {
		yylval.y_val->v_ldbl = f;
	} else {
		yylval.y_val->v_ldbl = d;
	}
	if (mergedomain(&typ, domain))
		lerror("fcon() 3");
	yylval.y_val->v_tspec = typ;

	return (T_CON);
}

/*
 * Convert an hexadecimal representation of a floating point value 
 * into its integral representation. 
 * Type and value are returned in yylval. fhexcon()
 * (and yylex()) returns T_CON.
 * XXX Currently no actual values are parsed.
 */
static int
fhexcon(void)
{
	const	char *cp;
	int	len;
	tspec_t typ;
	tspec_t	domain = NOTSPEC;
	char	c;
	double	d;
	float	f;

	cp = yytext;
	len = yyleng;

	c = cp[len - 1];
	if (c == 'i' || c == 'I' || c == 'j' || c == 'J') {
		domain = COMPLEX;		/* XXX should be IMAGINARY */
		len--;
		c = cp[len - 1];
	}
	if (c == 'f' || c == 'F') {
		typ = FLOAT;
		len--;
		c = cp[len - 1];
	} else if (c == 'l' || c == 'L') {
		typ = LDOUBLE;
		len--;
		c = cp[len - 1];
	} else {
		typ = DOUBLE;
	}
	if (c == 'i' || c == 'I' || c == 'j' || c == 'J') {
		if (domain != NOTSPEC)
			lerror("fhexcon() 1");	/* can't happen */
		domain = COMPLEX;		/* XXX should be IMAGINARY */
		len--;
	}

	/* arbitrary value, until strtod can cope */
	d = 1.0;

	if (typ == FLOAT) {
		f = (float)d;
	}

	yylval.y_val = xcalloc(1, sizeof (val_t));
	if (typ == FLOAT) {
		yylval.y_val->v_ldbl = f;
	} else {
		yylval.y_val->v_ldbl = d;
	}
	if (mergedomain(&typ, domain))
		lerror("fhexcon() 2");
	yylval.y_val->v_tspec = typ;

	return (T_CON);
}

static int
operator(int t, op_t o)
{
	yylval.y_op = o;
	return (t);
}

/*
 * Called if lex found a leading '.
 */
static int
ccon(void)
{
	int	n, val, c;
	char	cv;

	n = 0;
	val = 0;
	while ((c = getescc('\'')) >= 0) {
		val = (val << CHAR_BIT) + c;
		n++;
	}
	if (c == -2) {
		/* unterminated character constant */
		error(253);
	} else {
		if (n > sizeof (int) || (n > 1 && (pflag || hflag))) {
			/* too many characters in character constant */
			error(71);
		} else if (n > 1) {
			/* multi-character character constant */
			warning(294);
		} else if (n == 0) {
			/* empty character constant */
			error(73);
		}
	}
	if (n == 1) {
		cv = (char)val;
		val = cv;
	}

	yylval.y_val = xcalloc(1, sizeof (val_t));
	yylval.y_val->v_tspec = INT;
	yylval.y_val->v_lspec = CHAR;
	yylval.y_val->v_quad = val;

	return (T_CON);
}

/*
 * Called if lex found a leading L\'
 */
static int
wccon(void)
{
	static	char buf[MB_LEN_MAX + 1];
	int	i, c;
	wchar_t	wc;

	i = 0;
	while ((c = getescc('\'')) >= 0) {
		if (i < MB_CUR_MAX)
			buf[i] = (char)c;
		i++;
	}

	wc = 0;

	if (c == -2) {
		/* unterminated character constant */
		error(253);
	} else if (c == 0) {
		/* empty character constant */
		error(73);
	} else {
		if (i > MB_CUR_MAX) {
			i = MB_CUR_MAX;
			/* too many characters in character constant */
			error(71);
		} else {
			buf[i] = '\0';
			(void)mbtowc(NULL, NULL, 0);
			if (mbtowc(&wc, buf, MB_CUR_MAX) < 0)
				/* invalid multibyte character */
				error(291);
		}
	}

	yylval.y_val = xcalloc(1, sizeof (val_t));
	yylval.y_val->v_tspec = WCHAR;
	yylval.y_val->v_quad = wc;

	return (T_CON);
}

/*
 * Read a character which is part of a character constant or of a string
 * and handle escapes.
 *
 * The Argument is the character which delimits the character constant or
 * string.
 *
 * Returns -1 if the end of the character constant or string is reached,
 * -2 if the EOF is reached, and the charachter otherwise.
 */
static int
getescc(int d)
{
	static	int pbc = -1;
	int	n, c, v;

	if (pbc == -1) {
		c = inpc();
	} else {
		c = pbc;
		pbc = -1;
	}
	if (c == d)
		return (-1);
	switch (c) {
	case '\n':
		/* newline in string or char constant */
		error(254);
		return (-2);
	case EOF:
		return (-2);
	case '\\':
		switch (c = inpc()) {
		case '"':
			return ('"');
		case '\'':
			return ('\'');
		case '?':
			return ('?');
		case '\\':
			return ('\\');
		case 'a':
			return ('\a');
		case 'b':
			return ('\b');
		case 'f':
			return ('\f');
		case 'n':
			return ('\n');
		case 'r':
			return ('\r');
		case 't':
			return ('\t');
		case 'v':
			return ('\v');
		case '8': case '9':
			/* bad octal digit %c */
			warning(77, c);
			/* FALLTHROUGH */
		case '0': case '1': case '2': case '3':
		case '4': case '5': case '6': case '7':
			n = 3;
			v = 0;
			do {
				v = (v << 3) + (c - '0');
				c = inpc();
			} while (--n && isdigit(c) && (c <= '7'));
			pbc = c;
			if (v > UCHAR_MAX) {
				/* character escape does not fit in char. */
				warning(76);
				v &= CHAR_MASK;
			}
			return (v);
		case 'x':
			v = 0;
			n = 0;
			while ((c = inpc()) >= 0 && isxdigit(c)) {
				c = isdigit(c) ?
					c - '0' : toupper(c) - 'A' + 10;
				v = (v << 4) + c;
				if (n >= 0) {
					if ((v & ~CHAR_MASK) != 0) {
						/* overflow in hex escape */
						warning(75);
						n = -1;
					} else {
						n++;
					}
				}
			}
			pbc = c;
			if (n == 0) {
				/* no hex digits follow \x */
				error(74);
			} if (n == -1) {
				v &= CHAR_MASK;
			}
			return (v);
		case '\n':
			return (getescc(d));
		case EOF:
			return (-2);
		default:
			if (isprint(c)) {
				/* dubious escape \%c */
				warning(79, c);
			} else {
				/* dubious escape \%o */
				warning(80, c);
			}
		}
	}
	return (c);
}

/*
 * Called for preprocessor directives. Currently implemented are:
 *	# lineno
 *	# lineno "filename"
 */
static void
directive(void)
{
	const	char *cp, *fn;
	char	c, *eptr;
	size_t	fnl;
	long	ln;
	static	int first = 1;

	/* Go to first non-whitespace after # */
	for (cp = yytext + 1; (c = *cp) == ' ' || c == '\t'; cp++) ;

	if (!isdigit(c)) {
	error:
		/* undefined or invalid # directive */
		warning(255);
		return;
	}
	ln = strtol(--cp, &eptr, 10);
	if (cp == eptr)
		goto error;
	if ((c = *(cp = eptr)) != ' ' && c != '\t' && c != '\0')
		goto error;
	while ((c = *cp++) == ' ' || c == '\t') ;
	if (c != '\0') {
		if (c != '"')
			goto error;
		fn = cp;
		while ((c = *cp) != '"' && c != '\0')
			cp++;
		if (c != '"')
			goto error;
		if ((fnl = cp++ - fn) > PATH_MAX)
			goto error;
		while ((c = *cp++) == ' ' || c == '\t') ;
#if 0
		if (c != '\0')
			warning("extra character(s) after directive");
#endif
		curr_pos.p_file = fnnalloc(fn, fnl);
		/*
		 * If this is the first directive, the name is the name
		 * of the C source file as specified at the command line.
		 * It is written to the output file.
		 */
		if (first) {
			csrc_pos.p_file = curr_pos.p_file;
			outsrc(curr_pos.p_file);
			first = 0;
		}
	}
	curr_pos.p_line = (int)ln - 1;
	if (curr_pos.p_file == csrc_pos.p_file)
		csrc_pos.p_line = (int)ln - 1;
}

/*
 * Handle lint comments. Following comments are currently understood:
 *	ARGSUSEDn
 *	CONSTCOND CONSTANTCOND CONSTANTCONDITION
 *	FALLTHRU FALLTHROUGH
 *	LINTLIBRARY
 *	LINTED NOSTRICT
 *	LONGLONG
 *	NORETURN
 *	NOTREACHED
 *	PRINTFLIKEn
 *	PROTOLIB
 *	SCANFLIKEn
 *	VARARGSn
 * If one of this comments is recognized, the arguments, if any, are
 * parsed and a function which handles this comment is called.
 */
static void
comment(void)
{
	int	c, lc;
	static struct {
		const	char *keywd;
		int	arg;
		void	(*func)(int);
	} keywtab[] = {
		{ "ARGSUSED",		1,	argsused	},
		{ "CONSTCOND",		0,	constcond	},
		{ "CONSTANTCOND",	0,	constcond	},
		{ "CONSTANTCONDITION",	0,	constcond	},
		{ "FALLTHRU",		0,	fallthru	},
		{ "FALLTHROUGH",	0,	fallthru	},
		{ "LINTLIBRARY",	0,	lintlib		},
		{ "LINTED",		0,	linted		},
		{ "LINTUSED",		0,	lintused	},
		{ "LONGLONG",		0,	longlong	},
		{ "NORETURN",		1,	noreturn	},
		{ "NOSTRICT",		0,	linted		},
		{ "NOTREACHED",		0,	notreach	},
		{ "PRINTFLIKE",		1,	printflike	},
		{ "PROTOLIB",		1,	protolib	},
		{ "SCANFLIKE",		1,	scanflike	},
		{ "VARARGS",		1,	varargs		},
	};
	char	keywd[32];
	char	arg[32];
	int	l, i, a;
	int	eoc;

	eoc = 0;

	/* Skip white spaces after the start of the comment */
	while ((c = inpc()) != EOF && isspace(c)) ;

	/* Read the potential keyword to keywd */
	l = 0;
	while (c != EOF && isupper(c) && l < sizeof (keywd) - 1) {
		keywd[l++] = (char)c;
		c = inpc();
	}
	keywd[l] = '\0';

	/* look for the keyword */
	for (i = 0; i < sizeof (keywtab) / sizeof (keywtab[0]); i++) {
		if (strcmp(keywtab[i].keywd, keywd) == 0)
			break;
	}
	if (i == sizeof (keywtab) / sizeof (keywtab[0]))
		goto skip_rest;

	/* skip white spaces after the keyword */
	while (c != EOF && isspace(c))
		c = inpc();

	/* read the argument, if the keyword accepts one and there is one */
	l = 0;
	if (keywtab[i].arg) {
		while (c != EOF && isdigit(c) && l < sizeof (arg) - 1) {
			arg[l++] = (char)c;
			c = inpc();
		}
	}
	arg[l] = '\0';
	a = l != 0 ? atoi(arg) : -1;

	/* skip white spaces after the argument */
	while (c != EOF && isspace(c))
		c = inpc();

	if (c != '*' || (c = inpc()) != '/') {
		if (keywtab[i].func != linted)
			/* extra characters in lint comment */
			warning(257);
	} else {
		/*
		 * remember that we have already found the end of the
		 * comment
		 */
		eoc = 1;
	}

	if (keywtab[i].func != NULL)
		(*keywtab[i].func)(a);

 skip_rest:
	while (!eoc) {
		lc = c;
		if ((c = inpc()) == EOF) {
			/* unterminated comment */
			error(256);
			break;
		}
		if (lc == '*' && c == '/')
			eoc = 1;
	}
}

/*
 * Handle // style comments, which are valid in C99.
 */
static void
slashslashcomment(void)
{
	int c;

	while ((c = inpc()) != EOF && c != '\n');
}

/*
 * Clear flags for lint comments LINTED, LONGLONG and CONSTCOND.
 * clrwflgs() is called after function definitions and global and
 * local declarations and definitions. It is also called between
 * the controlling expression and the body of control statements
 * (if, switch, for, while).
 */
void
clrwflgs(void)
{
	nowarn = 0;
	quadflg = 1;
	ccflg = 0;
	usedflg = 0;
}

/*
 * Strings are stored in a dynamically alloceted buffer and passed
 * in yylval.y_xstrg to the parser. The parser or the routines called
 * by the parser are responsible for freeing this buffer.
 */
static int
string(void)
{
	u_char	*s;
	int	c;
	size_t	len, max;
	strg_t	*strg;

	s = xmalloc(max = 64);

	len = 0;
	while ((c = getescc('"')) >= 0) {
		/* +1 to reserve space for a trailing NUL character */
		if (len + 1 == max)
			s = xrealloc(s, max *= 2);
		s[len++] = (char)c;
	}
	s[len] = '\0';
	if (c == -2)
		/* unterminated string constant */
		error(258);

	strg = xcalloc(1, sizeof (strg_t));
	strg->st_tspec = CHAR;
	strg->st_len = len;
	strg->st_cp = s;

	yylval.y_strg = strg;
	return (T_STRING);
}

static int
wcstrg(void)
{
	char	*s;
	int	c, i, n, wi;
	size_t	len, max, wlen;
	wchar_t	*ws;
	strg_t	*strg;

	s = xmalloc(max = 64);
	len = 0;
	while ((c = getescc('"')) >= 0) {
		/* +1 to save space for a trailing NUL character */
		if (len + 1 >= max)
			s = xrealloc(s, max *= 2);
		s[len++] = (char)c;
	}
	s[len] = '\0';
	if (c == -2)
		/* unterminated string constant */
		error(258);

	/* get length of wide character string */
	(void)mblen(NULL, 0);
	for (i = 0, wlen = 0; i < len; i += n, wlen++) {
		if ((n = mblen(&s[i], MB_CUR_MAX)) == -1) {
			/* invalid multibyte character */
			error(291);
			break;
		}
		if (n == 0)
			n = 1;
	}

	ws = xmalloc((wlen + 1) * sizeof (wchar_t));

	/* convert from multibyte to wide char */
	(void)mbtowc(NULL, NULL, 0);
	for (i = 0, wi = 0; i < len; i += n, wi++) {
		if ((n = mbtowc(&ws[wi], &s[i], MB_CUR_MAX)) == -1)
			break;
		if (n == 0)
			n = 1;
	}
	ws[wi] = 0;
	free(s);

	strg = xcalloc(1, sizeof (strg_t));
	strg->st_tspec = WCHAR;
	strg->st_len = wlen;
	strg->st_wcp = ws;

	yylval.y_strg = strg;
	return (T_STRING);
}

/*
 * As noted above the scanner does not create new symbol table entries
 * for symbols it cannot find in the symbol table. This is to avoid
 * putting undeclared symbols into the symbol table if a syntax error
 * occurs.
 *
 * getsym() is called as soon as it is probably ok to put the symbol to
 * the symbol table. This does not mean that it is not possible that
 * symbols are put to the symbol table which are than not completely
 * declared due to syntax errors. To avoid too many problems in this
 * case symbols get type int in getsym().
 *
 * XXX calls to getsym() should be delayed until decl1*() is called
 */
sym_t *
getsym(sbuf_t *sb)
{
	dinfo_t	*di;
	char	*s;
	sym_t	*sym;

	sym = sb->sb_sym;

	/*
	 * During member declaration it is possible that name() looked
	 * for symbols of type FVFT, although it should have looked for
	 * symbols of type FTAG. Same can happen for labels. Both cases
	 * are compensated here.
	 */
	if (symtyp == FMOS || symtyp == FLAB) {
		if (sym == NULL || sym->s_kind == FVFT)
			sym = search(sb);
	}

	if (sym != NULL) {
		if (sym->s_kind != symtyp)
			lerror("storesym() 1");
		symtyp = FVFT;
		freesb(sb);
		return (sym);
	}

	/* create a new symbol table entry */

	/* labels must always be allocated at level 1 (outhermost block) */
	if (symtyp == FLAB) {
		sym = getlblk(1, sizeof (sym_t));
		s = getlblk(1, sb->sb_len + 1);
		(void)memcpy(s, sb->sb_name, sb->sb_len + 1);
		sym->s_name = s;
		sym->s_blklev = 1;
		di = dcs;
		while (di->d_nxt != NULL && di->d_nxt->d_nxt != NULL)
			di = di->d_nxt;
		if (di->d_ctx != AUTO)
			lerror("storesym() 2");
	} else {
		sym = getblk(sizeof (sym_t));
		sym->s_name = sb->sb_name;
		sym->s_blklev = blklev;
		di = dcs;
	}

	STRUCT_ASSIGN(sym->s_dpos, curr_pos);
	if ((sym->s_kind = symtyp) != FLAB)
		sym->s_type = gettyp(INT);

	symtyp = FVFT;

	if ((sym->s_link = symtab[sb->sb_hash]) != NULL)
		symtab[sb->sb_hash]->s_rlink = &sym->s_link;
	(symtab[sb->sb_hash] = sym)->s_rlink = &symtab[sb->sb_hash];

	*di->d_ldlsym = sym;
	di->d_ldlsym = &sym->s_dlnxt;

	freesb(sb);
	return (sym);
}

/*
 * Remove a symbol forever from the symbol table. s_blklev
 * is set to -1 to avoid that the symbol will later be put
 * back to the symbol table.
 */
void
rmsym(sym_t *sym)
{
	if ((*sym->s_rlink = sym->s_link) != NULL)
		sym->s_link->s_rlink = sym->s_rlink;
	sym->s_blklev = -1;
	sym->s_link = NULL;
}

/*
 * Remove a list of symbols declared at one level from the symbol
 * table.
 */
void
rmsyms(sym_t *syms)
{
	sym_t	*sym;

	for (sym = syms; sym != NULL; sym = sym->s_dlnxt) {
		if (sym->s_blklev != -1) {
			if ((*sym->s_rlink = sym->s_link) != NULL)
				sym->s_link->s_rlink = sym->s_rlink;
			sym->s_link = NULL;
			sym->s_rlink = NULL;
		}
	}
}

/*
 * Put a symbol into the symbol table
 */
void
inssym(int bl, sym_t *sym)
{
	int	h;

	h = hash(sym->s_name);
	if ((sym->s_link = symtab[h]) != NULL)
		symtab[h]->s_rlink = &sym->s_link;
	(symtab[h] = sym)->s_rlink = &symtab[h];
	sym->s_blklev = bl;
	if (sym->s_link != NULL && sym->s_blklev < sym->s_link->s_blklev)
		lerror("inssym()");
}

/*
 * Called at level 0 after syntax errors
 * Removes all symbols which are not declared at level 0 from the
 * symbol table. Also frees all memory which is not associated with
 * level 0.
 */
void
cleanup(void)
{
	sym_t	*sym, *nsym;
	int	i;

	for (i = 0; i < HSHSIZ1; i++) {
		for (sym = symtab[i]; sym != NULL; sym = nsym) {
			nsym = sym->s_link;
			if (sym->s_blklev >= 1) {
				if ((*sym->s_rlink = nsym) != NULL)
					nsym->s_rlink = sym->s_rlink;
			}
		}
	}

	for (i = mblklev; i > 0; i--)
		freelblk(i);
}

/*
 * Create a new symbol with the name of an existing symbol.
 */
sym_t *
pushdown(sym_t *sym)
{
	int	h;
	sym_t	*nsym;

	h = hash(sym->s_name);
	nsym = getblk(sizeof (sym_t));
	if (sym->s_blklev > blklev)
		lerror("pushdown()");
	nsym->s_name = sym->s_name;
	STRUCT_ASSIGN(nsym->s_dpos, curr_pos);
	nsym->s_kind = sym->s_kind;
	nsym->s_blklev = blklev;

	if ((nsym->s_link = symtab[h]) != NULL)
		symtab[h]->s_rlink = &nsym->s_link;
	(symtab[h] = nsym)->s_rlink = &symtab[h];

	*dcs->d_ldlsym = nsym;
	dcs->d_ldlsym = &nsym->s_dlnxt;

	return (nsym);
}

/*
 * Free any dynamically allocated memory referenced by
 * the value stack or yylval.
 * The type of information in yylval is described by tok.
 */
void
freeyyv(void *sp, int tok)
{
	if (tok == T_NAME || tok == T_TYPENAME) {
		sbuf_t *sb = *(sbuf_t **)sp;
		freesb(sb);
	} else if (tok == T_CON) {
		val_t *val = *(val_t **)sp;
		free(val);
	} else if (tok == T_STRING) {
		strg_t *strg = *(strg_t **)sp;
		if (strg->st_tspec == CHAR) {
			free(strg->st_cp);
		} else if (strg->st_tspec == WCHAR) {
			free(strg->st_wcp);
		} else {
			lerror("fryylv() 1");
		}
		free(strg);
	}
}
@


1.33
log
@remove rcsids which escaped the purge of 2009
@
text
@d2 1
a2 1
/*	$OpenBSD: scan.l,v 1.32 2010/07/24 22:17:03 guenther Exp $	*/
@


1.32
log
@Teach lint about C99's _Bool and _Complex, plus some related gcc
extensions: __real__ and __imag__ operators, the use of '~' for
complex conjugation, and 'i' or 'j' as a suffix for complex constants.
While this doesn't handle folding and overflow detection for complex
constants correctly, it's good enough to make it through libm...and
found several bugs once it could do so.

"no objections" miod@@, krw@@
@
text
@d2 1
a2 1
/*	$OpenBSD: scan.l,v 1.31 2007/09/05 16:32:17 fgsch Exp $	*/
a34 4

#ifndef lint
static char rcsid[] = "$OpenBSD: scan.l,v 1.31 2007/09/05 16:32:17 fgsch Exp $";
#endif
@


1.31
log
@Document NORETURN, add it to the directive list and rearrange the entries.
ok deraadt@@.
@
text
@d2 1
a2 1
/*	$OpenBSD: scan.l,v 1.30 2006/05/29 20:47:22 cloder Exp $	*/
d37 1
a37 1
static char rcsid[] = "$OpenBSD: scan.l,v 1.30 2006/05/29 20:47:22 cloder Exp $";
d94 1
d102 6
a107 6
{D}+\.{D}*{EX}?[fFlL]?		|
{D}+{EX}[fFlL]?			|
\.{D}+{EX}?[fFlL]?		return (fcon());
0[xX]{HD}+\.{HD}*{HEX}[fFlL]?	|
0[xX]{HD}+{HEX}[fFlL]?		|
0[xX]\.{HD}+{HEX}[fFlL]?	return (fhexcon());
d193 1
d203 1
d207 2
d223 2
d231 1
d258 1
d304 2
d458 2
d643 1
d651 7
a657 1
	if ((c = cp[len - 1]) == 'f' || c == 'F') {
d660 1
d664 1
d668 6
d692 1
a692 1
	(yylval.y_val = xcalloc(1, sizeof (val_t)))->v_tspec = typ;
d698 3
d718 1
d726 7
a732 1
	if ((c = cp[len - 1]) == 'f' || c == 'F') {
d735 1
d739 1
d743 6
d757 1
a757 1
	(yylval.y_val = xcalloc(1, sizeof (val_t)))->v_tspec = typ;
d763 3
@


1.30
log
@Get rid of -t (traditional C) option. Some corrections by moritz.
@
text
@d2 1
a2 1
/*	$OpenBSD: scan.l,v 1.29 2006/04/20 16:29:48 cloder Exp $	*/
d37 1
a37 1
static char rcsid[] = "$OpenBSD: scan.l,v 1.29 2006/04/20 16:29:48 cloder Exp $";
d1002 1
a1023 1
		{ "NORETURN",		1,	noreturn	},
d1030 1
@


1.29
log
@Add a LINTUSED special comment which marks the following declared symbol(s)
as used so that lint2 doesn't complain. Prodded by deraadt
@
text
@d2 1
a2 1
/*	$OpenBSD: scan.l,v 1.28 2006/03/13 21:12:32 moritz Exp $	*/
d37 1
a37 1
static char rcsid[] = "$OpenBSD: scan.l,v 1.28 2006/03/13 21:12:32 moritz Exp $";
a282 2
		if (kw->kw_stdc && tflag)
			continue;
a499 4
	if (tflag && u_suffix != 0) {
		/* suffix U is illegal in traditional C */
		warning(97);
	}
d531 1
a531 3
			if (tflag) {
				typ = LONG;
			} else if (!sflag) {
d545 1
a545 1
		if (ul > LONG_MAX && !tflag) {
d552 1
a552 1
		if (uq > QUAD_MAX && !tflag) {
a646 5
	if (tflag && typ != DOUBLE) {
		/* suffixes F and L are illegal in traditional C */
		warning(98);
	}

a703 5
	if (tflag) {
		/* hex float constant are only legal in C99 */
		warning(314);
	}

a850 3
			if (tflag && d == '\'')
				/* \" inside character constant undef. ... */
				warning(262);
a854 3
			if (tflag)
				/* \? undefined in traditional C */
				warning(263);
a858 3
			if (tflag)
				/* \a undefined in traditional C */
				warning(81);
a870 3
			if (tflag)
				/* \v undefined in traditional C */
				warning(264);
d883 1
a883 4
			} while (--n && isdigit(c) && (tflag || c <= '7'));
			if (tflag && n > 0 && isdigit(c))
				/* bad octal digit %c */
				warning(77, c);
a891 3
			if (tflag)
				/* \x undefined in traditional C */
				warning(82);
@


1.28
log
@Do not warn for functions declared with ARGSUSED
but having no arguments. ok deraadt@@ cloder@@
@
text
@d2 1
a2 1
/*	$OpenBSD: scan.l,v 1.27 2006/01/16 22:16:14 espie Exp $	*/
d37 1
a37 1
static char rcsid[] = "$OpenBSD: scan.l,v 1.27 2006/01/16 22:16:14 espie Exp $";
d1064 1
d1170 1
@


1.27
log
@minimal recognition of C99 float hex constants, allows lint to parse
frexp.c.

okay cloder@@, millert@@
@
text
@d2 1
a2 1
/*	$OpenBSD: scan.l,v 1.26 2005/12/17 21:08:27 cloder Exp $	*/
d37 1
a37 1
static char rcsid[] = "$OpenBSD: scan.l,v 1.26 2005/12/17 21:08:27 cloder Exp $";
d719 1
a719 1
		warning(315);
@


1.26
log
@Handle __dead functions using lint comments.
@
text
@d2 1
a2 1
/*	$OpenBSD: scan.l,v 1.25 2005/12/11 20:02:09 deraadt Exp $	*/
d37 1
a37 1
static char rcsid[] = "$OpenBSD: scan.l,v 1.25 2005/12/11 20:02:09 deraadt Exp $";
d74 1
d93 1
d104 3
d626 1
a626 1
 * Convert a string representing a floating point value into its interal
d675 52
@


1.25
log
@make this compile again
@
text
@d2 1
a2 1
/*	$OpenBSD: scan.l,v 1.24 2005/12/10 18:51:54 martin Exp $	*/
d37 1
a37 1
static char rcsid[] = "$OpenBSD: scan.l,v 1.24 2005/12/10 18:51:54 martin Exp $";
d1002 1
@


1.24
log
@translate a bunch of comments from german to english

ok cloder@@
@
text
@d2 1
a2 1
/*	$OpenBSD: scan.l,v 1.23 2005/12/10 17:41:03 cloder Exp $	*/
d37 1
a37 1
static char rcsid[] = "$OpenBSD: scan.l,v 1.23 2005/12/10 17:41:03 cloder Exp $";
d187 1
a187 1
	};
d241 4
@


1.23
log
@Back out all gcc attribute parsing changes until we can do this the right
way some day.  The effect of __attribute__ on a LALR C grammar is just too
ugly to fix quicklly.
@
text
@d2 1
a2 1
/*	$OpenBSD: scan.l,v 1.18 2005/12/02 18:03:09 cloder Exp $	*/
d37 1
a37 1
static char rcsid[] = "$OpenBSD: scan.l,v 1.18 2005/12/02 18:03:09 cloder Exp $";
d257 1
a257 1
/* Typ of next expected symbol */
@


1.22
log
@Don't ever complain when assigning a char literal to a char lvalue,
regardless of sign/unsign differences.  In other words, even though C
treats char literals as ints, if the rvalue is a literal inside single
quotes, and the lvalue is any kind of char, then assume the programmer
knows what he is doing.
@
text
@d2 1
a2 1
/*	$OpenBSD: scan.l,v 1.21 2005/12/07 01:55:12 cloder Exp $	*/
d37 1
a37 1
static char rcsid[] = "$OpenBSD: scan.l,v 1.21 2005/12/07 01:55:12 cloder Exp $";
d187 1
a187 1
	} kw_u;
a193 1
	{ "__attribute",	T_ATTRIBUTE,	{ 0 },		0, 0 },
a241 4
#define kw_scl		kw_u.kw_scl
#define kw_tspec	kw_u.kw_tspec
#define kw_tqual	kw_u.kw_tqual

a1409 34
}

/*
 * Return the corresponding attr_t constant for a particular C keyword,
 * or AT_UNKNOWN if not known.
 */
attr_t
getkwattr(int tok, int val)
{
	struct	kwtab *kw;
	int	eq;
	
	eq = 0;
	for (kw = kwtab; !eq && kw->kw_name != NULL; kw++) {
		if (kw->kw_token == tok) {
			switch (tok) {
			case T_QUAL:
				eq = (val == kw->kw_tqual);
				break;
			case T_TYPE:
			case T_SOU:
				eq = (val == kw->kw_tspec);
				break;
			case T_SCLASS:
				eq = (val == kw->kw_scl);
				break;
			}

			if (eq)
				return getattr(kw->kw_name);
		}
	}

	return AT_UNKNOWN;
@


1.21
log
@Refactor __attribute__ parsing a bit.  This takes us further to being able
to not only consume, but also make sense of gcc __attribute__ syntax.
@
text
@d2 1
a2 1
/*	$OpenBSD: scan.l,v 1.20 2005/12/03 01:14:39 cloder Exp $	*/
d37 1
a37 1
static char rcsid[] = "$OpenBSD: scan.l,v 1.20 2005/12/03 01:14:39 cloder Exp $";
d691 1
a691 1
 * Called if lex found a leading \'.
d727 1
@


1.20
log
@Fix enum types, thanks lint
@
text
@d2 1
a2 1
/*	$OpenBSD: scan.l,v 1.19 2005/12/03 00:27:54 cloder Exp $	*/
d37 1
a37 1
static char rcsid[] = "$OpenBSD: scan.l,v 1.19 2005/12/03 00:27:54 cloder Exp $";
a186 1
		attr_t	kw_attr;	/* attribute spec. if kw_token T_ATTR */
a219 1
	{ "__noreturn__",	T_ATTR,		{ NORETURN },	0, 1 },
a245 1
#define kw_attr		kw_u.kw_attr
a292 2
		} else if (kw->kw_token == T_ATTR) {
			sym->s_attr = kw->kw_attr;
a444 2
	} else if (t == T_ATTR) {
		yylval.y_attr = sym->s_attr;
d1414 34
@


1.19
log
@Lint can now parse every variation of gcc's __attribute__ that I could find
either in our tree or in the gcc docs.  See regression test 11 for examples
of this.  Right now, our cdefs.h actually defines __attribute__(x) to blank
when lint runs.  We can change this whenever we choose.
@
text
@d2 1
a2 1
/*	$OpenBSD: scan.l,v 1.17 2005/12/01 03:17:14 cloder Exp $	*/
d37 1
a37 1
static char rcsid[] = "$OpenBSD: scan.l,v 1.17 2005/12/01 03:17:14 cloder Exp $";
d188 1
a188 1
	};
d244 5
@


1.18
log
@Make three of the keytab fields into a union, because they are 3 different
enums that are mutually exclusive with each other.  Makes this file so
much neater.
@
text
@d187 1
d195 1
d221 1
d291 2
d445 2
@


1.17
log
@Typo
@
text
@d2 1
a2 1
/*	$OpenBSD: scan.l,v 1.16 2005/11/30 19:42:58 cloder Exp $	*/
d37 1
a37 1
static char rcsid[] = "$OpenBSD: scan.l,v 1.16 2005/11/30 19:42:58 cloder Exp $";
d183 5
a187 3
	scl_t	kw_scl;		/* storage class if kw_token T_SCLASS */
	tspec_t	kw_tspec;	/* type spec. if kw_token T_TYPE or T_SOU */
	tqual_t	kw_tqual;	/* type qual. fi kw_token T_QUAL */
d191 49
a239 49
	{ "asm",	T_ASM,		0,	0,	0,	  0, 1 },
	{ "__asm",	T_ASM,		0,	0,	0,	  0, 0 },
	{ "__asm__",	T_ASM,		0,	0,	0,	  0, 0 },
	{ "__attribute__", T_ATTRIBUTE,	0,	0,	0,	  0, 0 },
	{ "__lint_equal__", T_LEQUAL,	0,	0,	0,	  0, 0 },
	{ "auto",	T_SCLASS,	AUTO,	0,	0,	  0, 0 },
	{ "break",	T_BREAK,	0,	0,	0,	  0, 0 },
	{ "case",	T_CASE,		0,	0,	0,	  0, 0 },
	{ "char",	T_TYPE,		0,	CHAR,	0,	  0, 0 },
	{ "const",	T_QUAL,		0,	0,	CONST,	  1, 0 },
	{ "__const__",	T_QUAL,		0,	0,	CONST,	  0, 0 },
	{ "__const",	T_QUAL,		0,	0,	CONST,	  0, 0 },
	{ "continue",	T_CONTINUE,	0,	0,	0,	  0, 0 },
	{ "default",	T_DEFAULT,	0,	0,	0,	  0, 0 },
	{ "do",		T_DO,		0,	0,	0,	  0, 0 },
	{ "double",	T_TYPE,		0,	DOUBLE,	0,	  0, 0 },
	{ "else",	T_ELSE,		0,	0,	0,	  0, 0 },
	{ "enum",	T_ENUM,		0,	0,	0,	  0, 0 },
	{ "extern",	T_SCLASS,	EXTERN,	0,	0,	  0, 0 },
	{ "float",	T_TYPE,		0,	FLOAT,	0,	  0, 0 },
	{ "for",	T_FOR,		0,	0,	0,	  0, 0 },
	{ "goto",	T_GOTO,		0,	0,	0,	  0, 0 },
	{ "if",		T_IF,		0,	0,	0,	  0, 0 },
	{ "inline",	T_SCLASS,	INLINE,	0,	0,	  1, 0 },
	{ "__inline__",	T_SCLASS,	INLINE,	0,	0,	  0, 0 },
	{ "__inline",	T_SCLASS,	INLINE,	0,	0,	  0, 0 },
	{ "int",	T_TYPE,		0,	INT,	0,	  0, 0 },
	{ "long",	T_TYPE,		0,	LONG,	0,	  0, 0 },
	{ "register",	T_SCLASS,	REG,	0,	0,	  0, 0 },
	{ "__restrict",	T_QUAL,		0,	0,	RESTRICT, 0, 0 },
	{ "__restrict__",	T_QUAL,	0,	0,	RESTRICT, 0, 0 },
	{ "return",	T_RETURN,	0,	0,	0,	  0, 0 },
	{ "short",	T_TYPE,		0,	SHORT,	0,	  0, 0 },
	{ "signed",	T_TYPE,		0,	SIGNED,	0,	  1, 0 },
	{ "__signed__",	T_TYPE,		0,	SIGNED,	0,	  0, 0 },
	{ "__signed",	T_TYPE,		0,	SIGNED,	0,	  0, 0 },
	{ "sizeof",	T_SIZEOF,	0,	0,	0,	  0, 0 },
	{ "static",	T_SCLASS,	STATIC,	0,	0,	  0, 0 },
	{ "struct",	T_SOU,		0,	STRUCT,	0,	  0, 0 },
	{ "switch",	T_SWITCH,	0,	0,	0,	  0, 0 },
	{ "typedef",	T_SCLASS,	TYPEDEF, 0,	0,	  0, 0 },
	{ "union",	T_SOU,		0,	UNION,	0,	  0, 0 },
	{ "unsigned",	T_TYPE,		0,	UNSIGN,	0,	  0, 0 },
	{ "void",	T_TYPE,		0,	VOID,	0,	  0, 0 },
	{ "volatile",	T_QUAL,		0,	0,	VOLATILE, 1, 0 },
	{ "__volatile__", T_QUAL,	0,	0,	VOLATILE, 0, 0 },
	{ "__volatile",	T_QUAL,		0,	0,	VOLATILE, 0, 0 },
	{ "while",	T_WHILE,	0,	0,	0,	  0, 0 },
	{ NULL,		0,		0,	0,	0,	  0, 0 }
@


1.16
log
@Add support for // comments. From NetBSD
@
text
@d2 1
a2 1
/*	$OpenBSD: scan.l,v 1.15 2005/11/30 06:32:00 cloder Exp $	*/
d37 1
a37 1
static char rcsid[] = "$OpenBSD: scan.l,v 1.15 2005/11/30 06:32:00 cloder Exp $";
d510 1
a510 1
         * If the value is to big for the current type, we must choose
@


1.15
log
@KNF
@
text
@d2 1
a2 1
/*	$OpenBSD: scan.l,v 1.14 2005/11/30 06:22:42 cloder Exp $	*/
d37 1
a37 1
static char rcsid[] = "$OpenBSD: scan.l,v 1.14 2005/11/30 06:22:42 cloder Exp $";
d80 1
d156 1
d1078 11
@


1.14
log
@Fix a very old bug_t with memset
@
text
@d2 1
a2 1
/*	$OpenBSD: scan.l,v 1.13 2005/11/29 20:47:44 cloder Exp $	*/
d37 1
a37 1
static char rcsid[] = "$OpenBSD: scan.l,v 1.13 2005/11/29 20:47:44 cloder Exp $";
d160 1
a160 1
incline()
d168 1
a168 2
badchar(c)
	int	c;
d262 1
a262 1
initscan()
d306 1
a306 1
allocsb()
d323 1
a323 2
freesb(sb)
	sbuf_t	*sb;
d334 1
a334 1
inpc()
d344 1
a344 2
hash(s)
	const	char *s;
d373 1
a373 1
name()
d411 1
a411 2
search(sb)
	sbuf_t	*sb;
d426 1
a426 2
keyw(sym)
	sym_t	*sym;
d445 1
a445 2
icon(base)
	int	base;
d580 1
a580 4
sign(q, t, len)
	quad_t	q;
	tspec_t	t;
	int	len;
d588 1
a588 4
msb(q, t, len)
	quad_t	q;
	tspec_t	t;
	int	len;
d599 1
a599 4
xsign(q, t, len)
	quad_t	q;
	tspec_t	t;
	int	len;
d620 1
a620 1
fcon()
d675 1
a675 3
operator(t, o)
	int	t;
	op_t	o;
d685 1
a685 1
ccon()
d727 1
a727 1
wccon()
d780 1
a780 2
getescc(d)
	int	d;
d909 1
a909 1
directive()
d981 1
a981 1
comment()
d1086 1
a1086 1
clrwflgs()
d1099 1
a1099 1
string()
d1130 1
a1130 1
wcstrg()
d1200 1
a1200 2
getsym(sb)
	sbuf_t	*sb;
d1271 1
a1271 2
rmsym(sym)
	sym_t	*sym;
d1284 1
a1284 2
rmsyms(syms)
	sym_t	*syms;
d1302 1
a1302 3
inssym(bl, sym)
	int	bl;
	sym_t	*sym;
d1322 1
a1322 1
cleanup()
d1345 1
a1345 2
pushdown(sym)
	sym_t	*sym;
d1375 1
a1375 3
freeyyv(sp, tok)
	void	*sp;
	int	tok;
@


1.13
log
@stdlib.h has strtouq in it
@
text
@d2 1
a2 1
/*	$OpenBSD: scan.l,v 1.12 2005/11/24 01:45:28 deraadt Exp $	*/
d37 1
a37 1
static char rcsid[] = "$OpenBSD: scan.l,v 1.12 2005/11/24 01:45:28 deraadt Exp $";
d316 1
a316 1
	(void)memset(sb, 0, sizeof (sb));
@


1.12
log
@spacing
@
text
@d2 1
a2 1
/*	$OpenBSD: scan.l,v 1.11 2005/11/23 20:36:41 cloder Exp $	*/
d37 1
a37 1
static char rcsid[] = "$OpenBSD: scan.l,v 1.11 2005/11/23 20:36:41 cloder Exp $";
a52 3

/* XXX declaration of strtouq() is missing in stdlib.h ? */
extern	u_quad_t strtouq(const char *, char **, int);
@


1.11
log
@"inline" is a c99 keyword, so support it unless tflag is selected.
OK and input from millert, earlier version looked at by deraadt
@
text
@d2 1
a2 1
/*	$OpenBSD: scan.l,v 1.10 2005/11/23 18:47:41 cloder Exp $	*/
d37 1
a37 1
static char rcsid[] = "$OpenBSD: scan.l,v 1.10 2005/11/23 18:47:41 cloder Exp $";
d431 1
a431 1
			
d735 1
a735 1
	
d1422 1
a1422 1
	}	
@


1.10
log
@Grok __restrict__ and __restrict keywords.  OK deraadt
@
text
@d2 1
a2 1
/*	$OpenBSD: scan.l,v 1.9 2005/11/23 09:05:42 deraadt Exp $	*/
d37 1
a37 1
static char rcsid[] = "$OpenBSD: scan.l,v 1.9 2005/11/23 09:05:42 deraadt Exp $";
d214 1
a214 1
	{ "inline",	T_SCLASS,	INLINE,	0,	0,	  0, 1 },
@


1.9
log
@add a fake C construct __lint_equal__ which will be used to generate
alias entries for weak symbols and such
also let ; at the top scope be legal
@
text
@d2 1
a2 1
/*	$OpenBSD: scan.l,v 1.7 2005/11/20 17:42:49 deraadt Exp $	*/
d37 1
a37 1
static char rcsid[] = "$OpenBSD: scan.l,v 1.7 2005/11/20 17:42:49 deraadt Exp $";
d220 2
@


1.8
log
@support __attribute__
@
text
@d2 1
a2 1
/*	$OpenBSD: scan.l,v 1.8 2005/11/23 08:36:03 deraadt Exp $	*/
d37 1
a37 1
static char rcsid[] = "$OpenBSD: scan.l,v 1.8 2005/11/23 08:36:03 deraadt Exp $";
d195 1
@


1.7
log
@spacing
@
text
@d2 1
a2 1
/*	$OpenBSD: scan.l,v 1.6 2004/05/10 15:26:22 deraadt Exp $	*/
d37 1
a37 1
static char rcsid[] = "$OpenBSD: scan.l,v 1.6 2004/05/10 15:26:22 deraadt Exp $";
d194 1
@


1.6
log
@using a horrid hack: permit long long.  millert ok
@
text
@d2 1
a2 1
/*	$OpenBSD: scan.l,v 1.5 2002/02/19 19:39:39 millert Exp $	*/
d37 1
a37 1
static char rcsid[] = "$OpenBSD: scan.l,v 1.5 2002/02/19 19:39:39 millert Exp $";
d97 1
a97 1
{L}({L}|{D})*		 	return (name());
@


1.5
log
@We live in an ANSI C world.  Remove lots of gratuitous #ifdef __STDC__ cruft.
@
text
@d2 1
a2 1
/*	$OpenBSD: scan.l,v 1.4 2002/02/16 21:27:59 millert Exp $	*/
d37 1
a37 1
static char rcsid[] = "$OpenBSD: scan.l,v 1.4 2002/02/16 21:27:59 millert Exp $";
d1106 1
a1106 1
	quadflg = 0;
@


1.4
log
@Part one of userland __P removal.  Done with a simple regexp with some minor hand editing to make comments line up correctly.  Another pass is forthcoming that handles the cases that could not be done automatically.
@
text
@d2 1
a2 1
/*	$OpenBSD: scan.l,v 1.3 1996/06/26 05:44:18 deraadt Exp $	*/
d37 1
a37 1
static char rcsid[] = "$OpenBSD: scan.l,v 1.3 1996/06/26 05:44:18 deraadt Exp $";
a836 1
#ifdef __STDC__
a837 3
#else
			return ('\007');
#endif
a851 1
#ifdef __STDC__
a852 3
#else
			return ('\013');
#endif
@


1.3
log
@rcsid
@
text
@d2 1
a2 1
/*	$OpenBSD: scan.l,v 1.8 1995/10/23 13:38:51 jpo Exp $	*/
d37 1
a37 1
static char rcsid[] = "$OpenBSD: scan.l,v 1.8 1995/10/23 13:38:51 jpo Exp $";
d55 1
a55 1
extern	u_quad_t strtouq __P((const char *, char **, int));
d66 19
a84 19
static	void	incline __P((void));
static	void	badchar __P((int));
static	sbuf_t	*allocsb __P((void));
static	void	freesb __P((sbuf_t *));
static	int	inpc __P((void));
static	int	hash __P((const char *));
static	sym_t	*search __P((sbuf_t *));
static	int	name __P((void));
static	int	keyw __P((sym_t *));
static	int	icon __P((int));
static	int	fcon __P((void));
static	int	operator __P((int, op_t));
static	int	ccon __P((void));
static	int	wccon __P((void));
static	int	getescc __P((int));
static	void	directive __P((void));
static	void	comment __P((void));
static	int	string __P((void));
static	int	wcstrg __P((void));
d1012 1
a1012 1
		void	(*func) __P((int));
@


1.2
log
@update from netbsd
@
text
@d2 1
d37 1
a37 1
static char rcsid[] = "$NetBSD: scan.l,v 1.8 1995/10/23 13:38:51 jpo Exp $";
@


1.1
log
@Initial revision
@
text
@d2 1
a2 1
/*	$NetBSD: scan.l,v 1.7 1995/10/02 17:29:59 jpo Exp $	*/
d36 1
a36 1
static char rcsid[] = "$NetBSD: scan.l,v 1.7 1995/10/02 17:29:59 jpo Exp $";
d744 1
a744 1
	static	char buf[MB_CUR_MAX + 1];
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@
