head	1.16;
access;
symbols
	OPENBSD_5_1_BASE:1.15
	OPENBSD_5_1:1.15.0.4
	OPENBSD_5_0:1.15.0.2
	OPENBSD_5_0_BASE:1.15
	OPENBSD_4_9:1.14.0.4
	OPENBSD_4_9_BASE:1.14
	OPENBSD_4_8:1.14.0.2
	OPENBSD_4_8_BASE:1.14
	OPENBSD_4_7:1.13.0.14
	OPENBSD_4_7_BASE:1.13
	OPENBSD_4_6:1.13.0.16
	OPENBSD_4_6_BASE:1.13
	OPENBSD_4_5:1.13.0.12
	OPENBSD_4_5_BASE:1.13
	OPENBSD_4_4:1.13.0.10
	OPENBSD_4_4_BASE:1.13
	OPENBSD_4_3:1.13.0.8
	OPENBSD_4_3_BASE:1.13
	OPENBSD_4_2:1.13.0.6
	OPENBSD_4_2_BASE:1.13
	OPENBSD_4_1:1.13.0.4
	OPENBSD_4_1_BASE:1.13
	OPENBSD_4_0:1.13.0.2
	OPENBSD_4_0_BASE:1.13
	OPENBSD_3_9:1.11.0.2
	OPENBSD_3_9_BASE:1.11
	OPENBSD_3_8:1.2.0.38
	OPENBSD_3_8_BASE:1.2
	OPENBSD_3_7:1.2.0.36
	OPENBSD_3_7_BASE:1.2
	OPENBSD_3_6:1.2.0.34
	OPENBSD_3_6_BASE:1.2
	OPENBSD_3_5:1.2.0.32
	OPENBSD_3_5_BASE:1.2
	OPENBSD_3_4:1.2.0.30
	OPENBSD_3_4_BASE:1.2
	OPENBSD_3_3:1.2.0.28
	OPENBSD_3_3_BASE:1.2
	OPENBSD_3_2:1.2.0.26
	OPENBSD_3_2_BASE:1.2
	OPENBSD_3_1:1.2.0.24
	OPENBSD_3_1_BASE:1.2
	OPENBSD_3_0:1.2.0.22
	OPENBSD_3_0_BASE:1.2
	OPENBSD_2_9_BASE:1.2
	OPENBSD_2_9:1.2.0.20
	OPENBSD_2_8:1.2.0.18
	OPENBSD_2_8_BASE:1.2
	OPENBSD_2_7:1.2.0.16
	OPENBSD_2_7_BASE:1.2
	OPENBSD_2_6:1.2.0.14
	OPENBSD_2_6_BASE:1.2
	OPENBSD_2_5:1.2.0.12
	OPENBSD_2_5_BASE:1.2
	OPENBSD_2_4:1.2.0.10
	OPENBSD_2_4_BASE:1.2
	OPENBSD_2_3:1.2.0.8
	OPENBSD_2_3_BASE:1.2
	OPENBSD_2_2:1.2.0.6
	OPENBSD_2_2_BASE:1.2
	OPENBSD_2_1:1.2.0.4
	OPENBSD_2_1_BASE:1.2
	OPENBSD_2_0:1.2.0.2
	OPENBSD_2_0_BASE:1.2
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.16
date	2012.04.08.16.27.00;	author jsg;	state dead;
branches;
next	1.15;

1.15
date	2011.05.30.15.15.58;	author martynas;	state Exp;
branches;
next	1.14;

1.14
date	2010.07.24.22.17.03;	author guenther;	state Exp;
branches;
next	1.13;

1.13
date	2006.04.18.02.59.40;	author cloder;	state Exp;
branches;
next	1.12;

1.12
date	2006.03.08.07.18.51;	author moritz;	state Exp;
branches;
next	1.11;

1.11
date	2005.12.17.21.08.27;	author cloder;	state Exp;
branches;
next	1.10;

1.10
date	2005.12.10.17.41.03;	author cloder;	state Exp;
branches;
next	1.9;

1.9
date	2005.12.09.03.13.08;	author cloder;	state Exp;
branches;
next	1.8;

1.8
date	2005.12.07.01.55.12;	author cloder;	state Exp;
branches;
next	1.7;

1.7
date	2005.12.03.01.14.39;	author cloder;	state Exp;
branches;
next	1.6;

1.6
date	2005.12.03.00.27.54;	author cloder;	state Exp;
branches;
next	1.5;

1.5
date	2005.11.29.19.38.09;	author cloder;	state Exp;
branches;
next	1.4;

1.4
date	2005.11.23.18.47.41;	author cloder;	state Exp;
branches;
next	1.3;

1.3
date	2005.11.20.17.42.49;	author deraadt;	state Exp;
branches;
next	1.2;

1.2
date	96.06.26.05.44.15;	author deraadt;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.47.02;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.47.02;	author deraadt;	state Exp;
branches;
next	;


desc
@@


1.16
log
@tedu lint
ok tedu@@ guenther@@ krw@@ espie@@ deraadt@@
@
text
@/*	$OpenBSD: lint1.h,v 1.15 2011/05/30 15:15:58 martynas Exp $	*/
/*	$NetBSD: lint1.h,v 1.6 1995/10/02 17:31:41 jpo Exp $	*/

/*
 * Copyright (c) 1994, 1995 Jochen Pohl
 * All Rights Reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *      This product includes software developed by Jochen Pohl for
 *	The NetBSD Project.
 * 4. The name of the author may not be used to endorse or promote products
 *    derived from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
 * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
 * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

#include "lint.h"
#include "op.h"

/*
 * Describes the position of a declaration or anything else.
 */
typedef struct {
	int	p_line;
	const	char *p_file;
} pos_t;

/*
 * Strings cannot be referenced to simply by a pointer to its first
 * char. This is because strings can contain NUL characters other than the
 * trailing NUL.
 *
 * Strings are stored with a trailing NUL.
 */
typedef	struct strg {
	tspec_t	st_tspec;		/* CHAR or WCHAR */
	size_t	st_len;			/* length without trailing NUL */
	union {
		u_char	*_st_cp;
		wchar_t	*_st_wcp;
	} st_u;
} strg_t;

#define st_cp	st_u._st_cp
#define	st_wcp	st_u._st_wcp

/*
 * qualifiers (only for lex/yacc interface)
 */
typedef enum {
	CONST, VOLATILE, RESTRICT
} tqual_t;

/*
 * Integer and floating point values are stored in this structure
 */
typedef struct {
	tspec_t	v_tspec;
	int	v_ansiu;		/* set if an integer constant is
					   unsigned in ANSI C */
	tspec_t	v_lspec;		/* the underlying type of a literal */
	union {
		quad_t	_v_quad;	/* integers */
		ldbl_t	_v_ldbl;	/* floats */
	} v_u;
} val_t;

#define v_quad	v_u._v_quad
#define v_ldbl	v_u._v_ldbl

/*
 * Structures of type str_t uniqely identify structures. This can't
 * be done in structures of type type_t, because these are copied
 * if they must be modified. So it would not be possible to check
 * if two structures are identical by comparing the pointers to
 * the type structures.
 *
 * The typename is used if the structure is unnamed to identify
 * the structure type in pass 2.
 */
typedef	struct {
	u_int	size;		/* size in bit */
	u_int	align : 15;	/* alignment in bit */
	u_int	sincompl : 1;	/* set if incomplete type */
	struct	sym *memb;	/* list of members */
	struct	sym *stag;	/* symbol table entry of tag */
	struct	sym *stdef;	/* symbol table entry of first typename */
} str_t;

/*
 * same as above for enums
 */
typedef	struct {
	u_int	eincompl : 1;	/* incomplete enum type */
	struct	sym *elem;	/* list of enumerators */
	struct	sym *etag;	/* symbol table entry of tag */
	struct	sym *etdef;	/* symbol table entry of first typename */
} enum_t;

/*
 * Types are represented by concatenation of structures of type type_t
 * via t_subt.
 */
typedef	struct type {
	tspec_t	t_tspec;	/* type specifier */
	u_int	t_aincompl : 1;	/* incomplete array type */
	u_int	t_const : 1;	/* const modifier */
	u_int	t_volatile : 1;	/* volatile modifier */
	u_int	t_restrict : 1;	/* restrict modifier */
	u_int	t_proto : 1;	/* function prototype (t_args valid) */
	u_int	t_vararg : 1;	/* protoype with ... */
	u_int	t_typedef : 1;	/* type defined with typedef */
	u_int	t_isfield : 1;	/* type is bitfield */
	u_int	t_isenum : 1;	/* type is (or was) enum (t_enum valid) */
	union {
		int	_t_dim;		/* dimension */
		str_t	*_t_str;	/* struct/union tag */
		enum_t	*_t_enum;	/* enum tag */
		struct	sym *_t_args;	/* arguments (if t_proto) */
		struct {
			u_int	_t_flen : 8;	/* length of bit-field */
			u_int	_t_foffs : 24;	/* offset of bit-field */
		} _t_u;
	} t_u;
	struct	type *t_subt;	/* element type (arrays), return value
				   (functions), or type pointer points to */
} type_t;

#define	t_dim	t_u._t_dim
#define	t_str	t_u._t_str
#define	t_field	t_u._t_field
#define	t_enum	t_u._t_enum
#define	t_args	t_u._t_args
#define	t_flen	t_u._t_u._t_flen
#define	t_foffs	t_u._t_u._t_foffs

/*
 * types of symbols
 */
typedef	enum {
	FVFT,		/* variables, functions, type names, enums */
	FMOS,		/* members of structs or unions */
	FTAG,		/* tags */
	FLAB		/* labels */
} symt_t;

/*
 * storage classes
 */
typedef enum {
	NOSCL,
	EXTERN,		/* external symbols (indep. of decl_t) */
	STATIC,		/* static symbols (local and global) */
	AUTO,		/* automatic symbols (except register) */
	REG,		/* register */
	TYPEDEF,	/* typedef */
	STRTAG,
	UNIONTAG,
	ENUMTAG,
	MOS,		/* member of struct */
	MOU,		/* member of union */
	ENUMCON,	/* enumerator */
	ABSTRACT,	/* abstract symbol (sizeof, casts, unnamed argument) */
	ARG,		/* argument */
	PARG,		/* used in declaration stack during prototype
			   declaration */
	INLINE		/* only used by the parser */
} scl_t;

/*
 * symbol table entry
 */
typedef	struct sym {
	const	char *s_name;	/* name */
	pos_t	s_dpos;		/* position of last (prototype)definition,
				   prototypedeclaration, no-prototype-def.,
				   tentative definition or declaration,
				   in this order */
	pos_t	s_spos;		/* position of first initialisation */
	pos_t	s_upos;		/* position of first use */
	symt_t	s_kind;		/* type of symbol */
	u_int	s_keyw : 1;	/* keyword */
	u_int	s_field : 1;	/* bit-field */
	u_int	s_set : 1;	/* variable set, label defined */
	u_int	s_used : 1;	/* variable/label used */
	u_int	s_arg : 1;	/* symbol is function argument */
	u_int	s_reg : 1;	/* symbol is register variable */
	u_int	s_defarg : 1;	/* undefined symbol in old style function
				   definition */
	u_int	s_rimpl : 1;	/* return value of function implicit decl. */
	u_int	s_osdef : 1;	/* symbol stems from old style function def. */
	u_int	s_inline : 1;	/* true if this is a inline function */
	u_int	s_noreturn : 1;	/* true if this is a NORETURN function */
	struct	sym *s_xsym;	/* for local declared external symbols pointer
				   to external symbol with same name */
	def_t	s_def;		/* declared, tentative defined, defined */
	scl_t	s_scl;		/* storage class */
	int	s_blklev;	/* level of declaration, -1 if not in symbol
				   table */
	type_t	*s_type;	/* type */
	val_t	s_value;	/* value (if enumcon) */
	union {
		str_t	*_s_st;	/* tag, if it is a struct/union member */
		enum_t	*_s_et;	/* tag, if it is a enumerator */
		tspec_t	_s_tsp;	/* type (only for keywords) */
		tqual_t	_s_tqu;	/* qualifier (only for keywords) */
		struct	sym *_s_args; /* arguments in old style function
					 definitions */
		op_t	_s_op;	/* op type (only for operators) */
	} u;
	struct	sym *s_link;	/* next symbol with same hash value */
	struct	sym **s_rlink;	/* pointer to s_link of prev. symbol */
	struct	sym *s_nxt;	/* next struct/union member, enumerator,
				   argument */
	struct	sym *s_dlnxt;	/* next symbol declared on same level */
} sym_t;

#define	s_styp	u._s_st
#define	s_etyp	u._s_et
#define	s_tspec	u._s_tsp
#define	s_tqual	u._s_tqu
#define	s_op	u._s_op
#define	s_args	u._s_args

/*
 * Used to keep some informations about symbols before they are entered
 * into the symbol table.
 */
typedef	struct sbuf {
	const	char *sb_name;		/* name of symbol */
	size_t	sb_len;			/* length (without '\0') */
	int	sb_hash;		/* hash value */
	sym_t	*sb_sym;		/* symbol table entry */
	struct	sbuf *sb_nxt;		/* for freelist */
} sbuf_t;


/*
 * tree node
 */
typedef	struct tnode {
	op_t	tn_op;		/* operator */
	type_t	*tn_type;	/* type */
	u_int	tn_lvalue : 1;	/* node is lvalue */
	u_int	tn_cast : 1;	/* if tn_op == CVT its an explicit cast */
	u_int	tn_parn : 1;	/* node parenthesized */
	union {
		struct {
			struct	tnode *_tn_left;	/* (left) operand */
			struct	tnode *_tn_right;	/* right operand */
		} tn_s;
		sym_t	*_tn_sym;	/* symbol if op == NAME */
		val_t	*_tn_val;	/* value if op == CON */
		strg_t	*_tn_strg;	/* string if op == STRING */
	} tn_u;
} tnode_t;

#define	tn_left	tn_u.tn_s._tn_left
#define tn_right tn_u.tn_s._tn_right
#define tn_sym	tn_u._tn_sym
#define	tn_val	tn_u._tn_val
#define	tn_strg	tn_u._tn_strg

/*
 * For nested declarations a stack exists, which holds all information
 * needed for the current level. dcs points to the top element of this
 * stack.
 *
 * ctx describes the context of the current declaration. Its value is
 * one of
 *	EXTERN	global declarations
 *	MOS oder MOU declarations of struct or union members
 *	ENUMCON	declarations of enums
 *	ARG	declaration of arguments in old style function definitions
 *	PARG	declaration of arguments in function prototypes
 *	AUTO	declaration of local symbols
 *	ABSTRACT abstract declarations (sizeof, casts)
 *
 */
typedef	struct dinfo {
	tspec_t	d_atyp;		/* NOTSPEC, VOID, CHAR, INT, FLOAT or DOUBLE */
	tspec_t	d_smod;		/* sign: NOTSPEC, SIGNED or UNSIGN */
	tspec_t	d_lmod;		/* length: NOTSPEC, SHORT, LONG or QUAD */
	tspec_t	d_dmod;		/* domain: NOTSPEC, COMPLEX or IMAGINARY */
	scl_t	d_scl;		/* storage class */
	type_t	*d_type;	/* after deftyp() pointer to the type used
				   for all declarators */
	sym_t	*d_rdcsym;	/* redeclared symbol */
	int	d_offset;	/* offset of next structure member */
	int	d_stralign;	/* alignment required for current structure */
	scl_t	d_ctx;		/* context of declaration */
	u_int	d_const : 1;	/* const in declaration specifiers */
	u_int	d_volatile : 1;	/* volatile in declaration specifiers */
	u_int	d_restrict : 1;	/* restrict in declaration specifiers */
	u_int	d_inline : 1;	/* inline in declaration specifiers */
	u_int	d_mscl : 1;	/* multiple storage classes */
	u_int	d_terr : 1;	/* invalid type combination */
	u_int	d_nedecl : 1;	/* 1 if at least a tag is declared */
	u_int	d_vararg : 1;	/* ... in current function decl. */
	u_int	d_proto : 1;	/* current funct. decl. is prototype */
	u_int	d_notyp : 1;	/* set if no type specifier was present */
	u_int	d_asm : 1;	/* set if d_ctx == AUTO and asm() present */
	type_t	*d_tagtyp;	/* tag during member declaration */
	sym_t	*d_fargs;	/* list of arguments during function def. */
	pos_t	d_fdpos;	/* position of function definition */
	sym_t	*d_dlsyms;	/* first symbol declared at this level */
	sym_t	**d_ldlsym;	/* points to s_dlnxt in last symbol decl.
				   at this level */
	sym_t	*d_fpsyms;	/* symbols defined in prototype */
	struct	dinfo *d_nxt;	/* next level */
} dinfo_t;

/*
 * Type of stack which is used for initialisation of aggregate types.
 */
typedef	struct	istk {
	type_t	*i_type;		/* type of initialisation */
	type_t	*i_subt;		/* type of next level */
	u_int	i_brace : 1;		/* need } for pop */
	u_int	i_nolimit : 1;		/* incomplete array type */
	sym_t	*i_mem;			/* next structure member */
	int	i_cnt;			/* # of remaining elements */
	struct	istk *i_nxt;		/* previous level */
} istk_t;

/*
 * Used to collect information about pointers and qualifiers in
 * declarators.
 */
typedef	struct pqinf {
	int	p_pcnt;			/* number of asterisks */
	u_int	p_const : 1;
	u_int	p_volatile : 1;
	u_int	p_restrict : 1;
	struct	pqinf *p_nxt;
} pqinf_t;

/*
 * Case values are stored in a list of type clst_t.
 */
typedef	struct clst {
	val_t	cl_val;
	struct	clst *cl_nxt;
} clst_t;

/*
 * Used to keep informations about nested control statements.
 */
typedef struct cstk {
	int	c_env;			/* type of statement (T_IF, ...) */
	u_int	c_loop : 1;		/* continue && break are valid */
	u_int	c_switch : 1;		/* case && break are valid */
	u_int	c_break : 1;		/* loop/switch has break */
	u_int	c_cont : 1;		/* loop has continue */
	u_int	c_default : 1;		/* switch has default */
	u_int	c_infinite : 1;		/* break condition always false
					   (for (;;), while (1)) */
	u_int	c_rchif : 1;		/* end of if-branch reached */
	u_int	c_noretval : 1;		/* had "return;" */
	u_int	c_retval : 1;		/* had "return (e);" */
	type_t	*c_swtype;		/* type of switch expression */
	clst_t	*c_clst;		/* list of case values */
	struct	mbl *c_fexprm;		/* saved memory for end of loop
					   expression in for() */
	tnode_t	*c_f3expr;		/* end of loop expr in for() */
	pos_t	c_fpos;			/* position of end of loop expr */
	pos_t	c_cfpos;	        /* same for csrc_pos */
	struct	cstk *c_nxt;		/* outer control statement */
} cstk_t;

/*
 * Used to keep information about arguments passed to functions with
 * prototypes.
 */
typedef struct farg {
	int	fa_num;			/* argument number (1-basde) */
	sym_t	*fa_sym;		/* argument symbol */
	tnode_t	*fa_func;		/* function name */
} farg_t;

#include "externs1.h"
@


1.15
log
@Typos: "in in", "prototyp".
@
text
@d1 1
a1 1
/*	$OpenBSD: lint1.h,v 1.14 2010/07/24 22:17:03 guenther Exp $	*/
@


1.14
log
@Teach lint about C99's _Bool and _Complex, plus some related gcc
extensions: __real__ and __imag__ operators, the use of '~' for
complex conjugation, and 'i' or 'j' as a suffix for complex constants.
While this doesn't handle folding and overflow detection for complex
constants correctly, it's good enough to make it through libm...and
found several bugs once it could do so.

"no objections" miod@@, krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: lint1.h,v 1.13 2006/04/18 02:59:40 cloder Exp $	*/
d317 1
a317 1
	u_int	d_vararg : 1;	/* ... in in current function decl. */
@


1.13
log
@The old way of passing function argument information was to pass an int
which corresponded to the argument # (1-based, with 0 meaning it is not
an argument). This sucked because it is impossible to include the function
name or argument name in warnings when all you have is an argument number.
Introduce a new type farg_t which represents a passed function argument.
struct farg contains argument number, function name, and argument symbol
information from the prototype).
@
text
@d1 1
a1 1
/*	$OpenBSD: lint1.h,v 1.12 2006/03/08 07:18:51 moritz Exp $	*/
d227 1
d240 1
d299 4
a302 3
	tspec_t	d_atyp;		/* VOID, CHAR, INT, FLOAT or DOUBLE */
	tspec_t	d_smod;		/* SIGNED or UNSIGN */
	tspec_t	d_lmod;		/* SHORT, LONG or QUAD */
@


1.12
log
@some cleanup including:

o typos in comments
o missing #include
o remove pointless nomem() func
o unused variables
o more use of asprintf(3)

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: lint1.h,v 1.11 2005/12/17 21:08:27 cloder Exp $	*/
d385 10
@


1.11
log
@Handle __dead functions using lint comments.
@
text
@d1 1
a1 1
/*	$OpenBSD: lint1.h,v 1.10 2005/12/10 17:41:03 cloder Exp $	*/
d93 1
a93 1
 * if to structures are identical by comparing the pointers to
@


1.10
log
@Back out all gcc attribute parsing changes until we can do this the right
way some day.  The effect of __attribute__ on a LALR C grammar is just too
ugly to fix quicklly.
@
text
@d1 1
a1 1
/*	$OpenBSD: lint1.h,v 1.5 2005/11/29 19:38:09 cloder Exp $	*/
d211 1
@


1.9
log
@Don't ever complain when assigning a char literal to a char lvalue,
regardless of sign/unsign differences.  In other words, even though C
treats char literals as ints, if the rvalue is a literal inside single
quotes, and the lvalue is any kind of char, then assume the programmer
knows what he is doing.
@
text
@d1 1
a1 1
/*	$OpenBSD: lint1.h,v 1.8 2005/12/07 01:55:12 cloder Exp $	*/
a72 15
 * attributes
 */
typedef enum {
	AT_UNKNOWN, AT_NORETURN, AT_VOLATILE
} attr_t;

/*
 * A node in an attribute list.
 */
typedef struct attrnode {
	attr_t		an_attr;
	struct attrnode	*an_nxt;
} attrnode_t;

/*
a76 1
	tspec_t v_lspec;		/* the underlying type of a literal */
d79 1
a142 1
	struct	attrnode *t_attr; /* attributes */
a223 1
		attr_t	_s_att;	/* attribute (only for keywords) */
a237 1
#define	s_attr	u._s_att
@


1.8
log
@Refactor __attribute__ parsing a bit.  This takes us further to being able
to not only consume, but also make sense of gcc __attribute__ syntax.
@
text
@d1 1
a1 1
/*	$OpenBSD: lint1.h,v 1.7 2005/12/03 01:14:39 cloder Exp $	*/
d92 1
@


1.7
log
@Fix enum types, thanks lint
@
text
@d1 1
a1 1
/*	$OpenBSD: lint1.h,v 1.6 2005/12/03 00:27:54 cloder Exp $	*/
d76 1
a76 1
	NORETURN
d80 8
d157 1
@


1.6
log
@Lint can now parse every variation of gcc's __attribute__ that I could find
either in our tree or in the gcc docs.  See regression test 11 for examples
of this.  Right now, our cdefs.h actually defines __attribute__(x) to blank
when lint runs.  We can change this whenever we choose.
@
text
@d1 1
a1 1
/*	$OpenBSD: lint1.h,v 1.5 2005/11/29 19:38:09 cloder Exp $	*/
d230 1
a230 1
		tqual_t	_s_att;	/* attribute (only for keywords) */
@


1.5
log
@Typos in comments: explizit and implizit
@
text
@d1 1
a1 1
/*	$OpenBSD: lint1.h,v 1.4 2005/11/23 18:47:41 cloder Exp $	*/
d73 7
d230 1
d245 1
@


1.4
log
@Grok __restrict__ and __restrict keywords.  OK deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: lint1.h,v 1.3 2005/11/20 17:42:49 deraadt Exp $	*/
d207 1
a207 1
	u_int	s_rimpl : 1;	/* return value of function implizit decl. */
d259 1
a259 1
	u_int	tn_cast : 1;	/* if tn_op == CVT its an explizit cast */
@


1.3
log
@spacing
@
text
@d1 1
a1 1
/*	$OpenBSD: lint1.h,v 1.2 1996/06/26 05:44:15 deraadt Exp $	*/
d69 1
a69 1
	CONST, VOLATILE
d126 1
d307 1
d347 1
@


1.2
log
@rcsid
@
text
@d1 1
a1 1
/*	$OpenBSD: lint1.h,v 1.6 1995/10/02 17:31:41 jpo Exp $	*/
d229 1
a229 1
	struct	sym *s_dlnxt; 	/* next symbol declared on same level */
@


1.1
log
@Initial revision
@
text
@d1 1
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@
