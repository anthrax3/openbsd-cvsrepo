head	1.13;
access;
symbols
	OPENBSD_5_1_BASE:1.12
	OPENBSD_5_1:1.12.0.2
	OPENBSD_5_0:1.11.0.16
	OPENBSD_5_0_BASE:1.11
	OPENBSD_4_9:1.11.0.14
	OPENBSD_4_9_BASE:1.11
	OPENBSD_4_8:1.11.0.12
	OPENBSD_4_8_BASE:1.11
	OPENBSD_4_7:1.11.0.8
	OPENBSD_4_7_BASE:1.11
	OPENBSD_4_6:1.11.0.10
	OPENBSD_4_6_BASE:1.11
	OPENBSD_4_5:1.11.0.6
	OPENBSD_4_5_BASE:1.11
	OPENBSD_4_4:1.11.0.4
	OPENBSD_4_4_BASE:1.11
	OPENBSD_4_3:1.11.0.2
	OPENBSD_4_3_BASE:1.11
	OPENBSD_4_2:1.10.0.6
	OPENBSD_4_2_BASE:1.10
	OPENBSD_4_1:1.10.0.4
	OPENBSD_4_1_BASE:1.10
	OPENBSD_4_0:1.10.0.2
	OPENBSD_4_0_BASE:1.10
	OPENBSD_3_9:1.9.0.2
	OPENBSD_3_9_BASE:1.9
	OPENBSD_3_8:1.5.0.10
	OPENBSD_3_8_BASE:1.5
	OPENBSD_3_7:1.5.0.8
	OPENBSD_3_7_BASE:1.5
	OPENBSD_3_6:1.5.0.6
	OPENBSD_3_6_BASE:1.5
	OPENBSD_3_5:1.5.0.4
	OPENBSD_3_5_BASE:1.5
	OPENBSD_3_4:1.5.0.2
	OPENBSD_3_4_BASE:1.5
	OPENBSD_3_3:1.4.0.6
	OPENBSD_3_3_BASE:1.4
	OPENBSD_3_2:1.4.0.4
	OPENBSD_3_2_BASE:1.4
	OPENBSD_3_1:1.4.0.2
	OPENBSD_3_1_BASE:1.4
	OPENBSD_3_0:1.3.0.2
	OPENBSD_3_0_BASE:1.3
	OPENBSD_2_9_BASE:1.2
	OPENBSD_2_9:1.2.0.20
	OPENBSD_2_8:1.2.0.18
	OPENBSD_2_8_BASE:1.2
	OPENBSD_2_7:1.2.0.16
	OPENBSD_2_7_BASE:1.2
	OPENBSD_2_6:1.2.0.14
	OPENBSD_2_6_BASE:1.2
	OPENBSD_2_5:1.2.0.12
	OPENBSD_2_5_BASE:1.2
	OPENBSD_2_4:1.2.0.10
	OPENBSD_2_4_BASE:1.2
	OPENBSD_2_3:1.2.0.8
	OPENBSD_2_3_BASE:1.2
	OPENBSD_2_2:1.2.0.6
	OPENBSD_2_2_BASE:1.2
	OPENBSD_2_1:1.2.0.4
	OPENBSD_2_1_BASE:1.2
	OPENBSD_2_0:1.2.0.2
	OPENBSD_2_0_BASE:1.2
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.13
date	2012.04.08.16.27.00;	author jsg;	state dead;
branches;
next	1.12;

1.12
date	2011.09.21.18.08.07;	author jsg;	state Exp;
branches;
next	1.11;

1.11
date	2007.09.06.22.02.03;	author cloder;	state Exp;
branches;
next	1.10;

1.10
date	2006.03.08.07.18.51;	author moritz;	state Exp;
branches;
next	1.9;

1.9
date	2005.11.29.20.09.39;	author cloder;	state Exp;
branches;
next	1.8;

1.8
date	2005.11.20.18.18.57;	author cloder;	state Exp;
branches;
next	1.7;

1.7
date	2005.11.20.17.42.49;	author deraadt;	state Exp;
branches;
next	1.6;

1.6
date	2005.11.19.03.35.27;	author cloder;	state Exp;
branches;
next	1.5;

1.5
date	2003.08.06.21.08.08;	author millert;	state Exp;
branches;
next	1.4;

1.4
date	2002.02.16.21.27.59;	author millert;	state Exp;
branches;
next	1.3;

1.3
date	2001.05.11.16.06.06;	author art;	state Exp;
branches;
next	1.2;

1.2
date	96.06.26.05.44.17;	author deraadt;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.47.02;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.47.02;	author deraadt;	state Exp;
branches;
next	;


desc
@@


1.13
log
@tedu lint
ok tedu@@ guenther@@ krw@@ espie@@ deraadt@@
@
text
@/*	$OpenBSD: mem1.c,v 1.12 2011/09/21 18:08:07 jsg Exp $	*/
/*	$NetBSD: mem1.c,v 1.2 1995/07/03 21:24:25 cgd Exp $	*/

/*
 * Copyright (c) 1994, 1995 Jochen Pohl
 * All Rights Reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *      This product includes software developed by Jochen Pohl for
 *	The NetBSD Project.
 * 4. The name of the author may not be used to endorse or promote products
 *    derived from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
 * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
 * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

#include <sys/types.h>
#include <sys/mman.h>
#include <sys/param.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <err.h>

#include "lint1.h"

/*
 * Filenames allocated by fnalloc() and fnnalloc() are shared.
 */
typedef struct fn {
	char	*fn_name;
	size_t	fn_len;
	int	fn_id;
	struct	fn *fn_nxt;
} fn_t;

static	fn_t	*fnames;

static	fn_t	*srchfn(const char *, size_t);

/*
 * Look for a Filename of length l.
 */
static fn_t *
srchfn(const char *s, size_t len)
{
	fn_t	*fn;

	for (fn = fnames; fn != NULL; fn = fn->fn_nxt) {
		if (fn->fn_len == len && memcmp(fn->fn_name, s, len) == 0)
			break;
	}
	return (fn);
}

/*
 * Return a shared string for filename s.
 */
const char *
fnalloc(const char *s)
{
	return (s != NULL ? fnnalloc(s, strlen(s)) : NULL);
}

const char *
fnnalloc(const char *s, size_t len)
{
	fn_t	*fn;

	static	int	nxt_id = 0;

	if (s == NULL)
		return (NULL);

	if ((fn = srchfn(s, len)) == NULL) {
		fn = xmalloc(sizeof (fn_t));
		/* Do not used strdup() because string is not NUL-terminated.*/
		fn->fn_name = xmalloc(len + 1);
		(void)memcpy(fn->fn_name, s, len);
		fn->fn_name[len] = '\0';
		fn->fn_len = len;
		fn->fn_id = nxt_id++;
		fn->fn_nxt = fnames;
		fnames = fn;
		/* Write id of this filename to the output file. */
		outclr();
		outint(fn->fn_id);
		outchar('s');
		outstrg(fn->fn_name);
	}
	return (fn->fn_name);
}

/*
 * Get id of a filename.
 */
int
getfnid(const char *s)
{
	fn_t	*fn;

	if (s == NULL || (fn = srchfn(s, strlen(s))) == NULL)
		return (-1);
	return (fn->fn_id);
}

/*
 * Memory for declarations and other things which must be available
 * until the end of a block (or the end of the translation unit)
 * are associated with the level (mblklev) of the block (or with 0).
 * Because this memory is allocated in large blocks associated with
 * a given level it can be freed easily at the end of a block.
 */
#define	ML_INC	((size_t)32)		/* Increment for length of *mblks */

typedef struct mbl {
	void	*blk;			/* beginning of memory block */
	void	*ffree;			/* first free byte */
	size_t	nfree;			/* # of free bytes */
	size_t	size;			/* total size of memory block */
	struct	mbl *nxt;		/* next block */
} mbl_t;

/*
 * Array of pointers to lists of memory blocks. mblklev is used as
 * index into this array.
 */
static	mbl_t	**mblks;

/* number of elements in *mblks */
static	size_t	nmblks;

/* free list for memory blocks */
static	mbl_t	*frmblks;

/* length of new allocated memory blocks */
static	size_t	mblklen;

static	void	*xgetblk(mbl_t **, size_t);
static	void	xfreeblk(mbl_t **);
static	mbl_t	*xnewblk(void);

static mbl_t *
xnewblk(void)
{
	mbl_t	*mb;

	mb = xmalloc(sizeof (mbl_t));
	mb->blk = xmalloc(mblklen);
	mb->size = mblklen;
	return (mb);
}

/*
 * Allocate new memory. If the first block of the list has not enough
 * free space, or there is no first block, get a new block. The new
 * block is taken from the free list or, if there is no block on the
 * free list, is allocated using xnewblk(). If a new block is allocated
 * it is initialized with zero. Blocks taken from the free list are
 * zero'd in xfreeblk().
 */
static void *
xgetblk(mbl_t **mbp, size_t s)
{
	mbl_t	*mb;
	void	*p;

	s = ALIGN(s);
	if ((mb = *mbp) == NULL || mb->nfree < s) {
		if ((mb = frmblks) == NULL) {
			mb = xnewblk();
			(void)memset(mb->blk, 0, mb->size);
		} else {
			frmblks = mb->nxt;
		}
		mb->ffree = mb->blk;
		mb->nfree = mb->size;
		mb->nxt = *mbp;
		*mbp = mb;
	}
	p = mb->ffree;
	mb->ffree = (char *)mb->ffree + s;
	mb->nfree -= s;
	return (p);
}

/*
 * Move all blocks from list *fmbp to free list. For each block, set all
 * used memory to zero.
 */
static void
xfreeblk(mbl_t **fmbp)
{
	mbl_t	*mb;

	while ((mb = *fmbp) != NULL) {
		*fmbp = mb->nxt;
		mb->nxt = frmblks;
		frmblks = mb;
		(void)memset(mb->blk, 0, mb->size - mb->nfree);
	}
}

void
initmem(void)
{
	int	pgsz;

	pgsz = getpagesize();
	mblklen = ((MBLKSIZ + pgsz - 1) / pgsz) * pgsz;

	mblks = xcalloc(nmblks = ML_INC, sizeof (mbl_t *));
}


/*
 * Allocate memory associated with level l.
 */
void *
getlblk(int l, size_t s)
{
	while (l >= nmblks) {
		mblks = xrealloc(mblks, (nmblks + ML_INC) * sizeof (mbl_t *));
		(void)memset(&mblks[nmblks], 0, ML_INC * sizeof (mbl_t *));
		nmblks += ML_INC;
	}
	return (xgetblk(&mblks[l], s));
}

void *
getblk(size_t s)
{
	return (getlblk(mblklev, s));
}

/*
 * Free all memory associated with level l.
 */
void
freelblk(int l)
{
	xfreeblk(&mblks[l]);
}

void
freeblk(void)
{
	freelblk(mblklev);
}

/*
 * tgetblk() returns memory which is associated with the current
 * expression.
 */
static	mbl_t	*tmblk;

void *
tgetblk(size_t s)
{
	return (xgetblk(&tmblk, s));
}

/*
 * Get memory for a new tree node.
 */
tnode_t *
getnode(void)
{
	return (tgetblk(sizeof (tnode_t)));
}

/*
 * Free all memory which is allocated by the current expression.
 */
void
tfreeblk(void)
{
	xfreeblk(&tmblk);
}

/*
 * Save the memory which is used by the current expression. This memory
 * is not freed by the next tfreeblk() call. The pointer returned can be
 * used to restore the memory.
 */
mbl_t *
tsave(void)
{
	mbl_t	*tmem;

	tmem = tmblk;
	tmblk = NULL;
	return (tmem);
}

/*
 * Free all memory used for the current expression and the memory used
 * be a previous expression and saved by tsave(). The next call to
 * tfreeblk() frees the restored memory.
 */
void
trestor(mbl_t *tmem)
{
	tfreeblk();
	if (tmblk != NULL) {
		free(tmblk->blk);
		free(tmblk);
	}
	tmblk = tmem;
}
@


1.12
log
@remove rcsids which escaped the purge of 2009
@
text
@d1 1
a1 1
/*	$OpenBSD: mem1.c,v 1.11 2007/09/06 22:02:03 cloder Exp $	*/
@


1.11
log
@Fix typos in comments. No code changes
@
text
@d1 1
a1 1
/*	$OpenBSD: mem1.c,v 1.10 2006/03/08 07:18:51 moritz Exp $	*/
a33 4

#ifndef lint
static char rcsid[] = "$OpenBSD: mem1.c,v 1.10 2006/03/08 07:18:51 moritz Exp $";
#endif
@


1.10
log
@some cleanup including:

o typos in comments
o missing #include
o remove pointless nomem() func
o unused variables
o more use of asprintf(3)

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mem1.c,v 1.9 2005/11/29 20:09:39 cloder Exp $	*/
d36 1
a36 1
static char rcsid[] = "$OpenBSD: mem1.c,v 1.9 2005/11/29 20:09:39 cloder Exp $";
d132 2
a133 2
 * are assoziated with the level (mblklev) of the block (or wiht 0).
 * Because these memory is allocated in large blocks associated with
@


1.9
log
@Replace unnecessary mmap allocator with malloc.
@
text
@d1 1
a1 1
/*	$OpenBSD: mem1.c,v 1.8 2005/11/20 18:18:57 cloder Exp $	*/
d36 1
a36 1
static char rcsid[] = "$OpenBSD: mem1.c,v 1.8 2005/11/20 18:18:57 cloder Exp $";
a168 1
	int	prot, flags;
@


1.8
log
@Fix typos in comments
@
text
@d1 1
a1 1
/*	$OpenBSD: mem1.c,v 1.7 2005/11/20 17:42:49 deraadt Exp $	*/
d36 1
a36 1
static char rcsid[] = "$OpenBSD: mem1.c,v 1.7 2005/11/20 17:42:49 deraadt Exp $";
d172 1
a172 11

	/* use mmap instead of malloc to avoid malloc's size overhead */

	prot = PROT_READ | PROT_WRITE;
	flags = MAP_ANON | MAP_PRIVATE;
	mb->blk = mmap(NULL, mblklen, prot, flags, -1, (off_t)0);
	if (mb->blk == MAP_FAILED)
		err(1, "can't map memory");
	if (ALIGN((u_long)mb->blk) != (u_long)mb->blk)
		errx(1, "mapped address is not aligned");

a173 1

@


1.7
log
@spacing
@
text
@d1 1
a1 1
/*	$OpenBSD: mem1.c,v 1.6 2005/11/19 03:35:27 cloder Exp $	*/
d36 1
a36 1
static char rcsid[] = "$OpenBSD: mem1.c,v 1.6 2005/11/19 03:35:27 cloder Exp $";
d307 1
a307 1
 * Free all memory which is allocated by the the current expression.
@


1.6
log
@knf. OK kjell, brad
@
text
@d1 1
a1 1
/*	$OpenBSD: mem1.c,v 1.5 2003/08/06 21:08:08 millert Exp $	*/
d36 1
a36 1
static char rcsid[] = "$OpenBSD: mem1.c,v 1.5 2003/08/06 21:08:08 millert Exp $";
d249 1
a249 1
	
@


1.5
log
@Remove some double semicolons (hmm, do two semis equal a maxi?).
I've skipped the GNU stuff for now.  From Patrick Latifi.
@
text
@d1 1
a1 1
/*	$OpenBSD: mem1.c,v 1.4 2002/02/16 21:27:59 millert Exp $	*/
d36 1
a36 1
static char rcsid[] = "$OpenBSD: mem1.c,v 1.4 2002/02/16 21:27:59 millert Exp $";
d67 1
a67 3
srchfn(s, len)
	const	char *s;
	size_t	len;
d82 1
a82 2
fnalloc(s)
	const	char *s;
d88 1
a88 3
fnnalloc(s, len)
	const	char *s;
	size_t	len;
d120 1
a120 2
getfnid(s)
	const	char *s;
d166 1
a166 1
xnewblk()
d197 1
a197 3
xgetblk(mbp, s)
	mbl_t	**mbp;
	size_t	s;
d226 1
a226 2
xfreeblk(fmbp)
	mbl_t	**fmbp;
d239 1
a239 1
initmem()
d254 1
a254 3
getlblk(l, s)
	int	l;
	size_t	s;
d265 1
a265 2
getblk(s)
	size_t	s;
d274 1
a274 2
freelblk(l)
	int	l;
d280 1
a280 1
freeblk()
d292 1
a292 2
tgetblk(s)
	size_t	s;
d301 1
a301 1
getnode()
d310 1
a310 1
tfreeblk()
d321 1
a321 1
tsave()
d336 1
a336 2
trestor(tmem)
	mbl_t	*tmem;
@


1.4
log
@Part one of userland __P removal.  Done with a simple regexp with some minor hand editing to make comments line up correctly.  Another pass is forthcoming that handles the cases that could not be done automatically.
@
text
@d1 1
a1 1
/*	$OpenBSD: mem1.c,v 1.3 2001/05/11 16:06:06 art Exp $	*/
d36 1
a36 1
static char rcsid[] = "$OpenBSD: mem1.c,v 1.3 2001/05/11 16:06:06 art Exp $";
d219 1
a219 1
		mb->nfree = mb->size;;
@


1.3
log
@-1 -> MAP_FAILED
@
text
@d1 1
a1 1
/*	$OpenBSD: mem1.c,v 1.2 1996/06/26 05:44:17 deraadt Exp $	*/
d36 1
a36 1
static char rcsid[] = "$OpenBSD: mem1.c,v 1.2 1996/06/26 05:44:17 deraadt Exp $";
d61 1
a61 1
static	fn_t	*srchfn __P((const char *, size_t));
d167 3
a169 3
static	void	*xgetblk __P((mbl_t **, size_t));
static	void	xfreeblk __P((mbl_t **));
static	mbl_t	*xnewblk __P((void));
@


1.2
log
@rcsid
@
text
@d1 1
a1 1
/*	$OpenBSD: mem1.c,v 1.2 1995/07/03 21:24:25 cgd Exp $	*/
d36 1
a36 1
static char rcsid[] = "$OpenBSD: mem1.c,v 1.2 1995/07/03 21:24:25 cgd Exp $";
d184 1
a184 1
	if (mb->blk == (void *)-1)
@


1.1
log
@Initial revision
@
text
@d1 1
d36 1
a36 1
static char rcsid[] = "$NetBSD: mem1.c,v 1.2 1995/07/03 21:24:25 cgd Exp $";
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@
