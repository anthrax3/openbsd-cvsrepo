head	1.19;
access;
symbols
	OPENBSD_5_5:1.18.0.4
	OPENBSD_5_5_BASE:1.18
	OPENBSD_5_4:1.17.0.12
	OPENBSD_5_4_BASE:1.17
	OPENBSD_5_3:1.17.0.10
	OPENBSD_5_3_BASE:1.17
	OPENBSD_5_2:1.17.0.8
	OPENBSD_5_2_BASE:1.17
	OPENBSD_5_1_BASE:1.17
	OPENBSD_5_1:1.17.0.6
	OPENBSD_5_0:1.17.0.4
	OPENBSD_5_0_BASE:1.17
	OPENBSD_4_9:1.17.0.2
	OPENBSD_4_9_BASE:1.17
	OPENBSD_4_8:1.16.0.4
	OPENBSD_4_8_BASE:1.16
	OPENBSD_4_7:1.16.0.2
	OPENBSD_4_7_BASE:1.16
	OPENBSD_4_6:1.15.0.10
	OPENBSD_4_6_BASE:1.15
	OPENBSD_4_5:1.15.0.6
	OPENBSD_4_5_BASE:1.15
	OPENBSD_4_4:1.15.0.4
	OPENBSD_4_4_BASE:1.15
	OPENBSD_4_3:1.15.0.2
	OPENBSD_4_3_BASE:1.15
	OPENBSD_4_2:1.14.0.14
	OPENBSD_4_2_BASE:1.14
	OPENBSD_4_1:1.14.0.12
	OPENBSD_4_1_BASE:1.14
	OPENBSD_4_0:1.14.0.10
	OPENBSD_4_0_BASE:1.14
	OPENBSD_3_9:1.14.0.8
	OPENBSD_3_9_BASE:1.14
	OPENBSD_3_8:1.14.0.6
	OPENBSD_3_8_BASE:1.14
	OPENBSD_3_7:1.14.0.4
	OPENBSD_3_7_BASE:1.14
	OPENBSD_3_6:1.14.0.2
	OPENBSD_3_6_BASE:1.14
	OPENBSD_3_5:1.13.0.2
	OPENBSD_3_5_BASE:1.13
	OPENBSD_3_4:1.12.0.2
	OPENBSD_3_4_BASE:1.12
	OPENBSD_3_3:1.8.0.4
	OPENBSD_3_3_BASE:1.8
	OPENBSD_3_2:1.8.0.2
	OPENBSD_3_2_BASE:1.8
	OPENBSD_3_1:1.7.0.2
	OPENBSD_3_1_BASE:1.7
	OPENBSD_3_0:1.5.0.4
	OPENBSD_3_0_BASE:1.5
	OPENBSD_2_9_BASE:1.5
	OPENBSD_2_9:1.5.0.2
	OPENBSD_2_8:1.4.0.10
	OPENBSD_2_8_BASE:1.4
	OPENBSD_2_7:1.4.0.8
	OPENBSD_2_7_BASE:1.4
	OPENBSD_2_6:1.4.0.6
	OPENBSD_2_6_BASE:1.4
	OPENBSD_2_5:1.4.0.4
	OPENBSD_2_5_BASE:1.4
	OPENBSD_2_4:1.4.0.2
	OPENBSD_2_4_BASE:1.4
	OPENBSD_2_3:1.3.0.6
	OPENBSD_2_3_BASE:1.3
	OPENBSD_2_2:1.3.0.4
	OPENBSD_2_2_BASE:1.3
	OPENBSD_2_1:1.3.0.2
	OPENBSD_2_1_BASE:1.3
	OPENBSD_2_0:1.2.0.2
	OPENBSD_2_0_BASE:1.2;
locks; strict;
comment	@ * @;


1.19
date	2014.04.18.19.13.16;	author okan;	state dead;
branches;
next	1.18;

1.18
date	2013.11.25.18.02.50;	author deraadt;	state Exp;
branches;
next	1.17;

1.17
date	2011.01.20.22.12.42;	author jasper;	state Exp;
branches;
next	1.16;

1.16
date	2009.10.27.23.59.36;	author deraadt;	state Exp;
branches;
next	1.15;

1.15
date	2007.09.02.15.19.31;	author deraadt;	state Exp;
branches;
next	1.14;

1.14
date	2004.05.16.18.49.12;	author otto;	state Exp;
branches;
next	1.13;

1.13
date	2003.11.15.00.23.02;	author tedu;	state Exp;
branches;
next	1.12;

1.12
date	2003.07.02.21.04.09;	author deraadt;	state Exp;
branches;
next	1.11;

1.11
date	2003.06.10.22.20.45;	author deraadt;	state Exp;
branches;
next	1.10;

1.10
date	2003.06.03.02.56.06;	author millert;	state Exp;
branches;
next	1.9;

1.9
date	2003.03.31.20.46.03;	author rohee;	state Exp;
branches;
next	1.8;

1.8
date	2002.07.03.23.13.02;	author deraadt;	state Exp;
branches;
next	1.7;

1.7
date	2002.02.16.21.27.44;	author millert;	state Exp;
branches;
next	1.6;

1.6
date	2001.11.19.19.02.13;	author mpech;	state Exp;
branches;
next	1.5;

1.5
date	2001.02.05.08.38.23;	author deraadt;	state Exp;
branches;
next	1.4;

1.4
date	98.05.07.19.12.17;	author deraadt;	state Exp;
branches;
next	1.3;

1.3
date	97.01.15.23.42.13;	author millert;	state Exp;
branches;
next	1.2;

1.2
date	96.06.26.05.31.39;	author deraadt;	state Exp;
branches;
next	1.1;

1.1
date	95.12.15.02.38.27;	author deraadt;	state Exp;
branches;
next	;


desc
@@


1.19
log
@remove bdes(1) so as to not encourage its use; if someone really
wants to use DES, there's another way.

ok deraadt sthen sobrado (and probably tedu)
@
text
@/*	$OpenBSD: bdes.c,v 1.18 2013/11/25 18:02:50 deraadt Exp $	*/
/*	$NetBSD: bdes.c,v 1.2 1995/03/26 03:33:19 glass Exp $	*/

/*-
 * Copyright (c) 1991, 1993
 *	The Regents of the University of California.  All rights reserved.
 *
 * This code is derived from software contributed to Berkeley by
 * Matt Bishop of Dartmouth College.
 *
 * The United States Government has rights in this work pursuant
 * to contract no. NAG 2-680 between the National Aeronautics and
 * Space Administration and Dartmouth College.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */

/*
 * BDES -- DES encryption package for Berkeley Software Distribution 4.4
 * options:
 *	-a	key is in ASCII
 *	-b	use ECB (electronic code book) mode
 *	-d	invert (decrypt) input
 *	-f b	use b-bit CFB (cipher feedback) mode
 *	-F b	use b-bit CFB (cipher feedback) alternative mode
 *	-k key	use key as the cryptographic key
 *	-m b	generate a MAC of length b
 *	-o b	use b-bit OFB (output feedback) mode
 *	-p	don't reset the parity bit
 *	-v v	use v as the initialization vector (ignored for ECB)
 * note: the last character of the last block is the integer indicating
 * how many characters of that block are to be output
 *
 * Author: Matt Bishop
 *	   Department of Mathematics and Computer Science
 *	   Dartmouth College
 *	   Hanover, NH  03755
 * Email:  Matt.Bishop@@dartmouth.edu
 *	   ...!decvax!dartvax!Matt.Bishop
 *
 * See Technical Report PCS-TR91-158, Department of Mathematics and Computer
 * Science, Dartmouth College, for a detailed description of the implemen-
 * tation and differences between it and Sun's.  The DES is described in
 * FIPS PUB 46, and the modes in FIPS PUB 81 (see either the manual page
 * or the technical report for a complete reference).
 */

#include <err.h>
#include <errno.h>
#include <unistd.h>
#include <stdio.h>
#include <ctype.h>
#include <stdlib.h>
#include <string.h>

typedef char Desbuf[8];
int 	tobinhex(char, int);
void 	cvtkey(char *, char *);
int 	setbits(char *, int);
void 	makekey(Desbuf);
void 	ecbenc(void);
void 	ecbdec(void);
void 	cbcenc(void);
void 	cbcdec(void);
void 	cbcauth(void);
void 	cfbenc(void);
void 	cfbdec(void);
void 	cfbaenc(void);
void 	cfbadec(void);
void 	cfbauth(void);
void 	ofbdec(void);
void 	ofbenc(void);
void 	usage(void);

/*
 * BSD and System V systems offer special library calls that do
 * block moves and fills, so if possible we take advantage of them
 */
#define	MEMCPY(dest,src,len)	bcopy((src),(dest),(len))
#define	MEMZERO(dest,len)	bzero((dest),(len))

/* Hide the calls to the primitive encryption routines. */
#define	DES_KEY(buf) \
	if (des_setkey(buf)) \
		err(1, "des_setkey");
#define	DES_XFORM(buf) \
	if (des_cipher(buf, buf, 0L, (inverse ? -1 : 1))) \
		err(1, "des_cipher");

/*
 * this does an error-checking write
 */
#define	READ(buf, n)	fread(buf, sizeof(char), n, stdin)
#define WRITE(buf,n)						\
		if (fwrite(buf, sizeof(char), n, stdout) != n)	\
			err(1, "block %d", bn);

/*
 * some things to make references easier
 */
#define	CHAR(x,i)	(x[i])
#define	UCHAR(x,i)	(x[i])
#define	BUFFER(x)	(x)
#define	UBUFFER(x)	(x)

/*
 * global variables and related macros
 */
#define KEY_DEFAULT		0	/* interpret radix of key from key */
#define KEY_ASCII		1	/* key is in ASCII characters */
int keybase = KEY_DEFAULT;		/* how to interpret the key */

enum { 					/* encrypt, decrypt, authenticate */
	MODE_ENCRYPT, MODE_DECRYPT, MODE_AUTHENTICATE
} mode = MODE_ENCRYPT;
enum {					/* ecb, cbc, cfb, cfba, ofb? */
	ALG_ECB, ALG_CBC, ALG_CFB, ALG_OFB, ALG_CFBA
} alg = ALG_CBC;

Desbuf ivec;				/* initialization vector */
char bits[] = {				/* used to extract bits from a char */
	'\200', '\100', '\040', '\020', '\010', '\004', '\002', '\001'
};
int inverse;				/* 0 to encrypt, 1 to decrypt */
int macbits = -1;			/* number of bits in authentication */
int fbbits = -1;			/* number of feedback bits */
int pflag;				/* 1 to preserve parity bits */


int
main(int ac, char *av[])
{
	extern int optind;		/* option (argument) number */
	extern char *optarg;		/* argument to option if any */
	int i;				/* counter in a for loop */
	char *p;			/* used to obtain the key */
	Desbuf msgbuf;			/* I/O buffer */
	int kflag;			/* command-line encryption key */
	int argc;			/* the real arg count */
	char **argv;			/* the real argument vector */

	/*
	 * Hide the arguments from ps(1) by making private copies of them
	 * and clobbering the global (visible to ps(1)) ones.
	 */
	argc = ac;
	ac = 1;
	argv = calloc(argc + 1, sizeof(char *));
	if (argv == NULL)
		errx(1, "out of memory");
	for (i = 0; i < argc; ++i) {
		argv[i] = strdup(av[i]);
		MEMZERO(av[i], strlen(av[i]));
	}
	argv[argc] = NULL;

	/* initialize the initialization vector */
	MEMZERO(ivec, 8);

	/* process the argument list */
	kflag = 0;
	while ((i = getopt(argc, argv, "abdF:f:k:m:o:pv:")) != -1)
		switch (i) {
		case 'a':		/* key is ASCII */
			keybase = KEY_ASCII;
			break;
		case 'b':		/* use ECB mode */
			alg = ALG_ECB;
			break;
		case 'd':		/* decrypt */
			mode = MODE_DECRYPT;
			break;
		case 'F':		/* use alternative CFB mode */
			alg = ALG_CFBA;
			if ((fbbits = setbits(optarg, 7)) > 56 || fbbits == 0)
				err(1, "-F: number must be 1-56 inclusive");
			else if (fbbits == -1)
				err(1, "-F: number must be a multiple of 7");
			break;
		case 'f':		/* use CFB mode */
			alg = ALG_CFB;
			if ((fbbits = setbits(optarg, 8)) > 64 || fbbits == 0)
				err(1, "-f: number must be 1-64 inclusive");
			else if (fbbits == -1)
				err(1, "-f: number must be a multiple of 8");
			break;
		case 'k':		/* encryption key */
			kflag = 1;
			cvtkey(BUFFER(msgbuf), optarg);
			break;
		case 'm':		/* number of bits for MACing */
			mode = MODE_AUTHENTICATE;
			if ((macbits = setbits(optarg, 1)) > 64)
				err(1, "-m: number must be 0-64 inclusive");
			break;
		case 'o':		/* use OFB mode */
			alg = ALG_OFB;
			if ((fbbits = setbits(optarg, 8)) > 64 || fbbits == 0)
				err(1, "-o: number must be 1-64 inclusive");
			else if (fbbits == -1)
				err(1, "-o: number must be a multiple of 8");
			break;
		case 'p':		/* preserve parity bits */
			pflag = 1;
			break;
		case 'v':		/* set initialization vector */
			cvtkey(BUFFER(ivec), optarg);
			break;
		default:		/* error */
			usage();
		}

	if (!kflag) {
		/*
		 * if the key's not ASCII, assume it is
		 */
		keybase = KEY_ASCII;
		/*
		 * get the key
		 */
		if ((p = getpass("Enter key: ")) == NULL)
			err(1, "getpass");
		/*
		 * copy it, nul-padded, into the key area
		 */
		cvtkey(BUFFER(msgbuf), p);
	}

	makekey(msgbuf);
	inverse = (alg == ALG_CBC || alg == ALG_ECB) && mode == MODE_DECRYPT;

	switch (alg) {
	case ALG_CBC:
		switch (mode) {
		case MODE_AUTHENTICATE:	/* authenticate using CBC mode */
			cbcauth();
			break;
		case MODE_DECRYPT:	/* decrypt using CBC mode */
			cbcdec();
			break;
		case MODE_ENCRYPT:	/* encrypt using CBC mode */
			cbcenc();
			break;
		}
		break;
	case ALG_CFB:
		switch (mode) {
		case MODE_AUTHENTICATE:	/* authenticate using CFB mode */
			cfbauth();
			break;
		case MODE_DECRYPT:	/* decrypt using CFB mode */
			cfbdec();
			break;
		case MODE_ENCRYPT:	/* encrypt using CFB mode */
			cfbenc();
			break;
		}
		break;
	case ALG_CFBA:
		switch (mode) {
		case MODE_AUTHENTICATE:	/* authenticate using CFBA mode */
			err(1, "can't authenticate with CFBA mode");
			break;
		case MODE_DECRYPT:	/* decrypt using CFBA mode */
			cfbadec();
			break;
		case MODE_ENCRYPT:	/* encrypt using CFBA mode */
			cfbaenc();
			break;
		}
		break;
	case ALG_ECB:
		switch (mode) {
		case MODE_AUTHENTICATE:	/* authenticate using ECB mode */
			err(1, "can't authenticate with ECB mode");
			break;
		case MODE_DECRYPT:	/* decrypt using ECB mode */
			ecbdec();
			break;
		case MODE_ENCRYPT:	/* encrypt using ECB mode */
			ecbenc();
			break;
		}
		break;
	case ALG_OFB:
		switch (mode) {
		case MODE_AUTHENTICATE:	/* authenticate using OFB mode */
			err(1, "can't authenticate with OFB mode");
			break;
		case MODE_DECRYPT:	/* decrypt using OFB mode */
			ofbdec();
			break;
		case MODE_ENCRYPT:	/* encrypt using OFB mode */
			ofbenc();
			break;
		}
		break;
	}
	exit(0);
}

/*
 * map a hex character to an integer
 */
int
tobinhex(char c, int radix)
{
	switch (c) {
	case '0':		return(0x0);
	case '1':		return(0x1);
	case '2':		return(radix > 2 ? 0x2 : -1);
	case '3':		return(radix > 3 ? 0x3 : -1);
	case '4':		return(radix > 4 ? 0x4 : -1);
	case '5':		return(radix > 5 ? 0x5 : -1);
	case '6':		return(radix > 6 ? 0x6 : -1);
	case '7':		return(radix > 7 ? 0x7 : -1);
	case '8':		return(radix > 8 ? 0x8 : -1);
	case '9':		return(radix > 9 ? 0x9 : -1);
	case 'A': case 'a':	return(radix > 10 ? 0xa : -1);
	case 'B': case 'b':	return(radix > 11 ? 0xb : -1);
	case 'C': case 'c':	return(radix > 12 ? 0xc : -1);
	case 'D': case 'd':	return(radix > 13 ? 0xd : -1);
	case 'E': case 'e':	return(radix > 14 ? 0xe : -1);
	case 'F': case 'f':	return(radix > 15 ? 0xf : -1);
	}
	/*
	 * invalid character
	 */
	return(-1);
}

/*
 * convert the key to a bit pattern
 */
void
cvtkey(char *obuf, char *ibuf)
{
	int i, j;			/* counter in a for loop */
	int nbuf[64];			/* used for hex/key translation */

	/*
	 * just switch on the key base
	 */
	switch (keybase) {
	case KEY_ASCII:			/* ASCII to integer */
		(void)strncpy(obuf, ibuf, 8);
		return;
	case KEY_DEFAULT:		/* tell from context */
		/*
		 * leading '0x' or '0X' == hex key
		 */
		if (ibuf[0] == '0' && (ibuf[1] == 'x' || ibuf[1] == 'X')) {
			ibuf = &ibuf[2];
			/*
			 * now translate it, bombing on any illegal hex digit
			 */
			for (i = 0; ibuf[i] && i < 16; i++)
				if ((nbuf[i] = tobinhex(ibuf[i], 16)) == -1)
					err(1, "bad hex digit in key");
			while (i < 16)
				nbuf[i++] = 0;
			for (i = 0; i < 8; i++)
				obuf[i] =
				    ((nbuf[2*i]&0xf)<<4) | (nbuf[2*i+1]&0xf);
			/* preserve parity bits */
			pflag = 1;
			return;
		}
		/*
		 * leading '0b' or '0B' == binary key
		 */
		if (ibuf[0] == '0' && (ibuf[1] == 'b' || ibuf[1] == 'B')) {
			ibuf = &ibuf[2];
			/*
			 * now translate it, bombing on any illegal binary digit
			 */
			for (i = 0; ibuf[i] && i < 16; i++)
				if ((nbuf[i] = tobinhex(ibuf[i], 2)) == -1)
					err(1, "bad binary digit in key");
			while (i < 64)
				nbuf[i++] = 0;
			for (i = 0; i < 8; i++)
				for (j = 0; j < 8; j++)
					obuf[i] = (obuf[i]<<1)|nbuf[8*i+j];
			/* preserve parity bits */
			pflag = 1;
			return;
		}
		/*
		 * no special leader -- ASCII
		 */
		(void)strncpy(obuf, ibuf, 8);
	}
}

/*
 * convert an ASCII string into a decimal number:
 * 1. must be between 0 and 64 inclusive
 * 2. must be a valid decimal number
 * 3. must be a multiple of mult
 */
int
setbits(char *s, int mult)
{
	char *p;			/* pointer in a for loop */
	int n = 0;			/* the integer collected */

	/*
	 * skip white space
	 */
	while (isspace((unsigned char)*s))
		s++;
	/*
	 * get the integer
	 */
	for (p = s; *p; p++) {
		if (isdigit((unsigned char)*p))
			n = n * 10 + *p - '0';
		else {
			err(1, "bad decimal digit in MAC length");
		}
	}
	/*
	 * be sure it's a multiple of mult
	 */
	return((n % mult != 0) ? -1 : n);
}

/*****************
 * DES FUNCTIONS *
 *****************/
/*
 * This sets the DES key and (if you're using the deszip version)
 * the direction of the transformation.  This uses the Sun
 * to map the 64-bit key onto the 56 bits that the key schedule
 * generation routines use: the old way, which just uses the user-
 * supplied 64 bits as is, and the new way, which resets the parity
 * bit to be the same as the low-order bit in each character.  The
 * new way generates a greater variety of key schedules, since many
 * systems set the parity (high) bit of each character to 0, and the
 * DES ignores the low order bit of each character.
 */
void
makekey(Desbuf buf)
{
	int i, j;				/* counter in a for loop */
	int par;				/* parity counter */

	/*
	 * if the parity is not preserved, flip it
	 */
	if (!pflag) {
		for (i = 0; i < 8; i++) {
			par = 0;
			for (j = 1; j < 8; j++)
				if ((bits[j]&UCHAR(buf, i)) != 0)
					par++;
			if ((par&01) == 01)
				UCHAR(buf, i) = UCHAR(buf, i)&0177;
			else
				UCHAR(buf, i) = (UCHAR(buf, i)&0177)|0200;
		}
	}

	DES_KEY(UBUFFER(buf));
}

/*
 * This encrypts using the Electronic Code Book mode of DES
 */
void
ecbenc(void)
{
	int n;			/* number of bytes actually read */
	int bn;			/* block number */
	Desbuf msgbuf;		/* I/O buffer */

	for (bn = 0; (n = READ(BUFFER(msgbuf),  8)) == 8; bn++) {
		/*
		 * do the transformation
		 */
		DES_XFORM(UBUFFER(msgbuf));
		WRITE(BUFFER(msgbuf), 8);
	}
	/*
	 * at EOF or last block -- in either ase, the last byte contains
	 * the character representation of the number of bytes in it
	 */
	bn++;
	MEMZERO(&CHAR(msgbuf, n), 8 - n);
	CHAR(msgbuf, 7) = n;
	DES_XFORM(UBUFFER(msgbuf));
	WRITE(BUFFER(msgbuf), 8);

}

/*
 * This decrypts using the Electronic Code Book mode of DES
 */
void
ecbdec(void)
{
	int n;			/* number of bytes actually read */
	int c;			/* used to test for EOF */
	int bn;			/* block number */
	Desbuf msgbuf;		/* I/O buffer */

	for (bn = 1; (n = READ(BUFFER(msgbuf), 8)) == 8; bn++) {
		/*
		 * do the transformation
		 */
		DES_XFORM(UBUFFER(msgbuf));
		/*
		 * if the last one, handle it specially
		 */
		if ((c = getchar()) == EOF) {
			n = CHAR(msgbuf, 7);
			if (n < 0 || n > 7)
				err(1, "decryption failed (block %d corrupted)", bn);
		}
		else
			(void)ungetc(c, stdin);
		WRITE(BUFFER(msgbuf), n);
	}
	if (n > 0)
		err(1, "decryption failed (block %d incomplete)", bn);
}

/*
 * This encrypts using the Cipher Block Chaining mode of DES
 */
void
cbcenc(void)
{
	int n;			/* number of bytes actually read */
	int bn;			/* block number */
	Desbuf msgbuf;		/* I/O buffer */

	/*
	 * do the transformation
	 */
	for (bn = 1; (n = READ(BUFFER(msgbuf), 8)) == 8; bn++) {
		for (n = 0; n < 8; n++)
			CHAR(msgbuf, n) ^= CHAR(ivec, n);
		DES_XFORM(UBUFFER(msgbuf));
		MEMCPY(BUFFER(ivec), BUFFER(msgbuf), 8);
		WRITE(BUFFER(msgbuf), 8);
	}
	/*
	 * at EOF or last block -- in either case, the last byte contains
	 * the character representation of the number of bytes in it
	 */
	bn++;
	MEMZERO(&CHAR(msgbuf, n), 8 - n);
	CHAR(msgbuf, 7) = n;
	for (n = 0; n < 8; n++)
		CHAR(msgbuf, n) ^= CHAR(ivec, n);
	DES_XFORM(UBUFFER(msgbuf));
	WRITE(BUFFER(msgbuf), 8);

}

/*
 * This decrypts using the Cipher Block Chaining mode of DES
 */
void
cbcdec(void)
{
	int n;			/* number of bytes actually read */
	Desbuf msgbuf;		/* I/O buffer */
	Desbuf ibuf;		/* temp buffer for initialization vector */
	int c;			/* used to test for EOF */
	int bn;			/* block number */

	for (bn = 0; (n = READ(BUFFER(msgbuf), 8)) == 8; bn++) {
		/*
		 * do the transformation
		 */
		MEMCPY(BUFFER(ibuf), BUFFER(msgbuf), 8);
		DES_XFORM(UBUFFER(msgbuf));
		for (c = 0; c < 8; c++)
			UCHAR(msgbuf, c) ^= UCHAR(ivec, c);
		MEMCPY(BUFFER(ivec), BUFFER(ibuf), 8);
		/*
		 * if the last one, handle it specially
		 */
		if ((c = getchar()) == EOF) {
			n = CHAR(msgbuf, 7);
			if (n < 0 || n > 7)
				err(1, "decryption failed (block %d corrupted)", bn);
		}
		else
			(void)ungetc(c, stdin);
		WRITE(BUFFER(msgbuf), n);
	}
	if (n > 0)
		err(1, "decryption failed (block %d incomplete)", bn);
}

/*
 * This authenticates using the Cipher Block Chaining mode of DES
 */
void
cbcauth(void)
{
	int n, j;		/* number of bytes actually read */
	Desbuf msgbuf;		/* I/O buffer */
	Desbuf encbuf;		/* encryption buffer */

	/*
	 * do the transformation
	 * note we DISCARD the encrypted block;
	 * we only care about the last one
	 */
	while ((n = READ(BUFFER(msgbuf), 8)) == 8) {
		for (n = 0; n < 8; n++)
			CHAR(encbuf, n) = CHAR(msgbuf, n) ^ CHAR(ivec, n);
		DES_XFORM(UBUFFER(encbuf));
		MEMCPY(BUFFER(ivec), BUFFER(encbuf), 8);
	}
	/*
	 * now compute the last one, right padding with '\0' if need be
	 */
	if (n > 0) {
		MEMZERO(&CHAR(msgbuf, n), 8 - n);
		for (n = 0; n < 8; n++)
			CHAR(encbuf, n) = CHAR(msgbuf, n) ^ CHAR(ivec, n);
		DES_XFORM(UBUFFER(encbuf));
	}
	/*
	 * drop the bits
	 * we write chars until fewer than 7 bits,
	 * and then pad the last one with 0 bits
	 */
	for (n = 0; macbits > 7; n++, macbits -= 8)
		(void)putchar(CHAR(encbuf, n));
	if (macbits > 0) {
		CHAR(msgbuf, 0) = 0x00;
		for (j = 0; j < macbits; j++)
			CHAR(msgbuf, 0) |= (CHAR(encbuf, n)&bits[j]);
		(void)putchar(CHAR(msgbuf, 0));
	}
}

/*
 * This encrypts using the Cipher FeedBack mode of DES
 */
void
cfbenc(void)
{
	int n;			/* number of bytes actually read */
	int nbytes;		/* number of bytes to read */
	int bn;			/* block number */
	char ibuf[8];		/* input buffer */
	Desbuf msgbuf;		/* encryption buffer */

	/*
	 * do things in bytes, not bits
	 */
	nbytes = fbbits / 8;
	/*
	 * do the transformation
	 */
	for (bn = 1; (n = READ(ibuf, nbytes)) == nbytes; bn++) {
		MEMCPY(BUFFER(msgbuf), BUFFER(ivec), 8);
		DES_XFORM(UBUFFER(msgbuf));
		for (n = 0; n < 8 - nbytes; n++)
			UCHAR(ivec, n) = UCHAR(ivec, n+nbytes);
		for (n = 0; n < nbytes; n++)
			UCHAR(ivec, 8-nbytes+n) = ibuf[n] ^ UCHAR(msgbuf, n);
		WRITE(&CHAR(ivec, 8-nbytes), nbytes);
	}
	/*
	 * at EOF or last block -- in either case, the last byte contains
	 * the character representation of the number of bytes in it
	 */
	bn++;
	MEMZERO(&ibuf[n], nbytes - n);
	ibuf[nbytes - 1] = n;
	MEMCPY(BUFFER(msgbuf), BUFFER(ivec), 8);
	DES_XFORM(UBUFFER(msgbuf));
	for (n = 0; n < nbytes; n++)
		ibuf[n] ^= UCHAR(msgbuf, n);
	WRITE(ibuf, nbytes);
}

/*
 * This decrypts using the Cipher Block Chaining mode of DES
 */
void
cfbdec(void)
{
	int n;			/* number of bytes actually read */
	int c;			/* used to test for EOF */
	int nbytes;		/* number of bytes to read */
	int bn;			/* block number */
	char ibuf[8];		/* input buffer */
	char obuf[8];		/* output buffer */
	Desbuf msgbuf;		/* encryption buffer */

	/*
	 * do things in bytes, not bits
	 */
	nbytes = fbbits / 8;
	/*
	 * do the transformation
	 */
	for (bn = 1; (n = READ(ibuf, nbytes)) == nbytes; bn++) {
		MEMCPY(BUFFER(msgbuf), BUFFER(ivec), 8);
		DES_XFORM(UBUFFER(msgbuf));
		for (c = 0; c < 8 - nbytes; c++)
			CHAR(ivec, c) = CHAR(ivec, c+nbytes);
		for (c = 0; c < nbytes; c++) {
			CHAR(ivec, 8-nbytes+c) = ibuf[c];
			obuf[c] = ibuf[c] ^ UCHAR(msgbuf, c);
		}
		/*
		 * if the last one, handle it specially
		 */
		if ((c = getchar()) == EOF) {
			n = obuf[nbytes-1];
			if (n < 0 || n > nbytes-1)
				err(1, "decryption failed (block %d corrupted)", bn);
		}
		else
			(void)ungetc(c, stdin);
		WRITE(obuf, n);
	}
	if (n > 0)
		err(1, "decryption failed (block %d incomplete)", bn);
}

/*
 * This encrypts using the alternative Cipher FeedBack mode of DES
 */
void
cfbaenc(void)
{
	int n;			/* number of bytes actually read */
	int nbytes;		/* number of bytes to read */
	int bn;			/* block number */
	char ibuf[8];		/* input buffer */
	char obuf[8];		/* output buffer */
	Desbuf msgbuf;		/* encryption buffer */

	/*
	 * do things in bytes, not bits
	 */
	nbytes = fbbits / 7;
	/*
	 * do the transformation
	 */
	for (bn = 1; (n = READ(ibuf, nbytes)) == nbytes; bn++) {
		MEMCPY(BUFFER(msgbuf), BUFFER(ivec), 8);
		DES_XFORM(UBUFFER(msgbuf));
		for (n = 0; n < 8 - nbytes; n++)
			UCHAR(ivec, n) = UCHAR(ivec, n+nbytes);
		for (n = 0; n < nbytes; n++)
			UCHAR(ivec, 8-nbytes+n) = (ibuf[n] ^ UCHAR(msgbuf, n))
							|0200;
		for (n = 0; n < nbytes; n++)
			obuf[n] = CHAR(ivec, 8-nbytes+n)&0177;
		WRITE(obuf, nbytes);
	}
	/*
	 * at EOF or last block -- in either case, the last byte contains
	 * the character representation of the number of bytes in it
	 */
	bn++;
	MEMZERO(&ibuf[n], nbytes - n);
	ibuf[nbytes - 1] = ('0' + n)|0200;
	MEMCPY(BUFFER(msgbuf), BUFFER(ivec), 8);
	DES_XFORM(UBUFFER(msgbuf));
	for (n = 0; n < nbytes; n++)
		ibuf[n] ^= UCHAR(msgbuf, n);
	WRITE(ibuf, nbytes);
}

/*
 * This decrypts using the alternative Cipher Block Chaining mode of DES
 */
void
cfbadec(void)
{
	int n;			/* number of bytes actually read */
	int c;			/* used to test for EOF */
	int nbytes;		/* number of bytes to read */
	int bn;			/* block number */
	char ibuf[8];		/* input buffer */
	char obuf[8];		/* output buffer */
	Desbuf msgbuf;		/* encryption buffer */

	/*
	 * do things in bytes, not bits
	 */
	nbytes = fbbits / 7;
	/*
	 * do the transformation
	 */
	for (bn = 1; (n = READ(ibuf, nbytes)) == nbytes; bn++) {
		MEMCPY(BUFFER(msgbuf), BUFFER(ivec), 8);
		DES_XFORM(UBUFFER(msgbuf));
		for (c = 0; c < 8 - nbytes; c++)
			CHAR(ivec, c) = CHAR(ivec, c+nbytes);
		for (c = 0; c < nbytes; c++) {
			CHAR(ivec, 8-nbytes+c) = ibuf[c]|0200;
			obuf[c] = (ibuf[c] ^ UCHAR(msgbuf, c))&0177;
		}
		/*
		 * if the last one, handle it specially
		 */
		if ((c = getchar()) == EOF) {
			if ((n = (obuf[nbytes-1] - '0')) < 0
						|| n > nbytes-1)
				err(1, "decryption failed (block %d corrupted)", bn);
		}
		else
			(void)ungetc(c, stdin);
		WRITE(obuf, n);
	}
	if (n > 0)
		err(1, "decryption failed (block %d incomplete)", bn);
}


/*
 * This encrypts using the Output FeedBack mode of DES
 */
void
ofbenc(void)
{
	int n;			/* number of bytes actually read */
	int c;			/* used to test for EOF */
	int nbytes;		/* number of bytes to read */
	int bn;			/* block number */
	char ibuf[8];		/* input buffer */
	char obuf[8];		/* output buffer */
	Desbuf msgbuf;		/* encryption buffer */

	/*
	 * do things in bytes, not bits
	 */
	nbytes = fbbits / 8;
	/*
	 * do the transformation
	 */
	for (bn = 1; (n = READ(ibuf, nbytes)) == nbytes; bn++) {
		MEMCPY(BUFFER(msgbuf), BUFFER(ivec), 8);
		DES_XFORM(UBUFFER(msgbuf));
		for (n = 0; n < 8 - nbytes; n++)
			UCHAR(ivec, n) = UCHAR(ivec, n+nbytes);
		for (n = 0; n < nbytes; n++) {
			UCHAR(ivec, 8-nbytes+n) = UCHAR(msgbuf, n);
			obuf[n] = ibuf[n] ^ UCHAR(msgbuf, n);
		}
		WRITE(obuf, nbytes);
	}
	/*
	 * at EOF or last block -- in either case, the last byte contains
	 * the character representation of the number of bytes in it
	 */
	bn++;
	MEMZERO(&ibuf[n], nbytes - n);
	ibuf[nbytes - 1] = n;
	MEMCPY(BUFFER(msgbuf), BUFFER(ivec), 8);
	DES_XFORM(UBUFFER(msgbuf));
	for (c = 0; c < nbytes; c++)
		ibuf[c] ^= UCHAR(msgbuf, c);
	WRITE(ibuf, nbytes);
}

/*
 * This decrypts using the Output Block Chaining mode of DES
 */
void
ofbdec(void)
{
	int n;			/* number of bytes actually read */
	int c;			/* used to test for EOF */
	int nbytes;		/* number of bytes to read */
	int bn;			/* block number */
	char ibuf[8];		/* input buffer */
	char obuf[8];		/* output buffer */
	Desbuf msgbuf;		/* encryption buffer */

	/*
	 * do things in bytes, not bits
	 */
	nbytes = fbbits / 8;
	/*
	 * do the transformation
	 */
	for (bn = 1; (n = READ(ibuf, nbytes)) == nbytes; bn++) {
		MEMCPY(BUFFER(msgbuf), BUFFER(ivec), 8);
		DES_XFORM(UBUFFER(msgbuf));
		for (c = 0; c < 8 - nbytes; c++)
			CHAR(ivec, c) = CHAR(ivec, c+nbytes);
		for (c = 0; c < nbytes; c++) {
			CHAR(ivec, 8-nbytes+c) = UCHAR(msgbuf, c);
			obuf[c] = ibuf[c] ^ UCHAR(msgbuf, c);
		}
		/*
		 * if the last one, handle it specially
		 */
		if ((c = getchar()) == EOF) {
			n = obuf[nbytes-1];
			if (n < 0 || n > nbytes-1)
				err(1, "decryption failed (block %d corrupted)", bn);
		}
		else
			(void)ungetc(c, stdin);
		/*
		 * dump it
		 */
		WRITE(obuf, n);
	}
	if (n > 0)
		err(1, "decryption failed (block %d incomplete)", bn);
}

/*
 * This authenticates using the Cipher FeedBack mode of DES
 */
void
cfbauth(void)
{
	int n, j;		/* number of bytes actually read */
	int nbytes;		/* number of bytes to read */
	char ibuf[8];		/* input buffer */
	Desbuf msgbuf;		/* encryption buffer */

	/*
	 * do things in bytes, not bits
	 */
	nbytes = fbbits / 8;
	/*
	 * do the transformation
	 */
	while ((n = READ(ibuf, nbytes)) == nbytes) {
		MEMCPY(BUFFER(msgbuf), BUFFER(ivec), 8);
		DES_XFORM(UBUFFER(msgbuf));
		for (n = 0; n < 8 - nbytes; n++)
			UCHAR(ivec, n) = UCHAR(ivec, n+nbytes);
		for (n = 0; n < nbytes; n++)
			UCHAR(ivec, 8-nbytes+n) = ibuf[n] ^ UCHAR(msgbuf, n);
	}
	/*
	 * at EOF or last block -- in either case, the last byte contains
	 * the character representation of the number of bytes in it
	 */
	MEMZERO(&ibuf[n], nbytes - n);
	ibuf[nbytes - 1] = '0' + n;
	MEMCPY(BUFFER(msgbuf), BUFFER(ivec), 8);
	DES_XFORM(UBUFFER(msgbuf));
	for (n = 0; n < nbytes; n++)
		ibuf[n] ^= UCHAR(msgbuf, n);
	/*
	 * drop the bits
	 * we write chars until fewer than 7 bits,
	 * and then pad the last one with 0 bits
	 */
	for (n = 0; macbits > 7; n++, macbits -= 8)
		(void)putchar(CHAR(msgbuf, n));
	if (macbits > 0) {
		CHAR(msgbuf, 0) = 0x00;
		for (j = 0; j < macbits; j++)
			CHAR(msgbuf, 0) |= (CHAR(msgbuf, n)&bits[j]);
		(void)putchar(CHAR(msgbuf, 0));
	}
}

extern char *__progname;
/*
 * message about usage
 */
void
usage(void)
{
	(void) fprintf(stderr, "usage: %s %s\n", __progname,
	    "[-abdp] [-F N] [-f N] [-k key] [-m N] [-o N] [-v vector]");
	exit(1);
}
@


1.18
log
@variety of unsigned char casts (or conversions) for ctype
ok krw
@
text
@d1 1
a1 1
/*	$OpenBSD: bdes.c,v 1.17 2011/01/20 22:12:42 jasper Exp $	*/
@


1.17
log
@- remove some dead code, since we #define something and test for it on the next
line, the #else part can go.

ok miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: bdes.c,v 1.16 2009/10/27 23:59:36 deraadt Exp $	*/
d433 1
a433 1
	while (isspace(*s))
d439 1
a439 1
		if (isdigit(*p))
@


1.16
log
@rcsid[] and sccsid[] and copyright[] are essentially unmaintained (and
unmaintainable).  these days, people use source.  these id's do not provide
any benefit, and do hurt the small install media
(the 33,000 line diff is essentially mechanical)
ok with the idea millert, ok dms
@
text
@d1 1
a1 1
/*	$OpenBSD: bdes.c,v 1.15 2007/09/02 15:19:31 deraadt Exp $	*/
a104 2
#define	FASTWAY
#ifdef	FASTWAY
a110 17
#else
#define	DES_KEY(buf)	{						\
				char bits1[64];	/* bits of key */	\
				expand(buf, bits1);			\
				if (setkey(bits1))			\
					err(1, "setkey");		\
			}
#define	DES_XFORM(buf)	{						\
				char bits1[64];	/* bits of message */	\
				expand(buf, bits1);			\
				if (encrypt(bits1, inverse))		\
					err(1, "encrypt");		\
				compress(bits1, buf);			\
			}
void	expand(Desbuf, char *);
void	compress(Desbuf, char *);
#endif
a992 30

#ifndef FASTWAY
/*
 * change from 8 bits/Uchar to 1 bit/Uchar
 */
void
expand(Desbuf from, char *to)
{
	int i, j;			/* counters in for loop */

	for (i = 0; i < 8; i++)
		for (j = 0; j < 8; j++)
			*to++ = (CHAR(from, i)>>(7-j))&01;
}

/*
 * change from 1 bit/char to 8 bits/Uchar
 */
void
compress(char *from, Desbuf to)
{
	int i, j;			/* counters in for loop */

	for (i = 0; i < 8; i++) {
	 	CHAR(to, i) = 0;
		for (j = 0; j < 8; j++)
			CHAR(to, i) = ((*from++)<<(7-j))|CHAR(to, i);
	}
}
#endif
@


1.15
log
@use calloc() to avoid malloc(n * m) overflows; checked by djm canacar jsg
@
text
@d1 1
a1 1
/*	$OpenBSD: bdes.c,v 1.14 2004/05/16 18:49:12 otto Exp $	*/
a38 14

#ifndef lint
static char copyright[] =
"@@(#) Copyright (c) 1991, 1993\n\
	The Regents of the University of California.  All rights reserved.\n";
#endif /* not lint */

#ifndef lint
#if 0
static char sccsid[] = "@@(#)bdes.c	8.1 (Berkeley) 6/6/93";
#else
static char rcsid[] = "$OpenBSD: bdes.c,v 1.14 2004/05/16 18:49:12 otto Exp $";
#endif
#endif /* not lint */
@


1.14
log
@Prototypes; usage sync. ok millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: bdes.c,v 1.13 2003/11/15 00:23:02 tedu Exp $	*/
d50 1
a50 1
static char rcsid[] = "$OpenBSD: bdes.c,v 1.13 2003/11/15 00:23:02 tedu Exp $";
d203 1
a203 1
	argv = malloc((argc + 1) * sizeof(char *));
@


1.13
log
@check getpass for NULL.  from Jared Yanovich.  ok otto@@
@
text
@d1 1
a1 1
/*	$OpenBSD: bdes.c,v 1.12 2003/07/02 21:04:09 deraadt Exp $	*/
d50 1
a50 1
static char rcsid[] = "$OpenBSD: bdes.c,v 1.12 2003/07/02 21:04:09 deraadt Exp $";
d141 2
d1031 2
a1032 3
expand(from, to)
	Desbuf from;			/* 8bit/unsigned char string */
	char *to;			/* 1bit/char string */
d1044 2
a1045 3
compress(from, to)
	char *from;			/* 1bit/char string */
	Desbuf to;			/* 8bit/unsigned char string */
d1057 1
d1064 2
a1065 2
	(void)fprintf(stderr, "%s\n", 
"usage: bdes [-abdp] [-F bit] [-f bit] [-k key] [-m bit] [-o bit] [-v vector]");
@


1.12
log
@protos
@
text
@d1 1
a1 1
/*	$OpenBSD: bdes.c,v 1.11 2003/06/10 22:20:45 deraadt Exp $	*/
d50 1
a50 1
static char rcsid[] = "$OpenBSD: bdes.c,v 1.11 2003/06/10 22:20:45 deraadt Exp $";
d274 2
a275 1
		p = getpass("Enter key: ");
@


1.11
log
@mostly ansi cleanup; pval ok
@
text
@d1 1
a1 1
/*	$OpenBSD: bdes.c,v 1.10 2003/06/03 02:56:06 millert Exp $	*/
d50 1
a50 1
static char rcsid[] = "$OpenBSD: bdes.c,v 1.10 2003/06/03 02:56:06 millert Exp $";
d93 1
a93 1
int 	tobinhexi(char, int);
d216 1
a216 1
		switch(i) {
d284 1
a284 1
	switch(alg) {
d286 1
a286 1
		switch(mode) {
d299 1
a299 1
		switch(mode) {
d312 1
a312 1
		switch(mode) {
d325 1
a325 1
		switch(mode) {
d338 1
a338 1
		switch(mode) {
d360 1
a360 1
	switch(c) {
d396 1
a396 1
	switch(keybase) {
@


1.10
log
@Remove the advertising clause in the UCB license which Berkeley
rescinded 22 July 1999.  Proofed by myself and Theo.
@
text
@d1 1
a1 1
/*	$OpenBSD: bdes.c,v 1.9 2003/03/31 20:46:03 rohee Exp $	*/
d50 1
a50 1
static char rcsid[] = "$OpenBSD: bdes.c,v 1.9 2003/03/31 20:46:03 rohee Exp $";
d184 1
a184 3
main(ac, av)
	int ac;				/* arg count */
	char **av;			/* arg vector */
d358 1
a358 3
tobinhex(c, radix)
	char c;			/* char to be converted */
	int radix;		/* base (2 to 16) */
d388 1
a388 3
cvtkey(obuf, ibuf)
	char *obuf;			/* bit pattern */
	char *ibuf;			/* the key itself */
d455 1
a455 3
setbits(s, mult)
	char *s;			/* the ASCII string */
	int mult;			/* what it must be a multiple of */
d496 1
a496 2
makekey(buf)
	Desbuf buf;				/* key block */
d524 1
a524 1
ecbenc()
d553 1
a553 1
ecbdec()
d585 1
a585 1
cbcenc()
d619 1
a619 1
cbcdec()
d656 1
a656 1
cbcauth()
d701 1
a701 1
cfbenc()
d743 1
a743 1
cfbdec()
d789 1
a789 1
cfbaenc()
d835 1
a835 1
cfbadec()
d882 1
a882 1
ofbenc()
d928 1
a928 1
ofbdec()
d977 1
a977 1
cfbauth()
d1060 1
a1060 1
usage()
@


1.9
log
@Typos in comments.

encryptiooon -> encryption
vctor -> vector
ascii -> ASCII
@
text
@d1 1
a1 1
/*	$OpenBSD: bdes.c,v 1.8 2002/07/03 23:13:02 deraadt Exp $	*/
d23 1
a23 5
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
d50 1
a50 1
static char rcsid[] = "$OpenBSD: bdes.c,v 1.8 2002/07/03 23:13:02 deraadt Exp $";
@


1.8
log
@check for malloc failure; reported by cloder@@acm.org
@
text
@d1 1
a1 1
/*	$OpenBSD: bdes.c,v 1.7 2002/02/16 21:27:44 millert Exp $	*/
d54 1
a54 1
static char rcsid[] = "$OpenBSD: bdes.c,v 1.7 2002/02/16 21:27:44 millert Exp $";
d197 1
a197 1
	int kflag;			/* command-line encryptiooon key */
d216 1
a216 1
	/* initialize the initialization vctor */
d407 1
a407 1
	case KEY_ASCII:			/* ascii to integer */
@


1.7
log
@Part one of userland __P removal.  Done with a simple regexp with some minor hand editing to make comments line up correctly.  Another pass is forthcoming that handles the cases that could not be done automatically.
@
text
@d1 1
a1 1
/*	$OpenBSD: bdes.c,v 1.6 2001/11/19 19:02:13 mpech Exp $	*/
d54 1
a54 1
static char rcsid[] = "$OpenBSD: bdes.c,v 1.6 2001/11/19 19:02:13 mpech Exp $";
d208 2
@


1.6
log
@kill more registers

millert@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: bdes.c,v 1.5 2001/02/05 08:38:23 deraadt Exp $	*/
d54 1
a54 1
static char rcsid[] = "$OpenBSD: bdes.c,v 1.5 2001/02/05 08:38:23 deraadt Exp $";
d97 17
a113 17
int 	tobinhexi __P((char, int));
void 	cvtkey __P((char *, char *));
int 	setbits __P((char *, int));
void 	makekey __P((Desbuf));
void 	ecbenc __P((void));
void 	ecbdec __P((void));
void 	cbcenc __P((void));
void 	cbcdec __P((void));
void 	cbcauth __P((void));
void 	cfbenc __P((void));
void 	cfbdec __P((void));
void 	cfbaenc __P((void));
void 	cfbadec __P((void));
void 	cfbauth __P((void));
void 	ofbdec __P((void));
void 	ofbenc __P((void));
void 	usage __P((void));
@


1.5
log
@KNF cleanup; tomo
@
text
@d1 1
a1 1
/*	$OpenBSD: bdes.c,v 1.4 1998/05/07 19:12:17 deraadt Exp $	*/
d54 1
a54 1
static char rcsid[] = "$OpenBSD: bdes.c,v 1.4 1998/05/07 19:12:17 deraadt Exp $";
d194 2
a195 2
	register int i;			/* counter in a for loop */
	register char *p;		/* used to obtain the key */
d398 1
a398 1
	register int i, j;		/* counter in a for loop */
d467 2
a468 2
	register char *p;		/* pointer in a for loop */
	register int n = 0;		/* the integer collected */
d509 2
a510 2
	register int i, j;			/* counter in a for loop */
	register int par;			/* parity counter */
d537 2
a538 2
	register int n;		/* number of bytes actually read */
	register int bn;	/* block number */
d566 3
a568 3
	register int n;		/* number of bytes actually read */
	register int c;		/* used to test for EOF */
	register int bn;	/* block number */
d598 2
a599 2
	register int n;		/* number of bytes actually read */
	register int bn;	/* block number */
d632 1
a632 1
	register int n;		/* number of bytes actually read */
d635 2
a636 2
	register int c;		/* used to test for EOF */
	register int bn;	/* block number */
d669 1
a669 1
	register int n, j;		/* number of bytes actually read */
d714 3
a716 3
	register int n;		/* number of bytes actually read */
	register int nbytes;	/* number of bytes to read */
	register int bn;	/* block number */
d756 4
a759 4
	register int n;		/* number of bytes actually read */
	register int c;		/* used to test for EOF */
	register int nbytes;	/* number of bytes to read */
	register int bn;	/* block number */
d802 3
a804 3
	register int n;		/* number of bytes actually read */
	register int nbytes;	/* number of bytes to read */
	register int bn;	/* block number */
d848 4
a851 4
	register int n;		/* number of bytes actually read */
	register int c;		/* used to test for EOF */
	register int nbytes;	/* number of bytes to read */
	register int bn;	/* block number */
d895 4
a898 4
	register int n;		/* number of bytes actually read */
	register int c;		/* used to test for EOF */
	register int nbytes;	/* number of bytes to read */
	register int bn;	/* block number */
d941 4
a944 4
	register int n;		/* number of bytes actually read */
	register int c;		/* used to test for EOF */
	register int nbytes;	/* number of bytes to read */
	register int bn;	/* block number */
d990 2
a991 2
	register int n, j;	/* number of bytes actually read */
	register int nbytes;	/* number of bytes to read */
d1043 1
a1043 1
	register int i, j;		/* counters in for loop */
d1057 1
a1057 1
	register int i, j;		/* counters in for loop */
@


1.4
log
@fix err() use
@
text
@d1 1
a1 1
/*	$OpenBSD: bdes.c,v 1.3 1997/01/15 23:42:13 millert Exp $	*/
d54 1
a54 1
static char rcsid[] = "$OpenBSD: bdes.c,v 1.3 1997/01/15 23:42:13 millert Exp $";
d88 1
d96 19
d127 1
a127 1
		err("des_setkey", 0);
d130 1
a130 1
		err("des_cipher", 0);
d136 1
a136 1
					err("setkey", 0);		\
d142 1
a142 1
					err("encrypt", 0);		\
a157 1
typedef char Desbuf[8];
d186 2
a358 15
 * print a warning message and, possibly, terminate
 */
err(n, s)
	int n;			/* offending block number */
	char *s;		/* the message */
{
	if (n > 0)
		(void)fprintf(stderr, "bdes (block %d): ", n);
	else
		(void)fprintf(stderr, "bdes: ");
	(void)fprintf(stderr, "%s\n", s ? s : strerror(errno));
	exit(1);
}

/*
d361 1
d393 1
d462 1
d505 1
d534 1
d563 1
d595 1
d629 1
d666 1
d711 1
d753 1
d799 1
d845 1
d892 1
d938 1
d987 1
d1070 1
@


1.3
log
@getopt(3) returns -1 when out of args, not EOF, whee!
@
text
@d1 1
a1 1
/*	$OpenBSD: bdes.c,v 1.2 1996/06/26 05:31:39 deraadt Exp $	*/
d54 1
a54 1
static char rcsid[] = "$OpenBSD: bdes.c,v 1.2 1996/06/26 05:31:39 deraadt Exp $";
d133 1
a133 1
			err(bn, NULL);
d212 1
a212 1
				err(-1, "-F: number must be 1-56 inclusive");
d214 1
a214 1
				err(-1, "-F: number must be a multiple of 7");
d219 1
a219 1
				err(-1, "-f: number must be 1-64 inclusive");
d221 1
a221 1
				err(-1, "-f: number must be a multiple of 8");
d230 1
a230 1
				err(-1, "-m: number must be 0-64 inclusive");
d235 1
a235 1
				err(-1, "-o: number must be 1-64 inclusive");
d237 1
a237 1
				err(-1, "-o: number must be a multiple of 8");
d297 1
a297 1
			err(-1, "can't authenticate with CFBA mode");
d310 1
a310 1
			err(-1, "can't authenticate with ECB mode");
d323 1
a323 1
			err(-1, "can't authenticate with OFB mode");
d411 1
a411 1
					err(-1, "bad hex digit in key");
d431 1
a431 1
					err(-1, "bad binary digit in key");
d473 1
a473 1
			err(-1, "bad decimal digit in MAC length");
d570 1
a570 1
				err(bn, "decryption failed (block corrupted)");
d577 1
a577 1
		err(bn, "decryption failed (incomplete block)");
d639 1
a639 1
				err(bn, "decryption failed (block corrupted)");
d646 1
a646 1
		err(bn, "decryption failed (incomplete block)");
d769 1
a769 1
				err(bn, "decryption failed (block corrupted)");
d776 1
a776 1
		err(bn, "decryption failed (incomplete block)");
d859 1
a859 1
				err(bn, "decryption failed (block corrupted)");
d866 1
a866 1
		err(bn, "decryption failed (incomplete block)");
d950 1
a950 1
				err(bn, "decryption failed (block corrupted)");
d960 1
a960 1
		err(bn, "decryption failed (incomplete block)");
@


1.2
log
@rcsid
@
text
@d1 1
a1 1
/*	$OpenBSD: bdes.c,v 1.2 1995/03/26 03:33:19 glass Exp $	*/
d54 1
a54 1
static char rcsid[] = "$OpenBSD: bdes.c,v 1.2 1995/03/26 03:33:19 glass Exp $";
d198 1
a198 1
	while ((i = getopt(argc, argv, "abdF:f:k:m:o:pv:")) != EOF)
@


1.1
log
@use the real bdes
@
text
@d1 1
d54 1
a54 1
static char rcsid[] = "$NetBSD: bdes.c,v 1.2 1995/03/26 03:33:19 glass Exp $";
@
