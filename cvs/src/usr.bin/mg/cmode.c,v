head	1.16;
access;
symbols
	OPENBSD_6_2:1.16.0.10
	OPENBSD_6_2_BASE:1.16
	OPENBSD_6_1:1.16.0.8
	OPENBSD_6_1_BASE:1.16
	OPENBSD_6_0:1.16.0.4
	OPENBSD_6_0_BASE:1.16
	OPENBSD_5_9:1.16.0.2
	OPENBSD_5_9_BASE:1.16
	OPENBSD_5_8:1.15.0.4
	OPENBSD_5_8_BASE:1.15
	OPENBSD_5_7:1.12.0.2
	OPENBSD_5_7_BASE:1.12
	OPENBSD_5_6:1.9.0.4
	OPENBSD_5_6_BASE:1.9
	OPENBSD_5_5:1.8.0.10
	OPENBSD_5_5_BASE:1.8
	OPENBSD_5_4:1.8.0.6
	OPENBSD_5_4_BASE:1.8
	OPENBSD_5_3:1.8.0.4
	OPENBSD_5_3_BASE:1.8
	OPENBSD_5_2:1.8.0.2
	OPENBSD_5_2_BASE:1.8
	OPENBSD_5_1_BASE:1.7
	OPENBSD_5_1:1.7.0.6
	OPENBSD_5_0:1.7.0.4
	OPENBSD_5_0_BASE:1.7
	OPENBSD_4_9:1.7.0.2
	OPENBSD_4_9_BASE:1.7
	OPENBSD_4_8:1.6.0.8
	OPENBSD_4_8_BASE:1.6
	OPENBSD_4_7:1.6.0.4
	OPENBSD_4_7_BASE:1.6
	OPENBSD_4_6:1.6.0.6
	OPENBSD_4_6_BASE:1.6
	OPENBSD_4_5:1.6.0.2
	OPENBSD_4_5_BASE:1.6
	OPENBSD_4_4:1.4.0.2
	OPENBSD_4_4_BASE:1.4;
locks; strict;
comment	@ * @;


1.16
date	2015.09.26.21.51.58;	author jasper;	state Exp;
branches;
next	1.15;
commitid	yS81WdIVlzEJxLUH;

1.15
date	2015.03.19.21.48.05;	author bcallah;	state Exp;
branches;
next	1.14;
commitid	8rkHsVfUx5xgPXRB;

1.14
date	2015.03.19.21.22.15;	author bcallah;	state Exp;
branches;
next	1.13;
commitid	GbEBL4CfPvDkB8hj;

1.13
date	2015.03.16.13.47.48;	author bcallah;	state Exp;
branches;
next	1.12;
commitid	gSveQVkxMLs6vRqK;

1.12
date	2015.01.13.17.02.28;	author bcallah;	state Exp;
branches;
next	1.11;
commitid	jI5hJjs2ML65P3Uu;

1.11
date	2015.01.02.11.43.15;	author lum;	state Exp;
branches;
next	1.10;
commitid	KImc5RxUXDCynGEz;

1.10
date	2014.11.16.01.08.36;	author guenther;	state Exp;
branches;
next	1.9;
commitid	eCXSfIq2gOaj9bHM;

1.9
date	2014.03.31.14.26.03;	author bcallah;	state Exp;
branches;
next	1.8;

1.8
date	2012.05.18.02.13.44;	author lum;	state Exp;
branches;
next	1.7;

1.7
date	2011.01.18.17.35.42;	author lum;	state Exp;
branches;
next	1.6;

1.6
date	2008.12.17.10.28.27;	author sobrado;	state Exp;
branches;
next	1.5;

1.5
date	2008.09.15.16.13.35;	author kjell;	state Exp;
branches;
next	1.4;

1.4
date	2008.06.14.08.39.30;	author kjell;	state Exp;
branches;
next	1.3;

1.3
date	2008.06.13.19.10.17;	author kjell;	state Exp;
branches;
next	1.2;

1.2
date	2008.06.12.21.51.18;	author kjell;	state Exp;
branches;
next	1.1;

1.1
date	2008.06.12.01.58.44;	author kjell;	state Exp;
branches;
next	;


desc
@@


1.16
log
@whitespace
@
text
@/* $OpenBSD: cmode.c,v 1.15 2015/03/19 21:48:05 bcallah Exp $ */
/*
 * This file is in the public domain.
 *
 * Author: Kjell Wooding <kjell@@openbsd.org>
 */

/*
 * Implement an non-irritating KNF-compliant mode for editing
 * C code.
 */

#include <sys/queue.h>
#include <ctype.h>
#include <signal.h>
#include <stdio.h>

#include "def.h"
#include "funmap.h"
#include "kbd.h"

/* Pull in from modes.c */
extern int changemode(int, int, char *);

static int cc_strip_trailp = TRUE;	/* Delete Trailing space? */
static int cc_basic_indent = 8;		/* Basic Indent multiple */
static int cc_cont_indent = 4;		/* Continued line indent */
static int cc_colon_indent = -8;	/* Label / case indent */

static int getmatch(int, int);
static int getindent(const struct line *, int *);
static int in_whitespace(struct line *, int);
static int findcolpos(const struct buffer *, const struct line *, int);
static struct line *findnonblank(struct line *);
static int isnonblank(const struct line *, int);

void cmode_init(void);
int cc_comment(int, int);

/* Keymaps */

static PF cmode_brace[] = {
	cc_brace,	/* } */
};

static PF cmode_cCP[] = {
	compile,		/* C-c P */
};


static PF cmode_cc[] = {
	NULL,		/* ^C */
	rescan,		/* ^D */
	rescan,		/* ^E */
	rescan,		/* ^F */
	rescan,		/* ^G */
	rescan,		/* ^H */
	cc_tab,		/* ^I */
	rescan,		/* ^J */
	rescan,		/* ^K */
	rescan,		/* ^L */
	cc_lfindent,	/* ^M */
};

static PF cmode_spec[] = {
	cc_char,	/* : */
};

static struct KEYMAPE (1) cmode_cmap = {
	1,
	1,
	rescan,
	{
		{ 'P', 'P', cmode_cCP, NULL }
	}
};

static struct KEYMAPE (3) cmodemap = {
	3,
	3,
	rescan,
	{
		{ CCHR('C'), CCHR('M'), cmode_cc, (KEYMAP *) &cmode_cmap },
		{ ':', ':', cmode_spec, NULL },
		{ '}', '}', cmode_brace, NULL }
	}
};

/* Funtion, Mode hooks */

void
cmode_init(void)
{
	funmap_add(cmode, "c-mode");
	funmap_add(cc_char, "c-handle-special-char");
	funmap_add(cc_brace, "c-handle-special-brace");
	funmap_add(cc_tab, "c-tab-or-indent");
	funmap_add(cc_indent, "c-indent");
	funmap_add(cc_lfindent, "c-indent-and-newline");
	maps_add((KEYMAP *)&cmodemap, "c");
}

/*
 * Enable/toggle c-mode
 */
int
cmode(int f, int n)
{
	return(changemode(f, n, "c"));
}

/*
 * Handle special C character - selfinsert then indent.
 */
int
cc_char(int f, int n)
{
	if (n < 0)
		return (FALSE);
	if (selfinsert(FFRAND, n) == FALSE)
		return (FALSE);
	return (cc_indent(FFRAND, n));
}

/*
 * Handle special C character - selfinsert then indent.
 */
int
cc_brace(int f, int n)
{
	if (n < 0)
		return (FALSE);
	if (showmatch(FFRAND, 1) == FALSE)
		return (FALSE);
	return (cc_indent(FFRAND, n));
}


/*
 * If we are in the whitespace at the beginning of the line,
 * simply act as a regular tab. If we are not, indent
 * current line according to whitespace rules.
 */
int
cc_tab(int f, int n)
{
	int inwhitep = FALSE;	/* In leading whitespace? */

	inwhitep = in_whitespace(curwp->w_dotp, llength(curwp->w_dotp));

	/* If empty line, or in whitespace */
	if (llength(curwp->w_dotp) == 0 || inwhitep)
		return (selfinsert(f, n));

	return (cc_indent(FFRAND, 1));
}

/*
 * Attempt to indent current line according to KNF rules.
 */
int
cc_indent(int f, int n)
{
	int pi, mi;			/* Previous indents (mi is ignored) */
	int ci;				/* current indent */
	struct line *lp;
	int ret;

	if (n < 0)
		return (FALSE);

	undo_boundary_enable(FFRAND, 0);
	if (cc_strip_trailp)
		deltrailwhite(FFRAND, 1);

	/*
	 * Search backwards for a non-blank, non-preprocessor,
	 * non-comment line
	 */

	lp = findnonblank(curwp->w_dotp);

	pi = getindent(lp, &mi);

	/* Strip leading space on current line */
	delleadwhite(FFRAND, 1);
	/* current indent is computed only to current position */
	(void)getindent(curwp->w_dotp, &ci);

	if (pi + ci < 0)
		ret = indent(FFOTHARG, 0);
	else
		ret = indent(FFOTHARG, pi + ci);

	undo_boundary_enable(FFRAND, 1);

	return (ret);
}

/*
 * Indent-and-newline (technically, newline then indent)
 */
int
cc_lfindent(int f, int n)
{
	if (n < 0)
		return (FALSE);
	if (enewline(FFRAND, 1) == FALSE)
		return (FALSE);
	return (cc_indent(FFRAND, n));
}

/*
 * Get the level of indention after line lp is processed
 * Note getindent has two returns:
 * curi = value if indenting current line.
 * return value = value affecting subsequent lines.
 */
static int
getindent(const struct line *lp, int *curi)
{
	int lo, co;		/* leading space,  current offset*/
	int nicol = 0;		/* position count */
	int c = '\0';		/* current char */
	int newind = 0;		/* new index value */
	int stringp = FALSE;	/* in string? */
	int escp = FALSE;	/* Escape char? */
	int lastc = '\0';	/* Last matched string delimeter */
	int nparen = 0;		/* paren count */
	int obrace = 0;		/* open brace count */
	int cbrace = 0;		/* close brace count */
	int firstnwsp = FALSE;	/* First nonspace encountered? */
	int colonp = FALSE;	/* Did we see a colon? */
	int questionp = FALSE;	/* Did we see a question mark? */
	int slashp = FALSE;	/* Slash? */
	int astp = FALSE;	/* Asterisk? */
	int cpos = -1;		/* comment position */
	int cppp  = FALSE;	/* Preprocessor command? */

	*curi = 0;

	/* Compute leading space */
	for (lo = 0; lo < llength(lp); lo++) {
		if (!isspace(c = lgetc(lp, lo)))
			break;
		if (c == '\t'
#ifdef NOTAB
		    && !(curbp->b_flag & BFNOTAB)
#endif /* NOTAB */
		    ) {
			nicol |= 0x07;
		}
		nicol++;
	}

	/* If last line was blank, choose 0 */
	if (lo == llength(lp))
		nicol = 0;

	newind = 0;
	/* Compute modifiers */
	for (co = lo; co < llength(lp); co++) {
		c = lgetc(lp, co);
		/* We have a non-whitespace char */
		if (!firstnwsp && !isspace(c)) {
			if (c == '#')
				cppp = TRUE;
			firstnwsp = TRUE; 
		}
		if (c == '\\')
			escp = !escp;
		else if (stringp) {
			if (!escp && (c == '"' || c == '\'')) {
				/* unescaped string char */
				if (getmatch(c, lastc))
					stringp = FALSE;
			}
		} else if (c == '"' || c == '\'') {
			stringp = TRUE;
			lastc = c;
		} else if (c == '(') {
			nparen++;
		} else if (c == ')') {
			nparen--;
		} else if (c == '{') {
			obrace++;
			firstnwsp = FALSE;
		} else if (c == '}') {
			cbrace++;
		} else if (c == '?') {
			questionp = TRUE;
		} else if (c == ':') {
			/* ignore (foo ? bar : baz) construct */
			if (!questionp)
				colonp = TRUE;
		} else if (c == '/') {
			/* first nonwhitespace? -> indent */
			if (firstnwsp) {
				/* If previous char asterisk -> close */
				if (astp)
					cpos = -1;
				else
					slashp = TRUE;
			}
		} else if (c == '*') {
			/* If previous char slash -> open */
			if (slashp)
				cpos = co;
			else
				astp = TRUE;
		} else if (firstnwsp) {
			firstnwsp = FALSE;
		}

		/* Reset matches that apply to next character only */
		if (c != '\\')
			escp = FALSE;
		if (c != '*')
			astp = FALSE;
		if (c != '/')
			slashp = FALSE;
	}
	/*
	 * If not terminated with a semicolon, and brace or paren open.
	 * we continue
	 */
	if (colonp) {
		*curi += cc_colon_indent;
		newind -= cc_colon_indent;
	}

	*curi -= (cbrace) * cc_basic_indent;
	newind += obrace * cc_basic_indent;

	if (nparen < 0)
		newind -= cc_cont_indent;
	else if (nparen > 0)
		newind += cc_cont_indent;

	*curi += nicol;

	/* Ignore preprocessor. Otherwise, add current column */
	if (cppp) {
		newind = nicol;
		*curi = 0;
	} else {
		newind += nicol;
	}

	if (cpos != -1)
		newind = findcolpos(curbp, lp, cpos);

	return (newind);
}

/*
 * Given a delimeter and its purported mate, tell us if they
 * match.
 */
static int
getmatch(int c, int mc)
{
	int match = FALSE;

	switch (c) {
	case '"':
		match = (mc == '"');
		break;
	case '\'':
		match = (mc == '\'');
		break;
	case '(':
		match = (mc == ')');
		break;
	case '[':
		match = (mc == ']');
		break;
	case '{':
		match = (mc == '}');
		break;
	}

	return (match);
}

static int
in_whitespace(struct line *lp, int len)
{
	int lo;
	int inwhitep = FALSE;

	for (lo = 0; lo < len; lo++) {
		if (!isspace(lgetc(lp, lo)))
			break;
		if (lo == len - 1)
			inwhitep = TRUE;
	}

	return (inwhitep);
}


/* convert a line/offset pair to a column position (for indenting) */
static int
findcolpos(const struct buffer *bp, const struct line *lp, int lo)
{
	int	col, i, c;
	char tmp[5];

	/* determine column */
	col = 0;

	for (i = 0; i < lo; ++i) {
		c = lgetc(lp, i);
		if (c == '\t'
#ifdef NOTAB
		    && !(bp->b_flag & BFNOTAB)
#endif /* NOTAB */
			) {
			col |= 0x07;
			col++;
		} else if (ISCTRL(c) != FALSE)
			col += 2;
		else if (isprint(c)) {
			col++;
		} else {
			col += snprintf(tmp, sizeof(tmp), "\\%o", c);
		}

	}
	return (col);
}

/*
 * Find a non-blank line, searching backwards from the supplied line pointer.
 * For C, nonblank is non-preprocessor, non C++, and accounts
 * for complete C-style comments.
 */
static struct line *
findnonblank(struct line *lp)
{
	int lo;
	int nonblankp = FALSE;
	int commentp = FALSE;
	int slashp;
	int astp;
	int c;

	while (lback(lp) != curbp->b_headp && (commentp || !nonblankp)) {
		lp = lback(lp);
		slashp = FALSE;
		astp = FALSE;

		/* Potential nonblank? */
		nonblankp = isnonblank(lp, llength(lp));

		/*
		 * Search from end, removing complete C-style
		 * comments. If one is found, ignore it and
		 * test for nonblankness from where it starts.
		 */
		for (lo = llength(lp) - 1; lo >= 0; lo--) {
			if (!isspace(c = lgetc(lp, lo))) {
				if (commentp) { /* find comment "open" */
					if (c == '*')
						astp = TRUE;
					else if (astp && c == '/') {
						commentp = FALSE;
						/* whitespace to here? */
						nonblankp = isnonblank(lp, lo);
					}
				} else { /* find comment "close" */
					if (c == '/')
						slashp = TRUE;
					else if (slashp && c == '*')
						/* found a comment */
						commentp = TRUE;
				}
			}
		}
	}

	/* Rewound to start of file? */
	if (lback(lp) == curbp->b_headp && !nonblankp)
		return (curbp->b_headp);

	return (lp);
}

/*
 * Given a line, scan forward to 'omax' and determine if we
 * are all C whitespace.
 * Note that preprocessor directives and C++-style comments
 * count as whitespace. C-style comments do not, and must
 * be handled elsewhere.
 */
static int
isnonblank(const struct line *lp, int omax)
{
	int nonblankp = FALSE;		/* Return value */
	int slashp = FALSE;		/* Encountered slash */
	int lo;				/* Loop index */
	int c;				/* char being read */

	/* Scan from front for preprocessor, C++ comments */
	for (lo = 0; lo < omax; lo++) {
		if (!isspace(c = lgetc(lp, lo))) {
			/* Possible nonblank line */
			nonblankp = TRUE;
			/* skip // and # starts */
			if (c == '#' || (slashp && c == '/')) {
				nonblankp = FALSE;
				break;
			} else if (!slashp && c == '/') {
				slashp = TRUE;
				continue;
			}
		}
		slashp = FALSE;
	}
	return (nonblankp);
}
@


1.15
log
@More unifdef cleanup:
-UDIRED_XMAPS and -UFUND_XMAPS: you can't build mg the other way.
-DTIOCGWINSZ: you have this if you have term.h
Remove a #define TERMCAP which isn't being used.

Remove defines for NDIRED_XMAPS, NFUND_XMAPS, and IMAPEXT. They are all
defined to be 0 and are only ever used in addition. We don't need to add 0.
Simply lines that were using those defines.
ok florian@@
@
text
@d1 1
a1 1
/* $OpenBSD: cmode.c,v 1.14 2015/03/19 21:22:15 bcallah Exp $ */
d148 1
a148 1
	
d168 1
a168 1
	
d189 1
a189 1
	
d194 1
a194 1
	
d196 1
a196 1
	
d239 1
a239 1
	
@


1.14
log
@Clean up the includes in mg.
This does the following:
Moves all POSIX headers from sysdef.h into the individual .c files so that
each file now only includes what it needs. All headers are properly sorted.
Moves the remainder of sysdef.h to other files (mostly def.h) and deletes
sysdef.h now that it's no longer contains anything.
Tweak a comment that references sysdef.h so that it no longer does that.
ok florian@@
@
text
@d1 1
a1 1
/* $OpenBSD: cmode.c,v 1.13 2015/03/16 13:47:48 bcallah Exp $ */
d69 2
a70 1
static struct KEYMAPE (1 + IMAPEXT) cmode_cmap = {
a71 1
	1 + IMAPEXT,
d78 2
a79 1
static struct KEYMAPE (3 + IMAPEXT) cmodemap = {
a80 1
	3 + IMAPEXT,
@


1.13
log
@Change the internal name of the newline function to deconflict with a
function of the same name in term.h. This is the first step towards
cleaning up mg's includes. No user-visible changes.
ok florian@@
@
text
@d1 1
a1 1
/* $OpenBSD: cmode.c,v 1.12 2015/01/13 17:02:28 bcallah Exp $ */
d12 2
d15 2
d19 1
a20 1
#include "funmap.h"
@


1.12
log
@Remove a variable that's not really being used.
ok deraadt@@ jasper@@
@
text
@d1 1
a1 1
/* $OpenBSD: cmode.c,v 1.11 2015/01/02 11:43:15 lum Exp $ */
d204 1
a204 1
	if (newline(FFRAND, 1) == FALSE)
@


1.11
log
@Remove unused variable.
@
text
@d1 1
a1 1
/* $OpenBSD: cmode.c,v 1.10 2014/11/16 01:08:36 guenther Exp $ */
a227 1
	int contp = FALSE;	/* Continue? */
a261 1
			contp = TRUE;
a283 1
			contp = FALSE;
a291 3
		} else if (c == ';') {
			if (nparen > 0)
				contp = FALSE;
@


1.10
log
@Don't save the return from getindent() if you don't need it; adjust
comments to reflect that

based on a diff from Kamil Rytarowski (n54 (at) gmx.com)
@
text
@d1 1
a1 1
/* $OpenBSD: cmode.c,v 1.9 2014/03/31 14:26:03 bcallah Exp $ */
a219 1
	int ccol = 0;		/* current column */
a257 1
	ccol = nicol;			/* current column */
@


1.9
log
@Remove a redundant assignment for slashp in findnonblank().
Remove a redundant comment in the same place while here.
Tweaks from lum@@
ok florian@@ lum@@
@
text
@d1 1
a1 1
/* $OpenBSD: cmode.c,v 1.8 2012/05/18 02:13:44 lum Exp $ */
d160 2
a161 2
	int pi, mi;			/* Previous indents */
	int ci, dci;			/* current indent, don't care */
d184 1
a184 1
	dci = getindent(curwp->w_dotp, &ci);
@


1.8
log
@Allow no-tab-mode to compile. From James Turner.

note: no-tab-mode needs more work done before removing the NOTABs.
@
text
@d1 1
a1 1
/* $OpenBSD: cmode.c,v 1.7 2011/01/18 17:35:42 lum Exp $ */
a465 2
		slashp = FALSE;
		/* Scan backwards from end to find C-style comment */
@


1.7
log
@Add missing prototypes and move dired.c to "extensions" in Makefile.
ok kjell@@
@
text
@d1 1
a1 1
/* $OpenBSD: cmode.c,v 1.6 2008/12/17 10:28:27 sobrado Exp $ */
d246 1
a246 1
		    && !(curbp-b_flag & BFNOTAB)
@


1.6
log
@change the name displayed by the c-mode on the mode line to "c",
as other modes do, for consistency and to save a few chars.

written with help from kjell@@

ok kjell@@
@
text
@d1 1
a1 1
/* $OpenBSD: cmode.c,v 1.5 2008/09/15 16:13:35 kjell Exp $ */
d33 1
@


1.5
log
@Expose the undo commands as proper mg functions.
This should have no functional change on undo, but it does facilitate
testing undo behavior.
@
text
@d1 1
a1 1
/* $OpenBSD: cmode.c,v 1.4 2008/06/14 08:39:30 kjell Exp $ */
d95 1
a95 1
	maps_add((KEYMAP *)&cmodemap, "c-mode");
d104 1
a104 1
	return(changemode(f, n, "c-mode"));
@


1.4
log
@Add compile (c-C c-P) to the c-mode keymap (export from grep.c)
Also, attempt to make indent an atomic undo operation.
@
text
@d1 1
a1 1
/* $OpenBSD: cmode.c,v 1.3 2008/06/13 19:10:17 kjell Exp $ */
d167 1
a167 2
	undo_add_boundary();
	undo_boundary_enable(FALSE);
d190 1
a190 2
	undo_boundary_enable(TRUE);
	undo_add_boundary();
@


1.3
log
@phessler noted that c-mode ignored blinking braces.
Add "c-handle-special-brace" which does a blink and indent, rather
than just a selfinsert and indent
@
text
@d1 1
a1 1
/* $OpenBSD: cmode.c,v 1.2 2008/06/12 21:51:18 kjell Exp $ */
d41 12
a52 1
static PF cmode_ci[] = {
d64 9
d78 1
a78 1
		{ CCHR('I'), CCHR('M'), cmode_ci, NULL },
d162 2
a163 1

d167 2
d187 1
a187 1
		return(indent(FFOTHARG, 0));
d189 6
a194 1
		return(indent(FFOTHARG, pi + ci));
@


1.2
log
@c-mode now understands the two most common type of comments
(with appropriate indenting):

/*
 * comment
 */

and

foo();  /* comment */

Whew. A lot of code for a seemingly simple idea.
ok phessler@@
@
text
@d1 1
a1 1
/* $OpenBSD$ */
d38 1
a38 1
	cc_char,	/* } */
d71 1
d99 14
@


1.1
log
@Introduce a basic c-mode to mg.

The intent of this mode is NOT to copy emacs's monster cc-mode.
It is intended to handle basic KNF-format C, assisting
with indentation (to catch obvious typos), and strip
trailing whitespace. It is NOT enabled unless you ask for it (c-mode).

Basically, tab on start-of-line whitespace acts like tab.
Otherwise, tab indents.

Please try it out and let me know where it falls down.

Feedback Reyk, phessler. "hack in tree" from henning, theo
@
text
@d28 6
d49 1
a49 1
static PF cmode_colon[] = {
a50 1
	rescan,		/* ; */
d59 1
a59 1
		{ ':', ';', cmode_colon, NULL },
a106 1
	int lo;
d109 1
a109 6
	for (lo = 0; lo < llength(curwp->w_dotp); lo++) {
		if (!isspace(lgetc(curwp->w_dotp, lo)))
			break;
		if (lo == curwp->w_doto)
			inwhitep = TRUE;
	}
a110 4
	/* Special case: we could be at the end of a whitespace line */
	if (lo == llength(curwp->w_dotp) && curwp->w_doto == lo)
		inwhitep = TRUE;
	
a125 3
	int lo;
	int c;
	int nonblankp;
d134 6
a139 14
	/* Search backwards for a nonblank, non preprocessor line */
	lp = curwp->w_dotp;
	nonblankp = FALSE;
	while (lback(lp) != curbp->b_headp && !nonblankp) {
		lp = lback(lp);
		for (lo = 0; lo < llength(lp); lo++) {
			if (!isspace(c = lgetc(lp, lo))) {
				/* Leading # is a blank */
				if (c != '#')	
					nonblankp = TRUE;
				break;
			}
		}
	}
d169 1
a169 1
 * Note getindent has two returns: curi, nexti.
a171 2
 * note, we only process up to offset op.
 * set to llength(lp) for the whole line.
d178 1
d188 1
a188 1
	int firstseenp = FALSE;	/* First nonspace encountered? */
d191 4
a215 3
	if (c == '#')
		return (0);

d217 1
d222 1
a222 1
		if (!firstseenp && !isspace(c)) {
d224 3
a226 1
			firstseenp = TRUE; 
d245 1
a245 1
			firstseenp = FALSE;
d258 17
d277 1
a277 1
		/* Reset escape character match */
d280 4
d301 1
a301 1
	newind += nicol;
d304 11
d346 140
@

