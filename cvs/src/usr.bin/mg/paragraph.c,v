head	1.45;
access;
symbols
	OPENBSD_6_0:1.44.0.2
	OPENBSD_6_0_BASE:1.44
	OPENBSD_5_9:1.42.0.2
	OPENBSD_5_9_BASE:1.42
	OPENBSD_5_8:1.36.0.4
	OPENBSD_5_8_BASE:1.36
	OPENBSD_5_7:1.35.0.2
	OPENBSD_5_7_BASE:1.35
	OPENBSD_5_6:1.31.0.4
	OPENBSD_5_6_BASE:1.31
	OPENBSD_5_5:1.29.0.6
	OPENBSD_5_5_BASE:1.29
	OPENBSD_5_4:1.29.0.2
	OPENBSD_5_4_BASE:1.29
	OPENBSD_5_3:1.23.0.2
	OPENBSD_5_3_BASE:1.23
	OPENBSD_5_2:1.22.0.4
	OPENBSD_5_2_BASE:1.22
	OPENBSD_5_1_BASE:1.22
	OPENBSD_5_1:1.22.0.2
	OPENBSD_5_0:1.19.0.10
	OPENBSD_5_0_BASE:1.19
	OPENBSD_4_9:1.19.0.8
	OPENBSD_4_9_BASE:1.19
	OPENBSD_4_8:1.19.0.6
	OPENBSD_4_8_BASE:1.19
	OPENBSD_4_7:1.19.0.2
	OPENBSD_4_7_BASE:1.19
	OPENBSD_4_6:1.19.0.4
	OPENBSD_4_6_BASE:1.19
	OPENBSD_4_5:1.17.0.2
	OPENBSD_4_5_BASE:1.17
	OPENBSD_4_4:1.16.0.2
	OPENBSD_4_4_BASE:1.16
	OPENBSD_4_3:1.15.0.6
	OPENBSD_4_3_BASE:1.15
	OPENBSD_4_2:1.15.0.4
	OPENBSD_4_2_BASE:1.15
	OPENBSD_4_1:1.15.0.2
	OPENBSD_4_1_BASE:1.15
	OPENBSD_4_0:1.14.0.2
	OPENBSD_4_0_BASE:1.14
	OPENBSD_3_9:1.13.0.2
	OPENBSD_3_9_BASE:1.13
	OPENBSD_3_8:1.11.0.2
	OPENBSD_3_8_BASE:1.11
	OPENBSD_3_7:1.9.0.6
	OPENBSD_3_7_BASE:1.9
	OPENBSD_3_6:1.9.0.4
	OPENBSD_3_6_BASE:1.9
	OPENBSD_3_5:1.9.0.2
	OPENBSD_3_5_BASE:1.9
	OPENBSD_3_4:1.8.0.2
	OPENBSD_3_4_BASE:1.8
	OPENBSD_3_3:1.7.0.6
	OPENBSD_3_3_BASE:1.7
	OPENBSD_3_2:1.7.0.4
	OPENBSD_3_2_BASE:1.7
	OPENBSD_3_1:1.7.0.2
	OPENBSD_3_1_BASE:1.7
	OPENBSD_3_0:1.6.0.2
	OPENBSD_3_0_BASE:1.6
	OPENBSD_2_9_BASE:1.4
	OPENBSD_2_9:1.4.0.2
	OPENBSD_2_8:1.3.0.2
	OPENBSD_2_8_BASE:1.3
	OPENBSD_2_7:1.2.0.2
	OPENBSD_2_7_BASE:1.2;
locks; strict;
comment	@ * @;


1.45
date	2016.09.06.16.25.47;	author lum;	state Exp;
branches;
next	1.44;
commitid	hJDKzPbP2DIa0UP4;

1.44
date	2016.04.14.17.05.32;	author lum;	state Exp;
branches;
next	1.43;
commitid	SjhPISg2Q1dkB5Xg;

1.43
date	2016.04.12.06.20.50;	author lum;	state Exp;
branches;
next	1.42;
commitid	yyDIx7D2qffTRLEX;

1.42
date	2015.12.14.03.25.59;	author mmcc;	state Exp;
branches;
next	1.41;
commitid	6idgy7jHjp60ENt8;

1.41
date	2015.10.10.09.13.14;	author lum;	state Exp;
branches;
next	1.40;
commitid	hKKUrQOrFuzFuI2G;

1.40
date	2015.09.26.15.03.15;	author lum;	state Exp;
branches;
next	1.39;
commitid	0ywCmEETZEbQQnyp;

1.39
date	2015.09.24.07.20.12;	author lum;	state Exp;
branches;
next	1.38;
commitid	TJ1TekV8P0zq9MtW;

1.38
date	2015.09.24.07.07.59;	author lum;	state Exp;
branches;
next	1.37;
commitid	ilbGNsJo2VDLtO5r;

1.37
date	2015.09.24.01.24.10;	author lum;	state Exp;
branches;
next	1.36;
commitid	B2V0HjSrykWu3Pkr;

1.36
date	2015.03.19.21.22.15;	author bcallah;	state Exp;
branches;
next	1.35;
commitid	GbEBL4CfPvDkB8hj;

1.35
date	2014.11.16.04.16.41;	author guenther;	state Exp;
branches;
next	1.34;
commitid	a9yG0qCw9VEW27qI;

1.34
date	2014.10.17.13.25.13;	author lum;	state Exp;
branches;
next	1.33;
commitid	m6Igax0rIwnnu51z;

1.33
date	2014.10.13.21.01.05;	author lum;	state Exp;
branches;
next	1.32;
commitid	ONdLpRYsMvkAfuCE;

1.32
date	2014.10.12.18.09.41;	author lum;	state Exp;
branches;
next	1.31;
commitid	PhWAiRnlU9dCnHwU;

1.31
date	2014.03.27.09.30.55;	author florian;	state Exp;
branches;
next	1.30;

1.30
date	2014.03.20.07.47.29;	author lum;	state Exp;
branches;
next	1.29;

1.29
date	2013.06.15.19.58.39;	author lum;	state Exp;
branches;
next	1.28;

1.28
date	2013.06.01.14.27.32;	author lum;	state Exp;
branches;
next	1.27;

1.27
date	2013.06.01.10.23.40;	author lum;	state Exp;
branches;
next	1.26;

1.26
date	2013.06.01.09.50.47;	author lum;	state Exp;
branches;
next	1.25;

1.25
date	2013.06.01.09.46.31;	author lum;	state Exp;
branches;
next	1.24;

1.24
date	2013.05.19.10.27.11;	author lum;	state Exp;
branches;
next	1.23;

1.23
date	2013.02.17.15.42.21;	author lum;	state Exp;
branches;
next	1.22;

1.22
date	2011.11.29.05.59.54;	author lum;	state Exp;
branches;
next	1.21;

1.21
date	2011.11.28.23.37.32;	author matthew;	state Exp;
branches;
next	1.20;

1.20
date	2011.11.28.05.04.17;	author lum;	state Exp;
branches;
next	1.19;

1.19
date	2009.06.04.02.23.37;	author kjell;	state Exp;
branches;
next	1.18;

1.18
date	2009.06.02.21.55.25;	author kjell;	state Exp;
branches;
next	1.17;

1.17
date	2008.09.15.16.13.35;	author kjell;	state Exp;
branches;
next	1.16;

1.16
date	2008.06.12.21.36.47;	author kjell;	state Exp;
branches;
next	1.15;

1.15
date	2006.11.17.08.45.31;	author kjell;	state Exp;
branches;
next	1.14;

1.14
date	2006.07.25.08.22.32;	author kjell;	state Exp;
branches;
next	1.13;

1.13
date	2005.11.18.20.56.53;	author deraadt;	state Exp;
branches;
next	1.12;

1.12
date	2005.10.18.18.54.48;	author kjell;	state Exp;
branches;
next	1.11;

1.11
date	2005.06.14.18.14.40;	author kjell;	state Exp;
branches;
next	1.10;

1.10
date	2005.04.03.02.09.28;	author db;	state Exp;
branches;
next	1.9;

1.9
date	2003.10.24.20.32.06;	author avsm;	state Exp;
branches;
next	1.8;

1.8
date	2003.05.20.03.08.55;	author cloder;	state Exp;
branches;
next	1.7;

1.7
date	2002.02.14.14.24.21;	author deraadt;	state Exp;
branches;
next	1.6;

1.6
date	2001.05.24.03.05.25;	author mickey;	state Exp;
branches;
next	1.5;

1.5
date	2001.05.23.22.20.36;	author art;	state Exp;
branches;
next	1.4;

1.4
date	2001.01.29.01.58.09;	author niklas;	state Exp;
branches;
next	1.3;

1.3
date	2000.09.01.14.59.09;	author millert;	state Exp;
branches;
next	1.2;

1.2
date	2000.04.13.06.12.16;	author millert;	state Exp;
branches;
next	1.1;

1.1
date	2000.02.25.19.08.50;	author deraadt;	state Exp;
branches;
next	;


desc
@@


1.45
log
@If you have a paragraph:

123
456

With the cursor on either the 4, 5 or 6 and no newline after the '6',
and then execute forward-paragraph (M-}), the cursor sits still and
does not move to the end of the second line (after the 6), which is in
effect the end of parapraph. This diff fixes that behaviour.
@
text
@/*	$OpenBSD: paragraph.c,v 1.44 2016/04/14 17:05:32 lum Exp $	*/

/* This file is in the public domain. */

/*
 * Code for dealing with paragraphs and filling. Adapted from MicroEMACS 3.6
 * and GNU-ified by mwm@@ucbvax.	 Several bug fixes by blarson@@usc-oberon.
 */

#include <sys/queue.h>
#include <ctype.h>
#include <limits.h>
#include <signal.h>
#include <stdio.h>
#include <stdlib.h>

#include "def.h"

static int	fillcol = 70;

#define MAXWORD 256

static int	findpara(void);
static int 	do_gotoeop(int, int, int *);

/*
 * Move to start of paragraph.
 * Move backwards by line, checking from the 1st character forwards for the
 * existence a non-space. If a non-space character is found, move to the 
 * preceding line. Keep doing this until a line with only spaces is found or
 * the start of buffer.
 */
/* ARGSUSED */
int
gotobop(int f, int n)
{
	int col, nospace;

	/* the other way... */
	if (n < 0)
		return (gotoeop(f, -n));

	while (n-- > 0) {
		nospace = 0;
		while (lback(curwp->w_dotp) != curbp->b_headp) {
			curwp->w_doto = 0;
			col = 0;

			while (col < llength(curwp->w_dotp) &&
			    (isspace(lgetc(curwp->w_dotp, col))))
				col++;

			if (col >= llength(curwp->w_dotp)) {
				if (nospace)
					break;
			} else
				nospace = 1;

			curwp->w_dotline--;
			curwp->w_dotp = lback(curwp->w_dotp);
		}
	}
	/* force screen update */
	curwp->w_rflag |= WFMOVE;
	return (TRUE);
}

/*
 * Move to end of paragraph.
 * See comments for gotobop(). Same, but moving forwards.
 */
/* ARGSUSED */
int
gotoeop(int f, int n)
{
	int i;

	return(do_gotoeop(f, n, &i));
}

int
do_gotoeop(int f, int n, int *i)
{
	int col, nospace, j = 0;

	/* the other way... */
	if (n < 0)
		return (gotobop(f, -n));

	/* for each one asked for */
	while (n-- > 0) {
		*i = ++j;
		nospace = 0;
		while (lforw(curwp->w_dotp) != curbp->b_headp) {
			col = 0;
			curwp->w_doto = 0;

			while (col < llength(curwp->w_dotp) &&
			    (isspace(lgetc(curwp->w_dotp, col))))
				col++;

			if (col >= llength(curwp->w_dotp)) {
				if (nospace)
					break;
			} else
				nospace = 1;

			curwp->w_dotp = lforw(curwp->w_dotp);
			curwp->w_dotline++;

		}
	}
	/* do not continue after end of buffer */
	if (lforw(curwp->w_dotp) == curbp->b_headp) {
		gotoeol(FFRAND, 1);
		curwp->w_rflag |= WFMOVE;
		return (FALSE);
	}

	/* force screen update */
	curwp->w_rflag |= WFMOVE;
	return (TRUE);
}

/*
 * Justify a paragraph.  Fill the current paragraph according to the current
 * fill column.
 */
/* ARGSUSED */
int
fillpara(int f, int n)
{
	int	 c;		/* current char during scan		*/
	int	 wordlen;	/* length of current word		*/
	int	 clength;	/* position on line during fill		*/
	int	 i;		/* index during word copy		*/
	int	 eopflag;	/* Are we at the End-Of-Paragraph?	*/
	int	 firstflag;	/* first word? (needs no space)		*/
	int	 newlength;	/* tentative new line length		*/
	int	 eolflag;	/* was at end of line			*/
	int	 retval;	/* return value				*/
	struct line	*eopline;	/* pointer to line just past EOP	*/
	char	 wbuf[MAXWORD];	/* buffer for current word		*/

	if (n == 0)
		return (TRUE);

	undo_boundary_enable(FFRAND, 0);

	/* record the pointer to the line just past the EOP */
	(void)gotoeop(FFRAND, 1);
	if (curwp->w_doto != 0) {
		/* paragraph ends at end of buffer */
		(void)lnewline();
		eopline = lforw(curwp->w_dotp);
	} else
		eopline = curwp->w_dotp;

	/* and back top the beginning of the paragraph */
	(void)gotobop(FFRAND, 1);

	/* initialize various info */
	while (inword() == 0 && forwchar(FFRAND, 1));

	clength = curwp->w_doto;
	wordlen = 0;

	/* scan through lines, filling words */
	firstflag = TRUE;
	eopflag = FALSE;
	while (!eopflag) {

		/* get the next character in the paragraph */
		if ((eolflag = (curwp->w_doto == llength(curwp->w_dotp)))) {
			c = ' ';
			if (lforw(curwp->w_dotp) == eopline)
				eopflag = TRUE;
		} else
			c = lgetc(curwp->w_dotp, curwp->w_doto);

		/* and then delete it */
		if (ldelete((RSIZE) 1, KNONE) == FALSE && !eopflag) {
			retval = FALSE;
			goto cleanup;
		}

		/* if not a separator, just add it in */
		if (c != ' ' && c != '\t') {
			if (wordlen < MAXWORD - 1)
				wbuf[wordlen++] = c;
			else {
				/*
				 * You lose chars beyond MAXWORD if the word
				 * is too long. I'm too lazy to fix it now; it
				 * just silently truncated the word before,
				 * so I get to feel smug.
				 */
				ewprintf("Word too long!");
			}
		} else if (wordlen) {

			/* calculate tentative new length with word added */
			newlength = clength + 1 + wordlen;

			/*
			 * if at end of line or at doublespace and previous
			 * character was one of '.','?','!' doublespace here.
			 * behave the same way if a ')' is preceded by a
			 * [.?!] and followed by a doublespace.
			 */
			if (dblspace && (!eopflag && ((eolflag ||
			    curwp->w_doto == llength(curwp->w_dotp) ||
			    (c = lgetc(curwp->w_dotp, curwp->w_doto)) == ' '
			    || c == '\t') && (ISEOSP(wbuf[wordlen - 1]) ||
			    (wbuf[wordlen - 1] == ')' && wordlen >= 2 &&
			    ISEOSP(wbuf[wordlen - 2])))) &&
			    wordlen < MAXWORD - 1))
				wbuf[wordlen++] = ' ';

			/* at a word break with a word waiting */
			if (newlength <= fillcol) {
				/* add word to current line */
				if (!firstflag) {
					(void)linsert(1, ' ');
					++clength;
				}
				firstflag = FALSE;
			} else {
				if (curwp->w_doto > 0 &&
				    lgetc(curwp->w_dotp, curwp->w_doto - 1) == ' ') {
					curwp->w_doto -= 1;
					(void)ldelete((RSIZE) 1, KNONE);
				}
				/* start a new line */
				(void)lnewline();
				clength = 0;
			}

			/* and add the word in in either case */
			for (i = 0; i < wordlen; i++) {
				(void)linsert(1, wbuf[i]);
				++clength;
			}
			wordlen = 0;
		}
	}
	/* and add a last newline for the end of our new paragraph */
	(void)lnewline();

	/*
	 * We really should wind up where we started, (which is hard to keep
	 * track of) but I think the end of the last line is better than the
	 * beginning of the blank line.
	 */
	(void)backchar(FFRAND, 1);
	retval = TRUE;
cleanup:
	undo_boundary_enable(FFRAND, 1);
	return (retval);
}

/*
 * Delete n paragraphs. Move to the beginning of the current paragraph, or if
 * the cursor is on an empty line, move down the buffer to the first line with
 * non-space characters. Then mark n paragraphs and delete.
 */
/* ARGSUSED */
int
killpara(int f, int n)
{
	int	lineno, status;

	if (n == 0)
		return (TRUE);

	if (findpara() == FALSE)
		return (TRUE);

	/* go to the beginning of the paragraph */
	(void)gotobop(FFRAND, 1);

	/* take a note of the line number for after deletions and set mark */
	lineno = curwp->w_dotline;
	curwp->w_markp = curwp->w_dotp;
	curwp->w_marko = curwp->w_doto;

	(void)gotoeop(FFRAND, n);

	if ((status = killregion(FFRAND, 1)) != TRUE)
		return (status);

	curwp->w_dotline = lineno;
	return (TRUE);
}

/*
 * Mark n paragraphs starting with the n'th and working our way backwards.
 * This leaves the cursor at the beginning of the paragraph where markpara()
 * was invoked.
 */
/* ARGSUSED */
int
markpara(int f, int n)
{
	int i = 0;

	if (n == 0)
		return (TRUE);

	clearmark(FFARG, 0);

	if (findpara() == FALSE)
		return (TRUE);

	(void)do_gotoeop(FFRAND, n, &i);

	/* set the mark here */
	curwp->w_markp = curwp->w_dotp;
	curwp->w_marko = curwp->w_doto;

	(void)gotobop(FFRAND, i);

	return (TRUE);
}

/*
 * Transpose the current paragraph with the following paragraph. If invoked
 * multiple times, transpose to the n'th paragraph. If invoked between 
 * paragraphs, move to the previous paragraph, then continue.
 */
/* ARGSUSED */
int
transposepara(int f, int n)
{
	int	i = 0, status;
	char	flg;

	if (n == 0)
		return (TRUE);

	/* find a paragraph, set mark, then goto the end */
	gotobop(FFRAND, 1);
	curwp->w_markp = curwp->w_dotp;
	curwp->w_marko = curwp->w_doto;
	(void)gotoeop(FFRAND, 1);

	/* take a note of buffer flags - we may need them */
	flg = curbp->b_flag;	

	/* clean out kill buffer then kill region */
	kdelete();
	if ((status = killregion(FFRAND, 1)) != TRUE)
		return (status);

	/* 
	 * Now step through n paragraphs. If we reach the end of buffer,
	 * stop and paste the killed region back, then display a message.
	 */
	if (do_gotoeop(FFRAND, n, &i) == FALSE) {
		ewprintf("Cannot transpose paragraph, end of buffer reached.");
		(void)gotobop(FFRAND, i);
		(void)yank(FFRAND, 1);
		curbp->b_flag = flg;	
		return (FALSE);
	}
	(void)yank(FFRAND, 1);

	return (TRUE);
}

/*
 * Go down the buffer until we find a line with non-space characters.
 */
int
findpara(void)
{
	int	col, nospace = 0;

	/* we move forward to find a para to mark */
	do {
		curwp->w_doto = 0;
		col = 0;

		/* check if we are on a blank line */
		while (col < llength(curwp->w_dotp)) {
			if (!isspace(lgetc(curwp->w_dotp, col)))
				nospace = 1;
			col++;
		}
		if (nospace)
			break;

		if (lforw(curwp->w_dotp) == curbp->b_headp)
			return (FALSE);

		curwp->w_dotp = lforw(curwp->w_dotp);	
		curwp->w_dotline++;
	} while (1);

	return (TRUE);
}

/*
 * Insert char with work wrap.  Check to see if we're past fillcol, and if so,
 * justify this line.  As a last step, justify the line.
 */
/* ARGSUSED */
int
fillword(int f, int n)
{
	char	c;
	int	col, i, nce;

	for (i = col = 0; col <= fillcol; ++i, ++col) {
		if (i == curwp->w_doto)
			return selfinsert(f, n);
		c = lgetc(curwp->w_dotp, i);
		if (c == '\t'
#ifdef NOTAB
		    && !(curbp->b_flag & BFNOTAB)
#endif
			)
			col |= 0x07;
		else if (ISCTRL(c) != FALSE)
			++col;
	}
	if (curwp->w_doto != llength(curwp->w_dotp)) {
		(void)selfinsert(f, n);
		nce = llength(curwp->w_dotp) - curwp->w_doto;
	} else
		nce = 0;
	curwp->w_doto = i;

	if ((c = lgetc(curwp->w_dotp, curwp->w_doto)) != ' ' && c != '\t')
		do {
			(void)backchar(FFRAND, 1);
		} while ((c = lgetc(curwp->w_dotp, curwp->w_doto)) != ' ' &&
		    c != '\t' && curwp->w_doto > 0);

	if (curwp->w_doto == 0)
		do {
			(void)forwchar(FFRAND, 1);
		} while ((c = lgetc(curwp->w_dotp, curwp->w_doto)) != ' ' &&
		    c != '\t' && curwp->w_doto < llength(curwp->w_dotp));

	(void)delwhite(FFRAND, 1);
	(void)lnewline();
	i = llength(curwp->w_dotp) - nce;
	curwp->w_doto = i > 0 ? i : 0;
	curwp->w_rflag |= WFMOVE;
	if (nce == 0 && curwp->w_doto != 0)
		return (fillword(f, n));
	return (TRUE);
}

/*
 * Set fill column to n for justify.
 */
int
setfillcol(int f, int n)
{
	char buf[32], *rep;
	const char *es;
	int nfill;

	if ((f & FFARG) != 0) {
		fillcol = n;
	} else {
		if ((rep = eread("Set fill-column: ", buf, sizeof(buf),
		    EFNEW | EFCR)) == NULL)
			return (ABORT);
		else if (rep[0] == '\0')
			return (FALSE);
		nfill = strtonum(rep, 0, INT_MAX, &es);
		if (es != NULL) {
			dobeep();
			ewprintf("Invalid fill column: %s", rep);
			return (FALSE);
		}
		fillcol = nfill;
		ewprintf("Fill column set to %d", fillcol);
	}
	return (TRUE);
}

int
sentencespace(int f, int n)
{
	if (f & FFARG)
		dblspace = n > 1;
	else
		dblspace = !dblspace;

	return (TRUE);
}
@


1.44
log
@Add 'sentence-end-double-space'.

If you prefer "lighter" punctuation and one space between sentences,
for example:

Mr and Mrs Jones are from the UK. They arrived today.

over more liberal use of full stops and double spaces between
sentences:

Mr. and Mrs. Jones are from the U.K.  They arrived today.

then toggling 'sentence-end-double-space' will make mg's
fill-paragraph function format text using one space instead of two
(the default) between sentences. However, be careful, should you have
a double spaced document and accidentally "format" it to have single
spaces, then you may have a problem. mg won't be able to revert the
formatting for you (unless you have a previous version of the text in
the "undo" history, or are using mg's backup facility and haven't
opened and saved multiple times!).

Comments from schwarze@@
@
text
@d1 1
a1 1
/*	$OpenBSD: paragraph.c,v 1.43 2016/04/12 06:20:50 lum Exp $	*/
a110 6
			/* do not continue after end of buffer */
			if (lforw(curwp->w_dotp) == curbp->b_headp) {
				gotoeol(FFRAND, 1);
				curwp->w_rflag |= WFMOVE;
				return (FALSE);
			}
d112 6
@


1.43
log
@Stop mg putting a space at the end of a paragraph when using
fill-paragraph.  Reported by Harald Dunkel.
@
text
@d1 1
a1 1
/*	$OpenBSD: paragraph.c,v 1.42 2015/12/14 03:25:59 mmcc Exp $	*/
d211 1
a211 1
			if (!eopflag && ((eolflag ||
d216 1
a216 1
			    ISEOSP(wbuf[wordlen - 2]))) &&
d483 11
@


1.42
log
@s/begining/beginning/g
@
text
@d1 1
a1 1
/*	$OpenBSD: paragraph.c,v 1.41 2015/10/10 09:13:14 lum Exp $	*/
d211 1
a211 1
			if ((eolflag ||
d217 1
a217 1
			    wordlen < MAXWORD - 1)
@


1.41
log
@Make functions that accept multiple iterations via C-u N, honour 0.
Except C-k which has a defined behaviour. In mg, C-t doesn't complete
n iterations if requested, but probably should, hence it has been
included in this diff.
@
text
@d1 1
a1 1
/*	$OpenBSD: paragraph.c,v 1.40 2015/09/26 15:03:15 lum Exp $	*/
d159 1
a159 1
	/* and back top the begining of the paragraph */
@


1.40
log
@Add transpose-paragraphs. ok jasper@@
@
text
@d1 1
a1 1
/*	$OpenBSD: paragraph.c,v 1.39 2015/09/24 07:20:12 lum Exp $	*/
d145 3
d273 3
d307 3
d337 3
@


1.39
log
@Make comments more accurate.
@
text
@d1 1
a1 1
/*	$OpenBSD: paragraph.c,v 1.38 2015/09/24 07:07:59 lum Exp $	*/
d313 42
@


1.38
log
@Add mark-paragraph. ok jasper@@
@
text
@d1 1
a1 1
/*	$OpenBSD: paragraph.c,v 1.37 2015/09/24 01:24:10 lum Exp $	*/
d260 3
a262 1
 * Delete a paragraph.  Delete n paragraphs starting with the current one.
d291 1
a291 1
 * Mark n paragraphs starting with the last one and working our way backwards.
d318 1
a318 1
 * Go down the buffer until we find text.
@


1.37
log
@Fix multiple iterations of kill-paragraph. ok jasper@@
@
text
@d1 1
a1 1
/*	$OpenBSD: paragraph.c,v 1.36 2015/03/19 21:22:15 bcallah Exp $	*/
d24 1
d76 9
a84 1
	int col, nospace;
d92 1
d285 27
@


1.36
log
@Clean up the includes in mg.
This does the following:
Moves all POSIX headers from sysdef.h into the individual .c files so that
each file now only includes what it needs. All headers are properly sorted.
Moves the remainder of sysdef.h to other files (mostly def.h) and deletes
sysdef.h now that it's no longer contains anything.
Tweak a comment that references sysdef.h so that it no longer does that.
ok florian@@
@
text
@d1 1
a1 1
/*	$OpenBSD: paragraph.c,v 1.35 2014/11/16 04:16:41 guenther Exp $	*/
d23 2
d256 7
a262 1
	int	status, end = FALSE;	/* returned status of functions */
d264 4
a267 2
	/* for each paragraph to delete */
	while (n--) {
d269 1
a269 3
		/* mark out the end and beginning of the para to delete */
		if (!gotoeop(FFRAND, 1))
			end = TRUE;
d271 2
a272 3
		/* set the mark here */
		curwp->w_markp = curwp->w_dotp;
		curwp->w_marko = curwp->w_doto;
d274 11
a284 2
		/* go to the beginning of the paragraph */
		(void)gotobop(FFRAND, 1);
d286 2
a287 1
		/* force us to the beginning of line */
d289 10
d300 6
a305 3
		/* and delete it */
		if ((status = killregion(FFRAND, 1)) != TRUE)
			return (status);
a306 3
		if (end)
			return (TRUE);
	}
@


1.35
log
@Stop using <sys/param.h>; replace MAXPATHLEN with PATH_MAX, stop using MAX(),
and pull in <limits.h> for *_MAX constants.

inspired on a diff from Kamil Rytarowski (n54 (at) gmx.com)
ok bcallah@@
@
text
@d1 1
a1 1
/*	$OpenBSD: paragraph.c,v 1.34 2014/10/17 13:25:13 lum Exp $	*/
d10 1
d13 3
@


1.34
log
@If gotoeop() is called requiring more than one iteration, it behaves
oddly if it reaches the end of buffer before completing all
iterations. This diff makes the kill-paragraph and forward-paragraph
commands stop once they can go no further. ok florian@@
@
text
@d1 1
a1 1
/*	$OpenBSD: paragraph.c,v 1.33 2014/10/13 21:01:05 lum Exp $	*/
d11 1
@


1.33
log
@gotoeop() does not behave as expected when there is no '\n' at the end of the
buffer. ok florian@@
@
text
@d1 1
a1 1
/*	$OpenBSD: paragraph.c,v 1.32 2014/10/12 18:09:41 lum Exp $	*/
d93 7
a101 3
	/* covers corner case of no '\n' at end of buffer */
	if (lforw(curwp->w_dotp) == curbp->b_headp)
		gotoeol(FFRAND, 1);
d249 1
a249 1
	int	status;		/* returned status of functions */
d255 2
a256 1
		(void)gotoeop(FFRAND, 1);
d271 3
@


1.32
log
@Fix a bug in backward-paragraph. If the cursor is on the first line of
a paragraph, it jumps to the start of the previous paragraph if you
press M-{. Input and fix to my diff from florian@@
@
text
@d1 1
a1 1
/*	$OpenBSD: paragraph.c,v 1.31 2014/03/27 09:30:55 florian Exp $	*/
d95 4
@


1.31
log
@Don't use nospace uninitialized in gotobop and gotoeop.
Problem noticed and diff from bcallah@@.
Slightly different fix by me.
OK lum@@, bcallah@@
@
text
@d1 1
a1 1
/*	$OpenBSD: paragraph.c,v 1.30 2014/03/20 07:47:29 lum Exp $	*/
a37 2
			curwp->w_dotp = lback(curwp->w_dotp);
			curwp->w_dotline--;
d50 3
@


1.30
log
@Add some missing dobeeps.
ok florian@@
@
text
@d1 1
a1 1
/*	$OpenBSD: paragraph.c,v 1.29 2013/06/15 19:58:39 lum Exp $	*/
d36 1
a52 1
		nospace = 0;
d75 1
a92 1
		nospace = 0;
@


1.29
log
@Move upwards passed multiple lines with no characters instead of
stopping when first line with no characters is found.
@
text
@d1 1
a1 1
/*	$OpenBSD: paragraph.c,v 1.28 2013/06/01 14:27:32 lum Exp $	*/
d338 1
@


1.28
log
@Make 'kill-paragraph' behave like emacs. ok florian@@
@
text
@d1 1
a1 1
/*	$OpenBSD: paragraph.c,v 1.27 2013/06/01 10:23:40 lum Exp $	*/
d52 1
@


1.27
log
@Update the forw/backpara comments to reflect recent changes.
@
text
@d1 1
a1 1
/*	$OpenBSD: paragraph.c,v 1.26 2013/06/01 09:50:47 lum Exp $	*/
a259 3

		/* and clean up the 2 extra lines */
		(void)ldelete((RSIZE) 1, KFORW);
@


1.26
log
@tidy-up int declarations as suggested by florian@@
@
text
@d1 1
a1 1
/*	$OpenBSD: paragraph.c,v 1.25 2013/06/01 09:46:31 lum Exp $	*/
d19 5
a23 3
 * Move to start of paragraph.  Go back to the beginning of the current
 * paragraph here we look for a <NL><NL> or <NL><TAB> or <NL><SPACE>
 * combination to delimit the beginning of a paragraph.
d59 2
a60 3
 * Move to end of paragraph.  Go forward to the end of the current paragraph
 * here we look for a <NL><NL> or <NL><TAB> or <NL><SPACE> combination to
 * delimit the beginning of a paragraph.
@


1.25
log
@Adjust M-} (forward-paragraph) to behave like emacs.
Bug fix and ok florian@@
@
text
@d1 1
a1 1
/*	$OpenBSD: paragraph.c,v 1.24 2013/05/19 10:27:11 lum Exp $	*/
d27 1
a27 2
	int col;
	int nospace = 0;
d65 1
a65 2
	int col;
	int nospace;
@


1.24
log
@Make the cursor position when moving backwards by paragraph behave the
same as emacs: move to line above paragraph. ok florian@@
@
text
@d1 1
a1 1
/*	$OpenBSD: paragraph.c,v 1.23 2013/02/17 15:42:21 lum Exp $	*/
d66 3
d75 11
a85 15
		/* Find the first word on/after the current line */
		curwp->w_doto = 0;
		while (forwchar(FFRAND, 1) && inword() == 0);

		curwp->w_doto = 0;
		curwp->w_dotp = lforw(curwp->w_dotp);

		/* and scan forword until we hit a <NL><SP> or ... */
		while (curwp->w_dotp != curbp->b_headp) {
			if (llength(curwp->w_dotp) &&
			    lgetc(curwp->w_dotp, 0) != ' ' &&
			    lgetc(curwp->w_dotp, 0) != '.' &&
			    lgetc(curwp->w_dotp, 0) != '\t') {
				curwp->w_dotp = lforw(curwp->w_dotp);
				curwp->w_dotline++;
d87 4
a90 1
				break;
d92 1
a92 7
		if (curwp->w_dotp == curbp->b_headp) {
			/* beyond end of buffer, cleanup time */
			curwp->w_dotp = lback(curwp->w_dotp);
			curwp->w_doto = llength(curwp->w_dotp);
			break;
		} else
			curwp->w_dotline++;
@


1.23
log
@Fix line counting when using forward-paragraph and backward-paragraph.
Feedback and ok florian@@
@
text
@d1 1
a1 1
/*	$OpenBSD: paragraph.c,v 1.22 2011/11/29 05:59:54 lum Exp $	*/
d10 2
d27 3
d35 16
a50 25
		/* first scan back until we are in a word */
		while (backchar(FFRAND, 1) && inword() == 0);

		/* and go to the B-O-Line */
		curwp->w_doto = 0;

		/*
		 * and scan back until we hit a <NL><SP> <NL><TAB> or
		 * <NL><NL>
		 */
		while (lback(curwp->w_dotp) != curbp->b_headp)
			if (llength(lback(curwp->w_dotp)) &&
			    lgetc(curwp->w_dotp, 0) != ' ' &&
			    lgetc(curwp->w_dotp, 0) != '.' &&
			    lgetc(curwp->w_dotp, 0) != '\t') {
				curwp->w_dotp = lback(curwp->w_dotp);
				curwp->w_dotline--;
			} else {
				if (llength(lback(curwp->w_dotp)) &&
				    lgetc(curwp->w_dotp, 0) == '.') {
					curwp->w_dotp = lforw(curwp->w_dotp);
					curwp->w_dotline++;	 
				}
				break;
			}
@


1.22
log
@Missing wordlen check from version 1.20. Spotted by matthew@@
@
text
@d1 1
a1 1
/*	$OpenBSD: paragraph.c,v 1.21 2011/11/28 23:37:32 matthew Exp $	*/
d44 1
a44 1
			    lgetc(curwp->w_dotp, 0) != '\t')
d46 2
a47 1
			else {
d51 1
a51 10
					if (curwp->w_dotp == curbp->b_headp) {
						/*
						 * beyond end of buffer,
						 * cleanup time
						 */
						curwp->w_dotp =
						    lback(curwp->w_dotp);
						curwp->w_doto =
						    llength(curwp->w_dotp);
					}
d88 1
a88 1
			    lgetc(curwp->w_dotp, 0) != '\t')
d90 2
a91 1
			else
d99 2
a100 1
		}
@


1.21
log
@Fix a few grating comment typos.
@
text
@d1 1
a1 1
/*	$OpenBSD: paragraph.c,v 1.20 2011/11/28 05:04:17 lum Exp $	*/
d200 1
a200 1
			    (wbuf[wordlen - 1] == ')' && 
@


1.20
log
@Change behaviour of M-q (fill-paragraph) to allow
double-space after /[.?!]\)?/

From a diff sent to tech@@ by Matthew Dempsky some
months ago.
@
text
@d1 1
a1 1
/*	$OpenBSD: paragraph.c,v 1.19 2009/06/04 02:23:37 kjell Exp $	*/
d178 2
a179 2
				 * You loose chars beyond MAXWORD if the word
				 * is to long. I'm to lazy to fix it now; it
@


1.19
log
@Rename w_flag to w_rflag. This is not a general purpose
flag: it is for redisplay options only. I need an additional all-purpose
flag, so renaming removes the desire to wrongly overload the existing one.

Turdshine. No functional chage.
@
text
@d1 1
a1 1
/*	$OpenBSD: paragraph.c,v 1.18 2009/06/02 21:55:25 kjell Exp $	*/
d193 2
d199 3
a201 1
			    || c == '\t') && ISEOSP(wbuf[wordlen - 1]) &&
@


1.18
log
@we were erroneously setting fill-column, even when the input
to set-fill-column was garbage. (common, since they keystroke is
so close to find-file). Fix!
@
text
@d1 1
a1 1
/*	$OpenBSD: paragraph.c,v 1.17 2008/09/15 16:13:35 kjell Exp $	*/
d65 1
a65 1
	curwp->w_flag |= WFMOVE;
d109 1
a109 1
	curwp->w_flag |= WFMOVE;
d325 1
a325 1
	curwp->w_flag |= WFMOVE;
@


1.17
log
@Expose the undo commands as proper mg functions.
This should have no functional change on undo, but it does facilitate
testing undo behavior.
@
text
@d1 1
a1 1
/*	$OpenBSD: paragraph.c,v 1.16 2008/06/12 21:36:47 kjell Exp $	*/
d339 1
d349 3
a351 2
		fillcol = strtonum(rep, 0, INT_MAX, &es);
		if (es != NULL)
d353 2
@


1.16
log
@Make set-fill-column interactive (and scriptable in a startup file)
This replaces the ridiculous "move cursor to where you want to wrap things
and invoke this comment" behavior of before.

Note, this makes auto-fill-mode the moral equivalent of mail-mode.
(and set-fill-column the moral equivalent of mail-set-margin)
@
text
@d1 1
a1 1
/*	$OpenBSD: paragraph.c,v 1.15 2006/11/17 08:45:31 kjell Exp $	*/
d133 1
a133 2
	undo_add_boundary();
	undo_boundary_enable(FALSE);
d239 1
a239 2
	undo_boundary_enable(TRUE);
	undo_add_boundary();
@


1.15
log
@Fix a needless inversion of flag names; i.e. change them from the
negative to the positive. undo_boundary_enable(TRUE) makes a LOT more
sense than undo_no_boundary(FALSE).
While here, whack a global, and fix a bug noted by otto:
undoing a file insertion sometimes left stray characters around.
ok beck@@, otto@@
@
text
@d1 1
a1 1
/*	$OpenBSD: paragraph.c,v 1.14 2006/07/25 08:22:32 kjell Exp $	*/
d339 16
a354 2
	fillcol = ((f & FFARG) ? n : getcolpos());
	ewprintf("Fill column set to %d", fillcol);
@


1.14
log
@Rename the header line of a buffer to b_headp, from the remarkably
unintuitive b_linep. No binary change.
@
text
@d1 1
a1 1
/*	$OpenBSD: paragraph.c,v 1.13 2005/11/18 20:56:53 deraadt Exp $	*/
d134 1
a134 1
	undo_no_boundary(TRUE);
d240 1
a240 1
	undo_no_boundary(FALSE);
@


1.13
log
@greedy use of typedef struct was making code harder to read; ok kjell cloder
@
text
@d1 1
a1 1
/*	$OpenBSD: paragraph.c,v 1.12 2005/10/18 18:54:48 kjell Exp $	*/
d40 1
a40 1
		while (lback(curwp->w_dotp) != curbp->b_linep)
d50 1
a50 1
					if (curwp->w_dotp == curbp->b_linep) {
d92 1
a92 1
		while (curwp->w_dotp != curbp->b_linep) {
d101 1
a101 1
		if (curwp->w_dotp == curbp->b_linep) {
@


1.12
log
@make fill-paragraph undoable
@
text
@d1 1
a1 1
/*	$OpenBSD: paragraph.c,v 1.11 2005/06/14 18:14:40 kjell Exp $	*/
d130 1
a130 1
	LINE	*eopline;	/* pointer to line just past EOP	*/
@


1.11
log
@Add explicit public domain notices to all public domain files.
ok millert@@, deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: paragraph.c,v 1.10 2005/04/03 02:09:28 db Exp $	*/
d129 1
d133 3
d168 4
a171 2
		if (ldelete((RSIZE) 1, KNONE) == FALSE && !eopflag)
			return (FALSE);
d238 5
a242 1
	return (TRUE);
@


1.10
log
@This is a no binary change which does:

- spelling, punctuation fixes
- variable declaration lineup
- use parentheses for return and sizeof
- K&R function declarations -> ANSI
- other minor code beautification

ok henning@@
@
text
@d1 3
a3 1
/*	$OpenBSD: paragraph.c,v 1.9 2003/10/24 20:32:06 avsm Exp $	*/
@


1.9
log
@dont compare int to NULL, millert@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: paragraph.c,v 1.8 2003/05/20 03:08:55 cloder Exp $	*/
d15 1
a15 1
 * Move to start of paragraph.  Go back to the begining of the current
d17 1
a17 1
 * combination to delimit the begining of a paragraph.
d25 1
a25 1
		return gotoeop(f, -n);
d50 1
a50 1
						 * beond end of buffer,
d64 1
a64 1
	return TRUE;
d68 1
a68 1
 * Move to end of paragraph.  Go forword to the end of the current paragraph
d70 1
a70 1
 * delimit the begining of a paragraph.
d78 1
a78 1
		return gotobop(f, -n);
d100 1
a100 1
			/* beond end of buffer, cleanup time */
d108 1
a108 1
	return TRUE;
d119 1
a119 1
	int	 c;		/* current char durring scan		*/
d163 1
a163 1
			return FALSE;
d180 1
a180 1
			/* calculate tenatitive new length with word added */
d225 1
a225 1
	 * we realy should wind up where we started, (which is hard to keep
d227 1
a227 1
	 * begining of the blank line.
d230 1
a230 1
	return TRUE;
d245 1
a245 1
		/* mark out the end and begining of the para to delete */
d252 1
a252 1
		/* go to the begining of the paragraph */
d260 1
a260 1
			return status;
d265 1
a265 1
	return TRUE;
d317 2
a318 2
		return fillword(f, n);
	return TRUE;
d329 1
a329 1
	return TRUE;
@


1.8
log
@Finish KNF of prototypes.  That should be all of them.
OK vincent@@
@
text
@d1 1
a1 1
/*	$OpenBSD: paragraph.c,v 1.7 2002/02/14 14:24:21 deraadt Exp $	*/
d29 1
a29 1
		while (backchar(FFRAND, 1) && inword() == NULL);
d84 1
a84 1
		while (forwchar(FFRAND, 1) && inword() == NULL);
d143 1
a143 1
	while (inword() == NULL && forwchar(FFRAND, 1));
@


1.7
log
@some KNF
@
text
@d1 1
a1 1
/*	$OpenBSD: paragraph.c,v 1.6 2001/05/24 03:05:25 mickey Exp $	*/
d21 1
a21 2
gotobop(f, n)
	int f, n;
d74 1
a74 2
gotoeop(f, n)
	int f, n;
d117 1
a117 2
fillpara(f, n)
	int f, n;
d238 1
a238 2
killpara(f, n)
	int f, n;
d274 1
a274 2
fillword(f, n)
	int f, n;
d325 1
a325 2
setfillcol(f, n)
	int f, n;
@


1.6
log
@spaces
@
text
@d1 1
a1 1
/*	$OpenBSD: paragraph.c,v 1.5 2001/05/23 22:20:36 art Exp $	*/
d40 4
a43 4
			if (llength(lback(curwp->w_dotp))
			    && lgetc(curwp->w_dotp, 0) != ' '
			    && lgetc(curwp->w_dotp, 0) != '.'
			    && lgetc(curwp->w_dotp, 0) != '\t')
d46 2
a47 2
				if (llength(lback(curwp->w_dotp))
				    && lgetc(curwp->w_dotp, 0) == '.') {
d93 4
a96 4
			if (llength(curwp->w_dotp)
			    && lgetc(curwp->w_dotp, 0) != ' '
			    && lgetc(curwp->w_dotp, 0) != '.'
			    && lgetc(curwp->w_dotp, 0) != '\t')
d307 2
a308 2
		} while ((c = lgetc(curwp->w_dotp, curwp->w_doto)) != ' '
		    && c != '\t' && curwp->w_doto > 0);
d313 2
a314 2
		} while ((c = lgetc(curwp->w_dotp, curwp->w_doto)) != ' '
		    && c != '\t' && curwp->w_doto < llength(curwp->w_dotp));
@


1.5
log
@remove VOID. We're way beyond the point where this could build with an
ancient compiler.
@
text
@d1 1
a1 1
/*	$OpenBSD: paragraph.c,v 1.4 2001/01/29 01:58:09 niklas Exp $	*/
d15 2
a16 2
 * Move to start of paragraph.  Go back to the begining of the current 
 * paragraph here we look for a <NL><NL> or <NL><TAB> or <NL><SPACE> 
d54 1
a54 1
						curwp->w_dotp = 
d56 1
a56 1
						curwp->w_doto = 
d69 2
a70 2
 * Move to end of paragraph.  Go forword to the end of the current paragraph 
 * here we look for a <NL><NL> or <NL><TAB> or <NL><SPACE> combination to 
d114 1
a114 1
 * Justify a paragraph.  Fill the current paragraph according to the current 
d190 2
a191 2
			if ((eolflag || 
			    curwp->w_doto == llength(curwp->w_dotp) || 
d193 1
a193 1
			    || c == '\t') && ISEOSP(wbuf[wordlen - 1]) && 
d236 1
a236 1
/* 
@


1.4
log
@$OpenBSD$
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d134 1
a134 1
	(VOID)gotoeop(FFRAND, 1);
d137 1
a137 1
		(VOID)lnewline();
d143 1
a143 1
	(VOID)gotobop(FFRAND, 1);
d201 1
a201 1
					(VOID)linsert(1, ' ');
d209 1
a209 1
					(VOID)ldelete((RSIZE) 1, KNONE);
d212 1
a212 1
				(VOID)lnewline();
d218 1
a218 1
				(VOID)linsert(1, wbuf[i]);
d225 1
a225 1
	(VOID)lnewline();
d232 1
a232 1
	(VOID)backchar(FFRAND, 1);
d250 1
a250 1
		(VOID)gotoeop(FFRAND, 1);
d257 1
a257 1
		(VOID)gotobop(FFRAND, 1);
d267 1
a267 1
		(VOID)ldelete((RSIZE) 1, KFORW);
d298 1
a298 1
		(VOID)selfinsert(f, n);
d306 1
a306 1
			(VOID)backchar(FFRAND, 1);
d312 1
a312 1
			(VOID)forwchar(FFRAND, 1);
d316 2
a317 2
	(VOID)delwhite(FFRAND, 1);
	(VOID)lnewline();
@


1.3
log
@More -Wall anmd KNF, from op2@@tomahawk.SQUiSH.org
@
text
@d1 2
@


1.2
log
@The start of KNF + -Wall.  The code has been run through indent but
needs hand fixup.  I stopped at keymap.c...
@
text
@d5 1
d8 2
a9 1
static int      fillcol = 70;
d13 3
a15 3
 * go back to the begining of the current paragraph
 * here we look for a <NL><NL> or <NL><TAB> or <NL><SPACE>
 * combination to delimit the begining of a paragraph
d18 1
d20 1
d22 2
a23 1
	if (n < 0)		/* the other way... */
d26 1
a26 2
	while (n-- > 0) {	/* for each one asked for */

d28 1
d30 2
a31 3
		while (backchar(FFRAND, 1) && !inword()) {
		}
		curwp->w_doto = 0;	/* and go to the B-O-Line */
d52 4
a55 2
						curwp->w_dotp = lback(curwp->w_dotp);
						curwp->w_doto = llength(curwp->w_dotp);
d61 2
a62 1
	curwp->w_flag |= WFMOVE;/* force screen update */
d67 3
a69 3
 * go forword to the end of the current paragraph
 * here we look for a <NL><NL> or <NL><TAB> or <NL><SPACE>
 * combination to delimit the begining of a paragraph
d72 1
d74 1
d76 2
a77 1
	if (n < 0)		/* the other way... */
d80 2
a81 2
	while (n-- > 0) {	/* for each one asked for */

d84 2
a85 2
		while (forwchar(FFRAND, 1) && !inword()) {
		}
d88 1
d106 2
a107 1
	curwp->w_flag |= WFMOVE;/* force screen update */
d112 2
a113 2
 * Fill the current paragraph according to the current
 * fill column
d116 1
d118 1
d120 10
a129 10
	register int    c;	/* current char durring scan	 */
	register int    wordlen;/* length of current word	 */
	register int    clength;/* position on line during fill */
	register int    i;	/* index during word copy	 */
	register int    eopflag;/* Are we at the End-Of-Paragraph? */
	int             firstflag;	/* first word? (needs no space) */
	int             newlength;	/* tentative new line length	 */
	int             eolflag;/* was at end of line		 */
	LINE           *eopline;/* pointer to line just past EOP */
	char            wbuf[MAXWORD];	/* buffer for current word	 */
d132 1
a132 1
	(VOID) gotoeop(FFRAND, 1);
d135 1
a135 1
		(VOID) lnewline();
d141 1
a141 1
	(VOID) gotobop(FFRAND, 1);
d144 2
a145 2
	while (!inword() && forwchar(FFRAND, 1)) {
	}
d153 1
d155 1
a155 1
		if (eolflag = (curwp->w_doto == llength(curwp->w_dotp))) {
d180 1
d183 1
d188 5
a192 5
			if ((eolflag || curwp->w_doto == llength(curwp->w_dotp)
			 || (c = lgetc(curwp->w_dotp, curwp->w_doto)) == ' '
			     || c == '\t')
			    && ISEOSP(wbuf[wordlen - 1])
			    && wordlen < MAXWORD - 1)
d194 1
d199 1
a199 1
					(VOID) linsert(1, ' ');
d207 1
a207 1
					(VOID) ldelete((RSIZE) 1, KNONE);
d210 1
a210 1
				(VOID) lnewline();
d216 1
a216 1
				(VOID) linsert(1, wbuf[i]);
d223 2
a224 1
	(VOID) lnewline();
d230 1
a230 1
	(VOID) backchar(FFRAND, 1);
d234 3
a236 1
/* delete n paragraphs starting with the current one */
d238 1
d240 1
d242 1
a242 1
	register int    status;	/* returned status of functions */
d244 2
a245 1
	while (n--) {		/* for each paragraph to delete */
d248 1
a248 1
		(VOID) gotoeop(FFRAND, 1);
d255 4
a258 2
		(VOID) gotobop(FFRAND, 1);
		curwp->w_doto = 0;	/* force us to the begining of line */
d265 1
a265 1
		(VOID) ldelete((RSIZE) 1, KFORW);
d271 2
a272 2
 * check to see if we're past fillcol, and if so,
 * justify this line. As a last step, justify the line.
d275 1
d277 1
d279 2
a280 2
	register char   c;
	register int    col, i, nce;
d287 1
a287 1
#ifdef	NOTAB
d296 1
a296 1
		(VOID) selfinsert(f, n);
d304 1
a304 1
			(VOID) backchar(FFRAND, 1);
d306 1
a306 1
			 && c != '\t' && curwp->w_doto > 0);
d310 1
a310 1
			(VOID) forwchar(FFRAND, 1);
d314 2
a315 2
	(VOID) delwhite(FFRAND, 1);
	(VOID) lnewline();
d324 4
a327 1
/* Set fill column to n. */
d329 1
a330 2
	extern int      getcolpos();

@


1.1
log
@initial import of mg2a
@
text
@d7 1
a7 1
static int	fillcol = 70 ;
d15 1
a15 1
/*ARGSUSED*/
d18 1
a18 1
	if (n < 0)	/* the other way...*/
d24 3
a26 2
		
		while (backchar(FFRAND, 1) && !inword()) {}
d29 4
a32 1
		/* and scan back until we hit a <NL><SP> <NL><TAB> or <NL><NL> */
d35 3
a37 3
			    && lgetc(curwp->w_dotp,0) != ' '
			    && lgetc(curwp->w_dotp,0) != '.'
			    && lgetc(curwp->w_dotp,0) != '\t')
d40 14
a53 11
		          if (llength(lback(curwp->w_dotp))
		  	      && lgetc(curwp->w_dotp,0) == '.') {
			    curwp->w_dotp = lforw(curwp->w_dotp);
			    if(curwp->w_dotp == curbp->b_linep) {
			      /* beond end of buffer, cleanup time */
		 	      curwp->w_dotp = lback(curwp->w_dotp);
			      curwp->w_doto = llength(curwp->w_dotp);
			    }
		          }
			  break;
		        }
d55 1
a55 1
	curwp->w_flag |= WFMOVE;	/* force screen update */
d64 1
a64 1
/*ARGSUSED*/
d67 1
a67 1
	if (n < 0)	/* the other way...*/
d74 2
a75 1
		while(forwchar(FFRAND, 1) && !inword()) {}
d81 3
a83 3
			    && lgetc(curwp->w_dotp,0) != ' '
			    && lgetc(curwp->w_dotp,0) != '.'
			    && lgetc(curwp->w_dotp,0) != '\t')
d88 1
a88 1
		if(curwp->w_dotp == curbp->b_linep) {
d92 1
a92 1
			break;			
d95 1
a95 1
	curwp->w_flag |= WFMOVE;	/* force screen update */
d103 1
a103 1
/*ARGSUSED*/
d106 10
a115 10
	register int	c;		/* current char durring scan	*/
	register int	wordlen;	/* length of current word	*/
	register int	clength;	/* position on line during fill */
	register int	i;		/* index during word copy	*/
	register int	eopflag;	/* Are we at the End-Of-Paragraph? */
	int		firstflag;	/* first word? (needs no space) */
	int		newlength;	/* tentative new line length	*/
	int		eolflag;	/* was at end of line		*/
	LINE		*eopline;	/* pointer to line just past EOP */
	char wbuf[MAXWORD];		/* buffer for current word	*/
d119 1
a119 1
	if(curwp->w_doto != 0)	{
d123 2
a124 1
	} else	eopline = curwp->w_dotp;
d130 2
a131 1
	while (!inword() && forwchar(FFRAND, 1)) {}
d140 1
a140 1
		if (eolflag=(curwp->w_doto == llength(curwp->w_dotp))) {
d156 2
a157 1
				/* You loose chars beyond MAXWORD if the word
d159 2
a160 2
				 * just silently truncated the word before, so
				 * I get to feel smug.
d167 2
a168 1
			/* if at end of line or at doublespace and previous
d171 5
a175 5
			if((eolflag || curwp->w_doto==llength(curwp->w_dotp)
			    || (c=lgetc(curwp->w_dotp,curwp->w_doto))==' '
			    || c=='\t')
			  && ISEOSP(wbuf[wordlen-1])
			  && wordlen<MAXWORD-1)
d186 2
a187 2
				if(curwp->w_doto > 0 &&
				    lgetc(curwp->w_dotp,curwp->w_doto-1)==' ') {
d197 1
a197 1
			for (i=0; i<wordlen; i++) {
d206 2
a207 1
	/* we realy should wind up where we started, (which is hard to keep
d209 2
a210 1
	 * begining of the blank line.	 */
d216 1
a216 1
/*ARGSUSED*/
d219 1
a219 1
	register int status;	/* returned status of functions */
d248 1
a248 1
/*ARGSUSED*/
d251 2
a252 2
	register char	c;
	register int	col, i, nce;
d255 2
a256 1
		if (i == curwp->w_doto) return selfinsert(f, n) ;
d260 1
a260 1
			&& !(curbp->b_flag & BFNOTAB)
d262 4
a265 2
			) col |= 0x07;
		else if (ISCTRL(c) != FALSE) ++col;
d270 2
a271 1
	} else nce = 0;
d278 1
a278 1
		      && c != '\t' && curwp->w_doto > 0);
d284 1
a284 1
		      && c != '\t' && curwp->w_doto < llength(curwp->w_dotp));
d289 1
a289 1
	curwp->w_doto = i>0 ? i : 0;
d291 2
a292 1
	if (nce == 0 && curwp->w_doto != 0) return fillword(f, n);
d297 3
a299 2
setfillcol(f, n) {
	extern int	getcolpos() ;
@

