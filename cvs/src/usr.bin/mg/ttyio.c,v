head	1.37;
access;
symbols
	OPENBSD_6_1:1.37.0.8
	OPENBSD_6_1_BASE:1.37
	OPENBSD_6_0:1.37.0.6
	OPENBSD_6_0_BASE:1.37
	OPENBSD_5_9:1.37.0.2
	OPENBSD_5_9_BASE:1.37
	OPENBSD_5_8:1.37.0.4
	OPENBSD_5_8_BASE:1.37
	OPENBSD_5_7:1.35.0.2
	OPENBSD_5_7_BASE:1.35
	OPENBSD_5_6:1.35.0.4
	OPENBSD_5_6_BASE:1.35
	OPENBSD_5_5:1.34.0.6
	OPENBSD_5_5_BASE:1.34
	OPENBSD_5_4:1.34.0.2
	OPENBSD_5_4_BASE:1.34
	OPENBSD_5_3:1.33.0.2
	OPENBSD_5_3_BASE:1.33
	OPENBSD_5_2:1.32.0.20
	OPENBSD_5_2_BASE:1.32
	OPENBSD_5_1_BASE:1.32
	OPENBSD_5_1:1.32.0.18
	OPENBSD_5_0:1.32.0.16
	OPENBSD_5_0_BASE:1.32
	OPENBSD_4_9:1.32.0.14
	OPENBSD_4_9_BASE:1.32
	OPENBSD_4_8:1.32.0.12
	OPENBSD_4_8_BASE:1.32
	OPENBSD_4_7:1.32.0.8
	OPENBSD_4_7_BASE:1.32
	OPENBSD_4_6:1.32.0.10
	OPENBSD_4_6_BASE:1.32
	OPENBSD_4_5:1.32.0.6
	OPENBSD_4_5_BASE:1.32
	OPENBSD_4_4:1.32.0.4
	OPENBSD_4_4_BASE:1.32
	OPENBSD_4_3:1.32.0.2
	OPENBSD_4_3_BASE:1.32
	OPENBSD_4_2:1.31.0.6
	OPENBSD_4_2_BASE:1.31
	OPENBSD_4_1:1.31.0.4
	OPENBSD_4_1_BASE:1.31
	OPENBSD_4_0:1.31.0.2
	OPENBSD_4_0_BASE:1.31
	OPENBSD_3_9:1.29.0.2
	OPENBSD_3_9_BASE:1.29
	OPENBSD_3_8:1.28.0.2
	OPENBSD_3_8_BASE:1.28
	OPENBSD_3_7:1.25.0.6
	OPENBSD_3_7_BASE:1.25
	OPENBSD_3_6:1.25.0.4
	OPENBSD_3_6_BASE:1.25
	OPENBSD_3_5:1.25.0.2
	OPENBSD_3_5_BASE:1.25
	OPENBSD_3_4:1.23.0.6
	OPENBSD_3_4_BASE:1.23
	OPENBSD_3_3:1.23.0.4
	OPENBSD_3_3_BASE:1.23
	OPENBSD_3_2:1.23.0.2
	OPENBSD_3_2_BASE:1.23
	OPENBSD_3_1:1.21.0.2
	OPENBSD_3_1_BASE:1.21
	OPENBSD_3_0:1.16.0.2
	OPENBSD_3_0_BASE:1.16
	OPENBSD_2_9_BASE:1.13
	OPENBSD_2_9:1.13.0.2
	OPENBSD_2_8:1.12.0.2
	OPENBSD_2_8_BASE:1.12
	OPENBSD_2_7:1.11.0.2
	OPENBSD_2_7_BASE:1.11;
locks; strict;
comment	@ * @;


1.37
date	2015.03.23.12.31.19;	author bcallah;	state Exp;
branches;
next	1.36;
commitid	WS4uMCRyR8aXfh6U;

1.36
date	2015.03.19.21.22.15;	author bcallah;	state Exp;
branches;
next	1.35;
commitid	GbEBL4CfPvDkB8hj;

1.35
date	2014.03.20.07.47.29;	author lum;	state Exp;
branches;
next	1.34;

1.34
date	2013.04.20.17.39.50;	author deraadt;	state Exp;
branches;
next	1.33;

1.33
date	2013.01.19.21.22.28;	author florian;	state Exp;
branches;
next	1.32;

1.32
date	2008.02.05.12.53.38;	author reyk;	state Exp;
branches;
next	1.31;

1.31
date	2006.04.03.05.03.34;	author deraadt;	state Exp;
branches;
next	1.30;

1.30
date	2006.04.03.00.40.56;	author deraadt;	state Exp;
branches;
next	1.29;

1.29
date	2005.12.13.06.01.27;	author kjell;	state Exp;
branches;
next	1.28;

1.28
date	2005.06.14.18.14.40;	author kjell;	state Exp;
branches;
next	1.27;

1.27
date	2005.04.13.02.33.08;	author deraadt;	state Exp;
branches;
next	1.26;

1.26
date	2005.04.03.02.09.28;	author db;	state Exp;
branches;
next	1.25;

1.25
date	2003.12.04.01.37.28;	author vincent;	state Exp;
branches;
next	1.24;

1.24
date	2003.11.09.00.23.01;	author vincent;	state Exp;
branches;
next	1.23;

1.23
date	2002.09.15.14.08.57;	author vincent;	state Exp;
branches;
next	1.22;

1.22
date	2002.08.22.23.28.19;	author deraadt;	state Exp;
branches;
next	1.21;

1.21
date	2002.03.28.17.50.36;	author millert;	state Exp;
branches;
next	1.20;

1.20
date	2002.03.27.20.47.14;	author millert;	state Exp;
branches;
next	1.19;

1.19
date	2002.03.27.17.42.37;	author millert;	state Exp;
branches;
next	1.18;

1.18
date	2002.02.21.00.02.05;	author deraadt;	state Exp;
branches;
next	1.17;

1.17
date	2002.01.10.12.13.35;	author art;	state Exp;
branches;
next	1.16;

1.16
date	2001.05.24.03.05.27;	author mickey;	state Exp;
branches;
next	1.15;

1.15
date	2001.05.23.22.20.36;	author art;	state Exp;
branches;
next	1.14;

1.14
date	2001.05.03.20.40.22;	author art;	state Exp;
branches;
next	1.13;

1.13
date	2001.01.29.01.58.10;	author niklas;	state Exp;
branches;
next	1.12;

1.12
date	2000.07.25.19.52.50;	author millert;	state Exp;
branches;
next	1.11;

1.11
date	2000.04.13.06.12.18;	author millert;	state Exp;
branches;
next	1.10;

1.10
date	2000.03.02.21.55.41;	author millert;	state Exp;
branches;
next	1.9;

1.9
date	2000.03.02.17.01.41;	author millert;	state Exp;
branches;
next	1.8;

1.8
date	2000.03.02.15.51.36;	author millert;	state Exp;
branches;
next	1.7;

1.7
date	2000.02.27.17.30.40;	author millert;	state Exp;
branches;
next	1.6;

1.6
date	2000.02.27.17.24.12;	author millert;	state Exp;
branches;
next	1.5;

1.5
date	2000.02.27.05.52.32;	author millert;	state Exp;
branches;
next	1.4;

1.4
date	2000.02.26.22.53.16;	author millert;	state Exp;
branches;
next	1.3;

1.3
date	2000.02.25.19.13.21;	author deraadt;	state Exp;
branches;
next	1.2;

1.2
date	2000.02.25.19.09.48;	author deraadt;	state Exp;
branches;
next	1.1;

1.1
date	2000.02.25.19.08.52;	author deraadt;	state Exp;
branches;
next	;


desc
@@


1.37
log
@DIFFTOOL has to be defined for mg to build. TCSASOFT is defined via
termios.h so we don't need the code for when it is not defined.
ok reyk@@
@
text
@/*	$OpenBSD: ttyio.c,v 1.36 2015/03/19 21:22:15 bcallah Exp $	*/

/* This file is in the public domain. */

/*
 * POSIX terminal I/O.
 *
 * The functions in this file negotiate with the operating system for
 * keyboard characters, and write characters to the display in a barely
 * buffered fashion.
 */

#include <sys/ioctl.h>
#include <sys/queue.h>
#include <sys/time.h>
#include <sys/types.h>
#include <errno.h>
#include <fcntl.h>
#include <poll.h>
#include <signal.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <term.h>
#include <termios.h>
#include <unistd.h>

#include "def.h"

#define NOBUF	512			/* Output buffer size. */

int	ttstarted;
char	obuf[NOBUF];			/* Output buffer. */
size_t	nobuf;				/* Buffer count. */
struct	termios	oldtty;			/* POSIX tty settings. */
struct	termios	newtty;
int	nrow;				/* Terminal size, rows. */
int	ncol;				/* Terminal size, columns. */

/*
 * This function gets called once, to set up the terminal.
 * On systems w/o TCSASOFT we turn off off flow control,
 * which isn't really the right thing to do.
 */
void
ttopen(void)
{
	if (!isatty(STDIN_FILENO) || !isatty(STDOUT_FILENO))
		panic("standard input and output must be a terminal");

	if (ttraw() == FALSE)
		panic("aborting due to terminal initialize failure");
}

/*
 * This function sets the terminal to RAW mode, as defined for the current
 * shell.  This is called both by ttopen() above and by spawncli() to
 * get the current terminal settings and then change them to what
 * mg expects.	Thus, tty changes done while spawncli() is in effect
 * will be reflected in mg.
 */
int
ttraw(void)
{
	if (tcgetattr(0, &oldtty) < 0) {
		dobeep();
		ewprintf("ttopen can't get terminal attributes");
		return (FALSE);
	}
	(void)memcpy(&newtty, &oldtty, sizeof(newtty));
	/* Set terminal to 'raw' mode and ignore a 'break' */
	newtty.c_cc[VMIN] = 1;
	newtty.c_cc[VTIME] = 0;
	newtty.c_iflag |= IGNBRK;
	newtty.c_iflag &= ~(BRKINT | PARMRK | INLCR | IGNCR | ICRNL | IXON);
	newtty.c_oflag &= ~OPOST;
	newtty.c_lflag &= ~(ECHO | ECHONL | ICANON | ISIG | IEXTEN);

	if (tcsetattr(0, TCSASOFT | TCSADRAIN, &newtty) < 0) {
		dobeep();
		ewprintf("ttopen can't tcsetattr");
		return (FALSE);
	}
	ttstarted = 1;

	return (TRUE);
}

/*
 * This function gets called just before we go back home to the shell.
 * Put all of the terminal parameters back.
 * Under UN*X this just calls ttcooked(), but the ttclose() hook is in
 * because vttidy() in display.c expects it for portability reasons.
 */
void
ttclose(void)
{
	if (ttstarted) {
		if (ttcooked() == FALSE)
			panic("");	/* ttcooked() already printf'd */
		ttstarted = 0;
	}
}

/*
 * This function restores all terminal settings to their default values,
 * in anticipation of exiting or suspending the editor.
 */
int
ttcooked(void)
{
	ttflush();
	if (tcsetattr(0, TCSASOFT | TCSADRAIN, &oldtty) < 0) {
		dobeep();
		ewprintf("ttclose can't tcsetattr");
		return (FALSE);
	}
	return (TRUE);
}

/*
 * Write character to the display.  Characters are buffered up,
 * to make things a little bit more efficient.
 */
int
ttputc(int c)
{
	if (nobuf >= NOBUF)
		ttflush();
	obuf[nobuf++] = c;
	return (c);
}

/*
 * Flush output.
 */
void
ttflush(void)
{
	ssize_t	 written;
	char	*buf = obuf;

	if (nobuf == 0)
		return;

	while ((written = write(fileno(stdout), buf, nobuf)) != nobuf) {
		if (written == -1) {
			if (errno == EINTR)
				continue;
			panic("ttflush write failed");
		}
		buf += written;
		nobuf -= written;
	}
	nobuf = 0;
}

/*
 * Read character from terminal. All 8 bits are returned, so that you
 * can use a multi-national terminal.
 */
int
ttgetc(void)
{
	char	c;
	ssize_t	ret;

	do {
		ret = read(STDIN_FILENO, &c, 1);
		if (ret == -1 && errno == EINTR) {
			if (winch_flag) {
				redraw(0, 0);
				winch_flag = 0;
			}
		} else if (ret == -1 && errno == EIO)
			panic("lost stdin");
		else if (ret == 1)
			break;
	} while (1);
	return ((int) c) & 0xFF;
}

/*
 * Returns TRUE if there are characters waiting to be read.
 */
int
charswaiting(void)
{
	int	x;

	return ((ioctl(0, FIONREAD, &x) < 0) ? 0 : x);
}

/*
 * panic - just exit, as quickly as we can.
 */
void
panic(char *s)
{
	static int panicking = 0;

	if (panicking)
		return;
	else
		panicking = 1;
	ttclose();
	(void) fputs("panic: ", stderr);
	(void) fputs(s, stderr);
	(void) fputc('\n', stderr);
	exit(1);
}

/*
 * This function returns FALSE if any characters have showed up on the
 * tty before 'msec' milliseconds.
 */
int
ttwait(int msec)
{
	struct pollfd	pfd[1];

	pfd[0].fd = 0;
	pfd[0].events = POLLIN;

	if ((poll(pfd, 1, msec)) == 0)
		return (TRUE);
	return (FALSE);
}
@


1.36
log
@Clean up the includes in mg.
This does the following:
Moves all POSIX headers from sysdef.h into the individual .c files so that
each file now only includes what it needs. All headers are properly sorted.
Moves the remainder of sysdef.h to other files (mostly def.h) and deletes
sysdef.h now that it's no longer contains anything.
Tweak a comment that references sysdef.h so that it no longer does that.
ok florian@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ttyio.c,v 1.35 2014/03/20 07:47:29 lum Exp $	*/
a31 4
#ifndef TCSASOFT
#define TCSASOFT	0
#endif

a78 9
#if !TCSASOFT
	/*
	 * If we don't have TCSASOFT, force terminal to
	 * 8 bits, no parity.
	 */
	newtty.c_iflag &= ~ISTRIP;
	newtty.c_cflag &= ~(CSIZE | PARENB);
	newtty.c_cflag |= CS8;
#endif
@


1.35
log
@Add some missing dobeeps.
ok florian@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ttyio.c,v 1.34 2013/04/20 17:39:50 deraadt Exp $	*/
a11 1
#include "def.h"
d13 3
d17 1
a17 2
#include <sys/time.h>
#include <sys/ioctl.h>
d20 5
d26 3
a28 1
#include <term.h>
@


1.34
log
@use poll() instead of select() [with a fixed size fd_set]
ok florian
@
text
@d1 1
a1 1
/*	$OpenBSD: ttyio.c,v 1.33 2013/01/19 21:22:28 florian Exp $	*/
d62 1
d85 1
d119 1
@


1.33
log
@Don't spin in ttgetc when stdin is lost (found by benno@@).
While there prevent an unterminated recursion in panic().
ok lum@@, benno@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ttyio.c,v 1.32 2008/02/05 12:53:38 reyk Exp $	*/
d18 1
d222 1
a222 2
	fd_set		readfds;
	struct timeval	tmout;
d224 2
a225 2
	FD_ZERO(&readfds);
	FD_SET(0, &readfds);
d227 1
a227 4
	tmout.tv_sec = msec/1000;
	tmout.tv_usec = msec - tmout.tv_sec * 1000;

	if ((select(1, &readfds, NULL, NULL, &tmout)) == 0)
@


1.32
log
@prevent the "ttflush write failed" panic when resizing using a window
manager that that continously sends resize events.

fix inspired by an older diff for vi (r1.15 of src/usr.bin/vi/cl/cl_screen.c)

ok otto@@ jasper@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ttyio.c,v 1.31 2006/04/03 05:03:34 deraadt Exp $	*/
d176 3
a178 1
		} else if (ret == 1)
d201 6
@


1.31
log
@few more int that can become a size_t
@
text
@d1 1
a1 1
/*	$OpenBSD: ttyio.c,v 1.30 2006/04/03 00:40:56 deraadt Exp $	*/
d148 3
a150 1
		if (written == -1)
d152 1
@


1.30
log
@lint love; ok kjell
@
text
@d1 1
a1 1
/*	$OpenBSD: ttyio.c,v 1.29 2005/12/13 06:01:27 kjell Exp $	*/
d29 1
a29 1
int	nobuf;				/* Buffer count. */
@


1.29
log
@More name-clash delinting
@
text
@d1 1
a1 1
/*	$OpenBSD: ttyio.c,v 1.28 2005/06/14 18:14:40 kjell Exp $	*/
d164 1
a164 1
	int	ret;
d187 1
a187 1
	return ((ioctl(0, FIONREAD, (char *) &x) < 0) ? 0 : x);
@


1.28
log
@Add explicit public domain notices to all public domain files.
ok millert@@, deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ttyio.c,v 1.27 2005/04/13 02:33:08 deraadt Exp $	*/
d170 1
a170 1
				refresh(0, 0);
d183 1
a183 1
typeahead(void)
@


1.27
log
@use STD{IN,OUT,ERR}_FILENO
@
text
@d1 3
a3 1
/*	$OpenBSD: ttyio.c,v 1.26 2005/04/03 02:09:28 db Exp $	*/
@


1.26
log
@This is a no binary change which does:

- spelling, punctuation fixes
- variable declaration lineup
- use parentheses for return and sizeof
- K&R function declarations -> ANSI
- other minor code beautification

ok henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ttyio.c,v 1.25 2003/12/04 01:37:28 vincent Exp $	*/
d165 1
a165 1
		ret = read(0, &c, 1);
@


1.25
log
@fix sign extension bug that broke meta key support

from sra@@hactrn.net
@
text
@d1 1
a1 1
/*	$OpenBSD: ttyio.c,v 1.24 2003/11/09 00:23:01 vincent Exp $	*/
d10 1
a10 1
#include	"def.h"
d12 6
a17 6
#include	<sys/types.h>
#include	<sys/time.h>
#include	<sys/ioctl.h>
#include	<fcntl.h>
#include	<termios.h>
#include	<term.h>
d139 2
a140 2
	ssize_t written;
	char *buf = obuf;
d162 1
a162 1
	int ret;
d203 1
a203 1
 * tty before 'msec' miliseconds.
@


1.24
log
@fix up terminal correctly on panic (keeps terminal state correct when
started with an invalid $TERM)

spotted by deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: ttyio.c,v 1.23 2002/09/15 14:08:57 vincent Exp $	*/
d174 1
a174 1
	return ((int) c);
@


1.23
log
@KNF
@
text
@d1 1
a1 1
/*	$OpenBSD: ttyio.c,v 1.22 2002/08/22 23:28:19 deraadt Exp $	*/
d25 1
a40 1

a57 1

d84 2
d98 5
a102 2
	if (ttcooked() == FALSE)
		panic("");		/* ttcooked() already printf'd */
d194 1
@


1.22
log
@knf
@
text
@d1 1
a1 1
/*	$OpenBSD: ttyio.c,v 1.21 2002/03/28 17:50:36 millert Exp $	*/
d6 3
a8 4
 * The functions in this file
 * negotiate with the operating system for
 * keyboard characters, and write characters to
 * the display in a barely buffered fashion.
d19 1
a19 1
#define NOBUF	512			/* Output buffer size.		*/
d25 3
a27 3
char	obuf[NOBUF];			/* Output buffer.		*/
int	nobuf;				/* Buffer count.		*/
struct	termios	oldtty;			/* POSIX tty settings.		*/
d29 2
a30 2
int	nrow;				/* Terminal size, rows.		*/
int	ncol;				/* Terminal size, columns.	*/
d38 1
a38 1
ttopen()
d56 1
a56 1
ttraw()
d61 1
a61 1
		return(FALSE);
d83 1
a83 1
		return(FALSE);
d85 1
a85 1
	return(TRUE);
d95 1
a95 1
ttclose()
a96 1

d106 1
a106 1
ttcooked()
a107 1

d111 1
a111 1
		return(FALSE);
d113 1
a113 1
	return(TRUE);
a122 1

d126 1
a126 1
	return(c);
d133 1
a133 1
ttflush()
d151 2
a152 3
 * Read character from terminal.
 * All 8 bits are returned, so that you can use
 * a multi-national terminal.
d155 1
a155 1
ttgetc()
d177 1
a177 1
typeahead()
d181 1
a181 1
	return((ioctl(0, FIONREAD, (char *) &x) < 0) ? 0 : x);
a189 1

@


1.21
log
@Fix bug I introduced in previous commit.
@
text
@d1 1
a1 1
/*	$OpenBSD: ttyio.c,v 1.20 2002/03/27 20:47:14 millert Exp $	*/
d141 1
a141 1
	
@


1.20
log
@Fix write() loop in ttflush().  Pointed out by vincent@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ttyio.c,v 1.19 2002/03/27 17:42:37 millert Exp $	*/
d151 1
@


1.19
log
@Fixes the the following problems (from zyrnix)
1) Mg crashes with column width of 1, rows > 2
2) Mg panics on resizing due to incomplete write
3) Mg doesn't compile with STARTUPFILE defined
deraadt@@ OK
@
text
@d1 1
a1 1
/*	$OpenBSD: ttyio.c,v 1.18 2002/02/21 00:02:05 deraadt Exp $	*/
d140 1
d145 1
a145 1
	while ((written = write(fileno(stdout), obuf, nobuf)) != nobuf) {
d148 2
a149 2
		else
			nobuf -= written;
a150 1
	nobuf = 0;
@


1.18
log
@signal-safe window size changing
@
text
@d1 1
a1 1
/*	$OpenBSD: ttyio.c,v 1.17 2002/01/10 12:13:35 art Exp $	*/
d124 1
a124 2
ttputc(c)
	int c;
d139 4
d144 2
a145 2
	if (nobuf != 0) {
		if (write(1, obuf, nobuf) != nobuf)
d147 2
a148 1
		nobuf = 0;
d150 1
d192 1
a192 2
panic(s)
	char *s;
@


1.17
log
@Clean up tty resizing code.
Catch SIGWINCH and resize and refresh the screen.
@
text
@d1 1
a1 1
/*	$OpenBSD: ttyio.c,v 1.16 2001/05/24 03:05:27 mickey Exp $	*/
d157 1
d159 10
a168 2
	while (read(0, &c, 1) != 1)
		;
@


1.16
log
@spaces
@
text
@d1 1
a1 1
/*	$OpenBSD: ttyio.c,v 1.15 2001/05/23 22:20:36 art Exp $	*/
a160 28
}

/*
 * Set the tty size.
 * XXX - belongs in tty.c since it uses terminfo vars.
 */
void
setttysize()
{
#ifdef	TIOCGWINSZ
	struct	winsize winsize;

	if (ioctl(0, TIOCGWINSZ, (char *) &winsize) == 0) {
		nrow = winsize.ws_row;
		ncol = winsize.ws_col;
	} else nrow = 0;
#endif
	if ((nrow <= 0 || ncol <= 0) &&
	    ((nrow = lines) <= 0 || (ncol = columns) <= 0)) {
		nrow = 24;
		ncol = 80;
	}

	/* Enforce maximum screen size. */
	if (nrow > NROW)
		nrow = NROW;
	if (ncol > NCOL)
		ncol = NCOL;
@


1.15
log
@remove VOID. We're way beyond the point where this could build with an
ancient compiler.
@
text
@d1 1
a1 1
/*	$OpenBSD: ttyio.c,v 1.14 2001/05/03 20:40:22 art Exp $	*/
d43 1
a43 1
		panic("standard input and output must be a terminal");  
d226 1
a226 1
	FD_ZERO(&readfds);   
@


1.14
log
@Add a delay (in miliseconds) argument to ttwait.
@
text
@d1 1
a1 1
/*	$OpenBSD: ttyio.c,v 1.13 2001/01/29 01:58:10 niklas Exp $	*/
d205 1
a205 1
VOID
@


1.13
log
@$OpenBSD$
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
a215 1
#ifndef NO_DPROMPT
d217 2
a218 2
 * A program to return TRUE if we wait for 2 seconds without anything
 * happening, else return FALSE.  Cribbed from mod.sources xmodem.
d221 1
a221 1
ttwait()
d229 2
a230 2
	tmout.tv_sec = 2;
	tmout.tv_usec = 0;
a235 1
#endif /* NO_DPROMPT */
@


1.12
log
@o check that we are on a tty (and bail if not)
o in panic() just call exit() not abort()
@
text
@d1 2
@


1.11
log
@The start of KNF + -Wall.  The code has been run through indent but
needs hand fixup.  I stopped at keymap.c...
@
text
@d40 3
d211 1
a211 1
	abort();		/* To leave a core image. */
@


1.10
log
@add missing return value
@
text
@a30 13
/* XXX - move most of these to def.h? */
void ttopen __P((void));
int ttraw __P((void));
void ttclose __P((void));
int ttcooked __P((void));
void ttputc __P((int));
void ttflush __P((void));
int ttgetc __P((void));
void setttysize __P((void));
int typeahead __P((void));
void panic __P((char *));
int ttwait __P((void));

d118 1
a118 1
void
d126 1
d200 1
a200 1
void
@


1.9
log
@Use a char, not a char[1] in ttgetc and cast the return value to int.
Perhaps this should really be a u_char but I don't think it really matters.
@
text
@d45 1
a45 1
 * This function gets called once, to set up the terminal
d94 1
@


1.8
log
@Reorganize to be more like the BSD version + KNF
@
text
@d162 1
a162 1
	char	buf[1];
d164 1
a164 1
	while (read(0, &buf[0], 1) != 1)
d166 1
a166 1
	return (buf[0] & 0xFF);
@


1.7
log
@make this compile on systems w/o TCSASOFT
@
text
@d18 1
a18 1
#define	NOBUF	512			/* Output buffer size.		*/
d25 3
a27 8
int	nobuf;				/* buffer count			*/

static struct termios	ot;		/* entry state of the terminal	*/
static struct termios	nt;		/* editor's terminal state	*/

static int ttyactivep = FALSE;		/* terminal in editor mode?	*/
static int ttysavedp = FALSE;		/* terminal state saved?	*/

d31 17
a47 5
/*
 * This function gets called once, to set up
 * the terminal channel.  This version turns off flow
 * control.  This may be wrong for your system, but no
 * good solution has really been found (daveb).
d49 1
a51 1
	register char	*cp;
d53 3
a55 2
	if (ttyactivep)
		return;
d57 23
a79 12
	if( !ttysavedp )
	{
		if (tcgetattr(0, &ot) < 0)
			abort();
		nt = ot;		/* save entry state		*/
		/* Set terminal to 'raw' mode and ignore a 'break' */
		nt.c_cc[VMIN] = 1;
		nt.c_cc[VTIME] = 0;
		nt.c_iflag |= IGNBRK;
		nt.c_iflag &= ~(BRKINT|PARMRK|INLCR|IGNCR|ICRNL|IXON);
		nt.c_oflag &= ~OPOST;
		nt.c_lflag &= ~(ECHO|ECHONL|ICANON|ISIG|IEXTEN);
d82 7
a88 7
		/*
		 * If we don't have TCSASOFT, force terminal to
		 * 8 bits, no parity.
		 */
		nt.c_iflag &= ~ISTRIP;
		nt.c_cflag &= ~(CSIZE|PARENB);
		nt.c_cflag |= CS8;
d90 5
d96 9
a104 5
		ttysavedp = TRUE;
	}
	
	if (tcsetattr(0, TCSASOFT | TCSADRAIN, &nt) < 0)
		abort();
d106 2
a107 1
	ttyactivep = TRUE;
d111 2
a112 3
 * This function gets called just
 * before we go back home to the shell. Put all of
 * the terminal parameters back.
d114 2
a115 1
ttclose()
d117 1
a117 2
	if(!ttysavedp || !ttyactivep)
		return;
d119 5
a123 3
	if (tcsetattr(0, TCSASOFT | TCSADRAIN, &ot) < 0)
		abort();
	ttyactivep = FALSE;
d127 2
a128 3
 * Write character to the display.
 * Characters are buffered up, to make things
 * a little bit more efficient.
d130 1
d132 1
d143 1
d148 2
a149 1
		write(1, obuf, nobuf);
a157 4
 *
 * If keyboard 'queue' already has typeahead from a typeahead() call,
 * just return it.  Otherwise, make sure we are in blocking i/o mode
 * and read a character.
d159 1
d162 1
a162 1
	int    c;
d164 1
a164 1
	while (read(0, &c, 1) != 1)
d166 1
a166 1
	return (c & 0xFF);
d170 2
a171 1
 * Return TRUE if there are characters waiting to be read.
d173 1
a173 27
typeahead()
{
	int x;

	return((ioctl(0, FIONREAD, (char *) &x) < 0) ? 0 : x);
}


/*
 * panic:  print error and die, leaving core file.
 * Don't know why this is needed (daveb).
 */
panic(s)
char *s;
{

	(void) fputs("panic: ", stderr);
	(void) fputs(s, stderr);
	(void) fputc('\n', stderr);
	abort();		/* To leave a core image. */
}


/*
** This should check the size of the window, and reset if needed.
*/

d177 1
a177 1
        struct winsize winsize;
d182 1
a182 1
	} else
d184 2
a185 1
	if ((nrow = lines) <= 0 || (ncol = columns) <= 0) {
d197 25
d224 2
a225 1
 * Return TRUE if we wait without doing anything, else return FALSE.
d227 1
d230 2
a231 2
	fd_set readfds;
	struct timeval tmout;
d233 1
a233 1
	FD_ZERO(&readfds);
d240 2
a241 2
		return(TRUE);
	return(FALSE);
d243 1
a243 1
#endif NO_DPROMPT
@


1.6
log
@Better setting of terminal 'raw' mode, cribbed from BSD curses.
We no longer try to put the terminal into 8bit, no parity mode and
instead use the TCSASOFT flag to tcsetattr() as per the discussion
of this in lib/libocurses/tty.c.
@
text
@d20 4
d61 10
@


1.5
log
@Call setttysize() from ttinit() not ttopen() since we haven't
run setupterm() until ttinit() is called.
Remove a tgetnum() I missed in the termcap -> terminfo cleanup.
Merge parts of the BSD ttyio.c.  The termios stuff here could use a
cleanup, possibly including the flow control hack from the BSD ttyio.c.
@
text
@d50 3
a52 2
		nt.c_cc[VMIN] = 1;	/* one character read is OK	*/
		nt.c_cc[VTIME] = 0;	/* Never time out.		*/
d54 1
a54 1
		nt.c_iflag &= ~( ICRNL | INLCR | ISTRIP | IXON | IXOFF );
d56 1
a56 3
		nt.c_cflag |= CS8;	/* allow 8th bit on input	*/
		nt.c_cflag &= ~PARENB;	/* Don't check parity		*/
		nt.c_lflag &= ~( ECHO | ICANON | ISIG );
d61 1
a61 1
	if (tcsetattr(0, TCSAFLUSH, &nt) < 0)
d77 1
a77 1
	if (tcsetattr(0, TCSAFLUSH, &ot) < 0)
@


1.4
log
@change WINDOW -> MGWIN to avoid curses type conflict
convert to terminfo in tty*.c
add support for some keypad function keys (arrows, pgup, pgdown)
@
text
@d2 1
a2 6
 * Name:	MicroEMACS
 *		POSIX terminal I/O.
 * Version:	0
 * Last edit:	Tue Aug 26 23:57:57 PDT 1986
 * By:		gonzo!daveb
 *		{sun, amdahl, mtxinu}!rtech!gonzo!daveb
a7 2
 *
 * This version goes along with the terminfo tty.c.
d12 2
a31 7
/* These are used to implement typeahead on System V */

int kbdflgs;			/* saved keyboard fd flags	*/
int kbdpoll;			/* in O_NDELAY mode			*/
int kbdqp;			/* there is a char in kbdq	*/
char kbdq;			/* char we've already read	*/

a58 2
		kbdpoll = (((kbdflgs = fcntl(0, F_GETFL, 0)) & O_NDELAY) != 0);
	
a64 2
	setttysize();

d78 1
a78 2
	if (tcsetattr(0, TCSAFLUSH, &ot) < 0 ||
	    fcntl( 0, F_SETFL, kbdflgs ) < 0)
d90 1
d101 1
d119 5
a123 11
	if( kbdqp )
		kbdqp = FALSE;
	else
	{
		if( kbdpoll && fcntl( 0, F_SETFL, kbdflgs ) < 0 )
			abort();
		kbdpoll = FALSE;
		while (read(0, &kbdq, 1) != 1)
			;
	}
	return ( kbdq & 0xff );
d127 1
a127 5
 * Return non-FALSE if typeahead is pending.
 *
 * If already got unread typeahead, do nothing.
 * Otherwise, set keyboard to O_NDELAY if not already, and try
 * a one character read.
d131 3
a133 8
	if( !kbdqp )
	{
		if( !kbdpoll && fcntl( 0, F_SETFL, kbdflgs | O_NDELAY ) < 0 )
			abort();
		kbdpoll = TRUE;
		kbdqp = (1 == read( 0, &kbdq, 1 ));
	}
	return ( kbdqp );
d144 5
a148 2
	fprintf(stderr, "%s\r\n", s);
	abort();
d160 1
d162 2
a163 2
		nrow = winsize . ws_row;
		ncol = winsize . ws_col;
a178 10
#include <signal.h>
#include <setjmp.h>

static jmp_buf tohere;

static void alrm()
{
	longjmp(tohere, -1);
}

a181 1

d184 12
a195 8
	if (kbdqp)
		return FALSE;		/* already pending input	*/
	if (setjmp(tohere))
		return TRUE;		/* timeout on read if here	*/
	signal(SIGALRM, alrm); alarm(2);
	kbdqp = (1 == read(0, &kbdq, 1));
	alarm(0);
	return FALSE;			/* successful read if here	*/
@


1.3
log
@further pruning
@
text
@d3 1
a3 1
 *		System V terminal I/O.
d14 1
a14 3
 * This version goes along with tty/termcap/tty.c.
 * Terminal size is determined there, rather than here, and
 * this does not open the termcap file
d21 1
d79 1
a79 12
	/* This really belongs in tty/termcap... */

	if ((cp=getenv("TERMCAP")) == NULL
	|| (nrow=getvalue(cp, "li")) <= 0
	|| (ncol=getvalue(cp, "co")) <= 0) {
		nrow = 24;
		ncol = 80;
	}
	if (nrow > NROW)			/* Don't crash if the	*/
		nrow = NROW;			/* termcap entry is	*/
	if (ncol > NCOL)			/* too big.		*/
		ncol = NCOL;
a84 22
 * This routine scans a string, which is
 * actually the return value of a getenv call for the TERMCAP
 * variable, looking for numeric parameter "name". Return the value
 * if found. Return -1 if not there. Assume that "name" is 2
 * characters long. This limited use of the TERMCAP lets us find
 * out the size of a window on the X display.
 */
getvalue(cp, name)
register char	*cp;
register char	*name;
{
	for (;;) {
		while (*cp!=0 && *cp!=':')
			++cp;
		if (*cp++ == 0)			/* Not found.		*/
			return (-1);
		if (cp[0]==name[0] && cp[1]==name[1] && cp[2]=='#')
			return (atoi(cp+3));	/* Stops on ":".	*/
	}
}

/*
d192 1
a192 2
	if ((nrow=tgetnum ("li")) <= 0
	|| (ncol=tgetnum ("co")) <= 0) {
d196 5
a200 3
	if (nrow > NROW)			/* Don't crash if the	*/
		nrow = NROW;			/* termcap entry is	*/
	if (ncol > NCOL)			/* too big.		*/
@


1.2
log
@make it minimally compile; millert
@
text
@a53 1
	extern char	*getenv();
@


1.1
log
@initial import of mg2a
@
text
@d22 1
a22 1
#include	<termio.h>
d29 2
a30 2
static struct termio	ot;		/* entry state of the terminal	*/
static struct termio	nt;		/* editor's terminal state	*/
d61 1
a61 1
		if (ioctl(0, TCGETA, &ot) < 0)
d78 1
a78 1
	if (ioctl(0, TCSETAF, &nt) < 0)
d129 2
a130 1
	if (ioctl(0, TCSETAF, &ot) < 0 || fcntl( 0, F_SETFL, kbdflgs ) < 0)
a254 2
	int alrm();

@

