head	1.35;
access;
symbols
	OPENBSD_6_2:1.35.0.8
	OPENBSD_6_2_BASE:1.35
	OPENBSD_6_1:1.35.0.10
	OPENBSD_6_1_BASE:1.35
	OPENBSD_6_0:1.35.0.6
	OPENBSD_6_0_BASE:1.35
	OPENBSD_5_9:1.35.0.2
	OPENBSD_5_9_BASE:1.35
	OPENBSD_5_8:1.35.0.4
	OPENBSD_5_8_BASE:1.35
	OPENBSD_5_7:1.34.0.8
	OPENBSD_5_7_BASE:1.34
	OPENBSD_5_6:1.34.0.12
	OPENBSD_5_6_BASE:1.34
	OPENBSD_5_5:1.34.0.10
	OPENBSD_5_5_BASE:1.34
	OPENBSD_5_4:1.34.0.6
	OPENBSD_5_4_BASE:1.34
	OPENBSD_5_3:1.34.0.4
	OPENBSD_5_3_BASE:1.34
	OPENBSD_5_2:1.34.0.2
	OPENBSD_5_2_BASE:1.34
	OPENBSD_5_1_BASE:1.32
	OPENBSD_5_1:1.32.0.12
	OPENBSD_5_0:1.32.0.10
	OPENBSD_5_0_BASE:1.32
	OPENBSD_4_9:1.32.0.8
	OPENBSD_4_9_BASE:1.32
	OPENBSD_4_8:1.32.0.6
	OPENBSD_4_8_BASE:1.32
	OPENBSD_4_7:1.32.0.2
	OPENBSD_4_7_BASE:1.32
	OPENBSD_4_6:1.32.0.4
	OPENBSD_4_6_BASE:1.32
	OPENBSD_4_5:1.31.0.14
	OPENBSD_4_5_BASE:1.31
	OPENBSD_4_4:1.31.0.12
	OPENBSD_4_4_BASE:1.31
	OPENBSD_4_3:1.31.0.10
	OPENBSD_4_3_BASE:1.31
	OPENBSD_4_2:1.31.0.8
	OPENBSD_4_2_BASE:1.31
	OPENBSD_4_1:1.31.0.6
	OPENBSD_4_1_BASE:1.31
	OPENBSD_4_0:1.31.0.4
	OPENBSD_4_0_BASE:1.31
	OPENBSD_3_9:1.31.0.2
	OPENBSD_3_9_BASE:1.31
	OPENBSD_3_8:1.25.0.2
	OPENBSD_3_8_BASE:1.25
	OPENBSD_3_7:1.21.0.4
	OPENBSD_3_7_BASE:1.21
	OPENBSD_3_6:1.21.0.2
	OPENBSD_3_6_BASE:1.21
	OPENBSD_3_5:1.20.0.8
	OPENBSD_3_5_BASE:1.20
	OPENBSD_3_4:1.20.0.6
	OPENBSD_3_4_BASE:1.20
	OPENBSD_3_3:1.20.0.4
	OPENBSD_3_3_BASE:1.20
	OPENBSD_3_2:1.20.0.2
	OPENBSD_3_2_BASE:1.20
	OPENBSD_3_1:1.17.0.2
	OPENBSD_3_1_BASE:1.17
	OPENBSD_3_0:1.14.0.2
	OPENBSD_3_0_BASE:1.14
	OPENBSD_2_9_BASE:1.4
	OPENBSD_2_9:1.4.0.2
	OPENBSD_2_8:1.3.0.2
	OPENBSD_2_8_BASE:1.3
	OPENBSD_2_7:1.2.0.2
	OPENBSD_2_7_BASE:1.2;
locks; strict;
comment	@ * @;


1.35
date	2015.03.19.21.22.15;	author bcallah;	state Exp;
branches;
next	1.34;
commitid	GbEBL4CfPvDkB8hj;

1.34
date	2012.04.12.04.47.59;	author lum;	state Exp;
branches;
next	1.33;

1.33
date	2012.03.14.13.56.35;	author lum;	state Exp;
branches;
next	1.32;

1.32
date	2009.06.04.23.39.37;	author kjell;	state Exp;
branches;
next	1.31;

1.31
date	2005.12.14.07.11.44;	author kjell;	state Exp;
branches;
next	1.30;

1.30
date	2005.12.13.07.20.13;	author kjell;	state Exp;
branches;
next	1.29;

1.29
date	2005.12.13.06.01.27;	author kjell;	state Exp;
branches;
next	1.28;

1.28
date	2005.12.13.05.40.33;	author kjell;	state Exp;
branches;
next	1.27;

1.27
date	2005.11.18.20.56.53;	author deraadt;	state Exp;
branches;
next	1.26;

1.26
date	2005.10.14.15.41.33;	author deraadt;	state Exp;
branches;
next	1.25;

1.25
date	2005.08.09.00.53.48;	author kjell;	state Exp;
branches;
next	1.24;

1.24
date	2005.06.14.18.14.40;	author kjell;	state Exp;
branches;
next	1.23;

1.23
date	2005.04.28.07.23.56;	author otto;	state Exp;
branches;
next	1.22;

1.22
date	2005.04.03.02.09.28;	author db;	state Exp;
branches;
next	1.21;

1.21
date	2004.07.22.01.25.25;	author vincent;	state Exp;
branches;
next	1.20;

1.20
date	2002.08.22.23.28.19;	author deraadt;	state Exp;
branches;
next	1.19;

1.19
date	2002.07.01.14.33.44;	author vincent;	state Exp;
branches;
next	1.18;

1.18
date	2002.06.21.05.37.20;	author vincent;	state Exp;
branches;
next	1.17;

1.17
date	2002.03.16.19.30.29;	author vincent;	state Exp;
branches;
next	1.16;

1.16
date	2002.03.11.13.02.56;	author vincent;	state Exp;
branches;
next	1.15;

1.15
date	2001.11.25.07.34.17;	author deraadt;	state Exp;
branches;
next	1.14;

1.14
date	2001.05.24.09.47.34;	author art;	state Exp;
branches;
next	1.13;

1.13
date	2001.05.24.09.06.21;	author art;	state Exp;
branches;
next	1.12;

1.12
date	2001.05.24.03.05.23;	author mickey;	state Exp;
branches;
next	1.11;

1.11
date	2001.05.23.23.29.47;	author mickey;	state Exp;
branches;
next	1.10;

1.10
date	2001.05.23.22.20.35;	author art;	state Exp;
branches;
next	1.9;

1.9
date	2001.05.23.22.12.10;	author art;	state Exp;
branches;
next	1.8;

1.8
date	2001.05.23.21.47.33;	author art;	state Exp;
branches;
next	1.7;

1.7
date	2001.05.23.21.01.16;	author art;	state Exp;
branches;
next	1.6;

1.6
date	2001.05.23.20.19.44;	author art;	state Exp;
branches;
next	1.5;

1.5
date	2001.05.23.16.14.00;	author art;	state Exp;
branches;
next	1.4;

1.4
date	2001.01.29.01.58.07;	author niklas;	state Exp;
branches;
next	1.3;

1.3
date	2000.09.01.14.59.08;	author millert;	state Exp;
branches;
next	1.2;

1.2
date	2000.04.13.06.12.15;	author millert;	state Exp;
branches;
next	1.1;

1.1
date	2000.02.25.19.08.48;	author deraadt;	state Exp;
branches;
next	;


desc
@@


1.35
log
@Clean up the includes in mg.
This does the following:
Moves all POSIX headers from sysdef.h into the individual .c files so that
each file now only includes what it needs. All headers are properly sorted.
Moves the remainder of sysdef.h to other files (mostly def.h) and deletes
sysdef.h now that it's no longer contains anything.
Tweak a comment that references sysdef.h so that it no longer does that.
ok florian@@
@
text
@/*	$OpenBSD: help.c,v 1.34 2012/04/12 04:47:59 lum Exp $	*/

/* This file is in the public domain. */

/*
 * Help functions for Mg 2
 */

#include <sys/queue.h>
#include <signal.h>
#include <stdio.h>
#include <string.h>

#include "def.h"
#include "funmap.h"
#include "kbd.h"
#include "key.h"
#include "macro.h"

static int	showall(struct buffer *, KEYMAP *, char *);
static int	findbind(KEYMAP *, PF, char *, size_t);

/*
 * Read a key from the keyboard, and look it up in the keymap.
 * Display the name of the function currently bound to the key.
 */
/* ARGSUSED */
int
desckey(int f, int n)
{
	KEYMAP	*curmap;
	PF	 funct;
	int	 c, m, i, num;
	char	*pep;
	char	 dprompt[80];

	if (inmacro)
		return (TRUE);	/* ignore inside keyboard macro */

	num = strlcpy(dprompt, "Describe key briefly: ", sizeof(dprompt));
	if (num >= sizeof(dprompt))
		num = sizeof(dprompt) - 1;
	pep = dprompt + num;
	key.k_count = 0;
	m = curbp->b_nmodes;
	curmap = curbp->b_modes[m]->p_map;
	for (;;) {
		for (;;) {
			ewprintf("%s", dprompt);
			pep[-1] = ' ';
			pep = getkeyname(pep, sizeof(dprompt) - (pep - dprompt),
			    key.k_chars[key.k_count++] = c = getkey(FALSE));
			if ((funct = doscan(curmap, c, &curmap)) != NULL)
				break;
			*pep++ = '-';
			*pep = '\0';
		}
		if (funct != rescan)
			break;
		if (ISUPPER(key.k_chars[key.k_count - 1])) {
			funct = doscan(curmap,
			    TOLOWER(key.k_chars[key.k_count - 1]), &curmap);
			if (funct == NULL) {
				*pep++ = '-';
				*pep = '\0';
				continue;
			}
			if (funct != rescan)
				break;
		}
nextmode:
		if (--m < 0)
			break;
		curmap = curbp->b_modes[m]->p_map;
		for (i = 0; i < key.k_count; i++) {
			funct = doscan(curmap, key.k_chars[i], &curmap);
			if (funct != NULL) {
				if (i == key.k_count - 1 && funct != rescan)
					goto found;
				funct = rescan;
				goto nextmode;
			}
		}
		*pep++ = '-';
		*pep = '\0';
	}
found:
	if (funct == rescan || funct == selfinsert)
		ewprintf("%k is not bound to any function");
	else if ((pep = (char *)function_name(funct)) != NULL)
		ewprintf("%k runs the command %s", pep);
	else
		ewprintf("%k is bound to an unnamed function");
	return (TRUE);
}

/*
 * This function creates a table, listing all of the command
 * keys and their current bindings, and stores the table in the
 * *help* pop-up buffer.  This lets Mg produce it's own wall chart.
 */
/* ARGSUSED */
int
wallchart(int f, int n)
{
	int		 m;
	struct buffer		*bp;

	bp = bfind("*help*", TRUE);
	if (bclear(bp) != TRUE)
		/* clear it out */
		return (FALSE);
	bp->b_flag |= BFREADONLY;
	for (m = curbp->b_nmodes; m > 0; m--) {
		if ((addlinef(bp, "Local keybindings for mode %s:",
				curbp->b_modes[m]->p_name) == FALSE) ||
		    (showall(bp, curbp->b_modes[m]->p_map, "") == FALSE) ||
		    (addline(bp, "") == FALSE))
			return (FALSE);
	}
	if ((addline(bp, "Global bindings:") == FALSE) ||
	    (showall(bp, fundamental_map, "") == FALSE))
		return (FALSE);
	return (popbuftop(bp, WNONE));
}

static int
showall(struct buffer *bp, KEYMAP *map, char *prefix)
{
	KEYMAP	*newmap;
	char	 buf[80], keybuf[16];
	PF	 fun;
	int	 c;

	if (addline(bp, "") == FALSE)
		return (FALSE);

	/* XXX - 256 ? */
	for (c = 0; c < 256; c++) {
		fun = doscan(map, c, &newmap);
		if (fun == rescan || fun == selfinsert)
			continue;
		getkeyname(buf, sizeof(buf), c);
		(void)snprintf(keybuf, sizeof(keybuf), "%s%s ", prefix, buf);
		if (fun == NULL) {
			if (showall(bp, newmap, keybuf) == FALSE)
				return (FALSE);
		} else {
			if (addlinef(bp, "%-16s%s", keybuf,
				    function_name(fun)) == FALSE)
				return (FALSE);
		}
	}
	return (TRUE);
}

int
help_help(int f, int n)
{
	KEYMAP	*kp;
	PF	 funct;

	if ((kp = name_map("help")) == NULL)
		return (FALSE);
	ewprintf("a b c: ");
	do {
		funct = doscan(kp, getkey(FALSE), NULL);
	} while (funct == NULL || funct == help_help);

	if (macrodef && macrocount < MAXMACRO)
		macro[macrocount - 1].m_funct = funct;

	return ((*funct)(f, n));
}

/* ARGSUSED */
int
apropos_command(int f, int n)
{
	struct buffer		*bp;
	struct list		*fnames, *el;
	char		 string[32];

	if (eread("apropos: ", string, sizeof(string), EFNUL | EFNEW) == NULL)
		return (ABORT);
	/* FALSE means we got a 0 character string, which is fine */
	bp = bfind("*help*", TRUE);
	if (bclear(bp) == FALSE)
		return (FALSE);

	fnames = complete_function_list("");
	for (el = fnames; el != NULL; el = el->l_next) {
		char buf[32];

		if (strstr(el->l_name, string) == NULL)
			continue;

		buf[0] = '\0';
		findbind(fundamental_map, name_function(el->l_name),
		    buf, sizeof(buf));

		if (addlinef(bp, "%-32s%s", el->l_name,  buf) == FALSE) {
			free_file_list(fnames);
			return (FALSE);
		}
	}
	free_file_list(fnames);
	return (popbuftop(bp, WNONE));
}

static int
findbind(KEYMAP *map, PF fun, char *buf, size_t len)
{
	KEYMAP	*newmap;
	PF	 nfun;
	char	 buf2[16], keybuf[16];
	int	 c;

	/* XXX - 256 ? */
	for (c = 0; c < 256; c++) {
		nfun = doscan(map, c, &newmap);
		if (nfun == fun) {
			getkeyname(buf, len, c);
			return (TRUE);
		}
		if (nfun == NULL) {
			if (findbind(newmap, fun, buf2, sizeof(buf2)) == TRUE) {
				getkeyname(keybuf, sizeof(keybuf), c);
				(void)snprintf(buf, len, "%s %s", keybuf, buf2);
				return (TRUE);
			}
		}
	}
	return (FALSE);
}
@


1.34
log
@Remove the conditional directives NO_MACRO and NO_STARTUP.
They have not compiled for numerous years.
ok kjell@@ millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: help.c,v 1.33 2012/03/14 13:56:35 lum Exp $	*/
d9 5
a15 1

@


1.33
log
@Remove the NO_HELP conditional directives. If defined, mg will not compile and
has not done so for numerous years. Not hard to fix, but just remove anyway.
ok kjell@@ millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: help.c,v 1.32 2009/06/04 23:39:37 kjell Exp $	*/
a13 1
#ifndef NO_MACRO
a14 1
#endif /* !NO_MACRO */
a32 1
#ifndef NO_MACRO
d35 1
a35 1
#endif /* !NO_MACRO */
d165 1
a165 1
#ifndef NO_MACRO
d168 1
a168 1
#endif /* !NO_MACRO */
@


1.32
log
@Add the notion of an "ephemeral" popup, so we can flag a window
for destruction at a later date. (in the process, add a window flag field)

This fixes an issue noted by maja: namely, the *completion*
window that pops up when you try to complete a filename on
buffer load would destroy any second window that you happened
to have open.

ok maja@@
@
text
@d1 1
a1 1
/*	$OpenBSD: help.c,v 1.31 2005/12/14 07:11:44 kjell Exp $	*/
a11 1
#ifndef NO_HELP
a234 1
#endif /* !NO_HELP */
@


1.31
log
@argh. One problem with fixing a hidden global symbol is that if you miss one,
you get no warning. Fixes an immediate core in describe-bindings.
@
text
@d1 1
a1 1
/*	$OpenBSD: help.c,v 1.30 2005/12/13 07:20:13 kjell Exp $	*/
d124 1
a124 1
	return (popbuftop(bp));
d208 1
a208 1
	return (popbuftop(bp));
@


1.30
log
@Last round of easy delinting.
@
text
@d1 1
a1 1
/*	$OpenBSD: help.c,v 1.29 2005/12/13 06:01:27 kjell Exp $	*/
d149 1
a149 1
			if (addlinef(bp, "%-16s%s", key,
@


1.29
log
@More name-clash delinting
@
text
@d1 1
a1 1
/*	$OpenBSD: help.c,v 1.28 2005/12/13 05:40:33 kjell Exp $	*/
d131 1
a131 1
	char	 buf[80], key[16];
d144 1
a144 1
		(void)snprintf(key, sizeof(key), "%s%s ", prefix, buf);
d146 1
a146 1
			if (showall(bp, newmap, key) == FALSE)
d216 1
a216 1
	char	 buf2[16], key[16];
d228 2
a229 2
				getkeyname(key, sizeof(key), c);
				(void)snprintf(buf, len, "%s %s", key, buf2);
@


1.28
log
@do some silly de-linting
@
text
@d1 1
a1 1
/*	$OpenBSD: help.c,v 1.27 2005/11/18 20:56:53 deraadt Exp $	*/
d51 1
a51 1
			pep = keyname(pep, sizeof(dprompt) - (pep - dprompt),
d143 1
a143 1
		keyname(buf, sizeof(buf), c);
d223 1
a223 1
			keyname(buf, len, c);
d228 1
a228 1
				keyname(key, sizeof(key), c);
@


1.27
log
@greedy use of typedef struct was making code harder to read; ok kjell cloder
@
text
@d1 1
a1 1
/*	$OpenBSD: help.c,v 1.26 2005/10/14 15:41:33 deraadt Exp $	*/
d34 1
a34 1
	char	 prompt[80];
d40 4
a43 4
	num = strlcpy(prompt, "Describe key briefly: ", sizeof(prompt));
	if (num >= sizeof(prompt))
		num = sizeof(prompt) - 1;
	pep = prompt + num;
d49 1
a49 1
			ewprintf("%s", prompt);
d51 1
a51 1
			pep = keyname(pep, sizeof(prompt) - (pep - prompt),
@


1.26
log
@unused variables
@
text
@d1 1
a1 1
/*	$OpenBSD: help.c,v 1.25 2005/08/09 00:53:48 kjell Exp $	*/
d19 1
a19 1
static int	showall(BUFFER *, KEYMAP *, char *);
d107 1
a107 1
	BUFFER		*bp;
d128 1
a128 1
showall(BUFFER *bp, KEYMAP *map, char *prefix)
d180 2
a181 2
	BUFFER		*bp;
	LIST		*fnames, *el;
@


1.25
log
@Clean up eread handling in mg. (basically, fallout from the 'enter often
means abort' behaviour added during the hackathon). Eliminates
redundant ereply function, fixes miscellaneous cores when aborting,
and move a number of assumed pathnames into the prompt text, since
they are used there anyway. All changes consistent with emacs behavior

ok beck@@ many, many moons ago.
@
text
@d1 1
a1 1
/*	$OpenBSD: help.c,v 1.24 2005/06/14 18:14:40 kjell Exp $	*/
d182 1
a182 1
	char		 string[32], *bufp;
d184 1
a184 2
	if ((bufp = eread("apropos: ", string, sizeof(string),
	   EFNUL | EFNEW)) == NULL)
@


1.24
log
@Add explicit public domain notices to all public domain files.
ok millert@@, deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: help.c,v 1.23 2005/04/28 07:23:56 otto Exp $	*/
d184 2
a185 1
	if ((bufp = eread("apropos: ", string, sizeof(string), EFNEW)) == NULL)
@


1.23
log
@Get rid of unused arg to complete_function_list(). Han Boetes.
@
text
@d1 3
a3 1
/*	$OpenBSD: help.c,v 1.22 2005/04/03 02:09:28 db Exp $	*/
@


1.22
log
@This is a no binary change which does:

- spelling, punctuation fixes
- variable declaration lineup
- use parentheses for return and sizeof
- K&R function declarations -> ANSI
- other minor code beautification

ok henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: help.c,v 1.21 2004/07/22 01:25:25 vincent Exp $	*/
d189 1
a189 1
	fnames = complete_function_list("", NULL);
@


1.21
log
@stage 1 of the infinite minibuffer work - add support for on the fly
buffer reallocation in veread().  This commit only changes the API.
All the buffers have exactly the same bounds as before for now.

tested by a couple of my very helpful testers!
@
text
@d1 1
a1 1
/*	$OpenBSD: help.c,v 1.20 2002/08/22 23:28:19 deraadt Exp $	*/
d26 1
a26 2
desckey(f, n)
	int f, n;
d36 1
a36 1
		return TRUE;	/* ignore inside keyboard macro */
d39 2
a40 2
	if (num >= sizeof prompt)
		num = sizeof prompt - 1;
d92 1
a92 1
	return TRUE;
d102 1
a102 2
wallchart(f, n)
	int f, n;
d110 1
a110 1
		return FALSE;
d117 1
a117 1
			return FALSE;
d121 2
a122 2
		return FALSE;
	return popbuftop(bp);
d128 4
a131 4
	KEYMAP *newmap;
	char buf[80], key[16];
	PF fun;
	int c;
d134 1
a134 1
		return FALSE;
d142 1
a142 1
		(void)snprintf(key, sizeof key, "%s%s ", prefix, buf);
d145 1
a145 1
				return FALSE;
d149 1
a149 1
				return FALSE;
d152 1
a152 2

	return TRUE;
d156 1
a156 2
help_help(f, n)
	int f, n;
d162 1
a162 1
		return FALSE;
d171 1
a171 1
	return (*funct)(f, n);
d176 1
a176 2
apropos_command(f, n)
	int f, n;
d183 1
a183 1
		return ABORT;
d187 1
a187 1
		return FALSE;
d202 1
a202 1
			return FALSE;
d206 1
a206 1
	return popbuftop(bp);
d212 4
a215 4
	KEYMAP *newmap;
	PF nfun;
	char buf2[16], key[16];
	int c;
d222 1
a222 1
			return TRUE;
d228 1
a228 1
				return TRUE;
d232 1
a232 2

	return FALSE;
@


1.20
log
@knf
@
text
@d1 1
a1 1
/*	$OpenBSD: help.c,v 1.19 2002/07/01 14:33:44 vincent Exp $	*/
d185 1
a185 1
	char		 string[32];
d187 1
a187 1
	if (eread("apropos: ", string, sizeof(string), EFNEW) == ABORT)
@


1.19
log
@KNF + ansi; from zyrnix (only the easy part of his diffs)
@
text
@d1 1
a1 1
/*	$OpenBSD: help.c,v 1.18 2002/06/21 05:37:20 vincent Exp $	*/
d113 1
a113 1
	bp->b_flag |= BFREADONLY;	
@


1.18
log
@fix bad usage of strlcpy()'s return value. (made pointers point
beyond the boundaries of buffers)

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: help.c,v 1.17 2002/03/16 19:30:29 vincent Exp $	*/
d144 1
a144 1
		snprintf(key, sizeof key, "%s%s ", prefix, buf);
d232 1
a232 1
				snprintf(buf, len, "%s %s", key, buf2);
@


1.17
log
@ Make these special buffers readonly by default. ok art@@
@
text
@d1 1
a1 1
/*	$OpenBSD: help.c,v 1.16 2002/03/11 13:02:56 vincent Exp $	*/
d31 1
a31 1
	int	 c, m, i;
d39 4
a42 1
	pep = prompt + strlcpy(prompt, "Describe key briefly: ", sizeof(prompt));
@


1.16
log
@  * Move to ANSI function definitions.
  * Add a whole lot of consts where I thought it made sense

   no ok, but no objections either...
@
text
@d1 1
a1 1
/*	$OpenBSD: help.c,v 1.15 2001/11/25 07:34:17 deraadt Exp $	*/
d110 1
@


1.15
log
@snprintf makes me happy
@
text
@d1 1
a1 1
/*	$OpenBSD: help.c,v 1.14 2001/05/24 09:47:34 art Exp $	*/
d86 1
a86 1
	else if ((pep = function_name(funct)) != NULL)
@


1.14
log
@Break out function -> name mappings to an own file.
Add a possibility to dynamically extend the function table.
@
text
@d1 1
a1 1
/*	$OpenBSD: help.c,v 1.13 2001/05/24 09:06:21 art Exp $	*/
d140 1
a140 1
		sprintf(key, "%s%s ", prefix, buf);
@


1.13
log
@Give the arguments in the right order to keyname.
@
text
@d1 1
a1 1
/*	$OpenBSD: help.c,v 1.12 2001/05/24 03:05:23 mickey Exp $	*/
d8 1
@


1.12
log
@spaces
@
text
@d1 1
a1 1
/*	$OpenBSD: help.c,v 1.11 2001/05/23 23:29:47 mickey Exp $	*/
d138 1
a138 1
		keyname(buf, c, sizeof(buf));
d221 1
a221 1
			keyname(buf, c, len);
d226 1
a226 1
				keyname(key, c, sizeof(key));
@


1.11
log
@cinfo is const, keyname() and findbind() take buffer size to use strlcpy vs cpy+len
@
text
@d1 1
a1 1
/*	$OpenBSD: help.c,v 1.10 2001/05/23 22:20:35 art Exp $	*/
d4 1
a4 1
 * Help functions for Mg 2 
d233 1
a233 1
	return FALSE;	
@


1.10
log
@remove VOID. We're way beyond the point where this could build with an
ancient compiler.
@
text
@d1 1
a1 1
/*	$OpenBSD: help.c,v 1.9 2001/05/23 22:12:10 art Exp $	*/
d17 1
a17 1
static int	findbind(KEYMAP *, PF, char *);
d38 1
a38 2
	strcpy(prompt, "Describe key briefly: ");
	pep = prompt + strlen(prompt);
d46 2
a47 2
			pep = keyname(pep, key.k_chars[key.k_count++] =
			    c = getkey(FALSE));
d138 1
a138 1
		keyname(buf, c);
d197 2
a198 1
		findbind(fundamental_map, name_function(el->l_name), buf);
d210 1
a210 1
findbind(KEYMAP *map, PF fun, char *buf)
d221 1
a221 1
			keyname(buf, c);
d225 3
a227 3
			if (findbind(newmap, fun, buf2) == TRUE) {
				keyname(key, c);
				sprintf(buf, "%s %s", key, buf2);
@


1.9
log
@Use 'fundamental_map' where 'map_table[0].p_map' or 'name_map("fundamental")'
were used.
@
text
@d1 1
a1 1
/*	$OpenBSD: help.c,v 1.8 2001/05/23 21:47:33 art Exp $	*/
d38 1
a38 1
	(VOID)strcpy(prompt, "Describe key briefly: ");
@


1.8
log
@Simplify a lot of code in the help functions.
It might be a bit more cpu-intensive now, but it shrinks the code a lot.
@
text
@d1 1
a1 1
/*	$OpenBSD: help.c,v 1.7 2001/05/23 21:01:16 art Exp $	*/
d118 1
a118 1
	    (showall(bp, map_table[0].p_map, "") == FALSE))
d193 1
d196 1
d198 1
a198 2
		findbind(name_map("fundamental"),
			name_function(el->l_name), buf);
@


1.7
log
@When a key is bound to selfinsert, it shouldn't be considered to be bound
to anything.
@
text
@d1 1
a1 1
/*	$OpenBSD: help.c,v 1.6 2001/05/23 20:19:44 art Exp $	*/
d16 2
a17 8
static int	showall		__P((char *ind, KEYMAP *map));
static VOID	findbind	__P((PF, char *, KEYMAP *));
static VOID	bindfound	__P((void));

static BUFFER  *bp;
static char     buf[80];	/* used by showall and findbind */
static char     buf2[128];
static char    *buf2p;
d104 1
a104 1
	static char	 locbind[80] = "Local keybindings for mode ";
d111 3
a113 4
		(VOID)strcpy(&locbind[27], curbp->b_modes[m]->p_name);
		(VOID)strcat(&locbind[27], ":");
		if ((addline(bp, locbind) == FALSE) ||
		    (showall(buf, curbp->b_modes[m]->p_map) == FALSE) ||
d118 1
a118 1
	    (showall(buf, map_table[0].p_map) == FALSE))
d124 1
a124 3
showall(ind, map)
	char   *ind;
	KEYMAP *map;
d126 4
a129 4
	MAP_ELEMENT	*ele;
	PF		 functp;
	int		 i, last;
	char		*cp, *cp2;
d133 10
a142 14
	last = -1;
	for (ele = &map->map_element[0]; 
	    ele < &map->map_element[map->map_num]; ele++) {
		if (map->map_default != rescan && ++last < ele->k_base) {
			cp = keyname(ind, last);
			if (last < ele->k_base - 1) {
				(VOID)strcpy(cp, " .. ");
				cp = keyname(cp + 4, ele->k_base - 1);
			}
			do {
				*cp++ = ' ';
			} while (cp < &buf[16]);
			(VOID)strcpy(cp, function_name(map->map_default));
			if (addline(bp, buf) == FALSE)
d144 3
a146 33
		}
		last = ele->k_num;
		for (i = ele->k_base; i <= last; i++) {
			functp = ele->k_funcp[i - ele->k_base];
			if (functp != rescan) {
				if (functp != NULL)
					cp2 = function_name(functp);
				else
					cp2 = map_name(ele->k_prefmap);
				if (cp2 != NULL) {
					cp = keyname(ind, i);
					do {
						*cp++ = ' ';
					} while (cp < &buf[16]);
					(VOID)strcpy(cp, cp2);
					if (addline(bp, buf) == FALSE)
						return FALSE;
				}
			}
		}
	}
	for (ele = &map->map_element[0]; 
	    ele < &map->map_element[map->map_num]; ele++) {
		if (ele->k_prefmap != NULL) {
			for (i = ele->k_base;
			    ele->k_funcp[i - ele->k_base] != NULL; i++) {
				if (i >= ele->k_num)
					/* damaged map */
					return FALSE;
			}
			cp = keyname(ind, i);
			*cp++ = ' ';
			if (showall(cp, ele->k_prefmap) == FALSE)
d150 1
d180 1
a180 2
	FUNCTNAMES	*fnp;
	char		*cp1, *cp2;
d189 13
a201 14
	for (fnp = &functnames[0]; fnp < &functnames[nfunct]; fnp++) {
		for (cp1 = fnp->n_name; *cp1; cp1++) {
			cp2 = string;
			while (*cp2 && *cp1 == *cp2)
				cp1++, cp2++;
			if (!*cp2) {
				(VOID)strcpy(buf2, fnp->n_name);
				buf2p = &buf2[strlen(buf2)];
				findbind(fnp->n_funct, buf, map_table[0].p_map);
				if (addline(bp, buf2) == FALSE)
					return FALSE;
				break;
			} else
				cp1 -= cp2 - string;
d204 1
d208 2
a209 5
static VOID
findbind(funct, ind, map)
	KEYMAP *map;
	PF      funct;
	char   *ind;
d211 11
a221 14
	MAP_ELEMENT	*ele;
	int		 i, last;
	char		*cp;

	last = -1;
	for (ele = &map->map_element[0]; 
	    ele < &map->map_element[map->map_num]; ele++) {
		if (map->map_default == funct && ++last < ele->k_base) {
			cp = keyname(ind, last);
			if (last < ele->k_base - 1) {
				(VOID)strcpy(cp, " .. ");
				(VOID)keyname(cp + 4, ele->k_base - 1);
			}
			bindfound();
d223 5
a227 11
		last = ele->k_num;
		for (i = ele->k_base; i <= last; i++) {
			if (funct == ele->k_funcp[i - ele->k_base]) {
				if (funct == NULL) {
					cp = map_name(ele->k_prefmap);
					if (!cp ||
					    strncmp(cp, buf2, strlen(cp)) != 0)
						continue;
				}
				(VOID)keyname(ind, i);
				bindfound();
a230 15
	for (ele = &map->map_element[0]; 
	    ele < &map->map_element[map->map_num]; ele++) {
		if (ele->k_prefmap != NULL) {
			for (i = ele->k_base;
			    ele->k_funcp[i - ele->k_base] != NULL; i++) {
				if (i >= ele->k_num)
					/* damaged */
					return;
			}
			cp = keyname(ind, i);
			*cp++ = ' ';
			findbind(funct, cp, ele->k_prefmap);
		}
	}
}
d232 1
a232 13
static VOID
bindfound()
{
	if (buf2p < &buf2[32]) {
		do {
			*buf2p++ = ' ';
		} while (buf2p < &buf2[32]);
	} else {
		*buf2p++ = ',';
		*buf2p++ = ' ';
	}
	(VOID)strcpy(buf2p, buf);
	buf2p += strlen(buf);
@


1.6
log
@Add an argument to doscan which is a pointer to a KEYMAP pointer.
If that argument is not NULL, we set it to the k_prefmap of the pressed
key if there is one.
This is what most of the users of doscan did anyway, but they did it through
leaked global state.
@
text
@d1 1
a1 1
/*	$OpenBSD: help.c,v 1.5 2001/05/23 16:14:00 art Exp $	*/
d90 1
a90 1
	if (funct == rescan)
@


1.5
log
@Get rid of 'prefix' and use NULL instead.
@
text
@d1 1
a1 1
/*	$OpenBSD: help.c,v 1.4 2001/01/29 01:58:07 niklas Exp $	*/
d55 1
a55 1
			if ((funct = doscan(curmap, c)) != NULL)
a58 1
			curmap = ele->k_prefmap;
d64 1
a64 1
			    TOLOWER(key.k_chars[key.k_count - 1]));
a67 1
				curmap = ele->k_prefmap;
d78 1
a78 1
			funct = doscan(curmap, key.k_chars[i]);
a84 1
			curmap = ele->k_prefmap;
d207 1
a207 1
		funct = doscan(kp, getkey(FALSE));
@


1.4
log
@$OpenBSD$
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d55 1
a55 1
			if ((funct = doscan(curmap, c)) != prefix)
d66 1
a66 1
			if (funct == prefix) {
d81 1
a81 1
			if (funct != prefix) {
d165 1
a165 1
				if (functp != prefix)
d185 1
a185 1
			    ele->k_funcp[i - ele->k_base] != prefix; i++) {
d278 1
a278 1
				if (funct == prefix) {
d293 1
a293 1
			    ele->k_funcp[i - ele->k_base] != prefix; i++) {
@


1.3
log
@More -Wall anmd KNF, from op2@@tomahawk.SQUiSH.org
@
text
@d1 2
@


1.2
log
@The start of KNF + -Wall.  The code has been run through indent but
needs hand fixup.  I stopped at keymap.c...
@
text
@d1 3
a3 1
/* Help functions for Mg 2 */
d12 1
a12 1
#endif
d14 8
a21 3
static int showall	__P((char *ind, KEYMAP *map));
static VOID findbind	__P((PF, char *, KEYMAP *));
static VOID bindfound	__P((void));
d30 1
a30 1
	int     f, n;
d32 5
a36 7
	KEYMAP *curmap;
	PF      funct;
	char   *pep;
	char    prompt[80];
	int     c;
	int     m;
	int     i;
d41 2
a42 2
#endif
	(VOID) strcpy(prompt, "Describe key briefly: ");
a104 3
static BUFFER  *bp;
static char     buf[80];	/* used by showall and findbind */

d108 1
d110 2
a111 2
	int             m;
	static char     locbind[80] = "Local keybindings for mode ";
d115 2
a116 1
		return FALSE;	/* Clear it out.	 */
d118 2
a119 2
		(VOID) strcpy(&locbind[27], curbp->b_modes[m]->p_name);
		(VOID) strcat(&locbind[27], ":");
d133 2
a134 2
	char           *ind;
	KEYMAP         *map;
d136 4
a139 6
	MAP_ELEMENT    *ele;
	int             i;
	PF              functp;
	char           *cp;
	char           *cp2;
	int             last;
d144 2
a145 2
	for (ele = &map->map_element[0]; ele < &map->map_element[map->map_num];
	    ele++) {
d149 1
a149 1
				(VOID) strcpy(cp, " .. ");
d155 1
a155 1
			(VOID) strcpy(cp, function_name(map->map_default));
d172 1
a172 1
					(VOID) strcpy(cp, cp2);
d179 2
a180 2
	for (ele = &map->map_element[0]; ele < &map->map_element[map->map_num];
	    ele++) {
d184 2
a185 1
				if (i >= ele->k_num)	/* damaged map */
d199 1
a199 1
	int             f, n;
d201 2
a202 2
	KEYMAP         *kp;
	PF              funct;
d213 2
a214 2
#endif
	return (*funct) (f, n);
a216 3
static char     buf2[128];
static char    *buf2p;

d220 1
a220 1
	int             f, n;
d222 4
a225 4
	char           *cp1, *cp2;
	char            string[32];
	FUNCTNAMES     *fnp;
	BUFFER         *bp;
d239 1
a239 1
				(VOID) strcpy(buf2, fnp->n_name);
d254 3
a256 3
	PF              funct;
	char           *ind;
	KEYMAP         *map;
d258 3
a260 4
	MAP_ELEMENT    *ele;
	int             i;
	char           *cp;
	int             last;
d263 2
a264 2
	for (ele = &map->map_element[0]; ele < &map->map_element[map->map_num];
	    ele++) {
d268 2
a269 2
				(VOID) strcpy(cp, " .. ");
				(VOID) keyname(cp + 4, ele->k_base - 1);
d282 1
a282 1
				(VOID) keyname(ind, i);
d287 2
a288 2
	for (ele = &map->map_element[0]; ele < &map->map_element[map->map_num];
	    ele++) {
d293 2
a294 1
					return;	/* damaged */
a305 1

d314 1
a314 1
	(VOID) strcpy(buf2p, buf);
d317 1
a317 1
#endif
@


1.1
log
@initial import of mg2a
@
text
@d1 1
a1 1
/* Help functions for MicroGnuEmacs 2 */
d11 4
a14 1
extern int rescan();
d17 2
a18 3
 * Read a key from the keyboard, and look it
 * up in the keymap.  Display the name of the function
 * currently bound to the key.
d20 2
a21 1
/*ARGSUSED*/
d23 1
d25 7
a31 7
    register KEYMAP *curmap;
    register PF funct;
    register char *pep;
    char prompt[80];
    int c;
    int m;
    int i;
d34 2
a35 1
    if(inmacro) return TRUE;		/* ignore inside keyboard macro */
d37 45
a81 19
    (VOID) strcpy(prompt, "Describe key briefly: ");
    pep = prompt + strlen(prompt);
    key.k_count = 0;
    m = curbp->b_nmodes;
    curmap = curbp->b_modes[m]->p_map;
    for(;;) {
	for(;;) {
	    ewprintf("%s", prompt);
	    pep[-1] = ' ';
	    pep = keyname(pep, key.k_chars[key.k_count++] = c = getkey(FALSE));
	    if((funct = doscan(curmap, c)) != prefix) break;
	    *pep++ = '-';
	    *pep = '\0';
	    curmap = ele->k_prefmap;
	}
	if(funct != rescan) break;
	if(ISUPPER(key.k_chars[key.k_count-1])) {
	    funct = doscan(curmap, TOLOWER(key.k_chars[key.k_count-1]));
	    if(funct == prefix) {
a83 4
		curmap = ele->k_prefmap;
		continue;
	    }
	    if(funct != rescan) break;
a84 15
nextmode:
	if(--m < 0) break;
	curmap = curbp->b_modes[m]->p_map;
	for(i=0; i < key.k_count; i++) {
	    funct = doscan(curmap, key.k_chars[i]);
	    if(funct != prefix) {
		if(i == key.k_count - 1 && funct != rescan) goto found;
		funct = rescan;
		goto nextmode;
	    }
	    curmap = ele->k_prefmap;
	}
	*pep++ = '-';
	*pep = '\0';
    }
d86 7
a92 5
    if(funct == rescan) ewprintf("%k is not bound to any function");
    else if((pep = function_name(funct)) != NULL)
	    ewprintf("%k runs the command %s", pep);
    else    ewprintf("%k is bound to an unnamed function");
    return TRUE;
d96 3
a98 4
 * This function creates a table, listing all
 * of the command keys and their current bindings, and stores
 * the table in the *help* pop-up buffer.  This
 * lets MicroGnuEMACS produce it's own wall chart.
d100 2
a101 2
static BUFFER	*bp;
static char buf[80];	/* used by showall and findbind */
d103 2
a104 1
/*ARGSUSED*/
d107 2
a108 3
	int m;
	static char locbind[80] = "Local keybindings for mode ";
	static int showall();
d111 9
a119 7
	if (bclear(bp) != TRUE) return FALSE;	/* Clear it out.	*/
	for(m=curbp->b_nmodes; m > 0; m--) {
	    (VOID) strcpy(&locbind[27], curbp->b_modes[m]->p_name);
	    (VOID) strcat(&locbind[27], ":");
	    if((addline(bp, locbind) == FALSE) ||
		(showall(buf, curbp->b_modes[m]->p_map) == FALSE) ||
		(addline(bp, "") == FALSE)) return FALSE;
d121 3
a123 2
	if((addline(bp, "Global bindings:") == FALSE) ||
	    (showall(buf, map_table[0].p_map) == FALSE)) return FALSE;
d127 4
a130 3
static	int showall(ind, map)
char	*ind;
KEYMAP	*map;
d132 6
a137 6
	register MAP_ELEMENT *ele;
	register int i;
	PF	functp;
	char	*cp;
	char	*cp2;
	int	last;
d139 2
a140 1
	if(addline(bp, "") == FALSE) return FALSE;
d142 14
a155 6
	for(ele = &map->map_element[0]; ele < &map->map_element[map->map_num] ; ele++) {
	    if(map->map_default != rescan && ++last < ele->k_base) {
		cp = keyname(ind, last);
		if(last < ele->k_base - 1) {
		    (VOID) strcpy(cp, " .. ");
		    cp = keyname(cp + 4, ele->k_base - 1);
d157 18
a174 16
		do { *cp++ = ' '; } while(cp < &buf[16]);
		(VOID) strcpy(cp, function_name(map->map_default));
		if(addline(bp, buf) == FALSE) return FALSE;
	    }
	    last = ele->k_num;
	    for(i=ele->k_base; i <= last; i++) {
		functp = ele->k_funcp[i - ele->k_base];
		if(functp != rescan) {
		    if(functp != prefix) cp2 = function_name(functp);
		    else cp2 = map_name(ele->k_prefmap);
		    if(cp2 != NULL) {
			cp = keyname(ind, i);
			do { *cp++ = ' '; } while(cp < &buf[16]);
			(VOID) strcpy(cp, cp2);
			if (addline(bp, buf) == FALSE) return FALSE;
		    }
a175 1
	    }
d177 12
a188 5
	for(ele = &map->map_element[0]; ele < &map->map_element[map->map_num]; ele++) {
	    if(ele->k_prefmap != NULL) {
		for(i = ele->k_base; ele->k_funcp[i - ele->k_base] != prefix; i++) {
		    if(i >= ele->k_num)  /* damaged map */
			return FALSE;
a189 4
		cp = keyname(ind, i);
		*cp++ = ' ';
		if(showall(cp, ele->k_prefmap) == FALSE) return FALSE;
	    }
d194 1
d196 1
a196 1
int f, n;
d198 2
a199 2
    KEYMAP *kp;
    PF	funct;
d201 6
a206 5
    if((kp = name_map("help")) == NULL) return FALSE;
    ewprintf("a b c: ");
    do {
	funct = doscan(kp, getkey(FALSE));
    } while(funct==NULL || funct==help_help);
d208 2
a209 1
    if(macrodef && macrocount < MAXMACRO) macro[macrocount-1].m_funct = funct;
d211 1
a211 1
    return (*funct)(f, n);
d214 2
a215 2
static char buf2[128];
static char *buf2p;
d217 2
a218 1
/*ARGSUSED*/
d220 1
a220 1
int f, n;
d222 4
a225 5
    register char *cp1, *cp2;
    char string[32];
    FUNCTNAMES *fnp;
    BUFFER *bp;
    static VOID findbind();
d227 2
a228 1
    if(eread("apropos: ", string, sizeof(string), EFNEW) == ABORT) return ABORT;
d230 18
a247 14
    bp = bfind("*help*", TRUE);
    if(bclear(bp) == FALSE) return FALSE;
    for(fnp = &functnames[0]; fnp < &functnames[nfunct]; fnp++) {
	for(cp1 = fnp->n_name; *cp1; cp1++) {
	    cp2 = string;
	    while(*cp2 && *cp1 == *cp2)
		cp1++, cp2++;
	    if(!*cp2) {
		(VOID) strcpy(buf2, fnp->n_name);
		buf2p = &buf2[strlen(buf2)];
		findbind(fnp->n_funct, buf, map_table[0].p_map);
		if(addline(bp, buf2) == FALSE) return FALSE;
		break;
	    } else cp1 -= cp2 - string;
d249 1
a249 2
    }
    return popbuftop(bp);
d252 5
a256 4
static VOID findbind(funct, ind, map)
PF funct;
char *ind;
KEYMAP	*map;
d258 29
a286 15
    register MAP_ELEMENT *ele;
    register int i;
    char	*cp;
    int		last;
    static VOID	bindfound();

    last = -1;
    for(ele = &map->map_element[0]; ele < &map->map_element[map->map_num]; ele++) {
	if(map->map_default == funct && ++last < ele->k_base) {
	    cp = keyname(ind, last);
	    if(last < ele->k_base - 1) {
		(VOID) strcpy(cp, " .. ");
		(VOID) keyname(cp + 4, ele->k_base - 1);
	    }
	    bindfound();
d288 11
a298 6
	last = ele->k_num;
	for(i=ele->k_base; i <= last; i++) {
	    if(funct == ele->k_funcp[i - ele->k_base]) {
		if(funct == prefix) {
		    cp = map_name(ele->k_prefmap);
		    if(!cp || strncmp(cp, buf2, strlen(cp)) != 0) continue;
a299 13
		(VOID) keyname(ind, i);
		bindfound();
	    }
	}
    }
    for(ele = &map->map_element[0]; ele < &map->map_element[map->map_num]; ele++) {
	if(ele->k_prefmap != NULL) {
	    for(i = ele->k_base; ele->k_funcp[i - ele->k_base] != prefix; i++) {
		if(i >= ele->k_num) return; /* damaged */
	    }
	    cp = keyname(ind, i);
	    *cp++ = ' ';
	    findbind(funct, cp, ele->k_prefmap);
a300 1
    }
d303 14
a316 9
static VOID bindfound() {
    if(buf2p < &buf2[32]) {
	do { *buf2p++ = ' '; } while(buf2p < &buf2[32]);
    } else {
	*buf2p++ = ',';
	*buf2p++ = ' ';
    }
    (VOID) strcpy(buf2p, buf);
    buf2p += strlen(buf);
@

