head	1.19;
access;
symbols
	OPENBSD_6_2_BASE:1.19
	OPENBSD_6_1:1.19.0.10
	OPENBSD_6_1_BASE:1.19
	OPENBSD_6_0:1.19.0.6
	OPENBSD_6_0_BASE:1.19
	OPENBSD_5_9:1.19.0.2
	OPENBSD_5_9_BASE:1.19
	OPENBSD_5_8:1.19.0.4
	OPENBSD_5_8_BASE:1.19
	OPENBSD_5_7:1.18.0.32
	OPENBSD_5_7_BASE:1.18
	OPENBSD_5_6:1.18.0.36
	OPENBSD_5_6_BASE:1.18
	OPENBSD_5_5:1.18.0.34
	OPENBSD_5_5_BASE:1.18
	OPENBSD_5_4:1.18.0.30
	OPENBSD_5_4_BASE:1.18
	OPENBSD_5_3:1.18.0.28
	OPENBSD_5_3_BASE:1.18
	OPENBSD_5_2:1.18.0.26
	OPENBSD_5_2_BASE:1.18
	OPENBSD_5_1_BASE:1.18
	OPENBSD_5_1:1.18.0.24
	OPENBSD_5_0:1.18.0.22
	OPENBSD_5_0_BASE:1.18
	OPENBSD_4_9:1.18.0.20
	OPENBSD_4_9_BASE:1.18
	OPENBSD_4_8:1.18.0.18
	OPENBSD_4_8_BASE:1.18
	OPENBSD_4_7:1.18.0.14
	OPENBSD_4_7_BASE:1.18
	OPENBSD_4_6:1.18.0.16
	OPENBSD_4_6_BASE:1.18
	OPENBSD_4_5:1.18.0.12
	OPENBSD_4_5_BASE:1.18
	OPENBSD_4_4:1.18.0.10
	OPENBSD_4_4_BASE:1.18
	OPENBSD_4_3:1.18.0.8
	OPENBSD_4_3_BASE:1.18
	OPENBSD_4_2:1.18.0.6
	OPENBSD_4_2_BASE:1.18
	OPENBSD_4_1:1.18.0.4
	OPENBSD_4_1_BASE:1.18
	OPENBSD_4_0:1.18.0.2
	OPENBSD_4_0_BASE:1.18
	OPENBSD_3_9:1.17.0.2
	OPENBSD_3_9_BASE:1.17
	OPENBSD_3_8:1.16.0.2
	OPENBSD_3_8_BASE:1.16
	OPENBSD_3_7:1.14.0.14
	OPENBSD_3_7_BASE:1.14
	OPENBSD_3_6:1.14.0.12
	OPENBSD_3_6_BASE:1.14
	OPENBSD_3_5:1.14.0.10
	OPENBSD_3_5_BASE:1.14
	OPENBSD_3_4:1.14.0.8
	OPENBSD_3_4_BASE:1.14
	OPENBSD_3_3:1.14.0.6
	OPENBSD_3_3_BASE:1.14
	OPENBSD_3_2:1.14.0.4
	OPENBSD_3_2_BASE:1.14
	OPENBSD_3_1:1.14.0.2
	OPENBSD_3_1_BASE:1.14
	OPENBSD_3_0:1.12.0.2
	OPENBSD_3_0_BASE:1.12
	OPENBSD_2_9_BASE:1.4
	OPENBSD_2_9:1.4.0.2
	OPENBSD_2_8:1.3.0.2
	OPENBSD_2_8_BASE:1.3
	OPENBSD_2_7:1.2.0.2
	OPENBSD_2_7_BASE:1.2;
locks; strict;
comment	@ * @;


1.19
date	2015.03.19.21.48.05;	author bcallah;	state Exp;
branches;
next	1.18;
commitid	8rkHsVfUx5xgPXRB;

1.18
date	2006.07.27.19.59.29;	author deraadt;	state Exp;
branches;
next	1.17;

1.17
date	2005.11.18.20.56.53;	author deraadt;	state Exp;
branches;
next	1.16;

1.16
date	2005.06.14.18.14.40;	author kjell;	state Exp;
branches;
next	1.15;

1.15
date	2005.04.03.02.09.28;	author db;	state Exp;
branches;
next	1.14;

1.14
date	2002.03.11.13.02.56;	author vincent;	state Exp;
branches;
next	1.13;

1.13
date	2002.02.16.21.27.49;	author millert;	state Exp;
branches;
next	1.12;

1.12
date	2001.05.24.10.43.18;	author art;	state Exp;
branches;
next	1.11;

1.11
date	2001.05.24.09.47.34;	author art;	state Exp;
branches;
next	1.10;

1.10
date	2001.05.24.03.05.23;	author mickey;	state Exp;
branches;
next	1.9;

1.9
date	2001.05.23.22.10.43;	author art;	state Exp;
branches;
next	1.8;

1.8
date	2001.05.23.21.59.45;	author art;	state Exp;
branches;
next	1.7;

1.7
date	2001.05.23.20.19.44;	author art;	state Exp;
branches;
next	1.6;

1.6
date	2001.05.23.16.18.56;	author art;	state Exp;
branches;
next	1.5;

1.5
date	2001.05.23.16.14.00;	author art;	state Exp;
branches;
next	1.4;

1.4
date	2001.01.29.01.58.07;	author niklas;	state Exp;
branches;
next	1.3;

1.3
date	2000.09.01.14.59.08;	author millert;	state Exp;
branches;
next	1.2;

1.2
date	2000.04.13.06.12.15;	author millert;	state Exp;
branches;
next	1.1;

1.1
date	2000.02.25.19.08.48;	author deraadt;	state Exp;
branches;
next	;


desc
@@


1.19
log
@More unifdef cleanup:
-UDIRED_XMAPS and -UFUND_XMAPS: you can't build mg the other way.
-DTIOCGWINSZ: you have this if you have term.h
Remove a #define TERMCAP which isn't being used.

Remove defines for NDIRED_XMAPS, NFUND_XMAPS, and IMAPEXT. They are all
defined to be 0 and are only ever used in addition. We don't need to add 0.
Simply lines that were using those defines.
ok florian@@
@
text
@/*	$OpenBSD: kbd.h,v 1.18 2006/07/27 19:59:29 deraadt Exp $	*/

/* This file is in the public domain. */

/*
 * kbd.h: type definitions for symbol.c and kbd.c for mg experimental
 */

struct map_element {
	KCHAR		 k_base;	/* first key in element		 */
	KCHAR		 k_num;		/* last key in element		 */
	PF		*k_funcp;	/* pointer to array of pointers	 */
					/* to functions			 */
	struct keymap_s *k_prefmap;	/* keymap of ONLY prefix key in	 */
					/* element			 */
};

/*
 * Predefined keymaps are NOT type KEYMAP because final array needs
 * dimension.  If any changes are made to this struct, they must be reflected
 * in all keymap declarations.
 */

#define KEYMAPE(NUM)	{						\
	short	map_num;			/* elements used */	\
	short	map_max;			/* elements allocated */\
	PF	map_default;			/* default function */	\
	struct map_element map_element[NUM];	/* really [e_max] */	\
}
typedef struct keymap_s KEYMAPE(1) KEYMAP;

/* Number of map_elements to grow an overflowed keymap by */
#define MAPGROW 3
#define MAPINIT (MAPGROW+1)

/* Max number of default bindings added to avoid creating new element */
#define MAPELEDEF 4

struct maps_s {
	KEYMAP		*p_map;
	const char	*p_name;
	struct maps_s	*p_next;
};

extern struct maps_s	*maps;
extern struct maps_s	fundamental_mode;
#define		fundamental_map (fundamental_mode.p_map)

int		 dobindkey(KEYMAP *, const char *, const char *);
KEYMAP		*name_map(const char *);
struct maps_s	*name_mode(const char *);
PF		 doscan(KEYMAP *, int, KEYMAP **);
void		 maps_init(void);
int		 maps_add(KEYMAP *, const char *);

extern struct map_element	*ele;
extern struct maps_s		*defb_modes[];
@


1.18
log
@unused function
@
text
@d1 1
a1 1
/*	$OpenBSD: kbd.h,v 1.17 2005/11/18 20:56:53 deraadt Exp $	*/
a32 1
#define IMAPEXT 0
@


1.17
log
@greedy use of typedef struct was making code harder to read; ok kjell cloder
@
text
@d1 1
a1 1
/*	$OpenBSD: kbd.h,v 1.16 2005/06/14 18:14:40 kjell Exp $	*/
a53 1
const		 char *map_name(KEYMAP *);
@


1.16
log
@Add explicit public domain notices to all public domain files.
ok millert@@, deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: kbd.h,v 1.15 2005/04/03 02:09:28 db Exp $	*/
d9 4
a12 4
typedef struct {
	KCHAR	 k_base;		/* first key in element		 */
	KCHAR	 k_num;			/* last key in element		 */
	PF	*k_funcp;		/* pointer to array of pointers	 */
d16 1
a16 1
} MAP_ELEMENT;
d25 4
a28 4
	short	map_num;		/* elements used */		\
	short	map_max;		/* elements allocated */	\
	PF	map_default;		/* default function */		\
	MAP_ELEMENT map_element[NUM];	/* really [e_max] */		\
d40 1
a40 1
typedef struct MAPS_S {
d43 2
a44 2
	struct MAPS_S	*p_next;
} MAPS;
d46 2
a47 2
extern MAPS	*maps;
extern MAPS	fundamental_mode;
d50 7
a56 7
int	 dobindkey(KEYMAP *, const char *, const char *);
KEYMAP	*name_map(const char *);
MAPS	*name_mode(const char *);
PF	 doscan(KEYMAP *, int, KEYMAP **);
const	 char *map_name(KEYMAP *);
void	 maps_init(void);
int	 maps_add(KEYMAP *, const char *);
d58 2
a59 2
extern MAP_ELEMENT	*ele;
extern MAPS		*defb_modes[];
@


1.15
log
@This is a no binary change which does:

- spelling, punctuation fixes
- variable declaration lineup
- use parentheses for return and sizeof
- K&R function declarations -> ANSI
- other minor code beautification

ok henning@@
@
text
@d1 3
a3 1
/*	$OpenBSD: kbd.h,v 1.14 2002/03/11 13:02:56 vincent Exp $	*/
@


1.14
log
@  * Move to ANSI function definitions.
  * Add a whole lot of consts where I thought it made sense

   no ok, but no objections either...
@
text
@d1 1
a1 1
/*	$OpenBSD: kbd.h,v 1.13 2002/02/16 21:27:49 millert Exp $	*/
d8 6
a13 6
	KCHAR	k_base;	/* first key in element		 */
	KCHAR	k_num;		/* last key in element		 */
	PF	*k_funcp;	/* pointer to array of pointers
					 * to functions */
	struct keymap_s *k_prefmap;	/* keymap of ONLY prefix key in
					 * element */
d17 1
a17 1
 * predefined keymaps are NOT type KEYMAP because final array needs
d39 3
a41 3
	KEYMAP	*p_map;
	const char *p_name;
	struct MAPS_S *p_next;
@


1.13
log
@Part one of userland __P removal.  Done with a simple regexp with some minor hand editing to make comments line up correctly.  Another pass is forthcoming that handles the cases that could not be done automatically.
@
text
@d1 1
a1 1
/*	$OpenBSD: kbd.h,v 1.12 2001/05/24 10:43:18 art Exp $	*/
d40 1
a40 1
	char	*p_name;
d48 7
a54 7
int	dobindkey(KEYMAP *, char *, char *);
KEYMAP	*name_map(char *);
MAPS	*name_mode(char *);
PF	doscan(KEYMAP *, int, KEYMAP **);
char	*map_name(KEYMAP *);
void	maps_init(void);
int	maps_add(KEYMAP *, char *);
@


1.12
log
@Make the keymap/mode table growable in runtime.
@
text
@d1 1
a1 1
/*	$OpenBSD: kbd.h,v 1.11 2001/05/24 09:47:34 art Exp $	*/
d48 5
a52 5
int	dobindkey		__P((KEYMAP *, char *, char *));
KEYMAP	*name_map		__P((char *));
MAPS	*name_mode		__P((char *));
PF	doscan			__P((KEYMAP *, int, KEYMAP **));
char	*map_name		__P((KEYMAP *));
@


1.11
log
@Break out function -> name mappings to an own file.
Add a possibility to dynamically extend the function table.
@
text
@d1 1
a1 1
/*	$OpenBSD: kbd.h,v 1.10 2001/05/24 03:05:23 mickey Exp $	*/
d41 1
d44 3
a46 2
extern MAPS	map_table[];
extern KEYMAP	*fundamental_map;
d53 2
@


1.10
log
@spaces
@
text
@d1 1
a1 1
/*	$OpenBSD: kbd.h,v 1.9 2001/05/23 22:10:43 art Exp $	*/
a45 5
typedef struct {
	PF	n_funct;
	char	*n_name;
} FUNCTNAMES;

a49 2
PF	name_function		__P((char *));
char	*function_name		__P((PF));
@


1.9
log
@export "fundamental_map" that points to the fundamental keymap
@
text
@d1 1
a1 1
/*	$OpenBSD: kbd.h,v 1.8 2001/05/23 21:59:45 art Exp $	*/
d8 3
a10 3
	KCHAR            k_base;	/* first key in element		 */
	KCHAR            k_num;		/* last key in element		 */
	PF              *k_funcp;	/* pointer to array of pointers
d39 2
a40 2
	KEYMAP         *p_map;
	char           *p_name;
d43 1
a43 1
extern MAPS     map_table[];
d47 2
a48 2
	PF              n_funct;
	char           *n_name;
d51 7
a57 7
int	 dobindkey		__P((KEYMAP *, char *, char *));
KEYMAP  *name_map		__P((char *));
MAPS    *name_mode		__P((char *));
PF       doscan			__P((KEYMAP *, int, KEYMAP **));
PF       name_function		__P((char *));
char    *function_name		__P((PF));
char    *map_name		__P((KEYMAP *));
@


1.8
log
@No need to export nfunct and functnames now that help doesn't use them
anymore. nfunct isn't used anywhere.
@
text
@d1 1
a1 1
/*	$OpenBSD: kbd.h,v 1.7 2001/05/23 20:19:44 art Exp $	*/
d44 1
@


1.7
log
@Add an argument to doscan which is a pointer to a KEYMAP pointer.
If that argument is not NULL, we set it to the k_prefmap of the pressed
key if there is one.
This is what most of the users of doscan did anyway, but they did it through
leaked global state.
@
text
@d1 1
a1 1
/*	$OpenBSD: kbd.h,v 1.6 2001/05/23 16:18:56 art Exp $	*/
a57 2
extern int		 nfunct;
extern FUNCTNAMES	 functnames[];
@


1.6
log
@remove unused define
@
text
@d1 1
a1 1
/*	$OpenBSD: kbd.h,v 1.5 2001/05/23 16:14:00 art Exp $	*/
d53 1
a53 1
PF       doscan			__P((KEYMAP *, int));
@


1.5
log
@Get rid of 'prefix' and use NULL instead.
@
text
@d1 1
a1 1
/*	$OpenBSD: kbd.h,v 1.4 2001/01/29 01:58:07 niklas Exp $	*/
a28 2

#define none	ctrlg
@


1.4
log
@$OpenBSD$
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
a30 1
#define prefix	(PF)NULL
@


1.3
log
@More -Wall anmd KNF, from op2@@tomahawk.SQUiSH.org
@
text
@d1 2
@


1.2
log
@The start of KNF + -Wall.  The code has been run through indent but
needs hand fixup.  I stopped at keymap.c...
@
text
@d51 3
a56 1
KEYMAP  *name_map		__P((char *));
a57 1
MAPS    *name_mode		__P((char *));
d59 4
a62 3
extern FUNCTNAMES functnames[];
extern int      nfunct;
extern MAP_ELEMENT *ele;
@


1.1
log
@initial import of mg2a
@
text
@d5 13
a17 10
typedef struct	{
	KCHAR	k_base;		/* first key in element			*/
	KCHAR	k_num;		/* last key in element			*/
	PF	*k_funcp;	/* pointer to array of pointers to functions */
	struct	keymap_s	*k_prefmap;	/* keymap of ONLY prefix key in element */
}	MAP_ELEMENT;

/* predefined keymaps are NOT type KEYMAP because final array needs
 * dimension.  If any changes are made to this struct, they must be
 * reflected in all keymap declarations.
d20 5
a24 5
#define KEYMAPE(NUM)	{\
	short	map_num;\
	short	map_max;\
	PF	map_default;\
	MAP_ELEMENT map_element[NUM];\
d26 1
a26 5
		/* elements used		*/
		/* elements allocated		*/
		/* default function		*/
		/* realy [e_max]		*/
typedef struct	keymap_s KEYMAPE(1)	KEYMAP;
d31 1
a31 1
/* number of map_elements to grow an overflowed keymap by */
d36 1
a36 1
/* max number of default bindings added to avoid creating new element */
d40 3
a42 3
	KEYMAP	*p_map;
	char	*p_name;
}	MAPS;
d44 1
a44 1
extern	MAPS	map_table[];
d47 14
a60 16
	PF	n_funct;
	char	*n_name;
}	FUNCTNAMES;

extern	FUNCTNAMES	functnames[];
extern	int	nfunct;

extern	PF	doscan();
extern	PF	name_function();
extern	char	*function_name();
extern	int	complete_function();
extern	KEYMAP	*name_map();
extern	char	*map_name();
extern	MAPS	*name_mode();

extern	MAP_ELEMENT *ele;
@

