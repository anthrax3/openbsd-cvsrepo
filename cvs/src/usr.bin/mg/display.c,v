head	1.48;
access;
symbols
	OPENBSD_6_2:1.48.0.2
	OPENBSD_6_2_BASE:1.48
	OPENBSD_6_1:1.47.0.10
	OPENBSD_6_1_BASE:1.47
	OPENBSD_6_0:1.47.0.6
	OPENBSD_6_0_BASE:1.47
	OPENBSD_5_9:1.47.0.2
	OPENBSD_5_9_BASE:1.47
	OPENBSD_5_8:1.47.0.4
	OPENBSD_5_8_BASE:1.47
	OPENBSD_5_7:1.44.0.2
	OPENBSD_5_7_BASE:1.44
	OPENBSD_5_6:1.41.0.8
	OPENBSD_5_6_BASE:1.41
	OPENBSD_5_5:1.41.0.6
	OPENBSD_5_5_BASE:1.41
	OPENBSD_5_4:1.41.0.2
	OPENBSD_5_4_BASE:1.41
	OPENBSD_5_3:1.39.0.2
	OPENBSD_5_3_BASE:1.39
	OPENBSD_5_2:1.37.0.14
	OPENBSD_5_2_BASE:1.37
	OPENBSD_5_1_BASE:1.37
	OPENBSD_5_1:1.37.0.12
	OPENBSD_5_0:1.37.0.10
	OPENBSD_5_0_BASE:1.37
	OPENBSD_4_9:1.37.0.8
	OPENBSD_4_9_BASE:1.37
	OPENBSD_4_8:1.37.0.6
	OPENBSD_4_8_BASE:1.37
	OPENBSD_4_7:1.37.0.2
	OPENBSD_4_7_BASE:1.37
	OPENBSD_4_6:1.37.0.4
	OPENBSD_4_6_BASE:1.37
	OPENBSD_4_5:1.36.0.4
	OPENBSD_4_5_BASE:1.36
	OPENBSD_4_4:1.36.0.2
	OPENBSD_4_4_BASE:1.36
	OPENBSD_4_3:1.35.0.4
	OPENBSD_4_3_BASE:1.35
	OPENBSD_4_2:1.35.0.2
	OPENBSD_4_2_BASE:1.35
	OPENBSD_4_1:1.33.0.2
	OPENBSD_4_1_BASE:1.33
	OPENBSD_4_0:1.30.0.2
	OPENBSD_4_0_BASE:1.30
	OPENBSD_3_9:1.26.0.2
	OPENBSD_3_9_BASE:1.26
	OPENBSD_3_8:1.22.0.2
	OPENBSD_3_8_BASE:1.22
	OPENBSD_3_7:1.20.0.8
	OPENBSD_3_7_BASE:1.20
	OPENBSD_3_6:1.20.0.6
	OPENBSD_3_6_BASE:1.20
	OPENBSD_3_5:1.20.0.4
	OPENBSD_3_5_BASE:1.20
	OPENBSD_3_4:1.20.0.2
	OPENBSD_3_4_BASE:1.20
	OPENBSD_3_3:1.19.0.4
	OPENBSD_3_3_BASE:1.19
	OPENBSD_3_2:1.19.0.2
	OPENBSD_3_2_BASE:1.19
	OPENBSD_3_1:1.13.0.2
	OPENBSD_3_1_BASE:1.13
	OPENBSD_3_0:1.6.0.2
	OPENBSD_3_0_BASE:1.6
	OPENBSD_2_9_BASE:1.4
	OPENBSD_2_9:1.4.0.2
	OPENBSD_2_8:1.3.0.4
	OPENBSD_2_8_BASE:1.3
	OPENBSD_2_7:1.3.0.2
	OPENBSD_2_7_BASE:1.3;
locks; strict;
comment	@ * @;


1.48
date	2017.07.06.19.27.37;	author schwarze;	state Exp;
branches;
next	1.47;
commitid	cZs3e1I7EhRYitBX;

1.47
date	2015.04.03.22.10.29;	author bcallah;	state Exp;
branches;
next	1.46;
commitid	wYrqn8TPgZG0n5K2;

1.46
date	2015.03.24.22.28.10;	author bcallah;	state Exp;
branches;
next	1.45;
commitid	PCVpTMMH1y45VCt7;

1.45
date	2015.03.19.21.22.15;	author bcallah;	state Exp;
branches;
next	1.44;
commitid	GbEBL4CfPvDkB8hj;

1.44
date	2015.02.17.00.34.33;	author tedu;	state Exp;
branches;
next	1.43;
commitid	xDLdZ12nmjUd4nm6;

1.43
date	2015.02.17.00.32.40;	author tedu;	state Exp;
branches;
next	1.42;
commitid	AXKKQ5O2oacbZOGk;

1.42
date	2014.10.16.17.36.11;	author deraadt;	state Exp;
branches;
next	1.41;
commitid	wAYlH7Tqtpnzluvt;

1.41
date	2013.05.31.18.03.44;	author lum;	state Exp;
branches;
next	1.40;

1.40
date	2013.03.25.11.41.44;	author florian;	state Exp;
branches;
next	1.39;

1.39
date	2012.12.04.10.54.20;	author florian;	state Exp;
branches;
next	1.38;

1.38
date	2012.11.11.20.40.49;	author deraadt;	state Exp;
branches;
next	1.37;

1.37
date	2009.06.04.02.23.37;	author kjell;	state Exp;
branches;
next	1.36;

1.36
date	2008.06.11.19.35.37;	author kjell;	state Exp;
branches;
next	1.35;

1.35
date	2007.05.28.17.52.17;	author kjell;	state Exp;
branches;
next	1.34;

1.34
date	2007.03.29.17.37.15;	author kjell;	state Exp;
branches;
next	1.33;

1.33
date	2006.12.24.01.07.59;	author kjell;	state Exp;
branches;
next	1.32;

1.32
date	2006.12.20.21.31.45;	author deraadt;	state Exp;
branches;
next	1.31;

1.31
date	2006.11.19.16.51.19;	author deraadt;	state Exp;
branches;
next	1.30;

1.30
date	2006.07.25.08.22.32;	author kjell;	state Exp;
branches;
next	1.29;

1.29
date	2006.06.01.09.00.50;	author kjell;	state Exp;
branches;
next	1.28;

1.28
date	2006.05.29.00.02.23;	author kjell;	state Exp;
branches;
next	1.27;

1.27
date	2006.05.28.23.30.16;	author kjell;	state Exp;
branches;
next	1.26;

1.26
date	2005.12.13.06.01.27;	author kjell;	state Exp;
branches;
next	1.25;

1.25
date	2005.12.13.05.40.33;	author kjell;	state Exp;
branches;
next	1.24;

1.24
date	2005.11.20.03.53.45;	author deraadt;	state Exp;
branches;
next	1.23;

1.23
date	2005.11.18.20.56.52;	author deraadt;	state Exp;
branches;
next	1.22;

1.22
date	2005.06.14.18.14.40;	author kjell;	state Exp;
branches;
next	1.21;

1.21
date	2005.04.03.02.09.28;	author db;	state Exp;
branches;
next	1.20;

1.20
date	2003.08.15.23.23.18;	author vincent;	state Exp;
branches;
next	1.19;

1.19
date	2002.09.15.13.59.16;	author vincent;	state Exp;
branches;
next	1.18;

1.18
date	2002.08.29.22.45.22;	author vincent;	state Exp;
branches;
next	1.17;

1.17
date	2002.08.22.23.28.19;	author deraadt;	state Exp;
branches;
next	1.16;

1.16
date	2002.08.22.23.21.20;	author vincent;	state Exp;
branches;
next	1.15;

1.15
date	2002.07.01.18.01.40;	author vincent;	state Exp;
branches;
next	1.14;

1.14
date	2002.06.25.14.24.53;	author vincent;	state Exp;
branches;
next	1.13;

1.13
date	2002.03.27.17.42.37;	author millert;	state Exp;
branches;
next	1.12;

1.12
date	2002.03.16.04.17.36;	author vincent;	state Exp;
branches;
next	1.11;

1.11
date	2002.03.11.13.02.56;	author vincent;	state Exp;
branches;
next	1.10;

1.10
date	2002.02.16.21.27.49;	author millert;	state Exp;
branches;
next	1.9;

1.9
date	2002.02.14.14.24.21;	author deraadt;	state Exp;
branches;
next	1.8;

1.8
date	2002.02.14.00.11.46;	author vincent;	state Exp;
branches;
next	1.7;

1.7
date	2002.01.18.08.37.08;	author art;	state Exp;
branches;
next	1.6;

1.6
date	2001.05.24.03.05.22;	author mickey;	state Exp;
branches;
next	1.5;

1.5
date	2001.05.23.22.20.35;	author art;	state Exp;
branches;
next	1.4;

1.4
date	2001.01.29.01.58.07;	author niklas;	state Exp;
branches;
next	1.3;

1.3
date	2000.04.13.06.12.14;	author millert;	state Exp;
branches;
next	1.2;

1.2
date	2000.02.26.22.53.16;	author millert;	state Exp;
branches;
next	1.1;

1.1
date	2000.02.25.19.08.47;	author deraadt;	state Exp;
branches;
next	;


desc
@@


1.48
log
@Fix display of overlong lines containing non-ASCII bytes.
Also fixes a crash reported by Hiltjo Posthuma <hiltjo at codemadness
dot org>, though in a different way than with the patch he sent.
OK florian@@ bcallah@@
@
text
@/*	$OpenBSD: display.c,v 1.47 2015/04/03 22:10:29 bcallah Exp $	*/

/* This file is in the public domain. */

/*
 * The functions in this file handle redisplay. The
 * redisplay system knows almost nothing about the editing
 * process; the editing functions do, however, set some
 * hints to eliminate a lot of the grinding. There is more
 * that can be done; the "vtputc" interface is a real
 * pig.
 */

#include <sys/queue.h>
#include <ctype.h>
#include <signal.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <term.h>

#include "def.h"
#include "kbd.h"

/*
 * A video structure always holds
 * an array of characters whose length is equal to
 * the longest line possible. v_text is allocated
 * dynamically to fit the screen width.
 */
struct video {
	short	v_hash;		/* Hash code, for compares.	 */
	short	v_flag;		/* Flag word.			 */
	short	v_color;	/* Color of the line.		 */
	int	v_cost;		/* Cost of display.		 */
	char	*v_text;	/* The actual characters.	 */
};

#define VFCHG	0x0001			/* Changed.			 */
#define VFHBAD	0x0002			/* Hash and cost are bad.	 */
#define VFEXT	0x0004			/* extended line (beond ncol)	 */

/*
 * SCORE structures hold the optimal
 * trace trajectory, and the cost of redisplay, when
 * the dynamic programming redisplay code is used.
 */
struct score {
	int	s_itrace;	/* "i" index for track back.	 */
	int	s_jtrace;	/* "j" index for trace back.	 */
	int	s_cost;		/* Display cost.		 */
};

void	vtmove(int, int);
void	vtputc(int);
void	vtpute(int);
int	vtputs(const char *);
void	vteeol(void);
void	updext(int, int);
void	modeline(struct mgwin *, int);
void	setscores(int, int);
void	traceback(int, int, int, int);
void	ucopy(struct video *, struct video *);
void	uline(int, struct video *, struct video *);
void	hash(struct video *);


int	sgarbf = TRUE;		/* TRUE if screen is garbage.	 */
int	vtrow = HUGE;		/* Virtual cursor row.		 */
int	vtcol = HUGE;		/* Virtual cursor column.	 */
int	tthue = CNONE;		/* Current color.		 */
int	ttrow = HUGE;		/* Physical cursor row.		 */
int	ttcol = HUGE;		/* Physical cursor column.	 */
int	tttop = HUGE;		/* Top of scroll region.	 */
int	ttbot = HUGE;		/* Bottom of scroll region.	 */
int	lbound = 0;		/* leftmost bound of the current */
				/* line being displayed		 */

struct video	**vscreen;		/* Edge vector, virtual.	 */
struct video	**pscreen;		/* Edge vector, physical.	 */
struct video	 *video;		/* Actual screen data.		 */
struct video	  blanks;		/* Blank line image.		 */

/*
 * This matrix is written as an array because
 * we do funny things in the "setscores" routine, which
 * is very compute intensive, to make the subscripts go away.
 * It would be "SCORE	score[NROW][NROW]" in old speak.
 * Look at "setscores" to understand what is up.
 */
struct score *score;			/* [NROW * NROW] */

static int	 linenos = TRUE;
static int	 colnos = FALSE;

/* Is macro recording enabled? */
extern int macrodef;
/* Is working directory global? */
extern int globalwd;

/*
 * Since we don't have variables (we probably should) these are command
 * processors for changing the values of mode flags.
 */
/* ARGSUSED */
int
linenotoggle(int f, int n)
{
	if (f & FFARG)
		linenos = n > 0;
	else
		linenos = !linenos;

	sgarbf = TRUE;

	return (TRUE);
}

/* ARGSUSED */
int
colnotoggle(int f, int n)
{
	if (f & FFARG)
		colnos = n > 0;
	else
		colnos = !colnos;

	sgarbf = TRUE;

	return (TRUE);
}

/*
 * Reinit the display data structures, this is called when the terminal
 * size changes.
 */
int
vtresize(int force, int newrow, int newcol)
{
	int	 i;
	int	 rowchanged, colchanged;
	static	 int first_run = 1;
	struct video	*vp;

	if (newrow < 1 || newcol < 1)
		return (FALSE);

	rowchanged = (newrow != nrow);
	colchanged = (newcol != ncol);

#define TRYREALLOC(a, n) do {					\
		void *tmp;					\
		if ((tmp = realloc((a), (n))) == NULL) {	\
			panic("out of memory in display code");	\
		}						\
		(a) = tmp;					\
	} while (0)

#define TRYREALLOCARRAY(a, n, m) do {				\
		void *tmp;					\
		if ((tmp = reallocarray((a), (n), (m))) == NULL) {\
			panic("out of memory in display code");	\
		}						\
		(a) = tmp;					\
	} while (0)

	/* No update needed */
	if (!first_run && !force && !rowchanged && !colchanged)
		return (TRUE);

	if (first_run)
		memset(&blanks, 0, sizeof(blanks));

	if (rowchanged || first_run) {
		int vidstart;

		/*
		 * This is not pretty.
		 */
		if (nrow == 0)
			vidstart = 0;
		else
			vidstart = 2 * (nrow - 1);

		/*
		 * We're shrinking, free some internal data.
		 */
		if (newrow < nrow) {
			for (i = 2 * (newrow - 1); i < 2 * (nrow - 1); i++) {
				free(video[i].v_text);
				video[i].v_text = NULL;
			}
		}

		TRYREALLOCARRAY(score, newrow, newrow * sizeof(struct score));
		TRYREALLOCARRAY(vscreen, (newrow - 1), sizeof(struct video *));
		TRYREALLOCARRAY(pscreen, (newrow - 1), sizeof(struct video *));
		TRYREALLOCARRAY(video, (newrow - 1), 2 * sizeof(struct video));

		/*
		 * Zero-out the entries we just allocated.
		 */
		for (i = vidstart; i < 2 * (newrow - 1); i++)
			memset(&video[i], 0, sizeof(struct video));

		/*
		 * Reinitialize vscreen and pscreen arrays completely.
		 */
		vp = &video[0];
		for (i = 0; i < newrow - 1; ++i) {
			vscreen[i] = vp;
			++vp;
			pscreen[i] = vp;
			++vp;
		}
	}
	if (rowchanged || colchanged || first_run) {
		for (i = 0; i < 2 * (newrow - 1); i++)
			TRYREALLOC(video[i].v_text, newcol);
		TRYREALLOC(blanks.v_text, newcol);
	}

	nrow = newrow;
	ncol = newcol;

	if (ttrow > nrow)
		ttrow = nrow;
	if (ttcol > ncol)
		ttcol = ncol;

	first_run = 0;
	return (TRUE);
}

#undef TRYREALLOC
#undef TRYREALLOCARRAY

/*
 * Initialize the data structures used
 * by the display code. The edge vectors used
 * to access the screens are set up. The operating
 * system's terminal I/O channel is set up. Fill the
 * "blanks" array with ASCII blanks. The rest is done
 * at compile time. The original window is marked
 * as needing full update, and the physical screen
 * is marked as garbage, so all the right stuff happens
 * on the first call to redisplay.
 */
void
vtinit(void)
{
	int	i;

	ttopen();
	ttinit();

	/*
	 * ttinit called ttresize(), which called vtresize(), so our data
	 * structures are setup correctly.
	 */

	blanks.v_color = CTEXT;
	for (i = 0; i < ncol; ++i)
		blanks.v_text[i] = ' ';
}

/*
 * Tidy up the virtual display system
 * in anticipation of a return back to the host
 * operating system. Right now all we do is position
 * the cursor to the last line, erase the line, and
 * close the terminal channel.
 */
void
vttidy(void)
{
	ttcolor(CTEXT);
	ttnowindow();		/* No scroll window.	 */
	ttmove(nrow - 1, 0);	/* Echo line.		 */
	tteeol();
	tttidy();
	ttflush();
	ttclose();
}

/*
 * Move the virtual cursor to an origin
 * 0 spot on the virtual display screen. I could
 * store the column as a character pointer to the spot
 * on the line, which would make "vtputc" a little bit
 * more efficient. No checking for errors.
 */
void
vtmove(int row, int col)
{
	vtrow = row;
	vtcol = col;
}

/*
 * Write a character to the virtual display,
 * dealing with long lines and the display of unprintable
 * things like control characters. Also expand tabs every 8
 * columns. This code only puts printing characters into
 * the virtual display image. Special care must be taken when
 * expanding tabs. On a screen whose width is not a multiple
 * of 8, it is possible for the virtual cursor to hit the
 * right margin before the next tab stop is reached. This
 * makes the tab code loop if you are not careful.
 * Three guesses how we found this.
 */
void
vtputc(int c)
{
	struct video	*vp;

	c &= 0xff;

	vp = vscreen[vtrow];
	if (vtcol >= ncol)
		vp->v_text[ncol - 1] = '$';
	else if (c == '\t'
#ifdef	NOTAB
	    && !(curbp->b_flag & BFNOTAB)
#endif
	    ) {
		do {
			vtputc(' ');
		} while (vtcol < ncol && (vtcol & 0x07) != 0);
	} else if (ISCTRL(c)) {
		vtputc('^');
		vtputc(CCHR(c));
	} else if (isprint(c))
		vp->v_text[vtcol++] = c;
	else {
		char bf[5];

		snprintf(bf, sizeof(bf), "\\%o", c);
		vtputs(bf);
	}
}

/*
 * Put a character to the virtual screen in an extended line.  If we are not
 * yet on left edge, don't print it yet.  Check for overflow on the right
 * margin.
 */
void
vtpute(int c)
{
	struct video *vp;

	c &= 0xff;

	vp = vscreen[vtrow];
	if (vtcol >= ncol)
		vp->v_text[ncol - 1] = '$';
	else if (c == '\t'
#ifdef	NOTAB
	    && !(curbp->b_flag & BFNOTAB)
#endif
	    ) {
		do {
			vtpute(' ');
		} while (((vtcol + lbound) & 0x07) != 0 && vtcol < ncol);
	} else if (ISCTRL(c) != FALSE) {
		vtpute('^');
		vtpute(CCHR(c));
	} else if (isprint(c)) {
		if (vtcol >= 0)
			vp->v_text[vtcol] = c;
		++vtcol;
	} else {
		char bf[5], *cp;

		snprintf(bf, sizeof(bf), "\\%o", c);
		for (cp = bf; *cp != '\0'; cp++)
			vtpute(*cp);
	}
}

/*
 * Erase from the end of the software cursor to the end of the line on which
 * the software cursor is located. The display routines will decide if a
 * hardware erase to end of line command should be used to display this.
 */
void
vteeol(void)
{
	struct video *vp;

	vp = vscreen[vtrow];
	while (vtcol < ncol)
		vp->v_text[vtcol++] = ' ';
}

/*
 * Make sure that the display is
 * right. This is a three part process. First,
 * scan through all of the windows looking for dirty
 * ones. Check the framing, and refresh the screen.
 * Second, make sure that "currow" and "curcol" are
 * correct for the current window. Third, make the
 * virtual and physical screens the same.
 */
void
update(int modelinecolor)
{
	struct line	*lp;
	struct mgwin	*wp;
	struct video	*vp1;
	struct video	*vp2;
	int	 c, i, j;
	int	 hflag;
	int	 currow, curcol;
	int	 offs, size;

	if (charswaiting())
		return;
	if (sgarbf) {		/* must update everything */
		wp = wheadp;
		while (wp != NULL) {
			wp->w_rflag |= WFMODE | WFFULL;
			wp = wp->w_wndp;
		}
	}
	if (linenos || colnos) {
		wp = wheadp;
		while (wp != NULL) {
			wp->w_rflag |= WFMODE;
			wp = wp->w_wndp;
		}
	}
	hflag = FALSE;			/* Not hard. */
	for (wp = wheadp; wp != NULL; wp = wp->w_wndp) {
		/*
		 * Nothing to be done.
		 */
		if (wp->w_rflag == 0)
			continue;

		if ((wp->w_rflag & WFFRAME) == 0) {
			lp = wp->w_linep;
			for (i = 0; i < wp->w_ntrows; ++i) {
				if (lp == wp->w_dotp)
					goto out;
				if (lp == wp->w_bufp->b_headp)
					break;
				lp = lforw(lp);
			}
		}
		/*
		 * Put the middle-line in place.
		 */
		i = wp->w_frame;
		if (i > 0) {
			--i;
			if (i >= wp->w_ntrows)
				i = wp->w_ntrows - 1;
		} else if (i < 0) {
			i += wp->w_ntrows;
			if (i < 0)
				i = 0;
		} else
			i = wp->w_ntrows / 2; /* current center, no change */

		/*
		 * Find the line.
		 */
		lp = wp->w_dotp;
		while (i != 0 && lback(lp) != wp->w_bufp->b_headp) {
			--i;
			lp = lback(lp);
		}
		wp->w_linep = lp;
		wp->w_rflag |= WFFULL;	/* Force full.		 */
	out:
		lp = wp->w_linep;	/* Try reduced update.	 */
		i = wp->w_toprow;
		if ((wp->w_rflag & ~WFMODE) == WFEDIT) {
			while (lp != wp->w_dotp) {
				++i;
				lp = lforw(lp);
			}
			vscreen[i]->v_color = CTEXT;
			vscreen[i]->v_flag |= (VFCHG | VFHBAD);
			vtmove(i, 0);
			for (j = 0; j < llength(lp); ++j)
				vtputc(lgetc(lp, j));
			vteeol();
		} else if ((wp->w_rflag & (WFEDIT | WFFULL)) != 0) {
			hflag = TRUE;
			while (i < wp->w_toprow + wp->w_ntrows) {
				vscreen[i]->v_color = CTEXT;
				vscreen[i]->v_flag |= (VFCHG | VFHBAD);
				vtmove(i, 0);
				if (lp != wp->w_bufp->b_headp) {
					for (j = 0; j < llength(lp); ++j)
						vtputc(lgetc(lp, j));
					lp = lforw(lp);
				}
				vteeol();
				++i;
			}
		}
		if ((wp->w_rflag & WFMODE) != 0)
			modeline(wp, modelinecolor);
		wp->w_rflag = 0;
		wp->w_frame = 0;
	}
	lp = curwp->w_linep;	/* Cursor location. */
	currow = curwp->w_toprow;
	while (lp != curwp->w_dotp) {
		++currow;
		lp = lforw(lp);
	}
	curcol = 0;
	i = 0;
	while (i < curwp->w_doto) {
		c = lgetc(lp, i++);
		if (c == '\t'
#ifdef	NOTAB
		    && !(curbp->b_flag & BFNOTAB)
#endif
			) {
			curcol |= 0x07;
			curcol++;
		} else if (ISCTRL(c) != FALSE)
			curcol += 2;
		else if (isprint(c))
			curcol++;
		else {
			char bf[5];

			snprintf(bf, sizeof(bf), "\\%o", c);
			curcol += strlen(bf);
		}
	}
	if (curcol >= ncol - 1) {	/* extended line. */
		/* flag we are extended and changed */
		vscreen[currow]->v_flag |= VFEXT | VFCHG;
		updext(currow, curcol);	/* and output extended line */
	} else
		lbound = 0;	/* not extended line */

	/*
	 * Make sure no lines need to be de-extended because the cursor is no
	 * longer on them.
	 */
	wp = wheadp;
	while (wp != NULL) {
		lp = wp->w_linep;
		i = wp->w_toprow;
		while (i < wp->w_toprow + wp->w_ntrows) {
			if (vscreen[i]->v_flag & VFEXT) {
				/* always flag extended lines as changed */
				vscreen[i]->v_flag |= VFCHG;
				if ((wp != curwp) || (lp != wp->w_dotp) ||
				    (curcol < ncol - 1)) {
					vtmove(i, 0);
					for (j = 0; j < llength(lp); ++j)
						vtputc(lgetc(lp, j));
					vteeol();
					/* this line no longer is extended */
					vscreen[i]->v_flag &= ~VFEXT;
				}
			}
			lp = lforw(lp);
			++i;
		}
		/* if garbaged then fix up mode lines */
		if (sgarbf != FALSE)
			vscreen[i]->v_flag |= VFCHG;
		/* and onward to the next window */
		wp = wp->w_wndp;
	}

	if (sgarbf != FALSE) {	/* Screen is garbage.	 */
		sgarbf = FALSE;	/* Erase-page clears.	 */
		epresf = FALSE;	/* The message area.	 */
		tttop = HUGE;	/* Forget where you set. */
		ttbot = HUGE;	/* scroll region.	 */
		tthue = CNONE;	/* Color unknown.	 */
		ttmove(0, 0);
		tteeop();
		for (i = 0; i < nrow - 1; ++i) {
			uline(i, vscreen[i], &blanks);
			ucopy(vscreen[i], pscreen[i]);
		}
		ttmove(currow, curcol - lbound);
		ttflush();
		return;
	}
	if (hflag != FALSE) {			/* Hard update?		*/
		for (i = 0; i < nrow - 1; ++i) {/* Compute hash data.	*/
			hash(vscreen[i]);
			hash(pscreen[i]);
		}
		offs = 0;			/* Get top match.	*/
		while (offs != nrow - 1) {
			vp1 = vscreen[offs];
			vp2 = pscreen[offs];
			if (vp1->v_color != vp2->v_color
			    || vp1->v_hash != vp2->v_hash)
				break;
			uline(offs, vp1, vp2);
			ucopy(vp1, vp2);
			++offs;
		}
		if (offs == nrow - 1) {		/* Might get it all.	*/
			ttmove(currow, curcol - lbound);
			ttflush();
			return;
		}
		size = nrow - 1;		/* Get bottom match.	*/
		while (size != offs) {
			vp1 = vscreen[size - 1];
			vp2 = pscreen[size - 1];
			if (vp1->v_color != vp2->v_color
			    || vp1->v_hash != vp2->v_hash)
				break;
			uline(size - 1, vp1, vp2);
			ucopy(vp1, vp2);
			--size;
		}
		if ((size -= offs) == 0)	/* Get screen size.	*/
			panic("Illegal screen size in update");
		setscores(offs, size);		/* Do hard update.	*/
		traceback(offs, size, size, size);
		for (i = 0; i < size; ++i)
			ucopy(vscreen[offs + i], pscreen[offs + i]);
		ttmove(currow, curcol - lbound);
		ttflush();
		return;
	}
	for (i = 0; i < nrow - 1; ++i) {	/* Easy update.		*/
		vp1 = vscreen[i];
		vp2 = pscreen[i];
		if ((vp1->v_flag & VFCHG) != 0) {
			uline(i, vp1, vp2);
			ucopy(vp1, vp2);
		}
	}
	ttmove(currow, curcol - lbound);
	ttflush();
}

/*
 * Update a saved copy of a line,
 * kept in a video structure. The "vvp" is
 * the one in the "vscreen". The "pvp" is the one
 * in the "pscreen". This is called to make the
 * virtual and physical screens the same when
 * display has done an update.
 */
void
ucopy(struct video *vvp, struct video *pvp)
{
	vvp->v_flag &= ~VFCHG;		/* Changes done.	 */
	pvp->v_flag = vvp->v_flag;	/* Update model.	 */
	pvp->v_hash = vvp->v_hash;
	pvp->v_cost = vvp->v_cost;
	pvp->v_color = vvp->v_color;
	bcopy(vvp->v_text, pvp->v_text, ncol);
}

/*
 * updext: update the extended line which the cursor is currently on at a
 * column greater than the terminal width. The line will be scrolled right or
 * left to let the user see where the cursor is.
 */
void
updext(int currow, int curcol)
{
	struct line	*lp;			/* pointer to current line */
	int	 j;			/* index into line */

	if (ncol < 2)
		return;

	/*
	 * calculate what column the left bound should be
	 * (force cursor into middle half of screen)
	 */
	lbound = curcol - (curcol % (ncol >> 1)) - (ncol >> 2);

	/*
	 * scan through the line outputing characters to the virtual screen
	 * once we reach the left edge
	 */
	vtmove(currow, -lbound);		/* start scanning offscreen */
	lp = curwp->w_dotp;			/* line to output */
	for (j = 0; j < llength(lp); ++j)	/* until the end-of-line */
		vtpute(lgetc(lp, j));
	vteeol();				/* truncate the virtual line */
	vscreen[currow]->v_text[0] = '$';	/* and put a '$' in column 1 */
}

/*
 * Update a single line. This routine only
 * uses basic functionality (no insert and delete character,
 * but erase to end of line). The "vvp" points at the video
 * structure for the line on the virtual screen, and the "pvp"
 * is the same for the physical screen. Avoid erase to end of
 * line when updating CMODE color lines, because of the way that
 * reverse video works on most terminals.
 */
void
uline(int row, struct video *vvp, struct video *pvp)
{
	char  *cp1;
	char  *cp2;
	char  *cp3;
	char  *cp4;
	char  *cp5;
	int    nbflag;

	if (vvp->v_color != pvp->v_color) {	/* Wrong color, do a	 */
		ttmove(row, 0);			/* full redraw.		 */
#ifdef	STANDOUT_GLITCH
		if (pvp->v_color != CTEXT && magic_cookie_glitch >= 0)
			tteeol();
#endif
		ttcolor(vvp->v_color);
#ifdef	STANDOUT_GLITCH
		cp1 = &vvp->v_text[magic_cookie_glitch > 0 ? magic_cookie_glitch : 0];
		/*
		 * The odd code for magic_cookie_glitch==0 is to avoid
		 * putting the invisible glitch character on the next line.
		 * (Hazeltine executive 80 model 30)
		 */
		cp2 = &vvp->v_text[ncol - (magic_cookie_glitch >= 0 ?
		    (magic_cookie_glitch != 0 ? magic_cookie_glitch : 1) : 0)];
#else
		cp1 = &vvp->v_text[0];
		cp2 = &vvp->v_text[ncol];
#endif
		while (cp1 != cp2) {
			ttputc(*cp1++);
			++ttcol;
		}
		ttcolor(CTEXT);
		return;
	}
	cp1 = &vvp->v_text[0];		/* Compute left match.	 */
	cp2 = &pvp->v_text[0];
	while (cp1 != &vvp->v_text[ncol] && cp1[0] == cp2[0]) {
		++cp1;
		++cp2;
	}
	if (cp1 == &vvp->v_text[ncol])	/* All equal.		 */
		return;
	nbflag = FALSE;
	cp3 = &vvp->v_text[ncol];	/* Compute right match.  */
	cp4 = &pvp->v_text[ncol];
	while (cp3[-1] == cp4[-1]) {
		--cp3;
		--cp4;
		if (cp3[0] != ' ')	/* Note non-blanks in	 */
			nbflag = TRUE;	/* the right match.	 */
	}
	cp5 = cp3;			/* Is erase good?	 */
	if (nbflag == FALSE && vvp->v_color == CTEXT) {
		while (cp5 != cp1 && cp5[-1] == ' ')
			--cp5;
		/* Alcyon hack */
		if ((int) (cp3 - cp5) <= tceeol)
			cp5 = cp3;
	}
	/* Alcyon hack */
	ttmove(row, (int) (cp1 - &vvp->v_text[0]));
#ifdef	STANDOUT_GLITCH
	if (vvp->v_color != CTEXT && magic_cookie_glitch > 0) {
		if (cp1 < &vvp->v_text[magic_cookie_glitch])
			cp1 = &vvp->v_text[magic_cookie_glitch];
		if (cp5 > &vvp->v_text[ncol - magic_cookie_glitch])
			cp5 = &vvp->v_text[ncol - magic_cookie_glitch];
	} else if (magic_cookie_glitch < 0)
#endif
		ttcolor(vvp->v_color);
	while (cp1 != cp5) {
		ttputc(*cp1++);
		++ttcol;
	}
	if (cp5 != cp3)			/* Do erase.		 */
		tteeol();
}

/*
 * Redisplay the mode line for the window pointed to by the "wp".
 * This is the only routine that has any idea of how the mode line is
 * formatted. You can change the modeline format by hacking at this
 * routine. Called by "update" any time there is a dirty window.  Note
 * that if STANDOUT_GLITCH is defined, first and last magic_cookie_glitch
 * characters may never be seen.
 */
void
modeline(struct mgwin *wp, int modelinecolor)
{
	int	n, md;
	struct buffer *bp;
	char sl[21];		/* Overkill. Space for 2^64 in base 10. */
	int len;

	n = wp->w_toprow + wp->w_ntrows;	/* Location.		 */
	vscreen[n]->v_color = modelinecolor;	/* Mode line color.	 */
	vscreen[n]->v_flag |= (VFCHG | VFHBAD);	/* Recompute, display.	 */
	vtmove(n, 0);				/* Seek to right line.	 */
	bp = wp->w_bufp;
	vtputc('-');
	vtputc('-');
	if ((bp->b_flag & BFREADONLY) != 0) {
		vtputc('%');
		if ((bp->b_flag & BFCHG) != 0)
			vtputc('*');
		else
			vtputc('%');
	} else if ((bp->b_flag & BFCHG) != 0) {	/* "*" if changed.	 */
		vtputc('*');
		vtputc('*');
	} else {
		vtputc('-');
		vtputc('-');
	}
	vtputc('-');
	n = 5;
	n += vtputs("Mg: ");
	if (bp->b_bname[0] != '\0')
		n += vtputs(&(bp->b_bname[0]));
	while (n < 42) {			/* Pad out with blanks.	 */
		vtputc(' ');
		++n;
	}
	vtputc('(');
	++n;
	for (md = 0; ; ) {
		n += vtputs(bp->b_modes[md]->p_name);
		if (++md > bp->b_nmodes)
			break;
		vtputc('-');
		++n;
	}
	/* XXX These should eventually move to a real mode */
	if (macrodef == TRUE)
		n += vtputs("-def");
	if (globalwd == TRUE)
		n += vtputs("-gwd");
	vtputc(')');
	++n;

	if (linenos && colnos)
		len = snprintf(sl, sizeof(sl), "--L%d--C%d", wp->w_dotline,
		    getcolpos(wp));
	else if (linenos)
		len = snprintf(sl, sizeof(sl), "--L%d", wp->w_dotline);
	else if (colnos)
		len = snprintf(sl, sizeof(sl), "--C%d", getcolpos(wp));
	if ((linenos || colnos) && len < sizeof(sl) && len != -1)
		n += vtputs(sl);

	while (n < ncol) {			/* Pad out.		 */
		vtputc('-');
		++n;
	}
}

/*
 * Output a string to the mode line, report how long it was.
 */
int
vtputs(const char *s)
{
	int n = 0;

	while (*s != '\0') {
		vtputc(*s++);
		++n;
	}
	return (n);
}

/*
 * Compute the hash code for the line pointed to by the "vp".
 * Recompute it if necessary. Also set the approximate redisplay
 * cost. The validity of the hash code is marked by a flag bit.
 * The cost understand the advantages of erase to end of line.
 * Tuned for the VAX by Bob McNamara; better than it used to be on
 * just about any machine.
 */
void
hash(struct video *vp)
{
	int	i, n;
	char   *s;

	if ((vp->v_flag & VFHBAD) != 0) {	/* Hash bad.		 */
		s = &vp->v_text[ncol - 1];
		for (i = ncol; i != 0; --i, --s)
			if (*s != ' ')
				break;
		n = ncol - i;			/* Erase cheaper?	 */
		if (n > tceeol)
			n = tceeol;
		vp->v_cost = i + n;		/* Bytes + blanks.	 */
		for (n = 0; i != 0; --i, --s)
			n = (n << 5) + n + *s;
		vp->v_hash = n;			/* Hash code.		 */
		vp->v_flag &= ~VFHBAD;		/* Flag as all done.	 */
	}
}

/*
 * Compute the Insert-Delete
 * cost matrix. The dynamic programming algorithm
 * described by James Gosling is used. This code assumes
 * that the line above the echo line is the last line involved
 * in the scroll region. This is easy to arrange on the VT100
 * because of the scrolling region. The "offs" is the origin 0
 * offset of the first row in the virtual/physical screen that
 * is being updated; the "size" is the length of the chunk of
 * screen being updated. For a full screen update, use offs=0
 * and size=nrow-1.
 *
 * Older versions of this code implemented the score matrix by
 * a two dimensional array of SCORE nodes. This put all kinds of
 * multiply instructions in the code! This version is written to
 * use a linear array and pointers, and contains no multiplication
 * at all. The code has been carefully looked at on the VAX, with
 * only marginal checking on other machines for efficiency. In
 * fact, this has been tuned twice! Bob McNamara tuned it even
 * more for the VAX, which is a big issue for him because of
 * the 66 line X displays.
 *
 * On some machines, replacing the "for (i=1; i<=size; ++i)" with
 * i = 1; do { } while (++i <=size)" will make the code quite a
 * bit better; but it looks ugly.
 */
void
setscores(int offs, int size)
{
	struct score	 *sp;
	struct score	 *sp1;
	struct video	**vp, **pp;
	struct video	**vbase, **pbase;
	int	  tempcost;
	int	  bestcost;
	int	  j, i;

	vbase = &vscreen[offs - 1];	/* By hand CSE's.	 */
	pbase = &pscreen[offs - 1];
	score[0].s_itrace = 0;		/* [0, 0]		 */
	score[0].s_jtrace = 0;
	score[0].s_cost = 0;
	sp = &score[1];			/* Row 0, inserts.	 */
	tempcost = 0;
	vp = &vbase[1];
	for (j = 1; j <= size; ++j) {
		sp->s_itrace = 0;
		sp->s_jtrace = j - 1;
		tempcost += tcinsl;
		tempcost += (*vp)->v_cost;
		sp->s_cost = tempcost;
		++vp;
		++sp;
	}
	sp = &score[nrow];		/* Column 0, deletes.	 */
	tempcost = 0;
	for (i = 1; i <= size; ++i) {
		sp->s_itrace = i - 1;
		sp->s_jtrace = 0;
		tempcost += tcdell;
		sp->s_cost = tempcost;
		sp += nrow;
	}
	sp1 = &score[nrow + 1];		/* [1, 1].		 */
	pp = &pbase[1];
	for (i = 1; i <= size; ++i) {
		sp = sp1;
		vp = &vbase[1];
		for (j = 1; j <= size; ++j) {
			sp->s_itrace = i - 1;
			sp->s_jtrace = j;
			bestcost = (sp - nrow)->s_cost;
			if (j != size)	/* Cd(A[i])=0 @@ Dis.	 */
				bestcost += tcdell;
			tempcost = (sp - 1)->s_cost;
			tempcost += (*vp)->v_cost;
			if (i != size)	/* Ci(B[j])=0 @@ Dsj.	 */
				tempcost += tcinsl;
			if (tempcost < bestcost) {
				sp->s_itrace = i;
				sp->s_jtrace = j - 1;
				bestcost = tempcost;
			}
			tempcost = (sp - nrow - 1)->s_cost;
			if ((*pp)->v_color != (*vp)->v_color
			    || (*pp)->v_hash != (*vp)->v_hash)
				tempcost += (*vp)->v_cost;
			if (tempcost < bestcost) {
				sp->s_itrace = i - 1;
				sp->s_jtrace = j - 1;
				bestcost = tempcost;
			}
			sp->s_cost = bestcost;
			++sp;		/* Next column.		 */
			++vp;
		}
		++pp;
		sp1 += nrow;		/* Next row.		 */
	}
}

/*
 * Trace back through the dynamic programming cost
 * matrix, and update the screen using an optimal sequence
 * of redraws, insert lines, and delete lines. The "offs" is
 * the origin 0 offset of the chunk of the screen we are about to
 * update. The "i" and "j" are always started in the lower right
 * corner of the matrix, and imply the size of the screen.
 * A full screen traceback is called with offs=0 and i=j=nrow-1.
 * There is some do-it-yourself double subscripting here,
 * which is acceptable because this routine is much less compute
 * intensive then the code that builds the score matrix!
 */
void
traceback(int offs, int size, int i, int j)
{
	int	itrace, jtrace;
	int	k;
	int	ninsl, ndraw, ndell;

	if (i == 0 && j == 0)	/* End of update.	 */
		return;
	itrace = score[(nrow * i) + j].s_itrace;
	jtrace = score[(nrow * i) + j].s_jtrace;
	if (itrace == i) {	/* [i, j-1]		 */
		ninsl = 0;	/* Collect inserts.	 */
		if (i != size)
			ninsl = 1;
		ndraw = 1;
		while (itrace != 0 || jtrace != 0) {
			if (score[(nrow * itrace) + jtrace].s_itrace != itrace)
				break;
			jtrace = score[(nrow * itrace) + jtrace].s_jtrace;
			if (i != size)
				++ninsl;
			++ndraw;
		}
		traceback(offs, size, itrace, jtrace);
		if (ninsl != 0) {
			ttcolor(CTEXT);
			ttinsl(offs + j - ninsl, offs + size - 1, ninsl);
		}
		do {		/* B[j], A[j] blank.	 */
			k = offs + j - ndraw;
			uline(k, vscreen[k], &blanks);
		} while (--ndraw);
		return;
	}
	if (jtrace == j) {	/* [i-1, j]		 */
		ndell = 0;	/* Collect deletes.	 */
		if (j != size)
			ndell = 1;
		while (itrace != 0 || jtrace != 0) {
			if (score[(nrow * itrace) + jtrace].s_jtrace != jtrace)
				break;
			itrace = score[(nrow * itrace) + jtrace].s_itrace;
			if (j != size)
				++ndell;
		}
		if (ndell != 0) {
			ttcolor(CTEXT);
			ttdell(offs + i - ndell, offs + size - 1, ndell);
		}
		traceback(offs, size, itrace, jtrace);
		return;
	}
	traceback(offs, size, itrace, jtrace);
	k = offs + j - 1;
	uline(k, vscreen[k], pscreen[offs + i - 1]);
}
@


1.47
log
@Pull an #include out of an #ifdef.
XCHAR and XSHORT have always been defined to be int. Just make them int.
We don't need to care about making better code for whatever non-VAX
machines were being used in 1986.
ok florian@@
@
text
@d1 1
a1 1
/*	$OpenBSD: display.c,v 1.46 2015/03/24 22:28:10 bcallah Exp $	*/
d369 1
a369 1
	} else {
d373 6
@


1.46
log
@unifdef -DBINDKEY -- you can't build mg the other way.
unifdef -UMOVE_STANDOUT -- we had it under an '#ifdef undef' in ttydef.h
also remove those lines from ttydef.h

Set linenos = TRUE instead of an odd #ifdef dance that isn't used anywhere
else.

ok florian@@
@
text
@d1 1
a1 1
/*	$OpenBSD: display.c,v 1.45 2015/03/19 21:22:15 bcallah Exp $	*/
d20 1
a25 15
 * You can change these back to the types
 * implied by the name if you get tight for space. If you
 * make both of them "int" you get better code on the VAX.
 * They do nothing if this is not Gosling redisplay, except
 * for change the size of a structure that isn't used.
 * A bit of a cheat.
 */
#define	XCHAR	int
#define	XSHORT	int

#ifdef	STANDOUT_GLITCH
#include <term.h>
#endif

/*
d35 1
a35 1
	XSHORT	v_cost;		/* Cost of display.		 */
a46 3
 * If no fancy redisplay, this isn't used. The trace index
 * fields can be "char", and the cost a "short", but
 * this makes the code worse on the VAX.
d49 3
a51 3
	XCHAR	s_itrace;	/* "i" index for track back.	 */
	XCHAR	s_jtrace;	/* "j" index for trace back.	 */
	XSHORT	s_cost;		/* Display cost.		 */
@


1.45
log
@Clean up the includes in mg.
This does the following:
Moves all POSIX headers from sysdef.h into the individual .c files so that
each file now only includes what it needs. All headers are properly sorted.
Moves the remainder of sysdef.h to other files (mostly def.h) and deletes
sysdef.h now that it's no longer contains anything.
Tweak a comment that references sysdef.h so that it no longer does that.
ok florian@@
@
text
@d1 1
a1 1
/*	$OpenBSD: display.c,v 1.44 2015/02/17 00:34:33 tedu Exp $	*/
d110 1
a110 4
#ifndef LINENOMODE
#define LINENOMODE TRUE
#endif /* !LINENOMODE */
static int	 linenos = LINENOMODE;
a752 1
#ifndef MOVE_STANDOUT
a753 1
#endif
@


1.44
log
@shuffle reallocarray arguments around for better overflow checking
@
text
@d1 1
a1 1
/*	$OpenBSD: display.c,v 1.43 2015/02/17 00:32:40 tedu Exp $	*/
d13 8
a22 2

#include <ctype.h>
@


1.43
log
@undef tryreallocarray like tryrealloc when done.
from Kamil Rytarowski. ok bcallah
@
text
@d1 1
a1 1
/*	$OpenBSD: display.c,v 1.42 2014/10/16 17:36:11 deraadt Exp $	*/
d209 1
a209 1
		TRYREALLOCARRAY(score, newrow * newrow, sizeof(struct score));
d212 1
a212 1
		TRYREALLOCARRAY(video, (2 * (newrow - 1)), sizeof(struct video));
@


1.42
log
@Use reallocarray() where possible.  There are further possible overflows
in the region, but my time is limited...
@
text
@d1 1
a1 1
/*	$OpenBSD: display.c,v 1.41 2013/05/31 18:03:44 lum Exp $	*/
d250 1
@


1.41
log
@Make the system bell toggleable via 'audible-bell', and if switched
off, make available an alternative 'visible-bell'.

ok florian@@ jasper@@ Feedback Sunil Nimmagadda.
@
text
@d1 1
a1 1
/*	$OpenBSD: display.c,v 1.40 2013/03/25 11:41:44 florian Exp $	*/
d173 8
d209 4
a212 4
		TRYREALLOC(score, newrow * newrow * sizeof(struct score));
		TRYREALLOC(vscreen, (newrow - 1) * sizeof(struct video *));
		TRYREALLOC(pscreen, (newrow - 1) * sizeof(struct video *));
		TRYREALLOC(video, (2 * (newrow - 1)) * sizeof(struct video));
d233 2
a234 2
			TRYREALLOC(video[i].v_text, newcol * sizeof(char));
		TRYREALLOC(blanks.v_text, newcol * sizeof(char));
@


1.40
log
@Display the window's column number in mode line not the
column number of the active window.
OK jasper@@
@
text
@d1 1
a1 1
/*	$OpenBSD: display.c,v 1.39 2012/12/04 10:54:20 florian Exp $	*/
d71 1
a71 1
void	modeline(struct mgwin *);
d406 1
a406 1
update(void)
d506 1
a506 1
			modeline(wp);
d799 1
a799 1
modeline(struct mgwin *wp)
d807 1
a807 1
	vscreen[n]->v_color = CMODE;		/* Mode line color.	 */
@


1.39
log
@Bring back column numbers and make them configurable, off by default
to not kill slow serial lines.
Committing my independently written, slightly different version, as
requested by jasper@@.

OK jasper@@, OK reyk@@ for jasper@@'s version of the diff
"Sure, if you think so then." deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: display.c,v 1.38 2012/11/11 20:40:49 deraadt Exp $	*/
d854 1
a854 1
		    getcolpos());
d858 1
a858 1
		len = snprintf(sl, sizeof(sl), "--C%d", getcolpos());
@


1.38
log
@updating the character offset on the line all the time is astoundingly
hostile to slow terminals.
ok lum
@
text
@d1 1
a1 1
/*	$OpenBSD: display.c,v 1.37 2009/06/04 02:23:37 kjell Exp $	*/
d108 1
d133 14
d426 1
a426 1
	if (linenos) {
d852 4
a855 1
	if (linenos) {
d857 4
a860 3
		if (len < sizeof(sl) && len != -1)
			n += vtputs(sl);
	}
@


1.37
log
@Rename w_flag to w_rflag. This is not a general purpose
flag: it is for redisplay options only. I need an additional all-purpose
flag, so renaming removes the desire to wrongly overload the existing one.

Turdshine. No functional chage.
@
text
@d1 1
a1 1
/*	$OpenBSD: display.c,v 1.36 2008/06/11 19:35:37 kjell Exp $	*/
d838 1
a838 2
		len = snprintf(sl, sizeof(sl), "--L%d--C%d", wp->w_dotline,
		    getcolpos());
@


1.36
log
@Use getcolpos to compute column. doto does not account for tabs
@
text
@d1 1
a1 1
/*	$OpenBSD: display.c,v 1.35 2007/05/28 17:52:17 kjell Exp $	*/
d407 1
a407 1
			wp->w_flag |= WFMODE | WFFULL;
d414 1
a414 1
			wp->w_flag |= WFMODE;
d423 1
a423 1
		if (wp->w_flag == 0)
d426 1
a426 1
		if ((wp->w_flag & WFFRAME) == 0) {
d460 1
a460 1
		wp->w_flag |= WFFULL;	/* Force full.		 */
d464 1
a464 1
		if ((wp->w_flag & ~WFMODE) == WFEDIT) {
d475 1
a475 1
		} else if ((wp->w_flag & (WFEDIT | WFFULL)) != 0) {
d490 1
a490 1
		if ((wp->w_flag & WFMODE) != 0)
d492 1
a492 1
		wp->w_flag = 0;
@


1.35
log
@Add a global-wd-mode command, which toggles between the current
behavior (every buffer maintains its own cwd) and the old behavior of
one global working directory. This makes it slightly easier to hack
on things like kernel code, where compilation, etc, are initiated from
a different directory than you are working in.
While here, fix setting/handling of global wd.
@
text
@d1 1
a1 1
/*	$OpenBSD: display.c,v 1.34 2007/03/29 17:37:15 kjell Exp $	*/
d839 1
a839 1
		    wp->w_doto);
@


1.34
log
@Indicate when macro recording is in progress on the modeline.
(This should eventually move to becoming a "real" mode.)
Don't print end macro message unless the macro is being recorded.
ok cloder@@. looks fine art@@
@
text
@d1 1
a1 1
/*	$OpenBSD: display.c,v 1.33 2006/12/24 01:07:59 kjell Exp $	*/
d111 2
d115 2
a116 2
 * Since we don't have variables (we probably should) this is a command
 * processor for changing the value of the line number mode flag.
a131 2


d829 1
a829 1
	/* XXX This should eventually move to a real mode */
d832 2
@


1.33
log
@Add column-number indicator to status line (enabled when line-number-mode is
enabled; i.e. by default). This is essentially free, and has been requested
a few times now
@
text
@d1 1
a1 1
/*	$OpenBSD: display.c,v 1.32 2006/12/20 21:31:45 deraadt Exp $	*/
d109 3
d829 3
@


1.32
log
@kjell loves his extra spaces
@
text
@d1 1
a1 1
/*	$OpenBSD: display.c,v 1.31 2006/11/19 16:51:19 deraadt Exp $	*/
d830 2
a831 1
		len = snprintf(sl, sizeof(sl), "--L%d", wp->w_dotline);
@


1.31
log
@spacing
@
text
@d1 1
a1 1
/*	$OpenBSD: display.c,v 1.30 2006/07/25 08:22:32 kjell Exp $	*/
d106 1
a106 1
#endif /* !LINENOMODE */ 
@


1.30
log
@Rename the header line of a buffer to b_headp, from the remarkably
unintuitive b_linep. No binary change.
@
text
@d1 1
a1 1
/*	$OpenBSD: display.c,v 1.29 2006/06/01 09:00:50 kjell Exp $	*/
d107 1
a107 1
static int      linenos = LINENOMODE;
d122 1
a122 1
	sgarbf = TRUE;	
@


1.29
log
@Display line number in the mg statusbar.  Yes, it seems like a fugly
way to do it, but all the clever and pretty ways utterly failed.
Basic use seems fine. We'll turdshine the special cases later.

If it bothers you, use M-x line-number-mode, or put same in your ~/.mg
file to disable.

ok cloder, jason
@
text
@d1 1
a1 1
/*	$OpenBSD: display.c,v 1.28 2006/05/29 00:02:23 kjell Exp $	*/
d428 1
a428 1
				if (lp == wp->w_bufp->b_linep)
d452 1
a452 1
		while (i != 0 && lback(lp) != wp->w_bufp->b_linep) {
d478 1
a478 1
				if (lp != wp->w_bufp->b_linep) {
@


1.28
log
@Another mnemonic rename, missed the first time.
Also missed the ok cloder.
@
text
@d1 1
a1 1
/*	$OpenBSD: display.c,v 1.27 2006/05/28 23:30:16 kjell Exp $	*/
d104 25
d408 7
d785 2
d828 7
@


1.27
log
@Make Window Flags more mnemonic (and less dumb); i.e.
WFHARD -> WFFULL (Redraw full window)
WFFORCE -> WFFRAME (Reframe window).
No binary change
@
text
@d1 1
a1 1
/*	$OpenBSD: display.c,v 1.26 2005/12/13 06:01:27 kjell Exp $	*/
d404 1
a404 1
		i = wp->w_force;
d458 1
a458 1
		wp->w_force = 0;
@


1.26
log
@More name-clash delinting
@
text
@d1 1
a1 1
/*	$OpenBSD: display.c,v 1.25 2005/12/13 05:40:33 kjell Exp $	*/
d379 1
a379 1
			wp->w_flag |= WFMODE | WFHARD;
d391 1
a391 1
		if ((wp->w_flag & WFFORCE) == 0) {
d425 1
a425 1
		wp->w_flag |= WFHARD;	/* Force full.		 */
d440 1
a440 1
		} else if ((wp->w_flag & (WFEDIT | WFHARD)) != 0) {
@


1.25
log
@do some silly de-linting
@
text
@d1 1
a1 1
/*	$OpenBSD: display.c,v 1.24 2005/11/20 03:53:45 deraadt Exp $	*/
d374 1
a374 1
	if (typeahead())
@


1.24
log
@GOSLING screen update always on, so #ifdef can go; ok kjell
@
text
@d1 1
a1 1
/*	$OpenBSD: display.c,v 1.23 2005/11/18 20:56:52 deraadt Exp $	*/
d751 1
a751 1
	int	n;
a752 1
	int	mode;
d785 3
a787 3
	for (mode = 0; ; ) {
		n += vtputs(bp->b_modes[mode]->p_name);
		if (++mode > bp->b_nmodes)
@


1.23
log
@greedy use of typedef struct was making code harder to read; ok kjell cloder
@
text
@d1 1
a1 1
/*	$OpenBSD: display.c,v 1.22 2005/06/14 18:14:40 kjell Exp $	*/
d11 1
a11 5
 * pig. Two conditional compilation flags; the GOSLING
 * flag enables dynamic programming redisplay, using the
 * algorithm published by Jim Gosling in SIGOA. The MEMMAP
 * changes things around for memory mapped video. With
 * both off, the terminal is a VT52.
a25 2
/* These defines really belong in sysdef.h */
#ifndef XCHAR
a27 1
#endif
a94 1
#ifdef	GOSLING
a102 1
#endif
a157 1
#ifdef GOSLING
a158 1
#endif
a542 1
#ifdef	GOSLING
a584 1
#endif
a666 4
#ifdef	MEMMAP
	putline(row + 1, 1, &vvp->v_text[0]);
#else

d681 2
a682 1
		cp2 = &vvp->v_text[ncol - (magic_cookie_glitch >= 0 ? (magic_cookie_glitch != 0 ? magic_cookie_glitch : 1) : 0)];
a737 1
#endif
a815 1
#ifdef	GOSLING
a1015 1
#endif
@


1.22
log
@Add explicit public domain notices to all public domain files.
ok millert@@, deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: display.c,v 1.21 2005/04/03 02:09:28 db Exp $	*/
d46 1
a46 1
typedef struct {
d52 1
a52 1
} VIDEO;
d66 1
a66 1
typedef struct {
d70 1
a70 1
} SCORE;
d78 1
a78 1
void	modeline(MGWIN *);
d81 3
a83 3
void	ucopy(VIDEO *, VIDEO *);
void	uline(int, VIDEO *, VIDEO *);
void	hash(VIDEO *);
d97 4
a100 4
VIDEO	**vscreen;		/* Edge vector, virtual.	 */
VIDEO	**pscreen;		/* Edge vector, physical.	 */
VIDEO	 *video;		/* Actual screen data.		 */
VIDEO	  blanks;		/* Blank line image.		 */
d110 1
a110 1
SCORE *score;			/* [NROW * NROW] */
d123 1
a123 1
	VIDEO	*vp;
d168 1
a168 1
		TRYREALLOC(score, newrow * newrow * sizeof(SCORE));
d170 3
a172 3
		TRYREALLOC(vscreen, (newrow - 1) * sizeof(VIDEO *));
		TRYREALLOC(pscreen, (newrow - 1) * sizeof(VIDEO *));
		TRYREALLOC(video, (2 * (newrow - 1)) * sizeof(VIDEO));
d178 1
a178 1
			memset(&video[i], 0, sizeof(VIDEO));
d288 1
a288 1
	VIDEO	*vp;
d324 1
a324 1
	VIDEO *vp;
d357 1
a357 1
	VIDEO *vp;
d376 4
a379 4
	LINE	*lp;
	MGWIN	*wp;
	VIDEO	*vp1;
	VIDEO	*vp2;
d612 1
a612 1
 * kept in a VIDEO structure. The "vvp" is
d619 1
a619 1
ucopy(VIDEO *vvp, VIDEO *pvp)
d637 1
a637 1
	LINE	*lp;			/* pointer to current line */
d664 1
a664 1
 * but erase to end of line). The "vvp" points at the VIDEO
d671 1
a671 1
uline(int row, VIDEO *vvp, VIDEO *pvp)
d766 1
a766 1
modeline(MGWIN *wp)
d769 1
a769 1
	BUFFER *bp;
d843 1
a843 1
hash(VIDEO *vp)
d893 4
a896 4
	SCORE	 *sp;
	SCORE	 *sp1;
	VIDEO	**vp, **pp;
	VIDEO	**vbase, **pbase;
@


1.21
log
@This is a no binary change which does:

- spelling, punctuation fixes
- variable declaration lineup
- use parentheses for return and sizeof
- K&R function declarations -> ANSI
- other minor code beautification

ok henning@@
@
text
@d1 3
a3 1
/*	$OpenBSD: display.c,v 1.20 2003/08/15 23:23:18 vincent Exp $	*/
@


1.20
log
@make dired work more like emacs. (well, make it _work_, and then add a
bunch of missing commands)
@
text
@d1 1
a1 1
/*	$OpenBSD: display.c,v 1.19 2002/09/15 13:59:16 vincent Exp $	*/
d15 2
a16 2
#include	"def.h"
#include	"kbd.h"
d92 2
a93 2
int	lbound = 0;		/* leftmost bound of the current line */
				/*     being displayed		 */
d97 2
a98 2
VIDEO	*video;			/* Actual screen data.		 */
VIDEO	blanks;			/* Blank line image.		 */
d118 4
a121 4
	int i;
	int rowchanged, colchanged;
	static int first_run = 1;
	VIDEO *vp;
d138 1
a138 1
	if (!first_run && !force && !rowchanged && !colchanged) {
a139 1
	}
d141 1
a141 1
	if (first_run) {
a142 1
	}
d156 1
a156 1
		 * We're shrinking, free some internal data
d173 1
a173 1
		 * Zero-out the entries we just allocated
a247 1

d309 1
a309 1
		snprintf(bf, sizeof bf, "\\%o", c);
a346 1

d378 4
a381 7
	int	i, j;
	int	c;
	int	hflag;
	int	currow;
	int	curcol;
	int	offs;
	int	size;
d392 1
a392 1
	hflag = FALSE;			/* Not hard.		 */
d426 1
a426 1
		 * Find the line
d469 1
a469 1
	lp = curwp->w_linep;	/* Cursor location.	 */
d493 1
a493 1
			snprintf(bf, sizeof bf, "\\%o", c);
d505 2
a506 2
	 * make sure no lines need to be de-extended because the cursor is no
	 * longer on them
d537 3
a539 3
		sgarbf = FALSE;	/* Erase-page clears	 */
		epresf = FALSE;	/* the message area.	 */
		tttop = HUGE;	/* Forget where you set */
a618 1

d630 1
a630 1
 * left to let the user see where the cursor is
d636 1
a636 1
	int	j;			/* index into line */
d655 1
a655 1
	vteeol();		/* truncate the virtual line */
d676 1
a676 1
	int	nbflag;
d692 2
a693 2
		 * the odd code for magic_cookie_glitch==0 is to avoid
		 * putting the invisable glitch character on the next line.
d710 1
a710 1
	cp1 = &vvp->v_text[0];	/* Compute left match.	 */
d719 1
a719 1
	cp3 = &vvp->v_text[ncol];	/* Compute right match. */
d757 1
a757 1
 * This is the only routine that has any idea of how the modeline is
d768 1
a768 1
	int mode;
d795 1
a795 1
	while (n < 42) {		/* Pad out with blanks	 */
d810 1
a810 1
	while (n < ncol) {		/* Pad out.		 */
d815 1
d817 1
a817 1
 * output a string to the mode line, report how long it was.
d828 1
a828 1
	return n;
d843 2
a844 3
	int	i;
	int	n;
	char  *s;
d891 2
a892 5
	SCORE	*sp;
	SCORE	*sp1;
	int	tempcost;
	int	bestcost;
	int	j, i;
d895 3
d978 1
a978 2
	int	itrace;
	int	jtrace;
d980 1
a980 3
	int	ninsl;
	int	ndraw;
	int	ndell;
@


1.19
log
@typo in comment.
@
text
@d1 1
a1 1
/*	$OpenBSD: display.c,v 1.18 2002/08/29 22:45:22 vincent Exp $	*/
d349 1
@


1.18
log
@fix a little display bug when editing a file with binary characters, columns
weren't calculated correctly.

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: display.c,v 1.17 2002/08/22 23:28:19 deraadt Exp $	*/
d61 1
a61 1
 * fields can be "char", and the score a "short", but
@


1.17
log
@knf
@
text
@d1 1
a1 1
/*	$OpenBSD: display.c,v 1.16 2002/08/22 23:21:20 vincent Exp $	*/
d489 1
a489 1
			)
d491 11
a501 3
		else if (ISCTRL(c) != FALSE)
			++curcol;
		++curcol;
@


1.16
log
@print hex codes instead of non-printing characters.  fixes some display
problems when editing binary files.

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: display.c,v 1.15 2002/07/01 18:01:40 vincent Exp $	*/
d298 1
a298 1
		 && !(curbp->b_flag & BFNOTAB)
d300 1
a300 1
		) {
d311 1
d334 1
a334 1
		 && !(curbp->b_flag & BFNOTAB)
d336 1
a336 1
		) {
d776 1
a776 1
 	if ((bp->b_flag & BFREADONLY) != 0) {
d785 1
a785 1
 	} else {
@


1.15
log
@ just make vtresize return TRUE/FALSE instead of 0/-1, for consistency with
the rest of the mg code. + some KNF.

 adapted from diff by zyrnix.
@
text
@d1 1
a1 1
/*	$OpenBSD: display.c,v 1.14 2002/06/25 14:24:53 vincent Exp $	*/
d18 2
d307 1
a307 1
	} else
d309 5
@


1.14
log
@display readonly/modified combination just like emacs.

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: display.c,v 1.13 2002/03/27 17:42:37 millert Exp $	*/
d121 2
a122 3
	if (newrow < 1 || newcol < 1) {
		return -1;
	}
d131 1
a131 1
		}	\
d137 1
a137 1
		return 0;
d175 1
a175 1
		for (i = vidstart; i < 2 * (newrow - 1); i++) {
a176 1
		}
d190 1
a190 1
		for (i = 0; i < 2 * (newrow - 1); i++) {
a191 1
		}
d204 1
a204 1
	return 0;
@


1.13
log
@Fixes the the following problems (from zyrnix)
1) Mg crashes with column width of 1, rows > 2
2) Mg panics on resizing due to incomplete write
3) Mg doesn't compile with STARTUPFILE defined
deraadt@@ OK
@
text
@d1 1
a1 1
/*	$OpenBSD: display.c,v 1.12 2002/03/16 04:17:36 vincent Exp $	*/
d773 4
a776 1
		vtputc('%');
@


1.12
log
@ add readonly buffer support
 plus some KNF

 ok art@@
@
text
@d1 1
a1 1
/*	$OpenBSD: display.c,v 1.11 2002/03/11 13:02:56 vincent Exp $	*/
d632 3
d640 1
@


1.11
log
@  * Move to ANSI function definitions.
  * Add a whole lot of consts where I thought it made sense

   no ok, but no objections either...
@
text
@d1 1
a1 1
/*	$OpenBSD: display.c,v 1.10 2002/02/16 21:27:49 millert Exp $	*/
d758 1
a758 1
	int	mode;
d767 4
a770 1
	if ((bp->b_flag & BFCHG) != 0) {	/* "*" if changed.	 */
d773 1
a773 1
	} else {
@


1.10
log
@Part one of userland __P removal.  Done with a simple regexp with some minor hand editing to make comments line up correctly.  Another pass is forthcoming that handles the cases that could not be done automatically.
@
text
@d1 1
a1 1
/*	$OpenBSD: display.c,v 1.9 2002/02/14 14:24:21 deraadt Exp $	*/
d71 1
a71 1
int	vtputs(char *);
d224 1
a224 1
vtinit()
d249 1
a249 1
vttidy()
d269 1
a269 2
vtmove(row, col)
	int row, col;
d288 1
a288 2
vtputc(c)
	int	c;
d318 1
a318 2
vtpute(c)
	int	c;
d351 1
a351 1
vteeol()
d370 1
a370 1
update()
d610 1
a610 3
ucopy(vvp, pvp)
	VIDEO *vvp;
	VIDEO *pvp;
d627 1
a627 2
updext(currow, curcol)
	int	currow, curcol;
d659 1
a659 4
uline(row, vvp, pvp)
	int	row;
	VIDEO	*vvp;
	VIDEO	*pvp;
a660 3
#ifdef	MEMMAP
	putline(row + 1, 1, &vvp->v_text[0]);
#else
d668 4
d754 1
a754 2
modeline(wp)
	MGWIN  *wp;
d785 1
a785 1
	for (mode = 0;;) {
d803 1
a803 2
vtputs(s)
	char  *s;
d805 1
a805 1
	int	n = 0;
d824 1
a824 2
hash(vp)
	VIDEO *vp;
d873 1
a873 3
setscores(offs, size)
	int offs;
	int size;
d960 1
a960 5
traceback(offs, size, i, j)
	int	offs;
	int	size;
	int	i;
	int	j;
@


1.9
log
@some KNF
@
text
@d1 1
a1 1
/*	$OpenBSD: display.c,v 1.8 2002/02/14 00:11:46 vincent Exp $	*/
d68 12
a79 12
void	vtmove __P((int, int));
void	vtputc __P((int));
void	vtpute __P((int));
int	vtputs __P((char *));
void	vteeol __P((void));
void	updext __P((int, int));
void	modeline __P((MGWIN *));
void	setscores __P((int, int));
void	traceback __P((int, int, int, int));
void	ucopy __P((VIDEO *, VIDEO *));
void	uline __P((int, VIDEO *, VIDEO *));
void	hash __P((VIDEO *));
@


1.8
log
@ simplify a loop and add some comments.

 ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: display.c,v 1.7 2002/01/18 08:37:08 art Exp $	*/
d144 1
a144 1
		
d200 1
a200 1
	
d206 1
a206 1
	first_run = 0;	
d230 1
a230 1
	
d295 1
a295 1
	
d326 1
a326 1
	
d403 1
a403 1
		
d427 2
a428 3
			i = wp->w_ntrows / 2; /* current center,
					       * no change */
		
@


1.7
log
@Remove the NROW and NCOL limits. The static arrays are now replaced with
dynamically allocated memory.
Code written by Vincent Labrecque <limitln@@Psyfreaks.CA> with some minor
tweaks by me.
@
text
@d1 1
a1 1
/*	$OpenBSD: display.c,v 1.6 2001/05/24 03:05:22 mickey Exp $	*/
d294 2
d325 2
a327 1

d337 1
a337 2
		}
		while (((vtcol + lbound) & 0x07) != 0 && vtcol < ncol);
d397 15
a411 12
	wp = wheadp;
	while (wp != NULL) {
		if (wp->w_flag != 0) {	/* Need update.		 */
			if ((wp->w_flag & WFFORCE) == 0) {
				lp = wp->w_linep;
				for (i = 0; i < wp->w_ntrows; ++i) {
					if (lp == wp->w_dotp)
						goto out;
					if (lp == wp->w_bufp->b_linep)
						break;
					lp = lforw(lp);
				}
d413 34
a446 15
			i = wp->w_force;	/* Reframe this one.	 */
			if (i > 0) {
				--i;
				if (i >= wp->w_ntrows)
					i = wp->w_ntrows - 1;
			} else if (i < 0) {
				i += wp->w_ntrows;
				if (i < 0)
					i = 0;
			} else
				i = wp->w_ntrows / 2;
			lp = wp->w_dotp;
			while (i != 0 && lback(lp) != wp->w_bufp->b_linep) {
				--i;
				lp = lback(lp);
d448 9
a456 10
			wp->w_linep = lp;
			wp->w_flag |= WFHARD;	/* Force full.		 */
	out:
			lp = wp->w_linep;	/* Try reduced update.	 */
			i = wp->w_toprow;
			if ((wp->w_flag & ~WFMODE) == WFEDIT) {
				while (lp != wp->w_dotp) {
					++i;
					lp = lforw(lp);
				}
d460 5
a464 2
				for (j = 0; j < llength(lp); ++j)
					vtputc(lgetc(lp, j));
d466 1
a466 14
			} else if ((wp->w_flag & (WFEDIT | WFHARD)) != 0) {
				hflag = TRUE;
				while (i < wp->w_toprow + wp->w_ntrows) {
					vscreen[i]->v_color = CTEXT;
					vscreen[i]->v_flag |= (VFCHG | VFHBAD);
					vtmove(i, 0);
					if (lp != wp->w_bufp->b_linep) {
						for (j = 0; j < llength(lp); ++j)
							vtputc(lgetc(lp, j));
						lp = lforw(lp);
					}
					vteeol();
					++i;
				}
a467 4
			if ((wp->w_flag & WFMODE) != 0)
				modeline(wp);
			wp->w_flag = 0;
			wp->w_force = 0;
d469 4
a472 1
		wp = wp->w_wndp;
@


1.6
log
@spaces
@
text
@d1 1
a1 1
/*	$OpenBSD: display.c,v 1.5 2001/05/23 22:20:35 art Exp $	*/
d39 2
a40 2
 * the longest line possible. Only some of this is
 * used if "ncol" isn't the same as "NCOL".
d47 1
a47 1
	char	v_text[NCOL];	/* The actual characters.	 */
a67 1

d83 2
a84 2
int	vtrow = 0;		/* Virtual cursor row.		 */
int	vtcol = 0;		/* Virtual cursor column.	 */
d91 1
a91 1
					/* being displayed		 */
d93 3
a95 3
VIDEO	*vscreen[NROW - 1];	/* Edge vector, virtual.	 */
VIDEO	*pscreen[NROW - 1];	/* Edge vector, physical.	 */
VIDEO	video[2 * (NROW - 1)];	/* Actual screen data.		 */
d106 62
a167 1
SCORE score[NROW * NROW];
d169 42
a225 1
	VIDEO	*vp;
d230 6
a235 7
	vp = &video[0];
	for (i = 0; i < NROW - 1; ++i) {
		vscreen[i] = vp;
		++vp;
		pscreen[i] = vp;
		++vp;
	}
d237 1
a237 1
	for (i = 0; i < NCOL; ++i)
a271 1

d902 1
a902 1
	sp = &score[NROW];		/* Column 0, deletes.	 */
d909 1
a909 1
		sp += NROW;
d911 1
a911 1
	sp1 = &score[NROW + 1];		/* [1, 1].		 */
d919 1
a919 1
			bestcost = (sp - NROW)->s_cost;
d931 1
a931 1
			tempcost = (sp - NROW - 1)->s_cost;
d945 1
a945 1
		sp1 += NROW;		/* Next row.		 */
d977 2
a978 2
	itrace = score[(NROW * i) + j].s_itrace;
	jtrace = score[(NROW * i) + j].s_jtrace;
d985 1
a985 1
			if (score[(NROW * itrace) + jtrace].s_itrace != itrace)
d987 1
a987 1
			jtrace = score[(NROW * itrace) + jtrace].s_jtrace;
d1008 1
a1008 1
			if (score[(NROW * itrace) + jtrace].s_jtrace != jtrace)
d1010 1
a1010 1
			itrace = score[(NROW * itrace) + jtrace].s_itrace;
@


1.5
log
@remove VOID. We're way beyond the point where this could build with an
ancient compiler.
@
text
@d1 1
a1 1
/*	$OpenBSD: display.c,v 1.4 2001/01/29 01:58:07 niklas Exp $	*/
d43 5
a47 5
	short           v_hash;		/* Hash code, for compares.	 */
	short           v_flag;		/* Flag word.			 */
	short           v_color;	/* Color of the line.		 */
	XSHORT          v_cost;		/* Cost of display.		 */
	char            v_text[NCOL];	/* The actual characters.	 */
d63 3
a65 3
	XCHAR           s_itrace;	/* "i" index for track back.	 */
	XCHAR           s_jtrace;	/* "j" index for trace back.	 */
	XSHORT          s_cost;		/* Display cost.		 */
d69 23
a91 23
void     vtmove         __P((int, int));
void     vtputc         __P((int));
void     vtpute         __P((int));
int      vtputs         __P((char *));
void     vteeol         __P((void));
void     updext         __P((int, int));
void     modeline       __P((MGWIN *));
void     setscores      __P((int, int));
void     traceback      __P((int, int, int, int));
void     ucopy          __P((VIDEO *, VIDEO *));
void     uline          __P((int, VIDEO *, VIDEO *));
void     hash           __P((VIDEO *));


int             sgarbf = TRUE;		/* TRUE if screen is garbage.	 */
int             vtrow = 0;		/* Virtual cursor row.		 */
int             vtcol = 0;		/* Virtual cursor column.	 */
int             tthue = CNONE;		/* Current color.		 */
int             ttrow = HUGE;		/* Physical cursor row.		 */
int             ttcol = HUGE;		/* Physical cursor column.	 */
int             tttop = HUGE;		/* Top of scroll region.	 */
int             ttbot = HUGE;		/* Bottom of scroll region.	 */
int             lbound = 0;		/* leftmost bound of the current line */
d94 4
a97 4
VIDEO          *vscreen[NROW - 1];	/* Edge vector, virtual.	 */
VIDEO          *pscreen[NROW - 1];	/* Edge vector, physical.	 */
VIDEO           video[2 * (NROW - 1)];	/* Actual screen data.		 */
VIDEO           blanks;			/* Blank line image.		 */
d124 2
a125 2
	VIDEO *vp;
	int    i;
d191 1
a191 1
	int    c;
d193 1
a193 1
	VIDEO *vp;
d220 1
a220 1
	int    c;
d274 11
a284 12
	LINE  *lp;
	MGWIN *wp;
	VIDEO *vp1;
	VIDEO *vp2;
	int    i;
	int    j;
	int    c;
	int    hflag;
	int    currow;
	int    curcol;
	int    offs;
	int    size;
d523 1
a523 1
	int    currow, curcol;
d525 2
a526 2
	LINE  *lp;			/* pointer to current line */
	int    j;			/* index into line */
d556 3
a558 3
	int		row;
	VIDEO          *vvp;
	VIDEO          *pvp;
d568 1
a568 1
	int    nbflag;
d655 1
a655 1
	int     n;
d657 1
a657 1
	int     mode;
d705 1
a705 1
	int    n = 0;
d727 2
a728 2
	int    i;
	int    n;
d778 7
a784 8
	SCORE *sp;
	SCORE *sp1;
	int    tempcost;
	int    bestcost;
	int    j;
	int    i;
	VIDEO **vp, **pp;
	VIDEO **vbase, **pbase;
d864 11
a874 11
	int    offs;
	int    size;
	int    i;
	int    j;
{
	int    itrace;
	int    jtrace;
	int    k;
	int    ninsl;
	int    ndraw;
	int    ndell;
@


1.4
log
@$OpenBSD$
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d69 3
a71 3
VOID     vtmove         __P((int, int));
VOID     vtputc         __P((int));
VOID     vtpute         __P((int));
d73 8
a80 8
VOID     vteeol         __P((void));
VOID     updext         __P((int, int));
VOID     modeline       __P((MGWIN *));
VOID     setscores      __P((int, int));
VOID     traceback      __P((int, int, int, int));
VOID     ucopy          __P((VIDEO *, VIDEO *));
VOID     uline          __P((int, VIDEO *, VIDEO *));
VOID     hash           __P((VIDEO *));
d121 1
a121 1
VOID
d148 1
a148 1
VOID
d168 1
a168 1
VOID
d189 1
a189 1
VOID
d218 1
a218 1
VOID
d252 1
a252 1
VOID
d271 1
a271 1
VOID
d503 1
a503 1
VOID
d522 1
a522 1
VOID
d555 1
a555 1
VOID
d652 1
a652 1
VOID
d724 1
a724 1
VOID
d774 1
a774 1
VOID
d864 1
a864 1
VOID
@


1.3
log
@The start of KNF + -Wall.  The code has been run through indent but
needs hand fixup.  I stopped at keymap.c...
@
text
@d1 2
@


1.2
log
@change WINDOW -> MGWIN to avoid curses type conflict
convert to terminfo in tty*.c
add support for some keypad function keys (arrows, pgup, pgdown)
@
text
@d26 2
a27 2
#  define	XCHAR	int
#  define	XSHORT	int
d40 11
a50 11
typedef struct	{
	short	v_hash;			/* Hash code, for compares.	*/
	short	v_flag;			/* Flag word.			*/
	short	v_color;		/* Color of the line.		*/
	XSHORT	v_cost;			/* Cost of display.		*/
	char	v_text[NCOL];		/* The actual characters.	*/
}	VIDEO;

#define VFCHG	0x0001			/* Changed.			*/
#define VFHBAD	0x0002			/* Hash and cost are bad.	*/
#define VFEXT	0x0004			/* extended line (beond ncol)	*/
d60 36
a95 39
typedef struct	{
	XCHAR	s_itrace;		/* "i" index for track back.	*/
	XCHAR	s_jtrace;		/* "j" index for trace back.	*/
	XSHORT	s_cost;			/* Display cost.		*/
}	SCORE;

int	sgarbf	= TRUE;			/* TRUE if screen is garbage.	*/
int	vtrow	= 0;			/* Virtual cursor row.		*/
int	vtcol	= 0;			/* Virtual cursor column.	*/
int	tthue	= CNONE;		/* Current color.		*/
int	ttrow	= HUGE;			/* Physical cursor row.		*/
int	ttcol	= HUGE;			/* Physical cursor column.	*/
int	tttop	= HUGE;			/* Top of scroll region.	*/
int	ttbot	= HUGE;			/* Bottom of scroll region.	*/
int	lbound	= 0;			/* leftmost bound of the current line */
					/* being displayed		*/

VIDEO	*vscreen[NROW-1];		/* Edge vector, virtual.	*/
VIDEO	*pscreen[NROW-1];		/* Edge vector, physical.	*/
VIDEO	video[2*(NROW-1)];		/* Actual screen data.		*/
VIDEO	blanks;				/* Blank line image.		*/

/*
 * Some predeclerations to make ANSI compilers happy
 */
VOID	vtinit();
VOID	vttidy();
VOID	vtmove();
VOID	vtputc();
VOID	vtpute();
VOID	vteeol();
VOID	update();
VOID	updext();
VOID	ucopy();
VOID	uline();
VOID	modeline();
VOID	hash();
VOID	setscores();
VOID	traceback();
d105 1
a105 1
SCORE	score[NROW*NROW];
d120 4
a123 3
vtinit() {
	register VIDEO	*vp;
	register int	i;
d128 1
a128 1
	for (i=0; i<NROW-1; ++i) {
d135 1
a135 1
	for (i=0; i<NCOL; ++i)
d147 3
a149 1
vttidy() {
d151 2
a152 2
	ttnowindow();				/* No scroll window.	*/
	ttmove(nrow-1, 0);			/* Echo line.		*/
d167 4
a170 1
vtmove(row, col) {
d188 4
a191 2
vtputc(c) register int c; {
	register VIDEO	*vp;
d195 1
a195 1
		vp->v_text[ncol-1] = '$';
d198 1
a198 1
		&& !(curbp->b_flag & BFNOTAB)
d200 1
a200 1
	    ) {
d203 1
a203 1
		} while (vtcol<ncol && (vtcol&0x07)!=0);
d211 4
a214 3
/* Put a character to the virtual screen in an extended line.  If we are
 * not yet on left edge, don't print it yet.  Check for overflow on
 * the right margin.
d218 1
a218 1
int c;
d220 1
a220 1
    register VIDEO	*vp;
d222 1
a222 1
    vp = vscreen[vtrow];
d224 3
a226 2
    if (vtcol >= ncol) vp->v_text[ncol - 1] = '$';
    else if (c == '\t'
d228 1
a228 1
		       && !(curbp->b_flag & BFNOTAB)
d230 19
a248 20
					  ) {
	do {
	    vtpute(' ');
	}
	while (((vtcol + lbound)&0x07) != 0 && vtcol < ncol);
    } else if (ISCTRL(c) != FALSE) {
	vtpute('^');
	vtpute(CCHR(c));
    } else {
	if (vtcol >= 0) vp->v_text[vtcol] = c;
	++vtcol;
    }
}

/* Erase from the end of the
 * software cursor to the end of the
 * line on which the software cursor is
 * located. The display routines will decide
 * if a hardware erase to end of line command
 * should be used to display this.
d251 3
a253 2
vteeol() {
	register VIDEO	*vp;
d270 14
a283 15
update() {
	register LINE	*lp;
	register MGWIN *wp;
	register VIDEO	*vp1;
	VIDEO		*vp2;
	register int	i;
	register int	j;
	register int	c;
	register int	hflag;
	register int	currow;
	register int	curcol;
	register int	offs;
	register int	size;
	VOID traceback ();
	VOID uline ();
d285 3
a287 2
	if (typeahead()) return;
	if (sgarbf) {				/* must update everything */
d289 1
a289 1
		while(wp != NULL) {
d294 1
a294 1
	hflag = FALSE;				/* Not hard.		*/
d297 2
a298 2
		if (wp->w_flag != 0) {		/* Need update.		*/
			if ((wp->w_flag&WFFORCE) == 0) {
d300 1
a300 1
				for (i=0; i<wp->w_ntrows; ++i) {
d308 1
a308 1
			i = wp->w_force;	/* Reframe this one.	*/
d312 1
a312 1
					i = wp->w_ntrows-1;
d318 1
a318 1
				i = wp->w_ntrows/2;
d320 1
a320 1
			while (i!=0 && lback(lp)!=wp->w_bufp->b_linep) {
d325 5
a329 5
			wp->w_flag |= WFHARD;	/* Force full.		*/
		out:
			lp = wp->w_linep;	/* Try reduced update.	*/
			i  = wp->w_toprow;
			if ((wp->w_flag&~WFMODE) == WFEDIT) {
d335 1
a335 1
				vscreen[i]->v_flag |= (VFCHG|VFHBAD);
d337 1
a337 1
				for (j=0; j<llength(lp); ++j)
d340 1
a340 1
			} else if ((wp->w_flag&(WFEDIT|WFHARD)) != 0) {
d342 1
a342 1
				while (i < wp->w_toprow+wp->w_ntrows) {
d344 1
a344 1
					vscreen[i]->v_flag |= (VFCHG|VFHBAD);
d347 1
a347 1
						for (j=0; j<llength(lp); ++j)
d355 1
a355 1
			if ((wp->w_flag&WFMODE) != 0)
d357 1
a357 1
			wp->w_flag  = 0;
d362 1
a362 1
	lp = curwp->w_linep;			/* Cursor location.	*/
d374 1
a374 1
			&& !(curbp->b_flag & BFNOTAB)
d376 2
a377 1
			) curcol |= 0x07;
d382 2
a383 2
	if (curcol >= ncol - 1) {		/* extended line. */
		 /* flag we are extended and changed */
d385 3
a387 5
		updext(currow, curcol);		/* and output extended line */
	} else lbound = 0;			/* not extended line */

	/* make sure no lines need to be de-extended because the cursor is
	no longer on them */
d389 4
a393 1

d395 18
a412 15
	    lp = wp->w_linep;
	    i = wp->w_toprow;
	    while (i < wp->w_toprow + wp->w_ntrows) {
		if (vscreen[i]->v_flag & VFEXT) {
		    /* always flag extended lines as changed */
		    vscreen[i]->v_flag |= VFCHG;
		    if ((wp != curwp) || (lp != wp->w_dotp) ||
				(curcol < ncol - 1)) {
			vtmove(i, 0);
			for (j = 0; j < llength(lp); ++j)
				vtputc(lgetc(lp, j));
			vteeol();
			/* this line no longer is extended */
			vscreen[i]->v_flag &= ~VFEXT;
		    }
d414 5
a418 7
		lp = lforw(lp);
		++i;
	    }
	    /* if garbaged then fix up mode lines */
	    if (sgarbf != FALSE) vscreen[i]->v_flag |= VFCHG;
	    /* and onward to the next window */
	    wp = wp->w_wndp;
d421 6
a426 6
	if (sgarbf != FALSE) {			/* Screen is garbage.	*/
		sgarbf = FALSE;			/* Erase-page clears	*/
		epresf = FALSE;			/* the message area.	*/
		tttop  = HUGE;			/* Forget where you set */
		ttbot  = HUGE;			/* scroll region.	*/
		tthue  = CNONE;			/* Color unknown.	*/
d429 1
a429 1
		for (i=0; i<nrow-1; ++i) {
d439 1
a439 1
		for (i=0; i<nrow-1; ++i) {	/* Compute hash data.	*/
d444 1
a444 1
		while (offs != nrow-1) {
d448 1
a448 1
			||  vp1->v_hash	 != vp2->v_hash)
d454 1
a454 1
		if (offs == nrow-1) {		/* Might get it all.	*/
d459 1
a459 1
		size = nrow-1;			/* Get bottom match.	*/
d461 2
a462 2
			vp1 = vscreen[size-1];
			vp2 = pscreen[size-1];
d464 1
a464 1
			||  vp1->v_hash	 != vp2->v_hash)
d466 1
a466 1
			uline(size-1, vp1, vp2);
d474 2
a475 2
		for (i=0; i<size; ++i)
			ucopy(vscreen[offs+i], pscreen[offs+i]);
d481 1
a481 1
	for (i=0; i<nrow-1; ++i) {		/* Easy update.		*/
d484 1
a484 1
		if ((vp1->v_flag&VFCHG) != 0) {
d502 4
a505 1
ucopy(vvp, pvp) register VIDEO *vvp; register VIDEO *pvp; {
d507 4
a510 4
	vvp->v_flag &= ~VFCHG;			/* Changes done.	*/
	pvp->v_flag  = vvp->v_flag;		/* Update model.	*/
	pvp->v_hash  = vvp->v_hash;
	pvp->v_cost  = vvp->v_cost;
d515 4
a518 4
/* updext: update the extended line which the cursor is currently
 * on at a column greater than the terminal width. The line
 * will be scrolled right or left to let the user see where
 * the cursor is
d522 1
a522 1
int currow, curcol;
d524 2
a525 2
    register LINE *lp;			/* pointer to current line */
    register int j;			/* index into line */
d527 15
a541 11
    /* calculate what column the left bound should be */
    /* (force cursor into middle half of screen) */
    lbound = curcol - (curcol % (ncol>>1)) - (ncol>>2);
    /* scan through the line outputing characters to the virtual screen */
    /* once we reach the left edge */
    vtmove(currow, -lbound);			/* start scanning offscreen */
    lp = curwp->w_dotp;				/* line to output */
    for (j=0; j<llength(lp); ++j)		/* until the end-of-line */
	vtpute(lgetc(lp, j));
    vteeol();					/* truncate the virtual line */
    vscreen[currow]->v_text[0] = '$';		/* and put a '$' in column 1 */
d553 6
a558 1
VOID uline(row, vvp, pvp) VIDEO *vvp; VIDEO *pvp; {
d560 1
a560 1
	putline(row+1, 1, &vvp->v_text[0]);
d562 6
a567 6
	register char	*cp1;
	register char	*cp2;
	register char	*cp3;
	char		*cp4;
	char		*cp5;
	register int	nbflag;
d569 2
a570 2
	if (vvp->v_color != pvp->v_color) {	/* Wrong color, do a	*/
		ttmove(row, 0);			/* full redraw.		*/
d578 3
a580 3
		/* the odd code for magic_cookie_glitch==0
		 * is to avoid putting the invisable
		 * glitch character on the next line.
d583 1
a583 1
		cp2 = &vvp->v_text[ncol - (magic_cookie_glitch >= 0 ? (magic_cookie_glitch!=0 ? magic_cookie_glitch : 1) : 0)];
d597 1
a597 1
	cp1 = &vvp->v_text[0];			/* Compute left match.	*/
d599 1
a599 1
	while (cp1!=&vvp->v_text[ncol] && cp1[0]==cp2[0]) {
d603 1
a603 1
	if (cp1 == &vvp->v_text[ncol])		/* All equal.		*/
d606 1
a606 1
	cp3 = &vvp->v_text[ncol];		/* Compute right match. */
d611 2
a612 2
		if (cp3[0] != ' ')		/* Note non-blanks in	*/
			nbflag = TRUE;		/* the right match.	*/
d614 3
a616 3
	cp5 = cp3;				/* Is erase good?	*/
	if (nbflag==FALSE && vvp->v_color==CTEXT) {
		while (cp5!=cp1 && cp5[-1]==' ')
d619 1
a619 1
		if ((int)(cp3-cp5) <= tceeol)
d623 1
a623 1
	ttmove(row, (int)(cp1-&vvp->v_text[0]));
d626 4
a629 2
		if(cp1 < &vvp->v_text[magic_cookie_glitch]) cp1 = &vvp->v_text[magic_cookie_glitch];
		if(cp5 > &vvp->v_text[ncol-magic_cookie_glitch]) cp5 = &vvp->v_text[ncol-magic_cookie_glitch];
d637 1
a637 1
	if (cp5 != cp3)				/* Do erase.		*/
d643 19
a661 20
 * Redisplay the mode line for
 * the window pointed to by the "wp".
 * This is the only routine that has any idea
 * of how the modeline is formatted. You can
 * change the modeline format by hacking at
 * this routine. Called by "update" any time
 * there is a dirty window.
 * Note that if STANDOUT_GLITCH is defined, first and last
 * magic_cookie_glitch characters may never be seen.
 */
VOID
modeline(wp) register MGWIN *wp; {
	register int	n;
	register BUFFER *bp;
	int	mode;

	n = wp->w_toprow+wp->w_ntrows;		/* Location.		*/
	vscreen[n]->v_color = CMODE;		/* Mode line color.	*/
	vscreen[n]->v_flag |= (VFCHG|VFHBAD);	/* Recompute, display.	*/
	vtmove(n, 0);				/* Seek to right line.	*/
d663 5
a667 3
	vtputc('-'); vtputc('-');
	if ((bp->b_flag&BFCHG) != 0) {		/* "*" if changed.	*/
		vtputc('*'); vtputc('*');
d669 2
a670 1
		vtputc('-'); vtputc('-');
d673 1
a673 1
	n  = 5;
d677 1
a677 1
	while (n < 42) {			/* Pad out with blanks	*/
d683 6
a688 5
	for(mode=0;;) {
	    n += vtputs(bp->b_modes[mode]->p_name);
	    if(++mode > bp->b_nmodes) break;
	    vtputc('-');
	    ++n;
d692 1
a692 1
	while (n < ncol) {			/* Pad out.		*/
d700 5
a704 2
vtputs(s) register char *s; {
	register int n = 0;
d712 1
d715 5
a719 7
 * Compute the hash code for
 * the line pointed to by the "vp". Recompute
 * it if necessary. Also set the approximate redisplay
 * cost. The validity of the hash code is marked by
 * a flag bit. The cost understand the advantages
 * of erase to end of line. Tuned for the VAX
 * by Bob McNamara; better than it used to be on
d723 10
a732 8
hash(vp) register VIDEO *vp; {
	register int	i;
	register int	n;
	register char	*s;

	if ((vp->v_flag&VFHBAD) != 0) {		/* Hash bad.		*/
		s = &vp->v_text[ncol-1];
		for (i=ncol; i!=0; --i, --s)
d735 1
a735 1
		n = ncol-i;			/* Erase cheaper?	*/
d738 5
a742 5
		vp->v_cost = i+n;		/* Bytes + blanks.	*/
		for (n=0; i!=0; --i, --s)
			n = (n<<5) + n + *s;
		vp->v_hash = n;			/* Hash code.		*/
		vp->v_flag &= ~VFHBAD;		/* Flag as all done.	*/
d773 16
a788 13
setscores(offs, size) {
	register SCORE	*sp;
	SCORE		*sp1;
	register int	tempcost;
	register int	bestcost;
	register int	j;
	register int	i;
	register VIDEO	**vp;
	VIDEO		**pp, **vbase, **pbase;

	vbase = &vscreen[offs-1];		/* By hand CSE's.	*/
	pbase = &pscreen[offs-1];
	score[0].s_itrace = 0;			/* [0, 0]		*/
d790 2
a791 2
	score[0].s_cost	  = 0;
	sp = &score[1];				/* Row 0, inserts.	*/
d794 1
a794 1
	for (j=1; j<=size; ++j) {
d796 1
a796 1
		sp->s_jtrace = j-1;
d803 1
a803 1
	sp = &score[NROW];			/* Column 0, deletes.	*/
d805 2
a806 2
	for (i=1; i<=size; ++i) {
		sp->s_itrace = i-1;
d808 1
a808 1
		tempcost  += tcdell;
d812 1
a812 1
	sp1 = &score[NROW+1];			/* [1, 1].		*/
d814 1
a814 1
	for (i=1; i<=size; ++i) {
d817 2
a818 2
		for (j=1; j<=size; ++j) {
			sp->s_itrace = i-1;
d820 2
a821 2
			bestcost = (sp-NROW)->s_cost;
			if (j != size)		/* Cd(A[i])=0 @@ Dis.	*/
d823 1
a823 1
			tempcost = (sp-1)->s_cost;
d825 1
a825 1
			if (i != size)		/* Ci(B[j])=0 @@ Dsj.	*/
d829 1
a829 1
				sp->s_jtrace = j-1;
d832 1
a832 1
			tempcost = (sp-NROW-1)->s_cost;
d834 1
a834 1
			||  (*pp)->v_hash  != (*vp)->v_hash)
d837 2
a838 2
				sp->s_itrace = i-1;
				sp->s_jtrace = j-1;
d842 1
a842 1
			++sp;			/* Next column.		*/
d846 1
a846 1
		sp1 += NROW;			/* Next row.		*/
d862 13
a874 7
VOID traceback(offs, size, i, j) {
	register int	itrace;
	register int	jtrace;
	register int	k;
	register int	ninsl;
	register int	ndraw;
	register int	ndell;
d876 1
a876 1
	if (i==0 && j==0)			/* End of update.	*/
d878 4
a881 4
	itrace = score[(NROW*i) + j].s_itrace;
	jtrace = score[(NROW*i) + j].s_jtrace;
	if (itrace == i) {			/* [i, j-1]		*/
		ninsl = 0;			/* Collect inserts.	*/
d885 2
a886 2
		while (itrace!=0 || jtrace!=0) {
			if (score[(NROW*itrace) + jtrace].s_itrace != itrace)
d888 1
a888 1
			jtrace = score[(NROW*itrace) + jtrace].s_jtrace;
d896 1
a896 1
			ttinsl(offs+j-ninsl, offs+size-1, ninsl);
d898 2
a899 2
		do {				/* B[j], A[j] blank.	*/
			k = offs+j-ndraw;
d904 2
a905 2
	if (jtrace == j) {			/* [i-1, j]		*/
		ndell = 0;			/* Collect deletes.	*/
d908 2
a909 2
		while (itrace!=0 || jtrace!=0) {
			if (score[(NROW*itrace) + jtrace].s_jtrace != jtrace)
d911 1
a911 1
			itrace = score[(NROW*itrace) + jtrace].s_itrace;
d917 1
a917 1
			ttdell(offs+i-ndell, offs+size-1, ndell);
d923 2
a924 2
	k = offs+j-1;
	uline(k, vscreen[k], pscreen[offs+i-1]);
@


1.1
log
@initial import of mg2a
@
text
@d31 1
a31 1
extern int SG;				/* number of standout glitches	*/
d265 1
a265 1
	register WINDOW *wp;
d550 2
a551 1
		if (pvp->v_color != CTEXT && SG >= 0) tteeol();
d555 3
a557 2
		cp1 = &vvp->v_text[SG > 0 ? SG : 0];
		/* the odd code for SG==0 is to avoid putting the invisable
d561 1
a561 1
		cp2 = &vvp->v_text[ncol - (SG >= 0 ? (SG!=0 ? SG : 1) : 0)];
d603 4
a606 4
	if (vvp->v_color != CTEXT && SG > 0) {
		if(cp1 < &vvp->v_text[SG]) cp1 = &vvp->v_text[SG];
		if(cp5 > &vvp->v_text[ncol-SG]) cp5 = &vvp->v_text[ncol-SG];
	} else if (SG < 0)
d626 2
a627 2
 * Note that if STANDOUT_GLITCH is defined, first and last SG characters
 * may never be seen.
d630 1
a630 1
modeline(wp) register WINDOW *wp; {
@

