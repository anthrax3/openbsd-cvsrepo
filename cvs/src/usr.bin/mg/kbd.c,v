head	1.30;
access;
symbols
	OPENBSD_6_2:1.30.0.6
	OPENBSD_6_2_BASE:1.30
	OPENBSD_6_1:1.30.0.8
	OPENBSD_6_1_BASE:1.30
	OPENBSD_6_0:1.30.0.4
	OPENBSD_6_0_BASE:1.30
	OPENBSD_5_9:1.30.0.2
	OPENBSD_5_9_BASE:1.30
	OPENBSD_5_8:1.29.0.4
	OPENBSD_5_8_BASE:1.29
	OPENBSD_5_7:1.26.0.4
	OPENBSD_5_7_BASE:1.26
	OPENBSD_5_6:1.26.0.8
	OPENBSD_5_6_BASE:1.26
	OPENBSD_5_5:1.26.0.6
	OPENBSD_5_5_BASE:1.26
	OPENBSD_5_4:1.26.0.2
	OPENBSD_5_4_BASE:1.26
	OPENBSD_5_3:1.25.0.4
	OPENBSD_5_3_BASE:1.25
	OPENBSD_5_2:1.25.0.2
	OPENBSD_5_2_BASE:1.25
	OPENBSD_5_1_BASE:1.24
	OPENBSD_5_1:1.24.0.16
	OPENBSD_5_0:1.24.0.14
	OPENBSD_5_0_BASE:1.24
	OPENBSD_4_9:1.24.0.12
	OPENBSD_4_9_BASE:1.24
	OPENBSD_4_8:1.24.0.10
	OPENBSD_4_8_BASE:1.24
	OPENBSD_4_7:1.24.0.6
	OPENBSD_4_7_BASE:1.24
	OPENBSD_4_6:1.24.0.8
	OPENBSD_4_6_BASE:1.24
	OPENBSD_4_5:1.24.0.4
	OPENBSD_4_5_BASE:1.24
	OPENBSD_4_4:1.24.0.2
	OPENBSD_4_4_BASE:1.24
	OPENBSD_4_3:1.23.0.6
	OPENBSD_4_3_BASE:1.23
	OPENBSD_4_2:1.23.0.4
	OPENBSD_4_2_BASE:1.23
	OPENBSD_4_1:1.23.0.2
	OPENBSD_4_1_BASE:1.23
	OPENBSD_4_0:1.22.0.2
	OPENBSD_4_0_BASE:1.22
	OPENBSD_3_9:1.21.0.2
	OPENBSD_3_9_BASE:1.21
	OPENBSD_3_8:1.17.0.2
	OPENBSD_3_8_BASE:1.17
	OPENBSD_3_7:1.15.0.6
	OPENBSD_3_7_BASE:1.15
	OPENBSD_3_6:1.15.0.4
	OPENBSD_3_6_BASE:1.15
	OPENBSD_3_5:1.15.0.2
	OPENBSD_3_5_BASE:1.15
	OPENBSD_3_4:1.14.0.6
	OPENBSD_3_4_BASE:1.14
	OPENBSD_3_3:1.14.0.4
	OPENBSD_3_3_BASE:1.14
	OPENBSD_3_2:1.14.0.2
	OPENBSD_3_2_BASE:1.14
	OPENBSD_3_1:1.13.0.2
	OPENBSD_3_1_BASE:1.13
	OPENBSD_3_0:1.10.0.2
	OPENBSD_3_0_BASE:1.10
	OPENBSD_2_9_BASE:1.4
	OPENBSD_2_9:1.4.0.2
	OPENBSD_2_8:1.3.0.2
	OPENBSD_2_8_BASE:1.3
	OPENBSD_2_7:1.2.0.2
	OPENBSD_2_7_BASE:1.2;
locks; strict;
comment	@ * @;


1.30
date	2015.09.26.21.51.58;	author jasper;	state Exp;
branches;
next	1.29;
commitid	yS81WdIVlzEJxLUH;

1.29
date	2015.03.25.20.53.31;	author bcallah;	state Exp;
branches;
next	1.28;
commitid	zjZpBYab6uFsAfUg;

1.28
date	2015.03.25.12.29.03;	author bcallah;	state Exp;
branches;
next	1.27;
commitid	Bqpvo6ONEIbHL5KR;

1.27
date	2015.03.19.21.22.15;	author bcallah;	state Exp;
branches;
next	1.26;
commitid	GbEBL4CfPvDkB8hj;

1.26
date	2013.05.31.18.03.44;	author lum;	state Exp;
branches;
next	1.25;

1.25
date	2012.04.12.04.47.59;	author lum;	state Exp;
branches;
next	1.24;

1.24
date	2008.06.14.07.38.53;	author kjell;	state Exp;
branches;
next	1.23;

1.23
date	2006.12.21.18.06.02;	author kjell;	state Exp;
branches;
next	1.22;

1.22
date	2006.04.03.02.43.22;	author kjell;	state Exp;
branches;
next	1.21;

1.21
date	2005.12.13.07.20.13;	author kjell;	state Exp;
branches;
next	1.20;

1.20
date	2005.12.13.06.01.27;	author kjell;	state Exp;
branches;
next	1.19;

1.19
date	2005.11.19.20.14.38;	author kjell;	state Exp;
branches;
next	1.18;

1.18
date	2005.11.18.20.56.53;	author deraadt;	state Exp;
branches;
next	1.17;

1.17
date	2005.06.14.18.14.40;	author kjell;	state Exp;
branches;
next	1.16;

1.16
date	2005.04.03.02.09.28;	author db;	state Exp;
branches;
next	1.15;

1.15
date	2004.02.01.22.26.40;	author vincent;	state Exp;
branches;
next	1.14;

1.14
date	2002.07.01.14.33.44;	author vincent;	state Exp;
branches;
next	1.13;

1.13
date	2002.02.21.15.27.29;	author deraadt;	state Exp;
branches;
next	1.12;

1.12
date	2002.02.21.00.02.04;	author deraadt;	state Exp;
branches;
next	1.11;

1.11
date	2002.02.13.22.36.58;	author vincent;	state Exp;
branches;
next	1.10;

1.10
date	2001.05.24.03.05.23;	author mickey;	state Exp;
branches;
next	1.9;

1.9
date	2001.05.23.23.29.48;	author mickey;	state Exp;
branches;
next	1.8;

1.8
date	2001.05.23.22.20.35;	author art;	state Exp;
branches;
next	1.7;

1.7
date	2001.05.23.20.19.44;	author art;	state Exp;
branches;
next	1.6;

1.6
date	2001.05.23.16.14.00;	author art;	state Exp;
branches;
next	1.5;

1.5
date	2001.05.03.20.40.22;	author art;	state Exp;
branches;
next	1.4;

1.4
date	2001.01.29.01.58.07;	author niklas;	state Exp;
branches;
next	1.3;

1.3
date	2000.09.01.14.59.08;	author millert;	state Exp;
branches;
next	1.2;

1.2
date	2000.04.13.06.12.15;	author millert;	state Exp;
branches;
next	1.1;

1.1
date	2000.02.25.19.08.48;	author deraadt;	state Exp;
branches;
next	;


desc
@@


1.30
log
@whitespace
@
text
@/*	$OpenBSD: kbd.c,v 1.29 2015/03/25 20:53:31 bcallah Exp $	*/

/* This file is in the public domain. */

/*
 *	Terminal independent keyboard handling.
 */

#include <sys/queue.h>
#include <signal.h>
#include <stdio.h>

#include "def.h"
#include "kbd.h"
#include "key.h"
#include "macro.h"

#define METABIT 0x80

#define PROMPTL 80
char	 prompt[PROMPTL] = "", *promptp = prompt;

static int mgwrap(PF, int, int);

static int	 use_metakey = TRUE;
static int	 pushed = FALSE;
static int	 pushedc;

struct map_element	*ele;

struct key key;

/*
 * Toggle the value of use_metakey
 */
int
do_meta(int f, int n)
{
	if (f & FFARG)
		use_metakey = n > 0;
	else
		use_metakey = !use_metakey;
	ewprintf("Meta keys %sabled", use_metakey ? "en" : "dis");
	return (TRUE);
}

static int	 bs_map = 0;

/*
 * Toggle backspace mapping
 */
int
bsmap(int f, int n)
{
	if (f & FFARG)
		bs_map = n > 0;
	else
		bs_map = !bs_map;
	ewprintf("Backspace mapping %sabled", bs_map ? "en" : "dis");
	return (TRUE);
}

void
ungetkey(int c)
{
	if (use_metakey && pushed && c == CCHR('['))
		pushedc |= METABIT;
	else
		pushedc = c;
	pushed = TRUE;
}

int
getkey(int flag)
{
	int	 c;

	if (flag && !pushed) {
		if (prompt[0] != '\0' && ttwait(2000)) {
			/* avoid problems with % */
			ewprintf("%s", prompt);
			/* put the cursor back */
			update(CMODE);
			epresf = KCLEAR;
		}
		if (promptp > prompt)
			*(promptp - 1) = ' ';
	}
	if (pushed) {
		c = pushedc;
		pushed = FALSE;
	} else
		c = ttgetc();

	if (bs_map) {
		if (c == CCHR('H'))
			c = CCHR('?');
		else if (c == CCHR('?'))
			c = CCHR('H');
	}
	if (use_metakey && (c & METABIT)) {
		pushedc = c & ~METABIT;
		pushed = TRUE;
		c = CCHR('[');
	}
	if (flag && promptp < &prompt[PROMPTL - 5]) {
		promptp = getkeyname(promptp,
		    sizeof(prompt) - (promptp - prompt) - 1, c);
		*promptp++ = '-';
		*promptp = '\0';
	}
	return (c);
}

/*
 * doscan scans a keymap for a keyboard character and returns a pointer
 * to the function associated with that character.  Sets ele to the
 * keymap element the keyboard was found in as a side effect.
 */
PF
doscan(KEYMAP *map, int c, KEYMAP **newmap)
{
	struct map_element	*elec = &map->map_element[0];
	struct map_element	*last = &map->map_element[map->map_num];
	PF		 ret;

	while (elec < last && c > elec->k_num)
		elec++;

	/* used by prefix and binding code */
	ele = elec;
	if (elec >= last || c < elec->k_base)
		ret = map->map_default;
	else
		ret = elec->k_funcp[c - elec->k_base];
	if (ret == NULL && newmap != NULL)
		*newmap = elec->k_prefmap;

	return (ret);
}

int
doin(void)
{
	KEYMAP	*curmap;
	PF	 funct;

	*(promptp = prompt) = '\0';
	curmap = curbp->b_modes[curbp->b_nmodes]->p_map;
	key.k_count = 0;
	while ((funct = doscan(curmap, (key.k_chars[key.k_count++] =
	    getkey(TRUE)), &curmap)) == NULL)
		/* nothing */;

	if (macrodef && macrocount < MAXMACRO)
		macro[macrocount++].m_funct = funct;

	return (mgwrap(funct, 0, 1));
}

int
rescan(int f, int n)
{
	int	 c;
	KEYMAP	*curmap;
	int	 i;
	PF	 fp = NULL;
	int	 md = curbp->b_nmodes;

	for (;;) {
		if (ISUPPER(key.k_chars[key.k_count - 1])) {
			c = TOLOWER(key.k_chars[key.k_count - 1]);
			curmap = curbp->b_modes[md]->p_map;
			for (i = 0; i < key.k_count - 1; i++) {
				if ((fp = doscan(curmap, (key.k_chars[i]),
				    &curmap)) != NULL)
					break;
			}
			if (fp == NULL) {
				if ((fp = doscan(curmap, c, NULL)) == NULL)
					while ((fp = doscan(curmap,
					    key.k_chars[key.k_count++] =
					    getkey(TRUE), &curmap)) == NULL)
						/* nothing */;
				if (fp != rescan) {
					if (macrodef && macrocount <= MAXMACRO)
						macro[macrocount - 1].m_funct
						    = fp;
					return (mgwrap(fp, f, n));
				}
			}
		}
		/* try previous mode */
		if (--md < 0)
			return (ABORT);
		curmap = curbp->b_modes[md]->p_map;
		for (i = 0; i < key.k_count; i++) {
			if ((fp = doscan(curmap, (key.k_chars[i]), &curmap)) != NULL)
				break;
		}
		if (fp == NULL) {
			while ((fp = doscan(curmap, key.k_chars[i++] =
			    getkey(TRUE), &curmap)) == NULL)
				/* nothing */;
			key.k_count = i;
		}
		if (fp != rescan && i >= key.k_count - 1) {
			if (macrodef && macrocount <= MAXMACRO)
				macro[macrocount - 1].m_funct = fp;
			return (mgwrap(fp, f, n));
		}
	}
}

int
universal_argument(int f, int n)
{
	KEYMAP	*curmap;
	PF	 funct;
	int	 c, nn = 4;

	if (f & FFUNIV)
		nn *= n;
	for (;;) {
		key.k_chars[0] = c = getkey(TRUE);
		key.k_count = 1;
		if (c == '-')
			return (negative_argument(f, nn));
		if (c >= '0' && c <= '9')
			return (digit_argument(f, nn));
		curmap = curbp->b_modes[curbp->b_nmodes]->p_map;
		while ((funct = doscan(curmap, c, &curmap)) == NULL) {
			key.k_chars[key.k_count++] = c = getkey(TRUE);
		}
		if (funct != universal_argument) {
			if (macrodef && macrocount < MAXMACRO - 1) {
				if (f & FFARG)
					macrocount--;
				macro[macrocount++].m_count = nn;
				macro[macrocount++].m_funct = funct;
			}
			return (mgwrap(funct, FFUNIV, nn));
		}
		nn <<= 2;
	}
}

/* ARGSUSED */
int
digit_argument(int f, int n)
{
	KEYMAP	*curmap;
	PF	 funct;
	int	 nn, c;

	nn = key.k_chars[key.k_count - 1] - '0';
	for (;;) {
		c = getkey(TRUE);
		if (c < '0' || c > '9')
			break;
		nn *= 10;
		nn += c - '0';
	}
	key.k_chars[0] = c;
	key.k_count = 1;
	curmap = curbp->b_modes[curbp->b_nmodes]->p_map;
	while ((funct = doscan(curmap, c, &curmap)) == NULL) {
		key.k_chars[key.k_count++] = c = getkey(TRUE);
	}
	if (macrodef && macrocount < MAXMACRO - 1) {
		if (f & FFARG)
			macrocount--;
		else
			macro[macrocount - 1].m_funct = universal_argument;
		macro[macrocount++].m_count = nn;
		macro[macrocount++].m_funct = funct;
	}
	return (mgwrap(funct, FFOTHARG, nn));
}

int
negative_argument(int f, int n)
{
	KEYMAP	*curmap;
	PF	 funct;
	int	 c;
	int	 nn = 0;

	for (;;) {
		c = getkey(TRUE);
		if (c < '0' || c > '9')
			break;
		nn *= 10;
		nn += c - '0';
	}
	if (nn)
		nn = -nn;
	else
		nn = -n;
	key.k_chars[0] = c;
	key.k_count = 1;
	curmap = curbp->b_modes[curbp->b_nmodes]->p_map;
	while ((funct = doscan(curmap, c, &curmap)) == NULL) {
		key.k_chars[key.k_count++] = c = getkey(TRUE);
	}
	if (macrodef && macrocount < MAXMACRO - 1) {
		if (f & FFARG)
			macrocount--;
		else
			macro[macrocount - 1].m_funct = universal_argument;
		macro[macrocount++].m_count = nn;
		macro[macrocount++].m_funct = funct;
	}
	return (mgwrap(funct, FFNEGARG, nn));
}

/*
 * Insert a character.	While defining a macro, create a "LINE" containing
 * all inserted characters.
 */
int
selfinsert(int f, int n)
{
	struct line	*lp;
	int	 c;
	int	 count;

	if (n < 0)
		return (FALSE);
	if (n == 0)
		return (TRUE);
	c = key.k_chars[key.k_count - 1];

	if (macrodef && macrocount < MAXMACRO) {
		if (f & FFARG)
			macrocount -= 2;

		/* last command was insert -- tack on the end */
		if (lastflag & CFINS) {
			macrocount--;
			/* Ensure the line can handle the new characters */
			if (maclcur->l_size < maclcur->l_used + n) {
				if (lrealloc(maclcur, maclcur->l_used + n) ==
				    FALSE)
					return (FALSE);
			}
			maclcur->l_used += n;
			/* Copy in the new data */
			for (count = maclcur->l_used - n;
			    count < maclcur->l_used; count++)
				maclcur->l_text[count] = c;
		} else {
			macro[macrocount - 1].m_funct = insert;
			if ((lp = lalloc(n)) == NULL)
				return (FALSE);
			lp->l_bp = maclcur;
			lp->l_fp = maclcur->l_fp;
			maclcur->l_fp = lp;
			maclcur = lp;
			for (count = 0; count < n; count++)
				lp->l_text[count] = c;
		}
		thisflag |= CFINS;
	}
	if (c == '\n') {
		do {
			count = lnewline();
		} while (--n && count == TRUE);
		return (count);
	}

	/* overwrite mode */
	if (curbp->b_flag & BFOVERWRITE) {
		lchange(WFEDIT);
		while (curwp->w_doto < llength(curwp->w_dotp) && n--)
			lputc(curwp->w_dotp, curwp->w_doto++, c);
		if (n <= 0)
			return (TRUE);
	}
	return (linsert(n, c));
}

/*
 * This could be implemented as a keymap with everything defined as self-insert.
 */
int
quote(int f, int n)
{
	int	 c;

	key.k_count = 1;
	if ((key.k_chars[0] = getkey(TRUE)) >= '0' && key.k_chars[0] <= '7') {
		key.k_chars[0] -= '0';
		if ((c = getkey(TRUE)) >= '0' && c <= '7') {
			key.k_chars[0] <<= 3;
			key.k_chars[0] += c - '0';
			if ((c = getkey(TRUE)) >= '0' && c <= '7') {
				key.k_chars[0] <<= 3;
				key.k_chars[0] += c - '0';
			} else
				ungetkey(c);
		} else
			ungetkey(c);
	}
	return (selfinsert(f, n));
}

/*
 * Wraper function to count invocation repeats.
 * We ignore any function whose sole purpose is to get us
 * to the intended function.
 */
static int
mgwrap(PF funct, int f, int n)
{
	static	 PF ofp;

	if (funct != rescan &&
	    funct != negative_argument &&
	    funct != digit_argument &&
	    funct != universal_argument) {
		if (funct == ofp)
			rptcount++;
		else
			rptcount = 0;
		ofp = funct;
	}

	return ((*funct)(f, n));
}
@


1.29
log
@unifdef -U NO_DPROMPT and GOSREC.
NO_DPROMPT has been around since the import of mg2a and it has never been
considered a "(Common) compile-time option" in the Makefile.
Assume everyone has been running mg this way since at least 2000 if not
already in the 90s.

Same with GOSREC. Has always been there but it looks like no one noticed
it (and no one was running with it). Indeed, the mg tutorial appears to be
oblivious to GOSREC being an option.

With this commit there are no more #ifndef blocks in mg. Only a couple of
#ifdef blocks remain.

ok lum@@
@
text
@d1 1
a1 1
/*	$OpenBSD: kbd.c,v 1.28 2015/03/25 12:29:03 bcallah Exp $	*/
d417 1
a417 1
	
d428 1
a428 1
	
@


1.28
log
@Remove unused METACH #define.
No one is defining their own METABIT so remove the #ifndef around it.

ok florian@@
@
text
@d1 1
a1 1
/*	$OpenBSD: kbd.c,v 1.27 2015/03/19 21:22:15 bcallah Exp $	*/
a19 1
#ifndef NO_DPROMPT
a21 1
#endif /* !NO_DPROMPT */
a77 1
#ifndef NO_DPROMPT
a88 1
#endif /* !NO_DPROMPT */
a105 1
#ifndef NO_DPROMPT
a111 1
#endif /* !NO_DPROMPT */
a147 1
#ifndef NO_DPROMPT
a148 1
#endif /* !NO_DPROMPT */
@


1.27
log
@Clean up the includes in mg.
This does the following:
Moves all POSIX headers from sysdef.h into the individual .c files so that
each file now only includes what it needs. All headers are properly sorted.
Moves the remainder of sysdef.h to other files (mostly def.h) and deletes
sysdef.h now that it's no longer contains anything.
Tweak a comment that references sysdef.h so that it no longer does that.
ok florian@@
@
text
@d1 1
a1 1
/*	$OpenBSD: kbd.c,v 1.26 2013/05/31 18:03:44 lum Exp $	*/
a17 1
#ifndef METABIT
a18 1
#endif /* !METABIT */
@


1.26
log
@Make the system bell toggleable via 'audible-bell', and if switched
off, make available an alternative 'visible-bell'.

ok florian@@ jasper@@ Feedback Sunil Nimmagadda.
@
text
@d1 1
a1 1
/*	$OpenBSD: kbd.c,v 1.25 2012/04/12 04:47:59 lum Exp $	*/
d8 4
@


1.25
log
@Remove the conditional directives NO_MACRO and NO_STARTUP.
They have not compiled for numerous years.
ok kjell@@ millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: kbd.c,v 1.24 2008/06/14 07:38:53 kjell Exp $	*/
d84 1
a84 1
			update();
@


1.24
log
@unf*ck undo.
No seriously. Reposition the cursor to the start of the redo
position, like emacs. This gets us halfway to being emacs-finger-friendly.
For the rest, introduce a rptcount variable to count successive invocations
of the same function. This means undo will abort properly on C-g, and
other such interruptions.
This is a lot of diff for a simple-seeming problem. Emacs undo is hard.
@
text
@d1 1
a1 1
/*	$OpenBSD: kbd.c,v 1.23 2006/12/21 18:06:02 kjell Exp $	*/
a11 2

#ifndef NO_MACRO
a12 1
#endif /* !NO_MACRO */
d160 1
a160 1
#ifndef NO_MACRO
d163 1
a163 1
#endif /* !NO_MACRO */
a191 1
#ifndef NO_MACRO
a194 2
#endif /* !NO_MACRO */

a213 1
#ifndef NO_MACRO
a215 1
#endif /* !NO_MACRO */
a241 1
#ifndef NO_MACRO
a247 1
#endif /* !NO_MACRO */
a275 1
#ifndef NO_MACRO
a283 1
#endif /* !NO_MACRO */
a311 1
#ifndef NO_MACRO
a319 1
#endif /* !NO_MACRO */
a329 1
#ifndef NO_MACRO
a330 1
#endif /* !NO_MACRO */
d339 1
a339 1
#ifndef NO_MACRO
a370 1
#endif /* !NO_MACRO */
@


1.23
log
@Eliminate BSMAP #ifdef (we didn't define it). This exposes bsmap-mode,
which swaps ^H and DEL.

ok jason@@
@
text
@d1 1
a1 1
/*	$OpenBSD: kbd.c,v 1.22 2006/04/03 02:43:22 kjell Exp $	*/
d26 2
d167 1
a167 1
	return ((*funct)(0, 1));
d184 2
a185 2
				if ((fp = doscan(curmap, (key.k_chars[i]), &curmap))
				    != NULL)
d200 2
a201 1
					return ((*fp)(f, n));
d224 1
a224 1
			return ((*fp)(f, n));
d258 1
a258 1
			return ((*funct)(FFUNIV, nn));
d296 1
a296 1
	return ((*funct)(FFOTHARG, nn));
d334 1
a334 1
	return ((*funct)(FFNEGARG, nn));
d429 24
@


1.22
log
@fixed "text in message line would get stuck there" issue.
feedback from Philip Guenther and Han Boetes
@
text
@d1 1
a1 1
/*	$OpenBSD: kbd.c,v 1.21 2005/12/13 07:20:13 kjell Exp $	*/
d48 2
a49 2
#ifdef BSMAP
static int	 bs_map = BSMAP;
a62 1
#endif /* BSMAP */
d97 2
a98 2
#ifdef BSMAP
	if (bs_map)
d103 1
a103 1
#endif /* BSMAP */
@


1.21
log
@Last round of easy delinting.
@
text
@d1 1
a1 1
/*	$OpenBSD: kbd.c,v 1.20 2005/12/13 06:01:27 kjell Exp $	*/
d87 1
a87 1
			epresf = KPROMPT;
@


1.20
log
@More name-clash delinting
@
text
@d1 1
a1 1
/*	$OpenBSD: kbd.c,v 1.19 2005/11/19 20:14:38 kjell Exp $	*/
d176 1
a176 1
	int	 mode = curbp->b_nmodes;
d181 1
a181 1
			curmap = curbp->b_modes[mode]->p_map;
d204 1
a204 1
		if (--mode < 0)
d206 1
a206 1
		curmap = curbp->b_modes[mode]->p_map;
@


1.19
log
@Goodbye NO_METAKEY
(#ifdef is for emacs developers)
@
text
@d1 1
a1 1
/*	$OpenBSD: kbd.c,v 1.18 2005/11/18 20:56:53 deraadt Exp $	*/
d112 1
a112 1
		promptp = keyname(promptp,
@


1.18
log
@greedy use of typedef struct was making code harder to read; ok kjell cloder
@
text
@d1 1
a1 1
/*	$OpenBSD: kbd.c,v 1.17 2005/06/14 18:14:40 kjell Exp $	*/
a16 1
#ifdef DO_METAKEY
a46 1
#endif /* DO_METAKEY */
a67 1
#ifdef DO_METAKEY
a70 1
#endif /* DO_METAKEY */
a104 1
#ifdef DO_METAKEY
a109 1
#endif /* DO_METAKEY */
@


1.17
log
@Add explicit public domain notices to all public domain files.
ok millert@@, deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: kbd.c,v 1.16 2005/04/03 02:09:28 db Exp $	*/
d31 1
a31 1
MAP_ELEMENT	*ele;
d135 2
a136 2
	MAP_ELEMENT	*elec = &map->map_element[0];
	MAP_ELEMENT	*last = &map->map_element[map->map_num];
d349 1
a349 1
	LINE	*lp;
@


1.16
log
@This is a no binary change which does:

- spelling, punctuation fixes
- variable declaration lineup
- use parentheses for return and sizeof
- K&R function declarations -> ANSI
- other minor code beautification

ok henning@@
@
text
@d1 3
a3 1
/*	$OpenBSD: kbd.c,v 1.15 2004/02/01 22:26:40 vincent Exp $	*/
@


1.15
log
@remove old precompiler weirdness that is not really needed...
@
text
@d1 1
a1 1
/*	$OpenBSD: kbd.c,v 1.14 2002/07/01 14:33:44 vincent Exp $	*/
d44 1
a44 1
	return TRUE;
d61 1
a61 1
	return TRUE;
d122 1
a122 1
	return c;
d135 1
a135 1
	PF		ret;
d149 1
a149 1
	return ret;
d165 1
a165 1
		/*nothing*/;
d170 1
a170 1
	return (*funct)(0, 1);
d196 1
a196 1
						/*nothing*/;
d203 1
a203 1
					return (*fp)(f, n);
d209 1
a209 1
			return ABORT;
d218 1
a218 1
				/*nothing*/;
d226 1
a226 1
			return (*fp)(f, n);
d236 1
a236 2
	int	 c;
	int	 nn = 4;
d244 1
a244 1
			return negative_argument(f, nn);
d246 1
a246 1
			return digit_argument(f, nn);
d260 1
a260 1
			return (*funct)(FFUNIV, nn);
d298 1
a298 1
	return (*funct)(FFOTHARG, nn);
d336 1
a336 1
	return (*funct)(FFNEGARG, nn);
d353 1
a353 1
		return FALSE;
d355 1
a355 1
		return TRUE;
d369 1
a369 1
					return FALSE;
d379 1
a379 1
				return FALSE;
d394 1
a394 1
		return count;
d403 1
a403 1
			return TRUE;
d405 1
a405 1
	return linsert(n, c);
d409 1
a409 1
 * This could be implemented as a keymap with everthing defined as self-insert.
d430 1
a430 1
	return selfinsert(f, n);
@


1.14
log
@KNF + ansi; from zyrnix (only the easy part of his diffs)
@
text
@d1 1
a1 1
/*	$OpenBSD: kbd.c,v 1.13 2002/02/21 15:27:29 deraadt Exp $	*/
a6 2
#define EXTERN

d30 2
@


1.13
log
@KNF
@
text
@d1 1
a1 1
/*	$OpenBSD: kbd.c,v 1.12 2002/02/21 00:02:04 deraadt Exp $	*/
d37 1
a37 2
do_meta(f, n)
	int f, n;
d54 1
a54 2
bsmap(f, n)
	int f, n;
d66 1
a66 2
ungetkey(c)
	int	c;
d78 1
a78 2
getkey(flag)
	int flag;
d131 1
a131 4
doscan(map, c, newmap)
	KEYMAP	*map;
	int	c;
	KEYMAP	**newmap;
d153 1
a153 1
doin()
d174 1
a174 2
rescan(f, n)
	int f, n;
d232 1
a232 2
universal_argument(f, n)
	int f, n;
d269 1
a269 2
digit_argument(f, n)
	int f, n;
d303 1
a303 2
negative_argument(f, n)
	int f, n;
d345 1
a345 2
selfinsert(f, n)
	int f, n;
d413 1
a413 2
quote(f, n)
	int f, n;
@


1.12
log
@signal-safe window size changing
@
text
@d1 1
a1 1
/*	$OpenBSD: kbd.c,v 1.11 2002/02/13 22:36:58 vincent Exp $	*/
d387 1
a387 1
			     count < maclcur->l_used; count++)
@


1.11
log
@ Make mg malloc the l_text element instead of reallocating whole LINE
 structures all the time.
@
text
@d1 1
a1 1
/*	$OpenBSD: kbd.c,v 1.10 2001/05/24 03:05:23 mickey Exp $	*/
d103 1
a103 1
		c = getkbd();
@


1.10
log
@spaces
@
text
@d1 1
a1 1
/*	$OpenBSD: kbd.c,v 1.9 2001/05/23 23:29:48 mickey Exp $	*/
d378 1
d380 2
a381 1
				if ((lp = lallocx(maclcur->l_used + n)) == NULL)
a382 15
				lp->l_fp = maclcur->l_fp;
				lp->l_bp = maclcur->l_bp;
				lp->l_fp->l_bp = lp->l_bp->l_fp = lp;
				bcopy(maclcur->l_text, lp->l_text,
				    maclcur->l_used);
				for (count = maclcur->l_used;
				    count < lp->l_used; count++)
					lp->l_text[count] = c;
				free((char *)maclcur);
				maclcur = lp;
			} else {
				maclcur->l_used += n;
				for (count = maclcur->l_used - n;
				    count < maclcur->l_used; count++)
					maclcur->l_text[count] = c;
d384 5
d391 1
a391 1
			if ((lp = lallocx(n)) == NULL)
@


1.9
log
@cinfo is const, keyname() and findbind() take buffer size to use strlcpy vs cpy+len
@
text
@d1 1
a1 1
/*	$OpenBSD: kbd.c,v 1.8 2001/05/23 22:20:35 art Exp $	*/
d69 1
a69 1
	int     c;
d136 3
a138 3
	KEYMAP *map;
	int     c;
	KEYMAP **newmap;
d195 1
a195 1
				if ((fp = doscan(curmap, (key.k_chars[i]), &curmap)) 
d208 1
a208 1
						macro[macrocount - 1].m_funct 
d224 1
a224 1
			while ((fp = doscan(curmap, key.k_chars[i++] = 
d245 1
a245 1
	int	 c; 
d384 1
a384 1
				bcopy(maclcur->l_text, lp->l_text, 
d386 1
a386 1
				for (count = maclcur->l_used; 
@


1.8
log
@remove VOID. We're way beyond the point where this could build with an
ancient compiler.
@
text
@d1 1
a1 1
/*	$OpenBSD: kbd.c,v 1.7 2001/05/23 20:19:44 art Exp $	*/
d24 1
a24 1
char	 prompt[PROMPTL], *promptp;
d120 2
a121 1
		promptp = keyname(promptp, c);
@


1.7
log
@Add an argument to doscan which is a pointer to a KEYMAP pointer.
If that argument is not NULL, we set it to the k_prefmap of the pressed
key if there is one.
This is what most of the users of doscan did anyway, but they did it through
leaked global state.
@
text
@d1 1
a1 1
/*	$OpenBSD: kbd.c,v 1.6 2001/05/23 16:14:00 art Exp $	*/
d67 1
a67 1
VOID
@


1.6
log
@Get rid of 'prefix' and use NULL instead.
@
text
@d1 1
a1 1
/*	$OpenBSD: kbd.c,v 1.5 2001/05/03 20:40:22 art Exp $	*/
d134 1
a134 1
doscan(map, c)
d137 1
d141 1
d149 7
a155 2
		return map->map_default;
	return elec->k_funcp[c - elec->k_base];
d170 2
a171 2
	    getkey(TRUE)))) == NULL)
		curmap = ele->k_prefmap;
d194 1
a194 1
				if ((fp = doscan(curmap, (key.k_chars[i]))) 
a196 1
				curmap = ele->k_prefmap;
d199 1
a199 1
				if ((fp = doscan(curmap, c)) == NULL)
d202 2
a203 2
					    getkey(TRUE))) == NULL)
						curmap = ele->k_prefmap;
d219 1
a219 1
			if ((fp = doscan(curmap, (key.k_chars[i]))) != NULL)
a220 1
			curmap = ele->k_prefmap;
d224 2
a225 2
			    getkey(TRUE))) == NULL)
				curmap = ele->k_prefmap;
d257 1
a257 2
		while ((funct = doscan(curmap, c)) == NULL) {
			curmap = ele->k_prefmap;
d295 1
a295 2
	while ((funct = doscan(curmap, c)) == NULL) {
		curmap = ele->k_prefmap;
d334 1
a334 2
	while ((funct = doscan(curmap, c)) == NULL) {
		curmap = ele->k_prefmap;
@


1.5
log
@Add a delay (in miliseconds) argument to ttwait.
@
text
@d1 1
a1 1
/*	$OpenBSD: kbd.c,v 1.4 2001/01/29 01:58:07 niklas Exp $	*/
d163 1
a163 1
	    getkey(TRUE)))) == prefix)
d188 1
a188 1
				    != prefix)
d192 2
a193 2
			if (fp == prefix) {
				if ((fp = doscan(curmap, c)) == prefix)
d196 1
a196 1
					    getkey(TRUE))) == prefix)
d213 1
a213 1
			if ((fp = doscan(curmap, (key.k_chars[i]))) != prefix)
d217 1
a217 1
		if (fp == prefix) {
d219 1
a219 1
			    getkey(TRUE))) == prefix)
d252 1
a252 1
		while ((funct = doscan(curmap, c)) == prefix) {
d291 1
a291 1
	while ((funct = doscan(curmap, c)) == prefix) {
d331 1
a331 1
	while ((funct = doscan(curmap, c)) == prefix) {
@


1.4
log
@$OpenBSD$
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d88 1
a88 1
		if (prompt[0] != '\0' && ttwait()) {
@


1.3
log
@More -Wall anmd KNF, from op2@@tomahawk.SQUiSH.org
@
text
@d1 2
@


1.2
log
@The start of KNF + -Wall.  The code has been run through indent but
needs hand fixup.  I stopped at keymap.c...
@
text
@d2 1
a2 1
 *		Terminal independent keyboard handling.
a3 2
#include	"def.h"
#include	"kbd.h"
d6 4
a9 1
#include	"key.h"
d13 1
a13 1
#endif
d15 1
a15 1
#ifdef	DO_METAKEY
d18 6
a23 1
#endif
d25 5
a29 1
int             use_metakey = TRUE;
a37 1

d45 1
a45 1
#endif
d47 2
a48 2
#ifdef	BSMAP
static int      bs_map = BSMAP;
a55 1

d63 1
a63 9
#endif

#ifndef NO_DPROMPT
#define PROMPTL 80
char            prompt[PROMPTL], *promptp;
#endif

static int      pushed = FALSE;
static int      pushedc;
d69 1
a69 2

#ifdef	DO_METAKEY
d73 1
a73 1
#endif
d80 1
a80 1
	int     flag;
d82 1
a82 1
	int     c;
d87 4
a90 2
			ewprintf("%s", prompt);	/* avoid problems with % */
			update();	/* put the cursor back	 */
d96 1
a96 1
#endif
d102 1
a102 1
#ifdef 	BSMAP
d108 2
a109 2
#endif
#ifdef	DO_METAKEY
d115 1
a115 1
#endif
d122 1
a122 1
#endif
a130 3

MAP_ELEMENT    *ele;

d136 2
a137 2
	MAP_ELEMENT *elec = &map->map_element[0];
	MAP_ELEMENT *last = &map->map_element[map->map_num];
d141 3
a143 1
	ele = elec;		/* used by prefix and binding code	 */
d152 2
a153 2
	KEYMAP *curmap;
	PF      funct;
d157 1
a157 1
#endif
d166 2
a167 2
#endif
	return (*funct) (0, 1);
d172 1
a172 1
	int     f, n;
d174 5
a178 5
	int     c;
	KEYMAP *curmap;
	int     i;
	PF      fp;
	int     mode = curbp->b_nmodes;
d185 2
a186 1
				if ((fp = doscan(curmap, (key.k_chars[i]))) != prefix)
d194 1
a194 1
						   getkey(TRUE))) == prefix)
d199 4
a202 3
						macro[macrocount - 1].m_funct = fp;
#endif
					return (*fp) (f, n);
d216 2
a217 2
			while ((fp = doscan(curmap, key.k_chars[i++] = getkey(TRUE)))
			       == prefix)
d225 2
a226 2
#endif
			return (*fp) (f, n);
d233 1
a233 1
	int     f, n;
d235 4
a238 3
	int     c, nn = 4;
	KEYMAP *curmap;
	PF      funct;
d262 2
a263 2
#endif
			return (*funct) (FFUNIV, nn);
d272 1
a272 1
	int     f, n;
d274 3
a276 3
	int     nn, c;
	KEYMAP *curmap;
	PF      funct;
d302 2
a303 2
#endif
	return (*funct) (FFOTHARG, nn);
d308 1
a308 1
	int     f, n;
d310 4
a313 3
	int     nn = 0, c;
	KEYMAP *curmap;
	PF      funct;
d342 2
a343 2
#endif
	return (*funct) (FFNEGARG, nn);
d352 1
a352 1
	int    f, n;
a353 2
	int    c;
	int    count;
d355 4
a358 2
	LINE  *lp;
#endif
d369 3
a371 2
		if (lastflag & CFINS) {	/* last command was insert -- tack on
					 * end */
d379 4
a382 2
				bcopy(maclcur->l_text, lp->l_text, maclcur->l_used);
				for (count = maclcur->l_used; count < lp->l_used; count++)
d384 1
a384 1
				free((char *) maclcur);
d405 1
a405 1
#endif
d412 3
a414 1
	if (curbp->b_flag & BFOVERWRITE) {	/* Overwrite mode	 */
d425 1
a425 2
 * This could be implemented as a keymap with everthing defined
 * as self-insert.
d429 1
a429 1
	int    f, n;
d431 1
a431 1
	int    c;
@


1.1
log
@initial import of mg2a
@
text
@d19 1
a19 1
int use_metakey = TRUE;
d24 1
d26 1
d28 5
a32 2
	if(f & FFARG)	use_metakey = n > 0;
	else		use_metakey = !use_metakey;
d39 1
a39 1
static int bs_map = BSMAP;
d43 1
d45 1
d47 5
a51 2
	if(f & FFARG)	bs_map = n > 0;
	else		bs_map = ! bs_map;
d59 1
a59 1
  char	prompt[PROMPTL], *promptp;
d62 2
a63 2
static	int	pushed = FALSE;
static	int	pushedc;
d65 3
a67 2
VOID	ungetkey(c)
int	c;
d69 1
d71 2
a72 1
	if(use_metakey && pushed && c==CCHR('[')) pushedc |= METABIT;
d79 3
a81 2
int getkey(flag)
int	flag;
d83 1
a83 2
	int	c;
	char	*keyname();
d86 2
a87 2
	if(flag && !pushed) {
		if(prompt[0]!='\0' && ttwait()) {
d89 1
a89 1
			update();		/* put the cursor back	 */
d92 2
a93 1
		if(promptp > prompt) *(promptp-1) = ' ';
d96 1
a96 1
	if(pushed) {
d99 2
a100 1
	} else	c = getkbd();
d102 6
a107 4
	if(bs_map)
		if(c==CCHR('H')) c=CCHR('?');
		else if(c==CCHR('?')) c=CCHR('H');
#endif	
d109 1
a109 1
	if(use_metakey && (c&METABIT)) {
d116 4
a119 4
	if(flag && promptp < &prompt[PROMPTL - 5]) {
	    promptp = keyname(promptp, c);
	    *promptp++ = '-';
	    *promptp = '\0';
d131 9
a139 1
MAP_ELEMENT *ele;
d141 6
a146 12
PF	doscan(map, c)
register KEYMAP *map;
register int	c;
{
    register MAP_ELEMENT *elec = &map->map_element[0];	/* local register copy for faster access */
    register MAP_ELEMENT *last = &map->map_element[map->map_num];

    while(elec < last && c > elec->k_num) elec++;
    ele = elec;			/* used by prefix and binding code	*/
    if(elec >= last || c < elec->k_base)
	return map->map_default;
    return elec->k_funcp[c - elec->k_base];
d149 1
d152 2
a153 2
	KEYMAP	*curmap;
	PF	funct;
d156 1
a156 1
    *(promptp = prompt) = '\0';
d158 5
a162 5
    curmap = curbp->b_modes[curbp->b_nmodes]->p_map;
    key.k_count = 0;
    while((funct=doscan(curmap,(key.k_chars[key.k_count++]=getkey(TRUE))))
		== prefix)
	curmap = ele->k_prefmap;
d164 2
a165 2
    if(macrodef && macrocount < MAXMACRO)
	macro[macrocount++].m_funct = funct;
d167 1
a167 1
    return (*funct)(0, 1);
d170 1
d172 1
a172 1
int f, n;
d174 37
a210 18
    int c;
    register KEYMAP *curmap;
    int i;
    PF	fp;
    int mode = curbp->b_nmodes;

    for(;;) {
	if(ISUPPER(key.k_chars[key.k_count-1])) {
	    c = TOLOWER(key.k_chars[key.k_count-1]);
	    curmap = curbp->b_modes[mode]->p_map;
	    for(i=0; i < key.k_count-1; i++) {
		if((fp=doscan(curmap,(key.k_chars[i]))) != prefix) break;
		curmap = ele->k_prefmap;
	    }
	    if(fp==prefix) {
		if((fp = doscan(curmap, c)) == prefix)
		    while((fp=doscan(curmap,key.k_chars[key.k_count++] =
			    getkey(TRUE))) == prefix)
d212 8
a219 1
		if(fp!=rescan) {
d221 2
a222 2
		    if(macrodef && macrocount <= MAXMACRO)
			macro[macrocount-1].m_funct = fp;
d224 1
a224 1
		    return (*fp)(f, n);
a225 1
	    }
d227 25
a251 14
	/* try previous mode */
	if(--mode < 0) return ABORT;
	curmap = curbp->b_modes[mode]->p_map;
	for(i=0; i < key.k_count; i++) {
	    if((fp=doscan(curmap,(key.k_chars[i]))) != prefix) break;
	    curmap = ele->k_prefmap;
	}
	if(fp==prefix) {
	    while((fp=doscan(curmap,key.k_chars[i++]=getkey(TRUE)))
		    == prefix)
		curmap = ele->k_prefmap;
	    key.k_count = i;
	}
	if(fp!=rescan && i>=key.k_count-1) {
d253 6
a258 2
	    if(macrodef && macrocount <= MAXMACRO)
		macro[macrocount-1].m_funct = fp;
d260 3
a262 1
	    return (*fp)(f, n);
a263 1
    }
d266 4
a269 2
universal_argument(f, n)
int f, n;
d271 13
a283 7
    int c, nn=4;
    KEYMAP *curmap;
    PF	funct;

    if(f&FFUNIV) nn *= n;
    for(;;) {
	key.k_chars[0] = c = getkey(TRUE);
a284 2
	if(c == '-') return negative_argument(f, nn);
	if(c >= '0' && c <= '9') return digit_argument(f, nn);
d286 3
a288 3
	while((funct=doscan(curmap,c)) == prefix) {
	    curmap = ele->k_prefmap;
	    key.k_chars[key.k_count++] = c = getkey(TRUE);
a289 1
	if(funct != universal_argument) {
d291 5
a295 2
	    if(macrodef && macrocount < MAXMACRO-1) {
		if(f&FFARG) macrocount--;
a297 3
	    }
#endif
	    return (*funct)(FFUNIV, nn);
a298 33
	nn <<= 2;
    }
}

/*ARGSUSED*/
digit_argument(f, n)
int f, n;
{
    int nn, c;
    KEYMAP *curmap;
    PF	funct;

    nn = key.k_chars[key.k_count-1] - '0';
    for(;;) {
	c = getkey(TRUE);
	if(c < '0' || c > '9') break;
	nn *= 10;
	nn += c - '0';
    }
    key.k_chars[0] = c;
    key.k_count = 1;
    curmap = curbp->b_modes[curbp->b_nmodes]->p_map;
    while((funct=doscan(curmap,c)) == prefix) {
	curmap = ele->k_prefmap;
	key.k_chars[key.k_count++] = c = getkey(TRUE);
    }
#ifndef NO_MACRO
    if(macrodef && macrocount < MAXMACRO-1) {
	if(f&FFARG) macrocount--;
	else macro[macrocount-1].m_funct = universal_argument;
	macro[macrocount++].m_count = nn;
	macro[macrocount++].m_funct = funct;
    }
d300 1
a300 1
    return (*funct)(FFOTHARG, nn);
d303 1
d305 1
a305 1
int f, n;
d307 22
a328 19
    int nn = 0, c;
    KEYMAP *curmap;
    PF	funct;

    for(;;) {
	c = getkey(TRUE);
	if(c < '0' || c > '9') break;
	nn *= 10;
	nn += c - '0';
    }
    if(nn) nn = -nn;
    else nn = -n;
    key.k_chars[0] = c;
    key.k_count = 1;
    curmap = curbp->b_modes[curbp->b_nmodes]->p_map;
    while((funct=doscan(curmap,c)) == prefix) {
	curmap = ele->k_prefmap;
	key.k_chars[key.k_count++] = c = getkey(TRUE);
    }
d330 8
a337 6
    if(macrodef && macrocount < MAXMACRO-1) {
	if(f&FFARG) macrocount--;
	else macro[macrocount-1].m_funct = universal_argument;
	macro[macrocount++].m_count = nn;
	macro[macrocount++].m_funct = funct;
    }
d339 1
a339 1
    return (*funct)(FFNEGARG, nn);
d346 1
a346 1

d348 1
a348 1
int f, n;
d350 2
a351 3
    register int c;
    int count;
    VOID lchange();
d353 1
a353 2
    LINE *lp;
    int insert();
d356 5
a360 3
    if (n < 0)	return FALSE;
    if (n == 0) return TRUE;
    c = key.k_chars[key.k_count-1];
d362 51
a412 46
    if(macrodef && macrocount < MAXMACRO) {
	if(f & FFARG) macrocount -= 2;
	if(lastflag & CFINS) {	/* last command was insert -- tack on end */
	    macrocount--;
	    if(maclcur->l_size < maclcur->l_used + n) {
		if((lp = lallocx(maclcur->l_used + n)) == NULL)
		    return FALSE;
		lp->l_fp = maclcur->l_fp;
		lp->l_bp = maclcur->l_bp;
		lp->l_fp->l_bp = lp->l_bp->l_fp = lp;
		bcopy(maclcur->l_text, lp->l_text, maclcur->l_used);
		for(count = maclcur->l_used; count < lp->l_used; count++)
		    lp->l_text[count] = c;
		free((char *)maclcur);
		maclcur = lp;
	    } else {
		maclcur->l_used += n;
		for(count = maclcur->l_used-n; count < maclcur->l_used; count++)
		    maclcur->l_text[count] = c;
	    }
	} else {
	    macro[macrocount-1].m_funct = insert;
	    if((lp = lallocx(n)) == NULL) return FALSE;
	    lp->l_bp = maclcur;
	    lp->l_fp = maclcur->l_fp;
	    maclcur->l_fp = lp;
	    maclcur = lp;
	    for(count = 0; count < n; count++)
		lp->l_text[count] = c;
	}
	thisflag |= CFINS;
    }
#endif
    if(c == '\n') {
	do {
	    count = lnewline();
	} while (--n && count==TRUE);
	return count;
    }
    if(curbp->b_flag & BFOVERWRITE) {		/* Overwrite mode	*/
	lchange(WFEDIT);
	while(curwp->w_doto < llength(curwp->w_dotp) && n--)
	    lputc(curwp->w_dotp, curwp->w_doto++, c);
	if(n<=0) return TRUE;
    }
    return linsert(n, c);
d416 1
a416 1
 * this could be implemented as a keymap with everthing defined
d419 1
d421 1
d423 1
a423 1
    register int c;
d425 15
a439 13
    key.k_count = 1;
    if((key.k_chars[0] = getkey(TRUE)) >= '0' && key.k_chars[0] <= '7') {
	key.k_chars[0] -= '0';
	if((c = getkey(TRUE)) >= '0' && c <= '7') {
	    key.k_chars[0] <<= 3;
	    key.k_chars[0] += c - '0';
	    if((c = getkey(TRUE)) >= '0' && c <= '7') {
		key.k_chars[0] <<= 3;
		key.k_chars[0] += c - '0';
	    } else ungetkey(c);
	} else ungetkey(c);
    }
    return selfinsert(f, n);
@

