head	1.36;
access;
symbols
	OPENBSD_6_2_BASE:1.36
	OPENBSD_6_1:1.36.0.8
	OPENBSD_6_1_BASE:1.36
	OPENBSD_6_0:1.36.0.4
	OPENBSD_6_0_BASE:1.36
	OPENBSD_5_9:1.36.0.2
	OPENBSD_5_9_BASE:1.36
	OPENBSD_5_8:1.33.0.4
	OPENBSD_5_8_BASE:1.33
	OPENBSD_5_7:1.31.0.2
	OPENBSD_5_7_BASE:1.31
	OPENBSD_5_6:1.31.0.4
	OPENBSD_5_6_BASE:1.31
	OPENBSD_5_5:1.29.0.6
	OPENBSD_5_5_BASE:1.29
	OPENBSD_5_4:1.29.0.2
	OPENBSD_5_4_BASE:1.29
	OPENBSD_5_3:1.28.0.8
	OPENBSD_5_3_BASE:1.28
	OPENBSD_5_2:1.28.0.6
	OPENBSD_5_2_BASE:1.28
	OPENBSD_5_1_BASE:1.28
	OPENBSD_5_1:1.28.0.4
	OPENBSD_5_0:1.28.0.2
	OPENBSD_5_0_BASE:1.28
	OPENBSD_4_9:1.27.0.8
	OPENBSD_4_9_BASE:1.27
	OPENBSD_4_8:1.27.0.6
	OPENBSD_4_8_BASE:1.27
	OPENBSD_4_7:1.27.0.2
	OPENBSD_4_7_BASE:1.27
	OPENBSD_4_6:1.27.0.4
	OPENBSD_4_6_BASE:1.27
	OPENBSD_4_5:1.25.0.12
	OPENBSD_4_5_BASE:1.25
	OPENBSD_4_4:1.25.0.10
	OPENBSD_4_4_BASE:1.25
	OPENBSD_4_3:1.25.0.8
	OPENBSD_4_3_BASE:1.25
	OPENBSD_4_2:1.25.0.6
	OPENBSD_4_2_BASE:1.25
	OPENBSD_4_1:1.25.0.4
	OPENBSD_4_1_BASE:1.25
	OPENBSD_4_0:1.25.0.2
	OPENBSD_4_0_BASE:1.25
	OPENBSD_3_9:1.21.0.2
	OPENBSD_3_9_BASE:1.21
	OPENBSD_3_8:1.17.0.2
	OPENBSD_3_8_BASE:1.17
	OPENBSD_3_7:1.15.0.6
	OPENBSD_3_7_BASE:1.15
	OPENBSD_3_6:1.15.0.4
	OPENBSD_3_6_BASE:1.15
	OPENBSD_3_5:1.15.0.2
	OPENBSD_3_5_BASE:1.15
	OPENBSD_3_4:1.11.0.2
	OPENBSD_3_4_BASE:1.11
	OPENBSD_3_3:1.10.0.6
	OPENBSD_3_3_BASE:1.10
	OPENBSD_3_2:1.10.0.4
	OPENBSD_3_2_BASE:1.10
	OPENBSD_3_1:1.10.0.2
	OPENBSD_3_1_BASE:1.10
	OPENBSD_3_0:1.7.0.2
	OPENBSD_3_0_BASE:1.7
	OPENBSD_2_9_BASE:1.5
	OPENBSD_2_9:1.5.0.2
	OPENBSD_2_8:1.4.0.2
	OPENBSD_2_8_BASE:1.4
	OPENBSD_2_7:1.3.0.2
	OPENBSD_2_7_BASE:1.3;
locks; strict;
comment	@ * @;


1.36
date	2015.11.18.18.21.06;	author jasper;	state Exp;
branches;
next	1.35;
commitid	EC3wzGIKql4nQJg3;

1.35
date	2015.10.29.20.20.49;	author lum;	state Exp;
branches;
next	1.34;
commitid	pIsWfSYZAYWKPXSK;

1.34
date	2015.10.09.07.27.56;	author lum;	state Exp;
branches;
next	1.33;
commitid	RvjH1Qc2giehopE4;

1.33
date	2015.03.25.20.53.31;	author bcallah;	state Exp;
branches;
next	1.32;
commitid	zjZpBYab6uFsAfUg;

1.32
date	2015.03.19.21.22.15;	author bcallah;	state Exp;
branches;
next	1.31;
commitid	GbEBL4CfPvDkB8hj;

1.31
date	2014.05.28.07.59.36;	author florian;	state Exp;
branches;
next	1.30;

1.30
date	2014.03.20.07.47.29;	author lum;	state Exp;
branches;
next	1.29;

1.29
date	2013.05.31.18.03.45;	author lum;	state Exp;
branches;
next	1.28;

1.28
date	2011.08.01.12.15.23;	author lum;	state Exp;
branches;
next	1.27;

1.27
date	2009.06.04.23.39.37;	author kjell;	state Exp;
branches;
next	1.26;

1.26
date	2009.06.04.02.23.37;	author kjell;	state Exp;
branches;
next	1.25;

1.25
date	2006.07.25.08.22.32;	author kjell;	state Exp;
branches;
next	1.24;

1.24
date	2006.06.01.09.00.50;	author kjell;	state Exp;
branches;
next	1.23;

1.23
date	2006.05.29.00.02.23;	author kjell;	state Exp;
branches;
next	1.22;

1.22
date	2006.05.28.23.30.16;	author kjell;	state Exp;
branches;
next	1.21;

1.21
date	2006.02.25.14.40.16;	author otto;	state Exp;
branches;
next	1.20;

1.20
date	2005.12.13.06.01.27;	author kjell;	state Exp;
branches;
next	1.19;

1.19
date	2005.11.18.20.56.53;	author deraadt;	state Exp;
branches;
next	1.18;

1.18
date	2005.10.11.01.08.53;	author kjell;	state Exp;
branches;
next	1.17;

1.17
date	2005.06.14.18.14.40;	author kjell;	state Exp;
branches;
next	1.16;

1.16
date	2005.04.03.02.09.28;	author db;	state Exp;
branches;
next	1.15;

1.15
date	2004.01.27.23.43.37;	author vincent;	state Exp;
branches;
next	1.14;

1.14
date	2003.11.29.17.28.39;	author vincent;	state Exp;
branches;
next	1.13;

1.13
date	2003.10.27.11.21.12;	author vincent;	state Exp;
branches;
next	1.12;

1.12
date	2003.10.21.22.48.07;	author vincent;	state Exp;
branches;
next	1.11;

1.11
date	2003.05.20.03.08.55;	author cloder;	state Exp;
branches;
next	1.10;

1.10
date	2002.02.20.23.57.52;	author deraadt;	state Exp;
branches;
next	1.9;

1.9
date	2002.02.14.14.24.21;	author deraadt;	state Exp;
branches;
next	1.8;

1.8
date	2002.02.08.21.21.11;	author deraadt;	state Exp;
branches;
next	1.7;

1.7
date	2001.05.24.03.05.27;	author mickey;	state Exp;
branches;
next	1.6;

1.6
date	2001.05.23.22.36.15;	author art;	state Exp;
branches;
next	1.5;

1.5
date	2001.01.29.01.58.10;	author niklas;	state Exp;
branches;
next	1.4;

1.4
date	2000.09.01.14.59.09;	author millert;	state Exp;
branches;
next	1.3;

1.3
date	2000.04.13.06.12.18;	author millert;	state Exp;
branches;
next	1.2;

1.2
date	2000.02.26.22.53.16;	author millert;	state Exp;
branches;
next	1.1;

1.1
date	2000.02.25.19.08.52;	author deraadt;	state Exp;
branches;
next	;


desc
@@


1.36
log
@whitespace
@
text
@/*	$OpenBSD: window.c,v 1.35 2015/10/29 20:20:49 lum Exp $	*/

/* This file is in the public domain. */

/*
 *		Window handling.
 */

#include <sys/queue.h>
#include <signal.h>
#include <stdio.h>
#include <stdlib.h>

#include "def.h"

struct mgwin *
new_window(struct buffer *bp)
{
	struct mgwin *wp;

	wp = calloc(1, sizeof(struct mgwin));
	if (wp == NULL)
		return (NULL);

	wp->w_bufp = bp;
	wp->w_dotp = NULL;
	wp->w_doto = 0;
	wp->w_markp = NULL;
	wp->w_marko = 0;
	wp->w_rflag = 0;
	wp->w_frame = 0;
	wp->w_wrapline = NULL;
	wp->w_dotline = wp->w_markline = 1;
	if (bp)
		bp->b_nwnd++;
	return (wp);
}

/*
 * Reposition dot in the current window to line "n".  If the argument is
 * positive, it is that line.  If it is negative it is that line from the
 * bottom.  If it is 0 the window is centered (this is what the standard
 * redisplay code does).
 */
/* ARGSUSED */
int
reposition(int f, int n)
{
	curwp->w_frame = (f & FFARG) ? (n >= 0 ? n + 1 : n) : 0;
	curwp->w_rflag |= WFFRAME;
	sgarbf = TRUE;
	return (TRUE);
}

/*
 * Refresh the display.  A call is made to the "ttresize" entry in the
 * terminal handler, which tries to reset "nrow" and "ncol".  They will,
 * however, never be set outside of the NROW or NCOL range.  If the display
 * changed size, arrange that everything is redone, then call "update" to
 * fix the display.  We do this so the new size can be displayed.  In the
 * normal case the call to "update" in "main.c" refreshes the screen, and
 * all of the windows need not be recomputed. This call includes a
 * 'force' parameter to ensure that the redraw is done, even after a
 * a suspend/continue (where the window size parameters will already
 * be updated). Note that when you get to the "display unusable"
 * message, the screen will be messed up. If you make the window bigger
 * again, and send another command, everything will get fixed!
 */
int
redraw(int f, int n)
{
	return (do_redraw(f, n, FALSE));
}

/* ARGSUSED */
int
do_redraw(int f, int n, int force)
{
	struct mgwin	*wp;
	int		 oldnrow, oldncol;

	oldnrow = nrow;
	oldncol = ncol;
	ttresize();
	if (nrow != oldnrow || ncol != oldncol || force) {

		/* find last */
		wp = wheadp;
		while (wp->w_wndp != NULL)
			wp = wp->w_wndp;

		/* check if too small */
		if (nrow < wp->w_toprow + 3) {
			dobeep();
			ewprintf("Display unusable");
			return (FALSE);
		}
		wp->w_ntrows = nrow - wp->w_toprow - 2;
		sgarbf = TRUE;
		update(CMODE);
	} else
		sgarbf = TRUE;
	return (TRUE);
}

/*
 * The command to make the next window (next => down the screen) the current
 * window. There are no real errors, although the command does nothing if
 * there is only 1 window on the screen.
 */
/* ARGSUSED */
int
nextwind(int f, int n)
{
	struct mgwin	*wp;

	if ((wp = curwp->w_wndp) == NULL)
		wp = wheadp;
	curwp = wp;
	curbp = wp->w_bufp;
	return (TRUE);
}

/* not in GNU Emacs */
/*
 * This command makes the previous window (previous => up the screen) the
 * current window. There are no errors, although the command does not do
 * a lot if there is only 1 window.
 */
/* ARGSUSED */
int
prevwind(int f, int n)
{
	struct mgwin	*wp1, *wp2;

	wp1 = wheadp;
	wp2 = curwp;
	if (wp1 == wp2)
		wp2 = NULL;
	while (wp1->w_wndp != wp2)
		wp1 = wp1->w_wndp;
	curwp = wp1;
	curbp = wp1->w_bufp;
	return (TRUE);
}

/*
 * This command makes the current window the only window on the screen.  Try
 * to set the framing so that "." does not have to move on the display.  Some
 * care has to be taken to keep the values of dot and mark in the buffer
 * structures right if the destruction of a window makes a buffer become
 * undisplayed.
 */
/* ARGSUSED */
int
onlywind(int f, int n)
{
	struct mgwin	*wp;
	struct line	*lp;
	int		 i;

	while (wheadp != curwp) {
		wp = wheadp;
		wheadp = wp->w_wndp;
		if (--wp->w_bufp->b_nwnd == 0) {
			wp->w_bufp->b_dotp = wp->w_dotp;
			wp->w_bufp->b_doto = wp->w_doto;
			wp->w_bufp->b_markp = wp->w_markp;
			wp->w_bufp->b_marko = wp->w_marko;
			wp->w_bufp->b_dotline = wp->w_dotline;
			wp->w_bufp->b_markline = wp->w_markline;
		}
		free(wp);
	}
	while (curwp->w_wndp != NULL) {
		wp = curwp->w_wndp;
		curwp->w_wndp = wp->w_wndp;
		if (--wp->w_bufp->b_nwnd == 0) {
			wp->w_bufp->b_dotp = wp->w_dotp;
			wp->w_bufp->b_doto = wp->w_doto;
			wp->w_bufp->b_markp = wp->w_markp;
			wp->w_bufp->b_marko = wp->w_marko;
			wp->w_bufp->b_dotline = wp->w_dotline;
			wp->w_bufp->b_markline = wp->w_markline;
		}
		free(wp);
	}
	lp = curwp->w_linep;
	i = curwp->w_toprow;
	while (i != 0 && lback(lp) != curbp->b_headp) {
		--i;
		lp = lback(lp);
	}
	curwp->w_toprow = 0;

	/* 2 = mode, echo */
	curwp->w_ntrows = nrow - 2;
	curwp->w_linep = lp;
	curwp->w_rflag |= WFMODE | WFFULL;
	return (TRUE);
}

/*
 * Split the current window.  A window smaller than 3 lines cannot be split.
 * The only other error that is possible is a "malloc" failure allocating the
 * structure for the new window.
 * If called with a FFOTHARG, flags on the new window are set to 'n'.
 */
/* ARGSUSED */
int
splitwind(int f, int n)
{
	struct mgwin	*wp, *wp1, *wp2;
	struct line	*lp;
	int		 ntru, ntrd, ntrl;

	if (curwp->w_ntrows < 3) {
		dobeep();
		ewprintf("Cannot split a %d line window", curwp->w_ntrows);
		return (FALSE);
	}
	wp = new_window(curbp);
	if (wp == NULL) {
		dobeep();
		ewprintf("Unable to create a window");
		return (FALSE);
	}

	/* use the current dot and mark */
	wp->w_dotp = curwp->w_dotp;
	wp->w_doto = curwp->w_doto;
	wp->w_markp = curwp->w_markp;
	wp->w_marko = curwp->w_marko;
	wp->w_dotline = curwp->w_dotline;
	wp->w_markline = curwp->w_markline;

	/* figure out which half of the screen we're in */
	ntru = (curwp->w_ntrows - 1) / 2;	/* Upper size */
	ntrl = (curwp->w_ntrows - 1) - ntru;	/* Lower size */

	for (lp = curwp->w_linep, ntrd = 0; lp != curwp->w_dotp;
	    lp = lforw(lp))
		ntrd++;

	lp = curwp->w_linep;

	/* old is upper window */
	if (ntrd <= ntru) {
		/* hit mode line */
		if (ntrd == ntru)
			lp = lforw(lp);
		curwp->w_ntrows = ntru;
		wp->w_wndp = curwp->w_wndp;
		curwp->w_wndp = wp;
		wp->w_toprow = curwp->w_toprow + ntru + 1;
		wp->w_ntrows = ntrl;
	/* old is lower window */
	} else {
		wp1 = NULL;
		wp2 = wheadp;
		while (wp2 != curwp) {
			wp1 = wp2;
			wp2 = wp2->w_wndp;
		}
		if (wp1 == NULL)
			wheadp = wp;
		else
			wp1->w_wndp = wp;
		wp->w_wndp = curwp;
		wp->w_toprow = curwp->w_toprow;
		wp->w_ntrows = ntru;

		/* mode line */
		++ntru;
		curwp->w_toprow += ntru;
		curwp->w_ntrows = ntrl;
		while (ntru--)
			lp = lforw(lp);
	}

	/* adjust the top lines if necessary */
	curwp->w_linep = lp;
	wp->w_linep = lp;

	curwp->w_rflag |= WFMODE | WFFULL;
	wp->w_rflag |= WFMODE | WFFULL;
	/* if FFOTHARG, set flags) */
	if (f & FFOTHARG)
		wp->w_flag = n;

	return (TRUE);
}

/*
 * Enlarge the current window.  Find the window that loses space.  Make sure
 * it is big enough.  If so, hack the window descriptions, and ask redisplay
 * to do all the hard work.  You don't just set "force reframe" because dot
 * would move.
 */
/* ARGSUSED */
int
enlargewind(int f, int n)
{
	struct mgwin	*adjwp;
	struct line	*lp;
	int		 i;

	if (n < 0)
		return (shrinkwind(f, -n));
	if (wheadp->w_wndp == NULL) {
		dobeep();
		ewprintf("Only one window");
		return (FALSE);
	}
	if ((adjwp = curwp->w_wndp) == NULL) {
		adjwp = wheadp;
		while (adjwp->w_wndp != curwp)
			adjwp = adjwp->w_wndp;
	}
	if (adjwp->w_ntrows <= n) {
		dobeep();
		ewprintf("Impossible change");
		return (FALSE);
	}

	/* shrink below */
	if (curwp->w_wndp == adjwp) {
		lp = adjwp->w_linep;
		for (i = 0; i < n && lp != adjwp->w_bufp->b_headp; ++i)
			lp = lforw(lp);
		adjwp->w_linep = lp;
		adjwp->w_toprow += n;
	/* shrink above */
	} else {
		lp = curwp->w_linep;
		for (i = 0; i < n && lback(lp) != curbp->b_headp; ++i)
			lp = lback(lp);
		curwp->w_linep = lp;
		curwp->w_toprow -= n;
	}
	curwp->w_ntrows += n;
	adjwp->w_ntrows -= n;
	curwp->w_rflag |= WFMODE | WFFULL;
	adjwp->w_rflag |= WFMODE | WFFULL;
	return (TRUE);
}

/*
 * Shrink the current window.  Find the window that gains space.  Hack at the
 * window descriptions. Ask the redisplay to do all the hard work.
 */
int
shrinkwind(int f, int n)
{
	struct mgwin	*adjwp;
	struct line	*lp;
	int		 i;

	if (n < 0)
		return (enlargewind(f, -n));
	if (wheadp->w_wndp == NULL) {
		dobeep();
		ewprintf("Only one window");
		return (FALSE);
	}
	/*
	 * Bit of flakiness - FFRAND means it was an internal call, and
	 * to be trusted implicitly about sizes.
	 */
	if (!(f & FFRAND) && curwp->w_ntrows <= n) {
		dobeep();
		ewprintf("Impossible change");
		return (FALSE);
	}
	if ((adjwp = curwp->w_wndp) == NULL) {
		adjwp = wheadp;
		while (adjwp->w_wndp != curwp)
			adjwp = adjwp->w_wndp;
	}

	/* grow below */
	if (curwp->w_wndp == adjwp) {
		lp = adjwp->w_linep;
		for (i = 0; i < n && lback(lp) != adjwp->w_bufp->b_headp; ++i)
			lp = lback(lp);
		adjwp->w_linep = lp;
		adjwp->w_toprow -= n;
	/* grow above */
	} else {
		lp = curwp->w_linep;
		for (i = 0; i < n && lp != curbp->b_headp; ++i)
			lp = lforw(lp);
		curwp->w_linep = lp;
		curwp->w_toprow += n;
	}
	curwp->w_ntrows -= n;
	adjwp->w_ntrows += n;
	curwp->w_rflag |= WFMODE | WFFULL;
	adjwp->w_rflag |= WFMODE | WFFULL;
	return (TRUE);
}

/*
 * Delete current window. Call shrink-window to do the screen updating, then
 * throw away the window.
 */
/* ARGSUSED */
int
delwind(int f, int n)
{
	struct mgwin	*wp, *nwp;

	wp = curwp;		/* Cheap...		 */

	/* shrinkwind returning false means only one window... */
	if (shrinkwind(FFRAND, wp->w_ntrows + 1) == FALSE)
		return (FALSE);
	if (--wp->w_bufp->b_nwnd == 0) {
		wp->w_bufp->b_dotp = wp->w_dotp;
		wp->w_bufp->b_doto = wp->w_doto;
		wp->w_bufp->b_markp = wp->w_markp;
		wp->w_bufp->b_marko = wp->w_marko;
		wp->w_bufp->b_dotline = wp->w_dotline;
		wp->w_bufp->b_markline = wp->w_markline;
	}

	/* since shrinkwind did't crap out, we know we have a second window */
	if (wp == wheadp)
		wheadp = curwp = wp->w_wndp;
	else if ((curwp = wp->w_wndp) == NULL)
		curwp = wheadp;
	curbp = curwp->w_bufp;
	for (nwp = wheadp; nwp != NULL; nwp = nwp->w_wndp)
		if (nwp->w_wndp == wp) {
			nwp->w_wndp = wp->w_wndp;
			break;
		}
	free(wp);
	return (TRUE);
}
@


1.35
log
@I assume KRANDOM was the previous name for FFRAND. KRANDOM is not in
the mg source now.
@
text
@d1 1
a1 1
/*	$OpenBSD: window.c,v 1.34 2015/10/09 07:27:56 lum Exp $	*/
d290 1
a290 1
		
@


1.34
log
@Fix line number bug when calling onlywind().
@
text
@d1 1
a1 1
/*	$OpenBSD: window.c,v 1.33 2015/03/25 20:53:31 bcallah Exp $	*/
d367 1
a367 1
	 * Bit of flakiness - KRANDOM means it was an internal call, and
@


1.33
log
@unifdef -U NO_DPROMPT and GOSREC.
NO_DPROMPT has been around since the import of mg2a and it has never been
considered a "(Common) compile-time option" in the Makefile.
Assume everyone has been running mg this way since at least 2000 if not
already in the 90s.

Same with GOSREC. Has always been there but it looks like no one noticed
it (and no one was running with it). Indeed, the mg tutorial appears to be
oblivious to GOSREC being an option.

With this commit there are no more #ifndef blocks in mg. Only a couple of
#ifdef blocks remain.

ok lum@@
@
text
@d1 1
a1 1
/*	$OpenBSD: window.c,v 1.32 2015/03/19 21:22:15 bcallah Exp $	*/
d170 2
d183 2
@


1.32
log
@Clean up the includes in mg.
This does the following:
Moves all POSIX headers from sysdef.h into the individual .c files so that
each file now only includes what it needs. All headers are properly sorted.
Moves the remainder of sysdef.h to other files (mostly def.h) and deletes
sysdef.h now that it's no longer contains anything.
Tweak a comment that references sysdef.h so that it no longer does that.
ok florian@@
@
text
@d1 1
a1 1
/*	$OpenBSD: window.c,v 1.31 2014/05/28 07:59:36 florian Exp $	*/
d43 1
a43 3
 * redisplay code does).  If GOSREC is undefined, default is 0, so it acts
 * like GNU.  If GOSREC is defined, with no argument it defaults to 1 and
 * works like in Gosling.
a48 1
#ifndef GOSREC
a49 3
#else /* !GOSREC */
	curwp->w_frame = n;
#endif /* !GOSREC */
@


1.31
log
@On delete-window, remember the position of dot and mark in the buffer
so that an revisiting the buffer the correct line number is
displayed.
Found by jasper@@
OK lum@@
@
text
@d1 1
a1 1
/*	$OpenBSD: window.c,v 1.30 2014/03/20 07:47:29 lum Exp $	*/
d8 5
@


1.30
log
@Add some missing dobeeps.
ok florian@@
@
text
@d1 1
a1 1
/*	$OpenBSD: window.c,v 1.29 2013/05/31 18:03:45 lum Exp $	*/
d420 2
@


1.29
log
@Make the system bell toggleable via 'audible-bell', and if switched
off, make available an alternative 'visible-bell'.

ok florian@@ jasper@@ Feedback Sunil Nimmagadda.
@
text
@d1 1
a1 1
/*	$OpenBSD: window.c,v 1.28 2011/08/01 12:15:23 lum Exp $	*/
d95 1
d215 1
d221 1
d308 1
d318 1
d359 1
d368 1
@


1.28
log
@Change Gnu to GNU in man page (also, while here, in README and in a comment)
ok jmc@@
@
text
@d1 1
a1 1
/*	$OpenBSD: window.c,v 1.27 2009/06/04 23:39:37 kjell Exp $	*/
d100 1
a100 1
		update();
@


1.27
log
@Add the notion of an "ephemeral" popup, so we can flag a window
for destruction at a later date. (in the process, add a window flag field)

This fixes an issue noted by maja: namely, the *completion*
window that pops up when you try to complete a filename on
buffer load would destroy any second window that you happened
to have open.

ok maja@@
@
text
@d1 1
a1 1
/*	$OpenBSD: window.c,v 1.26 2009/06/04 02:23:37 kjell Exp $	*/
d124 1
a124 1
/* not in Gnu Emacs */
@


1.26
log
@Rename w_flag to w_rflag. This is not a general purpose
flag: it is for redisplay options only. I need an additional all-purpose
flag, so renaming removes the desire to wrongly overload the existing one.

Turdshine. No functional chage.
@
text
@d1 1
a1 1
/*	$OpenBSD: window.c,v 1.25 2006/07/25 08:22:32 kjell Exp $	*/
d203 1
d281 4
a427 22
}

/*
 * Pick a window for a pop-up.  Split the screen if there is only one window.
 * Pick the uppermost window that isn't the current window. An LRU algorithm
 * might be better. Return a pointer, or NULL on error.
 */
struct mgwin *
wpopup(void)
{
	struct mgwin	*wp;

	if (wheadp->w_wndp == NULL &&
	    splitwind(FFRAND, 0) == FALSE)
		return (NULL);

	/* find a window to use */
	wp = wheadp;

	while (wp != NULL && wp == curwp)
		wp = wp->w_wndp;
	return (wp);
@


1.25
log
@Rename the header line of a buffer to b_headp, from the remarkably
unintuitive b_linep. No binary change.
@
text
@d1 1
a1 1
/*	$OpenBSD: window.c,v 1.24 2006/06/01 09:00:50 kjell Exp $	*/
d25 1
a25 1
	wp->w_flag = 0;
d51 1
a51 1
	curwp->w_flag |= WFFRAME;
d195 1
a195 1
	curwp->w_flag |= WFMODE | WFFULL;
d278 2
a279 2
	curwp->w_flag |= WFMODE | WFFULL;
	wp->w_flag |= WFMODE | WFFULL;
d330 2
a331 2
	curwp->w_flag |= WFMODE | WFFULL;
	adjwp->w_flag |= WFMODE | WFFULL;
d383 2
a384 2
	curwp->w_flag |= WFMODE | WFFULL;
	adjwp->w_flag |= WFMODE | WFFULL;
@


1.24
log
@Display line number in the mg statusbar.  Yes, it seems like a fugly
way to do it, but all the clever and pretty ways utterly failed.
Basic use seems fine. We'll turdshine the special cases later.

If it bothers you, use M-x line-number-mode, or put same in your ~/.mg
file to disable.

ok cloder, jason
@
text
@d1 1
a1 1
/*	$OpenBSD: window.c,v 1.23 2006/05/29 00:02:23 kjell Exp $	*/
d186 1
a186 1
	while (i != 0 && lback(lp) != curbp->b_linep) {
d316 1
a316 1
		for (i = 0; i < n && lp != adjwp->w_bufp->b_linep; ++i)
d323 1
a323 1
		for (i = 0; i < n && lback(lp) != curbp->b_linep; ++i)
d369 1
a369 1
		for (i = 0; i < n && lback(lp) != adjwp->w_bufp->b_linep; ++i)
d376 1
a376 1
		for (i = 0; i < n && lp != curbp->b_linep; ++i)
@


1.23
log
@Another mnemonic rename, missed the first time.
Also missed the ok cloder.
@
text
@d1 1
a1 1
/*	$OpenBSD: window.c,v 1.22 2006/05/28 23:30:16 kjell Exp $	*/
d28 1
d227 2
@


1.22
log
@Make Window Flags more mnemonic (and less dumb); i.e.
WFHARD -> WFFULL (Redraw full window)
WFFORCE -> WFFRAME (Reframe window).
No binary change
@
text
@d1 1
a1 1
/*	$OpenBSD: window.c,v 1.21 2006/02/25 14:40:16 otto Exp $	*/
d26 1
a26 1
	wp->w_force = 0;
d46 1
a46 1
	curwp->w_force = (f & FFARG) ? (n >= 0 ? n + 1 : n) : 0;
d48 1
a48 1
	curwp->w_force = n;
@


1.21
log
@Fix a coredump occurring when the terminal is resized while mg is
suspended. Problem reported and fixed tested by reyk@@; tweak by
kjell@@; ok kjell@@
@
text
@d1 1
a1 1
/*	$OpenBSD: window.c,v 1.20 2005/12/13 06:01:27 kjell Exp $	*/
d50 1
a50 1
	curwp->w_flag |= WFFORCE;
d194 1
a194 1
	curwp->w_flag |= WFMODE | WFHARD;
d275 2
a276 2
	curwp->w_flag |= WFMODE | WFHARD;
	wp->w_flag |= WFMODE | WFHARD;
d327 2
a328 2
	curwp->w_flag |= WFMODE | WFHARD;
	adjwp->w_flag |= WFMODE | WFHARD;
d380 2
a381 2
	curwp->w_flag |= WFMODE | WFHARD;
	adjwp->w_flag |= WFMODE | WFHARD;
@


1.20
log
@More name-clash delinting
@
text
@d1 1
a1 1
/*	$OpenBSD: window.c,v 1.19 2005/11/18 20:56:53 deraadt Exp $	*/
d62 6
a67 3
 * all of the windows need not be recomputed.  Note that when you get to the
 * "display unusable" message, the screen will be messed up. If you make the
 * window bigger again, and send another command, everything will get fixed!
d69 6
d77 1
a77 1
redraw(int f, int n)
d85 1
a85 1
	if (nrow != oldnrow || ncol != oldncol) {
@


1.19
log
@greedy use of typedef struct was making code harder to read; ok kjell cloder
@
text
@d1 1
a1 1
/*	$OpenBSD: window.c,v 1.18 2005/10/11 01:08:53 kjell Exp $	*/
d68 1
a68 1
refresh(int f, int n)
@


1.18
log
@A while back, undo records were moved from the BUFFER struct to MGWIN.
This is nonsensical, and utterly broken if you are undo-ing across
multiple buffers. Change them back to being associated with the BUFFER
struct. (effectively, just revert the original change)

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: window.c,v 1.17 2005/06/14 18:14:40 kjell Exp $	*/
d11 2
a12 2
MGWIN *
new_window(BUFFER *bp)
d14 1
a14 1
	MGWIN *wp;
d16 1
a16 1
	wp = calloc(1, sizeof(MGWIN));
d70 2
a71 3
	MGWIN	*wp;
	int	 oldnrow;
	int	 oldncol;
d105 1
a105 1
	MGWIN	*wp;
d124 1
a124 1
	MGWIN	*wp1, *wp2;
d148 3
a150 3
	MGWIN	*wp;
	LINE	*lp;
	int	 i;
d198 3
a200 3
	MGWIN	*wp, *wp1, *wp2;
	LINE	*lp;
	int	 ntru, ntrd, ntrl;
d281 3
a283 3
	MGWIN	*adjwp;
	LINE	*lp;
	int	 i;
d330 3
a332 3
	MGWIN	*adjwp;
	LINE	*lp;
	int	 i;
d384 1
a384 1
	MGWIN	*wp, *nwp;
d418 1
a418 1
MGWIN *
d421 1
a421 1
	MGWIN	*wp;
@


1.17
log
@Add explicit public domain notices to all public domain files.
ok millert@@, deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: window.c,v 1.16 2005/04/03 02:09:28 db Exp $	*/
a29 4
	LIST_INIT(&wp->w_undo);
	wp->w_undoptr = NULL;
	wp->w_undopos = 0;

a32 14
void
free_window(MGWIN *wp)
{
	struct undo_rec *rec, *next;

	rec = LIST_FIRST(&wp->w_undo);
	while (rec != NULL) {
		next = LIST_NEXT(rec, next);
		free_undo_record(rec);
		rec = next;
	}
	free(wp);
}

d162 1
a162 1
		free_window(wp);
d173 1
a173 1
		free_window(wp);
d410 1
a410 1
	free_window(wp);
@


1.16
log
@This is a no binary change which does:

- spelling, punctuation fixes
- variable declaration lineup
- use parentheses for return and sizeof
- K&R function declarations -> ANSI
- other minor code beautification

ok henning@@
@
text
@d1 3
a3 1
/*	$OpenBSD: window.c,v 1.15 2004/01/27 23:43:37 vincent Exp $	*/
@


1.15
log
@make mail-mode more intelligent on middle-of-line insertions, and add a
comment to change the wrapping column. (mail-set-margin)

tested by henning and phessler, thanks!
@
text
@d1 1
a1 1
/*	$OpenBSD: window.c,v 1.14 2003/11/29 17:28:39 vincent Exp $	*/
d68 1
a68 1
	return TRUE;
d110 1
a110 1
	return TRUE;
d128 1
a128 1
	return TRUE;
d151 1
a151 1
	return TRUE;
d158 1
a158 1
 * structures right if the distruction of a window makes a buffer become
d203 1
a203 1
	return TRUE;
d285 1
a285 1
	return TRUE;
d303 1
a303 1
		return shrinkwind(f, -n);
d306 1
a306 1
		return FALSE;
d315 1
a315 1
		return FALSE;
d337 1
a337 1
	return TRUE;
d352 1
a352 1
		return enlargewind(f, -n);
d355 1
a355 1
		return FALSE;
d407 1
a407 1
		return FALSE;
d427 1
a427 1
	return TRUE;
d442 1
a442 1
		return NULL;
d449 1
a449 1
	return wp;
@


1.14
log
@save the previous undo position as an offset in the buffer instead of
a line/offset pair
@
text
@d1 1
a1 1
/*	$OpenBSD: window.c,v 1.13 2003/10/27 11:21:12 vincent Exp $	*/
d25 1
@


1.13
log
@fix crash on startup by using the good allocation routine in edinit()

spotted and ok by henning
@
text
@d1 1
a1 1
/*	$OpenBSD: window.c,v 1.12 2003/10/21 22:48:07 vincent Exp $	*/
d29 1
a29 1
	memset(&wp->w_undopos, 0, sizeof wp->w_undopos);
@


1.12
log
@make undo records per MGWIN, not per BUFFER...
@
text
@d1 1
a1 1
/*	$OpenBSD: window.c,v 1.11 2003/05/20 03:08:55 cloder Exp $	*/
d14 1
a14 1
	wp = malloc(sizeof(MGWIN));
d25 2
a26 1
	bp->b_nwnd++;
@


1.11
log
@Finish KNF of prototypes.  That should be all of them.
OK vincent@@
@
text
@d1 1
a1 1
/*	$OpenBSD: window.c,v 1.10 2002/02/20 23:57:52 deraadt Exp $	*/
d9 38
d176 1
a176 1
		free((char *)wp);
d187 1
a187 1
		free((char *)wp);
d221 3
a223 2
	if ((wp = malloc(sizeof(MGWIN))) == NULL) {
		ewprintf("Can't get %d", sizeof(MGWIN));
d227 1
a227 3
	/* displayed twice */
	++curbp->b_nwnd;
	wp->w_bufp = curbp;
d232 9
a240 10
	wp->w_flag = 0;
	wp->w_force = 0;
	ntru = (curwp->w_ntrows - 1) / 2;	/* Upper size		 */
	ntrl = (curwp->w_ntrows - 1) - ntru;	/* Lower size		 */
	lp = curwp->w_linep;
	ntrd = 0;
	while (lp != curwp->w_dotp) {
		++ntrd;
		lp = lforw(lp);
	}
d424 1
a424 1
	free((char *)wp);
@


1.10
log
@do not print "New size..." -- other emacs do not bother
@
text
@d1 1
a1 1
/*	$OpenBSD: window.c,v 1.9 2002/02/14 14:24:21 deraadt Exp $	*/
d19 1
a19 2
reposition(f, n)
	int f, n;
d44 1
a44 2
refresh(f, n)
	int f, n;
d80 1
a80 2
nextwind(f, n)
	int f, n;
d99 1
a99 2
prevwind(f, n)
	int f, n;
d123 1
a123 2
onlywind(f, n)
	int f, n;
d173 1
a173 2
splitwind(f, n)
	int f, n;
d258 1
a258 2
enlargewind(f, n)
	int f, n;
d307 1
a307 2
shrinkwind(f, n)
	int f, n;
d361 1
a361 2
delwind(f, n)
	int f, n;
d398 1
a398 1
wpopup()
@


1.9
log
@some KNF
@
text
@d1 1
a1 1
/*	$OpenBSD: window.c,v 1.8 2002/02/08 21:21:11 deraadt Exp $	*/
a69 1
		ewprintf("New size %d by %d", nrow, ncol);
@


1.8
log
@more gosmacs
@
text
@d1 1
a1 1
/*	$OpenBSD: window.c,v 1.7 2001/05/24 03:05:27 mickey Exp $	*/
d412 2
a413 2
	if (wheadp->w_wndp == NULL
	    && splitwind(FFRAND, 0) == FALSE)
@


1.7
log
@spaces
@
text
@d1 1
a1 1
/*	$OpenBSD: window.c,v 1.6 2001/05/23 22:36:15 art Exp $	*/
a94 2
#ifdef	GOSMACS

a117 1
#endif /* GOSEMACS */
@


1.6
log
@Get rid of unnecessary casts of NULL.
@
text
@d1 1
a1 1
/*	$OpenBSD: window.c,v 1.5 2001/01/29 01:58:10 niklas Exp $	*/
d10 5
a14 5
 * Reposition dot in the current window to line "n".  If the argument is 
 * positive, it is that line.  If it is negative it is that line from the 
 * bottom.  If it is 0 the window is centered (this is what the standard 
 * redisplay code does).  If GOSREC is undefined, default is 0, so it acts 
 * like GNU.  If GOSREC is defined, with no argument it defaults to 1 and 
d33 2
a34 2
 * Refresh the display.  A call is made to the "ttresize" entry in the 
 * terminal handler, which tries to reset "nrow" and "ncol".  They will, 
d36 5
a40 5
 * changed size, arrange that everything is redone, then call "update" to 
 * fix the display.  We do this so the new size can be displayed.  In the 
 * normal case the call to "update" in "main.c" refreshes the screen, and 
 * all of the windows need not be recomputed.  Note that when you get to the 
 * "display unusable" message, the screen will be messed up. If you make the 
d77 2
a78 2
 * The command to make the next window (next => down the screen) the current 
 * window. There are no real errors, although the command does nothing if 
d100 1
a100 1
 * current window. There are no errors, although the command does not do 
d123 4
a126 4
 * This command makes the current window the only window on the screen.  Try 
 * to set the framing so that "." does not have to move on the display.  Some 
 * care has to be taken to keep the values of dot and mark in the buffer 
 * structures right if the distruction of a window makes a buffer become 
d177 1
a177 1
 * The only other error that is possible is a "malloc" failure allocating the 
d261 3
a263 3
 * Enlarge the current window.  Find the window that loses space.  Make sure 
 * it is big enough.  If so, hack the window descriptions, and ask redisplay 
 * to do all the hard work.  You don't just set "force reframe" because dot 
d314 1
a314 1
 * Shrink the current window.  Find the window that gains space.  Hack at the 
d368 1
a368 1
 * Delete current window. Call shrink-window to do the screen updating, then 
d406 1
a406 1
 * Pick a window for a pop-up.  Split the screen if there is only one window. 
@


1.5
log
@$OpenBSD$
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d193 1
a193 1
	if ((wp = (MGWIN *)malloc(sizeof(MGWIN))) == NULL) {
@


1.4
log
@More -Wall anmd KNF, from op2@@tomahawk.SQUiSH.org
@
text
@d1 2
@


1.3
log
@The start of KNF + -Wall.  The code has been run through indent but
needs hand fixup.  I stopped at keymap.c...
@
text
@d4 2
a5 1
#include	"def.h"
d8 6
a13 8
 * Reposition dot in the current
 * window to line "n". If the argument is
 * positive, it is that line. If it is negative it
 * is that line from the bottom. If it is 0 the window
 * is centered (this is what the standard redisplay code
 * does).  If GOSREC is undefined, default is 0, so it acts like GNU.
 * If GOSREC is defined, with no argument it defaults to 1
 * and works like in Gosling.
d16 1
d18 1
d22 1
a22 1
#else
d24 1
a24 1
#endif
d31 9
a39 13
 * Refresh the display. A call is made to the
 * "ttresize" entry in the terminal handler, which tries
 * to reset "nrow" and "ncol". They will, however, never
 * be set outside of the NROW or NCOL range. If the display
 * changed size, arrange that everything is redone, then
 * call "update" to fix the display. We do this so the
 * new size can be displayed. In the normal case the
 * call to "update" in "main.c" refreshes the screen,
 * and all of the windows need not be recomputed.
 * Note that when you get to the "display unusable"
 * message, the screen will be messed up. If you make
 * the window bigger again, and send another command,
 * everything will get fixed!
d42 1
d44 1
d46 3
a48 3
	register MGWIN *wp;
	register int    oldnrow;
	register int    oldncol;
d54 3
a56 1
		wp = wheadp;	/* Find last.		 */
d59 3
a61 1
		if (nrow < wp->w_toprow + 3) {	/* Check if too small.	 */
d75 3
a77 6
 * The command to make the next
 * window (next => down the screen)
 * the current window. There are no real
 * errors, although the command does
 * nothing if there is only 1 window on
 * the screen.
d80 1
d82 1
d84 1
a84 1
	register MGWIN *wp;
d94 1
d97 3
a99 5
 * This command makes the previous
 * window (previous => up the screen) the
 * current window. There arn't any errors,
 * although the command does not do a lot
 * if there is 1 window.
d102 1
d104 1
d106 1
a106 2
	register MGWIN *wp1;
	register MGWIN *wp2;
d118 1
a118 1
#endif
d121 5
a125 9
 * This command makes the current
 * window the only window on the screen.
 * Try to set the framing
 * so that "." does not have to move on
 * the display. Some care has to be taken
 * to keep the values of dot and mark
 * in the buffer structures right if the
 * distruction of a window makes a buffer
 * become undisplayed.
d128 1
d130 1
d132 3
a134 3
	register MGWIN *wp;
	register LINE  *lp;
	register int    i;
d145 1
a145 1
		free((char *) wp);
d156 1
a156 1
		free((char *) wp);
d165 3
a167 1
	curwp->w_ntrows = nrow - 2;	/* 2 = mode, echo.	 */
d174 3
a176 5
 * Split the current window. A window
 * smaller than 3 lines cannot be split.
 * The only other error that is possible is
 * a "malloc" failure allocating the structure
 * for the new window.
d179 1
d181 1
d183 3
a185 6
	register MGWIN *wp;
	register LINE  *lp;
	register int    ntru;
	register int    ntrd;
	int             ntrl;
	MGWIN          *wp1, *wp2;
d191 1
a191 1
	if ((wp = (MGWIN *) malloc(sizeof(MGWIN))) == NULL) {
d195 3
a197 1
	++curbp->b_nwnd;	/* Displayed twice.	 */
d214 5
a218 2
	if (ntrd <= ntru) {	/* Old is upper window. */
		if (ntrd == ntru)	/* Hit mode line.	 */
d225 2
a226 1
	} else {		/* Old is lower window	 */
d240 3
a242 1
		++ntru;		/* Mode line.		 */
d248 5
a252 2
	curwp->w_linep = lp;	/* Adjust the top lines */
	wp->w_linep = lp;	/* if necessary.	 */
d259 4
a262 6
 * Enlarge the current window.
 * Find the window that loses space. Make
 * sure it is big enough. If so, hack the window
 * descriptions, and ask redisplay to do all the
 * hard work. You don't just set "force reframe"
 * because dot would move.
d265 1
d267 1
d269 3
a271 3
	register MGWIN *adjwp;
	register LINE  *lp;
	register int    i;
d288 3
a290 1
	if (curwp->w_wndp == adjwp) {	/* Shrink below.	 */
d296 2
a297 1
	} else {		/* Shrink above.	 */
d312 2
a313 4
 * Shrink the current window.
 * Find the window that gains space. Hack at
 * the window descriptions. Ask the redisplay to
 * do all the hard work.
d315 1
d317 1
d319 3
a321 3
	register MGWIN *adjwp;
	register LINE  *lp;
	register int    i;
d342 3
a344 1
	if (curwp->w_wndp == adjwp) {	/* Grow below.		 */
d350 2
a351 1
	} else {		/* Grow above.		 */
d366 2
a367 2
 * Delete current window. Call shrink-window to do the screen
 * updating, then throw away the window.
d370 1
d372 1
d374 1
a374 1
	register MGWIN *wp, *nwp;
d377 1
d387 1
d399 1
a399 1
	free((char *) wp);
d402 1
d404 3
a406 6
 * Pick a window for a pop-up.
 * Split the screen if there is only
 * one window. Pick the uppermost window that
 * isn't the current window. An LRU algorithm
 * might be better. Return a pointer, or
 * NULL on error.
d411 1
a411 1
	register MGWIN *wp;
d416 4
a419 1
	wp = wheadp;		/* Find window to use	 */
@


1.2
log
@change WINDOW -> MGWIN to avoid curses type conflict
convert to terminfo in tty*.c
add support for some keypad function keys (arrows, pgup, pgdown)
@
text
@d16 1
a16 1
/*ARGSUSED*/
d20 1
a20 1
	curwp->w_force = (f & FFARG) ? (n>=0 ? n+1 : n) : 0;
d44 1
a44 1
/*ARGSUSED*/
d48 2
a49 2
	register int	oldnrow;
	register int	oldncol;
d54 2
a55 2
	if (nrow!=oldnrow || ncol!=oldncol) {
		wp = wheadp;			/* Find last.		*/
d58 1
a58 1
		if (nrow < wp->w_toprow+3) {	/* Check if too small.	*/
d62 1
a62 1
		wp->w_ntrows = nrow-wp->w_toprow-2;
d79 1
a79 1
/*ARGSUSED*/
d84 1
a84 1
	if ((wp=curwp->w_wndp) == NULL)
d100 1
a100 1
/*ARGSUSED*/
d129 1
a129 1
/*ARGSUSED*/
d133 2
a134 2
	register LINE	*lp;
	register int	i;
d140 2
a141 2
			wp->w_bufp->b_dotp  = wp->w_dotp;
			wp->w_bufp->b_doto  = wp->w_doto;
d151 2
a152 2
			wp->w_bufp->b_dotp  = wp->w_dotp;
			wp->w_bufp->b_doto  = wp->w_doto;
d159 2
a160 2
	i  = curwp->w_toprow;
	while (i!=0 && lback(lp)!=curbp->b_linep) {
d165 3
a167 3
	curwp->w_ntrows = nrow-2;		/* 2 = mode, echo.	*/
	curwp->w_linep	= lp;
	curwp->w_flag  |= WFMODE|WFHARD;
d178 1
a178 1
/*ARGSUSED*/
d182 5
a186 5
	register LINE	*lp;
	register int	ntru;
	register int	ntrd;
	int		ntrl;
	MGWIN		*wp1, *wp2;
d192 1
a192 1
	if ((wp = (MGWIN *)malloc(sizeof(MGWIN))) == NULL) {
d196 4
a199 4
	++curbp->b_nwnd;			/* Displayed twice.	*/
	wp->w_bufp  = curbp;
	wp->w_dotp  = curwp->w_dotp;
	wp->w_doto  = curwp->w_doto;
d202 1
a202 1
	wp->w_flag  = 0;
d204 2
a205 2
	ntru = (curwp->w_ntrows-1) / 2;		/* Upper size		*/
	ntrl = (curwp->w_ntrows-1) - ntru;	/* Lower size		*/
d213 2
a214 2
	if (ntrd <= ntru) {			/* Old is upper window. */
		if (ntrd == ntru)		/* Hit mode line.	*/
d219 1
a219 1
		wp->w_toprow = curwp->w_toprow+ntru+1;
d221 1
a221 1
	} else {				/* Old is lower window	*/
d232 1
a232 1
		wp->w_wndp   = curwp;
d235 1
a235 1
		++ntru;				/* Mode line.		*/
d237 1
a237 1
		curwp->w_ntrows	 = ntrl;
d241 4
a244 4
	curwp->w_linep = lp;			/* Adjust the top lines */
	wp->w_linep = lp;			/* if necessary.	*/
	curwp->w_flag |= WFMODE|WFHARD;
	wp->w_flag |= WFMODE|WFHARD;
d256 1
a256 1
/*ARGSUSED*/
d260 2
a261 2
	register LINE	*lp;
	register int	i;
d269 1
a269 1
	if ((adjwp=curwp->w_wndp) == NULL) {
d278 1
a278 1
	if (curwp->w_wndp == adjwp) {		/* Shrink below.	*/
d280 1
a280 1
		for (i=0; i<n && lp!=adjwp->w_bufp->b_linep; ++i)
d282 1
a282 1
		adjwp->w_linep	= lp;
d284 1
a284 1
	} else {				/* Shrink above.	*/
d286 1
a286 1
		for (i=0; i<n && lback(lp)!=curbp->b_linep; ++i)
d288 1
a288 1
		curwp->w_linep	= lp;
d293 2
a294 2
	curwp->w_flag |= WFMODE|WFHARD;
	adjwp->w_flag |= WFMODE|WFHARD;
d307 2
a308 2
	register LINE	*lp;
	register int	i;
d320 1
a320 1
	if ( !(f & FFRAND) && curwp->w_ntrows <= n) {
d324 1
a324 1
	if ((adjwp=curwp->w_wndp) == NULL) {
d329 1
a329 1
	if (curwp->w_wndp == adjwp) {		/* Grow below.		*/
d331 1
a331 1
		for (i=0; i<n && lback(lp)!=adjwp->w_bufp->b_linep; ++i)
d333 1
a333 1
		adjwp->w_linep	= lp;
d335 1
a335 1
	} else {				/* Grow above.		*/
d337 1
a337 1
		for (i=0; i<n && lp!=curbp->b_linep; ++i)
d339 1
a339 1
		curwp->w_linep	= lp;
d344 2
a345 2
	curwp->w_flag |= WFMODE|WFHARD;
	adjwp->w_flag |= WFMODE|WFHARD;
d353 1
a353 1
/*ARGSUSED*/
d358 1
a358 1
	wp = curwp;			/* Cheap...		*/
d363 2
a364 2
		wp->w_bufp->b_dotp  = wp->w_dotp;
		wp->w_bufp->b_doto  = wp->w_doto;
d369 4
a372 2
	if (wp == wheadp) wheadp = curwp = wp->w_wndp;
	else if ((curwp = wp->w_wndp) == NULL) curwp = wheadp;
d377 1
a377 1
			break ;
d390 3
a392 2
MGWIN	*
wpopup() {
d396 1
a396 1
	&& splitwind(FFRAND, 0) == FALSE)
d398 2
a399 2
	wp = wheadp;				/* Find window to use	*/
	while (wp!=NULL && wp==curwp)
@


1.1
log
@initial import of mg2a
@
text
@d47 1
a47 1
	register WINDOW *wp;
d82 1
a82 1
	register WINDOW *wp;
d103 2
a104 2
	register WINDOW *wp1;
	register WINDOW *wp2;
d132 1
a132 1
	register WINDOW *wp;
d181 1
a181 1
	register WINDOW *wp;
d186 1
a186 1
	WINDOW		*wp1, *wp2;
d192 2
a193 2
	if ((wp = (WINDOW *)malloc(sizeof(WINDOW))) == NULL) {
		ewprintf("Can't get %d", sizeof(WINDOW));
d259 1
a259 1
	register WINDOW *adjwp;
d306 1
a306 1
	register WINDOW *adjwp;
d356 1
a356 1
	register WINDOW *wp, *nwp;
d388 1
a388 1
WINDOW	*
d390 1
a390 1
	register WINDOW *wp;
@

