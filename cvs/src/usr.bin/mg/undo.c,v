head	1.58;
access;
symbols
	OPENBSD_6_1:1.58.0.4
	OPENBSD_6_1_BASE:1.58
	OPENBSD_6_0:1.57.0.4
	OPENBSD_6_0_BASE:1.57
	OPENBSD_5_9:1.57.0.2
	OPENBSD_5_9_BASE:1.57
	OPENBSD_5_8:1.56.0.4
	OPENBSD_5_8_BASE:1.56
	OPENBSD_5_7:1.55.0.2
	OPENBSD_5_7_BASE:1.55
	OPENBSD_5_6:1.55.0.4
	OPENBSD_5_6_BASE:1.55
	OPENBSD_5_5:1.54.0.6
	OPENBSD_5_5_BASE:1.54
	OPENBSD_5_4:1.54.0.2
	OPENBSD_5_4_BASE:1.54
	OPENBSD_5_3:1.51.0.2
	OPENBSD_5_3_BASE:1.51
	OPENBSD_5_2:1.50.0.10
	OPENBSD_5_2_BASE:1.50
	OPENBSD_5_1_BASE:1.50
	OPENBSD_5_1:1.50.0.8
	OPENBSD_5_0:1.50.0.6
	OPENBSD_5_0_BASE:1.50
	OPENBSD_4_9:1.50.0.4
	OPENBSD_4_9_BASE:1.50
	OPENBSD_4_8:1.50.0.2
	OPENBSD_4_8_BASE:1.50
	OPENBSD_4_7:1.49.0.2
	OPENBSD_4_7_BASE:1.49
	OPENBSD_4_6:1.49.0.4
	OPENBSD_4_6_BASE:1.49
	OPENBSD_4_5:1.47.0.2
	OPENBSD_4_5_BASE:1.47
	OPENBSD_4_4:1.46.0.2
	OPENBSD_4_4_BASE:1.46
	OPENBSD_4_3:1.44.0.2
	OPENBSD_4_3_BASE:1.44
	OPENBSD_4_2:1.43.0.4
	OPENBSD_4_2_BASE:1.43
	OPENBSD_4_1:1.43.0.2
	OPENBSD_4_1_BASE:1.43
	OPENBSD_4_0:1.41.0.2
	OPENBSD_4_0_BASE:1.41
	OPENBSD_3_9:1.38.0.2
	OPENBSD_3_9_BASE:1.38
	OPENBSD_3_8:1.27.0.2
	OPENBSD_3_8_BASE:1.27
	OPENBSD_3_7:1.24.0.6
	OPENBSD_3_7_BASE:1.24
	OPENBSD_3_6:1.24.0.4
	OPENBSD_3_6_BASE:1.24
	OPENBSD_3_5:1.24.0.2
	OPENBSD_3_5_BASE:1.24
	OPENBSD_3_4:1.18.0.2
	OPENBSD_3_4_BASE:1.18
	OPENBSD_3_3:1.14.0.4
	OPENBSD_3_3_BASE:1.14
	OPENBSD_3_2:1.14.0.2
	OPENBSD_3_2_BASE:1.14
	OPENBSD_3_1:1.9.0.2
	OPENBSD_3_1_BASE:1.9;
locks; strict;
comment	@ * @;


1.58
date	2016.09.05.08.10.58;	author lum;	state Exp;
branches;
next	1.57;
commitid	wV0NqVGwPi8kNGH9;

1.57
date	2015.12.11.20.21.23;	author mmcc;	state Exp;
branches;
next	1.56;
commitid	fMxksA90Y2NKlI5v;

1.56
date	2015.03.19.21.22.15;	author bcallah;	state Exp;
branches;
next	1.55;
commitid	GbEBL4CfPvDkB8hj;

1.55
date	2014.03.20.07.47.29;	author lum;	state Exp;
branches;
next	1.54;

1.54
date	2013.06.01.16.27.56;	author lum;	state Exp;
branches;
next	1.53;

1.53
date	2013.03.25.11.39.38;	author florian;	state Exp;
branches;
next	1.52;

1.52
date	2013.03.25.11.38.22;	author florian;	state Exp;
branches;
next	1.51;

1.51
date	2012.11.06.18.04.10;	author florian;	state Exp;
branches;
next	1.50;

1.50
date	2010.06.30.19.12.54;	author oga;	state Exp;
branches;
next	1.49;

1.49
date	2009.06.05.18.02.06;	author kjell;	state Exp;
branches;
next	1.48;

1.48
date	2009.06.04.23.39.37;	author kjell;	state Exp;
branches;
next	1.47;

1.47
date	2008.09.15.16.13.35;	author kjell;	state Exp;
branches;
next	1.46;

1.46
date	2008.06.14.07.38.53;	author kjell;	state Exp;
branches;
next	1.45;

1.45
date	2008.06.11.17.07.37;	author kjell;	state Exp;
branches;
next	1.44;

1.44
date	2007.09.16.20.34.18;	author kjell;	state Exp;
branches;
next	1.43;

1.43
date	2006.11.19.16.51.19;	author deraadt;	state Exp;
branches;
next	1.42;

1.42
date	2006.11.17.08.45.31;	author kjell;	state Exp;
branches;
next	1.41;

1.41
date	2006.07.25.08.22.32;	author kjell;	state Exp;
branches;
next	1.40;

1.40
date	2006.07.08.17.56.10;	author kjell;	state Exp;
branches;
next	1.39;

1.39
date	2006.07.08.17.50.30;	author kjell;	state Exp;
branches;
next	1.38;

1.38
date	2005.12.20.05.04.28;	author kjell;	state Exp;
branches;
next	1.37;

1.37
date	2005.12.13.07.20.13;	author kjell;	state Exp;
branches;
next	1.36;

1.36
date	2005.12.13.05.40.33;	author kjell;	state Exp;
branches;
next	1.35;

1.35
date	2005.11.18.20.56.53;	author deraadt;	state Exp;
branches;
next	1.34;

1.34
date	2005.11.18.17.11.21;	author kjell;	state Exp;
branches;
next	1.33;

1.33
date	2005.11.12.18.48.08;	author kjell;	state Exp;
branches;
next	1.32;

1.32
date	2005.10.14.19.46.46;	author kjell;	state Exp;
branches;
next	1.31;

1.31
date	2005.10.13.20.28.49;	author deraadt;	state Exp;
branches;
next	1.30;

1.30
date	2005.10.13.20.07.26;	author kjell;	state Exp;
branches;
next	1.29;

1.29
date	2005.10.11.01.08.53;	author kjell;	state Exp;
branches;
next	1.28;

1.28
date	2005.10.06.16.48.00;	author kjell;	state Exp;
branches;
next	1.27;

1.27
date	2005.05.29.21.37.49;	author cloder;	state Exp;
branches;
next	1.26;

1.26
date	2005.04.29.07.22.38;	author otto;	state Exp;
branches;
next	1.25;

1.25
date	2005.04.03.02.09.28;	author db;	state Exp;
branches;
next	1.24;

1.24
date	2003.12.15.00.00.12;	author vincent;	state Exp;
branches;
next	1.23;

1.23
date	2003.11.29.17.28.40;	author vincent;	state Exp;
branches;
next	1.22;

1.22
date	2003.11.09.01.44.39;	author vincent;	state Exp;
branches;
next	1.21;

1.21
date	2003.11.09.01.20.32;	author vincent;	state Exp;
branches;
next	1.20;

1.20
date	2003.11.09.01.11.14;	author vincent;	state Exp;
branches;
next	1.19;

1.19
date	2003.10.21.22.48.07;	author vincent;	state Exp;
branches;
next	1.18;

1.18
date	2003.06.26.23.04.10;	author vincent;	state Exp;
branches;
next	1.17;

1.17
date	2003.06.01.15.53.34;	author deraadt;	state Exp;
branches;
next	1.16;

1.16
date	2003.05.20.03.08.55;	author cloder;	state Exp;
branches;
next	1.15;

1.15
date	2003.04.13.19.16.49;	author avsm;	state Exp;
branches;
next	1.14;

1.14
date	2002.09.15.22.18.39;	author vincent;	state Exp;
branches;
next	1.13;

1.13
date	2002.08.22.23.28.19;	author deraadt;	state Exp;
branches;
next	1.12;

1.12
date	2002.07.24.14.08.33;	author vincent;	state Exp;
branches;
next	1.11;

1.11
date	2002.06.20.04.27.11;	author vincent;	state Exp;
branches;
next	1.10;

1.10
date	2002.06.20.03.59.15;	author vincent;	state Exp;
branches;
next	1.9;

1.9
date	2002.03.18.01.45.55;	author vincent;	state Exp;
branches;
next	1.8;

1.8
date	2002.03.16.20.29.21;	author vincent;	state Exp;
branches;
next	1.7;

1.7
date	2002.02.26.00.45.45;	author vincent;	state Exp;
branches;
next	1.6;

1.6
date	2002.02.21.17.36.12;	author vincent;	state Exp;
branches;
next	1.5;

1.5
date	2002.02.21.04.21.05;	author vincent;	state Exp;
branches;
next	1.4;

1.4
date	2002.02.21.04.16.27;	author vincent;	state Exp;
branches;
next	1.3;

1.3
date	2002.02.21.03.24.14;	author vincent;	state Exp;
branches;
next	1.2;

1.2
date	2002.02.20.23.15.03;	author vincent;	state Exp;
branches;
next	1.1;

1.1
date	2002.02.20.22.30.54;	author vincent;	state Exp;
branches;
next	;


desc
@@


1.58
log
@Initialize stack variables to zero before memmove().

    Coverity Scan reported these two stack variables as uninitialized, in
    particular the .r_lineno struct member was uninitialized.  This patch
    clears the 'struct region' rather than setting .r_lineno because if
    any more struct members are added in the future the clear will cover
    them too.

Source Joachim Nilsson. ok tom@@ millert@@
@
text
@/* $OpenBSD: undo.c,v 1.57 2015/12/11 20:21:23 mmcc Exp $ */
/*
 * This file is in the public domain
 */

#include <sys/queue.h>
#include <signal.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#include "def.h"
#include "kbd.h"

#define MAX_FREE_RECORDS	32

/*
 * Local variables
 */
static struct undoq		 undo_free;
static int			 undo_free_num;
static int			 boundary_flag = TRUE;
static int			 undo_enable_flag = TRUE;

/*
 * Local functions
 */
static int find_dot(struct line *, int);
static int find_lo(int, struct line **, int *, int *);
static struct undo_rec *new_undo_record(void);
static int drop_oldest_undo_record(void);

/*
 * find_dot, find_lo()
 *
 * Find an absolute dot in the buffer from a line/offset pair, and vice-versa.
 *
 * Since lines can be deleted while they are referenced by undo record, we
 * need to have an absolute dot to have something reliable.
 */
static int
find_dot(struct line *lp, int off)
{
	int	 count = 0;
	struct line	*p;

	for (p = curbp->b_headp; p != lp; p = lforw(p)) {
		if (count != 0) {
			if (p == curbp->b_headp) {
				dobeep();
				ewprintf("Error: Undo stuff called with a"
				    "nonexistent line");
				return (FALSE);
			}
		}
		count += llength(p) + 1;
	}
	count += off;

	return (count);
}

static int
find_lo(int pos, struct line **olp, int *offset, int *lnum)
{
	struct line *p;
	int lineno;

	p = curbp->b_headp;
	lineno = 0;
	while (pos > llength(p)) {
		pos -= llength(p) + 1;
		if ((p = lforw(p)) == curbp->b_headp) {
			*olp = NULL;
			*offset = 0;
			return (FALSE);
		}
		lineno++;
	}
	*olp = p;
	*offset = pos;
	*lnum = lineno;

	return (TRUE);
}

static struct undo_rec *
new_undo_record(void)
{
	struct undo_rec *rec;

	rec = TAILQ_FIRST(&undo_free);
	if (rec != NULL) {
		/* Remove it from the free-list */
		TAILQ_REMOVE(&undo_free, rec, next);
		undo_free_num--;
	} else {
		if ((rec = malloc(sizeof(*rec))) == NULL)
			panic("Out of memory in undo code (record)");
	}
	memset(rec, 0, sizeof(struct undo_rec));

	return (rec);
}

void
free_undo_record(struct undo_rec *rec)
{
	static int initialised = 0;

	/*
	 * On the first run, do initialisation of the free list.
	 */
	if (initialised == 0) {
		TAILQ_INIT(&undo_free);
		initialised = 1;
	}
	free(rec->content);
	rec->content = NULL;
	if (undo_free_num >= MAX_FREE_RECORDS) {
		free(rec);
		return;
	}
	undo_free_num++;

	TAILQ_INSERT_HEAD(&undo_free, rec, next);
}

/*
 * Drop the oldest undo record in our list. Return 1 if we could remove it,
 * 0 if the undo list was empty.
 */
static int
drop_oldest_undo_record(void)
{
	struct undo_rec *rec;

	rec = TAILQ_LAST(&curbp->b_undo, undoq);
	if (rec != NULL) {
		undo_free_num--;
		TAILQ_REMOVE(&curbp->b_undo, rec, next);
		free_undo_record(rec);
		return (1);
	}
	return (0);
}

static int
lastrectype(void)
{
	struct undo_rec *rec;

	if ((rec = TAILQ_FIRST(&curbp->b_undo)) != NULL)
		return (rec->type);
	return (0);
}

/*
 * Returns TRUE if undo is enabled, FALSE otherwise.
 */
int
undo_enabled(void)
{
	return (undo_enable_flag);
}

/*
 * undo_enable: toggle undo_enable.
 * Returns the previous value of the flag.
 */
int
undo_enable(int f, int n)
{
	int pon = undo_enable_flag;

	if (f & (FFARG | FFRAND))
		undo_enable_flag = n > 0;
	else
		undo_enable_flag = !undo_enable_flag;

	if (!(f & FFRAND))
		ewprintf("Undo %sabled", undo_enable_flag ? "en" : "dis");

	return (pon);
}

/*
 * If undo is enabled, then:
 *  Toggle undo boundary recording.
 *  If called with an argument, (n > 0) => enable. Otherwise disable.
 * In either case, add an undo boundary
 * If undo is disabled, this function has no effect.
 */
int
undo_boundary_enable(int f, int n)
{
	int bon = boundary_flag;

	if (!undo_enable_flag)
		return (FALSE);

	undo_add_boundary(FFRAND, 1);

	if (f & (FFARG | FFRAND))
		boundary_flag = n > 0;
	else
		boundary_flag = !boundary_flag;

	if (!(f & FFRAND))
		ewprintf("Undo boundaries %sabled",
		    boundary_flag ? "en" : "dis");

	return (bon);
}

/*
 * Record an undo boundary, unless boundary_flag == FALSE.
 * Does nothing if previous undo entry is already a boundary or 'modified' flag.
 */
int
undo_add_boundary(int f, int n)
{
	struct undo_rec *rec;
	int last;

	if (boundary_flag == FALSE)
		return (FALSE);

	last = lastrectype();
	if (last == BOUNDARY || last == MODIFIED)
		return (TRUE);

	rec = new_undo_record();
	rec->type = BOUNDARY;

	TAILQ_INSERT_HEAD(&curbp->b_undo, rec, next);

	return (TRUE);
}

/*
 * Record an undo "modified" boundary
 */
void
undo_add_modified(void)
{
	struct undo_rec *rec, *trec;

	TAILQ_FOREACH_SAFE(rec, &curbp->b_undo, next, trec)
		if (rec->type == MODIFIED) {
			TAILQ_REMOVE(&curbp->b_undo, rec, next);
			free_undo_record(rec);
		}

	rec = new_undo_record();
	rec->type = MODIFIED;

	TAILQ_INSERT_HEAD(&curbp->b_undo, rec, next);

	return;
}

int
undo_add_insert(struct line *lp, int offset, int size)
{
	struct region	reg;
	struct	undo_rec *rec;
	int	pos;

	if (!undo_enable_flag)
		return (TRUE);

	memset(&reg, 0, sizeof(reg));
	reg.r_linep = lp;
	reg.r_offset = offset;
	reg.r_size = size;

	pos = find_dot(lp, offset);

	/*
	 * We try to reuse the last undo record to `compress' things.
	 */
	rec = TAILQ_FIRST(&curbp->b_undo);
	if (rec != NULL && rec->type == INSERT) {
		if (rec->pos + rec->region.r_size == pos) {
			rec->region.r_size += reg.r_size;
			return (TRUE);
		}
	}

	/*
	 * We couldn't reuse the last undo record, so prepare a new one.
	 */
	rec = new_undo_record();
	rec->pos = pos;
	rec->type = INSERT;
	memmove(&rec->region, &reg, sizeof(struct region));
	rec->content = NULL;

	undo_add_boundary(FFRAND, 1);

	TAILQ_INSERT_HEAD(&curbp->b_undo, rec, next);

	return (TRUE);
}

/*
 * This of course must be done _before_ the actual deletion is done.
 */
int
undo_add_delete(struct line *lp, int offset, int size, int isreg)
{
	struct region	reg;
	struct	undo_rec *rec;
	int	pos;

	if (!undo_enable_flag)
		return (TRUE);

	memset(&reg, 0, sizeof(reg));
	reg.r_linep = lp;
	reg.r_offset = offset;
	reg.r_size = size;

	pos = find_dot(lp, offset);

	if (offset == llength(lp))	/* if it's a newline... */
		undo_add_boundary(FFRAND, 1);
	else if ((rec = TAILQ_FIRST(&curbp->b_undo)) != NULL) {
		/*
		 * Separate this command from the previous one if we're not
		 * just before the previous record...
		 */
		if (!isreg && rec->type == DELETE) {
			if (rec->pos - rec->region.r_size != pos)
				undo_add_boundary(FFRAND, 1);
		}
	}
	rec = new_undo_record();
	rec->pos = pos;
	if (isreg)
		rec->type = DELREG;
	else
		rec->type = DELETE;
	memmove(&rec->region, &reg, sizeof(struct region));
	do {
		rec->content = malloc(reg.r_size + 1);
	} while ((rec->content == NULL) && drop_oldest_undo_record());

	if (rec->content == NULL)
		panic("Out of memory");

	region_get_data(&reg, rec->content, reg.r_size);

	if (isreg || lastrectype() != DELETE)
		undo_add_boundary(FFRAND, 1);

	TAILQ_INSERT_HEAD(&curbp->b_undo, rec, next);

	return (TRUE);
}

/*
 * This of course must be called before the change takes place.
 */
int
undo_add_change(struct line *lp, int offset, int size)
{
	if (!undo_enable_flag)
		return (TRUE);
	undo_add_boundary(FFRAND, 1);
	boundary_flag = FALSE;
	undo_add_delete(lp, offset, size, 0);
	undo_add_insert(lp, offset, size);
	boundary_flag = TRUE;
	undo_add_boundary(FFRAND, 1);

	return (TRUE);
}

/*
 * Show the undo records for the current buffer in a new buffer.
 */
/* ARGSUSED */
int
undo_dump(int f, int n)
{
	struct	 undo_rec *rec;
	struct buffer	*bp;
	struct mgwin	*wp;
	char	 buf[4096], tmp[1024];
	int	 num;

	/*
	 * Prepare the buffer for insertion.
	 */
	if ((bp = bfind("*undo*", TRUE)) == NULL)
		return (FALSE);
	bp->b_flag |= BFREADONLY;
	bclear(bp);
	if ((wp = popbuf(bp, WNONE)) == NULL)
		return (FALSE);

	for (wp = wheadp; wp != NULL; wp = wp->w_wndp) {
		if (wp->w_bufp == bp) {
			wp->w_dotp = bp->b_headp;
			wp->w_doto = 0;
		}
	}

	num = 0;
	TAILQ_FOREACH(rec, &curbp->b_undo, next) {
		num++;
		snprintf(buf, sizeof(buf),
		    "%d:\t %s at %d ", num,
		    (rec->type == DELETE) ? "DELETE":
		    (rec->type == DELREG) ? "DELREGION":
		    (rec->type == INSERT) ? "INSERT":
		    (rec->type == BOUNDARY) ? "----" :
		    (rec->type == MODIFIED) ? "MODIFIED": "UNKNOWN",
		    rec->pos);

		if (rec->content) {
			(void)strlcat(buf, "\"", sizeof(buf));
			snprintf(tmp, sizeof(tmp), "%.*s", rec->region.r_size,
			    rec->content);
			(void)strlcat(buf, tmp, sizeof(buf));
			(void)strlcat(buf, "\"", sizeof(buf));
		}
		snprintf(tmp, sizeof(tmp), " [%d]", rec->region.r_size);
		if (strlcat(buf, tmp, sizeof(buf)) >= sizeof(buf)) {
			dobeep();
			ewprintf("Undo record too large. Aborted.");
			return (FALSE);
		}
		addlinef(bp, "%s", buf);
	}
	for (wp = wheadp; wp != NULL; wp = wp->w_wndp) {
		if (wp->w_bufp == bp) {
			wp->w_dotline = num+1;
			wp->w_rflag |= WFFULL;
		}
	}
	return (TRUE);
}

/*
 * After the user did action1, then action2, then action3:
 *
 *	[action3] <--- Undoptr
 *	[action2]
 *	[action1]
 *	 ------
 *	 [undo]
 *
 * After undo:
 *
 *	[undo of action3]
 *	[action2] <--- Undoptr
 *	[action1]
 *	 ------
 *	 [undo]
 *
 * After another undo:
 *
 *
 *	[undo of action2]
 *	[undo of action3]
 *	[action1]  <--- Undoptr
 *	 ------
 *	 [undo]
 *
 * Note that the "undo of actionX" have no special meaning. Only when
 * we undo a deletion, the insertion will be recorded just as if it
 * was typed on the keyboard. Resulting in the inverse operation being
 * saved in the list.
 *
 * If undoptr reaches the bottom of the list, or if we moved between
 * two undo actions, we make it point back at the topmost record. This is
 * how we handle redoing.
 */
/* ARGSUSED */
int
undo(int f, int n)
{
	struct undo_rec	*ptr, *nptr;
	int		 done, rval;
	struct line	*lp;
	int		 offset, save;
	static int	 nulled = FALSE;
	int		 lineno;

	if (n < 0)
		return (FALSE);

	ptr = curbp->b_undoptr;

	/* first invocation, make ptr point back to the top of the list */
	if ((ptr == NULL && nulled == TRUE) ||  rptcount == 0) {
		ptr = TAILQ_FIRST(&curbp->b_undo);
		nulled = TRUE;
	}

	rval = TRUE;
	while (n--) {
		/* if we have a spurious boundary, free it and move on.... */
		while (ptr && ptr->type == BOUNDARY) {
			nptr = TAILQ_NEXT(ptr, next);
			TAILQ_REMOVE(&curbp->b_undo, ptr, next);
			free_undo_record(ptr);
			ptr = nptr;
		}
		/*
		 * Ptr is NULL, but on the next run, it will point to the
		 * top again, redoing all stuff done in the buffer since
		 * its creation.
		 */
		if (ptr == NULL) {
			dobeep();
			ewprintf("No further undo information");
			rval = FALSE;
			nulled = TRUE;
			break;
		}
		nulled = FALSE;

		/*
		 * Loop while we don't get a boundary specifying we've
		 * finished the current action...
		 */

		undo_add_boundary(FFRAND, 1);

		save = boundary_flag;
		boundary_flag = FALSE;

		done = 0;
		do {
			/*
			 * Move to where this has to apply
			 *
			 * Boundaries (and the modified flag)  are put as
			 * position 0 (to save lookup time in find_dot)
			 * so we must not move there...
			 */
			if (ptr->type != BOUNDARY && ptr->type != MODIFIED) {
				if (find_lo(ptr->pos, &lp,
				    &offset, &lineno) == FALSE) {
					dobeep();
					ewprintf("Internal error in Undo!");
					rval = FALSE;
					break;
				}
				curwp->w_dotp = lp;
				curwp->w_doto = offset;
				curwp->w_markline = curwp->w_dotline;
				curwp->w_dotline = lineno;
			}

			/*
			 * Do operation^-1
			 */
			switch (ptr->type) {
			case INSERT:
				ldelete(ptr->region.r_size, KNONE);
				break;
			case DELETE:
				lp = curwp->w_dotp;
				offset = curwp->w_doto;
				region_put_data(ptr->content,
				    ptr->region.r_size);
				curwp->w_dotp = lp;
				curwp->w_doto = offset;
				break;
			case DELREG:
				region_put_data(ptr->content,
				    ptr->region.r_size);
				break;
			case BOUNDARY:
				done = 1;
				break;
			case MODIFIED:
				curbp->b_flag &= ~BFCHG;
				break;
			default:
				break;
			}

			/* And move to next record */
			ptr = TAILQ_NEXT(ptr, next);
		} while (ptr != NULL && !done);

		boundary_flag = save;
		undo_add_boundary(FFRAND, 1);

		ewprintf("Undo!");
	}

	curbp->b_undoptr = ptr;

	return (rval);
}
@


1.57
log
@Remove NULL-checks before free().
@
text
@d1 1
a1 1
/* $OpenBSD: undo.c,v 1.56 2015/03/19 21:22:15 bcallah Exp $ */
d272 2
d320 1
@


1.56
log
@Clean up the includes in mg.
This does the following:
Moves all POSIX headers from sysdef.h into the individual .c files so that
each file now only includes what it needs. All headers are properly sorted.
Moves the remainder of sysdef.h to other files (mostly def.h) and deletes
sysdef.h now that it's no longer contains anything.
Tweak a comment that references sysdef.h so that it no longer does that.
ok florian@@
@
text
@d1 1
a1 1
/* $OpenBSD: undo.c,v 1.55 2014/03/20 07:47:29 lum Exp $ */
d118 2
a119 4
	if (rec->content != NULL) {
		free(rec->content);
		rec->content = NULL;
	}
@


1.55
log
@Add some missing dobeeps.
ok florian@@
@
text
@d1 1
a1 1
/* $OpenBSD: undo.c,v 1.54 2013/06/01 16:27:56 lum Exp $ */
d5 6
@


1.54
log
@If popbuf() fails, calling function should return FALSE.
@
text
@d1 1
a1 1
/* $OpenBSD: undo.c,v 1.53 2013/03/25 11:39:38 florian Exp $ */
d44 1
d425 1
d512 1
d542 1
@


1.53
log
@Correct line numbers for undo-list.
OK jasper@@
@
text
@d1 1
a1 1
/* $OpenBSD: undo.c,v 1.52 2013/03/25 11:38:22 florian Exp $ */
d393 2
a394 1
	popbuf(bp, WNONE);
@


1.52
log
@Record when the buffer was saved in the undo history. The buffer
will be marked unchanged at the correct point when stepping
through the undo history.
OK jasper@@
@
text
@d1 1
a1 1
/* $OpenBSD: undo.c,v 1.51 2012/11/06 18:04:10 florian Exp $ */
d427 6
@


1.51
log
@Remove never read struct member, found while investigating a llvm
report.

ok lum, jasper, benno
@
text
@d1 1
a1 1
/* $OpenBSD: undo.c,v 1.50 2010/06/30 19:12:54 oga Exp $ */
d242 7
a248 1
	struct undo_rec *rec;
@


1.50
log
@you keep saying LIST_END. I do not think it means what you think it
means.

If we hit an OOM condition, mg started to try and dump the older undo buffer
entries in order to be able to continue. OTOH, it was grabbing this entry with
LIST_END, which like all *_END() list macros evaluates to NULL.

Do what we actually want and switch that list to a TAILQ and use
TAILQ_LAST to grab the last entry.

Wrote this a loooooong time ago after a mail from Matthew Dempsky on
bugs@@. ok kjell@@, beck@@ also looked at this months ago and thought it
was alright.
@
text
@d1 1
a1 1
/* $OpenBSD: undo.c,v 1.49 2009/06/05 18:02:06 kjell Exp $ */
d467 1
a467 1
	int		 offset, save, dot;
a473 2
	dot = find_dot(curwp->w_dotp, curwp->w_doto);

d574 1
a574 4
	/*
	 * Record where we are. (we have to save our new position at the end
	 * since we change the dot when undoing....)
	 */
a575 2

	curbp->b_undopos = find_dot(curwp->w_dotp, curwp->w_doto);
@


1.49
log
@emacs handles the undo of a region kill (C-w) differently than a line kill
(C-k) with respect to cursor position. The former leaves the cursor at the end,
the latter at the beginning of the region.

emacs is wacky.

Make mg undo do the same. ok deraadt
@
text
@d1 1
a1 1
/* $OpenBSD: undo.c,v 1.48 2009/06/04 23:39:37 kjell Exp $ */
d14 1
a14 1
static LIST_HEAD(, undo_rec)	 undo_free;
d85 1
a85 1
	rec = LIST_FIRST(&undo_free);
d87 2
a88 1
		LIST_REMOVE(rec, next);	/* Remove it from the free-list */
d108 1
a108 1
		LIST_INIT(&undo_free);
d121 1
a121 1
	LIST_INSERT_HEAD(&undo_free, rec, next);
d133 1
a133 1
	rec = LIST_END(&curbp->b_undo);
d136 1
a136 1
		LIST_REMOVE(rec, next);
d148 1
a148 1
	if ((rec = LIST_FIRST(&curbp->b_undo)) != NULL)
d231 1
a231 1
	LIST_INSERT_HEAD(&curbp->b_undo, rec, next);
d247 1
a247 1
	LIST_INSERT_HEAD(&curbp->b_undo, rec, next);
d270 1
a270 1
	rec = LIST_FIRST(&curbp->b_undo);
d289 1
a289 1
	LIST_INSERT_HEAD(&curbp->b_undo, rec, next);
d315 1
a315 1
	else if ((rec = LIST_FIRST(&curbp->b_undo)) != NULL) {
d344 1
a344 1
	LIST_INSERT_HEAD(&curbp->b_undo, rec, next);
d397 1
a397 2
	for (rec = LIST_FIRST(&curbp->b_undo); rec != NULL;
	    rec = LIST_NEXT(rec, next)) {
d480 1
a480 1
		ptr = LIST_FIRST(&curbp->b_undo);
d488 2
a489 2
			nptr = LIST_NEXT(ptr, next);
			LIST_REMOVE(ptr, next);
d568 1
a568 1
			ptr = LIST_NEXT(ptr, next);
@


1.48
log
@Add the notion of an "ephemeral" popup, so we can flag a window
for destruction at a later date. (in the process, add a window flag field)

This fixes an issue noted by maja: namely, the *completion*
window that pops up when you try to complete a filename on
buffer load would destroy any second window that you happened
to have open.

ok maja@@
@
text
@d1 1
a1 1
/* $OpenBSD: undo.c,v 1.47 2008/09/15 16:13:35 kjell Exp $ */
d297 1
a297 1
undo_add_delete(struct line *lp, int offset, int size)
d319 1
a319 1
		if (rec->type == DELETE) {
d326 4
a329 2

	rec->type = DELETE;
d340 1
a340 1
	if (lastrectype() != DELETE)
d358 1
a358 1
	undo_add_delete(lp, offset, size);
d402 1
d552 4
@


1.47
log
@Expose the undo commands as proper mg functions.
This should have no functional change on undo, but it does facilitate
testing undo behavior.
@
text
@d1 1
a1 1
/* $OpenBSD: undo.c,v 1.46 2008/06/14 07:38:53 kjell Exp $ */
d384 1
a384 1
	popbuf(bp);
@


1.46
log
@unf*ck undo.
No seriously. Reposition the cursor to the start of the redo
position, like emacs. This gets us halfway to being emacs-finger-friendly.
For the rest, introduce a rptcount variable to count successive invocations
of the same function. This means undo will abort properly on C-g, and
other such interruptions.
This is a lot of diff for a simple-seeming problem. Emacs undo is hard.
@
text
@d1 1
a1 1
/* $OpenBSD: undo.c,v 1.45 2008/06/11 17:07:37 kjell Exp $ */
d162 2
a163 2
 * undo_enable(TRUE/FALSE) will enable / disable the undo mechanism.
 * Returns TRUE if previously enabled, FALSE otherwise.
d166 1
a166 1
undo_enable(int on)
d170 8
a177 1
	undo_enable_flag = on;
d183 3
a185 3
 *   undo_boundary_enable(FALSE) stops recording undo boundaries
 *   between actions.
 *   undo_boundary_enable(TRUE) enables undo boundaries.
d188 4
d193 15
a207 5
void
undo_boundary_enable(int flag)
{
	if (undo_enable_flag == TRUE)
		boundary_flag = flag;
d214 2
a215 2
void
undo_add_boundary(void)
d221 1
a221 1
		return;
d225 1
a225 1
		return;
d232 1
a232 1
	return;
d258 1
a258 1
	if (undo_enable_flag == FALSE)
d286 1
a286 1
	undo_add_boundary();
d303 1
a303 1
	if (undo_enable_flag == FALSE)
d313 1
a313 1
		undo_add_boundary();
d321 1
a321 1
				undo_add_boundary();
d339 1
a339 1
		undo_add_boundary();
d352 1
a352 1
	if (undo_enable_flag == FALSE)
d354 1
a354 1
	undo_add_boundary();
d359 1
a359 1
	undo_add_boundary();
d508 1
a508 1
		undo_add_boundary();
d565 1
a565 1
		undo_add_boundary();
@


1.45
log
@With Vincent's permission, the last remaining chunk of mg has been
placed in the public domain.
This means mg (minus theo.c) is once again a public domain
piece of code. Please try to keep it that way.
@
text
@d1 1
a1 1
/* $OpenBSD: undo.c,v 1.44 2007/09/16 20:34:18 kjell Exp $ */
d176 2
a177 1
 *   undo_boundary_enable(FALS) stops recording undo boundaries between actions.
d447 3
d454 2
a455 2
	/* if we moved, make ptr point back to the top of the list */
	if ((ptr == NULL && nulled == TRUE) || curbp->b_undopos != dot) {
d522 2
d526 2
@


1.44
log
@I can't think of any good reason to inline this.
Makes pcc happier, to boot.
@
text
@d1 1
a1 1
/* $OpenBSD: undo.c,v 1.43 2006/11/19 16:51:19 deraadt Exp $ */
d3 1
a3 23
 * Copyright (c) 2002 Vincent Labrecque <vincent@@openbsd.org>
 * Copyright (c) 2005, 2006 Kjell Wooding <kjell@@openbsd.org>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
 * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
 * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
@


1.43
log
@spacing
@
text
@d1 1
a1 1
/* $OpenBSD: undo.c,v 1.42 2006/11/17 08:45:31 kjell Exp $ */
d164 1
a164 1
static __inline__ int
@


1.42
log
@Fix a needless inversion of flag names; i.e. change them from the
negative to the positive. undo_boundary_enable(TRUE) makes a LOT more
sense than undo_no_boundary(FALSE).
While here, whack a global, and fix a bug noted by otto:
undoing a file insertion sometimes left stray characters around.
ok beck@@, otto@@
@
text
@d1 1
a1 1
/* $OpenBSD: undo.c,v 1.41 2006/07/25 08:22:32 kjell Exp $ */
d39 1
a39 1
static int 			 undo_enable_flag = TRUE;
@


1.41
log
@Rename the header line of a buffer to b_headp, from the remarkably
unintuitive b_linep. No binary change.
@
text
@d1 1
a1 1
/* $OpenBSD: undo.c,v 1.40 2006/07/08 17:56:10 kjell Exp $ */
d38 2
a39 11
static int			 nobound;

/*
 * Global variables
 */
/*
 * undo_disable_flag: Stop doing undo (useful when we know are
 *	going to deal with huge deletion/insertions
 *	that we don't plan to undo)
 */
int undo_disable_flag;
d175 9
d190 1
a190 1
	int pon = undo_disable_flag;
d192 2
a193 2
	undo_disable_flag = (on == TRUE) ? 0 : 1;
	return ((pon == TRUE) ? FALSE : TRUE);
d198 2
a199 2
 *   undo_no_boundary(TRUE) stops recording undo boundaries between actions.
 *   undo_no_boundary(FALSE) enables undo boundaries.
d202 1
d204 1
a204 1
undo_no_boundary(int flag)
d206 2
a207 2
	if (undo_disable_flag == FALSE)
		nobound = flag;
d211 1
a211 1
 * Record an undo boundary, unless 'nobound' is set via undo_no_boundary.
d220 1
a220 1
	if (nobound)
d258 1
a258 1
	if (undo_disable_flag)
d303 1
a303 1
	if (undo_disable_flag)
d352 1
a352 1
	if (undo_disable_flag)
d355 1
a355 1
	nobound = TRUE;
d358 1
a358 1
	nobound = FALSE;
d507 2
a508 2
		save = nobound;
		nobound = TRUE;
d557 1
a557 1
		nobound = save;
@


1.40
log
@Introduce a 'MODIFIED' boundary type for undo records.
This allows undo to clear the modified flag when undo-ing all the way
from a loaded buffer.
Originally whipped up at c2k6 after proddings from beck.
jason@@ ok.
@
text
@d1 1
a1 1
/* $OpenBSD: undo.c,v 1.39 2006/07/08 17:50:30 kjell Exp $ */
d72 1
a72 1
	for (p = curbp->b_linep; p != lp; p = lforw(p)) {
d74 1
a74 1
			if (p == curbp->b_linep) {
d93 1
a93 1
	p = curbp->b_linep;
d97 1
a97 1
		if ((p = lforw(p)) == curbp->b_linep) {
d387 1
a387 1
			wp->w_dotp = bp->b_linep;
@


1.39
log
@Fix a trio of bugs in line numbering: adjusting linenos after undo,
cutting a block, and off-by-one linecount. Initial bug discovered by
jason
@
text
@d1 1
a1 1
/* $OpenBSD: undo.c,v 1.38 2005/12/20 05:04:28 kjell Exp $ */
d211 1
a211 1
 * Does nothing if previous undo entry is already a boundary.
d217 1
d222 2
a223 1
	if (lastrectype() == BOUNDARY)
d234 16
d400 2
a401 1
		    (rec->type == BOUNDARY) ? "----" : "UNKNOWN",
d514 3
a516 3
			 * Boundaries are put as position 0 (to save
			 * lookup time in find_dot) so we must
			 * not move there...
d518 1
a518 1
			if (ptr->type != BOUNDARY) {
d544 3
@


1.38
log
@Do some delinting of strl-type functions. Also, remove a superfluous
word in the undo-list.
@
text
@d1 1
a1 1
/* $OpenBSD: undo.c,v 1.37 2005/12/13 07:20:13 kjell Exp $ */
d4 1
d54 1
a54 1
static int find_lo(int, struct line **, int *);
d88 1
a88 1
find_lo(int pos, struct line **olp, int *offset)
d91 1
d94 1
d102 1
d106 1
d446 1
d501 1
a501 1
				    &offset) == FALSE) {
d508 2
@


1.37
log
@Last round of easy delinting.
@
text
@d1 1
a1 1
/* $OpenBSD: undo.c,v 1.36 2005/12/13 05:40:33 kjell Exp $ */
d374 1
a374 1
		    "Record %d =>\t %s at %d ", num,
d381 1
a381 1
			strlcat(buf, "\"", sizeof(buf));
d384 2
a385 2
			strlcat(buf, tmp, sizeof(buf));
			strlcat(buf, "\"", sizeof(buf));
@


1.36
log
@do some silly de-linting
@
text
@d1 1
a1 1
/* $OpenBSD: undo.c,v 1.35 2005/11/18 20:56:53 deraadt Exp $ */
d208 1
a208 1
int
d214 1
a214 1
		return (TRUE);
d217 1
a217 1
		return (TRUE);
d224 1
a224 1
	return (TRUE);
@


1.35
log
@greedy use of typedef struct was making code harder to read; ok kjell cloder
@
text
@d1 1
a1 1
/* $OpenBSD: undo.c,v 1.34 2005/11/18 17:11:21 kjell Exp $ */
d438 1
a438 1
	struct line		*lp;
@


1.34
log
@One liner to fix doubled yank buffer issue (c-K, c-Y, M-x undo, c-Y).
@
text
@d1 1
a1 1
/* $OpenBSD: undo.c,v 1.33 2005/11/12 18:48:08 kjell Exp $ */
d52 2
a53 2
static int find_dot(LINE *, int);
static int find_lo(int, LINE **, int *);
d66 1
a66 1
find_dot(LINE *lp, int off)
d69 1
a69 1
	LINE	*p;
d87 1
a87 1
find_lo(int pos, LINE **olp, int *offset)
d89 1
a89 1
	LINE *p;
d228 1
a228 1
undo_add_insert(LINE *lp, int offset, int size)
d230 1
a230 1
	REGION	reg;
d259 1
a259 1
	memmove(&rec->region, &reg, sizeof(REGION));
d273 1
a273 1
undo_add_delete(LINE *lp, int offset, int size)
d275 1
a275 1
	REGION	reg;
d304 1
a304 1
	memmove(&rec->region, &reg, sizeof(REGION));
d326 1
a326 1
undo_add_change(LINE *lp, int offset, int size)
d348 2
a349 2
	BUFFER	*bp;
	MGWIN	*wp;
d438 1
a438 1
	LINE		*lp;
@


1.33
log
@Paranoia. Check if last of a series of strlcats overflows. Pointed out by
Han Boetes.
@
text
@d1 1
a1 1
/* $OpenBSD: undo.c,v 1.32 2005/10/14 19:46:46 kjell Exp $ */
d509 1
a509 1
				ldelete(ptr->region.r_size, KFORW);
@


1.32
log
@add missing /* ARGSUSED */ to quiet lint.
@
text
@d1 1
a1 1
/* $OpenBSD: undo.c,v 1.31 2005/10/13 20:28:49 deraadt Exp $ */
d388 4
a391 1
		strlcat(buf, tmp, sizeof(buf));
@


1.31
log
@spacing
@
text
@d1 1
a1 1
/* $OpenBSD: undo.c,v 1.30 2005/10/13 20:07:26 kjell Exp $ */
d343 1
d429 1
@


1.30
log
@Make undoing of a yank operation work as expected
(i.e. undo boundaries are placed around entire yanked block)
ok cloder@@
@
text
@d1 1
a1 1
/* $OpenBSD: undo.c,v 1.29 2005/10/11 01:08:53 kjell Exp $ */
d218 1
a218 1
	
d432 1
a432 1
	int 		 done, rval;
@


1.29
log
@A while back, undo records were moved from the BUFFER struct to MGWIN.
This is nonsensical, and utterly broken if you are undo-ing across
multiple buffers. Change them back to being associated with the BUFFER
struct. (effectively, just revert the original change)

ok deraadt@@
@
text
@d1 1
a1 1
/* $OpenBSD: undo.c,v 1.28 2005/10/06 16:48:00 kjell Exp $ */
d178 4
d188 1
a188 1
	return (pon ? FALSE : TRUE);
d191 6
d200 1
a200 1
	if (!undo_disable_flag)
d204 4
@


1.28
log
@Make mg undo much more emacs like (and correct).
Undo boundaries are now placed at newlines, and undo
of search-replace works as expected. Fixes bad behaviour
reported by matthieu

Ok deraadt@@, beck@@
@
text
@d1 1
a1 1
/* $OpenBSD: undo.c,v 1.27 2005/05/29 21:37:49 cloder Exp $ */
d158 1
a158 1
	rec = LIST_END(&curwp->w_undo);
d173 1
a173 1
	if ((rec = LIST_FIRST(&curwp->w_undo)) != NULL)
d208 1
a208 1
	LIST_INSERT_HEAD(&curwp->w_undo, rec, next);
d231 1
a231 1
	rec = LIST_FIRST(&curwp->w_undo);
d250 1
a250 1
	LIST_INSERT_HEAD(&curwp->w_undo, rec, next);
d276 1
a276 1
	else if ((rec = LIST_FIRST(&curwp->w_undo)) != NULL) {
d303 1
a303 1
	LIST_INSERT_HEAD(&curwp->w_undo, rec, next);
d355 1
a355 1
	for (rec = LIST_FIRST(&curwp->w_undo); rec != NULL;
d425 1
a425 1
	ptr = curwp->w_undoptr;
d428 2
a429 2
	if ((ptr == NULL && nulled == TRUE) || curwp->w_undopos != dot) {
		ptr = LIST_FIRST(&curwp->w_undo);
d516 1
a516 1
	curwp->w_undoptr = ptr;
d518 1
a518 1
	curwp->w_undopos = find_dot(curwp->w_dotp, curwp->w_doto);
@


1.27
log
@Try to undo crazy Quebecois stuff that was breaking undo
@
text
@d1 1
a1 1
/* $OpenBSD: undo.c,v 1.26 2005/04/29 07:22:38 otto Exp $ */
d187 7
d202 3
d317 1
a317 1
	nobound = 1;
d320 1
a320 1
	nobound = 0;
d421 1
d428 1
a428 1
	if (ptr == NULL || curwp->w_undopos != dot)
d430 2
d450 1
d453 1
d460 1
a460 2
		if (lastrectype() != BOUNDARY)
			undo_add_boundary();
d463 1
a463 1
		nobound = 1;
@


1.26
log
@Remove unneeded include. Han Boetes.
@
text
@d1 1
a1 1
/* $OpenBSD: undo.c,v 1.25 2005/04/03 02:09:28 db Exp $ */
d238 1
a238 2
	if (lastrectype() != INSERT)
		undo_add_boundary();
@


1.25
log
@This is a no binary change which does:

- spelling, punctuation fixes
- variable declaration lineup
- use parentheses for return and sizeof
- K&R function declarations -> ANSI
- other minor code beautification

ok henning@@
@
text
@d1 1
a1 1
/* $OpenBSD: undo.c,v 1.24 2003/12/15 00:00:12 vincent Exp $ */
a28 2

#include <sys/queue.h>
@


1.24
log
@shorter function names
@
text
@d1 1
a1 1
/* $OpenBSD: undo.c,v 1.23 2003/11/29 17:28:40 vincent Exp $ */
d3 1
a3 1
 * Copyright (c) 2002 Vincent Labrecque
a66 1

d70 2
a71 2
	int count = 0;
	LINE *p;
d118 1
a118 1
		if ((rec = malloc(sizeof *rec)) == NULL)
d153 1
a153 1
 * 0 if the undo list was empty
d208 3
a210 3
	REGION reg;
	struct undo_rec *rec;
	int pos;
d232 1
a232 1
	 * We couldn't reuse the last undo record, so prepare a new one
d249 1
a249 1
 * This of course must be done _before_ the actual deletion is done
d254 3
a256 3
	REGION reg;
	struct undo_rec *rec;
	int pos;
d302 1
a302 1
 * This of course must be called before the change takes place
d325 5
a329 5
	struct undo_rec *rec;
	BUFFER *bp;
	MGWIN *wp;
	char buf[4096], tmp[1024];
	int num;
d351 1
a351 1
		snprintf(buf, sizeof buf,
d359 2
a360 2
			strlcat(buf, "\"", sizeof buf);
			snprintf(tmp, sizeof tmp, "%.*s", rec->region.r_size,
d362 2
a363 2
			strlcat(buf, tmp, sizeof buf);
			strlcat(buf, "\"", sizeof buf);
d365 2
a366 2
		snprintf(tmp, sizeof tmp, " [%d]", rec->region.r_size);
		strlcat(buf, tmp, sizeof buf);
d373 1
a373 1
 * After the user did action1, then action2, then action3 :
d398 2
a399 2
 * Note that the "undo of actionX" have no special meaning. Only when,
 * say, we undo a deletion, the insertion will be recorded just as if it
d410 4
a413 4
	struct undo_rec *ptr, *nptr;
	int done, rval;
	LINE *lp;
	int offset, save, dot;
@


1.23
log
@save the previous undo position as an offset in the buffer instead of
a line/offset pair
@
text
@d1 1
a1 1
/* $OpenBSD: undo.c,v 1.22 2003/11/09 01:44:39 vincent Exp $ */
d54 2
a55 2
static int find_absolute_dot(LINE *, int);
static int find_line_offset(int, LINE **, int *);
d60 1
a60 1
 * find_{absolute_dot,line_offset}()
d69 1
a69 1
find_absolute_dot(LINE *lp, int off)
d90 1
a90 1
find_line_offset(int pos, LINE **olp, int *offset)
d219 1
a219 1
	pos = find_absolute_dot(lp, offset);
d266 1
a266 1
	pos = find_absolute_dot(lp, offset);
d416 1
a416 1
	dot = find_absolute_dot(curwp->w_dotp, curwp->w_doto);
d461 1
a461 1
			 * lookup time in find_absolute_dot) so we must
d465 1
a465 1
				if (find_line_offset(ptr->pos, &lp,
d508 1
a508 1
	curwp->w_undopos = find_absolute_dot(curwp->w_dotp, curwp->w_doto);
@


1.22
log
@better boundary placement.

there should be no more problems with inserting files now...
@
text
@d1 1
a1 1
/* $OpenBSD: undo.c,v 1.21 2003/11/09 01:20:32 vincent Exp $ */
d225 4
a228 6
	if (rec != NULL) {
		if (rec->type == INSERT) {
			if (rec->pos + rec->region.r_size == pos) {
				rec->region.r_size += reg.r_size;
				return (TRUE);
			}
d278 1
a278 2
		} else if (rec->type != BOUNDARY)
			undo_add_boundary();
d414 3
a416 1
	int offset, save;
d421 1
a421 3
	if ((curwp->w_undopos.r_linep != curwp->w_dotp) ||
	    (curwp->w_undopos.r_offset != curwp->w_doto) ||
	    (ptr == NULL))
d507 2
a508 2
	curwp->w_undopos.r_linep = curwp->w_dotp;
	curwp->w_undopos.r_offset = curwp->w_doto;
@


1.21
log
@fix a bug i introduced in -r1.19, we should still use the current buffer
to test for the end of circular lists.
@
text
@d1 1
a1 1
/* $OpenBSD: undo.c,v 1.20 2003/11/09 01:11:14 vincent Exp $ */
d172 1
a172 1
last_was_boundary(void)
d176 2
a177 3
	if ((rec = LIST_FIRST(&curwp->w_undo)) != NULL &&
	    (rec->type == BOUNDARY))
		return (1);
d185 1
a225 3
		/* this will be hit like, 80% of the time... */
		if (rec->type == BOUNDARY)
			rec = LIST_NEXT(rec, next);
d243 1
a243 1
	if (!last_was_boundary())
a246 1
	undo_add_boundary();
d297 3
a300 1
	undo_add_boundary();
d417 1
a417 1
	int offset;
d451 7
a459 4
			/* Unlink the current node from the list */
			nptr = LIST_NEXT(ptr, next);
			LIST_REMOVE(ptr, next);

a494 1
			free_undo_record(ptr);
d497 1
a497 1
			ptr = nptr;
d499 3
@


1.20
log
@remove the only use of the hackish undo_add_custom function.
@
text
@d1 1
a1 1
/* $OpenBSD: undo.c,v 1.19 2003/10/21 22:48:07 vincent Exp $ */
d74 1
a74 1
	for (p = curwp->w_linep; p != lp; p = lforw(p)) {
d76 1
a76 1
			if (p == curwp->w_linep) {
d94 1
a94 1
	p = curwp->w_linep;
d97 1
a97 1
		if ((p = lforw(p)) == curwp->w_linep) {
@


1.19
log
@make undo records per MGWIN, not per BUFFER...
@
text
@d1 1
a1 1
/* $OpenBSD: undo.c,v 1.18 2003/06/26 23:04:10 vincent Exp $ */
a201 33

	return (TRUE);
}

/*
 * If asocial is true, we arrange for this record to be let alone.  forever.
 * Yes, this is a bit of a hack...
 */
int
undo_add_custom(int asocial,
    int type, LINE *lp, int offset, void *content, int size)
{
	struct undo_rec *rec;

	if (undo_disable_flag)
		return (TRUE);
	rec = new_undo_record();
	if (lp != NULL)
		rec->pos = find_absolute_dot(lp, offset);
	else
		rec->pos = 0;
	rec->type = type;
	rec->content = content;
	rec->region.r_linep = lp;
	rec->region.r_offset = offset;
	rec->region.r_size = size;

	if (!last_was_boundary())
		undo_add_boundary();
	LIST_INSERT_HEAD(&curwp->w_undo, rec, next);
	undo_add_boundary();
	if (asocial)		/* Add a second one */
		undo_add_boundary();
@


1.18
log
@protos

ok deraadt
@
text
@d1 1
a1 1
/* $OpenBSD: undo.c,v 1.17 2003/06/01 15:53:34 deraadt Exp $ */
d161 1
a161 1
	rec = LIST_END(&curbp->b_undo);
d176 1
a176 1
	if ((rec = LIST_FIRST(&curbp->b_undo)) != NULL &&
d201 1
a201 1
	LIST_INSERT_HEAD(&curbp->b_undo, rec, next);
d231 1
a231 1
	LIST_INSERT_HEAD(&curbp->b_undo, rec, next);
d257 1
a257 1
	rec = LIST_FIRST(&curbp->b_undo);
d282 1
a282 1
	LIST_INSERT_HEAD(&curbp->b_undo, rec, next);
d309 1
a309 1
	else if ((rec = LIST_FIRST(&curbp->b_undo)) != NULL) {
d334 1
a334 1
	LIST_INSERT_HEAD(&curbp->b_undo, rec, next);
d387 1
a387 1
	for (rec = LIST_FIRST(&curbp->b_undo); rec != NULL;
d454 1
a454 1
	ptr = curbp->b_undoptr;
d457 2
a458 2
	if ((curbp->b_undopos.r_linep != curwp->w_dotp) ||
	    (curbp->b_undopos.r_offset != curwp->w_doto) ||
d460 1
a460 1
		ptr = LIST_FIRST(&curbp->b_undo);
d539 3
a541 3
	curbp->b_undoptr = ptr;
	curbp->b_undopos.r_linep = curwp->w_dotp;
	curbp->b_undopos.r_offset = curwp->w_doto;
@


1.17
log
@various format string cleanups; tedu ok
@
text
@d1 1
a1 1
/* $OpenBSD: undo.c,v 1.16 2003/05/20 03:08:55 cloder Exp $ */
d362 1
a362 1
undo_dump(void)
@


1.16
log
@Finish KNF of prototypes.  That should be all of them.
OK vincent@@
@
text
@d1 1
a1 1
/* $OpenBSD: undo.c,v 1.15 2003/04/13 19:16:49 avsm Exp $ */
d406 1
a406 1
		addlinef(bp, buf);
@


1.15
log
@correct snprintf bound value, ok millert@@, deraadt@@
@
text
@d1 1
a1 1
/* $OpenBSD: undo.c,v 1.14 2002/09/15 22:18:39 vincent Exp $ */
d172 1
a172 1
last_was_boundary()
@


1.14
log
@don't add undo records when we open a file, only when we insert it.

ok deraadt@@
@
text
@d1 1
a1 1
/* $OpenBSD: undo.c,v 1.13 2002/08/22 23:28:19 deraadt Exp $ */
d404 1
a404 1
		snprintf(tmp, sizeof buf, " [%d]", rec->region.r_size);
@


1.13
log
@knf
@
text
@d1 1
a1 1
/* $OpenBSD: undo.c,v 1.12 2002/07/24 14:08:33 vincent Exp $ */
d185 3
a187 3
	undo_disable_flag = on ? 0 : 1;

	return (on);
@


1.12
log
@ remove the CHANGE undo record type, use a combination of delete and insert
to have the same behavior in a simpler way.

 ok art@@
@
text
@d1 1
a1 1
/* $OpenBSD: undo.c,v 1.11 2002/06/20 04:27:11 vincent Exp $ */
d64 1
a64 1
 * Since lines can be deleted while they are referenced by undo record, we 
d206 1
a206 1
/* 
d256 1
a256 1
	 */	
d388 1
a388 1
	     rec = LIST_NEXT(rec, next)) {
d427 1
a427 1
 * 
d436 1
a436 1
 * 
d482 1
a482 1
		/* 
d518 1
a518 1
				region_put_data(ptr->content, 
d543 1
a543 1
 	return (rval);
@


1.11
log
@KNFify the return (return x -> return (x))
remove an "else" from last commit, it didn't make a lot of sense.
@
text
@d1 1
a1 1
/* $OpenBSD: undo.c,v 1.10 2002/06/20 03:59:15 vincent Exp $ */
d39 1
d195 3
a345 3
	REGION reg;
	struct undo_rec *rec;

d348 5
a352 25

	reg.r_linep = lp;
	reg.r_offset = offset;
	reg.r_size = size;

	rec = new_undo_record();
	rec->pos = find_absolute_dot(lp, offset);
	rec->type = CHANGE;
	memmove(&rec->region, &reg, sizeof reg);

	/*
	 * Try to allocate a buffer for the changed data.
	 */
	do {
		rec->content = malloc(size + 1);
	} while ((rec->content == NULL) && drop_oldest_undo_record());

	if (rec->content == NULL)
		panic("Out of memory in undo change code");

	region_get_data(&reg, rec->content, size);

	if (!last_was_boundary())
		undo_add_boundary();
	LIST_INSERT_HEAD(&curbp->b_undo, rec, next);
a393 1
		    (rec->type == CHANGE) ? "CHANGE":
d397 1
a397 1
		if (rec->type == DELETE || rec->type == CHANGE) {
a519 5
				break;
			case CHANGE:
				forwchar(0, ptr->region.r_size);
				lreplace(ptr->region.r_size,
				    ptr->content, 1);
@


1.10
log
@ some KNF
@
text
@d1 1
a1 1
/* $OpenBSD: undo.c,v 1.9 2002/03/18 01:45:55 vincent Exp $ */
d78 1
a78 1
				return FALSE;
d85 1
a85 1
	return count;
d99 1
a99 1
			return FALSE;
d105 1
a105 1
	return TRUE;
d123 1
a123 1
	return rec;
d165 1
a165 1
		return 1;
d167 1
a167 1
	return 0;
d177 2
a178 2
		return 1;
	return 0;
d186 1
a186 1
	return on;
d199 1
a199 1
	return TRUE;
d213 1
a213 1
		return TRUE;
d232 1
a232 1
	return TRUE;
d243 1
a243 1
		return TRUE;
d258 1
a258 1
		else if (rec->type == INSERT) {
d261 1
a261 1
				return TRUE;
d281 1
a281 1
	return TRUE;
d295 1
a295 1
		return TRUE;
d333 1
a333 1
	return TRUE;
d346 1
a346 1
		return TRUE;
d374 1
a374 1
	return TRUE;
d393 1
a393 1
		return FALSE;
d428 1
a428 1
	return TRUE;
d497 1
a497 1
			ewprintf("Nothing to undo!");
d568 1
a568 1
 	return rval;
@


1.9
log
@ Enter the new undo code.  it is still disabled since it has bugs, but it's
somewhat more useful....

 ok millert@@ + no objections on ICB
@
text
@d1 1
a1 1
/* $OpenBSD: undo.c,v 1.7 2002/02/26 00:45:45 vincent Exp $ */
d3 2
a4 2
 * Copyright (c) 2002 Vincent Labrecque <vincent@@openbsd.org>
 *							 All rights reserved.
d254 9
a262 9
	/* this will be hit like, 80% of the time... */
	if (rec != NULL && rec->type == BOUNDARY)
		rec = LIST_NEXT(rec, next);

	if ((rec != NULL) &&
	    (rec->type == INSERT)) {
		if (rec->pos + rec->region.r_size == pos) {
			rec->region.r_size += reg.r_size;
			return TRUE;
d303 1
a303 1
	if (offset == llength(lp)) /* if it's a newline... */
d310 1
a310 1
		if (rec->type == DELETE){
d398 1
a398 1
	for (wp = wheadp; wp != NULL; wp = wp->w_wndp)
d403 1
d416 1
a417 1

a425 1

d459 1
a459 1
 * was typed on the keyboard. Hence resulting in the inverse operation to be
d483 1
a483 1
	while (n > 0) {
d520 2
a521 2
				if (find_line_offset(ptr->pos,&lp,&offset)
				    == FALSE) {
a558 1
		n--;
@


1.8
log
@ This should've been commited yesterday, before the funmap change.

 ok millert@@
@
text
@d44 3
a46 5
 * undo_disable_flag -
 *
 * Stop doing undo (useful when we know are
 * going to deal with huge deletion/insertions
 * that we don't plan to undo)
a48 1
int undoaction;			/* Are we called indirectly from undo()? */
d53 2
a54 2
static int find_offset(LINE *, int);
static int find_linep(int, LINE **, int *);
d58 9
d68 1
a68 1
find_offset(LINE *lp, int off)
d77 1
a77 1
				    "nonexistent line\n");
d89 1
a89 1
find_linep(int pos, LINE **olp, int *offset)
d94 1
a94 1
	while (pos > 0 && pos > llength(p)) {
d114 1
a114 1
	if (rec != NULL)
d116 2
a117 1
	else {
d122 1
a122 1
	
d129 9
d147 1
a147 1
	
d160 1
a160 1
	rec = LIST_END(&undo_list);
d163 1
a163 2
		LIST_REMOVE(rec, next);	/* Remove it from the undo_list before
					 * we insert it in the free list */
d169 3
a171 3
	
int
undo_init(void)
d173 6
a178 3
	LIST_INIT(&undo_free);
	
	return TRUE;
d185 1
a185 9
	
	/*
	 * XXX-Vince:
	 *
	 * Here, I wonder if we should assume that the user has made a
	 * long term choice.  If so, we could free all internal undo
	 * data and save memory.
	 */
	
d190 1
a190 1
undo_add_custom(int type, LINE *lp, int offset, void *content, int size)
a193 2
	if (undo_disable_flag)
		return TRUE;
d195 1
a195 6
	rec->pos = find_offset(lp, offset);
	rec->type = type;
	rec->content = content;
	rec->region.r_linep = lp;
	rec->region.r_offset = offset;
	rec->region.r_size = size;
d198 1
a198 1
	
d202 4
d207 2
a208 1
undo_add_boundary(void)
a213 1

d215 9
a223 1
	rec->type = BOUNDARY;
d225 2
d228 4
a231 1
	
d240 2
a241 1
	
a243 1

d247 3
a249 1
	
d254 4
d259 2
a260 7
	    (rec->type == INSERT) &&
	    (rec->region.r_linep == lp)) {
		int dist;

		dist = rec->region.r_offset - reg.r_offset;
		
		if (rec->region.r_size >= dist) {
d265 1
a265 1
	
d270 1
a270 1
	rec->pos = find_offset(lp, offset);
d274 4
d279 1
d292 1
a292 1
	int dist, pos, skip = 0;
d301 1
a301 1
	pos = find_offset(lp, offset);
d303 12
a314 2
	if (size == 1 && llength(lp) == 0) {
		skip = 1;
a315 45

	/*
	 * Again, try to reuse last undo record, if we can
	 */
	rec = LIST_FIRST(&curbp->b_undo);
	if (!skip &&
	    (rec != NULL) &&
	    (rec->type == DELETE) &&
	    (rec->region.r_linep == reg.r_linep)) {
		char *newbuf;
		int newlen;

		dist = rec->region.r_offset - reg.r_offset;
		if (rec->region.r_size >= dist) {
			newlen = rec->region.r_size + reg.r_size;

			do {
				newbuf = malloc(newlen * sizeof(char));
			} while (newbuf == NULL && drop_oldest_undo_record());
			
			if (newbuf == NULL)
				panic("out of memory in undo delete code");

			/*
			 * [new data][old data]
			 */
			region_get_data(&reg, newbuf, size);
			memmove(newbuf + reg.r_size, rec->content,
			    rec->region.r_size);

			rec->pos = pos;
			rec->region.r_offset = reg.r_offset;
			rec->region.r_size = newlen;
			if (rec->content != NULL)
				free(rec->content);
			rec->content = newbuf;

			return TRUE;
		}
	}

	/*
	 * So we couldn't reuse the last undo record? Just allocate a new
	 * one.
	 */
d324 1
a324 1
	
d327 1
a327 1
	
d331 1
a344 1
		
d347 1
a347 1
	
d351 1
a351 1
	
d353 1
a353 1
	rec->pos = find_offset(lp, offset);
d357 3
d363 1
a363 1
	
d369 2
d372 2
a373 1
	
d394 1
a394 1

d431 35
d469 12
a480 10
	struct undo_rec *rec;
	LINE *ln;
	int off;

	/*
	 * Let called functions know they are below us (for
	 * example, ldelete don't want to record an undo record
	 * when called by us)
	 */
	undoaction++;
d482 1
d484 6
a489 8
		rec = LIST_FIRST(&curbp->b_undo);
		if (rec == NULL) {
			ewprintf("Nothing to undo!");
			return FALSE;
		}
		LIST_REMOVE(rec, next);
		if (rec->type == BOUNDARY) {
			continue;
a490 5

		find_linep(rec->pos, &ln, &off);
		if (ln == NULL)
			return FALSE;
		
d492 3
a494 1
		 * Move to where this record has to apply
d496 3
a498 15
		curwp->w_dotp = ln;
		curwp->w_doto = off;
		
		switch (rec->type) {
		case INSERT:
			ldelete(rec->region.r_size, KFORW);
			break;
		case DELETE:
			region_put_data(rec->content, rec->region.r_size);
			break;
		case CHANGE:
			forwchar(0, rec->region.r_size);
			lreplace(rec->region.r_size, rec->content, 1);
			break;
		default:
a500 2
		
		free_undo_record(rec);
d502 57
d561 9
a569 3
	undoaction--;
	
	return TRUE;
@


1.7
log
@keep undo records in the BUFFER structures insteda of having a huge list.
@
text
@d1 1
a1 1
/* $OpenBSD: undo.c,v 1.6 2002/02/21 17:36:12 vincent Exp $ */
d377 54
@


1.6
log
@ "rephrase" the loop's condition, gets rid of an ugly operation.
@
text
@d1 1
a1 1
/* $OpenBSD: undo.c,v 1.5 2002/02/21 04:21:05 vincent Exp $ */
a31 1
#define MAX_LIST_RECORDS	32
d37 2
a38 4
static struct undo_list	undo_list;
static int		undo_list_num;
static struct undo_list undo_free;
static int		undo_free_num;
a58 1
static void free_undo_record(struct undo_rec *);
a106 5
	while (undo_list_num >= MAX_LIST_RECORDS) {
		drop_oldest_undo_record();
		undo_list_num--;
	}
	undo_list_num++;
d119 1
a119 1
static void
a158 1
	LIST_INIT(&undo_list);
a187 1
	rec->buf = curbp;
d194 1
a194 1
	LIST_INSERT_HEAD(&undo_list, rec, next);
a207 1
	rec->buf = curbp;
d210 1
a210 1
	LIST_INSERT_HEAD(&undo_list, rec, next);
d231 1
a231 1
	rec = LIST_FIRST(&undo_list);
a233 1
	    (rec->buf == curbp) &&
a249 1
	rec->buf = curbp;
d253 1
a253 1
	LIST_INSERT_HEAD(&undo_list, rec, next);
d284 1
a284 1
	rec = LIST_FIRST(&undo_list);
a287 1
	    (rec->buf == curbp) &&
a327 1
	rec->buf = curbp;
d339 1
a339 1
	LIST_INSERT_HEAD(&undo_list, rec, next);
a362 1
	rec->buf = curbp;
d375 1
a375 1
	LIST_INSERT_HEAD(&undo_list, rec, next);
d395 1
a395 1
		rec = LIST_FIRST(&undo_list);
a399 3
		if (rec->buf != curbp)
			popbuf(rec->buf);
		
@


1.5
log
@ Save undo records for newline insertions.

 That makes mg behave more like GNU emacs.
@
text
@d1 1
a1 1
/* $OpenBSD: undo.c,v 1.4 2002/02/21 04:16:27 vincent Exp $ */
d257 1
d411 1
a411 1
	while (n-- > 0) {
a421 1
			n++;	/* XXX */
d451 2
@


1.4
log
@
 Don't ignore the argument to undo. (makes ^U work)
@
text
@d1 1
a1 1
/* $OpenBSD: undo.c,v 1.3 2002/02/21 03:24:14 vincent Exp $ */
d187 21
@


1.3
log
@ Typo and...

 Duh, newlines aren't even stored in the lines' content, check for
 a 0 length line to detect deleting newlines.
@
text
@d1 1
a1 1
/* $OpenBSD: undo.c,v 1.2 2002/02/20 23:15:03 vincent Exp $ */
d376 1
a376 1
undo(void)
a381 13
 again:
	rec = LIST_FIRST(&undo_list);
	if (rec == NULL) {
		ewprintf("Nothing to undo!");
		return FALSE;
	}
	if (rec->buf != curbp)
		popbuf(rec->buf);

	LIST_REMOVE(rec, next);
	if (rec->type == BOUNDARY)
		goto again;

d383 3
a385 2
	 * Let called functions know they are below us (for example, ldelete
	 * don't want to record an undo record when called by us)
d389 14
a402 9
	find_linep(rec->pos, &ln, &off);
	if (ln == NULL)
		return FALSE;
	
	/*
	 * Move to where this record has to apply
	 */
	curwp->w_dotp = ln;
	curwp->w_doto = off;
d404 26
a429 13
	switch (rec->type) {
	case INSERT:
		ldelete(rec->region.r_size, KFORW);
		break;
	case DELETE:
		region_put_data(rec->content, rec->region.r_size);
		break;
	case CHANGE:
		forwchar(0, rec->region.r_size);
		lreplace(rec->region.r_size, rec->content, 1);
		break;
	default:
		break;
a430 3

	free_undo_record(rec);

@


1.2
log
@ Save newline deletes in their own undo record.

 fixes the ^K^K bugs.
@
text
@d1 1
a1 1
/* $OpenBSD: undo.c,v 1.1 2002/02/20 22:30:54 vincent Exp $ */
d73 1
a73 1
			if (p == curbp->b_linep) {
d268 2
a269 2
	
	if (size == 1 && lgetc(lp, offset) == '\n')
d271 1
@


1.1
log
@ Add undo code to mg.

 needs further hacking.

 ok `whole bunch of people on icb'@@
@
text
@d1 1
a1 1
/* $OpenBSD$ */
d94 1
a94 1
		if ((p = lforw(p)) == curbp->b_linep) {
d258 1
a258 1
	int dist, pos;
d268 3
d276 2
a277 1
	if ((rec != NULL) &&
@

