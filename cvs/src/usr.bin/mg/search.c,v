head	1.44;
access;
symbols
	OPENBSD_6_0:1.44.0.6
	OPENBSD_6_0_BASE:1.44
	OPENBSD_5_9:1.44.0.2
	OPENBSD_5_9_BASE:1.44
	OPENBSD_5_8:1.44.0.4
	OPENBSD_5_8_BASE:1.44
	OPENBSD_5_7:1.43.0.2
	OPENBSD_5_7_BASE:1.43
	OPENBSD_5_6:1.43.0.4
	OPENBSD_5_6_BASE:1.43
	OPENBSD_5_5:1.42.0.6
	OPENBSD_5_5_BASE:1.42
	OPENBSD_5_4:1.42.0.2
	OPENBSD_5_4_BASE:1.42
	OPENBSD_5_3:1.41.0.2
	OPENBSD_5_3_BASE:1.41
	OPENBSD_5_2:1.40.0.2
	OPENBSD_5_2_BASE:1.40
	OPENBSD_5_1_BASE:1.38
	OPENBSD_5_1:1.38.0.6
	OPENBSD_5_0:1.38.0.4
	OPENBSD_5_0_BASE:1.38
	OPENBSD_4_9:1.38.0.2
	OPENBSD_4_9_BASE:1.38
	OPENBSD_4_8:1.37.0.6
	OPENBSD_4_8_BASE:1.37
	OPENBSD_4_7:1.37.0.2
	OPENBSD_4_7_BASE:1.37
	OPENBSD_4_6:1.37.0.4
	OPENBSD_4_6_BASE:1.37
	OPENBSD_4_5:1.36.0.4
	OPENBSD_4_5_BASE:1.36
	OPENBSD_4_4:1.36.0.2
	OPENBSD_4_4_BASE:1.36
	OPENBSD_4_3:1.35.0.6
	OPENBSD_4_3_BASE:1.35
	OPENBSD_4_2:1.35.0.4
	OPENBSD_4_2_BASE:1.35
	OPENBSD_4_1:1.35.0.2
	OPENBSD_4_1_BASE:1.35
	OPENBSD_4_0:1.32.0.2
	OPENBSD_4_0_BASE:1.32
	OPENBSD_3_9:1.28.0.2
	OPENBSD_3_9_BASE:1.28
	OPENBSD_3_8:1.22.0.2
	OPENBSD_3_8_BASE:1.22
	OPENBSD_3_7:1.11.0.4
	OPENBSD_3_7_BASE:1.11
	OPENBSD_3_6:1.11.0.2
	OPENBSD_3_6_BASE:1.11
	OPENBSD_3_5:1.10.0.4
	OPENBSD_3_5_BASE:1.10
	OPENBSD_3_4:1.10.0.2
	OPENBSD_3_4_BASE:1.10
	OPENBSD_3_3:1.9.0.6
	OPENBSD_3_3_BASE:1.9
	OPENBSD_3_2:1.9.0.4
	OPENBSD_3_2_BASE:1.9
	OPENBSD_3_1:1.9.0.2
	OPENBSD_3_1_BASE:1.9
	OPENBSD_3_0:1.7.0.2
	OPENBSD_3_0_BASE:1.7
	OPENBSD_2_9_BASE:1.4
	OPENBSD_2_9:1.4.0.2
	OPENBSD_2_8:1.3.0.2
	OPENBSD_2_8_BASE:1.3
	OPENBSD_2_7:1.2.0.2
	OPENBSD_2_7_BASE:1.2;
locks; strict;
comment	@ * @;


1.44
date	2015.03.19.21.22.15;	author bcallah;	state Exp;
branches;
next	1.43;
commitid	GbEBL4CfPvDkB8hj;

1.43
date	2014.03.20.07.47.29;	author lum;	state Exp;
branches;
next	1.42;

1.42
date	2013.05.31.18.03.45;	author lum;	state Exp;
branches;
next	1.41;

1.41
date	2012.09.07.19.01.56;	author lum;	state Exp;
branches;
next	1.40;

1.40
date	2012.05.25.05.16.59;	author lum;	state Exp;
branches;
next	1.39;

1.39
date	2012.04.12.04.47.59;	author lum;	state Exp;
branches;
next	1.38;

1.38
date	2011.01.21.19.10.13;	author kjell;	state Exp;
branches;
next	1.37;

1.37
date	2009.06.04.02.23.37;	author kjell;	state Exp;
branches;
next	1.36;

1.36
date	2008.06.12.21.58.33;	author kjell;	state Exp;
branches;
next	1.35;

1.35
date	2007.02.13.17.50.26;	author kjell;	state Exp;
branches;
next	1.34;

1.34
date	2006.11.18.22.46.16;	author kjell;	state Exp;
branches;
next	1.33;

1.33
date	2006.11.17.03.24.31;	author kjell;	state Exp;
branches;
next	1.32;

1.32
date	2006.07.25.08.27.09;	author kjell;	state Exp;
branches;
next	1.31;

1.31
date	2006.07.25.08.22.32;	author kjell;	state Exp;
branches;
next	1.30;

1.30
date	2006.06.01.09.00.50;	author kjell;	state Exp;
branches;
next	1.29;

1.29
date	2006.05.28.23.30.16;	author kjell;	state Exp;
branches;
next	1.28;

1.28
date	2006.02.03.13.57.03;	author otto;	state Exp;
branches;
next	1.27;

1.27
date	2005.12.13.06.01.27;	author kjell;	state Exp;
branches;
next	1.26;

1.26
date	2005.12.13.05.40.33;	author kjell;	state Exp;
branches;
next	1.25;

1.25
date	2005.11.18.20.56.53;	author deraadt;	state Exp;
branches;
next	1.24;

1.24
date	2005.11.18.17.35.17;	author kjell;	state Exp;
branches;
next	1.23;

1.23
date	2005.10.11.01.00.41;	author kjell;	state Exp;
branches;
next	1.22;

1.22
date	2005.08.09.00.53.48;	author kjell;	state Exp;
branches;
next	1.21;

1.21
date	2005.06.14.18.14.40;	author kjell;	state Exp;
branches;
next	1.20;

1.20
date	2005.06.14.00.55.45;	author kjell;	state Exp;
branches;
next	1.19;

1.19
date	2005.06.05.05.15.56;	author kjell;	state Exp;
branches;
next	1.18;

1.18
date	2005.06.03.15.16.22;	author cloder;	state Exp;
branches;
next	1.17;

1.17
date	2005.05.27.08.08.18;	author cloder;	state Exp;
branches;
next	1.16;

1.16
date	2005.05.27.07.22.52;	author cloder;	state Exp;
branches;
next	1.15;

1.15
date	2005.05.27.05.55.12;	author cloder;	state Exp;
branches;
next	1.14;

1.14
date	2005.05.25.23.04.39;	author cloder;	state Exp;
branches;
next	1.13;

1.13
date	2005.05.23.20.39.44;	author jason;	state Exp;
branches;
next	1.12;

1.12
date	2005.04.03.02.09.28;	author db;	state Exp;
branches;
next	1.11;

1.11
date	2004.07.22.01.25.25;	author vincent;	state Exp;
branches;
next	1.10;

1.10
date	2003.05.20.03.08.55;	author cloder;	state Exp;
branches;
next	1.9;

1.9
date	2002.02.16.21.27.49;	author millert;	state Exp;
branches;
next	1.8;

1.8
date	2002.02.13.03.03.49;	author vincent;	state Exp;
branches;
next	1.7;

1.7
date	2001.05.24.03.05.26;	author mickey;	state Exp;
branches;
next	1.6;

1.6
date	2001.05.23.22.20.36;	author art;	state Exp;
branches;
next	1.5;

1.5
date	2001.05.03.20.43.12;	author art;	state Exp;
branches;
next	1.4;

1.4
date	2001.01.29.01.58.09;	author niklas;	state Exp;
branches;
next	1.3;

1.3
date	2000.09.01.14.59.09;	author millert;	state Exp;
branches;
next	1.2;

1.2
date	2000.04.13.06.12.17;	author millert;	state Exp;
branches;
next	1.1;

1.1
date	2000.02.25.19.08.50;	author deraadt;	state Exp;
branches;
next	;


desc
@@


1.44
log
@Clean up the includes in mg.
This does the following:
Moves all POSIX headers from sysdef.h into the individual .c files so that
each file now only includes what it needs. All headers are properly sorted.
Moves the remainder of sysdef.h to other files (mostly def.h) and deletes
sysdef.h now that it's no longer contains anything.
Tweak a comment that references sysdef.h so that it no longer does that.
ok florian@@
@
text
@/*	$OpenBSD: search.c,v 1.43 2014/03/20 07:47:29 lum Exp $	*/

/* This file is in the public domain. */

/*
 *		Search commands.
 * The functions in this file implement the search commands (both plain and
 * incremental searches are supported) and the query-replace command.
 *
 * The plain old search code is part of the original MicroEMACS "distribution".
 * The incremental search code and the query-replace code is by Rich Ellison.
 */

#include <sys/queue.h>
#include <ctype.h>
#include <signal.h>
#include <stdio.h>
#include <string.h>

#include "def.h"
#include "macro.h"

#define SRCH_BEGIN	(0)	/* Search sub-codes.	 */
#define SRCH_FORW	(-1)
#define SRCH_BACK	(-2)
#define SRCH_NOPR	(-3)
#define SRCH_ACCM	(-4)
#define SRCH_MARK	(-5)

struct srchcom {
	int		 s_code;
	struct line	*s_dotp;
	int		 s_doto;
	int		 s_dotline;
};

static int	isearch(int);
static void	is_cpush(int);
static void	is_lpush(void);
static void	is_pop(void);
static int	is_peek(void);
static void	is_undo(int *, int *);
static int	is_find(int);
static void	is_prompt(int, int, int);
static void	is_dspl(char *, int);
static int	eq(int, int, int);

static struct srchcom	cmds[NSRCH];
static int	cip;

int		srch_lastdir = SRCH_NOPR;	/* Last search flags.	 */

/*
 * Search forward.  Get a search string from the user, and search for it
 * starting at ".".  If found, "." gets moved to just after the matched
 * characters, and display does all the hard stuff.  If not found, it just
 * prints a message.
 */
/* ARGSUSED */
int
forwsearch(int f, int n)
{
	int	s;

	if ((s = readpattern("Search")) != TRUE)
		return (s);
	if (forwsrch() == FALSE) {
		dobeep();
		ewprintf("Search failed: \"%s\"", pat);
		return (FALSE);
	}
	srch_lastdir = SRCH_FORW;
	return (TRUE);
}

/*
 * Reverse search.  Get a search string from the user, and search, starting
 * at "." and proceeding toward the front of the buffer.  If found "." is
 * left pointing at the first character of the pattern [the last character
 * that was matched].
 */
/* ARGSUSED */
int
backsearch(int f, int n)
{
	int	s;

	if ((s = readpattern("Search backward")) != TRUE)
		return (s);
	if (backsrch() == FALSE) {
		dobeep();
		ewprintf("Search failed: \"%s\"", pat);
		return (FALSE);
	}
	srch_lastdir = SRCH_BACK;
	return (TRUE);
}

/*
 * Search again, using the same search string and direction as the last
 * search command. The direction has been saved in "srch_lastdir", so you
 * know which way to go.
 */
/* ARGSUSED */
int
searchagain(int f, int n)
{
	if (srch_lastdir == SRCH_FORW) {
		if (forwsrch() == FALSE) {
			dobeep();
			ewprintf("Search failed: \"%s\"", pat);
			return (FALSE);
		}
		return (TRUE);
	}
	if (srch_lastdir == SRCH_BACK) {
		if (backsrch() == FALSE) {
			dobeep();
			ewprintf("Search failed: \"%s\"", pat);
			return (FALSE);
		}
		return (TRUE);
	}
	dobeep();
	ewprintf("No last search");
	return (FALSE);
}

/*
 * Use incremental searching, initially in the forward direction.
 * isearch ignores any explicit arguments.
 */
/* ARGSUSED */
int
forwisearch(int f, int n)
{
	if (macrodef || inmacro)
		/* We can't isearch in macro. Use search instead */
		return (forwsearch(f,n));
	else 
		return (isearch(SRCH_FORW));
}

/*
 * Use incremental searching, initially in the reverse direction.
 * isearch ignores any explicit arguments.
 */
/* ARGSUSED */
int
backisearch(int f, int n)
{
	if (macrodef || inmacro)
		/* We can't isearch in macro. Use search instead */
		return (backsearch(f,n));
	else 
		return (isearch(SRCH_BACK));
}

/*
 * Incremental Search.
 *	dir is used as the initial direction to search.
 *	^S	switch direction to forward
 *	^R	switch direction to reverse
 *	^Q	quote next character (allows searching for ^N etc.)
 *	<ESC>	exit from Isearch
 *	<DEL>	undoes last character typed. (tricky job to do this correctly).
 *	other ^ exit search, don't set mark
 *	else	accumulate into search string
 */
static int
isearch(int dir)
{
	struct line	*clp;		/* Saved line pointer */
	int		 c;
	int		 cbo;		/* Saved offset */
	int		 success;
	int		 pptr;
	int		 firstc;
	int		 xcase;
	int		 i;
	char		 opat[NPAT];
	int		 cdotline;	/* Saved line number */

	if (macrodef) {
		dobeep();
		ewprintf("Can't isearch in macro");
		return (FALSE);
	}
	for (cip = 0; cip < NSRCH; cip++)
		cmds[cip].s_code = SRCH_NOPR;

	(void)strlcpy(opat, pat, sizeof(opat));
	cip = 0;
	pptr = -1;
	clp = curwp->w_dotp;
	cbo = curwp->w_doto;
	cdotline = curwp->w_dotline;
	is_lpush();
	is_cpush(SRCH_BEGIN);
	success = TRUE;
	is_prompt(dir, TRUE, success);

	for (;;) {
		update(CMODE);

		switch (c = getkey(FALSE)) {
		case CCHR('['):
			/*
			 * If new characters come in the next 300 msec,
			 * we can assume that they belong to a longer
			 * escaped sequence so we should ungetkey the
			 * ESC to avoid writing out garbage.
			 */
			if (ttwait(300) == FALSE)
				ungetkey(c);
			srch_lastdir = dir;
			curwp->w_markp = clp;
			curwp->w_marko = cbo;
			curwp->w_markline = cdotline;
			ewprintf("Mark set");
			return (TRUE);
		case CCHR('G'):
			if (success != TRUE) {
				while (is_peek() == SRCH_ACCM)
					is_undo(&pptr, &dir);
				success = TRUE;
				is_prompt(dir, pptr < 0, success);
				break;
			}
			curwp->w_dotp = clp;
			curwp->w_doto = cbo;
			curwp->w_dotline = cdotline;
			curwp->w_rflag |= WFMOVE;
			srch_lastdir = dir;
			(void)ctrlg(FFRAND, 0);
			(void)strlcpy(pat, opat, sizeof(pat));
			return (ABORT);
		case CCHR('S'):
			if (dir == SRCH_BACK) {
				dir = SRCH_FORW;
				is_lpush();
				is_cpush(SRCH_FORW);
				success = TRUE;
			}
			if (success == FALSE && dir == SRCH_FORW) {
				/* wrap the search to beginning */
				curwp->w_dotp = bfirstlp(curbp);
				curwp->w_doto = 0;
				curwp->w_dotline = 1;
				if (is_find(dir) != FALSE) {
					is_cpush(SRCH_MARK);
					success = TRUE;
				}
				ewprintf("Overwrapped I-search: %s", pat);
				break;
			}
			is_lpush();
			pptr = strlen(pat);
			if (forwchar(FFRAND, 1) == FALSE) {
                                dobeep();
                                success = FALSE;
                                ewprintf("Failed I-search: %s", pat);
			} else {
				if (is_find(SRCH_FORW) != FALSE)
					is_cpush(SRCH_MARK);
				else {
					(void)backchar(FFRAND, 1);
					dobeep();
					success = FALSE;
					ewprintf("Failed I-search: %s", pat);
				}
			}
			is_prompt(dir, pptr < 0, success);
			break;
		case CCHR('R'):
			if (dir == SRCH_FORW) {
				dir = SRCH_BACK;
				is_lpush();
				is_cpush(SRCH_BACK);
				success = TRUE;
			}
			if (success == FALSE && dir == SRCH_BACK) {
				/* wrap the search to end */
				curwp->w_dotp = blastlp(curbp);
				curwp->w_doto = llength(curwp->w_dotp);
				curwp->w_dotline = curwp->w_bufp->b_lines;
				if (is_find(dir) != FALSE) {
					is_cpush(SRCH_MARK);
					success = TRUE;
				}
				ewprintf("Overwrapped I-search: %s", pat);
				break;
			}
			is_lpush();
			pptr = strlen(pat);
                        if (backchar(FFRAND, 1) == FALSE) {
                                dobeep();
                                success = FALSE;
                        } else {
				if (is_find(SRCH_BACK) != FALSE)
					is_cpush(SRCH_MARK);
				else {
					(void)forwchar(FFRAND, 1);
					dobeep();
					success = FALSE;
				}
			}
			is_prompt(dir, pptr < 0, success);
			break;
		case CCHR('W'):
			/* add the rest of the current word to the pattern */
			clp = curwp->w_dotp;
			cbo = curwp->w_doto;
			firstc = 1;
			if (pptr == -1)
				pptr = 0;
			if (dir == SRCH_BACK) {
				/* when isearching backwards, cbo is the start of the pattern */
				cbo += pptr;
			}

			/* if the search is case insensitive, add to pattern using lowercase */
			xcase = 0;
			for (i = 0; pat[i]; i++)
				if (ISUPPER(CHARMASK(pat[i])))
					xcase = 1;

			while (cbo < llength(clp)) {
				c = lgetc(clp, cbo++);
				if ((!firstc && !isalnum(c)))
					break;

				if (pptr == NPAT - 1) {
					dobeep();
					break;
				}
				firstc = 0;
				if (!xcase && ISUPPER(c))
					c = TOLOWER(c);

				pat[pptr++] = c;
				pat[pptr] = '\0';
				/* cursor only moves when isearching forwards */
				if (dir == SRCH_FORW) {
					curwp->w_doto = cbo;
					curwp->w_rflag |= WFMOVE;
					update(CMODE);
				}
			}
			is_prompt(dir, pptr < 0, success);
			break;
		case CCHR('H'):
		case CCHR('?'):
			is_undo(&pptr, &dir);
			if (is_peek() != SRCH_ACCM)
				success = TRUE;
			is_prompt(dir, pptr < 0, success);
			break;
		case CCHR('\\'):
		case CCHR('Q'):
			c = (char)getkey(FALSE);
			goto addchar;
		case CCHR('M'):
			c = CCHR('J');
			goto addchar;
		default:
			if (ISCTRL(c)) {
				ungetkey(c);
				curwp->w_markp = clp;
				curwp->w_marko = cbo;
				curwp->w_markline = cdotline;
				ewprintf("Mark set");
				curwp->w_rflag |= WFMOVE;
				return (TRUE);
			}
			/* FALLTHRU */
		case CCHR('I'):
		case CCHR('J'):
	addchar:
			if (pptr == -1)
				pptr = 0;
			if (pptr == 0)
				success = TRUE;
			if (pptr == NPAT - 1)
				dobeep();
			else {
				pat[pptr++] = c;
				pat[pptr] = '\0';
			}
			is_lpush();
			if (success != FALSE) {
				if (is_find(dir) != FALSE)
					is_cpush(c);
				else {
					success = FALSE;
					dobeep();
					is_cpush(SRCH_ACCM);
				}
			} else
				is_cpush(SRCH_ACCM);
			is_prompt(dir, FALSE, success);
		}
	}
	/* NOTREACHED */
}

static void
is_cpush(int cmd)
{
	if (++cip >= NSRCH)
		cip = 0;
	cmds[cip].s_code = cmd;
}

static void
is_lpush(void)
{
	int	ctp;

	ctp = cip + 1;
	if (ctp >= NSRCH)
		ctp = 0;
	cmds[ctp].s_code = SRCH_NOPR;
	cmds[ctp].s_doto = curwp->w_doto;
	cmds[ctp].s_dotp = curwp->w_dotp;
	cmds[ctp].s_dotline = curwp->w_dotline;
}

static void
is_pop(void)
{
	if (cmds[cip].s_code != SRCH_NOPR) {
		curwp->w_doto = cmds[cip].s_doto;
		curwp->w_dotp = cmds[cip].s_dotp;
		curwp->w_dotline = cmds[cip].s_dotline;
		curwp->w_rflag |= WFMOVE;
		cmds[cip].s_code = SRCH_NOPR;
	}
	if (--cip <= 0)
		cip = NSRCH - 1;
}

static int
is_peek(void)
{
	return (cmds[cip].s_code);
}

/* this used to always return TRUE (the return value was checked) */
static void
is_undo(int *pptr, int *dir)
{
	int	redo = FALSE;

	switch (cmds[cip].s_code) {
	case SRCH_BEGIN:
	case SRCH_NOPR:
		*pptr = -1;
		break;
	case SRCH_MARK:
		break;
	case SRCH_FORW:
		*dir = SRCH_BACK;
		redo = TRUE;
		break;
	case SRCH_BACK:
		*dir = SRCH_FORW;
		redo = TRUE;
		break;
	case SRCH_ACCM:
	default:
		*pptr -= 1;
		if (*pptr < 0)
			*pptr = 0;
		pat[*pptr] = '\0';
		break;
	}
	is_pop();
	if (redo)
		is_undo(pptr, dir);
}

static int
is_find(int dir)
{
	int	 plen, odoto, odotline;
	struct line	*odotp;

	odoto = curwp->w_doto;
	odotp = curwp->w_dotp;
	odotline = curwp->w_dotline;
	plen = strlen(pat);
	if (plen != 0) {
		if (dir == SRCH_FORW) {
			(void)backchar(FFARG | FFRAND, plen);
			if (forwsrch() == FALSE) {
				curwp->w_doto = odoto;
				curwp->w_dotp = odotp;
				curwp->w_dotline = odotline;
				return (FALSE);
			}
			return (TRUE);
		}
		if (dir == SRCH_BACK) {
			(void)forwchar(FFARG | FFRAND, plen);
			if (backsrch() == FALSE) {
				curwp->w_doto = odoto;
				curwp->w_dotp = odotp;
				curwp->w_dotline = odotline;
				return (FALSE);
			}
			return (TRUE);
		}
		dobeep();
		ewprintf("bad call to is_find");
		return (FALSE);
	}
	return (FALSE);
}

/*
 * If called with "dir" not one of SRCH_FORW or SRCH_BACK, this routine used
 * to print an error message.  It also used to return TRUE or FALSE, depending
 * on if it liked the "dir".  However, none of the callers looked at the
 * status, so I just made the checking vanish.
 */
static void
is_prompt(int dir, int flag, int success)
{
	if (dir == SRCH_FORW) {
		if (success != FALSE)
			is_dspl("I-search", flag);
		else
			is_dspl("Failing I-search", flag);
	} else if (dir == SRCH_BACK) {
		if (success != FALSE)
			is_dspl("I-search backward", flag);
		else
			is_dspl("Failing I-search backward", flag);
	} else
		ewprintf("Broken call to is_prompt");
}

/*
 * Prompt writing routine for the incremental search.  The "prompt" is just
 * a string. The "flag" determines whether pat should be printed.
 */
static void
is_dspl(char *prompt, int flag)
{
	if (flag != FALSE)
		ewprintf("%s: ", prompt);
	else
		ewprintf("%s: %s", prompt, pat);
}

/*
 * Query Replace.
 *	Replace strings selectively.  Does a search and replace operation.
 */
/* ARGSUSED */
int
queryrepl(int f, int n)
{
	int	s;
	int	rcnt = 0;		/* replacements made so far	*/
	int	plen;			/* length of found string	*/
	char	news[NPAT], *rep;	/* replacement string		*/

	if (macrodef) {
		dobeep();
		ewprintf("Can't query replace in macro");
		return (FALSE);
	}

	if ((s = readpattern("Query replace")) != TRUE)
		return (s);
	if ((rep = eread("Query replace %s with: ", news, NPAT,
	    EFNUL | EFNEW | EFCR, pat)) == NULL)
		return (ABORT);
	else if (rep[0] == '\0')
		news[0] = '\0';
	ewprintf("Query replacing %s with %s:", pat, news);
	plen = strlen(pat);

	/*
	 * Search forward repeatedly, checking each time whether to insert
	 * or not.  The "!" case makes the check always true, so it gets put
	 * into a tighter loop for efficiency.
	 */
	while (forwsrch() == TRUE) {
retry:
		update(CMODE);
		switch (getkey(FALSE)) {
		case 'y':
		case ' ':
			if (lreplace((RSIZE)plen, news) == FALSE)
				return (FALSE);
			rcnt++;
			break;
		case '.':
			if (lreplace((RSIZE)plen, news) == FALSE)
				return (FALSE);
			rcnt++;
			goto stopsearch;
		/* ^G, CR or ESC */
		case CCHR('G'):
			(void)ctrlg(FFRAND, 0);
			goto stopsearch;
		case CCHR('['):
		case CCHR('M'):
			goto stopsearch;
		case '!':
			do {
				if (lreplace((RSIZE)plen, news) == FALSE)
					return (FALSE);
				rcnt++;
			} while (forwsrch() == TRUE);
			goto stopsearch;
		case 'n':
		case CCHR('H'):
		/* To not replace */
		case CCHR('?'):
			break;
		default:
			ewprintf("y/n or <SP>/<DEL>: replace/don't, [.] repl-end, [!] repl-rest, <CR>/<ESC> quit");
			goto retry;
		}
	}
stopsearch:
	curwp->w_rflag |= WFFULL;
	update(CMODE);
	if (rcnt == 1)
		ewprintf("Replaced 1 occurrence");
	else
		ewprintf("Replaced %d occurrences", rcnt);
	return (TRUE);
}

/*
 * Replace string globally without individual prompting.
 */
/* ARGSUSED */
int
replstr(int f, int n)
{
	char	news[NPAT];
	int	s, plen, rcnt = 0;
	char	*r;

	if ((s = readpattern("Replace string")) != TRUE)
		return s;

	r = eread("Replace string %s with: ", news, NPAT,
	    EFNUL | EFNEW | EFCR,  pat);
	if (r == NULL)
		 return (ABORT);

	plen = strlen(pat);
	while (forwsrch() == TRUE) {
		update(CMODE);
		if (lreplace((RSIZE)plen, news) == FALSE)
			return (FALSE);

		rcnt++;
	}

	curwp->w_rflag |= WFFULL;
	update(CMODE);

	if (rcnt == 1)
		ewprintf("Replaced 1 occurrence");
	else
		ewprintf("Replaced %d occurrences", rcnt);

	return (TRUE);
}

/*
 * This routine does the real work of a forward search.  The pattern is sitting
 * in the external variable "pat".  If found, dot is updated, the window system
 * is notified of the change, and TRUE is returned.  If the string isn't found,
 * FALSE is returned.
 */
int
forwsrch(void)
{
	struct line	*clp, *tlp;
	int	 cbo, tbo, c, i, xcase = 0;
	char	*pp;
	int	 nline;

	clp = curwp->w_dotp;
	cbo = curwp->w_doto;
	nline = curwp->w_dotline;
	for (i = 0; pat[i]; i++)
		if (ISUPPER(CHARMASK(pat[i])))
			xcase = 1;
	for (;;) {
		if (cbo == llength(clp)) {
			if ((clp = lforw(clp)) == curbp->b_headp)
				break;
			nline++;
			cbo = 0;
			c = CCHR('J');
		} else
			c = lgetc(clp, cbo++);
		if (eq(c, pat[0], xcase) != FALSE) {
			tlp = clp;
			tbo = cbo;
			pp = &pat[1];
			while (*pp != 0) {
				if (tbo == llength(tlp)) {
					tlp = lforw(tlp);
					if (tlp == curbp->b_headp)
						goto fail;
					tbo = 0;
					c = CCHR('J');
					if (eq(c, *pp++, xcase) == FALSE)
						goto fail;
					nline++;
				} else {
					c = lgetc(tlp, tbo++);
					if (eq(c, *pp++, xcase) == FALSE)
						goto fail;
				}
			}
			curwp->w_dotp = tlp;
			curwp->w_doto = tbo;
			curwp->w_dotline = nline;
			curwp->w_rflag |= WFMOVE;
			return (TRUE);
		}
fail:		;
	}
	return (FALSE);
}

/*
 * This routine does the real work of a backward search.  The pattern is
 * sitting in the external variable "pat".  If found, dot is updated, the
 * window system is notified of the change, and TRUE is returned.  If the
 * string isn't found, FALSE is returned.
 */
int
backsrch(void)
{
	struct line	*clp, *tlp;
	int	 cbo, tbo, c, i, xcase = 0;
	char	*epp, *pp;
	int	 nline, pline;

	for (epp = &pat[0]; epp[1] != 0; ++epp);
	clp = curwp->w_dotp;
	cbo = curwp->w_doto;
	nline = curwp->w_dotline;
	for (i = 0; pat[i]; i++)
		if (ISUPPER(CHARMASK(pat[i])))
			xcase = 1;
	for (;;) {
		if (cbo == 0) {
			clp = lback(clp);
			if (clp == curbp->b_headp)
				return (FALSE);
			nline--;
			cbo = llength(clp) + 1;
		}
		if (--cbo == llength(clp))
			c = CCHR('J');
		else
			c = lgetc(clp, cbo);
		if (eq(c, *epp, xcase) != FALSE) {
			tlp = clp;
			tbo = cbo;
			pp = epp;
			pline = nline;
			while (pp != &pat[0]) {
				if (tbo == 0) {
					tlp = lback(tlp);
					if (tlp == curbp->b_headp)
						goto fail;
					nline--;
					tbo = llength(tlp) + 1;
				}
				if (--tbo == llength(tlp))
					c = CCHR('J');
				else
					c = lgetc(tlp, tbo);
				if (eq(c, *--pp, xcase) == FALSE) {
					nline = pline;
					goto fail;
				}
			}
			curwp->w_dotp = tlp;
			curwp->w_doto = tbo;
			curwp->w_dotline = nline;
			curwp->w_rflag |= WFMOVE;
			return (TRUE);
		}
fail:		;
	}
	/* NOTREACHED */
}

/*
 * Compare two characters.  The "bc" comes from the buffer.  It has its case
 * folded out. The "pc" is from the pattern.
 */
static int
eq(int bc, int pc, int xcase)
{
	bc = CHARMASK(bc);
	pc = CHARMASK(pc);
	if (bc == pc)
		return (TRUE);
	if (xcase)
		return (FALSE);
	if (ISUPPER(bc))
		return (TOLOWER(bc) == pc);
	if (ISUPPER(pc))
		return (bc == TOLOWER(pc));
	return (FALSE);
}

/*
 * Read a pattern.  Stash it in the external variable "pat".  The "pat" is not
 * updated if the user types in an empty line.  If the user typed an empty
 * line, and there is no old pattern, it is an error.  Display the old pattern,
 * in the style of Jeff Lomicka.  There is some do-it-yourself control
 * expansion.
 */
int
readpattern(char *prompt)
{
	char	tpat[NPAT], *rep;
	int	retval;

	if (pat[0] == '\0')
		rep = eread("%s: ", tpat, NPAT, EFNEW | EFCR, prompt);
	else
		rep = eread("%s: (default %s) ", tpat, NPAT,
		    EFNUL | EFNEW | EFCR, prompt, pat);

	/* specified */
	if (rep == NULL) {
		retval = ABORT;
	} else if (rep[0] != '\0') {
		(void)strlcpy(pat, tpat, sizeof(pat));
		retval = TRUE;
	} else if (pat[0] != '\0') {
		retval = TRUE;
	} else
		retval = FALSE;
	return (retval);
}
@


1.43
log
@Add some missing dobeeps.
ok florian@@
@
text
@d1 1
a1 1
/*	$OpenBSD: search.c,v 1.42 2013/05/31 18:03:45 lum Exp $	*/
d14 1
a14 2
#include "def.h"

d16 3
d20 1
@


1.42
log
@Make the system bell toggleable via 'audible-bell', and if switched
off, make available an alternative 'visible-bell'.

ok florian@@ jasper@@ Feedback Sunil Nimmagadda.
@
text
@d1 1
a1 1
/*	$OpenBSD: search.c,v 1.41 2012/09/07 19:01:56 lum Exp $	*/
d65 1
d88 1
d107 1
d115 1
d121 1
d182 1
d511 1
d568 1
@


1.41
log
@Make C-r not screw up the line counter if the pattern ends up not
matching.

More goodness from Florian Obser. (and a tweak by me)
@
text
@d1 1
a1 1
/*	$OpenBSD: search.c,v 1.40 2012/05/25 05:16:59 lum Exp $	*/
d195 1
a195 1
		update();
d251 1
a251 1
                                ttbeep();
d259 1
a259 1
					ttbeep();
d288 1
a288 1
                                ttbeep();
d295 1
a295 1
					ttbeep();
d325 1
a325 1
					ttbeep();
d338 1
a338 1
					update();
d376 1
a376 1
				ttbeep();
d387 1
a387 1
					ttbeep();
d582 1
a582 1
		update();
d621 1
a621 1
	update();
d650 1
a650 1
		update();
d658 1
a658 1
	update();
@


1.40
log
@Allow searching (C-s or C-r) to wrap around the ends of a buffer.
Even if the search string is located at the beginning or end of a
buffer.
@
text
@d1 1
a1 1
/*	$OpenBSD: search.c,v 1.39 2012/04/12 04:47:59 lum Exp $	*/
d740 1
a740 1
	int	 nline;
d765 1
d778 2
a779 1
				if (eq(c, *--pp, xcase) == FALSE)
d781 1
@


1.39
log
@Remove the conditional directives NO_MACRO and NO_STARTUP.
They have not compiled for numerous years.
ok kjell@@ millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: search.c,v 1.38 2011/01/21 19:10:13 kjell Exp $	*/
a247 1

d250 13
a262 8
			(void)forwchar(FFRAND, 1);
			if (is_find(SRCH_FORW) != FALSE)
				is_cpush(SRCH_MARK);
			else {
				(void)backchar(FFRAND, 1);
				ttbeep();
				success = FALSE;
				ewprintf("Failed I-search: %s", pat);
d287 11
a297 7
			(void)backchar(FFRAND, 1);
			if (is_find(SRCH_BACK) != FALSE)
				is_cpush(SRCH_MARK);
			else {
				(void)forwchar(FFRAND, 1);
				ttbeep();
				success = FALSE;
@


1.38
log
@It volates style(9), but in mg, #include"def.h" goes first. 'twas the way it was built. no binary change here. confirmed by lum@@, tested by Henri Kemppainen
@
text
@d1 1
a1 1
/*	$OpenBSD: search.c,v 1.37 2009/06/04 02:23:37 kjell Exp $	*/
a17 1
#ifndef NO_MACRO
a18 1
#endif /* !NO_MACRO */
a175 1
#ifndef NO_MACRO
a179 1
#endif /* !NO_MACRO */
a551 1
#ifndef NO_MACRO
a555 1
#endif /* !NO_MACRO */
@


1.37
log
@Rename w_flag to w_rflag. This is not a general purpose
flag: it is for redisplay options only. I need an additional all-purpose
flag, so renaming removes the desire to wrongly overload the existing one.

Turdshine. No functional chage.
@
text
@d1 1
a1 1
/*	$OpenBSD: search.c,v 1.36 2008/06/12 21:58:33 kjell Exp $	*/
d15 1
@


1.36
log
@incremental search isn't allowed in macros, so if your fingers
automatically go there during a macro def, the macro recording
is CANCELED. This sucks rocks.

This fixes the incremental searches to
automagically invoke the non-incremental varieties during
macro recording and playback.

ok art
@
text
@d1 1
a1 1
/*	$OpenBSD: search.c,v 1.35 2007/02/13 17:50:26 kjell Exp $	*/
d227 1
a227 1
			curwp->w_flag |= WFMOVE;
d332 1
a332 1
					curwp->w_flag |= WFMOVE;
d359 1
a359 1
				curwp->w_flag |= WFMOVE;
d422 1
a422 1
		curwp->w_flag |= WFMOVE;
d617 1
a617 1
	curwp->w_flag |= WFFULL;
d654 1
a654 1
	curwp->w_flag |= WFFULL;
d717 1
a717 1
			curwp->w_flag |= WFMOVE;
d780 1
a780 1
			curwp->w_flag |= WFMOVE;
@


1.35
log
@Fix a problem with wrapped incremental searches.
Basically, on wrap, the line pointer and offset would get out of sync, leading
to incorrect line numbers or a segfault.
Deanna Phillips did all the work of spotting it tracking it down to the
right function. Thanks!
While here, add emacs-like messages for wrapped and failed incremental
searches. Tested by Deanna.
@
text
@d1 1
a1 1
/*	$OpenBSD: search.c,v 1.34 2006/11/18 22:46:16 kjell Exp $	*/
d130 5
a134 1
	return (isearch(SRCH_FORW));
d145 5
a149 1
	return (isearch(SRCH_BACK));
@


1.34
log
@1. Fix line numbering/mark line bug in isearch.
To reproduce, set mark, move, isearch, then swap mark and point.
2. store mark in save structure (to reproduce search on a pattern twice,
 then backspace to back up the search stack)
Both from Peter De Wachter (debian bug#391827) Thanks!
@
text
@d1 1
a1 1
/*	$OpenBSD: search.c,v 1.33 2006/11/17 03:24:31 kjell Exp $	*/
d158 10
a167 11
	struct line	*clp;

	int	 c;
	int	 cbo;
	int	 success;
	int	 pptr;
	int	 firstc;
	int	 xcase;
	int	 i;
	char	 opat[NPAT];
	int	 cdotline;
a223 1
		case CCHR(']'):
d233 1
a233 2
				clp = bfirstlp(curbp);
				curwp->w_dotp = clp;
d240 1
d253 1
d266 2
a267 4
				clp = blastlp(curbp);
				curwp->w_dotp = clp;
				curwp->w_doto =
				    llength(curwp->w_dotp);
d273 1
@


1.33
log
@fix a segfault on isearch. Using ^W to add more than NPAT chars to the
search pattern had an off-by-one. Fix this and one other irritating behavior
with long search patterns.
Noted (similar diff proposed) and tested by deanna phillips
@
text
@d1 1
a1 1
/*	$OpenBSD: search.c,v 1.32 2006/07/25 08:27:09 kjell Exp $	*/
d29 1
a29 1
	int	 s_code;
d31 2
a32 1
	int	 s_doto;
d206 1
d351 1
d406 1
d415 1
d466 1
a466 1
	int	 plen, odoto;
d471 1
d479 1
d489 1
@


1.32
log
@Add bfirstlp(), blastlp() macros, returning the first and last lines
of a buffer respectively. Removes an ugly construction than necessitated
"go to first line"-type comments throughout the code.
No binary change
@
text
@d1 1
a1 1
/*	$OpenBSD: search.c,v 1.31 2006/07/25 08:22:32 kjell Exp $	*/
d308 1
a308 1
				if ((!firstc && !isalnum(c)) || pptr == NPAT)
d311 4
d361 5
a365 4
			pat[pptr++] = c;
			if (pptr == NPAT) {
				ewprintf("Pattern too long");
				return (FALSE);
a366 1
			pat[pptr] = '\0';
@


1.31
log
@Rename the header line of a buffer to b_headp, from the remarkably
unintuitive b_linep. No binary change.
@
text
@d1 1
a1 1
/*	$OpenBSD: search.c,v 1.30 2006/06/01 09:00:50 kjell Exp $	*/
d233 1
a233 1
				clp = lforw(curbp->b_headp);
d265 1
a265 1
				clp = lback(curbp->b_headp);
@


1.30
log
@Display line number in the mg statusbar.  Yes, it seems like a fugly
way to do it, but all the clever and pretty ways utterly failed.
Basic use seems fine. We'll turdshine the special cases later.

If it bothers you, use M-x line-number-mode, or put same in your ~/.mg
file to disable.

ok cloder, jason
@
text
@d1 1
a1 1
/*	$OpenBSD: search.c,v 1.29 2006/05/28 23:30:16 kjell Exp $	*/
d233 1
a233 1
				clp = lforw(curbp->b_linep);
d265 1
a265 1
				clp = lback(curbp->b_linep);
d669 1
a669 1
			if ((clp = lforw(clp)) == curbp->b_linep)
d683 1
a683 1
					if (tlp == curbp->b_linep)
d731 1
a731 1
			if (clp == curbp->b_linep)
d747 1
a747 1
					if (tlp == curbp->b_linep)
@


1.29
log
@Make Window Flags more mnemonic (and less dumb); i.e.
WFHARD -> WFFULL (Redraw full window)
WFFORCE -> WFFRAME (Reframe window).
No binary change
@
text
@d1 1
a1 1
/*	$OpenBSD: search.c,v 1.28 2006/02/03 13:57:03 otto Exp $	*/
d167 1
d183 1
d217 1
d236 1
d269 1
d659 1
d663 1
d671 1
d687 4
a690 1
				} else
d692 3
a694 2
				if (eq(c, *pp++, xcase) == FALSE)
					goto fail;
d698 1
d719 1
d724 1
d733 1
d749 1
d761 1
@


1.28
log
@Fix off by one ocurring if ^W immediate follows ^S; testing marc@@;
ok kjell@@; PR 4991
@
text
@d1 1
a1 1
/*	$OpenBSD: search.c,v 1.27 2005/12/13 06:01:27 kjell Exp $	*/
d594 1
a594 1
	curwp->w_flag |= WFHARD;
d631 1
a631 1
	curwp->w_flag |= WFHARD;
@


1.27
log
@More name-clash delinting
@
text
@d1 1
a1 1
/*	$OpenBSD: search.c,v 1.26 2005/12/13 05:40:33 kjell Exp $	*/
d288 2
@


1.26
log
@do some silly de-linting
@
text
@d1 1
a1 1
/*	$OpenBSD: search.c,v 1.25 2005/11/18 20:56:53 deraadt Exp $	*/
d341 2
a342 1
			}	/* FALLTHRU */
d423 1
d570 1
@


1.25
log
@greedy use of typedef struct was making code harder to read; ok kjell cloder
@
text
@d1 1
a1 1
/*	$OpenBSD: search.c,v 1.24 2005/11/18 17:35:17 kjell Exp $	*/
d341 1
a341 1
			}	/* and continue */
@


1.24
log
@Casefold on replace was killed ages ago (it was wrong). Remove a
leftover (unused) variable.
@
text
@d1 1
a1 1
/*	$OpenBSD: search.c,v 1.23 2005/10/11 01:00:41 kjell Exp $	*/
d28 1
a28 1
typedef struct {
d30 1
a30 1
	LINE	*s_dotp;
d32 1
a32 1
} SRCHCOM;
d45 1
a45 1
static SRCHCOM	cmds[NSRCH];
d157 1
a157 1
	LINE	*clp;
d449 1
a449 1
	LINE	*odotp;
d646 1
a646 1
	LINE	*clp, *tlp;
d698 1
a698 1
	LINE	*clp, *tlp;
@


1.23
log
@Allow the more traditional emacs keybindings during search/replace, too
(i.e. 'y' to accept, 'n' to skip, and <CR> to end)
ok deraadt@@, cloder@@
@
text
@d1 1
a1 1
/*	$OpenBSD: search.c,v 1.22 2005/08/09 00:53:48 kjell Exp $	*/
d556 1
a556 1
			if (lreplace((RSIZE)plen, news, f) == FALSE)
d561 1
a561 1
			if (lreplace((RSIZE)plen, news, f) == FALSE)
d573 1
a573 1
				if (lreplace((RSIZE)plen, news, f) == FALSE)
d620 1
a620 1
		if (lreplace((RSIZE)plen, news, f) == FALSE)
@


1.22
log
@Clean up eread handling in mg. (basically, fallout from the 'enter often
means abort' behaviour added during the hackathon). Eliminates
redundant ereply function, fixes miscellaneous cores when aborting,
and move a number of assumed pathnames into the prompt text, since
they are used there anyway. All changes consistent with emacs behavior

ok beck@@ many, many moons ago.
@
text
@d1 1
a1 1
/*	$OpenBSD: search.c,v 1.21 2005/06/14 18:14:40 kjell Exp $	*/
d554 1
d565 1
a565 1
		/* ^G or ESC */
d569 1
d578 1
d584 1
a584 1
			ewprintf("<SP> replace, [.] rep-end, <DEL> don't, [!] repl rest <ESC> quit");
d591 2
a592 4
	if (rcnt == 0)
		ewprintf("(No replacements done)");
	else if (rcnt == 1)
		ewprintf("(1 replacement done)");
d594 1
a594 1
		ewprintf("(%d replacements done)", rcnt);
d630 1
a630 1
		ewprintf("(1 replacement done)");
d632 1
a632 1
		ewprintf("(%d replacements done)", rcnt);
@


1.21
log
@Add explicit public domain notices to all public domain files.
ok millert@@, deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: search.c,v 1.20 2005/06/14 00:55:45 kjell Exp $	*/
d780 1
a780 1
		rep = ereply("%s: ", tpat, NPAT, prompt);
d788 2
a789 2
	} else if (*rep != '\0') {
		(void) strlcpy(pat, tpat, sizeof(pat));
@


1.20
log
@Three more ereply that should be ereads. This fixes henning's "replace
with null string is busted" observation.

ok henning@@, cloder@@
@
text
@d1 3
a3 1
/*	$OpenBSD: search.c,v 1.19 2005/06/05 05:15:56 kjell Exp $	*/
@


1.19
log
@if functions permits null reply from minibuffer, use eread (with
EFNUL), not ereply.
ok cloder
@
text
@d1 1
a1 1
/*	$OpenBSD: search.c,v 1.18 2005/06/03 15:16:22 cloder Exp $	*/
d535 2
a536 1
	if ((rep = ereply("Query replace %s with: ", news, NPAT, pat)) == NULL)
d609 2
a610 1
	r = ereply("Replace string %s with: ", news, NPAT, pat);
@


1.18
log
@Like emacs, handle ^W during incremental search.  Pressing ^W during
search will add the rest of the word from the current buffer to the
pattern buffer.  Testing and comments by kjell and marc
@
text
@d1 1
a1 1
/*	$OpenBSD: search.c,v 1.17 2005/05/27 08:08:18 cloder Exp $	*/
d778 2
a779 1
		rep = ereply("%s: (default %s) ", tpat, NPAT, prompt, pat);
@


1.17
log
@Add emacs-style replace-string function that does not prompt you
to confirm replacements.
OK jason, deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: search.c,v 1.14 2005/05/25 23:04:39 cloder Exp $	*/
d13 1
d161 3
a163 1

d278 36
@


1.16
log
@Fix dumb bug in initial prompt for search-forward
OK jason, kjell
@
text
@d1 1
a1 1
/*	$OpenBSD: search.c,v 1.15 2005/05/27 05:55:12 cloder Exp $	*/
d552 38
@


1.15
log
@Do not dump core if user hits ^g to exit minibuffer from search-forward.
Found by deraadt, ok kjell
@
text
@d1 1
a1 1
/*	$OpenBSD: search.c,v 1.14 2005/05/25 23:04:39 cloder Exp $	*/
d698 1
a698 1
	if (tpat[0] == '\0')
@


1.14
log
@Incremental search will now wrap to beginning (or end if backwards) if
you hit the search key again after a failure. OK jason
@
text
@d1 1
a1 1
/*	$OpenBSD: search.c,v 1.13 2005/05/23 20:39:44 jason Exp $	*/
d704 3
a706 1
	if (rep != NULL && *rep != '\0') {
d709 1
a709 1
	} else if (*rep == '\0' && pat[0] != '\0') {
@


1.13
log
@make ^S/^R behave like 'emacs': mixed case patterns forces a case sensitive
search.  all lower case patterns is a case insensitive search; ok art
@
text
@d1 1
a1 1
/*	$OpenBSD: search.c,v 1.12 2005/04/03 02:09:28 db Exp $	*/
d223 9
a231 1
			if (success == FALSE && dir == SRCH_FORW)
d233 2
d254 10
a263 1
			if (success == FALSE && dir == SRCH_BACK)
d265 1
@


1.12
log
@This is a no binary change which does:

- spelling, punctuation fixes
- variable declaration lineup
- use parentheses for return and sizeof
- K&R function declarations -> ANSI
- other minor code beautification

ok henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: search.c,v 1.11 2004/07/22 01:25:25 vincent Exp $	*/
d40 1
a40 1
static int	eq(int, int);
d545 1
a545 1
	int	 cbo, tbo, c;
d550 3
d561 1
a561 1
		if (eq(c, pat[0]) != FALSE) {
d574 1
a574 1
				if (eq(c, *pp++) == FALSE)
d597 1
a597 1
	int	 cbo, tbo, c;
d603 3
d617 1
a617 1
		if (eq(c, *epp) != FALSE) {
d632 1
a632 1
				if (eq(c, *--pp) == FALSE)
d650 1
a650 1
eq(int bc, int pc)
d656 2
@


1.11
log
@stage 1 of the infinite minibuffer work - add support for on the fly
buffer reallocation in veread().  This commit only changes the API.
All the buffers have exactly the same bounds as before for now.

tested by a couple of my very helpful testers!
@
text
@d1 1
a1 1
/*	$OpenBSD: search.c,v 1.10 2003/05/20 03:08:55 cloder Exp $	*/
d60 1
a60 1
		return s;
d63 1
a63 1
		return FALSE;
d66 1
a66 1
	return TRUE;
d85 1
a85 1
		return FALSE;
d88 1
a88 1
	return TRUE;
d103 1
a103 1
			return FALSE;
d105 1
a105 1
		return TRUE;
d110 1
a110 1
			return FALSE;
d112 1
a112 1
		return TRUE;
d115 1
a115 1
	return FALSE;
d126 1
a126 1
	return isearch(SRCH_FORW);
d137 1
a137 1
	return isearch(SRCH_BACK);
d166 1
a166 1
		return FALSE;
d172 1
a172 1
	(void)strlcpy(opat, pat, sizeof opat);
d213 2
a214 2
			(void)strlcpy(pat, opat, sizeof pat);
			return ABORT;
d279 1
a279 1
				return TRUE;
d291 1
a291 1
				return FALSE;
d348 1
a348 1
	return cmds[cip].s_code;
d399 1
a399 1
				return FALSE;
d401 1
a401 1
			return TRUE;
d408 1
a408 1
				return FALSE;
d410 1
a410 1
			return TRUE;
d413 1
a413 1
		return FALSE;
d415 1
a415 1
	return FALSE;
d470 1
a470 1
		return FALSE;
d477 1
a477 1
		return ABORT;
d532 1
a532 1
	return TRUE;
d577 1
a577 1
			return TRUE;
d581 1
a581 1
	return FALSE;
d604 1
a604 1
				return FALSE;
d632 1
a632 1
			return TRUE;
d649 1
a649 1
		return TRUE;
d651 1
a651 1
		return TOLOWER(bc) == pc;
d653 2
a654 2
		return bc == TOLOWER(pc);
	return FALSE;
d668 1
a668 1
	int retval;
d677 1
a677 1
		(void) strlcpy(pat, tpat, sizeof pat);
d683 1
a683 1
	return retval;
a684 1

@


1.10
log
@Finish KNF of prototypes.  That should be all of them.
OK vincent@@
@
text
@d1 1
a1 1
/*	$OpenBSD: search.c,v 1.9 2002/02/16 21:27:49 millert Exp $	*/
d465 1
a465 1
	char	news[NPAT];		/* replacement string		*/
d476 3
a478 3
	if ((s = ereply("Query replace %s with: ", news, NPAT, pat)) == ABORT)
		return (s);
	if (s == FALSE)
d667 2
a668 2
	int	s;
	char	tpat[NPAT];
d671 1
a671 1
		s = ereply("%s: ", tpat, NPAT, prompt);
d673 1
a673 1
		s = ereply("%s: (default %s) ", tpat, NPAT, prompt, pat);
d676 1
a676 1
	if (s == TRUE)
d678 6
a683 4
	/* CR, but old one */
	else if (s == FALSE && pat[0] != 0)
		s = TRUE;
	return s;
@


1.9
log
@Part one of userland __P removal.  Done with a simple regexp with some minor hand editing to make comments line up correctly.  Another pass is forthcoming that handles the cases that could not be done automatically.
@
text
@d1 1
a1 1
/*	$OpenBSD: search.c,v 1.8 2002/02/13 03:03:49 vincent Exp $	*/
d55 1
a55 2
forwsearch(f, n)
	int f, n;
d77 1
a77 2
backsearch(f, n)
	int f, n;
d98 1
a98 2
searchagain(f, n)
	int f, n;
d124 1
a124 2
forwisearch(f, n)
	int f, n;
d135 1
a135 2
backisearch(f, n)
	int f, n;
d152 1
a152 2
isearch(dir)
	int dir;
d312 1
a312 2
is_cpush(cmd)
	int cmd;
d320 1
a320 1
is_lpush()
d333 1
a333 1
is_pop()
d346 1
a346 1
is_peek()
d353 1
a353 2
is_undo(pptr, dir)
	int *pptr, *dir;
d385 1
a385 2
is_find(dir)
	int	dir;
d425 1
a425 2
is_prompt(dir, flag, success)
	int dir, flag, success;
d446 1
a446 3
is_dspl(prompt, flag)
	char *prompt;
	int flag;
d460 1
a460 2
queryrepl(f, n)
	int f, n;
d542 1
a542 1
forwsrch()
d591 1
a591 1
backsrch()
d644 1
a644 2
eq(bc, pc)
	int bc, pc;
d665 1
a665 2
readpattern(prompt)
	char *prompt;
d683 1
@


1.8
log
@ * Replace unsafe strcpy and strcat calls to safe strlcpy and strlcat.
 * Be a little bit more verbose about some errors
 * Fix some memory leaks in fileio.c

ok deraadt@@, art@@
@
text
@d1 1
a1 1
/*	$OpenBSD: search.c,v 1.7 2001/05/24 03:05:26 mickey Exp $	*/
d31 10
a40 10
static int	isearch		__P((int));
static void	is_cpush	__P((int));
static void	is_lpush	__P((void));
static void	is_pop		__P((void));
static int	is_peek		__P((void));
static void	is_undo		__P((int *, int *));
static int	is_find		__P((int));
static void	is_prompt	__P((int, int, int));
static void	is_dspl		__P((char *, int));
static int	eq		__P((int, int));
@


1.7
log
@spaces
@
text
@d1 1
a1 1
/*	$OpenBSD: search.c,v 1.6 2001/05/23 22:20:36 art Exp $	*/
d178 1
a178 1
	(void)strcpy(opat, pat);
d219 1
a219 1
			(void)strcpy(pat, opat);
d692 1
a692 1
		(void) strcpy(pat, tpat);
@


1.6
log
@remove VOID. We're way beyond the point where this could build with an
ancient compiler.
@
text
@d1 1
a1 1
/*	$OpenBSD: search.c,v 1.5 2001/05/03 20:43:12 art Exp $	*/
d5 1
a5 1
 * The functions in this file implement the search commands (both plain and 
d49 2
a50 2
 * starting at ".".  If found, "." gets moved to just after the matched 
 * characters, and display does all the hard stuff.  If not found, it just 
d71 3
a73 3
 * Reverse search.  Get a search string from the user, and search, starting 
 * at "." and proceeding toward the front of the buffer.  If found "." is 
 * left pointing at the first character of the pattern [the last character 
d94 2
a95 2
 * Search again, using the same search string and direction as the last 
 * search command. The direction has been saved in "srch_lastdir", so you 
d122 1
a122 1
 * Use incremental searching, initially in the forward direction.  
d428 3
a430 3
 * If called with "dir" not one of SRCH_FORW or SRCH_BACK, this routine used 
 * to print an error message.  It also used to return TRUE or FALSE, depending 
 * on if it liked the "dir".  However, none of the callers looked at the 
d452 1
a452 1
 * Prompt writing routine for the incremental search.  The "prompt" is just 
d549 1
a549 1
 * This routine does the real work of a forward search.  The pattern is sitting 
d551 1
a551 1
 * is notified of the change, and TRUE is returned.  If the string isn't found, 
d598 2
a599 2
 * This routine does the real work of a backward search.  The pattern is 
 * sitting in the external variable "pat".  If found, dot is updated, the 
d653 1
a653 1
 * Compare two characters.  The "bc" comes from the buffer.  It has its case 
d672 4
a675 4
 * Read a pattern.  Stash it in the external variable "pat".  The "pat" is not 
 * updated if the user types in an empty line.  If the user typed an empty 
 * line, and there is no old pattern, it is an error.  Display the old pattern, 
 * in the style of Jeff Lomicka.  There is some do-it-yourself control 
@


1.5
log
@Fix another annoying feature in mg. When I try to use the keypad to
escape from I-search (I don't know if it's legal, but it works in emacs)
the initial ESC in the sequence is caugth by I-search (which exits), but
not the rest of it which ends up written into the buffer.

This is extra annoying when we don't have undo.

Note that this is better than emacs because the ESC is removed if nothing
indicating a multi-char sequence comes within 300 miliseconds. (Try to ESC
from I-search in emacs and then press 'x').
@
text
@d1 1
a1 1
/*	$OpenBSD: search.c,v 1.4 2001/01/29 01:58:09 niklas Exp $	*/
d32 3
a34 3
static VOID	is_cpush	__P((int));
static VOID	is_lpush	__P((void));
static VOID	is_pop		__P((void));
d36 1
a36 1
static VOID	is_undo		__P((int *, int *));
d38 2
a39 2
static VOID	is_prompt	__P((int, int, int));
static VOID	is_dspl		__P((char *, int));
d178 1
a178 1
	(VOID)strcpy(opat, pat);
d218 2
a219 2
			(VOID)ctrlg(FFRAND, 0);
			(VOID)strcpy(pat, opat);
d233 1
a233 1
			(VOID)forwchar(FFRAND, 1);
d237 1
a237 1
				(VOID)backchar(FFRAND, 1);
d254 1
a254 1
			(VOID)backchar(FFRAND, 1);
d258 1
a258 1
				(VOID)forwchar(FFRAND, 1);
d317 1
a317 1
static VOID
d326 1
a326 1
static VOID
d339 1
a339 1
static VOID
d359 1
a359 1
static VOID
d404 1
a404 1
			(VOID)backchar(FFARG | FFRAND, plen);
d413 1
a413 1
			(VOID)forwchar(FFARG | FFRAND, plen);
d433 1
a433 1
static VOID
d455 1
a455 1
static VOID
d517 1
a517 1
			(VOID)ctrlg(FFRAND, 0);
d692 1
a692 1
		(VOID) strcpy(pat, tpat);
@


1.4
log
@$OpenBSD$
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d193 8
@


1.3
log
@More -Wall anmd KNF, from op2@@tomahawk.SQUiSH.org
@
text
@d1 2
@


1.2
log
@The start of KNF + -Wall.  The code has been run through indent but
needs hand fixup.  I stopped at keymap.c...
@
text
@d3 2
a4 3
 * The functions in this file implement the
 * search commands (both plain and incremental searches
 * are supported) and the query-replace command.
d6 2
a7 3
 * The plain old search code is part of the original
 * MicroEMACS "distribution". The incremental search code,
 * and the query-replace code, is by Rich Ellison.
d9 3
a11 1
#include	"def.h"
d13 2
a14 2
#include	"macro.h"
#endif
d24 26
a49 26
	int             s_code;
	LINE           *s_dotp;
	int             s_doto;
}               SRCHCOM;

static SRCHCOM  cmds[NSRCH];
static int      cip;

int             srch_lastdir = SRCH_NOPR;	/* Last search flags.	 */

static VOID     is_cpush();
static VOID     is_lpush();
static VOID     is_pop();
static int      is_peek();
static VOID     is_undo();
static int      is_find();
static VOID     is_prompt();
static VOID     is_dspl();
static int      eq();

/*
 * Search forward.
 * Get a search string from the user, and search for it,
 * starting at ".". If found, "." gets moved to just after the
 * matched characters, and display does all the hard stuff.
 * If not found, it just prints a message.
d52 1
d54 1
d56 1
a56 1
	register int    s;
d69 4
a72 5
 * Reverse search.
 * Get a search string from the	 user, and search, starting at "."
 * and proceeding toward the front of the buffer. If found "." is left
 * pointing at the first character of the pattern [the last character that
 * was matched].
d75 1
d77 1
d79 1
a79 1
	register int    s;
d92 3
a94 4
 * Search again, using the same search string
 * and direction as the last search command. The direction
 * has been saved in "srch_lastdir", so you know which way
 * to go.
d97 1
d99 1
d120 1
a120 1
 * Use incremental searching, initially in the forward direction.
d124 1
d126 1
d136 1
d138 1
d154 1
d156 1
d158 8
a165 7
	register int    c;
	register LINE  *clp;
	register int    cbo;
	register int    success;
	int             pptr;
	char            opat[NPAT];
	VOID            ungetkey();
d172 1
a172 1
#endif
d175 2
a176 1
	(VOID) strcpy(opat, pat);
d185 1
d188 1
a195 1

d208 2
a209 2
			(VOID) ctrlg(FFRAND, 0);
			(VOID) strcpy(pat, opat);
a210 1

d223 1
a223 1
			(VOID) forwchar(FFRAND, 1);
d227 1
a227 1
				(VOID) backchar(FFRAND, 1);
a232 1

d244 1
a244 1
			(VOID) backchar(FFRAND, 1);
d248 1
a248 1
				(VOID) forwchar(FFRAND, 1);
a253 1

a260 1

d263 1
a263 1
			c = (char) getkey(FALSE);
a267 1

d307 1
a307 1
static          VOID
d309 1
a309 1
	register int    cmd;
d316 1
a316 1
static          VOID
d319 1
a319 1
	register int    ctp;
d329 1
a329 1
static          VOID
d349 1
a349 1
static          VOID
d351 1
a351 2
	register int   *pptr;
	register int   *dir;
d353 2
a354 1
	register int    redo = FALSE;
a360 1

a364 1

a368 1

d384 1
a384 1
	register int    dir;
d386 2
a387 2
	register int    plen, odoto;
	register LINE  *odotp;
d394 1
a394 1
			(VOID) backchar(FFARG | FFRAND, plen);
d403 1
a403 1
			(VOID) forwchar(FFARG | FFRAND, plen);
d418 4
a421 6
 * If called with "dir" not one of SRCH_FORW
 * or SRCH_BACK, this routine used to print an error
 * message. It also used to return TRUE or FALSE,
 * depending on if it liked the "dir". However, none
 * of the callers looked at the status, so I just
 * made the checking vanish.
d423 1
a423 1
static          VOID
d425 1
d442 2
a443 3
 * Prompt writing routine for the incremental search.
 * The "prompt" is just a string. The "flag" determines
 * whether pat should be printed.
d445 1
a445 1
static          VOID
d447 2
a448 1
	char           *prompt;
a449 1

d461 1
d463 1
d465 4
a468 4
	register int    s;
	register int    rcnt = 0;	/* Replacements made so far	 */
	register int    plen;	/* length of found string	 */
	char            news[NPAT];	/* replacement string		 */
d475 2
a476 1
#endif
a490 1

d496 1
a496 1
			if (lreplace((RSIZE) plen, news, f) == FALSE)
a499 1

d501 1
a501 1
			if (lreplace((RSIZE) plen, news, f) == FALSE)
d505 3
a507 3

		case CCHR('G'):/* ^G or ESC */
			(VOID) ctrlg(FFRAND, 0);
a509 1

d512 1
a512 1
				if (lreplace((RSIZE) plen, news, f) == FALSE)
a516 1

d518 2
a519 1
		case CCHR('?'):/* To not replace */
a520 1

d539 4
a542 5
 * This routine does the real work of a
 * forward search. The pattern is sitting in the external
 * variable "pat". If found, dot is updated, the window system
 * is notified of the change, and TRUE is returned. If the
 * string isn't found, FALSE is returned.
d544 1
d547 3
a549 6
	register LINE  *clp;
	register int    cbo;
	register LINE  *tlp;
	register int    tbo;
	char           *pp;
	register int    c;
d588 3
a590 4
 * This routine does the real work of a
 * backward search. The pattern is sitting in the external
 * variable "pat". If found, dot is updated, the window system
 * is notified of the change, and TRUE is returned. If the
d593 1
d596 3
a598 7
	register LINE  *clp;
	register int    cbo;
	register LINE  *tlp;
	register int    tbo;
	register int    c;
	register char  *epp;
	register char  *pp;
d643 2
a644 4
 * Compare two characters.
 * The "bc" comes from the buffer.
 * It has its case folded out. The
 * "pc" is from the pattern.
d648 1
a648 1
	register int    bc, pc;
d662 5
a666 6
 * Read a pattern.
 * Stash it in the external variable "pat". The "pat" is
 * not updated if the user types in an empty line. If the user typed
 * an empty line, and there is no old pattern, it is an error.
 * Display the old pattern, in the style of Jeff Lomicka. There is
 * some do-it-yourself control expansion.
d668 1
d670 1
a670 1
	char           *prompt;
d672 2
a673 2
	register int    s;
	char            tpat[NPAT];
d680 2
a681 1
	if (s == TRUE)		/* Specified		 */
d683 2
a684 1
	else if (s == FALSE && pat[0] != 0)	/* CR, but old one	 */
@


1.1
log
@initial import of mg2a
@
text
@d16 1
a16 1
#define SRCH_BEGIN	(0)			/* Search sub-codes.	*/
d23 20
a42 20
typedef struct	{
	int	s_code;
	LINE	*s_dotp;
	int	s_doto;
}	SRCHCOM;

static	SRCHCOM cmds[NSRCH];
static	int	cip;

int	srch_lastdir = SRCH_NOPR;		/* Last search flags.	*/

static VOID	is_cpush();
static VOID	is_lpush();
static VOID	is_pop();
static int	is_peek();
static VOID	is_undo();
static int	is_find();
static VOID	is_prompt();
static VOID	is_dspl();
static int	eq();
d51 1
a51 1
/*ARGSUSED*/
d54 1
a54 1
	register int	s;
d56 1
a56 1
	if ((s=readpattern("Search")) != TRUE)
d73 1
a73 1
/*ARGSUSED*/
d76 1
a76 1
	register int	s;
d78 1
a78 1
	if ((s=readpattern("Search backward")) != TRUE)
d94 1
a94 1
/*ARGSUSED*/
d119 1
a119 1
/*ARGSUSED*/
d129 1
a129 1
/*ARGSUSED*/
d146 9
a154 8
isearch(dir) {
	register int	c;
	register LINE	*clp;
	register int	cbo;
	register int	success;
	int		pptr;
	char		opat[NPAT];
	VOID		ungetkey();
d157 3
a159 3
	if(macrodef) {
	    ewprintf("Can't isearch in macro");
	    return FALSE;
d162 1
a162 1
	for (cip=0; cip<NSRCH; cip++)
d207 1
a207 1
			if (success==FALSE && dir==SRCH_FORW)
d212 2
a213 1
			if (is_find(SRCH_FORW) != FALSE) is_cpush(SRCH_MARK);
d229 1
a229 1
			if (success==FALSE && dir==SRCH_BACK)
d234 2
a235 1
			if (is_find(SRCH_BACK) != FALSE) is_cpush(SRCH_MARK);
d247 2
a248 1
			if (is_peek() != SRCH_ACCM) success = TRUE;
d255 1
a255 1
			goto  addchar;
d258 1
a258 1
			goto  addchar;
d267 1
a267 1
				return	TRUE;
d271 1
a271 1
		addchar:
d296 1
a296 1
	/*NOTREACHED*/
d299 4
a302 2
static VOID
is_cpush(cmd) register int cmd; {
d308 4
a311 3
static VOID
is_lpush() {
	register int	ctp;
d313 1
a313 1
	ctp = cip+1;
d321 3
a323 2
static VOID
is_pop() {
d325 2
a326 2
		curwp->w_doto  = cmds[cip].s_doto;
		curwp->w_dotp  = cmds[cip].s_dotp;
d331 1
a331 1
		cip = NSRCH-1;
d335 2
a336 1
is_peek() {
d341 6
a346 3
static VOID
is_undo(pptr, dir) register int *pptr; register int *dir; {
	register int	redo = FALSE ;
d373 2
a374 1
	if (redo) is_undo(pptr, dir);
d378 5
a382 3
is_find(dir) register int dir; {
	register int	plen, odoto;
	register LINE	*odotp ;
d388 1
a388 1
		if (dir==SRCH_FORW) {
d397 1
a397 1
		if (dir==SRCH_BACK) {
d420 3
a422 2
static VOID
is_prompt(dir, flag, success) {
d433 2
a434 1
	} else ewprintf("Broken call to is_prompt");
d442 4
a445 2
static VOID
is_dspl(prompt, flag) char *prompt; {
d457 1
a457 1
/*ARGSUSED*/
d460 4
a463 4
	register int	s;
	register int	rcnt = 0;	/* Replacements made so far	*/
	register int	plen;		/* length of found string	*/
	char		news[NPAT];	/* replacement string		*/
d466 3
a468 3
	if(macrodef) {
	    ewprintf("Can't query replace in macro");
	    return FALSE;
d471 1
a471 1
	if ((s=readpattern("Query replace")) != TRUE)
d473 1
a473 1
	if ((s=ereply("Query replace %s with: ",news, NPAT, pat)) == ABORT)
d487 1
a487 1
	retry:
d502 1
a502 1
		case CCHR('G'): /* ^G or ESC */
d516 1
a516 1
		case CCHR('?'):		/* To not replace */
d520 1
a520 1
ewprintf("<SP> replace, [.] rep-end, <DEL> don't, [!] repl rest <ESC> quit");
d543 8
a550 7
forwsrch() {
	register LINE	*clp;
	register int	cbo;
	register LINE	*tlp;
	register int	tbo;
	char		*pp;
	register int	c;
d554 1
a554 1
	for(;;) {
d556 2
a557 1
			if((clp = lforw(clp)) == curbp->b_linep) break;
d565 1
a565 1
			pp  = &pat[1];
d578 2
a579 2
			curwp->w_dotp  = tlp;
			curwp->w_doto  = tbo;
d583 1
a583 1
	fail:	;
d595 9
a603 8
backsrch() {
	register LINE	*clp;
	register int	cbo;
	register LINE	*tlp;
	register int	tbo;
	register int	c;
	register char	*epp;
	register char	*pp;
d605 1
a605 2
	for (epp = &pat[0]; epp[1] != 0; ++epp)
		;
d613 1
a613 1
			cbo = llength(clp)+1;
d618 1
a618 1
			c = lgetc(clp,cbo);
d622 1
a622 1
			pp  = epp;
d628 1
a628 1
					tbo = llength(tlp)+1;
d633 1
a633 1
					c = lgetc(tlp,tbo);
d637 2
a638 2
			curwp->w_dotp  = tlp;
			curwp->w_doto  = tbo;
d642 1
a642 1
	fail:	;
d644 1
a644 1
	/*NOTREACHED*/
d655 1
a655 1
register int bc, pc;
d659 6
a664 3
	if (bc == pc) return TRUE;
	if (ISUPPER(bc)) return TOLOWER(bc) == pc;
	if (ISUPPER(pc)) return bc == TOLOWER(pc);
d676 5
a680 3
readpattern(prompt) char *prompt; {
	register int	s;
	char		tpat[NPAT];
d682 4
a685 2
	if (tpat[0] == '\0') s = ereply("%s: ", tpat, NPAT, prompt);
	else s = ereply("%s: (default %s) ", tpat, NPAT, prompt, pat);
d687 1
a687 1
	if (s == TRUE)				/* Specified		*/
d689 1
a689 1
	else if (s==FALSE && pat[0]!=0)		/* CR, but old one	*/
@

