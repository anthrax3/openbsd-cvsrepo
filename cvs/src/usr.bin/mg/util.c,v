head	1.38;
access;
symbols
	OPENBSD_6_1:1.38.0.8
	OPENBSD_6_1_BASE:1.38
	OPENBSD_6_0:1.38.0.4
	OPENBSD_6_0_BASE:1.38
	OPENBSD_5_9:1.38.0.2
	OPENBSD_5_9_BASE:1.38;
locks; strict;
comment	@ * @;


1.38
date	2015.11.18.18.21.06;	author jasper;	state Exp;
branches;
next	1.37;
commitid	EC3wzGIKql4nQJg3;

1.37
date	2015.10.10.09.13.14;	author lum;	state Exp;
branches;
next	1.36;
commitid	hKKUrQOrFuzFuI2G;

1.36
date	2015.09.29.03.19.24;	author guenther;	state Exp;
branches;
next	1.35;
commitid	yKdJafwKaYfM4gkS;

1.35
date	2015.03.19.21.22.15;	author bcallah;	state Exp;
branches;
next	1.34;
commitid	GbEBL4CfPvDkB8hj;

1.34
date	2015.03.16.13.47.48;	author bcallah;	state Exp;
branches;
next	1.33;
commitid	gSveQVkxMLs6vRqK;

1.33
date	2014.03.26.22.02.06;	author lum;	state Exp;
branches;
next	1.32;

1.32
date	2013.03.25.11.41.44;	author florian;	state Exp;
branches;
next	1.31;

1.31
date	2012.05.18.02.13.44;	author lum;	state Exp;
branches;
next	1.30;

1.30
date	2011.01.21.19.10.13;	author kjell;	state Exp;
branches;
next	1.29;

1.29
date	2011.01.19.16.11.38;	author kjell;	state Exp;
branches;
next	1.28;

1.28
date	2011.01.18.16.25.40;	author kjell;	state Exp;
branches;
next	1.27;

1.27
date	2011.01.17.03.12.06;	author kjell;	state Exp;
branches;
next	1.26;

1.26
date	2008.09.15.16.13.35;	author kjell;	state Exp;
branches;
next	1.25;

1.25
date	2008.06.11.23.18.33;	author kjell;	state Exp;
branches;
next	1.24;

1.24
date	2007.02.08.21.40.38;	author kjell;	state Exp;
branches;
next	1.23;

1.23
date	2006.11.17.08.45.31;	author kjell;	state Exp;
branches;
next	1.22;

1.22
date	2006.07.25.08.27.09;	author kjell;	state Exp;
branches;
next	1.21;

1.21
date	2006.07.25.08.22.32;	author kjell;	state Exp;
branches;
next	1.20;

1.20
date	2006.06.01.10.10.00;	author kjell;	state Exp;
branches;
next	1.19;

1.19
date	2006.06.01.09.54.08;	author kjell;	state Exp;
branches;
next	1.18;

1.18
date	2006.06.01.04.17.34;	author kjell;	state Exp;
branches;
next	1.17;

1.17
date	2005.11.22.05.02.44;	author kjell;	state Exp;
branches;
next	1.16;

1.16
date	2005.11.19.20.16.35;	author kjell;	state Exp;
branches;
next	1.15;

1.15
date	2005.11.18.20.56.53;	author deraadt;	state Exp;
branches;
next	1.14;

1.14
date	2005.11.18.19.04.09;	author kjell;	state Exp;
branches;
next	1.13;

1.13
date	2005.10.13.20.07.26;	author kjell;	state Exp;
branches;
next	1.12;

1.12
date	2005.06.14.18.14.40;	author kjell;	state Exp;
branches;
next	1.11;

1.11
date	2005.04.03.02.09.28;	author db;	state Exp;
branches;
next	1.10;

1.10
date	2003.05.20.03.08.55;	author cloder;	state Exp;
branches;
next	1.9;

1.9
date	2003.05.16.19.28.59;	author vincent;	state Exp;
branches;
next	1.8;

1.8
date	2002.05.30.16.07.57;	author vincent;	state Exp;
branches;
next	1.7;

1.7
date	2002.02.14.14.24.21;	author deraadt;	state Exp;
branches;
next	1.6;

1.6
date	2001.05.24.03.05.25;	author mickey;	state Exp;
branches;
next	1.5;

1.5
date	2001.05.23.22.20.36;	author art;	state Exp;
branches;
next	1.4;

1.4
date	2001.01.29.01.58.09;	author niklas;	state Exp;
branches;
next	1.3;

1.3
date	2000.09.01.14.59.09;	author millert;	state Exp;
branches;
next	1.2;

1.2
date	2000.04.13.06.12.16;	author millert;	state Exp;
branches;
next	1.1;

1.1
date	2000.02.25.19.08.50;	author deraadt;	state Exp;
branches;
next	;


desc
@@


1.38
log
@whitespace
@
text
@/*	$OpenBSD: util.c,v 1.37 2015/10/10 09:13:14 lum Exp $	*/

/* This file is in the public domain. */

/*
 *		Assorted commands.
 * This file contains the command processors for a large assortment of
 * unrelated commands.  The only thing they have in common is that they
 * are all command processors.
 */

#include <sys/queue.h>
#include <ctype.h>
#include <signal.h>
#include <stdio.h>

#include "def.h"

/*
 * Display a bunch of useful information about the current location of dot.
 * The character under the cursor (in octal), the current line, row, and
 * column, and approximate position of the cursor in the file (as a
 * percentage) is displayed.  The column position assumes an infinite
 * position display; it does not truncate just because the screen does.
 * This is normally bound to "C-X =".
 */
/* ARGSUSED */
int
showcpos(int f, int n)
{
	struct line	*clp;
	long	 nchar, cchar;
	int	 nline, row;
	int	 cline, cbyte;		/* Current line/char/byte */
	int	 ratio;

	/* collect the data */
	clp = bfirstlp(curbp);
	cchar = 0;
	cline = 0;
	cbyte = 0;
	nchar = 0;
	nline = 0;
	for (;;) {
		/* count this line */
		++nline;
		if (clp == curwp->w_dotp) {
			/* mark line */
			cline = nline;
			cchar = nchar + curwp->w_doto;
			if (curwp->w_doto == llength(clp))
				cbyte = '\n';
			else
				cbyte = lgetc(clp, curwp->w_doto);
		}
		/* now count the chars */
		nchar += llength(clp);
		clp = lforw(clp);
		if (clp == curbp->b_headp)
			break;
		/* count the newline */
		nchar++;
	}
	/* determine row */
	row = curwp->w_toprow + 1;
	clp = curwp->w_linep;
	while (clp != curbp->b_headp && clp != curwp->w_dotp) {
		++row;
		clp = lforw(clp);
	}
	ratio = nchar ? (100L * cchar) / nchar : 100;
	ewprintf("Char: %c (0%o)  point=%ld(%d%%)  line=%d  row=%d  col=%d",
	    cbyte, cbyte, cchar, ratio, cline, row, getcolpos(curwp));
	return (TRUE);
}

int
getcolpos(struct mgwin *wp)
{
	int	col, i, c;
	char tmp[5];

	/* determine column */
	col = 0;

	for (i = 0; i < wp->w_doto; ++i) {
		c = lgetc(wp->w_dotp, i);
		if (c == '\t'
#ifdef NOTAB
		    && !(wp->w_bufp->b_flag & BFNOTAB)
#endif /* NOTAB */
			) {
			col |= 0x07;
			col++;
		} else if (ISCTRL(c) != FALSE)
			col += 2;
		else if (isprint(c)) {
			col++;
		} else {
			col += snprintf(tmp, sizeof(tmp), "\\%o", c);
		}

	}
	return (col);
}

/*
 * Twiddle the two characters in front of and under dot, then move forward
 * one character.  Treat new-line characters the same as any other.
 * Normally bound to "C-t".  This always works within a line, so "WFEDIT"
 * is good enough.
 */
/* ARGSUSED */
int
twiddle(int f, int n)
{
	struct line	*dotp;
	int	 doto, cr;

	if (n == 0)
		return (TRUE);

	dotp = curwp->w_dotp;
	doto = curwp->w_doto;

	/* Don't twiddle if the dot is on the first char of buffer */
	if (doto == 0 && lback(dotp) == curbp->b_headp) {
		dobeep();
		ewprintf("Beginning of buffer");
		return(FALSE);
	}
	/* Don't twiddle if the dot is on the last char of buffer */
	if (doto == llength(dotp) && lforw(dotp) == curbp->b_headp) {
		dobeep();
		return(FALSE);
	}
	undo_boundary_enable(FFRAND, 0);
	if (doto == 0 && doto == llength(dotp)) { /* only '\n' on this line */
		(void)forwline(FFRAND, 1);
		curwp->w_doto = 0;
	} else {
		if (doto == 0) { /* 1st twiddle is on 1st character of a line */
			cr = lgetc(dotp, doto);
			(void)backdel(FFRAND, 1);
			(void)forwchar(FFRAND, 1);
			lnewline();
			linsert(1, cr);
			(void)backdel(FFRAND, 1);
		} else {	/* twiddle is elsewhere in line */
			cr = lgetc(dotp, doto - 1);
			(void)backdel(FFRAND, 1);
			(void)forwchar(FFRAND, 1);
			linsert(1, cr);
		}
	}
	undo_boundary_enable(FFRAND, 1);
	lchange(WFEDIT);
	return (TRUE);
}

/*
 * Open up some blank space.  The basic plan is to insert a bunch of
 * newlines, and then back up over them.  Everything is done by the
 * subcommand processors.  They even handle the looping.  Normally this
 * is bound to "C-O".
 */
/* ARGSUSED */
int
openline(int f, int n)
{
	int	i, s;

	if (n < 0)
		return (FALSE);
	if (n == 0)
		return (TRUE);

	/* insert newlines */
	undo_boundary_enable(FFRAND, 0);
	i = n;
	do {
		s = lnewline();
	} while (s == TRUE && --i);

	/* then go back up overtop of them all */
	if (s == TRUE)
		s = backchar(f | FFRAND, n);
	undo_boundary_enable(FFRAND, 1);
	return (s);
}

/*
 * Insert a newline.
 */
/* ARGSUSED */
int
enewline(int f, int n)
{
	int	 s;

	if (n < 0)
		return (FALSE);

	while (n--) {
		if ((s = lnewline()) != TRUE)
			return (s);
	}
	return (TRUE);
}

/*
 * Delete blank lines around dot. What this command does depends if dot is
 * sitting on a blank line. If dot is sitting on a blank line, this command
 * deletes all the blank lines above and below the current line. If it is
 * sitting on a non blank line then it deletes all of the blank lines after
 * the line. Normally this command is bound to "C-X C-O". Any argument is
 * ignored.
 */
/* ARGSUSED */
int
deblank(int f, int n)
{
	struct line	*lp1, *lp2;
	RSIZE	 nld;

	lp1 = curwp->w_dotp;
	while (llength(lp1) == 0 && (lp2 = lback(lp1)) != curbp->b_headp)
		lp1 = lp2;
	lp2 = lp1;
	nld = (RSIZE)0;
	while ((lp2 = lforw(lp2)) != curbp->b_headp && llength(lp2) == 0)
		++nld;
	if (nld == 0)
		return (TRUE);
	curwp->w_dotp = lforw(lp1);
	curwp->w_doto = 0;
	return (ldelete((RSIZE)nld, KNONE));
}

/*
 * Delete any whitespace around dot, then insert a space.
 */
int
justone(int f, int n)
{
	undo_boundary_enable(FFRAND, 0);
	(void)delwhite(f, n);
	linsert(1, ' ');
	undo_boundary_enable(FFRAND, 1);
	return (TRUE);
}

/*
 * Delete any whitespace around dot.
 */
/* ARGSUSED */
int
delwhite(int f, int n)
{
	int	col, s;

	col = curwp->w_doto;

	while (col < llength(curwp->w_dotp) &&
	    (isspace(lgetc(curwp->w_dotp, col))))
		++col;
	do {
		if (curwp->w_doto == 0) {
			s = FALSE;
			break;
		}
		if ((s = backchar(FFRAND, 1)) != TRUE)
			break;
	} while (isspace(lgetc(curwp->w_dotp, curwp->w_doto)));

	if (s == TRUE)
		(void)forwchar(FFRAND, 1);
	(void)ldelete((RSIZE)(col - curwp->w_doto), KNONE);
	return (TRUE);
}

/*
 * Delete any leading whitespace on the current line
 */
int
delleadwhite(int f, int n)
{
	int soff, ls;
	struct line *slp;

	/* Save current position */
	slp = curwp->w_dotp;
	soff = curwp->w_doto;

	for (ls = 0; ls < llength(slp); ls++)
                 if (!isspace(lgetc(slp, ls)))
                        break;
	gotobol(FFRAND, 1);
	forwdel(FFRAND, ls);
	soff -= ls;
	if (soff < 0)
		soff = 0;
	forwchar(FFRAND, soff);

	return (TRUE);
}

/*
 * Delete any trailing whitespace on the current line
 */
int
deltrailwhite(int f, int n)
{
	int soff;

	/* Save current position */
	soff = curwp->w_doto;

	gotoeol(FFRAND, 1);
	delwhite(FFRAND, 1);

	/* restore original position, if possible */
	if (soff < curwp->w_doto)
		curwp->w_doto = soff;

	return (TRUE);
}



/*
 * Insert a newline, then enough tabs and spaces to duplicate the indentation
 * of the previous line.  Assumes tabs are every eight characters.  Quite
 * simple.  Figure out the indentation of the current line.  Insert a newline
 * by calling the standard routine.  Insert the indentation by inserting the
 * right number of tabs and spaces.  Return TRUE if all ok.  Return FALSE if
 * one of the subcommands failed. Normally bound to "C-M".
 */
/* ARGSUSED */
int
lfindent(int f, int n)
{
	int	c, i, nicol;
	int	s = TRUE;

	if (n < 0)
		return (FALSE);

	undo_boundary_enable(FFRAND, 0);
	while (n--) {
		nicol = 0;
		for (i = 0; i < llength(curwp->w_dotp); ++i) {
			c = lgetc(curwp->w_dotp, i);
			if (c != ' ' && c != '\t')
				break;
			if (c == '\t')
				nicol |= 0x07;
			++nicol;
		}
		if (lnewline() == FALSE || ((
#ifdef	NOTAB
		    curbp->b_flag & BFNOTAB) ? linsert(nicol, ' ') == FALSE : (
#endif /* NOTAB */
		    ((i = nicol / 8) != 0 && linsert(i, '\t') == FALSE) ||
		    ((i = nicol % 8) != 0 && linsert(i, ' ') == FALSE)))) {
			s = FALSE;
			break;
		}
	}
	undo_boundary_enable(FFRAND, 1);
	return (s);
}

/*
 * Indent the current line. Delete existing leading whitespace,
 * and use tabs/spaces to achieve correct indentation. Try
 * to leave dot where it started.
 */
int
indent(int f, int n)
{
	int soff, i;

	if (n < 0)
		return (FALSE);

	delleadwhite(FFRAND, 1);

	/* If not invoked with a numerical argument, done */
	if (!(f & FFARG))
		return (TRUE);

	/* insert appropriate whitespace */
	soff = curwp->w_doto;
	(void)gotobol(FFRAND, 1);
	if (
#ifdef	NOTAB
	    (curbp->b_flag & BFNOTAB) ? linsert(n, ' ') == FALSE :
#endif /* NOTAB */
	    (((i = n / 8) != 0 && linsert(i, '\t') == FALSE) ||
	    ((i = n % 8) != 0 && linsert(i, ' ') == FALSE)))
		return (FALSE);

	forwchar(FFRAND, soff);

	return (TRUE);
}


/*
 * Delete forward.  This is real easy, because the basic delete routine does
 * all of the work.  Watches for negative arguments, and does the right thing.
 * If any argument is present, it kills rather than deletes, to prevent loss
 * of text if typed with a big argument.  Normally bound to "C-D".
 */
/* ARGSUSED */
int
forwdel(int f, int n)
{
	if (n < 0)
		return (backdel(f | FFRAND, -n));

	/* really a kill */
	if (f & FFARG) {
		if ((lastflag & CFKILL) == 0)
			kdelete();
		thisflag |= CFKILL;
	}

	return (ldelete((RSIZE) n, (f & FFARG) ? KFORW : KNONE));
}

/*
 * Delete backwards.  This is quite easy too, because it's all done with
 * other functions.  Just move the cursor back, and delete forwards.  Like
 * delete forward, this actually does a kill if presented with an argument.
 */
/* ARGSUSED */
int
backdel(int f, int n)
{
	int	s;

	if (n < 0)
		return (forwdel(f | FFRAND, -n));

	/* really a kill */
	if (f & FFARG) {
		if ((lastflag & CFKILL) == 0)
			kdelete();
		thisflag |= CFKILL;
	}
	if ((s = backchar(f | FFRAND, n)) == TRUE)
		s = ldelete((RSIZE)n, (f & FFARG) ? KFORW : KNONE);

	return (s);
}

#ifdef	NOTAB
/* ARGSUSED */
int
space_to_tabstop(int f, int n)
{
	if (n < 0)
		return (FALSE);
	if (n == 0)
		return (TRUE);
	return (linsert((n << 3) - (curwp->w_doto & 7), ' '));
}
#endif /* NOTAB */

/*
 * Move the dot to the first non-whitespace character of the current line.
 */
int
backtoindent(int f, int n)
{
	gotobol(FFRAND, 1);
	while (curwp->w_doto < llength(curwp->w_dotp) &&
	    (isspace(lgetc(curwp->w_dotp, curwp->w_doto))))
		++curwp->w_doto;
	return (TRUE);
}

/*
 * Join the current line to the previous, or with arg, the next line
 * to the current one.  If the former line is not empty, leave exactly
 * one space at the joint.  Otherwise, leave no whitespace.
 */
int
joinline(int f, int n)
{
	int doto;

	undo_boundary_enable(FFRAND, 0);
	if (f & FFARG) {
		gotoeol(FFRAND, 1);
		forwdel(FFRAND, 1);
	} else {
		gotobol(FFRAND, 1);
		backdel(FFRAND, 1);
	}

	delwhite(FFRAND, 1);

	if ((doto = curwp->w_doto) > 0) {
		linsert(1, ' ');
		curwp->w_doto = doto;
	}
	undo_boundary_enable(FFRAND, 1);

	return (TRUE);
}
@


1.37
log
@Make functions that accept multiple iterations via C-u N, honour 0.
Except C-k which has a defined behaviour. In mg, C-t doesn't complete
n iterations if requested, but probably should, hence it has been
included in this diff.
@
text
@d1 1
a1 1
/*	$OpenBSD: util.c,v 1.36 2015/09/29 03:19:24 guenther Exp $	*/
d149 1
a149 1
		} else {	/* twiddle is elsewhere in line */	
@


1.36
log
@Delete the final, inscrutable NOSTRICT and VARARGS lint comments

ok millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: random.c,v 1.35 2015/03/19 21:22:15 bcallah Exp $	*/
d119 3
@


1.35
log
@Clean up the includes in mg.
This does the following:
Moves all POSIX headers from sysdef.h into the individual .c files so that
each file now only includes what it needs. All headers are properly sorted.
Moves the remainder of sysdef.h to other files (mostly def.h) and deletes
sysdef.h now that it's no longer contains anything.
Tweak a comment that references sysdef.h so that it no longer does that.
ok florian@@
@
text
@d1 1
a1 1
/*	$OpenBSD: random.c,v 1.34 2015/03/16 13:47:48 bcallah Exp $	*/
a70 1
	/* NOSTRICT */
@


1.34
log
@Change the internal name of the newline function to deconflict with a
function of the same name in term.h. This is the first step towards
cleaning up mg's includes. No user-visible changes.
ok florian@@
@
text
@d1 1
a1 1
/*	$OpenBSD: random.c,v 1.33 2014/03/26 22:02:06 lum Exp $	*/
d12 5
a17 2

#include <ctype.h>
@


1.33
log
@Previously, C-t (transpose two chars) did not behave the same as
Emacs.  This diff makes mg behave more so. Though new-line characters
are treated as any other.

Difference from emacs observed and reported by deraadt@@. First diff
tested and ridiculed by deraadt@@. Second diff not tested and not
ridiculed by deraadt@@ but at least email responded to.
@
text
@d1 1
a1 1
/*	$OpenBSD: random.c,v 1.32 2013/03/25 11:41:44 florian Exp $	*/
d192 1
a192 1
newline(int f, int n)
@


1.32
log
@Display the window's column number in mode line not the
column number of the active window.
OK jasper@@
@
text
@d1 1
a1 1
/*	$OpenBSD: random.c,v 1.31 2012/05/18 02:13:44 lum Exp $	*/
d106 3
a108 5
 * Twiddle the two characters on either side of dot.  If dot is at the end
 * of the line twiddle the two characters before it.  Return with an error
 * if dot is at the beginning of line; it seems to be a bit pointless to
 * make this work.  This fixes up a very common typo with a single stroke.
 * Normally bound to "C-T".  This always works within a line, so "WFEDIT"
a116 1
	int	 fudge = FALSE;
d120 16
a135 5
	if (doto == llength(dotp)) {
		if (--doto <= 0)
			return (FALSE);
		(void)backchar(FFRAND, 1);
		fudge = TRUE;
d137 13
a149 2
		if (doto == 0)
			return (FALSE);
a150 7
	undo_boundary_enable(FFRAND, 0);
	cr = lgetc(dotp, doto - 1);
	(void)backdel(FFRAND, 1);
	(void)forwchar(FFRAND, 1);
	linsert(1, cr);
	if (fudge != TRUE)
		(void)backchar(FFRAND, 1);
@


1.31
log
@Allow no-tab-mode to compile. From James Turner.

note: no-tab-mode needs more work done before removing the NOTABs.
@
text
@d1 1
a1 1
/*	$OpenBSD: random.c,v 1.30 2011/01/21 19:10:13 kjell Exp $	*/
d71 1
a71 1
	    cbyte, cbyte, cchar, ratio, cline, row, getcolpos());
d76 1
a76 1
getcolpos(void)
d84 2
a85 2
	for (i = 0; i < curwp->w_doto; ++i) {
		c = lgetc(curwp->w_dotp, i);
d88 1
a88 1
		    && !(curbp->b_flag & BFNOTAB)
@


1.30
log
@It volates style(9), but in mg, #include"def.h" goes first. 'twas the way it was built. no binary change here. confirmed by lum@@, tested by Henri Kemppainen
@
text
@d1 1
a1 1
/*	$OpenBSD: random.c,v 1.29 2011/01/19 16:11:38 kjell Exp $	*/
d381 1
a381 1
	    curbp->b_flag & BFNOTAB) ? linsert(n, ' ') == FALSE :
@


1.29
log
@patch from Henri Kemppainen:
clean up undo boundaries for functions in random.c
This catches an error, where twiddling in an empty file could
disable undo boundaries for the rest of the session.
proper undo boundaries around newline() will have to wait until
proper reference counting is done... Thanks!
@
text
@d1 1
a1 1
/*	$OpenBSD: random.c,v 1.28 2011/01/18 16:25:40 kjell Exp $	*/
d13 1
@


1.28
log
@Add join-line, bound to M-^
Join the current line to the previous.

original diff by Henri Kemppainen. minor mod to add undo boundaries.
Thanks!
@
text
@d1 1
a1 1
/*	$OpenBSD: random.c,v 1.27 2011/01/17 03:12:06 kjell Exp $	*/
a121 1
	undo_boundary_enable(FFRAND, 0);
d131 1
d161 1
d170 1
d228 1
d230 3
a232 1
	return (linsert(1, ' '));
d326 1
d331 1
d347 4
a350 2
		    ((i = nicol % 8) != 0 && linsert(i, ' ') == FALSE))))
			return (FALSE);
d352 2
a353 1
	return (TRUE);
@


1.27
log
@Add back-to-indentation. (M-m)
Move the dot to the first non-whitespace character on the current line.
from Henri Kemppainen . ok theo
@
text
@d1 1
a1 1
/*	$OpenBSD: random.c,v 1.26 2008/09/15 16:13:35 kjell Exp $	*/
d454 30
@


1.26
log
@Expose the undo commands as proper mg functions.
This should have no functional change on undo, but it does facilitate
testing undo behavior.
@
text
@d1 1
a1 1
/*	$OpenBSD: random.c,v 1.25 2008/06/11 23:18:33 kjell Exp $	*/
d443 13
@


1.25
log
@Add delete-leading-space, delete-trailing-space,
indent-current-line utility functions for stripping leading/trailing
whitespace, and setting a fixed indent respectively.
@
text
@d1 1
a1 1
/*	$OpenBSD: random.c,v 1.24 2007/02/08 21:40:38 kjell Exp $	*/
d122 1
a122 2
	undo_add_boundary();
	undo_boundary_enable(FALSE);
d138 1
a138 2
	undo_boundary_enable(TRUE);
	undo_add_boundary();
@


1.24
log
@Fix a comment
@
text
@d1 1
a1 1
/*	$OpenBSD: random.c,v 1.23 2006/11/17 08:45:31 kjell Exp $	*/
d239 1
a239 1
	int	col, c, s;
d244 1
a244 1
	    ((c = lgetc(curwp->w_dotp, col)) == ' ' || c == '\t'))
d253 1
a253 1
	} while ((c = lgetc(curwp->w_dotp, curwp->w_doto)) == ' ' || c == '\t');
d262 49
d320 1
a320 1
indent(int f, int n)
d347 36
@


1.23
log
@Fix a needless inversion of flag names; i.e. change them from the
negative to the positive. undo_boundary_enable(TRUE) makes a LOT more
sense than undo_no_boundary(FALSE).
While here, whack a global, and fix a bug noted by otto:
undoing a file insertion sometimes left stray characters around.
ok beck@@, otto@@
@
text
@d1 1
a1 1
/*	$OpenBSD: random.c,v 1.22 2006/07/25 08:27:09 kjell Exp $	*/
d267 1
a267 1
 * one of the subcommands failed. Normally bound to "C-J".
@


1.22
log
@Add bfirstlp(), blastlp() macros, returning the first and last lines
of a buffer respectively. Removes an ugly construction than necessitated
"go to first line"-type comments throughout the code.
No binary change
@
text
@d1 1
a1 1
/*	$OpenBSD: random.c,v 1.21 2006/07/25 08:22:32 kjell Exp $	*/
d123 1
a123 1
	undo_no_boundary(TRUE);
d139 1
a139 1
	undo_no_boundary(FALSE);
@


1.21
log
@Rename the header line of a buffer to b_headp, from the remarkably
unintuitive b_linep. No binary change.
@
text
@d1 1
a1 1
/*	$OpenBSD: random.c,v 1.20 2006/06/01 10:10:00 kjell Exp $	*/
d34 1
a34 1
	clp = lforw(curbp->b_headp);
@


1.20
log
@kill another superfluous strlen
@
text
@d1 1
a1 1
/*	$OpenBSD: random.c,v 1.19 2006/06/01 09:54:08 kjell Exp $	*/
d34 1
a34 1
	clp = lforw(curbp->b_linep);
d55 1
a55 1
		if (clp == curbp->b_linep)
d63 1
a63 1
	while (clp != curbp->b_linep && clp != curwp->w_dotp) {
d209 1
a209 1
	while (llength(lp1) == 0 && (lp2 = lback(lp1)) != curbp->b_linep)
d213 1
a213 1
	while ((lp2 = lforw(lp2)) != curbp->b_linep && llength(lp2) == 0)
@


1.19
log
@Style. no practical change.
@
text
@d1 1
a1 1
/*	$OpenBSD: random.c,v 1.18 2006/06/01 04:17:34 kjell Exp $	*/
d78 1
d94 1
a94 1
		else if (isprint(c))
d96 2
a97 4
		else {
			char tmp[5];
			snprintf(tmp, sizeof(tmp), "\\%o", c);
			col += strlen(tmp);
@


1.18
log
@Make transpose (c-T) undoable.
There is still a bug here, but it lies in undo (cursor position when undo
wraps the undo list), and is purely cosmetic for now.
@
text
@d1 1
a1 1
/*	$OpenBSD: random.c,v 1.17 2005/11/22 05:02:44 kjell Exp $	*/
d128 1
a128 1
		backchar(f, 1);
d135 2
a136 2
	backdel(f, 1);
	forwchar(f, 1);
d139 1
a139 1
		backchar(f, 1);
@


1.17
log
@Move kill-related commands to their own file.
This will help move to a kill-ring.
@
text
@d1 1
a1 1
/*	$OpenBSD: random.c,v 1.16 2005/11/19 20:16:35 kjell Exp $	*/
d119 1
d123 2
d128 2
a132 1
		++curwp->w_doto;
d134 8
a141 3
	cr = lgetc(dotp, doto--);
	lputc(dotp, doto + 1, lgetc(dotp, doto));
	lputc(dotp, doto, cr);
@


1.16
log
@Clean up some lint.
@
text
@d1 1
a1 1
/*	$OpenBSD: random.c,v 1.15 2005/11/18 20:56:53 deraadt Exp $	*/
a337 119
}

/*
 * Kill line.  If called without an argument, it kills from dot to the end
 * of the line, unless it is at the end of the line, when it kills the
 * newline.  If called with an argument of 0, it kills from the start of the
 * line to dot.  If called with a positive argument, it kills from dot
 * forward over that number of newlines.  If called with a negative argument
 * it kills any text before dot on the current line, then it kills back
 * abs(arg) lines.
 */
/* ARGSUSED */
int
killline(int f, int n)
{
	struct line	*nextp;
	RSIZE	 chunk;
	int	 i, c;

	/* clear kill buffer if last wasn't a kill */
	if ((lastflag & CFKILL) == 0)
		kdelete();
	thisflag |= CFKILL;
	if (!(f & FFARG)) {
		for (i = curwp->w_doto; i < llength(curwp->w_dotp); ++i)
			if ((c = lgetc(curwp->w_dotp, i)) != ' ' && c != '\t')
				break;
		if (i == llength(curwp->w_dotp))
			chunk = llength(curwp->w_dotp) - curwp->w_doto + 1;
		else {
			chunk = llength(curwp->w_dotp) - curwp->w_doto;
			if (chunk == 0)
				chunk = 1;
		}
	} else if (n > 0) {
		chunk = llength(curwp->w_dotp) - curwp->w_doto + 1;
		nextp = lforw(curwp->w_dotp);
		i = n;
		while (--i) {
			if (nextp == curbp->b_linep)
				break;
			chunk += llength(nextp) + 1;
			nextp = lforw(nextp);
		}
	} else {
		/* n <= 0 */
		chunk = curwp->w_doto;
		curwp->w_doto = 0;
		i = n;
		while (i++) {
			if (lback(curwp->w_dotp) == curbp->b_linep)
				break;
			curwp->w_dotp = lback(curwp->w_dotp);
			curwp->w_flag |= WFMOVE;
			chunk += llength(curwp->w_dotp) + 1;
		}
	}
	/*
	 * KFORW here is a bug.  Should be KBACK/KFORW, but we need to
	 * rewrite the ldelete code (later)?
	 */
	return (ldelete(chunk, KFORW));
}

/*
 * Yank text back from the kill buffer.  This is really easy.  All of the work
 * is done by the standard insert routines.  All you do is run the loop, and
 * check for errors.  The blank lines are inserted with a call to "newline"
 * instead of a call to "lnewline" so that the magic stuff that happens when
 * you type a carriage return also happens when a carriage return is yanked
 * back from the kill buffer.  An attempt has been made to fix the cosmetic
 * bug associated with a yank when dot is on the top line of the window
 * (nothing moves, because all of the new text landed off screen).
 */
/* ARGSUSED */
int
yank(int f, int n)
{
	struct line	*lp;
	int	 c, i, nline;

	if (n < 0)
		return (FALSE);

	/* newline counting */
	nline = 0;

	undo_add_boundary();
	undo_no_boundary(TRUE);
	while (n--) {
		/* mark around last yank */
		isetmark();
		i = 0;
		while ((c = kremove(i)) >= 0) {
			if (c == '\n') {
				if (newline(FFRAND, 1) == FALSE)
					return (FALSE);
				++nline;
			} else {
				if (linsert(1, c) == FALSE)
					return (FALSE);
			}
			++i;
		}
	}
	/* cosmetic adjustment */
	lp = curwp->w_linep;

	/* if offscreen insert */
	if (curwp->w_dotp == lp) {
		while (nline-- && lback(lp) != curbp->b_linep)
			lp = lback(lp);
		/* adjust framing */
		curwp->w_linep = lp;
		curwp->w_flag |= WFHARD;
	}
	undo_no_boundary(FALSE);
	undo_add_boundary();
	return (TRUE);
@


1.15
log
@greedy use of typedef struct was making code harder to read; ok kjell cloder
@
text
@d1 1
a1 1
/*	$OpenBSD: random.c,v 1.14 2005/11/18 19:04:09 kjell Exp $	*/
a172 1
	struct line	*lp;
a178 1
		lp = curwp->w_dotp;
@


1.14
log
@Don't ifdef out. Delete it. That's what the attic is for.
@
text
@d1 1
a1 1
/*	$OpenBSD: random.c,v 1.13 2005/10/13 20:07:26 kjell Exp $	*/
d27 1
a27 1
	LINE	*clp;
d117 1
a117 1
	LINE	*dotp;
d173 1
a173 1
	LINE	*lp;
d199 1
a199 1
	LINE	*lp1, *lp2;
d355 1
a355 1
	LINE	*nextp;
d418 1
a418 1
	LINE	*lp;
@


1.13
log
@Make undoing of a yank operation work as expected
(i.e. undo boundaries are placed around entire yanked block)
ok cloder@@
@
text
@d1 1
a1 1
/*	$OpenBSD: random.c,v 1.12 2005/06/14 18:14:40 kjell Exp $	*/
d167 1
a167 6
 * Insert a newline.  [following "feature" not present in current version of
 * Gnu, and now disabled here too] If you are at the end of the line and the
 * next line is a blank line, just move into the blank line.  This makes
 * "C-O" and "C-X C-O" work nicely, and reduces the amount of screen update
 * that has to be done.  This would not be as critical if screen update were a
 * lot more efficient.
a180 8
#ifdef undef
		if (llength(lp) == curwp->w_doto &&
		    lforw(lp) != curbp->b_linep &&
		    llength(lforw(lp)) == 0) {
			if ((s = forwchar(FFRAND, 1)) != TRUE)
				return (s);
		} else
#endif /* undef */
@


1.12
log
@Add explicit public domain notices to all public domain files.
ok millert@@, deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: random.c,v 1.11 2005/04/03 02:09:28 db Exp $	*/
d440 2
d469 2
@


1.11
log
@This is a no binary change which does:

- spelling, punctuation fixes
- variable declaration lineup
- use parentheses for return and sizeof
- K&R function declarations -> ANSI
- other minor code beautification

ok henning@@
@
text
@d1 3
a3 1
/*	$OpenBSD: random.c,v 1.10 2003/05/20 03:08:55 cloder Exp $	*/
@


1.10
log
@Finish KNF of prototypes.  That should be all of them.
OK vincent@@
@
text
@d1 1
a1 1
/*	$OpenBSD: random.c,v 1.9 2003/05/16 19:28:59 vincent Exp $	*/
d26 1
a26 2
	long	 nchar;
	long	 cchar;
d69 1
a69 1
	return TRUE;
d95 1
a95 1
			snprintf(tmp, sizeof tmp, "\\%o", c);
d100 1
a100 1
	return col;
d122 1
a122 1
			return FALSE;
d125 1
a125 1
			return FALSE;
d132 1
a132 1
	return TRUE;
d138 1
a138 1
 * subcommand procerssors.  They even handle the looping.  Normally this
d145 1
a145 2
	int	i;
	int	s;
d148 1
a148 1
		return FALSE;
d150 1
a150 1
		return TRUE;
d161 1
a161 1
	return s;
d168 1
a168 1
 * "C-O" and "C-X C-O" work nicely, and reduces the ammount of screen update
d180 1
a180 1
		return FALSE;
d189 1
a189 1
				return s;
d193 1
a193 1
			return s;
d195 1
a195 1
	return TRUE;
d224 1
a224 1
	return ldelete((RSIZE)nld, KNONE);
d234 1
a234 1
	return linsert(1, ' ');
d263 1
a263 1
	return TRUE;
d272 1
a272 1
 * one of the subcomands failed. Normally bound to "C-J".
d278 1
a278 3
	int	nicol;
	int	c;
	int	i;
d299 1
a299 1
			return FALSE;
d301 1
a301 1
	return TRUE;
d315 1
a315 1
		return backdel(f | FFRAND, -n);
d324 1
a324 1
	return ldelete((RSIZE) n, (f & FFARG) ? KFORW : KNONE);
d339 1
a339 1
		return forwdel(f | FFRAND, -n);
d350 1
a350 1
	return s;
d433 1
a433 1
		return FALSE;
d445 1
a445 1
					return FALSE;
d449 1
a449 1
					return FALSE;
d465 1
a465 1
	return TRUE;
d474 1
a474 1
		return FALSE;
d476 2
a477 2
		return TRUE;
	return linsert((n << 3) - (curwp->w_doto & 7), ' ');
@


1.9
log
@fix the goal calculation routine so moving up and down moves to the right
column.

ok jason
@
text
@d1 1
a1 1
/*	$OpenBSD: random.c,v 1.8 2002/05/30 16:07:57 vincent Exp $	*/
d23 1
a23 2
showcpos(f, n)
	int f, n;
d114 1
a114 2
twiddle(f, n)
	int f, n;
d144 1
a144 2
openline(f, n)
	int f, n;
d176 1
a176 2
newline(f, n)
	int f, n;
d210 1
a210 2
deblank(f, n)
	int f, n;
d233 1
a233 2
justone(f, n)
	int f, n;
d244 1
a244 2
delwhite(f, n)
	int f, n;
d278 1
a278 2
indent(f, n)
	int f, n;
d316 1
a316 2
forwdel(f, n)
	int f, n;
d338 1
a338 2
backdel(f, n)
	int f, n;
d368 1
a368 2
killline(f, n)
	int f, n;
d431 1
a431 2
yank(f, n)
	int f, n;
d475 1
a475 2
space_to_tabstop(f, n)
	int f, n;
@


1.8
log
@fix segfault when using just-one-space on an empty line; from
dkm_holdings@@hotmail.com

ok art@@
@
text
@d1 1
a1 1
/*	$OpenBSD: random.c,v 1.7 2002/02/14 14:24:21 deraadt Exp $	*/
d11 1
d75 1
a75 1
getcolpos()
d80 1
a80 1
	col = 1;
d90 1
a90 1
			++col;
d92 9
a100 2
			++col;
		++col;
@


1.7
log
@some KNF
@
text
@d1 1
a1 1
/*	$OpenBSD: random.c,v 1.6 2001/05/24 03:05:25 mickey Exp $	*/
d249 2
a250 2
	while (((c = lgetc(curwp->w_dotp, col)) == ' ' || c == '\t') &&
	    col < llength(curwp->w_dotp))
@


1.6
log
@spaces
@
text
@d1 1
a1 1
/*	$OpenBSD: random.c,v 1.5 2001/05/23 22:20:36 art Exp $	*/
d183 3
a185 3
		if (llength(lp) == curwp->w_doto
		    && lforw(lp) != curbp->b_linep
		    && llength(lforw(lp)) == 0) {
d249 2
a250 2
	while (((c = lgetc(curwp->w_dotp, col)) == ' ' || c == '\t')
	       && col < llength(curwp->w_dotp))
@


1.5
log
@remove VOID. We're way beyond the point where this could build with an
ancient compiler.
@
text
@d1 1
a1 1
/*	$OpenBSD: random.c,v 1.4 2001/01/29 01:58:09 niklas Exp $	*/
d5 2
a6 2
 * This file contains the command processors for a large assortment of 
 * unrelated commands.  The only thing they have in common is that they 
d13 4
a16 4
 * Display a bunch of useful information about the current location of dot. 
 * The character under the cursor (in octal), the current line, row, and 
 * column, and approximate position of the cursor in the file (as a 
 * percentage) is displayed.  The column position assumes an infinite 
d26 1
a26 1
	long	 nchar; 
d39 1
a39 1
	for (;;) {	
d98 5
a102 5
 * Twiddle the two characters on either side of dot.  If dot is at the end 
 * of the line twiddle the two characters before it.  Return with an error 
 * if dot is at the beginning of line; it seems to be a bit pointless to 
 * make this work.  This fixes up a very common typo with a single stroke. 
 * Normally bound to "C-T".  This always works within a line, so "WFEDIT" 
d131 3
a133 3
 * Open up some blank space.  The basic plan is to insert a bunch of 
 * newlines, and then back up over them.  Everything is done by the 
 * subcommand procerssors.  They even handle the looping.  Normally this 
d164 3
a166 3
 * next line is a blank line, just move into the blank line.  This makes 
 * "C-O" and "C-X C-O" work nicely, and reduces the ammount of screen update 
 * that has to be done.  This would not be as critical if screen update were a 
d198 4
a201 4
 * sitting on a blank line. If dot is sitting on a blank line, this command 
 * deletes all the blank lines above and below the current line. If it is 
 * sitting on a non blank line then it deletes all of the blank lines after 
 * the line. Normally this command is bound to "C-X C-O". Any argument is 
d269 4
a272 4
 * of the previous line.  Assumes tabs are every eight characters.  Quite 
 * simple.  Figure out the indentation of the current line.  Insert a newline 
 * by calling the standard routine.  Insert the indentation by inserting the 
 * right number of tabs and spaces.  Return TRUE if all ok.  Return FALSE if 
d310 2
a311 2
 * all of the work.  Watches for negative arguments, and does the right thing. 
 * If any argument is present, it kills rather than deletes, to prevent loss 
d333 2
a334 2
 * Delete backwards.  This is quite easy too, because it's all done with 
 * other functions.  Just move the cursor back, and delete forwards.  Like 
d360 6
a365 6
 * Kill line.  If called without an argument, it kills from dot to the end 
 * of the line, unless it is at the end of the line, when it kills the 
 * newline.  If called with an argument of 0, it kills from the start of the 
 * line to dot.  If called with a positive argument, it kills from dot 
 * forward over that number of newlines.  If called with a negative argument 
 * it kills any text before dot on the current line, then it kills back 
d423 2
a424 2
 * Yank text back from the kill buffer.  This is really easy.  All of the work 
 * is done by the standard insert routines.  All you do is run the loop, and 
d426 4
a429 4
 * instead of a call to "lnewline" so that the magic stuff that happens when 
 * you type a carriage return also happens when a carriage return is yanked 
 * back from the kill buffer.  An attempt has been made to fix the cosmetic 
 * bug associated with a yank when dot is on the top line of the window 
@


1.4
log
@$OpenBSD$
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d233 1
a233 1
	(VOID)delwhite(f, n);
d262 2
a263 2
		(VOID)forwchar(FFRAND, 1);
	(VOID)ldelete((RSIZE)(col - curwp->w_doto), KNONE);
@


1.3
log
@More -Wall anmd KNF, from op2@@tomahawk.SQUiSH.org
@
text
@d1 2
@


1.2
log
@The start of KNF + -Wall.  The code has been run through indent but
needs hand fixup.  I stopped at keymap.c...
@
text
@d3 6
a8 6
 * The file contains the command
 * processors for a large assortment of unrelated
 * commands. The only thing they have in common is
 * that they are all command processors.
 */
#include	"def.h"
d11 5
a15 6
 * Display a bunch of useful information about
 * the current location of dot. The character under the
 * cursor (in octal), the current line, row, and column, and
 * approximate position of the cursor in the file (as a percentage)
 * is displayed. The column position assumes an infinite position
 * display; it does not truncate just because the screen does.
d19 1
d21 1
d23 12
a34 8
	register LINE  *clp;
	register long   nchar;
	long            cchar;
	register int    nline, row;
	int             cline, cbyte;	/* Current line/char/byte */
	int             ratio;

	clp = lforw(curbp->b_linep);	/* Collect the data.	 */
d37 3
a39 2
	for (;;) {
		++nline;	/* Count this line	 */
d41 2
a42 1
			cline = nline;	/* Mark line		 */
d49 2
a50 1
		nchar += llength(clp);	/* Now count the chars	 */
d54 2
a55 1
		nchar++;	/* count the newline	 */
d57 2
a58 1
	row = curwp->w_toprow + 1;	/* Determine row.	 */
d67 1
a67 1
		 cbyte, cbyte, cchar, ratio, cline, row, getcolpos());
d71 1
d74 4
a77 1
	register int    col, i, c;
a78 1
	col = 1;		/* Determine column.	 */
d82 1
a82 1
#ifdef	NOTAB
d84 1
a84 1
#endif
d94 1
d96 6
a101 8
 * Twiddle the two characters on either side of
 * dot. If dot is at the end of the line twiddle the
 * two characters before it. Return with an error if dot
 * is at the beginning of line; it seems to be a bit
 * pointless to make this work. This fixes up a very
 * common typo with a single stroke. Normally bound
 * to "C-T". This always works within a line, so
 * "WFEDIT" is good enough.
d104 1
d106 1
d108 2
a109 4
	register LINE  *dotp;
	register int    doto;
	register int    cr;
	VOID            lchange();
d129 4
a132 5
 * Open up some blank space. The basic plan
 * is to insert a bunch of newlines, and then back
 * up over them. Everything is done by the subcommand
 * procerssors. They even handle the looping. Normally
 * this is bound to "C-O".
d135 1
d137 1
d139 2
a140 2
	register int    i;
	register int    s;
d146 3
a148 1
	i = n;			/* Insert newlines.	 */
d152 4
a155 2
	if (s == TRUE)		/* Then back up overtop */
		s = backchar(f | FFRAND, n);	/* of them all.		 */
d160 6
a165 10
 * Insert a newline.
 * [following "feature" not present in current version of
 *  Gnu, and now disabled here too]
 * If you are at the end of the line and the
 * next line is a blank line, just move into the
 * blank line. This makes "C-O" and "C-X C-O" work
 * nicely, and reduces the ammount of screen
 * update that has to be done. This would not be
 * as critical if screen update were a lot
 * more efficient.
d168 1
d170 1
d172 2
a173 2
	register LINE  *lp;
	register int    s;
d177 1
d187 1
a187 1
#endif
d195 6
a200 8
 * Delete blank lines around dot.
 * What this command does depends if dot is
 * sitting on a blank line. If dot is sitting on a
 * blank line, this command deletes all the blank lines
 * above and below the current line. If it is sitting
 * on a non blank line then it deletes all of the
 * blank lines after the line. Normally this command
 * is bound to "C-X C-O". Any argument is ignored.
d203 1
d205 1
d207 2
a208 3
	register LINE  *lp1;
	register LINE  *lp2;
	register RSIZE  nld;
d214 1
a214 1
	nld = (RSIZE) 0;
d221 1
a221 1
	return ldelete((RSIZE) nld, KNONE);
d227 1
d229 1
d231 1
a231 1
	(VOID) delwhite(f, n);
d234 1
d239 1
d241 1
d243 1
a243 1
	register int    col, c, s;
d246 1
d260 2
a261 2
		(VOID) forwchar(FFRAND, 1);
	(VOID) ldelete((RSIZE) (col - curwp->w_doto), KNONE);
d264 1
d266 6
a271 10
 * Insert a newline, then enough
 * tabs and spaces to duplicate the indentation
 * of the previous line. Assumes tabs are every eight
 * characters. Quite simple. Figure out the indentation
 * of the current line. Insert a newline by calling
 * the standard routine. Insert the indentation by
 * inserting the right number of tabs and spaces.
 * Return TRUE if all ok. Return FALSE if one
 * of the subcomands failed. Normally bound
 * to "C-J".
d274 1
d276 1
d278 3
a280 3
	register int    nicol;
	register int    c;
	register int    i;
d284 1
d297 4
a300 5
					     curbp->b_flag & BFNOTAB) ?
					    linsert(nicol, ' ') == FALSE : (
#endif
		      ((i = nicol / 8) != 0 && linsert(i, '\t') == FALSE) ||
		       ((i = nicol % 8) != 0 && linsert(i, ' ') == FALSE))))
d307 4
a310 7
 * Delete forward. This is real
 * easy, because the basic delete routine does
 * all of the work. Watches for negative arguments,
 * and does the right thing. If any argument is
 * present, it kills rather than deletes, to prevent
 * loss of text if typed with a big argument.
 * Normally bound to "C-D".
d313 1
d315 1
d319 3
a321 1
	if (f & FFARG) {	/* Really a kill.	 */
d326 1
d331 3
a333 5
 * Delete backwards. This is quite easy too,
 * because it's all done with other functions. Just
 * move the cursor back, and delete forwards.
 * Like delete forward, this actually does a kill
 * if presented with an argument.
d336 1
d338 1
d340 1
a340 1
	register int    s;
d344 3
a346 1
	if (f & FFARG) {	/* Really a kill.	 */
d352 2
a353 1
		s = ldelete((RSIZE) n, (f & FFARG) ? KFORW : KNONE);
d358 7
a364 9
 * Kill line. If called without an argument,
 * it kills from dot to the end of the line, unless it
 * is at the end of the line, when it kills the newline.
 * If called with an argument of 0, it kills from the
 * start of the line to dot. If called with a positive
 * argument, it kills from dot forward over that number
 * of newlines. If called with a negative argument it
 * kills any text before dot on the current line,
 * then it kills back abs(arg) lines.
d367 1
d369 1
d371 7
a377 7
	register RSIZE  chunk;
	register LINE  *nextp;
	register int    i, c;
	VOID            kdelete();

	if ((lastflag & CFKILL) == 0)	/* Clear kill buffer if */
		kdelete();	/* last wasn't a kill.	 */
d400 2
a401 1
	} else {		/* n <= 0		 */
d414 1
a414 1
	 * KFORW here is a bug. Should be KBACK/KFORW, but we need to
d421 8
a428 13
 * Yank text back from the kill buffer. This
 * is really easy. All of the work is done by the
 * standard insert routines. All you do is run the loop,
 * and check for errors. The blank
 * lines are inserted with a call to "newline"
 * instead of a call to "lnewline" so that the magic
 * stuff that happens when you type a carriage
 * return also happens when a carriage return is
 * yanked back from the kill buffer.
 * An attempt has been made to fix the cosmetic bug
 * associated with a yank when dot is on the top line of
 * the window (nothing moves, because all of the new
 * text landed off screen).
d431 1
d433 1
d435 2
a436 5
	register int    c;
	register int    i;
	register LINE  *lp;
	register int    nline;
	VOID            isetmark();
d440 4
a443 1
	nline = 0;		/* Newline counting.	 */
d445 2
a446 1
		isetmark();	/* mark around last yank */
d460 5
a464 2
	lp = curwp->w_linep;	/* Cosmetic adjustment	 */
	if (curwp->w_dotp == lp) {	/* if offscreen insert. */
d467 2
a468 1
		curwp->w_linep = lp;	/* Adjust framing.	 */
d476 1
d478 1
a478 1
	int             f, n;
d486 1
a486 1
#endif
@


1.1
log
@initial import of mg2a
@
text
@d19 1
a19 1
/*ARGSUSED*/
d22 6
a27 6
	register LINE	*clp;
	register long	nchar;
	long		cchar;
	register int	nline, row;
	int		cline, cbyte;	/* Current line/char/byte */
	int		ratio;
d29 1
a29 1
	clp = lforw(curbp->b_linep);		/* Collect the data.	*/
d33 1
a33 1
		++nline;			/* Count this line	*/
d35 1
a35 1
			cline = nline;		/* Mark line		*/
d42 1
a42 1
		nchar += llength(clp);		/* Now count the chars	*/
d44 3
a46 2
		if (clp == curbp->b_linep) break;
		nchar++;			/* count the newline	*/
d48 1
a48 1
	row = curwp->w_toprow + 1;		/* Determine row.	*/
d50 1
a50 1
	while (clp!=curbp->b_linep && clp!=curwp->w_dotp) {
d54 2
a55 2
	/*NOSTRICT*/
	ratio = nchar ? (100L*cchar) / nchar : 100;
d57 1
a57 1
		cbyte, cbyte, cchar, ratio, cline, row, getcolpos());
d61 3
a63 2
getcolpos() {
	register int	col, i, c;
d65 2
a66 2
	col = 1;				/* Determine column.	*/
	for (i=0; i<curwp->w_doto; ++i) {
d70 1
a70 1
			&& !(curbp->b_flag & BFNOTAB)
d73 2
a74 2
		    col |= 0x07;
		    ++col;
d91 1
a91 1
/*ARGSUSED*/
d94 4
a97 4
	register LINE	*dotp;
	register int	doto;
	register int	cr;
	VOID	 lchange();
d101 3
a103 2
	if(doto==llength(dotp)) {
		if(--doto<=0) return FALSE;
d105 2
a106 1
		if(doto==0) return FALSE;
d110 1
a110 1
	lputc(dotp, doto+1, lgetc(dotp, doto));
d123 1
a123 1
/*ARGSUSED*/
d126 2
a127 2
	register int	i;
	register int	s;
d133 1
a133 1
	i = n;					/* Insert newlines.	*/
d136 3
a138 3
	} while (s==TRUE && --i);
	if (s == TRUE)				/* Then back up overtop */
		s = backchar(f | FFRAND, n);	/* of them all.		*/
d154 1
a154 1
/*ARGSUSED*/
d157 2
a158 2
	register LINE	*lp;
	register int	s;
d160 2
a161 1
	if (n < 0) return FALSE;
d166 3
a168 3
		&& lforw(lp) != curbp->b_linep
		&& llength(lforw(lp)) == 0) {
			if ((s=forwchar(FFRAND, 1)) != TRUE)
d172 2
a173 2
			if ((s=lnewline()) != TRUE)
				return s;
d188 1
a188 1
/*ARGSUSED*/
d191 3
a193 3
	register LINE	*lp1;
	register LINE	*lp2;
	register RSIZE	nld;
d196 1
a196 1
	while (llength(lp1)==0 && (lp2=lback(lp1))!=curbp->b_linep)
d200 1
a200 1
	while ((lp2=lforw(lp2))!=curbp->b_linep && llength(lp2)==0)
d206 1
a206 1
	return ldelete((RSIZE)nld, KNONE);
d212 2
a213 1
justone(f, n) {
d220 1
a220 1
/*ARGSUSED*/
d223 1
a223 1
	register int	col, c, s;
d227 1
a227 1
			&& col < llength(curwp->w_dotp))
d234 2
a235 1
		if ((s = backchar(FFRAND, 1)) != TRUE) break;
d238 3
a240 2
	if (s == TRUE) (VOID) forwchar(FFRAND, 1);
	(VOID) ldelete((RSIZE)(col - curwp->w_doto), KNONE);
d255 1
a255 1
/*ARGSUSED*/
d258 3
a260 3
	register int	nicol;
	register int	c;
	register int	i;
d262 2
a263 1
	if (n < 0) return (FALSE);
d266 1
a266 1
		for (i=0; i<llength(curwp->w_dotp); ++i) {
d268 1
a268 1
			if (c!=' ' && c!='\t')
d276 2
a277 2
		    curbp->b_flag&BFNOTAB) ?
			linsert(nicol, ' ') == FALSE : (
d279 2
a280 2
		    ((i=nicol/8)!=0 && linsert(i, '\t')==FALSE) ||
		    ((i=nicol%8)!=0 && linsert(i,  ' ')==FALSE))))
d295 1
a295 1
/*ARGSUSED*/
d300 2
a301 2
	if (f & FFARG) {			/* Really a kill.	*/
		if ((lastflag&CFKILL) == 0)
d315 1
a315 1
/*ARGSUSED*/
d318 1
a318 1
	register int	s;
d322 2
a323 2
	if (f & FFARG) {			/* Really a kill.	*/
		if ((lastflag&CFKILL) == 0)
d327 1
a327 1
	if ((s=backchar(f | FFRAND, n)) == TRUE)
d343 7
a349 6
/*ARGSUSED*/
killline(f, n) {
	register RSIZE	chunk;
	register LINE	*nextp;
	register int	i, c;
	VOID	 kdelete();
d351 2
a352 2
	if ((lastflag&CFKILL) == 0)		/* Clear kill buffer if */
		kdelete();			/* last wasn't a kill.	*/
d359 1
a359 1
			chunk = llength(curwp->w_dotp)-curwp->w_doto + 1;
d361 1
a361 1
			chunk = llength(curwp->w_dotp)-curwp->w_doto;
d366 1
a366 1
		chunk = llength(curwp->w_dotp)-curwp->w_doto+1;
d372 1
a372 1
			chunk += llength(nextp)+1;
d375 1
a375 1
	} else {				/* n <= 0		*/
d384 1
a384 1
			chunk += llength(curwp->w_dotp)+1;
d391 1
a391 1
	return (ldelete(chunk,	KFORW));
d409 1
a409 1
/*ARGSUSED*/
d412 5
a416 5
	register int	c;
	register int	i;
	register LINE	*lp;
	register int	nline;
	VOID	 isetmark();
d418 3
a420 2
	if (n < 0) return FALSE;
	nline = 0;				/* Newline counting.	*/
d422 1
a422 1
		isetmark();			/* mark around last yank */
d424 1
a424 1
		while ((c=kremove(i)) >= 0) {
d436 3
a438 3
	lp = curwp->w_linep;			/* Cosmetic adjustment	*/
	if (curwp->w_dotp == lp) {		/* if offscreen insert. */
		while (nline-- && lback(lp)!=curbp->b_linep)
d440 1
a440 1
		curwp->w_linep = lp;		/* Adjust framing.	*/
d447 1
a447 1
/*ARGSUSED*/
d449 1
a449 1
int f, n;
d451 5
a455 3
    if(n<0) return FALSE;
    if(n==0) return TRUE;
    return linsert((n<<3) - (curwp->w_doto & 7), ' ');
@

