head	1.33;
access;
symbols
	OPENBSD_6_1:1.31.0.10
	OPENBSD_6_1_BASE:1.31
	OPENBSD_6_0:1.31.0.6
	OPENBSD_6_0_BASE:1.31
	OPENBSD_5_9:1.31.0.2
	OPENBSD_5_9_BASE:1.31
	OPENBSD_5_8:1.31.0.4
	OPENBSD_5_8_BASE:1.31
	OPENBSD_5_7:1.30.0.2
	OPENBSD_5_7_BASE:1.30
	OPENBSD_5_6:1.30.0.4
	OPENBSD_5_6_BASE:1.30
	OPENBSD_5_5:1.29.0.4
	OPENBSD_5_5_BASE:1.29
	OPENBSD_5_4:1.27.0.2
	OPENBSD_5_4_BASE:1.27
	OPENBSD_5_3:1.26.0.10
	OPENBSD_5_3_BASE:1.26
	OPENBSD_5_2:1.26.0.8
	OPENBSD_5_2_BASE:1.26
	OPENBSD_5_1_BASE:1.26
	OPENBSD_5_1:1.26.0.6
	OPENBSD_5_0:1.26.0.4
	OPENBSD_5_0_BASE:1.26
	OPENBSD_4_9:1.26.0.2
	OPENBSD_4_9_BASE:1.26
	OPENBSD_4_8:1.25.0.6
	OPENBSD_4_8_BASE:1.25
	OPENBSD_4_7:1.25.0.2
	OPENBSD_4_7_BASE:1.25
	OPENBSD_4_6:1.25.0.4
	OPENBSD_4_6_BASE:1.25
	OPENBSD_4_5:1.24.0.12
	OPENBSD_4_5_BASE:1.24
	OPENBSD_4_4:1.24.0.10
	OPENBSD_4_4_BASE:1.24
	OPENBSD_4_3:1.24.0.8
	OPENBSD_4_3_BASE:1.24
	OPENBSD_4_2:1.24.0.6
	OPENBSD_4_2_BASE:1.24
	OPENBSD_4_1:1.24.0.4
	OPENBSD_4_1_BASE:1.24
	OPENBSD_4_0:1.24.0.2
	OPENBSD_4_0_BASE:1.24
	OPENBSD_3_9:1.22.0.2
	OPENBSD_3_9_BASE:1.22
	OPENBSD_3_8:1.18.0.2
	OPENBSD_3_8_BASE:1.18
	OPENBSD_3_7:1.13.0.4
	OPENBSD_3_7_BASE:1.13
	OPENBSD_3_6:1.13.0.2
	OPENBSD_3_6_BASE:1.13
	OPENBSD_3_5:1.12.0.4
	OPENBSD_3_5_BASE:1.12
	OPENBSD_3_4:1.12.0.2
	OPENBSD_3_4_BASE:1.12
	OPENBSD_3_3:1.11.0.6
	OPENBSD_3_3_BASE:1.11
	OPENBSD_3_2:1.11.0.4
	OPENBSD_3_2_BASE:1.11
	OPENBSD_3_1:1.11.0.2
	OPENBSD_3_1_BASE:1.11
	OPENBSD_3_0:1.9.0.2
	OPENBSD_3_0_BASE:1.9
	OPENBSD_2_9_BASE:1.7
	OPENBSD_2_9:1.7.0.2
	OPENBSD_2_8:1.6.0.2
	OPENBSD_2_8_BASE:1.6
	OPENBSD_2_7:1.5.0.2
	OPENBSD_2_7_BASE:1.5;
locks; strict;
comment	@ * @;


1.33
date	2017.08.06.04.39.45;	author bcallah;	state Exp;
branches;
next	1.32;
commitid	OgoyN2WL9YbKQ9Of;

1.32
date	2017.05.30.07.05.22;	author florian;	state Exp;
branches;
next	1.31;
commitid	L2GD0imd4EtMY0Yn;

1.31
date	2015.03.19.21.22.15;	author bcallah;	state Exp;
branches;
next	1.30;
commitid	GbEBL4CfPvDkB8hj;

1.30
date	2014.03.20.07.47.29;	author lum;	state Exp;
branches;
next	1.29;

1.29
date	2013.12.20.18.44.13;	author florian;	state Exp;
branches;
next	1.28;

1.28
date	2013.09.24.13.29.51;	author jasper;	state Exp;
branches;
next	1.27;

1.27
date	2013.05.31.18.03.45;	author lum;	state Exp;
branches;
next	1.26;

1.26
date	2011.01.21.19.10.13;	author kjell;	state Exp;
branches;
next	1.25;

1.25
date	2009.06.04.02.23.37;	author kjell;	state Exp;
branches;
next	1.24;

1.24
date	2006.07.25.08.22.32;	author kjell;	state Exp;
branches;
next	1.23;

1.23
date	2006.05.28.23.30.16;	author kjell;	state Exp;
branches;
next	1.22;

1.22
date	2005.12.13.06.01.27;	author kjell;	state Exp;
branches;
next	1.21;

1.21
date	2005.11.18.20.56.53;	author deraadt;	state Exp;
branches;
next	1.20;

1.20
date	2005.11.18.17.35.17;	author kjell;	state Exp;
branches;
next	1.19;

1.19
date	2005.10.14.15.41.33;	author deraadt;	state Exp;
branches;
next	1.18;

1.18
date	2005.08.09.00.53.48;	author kjell;	state Exp;
branches;
next	1.17;

1.17
date	2005.06.14.18.14.40;	author kjell;	state Exp;
branches;
next	1.16;

1.16
date	2005.06.14.00.55.45;	author kjell;	state Exp;
branches;
next	1.15;

1.15
date	2005.06.05.05.15.56;	author kjell;	state Exp;
branches;
next	1.14;

1.14
date	2005.04.03.02.09.28;	author db;	state Exp;
branches;
next	1.13;

1.13
date	2004.07.22.01.25.25;	author vincent;	state Exp;
branches;
next	1.12;

1.12
date	2003.05.20.03.08.55;	author cloder;	state Exp;
branches;
next	1.11;

1.11
date	2002.02.16.21.27.49;	author millert;	state Exp;
branches;
next	1.10;

1.10
date	2002.02.13.03.03.49;	author vincent;	state Exp;
branches;
next	1.9;

1.9
date	2001.05.24.03.05.25;	author mickey;	state Exp;
branches;
next	1.8;

1.8
date	2001.05.23.22.20.36;	author art;	state Exp;
branches;
next	1.7;

1.7
date	2001.01.29.01.58.09;	author niklas;	state Exp;
branches;
next	1.6;

1.6
date	2000.09.01.14.59.09;	author millert;	state Exp;
branches;
next	1.5;

1.5
date	2000.04.13.06.12.16;	author millert;	state Exp;
branches;
next	1.4;

1.4
date	2000.02.29.16.00.23;	author millert;	state Exp;
branches;
next	1.3;

1.3
date	2000.02.29.01.44.33;	author millert;	state Exp;
branches;
next	1.2;

1.2
date	2000.02.28.23.45.21;	author millert;	state Exp;
branches;
next	1.1;

1.1
date	2000.02.25.19.08.50;	author deraadt;	state Exp;
branches;
next	;


desc
@@


1.33
log
@Present the default choice before the colon in prompts. Matches GNU Emacs
behavior.

From Scott Cheloha <scottcheloha@@gmail.com>

ok florian@@
@
text
@/*	$OpenBSD: re_search.c,v 1.32 2017/05/30 07:05:22 florian Exp $	*/

/* This file is in the public domain. */

/*
 *	regular expression search commands for Mg
 *
 * This file contains functions to implement several of gnuemacs's regular
 * expression functions for Mg.  Several of the routines below are just minor
 * re-arrangements of Mg's non-regular expression search functions.  Some of
 * them are similar in structure to the original MicroEMACS, others are
 * modifications of Rich Ellison's code.  Peter Newton re-wrote about half of
 * them from scratch.
 */

#ifdef REGEX
#include <sys/queue.h>
#include <sys/types.h>
#include <regex.h>
#include <signal.h>
#include <stdio.h>
#include <string.h>

#include "def.h"
#include "macro.h"

#define SRCH_BEGIN	(0)		/* search sub-codes		    */
#define SRCH_FORW	(-1)
#define SRCH_BACK	(-2)
#define SRCH_NOPR	(-3)
#define SRCH_ACCM	(-4)
#define SRCH_MARK	(-5)

#define RE_NMATCH	10		/* max number of matches	    */
#define REPLEN		256		/* max length of replacement string */

char	re_pat[NPAT];			/* regex pattern		    */
int	re_srch_lastdir = SRCH_NOPR;	/* last search flags		    */
int	casefoldsearch = TRUE;		/* does search ignore case?	    */

static int	 re_doreplace(RSIZE, char *);
static int	 re_forwsrch(void);
static int	 re_backsrch(void);
static int	 re_readpattern(char *);
static int	 killmatches(int);
static int	 countmatches(int);

/*
 * Search forward.
 * Get a search string from the user and search for it starting at ".".  If
 * found, move "." to just after the matched characters.  display does all
 * the hard stuff.  If not found, it just prints a message.
 */
/* ARGSUSED */
int
re_forwsearch(int f, int n)
{
	int	s;

	if ((s = re_readpattern("RE Search")) != TRUE)
		return (s);
	if (re_forwsrch() == FALSE) {
		dobeep();
		ewprintf("Search failed: \"%s\"", re_pat);
		return (FALSE);
	}
	re_srch_lastdir = SRCH_FORW;
	return (TRUE);
}

/*
 * Reverse search.
 * Get a search string from the user, and search, starting at "."
 * and proceeding toward the front of the buffer. If found "." is left
 * pointing at the first character of the pattern [the last character that
 * was matched].
 */
/* ARGSUSED */
int
re_backsearch(int f, int n)
{
	int	s;

	if ((s = re_readpattern("RE Search backward")) != TRUE)
		return (s);
	if (re_backsrch() == FALSE) {
		dobeep();
		ewprintf("Search failed: \"%s\"", re_pat);
		return (FALSE);
	}
	re_srch_lastdir = SRCH_BACK;
	return (TRUE);
}

/*
 * Search again, using the same search string and direction as the last search
 * command.  The direction has been saved in "srch_lastdir", so you know which
 * way to go.
 *
 * XXX: This code has problems -- some incompatibility(?) with extend.c causes
 * match to fail when it should not.
 */
/* ARGSUSED */
int
re_searchagain(int f, int n)
{
	if (re_srch_lastdir == SRCH_NOPR) {
		dobeep();
		ewprintf("No last search");
		return (FALSE);
	}
	if (re_srch_lastdir == SRCH_FORW) {
		if (re_forwsrch() == FALSE) {
			dobeep();
			ewprintf("Search failed: \"%s\"", re_pat);
			return (FALSE);
		}
		return (TRUE);
	}
	if (re_srch_lastdir == SRCH_BACK)
		if (re_backsrch() == FALSE) {
			dobeep();
			ewprintf("Search failed: \"%s\"", re_pat);
			return (FALSE);
		}

	return (TRUE);
}

/* Compiled regex goes here-- changed only when new pattern read */
static regex_t		regex_buff;
static regmatch_t	regex_match[RE_NMATCH];

/*
 * Re-Query Replace.
 *	Replace strings selectively.  Does a search and replace operation.
 */
/* ARGSUSED */
int
re_queryrepl(int f, int n)
{
	int	rcnt = 0;		/* replacements made so far	*/
	int	plen, s;		/* length of found string	*/
	char	news[NPAT];		/* replacement string		*/

	if ((s = re_readpattern("RE Query replace")) != TRUE)
		return (s);
	if (eread("Query replace %s with: ", news, NPAT,
	    EFNUL | EFNEW | EFCR, re_pat) == NULL)
		return (ABORT);
	ewprintf("Query replacing %s with %s:", re_pat, news);

	/*
	 * Search forward repeatedly, checking each time whether to insert
	 * or not.  The "!" case makes the check always true, so it gets put
	 * into a tighter loop for efficiency.
	 */
	while (re_forwsrch() == TRUE) {
retry:
		update(CMODE);
		switch (getkey(FALSE)) {
		case ' ':
			plen = regex_match[0].rm_eo - regex_match[0].rm_so;
			if (re_doreplace((RSIZE)plen, news) == FALSE)
				return (FALSE);
			rcnt++;
			break;

		case '.':
			plen = regex_match[0].rm_eo - regex_match[0].rm_so;
			if (re_doreplace((RSIZE)plen, news) == FALSE)
				return (FALSE);
			rcnt++;
			goto stopsearch;

		case CCHR('G'):				/* ^G */
			(void)ctrlg(FFRAND, 0);
			goto stopsearch;
		case CCHR('['):				/* ESC */
		case '`':
			goto stopsearch;
		case '!':
			do {
				plen = regex_match[0].rm_eo - regex_match[0].rm_so;
				if (re_doreplace((RSIZE)plen, news) == FALSE)
					return (FALSE);
				rcnt++;
			} while (re_forwsrch() == TRUE);
			goto stopsearch;

		case CCHR('?'):				/* To not replace */
			break;

		default:
			ewprintf("<SP> replace, [.] rep-end, <DEL> don't, [!] repl rest <ESC> quit");
			goto retry;
		}
	}

stopsearch:
	curwp->w_rflag |= WFFULL;
	update(CMODE);
	if (!inmacro) {
		if (rcnt == 0)
			ewprintf("(No replacements done)");
		else if (rcnt == 1)
			ewprintf("(1 replacement done)");
		else
			ewprintf("(%d replacements done)", rcnt);
	}
	return (TRUE);
}

/*
 * Routine re_doreplace calls lreplace to make replacements needed by
 * re_query replace.  Its reason for existence is to deal with \1, \2. etc.
 *  plen: length to remove
 *  st:   replacement string
 */
static int
re_doreplace(RSIZE plen, char *st)
{
	int	 j, k, s, more, num, state;
	struct line	*clp;
	char	 repstr[REPLEN];

	clp = curwp->w_dotp;
	more = TRUE;
	j = 0;
	state = 0;
	num = 0;

	/* The following FSA parses the replacement string */
	while (more) {
		switch (state) {
		case 0:
			if (*st == '\\') {
				st++;
				state = 1;
			} else if (*st == '\0')
				more = FALSE;
			else {
				repstr[j] = *st;
				j++;
				if (j >= REPLEN)
					return (FALSE);
				st++;
			}
			break;
		case 1:
			if (*st >= '0' && *st <= '9') {
				num = *st - '0';
				st++;
				state = 2;
			} else if (*st == '\0')
				more = FALSE;
			else {
				repstr[j] = *st;
				j++;
				if (j >= REPLEN)
					return (FALSE);
				st++;
				state = 0;
			}
			break;
		case 2:
			if (*st >= '0' && *st <= '9') {
				num = 10 * num + *st - '0';
				st++;
			} else {
				if (num >= RE_NMATCH)
					return (FALSE);
				k = regex_match[num].rm_eo - regex_match[num].rm_so;
				if (j + k >= REPLEN)
					return (FALSE);
				bcopy(&(clp->l_text[regex_match[num].rm_so]),
				    &repstr[j], k);
				j += k;
				if (*st == '\0')
					more = FALSE;
				if (*st == '\\') {
					st++;
					state = 1;
				} else {
					repstr[j] = *st;
					j++;
					if (j >= REPLEN)
						return (FALSE);
					st++;
					state = 0;
				}
			}
			break;
		}		/* switch (state) */
	}			/* while (more)   */

	repstr[j] = '\0';
	s = lreplace(plen, repstr);
	return (s);
}

/*
 * This routine does the real work of a forward search.  The pattern is
 * sitting in the external variable "pat".  If found, dot is updated, the
 * window system is notified of the change, and TRUE is returned.  If the
 * string isn't found, FALSE is returned.
 */
static int
re_forwsrch(void)
{
	int	 tbo, tdotline, error;
	struct line	*clp;

	clp = curwp->w_dotp;
	tbo = curwp->w_doto;
	tdotline = curwp->w_dotline;

	if (tbo == clp->l_used)
		/*
		 * Don't start matching past end of line -- must move to
		 * beginning of next line, unless at end of file.
		 */
		if (clp != curbp->b_headp) {
			clp = lforw(clp);
			tdotline++;
			tbo = 0;
		}
	/*
	 * Note this loop does not process the last line, but this editor
	 * always makes the last line empty so this is good.
	 */
	while (clp != (curbp->b_headp)) {
		regex_match[0].rm_so = tbo;
		regex_match[0].rm_eo = llength(clp);
		error = regexec(&regex_buff, ltext(clp), RE_NMATCH, regex_match,
		    REG_STARTEND);
		if (error != 0) {
			clp = lforw(clp);
			tdotline++;
			tbo = 0;
		} else {
			curwp->w_doto = regex_match[0].rm_eo;
			curwp->w_dotp = clp;
			curwp->w_dotline = tdotline;
			curwp->w_rflag |= WFMOVE;
			return (TRUE);
		}
	}
	return (FALSE);
}

/*
 * This routine does the real work of a backward search.  The pattern is sitting
 * in the external variable "re_pat".  If found, dot is updated, the window
 * system is notified of the change, and TRUE is returned.  If the string isn't
 * found, FALSE is returned.
 */
static int
re_backsrch(void)
{
	struct line		*clp;
	int		 tbo, tdotline;
	regmatch_t	 lastmatch;

	clp = curwp->w_dotp;
	tbo = curwp->w_doto;
	tdotline = curwp->w_dotline;

	/* Start search one position to the left of dot */
	tbo = tbo - 1;
	if (tbo < 0) {
		/* must move up one line */
		clp = lback(clp);
		tdotline--;
		tbo = llength(clp);
	}

	/*
	 * Note this loop does not process the last line, but this editor
	 * always makes the last line empty so this is good.
	 */
	while (clp != (curbp->b_headp)) {
		regex_match[0].rm_so = 0;
		regex_match[0].rm_eo = llength(clp);
		lastmatch.rm_so = -1;
		/*
		 * Keep searching until we don't match any longer.  Assumes a
		 * non-match does not modify the regex_match array.  We have to
		 * do this character-by-character after the first match since
		 * POSIX regexps don't give you a way to do reverse matches.
		 */
		while (!regexec(&regex_buff, ltext(clp), RE_NMATCH, regex_match,
		    REG_STARTEND) && regex_match[0].rm_so < tbo) {
			memcpy(&lastmatch, &regex_match[0], sizeof(regmatch_t));
			regex_match[0].rm_so++;
			regex_match[0].rm_eo = llength(clp);
		}
		if (lastmatch.rm_so == -1) {
			clp = lback(clp);
			tdotline--;
			tbo = llength(clp);
		} else {
			memcpy(&regex_match[0], &lastmatch, sizeof(regmatch_t));
			curwp->w_doto = regex_match[0].rm_so;
			curwp->w_dotp = clp;
			curwp->w_dotline = tdotline;
			curwp->w_rflag |= WFMOVE;
			return (TRUE);
		}
	}
	return (FALSE);
}

/*
 * Read a pattern.
 * Stash it in the external variable "re_pat". The "pat" is
 * not updated if the user types in an empty line. If the user typed
 * an empty line, and there is no old pattern, it is an error.
 * Display the old pattern, in the style of Jeff Lomicka. There is
 * some do-it-yourself control expansion.
 */
static int
re_readpattern(char *re_prompt)
{
	static int	dofree = 0;
	int		flags, error, s;
	char		tpat[NPAT], *rep;

	if (re_pat[0] == '\0')
		rep = eread("%s: ", tpat, NPAT, EFNEW | EFCR, re_prompt);
	else
		rep = eread("%s (default %s): ", tpat, NPAT,
		    EFNUL | EFNEW | EFCR, re_prompt, re_pat);
	if (rep == NULL)
		return (ABORT);
	if (rep[0] != '\0') {
		/* New pattern given */
		(void)strlcpy(re_pat, tpat, sizeof(re_pat));
		if (casefoldsearch)
			flags = REG_EXTENDED | REG_ICASE;
		else
			flags = REG_EXTENDED;
		if (dofree)
			regfree(&regex_buff);
		error = regcomp(&regex_buff, re_pat, flags);
		if (error != 0) {
			char	message[256];
			regerror(error, &regex_buff, message, sizeof(message));
			dobeep();
			ewprintf("Regex Error: %s", message);
			re_pat[0] = '\0';
			return (FALSE);
		}
		dofree = 1;
		s = TRUE;
	} else if (rep[0] == '\0' && re_pat[0] != '\0')
		/* Just using old pattern */
		s = TRUE;
	else
		s = FALSE;
	return (s);
}

/*
 * Cause case to not matter in searches.  This is the default.	If called
 * with argument cause case to matter.
 */
/* ARGSUSED*/
int
setcasefold(int f, int n)
{
	if (f & FFARG) {
		casefoldsearch = FALSE;
		ewprintf("Case-fold-search unset");
	} else {
		casefoldsearch = TRUE;
		ewprintf("Case-fold-search set");
	}

	/*
	 * Invalidate the regular expression pattern since I'm too lazy to
	 * recompile it.
	 */
	re_pat[0] = '\0';
	return (TRUE);
}

/*
 * Delete all lines after dot that contain a string matching regex.
 */
/* ARGSUSED */
int
delmatchlines(int f, int n)
{
	int	s;

	if ((s = re_readpattern("Flush lines (containing match for regexp)"))
	    != TRUE)
		return (s);

	s = killmatches(TRUE);
	return (s);
}

/*
 * Delete all lines after dot that don't contain a string matching regex.
 */
/* ARGSUSED */
int
delnonmatchlines(int f, int n)
{
	int	s;

	if ((s = re_readpattern("Keep lines (containing match for regexp)"))
	    != TRUE)
		return (s);

	s = killmatches(FALSE);
	return (s);
}

/*
 * This function does the work of deleting matching lines.
 */
static int
killmatches(int cond)
{
	int	 s, error;
	int	 count = 0;
	struct line	*clp;

	clp = curwp->w_dotp;
	if (curwp->w_doto == llength(clp))
		/* Consider dot on next line */
		clp = lforw(clp);

	while (clp != (curbp->b_headp)) {
		/* see if line matches */
		regex_match[0].rm_so = 0;
		regex_match[0].rm_eo = llength(clp);
		error = regexec(&regex_buff, ltext(clp), RE_NMATCH, regex_match,
		    REG_STARTEND);

		/* Delete line when appropriate */
		if ((cond == FALSE && error) || (cond == TRUE && !error)) {
			curwp->w_doto = 0;
			curwp->w_dotp = clp;
			count++;
			s = ldelete(llength(clp) + 1, KNONE);
			clp = curwp->w_dotp;
			curwp->w_rflag |= WFMOVE;
			if (s == FALSE)
				return (FALSE);
		} else
			clp = lforw(clp);
	}

	ewprintf("%d line(s) deleted", count);
	if (count > 0)
		curwp->w_rflag |= WFMOVE;

	return (TRUE);
}

/*
 * Count lines matching regex.
 */
/* ARGSUSED */
int
cntmatchlines(int f, int n)
{
	int	s;

	if ((s = re_readpattern("Count lines (matching regexp)")) != TRUE)
		return (s);
	s = countmatches(TRUE);

	return (s);
}

/*
 * Count lines that fail to match regex.
 */
/* ARGSUSED */
int
cntnonmatchlines(int f, int n)
{
	int	s;

	if ((s = re_readpattern("Count lines (not matching regexp)")) != TRUE)
		return (s);
	s = countmatches(FALSE);

	return (s);
}

/*
 * This function does the work of counting matching lines.
 */
int
countmatches(int cond)
{
	int	 error;
	int	 count = 0;
	struct line	*clp;

	clp = curwp->w_dotp;
	if (curwp->w_doto == llength(clp))
		/* Consider dot on next line */
		clp = lforw(clp);

	while (clp != (curbp->b_headp)) {
		/* see if line matches */
		regex_match[0].rm_so = 0;
		regex_match[0].rm_eo = llength(clp);
		error = regexec(&regex_buff, ltext(clp), RE_NMATCH, regex_match,
		    REG_STARTEND);

		/* Count line when appropriate */
		if ((cond == FALSE && error) || (cond == TRUE && !error))
			count++;
		clp = lforw(clp);
	}

	if (cond)
		ewprintf("Number of lines matching: %d", count);
	else
		ewprintf("Number of lines not matching: %d", count);

	return (TRUE);
}
#endif	/* REGEX */
@


1.32
log
@fix -Wshadow warnings.
Found by bcallah, thanks!
@
text
@d1 1
a1 1
/*	$OpenBSD: re_search.c,v 1.31 2015/03/19 21:22:15 bcallah Exp $	*/
d432 1
a432 1
		rep = eread("%s: (default %s) ", tpat, NPAT,
@


1.31
log
@Clean up the includes in mg.
This does the following:
Moves all POSIX headers from sysdef.h into the individual .c files so that
each file now only includes what it needs. All headers are properly sorted.
Moves the remainder of sysdef.h to other files (mostly def.h) and deletes
sysdef.h now that it's no longer contains anything.
Tweak a comment that references sysdef.h so that it no longer does that.
ok florian@@
@
text
@d1 1
a1 1
/*	$OpenBSD: re_search.c,v 1.30 2014/03/20 07:47:29 lum Exp $	*/
d423 1
a423 1
re_readpattern(char *prompt)
d430 1
a430 1
		rep = eread("%s: ", tpat, NPAT, EFNEW | EFCR, prompt);
d433 1
a433 1
		    EFNUL | EFNEW | EFCR, prompt, re_pat);
@


1.30
log
@Add some missing dobeeps.
ok florian@@
@
text
@d1 1
a1 1
/*	$OpenBSD: re_search.c,v 1.29 2013/12/20 18:44:13 florian Exp $	*/
d17 1
a17 2
#include "def.h"

d20 3
d24 1
@


1.29
log
@Set the correct line number after successfully searching with
re-search-{backward,forward}.
OK lum
@
text
@d1 1
a1 1
/*	$OpenBSD: re_search.c,v 1.28 2013/09/24 13:29:51 jasper Exp $	*/
d60 1
d84 1
d105 1
d111 1
d119 1
d446 1
@


1.28
log
@rename re_match to regex_match to prevent a namespace conflict on Linux as
reported by Han Boetes.

while here, rename re_buff accordingly for consistency.

ok florian@@
@
text
@d1 1
a1 1
/*	$OpenBSD: re_search.c,v 1.27 2013/05/31 18:03:45 lum Exp $	*/
d303 1
a303 1
	int	 tbo, error;
d308 1
d317 1
d331 1
d336 1
d354 1
a354 1
	int		 tbo;
d359 1
d366 1
d392 1
d398 1
@


1.27
log
@Make the system bell toggleable via 'audible-bell', and if switched
off, make available an alternative 'visible-bell'.

ok florian@@ jasper@@ Feedback Sunil Nimmagadda.
@
text
@d1 1
a1 1
/*	$OpenBSD: re_search.c,v 1.26 2011/01/21 19:10:13 kjell Exp $	*/
d123 2
a124 2
static regex_t		re_buff;
static regmatch_t	re_match[RE_NMATCH];
d155 1
a155 1
			plen = re_match[0].rm_eo - re_match[0].rm_so;
d162 1
a162 1
			plen = re_match[0].rm_eo - re_match[0].rm_so;
d176 1
a176 1
				plen = re_match[0].rm_eo - re_match[0].rm_so;
d265 1
a265 1
				k = re_match[num].rm_eo - re_match[num].rm_so;
d268 1
a268 1
				bcopy(&(clp->l_text[re_match[num].rm_so]),
d323 3
a325 3
		re_match[0].rm_so = tbo;
		re_match[0].rm_eo = llength(clp);
		error = regexec(&re_buff, ltext(clp), RE_NMATCH, re_match,
d331 1
a331 1
			curwp->w_doto = re_match[0].rm_eo;
d369 2
a370 2
		re_match[0].rm_so = 0;
		re_match[0].rm_eo = llength(clp);
d374 1
a374 1
		 * non-match does not modify the re_match array.  We have to
d378 5
a382 5
		while (!regexec(&re_buff, ltext(clp), RE_NMATCH, re_match,
		    REG_STARTEND) && re_match[0].rm_so < tbo) {
			memcpy(&lastmatch, &re_match[0], sizeof(regmatch_t));
			re_match[0].rm_so++;
			re_match[0].rm_eo = llength(clp);
d388 2
a389 2
			memcpy(&re_match[0], &lastmatch, sizeof(regmatch_t));
			curwp->w_doto = re_match[0].rm_so;
d428 2
a429 2
			regfree(&re_buff);
		error = regcomp(&re_buff, re_pat, flags);
d432 1
a432 1
			regerror(error, &re_buff, message, sizeof(message));
d522 3
a524 3
		re_match[0].rm_so = 0;
		re_match[0].rm_eo = llength(clp);
		error = regexec(&re_buff, ltext(clp), RE_NMATCH, re_match,
d597 3
a599 3
		re_match[0].rm_so = 0;
		re_match[0].rm_eo = llength(clp);
		error = regexec(&re_buff, ltext(clp), RE_NMATCH, re_match,
@


1.26
log
@It volates style(9), but in mg, #include"def.h" goes first. 'twas the way it was built. no binary change here. confirmed by lum@@, tested by Henri Kemppainen
@
text
@d1 1
a1 1
/*	$OpenBSD: re_search.c,v 1.25 2009/06/04 02:23:37 kjell Exp $	*/
d152 1
a152 1
		update();
d194 1
a194 1
	update();
@


1.25
log
@Rename w_flag to w_rflag. This is not a general purpose
flag: it is for redisplay options only. I need an additional all-purpose
flag, so renaming removes the desire to wrongly overload the existing one.

Turdshine. No functional chage.
@
text
@d1 1
a1 1
/*	$OpenBSD: re_search.c,v 1.24 2006/07/25 08:22:32 kjell Exp $	*/
d17 2
a21 1
#include "def.h"
@


1.24
log
@Rename the header line of a buffer to b_headp, from the remarkably
unintuitive b_linep. No binary change.
@
text
@d1 1
a1 1
/*	$OpenBSD: re_search.c,v 1.23 2006/05/28 23:30:16 kjell Exp $	*/
d192 1
a192 1
	curwp->w_flag |= WFFULL;
d332 1
a332 1
			curwp->w_flag |= WFMOVE;
d390 1
a390 1
			curwp->w_flag |= WFMOVE;
d533 1
a533 1
			curwp->w_flag |= WFMOVE;
d542 1
a542 1
		curwp->w_flag |= WFMOVE;
@


1.23
log
@Make Window Flags more mnemonic (and less dumb); i.e.
WFHARD -> WFFULL (Redraw full window)
WFFORCE -> WFFRAME (Reframe window).
No binary change
@
text
@d1 1
a1 1
/*	$OpenBSD: re_search.c,v 1.22 2005/12/13 06:01:27 kjell Exp $	*/
d313 1
a313 1
		if (clp != curbp->b_linep) {
d321 1
a321 1
	while (clp != (curbp->b_linep)) {
d367 1
a367 1
	while (clp != (curbp->b_linep)) {
d519 1
a519 1
	while (clp != (curbp->b_linep)) {
d594 1
a594 1
	while (clp != (curbp->b_linep)) {
@


1.22
log
@More name-clash delinting
@
text
@d1 1
a1 1
/*	$OpenBSD: re_search.c,v 1.21 2005/11/18 20:56:53 deraadt Exp $	*/
d192 1
a192 1
	curwp->w_flag |= WFHARD;
@


1.21
log
@greedy use of typedef struct was making code harder to read; ok kjell cloder
@
text
@d1 1
a1 1
/*	$OpenBSD: re_search.c,v 1.20 2005/11/18 17:35:17 kjell Exp $	*/
d169 1
d450 1
d473 1
d490 1
d550 1
d566 1
@


1.20
log
@Casefold on replace was killed ages ago (it was wrong). Remove a
leftover (unused) variable.
@
text
@d1 1
a1 1
/*	$OpenBSD: re_search.c,v 1.19 2005/10/14 15:41:33 deraadt Exp $	*/
d214 1
a214 1
	LINE	*clp;
d302 1
a302 1
	LINE	*clp;
d347 1
a347 1
	LINE		*clp;
d508 1
a508 1
	LINE	*clp;
d581 1
a581 1
	LINE	*clp;
@


1.19
log
@unused variables
@
text
@d1 1
a1 1
/*	$OpenBSD: re_search.c,v 1.18 2005/08/09 00:53:48 kjell Exp $	*/
d37 1
a37 1
static int	 re_doreplace(RSIZE, char *, int);
a136 4
	/* Casefold check */
	if (!casefoldsearch)
		f = TRUE;

d155 1
a155 1
			if (re_doreplace((RSIZE)plen, news, f) == FALSE)
d162 1
a162 1
			if (re_doreplace((RSIZE)plen, news, f) == FALSE)
d175 1
a175 1
				if (re_doreplace((RSIZE)plen, news, f) == FALSE)
a208 1
 *  f:    case hack disable
d211 1
a211 1
re_doreplace(RSIZE plen, char *st, int f)
d288 1
a288 1
	s = lreplace(plen, repstr, f);
@


1.18
log
@Clean up eread handling in mg. (basically, fallout from the 'enter often
means abort' behaviour added during the hackathon). Eliminates
redundant ereply function, fixes miscellaneous cores when aborting,
and move a number of assumed pathnames into the prompt text, since
they are used there anyway. All changes consistent with emacs behavior

ok beck@@ many, many moons ago.
@
text
@d1 1
a1 1
/*	$OpenBSD: re_search.c,v 1.17 2005/06/14 18:14:40 kjell Exp $	*/
d135 1
a135 1
	char	news[NPAT], *rep;	/* replacement string		*/
d143 2
a144 2
	if ((rep = eread("Query replace %s with: ", news, NPAT,
	    EFNUL | EFNEW | EFCR, re_pat)) == NULL)
@


1.17
log
@Add explicit public domain notices to all public domain files.
ok millert@@, deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: re_search.c,v 1.16 2005/06/14 00:55:45 kjell Exp $	*/
d417 1
a417 1
		rep = ereply("%s: ", tpat, NPAT, prompt);
d421 3
a423 2

	if (rep != NULL && *rep != '\0') {
@


1.16
log
@Three more ereply that should be ereads. This fixes henning's "replace
with null string is busted" observation.

ok henning@@, cloder@@
@
text
@d1 3
a3 1
/*	$OpenBSD: re_search.c,v 1.15 2005/06/05 05:15:56 kjell Exp $	*/
@


1.15
log
@if functions permits null reply from minibuffer, use eread (with
EFNUL), not ereply.
ok cloder
@
text
@d1 1
a1 1
/*	$OpenBSD: re_search.c,v 1.14 2005/04/03 02:09:28 db Exp $	*/
d141 2
a142 2
	if ((rep =
	    ereply("Query replace %s with: ", news, NPAT, re_pat)) == NULL)
@


1.14
log
@This is a no binary change which does:

- spelling, punctuation fixes
- variable declaration lineup
- use parentheses for return and sizeof
- K&R function declarations -> ANSI
- other minor code beautification

ok henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: re_search.c,v 1.13 2004/07/22 01:25:25 vincent Exp $	*/
d417 2
a418 1
		rep = ereply("%s: (default %s) ", tpat, NPAT, prompt, re_pat);
@


1.13
log
@stage 1 of the infinite minibuffer work - add support for on the fly
buffer reallocation in veread().  This commit only changes the API.
All the buffers have exactly the same bounds as before for now.

tested by a couple of my very helpful testers!
@
text
@d1 1
a1 1
/*	$OpenBSD: re_search.c,v 1.12 2003/05/20 03:08:55 cloder Exp $	*/
d66 1
a66 1
 * Get a search string from the	 user, and search, starting at "."
d131 1
a131 1
	int	rcnt = 0;	/* replacements made so far	*/
d203 1
a203 1
	return TRUE;
a294 2


a340 1

a398 1

d421 1
a421 1
		(void)strlcpy(re_pat, tpat, sizeof re_pat);
a468 1

d470 1
a470 1
 * Delete all lines after dot that contain a string matching regex
d486 1
a486 1
 * Delete all lines after dot that don't contain a string matching regex
d502 1
a502 1
 * This function does the work of deleting matching lines
d545 1
a545 1
 * Count lines matching regex
d555 1
d560 1
a560 1
 * Count lines that fail to match regex
a568 1

@


1.12
log
@Finish KNF of prototypes.  That should be all of them.
OK vincent@@
@
text
@d1 1
a1 1
/*	$OpenBSD: re_search.c,v 1.11 2002/02/16 21:27:49 millert Exp $	*/
a130 1
	int	s;
d132 2
a133 2
	int	plen;		/* length of found string	*/
	char	news[NPAT];	/* replacement string		*/
d141 3
a143 5
	if ((s =
	    ereply("Query replace %s with: ", news, NPAT, re_pat)) == ABORT)
		return (s);
	if (s == FALSE)
		news[0] = '\0';
a413 2
	int		s, flags, error;
	char		tpat[NPAT];
d415 2
d419 1
a419 1
		s = ereply("%s: ", tpat, NPAT, prompt);
d421 1
a421 1
		s = ereply("%s: (default %s) ", tpat, NPAT, prompt, re_pat);
d423 1
a423 1
	if (s == TRUE) {
d441 2
a442 1
	} else if (s == FALSE && re_pat[0] != '\0')
d445 2
@


1.11
log
@Part one of userland __P removal.  Done with a simple regexp with some minor hand editing to make comments line up correctly.  Another pass is forthcoming that handles the cases that could not be done automatically.
@
text
@d1 1
a1 1
/*	$OpenBSD: re_search.c,v 1.10 2002/02/13 03:03:49 vincent Exp $	*/
d50 1
a50 2
re_forwsearch(f, n)
	int f, n;
d73 1
a73 2
re_backsearch(f, n)
	int f, n;
d97 1
a97 2
re_searchagain(f, n)
	int f, n;
d129 1
a129 2
re_queryrepl(f, n)
	int f, n;
d212 3
d217 1
a217 4
re_doreplace(plen, st, f)
	RSIZE	plen;	/* length to remove	*/
	char	*st;	/* replacement string	*/
	int	f;	/* case hack disable	*/
d307 1
a307 1
re_forwsrch()
d354 1
a354 1
re_backsrch()
d415 1
a415 2
re_readpattern(prompt)
	char *prompt;
d455 1
a455 2
setcasefold(f, n)
	int f, n;
d478 1
a478 2
delmatchlines(f, n)
	int f, n;
d494 1
a494 2
delnonmatchlines(f, n)
	int f, n;
d510 1
a510 2
killmatches(cond)
	int	cond;
d553 1
a553 2
cntmatchlines(f, n)
	int f, n;
d567 1
a567 2
cntnonmatchlines(f, n)
	int f, n;
d583 1
a583 2
countmatches(cond)
	int cond;
@


1.10
log
@ * Replace unsafe strcpy and strcat calls to safe strlcpy and strlcat.
 * Be a little bit more verbose about some errors
 * Fix some memory leaks in fileio.c

ok deraadt@@, art@@
@
text
@d1 1
a1 1
/*	$OpenBSD: re_search.c,v 1.9 2001/05/24 03:05:25 mickey Exp $	*/
d35 6
a40 6
static int	 re_doreplace	__P((RSIZE, char *, int));
static int	 re_forwsrch	__P((void));
static int	 re_backsrch	__P((void));
static int	 re_readpattern	__P((char *));
static int	 killmatches	__P((int));
static int	 countmatches	__P((int));
@


1.9
log
@spaces
@
text
@d1 1
a1 1
/*	$OpenBSD: re_search.c,v 1.8 2001/05/23 22:20:36 art Exp $	*/
d433 1
a433 1
		(void)strcpy(re_pat, tpat);
@


1.8
log
@remove VOID. We're way beyond the point where this could build with an
ancient compiler.
@
text
@d1 1
a1 1
/*	$OpenBSD: re_search.c,v 1.7 2001/01/29 01:58:09 niklas Exp $	*/
d9 1
a9 1
 * them are similar in structure to the original MicroEMACS, others are 
d44 2
a45 2
 * Get a search string from the user and search for it starting at ".".  If 
 * found, move "." to just after the matched characters.  display does all 
d90 2
a91 2
 * Search again, using the same search string and direction as the last search 
 * command.  The direction has been saved in "srch_lastdir", so you know which 
d113 1
a113 1
	if (re_srch_lastdir == SRCH_BACK) 
d146 1
a146 1
	if ((s = 
d219 3
a221 3
	RSIZE  plen;	/* length to remove	*/
	char  *st;	/* replacement string	*/
	int    f;	/* case hack disable	*/
d276 1
a276 1
				bcopy(&(clp->l_text[re_match[num].rm_so]), 
d305 2
a306 2
 * This routine does the real work of a forward search.  The pattern is 
 * sitting in the external variable "pat".  If found, dot is updated, the 
d335 1
a335 1
		error = regexec(&re_buff, ltext(clp), RE_NMATCH, re_match, 
d353 2
a354 2
 * in the external variable "re_pat".  If found, dot is updated, the window 
 * system is notified of the change, and TRUE is returned.  If the string isn't 
d489 1
a489 1
	if ((s = re_readpattern("Flush lines (containing match for regexp)")) 
d506 1
a506 1
	if ((s = re_readpattern("Keep lines (containing match for regexp)")) 
d514 2
a515 2
/* 
 * This function does the work of deleting matching lines 
d534 1
a534 1
		error = regexec(&re_buff, ltext(clp), RE_NMATCH, re_match, 
d610 1
a610 1
		error = regexec(&re_buff, ltext(clp), RE_NMATCH, re_match, 
@


1.7
log
@$OpenBSD$
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d177 1
a177 1
			(VOID)ctrlg(FFRAND, 0);
d433 1
a433 1
		(VOID)strcpy(re_pat, tpat);
@


1.6
log
@More -Wall anmd KNF, from op2@@tomahawk.SQUiSH.org
@
text
@d1 2
@


1.5
log
@The start of KNF + -Wall.  The code has been run through indent but
needs hand fixup.  I stopped at keymap.c...
@
text
@d2 1
a2 1
 *		regular expression search commands for Mg
d4 6
a9 6
 * This file contains functions to implement several of gnuemacs'
 * regular expression functions for Mg.  Several of the routines
 * below are just minor rearrangements of the Mg non-regular
 * expression search functions.  Hence some of them date back in
 * essential structure to the original MicroEMACS; others are modifications
 * of Rich Ellison's code.  I, Peter Newton, wrote about half from scratch.
d12 1
a12 2

#ifdef	REGEX
d16 2
a17 2
#include	"def.h"
#include	"macro.h"
d19 1
a19 1
#define SRCH_BEGIN	(0)	/* Search sub-codes.	 */
d26 2
a27 1
#define RE_NMATCH	10	/* max number of matches */
d29 10
a38 40
char            re_pat[NPAT];	/* Regex pattern		 */
int             re_srch_lastdir = SRCH_NOPR;	/* Last search flags. */
int             casefoldsearch = TRUE;	/* Does search ignore case ? */

/* Indexed by a character, gives the upper case equivalent of the character */

static char     upcase[0400] =
{000, 001, 002, 003, 004, 005, 006, 007,
	010, 011, 012, 013, 014, 015, 016, 017,
	020, 021, 022, 023, 024, 025, 026, 027,
	030, 031, 032, 033, 034, 035, 036, 037,
	040, 041, 042, 043, 044, 045, 046, 047,
	050, 051, 052, 053, 054, 055, 056, 057,
	060, 061, 062, 063, 064, 065, 066, 067,
	070, 071, 072, 073, 074, 075, 076, 077,
	0100, 0101, 0102, 0103, 0104, 0105, 0106, 0107,
	0110, 0111, 0112, 0113, 0114, 0115, 0116, 0117,
	0120, 0121, 0122, 0123, 0124, 0125, 0126, 0127,
	0130, 0131, 0132, 0133, 0134, 0135, 0136, 0137,
	0140, 0101, 0102, 0103, 0104, 0105, 0106, 0107,
	0110, 0111, 0112, 0113, 0114, 0115, 0116, 0117,
	0120, 0121, 0122, 0123, 0124, 0125, 0126, 0127,
	0130, 0131, 0132, 0173, 0174, 0175, 0176, 0177,
	0200, 0201, 0202, 0203, 0204, 0205, 0206, 0207,
	0210, 0211, 0212, 0213, 0214, 0215, 0216, 0217,
	0220, 0221, 0222, 0223, 0224, 0225, 0226, 0227,
	0230, 0231, 0232, 0233, 0234, 0235, 0236, 0237,
	0240, 0241, 0242, 0243, 0244, 0245, 0246, 0247,
	0250, 0251, 0252, 0253, 0254, 0255, 0256, 0257,
	0260, 0261, 0262, 0263, 0264, 0265, 0266, 0267,
	0270, 0271, 0272, 0273, 0274, 0275, 0276, 0277,
	0300, 0301, 0302, 0303, 0304, 0305, 0306, 0307,
	0310, 0311, 0312, 0313, 0314, 0315, 0316, 0317,
	0320, 0321, 0322, 0323, 0324, 0325, 0326, 0327,
	0330, 0331, 0332, 0333, 0334, 0335, 0336, 0337,
	0340, 0341, 0342, 0343, 0344, 0345, 0346, 0347,
	0350, 0351, 0352, 0353, 0354, 0355, 0356, 0357,
	0360, 0361, 0362, 0363, 0364, 0365, 0366, 0367,
	0370, 0371, 0372, 0373, 0374, 0375, 0376, 0377
};
d42 3
a44 4
 * Get a search string from the user, and search for it,
 * starting at ".". If found, "." gets moved to just after the
 * matched characters, and display does all the hard stuff.
 * If not found, it just prints a message.
d47 1
d49 1
d51 1
a51 1
	register int    s;
d71 1
d73 1
d75 1
a75 1
	register int    s;
a86 2


d88 6
a93 4
 * Search again, using the same search string
 * and direction as the last search command. The direction
 * has been saved in "srch_lastdir", so you know which way
 * to go.
d96 1
a96 4
/*
 * This code has problems-- some incompatibility(?) with extend.c causes
 * match to fail when it should not.
 */
d98 1
a99 1

d111 1
a111 1
	if (re_srch_lastdir == SRCH_BACK) {
d116 2
a117 2
		return (TRUE);
	}
a119 1

d121 2
a122 2
static regex_t  re_buff;
static regmatch_t re_match[RE_NMATCH];
d129 1
d131 1
d133 4
a136 4
	register int    s;
	register int    rcnt = 0;	/* Replacements made so far	 */
	register int    plen;	/* length of found string	 */
	char            news[NPAT];	/* replacement string		 */
d144 2
a145 1
	if ((s = ereply("Query replace %s with: ", news, NPAT, re_pat)) == ABORT)
a155 1

d162 1
a162 1
			if (re_doreplace((RSIZE) plen, news, f) == FALSE)
d169 1
a169 1
			if (re_doreplace((RSIZE) plen, news, f) == FALSE)
d174 3
a176 3
		case CCHR('G'):/* ^G */
			(VOID) ctrlg(FFRAND, 0);
		case CCHR('['):/* ESC */
a178 1

d182 1
a182 1
				if (re_doreplace((RSIZE) plen, news, f) == FALSE)
d188 1
a188 1
		case CCHR('?'):/* To not replace */
d196 1
a210 2


d215 1
a215 4

/* Maximum length of replacement string */
#define REPLEN 256

d217 7
a223 10
	register RSIZE  plen;	/* length to remove	     */
	char           *st;	/* replacement string	     */
	int             f;	/* case hack disable	     */
{
	int             s;
	int             num, k;
	register int    j;
	int             more, state;
	LINE           *clp;
	char            repstr[REPLEN];
d229 1
a233 1

d274 2
a275 1
				bcopy(&(clp->l_text[re_match[num].rm_so]), &repstr[j], k);
d292 2
a293 2
		}		/* end case */
	}			/* end while */
a295 1

a296 1

d303 3
a305 4
 * This routine does the real work of a
 * forward search. The pattern is sitting in the external
 * variable "pat". If found, dot is updated, the window system
 * is notified of the change, and TRUE is returned. If the
d308 1
d311 2
a312 4

	register LINE  *clp;
	register int    tbo;
	int             error, plen;
d319 2
a320 2
		 * Don't start matching off end of line-- must move to
		 * beginning of next line, unless at end
a329 1

a330 1

d333 3
a335 3
		error = regexec(&re_buff, ltext(clp), RE_NMATCH, re_match, REG_STARTEND);

		if (error) {
a343 1

a344 1

a345 1

d350 4
a353 5
 * This routine does the real work of a
 * backward search. The pattern is sitting in the external
 * variable "re_pat". If found, dot is updated, the window system
 * is notified of the change, and TRUE is returned. If the
 * string isn't found, FALSE is returned.
d355 1
d358 3
a360 5

	register LINE  *clp;
	register int    tbo;
	regmatch_t      lastmatch;
	char            m[1];
d372 1
a376 1

a377 1

a392 1

a402 1

a403 1

a404 1

d416 1
d418 1
a418 1
	char           *prompt;
d420 3
a422 5
	int             s;
	int             flags;
	int             error;
	char            tpat[NPAT];
	static int      dofree = 0;
d431 1
a431 1
		(VOID) strcpy(re_pat, tpat);
d439 2
a440 2
		if (error) {
			char            message[256];
a452 2


d457 1
d459 1
a460 1

a472 1

a473 1

d475 1
a475 2

}				/* end setcasefold */
d481 1
d483 1
d485 1
a485 1
	int             s;
d487 2
a488 1
	if ((s = re_readpattern("Flush lines (containing match for regexp)")) != TRUE)
a491 1

a494 2


d498 1
d500 1
d502 1
a502 2
	int             s;

d504 2
a505 1
	if ((s = re_readpattern("Keep lines (containing match for regexp)")) != TRUE)
a508 1

d512 4
a515 3


/* This function does the work of deleting matching lines */
d517 1
a517 1
	int             cond;
d519 3
a521 3
	int             s, error;
	int             count = 0;
	LINE           *clp;
a528 1

d532 2
a533 1
		error = regexec(&re_buff, ltext(clp), RE_NMATCH, re_match, REG_STARTEND);
a555 16

petersfunc(f, n)
{

	int             s;
	LINE           *clp;
	char            c;

	curwp->w_doto = 0;
	s = ldelete(llength(curwp->w_dotp) + 1, KNONE);
	curwp->w_flag |= WFMOVE;
	return (s);

}


d559 1
d561 1
d563 1
a563 1
	int             s;
a566 1

a567 1

a570 2


d574 1
d576 1
d578 1
a578 2
	int             s;

d588 4
a591 3


/* This function does the work of counting matching lines */
d593 1
a593 1
	int             cond;
d595 3
a597 3
	int             s, error;
	int             count = 0;
	LINE           *clp;
a604 1

d608 2
a609 1
		error = regexec(&re_buff, ltext(clp), RE_NMATCH, re_match, REG_STARTEND);
d624 1
a624 1
#endif
@


1.4
log
@Better backwards regexp searching.  POSIX regexp's don't really give
a good way to do this.
@
text
@d2 1
a2 2
 *		regular expression search commands for
 *			   MicroGnuEmacs
d5 4
a8 4
 * regular expression functions for MicroGnuEmacs.  Several of
 * the routines below are just minor rearrangements of the MicroGnuEmacs
 * non-regular expression search functions.  Hence some of them date back
 * in essential structure to the original MicroEMACS; others are modifications
d20 1
a20 1
#define SRCH_BEGIN	(0)			/* Search sub-codes.	*/
d27 1
a27 1
#define RE_NMATCH	10		/* max number of matches */
d29 3
a31 3
char	re_pat[NPAT];			/* Regex pattern		*/
int	re_srch_lastdir = SRCH_NOPR;	 /* Last search flags. */
int	casefoldsearch = TRUE;		 /* Does search ignore case ? */
d35 34
a68 34
static char upcase[0400] =
  { 000, 001, 002, 003, 004, 005, 006, 007,
    010, 011, 012, 013, 014, 015, 016, 017,
    020, 021, 022, 023, 024, 025, 026, 027,
    030, 031, 032, 033, 034, 035, 036, 037,
    040, 041, 042, 043, 044, 045, 046, 047,
    050, 051, 052, 053, 054, 055, 056, 057,
    060, 061, 062, 063, 064, 065, 066, 067,
    070, 071, 072, 073, 074, 075, 076, 077,
    0100, 0101, 0102, 0103, 0104, 0105, 0106, 0107,
    0110, 0111, 0112, 0113, 0114, 0115, 0116, 0117,
    0120, 0121, 0122, 0123, 0124, 0125, 0126, 0127,
    0130, 0131, 0132, 0133, 0134, 0135, 0136, 0137,
    0140, 0101, 0102, 0103, 0104, 0105, 0106, 0107,
    0110, 0111, 0112, 0113, 0114, 0115, 0116, 0117,
    0120, 0121, 0122, 0123, 0124, 0125, 0126, 0127,
    0130, 0131, 0132, 0173, 0174, 0175, 0176, 0177,
    0200, 0201, 0202, 0203, 0204, 0205, 0206, 0207,
    0210, 0211, 0212, 0213, 0214, 0215, 0216, 0217,
    0220, 0221, 0222, 0223, 0224, 0225, 0226, 0227,
    0230, 0231, 0232, 0233, 0234, 0235, 0236, 0237,
    0240, 0241, 0242, 0243, 0244, 0245, 0246, 0247,
    0250, 0251, 0252, 0253, 0254, 0255, 0256, 0257,
    0260, 0261, 0262, 0263, 0264, 0265, 0266, 0267,
    0270, 0271, 0272, 0273, 0274, 0275, 0276, 0277,
    0300, 0301, 0302, 0303, 0304, 0305, 0306, 0307,
    0310, 0311, 0312, 0313, 0314, 0315, 0316, 0317,
    0320, 0321, 0322, 0323, 0324, 0325, 0326, 0327,
    0330, 0331, 0332, 0333, 0334, 0335, 0336, 0337,
    0340, 0341, 0342, 0343, 0344, 0345, 0346, 0347,
    0350, 0351, 0352, 0353, 0354, 0355, 0356, 0357,
    0360, 0361, 0362, 0363, 0364, 0365, 0366, 0367,
    0370, 0371, 0372, 0373, 0374, 0375, 0376, 0377
  };
d77 4
a80 3
/*ARGSUSED*/
re_forwsearch(f, n) {
	register int	s;
d82 1
a82 1
	if ((s=re_readpattern("RE Search")) != TRUE)
d99 4
a102 3
/*ARGSUSED*/
re_backsearch(f, n) {
	register int	s;
d104 1
a104 1
	if ((s=re_readpattern("RE Search backward")) != TRUE)
d122 26
a147 25
/*ARGSUSED*/
/*  This code has problems-- some incompatibility(?) with
    extend.c causes match to fail when it should not.
 */
re_searchagain(f, n) {

  if (re_srch_lastdir == SRCH_NOPR) {
    ewprintf("No last search");
    return (FALSE);
  }

  if (re_srch_lastdir == SRCH_FORW) {
    if (re_forwsrch() == FALSE) {
      ewprintf("Search failed: \"%s\"", re_pat);
      return (FALSE);
    }
    return (TRUE);
  }
  if (re_srch_lastdir == SRCH_BACK) {
    if (re_backsrch() == FALSE) {
      ewprintf("Search failed: \"%s\"", re_pat);
      return (FALSE);
    }
    return (TRUE);
  }
d152 1
a152 1
static regex_t re_buff;
d159 7
a165 6
/*ARGSUSED*/
re_queryrepl(f, n) {
	register int	s;
	register int	rcnt = 0;	/* Replacements made so far	*/
	register int	plen;		/* length of found string	*/
	char		news[NPAT];	/* replacement string		*/
d168 2
a169 1
	if (!casefoldsearch) f = TRUE;
d171 1
a171 1
	if ((s=re_readpattern("RE Query replace")) != TRUE)
d173 1
a173 1
	if ((s=ereply("Query replace %s with: ",news, NPAT, re_pat)) == ABORT)
d186 1
a186 1
	retry:
d203 1
a203 1
		case CCHR('G'): /* ^G */
d205 1
a205 1
		case CCHR('['): /* ESC */
d218 1
a218 1
		case CCHR('?'):		/* To not replace */
d222 1
a222 1
ewprintf("<SP> replace, [.] rep-end, <DEL> don't, [!] repl rest <ESC> quit");
d242 3
a244 3
/* Routine re_doreplace calls lreplace to make replacements needed by
 * re_query replace.  Its reason for existence is to deal with \1,
 * \2. etc.
d251 79
a329 72
     register RSIZE  plen;		     /* length to remove	     */
     char	     *st;		     /* replacement string	     */
     int	     f;			     /* case hack disable	     */
{
  int s;
  int num, k;
  register int j;
  int more, state;
  LINE *clp;
  char repstr[REPLEN];

  clp = curwp->w_dotp;
  more = TRUE;
  j = 0;
  state = 0;

  /* The following FSA parses the replacement string */
  while (more) {
    switch (state) {

    case 0: if (*st == '\\') {
	      st++;
	      state = 1;
	    }
	    else if (*st == '\0')
	      more = FALSE;
	    else {
	      repstr[j] = *st;
	      j++; if (j >= REPLEN) return(FALSE);
	      st++;
	    }
	    break;
    case 1: if (*st >= '0' && *st <= '9') {
	      num = *st - '0';
	      st++;
	      state = 2;
	    }
	    else if (*st == '\0')
	      more = FALSE;
	    else {
	      repstr[j] = *st;
	      j++; if (j >= REPLEN) return(FALSE);
	      st++;
	      state = 0;
	    }
	    break;
    case 2: if (*st >= '0' && *st <= '9') {
	      num = 10*num + *st - '0';
	      st++;
	    }
	    else {
	      if (num >= RE_NMATCH) return(FALSE);
	      k = re_match[num].rm_eo - re_match[num].rm_so;
	      if (j+k >= REPLEN) return(FALSE);
	      bcopy(&(clp->l_text[re_match[num].rm_so]), &repstr[j], k);
	      j += k;
	      if (*st == '\0')
		more = FALSE;
	      if (*st == '\\') {
		st++;
		state = 1;
	      }
	      else {
		repstr[j] = *st;
		j++; if (j >= REPLEN) return(FALSE);
		st++;
		state = 0;
	      }
	    }
	    break;
	  } /* end case */
  } /* end while */
d331 1
a331 1
  repstr[j] = '\0';
d333 1
a333 1
  s = lreplace(plen, repstr, f);
d335 1
a335 1
  return(s);
d347 23
a369 1
re_forwsrch() {
d371 15
a385 36
  register LINE *clp;
  register int tbo;
  int error, plen;

  clp = curwp->w_dotp;
  tbo = curwp->w_doto;

  if (tbo == clp->l_used)
    /* Don't start matching off end of line-- must
     * move to beginning of next line, unless at end
     */
    if (clp != curbp->b_linep) {
      clp = lforw(clp);
      tbo = 0;
    }


  /* Note this loop does not process the last line, but this editor
     always makes the last line empty so this is good.
   */

  while (clp != (curbp->b_linep)) {

     re_match[0].rm_so = tbo;
     re_match[0].rm_eo = llength(clp);
     error = regexec(&re_buff, ltext(clp), RE_NMATCH, re_match, REG_STARTEND);

     if (error) {
       clp = lforw(clp);
       tbo = 0;
     } else {
       curwp->w_doto = re_match[0].rm_eo;
       curwp->w_dotp = clp;
       curwp->w_flag |= WFMOVE;
       return (TRUE);
     }
d387 1
a387 1
   }
d389 1
a389 1
  return(FALSE);
d401 24
a424 1
re_backsrch() {
d426 26
a451 47
  register LINE *clp;
  register int tbo;
  regmatch_t lastmatch;
  char m[1];

  clp = curwp->w_dotp;
  tbo = curwp->w_doto;

  /* Start search one position to the left of dot */
  tbo = tbo - 1;
  if (tbo < 0) {
    /* must move up one line */
    clp = lback(clp);
    tbo = llength(clp);
  }

  /* Note this loop does not process the last line, but this editor
     always makes the last line empty so this is good.
   */

  while (clp != (curbp->b_linep)) {

     re_match[0].rm_so = 0;
     re_match[0].rm_eo = llength(clp);
     lastmatch.rm_so = -1;
     /* Keep searching until we don't match any longer.  Assumes a non-match
        does not modify the re_match array.  We have to do this
	character-by-character after the first match since POSIX regexps don't
	give you a way to do reverse matches.
     */
     while (!regexec(&re_buff, ltext(clp), RE_NMATCH, re_match, REG_STARTEND) &&
	    re_match[0].rm_so < tbo) {
       memcpy(&lastmatch, &re_match[0], sizeof(regmatch_t));
       re_match[0].rm_so++;
       re_match[0].rm_eo = llength(clp);
     }

     if (lastmatch.rm_so == -1) {
       clp = lback(clp);
       tbo = llength(clp);
     } else {
       memcpy(&re_match[0], &lastmatch, sizeof(regmatch_t));
       curwp->w_doto = re_match[0].rm_so;
       curwp->w_dotp = clp;
       curwp->w_flag |= WFMOVE;
       return (TRUE);
     }
d453 1
a453 1
   }
d455 1
a455 1
  return(FALSE);
d468 13
a480 9
re_readpattern(prompt) char *prompt; {
	int s;
	int flags;
	int error;
	char tpat[NPAT];
	static int dofree = 0;

	if (re_pat[0] == '\0') s = ereply("%s: ", tpat, NPAT, prompt);
	else s = ereply("%s: (default %s) ", tpat, NPAT, prompt, re_pat);
d483 20
a502 21
	  /* New pattern given */
	  (VOID) strcpy(re_pat, tpat);
	  if (casefoldsearch)
	    flags = REG_EXTENDED|REG_ICASE;
	  else
	    flags = REG_EXTENDED;
	  if (dofree)
	      regfree(&re_buff);
	  error = regcomp(&re_buff, re_pat, flags);
	  if (error) {
	    char message[256];
	    regerror(error, &re_buff, message, sizeof(message));
	    ewprintf("Regex Error: %s", message);
	    re_pat[0] = '\0';
	    return(FALSE);
	  }
	  dofree = 1;
	}
	else if (s==FALSE && re_pat[0]!='\0')
	  /* Just using old pattern */
	  s = TRUE;
d508 3
a510 2
/* Cause case to not matter in searches.  This is the default.	If
 * called with argument cause case to matter.
d512 2
a513 1
setcasefold(f, n) {
d515 7
a521 8
  if (f & FFARG) {
    casefoldsearch = FALSE;
    ewprintf("Case-fold-search unset");
  }
  else {
    casefoldsearch = TRUE;
    ewprintf("Case-fold-search set");
  }
d523 4
a526 3
  /* Invalidate the regular expression pattern since I'm too lazy
   * to recompile it.
   */
d528 1
a528 1
  re_pat[0] = '\0';
d530 1
a530 1
  return(TRUE);
d532 1
a532 1
} /* end setcasefold */
d535 2
a536 1
/* Delete all lines after dot that contain a string matching regex
d538 3
a540 2
delmatchlines(f, n) {
  int s;
d542 2
a543 2
  if ((s=re_readpattern("Flush lines (containing match for regexp)")) != TRUE)
    return (s);
d545 1
a545 1
  s = killmatches(TRUE);
d547 1
a547 1
  return(s);
d552 2
a553 1
/* Delete all lines after dot that don't contain a string matching regex
d555 3
a557 2
delnonmatchlines(f, n) {
  int s;
d560 2
a561 2
  if ((s=re_readpattern("Keep lines (containing match for regexp)")) != TRUE)
    return (s);
d563 1
a563 1
  s = killmatches(FALSE);
d565 1
a565 1
  return(s);
d572 1
a572 1
   int cond;
d574 29
a602 3
  int s, error;
  int count = 0;
  LINE	*clp;
d604 3
a606 4
  clp = curwp->w_dotp;
  if (curwp->w_doto == llength(clp))
    /* Consider dot on next line */
    clp = lforw(clp);
d608 1
a608 25
  while (clp != (curbp->b_linep)) {

     /* see if line matches */
     re_match[0].rm_so = 0;
     re_match[0].rm_eo = llength(clp);
     error = regexec(&re_buff, ltext(clp), RE_NMATCH, re_match, REG_STARTEND);

     /* Delete line when appropriate */
     if ((cond == FALSE && error) || (cond == TRUE && !error)) {
       curwp->w_doto = 0;
       curwp->w_dotp = clp;
       count++;
       s = ldelete(llength(clp)+1, KNONE);
       clp = curwp->w_dotp;
       curwp->w_flag |= WFMOVE;
       if (s == FALSE) return(FALSE);
     }
     else
       clp = lforw(clp);
   }

  ewprintf("%d line(s) deleted", count);
  if (count > 0) curwp->w_flag |= WFMOVE;

  return(TRUE);
d612 2
a613 1
petersfunc(f, n) {
d615 8
a622 8
  int s;
  LINE	*clp;
  char c;

  curwp->w_doto = 0;
  s = ldelete(llength(curwp->w_dotp)+1, KNONE);
  curwp->w_flag |= WFMOVE;
  return(s);
d627 2
a628 1
/* Count lines matching regex
d630 3
a632 2
cntmatchlines(f, n) {
  int s;
d634 2
a635 2
  if ((s=re_readpattern("Count lines (matching regexp)")) != TRUE)
    return (s);
d637 1
a637 1
  s = countmatches(TRUE);
d639 1
a639 1
  return(s);
d644 2
a645 1
/* Count lines that fail to match regex
d647 3
a649 2
cntnonmatchlines(f, n) {
  int s;
d652 2
a653 2
  if ((s=re_readpattern("Count lines (not matching regexp)")) != TRUE)
    return (s);
d655 1
a655 1
  s = countmatches(FALSE);
d657 1
a657 1
  return(s);
d664 1
a664 1
   int cond;
d666 21
a686 25
  int s, error;
  int count = 0;
  LINE	*clp;

  clp = curwp->w_dotp;
  if (curwp->w_doto == llength(clp))
    /* Consider dot on next line */
    clp = lforw(clp);

  while (clp != (curbp->b_linep)) {

     /* see if line matches */
     re_match[0].rm_so = 0;
     re_match[0].rm_eo = llength(clp);
     error = regexec(&re_buff, ltext(clp), RE_NMATCH, re_match, REG_STARTEND);

     /*	 Count line when appropriate */
     if ((cond == FALSE && error) || (cond == TRUE && !error)) count++;
     clp = lforw(clp);
   }

  if (cond)
     ewprintf("Number of lines matching: %d", count);
  else
     ewprintf("Number of lines not matching: %d", count);
d688 6
a693 1
  return(TRUE);
@


1.3
log
@Make reverse searching work.
@
text
@d414 1
a414 1
     re_match[0].rm_eo = tbo;
d417 3
a419 1
        does not modify the re_match array.
d421 2
a422 1
     while (!regexec(&re_buff, ltext(clp), RE_NMATCH, re_match, REG_STARTEND)) {
d424 2
a425 4
       if (re_match[0].rm_eo >= tbo)
         break;
       re_match[0].rm_so = re_match[0].rm_eo;
       re_match[0].rm_eo = tbo;
@


1.2
log
@Use POSIX extended regular expressions.
Reverse regex searching does not yet work.
@
text
@d393 1
a393 1
  int error, startpos;
d413 13
a425 4
     re_match[0].rm_so = tbo;
     re_match[0].rm_eo = llength(clp);
     /* XXX - does not search backwards! */
     error = regexec(&re_buff, ltext(clp), RE_NMATCH, re_match, REG_STARTEND);
d427 1
a427 1
     if (error) {
d431 1
@


1.1
log
@initial import of mg2a
@
text
@a10 9
 *
 * Although I have nothing to do with the GNU project, these functions
 * require the GNU project's regular expression package (files regex.c and
 * regex.h).  Hence, this file comes under the same copyright notice
 * as the GNU project's code.  As far as I know, the rest of MicroGnuEmacs
 * need not since it may be used independently of any GNU project code.	 In
 * any case, I certainly do not warrant either the correctness or utility
 * of this code.  The GNU project copyright notice follows.  Don't you
 * wish they would make it a bit shorter!
a12 48
/*
GNU Emacs copying permission notice Copyright (C) 1985 Richard M. Stallman
     Verbatim copies of this document, including its copyright notice,
     may be distributed by anyone in any manner.
     Distribution with modifications is not permitted.

GNU Emacs is distributed in the hope that it will be useful,
but without any warranty.  No author or distributor
accepts responsibility to anyone for the consequences of using it
or for whether it serves any particular purpose or works at all,
unless he says so in writing.

Everyone is granted permission to copy, modify and redistribute
GNU Emacs under the following conditions:

   Permission is granted to anyone to make or distribute verbatim copies
   of GNU Emacs source code as received, in any medium, provided that all
   copyright notices and permission and nonwarranty notices are preserved,
   and that the distributor grants the recipient permission
   for further redistribution as permitted by this document,
   and gives him and points out to him an exact copy of this document
   to inform him of his rights.

   Permission is granted to distribute modified versions
   of GNU Emacs source code, or of portions of it,
   under the above conditions, provided also that all
   changed files carry prominent notices stating who last changed them
   and that all the GNU-Emacs-derived material, including everything
   packaged together with it and not independently usable, is
   distributed under the conditions stated in this document.

   Permission is granted to distribute GNU Emacs in
   compiled or executable form under the same conditions applying
   for source code, provided that either
    A.	it is accompanied by the corresponding machine-readable
      source code, or
    B.	it is accompanied by a written offer, with no time limit,
      to give anyone a machine-readable copy of the corresponding
      source code in return for reimbursement of the cost of distribution.
      This written offer must permit verbatim duplication by anyone.
    C.	it is distributed by someone who received only the
      executable form, and is accompanied by a copy of the
      written offer of source code which he received along with it.

In other words, you are welcome to use, share and improve GNU Emacs
You are forbidden to forbid anyone else to use, share and improve
what you give them.   Help stamp out software-hoarding!
*/
d15 3
d28 2
a148 3
#include "regex.h"
#define BYTEWIDTH 8

d150 2
a151 5
static struct re_pattern_buffer re_buff;
static char fastmap[(1 << BYTEWIDTH)];

/* regs holds boundaries of matched text */
static struct re_registers regs;
d186 1
a186 1
			plen = regs.end[0] - regs.start[0];
d193 1
a193 1
			plen = regs.end[0] - regs.start[0];
d207 1
a207 1
				plen = regs.end[0] - regs.start[0];
d298 2
a299 2
	      if (num >= RE_NREGS) return(FALSE);
	      k = regs.end[num] - regs.start[num];
d301 1
a301 1
	      bcopy(&(clp->l_text[regs.start[num]]), &repstr[j], k);
d340 1
a340 2
  int ntries;
  int i, plen;
d361 3
a363 2
     ntries = llength(clp) - tbo;
     i = re_search (&re_buff, ltext(clp), llength(clp), tbo, ntries, &regs);
d365 1
a365 1
     if (i == -1) {
d368 2
a369 3
     }
     else {
       curwp->w_doto = regs.end[0];
d393 2
a394 3
  int ntries;
  int i, startpos;
char m[1];
d413 4
a416 2
     ntries = tbo;
     i = re_search (&re_buff, ltext(clp), llength(clp), tbo, -ntries, &regs);
d418 1
a418 1
     if (i == -1) {
d421 2
a422 3
     }
     else {
       curwp->w_doto = regs.start[0];
d444 3
a446 1
	register int s;
d448 1
a448 1
	char *message;
a455 3
	  re_buff.allocated = 40;
	  re_buff.buffer = (char *) malloc (re_buff.allocated);
	  re_buff.fastmap = fastmap;
d457 1
a457 1
	    re_buff.translate = upcase;
d459 7
a465 3
	    re_buff.translate = '\0';
	  message = re_compile_pattern (re_pat, strlen(re_pat), &re_buff);
	  if (message != '\0') {
d470 1
a470 1
	  re_compile_fastmap (&re_buff);
d540 1
a540 1
  int s, i;
d552 4
a555 2
     i = re_search (&re_buff, ltext(clp), llength(clp), 0, llength(clp),
		    &regs);
d557 1
a557 1
     if ((cond == FALSE && i == -1) || (cond == TRUE && i != -1)) {
d626 1
a626 1
  int s, i;
d638 4
a641 2
     i = re_search (&re_buff, ltext(clp), llength(clp), 0, llength(clp),
		    &regs);
d643 1
a643 1
     if ((cond == FALSE && i == -1) || (cond == TRUE && i != -1)) count++;
@

