head	1.64;
access;
symbols
	OPENBSD_6_1:1.64.0.2
	OPENBSD_6_1_BASE:1.64
	OPENBSD_6_0:1.63.0.4
	OPENBSD_6_0_BASE:1.63
	OPENBSD_5_9:1.63.0.2
	OPENBSD_5_9_BASE:1.63
	OPENBSD_5_8:1.62.0.4
	OPENBSD_5_8_BASE:1.62
	OPENBSD_5_7:1.58.0.2
	OPENBSD_5_7_BASE:1.58
	OPENBSD_5_6:1.55.0.4
	OPENBSD_5_6_BASE:1.55
	OPENBSD_5_5:1.53.0.10
	OPENBSD_5_5_BASE:1.53
	OPENBSD_5_4:1.53.0.6
	OPENBSD_5_4_BASE:1.53
	OPENBSD_5_3:1.53.0.4
	OPENBSD_5_3_BASE:1.53
	OPENBSD_5_2:1.53.0.2
	OPENBSD_5_2_BASE:1.53
	OPENBSD_5_1_BASE:1.51
	OPENBSD_5_1:1.51.0.6
	OPENBSD_5_0:1.51.0.4
	OPENBSD_5_0_BASE:1.51
	OPENBSD_4_9:1.51.0.2
	OPENBSD_4_9_BASE:1.51
	OPENBSD_4_8:1.50.0.16
	OPENBSD_4_8_BASE:1.50
	OPENBSD_4_7:1.50.0.12
	OPENBSD_4_7_BASE:1.50
	OPENBSD_4_6:1.50.0.14
	OPENBSD_4_6_BASE:1.50
	OPENBSD_4_5:1.50.0.10
	OPENBSD_4_5_BASE:1.50
	OPENBSD_4_4:1.50.0.8
	OPENBSD_4_4_BASE:1.50
	OPENBSD_4_3:1.50.0.6
	OPENBSD_4_3_BASE:1.50
	OPENBSD_4_2:1.50.0.4
	OPENBSD_4_2_BASE:1.50
	OPENBSD_4_1:1.50.0.2
	OPENBSD_4_1_BASE:1.50
	OPENBSD_4_0:1.48.0.2
	OPENBSD_4_0_BASE:1.48
	OPENBSD_3_9:1.44.0.2
	OPENBSD_3_9_BASE:1.44
	OPENBSD_3_8:1.35.0.2
	OPENBSD_3_8_BASE:1.35
	OPENBSD_3_7:1.32.0.2
	OPENBSD_3_7_BASE:1.32
	OPENBSD_3_6:1.31.0.2
	OPENBSD_3_6_BASE:1.31
	OPENBSD_3_5:1.30.0.2
	OPENBSD_3_5_BASE:1.30
	OPENBSD_3_4:1.29.0.6
	OPENBSD_3_4_BASE:1.29
	OPENBSD_3_3:1.29.0.4
	OPENBSD_3_3_BASE:1.29
	OPENBSD_3_2:1.29.0.2
	OPENBSD_3_2_BASE:1.29
	OPENBSD_3_1:1.24.0.2
	OPENBSD_3_1_BASE:1.24
	OPENBSD_3_0:1.18.0.2
	OPENBSD_3_0_BASE:1.18
	OPENBSD_2_9_BASE:1.6
	OPENBSD_2_9:1.6.0.2
	OPENBSD_2_8:1.5.0.2
	OPENBSD_2_8_BASE:1.5
	OPENBSD_2_7:1.4.0.2
	OPENBSD_2_7_BASE:1.4;
locks; strict;
comment	@ * @;


1.64
date	2016.09.01.21.06.09;	author lum;	state Exp;
branches;
next	1.63;
commitid	TLwZkEX4xLvahQ3T;

1.63
date	2015.09.29.02.07.49;	author guenther;	state Exp;
branches;
next	1.62;
commitid	CahbaEqQk6XXuFul;

1.62
date	2015.04.12.21.42.18;	author florian;	state Exp;
branches;
next	1.61;
commitid	TMiHyAm4g7UpjZsF;

1.61
date	2015.03.24.22.28.10;	author bcallah;	state Exp;
branches;
next	1.60;
commitid	PCVpTMMH1y45VCt7;

1.60
date	2015.03.19.21.22.15;	author bcallah;	state Exp;
branches;
next	1.59;
commitid	GbEBL4CfPvDkB8hj;

1.59
date	2015.03.17.18.08.52;	author bcallah;	state Exp;
branches;
next	1.58;
commitid	ZNG0kOG8IxZdy28m;

1.58
date	2014.12.06.23.20.17;	author krw;	state Exp;
branches;
next	1.57;
commitid	dHu3Jb8ymJQQ9GXS;

1.57
date	2014.11.16.04.16.41;	author guenther;	state Exp;
branches;
next	1.56;
commitid	a9yG0qCw9VEW27qI;

1.56
date	2014.11.16.00.59.25;	author guenther;	state Exp;
branches;
next	1.55;
commitid	wPiRVLQSgR82vXRT;

1.55
date	2014.04.02.20.32.00;	author lum;	state Exp;
branches;
next	1.54;

1.54
date	2014.03.20.07.47.29;	author lum;	state Exp;
branches;
next	1.53;

1.53
date	2012.05.25.04.56.58;	author lum;	state Exp;
branches;
next	1.52;

1.52
date	2012.04.12.04.47.59;	author lum;	state Exp;
branches;
next	1.51;

1.51
date	2011.01.21.19.10.13;	author kjell;	state Exp;
branches;
next	1.50;

1.50
date	2006.12.30.14.11.06;	author martin;	state Exp;
branches;
next	1.49;

1.49
date	2006.12.21.18.18.13;	author kjell;	state Exp;
branches;
next	1.48;

1.48
date	2006.07.25.08.27.09;	author kjell;	state Exp;
branches;
next	1.47;

1.47
date	2006.07.25.08.22.32;	author kjell;	state Exp;
branches;
next	1.46;

1.46
date	2006.06.01.05.34.52;	author jason;	state Exp;
branches;
next	1.45;

1.45
date	2006.03.30.18.32.07;	author kjell;	state Exp;
branches;
next	1.44;

1.44
date	2005.12.20.06.17.36;	author kjell;	state Exp;
branches;
next	1.43;

1.43
date	2005.12.20.05.04.28;	author kjell;	state Exp;
branches;
next	1.42;

1.42
date	2005.12.13.06.01.27;	author kjell;	state Exp;
branches;
next	1.41;

1.41
date	2005.12.13.05.40.33;	author kjell;	state Exp;
branches;
next	1.40;

1.40
date	2005.11.18.20.56.52;	author deraadt;	state Exp;
branches;
next	1.39;

1.39
date	2005.11.07.23.49.09;	author kjell;	state Exp;
branches;
next	1.38;

1.38
date	2005.11.07.22.52.44;	author kjell;	state Exp;
branches;
next	1.37;

1.37
date	2005.10.14.19.46.46;	author kjell;	state Exp;
branches;
next	1.36;

1.36
date	2005.10.14.15.42.17;	author deraadt;	state Exp;
branches;
next	1.35;

1.35
date	2005.08.09.00.53.48;	author kjell;	state Exp;
branches;
next	1.34;

1.34
date	2005.06.14.18.14.40;	author kjell;	state Exp;
branches;
next	1.33;

1.33
date	2005.04.03.02.09.28;	author db;	state Exp;
branches;
next	1.32;

1.32
date	2005.03.10.16.58.57;	author deraadt;	state Exp;
branches;
next	1.31;

1.31
date	2004.07.22.01.25.25;	author vincent;	state Exp;
branches;
next	1.30;

1.30
date	2003.09.22.23.03.07;	author vincent;	state Exp;
branches;
next	1.29;

1.29
date	2002.09.15.14.48.50;	author vincent;	state Exp;
branches;
next	1.28;

1.28
date	2002.07.03.03.47.59;	author vincent;	state Exp;
branches;
next	1.27;

1.27
date	2002.07.01.14.33.44;	author vincent;	state Exp;
branches;
next	1.26;

1.26
date	2002.06.21.05.37.20;	author vincent;	state Exp;
branches;
next	1.25;

1.25
date	2002.05.29.12.28.45;	author vincent;	state Exp;
branches;
next	1.24;

1.24
date	2002.03.11.13.08.51;	author vincent;	state Exp;
branches;
next	1.23;

1.23
date	2002.03.11.13.02.56;	author vincent;	state Exp;
branches;
next	1.22;

1.22
date	2002.03.10.13.22.56;	author ho;	state Exp;
branches;
next	1.21;

1.21
date	2002.02.16.21.27.49;	author millert;	state Exp;
branches;
next	1.20;

1.20
date	2002.02.14.22.50.43;	author vincent;	state Exp;
branches;
next	1.19;

1.19
date	2002.02.13.03.21.12;	author vincent;	state Exp;
branches;
next	1.18;

1.18
date	2001.07.05.17.36.05;	author matthieu;	state Exp;
branches;
next	1.17;

1.17
date	2001.05.24.10.43.17;	author art;	state Exp;
branches;
next	1.16;

1.16
date	2001.05.24.09.47.33;	author art;	state Exp;
branches;
next	1.15;

1.15
date	2001.05.24.03.05.22;	author mickey;	state Exp;
branches;
next	1.14;

1.14
date	2001.05.23.23.29.47;	author mickey;	state Exp;
branches;
next	1.13;

1.13
date	2001.05.23.22.36.13;	author art;	state Exp;
branches;
next	1.12;

1.12
date	2001.05.23.22.20.35;	author art;	state Exp;
branches;
next	1.11;

1.11
date	2001.05.23.22.12.10;	author art;	state Exp;
branches;
next	1.10;

1.10
date	2001.05.23.20.57.54;	author art;	state Exp;
branches;
next	1.9;

1.9
date	2001.05.23.20.42.46;	author art;	state Exp;
branches;
next	1.8;

1.8
date	2001.05.23.20.19.44;	author art;	state Exp;
branches;
next	1.7;

1.7
date	2001.05.23.16.13.59;	author art;	state Exp;
branches;
next	1.6;

1.6
date	2001.01.29.01.58.07;	author niklas;	state Exp;
branches;
next	1.5;

1.5
date	2000.09.01.14.59.08;	author millert;	state Exp;
branches;
next	1.4;

1.4
date	2000.04.13.06.12.14;	author millert;	state Exp;
branches;
next	1.3;

1.3
date	2000.02.27.16.10.19;	author millert;	state Exp;
branches;
next	1.2;

1.2
date	2000.02.25.19.13.21;	author deraadt;	state Exp;
branches;
next	1.1;

1.1
date	2000.02.25.19.08.47;	author deraadt;	state Exp;
branches;
next	;


desc
@@


1.64
log
@Fix file descriptor leak

    Found by Coverity Scan.  The ffropen() function returns FIODIR when the
    file is a directory.  Check return value on error, in case of directory,
    close the descriptor.

Source Joachim Nilsson, ok sunil@@
@
text
@/*	$OpenBSD: extend.c,v 1.63 2015/09/29 02:07:49 guenther Exp $	*/

/* This file is in the public domain. */

/*
 *	Extended (M-X) commands, rebinding, and	startup file processing.
 */

#include <sys/queue.h>
#include <sys/types.h>
#include <ctype.h>
#include <limits.h>
#include <signal.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#include "chrdef.h"
#include "def.h"
#include "funmap.h"
#include "kbd.h"
#include "key.h"
#include "macro.h"

static int	 remap(KEYMAP *, int, PF, KEYMAP *);
static KEYMAP	*reallocmap(KEYMAP *);
static void	 fixmap(KEYMAP *, KEYMAP *, KEYMAP *);
static int	 dobind(KEYMAP *, const char *, int);
static char	*skipwhite(char *);
static char	*parsetoken(char *);
static int	 bindkey(KEYMAP **, const char *, KCHAR *, int);

/*
 * Insert a string, mainly for use from macros (created by selfinsert).
 */
/* ARGSUSED */
int
insert(int f, int n)
{
	char	 buf[128], *bufp, *cp;
	int	 count, c;

	if (inmacro) {
		while (--n >= 0) {
			for (count = 0; count < maclcur->l_used; count++) {
				if ((((c = maclcur->l_text[count]) == '\n')
				    ? lnewline() : linsert(1, c)) != TRUE)
					return (FALSE);
			}
		}
		maclcur = maclcur->l_fp;
		return (TRUE);
	}
	if (n == 1)
		/* CFINS means selfinsert can tack on the end */
		thisflag |= CFINS;

	if ((bufp = eread("Insert: ", buf, sizeof(buf), EFNEW)) == NULL)
		return (ABORT);
	else if (bufp[0] == '\0')
		return (FALSE);
	while (--n >= 0) {
		cp = buf;
		while (*cp) {
			if (((*cp == '\n') ? lnewline() : linsert(1, *cp))
			    != TRUE)
				return (FALSE);
			cp++;
		}
	}
	return (TRUE);
}

/*
 * Bind a key to a function.  Cases range from the trivial (replacing an
 * existing binding) to the extremely complex (creating a new prefix in a
 * map_element that already has one, so the map_element must be split,
 * but the keymap doesn't have enough room for another map_element, so
 * the keymap is reallocated).	No attempt is made to reclaim space no
 * longer used, if this is a problem flags must be added to indicate
 * malloced versus static storage in both keymaps and map_elements.
 * Structure assignments would come in real handy, but K&R based compilers
 * don't have them.  Care is taken so running out of memory will leave
 * the keymap in a usable state.
 * Parameters are:
 * curmap:  	pointer to the map being changed
 * c:		character being changed
 * funct: 	function being changed to
 * pref_map: 	if funct==NULL, map to bind to or NULL for new
 */
static int
remap(KEYMAP *curmap, int c, PF funct, KEYMAP *pref_map)
{
	int		 i, n1, n2, nold;
	KEYMAP		*mp, *newmap;
	PF		*pfp;
	struct map_element	*mep;

	if (ele >= &curmap->map_element[curmap->map_num] || c < ele->k_base) {
		if (ele > &curmap->map_element[0] && (funct != NULL ||
		    (ele - 1)->k_prefmap == NULL))
			n1 = c - (ele - 1)->k_num;
		else
			n1 = HUGE;
		if (ele < &curmap->map_element[curmap->map_num] &&
		    (funct != NULL || ele->k_prefmap == NULL))
			n2 = ele->k_base - c;
		else
			n2 = HUGE;
		if (n1 <= MAPELEDEF && n1 <= n2) {
			ele--;
			if ((pfp = calloc(c - ele->k_base + 1,
			    sizeof(PF))) == NULL) {
				dobeep();
				ewprintf("Out of memory");
				return (FALSE);
			}
			nold = ele->k_num - ele->k_base + 1;
			for (i = 0; i < nold; i++)
				pfp[i] = ele->k_funcp[i];
			while (--n1)
				pfp[i++] = curmap->map_default;
			pfp[i] = funct;
			ele->k_num = c;
			ele->k_funcp = pfp;
		} else if (n2 <= MAPELEDEF) {
			if ((pfp = calloc(ele->k_num - c + 1,
			    sizeof(PF))) == NULL) {
				dobeep();
				ewprintf("Out of memory");
				return (FALSE);
			}
			nold = ele->k_num - ele->k_base + 1;
			for (i = 0; i < nold; i++)
				pfp[i + n2] = ele->k_funcp[i];
			while (--n2)
				pfp[n2] = curmap->map_default;
			pfp[0] = funct;
			ele->k_base = c;
			ele->k_funcp = pfp;
		} else {
			if (curmap->map_num >= curmap->map_max) {
				if ((newmap = reallocmap(curmap)) == NULL)
					return (FALSE);
				curmap = newmap;
			}
			if ((pfp = malloc(sizeof(PF))) == NULL) {
				dobeep();
				ewprintf("Out of memory");
				return (FALSE);
			}
			pfp[0] = funct;
			for (mep = &curmap->map_element[curmap->map_num];
			    mep > ele; mep--) {
				mep->k_base = (mep - 1)->k_base;
				mep->k_num = (mep - 1)->k_num;
				mep->k_funcp = (mep - 1)->k_funcp;
				mep->k_prefmap = (mep - 1)->k_prefmap;
			}
			ele->k_base = c;
			ele->k_num = c;
			ele->k_funcp = pfp;
			ele->k_prefmap = NULL;
			curmap->map_num++;
		}
		if (funct == NULL) {
			if (pref_map != NULL)
				ele->k_prefmap = pref_map;
			else {
				if ((mp = malloc(sizeof(KEYMAP) +
				    (MAPINIT - 1) * sizeof(struct map_element))) == NULL) {
					dobeep();
					ewprintf("Out of memory");
					ele->k_funcp[c - ele->k_base] =
					    curmap->map_default;
					return (FALSE);
				}
				mp->map_num = 0;
				mp->map_max = MAPINIT;
				mp->map_default = rescan;
				ele->k_prefmap = mp;
			}
		}
	} else {
		n1 = c - ele->k_base;
		if (ele->k_funcp[n1] == funct && (funct != NULL ||
		    pref_map == NULL || pref_map == ele->k_prefmap))
			/* no change */
			return (TRUE);
		if (funct != NULL || ele->k_prefmap == NULL) {
			if (ele->k_funcp[n1] == NULL)
				ele->k_prefmap = NULL;
			/* easy case */
			ele->k_funcp[n1] = funct;
			if (funct == NULL) {
				if (pref_map != NULL)
					ele->k_prefmap = pref_map;
				else {
					if ((mp = malloc(sizeof(KEYMAP) +
					    (MAPINIT - 1) *
					    sizeof(struct map_element))) == NULL) {
						dobeep();
						ewprintf("Out of memory");
						ele->k_funcp[c - ele->k_base] =
						    curmap->map_default;
						return (FALSE);
					}
					mp->map_num = 0;
					mp->map_max = MAPINIT;
					mp->map_default = rescan;
					ele->k_prefmap = mp;
				}
			}
		} else {
			/*
			 * This case is the splits.
			 * Determine which side of the break c goes on
			 * 0 = after break; 1 = before break
			 */
			n2 = 1;
			for (i = 0; n2 && i < n1; i++)
				n2 &= ele->k_funcp[i] != NULL;
			if (curmap->map_num >= curmap->map_max) {
				if ((newmap = reallocmap(curmap)) == NULL)
					return (FALSE);
				curmap = newmap;
			}
			if ((pfp = calloc(ele->k_num - c + !n2,
			    sizeof(PF))) == NULL) {
				dobeep();
				ewprintf("Out of memory");
				return (FALSE);
			}
			ele->k_funcp[n1] = NULL;
			for (i = n1 + n2; i <= ele->k_num - ele->k_base; i++)
				pfp[i - n1 - n2] = ele->k_funcp[i];
			for (mep = &curmap->map_element[curmap->map_num];
			    mep > ele; mep--) {
				mep->k_base = (mep - 1)->k_base;
				mep->k_num = (mep - 1)->k_num;
				mep->k_funcp = (mep - 1)->k_funcp;
				mep->k_prefmap = (mep - 1)->k_prefmap;
			}
			ele->k_num = c - !n2;
			(ele + 1)->k_base = c + n2;
			(ele + 1)->k_funcp = pfp;
			ele += !n2;
			ele->k_prefmap = NULL;
			curmap->map_num++;
			if (pref_map == NULL) {
				if ((mp = malloc(sizeof(KEYMAP) + (MAPINIT - 1)
				    * sizeof(struct map_element))) == NULL) {
					dobeep();
					ewprintf("Out of memory");
					ele->k_funcp[c - ele->k_base] =
					    curmap->map_default;
					return (FALSE);
				}
				mp->map_num = 0;
				mp->map_max = MAPINIT;
				mp->map_default = rescan;
				ele->k_prefmap = mp;
			} else
				ele->k_prefmap = pref_map;
		}
	}
	return (TRUE);
}

/*
 * Reallocate a keymap. Returns NULL (without trashing the current map)
 * on failure.
 */
static KEYMAP *
reallocmap(KEYMAP *curmap)
{
	struct maps_s	*mps;
	KEYMAP	*mp;
	int	 i;

	if (curmap->map_max > SHRT_MAX - MAPGROW) {
		dobeep();
		ewprintf("keymap too large");
		return (NULL);
	}
	if ((mp = malloc(sizeof(KEYMAP) + (curmap->map_max + (MAPGROW - 1)) *
	    sizeof(struct map_element))) == NULL) {
		dobeep();
		ewprintf("Out of memory");
		return (NULL);
	}
	mp->map_num = curmap->map_num;
	mp->map_max = curmap->map_max + MAPGROW;
	mp->map_default = curmap->map_default;
	for (i = curmap->map_num; i--;) {
		mp->map_element[i].k_base = curmap->map_element[i].k_base;
		mp->map_element[i].k_num = curmap->map_element[i].k_num;
		mp->map_element[i].k_funcp = curmap->map_element[i].k_funcp;
		mp->map_element[i].k_prefmap = curmap->map_element[i].k_prefmap;
	}
	for (mps = maps; mps != NULL; mps = mps->p_next) {
		if (mps->p_map == curmap)
			mps->p_map = mp;
		else
			fixmap(curmap, mp, mps->p_map);
	}
	ele = &mp->map_element[ele - &curmap->map_element[0]];
	return (mp);
}

/*
 * Fix references to a reallocated keymap (recursive).
 */
static void
fixmap(KEYMAP *curmap, KEYMAP *mp, KEYMAP *mt)
{
	int	 i;

	for (i = mt->map_num; i--;) {
		if (mt->map_element[i].k_prefmap != NULL) {
			if (mt->map_element[i].k_prefmap == curmap)
				mt->map_element[i].k_prefmap = mp;
			else
				fixmap(curmap, mp, mt->map_element[i].k_prefmap);
		}
	}
}

/*
 * Do the input for local-set-key, global-set-key  and define-key
 * then call remap to do the work.
 */
static int
dobind(KEYMAP *curmap, const char *p, int unbind)
{
	KEYMAP	*pref_map = NULL;
	PF	 funct;
	char	 bprompt[80], *bufp, *pep;
	int	 c, s, n;

	if (macrodef) {
		/*
		 * Keystrokes aren't collected. Not hard, but pretty useless.
		 * Would not work for function keys in any case.
		 */
		dobeep();
		ewprintf("Can't rebind key in macro");
		return (FALSE);
	}
	if (inmacro) {
		for (s = 0; s < maclcur->l_used - 1; s++) {
			if (doscan(curmap, c = CHARMASK(maclcur->l_text[s]), &curmap)
			    != NULL) {
				if (remap(curmap, c, NULL, NULL)
				    != TRUE)
					return (FALSE);
			}
		}
		(void)doscan(curmap, c = maclcur->l_text[s], NULL);
		maclcur = maclcur->l_fp;
	} else {
		n = strlcpy(bprompt, p, sizeof(bprompt));
		if (n >= sizeof(bprompt))
			n = sizeof(bprompt) - 1;
		pep = bprompt + n;
		for (;;) {
			ewprintf("%s", bprompt);
			pep[-1] = ' ';
			pep = getkeyname(pep, sizeof(bprompt) -
			    (pep - bprompt), c = getkey(FALSE));
			if (doscan(curmap, c, &curmap) != NULL)
				break;
			*pep++ = '-';
			*pep = '\0';
		}
	}
	if (unbind)
		funct = rescan;
	else {
		if ((bufp = eread("%s to command: ", bprompt, sizeof(bprompt),
		    EFFUNC | EFNEW, bprompt)) == NULL)
			return (ABORT);
		else if (bufp[0] == '\0')
			return (FALSE);
		if (((funct = name_function(bprompt)) == NULL) ?
		    (pref_map = name_map(bprompt)) == NULL : funct == NULL) {
			dobeep();
			ewprintf("[No match]");
			return (FALSE);
		}
	}
	return (remap(curmap, c, funct, pref_map));
}

/*
 * bindkey: bind key sequence to a function in the specified map.  Used by
 * excline so it can bind function keys.  To close to release to change
 * calling sequence, should just pass KEYMAP *curmap rather than
 * KEYMAP **mapp.
 */
static int
bindkey(KEYMAP **mapp, const char *fname, KCHAR *keys, int kcount)
{
	KEYMAP	*curmap = *mapp;
	KEYMAP	*pref_map = NULL;
	PF	 funct;
	int	 c;

	if (fname == NULL)
		funct = rescan;
	else if (((funct = name_function(fname)) == NULL) ?
	    (pref_map = name_map(fname)) == NULL : funct == NULL) {
		dobeep();
		ewprintf("[No match: %s]", fname);
		return (FALSE);
	}
	while (--kcount) {
		if (doscan(curmap, c = *keys++, &curmap) != NULL) {
			if (remap(curmap, c, NULL, NULL) != TRUE)
				return (FALSE);
			/*
			 * XXX - Bizzarreness. remap creates an empty KEYMAP
			 *       that the last key is supposed to point to.
			 */
			curmap = ele->k_prefmap;
		}
	}
	(void)doscan(curmap, c = *keys, NULL);
	return (remap(curmap, c, funct, pref_map));
}

/*
 * Wrapper for bindkey() that converts escapes.
 */
int
dobindkey(KEYMAP *map, const char *func, const char *str)
{
	int	 i;

	for (i = 0; *str && i < MAXKEY; i++) {
		/* XXX - convert numbers w/ strol()? */
		if (*str == '^' && *(str + 1) !=  '\0') {
			key.k_chars[i] = CCHR(toupper((unsigned char)*++str));
		} else if (*str == '\\' && *(str + 1) != '\0') {
			switch (*++str) {
			case '^':
				key.k_chars[i] = '^';
				break;
			case 't':
			case 'T':
				key.k_chars[i] = '\t';
				break;
			case 'n':
			case 'N':
				key.k_chars[i] = '\n';
				break;
			case 'r':
			case 'R':
				key.k_chars[i] = '\r';
				break;
			case 'e':
			case 'E':
				key.k_chars[i] = CCHR('[');
				break;
			case '\\':
				key.k_chars[i] = '\\';
				break;
			}
		} else
			key.k_chars[i] = *str;
		str++;
	}
	key.k_count = i;
	return (bindkey(&map, func, key.k_chars, key.k_count));
}

/*
 * This function modifies the fundamental keyboard map.
 */
/* ARGSUSED */
int
bindtokey(int f, int n)
{
	return (dobind(fundamental_map, "Global set key: ", FALSE));
}

/*
 * This function modifies the current mode's keyboard map.
 */
/* ARGSUSED */
int
localbind(int f, int n)
{
	return (dobind(curbp->b_modes[curbp->b_nmodes]->p_map,
	    "Local set key: ", FALSE));
}

/*
 * This function redefines a key in any keymap.
 */
/* ARGSUSED */
int
redefine_key(int f, int n)
{
	static char	 buf[48];
	char		 tmp[32], *bufp;
	KEYMAP		*mp;

	(void)strlcpy(buf, "Define key map: ", sizeof(buf));
	if ((bufp = eread("%s", tmp, sizeof(tmp), EFNEW, buf)) == NULL)
		return (ABORT);
	else if (bufp[0] == '\0')
		return (FALSE);
	(void)strlcat(buf, tmp, sizeof(buf));
	if ((mp = name_map(tmp)) == NULL) {
		dobeep();
		ewprintf("Unknown map %s", tmp);
		return (FALSE);
	}
	if (strlcat(buf, "key: ", sizeof(buf)) >= sizeof(buf))
		return (FALSE);

	return (dobind(mp, buf, FALSE));
}

/* ARGSUSED */
int
unbindtokey(int f, int n)
{
	return (dobind(fundamental_map, "Global unset key: ", TRUE));
}

/* ARGSUSED */
int
localunbind(int f, int n)
{
	return (dobind(curbp->b_modes[curbp->b_nmodes]->p_map,
	    "Local unset key: ", TRUE));
}

/*
 * Extended command. Call the message line routine to read in the command
 * name and apply autocompletion to it. When it comes back, look the name
 * up in the symbol table and run the command if it is found.  Print an
 * error if there is anything wrong.
 */
int
extend(int f, int n)
{
	PF	 funct;
	char	 xname[NXNAME], *bufp;

	if (!(f & FFARG))
		bufp = eread("M-x ", xname, NXNAME, EFNEW | EFFUNC);
	else
		bufp = eread("%d M-x ", xname, NXNAME, EFNEW | EFFUNC, n);
	if (bufp == NULL)
		return (ABORT);
	else if (bufp[0] == '\0')
		return (FALSE);
	if ((funct = name_function(bufp)) != NULL) {
		if (macrodef) {
			struct line	*lp = maclcur;
			macro[macrocount - 1].m_funct = funct;
			maclcur = lp->l_bp;
			maclcur->l_fp = lp->l_fp;
			free(lp);
		}
		return ((*funct)(f, n));
	}
	dobeep();
	ewprintf("[No match]");
	return (FALSE);
}

/*
 * Define the commands needed to do startup-file processing.
 * This code is mostly a kludge just so we can get startup-file processing.
 *
 * If you're serious about having this code, you should rewrite it.
 * To wit:
 *	It has lots of funny things in it to make the startup-file look
 *	like a GNU startup file; mostly dealing with parens and semicolons.
 *	This should all vanish.
 *
 * We define eval-expression because it's easy.	 It can make
 * *-set-key or define-key set an arbitrary key sequence, so it isn't
 * useless.
 */

/*
 * evalexpr - get one line from the user, and run it.
 */
/* ARGSUSED */
int
evalexpr(int f, int n)
{
	char	 exbuf[128], *bufp;

	if ((bufp = eread("Eval: ", exbuf, sizeof(exbuf),
	    EFNEW | EFCR)) == NULL)
		return (ABORT);
	else if (bufp[0] == '\0')
		return (FALSE);
	return (excline(exbuf));
}

/*
 * evalbuffer - evaluate the current buffer as line commands. Useful for
 * testing startup files.
 */
/* ARGSUSED */
int
evalbuffer(int f, int n)
{
	struct line		*lp;
	struct buffer		*bp = curbp;
	int		 s;
	static char	 excbuf[128];

	for (lp = bfirstlp(bp); lp != bp->b_headp; lp = lforw(lp)) {
		if (llength(lp) >= 128)
			return (FALSE);
		(void)strncpy(excbuf, ltext(lp), llength(lp));

		/* make sure it's terminated */
		excbuf[llength(lp)] = '\0';
		if ((s = excline(excbuf)) != TRUE)
			return (s);
	}
	return (TRUE);
}

/*
 * evalfile - go get a file and evaluate it as line commands. You can
 *	go get your own startup file if need be.
 */
/* ARGSUSED */
int
evalfile(int f, int n)
{
	char	 fname[NFILEN], *bufp;

	if ((bufp = eread("Load file: ", fname, NFILEN,
	    EFNEW | EFCR)) == NULL)
		return (ABORT);
	else if (bufp[0] == '\0')
		return (FALSE);
	return (load(fname));
}

/*
 * load - go load the file name we got passed.
 */
int
load(const char *fname)
{
	int	 s = TRUE, line, ret;
	int	 nbytes = 0;
	char	 excbuf[128];
	FILE    *ffp;

	if ((fname = adjustname(fname, TRUE)) == NULL)
		/* just to be careful */
		return (FALSE);

	ret = ffropen(&ffp, fname, NULL);
	if (ret != FIOSUC) {
		if (ret == FIODIR)
			(void)ffclose(ffp, NULL);
		return (FALSE);
	}

	line = 0;
	while ((s = ffgetline(ffp, excbuf, sizeof(excbuf) - 1, &nbytes))
	    == FIOSUC) {
		line++;
		excbuf[nbytes] = '\0';
		if (excline(excbuf) != TRUE) {
			s = FIOERR;
			dobeep();
			ewprintf("Error loading file %s at line %d", fname, line);
			break;
		}
	}
	(void)ffclose(ffp, NULL);
	excbuf[nbytes] = '\0';
	if (s != FIOEOF || (nbytes && excline(excbuf) != TRUE))
		return (FALSE);
	return (TRUE);
}

/*
 * excline - run a line from a load file or eval-expression.
 */
int
excline(char *line)
{
	PF	 fp;
	struct line	*lp, *np;
	int	 status, c, f, n;
	char	*funcp, *tmp;
	char	*argp = NULL;
	long	 nl;
	int	 bind;
	KEYMAP	*curmap;
#define BINDARG		0  /* this arg is key to bind (local/global set key) */
#define	BINDNO		1  /* not binding or non-quoted BINDARG */
#define BINDNEXT	2  /* next arg " (define-key) */
#define BINDDO		3  /* already found key to bind */
#define BINDEXT		1  /* space for trailing \0 */

	lp = NULL;

	if (macrodef || inmacro) {
		dobeep();
		ewprintf("Not now!");
		return (FALSE);
	}
	f = 0;
	n = 1;
	funcp = skipwhite(line);
	if (*funcp == '\0')
		return (TRUE);	/* No error on blank lines */
	line = parsetoken(funcp);
	if (*line != '\0') {
		*line++ = '\0';
		line = skipwhite(line);
		if (ISDIGIT(*line) || *line == '-') {
			argp = line;
			line = parsetoken(line);
		}
	}
	if (argp != NULL) {
		f = FFARG;
		nl = strtol(argp, &tmp, 10);
		if (*tmp != '\0')
			return (FALSE);
		if (nl >= INT_MAX || nl <= INT_MIN)
			return (FALSE);
		n = (int)nl;
	}
	if ((fp = name_function(funcp)) == NULL) {
		dobeep();
		ewprintf("Unknown function: %s", funcp);
		return (FALSE);
	}
	if (fp == bindtokey || fp == unbindtokey) {
		bind = BINDARG;
		curmap = fundamental_map;
	} else if (fp == localbind || fp == localunbind) {
		bind = BINDARG;
		curmap = curbp->b_modes[curbp->b_nmodes]->p_map;
	} else if (fp == redefine_key)
		bind = BINDNEXT;
	else
		bind = BINDNO;
	/* Pack away all the args now... */
	if ((np = lalloc(0)) == FALSE)
		return (FALSE);
	np->l_fp = np->l_bp = maclcur = np;
	while (*line != '\0') {
		argp = skipwhite(line);
		if (*argp == '\0')
			break;
		line = parsetoken(argp);
		if (*argp != '"') {
			if (*argp == '\'')
				++argp;
			if ((lp = lalloc((int) (line - argp) + BINDEXT)) ==
			    NULL) {
				status = FALSE;
				goto cleanup;
			}
			bcopy(argp, ltext(lp), (int)(line - argp));
			/* don't count BINDEXT */
			lp->l_used--;
			if (bind == BINDARG)
				bind = BINDNO;
		} else {
			/* quoted strings are special */
			++argp;
			if (bind != BINDARG) {
				lp = lalloc((int)(line - argp) + BINDEXT);
				if (lp == NULL) {
					status = FALSE;
					goto cleanup;
				}
				lp->l_used = 0;
			} else
				key.k_count = 0;
			while (*argp != '"' && *argp != '\0') {
				if (*argp != '\\')
					c = *argp++;
				else {
					switch (*++argp) {
					case 't':
					case 'T':
						c = CCHR('I');
						break;
					case 'n':
					case 'N':
						c = CCHR('J');
						break;
					case 'r':
					case 'R':
						c = CCHR('M');
						break;
					case 'e':
					case 'E':
						c = CCHR('[');
						break;
					case '^':
						/*
						 * split into two statements
						 * due to bug in OSK cpp
						 */
						c = CHARMASK(*++argp);
						c = ISLOWER(c) ?
						    CCHR(TOUPPER(c)) : CCHR(c);
						break;
					case '0':
					case '1':
					case '2':
					case '3':
					case '4':
					case '5':
					case '6':
					case '7':
						c = *argp - '0';
						if (argp[1] <= '7' &&
						    argp[1] >= '0') {
							c <<= 3;
							c += *++argp - '0';
							if (argp[1] <= '7' &&
							    argp[1] >= '0') {
								c <<= 3;
								c += *++argp
								    - '0';
							}
						}
						break;
					case 'f':
					case 'F':
						c = *++argp - '0';
						if (ISDIGIT(argp[1])) {
							c *= 10;
							c += *++argp - '0';
						}
						c += KFIRST;
						break;
					default:
						c = CHARMASK(*argp);
						break;
					}
					argp++;
				}
				if (bind == BINDARG)
					key.k_chars[key.k_count++] = c;
				else
					lp->l_text[lp->l_used++] = c;
			}
			if (*line)
				line++;
		}
		switch (bind) {
		case BINDARG:
			bind = BINDDO;
			break;
		case BINDNEXT:
			lp->l_text[lp->l_used] = '\0';
			if ((curmap = name_map(lp->l_text)) == NULL) {
				dobeep();
				ewprintf("No such mode: %s", lp->l_text);
				status = FALSE;
				free(lp);
				goto cleanup;
			}
			free(lp);
			bind = BINDARG;
			break;
		default:
			lp->l_fp = np->l_fp;
			lp->l_bp = np;
			np->l_fp = lp;
			np = lp;
		}
	}
	switch (bind) {
	default:
		dobeep();
		ewprintf("Bad args to set key");
		status = FALSE;
		break;
	case BINDDO:
		if (fp != unbindtokey && fp != localunbind) {
			lp->l_text[lp->l_used] = '\0';
			status = bindkey(&curmap, lp->l_text, key.k_chars,
			    key.k_count);
		} else
			status = bindkey(&curmap, NULL, key.k_chars,
			    key.k_count);
		break;
	case BINDNO:
		inmacro = TRUE;
		maclcur = maclcur->l_fp;
		status = (*fp)(f, n);
		inmacro = FALSE;
	}
cleanup:
	lp = maclcur->l_fp;
	while (lp != maclcur) {
		np = lp->l_fp;
		free(lp);
		lp = np;
	}
	free(lp);
	maclhead = NULL;
	macrodef = FALSE;
	return (status);
}

/*
 * a pair of utility functions for the above
 */
static char *
skipwhite(char *s)
{
	while (*s == ' ' || *s == '\t' || *s == ')' || *s == '(')
		s++;
	if ((*s == ';') || (*s == '#'))
		*s = '\0';
	return (s);
}

static char *
parsetoken(char *s)
{
	if (*s != '"') {
		while (*s && *s != ' ' && *s != '\t' && *s != ')' && *s != '(')
			s++;
		if (*s == ';')
			*s = '\0';
	} else
		do {
			/*
			 * Strings get special treatment.
			 * Beware: You can \ out the end of the string!
			 */
			if (*s == '\\')
				++s;
		} while (*++s != '"' && *s != '\0');
	return (s);
}
@


1.63
log
@Mark eread(), veread(), and eformat() as printf-like and
Convert eread(buf, a2, a3, a4) to eread("%s", a2, a3, a4, buf)

ok millert@@ lum@@
@
text
@d1 1
a1 1
/*	$OpenBSD: extend.c,v 1.62 2015/04/12 21:42:18 florian Exp $	*/
d658 1
a658 1
	int	 s = TRUE, line;
d667 4
a670 1
	if (ffropen(&ffp, fname, NULL) != FIOSUC)
d672 1
@


1.62
log
@Prevent use after free in definemacro().
When the startup file contains (start-kbd-macro) mg crashes when
executing "start-kbd-macro" two times in the running mg.

The problem is that execline() is cleaning up behind our backs.
Finish the cleanup and make sure mg doesn't think we are in the
middle of a macro definition.

Problem found, tracked down and diff by gsoares@@
Tweaked & OK by me.
Committing on request of gsoares@@ who currently doesn't have good net
to commit.
@
text
@d1 1
a1 1
/*	$OpenBSD: extend.c,v 1.61 2015/03/24 22:28:10 bcallah Exp $	*/
d510 1
a510 1
	if ((bufp = eread(buf, tmp, sizeof(tmp), EFNEW)) == NULL)
@


1.61
log
@unifdef -DBINDKEY -- you can't build mg the other way.
unifdef -UMOVE_STANDOUT -- we had it under an '#ifdef undef' in ttydef.h
also remove those lines from ttydef.h

Set linenos = TRUE instead of an odd #ifdef dance that isn't used anywhere
else.

ok florian@@
@
text
@d1 1
a1 1
/*	$OpenBSD: extend.c,v 1.60 2015/03/19 21:22:15 bcallah Exp $	*/
d914 2
@


1.60
log
@Clean up the includes in mg.
This does the following:
Moves all POSIX headers from sysdef.h into the individual .c files so that
each file now only includes what it needs. All headers are properly sorted.
Moves the remainder of sysdef.h to other files (mostly def.h) and deletes
sysdef.h now that it's no longer contains anything.
Tweak a comment that references sysdef.h so that it no longer does that.
ok florian@@
@
text
@d1 1
a1 1
/*	$OpenBSD: extend.c,v 1.59 2015/03/17 18:08:52 bcallah Exp $	*/
a24 4
#ifndef	BINDKEY
#define	BINDKEY			/* bindkey is used by FKEYS startup code */
#endif /* !BINDKEY */

a30 1
#ifdef	BINDKEY
a31 1
#endif /* BINDKEY */
a400 1
#ifdef	BINDKEY
a475 1
#endif /* BINDKEY */
@


1.59
log
@It is impossible to build mg without both -DFKEYS and -DXKEYS. So let's
enforce that and remove the options.
Mostly mechanical diff from unifdef with bonus removal of comments that no
longer have any relevance.
ok florian@@
@
text
@d1 1
a1 1
/*	$OpenBSD: extend.c,v 1.58 2014/12/06 23:20:17 krw Exp $	*/
a7 4
#include "chrdef.h"
#include "def.h"
#include "kbd.h"
#include "funmap.h"
d9 1
d13 4
d18 5
a24 1
#include "key.h"
@


1.58
log
@A few last 'easy' #include dedups.

ok tedu@@
@
text
@d1 1
a1 1
/*	$OpenBSD: extend.c,v 1.57 2014/11/16 04:16:41 guenther Exp $	*/
a18 1
#ifdef	FKEYS
a22 1
#endif /* FKEYS */
a433 1
#ifdef FKEYS
a477 1
#endif /* FKEYS */
d693 1
a693 3
 * excline - run a line from a load file or eval-expression.  If FKEYS is
 * defined, duplicate functionality of dobind so function key values don't
 * have to fit in type char.
a703 1
#ifdef	FKEYS
a710 3
#else /* FKEYS */
#define BINDEXT		0
#endif /* FKEYS */
a746 1
#ifdef	FKEYS
a756 1
#endif /* FKEYS */
a774 1
#ifdef	FKEYS
a778 1
#endif /* FKEYS */
a781 1
#ifdef	FKEYS
a782 1
#endif /* FKEYS */
a788 1
#ifdef	FKEYS
a790 1
#endif /* FKEYS */
a841 1
#ifdef	FKEYS
a850 1
#endif /* FKEYS */
a856 1
#ifdef	FKEYS
a859 1
#endif /* FKEYS */
a864 1
#ifdef	FKEYS
a881 1
#endif /* FKEYS */
a885 1
#ifdef	FKEYS
a886 1
#endif /* FKEYS */
a887 1
#ifdef	FKEYS
a903 1
#endif /* FKEYS */
a907 1
#ifdef	FKEYS
a908 1
#endif /* FKEYS */
@


1.57
log
@Stop using <sys/param.h>; replace MAXPATHLEN with PATH_MAX, stop using MAX(),
and pull in <limits.h> for *_MAX constants.

inspired on a diff from Kamil Rytarowski (n54 (at) gmx.com)
ok bcallah@@
@
text
@d1 1
a1 1
/*	$OpenBSD: extend.c,v 1.56 2014/11/16 00:59:25 guenther Exp $	*/
a24 2

#include <ctype.h>
@


1.56
log
@ctype macros/functions expect unsigned char values.  Note that the lgetc()
macro does the cast internally like getc() does, so its return should be
put an in int for the same reason.

based on a diff from Kamil Rytarowski (n54 (at) gmx.com)
@
text
@d1 1
a1 1
/*	$OpenBSD: extend.c,v 1.55 2014/04/02 20:32:00 lum Exp $	*/
d15 1
@


1.55
log
@Add the '#' character as a comment character in the startup file.
Include ';' and '#' into man page.  ok deraadt@@ phessler@@
@
text
@d1 1
a1 1
/*	$OpenBSD: extend.c,v 1.54 2014/03/20 07:47:29 lum Exp $	*/
d449 1
a449 1
			key.k_chars[i] = CCHR(toupper(*++str));
@


1.54
log
@Add some missing dobeeps.
ok florian@@
@
text
@d1 1
a1 1
/*	$OpenBSD: extend.c,v 1.53 2012/05/25 04:56:58 lum Exp $	*/
d959 1
a959 1
	if (*s == ';')
@


1.53
log
@Remove static FILE pointer used for handling files in fileio.c. Pass
by reference instead. This allows the mg startup file to open other
files without unexpected things happening.

Discussed with Sunil Nimmagadda.
@
text
@d1 1
a1 1
/*	$OpenBSD: extend.c,v 1.52 2012/04/12 04:47:59 lum Exp $	*/
d118 1
d133 1
d152 1
d176 1
d206 1
d234 1
d257 1
d286 1
d292 1
d350 1
d391 1
d418 1
d524 1
d579 1
d685 1
d726 1
d754 1
d896 1
d918 1
@


1.52
log
@Remove the conditional directives NO_MACRO and NO_STARTUP.
They have not compiled for numerous years.
ok kjell@@ millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: extend.c,v 1.51 2011/01/21 19:10:13 kjell Exp $	*/
d655 1
d661 1
a661 1
	if (ffropen(fname, NULL) != FIOSUC)
d665 2
a666 1
	while ((s = ffgetline(excbuf, sizeof(excbuf) - 1, &nbytes)) == FIOSUC) {
d675 1
a675 1
	(void)ffclose(NULL);
@


1.51
log
@It volates style(9), but in mg, #include"def.h" goes first. 'twas the way it was built. no binary change here. confirmed by lum@@, tested by Henri Kemppainen
@
text
@d1 1
a1 1
/*	$OpenBSD: extend.c,v 1.50 2006/12/30 14:11:06 martin Exp $	*/
a15 1
#ifndef NO_MACRO
a16 1
#endif /* !NO_MACRO */
a19 1
#ifndef	NO_STARTUP
a22 1
#endif /* !NO_STARTUP */
a44 1
#ifndef NO_MACRO
d61 1
a61 1
#endif /* !NO_MACRO */
a335 1
#ifndef NO_MACRO
a343 1
#ifndef NO_STARTUP
a355 2
#endif /* !NO_STARTUP */
#endif /* !NO_MACRO */
a369 1
#ifndef NO_STARTUP
a370 1
#endif /* !NO_STARTUP */
a556 1
#ifndef NO_MACRO
a563 1
#endif /* !NO_MACRO */
a569 1
#ifndef NO_STARTUP
a961 1
#endif /* !NO_STARTUP */
@


1.50
log
@one more 'verses'->'versus' typo in comment
@
text
@d1 1
a1 1
/*	$OpenBSD: extend.c,v 1.49 2006/12/21 18:18:13 kjell Exp $	*/
a7 3
#include <sys/types.h>
#include <ctype.h>

d12 3
@


1.49
log
@Fix a realloc-style bug (curmap = reallocmap(curmap)) in
keymap repapping.
spotted by theo
@
text
@d1 1
a1 1
/*	$OpenBSD: extend.c,v 1.48 2006/07/25 08:27:09 kjell Exp $	*/
d90 1
a90 1
 * malloced verses static storage in both keymaps and map_elements.
@


1.48
log
@Add bfirstlp(), blastlp() macros, returning the first and last lines
of a buffer respectively. Removes an ugly construction than necessitated
"go to first line"-type comments throughout the code.
No binary change
@
text
@d1 1
a1 1
/*	$OpenBSD: extend.c,v 1.47 2006/07/25 08:22:32 kjell Exp $	*/
d94 5
d101 1
a101 4
remap(KEYMAP *curmap,		/* pointer to the map being changed */
    int c,			/* character being changed */
    PF funct,			/* function being changed to */
    KEYMAP *pref_map)		/* if funct==NULL, map to bind to or NULL for new */
d227 5
a231 3
			if (curmap->map_num >= curmap->map_max &&
			    (curmap = reallocmap(curmap)) == NULL)
				return (FALSE);
d273 2
a274 1
 * Reallocate a keymap, used above.
@


1.47
log
@Rename the header line of a buffer to b_headp, from the remarkably
unintuitive b_linep. No binary change.
@
text
@d1 1
a1 1
/*	$OpenBSD: extend.c,v 1.46 2006/06/01 05:34:52 jason Exp $	*/
d624 1
a624 1
	for (lp = lforw(bp->b_headp); lp != bp->b_headp; lp = lforw(lp)) {
@


1.46
log
@make // /~ path rewriting optional in adjustname() and use it everywhere
except for the command line specified files.  ok kjell,cloder
@
text
@d1 1
a1 1
/*	$OpenBSD: extend.c,v 1.45 2006/03/30 18:32:07 kjell Exp $	*/
d624 1
a624 1
	for (lp = lforw(bp->b_linep); lp != bp->b_linep; lp = lforw(lp)) {
@


1.45
log
@Clean up some allocations. Remove malloc casts, and some easy
malloc(A*B)->calloc changes.
@
text
@d1 1
a1 1
/*	$OpenBSD: extend.c,v 1.44 2005/12/20 06:17:36 kjell Exp $	*/
d665 1
a665 1
	if ((fname = adjustname(fname)) == NULL)
@


1.44
log
@Clean up the ugly casted frees. In one case, this meant eliminating a nasty
struct/union/casting nightmare when building the list of names for filename
completion. In particular, be consistent about strduping and freeing
the list data.
@
text
@d1 1
a1 1
/*	$OpenBSD: extend.c,v 1.43 2005/12/20 05:04:28 kjell Exp $	*/
d8 3
a15 2
#include <ctype.h>

d119 1
a119 1
			if ((pfp = (PF *)malloc((c - ele->k_base + 1) *
d133 1
a133 1
			if ((pfp = (PF *)malloc((ele->k_num - c + 1) *
d174 1
a174 1
				if ((mp = (KEYMAP *)malloc(sizeof(KEYMAP) +
d228 1
a228 1
			if ((pfp = malloc((ele->k_num - c + !n2) *
d278 6
a283 3
	if ((mp = (KEYMAP *)malloc((unsigned)(sizeof(KEYMAP) +
	    (curmap->map_max + (MAPGROW - 1)) *
	    sizeof(struct map_element)))) == NULL) {
@


1.43
log
@Do some delinting of strl-type functions. Also, remove a superfluous
word in the undo-list.
@
text
@d1 1
a1 1
/*	$OpenBSD: extend.c,v 1.42 2005/12/13 06:01:27 kjell Exp $	*/
d565 1
a565 1
			free((char *)lp);
d884 1
a884 1
				free((char *)lp);
d887 1
a887 1
			free((char *)lp);
d928 1
a928 1
		free((char *)lp);
d931 1
a931 1
	free((char *)lp);
@


1.42
log
@More name-clash delinting
@
text
@d1 1
a1 1
/*	$OpenBSD: extend.c,v 1.41 2005/12/13 05:40:33 kjell Exp $	*/
d507 1
a507 1
	strlcpy(buf, "Define key map: ", sizeof(buf));
d517 2
a518 1
	strlcat(buf, "key: ", sizeof(buf));
@


1.41
log
@do some silly de-linting
@
text
@d1 1
a1 1
/*	$OpenBSD: extend.c,v 1.40 2005/11/18 20:56:52 deraadt Exp $	*/
d363 1
a363 1
			pep = keyname(pep, sizeof(bprompt) -
d501 1
a501 1
define_key(int f, int n)
d750 1
a750 1
	} else if (fp == define_key)
@


1.40
log
@greedy use of typedef struct was making code harder to read; ok kjell cloder
@
text
@d1 1
a1 1
/*	$OpenBSD: extend.c,v 1.39 2005/11/07 23:49:09 kjell Exp $	*/
d329 1
a329 1
	char	 prompt[80], *bufp, *pep;
d356 4
a359 4
		n = strlcpy(prompt, p, sizeof(prompt));
		if (n >= sizeof(prompt))
			n = sizeof(prompt) - 1;
		pep = prompt + n;
d361 1
a361 1
			ewprintf("%s", prompt);
d363 2
a364 2
			pep = keyname(pep, sizeof(prompt) - (pep - prompt),
			    c = getkey(FALSE));
d376 2
a377 2
		if ((bufp = eread("%s to command: ", prompt, sizeof(prompt),
		    EFFUNC | EFNEW, prompt)) == NULL)
d381 2
a382 2
		if (((funct = name_function(prompt)) == NULL) ?
		    (pref_map = name_map(prompt)) == NULL : funct == NULL) {
@


1.39
log
@add missing ctype.h
@
text
@d1 1
a1 1
/*	$OpenBSD: extend.c,v 1.38 2005/11/07 22:52:44 kjell Exp $	*/
d103 1
a103 1
	MAP_ELEMENT	*mep;
d174 1
a174 1
				    (MAPINIT - 1) * sizeof(MAP_ELEMENT))) == NULL) {
d203 1
a203 1
					    sizeof(MAP_ELEMENT))) == NULL) {
d250 1
a250 1
				    * sizeof(MAP_ELEMENT))) == NULL) {
d273 1
a273 1
	MAPS	*mps;
d279 1
a279 1
	    sizeof(MAP_ELEMENT)))) == NULL) {
d560 1
a560 1
			LINE	*lp = maclcur;
d614 2
a615 2
	LINE		*lp;
	BUFFER		*bp = curbp;
d693 1
a693 1
	LINE	*lp, *np;
@


1.38
log
@Allow ctrl-key patterns ("^X^C") in keybind function. Will
allow more modularization of keymaps later.
Also, improved error checking suggested by cloder.
@
text
@d1 1
a1 1
/*	$OpenBSD: extend.c,v 1.37 2005/10/14 19:46:46 kjell Exp $	*/
d12 2
@


1.37
log
@add missing /* ARGSUSED */ to quiet lint.
@
text
@d1 1
a1 1
/*	$OpenBSD: extend.c,v 1.36 2005/10/14 15:42:17 deraadt Exp $	*/
d26 2
d436 3
a438 3
		if (*str != '\\')
			key.k_chars[i] = *str;
		else {
d440 3
d459 3
d463 2
a464 1
		}
@


1.36
log
@put proto in same #ifdef as code
@
text
@d1 1
a1 1
/*	$OpenBSD: extend.c,v 1.35 2005/08/09 00:53:48 kjell Exp $	*/
d511 1
d518 1
@


1.35
log
@Clean up eread handling in mg. (basically, fallout from the 'enter often
means abort' behaviour added during the hackathon). Eliminates
redundant ereply function, fixes miscellaneous cores when aborting,
and move a number of assumed pathnames into the prompt text, since
they are used there anyway. All changes consistent with emacs behavior

ok beck@@ many, many moons ago.
@
text
@d1 1
a1 1
/*	$OpenBSD: extend.c,v 1.34 2005/06/14 18:14:40 kjell Exp $	*/
d32 1
d34 1
@


1.34
log
@Add explicit public domain notices to all public domain files.
ok millert@@, deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: extend.c,v 1.33 2005/04/03 02:09:28 db Exp $	*/
d370 2
a371 2
		if ((bufp = eread("%s to command: ", prompt, 80, EFFUNC | EFNEW,
		    prompt)) == NULL)
d499 1
a499 1
	strlcat(buf, tmp, sizeof(buf));
d583 2
a584 1
	if ((bufp = ereply("Eval: ", exbuf, sizeof(exbuf))) == NULL)
d627 2
a628 1
	if ((bufp = ereply("Load file: ", fname, NFILEN)) == NULL)
@


1.33
log
@This is a no binary change which does:

- spelling, punctuation fixes
- variable declaration lineup
- use parentheses for return and sizeof
- K&R function declarations -> ANSI
- other minor code beautification

ok henning@@
@
text
@d1 3
a3 1
/*	$OpenBSD: extend.c,v 1.32 2005/03/10 16:58:57 deraadt Exp $	*/
@


1.32
log
@spacing
@
text
@d1 1
a1 1
/*	$OpenBSD: extend.c,v 1.31 2004/07/22 01:25:25 vincent Exp $	*/
d33 1
a33 1
 * Insert a string, mainly for use from macros (created by selfinsert)
d48 1
a48 1
					return FALSE;
d52 1
a52 1
		return TRUE;
d59 1
a59 1
		return ABORT;
d61 1
a61 1
		return FALSE;
d67 1
a67 1
				return FALSE;
d71 1
a71 1
	return TRUE;
d76 1
a76 1
 * existing binding) to the extremly complex (creating a new prefix in a
d113 1
a113 1
				return FALSE;
d127 1
a127 1
				return FALSE;
d140 1
a140 1
					return FALSE;
d145 1
a145 1
				return FALSE;
d170 1
a170 1
					return FALSE;
d183 1
a183 1
			return TRUE;
d199 1
a199 1
						return FALSE;
d218 1
a218 1
				return FALSE;
d222 1
a222 1
				return FALSE;
d246 1
a246 1
					return FALSE;
d256 1
a256 1
	return TRUE;
d265 1
a265 1
	MAPS *mps;
d273 1
a273 1
		return NULL;
d291 1
a291 1
	return mp;
d313 1
a313 1
 * do the input for local-set-key, global-set-key  and define-key
d321 1
a321 2
	char	 prompt[80], *bufp;
	char	*pep;
d331 1
a331 1
		return FALSE;
d340 1
a340 1
					return FALSE;
d348 3
a350 3
		n = strlcpy(prompt, p, sizeof prompt);
		if (n >= sizeof prompt)
			n = sizeof prompt - 1;
d370 1
a370 1
			return ABORT;
d372 1
a372 1
			return FALSE;
d376 1
a376 1
			return FALSE;
d379 1
a379 1
	return remap(curmap, c, funct, pref_map);
d402 1
a402 1
		return FALSE;
d407 1
a407 1
				return FALSE;
d416 1
a416 1
	return remap(curmap, c, funct, pref_map);
d467 1
a467 1
	return dobind(fundamental_map, "Global set key: ", FALSE);
d477 2
a478 2
	return dobind(curbp->b_modes[curbp->b_nmodes]->p_map,
	    "Local set key: ", FALSE);
d488 7
a494 7
	static char buf[48];
	char tmp[32], *bufp;
	KEYMAP *mp;

	strlcpy(buf, "Define key map: ", sizeof buf);
	if ((bufp = eread(buf, tmp, sizeof tmp, EFNEW)) == NULL)
		return ABORT;
d496 2
a497 2
		return FALSE;
	strlcat(buf, tmp, sizeof buf);
d500 1
a500 1
		return FALSE;
d502 1
a502 1
	strlcat(buf, "key: ", sizeof buf);
d504 1
a504 1
	return dobind(mp, buf, FALSE);
d510 1
a510 1
	return dobind(fundamental_map, "Global unset key: ", TRUE);
d516 2
a517 2
	return dobind(curbp->b_modes[curbp->b_nmodes]->p_map,
	    "Local unset key: ", TRUE);
d537 1
a537 1
		return ABORT;
d539 1
a539 1
		return FALSE;
d550 1
a550 1
		return (*funct)(f, n);
d553 1
a553 1
	return FALSE;
d582 1
a582 1
		return ABORT;
d584 2
a585 2
		return FALSE;
	return excline(exbuf);
d603 1
a603 1
			return FALSE;
d609 1
a609 1
			return s;
d611 1
a611 1
	return TRUE;
d625 1
a625 1
		return ABORT;
d627 2
a628 2
		return FALSE;
	return load(fname);
d643 1
a643 1
		return FALSE;
d646 1
a646 1
		return FALSE;
d661 2
a662 2
		return FALSE;
	return TRUE;
d666 2
a667 2
 * excline - run a line from a load file or eval-expression.  if FKEYS is
 * defined, duplicate functionallity of dobind so function key values don't
d695 1
a695 1
		return FALSE;
d701 1
a701 1
		return TRUE;	/* No error on blank lines */
d715 1
a715 1
			return FALSE;
d717 1
a717 1
			return FALSE;
d722 1
a722 1
		return FALSE;
d738 1
a738 1
		return FALSE;
d773 1
a773 1
			} else {
a774 1
			}
d891 1
a891 1
		} else {
a893 1
		}
d912 1
a912 1
	return status;
d925 1
a925 1
	return s;
d945 1
a945 1
	return s;
@


1.31
log
@stage 1 of the infinite minibuffer work - add support for on the fly
buffer reallocation in veread().  This commit only changes the API.
All the buffers have exactly the same bounds as before for now.

tested by a couple of my very helpful testers!
@
text
@d1 1
a1 1
/*	$OpenBSD: extend.c,v 1.30 2003/09/22 23:03:07 vincent Exp $	*/
d88 3
a90 5
      int c,			/* character being changed */
      PF funct,			/* function being changed to */
      KEYMAP *pref_map		/* if funct==NULL, map to bind to or
				   NULL for new */
      )
@


1.30
log
@fix leak on realloc failure

ok henning tedu
@
text
@d1 1
a1 1
/*	$OpenBSD: extend.c,v 1.29 2002/09/15 14:48:50 vincent Exp $	*/
d39 1
a39 2
	char	*cp;
	char	 buf[128];
d58 3
a60 1
	if (eread("Insert: ", buf, sizeof(buf), EFNEW) == FALSE)
d323 1
a323 1
	char	 prompt[80];
d371 5
a375 3
		if ((s = eread("%s to command: ", prompt, 80, EFFUNC | EFNEW,
		    prompt)) != TRUE)
			return s;
d492 1
a492 1
	char tmp[32];
d496 3
a498 1
	if (eread(buf, tmp, sizeof tmp, EFNEW) != TRUE)
d533 1
a533 2
	int	 s;
	char	 xname[NXNAME];
d536 1
a536 1
		s = eread("M-x ", xname, NXNAME, EFNEW | EFFUNC);
d538 6
a543 4
		s = eread("%d M-x ", xname, NXNAME, EFNEW | EFFUNC, n);
	if (s != TRUE)
		return s;
	if ((funct = name_function(xname)) != NULL) {
d582 1
a582 2
	int	 s;
	char	 exbuf[128];
d584 4
a587 2
	if ((s = ereply("Eval: ", exbuf, 128)) != TRUE)
		return s;
d625 1
a625 2
	int	 s;
	char	 fname[NFILEN];
d627 4
a630 2
	if ((s = ereply("Load file: ", fname, NFILEN)) != TRUE)
		return s;
@


1.29
log
@ rename realocmap to reallocmap, plus some style.

 ok art@@
@
text
@d1 1
a1 1
/*	$OpenBSD: extend.c,v 1.28 2002/07/03 03:47:59 vincent Exp $	*/
d94 1
a94 1
	KEYMAP		*mp;
d139 5
a143 3
			if (curmap->map_num >= curmap->map_max &&
			    (curmap = reallocmap(curmap)) == NULL)
				return FALSE;
@


1.28
log
@ a few missing tests for malloc()'s return value.

 ok art@@
@
text
@d1 1
a1 1
/*	$OpenBSD: extend.c,v 1.27 2002/07/01 14:33:44 vincent Exp $	*/
d25 1
a25 1
static KEYMAP	*realocmap(KEYMAP *);
d140 1
a140 1
			    (curmap = realocmap(curmap)) == NULL)
d161 1
a161 1
			if (pref_map != NULL) {
d163 3
a165 3
			} else {
				if (!(mp = (KEYMAP *)malloc(sizeof(KEYMAP) +
				    (MAPINIT - 1) * sizeof(MAP_ELEMENT)))) {
d216 1
a216 1
			    (curmap = realocmap(curmap)) == NULL)
d262 1
a262 1
realocmap(KEYMAP *curmap)
@


1.27
log
@KNF + ansi; from zyrnix (only the easy part of his diffs)
@
text
@d1 1
a1 1
/*	$OpenBSD: extend.c,v 1.26 2002/06/21 05:37:20 vincent Exp $	*/
d192 1
a192 1
					if (!(mp = malloc(sizeof(KEYMAP) +
d194 1
a194 1
					    sizeof(MAP_ELEMENT)))) {
@


1.26
log
@fix bad usage of strlcpy()'s return value. (made pointers point
beyond the boundaries of buffers)

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: extend.c,v 1.25 2002/05/29 12:28:45 vincent Exp $	*/
d510 1
a510 2
localunbind(f, n)
	int f, n;
@


1.25
log
@ show the line number in the config file when we find an error.

 ok art@@
@
text
@d1 1
a1 1
/*	$OpenBSD: extend.c,v 1.24 2002/03/11 13:08:51 vincent Exp $	*/
d322 1
a322 1
	int	 c, s;
d348 4
a351 1
		pep = prompt + strlcpy(prompt, p, sizeof(prompt));
@


1.24
log
@ remove errno=0 assignments, we don't need these with Hakan's code
@
text
@d1 1
a1 1
/*	$OpenBSD: extend.c,v 1.23 2002/03/11 13:02:56 vincent Exp $	*/
d628 1
a628 1
	int	 s = TRUE;
d639 1
d641 1
d645 1
a645 1
			ewprintf("Error loading file %s", fname);
@


1.23
log
@  * Move to ANSI function definitions.
  * Add a whole lot of consts where I thought it made sense

   no ok, but no objections either...
@
text
@d1 1
a1 1
/*	$OpenBSD: extend.c,v 1.22 2002/03/10 13:22:56 ho Exp $	*/
a701 1
		errno = 0;
@


1.22
log
@Better long vs int. millert@@ ok.
@
text
@d1 1
a1 1
/*	$OpenBSD: extend.c,v 1.21 2002/02/16 21:27:49 millert Exp $	*/
d27 1
a27 1
static int	 dobind(KEYMAP *, char *, int);
d30 1
a30 1
static int	 bindkey(KEYMAP **, char *, KCHAR *, int);
d37 1
a37 2
insert(f, n)
	int f, n;
d86 4
a89 5
remap(curmap, c, funct, pref_map)
	KEYMAP	*curmap;	/* pointer to the map being changed */
	int	c;		/* character being changed */
	PF	funct;		/* function being changed to */
	KEYMAP	*pref_map;	/* if funct==NULL, map to bind to or
d91 1
d262 1
a262 2
realocmap(curmap)
	KEYMAP *curmap;
d297 1
a297 4
fixmap(curmap, mp, mt)
	KEYMAP *mt;
	KEYMAP *curmap;
	KEYMAP *mp;
d316 1
a316 4
dobind(curmap, p, unbind)
	KEYMAP	*curmap;
	char	*p;
	int	unbind;
d385 1
a385 5
bindkey(mapp, fname, keys, kcount)
	KEYMAP	**mapp;
	char	*fname;
	KCHAR	*keys;
	int	kcount;
d419 1
a419 4
dobindkey(map, func, str)
	KEYMAP *map;
	char   *func;
	char   *str;
d460 1
a460 2
bindtokey(f, n)
	int f, n;
d470 1
a470 2
localbind(f, n)
	int f, n;
d501 1
a501 2
unbindtokey(f, n)
	int f, n;
d521 1
a521 2
extend(f, n)
	int f, n;
d570 1
a570 2
evalexpr(f, n)
	int f, n;
d586 1
a586 2
evalbuffer(f, n)
	int f, n;
d612 1
a612 2
evalfile(f, n)
	int f, n;
d626 1
a626 2
load(fname)
	char *fname;
d660 1
a660 2
excline(line)
	char *line;
d911 1
a911 2
skipwhite(s)
	char *s;
d921 1
a921 2
parsetoken(s)
	char  *s;
@


1.21
log
@Part one of userland __P removal.  Done with a simple regexp with some minor hand editing to make comments line up correctly.  Another pass is forthcoming that handles the cases that could not be done automatically.
@
text
@d1 1
a1 1
/*	$OpenBSD: extend.c,v 1.20 2002/02/14 22:50:43 vincent Exp $	*/
d689 1
a689 1
	char	*funcp;
d691 1
a724 1
		char *tmp;
d727 1
a727 1
		n = strtol(argp, &tmp, 10);
d730 1
a730 2
		if ((errno == ERANGE && (n == LONG_MAX || n == LONG_MIN)) ||
		    (n > INT_MAX || n < INT_MIN))
d732 1
@


1.20
log
@ use strtol instead of atoi to get range checking, etc
@
text
@d1 1
a1 1
/*	$OpenBSD: extend.c,v 1.19 2002/02/13 03:21:12 vincent Exp $	*/
d24 7
a30 7
static int	 remap		__P((KEYMAP *, int, PF, KEYMAP *));
static KEYMAP	*realocmap	__P((KEYMAP *));
static void	 fixmap		__P((KEYMAP *, KEYMAP *, KEYMAP *));
static int	 dobind		__P((KEYMAP *, char *, int));
static char	*skipwhite	__P((char *));
static char	*parsetoken	__P((char *));
static int	 bindkey	__P((KEYMAP **, char *, KCHAR *, int));
@


1.19
log
@ simplify the define_key() code to use sane functions in two separate buffer
 instead of hardcoding sizes.

 ok art@@,deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: extend.c,v 1.18 2001/07/05 17:36:05 matthieu Exp $	*/
d6 1
a6 1

d718 1
a718 1
		if ((*line >= '0' && *line <= '9') || *line == '-') {
d724 1
d726 7
a732 1
		n = atoi(argp);
d762 2
a763 1
			if (!(lp = lalloc((int) (line - argp) + BINDEXT))) {
@


1.18
log
@Fix a seg fault when an init file can't be read
@
text
@d1 1
a1 1
/*	$OpenBSD: extend.c,v 1.17 2001/05/24 10:43:17 art Exp $	*/
d498 1
a498 2
define_key(f, n)
	int f, n;
d500 3
a502 2
	static char	 buf[48] = "Define key map: ";
	KEYMAP		*mp;
d504 2
a505 2
	buf[16] = '\0';
	if (eread(buf, &buf[16], 48 - 16, EFNEW) != TRUE)
d507 3
a509 2
	if ((mp = name_map(&buf[16])) == NULL) {
		ewprintf("Unknown map %s", &buf[16]);
d512 2
a513 1
	(void)strncat(&buf[16], " key: ", 48 - 16 - 1);
@


1.17
log
@Make the keymap/mode table growable in runtime.
@
text
@d1 1
a1 1
/*	$OpenBSD: extend.c,v 1.16 2001/05/24 09:47:33 art Exp $	*/
d650 1
a650 1
	int	 nbytes;
@


1.16
log
@Break out function -> name mappings to an own file.
Add a possibility to dynamically extend the function table.
@
text
@d1 1
a1 1
/*	$OpenBSD: extend.c,v 1.15 2001/05/24 03:05:22 mickey Exp $	*/
d266 1
d285 3
a287 3
	for (i = nmaps; i--;) {
		if (map_table[i].p_map == curmap)
			map_table[i].p_map = mp;
d289 1
a289 1
			fixmap(curmap, mp, map_table[i].p_map);
@


1.15
log
@spaces
@
text
@d1 1
a1 1
/*	$OpenBSD: extend.c,v 1.14 2001/05/23 23:29:47 mickey Exp $	*/
d9 1
@


1.14
log
@cinfo is const, keyname() and findbind() take buffer size to use strlcpy vs cpy+len
@
text
@d1 1
a1 1
/*	$OpenBSD: extend.c,v 1.13 2001/05/23 22:36:13 art Exp $	*/
d31 2
a32 2
/* 
 * Insert a string, mainly for use from macros (created by selfinsert) 
d87 4
a90 4
	KEYMAP *curmap;		/* pointer to the map being changed */
	int     c;		/* character being changed */
	PF      funct;		/* function being changed to */
	KEYMAP *pref_map;	/* if funct==NULL, map to bind to or
d193 1
a193 1
					    (MAPINIT - 1) * 
d218 1
a218 1
			if ((pfp = malloc((ele->k_num - c + !n2) * 
d269 1
a269 1
	    (curmap->map_max + (MAPGROW - 1)) * 
d320 3
a322 3
	KEYMAP *curmap;
	char   *p;
	int     unbind;
d384 3
a386 3
 * bindkey: bind key sequence to a function in the specified map.  Used by 
 * excline so it can bind function keys.  To close to release to change 
 * calling sequence, should just pass KEYMAP *curmap rather than 
d392 4
a395 4
	KEYMAP **mapp;
	char    *fname;
	KCHAR   *keys;
	int      kcount;
d487 1
a487 1
	return dobind(curbp->b_modes[curbp->b_nmodes]->p_map, 
d529 3
a531 3
 * Extended command. Call the message line routine to read in the command 
 * name and apply autocompletion to it. When it comes back, look the name 
 * up in the symbol table and run the command if it is found.  Print an 
d597 1
a597 1
 * evalbuffer - evaluate the current buffer as line commands. Useful for 
d674 2
a675 2
 * excline - run a line from a load file or eval-expression.  if FKEYS is 
 * defined, duplicate functionallity of dobind so function key values don't 
d818 1
a818 1
						if (argp[1] <= '7' && 
d944 3
a946 3
			/* 
			 * Strings get special treatment.  
			 * Beware: You can \ out the end of the string! 
@


1.13
log
@Get rid of unnecessary casts of NULL.
@
text
@d1 1
a1 1
/*	$OpenBSD: extend.c,v 1.12 2001/05/23 22:20:35 art Exp $	*/
d354 1
a354 2
		(void)strcpy(prompt, p);
		pep = prompt + strlen(prompt);
d358 2
a359 1
			pep = keyname(pep, c = getkey(FALSE));
@


1.12
log
@remove VOID. We're way beyond the point where this could build with an
ancient compiler.
@
text
@d1 1
a1 1
/*	$OpenBSD: extend.c,v 1.11 2001/05/23 22:12:10 art Exp $	*/
d142 1
a142 1
			if ((pfp = (PF *)malloc(sizeof(PF))) == NULL) {
d185 1
a185 1
				ele->k_prefmap = (KEYMAP *) NULL;
d344 1
a344 1
				if (remap(curmap, c, NULL, (KEYMAP *)NULL)
d411 1
a411 1
			if (remap(curmap, c, NULL, (KEYMAP *)NULL) != TRUE)
d655 1
a655 1
	if (ffropen(fname, (BUFFER *)NULL) != FIOSUC)
d666 1
a666 1
	(void)ffclose((BUFFER *)NULL);
d894 2
a895 2
		} else
			status = bindkey(&curmap, (char *)NULL, key.k_chars,
d897 1
@


1.11
log
@Use 'fundamental_map' where 'map_table[0].p_map' or 'name_map("fundamental")'
were used.
@
text
@d1 1
a1 1
/*	$OpenBSD: extend.c,v 1.10 2001/05/23 20:57:54 art Exp $	*/
d25 1
a25 1
static VOID	 fixmap		__P((KEYMAP *, KEYMAP *, KEYMAP *));
d296 1
a296 1
static VOID
d349 1
a349 1
		(VOID)doscan(curmap, c = maclcur->l_text[s], NULL);
d354 1
a354 1
		(VOID)strcpy(prompt, p);
d420 1
a420 1
	(VOID)doscan(curmap, c = *keys, NULL);
d509 1
a509 1
	(VOID)strncat(&buf[16], " key: ", 48 - 16 - 1);
d613 1
a613 1
		(VOID)strncpy(excbuf, ltext(lp), llength(lp));
d666 1
a666 1
	(VOID)ffclose((BUFFER *)NULL);
@


1.10
log
@There is no need to use name_mode when all we use from the mode is the map.
name_map gives us what we want.
@
text
@d1 1
a1 1
/*	$OpenBSD: extend.c,v 1.9 2001/05/23 20:42:46 art Exp $	*/
d476 1
a476 1
	return dobind(map_table[0].p_map, "Global set key: ", FALSE);
d517 1
a517 1
	return dobind(map_table[0].p_map, "Global unset key: ", TRUE);
d730 1
a730 1
		curmap = map_table[0].p_map;
@


1.9
log
@Deal with another strangeness caused by the abuse of the
global ele variable.
@
text
@d1 1
a1 1
/*	$OpenBSD: extend.c,v 1.8 2001/05/23 20:19:44 art Exp $	*/
d500 1
a500 1
	MAPS		*mp;
d505 1
a505 1
	if ((mp = name_mode(&buf[16])) == NULL) {
d510 1
a510 1
	return dobind(mp->p_map, buf, FALSE);
a689 1
	MAPS	*mp;
d864 1
a864 1
			if ((mp = name_mode(lp->l_text)) == NULL) {
a869 1
			curmap = mp->p_map;
@


1.8
log
@Add an argument to doscan which is a pointer to a KEYMAP pointer.
If that argument is not NULL, we set it to the k_prefmap of the pressed
key if there is one.
This is what most of the users of doscan did anyway, but they did it through
leaked global state.
@
text
@d1 1
a1 1
/*	$OpenBSD: extend.c,v 1.7 2001/05/23 16:13:59 art Exp $	*/
d413 5
@


1.7
log
@Get rid of 'prefix' and use NULL instead.
@
text
@d1 1
a1 1
/*	$OpenBSD: extend.c,v 1.6 2001/01/29 01:58:07 niklas Exp $	*/
d342 1
a342 1
			if (doscan(curmap, c = CHARMASK(maclcur->l_text[s]))
a347 1
			curmap = ele->k_prefmap;
d349 1
a349 1
		(VOID)doscan(curmap, c = maclcur->l_text[s]);
d360 1
a360 1
			if (doscan(curmap, c) != NULL)
a363 1
			curmap = ele->k_prefmap;
d410 1
a410 1
		if (doscan(curmap, c = *keys++) != NULL) {
a413 1
		curmap = ele->k_prefmap;
d415 1
a415 1
	(VOID)doscan(curmap, c = *keys);
@


1.6
log
@$OpenBSD$
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d90 1
a90 1
	KEYMAP *pref_map;	/* if funct==prefix, map to bind to or
d99 1
a99 1
		if (ele > &curmap->map_element[0] && (funct != prefix ||
d105 1
a105 1
		    (funct != prefix || ele->k_prefmap == NULL))
d160 1
a160 1
		if (funct == prefix) {
d179 1
a179 1
		if (ele->k_funcp[n1] == funct && (funct != prefix ||
d183 2
a184 2
		if (funct != prefix || ele->k_prefmap == NULL) {
			if (ele->k_funcp[n1] == prefix)
d188 1
a188 1
			if (funct == prefix) {
d214 1
a214 1
				n2 &= ele->k_funcp[i] != prefix;
d223 1
a223 1
			ele->k_funcp[n1] = prefix;
d343 2
a344 2
			    != prefix) {
				if (remap(curmap, c, prefix, (KEYMAP *)NULL)
d361 1
a361 1
			if (doscan(curmap, c) != prefix)
d376 1
a376 1
		if (((funct = name_function(prompt)) == prefix) ?
d406 1
a406 1
	else if (((funct = name_function(fname)) == prefix) ?
d412 2
a413 2
		if (doscan(curmap, c = *keys++) != prefix) {
			if (remap(curmap, c, prefix, (KEYMAP *)NULL) != TRUE)
@


1.5
log
@More -Wall anmd KNF, from op2@@tomahawk.SQUiSH.org
@
text
@d1 2
@


1.4
log
@The start of KNF + -Wall.  The code has been run through indent but
needs hand fixup.  I stopped at keymap.c...
@
text
@d2 1
a2 2
 *	Extended (M-X) commands, rebinding, and
 *	startup file processing.
d4 3
a6 2
#include	"def.h"
#include	"kbd.h"
d9 2
a10 2
#include	"macro.h"
#endif
d13 1
a13 1
#include	"key.h"
d17 11
a27 10
#endif
#endif
#endif

static KEYMAP *realocmap	__P((KEYMAP *));
static VOID fixmap		__P((KEYMAP *, KEYMAP*, KEYMAP*));
static char *skipwhite		__P((char *));
static char *parsetoken		__P((char *));
int load			__P((char *));
int excline			__P((char *));
d29 3
a31 1
/* insert a string, mainly for use from macros (created by selfinsert) */
d37 2
a38 2
	char  *cp;
	char   buf[128];
d40 1
a40 2
	int    count;
	int    c;
d54 3
a56 3
		thisflag |= CFINS;	/* CFINS means selfinsert can tack on
					 * end */
#endif
a89 1
/* extern MAP_ELEMENT *ele;	must be set before calling */
d91 4
a94 5
	int             i;
	int             n1, n2, nold;
	KEYMAP         *mp;
	PF             *pfp;
	MAP_ELEMENT    *mep;
d98 1
a98 1
					    (ele - 1)->k_prefmap == NULL)) {
d100 1
a100 1
		} else
d103 1
a103 1
		    (funct != prefix || ele->k_prefmap == NULL)) {
d105 1
a105 1
		} else
d109 1
a109 1
			if ((pfp = (PF *) malloc((c - ele->k_base + 1) *
d123 2
a124 2
			if ((pfp = (PF *) malloc((ele->k_num - c + 1)
			    * sizeof(PF))) == NULL) {
d140 1
a140 1
			if ((pfp = (PF *) malloc(sizeof(PF))) == NULL) {
d162 1
a162 1
				if (!(mp = (KEYMAP *) malloc(sizeof(KEYMAP) +
d179 2
a180 1
			return TRUE;	/* no change */
d184 2
a185 1
			ele->k_funcp[n1] = funct;	/* easy case */
d191 2
a192 1
					    (MAPINIT - 1) * sizeof(MAP_ELEMENT)))) {
d206 2
a207 2
			 * This case is the splits
			 * determine which side of the break c goes on
d216 2
a217 1
			if (!(pfp = malloc((ele->k_num - c + !n2) * sizeof(PF)))) {
d261 1
a261 1
	KEYMAP         *curmap;
d263 2
a264 3
	KEYMAP         *mp;
	int             i;
	extern int      nmaps;
d266 3
a268 2
	if ((mp = (KEYMAP *) malloc((unsigned) (sizeof(KEYMAP) +
	(curmap->map_max + (MAPGROW - 1)) * sizeof(MAP_ELEMENT)))) == NULL) {
d300 1
a300 1
	int     i;
d322 5
a326 6
	PF      funct;
	char    prompt[80];
	char   *pep;
	int     c;
	int     s;
	KEYMAP *pref_map = NULL;
d342 1
a342 1
				if (remap(curmap, c, prefix, (KEYMAP *) NULL)
d348 1
a348 1
		(VOID) doscan(curmap, c = maclcur->l_text[s]);
d351 3
a353 3
#endif
#endif
		(VOID) strcpy(prompt, p);
d367 1
a367 1
#endif
d384 5
a388 5
 * bindkey: bind key sequence to a function in
 * the specified map.  Used by excline so it can bind function keys.
 * To close to release to change calling sequence, should just pass
 * KEYMAP *curmap rather than KEYMAP **mapp.
*/
d390 1
a390 1
int
d393 8
a400 8
	char   *fname;
	KCHAR  *keys;
	int     kcount;
{
	KEYMAP *curmap = *mapp;
	PF      funct;
	int     c;
	KEYMAP *pref_map = NULL;
d405 1
a405 1
		 (pref_map = name_map(fname)) == NULL : funct == NULL) {
d411 1
a411 1
			if (remap(curmap, c, prefix, (KEYMAP *) NULL) != TRUE)
d416 1
a416 1
	(VOID) doscan(curmap, c = *keys);
d430 1
a430 1
	int     i;
d461 2
a462 2
#endif
#endif
d483 2
a484 3

	return dobind(curbp->b_modes[curbp->b_nmodes]->p_map, "Local set key: ",
		      FALSE);
d495 2
a496 3
	static char     buf[48] = "Define key map: ";
	MAPS           *mp;
	char           *strncat();
d505 1
a505 1
	(VOID) strncat(&buf[16], " key: ", 48 - 16 - 1);
a512 1

a519 1

d525 4
a528 5
 * Extended command. Call the message line
 * routine to read in the command name and apply autocompletion
 * to it. When it comes back, look the name up in the symbol table
 * and run the command if it is found.
 * Print an error if there is anything wrong.
d532 1
a532 1
	int	f, n;
d534 3
a536 3
	PF      funct;
	int     s;
	char    xname[NXNAME];
d547 1
a547 1
			LINE           *lp = maclcur;
d551 1
a551 1
			free((char *) lp);
d553 2
a554 2
#endif
		return (*funct) (f, n);
d582 1
a582 1
	int	f, n;
d584 2
a585 2
	int     s;
	char    exbuf[128];
d593 2
a594 2
 * evalbuffer - evaluate the current buffer as line commands. Useful
 *	for testing startup files.
d599 1
a599 1
	int             f, n;
d601 4
a604 4
	LINE           *lp;
	BUFFER         *bp = curbp;
	int             s;
	static char     excbuf[128];
d609 4
a612 2
		(VOID) strncpy(excbuf, ltext(lp), llength(lp));
		excbuf[llength(lp)] = '\0';	/* make sure it's terminated */
d626 1
a626 1
	int    f, n;
d628 2
a629 2
	int    s;
	char   fname[NFILEN];
d641 1
a641 1
	char   *fname;
d643 3
a645 3
	int     s = TRUE;
	int     nbytes;
	char    excbuf[128];
d648 2
a649 1
		return FALSE;	/* just to be careful */
d651 1
a651 1
	if (ffropen(fname, (BUFFER *) NULL) != FIOSUC)
d653 1
d662 1
a662 1
	(VOID) ffclose((BUFFER *) NULL);
d670 3
a672 3
 * excline - run a line from a load file or eval-expression.
 * if FKEYS is defined, duplicate functionallity of dobind so function
 * key values don't have to fit in type char.
d676 1
a676 1
	char   *line;
d678 19
a696 19
	char   *funcp, *argp = NULL;
	int     c;
	int     status;
	int     f, n;
	LINE   *lp, *np;
	PF      fp;
#ifdef	FKEYS
	int     bind;
	KEYMAP *curmap;
	MAPS   *mp;
#define BINDARG		0	/* this arg is key to bind (local/global set
				 * key) */
#define	BINDNO		1	/* not binding or non-quoted BINDARG */
#define BINDNEXT	2	/* next arg " (define-key) */
#define BINDDO		3	/* already found key to bind */
#define BINDEXT 1		/* space for trailing \0 */
#else
#define BINDEXT 0
#endif
d735 2
a736 2
#endif
	/* Pack away all the args now...	 */
d752 1
a752 1
			bcopy(argp, ltext(lp), (int) (line - argp));
d754 2
a755 1
			lp->l_used--;	/* don't count BINDEXT! */
d758 3
a760 2
#endif
		} else {	/* Quoted strings special */
d764 2
a765 2
#endif
				lp = lalloc((int) (line - argp) + BINDEXT);
d775 1
a775 1
#endif
d815 2
a816 1
						if (argp[1] <= '7' && argp[1] >= '0') {
d837 1
a837 1
#endif
d848 1
a848 1
#endif
d864 1
a864 1
				free((char *) lp);
d868 1
a868 1
			free((char *) lp);
d872 1
a872 1
#endif
d879 1
a879 1
#endif
d893 1
a893 1
			status = bindkey(&curmap, (char *) NULL, key.k_chars,
d897 1
a897 1
#endif
d900 1
a900 1
		status = (*fp) (f, n);
d904 1
a904 1
#endif
d909 1
a909 1
		free((char *) lp);
d912 1
a912 1
	free((char *) lp);
d921 1
a921 1
	char  *s;
a922 1

a933 1

d940 5
a944 2
		do {	/* Strings get special treatment */
			/* Beware: You can \ out the end of the string! */
d950 1
a950 1
#endif
@


1.3
log
@Move dobindkey() into extend.c where it belongs.
@
text
@d2 1
a2 1
 *	Extended (M-X) commands, rebinding, and 
d16 1
a16 1
#define	BINDKEY		/* bindkey is used by FKEYS startup code */
d21 6
a26 1
extern	int rescan();
d29 2
a30 1
/*ARGSUSED*/
d32 1
a32 1
int f, n;
d34 2
a35 2
    register char *cp;
    char buf[128];
d37 2
a38 2
    register int count;
    int c;
d40 10
a49 6
    if(inmacro) {
	while(--n >= 0) {
	    for(count = 0; count < maclcur->l_used; count++) {
		if((((c=maclcur->l_text[count]) == '\n') ? lnewline()
		    : linsert(1, c)) != TRUE) return FALSE;
	    }
d51 3
a53 4
	maclcur = maclcur->l_fp;
	return TRUE;
    }
    if(n==1) thisflag |= CFINS; /* CFINS means selfinsert can tack on end */
d55 1
a55 5
    if(eread("Insert: ", buf, sizeof(buf), EFNEW) == FALSE) return FALSE;
    while(--n >= 0) {
	cp = buf;
	while(*cp) {
	    if(((*cp == '\n') ? lnewline() : linsert(1, *cp)) != TRUE)
d57 8
a64 1
	    cp++;
d66 1
a66 2
    }
    return TRUE;
d81 7
a87 5
static int remap(curmap, c, funct, pref_map)
register KEYMAP	*curmap;/* pointer to the map being changed */
int	c;		/* character being changed */
PF	funct;		/* function being changed to */
KEYMAP	*pref_map;	/* if funct==prefix, map to bind to or NULL for new */
d90 46
a135 66
	register int i;
	int	n1, n2, nold;
	KEYMAP	*mp;
	PF	*pfp;
	MAP_ELEMENT *mep;
	static	KEYMAP *realocmap();

	if(ele >= &curmap->map_element[curmap->map_num] || c < ele->k_base) {
	    if(ele > &curmap->map_element[0] && (funct!=prefix ||
			(ele-1)->k_prefmap==NULL)) {
		n1 = c - (ele-1)->k_num;
	    } else n1 = HUGE;
	    if(ele < &curmap->map_element[curmap->map_num] && (funct!=prefix ||
			ele->k_prefmap==NULL)) {
		n2 = ele->k_base - c;
	    } else n2 = HUGE;
	    if(n1 <= MAPELEDEF && n1 <= n2) {
		ele--;
		if((pfp = (PF *)malloc((unsigned)(c - ele->k_base+1) 
			* sizeof(PF))) == NULL) {
		    ewprintf("Out of memory");
		    return FALSE;
		}
		nold = ele->k_num - ele->k_base + 1;
		for(i=0; i < nold; i++)
		    pfp[i] = ele->k_funcp[i];
		while(--n1) pfp[i++] = curmap->map_default;
		pfp[i] = funct;
		ele->k_num = c;
		ele->k_funcp = pfp;
	    } else if(n2 <= MAPELEDEF) {
		if((pfp = (PF *)malloc((unsigned)(ele->k_num - c + 1) 
			* sizeof(PF))) == NULL) {
		    ewprintf("Out of memory");
		    return FALSE;
		}
		nold = ele->k_num - ele->k_base + 1;
		for(i=0; i < nold; i++)
		    pfp[i+n2] = ele->k_funcp[i];
		while(--n2) pfp[n2] = curmap->map_default;
		pfp[0] = funct;
		ele->k_base = c;
		ele->k_funcp = pfp;
	    } else {
		if(curmap->map_num >= curmap->map_max &&
		    (curmap = realocmap(curmap)) == NULL) return FALSE;
		if((pfp = (PF *)malloc(sizeof(PF))) == NULL) {
		    ewprintf("Out of memory");
		    return FALSE;
		}
		pfp[0] = funct;
		for(mep = &curmap->map_element[curmap->map_num]; mep > ele; mep--) {
		    mep->k_base    = (mep-1)->k_base;
		    mep->k_num     = (mep-1)->k_num;
		    mep->k_funcp   = (mep-1)->k_funcp;
		    mep->k_prefmap = (mep-1)->k_prefmap;
		}
		ele->k_base = c;
		ele->k_num = c;
		ele->k_funcp = pfp;
		ele->k_prefmap = NULL;
		curmap->map_num++;
	    }
	    if(funct == prefix) {
		if(pref_map != NULL) {
		    ele->k_prefmap = pref_map;
d137 37
a173 10
		    if((mp = (KEYMAP *)malloc(sizeof(KEYMAP) +
			    (MAPINIT-1)*sizeof(MAP_ELEMENT))) == NULL) {
			ewprintf("Out of memory");
			ele->k_funcp[c - ele->k_base] = curmap->map_default;
			return FALSE;
		    }
		    mp->map_num = 0;
		    mp->map_max = MAPINIT;
		    mp->map_default = rescan;
		    ele->k_prefmap = mp;
a174 1
	    }
d176 72
a247 66
	    n1 = c - ele->k_base;
	    if(ele->k_funcp[n1] == funct && (funct!=prefix || pref_map==NULL ||
		    pref_map==ele->k_prefmap))
		return TRUE;	/* no change */
	    if(funct!=prefix || ele->k_prefmap==NULL) {
		if(ele->k_funcp[n1] == prefix)
		    ele->k_prefmap = (KEYMAP *)NULL;
		ele->k_funcp[n1] = funct;	/* easy case */
		if(funct==prefix) {
		    if(pref_map!=NULL)
			ele->k_prefmap = pref_map;
		    else {
			if((mp = (KEYMAP *)malloc(sizeof(KEYMAP) +
				(MAPINIT-1)*sizeof(MAP_ELEMENT))) == NULL) {
			    ewprintf("Out of memory");
			    ele->k_funcp[c - ele->k_base] = curmap->map_default;
			    return FALSE;
			}
			mp->map_num = 0;
			mp->map_max = MAPINIT;
			mp->map_default = rescan;
			ele->k_prefmap = mp;
		    }
		}
	    } else {
		/* this case is the splits */
		/* determine which side of the break c goes on */
		/* 0 = after break; 1 = before break */
		n2 = 1;
		for(i=0; n2 && i < n1; i++)
			n2 &= ele->k_funcp[i] != prefix;
		if(curmap->map_num >= curmap->map_max &&
		    (curmap = realocmap(curmap)) == NULL) return FALSE;
		if((pfp = (PF *)malloc((unsigned)(ele->k_num - c + !n2) 
			* sizeof(PF))) == NULL) {
		    ewprintf("Out of memory");
		    return FALSE;
		}
		ele->k_funcp[n1] = prefix;
		for(i=n1+n2; i <= ele->k_num - ele->k_base; i++)
		    pfp[i-n1-n2] = ele->k_funcp[i];
		for(mep = &curmap->map_element[curmap->map_num]; mep > ele; mep--) {
		    mep->k_base    = (mep-1)->k_base;
		    mep->k_num     = (mep-1)->k_num;
		    mep->k_funcp   = (mep-1)->k_funcp;
		    mep->k_prefmap = (mep-1)->k_prefmap;
		}
		ele->k_num = c - !n2;
		(ele+1)->k_base = c + n2;
		(ele+1)->k_funcp = pfp;
		ele += !n2;
		ele->k_prefmap = NULL;
		curmap->map_num++;
		if(pref_map == NULL) {
		    if((mp = (KEYMAP *)malloc(sizeof(KEYMAP) +
			    (MAPINIT-1)*sizeof(MAP_ELEMENT))) == NULL) {
			ewprintf("Out of memory");
			ele->k_funcp[c - ele->k_base] = curmap->map_default;
			return FALSE;
		    }
		    mp->map_num = 0;
		    mp->map_max = MAPINIT;
		    mp->map_default = rescan;
		    ele->k_prefmap = mp;
		} else ele->k_prefmap = pref_map;
	    }
d252 53
a304 44
/* reallocate a keymap, used above */
static KEYMAP *realocmap(curmap)
register KEYMAP *curmap;
{
    register KEYMAP *mp;
    register int i;
    static VOID fixmap();
    extern int nmaps;

    if((mp = (KEYMAP *)malloc((unsigned)(sizeof(KEYMAP)+
	    (curmap->map_max+(MAPGROW-1))*sizeof(MAP_ELEMENT)))) == NULL) {
	ewprintf("Out of memory");
	return NULL;
    }
    mp->map_num = curmap->map_num;
    mp->map_max = curmap->map_max + MAPGROW;
    mp->map_default = curmap->map_default;
    for(i=curmap->map_num; i--; ) {
	mp->map_element[i].k_base	= curmap->map_element[i].k_base;
	mp->map_element[i].k_num	= curmap->map_element[i].k_num;
	mp->map_element[i].k_funcp	= curmap->map_element[i].k_funcp;
	mp->map_element[i].k_prefmap	= curmap->map_element[i].k_prefmap;
    }
    for(i=nmaps; i--; ) {
	if(map_table[i].p_map == curmap) map_table[i].p_map = mp;
	else fixmap(curmap, mp, map_table[i].p_map);
    }
    ele = &mp->map_element[ele - &curmap->map_element[0]];
    return mp;
}

/* fix references to a reallocated keymap (recursive) */
static VOID fixmap(curmap, mp, mt)
register KEYMAP *mt;
register KEYMAP *curmap;
KEYMAP *mp;
{
    register int i;

    for(i = mt->map_num; i--; ) {
	if(mt->map_element[i].k_prefmap != NULL) {
	    if(mt->map_element[i].k_prefmap == curmap)
	    	mt->map_element[i].k_prefmap = mp;
	    else fixmap(curmap, mp, mt->map_element[i].k_prefmap);
a305 1
    }
d312 12
a323 12

static int dobind(curmap, p, unbind)
register KEYMAP *curmap;
char *p;
int unbind;
{
	PF	funct;
	char	prompt[80];
	char	*pep;
	int	c;
	int	s;
	KEYMAP	*pref_map = NULL;
d326 7
a332 5
	if(macrodef) {
	/* keystrokes arn't collected.	Not hard, but pretty useless */
	/* would not work for function keys in any case */
	    ewprintf("Can't rebind key in macro");
	    return FALSE;
d335 9
a343 6
	if(inmacro) {
	    for(s=0; s < maclcur->l_used - 1; s++) {
		if(doscan(curmap, c=CHARMASK(maclcur->l_text[s])) != prefix) {
		    if(remap(curmap, c, prefix, (KEYMAP *)NULL) != TRUE) {
			return FALSE;
		    }
d345 2
a346 4
		curmap = ele->k_prefmap;
	    }
	    (VOID) doscan(curmap, c=maclcur->l_text[s]);
	    maclcur = maclcur->l_fp;
d350 12
a361 11
	    (VOID) strcpy(prompt, p);
	    pep = prompt + strlen(prompt);
	    for(;;) {
		ewprintf("%s", prompt);
		pep[-1] = ' ';
		pep = keyname(pep, c = getkey(FALSE));
		if(doscan(curmap,c) != prefix) break;
		*pep++ = '-';
		*pep = '\0';
		curmap = ele->k_prefmap;
	    }
d365 2
a366 1
	if(unbind) funct = rescan;
d368 8
a375 7
	    if ((s=eread("%s to command: ", prompt, 80, EFFUNC|EFNEW, prompt))
			!= TRUE) return s;
	    if (((funct = name_function(prompt)) == prefix) ?
	    		(pref_map = name_map(prompt)) == NULL : funct==NULL) {
		ewprintf("[No match]");
		return FALSE;
	    }
d387 1
d389 9
a397 9
KEYMAP **mapp;
char *fname;
KCHAR *keys;
int kcount;
{
	KEYMAP	*curmap = *mapp;
	PF	funct;
	int	c;
	KEYMAP	*pref_map = NULL;
d399 2
a400 1
	if(fname == NULL) funct = rescan;
d402 10
a411 10
		(pref_map = name_map(fname)) == NULL : funct==NULL) {
	    ewprintf("[No match: %s]", fname);
	    return FALSE;
	}
	while(--kcount) {
	    if(doscan(curmap, c = *keys++) != prefix) {
		if(remap(curmap, c, prefix, (KEYMAP *)NULL) != TRUE)
		    return FALSE;
	    }
	    curmap = ele->k_prefmap;
d424 2
a425 2
	char *func;
	char *str;
d427 1
a427 1
	int i;
d434 3
a436 2
			switch(*++str) {
			case 't': case 'T':
d439 2
a440 1
			case 'n': case 'N':
d443 2
a444 1
			case 'r': case 'R':
d447 2
a448 1
			case 'e': case 'E':
d456 1
a456 1
	return(bindkey(&map, func, key.k_chars, key.k_count));
d464 2
a465 1
/*ARGSUSED*/
d467 1
d469 1
a469 1
    return dobind(map_table[0].p_map, "Global set key: ", FALSE);
d475 2
a476 1
/*ARGSUSED*/
d478 1
d480 3
a482 2
    return dobind(curbp->b_modes[curbp->b_nmodes]->p_map, "Local set key: ",
	FALSE);
d488 2
a489 1
/*ARGSUSED*/
d491 1
d493 13
a505 12
    static char buf[48] = "Define key map: ";
    MAPS *mp;
    char *strncat();

    buf[16] = '\0';
    if(eread(buf, &buf[16], 48 - 16, EFNEW) != TRUE) return FALSE;
    if((mp = name_mode(&buf[16])) == NULL) {
	ewprintf("Unknown map %s", &buf[16]);
	return FALSE;
    }
    (VOID) strncat(&buf[16], " key: ", 48-16-1);
    return dobind(mp->p_map, buf, FALSE);
d508 1
d510 1
a510 1
int f, n;
d512 2
a513 1
    return dobind(map_table[0].p_map, "Global unset key: ", TRUE);
d516 1
d518 1
a518 1
int f, n;
d520 3
a522 2
    return dobind(curbp->b_modes[curbp->b_nmodes]->p_map, "Local unset key: ",
	TRUE);
d532 1
d534 1
d536 11
a546 8
	PF	funct;
	int	s;
	char	xname[NXNAME];

	if(!(f & FFARG)) s = eread("M-x ", xname, NXNAME, EFNEW|EFFUNC);
	else		 s = eread("%d M-x ", xname, NXNAME, EFNEW|EFFUNC, n);
	if(s != TRUE) return s;
	if((funct = name_function(xname)) != NULL) {
d548 7
a554 7
	    if(macrodef) {
		LINE *lp = maclcur;
		macro[macrocount-1].m_funct = funct;
		maclcur = lp->l_bp;
		maclcur->l_fp = lp->l_fp;
		free((char *)lp);
	    }
d556 1
a556 1
	    return (*funct)(f, n);
d581 2
a582 1
/*ARGSUSED*/
d584 1
d586 2
a587 2
	int	s;
	char	exbuf[128];
d593 1
d598 2
a599 1
/*ARGSUSED*/
d601 1
d603 4
a606 4
	register LINE	*lp;
	register BUFFER *bp = curbp;
	register int	s;
	static char	excbuf[128];
d609 2
a610 1
		if (llength(lp) >= 128) return FALSE;
d613 2
a614 1
		if ((s = excline(excbuf)) != TRUE) return s;
d618 1
d623 2
a624 1
/*ARGSUSED*/
d626 1
d628 2
a629 2
	register int	s;
	char		fname[NFILEN];
d639 7
a645 4
load(fname) char *fname; {
	int	s = TRUE;
	int	nbytes;
	char	excbuf[128];
d650 3
a652 2
	if (ffropen(fname, (BUFFER *) NULL) != FIOSUC) return FALSE;
	while ((s = ffgetline(excbuf, sizeof(excbuf)-1, &nbytes)) == FIOSUC) {
d662 1
a662 1
	if(s!=FIOEOF || (nbytes && excline(excbuf)!=TRUE))
d672 1
d674 1
a674 1
register char *line;
d676 12
a687 11
	register char	*funcp, *argp = NULL;
	register int	c;
	int		status;
	int	f, n;
	LINE	*lp, *np;
	PF	fp;
#ifdef	FKEYS
	int	bind;
	KEYMAP	*curmap;
	MAPS	*mp;
#define BINDARG		0	/* this arg is key to bind (local/global set key) */
a694 3
	PF	name_function();
	LINE	*lalloc();
	static	char	*skipwhite(), *parsetoken();
d696 1
a696 1
	if(macrodef || inmacro) {
a699 1

d703 2
a704 1
	if (*funcp == '\0') return TRUE;	/* No error on blank lines */
a713 1

d718 3
a720 3
	if((fp = name_function(funcp)) == NULL) {
	    ewprintf("Unknown function: %s", funcp);
	    return FALSE;
d723 1
a723 1
	if(fp == bindtokey || fp == unbindtokey) {
d726 1
a726 1
	} else if(fp == localbind || fp == localunbind) {
d729 4
a732 2
	} else if(fp == define_key) bind = BINDNEXT;
	else bind = BINDNO;
d734 3
a736 2
	/* Pack away all the args now...	*/
	if((np = lalloc(0))==FALSE) return FALSE;
d740 2
a741 1
		if (*argp == '\0') break;
d744 7
a750 6
		    if (*argp == '\'') ++argp;
		    if((lp = lalloc((int)(line-argp)+BINDEXT))==NULL) {
			status = FALSE;
			goto cleanup;
		    }
		    bcopy(argp, ltext(lp), (int)(line-argp));
d752 3
a754 2
		    lp->l_used--;	/* don't count BINDEXT! */
		    if(bind == BINDARG) bind = BINDNO;
d757 1
a757 1
		    ++argp;
d759 1
a759 1
		    if(bind != BINDARG) {
d761 6
a766 44
			if((lp = lalloc((int)(line-argp)+BINDEXT))==NULL) {
			    status = FALSE;
			    goto cleanup;
			}
			lp->l_used = 0;
#ifdef	FKEYS
		    } else {
			key.k_count = 0;
		    }
#endif
		    while (*argp != '"' && *argp != '\0') {
			if (*argp != '\\') c = *argp++;
			else {
			    switch(*++argp) {
				case 't': case 'T':
				    c = CCHR('I');
				    break;
				case 'n': case 'N':
				    c = CCHR('J');
				    break;
				case 'r': case 'R':
				    c = CCHR('M');
				    break;
				case 'e': case 'E':
				    c = CCHR('[');
				    break;
				case '^':
/* split into two statements due to bug in OSK cpp */
				    c = CHARMASK(*++argp);
				    c = ISLOWER(c) ?
					CCHR(TOUPPER(c)) : CCHR(c);
				    break;
				case '0': case '1': case '2': case '3':
				case '4': case '5': case '6': case '7':
				    c = *argp - '0';
				    if(argp[1] <= '7' && argp[1] >= '0') {
				    	c <<= 3;
					c += *++argp - '0';
					if(argp[1] <= '7' && argp[1] >= '0') {
					    c <<= 3;
					    c += *++argp - '0';
					}
				    }
				    break;
d768 2
a769 14
				case 'f': case 'F':
				    c = *++argp - '0';
				    if(ISDIGIT(argp[1])) {
					c *= 10;
					c += *++argp - '0';
				    }
				    c += KFIRST;
				    break;
#endif
				default:
				    c = CHARMASK(*argp);
				    break;
			    }
			    argp++;
d771 68
d840 3
a842 3
			if(bind == BINDARG)
			    key.k_chars[key.k_count++] = c;
			else
d844 4
a847 3
			    lp->l_text[lp->l_used++] = c;
		    }
		    if(*line) line++;
d850 2
a851 2
		switch(bind) {
		    case BINDARG:
d854 1
a854 1
		    case BINDNEXT:
d856 5
a860 5
			if((mp = name_mode(lp->l_text)) == NULL) {
			    ewprintf("No such mode: %s", lp->l_text);
			    status = FALSE;
			    free((char *)lp);
			    goto cleanup;
d863 1
a863 1
			free((char *)lp);
d866 1
a866 1
		    default:
d877 2
a878 2
	switch(bind) {
	    default:
d882 8
a889 5
	    case BINDDO:
	    	if(fp != unbindtokey && fp != localunbind) {
		    lp->l_text[lp->l_used] = '\0';
		    status = bindkey(&curmap, lp->l_text, key.k_chars, key.k_count);
		} else status = bindkey(&curmap, (char *)NULL, key.k_chars, key.k_count);
d891 1
a891 1
	    case BINDNO:
d895 1
a895 1
		status = (*fp)(f, n);
d902 4
a905 4
	while(lp!=maclcur) {
	    np = lp->l_fp;
	    free((char *)lp);
	    lp = np;
d907 1
a907 1
	free((char *)lp);
d916 1
a916 1
register char *s;
d918 5
a922 2
	while(*s == ' ' || *s == '\t' || *s == ')' || *s == '(') s++;
	if (*s == ';') *s = '\0' ;
d928 1
a928 1
register char *s;
d930 1
d932 4
a935 2
	    while(*s && *s!=' ' && *s!='\t' && *s!=')' && *s!='(') s++;
	    if(*s==';') *s='\0';
d937 1
a937 1
	    do {	/* Strings get special treatment */
d939 3
a941 2
		if (*s == '\\') ++s;
	    } while (*++s != '"' && *s != '\0');
@


1.2
log
@further pruning
@
text
@d375 39
@


1.1
log
@initial import of mg2a
@
text
@a20 1
extern	char	*strncpy();
@

