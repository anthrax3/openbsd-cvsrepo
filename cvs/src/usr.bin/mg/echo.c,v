head	1.66;
access;
symbols
	OPENBSD_6_2:1.66.0.6
	OPENBSD_6_2_BASE:1.66
	OPENBSD_6_1:1.66.0.4
	OPENBSD_6_1_BASE:1.66
	OPENBSD_6_0:1.65.0.4
	OPENBSD_6_0_BASE:1.65
	OPENBSD_5_9:1.65.0.2
	OPENBSD_5_9_BASE:1.65
	OPENBSD_5_8:1.59.0.4
	OPENBSD_5_8_BASE:1.59
	OPENBSD_5_7:1.57.0.2
	OPENBSD_5_7_BASE:1.57
	OPENBSD_5_6:1.56.0.4
	OPENBSD_5_6_BASE:1.56
	OPENBSD_5_5:1.55.0.6
	OPENBSD_5_5_BASE:1.55
	OPENBSD_5_4:1.55.0.2
	OPENBSD_5_4_BASE:1.55
	OPENBSD_5_3:1.54.0.2
	OPENBSD_5_3_BASE:1.54
	OPENBSD_5_2:1.50.0.2
	OPENBSD_5_2_BASE:1.50
	OPENBSD_5_1_BASE:1.49
	OPENBSD_5_1:1.49.0.12
	OPENBSD_5_0:1.49.0.10
	OPENBSD_5_0_BASE:1.49
	OPENBSD_4_9:1.49.0.8
	OPENBSD_4_9_BASE:1.49
	OPENBSD_4_8:1.49.0.6
	OPENBSD_4_8_BASE:1.49
	OPENBSD_4_7:1.49.0.2
	OPENBSD_4_7_BASE:1.49
	OPENBSD_4_6:1.49.0.4
	OPENBSD_4_6_BASE:1.49
	OPENBSD_4_5:1.46.0.12
	OPENBSD_4_5_BASE:1.46
	OPENBSD_4_4:1.46.0.10
	OPENBSD_4_4_BASE:1.46
	OPENBSD_4_3:1.46.0.8
	OPENBSD_4_3_BASE:1.46
	OPENBSD_4_2:1.46.0.6
	OPENBSD_4_2_BASE:1.46
	OPENBSD_4_1:1.46.0.4
	OPENBSD_4_1_BASE:1.46
	OPENBSD_4_0:1.46.0.2
	OPENBSD_4_0_BASE:1.46
	OPENBSD_3_9:1.43.0.2
	OPENBSD_3_9_BASE:1.43
	OPENBSD_3_8:1.36.0.2
	OPENBSD_3_8_BASE:1.36
	OPENBSD_3_7:1.30.0.2
	OPENBSD_3_7_BASE:1.30
	OPENBSD_3_6:1.29.0.2
	OPENBSD_3_6_BASE:1.29
	OPENBSD_3_5:1.27.0.2
	OPENBSD_3_5_BASE:1.27
	OPENBSD_3_4:1.26.0.2
	OPENBSD_3_4_BASE:1.26
	OPENBSD_3_3:1.25.0.4
	OPENBSD_3_3_BASE:1.25
	OPENBSD_3_2:1.25.0.2
	OPENBSD_3_2_BASE:1.25
	OPENBSD_3_1:1.21.0.2
	OPENBSD_3_1_BASE:1.21
	OPENBSD_3_0:1.16.0.2
	OPENBSD_3_0_BASE:1.16
	OPENBSD_2_9_BASE:1.4
	OPENBSD_2_9:1.4.0.2
	OPENBSD_2_8:1.3.0.2
	OPENBSD_2_8_BASE:1.3
	OPENBSD_2_7:1.2.0.2
	OPENBSD_2_7_BASE:1.2;
locks; strict;
comment	@ * @;


1.66
date	2016.10.24.17.18.42;	author jasper;	state Exp;
branches;
next	1.65;
commitid	IXOd0Psrml9wXinW;

1.65
date	2015.12.05.02.14.02;	author jsg;	state Exp;
branches;
next	1.64;
commitid	AOV1AfiKqi4NjM0Q;

1.64
date	2015.11.11.08.52.12;	author lum;	state Exp;
branches;
next	1.63;
commitid	CeBgYdF2woMqV5gx;

1.63
date	2015.11.09.11.44.00;	author jasper;	state Exp;
branches;
next	1.62;
commitid	OhOiH8uAa35fcUrS;

1.62
date	2015.11.09.07.52.18;	author jasper;	state Exp;
branches;
next	1.61;
commitid	jdIufX4AkertH2v7;

1.61
date	2015.10.31.11.59.47;	author jasper;	state Exp;
branches;
next	1.60;
commitid	U8nZYKS8w8nsC1zl;

1.60
date	2015.09.29.02.07.49;	author guenther;	state Exp;
branches;
next	1.59;
commitid	CahbaEqQk6XXuFul;

1.59
date	2015.05.08.12.35.08;	author bcallah;	state Exp;
branches;
next	1.58;
commitid	ipAmBG33jNfxs4qI;

1.58
date	2015.03.19.21.22.15;	author bcallah;	state Exp;
branches;
next	1.57;
commitid	GbEBL4CfPvDkB8hj;

1.57
date	2014.11.16.04.16.41;	author guenther;	state Exp;
branches;
next	1.56;
commitid	a9yG0qCw9VEW27qI;

1.56
date	2014.03.20.07.47.29;	author lum;	state Exp;
branches;
next	1.55;

1.55
date	2013.05.31.18.03.44;	author lum;	state Exp;
branches;
next	1.54;

1.54
date	2012.11.03.16.28.14;	author florian;	state Exp;
branches;
next	1.53;

1.53
date	2012.11.03.16.26.32;	author florian;	state Exp;
branches;
next	1.52;

1.52
date	2012.10.22.08.31.42;	author florian;	state Exp;
branches;
next	1.51;

1.51
date	2012.09.25.19.16.52;	author lum;	state Exp;
branches;
next	1.50;

1.50
date	2012.04.12.04.47.59;	author lum;	state Exp;
branches;
next	1.49;

1.49
date	2009.06.04.23.39.37;	author kjell;	state Exp;
branches;
next	1.48;

1.48
date	2009.06.03.20.58.20;	author kjell;	state Exp;
branches;
next	1.47;

1.47
date	2009.06.02.17.57.30;	author kjell;	state Exp;
branches;
next	1.46;

1.46
date	2006.04.02.17.18.58;	author kjell;	state Exp;
branches;
next	1.45;

1.45
date	2006.03.30.18.32.07;	author kjell;	state Exp;
branches;
next	1.44;

1.44
date	2006.03.28.20.16.24;	author kjell;	state Exp;
branches;
next	1.43;

1.43
date	2005.12.20.06.17.36;	author kjell;	state Exp;
branches;
next	1.42;

1.42
date	2005.12.13.06.01.27;	author kjell;	state Exp;
branches;
next	1.41;

1.41
date	2005.11.19.20.16.35;	author kjell;	state Exp;
branches;
next	1.40;

1.40
date	2005.11.18.20.56.52;	author deraadt;	state Exp;
branches;
next	1.39;

1.39
date	2005.11.11.18.40.51;	author deraadt;	state Exp;
branches;
next	1.38;

1.38
date	2005.11.11.18.40.01;	author kjell;	state Exp;
branches;
next	1.37;

1.37
date	2005.10.11.00.46.46;	author kjell;	state Exp;
branches;
next	1.36;

1.36
date	2005.08.09.00.53.48;	author kjell;	state Exp;
branches;
next	1.35;

1.35
date	2005.06.14.18.14.40;	author kjell;	state Exp;
branches;
next	1.34;

1.34
date	2005.05.31.20.38.59;	author kjell;	state Exp;
branches;
next	1.33;

1.33
date	2005.05.28.00.41.13;	author cloder;	state Exp;
branches;
next	1.32;

1.32
date	2005.04.28.07.23.56;	author otto;	state Exp;
branches;
next	1.31;

1.31
date	2005.04.03.02.09.28;	author db;	state Exp;
branches;
next	1.30;

1.30
date	2005.03.10.16.58.57;	author deraadt;	state Exp;
branches;
next	1.29;

1.29
date	2004.07.22.01.25.24;	author vincent;	state Exp;
branches;
next	1.28;

1.28
date	2004.07.08.21.28.06;	author vincent;	state Exp;
branches;
next	1.27;

1.27
date	2004.01.21.00.46.38;	author vincent;	state Exp;
branches;
next	1.26;

1.26
date	2003.04.16.17.30.49;	author millert;	state Exp;
branches;
next	1.25;

1.25
date	2002.08.22.23.28.19;	author deraadt;	state Exp;
branches;
next	1.24;

1.24
date	2002.07.03.17.25.38;	author vincent;	state Exp;
branches;
next	1.23;

1.23
date	2002.07.03.03.47.59;	author vincent;	state Exp;
branches;
next	1.22;

1.22
date	2002.07.01.14.33.44;	author vincent;	state Exp;
branches;
next	1.21;

1.21
date	2002.03.11.13.02.56;	author vincent;	state Exp;
branches;
next	1.20;

1.20
date	2002.02.16.21.27.49;	author millert;	state Exp;
branches;
next	1.19;

1.19
date	2002.02.14.23.00.56;	author vincent;	state Exp;
branches;
next	1.18;

1.18
date	2002.02.14.14.24.21;	author deraadt;	state Exp;
branches;
next	1.17;

1.17
date	2002.01.18.08.37.08;	author art;	state Exp;
branches;
next	1.16;

1.16
date	2001.05.24.09.47.33;	author art;	state Exp;
branches;
next	1.15;

1.15
date	2001.05.24.09.34.05;	author mickey;	state Exp;
branches;
next	1.14;

1.14
date	2001.05.24.01.55.49;	author mickey;	state Exp;
branches;
next	1.13;

1.13
date	2001.05.24.01.17.51;	author mickey;	state Exp;
branches;
next	1.12;

1.12
date	2001.05.23.23.29.47;	author mickey;	state Exp;
branches;
next	1.11;

1.11
date	2001.05.23.22.23.55;	author art;	state Exp;
branches;
next	1.10;

1.10
date	2001.05.23.22.20.35;	author art;	state Exp;
branches;
next	1.9;

1.9
date	2001.05.23.22.01.44;	author art;	state Exp;
branches;
next	1.8;

1.8
date	2001.05.23.21.42.34;	author art;	state Exp;
branches;
next	1.7;

1.7
date	2001.05.23.20.49.53;	author art;	state Exp;
branches;
next	1.6;

1.6
date	2001.05.23.16.25.24;	author art;	state Exp;
branches;
next	1.5;

1.5
date	2001.05.03.12.57.22;	author art;	state Exp;
branches;
next	1.4;

1.4
date	2001.01.29.01.58.07;	author niklas;	state Exp;
branches;
next	1.3;

1.3
date	2000.09.01.14.59.08;	author millert;	state Exp;
branches;
next	1.2;

1.2
date	2000.04.13.06.12.14;	author millert;	state Exp;
branches;
next	1.1;

1.1
date	2000.02.25.19.08.47;	author deraadt;	state Exp;
branches;
next	;


desc
@@


1.66
log
@remove double semicolon

from Brian Callahan
@
text
@/*	$OpenBSD: echo.c,v 1.65 2015/12/05 02:14:02 jsg Exp $	*/

/* This file is in the public domain. */

/*
 *	Echo line reading and writing.
 *
 * Common routines for reading and writing characters in the echo line area
 * of the display screen. Used by the entire known universe.
 */

#include <sys/queue.h>
#include <signal.h>
#include <stdarg.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <term.h>

#include "def.h"
#include "funmap.h"
#include "key.h"
#include "macro.h"

static char	*veread(const char *, char *, size_t, int, va_list)
			__attribute__((__format__ (printf, 1, 0)));
static int	 complt(int, int, char *, size_t, int, int *);
static int	 complt_list(int, char *, int);
static void	 eformat(const char *, va_list)
			__attribute__((__format__ (printf, 1, 0)));
static void	 eputi(int, int);
static void	 eputl(long, int);
static void	 eputs(const char *);
static void	 eputc(char);
static struct list	*copy_list(struct list *);

int		epresf = FALSE;		/* stuff in echo line flag */

/*
 * Erase the echo line.
 */
void
eerase(void)
{
	ttcolor(CTEXT);
	ttmove(nrow - 1, 0);
	tteeol();
	ttflush();
	epresf = FALSE;
}

/*
 * Ask a "yes" or "no" question.  Return ABORT if the user answers the
 * question with the abort ("^G") character.  Return FALSE for "no" and
 * TRUE for "yes".  No formatting services are available.  No newline
 * required.
 */
int
eyorn(const char *sp)
{
	int	 s;

	if (inmacro)
		return (TRUE);

	ewprintf("%s? (y or n) ", sp);
	for (;;) {
		s = getkey(FALSE);
		if (s == 'y' || s == 'Y' || s == ' ') {
			ewprintf("");
			return (TRUE);
		}
		if (s == 'n' || s == 'N' || s == CCHR('M')) {
			ewprintf("");
			return (FALSE);
		}
		if (s == CCHR('G')) {
			ewprintf("");
			return (ctrlg(FFRAND, 1));
		}
		ewprintf("Please answer y or n.  %s? (y or n) ", sp);
	}
	/* NOTREACHED */
}

/*
 * Ask a "yes", "no" or "revert" question.  Return ABORT if the user answers
 * the question with the abort ("^G") character.  Return FALSE for "no",
 * TRUE for "yes" and REVERT for "revert". No formatting services are
 * available.  No newline required.
 */
int
eynorr(const char *sp)
{
	int	 s;

	if (inmacro)
		return (TRUE);

	ewprintf("%s? (y, n or r) ", sp);
	for (;;) {
		s = getkey(FALSE);
		if (s == 'y' || s == 'Y' || s == ' ') {
			ewprintf("");
			return (TRUE);
		}
		if (s == 'n' || s == 'N' || s == CCHR('M')) {
			ewprintf("");
			return (FALSE);
		}
		if (s == 'r' || s == 'R') {
			ewprintf("");
			return (REVERT);
		}
		if (s == CCHR('G')) {
			ewprintf("");
			return (ctrlg(FFRAND, 1));
		}
		ewprintf("Please answer y, n or r.");
	}
	/* NOTREACHED */
}

/*
 * Like eyorn, but for more important questions.  User must type all of
 * "yes" or "no" and the trailing newline.
 */
int
eyesno(const char *sp)
{
	char	 buf[64], *rep;

	if (inmacro)
		return (TRUE);

	rep = eread("%s? (yes or no) ", buf, sizeof(buf),
	    EFNUL | EFNEW | EFCR, sp);
	for (;;) {
		if (rep == NULL) {
			ewprintf("");
			return (ABORT);
		}
		if (rep[0] != '\0') {
			if (macrodef) {
				struct line	*lp = maclcur;

				maclcur = lp->l_bp;
				maclcur->l_fp = lp->l_fp;
				free(lp);
			}
			if (strcasecmp(rep, "yes") == 0) {
				ewprintf("");
				return (TRUE);
			}
			if (strcasecmp(rep, "no") == 0) {
				ewprintf("");
				return (FALSE);
			}
		}
		rep = eread("Please answer yes or no.  %s? (yes or no) ",
		    buf, sizeof(buf), EFNUL | EFNEW | EFCR, sp);
	}
	/* NOTREACHED */
}

/*
 * This is the general "read input from the echo line" routine.  The basic
 * idea is that the prompt string "prompt" is written to the echo line, and
 * a one line reply is read back into the supplied "buf" (with maximum
 * length "len").
 * XXX: When checking for an empty return value, always check rep, *not* buf
 * as buf may be freed in pathological cases.
 */
char *
eread(const char *fmt, char *buf, size_t nbuf, int flag, ...)
{
	va_list	 ap;
	char	*rep;

	va_start(ap, flag);
	rep = veread(fmt, buf, nbuf, flag, ap);
	va_end(ap);
	return (rep);
}

static char *
veread(const char *fp, char *buf, size_t nbuf, int flag, va_list ap)
{
	int	 dynbuf = (buf == NULL);
	int	 cpos, epos;		/* cursor, end position in buf */
	int	 c, i, y;
	int	 cplflag;		/* display completion list */
	int	 cwin = FALSE;		/* completion list created */
	int	 mr, ml;		/* match left/right arrows */
	int	 esc;			/* position in esc pattern */
	struct buffer	*bp;			/* completion list buffer */
	struct mgwin	*wp;			/* window for compl list */
	int	 match;			/* esc match found */
	int	 cc, rr;		/* saved ttcol, ttrow */
	char	*ret;			/* return value */

	static char emptyval[] = "";	/* XXX hackish way to return err msg*/

	if (inmacro) {
		if (dynbuf) {
			if ((buf = malloc(maclcur->l_used + 1)) == NULL)
				return (NULL);
		} else if (maclcur->l_used >= nbuf)
			return (NULL);
		bcopy(maclcur->l_text, buf, maclcur->l_used);
		buf[maclcur->l_used] = '\0';
		maclcur = maclcur->l_fp;
		return (buf);
	}
	epos = cpos = 0;
	ml = mr = esc = 0;
	cplflag = FALSE;

	if ((flag & EFNEW) != 0 || ttrow != nrow - 1) {
		ttcolor(CTEXT);
		ttmove(nrow - 1, 0);
		epresf = TRUE;
	} else
		eputc(' ');
	eformat(fp, ap);
	if ((flag & EFDEF) != 0) {
		if (buf == NULL)
			return (NULL);
		eputs(buf);
		epos = cpos += strlen(buf);
	}
	tteeol();
	ttflush();
	for (;;) {
		c = getkey(FALSE);
		if ((flag & EFAUTO) != 0 && c == CCHR('I')) {
			if (cplflag == TRUE) {
				complt_list(flag, buf, cpos);
				cwin = TRUE;
			} else if (complt(flag, c, buf, nbuf, epos, &i) == TRUE) {
				cplflag = TRUE;
				epos += i;
				cpos = epos;
			}
			continue;
		}
		cplflag = FALSE;

		if (esc > 0) { /* ESC sequence started */
			match = 0;
			if (ml == esc && key_left[ml] && c == key_left[ml]) {
				match++;
				if (key_left[++ml] == '\0') {
					c = CCHR('B');
					esc = 0;
				}
			}
			if (mr == esc && key_right[mr] && c == key_right[mr]) {
				match++;
				if (key_right[++mr] == '\0') {
					c = CCHR('F');
					esc = 0;
				}
			}
			if (match == 0) {
				esc = 0;
				continue;
				/* hack. how do we know esc pattern is done? */
			}
			if (esc > 0) {
				esc++;
				continue;
			}
		}
		switch (c) {
		case CCHR('A'): /* start of line */
			while (cpos > 0) {
				if (ISCTRL(buf[--cpos]) != FALSE) {
					ttputc('\b');
					--ttcol;
				}
				ttputc('\b');
				--ttcol;
			}
			ttflush();
			break;
		case CCHR('D'):
			if (cpos != epos) {
				tteeol();
				epos--;
				rr = ttrow;
				cc = ttcol;
				for (i = cpos; i < epos; i++) {
					buf[i] = buf[i + 1];
					eputc(buf[i]);
				}
				ttmove(rr, cc);
				ttflush();
			}
			break;
		case CCHR('E'): /* end of line */
			while (cpos < epos) {
				eputc(buf[cpos++]);
			}
			ttflush();
			break;
		case CCHR('B'): /* back */
			if (cpos > 0) {
				if (ISCTRL(buf[--cpos]) != FALSE) {
					ttputc('\b');
					--ttcol;
				}
				ttputc('\b');
				--ttcol;
				ttflush();
			}
			break;
		case CCHR('F'): /* forw */
			if (cpos < epos) {
				eputc(buf[cpos++]);
				ttflush();
			}
			break;
		case CCHR('Y'): /* yank from kill buffer */
			i = 0;
			while ((y = kremove(i++)) >= 0 && y != '\n') {
				int t;
				if (dynbuf && epos + 1 >= nbuf) {
					void *newp;
					size_t newsize = epos + epos + 16;
					if ((newp = realloc(buf, newsize))
					    == NULL)
						goto memfail;
					buf = newp;
					nbuf = newsize;
				}
				if (!dynbuf && epos + 1 >= nbuf) {
					dobeep();
					ewprintf("Line too long");
					return (emptyval);
				}
				for (t = epos; t > cpos; t--)
					buf[t] = buf[t - 1];
				buf[cpos++] = (char)y;
				epos++;
				eputc((char)y);
				cc = ttcol;
				rr = ttrow;
				for (t = cpos; t < epos; t++)
					eputc(buf[t]);
				ttmove(rr, cc);
			}
			ttflush();
			break;
		case CCHR('K'): /* copy here-EOL to kill buffer */
			kdelete();
			for (i = cpos; i < epos; i++)
				kinsert(buf[i], KFORW);
			tteeol();
			epos = cpos;
			ttflush();
			break;
		case CCHR('['):
			ml = mr = esc = 1;
			break;
		case CCHR('J'):
			c = CCHR('M');
			/* FALLTHROUGH */
		case CCHR('M'):			/* return, done */
			/* if there's nothing in the minibuffer, abort */
			if (epos == 0 && !(flag & EFNUL)) {
				(void)ctrlg(FFRAND, 0);
				ttflush();
				return (NULL);
			}
			if ((flag & EFFUNC) != 0) {
				if (complt(flag, c, buf, nbuf, epos, &i)
				    == FALSE)
					continue;
				if (i > 0)
					epos += i;
			}
			buf[epos] = '\0';
			if ((flag & EFCR) != 0) {
				ttputc(CCHR('M'));
				ttflush();
			}
			if (macrodef) {
				struct line	*lp;

				if ((lp = lalloc(cpos)) == NULL)
					goto memfail;
				lp->l_fp = maclcur->l_fp;
				maclcur->l_fp = lp;
				lp->l_bp = maclcur;
				maclcur = lp;
				bcopy(buf, lp->l_text, cpos);
			}
			ret = buf;
			goto done;
		case CCHR('G'):			/* bell, abort */
			eputc(CCHR('G'));
			(void)ctrlg(FFRAND, 0);
			ttflush();
			ret = NULL;
			goto done;
		case CCHR('H'):			/* rubout, erase */
		case CCHR('?'):
			if (cpos != 0) {
				y = buf[--cpos];
				epos--;
				ttputc('\b');
				ttcol--;
				if (ISCTRL(y) != FALSE) {
					ttputc('\b');
					ttcol--;
				}
				rr = ttrow;
				cc = ttcol;
				for (i = cpos; i < epos; i++) {
					buf[i] = buf[i + 1];
					eputc(buf[i]);
				}
				ttputc(' ');
				if (ISCTRL(y) != FALSE) {
					ttputc(' ');
					ttputc('\b');
				}
				ttputc('\b');
				ttmove(rr, cc);
				ttflush();
			}
			break;
		case CCHR('X'):			/* kill line */
		case CCHR('U'):
			while (cpos != 0) {
				ttputc('\b');
				ttputc(' ');
				ttputc('\b');
				--ttcol;
				if (ISCTRL(buf[--cpos]) != FALSE) {
					ttputc('\b');
					ttputc(' ');
					ttputc('\b');
					--ttcol;
				}
				epos--;
			}
			ttflush();
			break;
		case CCHR('W'):			/* kill to beginning of word */
			while ((cpos > 0) && !ISWORD(buf[cpos - 1])) {
				ttputc('\b');
				ttputc(' ');
				ttputc('\b');
				--ttcol;
				if (ISCTRL(buf[--cpos]) != FALSE) {
					ttputc('\b');
					ttputc(' ');
					ttputc('\b');
					--ttcol;
				}
				epos--;
			}
			while ((cpos > 0) && ISWORD(buf[cpos - 1])) {
				ttputc('\b');
				ttputc(' ');
				ttputc('\b');
				--ttcol;
				if (ISCTRL(buf[--cpos]) != FALSE) {
					ttputc('\b');
					ttputc(' ');
					ttputc('\b');
					--ttcol;
				}
				epos--;
			}
			ttflush();
			break;
		case CCHR('\\'):
		case CCHR('Q'):			/* quote next */
			c = getkey(FALSE);
			/* FALLTHROUGH */
		default:
			if (dynbuf && epos + 1 >= nbuf) {
				void *newp;
				size_t newsize = epos + epos + 16;
				if ((newp = realloc(buf, newsize)) == NULL)
					goto memfail;
				buf = newp;
				nbuf = newsize;
			}
			if (!dynbuf && epos + 1 >= nbuf) {
				dobeep();
				ewprintf("Line too long");
				return (emptyval);
			}
			for (i = epos; i > cpos; i--)
				buf[i] = buf[i - 1];
			buf[cpos++] = (char)c;
			epos++;
			eputc((char)c);
			cc = ttcol;
			rr = ttrow;
			for (i = cpos; i < epos; i++)
				eputc(buf[i]);
			ttmove(rr, cc);
			ttflush();
		}
	}
done:
	if (cwin == TRUE) {
		/* blow away cpltion window */
		bp = bfind("*Completions*", TRUE);
		if ((wp = popbuf(bp, WEPHEM)) != NULL) {
			if (wp->w_flag & WEPHEM) {
				curwp = wp;
				delwind(FFRAND, 1);
			} else {
				killbuffer(bp);
			}
		}
	}
	return (ret);
memfail:
	if (dynbuf && buf)
		free(buf);
	dobeep();
	ewprintf("Out of memory");
	return (emptyval);
}

/*
 * Do completion on a list of objects.
 * c is SPACE, TAB, or CR
 * return TRUE if matched (or partially matched)
 * FALSE is result is ambiguous,
 * ABORT on error.
 */
static int
complt(int flags, int c, char *buf, size_t nbuf, int cpos, int *nx)
{
	struct list	*lh, *lh2;
	struct list	*wholelist = NULL;
	int	 i, nxtra, nhits, bxtra, msglen, nshown;
	int	 wflag = FALSE;
	char	*msg;

	lh = lh2 = NULL;

	if ((flags & EFFUNC) != 0) {
		buf[cpos] = '\0';
		wholelist = lh = complete_function_list(buf);
	} else if ((flags & EFBUF) != 0) {
		lh = &(bheadp->b_list);
	} else if ((flags & EFFILE) != 0) {
		buf[cpos] = '\0';
		wholelist = lh = make_file_list(buf);
	} else
		panic("broken complt call: flags");

	if (c == ' ')
		wflag = TRUE;
	else if (c != '\t' && c != CCHR('M'))
		panic("broken complt call: c");

	nhits = 0;
	nxtra = HUGE;

	for (; lh != NULL; lh = lh->l_next) {
		if (memcmp(buf, lh->l_name, cpos) != 0)
			continue;
		if (nhits == 0)
			lh2 = lh;
		++nhits;
		if (lh->l_name[cpos] == '\0')
			nxtra = -1; /* exact match */
		else {
			bxtra = getxtra(lh, lh2, cpos, wflag);
			if (bxtra < nxtra)
				nxtra = bxtra;
			lh2 = lh;
		}
	}
	if (nhits == 0)
		msg = " [No match]";
	else if (nhits > 1 && nxtra == 0)
		msg = " [Ambiguous. Ctrl-G to cancel]";
	else {
		/*
		 * Being lazy - ought to check length, but all things
		 * autocompleted have known types/lengths.
		 */
		if (nxtra < 0 && nhits > 1 && c == ' ')
			nxtra = 1; /* ??? */
		for (i = 0; i < nxtra && cpos < nbuf; ++i) {
			buf[cpos] = lh2->l_name[cpos];
			eputc(buf[cpos++]);
		}
		/* XXX should grow nbuf */
		ttflush();
		free_file_list(wholelist);
		*nx = nxtra;
		if (nxtra < 0 && c != CCHR('M')) /* exact */
			*nx = 0;
		return (TRUE);
	}

	/*
	 * wholelist is NULL if we are doing buffers.  Want to free lists
	 * that were created for us, but not the buffer list!
	 */
	free_file_list(wholelist);

	/* Set up backspaces, etc., being mindful of echo line limit. */
	msglen = strlen(msg);
	nshown = (ttcol + msglen + 2 > ncol) ?
		ncol - ttcol - 2 : msglen;
	eputs(msg);
	ttcol -= (i = nshown);	/* update ttcol!		 */
	while (i--)		/* move back before msg		 */
		ttputc('\b');
	ttflush();		/* display to user		 */
	i = nshown;
	while (i--)		/* blank out on next flush	 */
		eputc(' ');
	ttcol -= (i = nshown);	/* update ttcol on BS's		 */
	while (i--)
		ttputc('\b');	/* update ttcol again!		 */
	*nx = nxtra;
	return ((nhits > 0) ? TRUE : FALSE);
}

/*
 * Do completion on a list of objects, listing instead of completing.
 */
static int
complt_list(int flags, char *buf, int cpos)
{
	struct list	*lh, *lh2, *lh3;
	struct list	*wholelist = NULL;
	struct buffer	*bp;
	int	 i, maxwidth, width;
	int	 preflen = 0;
	int	 oldrow = ttrow;
	int	 oldcol = ttcol;
	int	 oldhue = tthue;
	char	 *linebuf;
	size_t	 linesize, len;
	char *cp;

	lh = NULL;

	ttflush();

	/* The results are put into a completion buffer. */
	bp = bfind("*Completions*", TRUE);
	if (bclear(bp) == FALSE)
		return (FALSE);
	bp->b_flag |= BFREADONLY;

	/*
	 * First get the list of objects.  This list may contain only
	 * the ones that complete what has been typed, or may be the
	 * whole list of all objects of this type.  They are filtered
	 * later in any case.  Set wholelist if the list has been
	 * cons'ed up just for us, so we can free it later.  We have
	 * to copy the buffer list for this function even though we
	 * didn't for complt.  The sorting code does destructive
	 * changes to the list, which we don't want to happen to the
	 * main buffer list!
	 */
	if ((flags & EFBUF) != 0)
		wholelist = lh = copy_list(&(bheadp->b_list));
	else if ((flags & EFFUNC) != 0) {
		buf[cpos] = '\0';
		wholelist = lh = complete_function_list(buf);
	} else if ((flags & EFFILE) != 0) {
		buf[cpos] = '\0';
		wholelist = lh = make_file_list(buf);
		/*
		 * We don't want to display stuff up to the / for file
		 * names preflen is the list of a prefix of what the
		 * user typed that should not be displayed.
		 */
		cp = strrchr(buf, '/');
		if (cp)
			preflen = cp - buf + 1;
	} else
		panic("broken complt call: flags");

	/*
	 * Sort the list, since users expect to see it in alphabetic
	 * order.
	 */
	lh2 = lh;
	while (lh2 != NULL) {
		lh3 = lh2->l_next;
		while (lh3 != NULL) {
			if (strcmp(lh2->l_name, lh3->l_name) > 0) {
				cp = lh2->l_name;
				lh2->l_name = lh3->l_name;
				lh3->l_name = cp;
			}
			lh3 = lh3->l_next;
		}
		lh2 = lh2->l_next;
	}

	/*
	 * First find max width of object to be displayed, so we can
	 * put several on a line.
	 */
	maxwidth = 0;
	lh2 = lh;
	while (lh2 != NULL) {
		for (i = 0; i < cpos; ++i) {
			if (buf[i] != lh2->l_name[i])
				break;
		}
		if (i == cpos) {
			width = strlen(lh2->l_name);
			if (width > maxwidth)
				maxwidth = width;
		}
		lh2 = lh2->l_next;
	}
	maxwidth += 1 - preflen;

	/*
	 * Now do the display.  Objects are written into linebuf until
	 * it fills, and then put into the help buffer.
	 */
	linesize = (ncol > maxwidth ? ncol : maxwidth) + 1;
	if ((linebuf = malloc(linesize)) == NULL) {
		free_file_list(wholelist);
		return (FALSE);
	}
	width = 0;

	/*
	 * We're going to strlcat() into the buffer, so it has to be
	 * NUL terminated.
	 */
	linebuf[0] = '\0';
	for (lh2 = lh; lh2 != NULL; lh2 = lh2->l_next) {
		for (i = 0; i < cpos; ++i) {
			if (buf[i] != lh2->l_name[i])
				break;
		}
		/* if we have a match */
		if (i == cpos) {
			/* if it wraps */
			if ((width + maxwidth) > ncol) {
				addline(bp, linebuf);
				linebuf[0] = '\0';
				width = 0;
			}
			len = strlcat(linebuf, lh2->l_name + preflen,
			    linesize);
			width += maxwidth;
			if (len < width && width < linesize) {
				/* pad so the objects nicely line up */
				memset(linebuf + len, ' ',
				    maxwidth - strlen(lh2->l_name + preflen));
				linebuf[width] = '\0';
			}
		}
	}
	if (width > 0)
		addline(bp, linebuf);
	free(linebuf);

	/*
	 * Note that we free lists only if they are put in wholelist lists
	 * that were built just for us should be freed.  However when we use
	 * the buffer list, obviously we don't want it freed.
	 */
	free_file_list(wholelist);
	popbuftop(bp, WEPHEM);	/* split the screen and put up the help
				 * buffer */
	update(CMODE);		/* needed to make the new stuff actually
				 * appear */
	ttmove(oldrow, oldcol);	/* update leaves cursor in arbitrary place */
	ttcolor(oldhue);	/* with arbitrary color */
	ttflush();
	return (0);
}

/*
 * The "lp1" and "lp2" point to list structures.  The "cpos" is a horizontal
 * position in the name.  Return the longest block of characters that can be
 * autocompleted at this point.  Sometimes the two symbols are the same, but
 * this is normal.
 */
int
getxtra(struct list *lp1, struct list *lp2, int cpos, int wflag)
{
	int	i;

	i = cpos;
	for (;;) {
		if (lp1->l_name[i] != lp2->l_name[i])
			break;
		if (lp1->l_name[i] == '\0')
			break;
		++i;
		if (wflag && !ISWORD(lp1->l_name[i - 1]))
			break;
	}
	return (i - cpos);
}

/*
 * Special "printf" for the echo line.  Each call to "ewprintf" starts a
 * new line in the echo area, and ends with an erase to end of the echo
 * line.  The formatting is done by a call to the standard formatting
 * routine.
 */
void
ewprintf(const char *fmt, ...)
{
	va_list	 ap;

	if (inmacro)
		return;

	va_start(ap, fmt);
	ttcolor(CTEXT);
	ttmove(nrow - 1, 0);
	eformat(fmt, ap);
	va_end(ap);
	tteeol();
	ttflush();
	epresf = TRUE;
}

/*
 * Printf style formatting. This is called by "ewprintf" to provide
 * formatting services to its clients.  The move to the start of the
 * echo line, and the erase to the end of the echo line, is done by
 * the caller. 
 * %c prints the "name" of the supplied character.
 * %k prints the name of the current key (and takes no arguments).
 * %d prints a decimal integer
 * %o prints an octal integer
 * %p prints a pointer
 * %s prints a string
 * %ld prints a long word
 * Anything else is echoed verbatim
 */
static void
eformat(const char *fp, va_list ap)
{
	char	kname[NKNAME], tmp[100], *cp;
	int	c;

	while ((c = *fp++) != '\0') {
		if (c != '%')
			eputc(c);
		else {
			c = *fp++;
			switch (c) {
			case 'c':
				getkeyname(kname, sizeof(kname),
				    va_arg(ap, int));
				eputs(kname);
				break;

			case 'k':
				for (cp = kname, c = 0; c < key.k_count; c++) {
					if (c)
						*cp++ = ' ';
					cp = getkeyname(cp, sizeof(kname) -
					    (cp - kname) - 1, key.k_chars[c]);
				}
				eputs(kname);
				break;

			case 'd':
				eputi(va_arg(ap, int), 10);
				break;

			case 'o':
				eputi(va_arg(ap, int), 8);
				break;

			case 'p':
				snprintf(tmp, sizeof(tmp), "%p",
				    va_arg(ap, void *));
				eputs(tmp);
				break;

			case 's':
				eputs(va_arg(ap, char *));
				break;

			case 'l':
				/* explicit longword */
				c = *fp++;
				switch (c) {
				case 'd':
					eputl(va_arg(ap, long), 10);
					break;
				default:
					eputc(c);
					break;
				}
				break;

			default:
				eputc(c);
			}
		}
	}
}

/*
 * Put integer, in radix "r".
 */
static void
eputi(int i, int r)
{
	int	 q;

	if (i < 0) {
		eputc('-');
		i = -i;
	}
	if ((q = i / r) != 0)
		eputi(q, r);
	eputc(i % r + '0');
}

/*
 * Put long, in radix "r".
 */
static void
eputl(long l, int r)
{
	long	 q;

	if (l < 0) {
		eputc('-');
		l = -l;
	}
	if ((q = l / r) != 0)
		eputl(q, r);
	eputc((int)(l % r) + '0');
}

/*
 * Put string.
 */
static void
eputs(const char *s)
{
	int	 c;

	while ((c = *s++) != '\0')
		eputc(c);
}

/*
 * Put character.  Watch for control characters, and for the line getting
 * too long.
 */
static void
eputc(char c)
{
	if (ttcol + 2 < ncol) {
		if (ISCTRL(c)) {
			eputc('^');
			c = CCHR(c);
		}
		ttputc(c);
		++ttcol;
	}
}

void
free_file_list(struct list *lp)
{
	struct list	*next;

	while (lp) {
		next = lp->l_next;
		free(lp->l_name);
		free(lp);
		lp = next;
	}
}

static struct list *
copy_list(struct list *lp)
{
	struct list	*current, *last, *nxt;

	last = NULL;
	while (lp) {
		current = malloc(sizeof(struct list));
		if (current == NULL) {
			/* Free what we have allocated so far */
			for (current = last; current; current = nxt) {
				nxt = current->l_next;
				free(current->l_name);
				free(current);
			}
			return (NULL);
		}
		current->l_next = last;
		current->l_name = strdup(lp->l_name);
		last = current;
		lp = lp->l_next;
	}
	return (last);
}
@


1.65
log
@Fix an incorrect use of sizeof(pointer) by removing it and switching
from strncasecmp to strcasecmp which will stop matching strings
with unwanted trailing characters.

ok jasper@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: echo.c,v 1.64 2015/11/11 08:52:12 lum Exp $	*/
d30 1
a30 1
			__attribute__((__format__ (printf, 1, 0)));;
@


1.64
log
@Clear the mini buffer once a question has been displayed. ok jasper@@
@
text
@d1 1
a1 1
/*	$OpenBSD: echo.c,v 1.63 2015/11/09 11:44:00 jasper Exp $	*/
d151 1
a151 1
			if (strncasecmp(rep, "yes", sizeof(rep)) == 0) {
d155 1
a155 1
			if (strncasecmp(rep, "no", sizeof(rep)) == 0) {
@


1.63
log
@use strncasecmp()

ok lum@@
@
text
@d1 1
a1 1
/*	$OpenBSD: echo.c,v 1.62 2015/11/09 07:52:18 jasper Exp $	*/
d69 2
a70 1
		if (s == 'y' || s == 'Y' || s == ' ')
d72 3
a74 1
		if (s == 'n' || s == 'N' || s == CCHR('M'))
d76 3
a78 1
		if (s == CCHR('G'))
d80 1
d103 2
a104 1
		if (s == 'y' || s == 'Y' || s == ' ')
d106 3
a108 1
		if (s == 'n' || s == 'N' || s == CCHR('M'))
d110 3
a112 1
		if (s == 'r' || s == 'R')
d114 3
a116 1
		if (s == CCHR('G'))
d118 1
d139 2
a140 1
		if (rep == NULL)
d142 1
d151 2
a152 1
			if (strncasecmp(rep, "yes", sizeof(rep)) == 0)
d154 3
a156 1
			if (strncasecmp(rep, "no", sizeof(rep)) == 0)
d158 1
@


1.62
log
@no need to initialize variables that are being initialized a few lines below

ok lum@@ on a previous diff
@
text
@d1 1
a1 1
/*	$OpenBSD: echo.c,v 1.61 2015/10/31 11:59:47 jasper Exp $	*/
d135 1
a135 4
			if ((rep[0] == 'y' || rep[0] == 'Y') &&
			    (rep[1] == 'e' || rep[1] == 'E') &&
			    (rep[2] == 's' || rep[2] == 'S') &&
			    (rep[3] == '\0'))
d137 1
a137 3
			if ((rep[0] == 'n' || rep[0] == 'N') &&
			    (rep[1] == 'o' || rep[0] == 'O') &&
			    (rep[2] == '\0'))
@


1.61
log
@mark *Completions* buffer as read-only

ok lum@@
@
text
@d1 1
a1 1
/*	$OpenBSD: echo.c,v 1.60 2015/09/29 02:07:49 guenther Exp $	*/
d177 1
a177 1
	int	 cplflag = FALSE;	/* display completion list */
d179 2
a180 3
	int	 mr = 0;		/* match left arrow */
	int	 ml = 0;		/* match right arrow */
	int	 esc = 0;		/* position in esc pattern */
@


1.60
log
@Mark eread(), veread(), and eformat() as printf-like and
Convert eread(buf, a2, a3, a4) to eread("%s", a2, a3, a4, buf)

ok millert@@ lum@@
@
text
@d1 1
a1 1
/*	$OpenBSD: echo.c,v 1.59 2015/05/08 12:35:08 bcallah Exp $	*/
d646 1
@


1.59
log
@Remove ereply prototype since it is never used. Tweak a comment to reflect
ereply removal.
ok jasper@@ florian@@
@
text
@d1 1
a1 1
/*	$OpenBSD: echo.c,v 1.58 2015/03/19 21:22:15 bcallah Exp $	*/
d25 2
a26 1
static char	*veread(const char *, char *, size_t, int, va_list);
d29 2
a30 1
static void	 eformat(const char *, va_list);
a158 1
/* VARARGS */
a804 1
/* VARARGS */
@


1.58
log
@Clean up the includes in mg.
This does the following:
Moves all POSIX headers from sysdef.h into the individual .c files so that
each file now only includes what it needs. All headers are properly sorted.
Moves the remainder of sysdef.h to other files (mostly def.h) and deletes
sysdef.h now that it's no longer contains anything.
Tweak a comment that references sysdef.h so that it no longer does that.
ok florian@@
@
text
@d1 1
a1 1
/*	$OpenBSD: echo.c,v 1.57 2014/11/16 04:16:41 guenther Exp $	*/
d824 3
a826 3
 * Printf style formatting. This is called by both "ewprintf" and "ereply"
 * to provide formatting services to their clients.  The move to the start
 * of the echo line, and the erase to the end of the echo line, is done by
@


1.57
log
@Stop using <sys/param.h>; replace MAXPATHLEN with PATH_MAX, stop using MAX(),
and pull in <limits.h> for *_MAX constants.

inspired on a diff from Kamil Rytarowski (n54 (at) gmx.com)
ok bcallah@@
@
text
@d1 1
a1 1
/*	$OpenBSD: echo.c,v 1.56 2014/03/20 07:47:29 lum Exp $	*/
d12 8
d21 1
a23 5

#include "funmap.h"

#include <stdarg.h>
#include <term.h>
@


1.56
log
@Add some missing dobeeps.
ok florian@@
@
text
@d1 1
a1 1
/*	$OpenBSD: echo.c,v 1.55 2013/05/31 18:03:44 lum Exp $	*/
d714 1
a714 1
	linesize = MAX(ncol, maxwidth) + 1;
@


1.55
log
@Make the system bell toggleable via 'audible-bell', and if switched
off, make available an alternative 'visible-bell'.

ok florian@@ jasper@@ Feedback Sunil Nimmagadda.
@
text
@d1 1
a1 1
/*	$OpenBSD: echo.c,v 1.54 2012/11/03 16:28:14 florian Exp $	*/
d319 1
d475 1
d509 1
@


1.54
log
@fix potential memory leak, found by llvm

ok haesbaert, lum, benno
@
text
@d1 1
a1 1
/*	$OpenBSD: echo.c,v 1.53 2012/11/03 16:26:32 florian Exp $	*/
d759 1
a759 1
	update();		/* needed to make the new stuff actually
@


1.53
log
@kill dead assignment, found by llvm

ok haesbaert, lum, benno
@
text
@d1 1
a1 1
/*	$OpenBSD: echo.c,v 1.52 2012/10/22 08:31:42 florian Exp $	*/
d712 2
a713 1
	if ((linebuf = malloc(linesize)) == NULL)
d715 1
@


1.52
log
@Add (r)evert prompt to "File changed on disk; really edit the buffer"
prompt.

input, ok lum@@, man bit ok jmc@@, ok benno@@
@
text
@d1 1
a1 1
/*	$OpenBSD: echo.c,v 1.51 2012/09/25 19:16:52 lum Exp $	*/
a270 1
				y = buf[cpos];
@


1.51
log
@Stop the space char completing a file name. This mimics more recent
versions of emacs.

kjell and jasper@@ agree.
@
text
@d1 1
a1 1
/*	$OpenBSD: echo.c,v 1.50 2012/04/12 04:47:59 lum Exp $	*/
d70 30
@


1.50
log
@Remove the conditional directives NO_MACRO and NO_STARTUP.
They have not compiled for numerous years.
ok kjell@@ millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: echo.c,v 1.49 2009/06/04 23:39:37 kjell Exp $	*/
d187 1
a187 1
		if ((flag & EFAUTO) != 0 && (c == ' ' || c == CCHR('I'))) {
@


1.49
log
@Add the notion of an "ephemeral" popup, so we can flag a window
for destruction at a later date. (in the process, add a window flag field)

This fixes an issue noted by maja: namely, the *completion*
window that pops up when you try to complete a filename on
buffer load would destroy any second window that you happened
to have open.

ok maja@@
@
text
@d1 1
a1 1
/*	$OpenBSD: echo.c,v 1.48 2009/06/03 20:58:20 kjell Exp $	*/
a13 1
#ifndef NO_MACRO
a14 1
#endif /* !NO_MACRO */
a56 1
#ifndef NO_MACRO
d59 1
a59 1
#endif /* !NO_MACRO */
a82 1
#ifndef NO_MACRO
d85 1
a85 1
#endif /* !NO_MACRO */
a91 1
#ifndef NO_MACRO
a98 1
#endif /* !NO_MACRO */
a154 1
#ifndef NO_MACRO
a165 1
#endif /* !NO_MACRO */
a338 1
#ifndef NO_MACRO
a349 1
#endif /* !NO_MACRO */
a771 1
#ifndef NO_MACRO
d774 1
a774 1
#endif /* !NO_MACRO */
@


1.48
log
@Match comment to reality, whitespace
@
text
@d1 1
a1 1
/*	$OpenBSD: echo.c,v 1.47 2009/06/02 17:57:30 kjell Exp $	*/
d475 7
a481 3
		if ((wp = popbuf(bp)) != NULL) {
			curwp = wp;
			delwind(FFRAND, 1);
d736 1
a736 1
	popbuftop(bp);		/* split the screen and put up the help
@


1.47
log
@Fix the long-standing crash when >NXNAME characters were inserted
into minibuffer. Found and fixed by Martynas. Cleaned up
a bit so that error messages display properly in the status line.
Fixes Debian bug #414846
@
text
@d1 1
a1 1
/*	$OpenBSD: echo.c,v 1.46 2006/04/02 17:18:58 kjell Exp $	*/
d796 9
a804 3
 * the caller.
 * Note: %c works, and prints the "name" of the character.
 * %k prints the name of a key (and takes no arguments).
d819 2
a820 1
				getkeyname(kname, sizeof(kname), va_arg(ap, int));
@


1.46
log
@fix ^W (delete to start of word) in minibuffer;
i.e. actually kill text, don't just move the pointer.
@
text
@d1 1
a1 1
/*	$OpenBSD: echo.c,v 1.45 2006/03/30 18:32:07 kjell Exp $	*/
d159 2
d293 1
a293 1
						goto fail;
d297 4
d351 2
a352 7
				if ((lp = lalloc(cpos)) == NULL) {
					static char falseval[] = "";
					/* XXX hackish */
					if (dynbuf && buf != NULL)
						free(buf);
					return (falseval);
				}
d450 1
a450 1
					goto fail;
d454 4
d481 3
a483 1
fail:
d485 1
a485 2
	free(buf);
	return (NULL);
@


1.45
log
@Clean up some allocations. Remove malloc casts, and some easy
malloc(A*B)->calloc changes.
@
text
@d1 1
a1 1
/*	$OpenBSD: echo.c,v 1.44 2006/03/28 20:16:24 kjell Exp $	*/
d423 1
d436 1
@


1.44
log
@Use <sp> and <cr> as shortcuts for y/n (like emacs)
requested by Han Boetes.
@
text
@d1 1
a1 1
/*	$OpenBSD: echo.c,v 1.43 2005/12/20 06:17:36 kjell Exp $	*/
d940 1
a940 1
		current = (struct list *)malloc(sizeof(struct list));
@


1.43
log
@Clean up the ugly casted frees. In one case, this meant eliminating a nasty
struct/union/casting nightmare when building the list of names for filename
completion. In particular, be consistent about strduping and freeing
the list data.
@
text
@d1 1
a1 1
/*	$OpenBSD: echo.c,v 1.42 2005/12/13 06:01:27 kjell Exp $	*/
d66 1
a66 1
		if (s == 'y' || s == 'Y')
d68 1
a68 1
		if (s == 'n' || s == 'N')
@


1.42
log
@More name-clash delinting
@
text
@d1 1
a1 1
/*	$OpenBSD: echo.c,v 1.41 2005/11/19 20:16:35 kjell Exp $	*/
d102 1
a102 1
				free((char *)lp);
d597 1
a597 1
	const char *cp;
d703 2
a704 1
			len = strlcat(linebuf, lh2->l_name + preflen, linesize);
d927 1
d942 1
d945 1
d951 1
a951 1
		current->l_name = lp->l_name;
@


1.41
log
@Clean up some lint.
@
text
@d1 1
a1 1
/*	$OpenBSD: echo.c,v 1.40 2005/11/18 20:56:52 deraadt Exp $	*/
a463 1
	ret = buf;
d804 1
a804 1
				keyname(kname, sizeof(kname), va_arg(ap, int));
d812 1
a812 1
					cp = keyname(cp, sizeof(kname) -
@


1.40
log
@greedy use of typedef struct was making code harder to read; ok kjell cloder
@
text
@d1 1
a1 1
/*	$OpenBSD: echo.c,v 1.39 2005/11/11 18:40:51 deraadt Exp $	*/
d25 1
a25 1
static int	 complt_list(int, int, char *, int);
d195 1
a195 1
				complt_list(flag, c, buf, cpos);
d586 1
a586 1
complt_list(int flags, int c, char *buf, int cpos)
@


1.39
log
@spacing
@
text
@d1 1
a1 1
/*	$OpenBSD: echo.c,v 1.38 2005/11/11 18:40:01 kjell Exp $	*/
d31 1
a31 1
static LIST	*copy_list(LIST *);
d98 1
a98 1
				LINE	*lp = maclcur;
d153 2
a154 2
	BUFFER	*bp;			/* completion list buffer */
	MGWIN	*wp;			/* window for compl list */
d343 1
a343 1
				LINE	*lp;
d491 2
a492 2
	LIST	*lh, *lh2;
	LIST	*wholelist = NULL;
d588 3
a590 3
	LIST	*lh, *lh2, *lh3;
	LIST	*wholelist = NULL;
	BUFFER	*bp;
d741 1
a741 1
getxtra(LIST *lp1, LIST *lp2, int cpos, int wflag)
d921 1
a921 1
free_file_list(LIST *lp)
d923 1
a923 1
	LIST	*next;
d932 2
a933 2
static LIST *
copy_list(LIST *lp)
d935 1
a935 1
	LIST	*current, *last, *nxt;
d939 1
a939 1
		current = (LIST *)malloc(sizeof(LIST));
@


1.38
log
@Enable some of the more common editing keybindings in the minibuffer.
i.e. left, right, ^B, ^F, ^Y, ^K, ^A, ^E

Also, make completions work as you would expect them to
i.e. a *Completions* buffer pops up with your choices in it
when you hit a second TAB or SP.

It's ugly, but it works. ok deraadt.
@
text
@d1 1
a1 1
/*	$OpenBSD: echo.c,v 1.37 2005/10/11 00:46:46 kjell Exp $	*/
d232 1
a232 1
	 	switch (c) {
@


1.37
log
@Be more explicit in error prompt. ok deraadt.
@
text
@d1 1
a1 1
/*	$OpenBSD: echo.c,v 1.36 2005/08/09 00:53:48 kjell Exp $	*/
d21 1
d24 1
a24 1
static int	 complt(int, int, char *, size_t, int);
d145 13
a157 2
	int	 cpos, dynbuf = (buf == NULL);
	int	 c, i;
d172 4
a175 1
	cpos = 0;
d187 1
a187 1
		cpos += strlen(buf);
d194 8
a201 1
			cpos += complt(flag, c, buf, nbuf, cpos);
d204 27
a230 3
		if ((flag & EFAUTO) != 0 && c == '?') {
			complt_list(flag, c, buf, cpos);
			continue;
d232 87
a318 1
		switch (c) {
d324 1
a324 1
			if (cpos == 0 && !(flag & EFNUL)) {
d330 2
a331 1
				if ((i = complt(flag, c, buf, nbuf, cpos)) == 0)
d334 1
a334 1
					cpos += i;
d336 1
a336 1
			buf[cpos] = '\0';
d359 1
d365 2
a366 1
			return (NULL);
d370 2
d373 11
d385 1
a385 4
				ttputc('\b');
				--ttcol;
				if (ISCTRL(buf[--cpos]) != FALSE) {
					ttputc('\b');
a387 1
					--ttcol;
d389 2
d407 1
d443 1
a443 2
			/* all the rest */
			if (dynbuf && cpos + 1 >= nbuf) {
d445 3
a447 7
				size_t newsize = cpos + cpos + 16;

				if ((newp = realloc(buf, newsize)) == NULL) {
					ewprintf("Out of memory");
					free(buf);
					return (NULL);
				}
d451 11
a461 5
			if (cpos < nbuf - 1) {
				buf[cpos++] = (char)c;
				eputc((char)c);
				ttflush();
			}
d464 1
d466 13
a478 1
	return (buf);
d483 4
d489 1
a489 1
complt(int flags, int c, char *buf, size_t nbuf, int cpos)
d525 1
a525 1
			nxtra = -1;
d543 1
a543 1
			nxtra = 1;
d548 1
d551 4
a554 3
		if (nxtra < 0 && c != CCHR('M'))
			return (0);
		return (nxtra);
d578 2
a579 1
	return (0);
d604 2
a605 2
	/* The results are put into a help buffer. */
	bp = bfind("*help*", TRUE);
@


1.36
log
@Clean up eread handling in mg. (basically, fallout from the 'enter often
means abort' behaviour added during the hackathon). Eliminates
redundant ereply function, fixes miscellaneous cores when aborting,
and move a number of assumed pathnames into the prompt text, since
they are used there anyway. All changes consistent with emacs behavior

ok beck@@ many, many moons ago.
@
text
@d1 1
a1 1
/*	$OpenBSD: echo.c,v 1.35 2005/06/14 18:14:40 kjell Exp $	*/
d371 1
a371 1
		msg = " [Ambiguous]";
@


1.35
log
@Add explicit public domain notices to all public domain files.
ok millert@@, deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: echo.c,v 1.34 2005/05/31 20:38:59 kjell Exp $	*/
d89 2
a90 1
	rep = ereply("%s? (yes or no) ", buf, sizeof(buf), sp);
d114 2
a115 2
		rep = ereply("Please answer yes or no.  %s? (yes or no) ",
		    buf, sizeof(buf), sp);
a120 19
 * Write out a prompt and read back a reply.  The prompt is now written
 * out with full "ewprintf" formatting, although the arguments are in a
 * rather strange place.  This is always a new message, there is no auto
 * completion, and the return is echoed as such.
 */
/* VARARGS */
char *
ereply(const char *fmt, char *buf, size_t nbuf, ...)
{
	va_list	 ap;
	char	*rep;

	va_start(ap, nbuf);
	rep = veread(fmt, buf, nbuf, EFNEW | EFCR, ap);
	va_end(ap);
	return (rep);
}

/*
d124 3
a126 2
 * length "len"). The "flag" contains EFNEW (a new prompt), an EFFUNC
 * (autocomplete), or EFCR (echo the carriage return as CR).
d191 1
a191 1
			/* if there's nothing in the minibuffer, quit */
@


1.34
log
@fix broken minibuffer defaults introduced in echo.c:1.33
adds eread flag EFDEF allowing null minibuffer response
noticed by otto
ok cloder@@ jason@@, works otto@@
@
text
@d1 4
a4 1
/*	$OpenBSD: echo.c,v 1.33 2005/05/28 00:41:13 cloder Exp $	*/
@


1.33
log
@If the user gets into a minibuffer, they will not know how to hit
Ctrl+g to get out of it.  Let them hit enter, like in emacs.
OK kjell, jason
@
text
@d1 1
a1 1
/*	$OpenBSD: echo.c,v 1.32 2005/04/28 07:23:56 otto Exp $	*/
d206 1
a206 1
			if (cpos == 0) {
@


1.32
log
@Get rid of unused arg to complete_function_list(). Han Boetes.
@
text
@d1 1
a1 1
/*	$OpenBSD: echo.c,v 1.31 2005/04/03 02:09:28 db Exp $	*/
d205 6
@


1.31
log
@This is a no binary change which does:

- spelling, punctuation fixes
- variable declaration lineup
- use parentheses for return and sizeof
- K&R function declarations -> ANSI
- other minor code beautification

ok henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: echo.c,v 1.30 2005/03/10 16:58:57 deraadt Exp $	*/
d344 1
a344 1
		wholelist = lh = complete_function_list(buf, c);
d464 1
a464 1
		wholelist = lh = complete_function_list(buf, c);
@


1.30
log
@spacing
@
text
@d1 1
a1 1
/*	$OpenBSD: echo.c,v 1.29 2004/07/22 01:25:24 vincent Exp $	*/
d20 7
a26 7
static int	complt(int, int, char *, size_t, int);
static int	complt_list(int, int, char *, int);
static void	eformat(const char *, va_list);
static void	eputi(int, int);
static void	eputl(long, int);
static void	eputs(const char *);
static void	eputc(char);
d57 1
a57 1
		return TRUE;
d63 1
a63 1
			return TRUE;
d65 1
a65 1
			return FALSE;
d67 1
a67 1
			return ctrlg(FFRAND, 1);
d75 1
a75 1
 * "yes" or "no" and the trainling newline.
d84 1
a84 1
		return TRUE;
d89 1
a89 1
			return ABORT;
d104 1
a104 1
				return TRUE;
d108 1
a108 1
				return FALSE;
d132 1
a132 1
	return rep;
d147 1
a147 1
	char *rep;
d152 1
a152 1
	return rep;
d159 1
a159 2
	int	 i;
	int	 c;
d165 1
a165 1
				return NULL;
d167 1
a167 1
			return NULL;
d171 1
a171 1
		return buf;
d184 1
a184 1
			return NULL;
d225 1
a225 1
					return falseval;
d239 1
a239 1
			return NULL;
d312 1
a312 1
					return NULL;
d325 1
a325 1
	return buf;
d329 1
a329 1
 * do completion on a list of objects.
d394 2
a395 2
			return 0;
		return nxtra;
d399 1
a399 1
	 * wholelist is null if we are doing buffers.  want to free lists
d404 1
a404 1
	/* Set up backspaces, etc., being mindful of echo line limit */
d419 1
a419 1
	return 0;
d423 1
a423 1
 * do completion on a list of objects, listing instead of completing
d444 1
a444 1
	/* the results are put into a help buffer */
d447 1
a447 1
		return FALSE;
d450 1
a450 1
	 * first get the list of objects.  This list may contain only
a478 1

d518 1
a518 1
	 * Now do the display.  objects are written into linebuf until
d523 1
a523 1
		return FALSE;
d528 1
a528 1
	 * NUL terminated
d571 1
a571 1
	return 0;
d668 1
a668 1
				snprintf(tmp, sizeof tmp, "%p",
@


1.29
log
@stage 1 of the infinite minibuffer work - add support for on the fly
buffer reallocation in veread().  This commit only changes the API.
All the buffers have exactly the same bounds as before for now.

tested by a couple of my very helpful testers!
@
text
@d1 1
a1 1
/*	$OpenBSD: echo.c,v 1.28 2004/07/08 21:28:06 vincent Exp $	*/
d304 1
a304 1
		default:		
@


1.28
log
@misplaced return NULL in the error path

found by lint via deraadt
ok deraadt
@
text
@d1 1
a1 2
/*	$OpenBSD: echo.c,v 1.27 2004/01/21 00:46:38 vincent Exp $	*/

d19 2
a20 2
static int	veread(const char *, char *buf, int, int, va_list);
static int	complt(int, int, char *, int);
d80 1
a80 2
	int	 s;
	char	 buf[64];
d86 1
a86 1
	s = ereply("%s? (yes or no) ", buf, sizeof(buf), sp);
d88 1
a88 1
		if (s == ABORT)
d90 1
a90 1
		if (s != FALSE) {
d100 4
a103 4
			if ((buf[0] == 'y' || buf[0] == 'Y') &&
			    (buf[1] == 'e' || buf[1] == 'E') &&
			    (buf[2] == 's' || buf[2] == 'S') &&
			    (buf[3] == '\0'))
d105 3
a107 3
			if ((buf[0] == 'n' || buf[0] == 'N') &&
			    (buf[1] == 'o' || buf[0] == 'O') &&
			    (buf[2] == '\0'))
d110 1
a110 1
		s = ereply("Please answer yes or no.  %s? (yes or no) ",
d123 2
a124 2
int
ereply(const char *fmt, char *buf, int nbuf, ...)
d127 2
a128 1
	int	 i;
d130 1
a130 1
	i = veread(fmt, buf, nbuf, EFNEW | EFCR, ap);
d132 1
a132 1
	return i;
d143 2
a144 2
int
eread(const char *fmt, char *buf, int nbuf, int flag, ...)
a145 1
	int	 i;
d147 2
d150 1
a150 1
	i = veread(fmt, buf, nbuf, flag, ap);
d152 1
a152 1
	return i;
d155 2
a156 2
static int
veread(const char *fp, char *buf, int nbuf, int flag, va_list ap)
d158 1
a158 1
	int	 cpos;
d164 5
d172 1
a172 1
		return TRUE;
d184 2
d194 1
a194 1
			cpos += complt(flag, c, buf, cpos);
d207 1
a207 1
				if ((i = complt(flag, c, buf, cpos)) == 0)
d221 7
a227 2
				if ((lp = lalloc(cpos)) == NULL)
					return FALSE;
d240 1
a240 1
			return ABORT;
d304 14
a317 1
		default:			/* all the rest */
d326 1
a326 1
	return buf[0] != '\0';
d333 1
a333 1
complt(int flags, int c, char *buf, int cpos)
d388 1
a388 1
		for (i = 0; i < nxtra; ++i) {
@


1.27
log
@support format `%p' to print pointers in eformat()
@
text
@d1 1
a1 1
/*	$OpenBSD: echo.c,v 1.26 2003/04/16 17:30:49 millert Exp $	*/
a760 1
				return (NULL);
d762 1
d766 1
a766 1
		last = (LIST *)current;
@


1.26
log
@Fix a buffer overflow in complt_list(); it was allocating space
based on nrow when it wanted ncol.  Also make the space-padding
more bulletproof and avoid trying to pad w/ 0 characters.
Closed PR 3190; vincent@@ OK
@
text
@d1 1
a1 1
/*	$OpenBSD: echo.c,v 1.25 2002/08/22 23:28:19 deraadt Exp $	*/
d612 1
a612 1
	char	kname[NKNAME], *cp;
d642 6
@


1.25
log
@knf
@
text
@d1 1
a1 1
/*	$OpenBSD: echo.c,v 1.24 2002/07/03 17:25:38 vincent Exp $	*/
d413 1
d498 2
a499 1
	if ((linebuf = malloc((nrow + 1) * sizeof(char))) == NULL)
d521 1
a521 5
			strlcat(linebuf, lh2->l_name + preflen, nrow+1);
			i = strlen(lh2->l_name + preflen);
			/* make all the objects nicely line up */
			memset(linebuf + strlen(linebuf), ' ',
			    maxwidth - i);
d523 6
a528 1
			linebuf[width] = '\0';
@


1.24
log
@remove a useless {} that was there for "historical reasons" and only served
to make the code go too far to the right.
@
text
@d1 1
a1 1
/*	$OpenBSD: echo.c,v 1.23 2002/07/03 03:47:59 vincent Exp $	*/
d501 1
a501 1
	/* 
@


1.23
log
@ a few missing tests for malloc()'s return value.

 ok art@@
@
text
@d1 1
a1 1
/*	$OpenBSD: echo.c,v 1.22 2002/07/01 14:33:44 vincent Exp $	*/
d424 19
a442 2
	{	/* this {} present for historical reasons */

d444 3
a446 9
		 * first get the list of objects.  This list may contain only
		 * the ones that complete what has been typed, or may be the
		 * whole list of all objects of this type.  They are filtered
		 * later in any case.  Set wholelist if the list has been
		 * cons'ed up just for us, so we can free it later.  We have
		 * to copy the buffer list for this function even though we
		 * didn't for complt.  The sorting code does destructive
		 * changes to the list, which we don't want to happen to the
		 * main buffer list!
d448 5
a452 18
		if ((flags & EFBUF) != 0)
			wholelist = lh = copy_list(&(bheadp->b_list));
		else if ((flags & EFFUNC) != 0) {
			buf[cpos] = '\0';
			wholelist = lh = complete_function_list(buf, c);
		} else if ((flags & EFFILE) != 0) {
			buf[cpos] = '\0';
			wholelist = lh = make_file_list(buf);
			/*
			 * We don't want to display stuff up to the / for file
			 * names preflen is the list of a prefix of what the
			 * user typed that should not be displayed.
			 */
			cp = strrchr(buf, '/');
			if (cp)
				preflen = cp - buf + 1;
		} else
			panic("broken complt call: flags");
d455 12
a466 14
		/*
		 * Sort the list, since users expect to see it in alphabetic
		 * order.
		 */
		lh2 = lh;
		while (lh2 != NULL) {
			lh3 = lh2->l_next;
			while (lh3 != NULL) {
				if (strcmp(lh2->l_name, lh3->l_name) > 0) {
					cp = lh2->l_name;
					lh2->l_name = lh3->l_name;
					lh3->l_name = cp;
				}
				lh3 = lh3->l_next;
d468 1
a468 1
			lh2 = lh2->l_next;
d470 2
d473 15
a487 17
		/*
		 * First find max width of object to be displayed, so we can
		 * put several on a line.
		 */
		maxwidth = 0;
		lh2 = lh;
		while (lh2 != NULL) {
			for (i = 0; i < cpos; ++i) {
				if (buf[i] != lh2->l_name[i])
					break;
			}
			if (i == cpos) {
				width = strlen(lh2->l_name);
				if (width > maxwidth)
					maxwidth = width;
			}
			lh2 = lh2->l_next;
d489 3
a491 1
		maxwidth += 1 - preflen;
d493 7
a499 7
		/*
		 * Now do the display.  objects are written into linebuf until
		 * it fills, and then put into the help buffer.
		 */
		if ((linebuf = malloc((nrow + 1) * sizeof(char))) == NULL)
			return FALSE;
		width = 0;
d501 9
a509 25
		/* 
		 * We're going to strlcat() into the buffer, so it has to be
		 * NUL terminated
		 */
		linebuf[0] = '\0';
		for (lh2 = lh; lh2 != NULL; lh2 = lh2->l_next) {
			for (i = 0; i < cpos; ++i) {
				if (buf[i] != lh2->l_name[i])
					break;
			}
			/* if we have a match */
			if (i == cpos) {
				/* if it wraps */
				if ((width + maxwidth) > ncol) {
					addline(bp, linebuf);
					linebuf[0] = '\0';
					width = 0;
		 		}
				strlcat(linebuf, lh2->l_name + preflen, nrow+1);				i = strlen(lh2->l_name + preflen);
				/* make all the objects nicely line up */
				memset(linebuf + strlen(linebuf), ' ',
					maxwidth - i);
				width += maxwidth;
				linebuf[width] = '\0';
			}
d511 15
a525 2
		if (width > 0) {
			addline(bp, linebuf);
a526 1
		free(linebuf);
d528 4
@


1.22
log
@KNF + ansi; from zyrnix (only the easy part of his diffs)
@
text
@d1 1
a1 1
/*	$OpenBSD: echo.c,v 1.21 2002/03/11 13:02:56 vincent Exp $	*/
d745 1
a745 1
	LIST	*current, *last;
d750 7
@


1.21
log
@  * Move to ANSI function definitions.
  * Add a whole lot of consts where I thought it made sense

   no ok, but no objections either...
@
text
@d1 1
a1 1
/*	$OpenBSD: echo.c,v 1.20 2002/02/16 21:27:49 millert Exp $	*/
d197 1
a197 1
			/* and continue */
d291 1
a291 1
			/* and continue */
@


1.20
log
@Part one of userland __P removal.  Done with a simple regexp with some minor hand editing to make comments line up correctly.  Another pass is forthcoming that handles the cases that could not be done automatically.
@
text
@d1 1
a1 1
/*	$OpenBSD: echo.c,v 1.19 2002/02/14 23:00:56 vincent Exp $	*/
d26 1
a26 1
static void	eputs(char *);
d36 1
a36 1
eerase()
d52 1
a52 2
eyorn(sp)
	char *sp;
d79 1
a79 2
eyesno(sp)
	char *sp;
d308 1
a308 3
complt(flags, c, buf, cpos)
	int   flags, c, cpos;
	char *buf;
d402 1
a402 5
complt_list(flags, c, buf, cpos)
	int   flags;
	int   c;
	char *buf;
	int   cpos;
d413 1
a413 1
	char	*cp;
d557 1
a557 4
getxtra(lp1, lp2, cpos, wflag)
	LIST *lp1, *lp2;
	int   cpos;
	int   wflag;
d671 1
a671 2
eputi(i, r)
	int i, r;
d688 1
a688 3
eputl(l, r)
	long l;
	int  r;
d705 1
a705 2
eputs(s)
	char *s;
d718 1
a718 2
eputc(c)
	char	 c;
d731 1
a731 2
free_file_list(lp)
	LIST *lp;
d743 1
a743 2
copy_list(lp)
	LIST *lp;
@


1.19
log
@ remove the strcpy call, plus some KNF

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: echo.c,v 1.18 2002/02/14 14:24:21 deraadt Exp $	*/
d20 9
a28 9
static int	veread		__P((const char *, char *buf, int, int, va_list));
static int	complt		__P((int, int, char *, int));
static int	complt_list	__P((int, int, char *, int));
static void	eformat		__P((const char *, va_list));
static void	eputi		__P((int, int));
static void	eputl		__P((long, int));
static void	eputs		__P((char *));
static void	eputc		__P((char));
static LIST	*copy_list	__P((LIST *));
@


1.18
log
@some KNF
@
text
@d1 1
a1 1
/*	$OpenBSD: echo.c,v 1.17 2002/01/18 08:37:08 art Exp $	*/
d470 1
a470 1
		while (lh2) {
d472 1
a472 1
			while (lh3) {
a508 1
		cp = linebuf;
d510 7
a516 2
		lh2 = lh;
		while (lh2 != NULL) {
d521 1
d523 1
a524 1
					*cp = 0;
d526 1
a526 1
					cp = linebuf;
d528 5
a532 6
				}
				strcpy(cp, lh2->l_name + preflen);
				i = strlen(lh2->l_name + preflen);
				cp += i;
				for (; i < maxwidth; i++)
					*cp++ = ' ';
d534 1
a535 1
			lh2 = lh2->l_next;
a537 1
			*cp = 0;
@


1.17
log
@Remove the NROW and NCOL limits. The static arrays are now replaced with
dynamically allocated memory.
Code written by Vincent Labrecque <limitln@@Psyfreaks.CA> with some minor
tweaks by me.
@
text
@d1 1
a1 1
/*	$OpenBSD: echo.c,v 1.16 2001/05/24 09:47:33 art Exp $	*/
d104 4
a107 4
			if ((buf[0] == 'y' || buf[0] == 'Y')
			    && (buf[1] == 'e' || buf[1] == 'E')
			    && (buf[2] == 's' || buf[2] == 'S')
			    && (buf[3] == '\0'))
d109 3
a111 3
			if ((buf[0] == 'n' || buf[0] == 'N')
			    && (buf[1] == 'o' || buf[0] == 'O')
			    && (buf[2] == '\0'))
@


1.16
log
@Break out function -> name mappings to an own file.
Add a possibility to dynamically extend the function table.
@
text
@d1 1
a1 1
/*	$OpenBSD: echo.c,v 1.15 2001/05/24 09:34:05 mickey Exp $	*/
d420 1
a420 1
	char	 linebuf[NCOL + 1];
d507 2
d537 1
@


1.15
log
@fix back a piece of my own stupidity
@
text
@d1 1
a1 1
/*	$OpenBSD: echo.c,v 1.14 2001/05/24 01:55:49 mickey Exp $	*/
d16 2
d180 4
@


1.14
log
@vararg bye bye, spaces
@
text
@d1 1
a1 1
/*	$OpenBSD: echo.c,v 1.13 2001/05/24 01:17:51 mickey Exp $	*/
d18 1
a18 1
static int	veread		__P((const char *, char *buf, int, int, ...));
d21 1
a21 1
static void	eformat		__P((const char *, ...));
d156 1
a156 1
veread(const char *fp, char *buf, int nbuf, int flag, ...)
a160 1
	va_list		ap;
a176 1
	va_start(ap, flag);
a177 1
	va_end(ap);
d608 1
a608 1
eformat(const char *fp, ...)
a610 1
	va_list ap;
a612 1
	va_start(ap, fp);
@


1.13
log
@no need to cast va_arg output
@
text
@d1 1
a1 1
/*	$OpenBSD: echo.c,v 1.12 2001/05/23 23:29:47 mickey Exp $	*/
d18 9
a26 9
static int	veread		__P((const char *, char *buf, int, int, va_list));
static int      complt		__P((int, int, char *, int));
static int      complt_list	__P((int, int, char *, int));
static void     eformat		__P((const char *, va_list));
static void     eputi		__P((int, int));
static void     eputl		__P((long, int));
static void     eputs		__P((char *));
static void     eputc		__P((char));
static LIST    *copy_list	__P((LIST *));
d28 1
a28 1
int             epresf = FALSE;		/* stuff in echo line flag */
d44 3
a46 3
 * Ask a "yes" or "no" question.  Return ABORT if the user answers the 
 * question with the abort ("^G") character.  Return FALSE for "no" and 
 * TRUE for "yes".  No formatting services are available.  No newline 
d119 2
a120 2
 * Write out a prompt and read back a reply.  The prompt is now written 
 * out with full "ewprintf" formatting, although the arguments are in a 
d137 1
a137 1
 * This is the general "read input from the echo line" routine.  The basic 
d139 2
a140 2
 * a one line reply is read back into the supplied "buf" (with maximum 
 * length "len"). The "flag" contains EFNEW (a new prompt), an EFFUNC 
d156 1
a156 5
veread(fp, buf, nbuf, flag, ap)
	const char *fp;
	char       *buf;
	int         nbuf, flag;
	va_list     ap;
d161 1
d178 1
d180 1
d229 1
a229 1
		case CCHR('?'):	
d551 2
a552 2
 * position in the name.  Return the longest block of characters that can be 
 * autocompleted at this point.  Sometimes the two symbols are the same, but 
d577 3
a579 3
 * Special "printf" for the echo line.  Each call to "ewprintf" starts a 
 * new line in the echo area, and ends with an erase to end of the echo 
 * line.  The formatting is done by a call to the standard formatting 
d603 3
a605 3
 * Printf style formatting. This is called by both "ewprintf" and "ereply" 
 * to provide formatting services to their clients.  The move to the start 
 * of the echo line, and the erase to the end of the echo line, is done by 
d611 1
a611 3
eformat(fp, ap)
	const char *fp;
	va_list ap;
d614 1
d617 1
d722 1
a722 1
 * Put character.  Watch for control characters, and for the line getting 
@


1.12
log
@cinfo is const, keyname() and findbind() take buffer size to use strlcpy vs cpy+len
@
text
@d1 1
a1 1
/*	$OpenBSD: echo.c,v 1.11 2001/05/23 22:23:55 art Exp $	*/
d657 1
a657 1
					eputl((long)va_arg(ap, long), 10);
@


1.11
log
@Bye, bye varargs. We're __STDC__.
@
text
@d1 1
a1 1
/*	$OpenBSD: echo.c,v 1.10 2001/05/23 22:20:35 art Exp $	*/
d614 1
a614 1
	va_list     ap;
d616 2
a617 3
	int	 c;
	char	 kname[NKNAME];
	char	*cp;
d626 1
a626 1
				(void)keyname(kname, va_arg(ap, int));
d631 5
a635 4
				cp = kname;
				for (c = 0; c < key.k_count; c++) {
					cp = keyname(cp, key.k_chars[c]);
					*cp++ = ' ';
a636 1
				*--cp = '\0';
@


1.10
log
@remove VOID. We're way beyond the point where this could build with an
ancient compiler.
@
text
@d1 1
a1 1
/*	$OpenBSD: echo.c,v 1.9 2001/05/23 22:01:44 art Exp $	*/
a15 1
#ifdef	__STDC__
a16 3
#else /* __STDC__ */
#include <varargs.h>
#endif /* __STDC__ */
a125 1
#ifdef __STDC__
a126 4
#else /* __STDC__ */
ereply(va_alist)
	va_dcl
#endif /* __STDC__ */
a129 1
#ifdef __STDC__
a130 9
#else /* __STDC__ */
	char	*fmt, *buf;
	int	 nbuf;

	va_start(ap);
	fmt = va_arg(ap, char *);
	buf = va_arg(ap, char *);
	nbuf = va_arg(ap, int);
#endif /* __STDC__ */
a144 1
#ifdef __STDC__
a145 6
#else /* __STDC__ */
eread(va_alist)
	char *fmt, *buf;
	int   buf, flag;
	va_dcl
#endif /* __STDC__ */
a148 1
#ifdef __STDC__
a149 10
#else /* __STDC__ */
	char	*fmt, *buf;
	int	 nbuf;

	va_start(ap);
	fmt = va_arg(ap, char *);
	buf = va_arg(ap, char *);
	nbuf = va_arg(ap, int);
	flag = va_arg(ap, int);
#endif /* __STDC__ */
a584 1
#ifdef __STDC__
a585 4
#else /* __STDC__ */
ewprintf(va_alist)
	va_dcl
#endif /* __STDC__ */
a587 3
#ifndef __STDC__
	char	*fmt;
#endif /* !__STDC__ */
a592 1
#ifdef __STDC__
a593 4
#else /* __STDC__ */
	va_start(ap);
	fmt = va_arg(ap, char *);
#endif /* __STDC__ */
@


1.9
log
@pretty
@
text
@d1 1
a1 1
/*	$OpenBSD: echo.c,v 1.8 2001/05/23 21:42:34 art Exp $	*/
d25 5
a29 5
static VOID     eformat		__P((const char *, va_list));
static VOID     eputi		__P((int, int));
static VOID     eputl		__P((long, int));
static VOID     eputs		__P((char *));
static VOID     eputc		__P((char));
d37 1
a37 1
VOID
d263 1
a263 1
			(VOID)ctrlg(FFRAND, 0);
d621 1
a621 1
VOID
d661 1
a661 1
static VOID
d677 1
a677 1
				(VOID)keyname(kname, va_arg(ap, int));
d726 1
a726 1
static VOID
d744 1
a744 1
static VOID
d763 1
a763 1
static VOID
d777 1
a777 1
static VOID
d791 1
a791 1
VOID
@


1.8
log
@export free_file_list. XXX - it doesn't belong in echo.c and it's the wrong name.
@
text
@d1 1
a1 1
/*	$OpenBSD: echo.c,v 1.7 2001/05/23 20:49:53 art Exp $	*/
d360 1
a360 1
	} else if ((flags & EFBUF) != 0)
d362 1
a362 1
	else if ((flags & EFFILE) != 0) {
@


1.7
log
@pretty
@
text
@d1 1
a1 1
/*	$OpenBSD: echo.c,v 1.6 2001/05/23 16:25:24 art Exp $	*/
a29 1
static VOID	free_file_list	__P((LIST *));
d791 1
a791 1
static VOID
@


1.6
log
@complt already has code to finish the completion from a list.
No point in duplicating that code in complete_function.
@
text
@d1 1
a1 1
/*	$OpenBSD: echo.c,v 1.5 2001/05/03 12:57:22 art Exp $	*/
d338 2
a339 1
done:	return buf[0] != '\0';
@


1.5
log
@ * Let make_file_list always append a '/' at the end of directories.
   This makes filename TAB-completion more useful, now you don't need to
   write that '/' manually.
 * random cleanups including using snprintf and memcmp where open-coded
   equivalents were used, waitpid instead of 'while (wait() != pid);', etc.
@
text
@d1 1
a1 1
/*	$OpenBSD: echo.c,v 1.4 2001/01/29 01:58:07 niklas Exp $	*/
d359 20
a378 53
		i = complete_function(buf, c);
		if (i > 0) {
			eputs(&buf[cpos]);
			ttflush();
			return i;
		}
		switch (i) {
		case -3:
			msg = " [Ambiguous]";
			break;
		case -2:
			i = 0;
			msg = " [No match]";
			break;
		case -1:
		case 0:
			return i;
		default:
			msg = " [Internal error]";
			break;
		}
	} else {
		if ((flags & EFBUF) != 0)
			lh = &(bheadp->b_list);
		else if ((flags & EFFILE) != 0) {
			buf[cpos] = '\0';
			wholelist = lh = make_file_list(buf);
		} else
			panic("broken complt call: flags");

		if (c == ' ')
			wflag = TRUE;
		else if (c != '\t' && c != CCHR('M'))
			panic("broken complt call: c");

		nhits = 0;
		nxtra = HUGE;

		for (; lh != NULL; lh = lh->l_next) {
			if (memcmp(buf, lh->l_name, cpos) != 0)
				continue;
			if (nhits == 0)
				lh2 = lh;
			++nhits;
			if (lh->l_name[cpos] == '\0')
				nxtra = -1;
			else {
				bxtra = getxtra(lh, lh2, cpos, wflag);
				if (bxtra < nxtra)
					nxtra = bxtra;
				lh2 = lh;
			}
		}
d380 4
a383 3
			msg = " [No match]";
		else if (nhits > 1 && nxtra == 0)
			msg = " [Ambiguous]";
d385 20
a404 15
			/*
			 * Being lazy - ought to check length, but all things
			 * autocompleted have known types/lengths.
			 */
			if (nxtra < 0 && nhits > 1 && c == ' ')
				nxtra = 1;
			for (i = 0; i < nxtra; ++i) {
				buf[cpos] = lh2->l_name[cpos];
				eputc(buf[cpos++]);
			}
			ttflush();
			free_file_list(wholelist);
			if (nxtra < 0 && c != CCHR('M'))
				return 0;
			return nxtra;
d406 5
@


1.4
log
@$OpenBSD$
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d385 1
a385 1
			wholelist = lh = make_file_list(buf, 0);
d397 13
a409 17
		while (lh != NULL) {
			for (i = 0; i < cpos; ++i) {
				if (buf[i] != lh->l_name[i])
					break;
			}
			if (i == cpos) {
				if (nhits == 0)
					lh2 = lh;
				++nhits;
				if (lh->l_name[i] == '\0')
					nxtra = -1;
				else {
					bxtra = getxtra(lh, lh2, cpos, wflag);
					if (bxtra < nxtra)
						nxtra = bxtra;
					lh2 = lh;
				}
a410 1
			lh = lh->l_next;
d509 1
a509 1
			wholelist = lh = make_file_list(buf, 1);
@


1.3
log
@More -Wall anmd KNF, from op2@@tomahawk.SQUiSH.org
@
text
@d1 2
@


1.2
log
@The start of KNF + -Wall.  The code has been run through indent but
needs hand fixup.  I stopped at keymap.c...
@
text
@d2 1
a2 1
 *		Echo line reading and writing.
d4 2
a5 4
 * Common routines for reading
 * and writing characters in the echo line area
 * of the display screen. Used by the entire
 * known universe.
d7 7
a13 2
#include	"def.h"
#include	"key.h"
d15 4
a18 7
#include	<stdarg.h>
#else
#include	<varargs.h>
#endif
#ifndef NO_MACRO
#include	"macro.h"
#endif
d20 3
a23 1
static int	veread		__P((const char *, char *buf, int, int, va_list));
d28 1
a28 2
static int      complt		__P((int, int, char *, int));
static int      complt_list	__P((int, int, char *, int));
a29 1
static VOID	free_file_list	__P((LIST *));
d31 1
a31 1
int             epresf = FALSE;		/* Stuff in echo line flag.	 */
a38 1

d47 4
a50 5
 * Ask "yes" or "no" question.
 * Return ABORT if the user answers the question
 * with the abort ("^G") character. Return FALSE
 * for "no" and TRUE for "yes". No formatting
 * services are available. No newline required.
d54 1
a54 1
	char  *sp;
d56 1
a56 1
	int    s;
d61 1
a61 1
#endif
d77 2
a78 2
 * Like eyorn, but for more important question. User must type either all of
 * "yes" or "no", and the trainling newline.
d82 1
a82 1
	char  *sp;
d84 2
a85 2
	int    s;
	char   buf[64];
d90 1
a90 1
#endif
d98 1
a98 1
				LINE           *lp = maclcur;
d102 1
a102 1
				free((char *) lp);
d104 1
a104 1
#endif
d116 1
a116 1
			   buf, sizeof(buf), sp);
d122 3
a124 4
 * Write out a prompt, and read back a
 * reply. The prompt is now written out with full "ewprintf"
 * formatting, although the arguments are in a rather strange
 * place. This is always a new message, there is no auto
d131 1
a131 1
#else
d134 1
a134 1
#endif
d136 2
a137 2
	va_list         ap;
	int    i;
d140 3
a142 3
#else
	char  *fmt, *buf;
	int    nbuf;
d148 1
a148 1
#endif
d155 5
a159 7
 * This is the general "read input from the
 * echo line" routine. The basic idea is that the prompt
 * string "prompt" is written to the echo line, and a one
 * line reply is read back into the supplied "buf" (with
 * maximum length "len"). The "flag" contains EFNEW (a
 * new prompt), an EFFUNC (autocomplete), or EFCR (echo
 * the carriage return as CR).
d165 1
a165 1
#else
d167 2
a168 4
	char *fmt;
	char *buf;
	int nbuf;
	int flag;
d170 1
a170 1
#endif
d172 2
a173 2
	int 		i;
	va_list         ap;
d176 3
a178 3
#else
	char  *fmt, *buf;
	int    nbuf;
d185 1
a185 1
#endif
d195 1
a195 2
	int	    nbuf;
	int	    flag;
d198 3
a200 3
	int         cpos;
	int         i;
	int         c;
d209 1
a209 1
#endif
d232 3
a234 2
			c = CCHR('M');	/* and continue		 */
		case CCHR('M'):/* Return, done.	 */
d248 1
a248 1
				LINE           *lp;
d258 1
a258 1
#endif
d260 1
a260 2

		case CCHR('G'):	/* Bell, abort.		 */
d262 1
a262 1
			(VOID) ctrlg(FFRAND, 0);
d265 2
a266 3

		case CCHR('H'):
		case CCHR('?'):	/* Rubout, erase.	 */
d281 2
a282 3

		case CCHR('X'):	/* C-X			 */
		case CCHR('U'):	/* C-U, kill line.	 */
d297 1
a297 4

		case CCHR('W'):	/* C-W, kill to beginning of */
			/* previous word	 */
			/* back up to first word character or beginning */
a323 1

d325 4
a328 3
		case CCHR('Q'):	/* C-Q, quote next	 */
			c = getkey(FALSE);	/* and continue		 */
		default:	/* All the rest.	 */
d330 2
a331 2
				buf[cpos++] = (char) c;
				eputc((char) c);
d344 10
a353 12
	int    flags;
	int    c;
	char  *buf;
	int    cpos;
{
	LIST  *lh, *lh2;
	LIST  *wholelist = NULL;
	int    i, nxtra;
	int    nhits, bxtra;
	int    wflag = FALSE;
	int    msglen, nshown;
	char  *msg;
d419 1
a419 1
		else {		/* Got a match, do it to it */
d437 1
d443 1
d454 1
a454 1
	while (i--)		/* blank out	on next flush	 */
d467 17
a483 15
	int     flags;
	int     c;
	char   *buf;
	int     cpos;
{
	LIST   *lh, *lh2, *lh3;
	LIST   *wholelist = NULL;
	int     i, maxwidth, width;
	int     preflen = 0;
	BUFFER *bp;
	int     oldrow = ttrow;
	int     oldcol = ttcol;
	int     oldhue = tthue;
	char    linebuf[NCOL + 1];
	char   *cp;
d613 4
a616 5
 * The "lp1" and "lp2" point to list structures. The
 * "cpos" is a horizontal position in the name.
 * Return the longest block of characters that can be
 * autocompleted at this point. Sometimes the two
 * symbols are the same, but this is normal.
d620 3
a622 3
	LIST  *lp1, *lp2;
	int    cpos;
	int    wflag;
d624 1
a624 1
	int    i;
d640 4
a643 5
 * Special "printf" for the echo line.
 * Each call to "ewprintf" starts a new line in the
 * echo area, and ends with an erase to end of the
 * echo line. The formatting is done by a call
 * to the standard formatting routine.
d649 1
a649 1
#else
d652 1
a652 1
#endif
d654 1
a654 1
	va_list         ap;
d656 2
a657 2
	char	      *fmt;
#endif
d662 1
a662 1
#endif
d665 1
a665 1
#else
d668 1
a668 1
#endif
d679 4
a682 5
 * Printf style formatting. This is
 * called by both "ewprintf" and "ereply" to provide
 * formatting services to their clients. The move to the
 * start of the echo line, and the erase to the end of
 * the echo line, is done by the caller.
d688 2
a689 2
	const char  *fp;
	va_list ap;
d691 3
a693 3
	int    c;
	char   kname[NKNAME];
	char  *cp;
d702 1
a702 1
				(VOID) keyname(kname, va_arg(ap, int));
d728 2
a729 1
			case 'l':	/* explicit longword */
d733 1
a733 1
					eputl((long) va_arg(ap, long), 10);
d753 1
a753 2
	int    i;
	int    r;
d755 1
a755 1
	int    q;
d771 2
a772 2
	long   l;
	int    r;
d774 1
a774 1
	long   q;
d782 1
a782 1
	eputc((int) (l % r) + '0');
d790 1
a790 1
	char  *s;
d792 1
a792 1
	int    c;
d799 2
a800 3
 * Put character. Watch for
 * control characters, and for the line
 * getting too long.
d804 1
a804 1
	char   c;
a805 1

d820 1
a820 1
	LIST *next;
d833 1
a833 1
	LIST *current, *last;
d837 1
a837 1
		current = (LIST *) malloc(sizeof(LIST));
d840 1
a840 1
		last = (LIST *) current;
@


1.1
log
@initial import of mg2a
@
text
@a8 4
/*
 * The varargs lint directive comments are 0 an attempt to get lint to shup
 * up about CORRECT usage of varargs.h.  It won't.
 */
d11 2
a12 2
#ifdef	LOCAL_VARARGS
#include	"varargs.h"
d17 1
a17 1
#  include	"macro.h"
d20 10
a29 15
static int	veread();
VOID		ewprintf();
static VOID	eformat();
static VOID	eputi();
static VOID	eputl();
static VOID	eputs();
static VOID	eputc();
static int	complt();
static int	complt_list();
LIST *		make_file_list();
LIST *		copy_list();
char *		strrchr();
extern LIST *	complete_function_list();

int	epresf	= FALSE;		/* Stuff in echo line flag.	*/
d31 1
a31 1
extern		int tthue;
d37 3
a39 1
eerase() {
d41 1
a41 1
	ttmove(nrow-1, 0);
d54 5
a58 2
eyorn(sp) char *sp; {
	register int	s;
d61 2
a62 1
	if(inmacro) return TRUE;
d67 6
a72 3
		if (s == 'y' || s == 'Y') return TRUE;
		if (s == 'n' || s == 'N') return FALSE;
		if (s == CCHR('G')) return ctrlg(FFRAND, 1);
d75 1
a75 1
	/*NOTREACHED*/
d82 6
a87 3
eyesno(sp) char *sp; {
	register int	s;
	char		buf[64];
d90 2
a91 1
	if(inmacro) return TRUE;
d95 2
a96 1
		if (s == ABORT) return ABORT;
d100 1
a100 1
			    LINE *lp = maclcur;
d102 3
a104 3
			    maclcur = lp->l_bp;
			    maclcur->l_fp = lp->l_fp;
			    free((char *)lp);
d108 4
a111 3
			    &&	(buf[1] == 'e' || buf[1] == 'E')
			    &&	(buf[2] == 's' || buf[2] == 'S')
			    &&	(buf[3] == '\0')) return TRUE;
d113 3
a115 2
			    &&	(buf[1] == 'o' || buf[0] == 'O')
			    &&	(buf[2] == '\0')) return FALSE;
d120 1
a120 1
	/*NOTREACHED*/
d122 1
d130 5
a134 1
/*VARARGS 0*/
d136 2
a137 1
va_dcl
d139 15
a153 11
	va_list pvar;
	register char *fp, *buf;
	register int nbuf;
	register int i;

	va_start(pvar);
	fp = va_arg(pvar, char *);
	buf = va_arg(pvar, char *);
	nbuf = va_arg(pvar, int);
	i = veread(fp, buf, nbuf, EFNEW|EFCR, &pvar);
	va_end(pvar);
d166 5
a170 1
/* VARARGS 0 */
d172 6
a177 1
va_dcl
d179 16
a194 10
	va_list pvar;
	char *fp, *buf;
	int nbuf, flag, i;
	va_start(pvar);
	fp   = va_arg(pvar, char *);
	buf  = va_arg(pvar, char *);
	nbuf = va_arg(pvar, int);
	flag = va_arg(pvar, int);
	i = veread(fp, buf, nbuf, flag, &pvar);
	va_end(pvar);
d198 11
a208 4
static veread(fp, buf, nbuf, flag, ap) char *fp; char *buf; va_list *ap; {
	register int	cpos;
	register int	i;
	register int	c;
d211 5
a215 5
	if(inmacro) {
	    bcopy(maclcur->l_text, buf, maclcur->l_used);
	    buf[maclcur->l_used] = '\0';
	    maclcur = maclcur->l_fp;
	    return TRUE;
d219 1
a219 1
	if ((flag&EFNEW)!=0 || ttrow!=nrow-1) {
d221 1
a221 1
		ttmove(nrow-1, 0);
d230 1
a230 1
		if ((flag&EFAUTO) != 0 && (c == ' ' || c == CCHR('I'))) {
d234 1
a234 1
		if ((flag&EFAUTO) != 0 && c == '?') {
d239 4
a242 4
		    case CCHR('J'):
			c = CCHR('M');		/* and continue		*/
		    case CCHR('M'):		/* Return, done.	*/
			if ((flag&EFFUNC) != 0) {
d245 2
a246 1
				if (i > 0) cpos += i;
d249 1
a249 1
			if ((flag&EFCR) != 0) {
d254 2
a255 2
			if(macrodef) {
			    LINE *lp;
d257 7
a263 6
			    if((lp = lalloc(cpos)) == NULL) return FALSE;
			    lp->l_fp = maclcur->l_fp;
			    maclcur->l_fp = lp;
			    lp->l_bp = maclcur;
			    maclcur = lp;
			    bcopy(buf, lp->l_text, cpos);
d268 1
a268 1
		    case CCHR('G'):		/* Bell, abort.		*/
d274 2
a275 2
		    case CCHR('H'):
		    case CCHR('?'):		/* Rubout, erase.	*/
d291 2
a292 2
		    case CCHR('X'):		/* C-X			*/
		    case CCHR('U'):		/* C-U, kill line.	*/
d308 2
a309 2
		    case CCHR('W'):		/* C-W, kill to beginning of */
						/* previous word	*/
d338 5
a342 5
		    case CCHR('\\'):
		    case CCHR('Q'):		/* C-Q, quote next	*/
			c = getkey(FALSE);	/* and continue		*/
		    default:			/* All the rest.	*/
			if (cpos < nbuf-1) {
d355 24
a378 21
static int complt(flags, c, buf, cpos)
register char *buf;
register int cpos;
{
	register LIST	*lh, *lh2;
	LIST		*wholelist = NULL;
	int		i, nxtra;
	int		nhits, bxtra;
	int		wflag = FALSE;
	int		msglen, nshown;
	char		*msg;

	if ((flags&EFFUNC) != 0) {
	    buf[cpos] = '\0';
	    i = complete_function(buf, c);
	    if(i>0) {
		eputs(&buf[cpos]);
		ttflush();
		return i;
	    }
	    switch(i) {
d380 2
a381 2
		    msg = " [Ambiguous]";
		    break;
d383 3
a385 3
		    i=0;
		    msg = " [No match]";
		    break;
d388 1
a388 1
		    return i;
d390 3
a392 3
		    msg = " [Internal error]";
		    break;
	    }
d394 56
a449 17
	    if ((flags&EFBUF) != 0) lh = &(bheadp->b_list);
	    else if ((flags&EFFILE) != 0) {
		buf[cpos] = '\0';
		wholelist = lh = make_file_list(buf,0);
	    }
	    else panic("broken complt call: flags");

	    if (c == ' ') wflag = TRUE;
	    else if (c != '\t' && c != CCHR('M')) panic("broken complt call: c");

	    nhits = 0;
	    nxtra = HUGE;

	    while (lh != NULL) {
		for (i=0; i<cpos; ++i) {
			if (buf[i] != lh->l_name[i])
				break;
a450 32
		if (i == cpos) {
			if (nhits == 0)
				lh2 = lh;
			++nhits;
			if (lh->l_name[i] == '\0') nxtra = -1;
			else {
				bxtra = getxtra(lh, lh2, cpos, wflag);
				if (bxtra < nxtra) nxtra = bxtra;
				lh2 = lh;
			}
		}
		lh = lh->l_next;
	    }
	    if (nhits == 0)
		msg = " [No match]";
	    else if (nhits > 1 && nxtra == 0)
		msg = " [Ambiguous]";
	    else {		/* Got a match, do it to it */
		/*
		 * Being lazy - ought to check length, but all things
		 * autocompleted have known types/lengths.
		 */
		if (nxtra < 0 && nhits > 1 && c == ' ') nxtra = 1;
		for (i = 0; i < nxtra; ++i) {
			buf[cpos] = lh2->l_name[cpos];
			eputc(buf[cpos++]);
		}
		ttflush();
		free_file_list(wholelist);
		if (nxtra < 0 && c != CCHR('M')) return 0;
		return nxtra;
	    }
d452 4
a455 2
	/* wholelist is null if we are doing buffers.  want to free
	 * lists that were created for us, but not the buffer list! */
d460 1
a460 1
			ncol - ttcol - 2 : msglen;
d462 2
a463 2
	ttcol -= (i = nshown);		/* update ttcol!		*/
	while (i--)			/* move back before msg		*/
d465 1
a465 1
	ttflush();			/* display to user		*/
d467 1
a467 1
	while (i--)			/* blank out	on next flush	*/
d469 1
a469 1
	ttcol -= (i = nshown);		/* update ttcol on BS's		*/
d471 1
a471 1
		ttputc('\b');		/* update ttcol again!		*/
d478 17
a494 15
static int complt_list(flags, c, buf, cpos)
register char *buf;
register int cpos;
{
	register LIST	*lh, *lh2, *lh3;
	LIST		*wholelist = NULL;
	int		i,maxwidth,width;
	int		preflen = 0;
        BUFFER		*bp;
        static VOID	findbind();
	int		oldrow = ttrow;
	int		oldcol = ttcol;
	int		oldhue = tthue;
	char		linebuf[NCOL+1];
	char		*cp;
d499 35
a534 2
	bp = bfind("*help*", TRUE);
	if(bclear(bp) == FALSE) return FALSE;
d536 17
a552 1
	{  /* this {} present for historical reasons */
a553 19
/*
 * first get the list of objects.  This list may contain only the
 * ones that complete what has been typed, or may be the whole list
 * of all objects of this type.  They are filtered later in any case.
 * set wholelist if the list has been cons'ed up just for us, so we
 * can free it later.  We have to copy the buffer list for this
 * function even though we didn't for complt.  The sorting code
 * does destructive changes to the list, which we don't want to
 * happen to the main buffer list!
 */
	    if ((flags&EFBUF) != 0)
		wholelist = lh = copy_list (&(bheadp->b_list));
	    else if ((flags&EFFUNC) != 0) {
		buf[cpos] = '\0';
		wholelist = lh = complete_function_list(buf, c);
	    }
	    else if ((flags&EFFILE) != 0) {
		buf[cpos] = '\0';
		wholelist = lh = make_file_list(buf,1);
d555 2
a556 3
		 * we don't want to display stuff up to the / for file names
		 * preflen is the list of a prefix of what the user typed
		 * that should not be displayed.		
d558 13
a570 34
		cp = strrchr(buf,'/');
		if (cp)
		    preflen = cp - buf + 1;
	    }
	    else panic("broken complt call: flags");


/* sort the list, since users expect to see it in alphabetic order */

 	    lh2 = lh;
	    while (lh2) {
	 	lh3 = lh2->l_next;
		while (lh3) {
		    if (strcmp(lh2->l_name, lh3->l_name) > 0) {
			cp = lh2->l_name;
			lh2->l_name = lh3->l_name;
			lh3->l_name = cp;
		    }
		    lh3 = lh3->l_next;
	    	}
	        lh2 = lh2->l_next;
	    }

/*
 * first find max width of object to be displayed, so we can
 * put several on a line
 */
	    maxwidth = 0;

	    lh2 = lh;		
	    while (lh2 != NULL) {
		for (i=0; i<cpos; ++i) {
			if (buf[i] != lh2->l_name[i])
				break;
d572 33
a604 20
		if (i == cpos) {
			width = strlen(lh2->l_name);
			if (width > maxwidth)
				maxwidth = width;
		}
		lh2 = lh2->l_next;
	    }
	    maxwidth += 1 - preflen;

/*
 * now do the display.  objects are written into linebuf until it
 * fills, and then put into the help buffer.
 */
	    cp = linebuf;
	    width = 0;
	    lh2 = lh;
	    while (lh2 != NULL) {
		for (i=0; i<cpos; ++i) {
			if (buf[i] != lh2->l_name[i])
				break;
d606 5
a610 26
		if (i == cpos) {
			if ((width + maxwidth) > ncol) {
				*cp = 0;
				addline(bp,linebuf);
				cp = linebuf;
				width = 0;
			}
			strcpy(cp,lh2->l_name+preflen);
			i = strlen(lh2->l_name+preflen);
			cp += i;
			for (; i < maxwidth; i++)
				*cp++ = ' ';
			width += maxwidth;
		}
		lh2 = lh2->l_next;
	    }
	    if (width > 0) {
		*cp = 0;
		addline(bp,linebuf);
	    }
 	}
	/* 
	 * note that we free lists only if they are put in wholelist
	 * lists that were built just for us should be freed.  However
	 * when we use the buffer list, obviously we don't want it
	 * freed.
d613 6
a618 4
	popbuftop(bp);   /* split the screen and put up the help buffer */
	update();	 /* needed to make the new stuff actually appear */
	ttmove(oldrow,oldcol);  /* update leaves cursor in arbitrary place */
	ttcolor(oldhue);  /* with arbitrary color */
d629 8
a636 3
  */
getxtra(lp1, lp2, cpos, wflag) register LIST *lp1, *lp2; register int wflag; {
	register int	i;
d640 4
a643 2
		if (lp1->l_name[i] != lp2->l_name[i]) break;
		if (lp1->l_name[i] == '\0') break;
d645 2
a646 1
		if (wflag && !ISWORD(lp1->l_name[i-1])) break;
d658 1
a658 1
/*VARARGS 0 */
d660 3
d664 2
a665 1
va_dcl
d667 4
a670 2
	va_list pvar;
	register char *fp;
d673 8
a680 1
	if(inmacro) return;
a681 2
	va_start(pvar);
	fp = va_arg(pvar, char *);
d683 3
a685 3
	ttmove(nrow-1, 0);
	eformat(fp, &pvar);
	va_end(pvar);
d702 2
a703 2
register char *fp;
register va_list *ap;
d705 3
a707 4
	register int c;
	char	kname[NKNAME];
	char	*keyname();
	char	*cp;
d716 1
a716 1
				(VOID) keyname(kname, va_arg(*ap, int));
d722 3
a724 3
				for(c=0; c < key.k_count; c++) {
				    cp = keyname(cp, key.k_chars[c]);
				    *cp++ = ' ';
d731 1
a731 1
				eputi(va_arg(*ap, int), 10);
d735 1
a735 1
				eputi(va_arg(*ap, int), 8);
d739 1
a739 1
				eputs(va_arg(*ap, char *));
d742 1
a742 1
			case 'l':/* explicit longword */
d744 1
a744 1
				switch(c) {
d746 1
a746 1
					eputl((long)va_arg(*ap, long), 10);
d766 2
a767 2
register int i;
register int r;
d769 1
a769 1
	register int	q;
d771 3
a773 3
	if(i<0) {
	    eputc('-');
	    i = -i;
d775 1
a775 1
	if ((q=i/r) != 0)
d777 1
a777 1
	eputc(i%r+'0');
d785 2
a786 2
register long l;
register int  r;
d788 1
a788 1
	register long	q;
d790 3
a792 3
	if(l < 0) {
	    eputc('-');
	    l = -l;
d794 1
a794 1
	if ((q=l/r) != 0)
d796 1
a796 1
	eputc((int)(l%r)+'0');
d804 1
a804 1
register char *s;
d806 1
a806 1
	register int	c;
d819 1
a819 1
register char c;
d821 2
a822 1
	if (ttcol+2 < ncol) {
d832 1
d834 1
a834 1
  LIST *lp;
d836 7
a842 6
LIST *next;
while (lp) {
	next = lp->l_next;
	free(lp);
	lp = next;
}
d845 15
a859 14
LIST *copy_list(lp)
  LIST *lp;
{
LIST *current,*last;

last = NULL;
while(lp) {
	current = (LIST *)malloc(sizeof(LIST));
	current->l_next = last;
	current->l_name = lp->l_name;
	last = (LIST *)current;
	lp = lp->l_next;
}
return(last);
@

