head	1.104;
access;
symbols
	OPENBSD_6_2:1.104.0.2
	OPENBSD_6_2_BASE:1.104
	OPENBSD_6_1:1.103.0.4
	OPENBSD_6_1_BASE:1.103
	OPENBSD_6_0:1.101.0.2
	OPENBSD_6_0_BASE:1.101
	OPENBSD_5_9:1.100.0.2
	OPENBSD_5_9_BASE:1.100
	OPENBSD_5_8:1.99.0.4
	OPENBSD_5_8_BASE:1.99
	OPENBSD_5_7:1.98.0.2
	OPENBSD_5_7_BASE:1.98
	OPENBSD_5_6:1.97.0.4
	OPENBSD_5_6_BASE:1.97
	OPENBSD_5_5:1.96.0.6
	OPENBSD_5_5_BASE:1.96
	OPENBSD_5_4:1.96.0.2
	OPENBSD_5_4_BASE:1.96
	OPENBSD_5_3:1.95.0.2
	OPENBSD_5_3_BASE:1.95
	OPENBSD_5_2:1.94.0.2
	OPENBSD_5_2_BASE:1.94
	OPENBSD_5_1_BASE:1.85
	OPENBSD_5_1:1.85.0.2
	OPENBSD_5_0:1.84.0.4
	OPENBSD_5_0_BASE:1.84
	OPENBSD_4_9:1.84.0.2
	OPENBSD_4_9_BASE:1.84
	OPENBSD_4_8:1.82.0.8
	OPENBSD_4_8_BASE:1.82
	OPENBSD_4_7:1.82.0.4
	OPENBSD_4_7_BASE:1.82
	OPENBSD_4_6:1.82.0.6
	OPENBSD_4_6_BASE:1.82
	OPENBSD_4_5:1.82.0.2
	OPENBSD_4_5_BASE:1.82
	OPENBSD_4_4:1.81.0.4
	OPENBSD_4_4_BASE:1.81
	OPENBSD_4_3:1.81.0.2
	OPENBSD_4_3_BASE:1.81
	OPENBSD_4_2:1.80.0.4
	OPENBSD_4_2_BASE:1.80
	OPENBSD_4_1:1.80.0.2
	OPENBSD_4_1_BASE:1.80
	OPENBSD_4_0:1.77.0.2
	OPENBSD_4_0_BASE:1.77
	OPENBSD_3_9:1.68.0.2
	OPENBSD_3_9_BASE:1.68
	OPENBSD_3_8:1.50.0.2
	OPENBSD_3_8_BASE:1.50
	OPENBSD_3_7:1.48.0.2
	OPENBSD_3_7_BASE:1.48
	OPENBSD_3_6:1.42.0.2
	OPENBSD_3_6_BASE:1.42
	OPENBSD_3_5:1.40.0.2
	OPENBSD_3_5_BASE:1.40
	OPENBSD_3_4:1.38.0.2
	OPENBSD_3_4_BASE:1.38
	OPENBSD_3_3:1.34.0.4
	OPENBSD_3_3_BASE:1.34
	OPENBSD_3_2:1.34.0.2
	OPENBSD_3_2_BASE:1.34
	OPENBSD_3_1:1.27.0.2
	OPENBSD_3_1_BASE:1.27
	OPENBSD_3_0:1.20.0.2
	OPENBSD_3_0_BASE:1.20
	OPENBSD_2_9_BASE:1.10
	OPENBSD_2_9:1.10.0.2
	OPENBSD_2_8:1.8.0.2
	OPENBSD_2_8_BASE:1.8
	OPENBSD_2_7:1.7.0.2
	OPENBSD_2_7_BASE:1.7;
locks; strict;
comment	@ * @;


1.104
date	2017.05.30.07.05.22;	author florian;	state Exp;
branches;
next	1.103;
commitid	L2GD0imd4EtMY0Yn;

1.103
date	2016.07.28.21.40.25;	author tedu;	state Exp;
branches;
next	1.102;
commitid	A9Wo4oeMYtMwtFF5;

1.102
date	2016.07.28.21.37.45;	author tedu;	state Exp;
branches;
next	1.101;
commitid	mWujHdKL90lJ6y6i;

1.101
date	2016.07.04.03.24.48;	author guenther;	state Exp;
branches;
next	1.100;
commitid	edxEc3ChY9S5lfHz;

1.100
date	2016.01.26.18.02.51;	author jasper;	state Exp;
branches;
next	1.99;
commitid	X06Q0ND9qYkj0TeN;

1.99
date	2015.03.19.21.22.15;	author bcallah;	state Exp;
branches;
next	1.98;
commitid	GbEBL4CfPvDkB8hj;

1.98
date	2014.11.16.04.16.41;	author guenther;	state Exp;
branches;
next	1.97;
commitid	a9yG0qCw9VEW27qI;

1.97
date	2014.03.20.07.47.29;	author lum;	state Exp;
branches;
next	1.96;

1.96
date	2013.05.18.05.53.58;	author lum;	state Exp;
branches;
next	1.95;

1.95
date	2012.11.27.19.45.01;	author jasper;	state Exp;
branches;
next	1.94;

1.94
date	2012.07.10.06.28.12;	author lum;	state Exp;
branches;
next	1.93;

1.93
date	2012.06.18.07.14.55;	author jasper;	state Exp;
branches;
next	1.92;

1.92
date	2012.06.15.17.52.42;	author lum;	state Exp;
branches;
next	1.91;

1.91
date	2012.06.14.17.21.22;	author lum;	state Exp;
branches;
next	1.90;

1.90
date	2012.06.11.18.30.03;	author lum;	state Exp;
branches;
next	1.89;

1.89
date	2012.05.25.04.56.58;	author lum;	state Exp;
branches;
next	1.88;

1.88
date	2012.05.23.05.29.22;	author lum;	state Exp;
branches;
next	1.87;

1.87
date	2012.04.12.04.47.59;	author lum;	state Exp;
branches;
next	1.86;

1.86
date	2012.03.28.17.16.53;	author lum;	state Exp;
branches;
next	1.85;

1.85
date	2011.08.31.08.58.29;	author lum;	state Exp;
branches;
next	1.84;

1.84
date	2011.01.21.19.10.13;	author kjell;	state Exp;
branches;
next	1.83;

1.83
date	2011.01.21.18.58.55;	author kjell;	state Exp;
branches;
next	1.82;

1.82
date	2008.09.15.16.11.35;	author kjell;	state Exp;
branches;
next	1.81;

1.81
date	2007.11.27.16.22.14;	author martynas;	state Exp;
branches;
next	1.80;

1.80
date	2006.12.24.01.20.53;	author kjell;	state Exp;
branches;
next	1.79;

1.79
date	2006.11.19.16.51.19;	author deraadt;	state Exp;
branches;
next	1.78;

1.78
date	2006.09.19.05.52.23;	author otto;	state Exp;
branches;
next	1.77;

1.77
date	2006.07.25.08.22.32;	author kjell;	state Exp;
branches;
next	1.76;

1.76
date	2006.06.29.21.59.08;	author jason;	state Exp;
branches;
next	1.75;

1.75
date	2006.06.01.05.56.51;	author kjell;	state Exp;
branches;
next	1.74;

1.74
date	2006.06.01.05.34.52;	author jason;	state Exp;
branches;
next	1.73;

1.73
date	2006.05.03.22.25.34;	author kjell;	state Exp;
branches;
next	1.72;

1.72
date	2006.05.03.22.19.41;	author kjell;	state Exp;
branches;
next	1.71;

1.71
date	2006.05.03.21.15.59;	author kjell;	state Exp;
branches;
next	1.70;

1.70
date	2006.04.03.00.40.56;	author deraadt;	state Exp;
branches;
next	1.69;

1.69
date	2006.04.02.20.21.19;	author kjell;	state Exp;
branches;
next	1.68;

1.68
date	2005.12.20.06.17.36;	author kjell;	state Exp;
branches;
next	1.67;

1.67
date	2005.12.20.05.04.28;	author kjell;	state Exp;
branches;
next	1.66;

1.66
date	2005.12.13.05.40.33;	author kjell;	state Exp;
branches;
next	1.65;

1.65
date	2005.11.20.18.47.11;	author kjell;	state Exp;
branches;
next	1.64;

1.64
date	2005.11.20.04.16.34;	author kjell;	state Exp;
branches;
next	1.63;

1.63
date	2005.11.20.03.24.17;	author deraadt;	state Exp;
branches;
next	1.62;

1.62
date	2005.11.18.20.56.52;	author deraadt;	state Exp;
branches;
next	1.61;

1.61
date	2005.11.13.07.49.02;	author kjell;	state Exp;
branches;
next	1.60;

1.60
date	2005.11.11.18.51.49;	author kjell;	state Exp;
branches;
next	1.59;

1.59
date	2005.11.11.18.40.51;	author deraadt;	state Exp;
branches;
next	1.58;

1.58
date	2005.10.18.04.07.06;	author kjell;	state Exp;
branches;
next	1.57;

1.57
date	2005.10.17.14.54.03;	author kjell;	state Exp;
branches;
next	1.56;

1.56
date	2005.10.14.15.41.50;	author deraadt;	state Exp;
branches;
next	1.55;

1.55
date	2005.10.14.06.41.47;	author kjell;	state Exp;
branches;
next	1.54;

1.54
date	2005.10.13.20.23.01;	author kjell;	state Exp;
branches;
next	1.53;

1.53
date	2005.10.13.19.46.45;	author kjell;	state Exp;
branches;
next	1.52;

1.52
date	2005.10.13.05.59.19;	author kjell;	state Exp;
branches;
next	1.51;

1.51
date	2005.10.13.05.47.45;	author kjell;	state Exp;
branches;
next	1.50;

1.50
date	2005.06.14.18.14.40;	author kjell;	state Exp;
branches;
next	1.49;

1.49
date	2005.04.03.02.09.28;	author db;	state Exp;
branches;
next	1.48;

1.48
date	2005.03.10.16.58.57;	author deraadt;	state Exp;
branches;
next	1.47;

1.47
date	2005.03.10.16.46.24;	author henning;	state Exp;
branches;
next	1.46;

1.46
date	2005.03.09.16.20.48;	author jfb;	state Exp;
branches;
next	1.45;

1.45
date	2005.02.01.16.04.15;	author henning;	state Exp;
branches;
next	1.44;

1.44
date	2005.01.31.15.48.00;	author millert;	state Exp;
branches;
next	1.43;

1.43
date	2005.01.11.17.19.16;	author henning;	state Exp;
branches;
next	1.42;

1.42
date	2004.07.09.13.50.40;	author vincent;	state Exp;
branches;
next	1.41;

1.41
date	2004.07.08.20.48.50;	author vincent;	state Exp;
branches;
next	1.40;

1.40
date	2003.11.14.22.41.33;	author vincent;	state Exp;
branches;
next	1.39;

1.39
date	2003.11.08.19.17.29;	author jmc;	state Exp;
branches;
next	1.38;

1.38
date	2003.08.15.23.23.18;	author vincent;	state Exp;
branches;
next	1.37;

1.37
date	2003.08.15.23.09.57;	author vincent;	state Exp;
branches;
next	1.36;

1.36
date	2003.05.08.12.37.13;	author vincent;	state Exp;
branches;
next	1.35;

1.35
date	2003.05.06.10.45.07;	author vincent;	state Exp;
branches;
next	1.34;

1.34
date	2002.08.22.23.28.19;	author deraadt;	state Exp;
branches;
next	1.33;

1.33
date	2002.07.25.16.37.54;	author vincent;	state Exp;
branches;
next	1.32;

1.32
date	2002.07.01.17.20.04;	author vincent;	state Exp;
branches;
next	1.31;

1.31
date	2002.06.21.05.37.20;	author vincent;	state Exp;
branches;
next	1.30;

1.30
date	2002.04.22.05.27.39;	author vincent;	state Exp;
branches;
next	1.29;

1.29
date	2002.04.22.04.27.37;	author vincent;	state Exp;
branches;
next	1.28;

1.28
date	2002.04.15.23.24.42;	author deraadt;	state Exp;
branches;
next	1.27;

1.27
date	2002.03.27.17.42.37;	author millert;	state Exp;
branches;
next	1.26;

1.26
date	2002.03.16.19.30.29;	author vincent;	state Exp;
branches;
next	1.25;

1.25
date	2002.03.11.13.02.56;	author vincent;	state Exp;
branches;
next	1.24;

1.24
date	2002.02.22.00.18.37;	author deraadt;	state Exp;
branches;
next	1.23;

1.23
date	2002.02.14.22.58.20;	author vincent;	state Exp;
branches;
next	1.22;

1.22
date	2002.02.14.14.24.21;	author deraadt;	state Exp;
branches;
next	1.21;

1.21
date	2002.02.13.03.03.49;	author vincent;	state Exp;
branches;
next	1.20;

1.20
date	2001.09.21.15.08.16;	author wilfried;	state Exp;
branches;
next	1.19;

1.19
date	2001.07.09.07.04.49;	author deraadt;	state Exp;
branches;
next	1.18;

1.18
date	2001.07.06.13.32.45;	author art;	state Exp;
branches;
next	1.17;

1.17
date	2001.05.24.10.19.51;	author art;	state Exp;
branches;
next	1.16;

1.16
date	2001.05.24.03.05.22;	author mickey;	state Exp;
branches;
next	1.15;

1.15
date	2001.05.24.00.59.38;	author mickey;	state Exp;
branches;
next	1.14;

1.14
date	2001.05.23.22.36.14;	author art;	state Exp;
branches;
next	1.13;

1.13
date	2001.05.23.22.20.35;	author art;	state Exp;
branches;
next	1.12;

1.12
date	2001.05.03.12.57.22;	author art;	state Exp;
branches;
next	1.11;

1.11
date	2001.05.01.13.26.59;	author art;	state Exp;
branches;
next	1.10;

1.10
date	2001.01.29.01.58.07;	author niklas;	state Exp;
branches;
next	1.9;

1.9
date	2001.01.24.20.24.15;	author millert;	state Exp;
branches;
next	1.8;

1.8
date	2000.08.02.04.10.48;	author millert;	state Exp;
branches;
next	1.7;

1.7
date	2000.04.13.06.12.14;	author millert;	state Exp;
branches;
next	1.6;

1.6
date	2000.02.27.06.02.35;	author millert;	state Exp;
branches;
next	1.5;

1.5
date	2000.02.27.05.49.14;	author millert;	state Exp;
branches;
next	1.4;

1.4
date	2000.02.26.23.22.44;	author millert;	state Exp;
branches;
next	1.3;

1.3
date	2000.02.25.19.13.21;	author deraadt;	state Exp;
branches;
next	1.2;

1.2
date	2000.02.25.19.09.48;	author deraadt;	state Exp;
branches;
next	1.1;

1.1
date	2000.02.25.19.08.47;	author deraadt;	state Exp;
branches;
next	;


desc
@@


1.104
log
@fix -Wshadow warnings.
Found by bcallah, thanks!
@
text
@/*	$OpenBSD: fileio.c,v 1.103 2016/07/28 21:40:25 tedu Exp $	*/

/* This file is in the public domain. */

/*
 *	POSIX fileio.c
 */

#include <sys/queue.h>
#include <sys/resource.h>
#include <sys/stat.h>
#include <sys/time.h>
#include <sys/types.h>
#include <sys/wait.h>
#include <dirent.h>
#include <errno.h>
#include <fcntl.h>
#include <limits.h>
#include <pwd.h>
#include <signal.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>

#include "def.h"
#include "kbd.h"
#include "pathnames.h"

static char *bkuplocation(const char *);
static int   bkupleavetmp(const char *);

static char *bkupdir;
static int   leavetmp = 0;	/* 1 = leave any '~' files in tmp dir */

/*
 * Open a file for reading.
 */
int
ffropen(FILE ** ffp, const char *fn, struct buffer *bp)
{
	if ((*ffp = fopen(fn, "r")) == NULL) {
		if (errno == ENOENT)
			return (FIOFNF);
		return (FIOERR);
	}

	/* If 'fn' is a directory open it with dired. */
	if (fisdir(fn) == TRUE)
		return (FIODIR);

	ffstat(*ffp, bp);

	return (FIOSUC);
}

/*
 * Update stat/dirty info
 */
void
ffstat(FILE *ffp, struct buffer *bp)
{
	struct stat	sb;

	if (bp && fstat(fileno(ffp), &sb) == 0) {
		/* set highorder bit to make sure this isn't all zero */
		bp->b_fi.fi_mode = sb.st_mode | 0x8000;
		bp->b_fi.fi_uid = sb.st_uid;
		bp->b_fi.fi_gid = sb.st_gid;
		bp->b_fi.fi_mtime = sb.st_mtimespec;
		/* Clear the ignore flag */
		bp->b_flag &= ~(BFIGNDIRTY | BFDIRTY);
	}
}

/*
 * Update the status/dirty info. If there is an error,
 * there's not a lot we can do.
 */
int
fupdstat(struct buffer *bp)
{
	FILE *ffp;

	if ((ffp = fopen(bp->b_fname, "r")) == NULL) {
		if (errno == ENOENT)
			return (FIOFNF);
		return (FIOERR);
	}
	ffstat(ffp, bp);
	(void)ffclose(ffp, bp);
	return (FIOSUC);
}

/*
 * Open a file for writing.
 */
int
ffwopen(FILE ** ffp, const char *fn, struct buffer *bp)
{
	int	fd;
	mode_t	fmode = DEFFILEMODE;

	if (bp && bp->b_fi.fi_mode)
		fmode = bp->b_fi.fi_mode & 07777;

	fd = open(fn, O_RDWR | O_CREAT | O_TRUNC, fmode);
	if (fd == -1) {
		ffp = NULL;
		dobeep();
		ewprintf("Cannot open file for writing : %s", strerror(errno));
		return (FIOERR);
	}

	if ((*ffp = fdopen(fd, "w")) == NULL) {
		dobeep();
		ewprintf("Cannot open file for writing : %s", strerror(errno));
		close(fd);
		return (FIOERR);
	}

	/*
	 * If we have file information, use it.  We don't bother to check for
	 * errors, because there's no a lot we can do about it.  Certainly
	 * trying to change ownership will fail if we aren't root.  That's
	 * probably OK.  If we don't have info, no need to get it, since any
	 * future writes will do the same thing.
	 */
	if (bp && bp->b_fi.fi_mode) {
		fchmod(fd, bp->b_fi.fi_mode & 07777);
		fchown(fd, bp->b_fi.fi_uid, bp->b_fi.fi_gid);
	}
	return (FIOSUC);
}

/*
 * Close a file.
 */
/* ARGSUSED */
int
ffclose(FILE *ffp, struct buffer *bp)
{
	if (fclose(ffp) == 0)
		return (FIOSUC);
	return (FIOERR);
}

/*
 * Write a buffer to the already opened file. bp points to the
 * buffer. Return the status.
 */
int
ffputbuf(FILE *ffp, struct buffer *bp)
{
	struct line   *lp, *lpend;

	lpend = bp->b_headp;
	for (lp = lforw(lpend); lp != lpend; lp = lforw(lp)) {
		if (fwrite(ltext(lp), 1, llength(lp), ffp) != llength(lp)) {
			dobeep();
			ewprintf("Write I/O error");
			return (FIOERR);
		}
		if (lforw(lp) != lpend)		/* no implied \n on last line */
			putc('\n', ffp);
	}
	/*
	 * XXX should be variable controlled (once we have variables)
	 */
	if (llength(lback(lpend)) != 0) {
		if (eyorn("No newline at end of file, add one") == TRUE) {
			lnewline_at(lback(lpend), llength(lback(lpend)));
			putc('\n', ffp);
		}
	}
	return (FIOSUC);
}

/*
 * Read a line from a file, and store the bytes
 * in the supplied buffer. Stop on end of file or end of
 * line.  When FIOEOF is returned, there is a valid line
 * of data without the normally implied \n.
 * If the line length exceeds nbuf, FIOLONG is returned.
 */
int
ffgetline(FILE *ffp, char *buf, int nbuf, int *nbytes)
{
	int	c, i;

	i = 0;
	while ((c = getc(ffp)) != EOF && c != '\n') {
		buf[i++] = c;
		if (i >= nbuf)
			return (FIOLONG);
	}
	if (c == EOF && ferror(ffp) != FALSE) {
		dobeep();
		ewprintf("File read error");
		return (FIOERR);
	}
	*nbytes = i;
	return (c == EOF ? FIOEOF : FIOSUC);
}

/*
 * Make a backup copy of "fname".  On Unix the backup has the same
 * name as the original file, with a "~" on the end; this seems to
 * be newest of the new-speak. The error handling is all in "file.c".
 * We do a copy instead of a rename since otherwise another process
 * with an open fd will get the backup, not the new file.  This is
 * a problem when using mg with things like crontab and vipw.
 */
int
fbackupfile(const char *fn)
{
	struct stat	 sb;
	struct timespec	 new_times[2];
	int		 from, to, serrno;
	ssize_t		 nread;
	char		 buf[BUFSIZ];
	char		*nname, *tname, *bkpth;

	if (stat(fn, &sb) == -1) {
		dobeep();
		ewprintf("Can't stat %s : %s", fn, strerror(errno));
		return (FALSE);
	}

	if ((bkpth = bkuplocation(fn)) == NULL)
		return (FALSE);

	if (asprintf(&nname, "%s~", bkpth) == -1) {
		dobeep();
		ewprintf("Can't allocate backup file name : %s", strerror(errno));
		free(bkpth);
		return (ABORT);
	}
	if (asprintf(&tname, "%s.XXXXXXXXXX", bkpth) == -1) {
		dobeep();
		ewprintf("Can't allocate temp file name : %s", strerror(errno));
		free(bkpth);
		free(nname);
		return (ABORT);
	}
	free(bkpth);

	if ((from = open(fn, O_RDONLY)) == -1) {
		free(nname);
		free(tname);
		return (FALSE);
	}
	to = mkstemp(tname);
	if (to == -1) {
		serrno = errno;
		close(from);
		free(nname);
		free(tname);
		errno = serrno;
		return (FALSE);
	}
	while ((nread = read(from, buf, sizeof(buf))) > 0) {
		if (write(to, buf, (size_t)nread) != nread) {
			nread = -1;
			break;
		}
	}
	serrno = errno;
	(void) fchmod(to, (sb.st_mode & 0777));

	/* copy the mtime to the backupfile */
	new_times[0] = sb.st_atim;
	new_times[1] = sb.st_mtim;
	futimens(to, new_times);

	close(from);
	close(to);
	if (nread == -1) {
		if (unlink(tname) == -1)
			ewprintf("Can't unlink temp : %s", strerror(errno));
	} else {
		if (rename(tname, nname) == -1) {
			ewprintf("Can't rename temp : %s", strerror(errno));
			(void) unlink(tname);
			nread = -1;
		}
	}
	free(nname);
	free(tname);
	errno = serrno;

	return (nread == -1 ? FALSE : TRUE);
}

/*
 * Convert "fn" to a canonicalized absolute filename, replacing
 * a leading ~/ with the user's home dir, following symlinks, and
 * remove all occurrences of /./ and /../
 */
char *
adjustname(const char *fn, int slashslash)
{
	static char	 fnb[PATH_MAX];
	const char	*cp, *ep = NULL;
	char		*path;

	if (slashslash == TRUE) {
		cp = fn + strlen(fn) - 1;
		for (; cp >= fn; cp--) {
			if (ep && (*cp == '/')) {
				fn = ep;
				break;
			}
			if (*cp == '/' || *cp == '~')
				ep = cp;
			else
				ep = NULL;
		}
	}
	if ((path = expandtilde(fn)) == NULL)
		return (NULL);

	if (realpath(path, fnb) == NULL)
		(void)strlcpy(fnb, path, sizeof(fnb));

	free(path);
	return (fnb);
}

/*
 * Find a startup file for the user and return its name. As a service
 * to other pieces of code that may want to find a startup file (like
 * the terminal driver in particular), accepts a suffix to be appended
 * to the startup file name.
 */
char *
startupfile(char *suffix)
{
	static char	 file[NFILEN];
	char		*home;
	int		 ret;

	if ((home = getenv("HOME")) == NULL || *home == '\0')
		goto nohome;

	if (suffix == NULL) {
		ret = snprintf(file, sizeof(file), _PATH_MG_STARTUP, home);
		if (ret < 0 || ret >= sizeof(file))
			return (NULL);
	} else {
		ret = snprintf(file, sizeof(file), _PATH_MG_TERM, home, suffix);
		if (ret < 0 || ret >= sizeof(file))
			return (NULL);
	}

	if (access(file, R_OK) == 0)
		return (file);
nohome:
#ifdef STARTUPFILE
	if (suffix == NULL) {
		ret = snprintf(file, sizeof(file), "%s", STARTUPFILE);
		if (ret < 0 || ret >= sizeof(file))
			return (NULL);
	} else {
		ret = snprintf(file, sizeof(file), "%s%s", STARTUPFILE,
		    suffix);
		if (ret < 0 || ret >= sizeof(file))
			return (NULL);
	}

	if (access(file, R_OK) == 0)
		return (file);
#endif /* STARTUPFILE */
	return (NULL);
}

int
copy(char *frname, char *toname)
{
	int	ifd, ofd;
	char	buf[BUFSIZ];
	mode_t	fmode = DEFFILEMODE;	/* XXX?? */
	struct	stat orig;
	ssize_t	sr;

	if ((ifd = open(frname, O_RDONLY)) == -1)
		return (FALSE);
	if (fstat(ifd, &orig) == -1) {
		dobeep();
		ewprintf("fstat: %s", strerror(errno));
		close(ifd);
		return (FALSE);
	}

	if ((ofd = open(toname, O_WRONLY|O_CREAT|O_TRUNC, fmode)) == -1) {
		close(ifd);
		return (FALSE);
	}
	while ((sr = read(ifd, buf, sizeof(buf))) > 0) {
		if (write(ofd, buf, (size_t)sr) != sr) {
			ewprintf("write error : %s", strerror(errno));
			break;
		}
	}
	if (fchmod(ofd, orig.st_mode) == -1)
		ewprintf("Cannot set original mode : %s", strerror(errno));

	if (sr == -1) {
		ewprintf("Read error : %s", strerror(errno));
		close(ifd);
		close(ofd);
		return (FALSE);
	}
	/*
	 * It is "normal" for this to fail since we can't guarantee that
	 * we will be running as root.
	 */
	if (fchown(ofd, orig.st_uid, orig.st_gid) && errno != EPERM)
		ewprintf("Cannot set owner : %s", strerror(errno));

	(void) close(ifd);
	(void) close(ofd);

	return (TRUE);
}

/*
 * return list of file names that match the name in buf.
 */
struct list *
make_file_list(char *buf)
{
	char		*dir, *file, *cp;
	size_t		 len, preflen;
	int		 ret;
	DIR		*dirp;
	struct dirent	*dent;
	struct list	*last, *current;
	char		 fl_name[NFILEN + 2];
	char		 prefixx[NFILEN + 1];

	/*
	 * We need three different strings:

	 * dir - the name of the directory containing what the user typed.
	 *  Must be a real unix file name, e.g. no ~user, etc..
	 *  Must not end in /.
	 * prefix - the portion of what the user typed that is before the
	 *  names we are going to find in the directory.  Must have a
	 * trailing / if the user typed it.
	 * names from the directory - We open dir, and return prefix
	 * concatenated with names.
	 */

	/* first we get a directory name we can look up */
	/*
	 * Names ending in . are potentially odd, because adjustname will
	 * treat foo/bar/.. as a foo/, whereas we are
	 * interested in names starting with ..
	 */
	len = strlen(buf);
	if (len && buf[len - 1] == '.') {
		buf[len - 1] = 'x';
		dir = adjustname(buf, TRUE);
		buf[len - 1] = '.';
	} else
		dir = adjustname(buf, TRUE);
	if (dir == NULL)
		return (NULL);
	/*
	 * If the user typed a trailing / or the empty string
	 * he wants us to use his file spec as a directory name.
	 */
	if (len && buf[len - 1] != '/') {
		file = strrchr(dir, '/');
		if (file) {
			*file = '\0';
			if (*dir == '\0')
				dir = "/";
		} else
			return (NULL);
	}
	/* Now we get the prefix of the name the user typed. */
	if (strlcpy(prefixx, buf, sizeof(prefixx)) >= sizeof(prefixx))
		return (NULL);
	cp = strrchr(prefixx, '/');
	if (cp == NULL)
		prefixx[0] = '\0';
	else
		cp[1] = '\0';

	preflen = strlen(prefixx);
	/* cp is the tail of buf that really needs to be compared. */
	cp = buf + preflen;
	len = strlen(cp);

	/*
	 * Now make sure that file names will fit in the buffers allocated.
	 * SV files are fairly short.  For BSD, something more general would
	 * be required.
	 */
	if (preflen > NFILEN - MAXNAMLEN)
		return (NULL);

	/* loop over the specified directory, making up the list of files */

	/*
	 * Note that it is worth our time to filter out names that don't
	 * match, even though our caller is going to do so again, and to
	 * avoid doing the stat if completion is being done, because stat'ing
	 * every file in the directory is relatively expensive.
	 */

	dirp = opendir(dir);
	if (dirp == NULL)
		return (NULL);
	last = NULL;

	while ((dent = readdir(dirp)) != NULL) {
		int isdir;
		if (strncmp(cp, dent->d_name, len) != 0)
			continue;
		isdir = 0;
		if (dent->d_type == DT_DIR) {
			isdir = 1;
		} else if (dent->d_type == DT_LNK ||
			    dent->d_type == DT_UNKNOWN) {
			struct stat	statbuf;

			if (fstatat(dirfd(dirp), dent->d_name, &statbuf, 0) < 0)
				continue;
			if (S_ISDIR(statbuf.st_mode))
				isdir = 1;
		}

		if ((current = malloc(sizeof(struct list))) == NULL) {
			free_file_list(last);
			closedir(dirp);
			return (NULL);
		}
		ret = snprintf(fl_name, sizeof(fl_name),
		    "%s%s%s", prefixx, dent->d_name, isdir ? "/" : "");
		if (ret < 0 || ret >= sizeof(fl_name)) {
			free(current);
			continue;
		}
		current->l_next = last;
		current->l_name = strdup(fl_name);
		last = current;
	}
	closedir(dirp);

	return (last);
}

/*
 * Test if a supplied filename refers to a directory
 * Returns ABORT on error, TRUE if directory. FALSE otherwise
 */
int
fisdir(const char *fname)
{
	struct stat	statbuf;

	if (stat(fname, &statbuf) != 0)
		return (ABORT);

	if (S_ISDIR(statbuf.st_mode))
		return (TRUE);

	return (FALSE);
}

/*
 * Check the mtime of the supplied filename.
 * Return TRUE if last mtime matches, FALSE if not,
 * If the stat fails, return TRUE and try the save anyway
 */
int
fchecktime(struct buffer *bp)
{
	struct stat sb;

	if (stat(bp->b_fname, &sb) == -1)
		return (TRUE);

	if (bp->b_fi.fi_mtime.tv_sec != sb.st_mtimespec.tv_sec ||
	    bp->b_fi.fi_mtime.tv_nsec != sb.st_mtimespec.tv_nsec)
		return (FALSE);

	return (TRUE);

}

/*
 * Location of backup file. This function creates the correct path.
 */
static char *
bkuplocation(const char *fn)
{
	struct stat sb;
	char *ret;

	if (bkupdir != NULL && (stat(bkupdir, &sb) == 0) &&
	    S_ISDIR(sb.st_mode) && !bkupleavetmp(fn)) {
		char fname[NFILEN];
		const char *c;
		int i = 0, len;

		c = fn;
		len = strlen(bkupdir);

		while (*c != '\0') {
			/* Make sure we don't go over combined:
		 	* strlen(bkupdir + '/' + fname + '\0')
		 	*/
			if (i >= NFILEN - len - 1)
				return (NULL);
			if (*c == '/') {
				fname[i] = '!';
			} else if (*c == '!') {
				if (i >= NFILEN - len - 2)
					return (NULL);
				fname[i++] = '!';
				fname[i] = '!';
			} else
				fname[i] = *c;
			i++;
			c++;
		}
		fname[i] = '\0';
		if (asprintf(&ret, "%s/%s", bkupdir, fname) == -1)
			return (NULL);

	} else if ((ret = strndup(fn, NFILEN)) == NULL)
		return (NULL);

	return (ret);
}

int
backuptohomedir(int f, int n)
{
	const char	*c = _PATH_MG_DIR;
	char		*p;

	if (bkupdir == NULL) {
		p = adjustname(c, TRUE);
		bkupdir = strndup(p, NFILEN);
		if (bkupdir == NULL)
			return(FALSE);

		if (mkdir(bkupdir, 0700) == -1 && errno != EEXIST) {
			free(bkupdir);
			bkupdir = NULL;
		}
	} else {
		free(bkupdir);
		bkupdir = NULL;
	}

	return (TRUE);
}

/*
 * For applications that use mg as the editor and have a desire to keep
 * '~' files in /tmp, toggle the location: /tmp | ~/.mg.d
 */
int
toggleleavetmp(int f, int n)
{
	leavetmp = !leavetmp;

	return (TRUE);
}

/*
 * Returns TRUE if fn is located in the temp directory and we want to save
 * those backups there.
 */
int
bkupleavetmp(const char *fn)
{
	if (!leavetmp)
		return(FALSE);

	if (strncmp(fn, "/tmp", 4) == 0)
		return (TRUE);

	return (FALSE);
}

/*
 * Expand file names beginning with '~' if appropriate:
 *   1, if ./~fn exists, continue without expanding tilde.
 *   2, else, if username 'fn' exists, expand tilde with home directory path.
 *   3, otherwise, continue and create new buffer called ~fn.
 */
char *
expandtilde(const char *fn)
{
	struct passwd	*pw;
	struct stat	 statbuf;
	const char	*cp;
	char		 user[LOGIN_NAME_MAX], path[NFILEN];
	char		*un, *ret;
	size_t		 ulen, plen;

	path[0] = '\0';

	if (fn[0] != '~' || stat(fn, &statbuf) == 0) {
		if ((ret = strndup(fn, NFILEN)) == NULL)
			return (NULL);
		return(ret);
	}
	cp = strchr(fn, '/');
	if (cp == NULL)
		cp = fn + strlen(fn); /* point to the NUL byte */
	ulen = cp - &fn[1];
	if (ulen >= sizeof(user)) {
		if ((ret = strndup(fn, NFILEN)) == NULL)
			return (NULL);
		return(ret);
	}
	if (ulen == 0) { /* ~/ or ~ */
		if ((un = getlogin()) != NULL)
			(void)strlcpy(user, un, sizeof(user));
		else
			user[0] = '\0';
	} else { /* ~user/ or ~user */
		memcpy(user, &fn[1], ulen);
		user[ulen] = '\0';
	}
	pw = getpwnam(user);
	if (pw != NULL) {
		plen = strlcpy(path, pw->pw_dir, sizeof(path));
		if (plen == 0 || path[plen - 1] != '/') {
			if (strlcat(path, "/", sizeof(path)) >= sizeof(path)) {
				dobeep();				
				ewprintf("Path too long");
				return (NULL);
			}
		}
		fn = cp;
		if (*fn == '/')
			fn++;
	}
	if (strlcat(path, fn, sizeof(path)) >= sizeof(path)) {
		dobeep();
		ewprintf("Path too long");
		return (NULL);
	}
	if ((ret = strndup(path, NFILEN)) == NULL)
		return (NULL);

	return (ret);
}
@


1.103
log
@strncmp is a more reasonable way to check the beginning of a string.
@
text
@d1 1
a1 1
/*	$OpenBSD: fileio.c,v 1.102 2016/07/28 21:37:45 tedu Exp $	*/
d218 1
a271 1
	struct timespec new_times[2];
@


1.102
log
@these programs probably do not need to use TMPDIR. ok florian
@
text
@d1 1
a1 1
/*	$OpenBSD: fileio.c,v 1.101 2016/07/04 03:24:48 guenther Exp $	*/
a683 2
	char	*tmp = NULL;

d687 1
a687 2
	tmp = strstr(fn, "/tmp");
	if (tmp == fn)
@


1.101
log
@Use fstatat() instead of crafting a filename to use with stat()

ok millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: fileio.c,v 1.100 2016/01/26 18:02:51 jasper Exp $	*/
d667 1
a667 1
 * '~' files in the TMPDIR, toggle the location: /tmp | ~/.mg.d
d684 1
a684 1
	char	*tmpdir, *tmp = NULL;
a687 8

	if((tmpdir = getenv("TMPDIR")) != NULL && *tmpdir != '\0') {
		tmp = strstr(fn, tmpdir);
		if (tmp == fn)
			return (TRUE);

		return (FALSE);
	}
@


1.100
log
@ensure the backup file has the same mtime as the original file, this is in line
with emacs' behaviour.

from Harald Dunkel via Han Boetes
ok lum@@
@
text
@d1 1
a1 1
/*	$OpenBSD: fileio.c,v 1.99 2015/03/19 21:22:15 bcallah Exp $	*/
a528 1
			char		statname[NFILEN + 2];
d530 1
a530 6
			statbuf.st_mode = 0;
			ret = snprintf(statname, sizeof(statname), "%s/%s",
			    dir, dent->d_name);
			if (ret < 0 || ret > sizeof(statname) - 1)
				continue;
			if (stat(statname, &statbuf) < 0)
@


1.99
log
@Clean up the includes in mg.
This does the following:
Moves all POSIX headers from sysdef.h into the individual .c files so that
each file now only includes what it needs. All headers are properly sorted.
Moves the remainder of sysdef.h to other files (mostly def.h) and deletes
sysdef.h now that it's no longer contains anything.
Tweak a comment that references sysdef.h so that it no longer does that.
ok florian@@
@
text
@d1 1
a1 1
/*	$OpenBSD: fileio.c,v 1.98 2014/11/16 04:16:41 guenther Exp $	*/
d269 7
@


1.98
log
@Stop using <sys/param.h>; replace MAXPATHLEN with PATH_MAX, stop using MAX(),
and pull in <limits.h> for *_MAX constants.

inspired on a diff from Kamil Rytarowski (n54 (at) gmx.com)
ok bcallah@@
@
text
@d1 1
a1 1
/*	$OpenBSD: fileio.c,v 1.97 2014/03/20 07:47:29 lum Exp $	*/
a7 1
#include "def.h"
d9 2
a10 1
#include <sys/types.h>
d13 1
a13 1
#include <sys/resource.h>
d15 2
a16 1

a18 1
#include <dirent.h>
d20 3
d26 1
@


1.97
log
@Add some missing dobeeps.
ok florian@@
@
text
@d1 1
a1 1
/*	$OpenBSD: fileio.c,v 1.96 2013/05/18 05:53:58 lum Exp $	*/
d292 1
a292 1
	static char	 fnb[MAXPATHLEN];
@


1.96
log
@and and -> and
@
text
@d1 1
a1 1
/*	$OpenBSD: fileio.c,v 1.95 2012/11/27 19:45:01 jasper Exp $	*/
d106 1
d112 1
d156 1
d194 1
d220 1
d229 1
d235 1
d378 1
d745 1
d755 1
@


1.95
log
@- move prototype of expandtilder() to def.h; needed by an upcoming diff.
@
text
@d1 1
a1 1
/*	$OpenBSD: fileio.c,v 1.94 2012/07/10 06:28:12 lum Exp $	*/
d280 1
a280 1
 * and remove all occurrences of /./ and /../
@


1.94
log
@Fix an outstanding debian bug: #658539

"looks good" kjell
@
text
@d1 1
a1 1
/*	$OpenBSD: fileio.c,v 1.93 2012/06/18 07:14:55 jasper Exp $	*/
a27 1
char	    *expandtilde(const char *);
@


1.93
log
@- add a pathnames.h
- some whitespace cleanup

ok lum@@
@
text
@d1 1
a1 1
/*	$OpenBSD: fileio.c,v 1.92 2012/06/15 17:52:42 lum Exp $	*/
d704 2
a705 1
	char		 user[LOGIN_NAME_MAX], path[NFILEN], *ret;
d724 6
a729 3
	if (ulen == 0) /* ~/ or ~ */
		(void)strlcpy(user, getlogin(), sizeof(user));
	else { /* ~user/ or ~user */
@


1.92
log
@Fixes a problem where if you try to open a file that doesn't exist and has
a name longer than LOGIN_NAME_MAX and also has a tilde at the front
e.g:

$ mg ~01234567890123456789012345678901

mg will give a "Login name too long" instead of opening a new buffer
named ~01234567890123456789012345678901
@
text
@d1 1
a1 1
/*	$OpenBSD: fileio.c,v 1.91 2012/06/14 17:21:22 lum Exp $	*/
d24 1
d31 1
a31 1
static int   leavetmp = 0;	/* 1 = leave any '~' files in tmp dir */  
d50 1
a50 1
	
d140 1
a140 1
	return (FIOERR);	
d330 1
a330 1
		ret = snprintf(file, sizeof(file), "%s/.mg", home);
d334 1
a334 1
		ret = snprintf(file, sizeof(file), "%s/.mg-%s", home, suffix);
d580 1
a580 1
	
d632 1
a632 1
	const char	*c = "~/.mg.d";
d692 1
a692 1
/* 
@


1.91
log
@Allow mg to save backup files to a users home directory.
Suggestions from eric@@ and Sunil Nimmagadda.
Remarks deraadt@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: fileio.c,v 1.90 2012/06/11 18:30:03 lum Exp $	*/
d27 1
a284 1
	struct stat	 statbuf; 
d287 1
a287 4
	char		 user[LOGIN_NAME_MAX], path[MAXPATHLEN];
	size_t		 ulen, plen;

	path[0] = '\0';
d302 1
a302 42

	/* 
	 * Next, expand file names beginning with '~', if appropriate:
	 *   1, if ./~fn exists, continue without expanding tilde.
	 *   2, otherwise, if username 'fn' exists, expand tilde with home
	 *	directory path.
	 *   3, otherwise, continue and create new buffer called ~fn.
	 */
	if (fn[0] == '~' && stat(fn, &statbuf) != 0) {
		struct passwd *pw;

		cp = strchr(fn, '/');
		if (cp == NULL)
			cp = fn + strlen(fn); /* point to the NUL byte */
		ulen = cp - &fn[1];
		if (ulen >= sizeof(user)) {
			ewprintf("Login name too long");
			return (NULL);
		}
		if (ulen == 0) /* ~/ or ~ */
			(void)strlcpy(user, getlogin(), sizeof(user));
		else { /* ~user/ or ~user */
			memcpy(user, &fn[1], ulen);
			user[ulen] = '\0';
		}
		pw = getpwnam(user);
		if (pw != NULL) {
			plen = strlcpy(path, pw->pw_dir, sizeof(path));
			if (plen == 0 || path[plen - 1] != '/') {
				if (strlcat(path, "/", sizeof(path)) >=
				    sizeof(path)) {
					ewprintf("Path too long");
					return (NULL);
				}
			}
			fn = cp;
			if (*fn == '/')
				fn++;
		}
	}
	if (strlcat(path, fn, sizeof(path)) >= sizeof(path)) {
		ewprintf("Path too long");
a303 1
	}
d308 1
d689 60
@


1.90
log
@Change error message to reflect the correct filename: nname is 'New
name' as opposed to tname 'Temp name'
@
text
@d1 1
a1 1
/*	$OpenBSD: fileio.c,v 1.89 2012/05/25 04:56:58 lum Exp $	*/
d25 6
d212 1
a212 1
	char		*nname, *tname;
d219 4
a222 1
	if (asprintf(&nname, "%s~", fn) == -1) {
d224 1
d227 1
a227 2

	if (asprintf(&tname, "%s.XXXXXXXXXX", fn) == -1) {
d229 1
d233 1
d624 109
@


1.89
log
@Remove static FILE pointer used for handling files in fileio.c. Pass
by reference instead. This allows the mg startup file to open other
files without unexpected things happening.

Discussed with Sunil Nimmagadda.
@
text
@d1 1
a1 1
/*	$OpenBSD: fileio.c,v 1.88 2012/05/23 05:29:22 lum Exp $	*/
d214 1
a214 1
		ewprintf("Can't allocate temp file name : %s", strerror(errno));
@


1.88
log
@Change how mg handles files beginning with a '~'.
Bring behaviour more into line with emacs.
@
text
@d1 1
a1 1
/*	$OpenBSD: fileio.c,v 1.87 2012/04/12 04:47:59 lum Exp $	*/
a24 2
static FILE	*ffp;

d29 1
a29 1
ffropen(const char *fn, struct buffer *bp)
d31 1
a31 1
	if ((ffp = fopen(fn, "r")) == NULL) {
d41 1
a41 1
	ffstat(bp);
d50 1
a50 1
ffstat(struct buffer *bp)
d72 2
d79 2
a80 2
	ffstat(bp);
	(void)ffclose(bp);
d88 1
a88 1
ffwopen(const char *fn, struct buffer *bp)
d103 1
a103 1
	if ((ffp = fdopen(fd, "w")) == NULL) {
d128 1
a128 1
ffclose(struct buffer *bp)
d140 1
a140 1
ffputbuf(struct buffer *bp)
d173 1
a173 1
ffgetline(char *buf, int nbuf, int *nbytes)
@


1.87
log
@Remove the conditional directives NO_MACRO and NO_STARTUP.
They have not compiled for numerous years.
ok kjell@@ millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: fileio.c,v 1.86 2012/03/28 17:16:53 lum Exp $	*/
d273 1
d295 8
a302 2
	/* first handle tilde expansion */
	if (fn[0] == '~') {
d320 8
a327 9
		if (pw == NULL) {
			ewprintf("Unknown user %s", user);
			return (NULL);
		}
		plen = strlcpy(path, pw->pw_dir, sizeof(path));
		if (plen == 0 || path[plen - 1] != '/') {
			if (strlcat(path, "/", sizeof(path)) >= sizeof(path)) {
				ewprintf("Path too long");
				return (NULL);
d329 3
a332 3
		fn = cp;
		if (*fn == '/')
			fn++;
@


1.86
log
@Close an opendir(). From Igor Zinovik.
@
text
@d1 1
a1 1
/*	$OpenBSD: fileio.c,v 1.85 2011/08/31 08:58:29 lum Exp $	*/
a338 1
#ifndef NO_STARTUP
a384 1
#endif /* !NO_STARTUP */
@


1.85
log
@On a file write fail:

1. return an error value
2. show an error message

From Loganaden Velvindron with suggestion from millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: fileio.c,v 1.84 2011/01/21 19:10:13 kjell Exp $	*/
d554 1
@


1.84
log
@It volates style(9), but in mg, #include"def.h" goes first. 'twas the way it was built. no binary change here. confirmed by lum@@, tested by Henri Kemppainen
@
text
@d1 1
a1 1
/*	$OpenBSD: fileio.c,v 1.83 2011/01/21 18:58:55 kjell Exp $	*/
d80 1
a80 1
	ffclose(bp);
a124 1
 * XXX - Should look at the status.
d130 3
a132 2
	(void) fclose(ffp);
	return (FIOSUC);
@


1.83
log
@Change len+memcmp check to a strncmp for prefix testing on
filename completion. Avoids a recurring portability headache.
ok lum@@
"concerns assuaged to the soothing sounds of Martin Denny blambert@@"
(I worry about that guy...)
@
text
@d1 1
a1 1
/*	$OpenBSD: fileio.c,v 1.82 2008/09/15 16:11:35 kjell Exp $	*/
a8 1

@


1.82
log
@Enable dirty buffer detection in mg.
Emulate the emacs behavior: after suspend/resume, buffer switch,
or at save time, warn (prompt) the user if the file has been modified
on disk in the interim.
This has already saved my butt numerous times.
ok phessler
@
text
@d1 1
a1 1
/*	$OpenBSD: fileio.c,v 1.81 2007/11/27 16:22:14 martynas Exp $	*/
d532 1
a532 2

		if (dent->d_namlen < len || memcmp(cp, dent->d_name, len) != 0)
a533 1

@


1.81
log
@typos;  ok jmc@@
sys/dev/pci/pciide.c from naddy@@
@
text
@d1 1
a1 1
/*	$OpenBSD: fileio.c,v 1.80 2006/12/24 01:20:53 kjell Exp $	*/
d11 1
a12 1
#include <sys/types.h>
a33 2
	struct stat	statbuf;

d44 14
a57 1
	if (bp && fstat(fileno(ffp), &statbuf) == 0) {
d59 6
a64 3
		bp->b_fi.fi_mode = statbuf.st_mode | 0x8000;
		bp->b_fi.fi_uid = statbuf.st_uid;
		bp->b_fi.fi_gid = statbuf.st_gid;
d66 1
d68 14
d590 21
@


1.80
log
@Fix a bug where inserting a file resulted in an incorrect
line-number count for a buffer (M-X insert-file, M-> to reproduce).
While here, fix a number of bugs with incorrect line numbers
after swap point-and-mark

Originally reported via debian's bug tracking system. Fix tested by
Han Boetes and Deanna Phillips.
@
text
@d1 1
a1 1
/*	$OpenBSD: fileio.c,v 1.79 2006/11/19 16:51:19 deraadt Exp $	*/
d240 1
a240 1
 * and remove all occurences of /./ and /../
@


1.79
log
@spacing
@
text
@d1 1
a1 1
/*	$OpenBSD: fileio.c,v 1.78 2006/09/19 05:52:23 otto Exp $	*/
d142 1
@


1.78
log
@Use S_IS* macros insted of masking with S_IF* flags. The latter may
have multiple bits set, which lead to surprising results. Spotted by
Paul Stoeber, more to come. ok millert@@ pedro@@ jaredy@@ djm@@
@
text
@d1 1
a1 1
/*	$OpenBSD: fileio.c,v 1.77 2006/07/25 08:22:32 kjell Exp $	*/
d424 1
a424 1
	 * We need three different strings: 
@


1.77
log
@Rename the header line of a buffer to b_headp, from the remarkably
unintuitive b_linep. No binary change.
@
text
@d1 1
a1 1
/*	$OpenBSD: fileio.c,v 1.76 2006/06/29 21:59:08 jason Exp $	*/
d521 1
a521 1
			if (statbuf.st_mode & S_IFDIR)
@


1.76
log
@- use <dirent.h> not <sys/dir.h> (this appeases FreeBSD's annoying #warning)
- grab <sys/time.h> before <sys/resource.h> like getrusage(2) says
ok kjell
@
text
@d1 1
a1 1
/*	$OpenBSD: fileio.c,v 1.75 2006/06/01 05:56:51 kjell Exp $	*/
d116 1
a116 1
	lpend = bp->b_linep;
@


1.75
log
@fix style
@
text
@d1 1
a1 1
/*	$OpenBSD: fileio.c,v 1.74 2006/06/01 05:34:52 jason Exp $	*/
a10 2
#include <sys/dir.h>
#include <sys/resource.h>
d14 1
d19 1
@


1.74
log
@make // /~ path rewriting optional in adjustname() and use it everywhere
except for the command line specified files.  ok kjell,cloder
@
text
@d1 1
a1 1
/*	$OpenBSD: fileio.c,v 1.73 2006/05/03 22:25:34 kjell Exp $	*/
d251 1
a251 1
	if (slashslash) {
@


1.73
log
@correct one more comment
@
text
@d1 1
a1 1
/*	$OpenBSD: fileio.c,v 1.70 2006/04/03 00:40:56 deraadt Exp $	*/
d242 1
a242 1
adjustname(const char *fn)
d245 1
a245 1
	const char	*cp;
d250 15
d445 1
a445 1
		dir = adjustname(buf);
d448 1
a448 1
		dir = adjustname(buf);
@


1.72
log
@Do some KNF, clean up some unused junk that has lying around for 40-odd
cvs revisions, and fix a few comments to match reality
@
text
@d237 3
a239 3
 * The string "fn" is a file name.  Perform any required appending of directory
 * name or case adjustments.  The same file should be referred to even if the
 * working directory changes.
@


1.71
log
@len = strlen(foo); if foo[len - 1]... will do bad things if len == 0.
Avoid, and rearrange a test so it can't (hypothetically) overflow.
@
text
@d11 3
a15 1
#include <sys/resource.h>
d17 2
a18 1
#include "kbd.h"
d20 1
a20 2
#include <sys/stat.h>
#include <sys/dir.h>
a21 1
#include <fcntl.h>
d24 2
a240 10
#ifdef SYMBLINK
#include <sys/types.h>
#include <sys/stat.h>
#ifndef MAXLINK
#define MAXLINK 8		/* maximum symbolic links to follow */
#endif
#endif
#include <pwd.h>
extern char	*wdir;

d409 9
a417 6
	 * We need three different strings: dir - the name of the directory
	 * containing what the user typed. Must be a real unix file name,
	 * e.g. no ~user, etc..  Must not end in /. prefix - the portion of
	 * what the user typed that is before the names we are going to find
	 * in the directory.  Must have a trailing / if the user typed it.
	 * names from the directory. We open dir, and return prefix
@


1.70
log
@lint love; ok kjell
@
text
@d1 1
a1 1
/*	$OpenBSD: fileio.c,v 1.69 2006/04/02 20:21:19 kjell Exp $	*/
d407 2
a408 1
	int		 len, preflen, ret;
d428 1
a428 1
	 * treat foo/.. as a reference to another directory, whereas we are
d432 1
a432 1
	if (buf[len - 1] == '.') {
d444 1
a444 1
	if (buf[0] && buf[strlen(buf) - 1] != '/') {
d472 1
a472 1
	if ((preflen + MAXNAMLEN) > NFILEN)
@


1.69
log
@test char against '\0', not 0
@
text
@d1 1
a1 1
/*	$OpenBSD: fileio.c,v 1.68 2005/12/20 06:17:36 kjell Exp $	*/
d207 1
a207 1
		if (write(to, buf, nread) != nread) {
d354 1
a354 1
	int	ifd, ofd, n;
d358 1
d372 2
a373 2
	while ((n = read(ifd, buf, sizeof(buf))) > 0) {
		if (write(ofd, buf, n) != n) {
d381 1
a381 1
	if (n == -1) {
@


1.68
log
@Clean up the ugly casted frees. In one case, this meant eliminating a nasty
struct/union/casting nightmare when building the list of names for filename
completion. In particular, be consistent about strduping and freeing
the list data.
@
text
@d1 1
a1 1
/*	$OpenBSD: fileio.c,v 1.67 2005/12/20 05:04:28 kjell Exp $	*/
d445 2
a446 2
			*file = 0;
			if (*dir == 0)
@


1.67
log
@Do some delinting of strl-type functions. Also, remove a superfluous
word in the undo-list.
@
text
@d1 1
a1 1
/*	$OpenBSD: fileio.c,v 1.66 2005/12/13 05:40:33 kjell Exp $	*/
a398 5
struct filelist {
	struct list	fl_l;
	char	fl_name[NFILEN + 2];
};

d409 2
a410 2
	struct list		*last;
	struct filelist *current;
d512 5
a516 5
		current = malloc(sizeof(struct filelist));
		if (current == NULL)
			break;

		ret = snprintf(current->fl_name, sizeof(current->fl_name),
d518 1
a518 1
		if (ret < 0 || ret >= sizeof(current->fl_name)) {
d522 3
a524 3
		current->fl_l.l_next = last;
		current->fl_l.l_name = current->fl_name;
		last = (struct list *) current;
@


1.66
log
@do some silly de-linting
@
text
@d1 1
a1 1
/*	$OpenBSD: fileio.c,v 1.65 2005/11/20 18:47:11 kjell Exp $	*/
d457 2
a458 1
	strlcpy(prefixx, buf, sizeof(prefixx));
d461 1
a461 1
		prefixx[0] = 0;
d463 1
a463 1
		cp[1] = 0;
@


1.65
log
@#ifdef NO_DIR can go too. From Han Boetes.
@
text
@d1 1
a1 1
/*	$OpenBSD: fileio.c,v 1.64 2005/11/20 04:16:34 kjell Exp $	*/
d60 1
a60 1
	mode_t	mode = DEFFILEMODE;
d63 1
a63 1
		mode = bp->b_fi.fi_mode & 07777;
d65 1
a65 1
	fd = open(fn, O_RDWR | O_CREAT | O_TRUNC, mode);
d356 1
a356 1
	mode_t	mode = DEFFILEMODE;	/* XXX?? */
d367 1
a367 1
	if ((ofd = open(toname, O_WRONLY|O_CREAT|O_TRUNC, mode)) == -1) {
@


1.64
log
@Kill the NO_BACKUP #ifdef
@
text
@d1 1
a1 1
/*	$OpenBSD: fileio.c,v 1.63 2005/11/20 03:24:17 deraadt Exp $	*/
d234 2
a235 3
 * The string "fn" is a file name.
 * Perform any required appending of directory name or case adjustments.
 * If NO_DIR is not defined, the same file should be referred to even if the
a245 1
#ifndef NO_DIR
a246 1
#endif
@


1.63
log
@toast NO_DIRED #ifdef; ok kjell
@
text
@d1 1
a1 1
/*	$OpenBSD: fileio.c,v 1.62 2005/11/18 20:56:52 deraadt Exp $	*/
a158 1
#ifndef NO_BACKUP
a231 1
#endif
@


1.62
log
@greedy use of typedef struct was making code harder to read; ok kjell cloder
@
text
@d1 1
a1 1
/*	$OpenBSD: fileio.c,v 1.61 2005/11/13 07:49:02 kjell Exp $	*/
a11 1
#ifndef NO_DIRED
a15 1
#endif /* !NO_DIRED */
a40 3
#ifdef NO_DIRED
		return (FIOERR);
#else
a41 1
#endif /* NO_DIRED */
a355 2
#ifndef NO_DIRED

a402 2

#endif				/* NO_DIRED */
@


1.61
log
@Better error checking of snprintfs. From Han Boetes.
@
text
@d1 1
a1 1
/*	$OpenBSD: fileio.c,v 1.60 2005/11/11 18:51:49 kjell Exp $	*/
d31 1
a31 1
ffropen(const char *fn, BUFFER *bp)
d63 1
a63 1
ffwopen(const char *fn, BUFFER *bp)
d104 1
a104 1
ffclose(BUFFER *bp)
d115 1
a115 1
ffputbuf(BUFFER *bp)
d117 1
a117 1
	LINE   *lp, *lpend;
d415 1
a415 1
	LIST	fl_l;
d422 1
a422 1
LIST *
d429 1
a429 1
	LIST		*last;
d543 1
a543 1
		last = (LIST *) current;
@


1.60
log
@Now that we have an editable minibuffer, revert parsing of
"//" and "/~" as '/' and '~' respectively. I know emacs does it,
but it is weird, and breaks things that foolishly use filenames
like "/tmp//crontab.xxxx".
Proddings from matthieu and deraadt. Error report from Bernd Ahlers.
@
text
@d1 1
a1 1
/*	$OpenBSD: fileio.c,v 1.59 2005/11/11 18:40:51 deraadt Exp $	*/
d325 1
d331 2
a332 2
		if (snprintf(file, sizeof(file), "%s/.mg", home)
		    >= sizeof(file))
d335 2
a336 2
		if (snprintf(file, sizeof(file), "%s/.mg-%s", home, suffix)
		    >= sizeof(file))
d345 2
a346 2
		if (snprintf(file, sizeof(file), "%s", STARTUPFILE)
		    >= sizeof(file))
d349 3
a351 2
		if (snprintf(file, sizeof(file), "%s%s", STARTUPFILE, suffix)
		    >= sizeof(file))
d357 1
a357 1
#endif
d360 1
a360 1
#endif
d426 1
a426 1
	int		 len, preflen;
d521 3
a523 2
			if (snprintf(statname, sizeof(statname), "%s/%s",
			    dir, dent->d_name) > sizeof(statname) - 1) {
a524 1
			}
d535 3
a537 3
		if (snprintf(current->fl_name, sizeof(current->fl_name),
		    "%s%s%s", prefixx, dent->d_name, isdir ? "/" : "")
		    >= sizeof(current->fl_name)) {
@


1.59
log
@spacing
@
text
@d1 1
a1 1
/*	$OpenBSD: fileio.c,v 1.58 2005/10/18 04:07:06 kjell Exp $	*/
d263 1
a263 1
	const char	*cp, *ep = NULL;
a267 13

	cp = fn + strlen(fn) - 1;
	for (; cp >= fn; cp--) {
		if (ep && (*cp == '/')) {
			fn = ep;
			break;
		}
		if (*cp == '/' || *cp == '~')
			ep = cp;
		else
			ep = NULL;
	}

@


1.58
log
@When attempting to open a filename, walk backwards through minibuffer:
a> if you run into the beginning of the string, use the whole thing
b> if you run into a // combo, use everything starting from the second /
c> if you run into a /~ combo, use everything starting from the ~
i.e. do like emacs.
From (and for) Jason Wright
@
text
@d1 1
a1 1
/*	$OpenBSD: fileio.c,v 1.57 2005/10/17 14:54:03 kjell Exp $	*/
d295 1
a295 1
		else { /* ~user/ or ~user */ 
@


1.57
log
@Fix string handling. LOGIN_NAME_MAX includes the NUL, so don't reserve extra
space. Fix usage of strlcpy. Correct test for terminating slash.

"looks good" deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: fileio.c,v 1.56 2005/10/14 15:41:50 deraadt Exp $	*/
d263 1
a263 1
	const char	*cp;
d268 13
@


1.56
log
@more headers to please lint
@
text
@d1 1
a1 1
/*	$OpenBSD: fileio.c,v 1.55 2005/10/14 06:41:47 kjell Exp $	*/
d264 2
a265 2
	char		 user[LOGIN_NAME_MAX + 1], path[MAXPATHLEN];
	int		 len;
d275 3
a277 3

		if ((cp - &fn[1]) > LOGIN_NAME_MAX) {
			ewprintf("login name too long");
d280 6
a285 4
		if (cp == &fn[1]) /* ~/ */
			strlcpy(user, getlogin(), sizeof(user));
		else
			strlcpy(user, &fn[1], cp - &fn[1] + 1);
d288 1
a288 1
			ewprintf("unknown user %s", user);
d291 6
a296 5
		strlcpy(path, pw->pw_dir, sizeof(path) - 1);
		len = strlen(path);
		if (path[len] != '/') {
			path[len] = '/';
			path[len + 1] = '\0';
d302 4
a305 1
	strlcat(path, fn, sizeof(path));
d308 1
a308 1
		strlcpy(fnb, path, sizeof(fnb));
@


1.55
log
@move the dired routines into dired.c where they belong.
ok cloder@@
@
text
@d1 1
a1 1
/*	$OpenBSD: fileio.c,v 1.54 2005/10/13 20:23:01 kjell Exp $	*/
d10 2
d13 2
a17 2

#include <sys/types.h>
@


1.54
log
@Make dired buffer read-only by default.
Noticed by Han Boetes
@
text
@d1 1
a1 1
/*	$OpenBSD: fileio.c,v 1.53 2005/10/13 19:46:45 kjell Exp $	*/
a21 1
#include <ctype.h>
a401 84
/*
 * dirname needs to have enough place to store an additional '/'.
 */
BUFFER *
dired_(char *dirname)
{
	BUFFER	*bp;
	FILE	*dirpipe;
	char	 line[256];
	int	 len;

	if ((dirname = adjustname(dirname)) == NULL) {
		ewprintf("Bad directory name");
		return (NULL);
	}
	/* this should not be done, instead adjustname() should get a flag */
	len = strlen(dirname);
	if (dirname[len - 1] != '/') {
		dirname[len++] = '/';
		dirname[len] = '\0';
	}
	if ((bp = findbuffer(dirname)) == NULL) {
		ewprintf("Could not create buffer");
		return (NULL);
	}
	if (bclear(bp) != TRUE)
		return (NULL);
	bp->b_flag |= BFREADONLY;
	if (snprintf(line, sizeof(line), "ls -al %s", dirname)
	    >= sizeof(line)) {
		ewprintf("Path too long");
		return (NULL);
	}
	if ((dirpipe = popen(line, "r")) == NULL) {
		ewprintf("Problem opening pipe to ls");
		return (NULL);
	}
	line[0] = line[1] = ' ';
	while (fgets(&line[2], sizeof(line) - 2, dirpipe) != NULL) {
		line[strlen(line) - 1] = '\0';	/* remove ^J	 */
		(void) addline(bp, line);
	}
	if (pclose(dirpipe) == -1) {
		ewprintf("Problem closing pipe to ls : %s",
		    strerror(errno));
		return (NULL);
	}
	bp->b_dotp = lforw(bp->b_linep);	/* go to first line */
	(void) strlcpy(bp->b_fname, dirname, sizeof(bp->b_fname));
	if ((bp->b_modes[1] = name_mode("dired")) == NULL) {
		bp->b_modes[0] = name_mode("fundamental");
		ewprintf("Could not find mode dired");
		return (NULL);
	}
	bp->b_nmodes = 1;
	return (bp);
}

#define NAME_FIELD	8

int
d_makename(LINE *lp, char *fn, int len)
{
	int	 i;
	char	*p, *ep;

	strlcpy(fn, curbp->b_fname, len);
	if ((p = lp->l_text) == NULL)
		return (ABORT);
	ep = lp->l_text + llength(lp);
	p++; /* skip action letter, if any */
	for (i = 0; i < NAME_FIELD; i++) {
		while (p < ep && isspace(*p))
			p++;
		while (p < ep && !isspace(*p))
			p++;
		while (p < ep && isspace(*p))
			p++;
		if (p == ep)
			return (ABORT);
	}
	strlcat(fn, p, len);
	return ((lgetc(lp, 2) == 'd') ? TRUE : FALSE);
}
@


1.53
log
@Use dired mode automatically if file specified for loading is
a directory. Modified version of patch from Han Boetes.
ok cloder@@
@
text
@d1 1
a1 1
/*	$OpenBSD: fileio.c,v 1.52 2005/10/13 05:59:19 kjell Exp $	*/
d41 1
a41 1
	if ((stat(fn, &statbuf) == 0) && S_ISDIR(statbuf.st_mode))
d623 18
@


1.52
log
@check if current line is null. fixes a core in dired.
@
text
@d1 1
a1 1
/*	$OpenBSD: fileio.c,v 1.51 2005/10/13 05:47:45 kjell Exp $	*/
d10 5
d39 9
d54 1
a353 2
#include <sys/wait.h>
#include "kbd.h"
@


1.51
log
@Fix dired mode. Make deletions work, and keystrokes match emacs.
* dired-other-window should default to current buffer's path.
* Remove redundant code (from Han Boetes)
* Move initialization (and since we're here, fix mail-mode initialization
  too)
* Remove redundant keymap in dired.c, and replace it with
  the better one that was being ignored in keymap.c.
@
text
@d1 1
a1 1
/*	$OpenBSD: fileio.c,v 1.50 2005/06/14 18:14:40 kjell Exp $	*/
d457 2
a458 1
	p = lp->l_text;
@


1.50
log
@Add explicit public domain notices to all public domain files.
ok millert@@, deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: fileio.c,v 1.49 2005/04/03 02:09:28 db Exp $	*/
d459 1
@


1.49
log
@This is a no binary change which does:

- spelling, punctuation fixes
- variable declaration lineup
- use parentheses for return and sizeof
- K&R function declarations -> ANSI
- other minor code beautification

ok henning@@
@
text
@d1 3
a3 1
/*	$OpenBSD: fileio.c,v 1.48 2005/03/10 16:58:57 deraadt Exp $	*/
@


1.48
log
@spacing
@
text
@d1 1
a1 1
/*	$OpenBSD: fileio.c,v 1.47 2005/03/10 16:46:24 henning Exp $	*/
d6 1
a6 3
#include	"def.h"

static FILE	*ffp;
d17 2
a42 2
 * Return TRUE if all is well, and
 * FALSE on error (cannot create).
d47 2
a48 2
	int fd;
	mode_t mode = DEFFILEMODE;
a87 1

d105 1
a105 1
			return FIOERR;
d137 1
a137 1
			return FIOLONG;
d141 1
a141 1
		return FIOERR;
d144 1
a144 1
	return c == EOF ? FIOEOF : FIOSUC;
d159 4
a162 4
	struct stat	sb;
	int		from, to, serrno;
	ssize_t		nread;
	char		buf[BUFSIZ];
d244 4
a247 4
	static char fnb[MAXPATHLEN];
	const char *cp;
	char user[LOGIN_NAME_MAX + 1], path[MAXPATHLEN];
	int len;
d263 1
a263 1
			strlcpy(user, getlogin(), sizeof user);
d271 1
a271 1
		strlcpy(path, pw->pw_dir, sizeof path - 1);
d281 1
a281 1
	strlcat(path, fn, sizeof path);
d299 1
a299 1
	static char	file[NFILEN];
d343 4
a346 4
	int ifd, ofd, n;
	char buf[BUFSIZ];
	mode_t mode = DEFFILEMODE;	/* XXX?? */
	struct stat orig;
d360 1
a360 1
	while ((n = read(ifd, buf, sizeof buf)) > 0) {
d377 1
a377 1
	 * we will be running as root
d396 2
a397 2
	char	line[256];
	int	len;
d401 1
a401 1
		return NULL;
d411 1
a411 1
		return NULL;
d414 1
a414 1
		return NULL;
d419 1
a419 1
		return NULL;
d423 1
a423 1
		return NULL;
d433 1
a433 1
		return NULL;
d436 1
a436 1
	(void) strlcpy(bp->b_fname, dirname, sizeof bp->b_fname);
d440 1
a440 1
		return NULL;
d443 1
a443 1
	return bp;
d451 2
a452 2
	int i;
	char *p, *ep;
d468 1
a468 1
	return (lgetc(lp, 2) == 'd') ? TRUE : FALSE;
a479 1

d484 1
a484 1
	int		len, preflen;
d489 1
a489 1
	char		prefixx[NFILEN + 1];
d497 1
a497 1
	 * names from the directory. we open dir, and return prefix
d526 1
a526 1
		} else {
a527 1
		}
d530 1
a530 1
	strlcpy(prefixx, buf, sizeof prefixx);
d538 1
a538 1
	/* cp is the tail of buf that really needs to be compared */
@


1.47
log
@the realpath() was needed to do do relative to absolute path
conversion. revert my diff that takes it out, and instead, on
realpath() failure (like when you have no perms on pwd) just return the
unexpanded path. everything still fine with that, just tab completeion
and the like does not work (obviously).
this was mainly for "sudo mg /etc/something" from ~ where ~ is
nfs-mounted with root mapped to -2
and now, that case works as well as tab completion on insert-file etc.
@
text
@d1 1
a1 1
/*	$OpenBSD: fileio.c,v 1.42 2004/07/09 13:50:40 vincent Exp $	*/
d112 1
a112 1
	}	
@


1.46
log
@fix mg's behaviour with regards to files on which we do not have
write access.  diff originally from vincent@@ and forgotten for
a while.

ok rohee@@, "toss it in, i'll bitch if it doesn't work" henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: fileio.c,v 1.45 2005/02/01 16:04:15 henning Exp $	*/
d247 1
a247 1
	static char path[MAXPATHLEN];
d249 1
a249 1
	char user[LOGIN_NAME_MAX + 1];
d286 4
a289 1
	return (path);
@


1.45
log
@make fbackupfile() return FALSE when the rename(2) from the
mkstemp()-derived name to the filename~ one fails
From: Han Boetes <han@@mijncomputer.nl>
@
text
@d1 1
a1 1
/*	$OpenBSD: fileio.c,v 1.44 2005/01/31 15:48:00 millert Exp $	*/
d27 5
a31 2
	if ((ffp = fopen(fn, "r")) == NULL)
		return (FIOFNF);
@


1.44
log
@Safer backup file generation using mkstemp(); henning@@ OK
@
text
@d1 1
a1 1
/*	$OpenBSD: fileio.c,v 1.43 2005/01/11 17:19:16 henning Exp $	*/
d212 1
@


1.43
log
@no need to call realpath() in adjustname()
realpath returns an error if cwd is not writeable, and that is quite common
with NFS-mounted ~ and sudo mg /etc/something - annoying as hell. realpath
is not needed at all here, so zap it. vincent ok
@
text
@d1 1
a1 1
/*	$OpenBSD: fileio.c,v 1.42 2004/07/09 13:50:40 vincent Exp $	*/
d163 1
a163 1
	char		*nname;
d171 7
a177 2
		ewprintf("Can't allocate temp file name : %s",
		    strerror(errno));
d183 1
d186 1
a186 1
	to = open(nname, O_WRONLY|O_CREAT|O_TRUNC, (sb.st_mode & 0777));
d191 1
d202 1
d206 1
a206 1
		if (unlink(nname) == -1)
d208 5
d215 1
@


1.42
log
@when saving a file, check whether it is newline terminated and if it is not,
prompt the user and add the newline if he agrees.

tested by a lot of helpful tech@@ guys, approved by henning
@
text
@d1 1
a1 1
/*	$OpenBSD: fileio.c,v 1.41 2004/07/08 20:48:50 vincent Exp $	*/
d229 1
a229 1
	static char fnb[MAXPATHLEN];
d231 1
a231 1
	char user[LOGIN_NAME_MAX + 1], path[MAXPATHLEN];
d268 1
a268 1
	return (realpath(path, fnb));
@


1.41
log
@simplify the file writing loop

looked at by ian, tested on i386, macppc, sparc64
@
text
@d1 1
a1 1
/*	$OpenBSD: fileio.c,v 1.40 2003/11/14 22:41:33 vincent Exp $	*/
d110 9
@


1.40
log
@read(2) returns ssize_t, not size_t.  spotted by Andrey Matveev.
@
text
@d1 1
a1 1
/*	$OpenBSD: fileio.c,v 1.39 2003/11/08 19:17:29 jmc Exp $	*/
d93 1
a93 2
 * Write a buffer to the already
 * opened file. bp points to the
a94 2
 * Check only at the newline and
 * end of buffer.
d99 1
a99 4
	char   *cp;
	char   *cpend;
	LINE   *lp;
	LINE   *lpend;
d102 4
a105 8
	lp = lforw(lpend);
	do {
		cp = &ltext(lp)[0];		/* beginning of line	 */
		cpend = &cp[llength(lp)];	/* end of line		 */
		while (cp != cpend) {
			putc(*cp, ffp);
			cp++;			/* putc may evaluate arguments
						   more than once */
d107 3
a109 9
		lp = lforw(lp);
		if (lp == lpend)
			break;			/* no implied \n on last line */
		putc('\n', ffp);
	} while (!ferror(ffp));
	if (ferror(ffp)) {
		ewprintf("Write I/O error");
		return FIOERR;
	}
@


1.39
log
@typos from Jonathon Gray;
@
text
@d1 1
a1 1
/*	$OpenBSD: fileio.c,v 1.38 2003/08/15 23:23:18 vincent Exp $	*/
d168 1
a168 1
	size_t		nread;
d197 2
a198 2
		    nread = -1;
		    break;
@


1.38
log
@make dired work more like emacs. (well, make it _work_, and then add a
bunch of missing commands)
@
text
@d1 1
a1 1
/*	$OpenBSD: fileio.c,v 1.37 2003/08/15 23:09:57 vincent Exp $	*/
d218 1
a218 1
 * If NO_DIR is not defined, the same file should be refered to even if the
@


1.37
log
@ actually extract the filename off the ls line. makes dired *slightly*
more useful.
@
text
@d1 1
a1 1
/*	$OpenBSD: fileio.c,v 1.36 2003/05/08 12:37:13 vincent Exp $	*/
d405 2
a406 1
	if (snprintf(line, sizeof(line), "ls -al %s", dirname) >= sizeof(line)){
d420 2
a421 1
		ewprintf("Problem closing pipe to ls");
d426 1
a426 1
	if ((bp->b_modes[0] = name_mode("dired")) == NULL) {
d431 1
a431 1
	bp->b_nmodes = 0;
d457 1
a457 1
	return lgetc(lp, 2) == 'd';
@


1.36
log
@use NULL to indicate failure in functions that return pointers, not FALSE.
typo in comment

from Patrick Latifi (patrick.l@@hermes.usherb.ca)
@
text
@d1 1
a1 1
/*	$OpenBSD: fileio.c,v 1.35 2003/05/06 10:45:07 vincent Exp $	*/
d17 1
d439 1
a439 1
	char *p, *np;
d443 1
d445 1
a445 5
		np = strpbrk(p, "\t ");
		if (np == NULL)
			return ABORT;
		p = np + 1;
		while (*p != '\0' && strchr("\t ", *p))
d447 6
@


1.35
log
@fix a small memleak on errors. noticed by pat latifi.

ok millert, fgsch
@
text
@d1 1
a1 1
/*	$OpenBSD: fileio.c,v 1.34 2002/08/22 23:28:19 deraadt Exp $	*/
d109 1
a109 1
		cp = &ltext(lp)[0];		/* begining of line	 */
d402 1
a402 1
		return FALSE;
d499 1
a499 1
		return (FALSE);
@


1.34
log
@knf
@
text
@d1 1
a1 1
/*	$OpenBSD: fileio.c,v 1.33 2002/07/25 16:37:54 vincent Exp $	*/
d171 5
a179 4
	}
	if (stat(fn, &sb) == -1) {
		ewprintf("Can't stat %s : %s", fn, strerror(errno));
		return (FALSE);
@


1.33
log
@ replace the ugly and buggy adjustname function by a simple one using
simple APIs. makes mg not crash with 65k filenames...

 ok art@@
@
text
@d1 1
a1 1
/*	$OpenBSD: fileio.c,v 1.32 2002/07/01 17:20:04 vincent Exp $	*/
d56 1
a56 1
	}		
d61 1
a61 1
		return (FIOERR);	
@


1.32
log
@KNF
@
text
@d1 1
a1 1
/*	$OpenBSD: fileio.c,v 1.31 2002/06/21 05:37:20 vincent Exp $	*/
d11 1
d234 13
a246 9
	char		*cp;
	static char	fnb[NFILEN];
	struct passwd	*pwent;
#ifdef	SYMBLINK
	struct stat	statbuf;
	int		i, j;
	char		linkbuf[NFILEN];
#endif
	int n;
d248 18
a265 32
	switch (*fn) {
	case '/':
		cp = fnb;
		*cp++ = *fn++;
		break;
	case '~':
		fn++;
		cp = getenv("HOME");
		if (cp != NULL && *cp != '\0' &&
		    (*fn == '/' || *fn == '\0')) {
			n = strlcpy(fnb, cp, sizeof fnb);
			if (n >= sizeof fnb)
				n = sizeof fnb - 1;
			cp = fnb + n;
			if (*fn)
				fn++;
			break;
		} else {
			cp = fnb;
			while (*fn && *fn != '/')
				*cp++ = *fn++;
			*cp = '\0';
			if ((pwent = getpwnam(fnb)) != NULL) {
				n = strlcpy(fnb, pwent->pw_dir, sizeof fnb);
				if (n >= sizeof fnb)
					n = sizeof fnb - 1;
				cp = fnb + n;
				break;
			} else {
				fn -= strlen(fnb) + 1;
				/* can't find ~user, continue to default case */
			}
d267 2
a268 66
	default:
#ifndef	NODIR
		n = strlcpy(fnb, wdir, sizeof fnb);
		if (n >= sizeof fnb)
			n = sizeof fnb - 1;
		cp = fnb + n;
		break;
#else
		return fn;	/* punt */
#endif
	}
	if (cp != fnb && cp[-1] != '/')
		*cp++ = '/';
	while (*fn) {
		switch (*fn) {
		case '.':
			switch (fn[1]) {
			case '\0':
				*--cp = '\0';
				return fnb;
			case '/':
				fn += 2;
				continue;
			case '.':
				if (fn[2] != '/' && fn[2] != '\0')
					break;
#ifdef SYMBLINK
				cp[-1] = '\0';
				for (j = MAXLINK; j-- &&
				     lstat(fnb, &statbuf) != -1 &&
				     (statbuf.st_mode & S_IFMT) == S_IFLNK &&
				     (i = readlink(fnb, linkbuf, sizeof linkbuf))
				     != -1;) {
					if (linkbuf[0] != '/') {
						--cp;
						while (cp > fnb && *--cp != '/')
							;
						++cp;
						(void) strncpy(cp, linkbuf, i);
						cp += i;
					} else {
						(void) strncpy(fnb, linkbuf, i);
						cp = fnb + i;
					}
					if (cp[-1] != '/')
						*cp++ = '\0';
					else
						cp[-1] = '\0';
				}
				cp[-1] = '/';
#endif
				--cp;
				while (cp > fnb && *--cp != '/')
					;
				++cp;
				if (fn[2] == '\0') {
					*--cp = '\0';
					return fnb;
				}
				fn += 3;
				continue;
			default:
				break;
			}
			break;
		case '/':
a269 6
			continue;
		default:
			break;
		}
		while (*fn && (*cp++ = *fn++) != '/')
			;
d271 3
a273 4
	if (cp[-1] == '/')
		--cp;
	*cp = '\0';
	return fnb;
d497 2
@


1.31
log
@fix bad usage of strlcpy()'s return value. (made pointers point
beyond the boundaries of buffers)

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: fileio.c,v 1.30 2002/04/22 05:27:39 vincent Exp $	*/
d374 2
a375 2
			    >= sizeof(file))
			return NULL;
d378 2
a379 2
			    >= sizeof(file))
			return NULL;
d383 1
a383 1
		return file;
d388 2
a389 2
			    >= sizeof(file))
			return NULL;
d392 2
a393 2
			    >= sizeof(file))
			return NULL;
d397 1
a397 1
		return file;
d399 1
a399 1
	return NULL;
d443 1
a443 1
	 * It is "normal" for this to fail since we can't garantee that
@


1.30
log
@ don't use /bin/cp to copy files.

 ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: fileio.c,v 1.28 2002/04/15 23:24:42 deraadt Exp $	*/
d241 1
d251 6
a256 2
		if (cp != NULL && *cp != '\0' && (*fn == '/' || *fn == '\0')) {
			cp = fnb + strlcpy(fnb, cp, sizeof(fnb));
d266 4
a269 1
				cp = fnb + strlcpy(fnb, pwent->pw_dir, sizeof(fnb));
d278 4
a281 1
		cp = fnb + strlcpy(fnb, wdir, sizeof(fnb));
d518 1
a518 1
	
@


1.29
log
@ fix mem leak

 ok deraadt@@
@
text
@a176 1
		free(nname);
d194 2
a195 2
			nread = -1;
			break;
d399 25
a423 2
	pid_t	pid;
	int	status;
d425 5
a429 9
	switch ((pid = vfork())) {
	case -1:
		return -1;
	case 0:
		execl("/bin/cp", "cp", frname, toname, (char *)NULL);
		_exit(1);	/* shouldn't happen */
	default:
		waitpid(pid, &status, 0);
		return (WIFEXITED(status) && WEXITSTATUS(status) == 0);
d431 11
@


1.28
log
@use fchmod and fchown instead; vincent
@
text
@d1 1
a1 1
/*	$OpenBSD: fileio.c,v 1.27 2002/03/27 17:42:37 millert Exp $	*/
d177 1
d195 2
a196 2
		    nread = -1;
		    break;
@


1.27
log
@Fixes the the following problems (from zyrnix)
1) Mg crashes with column width of 1, rows > 2
2) Mg panics on resizing due to incomplete write
3) Mg doesn't compile with STARTUPFILE defined
deraadt@@ OK
@
text
@d1 1
a1 1
/*	$OpenBSD: fileio.c,v 1.26 2002/03/16 19:30:29 vincent Exp $	*/
d71 2
a72 2
		chmod(fn, bp->b_fi.fi_mode & 07777);
		chown(fn, bp->b_fi.fi_uid, bp->b_fi.fi_gid);
@


1.26
log
@ Make these special buffers readonly by default. ok art@@
@
text
@d1 1
a1 1
/*	$OpenBSD: fileio.c,v 1.25 2002/03/11 13:02:56 vincent Exp $	*/
d300 2
a301 2
						while (cp > fnb && *--cp != '/') {
						}
d336 2
a337 2
		while (*fn && (*cp++ = *fn++) != '/') {
		}
d353 1
a353 2
startupfile(suffix)
	char	*suffix;
d375 1
a375 1
	if (suffix == NULL)
d397 1
a397 3
copy(frname, toname)
	char	*frname;
	char	*toname;
d418 1
a418 2
dired_(dirname)
	char	*dirname;
@


1.25
log
@  * Move to ANSI function definitions.
  * Add a whole lot of consts where I thought it made sense

   no ok, but no objections either...
@
text
@d1 1
a1 1
/*	$OpenBSD: fileio.c,v 1.24 2002/02/22 00:18:37 deraadt Exp $	*/
d417 3
d445 1
@


1.24
log
@if file mode known, try to avoid a race.. i think.  millert spotted a bug in my first draft
@
text
@d1 1
a1 1
/*	$OpenBSD: fileio.c,v 1.23 2002/02/14 22:58:20 vincent Exp $	*/
d21 1
a21 3
ffropen(fn, bp)
	char	*fn;
	BUFFER	*bp;
d42 1
a42 3
ffwopen(fn, bp)
	char   *fn;
	BUFFER *bp;
d83 1
a83 2
ffclose(bp)
	BUFFER *bp;
d98 1
a98 2
ffputbuf(bp)
	BUFFER *bp;
d134 1
a134 4
ffgetline(buf, nbuf, nbytes)
	char	*buf;
	int	nbuf;
	int	*nbytes;
d162 1
a162 2
fbackupfile(fn)
	char  *fn;
d231 1
a231 2
adjustname(fn)
	char	*fn;
d503 1
a503 2
make_file_list(buf)
	char	*buf;
@


1.23
log
@d_makename now takes a length parameter so we can remove the
strcpy call.
@
text
@d1 1
a1 1
/*	$OpenBSD: fileio.c,v 1.22 2002/02/14 14:24:21 deraadt Exp $	*/
d48 2
d51 6
a56 1
	if ((ffp = fopen(fn, "w")) == NULL) {
d59 6
d70 1
a70 1
	 * trying to change ownership will fail if we aren' root.  That's
@


1.22
log
@some KNF
@
text
@d1 1
a1 1
/*	$OpenBSD: fileio.c,v 1.21 2002/02/13 03:03:49 vincent Exp $	*/
a13 1
#include <errno.h>
d468 2
d471 1
a471 3
d_makename(lp, fn)
	LINE  *lp;
	char  *fn;
d473 14
a486 8
	char  *cp;

	if (llength(lp) <= 56)
		return ABORT;
	(void) strcpy(fn, curbp->b_fname);
	cp = fn + strlen(fn);
	bcopy(&lp->l_text[56], cp, llength(lp) - 56);
	cp[llength(lp) - 56] = '\0';
@


1.21
log
@ * Replace unsafe strcpy and strcat calls to safe strlcpy and strlcat.
 * Be a little bit more verbose about some errors
 * Fix some memory leaks in fileio.c

ok deraadt@@, art@@
@
text
@d1 1
a1 1
/*	$OpenBSD: fileio.c,v 1.20 2001/09/21 15:08:16 wilfried Exp $	*/
d205 1
a205 1
	
@


1.20
log
@correct fork logic and rewrite for clarity, ok todd@@
@
text
@d1 1
a1 1
/*	$OpenBSD: fileio.c,v 1.19 2001/07/09 07:04:49 deraadt Exp $	*/
d13 1
d51 1
a51 1
		ewprintf("Cannot open file for writing");
a164 1
	size_t		len;
d168 3
a170 3
	len = strlen(fn);
	if ((nname = malloc(len + 1 + 1)) == NULL) {
		ewprintf("Can't get %d bytes", len + 1 + 1);
a172 3
	(void) strcpy(nname, fn);
	(void) strcpy(nname + len, "~");

d174 1
a174 1
		ewprintf("Can't stat %s", fn);
d178 2
a179 1
	if ((from = open(fn, O_RDONLY)) == -1)
d181 1
d186 1
d199 4
a202 2
	if (nread == -1)
		unlink(nname);
d205 1
d316 2
a317 2
				while (cp > fnb && *--cp != '/') {
				}
d459 1
a459 1
	(void) strncpy(bp->b_fname, dirname, NFILEN);
d545 1
a545 1
	strcpy(prefixx, buf);
@


1.19
log
@correct type on last arg to execl(); nordin@@cse.ogi.edu
@
text
@d1 1
a1 1
/*	$OpenBSD: fileio.c,v 1.18 2001/07/06 13:32:45 art Exp $	*/
d401 4
a404 3
	if ((pid = vfork())) {
		if (pid == -1)
			return -1;
d407 3
a410 2
	waitpid(pid, &status, 0);
	return (WIFEXITED(status) && WEXITSTATUS(status) == 0);
@


1.18
log
@Change the filename completion code to:
 - not use an unprotected strcat.
 - Append a '/' when a file is a symlink to a directory.
   (tab completion on '/sys' is now less annoying.)
 - actually make some more sense.
@
text
@d1 1
a1 1
/*	$OpenBSD: fileio.c,v 1.17 2001/05/24 10:19:51 art Exp $	*/
d404 1
a404 1
		execl("/bin/cp", "cp", frname, toname, NULL);
@


1.17
log
@Don't assume that map_table[0] is the fundamental map.
@
text
@d1 1
a1 1
/*	$OpenBSD: fileio.c,v 1.16 2001/05/24 03:05:22 mickey Exp $	*/
a500 2
	struct stat	statbuf;
	char		statname[NFILEN + 2];
d575 2
d580 20
a599 1
		current = (struct filelist *) malloc(sizeof(struct filelist));
d602 1
d604 2
a605 2
		    "%s%s%s", prefixx, dent->d_name, dent->d_type == DT_DIR?
		    "/" : "") >= sizeof(current->fl_name)) {
a611 12
		if (dent->d_type != DT_UNKNOWN)
			continue;

		statbuf.st_mode = 0;
		if (snprintf(statname, sizeof(statname), "%s/%s",
		    dir, dent->d_name) > sizeof(statname) - 1) {
			continue;
		}
		if (stat(statname, &statbuf) < 0)
			continue;
		if (statbuf.st_mode & S_IFDIR)
			strcat(current->fl_name, "/");
@


1.16
log
@spaces
@
text
@d1 1
a1 1
/*	$OpenBSD: fileio.c,v 1.15 2001/05/24 00:59:38 mickey Exp $	*/
d456 1
a456 1
		bp->b_modes[0] = &map_table[0];
@


1.15
log
@use strlcpy vs cpy+len, some other fixes
@
text
@d1 1
a1 1
/*	$OpenBSD: fileio.c,v 1.14 2001/05/23 22:36:14 art Exp $	*/
d8 1
a8 1
static FILE    *ffp;
d22 2
a23 2
	char           *fn;
	BUFFER         *bp;
d25 1
a25 1
	struct stat     statbuf;
d128 3
a130 3
	char  *buf;
	int    nbuf;
	int   *nbytes;
d132 1
a132 2
	int    c;
	int    i;
d161 6
a166 6
	struct stat sb;
	int    from, to, serrno;
	size_t nread;
	size_t len;
	char   buf[BUFSIZ];
	char  *nname;
d222 1
a222 1
extern char    *wdir;
d227 1
a227 1
	char           *fn;
d229 3
a231 3
	char           *cp;
	static char     fnb[NFILEN];
	struct passwd  *pwent;
d233 3
a235 3
	struct stat     statbuf;
	int             i, j;
	char            linkbuf[NFILEN];
d350 1
a350 1
	char           *suffix;
d352 2
a353 2
	static char     file[NFILEN];
	char           *home;
d395 2
a396 2
	char   *frname;
	char   *toname;
d398 2
a399 2
	pid_t   pid;
	int     status;
d413 1
a413 1
	char   *dirname;
d415 3
a417 3
	BUFFER *bp;
	FILE   *dirpipe;
	char    line[256];
d482 2
a483 2
	LIST            fl_l;
	char            fl_name[NFILEN + 2];
d492 1
a492 1
	char           *buf;
d494 5
a498 5
	char           *dir, *file, *cp;
	int             len, preflen;
	DIR	       *dirp;
	struct dirent  *dent;
	LIST           *last;
d500 3
a502 3
	char            prefixx[NFILEN + 1];
	struct stat     statbuf;
	char            statname[NFILEN + 2];
@


1.14
log
@Get rid of unnecessary casts of NULL.
@
text
@d1 1
a1 1
/*	$OpenBSD: fileio.c,v 1.13 2001/05/23 22:20:35 art Exp $	*/
d248 1
a248 2
			(void) strcpy(fnb, cp);
			cp = fnb + strlen(fnb);
d258 1
a258 2
				(void) strcpy(fnb, pwent->pw_dir);
				cp = fnb + strlen(fnb);
d267 1
a267 2
		strcpy(fnb, wdir);
		cp = fnb + strlen(fnb);
d419 1
d425 6
a430 2
	if (dirname[strlen(dirname) - 1] != '/')
		(void) strcat(dirname, "/");
d437 4
a440 2
	(void) strcpy(line, "ls -al ");
	(void) strcpy(&line[7], dirname);
d446 1
a446 1
	while (fgets(&line[2], 254, dirpipe) != NULL) {
d585 2
a586 1
		    "%s%s", prefixx, dent->d_name) > sizeof(current->fl_name)) {
d593 1
a593 4
		if (dent->d_type == DT_DIR) {
			strcat(current->fl_name, "/");
			continue;
		} else if (dent->d_type != DT_UNKNOWN)
d603 1
a603 1
		if (statbuf.st_mode & 040000)
@


1.13
log
@remove VOID. We're way beyond the point where this could build with an
ancient compiler.
@
text
@d1 1
a1 1
/*	$OpenBSD: fileio.c,v 1.12 2001/05/03 12:57:22 art Exp $	*/
d408 1
a408 1
		execl("/bin/cp", "cp", frname, toname, (char *) NULL);
@


1.12
log
@ * Let make_file_list always append a '/' at the end of directories.
   This makes filename TAB-completion more useful, now you don't need to
   write that '/' manually.
 * random cleanups including using snprintf and memcmp where open-coded
   equivalents were used, waitpid instead of 'while (wait() != pid);', etc.
@
text
@d1 1
a1 1
/*	$OpenBSD: fileio.c,v 1.11 2001/05/01 13:26:59 art Exp $	*/
d78 1
a78 1
	(VOID) fclose(ffp);
d248 1
a248 1
			(VOID) strcpy(fnb, cp);
d259 1
a259 1
				(VOID) strcpy(fnb, pwent->pw_dir);
d303 1
a303 1
						(VOID) strncpy(cp, linkbuf, i);
d306 1
a306 1
						(VOID) strncpy(fnb, linkbuf, i);
d428 1
a428 1
		(VOID) strcat(dirname, "/");
d435 2
a436 2
	(VOID) strcpy(line, "ls -al ");
	(VOID) strcpy(&line[7], dirname);
d444 1
a444 1
		(VOID) addline(bp, line);
d451 1
a451 1
	(VOID) strncpy(bp->b_fname, dirname, NFILEN);
d470 1
a470 1
	(VOID) strcpy(fn, curbp->b_fname);
@


1.11
log
@Use opendir/readdir instead of open/read when making a file list.
This makes filename tab-completion work and takes dired a step further.
@
text
@d1 1
a1 1
/*	$OpenBSD: fileio.c,v 1.10 2001/01/29 01:58:07 niklas Exp $	*/
a345 2
#include <sys/file.h>

d356 5
a360 2
	char           *file;
	static char     home[NFILEN];
d362 8
a369 21
	if ((file = getenv("HOME")) == NULL || *file == '\0')
		goto notfound;
	if (strlen(file) + 7 >= NFILEN - 1)
		goto notfound;
	(VOID) strcpy(home, file);
	(VOID) strcat(home, "/.mg");
	if (suffix != NULL) {
		(VOID) strcat(home, "-");
		(VOID) strcat(home, suffix);
	}
	if (access(home, F_OK) == 0)
		return home;

notfound:
#ifdef	STARTUPFILE
	file = STARTUPFILE;
	if (suffix != NULL) {
		(VOID) strcpy(home, file);
		(VOID) strcat(home, "-");
		(VOID) strcat(home, suffix);
		file = home;
d371 16
a386 1
	if (access(file, F_OK) == 0)
a388 1

d411 2
a412 2
	while (wait(&status) != pid);
	return status == 0;
a484 4
 * System V version.  listing is a flag indicating whether the
 * list is being used for printing a listing rather than
 * completion.  In that case, trailing * and / are put on
 * for executables and directories.  The list is not sorted.
d488 1
a488 1
make_file_list(buf, listing)
a489 1
	int             listing;
a557 2
	if ((strlen(dir) + MAXNAMLEN) > NFILEN)
		listing = 0;
d578 2
d588 5
a592 6
		if (listing) {
			if (dent->d_type == DT_DIR) {
				strcat(current->fl_name, "/");
				continue;
			} else if (dent->d_type != DT_UNKNOWN)
				continue;
d594 4
a597 9
			statbuf.st_mode = 0;
			if (snprintf(statname, sizeof(statname), "%s/%s",
			    dir, dent->d_name) > sizeof(statname) - 1) {
				continue;
			}
			if (stat(statname, &statbuf) < 0)
				continue;
			if (statbuf.st_mode & 040000)
				strcat(current->fl_name, "/");
d599 4
@


1.10
log
@$OpenBSD$
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
a481 7
 * these things had better be contiguous, because we're going to refer to the
 * end of dirbuf + 1 byte
 */
struct dirent   dirbuf;
char            dirdummy;

/*
d495 3
a497 2
	int             len, i, preflen;
	int             fp;
d573 2
a574 2
	fp = open(dir, 0);
	if (fp < 0) {
a575 1
	}
d577 9
a585 7
	/* clear entry after last so we can treat d_name as ASCIZ */
	dirbuf.d_name[MAXNAMLEN] = 0;
	while (1) {
		if (read(fp, &dirbuf, sizeof(struct dirent)) <= 0) {
			break;
		}
		if (dirbuf.d_ino == 0)	/* entry not allocated */
a586 3
		for (i = 0; i < len; ++i) {
			if (cp[i] != dirbuf.d_name[i])
				break;
a587 3
		if (i < len)
			continue;
		current = (struct filelist *) malloc(sizeof(struct filelist));
a590 2
		strcpy(current->fl_name, prefixx);
		strcat(current->fl_name, dirbuf.d_name);
d592 6
d599 6
a604 4
			strcpy(statname, dir);
			strcat(statname, "/");
			strcat(statname, dirbuf.d_name);
			stat(statname, &statbuf);
a606 2
			else if (statbuf.st_mode & 0100)
				strcat(current->fl_name, "*");
d609 1
a609 1
	close(fp);
@


1.9
log
@Don't use rename to backup the file to a ~ file.  We need to make a
copy instead so the original is edited in place for things like
cron and vipw.
@
text
@d1 2
@


1.8
log
@$HOME paranoia: never use getenv("HOME") w/o checking for NULL and non-zero
@
text
@d11 3
d149 6
a154 7
 * Rename the file "fname" into a backup
 * copy. On Unix the backup has the same name as the
 * original file, with a "~" on the end; this seems to
 * be newest of the new-speak. The error handling is
 * all in "file.c". The "unlink" is perhaps not the
 * right thing here; I don't care that much as
 * I don't enable backups myself.
d160 5
d167 3
a169 2
	if ((nname = malloc((unsigned) (strlen(fn) + 1 + 1))) == NULL) {
		ewprintf("Can't get %d bytes", strlen(fn) + 1);
d173 8
a180 3
	(void) strcat(nname, "~");
	if (rename(fn, nname) < 0) {
		free(nname);
d182 12
d195 5
d201 2
a202 1
	return (TRUE);
@


1.7
log
@The start of KNF + -Wall.  The code has been run through indent but
needs hand fixup.  I stopped at keymap.c...
@
text
@d213 3
a215 2
		if (*fn == '/' || *fn == '\0') {
			(VOID) strcpy(fnb, getenv("HOME"));
d328 1
a328 1
	if ((file = getenv("HOME")) == NULL)
@


1.6
log
@Remove a now-bogus comment
Use pid_t
Use vfork(), not fork() when sensible
@
text
@d2 1
a2 1
 *		POSIX fileio.c
d6 1
a6 2
static	FILE	*ffp;
char	*adjustname();
d15 8
a22 4
ffropen(fn, bp) char *fn; BUFFER *bp; {
	struct stat statbuf;
	
	if ((ffp=fopen(fn, "r")) == NULL)
d25 1
a25 1
/* set highorder bit to make sure this isn't all zero */
d38 7
a44 2
ffwopen(fn, bp) char *fn; BUFFER *bp; {
	if ((ffp=fopen(fn, "w")) == NULL) {
d48 7
a54 7
	/* 
	 * If we have file information, use it.  We don't bother
	 * to check for errors, because there's no a lot we can do
	 * about it.  Certainly trying to change ownership will fail
	 * if we aren' root.  That's probably OK.  If we don't have
	 * info, no need to get it, since any future writes will do
	 * the same thing.
d65 1
a65 1
 * Should look at the status.
d67 6
a72 1
ffclose() {
d84 1
d86 1
a86 1
BUFFER *bp;
d88 25
a112 23
    register char *cp;
    register char *cpend;
    register LINE *lp;
    register LINE *lpend;

    lpend = bp->b_linep;
    lp = lforw(lpend);
    do {
	cp = &ltext(lp)[0];		/* begining of line	*/
	cpend = &cp[llength(lp)];	/* end of line		*/
	while(cp != cpend) {
	    putc(*cp, ffp);
	    cp++;	/* putc may evalualte arguments more than once */
	}
	lp = lforw(lp);
	if(lp == lpend) break;		/* no implied newline on last line */
	putc('\n', ffp);
    } while(!ferror(ffp));
    if(ferror(ffp)) {
	ewprintf("Write I/O error");
	return FIOERR;
    }
    return FIOSUC;
d121 1
d123 3
a125 3
register char	*buf;
register int	nbuf;
register int	*nbytes;
d127 2
a128 2
	register int	c;
	register int	i;
d131 1
a131 1
	while((c = getc(ffp))!=EOF && c!='\n') {
d133 2
a134 1
		if (i >= nbuf) return FIOLONG;
d136 1
a136 1
	if (c == EOF  && ferror(ffp) != FALSE) {
d141 1
a141 1
	return c==EOF ? FIOEOF : FIOSUC;
d154 5
a158 5
fbackupfile(fn) char *fn; {
	register char	*nname;
	char		*malloc(), *strrchr();
	int		i;
	char		*lastpart;
d160 1
a160 1
	if ((nname=malloc((unsigned)(strlen(fn)+1+1))) == NULL) {
d190 1
a190 1
extern char *wdir;
d193 3
a195 2
char *adjustname(fn)
register char *fn;
d197 3
a199 3
    register char *cp;
    static char fnb[NFILEN];
    struct passwd *pwent;
d201 3
a203 3
    struct stat statbuf;
    int i, j;
    char linkbuf[NFILEN];
d206 5
a210 5
    switch(*fn) {
    	case '/':
	    cp = fnb;
	    *cp++ = *fn++;
	    break;
d212 7
a218 14
	    fn++;
	    if(*fn == '/' || *fn == '\0') {
		(VOID) strcpy(fnb, getenv("HOME"));
		cp = fnb + strlen(fnb);
	    	if(*fn) fn++;
		break;
	    } else {
		cp = fnb;
		while(*fn && *fn != '/') *cp++ = *fn++;
		*cp = '\0';
		if((pwent = getpwnam(fnb)) != NULL) {
		    (VOID) strcpy(fnb, pwent->pw_dir);
		    cp = fnb + strlen(fnb);
		    break;
d220 12
a231 2
		    fn -= strlen(fnb) + 1;
		    /* can't find ~user, continue to default case */
a232 1
	    }
d235 3
a237 3
	    strcpy(fnb, wdir);
	    cp = fnb + strlen(fnb);
	    break;
d239 1
a239 1
	    return fn;				/* punt */
d241 16
a256 14
    }
    if(cp != fnb && cp[-1] != '/') *cp++ = '/';
    while(*fn) {
    	switch(*fn) {
	    case '.':
		switch(fn[1]) {
	            case '\0':
		    	*--cp = '\0';
		    	return fnb;
	    	    case '/':
	    	    	fn += 2;
		    	continue;
		    case '.':
		    	if(fn[2]=='/' || fn[2] == '\0') {
d258 21
a278 15
			    cp[-1] = '\0';
			    for(j = MAXLINK; j-- && 
			    	    lstat(fnb, &statbuf) != -1 && 
			    	    (statbuf.st_mode&S_IFMT) == S_IFLNK &&
			    	    (i = readlink(fnb, linkbuf, sizeof linkbuf))
				    != -1 ;) {
				if(linkbuf[0] != '/') {
				    --cp;
				    while(cp > fnb && *--cp != '/') {}
				    ++cp;
				    (VOID) strncpy(cp, linkbuf, i);
				    cp += i;
				} else {
				    (VOID) strncpy(fnb, linkbuf, i);
				    cp = fnb + i;
d280 1
a280 4
				if(cp[-1]!='/') *cp++ = '\0';
				else cp[-1] = '\0';
			    }
			    cp[-1] = '/';
d282 27
a308 26
			    --cp;
			    while(cp > fnb && *--cp != '/') {}
			    ++cp;
			    if(fn[2]=='\0') {
			        *--cp = '\0';
			        return fnb;
			    }
		            fn += 3;
		            continue;
		        }
		        break;
		    default:
		    	break;
	        }
		break;
	    case '/':
	    	fn++;
	    	continue;
	    default:
	    	break;
	}
	while(*fn && (*cp++ = *fn++) != '/') {}
    }
    if(cp[-1]=='/') --cp;
    *cp = '\0';
    return fnb;
d322 1
a322 1
char *suffix;
d324 2
a325 2
	register char	*file;
	static char	home[NFILEN];
d327 4
a330 2
	if ((file = getenv("HOME")) == NULL) goto notfound;
	if (strlen(file)+7 >= NFILEN - 1) goto notfound;
d337 2
a338 1
	if (access(home, F_OK) == 0) return home;
d349 2
a350 1
	if (access(file, F_OK ) == 0) return file;
d361 1
d363 2
a364 1
char *frname, *toname;
d366 2
a367 2
    pid_t pid;
    int status;
d369 54
a422 54
    if(pid = vfork()) {
	if(pid == -1)	return	-1;
	execl("/bin/cp", "cp", frname, toname, (char *)NULL);
	_exit(1);	/* shouldn't happen */
    }
    while(wait(&status) != pid)
	;
    return status == 0;
}

BUFFER *dired_(dirname)
char *dirname;
{
    register BUFFER *bp;
    char line[256];
    BUFFER *findbuffer();
    FILE *dirpipe;
    FILE *popen();
    char *strncpy();

    if((dirname = adjustname(dirname)) == NULL) {
	ewprintf("Bad directory name");
	return NULL;
    }
    if(dirname[strlen(dirname)-1] != '/') (VOID) strcat(dirname, "/");
    if((bp = findbuffer(dirname)) == NULL) {
	ewprintf("Could not create buffer");
	return NULL;
    }
    if(bclear(bp) != TRUE) return FALSE;
    (VOID) strcpy(line, "ls -al ");
    (VOID) strcpy(&line[7], dirname);
    if((dirpipe = popen(line, "r")) == NULL) {
	ewprintf("Problem opening pipe to ls");
	return NULL;
    }
    line[0] = line[1] = ' ';
    while(fgets(&line[2], 254, dirpipe) != NULL) {
	line[strlen(line) - 1] = '\0';		/* remove ^J	*/
	(VOID) addline(bp, line);
    }
    if(pclose(dirpipe) == -1) {
	ewprintf("Problem closing pipe to ls");
	return NULL;
    }
    bp->b_dotp = lforw(bp->b_linep);		/* go to first line */
    (VOID) strncpy(bp->b_fname, dirname, NFILEN);
    if((bp->b_modes[0] = name_mode("dired")) == NULL) {
	bp->b_modes[0] = &map_table[0];
	ewprintf("Could not find mode dired");
	return NULL;
    }
    bp->b_nmodes = 0;
    return bp;
d425 1
d427 2
a428 2
register LINE *lp;
register char *fn;
d430 1
a430 1
    register char *cp;
d432 7
a438 6
    if(llength(lp) <= 56) return ABORT;
    (VOID) strcpy(fn, curbp->b_fname);
    cp = fn + strlen(fn);
    bcopy(&lp->l_text[56], cp, llength(lp) - 56);
    cp[llength(lp) - 56] = '\0';
    return lgetc(lp, 2) == 'd';
d440 1
a440 1
#endif NO_DIRED
d443 2
a444 2
   LIST fl_l;
   char fl_name[NFILEN+2];
d447 6
a452 4
/* these things had better be contiguous, because we're going
 * to refer to the end of dirbuf + 1 byte */
struct direct dirbuf;
char dirdummy;
d462 50
a511 51
LIST *make_file_list(buf,listing)
  char *buf;
  int listing;
{
char *dir,*file,*cp;
int len,i,preflen;
int fp;
LIST *last,*l1,*l2;
struct filelist *current;
char prefixx[NFILEN+1];
extern int errno;
struct stat statbuf;
char statname[NFILEN+2];

/* We need three different strings:
 *   dir - the name of the directory containing what the user typed.
 *	   Must be a real unix file name, e.g. no ~user, etc..  Must
 *         not end in /.
 *   prefix - the portion of what the user typed that is before
 *	   the names we are going to find in the directory.  Must have
 *	   a trailing / if the user typed it.
 *   names from the directory.
 *   we open dir, and return prefix concatenated with names.
 */

/* first we get a directory name we can look up */
/* names ending in . are potentially odd, because adjustname
 * will treat foo/.. as a reference to another directory,
 * whereas we are interested in names starting with ..
 */
len = strlen(buf);
if (buf[len-1] == '.') {
	buf[len-1] = 'x';
	dir = adjustname(buf);
	buf[len-1] = '.';
}
else
	dir = adjustname(buf);
/*
 * if the user typed a trailing / or the empty string
 * he wants us to use his file spec as a directory name
 */
if (buf[0] && buf[strlen(buf)-1] != '/') {
	file = strrchr(dir, '/');
	if (file) {
		*file = 0;
		if (*dir == 0)
			dir = "/";
	}
	else {
		return(NULL);
d513 31
a543 1
}
d545 9
a553 48
/* now we get the prefix of the name the user typed */
strcpy(prefixx,buf);
cp = strrchr(prefixx, '/');
if (cp == NULL)
	prefixx[0] = 0;
else
	cp[1] = 0;

preflen = strlen(prefixx);
/* cp is the tail of buf that really needs to be compared */
cp = buf + preflen;
len = strlen(cp);

/* 
 * Now make sure that file names will fit in the buffers allocated.
 * SV files are fairly short.  For BSD, something more general
 * would be required.
 */
if ((preflen + MAXNAMLEN) > NFILEN)
	return(NULL);
if ((strlen(dir) + MAXNAMLEN) > NFILEN)
	listing = 0;

/* loop over the specified directory, making up the list of files */

/*
 * Note that it is worth our time to filter out names that don't
 * match, even though our caller is going to do so again, and to
 * avoid doing the stat if completion is being done, because stat'ing
 * every file in the directory is relatively expensive.
 */

fp = open(dir,0);
if (fp < 0) {
	return(NULL);
}

last = NULL;
/* clear entry after last so we can treat d_name as ASCIZ */
dirbuf.d_name[MAXNAMLEN] = 0;
while (1) {
	if (read(fp, &dirbuf, sizeof(struct direct)) <= 0) {
		break;
	}
	if (dirbuf.d_ino == 0)  /* entry not allocated */
		continue;
	for (i=0; i<len; ++i) {
		if (cp[i] != dirbuf.d_name[i])
d555 26
d582 1
a582 24
	if (i < len)
		continue;
	current = (struct filelist *)malloc(sizeof(struct filelist));
	current->fl_l.l_next = last;
	current->fl_l.l_name = current->fl_name;
	last = (LIST *)current;
	strcpy(current->fl_name,prefixx);
	strcat(current->fl_name,dirbuf.d_name);
	if (listing) {
		statbuf.st_mode = 0;
		strcpy(statname,dir);
		strcat(statname,"/");
		strcat(statname,dirbuf.d_name);
		stat(statname,&statbuf);
		if (statbuf.st_mode & 040000)
			strcat(current->fl_name,"/");
		else if (statbuf.st_mode & 0100)
			strcat(current->fl_name,"*");
	}

}
close(fp);

return (last);
d584 1
@


1.5
log
@We don't have silly SYSV 14-character file name limits.  Taken from
the BSD fileio.c.  Note that this module is rife with PATH_MAX overflow
possibilities.
@
text
@a329 14
/*
 * It's sort of gross to call system commands in a subfork.  However
 * that's by far the easiest way.  These things are used only in
 * dired, so they are not performance-critical.  The cp program is
 * almost certainly faster at copying files than any stupid code that
 * we would write.  In fact there is no other way to do unlinkdir.
 * You don't want to do a simple unlink.  To do the whole thing in
 * a general way requires root, and rmdir is setuid.  We don't really
 * want microemacs to have to run setuid.  rename is easy to do with
 * unlink, link, unlink.  However that code will fail if the destination
 * is on a different file system.  mv will copy in that case.  It seems
 * easier to let mv worry about this stuff.
 */

d333 1
a333 1
    int pid;
d336 1
a336 1
    if(pid = fork()) {
@


1.4
log
@Use uid_t, gid_t and mode_t where applicable.
Pull in changes from the BSD-specific sysdef.h and fileio.c:
kill bogus unlinkdir() and rename() kludges since we have rmdir(2) and rename(2)
define SYMBLINK since we have symlinks
TODO: merge BSD spawn.c and ttyio.c
@
text
@d147 2
a148 23
/*
 * with BSD, just strcat the ~.  But SV has a max file name of 14, so
 * we have to check.
 */
	lastpart = strrchr(nname, '/');
	if (lastpart)
		lastpart++;
	else
		lastpart = nname;
	i = strlen(lastpart);
	if (i > 13)
		if (lastpart[13] == '~') {   /* already a backup name */
			free(nname);
			return(FALSE);
		}
		else
			lastpart[13] = '~';
	else {
		lastpart[i] = '~';
		lastpart[i+1] = 0;
	}
	(void) unlink(nname);			/* Ignore errors.	*/
	if (link(fn, nname) != 0 || unlink(fn) != 0) {
d374 1
@


1.3
log
@further pruning
@
text
@d2 1
a2 1
 *		sys V fileio.c
a306 3
#ifndef F_OK
#define F_OK 04			/* for stupid Sys V		*/
#endif
d348 1
a437 37
}

/*
 * I, a System V novice, could only figure out how to do unlinkdir()
 * and rename() as exec's of the appropriate functions.  So sue me.
 * --Stephen Walton, December 1987
 */

unlinkdir(f)
char *f;
{
	int status, pid, wpid;

	if ((pid = fork()) == 0)
		execl("/bin/rmdir", "rmdir", f, (char *)NULL);
	else if (pid > 0)
		while ((wpid = wait(&status)) && wpid != pid)
			;
	else
		return FALSE;
	return status == 0;
}

Xrename(f1, f2)
char *f1, *f2;
{

	int status, pid, wpid;

	if ((pid = fork()) == 0)
		execl("/bin/mv", "mv", f1, f2, (char *)NULL);
	else if (pid > 0)
		while ((wpid = wait(&status)) && wpid != pid)
			;
	else
		return FALSE;
	return status == 0;
@


1.2
log
@make it minimally compile; millert
@
text
@a6 1
extern	char	*getenv();
a200 1
    extern struct passwd *getpwnam();
a322 1
	char		*getenv();
@


1.1
log
@initial import of mg2a
@
text
@d309 1
d311 1
d573 1
a573 1
if ((preflen + DIRSIZ) > NFILEN)
d575 1
a575 1
if ((strlen(dir) + DIRSIZ) > NFILEN)
d594 1
a594 1
dirbuf.d_name[DIRSIZ] = 0;
@

