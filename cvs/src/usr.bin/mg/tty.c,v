head	1.36;
access;
symbols
	OPENBSD_6_1_BASE:1.36
	OPENBSD_6_0:1.36.0.4
	OPENBSD_6_0_BASE:1.36
	OPENBSD_5_9:1.36.0.2
	OPENBSD_5_9_BASE:1.36
	OPENBSD_5_8:1.35.0.4
	OPENBSD_5_8_BASE:1.35
	OPENBSD_5_7:1.32.0.2
	OPENBSD_5_7_BASE:1.32
	OPENBSD_5_6:1.30.0.26
	OPENBSD_5_6_BASE:1.30
	OPENBSD_5_5:1.30.0.24
	OPENBSD_5_5_BASE:1.30
	OPENBSD_5_4:1.30.0.20
	OPENBSD_5_4_BASE:1.30
	OPENBSD_5_3:1.30.0.18
	OPENBSD_5_3_BASE:1.30
	OPENBSD_5_2:1.30.0.16
	OPENBSD_5_2_BASE:1.30
	OPENBSD_5_1_BASE:1.30
	OPENBSD_5_1:1.30.0.14
	OPENBSD_5_0:1.30.0.12
	OPENBSD_5_0_BASE:1.30
	OPENBSD_4_9:1.30.0.10
	OPENBSD_4_9_BASE:1.30
	OPENBSD_4_8:1.30.0.8
	OPENBSD_4_8_BASE:1.30
	OPENBSD_4_7:1.30.0.4
	OPENBSD_4_7_BASE:1.30
	OPENBSD_4_6:1.30.0.6
	OPENBSD_4_6_BASE:1.30
	OPENBSD_4_5:1.30.0.2
	OPENBSD_4_5_BASE:1.30
	OPENBSD_4_4:1.29.0.2
	OPENBSD_4_4_BASE:1.29
	OPENBSD_4_3:1.28.0.8
	OPENBSD_4_3_BASE:1.28
	OPENBSD_4_2:1.28.0.6
	OPENBSD_4_2_BASE:1.28
	OPENBSD_4_1:1.28.0.4
	OPENBSD_4_1_BASE:1.28
	OPENBSD_4_0:1.28.0.2
	OPENBSD_4_0_BASE:1.28
	OPENBSD_3_9:1.26.0.2
	OPENBSD_3_9_BASE:1.26
	OPENBSD_3_8:1.22.0.2
	OPENBSD_3_8_BASE:1.22
	OPENBSD_3_7:1.20.0.8
	OPENBSD_3_7_BASE:1.20
	OPENBSD_3_6:1.20.0.6
	OPENBSD_3_6_BASE:1.20
	OPENBSD_3_5:1.20.0.4
	OPENBSD_3_5_BASE:1.20
	OPENBSD_3_4:1.20.0.2
	OPENBSD_3_4_BASE:1.20
	OPENBSD_3_3:1.19.0.4
	OPENBSD_3_3_BASE:1.19
	OPENBSD_3_2:1.19.0.2
	OPENBSD_3_2_BASE:1.19
	OPENBSD_3_1:1.16.0.2
	OPENBSD_3_1_BASE:1.16
	OPENBSD_3_0:1.9.0.2
	OPENBSD_3_0_BASE:1.9
	OPENBSD_2_9_BASE:1.7
	OPENBSD_2_9:1.7.0.2
	OPENBSD_2_8:1.6.0.2
	OPENBSD_2_8_BASE:1.6
	OPENBSD_2_7:1.5.0.2
	OPENBSD_2_7_BASE:1.5;
locks; strict;
comment	@ * @;


1.36
date	2015.11.18.18.44.50;	author jasper;	state Exp;
branches;
next	1.35;
commitid	L9mmlkcp7mqqKa4c;

1.35
date	2015.03.19.21.48.05;	author bcallah;	state Exp;
branches;
next	1.34;
commitid	8rkHsVfUx5xgPXRB;

1.34
date	2015.03.19.21.22.15;	author bcallah;	state Exp;
branches;
next	1.33;
commitid	GbEBL4CfPvDkB8hj;

1.33
date	2015.03.17.18.08.52;	author bcallah;	state Exp;
branches;
next	1.32;
commitid	ZNG0kOG8IxZdy28m;

1.32
date	2014.11.16.00.50.00;	author guenther;	state Exp;
branches;
next	1.31;
commitid	VvWCnf5EC9WSImLy;

1.31
date	2014.11.16.00.47.35;	author guenther;	state Exp;
branches;
next	1.30;
commitid	7qsrLGuiYURGCay5;

1.30
date	2008.09.15.16.11.35;	author kjell;	state Exp;
branches;
next	1.29;

1.29
date	2008.06.11.00.03.49;	author tobias;	state Exp;
branches;
next	1.28;

1.28
date	2006.08.01.22.16.03;	author jason;	state Exp;
branches;
next	1.27;

1.27
date	2006.04.03.00.40.56;	author deraadt;	state Exp;
branches;
next	1.26;

1.26
date	2006.02.25.14.40.16;	author otto;	state Exp;
branches;
next	1.25;

1.25
date	2005.12.13.19.01.32;	author kjell;	state Exp;
branches;
next	1.24;

1.24
date	2005.12.13.06.01.27;	author kjell;	state Exp;
branches;
next	1.23;

1.23
date	2005.11.19.20.16.35;	author kjell;	state Exp;
branches;
next	1.22;

1.22
date	2005.06.14.18.14.40;	author kjell;	state Exp;
branches;
next	1.21;

1.21
date	2005.04.03.02.09.28;	author db;	state Exp;
branches;
next	1.20;

1.20
date	2003.06.10.22.20.48;	author deraadt;	state Exp;
branches;
next	1.19;

1.19
date	2002.08.28.19.48.29;	author art;	state Exp;
branches;
next	1.18;

1.18
date	2002.08.23.18.43.49;	author vincent;	state Exp;
branches;
next	1.17;

1.17
date	2002.07.01.18.01.40;	author vincent;	state Exp;
branches;
next	1.16;

1.16
date	2002.02.21.04.16.23;	author deraadt;	state Exp;
branches;
next	1.15;

1.15
date	2002.02.21.00.02.04;	author deraadt;	state Exp;
branches;
next	1.14;

1.14
date	2002.02.16.21.27.49;	author millert;	state Exp;
branches;
next	1.13;

1.13
date	2002.02.14.14.24.21;	author deraadt;	state Exp;
branches;
next	1.12;

1.12
date	2002.02.05.20.47.32;	author art;	state Exp;
branches;
next	1.11;

1.11
date	2002.01.18.08.37.08;	author art;	state Exp;
branches;
next	1.10;

1.10
date	2002.01.10.12.13.35;	author art;	state Exp;
branches;
next	1.9;

1.9
date	2001.05.24.03.05.26;	author mickey;	state Exp;
branches;
next	1.8;

1.8
date	2001.05.23.22.20.36;	author art;	state Exp;
branches;
next	1.7;

1.7
date	2001.01.29.01.58.10;	author niklas;	state Exp;
branches;
next	1.6;

1.6
date	2000.09.01.14.59.09;	author millert;	state Exp;
branches;
next	1.5;

1.5
date	2000.04.13.06.12.17;	author millert;	state Exp;
branches;
next	1.4;

1.4
date	2000.03.03.19.31.27;	author millert;	state Exp;
branches;
next	1.3;

1.3
date	2000.02.27.05.52.32;	author millert;	state Exp;
branches;
next	1.2;

1.2
date	2000.02.26.22.53.16;	author millert;	state Exp;
branches;
next	1.1;

1.1
date	2000.02.25.19.08.52;	author deraadt;	state Exp;
branches;
next	;


desc
@@


1.36
log
@shrink differences between ttinsl/ttdell
@
text
@/*	$OpenBSD: tty.c,v 1.35 2015/03/19 21:48:05 bcallah Exp $	*/

/* This file is in the public domain. */

/*
 * Terminfo display driver
 *
 * Terminfo is a terminal information database and routines to describe
 * terminals on most modern UNIX systems.  Many other systems have adopted
 * this as a reasonable way to allow for widely varying and ever changing
 * varieties of terminal types.	 This should be used where practical.
 */
/*
 * Known problems: If you have a terminal with no clear to end of screen and
 * memory of lines below the ones visible on the screen, display will be
 * wrong in some cases.  I doubt that any such terminal was ever made, but I
 * thought everyone with delete line would have clear to end of screen too...
 *
 * Code for terminals without clear to end of screen and/or clear to end of line
 * has not been extensively tested.
 *
 * Cost calculations are very rough.  Costs of insert/delete line may be far
 * from the truth.  This is accentuated by display.c not knowing about
 * multi-line insert/delete.
 *
 * Using scrolling region vs insert/delete line should probably be based on cost
 * rather than the assumption that scrolling region operations look better.
 */

#include <sys/ioctl.h>
#include <sys/queue.h>
#include <sys/types.h>
#include <sys/time.h>
#include <signal.h>
#include <stdio.h>
#include <term.h>

#include "def.h"

static int	 charcost(const char *);

static int	 cci;
static int	 insdel;	/* Do we have both insert & delete line? */
static const char	*scroll_fwd;	/* How to scroll forward. */

static void	 winchhandler(int);

/* ARGSUSED */
static void
winchhandler(int sig)
{
	winch_flag = 1;
}

/*
 * Initialize the terminal when the editor
 * gets started up.
 */
void
ttinit(void)
{
	int errret;

	if (setupterm(NULL, 1, &errret))
		panic("Terminal setup failed");

	signal(SIGWINCH, winchhandler);
	signal(SIGCONT, winchhandler);
	siginterrupt(SIGWINCH, 1);

	scroll_fwd = scroll_forward;
	if (scroll_fwd == NULL || *scroll_fwd == '\0') {
		/* this is what GNU Emacs does */
		scroll_fwd = parm_down_cursor;
		if (scroll_fwd == NULL || *scroll_fwd == '\0')
			scroll_fwd = "\n";
	}

	if (cursor_address == NULL || cursor_up == NULL)
		panic("This terminal is too stupid to run mg");

	/* set nrow & ncol */
	ttresize();

	if (!clr_eol)
		tceeol = ncol;
	else
		tceeol = charcost(clr_eol);

	/* Estimate cost of inserting a line */
	if (change_scroll_region && scroll_reverse)
		tcinsl = charcost(change_scroll_region) * 2 +
		    charcost(scroll_reverse);
	else if (parm_insert_line)
		tcinsl = charcost(parm_insert_line);
	else if (insert_line)
		tcinsl = charcost(insert_line);
	else
		/* make this cost high enough */
		tcinsl = nrow * ncol;

	/* Estimate cost of deleting a line */
	if (change_scroll_region)
		tcdell = charcost(change_scroll_region) * 2 +
		    charcost(scroll_fwd);
	else if (parm_delete_line)
		tcdell = charcost(parm_delete_line);
	else if (delete_line)
		tcdell = charcost(delete_line);
	else
		/* make this cost high enough */
		tcdell = nrow * ncol;

	/* Flag to indicate that we can both insert and delete lines */
	insdel = (insert_line || parm_insert_line) &&
	    (delete_line || parm_delete_line);

	if (enter_ca_mode)
		/* enter application mode */
		putpad(enter_ca_mode, 1);

	ttresize();
}

/*
 * Re-initialize the terminal when the editor is resumed.
 * The keypad_xmit doesn't really belong here but...
 */
void
ttreinit(void)
{
	/* check if file was modified while we were gone */
	if (fchecktime(curbp) != TRUE) {
		curbp->b_flag |= BFDIRTY;
	}

	if (enter_ca_mode)
		/* enter application mode */
		putpad(enter_ca_mode, 1);

	if (keypad_xmit)
		/* turn on keypad */
		putpad(keypad_xmit, 1);

	ttresize();
}

/*
 * Clean up the terminal, in anticipation of a return to the command
 * interpreter. This is a no-op on the ANSI display. On the SCALD display,
 * it sets the window back to half screen scrolling. Perhaps it should
 * query the display for the increment, and put it back to what it was.
 */
void
tttidy(void)
{
	ttykeymaptidy();

	/* set the term back to normal mode */
	if (exit_ca_mode)
		putpad(exit_ca_mode, 1);
}

/*
 * Move the cursor to the specified origin 0 row and column position. Try to
 * optimize out extra moves; redisplay may have left the cursor in the right
 * location last time!
 */
void
ttmove(int row, int col)
{
	if (ttrow != row || ttcol != col) {
		putpad(tgoto(cursor_address, col, row), 1);
		ttrow = row;
		ttcol = col;
	}
}

/*
 * Erase to end of line.
 */
void
tteeol(void)
{
	int	i;

	if (clr_eol)
		putpad(clr_eol, 1);
	else {
		i = ncol - ttcol;
		while (i--)
			ttputc(' ');
		ttrow = ttcol = HUGE;
	}
}

/*
 * Erase to end of page.
 */
void
tteeop(void)
{
	int	line;

	if (clr_eos)
		putpad(clr_eos, nrow - ttrow);
	else {
		putpad(clr_eol, 1);
		if (insdel)
			ttdell(ttrow + 1, lines, lines - ttrow - 1);
		else {
			/* do it by hand */
			for (line = ttrow + 1; line <= lines; ++line) {
				ttmove(line, 0);
				tteeol();
			}
		}
		ttrow = ttcol = HUGE;
	}
}

/*
 * Make a noise.
 */
void
ttbeep(void)
{
	putpad(bell, 1);
	ttflush();
}

/*
 * Insert nchunk blank line(s) onto the screen, scrolling the last line on
 * the screen off the bottom.  Use the scrolling region if possible for a
 * smoother display.  If there is no scrolling region, use a set of insert
 * and delete line sequences.
 */
void
ttinsl(int row, int bot, int nchunk)
{
	int	i, nl;

	/* One line special cases */
	if (row == bot) {
		ttmove(row, 0);
		tteeol();
		return;
	}
	/* Use scroll region and back index */
	if (change_scroll_region && scroll_reverse) {
		nl = bot - row;
		ttwindow(row, bot);
		ttmove(row, 0);
		while (nchunk--)
			putpad(scroll_reverse, nl);
		ttnowindow();
		return;
	/* else use insert/delete line */
	} else if (insdel) {
		ttmove(1 + bot - nchunk, 0);
		nl = nrow - ttrow;
		if (parm_delete_line)
			putpad(tgoto(parm_delete_line, 0, nchunk), nl);
		else
			/* For all lines in the chunk */
			for (i = 0; i < nchunk; i++)
				putpad(delete_line, nl);
		ttmove(row, 0);

		/* ttmove() changes ttrow */
		nl = nrow - ttrow;

		if (parm_insert_line)
			putpad(tgoto(parm_insert_line, 0, nchunk), nl);
		else
			/* For all lines in the chunk */
			for (i = 0; i < nchunk; i++)
				putpad(insert_line, nl);
		ttrow = HUGE;
		ttcol = HUGE;
	} else
		panic("ttinsl: Can't insert/delete line");
}

/*
 * Delete nchunk line(s) from "row", replacing the bottom line on the
 * screen with a blank line.  Unless we're using the scrolling region,
 * this is done with crafty sequences of insert and delete lines.  The
 * presence of the echo area makes a boundary condition go away.
 */
void
ttdell(int row, int bot, int nchunk)
{
	int	i, nl;

	/* One line special cases */
	if (row == bot) {
		ttmove(row, 0);
		tteeol();
		return;
	}
	/* scrolling region */
	if (change_scroll_region) {
		nl = bot - row;
		ttwindow(row, bot);
		ttmove(bot, 0);
		while (nchunk--)
			putpad(scroll_fwd, nl);
		ttnowindow();
	/* else use insert/delete line */
	} else if (insdel) {
		ttmove(row, 0);
		nl = nrow - ttrow;
		if (parm_delete_line)
			putpad(tgoto(parm_delete_line, 0, nchunk), nl);
		else
			/* For all lines in the chunk */
			for (i = 0; i < nchunk; i++)
				putpad(delete_line, nl);
		ttmove(1 + bot - nchunk, 0);

		/* ttmove() changes ttrow */
		nl = nrow - ttrow;

		if (parm_insert_line)
			putpad(tgoto(parm_insert_line, 0, nchunk), nl);
		else
			/* For all lines in the chunk */
			for (i = 0; i < nchunk; i++)
				putpad(insert_line, nl);
		ttrow = HUGE;
		ttcol = HUGE;
	} else
		panic("ttdell: Can't insert/delete line");
}

/*
 * This routine sets the scrolling window on the display to go from line
 * "top" to line "bot" (origin 0, inclusive).  The caller checks for the
 * pathological 1-line scroll window which doesn't work right and avoids
 * it.  The "ttrow" and "ttcol" variables are set to a crazy value to
 * ensure that the next call to "ttmove" does not turn into a no-op (the
 * window adjustment moves the cursor).
 */
void
ttwindow(int top, int bot)
{
	if (change_scroll_region && (tttop != top || ttbot != bot)) {
		putpad(tgoto(change_scroll_region, bot, top), nrow - ttrow);
		ttrow = HUGE;	/* Unknown.		 */
		ttcol = HUGE;
		tttop = top;	/* Remember region.	 */
		ttbot = bot;
	}
}

/*
 * Switch to full screen scroll. This is used by "spawn.c" just before it
 * suspends the editor and by "display.c" when it is getting ready to
 * exit.  This function does a full screen scroll by telling the terminal
 * to set a scrolling region that is lines or nrow rows high, whichever is
 * larger.  This behavior seems to work right on systems where you can set
 * your terminal size.
 */
void
ttnowindow(void)
{
	if (change_scroll_region) {
		putpad(tgoto(change_scroll_region,
		    (nrow > lines ? nrow : lines) - 1, 0), nrow - ttrow);
		ttrow = HUGE;	/* Unknown.		 */
		ttcol = HUGE;
		tttop = HUGE;	/* No scroll region.	 */
		ttbot = HUGE;
	}
}

/*
 * Set the current writing color to the specified color. Watch for color
 * changes that are not going to do anything (the color is already right)
 * and don't send anything to the display.  The rainbow version does this
 * in putline.s on a line by line basis, so don't bother sending out the
 * color shift.
 */
void
ttcolor(int color)
{
	if (color != tthue) {
		if (color == CTEXT)
			/* normal video */
			putpad(exit_standout_mode, 1);
		else if (color == CMODE)
			/* reverse video */
			putpad(enter_standout_mode, 1);
		/* save the color */
		tthue = color;
	}
}

/*
 * This routine is called by the "refresh the screen" command to try
 * to resize the display. Look in "window.c" to see how
 * the caller deals with a change.
 *
 * We use `newrow' and `newcol' so vtresize() know the difference between the
 * new and old settings.
 */
void
ttresize(void)
{
	int newrow = 0, newcol = 0;

	struct	winsize winsize;

	if (ioctl(0, TIOCGWINSZ, &winsize) == 0) {
		newrow = winsize.ws_row;
		newcol = winsize.ws_col;
	}
	if ((newrow <= 0 || newcol <= 0) &&
	    ((newrow = lines) <= 0 || (newcol = columns) <= 0)) {
		newrow = 24;
		newcol = 80;
	}
	if (vtresize(1, newrow, newcol) != TRUE)
		panic("vtresize failed");
}

/*
 * fake char output for charcost()
 */
/* ARGSUSED */
static int
fakec(int c)
{
	cci++;
	return (0);
}

/* calculate the cost of doing string s */
static int
charcost(const char *s)
{
	cci = 0;

	tputs(s, nrow, fakec);
	return (cci);
}
@


1.35
log
@More unifdef cleanup:
-UDIRED_XMAPS and -UFUND_XMAPS: you can't build mg the other way.
-DTIOCGWINSZ: you have this if you have term.h
Remove a #define TERMCAP which isn't being used.

Remove defines for NDIRED_XMAPS, NFUND_XMAPS, and IMAPEXT. They are all
defined to be 0 and are only ever used in addition. We don't need to add 0.
Simply lines that were using those defines.
ok florian@@
@
text
@d1 1
a1 1
/*	$OpenBSD: tty.c,v 1.34 2015/03/19 21:22:15 bcallah Exp $	*/
d243 1
a243 1
	/* Case of one line insert is special. */
d249 1
a250 1
		/* Use scroll region and back index	 */
d258 1
d265 1
a265 1
			/* For all lines in the chunk... */
d317 1
a317 1
			/* For all lines in the chunk	 */
d324 1
@


1.34
log
@Clean up the includes in mg.
This does the following:
Moves all POSIX headers from sysdef.h into the individual .c files so that
each file now only includes what it needs. All headers are properly sorted.
Moves the remainder of sysdef.h to other files (mostly def.h) and deletes
sysdef.h now that it's no longer contains anything.
Tweak a comment that references sysdef.h so that it no longer does that.
ok florian@@
@
text
@d1 1
a1 1
/*	$OpenBSD: tty.c,v 1.33 2015/03/17 18:08:52 bcallah Exp $	*/
a410 1
#ifdef	TIOCGWINSZ
a416 1
#endif
@


1.33
log
@It is impossible to build mg without both -DFKEYS and -DXKEYS. So let's
enforce that and remove the options.
Mostly mechanical diff from unifdef with bonus removal of comments that no
longer have any relevance.
ok florian@@
@
text
@d1 1
a1 1
/*	$OpenBSD: tty.c,v 1.32 2014/11/16 00:50:00 guenther Exp $	*/
d30 2
a31 2
#include "def.h"

d34 3
a36 1
#include <sys/ioctl.h>
d38 1
a38 1
#include <term.h>
@


1.32
log
@scroll_fwd should be const char *

from Kamil Rytarowski (n54 (at) gmx.com)
@
text
@d1 1
a1 1
/*	$OpenBSD: tty.c,v 1.31 2014/11/16 00:47:35 guenther Exp $	*/
a154 1
#ifdef	XKEYS
a155 1
#endif /* XKEYS */
@


1.31
log
@constipate charcost()

from Kamil Rytarowski (n54 (at) gmx.com)
@
text
@d1 1
a1 1
/*	$OpenBSD: tty.c,v 1.30 2008/09/15 16:11:35 kjell Exp $	*/
d42 1
a42 1
static char	*scroll_fwd;	/* How to scroll forward. */
@


1.30
log
@Enable dirty buffer detection in mg.
Emulate the emacs behavior: after suspend/resume, buffer switch,
or at save time, warn (prompt) the user if the file has been modified
on disk in the interim.
This has already saved my butt numerous times.
ok phessler
@
text
@d1 1
a1 1
/*	$OpenBSD: tty.c,v 1.29 2008/06/11 00:03:49 tobias Exp $	*/
d38 1
a38 1
static int	 charcost(char *);
d441 1
a441 1
charcost(char *s)
@


1.29
log
@Let curses handle the setup of terminal instead of doing it on our own
and leaving terminal in an inusable state if setupterm failed.

ok kjell
@
text
@d1 1
a1 1
/*	$OpenBSD: tty.c,v 1.28 2006/08/01 22:16:03 jason Exp $	*/
d130 5
@


1.28
log
@* move sys/queue.h inclusion to sysdef.h (it's system specific)
* add <signal.h> to sysdef.h (needed for sig_atomic_t on linux, and
we get it by accident on OpenBSD)
* remove <signal.h> from tty.c/spawn.c (not needed now that it's in sysdef.h)
ok beck
@
text
@d1 1
a1 1
/*	$OpenBSD: tty.c,v 1.27 2006/04/03 00:40:56 deraadt Exp $	*/
d60 1
a60 1
	char	*tv_stype, *p;
d62 2
a63 7
	if ((tv_stype = getenv("TERM")) == NULL)
		panic("Could not determine terminal type!");

	if (setupterm(tv_stype, 1, NULL)) {
		(void)asprintf(&p, "Unknown terminal type: %s", tv_stype);
		panic(p);
	}
@


1.27
log
@lint love; ok kjell
@
text
@d1 1
a1 1
/*	$OpenBSD: tty.c,v 1.26 2006/02/25 14:40:16 otto Exp $	*/
a36 1
#include <signal.h>
@


1.26
log
@Fix a coredump occurring when the terminal is resized while mg is
suspended. Problem reported and fixed tested by reyk@@; tweak by
kjell@@; ok kjell@@
@
text
@d1 1
a1 1
/*	$OpenBSD: tty.c,v 1.25 2005/12/13 19:01:32 kjell Exp $	*/
d415 1
a415 1
	if (ioctl(0, TIOCGWINSZ, (char *) &winsize) == 0) {
@


1.25
log
@Fix a typo (introduced in rev 1.6) that utterly broke cost calculations.
In theory, mg should now be much more efficient on slow displays (hello,
zaurus).

Spotted by lint. ok millert.
@
text
@d1 1
a1 1
/*	$OpenBSD: tty.c,v 1.24 2005/12/13 06:01:27 kjell Exp $	*/
d72 1
@


1.24
log
@More name-clash delinting
@
text
@d1 1
a1 1
/*	$OpenBSD: tty.c,v 1.23 2005/11/19 20:16:35 kjell Exp $	*/
d443 1
a443 1
	int	cci = 0;
@


1.23
log
@Clean up some lint.
@
text
@d1 1
a1 1
/*	$OpenBSD: tty.c,v 1.22 2005/06/14 18:14:40 kjell Exp $	*/
d35 1
@


1.22
log
@Add explicit public domain notices to all public domain files.
ok millert@@, deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: tty.c,v 1.21 2005/04/03 02:09:28 db Exp $	*/
d46 1
@


1.21
log
@This is a no binary change which does:

- spelling, punctuation fixes
- variable declaration lineup
- use parentheses for return and sizeof
- K&R function declarations -> ANSI
- other minor code beautification

ok henning@@
@
text
@d1 3
a3 1
/*	$OpenBSD: tty.c,v 1.20 2003/06/10 22:20:48 deraadt Exp $	*/
@


1.20
log
@mostly ansi cleanup; pval ok
@
text
@d1 1
a1 1
/*	$OpenBSD: tty.c,v 1.19 2002/08/28 19:48:29 art Exp $	*/
d8 1
a8 1
 * this as a reasonable way to allow for widly varying and ever changing
d18 1
a18 1
 * has not been extensivly tested.
d25 1
a25 1
 * rather than the assuption that scrolling region operations look better.
d42 1
a42 1
static void	winchhandler(int);
d131 1
a131 1
	if (enter_ca_mode) {
d134 2
a135 2
	}
	if (keypad_xmit) {
a137 1
	}
d284 1
a284 1
 * presence of the echo area makes a boundry condition go away.
d287 1
a287 2
ttdell(row, bot, nchunk)
	int row, bot, nchunk;
d340 1
a340 2
ttwindow(top, bot)
	int top, bot;
d380 1
a380 2
ttcolor(color)
	int color;
d432 1
a432 1
	return 0;
@


1.19
log
@ANSIfication uncovers function argument bugs. How unusual.
@
text
@d1 1
a1 1
/*	$OpenBSD: tty.c,v 1.18 2002/08/23 18:43:49 vincent Exp $	*/
d223 1
a223 1
ttbeep()
d363 1
a363 1
ttnowindow()
@


1.18
log
@ansi
@
text
@d1 1
a1 1
/*	$OpenBSD: tty.c,v 1.17 2002/07/01 18:01:40 vincent Exp $	*/
d433 1
a433 1
fakec(char c)
@


1.17
log
@ just make vtresize return TRUE/FALSE instead of 0/-1, for consistency with
the rest of the mg code. + some KNF.

 adapted from diff by zyrnix.
@
text
@d1 1
a1 1
/*	$OpenBSD: tty.c,v 1.16 2002/02/21 04:16:23 deraadt Exp $	*/
d55 1
a55 1
ttinit()
d129 1
a129 1
ttreinit()
d131 1
a131 1
	if (enter_ca_mode)
d134 2
a135 1
	if (keypad_xmit)
d138 1
d150 1
a150 1
tttidy()
d167 1
a167 2
ttmove(row, col)
	int row, col;
d180 1
a180 1
tteeol()
d198 1
a198 1
tteeop()
d236 1
a236 2
ttinsl(row, bot, nchunk)
	int row, bot, nchunk;
d407 1
a407 1
ttresize()
d433 1
a433 2
fakec(c)
	char c;
d441 1
a441 2
charcost(s)
	char *s;
@


1.16
log
@remove a wrapper around getenv()
@
text
@d1 1
a1 1
/*	$OpenBSD: tty.c,v 1.15 2002/02/21 00:02:04 deraadt Exp $	*/
d424 1
a424 1
	if (vtresize(1, newrow, newcol))
a425 2
	nrow = newrow;
	ncol = newcol;
@


1.15
log
@signal-safe window size changing
@
text
@d1 1
a1 1
/*	$OpenBSD: tty.c,v 1.14 2002/02/16 21:27:49 millert Exp $	*/
d59 1
a59 6
/* system dependent function to determine terminal type, if necessary. */
#ifndef gettermtype
	char	*gettermtype();
#endif /* gettermtype */

	if ((tv_stype = gettermtype()) == NULL)
@


1.14
log
@Part one of userland __P removal.  Done with a simple regexp with some minor hand editing to make comments line up correctly.  Another pass is forthcoming that handles the cases that could not be done automatically.
@
text
@d1 1
a1 1
/*	$OpenBSD: tty.c,v 1.13 2002/02/14 14:24:21 deraadt Exp $	*/
a41 1
#ifdef I_WANT_SIGNAL_RACES
d47 1
a47 1
	refresh(0,0);
a48 1
#endif
a71 1
#ifdef I_WANT_SIGNAL_RACES
d73 2
a74 1
#endif
@


1.13
log
@some KNF
@
text
@d1 1
a1 1
/*	$OpenBSD: tty.c,v 1.12 2002/02/05 20:47:32 art Exp $	*/
d36 1
a36 1
static int	 charcost	__P((char *));
@


1.12
log
@Get rid of signal race (and handling of SIGWINCH).
New code is almost done, but not really tested yet.
@
text
@d1 1
a1 1
/*	$OpenBSD: tty.c,v 1.11 2002/01/18 08:37:08 art Exp $	*/
d374 1
a374 1
		       (nrow > lines ? nrow : lines) - 1, 0), nrow - ttrow);
@


1.11
log
@Remove the NROW and NCOL limits. The static arrays are now replaced with
dynamically allocated memory.
Code written by Vincent Labrecque <limitln@@Psyfreaks.CA> with some minor
tweaks by me.
@
text
@d1 1
a1 1
/*	$OpenBSD: tty.c,v 1.10 2002/01/10 12:13:35 art Exp $	*/
d42 1
d50 1
d74 1
d76 1
@


1.10
log
@Clean up tty resizing code.
Catch SIGWINCH and resize and refresh the screen.
@
text
@d1 1
a1 1
/*	$OpenBSD: tty.c,v 1.9 2001/05/24 03:05:26 mickey Exp $	*/
d102 1
a102 1
		tcinsl = NROW * NCOL;
d114 1
a114 1
		tcdell = NROW * NCOL;
d403 1
a403 3
 * to resize the display. The new size, which must not exceed the NROW
 * and NCOL limits, is stored back into "nrow" and * "ncol". Display can
 * always deal with a screen NROW by NCOL. Look in "window.c" to see how
d405 3
d412 2
d418 3
a420 3
		nrow = winsize.ws_row;
		ncol = winsize.ws_col;
	} else nrow = 0;
d422 9
a430 11
	if ((nrow <= 0 || ncol <= 0) &&
	    ((nrow = lines) <= 0 || (ncol = columns) <= 0)) {
		nrow = 24;
		ncol = 80;
	}

	/* Enforce maximum screen size. */
	if (nrow > NROW)
		nrow = NROW;
	if (ncol > NCOL)
		ncol = NCOL;
@


1.9
log
@spaces
@
text
@d1 1
a1 1
/*	$OpenBSD: tty.c,v 1.8 2001/05/23 22:20:36 art Exp $	*/
d30 3
d34 1
a34 4

#ifdef NO_RESIZE
static int	 setttysize	__P((void));
#endif /* NO_RESIZE */
d42 8
d72 1
d124 1
a124 1
	setttysize();
d141 1
a141 1
	setttysize();
d411 13
a423 2
	/* found in "ttyio.c" */
	setttysize();
d425 2
a426 4
	/* ask OS for tty size and check limits */
	if (nrow < 1)
		nrow = 1;
	else if (nrow > NROW)
d428 1
a428 3
	if (ncol < 1)
		ncol = 1;
	else if (ncol > NCOL)
a430 9

#ifdef NO_RESIZE
static
setttysize()
{
	nrow = lines;
	ncol = columns;
}
#endif /* NO_RESIZE */
@


1.8
log
@remove VOID. We're way beyond the point where this could build with an
ancient compiler.
@
text
@d1 1
a1 1
/*	$OpenBSD: tty.c,v 1.7 2001/01/29 01:58:10 niklas Exp $	*/
d108 1
a108 1
	insdel = (insert_line || parm_insert_line) && 
d136 2
a137 2
 * Clean up the terminal, in anticipation of a return to the command 
 * interpreter. This is a no-op on the ANSI display. On the SCALD display, 
d223 3
a225 3
 * Insert nchunk blank line(s) onto the screen, scrolling the last line on 
 * the screen off the bottom.  Use the scrolling region if possible for a 
 * smoother display.  If there is no scrolling region, use a set of insert 
d276 3
a278 3
 * Delete nchunk line(s) from "row", replacing the bottom line on the 
 * screen with a blank line.  Unless we're using the scrolling region, 
 * this is done with crafty sequences of insert and delete lines.  The 
d328 5
a332 5
 * This routine sets the scrolling window on the display to go from line 
 * "top" to line "bot" (origin 0, inclusive).  The caller checks for the 
 * pathological 1-line scroll window which doesn't work right and avoids 
 * it.  The "ttrow" and "ttcol" variables are set to a crazy value to 
 * ensure that the next call to "ttmove" does not turn into a no-op (the 
d349 5
a353 5
 * Switch to full screen scroll. This is used by "spawn.c" just before it 
 * suspends the editor and by "display.c" when it is getting ready to 
 * exit.  This function does a full screen scroll by telling the terminal 
 * to set a scrolling region that is lines or nrow rows high, whichever is 
 * larger.  This behavior seems to work right on systems where you can set 
d370 1
a370 1
 * Set the current writing color to the specified color. Watch for color 
d372 2
a373 2
 * and don't send anything to the display.  The rainbow version does this 
 * in putline.s on a line by line basis, so don't bother sending out the 
d393 4
a396 4
 * This routine is called by the "refresh the screen" command to try 
 * to resize the display. The new size, which must not exceed the NROW 
 * and NCOL limits, is stored back into "nrow" and * "ncol". Display can 
 * always deal with a screen NROW by NCOL. Look in "window.c" to see how 
d426 1
a426 1
 * fake char output for charcost() 
@


1.7
log
@$OpenBSD$
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d46 1
a46 1
VOID
d122 1
a122 1
VOID
d141 1
a141 1
VOID
d158 1
a158 1
VOID
d172 1
a172 1
VOID
d190 1
a190 1
VOID
d215 1
a215 1
VOID
d228 1
a228 1
VOID
d281 1
a281 1
VOID
d335 1
a335 1
VOID
d356 1
a356 1
VOID
d376 1
a376 1
VOID
d399 1
a399 1
VOID
@


1.6
log
@More -Wall anmd KNF, from op2@@tomahawk.SQUiSH.org
@
text
@d1 2
@


1.5
log
@The start of KNF + -Wall.  The code has been run through indent but
needs hand fixup.  I stopped at keymap.c...
@
text
@a24 1
#include	"def.h"
d26 1
a26 1
#include	<term.h>
d28 1
a28 5
extern int      ttrow;
extern int      ttcol;
extern int      tttop;
extern int      ttbot;
extern int      tthue;
d30 3
a32 5
extern int      ttputc();

int             tceeol;		/* Costs are set later */
int             tcinsl;
int             tcdell;
d34 1
a34 2
static int      insdel;		/* Do we have both insert & delete line? */
static char    *scroll_fwd;	/* How to scroll forward. */
d36 3
a38 3
#ifdef NO_RESIZE
static          setttysize();
#endif
d47 6
a52 6
	char           *tv_stype;
	char           *t, *p;
#ifndef gettermtype		/* (avoid declaration if #define) */
	char           *gettermtype();	/* system dependent function to
					 * determin terminal type */
#endif
d55 2
a56 1
		panic("Could not determine terminal type");
d58 1
a58 1
		(void) asprintf(&p, "Unknown terminal type: %s", tv_stype);
d61 1
d63 1
a63 1
	if (!scroll_fwd || !*scroll_fwd) {
d66 1
a66 1
		if (!scroll_fwd || !*scroll_fwd)
d69 6
a74 3
	if (!cursor_address || !cursor_up)
		panic("This terminal is to stupid to run mg");
	ttresize();		/* set nrow & ncol	 */
d84 1
a84 1
			charcost(scroll_reverse);
d90 2
a91 1
		tcinsl = NROW * NCOL;	/* make this cost high enough */
d96 1
a96 1
			charcost(scroll_fwd);
d102 2
a103 1
		tcdell = NROW * NCOL;	/* make this cost high enough */
d106 2
a107 1
	insdel = (insert_line || parm_insert_line) && (delete_line || parm_delete_line);
d110 2
a111 1
		putpad(enter_ca_mode, 1);	/* enter application mode */
d124 2
a125 1
		putpad(enter_ca_mode, 1);	/* enter application mode */
d127 2
a128 1
		putpad(keypad_xmit, 1);		/* turn on keypad */
d134 4
a137 6
 * Clean up the terminal, in anticipation of
 * a return to the command interpreter. This is a no-op
 * on the ANSI display. On the SCALD display, it sets the
 * window back to half screen scrolling. Perhaps it should
 * query the display for the increment, and put it
 * back to what it was.
a141 1

d144 2
a145 1
#endif
d152 2
a153 4
 * Move the cursor to the specified
 * origin 0 row and column position. Try to
 * optimize out extra moves; redisplay may
 * have left the cursor in the right
d158 1
a159 2
	char           *tgoto();

d173 1
d178 1
a178 1
		int             i = ncol - ttcol;
d191 1
a191 1
	int             line;
d199 2
a200 1
		else {		/* do it by hand */
d221 4
a224 6
 * Insert nchunk blank line(s) onto the
 * screen, scrolling the last line on the
 * screen off the bottom.  Use the scrolling
 * region if possible for a smoother display.
 * If no scrolling region, use a set
 * of insert and delete line sequences
d228 1
d230 1
a230 1
	int             i, nl;
d232 3
a234 2
	if (row == bot) {	/* Case of one line insert is	 */
		ttmove(row, 0);	/* special			 */
d253 1
a253 1
			/* For all lines in the chunk	 */
d257 4
a260 1
		nl = nrow - ttrow;	/* ttmove() changes ttrow */
d274 4
a277 6
 * Delete nchunk line(s) from "row", replacing the
 * bottom line on the screen with a blank line.
 * Unless we're using the scrolling region, this is
 * done with a crafty sequences of insert and delete
 * lines.  The presence of the echo area makes a
 * boundry condition go away.
d281 1
d283 1
a283 1
	int             i, nl;
d285 2
a286 1
	if (row == bot) {	/* One line special case	 */
d291 2
a292 1
	if (change_scroll_region) {	/* scrolling region		 */
d299 1
d301 1
a301 1
		ttmove(row, 0);	/* Else use insert/delete line	 */
d310 3
a312 1
		nl = nrow - ttrow;	/* ttmove() changes ttrow */
d326 6
a331 10
 * This routine sets the scrolling window
 * on the display to go from line "top" to line
 * "bot" (origin 0, inclusive). The caller checks
 * for the pathalogical 1 line scroll window that
 * doesn't work right, and avoids it. The "ttrow"
 * and "ttcol" variables are set to a crazy value
 * to ensure that the next call to "ttmove" does
 * not turn into a no-op (the window adjustment
 * moves the cursor).
 *
d335 1
d347 6
a352 8
 * Switch to full screen scroll. This is
 * used by "spawn.c" just before is suspends the
 * editor, and by "display.c" when it is getting ready
 * to exit.  This function gets to full screen scroll
 * by telling the terminal to set a scrolling regin
 * that is lines or nrow rows high, whichever is larger.
 * This behavior seems to work right on systems
 * where you can set your terminal size.
d368 5
a372 7
 * Set the current writing color to the
 * specified color. Watch for color changes that are
 * not going to do anything (the color is already right)
 * and don't send anything to the display.
 * The rainbow version does this in putline.s on a
 * line by line basis, so don't bother sending
 * out the color shift.
d376 1
a376 1
	int             color;
a377 1

d379 2
a380 1
		if (color == CTEXT)	/* Normal video.	 */
d382 2
a383 1
		else if (color == CMODE)	/* Reverse video.	 */
d385 2
a386 1
		tthue = color;	/* Save the color.	 */
d391 5
a395 7
 * This routine is called by the
 * "refresh the screen" command to try and resize
 * the display. The new size, which must be deadstopped
 * to not exceed the NROW and NCOL limits, it stored
 * back into "nrow" and "ncol". Display can always deal
 * with a screen NROW by NCOL. Look in "window.c" to
 * see how the caller deals with a change.
d400 2
d403 2
a404 3
	setttysize();		/* found in "ttyio.c",	 */
	/* ask OS for tty size	 */
	if (nrow < 1)		/* Check limits.	 */
d421 1
a421 3
#endif

static int      cci;
d423 3
d427 1
a427 1
static int			/* fake char output for charcost() */
d429 1
a429 1
	char            c;
d432 1
d436 1
d438 1
a438 1
	char           *s;
d440 1
a440 1
	cci = 0;
@


1.4
log
@Reverse rutgers change (attachtoparent vs. spawncli)

New ttreinit function that enters application mode, enables the keypad
and resets the tty size.

New spawn module that calls tttidy() to exit application mode (and cleanup)
then calls ttreinit() after resume to get back into application mode.  Assumes
we have job control.  This takes advantage of the xterm 'alternate screen'.
@
text
@d9 5
a13 6
/* Known problems:
 *	If you have a terminal with no clear to end of screen and
 *	memory of lines below the ones visible on the screen, display
 *	will be wrong in some cases.  I doubt that any such terminal
 *	was ever made, but I thought everyone with delete line would
 *	have clear to end of screen too...
d15 2
a16 2
 *	Code for terminals without clear to end of screen and/or clear
 *	to end of line has not been extensivly tested.
d18 3
a20 3
 *	Cost calculations are very rough.  Costs of insert/delete line
 *	may be far from the truth.  This is accentuated by display.c
 *	not knowing about multi-line insert/delete.
d22 2
a23 3
 *	Using scrolling region vs insert/delete line should probably
 *	be based on cost rather than the assuption that scrolling
 *	region operations look better.
a26 1
#include	<curses.h>
d29 11
a39 11
extern	int	ttrow;
extern	int	ttcol;
extern	int	tttop;
extern	int	ttbot;
extern	int	tthue;

extern	int	ttputc();

int	tceeol;			/* Costs are set later */
int	tcinsl;
int	tcdell;
d41 2
a42 2
static	int	insdel;		/* Do we have both insert & delete line? */
static	char *	scroll_fwd;	/* How to scroll forward. */
d45 1
a45 1
static	setttysize();
d52 5
a56 3
ttinit() {
	char *tv_stype;
	char *t, *p;
d58 2
a59 1
	char *gettermtype();	/* system dependent function to determin terminal type */
d64 1
a64 1
	if (setupterm(tv_stype, 1, NULL) == ERR) {
a67 1

a74 1

d77 1
a77 1
	ttresize();			/* set nrow & ncol	*/
d86 2
a87 2
		tcinsl = charcost(change_scroll_region)*2 +
				  charcost(scroll_reverse);
d97 2
a98 2
		tcdell = charcost(change_scroll_region)*2 +
				  charcost(scroll_fwd);
d103 1
a103 1
	else	
d110 1
a110 1
		putpad(enter_ca_mode, 1);	/* init the term */
d119 3
a121 1
ttreinit() {
d138 3
a140 1
tttidy() {
d142 3
a147 3
#ifdef	XKEYS
	ttykeymaptidy();
#endif
d157 4
a160 2
ttmove(row, col) {
    char	*tgoto();
d162 5
a166 5
    if (ttrow != row || ttcol !=col) {
	    putpad(tgoto(cursor_address, col, row), 1);
	    ttrow = row;
	    ttcol = col;
    }
d172 3
a174 1
tteeol() {
d179 1
a179 1
		int i = ncol - ttcol;
d189 4
a192 2
tteeop() {
	int line;
d213 3
a215 1
ttbeep() {
d228 4
a231 2
ttinsl(row, bot, nchunk) {
	int	i, nl;
d233 2
a234 2
	if (row == bot) {		/* Case of one line insert is	*/
		ttmove(row, 0);		/*	special			*/
d239 1
a239 1
		/* Use scroll region and back index	*/
d241 1
a241 1
		ttwindow(row,bot);
d248 1
a248 1
		ttmove(1+bot-nchunk, 0);
d253 2
a254 2
			/* For all lines in the chunk	*/
			for (i=0; i<nchunk; i++)
d262 1
a262 1
			for (i=0; i<nchunk; i++)
d278 1
d281 1
a281 1
	int	i, nl;
d283 1
a283 1
	if (row == bot) {		/* One line special case	*/
d288 1
a288 1
	if (change_scroll_region) {	/* scrolling region		*/
d295 2
a296 3
	}
	else if (insdel) {
		ttmove(row, 0);		/* Else use insert/delete line	*/
d301 2
a302 2
			/* For all lines in the chunk	*/
			for (i=0; i<nchunk; i++)
d304 1
a304 1
		ttmove(1+bot-nchunk,0);
d310 1
a310 1
			for (i=0; i<nchunk; i++)
d330 1
d335 1
a335 1
		ttrow = HUGE;			/* Unknown.		*/
d337 1
a337 1
		tttop = top;			/* Remember region.	*/
d352 1
d357 2
a358 2
		    (nrow > lines ? nrow : lines) - 1, 0), nrow - ttrow);
		ttrow = HUGE;			/* Unknown.		*/
d360 1
a360 1
		tttop = HUGE;			/* No scroll region.	*/
d374 1
d376 1
a376 1
	int color;
d380 5
a384 5
	    if (color == CTEXT)			/* Normal video.	*/
		    putpad(exit_standout_mode, 1);
	    else if (color == CMODE)		/* Reverse video.	*/
		    putpad(enter_standout_mode, 1);
	    tthue = color;			/* Save the color.	*/
d397 3
a399 1
ttresize() {
d401 3
a403 3
	setttysize();			/* found in "ttyio.c",	*/
					/* ask OS for tty size	*/
	if (nrow < 1)			/* Check limits.	*/
d414 3
a416 1
static setttysize() {
d422 1
a422 1
static int cci;
d424 2
a425 2
/*ARGSUSED*/
static int		/* fake char output for charcost() */
d427 1
a427 1
char c;
d433 3
a435 1
charcost (s) char *s; {
@


1.3
log
@Call setttysize() from ttinit() not ttopen() since we haven't
run setupterm() until ttinit() is called.
Remove a tgetnum() I missed in the termcap -> terminfo cleanup.
Merge parts of the BSD ttyio.c.  The termios stuff here could use a
cleanup, possibly including the flow control hack from the BSD ttyio.c.
@
text
@d118 13
@


1.2
log
@change WINDOW -> MGWIN to avoid curses type conflict
convert to terminfo in tty*.c
add support for some keypad function keys (arrows, pgup, pgdown)
@
text
@d113 2
d385 2
a386 2
	nrow = tgetnum("li");
	ncol = tgetnum("co");
@


1.1
log
@initial import of mg2a
@
text
@d2 1
a2 1
 * Termcap/terminfo display driver
d4 2
a5 2
 * Termcap is a terminal information database and routines to describe
 * terminals on most UNIX systems.  Many other systems have adopted
d29 2
a30 1
#define BEL	0x07			/* BEL character.		*/
d38 2
d45 1
a50 40
char	*tgetstr();
char	*tgoto();
int	ttputc();

#define TCAPSLEN 1024

char tcapbuf[TCAPSLEN];

/* PC, UP, and BC are used by termlib, so must be extern and have these
 * names unless you have a non-standard termlib.
 */

int	LI;			/* standard # lines */
char	PC,
	*CM,
	*CE,
	*UP,
	*BC,
	*IM,			/* insert mode */
	*IC,			/* insert a single space */
	*EI,			/* end insert mode */
	*DC,
	*AL,			/* add line */
	*DL,			/* del line */
	*pAL,			/* parameterized add line */
	*pDL,			/* parameterized delete line */
	*TI,			/* term init -- start using cursor motion */
	*TE,			/* term end --- end using cursor motion */
	*SO,
	*SE,
	*CD,
	*CS,			/* set scroll region			*/
	*SF,			/* forw index (used with scroll region)	*/
	*SR;			/* back index (used with scroll region)	*/
#ifdef	XKEYS
char	*KS, *KE;		/* enter keypad mode, exit keypad mode	*/
#endif
int	SG;	/* number of glitches, 0 for invisible, -1 for none	*/
	/* (yes virginia, there are terminals with invisible glitches)	*/

a54 2
static char tcbuf[1024];

d57 1
a57 1
	char *t, *p, *tgetstr();
d62 1
a62 1
	if((tv_stype = gettermtype()) == NULL)
d64 3
a66 4
	if((tgetent(tcbuf, tv_stype)) != 1) {
		(VOID) strcpy(tcbuf, "Unknown terminal type ");
		(VOID) strcat(tcbuf, tv_stype);
		panic(tcbuf);
d69 6
a74 30
	p = tcapbuf;
	t = tgetstr("pc", &p);
	if(t) PC = *t;

	LI = tgetnum("li");
	CD = tgetstr("cd", &p);
	CM = tgetstr("cm", &p);
	CE = tgetstr("ce", &p);
	UP = tgetstr("up", &p);
	BC = tgetstr("bc", &p);
	IM = tgetstr("im", &p);
	IC = tgetstr("ic", &p);
	EI = tgetstr("ei", &p);
	DC = tgetstr("dc", &p);
	AL = tgetstr("al", &p);
	DL = tgetstr("dl", &p);
	pAL= tgetstr("AL", &p);	/* parameterized insert and del. line */
	pDL= tgetstr("DL", &p);
	TI = tgetstr("ti", &p);
	TE = tgetstr("te", &p);
	SO = tgetstr("so", &p);
	SE = tgetstr("se", &p);
	CS = tgetstr("cs", &p); /* set scrolling region */
	SF = tgetstr("sf", &p);
	if(!SF || !*SF) {	/* this is what GNU Emacs does */
	    SF = tgetstr("do", &p);
	    if(!SF || !*SF) {
		SF = tgetstr("nl", &p);
		if(!SF || !*SF) SF = "\n";
	    }
a75 6
	SR = tgetstr("sr", &p);
	SG = tgetnum("sg");	/* standout glitch	*/
#ifdef	XKEYS
	KS = tgetstr("ks", &p);	/* keypad start, keypad end	*/
	KE = tgetstr("ke", &p);
#endif
d77 2
a78 2
	if(CM == NULL || UP == NULL)
	    panic("This terminal is to stupid to run MicroGnuEmacs\n");
d81 4
a84 12
	/* watch out for empty capabilities (sure to be wrong)	*/
	if (CE && !*CE) CE = NULL;
	if (CS && !*CS) CS = NULL;
	if (SR && !*SR) SR = NULL;
	if (AL && !*AL) AL = NULL;
	if (DL && !*DL) DL = NULL;
	if (pAL && !*pAL) pAL = NULL;
	if (pDL && !*pDL) pDL = NULL;
	if (CD && !*CD) CD = NULL;

	if(!CE) tceeol = ncol;
	else	tceeol = charcost(CE);
d87 9
a95 4
	if (CS && SR)	tcinsl = charcost(CS)*2 + charcost(SR);
	else if (pAL)	tcinsl = charcost(pAL);
	else if (AL)	tcinsl = charcost(AL);
	else		tcinsl = NROW * NCOL;	/* make this cost high enough */
d98 9
a106 4
	if (CS)		tcdell = charcost(CS)*2 + charcost(SF);
	else if (pDL)	tcdell = charcost(pDL);
	else if (DL)	tcdell = charcost(DL);
	else		tcdell = NROW * NCOL;	/* make this cost high enough */
d109 1
a109 1
	insdel = (AL || pAL) && (DL || pDL);
d111 2
a112 3
	if (p >= &tcapbuf[TCAPSLEN])
		panic("Terminal description too big!\n");
	if (TI && *TI) putpad(TI, 1);	/* init the term */
d124 4
a127 1
	if (TE && *TE) putpad(TE, 1);	/* set the term back to normal mode */
d143 4
a146 4
    if (ttrow!=row || ttcol!=col) {
	putpad(tgoto(CM, col, row), 1);
	ttrow = row;
	ttcol = col;
d154 9
a162 6
    if(CE) putpad(CE, 1);
    else {
	register int i=ncol-ttcol;
	while(i--) ttputc(' ');
	ttrow = ttcol = HUGE;
    }
d169 15
a183 10
    if(CD) putpad(CD, nrow - ttrow);
    else {
	putpad(CE, 1);
	if (insdel) ttdell(ttrow + 1, LI, LI - ttrow - 1);
	else {		/* do it by hand */
	    register int line;
	    for (line = ttrow + 1; line <= LI; ++line) {
		ttmove(line, 0);
		tteeol();
	    }
a184 2
	ttrow = ttcol = HUGE;
    }
d191 1
a191 1
	ttputc(BEL);
d204 1
a204 1
    register int	i, nl;
d206 35
a240 26
    if (row == bot) {		/* Case of one line insert is	*/
	ttmove(row, 0);		/*	special			*/
	tteeol();
	return;
    }
    if (CS && SR) {		/* Use scroll region and back index	*/
	nl = bot - row;
	ttwindow(row,bot);
	ttmove(row, 0);
	while (nchunk--) putpad(SR, nl);
	ttnowindow();
	return;
    } else if (insdel) {
	ttmove(1+bot-nchunk, 0);
	nl = nrow - ttrow;
	if (pDL) putpad(tgoto(pDL, 0, nchunk), nl);
	else for (i=0; i<nchunk; i++)	/* For all lines in the chunk	*/
		putpad(DL, nl);
	ttmove(row, 0);
	nl = nrow - ttrow;	/* ttmove() changes ttrow */
	if (pAL) putpad(tgoto(pAL, 0, nchunk), nl);
	else for (i=0; i<nchunk; i++)	/* For all lines in the chunk	*/
		putpad(AL, nl);
	ttrow = HUGE;
	ttcol = HUGE;
    } else panic("ttinsl: Can't insert/delete line");
d253 1
a253 1
    register int	i, nl;
d255 34
a288 26
    if (row == bot) {		/* One line special case	*/
	ttmove(row, 0);
	tteeol();
	return;
    }
    if (CS) {			/* scrolling region	*/
	nl = bot - row;
	ttwindow(row, bot);
	ttmove(bot, 0);
	while (nchunk--) putpad(SF, nl);
	ttnowindow();
    }
    else if(insdel) {
	ttmove(row, 0);			/* Else use insert/delete line	*/
	nl = nrow - ttrow;
	if (pDL) putpad(tgoto(pDL, 0, nchunk), nl);
	else for (i=0; i<nchunk; i++)	/* For all lines in the chunk	*/
		putpad(DL, nl);
	ttmove(1+bot-nchunk,0);
	nl = nrow - ttrow;	/* ttmove() changes ttrow */
	if (pAL) putpad(tgoto(pAL, 0, nchunk), nl);
	else for (i=0; i<nchunk; i++)	/* For all lines in the chunk	*/
		putpad(AL, nl);
	ttrow = HUGE;
	ttcol = HUGE;
    } else panic("ttdell: Can't insert/delete line");
d305 2
a306 2
	if (CS && (tttop!=top || ttbot!=bot)) {
		putpad(tgoto(CS, bot, top), nrow - ttrow);
d320 1
a320 1
 * that is LI or nrow rows high, whichever is larger.
d326 8
a333 7
    if (CS) {
	putpad(tgoto(CS, (nrow > LI ? nrow : LI) - 1, 0), nrow - ttrow);
	ttrow = HUGE;			/* Unknown.		*/
	ttcol = HUGE;
	tttop = HUGE;			/* No scroll region.	*/
	ttbot = HUGE;
    }
d345 10
a354 6
ttcolor(color) register int color; {
    if (color != tthue) {
	if (color == CTEXT) {		/* Normal video.	*/
	    putpad(SE, 1);
	} else if (color == CMODE) {	/* Reverse video.	*/
	    putpad(SO, 1);
a355 2
	tthue = color;			/* Save the color.	*/
    }
d368 1
d400 1
a400 1
    cci = 0;
d402 2
a403 2
    tputs(s, nrow, fakec);
    return cci;
@

