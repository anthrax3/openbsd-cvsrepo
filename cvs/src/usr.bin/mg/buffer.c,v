head	1.104;
access;
symbols
	OPENBSD_6_2_BASE:1.104
	OPENBSD_6_1:1.103.0.4
	OPENBSD_6_1_BASE:1.103
	OPENBSD_6_0:1.100.0.4
	OPENBSD_6_0_BASE:1.100
	OPENBSD_5_9:1.100.0.2
	OPENBSD_5_9_BASE:1.100
	OPENBSD_5_8:1.98.0.4
	OPENBSD_5_8_BASE:1.98
	OPENBSD_5_7:1.94.0.2
	OPENBSD_5_7_BASE:1.94
	OPENBSD_5_6:1.94.0.4
	OPENBSD_5_6_BASE:1.94
	OPENBSD_5_5:1.92.0.4
	OPENBSD_5_5_BASE:1.92
	OPENBSD_5_4:1.91.0.2
	OPENBSD_5_4_BASE:1.91
	OPENBSD_5_3:1.90.0.2
	OPENBSD_5_3_BASE:1.90
	OPENBSD_5_2:1.78.0.2
	OPENBSD_5_2_BASE:1.78
	OPENBSD_5_1_BASE:1.77
	OPENBSD_5_1:1.77.0.6
	OPENBSD_5_0:1.77.0.4
	OPENBSD_5_0_BASE:1.77
	OPENBSD_4_9:1.77.0.2
	OPENBSD_4_9_BASE:1.77
	OPENBSD_4_8:1.74.0.2
	OPENBSD_4_8_BASE:1.74
	OPENBSD_4_7:1.73.0.2
	OPENBSD_4_7_BASE:1.73
	OPENBSD_4_6:1.73.0.4
	OPENBSD_4_6_BASE:1.73
	OPENBSD_4_5:1.68.0.2
	OPENBSD_4_5_BASE:1.68
	OPENBSD_4_4:1.67.0.6
	OPENBSD_4_4_BASE:1.67
	OPENBSD_4_3:1.67.0.4
	OPENBSD_4_3_BASE:1.67
	OPENBSD_4_2:1.67.0.2
	OPENBSD_4_2_BASE:1.67
	OPENBSD_4_1:1.66.0.2
	OPENBSD_4_1_BASE:1.66
	OPENBSD_4_0:1.63.0.2
	OPENBSD_4_0_BASE:1.63
	OPENBSD_3_9:1.54.0.2
	OPENBSD_3_9_BASE:1.54
	OPENBSD_3_8:1.44.0.2
	OPENBSD_3_8_BASE:1.44
	OPENBSD_3_7:1.36.0.2
	OPENBSD_3_7_BASE:1.36
	OPENBSD_3_6:1.34.0.2
	OPENBSD_3_6_BASE:1.34
	OPENBSD_3_5:1.33.0.2
	OPENBSD_3_5_BASE:1.33
	OPENBSD_3_4:1.32.0.2
	OPENBSD_3_4_BASE:1.32
	OPENBSD_3_3:1.30.0.4
	OPENBSD_3_3_BASE:1.30
	OPENBSD_3_2:1.30.0.2
	OPENBSD_3_2_BASE:1.30
	OPENBSD_3_1:1.28.0.2
	OPENBSD_3_1_BASE:1.28
	OPENBSD_3_0:1.16.0.2
	OPENBSD_3_0_BASE:1.16
	OPENBSD_2_9_BASE:1.5
	OPENBSD_2_9:1.5.0.2
	OPENBSD_2_8:1.4.0.2
	OPENBSD_2_8_BASE:1.4
	OPENBSD_2_7:1.3.0.2
	OPENBSD_2_7_BASE:1.3;
locks; strict;
comment	@ * @;


1.104
date	2017.08.06.04.39.45;	author bcallah;	state Exp;
branches;
next	1.103;
commitid	OgoyN2WL9YbKQ9Of;

1.103
date	2017.03.13.20.32.58;	author florian;	state Exp;
branches;
next	1.102;
commitid	GGcygsPqll92Wiyw;

1.102
date	2016.09.07.11.42.01;	author lum;	state Exp;
branches;
next	1.101;
commitid	0LWG5ApvRyMJNyOa;

1.101
date	2016.08.31.12.22.28;	author lum;	state Exp;
branches;
next	1.100;
commitid	vInFVabTWHd4Tdy4;

1.100
date	2015.10.10.08.35.26;	author lum;	state Exp;
branches;
next	1.99;
commitid	UpI6NYgP3f6p0UoQ;

1.99
date	2015.09.26.21.51.58;	author jasper;	state Exp;
branches;
next	1.98;
commitid	yS81WdIVlzEJxLUH;

1.98
date	2015.03.23.12.31.19;	author bcallah;	state Exp;
branches;
next	1.97;
commitid	WS4uMCRyR8aXfh6U;

1.97
date	2015.03.19.21.48.05;	author bcallah;	state Exp;
branches;
next	1.96;
commitid	8rkHsVfUx5xgPXRB;

1.96
date	2015.03.19.21.22.15;	author bcallah;	state Exp;
branches;
next	1.95;
commitid	GbEBL4CfPvDkB8hj;

1.95
date	2015.03.16.13.47.48;	author bcallah;	state Exp;
branches;
next	1.94;
commitid	gSveQVkxMLs6vRqK;

1.94
date	2014.06.12.16.29.41;	author bcallah;	state Exp;
branches;
next	1.93;
commitid	xBj5WGBVVssizpJ6;

1.93
date	2014.03.20.07.47.29;	author lum;	state Exp;
branches;
next	1.92;

1.92
date	2013.12.23.14.58.16;	author lum;	state Exp;
branches;
next	1.91;

1.91
date	2013.06.02.10.09.21;	author lum;	state Exp;
branches;
next	1.90;

1.90
date	2013.02.17.10.30.26;	author florian;	state Exp;
branches;
next	1.89;

1.89
date	2013.02.15.15.12.25;	author florian;	state Exp;
branches;
next	1.88;

1.88
date	2012.12.27.18.51.52;	author florian;	state Exp;
branches;
next	1.87;

1.87
date	2012.11.06.18.04.10;	author florian;	state Exp;
branches;
next	1.86;

1.86
date	2012.11.03.14.51.41;	author haesbaert;	state Exp;
branches;
next	1.85;

1.85
date	2012.10.23.20.51.17;	author florian;	state Exp;
branches;
next	1.84;

1.84
date	2012.10.22.08.31.42;	author florian;	state Exp;
branches;
next	1.83;

1.83
date	2012.10.22.08.22.04;	author florian;	state Exp;
branches;
next	1.82;

1.82
date	2012.10.12.21.13.46;	author jasper;	state Exp;
branches;
next	1.81;

1.81
date	2012.08.31.18.06.42;	author lum;	state Exp;
branches;
next	1.80;

1.80
date	2012.08.30.06.25.30;	author lum;	state Exp;
branches;
next	1.79;

1.79
date	2012.08.30.06.09.12;	author lum;	state Exp;
branches;
next	1.78;

1.78
date	2012.03.14.13.56.35;	author lum;	state Exp;
branches;
next	1.77;

1.77
date	2011.01.23.00.45.03;	author kjell;	state Exp;
branches;
next	1.76;

1.76
date	2011.01.21.19.10.13;	author kjell;	state Exp;
branches;
next	1.75;

1.75
date	2011.01.18.17.35.42;	author lum;	state Exp;
branches;
next	1.74;

1.74
date	2010.06.30.19.12.54;	author oga;	state Exp;
branches;
next	1.73;

1.73
date	2009.06.05.18.37.13;	author deraadt;	state Exp;
branches;
next	1.72;

1.72
date	2009.06.04.23.56.50;	author kjell;	state Exp;
branches;
next	1.71;

1.71
date	2009.06.04.23.39.37;	author kjell;	state Exp;
branches;
next	1.70;

1.70
date	2009.06.04.02.23.37;	author kjell;	state Exp;
branches;
next	1.69;

1.69
date	2009.06.02.18.52.42;	author kjell;	state Exp;
branches;
next	1.68;

1.68
date	2008.09.15.16.11.35;	author kjell;	state Exp;
branches;
next	1.67;

1.67
date	2007.05.28.17.52.17;	author kjell;	state Exp;
branches;
next	1.66;

1.66
date	2006.11.19.16.51.19;	author deraadt;	state Exp;
branches;
next	1.65;

1.65
date	2006.11.18.23.05.24;	author kjell;	state Exp;
branches;
next	1.64;

1.64
date	2006.11.18.19.27.27;	author kjell;	state Exp;
branches;
next	1.63;

1.63
date	2006.07.25.08.27.09;	author kjell;	state Exp;
branches;
next	1.62;

1.62
date	2006.07.25.08.22.32;	author kjell;	state Exp;
branches;
next	1.61;

1.61
date	2006.07.08.17.50.30;	author kjell;	state Exp;
branches;
next	1.60;

1.60
date	2006.06.01.09.00.50;	author kjell;	state Exp;
branches;
next	1.59;

1.59
date	2006.06.01.01.41.49;	author kjell;	state Exp;
branches;
next	1.58;

1.58
date	2006.05.28.23.30.16;	author kjell;	state Exp;
branches;
next	1.57;

1.57
date	2006.05.02.17.10.25;	author kjell;	state Exp;
branches;
next	1.56;

1.56
date	2006.04.06.05.28.17;	author kjell;	state Exp;
branches;
next	1.55;

1.55
date	2006.04.03.00.40.56;	author deraadt;	state Exp;
branches;
next	1.54;

1.54
date	2005.12.20.06.17.35;	author kjell;	state Exp;
branches;
next	1.53;

1.53
date	2005.12.13.06.01.26;	author kjell;	state Exp;
branches;
next	1.52;

1.52
date	2005.11.18.20.56.52;	author deraadt;	state Exp;
branches;
next	1.51;

1.51
date	2005.11.13.07.49.02;	author kjell;	state Exp;
branches;
next	1.50;

1.50
date	2005.10.14.19.46.46;	author kjell;	state Exp;
branches;
next	1.49;

1.49
date	2005.10.14.06.44.49;	author kjell;	state Exp;
branches;
next	1.48;

1.48
date	2005.10.13.20.28.49;	author deraadt;	state Exp;
branches;
next	1.47;

1.47
date	2005.10.13.05.34.11;	author kjell;	state Exp;
branches;
next	1.46;

1.46
date	2005.10.11.01.08.52;	author kjell;	state Exp;
branches;
next	1.45;

1.45
date	2005.09.28.06.37.52;	author deraadt;	state Exp;
branches;
next	1.44;

1.44
date	2005.08.09.00.53.48;	author kjell;	state Exp;
branches;
next	1.43;

1.43
date	2005.06.14.18.14.40;	author kjell;	state Exp;
branches;
next	1.42;

1.42
date	2005.06.03.15.18.05;	author cloder;	state Exp;
branches;
next	1.41;

1.41
date	2005.06.03.08.23.12;	author kjell;	state Exp;
branches;
next	1.40;

1.40
date	2005.05.31.20.38.59;	author kjell;	state Exp;
branches;
next	1.39;

1.39
date	2005.05.25.05.57.32;	author jason;	state Exp;
branches;
next	1.38;

1.38
date	2005.05.15.21.19.08;	author cloder;	state Exp;
branches;
next	1.37;

1.37
date	2005.04.03.02.09.28;	author db;	state Exp;
branches;
next	1.36;

1.36
date	2005.03.10.16.58.57;	author deraadt;	state Exp;
branches;
next	1.35;

1.35
date	2005.03.09.16.20.48;	author jfb;	state Exp;
branches;
next	1.34;

1.34
date	2004.07.22.01.25.24;	author vincent;	state Exp;
branches;
next	1.33;

1.33
date	2003.10.21.22.48.07;	author vincent;	state Exp;
branches;
next	1.32;

1.32
date	2003.08.15.23.23.18;	author vincent;	state Exp;
branches;
next	1.31;

1.31
date	2003.06.26.23.04.10;	author vincent;	state Exp;
branches;
next	1.30;

1.30
date	2002.07.25.16.40.57;	author vincent;	state Exp;
branches;
next	1.29;

1.29
date	2002.06.19.22.05.58;	author vincent;	state Exp;
branches;
next	1.28;

1.28
date	2002.03.16.19.30.29;	author vincent;	state Exp;
branches;
next	1.27;

1.27
date	2002.03.16.04.17.36;	author vincent;	state Exp;
branches;
next	1.26;

1.26
date	2002.03.11.13.02.56;	author vincent;	state Exp;
branches;
next	1.25;

1.25
date	2002.03.05.20.31.10;	author vincent;	state Exp;
branches;
next	1.24;

1.24
date	2002.02.26.00.45.45;	author vincent;	state Exp;
branches;
next	1.23;

1.23
date	2002.02.21.00.04.10;	author dhartmei;	state Exp;
branches;
next	1.22;

1.22
date	2002.02.16.21.27.49;	author millert;	state Exp;
branches;
next	1.21;

1.21
date	2002.02.14.14.24.21;	author deraadt;	state Exp;
branches;
next	1.20;

1.20
date	2002.02.13.03.03.49;	author vincent;	state Exp;
branches;
next	1.19;

1.19
date	2002.01.18.09.40.07;	author art;	state Exp;
branches;
next	1.18;

1.18
date	2002.01.18.08.37.08;	author art;	state Exp;
branches;
next	1.17;

1.17
date	2001.11.25.07.34.17;	author deraadt;	state Exp;
branches;
next	1.16;

1.16
date	2001.08.18.21.36.11;	author deraadt;	state Exp;
branches;
next	1.15;

1.15
date	2001.05.24.03.05.20;	author mickey;	state Exp;
branches;
next	1.14;

1.14
date	2001.05.23.22.36.13;	author art;	state Exp;
branches;
next	1.13;

1.13
date	2001.05.23.22.26.24;	author art;	state Exp;
branches;
next	1.12;

1.12
date	2001.05.23.22.20.34;	author art;	state Exp;
branches;
next	1.11;

1.11
date	2001.05.23.15.50.27;	author art;	state Exp;
branches;
next	1.10;

1.10
date	2001.05.23.15.46.25;	author art;	state Exp;
branches;
next	1.9;

1.9
date	2001.05.23.15.39.35;	author art;	state Exp;
branches;
next	1.8;

1.8
date	2001.05.23.15.35.10;	author art;	state Exp;
branches;
next	1.7;

1.7
date	2001.05.04.22.00.35;	author art;	state Exp;
branches;
next	1.6;

1.6
date	2001.05.04.21.47.41;	author art;	state Exp;
branches;
next	1.5;

1.5
date	2001.01.29.01.58.06;	author niklas;	state Exp;
branches;
next	1.4;

1.4
date	2000.09.01.14.59.08;	author millert;	state Exp;
branches;
next	1.3;

1.3
date	2000.04.13.06.12.13;	author millert;	state Exp;
branches;
next	1.2;

1.2
date	2000.02.26.22.53.16;	author millert;	state Exp;
branches;
next	1.1;

1.1
date	2000.02.25.19.08.46;	author deraadt;	state Exp;
branches;
next	;


desc
@@


1.104
log
@Present the default choice before the colon in prompts. Matches GNU Emacs
behavior.

From Scott Cheloha <scottcheloha@@gmail.com>

ok florian@@
@
text
@/*	$OpenBSD: buffer.c,v 1.103 2017/03/13 20:32:58 florian Exp $	*/

/* This file is in the public domain. */

/*
 *		Buffer handling.
 */

#include <sys/queue.h>
#include <errno.h>
#include <libgen.h>
#include <signal.h>
#include <stdarg.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>

#include "def.h"
#include "kbd.h"		/* needed for modes */

#define DIFFTOOL "/usr/bin/diff"

static struct buffer  *makelist(void);
static struct buffer *bnew(const char *);

static int usebufname(const char *);

/* Flag for global working dir */
extern int globalwd;

/* ARGSUSED */
int
togglereadonly(int f, int n)
{
	int s;

	if ((s = checkdirty(curbp)) != TRUE)
		return (s);
	if (!(curbp->b_flag & BFREADONLY))
		curbp->b_flag |= BFREADONLY;
	else {
		curbp->b_flag &= ~BFREADONLY;
		if (curbp->b_flag & BFCHG)
			ewprintf("Warning: Buffer was modified");
	}
	curwp->w_rflag |= WFMODE;

	return (TRUE);
}

/* Switch to the named buffer.
 * If no name supplied, switch to the default (alternate) buffer.
 */
int
usebufname(const char *bufp)
{
	struct buffer *bp = NULL;

	if (bufp == NULL) {
		if ((bp = bfind("*scratch*", TRUE)) == NULL)
			return(FALSE);
	} else if (bufp[0] == '\0' && curbp->b_altb != NULL)
			bp = curbp->b_altb;
	else if ((bp = bfind(bufp, TRUE)) == NULL)
		return (FALSE);

	/* and put it in current window */
	curbp = bp;
	return (showbuffer(bp, curwp, WFFRAME | WFFULL));
}

/*
 * Attach a buffer to a window. The values of dot and mark come
 * from the buffer if the use count is 0. Otherwise, they come
 * from some other window.  *scratch* is the default alternate
 * buffer.
 */
/* ARGSUSED */
int
usebuffer(int f, int n)
{
	char    bufn[NBUFN], *bufp;

	/* Get buffer to use from user */
	if (curbp->b_altb == NULL)
		bufp = eread("Switch to buffer: ", bufn, NBUFN, EFNEW | EFBUF);
	else
		bufp = eread("Switch to buffer (default %s): ", bufn, NBUFN,
		    EFNUL | EFNEW | EFBUF, curbp->b_altb->b_bname);

	if (bufp == NULL)
		return FALSE;

	return (usebufname(bufp));
}

/*
 * pop to buffer asked for by the user.
 */
/* ARGSUSED */
int
poptobuffer(int f, int n)
{
	struct buffer *bp;
	struct mgwin  *wp;
	char    bufn[NBUFN], *bufp;

	/* Get buffer to use from user */
	if ((curbp->b_altb == NULL) &&
	    ((curbp->b_altb = bfind("*scratch*", TRUE)) == NULL))
		bufp = eread("Switch to buffer in other window: ", bufn, NBUFN,
		    EFNEW | EFBUF);
	else
		bufp = eread("Switch to buffer in other window (default %s): ",
		    bufn, NBUFN, EFNUL | EFNEW | EFBUF, curbp->b_altb->b_bname);
	if (bufp == NULL)
		return (ABORT);
	if (bufp[0] == '\0' && curbp->b_altb != NULL)
		bp = curbp->b_altb;
	else if ((bp = bfind(bufn, TRUE)) == NULL)
		return (FALSE);
	if (bp == curbp)
		return (splitwind(f, n));
	/* and put it in a new, non-ephemeral window */
	if ((wp = popbuf(bp, WNONE)) == NULL)
		return (FALSE);
	curbp = bp;
	curwp = wp;
	return (TRUE);
}

/*
 * Dispose of a buffer, by name.
 * Ask for the name (unless called by dired mode). Look it up (don't
 * get too upset if it isn't there at all!). Clear the buffer (ask
 * if the buffer has been changed). Then free the header
 * line and the buffer header. Bound to "C-x k".
 */
/* ARGSUSED */
int
killbuffer_cmd(int f, int n)
{
	struct buffer *bp;
	char    bufn[NBUFN], *bufp;

	if (f & FFRAND) /* dired mode 'q' */
		bp = curbp;
	else if ((bufp = eread("Kill buffer (default %s): ", bufn, NBUFN,
	    EFNUL | EFNEW | EFBUF, curbp->b_bname)) == NULL)
		return (ABORT);
	else if (bufp[0] == '\0')
		bp = curbp;
	else if ((bp = bfind(bufn, FALSE)) == NULL)
		return (FALSE);
	return (killbuffer(bp));
}

int
killbuffer(struct buffer *bp)
{
	struct buffer *bp1;
	struct buffer *bp2;
	struct mgwin  *wp;
	int s;
	struct undo_rec *rec;

	/*
	 * Find some other buffer to display. Try the alternate buffer,
	 * then the first different buffer in the buffer list.  If there's
	 * only one buffer, create buffer *scratch* and make it the alternate
	 * buffer.  Return if *scratch* is only buffer...
	 */
	if ((bp1 = bp->b_altb) == NULL) {
		/* only one buffer. see if it's *scratch* */
		if (bp == bfind("*scratch*", FALSE))
			return (TRUE);
		/* create *scratch* for alternate buffer */
		if ((bp1 = bfind("*scratch*", TRUE)) == NULL)
			return (FALSE);
	}
	if ((s = bclear(bp)) != TRUE)
		return (s);
	for (wp = wheadp; bp->b_nwnd > 0; wp = wp->w_wndp) {
		if (wp->w_bufp == bp) {
			bp2 = bp1->b_altb;	/* save alternate buffer */
			if (showbuffer(bp1, wp, WFMODE | WFFRAME | WFFULL))
				bp1->b_altb = bp2;
			else
				bp1 = bp2;
		}
	}
	if (bp == curbp)
		curbp = bp1;
	free(bp->b_headp);			/* Release header line.  */
	bp2 = NULL;				/* Find the header.	 */
	bp1 = bheadp;
	while (bp1 != bp) {
		if (bp1->b_altb == bp)
			bp1->b_altb = (bp->b_altb == bp1) ? NULL : bp->b_altb;
		bp2 = bp1;
		bp1 = bp1->b_bufp;
	}
	bp1 = bp1->b_bufp;			/* Next one in chain.	 */
	if (bp2 == NULL)			/* Unlink it.		 */
		bheadp = bp1;
	else
		bp2->b_bufp = bp1;
	while (bp1 != NULL) {			/* Finish with altb's	 */
		if (bp1->b_altb == bp)
			bp1->b_altb = (bp->b_altb == bp1) ? NULL : bp->b_altb;
		bp1 = bp1->b_bufp;
	}

	while ((rec = TAILQ_FIRST(&bp->b_undo))) {
		TAILQ_REMOVE(&bp->b_undo, rec, next);
		free_undo_record(rec);
	}

	free(bp->b_bname);			/* Release name block	 */
	free(bp);				/* Release buffer block */
	return (TRUE);
}

/*
 * Save some buffers - just call anycb with the arg flag.
 */
/* ARGSUSED */
int
savebuffers(int f, int n)
{
	if (anycb(f) == ABORT)
		return (ABORT);
	return (TRUE);
}

/*
 * Listing buffers.
 */
static int listbuf_ncol;

static int	listbuf_goto_buffer(int f, int n);
static int	listbuf_goto_buffer_one(int f, int n);
static int	listbuf_goto_buffer_helper(int f, int n, int only);

static PF listbuf_pf[] = {
	listbuf_goto_buffer
};
static PF listbuf_one[] = {
	listbuf_goto_buffer_one
};


static struct KEYMAPE (2) listbufmap = {
	2,
	2,
	rescan,
	{
		{
			CCHR('M'), CCHR('M'), listbuf_pf, NULL
		},
		{
			'1', '1', listbuf_one, NULL
		}
	}
};

/*
 * Display the buffer list. This is done
 * in two parts. The "makelist" routine figures out
 * the text, and puts it in a buffer. "popbuf"
 * then pops the data onto the screen. Bound to
 * "C-X C-B".
 */
/* ARGSUSED */
int
listbuffers(int f, int n)
{
	static int		 initialized = 0;
	struct buffer		*bp;
	struct mgwin		*wp;

	if (!initialized) {
		maps_add((KEYMAP *)&listbufmap, "listbufmap");
		initialized = 1;
	}

	if ((bp = makelist()) == NULL || (wp = popbuf(bp, WNONE)) == NULL)
		return (FALSE);
	wp->w_dotp = bp->b_dotp; /* fix up if window already on screen */
	wp->w_doto = bp->b_doto;
	bp->b_modes[0] = name_mode("fundamental");
	bp->b_modes[1] = name_mode("listbufmap");
	bp->b_nmodes = 1;

	return (TRUE);
}

/*
 * This routine rebuilds the text for the
 * list buffers command. Return pointer
 * to new list if everything works.
 * Return NULL if there is an error (if
 * there is no memory).
 */
static struct buffer *
makelist(void)
{
	int		w = ncol / 2;
	struct buffer	*bp, *blp;
	struct line	*lp;

	if ((blp = bfind("*Buffer List*", TRUE)) == NULL)
		return (NULL);
	if (bclear(blp) != TRUE)
		return (NULL);
	blp->b_flag &= ~BFCHG;		/* Blow away old.	 */
	blp->b_flag |= BFREADONLY;

	listbuf_ncol = ncol;		/* cache ncol for listbuf_goto_buffer */

	if (addlinef(blp, "%-*s%s", w, " MR Buffer", "Size   File") == FALSE ||
	    addlinef(blp, "%-*s%s", w, " -- ------", "----   ----") == FALSE)
		return (NULL);

	for (bp = bheadp; bp != NULL; bp = bp->b_bufp) {
		RSIZE nbytes;

		nbytes = 0;			/* Count bytes in buf.	 */
		if (bp != blp) {
			lp = bfirstlp(bp);
			while (lp != bp->b_headp) {
				nbytes += llength(lp) + 1;
				lp = lforw(lp);
			}
			if (nbytes)
				nbytes--;	/* no bonus newline	 */
		}

		if (addlinef(blp, "%c%c%c %-*.*s%c%-6d %-*s",
		    (bp == curbp) ? '.' : ' ',	/* current buffer ? */
		    ((bp->b_flag & BFCHG) != 0) ? '*' : ' ',	/* changed ? */
		    ((bp->b_flag & BFREADONLY) != 0) ? ' ' : '*',
		    w - 5,		/* four chars already written */
		    w - 5,		/* four chars already written */
		    bp->b_bname,	/* buffer name */
		    strlen(bp->b_bname) < w - 5 ? ' ' : '$', /* truncated? */
		    nbytes,		/* buffer size */
		    w - 7,		/* seven chars already written */
		    bp->b_fname) == FALSE)
			return (NULL);
	}
	blp->b_dotp = bfirstlp(blp);		/* put dot at beginning of
						 * buffer */
	blp->b_doto = 0;
	return (blp);				/* All done		 */
}

static int
listbuf_goto_buffer(int f, int n)
{
	return (listbuf_goto_buffer_helper(f, n, 0));
}

static int
listbuf_goto_buffer_one(int f, int n)
{
	return (listbuf_goto_buffer_helper(f, n, 1));
}

static int
listbuf_goto_buffer_helper(int f, int n, int only)
{
	struct buffer	*bp;
	struct mgwin	*wp;
	char		*line = NULL;
	int		 i, ret = FALSE;

	if (curwp->w_dotp->l_text[listbuf_ncol/2 - 1] == '$') {
		dobeep();
		ewprintf("buffer name truncated");
		return (FALSE);
	}

	if ((line = malloc(listbuf_ncol/2)) == NULL)
		return (FALSE);

	memcpy(line, curwp->w_dotp->l_text + 4, listbuf_ncol/2 - 5);
	for (i = listbuf_ncol/2 - 6; i > 0; i--) {
		if (line[i] != ' ') {
			line[i + 1] = '\0';
			break;
		}
	}
	if (i == 0)
		goto cleanup;

	for (bp = bheadp; bp != NULL; bp = bp->b_bufp) {
		if (strcmp(bp->b_bname, line) == 0)
			break;
	}
	if (bp == NULL)
		goto cleanup;

	if ((wp = popbuf(bp, WNONE)) == NULL)
		goto cleanup;
	curbp = bp;
	curwp = wp;

	if (only)
		ret = (onlywind(FFRAND, 1));
	else
		ret = TRUE;

cleanup:
	free(line);

	return (ret);
}

/*
 * The argument "fmt" points to a format string.  Append this line to the
 * buffer. Handcraft the EOL on the end.  Return TRUE if it worked and
 * FALSE if you ran out of room.
 */
int
addlinef(struct buffer *bp, char *fmt, ...)
{
	va_list		 ap;
	struct line	*lp;

	if ((lp = lalloc(0)) == NULL)
		return (FALSE);
	va_start(ap, fmt);
	if (vasprintf(&lp->l_text, fmt, ap) == -1) {
		lfree(lp);
		va_end(ap);
		return (FALSE);
	}
	lp->l_used = strlen(lp->l_text);
	va_end(ap);

	bp->b_headp->l_bp->l_fp = lp;		/* Hook onto the end	 */
	lp->l_bp = bp->b_headp->l_bp;
	bp->b_headp->l_bp = lp;
	lp->l_fp = bp->b_headp;
	bp->b_lines++;

	return (TRUE);
}

/*
 * Look through the list of buffers, giving the user a chance to save them.
 * Return TRUE if there are any changed buffers afterwards.  Buffers that don't
 * have an associated file don't count.  Return FALSE if there are no changed
 * buffers.  Return ABORT if an error occurs or if the user presses c-g.
 */
int
anycb(int f)
{
	struct buffer	*bp;
	int		 s = FALSE, save = FALSE, save2 = FALSE, ret;
	char		 pbuf[NFILEN + 11];

	for (bp = bheadp; bp != NULL; bp = bp->b_bufp) {
		if (*(bp->b_fname) != '\0' && (bp->b_flag & BFCHG) != 0) {
			ret = snprintf(pbuf, sizeof(pbuf), "Save file %s",
			    bp->b_fname);
			if (ret < 0 || ret >= sizeof(pbuf)) {
				dobeep();
				ewprintf("Error: filename too long!");
				return (UERROR);
			}
			if ((f == TRUE || (save = eyorn(pbuf)) == TRUE) &&
			    (save2 = buffsave(bp)) == TRUE) {
				bp->b_flag &= ~BFCHG;
				upmodes(bp);
			} else {
				if (save2 == FIOERR)
					return (save2);
				s = TRUE;
			}
			if (save == ABORT)
				return (save);
			save = TRUE;
		}
	}
	if (save == FALSE /* && kbdmop == NULL */ )	/* experimental */
		ewprintf("(No files need saving)");
	return (s);
}

/*
 * Search for a buffer, by name.
 * If not found, and the "cflag" is TRUE,
 * create a new buffer. Return pointer to the found
 * (or new) buffer.
 */
struct buffer *
bfind(const char *bname, int cflag)
{
	struct buffer	*bp;

	bp = bheadp;
	while (bp != NULL) {
		if (strcmp(bname, bp->b_bname) == 0)
			return (bp);
		bp = bp->b_bufp;
	}
	if (cflag != TRUE)
		return (NULL);

	bp = bnew(bname);

	return (bp);
}

/*
 * Create a new buffer and put it in the list of
 * all buffers.
 */
static struct buffer *
bnew(const char *bname)
{
	struct buffer	*bp;
	struct line	*lp;
	int		 i;
	size_t		len;

	bp = calloc(1, sizeof(struct buffer));
	if (bp == NULL) {
		dobeep();
		ewprintf("Can't get %d bytes", sizeof(struct buffer));
		return (NULL);
	}
	if ((lp = lalloc(0)) == NULL) {
		free(bp);
		return (NULL);
	}
	bp->b_altb = bp->b_bufp = NULL;
	bp->b_dotp = lp;
	bp->b_doto = 0;
	bp->b_markp = NULL;
	bp->b_marko = 0;
	bp->b_flag = defb_flag;
	/* if buffer name starts and ends with '*', we ignore changes */
	len = strlen(bname);
	if (len) {
		if (bname[0] == '*' && bname[len - 1] == '*')
			bp->b_flag |= BFIGNDIRTY;
	}
	bp->b_nwnd = 0;
	bp->b_headp = lp;
	bp->b_nmodes = defb_nmodes;
	TAILQ_INIT(&bp->b_undo);
	bp->b_undoptr = NULL;
	i = 0;
	do {
		bp->b_modes[i] = defb_modes[i];
	} while (i++ < defb_nmodes);
	bp->b_fname[0] = '\0';
	bp->b_cwd[0] = '\0';
	bzero(&bp->b_fi, sizeof(bp->b_fi));
	lp->l_fp = lp;
	lp->l_bp = lp;
	bp->b_bufp = bheadp;
	bheadp = bp;
	bp->b_dotline = bp->b_markline = 1;
	bp->b_lines = 1;
	if ((bp->b_bname = strdup(bname)) == NULL) {
		dobeep();
		ewprintf("Can't get %d bytes", strlen(bname) + 1);
		return (NULL);
	}

	return (bp);
}

/*
 * This routine blows away all of the text
 * in a buffer. If the buffer is marked as changed
 * then we ask if it is ok to blow it away; this is
 * to save the user the grief of losing text. The
 * window chain is nearly always wrong if this gets
 * called; the caller must arrange for the updates
 * that are required. Return TRUE if everything
 * looks good.
 */
int
bclear(struct buffer *bp)
{
	struct line	*lp;
	int		 s;

	/* Has buffer changed, and do we care? */
	if (!(bp->b_flag & BFIGNDIRTY) && (bp->b_flag & BFCHG) != 0 &&
	    (s = eyesno("Buffer modified; kill anyway")) != TRUE)
		return (s);
	bp->b_flag &= ~BFCHG;	/* Not changed		 */
	while ((lp = lforw(bp->b_headp)) != bp->b_headp)
		lfree(lp);
	bp->b_dotp = bp->b_headp;	/* Fix dot */
	bp->b_doto = 0;
	bp->b_markp = NULL;	/* Invalidate "mark"	 */
	bp->b_marko = 0;
	bp->b_dotline = bp->b_markline = 1;
	bp->b_lines = 1;

	return (TRUE);
}

/*
 * Display the given buffer in the given window. Flags indicated
 * action on redisplay. Update modified flag so insert loop can check it.
 */
int
showbuffer(struct buffer *bp, struct mgwin *wp, int flags)
{
	struct buffer	*obp;
	struct mgwin	*owp;

	/* Ensure file has not been modified elsewhere */
	if (fchecktime(bp) != TRUE)
		bp->b_flag |= BFDIRTY;

	if (wp->w_bufp == bp) {	/* Easy case! */
		wp->w_rflag |= flags;
		return (TRUE);
	}
	/* First, detach the old buffer from the window */
	if ((bp->b_altb = obp = wp->w_bufp) != NULL) {
		if (--obp->b_nwnd == 0) {
			obp->b_dotp = wp->w_dotp;
			obp->b_doto = wp->w_doto;
			obp->b_markp = wp->w_markp;
			obp->b_marko = wp->w_marko;
			obp->b_dotline = wp->w_dotline;
			obp->b_markline = wp->w_markline;
		}
	}
	/* Now, attach the new buffer to the window */
	wp->w_bufp = bp;

	if (bp->b_nwnd++ == 0) {	/* First use.		 */
		wp->w_dotp = bp->b_dotp;
		wp->w_doto = bp->b_doto;
		wp->w_markp = bp->b_markp;
		wp->w_marko = bp->b_marko;
		wp->w_dotline = bp->b_dotline;
		wp->w_markline = bp->b_markline;
	} else
		/* already on screen, steal values from other window */
		for (owp = wheadp; owp != NULL; owp = wp->w_wndp)
			if (wp->w_bufp == bp && owp != wp) {
				wp->w_dotp = owp->w_dotp;
				wp->w_doto = owp->w_doto;
				wp->w_markp = owp->w_markp;
				wp->w_marko = owp->w_marko;
				wp->w_dotline = owp->w_dotline;
				wp->w_markline = owp->w_markline;
				break;
			}
	wp->w_rflag |= WFMODE | flags;
	return (TRUE);
}

/*
 * Augment a buffer name with a number, if necessary
 *
 * If more than one file of the same basename() is open,
 * the additional buffers are named "file<2>", "file<3>", and
 * so forth.  This function adjusts a buffer name to
 * include the number, if necessary.
 */
int
augbname(char *bn, const char *fn, size_t bs)
{
	int	 count;
	size_t	 remain, len;

	if ((len = xbasename(bn, fn, bs)) >= bs)
		return (FALSE);

	remain = bs - len;
	for (count = 2; bfind(bn, FALSE) != NULL; count++)
		snprintf(bn + len, remain, "<%d>", count);

	return (TRUE);
}

/*
 * Pop the buffer we got passed onto the screen.
 * Returns a status.
 */
struct mgwin *
popbuf(struct buffer *bp, int flags)
{
	struct mgwin	*wp;

	if (bp->b_nwnd == 0) {	/* Not on screen yet.	 */
		/*
		 * Pick a window for a pop-up.
		 * If only one window, split the screen.
		 * Flag the new window as ephemeral
		 */
		if (wheadp->w_wndp == NULL &&
		    splitwind(FFOTHARG, flags) == FALSE)
 			return (NULL);

		/*
		 * Pick the uppermost window that isn't
		 * the current window. An LRU algorithm
		 * might be better. Return a pointer, or NULL on error.
		 */
		wp = wheadp;

		while (wp != NULL && wp == curwp)
			wp = wp->w_wndp;
	} else {
		for (wp = wheadp; wp != NULL; wp = wp->w_wndp) {
			if (wp->w_bufp == bp) {
				wp->w_rflag |= WFFULL | WFFRAME;
				return (wp);
			}
		}
	}
	if (!wp)
		return (NULL);

	if (showbuffer(bp, wp, WFFULL) != TRUE)
		return (NULL);
	return (wp);
}

/*
 * Insert another buffer at dot.  Very useful.
 */
/* ARGSUSED */
int
bufferinsert(int f, int n)
{
	struct buffer *bp;
	struct line   *clp;
	int	clo, nline;
	char	bufn[NBUFN], *bufp;

	/* Get buffer to use from user */
	if (curbp->b_altb != NULL)
		bufp = eread("Insert buffer (default %s): ", bufn, NBUFN,
		    EFNUL | EFNEW | EFBUF, curbp->b_altb->b_bname);
	else
		bufp = eread("Insert buffer: ", bufn, NBUFN, EFNEW | EFBUF);
	if (bufp == NULL)
		return (ABORT);
	if (bufp[0] == '\0' && curbp->b_altb != NULL)
		bp = curbp->b_altb;
	else if ((bp = bfind(bufn, FALSE)) == NULL)
		return (FALSE);

	if (bp == curbp) {
		dobeep();
		ewprintf("Cannot insert buffer into self");
		return (FALSE);
	}
	/* insert the buffer */
	nline = 0;
	clp = bfirstlp(bp);
	for (;;) {
		for (clo = 0; clo < llength(clp); clo++)
			if (linsert(1, lgetc(clp, clo)) == FALSE)
				return (FALSE);
		if ((clp = lforw(clp)) == bp->b_headp)
			break;
		if (enewline(FFRAND, 1) == FALSE)	/* fake newline */
			return (FALSE);
		nline++;
	}
	if (nline == 1)
		ewprintf("[Inserted 1 line]");
	else
		ewprintf("[Inserted %d lines]", nline);

	clp = curwp->w_linep;		/* cosmetic adjustment	*/
	if (curwp->w_dotp == clp) {	/* for offscreen insert */
		while (nline-- && lback(clp) != curbp->b_headp)
			clp = lback(clp);
		curwp->w_linep = clp;	/* adjust framing.	*/
		curwp->w_rflag |= WFFULL;
	}
	return (TRUE);
}

/*
 * Turn off the dirty bit on this buffer.
 */
/* ARGSUSED */
int
notmodified(int f, int n)
{
	struct mgwin *wp;

	curbp->b_flag &= ~BFCHG;
	wp = wheadp;		/* Update mode lines.	 */
	while (wp != NULL) {
		if (wp->w_bufp == curbp)
			wp->w_rflag |= WFMODE;
		wp = wp->w_wndp;
	}
	ewprintf("Modification-flag cleared");
	return (TRUE);
}

/*
 * Popbuf and set all windows to top of buffer.
 */
int
popbuftop(struct buffer *bp, int flags)
{
	struct mgwin *wp;

	bp->b_dotp = bfirstlp(bp);
	bp->b_doto = 0;
	if (bp->b_nwnd != 0) {
		for (wp = wheadp; wp != NULL; wp = wp->w_wndp)
			if (wp->w_bufp == bp) {
				wp->w_dotp = bp->b_dotp;
				wp->w_doto = 0;
				wp->w_rflag |= WFFULL;
			}
	}
	return (popbuf(bp, flags) != NULL);
}

/*
 * Return the working directory for the current buffer, terminated
 * with a '/'. First, try to extract it from the current buffer's
 * filename. If that fails, use global cwd.
 */
int
getbufcwd(char *path, size_t plen)
{
	char cwd[NFILEN];

	if (plen == 0)
		return (FALSE);

	if (globalwd == FALSE && curbp->b_cwd[0] != '\0') {
		(void)strlcpy(path, curbp->b_cwd, plen);
	} else {
		if (getcwdir(cwd, sizeof(cwd)) == FALSE)
			goto error;
		(void)strlcpy(path, cwd, plen);
	}
	return (TRUE);
error:
	path[0] = '\0';
	return (FALSE);
}

/*
 * Ensures a buffer has not been modified elsewhere; e.g. on disk.
 * Prompt the user if it has.
 * Returns TRUE if it has NOT (i.e. buffer is ok to edit).
 * FALSE or ABORT otherwise
 */
int
checkdirty(struct buffer *bp)
{
	int s;

	if ((bp->b_flag & (BFCHG | BFDIRTY)) == 0)
		if (fchecktime(bp) != TRUE)
			bp->b_flag |= BFDIRTY;

	if ((bp->b_flag & (BFDIRTY | BFIGNDIRTY)) == BFDIRTY) {
		s = eynorr("File changed on disk; really edit the buffer");
		switch (s) {
		case TRUE:
			bp->b_flag &= ~BFDIRTY;
			bp->b_flag |= BFIGNDIRTY;
			return (TRUE);
		case REVERT:
			dorevert();
			return (FALSE);
		default:
			return (s);
		}
	}

	return (TRUE);
}

/*
 * Revert the current buffer to whatever is on disk.
 */
/* ARGSUSED */
int
revertbuffer(int f, int n)
{
	char fbuf[NFILEN + 32];

	if (curbp->b_fname[0] == 0) {
		dobeep();
		ewprintf("Cannot revert buffer not associated with any files.");
		return (FALSE);
	}

	snprintf(fbuf, sizeof(fbuf), "Revert buffer from file %s",
	    curbp->b_fname);

	if (eyorn(fbuf) == TRUE)
		return dorevert();

	return (FALSE);
}

int
dorevert(void)
{
	int lineno;
	struct undo_rec *rec;

	if (access(curbp->b_fname, F_OK|R_OK) != 0) {
		dobeep();
		if (errno == ENOENT)
			ewprintf("File %s no longer exists!",
			    curbp->b_fname);
		else
			ewprintf("File %s is no longer readable!",
			    curbp->b_fname);
		return (FALSE);
	}

	/* Save our current line, so we can go back after reloading. */
	lineno = curwp->w_dotline;

	/* Prevent readin from asking if we want to kill the buffer. */
	curbp->b_flag &= ~BFCHG;

	/* Clean up undo memory */
	while ((rec = TAILQ_FIRST(&curbp->b_undo))) {
		TAILQ_REMOVE(&curbp->b_undo, rec, next);
		free_undo_record(rec);
	}

	if (readin(curbp->b_fname))
		return(setlineno(lineno));
	return (FALSE);
}

/*
 * Diff the current buffer to what is on disk.
 */
/*ARGSUSED */
int
diffbuffer(int f, int n)
{
	struct buffer	*bp;
	struct line	*lp, *lpend;
	size_t		 len;
	int		 ret;
	char		*text, *ttext;
	char		* const argv[] =
	    {DIFFTOOL, "-u", "-p", curbp->b_fname, "-", (char *)NULL};

	len = 0;

	/* C-u is not supported */
	if (n > 1)
		return (ABORT);

	if (access(DIFFTOOL, X_OK) != 0) {
		dobeep();
		ewprintf("%s not found or not executable.", DIFFTOOL);
		return (FALSE);
	}

	if (curbp->b_fname[0] == 0) {
		dobeep();
		ewprintf("Cannot diff buffer not associated with any files.");
		return (FALSE);
	}

	lpend = curbp->b_headp;
	for (lp = lforw(lpend); lp != lpend; lp = lforw(lp)) {
		len+=llength(lp);
		if (lforw(lp) != lpend)		/* no implied \n on last line */
			len++;
	}
	if ((text = calloc(len + 1, sizeof(char))) == NULL) {
		dobeep();
		ewprintf("Cannot allocate memory.");
		return (FALSE);
	}
	ttext = text;

	for (lp = lforw(lpend); lp != lpend; lp = lforw(lp)) {
		if (llength(lp) != 0) {
			memcpy(ttext, ltext(lp), llength(lp));
			ttext += llength(lp);
		}
		if (lforw(lp) != lpend)		/* no implied \n on last line */
			*ttext++ = '\n';
	}

	bp = bfind("*Diff*", TRUE);
	bp->b_flag |= BFREADONLY;
	if (bclear(bp) != TRUE) {
		free(text);
		return (FALSE);
	}

	ret = pipeio(DIFFTOOL, argv, text, len, bp);

	if (ret == TRUE) {
		eerase();
		if (lforw(bp->b_headp) == bp->b_headp)
			addline(bp, "Diff finished (no differences).");
	}

	free(text);
	return (ret);
}

/*
 * Given a file name, either find the buffer it uses, or create a new
 * empty buffer to put it in.
 */
struct buffer *
findbuffer(char *fn)
{
	struct buffer	*bp;
	char		bname[NBUFN], fname[NBUFN];

	if (strlcpy(fname, fn, sizeof(fname)) >= sizeof(fname)) {
		dobeep();
		ewprintf("filename too long");
		return (NULL);
	}

	for (bp = bheadp; bp != NULL; bp = bp->b_bufp) {
		if (strcmp(bp->b_fname, fname) == 0)
			return (bp);
	}
	/* Not found. Create a new one, adjusting name first */
	if (augbname(bname, fname, sizeof(bname)) == FALSE)
		return (NULL);

	bp = bfind(bname, TRUE);
	return (bp);
}
@


1.103
log
@When aborting switch-to-buffer keep current buffer instead of
switching to *scratch*. (Which seems to be the least useful thing to
do.)
This brings mg in line with emacs.
OK lum; deraadt@@ was bugged by this, too
@
text
@d1 1
a1 1
/*	$OpenBSD: buffer.c,v 1.102 2016/09/07 11:42:01 lum Exp $	*/
d89 1
a89 1
		bufp = eread("Switch to buffer: (default %s) ", bufn, NBUFN,
d115 1
a115 1
		bufp = eread("Switch to buffer in other window: (default %s) ",
d149 1
a149 1
	else if ((bufp = eread("Kill buffer: (default %s) ", bufn, NBUFN,
d749 1
a749 1
		bufp = eread("Insert buffer: (default %s) ", bufn, NBUFN,
@


1.102
log
@Source Joachim Nilsson:

 Found by Coverity Scan.  The popbuf() function iterated over a list to
 find a wp pointer, then sent it to showbuffer() which immediately went
 ahead and dereferenced it.  This patch simply adds a NULL pointer check
 before calling showbuffer(), if NULL then just return NULL to callee.

ok awolk@@ millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: buffer.c,v 1.101 2016/08/31 12:22:28 lum Exp $	*/
d91 3
@


1.101
log
@Fix a bug reported by Han Boetes. Easily reproducible via:

mg
c-x b RET
c-x k RET

mg segvs. Initial diff from Joachim Nilsson. This diff tested
by Han and Joachim and ok florian@@ jasper@@
@
text
@d1 1
a1 1
/*	$OpenBSD: buffer.c,v 1.100 2015/10/10 08:35:26 lum Exp $	*/
d716 2
a717 2
	} else
		for (wp = wheadp; wp != NULL; wp = wp->w_wndp)
d722 5
@


1.100
log
@Call onlywind() properly.
@
text
@d1 1
a1 1
/*	$OpenBSD: buffer.c,v 1.99 2015/09/26 21:51:58 jasper Exp $	*/
d58 1
a58 1
	struct buffer *bp;
d60 5
a64 4
	if (bufp == NULL)
		return (ABORT);
	if (bufp[0] == '\0' && curbp->b_altb != NULL)
		bp = curbp->b_altb;
d86 1
a86 2
	if ((curbp->b_altb == NULL) &&
	    ((curbp->b_altb = bfind("*scratch*", TRUE)) == NULL))
d172 6
a177 9
		bp1 = (bp == bheadp) ? bp->b_bufp : bheadp;
		if (bp1 == NULL) {
			/* only one buffer. see if it's *scratch* */
			if (bp == bfind("*scratch*", FALSE))
				return (TRUE);
			/* create *scratch* for alternate buffer */
			if ((bp1 = bfind("*scratch*", TRUE)) == NULL)
				return (FALSE);
		}
@


1.99
log
@whitespace
@
text
@d1 1
a1 1
/*	$OpenBSD: buffer.c,v 1.98 2015/03/23 12:31:19 bcallah Exp $	*/
d411 1
a411 1
		ret = (onlywind(f, n));
@


1.98
log
@DIFFTOOL has to be defined for mg to build. TCSASOFT is defined via
termios.h so we don't need the code for when it is not defined.
ok reyk@@
@
text
@d1 1
a1 1
/*	$OpenBSD: buffer.c,v 1.97 2015/03/19 21:48:05 bcallah Exp $	*/
d701 1
a701 1
		/* 
d713 1
a713 1
		 * might be better. Return a pointer, or NULL on error. 
@


1.97
log
@More unifdef cleanup:
-UDIRED_XMAPS and -UFUND_XMAPS: you can't build mg the other way.
-DTIOCGWINSZ: you have this if you have term.h
Remove a #define TERMCAP which isn't being used.

Remove defines for NDIRED_XMAPS, NFUND_XMAPS, and IMAPEXT. They are all
defined to be 0 and are only ever used in addition. We don't need to add 0.
Simply lines that were using those defines.
ok florian@@
@
text
@d1 1
a1 1
/*	$OpenBSD: buffer.c,v 1.96 2015/03/19 21:22:15 bcallah Exp $	*/
a21 1
#ifndef DIFFTOOL
a22 1
#endif /* !DIFFTOOL */
@


1.96
log
@Clean up the includes in mg.
This does the following:
Moves all POSIX headers from sysdef.h into the individual .c files so that
each file now only includes what it needs. All headers are properly sorted.
Moves the remainder of sysdef.h to other files (mostly def.h) and deletes
sysdef.h now that it's no longer contains anything.
Tweak a comment that references sysdef.h so that it no longer does that.
ok florian@@
@
text
@d1 1
a1 1
/*	$OpenBSD: buffer.c,v 1.95 2015/03/16 13:47:48 bcallah Exp $	*/
d256 2
a257 1
static struct KEYMAPE (2 + IMAPEXT) listbufmap = {
a258 1
	2 + IMAPEXT,
@


1.95
log
@Change the internal name of the newline function to deconflict with a
function of the same name in term.h. This is the first step towards
cleaning up mg's includes. No user-visible changes.
ok florian@@
@
text
@d1 1
a1 1
/*	$OpenBSD: buffer.c,v 1.94 2014/06/12 16:29:41 bcallah Exp $	*/
d9 10
a20 3

#include <libgen.h>
#include <stdarg.h>
@


1.94
log
@Remove a comparison that is always true. Reported by clang.
Merge the new if into a single line, requested by florian@@
ok matthew@@ florian@@
@
text
@d1 1
a1 1
/*	$OpenBSD: buffer.c,v 1.93 2014/03/20 07:47:29 lum Exp $	*/
d764 1
a764 1
		if (newline(FFRAND, 1) == FALSE)	/* fake newline */
@


1.93
log
@Add some missing dobeeps.
ok florian@@
@
text
@d1 1
a1 1
/*	$OpenBSD: buffer.c,v 1.92 2013/12/23 14:58:16 lum Exp $	*/
d461 1
a461 2
		if (bp->b_fname != NULL && *(bp->b_fname) != '\0' &&
		    (bp->b_flag & BFCHG) != 0) {
@


1.92
log
@Move findbuffer() to buffer.c.
ok florian@@
@
text
@d1 1
a1 1
/*	$OpenBSD: buffer.c,v 1.91 2013/06/02 10:09:21 lum Exp $	*/
d375 1
d466 1
d528 1
d567 1
d752 1
d894 1
d915 1
d964 1
d970 1
d982 1
d1027 1
@


1.91
log
@Add the 'quit-window' dired command and receive a basic English lesson
from jmc@@ again.
@
text
@d1 1
a1 1
/*	$OpenBSD: buffer.c,v 1.90 2013/02/17 10:30:26 florian Exp $	*/
d1004 27
@


1.90
log
@Replace hand rolled TAILQ_REMOVE with example from queue(3).
While this did work in this particular case because the
list was no longer used it at least sets a bad example.
ok benno, jasper, lum
@
text
@d1 1
a1 1
/*	$OpenBSD: buffer.c,v 1.89 2013/02/15 15:12:25 florian Exp $	*/
d127 2
a128 2
 * Ask for the name. Look it up (don't get too
 * upset if it isn't there at all!). Clear the buffer (ask
d130 1
a130 1
 * line and the buffer header. Bound to "C-X k".
d139 3
a141 1
	if ((bufp = eread("Kill buffer: (default %s) ", bufn, NBUFN,
@


1.89
log
@cleanup undo history in revert-buffer
problem spotted, initial diff and ok lum@@
@
text
@d1 1
a1 1
/*	$OpenBSD: buffer.c,v 1.88 2012/12/27 18:51:52 florian Exp $	*/
d156 1
a156 1
	struct undo_rec *rec, *next;
a206 1
	rec = TAILQ_FIRST(&bp->b_undo);
d208 2
a209 2
	while (rec != NULL) {
		next = TAILQ_NEXT(rec, next);
a210 1
		rec = next;
@


1.88
log
@diff-buffer-with-file
input gsoares@@, Sunil Nimmagadda, jasper@@
ok jasper@@, benno@@
@
text
@d1 1
a1 1
/*	$OpenBSD: buffer.c,v 1.87 2012/11/06 18:04:10 florian Exp $	*/
d906 1
d923 6
@


1.87
log
@Remove never read struct member, found while investigating a llvm
report.

ok lum, jasper, benno
@
text
@d1 1
a1 1
/*	$OpenBSD: buffer.c,v 1.86 2012/11/03 14:51:41 haesbaert Exp $	*/
d15 4
d926 71
@


1.86
log
@This should be void.
@
text
@d1 1
a1 1
/*	$OpenBSD: buffer.c,v 1.85 2012/10/23 20:51:17 florian Exp $	*/
a545 1
	memset(&bp->b_undopos, 0, sizeof(bp->b_undopos));
@


1.85
log
@Use correct file for revert-buffer; do not ignore abort.

ok lum, jasper, benno
@
text
@d1 1
a1 1
/*	$OpenBSD: buffer.c,v 1.84 2012/10/22 08:31:42 florian Exp $	*/
d900 1
a900 1
dorevert()
@


1.84
log
@Add (r)evert prompt to "File changed on disk; really edit the buffer"
prompt.

input, ok lum@@, man bit ok jmc@@, ok benno@@
@
text
@d1 1
a1 1
/*	$OpenBSD: buffer.c,v 1.83 2012/10/22 08:22:04 florian Exp $	*/
a882 1
	struct buffer *bp = wheadp->w_bufp;
d885 1
a885 1
	if (bp->b_fname[0] == 0) {
d890 2
a891 1
	snprintf(fbuf, sizeof(fbuf), "Revert buffer from file %s", bp->b_fname);
d893 1
a893 1
	if (eyorn(fbuf))
a901 2
	struct mgwin *wp = wheadp;
	struct buffer *bp = wp->w_bufp;
d904 1
a904 1
	if (access(bp->b_fname, F_OK|R_OK) != 0) {
d907 1
a907 1
			    bp->b_fname);
d910 1
a910 1
			    bp->b_fname);
d915 1
a915 1
	lineno = wp->w_dotline;
d920 1
a920 1
	if (readin(bp->b_fname))
@


1.83
log
@Check for dirty buffer on buffer change.

ok jasper@@, benno@@
@
text
@d1 1
a1 1
/*	$OpenBSD: buffer.c,v 1.82 2012/10/12 21:13:46 jasper Exp $	*/
d859 10
a868 2
		if ((s = eyorn("File changed on disk; really edit the buffer"))
		    != TRUE)
d870 1
a870 2
		bp->b_flag &= ~BFDIRTY;
		bp->b_flag |= BFIGNDIRTY;
d883 1
a883 2
	struct mgwin *wp = wheadp;
	struct buffer *bp = wp->w_bufp;
a884 1
	int lineno;
d893 2
a894 10
	if (eyorn(fbuf)) {
		if (access(bp->b_fname, F_OK|R_OK) != 0) {
			if (errno == ENOENT)
				ewprintf("File %s no longer exists!",
				    bp->b_fname);
			else
				ewprintf("File %s is no longer readable!",
				    bp->b_fname);
			return (FALSE);
		}
d896 2
a897 2
		/* Save our current line, so we can go back after reloading. */
		lineno = wp->w_dotline;
d899 6
a904 2
		/* Prevent readin from asking if we want to kill the buffer. */
		curbp->b_flag &= ~BFCHG;
d906 8
a913 2
		if (readin(bp->b_fname))
			return(setlineno(lineno));
d916 8
@


1.82
log
@- implement "revert-buffer", which reverts the current buffer to what's on disk
- split gotoline() into the argument handling part and the part that actually
  goes to the specified line number so it can be re-used by revertbuffer()

input/ok florian@@ haesbaert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: buffer.c,v 1.81 2012/08/31 18:06:42 lum Exp $	*/
d853 5
a857 1
	
@


1.81
log
@Allow an error message for a filename that is too long to be seen and
let the error stop mg exiting when C-x C-c is called.
@
text
@d1 1
a1 1
/*	$OpenBSD: buffer.c,v 1.80 2012/08/30 06:25:30 lum Exp $	*/
d864 43
a906 1
	
@


1.80
log
@Some line counter goodness from Florian Obser.

If you open an already open buffer via C-x C-f, odd things can happen
with the cursor and line counter for that buffer. This diff stops that
behaviour and no regressions viewable.
@
text
@d1 1
a1 1
/*	$OpenBSD: buffer.c,v 1.79 2012/08/30 06:09:12 lum Exp $	*/
d462 1
a462 1
				return (ABORT);
@


1.79
log
@This diff allows the user to decide what to do with buffers that
experience write errors during C-x C-c (exiting mg). Emacs stops the
exiting process when it encounters problem buffers and lets the user
decide what to do, currently mg continues exiting and the contents of
these buffers are lost. This diff bring mg more into line with emacs.

Review and observations from Sunil Nimmagadda.
@
text
@d1 1
a1 1
/*	$OpenBSD: buffer.c,v 1.78 2012/03/14 13:56:35 lum Exp $	*/
a616 2
		wp->w_dotp = bp->b_dotp;
		wp->w_doto = bp->b_doto;
@


1.78
log
@Remove the NO_HELP conditional directives. If defined, mg will not compile and
has not done so for numerous years. Not hard to fix, but just remove anyway.
ok kjell@@ millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: buffer.c,v 1.77 2011/01/23 00:45:03 kjell Exp $	*/
d452 1
a452 1
	int		 s = FALSE, save = FALSE, ret;
d465 1
a465 1
			    buffsave(bp) == TRUE) {
d468 3
a470 1
			} else
d472 1
@


1.77
log
@Wrap basename,dirname with xbasename, xdirname funtions,
which have fewer special cases, and use the strlcpy/strlcat
src/dst/buffer len semantic. More portable to boot.
Discussion and feedback from Henri Kemppainen
@
text
@d1 1
a1 1
/*	$OpenBSD: buffer.c,v 1.76 2011/01/21 19:10:13 kjell Exp $	*/
a794 1
#ifndef NO_HELP
d796 1
a796 2
 * Popbuf and set all windows to top of buffer.	 Currently only used by
 * help functions.
a814 1
#endif
@


1.76
log
@It volates style(9), but in mg, #include"def.h" goes first. 'twas the way it was built. no binary change here. confirmed by lum@@, tested by Henri Kemppainen
@
text
@d1 1
a1 1
/*	$OpenBSD: buffer.c,v 1.75 2011/01/18 17:35:42 lum Exp $	*/
d669 1
a669 2
	len = strlcpy(bn, basename(fn), bs);
	if (len >= bs)
@


1.75
log
@Add missing prototypes and move dired.c to "extensions" in Makefile.
ok kjell@@
@
text
@d1 1
a1 1
/*	$OpenBSD: buffer.c,v 1.74 2010/06/30 19:12:54 oga Exp $	*/
d9 3
a13 3

#include "def.h"
#include "kbd.h"		/* needed for modes */
@


1.74
log
@you keep saying LIST_END. I do not think it means what you think it
means.

If we hit an OOM condition, mg started to try and dump the older undo buffer
entries in order to be able to continue. OTOH, it was grabbing this entry with
LIST_END, which like all *_END() list macros evaluates to NULL.

Do what we actually want and switch that list to a TAILQ and use
TAILQ_LAST to grab the last entry.

Wrote this a loooooong time ago after a mail from Matthew Dempsky on
bugs@@. ok kjell@@, beck@@ also looked at this months ago and thought it
was alright.
@
text
@d1 1
a1 1
/*	$OpenBSD: buffer.c,v 1.73 2009/06/05 18:37:13 deraadt Exp $	*/
d17 2
@


1.73
log
@swap function order to bring into scope
@
text
@d1 1
a1 1
/*	$OpenBSD: buffer.c,v 1.72 2009/06/04 23:56:50 kjell Exp $	*/
d201 2
a202 1
	rec = LIST_FIRST(&bp->b_undo);
d204 1
a204 1
		next = LIST_NEXT(rec, next);
d539 1
a539 1
	LIST_INIT(&bp->b_undo);
@


1.72
log
@If a buffer is created with a name that starts and ends with an askerisk
(e.g. *scratch*, *Completions*, *grep*) it is considered throwaway; i.e.
the user will NOT be prompted to save changes when the buffer is killed.
@
text
@d1 1
a1 1
/*	$OpenBSD: buffer.c,v 1.68 2008/09/15 16:11:35 kjell Exp $	*/
d41 20
a81 20
}

/* Switch to the named buffer.
 * If no name supplied, switch to the default (alternate) buffer.
 */
int
usebufname(const char *bufp)
{
	struct buffer *bp;

	if (bufp == NULL)
		return (ABORT);
	if (bufp[0] == '\0' && curbp->b_altb != NULL)
		bp = curbp->b_altb;
	else if ((bp = bfind(bufp, TRUE)) == NULL)
		return (FALSE);

	/* and put it in current window */
	curbp = bp;
	return (showbuffer(bp, curwp, WFFRAME | WFFULL));
@


1.71
log
@Add the notion of an "ephemeral" popup, so we can flag a window
for destruction at a later date. (in the process, add a window flag field)

This fixes an issue noted by maja: namely, the *completion*
window that pops up when you try to complete a filename on
buffer load would destroy any second window that you happened
to have open.

ok maja@@
@
text
@d1 1
a1 1
/*	$OpenBSD: buffer.c,v 1.70 2009/06/04 02:23:37 kjell Exp $	*/
a50 1
	struct buffer *bp;
d61 11
d76 1
a76 1
	else if ((bp = bfind(bufn, TRUE)) == NULL)
d512 1
d529 6
d578 2
a579 1
	if ((bp->b_flag & BFCHG) != 0 &&	/* Changed. */
@


1.70
log
@Rename w_flag to w_rflag. This is not a general purpose
flag: it is for redisplay options only. I need an additional all-purpose
flag, so renaming removes the desire to wrongly overload the existing one.

Turdshine. No functional chage.
@
text
@d1 1
a1 1
/*	$OpenBSD: buffer.c,v 1.69 2009/06/02 18:52:42 kjell Exp $	*/
d101 2
a102 2
	/* and put it in a new window */
	if ((wp = popbuf(bp)) == NULL)
d266 1
a266 1
	if ((bp = makelist()) == NULL || (wp = popbuf(bp)) == NULL)
d382 1
a382 1
	if ((wp = popbuf(bp)) == NULL)
d664 1
a664 1
popbuf(struct buffer *bp)
d669 18
a686 2
		if ((wp = wpopup()) == NULL)
			return (NULL);
d781 1
a781 1
popbuftop(struct buffer *bp)
d795 1
a795 1
	return (popbuf(bp) != NULL);
@


1.69
log
@Fix up some comments to match reality
@
text
@d1 1
a1 1
/*	$OpenBSD: buffer.c,v 1.68 2008/09/15 16:11:35 kjell Exp $	*/
d36 1
a36 1
	curwp->w_flag |= WFMODE;
d592 1
a592 1
		wp->w_flag |= flags;
d630 1
a630 1
	wp->w_flag |= WFMODE | flags;
d674 1
a674 1
				wp->w_flag |= WFFULL | WFFRAME;
d734 1
a734 1
		curwp->w_flag |= WFFULL;
d752 1
a752 1
			wp->w_flag |= WFMODE;
d776 1
a776 1
				wp->w_flag |= WFFULL;
@


1.68
log
@Enable dirty buffer detection in mg.
Emulate the emacs behavior: after suspend/resume, buffer switch,
or at save time, warn (prompt) the user if the file has been modified
on disk in the interim.
This has already saved my butt numerous times.
ok phessler
@
text
@d1 1
a1 1
/*	$OpenBSD: buffer.c,v 1.67 2007/05/28 17:52:17 kjell Exp $	*/
d114 1
a114 1
 * line and the buffer header. Bound to "C-X K".
d810 4
a813 2
 * Ensures a buffer has not been modified elsewhere.
 * Returns TRUE if it has NOT. FALSE or ABORT otherwise
@


1.67
log
@Add a global-wd-mode command, which toggles between the current
behavior (every buffer maintains its own cwd) and the old behavior of
one global working directory. This makes it slightly easier to hack
on things like kernel code, where compilation, etc, are initiated from
a different directory than you are working in.
While here, fix setting/handling of global wd.
@
text
@d1 1
a1 1
/*	$OpenBSD: buffer.c,v 1.66 2006/11/19 16:51:19 deraadt Exp $	*/
d25 4
d32 1
a32 1
		curbp->b_flag &=~ BFREADONLY;
d579 1
a579 1
 * action on redisplay.
d587 4
d809 20
@


1.66
log
@spacing
@
text
@d1 1
a1 1
/*	$OpenBSD: buffer.c,v 1.65 2006/11/18 23:05:24 kjell Exp $	*/
d18 3
d788 1
a788 1
	if (curbp->b_cwd[0] != '\0') {
@


1.65
log
@Move buffer name allocation into bnew() where it belongs
@
text
@d1 1
a1 1
/*	$OpenBSD: buffer.c,v 1.64 2006/11/18 19:27:27 kjell Exp $	*/
d487 1
a487 1
 * all buffers. 
d492 1
a492 1
	struct buffer 	*bp;
d634 1
a634 1
	int 	 count;
@


1.64
log
@Fix line number bug (actually, dot-mark bug). to reproduce:
-split window into two
-open a file, set the mark
-switch windows, open same file, exchange point-and-mark
from peter de wachter (Debian bug#391827)
@
text
@d1 1
a1 1
/*	$OpenBSD: buffer.c,v 1.63 2006/07/25 08:27:09 kjell Exp $	*/
d16 1
a16 1
static struct buffer *bnew(void);
d480 1
a480 7
	bp = bnew();

	if ((bp->b_bname = strdup(bname)) == NULL) {
		ewprintf("Can't get %d bytes", strlen(bname) + 1);
		free(bp);
		return (NULL);
	}
d490 1
a490 1
bnew()
d492 1
a492 1
	struct buffer *bp;
d530 4
@


1.63
log
@Add bfirstlp(), blastlp() macros, returning the first and last lines
of a buffer respectively. Removes an ugly construction than necessitated
"go to first line"-type comments throughout the code.
No binary change
@
text
@d1 1
a1 1
/*	$OpenBSD: buffer.c,v 1.62 2006/07/25 08:22:32 kjell Exp $	*/
d618 1
@


1.62
log
@Rename the header line of a buffer to b_headp, from the remarkably
unintuitive b_linep. No binary change.
@
text
@d1 1
a1 1
/*	$OpenBSD: buffer.c,v 1.61 2006/07/08 17:50:30 kjell Exp $	*/
d302 1
a302 1
			lp = lforw(bp->b_headp);
d324 1
a324 1
	blp->b_dotp = lforw(blp->b_headp);	/* put dot at beginning of
d703 1
a703 1
	clp = lforw(bp->b_headp);
d759 1
a759 1
	bp->b_dotp = lforw(bp->b_headp);
@


1.61
log
@Fix a trio of bugs in line numbering: adjusting linenos after undo,
cutting a block, and off-by-one linecount. Initial bug discovered by
jason
@
text
@d1 1
a1 1
/*	$OpenBSD: buffer.c,v 1.60 2006/06/01 09:00:50 kjell Exp $	*/
d165 1
a165 1
	free(bp->b_linep);			/* Release header line.  */
d302 2
a303 2
			lp = lforw(bp->b_linep);
			while (lp != bp->b_linep) {
d324 1
a324 1
	blp->b_dotp = lforw(blp->b_linep);	/* put dot at beginning of
d413 4
a416 4
	bp->b_linep->l_bp->l_fp = lp;		/* Hook onto the end	 */
	lp->l_bp = bp->b_linep->l_bp;
	bp->b_linep->l_bp = lp;
	lp->l_fp = bp->b_linep;
d518 1
a518 1
	bp->b_linep = lp;
d560 1
a560 1
	while ((lp = lforw(bp->b_linep)) != bp->b_linep)
d562 1
a562 1
	bp->b_dotp = bp->b_linep;	/* Fix dot */
d703 1
a703 1
	clp = lforw(bp->b_linep);
d708 1
a708 1
		if ((clp = lforw(clp)) == bp->b_linep)
d721 1
a721 1
		while (nline-- && lback(clp) != curbp->b_linep)
d759 1
a759 1
	bp->b_dotp = lforw(bp->b_linep);
@


1.60
log
@Display line number in the mg statusbar.  Yes, it seems like a fugly
way to do it, but all the clever and pretty ways utterly failed.
Basic use seems fine. We'll turdshine the special cases later.

If it bothers you, use M-x line-number-mode, or put same in your ~/.mg
file to disable.

ok cloder, jason
@
text
@d1 1
a1 1
/*	$OpenBSD: buffer.c,v 1.59 2006/06/01 01:41:49 kjell Exp $	*/
d535 1
a535 1
	bp->b_lines = 0;
d567 1
a567 1
	bp->b_lines = 0;
@


1.59
log
@find-file-other-window and find-buffer-other-window should split
the window if you ask for whatever file you are currently visiting.
pointed out, ok beck@@
@
text
@d1 1
a1 1
/*	$OpenBSD: buffer.c,v 1.58 2006/05/28 23:30:16 kjell Exp $	*/
d417 1
d534 2
d566 3
d595 2
d607 2
d617 1
@


1.58
log
@Make Window Flags more mnemonic (and less dumb); i.e.
WFHARD -> WFFULL (Redraw full window)
WFFORCE -> WFFRAME (Reframe window).
No binary change
@
text
@d1 1
a1 1
/*	$OpenBSD: buffer.c,v 1.57 2006/05/02 17:10:25 kjell Exp $	*/
d92 2
a93 1

@


1.57
log
@Make buffers store their own working directory. This makes things like
grep, compile, lint work as expected (act on current buffer's cwd).
Display this path when opening or replacing a file, rather than
relying on the user to guess, or remember.
@
text
@d1 1
a1 1
/*	$OpenBSD: buffer.c,v 1.56 2006/04/06 05:28:17 kjell Exp $	*/
d64 1
a64 1
	return (showbuffer(bp, curwp, WFFORCE | WFHARD));
d156 1
a156 1
			if (showbuffer(bp1, wp, WFMODE | WFFORCE | WFHARD))
d652 1
a652 1
				wp->w_flag |= WFHARD | WFFORCE;
d655 1
a655 1
	if (showbuffer(bp, wp, WFHARD) != TRUE)
d712 1
a712 1
		curwp->w_flag |= WFHARD;
d754 1
a754 1
				wp->w_flag |= WFHARD;
@


1.56
log
@Fix a bug whereby a written buffer (^X^W) would not have the correct
trailing buffer number appended (e.g. "file<2>") in case an existing
buffer shared its basename().
@
text
@d1 1
a1 1
/*	$OpenBSD: buffer.c,v 1.55 2006/04/03 00:40:56 deraadt Exp $	*/
d16 1
d461 2
a462 3
 * create a buffer and put it in the list of
 * all buffers. Return pointer to the BUFFER
 * block for the buffer.
a467 2
	struct line	*lp;
	int		 i;
d478 22
a504 5
	if ((bp->b_bname = strdup(bname)) == NULL) {
		ewprintf("Can't get %d bytes", strlen(bname) + 1);
		free(bp);
		return (NULL);
	}
a505 1
		free(bp->b_bname);
d526 1
d532 1
d621 1
a621 1
baugname(char *bn, const char *fn, size_t bs)
d760 27
@


1.55
log
@lint love; ok kjell
@
text
@d1 1
a1 1
/*	$OpenBSD: buffer.c,v 1.54 2005/12/20 06:17:35 kjell Exp $	*/
d9 3
a13 1
#include <stdarg.h>
d593 25
@


1.54
log
@Clean up the ugly casted frees. In one case, this meant eliminating a nasty
struct/union/casting nightmare when building the list of names for filename
completion. In particular, be consistent about strduping and freeing
the list data.
@
text
@d1 1
a1 1
/*	$OpenBSD: buffer.c,v 1.53 2005/12/13 06:01:26 kjell Exp $	*/
d50 1
a50 1
			  EFNUL | EFNEW | EFBUF, curbp->b_altb->b_bname);
d79 1
a79 1
			  EFNEW | EFBUF);
d82 1
a82 1
			bufn, NBUFN, EFNUL | EFNEW | EFBUF, curbp->b_altb->b_bname);
@


1.53
log
@More name-clash delinting
@
text
@d1 1
a1 1
/*	$OpenBSD: buffer.c,v 1.52 2005/11/18 20:56:52 deraadt Exp $	*/
d187 1
a187 1
	free((char *)bp->b_bname);		/* Release name block	 */
d489 1
a489 1
		free((char *) bp->b_bname);
@


1.52
log
@greedy use of typedef struct was making code harder to read; ok kjell cloder
@
text
@d1 1
a1 1
/*	$OpenBSD: buffer.c,v 1.51 2005/11/13 07:49:02 kjell Exp $	*/
d428 1
a428 1
	char		 prompt[NFILEN + 11];
d433 1
a433 1
			ret = snprintf(prompt, sizeof(prompt), "Save file %s",
d435 1
a435 1
			if (ret < 0 || ret >= sizeof(prompt)) {
d439 1
a439 1
			if ((f == TRUE || (save = eyorn(prompt)) == TRUE) &&
@


1.51
log
@Better error checking of snprintfs. From Han Boetes.
@
text
@d1 1
a1 1
/*	$OpenBSD: buffer.c,v 1.50 2005/10/14 19:46:46 kjell Exp $	*/
d13 1
a13 1
static BUFFER  *makelist(void);
d41 1
a41 1
	BUFFER *bp;
d71 2
a72 2
	BUFFER *bp;
	MGWIN  *wp;
d109 1
a109 1
	BUFFER *bp;
d123 1
a123 1
killbuffer(BUFFER *bp)
d125 3
a127 3
	BUFFER *bp1;
	BUFFER *bp2;
	MGWIN  *wp;
d246 3
a248 3
	static int	 initialized = 0;
	BUFFER		*bp;
	MGWIN		*wp;
d273 1
a273 1
static BUFFER *
d276 3
a278 4
	int	w = ncol / 2;
	BUFFER *bp, *blp;
	LINE   *lp;

d341 4
a344 4
	BUFFER  *bp;
	MGWIN   *wp;
	char	*line = NULL;
	int	 i, ret = FALSE;
d393 1
a393 1
addlinef(BUFFER *bp, char *fmt, ...)
d395 2
a396 2
	va_list  ap;
	LINE	*lp;
d426 3
a428 3
	BUFFER *bp;
	int	s = FALSE, save = FALSE, ret;
	char	prompt[NFILEN + 11];
d462 1
a462 1
BUFFER *
d465 3
a467 3
	BUFFER	*bp;
	LINE	*lp;
	int	 i;
d478 1
a478 1
	bp = calloc(1, sizeof(BUFFER));
d480 1
a480 1
		ewprintf("Can't get %d bytes", sizeof(BUFFER));
d529 1
a529 1
bclear(BUFFER *bp)
d531 2
a532 2
	LINE  *lp;
	int    s;
d552 1
a552 1
showbuffer(BUFFER *bp, MGWIN *wp, int flags)
d554 2
a555 2
	BUFFER *obp;
	MGWIN  *owp;
d598 2
a599 2
MGWIN *
popbuf(BUFFER *bp)
d601 1
a601 1
	MGWIN  *wp;
d624 2
a625 2
	BUFFER *bp;
	LINE   *clp;
d681 1
a681 1
	MGWIN *wp;
d700 1
a700 1
popbuftop(BUFFER *bp)
d702 1
a702 1
	MGWIN *wp;
@


1.50
log
@add missing /* ARGSUSED */ to quiet lint.
@
text
@d1 1
a1 1
/*	$OpenBSD: buffer.c,v 1.49 2005/10/14 06:44:49 kjell Exp $	*/
d420 3
a422 3
 * Return TRUE if there are any changed buffers afterwards.  Buffers that
 * don't have an associated file don't count.  Return FALSE if there are
 * no changed buffers.
d428 1
a428 1
	int	s = FALSE, save = FALSE;
d434 1
a434 1
			snprintf(prompt, sizeof(prompt), "Save file %s",
d436 4
@


1.49
log
@Whoops. C-x C-v (filevisitalt) didn't work on inital scratch buffer.
It does now. Noted by deraadt.
@
text
@d1 1
a1 1
/*	$OpenBSD: buffer.c,v 1.48 2005/10/13 20:28:49 deraadt Exp $	*/
d15 1
@


1.48
log
@spacing
@
text
@d1 1
a1 1
/*	$OpenBSD: buffer.c,v 1.47 2005/10/13 05:34:11 kjell Exp $	*/
d141 1
a141 1
				return (FALSE);
@


1.47
log
@KNF and minor cleanup. Remove an impossible condition check.
Also, remove annoying "now readonly" message, as this information
is already reflected in the statusbar
@
text
@d1 1
a1 1
/*	$OpenBSD: buffer.c,v 1.46 2005/10/11 01:08:52 kjell Exp $	*/
d128 1
a128 1
	struct undo_rec *rec, *next;	
@


1.46
log
@A while back, undo records were moved from the BUFFER struct to MGWIN.
This is nonsensical, and utterly broken if you are undo-ing across
multiple buffers. Change them back to being associated with the BUFFER
struct. (effectively, just revert the original change)

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: buffer.c,v 1.45 2005/09/28 06:37:52 deraadt Exp $	*/
d18 1
a18 1
	if (!(curbp->b_flag & BFREADONLY)) {
d20 1
a20 2
		ewprintf("Now readonly");
	} else {
d27 1
a27 1
	return (1);
d388 1
a388 1
 * The argument "text" points to a format string.  Append this line to the
@


1.45
log
@fix buflist mode; pr 4524; from jason
@
text
@d1 1
a1 1
/*	$OpenBSD: buffer.c,v 1.44 2005/08/09 00:53:48 kjell Exp $	*/
d129 1
d180 7
d499 3
@


1.44
log
@Clean up eread handling in mg. (basically, fallout from the 'enter often
means abort' behaviour added during the hackathon). Eliminates
redundant ereply function, fixes miscellaneous cores when aborting,
and move a number of assumed pathnames into the prompt text, since
they are used there anyway. All changes consistent with emacs behavior

ok beck@@ many, many moons ago.
@
text
@d1 1
a1 1
/*	$OpenBSD: buffer.c,v 1.43 2005/06/14 18:14:40 kjell Exp $	*/
d219 1
a219 1
			'1', '1', listbuf_one, NULL
d222 1
a222 1
			CCHR('M'), CCHR('M'), listbuf_pf, NULL
@


1.43
log
@Add explicit public domain notices to all public domain files.
ok millert@@, deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: buffer.c,v 1.42 2005/06/03 15:18:05 cloder Exp $	*/
d54 1
a54 1
	if (bufn[0] == 0 && curbp->b_altb != NULL)
d85 1
a85 1
	if (bufp[0] == 0 && curbp->b_altb != NULL)
d115 1
a115 1
	else if (bufp[0] == 0)
@


1.42
log
@Fix memory leak.  OK kjell, with comments by beck and kjell
@
text
@d1 3
a3 1
/*	$OpenBSD: buffer.c,v 1.41 2005/06/03 08:23:12 kjell Exp $	*/
@


1.41
log
@Clean up find-alternate-file (C-x C-v) so abort returns to original
file, like its emacs ancestor.

ok cloder@@
@
text
@d1 1
a1 1
/*	$OpenBSD: buffer.c,v 1.40 2005/05/31 20:38:59 kjell Exp $	*/
d334 2
a335 2
	char	*line;
	int	 i;
d353 1
a353 1
		return (FALSE);
d360 1
a360 1
		return (FALSE);
d363 1
a363 1
		return (FALSE);
d368 6
a373 1
		return (onlywind(f, n));
d375 1
a375 1
	return (TRUE);
@


1.40
log
@fix broken minibuffer defaults introduced in echo.c:1.33
adds eread flag EFDEF allowing null minibuffer response
noticed by otto
ok cloder@@ jason@@, works otto@@
@
text
@d1 1
a1 1
/*	$OpenBSD: buffer.c,v 1.39 2005/05/25 05:57:32 jason Exp $	*/
d126 1
d145 2
a146 2
	if (bclear(bp) != TRUE)
		return (TRUE);
@


1.39
log
@'1' in buffer-list mode should open the listed buffer in its own window
(ie. it's just like ^M, except for a call to onlywind()).
@
text
@d1 1
a1 1
/*	$OpenBSD: buffer.c,v 1.38 2005/05/15 21:19:08 cloder Exp $	*/
d48 1
a48 1
			  EFNEW | EFBUF, curbp->b_altb->b_bname);
d80 1
a80 1
			bufn, NBUFN, EFNEW | EFBUF, curbp->b_altb->b_bname);
d110 2
a111 2
	if ((bufp = eread("Kill buffer: (default %s) ", bufn, NBUFN, EFNEW | EFBUF,
	    curbp->b_bname)) == NULL)
d610 1
a610 1
		    EFNEW | EFBUF, curbp->b_altb->b_bname);
@


1.38
log
@Fix insert-buffer prompt format string. strlcpy returns size_t, not int
(from Han Boetes). Improve error messages (from Han Boetes).
OK otto, jaredy, beck
@
text
@d1 1
a1 1
/*	$OpenBSD: buffer.c,v 1.37 2005/04/03 02:09:28 db Exp $	*/
d199 2
d205 4
d210 3
a212 3
static struct KEYMAPE (1 + IMAPEXT) listbufmap = {
	1,
	1 + IMAPEXT,
d215 6
a220 1
		{ CCHR('M'), CCHR('M'), listbuf_pf, NULL }
d319 12
d365 3
@


1.37
log
@This is a no binary change which does:

- spelling, punctuation fixes
- variable declaration lineup
- use parentheses for return and sizeof
- K&R function declarations -> ANSI
- other minor code beautification

ok henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: buffer.c,v 1.36 2005/03/10 16:58:57 deraadt Exp $	*/
d584 1
a584 1
		    EFNEW | EFBUF, &(curbp->b_altb->b_bname), NULL);
d586 1
a586 1
		bufp = eread("Insert buffer: ", bufn, NBUFN, EFNEW | EFBUF, NULL);
@


1.36
log
@spacing
@
text
@d1 1
a1 1
/*	$OpenBSD: buffer.c,v 1.35 2005/03/09 16:20:48 jfb Exp $	*/
d26 1
a26 1
	return(1);
d51 1
a51 1
		return ABORT;
d55 1
a55 1
		return FALSE;
d59 1
a59 1
	return showbuffer(bp, curwp, WFFORCE | WFHARD);
d82 1
a82 1
		return ABORT;
d86 1
a86 1
		return FALSE;
d90 1
a90 1
		return FALSE;
d93 1
a93 1
	return TRUE;
d112 1
a112 1
		return ABORT;
d116 2
a117 2
		return FALSE;
	return killbuffer(bp);
d128 1
a128 1
	 * Find some other buffer to display. try the alternate buffer,
d138 1
a138 1
				return FALSE;
d141 1
a141 1
				return FALSE;
d145 1
a145 1
		return TRUE;
d178 1
a178 1
	return TRUE;
d189 2
a190 2
		return ABORT;
	return TRUE;
d201 1
a201 1
	listbuf_goto_buffer,
d209 1
a209 1
		{ CCHR('M'), CCHR('M'), listbuf_pf, NULL },
d224 3
a226 3
	static int initialized = 0;
	BUFFER *bp;
	MGWIN  *wp;
d234 2
a235 2
		return FALSE;
	wp->w_dotp = bp->b_dotp;/* fix up if window already on screen */
d241 1
a241 1
	return TRUE;
d246 4
a249 3
 * list buffers command. Return TRUE if
 * everything works. Return FALSE if there
 * is an error (if there is no memory).
d260 1
a260 1
		return NULL;
d262 1
a262 1
		return NULL;
d270 1
a270 1
		return NULL;
d297 1
a297 1
			return NULL;
d302 1
a302 1
	return blp;				/* All done		 */
d308 4
a311 4
	BUFFER *bp;
	MGWIN *wp;
	char *line;
	int i;
d315 1
a315 1
		return FALSE;
d319 1
a319 1
		return FALSE;
d328 2
a329 3
	if (i == 0) {
		return FALSE;
	}
d335 3
a337 3
	if (bp == NULL) {
		return FALSE;
	}
d339 1
a339 1
		return FALSE;
d343 1
a343 1
	return TRUE;
d354 2
a355 2
	va_list ap;
	LINE  *lp;
d373 1
a373 1
	return TRUE;
d386 2
a387 2
	int s = FALSE, save = FALSE;
	char prompt[NFILEN + 11];
d392 1
a392 1
			snprintf(prompt, sizeof prompt, "Save file %s",
d407 1
a407 1
	return s;
d427 1
a427 1
			return bp;
d431 1
a431 1
		return NULL;
d436 1
a436 1
		return NULL;
d441 1
a441 1
		return NULL;
d446 1
a446 1
		return NULL;
d467 1
a467 1
	return bp;
d486 1
a486 1
	if ((bp->b_flag & BFCHG) != 0 &&	/* Changed.		 */
d496 1
a496 1
	return TRUE;
d513 1
a513 1
		return TRUE;
d515 1
a515 1
	/* First, dettach the old buffer from the window */
d543 1
a543 1
	return TRUE;
d557 1
a557 1
			return NULL;
d562 1
a562 1
				return wp;
d565 2
a566 2
		return NULL;
	return wp;
d588 1
a588 1
		return ABORT;
d592 1
a592 1
		return FALSE;
d596 1
a596 1
		return FALSE;
d604 1
a604 1
				return FALSE;
d608 1
a608 1
			return FALSE;
d616 1
a616 1
	clp = curwp->w_linep;	/* cosmetic adjustment */
d620 1
a620 1
		curwp->w_linep = clp;	/* adjust framing.	 */
d643 1
a643 1
	return TRUE;
d666 1
a666 1
	return popbuf(bp) != NULL;
@


1.35
log
@fix mg's behaviour with regards to files on which we do not have
write access.  diff originally from vincent@@ and forgotten for
a while.

ok rohee@@, "toss it in, i'll bitch if it doesn't work" henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: buffer.c,v 1.34 2004/07/22 01:25:24 vincent Exp $	*/
d386 2
a387 2
	int     s = FALSE, save = FALSE;
	char    prompt[NFILEN + 11];
d578 2
a579 3
	int     clo;
	int     nline;
	char    bufn[NBUFN], *bufp;
@


1.34
log
@stage 1 of the infinite minibuffer work - add support for on the fly
buffer reallocation in veread().  This commit only changes the API.
All the buffers have exactly the same bounds as before for now.

tested by a couple of my very helpful testers!
@
text
@d1 1
a1 1
/*	$OpenBSD: buffer.c,v 1.33 2003/10/21 22:48:07 vincent Exp $	*/
d105 1
a105 1
killbuffer(int f, int n)
a107 3
	BUFFER *bp1;
	BUFFER *bp2;
	MGWIN  *wp;
d117 9
@


1.33
log
@make undo records per MGWIN, not per BUFFER...
@
text
@d1 1
a1 1
/*	$OpenBSD: buffer.c,v 1.32 2003/08/15 23:23:18 vincent Exp $	*/
d40 1
a40 2
	int     s;
	char    bufn[NBUFN];
d45 1
a45 1
		s = eread("Switch to buffer: ", bufn, NBUFN, EFNEW | EFBUF);
d47 1
a47 1
		s = eread("Switch to buffer: (default %s) ", bufn, NBUFN,
d50 3
a52 3
	if (s == ABORT)
		return s;
	if (s == FALSE && curbp->b_altb != NULL)
d71 1
a71 2
	int     s;
	char    bufn[NBUFN];
d76 1
a76 1
		s = eread("Switch to buffer in other window: ", bufn, NBUFN,
d79 1
a79 1
		s = eread("Switch to buffer in other window: (default %s) ",
d81 3
a83 3
	if (s == ABORT)
		return s;
	if (s == FALSE && curbp->b_altb != NULL)
d111 1
a111 2
	int     s;
	char    bufn[NBUFN];
d113 4
a116 4
	if ((s = eread("Kill buffer: (default %s) ", bufn, NBUFN, EFNEW | EFBUF,
	    curbp->b_bname)) == ABORT)
		return (s);
	else if (s == FALSE)
d574 1
a574 2
	int     s;
	char    bufn[NBUFN];
d578 2
a579 2
		s = eread("Insert buffer: (default %s) ", bufn, NBUFN,
			  EFNEW | EFBUF, &(curbp->b_altb->b_bname), NULL);
d581 4
a584 4
		s = eread("Insert buffer: ", bufn, NBUFN, EFNEW | EFBUF, NULL);
	if (s == ABORT)
		return (s);
	if (s == FALSE && curbp->b_altb != NULL)
@


1.32
log
@make dired work more like emacs. (well, make it _work_, and then add a
bunch of missing commands)
@
text
@d1 1
a1 1
/*	$OpenBSD: buffer.c,v 1.31 2003/06/26 23:04:10 vincent Exp $	*/
a114 1
	struct undo_rec *rec, *next;
a172 6
	rec = LIST_FIRST(&bp->b_undo);
	while (rec != NULL) {
		next = LIST_NEXT(rec, next);
		free_undo_record(rec);
		rec = next;
	}
a453 3
	LIST_INIT(&bp->b_undo);
	bp->b_undoptr = NULL;
	memset(&bp->b_undopos, 0, sizeof bp->b_undopos);
@


1.31
log
@protos

ok deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: buffer.c,v 1.30 2002/07/25 16:40:57 vincent Exp $	*/
d437 2
a438 1
	if ((bp = malloc(sizeof(BUFFER))) == NULL) {
d499 1
a499 1
	bp->b_dotp = bp->b_linep;	/* Fix "."		 */
d516 1
a516 1
	if (wp->w_bufp == bp) {	/* Easy case!	 */
d518 2
@


1.30
log
@use vasprintf() instead of vsnprintf + malloc + vsnprintf hack;idea from deraadt

ok art
@
text
@d1 1
a1 1
/*	$OpenBSD: buffer.c,v 1.29 2002/06/19 22:05:58 vincent Exp $	*/
d14 1
a14 1
togglereadonly(void)
@


1.29
log
@initialize some undo-related variables.

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: buffer.c,v 1.28 2002/03/16 19:30:29 vincent Exp $	*/
a359 2
	int    ntext;
	char   dummy[1];
d361 2
d364 2
a365 2
	ntext = vsnprintf(dummy, 1, fmt, ap);
	if (ntext == -1) {
d367 1
a367 1
		return FALSE;
d369 1
a369 9
	ntext++;
	if ((lp = lalloc(ntext)) == NULL) {
		va_end(ap);
		return FALSE;
	}
	va_end(ap);
	va_start(ap, fmt);
	vsnprintf(lp->l_text, ntext, fmt, ap);
	lp->l_used--;
@


1.28
log
@ Make these special buffers readonly by default. ok art@@
@
text
@d1 1
a1 1
/*	$OpenBSD: buffer.c,v 1.27 2002/03/16 04:17:36 vincent Exp $	*/
d444 2
a445 2
	/* NOSTRICT */
	if ((bp = (BUFFER *) malloc(sizeof(BUFFER))) == NULL) {
d451 1
a451 1
		free((char *) bp);
d456 1
a456 1
		free((char *) bp);
d469 2
@


1.27
log
@ add readonly buffer support
 plus some KNF

 ok art@@
@
text
@d1 1
a1 1
/*	$OpenBSD: buffer.c,v 1.26 2002/03/11 13:02:56 vincent Exp $	*/
d267 1
@


1.26
log
@  * Move to ANSI function definitions.
  * Add a whole lot of consts where I thought it made sense

   no ok, but no objections either...
@
text
@d1 1
a1 1
/*	$OpenBSD: buffer.c,v 1.25 2002/03/05 20:31:10 vincent Exp $	*/
d13 16
a179 1

d291 1
a291 1
		    ' ',			/* no readonly buffers yet */
@


1.25
log
@ Fix a ridiculous bug I introduced in the buffer code.  Free the undo records
list correctly.
@
text
@d1 1
a1 1
/*	$OpenBSD: buffer.c,v 1.24 2002/02/26 00:45:45 vincent Exp $	*/
d21 1
a21 2
usebuffer(f, n)
	int     f, n;
d52 1
a52 2
poptobuffer(f, n)
	int     f, n;
d91 1
a91 2
killbuffer(f, n)
	int     f, n;
d165 1
a165 1
	free(bp->b_bname);			/* Release name block	 */
d175 1
a175 2
savebuffers(f, n)
	int f, n;
d211 1
a211 2
listbuffers(f, n)
	int f, n;
a221 1

d240 1
a240 1
makelist()
d379 1
a379 2
anycb(f)
	int     f;
d414 1
a414 3
bfind(bname, cflag)
	char *bname;
	int   cflag;
d439 1
a439 1
		free(bp->b_bname);
d477 1
a477 2
bclear(bp)
	BUFFER *bp;
d500 1
a500 4
showbuffer(bp, wp, flags)
	BUFFER *bp;
	MGWIN  *wp;
	int     flags;
d545 1
a545 2
popbuf(bp)
	BUFFER *bp;
d568 1
a568 1
bufferinsert(f, n)
d627 1
a627 1
notmodified(f, n)
d648 1
a648 2
popbuftop(bp)
	BUFFER *bp;
@


1.24
log
@keep undo records in the BUFFER structures insteda of having a huge list.
@
text
@d1 1
a1 1
/*	$OpenBSD: buffer.c,v 1.23 2002/02/21 00:04:10 dhartmei Exp $	*/
d102 1
a102 1
	struct undo_rec *rec;
d161 3
a163 1
	while ((rec = LIST_FIRST(&bp->b_undo)) != NULL) {
d165 1
a165 1
		LIST_REMOVE(rec, next);
d167 1
@


1.23
log
@It seems you need to have hacked mg at some point to be considered a
true old fart, so here's my contribution ;)

Don't use the same va_list twice without re-va_start()ing it, doesn't
work on macppc.
@
text
@d1 1
a1 1
/*	$OpenBSD: buffer.c,v 1.22 2002/02/16 21:27:49 millert Exp $	*/
d102 1
d161 4
d458 1
@


1.22
log
@Part one of userland __P removal.  Done with a simple regexp with some minor hand editing to make comments line up correctly.  Another pass is forthcoming that handles the cases that could not be done automatically.
@
text
@d1 1
a1 1
/*	$OpenBSD: buffer.c,v 1.21 2002/02/14 14:24:21 deraadt Exp $	*/
d346 1
a346 1
	ntext = vsnprintf(dummy, 1, fmt, ap) + 1;
d351 1
d356 2
@


1.21
log
@some KNF
@
text
@d1 1
a1 1
/*	$OpenBSD: buffer.c,v 1.20 2002/02/13 03:03:49 vincent Exp $	*/
d11 1
a11 1
static BUFFER  *makelist	__P((void));
@


1.20
log
@ * Replace unsafe strcpy and strcat calls to safe strlcpy and strlcat.
 * Be a little bit more verbose about some errors
 * Fix some memory leaks in fileio.c

ok deraadt@@, art@@
@
text
@d1 1
a1 1
/*	$OpenBSD: buffer.c,v 1.19 2002/01/18 09:40:07 art Exp $	*/
d29 2
a30 2
	if ((curbp->b_altb == NULL)
	    && ((curbp->b_altb = bfind("*scratch*", TRUE)) == NULL))
d62 2
a63 2
	if ((curbp->b_altb == NULL)
	    && ((curbp->b_altb = bfind("*scratch*", TRUE)) == NULL))
d104 1
a104 1
		       curbp->b_bname)) == ABORT)
d382 2
a383 2
		if (bp->b_fname != NULL && *(bp->b_fname) != '\0'
		    && (bp->b_flag & BFCHG) != 0) {
d386 2
a387 2
			if ((f == TRUE || (save = eyorn(prompt)) == TRUE)
			    && buffsave(bp) == TRUE) {
d480 2
a481 2
	if ((bp->b_flag & BFCHG) != 0	/* Changed.		 */
	    && (s = eyesno("Buffer modified; kill anyway")) != TRUE)
@


1.19
log
@When listing buffers, detect if the buffer name is too long to fit in the
designated space and if it's too long, truncate it correctly and print
a '$'-sign at the end of the name.

Add support for selecting a buffer with ^M in the buffer list.
@
text
@d1 1
a1 1
/*	$OpenBSD: buffer.c,v 1.18 2002/01/18 08:37:08 art Exp $	*/
d431 1
a431 1
	if ((bp->b_bname = malloc((strlen(bname) + 1))) == NULL) {
a455 1
	(void) strcpy(bp->b_bname, bname);
@


1.18
log
@Remove the NROW and NCOL limits. The static arrays are now replaced with
dynamically allocated memory.
Code written by Vincent Labrecque <limitln@@Psyfreaks.CA> with some minor
tweaks by me.
@
text
@d1 1
a1 1
/*	$OpenBSD: buffer.c,v 1.17 2001/11/25 07:34:17 deraadt Exp $	*/
d179 20
d210 1
d214 6
d224 4
d244 1
d251 2
d271 1
a271 1
		if (addlinef(blp, "%c%c%c %-*s%-6d %-*s",
d275 2
a276 1
		    w - 4,		/* four chars already written */
d278 1
d288 42
@


1.17
log
@snprintf makes me happy
@
text
@d1 1
a1 1
/*	$OpenBSD: buffer.c,v 1.16 2001/08/18 21:36:11 deraadt Exp $	*/
d304 1
a304 1
		if (*(bp->b_fname) != '\0'
@


1.16
log
@handle vsnprintf returning -1
@
text
@d1 1
a1 1
/*	$OpenBSD: buffer.c,v 1.15 2001/05/24 03:05:20 mickey Exp $	*/
d306 2
a307 1
			sprintf(prompt, "Save file %s", bp->b_fname);
@


1.15
log
@spaces
@
text
@d1 1
a1 1
/*	$OpenBSD: buffer.c,v 1.14 2001/05/23 22:36:13 art Exp $	*/
d269 4
@


1.14
log
@Get rid of unnecessary casts of NULL.
@
text
@d1 1
a1 1
/*	$OpenBSD: buffer.c,v 1.13 2001/05/23 22:26:24 art Exp $	*/
d333 1
a333 1
	int	 i; 
@


1.13
log
@sprintf instead of two strcpy (there was a bug here)
@
text
@d1 1
a1 1
/*	$OpenBSD: buffer.c,v 1.12 2001/05/23 22:20:34 art Exp $	*/
d500 1
a500 2
			  EFNEW | EFBUF, &(curbp->b_altb->b_bname),
			  (char *) NULL);
d502 1
a502 2
		s = eread("Insert buffer: ", bufn, NBUFN, EFNEW | EFBUF,
			  (char *) NULL);
@


1.12
log
@remove VOID. We're way beyond the point where this could build with an
ancient compiler.
@
text
@d1 1
a1 1
/*	$OpenBSD: buffer.c,v 1.11 2001/05/23 15:50:27 art Exp $	*/
d302 1
a302 2
			(void) strcpy(prompt, "Save file ");
			(void) strcpy(prompt + 10, bp->b_fname);
@


1.11
log
@Creatively use addlinef when listing buffers (C-X-C-B).

This also fixes the strange formatting that showed up when the maximal buffer
name grew. Now the "Size" column starts in the middle of the visible window
instead of far outside.
@
text
@d1 1
a1 1
/*	$OpenBSD: buffer.c,v 1.10 2001/05/23 15:46:25 art Exp $	*/
d302 2
a303 2
			(VOID) strcpy(prompt, "Save file ");
			(VOID) strcpy(prompt + 10, bp->b_fname);
d374 1
a374 1
	(VOID) strcpy(bp->b_bname, bname);
@


1.10
log
@Don't include the trailing NUL in output.
@
text
@d1 1
a1 1
/*	$OpenBSD: buffer.c,v 1.9 2001/05/23 15:39:35 art Exp $	*/
a10 1
static RSIZE    itor		__P((char *, int, RSIZE));
d209 2
a210 4
	char   *cp1;
	char   *cp2;
	int     c;
	BUFFER *bp;
a211 4
	RSIZE   nbytes;
	BUFFER *blp;
	char    b[6 + 1];
	char    line[NBUFN+128];
d219 2
a220 6
	(VOID) strcpy(line, " MR Buffer");
	cp1 = line + 10;
	while (cp1 < line + 4 + NBUFN + 1)
		*cp1++ = ' ';
	(VOID) strcpy(cp1, "Size   File");
	if (addline(blp, line) == FALSE)
d222 4
a225 19
	(VOID) strcpy(line, " -- ------");
	cp1 = line + 10;
	while (cp1 < line + 4 + NBUFN + 1)
		*cp1++ = ' ';
	(VOID) strcpy(cp1, "----   ----");
	if (addline(blp, line) == FALSE)
		return NULL;
	bp = bheadp;				/* For all buffers	 */
	while (bp != NULL) {
		cp1 = &line[0];			/* Start at left edge	 */
		*cp1++ = (bp == curbp) ? '.' : ' ';
		*cp1++ = ((bp->b_flag & BFCHG) != 0) ? '*' : ' ';
		*cp1++ = ' ';			/* Gap.			 */
		*cp1++ = ' ';
		cp2 = &bp->b_bname[0];		/* Buffer name		 */
		while ((c = *cp2++) != 0)
			*cp1++ = c;
		while (cp1 < &line[4 + NBUFN + 1])
			*cp1++ = ' ';
d236 10
a245 14
		(VOID) itor(b, 6, nbytes);	/* 6 digit buffer size. */
		cp2 = &b[0];
		while ((c = *cp2++) != 0)
			*cp1++ = c;
		*cp1++ = ' ';			/* Gap..		 */
		cp2 = &bp->b_fname[0];		/* File name		 */
		if (*cp2 != 0) {
			while ((c = *cp2++) != 0) {
				if (cp1 < &line[128 - 1])
					*cp1++ = c;
			}
		}
		*cp1 = 0;	/* Add to the buffer.	 */
		if (addline(blp, line) == FALSE)
a246 1
		bp = bp->b_bufp;
a251 24
}

/*
 * Used above.
 */
static RSIZE 
itor(buf, width, num)
	char  *buf;
	int    width;
	RSIZE  num;
{
	RSIZE  r;

	if (num / 10 == 0) {
		buf[0] = (num % 10) + '0';
		for (r = 1; r < width; buf[r++] = ' ');
		buf[width] = '\0';
		return 1;
	} else {
		buf[r = itor(buf, width, num / (RSIZE) 10)] =
			(num % (RSIZE) 10) + '0';
		return r + 1;
	}
	/* NOTREACHED */
@


1.9
log
@It's unnecessary to have addline as a function. Make it a macro.
@
text
@d1 1
a1 1
/*	$OpenBSD: buffer.c,v 1.8 2001/05/23 15:35:10 art Exp $	*/
d329 1
@


1.8
log
@Add addlinef that's an addline with printf-style format arguments.
Make addline a wrapper around addlinef. (should go away)
@
text
@d1 1
a1 1
/*	$OpenBSD: buffer.c,v 1.7 2001/05/04 22:00:35 art Exp $	*/
a318 1
	int    i;
a336 9
}

/*
 * Wrapper for addlinef with just one string. Should go away.
 */
int
addline(BUFFER *bp, char *text)
{
	return addlinef(bp, "%s", text);
@


1.7
log
@Cleanups in filename and buffer name handling.
Mostly just using libc instead of rolling our own.
@
text
@d1 1
a1 1
/*	$OpenBSD: buffer.c,v 1.6 2001/05/04 21:47:41 art Exp $	*/
d9 1
d310 1
a310 1
 * The argument "text" points to a string.  Append this line to the
d315 1
a315 3
addline(bp, text)
	BUFFER *bp;
	char   *text;
d317 1
d321 1
d323 4
a326 2
	ntext = strlen(text);
	if ((lp = lalloc(ntext)) == NULL)
d328 4
a331 2
	for (i = 0; i < ntext; ++i)
		lputc(lp, i, text[i]);
d336 1
a336 6
#ifdef CANTHAPPEN
	if (bp->b_dotp == bp->b_linep)		/* If "." is at the end	 */
		bp->b_dotp = lp;		/* move it to new line	 */
	if (bp->b_markp == bp->b_linep)		/* ditto for mark	 */
		bp->b_markp = lp;
#endif
d338 9
@


1.6
log
@Qick fix for an overflow in C-X C-B.
This function needs a lot of work.
@
text
@d1 1
a1 1
/*	$OpenBSD: buffer.c,v 1.5 2001/01/29 01:58:06 niklas Exp $	*/
d393 1
a393 1
		if (fncmp(bname, bp->b_bname) == 0)
@


1.5
log
@$OpenBSD$
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d217 1
a217 1
	char    line[128];
@


1.4
log
@More -Wall anmd KNF, from op2@@tomahawk.SQUiSH.org
@
text
@d1 2
@


1.3
log
@The start of KNF + -Wall.  The code has been run through indent but
needs hand fixup.  I stopped at keymap.c...
@
text
@d4 3
a6 2
#include	"def.h"
#include	"kbd.h"		/* needed for modes */
a57 1
	MGWIN  *popbuf();
a170 1

d186 1
a186 1
	int     f, n;
d382 2
a383 2
	char           *bname;
	int             cflag;
d385 3
a387 6
	BUFFER         *bp;
	LINE           *lp;
	int             i;
	extern int      defb_nmodes;
	extern MAPS    *defb_modes[PBMODES];
	extern int      defb_flag;
@


1.2
log
@change WINDOW -> MGWIN to avoid curses type conflict
convert to terminfo in tty*.c
add support for some keypad function keys (arrows, pgup, pgdown)
@
text
@d5 1
a5 1
#include	"kbd.h"			/* needed for modes */
d7 2
a8 1
static RSIZE	itor();
d16 2
a17 1
/*ARGSUSED*/
d19 1
d21 3
a23 3
	register BUFFER *bp;
	register int	s;
	char		bufn[NBUFN];
d28 1
a28 1
		s=eread("Switch to buffer: ", bufn, NBUFN, EFNEW|EFBUF);
d30 2
a31 2
		s=eread("Switch to buffer: (default %s) ", bufn, NBUFN,
			 EFNEW|EFBUF, curbp->b_altb->b_bname);
d33 6
a38 3
	if (s == ABORT) return s;
	if (s == FALSE && curbp->b_altb != NULL) bp = curbp->b_altb ;
	else if ((bp=bfind(bufn, TRUE)) == NULL) return FALSE;
d42 1
a42 1
	return showbuffer(bp, curwp, WFFORCE|WFHARD);
d48 2
a49 1
/*ARGSUSED*/
d51 1
d53 5
a57 5
	register BUFFER *bp;
	register MGWIN *wp;
	register int	s;
	char		bufn[NBUFN];
	MGWIN	*popbuf();
d62 2
a63 2
		s=eread("Switch to buffer in other window: ", bufn, NBUFN,
			EFNEW|EFBUF);
d65 8
a72 5
		s=eread("Switch to buffer in other window: (default %s) ",
			 bufn, NBUFN, EFNEW|EFBUF, curbp->b_altb->b_bname);
	if (s == ABORT) return s;
	if (s == FALSE && curbp->b_altb != NULL) bp = curbp->b_altb ;
	else if ((bp=bfind(bufn, TRUE)) == NULL) return FALSE;
d75 2
a76 1
	if ((wp = popbuf(bp)) == NULL) return FALSE;
d89 2
a90 1
/*ARGSUSED*/
d92 1
d94 20
a113 16
	register BUFFER *bp;
	register BUFFER *bp1;
	register BUFFER *bp2;
	MGWIN		*wp;
	register int	s;
	char		bufn[NBUFN];

	if ((s=eread("Kill buffer: (default %s) ", bufn, NBUFN, EFNEW|EFBUF,
		    curbp->b_bname)) == ABORT) return (s);
	else if (s == FALSE) bp = curbp;
	else if ((bp=bfind(bufn, FALSE)) == NULL) return FALSE;

	/* find some other buffer to display. try the alternate buffer,
	 * then the first different buffer in the buffer list.	if
	 * there's only one buffer, create buffer *scratch* and make
	 * it the alternate buffer.  return if *scratch* is only buffer
d119 1
a119 1
			if (bp == bfind("*scratch*",FALSE))
d122 1
a122 1
			if ((bp1 = bfind("*scratch*",TRUE)) == NULL)
d126 2
a127 1
	if (bclear(bp) != TRUE) return TRUE;
d129 12
a140 10
	    if (wp->w_bufp == bp) {
		bp2 = bp1->b_altb;		/* save alternate buffer */
		if(showbuffer(bp1, wp, WFMODE|WFFORCE|WFHARD) != NULL)
			bp1->b_altb = bp2;
		else	bp1 = bp2;
	    }
	}
	if (bp == curbp) curbp = bp1;
	free((char *) bp->b_linep);		/* Release header line. */
	bp2 = NULL;				/* Find the header.	*/
d148 2
a149 2
	bp1 = bp1->b_bufp;			/* Next one in chain.	*/
	if (bp2 == NULL)			/* Unlink it.		*/
d153 1
a153 1
	while (bp1 != NULL) {			/* Finish with altb's	*/
d158 2
a159 2
	free(bp->b_bname);			/* Release name block	*/
	free((char *) bp);			/* Release buffer block */
d166 2
a167 1
/*ARGSUSED*/
d169 1
d171 3
a173 1
	if (anycb(f) == ABORT) return ABORT;
d184 2
a185 1
/*ARGSUSED*/
d187 1
d189 2
a190 4
	register BUFFER *bp;
	register MGWIN *wp;
	BUFFER		*makelist();
	MGWIN		*popbuf();
d192 1
a192 1
	if ((bp=makelist()) == NULL || (wp=popbuf(bp)) == NULL)
d194 1
a194 1
	wp->w_dotp = bp->b_dotp;	/* fix up if window already on screen */
d205 18
a222 15
BUFFER *
makelist() {
	register char	*cp1;
	register char	*cp2;
	register int	c;
	register BUFFER *bp;
	LINE		*lp;
	register RSIZE	nbytes;
	BUFFER		*blp;
	char		b[6+1];
	char		line[128];

	if ((blp = bfind("*Buffer List*", TRUE)) == NULL) return NULL;
	if (bclear(blp) != TRUE) return NULL;
	blp->b_flag &= ~BFCHG;			/* Blow away old.	*/
d226 2
a227 1
	while(cp1 < line + 4 + NBUFN + 1) *cp1++ = ' ';
d229 2
a230 1
	if (addline(blp, line) == FALSE) return NULL;
d233 2
a234 1
	while(cp1 < line + 4 + NBUFN + 1) *cp1++ = ' ';
d236 3
a238 2
	if (addline(blp, line) == FALSE) return NULL;
	bp = bheadp;				/* For all buffers	*/
d240 1
a240 1
		cp1 = &line[0];			/* Start at left edge	*/
d242 2
a243 2
		*cp1++ = ((bp->b_flag&BFCHG) != 0) ? '*' : ' ';
		*cp1++ = ' ';			/* Gap.			*/
d245 1
a245 1
		cp2 = &bp->b_bname[0];		/* Buffer name		*/
d248 1
a248 1
		while (cp1 < &line[4+NBUFN+1])
d250 1
a250 1
		nbytes = 0;			/* Count bytes in buf.	*/
d254 1
a254 1
				nbytes += llength(lp)+1;
d257 2
a258 1
			if(nbytes) nbytes--;	/* no bonus newline	*/
d264 2
a265 2
		*cp1++ = ' ';			/* Gap..			*/
		cp2 = &bp->b_fname[0];		/* File name		*/
d268 1
a268 1
				if (cp1 < &line[128-1])
d272 1
a272 1
		*cp1 = 0;			/* Add to the buffer.	*/
d277 2
a278 1
	blp->b_dotp = lforw(blp->b_linep);	/* put dot at beginning of buffer */
d280 1
a280 1
	return blp;				/* All done		*/
d286 7
a292 3
static RSIZE itor(buf, width, num)
register char buf[]; register int width; register RSIZE num; {
	register RSIZE r;
d296 1
a296 2
		for (r = 1; r < width; buf[r++] = ' ')
			;
d300 2
a301 2
		buf[r = itor(buf, width, num / (RSIZE)10)] =
				(num % (RSIZE)10) + '0';
d304 1
a304 1
	/*NOTREACHED*/
d308 2
a309 4
 * The argument "text" points to
 * a string. Append this line to the
 * buffer. Handcraft the EOL
 * on the end. Return TRUE if it worked and
d312 8
a319 4
addline(bp, text) register BUFFER *bp; char *text; {
	register LINE	*lp;
	register int	i;
	register int	ntext;
d322 1
a322 1
	if ((lp=lalloc(ntext)) == NULL)
d324 1
a324 1
	for (i=0; i<ntext; ++i)
d326 1
a326 1
	bp->b_linep->l_bp->l_fp = lp;		/* Hook onto the end	*/
d331 3
a333 3
	if (bp->b_dotp == bp->b_linep)		/* If "." is at the end	*/
		bp->b_dotp = lp;		/* move it to new line	*/
	if (bp->b_markp == bp->b_linep)		/* ditto for mark	*/
d340 12
a351 11
 * Look through the list of buffers, giving the user
 * a chance to save them.  Return TRUE if there are
 * any changed buffers afterwards. Buffers that don't
 * have an associated file don't count. Return FALSE
 * if there are no changed buffers.
 */
anycb(f) {
	register BUFFER *bp;
	register int	s = FALSE, save = FALSE;
	char		prompt[NFILEN + 11];
	VOID		upmodes();
d355 1
a355 1
		&&  (bp->b_flag&BFCHG) != 0) {
d359 1
a359 1
			&&  buffsave(bp) == TRUE) {
d362 4
a365 2
			} else s = TRUE;
			if (save == ABORT) return (save);
d381 11
a391 9
BUFFER	*
bfind(bname, cflag) register char *bname; {
	register BUFFER *bp;
	char		*malloc();
	register LINE	*lp;
	int i;
	extern int defb_nmodes;
	extern MAPS *defb_modes[PBMODES];
	extern int defb_flag;
d399 4
a402 3
	if (cflag!=TRUE) return NULL;
	/*NOSTRICT*/
	if ((bp=(BUFFER *)malloc(sizeof(BUFFER))) == NULL) {
d406 2
a407 2
	if ((bp->b_bname=malloc((unsigned)(strlen(bname)+1))) == NULL) {
		ewprintf("Can't get %d bytes", strlen(bname)+1);
d416 3
a418 3
	bp->b_altb = bp->b_bufp	 = NULL;
	bp->b_dotp  = lp;
	bp->b_doto  = 0;
d421 2
a422 2
	bp->b_flag  = defb_flag;
	bp->b_nwnd  = 0;
d427 2
a428 2
	    bp->b_modes[i] = defb_modes[i];
	} while(i++ < defb_nmodes);
d449 6
a454 4
bclear(bp) register BUFFER *bp; {
	register LINE	*lp;
	register int	s;
	VOID		lfree();
d456 2
a457 2
	if ((bp->b_flag&BFCHG) != 0		/* Changed.		*/
	&& (s=eyesno("Buffer modified; kill anyway")) != TRUE)
d459 2
a460 2
	bp->b_flag  &= ~BFCHG;			/* Not changed		*/
	while ((lp=lforw(bp->b_linep)) != bp->b_linep)
d462 3
a464 3
	bp->b_dotp  = bp->b_linep;		/* Fix "."		*/
	bp->b_doto  = 0;
	bp->b_markp = NULL;			/* Invalidate "mark"	*/
d473 8
a480 3
showbuffer(bp, wp, flags) register BUFFER *bp; register MGWIN *wp; {
	register BUFFER *obp;
	MGWIN		*owp;
d482 1
a482 1
	if (wp->w_bufp == bp) {			/* Easy case!	*/
a485 1

d489 2
a490 2
			obp->b_dotp  = wp->w_dotp;
			obp->b_doto  = wp->w_doto;
a494 1

d498 3
a500 3
	if (bp->b_nwnd++ == 0) {		/* First use.		*/
		wp->w_dotp  = bp->b_dotp;
		wp->w_doto  = bp->b_doto;
d504 1
a504 1
	/* already on screen, steal values from other window */
d507 2
a508 2
				wp->w_dotp  = owp->w_dotp;
				wp->w_doto  = owp->w_doto;
d513 1
a513 1
	wp->w_flag |= WFMODE|flags;
d522 4
a525 2
popbuf(bp) register BUFFER *bp; {
	register MGWIN *wp;
d527 3
a529 2
	if (bp->b_nwnd == 0) {		/* Not on screen yet.	*/
		if ((wp=wpopup()) == NULL) return NULL;
d533 2
a534 2
				wp->w_flag |= WFHARD|WFFORCE;
				return wp ;
d536 2
a537 1
	if (showbuffer(bp, wp, WFHARD) != TRUE) return NULL;
d544 2
a545 1
/*ARGSUSED*/
d548 6
a553 6
	register BUFFER *bp;
	register LINE	*clp;
	register int	clo;
	register int	nline;
	int		s;
	char		bufn[NBUFN];
d557 3
a559 3
		s=eread("Insert buffer: (default %s) ", bufn, NBUFN,
			 EFNEW|EFBUF, &(curbp->b_altb->b_bname),
			 (char *) NULL) ;
d561 8
a568 5
		s=eread("Insert buffer: ", bufn, NBUFN, EFNEW|EFBUF,
			 (char *) NULL) ;
	if (s == ABORT) return (s);
	if (s == FALSE && curbp->b_altb != NULL) bp = curbp->b_altb;
	else if ((bp=bfind(bufn, FALSE)) == NULL) return FALSE;
d570 1
a570 1
	if (bp==curbp) {
a573 1

d577 1
a577 1
	for(;;) {
d581 3
a583 2
		if((clp = lforw(clp)) == bp->b_linep) break;
		if (newline(FFRAND, 1) == FALSE) /* fake newline */
d587 4
a590 2
	if (nline == 1) ewprintf("[Inserted 1 line]");
	else	ewprintf("[Inserted %d lines]", nline);
d592 3
a594 3
	clp = curwp->w_linep;			/* cosmetic adjustment */
	if (curwp->w_dotp == clp) {		/* for offscreen insert */
		while (nline-- && lback(clp)!=curbp->b_linep)
d596 1
a596 1
		curwp->w_linep = clp;		/* adjust framing.	*/
d605 2
a606 1
/*ARGSUSED*/
d609 1
a609 1
	register MGWIN *wp;
d612 1
a612 1
	wp = wheadp;				/* Update mode lines.	*/
d627 1
a627 1

d629 1
a629 1
register BUFFER *bp;
d631 1
a631 1
    register MGWIN *wp;
d633 11
a643 11
    bp->b_dotp = lforw(bp->b_linep);
    bp->b_doto = 0;
    if(bp->b_nwnd != 0) {
	for(wp = wheadp; wp!=NULL; wp = wp->w_wndp)
	    if(wp->w_bufp == bp) {
		wp->w_dotp = bp->b_dotp;
		wp->w_doto = 0;
		wp->w_flag |= WFHARD;
	    }
    }
    return popbuf(bp) != NULL;
@


1.1
log
@initial import of mg2a
@
text
@d46 1
a46 1
	register WINDOW *wp;
d49 1
a49 1
	WINDOW	*popbuf();
d83 1
a83 1
	WINDOW		*wp;
d163 1
a163 1
	register WINDOW *wp;
d165 1
a165 1
	WINDOW		*popbuf();
d426 1
a426 1
showbuffer(bp, wp, flags) register BUFFER *bp; register WINDOW *wp; {
d428 1
a428 1
	WINDOW		*owp;
d471 1
a471 1
WINDOW *
d473 1
a473 1
	register WINDOW *wp;
d548 1
a548 1
	register WINDOW *wp;
d570 1
a570 1
    register WINDOW *wp;
@

