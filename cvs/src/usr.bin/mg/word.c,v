head	1.19;
access;
symbols
	OPENBSD_6_1_BASE:1.19
	OPENBSD_6_0:1.19.0.4
	OPENBSD_6_0_BASE:1.19
	OPENBSD_5_9:1.19.0.2
	OPENBSD_5_9_BASE:1.19
	OPENBSD_5_8:1.17.0.4
	OPENBSD_5_8_BASE:1.17
	OPENBSD_5_7:1.16.0.2
	OPENBSD_5_7_BASE:1.16
	OPENBSD_5_6:1.16.0.4
	OPENBSD_5_6_BASE:1.16
	OPENBSD_5_5:1.15.0.24
	OPENBSD_5_5_BASE:1.15
	OPENBSD_5_4:1.15.0.20
	OPENBSD_5_4_BASE:1.15
	OPENBSD_5_3:1.15.0.18
	OPENBSD_5_3_BASE:1.15
	OPENBSD_5_2:1.15.0.16
	OPENBSD_5_2_BASE:1.15
	OPENBSD_5_1_BASE:1.15
	OPENBSD_5_1:1.15.0.14
	OPENBSD_5_0:1.15.0.12
	OPENBSD_5_0_BASE:1.15
	OPENBSD_4_9:1.15.0.10
	OPENBSD_4_9_BASE:1.15
	OPENBSD_4_8:1.15.0.8
	OPENBSD_4_8_BASE:1.15
	OPENBSD_4_7:1.15.0.4
	OPENBSD_4_7_BASE:1.15
	OPENBSD_4_6:1.15.0.6
	OPENBSD_4_6_BASE:1.15
	OPENBSD_4_5:1.15.0.2
	OPENBSD_4_5_BASE:1.15
	OPENBSD_4_4:1.14.0.10
	OPENBSD_4_4_BASE:1.14
	OPENBSD_4_3:1.14.0.8
	OPENBSD_4_3_BASE:1.14
	OPENBSD_4_2:1.14.0.6
	OPENBSD_4_2_BASE:1.14
	OPENBSD_4_1:1.14.0.4
	OPENBSD_4_1_BASE:1.14
	OPENBSD_4_0:1.14.0.2
	OPENBSD_4_0_BASE:1.14
	OPENBSD_3_9:1.13.0.2
	OPENBSD_3_9_BASE:1.13
	OPENBSD_3_8:1.10.0.2
	OPENBSD_3_8_BASE:1.10
	OPENBSD_3_7:1.8.0.8
	OPENBSD_3_7_BASE:1.8
	OPENBSD_3_6:1.8.0.6
	OPENBSD_3_6_BASE:1.8
	OPENBSD_3_5:1.8.0.4
	OPENBSD_3_5_BASE:1.8
	OPENBSD_3_4:1.8.0.2
	OPENBSD_3_4_BASE:1.8
	OPENBSD_3_3:1.7.0.4
	OPENBSD_3_3_BASE:1.7
	OPENBSD_3_2:1.7.0.2
	OPENBSD_3_2_BASE:1.7
	OPENBSD_3_1:1.6.0.2
	OPENBSD_3_1_BASE:1.6
	OPENBSD_3_0:1.5.0.2
	OPENBSD_3_0_BASE:1.5
	OPENBSD_2_9_BASE:1.4
	OPENBSD_2_9:1.4.0.2
	OPENBSD_2_8:1.3.0.2
	OPENBSD_2_8_BASE:1.3
	OPENBSD_2_7:1.2.0.2
	OPENBSD_2_7_BASE:1.2;
locks; strict;
comment	@ * @;


1.19
date	2015.12.30.20.51.51;	author lum;	state Exp;
branches;
next	1.18;
commitid	gmAQSeOTq02tjNYE;

1.18
date	2015.12.29.19.44.32;	author lum;	state Exp;
branches;
next	1.17;
commitid	zQwbtQmO8Wf9dGsD;

1.17
date	2015.03.19.21.22.15;	author bcallah;	state Exp;
branches;
next	1.16;
commitid	GbEBL4CfPvDkB8hj;

1.16
date	2014.03.20.07.47.29;	author lum;	state Exp;
branches;
next	1.15;

1.15
date	2008.09.15.16.11.35;	author kjell;	state Exp;
branches;
next	1.14;

1.14
date	2006.05.28.23.30.16;	author kjell;	state Exp;
branches;
next	1.13;

1.13
date	2005.11.18.20.56.53;	author deraadt;	state Exp;
branches;
next	1.12;

1.12
date	2005.11.11.18.40.51;	author deraadt;	state Exp;
branches;
next	1.11;

1.11
date	2005.10.17.20.08.48;	author kjell;	state Exp;
branches;
next	1.10;

1.10
date	2005.06.14.18.14.40;	author kjell;	state Exp;
branches;
next	1.9;

1.9
date	2005.04.03.02.09.28;	author db;	state Exp;
branches;
next	1.8;

1.8
date	2003.05.20.03.08.55;	author cloder;	state Exp;
branches;
next	1.7;

1.7
date	2002.05.29.12.44.59;	author vincent;	state Exp;
branches;
next	1.6;

1.6
date	2002.02.21.15.27.29;	author deraadt;	state Exp;
branches;
next	1.5;

1.5
date	2001.05.24.03.05.28;	author mickey;	state Exp;
branches;
next	1.4;

1.4
date	2001.01.29.01.58.10;	author niklas;	state Exp;
branches;
next	1.3;

1.3
date	2000.09.01.14.59.09;	author millert;	state Exp;
branches;
next	1.2;

1.2
date	2000.04.13.06.12.18;	author millert;	state Exp;
branches;
next	1.1;

1.1
date	2000.02.25.19.08.52;	author deraadt;	state Exp;
branches;
next	;


desc
@@


1.19
log
@Small tidy of recently committed transpose-words: unused value
assignment and I missed an ABORT case.
@
text
@/*	$OpenBSD: word.c,v 1.18 2015/12/29 19:44:32 lum Exp $	*/

/* This file is in the public domain. */

/*
 *		Word mode commands.
 * The routines in this file implement commands that work word at a time.
 * There are all sorts of word mode commands.
 */

#include <sys/queue.h>
#include <signal.h>
#include <errno.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#include "def.h"

RSIZE	countfword(void);
int	grabword(char **);

/*
 * Move the cursor backward by "n" words. All of the details of motion are
 * performed by the "backchar" and "forwchar" routines.
 */
/* ARGSUSED */
int
backword(int f, int n)
{
	if (n < 0)
		return (forwword(f | FFRAND, -n));
	if (backchar(FFRAND, 1) == FALSE)
		return (FALSE);
	while (n--) {
		while (inword() == FALSE) {
			if (backchar(FFRAND, 1) == FALSE)
				return (TRUE);
		}
		while (inword() != FALSE) {
			if (backchar(FFRAND, 1) == FALSE)
				return (TRUE);
		}
	}
	return (forwchar(FFRAND, 1));
}

/*
 * Move the cursor forward by the specified number of words.  All of the
 * motion is done by "forwchar".
 */
/* ARGSUSED */
int
forwword(int f, int n)
{
	if (n < 0)
		return (backword(f | FFRAND, -n));
	while (n--) {
		while (inword() == FALSE) {
			if (forwchar(FFRAND, 1) == FALSE)
				return (TRUE);
		}
		while (inword() != FALSE) {
			if (forwchar(FFRAND, 1) == FALSE)
				return (TRUE);
		}
	}
	return (TRUE);
}

/*
 * Transpose 2 words. 
 * The function below is artifically restricted to only a maximum of 1 iteration
 * at the moment because the 'undo' functionality within mg needs amended for
 * multiple movements of point, backwards and forwards.
 */
int
transposeword(int f, int n)
{
	struct line	*tmp1_w_dotp = NULL;
	struct line	*tmp2_w_dotp = NULL;
	int		 tmp2_w_doto = 0;
	int		 tmp1_w_dotline = 0;
	int		 tmp2_w_dotline = 0;
	int		 tmp1_w_doto;
	int		 i;		/* start-of-line space counter */
	int		 ret, s;
	int		 newline;
	int		 leave = 0;
	int		 tmp_len;
	char		*word1 = NULL;
	char		*word2 = NULL;
	char		*chr;

	if (n == 0)
		return (TRUE);

	n = 1; /* remove this line to allow muliple-iterations */

	if ((s = checkdirty(curbp)) != TRUE)
		return (s);
	if (curbp->b_flag & BFREADONLY) {
		dobeep();
		ewprintf("Buffer is read-only");
		return (FALSE);
	}
	undo_boundary_enable(FFRAND, 0);

	/* go backwards to find the start of a word to transpose. */
	(void)backword(FFRAND, 1);
	ret = grabword(&word1);
	if (ret == ABORT) {
		ewprintf("No word to the left to tranpose.");
		return (FALSE);
	}
	if (ret < 0) {
		dobeep();
		ewprintf("Error copying word: %s", strerror(ret));
		free(word1);
		return (FALSE);
	}

	while (n-- > 0) {
		i = 0;
		newline = 0;

		tmp1_w_doto = curwp->w_doto;
		tmp1_w_dotline = curwp->w_dotline;
		tmp1_w_dotp = curwp->w_dotp;

		/* go forward and find next word. */
		while (inword() == FALSE) {
			if (forwchar(FFRAND, 1) == FALSE) {
				leave = 1;
				if (tmp1_w_dotline < curwp->w_dotline)
					curwp->w_dotline--;
				ewprintf("Don't have two things to transpose");
				break;
			}
			if (curwp->w_doto == 0) {
				newline = 1;
				i = 0;
			} else if (newline)
				i++;
		}
		if (leave) {
			tmp2_w_doto = tmp1_w_doto;
			tmp2_w_dotline = tmp1_w_dotline;
			tmp2_w_dotp = tmp1_w_dotp;
			break;
		}
		tmp2_w_doto = curwp->w_doto;
		tmp2_w_dotline = curwp->w_dotline;
		tmp2_w_dotp = curwp->w_dotp;

		ret = grabword(&word2);
		if (ret < 0 || ret == ABORT) {
			dobeep();
			ewprintf("Error copying word: %s", strerror(ret));
			free(word1);
			return (FALSE);
		}
		tmp_len = strlen(word2);
		tmp2_w_doto += tmp_len;

		curwp->w_doto = tmp1_w_doto;
		curwp->w_dotline = tmp1_w_dotline;
		curwp->w_dotp = tmp1_w_dotp;

		/* insert shuffled along word */
		for (chr = word2; *chr != '\0'; ++chr)
			linsert(1, *chr);

		if (newline)
			tmp2_w_doto = i;

		curwp->w_doto = tmp2_w_doto;
		curwp->w_dotline = tmp2_w_dotline;
		curwp->w_dotp = tmp2_w_dotp;

		word2 = NULL;
	}
	curwp->w_doto = tmp2_w_doto;
	curwp->w_dotline = tmp2_w_dotline;
	curwp->w_dotp = tmp2_w_dotp;

	/* insert very first word in its new position */
	for (chr = word1; *chr != '\0'; ++chr)
		linsert(1, *chr);

	if (leave)
		(void)backword(FFRAND, 1);

	free(word1);
	free(word2);

	undo_boundary_enable(FFRAND, 1);

	return (TRUE);
}

/*
 * copy and delete word.
*/
int
grabword(char **word)
{
	int c;

	while (inword() == TRUE) {
		c = lgetc(curwp->w_dotp, curwp->w_doto);
		if (*word == NULL) {
			if (asprintf(word, "%c", c) == -1)
				return (errno);
		} else {
			if (asprintf(word, "%s%c", *word, c) == -1)
				return (errno);
		}
		(void)forwdel(FFRAND, 1);
	}
	if (*word == NULL)
		return (ABORT);
	return (TRUE);
}

/*
 * Move the cursor forward by the specified number of words.  As you move,
 * convert any characters to upper case.
 */
/* ARGSUSED */
int
upperword(int f, int n)
{
	int	c, s;
	RSIZE	size;

	if ((s = checkdirty(curbp)) != TRUE)
		return (s);
	if (curbp->b_flag & BFREADONLY) {
		dobeep();
		ewprintf("Buffer is read-only");
		return (FALSE);
	}

	if (n < 0)
		return (FALSE);
	while (n--) {
		while (inword() == FALSE) {
			if (forwchar(FFRAND, 1) == FALSE)
				return (TRUE);
		}
		size = countfword();
		undo_add_change(curwp->w_dotp, curwp->w_doto, size);

		while (inword() != FALSE) {
			c = lgetc(curwp->w_dotp, curwp->w_doto);
			if (ISLOWER(c) != FALSE) {
				c = TOUPPER(c);
				lputc(curwp->w_dotp, curwp->w_doto, c);
				lchange(WFFULL);
			}
			if (forwchar(FFRAND, 1) == FALSE)
				return (TRUE);
		}
	}
	return (TRUE);
}

/*
 * Move the cursor forward by the specified number of words.  As you move
 * convert characters to lower case.
 */
/* ARGSUSED */
int
lowerword(int f, int n)
{
	int	c, s;
	RSIZE	size;

	if ((s = checkdirty(curbp)) != TRUE)
		return (s);
	if (curbp->b_flag & BFREADONLY) {
		dobeep();
		ewprintf("Buffer is read-only");
		return (FALSE);
	}
	if (n < 0)
		return (FALSE);
	while (n--) {
		while (inword() == FALSE) {
			if (forwchar(FFRAND, 1) == FALSE)
				return (TRUE);
		}
		size = countfword();
		undo_add_change(curwp->w_dotp, curwp->w_doto, size);

		while (inword() != FALSE) {
			c = lgetc(curwp->w_dotp, curwp->w_doto);
			if (ISUPPER(c) != FALSE) {
				c = TOLOWER(c);
				lputc(curwp->w_dotp, curwp->w_doto, c);
				lchange(WFFULL);
			}
			if (forwchar(FFRAND, 1) == FALSE)
				return (TRUE);
		}
	}
	return (TRUE);
}

/*
 * Move the cursor forward by the specified number of words.  As you move
 * convert the first character of the word to upper case, and subsequent
 * characters to lower case.  Error if you try to move past the end of the
 * buffer.
 */
/* ARGSUSED */
int
capword(int f, int n)
{
	int	c, s;
	RSIZE	size;

	if ((s = checkdirty(curbp)) != TRUE)
		return (s);
	if (curbp->b_flag & BFREADONLY) {
		dobeep();
		ewprintf("Buffer is read-only");
		return (FALSE);
	}

	if (n < 0)
		return (FALSE);
	while (n--) {
		while (inword() == FALSE) {
			if (forwchar(FFRAND, 1) == FALSE)
				return (TRUE);
		}
		size = countfword();
		undo_add_change(curwp->w_dotp, curwp->w_doto, size);

		if (inword() != FALSE) {
			c = lgetc(curwp->w_dotp, curwp->w_doto);
			if (ISLOWER(c) != FALSE) {
				c = TOUPPER(c);
				lputc(curwp->w_dotp, curwp->w_doto, c);
				lchange(WFFULL);
			}
			if (forwchar(FFRAND, 1) == FALSE)
				return (TRUE);
			while (inword() != FALSE) {
				c = lgetc(curwp->w_dotp, curwp->w_doto);
				if (ISUPPER(c) != FALSE) {
					c = TOLOWER(c);
					lputc(curwp->w_dotp, curwp->w_doto, c);
					lchange(WFFULL);
				}
				if (forwchar(FFRAND, 1) == FALSE)
					return (TRUE);
			}
		}
	}
	return (TRUE);
}

/*
 * Count characters in word, from current position
 */
RSIZE
countfword()
{
	RSIZE		 size;
	struct line	*dotp;
	int		 doto;

	dotp = curwp->w_dotp;
	doto = curwp->w_doto;
	size = 0;

	while (inword() != FALSE) {
		if (forwchar(FFRAND, 1) == FALSE)
			/* hit the end of the buffer */
			goto out;
		++size;
	}
out:
	curwp->w_dotp = dotp;
	curwp->w_doto = doto;
	return (size);
}


/*
 * Kill forward by "n" words.
 */
/* ARGSUSED */
int
delfword(int f, int n)
{
	RSIZE		 size;
	struct line	*dotp;
	int		 doto;
	int s;

	if ((s = checkdirty(curbp)) != TRUE)
		return (s);
	if (curbp->b_flag & BFREADONLY) {
		dobeep();
		ewprintf("Buffer is read-only");
		return (FALSE);
	}
	if (n < 0)
		return (FALSE);

	/* purge kill buffer */
	if ((lastflag & CFKILL) == 0)
		kdelete();

	thisflag |= CFKILL;
	dotp = curwp->w_dotp;
	doto = curwp->w_doto;
	size = 0;

	while (n--) {
		while (inword() == FALSE) {
			if (forwchar(FFRAND, 1) == FALSE)
				/* hit the end of the buffer */
				goto out;
			++size;
		}
		while (inword() != FALSE) {
			if (forwchar(FFRAND, 1) == FALSE)
				/* hit the end of the buffer */
				goto out;
			++size;
		}
	}
out:
	curwp->w_dotp = dotp;
	curwp->w_doto = doto;
	return (ldelete(size, KFORW));
}

/*
 * Kill backwards by "n" words.  The rules for success and failure are now
 * different, to prevent strange behavior at the start of the buffer.  The
 * command only fails if something goes wrong with the actual delete of the
 * characters.  It is successful even if no characters are deleted, or if you
 * say delete 5 words, and there are only 4 words left.  I considered making
 * the first call to "backchar" special, but decided that that would just be
 * weird. Normally this is bound to "M-Rubout" and to "M-Backspace".
 */
/* ARGSUSED */
int
delbword(int f, int n)
{
	RSIZE	size;
	int s;

	if ((s = checkdirty(curbp)) != TRUE)
		return (s);
	if (curbp->b_flag & BFREADONLY) {
		dobeep();
		ewprintf("Buffer is read-only");
		return (FALSE);
	}

	if (n < 0)
		return (FALSE);

	/* purge kill buffer */
	if ((lastflag & CFKILL) == 0)
		kdelete();
	thisflag |= CFKILL;
	if (backchar(FFRAND, 1) == FALSE)
		/* hit buffer start */
		return (TRUE);

	/* one deleted */
	size = 1;
	while (n--) {
		while (inword() == FALSE) {
			if (backchar(FFRAND, 1) == FALSE)
				/* hit buffer start */
				goto out;
			++size;
		}
		while (inword() != FALSE) {
			if (backchar(FFRAND, 1) == FALSE)
				/* hit buffer start */
				goto out;
			++size;
		}
	}
	if (forwchar(FFRAND, 1) == FALSE)
		return (FALSE);

	/* undo assumed delete */
	--size;
out:
	return (ldelete(size, KBACK));
}

/*
 * Return TRUE if the character at dot is a character that is considered to be
 * part of a word. The word character list is hard coded. Should be settable.
 */
int
inword(void)
{
	/* can't use lgetc in ISWORD due to bug in OSK cpp */
	return (curwp->w_doto != llength(curwp->w_dotp) &&
	    ISWORD(curwp->w_dotp->l_text[curwp->w_doto]));
}
@


1.18
log
@Add transpose-words, ok jasper@@.
Limited to one iteration until 'undo' is looked into.
@
text
@d1 1
a1 1
/*	$OpenBSD: word.c,v 1.17 2015/03/19 21:22:15 bcallah Exp $	*/
a121 1
	tmp_len = strlen(word1);
d157 1
a157 1
		if (ret < 0) {
@


1.17
log
@Clean up the includes in mg.
This does the following:
Moves all POSIX headers from sysdef.h into the individual .c files so that
each file now only includes what it needs. All headers are properly sorted.
Moves the remainder of sysdef.h to other files (mostly def.h) and deletes
sysdef.h now that it's no longer contains anything.
Tweak a comment that references sysdef.h so that it no longer does that.
ok florian@@
@
text
@d1 1
a1 1
/*	$OpenBSD: word.c,v 1.16 2014/03/20 07:47:29 lum Exp $	*/
d13 1
d15 2
d21 1
d68 156
@


1.16
log
@Add some missing dobeeps.
ok florian@@
@
text
@d1 1
a1 1
/*	$OpenBSD: word.c,v 1.15 2008/09/15 16:11:35 kjell Exp $	*/
d10 4
@


1.15
log
@Enable dirty buffer detection in mg.
Emulate the emacs behavior: after suspend/resume, buffer switch,
or at save time, warn (prompt) the user if the file has been modified
on disk in the interim.
This has already saved my butt numerous times.
ok phessler
@
text
@d1 1
a1 1
/*	$OpenBSD: word.c,v 1.14 2006/05/28 23:30:16 kjell Exp $	*/
d77 1
d120 1
d164 1
d245 1
d300 1
@


1.14
log
@Make Window Flags more mnemonic (and less dumb); i.e.
WFHARD -> WFFULL (Redraw full window)
WFFORCE -> WFFRAME (Reframe window).
No binary change
@
text
@d1 1
a1 1
/*	$OpenBSD: word.c,v 1.13 2005/11/18 20:56:53 deraadt Exp $	*/
d71 1
a71 1
	int	c;
d74 2
d113 1
a113 1
	int	c;
d116 2
d156 1
a156 1
	int	c;
d159 2
d237 1
d239 2
d291 1
d293 2
@


1.13
log
@greedy use of typedef struct was making code harder to read; ok kjell cloder
@
text
@d1 1
a1 1
/*	$OpenBSD: word.c,v 1.12 2005/11/11 18:40:51 deraadt Exp $	*/
d94 1
a94 1
				lchange(WFHARD);
d133 1
a133 1
				lchange(WFHARD);
d175 1
a175 1
				lchange(WFHARD);
d184 1
a184 1
					lchange(WFHARD);
@


1.12
log
@spacing
@
text
@d1 1
a1 1
/*	$OpenBSD: word.c,v 1.11 2005/10/17 20:08:48 kjell Exp $	*/
d200 3
a202 3
	RSIZE	 size;
	LINE	*dotp;
	int	 doto;
d228 3
a230 3
	RSIZE	 size;
	LINE	*dotp;
	int	 doto;
@


1.11
log
@make undo of word-based capitalization functions work
ok beck@@
@
text
@d1 1
a1 1
/*	$OpenBSD: word.c,v 1.10 2005/06/14 18:14:40 kjell Exp $	*/
d88 1
a88 1
		
@


1.10
log
@Add explicit public domain notices to all public domain files.
ok millert@@, deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: word.c,v 1.9 2005/04/03 02:09:28 db Exp $	*/
d13 2
d72 1
d86 3
d112 1
d125 3
d153 1
d167 3
d193 27
@


1.9
log
@This is a no binary change which does:

- spelling, punctuation fixes
- variable declaration lineup
- use parentheses for return and sizeof
- K&R function declarations -> ANSI
- other minor code beautification

ok henning@@
@
text
@d1 3
a3 1
/*	$OpenBSD: word.c,v 1.8 2003/05/20 03:08:55 cloder Exp $	*/
@


1.8
log
@Finish KNF of prototypes.  That should be all of them.
OK vincent@@
@
text
@d1 1
a1 1
/*	$OpenBSD: word.c,v 1.7 2002/05/29 12:44:59 vincent Exp $	*/
d20 1
a20 1
		return forwword(f | FFRAND, -n);
d22 1
a22 1
		return FALSE;
d26 1
a26 1
				return TRUE;
d30 1
a30 1
				return TRUE;
d33 1
a33 1
	return forwchar(FFRAND, 1);
d45 1
a45 1
		return backword(f | FFRAND, -n);
d49 1
a49 1
				return TRUE;
d53 1
a53 1
				return TRUE;
d56 1
a56 1
	return TRUE;
d75 1
a75 1
		return FALSE;
d79 1
a79 1
				return TRUE;
d89 1
a89 1
				return TRUE;
d92 1
a92 1
	return TRUE;
d110 1
a110 1
		return FALSE;
d114 1
a114 1
				return TRUE;
d124 1
a124 1
				return TRUE;
d127 1
a127 1
	return TRUE;
d148 1
a148 1
		return FALSE;
d152 1
a152 1
				return TRUE;
d162 1
a162 1
				return TRUE;
d171 1
a171 1
					return TRUE;
d175 1
a175 1
	return TRUE;
d194 1
a194 1
		return FALSE;
d246 1
a246 1
		return FALSE;
d273 1
a273 1
		return FALSE;
d278 1
a278 1
	return ldelete(size, KBACK);
d283 1
a283 1
 * part of a word. The word character list is hard coded. Should be setable.
d289 2
a290 2
	return curwp->w_doto != llength(curwp->w_dotp) &&
	    ISWORD(curwp->w_dotp->l_text[curwp->w_doto]);
@


1.7
log
@Add a few missing tests for BFREADONLY.

ok art@@
@
text
@d1 1
a1 1
/*	$OpenBSD: word.c,v 1.6 2002/02/21 15:27:29 deraadt Exp $	*/
d17 1
a17 2
backword(f, n)
	int f, n;
d42 1
a42 2
forwword(f, n)
	int f, n;
d65 1
a65 2
upperword(f, n)
	int f, n;
d101 1
a101 2
lowerword(f, n)
	int f, n;
d138 1
a138 2
capword(f, n)
	int f, n;
d183 1
a183 2
delfword(f, n)
	int f, n;
d236 1
a236 2
delbword(f, n)
	int f, n;
d286 1
a286 1
inword()
@


1.6
log
@KNF
@
text
@d1 1
a1 1
/*	$OpenBSD: word.c,v 1.5 2001/05/24 03:05:28 mickey Exp $	*/
d72 5
d109 4
d147 5
d195 4
d246 5
@


1.5
log
@spaces
@
text
@d1 1
a1 1
/*	$OpenBSD: word.c,v 1.4 2001/01/29 01:58:10 niklas Exp $	*/
d274 1
a274 1
		ISWORD(curwp->w_dotp->l_text[curwp->w_doto]);
@


1.4
log
@$OpenBSD$
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d5 1
a5 1
 * The routines in this file implement commands that work word at a time. 
d12 1
a12 1
 * Move the cursor backward by "n" words. All of the details of motion are 
d127 2
a128 2
 * convert the first character of the word to upper case, and subsequent 
 * characters to lower case.  Error if you try to move past the end of the 
d214 6
a219 6
 * Kill backwards by "n" words.  The rules for success and failure are now 
 * different, to prevent strange behavior at the start of the buffer.  The 
 * command only fails if something goes wrong with the actual delete of the 
 * characters.  It is successful even if no characters are deleted, or if you 
 * say delete 5 words, and there are only 4 words left.  I considered making 
 * the first call to "backchar" special, but decided that that would just be 
@


1.3
log
@More -Wall anmd KNF, from op2@@tomahawk.SQUiSH.org
@
text
@d1 2
@


1.2
log
@The start of KNF + -Wall.  The code has been run through indent but
needs hand fixup.  I stopped at keymap.c...
@
text
@d3 5
a7 6
 * The routines in this file
 * implement commands that work word at
 * a time. There are all sorts of word mode
 * commands.
 */
#include	"def.h"
d10 2
a11 4
 * Move the cursor backward by
 * "n" words. All of the details of motion
 * are performed by the "backchar" and "forwchar"
 * routines.
d14 1
d16 1
d36 1
a36 2
 * Move the cursor forward by
 * the specified number of words. All of the
d40 1
d42 1
d60 1
a60 2
 * Move the cursor forward by
 * the specified number of words. As you move,
d64 1
d66 1
d68 1
a68 1
	register int    c;
d92 1
a92 2
 * Move the cursor forward by
 * the specified number of words. As you move
d96 1
d98 1
d100 1
a100 1
	register int    c;
d124 4
a127 5
 * Move the cursor forward by
 * the specified number of words. As you move
 * convert the first character of the word to upper
 * case, and subsequent characters to lower case. Error
 * if you try and move past the end of the buffer.
d130 1
d132 1
d134 1
a134 2
	register int    c;
	VOID            lchange();
d171 1
d173 1
d175 3
a177 3
	register RSIZE  size;
	register LINE  *dotp;
	register int    doto;
d181 3
a183 1
	if ((lastflag & CFKILL) == 0)	/* Purge kill buffer.	 */
d185 1
d190 1
d194 2
a195 1
				goto out;	/* Hit end of buffer.	 */
d200 2
a201 1
				goto out;	/* Hit end of buffer.	 */
d212 7
a218 10
 * Kill backwards by "n" words. The rules
 * for success and failure are now different, to prevent
 * strange behavior at the start of the buffer. The command
 * only fails if something goes wrong with the actual delete
 * of the characters. It is successful even if no characters
 * are deleted, or if you say delete 5 words, and there are
 * only 4 words left. I considered making the first call
 * to "backchar" special, but decided that that would just
 * be wierd. Normally this is bound to "M-Rubout" and
 * to "M-Backspace".
d221 1
d223 1
d225 1
a225 2
	register RSIZE  size;
	VOID            kdelete();
d229 3
a231 1
	if ((lastflag & CFKILL) == 0)	/* Purge kill buffer.	 */
d235 5
a239 2
		return (TRUE);	/* Hit buffer start.	 */
	size = 1;		/* One deleted.		 */
d243 2
a244 1
				goto out;	/* Hit buffer start.	 */
d249 2
a250 1
				goto out;	/* Hit buffer start.	 */
d256 3
a258 1
	--size;			/* Undo assumed delete. */
d264 2
a265 4
 * Return TRUE if the character at dot
 * is a character that is considered to be
 * part of a word. The word character list is hard
 * coded. Should be setable.
d267 1
@


1.1
log
@initial import of mg2a
@
text
@d16 1
a16 1
/*ARGSUSED*/
d19 2
a20 1
	if (n < 0) return forwword(f | FFRAND, -n);
d41 1
a41 1
/*ARGSUSED*/
d64 1
a64 1
/*ARGSUSED*/
d67 1
a67 1
	register int	c;
d69 2
a70 1
	if (n < 0) return FALSE;
d95 1
a95 1
/*ARGSUSED*/
d98 1
a98 1
	register int	c;
d100 2
a101 1
	if (n < 0) return FALSE;
d128 1
a128 1
/*ARGSUSED*/
d131 2
a132 2
	register int	c;
	VOID		lchange();
d134 2
a135 1
	if (n < 0) return FALSE;
d168 1
a168 1
/*ARGSUSED*/
d171 3
a173 3
	register RSIZE	size;
	register LINE	*dotp;
	register int	doto;
d177 1
a177 1
	if ((lastflag&CFKILL) == 0)		/* Purge kill buffer.	*/
d186 1
a186 1
				goto out;	/* Hit end of buffer.	*/
d191 1
a191 1
				goto out;	/* Hit end of buffer.	*/
d213 1
a213 1
/*ARGSUSED*/
d216 2
a217 2
	register RSIZE	size;
	VOID		kdelete();
d219 3
a221 2
	if (n < 0) return FALSE;
	if ((lastflag&CFKILL) == 0)		/* Purge kill buffer.	*/
d225 2
a226 2
		return (TRUE);			/* Hit buffer start.	*/
	size = 1;				/* One deleted.		*/
d230 1
a230 1
				goto out;	/* Hit buffer start.	*/
d235 1
a235 1
				goto out;	/* Hit buffer start.	*/
d241 1
a241 1
	--size;					/* Undo assumed delete. */
d252 4
a255 3
inword() {
/* can't use lgetc in ISWORD due to bug in OSK cpp */
	return curwp->w_doto != llength(curwp->w_dotp) && 
a257 1

@

