head	1.21;
access;
symbols
	OPENBSD_6_2:1.21.0.2
	OPENBSD_6_2_BASE:1.21
	OPENBSD_6_1:1.20.0.10
	OPENBSD_6_1_BASE:1.20
	OPENBSD_6_0:1.20.0.6
	OPENBSD_6_0_BASE:1.20
	OPENBSD_5_9:1.20.0.2
	OPENBSD_5_9_BASE:1.20
	OPENBSD_5_8:1.20.0.4
	OPENBSD_5_8_BASE:1.20
	OPENBSD_5_7:1.19.0.2
	OPENBSD_5_7_BASE:1.19
	OPENBSD_5_6:1.19.0.4
	OPENBSD_5_6_BASE:1.19
	OPENBSD_5_5:1.18.0.26
	OPENBSD_5_5_BASE:1.18
	OPENBSD_5_4:1.18.0.22
	OPENBSD_5_4_BASE:1.18
	OPENBSD_5_3:1.18.0.20
	OPENBSD_5_3_BASE:1.18
	OPENBSD_5_2:1.18.0.18
	OPENBSD_5_2_BASE:1.18
	OPENBSD_5_1_BASE:1.18
	OPENBSD_5_1:1.18.0.16
	OPENBSD_5_0:1.18.0.14
	OPENBSD_5_0_BASE:1.18
	OPENBSD_4_9:1.18.0.12
	OPENBSD_4_9_BASE:1.18
	OPENBSD_4_8:1.18.0.10
	OPENBSD_4_8_BASE:1.18
	OPENBSD_4_7:1.18.0.6
	OPENBSD_4_7_BASE:1.18
	OPENBSD_4_6:1.18.0.8
	OPENBSD_4_6_BASE:1.18
	OPENBSD_4_5:1.18.0.4
	OPENBSD_4_5_BASE:1.18
	OPENBSD_4_4:1.18.0.2
	OPENBSD_4_4_BASE:1.18
	OPENBSD_4_3:1.16.0.10
	OPENBSD_4_3_BASE:1.16
	OPENBSD_4_2:1.16.0.8
	OPENBSD_4_2_BASE:1.16
	OPENBSD_4_1:1.16.0.6
	OPENBSD_4_1_BASE:1.16
	OPENBSD_4_0:1.16.0.4
	OPENBSD_4_0_BASE:1.16
	OPENBSD_3_9:1.16.0.2
	OPENBSD_3_9_BASE:1.16
	OPENBSD_3_8:1.12.0.2
	OPENBSD_3_8_BASE:1.12
	OPENBSD_3_7:1.9.0.4
	OPENBSD_3_7_BASE:1.9
	OPENBSD_3_6:1.9.0.2
	OPENBSD_3_6_BASE:1.9
	OPENBSD_3_5:1.8.0.8
	OPENBSD_3_5_BASE:1.8
	OPENBSD_3_4:1.8.0.6
	OPENBSD_3_4_BASE:1.8
	OPENBSD_3_3:1.8.0.4
	OPENBSD_3_3_BASE:1.8
	OPENBSD_3_2:1.8.0.2
	OPENBSD_3_2_BASE:1.8
	OPENBSD_3_1:1.7.0.2
	OPENBSD_3_1_BASE:1.7
	OPENBSD_3_0:1.6.0.2
	OPENBSD_3_0_BASE:1.6
	OPENBSD_2_9_BASE:1.4
	OPENBSD_2_9:1.4.0.2
	OPENBSD_2_8:1.3.0.2
	OPENBSD_2_8_BASE:1.3
	OPENBSD_2_7:1.2.0.2
	OPENBSD_2_7_BASE:1.2;
locks; strict;
comment	@ * @;


1.21
date	2017.05.30.07.05.22;	author florian;	state Exp;
branches;
next	1.20;
commitid	L2GD0imd4EtMY0Yn;

1.20
date	2015.03.19.21.22.15;	author bcallah;	state Exp;
branches;
next	1.19;
commitid	GbEBL4CfPvDkB8hj;

1.19
date	2014.03.20.07.47.29;	author lum;	state Exp;
branches;
next	1.18;

1.18
date	2008.06.14.08.46.30;	author kjell;	state Exp;
branches;
next	1.17;

1.17
date	2008.06.11.23.23.55;	author kjell;	state Exp;
branches;
next	1.16;

1.16
date	2005.12.13.07.20.13;	author kjell;	state Exp;
branches;
next	1.15;

1.15
date	2005.12.13.06.01.27;	author kjell;	state Exp;
branches;
next	1.14;

1.14
date	2005.11.22.04.23.14;	author kjell;	state Exp;
branches;
next	1.13;

1.13
date	2005.11.18.20.56.53;	author deraadt;	state Exp;
branches;
next	1.12;

1.12
date	2005.08.09.00.53.48;	author kjell;	state Exp;
branches;
next	1.11;

1.11
date	2005.06.14.18.14.40;	author kjell;	state Exp;
branches;
next	1.10;

1.10
date	2005.04.03.02.09.28;	author db;	state Exp;
branches;
next	1.9;

1.9
date	2004.07.22.01.25.25;	author vincent;	state Exp;
branches;
next	1.8;

1.8
date	2002.07.01.14.33.44;	author vincent;	state Exp;
branches;
next	1.7;

1.7
date	2002.02.16.21.27.49;	author millert;	state Exp;
branches;
next	1.6;

1.6
date	2001.05.24.10.43.21;	author art;	state Exp;
branches;
next	1.5;

1.5
date	2001.05.24.03.05.25;	author mickey;	state Exp;
branches;
next	1.4;

1.4
date	2001.01.29.01.58.09;	author niklas;	state Exp;
branches;
next	1.3;

1.3
date	2000.09.01.14.59.09;	author millert;	state Exp;
branches;
next	1.2;

1.2
date	2000.04.13.06.12.16;	author millert;	state Exp;
branches;
next	1.1;

1.1
date	2000.02.25.19.08.50;	author deraadt;	state Exp;
branches;
next	;


desc
@@


1.21
log
@fix -Wshadow warnings.
Found by bcallah, thanks!
@
text
@/*	$OpenBSD: modes.c,v 1.20 2015/03/19 21:22:15 bcallah Exp $	*/

/* This file is in the public domain. */

/*
 * Commands to toggle modes.   Without an argument, these functions will
 * toggle the given mode.  A negative or zero argument will turn the mode
 * off.  A positive argument will turn the mode on.
 */

#include <sys/queue.h>
#include <signal.h>
#include <stdio.h>
#include <string.h>

#include "def.h"
#include "kbd.h"

int	changemode(int, int, char *);

int	 defb_nmodes = 0;
struct maps_s	*defb_modes[PBMODES] = { &fundamental_mode };
int	 defb_flag = 0;

int
changemode(int f, int n, char *newmode)
{
	int	 i;
	struct maps_s	*m;

	if ((m = name_mode(newmode)) == NULL) {
		dobeep();
		ewprintf("Can't find mode %s", newmode);
		return (FALSE);
	}
	if (!(f & FFARG)) {
		for (i = 0; i <= curbp->b_nmodes; i++)
			if (curbp->b_modes[i] == m) {
				/* mode already set */
				n = 0;
				break;
			}
	}
	if (n > 0) {
		for (i = 0; i <= curbp->b_nmodes; i++)
			if (curbp->b_modes[i] == m)
				/* mode already set */
				return (TRUE);
		if (curbp->b_nmodes >= PBMODES - 1) {
			dobeep();
			ewprintf("Too many modes");
			return (FALSE);
		}
		curbp->b_modes[++(curbp->b_nmodes)] = m;
	} else {
		/* fundamental is b_modes[0] and can't be unset */
		for (i = 1; i <= curbp->b_nmodes && m != curbp->b_modes[i];
		    i++);
		if (i > curbp->b_nmodes)
			return (TRUE);	/* mode wasn't set */
		for (; i < curbp->b_nmodes; i++)
			curbp->b_modes[i] = curbp->b_modes[i + 1];
		curbp->b_nmodes--;
	}
	upmodes(curbp);
	return (TRUE);
}

int
indentmode(int f, int n)
{
	return (changemode(f, n, "indent"));
}

int
fillmode(int f, int n)
{
	return (changemode(f, n, "fill"));
}

#ifdef NOTAB
int
notabmode(int f, int n)
{
	if (changemode(f, n, "notab") == FALSE)
		return (FALSE);
	if (f & FFARG) {
		if (n <= 0)
			curbp->b_flag &= ~BFNOTAB;
		else
			curbp->b_flag |= BFNOTAB;
	} else
		curbp->b_flag ^= BFNOTAB;
	return (TRUE);
}
#endif	/* NOTAB */

int
overwrite_mode(int f, int n)
{
	if (changemode(f, n, "overwrite") == FALSE)
		return (FALSE);
	if (f & FFARG) {
		if (n <= 0)
			curbp->b_flag &= ~BFOVERWRITE;
		else
			curbp->b_flag |= BFOVERWRITE;
	} else
		curbp->b_flag ^= BFOVERWRITE;
	return (TRUE);
}

int
set_default_mode(int f, int n)
{
	int	 i;
	struct maps_s	*m;
	char	 modebuf[32], *bufp;

	if ((bufp = eread("Set Default Mode: ", modebuf, sizeof(modebuf),
	    EFNEW)) == NULL)
		return (ABORT);
	else if (bufp[0] == '\0')
		return (FALSE);
	if ((m = name_mode(modebuf)) == NULL) {
		dobeep();
		ewprintf("can't find mode %s", modebuf);
		return (FALSE);
	}
	if (!(f & FFARG)) {
		for (i = 0; i <= defb_nmodes; i++)
			if (defb_modes[i] == m) {
				/* mode already set */
				n = 0;
				break;
			}
	}
	if (n > 0) {
		for (i = 0; i <= defb_nmodes; i++)
			if (defb_modes[i] == m)
				/* mode already set */
				return (TRUE);
		if (defb_nmodes >= PBMODES - 1) {
			dobeep();
			ewprintf("Too many modes");
			return (FALSE);
		}
		defb_modes[++defb_nmodes] = m;
	} else {
		/* fundamental is defb_modes[0] and can't be unset */
		for (i = 1; i <= defb_nmodes && m != defb_modes[i]; i++);
		if (i > defb_nmodes)
			/* mode was not set */
			return (TRUE);
		for (; i < defb_nmodes; i++)
			defb_modes[i] = defb_modes[i + 1];
		defb_nmodes--;
	}
	if (strcmp(modebuf, "overwrite") == 0) {
		if (n <= 0)
			defb_flag &= ~BFOVERWRITE;
		else
			defb_flag |= BFOVERWRITE;
	}
#ifdef NOTAB
	if (strcmp(modebuf, "notab") == 0) {
		if (n <= 0)
			defb_flag &= ~BFNOTAB;
		else
			defb_flag |= BFNOTAB;
	}
#endif	/* NOTAB */
	return (TRUE);
}
@


1.20
log
@Clean up the includes in mg.
This does the following:
Moves all POSIX headers from sysdef.h into the individual .c files so that
each file now only includes what it needs. All headers are properly sorted.
Moves the remainder of sysdef.h to other files (mostly def.h) and deletes
sysdef.h now that it's no longer contains anything.
Tweak a comment that references sysdef.h so that it no longer does that.
ok florian@@
@
text
@d1 1
a1 1
/*	$OpenBSD: modes.c,v 1.19 2014/03/20 07:47:29 lum Exp $	*/
d26 1
a26 1
changemode(int f, int n, char *mode)
d31 1
a31 1
	if ((m = name_mode(mode)) == NULL) {
d33 1
a33 1
		ewprintf("Can't find mode %s", mode);
@


1.19
log
@Add some missing dobeeps.
ok florian@@
@
text
@d1 1
a1 1
/*	$OpenBSD: modes.c,v 1.18 2008/06/14 08:46:30 kjell Exp $	*/
d10 5
@


1.18
log
@We do not need a whole MODE for blinking one character.

both emacsen automatically blink, so mg should too. This can be
overridden in your ~/.mg by adding, e.g.

global-set-key ")" self-insert-command

So, I've eliminated blink mode, and renamed "blink-matching-paren-hack"
to "blink-and-insert". It's not just for parens anyway.

While I'm here, set up an empty (rescan) target for backtab, so I can
bind something convenient to it; e.g.

global-set-key "\e[Z" backward-char

Finally, remove all references to Scribd.
Theo doesn't hate this, though I would hesitate to call it an ok.
@
text
@d1 1
a1 1
/*	$OpenBSD: modes.c,v 1.17 2008/06/11 23:23:55 kjell Exp $	*/
d27 1
d45 1
d121 1
d139 1
@


1.17
log
@Expose changemode for use by "self-contained" modes
@
text
@d1 1
a1 1
/*	$OpenBSD: modes.c,v 1.16 2005/12/13 07:20:13 kjell Exp $	*/
a71 9
}

/*
 * Fake the GNU "blink-matching-paren" variable.
 */
int
blinkparen(int f, int n)
{
	return (changemode(f, n, "blink"));
@


1.16
log
@Last round of easy delinting.
@
text
@d1 1
a1 1
/*	$OpenBSD: modes.c,v 1.15 2005/12/13 06:01:27 kjell Exp $	*/
d14 1
a14 1
static int	changemode(int, int, char *);
d20 1
a20 1
static int
@


1.15
log
@More name-clash delinting
@
text
@d1 1
a1 1
/*	$OpenBSD: modes.c,v 1.14 2005/11/22 04:23:14 kjell Exp $	*/
d120 1
a120 1
	char	 mode[32], *bufp;
d122 1
a122 1
	if ((bufp = eread("Set Default Mode: ", mode, sizeof(mode),
d127 2
a128 2
	if ((m = name_mode(mode)) == NULL) {
		ewprintf("can't find mode %s", mode);
d159 1
a159 1
	if (strcmp(mode, "overwrite") == 0) {
d166 1
a166 1
	if (strcmp(mode, "notab") == 0) {
@


1.14
log
@Fix up an ambiguous else (though ifdefed out at the moment)
@
text
@d1 1
a1 1
/*	$OpenBSD: modes.c,v 1.13 2005/11/18 20:56:53 deraadt Exp $	*/
d101 1
a101 1
overwrite(int f, int n)
@


1.13
log
@greedy use of typedef struct was making code harder to read; ok kjell cloder
@
text
@d1 1
a1 1
/*	$OpenBSD: modes.c,v 1.12 2005/08/09 00:53:48 kjell Exp $	*/
d166 1
a166 1
	if (strcmp(mode, "notab") == 0)
d171 1
@


1.12
log
@Clean up eread handling in mg. (basically, fallout from the 'enter often
means abort' behaviour added during the hackathon). Eliminates
redundant ereply function, fixes miscellaneous cores when aborting,
and move a number of assumed pathnames into the prompt text, since
they are used there anyway. All changes consistent with emacs behavior

ok beck@@ many, many moons ago.
@
text
@d1 1
a1 1
/*	$OpenBSD: modes.c,v 1.11 2005/06/14 18:14:40 kjell Exp $	*/
d17 1
a17 1
MAPS	*defb_modes[PBMODES] = { &fundamental_mode };
d24 1
a24 1
	MAPS	*m;
d119 1
a119 1
	MAPS	*m;
@


1.11
log
@Add explicit public domain notices to all public domain files.
ok millert@@, deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: modes.c,v 1.10 2005/04/03 02:09:28 db Exp $	*/
d122 2
a123 1
	if ((bufp = eread("Set Default Mode: ", mode, 32, EFNEW)) == NULL)
@


1.10
log
@This is a no binary change which does:

- spelling, punctuation fixes
- variable declaration lineup
- use parentheses for return and sizeof
- K&R function declarations -> ANSI
- other minor code beautification

ok henning@@
@
text
@d1 3
a3 1
/*	$OpenBSD: modes.c,v 1.9 2004/07/22 01:25:25 vincent Exp $	*/
@


1.9
log
@stage 1 of the infinite minibuffer work - add support for on the fly
buffer reallocation in veread().  This commit only changes the API.
All the buffers have exactly the same bounds as before for now.

tested by a couple of my very helpful testers!
@
text
@d1 1
a1 1
/*	$OpenBSD: modes.c,v 1.8 2002/07/01 14:33:44 vincent Exp $	*/
d26 1
a26 1
		return FALSE;
d40 1
a40 1
				return TRUE;
d43 1
a43 1
			return FALSE;
d51 1
a51 1
			return TRUE;	/* mode wasn't set */
d57 1
a57 1
	return TRUE;
d63 1
a63 1
	return changemode(f, n, "indent");
d69 1
a69 1
	return changemode(f, n, "fill");
d78 1
a78 1
	return changemode(f, n, "blink");
d86 1
a86 1
		return FALSE;
d94 1
a94 1
	return TRUE;
d102 1
a102 1
		return FALSE;
d110 1
a110 1
	return TRUE;
d121 1
a121 1
		return ABORT;
d123 1
a123 1
		return FALSE;
d126 1
a126 1
		return FALSE;
d140 1
a140 1
				return TRUE;
d143 1
a143 1
			return FALSE;
d151 1
a151 1
			return TRUE;
d169 1
a169 1
	return TRUE;
@


1.8
log
@KNF + ansi; from zyrnix (only the easy part of his diffs)
@
text
@d1 1
a1 1
/*	$OpenBSD: modes.c,v 1.7 2002/02/16 21:27:49 millert Exp $	*/
d118 1
a118 1
	char	 mode[32];
d120 1
a120 1
	if (eread("Set Default Mode: ", mode, 32, EFNEW) != TRUE)
d122 2
@


1.7
log
@Part one of userland __P removal.  Done with a simple regexp with some minor hand editing to make comments line up correctly.  Another pass is forthcoming that handles the cases that could not be done automatically.
@
text
@d1 1
a1 1
/*	$OpenBSD: modes.c,v 1.6 2001/05/24 10:43:21 art Exp $	*/
d19 1
a19 3
changemode(f, n, mode)
	int   f, n;
	char *mode;
d61 1
a61 2
indentmode(f, n)
	int f, n;
d67 1
a67 2
fillmode(f, n)
	int f, n;
d76 1
a76 2
blinkparen(f, n)
	int f, n;
d83 1
a83 2
notabmode(f, n)
	int f, n;
d99 1
a99 2
overwrite(f, n)
	int f, n;
d114 1
a114 2
set_default_mode(f, n)
	int f, n;
@


1.6
log
@Make the keymap/mode table growable in runtime.
@
text
@d1 1
a1 1
/*	$OpenBSD: modes.c,v 1.5 2001/05/24 03:05:25 mickey Exp $	*/
d12 1
a12 1
static int	changemode	__P((int, int, char *));
@


1.5
log
@spaces
@
text
@d1 1
a1 1
/*	$OpenBSD: modes.c,v 1.4 2001/01/29 01:58:09 niklas Exp $	*/
d15 1
a15 1
MAPS	*defb_modes[PBMODES] = { &map_table[0] };
@


1.4
log
@$OpenBSD$
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d4 2
a5 2
 * Commands to toggle modes.   Without an argument, these functions will 
 * toggle the given mode.  A negative or zero argument will turn the mode 
d50 1
a50 1
		for (i = 1; i <= curbp->b_nmodes && m != curbp->b_modes[i]; 
d163 1
a163 1
		if (n <= 0) 
d165 1
a165 1
		else 
@


1.3
log
@More -Wall anmd KNF, from op2@@tomahawk.SQUiSH.org
@
text
@d1 2
@


1.2
log
@The start of KNF + -Wall.  The code has been run through indent but
needs hand fixup.  I stopped at keymap.c...
@
text
@d2 3
a4 2
 * Commands to toggle modes. Without an argument, toggle mode.
 * Negitive or zero argument, mode off.	 Positive argument, mode on.
d10 5
a14 3
int             defb_nmodes = 0;
MAPS           *defb_modes[PBMODES] = {&map_table[0]};
int             defb_flag = 0;
d18 2
a19 2
	int             f, n;
	char           *mode;
d21 2
a22 2
	register int    i;
	MAPS           *m;
d31 2
a32 1
				n = 0;	/* mode already set */
d39 2
a40 1
				return TRUE;	/* mode already set */
d48 2
a49 2
		for (i = 1; i <= curbp->b_nmodes && m != curbp->b_modes[i]; i++) {
		}
d60 1
d62 1
d67 1
d69 1
d77 1
d79 1
d84 2
a85 1
#ifdef	NOTAB
d87 1
d100 1
a100 1
#endif
d102 1
d104 1
a104 1
	int             f, n;
d118 1
d120 1
a120 1
	int             f, n;
d122 3
a124 3
	register int    i;
	register MAPS  *m;
	char            mode[32];
d135 2
a136 1
				n = 0;	/* mode already set */
d143 2
a144 1
				return TRUE;	/* mode already set */
d152 1
a152 2
		for (i = 1; i <= defb_nmodes && m != defb_modes[i]; i++) {
		}
d154 2
a155 1
			return TRUE;	/* mode wasn't set */
d160 2
a161 2
	if (strcmp(mode, "overwrite") == 0)
		if (n <= 0)
d163 1
a163 1
		else
d165 1
d172 1
a172 1
#endif
@


1.1
log
@initial import of mg2a
@
text
@d9 44
a52 41
int defb_nmodes = 0;
MAPS *defb_modes[PBMODES] = {&map_table[0]};
int defb_flag = 0;

static int changemode(f, n, mode)
int f, n;
char *mode;
{
    register int i;
    MAPS *m;
    VOID upmodes();

    if((m = name_mode(mode)) == NULL) {
	ewprintf("Can't find mode %s", mode);
	return FALSE;
    }
    if(!(f & FFARG)) {
	for(i=0; i <= curbp->b_nmodes; i++)
	    if(curbp->b_modes[i] == m) {
		n = 0;			/* mode already set */
		break;
	    }
    }
    if(n > 0) {
	for(i=0; i <= curbp->b_nmodes; i++)
	    if(curbp->b_modes[i] == m) return TRUE;	/* mode already set */
	if(curbp->b_nmodes >= PBMODES-1) {
	    ewprintf("Too many modes");
	    return FALSE;
	}
	curbp->b_modes[++(curbp->b_nmodes)] = m;
    } else {
	/* fundamental is b_modes[0] and can't be unset */
	for(i=1; i <= curbp->b_nmodes && m != curbp->b_modes[i]; i++) {}
	if(i > curbp->b_nmodes) return TRUE;		/* mode wasn't set */
	for(; i < curbp->b_nmodes; i++)
	    curbp->b_modes[i] = curbp->b_modes[i+1];
	curbp->b_nmodes--;
    }
    upmodes(curbp);
    return TRUE;
d57 1
a57 1
    return changemode(f, n, "indent");
d62 1
a62 1
    return changemode(f, n, "fill");
d70 1
a70 1
    return changemode(f, n, "blink");
d76 10
a85 6
    if(changemode(f, n, "notab") == FALSE) return FALSE;
    if(f & FFARG) {
	if(n <= 0) curbp->b_flag &= ~BFNOTAB;
	else curbp->b_flag |= BFNOTAB;
    } else curbp->b_flag ^= BFNOTAB;
    return TRUE;
d90 1
a90 1
int f, n;
d92 10
a101 6
    if(changemode(f, n, "overwrite") == FALSE) return FALSE;
    if(f & FFARG) {
	if(n <= 0) curbp->b_flag &= ~BFOVERWRITE;
	else curbp->b_flag |= BFOVERWRITE;
    } else curbp->b_flag ^= BFOVERWRITE;
    return TRUE;
d105 1
a105 1
int f, n;
d107 41
a147 36
    register int i;
    register MAPS *m;
    char mode[32];

    if(eread("Set Default Mode: ", mode, 32, EFNEW) != TRUE)
    	return ABORT;
    if((m = name_mode(mode)) == NULL) {
    	ewprintf("can't find mode %s", mode);
	return FALSE;
    }
    if(!(f & FFARG)) {
	for(i=0; i <= defb_nmodes; i++)
	    if(defb_modes[i] == m) {
		n = 0;			/* mode already set */
		break;
	    }
    }
    if(n > 0) {
	for(i=0; i <= defb_nmodes; i++)
	    if(defb_modes[i] == m) return TRUE;	/* mode already set */
	if(defb_nmodes >= PBMODES-1) {
	    ewprintf("Too many modes");
	    return FALSE;
	}
	defb_modes[++defb_nmodes] = m;
    } else {
	/* fundamental is defb_modes[0] and can't be unset */
	for(i=1; i <= defb_nmodes && m != defb_modes[i]; i++) {}
	if(i > defb_nmodes) return TRUE;		/* mode wasn't set */
	for(; i < defb_nmodes; i++)
	    defb_modes[i] = defb_modes[i+1];
	defb_nmodes--;
    }
    if(strcmp(mode, "overwrite")==0)
    	if(n<=0) defb_flag &= ~BFOVERWRITE;
	else defb_flag |= BFOVERWRITE;
d149 5
a153 3
    if(strcmp(mode, "notab")==0)
    	if(n<=0) defb_flag &= ~BFNOTAB;
	else defb_flag |= BFNOTAB;
d155 1
a155 1
    return TRUE;
@

