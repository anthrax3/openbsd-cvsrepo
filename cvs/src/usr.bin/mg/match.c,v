head	1.19;
access;
symbols
	OPENBSD_6_2:1.19.0.8
	OPENBSD_6_2_BASE:1.19
	OPENBSD_6_1:1.19.0.10
	OPENBSD_6_1_BASE:1.19
	OPENBSD_6_0:1.19.0.6
	OPENBSD_6_0_BASE:1.19
	OPENBSD_5_9:1.19.0.2
	OPENBSD_5_9_BASE:1.19
	OPENBSD_5_8:1.19.0.4
	OPENBSD_5_8_BASE:1.19
	OPENBSD_5_7:1.17.0.4
	OPENBSD_5_7_BASE:1.17
	OPENBSD_5_6:1.17.0.8
	OPENBSD_5_6_BASE:1.17
	OPENBSD_5_5:1.17.0.6
	OPENBSD_5_5_BASE:1.17
	OPENBSD_5_4:1.17.0.2
	OPENBSD_5_4_BASE:1.17
	OPENBSD_5_3:1.16.0.16
	OPENBSD_5_3_BASE:1.16
	OPENBSD_5_2:1.16.0.14
	OPENBSD_5_2_BASE:1.16
	OPENBSD_5_1_BASE:1.16
	OPENBSD_5_1:1.16.0.12
	OPENBSD_5_0:1.16.0.10
	OPENBSD_5_0_BASE:1.16
	OPENBSD_4_9:1.16.0.8
	OPENBSD_4_9_BASE:1.16
	OPENBSD_4_8:1.16.0.6
	OPENBSD_4_8_BASE:1.16
	OPENBSD_4_7:1.16.0.2
	OPENBSD_4_7_BASE:1.16
	OPENBSD_4_6:1.16.0.4
	OPENBSD_4_6_BASE:1.16
	OPENBSD_4_5:1.15.0.4
	OPENBSD_4_5_BASE:1.15
	OPENBSD_4_4:1.15.0.2
	OPENBSD_4_4_BASE:1.15
	OPENBSD_4_3:1.13.0.8
	OPENBSD_4_3_BASE:1.13
	OPENBSD_4_2:1.13.0.6
	OPENBSD_4_2_BASE:1.13
	OPENBSD_4_1:1.13.0.4
	OPENBSD_4_1_BASE:1.13
	OPENBSD_4_0:1.13.0.2
	OPENBSD_4_0_BASE:1.13
	OPENBSD_3_9:1.12.0.2
	OPENBSD_3_9_BASE:1.12
	OPENBSD_3_8:1.11.0.2
	OPENBSD_3_8_BASE:1.11
	OPENBSD_3_7:1.9.0.8
	OPENBSD_3_7_BASE:1.9
	OPENBSD_3_6:1.9.0.6
	OPENBSD_3_6_BASE:1.9
	OPENBSD_3_5:1.9.0.4
	OPENBSD_3_5_BASE:1.9
	OPENBSD_3_4:1.9.0.2
	OPENBSD_3_4_BASE:1.9
	OPENBSD_3_3:1.8.0.6
	OPENBSD_3_3_BASE:1.8
	OPENBSD_3_2:1.8.0.4
	OPENBSD_3_2_BASE:1.8
	OPENBSD_3_1:1.8.0.2
	OPENBSD_3_1_BASE:1.8
	OPENBSD_3_0:1.7.0.2
	OPENBSD_3_0_BASE:1.7
	OPENBSD_2_9_BASE:1.4
	OPENBSD_2_9:1.4.0.2
	OPENBSD_2_8:1.3.0.2
	OPENBSD_2_8_BASE:1.3
	OPENBSD_2_7:1.2.0.2
	OPENBSD_2_7_BASE:1.2;
locks; strict;
comment	@ * @;


1.19
date	2015.06.03.23.40.01;	author bcallah;	state Exp;
branches;
next	1.18;
commitid	CQOgDk07oNMjC1Ge;

1.18
date	2015.03.19.21.22.15;	author bcallah;	state Exp;
branches;
next	1.17;
commitid	GbEBL4CfPvDkB8hj;

1.17
date	2013.05.31.18.03.44;	author lum;	state Exp;
branches;
next	1.16;

1.16
date	2009.06.04.02.23.37;	author kjell;	state Exp;
branches;
next	1.15;

1.15
date	2008.06.14.08.46.30;	author kjell;	state Exp;
branches;
next	1.14;

1.14
date	2008.06.13.19.01.53;	author kjell;	state Exp;
branches;
next	1.13;

1.13
date	2006.07.25.08.22.32;	author kjell;	state Exp;
branches;
next	1.12;

1.12
date	2005.11.18.20.56.53;	author deraadt;	state Exp;
branches;
next	1.11;

1.11
date	2005.06.14.18.14.40;	author kjell;	state Exp;
branches;
next	1.10;

1.10
date	2005.04.03.02.09.28;	author db;	state Exp;
branches;
next	1.9;

1.9
date	2003.05.20.03.08.55;	author cloder;	state Exp;
branches;
next	1.8;

1.8
date	2002.02.16.21.27.49;	author millert;	state Exp;
branches;
next	1.7;

1.7
date	2001.05.24.03.05.24;	author mickey;	state Exp;
branches;
next	1.6;

1.6
date	2001.05.23.22.20.36;	author art;	state Exp;
branches;
next	1.5;

1.5
date	2001.05.23.15.20.19;	author art;	state Exp;
branches;
next	1.4;

1.4
date	2001.01.29.01.58.08;	author niklas;	state Exp;
branches;
next	1.3;

1.3
date	2000.09.01.14.59.09;	author millert;	state Exp;
branches;
next	1.2;

1.2
date	2000.04.13.06.12.16;	author millert;	state Exp;
branches;
next	1.1;

1.1
date	2000.02.25.19.08.49;	author deraadt;	state Exp;
branches;
next	;


desc
@@


1.19
log
@Remove unused defines and functions.
"Looks fine." deraadt@@
@
text
@/*	$OpenBSD: match.c,v 1.18 2015/03/19 21:22:15 bcallah Exp $	*/

/* This file is in the public domain. */

/*
 *	Limited parenthesis matching routines
 *
 * The hacks in this file implement automatic matching * of (), [], {}, and
 * other characters.  It would be better to have a full-blown syntax table,
 * but there's enough overhead in the editor as it is.
 */

#include <sys/queue.h>
#include <signal.h>
#include <stdio.h>

#include "def.h"
#include "key.h"

static int	balance(void);
static void	displaymatch(struct line *, int);

/*
 * Balance table. When balance() encounters a character that is to be
 * matched, it first searches this table for a balancing left-side character.
 * If the character is not in the table, the character is balanced by itself.
 */
static struct balance {
	char	left, right;
} bal[] = {
	{ '(', ')' },
	{ '[', ']' },
	{ '{', '}' },
	{ '<', '>' },
	{ '\0', '\0' }
};

/*
 * Hack to show matching paren.  Self-insert character, then show matching
 * character, if any.  Bound to "blink-and-insert".
 */
int
showmatch(int f, int n)
{
	int	i, s;

	for (i = 0; i < n; i++) {
		if ((s = selfinsert(FFRAND, 1)) != TRUE)
			return (s);
		/* unbalanced -- warn user */
		if (balance() != TRUE)
			dobeep();
	}
	return (TRUE);
}

/*
 * Search for and display a matching character.
 *
 * This routine does the real work of searching backward
 * for a balancing character.  If such a balancing character
 * is found, it uses displaymatch() to display the match.
 */
static int
balance(void)
{
	struct line	*clp;
	int	 cbo;
	int	 c, i, depth;
	int	 rbal, lbal;

	rbal = key.k_chars[key.k_count - 1];

	/* See if there is a matching character -- default to the same */
	lbal = rbal;
	for (i = 0; bal[i].right != '\0'; i++)
		if (bal[i].right == rbal) {
			lbal = bal[i].left;
			break;
		}

	/*
	 * Move behind the inserted character.	We are always guaranteed
	 * that there is at least one character on the line.
	 */
	clp = curwp->w_dotp;
	cbo = curwp->w_doto - 1;

	/* init nesting depth */
	depth = 0;

	for (;;) {
		if (cbo == 0) {
			clp = lback(clp);	/* beginning of line	*/
			if (clp == curbp->b_headp)
				return (FALSE);
			cbo = llength(clp) + 1;
		}
		if (--cbo == llength(clp))
			c = '\n';		/* end of line		*/
		else
			c = lgetc(clp, cbo);	/* somewhere in middle	*/

		/*
		 * Check for a matching character.  If still in a nested
		 * level, pop out of it and continue search.  This check
		 * is done before the nesting check so single-character
		 * matches will work too.
		 */
		if (c == lbal) {
			if (depth == 0) {
				displaymatch(clp, cbo);
				return (TRUE);
			} else
				depth--;
		}
		/* Check for another level of nesting.	 */
		if (c == rbal)
			depth++;
	}
	/* NOTREACHED */
}

/*
 * Display matching character.  Matching characters that are not in the
 * current window are displayed in the echo line. If in the current window,
 * move dot to the matching character, sit there a while, then move back.
 */
static void
displaymatch(struct line *clp, int cbo)
{
	struct line	*tlp;
	int	 tbo;
	int	 cp;
	int	 bufo;
	int	 c;
	int	 inwindow;
	char	 buf[NLINE];

	/*
	 * Figure out if matching char is in current window by
	 * searching from the top of the window to dot.
	 */
	inwindow = FALSE;
	for (tlp = curwp->w_linep; tlp != lforw(curwp->w_dotp);
	    tlp = lforw(tlp))
		if (tlp == clp)
			inwindow = TRUE;

	if (inwindow == TRUE) {
		tlp = curwp->w_dotp;	/* save current position */
		tbo = curwp->w_doto;

		curwp->w_dotp = clp;	/* move to new position */
		curwp->w_doto = cbo;
		curwp->w_rflag |= WFMOVE;

		update(CMODE);		/* show match */
		ttwait(1000);		/* wait for key or 1 second */

		curwp->w_dotp = tlp;	/* return to old position */
		curwp->w_doto = tbo;
		curwp->w_rflag |= WFMOVE;
		update(CMODE);
	} else {
		/* match is not in this window, so display line in echo area */
		bufo = 0;
		for (cp = 0; cp < llength(clp); cp++) {
			c = lgetc(clp, cp);
			if (c != '\t'
#ifdef NOTAB
			    || (curbp->b_flag & BFNOTAB)
#endif
				)
				if (ISCTRL(c)) {
					buf[bufo++] = '^';
					buf[bufo++] = CCHR(c);
				} else
					buf[bufo++] = c;
			else
				do {
					buf[bufo++] = ' ';
				} while (bufo & 7);
		}
		buf[bufo++] = '\0';
		ewprintf("Matches %s", buf);
	}
}
@


1.18
log
@Clean up the includes in mg.
This does the following:
Moves all POSIX headers from sysdef.h into the individual .c files so that
each file now only includes what it needs. All headers are properly sorted.
Moves the remainder of sysdef.h to other files (mostly def.h) and deletes
sysdef.h now that it's no longer contains anything.
Tweak a comment that references sysdef.h so that it no longer does that.
ok florian@@
@
text
@d1 1
a1 1
/*	$OpenBSD: match.c,v 1.17 2013/05/31 18:03:44 lum Exp $	*/
d84 1
a84 2
	 * that there is at least one character on the line, since one was
	 * just self-inserted by blinkparen.
@


1.17
log
@Make the system bell toggleable via 'audible-bell', and if switched
off, make available an alternative 'visible-bell'.

ok florian@@ jasper@@ Feedback Sunil Nimmagadda.
@
text
@d1 1
a1 1
/*	$OpenBSD: match.c,v 1.16 2009/06/04 02:23:37 kjell Exp $	*/
d12 4
@


1.16
log
@Rename w_flag to w_rflag. This is not a general purpose
flag: it is for redisplay options only. I need an additional all-purpose
flag, so renaming removes the desire to wrongly overload the existing one.

Turdshine. No functional chage.
@
text
@d1 1
a1 1
/*	$OpenBSD: match.c,v 1.15 2008/06/14 08:46:30 kjell Exp $	*/
d48 1
a48 1
			ttbeep();
d155 1
a155 1
		update();		/* show match */
d161 1
a161 1
		update();
@


1.15
log
@We do not need a whole MODE for blinking one character.

both emacsen automatically blink, so mg should too. This can be
overridden in your ~/.mg by adding, e.g.

global-set-key ")" self-insert-command

So, I've eliminated blink mode, and renamed "blink-matching-paren-hack"
to "blink-and-insert". It's not just for parens anyway.

While I'm here, set up an empty (rescan) target for backtab, so I can
bind something convenient to it; e.g.

global-set-key "\e[Z" backward-char

Finally, remove all references to Scribd.
Theo doesn't hate this, though I would hesitate to call it an ok.
@
text
@d1 1
a1 1
/*	$OpenBSD: match.c,v 1.14 2008/06/13 19:01:53 kjell Exp $	*/
d153 1
a153 1
		curwp->w_flag |= WFMOVE;
d160 1
a160 1
		curwp->w_flag |= WFMOVE;
@


1.14
log
@Allow selfinsert to be called with FFRAND; i.e. from another
function. While here, tighten whitespace.
@
text
@d1 1
a1 1
/*	$OpenBSD: match.c,v 1.13 2006/07/25 08:22:32 kjell Exp $	*/
a10 3
 *
 * Since I often edit Scribe code, I've made it possible to blink arbitrary
 * characters -- just bind delimiter characters to "blink-matching-paren-hack"
a22 1
 * This is to allow delimiters in Scribe documents to be matched.
d36 1
a36 1
 * character, if any.  Bound to "blink-matching-paren-command".
@


1.13
log
@Rename the header line of a buffer to b_headp, from the remarkably
unintuitive b_linep. No binary change.
@
text
@d1 1
a1 1
/*	$OpenBSD: match.c,v 1.12 2005/11/18 20:56:53 deraadt Exp $	*/
d31 5
a35 15
	{
		'(', ')'
	},
	{
		'[', ']'
	},
	{
		'{', '}'
	},
	{
		'<', '>'
	},
	{
		'\0', '\0'
	}
a46 2
	if (f & FFRAND)
		return (FALSE);
@


1.12
log
@greedy use of typedef struct was making code harder to read; ok kjell cloder
@
text
@d1 1
a1 1
/*	$OpenBSD: match.c,v 1.11 2005/06/14 18:14:40 kjell Exp $	*/
d108 1
a108 1
			if (clp == curbp->b_linep)
@


1.11
log
@Add explicit public domain notices to all public domain files.
ok millert@@, deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: match.c,v 1.10 2005/04/03 02:09:28 db Exp $	*/
d20 1
a20 1
static void	displaymatch(LINE *, int);
d79 1
a79 1
	LINE	*clp;
d143 1
a143 1
displaymatch(LINE *clp, int cbo)
d145 1
a145 1
	LINE	*tlp;
@


1.10
log
@This is a no binary change which does:

- spelling, punctuation fixes
- variable declaration lineup
- use parentheses for return and sizeof
- K&R function declarations -> ANSI
- other minor code beautification

ok henning@@
@
text
@d1 3
a3 1
/*	$OpenBSD: match.c,v 1.9 2003/05/20 03:08:55 cloder Exp $	*/
@


1.9
log
@Finish KNF of prototypes.  That should be all of them.
OK vincent@@
@
text
@d1 1
a1 1
/*	$OpenBSD: match.c,v 1.8 2002/02/16 21:27:49 millert Exp $	*/
a25 1

d56 1
a56 1
		return FALSE;
d59 1
a59 1
			return s;
d64 1
a64 1
	return TRUE;
a73 1

d79 2
a80 5
	int	 c;
	int	 i;
	int	 rbal;
	int	 lbal;
	int	 depth;
a134 1

a139 1

@


1.8
log
@Part one of userland __P removal.  Done with a simple regexp with some minor hand editing to make comments line up correctly.  Another pass is forthcoming that handles the cases that could not be done automatically.
@
text
@d1 1
a1 1
/*	$OpenBSD: match.c,v 1.7 2001/05/24 03:05:24 mickey Exp $	*/
d52 1
a52 2
showmatch(f, n)
	int f, n;
d77 1
a77 1
balance()
d148 1
a148 3
displaymatch(clp, cbo)
	LINE *clp;
	int cbo;
@


1.7
log
@spaces
@
text
@d1 1
a1 1
/*	$OpenBSD: match.c,v 1.6 2001/05/23 22:20:36 art Exp $	*/
d17 2
a18 2
static int	balance		__P((void));
static void	displaymatch	__P((LINE *, int));
@


1.6
log
@remove VOID. We're way beyond the point where this could build with an
ancient compiler.
@
text
@d1 1
a1 1
/*	$OpenBSD: match.c,v 1.5 2001/05/23 15:20:19 art Exp $	*/
d6 2
a7 2
 * The hacks in this file implement automatic matching * of (), [], {}, and 
 * other characters.  It would be better to have a full-blown syntax table, 
d10 1
a10 1
 * Since I often edit Scribe code, I've made it possible to blink arbitrary 
d48 1
a48 1
 * Hack to show matching paren.  Self-insert character, then show matching 
d84 1
a84 1
	int	 rbal; 
d143 2
a144 2
 * Display matching character.  Matching characters that are not in the 
 * current window are displayed in the echo line. If in the current window, 
d166 1
a166 1
	for (tlp = curwp->w_linep; tlp != lforw(curwp->w_dotp); 
@


1.5
log
@When showing the matching paren, don't sleep for one second, use ttwait
instead so that the sleep is aborted when we continue typing.
@
text
@d1 1
a1 1
/*	$OpenBSD: match.c,v 1.4 2001/01/29 01:58:08 niklas Exp $	*/
d18 1
a18 1
static VOID	displaymatch	__P((LINE *, int));
d148 1
a148 1
static VOID
@


1.4
log
@$OpenBSD$
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d172 1
a172 1
		tlp = curwp->w_dotp;	/* save current position	*/
d175 1
a175 1
		curwp->w_dotp = clp;	/* move to new position		*/
d179 2
a180 2
		update();		/* show match			*/
		sleep(1);		/* wait a bit			*/
d182 1
a182 1
		curwp->w_dotp = tlp;	/* return to old position	*/
@


1.3
log
@More -Wall anmd KNF, from op2@@tomahawk.SQUiSH.org
@
text
@d1 2
@


1.2
log
@The start of KNF + -Wall.  The code has been run through indent but
needs hand fixup.  I stopped at keymap.c...
@
text
@d2 1
a2 2
 * Name:	MicroEMACS
 *		Limited parenthesis matching routines
d4 3
a6 4
 * The hacks in this file implement automatic matching
 * of (), [], {}, and other characters.	 It would be
 * better to have a full-blown syntax table, but there's
 * enough overhead in the editor as it is.
d8 2
a9 3
 * Since I often edit Scribe code, I've made it possible to
 * blink arbitrary characters -- just bind delimiter characters
 * to "blink-matching-paren-hack"
a10 2
#include	"def.h"
#include	"key.h"
d12 5
a16 2
static int      balance();
static VOID     displaymatch();
d21 1
a21 1
 * f the character is not in the table, the character is balanced by itself.
d26 2
a27 2
	char            left, right;
}               bal[] = {
d46 2
a47 2
 * Self-insert character, then show matching character,
 * if any.  Bound to "blink-matching-paren-command".
d49 1
a49 1

d51 1
d53 1
a53 1
	register int    i, s;
d60 2
a61 1
		if (balance() != TRUE)	/* unbalanced -- warn user */
d75 1
a75 1
static
d78 7
a84 6
	register LINE  *clp;
	register int    cbo;
	int             c;
	int             i;
	int             rbal, lbal;
	int             depth;
a88 1

a94 3
	/* Move behind the inserted character.	We are always guaranteed    */
	/* that there is at least one character on the line, since one was  */
	/* just self-inserted by blinkparen.				    */
d96 5
d104 2
a105 1
	depth = 0;		/* init nesting depth		 */
d108 2
a109 2
		if (cbo == 0) {	/* beginning of line	 */
			clp = lback(clp);
d114 2
a115 2
		if (--cbo == llength(clp))	/* end of line		 */
			c = '\n';
d117 1
a117 1
			c = lgetc(clp, cbo);	/* somewhere in middle	 */
d119 6
a124 4
		/* Check for a matching character.  If still in a nested */
		/* level, pop out of it and continue search.  This check */
		/* is done before the nesting check so single-character	 */
		/* matches will work too.				 */
d141 3
a143 5
 * Display matching character.
 * Matching characters that are not in the current window
 * are displayed in the echo line. If in the current
 * window, move dot to the matching character,
 * sit there a while, then move back.
d146 1
a146 1
static          VOID
d148 2
a149 2
	register LINE  *clp;
	register int    cbo;
d151 12
a162 11
	register LINE  *tlp;
	register int    tbo;
	register int    cp;
	register int    bufo;
	register int    c;
	int             inwindow;
	char            buf[NLINE];

	/* Figure out if matching char is in current window by	 */
	/* searching from the top of the window to dot.		 */

d164 2
a165 1
	for (tlp = curwp->w_linep; tlp != lforw(curwp->w_dotp); tlp = lforw(tlp))
d170 1
a170 1
		tlp = curwp->w_dotp;	/* save current position */
d173 1
a173 1
		curwp->w_dotp = clp;	/* move to new position */
d177 2
a178 2
		update();	/* show match */
		sleep(1);	/* wait a bit */
d180 1
a180 1
		curwp->w_dotp = tlp;	/* return to old position */
d184 2
a185 2
	} else {		/* match not in this window so display line
				 * in echo area */
d187 1
a187 1
		for (cp = 0; cp < llength(clp); cp++) {	/* expand tabs	 */
d190 1
a190 1
#ifdef	NOTAB
@


1.1
log
@initial import of mg2a
@
text
@d17 2
a18 2
static int	balance();
static VOID	displaymatch();
d20 4
a23 4
/* Balance table. When balance() encounters a character
 * that is to be matched, it first searches this table
 * for a balancing left-side character.	 If the character
 * is not in the table, the character is balanced by itself.
d28 17
a44 7
	char left, right;
} bal[] = {
	{ '(', ')' },
	{ '[', ']' },
	{ '{', '}' },
	{ '<', '>' },
	{ '\0','\0'}
d54 1
a54 1
	register int  i, s;
d56 2
a57 1
	if (f & FFRAND) return FALSE;
d61 1
a61 1
		if (balance() != TRUE) /* unbalanced -- warn user */
d75 2
a76 1
static balance()
d78 6
a83 6
	register LINE	*clp;
	register int	cbo;
	int	c;
	int	i;
	int	rbal, lbal;
	int	depth;
d85 1
a85 1
	rbal = key.k_chars[key.k_count-1];
a94 1

d102 1
a102 1
	depth = 0;			/* init nesting depth		*/
d105 1
a105 1
		if (cbo == 0) {			/* beginning of line	*/
d109 1
a109 1
			cbo = llength(clp)+1;
d111 1
a111 1
		if (--cbo == llength(clp))	/* end of line		*/
d114 1
a114 1
			c = lgetc(clp,cbo);	/* somewhere in middle	*/
d122 1
a122 1
				displaymatch(clp,cbo);
d124 1
a124 2
			}
			else
d127 1
a127 1
		/* Check for another level of nesting.	*/
d131 1
a131 1
	/*NOTREACHED*/
d143 4
a146 3
static VOID displaymatch(clp, cbo)
register LINE *clp;
register int  cbo;
d148 7
a154 7
	register LINE	*tlp;
	register int	tbo;
	register int	cp;
	register int	bufo;
	register int	c;
	int		inwindow;
	char		buf[NLINE];
d156 2
a157 2
	/* Figure out if matching char is in current window by	*/
	/* searching from the top of the window to dot.		*/
d168 2
a169 2
		curwp->w_dotp  = clp;	/* move to new position */
		curwp->w_doto  = cbo;
d172 2
a173 2
		update();		/* show match */
		sleep(1);		/* wait a bit */
d175 3
a177 3
		curwp->w_dotp	= tlp;	/* return to old position */
		curwp->w_doto	= tbo;
		curwp->w_flag  |= WFMOVE;
d179 2
a180 2
	}
	else {	/* match not in this window so display line in echo area */
d182 2
a183 2
		for (cp = 0; cp < llength(clp); cp++) { /* expand tabs	*/
			c = lgetc(clp,cp);
d186 1
a186 1
				|| (curbp->b_flag & BFNOTAB)
d188 6
a193 4
				) if(ISCTRL(c)) {
				    buf[bufo++] = '^';
				    buf[bufo++] = CCHR(c);
				} else buf[bufo++] = c;
d200 1
a200 1
		ewprintf("Matches %s",buf);
@

