head	1.84;
access;
symbols
	OPENBSD_6_2:1.84.0.2
	OPENBSD_6_2_BASE:1.84
	OPENBSD_6_1:1.84.0.4
	OPENBSD_6_1_BASE:1.84
	OPENBSD_6_0:1.83.0.2
	OPENBSD_6_0_BASE:1.83
	OPENBSD_5_9:1.81.0.2
	OPENBSD_5_9_BASE:1.81
	OPENBSD_5_8:1.75.0.4
	OPENBSD_5_8_BASE:1.75
	OPENBSD_5_7:1.74.0.2
	OPENBSD_5_7_BASE:1.74
	OPENBSD_5_6:1.72.0.4
	OPENBSD_5_6_BASE:1.72
	OPENBSD_5_5:1.71.0.6
	OPENBSD_5_5_BASE:1.71
	OPENBSD_5_4:1.71.0.2
	OPENBSD_5_4_BASE:1.71
	OPENBSD_5_3:1.70.0.2
	OPENBSD_5_3_BASE:1.70
	OPENBSD_5_2:1.67.0.2
	OPENBSD_5_2_BASE:1.67
	OPENBSD_5_1_BASE:1.63
	OPENBSD_5_1:1.63.0.2
	OPENBSD_5_0:1.61.0.10
	OPENBSD_5_0_BASE:1.61
	OPENBSD_4_9:1.61.0.8
	OPENBSD_4_9_BASE:1.61
	OPENBSD_4_8:1.61.0.6
	OPENBSD_4_8_BASE:1.61
	OPENBSD_4_7:1.61.0.2
	OPENBSD_4_7_BASE:1.61
	OPENBSD_4_6:1.61.0.4
	OPENBSD_4_6_BASE:1.61
	OPENBSD_4_5:1.60.0.4
	OPENBSD_4_5_BASE:1.60
	OPENBSD_4_4:1.60.0.2
	OPENBSD_4_4_BASE:1.60
	OPENBSD_4_3:1.56.0.6
	OPENBSD_4_3_BASE:1.56
	OPENBSD_4_2:1.56.0.4
	OPENBSD_4_2_BASE:1.56
	OPENBSD_4_1:1.56.0.2
	OPENBSD_4_1_BASE:1.56
	OPENBSD_4_0:1.54.0.2
	OPENBSD_4_0_BASE:1.54
	OPENBSD_3_9:1.49.0.2
	OPENBSD_3_9_BASE:1.49
	OPENBSD_3_8:1.41.0.2
	OPENBSD_3_8_BASE:1.41
	OPENBSD_3_7:1.37.0.2
	OPENBSD_3_7_BASE:1.37
	OPENBSD_3_6:1.33.0.2
	OPENBSD_3_6_BASE:1.33
	OPENBSD_3_5:1.29.0.2
	OPENBSD_3_5_BASE:1.29
	OPENBSD_3_4:1.25.0.2
	OPENBSD_3_4_BASE:1.25
	OPENBSD_3_3:1.23.0.2
	OPENBSD_3_3_BASE:1.23
	OPENBSD_3_2:1.22.0.2
	OPENBSD_3_2_BASE:1.22
	OPENBSD_3_1:1.19.0.2
	OPENBSD_3_1_BASE:1.19
	OPENBSD_3_0:1.14.0.2
	OPENBSD_3_0_BASE:1.14
	OPENBSD_2_9_BASE:1.6
	OPENBSD_2_9:1.6.0.2
	OPENBSD_2_8:1.5.0.2
	OPENBSD_2_8_BASE:1.5
	OPENBSD_2_7:1.4.0.2
	OPENBSD_2_7_BASE:1.4;
locks; strict;
comment	@ * @;


1.84
date	2016.09.16.17.17.40;	author tedu;	state Exp;
branches;
next	1.83;
commitid	g9Ro3DaY4DSbeipm;

1.83
date	2016.07.14.08.31.18;	author semarie;	state Exp;
branches;
next	1.82;
commitid	X351wak6SvhlNPZD;

1.82
date	2016.04.14.17.05.32;	author lum;	state Exp;
branches;
next	1.81;
commitid	SjhPISg2Q1dkB5Xg;

1.81
date	2015.12.24.09.07.47;	author lum;	state Exp;
branches;
next	1.80;
commitid	bbpWLjeo17Iha7wQ;

1.80
date	2015.11.19.19.30.44;	author bentley;	state Exp;
branches;
next	1.79;
commitid	fRy3vQUSh4OE6ZQH;

1.79
date	2015.11.11.15.37.34;	author deraadt;	state Exp;
branches;
next	1.78;
commitid	zA9ZbOybgNXdLu2t;

1.78
date	2015.11.11.15.10.20;	author deraadt;	state Exp;
branches;
next	1.77;
commitid	hmdAQoY8ffcMqPTo;

1.77
date	2015.11.08.19.31.57;	author jasper;	state Exp;
branches;
next	1.76;
commitid	AlKXuJsB2Jhy9WJp;

1.76
date	2015.10.29.19.46.47;	author lum;	state Exp;
branches;
next	1.75;
commitid	PxYPCO6Bag1LXTJ7;

1.75
date	2015.03.19.21.22.15;	author bcallah;	state Exp;
branches;
next	1.74;
commitid	GbEBL4CfPvDkB8hj;

1.74
date	2014.11.16.04.16.41;	author guenther;	state Exp;
branches;
next	1.73;
commitid	a9yG0qCw9VEW27qI;

1.73
date	2014.11.13.21.36.23;	author florian;	state Exp;
branches;
next	1.72;
commitid	hn552QYOpWpuadxy;

1.72
date	2014.03.22.11.05.37;	author lum;	state Exp;
branches;
next	1.71;

1.71
date	2013.05.31.18.03.44;	author lum;	state Exp;
branches;
next	1.70;

1.70
date	2012.12.28.16.12.50;	author naddy;	state Exp;
branches;
next	1.69;

1.69
date	2012.08.31.18.06.42;	author lum;	state Exp;
branches;
next	1.68;

1.68
date	2012.08.30.06.09.12;	author lum;	state Exp;
branches;
next	1.67;

1.67
date	2012.05.29.06.08.48;	author lum;	state Exp;
branches;
next	1.66;

1.66
date	2012.05.29.05.52.46;	author lum;	state Exp;
branches;
next	1.65;

1.65
date	2012.05.25.05.05.48;	author lum;	state Exp;
branches;
next	1.64;

1.64
date	2012.04.12.04.47.59;	author lum;	state Exp;
branches;
next	1.63;

1.63
date	2012.01.26.04.14.11;	author lum;	state Exp;
branches;
next	1.62;

1.62
date	2011.11.28.04.41.39;	author lum;	state Exp;
branches;
next	1.61;

1.61
date	2009.06.04.02.23.37;	author kjell;	state Exp;
branches;
next	1.60;

1.60
date	2008.06.13.18.51.02;	author kjell;	state Exp;
branches;
next	1.59;

1.59
date	2008.06.13.18.41.57;	author kjell;	state Exp;
branches;
next	1.58;

1.58
date	2008.06.12.01.58.44;	author kjell;	state Exp;
branches;
next	1.57;

1.57
date	2008.05.29.19.58.15;	author sobrado;	state Exp;
branches;
next	1.56;

1.56
date	2007.02.20.04.39.45;	author cloder;	state Exp;
branches;
next	1.55;

1.55
date	2006.11.19.16.51.19;	author deraadt;	state Exp;
branches;
next	1.54;

1.54
date	2006.07.25.08.22.32;	author kjell;	state Exp;
branches;
next	1.53;

1.53
date	2006.07.17.14.11.55;	author kjell;	state Exp;
branches;
next	1.52;

1.52
date	2006.06.01.05.34.52;	author jason;	state Exp;
branches;
next	1.51;

1.51
date	2006.05.28.23.30.16;	author kjell;	state Exp;
branches;
next	1.50;

1.50
date	2006.04.03.02.43.22;	author kjell;	state Exp;
branches;
next	1.49;

1.49
date	2006.02.25.14.40.16;	author otto;	state Exp;
branches;
next	1.48;

1.48
date	2005.12.13.06.01.27;	author kjell;	state Exp;
branches;
next	1.47;

1.47
date	2005.11.20.18.47.11;	author kjell;	state Exp;
branches;
next	1.46;

1.46
date	2005.11.20.03.24.17;	author deraadt;	state Exp;
branches;
next	1.45;

1.45
date	2005.11.18.20.56.53;	author deraadt;	state Exp;
branches;
next	1.44;

1.44
date	2005.10.13.20.43.17;	author deraadt;	state Exp;
branches;
next	1.43;

1.43
date	2005.10.13.20.41.09;	author deraadt;	state Exp;
branches;
next	1.42;

1.42
date	2005.10.13.05.47.45;	author kjell;	state Exp;
branches;
next	1.41;

1.41
date	2005.08.09.00.53.48;	author kjell;	state Exp;
branches;
next	1.40;

1.40
date	2005.06.14.18.14.40;	author kjell;	state Exp;
branches;
next	1.39;

1.39
date	2005.04.21.19.16.21;	author beck;	state Exp;
branches;
next	1.38;

1.38
date	2005.04.03.02.09.28;	author db;	state Exp;
branches;
next	1.37;

1.37
date	2005.03.12.10.36.13;	author jmc;	state Exp;
branches;
next	1.36;

1.36
date	2005.03.12.06.16.07;	author deraadt;	state Exp;
branches;
next	1.35;

1.35
date	2005.03.10.16.47.33;	author henning;	state Exp;
branches;
next	1.34;

1.34
date	2005.03.09.16.20.48;	author jfb;	state Exp;
branches;
next	1.33;

1.33
date	2004.07.19.12.14.08;	author vincent;	state Exp;
branches;
next	1.32;

1.32
date	2004.07.11.23.46.17;	author vincent;	state Exp;
branches;
next	1.31;

1.31
date	2004.07.11.20.37.15;	author pvalchev;	state Exp;
branches;
next	1.30;

1.30
date	2004.07.11.20.36.32;	author pvalchev;	state Exp;
branches;
next	1.29;

1.29
date	2004.02.02.20.21.14;	author vincent;	state Exp;
branches;
next	1.28;

1.28
date	2004.01.27.23.43.37;	author vincent;	state Exp;
branches;
next	1.27;

1.27
date	2003.12.04.01.52.01;	author vincent;	state Exp;
branches;
next	1.26;

1.26
date	2003.10.27.11.21.12;	author vincent;	state Exp;
branches;
next	1.25;

1.25
date	2003.06.26.23.04.10;	author vincent;	state Exp;
branches;
next	1.24;

1.24
date	2003.05.05.11.12.07;	author vincent;	state Exp;
branches;
next	1.23;

1.23
date	2003.01.06.17.04.09;	author deraadt;	state Exp;
branches;
next	1.22;

1.22
date	2002.07.25.16.37.54;	author vincent;	state Exp;
branches;
next	1.21;

1.21
date	2002.07.03.03.47.59;	author vincent;	state Exp;
branches;
next	1.20;

1.20
date	2002.07.01.14.33.44;	author vincent;	state Exp;
branches;
next	1.19;

1.19
date	2002.03.18.01.45.55;	author vincent;	state Exp;
branches;
next	1.18;

1.18
date	2002.02.21.15.27.29;	author deraadt;	state Exp;
branches;
next	1.17;

1.17
date	2002.02.21.00.02.04;	author deraadt;	state Exp;
branches;
next	1.16;

1.16
date	2002.02.20.22.30.54;	author vincent;	state Exp;
branches;
next	1.15;

1.15
date	2002.02.16.21.27.49;	author millert;	state Exp;
branches;
next	1.14;

1.14
date	2001.06.23.04.22.44;	author art;	state Exp;
branches;
next	1.13;

1.13
date	2001.05.24.10.58.34;	author art;	state Exp;
branches;
next	1.12;

1.12
date	2001.05.24.10.43.19;	author art;	state Exp;
branches;
next	1.11;

1.11
date	2001.05.24.09.47.34;	author art;	state Exp;
branches;
next	1.10;

1.10
date	2001.05.24.03.05.24;	author mickey;	state Exp;
branches;
next	1.9;

1.9
date	2001.05.23.23.29.48;	author mickey;	state Exp;
branches;
next	1.8;

1.8
date	2001.05.23.22.36.15;	author art;	state Exp;
branches;
next	1.7;

1.7
date	2001.05.23.22.20.35;	author art;	state Exp;
branches;
next	1.6;

1.6
date	2001.01.29.01.58.08;	author niklas;	state Exp;
branches;
next	1.5;

1.5
date	2000.09.01.14.59.09;	author millert;	state Exp;
branches;
next	1.4;

1.4
date	2000.04.13.06.12.16;	author millert;	state Exp;
branches;
next	1.3;

1.3
date	2000.02.26.22.53.16;	author millert;	state Exp;
branches;
next	1.2;

1.2
date	2000.02.25.19.09.48;	author deraadt;	state Exp;
branches;
next	1.1;

1.1
date	2000.02.25.19.08.49;	author deraadt;	state Exp;
branches;
next	;


desc
@@


1.84
log
@like the sparc port, ancient wisdom is ancient. consign to the archives.
ok beck
@
text
@/*	$OpenBSD: main.c,v 1.83 2016/07/14 08:31:18 semarie Exp $	*/

/* This file is in the public domain. */

/*
 *	Mainline.
 */

#include <sys/queue.h>
#include <err.h>
#include <limits.h>
#include <locale.h>
#include <signal.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>

#include "def.h"
#include "kbd.h"
#include "funmap.h"
#include "macro.h"

int		 thisflag;			/* flags, this command	*/
int		 lastflag;			/* flags, last command	*/
int		 curgoal;			/* goal column		*/
int		 startrow;			/* row to start		*/
int		 doaudiblebell;			/* audible bell toggle	*/
int		 dovisiblebell;			/* visible bell toggle	*/
int		 dblspace;			/* sentence end #spaces	*/
struct buffer	*curbp;				/* current buffer	*/
struct buffer	*bheadp;			/* BUFFER list head	*/
struct mgwin	*curwp;				/* current window	*/
struct mgwin	*wheadp;			/* MGWIN listhead	*/
char		 pat[NPAT];			/* pattern		*/

static void	 edinit(struct buffer *);
static __dead void usage(void);

extern char	*__progname;
extern void     closetags(void);

static __dead void
usage()
{
	fprintf(stderr, "usage: %s [-nR] [-f mode] [+number] [file ...]\n",
	    __progname);
	exit(1);
}

int
main(int argc, char **argv)
{
	char		*cp, *init_fcn_name = NULL;
	PF		 init_fcn = NULL;
	int	 	 o, i, nfiles;
	int	  	 nobackups = 0, bro = 0;
	struct buffer	*bp = NULL;

	if (pledge("stdio rpath wpath cpath fattr chown getpw tty proc exec",
	    NULL) == -1)
		err(1, "pledge");

	while ((o = getopt(argc, argv, "nRf:")) != -1)
		switch (o) {
		case 'R':
			bro = 1;
			break;
		case 'n':
			nobackups = 1;
			break;
		case 'f':
			if (init_fcn_name != NULL)
				errx(1, "cannot specify more than one "
				    "initial function");
			init_fcn_name = optarg;
			break;
		default:
			usage();
		}
	argc -= optind;
	argv += optind;

	setlocale(LC_CTYPE, "");

	maps_init();		/* Keymaps and modes.		*/
	funmap_init();		/* Functions.			*/

	/*
	 * This is where we initialize standalone extensions that should
	 * be loaded dynamically sometime in the future.
	 */
	{
		extern void grep_init(void);
		extern void cmode_init(void);
		extern void dired_init(void);

		dired_init();
		grep_init();
		cmode_init();
	}

	if (init_fcn_name &&
	    (init_fcn = name_function(init_fcn_name)) == NULL)
		errx(1, "Unknown function `%s'", init_fcn_name);

	vtinit();		/* Virtual terminal.		*/
	dirinit();		/* Get current directory.	*/
	edinit(bp);		/* Buffers, windows.		*/
	ttykeymapinit();	/* Symbols, bindings.		*/
	bellinit();		/* Audible and visible bell.	*/
	dblspace = 1;		/* two spaces for sentence end. */

	/*
	 * doing update() before reading files causes the error messages from
	 * the file I/O show up on the screen.	(and also an extra display of
	 * the mode line if there are files specified on the command line.)
	 */
	update(CMODE);

	/* user startup file. */
	if ((cp = startupfile(NULL)) != NULL)
		(void)load(cp);

	/*
	 * Now ensure any default buffer modes from the startup file are
	 * given to any files opened when parsing the startup file.
	 * Note *scratch* will also be updated.
	 */
	for (bp = bheadp; bp != NULL; bp = bp->b_bufp) {
		bp->b_flag = defb_flag;
		for (i = 0; i <= defb_nmodes; i++) {
                	bp->b_modes[i] = defb_modes[i];
        	}
	}

	/* Force FFOTHARG=1 so that this mode is enabled, not simply toggled */
	if (init_fcn)
		init_fcn(FFOTHARG, 1);

	if (nobackups)
		makebkfile(FFARG, 0);

	for (nfiles = 0, i = 0; i < argc; i++) {
		if (argv[i][0] == '+' && strlen(argv[i]) >= 2) {
			long long lval;
			const char *errstr;

			lval = strtonum(&argv[i][1], INT_MIN, INT_MAX, &errstr);
			if (argv[i][1] == '\0' || errstr != NULL)
				goto notnum;
			startrow = lval;
		} else {
notnum:
			cp = adjustname(argv[i], FALSE);
			if (cp != NULL) {
				if (nfiles == 1)
					splitwind(0, 1);

				if (fisdir(cp) == TRUE) {
					(void)do_dired(cp);
					continue;
				}
				if ((curbp = findbuffer(cp)) == NULL) {
					vttidy();
					errx(1, "Can't find current buffer!");
				}
				(void)showbuffer(curbp, curwp, 0);
				if (readin(cp) != TRUE)
					killbuffer(curbp);
				else {
					/* Ensure enabled, not just toggled */
					if (init_fcn_name)
						init_fcn(FFOTHARG, 1);
					nfiles++;
				}
				if (bro)
					curbp->b_flag |= BFREADONLY;
			}
		}
	}

	if (nfiles > 2)
		listbuffers(0, 1);

	/* fake last flags */
	thisflag = 0;
	for (;;) {
		if (epresf == KCLEAR)
			eerase();
		if (epresf == TRUE)
			epresf = KCLEAR;
		if (winch_flag) {
			do_redraw(0, 0, TRUE);
			winch_flag = 0;
		}
		update(CMODE);
		lastflag = thisflag;
		thisflag = 0;

		switch (doin()) {
		case TRUE:
			break;
		case ABORT:
			ewprintf("Quit");
			/* FALLTHRU */
		case FALSE:
		default:
			macrodef = FALSE;
		}
	}
}

/*
 * Initialize default buffer and window. Default buffer is called *scratch*.
 */
static void
edinit(struct buffer *bp)
{
	struct mgwin	*wp;

	bheadp = NULL;
	bp = bfind("*scratch*", TRUE);		/* Text buffer.          */
	if (bp == NULL)
		panic("edinit");

	wp = new_window(bp);
	if (wp == NULL)
		panic("edinit: Out of memory");

	curbp = bp;				/* Current buffer.	 */
	wheadp = wp;
	curwp = wp;
	wp->w_wndp = NULL;			/* Initialize window.	 */
	wp->w_linep = wp->w_dotp = bp->b_headp;
	wp->w_ntrows = nrow - 2;		/* 2 = mode, echo.	 */
	wp->w_rflag = WFMODE | WFFULL;		/* Full.		 */
}

/*
 * Quit command.  If an argument, always quit.  Otherwise confirm if a buffer
 * has been changed and not written out.  Normally bound to "C-X C-C".
 */
/* ARGSUSED */
int
quit(int f, int n)
{
	int	 s;

	if ((s = anycb(FALSE)) == ABORT)
		return (ABORT);
	if (s == FIOERR || s == UERROR)
		return (FALSE);
	if (s == FALSE
	    || eyesno("Modified buffers exist; really exit") == TRUE) {
		vttidy();
		closetags();
		exit(0);
	}
	return (TRUE);
}

/*
 * User abort.  Should be called by any input routine that sees a C-g to abort
 * whatever C-g is aborting these days. Currently does nothing.
 */
/* ARGSUSED */
int
ctrlg(int f, int n)
{
	return (ABORT);
}
@


1.83
log
@make several program to use "chown" promise.

it allows chown(2) call to change the user or group on a file.

- usr.bin/compress : aka gzip
- usr.bin/mg : open a file for writing
- usr.bin/sed : inplace editing
- usr.bin/sort : if outfile equals one of the input files

ok deraadt@@ tb@@

(and a reminder from Remi Locherer)

warning: in order to use it, you must have a recent kernel with the new
promise.
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.82 2016/04/14 17:05:32 lum Exp $	*/
a94 1
		extern void theo_init(void);
a99 1
		theo_init();
@


1.82
log
@Add 'sentence-end-double-space'.

If you prefer "lighter" punctuation and one space between sentences,
for example:

Mr and Mrs Jones are from the UK. They arrived today.

over more liberal use of full stops and double spaces between
sentences:

Mr. and Mrs. Jones are from the U.K.  They arrived today.

then toggling 'sentence-end-double-space' will make mg's
fill-paragraph function format text using one space instead of two
(the default) between sentences. However, be careful, should you have
a double spaced document and accidentally "format" it to have single
spaces, then you may have a problem. mg won't be able to revert the
formatting for you (unless you have a previous version of the text in
the "undo" history, or are using mg's backup facility and haven't
opened and saved multiple times!).

Comments from schwarze@@
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.81 2015/12/24 09:07:47 lum Exp $	*/
d60 2
a61 1
	if (pledge("stdio rpath wpath cpath fattr getpw tty proc exec", NULL) == -1)
@


1.81
log
@Add -R option to allow files specified on the command line to be
opened read-only. ok jasper@@ phessler@@ and man page advice from jmc@@
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.80 2015/11/19 19:30:44 bentley Exp $	*/
d30 1
d113 1
@


1.80
log
@"tty proc exec", not "proc exec tty"
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.79 2015/11/11 15:37:34 deraadt Exp $	*/
d45 1
a45 1
	fprintf(stderr, "usage: %s [-n] [-f mode] [+number] [file ...]\n",
d56 1
a56 1
	int	  	 nobackups = 0;
d62 1
a62 1
	while ((o = getopt(argc, argv, "nf:")) != -1)
d64 3
d176 2
@


1.79
log
@needs pledge "getpw" also
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.78 2015/11/11 15:10:20 deraadt Exp $	*/
d59 1
a59 1
	if (pledge("stdio rpath wpath cpath fattr getpw proc exec tty", NULL) == -1)
@


1.78
log
@pledge "stdio rpath wpath cpath fattr proc exec tty" seems to work.
there are a few system, popen, fork...
ok florian
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.77 2015/11/08 19:31:57 jasper Exp $	*/
d59 1
a59 1
	if (pledge("stdio rpath wpath cpath fattr proc exec tty", NULL) == -1)
@


1.77
log
@whitespace
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.76 2015/10/29 19:46:47 lum Exp $	*/
d58 3
@


1.76
log
@Fix opening dired from the command line. Incorrect cursor placement
and make the error more useful when there is a problem opening a
directory. Reported by and ok jasper@@
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.75 2015/03/19 21:22:15 bcallah Exp $	*/
d118 1
a118 1
	/* 
d155 1
a155 1
					continue;					
@


1.75
log
@Clean up the includes in mg.
This does the following:
Moves all POSIX headers from sysdef.h into the individual .c files so that
each file now only includes what it needs. All headers are properly sorted.
Moves the remainder of sysdef.h to other files (mostly def.h) and deletes
sysdef.h now that it's no longer contains anything.
Tweak a comment that references sysdef.h so that it no longer does that.
ok florian@@
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.74 2014/11/16 04:16:41 guenther Exp $	*/
d153 4
@


1.74
log
@Stop using <sys/param.h>; replace MAXPATHLEN with PATH_MAX, stop using MAX(),
and pull in <limits.h> for *_MAX constants.

inspired on a diff from Kamil Rytarowski (n54 (at) gmx.com)
ok bcallah@@
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.73 2014/11/13 21:36:23 florian Exp $	*/
d9 10
a22 4

#include <err.h>
#include <limits.h>
#include <locale.h>
@


1.73
log
@Nuke GOOD define and just exit(0) on success. While there remove
unused MALLOCROUND define.
No binary change.
From Martin Natano (natano AT natano DOT net).
OK lum@@
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.72 2014/03/22 11:05:37 lum Exp $	*/
d15 1
@


1.72
log
@donebell is no longer required.
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.71 2013/05/31 18:03:44 lum Exp $	*/
d238 1
a238 1
		exit(GOOD);
@


1.71
log
@Make the system bell toggleable via 'audible-bell', and if switched
off, make available an alternative 'visible-bell'.

ok florian@@ jasper@@ Feedback Sunil Nimmagadda.
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.70 2012/12/28 16:12:50 naddy Exp $	*/
a22 1
int		 donebell;			/* done't wring bell	*/
a188 2
			if (!donebell)
				dobeep();
a190 1
		donebell = 0;
@


1.70
log
@Respect locale for ctype purposes, e.g. display ISO Latin 1 characters;
ok stsp@@ reyk@@

Document that multi-byte character sets are not supported; from stsp@@
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.69 2012/08/31 18:06:42 lum Exp $	*/
d21 3
d99 1
d106 1
a106 1
	update();
d178 1
a178 1
		update();
d190 2
a191 1
			ttbeep();
d194 1
@


1.69
log
@Allow an error message for a filename that is too long to be seen and
let the error stop mg exiting when C-x C-c is called.
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.68 2012/08/30 06:09:12 lum Exp $	*/
d15 1
d66 2
@


1.68
log
@This diff allows the user to decide what to do with buffers that
experience write errors during C-x C-c (exiting mg). Emacs stops the
exiting process when it encounters problem buffers and lets the user
decide what to do, currently mg continues exiting and the contents of
these buffers are lost. This diff bring mg more into line with emacs.

Review and observations from Sunil Nimmagadda.
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.67 2012/05/29 06:08:48 lum Exp $	*/
d227 1
a227 1
	if (s == FIOERR)
@


1.67
log
@There is no other reference to SYSCLEANUP in the src tree. Remove.
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.66 2012/05/29 05:52:46 lum Exp $	*/
d227 2
@


1.66
log
@There is no need to use an *init* buffer if we go back and update
opened file(s)/*scratch* with default modes after they are open.
Also, pass buffer (bp) to edinit(), this fixes theo mode from the
command line (mg -f theo).
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.65 2012/05/25 05:05:48 lum Exp $	*/
a229 3
#ifdef SYSCLEANUP
		SYSCLEANUP;
#endif	/* SYSCLEANUP */
@


1.65
log
@Prepare mg buffers before startup file is parsed so multiple files can
be opened via the startup file. Having find-file, insert-file etc.. in
the startup file now work as you would expect.

Reviewed by Sunil Nimmagadda.
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.64 2012/04/12 04:47:59 lum Exp $	*/
d26 1
a26 1
static void	 edinit(PF);
d43 5
a47 5
	char	*cp, *init_fcn_name = NULL;
	PF	 init_fcn = NULL;
	int	 o, i, nfiles;
	int	 nobackups = 0;
	struct buffer *bp;
d91 1
a91 1
	edinit(init_fcn);	/* Buffers, windows.		*/
a100 7
	/*
	 * Create scratch buffer now, killing old *init* buffer.
	 * This causes *scratch* to be created and made curbp.
	 */
	if ((bp = bfind("*init*", FALSE)) != NULL)
		killbuffer(bp);

d190 1
a190 3
 * Initialize default buffer and window.
 * Initially, buffer is named *init*. This is changed later
 * to *scratch* after the startup files are read.
d193 1
a193 1
edinit(PF init_fcn)
a194 1
	struct buffer	*bp;
d198 1
a198 1
	bp = bfind("*init*", TRUE);		/* Text buffer.		 */
d204 1
a204 1
		panic("Out of memory");
d206 1
a206 1
	curbp = bp;				/* Current ones.	 */
@


1.64
log
@Remove the conditional directives NO_MACRO and NO_STARTUP.
They have not compiled for numerous years.
ok kjell@@ millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.63 2012/01/26 04:14:11 lum Exp $	*/
a100 4
	/* user startup file */
	if ((cp = startupfile(NULL)) != NULL)
		(void)load(cp);

d103 1
a103 3
	 * This causes *scratch* to be created and made curbp,
	 * ensuring default modes are inherited from the startup
	 * file correctly
a104 1

d107 16
@


1.63
log
@Tidy window and buffer NULL checks.

Reveiwed by Sunil Nimmagadda.
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.62 2011/11/28 04:41:39 lum Exp $	*/
a11 2

#ifndef NO_MACRO
a12 1
#endif	/* NO_MACRO */
a100 1
#ifndef NO_STARTUP
a103 1
#endif	/* !NO_STARTUP */
a181 1
#ifndef NO_MACRO
a182 1
#endif	/* !NO_MACRO */
@


1.62
log
@Add some ctags support to mg. From Sunil Nimmagadda.

Man page review and suggestions from jmc@@

Revewied and tested by myself, and ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.61 2009/06/04 02:23:37 kjell Exp $	*/
d207 3
d213 1
a213 2
	if (bp == NULL || wp == NULL)
		panic("edinit");
@


1.61
log
@Rename w_flag to w_rflag. This is not a general purpose
flag: it is for redisplay options only. I need an additional all-purpose
flag, so renaming removes the desire to wrongly overload the existing one.

Turdshine. No functional chage.
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.60 2008/06/13 18:51:02 kjell Exp $	*/
d33 1
d239 1
@


1.60
log
@Remove mail-mode. It was a buggy reimplementation of auto-fill-mode.
If you use this, change your habits (and .mg) to use the following
commands instead:

mail-mode => auto-fill-mode
mail-set-margin => set-fill-column

ok henning@@. Will also "fix" debian bug #460189
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.59 2008/06/13 18:41:57 kjell Exp $	*/
d217 1
a217 1
	wp->w_flag = WFMODE | WFFULL;		/* Full.		 */
@


1.59
log
@Fix autoexec file handling.
Two issues: *scratch* did not inherit any modes set from
~/.mg, as it was created too early. Switch to using *init* buffer
until after autoexec, then kill it and inherit correct *scratch*.
Second, -f should force the mode. Not toggle it.
ok phessler@@
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.58 2008/06/12 01:58:44 kjell Exp $	*/
a77 1
		extern void mail_init(void);
a83 1
		mail_init();
@


1.58
log
@Introduce a basic c-mode to mg.

The intent of this mode is NOT to copy emacs's monster cc-mode.
It is intended to handle basic KNF-format C, assisting
with indentation (to catch obvious typos), and strip
trailing whitespace. It is NOT enabled unless you ask for it (c-mode).

Basically, tab on start-of-line whitespace acts like tab.
Otherwise, tab indents.

Please try it out and let me know where it falls down.

Feedback Reyk, phessler. "hack in tree" from henning, theo
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.57 2008/05/29 19:58:15 sobrado Exp $	*/
d49 1
d111 14
d152 1
d154 1
a154 1
						init_fcn(0, 1);
d197 2
d207 1
a207 1
	bp = bfind("*scratch*", TRUE);		/* Text buffer.		 */
a219 3

	if (init_fcn)
		init_fcn(0, 1);
@


1.57
log
@add a detailed synopsis to mg(1); synchronize with usage.

tweaks by jmc@@

ok jmc@@
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.56 2007/02/20 04:39:45 cloder Exp $	*/
d78 1
d85 1
@


1.56
log
@Remove useless -h option (if you don't know the synopsis, how do you know
-h?). OK deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.55 2006/11/19 16:51:19 deraadt Exp $	*/
d37 1
a37 1
	fprintf(stderr, "usage: %s [+line] [-n] [-f mode] [file ...]\n",
@


1.55
log
@spacing
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.54 2006/07/25 08:22:32 kjell Exp $	*/
d37 1
a37 1
	fprintf(stderr, "usage: %s [+line] [-hn] [-f mode] [file ...]\n",
d50 1
a50 1
	while ((o = getopt(argc, argv, "hnf:")) != -1)
a60 2
		case 'h':
			/* FALLTHRU */
@


1.54
log
@Rename the header line of a buffer to b_headp, from the remarkably
unintuitive b_linep. No binary change.
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.53 2006/07/17 14:11:55 kjell Exp $	*/
d23 1
a23 1
struct buffer 	*curbp;				/* current buffer	*/
@


1.53
log
@Better usage() wording. Add -h to mean same. Some whitespace clean
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.52 2006/06/01 05:34:52 jason Exp $	*/
d199 1
a199 1
	wp->w_linep = wp->w_dotp = bp->b_linep;
@


1.52
log
@make // /~ path rewriting optional in adjustname() and use it everywhere
except for the command line specified files.  ok kjell,cloder
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.51 2006/05/28 23:30:16 kjell Exp $	*/
d23 4
a26 4
struct buffer		*curbp;				/* current buffer	*/
struct buffer		*bheadp;			/* BUFFER list head	*/
struct mgwin		*curwp;				/* current window	*/
struct mgwin		*wheadp;			/* MGWIN listhead	*/
d30 11
d50 1
a50 1
	while ((o = getopt(argc, argv, "nf:")) != -1)
d61 2
d64 1
a64 1
			errx(1, "usage: mg [options] [file ...]");
@


1.51
log
@Make Window Flags more mnemonic (and less dumb); i.e.
WFHARD -> WFFULL (Redraw full window)
WFFORCE -> WFFRAME (Reframe window).
No binary change
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.50 2006/04/03 02:43:22 kjell Exp $	*/
d111 1
a111 1
			cp = adjustname(argv[i]);
@


1.50
log
@fixed "text in message line would get stuck there" issue.
feedback from Philip Guenther and Han Boetes
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.49 2006/02/25 14:40:16 otto Exp $	*/
d188 1
a188 1
	wp->w_flag = WFMODE | WFHARD;		/* Full.		 */
@


1.49
log
@Fix a coredump occurring when the terminal is resized while mg is
suspended. Problem reported and fixed tested by reyk@@; tweak by
kjell@@; ok kjell@@
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.48 2005/12/13 06:01:27 kjell Exp $	*/
d138 1
a138 2
#ifndef NO_DPROMPT
		if (epresf == KPROMPT)
d140 2
a141 1
#endif	/* !NO_DPROMPT */
@


1.48
log
@More name-clash delinting
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.47 2005/11/20 18:47:11 kjell Exp $	*/
d143 1
a143 1
			redraw(0, 0);
@


1.47
log
@#ifdef NO_DIR can go too. From Han Boetes.
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.46 2005/11/20 03:24:17 deraadt Exp $	*/
d143 1
a143 1
			refresh(0, 0);
d155 1
a155 1
			/* and fall through */
@


1.46
log
@toast NO_DIRED #ifdef; ok kjell
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.45 2005/11/18 20:56:53 deraadt Exp $	*/
a79 1
#ifndef NO_DIR
a80 1
#endif	/* !NO_DIR */
@


1.45
log
@greedy use of typedef struct was making code harder to read; ok kjell cloder
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.44 2005/10/13 20:43:17 deraadt Exp $	*/
a66 1
#ifndef NO_DIRED
a69 1
#endif /* !NO_DIRED */
@


1.44
log
@toast unused variable
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.43 2005/10/13 20:41:09 deraadt Exp $	*/
d23 4
a26 4
BUFFER		*curbp;				/* current buffer	*/
BUFFER		*bheadp;			/* BUFFER list head	*/
MGWIN		*curwp;				/* current window	*/
MGWIN		*wheadp;			/* MGWIN listhead	*/
d176 2
a177 2
	BUFFER	*bp;
	MGWIN	*wp;
@


1.43
log
@use strtonum() correctly
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.42 2005/10/13 05:47:45 kjell Exp $	*/
d36 1
a36 1
	int	 o, i, nfiles, status;
d125 1
a125 1
				if ((status = readin(cp)) != TRUE)
@


1.42
log
@Fix dired mode. Make deletions work, and keystrokes match emacs.
* dired-other-window should default to current buffer's path.
* Remove redundant code (from Han Boetes)
* Move initialization (and since we're here, fix mail-mode initialization
  too)
* Remove redundant keymap in dired.c, and replace it with
  the better one that was being ignored in keymap.c.
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.41 2005/08/09 00:53:48 kjell Exp $	*/
d106 1
a106 1
			int lval;
@


1.41
log
@Clean up eread handling in mg. (basically, fallout from the 'enter often
means abort' behaviour added during the hackathon). Eliminates
redundant ereply function, fixes miscellaneous cores when aborting,
and move a number of assumed pathnames into the prompt text, since
they are used there anyway. All changes consistent with emacs behavior

ok beck@@ many, many moons ago.
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.40 2005/06/14 18:14:40 kjell Exp $	*/
d66 3
d70 2
@


1.40
log
@Add explicit public domain notices to all public domain files.
ok millert@@, deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.39 2005/04/21 19:16:21 beck Exp $	*/
d206 1
a206 1
	    || eyesno("Some modified buffers exist, really exit") == TRUE) {
@


1.39
log
@correct strlcpy abuse, and always check for NULL return from find_buffer
ok cloder@@, feedback from many
@
text
@d1 3
a3 1
/*	$OpenBSD: main.c,v 1.38 2005/04/03 02:09:28 db Exp $	*/
@


1.38
log
@This is a no binary change which does:

- spelling, punctuation fixes
- variable declaration lineup
- use parentheses for return and sizeof
- K&R function declarations -> ANSI
- other minor code beautification

ok henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.37 2005/03/12 10:36:13 jmc Exp $	*/
d113 4
a116 1
				curbp = findbuffer(cp);
@


1.37
log
@sync usage() w/ synopsis;
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.36 2005/03/12 06:16:07 deraadt Exp $	*/
d7 3
a9 3
#include	"def.h"
#include	"kbd.h"
#include	"funmap.h"
d12 1
a12 1
#include	"macro.h"
d22 1
a22 1
BUFFER		*bheadp;			/* BUFFER list head */
d33 3
a35 3
	PF init_fcn = NULL;
	int o, i, nfiles, status;
	int nobackups = 0;
d110 1
a110 1
				if (nfiles == 1) {
d112 1
a112 1
				}
d115 1
a115 1
				if ((status = readin(cp)) != TRUE) {
d117 1
a117 1
				} else {
d181 2
a182 2
	wp->w_ntrows = nrow - 2;		/* 2 = mode, echo. */
	wp->w_flag = WFMODE | WFHARD;		/* Full. */
d199 1
a199 1
		return ABORT;
d208 1
a208 1
	return TRUE;
@


1.36
log
@spacing
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.35 2005/03/10 16:47:33 henning Exp $	*/
d49 1
a49 1
			errx(1, "usage: mg [-f <mode>] [files...]");
@


1.35
log
@add -n command line switch to disable backup file generation, handy
when you use mg for your mail from within mutt etc
from PR3930, Carson Harding <harding@@motd.ca>, Thanks!
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.34 2005/03/09 16:20:48 jfb Exp $	*/
d20 1
a20 1
int		 startrow;			/* row to start         */
@


1.34
log
@fix mg's behaviour with regards to files on which we do not have
write access.  diff originally from vincent@@ and forgotten for
a while.

ok rohee@@, "toss it in, i'll bitch if it doesn't work" henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.33 2004/07/19 12:14:08 vincent Exp $	*/
d35 1
d37 1
a37 1
	while ((o = getopt(argc, argv, "f:")) != -1)
d39 3
d93 3
@


1.33
log
@correct error checking for strtonum, from mjc@@bitz.ca
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.32 2004/07/11 23:46:17 vincent Exp $	*/
d34 1
a34 1
	int o, i, nfiles;
d108 7
a114 4
				(void)readin(cp);
				if (init_fcn_name)
					init_fcn(0, 1);
				nfiles++;
@


1.32
log
@oops

I just realized I gave a really bad advise to pval, negative goto-line are
entirely valid (mean # of lines from end of file)

go back to INT_MIN as the lower bound
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.31 2004/07/11 20:37:15 pvalchev Exp $	*/
d96 1
a96 1
			if (argv[i][1] == '\0' || *errstr != '\0')
@


1.31
log
@change lower bound to 0, row shouldn't be negative; suggested & ok vincent
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.30 2004/07/11 20:36:32 pvalchev Exp $	*/
d95 1
a95 1
			lval = strtonum(&argv[i][1], 0, INT_MAX, &errstr);
@


1.30
log
@use strtonum instead of strtoul and don't abuse a long for int
functionality; ok vincent
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.29 2004/02/02 20:21:14 vincent Exp $	*/
d95 1
a95 1
			lval = strtonum(&argv[i][1], INT_MIN, INT_MAX, &errstr);
@


1.29
log
@be just like gnu emacs when more than 2 files are specified on the command
line: create a buffer list window
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.28 2004/01/27 23:43:37 vincent Exp $	*/
d92 2
a93 2
			long lval;
			char *ep;
d95 2
a96 3
			errno = 0;
			lval = strtoul(&argv[i][1], &ep, 10);
			if (argv[i][1] == '\0' || *ep != '\0')
d98 1
a98 5
			if ((errno == ERANGE &&
			    (lval == LONG_MAX || lval == LONG_MIN)) ||
			    (lval > INT_MAX || lval < INT_MIN))
				goto notnum;
			startrow = (int)lval;
@


1.28
log
@make mail-mode more intelligent on middle-of-line insertions, and add a
comment to change the wrapping column. (mail-set-margin)

tested by henning and phessler, thanks!
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.27 2003/12/04 01:52:01 vincent Exp $	*/
d22 1
a22 1
BUFFER		*bheadp;			/* BUFFER listhead	*/
d108 1
a108 1
				if (nfiles > 0 && nfiles < 3)
d110 1
d120 3
@


1.27
log
@split the screen in multiple windows when more than one files are given
on the command line

ok deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.26 2003/10/27 11:21:12 vincent Exp $	*/
d172 2
a173 2
	wp->w_ntrows = nrow - 2;		/* 2 = mode, echo.	 */
	wp->w_flag = WFMODE | WFHARD;		/* Full.		 */
@


1.26
log
@fix crash on startup by using the good allocation routine in edinit()

spotted and ok by henning
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.25 2003/06/26 23:04:10 vincent Exp $	*/
d34 1
a34 1
	int o;
d89 3
a91 2
	while (argc > 0) {
		if (argv[0][0] == '+' && strlen(argv[0]) >= 2) {
d96 2
a97 2
			lval = strtoul(&argv[0][1], &ep, 10);
			if (argv[0][1] == '\0' || *ep != '\0')
d106 1
a106 1
			cp = adjustname(*argv);
d108 2
d115 1
a117 2
		argc--;
		argv++;
@


1.25
log
@protos

ok deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.24 2003/05/05 11:12:07 vincent Exp $	*/
d160 1
a160 1
	wp = (MGWIN *)malloc(sizeof(MGWIN));	/* Initial window.	 */
a168 2
	wp->w_bufp = bp;
	bp->b_nwnd = 1;				/* Displayed.		 */
a169 4
	wp->w_doto = 0;
	wp->w_markp = NULL;
	wp->w_marko = 0;
	wp->w_toprow = 0;
a170 1
	wp->w_force = 0;
@


1.24
log
@add a mail-mode, to do automatic line-wrapping.

(at the same time, change the command line parsing to support a
 -f <mode> that is slightly different from the one in gnu emacs,
we apply it to all buffers created from command line arguments,
so you can use "mg -f mail-mode" as your editor. manpage change
coming soon)

ok henning
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.23 2003/01/06 17:04:09 deraadt Exp $	*/
d111 1
a111 1
					init_fcn();
d181 1
a181 1
		init_fcn();
@


1.23
log
@support +number; rewritten from buggy code by mjc@@bitz.ca, vincent ok
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.22 2002/07/25 16:37:54 vincent Exp $	*/
d15 2
d27 1
a27 1
static void	 edinit(void);
d32 17
a48 1
	char	*cp;
a49 5
	vtinit();		/* Virtual terminal.		*/
#ifndef NO_DIR
	dirinit();		/* Get current directory.	*/
#endif	/* !NO_DIR */
	edinit();		/* Buffers, windows.		*/
a51 1
	ttykeymapinit();	/* Symbols, bindings.		*/
d63 1
d66 11
d89 1
a89 3
	while (--argc > 0) {
		argv++;

d103 1
a103 2
			continue;
		}
d105 8
a112 6

		cp = adjustname(*argv);
		if (cp != NULL) {
			curbp = findbuffer(cp);
			(void)showbuffer(curbp, curwp, 0);
			(void)readin(cp);
d114 2
d153 1
a153 1
edinit(void)
d179 3
d215 1
a215 1
	return ABORT;
@


1.22
log
@ replace the ugly and buggy adjustname function by a simple one using
simple APIs. makes mg not crash with 65k filenames...

 ok art@@
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.21 2002/07/03 03:47:59 vincent Exp $	*/
d18 1
d66 20
a85 1
		cp = adjustname(*++argv);
@


1.21
log
@ a few missing tests for malloc()'s return value.

 ok art@@
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.20 2002/07/01 14:33:44 vincent Exp $	*/
d66 5
a70 3
		curbp = findbuffer(cp);
		(void)showbuffer(curbp, curwp, 0);
		(void)readin(cp);
@


1.20
log
@KNF + ansi; from zyrnix (only the easy part of his diffs)
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.19 2002/03/18 01:45:55 vincent Exp $	*/
d114 2
@


1.19
log
@ Enter the new undo code.  it is still disabled since it has bugs, but it's
somewhat more useful....

 ok millert@@ + no objections on ICB
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.18 2002/02/21 15:27:29 deraadt Exp $	*/
d106 1
a106 1
edinit()
d138 1
a138 2
quit(f, n)
	int f, n;
d161 1
a161 2
ctrlg(f, n)
	int f, n;
@


1.18
log
@KNF
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.17 2002/02/21 00:02:04 deraadt Exp $	*/
d27 1
a27 3
main(argc, argv)
	int	argc;
	char	**argv;
d39 1
a39 2
	undo_init();
	
@


1.17
log
@signal-safe window size changing
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.16 2002/02/20 22:30:54 vincent Exp $	*/
a32 3
#ifdef SYSINIT
	SYSINIT;		/* System dependent.		*/
#endif	/* SYSINIT */
@


1.16
log
@ Add undo code to mg.

 needs further hacking.

 ok `whole bunch of people on icb'@@
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.15 2002/02/16 21:27:49 millert Exp $	*/
d84 4
@


1.15
log
@Part one of userland __P removal.  Done with a simple regexp with some minor hand editing to make comments line up correctly.  Another pass is forthcoming that handles the cases that could not be done automatically.
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.14 2001/06/23 04:22:44 art Exp $	*/
d44 2
a45 1

@


1.14
log
@Add "M-x theo". Just like "M-x doctor" in emacs... Well, almost.

More beer!
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.13 2001/05/24 10:58:34 art Exp $	*/
d24 1
a24 1
static void	 edinit		__P((void));
@


1.13
log
@Add a compile/grep/id-utils mode.

The only pollution this code introduces in the rest of thed code is a call to
an init function in main(). In the future we might want to load extensions
like this dynamically.

Of course I did the test compile in the compile mode.
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.12 2001/05/24 10:43:19 art Exp $	*/
d51 1
d54 1
@


1.12
log
@Make the keymap/mode table growable in runtime.
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.11 2001/05/24 09:47:34 art Exp $	*/
d44 10
@


1.11
log
@Break out function -> name mappings to an own file.
Add a possibility to dynamically extend the function table.
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.10 2001/05/24 03:05:24 mickey Exp $	*/
d8 1
d41 1
@


1.10
log
@spaces
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.9 2001/05/23 23:29:48 mickey Exp $	*/
d8 1
d40 1
@


1.9
log
@cinfo is const, keyname() and findbind() take buffer size to use strlcpy vs cpy+len
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.8 2001/05/23 22:36:15 art Exp $	*/
d26 2
a27 2
	int    argc;
	char **argv;
d142 1
a142 1
 * User abort.  Should be called by any input routine that sees a C-g to abort 
@


1.8
log
@Get rid of unnecessary casts of NULL.
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.7 2001/05/23 22:20:35 art Exp $	*/
a63 1
		*(promptp = prompt) = '\0';
@


1.7
log
@remove VOID. We're way beyond the point where this could build with an
ancient compiler.
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.6 2001/01/29 01:58:08 niklas Exp $	*/
d19 1
a19 1
MGWIN		*wheadp = (MGWIN *)NULL;	/* MGWIN listhead	*/
d50 1
a50 1
	if ((cp = startupfile((char *)NULL)) != NULL)
@


1.6
log
@$OpenBSD$
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d22 1
a22 1
static VOID	 edinit		__P((VOID));
d51 1
a51 1
		(VOID)load(cp);
d56 2
a57 2
		(VOID)showbuffer(curbp, curwp, 0);
		(VOID)readin(cp);
d91 1
a91 1
static VOID
@


1.5
log
@More -Wall anmd KNF, from op2@@tomahawk.SQUiSH.org
@
text
@d1 2
@


1.4
log
@The start of KNF + -Wall.  The code has been run through indent but
needs hand fixup.  I stopped at keymap.c...
@
text
@d2 1
a2 1
 *		Mainline
d4 1
d6 1
d9 1
a9 1
#endif
d11 8
a18 11
int             thisflag;	/* Flags, this command		 */
int             lastflag;	/* Flags, last command		 */
int             curgoal;	/* Goal column			 */
BUFFER         *curbp;		/* Current buffer		 */
MGWIN          *curwp;		/* Current window		 */
BUFFER         *bheadp;		/* BUFFER listhead		 */
MGWIN          *wheadp = (MGWIN *) NULL;	/* MGWIN listhead		 */
char            pat[NPAT];	/* Pattern			 */
#ifndef NO_DPROMPT
extern char     prompt[], *promptp;	/* delayed prompting		 */
#endif
d20 1
a20 1
static VOID     edinit();
d24 2
a25 2
	int             argc;
	char          **argv;
d27 1
a27 6
#ifndef NO_STARTUP
	char           *startupfile();
#endif
	char           *cp;
	VOID            vtinit(), makename(), eerase();
	BUFFER         *findbuffer();
d30 3
a32 3
	SYSINIT;		/* system dependent.	 */
#endif
	vtinit();		/* Virtual terminal.	 */
d34 5
a38 4
	dirinit();		/* Get current directory */
#endif
	edinit();		/* Buffers, windows.	 */
	ttykeymapinit();	/* Symbols, bindings.	 */
d45 6
a50 4
#ifndef NO_STARTUP		/* User startup file.	 */
	if ((cp = startupfile((char *) NULL)) != NULL)
		(VOID) load(cp);
#endif
d54 2
a55 2
		(VOID) showbuffer(curbp, curwp, 0);
		(VOID) readin(cp);
d57 3
a59 1
	thisflag = 0;		/* Fake last flags.	 */
d65 1
a65 1
#endif
d69 1
d74 2
a75 1
			ewprintf("Quit");	/* and fall through	 */
d81 1
a81 1
#endif
d89 1
a89 1
static          VOID
d92 2
a93 2
	register BUFFER *bp;
	register MGWIN *wp;
d96 2
a97 2
	bp = bfind("*scratch*", TRUE);	/* Text buffer.		 */
	wp = (MGWIN *) malloc(sizeof(MGWIN));	/* Initial window.	 */
d100 1
a100 1
	curbp = bp;		/* Current ones.	 */
d103 1
a103 1
	wp->w_wndp = NULL;	/* Initialize window.	 */
d105 1
a105 1
	bp->b_nwnd = 1;		/* Displayed.		 */
d111 1
a111 1
	wp->w_ntrows = nrow - 2;/* 2 = mode, echo.	 */
d113 1
a113 1
	wp->w_flag = WFMODE | WFHARD;	/* Full.		 */
d117 2
a118 4
 * Quit command. If an argument, always
 * quit. Otherwise confirm if a buffer has been
 * changed and not written out. Normally bound
 * to "C-X C-C".
d121 1
d123 1
d125 1
a125 2
	register int    s;
	VOID            vttidy();
d132 1
a132 1
#ifdef	SYSCLEANUP
d134 1
a134 1
#endif
d141 2
a142 3
 * User abort. Should be called by any input routine that sees a C-g
 * to abort whatever C-g is aborting these days. Currently does
 * nothing.
@


1.3
log
@change WINDOW -> MGWIN to avoid curses type conflict
convert to terminfo in tty*.c
add support for some keypad function keys (arrows, pgup, pgdown)
@
text
@d9 8
a16 8
int	thisflag;			/* Flags, this command		*/
int	lastflag;			/* Flags, last command		*/
int	curgoal;			/* Goal column			*/
BUFFER	*curbp;				/* Current buffer		*/
MGWIN	*curwp;				/* Current window		*/
BUFFER	*bheadp;			/* BUFFER listhead		*/
MGWIN	*wheadp = (MGWIN *)NULL;	/* MGWIN listhead		*/
char	pat[NPAT];			/* Pattern			*/
d18 1
a18 1
extern char prompt[], *promptp;		/* delayed prompting		*/
d21 1
a21 1
static VOID	edinit();
d25 2
a26 2
int  argc;
char **argv;
d29 1
a29 1
	char	*startupfile();
d31 3
a33 3
	char	*cp;
	VOID	vtinit(), makename(), eerase();
	BUFFER	*findbuffer();
d36 1
a36 1
	SYSINIT;				/* system dependent.	*/
d38 1
a38 1
	vtinit();				/* Virtual terminal.	*/
d40 1
a40 1
	dirinit();				/* Get current directory */
d42 6
a47 5
	edinit();				/* Buffers, windows.	*/
	ttykeymapinit();			/* Symbols, bindings.	*/
	/* doing update() before reading files causes the error messages from
	 * the file I/O show up on the screen.	(and also an extra display
	 * of the mode line if there are files specified on the command line.)
d50 2
a51 2
#ifndef NO_STARTUP				/* User startup file.	*/
	if ((cp = startupfile((char *)NULL)) != NULL)
d60 2
a61 2
	thisflag = 0;				/* Fake last flags.	*/
	for(;;) {
d63 10
a72 8
	    *(promptp = prompt) = '\0';
	    if(epresf == KPROMPT) eerase();
#endif
	    update();
	    lastflag = thisflag;
	    thisflag = 0;
	    switch(doin()) {
		case TRUE: break;
d74 1
a74 1
		    ewprintf("Quit");		/* and fall through	*/
d77 1
a77 1
		    ttbeep();
d79 1
a79 1
		    macrodef = FALSE;
d81 1
a81 1
	    }
d88 3
a90 2
static VOID
edinit() {
d95 5
a99 4
	bp = bfind("*scratch*", TRUE);		/* Text buffer.		*/
	wp = (MGWIN *)malloc(sizeof(MGWIN));	/* Initial window.	*/
	if (bp==NULL || wp==NULL) panic("edinit");
	curbp  = bp;				/* Current ones.	*/
d101 4
a104 4
	curwp  = wp;
	wp->w_wndp  = NULL;			/* Initialize window.	*/
	wp->w_bufp  = bp;
	bp->b_nwnd  = 1;			/* Displayed.		*/
d106 1
a106 1
	wp->w_doto  = 0;
d110 1
a110 1
	wp->w_ntrows = nrow-2;			/* 2 = mode, echo.	*/
d112 1
a112 1
	wp->w_flag  = WFMODE|WFHARD;		/* Full.		*/
d121 1
a121 1
/*ARGSUSED*/
d124 2
a125 2
	register int	s;
	VOID		vttidy();
d127 2
a128 1
	if ((s = anycb(FALSE)) == ABORT) return ABORT;
d130 1
a130 1
	|| eyesno("Some modified buffers exist, really exit") == TRUE) {
d133 1
a133 1
	SYSCLEANUP;
d145 2
a146 1
/*ARGSUSED*/
d148 1
@


1.2
log
@make it minimally compile; millert
@
text
@d13 1
a13 1
WINDOW	*curwp;				/* Current window		*/
d15 1
a15 1
WINDOW	*wheadp = (WINDOW *)NULL;	/* WINDOW listhead		*/
d88 1
a88 1
	register WINDOW *wp;
d92 1
a92 1
	wp = (WINDOW *)malloc(sizeof(WINDOW));	/* Initial window.	*/
@


1.1
log
@initial import of mg2a
@
text
@d23 1
a23 1
VOID
@

