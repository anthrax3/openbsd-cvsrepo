head	1.59;
access;
symbols
	OPENBSD_6_2:1.59.0.4
	OPENBSD_6_2_BASE:1.59
	OPENBSD_6_1:1.58.0.8
	OPENBSD_6_1_BASE:1.58
	OPENBSD_6_0:1.58.0.4
	OPENBSD_6_0_BASE:1.58
	OPENBSD_5_9:1.58.0.2
	OPENBSD_5_9_BASE:1.58
	OPENBSD_5_8:1.56.0.4
	OPENBSD_5_8_BASE:1.56
	OPENBSD_5_7:1.54.0.2
	OPENBSD_5_7_BASE:1.54
	OPENBSD_5_6:1.53.0.4
	OPENBSD_5_6_BASE:1.53
	OPENBSD_5_5:1.52.0.4
	OPENBSD_5_5_BASE:1.52
	OPENBSD_5_4:1.51.0.2
	OPENBSD_5_4_BASE:1.51
	OPENBSD_5_3:1.50.0.10
	OPENBSD_5_3_BASE:1.50
	OPENBSD_5_2:1.50.0.8
	OPENBSD_5_2_BASE:1.50
	OPENBSD_5_1_BASE:1.50
	OPENBSD_5_1:1.50.0.6
	OPENBSD_5_0:1.50.0.4
	OPENBSD_5_0_BASE:1.50
	OPENBSD_4_9:1.50.0.2
	OPENBSD_4_9_BASE:1.50
	OPENBSD_4_8:1.49.0.4
	OPENBSD_4_8_BASE:1.49
	OPENBSD_4_7:1.49.0.2
	OPENBSD_4_7_BASE:1.49
	OPENBSD_4_6:1.48.0.4
	OPENBSD_4_6_BASE:1.48
	OPENBSD_4_5:1.46.0.2
	OPENBSD_4_5_BASE:1.46
	OPENBSD_4_4:1.44.0.8
	OPENBSD_4_4_BASE:1.44
	OPENBSD_4_3:1.44.0.6
	OPENBSD_4_3_BASE:1.44
	OPENBSD_4_2:1.44.0.4
	OPENBSD_4_2_BASE:1.44
	OPENBSD_4_1:1.44.0.2
	OPENBSD_4_1_BASE:1.44
	OPENBSD_4_0:1.42.0.2
	OPENBSD_4_0_BASE:1.42
	OPENBSD_3_9:1.37.0.2
	OPENBSD_3_9_BASE:1.37
	OPENBSD_3_8:1.23.0.2
	OPENBSD_3_8_BASE:1.23
	OPENBSD_3_7:1.21.0.4
	OPENBSD_3_7_BASE:1.21
	OPENBSD_3_6:1.21.0.2
	OPENBSD_3_6_BASE:1.21
	OPENBSD_3_5:1.20.0.2
	OPENBSD_3_5_BASE:1.20
	OPENBSD_3_4:1.18.0.2
	OPENBSD_3_4_BASE:1.18
	OPENBSD_3_3:1.17.0.4
	OPENBSD_3_3_BASE:1.17
	OPENBSD_3_2:1.17.0.2
	OPENBSD_3_2_BASE:1.17
	OPENBSD_3_1:1.16.0.2
	OPENBSD_3_1_BASE:1.16
	OPENBSD_3_0:1.8.0.2
	OPENBSD_3_0_BASE:1.8
	OPENBSD_2_9_BASE:1.5
	OPENBSD_2_9:1.5.0.2
	OPENBSD_2_8:1.4.0.2
	OPENBSD_2_8_BASE:1.4
	OPENBSD_2_7:1.3.0.2
	OPENBSD_2_7_BASE:1.3;
locks; strict;
comment	@ * @;


1.59
date	2017.09.09.13.10.28;	author florian;	state Exp;
branches;
next	1.58;
commitid	X7Opont33G90SURX;

1.58
date	2015.12.11.20.21.23;	author mmcc;	state Exp;
branches;
next	1.57;
commitid	fMxksA90Y2NKlI5v;

1.57
date	2015.09.29.02.07.49;	author guenther;	state Exp;
branches;
next	1.56;
commitid	CahbaEqQk6XXuFul;

1.56
date	2015.06.03.23.40.01;	author bcallah;	state Exp;
branches;
next	1.55;
commitid	CQOgDk07oNMjC1Ge;

1.55
date	2015.03.19.21.22.15;	author bcallah;	state Exp;
branches;
next	1.54;
commitid	GbEBL4CfPvDkB8hj;

1.54
date	2014.11.16.04.16.41;	author guenther;	state Exp;
branches;
next	1.53;
commitid	a9yG0qCw9VEW27qI;

1.53
date	2014.03.20.07.47.29;	author lum;	state Exp;
branches;
next	1.52;

1.52
date	2013.12.23.21.47.32;	author florian;	state Exp;
branches;
next	1.51;

1.51
date	2013.06.01.10.17.01;	author lum;	state Exp;
branches;
next	1.50;

1.50
date	2011.01.18.16.28.00;	author kjell;	state Exp;
branches;
next	1.49;

1.49
date	2009.11.12.16.37.14;	author millert;	state Exp;
branches;
next	1.48;

1.48
date	2009.06.05.18.02.06;	author kjell;	state Exp;
branches;
next	1.47;

1.47
date	2009.06.04.02.23.37;	author kjell;	state Exp;
branches;
next	1.46;

1.46
date	2008.09.15.16.13.35;	author kjell;	state Exp;
branches;
next	1.45;

1.45
date	2008.09.15.16.11.35;	author kjell;	state Exp;
branches;
next	1.44;

1.44
date	2006.12.24.01.20.53;	author kjell;	state Exp;
branches;
next	1.43;

1.43
date	2006.11.17.08.45.31;	author kjell;	state Exp;
branches;
next	1.42;

1.42
date	2006.07.25.08.27.09;	author kjell;	state Exp;
branches;
next	1.41;

1.41
date	2006.07.25.08.22.32;	author kjell;	state Exp;
branches;
next	1.40;

1.40
date	2006.06.01.09.00.50;	author kjell;	state Exp;
branches;
next	1.39;

1.39
date	2006.05.28.23.30.16;	author kjell;	state Exp;
branches;
next	1.38;

1.38
date	2006.05.27.21.20.11;	author kjell;	state Exp;
branches;
next	1.37;

1.37
date	2005.12.20.06.17.36;	author kjell;	state Exp;
branches;
next	1.36;

1.36
date	2005.12.20.05.04.28;	author kjell;	state Exp;
branches;
next	1.35;

1.35
date	2005.12.20.04.58.10;	author kjell;	state Exp;
branches;
next	1.34;

1.34
date	2005.12.13.05.40.33;	author kjell;	state Exp;
branches;
next	1.33;

1.33
date	2005.11.22.05.02.44;	author kjell;	state Exp;
branches;
next	1.32;

1.32
date	2005.11.22.04.38.57;	author kjell;	state Exp;
branches;
next	1.31;

1.31
date	2005.11.21.19.47.23;	author deraadt;	state Exp;
branches;
next	1.30;

1.30
date	2005.11.20.03.24.17;	author deraadt;	state Exp;
branches;
next	1.29;

1.29
date	2005.11.18.23.37.31;	author kjell;	state Exp;
branches;
next	1.28;

1.28
date	2005.11.18.20.56.53;	author deraadt;	state Exp;
branches;
next	1.27;

1.27
date	2005.11.18.17.35.17;	author kjell;	state Exp;
branches;
next	1.26;

1.26
date	2005.11.18.17.19.51;	author kjell;	state Exp;
branches;
next	1.25;

1.25
date	2005.10.13.20.28.49;	author deraadt;	state Exp;
branches;
next	1.24;

1.24
date	2005.10.06.16.48.00;	author kjell;	state Exp;
branches;
next	1.23;

1.23
date	2005.06.14.18.14.40;	author kjell;	state Exp;
branches;
next	1.22;

1.22
date	2005.04.03.02.09.28;	author db;	state Exp;
branches;
next	1.21;

1.21
date	2004.07.09.13.50.40;	author vincent;	state Exp;
branches;
next	1.20;

1.20
date	2004.01.27.23.43.37;	author vincent;	state Exp;
branches;
next	1.19;

1.19
date	2003.11.09.01.11.14;	author vincent;	state Exp;
branches;
next	1.18;

1.18
date	2003.04.16.02.38.18;	author millert;	state Exp;
branches;
next	1.17;

1.17
date	2002.07.01.14.33.44;	author vincent;	state Exp;
branches;
next	1.16;

1.16
date	2002.03.18.01.45.54;	author vincent;	state Exp;
branches;
next	1.15;

1.15
date	2002.03.16.04.17.36;	author vincent;	state Exp;
branches;
next	1.14;

1.14
date	2002.02.21.04.21.05;	author vincent;	state Exp;
branches;
next	1.13;

1.13
date	2002.02.20.22.30.54;	author vincent;	state Exp;
branches;
next	1.12;

1.12
date	2002.02.16.21.27.49;	author millert;	state Exp;
branches;
next	1.11;

1.11
date	2002.02.14.14.24.21;	author deraadt;	state Exp;
branches;
next	1.10;

1.10
date	2002.02.14.03.15.04;	author vincent;	state Exp;
branches;
next	1.9;

1.9
date	2002.02.13.22.36.58;	author vincent;	state Exp;
branches;
next	1.8;

1.8
date	2001.05.24.03.05.23;	author mickey;	state Exp;
branches;
next	1.7;

1.7
date	2001.05.23.22.36.14;	author art;	state Exp;
branches;
next	1.6;

1.6
date	2001.05.23.22.20.35;	author art;	state Exp;
branches;
next	1.5;

1.5
date	2001.01.29.01.58.08;	author niklas;	state Exp;
branches;
next	1.4;

1.4
date	2000.09.01.14.59.09;	author millert;	state Exp;
branches;
next	1.3;

1.3
date	2000.04.13.06.12.15;	author millert;	state Exp;
branches;
next	1.2;

1.2
date	2000.02.26.22.53.16;	author millert;	state Exp;
branches;
next	1.1;

1.1
date	2000.02.25.19.08.48;	author deraadt;	state Exp;
branches;
next	;


desc
@@


1.59
log
@When inserting a newline, only increment dotline for windows that are
displaying the same buffer as the current one.
From Martin Wanvik (martin.kr.wanvik AT gmail), thanks!
OK bcallah
@
text
@/*	$OpenBSD: line.c,v 1.58 2015/12/11 20:21:23 mmcc Exp $	*/

/* This file is in the public domain. */

/*
 *		Text line handling.
 *
 * The functions in this file are a general set of line management
 * utilities. They are the only routines that touch the text. They
 * also touch the buffer and window structures to make sure that the
 * necessary updating gets done.
 *
 * Note that this code only updates the dot and mark values in the window
 * list.  Since all the code acts on the current window, the buffer that
 * we are editing must be displayed, which means that "b_nwnd" is non-zero,
 * which means that the dot and mark values in the buffer headers are
 * nonsense.
 */

#include <sys/queue.h>
#include <limits.h>
#include <signal.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#include "def.h"

/*
 * Allocate a new line of size `used'.  lrealloc() can be called if the line
 * ever needs to grow beyond that.
 */
struct line *
lalloc(int used)
{
	struct line *lp;

	if ((lp = malloc(sizeof(*lp))) == NULL)
		return (NULL);
	lp->l_text = NULL;
	lp->l_size = 0;
	lp->l_used = used;	/* XXX */
	if (lrealloc(lp, used) == FALSE) {
		free(lp);
		return (NULL);
	}
	return (lp);
}

int
lrealloc(struct line *lp, int newsize)
{
	char *tmp;

	if (lp->l_size < newsize) {
		if ((tmp = realloc(lp->l_text, newsize)) == NULL)
			return (FALSE);
		lp->l_text = tmp;
		lp->l_size = newsize;
	}
	return (TRUE);
}

/*
 * Delete line "lp".  Fix all of the links that might point to it (they are
 * moved to offset 0 of the next line.  Unlink the line from whatever buffer
 * it might be in, and release the memory.  The buffers are updated too; the
 * magic conditions described in the above comments don't hold here.
 */
void
lfree(struct line *lp)
{
	struct buffer	*bp;
	struct mgwin	*wp;

	for (wp = wheadp; wp != NULL; wp = wp->w_wndp) {
		if (wp->w_linep == lp)
			wp->w_linep = lp->l_fp;
		if (wp->w_dotp == lp) {
			wp->w_dotp = lp->l_fp;
			wp->w_doto = 0;
		}
		if (wp->w_markp == lp) {
			wp->w_markp = lp->l_fp;
			wp->w_marko = 0;
		}
	}
	for (bp = bheadp; bp != NULL; bp = bp->b_bufp) {
		if (bp->b_nwnd == 0) {
			if (bp->b_dotp == lp) {
				bp->b_dotp = lp->l_fp;
				bp->b_doto = 0;
			}
			if (bp->b_markp == lp) {
				bp->b_markp = lp->l_fp;
				bp->b_marko = 0;
			}
		}
	}
	lp->l_bp->l_fp = lp->l_fp;
	lp->l_fp->l_bp = lp->l_bp;
	free(lp->l_text);
	free(lp);
}

/*
 * This routine is called when a character changes in place in the current
 * buffer. It updates all of the required flags in the buffer and window
 * system. The flag used is passed as an argument; if the buffer is being
 * displayed in more than 1 window we change EDIT to HARD. Set MODE if the
 * mode line needs to be updated (the "*" has to be set).
 */
void
lchange(int flag)
{
	struct mgwin	*wp;

	/* update mode lines if this is the first change. */
	if ((curbp->b_flag & BFCHG) == 0) {
		flag |= WFMODE;
		curbp->b_flag |= BFCHG;
	}
	for (wp = wheadp; wp != NULL; wp = wp->w_wndp) {
		if (wp->w_bufp == curbp) {
			wp->w_rflag |= flag;
			if (wp != curwp)
				wp->w_rflag |= WFFULL;
		}
	}
}

/*
 * Insert "n" copies of the character "c" at the current location of dot.
 * In the easy case all that happens is the text is stored in the line.
 * In the hard case, the line has to be reallocated.  When the window list
 * is updated, take special care; I screwed it up once.  You always update
 * dot in the current window.  You update mark and a dot in another window
 * if it is greater than the place where you did the insert. Return TRUE
 * if all is well, and FALSE on errors.
 */
int
linsert(int n, int c)
{
	struct line	*lp1;
	struct mgwin	*wp;
	RSIZE	 i;
	int	 doto;
	int s;

	if (!n)
		return (TRUE);

	if ((s = checkdirty(curbp)) != TRUE)
		return (s);
	
	if (curbp->b_flag & BFREADONLY) {
		dobeep();
		ewprintf("Buffer is read only");
		return (FALSE);
	}

	lchange(WFEDIT);

	/* current line */
	lp1 = curwp->w_dotp;

	/* special case for the end */
	if (lp1 == curbp->b_headp) {
		struct line *lp2, *lp3;

		/* now should only happen in empty buffer */
		if (curwp->w_doto != 0) {
			dobeep();
			ewprintf("bug: linsert");
			return (FALSE);
		}
		/* allocate a new line */
		if ((lp2 = lalloc(n)) == NULL)
			return (FALSE);
		/* previous line */
		lp3 = lp1->l_bp;
		/* link in */
		lp3->l_fp = lp2;
		lp2->l_fp = lp1;
		lp1->l_bp = lp2;
		lp2->l_bp = lp3;
		for (i = 0; i < n; ++i)
			lp2->l_text[i] = c;
		for (wp = wheadp; wp != NULL; wp = wp->w_wndp) {
			if (wp->w_linep == lp1)
				wp->w_linep = lp2;
			if (wp->w_dotp == lp1)
				wp->w_dotp = lp2;
			if (wp->w_markp == lp1)
				wp->w_markp = lp2;
		}
		undo_add_insert(lp2, 0, n);
		curwp->w_doto = n;
		return (TRUE);
	}
	/* save for later */
	doto = curwp->w_doto;

	if ((lp1->l_used + n) > lp1->l_size) {
		if (lrealloc(lp1, lp1->l_used + n) == FALSE)
			return (FALSE);
	}
	lp1->l_used += n;
	if (lp1->l_used != n)
		memmove(&lp1->l_text[doto + n], &lp1->l_text[doto],
		    lp1->l_used - n - doto);

	/* Add the characters */
	for (i = 0; i < n; ++i)
		lp1->l_text[doto + i] = c;
	for (wp = wheadp; wp != NULL; wp = wp->w_wndp) {
		if (wp->w_dotp == lp1) {
			if (wp == curwp || wp->w_doto > doto)
				wp->w_doto += n;
		}
		if (wp->w_markp == lp1) {
			if (wp->w_marko > doto)
				wp->w_marko += n;
		}
	}
	undo_add_insert(curwp->w_dotp, doto, n);
	return (TRUE);
}

/*
 * Do the work of inserting a newline at the given line/offset.
 * If mark is on the current line, we may have to move the markline
 * to keep line numbers in sync.
 * lnewline_at assumes the current buffer is writable. Checking for
 * this fact should be done by the caller.
 */
int
lnewline_at(struct line *lp1, int doto)
{
	struct line	*lp2;
	struct mgwin	*wp;
	int	 	 nlen, tcurwpdotline;

	lchange(WFFULL);

	curwp->w_bufp->b_lines++;
	/* Check if mark is past dot (even on current line) */
	if (curwp->w_markline > curwp->w_dotline  ||
	   (curwp->w_dotline == curwp->w_markline &&
	    curwp->w_marko >= doto))
		curwp->w_markline++;

	tcurwpdotline = curwp->w_dotline;

	/* If start of line, allocate a new line instead of copying */
	if (doto == 0) {
		/* new first part */
		if ((lp2 = lalloc(0)) == NULL)
			return (FALSE);
		lp2->l_bp = lp1->l_bp;
		lp1->l_bp->l_fp = lp2;
		lp2->l_fp = lp1;
		lp1->l_bp = lp2;
		for (wp = wheadp; wp != NULL; wp = wp->w_wndp) {
			if (wp->w_linep == lp1)
				wp->w_linep = lp2;
			if (wp->w_dotline >= tcurwpdotline && 
			    wp->w_bufp == curwp->w_bufp)
				wp->w_dotline++;
		}
		undo_add_boundary(FFRAND, 1);
		undo_add_insert(lp2, 0, 1);
		undo_add_boundary(FFRAND, 1);
		return (TRUE);
	}

	/* length of new part */
	nlen = llength(lp1) - doto;

	/* new second half line */
	if ((lp2 = lalloc(nlen)) == NULL)
		return (FALSE);
	if (nlen != 0)
		bcopy(&lp1->l_text[doto], &lp2->l_text[0], nlen);
	lp1->l_used = doto;
	lp2->l_bp = lp1;
	lp2->l_fp = lp1->l_fp;
	lp1->l_fp = lp2;
	lp2->l_fp->l_bp = lp2;
	/* Windows */
	for (wp = wheadp; wp != NULL; wp = wp->w_wndp) {
		if (wp->w_dotp == lp1 && wp->w_doto >= doto) {
			wp->w_dotp = lp2;
			wp->w_doto -= doto;
			wp->w_dotline++;
		} else if (wp->w_dotline > tcurwpdotline &&
		    wp->w_bufp == curwp->w_bufp)
			wp->w_dotline++;
		if (wp->w_markp == lp1 && wp->w_marko >= doto) {
			wp->w_markp = lp2;
			wp->w_marko -= doto;
		}
	}
	undo_add_boundary(FFRAND, 1);
	undo_add_insert(lp1, llength(lp1), 1);
	undo_add_boundary(FFRAND, 1);
	return (TRUE);
}

/*
 * Insert a newline into the buffer at the current location of dot in the
 * current window.
 */
int
lnewline(void)
{
	int s;

	if ((s = checkdirty(curbp)) != TRUE)
		return (s);
	if (curbp->b_flag & BFREADONLY) {
		dobeep();
		ewprintf("Buffer is read only");
		return (FALSE);
	}
	return (lnewline_at(curwp->w_dotp, curwp->w_doto));
}

/*
 * This function deletes "n" bytes, starting at dot. (actually, n+1, as the
 * newline is included) It understands how to deal with end of lines, etc.
 * It returns TRUE if all of the characters were deleted, and FALSE if
 * they were not (because dot ran into the end of the buffer).
 * The "kflag" indicates either no insertion, or direction  of insertion
 * into the kill buffer.
 */
int
ldelete(RSIZE n, int kflag)
{
	struct line	*dotp;
	RSIZE		 chunk;
	struct mgwin	*wp;
	int		 doto;
	char		*cp1, *cp2;
	size_t		 len;
	char		*sv = NULL;
	int		 end;
	int		 s;
	int		 rval = FALSE;

	if ((s = checkdirty(curbp)) != TRUE)
		return (s);
	if (curbp->b_flag & BFREADONLY) {
		dobeep();
		ewprintf("Buffer is read only");
		goto out;
	}
	len = n;
	if ((sv = calloc(1, len + 1)) == NULL)
		goto out;
	end = 0;

	undo_add_delete(curwp->w_dotp, curwp->w_doto, n, (kflag & KREG));

	while (n != 0) {
		dotp = curwp->w_dotp;
		doto = curwp->w_doto;
		/* Hit the end of the buffer */
		if (dotp == curbp->b_headp)
			goto out;
		/* Size of the chunk */
		chunk = dotp->l_used - doto;

		if (chunk > n)
			chunk = n;
		/* End of line, merge */
		if (chunk == 0) {
			if (dotp == blastlp(curbp))
				goto out;
			lchange(WFFULL);
			if (ldelnewline() == FALSE)
				goto out;
			end = strlcat(sv, "\n", len + 1);
			--n;
			continue;
		}
		lchange(WFEDIT);
		/* Scrunch text */
		cp1 = &dotp->l_text[doto];
		memcpy(&sv[end], cp1, chunk);
		end += chunk;
		sv[end] = '\0';
		for (cp2 = cp1 + chunk; cp2 < &dotp->l_text[dotp->l_used];
		    cp2++)
			*cp1++ = *cp2;
		dotp->l_used -= (int)chunk;
		for (wp = wheadp; wp != NULL; wp = wp->w_wndp) {
			if (wp->w_dotp == dotp && wp->w_doto >= doto) {
				wp->w_doto -= chunk;
				if (wp->w_doto < doto)
					wp->w_doto = doto;
			}
			if (wp->w_markp == dotp && wp->w_marko >= doto) {
				wp->w_marko -= chunk;
				if (wp->w_marko < doto)
					wp->w_marko = doto;
			}
		}
		n -= chunk;
	}
	if (kchunk(sv, (RSIZE)len, kflag) != TRUE)
		goto out;
	rval = TRUE;
out:
	free(sv);
	return (rval);
}

/*
 * Delete a newline and join the current line with the next line. If the next
 * line is the magic header line always return TRUE; merging the last line
 * with the header line can be thought of as always being a successful
 * operation.  Even if nothing is done, this makes the kill buffer work
 * "right". If the mark is past the dot (actually, markline > dotline),
 * decrease the markline accordingly to keep line numbers in sync.
 * Easy cases can be done by shuffling data around.  Hard cases
 * require that lines be moved about in memory.  Return FALSE on error and
 * TRUE if all looks ok. We do not update w_dotline here, as deletes are done
 * after moves.
 */
int
ldelnewline(void)
{
	struct line	*lp1, *lp2, *lp3;
	struct mgwin	*wp;
	int s;

	if ((s = checkdirty(curbp)) != TRUE)
		return (s);
	if (curbp->b_flag & BFREADONLY) {
		dobeep();
		ewprintf("Buffer is read only");
		return (FALSE);
	}

	lp1 = curwp->w_dotp;
	lp2 = lp1->l_fp;
	/* at the end of the buffer */
	if (lp2 == curbp->b_headp)
		return (TRUE);
	/* Keep line counts in sync */
	curwp->w_bufp->b_lines--;
	if (curwp->w_markline > curwp->w_dotline)
		curwp->w_markline--;
	if (lp2->l_used <= lp1->l_size - lp1->l_used) {
		bcopy(&lp2->l_text[0], &lp1->l_text[lp1->l_used], lp2->l_used);
		for (wp = wheadp; wp != NULL; wp = wp->w_wndp) {
			if (wp->w_linep == lp2)
				wp->w_linep = lp1;
			if (wp->w_dotp == lp2) {
				wp->w_dotp = lp1;
				wp->w_doto += lp1->l_used;
			}
			if (wp->w_markp == lp2) {
				wp->w_markp = lp1;
				wp->w_marko += lp1->l_used;
			}
		}
		lp1->l_used += lp2->l_used;
		lp1->l_fp = lp2->l_fp;
		lp2->l_fp->l_bp = lp1;
		free(lp2);
		return (TRUE);
	}
	if ((lp3 = lalloc(lp1->l_used + lp2->l_used)) == NULL)
		return (FALSE);
	bcopy(&lp1->l_text[0], &lp3->l_text[0], lp1->l_used);
	bcopy(&lp2->l_text[0], &lp3->l_text[lp1->l_used], lp2->l_used);
	lp1->l_bp->l_fp = lp3;
	lp3->l_fp = lp2->l_fp;
	lp2->l_fp->l_bp = lp3;
	lp3->l_bp = lp1->l_bp;
	for (wp = wheadp; wp != NULL; wp = wp->w_wndp) {
		if (wp->w_linep == lp1 || wp->w_linep == lp2)
			wp->w_linep = lp3;
		if (wp->w_dotp == lp1)
			wp->w_dotp = lp3;
		else if (wp->w_dotp == lp2) {
			wp->w_dotp = lp3;
			wp->w_doto += lp1->l_used;
		}
		if (wp->w_markp == lp1)
			wp->w_markp = lp3;
		else if (wp->w_markp == lp2) {
			wp->w_markp = lp3;
			wp->w_marko += lp1->l_used;
		}
	}
	free(lp1);
	free(lp2);
	return (TRUE);
}

/*
 * Replace plen characters before dot with argument string.  Control-J
 * characters in st are interpreted as newlines.  There is a casehack
 * disable flag (normally it likes to match case of replacement to what
 * was there).
 */
int
lreplace(RSIZE plen, char *st)
{
	RSIZE	rlen;	/* replacement length		 */
	int s;

	if ((s = checkdirty(curbp)) != TRUE)
		return (s);
	if (curbp->b_flag & BFREADONLY) {
		dobeep();
		ewprintf("Buffer is read only");
		return (FALSE);
	}
	undo_boundary_enable(FFRAND, 0);

	(void)backchar(FFARG | FFRAND, (int)plen);
	(void)ldelete(plen, KNONE);

	rlen = strlen(st);
	region_put_data(st, rlen);
	lchange(WFFULL);

	undo_boundary_enable(FFRAND, 1);
	return (TRUE);
}

/*
 * Allocate and return the supplied line as a C string
 */
char *
linetostr(const struct line *ln)
{
	int	 len;
	char	*line;

	len = llength(ln);
	if (len == INT_MAX)  /* (len + 1) overflow */
		return (NULL);

	if ((line = malloc(len + 1)) == NULL)
		return (NULL);

	(void)memcpy(line, ltext(ln), len);
	line[len] = '\0';

	return (line);
}
@


1.58
log
@Remove NULL-checks before free().
@
text
@d1 1
a1 1
/*	$OpenBSD: line.c,v 1.57 2015/09/29 02:07:49 guenther Exp $	*/
d267 2
a268 1
			if (wp->w_dotline >= tcurwpdotline)
d296 2
a297 1
		} else if (wp->w_dotline > tcurwpdotline)
@


1.57
log
@Mark eread(), veread(), and eformat() as printf-like and
Convert eread(buf, a2, a3, a4) to eread("%s", a2, a3, a4, buf)

ok millert@@ lum@@
@
text
@d1 1
a1 1
/*	$OpenBSD: line.c,v 1.56 2015/06/03 23:40:01 bcallah Exp $	*/
d102 1
a102 2
	if (lp->l_text != NULL)
		free(lp->l_text);
@


1.56
log
@Remove unused defines and functions.
"Looks fine." deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: line.c,v 1.55 2015/03/19 21:22:15 bcallah Exp $	*/
a397 1
				/* NOSTRICT */
a402 1
				/* NOSTRICT */
@


1.55
log
@Clean up the includes in mg.
This does the following:
Moves all POSIX headers from sysdef.h into the individual .c files so that
each file now only includes what it needs. All headers are properly sorted.
Moves the remainder of sysdef.h to other files (mostly def.h) and deletes
sysdef.h now that it's no longer contains anything.
Tweak a comment that references sysdef.h so that it no longer does that.
ok florian@@
@
text
@d1 1
a1 1
/*	$OpenBSD: line.c,v 1.54 2014/11/16 04:16:41 guenther Exp $	*/
a130 94
}

/*
 * Insert "n" bytes from "s" at the current location of dot.
 * In the easy case all that happens is the text is stored in the line.
 * In the hard case, the line has to be reallocated.  When the window list
 * is updated, take special care; I screwed it up once.  You always update
 * dot in the current window.  You update mark and a dot in another window
 * if it is greater than the place where you did the insert. Return TRUE
 * if all is well, and FALSE on errors.
 */
int
linsert_str(const char *s, int n)
{
	struct line	*lp1;
	struct mgwin	*wp;
	RSIZE	 i;
	int	 doto, k;

	if ((k = checkdirty(curbp)) != TRUE)
		return (k);

	if (curbp->b_flag & BFREADONLY) {
		dobeep();
		ewprintf("Buffer is read only");
		return (FALSE);
	}

	if (!n)
		return (TRUE);

	lchange(WFFULL);

	/* current line */
	lp1 = curwp->w_dotp;

	/* special case for the end */
	if (lp1 == curbp->b_headp) {
		struct line *lp2, *lp3;

		/* now should only happen in empty buffer */
		if (curwp->w_doto != 0)
			panic("bug: linsert_str");
		/* allocate a new line */
		if ((lp2 = lalloc(n)) == NULL)
			return (FALSE);
		/* previous line */
		lp3 = lp1->l_bp;
		/* link in */
		lp3->l_fp = lp2;
		lp2->l_fp = lp1;
		lp1->l_bp = lp2;
		lp2->l_bp = lp3;
		for (i = 0; i < n; ++i)
			lp2->l_text[i] = s[i];
		for (wp = wheadp; wp != NULL; wp = wp->w_wndp) {
			if (wp->w_linep == lp1)
				wp->w_linep = lp2;
			if (wp->w_dotp == lp1)
				wp->w_dotp = lp2;
			if (wp->w_markp == lp1)
				wp->w_markp = lp2;
		}
		undo_add_insert(lp2, 0, n);
		curwp->w_doto = n;
		return (TRUE);
	}
	/* save for later */
	doto = curwp->w_doto;

	if ((lp1->l_used + n) > lp1->l_size) {
		if (lrealloc(lp1, lp1->l_used + n) == FALSE)
			return (FALSE);
	}
	lp1->l_used += n;
	if (lp1->l_used != n)
		memmove(&lp1->l_text[doto + n], &lp1->l_text[doto],
		    lp1->l_used - n - doto);

	/* Add the characters */
	for (i = 0; i < n; ++i)
		lp1->l_text[doto + i] = s[i];
	for (wp = wheadp; wp != NULL; wp = wp->w_wndp) {
		if (wp->w_dotp == lp1) {
			if (wp == curwp || wp->w_doto > doto)
				wp->w_doto += n;
		}
		if (wp->w_markp == lp1) {
			if (wp->w_marko > doto)
				wp->w_marko += n;
		}
	}
	undo_add_insert(curwp->w_dotp, doto, n);
	return (TRUE);
@


1.54
log
@Stop using <sys/param.h>; replace MAXPATHLEN with PATH_MAX, stop using MAX(),
and pull in <limits.h> for *_MAX constants.

inspired on a diff from Kamil Rytarowski (n54 (at) gmx.com)
ok bcallah@@
@
text
@d1 1
a1 1
/*	$OpenBSD: line.c,v 1.53 2014/03/20 07:47:29 lum Exp $	*/
d20 1
a20 2
#include "def.h"

d22 2
d26 2
@


1.53
log
@Add some missing dobeeps.
ok florian@@
@
text
@d1 1
a1 1
/*	$OpenBSD: line.c,v 1.52 2013/12/23 21:47:32 florian Exp $	*/
d22 1
@


1.52
log
@Fix two dotline bugs for the price of one.
1) When answering "No newline at end of file, add one?" with y and
   dot is not at the end of buffer dotline is off by one
2) When displaying the same buffer in two windows, dot in the
   second window is below dot in the first and a newline is entered in
   the first window dotline is not updated in the second.

OK lum
@
text
@d1 1
a1 1
/*	$OpenBSD: line.c,v 1.51 2013/06/01 10:17:01 lum Exp $	*/
d150 1
d248 1
d264 1
d411 1
d443 1
d532 1
d610 1
@


1.51
log
@The k*() functions were moved to yank.c in 2005. Update the comment to
reflect this.
@
text
@d1 1
a1 1
/*	$OpenBSD: line.c,v 1.50 2011/01/18 16:28:00 kjell Exp $	*/
a328 1
	int	 nlen;
d330 1
d340 2
a341 1
	curwp->w_dotline++;
d352 1
a352 1
		for (wp = wheadp; wp != NULL; wp = wp->w_wndp)
d355 3
d382 3
a384 1
		}
@


1.50
log
@Obvious error on my part.
test len against INT_MAX, not SIZE_MAX. 'looks good' jasper@@
@
text
@d1 1
a1 1
/*	$OpenBSD: line.c,v 1.49 2009/11/12 16:37:14 millert Exp $	*/
d11 1
a11 2
 * necessary updating gets done.  There are routines in this file that
 * handle the kill buffer too.  It isn't here for any good reason.
@


1.49
log
@fix memory leak found by parfait; ok jsg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: line.c,v 1.48 2009/06/05 18:02:06 kjell Exp $	*/
d621 1
a621 1
	size_t	 len;
d625 1
a625 1
	if (len == SIZE_MAX)  /* (len + 1) overflow */
@


1.48
log
@emacs handles the undo of a region kill (C-w) differently than a line kill
(C-k) with respect to cursor position. The former leaves the cursor at the end,
the latter at the beginning of the region.

emacs is wacky.

Make mg undo do the same. ok deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: line.c,v 1.47 2009/06/04 02:23:37 kjell Exp $	*/
d426 1
a426 1
	char		*sv;
d429 1
d435 1
a435 1
		return (FALSE);
d439 1
a439 1
		return (FALSE);
d449 1
a449 1
			return (FALSE);
d458 1
a458 1
				return (FALSE);
d461 1
a461 1
				return (FALSE);
d493 3
a495 1
		return (FALSE);
d497 1
a497 1
	return (TRUE);
@


1.47
log
@Rename w_flag to w_rflag. This is not a general purpose
flag: it is for redisplay options only. I need an additional all-purpose
flag, so renaming removes the desire to wrongly overload the existing one.

Turdshine. No functional chage.
@
text
@d1 1
a1 1
/*	$OpenBSD: line.c,v 1.46 2008/09/15 16:13:35 kjell Exp $	*/
d441 1
a441 1
	undo_add_delete(curwp->w_dotp, curwp->w_doto, n);
@


1.46
log
@Expose the undo commands as proper mg functions.
This should have no functional change on undo, but it does facilitate
testing undo behavior.
@
text
@d1 1
a1 1
/*	$OpenBSD: line.c,v 1.45 2008/09/15 16:11:35 kjell Exp $	*/
d123 1
a123 1
			wp->w_flag |= flag;
d125 1
a125 1
				wp->w_flag |= WFFULL;
@


1.45
log
@Enable dirty buffer detection in mg.
Emulate the emacs behavior: after suspend/resume, buffer switch,
or at save time, warn (prompt) the user if the file has been modified
on disk in the interim.
This has already saved my butt numerous times.
ok phessler
@
text
@d1 1
a1 1
/*	$OpenBSD: line.c,v 1.44 2006/12/24 01:20:53 kjell Exp $	*/
d355 1
a355 1
		undo_add_boundary();
d357 1
a357 1
		undo_add_boundary();
d385 1
a385 1
	undo_add_boundary();
d387 1
a387 1
	undo_add_boundary();
d599 1
a599 2
	undo_add_boundary();
	undo_boundary_enable(FALSE);
d608 1
a608 2
	undo_boundary_enable(TRUE);
	undo_add_boundary();
@


1.44
log
@Fix a bug where inserting a file resulted in an incorrect
line-number count for a buffer (M-X insert-file, M-> to reproduce).
While here, fix a number of bugs with incorrect line numbers
after swap point-and-mark

Originally reported via debian's bug tracking system. Fix tested by
Han Boetes and Deanna Phillips.
@
text
@d1 1
a1 1
/*	$OpenBSD: line.c,v 1.43 2006/11/17 08:45:31 kjell Exp $	*/
d145 4
a148 1
	int	 doto;
d239 1
d244 3
d398 4
d428 1
d430 2
d514 1
d516 2
d591 1
d593 2
@


1.43
log
@Fix a needless inversion of flag names; i.e. change them from the
negative to the positive. undo_boundary_enable(TRUE) makes a LOT more
sense than undo_no_boundary(FALSE).
While here, whack a global, and fix a bug noted by otto:
undoing a file insertion sometimes left stray characters around.
ok beck@@, otto@@
@
text
@d1 1
a1 1
/*	$OpenBSD: line.c,v 1.42 2006/07/25 08:27:09 kjell Exp $	*/
d312 7
d328 8
a394 2
	curwp->w_bufp->b_lines++;
	curwp->w_dotline++;
d488 3
a490 1
 * "right".  Easy cases can be done by shuffling data around.  Hard cases
d511 1
d513 2
@


1.42
log
@Add bfirstlp(), blastlp() macros, returning the first and last lines
of a buffer respectively. Removes an ugly construction than necessitated
"go to first line"-type comments throughout the code.
No binary change
@
text
@d1 1
a1 1
/*	$OpenBSD: line.c,v 1.41 2006/07/25 08:22:32 kjell Exp $	*/
d562 1
a562 1
	undo_no_boundary(TRUE);
d571 1
a571 1
	undo_no_boundary(FALSE);
@


1.41
log
@Rename the header line of a buffer to b_headp, from the remarkably
unintuitive b_linep. No binary change.
@
text
@d1 1
a1 1
/*	$OpenBSD: line.c,v 1.40 2006/06/01 09:00:50 kjell Exp $	*/
d429 1
a429 2
			if (dotp == lback(curbp->b_headp))
				/* End of buffer */
@


1.40
log
@Display line number in the mg statusbar.  Yes, it seems like a fugly
way to do it, but all the clever and pretty ways utterly failed.
Basic use seems fine. We'll turdshine the special cases later.

If it bothers you, use M-x line-number-mode, or put same in your ~/.mg
file to disable.

ok cloder, jason
@
text
@d1 1
a1 1
/*	$OpenBSD: line.c,v 1.39 2006/05/28 23:30:16 kjell Exp $	*/
d161 1
a161 1
	if (lp1 == curbp->b_linep) {
d251 1
a251 1
	if (lp1 == curbp->b_linep) {
d420 1
a420 1
		if (dotp == curbp->b_linep)
d429 1
a429 1
			if (dotp == lback(curbp->b_linep))
d495 1
a495 1
	if (lp2 == curbp->b_linep)
@


1.39
log
@Make Window Flags more mnemonic (and less dumb); i.e.
WFHARD -> WFFULL (Redraw full window)
WFFORCE -> WFFRAME (Reframe window).
No binary change
@
text
@d1 1
a1 1
/*	$OpenBSD: line.c,v 1.38 2006/05/27 21:20:11 kjell Exp $	*/
d380 2
d478 2
a479 1
 * TRUE if all looks ok.
d497 1
@


1.38
log
@Move mg "line to c-string" functionality to a function.
@
text
@d1 1
a1 1
/*	$OpenBSD: line.c,v 1.37 2005/12/20 06:17:36 kjell Exp $	*/
d125 1
a125 1
				wp->w_flag |= WFHARD;
d155 1
a155 1
	lchange(WFHARD);
d319 1
a319 1
	lchange(WFHARD);
d430 1
a430 1
			lchange(WFHARD);
d566 1
a566 1
	lchange(WFHARD);
@


1.37
log
@Clean up the ugly casted frees. In one case, this meant eliminating a nasty
struct/union/casting nightmare when building the list of names for filename
completion. In particular, be consistent about strduping and freeing
the list data.
@
text
@d1 1
a1 1
/*	$OpenBSD: line.c,v 1.36 2005/12/20 05:04:28 kjell Exp $	*/
d571 22
@


1.36
log
@Do some delinting of strl-type functions. Also, remove a superfluous
word in the undo-list.
@
text
@d1 1
a1 1
/*	$OpenBSD: line.c,v 1.35 2005/12/20 04:58:10 kjell Exp $	*/
d511 1
a511 1
		free((char *)lp2);
d538 2
a539 2
	free((char *)lp1);
	free((char *)lp2);
@


1.35
log
@Fix broken "Undo of undo" when line is empty. Noticed by theo.
@
text
@d1 1
a1 1
/*	$OpenBSD: line.c,v 1.34 2005/12/13 05:40:33 kjell Exp $	*/
d384 6
a389 5
 * This function deletes "n" bytes, starting at dot. It understands how to
 * deal with end of lines, etc.  It returns TRUE if all of the characters
 * were deleted, and FALSE if they were not (because dot ran into the end
 * of the buffer.  The "kflag" indicates either no insertion, or direction
 * of insertion into the kill buffer.
d395 1
a395 1
	RSIZE	 chunk;
d397 5
a401 5
	int	 doto;
	char	*cp1, *cp2;
	size_t	 len;
	char	*sv;
	int	 end;
@


1.34
log
@do some silly de-linting
@
text
@d1 1
a1 1
/*	$OpenBSD: line.c,v 1.33 2005/11/22 05:02:44 kjell Exp $	*/
a317 1
	int	 retval = TRUE;
d321 1
a321 1
	/* avoid unnecessary copying */
d324 2
a325 4
		if ((lp2 = lalloc(0)) == NULL) {
			retval = FALSE;
			goto lnl_done;
		}
d333 4
a336 1
		goto lnl_done;
d343 2
a344 4
	if ((lp2 = lalloc(nlen)) == NULL) {
		retval = FALSE;
		goto lnl_done;
	}
a362 1
lnl_done:
d366 1
a366 1
	return (retval);
@


1.33
log
@Move kill-related commands to their own file.
This will help move to a kill-ring.
@
text
@d1 1
a1 1
/*	$OpenBSD: line.c,v 1.32 2005/11/22 04:38:57 kjell Exp $	*/
d465 1
a465 1
	if (kchunk(sv, len, kflag) != TRUE)
@


1.32
log
@Fix backwards insert into kill buffer (aaa \n bbb M-BS M-BS c-Y) by
batching string before prepending.
ok cloder, (grudgingly) beck
@
text
@d1 1
a1 1
/*	$OpenBSD: line.c,v 1.31 2005/11/21 19:47:23 deraadt Exp $	*/
a26 16
 * The number of bytes member from the start of the structure type should be
 * computed at compile time.
 */

#ifndef KBLOCK
#define KBLOCK	256		/* Kill buffer block size.	 */
#endif

static char	*kbufp = NULL;	/* Kill buffer data.		 */
static RSIZE	 kused = 0;	/* # of bytes used in KB.	 */
static RSIZE	 ksize = 0;	/* # of bytes allocated in KB.	 */
static RSIZE	 kstart = 0;	/* # of first used byte in KB.	 */

static int	 kgrow(int);

/*
a571 116
	return (TRUE);
}

/*
 * Delete all of the text saved in the kill buffer.  Called by commands when
 * a new kill context is created. The kill buffer array is released, just in
 * case the buffer has grown to an immense size.  No errors.
 */
void
kdelete(void)
{
	if (kbufp != NULL) {
		free((char *)kbufp);
		kbufp = NULL;
		kstart = kused = ksize = 0;
	}
}

/*
 * Insert a character to the kill buffer, enlarging the buffer if there
 * isn't any room. Always grow the buffer in chunks, on the assumption
 * that if you put something in the kill buffer you are going to put more
 * stuff there too later. Return TRUE if all is well, and FALSE on errors.
 * Print a message on errors.  Dir says whether to put it at back or front.
 * This call is ignored if  KNONE is set. 
 */
int
kinsert(int c, int dir)
{
	if (dir == KNONE)
		return (TRUE);
	if (kused == ksize && dir == KFORW && kgrow(dir) == FALSE)
		return (FALSE);
	if (kstart == 0 && dir == KBACK && kgrow(dir) == FALSE)
		return (FALSE);
	if (dir == KFORW)
		kbufp[kused++] = c;
	else if (dir == KBACK)
		kbufp[--kstart] = c;
	else
		panic("broken kinsert call");	/* Oh shit! */
	return (TRUE);
}

/*
 * kgrow - just get more kill buffer for the callee. If dir = KBACK
 * we are trying to get space at the beginning of the kill buffer.
 */
static int
kgrow(int dir)
{
	int	 nstart;
	char	*nbufp;

	if ((unsigned)(ksize + KBLOCK) <= (unsigned)ksize) {
		/* probably 16 bit unsigned */
		ewprintf("Kill buffer size at maximum");
		return (FALSE);
	}
	if ((nbufp = malloc((unsigned)(ksize + KBLOCK))) == NULL) {
		ewprintf("Can't get %ld bytes", (long)(ksize + KBLOCK));
		return (FALSE);
	}
	nstart = (dir == KBACK) ? (kstart + KBLOCK) : (KBLOCK / 4);
	bcopy(&(kbufp[kstart]), &(nbufp[nstart]), (int)(kused - kstart));
	if (kbufp != NULL)
		free((char *)kbufp);
	kbufp = nbufp;
	ksize += KBLOCK;
	kused = kused - kstart + nstart;
	kstart = nstart;
	return (TRUE);
}

/*
 * This function gets characters from the kill buffer. If the character
 * index "n" is off the end, it returns "-1". This lets the caller just
 * scan along until it gets a "-1" back.
 */
int
kremove(int n)
{
	if (n < 0 || n + kstart >= kused)
		return (-1);
	return (CHARMASK(kbufp[n + kstart]));
}

/*
 * Copy a string into the kill buffer. kflag gives direction.
 * if KNONE, do nothing.
 */
int
kchunk(char *cp1, RSIZE chunk, int kflag)
{
	/*
	 * HACK - doesn't matter, and fixes back-over-nl bug for empty
	 *	kill buffers.
	 */
	if (kused == kstart)
		kflag = KFORW;

	if (kflag == KFORW) {
		while (ksize - kused < chunk)
			if (kgrow(kflag) == FALSE)
				return (FALSE);
		bcopy(cp1, &(kbufp[kused]), (int)chunk);
		kused += chunk;
	} else if (kflag == KBACK) {
		while (kstart < chunk)
			if (kgrow(kflag) == FALSE)
				return (FALSE);
		bcopy(cp1, &(kbufp[kstart - chunk]), (int)chunk);
		kstart -= chunk;
	} else if (kflag != KNONE)
		panic("broken ldelete call");

@


1.31
log
@kill kill kill unused stuff; ok kjell
@
text
@d1 1
a1 1
/*	$OpenBSD: line.c,v 1.30 2005/11/20 03:24:17 deraadt Exp $	*/
d23 3
d417 3
d425 4
d449 1
a449 2
			if (ldelnewline() == FALSE ||
			    (kflag != KNONE && kinsert('\n', kflag) == FALSE))
d451 1
d458 3
a460 2
		if (kchunk(cp1, chunk, kflag) == FALSE)
			return(FALSE);
d481 3
d612 1
d617 2
@


1.30
log
@toast NO_DIRED #ifdef; ok kjell
@
text
@d1 1
a1 1
/*	$OpenBSD: line.c,v 1.29 2005/11/18 23:37:31 kjell Exp $	*/
a26 8

#ifndef OFFSET
#define OFFSET(type,member) ((char *)&(((type *)0)->member)-(char *)((type *)0))
#endif

#ifndef NBLOCK
#define NBLOCK	16		/* Line block chunk size.	 */
#endif
@


1.29
log
@Split kill buffer code into a separate function.
@
text
@d1 1
a1 1
/*	$OpenBSD: line.c,v 1.28 2005/11/18 20:56:53 deraadt Exp $	*/
d457 1
a457 1
			return(FALSE); 
@


1.28
log
@greedy use of typedef struct was making code harder to read; ok kjell cloder
@
text
@d1 1
a1 1
/*	$OpenBSD: line.c,v 1.27 2005/11/18 17:35:17 kjell Exp $	*/
a429 7
	/*
	 * HACK - doesn't matter, and fixes back-over-nl bug for empty
	 *	kill buffers.
	 */
	if (kused == kstart)
		kflag = KFORW;

d456 2
a457 14
		if (kflag == KFORW) {
			while (ksize - kused < chunk)
				if (kgrow(kflag) == FALSE)
					return (FALSE);
			bcopy(cp1, &(kbufp[kused]), (int)chunk);
			kused += chunk;
		} else if (kflag == KBACK) {
			while (kstart < chunk)
				if (kgrow(kflag) == FALSE)
					return (FALSE);
			bcopy(cp1, &(kbufp[kstart - chunk]), (int)chunk);
			kstart -= chunk;
		} else if (kflag != KNONE)
			panic("broken ldelete call");
d664 32
@


1.27
log
@Casefold on replace was killed ages ago (it was wrong). Remove a
leftover (unused) variable.
@
text
@d1 1
a1 1
/*	$OpenBSD: line.c,v 1.26 2005/11/18 17:19:51 kjell Exp $	*/
d51 1
a51 1
LINE *
d54 1
a54 1
	LINE *lp;
d69 1
a69 1
lrealloc(LINE *lp, int newsize)
d89 1
a89 1
lfree(LINE *lp)
d91 2
a92 2
	BUFFER	*bp;
	MGWIN	*wp;
d135 1
a135 1
	MGWIN	*wp;
d163 2
a164 2
	LINE	*lp1;
	MGWIN	*wp;
d183 1
a183 1
		LINE *lp2, *lp3;
d253 2
a254 2
	LINE	*lp1;
	MGWIN	*wp;
d273 1
a273 1
		LINE *lp2, *lp3;
d334 1
a334 1
lnewline_at(LINE *lp1, int doto)
d336 1
a336 1
	LINE	*lp2;
d338 1
a338 1
	MGWIN	*wp;
d417 1
a417 1
	LINE	*dotp;
d419 1
a419 1
	MGWIN	*wp;
d512 2
a513 2
	LINE	*lp1, *lp2, *lp3;
	MGWIN	*wp;
@


1.26
log
@Kill a stupid interface. kgrow should take direction, not TRUE/FALSE.
@
text
@d1 1
a1 1
/*	$OpenBSD: line.c,v 1.25 2005/10/13 20:28:49 deraadt Exp $	*/
d581 1
a581 1
lreplace(RSIZE plen, char *st, int f)
@


1.25
log
@spacing
@
text
@d1 1
a1 1
/*	$OpenBSD: line.c,v 1.24 2005/10/06 16:48:00 kjell Exp $	*/
d465 1
a465 1
				if (kgrow(FALSE) == FALSE)
d471 1
a471 1
				if (kgrow(TRUE) == FALSE)
d629 1
a629 1
	if (kused == ksize && dir == KFORW && kgrow(FALSE) == FALSE)
d631 1
a631 1
	if (kstart == 0 && dir == KBACK && kgrow(TRUE) == FALSE)
d643 1
a643 1
 * kgrow - just get more kill buffer for the callee. back is true if
d647 1
a647 1
kgrow(int back)
d661 1
a661 1
	nstart = (back == TRUE) ? (kstart + KBLOCK) : (KBLOCK / 4);
@


1.24
log
@Make mg undo much more emacs like (and correct).
Undo boundaries are now placed at newlines, and undo
of search-replace works as expected. Fixes bad behaviour
reported by matthieu

Ok deraadt@@, beck@@
@
text
@d1 1
a1 1
/*	$OpenBSD: line.c,v 1.23 2005/06/14 18:14:40 kjell Exp $	*/
d591 1
a591 1
	
@


1.23
log
@Add explicit public domain notices to all public domain files.
ok millert@@, deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: line.c,v 1.22 2005/04/03 02:09:28 db Exp $	*/
d339 1
a342 4
	undo_add_boundary();
	undo_add_insert(lp1, llength(lp1), 1);
	undo_add_boundary();

d346 4
a349 2
		if ((lp2 = lalloc(0)) == NULL)
			return (FALSE);
d357 1
a357 1
		return (TRUE);
d364 4
a367 2
	if ((lp2 = lalloc(nlen)) == NULL)
		return (FALSE);
d386 5
a390 1
	return (TRUE);
a583 3
	int	rtype;	/* capitalization		 */
	int	c;	/* used for random characters	 */
	int	doto;	/* offset into line		 */
d589 3
a591 9

	undo_add_change(curwp->w_dotp, curwp->w_doto, plen);

	/*
	 * Find the capitalization of the word that was found.  f says use
	 * exact case of replacement string (same thing that happens with
	 * lowercase found), so bypass check.
	 */
	/* NOSTRICT */
d593 1
a593 11
	rtype = _MG_L;
	c = lgetc(curwp->w_dotp, curwp->w_doto);
	if (ISUPPER(c) != FALSE && f == FALSE) {
		rtype = _MG_U | _MG_L;
		if (curwp->w_doto + 1 < llength(curwp->w_dotp)) {
			c = lgetc(curwp->w_dotp, curwp->w_doto + 1);
			if (ISUPPER(c) != FALSE) {
				rtype = _MG_U;
			}
		}
	}
a594 5
	/*
	 * make the string lengths match (either pad the line
	 * so that it will fit, or scrunch out the excess).
	 * be careful with dot's offset.
	 */
d596 2
a597 8
	doto = curwp->w_doto;
	if (plen > rlen)
		(void)ldelete((RSIZE) (plen - rlen), KNONE);
	else if (plen < rlen) {
		if (linsert((int)(rlen - plen), ' ') == FALSE)
			return (FALSE);
	}
	curwp->w_doto = doto;
d599 2
a600 26
	/*
	 * do the replacement:	If was capital, then place first
	 * char as if upper, and subsequent chars as if lower.
	 * If inserting upper, check replacement for case.
	 */
	while ((c = CHARMASK(*st++)) != '\0') {
		if ((rtype & _MG_U) != 0 && ISLOWER(c) != 0)
			c = TOUPPER(c);
		if (rtype == (_MG_U | _MG_L))
			rtype = _MG_L;
		if (c == CCHR('J')) {
			if (curwp->w_doto == llength(curwp->w_dotp))
				(void)forwchar(FFRAND, 1);
			else {
				if (ldelete((RSIZE) 1, KNONE) != FALSE)
					(void)lnewline();
			}
		} else if (curwp->w_dotp == curbp->b_linep) {
			(void)linsert(1, c);
		} else if (curwp->w_doto == llength(curwp->w_dotp)) {
			if (ldelete((RSIZE) 1, KNONE) != FALSE)
				(void)linsert(1, c);
		} else
			lputc(curwp->w_dotp, curwp->w_doto++, c);
	}
	lchange(WFHARD);
@


1.22
log
@This is a no binary change which does:

- spelling, punctuation fixes
- variable declaration lineup
- use parentheses for return and sizeof
- K&R function declarations -> ANSI
- other minor code beautification

ok henning@@
@
text
@d1 3
a3 1
/*	$OpenBSD: line.c,v 1.21 2004/07/09 13:50:40 vincent Exp $	*/
@


1.21
log
@when saving a file, check whether it is newline terminated and if it is not,
prompt the user and add the newline if he agrees.

tested by a lot of helpful tech@@ guys, approved by henning
@
text
@d1 1
a1 1
/*	$OpenBSD: line.c,v 1.20 2004/01/27 23:43:37 vincent Exp $	*/
d31 1
a31 1
#define NBLOCK	16		/* Line block chunk size	 */
d54 2
a55 2
	if ((lp = malloc(sizeof *lp)) == NULL)
		return NULL;
d61 1
a61 1
		return NULL;
d63 1
a63 1
	return lp;
d73 1
a73 1
			return FALSE;
d77 1
a77 2

	return TRUE;
d161 1
a161 1
	LINE *lp1;
d168 1
a168 1
		return FALSE;
d188 1
a188 1
			return FALSE;
d208 1
a208 1
		return TRUE;
d215 1
a215 1
			return FALSE;
d236 1
a236 1
	return TRUE;
d251 1
a251 1
	LINE *lp1;
d261 1
a261 1
		return FALSE;
d276 1
a276 1
			return FALSE;
d280 1
a280 1
			return FALSE;
d300 1
a300 1
		return TRUE;
a304 1

d307 1
a307 1
			return FALSE;
d328 1
a328 1
	return TRUE;
d348 1
a348 1
			return FALSE;
d356 1
a356 1
		return TRUE;
d364 1
a364 1
		return FALSE;
d383 1
a383 1
	return TRUE;
d395 1
a395 1
		return FALSE;
d397 1
a397 1
	return lnewline_at(curwp->w_dotp, curwp->w_doto);
d418 1
a418 1
		return FALSE;
d435 1
a435 1
			return FALSE;
d445 1
a445 1
				return FALSE;
d449 1
a449 1
				return FALSE;
d459 1
a459 1
					return FALSE;
d465 1
a465 1
					return FALSE;
d490 1
a490 1
	return TRUE;
d510 1
a510 1
		return FALSE;
d517 1
a517 1
		return TRUE;
d536 1
a536 1
		return TRUE;
d539 1
a539 1
		return FALSE;
d564 1
a564 1
	return TRUE;
a566 1

d583 1
a583 1
		return FALSE;
d618 1
a618 1
			return FALSE;
a650 1

d677 1
a677 1
		return FALSE;
d679 1
a679 1
		return FALSE;
d702 1
a702 1
		return FALSE;
d706 1
a706 1
		return FALSE;
d716 1
a716 1
	return TRUE;
d728 2
a729 2
		return -1;
	return CHARMASK(kbufp[n + kstart]);
@


1.20
log
@make mail-mode more intelligent on middle-of-line insertions, and add a
comment to change the wrapping column. (mail-set-margin)

tested by henning and phessler, thanks!
@
text
@d1 1
a1 1
/*	$OpenBSD: line.c,v 1.19 2003/11/09 01:11:14 vincent Exp $	*/
a332 4
/*
 * Insert a newline into the buffer at the current location of dot in the
 * current window.  The funny ass-backwards way is no longer used.
 */
d334 1
a334 1
lnewline(void)
d336 2
a337 2
	LINE	*lp1, *lp2;
	int	 doto, nlen;
a339 5
	if (curbp->b_flag & BFREADONLY) {
		ewprintf("Buffer is read only");
		return FALSE;
	}

d343 1
a343 1
	undo_add_insert(curwp->w_dotp, llength(curwp->w_dotp), 1);
a345 4
	/* Get the address and offset of "." */
	lp1 = curwp->w_dotp;
	doto = curwp->w_doto;

d389 14
d698 1
a698 2
kgrow(back)
	int back;
d729 1
a729 2
kremove(n)
	int n;
@


1.19
log
@remove the only use of the hackish undo_add_custom function.
@
text
@d1 1
a1 1
/*	$OpenBSD: line.c,v 1.18 2003/04/16 02:38:18 millert Exp $	*/
d151 90
d257 3
d439 1
a456 1
		cp2 = cp1 + chunk;
d471 3
a473 2
		while (cp2 != &dotp->l_text[dotp->l_used])
			*cp1++ = *cp2++;
@


1.18
log
@lalloc() - return NULL on error, not FALSE
lrealloc() - don't realloc if new size <= old size.  Avoids a realloc(p, 0)
vincent@@ OK
@
text
@d1 1
a1 1
/*	$OpenBSD: line.c,v 1.17 2002/07/01 14:33:44 vincent Exp $	*/
d258 3
a260 3
	/* XXX */
	undo_add_custom(1,INSERT, curwp->w_dotp, curwp->w_doto,
	    strdup("\n"), 1);
@


1.17
log
@KNF + ansi; from zyrnix (only the easy part of his diffs)
@
text
@d1 1
a1 1
/*	$OpenBSD: line.c,v 1.16 2002/03/18 01:45:54 vincent Exp $	*/
d55 1
a55 1
		return FALSE;
d71 6
a76 4
	if ((tmp = realloc(lp->l_text, newsize)) == NULL)
		return FALSE;
	lp->l_text = tmp;
	lp->l_size = newsize;
@


1.16
log
@ Enter the new undo code.  it is still disabled since it has bugs, but it's
somewhat more useful....

 ok millert@@ + no objections on ICB
@
text
@d1 1
a1 1
/*	$OpenBSD: line.c,v 1.15 2002/03/16 04:17:36 vincent Exp $	*/
d564 1
a564 1
kdelete()
d581 1
a581 2
kinsert(c, dir)
	int c, dir;
@


1.15
log
@ add readonly buffer support
 plus some KNF

 ok art@@
@
text
@d1 1
a1 1
/*	$OpenBSD: line.c,v 1.14 2002/02/21 04:21:05 vincent Exp $	*/
d204 1
a204 2
		if (!undoaction)
			undo_add_insert(lp2, 0, n);
d234 1
a234 2
	if (!undoaction)
		undo_add_insert(curwp->w_dotp, doto, n);
d256 3
a258 5
	if (!undoaction) {
		/* XXX */
		undo_add_custom(INSERT, curwp->w_dotp, curwp->w_doto,
		    strdup("\n"), 1);
	}
d327 1
a327 3
	if (!undoaction) {
		undo_add_delete(curwp->w_dotp, curwp->w_doto, n);
	}
d491 2
@


1.14
log
@ Save undo records for newline insertions.

 That makes mg behave more like GNU emacs.
@
text
@d1 1
a1 1
/*	$OpenBSD: line.c,v 1.13 2002/02/20 22:30:54 vincent Exp $	*/
d86 1
a86 2
lfree(lp)
	LINE *lp;
d130 1
a130 2
lchange(flag)
	int flag;
d158 1
a158 2
linsert(n, c)
	int n, c;
d165 5
d174 1
a174 1
	
d245 1
a245 1
lnewline()
d251 5
a263 1

d318 1
a318 3
ldelete(n, kflag)
	RSIZE n;
	int   kflag;
d326 5
d334 1
a334 1
	
d414 1
a414 1
ldelnewline()
d419 5
d486 1
a486 4
lreplace(plen, st, f)
	RSIZE	plen;	/* length to remove		 */
	char	*st;	/* replacement string		 */
	int	f;	/* case hack disable		 */
d492 6
a497 1
	
d516 1
a516 1
	
@


1.13
log
@ Add undo code to mg.

 needs further hacking.

 ok `whole bunch of people on icb'@@
@
text
@d1 1
a1 1
/*	$OpenBSD: line.c,v 1.12 2002/02/16 21:27:49 millert Exp $	*/
d250 7
@


1.12
log
@Part one of userland __P removal.  Done with a simple regexp with some minor hand editing to make comments line up correctly.  Another pass is forthcoming that handles the cases that could not be done automatically.
@
text
@d1 1
a1 1
/*	$OpenBSD: line.c,v 1.11 2002/02/14 14:24:21 deraadt Exp $	*/
d172 1
a172 1

a184 1

d202 2
a203 1

d233 2
a234 1

d315 4
d474 1
a474 1

d493 1
d537 1
@


1.11
log
@some KNF
@
text
@d1 1
a1 1
/*	$OpenBSD: line.c,v 1.10 2002/02/14 03:15:04 vincent Exp $	*/
d43 1
a43 1
static int	 kgrow		__P((int));
@


1.10
log
@ Oups, my chartypes commit broke this.

 Use mg specific _MG_U/_MG_L chartypes instead of systemwide ones.
@
text
@d1 1
a1 1
/*	$OpenBSD: line.c,v 1.9 2002/02/13 22:36:58 vincent Exp $	*/
d75 1
a75 1
	
d172 1
a172 1
	
d176 1
a176 1
		
d185 1
a185 1
		
d203 1
a203 1
		
d214 1
a214 1
	} 
d216 1
a216 1
	if (lp1->l_used != n) 
@


1.9
log
@ Make mg malloc the l_text element instead of reallocating whole LINE
 structures all the time.
@
text
@d1 1
a1 1
/*	$OpenBSD: line.c,v 1.8 2001/05/24 03:05:23 mickey Exp $	*/
d477 1
a477 1
	rtype = _L;
d480 1
a480 1
		rtype = _U | _L;
d484 1
a484 1
				rtype = _U;
d509 1
a509 1
		if ((rtype & _U) != 0 && ISLOWER(c) != 0)
d511 2
a512 2
		if (rtype == (_U | _L))
			rtype = _L;
@


1.8
log
@spaces
@
text
@d1 1
a1 1
/*	$OpenBSD: line.c,v 1.7 2001/05/23 22:36:14 art Exp $	*/
d46 2
a47 5
 * This routine allocates a block of memory large enough to hold a LINE
 * containing "used" characters. The block is rounded up to whatever
 * needs to be allocated. (use lallocx for lines likely to grow.)
 * Return a pointer to the new block, or NULL if there isn't any memory
 * left. Print a message in the message line if no space.
d50 1
a50 2
lalloc(used)
	int used;
d52 1
a52 2
	LINE	*lp;
	int	 size;
d54 7
a60 8
	/* any padding at the end of the structure is used */
	if ((size = used + OFFSET(LINE, l_text[0])) < sizeof(LINE))
	    size = sizeof(LINE);
#ifdef MALLOCROUND
	MALLOCROUND(size);	/* round up to a size optimal to malloc */
#endif
	if ((lp = malloc((unsigned)size)) == NULL) {
		ewprintf("Can't get %d bytes", size);
a62 2
	lp->l_size = size - OFFSET(LINE, l_text[0]);
	lp->l_used = used;
d66 2
a67 8
/*
 * Like lalloc, only round amount desired up because this line will
 * probably grow.  We always make room for at least one more char.
 * (thus making 0 not a special case anymore.)
 */
LINE *
lallocx(used)
	int used;
d69 1
a69 2
	int	 size;
	LINE	*lp;
d71 6
a76 4
	size = (NBLOCK + used) & ~(NBLOCK - 1);
	if ((lp = lalloc(size)) != NULL)
		lp->l_used = used;
	return lp;
d118 3
a120 1
	free((char *)lp);
d163 1
a163 1
	LINE	*lp1, *lp2, *lp3;
a166 1
	char	*cp1, *cp2;
d172 1
a172 1

d175 2
d183 1
a183 1
		if ((lp2 = lallocx(n)) == NULL)
d185 1
d203 1
a203 1
		/* NOSTRICT */
d209 4
a212 4
	/* NOSTRICT (2) */
	/* Hard case: reallocate */
	if (lp1->l_used + n > lp1->l_size) {
		if ((lp2 = lallocx(lp1->l_used + n)) == NULL)
d214 6
a219 25
		cp1 = &lp1->l_text[0];
		cp2 = &lp2->l_text[0];
		while (cp1 != &lp1->l_text[doto])
			*cp2++ = *cp1++;
		/* NOSTRICT */
		cp2 += n;
		while (cp1 != &lp1->l_text[lp1->l_used])
			*cp2++ = *cp1++;
		lp1->l_bp->l_fp = lp2;
		lp2->l_fp = lp1->l_fp;
		lp1->l_fp->l_bp = lp2;
		lp2->l_bp = lp1->l_bp;
		free((char *)lp1);
	/* Easy case: in place */
	} else {
		/* pretend there's a new line */
		lp2 = lp1;
		/* NOSTRICT */
		lp2->l_used += n;
		cp2 = &lp1->l_text[lp1->l_used];

		cp1 = cp2 - n;
		while (cp1 != &lp1->l_text[doto])
			*--cp2 = *--cp1;
	}
d222 1
a222 2
		lp2->l_text[doto + i] = c;

a223 2
		if (wp->w_linep == lp1)
			wp->w_linep = lp2;
a224 1
			wp->w_dotp = lp2;
a225 1
				/* NOSTRICT */
a228 1
			wp->w_markp = lp2;
a229 1
				/* NOSTRICT */
d233 1
d257 1
a257 1
		if ((lp2 = lallocx(0)) == NULL)
d273 1
a273 1
	if ((lp2 = lallocx(nlen)) == NULL)
d451 1
@


1.7
log
@Get rid of unnecessary casts of NULL.
@
text
@d1 1
a1 1
/*	$OpenBSD: line.c,v 1.6 2001/05/23 22:20:35 art Exp $	*/
d5 1
a5 1
 * 
d7 3
a9 3
 * utilities. They are the only routines that touch the text. They 
 * also touch the buffer and window structures to make sure that the 
 * necessary updating gets done.  There are routines in this file that 
d12 4
a15 4
 * Note that this code only updates the dot and mark values in the window 
 * list.  Since all the code acts on the current window, the buffer that 
 * we are editing must be displayed, which means that "b_nwnd" is non-zero, 
 * which means that the dot and mark values in the buffer headers are 
d22 1
a22 1
 * The number of bytes member from the start of the structure type should be 
d49 1
a49 1
 * Return a pointer to the new block, or NULL if there isn't any memory 
d94 2
a95 2
 * moved to offset 0 of the next line.  Unlink the line from whatever buffer 
 * it might be in, and release the memory.  The buffers are updated too; the 
d135 4
a138 4
 * This routine is called when a character changes in place in the current 
 * buffer. It updates all of the required flags in the buffer and window 
 * system. The flag used is passed as an argument; if the buffer is being 
 * displayed in more than 1 window we change EDIT to HARD. Set MODE if the 
d162 4
a165 4
 * Insert "n" copies of the character "c" at the current location of dot. 
 * In the easy case all that happens is the text is stored in the line.  
 * In the hard case, the line has to be reallocated.  When the window list 
 * is updated, take special care; I screwed it up once.  You always update 
d272 1
a272 1
 * Insert a newline into the buffer at the current location of dot in the 
d331 4
a334 4
 * This function deletes "n" bytes, starting at dot. It understands how to 
 * deal with end of lines, etc.  It returns TRUE if all of the characters 
 * were deleted, and FALSE if they were not (because dot ran into the end 
 * of the buffer.  The "kflag" indicates either no insertion, or direction 
d371 1
a371 1
			if (ldelnewline() == FALSE || 
d418 1
a418 1
 * Delete a newline and join the current line with the next line. If the next 
d420 4
a423 4
 * with the header line can be thought of as always being a successful 
 * operation.  Even if nothing is done, this makes the kill buffer work 
 * "right".  Easy cases can be done by shuffling data around.  Hard cases 
 * require that lines be moved about in memory.  Return FALSE on error and 
d487 3
a489 3
 * Replace plen characters before dot with argument string.  Control-J 
 * characters in st are interpreted as newlines.  There is a casehack 
 * disable flag (normally it likes to match case of replacement to what 
d494 3
a496 3
	RSIZE  plen;	/* length to remove		 */
	char  *st;	/* replacement string		 */
	int    f;	/* case hack disable		 */
d504 2
a505 2
	 * Find the capitalization of the word that was found.  f says use 
	 * exact case of replacement string (same thing that happens with 
d566 2
a567 2
 * Delete all of the text saved in the kill buffer.  Called by commands when 
 * a new kill context is created. The kill buffer array is released, just in 
d581 4
a584 4
 * Insert a character to the kill buffer, enlarging the buffer if there 
 * isn't any room. Always grow the buffer in chunks, on the assumption 
 * that if you put something in the kill buffer you are going to put more 
 * stuff there too later. Return TRUE if all is well, and FALSE on errors. 
d636 2
a637 2
 * This function gets characters from the kill buffer. If the character 
 * index "n" is off the end, it returns "-1". This lets the caller just 
@


1.6
log
@remove VOID. We're way beyond the point where this could build with an
ancient compiler.
@
text
@d1 1
a1 1
/*	$OpenBSD: line.c,v 1.5 2001/01/29 01:58:08 niklas Exp $	*/
d65 1
a65 1
	if ((lp = (LINE *)malloc((unsigned)size)) == NULL) {
d67 1
a67 1
		return (LINE *)NULL;
@


1.5
log
@$OpenBSD$
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d98 1
a98 1
VOID
d141 1
a141 1
VOID
d509 1
a509 1
	(VOID)backchar(FFARG | FFRAND, (int)plen);
d529 1
a529 1
		(VOID)ldelete((RSIZE) (plen - rlen), KNONE);
d548 1
a548 1
				(VOID)forwchar(FFRAND, 1);
d551 1
a551 1
					(VOID)lnewline();
d554 1
a554 1
			(VOID)linsert(1, c);
d557 1
a557 1
				(VOID)linsert(1, c);
d570 1
a570 1
VOID
@


1.4
log
@More -Wall anmd KNF, from op2@@tomahawk.SQUiSH.org
@
text
@d1 2
@


1.3
log
@The start of KNF + -Wall.  The code has been run through indent but
needs hand fixup.  I stopped at keymap.c...
@
text
@d3 6
a8 8
 * The functions in this file
 * are a general set of line management
 * utilities. They are the only routines that
 * touch the text. They also touch the buffer
 * and window structures, to make sure that the
 * necessary updating gets done. There are routines
 * in this file that handle the kill buffer too.
 * It isn't here for any good reason.
d10 4
a13 6
 * Note that this code only updates the dot and
 * mark values in the window list. Since all the code
 * acts on the current window, the buffer that we
 * are editing must be being displayed, which means
 * that "b_nwnd" is non zero, which means that the
 * dot and mark values in the buffer headers are
a15 1
#include	"def.h"
d17 6
a22 2
/* number of bytes member is from start of structure type	 */
/* should be computed at compile time				 */
d36 6
a41 4
static char    *kbufp = NULL;	/* Kill buffer data.		 */
static RSIZE    kused = 0;	/* # of bytes used in KB.	 */
static RSIZE    ksize = 0;	/* # of bytes allocated in KB.	 */
static RSIZE    kstart = 0;	/* # of first used byte in KB.	 */
d47 2
a48 2
 * Return a pointer to the new block, or NULL if there isn't
 * any memory left. Print a message in the message line if no space.
d52 1
a52 1
	int    used;
d54 2
a55 2
	LINE  *lp;
	int    size;
d59 1
a59 1
		size = sizeof(LINE);
d63 1
a63 1
	if ((lp = (LINE *) malloc((unsigned) size)) == NULL) {
d65 1
a65 1
		return (LINE *) NULL;
d79 1
a79 1
	int    used;
d81 2
a82 2
	int    size;
	LINE  *lp;
d91 4
a94 8
 * Delete line "lp". Fix all of the
 * links that might point at it (they are
 * moved to offset 0 of the next line.
 * Unlink the line from whatever buffer it
 * might be in. Release the memory. The
 * buffers are updated too; the magic conditions
 * described in the above comments don't hold
 * here.
d98 1
a98 1
	register LINE  *lp;
d100 2
a101 2
	register BUFFER *bp;
	register MGWIN *wp;
d129 1
a129 1
	free((char *) lp);
d133 5
a137 8
 * This routine gets called when
 * a character is changed in place in the
 * current buffer. It updates all of the required
 * flags in the buffer and window system. The flag
 * used is passed as an argument; if the buffer is being
 * displayed in more than 1 window we change EDIT to
 * HARD. Set MODE if the mode line needs to be
 * updated (the "*" has to be set).
d141 1
a141 1
	register int    flag;
d143 1
a143 1
	register MGWIN *wp;
d145 3
a147 2
	if ((curbp->b_flag & BFCHG) == 0) {	/* First change, so	 */
		flag |= WFMODE;	/* update mode lines.	 */
d160 6
a165 9
 * Insert "n" copies of the character "c"
 * at the current location of dot. In the easy case
 * all that happens is the text is stored in the line.
 * In the hard case, the line has to be reallocated.
 * When the window list is updated, take special
 * care; I screwed it up once. You always update dot
 * in the current window. You update mark, and a
 * dot in another window, if it is greater than
 * the place where you did the insert. Return TRUE
d168 1
d170 1
a170 1
	int             n;
d172 5
a176 8
	register char  *cp1;
	register char  *cp2;
	register LINE  *lp1;
	LINE           *lp2;
	LINE           *lp3;
	register int    doto;
	register RSIZE  i;
	MGWIN          *wp;
d179 7
a185 3
	lp1 = curwp->w_dotp;	/* Current line		 */
	if (lp1 == curbp->b_linep) {	/* At the end: special	 */
		/* (now should only happen in empty buffer	 */
d190 2
a191 1
		if ((lp2 = lallocx(n)) == NULL)	/* Allocate new line */
d193 4
a196 2
		lp3 = lp1->l_bp;/* Previous line	 */
		lp3->l_fp = lp2;/* Link in		 */
d214 2
a215 1
	doto = curwp->w_doto;	/* Save for later.	 */
d217 2
a218 1
	if (lp1->l_used + n > lp1->l_size) {	/* Hard: reallocate	 */
d233 5
a237 3
		free((char *) lp1);
	} else {		/* Easy: in place	 */
		lp2 = lp1;	/* Pretend new line	 */
d246 2
a247 1
	for (i = 0; i < n; ++i)	/* Add the characters	 */
d270 2
a271 3
 * Insert a newline into the buffer
 * at the current location of dot in the current
 * window.  The funny ass-backwards way is no longer used.
d273 1
d276 3
a278 5
	register LINE  *lp1;
	register LINE  *lp2;
	register int    doto;
	register int    nlen;
	MGWIN          *wp;
d281 9
a289 4
	lp1 = curwp->w_dotp;	/* Get the address and	 */
	doto = curwp->w_doto;	/* offset of "."	 */
	if (doto == 0) {	/* avoid unnessisary copying */
		if ((lp2 = lallocx(0)) == NULL)	/* new first part	 */
d300 6
a305 2
	nlen = llength(lp1) - doto;	/* length of new part	 */
	if ((lp2 = lallocx(nlen)) == NULL)	/* New second half line */
d314 2
a315 1
	for (wp = wheadp; wp != NULL; wp = wp->w_wndp) {	/* Windows	 */
d329 5
a333 7
 * This function deletes "n" bytes,
 * starting at dot. It understands how do deal
 * with end of lines, etc. It returns TRUE if all
 * of the characters were deleted, and FALSE if
 * they were not (because dot ran into the end of
 * the buffer. The "kflag" indicates either no insertion,
 * or direction of insertion into the kill buffer.
d335 1
d337 2
a338 1
	RSIZE           n;
d340 5
a344 6
	register char  *cp1;
	register char  *cp2;
	register LINE  *dotp;
	register int    doto;
	register RSIZE  chunk;
	MGWIN          *wp;
d356 2
a357 1
		if (dotp == curbp->b_linep)	/* Hit end of buffer.	 */
d359 2
a360 1
		chunk = dotp->l_used - doto;	/* Size of chunk.	 */
d363 2
a364 1
		if (chunk == 0) {	/* End of line, merge.	 */
d366 2
a367 1
				return FALSE;	/* End of buffer.	 */
d369 2
a370 2
			if (ldelnewline() == FALSE
			|| (kflag != KNONE && kinsert('\n', kflag) == FALSE))
d376 2
a377 1
		cp1 = &dotp->l_text[doto];	/* Scrunch text.	 */
d383 1
a383 1
			bcopy(cp1, &(kbufp[kused]), (int) chunk);
d389 1
a389 1
			bcopy(cp1, &(kbufp[kstart - chunk]), (int) chunk);
d395 1
a395 1
		dotp->l_used -= (int) chunk;
d416 7
a422 9
 * Delete a newline. Join the current line
 * with the next line. If the next line is the magic
 * header line always return TRUE; merging the last line
 * with the header line can be thought of as always being a
 * successful operation, even if nothing is done, and this makes
 * the kill buffer work "right". Easy cases can be done by
 * shuffling data around. Hard cases require that lines be moved
 * about in memory. Return FALSE on error and TRUE if all
 * looks ok.
d424 1
d427 2
a428 4
	register LINE  *lp1;
	register LINE  *lp2;
	register MGWIN *wp;
	LINE           *lp3;
d432 2
a433 1
	if (lp2 == curbp->b_linep)	/* At the buffer end.	 */
d452 1
a452 1
		free((char *) lp2);
d479 2
a480 2
	free((char *) lp1);
	free((char *) lp2);
d485 4
a488 4
 * Replace plen characters before dot with argument string.
 * Control-J characters in st are interpreted as newlines.
 * There is a casehack disable flag (normally it likes to match
 * case of replacement to what was there).
d490 1
d492 8
a499 8
	register RSIZE  plen;	/* length to remove		 */
	char           *st;	/* replacement string		 */
	int             f;	/* case hack disable		 */
{
	register RSIZE  rlen;	/* replacement length		 */
	register int    rtype;	/* capitalization		 */
	register int    c;	/* used for random characters	 */
	register int    doto;	/* offset into line		 */
d502 3
a504 3
	 * Find the capitalization of the word that was found.
	 * f says use exact case of replacement string (same thing that
	 * happens with lowercase found), so bypass check.
d507 1
a507 1
	(VOID) backchar(FFARG | FFRAND, (int) plen);
d527 1
a527 1
		(VOID) ldelete((RSIZE) (plen - rlen), KNONE);
d529 1
a529 1
		if (linsert((int) (rlen - plen), ' ') == FALSE)
d546 1
a546 1
				(VOID) forwchar(FFRAND, 1);
d549 1
a549 1
					(VOID) lnewline();
d552 1
a552 1
			(VOID) linsert(1, c);
d555 1
a555 1
				(VOID) linsert(1, c);
d564 3
a566 5
 * Delete all of the text
 * saved in the kill buffer. Called by commands
 * when a new kill context is being created. The kill
 * buffer array is released, just in case the buffer has
 * grown to immense size. No errors.
a570 1

d572 1
a572 1
		free((char *) kbufp);
d579 5
a583 7
 * Insert a character to the kill buffer,
 * enlarging the buffer if there isn't any room. Always
 * grow the buffer in chunks, on the assumption that if you
 * put something in the kill buffer you are going to put
 * more stuff there too later. Return TRUE if all is
 * well, and FALSE on errors. Print a message on
 * errors. Dir says whether to put it at back or front.
d585 1
d587 1
a588 1

d606 1
d608 1
d610 2
a611 2
	register int    nstart;
	register char  *nbufp;
d613 1
a613 1
	if ((unsigned) (ksize + KBLOCK) <= (unsigned) ksize) {
d618 2
a619 2
	if ((nbufp = malloc((unsigned) (ksize + KBLOCK))) == NULL) {
		ewprintf("Can't get %ld bytes", (long) (ksize + KBLOCK));
d623 1
a623 1
	bcopy(&(kbufp[kstart]), &(nbufp[nstart]), (int) (kused - kstart));
d625 1
a625 1
		free((char *) kbufp);
d634 3
a636 4
 * This function gets characters from
 * the kill buffer. If the character index "n" is
 * off the end, it returns "-1". This lets the caller
 * just scan along until it gets a "-1" back.
d638 1
d640 1
@


1.2
log
@change WINDOW -> MGWIN to avoid curses type conflict
convert to terminfo in tty*.c
add support for some keypad function keys (arrows, pgup, pgdown)
@
text
@d22 2
a23 2
/* number of bytes member is from start of structure type	*/
/* should be computed at compile time				*/
d30 1
a30 1
#define NBLOCK	16			/* Line block chunk size	*/
d34 1
a34 1
#define KBLOCK	256			/* Kill buffer block size.	*/
d37 4
a40 4
static char	*kbufp	= NULL;		/* Kill buffer data.		*/
static RSIZE	kused	= 0;		/* # of bytes used in KB.	*/
static RSIZE	ksize	= 0;		/* # of bytes allocated in KB.	*/
static RSIZE	kstart	= 0;		/* # of first used byte in KB.	*/
d50 5
a54 3
lalloc(used) register int used; {
	register LINE	*lp;
	register int	size;
d57 1
a57 1
	if((size = used + OFFSET(LINE, l_text[0])) < sizeof(LINE))
d60 1
a60 1
	MALLOCROUND(size);    /* round up to a size optimal to malloc */
d62 1
a62 1
	if((lp = (LINE *)malloc((unsigned)size)) == NULL) {
d64 1
a64 1
		return (LINE *)NULL;
d78 1
a78 1
int used;
d80 2
a81 2
	register int size;
	register LINE *lp;
d83 3
a85 2
	size = (NBLOCK+used) & ~(NBLOCK-1);
	if((lp = lalloc(size)) != NULL) lp->l_used = used;
d100 3
a102 1
lfree(lp) register LINE *lp; {
d106 1
a106 1
	for(wp = wheadp; wp != NULL; wp = wp->w_wndp) {
d109 3
a111 3
		if (wp->w_dotp	== lp) {
			wp->w_dotp  = lp->l_fp;
			wp->w_doto  = 0;
d118 1
a118 1
	for(bp = bheadp; bp != NULL; bp = bp->b_bufp) {
d120 1
a120 1
			if (bp->b_dotp	== lp) {
d146 3
a148 1
lchange(flag) register int flag; {
d151 2
a152 2
	if ((curbp->b_flag&BFCHG) == 0) {	/* First change, so	*/
		flag |= WFMODE;			/* update mode lines.	*/
d155 1
a155 1
	for(wp = wheadp; wp != NULL; wp = wp->w_wndp) {
d158 2
a159 1
			if(wp != curwp) wp->w_flag |= WFHARD;
d177 1
a177 1
int n;
d179 8
a186 8
	register char	*cp1;
	register char	*cp2;
	register LINE	*lp1;
	LINE		*lp2;
	LINE		*lp3;
	register int	doto;
	register RSIZE	i;
	MGWIN		*wp;
d189 3
a191 3
	lp1 = curwp->w_dotp;			/* Current line		*/
	if (lp1 == curbp->b_linep) {		/* At the end: special	*/
			/* (now should only happen in empty buffer	*/
d196 1
a196 1
		if ((lp2=lallocx(n)) == NULL) /* Allocate new line */
d198 2
a199 2
		lp3 = lp1->l_bp;		/* Previous line	*/
		lp3->l_fp = lp2;		/* Link in		*/
d203 1
a203 1
		for (i=0; i<n; ++i)
d205 1
a205 1
		for(wp = wheadp; wp != NULL; wp = wp->w_wndp) {
d213 1
a213 1
		/*NOSTRICT*/
d217 4
a220 4
	doto = curwp->w_doto;			/* Save for later.	*/
	/*NOSTRICT (2) */
	if (lp1->l_used+n > lp1->l_size) {	/* Hard: reallocate	*/
		if ((lp2=lallocx(lp1->l_used+n)) == NULL)
d226 1
a226 1
		/*NOSTRICT*/
d235 3
a237 3
	} else {				/* Easy: in place	*/
		lp2 = lp1;			/* Pretend new line	*/
		/*NOSTRICT*/
d241 1
a241 1
		cp1 = cp2-n;
d245 2
a246 2
	for (i=0; i<n; ++i)			/* Add the characters	*/
		lp2->l_text[doto+i] = c;
d248 1
a248 1
	for(wp = wheadp; wp != NULL; wp = wp->w_wndp) {
d253 2
a254 2
			if (wp==curwp || wp->w_doto>doto)
				/*NOSTRICT*/
d260 1
a260 1
				/*NOSTRICT*/
d274 5
a278 5
	register LINE	*lp1;
	register LINE	*lp2;
	register int	doto;
	register int	nlen;
	MGWIN		*wp;
d281 4
a284 4
	lp1  = curwp->w_dotp;			/* Get the address and	*/
	doto = curwp->w_doto;			/* offset of "."	*/
	if(doto == 0) {				/* avoid unnessisary copying */
		if((lp2 = lallocx(0)) == NULL)	/* new first part	*/
d290 4
a293 3
		for(wp = wheadp; wp!=NULL; wp = wp->w_wndp)
			if(wp->w_linep == lp1) wp->w_linep = lp2;
		return	TRUE;
d295 2
a296 2
	nlen = llength(lp1) - doto;		/* length of new part	*/
	if((lp2=lallocx(nlen)) == NULL)		/* New second half line */
d298 2
a299 1
	if(nlen!=0) bcopy(&lp1->l_text[doto], &lp2->l_text[0], nlen);
d305 1
a305 1
	for(wp = wheadp; wp != NULL; wp = wp->w_wndp) { /* Windows	*/
d327 9
a335 7
ldelete(n, kflag) RSIZE n; {
	register char	*cp1;
	register char	*cp2;
	register LINE	*dotp;
	register int	doto;
	register RSIZE	chunk;
	MGWIN		*wp;
d341 2
a342 1
	if (kused == kstart) kflag = KFORW;
d347 1
a347 1
		if (dotp == curbp->b_linep)	/* Hit end of buffer.	*/
d349 1
a349 1
		chunk = dotp->l_used-doto;	/* Size of chunk.	*/
d352 3
a354 3
		if (chunk == 0) {		/* End of line, merge.	*/
			if(dotp == lback(curbp->b_linep))
				return FALSE;	/* End of buffer.	*/
d357 1
a357 1
			|| (kflag!=KNONE && kinsert('\n', kflag)==FALSE))
d363 1
a363 1
		cp1 = &dotp->l_text[doto];	/* Scrunch text.	*/
d367 2
a368 1
				if (kgrow(FALSE) == FALSE) return FALSE;
d373 3
a375 2
				if (kgrow(TRUE) == FALSE) return FALSE;
			bcopy(cp1, &(kbufp[kstart-chunk]), (int) chunk);
d377 2
a378 1
		} else if (kflag != KNONE) panic("broken ldelete call");
d382 3
a384 3
		for(wp = wheadp; wp != NULL; wp = wp->w_wndp ) {
			if (wp->w_dotp==dotp && wp->w_doto>=doto) {
				/*NOSTRICT*/
d389 2
a390 2
			if (wp->w_markp==dotp && wp->w_marko>=doto) {
				/*NOSTRICT*/
d412 4
a415 3
ldelnewline() {
	register LINE	*lp1;
	register LINE	*lp2;
d417 1
a417 1
	LINE		*lp3;
d421 1
a421 1
	if (lp2 == curbp->b_linep)		/* At the buffer end.	*/
d425 1
a425 1
		for(wp = wheadp; wp != NULL; wp = wp->w_wndp) {
d429 1
a429 1
				wp->w_dotp  = lp1;
d433 1
a433 1
				wp->w_markp  = lp1;
d443 1
a443 1
	if ((lp3=lalloc(lp1->l_used + lp2->l_used)) == NULL)
d451 2
a452 2
	for(wp = wheadp; wp != NULL; wp = wp->w_wndp) {
		if (wp->w_linep==lp1 || wp->w_linep==lp2)
d455 1
a455 1
			wp->w_dotp  = lp3;
d457 1
a457 1
			wp->w_dotp  = lp3;
d461 1
a461 1
			wp->w_markp  = lp3;
d463 1
a463 1
			wp->w_markp  = lp3;
d479 8
a486 8
register RSIZE	plen;			/* length to remove		*/
char		*st;			/* replacement string		*/
int		f;			/* case hack disable		*/
{
	register RSIZE	rlen;		/* replacement length		*/
	register int	rtype;		/* capitalization		*/
	register int	c;		/* used for random characters	*/
	register int	doto;		/* offset into line		*/
d493 1
a493 1
	/*NOSTRICT*/
d497 4
a500 4
	if (ISUPPER(c)!=FALSE  &&  f==FALSE) {
		rtype = _U|_L;
		if (curwp->w_doto+1 < llength(curwp->w_dotp)) {
			c = lgetc(curwp->w_dotp, curwp->w_doto+1);
a505 1

d514 1
a514 1
		(VOID) ldelete((RSIZE) (plen-rlen), KNONE);
d516 1
a516 1
		if (linsert((int)(rlen-plen), ' ') == FALSE)
d527 1
a527 1
		if ((rtype&_U)!=0  &&  ISLOWER(c)!=0)
d529 1
a529 1
		if (rtype == (_U|_L))
d558 3
a560 1
kdelete() {
d577 2
a578 1
kinsert(c, dir) {
d584 6
a589 3
	if (dir == KFORW) kbufp[kused++] = c;
	else if (dir == KBACK) kbufp[--kstart] = c;
	else panic("broken kinsert call");		/* Oh shit! */
d597 4
a600 3
kgrow(back) {
	register int	nstart;
	register char	*nbufp;
d602 1
a602 1
	if ((unsigned)(ksize+KBLOCK) <= (unsigned)ksize) {
d607 2
a608 2
	if ((nbufp=malloc((unsigned)(ksize+KBLOCK))) == NULL) {
		ewprintf("Can't get %ld bytes", (long)(ksize+KBLOCK));
d611 2
a612 2
	nstart = (back == TRUE) ? (kstart + KBLOCK) : (KBLOCK / 4) ;
	bcopy(&(kbufp[kstart]), &(nbufp[nstart]), (int) (kused-kstart));
d615 1
a615 1
	kbufp  = nbufp;
d628 2
a629 1
kremove(n) {
@


1.1
log
@initial import of mg2a
@
text
@d99 1
a99 1
	register WINDOW *wp;
d142 1
a142 1
	register WINDOW *wp;
d178 1
a178 1
	WINDOW		*wp;
d270 1
a270 1
	WINDOW		*wp;
d323 1
a323 1
	WINDOW		*wp;
d399 1
a399 1
	register WINDOW *wp;
@

