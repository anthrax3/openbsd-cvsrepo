head	1.37;
access;
symbols
	OPENBSD_6_2:1.37.0.2
	OPENBSD_6_2_BASE:1.37
	OPENBSD_6_1:1.37.0.4
	OPENBSD_6_1_BASE:1.37
	OPENBSD_6_0:1.35.0.6
	OPENBSD_6_0_BASE:1.35
	OPENBSD_5_9:1.35.0.2
	OPENBSD_5_9_BASE:1.35
	OPENBSD_5_8:1.35.0.4
	OPENBSD_5_8_BASE:1.35
	OPENBSD_5_7:1.34.0.2
	OPENBSD_5_7_BASE:1.34
	OPENBSD_5_6:1.34.0.4
	OPENBSD_5_6_BASE:1.34
	OPENBSD_5_5:1.33.0.6
	OPENBSD_5_5_BASE:1.33
	OPENBSD_5_4:1.33.0.2
	OPENBSD_5_4_BASE:1.33
	OPENBSD_5_3:1.32.0.2
	OPENBSD_5_3_BASE:1.32
	OPENBSD_5_2:1.30.0.2
	OPENBSD_5_2_BASE:1.30
	OPENBSD_5_1_BASE:1.29
	OPENBSD_5_1:1.29.0.12
	OPENBSD_5_0:1.29.0.10
	OPENBSD_5_0_BASE:1.29
	OPENBSD_4_9:1.29.0.8
	OPENBSD_4_9_BASE:1.29
	OPENBSD_4_8:1.29.0.6
	OPENBSD_4_8_BASE:1.29
	OPENBSD_4_7:1.29.0.2
	OPENBSD_4_7_BASE:1.29
	OPENBSD_4_6:1.29.0.4
	OPENBSD_4_6_BASE:1.29
	OPENBSD_4_5:1.27.0.2
	OPENBSD_4_5_BASE:1.27
	OPENBSD_4_4:1.26.0.2
	OPENBSD_4_4_BASE:1.26
	OPENBSD_4_3:1.25.0.6
	OPENBSD_4_3_BASE:1.25
	OPENBSD_4_2:1.25.0.4
	OPENBSD_4_2_BASE:1.25
	OPENBSD_4_1:1.25.0.2
	OPENBSD_4_1_BASE:1.25
	OPENBSD_4_0:1.24.0.2
	OPENBSD_4_0_BASE:1.24
	OPENBSD_3_9:1.21.0.2
	OPENBSD_3_9_BASE:1.21
	OPENBSD_3_8:1.18.0.2
	OPENBSD_3_8_BASE:1.18
	OPENBSD_3_7:1.14.0.4
	OPENBSD_3_7_BASE:1.14
	OPENBSD_3_6:1.14.0.2
	OPENBSD_3_6_BASE:1.14
	OPENBSD_3_5:1.13.0.2
	OPENBSD_3_5_BASE:1.13
	OPENBSD_3_4:1.12.0.2
	OPENBSD_3_4_BASE:1.12
	OPENBSD_3_3:1.11.0.4
	OPENBSD_3_3_BASE:1.11
	OPENBSD_3_2:1.11.0.2
	OPENBSD_3_2_BASE:1.11
	OPENBSD_3_1:1.9.0.2
	OPENBSD_3_1_BASE:1.9
	OPENBSD_3_0:1.6.0.2
	OPENBSD_3_0_BASE:1.6
	OPENBSD_2_9_BASE:1.4
	OPENBSD_2_9:1.4.0.2
	OPENBSD_2_8:1.3.0.2
	OPENBSD_2_8_BASE:1.3
	OPENBSD_2_7:1.2.0.2
	OPENBSD_2_7_BASE:1.2;
locks; strict;
comment	@ * @;


1.37
date	2016.09.09.06.05.51;	author lum;	state Exp;
branches;
next	1.36;
commitid	ERFdFKnLF39uMpN0;

1.36
date	2016.09.08.07.50.09;	author lum;	state Exp;
branches;
next	1.35;
commitid	loNtvi2fWspP6yGd;

1.35
date	2015.03.19.21.22.15;	author bcallah;	state Exp;
branches;
next	1.34;
commitid	GbEBL4CfPvDkB8hj;

1.34
date	2014.03.20.07.47.29;	author lum;	state Exp;
branches;
next	1.33;

1.33
date	2013.05.22.19.23.45;	author lum;	state Exp;
branches;
next	1.32;

1.32
date	2012.12.27.18.49.59;	author florian;	state Exp;
branches;
next	1.31;

1.31
date	2012.10.26.20.46.12;	author florian;	state Exp;
branches;
next	1.30;

1.30
date	2012.04.11.17.51.10;	author lum;	state Exp;
branches;
next	1.29;

1.29
date	2009.06.05.18.02.06;	author kjell;	state Exp;
branches;
next	1.28;

1.28
date	2009.06.04.23.31.48;	author kjell;	state Exp;
branches;
next	1.27;

1.27
date	2008.09.15.16.11.35;	author kjell;	state Exp;
branches;
next	1.26;

1.26
date	2008.06.10.23.23.53;	author kjell;	state Exp;
branches;
next	1.25;

1.25
date	2006.12.16.17.00.03;	author kjell;	state Exp;
branches;
next	1.24;

1.24
date	2006.07.25.08.22.32;	author kjell;	state Exp;
branches;
next	1.23;

1.23
date	2006.07.08.17.50.30;	author kjell;	state Exp;
branches;
next	1.22;

1.22
date	2006.05.28.23.30.16;	author kjell;	state Exp;
branches;
next	1.21;

1.21
date	2005.12.15.19.39.19;	author kjell;	state Exp;
branches;
next	1.20;

1.20
date	2005.12.13.05.23.03;	author kjell;	state Exp;
branches;
next	1.19;

1.19
date	2005.11.18.20.56.53;	author deraadt;	state Exp;
branches;
next	1.18;

1.18
date	2005.08.09.00.53.48;	author kjell;	state Exp;
branches;
next	1.17;

1.17
date	2005.06.14.18.14.40;	author kjell;	state Exp;
branches;
next	1.16;

1.16
date	2005.06.05.05.15.56;	author kjell;	state Exp;
branches;
next	1.15;

1.15
date	2005.04.03.02.09.28;	author db;	state Exp;
branches;
next	1.14;

1.14
date	2004.07.22.01.25.25;	author vincent;	state Exp;
branches;
next	1.13;

1.13
date	2003.11.09.00.25.55;	author vincent;	state Exp;
branches;
next	1.12;

1.12
date	2003.05.20.03.08.55;	author cloder;	state Exp;
branches;
next	1.11;

1.11
date	2002.08.22.23.28.19;	author deraadt;	state Exp;
branches;
next	1.10;

1.10
date	2002.05.29.12.44.59;	author vincent;	state Exp;
branches;
next	1.9;

1.9
date	2002.02.20.22.30.54;	author vincent;	state Exp;
branches;
next	1.8;

1.8
date	2002.02.16.21.27.49;	author millert;	state Exp;
branches;
next	1.7;

1.7
date	2002.02.13.03.03.49;	author vincent;	state Exp;
branches;
next	1.6;

1.6
date	2001.05.24.03.05.26;	author mickey;	state Exp;
branches;
next	1.5;

1.5
date	2001.05.23.22.20.36;	author art;	state Exp;
branches;
next	1.4;

1.4
date	2001.01.29.01.58.09;	author niklas;	state Exp;
branches;
next	1.3;

1.3
date	2000.09.01.14.59.09;	author millert;	state Exp;
branches;
next	1.2;

1.2
date	2000.04.13.06.12.17;	author millert;	state Exp;
branches;
next	1.1;

1.1
date	2000.02.25.19.08.50;	author deraadt;	state Exp;
branches;
next	;


desc
@@


1.37
log
@Source Joachim Nilsson:

 Coverity Scan found this interesting buglet.  If read() fails the code,
 before this patch, would trigger a "Negative array index write".

ok florian@@
@
text
@/*	$OpenBSD: region.c,v 1.36 2016/09/08 07:50:09 lum Exp $	*/

/* This file is in the public domain. */

/*
 *		Region based commands.
 * The routines in this file deal with the region, that magic space between
 * "." and mark.  Some functions are commands.  Some functions are just for
 * internal use.
 */

#include <sys/queue.h>
#include <sys/socket.h>
#include <sys/types.h>
#include <sys/wait.h>
#include <errno.h>
#include <fcntl.h>
#include <poll.h>
#include <signal.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>

#include "def.h"

#define TIMEOUT 10000

static char leftover[BUFSIZ];

static	int	getregion(struct region *);
static	int	iomux(int, char * const, int, struct buffer *);
static	int	preadin(int, struct buffer *);
static	void	pwriteout(int, char **, int *);
static	int	setsize(struct region *, RSIZE);
static	int	shellcmdoutput(char * const[], char * const, int);

/*
 * Kill the region.  Ask "getregion" to figure out the bounds of the region.
 * Move "." to the start, and kill the characters. Mark is cleared afterwards.
 */
/* ARGSUSED */
int
killregion(int f, int n)
{
	int	s;
	struct region	region;

	if ((s = getregion(&region)) != TRUE)
		return (s);
	/* This is a kill-type command, so do magic kill buffer stuff. */
	if ((lastflag & CFKILL) == 0)
		kdelete();
	thisflag |= CFKILL;
	curwp->w_dotp = region.r_linep;
	curwp->w_doto = region.r_offset;
	curwp->w_dotline = region.r_lineno;
	s = ldelete(region.r_size, KFORW | KREG);
	clearmark(FFARG, 0);

	return (s);
}

/*
 * Copy all of the characters in the region to the kill buffer,
 * clearing the mark afterwards.
 * This is a bit like a kill region followed by a yank.
 */
/* ARGSUSED */
int
copyregion(int f, int n)
{
	struct line	*linep;
	struct region	 region;
	int	 loffs;
	int	 s;

	if ((s = getregion(&region)) != TRUE)
		return (s);

	/* kill type command */
	if ((lastflag & CFKILL) == 0)
		kdelete();
	thisflag |= CFKILL;

	/* current line */
	linep = region.r_linep;

	/* current offset */
	loffs = region.r_offset;

	while (region.r_size--) {
		if (loffs == llength(linep)) {	/* End of line.		 */
			if ((s = kinsert('\n', KFORW)) != TRUE)
				return (s);
			linep = lforw(linep);
			loffs = 0;
		} else {			/* Middle of line.	 */
			if ((s = kinsert(lgetc(linep, loffs), KFORW)) != TRUE)
				return (s);
			++loffs;
		}
	}
	clearmark(FFARG, 0);

	return (TRUE);
}

/*
 * Lower case region.  Zap all of the upper case characters in the region to
 * lower case. Use the region code to set the limits. Scan the buffer, doing
 * the changes. Call "lchange" to ensure that redisplay is done in all
 * buffers.
 */
/* ARGSUSED */
int
lowerregion(int f, int n)
{
	struct line	*linep;
	struct region	 region;
	int	 loffs, c, s;

	if ((s = checkdirty(curbp)) != TRUE)
		return (s);
	if (curbp->b_flag & BFREADONLY) {
		dobeep();
		ewprintf("Buffer is read-only");
		return (FALSE);
	}

	if ((s = getregion(&region)) != TRUE)
		return (s);

	undo_add_change(region.r_linep, region.r_offset, region.r_size);

	lchange(WFFULL);
	linep = region.r_linep;
	loffs = region.r_offset;
	while (region.r_size--) {
		if (loffs == llength(linep)) {
			linep = lforw(linep);
			loffs = 0;
		} else {
			c = lgetc(linep, loffs);
			if (ISUPPER(c) != FALSE)
				lputc(linep, loffs, TOLOWER(c));
			++loffs;
		}
	}
	return (TRUE);
}

/*
 * Upper case region.  Zap all of the lower case characters in the region to
 * upper case.  Use the region code to set the limits.  Scan the buffer,
 * doing the changes.  Call "lchange" to ensure that redisplay is done in all
 * buffers.
 */
/* ARGSUSED */
int
upperregion(int f, int n)
{
	struct line	 *linep;
	struct region	  region;
	int	  loffs, c, s;

	if ((s = checkdirty(curbp)) != TRUE)
		return (s);
	if (curbp->b_flag & BFREADONLY) {
		dobeep();
		ewprintf("Buffer is read-only");
		return (FALSE);
	}
	if ((s = getregion(&region)) != TRUE)
		return (s);

	undo_add_change(region.r_linep, region.r_offset, region.r_size);

	lchange(WFFULL);
	linep = region.r_linep;
	loffs = region.r_offset;
	while (region.r_size--) {
		if (loffs == llength(linep)) {
			linep = lforw(linep);
			loffs = 0;
		} else {
			c = lgetc(linep, loffs);
			if (ISLOWER(c) != FALSE)
				lputc(linep, loffs, TOUPPER(c));
			++loffs;
		}
	}
	return (TRUE);
}

/*
 * This routine figures out the bound of the region in the current window,
 * and stores the results into the fields of the REGION structure. Dot and
 * mark are usually close together, but I don't know the order, so I scan
 * outward from dot, in both directions, looking for mark. The size is kept
 * in a long. At the end, after the size is figured out, it is assigned to
 * the size field of the region structure. If this assignment loses any bits,
 * then we print an error. This is "type independent" overflow checking. All
 * of the callers of this routine should be ready to get an ABORT status,
 * because I might add a "if regions is big, ask before clobbering" flag.
 */
static int
getregion(struct region *rp)
{
	struct line	*flp, *blp;
	long	 fsize, bsize;

	if (curwp->w_markp == NULL) {
		dobeep();
		ewprintf("No mark set in this window");
		return (FALSE);
	}

	/* "r_size" always ok */
	if (curwp->w_dotp == curwp->w_markp) {
		rp->r_linep = curwp->w_dotp;
		rp->r_lineno = curwp->w_dotline;
		if (curwp->w_doto < curwp->w_marko) {
			rp->r_offset = curwp->w_doto;
			rp->r_size = (RSIZE)(curwp->w_marko - curwp->w_doto);
		} else {
			rp->r_offset = curwp->w_marko;
			rp->r_size = (RSIZE)(curwp->w_doto - curwp->w_marko);
		}
		return (TRUE);
	}
	/* get region size */
	flp = blp = curwp->w_dotp;
	bsize = curwp->w_doto;
	fsize = llength(flp) - curwp->w_doto + 1;
	while (lforw(flp) != curbp->b_headp || lback(blp) != curbp->b_headp) {
		if (lforw(flp) != curbp->b_headp) {
			flp = lforw(flp);
			if (flp == curwp->w_markp) {
				rp->r_linep = curwp->w_dotp;
				rp->r_offset = curwp->w_doto;
				rp->r_lineno = curwp->w_dotline;
				return (setsize(rp,
				    (RSIZE)(fsize + curwp->w_marko)));
			}
			fsize += llength(flp) + 1;
		}
		if (lback(blp) != curbp->b_headp) {
			blp = lback(blp);
			bsize += llength(blp) + 1;
			if (blp == curwp->w_markp) {
				rp->r_linep = blp;
				rp->r_offset = curwp->w_marko;
				rp->r_lineno = curwp->w_markline;
				return (setsize(rp,
				    (RSIZE)(bsize - curwp->w_marko)));
			}
		}
	}
	dobeep();
	ewprintf("Bug: lost mark");
	return (FALSE);
}

/*
 * Set size, and check for overflow.
 */
static int
setsize(struct region *rp, RSIZE size)
{
	rp->r_size = size;
	if (rp->r_size != size) {
		dobeep();
		ewprintf("Region is too large");
		return (FALSE);
	}
	return (TRUE);
}

#define PREFIXLENGTH 40
static char	prefix_string[PREFIXLENGTH] = {'>', '\0'};

/*
 * Prefix the region with whatever is in prefix_string.  Leaves dot at the
 * beginning of the line after the end of the region.  If an argument is
 * given, prompts for the line prefix string.
 */
/* ARGSUSED */
int
prefixregion(int f, int n)
{
	struct line	*first, *last;
	struct region	 region;
	char	*prefix = prefix_string;
	int	 nline;
	int	 s;

	if ((s = checkdirty(curbp)) != TRUE)
		return (s);
	if (curbp->b_flag & BFREADONLY) {
		dobeep();
		ewprintf("Buffer is read-only");
		return (FALSE);
	}
	if ((f == TRUE) && ((s = setprefix(FFRAND, 1)) != TRUE))
		return (s);

	/* get # of lines to affect */
	if ((s = getregion(&region)) != TRUE)
		return (s);
	first = region.r_linep;
	last = (first == curwp->w_dotp) ? curwp->w_markp : curwp->w_dotp;
	for (nline = 1; first != last; nline++)
		first = lforw(first);

	/* move to beginning of region */
	curwp->w_dotp = region.r_linep;
	curwp->w_doto = region.r_offset;
	curwp->w_dotline = region.r_lineno;

	/* for each line, go to beginning and insert the prefix string */
	while (nline--) {
		(void)gotobol(FFRAND, 1);
		for (prefix = prefix_string; *prefix; prefix++)
			(void)linsert(1, *prefix);
		(void)forwline(FFRAND, 1);
	}
	(void)gotobol(FFRAND, 1);
	return (TRUE);
}

/*
 * Set line prefix string. Used by prefixregion.
 */
/* ARGSUSED */
int
setprefix(int f, int n)
{
	char	buf[PREFIXLENGTH], *rep;
	int	retval;

	if (prefix_string[0] == '\0')
		rep = eread("Prefix string: ", buf, sizeof(buf),
		    EFNEW | EFCR);
	else
		rep = eread("Prefix string (default %s): ", buf, sizeof(buf),
		    EFNUL | EFNEW | EFCR, prefix_string);
	if (rep == NULL)
		return (ABORT);
	if (rep[0] != '\0') {
		(void)strlcpy(prefix_string, rep, sizeof(prefix_string));
		retval = TRUE;
	} else if (rep[0] == '\0' && prefix_string[0] != '\0') {
		/* CR -- use old one */
		retval = TRUE;
	} else
		retval = FALSE;
	return (retval);
}

int
region_get_data(struct region *reg, char *buf, int len)
{
	int	 i, off;
	struct line	*lp;

	off = reg->r_offset;
	lp = reg->r_linep;
	for (i = 0; i < len; i++) {
		if (off == llength(lp)) {
			lp = lforw(lp);
			if (lp == curbp->b_headp)
				break;
			off = 0;
			buf[i] = '\n';
		} else {
			buf[i] = lgetc(lp, off);
			off++;
		}
	}
	buf[i] = '\0';
	return (i);
}

void
region_put_data(const char *buf, int len)
{
	int i;

	for (i = 0; buf[i] != '\0' && i < len; i++) {
		if (buf[i] == '\n')
			lnewline();
		else
			linsert(1, buf[i]);
	}
}

/*
 * Mark whole buffer by first traversing to end-of-buffer
 * and then to beginning-of-buffer. Mark, dot are implicitly
 * set to eob, bob respectively during traversal.
 */
int
markbuffer(int f, int n)
{
	if (gotoeob(f,n) == FALSE)
		return (FALSE);
	if (gotobob(f,n) == FALSE)
		return (FALSE);
	return (TRUE);
}

/*
 * Pipe text from current region to external command.
 */
/*ARGSUSED */
int
piperegion(int f, int n)
{
	struct region region;
	int len;
	char *cmd, cmdbuf[NFILEN], *text;
	char *argv[] = {"sh", "-c", (char *) NULL, (char *) NULL};

	/* C-u M-| is not supported yet */
	if (n > 1)
		return (ABORT);

	if (curwp->w_markp == NULL) {
		dobeep();
		ewprintf("The mark is not set now, so there is no region");
		return (FALSE);
	}

	if ((cmd = eread("Shell command on region: ", cmdbuf, sizeof(cmdbuf),
	    EFNEW | EFCR)) == NULL || (cmd[0] == '\0'))
		return (ABORT);

	argv[2] = cmd;

	if (getregion(&region) != TRUE)
		return (FALSE);

	len = region.r_size;

	if ((text = malloc(len + 1)) == NULL) {
		dobeep();
		ewprintf("Cannot allocate memory.");
		return (FALSE);
	}

	region_get_data(&region, text, len);

	return shellcmdoutput(argv, text, len);
}

/*
 * Get command from mini-buffer and execute externally.
 */
/*ARGSUSED */
int
shellcommand(int f, int n)
{

	char *cmd, cmdbuf[NFILEN];
	char *argv[] = {"sh", "-c", (char *) NULL, (char *) NULL};

	if (n > 1)
		return (ABORT);

	if ((cmd = eread("Shell command: ", cmdbuf, sizeof(cmdbuf),
	    EFNEW | EFCR)) == NULL || (cmd[0] == '\0'))
		return (ABORT);

	argv[2] = cmd;

	return shellcmdoutput(argv, NULL, 0);
}


int
shellcmdoutput(char* const argv[], char* const text, int len)
{

	struct buffer *bp;
	char	*shellp;
	int	 ret;

	bp = bfind("*Shell Command Output*", TRUE);
	bp->b_flag |= BFREADONLY;
	if (bclear(bp) != TRUE) {
		free(text);
		return (FALSE);
	}

	shellp = getenv("SHELL");

	ret = pipeio(shellp, argv, text, len, bp);

	if (ret == TRUE) {
		eerase();
		if (lforw(bp->b_headp) == bp->b_headp)
			addline(bp, "(Shell command succeeded with no output)");
	}

	free(text);
	return (ret);
}

/*
 * Create a socketpair, fork and execv path with argv.
 * STDIN, STDOUT and STDERR of child process are redirected to socket.
 * Parent writes len chars from text to socket.
 */
int
pipeio(const char* const path, char* const argv[], char* const text, int len,
    struct buffer *outbp)
{
	int s[2], ret;
	char *err;
	pid_t pid;

	if (socketpair(AF_UNIX, SOCK_STREAM, PF_UNSPEC, s) == -1) {
		dobeep();
		ewprintf("socketpair error");
		return (FALSE);
	}

	switch((pid = fork())) {
	case -1:
		dobeep();
		ewprintf("Can't fork");
		return (FALSE);
	case 0:
		/* Child process */
		close(s[0]);
		if (dup2(s[1], STDIN_FILENO) == -1)
			_exit(1);
		if (dup2(s[1], STDOUT_FILENO) == -1)
			_exit(1);
		if (dup2(s[1], STDERR_FILENO) == -1)
			_exit(1);
		if (path == NULL)
			_exit(1);

		execv(path, argv);
		err = strerror(errno);
		write(s[1], err, strlen(err));
		_exit(1);
	default:
		/* Parent process */
		close(s[1]);
		ret = iomux(s[0], text, len, outbp);
		waitpid(pid, NULL, 0); /* Collect child to prevent zombies */

		return (ret);
	}
	return (FALSE);
}

/*
 * Multiplex read, write on socket fd passed. Put output in outbp
 * Poll on the fd for both read and write readiness.
 */
int
iomux(int fd, char* const text, int len, struct buffer *outbp)
{
	struct pollfd pfd[1];
	int nfds;
	char *textcopy;

	textcopy = text;
	fcntl(fd, F_SETFL, O_NONBLOCK);
	pfd[0].fd = fd;

	/* There is nothing to write if len is zero
	 * but the cmd's output should be read so shutdown 
	 * the socket for writing only and don't wait for POLLOUT
	 */
	if (len == 0) {
		shutdown(fd, SHUT_WR);
		pfd[0].events = POLLIN;
	} else
		pfd[0].events = POLLIN | POLLOUT;

	while ((nfds = poll(pfd, 1, TIMEOUT)) != -1 ||
	    (pfd[0].revents & (POLLERR | POLLHUP | POLLNVAL))) {
		if (pfd[0].revents & POLLOUT && len > 0)
			pwriteout(fd, &textcopy, &len);
		else if (pfd[0].revents & POLLIN)
			if (preadin(fd, outbp) == FALSE)
				break;
		if (len == 0 && pfd[0].events & POLLOUT)
			pfd[0].events = POLLIN;
	}
	close(fd);

	/* In case if last line doesn't have a '\n' add the leftover 
	 * characters to buffer.
	 */
	if (leftover[0] != '\0') {
		addline(outbp, leftover);
		leftover[0] = '\0';
	}
	if (nfds == 0) {
		dobeep();
		ewprintf("poll timed out");
		return (FALSE);
	} else if (nfds == -1) {
		dobeep();
		ewprintf("poll error");
		return (FALSE);
	}
	return (popbuftop(outbp, WNONE));
}

/*
 * Write some text from region to fd. Once done shutdown the 
 * write end.
 */
void
pwriteout(int fd, char **text, int *len)
{
	int w;

	if (((w = send(fd, *text, *len, MSG_NOSIGNAL)) == -1)) {
		switch(errno) {
		case EPIPE:
			*len = -1;
			break;
		case EAGAIN:
			return;
		}
	} else
		*len -= w;

	*text += w;
	if (*len <= 0)
		shutdown(fd, SHUT_WR);		
}

/*
 * Read some data from socket fd, break on '\n' and add
 * to buffer. If couldn't break on newline hold leftover
 * characters and append in next iteration.
 */
int
preadin(int fd, struct buffer *bp)
{
	int len;
	char buf[BUFSIZ], *p, *q;

	if ((len = read(fd, buf, BUFSIZ - 1)) <= 0)
		return (FALSE);

	buf[len] = '\0';
	p = q = buf;
	if (leftover[0] != '\0' && ((q = strchr(p, '\n')) != NULL)) {
		*q++ = '\0';
		if (strlcat(leftover, p, sizeof(leftover)) >=
		    sizeof(leftover)) {
			dobeep();
			ewprintf("line too long");
			return (FALSE);
		}
		addline(bp, leftover);
		leftover[0] = '\0';
		p = q;
	}
	while ((q = strchr(p, '\n')) != NULL) {
		*q++ = '\0';
		addline(bp, p);
		p = q;
	}
	if (strlcpy(leftover, p, sizeof(leftover)) >= sizeof(leftover)) {
		dobeep();
		ewprintf("line too long");
		return (FALSE);
	}
	return (TRUE);
}
@


1.36
log
@Source Joachim Nilsson:

 Collect forked off children from M-| command

 Mg left zombies from commands executed when piping a region of text to
 an external command.  This patch makes sure to collect for the child
 before returning.

ok sunil@@ millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: region.c,v 1.35 2015/03/19 21:22:15 bcallah Exp $	*/
d653 1
a653 1
	if ((len = read(fd, buf, BUFSIZ - 1)) == 0)
@


1.35
log
@Clean up the includes in mg.
This does the following:
Moves all POSIX headers from sysdef.h into the individual .c files so that
each file now only includes what it needs. All headers are properly sorted.
Moves the remainder of sysdef.h to other files (mostly def.h) and deletes
sysdef.h now that it's no longer contains anything.
Tweak a comment that references sysdef.h so that it no longer does that.
ok florian@@
@
text
@d1 1
a1 1
/*	$OpenBSD: region.c,v 1.34 2014/03/20 07:47:29 lum Exp $	*/
d15 1
d519 1
a519 1
	int s[2];
d521 1
d529 1
a529 1
	switch(fork()) {
d553 4
a556 1
		return (iomux(s[0], text, len, outbp));
@


1.34
log
@Add some missing dobeeps.
ok florian@@
@
text
@d1 1
a1 1
/*	$OpenBSD: region.c,v 1.33 2013/05/22 19:23:45 lum Exp $	*/
d12 2
d15 1
a15 2
#include <sys/socket.h>

d18 3
@


1.33
log
@Shuffle shell-command-on-region around to give shell-command.
ok florian@@ jasper@@
Testing Sunil Nimmagadda
@
text
@d1 1
a1 1
/*	$OpenBSD: region.c,v 1.32 2012/12/27 18:49:59 florian Exp $	*/
d121 1
d165 1
d209 1
d255 1
d268 1
d296 1
d425 1
d442 1
d518 1
d525 1
d597 1
d601 1
d653 1
d667 1
@


1.32
log
@Move code for shell-command-on-region around to make pipeio() usable
in other functions.
ok jasper@@, benno@@
@
text
@d1 1
a1 1
/*	$OpenBSD: region.c,v 1.31 2012/10/26 20:46:12 florian Exp $	*/
d31 1
d410 2
a411 3
	struct buffer *bp;
	int len, ret;
	char *cmd, cmdbuf[NFILEN], *shellp, *text;
d439 37
a482 1
	region_get_data(&region, text, len);
@


1.31
log
@- fix potential memory and fd leak
ok benno, lum
@
text
@d1 1
a1 1
/*	$OpenBSD: region.c,v 1.30 2012/04/11 17:51:10 lum Exp $	*/
d27 1
a27 2
static	int	iomux(int);
static	int	pipeio(const char *);
d408 5
a412 1
	char *cmd, cmdbuf[NFILEN];
d422 1
d427 32
a458 1
	return (pipeio(cmdbuf));
d462 3
a464 2
 * Create a socketpair, fork and execl cmd passed. STDIN, STDOUT
 * and STDERR of child process are redirected to socket.
d467 2
a468 1
pipeio(const char* const cmd)
d471 1
a471 1
	char *shellp;
d477 1
d491 1
a491 1
		if ((shellp = getenv("SHELL")) == NULL)
d493 4
a496 1
		execl(shellp, "sh", "-c", cmd, (char *)NULL);
d501 1
a501 1
		return iomux(s[0]);
d507 1
a507 2
 * Multiplex read, write on socket fd passed. First get the region,
 * find/create *Shell Command Output* buffer and clear it's contents.
d511 1
a511 1
iomux(int fd)
a512 2
	struct region region;
	struct buffer *bp;
d515 1
a515 11
	char *text, *textcopy;
	
	if (getregion(&region) != TRUE) {
		close(fd);
		return (FALSE);
	}

	if ((text = malloc(region.r_size + 1)) == NULL) {
		close(fd);
		return (ABORT);
	}
a516 1
	region_get_data(&region, text, region.r_size);
d519 3
a521 2
	
	/* There is nothing to write if r_size is zero
d523 1
a523 1
	 * the socket for writing only.
d525 1
a525 1
	if (region.r_size == 0)
d527 3
a529 8
	
	bp = bfind("*Shell Command Output*", TRUE);
	bp->b_flag |= BFREADONLY;
	if (bclear(bp) != TRUE) {
		close(fd);
		free(text);
		return (FALSE);
	}
a530 2
	pfd[0].fd = fd;
	pfd[0].events = POLLIN | POLLOUT;
d533 2
a534 2
		if (pfd[0].revents & POLLOUT && region.r_size > 0)
			pwriteout(fd, &textcopy, &region.r_size);	
d536 1
a536 1
			if (preadin(fd, bp) == FALSE)
d538 2
d542 1
a542 1
	free(text);
d547 1
a547 1
		addline(bp, leftover);
d557 1
a557 1
	return (popbuftop(bp, WNONE));
a593 1
	static int nooutput;
d596 1
a596 4
	if ((len = read(fd, buf, BUFSIZ - 1)) == 0) {
		if (nooutput == 0)
			addline(bp, "(Shell command succeeded with no output)");
		nooutput = 0;
d598 1
a598 2
	}
	nooutput = 1;
@


1.30
log
@Add:
 1. C-x h to mark whole buffer.
 2. M-| to pipe current region to external command.
From Sunil Nimmagadda.

Feedback from deraadt@@ and myself. ok for man page amendments from jmc@@
@
text
@d1 1
a1 1
/*	$OpenBSD: region.c,v 1.29 2009/06/05 18:02:06 kjell Exp $	*/
d479 2
a480 1
	if (getregion(&region) != TRUE)
d482 4
a485 2
	
	if ((text = malloc(region.r_size + 1)) == NULL)
d487 2
a488 1
	
d502 3
a504 1
	if (bclear(bp) != TRUE)
d506 1
@


1.29
log
@emacs handles the undo of a region kill (C-w) differently than a line kill
(C-k) with respect to cursor position. The former leaves the cursor at the end,
the latter at the beginning of the region.

emacs is wacky.

Make mg undo do the same. ok deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: region.c,v 1.28 2009/06/04 23:31:48 kjell Exp $	*/
d12 8
d22 4
d27 4
d385 212
@


1.28
log
@Fix problem where line numbers get out of sync on a region-kill (C-w).
Noticed and ok matthieu@@
@
text
@d1 1
a1 1
/*	$OpenBSD: region.c,v 1.27 2008/09/15 16:11:35 kjell Exp $	*/
d37 1
a37 1
	s = ldelete(region.r_size, KFORW);
@


1.27
log
@Enable dirty buffer detection in mg.
Emulate the emacs behavior: after suspend/resume, buffer switch,
or at save time, warn (prompt) the user if the file has been modified
on disk in the interim.
This has already saved my butt numerous times.
ok phessler
@
text
@d1 1
a1 1
/*	$OpenBSD: region.c,v 1.26 2008/06/10 23:23:53 kjell Exp $	*/
d36 1
d198 1
d218 1
d230 1
d292 1
@


1.26
log
@Add a clear-mark function.
Use it to clear the region it is copied (M-w), or yanked (C-w).
This matches xemacs behavior, is not horribly different from gnu
emacs, and way less wrong than the current behavior.
Noticed by Han Boetes. ok otto@@
@
text
@d1 1
a1 1
/*	$OpenBSD: region.c,v 1.25 2006/12/16 17:00:03 kjell Exp $	*/
d101 2
d144 2
d268 2
@


1.25
log
@Get rid of PREFIXREGION ifdef, since we always enable it anyway.
no binary change.
@
text
@d1 1
a1 1
/*	$OpenBSD: region.c,v 1.24 2006/07/25 08:22:32 kjell Exp $	*/
d19 1
a19 1
 * Move "." to the start, and kill the characters.
d37 2
a38 2
	if (s == TRUE && curwp->w_dotline > curwp->w_markline)
		curwp->w_dotline = curwp->w_markline;
d43 3
a45 2
 * Copy all of the characters in the region to the kill buffer.  Don't move
 * dot at all.  This is a bit like a kill region followed by a yank.
d82 2
@


1.24
log
@Rename the header line of a buffer to b_headp, from the remarkably
unintuitive b_linep. No binary change.
@
text
@d1 1
a1 1
/*	$OpenBSD: region.c,v 1.23 2006/07/08 17:50:30 kjell Exp $	*/
a242 9
#ifdef PREFIXREGION
/*
 * Implements one of my favorite keyboard macros; put a string at the
 * beginning of a number of lines in a buffer.	The quote string is
 * settable by using set-prefix-string.	 Great for quoting mail, which
 * is the real reason I wrote it, but also has uses for creating bar
 * comments (like the one you're reading) in C code.
 */

d292 1
a292 1
 * Set line prefix string.
a318 1
#endif /* PREFIXREGION */
@


1.23
log
@Fix a trio of bugs in line numbering: adjusting linenos after undo,
cutting a block, and off-by-one linecount. Initial bug discovered by
jason
@
text
@d1 1
a1 1
/*	$OpenBSD: region.c,v 1.22 2006/05/28 23:30:16 kjell Exp $	*/
d203 2
a204 2
	while (lforw(flp) != curbp->b_linep || lback(blp) != curbp->b_linep) {
		if (lforw(flp) != curbp->b_linep) {
d214 1
a214 1
		if (lback(blp) != curbp->b_linep) {
d341 1
a341 1
			if (lp == curbp->b_linep)
@


1.22
log
@Make Window Flags more mnemonic (and less dumb); i.e.
WFHARD -> WFFULL (Redraw full window)
WFFORCE -> WFFRAME (Reframe window).
No binary change
@
text
@d1 1
a1 1
/*	$OpenBSD: region.c,v 1.21 2005/12/15 19:39:19 kjell Exp $	*/
d36 4
a39 1
	return (ldelete(region.r_size, KFORW));
@


1.21
log
@NULL != '\0'. Spotted by Han Boetes and a linux gcc.
@
text
@d1 1
a1 1
/*	$OpenBSD: region.c,v 1.20 2005/12/13 05:23:03 kjell Exp $	*/
d105 1
a105 1
	lchange(WFHARD);
d145 1
a145 1
	lchange(WFHARD);
@


1.20
log
@If you're going to pass a length parameter, you should use it.
@
text
@d1 1
a1 1
/*	$OpenBSD: region.c,v 1.19 2005/11/18 20:56:53 deraadt Exp $	*/
d356 1
a356 1
	for (i = 0; buf[i] != NULL && i < len; i++) {
@


1.19
log
@greedy use of typedef struct was making code harder to read; ok kjell cloder
@
text
@d1 1
a1 1
/*	$OpenBSD: region.c,v 1.18 2005/08/09 00:53:48 kjell Exp $	*/
d351 1
a351 1
int
d356 1
a356 1
	for (i = 0; buf[i]; i++) {
a361 1
	return (0);
@


1.18
log
@Clean up eread handling in mg. (basically, fallout from the 'enter often
means abort' behaviour added during the hackathon). Eliminates
redundant ereply function, fixes miscellaneous cores when aborting,
and move a number of assumed pathnames into the prompt text, since
they are used there anyway. All changes consistent with emacs behavior

ok beck@@ many, many moons ago.
@
text
@d1 1
a1 1
/*	$OpenBSD: region.c,v 1.17 2005/06/14 18:14:40 kjell Exp $	*/
d14 2
a15 2
static	int	getregion(REGION *);
static	int	setsize(REGION *, RSIZE);
d26 1
a26 1
	REGION	region;
d47 2
a48 2
	LINE	*linep;
	REGION	 region;
d91 2
a92 2
	LINE	*linep;
	REGION	 region;
d132 2
a133 2
	LINE	 *linep;
	REGION	  region;
d174 1
a174 1
getregion(REGION *rp)
d176 1
a176 1
	LINE	*flp, *blp;
d230 1
a230 1
setsize(REGION *rp, RSIZE size)
d261 2
a262 2
	LINE	*first, *last;
	REGION	 region;
d328 1
a328 1
region_get_data(REGION *reg, char *buf, int len)
d331 1
a331 1
	LINE	*lp;
@


1.17
log
@Add explicit public domain notices to all public domain files.
ok millert@@, deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: region.c,v 1.16 2005/06/05 05:15:56 kjell Exp $	*/
d308 2
a309 1
		rep = ereply("Prefix string: ", buf, sizeof(buf));
d311 5
a315 3
		rep = eread("Prefix string (default %s): ",
		    buf, sizeof(buf), EFNUL | EFNEW | EFCR, prefix_string);
	if (rep != NULL && *rep != '\0') {
d318 1
a318 1
	} else if (*rep == '\0' && prefix_string[0] != '\0') {
@


1.16
log
@if functions permits null reply from minibuffer, use eread (with
EFNUL), not ereply.
ok cloder
@
text
@d1 3
a3 1
/*	$OpenBSD: region.c,v 1.15 2005/04/03 02:09:28 db Exp $	*/
@


1.15
log
@This is a no binary change which does:

- spelling, punctuation fixes
- variable declaration lineup
- use parentheses for return and sizeof
- K&R function declarations -> ANSI
- other minor code beautification

ok henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: region.c,v 1.14 2004/07/22 01:25:25 vincent Exp $	*/
d308 2
a309 2
		rep = ereply("Prefix string (default %s): ",
		    buf, sizeof(buf), prefix_string);
@


1.14
log
@stage 1 of the infinite minibuffer work - add support for on the fly
buffer reallocation in veread().  This commit only changes the API.
All the buffers have exactly the same bounds as before for now.

tested by a couple of my very helpful testers!
@
text
@d1 1
a1 1
/*	$OpenBSD: region.c,v 1.13 2003/11/09 00:25:55 vincent Exp $	*/
d51 1
a51 1
		return s;
d72 1
a72 1
				return s;
d76 1
a76 1
	return TRUE;
d99 1
a99 1
		return s;
d117 1
a117 1
	return TRUE;
d139 1
a139 1
		return s;
d157 1
a157 1
	return TRUE;
d169 1
a169 1
 * because I might add a "if regions is big, ask before clobberring" flag.
d192 1
a192 1
		return TRUE;
d221 1
a221 1
	return FALSE;
d233 1
a233 1
		return FALSE;
d235 1
a235 1
	return TRUE;
d270 1
a270 1
		return s;
d292 1
a292 1
	return TRUE;
d303 1
a303 1
	int retval;
d306 1
a306 1
		rep = ereply("Prefix string: ", buf, sizeof buf);
d309 1
a309 1
		    buf, sizeof buf, prefix_string);
d311 1
a311 1
		(void)strlcpy(prefix_string, rep, sizeof prefix_string);
d318 1
a318 1
	return retval;
a321 1

d325 2
a326 2
	int i, off;
	LINE *lp;
d343 1
a343 1
	return i;
d357 1
a357 1
	return 0;
@


1.13
log
@proper test for circular list traversal, and nul-terminate strings for
safety.
@
text
@d1 1
a1 1
/*	$OpenBSD: region.c,v 1.12 2003/05/20 03:08:55 cloder Exp $	*/
d302 2
a303 2
	char	buf[PREFIXLENGTH];
	int	s;
d306 1
a306 1
		s = ereply("Prefix string: ", buf, sizeof buf);
d308 11
a318 8
		s = ereply("Prefix string (default %s): ",
			   buf, sizeof buf, prefix_string);
	if (s == TRUE)
		(void)strlcpy(prefix_string, buf, sizeof prefix_string);
	/* CR -- use old one */
	if ((s == FALSE) && (prefix_string[0] != '\0'))
		s = TRUE;
	return s;
@


1.12
log
@Finish KNF of prototypes.  That should be all of them.
OK vincent@@
@
text
@d1 1
a1 1
/*	$OpenBSD: region.c,v 1.11 2002/08/22 23:28:19 deraadt Exp $	*/
a325 1
	i = 0;
d328 1
a328 1
	while (i < len) {
d331 1
a331 1
			if (lp == curwp->w_linep)
a338 1
		i++;
d340 1
d349 1
a349 1
	for (i = 0; i < len; i++) {
a356 2


@


1.11
log
@knf
@
text
@d1 1
a1 1
/*	$OpenBSD: region.c,v 1.10 2002/05/29 12:44:59 vincent Exp $	*/
d21 1
a21 2
killregion(f, n)
	int f, n;
d43 1
a43 2
copyregion(f, n)
	int f, n;
d87 1
a87 2
lowerregion(f, n)
	int f, n;
d128 1
a128 2
upperregion(f, n)
	int f, n;
d172 1
a172 2
getregion(rp)
	REGION *rp;
d228 1
a228 3
setsize(rp, size)
	REGION *rp;
	RSIZE   size;
d257 1
a257 2
prefixregion(f, n)
	int f, n;
d300 1
a300 2
setprefix(f, n)
	int f, n;
@


1.10
log
@Add a few missing tests for BFREADONLY.

ok art@@
@
text
@d1 1
a1 1
/*	$OpenBSD: region.c,v 1.9 2002/02/20 22:30:54 vincent Exp $	*/
d105 1
a105 1
	
d144 1
a144 1
	
d146 1
a146 1
		
d334 1
a334 1
	
@


1.9
log
@ Add undo code to mg.

 needs further hacking.

 ok `whole bunch of people on icb'@@
@
text
@d1 1
a1 1
/*	$OpenBSD: region.c,v 1.8 2002/02/16 21:27:49 millert Exp $	*/
d96 5
d138 4
d273 4
@


1.8
log
@Part one of userland __P removal.  Done with a simple regexp with some minor hand editing to make comments line up correctly.  Another pass is forthcoming that handles the cases that could not be done automatically.
@
text
@d1 1
a1 1
/*	$OpenBSD: region.c,v 1.7 2002/02/13 03:03:49 vincent Exp $	*/
d98 3
d135 3
d314 42
@


1.7
log
@ * Replace unsafe strcpy and strcat calls to safe strlcpy and strlcat.
 * Be a little bit more verbose about some errors
 * Fix some memory leaks in fileio.c

ok deraadt@@, art@@
@
text
@d1 1
a1 1
/*	$OpenBSD: region.c,v 1.6 2001/05/24 03:05:26 mickey Exp $	*/
d12 2
a13 2
static	int	getregion	__P((REGION *));
static	int	setsize		__P((REGION *, RSIZE));
@


1.6
log
@spaces
@
text
@d1 1
a1 1
/*	$OpenBSD: region.c,v 1.5 2001/05/23 22:20:36 art Exp $	*/
d301 1
a301 1
		(void)strcpy(prefix_string, buf);
@


1.5
log
@remove VOID. We're way beyond the point where this could build with an
ancient compiler.
@
text
@d1 1
a1 1
/*	$OpenBSD: region.c,v 1.4 2001/01/29 01:58:09 niklas Exp $	*/
d5 1
a5 1
 * The routines in this file deal with the region, that magic space between 
d39 1
a39 1
 * Copy all of the characters in the region to the kill buffer.  Don't move 
d82 3
a84 3
 * Lower case region.  Zap all of the upper case characters in the region to 
 * lower case. Use the region code to set the limits. Scan the buffer, doing 
 * the changes. Call "lchange" to ensure that redisplay is done in all 
d116 1
a116 1
 * Upper case region.  Zap all of the lower case characters in the region to 
d118 1
a118 1
 * doing the changes.  Call "lchange" to ensure that redisplay is done in all 
d150 8
a157 8
 * This routine figures out the bound of the region in the current window, 
 * and stores the results into the fields of the REGION structure. Dot and 
 * mark are usually close together, but I don't know the order, so I scan 
 * outward from dot, in both directions, looking for mark. The size is kept 
 * in a long. At the end, after the size is figured out, it is assigned to 
 * the size field of the region structure. If this assignment loses any bits, 
 * then we print an error. This is "type independent" overflow checking. All 
 * of the callers of this routine should be ready to get an ABORT status, 
d243 2
a244 2
 * Prefix the region with whatever is in prefix_string.  Leaves dot at the 
 * beginning of the line after the end of the region.  If an argument is 
@


1.4
log
@$OpenBSD$
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d275 1
a275 1
		(VOID)gotobol(FFRAND, 1);
d277 2
a278 2
			(VOID)linsert(1, *prefix);
		(VOID)forwline(FFRAND, 1);
d280 1
a280 1
	(VOID)gotobol(FFRAND, 1);
d301 1
a301 1
		(VOID)strcpy(prefix_string, buf);
@


1.3
log
@More -Wall anmd KNF, from op2@@tomahawk.SQUiSH.org
@
text
@d1 2
@


1.2
log
@The start of KNF + -Wall.  The code has been run through indent but
needs hand fixup.  I stopped at keymap.c...
@
text
@d3 2
a4 4
 * The routines in this file
 * deal with the region, that magic space
 * between "." and mark. Some functions are
 * commands. Some functions are just for
d7 5
a11 1
#include	"def.h"
d14 1
a14 2
 * Kill the region. Ask "getregion"
 * to figure out the bounds of the region.
d18 1
d20 1
d22 2
a23 2
	register int    s;
	REGION          region;
d27 4
a30 3
	if ((lastflag & CFKILL) == 0)	/* This is a kill type	 */
		kdelete();	/* command, so do magic */
	thisflag |= CFKILL;	/* kill buffer stuff.	 */
d37 2
a38 4
 * Copy all of the characters in the
 * region to the kill buffer. Don't move dot
 * at all. This is a bit like a kill region followed
 * by a yank.
d41 1
d43 1
d45 4
a48 5
	register LINE  *linep;
	register int    loffs;
	register int    s;
	REGION          region;
	VOID            kdelete();
d52 3
a54 1
	if ((lastflag & CFKILL) == 0)	/* Kill type command.	 */
d57 7
a63 2
	linep = region.r_linep;	/* Current line.	 */
	loffs = region.r_offset;/* Current offset.	 */
d70 1
a70 1
		} else {	/* Middle of line.	 */
d80 4
a83 5
 * Lower case region. Zap all of the upper
 * case characters in the region to lower case. Use
 * the region code to set the limits. Scan the buffer,
 * doing the changes. Call "lchange" to ensure that
 * redisplay is done in all buffers.
d86 1
d88 1
d90 3
a92 5
	register LINE  *linep;
	register int    loffs;
	register int    c;
	register int    s;
	REGION          region;
d114 4
a117 5
 * Upper case region. Zap all of the lower
 * case characters in the region to upper case. Use
 * the region code to set the limits. Scan the buffer,
 * doing the changes. Call "lchange" to ensure that
 * redisplay is done in all buffers.
d120 1
d122 1
d124 3
a126 6
	register LINE  *linep;
	register int    loffs;
	register int    c;
	register int    s;
	REGION          region;
	VOID            lchange();
d148 9
a156 11
 * This routine figures out the bound of the region
 * in the current window, and stores the results into the fields
 * of the REGION structure. Dot and mark are usually close together,
 * but I don't know the order, so I scan outward from dot, in both
 * directions, looking for mark. The size is kept in a long. At the
 * end, after the size is figured out, it is assigned to the size
 * field of the region structure. If this assignment loses any bits,
 * then we print an error. This is "type independent" overflow
 * checking. All of the callers of this routine should be ready to
 * get an ABORT status, because I might add a "if regions is big,
 * ask before clobberring" flag.
d158 1
d160 1
a160 1
	register REGION *rp;
d162 2
a163 4
	register LINE  *flp;
	register LINE  *blp;
	register long   fsize;	/* Long now.		 */
	register long   bsize;
d169 3
a171 1
	if (curwp->w_dotp == curwp->w_markp) {	/* "r_size" always ok.	 */
d175 1
a175 1
			rp->r_size = (RSIZE) (curwp->w_marko - curwp->w_doto);
d178 1
a178 1
			rp->r_size = (RSIZE) (curwp->w_doto - curwp->w_marko);
d182 2
a183 1
	flp = blp = curwp->w_dotp;	/* Get region size.	 */
d193 1
a193 1
					 (RSIZE) (fsize + curwp->w_marko)));
d204 1
a204 1
					 (RSIZE) (bsize - curwp->w_marko)));
d208 1
a208 1
	ewprintf("Bug: lost mark");	/* Gak!			 */
d215 1
d217 2
a218 2
	register REGION *rp;
	register RSIZE  size;
a219 1

d228 1
a228 1
#ifdef	PREFIXREGION
d238 1
a238 1
static char     prefix_string[PREFIXLENGTH] = {'>', '\0'};
d241 3
a243 4
 * Prefix the region with whatever is in prefix_string.
 * Leaves dot at the beginning of the line after the end
 * of the region.  If an argument is given, prompts for the
 * line prefix string.
a244 1

d246 1
d248 1
d250 5
a254 5
	register int    s;
	register LINE  *first, *last;
	register int    nline;
	REGION          region;
	char           *prefix = prefix_string;
d273 1
a273 1
		(VOID) gotobol(FFRAND, 1);
d275 2
a276 2
			(VOID) linsert(1, *prefix);
		(VOID) forwline(FFRAND, 1);
d278 1
a278 1
	(VOID) gotobol(FFRAND, 1);
d283 1
a283 1
 * Set prefix string.
a284 1

d286 1
d288 1
d290 2
a291 2
	char            buf[PREFIXLENGTH];
	register int    s;
d299 3
a301 2
		(VOID) strcpy(prefix_string, buf);
	if ((s == FALSE) && (prefix_string[0] != '\0'))	/* CR -- use old one */
d305 1
a305 1
#endif
@


1.1
log
@initial import of mg2a
@
text
@d16 1
a16 1
/*ARGSUSED*/
d19 2
a20 2
	register int	s;
	REGION		region;
d22 1
a22 1
	if ((s=getregion(&region)) != TRUE)
d24 3
a26 3
	if ((lastflag&CFKILL) == 0)		/* This is a kill type	*/
		kdelete();			/* command, so do magic */
	thisflag |= CFKILL;			/* kill buffer stuff.	*/
d38 1
a38 1
/*ARGSUSED*/
d41 5
a45 5
	register LINE	*linep;
	register int	loffs;
	register int	s;
	REGION		region;
	VOID		kdelete();
d47 1
a47 1
	if ((s=getregion(&region)) != TRUE)
d49 1
a49 1
	if ((lastflag&CFKILL) == 0)		/* Kill type command.	*/
d52 2
a53 2
	linep = region.r_linep;			/* Current line.	*/
	loffs = region.r_offset;		/* Current offset.	*/
d55 2
a56 2
		if (loffs == llength(linep)) {	/* End of line.		*/
			if ((s=kinsert('\n', KFORW)) != TRUE)
d60 2
a61 2
		} else {			/* Middle of line.	*/
			if ((s=kinsert(lgetc(linep, loffs), KFORW)) != TRUE)
d76 1
a76 1
/*ARGSUSED*/
d79 5
a83 5
	register LINE	*linep;
	register int	loffs;
	register int	c;
	register int	s;
	REGION		region;
d85 1
a85 1
	if ((s=getregion(&region)) != TRUE)
d111 1
a111 1
/*ARGSUSED*/
d114 6
a119 6
	register LINE	*linep;
	register int	loffs;
	register int	c;
	register int	s;
	REGION		region;
	VOID		lchange();
d121 1
a121 1
	if ((s=getregion(&region)) != TRUE)
d153 7
a159 5
getregion(rp) register REGION *rp; {
	register LINE	*flp;
	register LINE	*blp;
	register long	fsize;			/* Long now.		*/
	register long	bsize;
d165 1
a165 1
	if (curwp->w_dotp == curwp->w_markp) {	/* "r_size" always ok.	*/
d169 1
a169 1
			rp->r_size = (RSIZE) (curwp->w_marko-curwp->w_doto);
d172 1
a172 1
			rp->r_size = (RSIZE) (curwp->w_doto-curwp->w_marko);
d176 1
a176 1
	flp = blp = curwp->w_dotp;		/* Get region size.	*/
d178 2
a179 2
	fsize = llength(flp)-curwp->w_doto+1;
	while (lforw(flp)!=curbp->b_linep || lback(blp)!=curbp->b_linep) {
d186 1
a186 1
					(RSIZE) (fsize+curwp->w_marko)));
d188 1
a188 1
			fsize += llength(flp)+1;
d192 1
a192 1
			bsize += llength(blp)+1;
d197 1
a197 1
					(RSIZE) (bsize-curwp->w_marko)));
d201 1
a201 1
	ewprintf("Bug: lost mark");		/* Gak!			*/
d208 4
a211 1
setsize(rp, size) register REGION *rp; register RSIZE size; {
d231 1
a231 1
static char prefix_string[PREFIXLENGTH] = { '>', '\0' };
d240 1
a240 1
/*ARGSUSED*/
d243 5
a247 5
	register int	s;
	register LINE	*first, *last;
	register int	nline;
	REGION		region;
	char		*prefix = prefix_string;
d260 1
a260 1
	/*move to beginning of region */
d279 1
a279 1
/*ARGSUSED*/
d282 2
a283 2
	char		buf[PREFIXLENGTH];
	register int	s;
d286 1
a286 1
		s = ereply("Prefix string: ",buf,sizeof buf);
d289 1
a289 1
				buf,sizeof buf,prefix_string);
d292 1
a292 1
	if ((s == FALSE) && (prefix_string[0] != '\0')) /* CR -- use old one */
@

