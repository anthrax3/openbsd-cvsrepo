head	1.14;
access;
symbols
	OPENBSD_6_1:1.14.0.8
	OPENBSD_6_1_BASE:1.14
	OPENBSD_6_0:1.14.0.4
	OPENBSD_6_0_BASE:1.14
	OPENBSD_5_9:1.14.0.2
	OPENBSD_5_9_BASE:1.14
	OPENBSD_5_8:1.13.0.4
	OPENBSD_5_8_BASE:1.13
	OPENBSD_5_7:1.11.0.2
	OPENBSD_5_7_BASE:1.11
	OPENBSD_5_6:1.11.0.4
	OPENBSD_5_6_BASE:1.11
	OPENBSD_5_5:1.10.0.14
	OPENBSD_5_5_BASE:1.10
	OPENBSD_5_4:1.10.0.10
	OPENBSD_5_4_BASE:1.10
	OPENBSD_5_3:1.10.0.8
	OPENBSD_5_3_BASE:1.10
	OPENBSD_5_2:1.10.0.6
	OPENBSD_5_2_BASE:1.10
	OPENBSD_5_1_BASE:1.10
	OPENBSD_5_1:1.10.0.4
	OPENBSD_5_0:1.10.0.2
	OPENBSD_5_0_BASE:1.10
	OPENBSD_4_9:1.9.0.8
	OPENBSD_4_9_BASE:1.9
	OPENBSD_4_8:1.9.0.6
	OPENBSD_4_8_BASE:1.9
	OPENBSD_4_7:1.9.0.2
	OPENBSD_4_7_BASE:1.9
	OPENBSD_4_6:1.9.0.4
	OPENBSD_4_6_BASE:1.9
	OPENBSD_4_5:1.7.0.2
	OPENBSD_4_5_BASE:1.7
	OPENBSD_4_4:1.6.0.8
	OPENBSD_4_4_BASE:1.6
	OPENBSD_4_3:1.6.0.6
	OPENBSD_4_3_BASE:1.6
	OPENBSD_4_2:1.6.0.4
	OPENBSD_4_2_BASE:1.6
	OPENBSD_4_1:1.6.0.2
	OPENBSD_4_1_BASE:1.6
	OPENBSD_4_0:1.4.0.2
	OPENBSD_4_0_BASE:1.4
	OPENBSD_3_9:1.2.0.2
	OPENBSD_3_9_BASE:1.2;
locks; strict;
comment	@ * @;


1.14
date	2015.12.11.20.21.23;	author mmcc;	state Exp;
branches;
next	1.13;
commitid	fMxksA90Y2NKlI5v;

1.13
date	2015.03.19.21.22.15;	author bcallah;	state Exp;
branches;
next	1.12;
commitid	GbEBL4CfPvDkB8hj;

1.12
date	2015.03.16.13.47.48;	author bcallah;	state Exp;
branches;
next	1.11;
commitid	gSveQVkxMLs6vRqK;

1.11
date	2014.03.20.07.47.29;	author lum;	state Exp;
branches;
next	1.10;

1.10
date	2011.07.15.16.50.52;	author deraadt;	state Exp;
branches;
next	1.9;

1.9
date	2009.06.05.18.02.06;	author kjell;	state Exp;
branches;
next	1.8;

1.8
date	2009.06.04.02.23.37;	author kjell;	state Exp;
branches;
next	1.7;

1.7
date	2008.09.15.16.13.35;	author kjell;	state Exp;
branches;
next	1.6;

1.6
date	2006.11.19.16.51.19;	author deraadt;	state Exp;
branches;
next	1.5;

1.5
date	2006.11.17.08.45.31;	author kjell;	state Exp;
branches;
next	1.4;

1.4
date	2006.07.25.08.22.32;	author kjell;	state Exp;
branches;
next	1.3;

1.3
date	2006.05.28.23.30.16;	author kjell;	state Exp;
branches;
next	1.2;

1.2
date	2005.12.20.06.17.36;	author kjell;	state Exp;
branches;
next	1.1;

1.1
date	2005.11.22.05.02.44;	author kjell;	state Exp;
branches;
next	;


desc
@@


1.14
log
@Remove NULL-checks before free().
@
text
@/*	$OpenBSD: yank.c,v 1.13 2015/03/19 21:22:15 bcallah Exp $	*/

/* This file is in the public domain. */

/*
 *	kill ring functions
 */

#include <sys/queue.h>
#include <signal.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#include "def.h"

#define KBLOCK	 8192		/* Kill grow.                    */

static char	*kbufp = NULL;	/* Kill buffer data.		 */
static RSIZE	 kused = 0;	/* # of bytes used in KB.	 */
static RSIZE	 ksize = 0;	/* # of bytes allocated in KB.	 */
static RSIZE	 kstart = 0;	/* # of first used byte in KB.	 */

static int	 kgrow(int);

/*
 * Delete all of the text saved in the kill buffer.  Called by commands when
 * a new kill context is created. The kill buffer array is released, just in
 * case the buffer has grown to an immense size.  No errors.
 */
void
kdelete(void)
{
	if (kbufp != NULL) {
		free(kbufp);
		kbufp = NULL;
		kstart = kused = ksize = 0;
	}
}

/*
 * Insert a character to the kill buffer, enlarging the buffer if there
 * isn't any room. Always grow the buffer in chunks, on the assumption
 * that if you put something in the kill buffer you are going to put more
 * stuff there too later. Return TRUE if all is well, and FALSE on errors.
 * Print a message on errors.  Dir says whether to put it at back or front.
 * This call is ignored if  KNONE is set.
 */
int
kinsert(int c, int dir)
{
	if (dir == KNONE)
		return (TRUE);
	if (kused == ksize && dir == KFORW && kgrow(dir) == FALSE)
		return (FALSE);
	if (kstart == 0 && dir == KBACK && kgrow(dir) == FALSE)
		return (FALSE);
	if (dir == KFORW)
		kbufp[kused++] = c;
	else if (dir == KBACK)
		kbufp[--kstart] = c;
	else
		panic("broken kinsert call");	/* Oh shit! */
	return (TRUE);
}

/*
 * kgrow - just get more kill buffer for the callee. If dir = KBACK
 * we are trying to get space at the beginning of the kill buffer.
 */
static int
kgrow(int dir)
{
	int	 nstart;
	char	*nbufp;

	if ((unsigned)(ksize + KBLOCK) <= (unsigned)ksize) {
		/* probably 16 bit unsigned */
		dobeep();
		ewprintf("Kill buffer size at maximum");
		return (FALSE);
	}
	if ((nbufp = malloc((unsigned)(ksize + KBLOCK))) == NULL) {
		dobeep();
		ewprintf("Can't get %ld bytes", (long)(ksize + KBLOCK));
		return (FALSE);
	}
	nstart = (dir == KBACK) ? (kstart + KBLOCK) : (KBLOCK / 4);
	bcopy(&(kbufp[kstart]), &(nbufp[nstart]), (int)(kused - kstart));
	free(kbufp);
	kbufp = nbufp;
	ksize += KBLOCK;
	kused = kused - kstart + nstart;
	kstart = nstart;
	return (TRUE);
}

/*
 * This function gets characters from the kill buffer. If the character
 * index "n" is off the end, it returns "-1". This lets the caller just
 * scan along until it gets a "-1" back.
 */
int
kremove(int n)
{
	if (n < 0 || n + kstart >= kused)
		return (-1);
	return (CHARMASK(kbufp[n + kstart]));
}

/*
 * Copy a string into the kill buffer. kflag gives direction.
 * if KNONE, do nothing.
 */
int
kchunk(char *cp1, RSIZE chunk, int kflag)
{
	/*
	 * HACK - doesn't matter, and fixes back-over-nl bug for empty
	 *	kill buffers.
	 */
	if (kused == kstart)
		kflag = KFORW;

	if (kflag & KFORW) {
		while (ksize - kused < chunk)
			if (kgrow(kflag) == FALSE)
				return (FALSE);
		bcopy(cp1, &(kbufp[kused]), (int)chunk);
		kused += chunk;
	} else if (kflag & KBACK) {
		while (kstart < chunk)
			if (kgrow(kflag) == FALSE)
				return (FALSE);
		bcopy(cp1, &(kbufp[kstart - chunk]), (int)chunk);
		kstart -= chunk;
	}

	return (TRUE);
}

/*
 * Kill line.  If called without an argument, it kills from dot to the end
 * of the line, unless it is at the end of the line, when it kills the
 * newline.  If called with an argument of 0, it kills from the start of the
 * line to dot.  If called with a positive argument, it kills from dot
 * forward over that number of newlines.  If called with a negative argument
 * it kills any text before dot on the current line, then it kills back
 * abs(arg) lines.
 */
/* ARGSUSED */
int
killline(int f, int n)
{
	struct line	*nextp;
	RSIZE	 chunk;
	int	 i, c;

	/* clear kill buffer if last wasn't a kill */
	if ((lastflag & CFKILL) == 0)
		kdelete();
	thisflag |= CFKILL;
	if (!(f & FFARG)) {
		for (i = curwp->w_doto; i < llength(curwp->w_dotp); ++i)
			if ((c = lgetc(curwp->w_dotp, i)) != ' ' && c != '\t')
				break;
		if (i == llength(curwp->w_dotp))
			chunk = llength(curwp->w_dotp) - curwp->w_doto + 1;
		else {
			chunk = llength(curwp->w_dotp) - curwp->w_doto;
			if (chunk == 0)
				chunk = 1;
		}
	} else if (n > 0) {
		chunk = llength(curwp->w_dotp) - curwp->w_doto;
		nextp = lforw(curwp->w_dotp);
		if (nextp != curbp->b_headp)
			chunk++;		/* newline */
		if (nextp == curbp->b_headp)
			goto done;		/* EOL */
		i = n;
		while (--i) {
			chunk += llength(nextp);
			nextp = lforw(nextp);
			if (nextp != curbp->b_headp)
				chunk++;	/* newline */
			if (nextp == curbp->b_headp)
				break;		/* EOL */
		}
	} else {
		/* n <= 0 */
		chunk = curwp->w_doto;
		curwp->w_doto = 0;
		i = n;
		while (i++) {
			if (lforw(curwp->w_dotp))
				chunk++;
			curwp->w_dotp = lback(curwp->w_dotp);
			curwp->w_rflag |= WFMOVE;
			chunk += llength(curwp->w_dotp);
		}
	}
	/*
	 * KFORW here is a bug.  Should be KBACK/KFORW, but we need to
	 * rewrite the ldelete code (later)?
	 */
done:
	if (chunk)
		return (ldelete(chunk, KFORW));
	return (TRUE);
}

/*
 * Yank text back from the kill buffer.  This is really easy.  All of the work
 * is done by the standard insert routines.  All you do is run the loop, and
 * check for errors.  The blank lines are inserted with a call to "newline"
 * instead of a call to "lnewline" so that the magic stuff that happens when
 * you type a carriage return also happens when a carriage return is yanked
 * back from the kill buffer.  An attempt has been made to fix the cosmetic
 * bug associated with a yank when dot is on the top line of the window
 * (nothing moves, because all of the new text landed off screen).
 */
/* ARGSUSED */
int
yank(int f, int n)
{
	struct line	*lp;
	int	 c, i, nline;

	if (n < 0)
		return (FALSE);

	/* newline counting */
	nline = 0;

	undo_boundary_enable(FFRAND, 0);
	while (n--) {
		/* mark around last yank */
		isetmark();
		i = 0;
		while ((c = kremove(i)) >= 0) {
			if (c == '\n') {
				if (enewline(FFRAND, 1) == FALSE)
					return (FALSE);
				++nline;
			} else {
				if (linsert(1, c) == FALSE)
					return (FALSE);
			}
			++i;
		}
	}
	/* cosmetic adjustment */
	lp = curwp->w_linep;

	/* if offscreen insert */
	if (curwp->w_dotp == lp) {
		while (nline-- && lback(lp) != curbp->b_headp)
			lp = lback(lp);
		/* adjust framing */
		curwp->w_linep = lp;
		curwp->w_rflag |= WFFULL;
	}
	undo_boundary_enable(FFRAND, 1);
	return (TRUE);
}

@


1.13
log
@Clean up the includes in mg.
This does the following:
Moves all POSIX headers from sysdef.h into the individual .c files so that
each file now only includes what it needs. All headers are properly sorted.
Moves the remainder of sysdef.h to other files (mostly def.h) and deletes
sysdef.h now that it's no longer contains anything.
Tweak a comment that references sysdef.h so that it no longer does that.
ok florian@@
@
text
@d1 1
a1 1
/*	$OpenBSD: yank.c,v 1.12 2015/03/16 13:47:48 bcallah Exp $	*/
d90 1
a90 2
	if (kbufp != NULL)
		free(kbufp);
@


1.12
log
@Change the internal name of the newline function to deconflict with a
function of the same name in term.h. This is the first step towards
cleaning up mg's includes. No user-visible changes.
ok florian@@
@
text
@d1 1
a1 1
/*	$OpenBSD: yank.c,v 1.11 2014/03/20 07:47:29 lum Exp $	*/
d9 6
d17 1
a17 5
#include <string.h>

#ifndef KBLOCK
#define KBLOCK	256		/* Kill buffer block size.	 */
#endif
@


1.11
log
@Add some missing dobeeps.
ok florian@@
@
text
@d1 1
a1 1
/*	$OpenBSD: yank.c,v 1.10 2011/07/15 16:50:52 deraadt Exp $	*/
d242 1
a242 1
				if (newline(FFRAND, 1) == FALSE)
@


1.10
log
@When killing lines using ^U <n> ^K, count the characters exactly (for
both forwards and backwards cases, though the forward case is better
tested.  This is required because the actual character deleter
function (ldelete) requires an exact count.  If it runs short, it will
not put the deletion into the kill buffer.  This is complicated by how
mg internals consider newline's as counted characters even though they
do not occur in the buffers... and then there is the no newline at EOF
fiasco....
@
text
@d1 1
a1 1
/*	$OpenBSD: yank.c,v 1.9 2009/06/05 18:02:06 kjell Exp $	*/
d77 1
d82 1
@


1.9
log
@emacs handles the undo of a region kill (C-w) differently than a line kill
(C-k) with respect to cursor position. The former leaves the cursor at the end,
the latter at the beginning of the region.

emacs is wacky.

Make mg undo do the same. ok deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: yank.c,v 1.8 2009/06/04 02:23:37 kjell Exp $	*/
d172 1
a172 1
		chunk = llength(curwp->w_dotp) - curwp->w_doto + 1;
d174 4
d180 4
d185 1
a185 3
				break;
			chunk += llength(nextp) + 1;
			nextp = lforw(nextp);
d193 2
a194 2
			if (lback(curwp->w_dotp) == curbp->b_headp)
				break;
d197 1
a197 1
			chunk += llength(curwp->w_dotp) + 1;
d204 4
a207 1
	return (ldelete(chunk, KFORW));
@


1.8
log
@Rename w_flag to w_rflag. This is not a general purpose
flag: it is for redisplay options only. I need an additional all-purpose
flag, so renaming removes the desire to wrongly overload the existing one.

Turdshine. No functional chage.
@
text
@d1 1
a1 1
/*	$OpenBSD: yank.c,v 1.7 2008/09/15 16:13:35 kjell Exp $	*/
d122 1
a122 1
	if (kflag == KFORW) {
d128 1
a128 1
	} else if (kflag == KBACK) {
d134 1
a134 2
	} else if (kflag != KNONE)
		panic("broken ldelete call");
@


1.7
log
@Expose the undo commands as proper mg functions.
This should have no functional change on undo, but it does facilitate
testing undo behavior.
@
text
@d1 1
a1 1
/*	$OpenBSD: yank.c,v 1.6 2006/11/19 16:51:19 deraadt Exp $	*/
d191 1
a191 1
			curwp->w_flag |= WFMOVE;
d251 1
a251 1
		curwp->w_flag |= WFFULL;
@


1.6
log
@spacing
@
text
@d1 1
a1 1
/*	$OpenBSD: yank.c,v 1.5 2006/11/17 08:45:31 kjell Exp $	*/
d225 1
a225 2
	undo_add_boundary();
	undo_boundary_enable(FALSE);
d253 1
a253 2
	undo_boundary_enable(TRUE);
	undo_add_boundary();
@


1.5
log
@Fix a needless inversion of flag names; i.e. change them from the
negative to the positive. undo_boundary_enable(TRUE) makes a LOT more
sense than undo_no_boundary(FALSE).
While here, whack a global, and fix a bug noted by otto:
undoing a file insertion sometimes left stray characters around.
ok beck@@, otto@@
@
text
@d1 1
a1 1
/*	$OpenBSD: yank.c,v 1.4 2006/07/25 08:22:32 kjell Exp $	*/
d45 1
a45 1
 * This call is ignored if  KNONE is set. 
@


1.4
log
@Rename the header line of a buffer to b_headp, from the remarkably
unintuitive b_linep. No binary change.
@
text
@d1 1
a1 1
/*	$OpenBSD: yank.c,v 1.3 2006/05/28 23:30:16 kjell Exp $	*/
d226 1
a226 1
	undo_no_boundary(TRUE);
d254 1
a254 1
	undo_no_boundary(FALSE);
@


1.3
log
@Make Window Flags more mnemonic (and less dumb); i.e.
WFHARD -> WFFULL (Redraw full window)
WFFORCE -> WFFRAME (Reframe window).
No binary change
@
text
@d1 1
a1 1
/*	$OpenBSD: yank.c,v 1.2 2005/12/20 06:17:36 kjell Exp $	*/
d177 1
a177 1
			if (nextp == curbp->b_linep)
d188 1
a188 1
			if (lback(curwp->w_dotp) == curbp->b_linep)
d248 1
a248 1
		while (nline-- && lback(lp) != curbp->b_linep)
@


1.2
log
@Clean up the ugly casted frees. In one case, this meant eliminating a nasty
struct/union/casting nightmare when building the list of names for filename
completion. In particular, be consistent about strduping and freeing
the list data.
@
text
@d1 1
a1 1
/*	$OpenBSD: yank.c,v 1.1 2005/11/22 05:02:44 kjell Exp $	*/
d252 1
a252 1
		curwp->w_flag |= WFHARD;
@


1.1
log
@Move kill-related commands to their own file.
This will help move to a kill-ring.
@
text
@d1 1
a1 1
/*	$OpenBSD: line.c,v 1.32 2005/11/22 04:38:57 kjell Exp $	*/
d33 1
a33 1
		free((char *)kbufp);
d87 1
a87 1
		free((char *)kbufp);
@

