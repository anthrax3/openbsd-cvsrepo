head	1.12;
access;
symbols
	OPENBSD_6_2:1.12.0.12
	OPENBSD_6_2_BASE:1.12
	OPENBSD_6_1:1.12.0.10
	OPENBSD_6_1_BASE:1.12
	OPENBSD_6_0:1.12.0.6
	OPENBSD_6_0_BASE:1.12
	OPENBSD_5_9:1.12.0.2
	OPENBSD_5_9_BASE:1.12
	OPENBSD_5_8:1.12.0.4
	OPENBSD_5_8_BASE:1.12
	OPENBSD_5_7:1.11.0.32
	OPENBSD_5_7_BASE:1.11
	OPENBSD_5_6:1.11.0.36
	OPENBSD_5_6_BASE:1.11
	OPENBSD_5_5:1.11.0.34
	OPENBSD_5_5_BASE:1.11
	OPENBSD_5_4:1.11.0.30
	OPENBSD_5_4_BASE:1.11
	OPENBSD_5_3:1.11.0.28
	OPENBSD_5_3_BASE:1.11
	OPENBSD_5_2:1.11.0.26
	OPENBSD_5_2_BASE:1.11
	OPENBSD_5_1_BASE:1.11
	OPENBSD_5_1:1.11.0.24
	OPENBSD_5_0:1.11.0.22
	OPENBSD_5_0_BASE:1.11
	OPENBSD_4_9:1.11.0.20
	OPENBSD_4_9_BASE:1.11
	OPENBSD_4_8:1.11.0.18
	OPENBSD_4_8_BASE:1.11
	OPENBSD_4_7:1.11.0.14
	OPENBSD_4_7_BASE:1.11
	OPENBSD_4_6:1.11.0.16
	OPENBSD_4_6_BASE:1.11
	OPENBSD_4_5:1.11.0.12
	OPENBSD_4_5_BASE:1.11
	OPENBSD_4_4:1.11.0.10
	OPENBSD_4_4_BASE:1.11
	OPENBSD_4_3:1.11.0.8
	OPENBSD_4_3_BASE:1.11
	OPENBSD_4_2:1.11.0.6
	OPENBSD_4_2_BASE:1.11
	OPENBSD_4_1:1.11.0.4
	OPENBSD_4_1_BASE:1.11
	OPENBSD_4_0:1.11.0.2
	OPENBSD_4_0_BASE:1.11
	OPENBSD_3_9:1.10.0.4
	OPENBSD_3_9_BASE:1.10
	OPENBSD_3_8:1.10.0.2
	OPENBSD_3_8_BASE:1.10
	OPENBSD_3_7:1.8.0.8
	OPENBSD_3_7_BASE:1.8
	OPENBSD_3_6:1.8.0.6
	OPENBSD_3_6_BASE:1.8
	OPENBSD_3_5:1.8.0.4
	OPENBSD_3_5_BASE:1.8
	OPENBSD_3_4:1.8.0.2
	OPENBSD_3_4_BASE:1.8
	OPENBSD_3_3:1.7.0.8
	OPENBSD_3_3_BASE:1.7
	OPENBSD_3_2:1.7.0.6
	OPENBSD_3_2_BASE:1.7
	OPENBSD_3_1:1.7.0.4
	OPENBSD_3_1_BASE:1.7
	OPENBSD_3_0:1.7.0.2
	OPENBSD_3_0_BASE:1.7
	OPENBSD_2_9_BASE:1.6
	OPENBSD_2_9:1.6.0.2
	OPENBSD_2_8:1.5.0.2
	OPENBSD_2_8_BASE:1.5
	OPENBSD_2_7:1.4.0.2
	OPENBSD_2_7_BASE:1.4;
locks; strict;
comment	@ * @;


1.12
date	2015.03.19.21.22.15;	author bcallah;	state Exp;
branches;
next	1.11;
commitid	GbEBL4CfPvDkB8hj;

1.11
date	2006.08.01.22.16.03;	author jason;	state Exp;
branches;
next	1.10;

1.10
date	2005.06.14.18.14.40;	author kjell;	state Exp;
branches;
next	1.9;

1.9
date	2005.04.03.02.09.28;	author db;	state Exp;
branches;
next	1.8;

1.8
date	2003.05.20.03.08.55;	author cloder;	state Exp;
branches;
next	1.7;

1.7
date	2001.05.24.03.05.26;	author mickey;	state Exp;
branches;
next	1.6;

1.6
date	2001.01.29.01.58.09;	author niklas;	state Exp;
branches;
next	1.5;

1.5
date	2000.09.01.14.59.09;	author millert;	state Exp;
branches;
next	1.4;

1.4
date	2000.04.13.06.12.17;	author millert;	state Exp;
branches;
next	1.3;

1.3
date	2000.03.03.19.31.26;	author millert;	state Exp;
branches;
next	1.2;

1.2
date	2000.02.25.19.13.21;	author deraadt;	state Exp;
branches;
next	1.1;

1.1
date	2000.02.25.19.08.51;	author deraadt;	state Exp;
branches;
next	;


desc
@@


1.12
log
@Clean up the includes in mg.
This does the following:
Moves all POSIX headers from sysdef.h into the individual .c files so that
each file now only includes what it needs. All headers are properly sorted.
Moves the remainder of sysdef.h to other files (mostly def.h) and deletes
sysdef.h now that it's no longer contains anything.
Tweak a comment that references sysdef.h so that it no longer does that.
ok florian@@
@
text
@/*	$OpenBSD: spawn.c,v 1.11 2006/08/01 22:16:03 jason Exp $	*/

/* This file is in the public domain. */

/*
 * Spawn.  Actually just suspends Mg.
 * Assumes POSIX job control.
 */

#include <sys/queue.h>
#include <signal.h>
#include <stdio.h>
#include <term.h>
#include <termios.h>

#include "def.h"

/*
 * This causes mg to send itself a stop signal.  It assumes the parent
 * shell supports POSIX job control.  If the terminal supports an alternate
 * screen, we will switch to it.
 */
/* ARGSUSED */
int
spawncli(int f, int n)
{
	sigset_t	oset;

	/* Very similar to what vttidy() does. */
	ttcolor(CTEXT);
	ttnowindow();
	ttmove(nrow - 1, 0);
	if (epresf != FALSE) {
		tteeol();
		epresf = FALSE;
	}
	if (ttcooked() == FALSE)
		return (FALSE);

	/* Exit application mode and tidy. */
	tttidy();
	ttflush();
	(void)sigprocmask(SIG_SETMASK, NULL, &oset);
	(void)kill(0, SIGTSTP);
	(void)sigprocmask(SIG_SETMASK, &oset, NULL);
	ttreinit();

	/* Force repaint. */
	sgarbf = TRUE;
	return (ttraw());
}
@


1.11
log
@* move sys/queue.h inclusion to sysdef.h (it's system specific)
* add <signal.h> to sysdef.h (needed for sig_atomic_t on linux, and
we get it by accident on OpenBSD)
* remove <signal.h> from tty.c/spawn.c (not needed now that it's in sysdef.h)
ok beck
@
text
@d1 1
a1 1
/*	$OpenBSD: spawn.c,v 1.10 2005/06/14 18:14:40 kjell Exp $	*/
d10 6
a16 3

#include <termios.h>
#include <term.h>
@


1.10
log
@Add explicit public domain notices to all public domain files.
ok millert@@, deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: spawn.c,v 1.9 2005/04/03 02:09:28 db Exp $	*/
a11 1
#include <signal.h>
@


1.9
log
@This is a no binary change which does:

- spelling, punctuation fixes
- variable declaration lineup
- use parentheses for return and sizeof
- K&R function declarations -> ANSI
- other minor code beautification

ok henning@@
@
text
@d1 3
a3 1
/*	$OpenBSD: spawn.c,v 1.8 2003/05/20 03:08:55 cloder Exp $	*/
@


1.8
log
@Finish KNF of prototypes.  That should be all of them.
OK vincent@@
@
text
@d1 1
a1 1
/*	$OpenBSD: spawn.c,v 1.7 2001/05/24 03:05:26 mickey Exp $	*/
d34 1
a34 1
		return(FALSE);
d46 1
a46 1
	return ttraw();
@


1.7
log
@spaces
@
text
@d1 1
a1 1
/*	$OpenBSD: spawn.c,v 1.6 2001/01/29 01:58:09 niklas Exp $	*/
d21 1
a21 2
spawncli(f, n)
	int f, n;
@


1.6
log
@$OpenBSD$
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d15 2
a16 2
 * This causes mg to send itself a stop signal.  It assumes the parent 
 * shell supports POSIX job control.  If the terminal supports an alternate 
@


1.5
log
@More -Wall anmd KNF, from op2@@tomahawk.SQUiSH.org
@
text
@d1 2
@


1.4
log
@The start of KNF + -Wall.  The code has been run through indent but
needs hand fixup.  I stopped at keymap.c...
@
text
@a4 1
#include	"def.h"
d6 5
a10 3
#include	<signal.h>
#include	<termios.h>
#include	<term.h>
d13 3
a15 3
 * This causes mg to send itself a stop signal.
 * Assumes the parent shell supports POSIX job control.
 * If the terminal supports an alternate screen, we will sitch to it.
d18 1
d20 1
d22 1
a22 2
	sigset_t oset;
	int ttputc __P((int)); /* XXX */
d33 4
a36 2
		return (FALSE);
	tttidy();		/* Exit application mode and tidy. */
d38 3
a40 3
	(void) sigprocmask(SIG_SETMASK, NULL, &oset);
	(void) kill(0, SIGTSTP);
	(void) sigprocmask(SIG_SETMASK, &oset, NULL);
d42 3
a44 1
	sgarbf = TRUE;		/* Force repaint.	 */
@


1.3
log
@Reverse rutgers change (attachtoparent vs. spawncli)

New ttreinit function that enters application mode, enables the keypad
and resets the tty size.

New spawn module that calls tttidy() to exit application mode (and cleanup)
then calls ttreinit() after resume to get back into application mode.  Assumes
we have job control.  This takes advantage of the xterm 'alternate screen'.
@
text
@d9 1
@


1.2
log
@further pruning
@
text
@d2 2
a3 4
 * Name:	MicroGnuEmacs
 *		Spawn CLI for System V.
 *
 * Spawn for System V.
d8 1
a8 3

char	*shellp	= NULL;			/* Saved "SHELL" program.	*/
char	*shname = NULL;			/* Saved shell name		*/
d11 3
a13 6
 * On System V, we no gots job control, so always run
 * a subshell using fork/exec. Bound to "C-C", and used
 * as a subcommand by "C-Z". (daveb)
 *
 * Returns 0 if the shell executed OK, something else if
 * we couldn't start shell or it exited badly.
d15 1
d18 2
a19 6
	register int	pid;
	register int	wpid;
	register void	(*oqsig)();
	register void	(*oisig)();
	int		status;
	int		errp = FALSE;
d21 1
a21 10
	if (shellp == NULL) {
		shellp = getenv("SHELL");
		if (shellp == NULL)
			shellp = getenv("shell");
		if (shellp == NULL)
			shellp = "/bin/sh";	/* Safer.		*/
		shname = strrchr( shellp, '/' ); 
		shname = shname ? shname++ : shellp;
		
	}
d24 1
a24 1
	ttmove(nrow-1, 0);
d29 5
a33 58
	ttclose();
	sgarbf = TRUE;				/* Force repaint.	*/
	oqsig = signal(SIGQUIT, SIG_IGN);
	oisig = signal(SIGINT,  SIG_IGN);
	if ((pid=fork()) == 0) {
		(void) signal(SIGINT, oisig);
		(void) signal(SIGQUIT, oqsig);
		execlp(shellp, shname, "-i", (char *)NULL);
		_exit(1);			/* Should do better!	*/
	}
	else if (pid > 0) {
		while ((wpid=wait(&status))>=0 && wpid!=pid)
			;
	}
	else errp = TRUE;

	signal(SIGINT,  oisig);
	signal(SIGQUIT, oqsig);
	ttopen();
	setttysize();
	ttwindow();

	if(errp)
		ewprintf("Failed to create process");

	return ( errp | status );
}

/*
 * Put the tty in normal mode, so he can do a second ^Z.  Then
 * wait for a char.  To use ^Z^Z to suspend and "fg %mg CR CR"
 * to continue;
 *
 * Returns 0 if it works, which presumably it must.
 */
attachtoparent(f, n)
{
	register int	pid;
	register int	wpid;
	register int	(*oqsig)();
	register int	(*oisig)();
	int		status;
	int		errp = FALSE;
	int		omask;
	sigset_t	newsig,oldsig;

	ttcolor(CTEXT);
	ttnowindow();
	ttmove(nrow-1, 0);
	if (epresf != FALSE) {
		tteeol();
		epresf = FALSE;
	}
	ttclose();
	sgarbf = TRUE;				/* Force repaint.	*/
#ifdef SIGTSTP
	sigemptyset(&newsig);
	sigprocmask(SIG_SETMASK, &newsig, &oldsig);
d35 4
a38 9
	sigprocmask(SIG_SETMASK, &oldsig, NULL);
#else
	getchar();
#endif
	ttopen();
	setttysize();
	ttwindow();

	return ( 0 );
@


1.1
log
@initial import of mg2a
@
text
@a13 2
extern	char	*getenv();

a23 1
	extern char	*strrchr();
d26 2
a27 2
	register int	(*oqsig)();
	register int	(*oisig)();
a84 1
	extern char	*strrchr();
@

