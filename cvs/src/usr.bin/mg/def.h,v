head	1.155;
access;
symbols
	OPENBSD_6_1:1.155.0.4
	OPENBSD_6_1_BASE:1.155
	OPENBSD_6_0:1.155.0.2
	OPENBSD_6_0_BASE:1.155
	OPENBSD_5_9:1.154.0.2
	OPENBSD_5_9_BASE:1.154
	OPENBSD_5_8:1.147.0.4
	OPENBSD_5_8_BASE:1.147
	OPENBSD_5_7:1.141.0.2
	OPENBSD_5_7_BASE:1.141
	OPENBSD_5_6:1.141.0.4
	OPENBSD_5_6_BASE:1.141
	OPENBSD_5_5:1.139.0.4
	OPENBSD_5_5_BASE:1.139
	OPENBSD_5_4:1.138.0.2
	OPENBSD_5_4_BASE:1.138
	OPENBSD_5_3:1.134.0.2
	OPENBSD_5_3_BASE:1.134
	OPENBSD_5_2:1.124.0.2
	OPENBSD_5_2_BASE:1.124
	OPENBSD_5_1_BASE:1.118
	OPENBSD_5_1:1.118.0.2
	OPENBSD_5_0:1.116.0.4
	OPENBSD_5_0_BASE:1.116
	OPENBSD_4_9:1.116.0.2
	OPENBSD_4_9_BASE:1.116
	OPENBSD_4_8:1.113.0.2
	OPENBSD_4_8_BASE:1.113
	OPENBSD_4_7:1.112.0.2
	OPENBSD_4_7_BASE:1.112
	OPENBSD_4_6:1.112.0.4
	OPENBSD_4_6_BASE:1.112
	OPENBSD_4_5:1.108.0.2
	OPENBSD_4_5_BASE:1.108
	OPENBSD_4_4:1.106.0.2
	OPENBSD_4_4_BASE:1.106
	OPENBSD_4_3:1.100.0.4
	OPENBSD_4_3_BASE:1.100
	OPENBSD_4_2:1.100.0.2
	OPENBSD_4_2_BASE:1.100
	OPENBSD_4_1:1.99.0.2
	OPENBSD_4_1_BASE:1.99
	OPENBSD_4_0:1.96.0.2
	OPENBSD_4_0_BASE:1.96
	OPENBSD_3_9:1.83.0.2
	OPENBSD_3_9_BASE:1.83
	OPENBSD_3_8:1.64.0.2
	OPENBSD_3_8_BASE:1.64
	OPENBSD_3_7:1.59.0.2
	OPENBSD_3_7_BASE:1.59
	OPENBSD_3_6:1.56.0.2
	OPENBSD_3_6_BASE:1.56
	OPENBSD_3_5:1.54.0.2
	OPENBSD_3_5_BASE:1.54
	OPENBSD_3_4:1.48.0.2
	OPENBSD_3_4_BASE:1.48
	OPENBSD_3_3:1.45.0.2
	OPENBSD_3_3_BASE:1.45
	OPENBSD_3_2:1.44.0.2
	OPENBSD_3_2_BASE:1.44
	OPENBSD_3_1:1.39.0.2
	OPENBSD_3_1_BASE:1.39
	OPENBSD_3_0:1.21.0.2
	OPENBSD_3_0_BASE:1.21
	OPENBSD_2_9_BASE:1.6
	OPENBSD_2_9:1.6.0.2
	OPENBSD_2_8:1.5.0.2
	OPENBSD_2_8_BASE:1.5
	OPENBSD_2_7:1.4.0.2
	OPENBSD_2_7_BASE:1.4;
locks; strict;
comment	@ * @;


1.155
date	2016.04.14.17.05.32;	author lum;	state Exp;
branches;
next	1.154;
commitid	SjhPISg2Q1dkB5Xg;

1.154
date	2016.01.02.10.39.19;	author lum;	state Exp;
branches;
next	1.153;
commitid	cWRm8x2aZlyBJTgu;

1.153
date	2015.12.29.19.44.32;	author lum;	state Exp;
branches;
next	1.152;
commitid	zQwbtQmO8Wf9dGsD;

1.152
date	2015.10.29.19.46.47;	author lum;	state Exp;
branches;
next	1.151;
commitid	PxYPCO6Bag1LXTJ7;

1.151
date	2015.10.12.19.08.39;	author lum;	state Exp;
branches;
next	1.150;
commitid	aNH8NmTWvN6cB4Om;

1.150
date	2015.09.29.02.07.49;	author guenther;	state Exp;
branches;
next	1.149;
commitid	CahbaEqQk6XXuFul;

1.149
date	2015.09.26.15.03.15;	author lum;	state Exp;
branches;
next	1.148;
commitid	0ywCmEETZEbQQnyp;

1.148
date	2015.09.24.07.07.59;	author lum;	state Exp;
branches;
next	1.147;
commitid	ilbGNsJo2VDLtO5r;

1.147
date	2015.06.03.23.40.01;	author bcallah;	state Exp;
branches;
next	1.146;
commitid	CQOgDk07oNMjC1Ge;

1.146
date	2015.05.08.12.35.08;	author bcallah;	state Exp;
branches;
next	1.145;
commitid	ipAmBG33jNfxs4qI;

1.145
date	2015.03.25.20.53.31;	author bcallah;	state Exp;
branches;
next	1.144;
commitid	zjZpBYab6uFsAfUg;

1.144
date	2015.03.25.12.25.36;	author bcallah;	state Exp;
branches;
next	1.143;
commitid	wxpmevSdJTEN4Uqg;

1.143
date	2015.03.19.21.22.15;	author bcallah;	state Exp;
branches;
next	1.142;
commitid	GbEBL4CfPvDkB8hj;

1.142
date	2015.03.16.13.47.48;	author bcallah;	state Exp;
branches;
next	1.141;
commitid	gSveQVkxMLs6vRqK;

1.141
date	2014.04.03.20.17.12;	author lum;	state Exp;
branches;
next	1.140;

1.140
date	2014.03.22.11.05.37;	author lum;	state Exp;
branches;
next	1.139;

1.139
date	2013.12.23.14.58.16;	author lum;	state Exp;
branches;
next	1.138;

1.138
date	2013.05.31.18.03.43;	author lum;	state Exp;
branches;
next	1.137;

1.137
date	2013.05.30.04.17.25;	author lum;	state Exp;
branches;
next	1.136;

1.136
date	2013.05.22.19.23.45;	author lum;	state Exp;
branches;
next	1.135;

1.135
date	2013.03.25.11.41.44;	author florian;	state Exp;
branches;
next	1.134;

1.134
date	2012.12.27.18.51.52;	author florian;	state Exp;
branches;
next	1.133;

1.133
date	2012.12.27.18.49.59;	author florian;	state Exp;
branches;
next	1.132;

1.132
date	2012.12.04.10.54.20;	author florian;	state Exp;
branches;
next	1.131;

1.131
date	2012.11.27.19.46.46;	author jasper;	state Exp;
branches;
next	1.130;

1.130
date	2012.11.27.19.45.01;	author jasper;	state Exp;
branches;
next	1.129;

1.129
date	2012.11.06.18.04.10;	author florian;	state Exp;
branches;
next	1.128;

1.128
date	2012.11.03.14.51.41;	author haesbaert;	state Exp;
branches;
next	1.127;

1.127
date	2012.10.22.08.31.42;	author florian;	state Exp;
branches;
next	1.126;

1.126
date	2012.10.12.21.13.46;	author jasper;	state Exp;
branches;
next	1.125;

1.125
date	2012.08.31.18.06.42;	author lum;	state Exp;
branches;
next	1.124;

1.124
date	2012.06.14.17.21.22;	author lum;	state Exp;
branches;
next	1.123;

1.123
date	2012.06.07.15.15.04;	author lum;	state Exp;
branches;
next	1.122;

1.122
date	2012.05.29.05.40.36;	author lum;	state Exp;
branches;
next	1.121;

1.121
date	2012.05.25.04.56.58;	author lum;	state Exp;
branches;
next	1.120;

1.120
date	2012.04.12.04.47.59;	author lum;	state Exp;
branches;
next	1.119;

1.119
date	2012.04.11.17.51.10;	author lum;	state Exp;
branches;
next	1.118;

1.118
date	2011.12.10.14.09.48;	author lum;	state Exp;
branches;
next	1.117;

1.117
date	2011.11.28.04.41.39;	author lum;	state Exp;
branches;
next	1.116;

1.116
date	2011.01.23.00.45.03;	author kjell;	state Exp;
branches;
next	1.115;

1.115
date	2011.01.18.16.25.40;	author kjell;	state Exp;
branches;
next	1.114;

1.114
date	2011.01.17.03.12.06;	author kjell;	state Exp;
branches;
next	1.113;

1.113
date	2010.06.30.19.12.54;	author oga;	state Exp;
branches;
next	1.112;

1.112
date	2009.06.05.18.02.06;	author kjell;	state Exp;
branches;
next	1.111;

1.111
date	2009.06.04.23.39.37;	author kjell;	state Exp;
branches;
next	1.110;

1.110
date	2009.06.04.23.31.47;	author kjell;	state Exp;
branches;
next	1.109;

1.109
date	2009.06.04.02.23.37;	author kjell;	state Exp;
branches;
next	1.108;

1.108
date	2008.09.15.16.13.35;	author kjell;	state Exp;
branches;
next	1.107;

1.107
date	2008.09.15.16.11.35;	author kjell;	state Exp;
branches;
next	1.106;

1.106
date	2008.06.14.08.39.30;	author kjell;	state Exp;
branches;
next	1.105;

1.105
date	2008.06.14.07.38.53;	author kjell;	state Exp;
branches;
next	1.104;

1.104
date	2008.06.13.19.10.17;	author kjell;	state Exp;
branches;
next	1.103;

1.103
date	2008.06.12.01.58.44;	author kjell;	state Exp;
branches;
next	1.102;

1.102
date	2008.06.11.23.18.33;	author kjell;	state Exp;
branches;
next	1.101;

1.101
date	2008.06.10.23.23.53;	author kjell;	state Exp;
branches;
next	1.100;

1.100
date	2007.05.28.17.52.17;	author kjell;	state Exp;
branches;
next	1.99;

1.99
date	2007.02.21.23.33.12;	author deanna;	state Exp;
branches;
next	1.98;

1.98
date	2006.11.19.16.51.19;	author deraadt;	state Exp;
branches;
next	1.97;

1.97
date	2006.11.17.08.45.31;	author kjell;	state Exp;
branches;
next	1.96;

1.96
date	2006.08.01.22.16.03;	author jason;	state Exp;
branches;
next	1.95;

1.95
date	2006.07.25.08.27.09;	author kjell;	state Exp;
branches;
next	1.94;

1.94
date	2006.07.25.08.22.32;	author kjell;	state Exp;
branches;
next	1.93;

1.93
date	2006.07.08.17.56.10;	author kjell;	state Exp;
branches;
next	1.92;

1.92
date	2006.06.01.09.00.50;	author kjell;	state Exp;
branches;
next	1.91;

1.91
date	2006.06.01.05.34.52;	author jason;	state Exp;
branches;
next	1.90;

1.90
date	2006.05.29.00.02.23;	author kjell;	state Exp;
branches;
next	1.89;

1.89
date	2006.05.28.23.30.16;	author kjell;	state Exp;
branches;
next	1.88;

1.88
date	2006.05.27.21.20.11;	author kjell;	state Exp;
branches;
next	1.87;

1.87
date	2006.05.08.21.24.24;	author kjell;	state Exp;
branches;
next	1.86;

1.86
date	2006.05.02.17.10.25;	author kjell;	state Exp;
branches;
next	1.85;

1.85
date	2006.04.06.05.28.17;	author kjell;	state Exp;
branches;
next	1.84;

1.84
date	2006.04.03.02.43.22;	author kjell;	state Exp;
branches;
next	1.83;

1.83
date	2006.02.25.14.40.16;	author otto;	state Exp;
branches;
next	1.82;

1.82
date	2005.12.20.06.17.36;	author kjell;	state Exp;
branches;
next	1.81;

1.81
date	2005.12.13.07.20.13;	author kjell;	state Exp;
branches;
next	1.80;

1.80
date	2005.12.13.06.01.27;	author kjell;	state Exp;
branches;
next	1.79;

1.79
date	2005.12.13.05.23.03;	author kjell;	state Exp;
branches;
next	1.78;

1.78
date	2005.11.22.05.02.44;	author kjell;	state Exp;
branches;
next	1.77;

1.77
date	2005.11.20.03.24.17;	author deraadt;	state Exp;
branches;
next	1.76;

1.76
date	2005.11.18.23.37.30;	author kjell;	state Exp;
branches;
next	1.75;

1.75
date	2005.11.18.23.15.00;	author kjell;	state Exp;
branches;
next	1.74;

1.74
date	2005.11.18.20.56.52;	author deraadt;	state Exp;
branches;
next	1.73;

1.73
date	2005.11.18.17.35.17;	author kjell;	state Exp;
branches;
next	1.72;

1.72
date	2005.11.07.23.32.20;	author kjell;	state Exp;
branches;
next	1.71;

1.71
date	2005.10.14.06.41.47;	author kjell;	state Exp;
branches;
next	1.70;

1.70
date	2005.10.13.20.23.01;	author kjell;	state Exp;
branches;
next	1.69;

1.69
date	2005.10.13.19.46.45;	author kjell;	state Exp;
branches;
next	1.68;

1.68
date	2005.10.13.05.24.52;	author kjell;	state Exp;
branches;
next	1.67;

1.67
date	2005.10.11.01.08.53;	author kjell;	state Exp;
branches;
next	1.66;

1.66
date	2005.10.11.00.50.00;	author kjell;	state Exp;
branches;
next	1.65;

1.65
date	2005.10.06.16.48.00;	author kjell;	state Exp;
branches;
next	1.64;

1.64
date	2005.06.14.18.14.40;	author kjell;	state Exp;
branches;
next	1.63;

1.63
date	2005.05.31.20.38.59;	author kjell;	state Exp;
branches;
next	1.62;

1.62
date	2005.05.30.13.13.50;	author jason;	state Exp;
branches;
next	1.61;

1.61
date	2005.05.27.08.08.18;	author cloder;	state Exp;
branches;
next	1.60;

1.60
date	2005.04.03.02.09.28;	author db;	state Exp;
branches;
next	1.59;

1.59
date	2005.03.12.06.16.07;	author deraadt;	state Exp;
branches;
next	1.58;

1.58
date	2005.03.10.18.27.47;	author henning;	state Exp;
branches;
next	1.57;

1.57
date	2005.03.09.16.20.48;	author jfb;	state Exp;
branches;
next	1.56;

1.56
date	2004.07.22.01.25.24;	author vincent;	state Exp;
branches;
next	1.55;

1.55
date	2004.07.09.13.50.39;	author vincent;	state Exp;
branches;
next	1.54;

1.54
date	2004.01.27.23.43.37;	author vincent;	state Exp;
branches;
next	1.53;

1.53
date	2003.11.29.17.28.40;	author vincent;	state Exp;
branches;
next	1.52;

1.52
date	2003.11.09.01.11.14;	author vincent;	state Exp;
branches;
next	1.51;

1.51
date	2003.11.09.00.20.06;	author vincent;	state Exp;
branches;
next	1.50;

1.50
date	2003.10.27.11.21.12;	author vincent;	state Exp;
branches;
next	1.49;

1.49
date	2003.10.21.22.48.07;	author vincent;	state Exp;
branches;
next	1.48;

1.48
date	2003.08.15.23.23.18;	author vincent;	state Exp;
branches;
next	1.47;

1.47
date	2003.06.26.23.04.10;	author vincent;	state Exp;
branches;
next	1.46;

1.46
date	2003.05.05.11.12.07;	author vincent;	state Exp;
branches;
next	1.45;

1.45
date	2003.01.06.17.04.09;	author deraadt;	state Exp;
branches;
next	1.44;

1.44
date	2002.07.24.14.08.33;	author vincent;	state Exp;
branches;
next	1.43;

1.43
date	2002.07.01.14.33.44;	author vincent;	state Exp;
branches;
next	1.42;

1.42
date	2002.06.21.00.54.55;	author vincent;	state Exp;
branches;
next	1.41;

1.41
date	2002.05.29.12.41.42;	author vincent;	state Exp;
branches;
next	1.40;

1.40
date	2002.05.29.12.32.51;	author vincent;	state Exp;
branches;
next	1.39;

1.39
date	2002.03.18.01.45.54;	author vincent;	state Exp;
branches;
next	1.38;

1.38
date	2002.03.16.20.29.21;	author vincent;	state Exp;
branches;
next	1.37;

1.37
date	2002.03.16.04.17.36;	author vincent;	state Exp;
branches;
next	1.36;

1.36
date	2002.03.11.13.02.56;	author vincent;	state Exp;
branches;
next	1.35;

1.35
date	2002.02.26.00.45.45;	author vincent;	state Exp;
branches;
next	1.34;

1.34
date	2002.02.21.15.27.29;	author deraadt;	state Exp;
branches;
next	1.33;

1.33
date	2002.02.21.04.21.05;	author vincent;	state Exp;
branches;
next	1.32;

1.32
date	2002.02.21.04.16.27;	author vincent;	state Exp;
branches;
next	1.31;

1.31
date	2002.02.21.00.02.04;	author deraadt;	state Exp;
branches;
next	1.30;

1.30
date	2002.02.20.22.30.54;	author vincent;	state Exp;
branches;
next	1.29;

1.29
date	2002.02.16.21.27.49;	author millert;	state Exp;
branches;
next	1.28;

1.28
date	2002.02.14.22.58.20;	author vincent;	state Exp;
branches;
next	1.27;

1.27
date	2002.02.14.13.41.44;	author deraadt;	state Exp;
branches;
next	1.26;

1.26
date	2002.02.13.22.36.58;	author vincent;	state Exp;
branches;
next	1.25;

1.25
date	2002.02.13.03.03.49;	author vincent;	state Exp;
branches;
next	1.24;

1.24
date	2002.01.18.08.37.08;	author art;	state Exp;
branches;
next	1.23;

1.23
date	2002.01.10.12.13.35;	author art;	state Exp;
branches;
next	1.22;

1.22
date	2002.01.08.12.29.27;	author millert;	state Exp;
branches;
next	1.21;

1.21
date	2001.05.24.10.43.16;	author art;	state Exp;
branches;
next	1.20;

1.20
date	2001.05.24.10.10.00;	author art;	state Exp;
branches;
next	1.19;

1.19
date	2001.05.24.09.47.33;	author art;	state Exp;
branches;
next	1.18;

1.18
date	2001.05.24.03.05.20;	author mickey;	state Exp;
branches;
next	1.17;

1.17
date	2001.05.23.23.29.47;	author mickey;	state Exp;
branches;
next	1.16;

1.16
date	2001.05.23.22.20.35;	author art;	state Exp;
branches;
next	1.15;

1.15
date	2001.05.23.21.59.45;	author art;	state Exp;
branches;
next	1.14;

1.14
date	2001.05.23.21.42.34;	author art;	state Exp;
branches;
next	1.13;

1.13
date	2001.05.23.16.26.39;	author art;	state Exp;
branches;
next	1.12;

1.12
date	2001.05.23.15.39.35;	author art;	state Exp;
branches;
next	1.11;

1.11
date	2001.05.23.15.35.10;	author art;	state Exp;
branches;
next	1.10;

1.10
date	2001.05.04.22.00.35;	author art;	state Exp;
branches;
next	1.9;

1.9
date	2001.05.03.20.40.22;	author art;	state Exp;
branches;
next	1.8;

1.8
date	2001.05.03.12.57.22;	author art;	state Exp;
branches;
next	1.7;

1.7
date	2001.05.01.13.22.00;	author art;	state Exp;
branches;
next	1.6;

1.6
date	2001.01.29.01.58.06;	author niklas;	state Exp;
branches;
next	1.5;

1.5
date	2000.09.01.14.59.08;	author millert;	state Exp;
branches;
next	1.4;

1.4
date	2000.04.13.06.12.14;	author millert;	state Exp;
branches;
next	1.3;

1.3
date	2000.02.26.22.53.16;	author millert;	state Exp;
branches;
next	1.2;

1.2
date	2000.02.25.19.13.21;	author deraadt;	state Exp;
branches;
next	1.1;

1.1
date	2000.02.25.19.08.46;	author deraadt;	state Exp;
branches;
next	;


desc
@@


1.155
log
@Add 'sentence-end-double-space'.

If you prefer "lighter" punctuation and one space between sentences,
for example:

Mr and Mrs Jones are from the UK. They arrived today.

over more liberal use of full stops and double spaces between
sentences:

Mr. and Mrs. Jones are from the U.K.  They arrived today.

then toggling 'sentence-end-double-space' will make mg's
fill-paragraph function format text using one space instead of two
(the default) between sentences. However, be careful, should you have
a double spaced document and accidentally "format" it to have single
spaces, then you may have a problem. mg won't be able to revert the
formatting for you (unless you have a previous version of the text in
the "undo" history, or are using mg's backup facility and haven't
opened and saved multiple times!).

Comments from schwarze@@
@
text
@/*	$OpenBSD: def.h,v 1.154 2016/01/02 10:39:19 lum Exp $	*/

/* This file is in the public domain. */

/*
 * This file is the general header file for all parts
 * of the Mg display editor. It contains all of the
 * general definitions and macros. It also contains some
 * conditional compilation flags. All of the per-system and
 * per-terminal definitions are in special header files.
 */

#include	"chrdef.h"

typedef int	(*PF)(int, int);	/* generally useful type */

/*
 * Table sizes, etc.
 */
#define NFILEN	1024		/* Length, file name.		 */
#define NBUFN	NFILEN		/* Length, buffer name.		 */
#define NLINE	256		/* Length, line.		 */
#define PBMODES 4		/* modes per buffer		 */
#define NPAT	80		/* Length, pattern.		 */
#define HUGE	1000		/* A rather large number.	 */
#define NSRCH	128		/* Undoable search commands.	 */
#define NXNAME	64		/* Length, extended command.	 */
#define NKNAME	20		/* Length, key names.		 */
#define NTIME	50		/* Length, timestamp string.	 */

/*
 * Universal.
 */
#define FALSE	0		/* False, no, bad, etc.		 */
#define TRUE	1		/* True, yes, good, etc.	 */
#define ABORT	2		/* Death, ^G, abort, etc.	 */
#define UERROR	3		/* User Error.			 */
#define REVERT	4		/* Revert the buffer		 */

#define KCLEAR	2		/* clear echo area		 */

/*
 * These flag bits keep track of
 * some aspects of the last command. The CFCPCN
 * flag controls goal column setting. The CFKILL
 * flag controls the clearing versus appending
 * of data in the kill buffer.
 */
#define CFCPCN	0x0001		/* Last command was C-P, C-N	 */
#define CFKILL	0x0002		/* Last command was a kill	 */
#define CFINS	0x0004		/* Last command was self-insert	 */

/*
 * File I/O.
 */
#define FIOSUC	0		/* Success.			 */
#define FIOFNF	1		/* File not found.		 */
#define FIOEOF	2		/* End of file.			 */
#define FIOERR	3		/* Error.			 */
#define FIOLONG 4		/* long line partially read	 */
#define FIODIR 5		/* File is a directory		 */

/*
 * Display colors.
 */
#define CNONE	0		/* Unknown color.		 */
#define CTEXT	1		/* Text color.			 */
#define CMODE	2		/* Mode line color.		 */

/*
 * Flags for keyboard invoked functions.
 */
#define FFUNIV		1	/* universal argument		 */
#define FFNEGARG	2	/* negative only argument	 */
#define FFOTHARG	4	/* other argument		 */
#define FFARG		7	/* any argument			 */
#define FFRAND		8	/* Called by other function	 */

/*
 * Flags for "eread".
 */
#define EFFUNC	0x0001		/* Autocomplete functions.	 */
#define EFBUF	0x0002		/* Autocomplete buffers.	 */
#define EFFILE	0x0004		/* " files (maybe someday)	 */
#define EFAUTO	0x0007		/* Some autocompletion on	 */
#define EFNEW	0x0008		/* New prompt.			 */
#define EFCR	0x0010		/* Echo CR at end; last read.	 */
#define EFDEF	0x0020		/* buffer contains default args	 */
#define EFNUL	0x0040		/* Null Minibuffer OK		 */

/*
 * Direction of insert into kill ring
 */
#define KNONE	0x00
#define KFORW	0x01		/* forward insert into kill ring */
#define KBACK	0x02		/* Backwards insert into kill ring */
#define KREG	0x04		/* This is a region-based kill */

#define MAX_TOKEN 64

/*
 * Previously from sysdef.h
 */
typedef int	RSIZE;		/* Type for file/region sizes    */
typedef short	KCHAR;		/* Type for internal keystrokes  */

/*
 * This structure holds the starting position
 * (as a line/offset pair) and the number of characters in a
 * region of a buffer. This makes passing the specification
 * of a region around a little bit easier.
 */
struct region {
	struct line	*r_linep;	/* Origin line address.		 */
	int		 r_offset;	/* Origin line offset.		 */
	int		 r_lineno;	/* Origin line number		 */
	RSIZE		 r_size;	/* Length in characters.	 */
};


/*
 * All text is kept in circularly linked
 * lists of "line" structures. These begin at the
 * header line (which is the blank line beyond the
 * end of the buffer). This line is pointed to by
 * the "buffer" structure. Each line contains the number of
 * bytes in the line (the "used" size), the size
 * of the text array, and the text. The end of line
 * is not stored as a byte; it's implied. Future
 * additions will include update hints, and a
 * list of marks into the line.
 */
struct line {
	struct line	*l_fp;		/* Link to the next line	 */
	struct line	*l_bp;		/* Link to the previous line	 */
	int		 l_size;	/* Allocated size		 */
	int		 l_used;	/* Used size			 */
	char		*l_text;	/* Content of the line		 */
};

/*
 * The rationale behind these macros is that you
 * could (with some editing, like changing the type of a line
 * link from a "struct line *" to a "REFLINE", and fixing the commands
 * like file reading that break the rules) change the actual
 * storage representation of lines to use something fancy on
 * machines with small address spaces.
 */
#define lforw(lp)	((lp)->l_fp)
#define lback(lp)	((lp)->l_bp)
#define lgetc(lp, n)	(CHARMASK((lp)->l_text[(n)]))
#define lputc(lp, n, c) ((lp)->l_text[(n)]=(c))
#define llength(lp)	((lp)->l_used)
#define ltext(lp)	((lp)->l_text)

/*
 * All repeated structures are kept as linked lists of structures.
 * All of these start with a LIST structure (except lines, which
 * have their own abstraction). This will allow for
 * later conversion to generic list manipulation routines should
 * I decide to do that. It does mean that there are four extra
 * bytes per window. I feel that this is an acceptable price,
 * considering that there are usually only one or two windows.
 */
struct list {
	union {
		struct mgwin	*l_wp;
		struct buffer	*x_bp;	/* l_bp is used by struct line */
		struct list	*l_nxt;
	} l_p;
	char *l_name;
};

/*
 * Usual hack - to keep from uglifying the code with lotsa
 * references through the union, we #define something for it.
 */
#define l_next	l_p.l_nxt

/*
 * There is a window structure allocated for
 * every active display window. The windows are kept in a
 * big list, in top to bottom screen order, with the listhead at
 * "wheadp". Each window contains its own values of dot and mark.
 * The flag field contains some bits that are set by commands
 * to guide redisplay; although this is a bit of a compromise in
 * terms of decoupling, the full blown redisplay is just too
 * expensive to run for every input character.
 */
struct mgwin {
	struct list	 w_list;	/* List header			*/
	struct buffer	*w_bufp;	/* Buffer displayed in window	*/
	struct line	*w_linep;	/* Top line in the window	*/
	struct line	*w_dotp;	/* Line containing "."		*/
	struct line	*w_markp;	/* Line containing "mark"	*/
	int		 w_doto;	/* Byte offset for "."		*/
	int		 w_marko;	/* Byte offset for "mark"	*/
	int		 w_toprow;	/* Origin 0 top row of window	*/
	int		 w_ntrows;	/* # of rows of text in window	*/
	int		 w_frame;	/* #lines to reframe by.	*/
	char		 w_rflag;	/* Redisplay Flags.		*/
	char		 w_flag;	/* Flags.			*/
	struct line	*w_wrapline;
	int		 w_dotline;	/* current line number of dot	*/
	int		 w_markline;	/* current line number of mark	*/
};
#define w_wndp	w_list.l_p.l_wp
#define w_name	w_list.l_name

/*
 * Window redisplay flags are set by command processors to
 * tell the display system what has happened to the buffer
 * mapped by the window. Setting "WFFULL" is always a safe thing
 * to do, but it may do more work than is necessary. Always try
 * to set the simplest action that achieves the required update.
 * Because commands set bits in the "w_flag", update will see
 * all change flags, and do the most general one.
 */
#define WFFRAME 0x01			/* Force reframe.		 */
#define WFMOVE	0x02			/* Movement from line to line.	 */
#define WFEDIT	0x04			/* Editing within a line.	 */
#define WFFULL	0x08			/* Do a full display.		 */
#define WFMODE	0x10			/* Update mode line.		 */

/*
 * Window flags
 */
#define WNONE  0x00 			/* No special window options.	*/
#define WEPHEM 0x01 			/* Window is ephemeral.	 	*/

struct undo_rec;
TAILQ_HEAD(undoq, undo_rec);

/*
 * Previously from sysdef.h
 * Only used in struct buffer.
 */
struct fileinfo {
        uid_t           fi_uid;
        gid_t           fi_gid;
        mode_t          fi_mode;
        struct timespec fi_mtime;       /* Last modified time */
};

/*
 * Text is kept in buffers. A buffer header, described
 * below, exists for every buffer in the system. The buffers are
 * kept in a big list, so that commands that search for a buffer by
 * name can find the buffer header. There is a safe store for the
 * dot and mark in the header, but this is only valid if the buffer
 * is not being displayed (that is, if "b_nwnd" is 0). The text for
 * the buffer is kept in a circularly linked list of lines, with
 * a pointer to the header line in "b_headp".
 */
struct buffer {
	struct list	 b_list;	/* buffer list pointer		 */
	struct buffer	*b_altb;	/* Link to alternate buffer	 */
	struct line	*b_dotp;	/* Link to "." line structure	 */
	struct line	*b_markp;	/* ditto for mark		 */
	struct line	*b_headp;	/* Link to the header line	 */
	struct maps_s	*b_modes[PBMODES]; /* buffer modes		 */
	int		 b_doto;	/* Offset of "." in above line	 */
	int		 b_marko;	/* ditto for the "mark"		 */
	short		 b_nmodes;	/* number of non-fundamental modes */
	char		 b_nwnd;	/* Count of windows on buffer	 */
	char		 b_flag;	/* Flags			 */
	char		 b_fname[NFILEN]; /* File name			 */
	char		 b_cwd[NFILEN]; /* working directory		 */
	struct fileinfo	 b_fi;		/* File attributes		 */
	struct undoq	 b_undo;	/* Undo actions list		 */
	struct undo_rec *b_undoptr;
	int		 b_dotline;	/* Line number of dot */
	int		 b_markline;	/* Line number of mark */
	int		 b_lines;	/* Number of lines in file	*/
};
#define b_bufp	b_list.l_p.x_bp
#define b_bname b_list.l_name

/* Some helper macros, in case they ever change to functions */
#define bfirstlp(buf)	(lforw((buf)->b_headp))
#define blastlp(buf)	(lback((buf)->b_headp))

#define BFCHG	0x01			/* Changed.			 */
#define BFBAK	0x02			/* Need to make a backup.	 */
#ifdef	NOTAB
#define BFNOTAB 0x04			/* no tab mode			 */
#endif
#define BFOVERWRITE 0x08		/* overwrite mode		 */
#define BFREADONLY  0x10		/* read only mode		 */
#define BFDIRTY     0x20		/* Buffer was modified elsewhere */
#define BFIGNDIRTY  0x40		/* Ignore modifications 	 */
#define BFDIREDDEL  0x80		/* Dired has a deleted 'D' file	 */
/*
 * This structure holds information about recent actions for the Undo command.
 */
struct undo_rec {
	TAILQ_ENTRY(undo_rec) next;
	enum {
		INSERT = 1,
		DELETE,
		BOUNDARY,
		MODIFIED,
		DELREG
	} type;
	struct region	 region;
	int		 pos;
	char		*content;
};

/*
 * Previously from ttydef.h
 */
#define STANDOUT_GLITCH			/* possible standout glitch	*/

#define putpad(str, num)	tputs(str, num, ttputc)

#define KFIRST	K00
#define KLAST	K00

/*
 * Prototypes.
 */

/* tty.c X */
void		 ttinit(void);
void		 ttreinit(void);
void		 tttidy(void);
void		 ttmove(int, int);
void		 tteeol(void);
void		 tteeop(void);
void		 ttbeep(void);
void		 ttinsl(int, int, int);
void		 ttdell(int, int, int);
void		 ttwindow(int, int);
void		 ttnowindow(void);
void		 ttcolor(int);
void		 ttresize(void);

volatile sig_atomic_t winch_flag;

/* ttyio.c */
void		 ttopen(void);
int		 ttraw(void);
void		 ttclose(void);
int		 ttcooked(void);
int		 ttputc(int);
void		 ttflush(void);
int		 ttgetc(void);
int		 ttwait(int);
int		 charswaiting(void);

/* dir.c */
void		 dirinit(void);
int		 changedir(int, int);
int		 showcwdir(int, int);
int		 getcwdir(char *, size_t);
int		 makedir(int, int);
int		 do_makedir(char *);
int		 ask_makedir(void);

/* dired.c */
struct buffer	*dired_(char *);
int 		 do_dired(char *);

/* file.c X */
int		 fileinsert(int, int);
int		 filevisit(int, int);
int		 filevisitalt(int, int);
int		 filevisitro(int, int);
int		 poptofile(int, int);
int		 readin(char *);
int		 insertfile(char *, char *, int);
int		 filewrite(int, int);
int		 filesave(int, int);
int		 buffsave(struct buffer *);
int		 makebkfile(int, int);
int		 writeout(FILE **, struct buffer *, char *);
void		 upmodes(struct buffer *);
size_t		 xbasename(char *, const char *, size_t);
int		 do_filevisitalt(char *);

/* line.c X */
struct line	*lalloc(int);
int		 lrealloc(struct line *, int);
void		 lfree(struct line *);
void		 lchange(int);
int		 linsert(int, int);
int		 lnewline_at(struct line *, int);
int		 lnewline(void);
int		 ldelete(RSIZE, int);
int		 ldelnewline(void);
int		 lreplace(RSIZE, char *);
char *		 linetostr(const struct line *);

/* yank.c X */

void		 kdelete(void);
int		 kinsert(int, int);
int		 kremove(int);
int		 kchunk(char *, RSIZE, int);
int		 killline(int, int);
int		 yank(int, int);

/* window.c X */
struct mgwin	*new_window(struct buffer *);
int		 reposition(int, int);
int		 redraw(int, int);
int		 do_redraw(int, int, int);
int		 nextwind(int, int);
int		 prevwind(int, int);
int		 onlywind(int, int);
int		 splitwind(int, int);
int		 enlargewind(int, int);
int		 shrinkwind(int, int);
int		 delwind(int, int);

/* buffer.c */
int		 togglereadonly(int, int);
struct buffer   *bfind(const char *, int);
int		 poptobuffer(int, int);
int		 killbuffer(struct buffer *);
int		 killbuffer_cmd(int, int);
int		 savebuffers(int, int);
int		 listbuffers(int, int);
int		 addlinef(struct buffer *, char *, ...);
#define	 addline(bp, text)	addlinef(bp, "%s", text)
int		 anycb(int);
int		 bclear(struct buffer *);
int		 showbuffer(struct buffer *, struct mgwin *, int);
int		 augbname(char *, const char *, size_t);
struct mgwin    *popbuf(struct buffer *, int);
int		 bufferinsert(int, int);
int		 usebuffer(int, int);
int		 notmodified(int, int);
int		 popbuftop(struct buffer *, int);
int		 getbufcwd(char *, size_t);
int		 checkdirty(struct buffer *);
int		 revertbuffer(int, int);
int		 dorevert(void);
int		 diffbuffer(int, int);
struct buffer	*findbuffer(char *);

/* display.c */
int		vtresize(int, int, int);
void		vtinit(void);
void		vttidy(void);
void		update(int);
int		linenotoggle(int, int);
int		colnotoggle(int, int);

/* echo.c X */
void		 eerase(void);
int		 eyorn(const char *);
int		 eynorr(const char *);
int		 eyesno(const char *);
void		 ewprintf(const char *fmt, ...);
char		*eread(const char *, char *, size_t, int, ...)
				__attribute__((__format__ (printf, 1, 5)));
int		 getxtra(struct list *, struct list *, int, int);
void		 free_file_list(struct list *);

/* fileio.c */
int		 ffropen(FILE **, const char *, struct buffer *);
void		 ffstat(FILE *, struct buffer *);
int		 ffwopen(FILE **, const char *, struct buffer *);
int		 ffclose(FILE *, struct buffer *);
int		 ffputbuf(FILE *, struct buffer *);
int		 ffgetline(FILE *, char *, int, int *);
int		 fbackupfile(const char *);
char		*adjustname(const char *, int);
char		*startupfile(char *);
int		 copy(char *, char *);
struct list	*make_file_list(char *);
int		 fisdir(const char *);
int		 fchecktime(struct buffer *);
int		 fupdstat(struct buffer *);
int		 backuptohomedir(int, int);
int		 toggleleavetmp(int, int);
char		*expandtilde(const char *);

/* kbd.c X */
int		 do_meta(int, int);
int		 bsmap(int, int);
void		 ungetkey(int);
int		 getkey(int);
int		 doin(void);
int		 rescan(int, int);
int		 universal_argument(int, int);
int		 digit_argument(int, int);
int		 negative_argument(int, int);
int		 selfinsert(int, int);
int		 quote(int, int);

/* main.c */
int		 ctrlg(int, int);
int		 quit(int, int);

/* ttyio.c */
void		 panic(char *);

/* cinfo.c */
char		*getkeyname(char  *, size_t, int);

/* basic.c */
int		 gotobol(int, int);
int		 backchar(int, int);
int		 gotoeol(int, int);
int		 forwchar(int, int);
int		 gotobob(int, int);
int		 gotoeob(int, int);
int		 forwline(int, int);
int		 backline(int, int);
void		 setgoal(void);
int		 getgoal(struct line *);
int		 forwpage(int, int);
int		 backpage(int, int);
int		 forw1page(int, int);
int		 back1page(int, int);
int		 pagenext(int, int);
void		 isetmark(void);
int		 setmark(int, int);
int		 clearmark(int, int);
int		 swapmark(int, int);
int		 gotoline(int, int);
int		 setlineno(int);

/* random.c X */
int		 showcpos(int, int);
int		 getcolpos(struct mgwin *);
int		 twiddle(int, int);
int		 openline(int, int);
int		 enewline(int, int);
int		 deblank(int, int);
int		 justone(int, int);
int		 delwhite(int, int);
int		 delleadwhite(int, int);
int		 deltrailwhite(int, int);
int		 lfindent(int, int);
int		 indent(int, int);
int		 forwdel(int, int);
int		 backdel(int, int);
int		 space_to_tabstop(int, int);
int		 backtoindent(int, int);
int		 joinline(int, int);

/* tags.c X */
int		 findtag(int, int);
int 		 poptag(int, int);
int		 tagsvisit(int, int);
int		 curtoken(int, int, char *);

/* cscope.c */
int		cssymbol(int, int);
int		csdefinition(int, int);
int		csfuncalled(int, int);
int		cscallerfuncs(int, int);
int		csfindtext(int, int);
int		csegrep(int, int);
int		csfindfile(int, int);
int		csfindinc(int, int);
int		csnextfile(int, int);
int		csnextmatch(int, int);
int		csprevfile(int, int);
int		csprevmatch(int, int);
int		cscreatelist(int, int);

/* extend.c X */
int		 insert(int, int);
int		 bindtokey(int, int);
int		 localbind(int, int);
int		 redefine_key(int, int);
int		 unbindtokey(int, int);
int		 localunbind(int, int);
int		 extend(int, int);
int		 evalexpr(int, int);
int		 evalbuffer(int, int);
int		 evalfile(int, int);
int		 load(const char *);
int		 excline(char *);

/* help.c X */
int		 desckey(int, int);
int		 wallchart(int, int);
int		 help_help(int, int);
int		 apropos_command(int, int);

/* paragraph.c X */
int		 gotobop(int, int);
int		 gotoeop(int, int);
int		 fillpara(int, int);
int		 killpara(int, int);
int		 fillword(int, int);
int		 setfillcol(int, int);
int		 markpara(int, int);
int		 transposepara(int, int);
int		 sentencespace(int, int);

/* word.c X */
int		 backword(int, int);
int		 forwword(int, int);
int		 upperword(int, int);
int		 lowerword(int, int);
int		 capword(int, int);
int		 delfword(int, int);
int		 delbword(int, int);
int		 inword(void);
int		 transposeword(int, int);

/* region.c X */
int		 killregion(int, int);
int		 copyregion(int, int);
int		 lowerregion(int, int);
int		 upperregion(int, int);
int		 prefixregion(int, int);
int		 setprefix(int, int);
int		 region_get_data(struct region *, char *, int);
void		 region_put_data(const char *, int);
int		 markbuffer(int, int);
int		 piperegion(int, int);
int		 shellcommand(int, int);
int		 pipeio(const char * const, char * const[], char * const, int,
		     struct buffer *);

/* search.c X */
int		 forwsearch(int, int);
int		 backsearch(int, int);
int		 searchagain(int, int);
int		 forwisearch(int, int);
int		 backisearch(int, int);
int		 queryrepl(int, int);
int		 forwsrch(void);
int		 backsrch(void);
int		 readpattern(char *);

/* spawn.c X */
int		 spawncli(int, int);

/* ttykbd.c X */
void		 ttykeymapinit(void);
void		 ttykeymaptidy(void);

/* match.c X */
int		 showmatch(int, int);

/* version.c X */
int		 showversion(int, int);

/* macro.c X */
int		 definemacro(int, int);
int		 finishmacro(int, int);
int		 executemacro(int, int);

/* modes.c X */
int		 indentmode(int, int);
int		 fillmode(int, int);
#ifdef NOTAB
int		 notabmode(int, int);
#endif	/* NOTAB */
int		 overwrite_mode(int, int);
int		 set_default_mode(int,int);

#ifdef REGEX
/* re_search.c X */
int		 re_forwsearch(int, int);
int		 re_backsearch(int, int);
int		 re_searchagain(int, int);
int		 re_queryrepl(int, int);
int		 replstr(int, int);
int		 setcasefold(int, int);
int		 delmatchlines(int, int);
int		 delnonmatchlines(int, int);
int		 cntmatchlines(int, int);
int		 cntnonmatchlines(int, int);
#endif	/* REGEX */

/* undo.c X */
void		 free_undo_record(struct undo_rec *);
int		 undo_dump(int, int);
int		 undo_enabled(void);
int		 undo_enable(int, int);
int		 undo_add_boundary(int, int);
void		 undo_add_modified(void);
int		 undo_add_insert(struct line *, int, int);
int		 undo_add_delete(struct line *, int, int, int);
int		 undo_boundary_enable(int, int);
int		 undo_add_change(struct line *, int, int);
int		 undo(int, int);

/* autoexec.c X */
int		 auto_execute(int, int);
PF		*find_autoexec(const char *);
int		 add_autoexec(const char *, const char *);

/* cmode.c X */
int		 cmode(int, int);
int		 cc_brace(int, int);
int		 cc_char(int, int);
int		 cc_tab(int, int);
int		 cc_indent(int, int);
int		 cc_lfindent(int, int);

/* grep.c X */
int		 next_error(int, int);
int		 globalwdtoggle(int, int);
int		 compile(int, int);

/* bell.c */
void		 bellinit(void);
int		 toggleaudiblebell(int, int);
int		 togglevisiblebell(int, int);
void		 dobeep(void);

/*
 * Externals.
 */
extern struct buffer	*bheadp;
extern struct buffer	*curbp;
extern struct mgwin	*curwp;
extern struct mgwin	*wheadp;
extern int		 thisflag;
extern int		 lastflag;
extern int		 curgoal;
extern int		 startrow;
extern int		 epresf;
extern int		 sgarbf;
extern int		 mode;
extern int		 nrow;
extern int		 ncol;
extern int		 ttrow;
extern int		 ttcol;
extern int		 tttop;
extern int		 ttbot;
extern int		 tthue;
extern int		 defb_nmodes;
extern int		 defb_flag;
extern int		 doaudiblebell;
extern int		 dovisiblebell;
extern int		 dblspace;
extern char	 	 cinfo[];
extern char		*keystrings[];
extern char		 pat[NPAT];
extern char		 prompt[];

/*
 * Globals.
 */
int		 tceeol;
int		 tcinsl;
int		 tcdell;
int		 rptcount;	/* successive invocation count */
@


1.154
log
@Add dired-find-alternate-file.
@
text
@d1 1
a1 1
/*	$OpenBSD: def.h,v 1.153 2015/12/29 19:44:32 lum Exp $	*/
d596 1
d738 1
@


1.153
log
@Add transpose-words, ok jasper@@.
Limited to one iteration until 'undo' is looked into.
@
text
@d1 1
a1 1
/*	$OpenBSD: def.h,v 1.152 2015/10/29 19:46:47 lum Exp $	*/
d380 1
@


1.152
log
@Fix opening dired from the command line. Incorrect cursor placement
and make the error more useful when there is a problem opening a
directory. Reported by and ok jasper@@
@
text
@d1 1
a1 1
/*	$OpenBSD: def.h,v 1.151 2015/10/12 19:08:39 lum Exp $	*/
d605 1
@


1.151
log
@Maintain a list of files marked for deletion while refreshing a dired
buffer. Previously, when refreshing the buffer the files marked for
deletion would be lost.

Since the relationship between the files that have been marked for
deletion and those that exist on disk is volatile, I have chosen to
implement the discovery of marked files during the refresh function as
opposed to maintaining a dired buffer specific list.
@
text
@d1 1
a1 1
/*	$OpenBSD: def.h,v 1.150 2015/09/29 02:07:49 guenther Exp $	*/
d363 1
@


1.150
log
@Mark eread(), veread(), and eformat() as printf-like and
Convert eread(buf, a2, a3, a4) to eread("%s", a2, a3, a4, buf)

ok millert@@ lum@@
@
text
@d1 1
a1 1
/*	$OpenBSD: def.h,v 1.149 2015/09/26 15:03:15 lum Exp $	*/
d291 2
a292 1
#define BFIGNDIRTY  0x40		/* Ignore modifications */
@


1.149
log
@Add transpose-paragraphs. ok jasper@@
@
text
@d1 1
a1 1
/*	$OpenBSD: def.h,v 1.148 2015/09/24 07:07:59 lum Exp $	*/
d454 2
a455 1
char		*eread(const char *, char *, size_t, int, ...);
@


1.148
log
@Add mark-paragraph. ok jasper@@
@
text
@d1 1
a1 1
/*	$OpenBSD: def.h,v 1.147 2015/06/03 23:40:01 bcallah Exp $	*/
d591 1
@


1.147
log
@Remove unused defines and functions.
"Looks fine." deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: def.h,v 1.146 2015/05/08 12:35:08 bcallah Exp $	*/
d590 1
@


1.146
log
@Remove ereply prototype since it is never used. Tweak a comment to reflect
ereply removal.
ok jasper@@ florian@@
@
text
@d1 1
a1 1
/*	$OpenBSD: def.h,v 1.145 2015/03/25 20:53:31 bcallah Exp $	*/
a23 1
#define NKBDM	256		/* Length, keyboard macro.	 */
d30 1
a63 7
 * Directory I/O.
 */
#define DIOSUC	0		/* Success.			 */
#define DIOEOF	1		/* End of file.			 */
#define DIOERR	2		/* Error.			 */

/*
a383 1
int		 linsert_str(const char *, int);
a402 1
void		 free_window(struct mgwin *);
a647 1
int		 blinkparen(int, int);
@


1.145
log
@unifdef -U NO_DPROMPT and GOSREC.
NO_DPROMPT has been around since the import of mg2a and it has never been
considered a "(Common) compile-time option" in the Makefile.
Assume everyone has been running mg this way since at least 2000 if not
already in the 90s.

Same with GOSREC. Has always been there but it looks like no one noticed
it (and no one was running with it). Indeed, the mg tutorial appears to be
oblivious to GOSREC being an option.

With this commit there are no more #ifndef blocks in mg. Only a couple of
#ifdef blocks remain.

ok lum@@
@
text
@d1 1
a1 1
/*	$OpenBSD: def.h,v 1.144 2015/03/25 12:25:36 bcallah Exp $	*/
a462 1
char		*ereply(const char *, char *, size_t, ...);
@


1.144
log
@We really don't need ttydef.h -- it is like sysdef.h -- once useful because
supported a lot of systems and nothing was standardized. But now it only
4 defines. Move those defines into def.h since ttydef.h is only sourced in
def.h

While here, MAKEBACKUP has the same #ifdef dance that LINENOMODE had. Set
it directly to TRUE and remove the #ifdef block.

ok florian@@
@
text
@d1 1
a1 1
/*	$OpenBSD: def.h,v 1.143 2015/03/19 21:22:15 bcallah Exp $	*/
a743 1
#ifndef NO_DPROMPT
a744 1
#endif	/* !NO_DPROMPT */
@


1.143
log
@Clean up the includes in mg.
This does the following:
Moves all POSIX headers from sysdef.h into the individual .c files so that
each file now only includes what it needs. All headers are properly sorted.
Moves the remainder of sysdef.h to other files (mostly def.h) and deletes
sysdef.h now that it's no longer contains anything.
Tweak a comment that references sysdef.h so that it no longer does that.
ok florian@@
@
text
@d1 1
a1 1
/*	$OpenBSD: def.h,v 1.142 2015/03/16 13:47:48 bcallah Exp $	*/
a13 1
#include	"ttydef.h"
d315 10
@


1.142
log
@Change the internal name of the newline function to deconflict with a
function of the same name in term.h. This is the first step towards
cleaning up mg's includes. No user-visible changes.
ok florian@@
@
text
@d1 1
a1 1
/*	$OpenBSD: def.h,v 1.141 2014/04/03 20:17:12 lum Exp $	*/
d13 1
a13 1
#include	"sysdef.h"	/* Order is critical.		 */
a14 1
#include	"chrdef.h"
d110 6
d241 11
@


1.141
log
@When finding a file in a non-existant directory:

C-x C-f ~/no/dir/here/fn

offer to make the directory by pressing 'y', instead of suggesting the
make-directory command. ok jasper@@
@
text
@d1 1
a1 1
/*	$OpenBSD: def.h,v 1.140 2014/03/22 11:05:37 lum Exp $	*/
d513 1
a513 1
int		 newline(int, int);
@


1.140
log
@donebell is no longer required.
@
text
@d1 1
a1 1
/*	$OpenBSD: def.h,v 1.139 2013/12/23 14:58:16 lum Exp $	*/
d339 2
a340 1
int		 do_makedir(void);
@


1.139
log
@Move findbuffer() to buffer.c.
ok florian@@
@
text
@d1 1
a1 1
/*	$OpenBSD: def.h,v 1.138 2013/05/31 18:03:43 lum Exp $	*/
a714 1
extern int		 donebell;
@


1.138
log
@Make the system bell toggleable via 'audible-bell', and if switched
off, make available an alternative 'visible-bell'.

ok florian@@ jasper@@ Feedback Sunil Nimmagadda.
@
text
@d1 1
a1 1
/*	$OpenBSD: def.h,v 1.137 2013/05/30 04:17:25 lum Exp $	*/
a349 1
struct buffer	*findbuffer(char *);
d421 1
@


1.137
log
@Reuse the makedir() function in dir.c for dired's
dired-create-directory command.
ok jasper@@
@
text
@d1 1
a1 1
/*	$OpenBSD: def.h,v 1.136 2013/05/22 19:23:45 lum Exp $	*/
d427 1
a427 1
void		update(void);
d684 6
d713 3
@


1.136
log
@Shuffle shell-command-on-region around to give shell-command.
ok florian@@ jasper@@
Testing Sunil Nimmagadda
@
text
@d1 1
a1 1
/*	$OpenBSD: def.h,v 1.135 2013/03/25 11:41:44 florian Exp $	*/
d339 1
@


1.135
log
@Display the window's column number in mode line not the
column number of the active window.
OK jasper@@
@
text
@d1 1
a1 1
/*	$OpenBSD: def.h,v 1.134 2012/12/27 18:51:52 florian Exp $	*/
d595 1
@


1.134
log
@diff-buffer-with-file
input gsoares@@, Sunil Nimmagadda, jasper@@
ok jasper@@, benno@@
@
text
@d1 1
a1 1
/*	$OpenBSD: def.h,v 1.133 2012/12/27 18:49:59 florian Exp $	*/
d508 1
a508 1
int		 getcolpos(void);
@


1.133
log
@Move code for shell-command-on-region around to make pipeio() usable
in other functions.
ok jasper@@, benno@@
@
text
@d1 1
a1 1
/*	$OpenBSD: def.h,v 1.132 2012/12/04 10:54:20 florian Exp $	*/
d420 1
@


1.132
log
@Bring back column numbers and make them configurable, off by default
to not kill slow serial lines.
Committing my independently written, slightly different version, as
requested by jasper@@.

OK jasper@@, OK reyk@@ for jasper@@'s version of the diff
"Sure, if you think so then." deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: def.h,v 1.131 2012/11/27 19:46:46 jasper Exp $	*/
d594 2
@


1.131
log
@- add 'make-directory' (not bound to any shortcut).

feedback from florian@@ lum@@
ok florian@@
@
text
@d1 1
a1 1
/*	$OpenBSD: def.h,v 1.130 2012/11/27 19:45:01 jasper Exp $	*/
d427 1
@


1.130
log
@- move prototype of expandtilder() to def.h; needed by an upcoming diff.
@
text
@d1 1
a1 1
/*	$OpenBSD: def.h,v 1.129 2012/11/06 18:04:10 florian Exp $	*/
d338 1
@


1.129
log
@Remove never read struct member, found while investigating a llvm
report.

ok lum, jasper, benno
@
text
@d1 1
a1 1
/*	$OpenBSD: def.h,v 1.128 2012/11/03 14:51:41 haesbaert Exp $	*/
d455 1
@


1.128
log
@This should be void.
@
text
@d1 1
a1 1
/*	$OpenBSD: def.h,v 1.127 2012/10/22 08:31:42 florian Exp $	*/
a262 1
	int		 b_undopos;	/* Where we were during last undo */
@


1.127
log
@Add (r)evert prompt to "File changed on disk; really edit the buffer"
prompt.

input, ok lum@@, man bit ok jmc@@, ok benno@@
@
text
@d1 1
a1 1
/*	$OpenBSD: def.h,v 1.126 2012/10/12 21:13:46 jasper Exp $	*/
d419 1
a419 1
int		 dorevert();
@


1.126
log
@- implement "revert-buffer", which reverts the current buffer to what's on disk
- split gotoline() into the argument handling part and the part that actually
  goes to the specified line number so it can be re-used by revertbuffer()

input/ok florian@@ haesbaert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: def.h,v 1.125 2012/08/31 18:06:42 lum Exp $	*/
d40 1
d419 1
d431 1
@


1.125
log
@Allow an error message for a filename that is too long to be seen and
let the error stop mg exiting when C-x C-c is called.
@
text
@d1 1
a1 1
/*	$OpenBSD: def.h,v 1.124 2012/06/14 17:21:22 lum Exp $	*/
d417 1
d498 1
@


1.124
log
@Allow mg to save backup files to a users home directory.
Suggestions from eric@@ and Sunil Nimmagadda.
Remarks deraadt@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: def.h,v 1.123 2012/06/07 15:15:04 lum Exp $	*/
d39 1
@


1.123
log
@Add some cscope support to mg. From Sunil Nimmagadda.  Due to some
structural limitations in mg, mg doesn't behave exactly the same as
emacs cscope (see the README) but is still very usable.

man page bits reviewed by jmc@@, otherwise tested and reviewed by
myself.
@
text
@d1 1
a1 1
/*	$OpenBSD: def.h,v 1.122 2012/05/29 05:40:36 lum Exp $	*/
d449 2
@


1.122
log
@Increase the size of some window variables from char to int. This diff
improves mg on screens (xterms) with lots of lines.  Testing done by
naddy@@ and myself.
@
text
@d1 1
a1 1
/*	$OpenBSD: def.h,v 1.121 2012/05/25 04:56:58 lum Exp $	*/
d106 2
d518 16
@


1.121
log
@Remove static FILE pointer used for handling files in fileio.c. Pass
by reference instead. This allows the mg startup file to open other
files without unexpected things happening.

Discussed with Sunil Nimmagadda.
@
text
@d1 1
a1 1
/*	$OpenBSD: def.h,v 1.120 2012/04/12 04:47:59 lum Exp $	*/
d197 3
a199 3
	char		 w_toprow;	/* Origin 0 top row of window	*/
	char		 w_ntrows;	/* # of rows of text in window	*/
	char		 w_frame;	/* #lines to reframe by.	*/
@


1.120
log
@Remove the conditional directives NO_MACRO and NO_STARTUP.
They have not compiled for numerous years.
ok kjell@@ millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: def.h,v 1.119 2012/04/11 17:51:10 lum Exp $	*/
d352 1
a352 1
int		 writeout(struct buffer *, char *);
d433 6
a438 6
int		 ffropen(const char *, struct buffer *);
void		 ffstat(struct buffer *);
int		 ffwopen(const char *, struct buffer *);
int		 ffclose(struct buffer *);
int		 ffputbuf(struct buffer *);
int		 ffgetline(char *, int, int *);
@


1.119
log
@Add:
 1. C-x h to mark whole buffer.
 2. M-| to pipe current region to external command.
From Sunil Nimmagadda.

Feedback from deraadt@@ and myself. ok for man page amendments from jmc@@
@
text
@d1 1
a1 1
/*	$OpenBSD: def.h,v 1.118 2011/12/10 14:09:48 lum Exp $	*/
a16 6
#ifdef	NO_MACRO
#ifndef NO_STARTUP
#define NO_STARTUP		/* NO_MACRO implies NO_STARTUP */
#endif
#endif

a590 1
#ifndef NO_MACRO
a594 1
#endif	/* !NO_MACRO */
@


1.118
log
@mail.c was removed 3 yrs 5 months ago.
@
text
@d1 1
a1 1
/*	$OpenBSD: def.h,v 1.117 2011/11/28 04:41:39 lum Exp $	*/
d570 2
@


1.117
log
@Add some ctags support to mg. From Sunil Nimmagadda.

Man page review and suggestions from jmc@@

Revewied and tested by myself, and ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: def.h,v 1.116 2011/01/23 00:45:03 kjell Exp $	*/
a643 2
/* mail.c X */
void		 mail_init(void);
@


1.116
log
@Wrap basename,dirname with xbasename, xdirname funtions,
which have fewer special cases, and use the strlcpy/strlcat
src/dst/buffer len semantic. More portable to boot.
Discussion and feedback from Henri Kemppainen
@
text
@d1 1
a1 1
/*	$OpenBSD: def.h,v 1.115 2011/01/18 16:25:40 kjell Exp $	*/
d518 5
d682 1
a682 1
extern const char	 cinfo[];
@


1.115
log
@Add join-line, bound to M-^
Join the current line to the previous.

original diff by Henri Kemppainen. minor mod to add undo boundaries.
Thanks!
@
text
@d1 1
a1 1
/*	$OpenBSD: def.h,v 1.114 2011/01/17 03:12:06 kjell Exp $	*/
d360 1
@


1.114
log
@Add back-to-indentation. (M-m)
Move the dot to the first non-whitespace character on the current line.
from Henri Kemppainen . ok theo
@
text
@d1 1
a1 1
/*	$OpenBSD: def.h,v 1.113 2010/06/30 19:12:54 oga Exp $	*/
d515 1
@


1.113
log
@you keep saying LIST_END. I do not think it means what you think it
means.

If we hit an OOM condition, mg started to try and dump the older undo buffer
entries in order to be able to continue. OTOH, it was grabbing this entry with
LIST_END, which like all *_END() list macros evaluates to NULL.

Do what we actually want and switch that list to a TAILQ and use
TAILQ_LAST to grab the last entry.

Wrote this a loooooong time ago after a mail from Matthew Dempsky on
bugs@@. ok kjell@@, beck@@ also looked at this months ago and thought it
was alright.
@
text
@d1 1
a1 1
/*	$OpenBSD: def.h,v 1.112 2009/06/05 18:02:06 kjell Exp $	*/
d514 1
@


1.112
log
@emacs handles the undo of a region kill (C-w) differently than a line kill
(C-k) with respect to cursor position. The former leaves the cursor at the end,
the latter at the beginning of the region.

emacs is wacky.

Make mg undo do the same. ok deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: def.h,v 1.111 2009/06/04 23:39:37 kjell Exp $	*/
d237 1
d264 1
a264 1
	LIST_HEAD(, undo_rec) b_undo;	/* Undo actions list		*/
d291 1
a291 1
	LIST_ENTRY(undo_rec) next;
@


1.111
log
@Add the notion of an "ephemeral" popup, so we can flag a window
for destruction at a later date. (in the process, add a window flag field)

This fixes an issue noted by maja: namely, the *completion*
window that pops up when you try to complete a filename on
buffer load would destroy any second window that you happened
to have open.

ok maja@@
@
text
@d1 1
a1 1
/*	$OpenBSD: def.h,v 1.110 2009/06/04 23:31:47 kjell Exp $	*/
d107 4
a110 3
#define KNONE	0
#define KFORW	1
#define KBACK	2
d295 2
a296 1
		MODIFIED
d625 1
a625 1
int		 undo_add_delete(struct line *, int, int);
@


1.110
log
@Fix problem where line numbers get out of sync on a region-kill (C-w).
Noticed and ok matthieu@@
@
text
@d1 1
a1 1
/*	$OpenBSD: def.h,v 1.109 2009/06/04 02:23:37 kjell Exp $	*/
d205 2
a206 1
	char		 w_rflag;	/* Redisplay Flags.			*/
d229 6
a393 1
struct mgwin   *wpopup(void);
d409 1
a409 1
struct mgwin    *popbuf(struct buffer *);
d413 1
a413 1
int		 popbuftop(struct buffer *);
@


1.109
log
@Rename w_flag to w_rflag. This is not a general purpose
flag: it is for redisplay options only. I need an additional all-purpose
flag, so renaming removes the desire to wrongly overload the existing one.

Turdshine. No functional chage.
@
text
@d1 1
a1 1
/*	$OpenBSD: def.h,v 1.108 2008/09/15 16:13:35 kjell Exp $	*/
d120 1
@


1.108
log
@Expose the undo commands as proper mg functions.
This should have no functional change on undo, but it does facilitate
testing undo behavior.
@
text
@d1 1
a1 1
/*	$OpenBSD: def.h,v 1.107 2008/09/15 16:11:35 kjell Exp $	*/
d204 1
a204 1
	char		 w_flag;	/* Flags.			*/
d213 1
a213 1
 * Window flags are set by command processors to
@


1.107
log
@Enable dirty buffer detection in mg.
Emulate the emacs behavior: after suspend/resume, buffer switch,
or at save time, warn (prompt) the user if the file has been modified
on disk in the interim.
This has already saved my butt numerous times.
ok phessler
@
text
@d1 1
a1 1
/*	$OpenBSD: def.h,v 1.106 2008/06/14 08:39:30 kjell Exp $	*/
d612 2
a613 2
int		 undo_enable(int);
void		 undo_add_boundary(void);
d617 1
a617 1
void		 undo_boundary_enable(int);
@


1.106
log
@Add compile (c-C c-P) to the c-mode keymap (export from grep.c)
Also, attempt to make indent an atomic undo operation.
@
text
@d1 1
a1 1
/*	$OpenBSD: def.h,v 1.105 2008/06/14 07:38:53 kjell Exp $	*/
d275 2
a276 1

d408 1
d429 1
d440 2
@


1.105
log
@unf*ck undo.
No seriously. Reposition the cursor to the start of the redo
position, like emacs. This gets us halfway to being emacs-finger-friendly.
For the rest, introduce a rptcount variable to count successive invocations
of the same function. This means undo will abort properly on C-g, and
other such interruptions.
This is a lot of diff for a simple-seeming problem. Emacs undo is hard.
@
text
@d1 1
a1 1
/*	$OpenBSD: def.h,v 1.104 2008/06/13 19:10:17 kjell Exp $	*/
d634 1
@


1.104
log
@phessler noted that c-mode ignored blinking braces.
Add "c-handle-special-brace" which does a blink and indent, rather
than just a selfinsert and indent
@
text
@d1 1
a1 1
/*	$OpenBSD: def.h,v 1.103 2008/06/12 01:58:44 kjell Exp $	*/
d671 1
@


1.103
log
@Introduce a basic c-mode to mg.

The intent of this mode is NOT to copy emacs's monster cc-mode.
It is intended to handle basic KNF-format C, assisting
with indentation (to catch obvious typos), and strip
trailing whitespace. It is NOT enabled unless you ask for it (c-mode).

Basically, tab on start-of-line whitespace acts like tab.
Otherwise, tab indents.

Please try it out and let me know where it falls down.

Feedback Reyk, phessler. "hack in tree" from henning, theo
@
text
@d1 1
a1 1
/*	$OpenBSD: def.h,v 1.102 2008/06/11 23:18:33 kjell Exp $	*/
d625 1
@


1.102
log
@Add delete-leading-space, delete-trailing-space,
indent-current-line utility functions for stripping leading/trailing
whitespace, and setting a fixed indent respectively.
@
text
@d1 1
a1 1
/*	$OpenBSD: def.h,v 1.101 2008/06/10 23:23:53 kjell Exp $	*/
d623 6
@


1.101
log
@Add a clear-mark function.
Use it to clear the region it is copied (M-w), or yanked (C-w).
This matches xemacs behavior, is not horribly different from gnu
emacs, and way less wrong than the current behavior.
Noticed by Han Boetes. ok otto@@
@
text
@d1 1
a1 1
/*	$OpenBSD: def.h,v 1.100 2007/05/28 17:52:17 kjell Exp $	*/
d492 3
@


1.100
log
@Add a global-wd-mode command, which toggles between the current
behavior (every buffer maintains its own cwd) and the old behavior of
one global working directory. This makes it slightly easier to hack
on things like kernel code, where compilation, etc, are initiated from
a different directory than you are working in.
While here, fix setting/handling of global wd.
@
text
@d1 1
a1 1
/*	$OpenBSD: def.h,v 1.99 2007/02/21 23:33:12 deanna Exp $	*/
d479 1
@


1.99
log
@Fix a reference to WFHARD in a comment; it was renamed WFFULL months
ago.

ok kjell
@
text
@d1 1
a1 1
/*	$OpenBSD: def.h,v 1.98 2006/11/19 16:51:19 deraadt Exp $	*/
d622 1
@


1.98
log
@spacing
@
text
@d1 1
a1 1
/*	$OpenBSD: def.h,v 1.97 2006/11/17 08:45:31 kjell Exp $	*/
d215 1
a215 1
 * mapped by the window. Setting "WFHARD" is always a safe thing
@


1.97
log
@Fix a needless inversion of flag names; i.e. change them from the
negative to the positive. undo_boundary_enable(TRUE) makes a LOT more
sense than undo_no_boundary(FALSE).
While here, whack a global, and fix a bug noted by otto:
undoing a file insertion sometimes left stray characters around.
ok beck@@, otto@@
@
text
@d1 1
a1 1
/*	$OpenBSD: def.h,v 1.96 2006/08/01 22:16:03 jason Exp $	*/
d46 1
a46 1
#define KCLEAR	2		/* clear echo area 		 */
@


1.96
log
@* move sys/queue.h inclusion to sysdef.h (it's system specific)
* add <signal.h> to sysdef.h (needed for sig_atomic_t on linux, and
we get it by accident on OpenBSD)
* remove <signal.h> from tty.c/spawn.c (not needed now that it's in sysdef.h)
ok beck
@
text
@d1 1
a1 1
/*	$OpenBSD: def.h,v 1.95 2006/07/25 08:27:09 kjell Exp $	*/
d602 1
d608 1
a608 1
void		 undo_no_boundary(int);
@


1.95
log
@Add bfirstlp(), blastlp() macros, returning the first and last lines
of a buffer respectively. Removes an ugly construction than necessitated
"go to first line"-type comments throughout the code.
No binary change
@
text
@d1 1
a1 1
/*	$OpenBSD: def.h,v 1.94 2006/07/25 08:22:32 kjell Exp $	*/
a3 2

#include <sys/queue.h>
@


1.94
log
@Rename the header line of a buffer to b_headp, from the remarkably
unintuitive b_linep. No binary change.
@
text
@d1 1
a1 1
/*	$OpenBSD: def.h,v 1.93 2006/07/08 17:56:10 kjell Exp $	*/
d265 4
@


1.93
log
@Introduce a 'MODIFIED' boundary type for undo records.
This allows undo to clear the modified flag when undo-ing all the way
from a loaded buffer.
Originally whipped up at c2k6 after proddings from beck.
jason@@ ok.
@
text
@d1 1
a1 1
/*	$OpenBSD: def.h,v 1.93 2006/06/20 05:17:14 kjell Exp $	*/
d239 1
a239 1
 * a pointer to the header line in "b_linep".
d246 1
a246 1
	struct line	*b_linep;	/* Link to the header line	 */
@


1.92
log
@Display line number in the mg statusbar.  Yes, it seems like a fugly
way to do it, but all the clever and pretty ways utterly failed.
Basic use seems fine. We'll turdshine the special cases later.

If it bothers you, use M-x line-number-mode, or put same in your ~/.mg
file to disable.

ok cloder, jason
@
text
@d1 1
a1 1
/*	$OpenBSD: def.h,v 1.91 2006/06/01 05:34:52 jason Exp $	*/
d282 2
a283 1
		BOUNDARY
d602 1
@


1.91
log
@make // /~ path rewriting optional in adjustname() and use it everywhere
except for the command line specified files.  ok kjell,cloder
@
text
@d1 1
a1 1
/*	$OpenBSD: def.h,v 1.90 2006/05/29 00:02:23 kjell Exp $	*/
d208 2
d259 3
d410 1
@


1.90
log
@Another mnemonic rename, missed the first time.
Also missed the ok cloder.
@
text
@d1 1
a1 1
/*	$OpenBSD: def.h,v 1.88 2006/05/27 21:20:11 kjell Exp $	*/
d423 1
a423 1
char		*adjustname(const char *);
@


1.89
log
@Make Window Flags more mnemonic (and less dumb); i.e.
WFHARD -> WFFULL (Redraw full window)
WFFORCE -> WFFRAME (Reframe window).
No binary change
@
text
@d205 1
a205 1
	char		 w_force;	/* If NZ, forcing row.		*/
@


1.88
log
@Move mg "line to c-string" functionality to a function.
@
text
@d1 1
a1 1
/*	$OpenBSD: def.h,v 1.87 2006/05/08 21:24:24 kjell Exp $	*/
d221 1
a221 1
#define WFFORCE 0x01			/* Force reframe.		 */
d224 1
a224 1
#define WFHARD	0x08			/* Better to a full display.	 */
@


1.87
log
@spacing
@
text
@d1 1
a1 1
/*	$OpenBSD: def.h,v 1.86 2006/05/02 17:10:25 kjell Exp $	*/
d353 1
@


1.86
log
@Make buffers store their own working directory. This makes things like
grep, compile, lint work as expected (act on current buffer's cwd).
Display this path when opening or replacing a file, rather than
relying on the user to guess, or remember.
@
text
@d1 1
a1 1
/*	$OpenBSD: def.h,v 1.85 2006/04/06 05:28:17 kjell Exp $	*/
d331 1
a331 1
struct buffer  *findbuffer(char *);
@


1.85
log
@Fix a bug whereby a written buffer (^X^W) would not have the correct
trailing buffer number appended (e.g. "file<2>") in case an existing
buffer shared its basename().
@
text
@d1 1
a1 1
/*	$OpenBSD: def.h,v 1.84 2006/04/03 02:43:22 kjell Exp $	*/
d252 1
d320 1
d380 1
a380 1
struct buffer  *bfind(const char *, int);
d391 2
a392 2
int		 baugname(char *, const char *, size_t);
struct mgwin   *popbuf(struct buffer *);
d397 1
@


1.84
log
@fixed "text in message line would get stuck there" issue.
feedback from Philip Guenther and Han Boetes
@
text
@d1 1
a1 1
/*	$OpenBSD: def.h,v 1.83 2006/02/25 14:40:16 otto Exp $	*/
d389 1
@


1.83
log
@Fix a coredump occurring when the terminal is resized while mg is
suspended. Problem reported and fixed tested by reyk@@; tweak by
kjell@@; ok kjell@@
@
text
@d1 1
a1 1
/*	$OpenBSD: def.h,v 1.82 2005/12/20 06:17:36 kjell Exp $	*/
d48 1
a48 1
#define KPROMPT 2		/* keyboard prompt		 */
@


1.82
log
@Clean up the ugly casted frees. In one case, this meant eliminating a nasty
struct/union/casting nightmare when building the list of names for filename
completion. In particular, be consistent about strduping and freeing
the list data.
@
text
@d1 1
a1 1
/*	$OpenBSD: def.h,v 1.81 2005/12/13 07:20:13 kjell Exp $	*/
d366 1
@


1.81
log
@Last round of easy delinting.
@
text
@d1 1
a1 1
/*	$OpenBSD: def.h,v 1.80 2005/12/13 06:01:27 kjell Exp $	*/
d176 1
a176 1
	const char *l_name;
@


1.80
log
@More name-clash delinting
@
text
@d1 1
a1 1
/*	$OpenBSD: def.h,v 1.79 2005/12/13 05:23:03 kjell Exp $	*/
d588 1
a588 1
int		 undo_add_boundary(void);
@


1.79
log
@If you're going to pass a length parameter, you should use it.
@
text
@d1 1
a1 1
/*	$OpenBSD: def.h,v 1.78 2005/11/22 05:02:44 kjell Exp $	*/
d313 1
a313 1
int		 typeahead(void);
d365 1
a365 1
int		 refresh(int, int);
d444 1
a444 1
char		*keyname(char  *, size_t, int);
d485 1
a485 1
int		 define_key(int, int);
d567 1
a567 1
int		 overwrite(int, int);
@


1.78
log
@Move kill-related commands to their own file.
This will help move to a kill-ring.
@
text
@d1 1
a1 1
/*	$OpenBSD: def.h,v 1.77 2005/11/20 03:24:17 deraadt Exp $	*/
d527 1
a527 1
int		 region_put_data(const char *, int);
@


1.77
log
@toast NO_DIRED #ifdef; ok kjell
@
text
@d1 1
a1 1
/*	$OpenBSD: def.h,v 1.76 2005/11/18 23:37:30 kjell Exp $	*/
d351 3
d358 2
a478 2
int		 killline(int, int);
int		 yank(int, int);
@


1.76
log
@Split kill buffer code into a separate function.
@
text
@d1 1
a1 1
/*	$OpenBSD: def.h,v 1.75 2005/11/18 23:15:00 kjell Exp $	*/
d69 1
a69 3
#ifndef NO_DIRED
# define FIODIR 5		/* File is a directory		 */
#endif /* !NO_DIRED */
d254 1
a254 2
	int		 b_undopos;	/* Where we were during the	*/
                                        /* last undo action.		*/
a319 1
#ifndef NO_DIRED
a321 1
#endif /* !NO_DIRED */
@


1.75
log
@clean up some comments after theo's cleanup
@
text
@d1 1
a1 1
/*	$OpenBSD: def.h,v 1.74 2005/11/18 20:56:52 deraadt Exp $	*/
d359 1
@


1.74
log
@greedy use of typedef struct was making code harder to read; ok kjell cloder
@
text
@d1 1
a1 1
/*	$OpenBSD: def.h,v 1.73 2005/11/18 17:35:17 kjell Exp $	*/
d109 1
a109 1
 * Flags for "ldelete"/"kinsert"
a114 1

d130 1
a130 1
 * lists of "LINE" structures. These begin at the
d133 1
a133 1
 * the "BUFFER". Each line contains the number of
d151 1
a151 1
 * link from a "LINE *" to a "REFLINE", and fixing the commands
d175 1
a175 1
		struct buffer	*x_bp;	/* l_bp is used by LINE */
d244 1
a244 1
	struct line	*b_dotp;	/* Link to "." LINE structure	 */
d246 1
a246 1
	struct line	*b_linep;	/* Link to the header LINE	 */
d248 1
a248 1
	int		 b_doto;	/* Offset of "." in above LINE	 */
@


1.73
log
@Casefold on replace was killed ages ago (it was wrong). Remove a
leftover (unused) variable.
@
text
@d1 1
a1 1
/*	$OpenBSD: def.h,v 1.72 2005/11/07 23:32:20 kjell Exp $	*/
d122 3
a124 3
typedef struct {
	struct LINE	*r_linep;	/* Origin LINE address.		 */
	int		 r_offset;	/* Origin LINE offset.		 */
d126 1
a126 1
} REGION;
d141 3
a143 3
typedef struct LINE {
	struct LINE	*l_fp;		/* Link to the next line	 */
	struct LINE	*l_bp;		/* Link to the previous line	 */
d147 1
a147 1
} LINE;
d173 1
a173 1
typedef struct LIST {
d175 3
a177 3
		struct MGWIN	*l_wp;
		struct BUFFER	*x_bp;	/* l_bp is used by LINE */
		struct LIST	*l_nxt;
d180 1
a180 1
} LIST;
d198 6
a203 6
typedef struct MGWIN {
	LIST		 w_list;	/* List header			*/
	struct BUFFER	*w_bufp;	/* Buffer displayed in window	*/
	struct LINE	*w_linep;	/* Top line in the window	*/
	struct LINE	*w_dotp;	/* Line containing "."		*/
	struct LINE	*w_markp;	/* Line containing "mark"	*/
d210 2
a211 2
	struct LINE	*w_wrapline;
} MGWIN;
d242 7
a248 7
typedef struct BUFFER {
	LIST		 b_list;	/* buffer list pointer		 */
	struct BUFFER	*b_altb;	/* Link to alternate buffer	 */
	struct LINE	*b_dotp;	/* Link to "." LINE structure	 */
	struct LINE	*b_markp;	/* ditto for mark		 */
	struct LINE	*b_linep;	/* Link to the header LINE	 */
	struct MAPS_S	*b_modes[PBMODES]; /* buffer modes		 */
d260 1
a260 1
} BUFFER;
d282 1
a282 1
	REGION		 region;
d292 13
a304 13
void	 ttinit(void);
void	 ttreinit(void);
void	 tttidy(void);
void	 ttmove(int, int);
void	 tteeol(void);
void	 tteeop(void);
void	 ttbeep(void);
void	 ttinsl(int, int, int);
void	 ttdell(int, int, int);
void	 ttwindow(int, int);
void	 ttnowindow(void);
void	 ttcolor(int);
void	 ttresize(void);
d309 9
a317 9
void	 ttopen(void);
int	 ttraw(void);
void	 ttclose(void);
int	 ttcooked(void);
int	 ttputc(int);
void	 ttflush(void);
int	 ttgetc(void);
int	 ttwait(int);
int	 typeahead(void);
d320 3
a322 3
void	 dirinit(void);
int	 changedir(int, int);
int	 showcwdir(int, int);
d326 1
a326 1
BUFFER	*dired_(char *);
d330 14
a343 14
int	 fileinsert(int, int);
int	 filevisit(int, int);
int	 filevisitalt(int, int);
int	 filevisitro(int, int);
int	 poptofile(int, int);
BUFFER  *findbuffer(char *);
int	 readin(char *);
int	 insertfile(char *, char *, int);
int	 filewrite(int, int);
int	 filesave(int, int);
int	 buffsave(BUFFER *);
int	 makebkfile(int, int);
int	 writeout(BUFFER *, char *);
void	 upmodes(BUFFER *);
d346 14
a359 14
LINE	*lalloc(int);
int	 lrealloc(LINE *, int);
void	 lfree(LINE *);
void	 lchange(int);
int	 linsert_str(const char *, int);
int	 linsert(int, int);
int	 lnewline_at(LINE *, int);
int	 lnewline(void);
int	 ldelete(RSIZE, int);
int	 ldelnewline(void);
int	 lreplace(RSIZE, char *);
void	 kdelete(void);
int	 kinsert(int, int);
int	 kremove(int);
d362 12
a373 12
MGWIN	*new_window(BUFFER *);
void	 free_window(MGWIN *);
int	 reposition(int, int);
int	 refresh(int, int);
int	 nextwind(int, int);
int	 prevwind(int, int);
int	 onlywind(int, int);
int	 splitwind(int, int);
int	 enlargewind(int, int);
int	 shrinkwind(int, int);
int	 delwind(int, int);
MGWIN   *wpopup(void);
d376 8
a383 8
int	 togglereadonly(int, int);
BUFFER  *bfind(const char *, int);
int	 poptobuffer(int, int);
int	 killbuffer(BUFFER *);
int	 killbuffer_cmd(int, int);
int	 savebuffers(int, int);
int	 listbuffers(int, int);
int	 addlinef(BUFFER *, char *, ...);
d385 8
a392 8
int	 anycb(int);
int	 bclear(BUFFER *);
int	 showbuffer(BUFFER *, MGWIN *, int);
MGWIN   *popbuf(BUFFER *);
int	 bufferinsert(int, int);
int	 usebuffer(int, int);
int	 notmodified(int, int);
int	 popbuftop(BUFFER *);
d395 4
a398 4
int	vtresize(int, int, int);
void	vtinit(void);
void	vttidy(void);
void	update(void);
d401 8
a408 8
void	 eerase(void);
int	 eyorn(const char *);
int	 eyesno(const char *);
void	 ewprintf(const char *fmt, ...);
char	*ereply(const char *, char *, size_t, ...);
char	*eread(const char *, char *, size_t, int, ...);
int	 getxtra(LIST *, LIST *, int, int);
void	 free_file_list(LIST *);
d411 11
a421 11
int	 ffropen(const char *, BUFFER *);
int	 ffwopen(const char *, BUFFER *);
int	 ffclose(BUFFER *);
int	 ffputbuf(BUFFER *);
int	 ffgetline(char *, int, int *);
int	 fbackupfile(const char *);
char	*adjustname(const char *);
char	*startupfile(char *);
int	 copy(char *, char *);
LIST	*make_file_list(char *);
int	 fisdir(const char *);
d424 11
a434 11
int	 do_meta(int, int);
int	 bsmap(int, int);
void	 ungetkey(int);
int	 getkey(int);
int	 doin(void);
int	 rescan(int, int);
int	 universal_argument(int, int);
int	 digit_argument(int, int);
int	 negative_argument(int, int);
int	 selfinsert(int, int);
int	 quote(int, int);
d437 2
a438 2
int	 ctrlg(int, int);
int	 quit(int, int);
d441 1
a441 1
void	 panic(char *);
d444 1
a444 1
char	*keyname(char  *, size_t, int);
d447 19
a465 19
int	 gotobol(int, int);
int	 backchar(int, int);
int	 gotoeol(int, int);
int	 forwchar(int, int);
int	 gotobob(int, int);
int	 gotoeob(int, int);
int	 forwline(int, int);
int	 backline(int, int);
void	 setgoal(void);
int	 getgoal(LINE *);
int	 forwpage(int, int);
int	 backpage(int, int);
int	 forw1page(int, int);
int	 back1page(int, int);
int	 pagenext(int, int);
void	 isetmark(void);
int	 setmark(int, int);
int	 swapmark(int, int);
int	 gotoline(int, int);
d468 14
a481 14
int	 showcpos(int, int);
int	 getcolpos(void);
int	 twiddle(int, int);
int	 openline(int, int);
int	 newline(int, int);
int	 deblank(int, int);
int	 justone(int, int);
int	 delwhite(int, int);
int	 indent(int, int);
int	 forwdel(int, int);
int	 backdel(int, int);
int	 killline(int, int);
int	 yank(int, int);
int	 space_to_tabstop(int, int);
d484 12
a495 12
int	 insert(int, int);
int	 bindtokey(int, int);
int	 localbind(int, int);
int	 define_key(int, int);
int	 unbindtokey(int, int);
int	 localunbind(int, int);
int	 extend(int, int);
int	 evalexpr(int, int);
int	 evalbuffer(int, int);
int	 evalfile(int, int);
int	 load(const char *);
int	 excline(char *);
d498 4
a501 4
int	 desckey(int, int);
int	 wallchart(int, int);
int	 help_help(int, int);
int	 apropos_command(int, int);
d504 6
a509 6
int	 gotobop(int, int);
int	 gotoeop(int, int);
int	 fillpara(int, int);
int	 killpara(int, int);
int	 fillword(int, int);
int	 setfillcol(int, int);
d512 8
a519 8
int	 backword(int, int);
int	 forwword(int, int);
int	 upperword(int, int);
int	 lowerword(int, int);
int	 capword(int, int);
int	 delfword(int, int);
int	 delbword(int, int);
int	 inword(void);
d522 8
a529 8
int	 killregion(int, int);
int	 copyregion(int, int);
int	 lowerregion(int, int);
int	 upperregion(int, int);
int	 prefixregion(int, int);
int	 setprefix(int, int);
int	 region_get_data(REGION *, char *, int);
int	 region_put_data(const char *, int);
d532 9
a540 9
int	 forwsearch(int, int);
int	 backsearch(int, int);
int	 searchagain(int, int);
int	 forwisearch(int, int);
int	 backisearch(int, int);
int	 queryrepl(int, int);
int	 forwsrch(void);
int	 backsrch(void);
int	 readpattern(char *);
d543 1
a543 1
int	 spawncli(int, int);
d546 2
a547 2
void	 ttykeymapinit(void);
void	 ttykeymaptidy(void);
d550 1
a550 1
int	 showmatch(int, int);
d553 1
a553 1
int	 showversion(int, int);
d557 3
a559 3
int	 definemacro(int, int);
int	 finishmacro(int, int);
int	 executemacro(int, int);
d563 3
a565 3
int	 indentmode(int, int);
int	 fillmode(int, int);
int	 blinkparen(int, int);
d567 1
a567 1
int	 notabmode(int, int);
d569 2
a570 2
int	 overwrite(int, int);
int	 set_default_mode(int,int);
d574 10
a583 10
int	 re_forwsearch(int, int);
int	 re_backsearch(int, int);
int	 re_searchagain(int, int);
int	 re_queryrepl(int, int);
int	 replstr(int, int);
int	 setcasefold(int, int);
int	 delmatchlines(int, int);
int	 delnonmatchlines(int, int);
int	 cntmatchlines(int, int);
int	 cntnonmatchlines(int, int);
d587 9
a595 9
void	 free_undo_record(struct undo_rec *);
int	 undo_dump(int, int);
int	 undo_enable(int);
int	 undo_add_boundary(void);
int	 undo_add_insert(LINE *, int, int);
int	 undo_add_delete(LINE *, int, int);
void	 undo_no_boundary(int);
int	 undo_add_change(LINE *, int, int);
int	 undo(int, int);
d598 3
a600 3
int	 auto_execute(int, int);
PF	*find_autoexec(const char *);
int	 add_autoexec(const char *, const char *);
d603 1
a603 1
void	 mail_init(void);
d606 1
a606 1
int	 next_error(int, int);
d611 23
a633 23
extern BUFFER	*bheadp;
extern BUFFER	*curbp;
extern MGWIN	*curwp;
extern MGWIN	*wheadp;
extern int	 thisflag;
extern int	 lastflag;
extern int	 curgoal;
extern int	 startrow;
extern int	 epresf;
extern int	 sgarbf;
extern int	 mode;
extern int	 nrow;
extern int	 ncol;
extern int	 ttrow;
extern int	 ttcol;
extern int	 tttop;
extern int	 ttbot;
extern int	 tthue;
extern int	 defb_nmodes;
extern int	 defb_flag;
extern const char cinfo[];
extern char	*keystrings[];
extern char	 pat[NPAT];
d635 1
a635 1
extern char	 prompt[];
d641 3
a643 3
int	 tceeol;
int	 tcinsl;
int	 tcdell;
@


1.72
log
@Move most of the dired hooks into dired.c.  While here, enable some
dired functions that were written, but not bound to keys. No other
functional change.

Tested by Han Boetes.
@
text
@d1 1
a1 1
/*	$OpenBSD: def.h,v 1.71 2005/10/14 06:41:47 kjell Exp $	*/
d356 1
a356 1
int	 lreplace(RSIZE, char *, int);
@


1.71
log
@move the dired routines into dired.c where they belong.
ok cloder@@
@
text
@d1 1
a1 1
/*	$OpenBSD: def.h,v 1.70 2005/10/13 20:23:01 kjell Exp $	*/
a325 12
int	 dired(int, int);
int	 d_otherwindow(int, int);
int	 d_undel(int, int);
int	 d_undelbak(int, int);
int	 d_findfile(int, int);
int	 d_ffotherwindow(int, int);
int	 d_expunge(int, int);
int	 d_copy(int, int);
int	 d_del(int, int);
int	 d_rename(int, int);
int	 d_shell_command(int, int);
int	 d_create_directory(int, int);
@


1.70
log
@Make dired buffer read-only by default.
Noticed by Han Boetes
@
text
@d1 1
a1 1
/*	$OpenBSD: def.h,v 1.69 2005/10/13 19:46:45 kjell Exp $	*/
d324 1
d338 2
a431 2
BUFFER  *dired_(char *);
int	 d_makename(LINE  *, char *, int);
@


1.69
log
@Use dired mode automatically if file specified for loading is
a directory. Modified version of patch from Han Boetes.
ok cloder@@
@
text
@d1 1
a1 1
/*	$OpenBSD: def.h,v 1.68 2005/10/13 05:24:52 kjell Exp $	*/
d432 1
@


1.68
log
@Make mg's grep and compile more path-aware, by defaulting to
the path of the invoking buffer.
Also, make subshell output look more like emacs (show directory,
completion time). oked at one point by deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: def.h,v 1.67 2005/10/11 01:08:53 kjell Exp $	*/
d69 3
@


1.67
log
@A while back, undo records were moved from the BUFFER struct to MGWIN.
This is nonsensical, and utterly broken if you are undo-ing across
multiple buffers. Change them back to being associated with the BUFFER
struct. (effectively, just revert the original change)

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: def.h,v 1.66 2005/10/11 00:50:00 kjell Exp $	*/
d40 1
@


1.66
log
@Enable the 'next-error' (C-x `) keybinding by default.
Niklas, this one is for you.
ok deraadt@@, cloder@@
@
text
@d1 1
a1 1
/*	$OpenBSD: def.h,v 1.65 2005/10/06 16:48:00 kjell Exp $	*/
a205 4
	LIST_HEAD(, undo_rec) w_undo;	/* Undo actions list		*/
	int		 w_undopos;	/* Where we were during the	*/
                                        /* last undo action.		*/
	struct undo_rec *w_undoptr;
d252 4
@


1.65
log
@Make mg undo much more emacs like (and correct).
Undo boundaries are now placed at newlines, and undo
of search-replace works as expected. Fixes bad behaviour
reported by matthieu

Ok deraadt@@, beck@@
@
text
@d1 1
a1 1
/*	$OpenBSD: def.h,v 1.64 2005/06/14 18:14:40 kjell Exp $	*/
d610 3
@


1.64
log
@Add explicit public domain notices to all public domain files.
ok millert@@, deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: def.h,v 1.63 2005/05/31 20:38:59 kjell Exp $	*/
d599 1
@


1.63
log
@fix broken minibuffer defaults introduced in echo.c:1.33
adds eread flag EFDEF allowing null minibuffer response
noticed by otto
ok cloder@@ jason@@, works otto@@
@
text
@d1 3
a3 1
/*	$OpenBSD: def.h,v 1.62 2005/05/30 13:13:50 jason Exp $	*/
@


1.62
log
@add find-alternate-file command and binding for ^X^V; ok cloder
(you're welcome kjell)
@
text
@d1 1
a1 1
/*	$OpenBSD: def.h,v 1.61 2005/05/27 08:08:18 cloder Exp $	*/
d100 1
@


1.61
log
@Add emacs-style replace-string function that does not prompt you
to confirm replacements.
OK jason, deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: def.h,v 1.60 2005/04/03 02:09:28 db Exp $	*/
d334 1
@


1.60
log
@This is a no binary change which does:

- spelling, punctuation fixes
- variable declaration lineup
- use parentheses for return and sizeof
- K&R function declarations -> ANSI
- other minor code beautification

ok henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: def.h,v 1.59 2005/03/12 06:16:07 deraadt Exp $	*/
d580 1
@


1.59
log
@spacing
@
text
@d1 1
a1 1
/*	$OpenBSD: def.h,v 1.58 2005/03/10 18:27:47 henning Exp $	*/
d37 1
a37 1
#define NKNAME	20		/* Length, key names		 */
d56 1
a56 1
#define CFINS	0x0004		/* Last command was self-insert */
d96 1
a96 1
#define EFAUTO	0x0007		/* Some autocompleteion on	 */
d117 2
a118 2
	int		r_offset;	/* Origin LINE offset.		 */
	RSIZE		r_size;		/* Length in characters.	 */
d127 1
a127 1
 * the "BUFFER". Each line contains a the number of
d135 5
a139 5
	struct LINE	*l_fp;	/* Link to the next line	 */
	struct LINE	*l_bp;	/* Link to the previous line	 */
	int		l_size;	/* Allocated size		 */
	int		l_used;	/* Used size			 */
	char		*l_text;	/* Content of the line */
d162 1
a162 1
 * I decide to do that. it does mean that there are four extra
d192 1
a192 1
	LIST		w_list;		/* List header			*/
d197 9
a205 9
	int		w_doto;		/* Byte offset for "."		*/
	int		w_marko;	/* Byte offset for "mark"	*/
	char		w_toprow;	/* Origin 0 top row of window	*/
	char		w_ntrows;	/* # of rows of text in window	*/
	char		w_force;	/* If NZ, forcing row.		*/
	char		w_flag;		/* Flags.			*/
	LIST_HEAD(, undo_rec) w_undo;	/* Undo actions list */
	int		w_undopos;	/* Where we were during the last
					   undo action */
d240 1
a240 1
	LIST		b_list;		/* buffer list pointer		 */
d246 7
a252 7
	int		b_doto;		/* Offset of "." in above LINE	 */
	int		b_marko;	/* ditto for the "mark"		 */
	short		b_nmodes;	/* number of non-fundamental modes */
	char		b_nwnd;		/* Count of windows on buffer	 */
	char		b_flag;		/* Flags			 */
	char		b_fname[NFILEN];/* File name			 */
	struct fileinfo	b_fi;		/* File attributes		 */
d263 1
a263 2
#define BFREADONLY  0x10		/* read only mode */

d443 1
a443 1
void	panic(char *);
@


1.58
log
@fix more BACKUP/NOBACKUP/NO_BACKUP confusion, again no binary change.
spotted by jmc@@
@
text
@d1 1
a1 1
/*	$OpenBSD: def.h,v 1.57 2005/03/09 16:20:48 jfb Exp $	*/
d204 1
a204 1
	int             w_undopos;      /* Where we were during the last
@


1.57
log
@fix mg's behaviour with regards to files on which we do not have
write access.  diff originally from vincent@@ and forgotten for
a while.

ok rohee@@, "toss it in, i'll bitch if it doesn't work" henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: def.h,v 1.56 2004/07/22 01:25:24 vincent Exp $	*/
a10 2
 * The most common reason to edit this file would be to zap
 * the definition of CVMVAS or BACKUP.
d12 1
@


1.56
log
@stage 1 of the infinite minibuffer work - add support for on the fly
buffer reallocation in veread().  This commit only changes the API.
All the buffers have exactly the same bounds as before for now.

tested by a couple of my very helpful testers!
@
text
@d1 1
a1 1
/*	$OpenBSD: def.h,v 1.55 2004/07/09 13:50:39 vincent Exp $	*/
d382 2
a383 1
int	 killbuffer(int, int);
@


1.55
log
@when saving a file, check whether it is newline terminated and if it is not,
prompt the user and add the newline if he agrees.

tested by a lot of helpful tech@@ guys, approved by henning
@
text
@d1 1
a1 1
/*	$OpenBSD: def.h,v 1.54 2004/01/27 23:43:37 vincent Exp $	*/
d407 2
a408 2
int	 ereply(const char *, char *, int, ...);
int	 eread(const char *, char *, int, int, ...);
@


1.54
log
@make mail-mode more intelligent on middle-of-line insertions, and add a
comment to change the wrapping column. (mail-set-margin)

tested by henning and phessler, thanks!
@
text
@d1 1
a1 1
/*	$OpenBSD: def.h,v 1.53 2003/11/29 17:28:40 vincent Exp $	*/
d355 1
@


1.53
log
@save the previous undo position as an offset in the buffer instead of
a line/offset pair
@
text
@d1 1
a1 1
/*	$OpenBSD: def.h,v 1.52 2003/11/09 01:11:14 vincent Exp $	*/
d208 1
d353 1
@


1.52
log
@remove the only use of the hackish undo_add_custom function.
@
text
@d1 1
a1 1
/*	$OpenBSD: def.h,v 1.51 2003/11/09 00:20:06 vincent Exp $	*/
d205 1
a205 1
	REGION          w_undopos;      /* Where we were during the last
@


1.51
log
@remove unused structure element
@
text
@d1 1
a1 1
/*	$OpenBSD: def.h,v 1.50 2003/10/27 11:21:12 vincent Exp $	*/
a588 1
int	 undo_add_custom(int, int, LINE *, int, void *, int);
@


1.50
log
@fix crash on startup by using the good allocation routine in edinit()

spotted and ok by henning
@
text
@d1 1
a1 1
/*	$OpenBSD: def.h,v 1.49 2003/10/21 22:48:07 vincent Exp $	*/
a277 1
	int		 size;
@


1.49
log
@make undo records per MGWIN, not per BUFFER...
@
text
@d1 1
a1 1
/*	$OpenBSD: def.h,v 1.48 2003/08/15 23:23:18 vincent Exp $	*/
d363 2
@


1.48
log
@make dired work more like emacs. (well, make it _work_, and then add a
bunch of missing commands)
@
text
@d1 1
a1 1
/*	$OpenBSD: def.h,v 1.47 2003/06/26 23:04:10 vincent Exp $	*/
d109 14
d204 4
a229 11
 * This structure holds the starting position
 * (as a line/offset pair) and the number of characters in a
 * region of a buffer. This makes passing the specification
 * of a region around a little bit easier.
 */
typedef struct {
	struct LINE	*r_linep;	/* Origin LINE address.		 */
	int		r_offset;	/* Origin LINE offset.		 */
	RSIZE		r_size;		/* Length in characters.	 */
} REGION;
/*
a252 4
	LIST_HEAD(, undo_rec) b_undo;	/* Undo actions list */
	REGION          b_undopos;      /* Where we were during the last
					   undo action */
	struct undo_rec *b_undoptr;
a253 1

@


1.47
log
@protos

ok deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: def.h,v 1.46 2003/05/05 11:12:07 vincent Exp $	*/
d328 2
@


1.46
log
@add a mail-mode, to do automatic line-wrapping.

(at the same time, change the command line parsing to support a
 -f <mode> that is slightly different from the one in gnu emacs,
we apply it to all buffers created from command line arguments,
so you can use "mg -f mail-mode" as your editor. manpage change
coming soon)

ok henning
@
text
@d1 1
a1 1
/*	$OpenBSD: def.h,v 1.45 2003/01/06 17:04:09 deraadt Exp $	*/
d24 1
a24 1
typedef int	(*PF)();	/* generally useful type */
d371 1
a371 1
int	 togglereadonly(void);
d582 1
a582 1
int	 undo_dump(void);
@


1.45
log
@support +number; rewritten from buggy code by mjc@@bitz.ca, vincent ok
@
text
@d1 1
a1 1
/*	$OpenBSD: def.h,v 1.44 2002/07/24 14:08:33 vincent Exp $	*/
d595 3
@


1.44
log
@ remove the CHANGE undo record type, use a combination of delete and insert
to have the same behavior in a simpler way.

 ok art@@
@
text
@d1 1
a1 1
/*	$OpenBSD: def.h,v 1.43 2002/07/01 14:33:44 vincent Exp $	*/
d606 1
@


1.43
log
@KNF + ansi; from zyrnix (only the easy part of his diffs)
@
text
@d1 1
a1 1
/*	$OpenBSD: def.h,v 1.42 2002/06/21 00:54:55 vincent Exp $	*/
a271 1
		CHANGE,
@


1.42
log
@remove the "extern" for a variable that does not exist anymore.
@
text
@d1 1
a1 1
/*	$OpenBSD: def.h,v 1.41 2002/05/29 12:41:42 vincent Exp $	*/
d203 5
a207 5
#define WFFORCE 0x01		/* Force reframe.		 */
#define WFMOVE	0x02		/* Movement from line to line.	 */
#define WFEDIT	0x04		/* Editing within a line.	 */
#define WFHARD	0x08		/* Better to a full display.	 */
#define WFMODE	0x10		/* Update mode line.		 */
d255 2
a256 2
#define BFCHG	0x01		/* Changed.			 */
#define BFBAK	0x02		/* Need to make a backup.	 */
d258 1
a258 1
#define BFNOTAB 0x04		/* no tab mode			 */
d260 2
a261 2
#define BFOVERWRITE 0x08	/* overwrite mode		 */
#define BFREADONLY  0x10	/* read only mode */
@


1.41
log
@ add an "auto-execute" feature, that allows binding function calls to
certain patterns. for example, `auto-execute "*.c" auto-indent-mode'.

 ok art@@
@
text
@d1 1
a1 1
/*	$OpenBSD: def.h,v 1.40 2002/05/29 12:32:51 vincent Exp $	*/
a616 1
extern int	 undoaction;
@


1.40
log
@ add a function to visit a file read-only mapped to C-x C-v

 ok art@@
@
text
@d1 1
a1 1
/*	$OpenBSD: def.h,v 1.39 2002/03/18 01:45:54 vincent Exp $	*/
d591 5
@


1.39
log
@ Enter the new undo code.  it is still disabled since it has bugs, but it's
somewhat more useful....

 ok millert@@ + no objections on ICB
@
text
@d1 1
a1 1
/*	$OpenBSD: def.h,v 1.38 2002/03/16 20:29:21 vincent Exp $	*/
d333 1
@


1.38
log
@ This should've been commited yesterday, before the funmap change.

 ok millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: def.h,v 1.37 2002/03/16 04:17:36 vincent Exp $	*/
d212 11
d247 3
a264 12
 * This structure holds the starting position
 * (as a line/offset pair) and the number of characters in a
 * region of a buffer. This makes passing the specification
 * of a region around a little bit easier.
 */
typedef struct {
	struct LINE	*r_linep;	/* Origin LINE address.		 */
	int		r_offset;	/* Origin LINE offset.		 */
	RSIZE		r_size;		/* Length in characters.	 */
} REGION;

/*
a581 1
int	 undo_init(void);
d584 1
a584 1
int	 undo_add_custom(int, LINE *, int, void *, int);
@


1.37
log
@ add readonly buffer support
 plus some KNF

 ok art@@
@
text
@d1 1
a1 1
/*	$OpenBSD: def.h,v 1.36 2002/03/11 13:02:56 vincent Exp $	*/
d581 1
@


1.36
log
@  * Move to ANSI function definitions.
  * Add a whole lot of consts where I thought it made sense

   no ok, but no objections either...
@
text
@d1 1
a1 1
/*	$OpenBSD: def.h,v 1.35 2002/02/26 00:45:45 vincent Exp $	*/
d237 1
d247 2
d369 1
@


1.35
log
@keep undo records in the BUFFER structures insteda of having a huge list.
@
text
@d1 1
a1 1
/*	$OpenBSD: def.h,v 1.34 2002/02/21 15:27:29 deraadt Exp $	*/
d159 1
a159 1
	char *l_name;
d366 1
a366 1
BUFFER  *bfind(char *, int);
d390 2
a391 2
int	 eyorn(char *);
int	 eyesno(char *);
d399 2
a400 2
int	 ffropen(char *, BUFFER *);
int	 ffwopen(char *, BUFFER *);
d404 2
a405 2
int	 fbackupfile(char *);
char	*adjustname(char *);
d483 1
a483 1
int	 load(char *);
@


1.34
log
@KNF
@
text
@d1 1
a1 1
/*	$OpenBSD: def.h,v 1.33 2002/02/21 04:21:05 vincent Exp $	*/
d209 2
d235 1
a263 1
	BUFFER		*buf;
a274 2
   
LIST_HEAD(undo_list, undo_rec);
d575 1
@


1.33
log
@ Save undo records for newline insertions.

 That makes mg behave more like GNU emacs.
@
text
@d1 1
a1 1
/*	$OpenBSD: def.h,v 1.32 2002/02/21 04:16:27 vincent Exp $	*/
d260 2
a261 2
        LIST_ENTRY(undo_rec) next;
        BUFFER          *buf;
d271 1
a271 1
        char            *content;
@


1.32
log
@
 Don't ignore the argument to undo. (makes ^U work)
@
text
@d1 1
a1 1
/*	$OpenBSD: def.h,v 1.31 2002/02/21 00:02:04 deraadt Exp $	*/
d577 1
@


1.31
log
@signal-safe window size changing
@
text
@d1 1
a1 1
/*	$OpenBSD: def.h,v 1.30 2002/02/20 22:30:54 vincent Exp $	*/
d581 1
a581 1
int	 undo(void);
@


1.30
log
@ Add undo code to mg.

 needs further hacking.

 ok `whole bunch of people on icb'@@
@
text
@d1 1
a1 1
/*	$OpenBSD: def.h,v 1.29 2002/02/16 21:27:49 millert Exp $	*/
d294 2
@


1.29
log
@Part one of userland __P removal.  Done with a simple regexp with some minor hand editing to make comments line up correctly.  Another pass is forthcoming that handles the cases that could not be done automatically.
@
text
@d1 3
a3 1
/*	$OpenBSD: def.h,v 1.28 2002/02/14 22:58:20 vincent Exp $	*/
d257 20
d515 2
d572 9
d601 1
a616 1

@


1.28
log
@d_makename now takes a length parameter so we can remove the
strcpy call.
@
text
@d1 1
a1 1
/*	$OpenBSD: def.h,v 1.27 2002/02/14 13:41:44 deraadt Exp $	*/
d259 13
a271 13
void	 ttinit			__P((void));
void	 ttreinit		__P((void));
void	 tttidy			__P((void));
void	 ttmove			__P((int, int));
void	 tteeol			__P((void));
void	 tteeop			__P((void));
void	 ttbeep			__P((void));
void	 ttinsl			__P((int, int, int));
void	 ttdell			__P((int, int, int));
void	 ttwindow		__P((int, int));
void	 ttnowindow		__P((void));
void	 ttcolor		__P((int));
void	 ttresize		__P((void));
d274 9
a282 9
void	 ttopen			__P((void));
int	 ttraw			__P((void));
void	 ttclose		__P((void));
int	 ttcooked		__P((void));
int	 ttputc			__P((int));
void	 ttflush		__P((void));
int	 ttgetc			__P((void));
int	 ttwait			__P((int));
int	 typeahead		__P((void));
d285 3
a287 3
void	 dirinit		__P((void));
int	 changedir		__P((int, int));
int	 showcwdir		__P((int, int));
d290 10
a299 10
int	 dired			__P((int, int));
int	 d_otherwindow		__P((int, int));
int	 d_undel		__P((int, int));
int	 d_undelbak		__P((int, int));
int	 d_findfile		__P((int, int));
int	 d_ffotherwindow	__P((int, int));
int	 d_expunge		__P((int, int));
int	 d_copy			__P((int, int));
int	 d_del			__P((int, int));
int	 d_rename		__P((int, int));
d302 12
a313 12
int	 fileinsert		__P((int, int));
int	 filevisit		__P((int, int));
int	 poptofile		__P((int, int));
BUFFER  *findbuffer		__P((char *));
int	 readin			__P((char *));
int	 insertfile		__P((char *, char *, int));
int	 filewrite		__P((int, int));
int	 filesave		__P((int, int));
int	 buffsave		__P((BUFFER *));
int	 makebkfile		__P((int, int));
int	 writeout		__P((BUFFER *, char *));
void	 upmodes		__P((BUFFER *));
d316 12
a327 12
LINE	*lalloc			__P((int));
int	 lrealloc		__P((LINE *, int));
void	 lfree			__P((LINE *));
void	 lchange		__P((int));
int	 linsert		__P((int, int));
int	 lnewline		__P((void));
int	 ldelete		__P((RSIZE, int));
int	 ldelnewline		__P((void));
int	 lreplace		__P((RSIZE, char *, int));
void	 kdelete		__P((void));
int	 kinsert		__P((int, int));
int	 kremove		__P((int));
d330 10
a339 10
int	 reposition		__P((int, int));
int	 refresh		__P((int, int));
int	 nextwind		__P((int, int));
int	 prevwind		__P((int, int));
int	 onlywind		__P((int, int));
int	 splitwind		__P((int, int));
int	 enlargewind		__P((int, int));
int	 shrinkwind		__P((int, int));
int	 delwind		__P((int, int));
MGWIN   *wpopup			__P((void));
d342 6
a347 6
BUFFER  *bfind			__P((char *, int));
int	 poptobuffer		__P((int, int));
int	 killbuffer		__P((int, int));
int	 savebuffers		__P((int, int));
int	 listbuffers		__P((int, int));
int	 addlinef		__P((BUFFER *, char *, ...));
d349 8
a356 8
int	 anycb			__P((int));
int	 bclear			__P((BUFFER *));
int	 showbuffer		__P((BUFFER *, MGWIN *, int));
MGWIN   *popbuf			__P((BUFFER *));
int	 bufferinsert		__P((int, int));
int	 usebuffer		__P((int, int));
int	 notmodified		__P((int, int));
int	 popbuftop		__P((BUFFER *));
d359 4
a362 4
int	vtresize		__P((int, int, int));
void	vtinit			__P((void));
void	vttidy			__P((void));
void	update			__P((void));
d365 8
a372 8
void	 eerase			__P((void));
int	 eyorn			__P((char *));
int	 eyesno			__P((char *));
void	 ewprintf		__P((const char *fmt, ...));
int	 ereply			__P((const char *, char *, int, ...));
int	 eread			__P((const char *, char *, int, int, ...));
int	 getxtra		__P((LIST *, LIST *, int, int));
void	 free_file_list	__P((LIST *));
d375 12
a386 12
int	 ffropen		__P((char *, BUFFER *));
int	 ffwopen		__P((char *, BUFFER *));
int	 ffclose		__P((BUFFER *));
int	 ffputbuf		__P((BUFFER *));
int	 ffgetline		__P((char *, int, int *));
int	 fbackupfile		__P((char *));
char	*adjustname		__P((char *));
char	*startupfile		__P((char *));
int	 copy			__P((char *, char *));
BUFFER  *dired_			__P((char *));
int	 d_makename		__P((LINE  *, char *, int));
LIST	*make_file_list		__P((char *));
d389 11
a399 11
int	 do_meta		__P((int, int));
int	 bsmap			__P((int, int));
void	 ungetkey		__P((int));
int	 getkey			__P((int));
int	 doin			__P((void));
int	 rescan			__P((int, int));
int	 universal_argument	__P((int, int));
int	 digit_argument		__P((int, int));
int	 negative_argument	__P((int, int));
int	 selfinsert		__P((int, int));
int	 quote			__P((int, int));
d402 2
a403 2
int	 ctrlg			__P((int, int));
int	 quit			__P((int, int));
d406 1
a406 1
void	panic			__P((char *));
d409 1
a409 1
char	*keyname		__P((char  *, size_t, int));
d412 19
a430 19
int	 gotobol		__P((int, int));
int	 backchar		__P((int, int));
int	 gotoeol		__P((int, int));
int	 forwchar		__P((int, int));
int	 gotobob		__P((int, int));
int	 gotoeob		__P((int, int));
int	 forwline		__P((int, int));
int	 backline		__P((int, int));
void	 setgoal		__P((void));
int	 getgoal		__P((LINE *));
int	 forwpage		__P((int, int));
int	 backpage		__P((int, int));
int	 forw1page		__P((int, int));
int	 back1page		__P((int, int));
int	 pagenext		__P((int, int));
void	 isetmark		__P((void));
int	 setmark		__P((int, int));
int	 swapmark		__P((int, int));
int	 gotoline		__P((int, int));
d433 14
a446 14
int	 showcpos		__P((int, int));
int	 getcolpos		__P((void));
int	 twiddle		__P((int, int));
int	 openline		__P((int, int));
int	 newline		__P((int, int));
int	 deblank		__P((int, int));
int	 justone		__P((int, int));
int	 delwhite		__P((int, int));
int	 indent			__P((int, int));
int	 forwdel		__P((int, int));
int	 backdel		__P((int, int));
int	 killline		__P((int, int));
int	 yank			__P((int, int));
int	 space_to_tabstop	__P((int, int));
d449 12
a460 12
int	 insert			__P((int, int));
int	 bindtokey		__P((int, int));
int	 localbind		__P((int, int));
int	 define_key		__P((int, int));
int	 unbindtokey		__P((int, int));
int	 localunbind		__P((int, int));
int	 extend			__P((int, int));
int	 evalexpr		__P((int, int));
int	 evalbuffer		__P((int, int));
int	 evalfile		__P((int, int));
int	 load			__P((char *));
int	 excline		__P((char *));
d463 4
a466 4
int	 desckey		__P((int, int));
int	 wallchart		__P((int, int));
int	 help_help		__P((int, int));
int	 apropos_command	__P((int, int));
d469 6
a474 6
int	 gotobop		__P((int, int));
int	 gotoeop		__P((int, int));
int	 fillpara		__P((int, int));
int	 killpara		__P((int, int));
int	 fillword		__P((int, int));
int	 setfillcol		__P((int, int));
d477 8
a484 8
int	 backword		__P((int, int));
int	 forwword		__P((int, int));
int	 upperword		__P((int, int));
int	 lowerword		__P((int, int));
int	 capword		__P((int, int));
int	 delfword		__P((int, int));
int	 delbword		__P((int, int));
int	 inword			__P((void));
d487 6
a492 6
int	 killregion		__P((int, int));
int	 copyregion		__P((int, int));
int	 lowerregion		__P((int, int));
int	 upperregion		__P((int, int));
int	 prefixregion		__P((int, int));
int	 setprefix		__P((int, int));
d495 9
a503 9
int	 forwsearch		__P((int, int));
int	 backsearch		__P((int, int));
int	 searchagain		__P((int, int));
int	 forwisearch		__P((int, int));
int	 backisearch		__P((int, int));
int	 queryrepl		__P((int, int));
int	 forwsrch		__P((void));
int	 backsrch		__P((void));
int	 readpattern		__P((char *));
d506 1
a506 1
int	 spawncli		__P((int, int));
d509 2
a510 2
void	 ttykeymapinit		__P((void));
void	 ttykeymaptidy		__P((void));
d513 1
a513 1
int	 showmatch		__P((int, int));
d516 1
a516 1
int	 showversion		__P((int, int));
d520 3
a522 3
int	 definemacro		__P((int, int));
int	 finishmacro		__P((int, int));
int	 executemacro		__P((int, int));
d526 3
a528 3
int	 indentmode		__P((int, int));
int	 fillmode		__P((int, int));
int	 blinkparen		__P((int, int));
d530 1
a530 1
int	 notabmode		__P((int, int));
d532 2
a533 2
int	 overwrite		__P((int, int));
int	 set_default_mode	__P((int,int));
d537 9
a545 9
int	 re_forwsearch		__P((int, int));
int	 re_backsearch		__P((int, int));
int	 re_searchagain		__P((int, int));
int	 re_queryrepl		__P((int, int));
int	 setcasefold		__P((int, int));
int	 delmatchlines		__P((int, int));
int	 delnonmatchlines	__P((int, int));
int	 cntmatchlines		__P((int, int));
int	 cntnonmatchlines	__P((int, int));
@


1.27
log
@spelling
@
text
@d1 1
a1 1
/*	$OpenBSD: def.h,v 1.26 2002/02/13 22:36:58 vincent Exp $	*/
d385 1
a385 1
int	 d_makename		__P((LINE  *, char *));
@


1.26
log
@ Make mg malloc the l_text element instead of reallocating whole LINE
 structures all the time.
@
text
@d1 1
a1 1
/*	$OpenBSD: def.h,v 1.25 2002/02/13 03:03:49 vincent Exp $	*/
d84 1
a84 1
#define FFNEGARG	2	/* negitive only argument	 */
@


1.25
log
@ * Replace unsafe strcpy and strcat calls to safe strlcpy and strlcat.
 * Be a little bit more verbose about some errors
 * Fix some memory leaks in fileio.c

ok deraadt@@, art@@
@
text
@d1 1
a1 1
/*	$OpenBSD: def.h,v 1.24 2002/01/18 08:37:08 art Exp $	*/
d124 1
a124 5
#ifndef ZEROARRAY
	char		l_text[1];	/* A bunch of chars.	 */
#else
	char		l_text[];	/* A bunch of chars.	 */
#endif
d317 1
a317 1
LINE	*lallocx		__P((int));
@


1.24
log
@Remove the NROW and NCOL limits. The static arrays are now replaced with
dynamically allocated memory.
Code written by Vincent Labrecque <limitln@@Psyfreaks.CA> with some minor
tweaks by me.
@
text
@d1 1
a1 1
/*	$OpenBSD: def.h,v 1.23 2002/01/10 12:13:35 art Exp $	*/
d576 1
a576 1
extern char	 pat[];
@


1.23
log
@Clean up tty resizing code.
Catch SIGWINCH and resize and refresh the screen.
@
text
@d1 1
a1 1
/*	$OpenBSD: def.h,v 1.22 2002/01/08 12:29:27 millert Exp $	*/
d363 1
@


1.22
log
@typo; mjc@@bitz.ca
@
text
@d1 1
a1 1
/*	$OpenBSD: def.h,v 1.21 2001/05/24 10:43:16 art Exp $	*/
a285 1
void	 setttysize		__P((void));
@


1.21
log
@Make the keymap/mode table growable in runtime.
@
text
@d1 1
a1 1
/*	$OpenBSD: def.h,v 1.18 2001/05/24 03:05:20 mickey Exp $	*/
d81 1
a81 1
 * Flags for keyboard involked functions.
@


1.20
log
@Add a missing piece of something I committed by accident that I
planned to add later.

A new flag to veread (and caller) called EFDEF that indicates that
when a user is prompted for input, a default value is given from start
in the output buffer.
@
text
@a571 1
extern int	 nmaps;
@


1.19
log
@Break out function -> name mappings to an own file.
Add a possibility to dynamically extend the function table.
@
text
@d98 1
@


1.18
log
@spaces
@
text
@d1 1
a1 1
/*	$OpenBSD: def.h,v 1.17 2001/05/23 23:29:47 mickey Exp $	*/
a389 3

/* keymap.c X */
LIST	*complete_function_list	__P((char *, int));
@


1.17
log
@cinfo is const, keyname() and findbind() take buffer size to use strlcpy vs cpy+len
@
text
@d1 1
a1 1
/*	$OpenBSD: def.h,v 1.16 2001/05/23 22:20:35 art Exp $	*/
d22 1
a22 1
typedef int     (*PF)();	/* generally useful type */
d119 4
a122 4
	struct LINE    *l_fp;	/* Link to the next line	 */
	struct LINE    *l_bp;	/* Link to the previous line	 */
	int             l_size;	/* Allocated size		 */
	int             l_used;	/* Used size			 */
d124 1
a124 1
	char            l_text[1];	/* A bunch of chars.	 */
d126 1
a126 1
	char            l_text[];	/* A bunch of chars.	 */
d156 3
a158 3
		struct MGWIN   *l_wp;
		struct BUFFER  *x_bp;	/* l_bp is used by LINE */
		struct LIST    *l_nxt;
d180 11
a190 11
	LIST            w_list;		/* List header			*/
	struct BUFFER  *w_bufp;		/* Buffer displayed in window	*/
	struct LINE    *w_linep;	/* Top line in the window	*/
	struct LINE    *w_dotp;		/* Line containing "."		*/
	struct LINE    *w_markp;	/* Line containing "mark"	*/
	int             w_doto;		/* Byte offset for "."		*/
	int             w_marko;	/* Byte offset for "mark"	*/
	char            w_toprow;	/* Origin 0 top row of window	*/
	char            w_ntrows;	/* # of rows of text in window	*/
	char            w_force;	/* If NZ, forcing row.		*/
	char            w_flag;		/* Flags.			*/
d221 13
a233 13
	LIST            b_list;		/* buffer list pointer		 */
	struct BUFFER  *b_altb;		/* Link to alternate buffer	 */
	struct LINE    *b_dotp;		/* Link to "." LINE structure	 */
	struct LINE    *b_markp;	/* ditto for mark		 */
	struct LINE    *b_linep;	/* Link to the header LINE	 */
	struct MAPS_S  *b_modes[PBMODES]; /* buffer modes		 */
	int             b_doto;		/* Offset of "." in above LINE	 */
	int             b_marko;	/* ditto for the "mark"		 */
	short           b_nmodes;	/* number of non-fundamental modes */
	char            b_nwnd;		/* Count of windows on buffer	 */
	char            b_flag;		/* Flags			 */
	char            b_fname[NFILEN];/* File name			 */
	struct fileinfo b_fi;		/* File attributes		 */
d252 3
a254 3
	struct LINE    *r_linep;	/* Origin LINE address.		 */
	int             r_offset;	/* Origin LINE offset.		 */
	RSIZE           r_size;		/* Length in characters.	 */
d317 1
a317 1
void     upmodes		__P((BUFFER *));
d320 2
a321 2
LINE    *lalloc			__P((int));
LINE    *lallocx		__P((int));
d323 1
a323 1
void     lchange		__P((int));
d327 1
a327 1
int      ldelnewline		__P((void));
d329 1
a329 1
void     kdelete		__P((void));
d363 3
a365 3
void     vtinit			__P((void));
void     vttidy			__P((void));
void     update			__P((void));
d371 1
a371 1
void     ewprintf		__P((const char *fmt, ...));
d383 4
a386 4
int      fbackupfile		__P((char *));
char    *adjustname		__P((char *));
char    *startupfile		__P((char *));
int      copy			__P((char *, char *));
d389 1
a389 1
LIST    *make_file_list		__P((char *));
d412 1
a412 1
void     panic			__P((char *));
d415 1
a415 1
char    *keyname		__P((char  *, size_t, int));
@


1.16
log
@remove VOID. We're way beyond the point where this could build with an
ancient compiler.
@
text
@d1 1
a1 1
/*	$OpenBSD: def.h,v 1.15 2001/05/23 21:59:45 art Exp $	*/
d415 1
a415 1
char    *keyname		__P((char  *, int));
d577 1
a577 1
extern char	 cinfo[];
a581 1
extern char	*promptp;
@


1.15
log
@No need to export nfunct and functnames now that help doesn't use them
anymore. nfunct isn't used anywhere.
@
text
@d1 1
a1 1
/*	$OpenBSD: def.h,v 1.14 2001/05/23 21:42:34 art Exp $	*/
a15 19
/*
 * If your system and/or compiler does not support the "void" type
 * then define NO_VOID_TYPE in sysdef.h.  In the absence of some
 * other definition for VOID, the default in that case will be to
 * turn it into an int, which works with most compilers that don't
 * support void.  In the absence of any definition of VOID or
 * NO_VOID_TYPE, the default is to assume void is supported, which
 * should be the case for most modern C compilers.
 */

#ifdef NO_VOID_TYPE
#undef VOID
#define VOID int		/* Default for no void is int */
#else
#ifndef VOID
#define VOID void		/* Just use normal void */
#endif				/* VOID */
#endif				/* NO_VOID_TYPE */

d262 13
a274 13
VOID	 ttinit			__P((void));
VOID	 ttreinit		__P((void));
VOID	 tttidy			__P((void));
VOID	 ttmove			__P((int, int));
VOID	 tteeol			__P((void));
VOID	 tteeop			__P((void));
VOID	 ttbeep			__P((void));
VOID	 ttinsl			__P((int, int, int));
VOID	 ttdell			__P((int, int, int));
VOID	 ttwindow		__P((int, int));
VOID	 ttnowindow		__P((void));
VOID	 ttcolor		__P((int));
VOID	 ttresize		__P((void));
d277 1
a277 1
VOID	 ttopen			__P((void));
d279 1
a279 1
VOID	 ttclose		__P((void));
d282 1
a282 1
VOID	 ttflush		__P((void));
d285 1
a285 1
VOID	 setttysize		__P((void));
d289 1
a289 1
VOID	 dirinit		__P((VOID));
d317 1
a317 1
VOID     upmodes		__P((BUFFER *));
d322 2
a323 2
VOID	 lfree			__P((LINE *));
VOID     lchange		__P((int));
d329 1
a329 1
VOID     kdelete		__P((void));
d363 3
a365 3
VOID     vtinit			__P((void));
VOID     vttidy			__P((void));
VOID     update			__P((void));
d368 1
a368 1
VOID	 eerase			__P((void));
d371 1
a371 1
VOID     ewprintf		__P((const char *fmt, ...));
d375 1
a375 1
VOID	 free_file_list	__P((LIST *));
d397 1
a397 1
VOID	 ungetkey		__P((int));
d412 1
a412 1
VOID     panic			__P((char *));
d426 1
a426 1
VOID	 setgoal		__P((void));
d433 1
a433 1
VOID	 isetmark		__P((VOID));
@


1.14
log
@export free_file_list. XXX - it doesn't belong in echo.c and it's the wrong name.
@
text
@d1 1
a1 1
/*	$OpenBSD: def.h,v 1.13 2001/05/23 16:26:39 art Exp $	*/
a593 1
extern int	 nfunct;
@


1.13
log
@kill complete_function. Not used anymore.
@
text
@d1 1
a1 1
/*	$OpenBSD: def.h,v 1.12 2001/05/23 15:39:35 art Exp $	*/
d394 1
@


1.12
log
@It's unnecessary to have addline as a function. Make it a macro.
@
text
@d1 1
a1 1
/*	$OpenBSD: def.h,v 1.11 2001/05/23 15:35:10 art Exp $	*/
a409 1
int	 complete_function	__P((char *, int));
@


1.11
log
@Add addlinef that's an addline with printf-style format arguments.
Make addline a wrapper around addlinef. (should go away)
@
text
@d1 1
a1 1
/*	$OpenBSD: def.h,v 1.10 2001/05/04 22:00:35 art Exp $	*/
a369 1
int	 addline		__P((BUFFER *, char *));
d371 1
@


1.10
log
@Cleanups in filename and buffer name handling.
Mostly just using libc instead of rolling our own.
@
text
@d1 1
a1 1
/*	$OpenBSD: def.h,v 1.9 2001/05/03 20:40:22 art Exp $	*/
d371 1
@


1.9
log
@Add a delay (in miliseconds) argument to ttwait.
@
text
@d1 1
a1 1
/*	$OpenBSD: def.h,v 1.8 2001/05/03 12:57:22 art Exp $	*/
a330 1
VOID     makename		__P((char *, char *));
@


1.8
log
@ * Let make_file_list always append a '/' at the end of directories.
   This makes filename TAB-completion more useful, now you don't need to
   write that '/' manually.
 * random cleanups including using snprintf and memcmp where open-coded
   equivalents were used, waitpid instead of 'while (wait() != pid);', etc.
@
text
@d1 1
a1 1
/*	$OpenBSD: def.h,v 1.7 2001/05/01 13:22:00 art Exp $	*/
d303 1
a303 1
int	 ttwait			__P((void));
@


1.7
log
@raise the file name and buffer name sizes
@
text
@d1 1
a1 1
/*	$OpenBSD: def.h,v 1.6 2001/01/29 01:58:06 niklas Exp $	*/
d407 1
a407 1
LIST    *make_file_list		__P((char *, int));
@


1.6
log
@$OpenBSD$
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d46 2
a47 2
#define NFILEN	80		/* Length, file name.		 */
#define NBUFN	24		/* Length, buffer name.		 */
@


1.5
log
@More -Wall anmd KNF, from op2@@tomahawk.SQUiSH.org
@
text
@d1 2
@


1.4
log
@The start of KNF + -Wall.  The code has been run through indent but
needs hand fixup.  I stopped at keymap.c...
@
text
@d39 1
a39 1
typedef int     (*PF) ();	/* generaly useful type */
d278 14
a291 14
/* tty.c */
VOID	 ttinit		__P((void));
VOID	 ttreinit	__P((void));
VOID	 tttidy		__P((void));
VOID	 ttmove		__P((int, int));
VOID	 tteeol		__P((void));
VOID	 tteeop		__P((void));
VOID	 ttbeep		__P((void));
VOID	 ttinsl		__P((int, int, int));
VOID	 ttdell		__P((int, int, int));
VOID	 ttwindow	__P((int, int));
VOID	 ttnowindow	__P((void));
VOID	 ttcolor	__P((int));
VOID	 ttresize	__P((void));
d294 10
a303 10
VOID	 ttopen		__P((void));
int	 ttraw		__P((void));
VOID	 ttclose	__P((void));
int	 ttcooked	__P((void));
int	 ttputc		__P((int));
VOID	 ttflush	__P((void));
int	 ttgetc		__P((void));
int	 ttwait		__P((void));
VOID	 setttysize	__P((void));
int	 typeahead	__P((void));
d306 3
a308 3
VOID	 dirinit	__P((VOID));
int	 changedir	__P((int, int));
int	 showcwdir	__P((int, int));
d311 51
a361 39
int	 dired		__P((int, int));
int	 d_otherwindow	__P((int, int));
int	 d_undel	__P((int, int));
int	 d_undelbak	__P((int, int));
int	 d_findfile	__P((int, int));
int	 d_ffotherwindow __P((int, int));
int	 d_expunge	__P((int, int));
int	 d_copy		__P((int, int));
int	 d_del		__P((int, int));
int	 d_rename	__P((int, int));

/* file.c */
int	 fileinsert	__P((int, int));
int	 filevisit	__P((int, int));
int	 poptofile	__P((int, int));
BUFFER  *findbuffer	__P((char *));
int	 readin		__P((char *));
int	 insertfile	__P((char *, char *, int));
VOID     makename	__P((char *, char *));
int	 filewrite	__P((int, int));
int	 filesave	__P((int, int));
int	 buffsave	__P((BUFFER *));
int	 makebkfile	__P((int, int));
int	 writeout	__P((BUFFER *, char *));
VOID     upmodes	__P((BUFFER *));

/* line.c */
LINE    *lalloc		__P((int));
LINE    *lallocx	__P((int));
int	 lnewline	__P((void));
VOID	 lfree		__P((LINE *));
VOID     lchange	__P((int));
VOID     kdelete	__P((void));
int      ldelnewline	__P((void));
int	 linsert	__P((int, int));

/* window.c */
MGWIN   *wpopup		__P((void));
int	 nextwind	__P((int, int));
d364 14
a377 14
BUFFER  *bfind		__P((char *, int));
int	 poptobuffer	__P((int, int));
int	 killbuffer	__P((int, int));
int	 savebuffers	__P((int, int));
int	 listbuffers	__P((int, int));
int	 addline	__P((BUFFER *, char *));
int	 anycb		__P((int));
int	 bclear		__P((BUFFER *));
int	 showbuffer	__P((BUFFER *, MGWIN *, int));
MGWIN   *popbuf		__P((BUFFER *));
int	 bufferinsert	__P((int, int));
int	 usebuffer	__P((int, int));
int	 notmodified	__P((int, int));
int	 popbuftop	__P((BUFFER *));
d380 12
a391 11
VOID     vtinit		__P((void));
VOID     vttidy		__P((void));
VOID     update		__P((void));

/* echo.c */
int	 eyorn		__P((char *));
int	 eyesno		__P((char *));
VOID     ewprintf	__P((const char *fmt, ...));
int	 ereply		__P((const char *, char *, int, ...));
int	 eread		__P((const char *, char *, int, int, ...));
int	 getxtra	__P((LIST *, LIST *, int, int));
d394 12
a405 12
int	 ffropen	__P((char *, BUFFER *));
int	 ffwopen	__P((char *, BUFFER *));
int	 ffclose	__P((BUFFER *));
int	 ffputbuf	__P((BUFFER *));
int	 ffgetline	__P((char *, int, int *));
int      fbackupfile	__P((char *));
char    *adjustname	__P((char *));
char    *startupfile	__P((char *));
int      copy		__P((char *, char *));
BUFFER  *dired_		__P((char *));
int	 d_makename	__P((LINE  *, char *));
LIST    *make_file_list	__P((char *, int));
d407 2
a408 1
/* keymap.c */
a409 1
int	 complete_function	__P((char *, int));
d411 12
a422 12
/* kbd.c */
int	 do_meta	__P((int, int));
int	 bsmap		__P((int, int));
VOID	 ungetkey	__P((int));
int	 getkey		__P((int));
int	 doin		__P((void));
int	 rescan		__P((int, int));
int	 universal_argument __P((int, int));
int	 digit_argument	__P((int, int));
int	 negative_argument __P((int, int));
int	 selfinsert	__P((int, int));
int	 quote		__P((int, int));
d425 2
a426 1
int	 ctrlg		__P((int, int));
d429 1
a429 1
VOID     panic		__P((char *));
d432 1
a432 1
char    *keyname	__P((char  *, int));
d435 135
a569 43
int	 gotobol	__P((int, int));
int	 backchar	__P((int, int));
int	 gotoeol	__P((int, int));
int	 forwchar	__P((int, int));
int	 gotobob	__P((int, int));
int	 gotoeob	__P((int, int));
int	 forwline	__P((int, int));
int	 backline	__P((int, int));
VOID	 setgoal	__P((void));
int	 getgoal	__P((LINE *));
int	 forwpage	__P((int, int));
int	 backpage	__P((int, int));
int	 forw1page	__P((int, int));
int	 back1page	__P((int, int));
int	 pagenext	__P((int, int));
VOID	 isetmark	__P((VOID));
int	 setmark	__P((int, int));
int	 swapmark	__P((int, int));
int	 gotoline	__P((int, int));

/* random.c */
int	 getcolpos	__P((void));
int	 newline	__P((int, int));

/* extend.c */
int	 insert		__P((int, int));
int	 bindtokey	__P((int, int));
int	 localbind	__P((int, int));
int	 define_key	__P((int, int));
int	 unbindtokey	__P((int, int));
int	 localunbind	__P((int, int));
int	 extend		__P((int, int));
int	 evalexpr	__P((int, int));
int	 evalbuffer	__P((int, int));
int	 evalfile	__P((int, int));
int	 load		__P((char *));
int	 excline	__P((char *));

/* help.c */
int	 desckey	__P((int, int));
int	 wallchart	__P((int, int));
int	 help_help	__P((int, int));
int	 apropos_command __P((int, int));
d574 36
a609 21
extern int      thisflag;
extern int      lastflag;
extern int      curgoal;
extern int      epresf;
extern int      sgarbf;
extern int      mode;
extern MGWIN   *curwp;
extern BUFFER  *curbp;
extern MGWIN   *wheadp;
extern BUFFER  *bheadp;
extern char     pat[];
extern int      nrow;
extern int      ncol;
extern int      ttrow;
extern int      ttcol;
extern int      tthue;
extern int      tceeol;
extern int      tcinsl;
extern int      tcdell;
extern char     cinfo[];
extern char    *keystrings[];
@


1.3
log
@change WINDOW -> MGWIN to avoid curses type conflict
convert to terminfo in tty*.c
add support for some keypad function keys (arrows, pgup, pgdown)
@
text
@d3 1
a3 1
 * of the MicroEMACS display editor. It contains all of the
d10 1
a10 1
#include	"sysdef.h"		/* Order is critical.		*/
d25 2
a26 2
#  undef VOID
#  define VOID int			/* Default for no void is int */
d29 3
a31 3
#  define VOID void			/* Just use normal void */
#endif /* VOID */
#endif /* NO_VOID_TYPE */
d35 1
a35 1
#define NO_STARTUP			/* NO_MACRO implies NO_STARTUP */
d39 1
a39 1
typedef int (*PF)();			/* generaly useful type */
d44 10
a53 10
#define NFILEN	80			/* Length, file name.		*/
#define NBUFN	24			/* Length, buffer name.		*/
#define NLINE	256			/* Length, line.		*/
#define PBMODES 4			/* modes per buffer		*/
#define NKBDM	256			/* Length, keyboard macro.	*/
#define NPAT	80			/* Length, pattern.		*/
#define HUGE	1000			/* A rather large number.	*/
#define NSRCH	128			/* Undoable search commands.	*/
#define NXNAME	64			/* Length, extended command.	*/
#define NKNAME	20			/* Length, key names		*/
d57 3
a59 3
#define FALSE	0			/* False, no, bad, etc.		*/
#define TRUE	1			/* True, yes, good, etc.	*/
#define ABORT	2			/* Death, ^G, abort, etc.	*/
d61 1
a61 1
#define KPROMPT 2			/* keyboard prompt		*/
d70 3
a72 3
#define CFCPCN	0x0001			/* Last command was C-P, C-N	*/
#define CFKILL	0x0002			/* Last command was a kill	*/
#define CFINS	0x0004			/* Last command was self-insert */
d77 5
a81 5
#define FIOSUC	0			/* Success.			*/
#define FIOFNF	1			/* File not found.		*/
#define FIOEOF	2			/* End of file.			*/
#define FIOERR	3			/* Error.			*/
#define FIOLONG 4			/* long line partially read	*/
d86 3
a88 3
#define DIOSUC	0			/* Success.			*/
#define DIOEOF	1			/* End of file.			*/
#define DIOERR	2			/* Error.			*/
d93 12
a104 11
#define CNONE	0			/* Unknown color.		*/
#define CTEXT	1			/* Text color.			*/
#define CMODE	2			/* Mode line color.		*/

/* Flags for keyboard involked functions */

#define FFUNIV		1		/* universal argument		*/
#define FFNEGARG	2		/* negitive only argument	*/
#define FFOTHARG	4		/* other argument		*/
#define FFARG		7		/* any argument			*/
#define FFRAND		8		/* Called by other function	*/
d109 6
a114 6
#define EFFUNC	0x0001			/* Autocomplete functions.	*/
#define EFBUF	0x0002			/* Autocomplete buffers.	*/
#define EFFILE	0x0004			/* " files (maybe someday)	*/
#define EFAUTO	0x0007			/* Some autocompleteion on	*/
#define EFNEW	0x0008			/* New prompt.			*/
#define EFCR	0x0010			/* Echo CR at end; last read.	*/
a118 1

d135 5
a139 5
typedef struct	LINE {
	struct	LINE *l_fp;		/* Link to the next line	*/
	struct	LINE *l_bp;		/* Link to the previous line	*/
	int	l_size;			/* Allocated size		*/
	int	l_used;			/* Used size			*/
d141 1
a141 1
	char	l_text[1];		/* A bunch of characters.	*/
d143 1
a143 1
	char	l_text[];		/* A bunch of characters.	*/
d145 1
a145 1
}	LINE;
d173 3
a175 3
		struct MGWIN	*l_wp;
		struct BUFFER	*x_bp;	/* l_bp is used by LINE */
		struct LIST	*l_nxt;
d177 1
a177 1
	char	*l_name;
d179 1
d196 13
a208 13
typedef struct	MGWIN {
	LIST	w_list;			/* List header		       */
	struct	BUFFER *w_bufp;		/* Buffer displayed in window	*/
	struct	LINE *w_linep;		/* Top line in the window	*/
	struct	LINE *w_dotp;		/* Line containing "."		*/
	struct	LINE *w_markp;		/* Line containing "mark"	*/
	int	w_doto;			/* Byte offset for "."		*/
	int	w_marko;		/* Byte offset for "mark"	*/
	char	w_toprow;		/* Origin 0 top row of window	*/
	char	w_ntrows;		/* # of rows of text in window	*/
	char	w_force;		/* If NZ, forcing row.		*/
	char	w_flag;			/* Flags.			*/
}	MGWIN;
d221 5
a225 5
#define WFFORCE 0x01			/* Force reframe.		*/
#define WFMOVE	0x02			/* Movement from line to line.	*/
#define WFEDIT	0x04			/* Editing within a line.	*/
#define WFHARD	0x08			/* Better to a full display.	*/
#define WFMODE	0x10			/* Update mode line.		*/
d237 15
a251 15
typedef struct	BUFFER {
	LIST	b_list;			/* buffer list pointer		*/
	struct	BUFFER *b_altb;		/* Link to alternate buffer	*/
	struct	LINE *b_dotp;		/* Link to "." LINE structure	*/
	struct	LINE *b_markp;		/* ditto for mark		*/
	struct	LINE *b_linep;		/* Link to the header LINE	*/
	struct	MAPS_S *b_modes[PBMODES]; /* buffer modes		*/
	int	b_doto;			/* Offset of "." in above LINE	*/
	int	b_marko;		/* ditto for the "mark"		*/
	short	b_nmodes;		/* number of non-fundamental modes */
	char	b_nwnd;			/* Count of windows on buffer	*/
	char	b_flag;			/* Flags			*/
	char	b_fname[NFILEN];	/* File name			*/
	struct	fileinfo b_fi;		/* File attributes		*/
}	BUFFER;
d255 2
a256 2
#define BFCHG	0x01			/* Changed.			*/
#define BFBAK	0x02			/* Need to make a backup.	*/
d258 1
a258 1
#define BFNOTAB 0x04			/* no tab mode			*/
d260 1
a260 1
#define BFOVERWRITE 0x08		/* overwrite mode		*/
d268 196
a463 5
typedef struct	{
	struct	LINE *r_linep;		/* Origin LINE address.		*/
	int	r_offset;		/* Origin LINE offset.		*/
	RSIZE	r_size;			/* Length in characters.	*/
}	REGION;
d468 21
a488 31
extern	int	thisflag;
extern	int	lastflag;
extern	int	curgoal;
extern	int	epresf;
extern	int	sgarbf;
extern	int	mode;
extern	MGWIN	*curwp;
extern	BUFFER	*curbp;
extern	MGWIN	*wheadp;
extern	BUFFER	*bheadp;
extern	char	pat[];
extern	BUFFER	*bfind();
extern	MGWIN	*popbuf();
extern	MGWIN	*wpopup();
extern	LINE	*lalloc();
extern	LINE	*lallocx();
extern	VOID	ewprintf();
extern	int	nrow;
extern	int	ncol;
extern	int	ttrow;
extern	int	ttcol;
extern	int	tceeol;
extern	int	tcinsl;
extern	int	tcdell;
extern	char	cinfo[];
extern	char	*keystrings[];
extern	VOID	update();
extern	char	*keyname();
extern	char	*adjustname();
extern	VOID	kdelete();
extern	VOID	lchange();
@


1.2
log
@further pruning
@
text
@d173 1
a173 1
		struct WINDOW	*l_wp;
d195 1
a195 1
typedef struct	WINDOW {
d207 1
a207 1
}	WINDOW;
d282 1
a282 1
extern	WINDOW	*curwp;
d284 1
a284 1
extern	WINDOW	*wheadp;
d288 2
a289 2
extern	WINDOW	*popbuf();
extern	WINDOW	*wpopup();
@


1.1
log
@initial import of mg2a
@
text
@a306 6
/*
 * Standard I/O.
 */
extern	char	*strcpy();
extern	char	*strcat();
extern	char	*malloc();
@

