head	1.83;
access;
symbols
	OPENBSD_6_2:1.83.0.2
	OPENBSD_6_2_BASE:1.83
	OPENBSD_6_1:1.83.0.4
	OPENBSD_6_1_BASE:1.83
	OPENBSD_6_0:1.82.0.4
	OPENBSD_6_0_BASE:1.82
	OPENBSD_5_9:1.82.0.2
	OPENBSD_5_9_BASE:1.82
	OPENBSD_5_8:1.71.0.4
	OPENBSD_5_8_BASE:1.71
	OPENBSD_5_7:1.69.0.2
	OPENBSD_5_7_BASE:1.69
	OPENBSD_5_6:1.67.0.4
	OPENBSD_5_6_BASE:1.67
	OPENBSD_5_5:1.65.0.4
	OPENBSD_5_5_BASE:1.65
	OPENBSD_5_4:1.63.0.2
	OPENBSD_5_4_BASE:1.63
	OPENBSD_5_3:1.52.0.2
	OPENBSD_5_3_BASE:1.52
	OPENBSD_5_2:1.51.0.2
	OPENBSD_5_2_BASE:1.51
	OPENBSD_5_1_BASE:1.50
	OPENBSD_5_1:1.50.0.2
	OPENBSD_5_0:1.48.0.4
	OPENBSD_5_0_BASE:1.48
	OPENBSD_4_9:1.48.0.2
	OPENBSD_4_9_BASE:1.48
	OPENBSD_4_8:1.46.0.2
	OPENBSD_4_8_BASE:1.46
	OPENBSD_4_7:1.45.0.2
	OPENBSD_4_7_BASE:1.45
	OPENBSD_4_6:1.45.0.4
	OPENBSD_4_6_BASE:1.45
	OPENBSD_4_5:1.43.0.6
	OPENBSD_4_5_BASE:1.43
	OPENBSD_4_4:1.43.0.4
	OPENBSD_4_4_BASE:1.43
	OPENBSD_4_3:1.43.0.2
	OPENBSD_4_3_BASE:1.43
	OPENBSD_4_2:1.42.0.4
	OPENBSD_4_2_BASE:1.42
	OPENBSD_4_1:1.42.0.2
	OPENBSD_4_1_BASE:1.42
	OPENBSD_4_0:1.41.0.2
	OPENBSD_4_0_BASE:1.41
	OPENBSD_3_9:1.35.0.2
	OPENBSD_3_9_BASE:1.35
	OPENBSD_3_8:1.21.0.2
	OPENBSD_3_8_BASE:1.21
	OPENBSD_3_7:1.14.0.4
	OPENBSD_3_7_BASE:1.14
	OPENBSD_3_6:1.14.0.2
	OPENBSD_3_6_BASE:1.14
	OPENBSD_3_5:1.13.0.4
	OPENBSD_3_5_BASE:1.13
	OPENBSD_3_4:1.13.0.2
	OPENBSD_3_4_BASE:1.13
	OPENBSD_3_3:1.10.0.6
	OPENBSD_3_3_BASE:1.10
	OPENBSD_3_2:1.10.0.4
	OPENBSD_3_2_BASE:1.10
	OPENBSD_3_1:1.10.0.2
	OPENBSD_3_1_BASE:1.10
	OPENBSD_3_0:1.7.0.2
	OPENBSD_3_0_BASE:1.7
	OPENBSD_2_9_BASE:1.6
	OPENBSD_2_9:1.6.0.2
	OPENBSD_2_8:1.5.0.4
	OPENBSD_2_8_BASE:1.5
	OPENBSD_2_7:1.5.0.2
	OPENBSD_2_7_BASE:1.5;
locks; strict;
comment	@ * @;


1.83
date	2016.10.07.00.17.20;	author jsg;	state Exp;
branches;
next	1.82;
commitid	44rWrWkGb8jFCO1K;

1.82
date	2016.01.02.10.39.19;	author lum;	state Exp;
branches;
next	1.81;
commitid	cWRm8x2aZlyBJTgu;

1.81
date	2015.12.11.20.21.23;	author mmcc;	state Exp;
branches;
next	1.80;
commitid	fMxksA90Y2NKlI5v;

1.80
date	2015.10.29.19.46.47;	author lum;	state Exp;
branches;
next	1.79;
commitid	PxYPCO6Bag1LXTJ7;

1.79
date	2015.10.13.20.10.09;	author lum;	state Exp;
branches;
next	1.78;
commitid	kZtawIy6eTgdfmG0;

1.78
date	2015.10.12.19.08.39;	author lum;	state Exp;
branches;
next	1.77;
commitid	aNH8NmTWvN6cB4Om;

1.77
date	2015.09.28.11.56.17;	author lum;	state Exp;
branches;
next	1.76;
commitid	Ar6WiO4O5pZXu1eS;

1.76
date	2015.09.26.21.51.58;	author jasper;	state Exp;
branches;
next	1.75;
commitid	yS81WdIVlzEJxLUH;

1.75
date	2015.09.24.18.20.52;	author lum;	state Exp;
branches;
next	1.74;
commitid	gkRE4pqrLVphOZr6;

1.74
date	2015.09.23.05.03.03;	author lum;	state Exp;
branches;
next	1.73;
commitid	kbonC4x8hhzJRm9G;

1.73
date	2015.09.21.06.59.54;	author lum;	state Exp;
branches;
next	1.72;
commitid	zqoD9YYcFyqA4fF4;

1.72
date	2015.09.14.16.37.19;	author lum;	state Exp;
branches;
next	1.71;
commitid	AmokcTqrR5TloPcq;

1.71
date	2015.03.19.21.48.05;	author bcallah;	state Exp;
branches;
next	1.70;
commitid	8rkHsVfUx5xgPXRB;

1.70
date	2015.03.19.21.22.15;	author bcallah;	state Exp;
branches;
next	1.69;
commitid	GbEBL4CfPvDkB8hj;

1.69
date	2014.12.30.22.05.32;	author bcallah;	state Exp;
branches;
next	1.68;
commitid	E0Zae4TaO35beVhI;

1.68
date	2014.11.16.04.16.41;	author guenther;	state Exp;
branches;
next	1.67;
commitid	a9yG0qCw9VEW27qI;

1.67
date	2014.04.03.20.17.12;	author lum;	state Exp;
branches;
next	1.66;

1.66
date	2014.03.20.07.47.29;	author lum;	state Exp;
branches;
next	1.65;

1.65
date	2013.12.20.15.49.00;	author lum;	state Exp;
branches;
next	1.64;

1.64
date	2013.12.19.19.04.56;	author lum;	state Exp;
branches;
next	1.63;

1.63
date	2013.06.03.05.10.59;	author lum;	state Exp;
branches;
next	1.62;

1.62
date	2013.06.02.10.09.21;	author lum;	state Exp;
branches;
next	1.61;

1.61
date	2013.06.02.09.57.23;	author lum;	state Exp;
branches;
next	1.60;

1.60
date	2013.06.02.09.53.42;	author lum;	state Exp;
branches;
next	1.59;

1.59
date	2013.05.30.17.43.43;	author lum;	state Exp;
branches;
next	1.58;

1.58
date	2013.05.30.04.27.18;	author lum;	state Exp;
branches;
next	1.57;

1.57
date	2013.05.30.04.17.25;	author lum;	state Exp;
branches;
next	1.56;

1.56
date	2013.05.29.19.16.48;	author lum;	state Exp;
branches;
next	1.55;

1.55
date	2013.05.29.05.28.48;	author lum;	state Exp;
branches;
next	1.54;

1.54
date	2013.05.28.18.35.10;	author lum;	state Exp;
branches;
next	1.53;

1.53
date	2013.05.27.18.24.44;	author lum;	state Exp;
branches;
next	1.52;

1.52
date	2012.11.03.15.36.03;	author haesbaert;	state Exp;
branches;
next	1.51;

1.51
date	2012.03.14.13.56.35;	author lum;	state Exp;
branches;
next	1.50;

1.50
date	2011.08.31.03.40.53;	author lum;	state Exp;
branches;
next	1.49;

1.49
date	2011.08.29.11.02.06;	author lum;	state Exp;
branches;
next	1.48;

1.48
date	2011.01.23.00.45.03;	author kjell;	state Exp;
branches;
next	1.47;

1.47
date	2011.01.18.17.35.42;	author lum;	state Exp;
branches;
next	1.46;

1.46
date	2010.06.26.16.18.43;	author kjell;	state Exp;
branches;
next	1.45;

1.45
date	2009.06.04.23.39.37;	author kjell;	state Exp;
branches;
next	1.44;

1.44
date	2009.06.04.02.23.37;	author kjell;	state Exp;
branches;
next	1.43;

1.43
date	2007.09.11.15.47.17;	author gilles;	state Exp;
branches;
next	1.42;

1.42
date	2006.11.01.06.02.29;	author ray;	state Exp;
branches;
next	1.41;

1.41
date	2006.07.25.08.27.09;	author kjell;	state Exp;
branches;
next	1.40;

1.40
date	2006.07.25.08.22.32;	author kjell;	state Exp;
branches;
next	1.39;

1.39
date	2006.06.01.09.00.50;	author kjell;	state Exp;
branches;
next	1.38;

1.38
date	2006.06.01.05.34.52;	author jason;	state Exp;
branches;
next	1.37;

1.37
date	2006.05.28.23.30.16;	author kjell;	state Exp;
branches;
next	1.36;

1.36
date	2006.05.02.17.10.25;	author kjell;	state Exp;
branches;
next	1.35;

1.35
date	2005.12.20.05.04.28;	author kjell;	state Exp;
branches;
next	1.34;

1.34
date	2005.12.13.07.20.13;	author kjell;	state Exp;
branches;
next	1.33;

1.33
date	2005.12.13.06.01.27;	author kjell;	state Exp;
branches;
next	1.32;

1.32
date	2005.11.20.03.24.17;	author deraadt;	state Exp;
branches;
next	1.31;

1.31
date	2005.11.18.20.56.52;	author deraadt;	state Exp;
branches;
next	1.30;

1.30
date	2005.11.13.07.49.02;	author kjell;	state Exp;
branches;
next	1.29;

1.29
date	2005.11.12.20.13.47;	author deraadt;	state Exp;
branches;
next	1.28;

1.28
date	2005.11.07.23.46.18;	author kjell;	state Exp;
branches;
next	1.27;

1.27
date	2005.11.07.23.32.20;	author kjell;	state Exp;
branches;
next	1.26;

1.26
date	2005.10.14.19.46.46;	author kjell;	state Exp;
branches;
next	1.25;

1.25
date	2005.10.14.15.41.33;	author deraadt;	state Exp;
branches;
next	1.24;

1.24
date	2005.10.14.06.41.47;	author kjell;	state Exp;
branches;
next	1.23;

1.23
date	2005.10.13.05.47.44;	author kjell;	state Exp;
branches;
next	1.22;

1.22
date	2005.10.11.01.28.29;	author deraadt;	state Exp;
branches;
next	1.21;

1.21
date	2005.08.09.00.53.48;	author kjell;	state Exp;
branches;
next	1.20;

1.20
date	2005.06.14.18.14.40;	author kjell;	state Exp;
branches;
next	1.19;

1.19
date	2005.05.28.01.53.37;	author cloder;	state Exp;
branches;
next	1.18;

1.18
date	2005.05.15.21.19.08;	author cloder;	state Exp;
branches;
next	1.17;

1.17
date	2005.04.28.07.14.09;	author otto;	state Exp;
branches;
next	1.16;

1.16
date	2005.04.28.07.13.01;	author otto;	state Exp;
branches;
next	1.15;

1.15
date	2005.04.03.02.09.28;	author db;	state Exp;
branches;
next	1.14;

1.14
date	2004.07.22.01.25.24;	author vincent;	state Exp;
branches;
next	1.13;

1.13
date	2003.08.16.00.24.51;	author deraadt;	state Exp;
branches;
next	1.12;

1.12
date	2003.08.15.23.23.18;	author vincent;	state Exp;
branches;
next	1.11;

1.11
date	2003.06.26.23.04.10;	author vincent;	state Exp;
branches;
next	1.10;

1.10
date	2002.03.11.13.02.56;	author vincent;	state Exp;
branches;
next	1.9;

1.9
date	2002.02.15.01.04.59;	author vincent;	state Exp;
branches;
next	1.8;

1.8
date	2002.02.14.22.58.20;	author vincent;	state Exp;
branches;
next	1.7;

1.7
date	2001.05.24.03.05.21;	author mickey;	state Exp;
branches;
next	1.6;

1.6
date	2001.01.29.01.58.06;	author niklas;	state Exp;
branches;
next	1.5;

1.5
date	2000.04.13.06.12.14;	author millert;	state Exp;
branches;
next	1.4;

1.4
date	2000.02.27.05.55.30;	author millert;	state Exp;
branches;
next	1.3;

1.3
date	2000.02.26.23.22.44;	author millert;	state Exp;
branches;
next	1.2;

1.2
date	2000.02.26.22.53.16;	author millert;	state Exp;
branches;
next	1.1;

1.1
date	2000.02.25.19.08.47;	author deraadt;	state Exp;
branches;
next	;


desc
@@


1.83
log
@Switch a SLIST_FOREACH loop containing SLIST_REMOVE to SLIST_FOREACH_SAFE.
ok lum@@ sunil@@
@
text
@/*	$OpenBSD: dired.c,v 1.82 2016/01/02 10:39:19 lum Exp $	*/

/* This file is in the public domain. */

/* dired module for mg 2a
 * by Robert A. Larson
 */

#include <sys/queue.h>
#include <sys/resource.h>
#include <sys/stat.h>
#include <sys/time.h>
#include <sys/types.h>
#include <sys/wait.h>
#include <ctype.h>
#include <err.h>
#include <errno.h>
#include <fcntl.h>
#include <libgen.h>
#include <limits.h>
#include <signal.h>
#include <stdarg.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>

#include "def.h"
#include "funmap.h"
#include "kbd.h"

void		 dired_init(void);
static int	 dired(int, int);
static int	 d_otherwindow(int, int);
static int	 d_undel(int, int);
static int	 d_undelbak(int, int);
static int	 d_findfile(int, int);
static int	 d_ffotherwindow(int, int);
static int	 d_expunge(int, int);
static int	 d_copy(int, int);
static int	 d_del(int, int);
static int	 d_rename(int, int);
static int	 d_exec(int, struct buffer *, const char *, const char *, ...);
static int	 d_shell_command(int, int);
static int	 d_create_directory(int, int);
static int	 d_makename(struct line *, char *, size_t);
static int	 d_warpdot(struct line *, int *);
static int	 d_forwpage(int, int);
static int	 d_backpage(int, int);
static int	 d_forwline(int, int);
static int	 d_backline(int, int);
static int	 d_killbuffer_cmd(int, int);
static int	 d_refreshbuffer(int, int);
static int	 d_filevisitalt(int, int);
static void	 reaper(int);
static struct buffer	*refreshbuffer(struct buffer *);
static int	 createlist(struct buffer *);
static void	 redelete(struct buffer *);
static char 	 *findfname(struct line *, char *);

extern struct keymap_s helpmap, cXmap, metamap;

const char DDELCHAR = 'D';

/*
 * Structure which holds a linked list of file names marked for
 * deletion. Used to maintain dired buffer 'state' between refreshes.
 */
struct delentry {
	SLIST_ENTRY(delentry) entry;
	char   *fn;
};
SLIST_HEAD(slisthead, delentry) delhead = SLIST_HEAD_INITIALIZER(delhead);

static PF dirednul[] = {
	setmark,		/* ^@@ */
	gotobol,		/* ^A */
	backchar,		/* ^B */
	rescan,			/* ^C */
	d_del,			/* ^D */
	gotoeol,		/* ^E */
	forwchar,		/* ^F */
	ctrlg,			/* ^G */
	NULL,			/* ^H */
};

static PF diredcl[] = {
	reposition,		/* ^L */
	d_findfile,		/* ^M */
	d_forwline,		/* ^N */
	rescan,			/* ^O */
	d_backline,		/* ^P */
	rescan,			/* ^Q */
	backisearch,		/* ^R */
	forwisearch,		/* ^S */
	rescan,			/* ^T */
	universal_argument,	/* ^U */
	d_forwpage,		/* ^V */
	rescan,			/* ^W */
	NULL			/* ^X */
};

static PF diredcz[] = {
	spawncli,		/* ^Z */
	NULL,			/* esc */
	rescan,			/* ^\ */
	rescan,			/* ^] */
	rescan,			/* ^^ */
	rescan,			/* ^_ */
	d_forwline,		/* SP */
	d_shell_command,	/* ! */
	rescan,			/* " */
	rescan,			/* # */
	rescan,			/* $ */
	rescan,			/* % */
	rescan,			/* & */
	rescan,			/* ' */
	rescan,			/* ( */
	rescan,			/* ) */
	rescan,			/* * */
	d_create_directory	/* + */
};

static PF direda[] = {
	d_filevisitalt,		/* a */
	rescan,			/* b */
	d_copy,			/* c */
	d_del,			/* d */
	d_findfile,		/* e */
	d_findfile,		/* f */
	d_refreshbuffer		/* g */
};

static PF diredn[] = {
	d_forwline,		/* n */
	d_ffotherwindow,	/* o */
	d_backline,		/* p */
	d_killbuffer_cmd,	/* q */
	d_rename,		/* r */
	rescan,			/* s */
	rescan,			/* t */
	d_undel,		/* u */
	rescan,			/* v */
	rescan,			/* w */
	d_expunge		/* x */
};

static PF direddl[] = {
	d_undelbak		/* del */
};

static PF diredbp[] = {
	d_backpage		/* v */
};

static PF dirednull[] = {
	NULL
};

static struct KEYMAPE (1) d_backpagemap = {
	1,
	1,
	rescan,
	{
		{
		'v', 'v', diredbp, NULL
		}
	}
};

static struct KEYMAPE (7) diredmap = {
	7,
	7,
	rescan,
	{
		{
			CCHR('@@'), CCHR('H'), dirednul, (KEYMAP *) & helpmap
		},
		{
			CCHR('L'), CCHR('X'), diredcl, (KEYMAP *) & cXmap
		},
		{
			CCHR('['), CCHR('['), dirednull, (KEYMAP *) &
			d_backpagemap
		},
		{
			CCHR('Z'), '+', diredcz, (KEYMAP *) & metamap
		},
		{
			'a', 'g', direda, NULL
		},
		{
			'n', 'x', diredn, NULL
		},
		{
			CCHR('?'), CCHR('?'), direddl, NULL
		},
	}
};

void
dired_init(void)
{
	funmap_add(dired, "dired");
	funmap_add(d_undelbak, "dired-unmark-backward");
	funmap_add(d_create_directory, "dired-create-directory");
	funmap_add(d_copy, "dired-do-copy");
	funmap_add(d_expunge, "dired-do-flagged-delete");
	funmap_add(d_findfile, "dired-find-file");
	funmap_add(d_ffotherwindow, "dired-find-file-other-window");
	funmap_add(d_del, "dired-flag-file-deletion");
	funmap_add(d_forwline, "dired-next-line");
	funmap_add(d_otherwindow, "dired-other-window");
	funmap_add(d_backline, "dired-previous-line");
	funmap_add(d_rename, "dired-do-rename");
	funmap_add(d_backpage, "dired-scroll-down");
	funmap_add(d_forwpage, "dired-scroll-up");
	funmap_add(d_undel, "dired-unmark");
	funmap_add(d_killbuffer_cmd, "quit-window");
	maps_add((KEYMAP *)&diredmap, "dired");
	dobindkey(fundamental_map, "dired", "^Xd");
}

/* ARGSUSED */
int
dired(int f, int n)
{
	char		 dname[NFILEN], *bufp, *slash;
	struct buffer	*bp;

	if (curbp->b_fname[0] != '\0') {
		(void)strlcpy(dname, curbp->b_fname, sizeof(dname));
		if ((slash = strrchr(dname, '/')) != NULL) {
			*(slash + 1) = '\0';
		}
	} else {
		if (getcwd(dname, sizeof(dname)) == NULL)
			dname[0] = '\0';
	}

	if ((bufp = eread("Dired: ", dname, NFILEN,
	    EFDEF | EFNEW | EFCR)) == NULL)
		return (ABORT);
	if (bufp[0] == '\0')
		return (FALSE);
	if ((bp = dired_(bufp)) == NULL)
		return (FALSE);

	curbp = bp;
	return (showbuffer(bp, curwp, WFFULL | WFMODE));
}

/* ARGSUSED */
int
d_otherwindow(int f, int n)
{
	char		 dname[NFILEN], *bufp, *slash;
	struct buffer	*bp;
	struct mgwin	*wp;

	if (curbp->b_fname[0] != '\0') {
		(void)strlcpy(dname, curbp->b_fname, sizeof(dname));
		if ((slash = strrchr(dname, '/')) != NULL) {
			*(slash + 1) = '\0';
		}
	} else {
		if (getcwd(dname, sizeof(dname)) == NULL)
			dname[0] = '\0';
	}

	if ((bufp = eread("Dired other window: ", dname, NFILEN,
	    EFDEF | EFNEW | EFCR)) == NULL)
		return (ABORT);
	else if (bufp[0] == '\0')
		return (FALSE);
	if ((bp = dired_(bufp)) == NULL)
		return (FALSE);
	if ((wp = popbuf(bp, WNONE)) == NULL)
		return (FALSE);
	curbp = bp;
	curwp = wp;
	return (TRUE);
}

/* ARGSUSED */
int
d_del(int f, int n)
{
	if (n < 0)
		return (FALSE);
	while (n--) {
		if (d_warpdot(curwp->w_dotp, &curwp->w_doto) == TRUE) {
			lputc(curwp->w_dotp, 0, DDELCHAR);
			curbp->b_flag |= BFDIREDDEL;
		}
		if (lforw(curwp->w_dotp) != curbp->b_headp) {
			curwp->w_dotp = lforw(curwp->w_dotp);
			curwp->w_dotline++;
		}
	}
	curwp->w_rflag |= WFEDIT | WFMOVE;
	return (d_warpdot(curwp->w_dotp, &curwp->w_doto));
}

/* ARGSUSED */
int
d_undel(int f, int n)
{
	if (n < 0)
		return (d_undelbak(f, -n));
	while (n--) {
		if (llength(curwp->w_dotp) > 0)
			lputc(curwp->w_dotp, 0, ' ');
		if (lforw(curwp->w_dotp) != curbp->b_headp) {
			curwp->w_dotp = lforw(curwp->w_dotp);
			curwp->w_dotline++;
		}
	}
	curwp->w_rflag |= WFEDIT | WFMOVE;
	return (d_warpdot(curwp->w_dotp, &curwp->w_doto));
}

/* ARGSUSED */
int
d_undelbak(int f, int n)
{
	if (n < 0)
		return (d_undel(f, -n));
	while (n--) {
		if (lback(curwp->w_dotp) != curbp->b_headp) {
			curwp->w_dotp = lback(curwp->w_dotp);
			curwp->w_dotline--;
		}
		if (llength(curwp->w_dotp) > 0)
			lputc(curwp->w_dotp, 0, ' ');
	}
	curwp->w_rflag |= WFEDIT | WFMOVE;
	return (d_warpdot(curwp->w_dotp, &curwp->w_doto));
}

/* ARGSUSED */
int
d_findfile(int f, int n)
{
	struct buffer	*bp;
	int		 s;
	char		 fname[NFILEN];

	if ((s = d_makename(curwp->w_dotp, fname, sizeof(fname))) == ABORT)
		return (FALSE);
	if (s == TRUE)
		bp = dired_(fname);
	else
		bp = findbuffer(fname);
	if (bp == NULL)
		return (FALSE);
	curbp = bp;
	if (showbuffer(bp, curwp, WFFULL) != TRUE)
		return (FALSE);
	if (bp->b_fname[0] != 0)
		return (TRUE);
	return (readin(fname));
}

/* ARGSUSED */
int
d_ffotherwindow(int f, int n)
{
	char		 fname[NFILEN];
	int		 s;
	struct buffer	*bp;
	struct mgwin	*wp;

	if ((s = d_makename(curwp->w_dotp, fname, sizeof(fname))) == ABORT)
		return (FALSE);
	if ((bp = (s ? dired_(fname) : findbuffer(fname))) == NULL)
		return (FALSE);
	if ((wp = popbuf(bp, WNONE)) == NULL)
		return (FALSE);
	curbp = bp;
	curwp = wp;
	if (bp->b_fname[0] != 0)
		return (TRUE);	/* never true for dired buffers */
	return (readin(fname));
}

/* ARGSUSED */
int
d_expunge(int f, int n)
{
	struct line	*lp, *nlp;
	char		 fname[NFILEN], sname[NFILEN];
	int		 tmp;

	tmp = curwp->w_dotline;
	curwp->w_dotline = 0;

	for (lp = bfirstlp(curbp); lp != curbp->b_headp; lp = nlp) {
		curwp->w_dotline++;
		nlp = lforw(lp);
		if (llength(lp) && lgetc(lp, 0) == 'D') {
			switch (d_makename(lp, fname, sizeof(fname))) {
			case ABORT:
				dobeep();
				ewprintf("Bad line in dired buffer");
				curwp->w_dotline = tmp;
				return (FALSE);
			case FALSE:
				if (unlink(fname) < 0) {
					(void)xbasename(sname, fname, NFILEN);
					dobeep();
					ewprintf("Could not delete '%s'", sname);
					curwp->w_dotline = tmp;
					return (FALSE);
				}
				break;
			case TRUE:
				if (rmdir(fname) < 0) {
					(void)xbasename(sname, fname, NFILEN);
					dobeep();
					ewprintf("Could not delete directory "
					    "'%s'", sname);
					curwp->w_dotline = tmp;
					return (FALSE);
				}
				break;
			}
			lfree(lp);
			curwp->w_bufp->b_lines--;
			if (tmp > curwp->w_dotline)
				tmp--;
			curwp->w_rflag |= WFFULL;
		}
	}
	curwp->w_dotline = tmp;
	d_warpdot(curwp->w_dotp, &curwp->w_doto);

	/* we have deleted all items successfully, remove del flag */
	curbp->b_flag &= ~BFDIREDDEL;

	return (TRUE);
}

/* ARGSUSED */
int
d_copy(int f, int n)
{
	char		 frname[NFILEN], toname[NFILEN], sname[NFILEN];
	char		*topath, *bufp;
	int		 ret;
	size_t		 off;
	struct buffer	*bp;

	if (d_makename(curwp->w_dotp, frname, sizeof(frname)) != FALSE) {
		dobeep();
		ewprintf("Not a file");
		return (FALSE);
	}
	off = strlcpy(toname, curbp->b_fname, sizeof(toname));
	if (off >= sizeof(toname) - 1) {	/* can't happen, really */
		dobeep();
		ewprintf("Directory name too long");
		return (FALSE);
	}
	(void)xbasename(sname, frname, NFILEN);
	bufp = eread("Copy %s to: ", toname, sizeof(toname),
	    EFDEF | EFNEW | EFCR, sname);
	if (bufp == NULL)
		return (ABORT);
	else if (bufp[0] == '\0')
		return (FALSE);

	topath = adjustname(toname, TRUE);
	ret = (copy(frname, topath) >= 0) ? TRUE : FALSE;
	if (ret != TRUE)
		return (ret);
	if ((bp = refreshbuffer(curbp)) == NULL)
		return (FALSE);
	return (showbuffer(bp, curwp, WFFULL | WFMODE));
}

/* ARGSUSED */
int
d_rename(int f, int n)
{
	char		 frname[NFILEN], toname[NFILEN];
	char		*topath, *bufp;
	int		 ret;
	size_t		 off;
	struct buffer	*bp;
	char		 sname[NFILEN];

	if (d_makename(curwp->w_dotp, frname, sizeof(frname)) != FALSE) {
		dobeep();
		ewprintf("Not a file");
		return (FALSE);
	}
	off = strlcpy(toname, curbp->b_fname, sizeof(toname));
	if (off >= sizeof(toname) - 1) {	/* can't happen, really */
		dobeep();
		ewprintf("Directory name too long");
		return (FALSE);
	}
	(void)xbasename(sname, frname, NFILEN);
	bufp = eread("Rename %s to: ", toname,
	    sizeof(toname), EFDEF | EFNEW | EFCR, sname);
	if (bufp == NULL)
		return (ABORT);
	else if (bufp[0] == '\0')
		return (FALSE);

	topath = adjustname(toname, TRUE);
	ret = (rename(frname, topath) >= 0) ? TRUE : FALSE;
	if (ret != TRUE)
		return (ret);
	if ((bp = refreshbuffer(curbp)) == NULL)
		return (FALSE);
	return (showbuffer(bp, curwp, WFFULL | WFMODE));
}

/* ARGSUSED */
void
reaper(int signo __attribute__((unused)))
{
	int	save_errno = errno, status;

	while (waitpid(-1, &status, WNOHANG) >= 0)
		;
	errno = save_errno;
}

/*
 * Pipe the currently selected file through a shell command.
 */
/* ARGSUSED */
int
d_shell_command(int f, int n)
{
	char		 command[512], fname[PATH_MAX], *bufp;
	struct buffer	*bp;
	struct mgwin	*wp;
	char		 sname[NFILEN];

	bp = bfind("*Shell Command Output*", TRUE);
	if (bclear(bp) != TRUE)
		return (ABORT);

	if (d_makename(curwp->w_dotp, fname, sizeof(fname)) != FALSE) {
		dobeep();
		ewprintf("bad line");
		return (ABORT);
	}

	command[0] = '\0';
	(void)xbasename(sname, fname, NFILEN);
	bufp = eread("! on %s: ", command, sizeof(command), EFNEW, sname);
	if (bufp == NULL)
		return (ABORT);

	if (d_exec(0, bp, fname, "sh", "-c", command, NULL) != TRUE)
		return (ABORT);

	if ((wp = popbuf(bp, WNONE)) == NULL)
		return (ABORT);	/* XXX - free the buffer?? */
	curwp = wp;
	curbp = wp->w_bufp;
	return (TRUE);
}

/*
 * Pipe input file to cmd and insert the command's output in the
 * given buffer.  Each line will be prefixed with the given
 * number of spaces.
 */
static int
d_exec(int space, struct buffer *bp, const char *input, const char *cmd, ...)
{
	char	 buf[BUFSIZ];
	va_list	 ap;
	struct	 sigaction olda, newa;
	char	**argv = NULL, *cp;
	FILE	*fin;
	int	 fds[2] = { -1, -1 };
	int	 infd = -1;
	int	 ret = (ABORT), n;
	pid_t	 pid;

	if (sigaction(SIGCHLD, NULL, &olda) == -1)
		return (ABORT);

	/* Find the number of arguments. */
	va_start(ap, cmd);
	for (n = 2; va_arg(ap, char *) != NULL; n++)
		;
	va_end(ap);

	/* Allocate and build the argv. */
	if ((argv = calloc(n, sizeof(*argv))) == NULL) {
		dobeep();
		ewprintf("Can't allocate argv : %s", strerror(errno));
		goto out;
	}

	n = 1;
	argv[0] = (char *)cmd;
	va_start(ap, cmd);
	while ((argv[n] = va_arg(ap, char *)) != NULL)
		n++;
	va_end(ap);

	if (input == NULL)
		input = "/dev/null";

	if ((infd = open(input, O_RDONLY)) == -1) {
		dobeep();
		ewprintf("Can't open input file : %s", strerror(errno));
		goto out;
	}

	if (pipe(fds) == -1) {
		dobeep();
		ewprintf("Can't create pipe : %s", strerror(errno));
		goto out;
	}

	newa.sa_handler = reaper;
	newa.sa_flags = 0;
	if (sigaction(SIGCHLD, &newa, NULL) == -1)
		goto out;

	if ((pid = fork()) == -1) {
		dobeep();
		ewprintf("Can't fork");
		goto out;
	}

	switch (pid) {
	case 0: /* Child */
		close(fds[0]);
		dup2(infd, STDIN_FILENO);
		dup2(fds[1], STDOUT_FILENO);
		dup2(fds[1], STDERR_FILENO);
		if (execvp(argv[0], argv) == -1)
			ewprintf("Can't exec %s: %s", argv[0], strerror(errno));
		exit(1);
		break;
	default: /* Parent */
		close(infd);
		close(fds[1]);
		infd = fds[1] = -1;
		if ((fin = fdopen(fds[0], "r")) == NULL)
			goto out;
		while (fgets(buf, sizeof(buf), fin) != NULL) {
			cp = strrchr(buf, '\n');
			if (cp == NULL && !feof(fin)) {	/* too long a line */
				int c;
				addlinef(bp, "%*s%s...", space, "", buf);
				while ((c = getc(fin)) != EOF && c != '\n')
					;
				continue;
			} else if (cp)
				*cp = '\0';
			addlinef(bp, "%*s%s", space, "", buf);
		}
		fclose(fin);
		break;
	}
	ret = (TRUE);

out:
	if (sigaction(SIGCHLD, &olda, NULL) == -1)
		ewprintf("Warning, couldn't reset previous signal handler");
	if (fds[0] != -1)
		close(fds[0]);
	if (fds[1] != -1)
		close(fds[1]);
	if (infd != -1)
		close(infd);
	free(argv);
	return ret;
}

/* ARGSUSED */
int
d_create_directory(int f, int n)
{
	int ret;
	struct buffer	*bp;

	ret = ask_makedir();
	if (ret != TRUE)
		return(ret);

	if ((bp = refreshbuffer(curbp)) == NULL)
		return (FALSE);

	return (showbuffer(bp, curwp, WFFULL | WFMODE));
}

/* ARGSUSED */
int
d_killbuffer_cmd(int f, int n)
{
	return(killbuffer_cmd(FFRAND, 0));
}

int
d_refreshbuffer(int f, int n)
{
	struct buffer *bp;

	if ((bp = refreshbuffer(curbp)) == NULL)
		return (FALSE);

	return (showbuffer(bp, curwp, WFFULL | WFMODE));
}

/*
 * Kill then re-open the requested dired buffer.
 * If required, take a note of any files marked for deletion. Then once
 * the buffer has been re-opened, remark the same files as deleted.
 */
struct buffer *
refreshbuffer(struct buffer *bp)
{
	char		*tmp_b_fname;
	int	 	 i, tmp_w_dotline, ddel = 0;

	/* remember directory path to open later */
	tmp_b_fname = strdup(bp->b_fname);
	if (tmp_b_fname == NULL) {
		dobeep();
		ewprintf("Out of memory");
		return (NULL);
	}
	tmp_w_dotline = curwp->w_dotline;

	/* create a list of files for deletion */
	if (bp->b_flag & BFDIREDDEL)
		ddel = createlist(bp);

	killbuffer(bp);

	/* dired_() uses findbuffer() to create new buffer */
	if ((bp = dired_(tmp_b_fname)) == NULL) {
		free(tmp_b_fname);
		return (NULL);
	}
	free(tmp_b_fname);

	/* remark any previously deleted files with a 'D' */
	if (ddel)
		redelete(bp);		

	/* find dot line */
	bp->b_dotp = bfirstlp(bp);
	if (tmp_w_dotline > bp->b_lines)
		tmp_w_dotline = bp->b_lines - 1;
	for (i = 1; i < tmp_w_dotline; i++)
		bp->b_dotp = lforw(bp->b_dotp);

	bp->b_dotline = i;
	bp->b_doto = 0;
	d_warpdot(bp->b_dotp, &bp->b_doto);

	curbp = bp;

	return (bp);
}

static int
d_makename(struct line *lp, char *fn, size_t len)
{
	int	 start, nlen;
	char	*namep;

	if (d_warpdot(lp, &start) == FALSE)
		return (ABORT);
	namep = &lp->l_text[start];
	nlen = llength(lp) - start;

	if (snprintf(fn, len, "%s%.*s", curbp->b_fname, nlen, namep) >= len)
		return (ABORT); /* Name is too long. */

	/* Return TRUE if the entry is a directory. */
	return ((lgetc(lp, 2) == 'd') ? TRUE : FALSE);
}

#define NAME_FIELD	9

static int
d_warpdot(struct line *dotp, int *doto)
{
	char *tp = dotp->l_text;
	int off = 0, field = 0, len;

	/*
	 * Find the byte offset to the (space-delimited) filename
	 * field in formatted ls output.
	 */
	len = llength(dotp);
	while (off < len) {
		if (tp[off++] == ' ') {
			if (++field == NAME_FIELD) {
				*doto = off;
				return (TRUE);
			}
			/* Skip the space. */
			while (off < len && tp[off] == ' ')
				off++;
		}
	}
	/* We didn't find the field. */
	*doto = 0;
	return (FALSE);
}

static int
d_forwpage(int f, int n)
{
	forwpage(f | FFRAND, n);
	return (d_warpdot(curwp->w_dotp, &curwp->w_doto));
}

static int
d_backpage (int f, int n)
{
	backpage(f | FFRAND, n);
	return (d_warpdot(curwp->w_dotp, &curwp->w_doto));
}

static int
d_forwline (int f, int n)
{
	forwline(f | FFRAND, n);
	return (d_warpdot(curwp->w_dotp, &curwp->w_doto));
}

static int
d_backline (int f, int n)
{
	backline(f | FFRAND, n);
	return (d_warpdot(curwp->w_dotp, &curwp->w_doto));
}

int
d_filevisitalt (int f, int n)
{
	char	 fname[NFILEN];

	if (d_makename(curwp->w_dotp, fname, sizeof(fname)) == ABORT)
		return (FALSE);

	return(do_filevisitalt(fname));
}

/*
 * XXX dname needs to have enough place to store an additional '/'.
 */
struct buffer *
dired_(char *dname)
{
	struct buffer	*bp;
	int		 i;
	size_t		 len;

	if ((dname = adjustname(dname, TRUE)) == NULL) {
		dobeep();
		ewprintf("Bad directory name");
		return (NULL);
	}
	/* this should not be done, instead adjustname() should get a flag */
	len = strlen(dname);
	if (dname[len - 1] != '/') {
		dname[len++] = '/';
		dname[len] = '\0';
	}
	if ((access(dname, R_OK | X_OK)) == -1) {
		if (errno == EACCES) {
			dobeep();
			ewprintf("Permission denied: %s", dname);
		}
		return (NULL);
	}
	for (bp = bheadp; bp != NULL; bp = bp->b_bufp) {
		if (strcmp(bp->b_fname, dname) == 0) {
			if (fchecktime(bp) != TRUE)
				ewprintf("Directory has changed on disk;"
				    " type g to update Dired");
			return (bp);
		}

	}
	bp = bfind(dname, TRUE);
	bp->b_flag |= BFREADONLY | BFIGNDIRTY;

	if ((d_exec(2, bp, NULL, "ls", "-al", dname, NULL)) != TRUE)
		return (NULL);

	/* Find the line with ".." on it. */
	bp->b_dotp = bfirstlp(bp);
	bp->b_dotline = 1;
	for (i = 0; i < bp->b_lines; i++) {
		bp->b_dotp = lforw(bp->b_dotp);
		bp->b_dotline++;
		if (d_warpdot(bp->b_dotp, &bp->b_doto) == FALSE)
			continue;
		if (strcmp(ltext(bp->b_dotp) + bp->b_doto, "..") == 0)
			break;
	}

	/* We want dot on the entry right after "..", if possible. */
	if (++i < bp->b_lines - 2) {
		bp->b_dotp = lforw(bp->b_dotp);
		bp->b_dotline++;
	}
	d_warpdot(bp->b_dotp, &bp->b_doto);

	(void)strlcpy(bp->b_fname, dname, sizeof(bp->b_fname));
	(void)strlcpy(bp->b_cwd, dname, sizeof(bp->b_cwd));
	if ((bp->b_modes[1] = name_mode("dired")) == NULL) {
		bp->b_modes[0] = name_mode("fundamental");
		dobeep();
		ewprintf("Could not find mode dired");
		return (NULL);
	}
	(void)fupdstat(bp);
	bp->b_nmodes = 1;
	return (bp);
}

/*
 * Iterate through the lines of the dired buffer looking for files
 * collected in the linked list made in createlist(). If a line is found
 * replace 'D' as first char in a line. As lines are found, remove the
 * corresponding item from the linked list. Iterate for as long as there
 * are items in the linked list or until end of buffer is found.
 */
void
redelete(struct buffer *bp)
{
	struct delentry	*dt, *d1 = NULL;
	struct line	*lp, *nlp;
	char		 fname[NFILEN];
	char		*p = fname;
	size_t		 plen, fnlen;
	int		 finished = 0;

	/* reset the deleted file buffer flag until a deleted file is found */
	bp->b_flag &= ~BFDIREDDEL;

	for (lp = bfirstlp(bp); lp != bp->b_headp; lp = nlp) {	
		bp->b_dotp = lp;
		if ((p = findfname(lp, p)) == NULL) {
			nlp = lforw(lp);
			continue;
		}
		plen = strlen(p);
		SLIST_FOREACH_SAFE(d1, &delhead, entry, dt) {
			fnlen = strlen(d1->fn);
			if ((plen == fnlen) && 
			    (strncmp(p, d1->fn, plen) == 0)) {
				lputc(bp->b_dotp, 0, DDELCHAR);
				bp->b_flag |= BFDIREDDEL;
				SLIST_REMOVE(&delhead, d1, delentry, entry);
				if (SLIST_EMPTY(&delhead)) {
					finished = 1;
					break;
				}	
			}
		}
		if (finished)
			break;
		nlp = lforw(lp);
	}
	while (!SLIST_EMPTY(&delhead)) {
		d1 = SLIST_FIRST(&delhead);
		SLIST_REMOVE_HEAD(&delhead, entry);
		free(d1->fn);
		free(d1);
	}
	return;
}

/*
 * Create a list of files marked for deletion.
 */
int
createlist(struct buffer *bp)
{
	struct delentry	*d1 = NULL, *d2;
	struct line	*lp, *nlp;
	char		 fname[NFILEN];
	char		*p = fname;
	int		 ret = FALSE;

	for (lp = bfirstlp(bp); lp != bp->b_headp; lp = nlp) {
		/* 
		 * Check if the line has 'D' on the first char and if a valid
		 * filename can be extracted from it.
		 */
		if (((lp->l_text[0] != DDELCHAR)) ||
		    ((p = findfname(lp, p)) == NULL)) {
			nlp = lforw(lp);
			continue;
		}
		if (SLIST_EMPTY(&delhead)) {
			if ((d1 = malloc(sizeof(struct delentry)))
			     == NULL)
				return (ABORT);
			if ((d1->fn = strdup(p)) == NULL) {
				free(d1);
				return (ABORT);
			}
			SLIST_INSERT_HEAD(&delhead, d1, entry);
		} else {
			if ((d2 = malloc(sizeof(struct delentry)))
			     == NULL) {
				free(d1->fn);
				free(d1);
				return (ABORT);
			}
			if ((d2->fn = strdup(p)) == NULL) {
				free(d1->fn);
				free(d1);
				free(d2);
				return (ABORT);
			}
			SLIST_INSERT_AFTER(d1, d2, entry);
			d1 = d2;				
		}
		ret = TRUE;
		nlp = lforw(lp);
	}
	return (ret);
}

/*
 * Look for and extract a file name on a dired buffer line.
 */
char *
findfname(struct line *lp, char *fn)
{
	int start;

	(void)d_warpdot(lp, &start);
	if (start < 1)
		return NULL;
	fn = &lp->l_text[start];
	return fn;
}
@


1.82
log
@Add dired-find-alternate-file.
@
text
@d1 1
a1 1
/*	$OpenBSD: dired.c,v 1.81 2015/12/11 20:21:23 mmcc Exp $	*/
d942 1
a942 1
	struct delentry	*d1 = NULL;
d959 1
a959 1
		SLIST_FOREACH(d1, &delhead, entry) {
@


1.81
log
@Remove NULL-checks before free().
@
text
@d1 1
a1 1
/*	$OpenBSD: dired.c,v 1.80 2015/10/29 19:46:47 lum Exp $	*/
d54 1
d124 3
a126 1
static PF diredc[] = {
d190 1
a190 1
			'c', 'g', diredc, NULL
d844 11
@


1.80
log
@Fix opening dired from the command line. Incorrect cursor placement
and make the error more useful when there is a problem opening a
directory. Reported by and ok jasper@@
@
text
@d1 1
a1 1
/*	$OpenBSD: dired.c,v 1.79 2015/10/13 20:10:09 lum Exp $	*/
d676 1
a676 2
	if (argv != NULL)
		free(argv);
@


1.79
log
@Check if a file name can be extracted from a line before marking for
deletion.
@
text
@d1 1
a1 1
/*	$OpenBSD: dired.c,v 1.78 2015/10/12 19:08:39 lum Exp $	*/
d868 1
a868 1
			ewprintf("Permission denied");
@


1.78
log
@Maintain a list of files marked for deletion while refreshing a dired
buffer. Previously, when refreshing the buffer the files marked for
deletion would be lost.

Since the relationship between the files that have been marked for
deletion and those that exist on disk is volatile, I have chosen to
implement the discovery of marked files during the refresh function as
opposed to maintaining a dired buffer specific list.
@
text
@d1 1
a1 1
/*	$OpenBSD: dired.c,v 1.77 2015/09/28 11:56:17 lum Exp $	*/
d289 1
a289 1
		if (llength(curwp->w_dotp) > 0) {
@


1.77
log
@Make dired mode treat a double '/' in a path like fundamental mode.
Problem reported by jasper@@ and ok jasper@@
@
text
@d1 1
a1 1
/*	$OpenBSD: dired.c,v 1.76 2015/09/26 21:51:58 jasper Exp $	*/
d56 3
d62 12
d289 4
a292 2
		if (llength(curwp->w_dotp) > 0)
			lputc(curwp->w_dotp, 0, 'D');
d434 4
d716 5
d724 2
a725 1
	char	*tmp;
d727 3
a729 2
	tmp = strdup(bp->b_fname);
	if (tmp == NULL) {
d734 5
d743 2
a744 2
	if ((bp = dired_(tmp)) == NULL) {
		free(tmp);
d747 17
a763 1
	free(tmp);
d917 121
@


1.76
log
@whitespace
@
text
@d1 1
a1 1
/*	$OpenBSD: dired.c,v 1.75 2015/09/24 18:20:52 lum Exp $	*/
d805 1
a805 1
	if ((dname = adjustname(dname, FALSE)) == NULL) {
@


1.75
log
@Fix where the cursor is positioned after expunging files. ok jasper@@
@
text
@d1 1
a1 1
/*	$OpenBSD: dired.c,v 1.74 2015/09/23 05:03:03 lum Exp $	*/
d135 1
a135 1
	d_backpage		/* v */	
d145 1
a145 1
	rescan,                 
d165 1
a165 1
			CCHR('['), CCHR('['), dirednull, (KEYMAP *) & 
d444 1
a444 1
	if (bufp == NULL) 
d768 1
a768 1
d_forwpage(int f, int n) 
d774 1
a774 1
static int 
@


1.74
log
@fix line number handling in dired delete functions.
@
text
@d1 1
a1 1
/*	$OpenBSD: dired.c,v 1.73 2015/09/21 06:59:54 lum Exp $	*/
d416 1
@


1.73
log
@If you open the same directory twice in dired mode, mg does not behave
correctly. In effect what should happen is the existing dired buffer
is brought to the fore, and if the directory contents has changed
inform the user.

ok sunil@@
@
text
@d1 1
a1 1
/*	$OpenBSD: dired.c,v 1.72 2015/09/14 16:37:19 lum Exp $	*/
d276 1
a276 1
		if (lforw(curwp->w_dotp) != curbp->b_headp)
d278 2
d294 1
a294 1
		if (lforw(curwp->w_dotp) != curbp->b_headp)
d296 2
d310 1
a310 1
		if (lback(curwp->w_dotp) != curbp->b_headp)
d312 2
d373 4
d379 1
d386 1
d393 1
d403 1
d410 2
d415 1
@


1.72
log
@Calculate the correct line number when opening in dired mode.
ok florian@@
@
text
@d1 1
a1 1
/*	$OpenBSD: dired.c,v 1.71 2015/03/19 21:48:05 bcallah Exp $	*/
d805 8
a812 4
	if ((bp = findbuffer(dname)) == NULL) {
		dobeep();
		ewprintf("Could not create buffer");
		return (NULL);
d814 1
a814 2
	if (bclear(bp) != TRUE)
		return (NULL);
d847 1
@


1.71
log
@More unifdef cleanup:
-UDIRED_XMAPS and -UFUND_XMAPS: you can't build mg the other way.
-DTIOCGWINSZ: you have this if you have term.h
Remove a #define TERMCAP which isn't being used.

Remove defines for NDIRED_XMAPS, NFUND_XMAPS, and IMAPEXT. They are all
defined to be 0 and are only ever used in addition. We don't need to add 0.
Simply lines that were using those defines.
ok florian@@
@
text
@d1 1
a1 1
/*	$OpenBSD: dired.c,v 1.70 2015/03/19 21:22:15 bcallah Exp $	*/
d819 1
d822 1
d830 1
a830 1
	if (++i < bp->b_lines - 2)
d832 2
@


1.70
log
@Clean up the includes in mg.
This does the following:
Moves all POSIX headers from sysdef.h into the individual .c files so that
each file now only includes what it needs. All headers are properly sorted.
Moves the remainder of sysdef.h to other files (mostly def.h) and deletes
sysdef.h now that it's no longer contains anything.
Tweak a comment that references sysdef.h so that it no longer does that.
ok florian@@
@
text
@d1 1
a1 1
/*	$OpenBSD: dired.c,v 1.69 2014/12/30 22:05:32 bcallah Exp $	*/
d142 2
a143 5
#ifndef	DIRED_XMAPS
#define	NDIRED_XMAPS	0	/* number of extra map sections */
#endif /* DIRED_XMAPS */

static struct KEYMAPE (1 + IMAPEXT) d_backpagemap = {
a144 1
	1 + IMAPEXT,
d153 3
a155 3
static struct KEYMAPE (7 + NDIRED_XMAPS + IMAPEXT) diredmap = {
	7 + NDIRED_XMAPS,
	7 + NDIRED_XMAPS + IMAPEXT,
a179 3
#ifdef	DIRED_XMAPS
		DIRED_XMAPS,	/* map sections for dired mode keys	 */
#endif /* DIRED_XMAPS */
@


1.69
log
@Remove some checks that will always evaluate to true. Noticed by a very
recent clang.
ok schwarze@@ lum@@
@
text
@d1 1
a1 1
/*	$OpenBSD: dired.c,v 1.68 2014/11/16 04:16:41 guenther Exp $	*/
d9 2
a10 5
#include "def.h"
#include "funmap.h"
#include "kbd.h"

#include <sys/types.h>
d13 1
a13 1
#include <sys/resource.h>
a14 1

a15 3
#include <limits.h>
#include <signal.h>
#include <fcntl.h>
d18 1
d20 2
d23 8
@


1.68
log
@Stop using <sys/param.h>; replace MAXPATHLEN with PATH_MAX, stop using MAX(),
and pull in <limits.h> for *_MAX constants.

inspired on a diff from Kamil Rytarowski (n54 (at) gmx.com)
ok bcallah@@
@
text
@d1 1
a1 1
/*	$OpenBSD: dired.c,v 1.67 2014/04/03 20:17:12 lum Exp $	*/
d216 1
a216 1
	if (curbp->b_fname && curbp->b_fname[0] != '\0') {
d246 1
a246 1
	if (curbp->b_fname && curbp->b_fname[0] != '\0') {
@


1.67
log
@When finding a file in a non-existant directory:

C-x C-f ~/no/dir/here/fn

offer to make the directory by pressing 'y', instead of suggesting the
make-directory command. ok jasper@@
@
text
@d1 1
a1 1
/*	$OpenBSD: dired.c,v 1.66 2014/03/20 07:47:29 lum Exp $	*/
d20 1
d500 1
a500 1
	char		 command[512], fname[MAXPATHLEN], *bufp;
@


1.66
log
@Add some missing dobeeps.
ok florian@@
@
text
@d1 1
a1 1
/*	$OpenBSD: dired.c,v 1.65 2013/12/20 15:49:00 lum Exp $	*/
d651 1
a651 1
	ret = do_makedir();
@


1.65
log
@Remove a spurious message that appears in dired mode if you press a
key without a function bound to it.
ok florian@@
@
text
@d1 1
a1 1
/*	$OpenBSD: dired.c,v 1.64 2013/12/19 19:04:56 lum Exp $	*/
d375 1
d381 1
d389 1
d415 1
d421 1
d454 1
d460 1
d509 1
d559 1
d575 1
d581 1
d592 1
d686 1
d790 1
d801 2
a802 1
		if (errno == EACCES)
d804 1
d808 1
d838 1
@


1.64
log
@Make dired-unmark-backward behave the same as emacs: move cursor up a
line then remove 'D' instead of remove 'D' then move up a line.
input/ok florian@@
@
text
@d1 1
a1 1
/*	$OpenBSD: dired.c,v 1.63 2013/06/03 05:10:59 lum Exp $	*/
d797 1
a797 1
	bp->b_flag |= BFREADONLY;
@


1.63
log
@Add the 'g' character and dired-revert to refresh the dired buffer.
ok jmc@@ for man page.
@
text
@d1 1
a1 1
/*	$OpenBSD: dired.c,v 1.62 2013/06/02 10:09:21 lum Exp $	*/
d308 2
a311 2
		if (lback(curwp->w_dotp) != curbp->b_headp)
			curwp->w_dotp = lback(curwp->w_dotp);
@


1.62
log
@Add the 'quit-window' dired command and receive a basic English lesson
from jmc@@ again.
@
text
@d1 1
a1 1
/*	$OpenBSD: dired.c,v 1.61 2013/06/02 09:57:23 lum Exp $	*/
d48 1
d107 2
a108 1
	d_findfile		/* f */
d171 1
a171 1
			'c', 'f', diredc, NULL
d654 11
@


1.61
log
@Fix return value in refreshbuffer.
@
text
@d1 1
a1 1
/*	$OpenBSD: dired.c,v 1.60 2013/06/02 09:53:42 lum Exp $	*/
d47 1
d113 1
a113 1
	rescan,			/* q */
d201 1
d645 7
@


1.60
log
@Rename the dired-* commands to be like the emacs equivalents.
@
text
@d1 1
a1 1
/*	$OpenBSD: dired.c,v 1.59 2013/05/30 17:43:43 lum Exp $	*/
d653 1
a653 1
		return (FALSE);
@


1.59
log
@Use adjustname() for the dired-copy-file and dired-rename-file
commands.
@
text
@d1 1
a1 1
/*	$OpenBSD: dired.c,v 1.58 2013/05/30 04:27:18 lum Exp $	*/
d186 1
a186 1
	funmap_add(d_undelbak, "dired-backup-unflag");
d188 2
a189 2
	funmap_add(d_copy, "dired-copy-file");
	funmap_add(d_expunge, "dired-do-deletions");
d192 1
a192 1
	funmap_add(d_del, "dired-flag-file-deleted");
d196 1
a196 1
	funmap_add(d_rename, "dired-rename-file");
d199 1
a199 1
	funmap_add(d_undel, "dired-unflag");
@


1.58
log
@Use adjustname() before trying to use the path to be dired.
ok jasper@@
@
text
@d1 1
a1 1
/*	$OpenBSD: dired.c,v 1.57 2013/05/30 04:17:25 lum Exp $	*/
d401 5
a405 4
	char	frname[NFILEN], toname[NFILEN], sname[NFILEN], *bufp;
	int	ret;
	size_t	off;
	struct buffer *bp;
d423 3
a425 1
	ret = (copy(frname, toname) >= 0) ? TRUE : FALSE;
d437 2
a438 1
	char		 frname[NFILEN], toname[NFILEN], *bufp;
d460 3
a462 1
	ret = (rename(frname, toname) >= 0) ? TRUE : FALSE;
@


1.57
log
@Reuse the makedir() function in dir.c for dired's
dired-create-directory command.
ok jasper@@
@
text
@d1 1
a1 1
/*	$OpenBSD: dired.c,v 1.56 2013/05/29 19:16:48 lum Exp $	*/
a747 5
	if ((access(dname, R_OK | X_OK)) == -1) {
		if (errno == EACCES)
			ewprintf("Permission denied");
		return (NULL);
	}
d757 5
@


1.56
log
@Make the mg dired commands:

dired-flag-file-deleted
dired-backup-unflag
dired-unflag

behave more like emacs when the cursor stays on the first character of
the file name.
@
text
@d1 1
a1 1
/*	$OpenBSD: dired.c,v 1.55 2013/05/29 05:28:48 lum Exp $	*/
d626 1
a626 2
	char	 tocreate[MAXPATHLEN], *bufp;
	size_t  off;
d629 4
a632 13
	off = strlcpy(tocreate, curbp->b_fname, sizeof(tocreate));
	if (off >= sizeof(tocreate) - 1)
		return (FALSE);
	if ((bufp = eread("Create directory: ", tocreate,
	    sizeof(tocreate), EFDEF | EFNEW | EFCR)) == NULL)
		return (ABORT);
	else if (bufp[0] == '\0')
		return (FALSE);
	if (mkdir(tocreate, 0755) == -1) {
		ewprintf("Creating directory: %s, %s", strerror(errno),
		    tocreate);
		return (FALSE);
	}
d635 1
@


1.55
log
@Use same method as elsewhere in mg to inidicate a failure of strdup.
@
text
@d1 1
a1 1
/*	$OpenBSD: dired.c,v 1.54 2013/05/28 18:35:10 lum Exp $	*/
d278 1
a278 2
	curwp->w_doto = 0;
	return (TRUE);
d294 1
a294 2
	curwp->w_doto = 0;
	return (TRUE);
a308 1
	curwp->w_doto = 0;
d310 1
a310 1
	return (TRUE);
@


1.54
log
@In dired mode the commands:

dired-copy-file
dired-rename-file
dired-create-directory

do not refresh the dired buffer. Now they do.
@
text
@d1 1
a1 1
/*	$OpenBSD: dired.c,v 1.53 2013/05/27 18:24:44 lum Exp $	*/
d657 4
a660 2
	if (tmp == NULL)
		err(1, NULL);
@


1.53
log
@Add dired-create-directory to function maps.
@
text
@d1 1
a1 1
/*	$OpenBSD: dired.c,v 1.52 2012/11/03 15:36:03 haesbaert Exp $	*/
d22 1
d48 1
d428 2
a429 1
	bp = dired_(curbp->b_fname);
d462 2
a463 1
	bp = dired_(curbp->b_fname);
d646 2
a647 1
	bp = dired_(curbp->b_fname);
d649 22
@


1.52
log
@Don't leak a file descriptor when testing for permissions, also make
sure directory is executable, otherwise we can't list it.

Found by and original diff from RustyBSD.

While here, strlen returns a size_t not an int.

ok florian.
@
text
@d1 1
a1 1
/*	$OpenBSD: dired.c,v 1.51 2012/03/14 13:56:35 lum Exp $	*/
d185 1
@


1.51
log
@Remove the NO_HELP conditional directives. If defined, mg will not compile and
has not done so for numerous years. Not hard to fix, but just remove anyway.
ok kjell@@ millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: dired.c,v 1.50 2011/08/31 03:40:53 lum Exp $	*/
d727 2
a728 1
	int		 len, i;
d730 1
a730 1
	if ((fopen(dname,"r")) == NULL) {
@


1.50
log
@Allow dired mode to open files regardless of characters in
filename, from Henri Kemppainen.

Tested, reviewed and a tweak each from Loganaden Velvindron
and myself.

ok jasper@@
@
text
@d1 1
a1 1
/*	$OpenBSD: dired.c,v 1.49 2011/08/29 11:02:06 lum Exp $	*/
a58 1
#ifndef NO_HELP
a59 1
#endif /* !NO_HELP */
a151 1
#ifndef NO_HELP
a154 5
#else /* !NO_HELP */
		{
			CCHR('@@'), CCHR('G'), dirednul, NULL
		},
#endif /* !NO_HELP */
@


1.49
log
@In dired mode, make point move up and down first character
of file name. Also add some missing keybindings.

Initial diff and numerous revisions from Loganaden Velvindron,
contributions from Henri Kemppainen and myself. Much testing
done by Nima Hoda.

ok jasper@@
@
text
@d1 1
a1 1
/*	$OpenBSD: dired.c,v 1.48 2011/01/23 00:45:03 kjell Exp $	*/
d24 1
d37 1
d488 1
a488 4
	char	 command[512], fname[MAXPATHLEN], buf[BUFSIZ], *bufp, *cp;
	int	 infd, fds[2];
	pid_t	 pid;
	struct	 sigaction olda, newa;
d491 1
a491 2
	FILE	*fin;
	char	 sname[NFILEN];
d507 55
a561 2
	infd = open(fname, O_RDONLY);
	if (infd == -1) {
d563 1
a563 1
		return (FALSE);
d565 1
d568 1
a568 2
		close(infd);
		return (FALSE);
d573 6
a578 5
	if (sigaction(SIGCHLD, &newa, &olda) == -1) {
		close(infd);
		close(fds[0]);
		close(fds[1]);
		return (ABORT);
d580 1
a580 1
	pid = fork();
d582 1
a582 4
	case -1:
		ewprintf("Can't fork");
		return (ABORT);
	case 0:
d587 2
a588 1
		execl("/bin/sh", "sh", "-c", bufp, (char *)NULL);
d591 1
a591 1
	default:
d594 3
a596 3
		fin = fdopen(fds[0], "r");
		if (fin == NULL)	/* "r" is surely a valid mode! */
			panic("can't happen");
d601 1
a601 1
				addlinef(bp, "%s...", buf);
d607 1
a607 1
			addline(bp, buf);
a609 1
		close(fds[0]);
d612 3
a614 5
	wp = popbuf(bp, WNONE);
	if (wp == NULL)
		return (ABORT);	/* XXX - free the buffer?? */
	curwp = wp;
	curbp = wp->w_bufp;
d617 9
a625 1
	return (TRUE);
a652 2
#define NAME_FIELD	8

d656 2
a657 2
	int	 i;
	char	*p, *ep;
d659 1
a659 3
	if (strlcpy(fn, curbp->b_fname, len) >= len)
		return (FALSE);
	if ((p = lp->l_text) == NULL)
d661 7
a667 14
	ep = lp->l_text + llength(lp);
	p++; /* skip action letter, if any */
	for (i = 0; i < NAME_FIELD; i++) {
		while (p < ep && isspace(*p))
			p++;
		while (p < ep && !isspace(*p))
			p++;
		while (p < ep && isspace(*p))
			p++;
		if (p == ep)
			return (ABORT);
	}
	if (strlcat(fn, p, len) >= len)
		return (FALSE);
d671 2
d686 4
a689 2
			if (++field == 9)
				break;
d695 3
a697 2
	*doto = off;
	return (TRUE);
d735 1
a735 3
	FILE	*dirpipe;
	char	 line[256];
	int	 len, ret, i;
d759 2
a760 17
	ret = snprintf(line, sizeof(line), "ls -al %s", dname);
	if (ret < 0 || ret  >= sizeof(line)) {
		ewprintf("Path too long");
		return (NULL);
	}
	if ((dirpipe = popen(line, "r")) == NULL) {
		ewprintf("Problem opening pipe to ls");
		return (NULL);
	}
	line[0] = line[1] = ' ';
	while (fgets(&line[2], sizeof(line) - 2, dirpipe) != NULL) {
		line[strcspn(line, "\n")] = '\0'; /* remove ^J	 */
		(void) addline(bp, line);
	}
	if (pclose(dirpipe) == -1) {
		ewprintf("Problem closing pipe to ls : %s",
		    strerror(errno));
a761 1
	}
d767 1
a767 2
		d_warpdot(bp->b_dotp, &bp->b_doto);
		if (bp->b_doto >= llength(bp->b_dotp))
@


1.48
log
@Wrap basename,dirname with xbasename, xdirname funtions,
which have fewer special cases, and use the strlcpy/strlcat
src/dst/buffer len semantic. More portable to boot.
Discussion and feedback from Henri Kemppainen
@
text
@d1 1
a1 1
/*	$OpenBSD: dired.c,v 1.47 2011/01/18 17:35:42 lum Exp $	*/
d39 5
d65 1
a65 1
	forwline,		/* ^N */
d67 1
a67 1
	backline,		/* ^P */
d73 1
a73 1
	forwpage,		/* ^V */
d85 1
a85 1
	forwline,		/* SP */
d107 1
a107 1
	forwline,		/* n */
d109 1
a109 1
	backline,		/* p */
d124 8
d136 14
a149 3
static struct KEYMAPE (6 + NDIRED_XMAPS + IMAPEXT) diredmap = {
	6 + NDIRED_XMAPS,
	6 + NDIRED_XMAPS + IMAPEXT,
d165 4
d196 1
d198 1
d200 2
d627 52
d688 1
a688 3
	int	 len, ret, counter, warp;
	counter = 0;
	warp = 0;
a724 5
		if ((strrchr(line,' ')) != NULL) {
			counter++;
			if ((strcmp((strrchr(line,' '))," ..")) == 0)  
				warp = counter;
		}
a725 6
	if ((strrchr(line,' ')) != NULL) {
		if (strcmp((strrchr(line,' '))," ..") == 0) 
			warp = counter - 1;
	}		
	if ((strrchr(line,' ')) != NULL)
		bp->b_doto = strrchr(line,' ') - line + 1;
d731 2
d734 14
a747 2
	while (warp--)
		bp->b_dotp  = lforw(bp->b_dotp);
@


1.47
log
@Add missing prototypes and move dired.c to "extensions" in Makefile.
ok kjell@@
@
text
@d1 1
a1 1
/*	$OpenBSD: dired.c,v 1.46 2010/06/26 16:18:43 kjell Exp $	*/
d338 1
a338 1
	char		 fname[NFILEN];
d349 2
a350 2
					ewprintf("Could not delete '%s'",
					    basename(fname));
d356 3
a358 2
					ewprintf("Could not delete directory '%s'",
					    basename(fname));
d375 1
a375 1
	char	frname[NFILEN], toname[NFILEN], *bufp;
d389 4
a392 2
	if ((bufp = eread("Copy %s to: ", toname, sizeof(toname),
	    EFDEF | EFNEW | EFCR, basename(frname))) == NULL)
d411 1
d422 4
a425 2
	if ((bufp = eread("Rename %s to: ", toname,
	    sizeof(toname), EFDEF | EFNEW | EFCR, basename(frname))) == NULL)
d461 1
d473 3
a475 2
	if ((bufp = eread("! on %s: ", command, sizeof(command), EFNEW,
	    basename(fname))) == NULL)
@


1.46
log
@From the Loganaden Velvindron:
 Make dired more sane (and emacslike):
 *  Position cursor at first filename after ..
 *  Don't reposition cursor on reopening
 *  Check for permission before attempting to open directory

I took forever to get this in. Thanks, Logan for being patient!
@
text
@d1 1
a1 1
/*	$OpenBSD: dired.c,v 1.45 2009/06/04 23:39:37 kjell Exp $	*/
d39 1
@


1.45
log
@Add the notion of an "ephemeral" popup, so we can flag a window
for destruction at a later date. (in the process, add a window flag field)

This fixes an issue noted by maja: namely, the *completion*
window that pops up when you try to complete a filename on
buffer load would destroy any second window that you happened
to have open.

ok maja@@
@
text
@d1 1
a1 1
/*	$OpenBSD: dired.c,v 1.44 2009/06/04 02:23:37 kjell Exp $	*/
d595 9
a603 2
	int	 len, ret;

d634 5
d640 6
d652 2
@


1.44
log
@Rename w_flag to w_rflag. This is not a general purpose
flag: it is for redisplay options only. I need an additional all-purpose
flag, so renaming removes the desire to wrongly overload the existing one.

Turdshine. No functional chage.
@
text
@d1 1
a1 1
/*	$OpenBSD: dired.c,v 1.43 2007/09/11 15:47:17 gilles Exp $	*/
d228 1
a228 1
	if ((wp = popbuf(bp)) == NULL)
d323 1
a323 1
	if ((wp = popbuf(bp)) == NULL)
d522 1
a522 1
	wp = popbuf(bp);
@


1.43
log
@use strcspn to properly overwrite '\n' in fgets returned buffer

ok pyr@@, ray@@, millert@@, moritz@@, chl@@
@
text
@d1 1
a1 1
/*	$OpenBSD: dired.c,v 1.42 2006/11/01 06:02:29 ray Exp $	*/
d247 1
a247 1
	curwp->w_flag |= WFEDIT | WFMOVE;
d264 1
a264 1
	curwp->w_flag |= WFEDIT | WFMOVE;
d282 1
a282 1
	curwp->w_flag |= WFEDIT | WFMOVE;
d363 1
a363 1
			curwp->w_flag |= WFFULL;
@


1.42
log
@Don't overwrite line[strlen(line) - 1] when line is zero-length.

Initial patch by Charles Longeau <chl at tuxfamily dot org>.

OK kjell@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: dired.c,v 1.41 2006/07/25 08:27:09 kjell Exp $	*/
d625 1
a625 4
		char *p;

		if ((p = strchr(line, '\n')) != NULL)
			*p = '\0';	/* remove ^J	 */
@


1.41
log
@Add bfirstlp(), blastlp() macros, returning the first and last lines
of a buffer respectively. Removes an ugly construction than necessitated
"go to first line"-type comments throughout the code.
No binary change
@
text
@d1 1
a1 1
/*	$OpenBSD: dired.c,v 1.40 2006/07/25 08:22:32 kjell Exp $	*/
d625 4
a628 1
		line[strlen(line) - 1] = '\0';	/* remove ^J	 */
@


1.40
log
@Rename the header line of a buffer to b_headp, from the remarkably
unintuitive b_linep. No binary change.
@
text
@d1 1
a1 1
/*	$OpenBSD: dired.c,v 1.39 2006/06/01 09:00:50 kjell Exp $	*/
d339 1
a339 1
	for (lp = lforw(curbp->b_headp); lp != curbp->b_headp; lp = nlp) {
d633 1
a633 1
	bp->b_dotp = lforw(bp->b_headp);	/* go to first line */
@


1.39
log
@Display line number in the mg statusbar.  Yes, it seems like a fugly
way to do it, but all the clever and pretty ways utterly failed.
Basic use seems fine. We'll turdshine the special cases later.

If it bothers you, use M-x line-number-mode, or put same in your ~/.mg
file to disable.

ok cloder, jason
@
text
@d1 1
a1 1
/*	$OpenBSD: dired.c,v 1.38 2006/06/01 05:34:52 jason Exp $	*/
d244 1
a244 1
		if (lforw(curwp->w_dotp) != curbp->b_linep)
d261 1
a261 1
		if (lforw(curwp->w_dotp) != curbp->b_linep)
d278 1
a278 1
		if (lback(curwp->w_dotp) != curbp->b_linep)
d339 1
a339 1
	for (lp = lforw(curbp->b_linep); lp != curbp->b_linep; lp = nlp) {
d633 1
a633 1
	bp->b_dotp = lforw(bp->b_linep);	/* go to first line */
@


1.38
log
@make // /~ path rewriting optional in adjustname() and use it everywhere
except for the command line specified files.  ok kjell,cloder
@
text
@d1 1
a1 1
/*	$OpenBSD: dired.c,v 1.37 2006/05/28 23:30:16 kjell Exp $	*/
d362 1
@


1.37
log
@Make Window Flags more mnemonic (and less dumb); i.e.
WFHARD -> WFFULL (Redraw full window)
WFFORCE -> WFFRAME (Reframe window).
No binary change
@
text
@d1 1
a1 1
/*	$OpenBSD: dired.c,v 1.36 2006/05/02 17:10:25 kjell Exp $	*/
d596 1
a596 1
	if ((dname = adjustname(dname)) == NULL) {
@


1.36
log
@Make buffers store their own working directory. This makes things like
grep, compile, lint work as expected (act on current buffer's cwd).
Display this path when opening or replacing a file, rather than
relying on the user to guess, or remember.
@
text
@d1 1
a1 1
/*	$OpenBSD: dired.c,v 1.35 2005/12/20 05:04:28 kjell Exp $	*/
d200 1
a200 1
	return (showbuffer(bp, curwp, WFHARD | WFMODE));
d303 1
a303 1
	if (showbuffer(bp, curwp, WFHARD) != TRUE)
d362 1
a362 1
			curwp->w_flag |= WFHARD;
d395 1
a395 1
	return (showbuffer(bp, curwp, WFHARD | WFMODE));
d425 1
a425 1
	return (showbuffer(bp, curwp, WFHARD | WFMODE));
d553 1
a553 1
	return (showbuffer(bp, curwp, WFHARD | WFMODE));
@


1.35
log
@Do some delinting of strl-type functions. Also, remove a superfluous
word in the undo-list.
@
text
@d1 1
a1 1
/*	$OpenBSD: dired.c,v 1.34 2005/12/13 07:20:13 kjell Exp $	*/
d633 2
a634 1
	(void) strlcpy(bp->b_fname, dname, sizeof(bp->b_fname));
@


1.34
log
@Last round of easy delinting.
@
text
@d1 1
a1 1
/*	$OpenBSD: dired.c,v 1.33 2005/12/13 06:01:27 kjell Exp $	*/
d564 2
a565 1
	strlcpy(fn, curbp->b_fname, len);
d580 2
a581 1
	strlcat(fn, p, len);
@


1.33
log
@More name-clash delinting
@
text
@d1 1
a1 1
/*	$OpenBSD: dired.c,v 1.32 2005/11/20 03:24:17 deraadt Exp $	*/
d38 1
a38 1
static int	 d_makename(struct line *, char *, int);
d559 1
a559 1
d_makename(struct line *lp, char *fn, int len)
@


1.32
log
@toast NO_DIRED #ifdef; ok kjell
@
text
@d1 1
a1 1
/*	$OpenBSD: dired.c,v 1.31 2005/11/18 20:56:52 deraadt Exp $	*/
d178 1
a178 1
	char		 dirname[NFILEN], *bufp, *slash;
d182 2
a183 2
		(void)strlcpy(dirname, curbp->b_fname, sizeof(dirname));
		if ((slash = strrchr(dirname, '/')) != NULL) {
d187 2
a188 2
		if (getcwd(dirname, sizeof(dirname)) == NULL)
			dirname[0] = '\0';
d191 1
a191 1
	if ((bufp = eread("Dired: ", dirname, NFILEN,
d207 1
a207 1
	char		 dirname[NFILEN], *bufp, *slash;
d212 2
a213 2
		(void)strlcpy(dirname, curbp->b_fname, sizeof(dirname));
		if ((slash = strrchr(dirname, '/')) != NULL) {
d217 2
a218 2
		if (getcwd(dirname, sizeof(dirname)) == NULL)
			dirname[0] = '\0';
d221 1
a221 1
	if ((bufp = eread("Dired other window: ", dirname, NFILEN,
d373 1
a373 1
	int	stat;
d391 3
a393 3
	stat = (copy(frname, toname) >= 0) ? TRUE : FALSE;
	if (stat != TRUE)
		return (stat);
d403 1
a403 1
	int		 stat;
d421 3
a423 3
	stat = (rename(frname, toname) >= 0) ? TRUE : FALSE;
	if (stat != TRUE)
		return (stat);
d584 1
a584 1
 * XXX dirname needs to have enough place to store an additional '/'.
d587 1
a587 1
dired_(char *dirname)
d594 1
a594 1
	if ((dirname = adjustname(dirname)) == NULL) {
d599 4
a602 4
	len = strlen(dirname);
	if (dirname[len - 1] != '/') {
		dirname[len++] = '/';
		dirname[len] = '\0';
d604 1
a604 1
	if ((bp = findbuffer(dirname)) == NULL) {
d611 1
a611 1
	ret = snprintf(line, sizeof(line), "ls -al %s", dirname);
d631 1
a631 1
	(void) strlcpy(bp->b_fname, dirname, sizeof(bp->b_fname));
@


1.31
log
@greedy use of typedef struct was making code harder to read; ok kjell cloder
@
text
@d1 1
a1 1
/*	$OpenBSD: dired.c,v 1.30 2005/11/13 07:49:02 kjell Exp $	*/
a24 2
#ifndef NO_DIRED

a639 2

#endif /* !NO_DIRED */
@


1.30
log
@Better error checking of snprintfs. From Han Boetes.
@
text
@d1 1
a1 1
/*	$OpenBSD: dired.c,v 1.29 2005/11/12 20:13:47 deraadt Exp $	*/
d40 1
a40 1
static int	 d_makename(LINE  *, char *, int);
d180 2
a181 2
	char	     dirname[NFILEN], *bufp, *slash;
	BUFFER	    *bp;
d209 3
a211 3
	char	 dirname[NFILEN], *bufp, *slash;
	BUFFER	*bp;
	MGWIN	*wp;
d292 3
a294 3
	BUFFER	*bp;
	int	 s;
	char	 fname[NFILEN];
d316 4
a319 4
	char	fname[NFILEN];
	int	s;
	BUFFER *bp;
	MGWIN  *wp;
d338 2
a339 2
	LINE	*lp, *nlp;
	char	 fname[NFILEN];
d377 1
a377 1
	BUFFER *bp;
d404 4
a407 4
	char	frname[NFILEN], toname[NFILEN], *bufp;
	int	stat;
	size_t	off;
	BUFFER *bp;
d430 1
d452 2
a453 2
	BUFFER	*bp;
	MGWIN	*wp;
d539 1
a539 1
	BUFFER	*bp;
d561 1
a561 1
d_makename(LINE *lp, char *fn, int len)
d588 1
a588 1
BUFFER *
d591 1
a591 1
	BUFFER	*bp;
@


1.29
log
@break in case
@
text
@d1 1
a1 1
/*	$OpenBSD: dired.c,v 1.28 2005/11/07 23:46:18 kjell Exp $	*/
d593 1
a593 1
	int	 len;
d612 2
a613 2
	if (snprintf(line, sizeof(line), "ls -al %s", dirname)
	    >= sizeof(line)) {
@


1.28
log
@KNF
@
text
@d1 1
a1 1
/*	$OpenBSD: dired.c,v 1.27 2005/11/07 23:32:20 kjell Exp $	*/
d499 1
@


1.27
log
@Move most of the dired hooks into dired.c.  While here, enable some
dired functions that were written, but not bound to keys. No other
functional change.

Tested by Han Boetes.
@
text
@d1 1
a1 1
/*	$OpenBSD: dired.c,v 1.26 2005/10/14 19:46:46 kjell Exp $	*/
d10 1
a11 1
#include "funmap.h"
@


1.26
log
@add missing /* ARGSUSED */ to quiet lint.
@
text
@d1 1
a1 1
/*	$OpenBSD: dired.c,v 1.25 2005/10/14 15:41:33 deraadt Exp $	*/
d11 2
d28 12
d81 12
a92 1
	forwline		/* SP */
d142 1
a142 1
			CCHR('Z'), ' ', diredcz, (KEYMAP *) & metamap
d162 10
d173 1
@


1.25
log
@unused variables
@
text
@d1 1
a1 1
/*	$OpenBSD: dired.c,v 1.24 2005/10/14 06:41:47 kjell Exp $	*/
d407 1
d495 1
@


1.24
log
@move the dired routines into dired.c where they belong.
ok cloder@@
@
text
@d1 1
a1 1
/*	$OpenBSD: dired.c,v 1.23 2005/10/13 05:47:44 kjell Exp $	*/
d13 2
a397 1
	pid_t	ret;
d399 1
a399 1
	while ((ret = waitpid(-1, &status, WNOHANG)) >= 0)
@


1.23
log
@Fix dired mode. Make deletions work, and keystrokes match emacs.
* dired-other-window should default to current buffer's path.
* Remove redundant code (from Han Boetes)
* Move initialization (and since we're here, fix mail-mode initialization
  too)
* Remove redundant keymap in dired.c, and replace it with
  the better one that was being ignored in keymap.c.
@
text
@d1 1
a1 1
/*	$OpenBSD: dired.c,v 1.22 2005/10/11 01:28:29 deraadt Exp $	*/
d15 1
d23 2
a24 1
void dired_init(void);
a390 1
#endif
d516 87
@


1.22
log
@prevent trashing of errno in signal handler
@
text
@d1 1
a1 1
/*	$OpenBSD: dired.c,v 1.21 2005/08/09 00:53:48 kjell Exp $	*/
d22 1
a22 1
int d_findfile(int, int);
d24 14
a37 71
static PF dired_cmds_1[] = {
	forwline,		/* space */
	d_shell_command,	/* ! */
	rescan,			/* " */
	rescan,			/* # */
	rescan,			/* $ */
	rescan,			/* % */
	rescan,			/* & */
	rescan,			/* ' */
	rescan,			/* ( */
	rescan,			/* ) */
	rescan,			/* * */
	d_create_directory	/* + */
};

static PF dired_cmds_2[] = {
	rescan,			/* a */
	rescan,			/* b */
	rescan,			/* c */
	rescan, 		/* d */
	d_findfile, 		/* e */
	d_findfile, 		/* f */
	rescan, 		/* g */
	rescan, 		/* h */
	rescan, 		/* i */
	rescan, 		/* j */
	rescan, 		/* k */
	rescan, 		/* l */
	rescan, 		/* m */
	forwline, 		/* n */
	d_ffotherwindow, 	/* o */
	rescan, 		/* p */
	rescan, 		/* q */
	rescan, 		/* r */
	rescan, 		/* s */
	rescan, 		/* t */
	rescan, 		/* u */
	d_findfile, 		/* v */
	rescan, 		/* w */
	d_expunge, 		/* x */
	rescan, 		/* y */
	rescan			/* z */
};

static PF dired_cmds_3[] = {
	rescan,			/* A */
	rescan,			/* B */
	d_copy,			/* C */
	d_del,			/* D */
	rescan,			/* E */
	rescan, 		/* F */
	rescan, 		/* G */
	rescan, 		/* H */
	rescan, 		/* I */
	rescan, 		/* J */
	rescan, 		/* K */
	rescan, 		/* L */
	rescan, 		/* M */
	rescan, 		/* N */
	rescan, 		/* O */
	rescan, 		/* P */
	rescan, 		/* Q */
	d_rename, 		/* R */
	rescan, 		/* S */
	rescan, 		/* T */
	rescan, 		/* U */
	d_findfile, 		/* V */
	rescan, 		/* W */
	d_expunge, 		/* X */
	rescan, 		/* Y */
	rescan			/* Z */
d40 2
a41 1
static PF dired_pf[] = {
d43 46
a88 2
	rescan,			/* ^N */
	d_findfile		/* ^O */
d91 7
a97 3
static struct KEYMAPE (4 + IMAPEXT) diredmap = {
	4,
	4 + IMAPEXT,
d100 27
a126 4
		{ CCHR('M'), CCHR('O'), dired_pf, NULL },
		{ ' ', '+', dired_cmds_1, NULL },
		{ 'A', 'Z', dired_cmds_3, NULL },
		{ 'a', 'z', dired_cmds_2, NULL }
d130 5
a139 1
	static int   inited = 0;
a142 5
	if (inited == 0) {
		maps_add((KEYMAP *)&diredmap, "dired");
		inited = 1;
	}

d160 1
a160 3
	bp->b_modes[0] = name_mode("fundamental");
	bp->b_modes[1] = name_mode("dired");
	bp->b_nmodes = 1;
d169 1
a169 1
	char	 dirname[NFILEN], *bufp;
d173 10
a182 1
	dirname[0] = '\0';
@


1.21
log
@Clean up eread handling in mg. (basically, fallout from the 'enter often
means abort' behaviour added during the hackathon). Eliminates
redundant ereply function, fixes miscellaneous cores when aborting,
and move a number of assumed pathnames into the prompt text, since
they are used there anyway. All changes consistent with emacs behavior

ok beck@@ many, many moons ago.
@
text
@d1 1
a1 1
/*	$OpenBSD: dired.c,v 1.20 2005/06/14 18:14:40 kjell Exp $	*/
d373 1
a374 1
	int	status;
d378 1
@


1.20
log
@Add explicit public domain notices to all public domain files.
ok millert@@, deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: dired.c,v 1.19 2005/05/28 01:53:37 cloder Exp $	*/
d130 1
a130 1
		strlcpy(dirname, curbp->b_fname, sizeof(dirname));
d139 2
a140 1
	if ((bufp = eread("Dired: ", dirname, NFILEN, EFDEF | EFNEW | EFCR)) == NULL)
d142 2
d163 1
a163 1
	    EFNEW | EFCR)) == NULL)
d165 2
d327 2
a328 2
	if ((bufp = eread("Copy %s to: ", toname + off, sizeof(toname) - off,
	    EFNEW | EFCR, basename(frname))) == NULL)
d357 2
a358 2
	if ((bufp = eread("Rename %s to: ", toname + off,
	    sizeof(toname) - off, EFNEW | EFCR, basename(frname))) == NULL)
d404 1
a404 1
	if ((bufp = eread("! on %s: ", command, sizeof(command), 0,
d410 1
a410 1
		return (ABORT);
d415 1
a415 1
		return (ABORT);
d480 2
a481 2
	if ((bufp = ereply("Create directory: ", tocreate + off,
	    sizeof(tocreate) - off)) == NULL)
d488 1
a488 1
		return (ABORT);
@


1.19
log
@Dired now prompts in the minibuffer using the current directory name
or the name of the directory of the current buffer's file.
OK kjell, jason
@
text
@d1 1
a1 1
/*	$OpenBSD: dired.c,v 1.18 2005/05/15 21:19:08 cloder Exp $	*/
d3 5
a7 2
/* dired module for mg 2a	 */
/* by Robert A. Larson		 */
@


1.18
log
@Fix insert-buffer prompt format string. strlcpy returns size_t, not int
(from Han Boetes). Improve error messages (from Han Boetes).
OK otto, jaredy, beck
@
text
@d1 1
a1 1
/*	$OpenBSD: dired.c,v 1.17 2005/04/28 07:14:09 otto Exp $	*/
d118 1
a118 1
	char	     dirname[NFILEN], *bufp;
d126 11
a136 2
	dirname[0] = '\0';
	if ((bufp = eread("Dired: ", dirname, NFILEN, EFNEW | EFCR)) == NULL)
@


1.17
log
@That should be FALSE in previous commit.
@
text
@d1 1
a1 1
/*	$OpenBSD: dired.c,v 1.16 2005/04/28 07:13:01 otto Exp $	*/
d298 1
a298 1
	int	off;
d307 1
a307 1
		ewprintf("too long directory name");
d327 2
a328 1
	int	stat, off;
d337 1
a337 1
		ewprintf("too long directory name");
d457 1
a457 1
	ssize_t  off;
@


1.16
log
@NULL is not an int. Han Boetes.
@
text
@d1 1
a1 1
/*	$OpenBSD: dired.c,v 1.15 2005/04/03 02:09:28 db Exp $	*/
d314 1
a314 1
		return (0);
@


1.15
log
@This is a no binary change which does:

- spelling, punctuation fixes
- variable declaration lineup
- use parentheses for return and sizeof
- K&R function declarations -> ANSI
- other minor code beautification

ok henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: dired.c,v 1.14 2004/07/22 01:25:24 vincent Exp $	*/
d314 1
a314 1
		return (NULL);
@


1.14
log
@stage 1 of the infinite minibuffer work - add support for on the fly
buffer reallocation in veread().  This commit only changes the API.
All the buffers have exactly the same bounds as before for now.

tested by a couple of my very helpful testers!
@
text
@d1 1
a1 1
/*	$OpenBSD: dired.c,v 1.13 2003/08/16 00:24:51 deraadt Exp $	*/
d33 1
a33 1
	d_create_directory,	/* + */
d37 26
a62 26
	rescan,	/* a */
	rescan,	/* b */
	rescan,	/* c */
	rescan, /* d */
	d_findfile, /* e */
	d_findfile, /* f */
	rescan, /* g */
	rescan, /* h */
	rescan, /* i */
	rescan, /* j */
	rescan, /* k */
	rescan, /* l */
	rescan, /* m */
	forwline, /* n */
	d_ffotherwindow, /* o */
	rescan, /* p */
	rescan, /* q */
	rescan, /* r */
	rescan, /* s */
	rescan, /* t */
	rescan, /* u */
	d_findfile, /* v */
	rescan, /* w */
	d_expunge, /* x */
	rescan, /* y */
	rescan, /* z */
d66 26
a91 26
	rescan,	/* A */
	rescan,	/* B */
	d_copy,	/* C */
	d_del,	/* D */
	rescan,	/* E */
	rescan, /* F */
	rescan, /* G */
	rescan, /* H */
	rescan, /* I */
	rescan, /* J */
	rescan, /* K */
	rescan, /* L */
	rescan, /* M */
	rescan, /* N */
	rescan, /* O */
	rescan, /* P */
	rescan, /* Q */
	d_rename, /* R */
	rescan, /* S */
	rescan, /* T */
	rescan, /* U */
	d_findfile, /* V */
	rescan, /* W */
	d_expunge, /* X */
	rescan, /* Y */
	rescan, /* Z */
d95 3
a97 3
	d_findfile,	/* ^M */
	rescan,		/* ^N */
	d_findfile,	/* ^O */
d117 3
a119 3
	static int inited = 0;
	char	dirname[NFILEN], *bufp;
	BUFFER *bp;
d128 1
a128 1
		return ABORT;
d130 1
a130 1
		return FALSE;
d135 1
a135 1
	return showbuffer(bp, curwp, WFHARD | WFMODE);
d142 1
a142 1
	char	dirname[NFILEN], *bufp;
d149 1
a149 1
		return ABORT;
d151 1
a151 1
		return FALSE;
d153 1
a153 1
		return FALSE;
d156 1
a156 1
	return TRUE;
d164 1
a164 1
		return FALSE;
d173 1
a173 1
	return TRUE;
d181 1
a181 1
		return d_undelbak(f, -n);
d190 1
a190 1
	return TRUE;
d198 1
a198 1
		return d_undel(f, -n);
d207 1
a207 1
	return TRUE;
d214 3
a216 3
	BUFFER *bp;
	int	s;
	char	fname[NFILEN];
d218 2
a219 2
	if ((s = d_makename(curwp->w_dotp, fname, sizeof fname)) == ABORT)
		return FALSE;
d225 1
a225 1
		return FALSE;
d228 1
a228 1
		return FALSE;
d230 2
a231 2
		return TRUE;
	return readin(fname);
d243 2
a244 2
	if ((s = d_makename(curwp->w_dotp, fname, sizeof fname)) == ABORT)
		return FALSE;
d246 1
a246 1
		return FALSE;
d248 1
a248 1
		return FALSE;
d252 2
a253 2
		return TRUE;	/* never true for dired buffers */
	return readin(fname);
d261 1
a261 1
	char	fname[NFILEN];
d266 1
a266 1
			switch (d_makename(lp, fname, sizeof fname)) {
d269 1
a269 1
				return FALSE;
d274 1
a274 1
					return FALSE;
d281 1
a281 1
					return FALSE;
d289 1
a289 1
	return TRUE;
a291 1

d301 1
a301 1
	if (d_makename(curwp->w_dotp, frname, sizeof frname) != FALSE) {
d303 1
a303 1
		return FALSE;
d305 2
a306 2
	off = strlcpy(toname, curbp->b_fname, sizeof toname);
	if (off >= sizeof toname - 1) {	/* can't happen, really */
d310 1
a310 1
	if ((bufp = eread("Copy %s to: ", toname + off, sizeof toname - off,
d312 1
a312 1
		return ABORT;
d314 1
a314 1
		return NULL;
d330 1
a330 1
	if (d_makename(curwp->w_dotp, frname, sizeof frname) != FALSE) {
d332 1
a332 1
		return FALSE;
d334 2
a335 2
	off = strlcpy(toname, curbp->b_fname, sizeof toname);
	if (off >= sizeof toname - 1) {	/* can't happen, really */
d340 2
a341 2
	    sizeof toname - off, EFNEW | EFCR, basename(frname))) == NULL)
		return ABORT;
d343 1
a343 1
		return FALSE;
d355 2
a356 2
	pid_t ret;
	int status;
d368 7
a374 7
	char command[512], fname[MAXPATHLEN], buf[BUFSIZ], *bufp, *cp;
	int infd, fds[2];
	pid_t pid;
	struct sigaction olda, newa;
	BUFFER *bp;
	MGWIN *wp;
	FILE *fin;
d380 1
a380 1
	if (d_makename(curwp->w_dotp, fname, sizeof fname) != FALSE) {
d386 1
a386 1
	if ((bufp = eread("! on %s: ", command, sizeof command, 0,
d426 1
a426 1
		while (fgets(buf, sizeof buf, fin) != NULL) {
d455 3
a457 3
	char tocreate[MAXPATHLEN], *bufp;
	ssize_t off;
	BUFFER *bp;
d459 2
a460 2
	off = strlcpy(tocreate, curbp->b_fname, sizeof tocreate);
	if (off >= sizeof tocreate - 1)
d463 1
a463 1
	    sizeof tocreate - off)) == NULL)
d466 1
a466 1
		return FALSE;
@


1.13
log
@spacing
@
text
@d1 1
a1 1
/*	$OpenBSD: dired.c,v 1.12 2003/08/15 23:23:18 vincent Exp $	*/
d118 1
a118 1
	char	dirname[NFILEN];
d127 1
a127 1
	if (eread("Dired: ", dirname, NFILEN, EFNEW | EFCR) == ABORT)
d129 1
a129 1
	if ((bp = dired_(dirname)) == NULL)
d142 1
a142 1
	char	dirname[NFILEN];
d147 2
a148 2
	if (eread("Dired other window: ", dirname, NFILEN, EFNEW | EFCR)
	    == ABORT)
d150 1
a150 1
	if ((bp = dired_(dirname)) == NULL)
d297 3
a299 2
	char	frname[NFILEN], toname[NFILEN];
	int	stat, off;
d311 5
a315 3
	if ((stat = eread("Copy %s to: ", toname + off, sizeof toname - off,
	    EFNEW | EFCR, basename(frname))) != TRUE)
		return (stat);
d327 1
a327 1
	char	frname[NFILEN], toname[NFILEN];
d340 5
a344 3
	if ((stat = eread("Rename %s to: ", toname + off,
	    sizeof toname - off, EFNEW | EFCR, basename(frname))) != TRUE)
		return stat;
d369 1
a369 1
	char command[512], fname[MAXPATHLEN], buf[BUFSIZ], *cp;
d387 2
a388 2
	if (eread("! on %s: ", command, sizeof command, 0,
	    basename(fname)) == ABORT)
d419 1
a419 1
		execl("/bin/sh", "sh", "-c", command, (char *)NULL);
d456 2
a457 2
	char tocreate[MAXPATHLEN], off;
	int stat;
d463 5
a467 4
	if ((stat = ereply("Create directory: ", tocreate + off,
	    sizeof tocreate - off))
	    != TRUE)
		return (stat);
@


1.12
log
@make dired work more like emacs. (well, make it _work_, and then add a
bunch of missing commands)
@
text
@d1 1
a1 1
/*	$OpenBSD: dired.c,v 1.11 2003/06/26 23:04:10 vincent Exp $	*/
d99 1
a99 1
  
@


1.11
log
@protos

ok deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: dired.c,v 1.10 2002/03/11 13:02:56 vincent Exp $	*/
d8 8
d21 73
d95 3
a97 1
	d_findfile,
d99 4
a102 4

static struct KEYMAPE (1 + IMAPEXT) diredmap = {
	1,
	1 + IMAPEXT,
d105 4
a108 1
		{ CCHR('M'), CCHR('M'), dired_pf, NULL },
d112 1
d147 2
a148 1
	if (eread("Dired other window: ", dirname, NFILEN, EFNEW | EFCR) == ABORT)
d220 5
a224 1
	if ((bp = (s ? dired_(fname) : findbuffer(fname))) == NULL)
d272 2
a273 1
					ewprintf("Could not delete '%s'", fname);
d280 1
a280 1
					    fname);
d292 1
d298 2
a299 1
	int	stat;
d305 13
a317 4
	if ((stat = eread("Copy %s to: ", toname, NFILEN, EFNEW | EFCR, frname))
	    != TRUE)
		return stat;
	return copy(frname, toname) >= 0;
d325 2
a326 1
	int	stat;
d332 7
a338 2
	if ((stat = eread("Rename %s to: ", toname, NFILEN, EFNEW | EFCR,
	    frname)) != TRUE)
d340 5
a344 1
	return rename(frname, toname) >= 0;
d347 123
@


1.10
log
@  * Move to ANSI function definitions.
  * Add a whole lot of consts where I thought it made sense

   no ok, but no objections either...
@
text
@d1 1
a1 1
/*	$OpenBSD: dired.c,v 1.9 2002/02/15 01:04:59 vincent Exp $	*/
d10 2
@


1.9
log
@ make pressing return in dired mode open the file we're currently at.

 ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: dired.c,v 1.8 2002/02/14 22:58:20 vincent Exp $	*/
d26 1
a26 2
dired(f, n)
	int	f, n;
d51 1
a51 2
d_otherwindow(f, n)
	int	f, n;
d71 1
a71 2
d_del(f, n)
	int f, n;
a72 1

d88 1
a88 2
d_undel(f, n)
	int f, n;
d105 1
a105 2
d_undelbak(f, n)
	int f, n;
a106 1

d122 1
a122 2
d_findfile(f, n)
	int f, n;
d142 1
a142 2
d_ffotherwindow(f, n)
	int	f, n;
d164 1
a164 2
d_expunge(f, n)
	int	f, n;
d199 1
a199 2
d_copy(f, n)
	int	f, n;
d216 1
a216 2
d_rename(f, n)
	int	f, n;
@


1.8
log
@d_makename now takes a length parameter so we can remove the
strcpy call.
@
text
@d1 1
a1 1
/*	$OpenBSD: dired.c,v 1.7 2001/05/24 03:05:21 mickey Exp $	*/
d7 1
d11 13
d29 1
d33 5
d43 3
@


1.7
log
@spaces
@
text
@d1 1
a1 1
/*	$OpenBSD: dired.c,v 1.6 2001/01/29 01:58:06 niklas Exp $	*/
d113 1
a113 1
	if ((s = d_makename(curwp->w_dotp, fname)) == ABORT)
d135 1
a135 1
	if ((s = d_makename(curwp->w_dotp, fname)) == ABORT)
d159 1
a159 1
			switch (d_makename(lp, fname)) {
d192 1
a192 1
	if (d_makename(curwp->w_dotp, frname) != FALSE) {
d210 1
a210 1
	if (d_makename(curwp->w_dotp, frname) != FALSE) {
@


1.6
log
@$OpenBSD$
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d13 1
a13 1
	int     f, n;
d15 1
a15 1
	char    dirname[NFILEN];
d30 1
a30 1
	int     f, n;
d32 3
a34 3
	char    dirname[NFILEN];
	BUFFER *bp;
	MGWIN  *wp;
d110 2
a111 2
	int     s;
	char    fname[NFILEN];
d128 1
a128 1
	int     f, n;
d130 2
a131 2
	char    fname[NFILEN];
	int     s;
d151 1
a151 1
	int    f, n;
d153 2
a154 2
	LINE  *lp, *nlp;
	char   fname[NFILEN];
d187 1
a187 1
	int     f, n;
d189 2
a190 2
	char    frname[NFILEN], toname[NFILEN];
	int     stat;
@


1.5
log
@The start of KNF + -Wall.  The code has been run through indent but
needs hand fixup.  I stopped at keymap.c...
@
text
@d1 2
@


1.4
log
@use rmdir, not unlinkdir hack
@
text
@d1 2
a2 2
/* dired module for mg 2a	*/
/* by Robert A. Larson		*/
d8 2
a9 3
BUFFER *dired_();

/*ARGSUSED*/
d11 1
a11 1
int f, n;
d13 2
a14 2
    char dirname[NFILEN];
    BUFFER *bp;
d16 7
a22 6
    dirname[0] = '\0';
    if(eread("Dired: ", dirname, NFILEN, EFNEW | EFCR) == ABORT)
	return ABORT;
    if((bp = dired_(dirname)) == NULL) return FALSE;
    curbp = bp;
    return showbuffer(bp, curwp, WFHARD | WFMODE);
d25 2
a26 1
/*ARGSUSED*/
d28 1
a28 1
int f, n;
d30 14
a43 12
    char dirname[NFILEN];
    BUFFER *bp;
    MGWIN *wp;

    dirname[0] = '\0';
    if(eread("Dired other window: ", dirname, NFILEN, EFNEW | EFCR) == ABORT)
	return ABORT;
    if((bp = dired_(dirname)) == NULL) return FALSE;
    if((wp = popbuf(bp)) == NULL) return FALSE;
    curbp = bp;
    curwp = wp;
    return TRUE;
d46 2
a47 1
/*ARGSUSED*/
d49 1
a49 1
int f, n;
d51 12
a62 10
    if(n < 0) return FALSE;
    while(n--) {
	if(llength(curwp->w_dotp) > 0)
	    lputc(curwp->w_dotp, 0, 'D');
	if(lforw(curwp->w_dotp) != curbp->b_linep)
	    curwp->w_dotp = lforw(curwp->w_dotp);
    }
    curwp->w_flag |= WFEDIT | WFMOVE;
    curwp->w_doto = 0;
    return TRUE;
d65 2
a66 1
/*ARGSUSED*/
d68 1
a68 1
int f, n;
d70 11
a80 10
    if(n < 0) return d_undelbak(f, -n);
    while(n--) {
	if(llength(curwp->w_dotp) > 0)
	    lputc(curwp->w_dotp, 0, ' ');
	if(lforw(curwp->w_dotp) != curbp->b_linep)
	    curwp->w_dotp = lforw(curwp->w_dotp);
    }
    curwp->w_flag |= WFEDIT | WFMOVE;
    curwp->w_doto = 0;
    return TRUE;
d83 2
a84 1
/*ARGSUSED*/
d86 1
a86 1
int f, n;
d88 12
a99 10
    if(n < 0) return d_undel(f, -n);
    while(n--) {
	if(llength(curwp->w_dotp) > 0)
	    lputc(curwp->w_dotp, 0, ' ');
	if(lback(curwp->w_dotp) != curbp->b_linep)
	    curwp->w_dotp = lback(curwp->w_dotp);
    }
    curwp->w_doto = 0;
    curwp->w_flag |= WFEDIT | WFMOVE;
    return TRUE;
d102 2
a103 1
/*ARGSUSED*/
d105 1
a105 1
int f, n;
d107 14
a120 11
    char fname[NFILEN];
    register BUFFER *bp;
    register int s;
    BUFFER *findbuffer();

    if((s = d_makename(curwp->w_dotp, fname)) == ABORT) return FALSE;
    if ((bp = (s ? dired_(fname) : findbuffer(fname))) == NULL) return FALSE;
    curbp = bp;
    if (showbuffer(bp, curwp, WFHARD) != TRUE) return FALSE;
    if (bp->b_fname[0] != 0) return TRUE;
    return readin(fname);
d123 2
a124 1
/*ARGSUSED*/
d126 1
a126 1
int f, n;
d128 16
a143 13
    char fname[NFILEN];
    register BUFFER *bp;
    register int s;
    register MGWIN *wp;
    BUFFER *findbuffer();

    if((s = d_makename(curwp->w_dotp, fname)) == ABORT) return FALSE;
    if ((bp = (s ? dired_(fname) : findbuffer(fname))) == NULL) return FALSE;
    if ((wp = popbuf(bp)) == NULL) return FALSE;
    curbp = bp;
    curwp = wp;
    if (bp->b_fname[0] != 0) return TRUE;  /* never true for dired buffers */
    return readin(fname);
d146 2
a147 1
/*ARGSUSED*/
d149 1
a149 1
int f, n;
d151 27
a177 26
    register LINE *lp, *nlp;
    char fname[NFILEN];
    VOID lfree();

    for(lp = lforw(curbp->b_linep); lp != curbp->b_linep; lp = nlp) {
	nlp = lforw(lp);
	if(llength(lp) && lgetc(lp, 0) == 'D') {
	    switch(d_makename(lp, fname)) {
		case ABORT:
		    ewprintf("Bad line in dired buffer");
		    return FALSE;
		case FALSE:
		    if(unlink(fname) < 0) {
			ewprintf("Could not delete '%s'", fname);
			return FALSE;
		    }
		    break;
		case TRUE:
		    if(rmdir(fname) < 0) {
			ewprintf("Could not delete directory '%s'", fname);
			return FALSE;
		    }
		    break;
	    }
	    lfree(lp);
	    curwp->w_flag |= WFHARD;
d179 1
a179 2
    }
    return TRUE;
d182 2
a183 1
/*ARGSUSED*/
d185 1
a185 1
int f, n;
d187 2
a188 2
    char frname[NFILEN], toname[NFILEN];
    int stat;
d190 8
a197 7
    if(d_makename(curwp->w_dotp, frname) != FALSE) {
	ewprintf("Not a file");
	return FALSE;
    }
    if((stat = eread("Copy %s to: ", toname, NFILEN, EFNEW | EFCR, frname))
	!= TRUE) return stat;
    return copy(frname, toname) >= 0;
d200 2
a201 1
/*ARGSUSED*/
d203 1
a203 1
int f, n;
d205 2
a206 2
    char frname[NFILEN], toname[NFILEN];
    int stat;
d208 8
a215 7
    if(d_makename(curwp->w_dotp, frname) != FALSE) {
	ewprintf("Not a file");
	return FALSE;
    }
    if((stat = eread("Rename %s to: ", toname, NFILEN, EFNEW | EFCR, frname))
	!= TRUE) return stat;
    return rename(frname, toname) >= 0;
a217 2


@


1.3
log
@Use uid_t, gid_t and mode_t where applicable.
Pull in changes from the BSD-specific sysdef.h and fileio.c:
kill bogus unlinkdir() and rename() kludges since we have rmdir(2) and rename(2)
define SYMBLINK since we have symlinks
TODO: merge BSD spawn.c and ttyio.c
@
text
@d149 1
a149 1
		    if(unlinkdir(fname) < 0) {
@


1.2
log
@change WINDOW -> MGWIN to avoid curses type conflict
convert to terminfo in tty*.c
add support for some keypad function keys (arrows, pgup, pgdown)
@
text
@d191 1
a191 1
    return Xrename(frname, toname) >= 0;
@


1.1
log
@initial import of mg2a
@
text
@d31 1
a31 1
    WINDOW *wp;
d115 1
a115 1
    register WINDOW *wp;
@

