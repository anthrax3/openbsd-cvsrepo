head	1.100;
access;
symbols
	OPENBSD_6_1:1.100.0.8
	OPENBSD_6_1_BASE:1.100
	OPENBSD_6_0:1.100.0.4
	OPENBSD_6_0_BASE:1.100
	OPENBSD_5_9:1.100.0.2
	OPENBSD_5_9_BASE:1.100
	OPENBSD_5_8:1.97.0.4
	OPENBSD_5_8_BASE:1.97
	OPENBSD_5_7:1.95.0.2
	OPENBSD_5_7_BASE:1.95
	OPENBSD_5_6:1.95.0.4
	OPENBSD_5_6_BASE:1.95
	OPENBSD_5_5:1.90.0.4
	OPENBSD_5_5_BASE:1.90
	OPENBSD_5_4:1.87.0.2
	OPENBSD_5_4_BASE:1.87
	OPENBSD_5_3:1.86.0.2
	OPENBSD_5_3_BASE:1.86
	OPENBSD_5_2:1.81.0.2
	OPENBSD_5_2_BASE:1.81
	OPENBSD_5_1_BASE:1.76
	OPENBSD_5_1:1.76.0.2
	OPENBSD_5_0:1.75.0.4
	OPENBSD_5_0_BASE:1.75
	OPENBSD_4_9:1.75.0.2
	OPENBSD_4_9_BASE:1.75
	OPENBSD_4_8:1.72.0.2
	OPENBSD_4_8_BASE:1.72
	OPENBSD_4_7:1.71.0.2
	OPENBSD_4_7_BASE:1.71
	OPENBSD_4_6:1.71.0.4
	OPENBSD_4_6_BASE:1.71
	OPENBSD_4_5:1.69.0.2
	OPENBSD_4_5_BASE:1.69
	OPENBSD_4_4:1.67.0.2
	OPENBSD_4_4_BASE:1.67
	OPENBSD_4_3:1.64.0.6
	OPENBSD_4_3_BASE:1.64
	OPENBSD_4_2:1.64.0.4
	OPENBSD_4_2_BASE:1.64
	OPENBSD_4_1:1.64.0.2
	OPENBSD_4_1_BASE:1.64
	OPENBSD_4_0:1.62.0.2
	OPENBSD_4_0_BASE:1.62
	OPENBSD_3_9:1.50.0.2
	OPENBSD_3_9_BASE:1.50
	OPENBSD_3_8:1.38.0.2
	OPENBSD_3_8_BASE:1.38
	OPENBSD_3_7:1.31.0.2
	OPENBSD_3_7_BASE:1.31
	OPENBSD_3_6:1.29.0.2
	OPENBSD_3_6_BASE:1.29
	OPENBSD_3_5:1.28.0.2
	OPENBSD_3_5_BASE:1.28
	OPENBSD_3_4:1.25.0.2
	OPENBSD_3_4_BASE:1.25
	OPENBSD_3_3:1.24.0.2
	OPENBSD_3_3_BASE:1.24
	OPENBSD_3_2:1.23.0.2
	OPENBSD_3_2_BASE:1.23
	OPENBSD_3_1:1.16.0.2
	OPENBSD_3_1_BASE:1.16
	OPENBSD_3_0:1.9.0.2
	OPENBSD_3_0_BASE:1.9
	OPENBSD_2_9_BASE:1.5
	OPENBSD_2_9:1.5.0.2
	OPENBSD_2_8:1.4.0.2
	OPENBSD_2_8_BASE:1.4
	OPENBSD_2_7:1.3.0.2
	OPENBSD_2_7_BASE:1.3;
locks; strict;
comment	@ * @;


1.100
date	2016.01.02.10.39.19;	author lum;	state Exp;
branches;
next	1.99;
commitid	cWRm8x2aZlyBJTgu;

1.99
date	2015.10.29.19.46.47;	author lum;	state Exp;
branches;
next	1.98;
commitid	PxYPCO6Bag1LXTJ7;

1.98
date	2015.09.29.08.53.53;	author lum;	state Exp;
branches;
next	1.97;
commitid	UAAEtKXk6Ru46ZjK;

1.97
date	2015.03.25.12.25.36;	author bcallah;	state Exp;
branches;
next	1.96;
commitid	wxpmevSdJTEN4Uqg;

1.96
date	2015.03.19.21.22.15;	author bcallah;	state Exp;
branches;
next	1.95;
commitid	GbEBL4CfPvDkB8hj;

1.95
date	2014.04.09.20.50.03;	author florian;	state Exp;
branches;
next	1.94;

1.94
date	2014.04.03.20.17.12;	author lum;	state Exp;
branches;
next	1.93;

1.93
date	2014.03.31.21.29.59;	author lum;	state Exp;
branches;
next	1.92;

1.92
date	2014.03.20.07.47.29;	author lum;	state Exp;
branches;
next	1.91;

1.91
date	2014.03.14.10.02.52;	author lum;	state Exp;
branches;
next	1.90;

1.90
date	2013.12.23.14.58.16;	author lum;	state Exp;
branches;
next	1.89;

1.89
date	2013.10.22.09.54.16;	author florian;	state Exp;
branches;
next	1.88;

1.88
date	2013.10.22.07.41.23;	author florian;	state Exp;
branches;
next	1.87;

1.87
date	2013.03.25.11.38.22;	author florian;	state Exp;
branches;
next	1.86;

1.86
date	2013.02.10.15.38.18;	author lum;	state Exp;
branches;
next	1.85;

1.85
date	2012.11.27.19.46.46;	author jasper;	state Exp;
branches;
next	1.84;

1.84
date	2012.08.30.21.36.48;	author lum;	state Exp;
branches;
next	1.83;

1.83
date	2012.08.30.06.09.12;	author lum;	state Exp;
branches;
next	1.82;

1.82
date	2012.08.28.11.37.49;	author lum;	state Exp;
branches;
next	1.81;

1.81
date	2012.06.18.09.19.21;	author lum;	state Exp;
branches;
next	1.80;

1.80
date	2012.05.25.04.56.58;	author lum;	state Exp;
branches;
next	1.79;

1.79
date	2012.05.10.16.07.46;	author lum;	state Exp;
branches;
next	1.78;

1.78
date	2012.05.08.15.26.31;	author lum;	state Exp;
branches;
next	1.77;

1.77
date	2012.04.11.14.16.57;	author lum;	state Exp;
branches;
next	1.76;

1.76
date	2011.08.31.08.58.29;	author lum;	state Exp;
branches;
next	1.75;

1.75
date	2011.01.23.00.45.03;	author kjell;	state Exp;
branches;
next	1.74;

1.74
date	2011.01.21.19.10.13;	author kjell;	state Exp;
branches;
next	1.73;

1.73
date	2011.01.18.16.29.37;	author kjell;	state Exp;
branches;
next	1.72;

1.72
date	2010.06.26.16.18.44;	author kjell;	state Exp;
branches;
next	1.71;

1.71
date	2009.06.04.23.39.37;	author kjell;	state Exp;
branches;
next	1.70;

1.70
date	2009.06.04.02.23.37;	author kjell;	state Exp;
branches;
next	1.69;

1.69
date	2008.09.15.16.13.35;	author kjell;	state Exp;
branches;
next	1.68;

1.68
date	2008.09.15.16.11.35;	author kjell;	state Exp;
branches;
next	1.67;

1.67
date	2008.06.18.17.13.53;	author kjell;	state Exp;
branches;
next	1.66;

1.66
date	2008.06.13.18.45.41;	author kjell;	state Exp;
branches;
next	1.65;

1.65
date	2008.03.21.08.01.20;	author pyr;	state Exp;
branches;
next	1.64;

1.64
date	2006.12.24.01.20.53;	author kjell;	state Exp;
branches;
next	1.63;

1.63
date	2006.11.17.08.45.31;	author kjell;	state Exp;
branches;
next	1.62;

1.62
date	2006.07.25.08.27.09;	author kjell;	state Exp;
branches;
next	1.61;

1.61
date	2006.07.25.08.22.32;	author kjell;	state Exp;
branches;
next	1.60;

1.60
date	2006.07.08.17.56.10;	author kjell;	state Exp;
branches;
next	1.59;

1.59
date	2006.06.01.09.00.50;	author kjell;	state Exp;
branches;
next	1.58;

1.58
date	2006.06.01.05.34.52;	author jason;	state Exp;
branches;
next	1.57;

1.57
date	2006.06.01.05.07.39;	author kjell;	state Exp;
branches;
next	1.56;

1.56
date	2006.06.01.01.41.49;	author kjell;	state Exp;
branches;
next	1.55;

1.55
date	2006.05.28.23.30.16;	author kjell;	state Exp;
branches;
next	1.54;

1.54
date	2006.05.02.17.10.25;	author kjell;	state Exp;
branches;
next	1.53;

1.53
date	2006.04.06.05.28.17;	author kjell;	state Exp;
branches;
next	1.52;

1.52
date	2006.04.03.05.03.34;	author deraadt;	state Exp;
branches;
next	1.51;

1.51
date	2006.04.03.00.40.56;	author deraadt;	state Exp;
branches;
next	1.50;

1.50
date	2005.12.20.06.17.36;	author kjell;	state Exp;
branches;
next	1.49;

1.49
date	2005.12.20.05.04.28;	author kjell;	state Exp;
branches;
next	1.48;

1.48
date	2005.12.13.06.01.27;	author kjell;	state Exp;
branches;
next	1.47;

1.47
date	2005.11.20.04.16.34;	author kjell;	state Exp;
branches;
next	1.46;

1.46
date	2005.11.20.03.24.17;	author deraadt;	state Exp;
branches;
next	1.45;

1.45
date	2005.11.18.20.56.52;	author deraadt;	state Exp;
branches;
next	1.44;

1.44
date	2005.11.13.07.24.48;	author kjell;	state Exp;
branches;
next	1.43;

1.43
date	2005.10.14.19.46.46;	author kjell;	state Exp;
branches;
next	1.42;

1.42
date	2005.10.13.20.28.49;	author deraadt;	state Exp;
branches;
next	1.41;

1.41
date	2005.10.13.20.23.01;	author kjell;	state Exp;
branches;
next	1.40;

1.40
date	2005.10.13.19.46.45;	author kjell;	state Exp;
branches;
next	1.39;

1.39
date	2005.10.13.05.34.11;	author kjell;	state Exp;
branches;
next	1.38;

1.38
date	2005.08.09.00.53.48;	author kjell;	state Exp;
branches;
next	1.37;

1.37
date	2005.06.14.18.14.40;	author kjell;	state Exp;
branches;
next	1.36;

1.36
date	2005.06.03.08.23.12;	author kjell;	state Exp;
branches;
next	1.35;

1.35
date	2005.05.30.13.13.50;	author jason;	state Exp;
branches;
next	1.34;

1.34
date	2005.05.27.08.52.30;	author cloder;	state Exp;
branches;
next	1.33;

1.33
date	2005.04.21.19.16.21;	author beck;	state Exp;
branches;
next	1.32;

1.32
date	2005.04.03.02.09.28;	author db;	state Exp;
branches;
next	1.31;

1.31
date	2005.03.10.18.27.47;	author henning;	state Exp;
branches;
next	1.30;

1.30
date	2005.03.09.16.20.48;	author jfb;	state Exp;
branches;
next	1.29;

1.29
date	2004.07.22.01.25.25;	author vincent;	state Exp;
branches;
next	1.28;

1.28
date	2003.11.09.00.19.02;	author vincent;	state Exp;
branches;
next	1.27;

1.27
date	2003.11.08.19.17.29;	author jmc;	state Exp;
branches;
next	1.26;

1.26
date	2003.10.13.02.29.29;	author vincent;	state Exp;
branches;
next	1.25;

1.25
date	2003.08.16.00.24.51;	author deraadt;	state Exp;
branches;
next	1.24;

1.24
date	2003.01.06.17.04.09;	author deraadt;	state Exp;
branches;
next	1.23;

1.23
date	2002.09.15.22.18.40;	author vincent;	state Exp;
branches;
next	1.22;

1.22
date	2002.07.25.16.37.54;	author vincent;	state Exp;
branches;
next	1.21;

1.21
date	2002.07.03.03.47.59;	author vincent;	state Exp;
branches;
next	1.20;

1.20
date	2002.07.01.14.33.44;	author vincent;	state Exp;
branches;
next	1.19;

1.19
date	2002.06.19.22.02.08;	author vincent;	state Exp;
branches;
next	1.18;

1.18
date	2002.05.29.12.41.42;	author vincent;	state Exp;
branches;
next	1.17;

1.17
date	2002.05.29.12.32.51;	author vincent;	state Exp;
branches;
next	1.16;

1.16
date	2002.03.16.04.17.36;	author vincent;	state Exp;
branches;
next	1.15;

1.15
date	2002.03.11.13.02.56;	author vincent;	state Exp;
branches;
next	1.14;

1.14
date	2002.02.19.12.58.42;	author vincent;	state Exp;
branches;
next	1.13;

1.13
date	2002.02.14.14.24.21;	author deraadt;	state Exp;
branches;
next	1.12;

1.12
date	2002.02.13.22.50.40;	author vincent;	state Exp;
branches;
next	1.11;

1.11
date	2002.02.13.22.36.58;	author vincent;	state Exp;
branches;
next	1.10;

1.10
date	2002.02.13.03.03.49;	author vincent;	state Exp;
branches;
next	1.9;

1.9
date	2001.05.24.03.05.22;	author mickey;	state Exp;
branches;
next	1.8;

1.8
date	2001.05.23.22.36.14;	author art;	state Exp;
branches;
next	1.7;

1.7
date	2001.05.23.22.20.35;	author art;	state Exp;
branches;
next	1.6;

1.6
date	2001.05.04.22.00.35;	author art;	state Exp;
branches;
next	1.5;

1.5
date	2001.01.29.01.58.07;	author niklas;	state Exp;
branches;
next	1.4;

1.4
date	2000.09.01.14.59.08;	author millert;	state Exp;
branches;
next	1.3;

1.3
date	2000.04.13.06.12.14;	author millert;	state Exp;
branches;
next	1.2;

1.2
date	2000.02.26.22.53.16;	author millert;	state Exp;
branches;
next	1.1;

1.1
date	2000.02.25.19.08.47;	author deraadt;	state Exp;
branches;
next	;


desc
@@


1.100
log
@Add dired-find-alternate-file.
@
text
@/*	$OpenBSD: file.c,v 1.99 2015/10/29 19:46:47 lum Exp $	*/

/* This file is in the public domain. */

/*
 *	File commands.
 */

#include <sys/queue.h>
#include <sys/stat.h>
#include <errno.h>
#include <libgen.h>
#include <signal.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>

#include "def.h"

size_t xdirname(char *, const char *, size_t);

/*
 * Insert a file into the current buffer.  Real easy - just call the
 * insertfile routine with the file name.
 */
/* ARGSUSED */
int
fileinsert(int f, int n)
{
	char	 fname[NFILEN], *bufp, *adjf;

	if (getbufcwd(fname, sizeof(fname)) != TRUE)
		fname[0] = '\0';
	bufp = eread("Insert file: ", fname, NFILEN,
	    EFNEW | EFCR | EFFILE | EFDEF);
	if (bufp == NULL)
		return (ABORT);
	else if (bufp[0] == '\0')
		return (FALSE);
	adjf = adjustname(bufp, TRUE);
	if (adjf == NULL)
		return (FALSE);
	return (insertfile(adjf, NULL, FALSE));
}

/*
 * Select a file for editing.  If the file is a directory, invoke dired.
 * Otherwise, look around to see if you can find the file in another buffer;
 * if you can find it, just switch to the buffer.  If you cannot find the
 * file, create a new buffer, read in the text, and switch to the new buffer.
 */
/* ARGSUSED */
int
filevisit(int f, int n)
{
	struct buffer	*bp;
	char	 fname[NFILEN], *bufp, *adjf;
	int	 status;

	if (getbufcwd(fname, sizeof(fname)) != TRUE)
		fname[0] = '\0';
	bufp = eread("Find file: ", fname, NFILEN,
	    EFNEW | EFCR | EFFILE | EFDEF);
	if (bufp == NULL)
		return (ABORT);
	else if (bufp[0] == '\0')
		return (FALSE);
	adjf = adjustname(fname, TRUE);
	if (adjf == NULL)
		return (FALSE);
	if (fisdir(adjf) == TRUE)
		return (do_dired(adjf));
	if ((bp = findbuffer(adjf)) == NULL)
		return (FALSE);
	curbp = bp;
	if (showbuffer(bp, curwp, WFFULL) != TRUE)
		return (FALSE);
	if (bp->b_fname[0] == '\0') {
		if ((status = readin(adjf)) != TRUE)
			killbuffer(bp);
		return (status);
	}
	return (TRUE);
}

/*
 * Replace the current file with an alternate one. Semantics for finding
 * the replacement file are the same as 'filevisit', except the current
 * buffer is killed before the switch. If the kill fails, or is aborted,
 * revert to the original file.
 */
/* ARGSUSED */
int
filevisitalt(int f, int n)
{
	char	 fname[NFILEN], *bufp;

	if (getbufcwd(fname, sizeof(fname)) != TRUE)
		fname[0] = '\0';
	bufp = eread("Find alternate file: ", fname, NFILEN,
	    EFNEW | EFCR | EFFILE | EFDEF);
	if (bufp == NULL)
		return (ABORT);
	else if (bufp[0] == '\0')
		return (FALSE);

	return (do_filevisitalt(fname));
}

int
do_filevisitalt(char *fn)
{
	struct buffer	*bp;
	int		 status;
	char		*adjf;

	status = killbuffer(curbp);
	if (status == ABORT || status == FALSE)
		return (ABORT);

	adjf = adjustname(fn, TRUE);
	if (adjf == NULL)
		return (FALSE);
	if (fisdir(adjf) == TRUE)
		return (do_dired(adjf));
	if ((bp = findbuffer(adjf)) == NULL)
		return (FALSE);
	curbp = bp;
	if (showbuffer(bp, curwp, WFFULL) != TRUE)
		return (FALSE);
	if (bp->b_fname[0] == '\0') {
		if ((status = readin(adjf)) != TRUE)
			killbuffer(bp);
		return (status);
	}
	return (TRUE);
}

int
filevisitro(int f, int n)
{
	int error;

	error = filevisit(f, n);
	if (error != TRUE)
		return (error);
	curbp->b_flag |= BFREADONLY;
	return (TRUE);
}

/*
 * Pop to a file in the other window.  Same as the last function, but uses
 * popbuf instead of showbuffer.
 */
/* ARGSUSED */
int
poptofile(int f, int n)
{
	struct buffer	*bp;
	struct mgwin	*wp;
	char	 fname[NFILEN], *adjf, *bufp;
	int	 status;

	if (getbufcwd(fname, sizeof(fname)) != TRUE)
		fname[0] = '\0';
	if ((bufp = eread("Find file in other window: ", fname, NFILEN,
	    EFNEW | EFCR | EFFILE | EFDEF)) == NULL)
		return (ABORT);
	else if (bufp[0] == '\0')
		return (FALSE);
	adjf = adjustname(fname, TRUE);
	if (adjf == NULL)
		return (FALSE);
	if (fisdir(adjf) == TRUE)
		return (do_dired(adjf));
	if ((bp = findbuffer(adjf)) == NULL)
		return (FALSE);
	if (bp == curbp)
		return (splitwind(f, n));
	if ((wp = popbuf(bp, WNONE)) == NULL)
		return (FALSE);
	curbp = bp;
	curwp = wp;
	if (bp->b_fname[0] == '\0') {
		if ((status = readin(adjf)) != TRUE)
			killbuffer(bp);
		return (status);
	}
	return (TRUE);
}

/*
 * Read the file "fname" into the current buffer.  Make all of the text
 * in the buffer go away, after checking for unsaved changes.  This is
 * called by the "read" command, the "visit" command, and the mainline
 * (for "mg file").
 */
int
readin(char *fname)
{
	struct mgwin	*wp;
	struct stat	 statbuf;
	int	 status, i, ro = FALSE;
	PF	*ael;
	char	 dp[NFILEN];

	/* might be old */
	if (bclear(curbp) != TRUE)
		return (TRUE);
	/* Clear readonly. May be set by autoexec path */
	curbp->b_flag &= ~BFREADONLY;
	if ((status = insertfile(fname, fname, TRUE)) != TRUE) {
		dobeep();
		ewprintf("File is not readable: %s", fname);
		return (FALSE);
	}

	for (wp = wheadp; wp != NULL; wp = wp->w_wndp) {
		if (wp->w_bufp == curbp) {
			wp->w_dotp = wp->w_linep = bfirstlp(curbp);
			wp->w_doto = 0;
			wp->w_markp = NULL;
			wp->w_marko = 0;
		}
	}

	/*
	 * Call auto-executing function if we need to.
	 */
	if ((ael = find_autoexec(fname)) != NULL) {
		for (i = 0; ael[i] != NULL; i++)
			(*ael[i])(0, 1);
		free(ael);
	}

	/* no change */
	curbp->b_flag &= ~BFCHG;

	/*
	 * Set the buffer READONLY flag if any of following are true:
	 *   1. file is a directory.
	 *   2. file is read-only.
	 *   3. file doesn't exist and directory is read-only.
	 */
	if (fisdir(fname) == TRUE) {
		ro = TRUE;
	} else if ((access(fname, W_OK) == -1)) {
		if (errno != ENOENT) {
			ro = TRUE;
		} else if (errno == ENOENT) {
			(void)xdirname(dp, fname, sizeof(dp));
			(void)strlcat(dp, "/", sizeof(dp));

			/* Missing directory; keep buffer rw, like emacs */
			if (stat(dp, &statbuf) == -1 && errno == ENOENT) {
				if (eyorn("Missing directory, create") == TRUE)
					(void)do_makedir(dp);
			} else if (access(dp, W_OK) == -1 && errno == EACCES) {
				ewprintf("File not found and directory"
				    " write-protected");
				ro = TRUE;
			}
		}
	}
	if (ro == TRUE)
		curbp->b_flag |= BFREADONLY;

	if (startrow) {
		gotoline(FFARG, startrow);
		startrow = 0;
	}

	undo_add_modified();
	return (status);
}

/*
 * NB, getting file attributes is done here under control of a flag
 * rather than in readin, which would be cleaner.  I was concerned
 * that some operating system might require the file to be open
 * in order to get the information.  Similarly for writing.
 */

/*
 * Insert a file in the current buffer, after dot. If file is a directory,
 * and 'replacebuf' is TRUE, invoke dired mode, else die with an error.
 * If file is a regular file, set mark at the end of the text inserted;
 * point at the beginning.  Return a standard status. Print a summary
 * (lines read, error message) out as well. This routine also does the
 * read end of backup processing.  The BFBAK flag, if set in a buffer,
 * says that a backup should be taken.  It is set when a file is read in,
 * but not on a new file. You don't need to make a backup copy of nothing.
 */

static char	*line = NULL;
static int	linesize = 0;

int
insertfile(char *fname, char *newname, int replacebuf)
{
	struct buffer	*bp;
	struct line	*lp1, *lp2;
	struct line	*olp;			/* line we started at */
	struct mgwin	*wp;
	int	 nbytes, s, nline = 0, siz, x, x2;
	int	 opos;			/* offset we started at */
	int	 oline;			/* original line number */
        FILE    *ffp;

	if (replacebuf == TRUE)
		x = undo_enable(FFRAND, 0);
	else
		x = undo_enabled();

	lp1 = NULL;
	if (line == NULL) {
		line = malloc(NLINE);
		if (line == NULL)
			panic("out of memory");
		linesize = NLINE;
	}

	/* cheap */
	bp = curbp;
	if (newname != NULL) {
		(void)strlcpy(bp->b_fname, newname, sizeof(bp->b_fname));
		(void)xdirname(bp->b_cwd, newname, sizeof(bp->b_cwd));
		(void)strlcat(bp->b_cwd, "/", sizeof(bp->b_cwd));
	}

	/* hard file open */
	if ((s = ffropen(&ffp, fname, (replacebuf == TRUE) ? bp : NULL))
	    == FIOERR)
		goto out;
	if (s == FIOFNF) {
		/* file not found */
		if (newname != NULL)
			ewprintf("(New file)");
		else
			ewprintf("(File not found)");
		goto out;
	} else if (s == FIODIR) {
		/* file was a directory */
		if (replacebuf == FALSE) {
			dobeep();
			ewprintf("Cannot insert: file is a directory, %s",
			    fname);
			goto cleanup;
		}
		killbuffer(bp);
		bp = dired_(fname);
		undo_enable(FFRAND, x);
		if (bp == NULL)
			return (FALSE);
		curbp = bp;
		return (showbuffer(bp, curwp, WFFULL | WFMODE));
	} else {
		(void)xdirname(bp->b_cwd, fname, sizeof(bp->b_cwd));
		(void)strlcat(bp->b_cwd, "/", sizeof(bp->b_cwd));
	}
	opos = curwp->w_doto;
	oline = curwp->w_dotline;
	/*
	 * Open a new line at dot and start inserting after it.
	 * We will delete this newline after insertion.
	 * Disable undo, as we create the undo record manually.
	 */
	x2 = undo_enable(FFRAND, 0);
	(void)lnewline();
	olp = lback(curwp->w_dotp);
	undo_enable(FFRAND, x2);

	nline = 0;
	siz = 0;
	while ((s = ffgetline(ffp, line, linesize, &nbytes)) != FIOERR) {
retry:
		siz += nbytes + 1;
		switch (s) {
		case FIOSUC:
			/* FALLTHRU */
		case FIOEOF:
			++nline;
			if ((lp1 = lalloc(nbytes)) == NULL) {
				/* keep message on the display */
				s = FIOERR;
				undo_add_insert(olp, opos,
				    siz - nbytes - 1 - 1);
				goto endoffile;
			}
			bcopy(line, &ltext(lp1)[0], nbytes);
			lp2 = lback(curwp->w_dotp);
			lp2->l_fp = lp1;
			lp1->l_fp = curwp->w_dotp;
			lp1->l_bp = lp2;
			curwp->w_dotp->l_bp = lp1;
			if (s == FIOEOF) {
				undo_add_insert(olp, opos, siz - 1);
				goto endoffile;
			}
			break;
		case FIOLONG: {
				/* a line too long to fit in our buffer */
				char	*cp;
				int	newsize;

				newsize = linesize * 2;
				if (newsize < 0 ||
				    (cp = malloc(newsize)) == NULL) {
					dobeep();
					ewprintf("Could not allocate %d bytes",
					    newsize);
						s = FIOERR;
						goto endoffile;
				}
				bcopy(line, cp, linesize);
				free(line);
				line = cp;
				s = ffgetline(ffp, line + linesize, linesize,
				    &nbytes);
				nbytes += linesize;
				linesize = newsize;
				if (s == FIOERR)
					goto endoffile;
				goto retry;
			}
		default:
			dobeep();
			ewprintf("Unknown code %d reading file", s);
			s = FIOERR;
			break;
		}
	}
endoffile:
	/* ignore errors */
	(void)ffclose(ffp, NULL);
	/* don't zap an error */
	if (s == FIOEOF) {
		if (nline == 1)
			ewprintf("(Read 1 line)");
		else
			ewprintf("(Read %d lines)", nline);
	}
	/* set mark at the end of the text */
	curwp->w_dotp = curwp->w_markp = lback(curwp->w_dotp);
	curwp->w_marko = llength(curwp->w_markp);
	curwp->w_markline = oline + nline + 1;
	/*
	 * if we are at the end of the file, ldelnewline is a no-op,
	 * but we still need to decrement the line and markline counts
	 * as we've accounted for this fencepost in our arithmetic
	 */
	if (lforw(curwp->w_dotp) == curwp->w_bufp->b_headp) {
		curwp->w_bufp->b_lines--;
		curwp->w_markline--;
	} else
		(void)ldelnewline();
	curwp->w_dotp = olp;
	curwp->w_doto = opos;
	curwp->w_dotline = oline;
	if (olp == curbp->b_headp)
		curwp->w_dotp = lforw(olp);
	if (newname != NULL)
		bp->b_flag |= BFCHG | BFBAK;	/* Need a backup.	 */
	else
		bp->b_flag |= BFCHG;
	/*
	 * If the insert was at the end of buffer, set lp1 to the end of
	 * buffer line, and lp2 to the beginning of the newly inserted text.
	 * (Otherwise lp2 is set to NULL.)  This is used below to set
	 * pointers in other windows correctly if they are also at the end of
	 * buffer.
	 */
	lp1 = bp->b_headp;
	if (curwp->w_markp == lp1) {
		lp2 = curwp->w_dotp;
	} else {
		/* delete extraneous newline */
		(void)ldelnewline();
out:		lp2 = NULL;
	}
	for (wp = wheadp; wp != NULL; wp = wp->w_wndp) {
		if (wp->w_bufp == curbp) {
			wp->w_rflag |= WFMODE | WFEDIT;
			if (wp != curwp && lp2 != NULL) {
				if (wp->w_dotp == lp1)
					wp->w_dotp = lp2;
				if (wp->w_markp == lp1)
					wp->w_markp = lp2;
				if (wp->w_linep == lp1)
					wp->w_linep = lp2;
			}
		}
	}
	bp->b_lines += nline;
cleanup:
	undo_enable(FFRAND, x);

	/* return FALSE if error */
	return (s != FIOERR);
}

/*
 * Ask for a file name and write the contents of the current buffer to that
 * file.  Update the remembered file name and clear the buffer changed flag.
 * This handling of file names is different from the earlier versions and
 * is more compatible with Gosling EMACS than with ITS EMACS.
 */
/* ARGSUSED */
int
filewrite(int f, int n)
{
	struct stat     statbuf;
	int	 s;
	char	 fname[NFILEN], bn[NBUFN], tmp[NFILEN + 25];
	char	*adjfname, *bufp;
        FILE    *ffp;

	if (getbufcwd(fname, sizeof(fname)) != TRUE)
		fname[0] = '\0';
	if ((bufp = eread("Write file: ", fname, NFILEN,
	    EFDEF | EFNEW | EFCR | EFFILE)) == NULL)
		return (ABORT);
	else if (bufp[0] == '\0')
		return (FALSE);

	adjfname = adjustname(fname, TRUE);
	if (adjfname == NULL)
		return (FALSE);

        /* Check if file exists; write checks done later */
        if (stat(adjfname, &statbuf) == 0) {
		if (S_ISDIR(statbuf.st_mode)) {
			dobeep();
			ewprintf("%s is a directory", adjfname);
			return (FALSE);
		}
		snprintf(tmp, sizeof(tmp), "File `%s' exists; overwrite",
		    adjfname);
		if ((s = eyorn(tmp)) != TRUE)
                        return (s);
        }

	/* old attributes are no longer current */
	bzero(&curbp->b_fi, sizeof(curbp->b_fi));
	if ((s = writeout(&ffp, curbp, adjfname)) == TRUE) {
		(void)strlcpy(curbp->b_fname, adjfname, sizeof(curbp->b_fname));
		if (getbufcwd(curbp->b_cwd, sizeof(curbp->b_cwd)) != TRUE)
			(void)strlcpy(curbp->b_cwd, "/", sizeof(curbp->b_cwd));
		if (augbname(bn, curbp->b_fname, sizeof(bn))
		    == FALSE)
			return (FALSE);
		free(curbp->b_bname);
		if ((curbp->b_bname = strdup(bn)) == NULL)
			return (FALSE);
		(void)fupdstat(curbp);
		curbp->b_flag &= ~(BFBAK | BFCHG);
		upmodes(curbp);
		undo_add_boundary(FFRAND, 1);
		undo_add_modified();
	}
	return (s);
}

/*
 * Save the contents of the current buffer back into its associated file.
 */
static int	makebackup = TRUE;

/* ARGSUSED */
int
filesave(int f, int n)
{
	if (curbp->b_fname[0] == '\0')
		return (filewrite(f, n));
	else
		return (buffsave(curbp));
}

/*
 * Save the contents of the buffer argument into its associated file.  Do
 * nothing if there have been no changes (is this a bug, or a feature?).
 * Error if there is no remembered file name. If this is the first write
 * since the read or visit, then a backup copy of the file is made.
 * Allow user to select whether or not to make backup files by looking at
 * the value of makebackup.
 */
int
buffsave(struct buffer *bp)
{
	int	 s;
        FILE    *ffp;

	/* return, no changes */
	if ((bp->b_flag & BFCHG) == 0) {
		ewprintf("(No changes need to be saved)");
		return (TRUE);
	}

	/* must have a name */
	if (bp->b_fname[0] == '\0') {
		dobeep();
		ewprintf("No file name");
		return (FALSE);
	}

	/* Ensure file has not been modified elsewhere */
	/* We don't use the ignore flag here */
	if (fchecktime(bp) != TRUE) {
		if ((s = eyesno("File has changed on disk since last save. "
		    "Save anyway")) != TRUE)
			return (s);
	}
	
	if (makebackup && (bp->b_flag & BFBAK)) {
		s = fbackupfile(bp->b_fname);
		/* hard error */
		if (s == ABORT)
			return (FALSE);
		/* softer error */
		if (s == FALSE &&
		    (s = eyesno("Backup error, save anyway")) != TRUE)
			return (s);
	}
	if ((s = writeout(&ffp, bp, bp->b_fname)) == TRUE) {
		(void)fupdstat(bp);
		bp->b_flag &= ~(BFCHG | BFBAK);
		upmodes(bp);
		undo_add_boundary(FFRAND, 1);
		undo_add_modified();
	}
	return (s);
}

/*
 * Since we don't have variables (we probably should) this is a command
 * processor for changing the value of the make backup flag.  If no argument
 * is given, sets makebackup to true, so backups are made.  If an argument is
 * given, no backup files are made when saving a new version of a file.
 */
/* ARGSUSED */
int
makebkfile(int f, int n)
{
	if (f & FFARG)
		makebackup = n > 0;
	else
		makebackup = !makebackup;
	ewprintf("Backup files %sabled", makebackup ? "en" : "dis");
	return (TRUE);
}

/*
 * NB: bp is passed to both ffwopen and ffclose because some
 * attribute information may need to be updated at open time
 * and others after the close.  This is OS-dependent.  Note
 * that the ff routines are assumed to be able to tell whether
 * the attribute information has been set up in this buffer
 * or not.
 */

/*
 * This function performs the details of file writing; writing the file
 * in buffer bp to file fn. Uses the file management routines in the
 * "fileio.c" package. Most of the grief is checking of some sort.
 * You may want to call fupdstat() after using this function.
 */
int
writeout(FILE ** ffp, struct buffer *bp, char *fn)
{
	struct stat	statbuf;
	int	 s;
	char     dp[NFILEN];

	if (stat(fn, &statbuf) == -1 && errno == ENOENT) {
		errno = 0;
		(void)xdirname(dp, fn, sizeof(dp));
		(void)strlcat(dp, "/", sizeof(dp));
		if (access(dp, W_OK) && errno == EACCES) {
			dobeep();
			ewprintf("Directory %s write-protected", dp);
			return (FIOERR);
		} else if (errno == ENOENT) {
   			dobeep();
			ewprintf("%s: no such directory", dp);
			return (FIOERR);
		}
        }
	/* open writes message */
	if ((s = ffwopen(ffp, fn, bp)) != FIOSUC)
		return (FALSE);
	s = ffputbuf(*ffp, bp);
	if (s == FIOSUC) {
		/* no write error */
		s = ffclose(*ffp, bp);
		if (s == FIOSUC)
			ewprintf("Wrote %s", fn);
	} else {
		/* print a message indicating write error */
		(void)ffclose(*ffp, bp);
		dobeep();
		ewprintf("Unable to write %s", fn);
	}
	return (s == FIOSUC);
}

/*
 * Tag all windows for bp (all windows if bp == NULL) as needing their
 * mode line updated.
 */
void
upmodes(struct buffer *bp)
{
	struct mgwin	*wp;

	for (wp = wheadp; wp != NULL; wp = wp->w_wndp)
		if (bp == NULL || curwp->w_bufp == bp)
			wp->w_rflag |= WFMODE;
}

/*
 * dirname using strlcpy semantic.
 * Like dirname() except an empty string is returned in
 * place of "/". This means we can always add a trailing
 * slash and be correct.
 * Address portability issues by copying argument
 * before using. Some implementations modify the input string.
 */
size_t
xdirname(char *dp, const char *path, size_t dplen)
{
	char ts[NFILEN];
	size_t len;

	(void)strlcpy(ts, path, NFILEN);
	len = strlcpy(dp, dirname(ts), dplen);
	if (dplen > 0 && dp[0] == '/' && dp[1] == '\0') {
		dp[0] = '\0';
		len = 0;
	}
	return (len);
}

/*
 * basename using strlcpy/strlcat semantic.
 * Address portability issue by copying argument
 * before using: some implementations modify the input string.
 */
size_t
xbasename(char *bp, const char *path, size_t bplen)
{
	char ts[NFILEN];

	(void)strlcpy(ts, path, NFILEN);
	return (strlcpy(bp, basename(ts), bplen));
}

/*
 * The adjusted file name refers to a directory, so open dired mode.
 */
int
do_dired(char *adjf)
{
	struct buffer	*bp;

	if ((bp = dired_(adjf)) == FALSE)
		return (FALSE);
	curbp = bp;
	return (showbuffer(bp, curwp, WFFULL | WFMODE));
}
@


1.99
log
@Fix opening dired from the command line. Incorrect cursor placement
and make the error more useful when there is a problem opening a
directory. Reported by and ok jasper@@
@
text
@d1 1
a1 1
/*	$OpenBSD: file.c,v 1.98 2015/09/29 08:53:53 lum Exp $	*/
d97 1
a97 3
	struct buffer	*bp;
	char	 fname[NFILEN], *bufp, *adjf;
	int	 status;
d108 10
d122 1
a122 1
	adjf = adjustname(fname, TRUE);
@


1.98
log
@Check to see if the file to be opened is a directory as soon as is
feasible. Currently, mg does this check much later on which means some
functions (e.g showbuffer()) are called multiple times. This fixes the
location of the cursor when opening a directory using filevisit,
findvisitalt and poptofile. ok jasper@@
@
text
@d1 1
a1 1
/*	$OpenBSD: file.c,v 1.97 2015/03/25 12:25:36 bcallah Exp $	*/
a21 2

static	int do_dired(char *);
@


1.97
log
@We really don't need ttydef.h -- it is like sysdef.h -- once useful because
supported a lot of systems and nothing was standardized. But now it only
4 defines. Move those defines into def.h since ttydef.h is only sourced in
def.h

While here, MAKEBACKUP has the same #ifdef dance that LINENOMODE had. Set
it directly to TRUE and remove the #ifdef block.

ok florian@@
@
text
@d1 1
a1 1
/*	$OpenBSD: file.c,v 1.96 2015/03/19 21:22:15 bcallah Exp $	*/
d23 2
d50 4
a53 4
 * Select a file for editing.  Look around to see if you can find the file
 * in another buffer; if you can find it, just switch to the buffer.  If
 * you cannot find the file, create a new buffer, read in the text, and
 * switch to the new buffer.
d74 2
d119 2
d169 2
d750 14
@


1.96
log
@Clean up the includes in mg.
This does the following:
Moves all POSIX headers from sysdef.h into the individual .c files so that
each file now only includes what it needs. All headers are properly sorted.
Moves the remainder of sysdef.h to other files (mostly def.h) and deletes
sysdef.h now that it's no longer contains anything.
Tweak a comment that references sysdef.h so that it no longer does that.
ok florian@@
@
text
@d1 1
a1 1
/*	$OpenBSD: file.c,v 1.95 2014/04/09 20:50:03 florian Exp $	*/
d554 1
a554 4
#ifndef	MAKEBACKUP
#define	MAKEBACKUP TRUE
#endif /* !MAKEBACKUP */
static int	makebackup = MAKEBACKUP;
@


1.95
log
@Revert 1.93, it breaks permission checks.
"go for it" deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: file.c,v 1.94 2014/04/03 20:17:12 lum Exp $	*/
d9 1
a9 2
#include "def.h"

d11 7
d19 1
a19 1
#include <libgen.h>
@


1.94
log
@When finding a file in a non-existant directory:

C-x C-f ~/no/dir/here/fn

offer to make the directory by pressing 'y', instead of suggesting the
make-directory command. ok jasper@@
@
text
@d1 1
a1 1
/*	$OpenBSD: file.c,v 1.93 2014/03/31 21:29:59 lum Exp $	*/
d228 2
a229 13
	} else if ((access(fname, W_OK) == -1) && (errno != ENOENT)) {
		ro = TRUE;
	} else if (errno == ENOENT) {
		(void)xdirname(dp, fname, sizeof(dp));
		(void)strlcat(dp, "/", sizeof(dp));

		/* Missing directory; keep buffer read-write, like emacs */
		if (stat(dp, &statbuf) == -1 && errno == ENOENT) {
			if (eyorn("Missing directory, create") == TRUE)
				(void)do_makedir(dp);
		} else if (access(dp, W_OK) == -1 && errno == EACCES) {
			ewprintf("File not found and directory"
			    " write-protected");
d231 13
@


1.93
log
@Tidy up. No functional change.
@
text
@d1 1
a1 1
/*	$OpenBSD: file.c,v 1.92 2014/03/20 07:47:29 lum Exp $	*/
d234 1
d236 2
a237 3
			/* not read-only; like emacs */
			ewprintf("Use M-x make-directory RET RET to create the"
			    " directory and its parents");
@


1.92
log
@Add some missing dobeeps.
ok florian@@
@
text
@d1 1
a1 1
/*	$OpenBSD: file.c,v 1.91 2014/03/14 10:02:52 lum Exp $	*/
d228 13
a240 2
	} else if (access(fname, W_OK) == -1) {
		if (errno != ENOENT)
a241 13
		else if (errno == ENOENT) {
			(void)xdirname(dp, fname, sizeof(dp));
			(void)strlcat(dp, "/", sizeof(dp));
			if (stat(dp, &statbuf) == -1 && errno == ENOENT) {
				/* no read-only; like emacs */
				ewprintf("Use M-x make-directory RET RET to "
				    "create the directory and its parents");
			} else if (access(dp, W_OK) == -1 && 
			    errno == EACCES) {
				ewprintf("File not found and directory"
				    " write-protected");
				ro = TRUE;
			}
@


1.91
log
@Check if buffer is to be saved as a directory.
ok florian@@
@
text
@d1 1
a1 1
/*	$OpenBSD: file.c,v 1.90 2013/12/23 14:58:16 lum Exp $	*/
d194 1
d326 1
d390 1
d408 1
d585 1
d663 1
d667 2
a668 1
                        ewprintf("%s: no such directory", dp);
d684 1
@


1.90
log
@Move findbuffer() to buffer.c.
ok florian@@
@
text
@d1 1
a1 1
/*	$OpenBSD: file.c,v 1.89 2013/10/22 09:54:16 florian Exp $	*/
d509 5
@


1.89
log
@Fix previous; ENOCOFFEE.
Move xdirname call into the right if block, pointed out by Ulrich
Mueller.
@
text
@d1 1
a1 1
/*	$OpenBSD: file.c,v 1.88 2013/10/22 07:41:23 florian Exp $	*/
a170 27
}

/*
 * Given a file name, either find the buffer it uses, or create a new
 * empty buffer to put it in.
 */
struct buffer *
findbuffer(char *fn)
{
	struct buffer	*bp;
	char		bname[NBUFN], fname[NBUFN];

	if (strlcpy(fname, fn, sizeof(fname)) >= sizeof(fname)) {
		ewprintf("filename too long");
		return (NULL);
	}

	for (bp = bheadp; bp != NULL; bp = bp->b_bufp) {
		if (strcmp(bp->b_fname, fname) == 0)
			return (bp);
	}
	/* Not found. Create a new one, adjusting name first */
	if (augbname(bname, fname, sizeof(bname)) == FALSE)
		return (NULL);

	bp = bfind(bname, TRUE);
	return (bp);
@


1.88
log
@Our man page states that it's not portable to rely on dirname(3) not
modifying the contents of the passed string. Replace dirname(3) with
mg's xdirname portability helper function (a slightly different fix
than Gentoo's).

Report and initial analysis by Marien Zwart in Gentoo bug #487758 via
Han Boetes (hboetes _AT_ gmail).
Gentoo bugfix by Ulrich Mueller (ulm _AT_ gentoo).
testing on glibc / input Ulrich Mueller; testing on glibc Han Boetes.
Thanks!

OK jasper@@
@
text
@d1 1
a1 1
/*	$OpenBSD: file.c,v 1.87 2013/03/25 11:38:22 florian Exp $	*/
d677 2
a679 3
			(void)xdirname(dp, fn, sizeof(dp));
			(void)strlcat(dp, "/", sizeof(dp));

@


1.87
log
@Record when the buffer was saved in the undo history. The buffer
will be marked unchanged at the correct point when stepping
through the undo history.
OK jasper@@
@
text
@d1 1
a1 1
/*	$OpenBSD: file.c,v 1.86 2013/02/10 15:38:18 lum Exp $	*/
d213 1
a213 1
	char	*dp;
d258 2
a259 1
			dp = dirname(fname);
d673 1
a673 3
	char    *dp;

	dp = dirname(fn);
d678 4
a681 2
			ewprintf("Directory %s%s write-protected", dp,
			    (dp[0] == '/' && dp[1] == '\0') ? "" : "/");
d684 1
a684 2
                        ewprintf("%s%s: no such directory", dp,
                            (dp[0] == '/' && dp[1] == '\0') ? "" : "/");
@


1.86
log
@Grammar nits.
@
text
@d1 1
a1 1
/*	$OpenBSD: file.c,v 1.85 2012/11/27 19:46:46 jasper Exp $	*/
d556 2
d628 2
@


1.85
log
@- add 'make-directory' (not bound to any shortcut).

feedback from florian@@ lum@@
ok florian@@
@
text
@d1 1
a1 1
/*	$OpenBSD: file.c,v 1.84 2012/08/30 21:36:48 lum Exp $	*/
d262 1
a262 1
				    "create the directory and it's parents");
@


1.84
log
@oops. need to reset errno. Otherwise we can't save a new file in a
directory where permissions are ok.
@
text
@d1 1
a1 1
/*	$OpenBSD: file.c,v 1.83 2012/08/30 06:09:12 lum Exp $	*/
d261 2
a262 1
				ewprintf("Parent directory missing");
d268 1
a268 1
			} 
@


1.83
log
@This diff allows the user to decide what to do with buffers that
experience write errors during C-x C-c (exiting mg). Emacs stops the
exiting process when it encounters problem buffers and lets the user
decide what to do, currently mg continues exiting and the contents of
these buffers are lost. This diff bring mg more into line with emacs.

Review and observations from Sunil Nimmagadda.
@
text
@d1 1
a1 1
/*	$OpenBSD: file.c,v 1.82 2012/08/28 11:37:49 lum Exp $	*/
d672 1
@


1.82
log
@Make mg behave more like emacs with regards to opening a new buffer:

1. If parent directory is read-only, make buffer read-only.
2. If parent doesn't exist; give user a message and create buffer
   as readable.

Reviewed by Sunil Nimmagadda.
ok jasper@@
@
text
@d1 1
a1 1
/*	$OpenBSD: file.c,v 1.81 2012/06/18 09:19:21 lum Exp $	*/
d665 1
d667 1
d669 13
@


1.81
log
@Removing this 'if' statement allows dired buffers to not have their
forward and backward line pointers pointing to the same line, causing
mg to spin when asked to split the window. This happens if a directory
is opened via the command line sequentially first, and other windows
need to opened afterwards (for other files).

Since the information within this 'if' statement is updated later for
files and directories I can see no problem with removing this. No
regressions viewable either.

Problem reported by and diff tested by jasper@@
@
text
@d1 1
a1 1
/*	$OpenBSD: file.c,v 1.80 2012/05/25 04:56:58 lum Exp $	*/
d210 1
d213 1
d247 4
a250 2
	 * We need to set the READONLY flag after we insert the file,
	 * unless the file is a directory.
d252 1
a252 3
	if (access(fname, W_OK) && errno != ENOENT)
		ro = TRUE;
	if (fisdir(fname) == TRUE)
d254 16
@


1.80
log
@Remove static FILE pointer used for handling files in fileio.c. Pass
by reference instead. This allows the mg startup file to open other
files without unexpected things happening.

Discussed with Sunil Nimmagadda.
@
text
@d1 1
a1 1
/*	$OpenBSD: file.c,v 1.79 2012/05/10 16:07:46 lum Exp $	*/
d225 4
a228 6
			if ((fisdir(fname)) != TRUE) {
				wp->w_dotp = wp->w_linep = bfirstlp(curbp);
				wp->w_doto = 0;
				wp->w_markp = NULL;
				wp->w_marko = 0;
				}
@


1.79
log
@Allow throwaway buffers to be saved via C-c s. This diff
does not change the behaviour with regards to mg not asking
to save throwaway buffers when exiting.

Reviewed by Sunil Nimmagadda.
@
text
@d1 1
a1 1
/*	$OpenBSD: file.c,v 1.78 2012/05/08 15:26:31 lum Exp $	*/
d297 1
d321 2
a322 1
	if ((s = ffropen(fname, (replacebuf == TRUE) ? bp : NULL)) == FIOERR)
d363 1
a363 1
	while ((s = ffgetline(line, linesize, &nbytes)) != FIOERR) {
d405 1
a405 1
				s = ffgetline(line + linesize, linesize,
d421 1
a421 1
	(void)ffclose(NULL);
d502 1
d526 1
a526 1
	if ((s = writeout(curbp, adjfname)) == TRUE) {
d573 1
d605 1
a605 1
	if ((s = writeout(bp, bp->b_fname)) == TRUE) {
d647 1
a647 1
writeout(struct buffer *bp, char *fn)
d652 1
a652 1
	if ((s = ffwopen(fn, bp)) != FIOSUC)
d654 1
a654 1
	s = ffputbuf(bp);
d657 1
a657 1
		s = ffclose(bp);
d662 1
a662 1
		(void)ffclose(bp);
@


1.78
log
@Fix a bug in writeout() where the stats of the wrong file
were given to a buffer being written.

Reviewed by Sunil Nimmagadda.
@
text
@d1 1
a1 1
/*	$OpenBSD: file.c,v 1.77 2012/04/11 14:16:57 lum Exp $	*/
d552 4
a555 1
	return (buffsave(curbp));
@


1.77
log
@When writing a file via 'C-x C-w', ask user if they want to overwrite an
existing file. This mimics emacs behaviour.

Reviewed by Sunil Nimmagadda.
@
text
@d1 1
a1 1
/*	$OpenBSD: file.c,v 1.76 2011/08/31 08:58:29 lum Exp $	*/
d533 1
d599 1
d637 1
a657 1
	(void)fupdstat(bp);
@


1.76
log
@On a file write fail:

1. return an error value
2. show an error message

From Loganaden Velvindron with suggestion from millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: file.c,v 1.75 2011/01/23 00:45:03 kjell Exp $	*/
d11 2
d496 1
d498 1
a498 1
	char	 fname[NFILEN], bn[NBUFN];
d512 9
@


1.75
log
@Wrap basename,dirname with xbasename, xdirname funtions,
which have fewer special cases, and use the strlcpy/strlcat
src/dst/buffer len semantic. More portable to boot.
Discussion and feedback from Henri Kemppainen
@
text
@d1 1
a1 1
/*	$OpenBSD: file.c,v 1.74 2011/01/21 19:10:13 kjell Exp $	*/
d417 1
a417 1
	ffclose(NULL);
d638 2
a639 2
	} else
		/* ignore close error if it is a write error */
d641 2
@


1.74
log
@It volates style(9), but in mg, #include"def.h" goes first. 'twas the way it was built. no binary change here. confirmed by lum@@, tested by Henri Kemppainen
@
text
@d1 1
a1 1
/*	$OpenBSD: file.c,v 1.73 2011/01/18 16:29:37 kjell Exp $	*/
d13 1
a13 1
static char *xdirname(const char *);
a294 1
	char *dp;
d313 1
a313 2
		dp = xdirname(newname);
		(void)strlcpy(bp->b_cwd, dp, sizeof(bp->b_cwd));
a314 1
		free(dp);
d335 3
a337 1
		if ((bp = dired_(fname)) == NULL)
a338 1
		undo_enable(FFRAND, x);
d342 1
a342 2
		dp = xdirname(fname);
		(void)strlcpy(bp->b_cwd, dp, sizeof(bp->b_cwd));
a343 1
		free(dp);
d660 2
a661 1
 * Same as dirname, except an empty string is returned in
d664 2
a665 1
 * Unlike dirname, we allocate. Caller must free.
d667 2
a668 2
static char *
xdirname(const char *path)
d670 24
a693 7
	char *dp;
	
	dp = dirname(path);
	if (*dp && dp[0] == '/' && dp[1] == '\0')
		return (strdup(""));
		
	return (strdup(dp));	
@


1.73
log
@augbname immediately does a basename. No need to do it in the
caller, too. ok lum@@
@
text
@d1 1
a1 1
/*	$OpenBSD: file.c,v 1.72 2010/06/26 16:18:44 kjell Exp $	*/
d9 2
a11 2

#include "def.h"
@


1.72
log
@From the Loganaden Velvindron:
 Make dired more sane (and emacslike):
 *  Position cursor at first filename after ..
 *  Don't reposition cursor on reopening
 *  Check for permission before attempting to open directory

I took forever to get this in. Thanks, Logan for being patient!
@
text
@d1 1
a1 1
/*	$OpenBSD: file.c,v 1.71 2009/06/04 23:39:37 kjell Exp $	*/
d519 1
a519 1
		if (augbname(bn, basename(curbp->b_fname), sizeof(bn))
@


1.71
log
@Add the notion of an "ephemeral" popup, so we can flag a window
for destruction at a later date. (in the process, add a window flag field)

This fixes an issue noted by maja: namely, the *completion*
window that pops up when you try to complete a filename on
buffer load would destroy any second window that you happened
to have open.

ok maja@@
@
text
@d1 1
a1 1
/*	$OpenBSD: file.c,v 1.70 2009/06/04 02:23:37 kjell Exp $	*/
d223 6
a228 4
			wp->w_dotp = wp->w_linep = bfirstlp(curbp);
			wp->w_doto = 0;
			wp->w_markp = NULL;
			wp->w_marko = 0;
@


1.70
log
@Rename w_flag to w_rflag. This is not a general purpose
flag: it is for redisplay options only. I need an additional all-purpose
flag, so renaming removes the desire to wrongly overload the existing one.

Turdshine. No functional chage.
@
text
@d1 1
a1 1
/*	$OpenBSD: file.c,v 1.69 2008/09/15 16:13:35 kjell Exp $	*/
d159 1
a159 1
	if ((wp = popbuf(bp)) == NULL)
@


1.69
log
@Expose the undo commands as proper mg functions.
This should have no functional change on undo, but it does facilitate
testing undo behavior.
@
text
@d1 1
a1 1
/*	$OpenBSD: file.c,v 1.68 2008/09/15 16:11:35 kjell Exp $	*/
d467 1
a467 1
			wp->w_flag |= WFMODE | WFEDIT;
d658 1
a658 1
			wp->w_flag |= WFMODE;
@


1.68
log
@Enable dirty buffer detection in mg.
Emulate the emacs behavior: after suspend/resume, buffer switch,
or at save time, warn (prompt) the user if the file has been modified
on disk in the interim.
This has already saved my butt numerous times.
ok phessler
@
text
@d1 1
a1 1
/*	$OpenBSD: file.c,v 1.67 2008/06/18 17:13:53 kjell Exp $	*/
d296 1
a296 1
		x = undo_enable(FALSE);
d338 1
a338 1
		undo_enable(x);
d354 1
a354 1
	x2 = undo_enable(FALSE);
d357 1
a357 1
	undo_enable(x2);
d480 1
a480 1
	undo_enable(x);
@


1.67
log
@Don't free the buffer name until after you call adjustname.
Fixes a segfault that occurs when you write a file to an alternate name.
Introduced by yours truly in 20060406. how did it last this long?
@
text
@d1 1
a1 1
/*	$OpenBSD: file.c,v 1.66 2008/06/13 18:45:41 kjell Exp $	*/
d215 1
a215 1
	curbp->b_flag &=~ BFREADONLY;
d569 8
d643 1
@


1.66
log
@Fix debian bug #432656
'Prints root directory as "//" instead of "/" for root files.'
Issue was with dirname, which strips the trailing slash, except
when given "/". Wrap it in a cover function to fix. Also helps
with portability to data-munging dirname glibc.
@
text
@d1 1
a1 1
/*	$OpenBSD: file.c,v 1.65 2008/03/21 08:01:20 pyr Exp $	*/
a516 1
		free(curbp->b_bname);
d520 1
@


1.65
log
@Reset startrow when opening multiple files. Spotted by matthieu@@
ok, kjell@@, matthieu@@
@
text
@d1 1
a1 1
/*	$OpenBSD: file.c,v 1.64 2006/12/24 01:20:53 kjell Exp $	*/
d13 2
d293 1
d312 2
a313 2
		(void)strlcpy(bp->b_cwd, dirname(newname),
		    sizeof(bp->b_cwd));
d315 1
d342 2
a343 1
		(void)strlcpy(bp->b_cwd, dirname(fname), sizeof(bp->b_cwd));
d345 1
d650 18
@


1.64
log
@Fix a bug where inserting a file resulted in an incorrect
line-number count for a buffer (M-X insert-file, M-> to reproduce).
While here, fix a number of bugs with incorrect line numbers
after swap point-and-mark

Originally reported via debian's bug tracking system. Fix tested by
Han Boetes and Deanna Phillips.
@
text
@d1 1
a1 1
/*	$OpenBSD: file.c,v 1.63 2006/11/17 08:45:31 kjell Exp $	*/
d251 1
a251 1
	if (startrow)
d253 2
@


1.63
log
@Fix a needless inversion of flag names; i.e. change them from the
negative to the positive. undo_boundary_enable(TRUE) makes a LOT more
sense than undo_no_boundary(FALSE).
While here, whack a global, and fix a bug noted by otto:
undoing a file insertion sometimes left stray characters around.
ok beck@@, otto@@
@
text
@d1 1
a1 1
/*	$OpenBSD: file.c,v 1.62 2006/07/25 08:27:09 kjell Exp $	*/
d340 6
a345 2

	/* Open a new line, at point, and start inserting after it. */
a346 1
	oline = curwp->w_dotline;
a348 5
	if (olp == curbp->b_headp) {
		/* if at end of buffer, create a line to insert before */
		(void)lnewline();
		curwp->w_dotp = lback(curwp->w_dotp);
	}
a350 1
	/* don't count fake lines at the end */
d354 1
a354 1
doneread:
a359 1
			/* the last line of the file */
d364 2
d374 2
a375 1
			if (s == FIOEOF)
d377 1
d401 1
a401 1
				goto doneread;
a409 2
	undo_add_insert(olp, opos, siz - 1);

d422 11
a432 1
	(void)ldelnewline();
@


1.62
log
@Add bfirstlp(), blastlp() macros, returning the first and last lines
of a buffer respectively. Removes an ugly construction than necessitated
"go to first line"-type comments throughout the code.
No binary change
@
text
@d1 1
a1 1
/*	$OpenBSD: file.c,v 1.61 2006/07/25 08:22:32 kjell Exp $	*/
d286 1
a286 1
	int	 nbytes, s, nline = 0, siz, x = -1, x2;
d292 2
@


1.61
log
@Rename the header line of a buffer to b_headp, from the remarkably
unintuitive b_linep. No binary change.
@
text
@d1 1
a1 1
/*	$OpenBSD: file.c,v 1.60 2006/07/08 17:56:10 kjell Exp $	*/
d221 1
a221 1
			wp->w_dotp = wp->w_linep = lforw(curbp->b_headp);
@


1.60
log
@Introduce a 'MODIFIED' boundary type for undo records.
This allows undo to clear the modified flag when undo-ing all the way
from a loaded buffer.
Originally whipped up at c2k6 after proddings from beck.
jason@@ ok.
@
text
@d1 1
a1 1
/*	$OpenBSD: file.c,v 1.59 2006/06/01 09:00:50 kjell Exp $	*/
d221 1
a221 1
			wp->w_dotp = wp->w_linep = lforw(curbp->b_linep);
d344 1
a344 1
	if (olp == curbp->b_linep) {
d426 1
a426 1
	if (olp == curbp->b_linep)
d439 1
a439 1
	lp1 = bp->b_linep;
@


1.59
log
@Display line number in the mg statusbar.  Yes, it seems like a fugly
way to do it, but all the clever and pretty ways utterly failed.
Basic use seems fine. We'll turdshine the special cases later.

If it bothers you, use M-x line-number-mode, or put same in your ~/.mg
file to disable.

ok cloder, jason
@
text
@d1 1
a1 1
/*	$OpenBSD: file.c,v 1.58 2006/06/01 05:34:52 jason Exp $	*/
d254 1
@


1.58
log
@make // /~ path rewriting optional in adjustname() and use it everywhere
except for the command line specified files.  ok kjell,cloder
@
text
@d1 1
a1 1
/*	$OpenBSD: file.c,v 1.57 2006/06/01 05:07:39 kjell Exp $	*/
d285 1
a285 1
	int	 nbytes, s, nline, siz, x = -1, x2;
d287 1
d338 1
a338 1
	/* open a new line, at point, and start inserting after it */
d340 1
a357 1
			++nline;
d361 1
d407 1
a407 1
	undo_add_insert(olp, opos, siz-1);
d424 1
d459 1
d571 1
a571 2
 * given, no backup files are made when saving a new version of a file. Only
 * used when BACKUP is #defined.
@


1.57
log
@Initialize current window, and clear the readonly flag earlier in file
read process.  This allows code in the autoexec path (i.e. ~/.mg) to
operate on the buffer, making ~/.mg files much more useful.
@
text
@d1 1
a1 1
/*	$OpenBSD: file.c,v 1.56 2006/06/01 01:41:49 kjell Exp $	*/
d31 1
a31 1
	adjf = adjustname(bufp);
d59 1
a59 1
	adjf = adjustname(fname);
d102 1
a102 1
	adjf = adjustname(fname);
d150 1
a150 1
	adjf = adjustname(fname);
d485 1
a485 1
	adjfname = adjustname(fname);
@


1.56
log
@find-file-other-window and find-buffer-other-window should split
the window if you ask for whatever file you are currently visiting.
pointed out, ok beck@@
@
text
@d1 1
a1 1
/*	$OpenBSD: file.c,v 1.55 2006/05/28 23:30:16 kjell Exp $	*/
d212 2
d219 9
a238 8
	for (wp = wheadp; wp != NULL; wp = wp->w_wndp) {
		if (wp->w_bufp == curbp) {
			wp->w_dotp = wp->w_linep = lforw(curbp->b_linep);
			wp->w_doto = 0;
			wp->w_markp = NULL;
			wp->w_marko = 0;
		}
	}
a249 2
	else
		curbp->b_flag &=~ BFREADONLY;
@


1.55
log
@Make Window Flags more mnemonic (and less dumb); i.e.
WFHARD -> WFFULL (Redraw full window)
WFFORCE -> WFFRAME (Reframe window).
No binary change
@
text
@d1 1
a1 1
/*	$OpenBSD: file.c,v 1.54 2006/05/02 17:10:25 kjell Exp $	*/
d155 2
@


1.54
log
@Make buffers store their own working directory. This makes things like
grep, compile, lint work as expected (act on current buffer's cwd).
Display this path when opening or replacing a file, rather than
relying on the user to guess, or remember.
@
text
@d1 1
a1 1
/*	$OpenBSD: file.c,v 1.53 2006/04/06 05:28:17 kjell Exp $	*/
d65 1
a65 1
	if (showbuffer(bp, curwp, WFHARD) != TRUE)
d108 1
a108 1
	if (showbuffer(bp, curwp, WFHARD) != TRUE)
d327 1
a327 1
		return (showbuffer(bp, curwp, WFHARD | WFMODE));
@


1.53
log
@Fix a bug whereby a written buffer (^X^W) would not have the correct
trailing buffer number appended (e.g. "file<2>") in case an existing
buffer shared its basename().
@
text
@d1 1
a1 1
/*	$OpenBSD: file.c,v 1.52 2006/04/03 05:03:34 deraadt Exp $	*/
d9 2
a12 2
#include <libgen.h>

d23 4
a26 1
	bufp = eread("Insert file: ", fname, NFILEN, EFNEW | EFCR | EFFILE);
d48 1
a48 1
	char	 fname[NFILEN], *bufp, *adjf, *slash;
d51 1
a51 8
	if (curbp->b_fname && curbp->b_fname[0] != '\0') {
		if (strlcpy(fname, curbp->b_fname, sizeof(fname)) >= sizeof(fname))
			return (FALSE);
		if ((slash = strrchr(fname, '/')) != NULL) {
			*(slash + 1) = '\0';
		}
	}
	else
a52 1

d86 1
a86 1
	char	 fname[NFILEN], *bufp, *adjf, *slash;
d89 1
a89 7
	if (curbp->b_fname && curbp->b_fname[0] != '\0') {
		if (strlcpy(fname, curbp->b_fname, sizeof(fname)) >= sizeof(fname))
			return (FALSE);
		if ((slash = strrchr(fname, '/')) != NULL) {
			*(slash + 1) = '\0';
		}
	} else
a90 1

d143 2
d146 1
a146 1
	    EFNEW | EFCR | EFFILE)) == NULL)
d187 1
a187 1
	if (baugname(bname, fname, sizeof(bname)) == FALSE)
d298 6
a303 2
	if (newname != NULL)
		(void)strlcpy(bp->b_fname, newname, sizeof bp->b_fname);
d328 3
d474 2
d477 1
a477 1
	    EFNEW | EFCR | EFFILE)) == NULL)
d489 2
d492 1
a492 1
		if (baugname(bn, basename(curbp->b_fname), sizeof(bn))
@


1.52
log
@few more int that can become a size_t
@
text
@d1 1
a1 1
/*	$OpenBSD: file.c,v 1.51 2006/04/03 00:40:56 deraadt Exp $	*/
a185 2
	unsigned int	count;
	size_t		i, remain;
d196 2
a197 2
	i = strlcpy(bname, basename(fname), sizeof(bname));
	if (i >= sizeof(bname))
a198 3
	remain = sizeof(bname) - i;
	for (count = 2; bfind(bname, FALSE) != NULL; count++)
		snprintf(&bname[i], remain, "<%d>", count);
d200 2
a201 1
	return (bfind(bname, TRUE));
d474 2
a475 2
	char	 fname[NFILEN];
	char	*adjfname, *p, *bufp;
d489 1
a489 6
		(void)strlcpy(curbp->b_fname, adjfname, sizeof curbp->b_fname);
		p = strrchr(curbp->b_fname, '/');
		if (p)
			p++;
		else
			p = curbp->b_fname;
d491 5
a495 1
		curbp->b_bname = strdup(p);
@


1.51
log
@lint love; ok kjell
@
text
@d1 1
a1 1
/*	$OpenBSD: file.c,v 1.50 2005/12/20 06:17:36 kjell Exp $	*/
d184 4
a187 3
	struct buffer		*bp;
	char		 bname[NBUFN], fname[NBUFN];
	unsigned int	 count, remain, i;
@


1.50
log
@Clean up the ugly casted frees. In one case, this meant eliminating a nasty
struct/union/casting nightmare when building the list of names for filename
completion. In particular, be consistent about strduping and freeing
the list data.
@
text
@d1 1
a1 1
/*	$OpenBSD: file.c,v 1.49 2005/12/20 05:04:28 kjell Exp $	*/
d384 1
a384 1
				    (cp = malloc((unsigned)newsize)) == NULL) {
@


1.49
log
@Do some delinting of strl-type functions. Also, remove a superfluous
word in the undo-list.
@
text
@d1 1
a1 1
/*	$OpenBSD: file.c,v 1.48 2005/12/13 06:01:27 kjell Exp $	*/
d498 1
a498 2
		if (curbp->b_bname)
			free((char *)curbp->b_bname);
@


1.48
log
@More name-clash delinting
@
text
@d1 1
a1 1
/*	$OpenBSD: file.c,v 1.47 2005/11/20 04:16:34 kjell Exp $	*/
d49 2
a50 1
		strlcpy(fname, curbp->b_fname, sizeof(fname));
d95 2
a96 1
		strlcpy(fname, curbp->b_fname, sizeof(fname));
@


1.47
log
@Kill the NO_BACKUP #ifdef
@
text
@d1 1
a1 1
/*	$OpenBSD: file.c,v 1.46 2005/11/20 03:24:17 deraadt Exp $	*/
d358 1
a358 1
			/* and continue */
@


1.46
log
@toast NO_DIRED #ifdef; ok kjell
@
text
@d1 1
a1 1
/*	$OpenBSD: file.c,v 1.45 2005/11/18 20:56:52 deraadt Exp $	*/
d276 5
a280 6
 * point at the beginning.  Return a standard status.
 * Print a summary (lines read, error message) out as well.  Unless the
 * NO_BACKUP conditional is set, this routine also does the read end of
 * backup processing.  The BFBAK flag, if set in a buffer, says that a
 * backup should be taken.  It is set when a file is read in, but not on
 * a new file.  (You don't need to make a backup copy of nothing.)
d282 1
a424 1
#ifndef NO_BACKUP
a428 3
#else /* !NO_BACKUP */
	bp->b_flag |= BFCHG;
#endif /* !NO_BACKUP */
a498 1
#ifndef NO_BACKUP
a499 3
#else /* !NO_BACKUP */
		curbp->b_flag &= ~BFCHG;
#endif /* !NO_BACKUP */
a507 1
#ifndef NO_BACKUP
a511 1
#endif /* !NO_BACKUP */
a544 1
#ifndef NO_BACKUP
a554 1
#endif /* !NO_BACKUP */
a555 1
#ifndef NO_BACKUP
a556 3
#else /* !NO_BACKUP */
		bp->b_flag &= ~BFCHG;
#endif /* !NO_BACKUP */
a561 1
#ifndef NO_BACKUP
a579 1
#endif /* !NO_BACKUP */
@


1.45
log
@greedy use of typedef struct was making code harder to read; ok kjell cloder
@
text
@d1 1
a1 1
/*	$OpenBSD: file.c,v 1.44 2005/11/13 07:24:48 kjell Exp $	*/
a251 1
#ifndef NO_DIRED
a253 1
#endif
a321 1
#ifndef NO_DIRED
a334 1
#endif /* !NO_DIRED */
@


1.44
log
@Copy buffer before handing it to basename().
Inspired by a patch from Han Boetes.
@
text
@d1 1
a1 1
/*	$OpenBSD: file.c,v 1.43 2005/10/14 19:46:46 kjell Exp $	*/
d44 1
a44 1
	BUFFER	*bp;
d89 1
a89 1
	BUFFER	*bp;
d148 2
a149 2
	BUFFER	*bp;
	MGWIN	*wp;
d179 1
a179 1
BUFFER *
d182 1
a182 1
	BUFFER		*bp;
d214 1
a214 1
	MGWIN	*wp;
d291 4
a294 4
	BUFFER	*bp;
	LINE	*lp1, *lp2;
	LINE	*olp;			/* line we started at */
	MGWIN	*wp;
d543 1
a543 1
buffsave(BUFFER *bp)
d618 1
a618 1
writeout(BUFFER *bp, char *fn)
d642 1
a642 1
upmodes(BUFFER *bp)
d644 1
a644 1
	MGWIN	*wp;
@


1.43
log
@add missing /* ARGSUSED */ to quiet lint.
@
text
@d1 1
a1 1
/*	$OpenBSD: file.c,v 1.42 2005/10/13 20:28:49 deraadt Exp $	*/
d180 1
a180 1
findbuffer(char *fname)
d183 1
a183 1
	char		 bname[NBUFN];
d186 5
d197 1
a197 1
		return NULL;
@


1.42
log
@spacing
@
text
@d1 1
a1 1
/*	$OpenBSD: file.c,v 1.41 2005/10/13 20:23:01 kjell Exp $	*/
d85 1
@


1.41
log
@Make dired buffer read-only by default.
Noticed by Han Boetes
@
text
@d1 1
a1 1
/*	$OpenBSD: file.c,v 1.40 2005/10/13 19:46:45 kjell Exp $	*/
d191 1
a191 1
		return NULL;  
@


1.40
log
@Use dired mode automatically if file specified for loading is
a directory. Modified version of patch from Han Boetes.
ok cloder@@
@
text
@d1 1
a1 1
/*	$OpenBSD: file.c,v 1.39 2005/10/13 05:34:11 kjell Exp $	*/
d9 2
a11 1
#include "def.h"
d209 1
a209 1
	int	 status, i;
d240 4
a243 1
	/* We need to set the READONLY flag after we insert the file. */
d245 6
@


1.39
log
@KNF and minor cleanup. Remove an impossible condition check.
Also, remove annoying "now readonly" message, as this information
is already reflected in the statusbar
@
text
@d1 1
a1 1
/*	$OpenBSD: file.c,v 1.38 2005/08/09 00:53:48 kjell Exp $	*/
d308 15
d449 1
@


1.38
log
@Clean up eread handling in mg. (basically, fallout from the 'enter often
means abort' behaviour added during the hackathon). Eliminates
redundant ereply function, fixes miscellaneous cores when aborting,
and move a number of assumed pathnames into the prompt text, since
they are used there anyway. All changes consistent with emacs behavior

ok beck@@ many, many moons ago.
@
text
@d1 1
a1 1
/*	$OpenBSD: file.c,v 1.37 2005/06/14 18:14:40 kjell Exp $	*/
d45 1
d70 1
a70 3
	if (bp->b_fname[0] == 0) {
		int status;

d149 1
d165 1
a165 3
	if (bp->b_fname[0] == 0) {
		int status;

d259 4
a262 2
 * Insert a file in the current buffer, after dot.  Set mark at the end of
 * the text inserted; point at the beginning.  Return a standard status.
d273 1
a273 1
insertfile(char *fname, char *newname, int needinfo)
d282 1
a282 1
	if (needinfo)
d299 1
a299 1
	if ((s = ffropen(fname, needinfo ? bp : NULL)) == FIOERR)
d434 1
a434 2
	if (x != -1)
		undo_enable(x);
d436 1
a436 1
	/* return false if error */
@


1.37
log
@Add explicit public domain notices to all public domain files.
ok millert@@, deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: file.c,v 1.36 2005/06/03 08:23:12 kjell Exp $	*/
d55 2
a56 1
	bufp = eread("Find file: ", fname, NFILEN, EFNEW | EFCR | EFFILE | EFDEF);
@


1.36
log
@Clean up find-alternate-file (C-x C-v) so abort returns to original
file, like its emacs ancestor.

ok cloder@@
@
text
@d1 3
a3 1
/*	$OpenBSD: file.c,v 1.35 2005/05/30 13:13:50 jason Exp $	*/
@


1.35
log
@add find-alternate-file command and binding for ^X^V; ok cloder
(you're welcome kjell)
@
text
@d1 1
a1 1
/*	$OpenBSD: file.c,v 1.34 2005/05/27 08:52:30 cloder Exp $	*/
d76 6
d85 15
a99 1
	if (killbuffer(curbp) == ABORT)
d101 21
a121 1
	return (filevisit(f, n));
@


1.34
log
@In find file, behave like emacs: the default starting directory for
completion is the directory of the current buffer's file, if any,
rather than the working directory from where you launched mg.
Prodding by reyk, ok reyk and fgont
@
text
@d1 1
a1 1
/*	$OpenBSD: file.c,v 1.33 2005/04/21 19:16:21 beck Exp $	*/
d74 8
@


1.33
log
@correct strlcpy abuse, and always check for NULL return from find_buffer
ok cloder@@, feedback from many
@
text
@d1 1
a1 1
/*	$OpenBSD: file.c,v 1.32 2005/04/03 02:09:28 db Exp $	*/
d42 10
a51 1
	char	 fname[NFILEN], *bufp, *adjf;
d53 1
a53 1
	bufp = eread("Find file: ", fname, NFILEN, EFNEW | EFCR | EFFILE);
@


1.32
log
@This is a no binary change which does:

- spelling, punctuation fixes
- variable declaration lineup
- use parentheses for return and sizeof
- K&R function declarations -> ANSI
- other minor code beautification

ok henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: file.c,v 1.31 2005/03/10 18:27:47 henning Exp $	*/
d131 2
@


1.31
log
@fix more BACKUP/NOBACKUP/NO_BACKUP confusion, again no binary change.
spotted by jmc@@
@
text
@d1 1
a1 1
/*	$OpenBSD: file.c,v 1.30 2005/03/09 16:20:48 jfb Exp $	*/
d22 1
a22 1
		return ABORT;
d24 1
a24 1
		return FALSE;
d28 1
a28 1
	return insertfile(adjf, NULL, FALSE);
d46 1
a46 1
		return ABORT;
d48 1
a48 1
		return FALSE;
d53 1
a53 1
		return FALSE;
d56 1
a56 1
		return FALSE;
d62 1
a62 1
		return status;
d64 1
a64 1
	return TRUE;
d78 1
d93 1
a93 1
		return ABORT;
d95 1
a95 1
		return FALSE;
d100 1
a100 1
		return FALSE;
d102 1
a102 1
		return FALSE;
d110 1
a110 1
		return status;
d112 1
a112 1
	return TRUE;
d116 1
a116 1
 * given a file name, either find the buffer it uses, or create a new
d128 1
a128 1
			return bp;
d135 1
a135 1
	return bfind(bname, TRUE);
d153 1
a153 1
		return TRUE;
d156 1
a156 1
		return FALSE;
d179 1
a179 1
	/* We need to set the READONLY flag after we insert the file */
d188 1
a188 1
	return status;
d202 1
a202 1
 * NO_BACKUP conditional is set, this routine also does the read end of 
d345 1
a345 1
	 * if the insert was at the end of buffer, set lp1 to the end of
d376 1
a376 1
	return s != FIOERR;
d395 1
a395 1
		return ABORT;
d397 1
a397 1
		return FALSE;
d421 1
a421 1
	return s;
d438 1
a438 1
	return buffsave(curbp);
d457 1
a457 1
		return TRUE;
d471 1
a471 1
			return FALSE;
d475 1
a475 1
			return s;
d486 1
a486 1
	return s;
d506 1
a506 1
	return TRUE;
d541 1
a541 1
	return s == FIOSUC;
@


1.30
log
@fix mg's behaviour with regards to files on which we do not have
write access.  diff originally from vincent@@ and forgotten for
a while.

ok rohee@@, "toss it in, i'll bitch if it doesn't work" henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: file.c,v 1.29 2004/07/22 01:25:25 vincent Exp $	*/
d200 5
a204 5
 * Print a summary (lines read, error message) out as well.  If the BACKUP
 * conditional is set, then this routine also does the read end of backup
 * processing.  The BFBAK flag, if set in a buffer, says that a backup
 * should be taken.  It is set when a file is read in, but not on a new
 * file.  (You don't need to make a backup copy of nothing.)
@


1.29
log
@stage 1 of the infinite minibuffer work - add support for on the fly
buffer reallocation in veread().  This commit only changes the API.
All the buffers have exactly the same bounds as before for now.

tested by a couple of my very helpful testers!
@
text
@d1 1
a1 1
/*	$OpenBSD: file.c,v 1.28 2003/11/09 00:19:02 vincent Exp $	*/
d57 7
a63 2
	if (bp->b_fname[0] == 0)
		return readin(adjf);
d104 7
a110 2
	if (bp->b_fname[0] == 0)
		return readin(adjf);
d153 4
a156 1
	status = insertfile(fname, fname, TRUE);
@


1.28
log
@fix the undo record size for insert-file so we do not get an extra byte
@
text
@d1 1
a1 1
/*	$OpenBSD: file.c,v 1.27 2003/11/08 19:17:29 jmc Exp $	*/
d18 1
a18 2
	int	 s;
	char	 fname[NFILEN], *adjf;
d20 6
a25 4
	s = eread("Insert file: ", fname, NFILEN, EFNEW | EFCR | EFFILE);
	if (s != TRUE)
		return (s);
	adjf = adjustname(fname);
d42 1
a42 3
	int	 s;
	char	 fname[NFILEN];
	char	*adjf;
d44 5
a48 3
	s = eread("Find file: ", fname, NFILEN, EFNEW | EFCR | EFFILE);
	if (s != TRUE)
		return s;
d83 1
a83 3
	int	 s;
	char	 fname[NFILEN];
	char	*adjf;
d85 5
a89 3
	if ((s = eread("Find file in other window: ", fname, NFILEN,
	    EFNEW | EFCR | EFFILE)) != TRUE)
		return s;
d377 7
a383 1
	char	*adjfname, *p;
a384 3
	if ((s = eread("Write file: ", fname, NFILEN,
	    EFNEW | EFCR | EFFILE)) != TRUE)
		return (s);
@


1.27
log
@typos from Jonathon Gray;
@
text
@d1 1
a1 1
/*	$OpenBSD: file.c,v 1.26 2003/10/13 02:29:29 vincent Exp $	*/
d302 1
a302 1
	undo_add_insert(olp, opos, siz);
@


1.26
log
@remember the new filename on ^X^W

ok deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: file.c,v 1.25 2003/08/16 00:24:51 deraadt Exp $	*/
d368 1
a368 1
 * is more compatable with Gosling EMACS than with ITS EMACS.
@


1.25
log
@spacing
@
text
@d1 1
a1 1
/*	$OpenBSD: file.c,v 1.24 2003/01/06 17:04:09 deraadt Exp $	*/
d376 1
a376 1
	char	*adjfname;
d388 8
@


1.24
log
@support +number; rewritten from buggy code by mjc@@bitz.ca, vincent ok
@
text
@d1 1
a1 1
/*	$OpenBSD: file.c,v 1.23 2002/09/15 22:18:40 vincent Exp $	*/
d169 1
a169 1
	
@


1.23
log
@don't add undo records when we open a file, only when we insert it.

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: file.c,v 1.22 2002/07/25 16:37:54 vincent Exp $	*/
d169 3
@


1.22
log
@ replace the ugly and buggy adjustname function by a simple one using
simple APIs. makes mg not crash with 65k filenames...

 ok art@@
@
text
@d1 1
a1 1
/*	$OpenBSD: file.c,v 1.21 2002/07/03 03:47:59 vincent Exp $	*/
d199 1
a199 1
	int	 nbytes, s, nline, siz;
d202 3
d232 1
d240 1
d354 3
@


1.21
log
@ a few missing tests for malloc()'s return value.

 ok art@@
@
text
@d1 1
a1 1
/*	$OpenBSD: file.c,v 1.20 2002/07/01 14:33:44 vincent Exp $	*/
d19 1
a19 1
	char	 fname[NFILEN];
d24 4
a27 2
	return insertfile(adjustname(fname), NULL, FALSE);
	/* don't set buffer name */
d49 2
d90 2
d371 2
@


1.20
log
@KNF + ansi; from zyrnix (only the easy part of his diffs)
@
text
@d1 1
a1 1
/*	$OpenBSD: file.c,v 1.19 2002/06/19 22:02:08 vincent Exp $	*/
d199 2
@


1.19
log
@add an undo insert record on insert-file.  this makes insert-file undoable.

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: file.c,v 1.18 2002/05/29 12:41:42 vincent Exp $	*/
d106 1
a106 1
	unsigned int count, remain, i;
d131 1
a131 1
	PF	 *ael;
d187 1
a187 3
insertfile(fname, newname, needinfo)
	char *fname, *newname;
	int   needinfo;
d221 1
a221 1
	lnewline();
d353 1
a353 2
filewrite(f, n)
	int f, n;
d389 1
a389 2
filesave(f, n)
	int f, n;
d403 1
a403 2
buffsave(bp)
	BUFFER *bp;
d452 1
a452 2
makebkfile(f, n)
	int f, n;
d478 1
a478 3
writeout(bp, fn)
	BUFFER *bp;
	char   *fn;
d502 1
a502 2
upmodes(bp)
	BUFFER *bp;
@


1.18
log
@ add an "auto-execute" feature, that allows binding function calls to
certain patterns. for example, `auto-execute "*.c" auto-indent-mode'.

 ok art@@
@
text
@d1 1
a1 1
/*	$OpenBSD: file.c,v 1.17 2002/05/29 12:32:51 vincent Exp $	*/
d124 1
a124 1
 * (for "uemacs file").
d127 1
a127 2
readin(fname)
	char *fname;
a163 1

d195 2
a196 2
	int	 nbytes, s, nline;
	int	 opos;			/* and offset into it */
a198 1

d223 1
a223 1
	(void)lnewline();
d233 1
d236 1
d257 1
a257 1
		case FIOLONG:{
d288 2
@


1.17
log
@ add a function to visit a file read-only mapped to C-x C-v

 ok art@@
@
text
@d1 1
a1 1
/*	$OpenBSD: file.c,v 1.16 2002/03/16 04:17:36 vincent Exp $	*/
d131 2
a132 1
	int	 status;
d138 9
@


1.16
log
@ add readonly buffer support
 plus some KNF

 ok art@@
@
text
@d1 1
a1 1
/*	$OpenBSD: file.c,v 1.15 2002/03/11 13:02:56 vincent Exp $	*/
d57 11
@


1.15
log
@  * Move to ANSI function definitions.
  * Add a whole lot of consts where I thought it made sense

   no ok, but no objections either...
@
text
@d1 1
a1 1
/*	$OpenBSD: file.c,v 1.14 2002/02/19 12:58:42 vincent Exp $	*/
d137 8
@


1.14
log
@
 Make multiple buffers with the same basename work correctly.. (like GNU
 emacs) and unbreak a stupid loop at the same time.

 ok art@@
@
text
@d1 1
a1 1
/*	$OpenBSD: file.c,v 1.13 2002/02/14 14:24:21 deraadt Exp $	*/
d16 1
a16 2
fileinsert(f, n)
	int f, n;
d36 1
a36 2
filevisit(f, n)
	int f, n;
d63 1
a63 2
poptofile(f, n)
	int f, n;
@


1.13
log
@some KNF
@
text
@d1 1
a1 1
/*	$OpenBSD: file.c,v 1.12 2002/02/13 22:50:40 vincent Exp $	*/
d94 1
a94 2
findbuffer(fname)
	char *fname;
d98 1
a98 1
	unsigned int	 count;
d104 4
a107 7
	/* new buffer name */
	for (count = 1; bfind(bname, FALSE) != NULL; count++)
		;
	if (count == 1)
		snprintf(bname, sizeof bname, "%s", basename(fname));
	else
		snprintf(bname, sizeof bname, "%s<%d>", basename(fname), count);
@


1.12
log
@ Oups, don't print fname<1> when there's only one buffer for this file.
@
text
@d1 1
a1 1
/*	$OpenBSD: file.c,v 1.11 2002/02/13 22:36:58 vincent Exp $	*/
d75 1
a75 1
		       EFNEW | EFCR | EFFILE)) != TRUE)
d340 1
a340 1
		       EFNEW | EFCR | EFFILE)) != TRUE)
@


1.11
log
@ Make mg malloc the l_text element instead of reallocating whole LINE
 structures all the time.
@
text
@d1 1
a1 1
/*	$OpenBSD: file.c,v 1.10 2002/02/13 03:03:49 vincent Exp $	*/
d108 4
a111 1
	snprintf(bname, sizeof bname, "%s<%d>", basename(fname), count);
@


1.10
log
@ * Replace unsafe strcpy and strcat calls to safe strlcpy and strlcat.
 * Be a little bit more verbose about some errors
 * Fix some memory leaks in fileio.c

ok deraadt@@, art@@
@
text
@d1 1
a1 1
/*	$OpenBSD: file.c,v 1.9 2001/05/24 03:05:22 mickey Exp $	*/
d99 1
a99 1
	unsigned int	 count = 1;
@


1.9
log
@spaces
@
text
@d1 1
a1 1
/*	$OpenBSD: file.c,v 1.8 2001/05/23 22:36:14 art Exp $	*/
d98 1
a98 1
	char		 bname[NBUFN], *cp;
a105 2
	strcpy(bname, basename(fname));
	cp = bname + strlen(bname);
d107 3
a109 1
		sprintf(cp, "<%d>", count);
d185 1
a185 1
		(void)strcpy(bp->b_fname, newname);
d343 1
a343 1
		(void)strcpy(curbp->b_fname, adjfname);
@


1.8
log
@Get rid of unnecessary casts of NULL.
@
text
@d1 1
a1 1
/*	$OpenBSD: file.c,v 1.7 2001/05/23 22:20:35 art Exp $	*/
d30 1
a30 1
 * Select a file for editing.  Look around to see if you can find the file 
d32 1
a32 1
 * you cannot find the file, create a new buffer, read in the text, and 
d114 3
a116 3
 * Read the file "fname" into the current buffer.  Make all of the text 
 * in the buffer go away, after checking for unsaved changes.  This is 
 * called by the "read" command, the "visit" command, and the mainline 
d152 6
a157 6
 * Insert a file in the current buffer, after dot.  Set mark at the end of 
 * the text inserted; point at the beginning.  Return a standard status. 
 * Print a summary (lines read, error message) out as well.  If the BACKUP 
 * conditional is set, then this routine also does the read end of backup 
 * processing.  The BFBAK flag, if set in a buffer, says that a backup 
 * should be taken.  It is set when a file is read in, but not on a new 
d160 2
a161 2
static char    *line = NULL;
static int      linesize = 0;
d235 2
a236 2
				char           *cp;
				int             newsize;
d249 1
a249 1
				s = ffgetline(line + linesize, linesize, 
d322 2
a323 2
 * Ask for a file name and write the contents of the current buffer to that 
 * file.  Update the remembered file name and clear the buffer changed flag. 
d361 1
a361 1
static int      makebackup = MAKEBACKUP;
d373 3
a375 3
 * Save the contents of the buffer argument into its associated file.  Do 
 * nothing if there have been no changes (is this a bug, or a feature?). 
 * Error if there is no remembered file name. If this is the first write 
d377 1
a377 1
 * Allow user to select whether or not to make backup files by looking at 
d405 1
a405 1
		if (s == FALSE && 
d453 2
a454 2
 * This function performs the details of file writing; writing the file 
 * in buffer bp to file fn. Uses the file management routines in the 
@


1.7
log
@remove VOID. We're way beyond the point where this could build with an
ancient compiler.
@
text
@d1 1
a1 1
/*	$OpenBSD: file.c,v 1.6 2001/05/04 22:00:35 art Exp $	*/
d25 1
a25 1
	return insertfile(adjustname(fname), (char *)NULL, FALSE);
d184 1
a184 1
	if (newname != (char *)NULL)
d188 1
a188 1
	if ((s = ffropen(fname, needinfo ? bp : (BUFFER *) NULL)) == FIOERR)
d265 1
a265 1
	(void)ffclose((BUFFER *)NULL);
@


1.6
log
@Cleanups in filename and buffer name handling.
Mostly just using libc instead of rolling our own.
@
text
@d1 1
a1 1
/*	$OpenBSD: file.c,v 1.5 2001/01/29 01:58:07 niklas Exp $	*/
d185 1
a185 1
		(VOID)strcpy(bp->b_fname, newname);
d201 1
a201 1
	(VOID)lnewline();
d205 1
a205 1
		(VOID)lnewline();
d265 1
a265 1
	(VOID)ffclose((BUFFER *)NULL);
d276 1
a276 1
	(VOID)ldelnewline();
d301 1
a301 1
		(VOID)ldelnewline();
d343 1
a343 1
		(VOID)strcpy(curbp->b_fname, adjfname);
d475 1
a475 1
		(VOID)ffclose(bp);
d483 1
a483 1
VOID
@


1.5
log
@$OpenBSD$
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d7 1
a9 2
static char	*itos	__P((char *, unsigned int));

d102 1
a102 1
		if (fncmp(bp->b_fname, fname) == 0)
d106 1
a106 1
	makename(bname, fname);
d108 2
a109 5
	while (bfind(bname, FALSE) != NULL) {
		/* add "<count>" to the name */
		*cp = '<';
		(VOID)strcpy(itos(cp, ++count) + 1, ">");
	}
a113 17
 * Put the decimal representation of num into a buffer.  Hacked to be
 * faster, smaller, and less general.
 */
static char *
itos(bufp, num)
	char		*bufp;
	unsigned int	 num;
{
	if (num >= 10) {
		bufp = itos(bufp, num / 10);
		num %= 10;
	}
	*++bufp = '0' + num;
	return bufp;
}

/*
a318 38
}

/*
 * Fabriacte a buffer name from a given filename.  This routing knows
 * about the syntax of file names on the target system.
 * BDC1		left scan delimiter.
 * BDC2		optional second left scan delimiter.
 * BDC3		optional right scan delimiter.
 */
VOID
makename(bname, fname)
	char *bname, *fname;
{
	char *cp1, *cp2;

	cp1 = &fname[0];
	while (*cp1 != 0)
		++cp1;

	/* insure at least 1 character */
	--cp1;
#ifdef BDC2
	while (cp1 != &fname[0] && cp1[-1] != BDC1 && cp1[-1] != BDC2)
		--cp1;
#else /* BDC2 */
	while (cp1 != &fname[0] && cp1[-1] != BDC1)
		--cp1;
#endif /* BDC2 */
	cp2 = &bname[0];

#ifdef BDC3
	while (cp2 != &bname[NBUFN - 1] && *cp1 != 0 && *cp1 != BDC3)
		*cp2++ = *cp1++;
#else /* BDC3 */
	while (cp2 != &bname[NBUFN - 1] && *cp1 != 0)
		*cp2++ = *cp1++;
#endif /* BDC3 */
	*cp2 = 0;
@


1.4
log
@More -Wall anmd KNF, from op2@@tomahawk.SQUiSH.org
@
text
@d1 2
@


1.3
log
@The start of KNF + -Wall.  The code has been run through indent but
needs hand fixup.  I stopped at keymap.c...
@
text
@d2 1
a2 1
 *		File commands.
a3 1
#include	"def.h"
d5 3
a7 1
static char *itos	__P((char *, unsigned int));
d10 1
a10 1
 * insert a file into the current buffer. Real easy - just call the
d16 1
a16 1
	int    f, n;
d18 2
a19 2
	int    s;
	char   fname[NFILEN];
d24 1
a24 1
	return insertfile(adjustname(fname), (char *) NULL, FALSE);
d29 4
a32 6
 * Select a file for editing.
 * Look around to see if you can find the
 * fine in another buffer; if you can find it
 * just switch to the buffer. If you cannot find
 * the file, create a new buffer, read in the
 * text, and switch to the new buffer.
d37 1
a37 1
	int     f, n;
d39 4
a42 4
	BUFFER *bp;
	int     s;
	char    fname[NFILEN];
	char   *adjf;
d54 1
a54 1
		return readin(adjf);	/* Read it in.		 */
d59 1
a59 1
 * Pop to a file in the other window. Same as last function, just
d65 1
a65 1
	int     f, n;
d67 5
a71 5
	BUFFER *bp;
	MGWIN  *wp;
	int     s;
	char    fname[NFILEN];
	char   *adjf;
d84 1
a84 1
		return readin(adjf);	/* Read it in.		 */
d94 1
a94 1
	char           *fname;
d96 3
a98 3
	BUFFER         *bp;
	char            bname[NBUFN], *cp;
	unsigned int    count = 1;
d104 2
a105 1
	makename(bname, fname);	/* New buffer name.	 */
d108 3
a110 2
		*cp = '<';	/* add "<count>" to then name	 */
		(VOID) strcpy(itos(cp, ++count) + 1, ">");
d121 2
a122 2
	char           *bufp;
	unsigned int    num;
a123 1

d133 4
a136 4
 * Read the file "fname" into the current buffer.
 * Make all of the text in the buffer go away, after checking
 * for unsaved changes. This is called by the "read" command, the
 * "visit" command, and the mainline (for "uemacs file").
d140 1
a140 1
	char  *fname;
d142 2
a143 2
	int    status;
	MGWIN *wp;
d145 2
a146 1
	if (bclear(curbp) != TRUE)	/* Might be old.	 */
d149 3
a151 1
	curbp->b_flag &= ~BFCHG;/* No change.		 */
d162 1
d171 7
a177 9
 * insert a file in the current buffer, after dot. Set mark
 * at the end of the text inserted, point at the beginning.
 * Return a standard status. Print a summary (lines read,
 * error message) out as well. If the
 * BACKUP conditional is set, then this routine also does the read
 * end of backup processing. The BFBAK flag, if set in a buffer,
 * says that a backup should be taken. It is set when a file is
 * read in, but not on a new file (you don't need to make a backup
 * copy of nothing).
d184 2
a185 2
	char   *fname, *newname;
	int     needinfo;
d187 8
a194 8
	LINE   *lp1;
	LINE   *lp2;
	MGWIN  *wp;
	int     nbytes;
	LINE   *olp;	/* Line we started at */
	int     opos;	/* and offset into it */
	int     s, nline;
	BUFFER *bp;
d200 7
a206 4
	bp = curbp;		/* Cheap.		 */
	if (newname != (char *) NULL)
		(VOID) strcpy(bp->b_fname, newname);
	/* Hard file open.	 */
d209 2
a210 1
	if (s == FIOFNF) {	/* File not found.	 */
d218 3
a220 2
	/* Open a new line, at point, and start inserting after it */
	(VOID) lnewline();
d224 1
a224 1
		(VOID) lnewline();
d227 3
a229 1
	nline = 0;		/* Don't count fake line at end */
d236 2
a237 1
		case FIOEOF:	/* the last line of the file		 */
d239 3
a241 2
				s = FIOERR;	/* Keep message on the	 */
				goto endoffile;	/* display.		 */
d252 2
a253 1
		case FIOLONG:{	/* a line too long to fit in our buffer	 */
d259 1
a259 1
				(cp = malloc((unsigned) newsize)) == NULL) {
d261 3
a263 3
						 newsize);
					s = FIOERR;
					goto endoffile;
d268 2
a269 1
				s = ffgetline(line + linesize, linesize, &nbytes);
d283 4
a286 2
	(VOID) ffclose((BUFFER *) NULL);	/* Ignore errors.	 */
	if (s == FIOEOF) {	/* Don't zap an error.	 */
d292 1
a292 1
	/* Set mark at the end of the text */
d295 1
a295 1
	(VOID) ldelnewline();
d305 1
a305 1
#else
d307 1
a307 1
#endif
d319 2
a320 1
		(VOID) ldelnewline();	/* delete extranious newline */
d336 2
a337 1
	return s != FIOERR;	/* False if error.	 */
d341 1
a341 2
 * Take a file name, and from it
 * fabricate a buffer name. This routine knows
d349 1
a349 2
	char  *bname;
	char  *fname;
d351 1
a351 2
	char  *cp1;
	char  *cp2;
d356 4
a359 2
	--cp1;			/* insure at least 1 character ! */
#ifdef	BDC2
d362 1
a362 1
#else
d365 1
a365 1
#endif
d367 2
a368 1
#ifdef	BDC3
d371 1
a371 1
#else
d374 1
a374 1
#endif
d379 4
a382 7
 * Ask for a file name, and write the
 * contents of the current buffer to that file.
 * Update the remembered file name and clear the
 * buffer changed flag. This handling of file names
 * is different from the earlier versions, and
 * is more compatable with Gosling EMACS than
 * with ITS EMACS.
d387 1
a387 1
	int    f, n;
d389 3
a391 3
	int    s;
	char   fname[NFILEN];
	char  *adjfname;
d400 1
a400 1
		(VOID) strcpy(curbp->b_fname, adjfname);
d403 1
a403 1
#else
d405 1
a405 1
#endif
d412 1
a412 2
 * Save the contents of the current buffer back into
 * its associated file.
d417 1
a417 1
#endif
d419 1
a419 1
#endif
d424 1
d430 6
a435 7
 * Save the contents of the buffer argument into its associated file.
 * Do nothing if there have been no changes
 * (is this a bug, or a feature). Error if there is no remembered
 * file name. If this is the first write since the read or visit,
 * then a backup copy of the file is made.
 * Allow user to select whether or not to make backup files
 * by looking at the value of makebackup.
d441 1
a441 1
	int     s;
d443 2
a444 1
	if ((bp->b_flag & BFCHG) == 0) {	/* Return, no changes.	 */
d448 3
a450 1
	if (bp->b_fname[0] == '\0') {	/* Must have a name.	 */
d454 1
d458 2
a459 1
		if (s == ABORT)	/* Hard error.		 */
d461 3
a463 2
		if (s == FALSE	/* Softer error.	 */
		    && (s = eyesno("Backup error, save anyway")) != TRUE)
d466 1
a466 1
#endif
d470 1
a470 1
#else
d472 1
a472 1
#endif
d489 1
a490 1

d498 1
a498 1
#endif
d510 3
a512 5
 * This function performs the details of file
 * writing; writing the file in buffer bp to
 * file fn. Uses the file management routines
 * in the "fileio.c" package. Most of the grief
 * is checking of some sort.
d519 1
a519 1
	int     s;
d521 2
a522 1
	if ((s = ffwopen(fn, bp)) != FIOSUC)	/* Open writes message. */
d525 2
a526 1
	if (s == FIOSUC) {	/* No write error.	 */
d530 3
a532 2
	} else			/* Ignore close error	 */
		(VOID) ffclose(bp);	/* if a write error.	 */
d537 1
a537 1
 * Tag all windows for bp (all windows if bp NULL) as needing their
d544 1
a544 1
	MGWIN  *wp;
@


1.2
log
@change WINDOW -> MGWIN to avoid curses type conflict
convert to terminfo in tty*.c
add support for some keypad function keys (arrows, pgup, pgdown)
@
text
@d6 1
a6 4
BUFFER	*findbuffer();
VOID	makename();
VOID	upmodes();
static	char *itos();
d12 2
a13 1
/*ARGSUSED*/
d15 1
d17 2
a18 2
	register int	s;
	char		fname[NFILEN];
d20 2
a21 1
	if ((s=eread("Insert file: ", fname, NFILEN, EFNEW|EFCR|EFFILE)) != TRUE)
d24 1
a24 1
						/* don't set buffer name */
d35 2
a36 1
/*ARGSUSED*/
d38 1
d40 4
a43 4
	register BUFFER *bp;
	int	s;
	char	fname[NFILEN];
	char	*adjf;
d45 2
a46 1
	if ((s=eread("Find file: ", fname, NFILEN, EFNEW|EFCR|EFFILE)) != TRUE)
d49 2
a50 1
	if ((bp = findbuffer(adjf)) == NULL) return FALSE;
d52 2
a53 1
	if (showbuffer(bp, curwp, WFHARD) != TRUE) return FALSE;
d55 1
a55 1
		return readin(adjf);		/* Read it in.		*/
d63 2
a64 1
/*ARGSUSED*/
d66 1
d68 5
a72 5
	register BUFFER *bp;
	register MGWIN *wp;
	int	s;
	char	fname[NFILEN];
	char	*adjf;
d74 2
a75 2
	if ((s=eread("Find file in other window: ", fname, NFILEN,
		     EFNEW|EFCR|EFFILE)) != TRUE)
d78 4
a81 2
	if ((bp = findbuffer(adjf)) == NULL) return FALSE;
	if ((wp = popbuf(bp)) == NULL) return FALSE;
d85 1
a85 1
		return readin(adjf);		/* Read it in.		*/
d95 1
a95 1
char *fname;
d97 3
a99 3
	register BUFFER *bp;
	char	bname[NBUFN], *cp;
	unsigned count = 1;
d101 1
a101 1
	for (bp=bheadp; bp!=NULL; bp=bp->b_bufp) {
d105 1
a105 1
	makename(bname, fname);			/* New buffer name.	*/
d107 3
a109 3
	while(bfind(bname, FALSE) != NULL) {
		*cp = '<';		/* add "<count>" to then name	*/
		(VOID) strcpy(itos(cp, ++count)+1, ">");
d118 4
a121 3
static char *itos(bufp, num)
char *bufp;
unsigned num;
d123 1
d125 1
a125 1
		bufp = itos(bufp, num/10);
d138 6
a143 3
readin(fname) char *fname; {
	register int		status;
	register MGWIN		*wp;
d145 1
a145 1
	if (bclear(curbp) != TRUE)		/* Might be old.	*/
d147 3
a149 3
	status = insertfile(fname, fname, TRUE) ;
	curbp->b_flag &= ~BFCHG;		/* No change.		*/
	for (wp=wheadp; wp!=NULL; wp=wp->w_wndp) {
d151 2
a152 2
			wp->w_dotp  = wp->w_linep = lforw(curbp->b_linep);
			wp->w_doto  = 0;
d177 2
a178 2
static char *line = NULL;
static int linesize = 0;
d180 13
a192 9
insertfile(fname, newname, needinfo) char fname[], newname[]; {
	register LINE	*lp1;
	register LINE	*lp2;
	register MGWIN *wp;
	int		nbytes;
	LINE		*olp;			/* Line we started at */
	int		opos;			/* and offset into it */
	int		s, nline;
	BUFFER		*bp;
d198 1
a198 1
	bp = curbp;				/* Cheap.		*/
d201 2
a202 2
	/* Hard file open.	*/
	if ((s=ffropen(fname, needinfo ? bp : (BUFFER *) NULL)) == FIOERR)
d204 1
a204 1
	if (s == FIOFNF) {			/* File not found.	*/
d207 2
a208 1
		else	ewprintf("(File not found)");
d215 1
a215 1
	if(olp == curbp->b_linep) {
d220 2
a221 2
	nline = 0;			/* Don't count fake line at end */
	while ((s=ffgetline(line, linesize, &nbytes)) != FIOERR) {
d223 44
a266 38
	    switch(s) {
	    case FIOSUC:
		++nline;
		/* and continue */
	    case FIOEOF:	/* the last line of the file		*/
		if ((lp1=lalloc(nbytes)) == NULL) {
			s = FIOERR;		/* Keep message on the	*/
			goto endoffile;		/* display.		*/
		}
		bcopy(line, &ltext(lp1)[0], nbytes);
		lp2 = lback(curwp->w_dotp);
		lp2->l_fp = lp1;
		lp1->l_fp = curwp->w_dotp;
		lp1->l_bp = lp2;
		curwp->w_dotp->l_bp = lp1;
		if(s==FIOEOF) goto endoffile;
		break;
	    case FIOLONG: {	/* a line to long to fit in our buffer	*/
		    char *cp;
		    int newsize;

		    newsize = linesize * 2;
		    if(newsize < 0 || 
		       (cp = malloc((unsigned)newsize)) == NULL) {
			    ewprintf("Could not allocate %d bytes",
				    newsize);
			    s = FIOERR;
			    goto endoffile;
		    }
		    bcopy(line, cp, linesize);
		    free(line);
		    line = cp;
		    s=ffgetline(line+linesize, linesize, &nbytes);
		    nbytes += linesize;
		    linesize = newsize;
		    if (s == FIOERR)
			goto endoffile;
		    goto doneread;
a267 5
	    default:
		ewprintf("Unknown code %d reading file", s);
		s = FIOERR;
		break;
	    }
d270 6
a275 4
	(VOID) ffclose((BUFFER *) NULL);	/* Ignore errors.	*/
	if (s==FIOEOF) {			/* Don't zap an error.	*/
		if (nline == 1) ewprintf("(Read 1 line)");
		else		ewprintf("(Read %d lines)", nline);
d283 2
a284 1
	if(olp == curbp->b_linep) curwp->w_dotp = lforw(olp);
d287 3
a289 2
		bp->b_flag |= BFCHG | BFBAK;	/* Need a backup.	*/
	else	bp->b_flag |= BFCHG;
d293 6
a298 5
	/* if the insert was at the end of buffer, set lp1 to the end of
	 * buffer line, and lp2 to the beginning of the newly inserted
	 * text.  (Otherwise lp2 is set to NULL.)  This is
	 * used below to set pointers in other windows correctly if they
	 * are also at the end of buffer.
d304 1
a304 1
		(VOID) ldelnewline();		/* delete extranious newline */
d307 1
a307 1
	for (wp=wheadp; wp!=NULL; wp=wp->w_wndp) {
d309 1
a309 1
			wp->w_flag |= WFMODE|WFEDIT;
d311 6
a316 3
				if (wp->w_dotp == lp1)	wp->w_dotp  = lp2;
				if (wp->w_markp == lp1) wp->w_markp = lp2;
				if (wp->w_linep == lp1) wp->w_linep = lp2;
d320 1
a320 1
	return s != FIOERR;			/* False if error.	*/
d332 6
a337 3
makename(bname, fname) char bname[]; char fname[]; {
	register char	*cp1;
	register char	*cp2;
d344 1
a344 1
	while (cp1!=&fname[0] && cp1[-1]!=BDC1 && cp1[-1]!=BDC2)
d347 1
a347 1
	while (cp1!=&fname[0] && cp1[-1]!=BDC1)
d352 1
a352 1
	while (cp2!=&bname[NBUFN-1] && *cp1!=0 && *cp1!=BDC3)
d355 1
a355 1
	while (cp2!=&bname[NBUFN-1] && *cp1!=0)
d370 2
a371 1
/*ARGSUSED*/
d373 1
d375 3
a377 3
	register int	s;
	char		fname[NFILEN];
	char		*adjfname;
d379 2
a380 2
	if ((s=eread("Write file: ", fname, NFILEN,
		      EFNEW|EFCR|EFFILE)) != TRUE)
d385 1
a385 1
	if ((s=writeout(curbp, adjfname)) == TRUE) {
d405 1
a405 1
static int	makebackup = MAKEBACKUP;
d408 2
a409 1
/*ARGSUSED*/
d424 5
a428 2
buffsave(bp) BUFFER *bp; {
	register int	s;
d430 1
a430 1
	if ((bp->b_flag&BFCHG) == 0)	{	/* Return, no changes.	*/
d434 1
a434 1
	if (bp->b_fname[0] == '\0') {		/* Must have a name.	*/
d439 1
a439 1
	if (makebackup && (bp->b_flag&BFBAK)) {
d441 1
a441 1
		if (s == ABORT)			/* Hard error.		*/
d443 2
a444 2
		if (s == FALSE			/* Softer error.	*/
		&& (s=eyesno("Backup error, save anyway")) != TRUE)
d448 1
a448 1
	if ((s=writeout(bp, bp->b_fname)) == TRUE) {
d460 6
a465 7
/* Since we don't have variables (we probably should)
 * this is a command processor for changing the value of
 * the make backup flag.  If no argument is given,
 * sets makebackup to true, so backups are made.  If
 * an argument is given, no backup files are made when
 * saving a new version of a file. Only used when BACKUP
 * is #defined.
d467 2
a468 1
/*ARGSUSED*/
d471 5
a475 2
	if(f & FFARG) makebackup = n > 0;
	else makebackup = !makebackup;
d497 6
a502 2
writeout(bp, fn) register BUFFER *bp; char *fn; {
	register int	s;
d504 1
a504 1
	if ((s=ffwopen(fn,bp)) != FIOSUC)	/* Open writes message. */
d507 1
a507 1
	if (s == FIOSUC) {			/* No write error.	*/
d509 1
a509 1
		if (s==FIOSUC)
d511 2
a512 2
	} else					/* Ignore close error	*/
		(VOID) ffclose(bp);		/* if a write error.	*/
d521 4
a524 2
upmodes(bp) register BUFFER *bp; {
	register MGWIN *wp;
d527 2
a528 1
		if (bp == NULL || curwp->w_bufp == bp) wp->w_flag |= WFMODE;
@


1.1
log
@initial import of mg2a
@
text
@d62 1
a62 1
	register WINDOW *wp;
d129 1
a129 1
	register WINDOW		*wp;
d169 1
a169 1
	register WINDOW *wp;
d478 1
a478 1
	register WINDOW *wp;
@

