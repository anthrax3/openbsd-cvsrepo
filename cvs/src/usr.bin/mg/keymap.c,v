head	1.58;
access;
symbols
	OPENBSD_6_0:1.58.0.4
	OPENBSD_6_0_BASE:1.58
	OPENBSD_5_9:1.58.0.2
	OPENBSD_5_9_BASE:1.58
	OPENBSD_5_8:1.55.0.4
	OPENBSD_5_8_BASE:1.55
	OPENBSD_5_7:1.52.0.2
	OPENBSD_5_7_BASE:1.52
	OPENBSD_5_6:1.51.0.8
	OPENBSD_5_6_BASE:1.51
	OPENBSD_5_5:1.51.0.6
	OPENBSD_5_5_BASE:1.51
	OPENBSD_5_4:1.51.0.2
	OPENBSD_5_4_BASE:1.51
	OPENBSD_5_3:1.50.0.4
	OPENBSD_5_3_BASE:1.50
	OPENBSD_5_2:1.50.0.2
	OPENBSD_5_2_BASE:1.50
	OPENBSD_5_1_BASE:1.46
	OPENBSD_5_1:1.46.0.2
	OPENBSD_5_0:1.45.0.4
	OPENBSD_5_0_BASE:1.45
	OPENBSD_4_9:1.45.0.2
	OPENBSD_4_9_BASE:1.45
	OPENBSD_4_8:1.43.0.8
	OPENBSD_4_8_BASE:1.43
	OPENBSD_4_7:1.43.0.4
	OPENBSD_4_7_BASE:1.43
	OPENBSD_4_6:1.43.0.6
	OPENBSD_4_6_BASE:1.43
	OPENBSD_4_5:1.43.0.2
	OPENBSD_4_5_BASE:1.43
	OPENBSD_4_4:1.42.0.2
	OPENBSD_4_4_BASE:1.42
	OPENBSD_4_3:1.39.0.8
	OPENBSD_4_3_BASE:1.39
	OPENBSD_4_2:1.39.0.6
	OPENBSD_4_2_BASE:1.39
	OPENBSD_4_1:1.39.0.4
	OPENBSD_4_1_BASE:1.39
	OPENBSD_4_0:1.39.0.2
	OPENBSD_4_0_BASE:1.39
	OPENBSD_3_9:1.37.0.2
	OPENBSD_3_9_BASE:1.37
	OPENBSD_3_8:1.30.0.2
	OPENBSD_3_8_BASE:1.30
	OPENBSD_3_7:1.27.0.2
	OPENBSD_3_7_BASE:1.27
	OPENBSD_3_6:1.26.0.8
	OPENBSD_3_6_BASE:1.26
	OPENBSD_3_5:1.26.0.6
	OPENBSD_3_5_BASE:1.26
	OPENBSD_3_4:1.26.0.4
	OPENBSD_3_4_BASE:1.26
	OPENBSD_3_3:1.26.0.2
	OPENBSD_3_3_BASE:1.26
	OPENBSD_3_2:1.25.0.2
	OPENBSD_3_2_BASE:1.25
	OPENBSD_3_1:1.19.0.2
	OPENBSD_3_1_BASE:1.19
	OPENBSD_3_0:1.14.0.2
	OPENBSD_3_0_BASE:1.14
	OPENBSD_2_9_BASE:1.5
	OPENBSD_2_9:1.5.0.2
	OPENBSD_2_8:1.4.0.2
	OPENBSD_2_8_BASE:1.4
	OPENBSD_2_7:1.3.0.2
	OPENBSD_2_7_BASE:1.3;
locks; strict;
comment	@ * @;


1.58
date	2015.12.29.19.44.32;	author lum;	state Exp;
branches;
next	1.57;
commitid	zQwbtQmO8Wf9dGsD;

1.57
date	2015.09.26.21.51.58;	author jasper;	state Exp;
branches;
next	1.56;
commitid	yS81WdIVlzEJxLUH;

1.56
date	2015.09.24.07.07.59;	author lum;	state Exp;
branches;
next	1.55;
commitid	ilbGNsJo2VDLtO5r;

1.55
date	2015.03.19.21.48.05;	author bcallah;	state Exp;
branches;
next	1.54;
commitid	8rkHsVfUx5xgPXRB;

1.54
date	2015.03.19.21.22.15;	author bcallah;	state Exp;
branches;
next	1.53;
commitid	GbEBL4CfPvDkB8hj;

1.53
date	2015.03.16.13.47.48;	author bcallah;	state Exp;
branches;
next	1.52;
commitid	gSveQVkxMLs6vRqK;

1.52
date	2014.08.14.12.22.58;	author bcallah;	state Exp;
branches;
next	1.51;
commitid	dQBDyJO5uawmEWA2;

1.51
date	2013.05.22.19.23.45;	author lum;	state Exp;
branches;
next	1.50;

1.50
date	2012.06.07.15.15.04;	author lum;	state Exp;
branches;
next	1.49;

1.49
date	2012.04.12.04.47.59;	author lum;	state Exp;
branches;
next	1.48;

1.48
date	2012.04.11.17.51.10;	author lum;	state Exp;
branches;
next	1.47;

1.47
date	2012.03.14.13.56.35;	author lum;	state Exp;
branches;
next	1.46;

1.46
date	2011.11.28.04.41.39;	author lum;	state Exp;
branches;
next	1.45;

1.45
date	2011.01.18.16.25.40;	author kjell;	state Exp;
branches;
next	1.44;

1.44
date	2011.01.17.03.12.06;	author kjell;	state Exp;
branches;
next	1.43;

1.43
date	2008.08.27.04.11.52;	author kjell;	state Exp;
branches;
next	1.42;

1.42
date	2008.06.14.08.46.30;	author kjell;	state Exp;
branches;
next	1.41;

1.41
date	2008.06.12.21.13.20;	author kjell;	state Exp;
branches;
next	1.40;

1.40
date	2008.06.11.23.18.33;	author kjell;	state Exp;
branches;
next	1.39;

1.39
date	2006.08.18.00.22.56;	author kjell;	state Exp;
branches;
next	1.38;

1.38
date	2006.07.27.19.59.29;	author deraadt;	state Exp;
branches;
next	1.37;

1.37
date	2005.11.18.20.56.53;	author deraadt;	state Exp;
branches;
next	1.36;

1.36
date	2005.11.07.23.32.20;	author kjell;	state Exp;
branches;
next	1.35;

1.35
date	2005.10.13.20.28.49;	author deraadt;	state Exp;
branches;
next	1.34;

1.34
date	2005.10.13.06.20.25;	author kjell;	state Exp;
branches;
next	1.33;

1.33
date	2005.10.13.05.47.45;	author kjell;	state Exp;
branches;
next	1.32;

1.32
date	2005.10.11.00.50.00;	author kjell;	state Exp;
branches;
next	1.31;

1.31
date	2005.10.06.20.02.10;	author kjell;	state Exp;
branches;
next	1.30;

1.30
date	2005.06.14.18.14.40;	author kjell;	state Exp;
branches;
next	1.29;

1.29
date	2005.05.30.13.13.50;	author jason;	state Exp;
branches;
next	1.28;

1.28
date	2005.04.03.02.09.28;	author db;	state Exp;
branches;
next	1.27;

1.27
date	2005.03.09.16.20.48;	author jfb;	state Exp;
branches;
next	1.26;

1.26
date	2002.12.09.08.20.46;	author deraadt;	state Exp;
branches;
next	1.25;

1.25
date	2002.09.28.05.18.48;	author deraadt;	state Exp;
branches;
next	1.24;

1.24
date	2002.09.26.10.12.26;	author deraadt;	state Exp;
branches;
next	1.23;

1.23
date	2002.06.27.23.07.58;	author vincent;	state Exp;
branches;
next	1.22;

1.22
date	2002.06.27.21.39.56;	author vincent;	state Exp;
branches;
next	1.21;

1.21
date	2002.05.29.20.25.00;	author vincent;	state Exp;
branches;
next	1.20;

1.20
date	2002.05.29.12.32.51;	author vincent;	state Exp;
branches;
next	1.19;

1.19
date	2002.03.11.13.02.56;	author vincent;	state Exp;
branches;
next	1.18;

1.18
date	2002.03.01.19.05.40;	author deraadt;	state Exp;
branches;
next	1.17;

1.17
date	2002.02.21.04.14.01;	author deraadt;	state Exp;
branches;
next	1.16;

1.16
date	2002.02.20.23.37.24;	author art;	state Exp;
branches;
next	1.15;

1.15
date	2002.02.08.21.21.11;	author deraadt;	state Exp;
branches;
next	1.14;

1.14
date	2001.05.24.10.47.54;	author art;	state Exp;
branches;
next	1.13;

1.13
date	2001.05.24.10.43.18;	author art;	state Exp;
branches;
next	1.12;

1.12
date	2001.05.24.09.47.34;	author art;	state Exp;
branches;
next	1.11;

1.11
date	2001.05.23.22.56.52;	author mickey;	state Exp;
branches;
next	1.10;

1.10
date	2001.05.23.22.36.14;	author art;	state Exp;
branches;
next	1.9;

1.9
date	2001.05.23.22.10.43;	author art;	state Exp;
branches;
next	1.8;

1.8
date	2001.05.23.21.59.45;	author art;	state Exp;
branches;
next	1.7;

1.7
date	2001.05.23.16.26.39;	author art;	state Exp;
branches;
next	1.6;

1.6
date	2001.05.23.16.14.00;	author art;	state Exp;
branches;
next	1.5;

1.5
date	2001.01.29.01.58.08;	author niklas;	state Exp;
branches;
next	1.4;

1.4
date	2000.09.01.14.59.08;	author millert;	state Exp;
branches;
next	1.3;

1.3
date	2000.04.13.06.12.15;	author millert;	state Exp;
branches;
next	1.2;

1.2
date	2000.03.03.19.31.26;	author millert;	state Exp;
branches;
next	1.1;

1.1
date	2000.02.25.19.08.48;	author deraadt;	state Exp;
branches;
next	;


desc
@@


1.58
log
@Add transpose-words, ok jasper@@.
Limited to one iteration until 'undo' is looked into.
@
text
@/*	$OpenBSD: keymap.c,v 1.57 2015/09/26 21:51:58 jasper Exp $	*/

/* This file is in the public domain. */

/*
 * Keyboard maps.  This is character set dependent.  The terminal specific
 * parts of building the keymap has been moved to a better place.
 */

#include <sys/queue.h>
#include <signal.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#include "def.h"
#include "kbd.h"

/*
 * initial keymap declarations, deepest first
 */

static PF cHcG[] = {
	ctrlg,			/* ^G */
	help_help		/* ^H */
};

static PF cHa[] = {
	apropos_command,	/* a */
	wallchart,		/* b */
	desckey			/* c */
};

struct KEYMAPE (2) helpmap = {
	2,
	2,
	rescan,
	{
		{
			CCHR('G'), CCHR('H'), cHcG, NULL
		},
		{
			'a', 'c', cHa, NULL
		}
	}
};

static PF cCsc[] = {
	cscallerfuncs,		/* c */
	csdefinition,		/* d */
	csegrep,		/* e */
	csfindfile,		/* f */
	rescan,			/* g */
	rescan,			/* h */
	csfindinc,		/* i */
	rescan,			/* j */
	rescan,			/* k */
	rescan,			/* l */
	rescan,			/* m */
	csnextmatch,		/* n */
	rescan,			/* o */
	csprevmatch,		/* p */
	rescan,			/* q */
	rescan, 		/* r */
	cssymbol,		/* s */
	csfindtext		/* t */
};

static struct KEYMAPE (1) cCsmap = {
	1,
	1,
	rescan,
	{
		{
			'c', 't', cCsc, NULL
		}
	}
};

static PF cCs[] = {
	NULL			/* s */
};

struct KEYMAPE (2) ccmap = {
	2,
	2,
	rescan,
	{
		{
			CCHR('@@'), CCHR('@@'), (PF[]){ rescan }, NULL
		},
		{
			's', 's', cCs, (KEYMAP *) & cCsmap
		}
	}
};

static PF cX4cF[] = {
	poptofile,		/* ^f */
	ctrlg			/* ^g */
};
static PF cX4b[] = {
	poptobuffer,		/* b */
	rescan,			/* c */
	rescan,			/* d */
	rescan,			/* e */
	poptofile		/* f */
};
static struct KEYMAPE (2) cX4map = {
	2,
	2,
	rescan,
	{
		{
			CCHR('F'), CCHR('G'), cX4cF, NULL
		},
		{
			'b', 'f', cX4b, NULL
		}
	}
};

static PF cXcB[] = {
	listbuffers,		/* ^B */
	quit,			/* ^C */
	rescan,			/* ^D */
	rescan,			/* ^E */
	filevisit,		/* ^F */
	ctrlg			/* ^G */
};

static PF cXcL[] = {
	lowerregion,		/* ^L */
	rescan,			/* ^M */
	rescan,			/* ^N */
	deblank,		/* ^O */
	rescan,			/* ^P */
	togglereadonly,		/* ^Q */
	filevisitro,		/* ^R */
	filesave,		/* ^S */
	rescan,			/* ^T */
	upperregion,		/* ^U */
	filevisitalt,		/* ^V */
	filewrite,		/* ^W */
	swapmark		/* ^X */
};

static PF cXlp[] = {
	definemacro,		/* ( */
	finishmacro		/* ) */
};

static PF cX0[] = {
	delwind,		/* 0 */
	onlywind,		/* 1 */
	splitwind,		/* 2 */
	rescan,			/* 3 */
	NULL			/* 4 */
};

static PF cXeq[] = {
	showcpos		/* = */
};

static PF cXcar[] = {
	enlargewind,		/* ^ */
	rescan,			/* _ */
	next_error,		/* ` */
	rescan,			/* a */
	usebuffer,		/* b */
	rescan,			/* c */
	rescan,			/* d */
	executemacro,		/* e */
	setfillcol,		/* f */
	gotoline,		/* g */
	markbuffer,		/* h */
	fileinsert,		/* i */
	rescan,			/* j */
	killbuffer_cmd,		/* k */
	rescan,			/* l */
	rescan,			/* m */
	nextwind,		/* n */
	nextwind,		/* o */
	prevwind,		/* p */
	rescan,			/* q */
	rescan,			/* r */
	savebuffers,		/* s */
	rescan,			/* t */
	undo			/* u */
};

struct KEYMAPE (6) cXmap = {
	6,
	6,
	rescan,
	{
		{
			CCHR('B'), CCHR('G'), cXcB, NULL
		},
		{
			CCHR('L'), CCHR('X'), cXcL, NULL
		},
		{
			'(', ')', cXlp, NULL
		},
		{
			'0', '4', cX0, (KEYMAP *) & cX4map
		},
		{
			'=', '=', cXeq, NULL
		},
		{
			'^', 'u', cXcar, NULL
		}
	}
};

static PF metacG[] = {
	ctrlg			/* ^G */
};

static PF metacV[] = {
	pagenext		/* ^V */
};

static PF metaspex[] = {
	justone,		/* space */
	shellcommand		/* ! */
};

static PF metapct[] = {
	queryrepl		/* % */
};

static PF metami[] = {
	poptag,                 /* * */
	rescan,                 /* + */
	rescan,                 /* , */
	negative_argument,	/* - */
	findtag,		/* . */
	rescan,			/* / */
	digit_argument,		/* 0 */
	digit_argument,		/* 1 */
	digit_argument,		/* 2 */
	digit_argument,		/* 3 */
	digit_argument,		/* 4 */
	digit_argument,		/* 5 */
	digit_argument,		/* 6 */
	digit_argument,		/* 7 */
	digit_argument,		/* 8 */
	digit_argument,		/* 9 */
	rescan,			/* : */
	rescan,			/* ; */
	gotobob,		/* < */
	rescan,			/* = */
	gotoeob			/* > */
};

static PF metasqf[] = {
	NULL,			/* [ */
	delwhite,		/* \ */
	rescan,			/* ] */
	joinline,		/* ^ */
	rescan,			/* _ */
	rescan,			/* ` */
	rescan,			/* a */
	backword,		/* b */
	capword,		/* c */
	delfword,		/* d */
	rescan,			/* e */
	forwword,		/* f */
	rescan,			/* g */
	markpara		/* h */
};

static PF metal[] = {
	lowerword,		/* l */
	backtoindent,		/* m */
	rescan,			/* n */
	rescan,			/* o */
	rescan,			/* p */
	fillpara,		/* q */
	backsearch,		/* r */
	forwsearch,		/* s */
	transposeword,		/* t */
	upperword,		/* u */
	backpage,		/* v */
	copyregion,		/* w */
	extend,			/* x */
	rescan,			/* y */
	rescan,			/* z */
	gotobop,		/* { */
	piperegion,		/* | */
	gotoeop			/* } */
};

static PF metasqlZ[] = {
	rescan			/* Z */
};

static PF metatilde[] = {
	notmodified,		/* ~ */
	delbword		/* DEL */
};

struct KEYMAPE (1) metasqlmap = {
	1,
	1,
	rescan,
	{
		{
			'Z', 'Z', metasqlZ, NULL
		}
	}
};

struct KEYMAPE (8) metamap = {
	8,
	8,
	rescan,
	{
		{
			CCHR('G'), CCHR('G'), metacG, NULL
		},
		{
			CCHR('V'), CCHR('V'), metacV, NULL
		},
		{
			' ', '!', metaspex, NULL
		},
		{
			'%', '%', metapct, NULL
		},
		{
			'*', '>', metami, NULL
		},
		{
			'[', 'h', metasqf, (KEYMAP *) &metasqlmap
		},
		{
			'l', '}', metal, NULL
		},
		{
			'~', CCHR('?'), metatilde, NULL
		}
	}
};

static PF fund_at[] = {
	setmark,		/* ^@@ */
	gotobol,		/* ^A */
	backchar,		/* ^B */
	NULL,			/* ^C */
	forwdel,		/* ^D */
	gotoeol,		/* ^E */
	forwchar,		/* ^F */
	ctrlg,			/* ^G */
};

static PF fund_h[] = {
	NULL,			/* ^H */
};


/* ^I is selfinsert */
static PF fund_CJ[] = {
	lfindent,		/* ^J */
	killline,		/* ^K */
	reposition,		/* ^L */
	enewline,		/* ^M */
	forwline,		/* ^N */
	openline,		/* ^O */
	backline,		/* ^P */
	quote,			/* ^Q */
	backisearch,		/* ^R */
	forwisearch,		/* ^S */
	twiddle,		/* ^T */
	universal_argument,	/* ^U */
	forwpage,		/* ^V */
	killregion,		/* ^W */
	NULL,			/* ^X */
	yank,			/* ^Y */
	spawncli		/* ^Z */
};

static PF fund_esc[] = {
	NULL,			/* esc */
	rescan,			/* ^\ selfinsert is default on fundamental */
	rescan,			/* ^] */
	rescan,			/* ^^ */
	undo			/* ^_ */
};

static PF fund_del[] = {
	backdel			/* DEL */
};

static PF fund_cb[] = {
	showmatch		/* ) ] }  */
};

static struct KEYMAPE (8) fundmap = {
	8,
	8,
	selfinsert,
	{
		{
			CCHR('@@'), CCHR('G'), fund_at, (KEYMAP *) & ccmap
		},
		{
			CCHR('H'), CCHR('H'), fund_h, (KEYMAP *) & helpmap
		},
		{
			CCHR('J'), CCHR('Z'), fund_CJ, (KEYMAP *) & cXmap
		},
		{
			CCHR('['), CCHR('_'), fund_esc, (KEYMAP *) & metamap
		},
		{
			')', ')', fund_cb, NULL
		},
		{
			']', ']', fund_cb, NULL
		},
		{
			'}', '}', fund_cb, NULL
		},
		{
			CCHR('?'), CCHR('?'), fund_del, NULL
		},
	}
};

static PF fill_sp[] = {
	fillword		/* ' ' */
};

static struct KEYMAPE (1) fillmap = {
	1,
	1,
	rescan,
	{
		{ ' ', ' ', fill_sp, NULL }
	}
};

static PF indent_lf[] = {
	enewline,		/* ^J */
	rescan,			/* ^K */
	rescan,			/* ^L */
	lfindent		/* ^M */
};

static struct KEYMAPE (1) indntmap = {
	1,
	1,
	rescan,
	{
		{
			CCHR('J'), CCHR('M'), indent_lf, NULL
		}
	}
};

#ifdef NOTAB
static PF notab_tab[] = {
	space_to_tabstop	/* ^I */
};

static struct KEYMAPE (1) notabmap = {
	1,
	1,
	rescan,
	{
		{
			CCHR('I'), CCHR('I'), notab_tab, NULL
		}
	}
};
#endif /* NOTAB */

static struct KEYMAPE (1) overwmap = {
	0,
	1,		/* 1 to avoid 0 sized array */
	rescan,
	{
		/* unused dummy entry for VMS C */
		{
			(KCHAR)0, (KCHAR)0, NULL, NULL
		}
	}
};


/*
 * The basic (root) keyboard map
 */
struct maps_s	fundamental_mode = { (KEYMAP *)&fundmap, "fundamental" };

/*
 * give names to the maps, for use by help etc. If the map is to be bindable,
 * it must also be listed in the function name table below with the same
 * name. Maps created dynamically currently don't get added here, thus are
 * unnamed. Modes are just named keymaps with functions to add/subtract them
 * from a buffer's list of modes.  If you change a mode name, change it in
 * modes.c also.
 */

static struct maps_s map_table[] = {
	{(KEYMAP *) &fillmap, "fill",},
	{(KEYMAP *) &indntmap, "indent",},
#ifdef NOTAB
	{(KEYMAP *) &notabmap, "notab",},
#endif /* NOTAB */
	{(KEYMAP *) &overwmap, "overwrite",},
	{(KEYMAP *) &metamap, "esc prefix",},
	{(KEYMAP *) &cXmap, "c-x prefix",},
	{(KEYMAP *) &cX4map, "c-x 4 prefix",},
	{(KEYMAP *) &helpmap, "help",},
	{NULL, NULL}
};

struct maps_s *maps;

void
maps_init(void)
{
	int	 i;
	struct maps_s	*mp;

	maps = &fundamental_mode;
	for (i = 0; map_table[i].p_name != NULL; i++) {
		mp = &map_table[i];
		mp->p_next = maps;
		maps = mp;
	}
}

/*
 * Insert a new (named) keymap at the head of the keymap list.
 */
int
maps_add(KEYMAP *map, const char *name)
{
	struct maps_s	*mp;

	if ((mp = malloc(sizeof(*mp))) == NULL)
		return (FALSE);

	mp->p_name = name;
	mp->p_map = map;
	mp->p_next = maps;
	maps = mp;

	return (TRUE);
}

struct maps_s *
name_mode(const char *name)
{
	struct maps_s	*mp;

	for (mp = maps; mp != NULL; mp = mp->p_next)
		if (strcmp(mp->p_name, name) == 0)
			return (mp);
	return (NULL);
}

KEYMAP *
name_map(const char *name)
{
	struct maps_s	*mp;

	return ((mp = name_mode(name)) == NULL ? NULL : mp->p_map);
}
@


1.57
log
@whitespace
@
text
@d1 1
a1 1
/*	$OpenBSD: keymap.c,v 1.56 2015/09/24 07:07:59 lum Exp $	*/
d285 1
a285 1
	rescan,			/* t */
@


1.56
log
@Add mark-paragraph. ok jasper@@
@
text
@d1 1
a1 1
/*	$OpenBSD: keymap.c,v 1.55 2015/03/19 21:48:05 bcallah Exp $	*/
d64 1
a64 1
	rescan, 		/* r */	
@


1.55
log
@More unifdef cleanup:
-UDIRED_XMAPS and -UFUND_XMAPS: you can't build mg the other way.
-DTIOCGWINSZ: you have this if you have term.h
Remove a #define TERMCAP which isn't being used.

Remove defines for NDIRED_XMAPS, NFUND_XMAPS, and IMAPEXT. They are all
defined to be 0 and are only ever used in addition. We don't need to add 0.
Simply lines that were using those defines.
ok florian@@
@
text
@d1 1
a1 1
/*	$OpenBSD: keymap.c,v 1.54 2015/03/19 21:22:15 bcallah Exp $	*/
d271 3
a273 1
	forwword		/* f */
d338 1
a338 1
			'[', 'f', metasqf, (KEYMAP *) &metasqlmap
@


1.54
log
@Clean up the includes in mg.
This does the following:
Moves all POSIX headers from sysdef.h into the individual .c files so that
each file now only includes what it needs. All headers are properly sorted.
Moves the remainder of sysdef.h to other files (mostly def.h) and deletes
sysdef.h now that it's no longer contains anything.
Tweak a comment that references sysdef.h so that it no longer does that.
ok florian@@
@
text
@d1 1
a1 1
/*	$OpenBSD: keymap.c,v 1.53 2015/03/16 13:47:48 bcallah Exp $	*/
d34 2
a35 1
struct KEYMAPE (2 + IMAPEXT) helpmap = {
a36 1
	2 + IMAPEXT,
d69 2
a70 1
static struct KEYMAPE (1 + IMAPEXT) cCsmap = {
a71 1
	1 + IMAPEXT,
d84 2
a85 1
struct KEYMAPE (2 + IMAPEXT) ccmap = {
a86 1
	2 + IMAPEXT,
d109 2
a110 1
static struct KEYMAPE (2 + IMAPEXT) cX4map = {
a111 1
	2 + IMAPEXT,
d192 2
a193 1
struct KEYMAPE (6 + IMAPEXT) cXmap = {
a194 1
	6 + IMAPEXT,
d304 2
a305 1
struct KEYMAPE (1 + IMAPEXT) metasqlmap = {
a306 1
	1 + IMAPEXT,
d315 2
a316 1
struct KEYMAPE (8 + IMAPEXT) metamap = {
a317 1
	8 + IMAPEXT,
d400 3
a402 7
#ifndef	FUND_XMAPS
#define NFUND_XMAPS	0	/* extra map sections after normal ones */
#endif

static struct KEYMAPE (8 + NFUND_XMAPS + IMAPEXT) fundmap = {
	8 + NFUND_XMAPS,
	8 + NFUND_XMAPS + IMAPEXT,
a428 3
#ifdef FUND_XMAPS
		FUND_XMAPS,
#endif /* FUND_XMAPS */
d436 2
a437 1
static struct KEYMAPE (1 + IMAPEXT) fillmap = {
a438 1
	1 + IMAPEXT,
d452 2
a453 1
static struct KEYMAPE (1 + IMAPEXT) indntmap = {
a454 1
	1 + IMAPEXT,
d468 2
a469 1
static struct KEYMAPE (1 + IMAPEXT) notabmap = {
a470 1
	1 + IMAPEXT,
d480 1
a480 1
static struct KEYMAPE (1 + IMAPEXT) overwmap = {
d482 1
a482 1
	1 + IMAPEXT,		/* 1 to avoid 0 sized array */
@


1.53
log
@Change the internal name of the newline function to deconflict with a
function of the same name in term.h. This is the first step towards
cleaning up mg's includes. No user-visible changes.
ok florian@@
@
text
@d1 1
a1 1
/*	$OpenBSD: keymap.c,v 1.52 2014/08/14 12:22:58 bcallah Exp $	*/
d9 6
@


1.52
log
@Add bounce matching for [] and {} like mg already does with () and like
Emacs does.
ok florian@@
@
text
@d1 1
a1 1
/*	$OpenBSD: keymap.c,v 1.51 2013/05/22 19:23:45 lum Exp $	*/
d362 1
a362 1
	newline,		/* ^M */
d447 1
a447 1
	newline,		/* ^J */
@


1.51
log
@Shuffle shell-command-on-region around to give shell-command.
ok florian@@ jasper@@
Testing Sunil Nimmagadda
@
text
@d1 1
a1 1
/*	$OpenBSD: keymap.c,v 1.50 2012/06/07 15:15:04 lum Exp $	*/
d391 1
a391 1
	showmatch		/* )  */
d398 3
a400 3
static struct KEYMAPE (6 + NFUND_XMAPS + IMAPEXT) fundmap = {
	6 + NFUND_XMAPS,
	6 + NFUND_XMAPS + IMAPEXT,
d417 6
@


1.50
log
@Add some cscope support to mg. From Sunil Nimmagadda.  Due to some
structural limitations in mg, mg doesn't behave exactly the same as
emacs cscope (see the README) but is still very usable.

man page bits reviewed by jmc@@, otherwise tested and reviewed by
myself.
@
text
@d1 1
a1 1
/*	$OpenBSD: keymap.c,v 1.49 2012/04/12 04:47:59 lum Exp $	*/
d220 3
a222 2
static PF metasp[] = {
	justone			/* space */
d321 1
a321 1
			' ', ' ', metasp, NULL
@


1.49
log
@Remove the conditional directives NO_MACRO and NO_STARTUP.
They have not compiled for numerous years.
ok kjell@@ millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: keymap.c,v 1.48 2012/04/11 17:51:10 lum Exp $	*/
d42 22
a63 1
struct KEYMAPE (1 + IMAPEXT) ccmap = {
d69 15
d85 3
a90 1

@


1.48
log
@Add:
 1. C-x h to mark whole buffer.
 2. M-| to pipe current region to external command.
From Sunil Nimmagadda.

Feedback from deraadt@@ and myself. ok for man page amendments from jmc@@
@
text
@d1 1
a1 1
/*	$OpenBSD: keymap.c,v 1.47 2012/03/14 13:56:35 lum Exp $	*/
a103 1
#ifndef NO_MACRO
a107 1
#endif /* !NO_MACRO */
a128 1
#ifndef NO_MACRO
a129 3
#else /* !NO_MACRO */
	rescan,			/* e */
#endif /* !NO_MACRO */
a147 1
#ifndef NO_MACRO
a150 5
#else /* !NO_MACRO */
static struct KEYMAPE (5 + IMAPEXT) cXmap = {
	5,
	5 + IMAPEXT,
#endif /* !NO_MACRO */
a158 1
#ifndef NO_MACRO
a161 1
#endif /* !NO_MACRO */
@


1.47
log
@Remove the NO_HELP conditional directives. If defined, mg will not compile and
has not done so for numerous years. Not hard to fix, but just remove anyway.
ok kjell@@ millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: keymap.c,v 1.46 2011/11/28 04:41:39 lum Exp $	*/
d138 1
a138 1
	rescan,			/* h */
d260 1
a260 1
	rescan,			/* | */
@


1.46
log
@Add some ctags support to mg. From Sunil Nimmagadda.

Man page review and suggestions from jmc@@

Revewied and tested by myself, and ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: keymap.c,v 1.45 2011/01/18 16:25:40 kjell Exp $	*/
a16 1
#ifndef NO_HELP
a40 1
#endif /* !NO_HELP */
a327 1
#ifndef NO_HELP
a328 3
#else /* !NO_HELP */
	rescan,			/* ^H */
#endif /* !NO_HELP */
a380 1
#ifndef NO_HELP
a383 5
#else /* !NO_HELP */
		{
			CCHR('@@'), CCHR('H'), fund_h, NULL
		},
#endif /* !NO_HELP */
a486 1
#ifndef NO_HELP
a487 1
#endif
@


1.45
log
@Add join-line, bound to M-^
Join the current line to the previous.

original diff by Henri Kemppainen. minor mod to add undo boundaries.
Thanks!
@
text
@d1 1
a1 1
/*	$OpenBSD: keymap.c,v 1.44 2011/01/17 03:12:06 kjell Exp $	*/
d207 3
d211 1
a211 1
	rescan,			/* . */
d304 1
a304 1
			'-', '>', metami, NULL
@


1.44
log
@Add back-to-indentation. (M-m)
Move the dot to the first non-whitespace character on the current line.
from Henri Kemppainen . ok theo
@
text
@d1 1
a1 1
/*	$OpenBSD: keymap.c,v 1.43 2008/08/27 04:11:52 kjell Exp $	*/
d231 1
a231 1
	rescan,			/* ^ */
@


1.43
log
@add a C-c target, so we can use it as a prefix for keybindings.
Now you can do something like:
  global-set-key "\^c\^c" compile
in your ~/.mg
@
text
@d1 1
a1 1
/*	$OpenBSD: keymap.c,v 1.42 2008/06/14 08:46:30 kjell Exp $	*/
d244 1
a244 1
	rescan,			/* m */
@


1.42
log
@We do not need a whole MODE for blinking one character.

both emacsen automatically blink, so mg should too. This can be
overridden in your ~/.mg by adding, e.g.

global-set-key ")" self-insert-command

So, I've eliminated blink mode, and renamed "blink-matching-paren-hack"
to "blink-and-insert". It's not just for parens anyway.

While I'm here, set up an empty (rescan) target for backtab, so I can
bind something convenient to it; e.g.

global-set-key "\e[Z" backward-char

Finally, remove all references to Scribd.
Theo doesn't hate this, though I would hesitate to call it an ok.
@
text
@d1 1
a1 1
/*	$OpenBSD: keymap.c,v 1.41 2008/06/12 21:13:20 kjell Exp $	*/
d44 12
d319 1
a319 1
	rescan,			/* ^C */
d324 3
d334 1
d376 3
a378 3
static struct KEYMAPE (5 + NFUND_XMAPS + IMAPEXT) fundmap = {
	5 + NFUND_XMAPS,
	5 + NFUND_XMAPS + IMAPEXT,
d381 3
d386 1
a386 1
			CCHR('@@'), CCHR('H'), fund_at, (KEYMAP *) & helpmap
d390 1
a390 1
			CCHR('@@'), CCHR('H'), fund_at, NULL
@


1.41
log
@Whitespace
@
text
@d1 1
a1 1
/*	$OpenBSD: keymap.c,v 1.40 2008/06/11 23:18:33 kjell Exp $	*/
d215 2
a216 1
static PF metabsl[] = {
d251 4
d260 11
d292 1
a292 1
			'\\', 'f', metabsl, NULL
d352 4
d360 3
a362 3
static struct KEYMAPE (4 + NFUND_XMAPS + IMAPEXT) fundmap = {
	4 + NFUND_XMAPS,
	4 + NFUND_XMAPS + IMAPEXT,
d381 3
a422 15
static PF blink_rp[] = {
	showmatch		/* ) */
};

static struct KEYMAPE (1 + IMAPEXT) blinkmap = {
	1,
	1 + IMAPEXT,
	rescan,
	{
		{
			')', ')', blink_rp, NULL
		}
	}
};

a469 1
	{(KEYMAP *) &blinkmap, "blink",},
@


1.40
log
@Add delete-leading-space, delete-trailing-space,
indent-current-line utility functions for stripping leading/trailing
whitespace, and setting a fixed indent respectively.
@
text
@d1 1
a1 1
/*	$OpenBSD: keymap.c,v 1.39 2006/08/18 00:22:56 kjell Exp $	*/
d378 1
a378 3
		{
			' ', ' ', fill_sp, NULL
		}
@


1.39
log
@Move  backward-paragraph, forward-paragraph to M-{, M-} respectively.
(not M-[, M-]). This is where emacs has it.
@
text
@d1 1
a1 1
/*	$OpenBSD: keymap.c,v 1.38 2006/07/27 19:59:29 deraadt Exp $	*/
d305 1
a305 1
	indent,			/* ^J */
d388 1
a388 1
	indent			/* ^M */
@


1.38
log
@unused function
@
text
@d1 1
a1 1
/*	$OpenBSD: keymap.c,v 1.37 2005/11/18 20:56:53 deraadt Exp $	*/
d215 1
a215 2
static PF metalb[] = {
	gotobop,		/* [ */
d217 1
a217 1
	gotoeop,		/* ] */
d242 6
a247 1
	extend			/* x */
d276 1
a276 1
			'[', 'f', metalb, NULL
d279 1
a279 1
			'l', 'x', metal, NULL
@


1.37
log
@greedy use of typedef struct was making code harder to read; ok kjell cloder
@
text
@d1 1
a1 1
/*	$OpenBSD: keymap.c,v 1.36 2005/11/07 23:32:20 kjell Exp $	*/
a506 11
}

const char *
map_name(KEYMAP *map)
{
	struct maps_s	*mp;

	for (mp = maps; mp != NULL; mp = mp->p_next)
		if (mp->p_map == map)
			return (mp->p_name);
	return (NULL);
@


1.36
log
@Move most of the dired hooks into dired.c.  While here, enable some
dired functions that were written, but not bound to keys. No other
functional change.

Tested by Han Boetes.
@
text
@d1 1
a1 1
/*	$OpenBSD: keymap.c,v 1.35 2005/10/13 20:28:49 deraadt Exp $	*/
d446 1
a446 1
MAPS	fundamental_mode = { (KEYMAP *)&fundmap, "fundamental" };
d457 1
a457 1
static MAPS map_table[] = {
d474 1
a474 1
MAPS *maps;
d480 1
a480 1
	MAPS	*mp;
d496 1
a496 1
	MAPS	*mp;
d512 1
a512 1
	MAPS	*mp;
d520 1
a520 1
MAPS *
d523 1
a523 1
	MAPS	*mp;
d534 2
a535 1
	MAPS	*mp;
@


1.35
log
@spacing
@
text
@d1 1
a1 1
/*	$OpenBSD: keymap.c,v 1.34 2005/10/13 06:20:25 kjell Exp $	*/
a119 3
#ifndef NO_DIRED
	dired,			/* d */
#else /* !NO_DIRED */
a120 1
#endif /* !NO_DIRED */
@


1.34
log
@add the (emacs) toggle-readonly keybinding (C-x C-q).
Also, remove a silly non-emacsism.
@
text
@d1 1
a1 1
/*	$OpenBSD: keymap.c,v 1.33 2005/10/13 05:47:45 kjell Exp $	*/
d449 1
a449 1
 */  
@


1.33
log
@Fix dired mode. Make deletions work, and keystrokes match emacs.
* dired-other-window should default to current buffer's path.
* Remove redundant code (from Han Boetes)
* Move initialization (and since we're here, fix mail-mode initialization
  too)
* Remove redundant keymap in dired.c, and replace it with
  the better one that was being ignored in keymap.c.
@
text
@d1 1
a1 1
/*	$OpenBSD: keymap.c,v 1.32 2005/10/11 00:50:00 kjell Exp $	*/
d84 1
a84 1
	rescan,			/* ^Q */
@


1.32
log
@Enable the 'next-error' (C-x `) keybinding by default.
Niklas, this one is for you.
ok deraadt@@, cloder@@
@
text
@d1 1
a1 1
/*	$OpenBSD: keymap.c,v 1.31 2005/10/06 20:02:10 kjell Exp $	*/
d29 1
a29 1
static struct KEYMAPE (2 + IMAPEXT) helpmap = {
d149 1
a149 1
static struct KEYMAPE (6 + IMAPEXT) cXmap = {
d255 1
a255 1
static struct KEYMAPE (8 + IMAPEXT) metamap = {
a445 105
#ifndef NO_DIRED
static PF dirednul[] = {
	setmark,		/* ^@@ */
	gotobol,		/* ^A */
	backchar,		/* ^B */
	rescan,			/* ^C */
	d_del,			/* ^D */
	gotoeol,		/* ^E */
	forwchar,		/* ^F */
	ctrlg,			/* ^G */
#ifndef NO_HELP
	NULL,			/* ^H */
#endif /* !NO_HELP */
};

static PF diredcl[] = {
	reposition,		/* ^L */
	forwline,		/* ^M */
	forwline,		/* ^N */
	rescan,			/* ^O */
	backline,		/* ^P */
	rescan,			/* ^Q */
	backisearch,		/* ^R */
	forwisearch,		/* ^S */
	rescan,			/* ^T */
	universal_argument,	/* ^U */
	forwpage,		/* ^V */
	rescan,			/* ^W */
	NULL			/* ^X */
};

static PF diredcz[] = {
	spawncli,		/* ^Z */
	NULL,			/* esc */
	rescan,			/* ^\ */
	rescan,			/* ^] */
	rescan,			/* ^^ */
	rescan,			/* ^_ */
	forwline		/* SP */
};

static PF diredc[] = {
	d_copy,			/* c */
	d_del,			/* d */
	d_findfile,		/* e */
	d_findfile		/* f */
};

static PF diredn[] = {
	forwline,		/* n */
	d_ffotherwindow,	/* o */
	backline,		/* p */
	rescan,			/* q */
	d_rename,		/* r */
	rescan,			/* s */
	rescan,			/* t */
	d_undel,		/* u */
	rescan,			/* v */
	rescan,			/* w */
	d_expunge		/* x */
};

static PF direddl[] = {
	d_undelbak		/* del */
};

#ifndef	DIRED_XMAPS
#define	NDIRED_XMAPS	0	/* number of extra map sections */
#endif /* DIRED_XMAPS */

static struct KEYMAPE (6 + NDIRED_XMAPS + IMAPEXT) diredmap = {
	6 + NDIRED_XMAPS,
	6 + NDIRED_XMAPS + IMAPEXT,
	rescan,
	{
#ifndef NO_HELP
		{
			CCHR('@@'), CCHR('H'), dirednul, (KEYMAP *) & helpmap
		},
#else /* !NO_HELP */
		{
			CCHR('@@'), CCHR('G'), dirednul, NULL
		},
#endif /* !NO_HELP */
		{
			CCHR('L'), CCHR('X'), diredcl, (KEYMAP *) & cXmap
		},
		{
			CCHR('Z'), ' ', diredcz, (KEYMAP *) & metamap
		},
		{
			'c', 'f', diredc, NULL
		},
		{
			'n', 'x', diredn, NULL
		},
		{
			CCHR('?'), CCHR('?'), direddl, NULL
		},
#ifdef	DIRED_XMAPS
		DIRED_XMAPS,	/* map sections for dired mode keys	 */
#endif /* DIRED_XMAPS */
	}
};
#endif /* !NO_DIRED */
d447 3
a474 3
#ifndef NO_DIRED
	{(KEYMAP *) &diredmap, "dired",},
#endif
d494 3
@


1.31
log
@Add find-file-read-only keybinding (c-X c-R), as in emacs.
closes PR4523. Enjoy, jason!
@
text
@d1 1
a1 1
/*	$OpenBSD: keymap.c,v 1.30 2005/06/14 18:14:40 kjell Exp $	*/
d116 1
a116 1
	rescan,			/* ` */
@


1.30
log
@Add explicit public domain notices to all public domain files.
ok millert@@, deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: keymap.c,v 1.29 2005/05/30 13:13:50 jason Exp $	*/
d85 1
a85 1
	rescan,			/* ^R */
@


1.29
log
@add find-alternate-file command and binding for ^X^V; ok cloder
(you're welcome kjell)
@
text
@d1 3
a3 1
/*	$OpenBSD: keymap.c,v 1.28 2005/04/03 02:09:28 db Exp $	*/
@


1.28
log
@This is a no binary change which does:

- spelling, punctuation fixes
- variable declaration lineup
- use parentheses for return and sizeof
- K&R function declarations -> ANSI
- other minor code beautification

ok henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: keymap.c,v 1.27 2005/03/09 16:20:48 jfb Exp $	*/
d87 1
a87 1
	rescan,			/* ^V */
@


1.27
log
@fix mg's behaviour with regards to files on which we do not have
write access.  diff originally from vincent@@ and forgotten for
a while.

ok rohee@@, "toss it in, i'll bitch if it doesn't work" henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: keymap.c,v 1.26 2002/12/09 08:20:46 deraadt Exp $	*/
d8 2
a9 2
#include	"def.h"
#include	"kbd.h"
d18 1
a18 1
	help_help,		/* ^H */
d24 1
a24 1
	desckey,		/* c */
d37 1
a37 1
		},
d44 1
a44 1
	ctrlg,			/* ^g */
d51 1
a51 1
	poptofile,		/* f */
d63 1
a63 1
		},
d73 1
a73 1
	ctrlg,			/* ^G */
d89 1
a89 1
	swapmark,		/* ^X */
d95 1
a95 1
	finishmacro,		/* ) */
d104 1
a104 1
	NULL,			/* 4 */
d108 1
a108 1
	showcpos,		/* = */
d176 1
a176 1
		},
d181 1
a181 1
	ctrlg,			/* ^G */
d185 1
a185 1
	pagenext,		/* ^V */
d189 1
a189 1
	justone,		/* space */
d193 1
a193 1
	queryrepl,		/* % */
d214 1
a214 1
	gotoeob,		/* > */
d229 1
a229 1
	forwword,		/* f */
d245 1
a245 1
	extend,			/* x */
d250 1
a250 1
	delbword,		/* DEL */
d281 1
a281 1
		},
d319 1
a319 1
	spawncli,		/* ^Z */
d327 1
a327 1
	undo,			/* ^_ */
d331 1
a331 1
	backdel,		/* DEL */
d368 1
a368 1
	fillword,		/* ' ' */
d378 1
a378 1
		},
d386 1
a386 1
	indent,			/* ^M */
d396 1
a396 1
		},
d401 1
a401 1
	showmatch,		/* ) */
d411 1
a411 1
		},
d417 1
a417 1
	space_to_tabstop,	/* ^I */
d427 1
a427 1
		},
d440 1
a440 1
		},
d472 1
a472 1
	NULL,			/* ^X */
d482 1
a482 1
	forwline,		/* SP */
d489 1
a489 1
	d_findfile,		/* f */
d503 1
a503 1
	d_expunge,		/* x */
d507 1
a507 1
	d_undelbak,		/* del */
d550 1
a550 1
MAPS	fundamental_mode = { (KEYMAP *)&fundmap, "fundamental", };
d555 1
a555 1
 * name. Maps created dynamicly currently don't get added here, thus are
d578 1
a578 1
	{NULL, NULL},
d586 2
a587 2
	int i;
	MAPS *mp;
d600 1
a600 1
	MAPS *mp;
d603 1
a603 1
		return FALSE;
d610 1
a610 1
	return TRUE;
d616 1
a616 1
	MAPS *mp;
d620 2
a621 2
			return mp->p_name;
	return NULL;
d627 1
a627 1
	MAPS *mp;
d631 2
a632 2
			return mp;
	return NULL;
d639 1
a639 1
	return (mp = name_mode(name)) == NULL ? NULL : mp->p_map;
a640 1

@


1.26
log
@bind ^Xg to gotoline by default
@
text
@d1 1
a1 1
/*	$OpenBSD: keymap.c,v 1.25 2002/09/28 05:18:48 deraadt Exp $	*/
d133 1
a133 1
	killbuffer,		/* k */
@


1.25
log
@use rescan, not NULL, since ^X-t is not a prefix
@
text
@d1 1
a1 1
/*	$OpenBSD: keymap.c,v 1.24 2002/09/26 10:12:26 deraadt Exp $	*/
d129 1
a129 1
	rescan,			/* g */
@


1.24
log
@activate the two key sequences for undo again; ok art henning
@
text
@d1 1
a1 1
/*	$OpenBSD: keymap.c,v 1.23 2002/06/27 23:07:58 vincent Exp $	*/
d142 1
a142 1
	NULL,			/* t */
@


1.23
log
@seems c-x c-q is for the vc- mode. remove it.
@
text
@d1 1
a1 1
/*	$OpenBSD: keymap.c,v 1.22 2002/06/27 21:39:56 vincent Exp $	*/
d142 2
d175 1
a175 1
			'^', 's', cXcar, NULL
d327 1
a327 1
	rescan,			/* ^_ */
@


1.22
log
@ bind C-x C-q to toggle-read-only, just like emacs.

 ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: keymap.c,v 1.21 2002/05/29 20:25:00 vincent Exp $	*/
d82 1
a82 1
	togglereadonly,		/* ^Q */
@


1.21
log
@ zap the ctrl-x ctrl-v keybinding for find-file-read-only.  looks like
i need more studying of emacs' keybindings :-)

 ok art@@ (i guess that's what "vincent, zap out the keybinding" meant)
@
text
@d1 1
a1 1
/*	$OpenBSD: keymap.c,v 1.20 2002/05/29 12:32:51 vincent Exp $	*/
d82 1
a82 1
	rescan,			/* ^Q */
d87 1
a87 1
	rescan,		/* ^V */
@


1.20
log
@ add a function to visit a file read-only mapped to C-x C-v

 ok art@@
@
text
@d1 1
a1 1
/*	$OpenBSD: keymap.c,v 1.19 2002/03/11 13:02:56 vincent Exp $	*/
d87 1
a87 1
	filevisitro,		/* ^V */
@


1.19
log
@  * Move to ANSI function definitions.
  * Add a whole lot of consts where I thought it made sense

   no ok, but no objections either...
@
text
@d1 1
a1 1
/*	$OpenBSD: keymap.c,v 1.18 2002/03/01 19:05:40 deraadt Exp $	*/
d87 1
a87 1
	rescan,			/* ^V */
@


1.18
log
@disable undo until it is fixed to be (1) correct and (2) not crash like it does now
@
text
@d1 1
a1 1
/*	$OpenBSD: keymap.c,v 1.15 2002/02/08 21:21:11 deraadt Exp $	*/
d596 1
a596 1
maps_add(KEYMAP *map, char *name)
d611 1
a611 1
char *
d623 1
a623 1
name_mode(char *name)
d634 1
a634 1
name_map(char *name)
@


1.17
log
@^Xu is also an undo char
@
text
@d1 1
a1 1
/*	$OpenBSD: keymap.c,v 1.16 2002/02/20 23:37:24 art Exp $	*/
a141 2
	NULL,			/* t */
	undo,			/* u */
d173 1
a173 1
			'^', 'u', cXcar, NULL
d325 1
a325 1
	undo,			/* ^_ */
@


1.16
log
@bind C-_ to undo.
@
text
@d1 1
a1 1
/*	$OpenBSD: keymap.c,v 1.15 2002/02/08 21:21:11 deraadt Exp $	*/
d142 2
d175 1
a175 1
			'^', 's', cXcar, NULL
@


1.15
log
@more gosmacs
@
text
@d1 1
a1 1
/*	$OpenBSD: keymap.c,v 1.14 2001/05/24 10:47:54 art Exp $	*/
d325 1
a325 1
	rescan,			/* ^_ */
@


1.14
log
@No need for those extra maps now.
@
text
@d1 1
a1 1
/*	$OpenBSD: keymap.c,v 1.13 2001/05/24 10:43:18 art Exp $	*/
d136 1
a136 1
	rescan,			/* n */
d138 1
a138 1
	rescan,			/* p */
@


1.13
log
@Make the keymap/mode table growable in runtime.
@
text
@d1 1
a1 1
/*	$OpenBSD: keymap.c,v 1.12 2001/05/24 09:47:34 art Exp $	*/
a41 30
static struct KEYMAPE (1 + IMAPEXT) extramap1 = {
	0,
	1 + IMAPEXT,
	rescan
};

static struct KEYMAPE (1 + IMAPEXT) extramap2 = {
	0,
	1 + IMAPEXT,
	rescan
};

static struct KEYMAPE (1 + IMAPEXT) extramap3 = {
	0,
	1 + IMAPEXT,
	rescan
};

static struct KEYMAPE (1 + IMAPEXT) extramap4 = {
	0,
	1 + IMAPEXT,
	rescan
};

static struct KEYMAPE (1 + IMAPEXT) extramap5 = {
	0,
	1 + IMAPEXT,
	rescan
};

a569 5
	{(KEYMAP *) &extramap1, "extra prefix 1",},
	{(KEYMAP *) &extramap2, "extra prefix 2",},
	{(KEYMAP *) &extramap3, "extra prefix 3",},
	{(KEYMAP *) &extramap4, "extra prefix 4",},
	{(KEYMAP *) &extramap5, "extra prefix 5",},
@


1.12
log
@Break out function -> name mappings to an own file.
Add a possibility to dynamically extend the function table.
@
text
@d1 1
a1 1
/*	$OpenBSD: keymap.c,v 1.11 2001/05/23 22:56:52 mickey Exp $	*/
d578 2
d589 4
a592 6
MAPS map_table[] = {
	/* fundamental map MUST be first entry */
	{(KEYMAP *) & fundmap, "fundamental"},
	{(KEYMAP *) & fillmap, "fill"},
	{(KEYMAP *) & indntmap, "indent"},
	{(KEYMAP *) & blinkmap, "blink"},
d594 1
a594 1
	{(KEYMAP *) & notabmap, "notab"},
d596 9
a604 9
	{(KEYMAP *) & overwmap, "overwrite"},
	{(KEYMAP *) & metamap, "esc prefix"},
	{(KEYMAP *) & cXmap, "c-x prefix"},
	{(KEYMAP *) & cX4map, "c-x 4 prefix"},
	{(KEYMAP *) & extramap1, "extra prefix 1"},
	{(KEYMAP *) & extramap2, "extra prefix 2"},
	{(KEYMAP *) & extramap3, "extra prefix 3"},
	{(KEYMAP *) & extramap4, "extra prefix 4"},
	{(KEYMAP *) & extramap5, "extra prefix 5"},
d606 1
a606 1
	{(KEYMAP *) & helpmap, "help"},
d609 1
a609 1
	{(KEYMAP *) & diredmap, "dired"},
d611 1
d614 15
a628 2
#define NMAPS	(sizeof map_table/sizeof(MAPS))
int	 nmaps = NMAPS;		/* for use by rebind in extend.c */
d630 15
a644 1
KEYMAP *fundamental_map = (KEYMAP *)&fundmap;
d647 1
a647 2
map_name(map)
	KEYMAP *map;
d649 1
a649 1
	MAPS	*mp = &map_table[0];
d651 1
a651 1
	do {
a653 1
	} while (++mp < &map_table[NMAPS]);
d658 1
a658 2
name_mode(name)
	char *name;
d660 1
a660 1
	MAPS	*mp = &map_table[0];
d662 1
a662 1
	do {
a664 1
	} while (++mp < &map_table[NMAPS]);
d669 1
a669 2
name_map(name)
	char *name;
@


1.11
log
@functnames can be const, some spaces
@
text
@d1 1
a1 1
/*	$OpenBSD: keymap.c,v 1.10 2001/05/23 22:36:14 art Exp $	*/
a10 2
static int	 name_fent	__P((char *, int));

a651 311
/*
 * Warning: functnames MUST be in alphabetical order!  (due to binary search
 * in name_function.)  If the function is NULL, it must be listed with the
 * same name in the map_table above.
 */
const FUNCTNAMES functnames[] = {
#ifndef	NO_HELP
	{apropos_command, "apropos"},
#endif /* !NO_HELP */
	{fillmode, "auto-fill-mode"},
	{indentmode, "auto-indent-mode"},
	{backchar, "backward-char"},
	{delbword, "backward-kill-word"},
	{gotobop, "backward-paragraph"},
	{backword, "backward-word"},
	{gotobob, "beginning-of-buffer"},
	{gotobol, "beginning-of-line"},
	{blinkparen, "blink-matching-paren"},
	{showmatch, "blink-matching-paren-hack"},
#ifdef BSMAP
	{bsmap, "bsmap-mode"},
#endif /* BSMAP */
	{NULL, "c-x 4 prefix"},
	{NULL, "c-x prefix"},
#ifndef NO_MACRO
	{executemacro, "call-last-kbd-macro"},
#endif /* !NO_MACRO */
	{capword, "capitalize-word"},
#ifndef NO_DIR
	{changedir, "cd"},
#endif /* !NO_DIR */
	{copyregion, "copy-region-as-kill"},
#ifdef	REGEX
	{cntmatchlines, "count-matches"},
	{cntnonmatchlines, "count-non-matches"},
#endif /* REGEX */
	{define_key, "define-key"},
	{backdel, "delete-backward-char"},
	{deblank, "delete-blank-lines"},
	{forwdel, "delete-char"},
	{delwhite, "delete-horizontal-space"},
#ifdef	REGEX
	{delmatchlines, "delete-matching-lines"},
	{delnonmatchlines, "delete-non-matching-lines"},
#endif /* REGEX */
	{onlywind, "delete-other-windows"},
	{delwind, "delete-window"},
#ifndef NO_HELP
	{wallchart, "describe-bindings"},
	{desckey, "describe-key-briefly"},
#endif /* !NO_HELP */
	{digit_argument, "digit-argument"},
#ifndef NO_DIRED
	{dired, "dired"},
	{d_undelbak, "dired-backup-unflag"},
	{d_copy, "dired-copy-file"},
	{d_expunge, "dired-do-deletions"},
	{d_findfile, "dired-find-file"},
	{d_ffotherwindow, "dired-find-file-other-window"},
	{d_del, "dired-flag-file-deleted"},
	{d_otherwindow, "dired-other-window"},
	{d_rename, "dired-rename-file"},
	{d_undel, "dired-unflag"},
#endif /* !NO_DIRED */
	{lowerregion, "downcase-region"},
	{lowerword, "downcase-word"},
	{showversion, "emacs-version"},
#ifndef NO_MACRO
	{finishmacro, "end-kbd-macro"},
#endif /* !NO_MACRO */
	{gotoeob, "end-of-buffer"},
	{gotoeol, "end-of-line"},
	{enlargewind, "enlarge-window"},
	{NULL, "esc prefix"},
#ifndef NO_STARTUP
	{evalbuffer, "eval-current-buffer"},
	{evalexpr, "eval-expression"},
#endif /* !NO_STARTUP */
	{swapmark, "exchange-point-and-mark"},
	{extend, "execute-extended-command"},
	{NULL, "extra prefix 1"},
	{NULL, "extra prefix 2"},
	{NULL, "extra prefix 3"},
	{NULL, "extra prefix 4"},
	{NULL, "extra prefix 5"},
	{fillpara, "fill-paragraph"},
	{filevisit, "find-file"},
	{poptofile, "find-file-other-window"},
	{forwchar, "forward-char"},
	{gotoeop, "forward-paragraph"},
	{forwword, "forward-word"},
	{bindtokey, "global-set-key"},
	{unbindtokey, "global-unset-key"},
	{gotoline, "goto-line"},
#ifndef NO_HELP
	{NULL, "help"},
	{help_help, "help-help"},
#endif /* !NO_HELP */
	{insert, "insert"},
	{bufferinsert, "insert-buffer"},
	{fileinsert, "insert-file"},
	{fillword, "insert-with-wrap"},
	{backisearch, "isearch-backward"},
	{forwisearch, "isearch-forward"},
	{justone, "just-one-space"},
	{ctrlg, "keyboard-quit"},
	{killbuffer, "kill-buffer"},
	{killline, "kill-line"},
	{killpara, "kill-paragraph"},
	{killregion, "kill-region"},
	{delfword, "kill-word"},
	{listbuffers, "list-buffers"},
#ifndef NO_STARTUP
	{evalfile, "load"},
#endif /* !NO_STARTUP */
	{localbind, "local-set-key"},
	{localunbind, "local-unset-key"},
#ifndef NO_BACKUP
	{makebkfile, "make-backup-files"},
#endif /* !NO_BACKUP */
#ifdef DO_METAKEY
	{do_meta, "meta-key-mode"},	/* better name, anyone? */
#endif /* DO_METAKEY */
	{negative_argument, "negative-argument"},
	{newline, "newline"},
	{indent, "newline-and-indent"},
	{forwline, "next-line"},
#ifdef NOTAB
	{notabmode, "no-tab-mode"},
#endif /* NOTAB */
	{notmodified, "not-modified"},
	{openline, "open-line"},
	{nextwind, "other-window"},
	{overwrite, "overwrite-mode"},
#ifdef PREFIXREGION
	{prefixregion, "prefix-region"},
#endif /* PREFIXREGION */
	{backline, "previous-line"},
#ifdef GOSMACS
	{prevwind, "previous-window"},
#endif /* GOSEMACS */
	{spawncli, "push-shell"},
#ifndef NO_DIR
	{showcwdir, "pwd"},
#endif /* !NO_DIR */
	{queryrepl, "query-replace"},
#ifdef REGEX
	{re_queryrepl, "query-replace-regexp"},
#endif /* REGEX */
	{quote, "quoted-insert"},
#ifdef REGEX
	{re_searchagain, "re-search-again"},
	{re_backsearch, "re-search-backward"},
	{re_forwsearch, "re-search-forward"},
#endif /* REGEX */
	{reposition, "recenter"},
	{refresh, "redraw-display"},
	{filesave, "save-buffer"},
	{quit, "save-buffers-kill-emacs"},
	{savebuffers, "save-some-buffers"},
	{backpage, "scroll-down"},
#ifdef GOSMACS
	{back1page, "scroll-one-line-down"},
	{forw1page, "scroll-one-line-up"},
#endif /* GOSMACS */
	{pagenext, "scroll-other-window"},
	{forwpage, "scroll-up"},
	{searchagain, "search-again"},
	{backsearch, "search-backward"},
	{forwsearch, "search-forward"},
	{selfinsert, "self-insert-command"},
#ifdef REGEX
	{setcasefold, "set-case-fold-search"},
#endif /* REGEX */
	{set_default_mode, "set-default-mode"},
	{setfillcol, "set-fill-column"},
	{setmark, "set-mark-command"},
#ifdef PREFIXREGION
	{setprefix, "set-prefix-string"},
#endif /* PREFIXREGION */
	{shrinkwind, "shrink-window"},
#ifdef NOTAB
	{space_to_tabstop, "space-to-tabstop"},
#endif /* NOTAB */
	{splitwind, "split-window-vertically"},
#ifndef NO_MACRO
	{definemacro, "start-kbd-macro"},
#endif /* !NO_MACRO */
	{spawncli, "suspend-emacs"},
	{usebuffer, "switch-to-buffer"},
	{poptobuffer, "switch-to-buffer-other-window"},
	{twiddle, "transpose-chars"},
	{universal_argument, "universal-argument"},
	{upperregion, "upcase-region"},
	{upperword, "upcase-word"},
	{showcpos, "what-cursor-position"},
	{filewrite, "write-file"},
	{yank, "yank"},
};

#define NFUNCT	(sizeof(functnames)/sizeof(FUNCTNAMES))

/*
 * The general-purpose version of ROUND2 blows osk C (2.0) out of the water.
 * (reboot required)  If you need to build a version of mg with less than 32
 * or more than 511 functions, something better must be done.
 * The version that should work, but doesn't is:
 * #define ROUND2(x) (1+((x>>1)|(x>>2)|(x>>3)|(x>>4)|(x>>5)|(x>>6)|(x>>7)|\
 *	(x>>8)|(x>>9)|(x>>10)|(x>>11)|(x>>12)|(x>>13)|(x>>14)|(x>>15)))
 */
#define ROUND2(x) (x<128?(x<64?32:64):(x<256?128:256))

static int
name_fent(fname, flag)
	char *fname;
	int   flag;
{
	int	 try, notit;
	int	 x = ROUND2(NFUNCT);
	int	 base = 0;

	do {
		/* + can be used instead of | here if more efficent.	 */
		if ((try = base | x) < NFUNCT) {
			if ((notit = strcmp(fname, functnames[try].n_name))
			    >= 0) {
				if (!notit)
					return try;
				base = try;
			}
		}
	/* try 0 once if needed */
	} while ((x >>= 1) || (try == 1 && base == 0));
	return flag ? base : -1;
}

/*
 * Translate from function name to function pointer, using binary search.
 */

PF
name_function(fname)
	char *fname;
{
	int	 i;
	if ((i = name_fent(fname, FALSE)) >= 0)
		return functnames[i].n_funct;
	return (PF)NULL;
}

/*
 * list possible function name completions.
 */
LIST *
complete_function_list(fname, c)
	char *fname;
	int   c;
{
	int	 i, j, k, l;
	LIST	*current, *last;

	i = name_fent(fname, TRUE);
	for (j = 0; (l = fname[j]) && functnames[i].n_name[j] == l; j++);
	if (fname[j] != '\0') {
		if (++i >= NFUNCT)
			/* no match */
			return NULL;
		for (j = 0; (l = fname[j]) && functnames[i].n_name[j] == l;
		    j++);
		if (fname[j] != '\0')
			/* no match */
			return NULL;
	}
	/*
	 * if(c==CCHR('M') && functnames[i].n_name[j]=='\0') return -1;
	 */
	/* find last match */
	for (k = i + 1; k < NFUNCT; k++) {
		for (l = 0; functnames[k].n_name[l] == fname[l]; l++);
		if (l < j)
			break;
	}
	k--;
	last = NULL;
	for (; k >= i; k--) {
		current = (LIST *)malloc(sizeof(LIST));
		current->l_next = last;
		current->l_name = functnames[k].n_name;
		last = current;
	}
	return (last);
}

/*
 * translate from function pointer to function name.
 */
char *
function_name(fpoint)
	PF fpoint;
{
	const FUNCTNAMES	*fnp = &functnames[0];

	if (fpoint == NULL)
		/* ambiguous */
		return NULL;
	do {
		if (fnp->n_funct == fpoint)
			return fnp->n_name;
	} while (++fnp < &functnames[NFUNCT]);
	return NULL;
}
@


1.10
log
@Get rid of unnecessary casts of NULL.
@
text
@d1 1
a1 1
/*	$OpenBSD: keymap.c,v 1.9 2001/05/23 22:10:43 art Exp $	*/
d4 1
a4 1
 * Keyboard maps.  This is character set dependent.  The terminal specific 
d14 1
a14 1
 * initial keymap declarations, deepest first 
d659 1
a659 1
FUNCTNAMES functnames[] = {
d878 1
a878 1
			if ((notit = strcmp(fname, functnames[try].n_name)) 
d921 1
a921 1
		for (j = 0; (l = fname[j]) && functnames[i].n_name[j] == l; 
d954 1
a954 1
	FUNCTNAMES	*fnp = &functnames[0];
@


1.9
log
@export "fundamental_map" that points to the fundamental keymap
@
text
@d1 1
a1 1
/*	$OpenBSD: keymap.c,v 1.8 2001/05/23 21:59:45 art Exp $	*/
d35 1
a35 1
			CCHR('G'), CCHR('H'), cHcG, (KEYMAP *)NULL
d38 1
a38 1
			'a', 'c', cHa, (KEYMAP *)NULL
d91 1
a91 1
			CCHR('F'), CCHR('G'), cX4cF, (KEYMAP *)NULL
d94 1
a94 1
			'b', 'f', cX4b, (KEYMAP *)NULL
d188 1
a188 1
			CCHR('B'), CCHR('G'), cXcB, (KEYMAP *)NULL
d191 1
a191 1
			CCHR('L'), CCHR('X'), cXcL, (KEYMAP *)NULL
d195 1
a195 1
			'(', ')', cXlp, (KEYMAP *)NULL
d202 1
a202 1
			'=', '=', cXeq, (KEYMAP *)NULL
d205 1
a205 1
			'^', 's', cXcar, (KEYMAP *)NULL
d289 1
a289 1
			CCHR('G'), CCHR('G'), metacG, (KEYMAP *)NULL
d292 1
a292 1
			CCHR('V'), CCHR('V'), metacV, (KEYMAP *)NULL
d295 1
a295 1
			' ', ' ', metasp, (KEYMAP *)NULL
d298 1
a298 1
			'%', '%', metapct, (KEYMAP *)NULL
d301 1
a301 1
			'-', '>', metami, (KEYMAP *)NULL
d304 1
a304 1
			'[', 'f', metalb, (KEYMAP *)NULL
d307 1
a307 1
			'l', 'x', metal, (KEYMAP *) NULL
d310 1
a310 1
			'~', CCHR('?'), metatilde, (KEYMAP *)NULL
d379 1
a379 1
			CCHR('@@'), CCHR('H'), fund_at, (KEYMAP *)NULL
d389 1
a389 1
			CCHR('?'), CCHR('?'), fund_del, (KEYMAP *)NULL
d407 1
a407 1
			' ', ' ', fill_sp, (KEYMAP *)NULL
d425 1
a425 1
			CCHR('J'), CCHR('M'), indent_lf, (KEYMAP *)NULL
d440 1
a440 1
			')', ')', blink_rp, (KEYMAP *)NULL
d456 1
a456 1
			CCHR('I'), CCHR('I'), notab_tab, (KEYMAP *)NULL
d469 1
a469 1
			(KCHAR)0, (KCHAR)0, (PF *)NULL, (KEYMAP *)NULL
d555 1
a555 1
			CCHR('@@'), CCHR('G'), dirednul, (KEYMAP *)NULL
d565 1
a565 1
			'c', 'f', diredc, (KEYMAP *)NULL
d568 1
a568 1
			'n', 'x', diredn, (KEYMAP *)NULL
d571 1
a571 1
			CCHR('?'), CCHR('?'), direddl, (KEYMAP *)NULL
d630 1
a630 1
	return (char *)NULL;
d643 1
a643 1
	return (MAPS *)NULL;
d651 1
a651 1
	return (mp = name_mode(name)) == NULL ? (KEYMAP *)NULL : mp->p_map;
d958 1
a958 1
		return (char *)NULL;
d963 1
a963 1
	return (char *)NULL;
@


1.8
log
@No need to export nfunct and functnames now that help doesn't use them
anymore. nfunct isn't used anywhere.
@
text
@d1 1
a1 1
/*	$OpenBSD: keymap.c,v 1.7 2001/05/23 16:26:39 art Exp $	*/
d617 2
@


1.7
log
@kill complete_function. Not used anymore.
@
text
@d1 1
a1 1
/*	$OpenBSD: keymap.c,v 1.6 2001/05/23 16:14:00 art Exp $	*/
a852 2

int	 nfunct = NFUNCT;	/* used by help.c */
@


1.6
log
@Get rid of 'prefix' and use NULL instead.
@
text
@d1 1
a1 1
/*	$OpenBSD: keymap.c,v 1.5 2001/01/29 01:58:08 niklas Exp $	*/
a901 57
}

/*
 * complete function name
 */
int
complete_function(fname, c)
	char *fname;
	int   c;
{
	int	i, j, k, l, oj;

	i = name_fent(fname, TRUE);
	for (j = 0; (l = fname[j]) && functnames[i].n_name[j] == l; j++) {
	}
	if (fname[j] != '\0') {
		if (++i >= NFUNCT)
			/* no match */
			return -2;
		for (j = 0; (l = fname[j]) && functnames[i].n_name[j] == l; 
		    j++);
		if (fname[j] != '\0')
			/* no match */
			return -2;
	}
	if (c == CCHR('M') && functnames[i].n_name[j] == '\0')
		return -1;
	/* find last match */
	for (k = i + 1; k < NFUNCT; k++) {
		for (l = 0; functnames[k].n_name[l] == fname[l]; l++);
		if (l < j)
			break;
	}
	k--;
	oj = j;

	if (k > i) {
		/* multiple matches */
		while ((l = functnames[i].n_name[j]) == 
		    functnames[k].n_name[j]) {
			fname[j++] = l;
			if (l == '-' && c == ' ')
				break;
		}
		if (j == oj)
			/* ambiguous */
			return -3;
	} else {
		/* single match */
		while ((l = functnames[i].n_name[j])) {
			fname[j++] = l;
			if (l == '-' && c == ' ')
				break;
		}
	}
	fname[j] = '\0';
	return j - oj;
@


1.5
log
@$OpenBSD$
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d136 1
a136 1
	prefix,			/* 4 */
d325 1
a325 1
	prefix,			/* ^H */
d347 1
a347 1
	prefix,			/* ^X */
d353 1
a353 1
	prefix,			/* esc */
d485 1
a485 1
	prefix,			/* ^H */
d502 1
a502 1
	prefix,			/* ^X */
d507 1
a507 1
	prefix,			/* esc */
d654 1
a654 1
 * in name_function.)  If the function is prefix, it must be listed with the
d674 2
a675 2
	{prefix, "c-x 4 prefix"},
	{prefix, "c-x prefix"},
d725 1
a725 1
	{prefix, "esc prefix"},
d732 5
a736 5
	{prefix, "extra prefix 1"},
	{prefix, "extra prefix 2"},
	{prefix, "extra prefix 3"},
	{prefix, "extra prefix 4"},
	{prefix, "extra prefix 5"},
d747 1
a747 1
	{prefix, "help"},
d1013 1
a1013 1
	if (fpoint == prefix)
@


1.4
log
@More -Wall anmd KNF, from op2@@tomahawk.SQUiSH.org
@
text
@d1 2
@


1.3
log
@The start of KNF + -Wall.  The code has been run through indent but
needs hand fixup.  I stopped at keymap.c...
@
text
@d2 2
a3 3
 * Keyboard maps.  This is character set dependent.
 * The terminal specific parts of building the
 * keymap has been moved to a better place.
d5 1
d9 1
a9 8
/*
 * defined by "macro.c"
 */
#ifndef NO_MACRO
extern int      definemacro();	/* Begin macro			 */
extern int      finishmacro();	/* End macro			 */
extern int      executemacro();	/* Execute macro		 */
#endif
d12 1
a12 1
 * Defined by "main.c".
a13 178
extern int      ctrlg();	/* Abort out of things		 */
extern int      quit();		/* Quit				 */

/*
 * Defined by "match.c"
 */
extern int      showmatch();	/* Hack to show matching paren	 */

/* defined by "modes.c" */

extern int      indentmode();	/* set auto-indent mode		 */
extern int      fillmode();	/* set word-wrap mode		 */
extern int      blinkparen();	/* Fake blink-matching-paren var */
#ifdef	NOTAB
extern int      notabmode();	/* no tab mode			 */
#endif
extern int      overwrite();	/* overwrite mode		 */
extern int      set_default_mode();	/* set default modes		 */

/*
 * defined by "paragraph.c" - the paragraph justification code.
 */
extern int      gotobop();	/* Move to start of paragraph.	 */
extern int      gotoeop();	/* Move to end of paragraph.	 */
extern int      fillpara();	/* Justify a paragraph.		 */
extern int      killpara();	/* Delete a paragraph.		 */
extern int      setfillcol();	/* Set fill column for justify. */
extern int      fillword();	/* Insert char with word wrap.	 */

/*
 * Defined by "random.c".
 */
extern int      showcpos();	/* Show the cursor position	 */
extern int      twiddle();	/* Twiddle characters		 */
extern int      quote();	/* Insert literal		 */
extern int      openline();	/* Open up a blank line		 */
extern int      newline();	/* Insert newline		 */
extern int      deblank();	/* Delete blank lines		 */
extern int      justone();	/* Delete extra whitespace	 */
extern int      delwhite();	/* Delete all whitespace	 */
extern int      indent();	/* Insert newline, then indent	 */
extern int      forwdel();	/* Forward delete		 */
extern int      backdel();	/* Backward delete in		 */
extern int      killline();	/* Kill forward			 */
extern int      yank();		/* Yank back from killbuffer.	 */
#ifdef NOTAB
extern int      space_to_tabstop();
#endif

#ifdef	REGEX
/*
 * Defined by "re_search.c"
 */
extern int      re_forwsearch();/* Regex search forward		 */
extern int      re_backsearch();/* Regex search backwards	 */
extern int      re_searchagain();	/* Repeat regex search command	 */
extern int      re_queryrepl();	/* Regex query replace		 */
extern int      setcasefold();	/* Set case fold in searches	 */
extern int      delmatchlines();/* Delete all lines matching	 */
extern int      delnonmatchlines();	/* Delete all lines not matching */
extern int      cntmatchlines();/* Count matching lines		 */
extern int      cntnonmatchlines();	/* Count nonmatching lines	 */
#endif

/*
 * Defined by "region.c".
 */
extern int      killregion();	/* Kill region.			 */
extern int      copyregion();	/* Copy region to kill buffer.	 */
extern int      lowerregion();	/* Lower case region.		 */
extern int      upperregion();	/* Upper case region.		 */
#ifdef	PREFIXREGION
extern int      prefixregion();	/* Prefix all lines in region	 */
extern int      setprefix();	/* Set line prefix string	 */
#endif

/*
 * Defined by "search.c".
 */
extern int      forwsearch();	/* Search forward		 */
extern int      backsearch();	/* Search backwards		 */
extern int      searchagain();	/* Repeat last search command	 */
extern int      forwisearch();	/* Incremental search forward	 */
extern int      backisearch();	/* Incremental search backwards */
extern int      queryrepl();	/* Query replace		 */

/*
 * Defined by "spawn.c".
 */
extern int      spawncli();		/* Run CLI in a subjob.		 */
#ifdef	VMS
extern int      attachtoparent();	/* Attach to parent process	 */
#endif

/* defined by "version.c" */

extern int      showversion();	/* Show version numbers, etc.	 */

/*
 * Defined by "window.c".
 */
extern int      reposition();	/* Reposition window		 */
extern int      refresh();	/* Refresh the screen		 */
extern int      nextwind();	/* Move to the next window	 */
#ifdef	GOSMACS
extern int      prevwind();	/* Move to the previous window	 */
#endif
extern int      onlywind();	/* Make current window only one */
extern int      splitwind();	/* Split current window		 */
extern int      delwind();	/* Delete current window	 */
extern int      enlargewind();	/* Enlarge display window.	 */
extern int      shrinkwind();	/* Shrink window.		 */

/*
 * Defined by "word.c".
 */
extern int      backword();	/* Backup by words		 */
extern int      forwword();	/* Advance by words		 */
extern int      upperword();	/* Upper case word.		 */
extern int      lowerword();	/* Lower case word.		 */
extern int      capword();	/* Initial capitalize word.	 */
extern int      delfword();	/* Delete forward word.		 */
extern int      delbword();	/* Delete backward word.	 */

#ifdef	AMIGA
#ifdef	DO_ICONIFY
extern int      tticon();
#endif
#ifdef	DO_MENU
extern int      amigamenu();	/* Menu function		 */
#endif
#ifdef	MOUSE
extern int      amigamouse();	/* Amiga mouse functions	 */
extern int      mgotobob();
extern int      mforwdel();
extern int      mdelwhite();
extern int      mdelwind();
extern int      mgotoeob();
extern int      menlargewind();
extern int      mkillline();
extern int      mkillregion();
extern int      mdelfword();
extern int      mreposition();
extern int      mbackpage();
extern int      mforwpage();
extern int      mshrinkwind();
extern int      msplitwind();
extern int      myank();
#endif				/* MOUSE */

extern int      togglewindow();	/* Defined by "ttyio.c"		 */
extern int      togglezooms();	/* ""         ""		 */

#ifdef	CHANGE_FONT
extern int      setfont();	/* Defined by "ttyio.c"		 */
#endif

#ifdef	CHANGE_COLOR
/* functions to mess with the mode line rendition, window colors */
extern int      ttmode();	/* Defined by "tty.c"		 */
extern int      tttext();	/* ""				 */
extern int      textforeground();	/* ""				 */
extern int      textbackground();	/* ""				 */
extern int      modeforeground();	/* ""				 */
extern int      modebackground();	/* ""				 */
#endif

/*
 * This file contains map segment definitions for adding function keys to
 * keymap declarations.  Currently you can add things to the fundamental
 * mode keymap and the dired mode keymap.  See the declaration of
 * diredmap and fundmap for details.
 */
#include "amiga_maps.c"

#endif				/* AMIGA */

/* initial keymap declarations, deepest first */
d16 1
a16 1
static PF       cHcG[] = {
d20 2
a21 1
static PF       cHa[] = {
d26 1
d33 1
a33 1
			CCHR('G'), CCHR('H'), cHcG, (KEYMAP *) NULL
d36 1
a36 1
			'a', 'c', cHa, (KEYMAP *) NULL
d40 1
a40 1
#endif
d72 1
a72 1
static PF       cX4cF[] = {
d76 1
a76 1
static PF       cX4b[] = {
d89 1
a89 1
			CCHR('F'), CCHR('G'), cX4cF, (KEYMAP *) NULL
d92 1
a92 1
			'b', 'f', cX4b, (KEYMAP *) NULL
d97 1
a97 1
static PF       cXcB[] = {
d105 2
a106 1
static PF       cXcL[] = {
d121 1
d123 1
a123 1
static PF       cXlp[] = {
d127 3
a129 2
#endif
static PF       cX0[] = {
d136 2
a137 1
static PF       cXeq[] = {
d140 2
a141 1
static PF       cXcar[] = {
d150 1
a150 1
#else
d152 1
a152 1
#endif
d155 1
a155 1
#else
d157 1
a157 1
#endif
d173 1
d178 1
a178 1
#else
d182 1
a182 1
#endif
d186 1
a186 1
			CCHR('B'), CCHR('G'), cXcB, (KEYMAP *) NULL
d189 1
a189 1
			CCHR('L'), CCHR('X'), cXcL, (KEYMAP *) NULL
d193 1
a193 1
			'(', ')', cXlp, (KEYMAP *) NULL
d195 1
a195 1
#endif
d200 1
a200 1
			'=', '=', cXeq, (KEYMAP *) NULL
d203 1
a203 1
			'^', 's', cXcar, (KEYMAP *) NULL
d208 1
a208 1
static PF       metacG[] = {
d211 2
a212 1
static PF       metacV[] = {
d215 2
a216 1
static PF       metasp[] = {
d219 2
a220 1
static PF       metapct[] = {
d223 2
a224 1
static PF       metami[] = {
d244 2
a245 1
static PF       metalb[] = {
d259 2
a260 1
static PF       metal[] = {
d275 2
a276 1
static PF       metatilde[] = {
d280 1
d287 1
a287 1
			CCHR('G'), CCHR('G'), metacG, (KEYMAP *) NULL
d290 1
a290 1
			CCHR('V'), CCHR('V'), metacV, (KEYMAP *) NULL
d293 1
a293 1
			' ', ' ', metasp, (KEYMAP *) NULL
d296 1
a296 1
			'%', '%', metapct, (KEYMAP *) NULL
d299 1
a299 1
			'-', '>', metami, (KEYMAP *) NULL
d302 1
a302 1
			'[', 'f', metalb, (KEYMAP *) NULL
d308 1
a308 1
			'~', CCHR('?'), metatilde, (KEYMAP *) NULL
d313 1
a313 1
static PF       fund_at[] = {
d324 1
a324 1
#else
d326 1
a326 1
#endif
d328 1
d330 1
a330 1
static PF       fund_CJ[] = {
a346 1
#ifndef	VMS
a347 3
#else
	attachtoparent,		/* ^Z */
#endif
d349 2
a350 1
static PF       fund_esc[] = {
d352 1
a352 2
	rescan,			/* ^\ *//* selfinsert is default on
				 * fundamental */
d357 2
a358 1
static PF       fund_del[] = {
d375 1
a375 1
#else
d377 1
a377 1
			CCHR('@@'), CCHR('H'), fund_at, (KEYMAP *) NULL
d379 1
a379 1
#endif
d387 1
a387 1
			CCHR('?'), CCHR('?'), fund_del, (KEYMAP *) NULL
d389 1
a389 1
#ifdef	FUND_XMAPS
d391 1
a391 1
#endif
d395 1
a395 1
static PF       fill_sp[] = {
d398 1
d405 1
a405 1
			' ', ' ', fill_sp, (KEYMAP *) NULL
d410 1
a410 1
static PF       indent_lf[] = {
d416 1
d423 1
a423 1
			CCHR('J'), CCHR('M'), indent_lf, (KEYMAP *) NULL
d427 2
a428 1
static PF       blink_rp[] = {
d431 1
d438 1
a438 1
			')', ')', blink_rp, (KEYMAP *) NULL
d443 2
a444 2
#ifdef	NOTAB
static PF       notab_tab[] = {
d447 1
d454 1
a454 1
			CCHR('I'), CCHR('I'), notab_tab, (KEYMAP *) NULL
d458 1
a458 1
#endif
d467 1
a467 1
			(KCHAR) 0, (KCHAR) 0, (PF *) NULL, (KEYMAP *) NULL
d473 1
a473 1
static PF       dirednul[] = {
d484 1
a484 1
#endif
d486 2
a487 1
static PF       diredcl[] = {
d502 2
a503 2
static PF       diredcz[] = {
#ifndef	VMS
a504 3
#else
	attachtoparent,		/* ^Z */
#endif
d512 2
a513 1
static PF       diredc[] = {
d519 2
a520 1
static PF       diredn[] = {
d533 2
a534 1
static PF       direddl[] = {
d540 1
a540 1
#endif
d551 1
a551 1
#else
d553 1
a553 1
			CCHR('@@'), CCHR('G'), dirednul, (KEYMAP *) NULL
d555 1
a555 1
#endif
d563 1
a563 1
			'c', 'f', diredc, (KEYMAP *) NULL
d566 1
a566 1
			'n', 'x', diredn, (KEYMAP *) NULL
d569 1
a569 1
			CCHR('?'), CCHR('?'), direddl, (KEYMAP *) NULL
d573 1
a573 1
#endif
d576 1
a576 1
#endif
d587 1
a587 1
MAPS            map_table[] = {
d593 1
a593 1
#ifdef	NOTAB
d595 1
a595 1
#endif
d614 1
a614 1
int             nmaps = NMAPS;	/* for use by rebind in extend.c */
d616 1
a616 1
char           *
d618 1
a618 1
	KEYMAP         *map;
d620 1
a620 1
	MAPS           *mp = &map_table[0];
d626 1
a626 1
	return (char *) NULL;
d629 1
a629 1
MAPS           *
d631 1
a631 1
	char           *name;
d633 1
a633 1
	MAPS           *mp = &map_table[0];
d639 1
a639 1
	return (MAPS *) NULL;
d642 1
a642 1
KEYMAP         *
d644 1
a644 1
	char           *name;
d646 2
a647 2
	MAPS           *mp;
	return (mp = name_mode(name)) == NULL ? (KEYMAP *) NULL : mp->p_map;
d655 1
a655 25

FUNCTNAMES      functnames[] = {
#ifdef	AMIGA
#ifdef	DO_ICONIFY
	{tticon, "amiga-iconify"},
#endif
#ifdef	DO_MENU
	{amigamenu, "amiga-menu"},
#endif
#ifdef	CHANGE_COLOR
	{modebackground, "amiga-mode-background"},
	{modeforeground, "amiga-mode-foreground"},
	{ttmode, "amiga-mode-rendition"},
#endif
#ifdef	CHANGE_FONT
	{setfont, "amiga-set-font"},
#endif
#ifdef	CHANGE_COLOR
	{textbackground, "amiga-text-background"},
	{textforeground, "amiga-text-foreground"},
	{tttext, "amiga-text-rendition"},
#endif
	{togglewindow, "amiga-toggle-border"},
	{togglezooms, "amiga-zoom-mode"},
#endif				/* AMIGA */
d658 1
a658 1
#endif
d669 1
a669 1
#ifdef	BSMAP
d671 1
a671 1
#endif
d676 1
a676 1
#endif
d680 1
a680 1
#endif
d685 1
a685 1
#endif
d694 1
a694 1
#endif
d700 1
a700 1
#endif
d713 1
a713 1
#endif
d719 1
a719 1
#endif
d727 1
a727 1
#endif
d747 1
a747 1
#endif
d764 1
a764 1
#endif
d769 2
a770 2
#endif
#ifdef	DO_METAKEY
d772 1
a772 21
#endif
#ifdef	AMIGA
#ifdef	MOUSE
	{mgotobob, "mouse-beginning-of-buffer"},
	{mforwdel, "mouse-delete-char"},
	{mdelwhite, "mouse-delete-horizontal-space"},
	{mdelwind, "mouse-delete-window"},
	{mgotoeob, "mouse-end-of-buffer"},
	{menlargewind, "mouse-enlarge-window"},
	{mkillline, "mouse-kill-line"},
	{mkillregion, "mouse-kill-region"},
	{mdelfword, "mouse-kill-word"},
	{mreposition, "mouse-recenter"},
	{mbackpage, "mouse-scroll-down"},
	{mforwpage, "mouse-scroll-up"},
	{amigamouse, "mouse-set-point"},
	{mshrinkwind, "mouse-shrink-window"},
	{msplitwind, "mouse-split-window-vertically"},
	{myank, "mouse-yank"},
#endif
#endif
d777 1
a777 1
#ifdef	NOTAB
d779 1
a779 1
#endif
d784 1
a784 1
#ifdef	PREFIXREGION
d786 1
a786 1
#endif
d788 1
a788 1
#ifdef	GOSMACS
d790 1
a790 4
#endif
#ifdef	VMS
	{spawncli, "push-to-dcl"},
#else
a791 1
#endif
d794 1
a794 1
#endif
d796 1
a796 1
#ifdef	REGEX
d798 1
a798 1
#endif
d800 1
a800 1
#ifdef	REGEX
d804 1
a804 1
#endif
d811 1
a811 1
#ifdef	GOSMACS
d814 1
a814 1
#endif
d821 1
a821 1
#ifdef	REGEX
d823 1
a823 1
#endif
d827 1
a827 1
#ifdef	PREFIXREGION
d829 1
a829 1
#endif
d831 1
a831 1
#ifdef	NOTAB
d833 1
a833 1
#endif
d837 1
a837 4
#endif
#ifdef	VMS
	{attachtoparent, "suspend-emacs"},
#else
a838 1
#endif
d852 1
a852 1
int             nfunct = NFUNCT;/* used by help.c */
d864 1
a864 1
static
d866 2
a867 2
	register char  *fname;
	int             flag;
d869 3
a871 4
	register int    try;
	register int    x = ROUND2(NFUNCT);
	register int    base = 0;
	register int    notit;
d876 2
a877 1
			if ((notit = strcmp(fname, functnames[try].n_name)) >= 0) {
d883 2
a884 1
	} while ((x >>= 1) || (try == 1 && base == 0));	/* try 0 once if needed */
d894 1
a894 1
	char           *fname;
d896 1
a896 1
	int             i;
d899 1
a899 1
	return (PF) NULL;
d902 3
a904 2
/* complete function name */

d907 2
a908 2
	register char  *fname;
	int             c;
d910 1
a910 2
	register int    i, j, k, l;
	int             oj;
d917 4
a920 3
			return -2;	/* no match */
		for (j = 0; (l = fname[j]) && functnames[i].n_name[j] == l; j++) {
		}
d922 2
a923 1
			return -2;	/* no match */
d927 3
a929 3
	for (k = i + 1; k < NFUNCT; k++) {	/* find last match */
		for (l = 0; functnames[k].n_name[l] == fname[l]; l++) {
		}
d935 5
a939 2
	if (k > i) {		/* multiple matches */
		while ((l = functnames[i].n_name[j]) == functnames[k].n_name[j]) {
d945 5
a949 3
			return -3;	/* ambiguous	 */
	} else {		/* single match */
		while (l = functnames[i].n_name[j]) {
d959 4
a962 3
/* list possible function name completions */

LIST           *
d964 2
a965 1
	register char  *fname;
d967 2
a968 3
	register int    i, j, k, l;
	int             oj;
	LIST           *current, *last;
d971 1
a971 2
	for (j = 0; (l = fname[j]) && functnames[i].n_name[j] == l; j++) {
	}
d974 4
a977 3
			return NULL;	/* no match */
		for (j = 0; (l = fname[j]) && functnames[i].n_name[j] == l; j++) {
		}
d979 2
a980 1
			return NULL;	/* no match */
d983 1
a983 1
	 *	if(c==CCHR('M') && functnames[i].n_name[j]=='\0') return -1;
d985 3
a987 3
	for (k = i + 1; k < NFUNCT; k++) {	/* find last match */
		for (l = 0; functnames[k].n_name[l] == fname[l]; l++) {
		}
d994 1
a994 1
		current = (LIST *) malloc(sizeof(LIST));
d1002 4
a1005 3
/* translate from function pointer to function name. */

char           *
d1007 1
a1007 1
	register PF     fpoint;
d1009 1
a1009 1
	register FUNCTNAMES *fnp = &functnames[0];
d1012 2
a1013 1
		return (char *) NULL;	/* ambiguous */
d1018 1
a1018 1
	return (char *) NULL;
@


1.2
log
@Reverse rutgers change (attachtoparent vs. spawncli)

New ttreinit function that enters application mode, enables the keypad
and resets the tty size.

New spawn module that calls tttidy() to exit application mode (and cleanup)
then calls ttreinit() after resume to get back into application mode.  Assumes
we have job control.  This takes advantage of the xterm 'alternate screen'.
@
text
@a9 110
 * Defined by "basic.c".
 */
extern	int	gotobol();		/* Move to start of line	*/
extern	int	backchar();		/* Move backward by characters	*/
extern	int	gotoeol();		/* Move to end of line		*/
extern	int	forwchar();		/* Move forward by characters	*/
extern	int	gotobob();		/* Move to start of buffer	*/
extern	int	gotoeob();		/* Move to end of buffer	*/
extern	int	forwline();		/* Move forward by lines	*/
extern	int	backline();		/* Move backward by lines	*/
extern	int	forwpage();		/* Move forward by pages	*/
extern	int	backpage();		/* Move backward by pages	*/
extern	int	pagenext();		/* Page forward next window	*/
extern	int	setmark();		/* Set mark			*/
extern	int	swapmark();		/* Swap "." and mark		*/
extern	int	gotoline();		/* Go to a specified line.	*/
#ifdef	GOSMACS
extern	int	forw1page();		/* move forward by lines	*/
extern	int	back1page();		/* move back by lines		*/
#endif

/*
 * Defined by "buffer.c".
 */
extern	int	listbuffers();		/* Display list of buffers	*/
extern	int	usebuffer();		/* Switch a window to a buffer	*/
extern	int	poptobuffer();		/* Other window to a buffer	*/
extern	int	killbuffer();		/* Make a buffer go away.	*/
extern	int	savebuffers();		/* Save unmodified buffers	*/
extern	int	bufferinsert();		/* Insert buffer into another	*/
extern	int	notmodified();		/* Reset modification flag	*/

#ifndef NO_DIR
/*
 * Defined by "dir.c"
 */
extern	int	changedir();		/* change current directory	*/
extern	int	showcwdir();		/* show current directory	*/

#ifndef NO_DIRED
/*
 * defined by "dired.c"
 */
extern	int	dired();		/* dired			*/
extern	int	d_findfile();		/* dired find file		*/
extern	int	d_del();		/* dired mark for deletion	*/
extern	int	d_undel();		/* dired unmark			*/
extern	int	d_undelbak();		/* dired unmark backwards	*/
extern	int	d_expunge();		/* dired expunge		*/
extern	int	d_copy();		/* dired copy			*/
extern	int	d_rename();		/* dired rename			*/
extern	int	d_otherwindow();	/* dired other window		*/
extern	int	d_ffotherwindow();	/* dired find file other window */
#endif
#endif

/*
 * Defined by "extend.c".
 */
extern	int	extend();		/* Extended commands.		*/
extern	int	bindtokey();		/* Modify global key bindings.	*/
extern	int	localbind();		/* Modify mode key bindings.	*/
extern	int	define_key();		/* modify any key map		*/
extern	int	unbindtokey();		/* delete global binding	*/
extern	int	localunbind();		/* delete local binding		*/
extern	int	insert();		/* insert string		*/
#ifndef NO_STARTUP
extern	int	evalexpr();		/* Extended commands (again)	*/
extern	int	evalbuffer();		/* Evaluate current buffer	*/
extern	int	evalfile();		/* Evaluate a file		*/
#endif

/*
 * Defined by "file.c".
 */
extern	int	filevisit();		/* Get a file, read write	*/
extern	int	poptofile();		/* Get a file, other window	*/
extern	int	filewrite();		/* Write a file			*/
extern	int	filesave();		/* Save current file		*/
extern	int	fileinsert();		/* Insert file into buffer	*/
#ifndef NO_BACKUP
extern	int	makebkfile();		/* Control backups on saves	*/
#endif

/*
 * defined by help.c
 */
#ifndef NO_HELP
extern	int	desckey();		/* describe key			*/
extern	int	wallchart();		/* Make wall chart.		*/
extern	int	help_help();		/* help help			*/
extern	int	apropos_command();	/* apropos			*/
#endif

/*
 * defined by "kbd.c"
 */
#ifdef	DO_METAKEY
extern	int	do_meta();		/* interpret meta keys		*/
#endif
#ifdef	BSMAP
extern	int	bsmap();		/* backspace mapping		*/
#endif
extern	int	universal_argument();	/* Ctrl-U			*/
extern	int	digit_argument();	/* M-1, etc.			*/
extern	int	negative_argument();	/* M--				*/
extern	int	selfinsert();		/* Insert character		*/
extern	int	rescan();		/* internal try again function	*/

/*
d13 3
a15 3
extern	int	definemacro();		/* Begin macro			*/
extern	int	finishmacro();		/* End macro			*/
extern	int	executemacro();		/* Execute macro		*/
d21 2
a22 2
extern	int	ctrlg();		/* Abort out of things		*/
extern	int	quit();			/* Quit				*/
d27 1
a27 1
extern	int	showmatch();		/* Hack to show matching paren	 */
d31 3
a33 3
extern	int	indentmode();		/* set auto-indent mode		*/
extern	int	fillmode();		/* set word-wrap mode		*/
extern	int	blinkparen();		/* Fake blink-matching-paren var */
d35 1
a35 1
extern	int	notabmode();		/* no tab mode			*/
d37 2
a38 2
extern	int	overwrite();		/* overwrite mode		*/
extern	int	set_default_mode();	/* set default modes		*/
d43 6
a48 6
extern	int	gotobop();		/* Move to start of paragraph.	*/
extern	int	gotoeop();		/* Move to end of paragraph.	*/
extern	int	fillpara();		/* Justify a paragraph.		*/
extern	int	killpara();		/* Delete a paragraph.		*/
extern	int	setfillcol();		/* Set fill column for justify. */
extern	int	fillword();		/* Insert char with word wrap.	*/
d53 13
a65 13
extern	int	showcpos();		/* Show the cursor position	*/
extern	int	twiddle();		/* Twiddle characters		*/
extern	int	quote();		/* Insert literal		*/
extern	int	openline();		/* Open up a blank line		*/
extern	int	newline();		/* Insert newline		*/
extern	int	deblank();		/* Delete blank lines		*/
extern	int	justone();		/* Delete extra whitespace	*/
extern	int	delwhite();		/* Delete all whitespace	*/
extern	int	indent();		/* Insert newline, then indent	*/
extern	int	forwdel();		/* Forward delete		*/
extern	int	backdel();		/* Backward delete in		*/
extern	int	killline();		/* Kill forward			*/
extern	int	yank();			/* Yank back from killbuffer.	*/
d67 1
a67 1
extern	int	space_to_tabstop();
d74 9
a82 9
extern	int	re_forwsearch();	/* Regex search forward		 */
extern	int	re_backsearch();	/* Regex search backwards	 */
extern	int	re_searchagain();	/* Repeat regex search command	 */
extern	int	re_queryrepl();		/* Regex query replace		 */
extern	int	setcasefold();		/* Set case fold in searches	 */
extern	int	delmatchlines();	/* Delete all lines matching	 */
extern	int	delnonmatchlines();	/* Delete all lines not matching */
extern	int	cntmatchlines();	/* Count matching lines		 */
extern	int	cntnonmatchlines();	/* Count nonmatching lines	 */
d88 4
a91 4
extern	int	killregion();		/* Kill region.			*/
extern	int	copyregion();		/* Copy region to kill buffer.	*/
extern	int	lowerregion();		/* Lower case region.		*/
extern	int	upperregion();		/* Upper case region.		*/
d93 2
a94 2
extern	int	prefixregion();		/* Prefix all lines in region	*/
extern	int	setprefix();		/* Set line prefix string	*/
d100 6
a105 6
extern	int	forwsearch();		/* Search forward		*/
extern	int	backsearch();		/* Search backwards		*/
extern	int	searchagain();		/* Repeat last search command	*/
extern	int	forwisearch();		/* Incremental search forward	*/
extern	int	backisearch();		/* Incremental search backwards */
extern	int	queryrepl();		/* Query replace		*/
d110 1
a110 1
extern	int	spawncli();		/* Run CLI in a subjob.		*/
d112 1
a112 1
extern	int	attachtoparent();	/* Attach to parent process	*/
d117 1
a117 1
extern	int	showversion();		/* Show version numbers, etc.	*/
d122 3
a124 3
extern	int	reposition();		/* Reposition window		*/
extern	int	refresh();		/* Refresh the screen		*/
extern	int	nextwind();		/* Move to the next window	*/
d126 1
a126 1
extern	int	prevwind();		/* Move to the previous window	*/
d128 5
a132 5
extern	int	onlywind();		/* Make current window only one */
extern	int	splitwind();		/* Split current window		*/
extern	int	delwind();		/* Delete current window	*/
extern	int	enlargewind();		/* Enlarge display window.	*/
extern	int	shrinkwind();		/* Shrink window.		*/
d137 7
a143 7
extern	int	backword();		/* Backup by words		*/
extern	int	forwword();		/* Advance by words		*/
extern	int	upperword();		/* Upper case word.		*/
extern	int	lowerword();		/* Lower case word.		*/
extern	int	capword();		/* Initial capitalize word.	*/
extern	int	delfword();		/* Delete forward word.		*/
extern	int	delbword();		/* Delete backward word.	*/
d147 1
a147 1
extern	int tticon();
d150 1
a150 1
extern	int	amigamenu();		/* Menu function		*/
d153 17
a169 17
extern	int	amigamouse();		/* Amiga mouse functions	*/
extern	int	mgotobob();
extern	int	mforwdel();
extern	int	mdelwhite();
extern	int	mdelwind();
extern	int	mgotoeob();
extern	int	menlargewind();
extern	int	mkillline();
extern	int	mkillregion();
extern	int	mdelfword();
extern	int	mreposition();
extern	int	mbackpage();
extern	int	mforwpage();
extern	int	mshrinkwind();
extern	int	msplitwind();
extern	int	myank();
#endif	MOUSE
d171 2
a172 2
extern	int	togglewindow();		/* Defined by "ttyio.c"		*/
extern	int	togglezooms();		/*    ""         ""		*/
d175 1
a175 1
extern	int	setfont();		/* Defined by "ttyio.c"		*/
d179 7
a185 7
	/* functions to mess with the mode line rendition, window colors*/
extern	int	ttmode();		/* Defined by "tty.c"		*/
extern	int	tttext();		/*  ""				*/
extern	int	textforeground();	/*  ""				*/
extern	int	textbackground();	/*  ""				*/
extern	int	modeforeground();	/*  ""				*/
extern	int	modebackground();	/*  ""				*/
d196 1
a196 1
#endif	/* AMIGA */
d201 8
a208 8
static	PF	cHcG[] = {
	ctrlg,		/* ^G */
	help_help,	/* ^H */
};
static	PF	cHa[]	= {
	apropos_command,/* a */
	wallchart,	/* b */
	desckey,	/* c */
d210 1
a210 1
static	struct	KEYMAPE(2+IMAPEXT)	helpmap = {
d212 1
a212 1
	2+IMAPEXT,
d215 6
a220 2
		{CCHR('G'),CCHR('H'),	cHcG,	(KEYMAP *)NULL},
		{'a',	'c',		cHa,	(KEYMAP *)NULL},
d225 1
a225 1
static	struct	KEYMAPE(1+IMAPEXT)	extramap1 = {
d227 1
a227 1
	1+IMAPEXT,
d231 1
a231 1
static	struct	KEYMAPE(1+IMAPEXT)	extramap2 = {
d233 1
a233 1
	1+IMAPEXT,
d237 1
a237 1
static	struct	KEYMAPE(1+IMAPEXT)	extramap3 = {
d239 1
a239 1
	1+IMAPEXT,
d243 1
a243 1
static	struct	KEYMAPE(1+IMAPEXT)	extramap4 = {
d245 1
a245 1
	1+IMAPEXT,
d249 1
a249 1
static	struct	KEYMAPE(1+IMAPEXT)	extramap5 = {
d251 1
a251 1
	1+IMAPEXT,
d255 10
a264 10
static	PF	cX4cF[] = {
	poptofile,	/* ^f */
	ctrlg,		/* ^g */
};
static	PF	cX4b[] = {
	poptobuffer,	/* b */
	rescan,		/* c */
	rescan,		/* d */
	rescan,		/* e */
	poptofile,	/* f */
d266 1
a266 1
static	struct	KEYMAPE(2+IMAPEXT)	cX4map	= {
d268 1
a268 1
	2+IMAPEXT,
d271 6
a276 2
		{CCHR('F'),CCHR('G'),	cX4cF,	(KEYMAP *)NULL},
		{'b',	'f',		cX4b,	(KEYMAP *)NULL},
d280 22
a301 22
static	PF	cXcB[] = {
	listbuffers,	/* ^B */
	quit,		/* ^C */
	rescan,		/* ^D */
	rescan,		/* ^E */
	filevisit,	/* ^F */
	ctrlg,		/* ^G */
};
static	PF	cXcL[] = {
	lowerregion,	/* ^L */
	rescan,		/* ^M */
	rescan,		/* ^N */
	deblank,	/* ^O */
	rescan,		/* ^P */
	rescan,		/* ^Q */
	rescan,		/* ^R */
	filesave,	/* ^S */
	rescan,		/* ^T */
	upperregion,	/* ^U */
	rescan,		/* ^V */
	filewrite,	/* ^W */
	swapmark,	/* ^X */
d304 22
a325 22
static	PF	cXlp[]	= {
	definemacro,	/* ( */
	finishmacro,	/* ) */
};
#endif
static	PF	cX0[]	= {
	delwind,	/* 0 */
	onlywind,	/* 1 */
	splitwind,	/* 2 */
	rescan,		/* 3 */
	prefix,		/* 4 */
};
static	PF	cXeq[]	= {
	showcpos,	/* = */
};
static	PF	cXcar[] = {
	enlargewind,	/* ^ */
	rescan,		/* _ */
	rescan,		/* ` */
	rescan,		/* a */
	usebuffer,	/* b */
	rescan,		/* c */
d327 1
a327 1
	dired,		/* d */
d329 1
a329 1
	rescan,		/* d */
d332 1
a332 1
	executemacro,	/* e */
d334 1
a334 1
	rescan,		/* e */
d336 14
a349 14
	setfillcol,	/* f */
	rescan,		/* g */
	rescan,		/* h */
	fileinsert,	/* i */
	rescan,		/* j */
	killbuffer,	/* k */
	rescan,		/* l */
	rescan,		/* m */
	rescan,		/* n */
	nextwind,	/* o */
	rescan,		/* p */
	rescan,		/* q */
	rescan,		/* r */
	savebuffers,	/* s */
d352 1
a352 1
static	struct	KEYMAPE(6+IMAPEXT)	cXmap = {
d354 1
a354 1
	6+IMAPEXT,
d356 1
a356 1
static	struct	KEYMAPE(5+IMAPEXT)	cXmap = {
d358 1
a358 1
	5+IMAPEXT,
d362 6
a367 2
		{CCHR('B'),CCHR('G'),	cXcB,	(KEYMAP *)NULL},
		{CCHR('L'),CCHR('X'),	cXcL,	(KEYMAP *)NULL},
d369 13
a381 5
		{'(',	')',		cXlp,	(KEYMAP *)NULL},
#endif
		{'0',	'4',		cX0,	(KEYMAP *)&cX4map},
		{'=',	'=',		cXeq,	(KEYMAP *)NULL},
		{'^',	's',		cXcar,	(KEYMAP *)NULL},
d385 2
a386 2
static	PF	metacG[] = {
	ctrlg,		/* ^G */
d388 2
a389 2
static	PF	metacV[] = {
	pagenext,	/* ^V */
d391 2
a392 2
static	PF	metasp[] = {
	justone,	/* space */
d394 2
a395 2
static	PF	metapct[] = {
	queryrepl,	/* % */
d397 1
a397 1
static	PF	metami[] = {
d399 50
a448 50
	rescan,		/* . */
	rescan,		/* / */
	digit_argument, /* 0 */
	digit_argument, /* 1 */
	digit_argument, /* 2 */
	digit_argument, /* 3 */
	digit_argument, /* 4 */
	digit_argument, /* 5 */
	digit_argument, /* 6 */
	digit_argument, /* 7 */
	digit_argument, /* 8 */
	digit_argument, /* 9 */
	rescan,		/* : */
	rescan,		/* ; */
	gotobob,	/* < */
	rescan,		/* = */
	gotoeob,	/* > */
};
static	PF	metalb[] = {
	gotobop,	/* [ */
	delwhite,	/* \ */
	gotoeop,	/* ] */
	rescan,		/* ^ */
	rescan,		/* _ */
	rescan,		/* ` */
	rescan,		/* a */
	backword,	/* b */
	capword,	/* c */
	delfword,	/* d */
	rescan,		/* e */
	forwword,	/* f */
};
static	PF	metal[] = {
	lowerword,	/* l */
	rescan,		/* m */
	rescan,		/* n */
	rescan,		/* o */
	rescan,		/* p */
	fillpara,	/* q */
	backsearch,	/* r */
	forwsearch,	/* s */
	rescan,		/* t */
	upperword,	/* u */
	backpage,	/* v */
	copyregion,	/* w */
	extend,		/* x */
};
static	PF	metatilde[] = {
	notmodified,	/* ~ */
	delbword,	/* DEL */
d450 1
a450 1
static	struct	KEYMAPE(8+IMAPEXT)	metamap = {
d452 1
a452 1
	8+IMAPEXT,
d455 24
a478 8
		{CCHR('G'),CCHR('G'),	metacG, (KEYMAP *)NULL},
		{CCHR('V'),CCHR('V'),	metacV, (KEYMAP *)NULL},
		{' ',	' ',		metasp, (KEYMAP *)NULL},
		{'%',	'%',		metapct,(KEYMAP *)NULL},
		{'-',	'>',		metami, (KEYMAP *)NULL},
		{'[',	'f',		metalb, (KEYMAP *)NULL},
		{'l',	'x',		metal,	(KEYMAP *)NULL},
		{'~',	CCHR('?'),	metatilde,(KEYMAP *)NULL},
d482 9
a490 9
static	PF	fund_at[] = {
	setmark,	/* ^@@ */
	gotobol,	/* ^A */
	backchar,	/* ^B */
	rescan,		/* ^C */
	forwdel,	/* ^D */
	gotoeol,	/* ^E */
	forwchar,	/* ^F */
	ctrlg,		/* ^G */
d492 1
a492 1
	prefix,		/* ^H */
d494 1
a494 1
	rescan,		/* ^H */
d498 12
a509 12
static	PF	fund_CJ[] = {
	indent,		/* ^J */
	killline,	/* ^K */
	reposition,	/* ^L */
	newline,	/* ^M */
	forwline,	/* ^N */
	openline,	/* ^O */
	backline,	/* ^P */
	quote,		/* ^Q */
	backisearch,	/* ^R */
	forwisearch,	/* ^S */
	twiddle,	/* ^T */
d511 4
a514 4
	forwpage,	/* ^V */
	killregion,	/* ^W */
	prefix,		/* ^X */
	yank,		/* ^Y */
d516 1
a516 1
	spawncli,	 /* ^Z */
d518 1
a518 1
	attachtoparent, /* ^Z */
d521 7
a527 6
static	PF	fund_esc[] = {
	prefix,		/* esc */
	rescan,		/* ^\ */	/* selfinsert is default on fundamental */
	rescan,		/* ^] */
	rescan,		/* ^^ */
	rescan,		/* ^_ */
d529 2
a530 2
static	PF	fund_del[] = {
	backdel,	/* DEL */
d537 1
a537 1
static	struct	KEYMAPE(4+NFUND_XMAPS+IMAPEXT)	fundmap = {
d543 3
a545 1
		{CCHR('@@'),CCHR('H'),	fund_at, (KEYMAP *)&helpmap},
d547 13
a559 5
		{CCHR('@@'),CCHR('H'),	fund_at, (KEYMAP *)NULL},
#endif
		{CCHR('J'),CCHR('Z'),	fund_CJ, (KEYMAP *)&cXmap},
		{CCHR('['),CCHR('_'),	fund_esc,(KEYMAP *)&metamap},
		{CCHR('?'),CCHR('?'),	fund_del,(KEYMAP *)NULL},
d566 2
a567 2
static	PF	fill_sp[] = {
	fillword,	/* ' ' */
d569 1
a569 1
static struct KEYMAPE(1+IMAPEXT)	fillmap = {
d571 1
a571 1
	1+IMAPEXT,
d574 3
a576 1
		{' ',	' ',	fill_sp,	(KEYMAP *)NULL},
d580 5
a584 5
static	PF	indent_lf[] = {
	newline,	/* ^J */
	rescan,		/* ^K */
	rescan,		/* ^L */
	indent,		/* ^M */
d586 1
a586 1
static	struct	KEYMAPE(1+IMAPEXT)	indntmap = {
d588 1
a588 1
	1+IMAPEXT,
d591 3
a593 1
		{CCHR('J'), CCHR('M'),	indent_lf,	(KEYMAP *)NULL},
d596 2
a597 2
static	PF	blink_rp[] = {
	showmatch,	/* ) */
d599 1
a599 1
static	struct	KEYMAPE(1+IMAPEXT)	blinkmap = {
d601 1
a601 1
	1+IMAPEXT,
d604 3
a606 1
		{')',	')',	blink_rp,	(KEYMAP *)NULL},
d611 1
a611 1
static	PF	notab_tab[] = {
d614 1
a614 1
static	struct	KEYMAPE(1+IMAPEXT)	notabmap = {
d616 1
a616 1
	1+IMAPEXT,
d619 3
a621 1
		{CCHR('I'),CCHR('I'),	notab_tab,	(KEYMAP *)NULL},
d626 1
a626 1
static	struct	KEYMAPE(1+IMAPEXT)	overwmap = {
d628 1
a628 1
	1+IMAPEXT,			/* 1 to avoid 0 sized array */
d632 3
a634 1
		{(KCHAR)0,	(KCHAR)0, (PF *)NULL,	(KEYMAP *)NULL},
d639 9
a647 9
static	PF	dirednul[] = {
	setmark,	/* ^@@ */
	gotobol,	/* ^A */
	backchar,	/* ^B */
	rescan,		/* ^C */
	d_del,		/* ^D */
	gotoeol,	/* ^E */
	forwchar,	/* ^F */
	ctrlg,		/* ^G */
d649 1
a649 1
	prefix,		/* ^H */
d652 14
a665 14
static	PF	diredcl[] = {
	reposition,	/* ^L */
	forwline,	/* ^M */
	forwline,	/* ^N */
	rescan,		/* ^O */
	backline,	/* ^P */
	rescan,		/* ^Q */
	backisearch,	/* ^R */
	forwisearch,	/* ^S */
	rescan,		/* ^T */
	universal_argument, /* ^U */
	forwpage,	/* ^V */
	rescan,		/* ^W */
	prefix,		/* ^X */
d667 1
a667 1
static	PF	diredcz[] = {
d669 1
a669 1
	spawncli,	 /* ^Z */
d671 1
a671 1
	attachtoparent, /* ^Z */
d673 25
a697 25
	prefix,		/* esc */
	rescan,		/* ^\ */
	rescan,		/* ^] */
	rescan,		/* ^^ */
	rescan,		/* ^_ */
	forwline,	/* SP */
};
static	PF	diredc[] = {
	d_copy,		/* c */
	d_del,		/* d */
	d_findfile,	/* e */
	d_findfile,	/* f */
};
static	PF	diredn[] = {
	forwline,	/* n */
	d_ffotherwindow,/* o */
	backline,	/* p */
	rescan,		/* q */
	d_rename,	/* r */
	rescan,		/* s */
	rescan,		/* t */
	d_undel,	/* u */
	rescan,		/* v */
	rescan,		/* w */
	d_expunge,	/* x */
d699 2
a700 2
static	PF	direddl[] = {
	d_undelbak,	/* del */
d707 1
a707 1
static	struct	KEYMAPE(6 + NDIRED_XMAPS + IMAPEXT)	diredmap = {
d713 3
a715 1
		{CCHR('@@'),	CCHR('H'),	dirednul, (KEYMAP *)&helpmap},
d717 19
a735 7
		{CCHR('@@'),	CCHR('G'),	dirednul, (KEYMAP *)NULL},
#endif
		{CCHR('L'),	CCHR('X'),	diredcl,  (KEYMAP *)&cXmap},
		{CCHR('Z'),	' ',		diredcz,  (KEYMAP *)&metamap},
		{'c',		'f',		diredc,   (KEYMAP *)NULL},
		{'n',		'x',		diredn,   (KEYMAP *)NULL},
		{CCHR('?'),	CCHR('?'),	direddl,  (KEYMAP *)NULL},
d737 1
a737 1
		DIRED_XMAPS,	/* map sections for dired mode keys	*/
d743 6
a748 6
/* give names to the maps, for use by help etc.
 * If the map is to be bindable, it must also be listed in the
 * function name table below with the same name.
 * Maps created dynamicly currently don't get added here, thus are unnamed.
 * Modes are just named keymaps with functions to add/subtract them from
 * a buffer's list of modes.  If you change a mode name, change it in
d752 1
a752 1
MAPS	map_table[] = {
d754 4
a757 4
	{(KEYMAP *)&fundmap,	"fundamental"},
	{(KEYMAP *)&fillmap,	"fill"},
	{(KEYMAP *)&indntmap,	"indent"},
	{(KEYMAP *)&blinkmap,	"blink"},
d759 1
a759 1
	{(KEYMAP *)&notabmap,	"notab"},
d761 9
a769 9
	{(KEYMAP *)&overwmap,	"overwrite"},
	{(KEYMAP *)&metamap,	"esc prefix"},
	{(KEYMAP *)&cXmap,	"c-x prefix"},
	{(KEYMAP *)&cX4map,	"c-x 4 prefix"},
	{(KEYMAP *)&extramap1,	"extra prefix 1"},
	{(KEYMAP *)&extramap2,	"extra prefix 2"},
	{(KEYMAP *)&extramap3,	"extra prefix 3"},
	{(KEYMAP *)&extramap4,	"extra prefix 4"},
	{(KEYMAP *)&extramap5,	"extra prefix 5"},
d771 1
a771 1
	{(KEYMAP *)&helpmap,	"help"},
d774 1
a774 1
	{(KEYMAP *)&diredmap,	"dired"},
d779 1
a779 1
int	nmaps = NMAPS;		/* for use by rebind in extend.c */
d781 3
a783 2
char *map_name(map)
KEYMAP *map;
d785 1
a785 1
	MAPS *mp = &map_table[0];
d788 4
a791 3
	    if(mp->p_map == map) return mp->p_name;
	} while(++mp < &map_table[NMAPS]);
	return (char *)NULL;
d794 3
a796 2
MAPS *name_mode(name)
char *name;
d798 1
a798 1
	MAPS *mp = &map_table[0];
d801 4
a804 3
	    if(strcmp(mp->p_name,name)==0) return mp;
	} while(++mp < &map_table[NMAPS]);
	return (MAPS *)NULL;
d807 3
a809 2
KEYMAP *name_map(name)
char *name;
d811 2
a812 2
	MAPS *mp;
	return (mp=name_mode(name))==NULL ? (KEYMAP *)NULL : mp->p_map;
d815 4
a818 3
/* Warning: functnames MUST be in alphabetical order!  (due to binary
 * search in name_function.)  If the function is prefix, it must be listed
 * with the same name in the map_table above.
d821 1
a821 1
FUNCTNAMES	functnames[] = {
d824 1
a824 1
	{tticon,	"amiga-iconify"},
d827 1
a827 1
	{amigamenu,	"amiga-menu"},
d830 3
a832 3
	{modebackground,"amiga-mode-background"},
	{modeforeground,"amiga-mode-foreground"},
	{ttmode,	"amiga-mode-rendition"},
d835 1
a835 1
	{setfont,	"amiga-set-font"},
d838 7
a844 7
	{textbackground,"amiga-text-background"},
	{textforeground,"amiga-text-foreground"},
	{tttext,	"amiga-text-rendition"},
#endif
	{togglewindow,	"amiga-toggle-border"},
	{togglezooms,	"amiga-zoom-mode"},
#endif	/* AMIGA */
d848 10
a857 10
	{fillmode,	"auto-fill-mode"},
	{indentmode,	"auto-indent-mode"},
	{backchar,	"backward-char"},
	{delbword,	"backward-kill-word"},
	{gotobop,	"backward-paragraph"},
	{backword,	"backward-word"},
	{gotobob,	"beginning-of-buffer"},
	{gotobol,	"beginning-of-line"},
	{blinkparen,	"blink-matching-paren"},
	{showmatch,	"blink-matching-paren-hack"},
d859 1
a859 1
	{bsmap,		"bsmap-mode"},
d861 2
a862 2
	{prefix,	"c-x 4 prefix"},
	{prefix,	"c-x prefix"},
d864 1
a864 1
	{executemacro,	"call-last-kbd-macro"},
d866 1
a866 1
	{capword,	"capitalize-word"},
d868 1
a868 1
	{changedir,	"cd"},
d870 1
a870 1
	{copyregion,	"copy-region-as-kill"},
d873 1
a873 1
	{cntnonmatchlines,"count-non-matches"},
d875 5
a879 5
	{define_key,	"define-key"},
	{backdel,	"delete-backward-char"},
	{deblank,	"delete-blank-lines"},
	{forwdel,	"delete-char"},
	{delwhite,	"delete-horizontal-space"},
d882 1
a882 1
	{delnonmatchlines,"delete-non-matching-lines"},
d884 2
a885 2
	{onlywind,	"delete-other-windows"},
	{delwind,	"delete-window"},
d887 2
a888 2
	{wallchart,	"describe-bindings"},
	{desckey,	"describe-key-briefly"},
d890 1
a890 1
	{digit_argument,"digit-argument"},
d892 5
a896 5
	{dired,		"dired"},
	{d_undelbak,	"dired-backup-unflag"},
	{d_copy,	"dired-copy-file"},
	{d_expunge,	"dired-do-deletions"},
	{d_findfile,	"dired-find-file"},
d898 1
a898 1
	{d_del,		"dired-flag-file-deleted"},
d900 2
a901 2
	{d_rename,	"dired-rename-file"},
	{d_undel,	"dired-unflag"},
d903 3
a905 3
	{lowerregion,	"downcase-region"},
	{lowerword,	"downcase-word"},
	{showversion,	"emacs-version"},
d907 1
a907 1
	{finishmacro,	"end-kbd-macro"},
d909 4
a912 4
	{gotoeob,	"end-of-buffer"},
	{gotoeol,	"end-of-line"},
	{enlargewind,	"enlarge-window"},
	{prefix,	"esc prefix"},
d914 2
a915 2
	{evalbuffer,	"eval-current-buffer"},
	{evalexpr,	"eval-expression"},
d917 16
a932 16
	{swapmark,	"exchange-point-and-mark"},
	{extend,	"execute-extended-command"},
	{prefix,	"extra prefix 1"},
	{prefix,	"extra prefix 2"},
	{prefix,	"extra prefix 3"},
	{prefix,	"extra prefix 4"},
	{prefix,	"extra prefix 5"},
	{fillpara,	"fill-paragraph"},
	{filevisit,	"find-file"},
	{poptofile,	"find-file-other-window"},
	{forwchar,	"forward-char"},
	{gotoeop,	"forward-paragraph"},
	{forwword,	"forward-word"},
	{bindtokey,	"global-set-key"},
	{unbindtokey,	"global-unset-key"},
	{gotoline,	"goto-line"},
d934 2
a935 2
	{prefix,	"help"},
	{help_help,	"help-help"},
d937 14
a950 14
	{insert,	"insert"},
	{bufferinsert,	"insert-buffer"},
	{fileinsert,	"insert-file"},
	{fillword,	"insert-with-wrap"},
	{backisearch,	"isearch-backward"},
	{forwisearch,	"isearch-forward"},
	{justone,	"just-one-space"},
	{ctrlg,		"keyboard-quit"},
	{killbuffer,	"kill-buffer"},
	{killline,	"kill-line"},
	{killpara,	"kill-paragraph"},
	{killregion,	"kill-region"},
	{delfword,	"kill-word"},
	{listbuffers,	"list-buffers"},
d952 1
a952 1
	{evalfile,	"load"},
d954 2
a955 2
	{localbind,	"local-set-key"},
	{localunbind,	"local-unset-key"},
d957 1
a957 1
	{makebkfile,	"make-backup-files"},
d960 1
a960 1
	{do_meta,	"meta-key-mode"},	/* better name, anyone? */
d964 16
a979 16
	{mgotobob,	"mouse-beginning-of-buffer"},
	{mforwdel,	"mouse-delete-char"},
	{mdelwhite,	"mouse-delete-horizontal-space"},
	{mdelwind,	"mouse-delete-window"},
	{mgotoeob,	"mouse-end-of-buffer"},
	{menlargewind,	"mouse-enlarge-window"},
	{mkillline,	"mouse-kill-line"},
	{mkillregion,	"mouse-kill-region"},
	{mdelfword,	"mouse-kill-word"},
	{mreposition,	"mouse-recenter"},
	{mbackpage,	"mouse-scroll-down"},
	{mforwpage,	"mouse-scroll-up"},
	{amigamouse,	"mouse-set-point"},
	{mshrinkwind,	"mouse-shrink-window"},
	{msplitwind,	"mouse-split-window-vertically"},
	{myank,		"mouse-yank"},
d983 3
a985 3
	{newline,	"newline"},
	{indent,	"newline-and-indent"},
	{forwline,	"next-line"},
d987 1
a987 1
	{notabmode,	"no-tab-mode"},
d989 4
a992 4
	{notmodified,	"not-modified"},
	{openline,	"open-line"},
	{nextwind,	"other-window"},
	{overwrite,	"overwrite-mode"},
d994 1
a994 1
	{prefixregion,	"prefix-region"},
d996 1
a996 1
	{backline,	"previous-line"},
d998 1
a998 1
	{prevwind,	"previous-window"},
d1001 1
a1001 1
	{spawncli,	"push-to-dcl"},
d1003 1
a1003 1
	{spawncli,	"push-shell"},
d1006 1
a1006 1
	{showcwdir,	"pwd"},
d1008 1
a1008 1
	{queryrepl,	"query-replace"},
d1010 1
a1010 1
	{re_queryrepl,	"query-replace-regexp"},
d1012 1
a1012 1
	{quote,		"quoted-insert"},
d1014 1
a1014 1
	{re_searchagain,"re-search-again"},
d1018 6
a1023 6
	{reposition,	"recenter"},
	{refresh,	"redraw-display"},
	{filesave,	"save-buffer"},
	{quit,		"save-buffers-kill-emacs"},
	{savebuffers,	"save-some-buffers"},
	{backpage,	"scroll-down"},
d1025 2
a1026 2
	{back1page,	"scroll-one-line-down"},
	{forw1page,	"scroll-one-line-up"},
d1028 6
a1033 6
	{pagenext,	"scroll-other-window"},
	{forwpage,	"scroll-up"},
	{searchagain,	"search-again"},
	{backsearch,	"search-backward"},
	{forwsearch,	"search-forward"},
	{selfinsert,	"self-insert-command"},
d1035 1
a1035 1
	{setcasefold,	"set-case-fold-search"},
d1038 2
a1039 2
	{setfillcol,	"set-fill-column"},
	{setmark,	"set-mark-command"},
d1041 1
a1041 1
	{setprefix,	"set-prefix-string"},
d1043 1
a1043 1
	{shrinkwind,	"shrink-window"},
d1047 1
a1047 1
	{splitwind,	"split-window-vertically"},
d1049 1
a1049 1
	{definemacro,	"start-kbd-macro"},
d1052 1
a1052 1
	{attachtoparent,"suspend-emacs"},
d1054 1
a1054 1
	{spawncli,	"suspend-emacs"},
d1056 3
a1058 3
	{usebuffer,	"switch-to-buffer"},
	{poptobuffer,	"switch-to-buffer-other-window"},
	{twiddle,	"transpose-chars"},
d1060 5
a1064 5
	{upperregion,	"upcase-region"},
	{upperword,	"upcase-word"},
	{showcpos,	"what-cursor-position"},
	{filewrite,	"write-file"},
	{yank,		"yank"},
d1069 1
a1069 1
int	nfunct = NFUNCT;		/* used by help.c */
d1081 4
a1084 3
static	name_fent(fname, flag)
register char *fname;
int	flag;
d1086 4
a1089 4
	register int	try;
	register int	x = ROUND2(NFUNCT);
	register int	base = 0;
	register int	notit;
d1092 7
a1098 5
	    /* + can be used instead of | here if more efficent.	*/
	    if((try = base | x) < NFUNCT) {
		if((notit = strcmp(fname, functnames[try].n_name)) >= 0) {
		    if(!notit) return try;
		    base = try;
d1100 1
a1100 2
	    }
	} while((x>>=1) || (try==1 && base==0));    /* try 0 once if needed */
d1108 3
a1110 2
PF	name_function(fname)
char	*fname;
d1112 4
a1115 3
	int i;
	if((i = name_fent(fname, FALSE)) >= 0) return functnames[i].n_funct;
	return (PF)NULL;
d1120 1
d1122 2
a1123 1
register char	*fname;
d1125 2
a1126 2
	register int i, j, k, l;
	int	oj;
d1129 1
a1129 5
	for(j=0; (l=fname[j]) && functnames[i].n_name[j]==l; j++) {}
	if(fname[j]!='\0') {
	    if(++i >= NFUNCT) return -2;	/* no match */
	    for(j=0; (l=fname[j]) && functnames[i].n_name[j]==l; j++) {}
	    if(fname[j]!='\0') return -2;	/* no match */
d1131 15
a1145 4
	if(c==CCHR('M') && functnames[i].n_name[j]=='\0') return -1;
	for(k=i+1; k<NFUNCT; k++) {		/* find last match */
	    for(l=0; functnames[k].n_name[l]==fname[l]; l++) {}
	    if(l<j) break;
d1149 14
a1162 11
	if(k>i) {					/* multiple matches */
	    while((l = functnames[i].n_name[j]) == functnames[k].n_name[j]) {
		fname[j++] = l;
		if(l=='-' && c==' ') break;
	    }
	    if(j==oj) return -3;			/* ambiguous	*/
	} else {					/* single match */
	    while(l = functnames[i].n_name[j]) {
		fname[j++] = l;
		if(l=='-' && c==' ') break;
	    }
d1170 3
a1172 2
LIST *complete_function_list(fname, c)
register char	*fname;
d1174 3
a1176 3
	register int i, j, k, l;
	int	oj;
	LIST *current,*last;
d1179 9
a1187 5
	for(j=0; (l=fname[j]) && functnames[i].n_name[j]==l; j++) {}
	if(fname[j]!='\0') {
	    if(++i >= NFUNCT) return NULL;	/* no match */
	    for(j=0; (l=fname[j]) && functnames[i].n_name[j]==l; j++) {}
	    if(fname[j]!='\0') return NULL;	/* no match */
d1189 8
a1196 6
/*
 *	if(c==CCHR('M') && functnames[i].n_name[j]=='\0') return -1;
 */
	for(k=i+1; k<NFUNCT; k++) {		/* find last match */
	    for(l=0; functnames[k].n_name[l]==fname[l]; l++) {}
	    if(l<j) break;
d1201 4
a1204 4
	    current = (LIST *)malloc(sizeof(LIST));
	    current->l_next = last;
	    current->l_name = functnames[k].n_name;
	    last = current;
d1206 1
a1206 1
	return(last);	
d1211 3
a1213 2
char *function_name(fpoint)
register PF fpoint;
d1215 1
a1215 1
	register FUNCTNAMES	*fnp = &functnames[0];
d1217 2
a1218 1
	if(fpoint == prefix) return (char *)NULL;	/* ambiguous */
d1220 4
a1223 3
	    if(fnp->n_funct == fpoint) return fnp->n_name;
	} while(++fnp < &functnames[NFUNCT]);
	return (char *)NULL;
@


1.1
log
@initial import of mg2a
@
text
@d221 1
d223 1
d589 3
d593 1
d721 3
d725 1
d1084 1
d1086 3
@

