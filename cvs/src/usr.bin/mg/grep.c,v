head	1.44;
access;
symbols
	OPENBSD_6_2_BASE:1.44
	OPENBSD_6_1:1.44.0.10
	OPENBSD_6_1_BASE:1.44
	OPENBSD_6_0:1.44.0.6
	OPENBSD_6_0_BASE:1.44
	OPENBSD_5_9:1.44.0.2
	OPENBSD_5_9_BASE:1.44
	OPENBSD_5_8:1.44.0.4
	OPENBSD_5_8_BASE:1.44
	OPENBSD_5_7:1.42.0.2
	OPENBSD_5_7_BASE:1.42
	OPENBSD_5_6:1.40.0.4
	OPENBSD_5_6_BASE:1.40
	OPENBSD_5_5:1.39.0.6
	OPENBSD_5_5_BASE:1.39
	OPENBSD_5_4:1.39.0.2
	OPENBSD_5_4_BASE:1.39
	OPENBSD_5_3:1.38.0.16
	OPENBSD_5_3_BASE:1.38
	OPENBSD_5_2:1.38.0.14
	OPENBSD_5_2_BASE:1.38
	OPENBSD_5_1_BASE:1.38
	OPENBSD_5_1:1.38.0.12
	OPENBSD_5_0:1.38.0.10
	OPENBSD_5_0_BASE:1.38
	OPENBSD_4_9:1.38.0.8
	OPENBSD_4_9_BASE:1.38
	OPENBSD_4_8:1.38.0.6
	OPENBSD_4_8_BASE:1.38
	OPENBSD_4_7:1.38.0.2
	OPENBSD_4_7_BASE:1.38
	OPENBSD_4_6:1.38.0.4
	OPENBSD_4_6_BASE:1.38
	OPENBSD_4_5:1.36.0.4
	OPENBSD_4_5_BASE:1.36
	OPENBSD_4_4:1.36.0.2
	OPENBSD_4_4_BASE:1.36
	OPENBSD_4_3:1.34.0.4
	OPENBSD_4_3_BASE:1.34
	OPENBSD_4_2:1.34.0.2
	OPENBSD_4_2_BASE:1.34
	OPENBSD_4_1:1.33.0.2
	OPENBSD_4_1_BASE:1.33
	OPENBSD_4_0:1.32.0.2
	OPENBSD_4_0_BASE:1.32
	OPENBSD_3_9:1.26.0.2
	OPENBSD_3_9_BASE:1.26
	OPENBSD_3_8:1.16.0.2
	OPENBSD_3_8_BASE:1.16
	OPENBSD_3_7:1.12.0.4
	OPENBSD_3_7_BASE:1.12
	OPENBSD_3_6:1.12.0.2
	OPENBSD_3_6_BASE:1.12
	OPENBSD_3_5:1.10.0.2
	OPENBSD_3_5_BASE:1.10
	OPENBSD_3_4:1.8.0.2
	OPENBSD_3_4_BASE:1.8
	OPENBSD_3_3:1.7.0.4
	OPENBSD_3_3_BASE:1.7
	OPENBSD_3_2:1.7.0.2
	OPENBSD_3_2_BASE:1.7
	OPENBSD_3_1:1.5.0.2
	OPENBSD_3_1_BASE:1.5
	OPENBSD_3_0:1.1.0.2
	OPENBSD_3_0_BASE:1.1;
locks; strict;
comment	@ * @;


1.44
date	2015.03.19.21.48.05;	author bcallah;	state Exp;
branches;
next	1.43;
commitid	8rkHsVfUx5xgPXRB;

1.43
date	2015.03.19.21.22.15;	author bcallah;	state Exp;
branches;
next	1.42;
commitid	GbEBL4CfPvDkB8hj;

1.42
date	2014.11.16.04.16.41;	author guenther;	state Exp;
branches;
next	1.41;
commitid	a9yG0qCw9VEW27qI;

1.41
date	2014.11.16.00.59.25;	author guenther;	state Exp;
branches;
next	1.40;
commitid	wPiRVLQSgR82vXRT;

1.40
date	2014.03.20.07.47.29;	author lum;	state Exp;
branches;
next	1.39;

1.39
date	2013.06.01.17.31.11;	author lum;	state Exp;
branches;
next	1.38;

1.38
date	2009.06.04.23.39.37;	author kjell;	state Exp;
branches;
next	1.37;

1.37
date	2009.06.04.02.23.37;	author kjell;	state Exp;
branches;
next	1.36;

1.36
date	2008.06.14.08.39.30;	author kjell;	state Exp;
branches;
next	1.35;

1.35
date	2008.06.10.00.19.31;	author kjell;	state Exp;
branches;
next	1.34;

1.34
date	2007.05.28.17.52.17;	author kjell;	state Exp;
branches;
next	1.33;

1.33
date	2006.11.19.16.51.19;	author deraadt;	state Exp;
branches;
next	1.32;

1.32
date	2006.07.25.08.27.09;	author kjell;	state Exp;
branches;
next	1.31;

1.31
date	2006.07.25.08.22.32;	author kjell;	state Exp;
branches;
next	1.30;

1.30
date	2006.06.01.05.34.52;	author jason;	state Exp;
branches;
next	1.29;

1.29
date	2006.05.27.21.22.45;	author kjell;	state Exp;
branches;
next	1.28;

1.28
date	2006.05.02.17.10.25;	author kjell;	state Exp;
branches;
next	1.27;

1.27
date	2006.04.03.00.19.32;	author kjell;	state Exp;
branches;
next	1.26;

1.26
date	2005.12.13.07.20.13;	author kjell;	state Exp;
branches;
next	1.25;

1.25
date	2005.12.13.02.08.06;	author kjell;	state Exp;
branches;
next	1.24;

1.24
date	2005.11.18.20.56.53;	author deraadt;	state Exp;
branches;
next	1.23;

1.23
date	2005.11.12.19.13.09;	author deraadt;	state Exp;
branches;
next	1.22;

1.22
date	2005.11.11.18.40.51;	author deraadt;	state Exp;
branches;
next	1.21;

1.21
date	2005.10.18.21.22.52;	author kjell;	state Exp;
branches;
next	1.20;

1.20
date	2005.10.14.19.46.46;	author kjell;	state Exp;
branches;
next	1.19;

1.19
date	2005.10.13.20.28.49;	author deraadt;	state Exp;
branches;
next	1.18;

1.18
date	2005.10.13.05.24.52;	author kjell;	state Exp;
branches;
next	1.17;

1.17
date	2005.10.11.00.50.00;	author kjell;	state Exp;
branches;
next	1.16;

1.16
date	2005.08.09.00.53.48;	author kjell;	state Exp;
branches;
next	1.15;

1.15
date	2005.06.03.23.39.55;	author cloder;	state Exp;
branches;
next	1.14;

1.14
date	2005.05.25.20.15.18;	author jason;	state Exp;
branches;
next	1.13;

1.13
date	2005.04.03.02.09.28;	author db;	state Exp;
branches;
next	1.12;

1.12
date	2004.07.22.01.25.25;	author vincent;	state Exp;
branches;
next	1.11;

1.11
date	2004.06.12.15.04.41;	author vincent;	state Exp;
branches;
next	1.10;

1.10
date	2004.01.15.20.55.47;	author vincent;	state Exp;
branches;
next	1.9;

1.9
date	2003.11.09.00.16.36;	author vincent;	state Exp;
branches;
next	1.8;

1.8
date	2003.04.08.21.19.57;	author vincent;	state Exp;
branches;
next	1.7;

1.7
date	2002.07.25.16.37.54;	author vincent;	state Exp;
branches;
next	1.6;

1.6
date	2002.07.01.14.33.44;	author vincent;	state Exp;
branches;
next	1.5;

1.5
date	2002.03.18.01.22.31;	author vincent;	state Exp;
branches;
next	1.4;

1.4
date	2002.03.16.19.30.29;	author vincent;	state Exp;
branches;
next	1.3;

1.3
date	2002.02.14.14.24.21;	author deraadt;	state Exp;
branches;
next	1.2;

1.2
date	2001.11.25.07.34.17;	author deraadt;	state Exp;
branches;
next	1.1;

1.1
date	2001.05.24.10.58.34;	author art;	state Exp;
branches;
next	;


desc
@@


1.44
log
@More unifdef cleanup:
-UDIRED_XMAPS and -UFUND_XMAPS: you can't build mg the other way.
-DTIOCGWINSZ: you have this if you have term.h
Remove a #define TERMCAP which isn't being used.

Remove defines for NDIRED_XMAPS, NFUND_XMAPS, and IMAPEXT. They are all
defined to be 0 and are only ever used in addition. We don't need to add 0.
Simply lines that were using those defines.
ok florian@@
@
text
@/*	$OpenBSD: grep.c,v 1.43 2015/03/19 21:22:15 bcallah Exp $	*/

/* This file is in the public domain */

#include <sys/queue.h>
#include <sys/types.h>
#include <ctype.h>
#include <libgen.h>
#include <limits.h>
#include <signal.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <time.h>
#include <unistd.h>

#include "def.h"
#include "kbd.h"
#include "funmap.h"

int	 globalwd = FALSE;
static int	 compile_goto_error(int, int);
int		 next_error(int, int);
static int	 grep(int, int);
static int	 gid(int, int);
static struct buffer	*compile_mode(const char *, const char *);
void grep_init(void);

static char compile_last_command[NFILEN] = "make ";

/*
 * Hints for next-error
 *
 * XXX - need some kind of callback to find out when those get killed.
 */
struct mgwin	*compile_win;
struct buffer	*compile_buffer;

static PF compile_pf[] = {
	compile_goto_error
};

static struct KEYMAPE (1) compilemap = {
	1,
	1,
	rescan,
	{
		{ CCHR('M'), CCHR('M'), compile_pf, NULL }
	}
};

void
grep_init(void)
{
	funmap_add(compile_goto_error, "compile-goto-error");
	funmap_add(next_error, "next-error");
	funmap_add(grep, "grep");
	funmap_add(compile, "compile");
	funmap_add(gid, "gid");
	maps_add((KEYMAP *)&compilemap, "compile");
}

/* ARGSUSED */
static int
grep(int f, int n)
{
	char	 cprompt[NFILEN], *bufp;
	struct buffer	*bp;
	struct mgwin	*wp;

	(void)strlcpy(cprompt, "grep -n ", sizeof(cprompt));
	if ((bufp = eread("Run grep: ", cprompt, NFILEN,
	    EFDEF | EFNEW | EFCR)) == NULL)
		return (ABORT);
	else if (bufp[0] == '\0')
		return (FALSE);
	if (strlcat(cprompt, " /dev/null", sizeof(cprompt)) >= sizeof(cprompt))
		return (FALSE);

	if ((bp = compile_mode("*grep*", cprompt)) == NULL)
		return (FALSE);
	if ((wp = popbuf(bp, WNONE)) == NULL)
		return (FALSE);
	curbp = bp;
	compile_win = curwp = wp;
	return (TRUE);
}

/* ARGSUSED */
int
compile(int f, int n)
{
	char	 cprompt[NFILEN], *bufp;
	struct buffer	*bp;
	struct mgwin	*wp;

	(void)strlcpy(cprompt, compile_last_command, sizeof(cprompt));
	if ((bufp = eread("Compile command: ", cprompt, NFILEN,
	    EFDEF | EFNEW | EFCR)) == NULL)
		return (ABORT);
	else if (bufp[0] == '\0')
		return (FALSE);
	if (savebuffers(f, n) == ABORT)
		return (ABORT);
	(void)strlcpy(compile_last_command, bufp, sizeof(compile_last_command));

	if ((bp = compile_mode("*compile*", cprompt)) == NULL)
		return (FALSE);
	if ((wp = popbuf(bp, WNONE)) == NULL)
		return (FALSE);
	curbp = bp;
	compile_win = curwp = wp;
	gotoline(FFARG, 0);
	return (TRUE);
}

/* id-utils foo. */
/* ARGSUSED */
static int
gid(int f, int n)
{
	char	 command[NFILEN];
	char	 cprompt[NFILEN], *bufp;
	int	c;
	struct buffer	*bp;
	struct mgwin	*wp;
	int	 i, j, len;

	/* catch ([^\s(){}]+)[\s(){}]* */

	i = curwp->w_doto;
	/* Skip backwards over delimiters we are currently on */
	while (i > 0) {
		c = lgetc(curwp->w_dotp, i);
		if (isalnum(c) || c == '_')
			break;

		i--;
	}

	/* Skip the symbol itself */
	for (; i > 0; i--) {
		c = lgetc(curwp->w_dotp, i - 1);
		if (!isalnum(c) && c != '_')
			break;
	}
	/* Fill the symbol in cprompt[] */
	for (j = 0; j < sizeof(cprompt) - 1 && i < llength(curwp->w_dotp);
	    j++, i++) {
		c = lgetc(curwp->w_dotp, i);
		if (!isalnum(c) && c != '_')
			break;
		cprompt[j] = c;
	}
	cprompt[j] = '\0';

	if ((bufp = eread("Run gid (with args): ", cprompt, NFILEN,
	    (j ? EFDEF : 0) | EFNEW | EFCR)) == NULL)
		return (ABORT);
	else if (bufp[0] == '\0')
		return (FALSE);
	len = snprintf(command, sizeof(command), "gid %s", cprompt);
	if (len < 0 || len >= sizeof(command))
		return (FALSE);

	if ((bp = compile_mode("*gid*", command)) == NULL)
		return (FALSE);
	if ((wp = popbuf(bp, WNONE)) == NULL)
		return (FALSE);
	curbp = bp;
	compile_win = curwp = wp;
	return (TRUE);
}

struct buffer *
compile_mode(const char *name, const char *command)
{
	struct buffer	*bp;
	FILE	*fpipe;
	char	*buf;
	size_t	 len;
	int	 ret, n;
	char	 cwd[NFILEN], qcmd[NFILEN];
	char	 timestr[NTIME];
	time_t	 t;

	n = snprintf(qcmd, sizeof(qcmd), "%s 2>&1", command);
	if (n < 0 || n >= sizeof(qcmd))
		return (NULL);

	bp = bfind(name, TRUE);
	if (bclear(bp) != TRUE)
		return (NULL);

	if (getbufcwd(bp->b_cwd, sizeof(bp->b_cwd)) != TRUE)
		return (NULL);
	addlinef(bp, "cd %s", bp->b_cwd);
	addline(bp, qcmd);
	addline(bp, "");

	if (getcwd(cwd, sizeof(cwd)) == NULL)
		panic("Can't get current directory!");
	if (chdir(bp->b_cwd) == -1) {
		dobeep();
		ewprintf("Can't change dir to %s", bp->b_cwd);
		return (NULL);
	}
	if ((fpipe = popen(qcmd, "r")) == NULL) {
		dobeep();
		ewprintf("Problem opening pipe");
		return (NULL);
	}
	/*
	 * We know that our commands are nice and the last line will end with
	 * a \n, so we don't need to try to deal with the last line problem
	 * in fgetln.
	 */
	while ((buf = fgetln(fpipe, &len)) != NULL) {
		buf[len - 1] = '\0';
		addline(bp, buf);
	}
	ret = pclose(fpipe);
	t = time(NULL);
	strftime(timestr, sizeof(timestr), "%a %b %e %T %Y", localtime(&t));
	addline(bp, "");
	if (ret != 0)
		addlinef(bp, "Command exited abnormally with code %d"
		    " at %s", ret, timestr);
	else
		addlinef(bp, "Command finished at %s", timestr);

	bp->b_dotp = bfirstlp(bp);
	bp->b_modes[0] = name_mode("fundamental");
	bp->b_modes[1] = name_mode("compile");
	bp->b_nmodes = 1;

	compile_buffer = bp;

	if (chdir(cwd) == -1) {
		dobeep();
		ewprintf("Can't change dir back to %s", cwd);
		return (NULL);
	}
	return (bp);
}

/* ARGSUSED */
static int
compile_goto_error(int f, int n)
{
	struct buffer	*bp;
	struct mgwin	*wp;
	char	*fname, *line, *lp, *ln;
	int	 lineno;
	char	*adjf, path[NFILEN];
	const char *errstr;
	struct line	*last;

	compile_win = curwp;
	compile_buffer = curbp;
	last = blastlp(compile_buffer);

 retry:
	/* last line is compilation result */
	if (curwp->w_dotp == last)
		return (FALSE);

	if ((line = linetostr(curwp->w_dotp)) == NULL)
		return (FALSE);
	lp = line;
	if ((fname = strsep(&lp, ":")) == NULL || *fname == '\0')
		goto fail;
	if ((ln = strsep(&lp, ":")) == NULL || *ln == '\0')
		goto fail;
	lineno = (int)strtonum(ln, INT_MIN, INT_MAX, &errstr);
	if (errstr)
		goto fail;

	if (fname && fname[0] != '/') {
		if (getbufcwd(path, sizeof(path)) == FALSE)
			goto fail;
		if (strlcat(path, fname, sizeof(path)) >= sizeof(path))
			goto fail;
		adjf = path;
	} else {
		adjf = adjustname(fname, TRUE);
	}
	free(line);

	if (adjf == NULL)
		return (FALSE);

	if ((bp = findbuffer(adjf)) == NULL)
		return (FALSE);
	if ((wp = popbuf(bp, WNONE)) == NULL)
		return (FALSE);
	curbp = bp;
	curwp = wp;
	if (bp->b_fname[0] == '\0')
		readin(adjf);
	gotoline(FFARG, lineno);
	return (TRUE);
fail:
	free(line);
	if (curwp->w_dotp != blastlp(curbp)) {
		curwp->w_dotp = lforw(curwp->w_dotp);
		curwp->w_rflag |= WFMOVE;
		goto retry;
	}
	dobeep();
	ewprintf("No more hits");
	return (FALSE);
}

/* ARGSUSED */
int
next_error(int f, int n)
{
	if (compile_win == NULL || compile_buffer == NULL) {
		dobeep();
		ewprintf("No compilation active");
		return (FALSE);
	}
	curwp = compile_win;
	curbp = compile_buffer;
	if (curwp->w_dotp == blastlp(curbp)) {
		dobeep();
		ewprintf("No more hits");
		return (FALSE);
	}
	curwp->w_dotp = lforw(curwp->w_dotp);
	curwp->w_rflag |= WFMOVE;

	return (compile_goto_error(f, n));
}

/*
 * Since we don't have variables (we probably should) these are command
 * processors for changing the values of mode flags.
 */
/* ARGSUSED */
int
globalwdtoggle(int f, int n)
{
	if (f & FFARG)
		globalwd = n > 0;
	else
		globalwd = !globalwd;

	sgarbf = TRUE;

	return (TRUE);
}
@


1.43
log
@Clean up the includes in mg.
This does the following:
Moves all POSIX headers from sysdef.h into the individual .c files so that
each file now only includes what it needs. All headers are properly sorted.
Moves the remainder of sysdef.h to other files (mostly def.h) and deletes
sysdef.h now that it's no longer contains anything.
Tweak a comment that references sysdef.h so that it no longer does that.
ok florian@@
@
text
@d1 1
a1 1
/*	$OpenBSD: grep.c,v 1.42 2014/11/16 04:16:41 guenther Exp $	*/
d43 2
a44 1
static struct KEYMAPE (1 + IMAPEXT) compilemap = {
a45 1
	1 + IMAPEXT,
@


1.42
log
@Stop using <sys/param.h>; replace MAXPATHLEN with PATH_MAX, stop using MAX(),
and pull in <limits.h> for *_MAX constants.

inspired on a diff from Kamil Rytarowski (n54 (at) gmx.com)
ok bcallah@@
@
text
@d1 1
a1 1
/*	$OpenBSD: grep.c,v 1.41 2014/11/16 00:59:25 guenther Exp $	*/
d5 1
a5 4
#include "def.h"
#include "kbd.h"
#include "funmap.h"

d10 4
d15 5
@


1.41
log
@ctype macros/functions expect unsigned char values.  Note that the lgetc()
macro does the cast internally like getc() does, so its return should be
put an in int for the same reason.

based on a diff from Kamil Rytarowski (n54 (at) gmx.com)
@
text
@d1 1
a1 1
/*	$OpenBSD: grep.c,v 1.40 2014/03/20 07:47:29 lum Exp $	*/
d12 1
@


1.40
log
@Add some missing dobeeps.
ok florian@@
@
text
@d1 1
a1 1
/*	$OpenBSD: grep.c,v 1.39 2013/06/01 17:31:11 lum Exp $	*/
d116 2
a117 1
	char	 cprompt[NFILEN], c, *bufp;
@


1.39
log
@Remove 'lint' mode. lint(1) is gone, and the mode was not documented
anywhere.
ok jasper@@ florian@@
@
text
@d1 1
a1 1
/*	$OpenBSD: grep.c,v 1.38 2009/06/04 23:39:37 kjell Exp $	*/
d196 1
d201 1
d232 1
d302 1
d312 1
d319 1
@


1.38
log
@Add the notion of an "ephemeral" popup, so we can flag a window
for destruction at a later date. (in the process, add a window flag field)

This fixes an issue noted by maja: namely, the *completion*
window that pops up when you try to complete a filename on
buffer load would destroy any second window that you happened
to have open.

ok maja@@
@
text
@d1 1
a1 1
/*	$OpenBSD: grep.c,v 1.37 2009/06/04 02:23:37 kjell Exp $	*/
a19 1
static int	 xlint(int, int);
a50 1
	funmap_add(xlint, "lint");
a73 24
		return (FALSE);
	if ((wp = popbuf(bp, WNONE)) == NULL)
		return (FALSE);
	curbp = bp;
	compile_win = curwp = wp;
	return (TRUE);
}

/* ARGSUSED */
static int
xlint(int f, int n)
{
	char	 cprompt[NFILEN], *bufp;
	struct buffer	*bp;
	struct mgwin	*wp;

	(void)strlcpy(cprompt, "make lint ", sizeof(cprompt));
	if ((bufp = eread("Run lint: ", cprompt, NFILEN,
	    EFDEF | EFNEW | EFCR)) == NULL)
		return (ABORT);
	else if (bufp[0] == '\0')
		return (FALSE);

	if ((bp = compile_mode("*lint*", cprompt)) == NULL)
@


1.37
log
@Rename w_flag to w_rflag. This is not a general purpose
flag: it is for redisplay options only. I need an additional all-purpose
flag, so renaming removes the desire to wrongly overload the existing one.

Turdshine. No functional chage.
@
text
@d1 1
a1 1
/*	$OpenBSD: grep.c,v 1.36 2008/06/14 08:39:30 kjell Exp $	*/
d77 1
a77 1
	if ((wp = popbuf(bp)) == NULL)
d101 1
a101 1
	if ((wp = popbuf(bp)) == NULL)
d128 1
a128 1
	if ((wp = popbuf(bp)) == NULL)
d186 1
a186 1
	if ((wp = popbuf(bp)) == NULL)
d310 1
a310 1
	if ((wp = popbuf(bp)) == NULL)
@


1.36
log
@Add compile (c-C c-P) to the c-mode keymap (export from grep.c)
Also, attempt to make indent an atomic undo operation.
@
text
@d1 1
a1 1
/*	$OpenBSD: grep.c,v 1.35 2008/06/10 00:19:31 kjell Exp $	*/
d322 1
a322 1
		curwp->w_flag |= WFMOVE;
d344 1
a344 1
	curwp->w_flag |= WFMOVE;
@


1.35
log
@Remove copyright notices and put these files back into the public domain.
ok art
@
text
@d1 1
a1 1
/*	$OpenBSD: grep.c,v 1.34 2007/05/28 17:52:17 kjell Exp $	*/
a17 1
static int	 compile(int, int);
d109 1
a109 1
static int
@


1.34
log
@Add a global-wd-mode command, which toggles between the current
behavior (every buffer maintains its own cwd) and the old behavior of
one global working directory. This makes it slightly easier to hack
on things like kernel code, where compilation, etc, are initiated from
a different directory than you are working in.
While here, fix setting/handling of global wd.
@
text
@d1 3
a3 26
/*	$OpenBSD: grep.c,v 1.33 2006/11/19 16:51:19 deraadt Exp $	*/
/*
 * Copyright (c) 2001 Artur Grabowski <art@@openbsd.org>.
 * Copyright (c) 2005 Kjell Wooding <kjell@@openbsd.org>.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
 * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
 * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
@


1.33
log
@spacing
@
text
@d1 1
a1 1
/*	$OpenBSD: grep.c,v 1.32 2006/07/25 08:27:09 kjell Exp $	*/
d37 1
a44 1

d319 2
a320 1
		(void)strlcpy(path, curbp->b_cwd, sizeof(path));
d371 18
@


1.32
log
@Add bfirstlp(), blastlp() macros, returning the first and last lines
of a buffer respectively. Removes an ugly construction than necessitated
"go to first line"-type comments throughout the code.
No binary change
@
text
@d1 1
a1 1
/*	$OpenBSD: grep.c,v 1.31 2006/07/25 08:22:32 kjell Exp $	*/
d306 1
a306 1
	
d317 1
a317 1
	
@


1.31
log
@Rename the header line of a buffer to b_headp, from the remarkably
unintuitive b_linep. No binary change.
@
text
@d1 1
a1 1
/*	$OpenBSD: grep.c,v 1.30 2006/06/01 05:34:52 jason Exp $	*/
d272 1
a272 1
	bp->b_dotp = lforw(bp->b_headp);	/* go to first line */
d300 1
a300 1
	last = lback(compile_buffer->b_headp);
d343 1
a343 1
	if (curwp->w_dotp != lback(curbp->b_headp)) {
d362 1
a362 1
	if (curwp->w_dotp == lback(curbp->b_headp)) {
@


1.30
log
@make // /~ path rewriting optional in adjustname() and use it everywhere
except for the command line specified files.  ok kjell,cloder
@
text
@d1 1
a1 1
/*	$OpenBSD: grep.c,v 1.29 2006/05/27 21:22:45 kjell Exp $	*/
d272 1
a272 1
	bp->b_dotp = lforw(bp->b_linep);	/* go to first line */
d300 1
a300 1
	last = lback(compile_buffer->b_linep);
d343 1
a343 1
	if (curwp->w_dotp != lback(curbp->b_linep)) {
d362 1
a362 1
	if (curwp->w_dotp == lback(curbp->b_linep)) {
@


1.29
log
@Move stderr redirection to a common location, as suggested by vincent a
while ago. While here, get rid of some of the stupid static buffer
sizes. I've been running with this for quite a while.
@
text
@d1 1
a1 1
/*	$OpenBSD: grep.c,v 1.28 2006/05/02 17:10:25 kjell Exp $	*/
d324 1
a324 1
		adjf = adjustname(fname);
@


1.28
log
@Make buffers store their own working directory. This makes things like
grep, compile, lint work as expected (act on current buffer's cwd).
Display this path when opening or replacing a file, rather than
relying on the user to guess, or remember.
@
text
@d1 1
a1 1
/*	$OpenBSD: grep.c,v 1.27 2006/04/03 00:19:32 kjell Exp $	*/
a85 1
	char	 command[NFILEN + 21];
d96 2
a97 1
	(void)snprintf(command, sizeof(command), "%s /dev/null", bufp);
d99 1
a99 1
	if ((bp = compile_mode("*grep*", command)) == NULL)
a111 1
	char	 command[NFILEN + 16];
a121 1
	(void)snprintf(command, sizeof(command), "%s 2>&1", bufp);
d123 1
a123 1
	if ((bp = compile_mode("*lint*", command)) == NULL)
a135 1
	char	 command[NFILEN + 20];
d150 1
a150 3
	(void)snprintf(command, sizeof(command), "%s 2>&1", bufp);

	if ((bp = compile_mode("*compile*", command)) == NULL)
d165 1
a165 1
	char	 command[NFILEN + 20];
d169 1
a169 1
	int	 i, j;
d204 3
a206 1
	(void)snprintf(command, sizeof(command), "gid %s", cprompt);
d224 2
a225 2
	int	 ret;
	char	 cwd[NFILEN];
d229 4
d240 1
a240 1
	addline(bp, command);
d249 1
a249 1
	if ((fpipe = popen(command, "r")) == NULL) {
d293 1
a293 1
	int	 lineno, len;
d306 2
a307 4

	len = llength(curwp->w_dotp);

	if ((line = malloc(len + 1)) == NULL)
a308 4

	(void)memcpy(line, curwp->w_dotp->l_text, len);
	line[len] = '\0';

@


1.27
log
@Always leave compile buffer on first line after compilation.
Change 0->NUL while I'm here.
@
text
@d1 1
a1 1
/*	$OpenBSD: grep.c,v 1.26 2005/12/13 07:20:13 kjell Exp $	*/
d42 1
a42 2
static struct buffer	*compile_mode(const char *, const char *, const char *);
static int	 getbufcwd(char *, size_t);
a89 8
	char	 path[NFILEN];

	/* get buffer cwd */
	if (getbufcwd(path, sizeof(path)) == FALSE) {
		ewprintf("Failed. "
		    "Can't get working directory of current buffer.");
		return (FALSE);
	}
d99 1
a99 1
	if ((bp = compile_mode("*grep*", command, path)) == NULL)
a115 8
	char	 path[NFILEN];

	/* get buffer cwd */
	if (getbufcwd(path, sizeof(path)) == FALSE) {
		ewprintf("Failed. "
		    "Can't get working directory of current buffer.");
		return (FALSE);
	}
d125 1
a125 1
	if ((bp = compile_mode("*lint*", command, path)) == NULL)
a141 8
	char	 path[NFILEN];

	/* get buffer cwd */
	if (getbufcwd(path, sizeof(path)) == FALSE) {
		ewprintf("Failed. "
		    "Can't get working directory of current buffer.");
		return (FALSE);
	}
d155 1
a155 1
	if ((bp = compile_mode("*compile*", command, path)) == NULL)
a174 8
	char	 path[NFILEN];

	/* get buffer cwd */
	if (getbufcwd(path, sizeof(path)) == FALSE) {
		ewprintf("Failed. "
		    "Can't get working directory of current buffer.");
		return (FALSE);
	}
d211 1
a211 1
	if ((bp = compile_mode("*gid*", command, path)) == NULL)
d221 1
a221 1
compile_mode(const char *name, const char *command, const char *path)
d236 3
a238 1
	addlinef(bp, "cd %s", path);
d244 2
a245 2
	if (chdir(path) == -1) {
		ewprintf("Can't change dir to %s", path);
d293 1
a293 1
	char	*adjf;
d322 9
a330 2

	adjf = adjustname(fname);
a374 30
}

/*
 * Return the working directory for the current buffer, terminated
 * with a '/'. First, try to extract it from the current buffer's
 * filename. If that fails, use global cwd.
 */
static int
getbufcwd(char *path, size_t plen)
{
	char *dname, cwd[NFILEN];
	if (plen == 0)
		goto error;

	if (curbp->b_fname && curbp->b_fname[0] != '\0' &&
	    (dname = dirname(curbp->b_fname)) != NULL) {
		if (strlcpy(path, dname, plen) >= plen)
			goto error;
		if (strlcat(path, "/", plen) >= plen)
			goto error;
	} else {
		if ((dname = getcwd(cwd, sizeof(cwd))) == NULL)
			goto error;
		if (strlcpy(path, dname, plen) >= plen)
			goto error;
	}
	return (TRUE);
error:
	path = NULL;
	return (FALSE);
@


1.26
log
@Last round of easy delinting.
@
text
@d1 1
a1 1
/*	$OpenBSD: grep.c,v 1.25 2005/12/13 02:08:06 kjell Exp $	*/
d186 1
d366 1
a366 1
	if (bp->b_fname[0] == 0)
@


1.25
log
@Add a "M-x lint" mode, now that lint is next-error friendly.
While here, delint some name clashes.
@
text
@d1 1
a1 1
/*	$OpenBSD: grep.c,v 1.24 2005/11/18 20:56:53 deraadt Exp $	*/
d256 1
a256 1
	FILE	*pipe;
d278 1
a278 1
	if ((pipe = popen(command, "r")) == NULL) {
d287 1
a287 1
	while ((buf = fgetln(pipe, &len)) != NULL) {
d291 1
a291 1
	ret = pclose(pipe);
@


1.24
log
@greedy use of typedef struct was making code harder to read; ok kjell cloder
@
text
@d1 1
a1 1
/*	$OpenBSD: grep.c,v 1.23 2005/11/12 19:13:09 deraadt Exp $	*/
d44 1
d77 1
d87 2
a88 2
	char	 command[NFILEN + 20];
	char	 prompt[NFILEN], *bufp;
d100 2
a101 2
	(void)strlcpy(prompt, "grep -n ", sizeof(prompt));
	if ((bufp = eread("Run grep: ", prompt, NFILEN,
d119 34
d156 1
a156 1
	char	 prompt[NFILEN], *bufp;
d168 2
a169 2
	(void)strlcpy(prompt, compile_last_command, sizeof(prompt));
	if ((bufp = eread("Compile command: ", prompt, NFILEN,
d195 1
a195 1
	char	 prompt[NFILEN], c, *bufp;
d226 2
a227 2
	/* Fill the symbol in prompt[] */
	for (j = 0; j < sizeof(prompt) - 1 && i < llength(curwp->w_dotp);
d232 1
a232 1
		prompt[j] = c;
d234 1
a234 1
	prompt[j] = '\0';
d236 1
a236 1
	if ((bufp = eread("Run gid (with args): ", prompt, NFILEN,
d241 1
a241 1
	(void)snprintf(command, sizeof(command), "gid %s", prompt);
@


1.23
log
@remove unused variable; ok kjell
@
text
@d1 1
a1 1
/*	$OpenBSD: grep.c,v 1.22 2005/11/11 18:40:51 deraadt Exp $	*/
d42 1
a42 1
static BUFFER	*compile_mode(const char *, const char *, const char *);
d54 2
a55 2
MGWIN	*compile_win;
BUFFER	*compile_buffer;
d87 2
a88 2
	BUFFER	*bp;
	MGWIN	*wp;
d121 2
a122 2
	BUFFER	*bp;
	MGWIN	*wp;
d160 2
a161 2
	BUFFER	*bp;
	MGWIN	*wp;
d216 1
a216 1
BUFFER *
d219 1
a219 1
	BUFFER	*bp;
d283 2
a284 2
	BUFFER	*bp;
	MGWIN	*wp;
d289 1
a289 1
	LINE	*last;
d313 1
a313 1
	lineno = strtonum(ln, INT_MIN, INT_MAX, &errstr);
@


1.22
log
@spacing
@
text
@d1 1
a1 1
/*	$OpenBSD: grep.c,v 1.21 2005/10/18 21:22:52 kjell Exp $	*/
d224 1
a224 1
	char	*wdir, cwd[NFILEN];
d236 1
a236 1
	if ((wdir = getcwd(cwd, sizeof(cwd))) == NULL)
@


1.21
log
@Don't consider the last line of the compilation buffer as
parsable output. It is always a status message.
While here, some better error checking.
looks ok, cloder@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: grep.c,v 1.20 2005/10/14 19:46:46 kjell Exp $	*/
d294 1
a294 1
 
@


1.20
log
@add missing /* ARGSUSED */ to quiet lint.
@
text
@d1 1
a1 1
/*	$OpenBSD: grep.c,v 1.19 2005/10/13 20:28:49 deraadt Exp $	*/
d42 1
a42 1
static BUFFER	*compile_mode(char *, char *, char *);
d217 1
a217 1
compile_mode(char *name, char *command, char *path)
d285 1
a285 1
	char	*fname, *line, *lp, *ln, *lp1;
d288 2
d293 6
a299 1
retry:
d309 1
a309 1
	if ((fname = strsep(&lp, ":")) == NULL)
d311 1
a311 1
	if ((ln = strsep(&lp, ":")) == NULL)
d313 2
a314 2
	lineno = strtol(ln, &lp1, 10);
	if (lp != lp1 + 1)
@


1.19
log
@spacing
@
text
@d1 1
a1 1
/*	$OpenBSD: grep.c,v 1.18 2005/10/13 05:24:52 kjell Exp $	*/
d81 1
d115 1
d154 1
d279 1
d337 1
@


1.18
log
@Make mg's grep and compile more path-aware, by defaulting to
the path of the invoking buffer.
Also, make subshell output look more like emacs (show directory,
completion time). oked at one point by deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: grep.c,v 1.17 2005/10/11 00:50:00 kjell Exp $	*/
d221 1
a221 1
	char 	*wdir, cwd[NFILEN];
d238 1
a238 1
	}	
d272 1
a272 1
	}	
@


1.17
log
@Enable the 'next-error' (C-x `) keybinding by default.
Niklas, this one is for you.
ok deraadt@@, cloder@@
@
text
@d1 1
a1 1
/*	$OpenBSD: grep.c,v 1.16 2005/08/09 00:53:48 kjell Exp $	*/
d3 3
a5 1
 * Copyright (c) 2001 Artur Grabowski <art@@openbsd.org>.  All rights reserved.
d32 1
d34 2
d42 2
a43 2
static BUFFER	*compile_mode(char *, char *);

d88 8
d105 1
a105 1
	if ((bp = compile_mode("*grep*", command)) == NULL)
d121 8
d142 1
a142 1
	if ((bp = compile_mode("*compile*", command)) == NULL)
d160 8
d204 1
a204 1
	if ((bp = compile_mode("*gid*", command)) == NULL)
d214 1
a214 1
compile_mode(char *name, char *command)
d221 3
d229 2
a230 1
	addlinef(bp, "Running (%s).", command);
d233 6
d253 2
d256 6
a261 2
	addlinef(bp, "Command (%s) completed %s.", command,
		ret == 0 ? "successfully" : "with errors");
d269 4
d350 30
@


1.16
log
@Clean up eread handling in mg. (basically, fallout from the 'enter often
means abort' behaviour added during the hackathon). Eliminates
redundant ereply function, fixes miscellaneous cores when aborting,
and move a number of assumed pathnames into the prompt text, since
they are used there anyway. All changes consistent with emacs behavior

ok beck@@ many, many moons ago.
@
text
@d1 1
a1 1
/*	$OpenBSD: grep.c,v 1.15 2005/06/03 23:39:55 cloder Exp $	*/
d33 1
a33 1
static int	 next_error(int, int);
d284 1
a284 1
static int
@


1.15
log
@Make M-x gid tokenize C identifiers correctly. Problem reported by mjc.
Testing and OK mjc
@
text
@d1 1
a1 1
/*	$OpenBSD: grep.c,v 1.14 2005/05/25 20:15:18 jason Exp $	*/
d85 2
a86 2
	if ((bufp = eread("Run grep: ", prompt, NFILEN, EFDEF|EFNEW|EFCR))
	    == NULL)
d88 2
a89 1

d110 2
a111 1
	if ((bufp = eread("Compile command: ", prompt, NFILEN, EFDEF|EFNEW|EFCR)) == NULL)
d113 2
d169 1
a169 1
	    (j ? EFDEF : 0)|EFNEW|EFCR)) == NULL)
d171 2
@


1.14
log
@in M-x compile, after prompting for command, check buffers and optionally
save them.  ok cloder@@
@
text
@d1 1
a1 1
/*	$OpenBSD: grep.c,v 1.13 2005/04/03 02:09:28 db Exp $	*/
d139 6
a144 3
	/* Skip delimiters we are currently on */
	while (i > 0 && ((c = lgetc(curwp->w_dotp, i)) == '(' || c == ')' ||
	    c == '{' || c == '}' || isspace(c)))
d146 2
d151 1
a151 2
		if (isspace(c) || c == '(' || c == ')' ||
		    c == '{' || c == '}')
d158 1
a158 2
		if (isspace(c) || c == '(' || c == ')' ||
		    c == '{' || c == '}')
@


1.13
log
@This is a no binary change which does:

- spelling, punctuation fixes
- variable declaration lineup
- use parentheses for return and sizeof
- K&R function declarations -> ANSI
- other minor code beautification

ok henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: grep.c,v 1.12 2004/07/22 01:25:25 vincent Exp $	*/
d110 2
@


1.12
log
@stage 1 of the infinite minibuffer work - add support for on the fly
buffer reallocation in veread().  This commit only changes the API.
All the buffers have exactly the same bounds as before for now.

tested by a couple of my very helpful testers!
@
text
@d1 1
a1 1
/*	$OpenBSD: grep.c,v 1.11 2004/06/12 15:04:41 vincent Exp $	*/
d32 5
a36 5
static int	compile_goto_error(int, int);
static int	next_error(int, int);
static int	grep(int, int);
static int	compile(int, int);
static int	gid(int, int);
d49 2
a50 2
MGWIN *compile_win;
BUFFER *compile_buffer;
d53 1
a53 1
	compile_goto_error,
d61 1
a61 1
		{ CCHR('M'), CCHR('M'), compile_pf, NULL },
d79 4
a82 4
	char command[NFILEN + 20];
	char prompt[NFILEN], *bufp;
	BUFFER *bp;
	MGWIN *wp;
d84 1
a84 1
	(void)strlcpy(prompt, "grep -n ", sizeof prompt);
d87 1
a87 1
		return ABORT;
d89 1
a89 1
	(void)snprintf(command, sizeof command, "%s /dev/null", bufp);
d92 1
a92 1
		return FALSE;
d94 1
a94 1
		return FALSE;
d97 1
a97 1
	return TRUE;
d103 4
a106 4
	char command[NFILEN + 20];
	char prompt[NFILEN], *bufp;
	BUFFER *bp;
	MGWIN *wp;
d108 1
a108 1
	(void)strlcpy(prompt, compile_last_command, sizeof prompt);
d110 2
a111 2
		return ABORT;
	(void)strlcpy(compile_last_command, bufp, sizeof compile_last_command);
d113 1
a113 1
	(void)snprintf(command, sizeof command, "%s 2>&1", bufp);
d116 1
a116 1
		return FALSE;
d118 1
a118 1
		return FALSE;
d121 1
a121 1
	return TRUE;
d128 5
a132 5
	char command[NFILEN + 20];
	char prompt[NFILEN], c, *bufp;
	BUFFER *bp;
	MGWIN *wp;
	int i, j;
d161 2
a162 2
		return ABORT;
	(void)snprintf(command, sizeof command, "gid %s", prompt);
d165 1
a165 1
		return FALSE;
d167 1
a167 1
		return FALSE;
d170 1
a170 1
	return TRUE;
d176 5
a180 5
	BUFFER *bp;
	FILE *pipe;
	char *buf;
	size_t len;
	int ret;
d184 1
a184 1
		return NULL;
d191 1
a191 1
		return NULL;
d213 1
a213 1
	return bp;
d219 5
a223 5
	BUFFER *bp;
	MGWIN *wp;
	char *fname, *line, *lp, *ln, *lp1;
	int lineno, len;
	char *adjf;
d232 1
a232 1
		return FALSE;
d253 1
a253 1
		return FALSE;
d255 1
a255 1
		return FALSE;
d261 1
a261 1
	return TRUE;
d270 1
a270 1
	return FALSE;
d278 1
a278 1
		return FALSE;
d284 1
a284 1
		return FALSE;
d289 1
a289 1
	return compile_goto_error(f, n);
@


1.11
log
@make M-x gid try to guess the symbol name to look up by looking at the
current word.

ok beck@@
@
text
@d1 1
a1 1
/*	$OpenBSD: grep.c,v 1.10 2004/01/15 20:55:47 vincent Exp $	*/
d80 1
a80 1
	char prompt[NFILEN];
d85 2
a86 1
	if (eread("Run grep: ", prompt, NFILEN, EFDEF|EFNEW|EFCR) == ABORT)
d89 1
a89 1
	(void)snprintf(command, sizeof command, "%s /dev/null", prompt);
d104 1
a104 1
	char prompt[NFILEN];
d109 1
a109 1
	if (eread("Compile command: ", prompt, NFILEN, EFDEF|EFNEW|EFCR) == ABORT)
d111 1
a111 1
	(void)strlcpy(compile_last_command, prompt, sizeof compile_last_command);
d113 1
a113 1
	(void)snprintf(command, sizeof command, "%s 2>&1", prompt);
d129 1
a129 1
	char prompt[NFILEN], c;
d159 2
a160 2
	if (eread("Run gid (with args): ", prompt, NFILEN,
	    (j ? EFDEF : 0)|EFNEW|EFCR) == ABORT)
@


1.10
log
@fix an early free that made compile-goto-error work only from time to time
@
text
@d1 1
a1 1
/*	$OpenBSD: grep.c,v 1.9 2003/11/09 00:16:36 vincent Exp $	*/
d30 2
d128 1
a128 1
	char prompt[NFILEN];
d131 1
d133 27
a159 1
	if (eread("Run gid (with args): ", prompt, NFILEN, EFNEW|EFCR) == ABORT)
a160 1

@


1.9
log
@knf
@
text
@d1 1
a1 1
/*	$OpenBSD: grep.c,v 1.8 2003/04/08 21:19:57 vincent Exp $	*/
d216 2
a219 1
	adjf = adjustname(fname);
d222 1
@


1.8
log
@remember the last M-x compile command used.

ok art@@
@
text
@d1 1
a1 1
/*	$OpenBSD: grep.c,v 1.7 2002/07/25 16:37:54 vincent Exp $	*/
d30 2
a31 2
static int	compile_goto_error(int f, int n);
static int	next_error(int f, int n);
d35 1
a35 1
static BUFFER	*compile_mode(char *name, char *command);
@


1.7
log
@ replace the ugly and buggy adjustname function by a simple one using
simple APIs. makes mg not crash with 65k filenames...

 ok art@@
@
text
@d1 1
a1 1
/*	$OpenBSD: grep.c,v 1.6 2002/07/01 14:33:44 vincent Exp $	*/
d40 2
d105 1
a105 1
	(void)strlcpy(prompt, "make ", sizeof prompt);
d108 1
@


1.6
log
@KNF + ansi; from zyrnix (only the easy part of his diffs)
@
text
@d1 1
a1 1
/*	$OpenBSD: grep.c,v 1.5 2002/03/18 01:22:31 vincent Exp $	*/
d216 2
@


1.5
log
@ grep/compile mode shouldn't be readonly by default.

 ok art@@
@
text
@d1 1
a1 1
/*	$OpenBSD: grep.c,v 1.4 2002/03/16 19:30:29 vincent Exp $	*/
d80 1
a80 1
	strlcpy(prompt, "grep -n ", sizeof prompt);
d84 1
a84 1
	snprintf(command, sizeof command, "%s /dev/null", prompt);
d103 1
a103 1
	strlcpy(prompt, "make ", sizeof prompt);
d107 1
a107 1
	snprintf(command, sizeof command, "%s 2>&1", prompt);
d130 1
a130 1
	snprintf(command, sizeof command, "gid %s", prompt);
d202 1
a202 1
	memcpy(line, curwp->w_dotp->l_text, len);
@


1.4
log
@ Make these special buffers readonly by default. ok art@@
@
text
@d1 1
a1 1
/*	$OpenBSD: grep.c,v 1.3 2002/02/14 14:24:21 deraadt Exp $	*/
a152 1
	bp->b_flag |= BFREADONLY;
@


1.3
log
@some KNF
@
text
@d1 1
a1 1
/*	$OpenBSD: grep.c,v 1.2 2001/11/25 07:34:17 deraadt Exp $	*/
d153 1
@


1.2
log
@snprintf makes me happy
@
text
@d1 1
a1 1
/*	$OpenBSD: grep.c,v 1.1 2001/05/24 10:58:34 art Exp $	*/
d103 1
a103 1
	strcpy(prompt, "make ");
d154 1
a154 1
	addlinef(bp, "Running (%s).", command); 
d227 1
a227 1
 	free(line);
d234 1
a234 1
 	return FALSE;
@


1.1
log
@Add a compile/grep/id-utils mode.

The only pollution this code introduces in the rest of thed code is a call to
an init function in main(). In the future we might want to load extensions
like this dynamically.

Of course I did the test compile in the compile mode.
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d80 1
a80 1
	strcpy(prompt, "grep -n ");
d84 1
a84 1
	sprintf(command, "%s /dev/null", prompt);
d107 1
a107 1
	sprintf(command, "%s 2>&1", prompt);
d130 1
a130 1
	sprintf(command, "gid %s", prompt);
@

