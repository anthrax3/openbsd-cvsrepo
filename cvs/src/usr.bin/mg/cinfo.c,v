head	1.18;
access;
symbols
	OPENBSD_6_2:1.18.0.12
	OPENBSD_6_2_BASE:1.18
	OPENBSD_6_1:1.18.0.10
	OPENBSD_6_1_BASE:1.18
	OPENBSD_6_0:1.18.0.6
	OPENBSD_6_0_BASE:1.18
	OPENBSD_5_9:1.18.0.2
	OPENBSD_5_9_BASE:1.18
	OPENBSD_5_8:1.18.0.4
	OPENBSD_5_8_BASE:1.18
	OPENBSD_5_7:1.16.0.10
	OPENBSD_5_7_BASE:1.16
	OPENBSD_5_6:1.16.0.14
	OPENBSD_5_6_BASE:1.16
	OPENBSD_5_5:1.16.0.12
	OPENBSD_5_5_BASE:1.16
	OPENBSD_5_4:1.16.0.8
	OPENBSD_5_4_BASE:1.16
	OPENBSD_5_3:1.16.0.6
	OPENBSD_5_3_BASE:1.16
	OPENBSD_5_2:1.16.0.4
	OPENBSD_5_2_BASE:1.16
	OPENBSD_5_1_BASE:1.16
	OPENBSD_5_1:1.16.0.2
	OPENBSD_5_0:1.15.0.24
	OPENBSD_5_0_BASE:1.15
	OPENBSD_4_9:1.15.0.22
	OPENBSD_4_9_BASE:1.15
	OPENBSD_4_8:1.15.0.20
	OPENBSD_4_8_BASE:1.15
	OPENBSD_4_7:1.15.0.16
	OPENBSD_4_7_BASE:1.15
	OPENBSD_4_6:1.15.0.18
	OPENBSD_4_6_BASE:1.15
	OPENBSD_4_5:1.15.0.14
	OPENBSD_4_5_BASE:1.15
	OPENBSD_4_4:1.15.0.12
	OPENBSD_4_4_BASE:1.15
	OPENBSD_4_3:1.15.0.10
	OPENBSD_4_3_BASE:1.15
	OPENBSD_4_2:1.15.0.8
	OPENBSD_4_2_BASE:1.15
	OPENBSD_4_1:1.15.0.6
	OPENBSD_4_1_BASE:1.15
	OPENBSD_4_0:1.15.0.4
	OPENBSD_4_0_BASE:1.15
	OPENBSD_3_9:1.15.0.2
	OPENBSD_3_9_BASE:1.15
	OPENBSD_3_8:1.12.0.2
	OPENBSD_3_8_BASE:1.12
	OPENBSD_3_7:1.10.0.12
	OPENBSD_3_7_BASE:1.10
	OPENBSD_3_6:1.10.0.10
	OPENBSD_3_6_BASE:1.10
	OPENBSD_3_5:1.10.0.8
	OPENBSD_3_5_BASE:1.10
	OPENBSD_3_4:1.10.0.6
	OPENBSD_3_4_BASE:1.10
	OPENBSD_3_3:1.10.0.4
	OPENBSD_3_3_BASE:1.10
	OPENBSD_3_2:1.10.0.2
	OPENBSD_3_2_BASE:1.10
	OPENBSD_3_1:1.8.0.2
	OPENBSD_3_1_BASE:1.8
	OPENBSD_3_0:1.6.0.2
	OPENBSD_3_0_BASE:1.6
	OPENBSD_2_9_BASE:1.3
	OPENBSD_2_9:1.3.0.2
	OPENBSD_2_8:1.2.0.4
	OPENBSD_2_8_BASE:1.2
	OPENBSD_2_7:1.2.0.2
	OPENBSD_2_7_BASE:1.2;
locks; strict;
comment	@ * @;


1.18
date	2015.03.19.21.22.15;	author bcallah;	state Exp;
branches;
next	1.17;
commitid	GbEBL4CfPvDkB8hj;

1.17
date	2015.03.17.18.08.52;	author bcallah;	state Exp;
branches;
next	1.16;
commitid	ZNG0kOG8IxZdy28m;

1.16
date	2011.11.28.04.41.39;	author lum;	state Exp;
branches;
next	1.15;

1.15
date	2005.12.13.06.01.27;	author kjell;	state Exp;
branches;
next	1.14;

1.14
date	2005.11.18.20.56.52;	author deraadt;	state Exp;
branches;
next	1.13;

1.13
date	2005.10.13.06.20.25;	author kjell;	state Exp;
branches;
next	1.12;

1.12
date	2005.06.14.18.14.40;	author kjell;	state Exp;
branches;
next	1.11;

1.11
date	2005.04.03.02.09.28;	author db;	state Exp;
branches;
next	1.10;

1.10
date	2002.07.01.14.33.44;	author vincent;	state Exp;
branches;
next	1.9;

1.9
date	2002.05.06.19.22.38;	author deraadt;	state Exp;
branches;
next	1.8;

1.8
date	2002.03.11.13.02.56;	author vincent;	state Exp;
branches;
next	1.7;

1.7
date	2002.02.14.02.50.10;	author vincent;	state Exp;
branches;
next	1.6;

1.6
date	2001.05.23.23.29.47;	author mickey;	state Exp;
branches;
next	1.5;

1.5
date	2001.05.23.22.20.35;	author art;	state Exp;
branches;
next	1.4;

1.4
date	2001.05.23.21.55.32;	author art;	state Exp;
branches;
next	1.3;

1.3
date	2001.01.29.01.58.06;	author niklas;	state Exp;
branches;
next	1.2;

1.2
date	2000.04.13.06.12.13;	author millert;	state Exp;
branches;
next	1.1;

1.1
date	2000.02.25.19.08.46;	author deraadt;	state Exp;
branches;
next	;


desc
@@


1.18
log
@Clean up the includes in mg.
This does the following:
Moves all POSIX headers from sysdef.h into the individual .c files so that
each file now only includes what it needs. All headers are properly sorted.
Moves the remainder of sysdef.h to other files (mostly def.h) and deletes
sysdef.h now that it's no longer contains anything.
Tweak a comment that references sysdef.h so that it no longer does that.
ok florian@@
@
text
@/*	$OpenBSD: cinfo.c,v 1.17 2015/03/17 18:08:52 bcallah Exp $	*/

/* This file is in the public domain. */

/*
 *		Character class tables.
 * Do it yourself character classification
 * macros, that understand the multinational character set,
 * and let me ask some questions the standard macros (in
 * ctype.h) don't let you ask.
 */

#include <sys/queue.h>
#include <signal.h>
#include <stdio.h>
#include <string.h>

#include "def.h"

/*
 * This table, indexed by a character drawn
 * from the 256 member character set, is used by my
 * own character type macros to answer questions about the
 * type of a character. It handles the full multinational
 * character set, and lets me ask some questions that the
 * standard "ctype" macros cannot ask.
 */
/*
 * Due to incompatible behaviour between "standard" emacs and
 * ctags word traversing, '_' character's value is changed on 
 * the fly in ctags mode, hence non-const.
 */
char cinfo[256] = {
	_MG_C, _MG_C, _MG_C, _MG_C,				      /* 0x0X */
	_MG_C, _MG_C, _MG_C, _MG_C,
	_MG_C, _MG_C, _MG_C, _MG_C,
	_MG_C, _MG_C, _MG_C, _MG_C,
	_MG_C, _MG_C, _MG_C, _MG_C,				      /* 0x1X */
	_MG_C, _MG_C, _MG_C, _MG_C,
	_MG_C, _MG_C, _MG_C, _MG_C,
	_MG_C, _MG_C, _MG_C, _MG_C,
	0, _MG_P, 0, 0,						      /* 0x2X */
	_MG_W, _MG_W, 0, _MG_W,
	0, 0, 0, 0,
	0, 0, _MG_P, 0,
	_MG_D | _MG_W, _MG_D | _MG_W, _MG_D | _MG_W, _MG_D | _MG_W,   /* 0x3X */
	_MG_D | _MG_W, _MG_D | _MG_W, _MG_D | _MG_W, _MG_D | _MG_W,
	_MG_D | _MG_W, _MG_D | _MG_W, 0, 0,
	0, 0, 0, _MG_P,
	0, _MG_U | _MG_W, _MG_U | _MG_W, _MG_U | _MG_W,		      /* 0x4X */
	_MG_U | _MG_W, _MG_U | _MG_W, _MG_U | _MG_W, _MG_U | _MG_W,
	_MG_U | _MG_W, _MG_U | _MG_W, _MG_U | _MG_W, _MG_U | _MG_W,
	_MG_U | _MG_W, _MG_U | _MG_W, _MG_U | _MG_W, _MG_U | _MG_W,
	_MG_U | _MG_W, _MG_U | _MG_W, _MG_U | _MG_W, _MG_U | _MG_W,   /* 0x5X */
	_MG_U | _MG_W, _MG_U | _MG_W, _MG_U | _MG_W, _MG_U | _MG_W,
	_MG_U | _MG_W, _MG_U | _MG_W, _MG_U | _MG_W, 0,
	0, 0, 0, 0,
	0, _MG_L | _MG_W, _MG_L | _MG_W, _MG_L | _MG_W,		      /* 0x6X */
	_MG_L | _MG_W, _MG_L | _MG_W, _MG_L | _MG_W, _MG_L | _MG_W,
	_MG_L | _MG_W, _MG_L | _MG_W, _MG_L | _MG_W, _MG_L | _MG_W,
	_MG_L | _MG_W, _MG_L | _MG_W, _MG_L | _MG_W, _MG_L | _MG_W,
	_MG_L | _MG_W, _MG_L | _MG_W, _MG_L | _MG_W, _MG_L | _MG_W,   /* 0x7X */
	_MG_L | _MG_W, _MG_L | _MG_W, _MG_L | _MG_W, _MG_L | _MG_W,
	_MG_L | _MG_W, _MG_L | _MG_W, _MG_L | _MG_W, 0,
	0, 0, 0, _MG_C,
	0, 0, 0, 0,						      /* 0x8X */
	0, 0, 0, 0,
	0, 0, 0, 0,
	0, 0, 0, 0,
	0, 0, 0, 0,						      /* 0x9X */
	0, 0, 0, 0,
	0, 0, 0, 0,
	0, 0, 0, 0,
	0, 0, 0, 0,						      /* 0xAX */
	0, 0, 0, 0,
	0, 0, 0, 0,
	0, 0, 0, 0,
	0, 0, 0, 0,						      /* 0xBX */
	0, 0, 0, 0,
	0, 0, 0, 0,
	0, 0, 0, 0,
	_MG_U | _MG_W, _MG_U | _MG_W, _MG_U | _MG_W, _MG_U | _MG_W,   /* 0xCX */
	_MG_U | _MG_W, _MG_U | _MG_W, _MG_U | _MG_W, _MG_U | _MG_W,
	_MG_U | _MG_W, _MG_U | _MG_W, _MG_U | _MG_W, _MG_U | _MG_W,
	_MG_U | _MG_W, _MG_U | _MG_W, _MG_U | _MG_W, _MG_U | _MG_W,
	0, _MG_U | _MG_W, _MG_U | _MG_W, _MG_U | _MG_W,		      /* 0xDX */
	_MG_U | _MG_W, _MG_U | _MG_W, _MG_U | _MG_W, _MG_U | _MG_W,
	_MG_U | _MG_W, _MG_U | _MG_W, _MG_U | _MG_W, _MG_U | _MG_W,
	_MG_U | _MG_W, _MG_U | _MG_W, 0, _MG_W,
	_MG_L | _MG_W, _MG_L | _MG_W, _MG_L | _MG_W, _MG_L | _MG_W,   /* 0xEX */
	_MG_L | _MG_W, _MG_L | _MG_W, _MG_L | _MG_W, _MG_L | _MG_W,
	_MG_L | _MG_W, _MG_L | _MG_W, _MG_L | _MG_W, _MG_L | _MG_W,
	_MG_L | _MG_W, _MG_L | _MG_W, _MG_L | _MG_W, _MG_L | _MG_W,
	0, _MG_L | _MG_W, _MG_L | _MG_W, _MG_L | _MG_W,		      /* 0xFX */
	_MG_L | _MG_W, _MG_L | _MG_W, _MG_L | _MG_W, _MG_L | _MG_W,
	_MG_L | _MG_W, _MG_L | _MG_W, _MG_L | _MG_W, _MG_L | _MG_W,
	_MG_L | _MG_W, _MG_L | _MG_W, 0, 0
};

/*
 * Find the name of a keystroke.  Needs to be changed to handle 8-bit printing
 * characters and function keys better.	 Returns a pointer to the terminating
 * '\0'.  Returns NULL on failure.
 */
char *
getkeyname(char *cp, size_t len, int k)
{
	const char	*np;
	size_t		 copied;

	if (k < 0)
		k = CHARMASK(k);	/* sign extended char */
	switch (k) {
	case CCHR('@@'):
		np = "C-SPC";
		break;
	case CCHR('I'):
		np = "TAB";
		break;
	case CCHR('M'):
		np = "RET";
		break;
	case CCHR('['):
		np = "ESC";
		break;
	case ' ':
		np = "SPC";
		break;		/* yuck again */
	case CCHR('?'):
		np = "DEL";
		break;
	default:
		if (k >= KFIRST && k <= KLAST &&
		    (np = keystrings[k - KFIRST]) != NULL)
			break;
		if (k > CCHR('?')) {
			*cp++ = '0';
			*cp++ = ((k >> 6) & 7) + '0';
			*cp++ = ((k >> 3) & 7) + '0';
			*cp++ = (k & 7) + '0';
			*cp = '\0';
			return (cp);
		} else if (k < ' ') {
			*cp++ = 'C';
			*cp++ = '-';
			k = CCHR(k);
			if (ISUPPER(k))
				k = TOLOWER(k);
		}
		*cp++ = k;
		*cp = '\0';
		return (cp);
	}
	copied = strlcpy(cp, np, len);
	if (copied >= len)
		copied = len - 1;
	return (cp + copied);
}
@


1.17
log
@It is impossible to build mg without both -DFKEYS and -DXKEYS. So let's
enforce that and remove the options.
Mostly mechanical diff from unifdef with bonus removal of comments that no
longer have any relevance.
ok florian@@
@
text
@d1 1
a1 1
/*	$OpenBSD: cinfo.c,v 1.16 2011/11/28 04:41:39 lum Exp $	*/
d12 7
a18 1
#include	"def.h"
@


1.16
log
@Add some ctags support to mg. From Sunil Nimmagadda.

Man page review and suggestions from jmc@@

Revewied and tested by myself, and ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: cinfo.c,v 1.15 2005/12/13 06:01:27 kjell Exp $	*/
a126 1
#ifdef	FKEYS
a129 1
#endif
@


1.15
log
@More name-clash delinting
@
text
@d1 1
a1 1
/*	$OpenBSD: cinfo.c,v 1.14 2005/11/18 20:56:52 deraadt Exp $	*/
d22 6
a27 1
const char cinfo[256] = {
@


1.14
log
@greedy use of typedef struct was making code harder to read; ok kjell cloder
@
text
@d1 1
a1 1
/*	$OpenBSD: cinfo.c,v 1.13 2005/10/13 06:20:25 kjell Exp $	*/
d95 1
a95 1
keyname(char *cp, size_t len, int k)
@


1.13
log
@add the (emacs) toggle-readonly keybinding (C-x C-q).
Also, remove a silly non-emacsism.
@
text
@d1 1
a1 1
/*	$OpenBSD: cinfo.c,v 1.12 2005/06/14 18:14:40 kjell Exp $	*/
d97 2
a98 2
	const char  *np;
	size_t	     copied;
@


1.12
log
@Add explicit public domain notices to all public domain files.
ok millert@@, deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: cinfo.c,v 1.11 2005/04/03 02:09:28 db Exp $	*/
a108 3
	case CCHR('J'):
		np = "LFD";
		break;		/* yuck, but that's what GNU calls it */
@


1.11
log
@This is a no binary change which does:

- spelling, punctuation fixes
- variable declaration lineup
- use parentheses for return and sizeof
- K&R function declarations -> ANSI
- other minor code beautification

ok henning@@
@
text
@d1 3
a3 1
/*	$OpenBSD: cinfo.c,v 1.10 2002/07/01 14:33:44 vincent Exp $	*/
@


1.10
log
@KNF + ansi; from zyrnix (only the easy part of his diffs)
@
text
@d1 1
a1 1
/*	$OpenBSD: cinfo.c,v 1.9 2002/05/06 19:22:38 deraadt Exp $	*/
d96 1
a96 1
	size_t copied;
d99 1
a99 1
		k = CHARMASK(k);/* sign extended char */
d134 1
a134 1
			return cp;
d144 1
a144 1
		return cp;
d149 1
a149 1
	return cp + copied;
@


1.9
log
@different fix; reported by zyrnix@@users.sourceforge.net
@
text
@d1 1
a1 1
/*	$OpenBSD: cinfo.c,v 1.8 2002/03/11 13:02:56 vincent Exp $	*/
d21 1
a21 1
	_MG_C, _MG_C, _MG_C, _MG_C,		/* 0x0X */
d25 1
a25 1
	_MG_C, _MG_C, _MG_C, _MG_C,		/* 0x1X */
d29 1
a29 1
	0, _MG_P, 0, 0,		/* 0x2X */
d33 1
a33 1
	_MG_D | _MG_W, _MG_D | _MG_W, _MG_D | _MG_W, _MG_D | _MG_W,	/* 0x3X */
d37 1
a37 1
	0, _MG_U | _MG_W, _MG_U | _MG_W, _MG_U | _MG_W,	/* 0x4X */
d41 1
a41 1
	_MG_U | _MG_W, _MG_U | _MG_W, _MG_U | _MG_W, _MG_U | _MG_W,	/* 0x5X */
d45 1
a45 1
	0, _MG_L | _MG_W, _MG_L | _MG_W, _MG_L | _MG_W,	/* 0x6X */
d49 1
a49 1
	_MG_L | _MG_W, _MG_L | _MG_W, _MG_L | _MG_W, _MG_L | _MG_W,	/* 0x7X */
d53 1
a53 1
	0, 0, 0, 0,		/* 0x8X */
d57 1
a57 1
	0, 0, 0, 0,		/* 0x9X */
d61 1
a61 1
	0, 0, 0, 0,		/* 0xAX */
d65 1
a65 1
	0, 0, 0, 0,		/* 0xBX */
d69 1
a69 1
	_MG_U | _MG_W, _MG_U | _MG_W, _MG_U | _MG_W, _MG_U | _MG_W,	/* 0xCX */
d73 1
a73 1
	0, _MG_U | _MG_W, _MG_U | _MG_W, _MG_U | _MG_W,	/* 0xDX */
d77 1
a77 1
	_MG_L | _MG_W, _MG_L | _MG_W, _MG_L | _MG_W, _MG_L | _MG_W,	/* 0xEX */
d81 1
a81 1
	0, _MG_L | _MG_W, _MG_L | _MG_W, _MG_L | _MG_W,	/* 0xFX */
d90 1
a90 1
 * '\0'.
d135 1
a135 2
		}
		if (k < ' ') {
@


1.8
log
@  * Move to ANSI function definitions.
  * Add a whole lot of consts where I thought it made sense

   no ok, but no objections either...
@
text
@d1 1
a1 1
/*	$OpenBSD: cinfo.c,v 1.7 2002/02/14 02:50:10 vincent Exp $	*/
d96 1
d147 4
a150 1
	return cp + strlcpy(cp, np, len);
@


1.7
log
@ Change character types definitions defines so they don't clash with
 the system's ctype.h.

 ok art@@
@
text
@d1 1
a1 1
/*	$OpenBSD: cinfo.c,v 1.6 2001/05/23 23:29:47 mickey Exp $	*/
d93 1
a93 4
keyname(cp, len, k)
	char	*cp;
	size_t	len;
	int	k;
d95 1
a95 1
	char  *np;
@


1.6
log
@cinfo is const, keyname() and findbind() take buffer size to use strlcpy vs cpy+len
@
text
@d1 1
a1 1
/*	$OpenBSD: cinfo.c,v 1.5 2001/05/23 22:20:35 art Exp $	*/
d21 32
a52 32
	_C, _C, _C, _C,		/* 0x0X */
	_C, _C, _C, _C,
	_C, _C, _C, _C,
	_C, _C, _C, _C,
	_C, _C, _C, _C,		/* 0x1X */
	_C, _C, _C, _C,
	_C, _C, _C, _C,
	_C, _C, _C, _C,
	0, _P, 0, 0,		/* 0x2X */
	_W, _W, 0, _W,
	0, 0, 0, 0,
	0, 0, _P, 0,
	_D | _W, _D | _W, _D | _W, _D | _W,	/* 0x3X */
	_D | _W, _D | _W, _D | _W, _D | _W,
	_D | _W, _D | _W, 0, 0,
	0, 0, 0, _P,
	0, _U | _W, _U | _W, _U | _W,	/* 0x4X */
	_U | _W, _U | _W, _U | _W, _U | _W,
	_U | _W, _U | _W, _U | _W, _U | _W,
	_U | _W, _U | _W, _U | _W, _U | _W,
	_U | _W, _U | _W, _U | _W, _U | _W,	/* 0x5X */
	_U | _W, _U | _W, _U | _W, _U | _W,
	_U | _W, _U | _W, _U | _W, 0,
	0, 0, 0, 0,
	0, _L | _W, _L | _W, _L | _W,	/* 0x6X */
	_L | _W, _L | _W, _L | _W, _L | _W,
	_L | _W, _L | _W, _L | _W, _L | _W,
	_L | _W, _L | _W, _L | _W, _L | _W,
	_L | _W, _L | _W, _L | _W, _L | _W,	/* 0x7X */
	_L | _W, _L | _W, _L | _W, _L | _W,
	_L | _W, _L | _W, _L | _W, 0,
	0, 0, 0, _C,
d69 16
a84 16
	_U | _W, _U | _W, _U | _W, _U | _W,	/* 0xCX */
	_U | _W, _U | _W, _U | _W, _U | _W,
	_U | _W, _U | _W, _U | _W, _U | _W,
	_U | _W, _U | _W, _U | _W, _U | _W,
	0, _U | _W, _U | _W, _U | _W,	/* 0xDX */
	_U | _W, _U | _W, _U | _W, _U | _W,
	_U | _W, _U | _W, _U | _W, _U | _W,
	_U | _W, _U | _W, 0, _W,
	_L | _W, _L | _W, _L | _W, _L | _W,	/* 0xEX */
	_L | _W, _L | _W, _L | _W, _L | _W,
	_L | _W, _L | _W, _L | _W, _L | _W,
	_L | _W, _L | _W, _L | _W, _L | _W,
	0, _L | _W, _L | _W, _L | _W,	/* 0xFX */
	_L | _W, _L | _W, _L | _W, _L | _W,
	_L | _W, _L | _W, _L | _W, _L | _W,
	_L | _W, _L | _W, 0, 0
@


1.5
log
@remove VOID. We're way beyond the point where this could build with an
ancient compiler.
@
text
@d1 1
a1 1
/*	$OpenBSD: cinfo.c,v 1.4 2001/05/23 21:55:32 art Exp $	*/
d20 1
a20 1
char cinfo[256] = {
d93 4
a96 3
keyname(cp, k)
	char  *cp;
	int    k;
d149 1
a149 2
	strcpy(cp, np);
	return cp + strlen(cp);
@


1.4
log
@Call it 'C-SPC', not 'NUL'. Less confusing.
@
text
@d1 1
a1 1
/*	$OpenBSD: cinfo.c,v 1.3 2001/01/29 01:58:06 niklas Exp $	*/
d148 1
a148 1
	(VOID) strcpy(cp, np);
@


1.3
log
@$OpenBSD$
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d103 1
a103 1
		np = "NUL";
@


1.2
log
@The start of KNF + -Wall.  The code has been run through indent but
needs hand fixup.  I stopped at keymap.c...
@
text
@d1 2
@


1.1
log
@initial import of mg2a
@
text
@d18 65
a82 65
char	cinfo[256] = {
	_C,		_C,		_C,		_C,	/* 0x0X */
	_C,		_C,		_C,		_C,
	_C,		_C,		_C,		_C,
	_C,		_C,		_C,		_C,
	_C,		_C,		_C,		_C,	/* 0x1X */
	_C,		_C,		_C,		_C,
	_C,		_C,		_C,		_C,
	_C,		_C,		_C,		_C,
	0,		_P,		0,		0,	/* 0x2X */
	_W,		_W,		0,		_W,
	0,		0,		0,		0,
	0,		0,		_P,		0,
	_D|_W,		_D|_W,		_D|_W,		_D|_W,	/* 0x3X */
	_D|_W,		_D|_W,		_D|_W,		_D|_W,
	_D|_W,		_D|_W,		0,		0,
	0,		0,		0,		_P,
	0,		_U|_W,		_U|_W,		_U|_W,	/* 0x4X */
	_U|_W,		_U|_W,		_U|_W,		_U|_W,
	_U|_W,		_U|_W,		_U|_W,		_U|_W,
	_U|_W,		_U|_W,		_U|_W,		_U|_W,
	_U|_W,		_U|_W,		_U|_W,		_U|_W,	/* 0x5X */
	_U|_W,		_U|_W,		_U|_W,		_U|_W,
	_U|_W,		_U|_W,		_U|_W,		0,
	0,		0,		0,		0,
	0,		_L|_W,		_L|_W,		_L|_W,	/* 0x6X */
	_L|_W,		_L|_W,		_L|_W,		_L|_W,
	_L|_W,		_L|_W,		_L|_W,		_L|_W,
	_L|_W,		_L|_W,		_L|_W,		_L|_W,
	_L|_W,		_L|_W,		_L|_W,		_L|_W,	/* 0x7X */
	_L|_W,		_L|_W,		_L|_W,		_L|_W,
	_L|_W,		_L|_W,		_L|_W,		0,
	0,		0,		0,		_C,
	0,		0,		0,		0,	/* 0x8X */
	0,		0,		0,		0,
	0,		0,		0,		0,
	0,		0,		0,		0,
	0,		0,		0,		0,	/* 0x9X */
	0,		0,		0,		0,
	0,		0,		0,		0,
	0,		0,		0,		0,
	0,		0,		0,		0,	/* 0xAX */
	0,		0,		0,		0,
	0,		0,		0,		0,
	0,		0,		0,		0,
	0,		0,		0,		0,	/* 0xBX */
	0,		0,		0,		0,
	0,		0,		0,		0,
	0,		0,		0,		0,
	_U|_W,		_U|_W,		_U|_W,		_U|_W,	/* 0xCX */
	_U|_W,		_U|_W,		_U|_W,		_U|_W,
	_U|_W,		_U|_W,		_U|_W,		_U|_W,
	_U|_W,		_U|_W,		_U|_W,		_U|_W,
	0,		_U|_W,		_U|_W,		_U|_W,	/* 0xDX */
	_U|_W,		_U|_W,		_U|_W,		_U|_W,
	_U|_W,		_U|_W,		_U|_W,		_U|_W,
	_U|_W,		_U|_W,		0,		_W,
	_L|_W,		_L|_W,		_L|_W,		_L|_W,	/* 0xEX */
	_L|_W,		_L|_W,		_L|_W,		_L|_W,
	_L|_W,		_L|_W,		_L|_W,		_L|_W,
	_L|_W,		_L|_W,		_L|_W,		_L|_W,
	0,		_L|_W,		_L|_W,		_L|_W,	/* 0xFX */
	_L|_W,		_L|_W,		_L|_W,		_L|_W,
	_L|_W,		_L|_W,		_L|_W,		_L|_W,
	_L|_W,		_L|_W,		0,		0
d90 4
a93 4

char *keyname(cp, k)
register char *cp;
register int k;
d95 1
a95 4
    register char *np;
#ifdef	FKEYS
    extern char *keystrings[];
#endif
d97 24
a120 9
    if(k < 0) k = CHARMASK(k);			/* sign extended char */
    switch(k) {
	case CCHR('@@'): np = "NUL"; break;
	case CCHR('I'): np = "TAB"; break;
	case CCHR('J'): np = "LFD"; break; /* yuck, but that's what GNU calls it */
	case CCHR('M'): np = "RET"; break;
	case CCHR('['): np = "ESC"; break;
	case ' ':	np = "SPC"; break; /* yuck again */
	case CCHR('?'): np = "DEL"; break;
d123 1
a123 1
	    if(k >= KFIRST && k <= KLAST &&
d125 1
a125 1
		break;
d127 16
a142 5
	    if(k > CCHR('?')) {
		*cp++ = '0';
		*cp++ = ((k>>6)&7) + '0';
		*cp++ = ((k>>3)&7) + '0';
		*cp++ = (k&7) + '0';
d145 3
a147 13
	    }
	    if(k < ' ') {
		*cp++ = 'C';
		*cp++ = '-';
		k = CCHR(k);
		if(ISUPPER(k)) k = TOLOWER(k);
	    }
	    *cp++ = k;
	    *cp = '\0';
	    return cp;
    }
    (VOID) strcpy(cp, np);
    return cp + strlen(cp);
@

