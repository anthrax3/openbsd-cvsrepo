head	1.47;
access;
symbols
	OPENBSD_6_1:1.47.0.8
	OPENBSD_6_1_BASE:1.47
	OPENBSD_6_0:1.47.0.4
	OPENBSD_6_0_BASE:1.47
	OPENBSD_5_9:1.47.0.2
	OPENBSD_5_9_BASE:1.47
	OPENBSD_5_8:1.45.0.4
	OPENBSD_5_8_BASE:1.45
	OPENBSD_5_7:1.43.0.2
	OPENBSD_5_7_BASE:1.43
	OPENBSD_5_6:1.42.0.4
	OPENBSD_5_6_BASE:1.42
	OPENBSD_5_5:1.41.0.6
	OPENBSD_5_5_BASE:1.41
	OPENBSD_5_4:1.41.0.2
	OPENBSD_5_4_BASE:1.41
	OPENBSD_5_3:1.38.0.2
	OPENBSD_5_3_BASE:1.38
	OPENBSD_5_2:1.37.0.2
	OPENBSD_5_2_BASE:1.37
	OPENBSD_5_1_BASE:1.30
	OPENBSD_5_1:1.30.0.12
	OPENBSD_5_0:1.30.0.10
	OPENBSD_5_0_BASE:1.30
	OPENBSD_4_9:1.30.0.8
	OPENBSD_4_9_BASE:1.30
	OPENBSD_4_8:1.30.0.6
	OPENBSD_4_8_BASE:1.30
	OPENBSD_4_7:1.30.0.2
	OPENBSD_4_7_BASE:1.30
	OPENBSD_4_6:1.30.0.4
	OPENBSD_4_6_BASE:1.30
	OPENBSD_4_5:1.29.0.4
	OPENBSD_4_5_BASE:1.29
	OPENBSD_4_4:1.29.0.2
	OPENBSD_4_4_BASE:1.29
	OPENBSD_4_3:1.28.0.6
	OPENBSD_4_3_BASE:1.28
	OPENBSD_4_2:1.28.0.4
	OPENBSD_4_2_BASE:1.28
	OPENBSD_4_1:1.28.0.2
	OPENBSD_4_1_BASE:1.28
	OPENBSD_4_0:1.26.0.2
	OPENBSD_4_0_BASE:1.26
	OPENBSD_3_9:1.21.0.2
	OPENBSD_3_9_BASE:1.21
	OPENBSD_3_8:1.20.0.2
	OPENBSD_3_8_BASE:1.20
	OPENBSD_3_7:1.17.0.2
	OPENBSD_3_7_BASE:1.17
	OPENBSD_3_6:1.16.0.2
	OPENBSD_3_6_BASE:1.16
	OPENBSD_3_5:1.15.0.2
	OPENBSD_3_5_BASE:1.15
	OPENBSD_3_4:1.14.0.2
	OPENBSD_3_4_BASE:1.14
	OPENBSD_3_3:1.13.0.6
	OPENBSD_3_3_BASE:1.13
	OPENBSD_3_2:1.13.0.4
	OPENBSD_3_2_BASE:1.13
	OPENBSD_3_1:1.13.0.2
	OPENBSD_3_1_BASE:1.13
	OPENBSD_3_0:1.6.0.2
	OPENBSD_3_0_BASE:1.6
	OPENBSD_2_9_BASE:1.5
	OPENBSD_2_9:1.5.0.2
	OPENBSD_2_8:1.3.0.4
	OPENBSD_2_8_BASE:1.3
	OPENBSD_2_7:1.3.0.2
	OPENBSD_2_7_BASE:1.3;
locks; strict;
comment	@ * @;


1.47
date	2015.10.10.09.13.14;	author lum;	state Exp;
branches;
next	1.46;
commitid	hKKUrQOrFuzFuI2G;

1.46
date	2015.09.26.21.51.58;	author jasper;	state Exp;
branches;
next	1.45;
commitid	yS81WdIVlzEJxLUH;

1.45
date	2015.03.24.22.34.39;	author florian;	state Exp;
branches;
next	1.44;
commitid	8A0AF8uf3KHDbiXK;

1.44
date	2015.03.19.21.22.15;	author bcallah;	state Exp;
branches;
next	1.43;
commitid	GbEBL4CfPvDkB8hj;

1.43
date	2014.11.16.04.16.41;	author guenther;	state Exp;
branches;
next	1.42;
commitid	a9yG0qCw9VEW27qI;

1.42
date	2014.03.20.07.47.29;	author lum;	state Exp;
branches;
next	1.41;

1.41
date	2013.05.31.18.19.19;	author florian;	state Exp;
branches;
next	1.40;

1.40
date	2013.05.31.18.03.43;	author lum;	state Exp;
branches;
next	1.39;

1.39
date	2013.03.25.11.41.44;	author florian;	state Exp;
branches;
next	1.38;

1.38
date	2012.10.12.21.13.46;	author jasper;	state Exp;
branches;
next	1.37;

1.37
date	2012.06.18.09.26.03;	author lum;	state Exp;
branches;
next	1.36;

1.36
date	2012.06.08.21.21.57;	author lum;	state Exp;
branches;
next	1.35;

1.35
date	2012.06.08.05.10.50;	author lum;	state Exp;
branches;
next	1.34;

1.34
date	2012.06.01.11.22.06;	author lum;	state Exp;
branches;
next	1.33;

1.33
date	2012.05.31.10.55.53;	author lum;	state Exp;
branches;
next	1.32;

1.32
date	2012.05.30.06.13.32;	author lum;	state Exp;
branches;
next	1.31;

1.31
date	2012.05.25.15.14.38;	author lum;	state Exp;
branches;
next	1.30;

1.30
date	2009.06.04.02.23.37;	author kjell;	state Exp;
branches;
next	1.29;

1.29
date	2008.06.10.23.23.52;	author kjell;	state Exp;
branches;
next	1.28;

1.28
date	2006.12.20.21.21.09;	author kjell;	state Exp;
branches;
next	1.27;

1.27
date	2006.11.18.20.36.50;	author kjell;	state Exp;
branches;
next	1.26;

1.26
date	2006.07.25.08.27.09;	author kjell;	state Exp;
branches;
next	1.25;

1.25
date	2006.07.25.08.22.32;	author kjell;	state Exp;
branches;
next	1.24;

1.24
date	2006.06.01.09.45.05;	author kjell;	state Exp;
branches;
next	1.23;

1.23
date	2006.06.01.09.00.50;	author kjell;	state Exp;
branches;
next	1.22;

1.22
date	2006.05.28.23.30.16;	author kjell;	state Exp;
branches;
next	1.21;

1.21
date	2005.11.18.20.56.52;	author deraadt;	state Exp;
branches;
next	1.20;

1.20
date	2005.08.09.00.53.48;	author kjell;	state Exp;
branches;
next	1.19;

1.19
date	2005.06.14.18.14.40;	author kjell;	state Exp;
branches;
next	1.18;

1.18
date	2005.04.03.02.09.28;	author db;	state Exp;
branches;
next	1.17;

1.17
date	2005.03.10.16.58.57;	author deraadt;	state Exp;
branches;
next	1.16;

1.16
date	2004.07.22.01.25.24;	author vincent;	state Exp;
branches;
next	1.15;

1.15
date	2003.09.19.21.20.47;	author deraadt;	state Exp;
branches;
next	1.14;

1.14
date	2003.05.16.19.28.59;	author vincent;	state Exp;
branches;
next	1.13;

1.13
date	2002.03.11.13.08.51;	author vincent;	state Exp;
branches;
next	1.12;

1.12
date	2002.03.11.13.02.56;	author vincent;	state Exp;
branches;
next	1.11;

1.11
date	2002.03.10.13.22.56;	author ho;	state Exp;
branches;
next	1.10;

1.10
date	2002.02.16.21.27.49;	author millert;	state Exp;
branches;
next	1.9;

1.9
date	2002.02.14.22.50.43;	author vincent;	state Exp;
branches;
next	1.8;

1.8
date	2002.02.13.22.36.58;	author vincent;	state Exp;
branches;
next	1.7;

1.7
date	2002.02.08.21.21.11;	author deraadt;	state Exp;
branches;
next	1.6;

1.6
date	2001.05.23.22.20.34;	author art;	state Exp;
branches;
next	1.5;

1.5
date	2001.02.12.21.51.55;	author millert;	state Exp;
branches;
next	1.4;

1.4
date	2001.01.29.01.58.06;	author niklas;	state Exp;
branches;
next	1.3;

1.3
date	2000.04.13.06.12.13;	author millert;	state Exp;
branches;
next	1.2;

1.2
date	2000.02.26.22.53.16;	author millert;	state Exp;
branches;
next	1.1;

1.1
date	2000.02.25.19.08.46;	author deraadt;	state Exp;
branches;
next	;


desc
@@


1.47
log
@Make functions that accept multiple iterations via C-u N, honour 0.
Except C-k which has a defined behaviour. In mg, C-t doesn't complete
n iterations if requested, but probably should, hence it has been
included in this diff.
@
text
@/*	$OpenBSD: basic.c,v 1.46 2015/09/26 21:51:58 jasper Exp $	*/

/* This file is in the public domain */

/*
 *		Basic cursor motion commands.
 *
 * The routines in this file are the basic
 * command functions for moving the cursor around on
 * the screen, setting mark, and swapping dot with
 * mark. Only moves between lines, which might make the
 * current buffer framing bad, are hard.
 */

#include <sys/queue.h>
#include <ctype.h>
#include <limits.h>
#include <signal.h>
#include <stdio.h>
#include <stdlib.h>

#include "def.h"

/*
 * Go to beginning of line.
 */
/* ARGSUSED */
int
gotobol(int f, int n)
{
	if (n == 0)
		return (TRUE);

	curwp->w_doto = 0;
	return (TRUE);
}

/*
 * Move cursor backwards. Do the
 * right thing if the count is less than
 * 0. Error if you try to move back from
 * the beginning of the buffer.
 */
/* ARGSUSED */
int
backchar(int f, int n)
{
	struct line   *lp;

	if (n < 0)
		return (forwchar(f, -n));
	while (n--) {
		if (curwp->w_doto == 0) {
			if ((lp = lback(curwp->w_dotp)) == curbp->b_headp) {
				if (!(f & FFRAND)) {
					dobeep();
					ewprintf("Beginning of buffer");
				}
				return (FALSE);
			}
			curwp->w_dotp = lp;
			curwp->w_doto = llength(lp);
			curwp->w_rflag |= WFMOVE;
			curwp->w_dotline--;
		} else
			curwp->w_doto--;
	}
	return (TRUE);
}

/*
 * Go to end of line.
 */
/* ARGSUSED */
int
gotoeol(int f, int n)
{
	if (n == 0)
		return (TRUE);

	curwp->w_doto = llength(curwp->w_dotp);
	return (TRUE);
}

/*
 * Move cursor forwards. Do the
 * right thing if the count is less than
 * 0. Error if you try to move forward
 * from the end of the buffer.
 */
/* ARGSUSED */
int
forwchar(int f, int n)
{
	if (n < 0)
		return (backchar(f, -n));
	while (n--) {
		if (curwp->w_doto == llength(curwp->w_dotp)) {
			curwp->w_dotp = lforw(curwp->w_dotp);
			if (curwp->w_dotp == curbp->b_headp) {
				curwp->w_dotp = lback(curwp->w_dotp);
				if (!(f & FFRAND)) {
					dobeep();
					ewprintf("End of buffer");
				}
				return (FALSE);
			}
			curwp->w_doto = 0;
			curwp->w_dotline++;
			curwp->w_rflag |= WFMOVE;
		} else
			curwp->w_doto++;
	}
	return (TRUE);
}

/*
 * Go to the beginning of the
 * buffer. Setting WFFULL is conservative,
 * but almost always the case.
 */
int
gotobob(int f, int n)
{
	(void) setmark(f, n);
	curwp->w_dotp = bfirstlp(curbp);
	curwp->w_doto = 0;
	curwp->w_rflag |= WFFULL;
	curwp->w_dotline = 1;
	return (TRUE);
}

/*
 * Go to the end of the buffer. Leave dot 3 lines from the bottom of the
 * window if buffer length is longer than window length; same as emacs.
 * Setting WFFULL is conservative, but almost always the case.
 */
int
gotoeob(int f, int n)
{
	struct line	*lp;

	(void) setmark(f, n);
	curwp->w_dotp = blastlp(curbp);
	curwp->w_doto = llength(curwp->w_dotp);
	curwp->w_dotline = curwp->w_bufp->b_lines;

	lp = curwp->w_dotp;
	n = curwp->w_ntrows - 3;

	if (n < curwp->w_bufp->b_lines && n >= 3) {
		while (n--)
			curwp->w_dotp = lback(curwp->w_dotp);

		curwp->w_linep = curwp->w_dotp;
		curwp->w_dotp = lp;
	}
	curwp->w_rflag |= WFFULL;
	return (TRUE);
}

/*
 * Move forward by full lines.
 * If the number of lines to move is less
 * than zero, call the backward line function to
 * actually do it. The last command controls how
 * the goal column is set.
 */
/* ARGSUSED */
int
forwline(int f, int n)
{
	struct line  *dlp;

	if (n < 0)
		return (backline(f | FFRAND, -n));
	if ((dlp = curwp->w_dotp) == curbp->b_headp) {
		if (!(f & FFRAND)) {
			dobeep();
			ewprintf("End of buffer");
		}
		return(TRUE);
	}
	if ((lastflag & CFCPCN) == 0)	/* Fix goal. */
		setgoal();
	thisflag |= CFCPCN;
	if (n == 0)
		return (TRUE);
	while (n--) {
		dlp = lforw(dlp);
		if (dlp == curbp->b_headp) {
			curwp->w_dotp = lback(dlp);
			curwp->w_doto = llength(curwp->w_dotp);
			curwp->w_rflag |= WFMOVE;
			if (!(f & FFRAND)) {
				dobeep();
				ewprintf("End of buffer");
			}
			return (TRUE);
		}
		curwp->w_dotline++;
	}
	curwp->w_rflag |= WFMOVE;
	curwp->w_dotp = dlp;
	curwp->w_doto = getgoal(dlp);

	return (TRUE);
}

/*
 * This function is like "forwline", but
 * goes backwards. The scheme is exactly the same.
 * Check for arguments that are less than zero and
 * call your alternate. Figure out the new line and
 * call "movedot" to perform the motion.
 */
/* ARGSUSED */
int
backline(int f, int n)
{
	struct line   *dlp;

	if (n < 0)
		return (forwline(f | FFRAND, -n));
	if ((lastflag & CFCPCN) == 0)	/* Fix goal. */
		setgoal();
	thisflag |= CFCPCN;
	dlp = curwp->w_dotp;
	if (lback(dlp) == curbp->b_headp)  {
		if (!(f & FFRAND)) {
			dobeep();
			ewprintf("Beginning of buffer");
		}
		return(TRUE);
	}
	while (n-- && lback(dlp) != curbp->b_headp) {
		dlp = lback(dlp);
		curwp->w_dotline--;
	}
	if (n > 0 && !(f & FFRAND)) {
		dobeep();
		ewprintf("Beginning of buffer");
	}
	curwp->w_dotp = dlp;
	curwp->w_doto = getgoal(dlp);
	curwp->w_rflag |= WFMOVE;
	return (TRUE);
}

/*
 * Set the current goal column, which is saved in the external variable
 * "curgoal", to the current cursor column. The column is never off
 * the edge of the screen; it's more like display then show position.
 */
void
setgoal(void)
{
	curgoal = getcolpos(curwp);	/* Get the position. */
	/* we can now display past end of display, don't chop! */
}

/*
 * This routine looks at a line (pointed
 * to by the LINE pointer "dlp") and the current
 * vertical motion goal column (set by the "setgoal"
 * routine above) and returns the best offset to use
 * when a vertical motion is made into the line.
 */
int
getgoal(struct line *dlp)
{
	int c, i, col = 0;
	char tmp[5];


	for (i = 0; i < llength(dlp); i++) {
		c = lgetc(dlp, i);
		if (c == '\t'
#ifdef	NOTAB
		    && !(curbp->b_flag & BFNOTAB)
#endif
			) {
			col |= 0x07;
			col++;
		} else if (ISCTRL(c) != FALSE) {
			col += 2;
		} else if (isprint(c))
			col++;
		else {
			col += snprintf(tmp, sizeof(tmp), "\\%o", c);
		}
		if (col > curgoal)
			break;
	}
	return (i);
}

/*
 * Scroll forward by a specified number
 * of lines, or by a full page if no argument.
 * The "2" is the window overlap (this is the default
 * value from ITS EMACS). Because the top line in
 * the window is zapped, we have to do a hard
 * update and get it back.
 */
/* ARGSUSED */
int
forwpage(int f, int n)
{
	struct line  *lp;

	if (!(f & FFARG)) {
		n = curwp->w_ntrows - 2;	/* Default scroll.	 */
		if (n <= 0)			/* Forget the overlap	 */
			n = 1;			/* if tiny window.	 */
	} else if (n < 0)
		return (backpage(f | FFRAND, -n));

	lp = curwp->w_linep;
	while (n--)
		if ((lp = lforw(lp)) == curbp->b_headp) {
			dobeep();
			ewprintf("End of buffer");
			return(TRUE);
		}

	curwp->w_linep = lp;
	curwp->w_rflag |= WFFULL;

	/* if in current window, don't move dot */
	for (n = curwp->w_ntrows; n-- && lp != curbp->b_headp; lp = lforw(lp))
		if (lp == curwp->w_dotp)
			return (TRUE);

	/* Advance the dot the slow way, for line nos */
	while (curwp->w_dotp != curwp->w_linep) {
		curwp->w_dotp = lforw(curwp->w_dotp);
		curwp->w_dotline++;
	}
	curwp->w_doto = 0;
	return (TRUE);
}

/*
 * This command is like "forwpage",
 * but it goes backwards. The "2", like above,
 * is the overlap between the two windows. The
 * value is from the ITS EMACS manual. The
 * hard update is done because the top line in
 * the window is zapped.
 */
/* ARGSUSED */
int
backpage(int f, int n)
{
	struct line  *lp, *lp2;

	if (!(f & FFARG)) {
		n = curwp->w_ntrows - 2;	/* Default scroll.	 */
		if (n <= 0)			/* Don't blow up if the  */
			return (backline(f, 1));/* window is tiny.	 */
	} else if (n < 0)
		return (forwpage(f | FFRAND, -n));

	lp = lp2 = curwp->w_linep;

	while (n-- && lback(lp) != curbp->b_headp) {
		lp = lback(lp);
	}
	if (lp == curwp->w_linep) {
		dobeep();
		ewprintf("Beginning of buffer");
	}
	curwp->w_linep = lp;
	curwp->w_rflag |= WFFULL;

	/* if in current window, don't move dot */
	for (n = curwp->w_ntrows; n-- && lp != curbp->b_headp; lp = lforw(lp))
		if (lp == curwp->w_dotp)
			return (TRUE);

        lp2 = lforw(lp2);

	/* Move the dot the slow way, for line nos */
	while (curwp->w_dotp != lp2) {
                if (curwp->w_dotline <= curwp->w_ntrows)
			goto out;
		curwp->w_dotp = lback(curwp->w_dotp);
		curwp->w_dotline--;
	}
out:
	curwp->w_doto = 0;
	return (TRUE);
}

/*
 * These functions are provided for compatibility with Gosling's Emacs. They
 * are used to scroll the display up (or down) one line at a time.
 */
int
forw1page(int f, int n)
{
	if (!(f & FFARG)) {
		n = 1;
		f = FFUNIV;
	}
	forwpage(f | FFRAND, n);
	return (TRUE);
}

int
back1page(int f, int n)
{
	if (!(f & FFARG)) {
		n = 1;
		f = FFUNIV;
	}
	backpage(f | FFRAND, n);
	return (TRUE);
}

/*
 * Page the other window. Check to make sure it exists, then
 * nextwind, forwpage and restore window pointers.
 */
int
pagenext(int f, int n)
{
	struct mgwin *wp;

	if (wheadp->w_wndp == NULL) {
		dobeep();
		ewprintf("No other window");
		return (FALSE);
	}
	wp = curwp;
	(void) nextwind(f, n);
	(void) forwpage(f, n);
	curwp = wp;
	curbp = wp->w_bufp;
	return (TRUE);
}

/*
 * Internal set mark routine, used by other functions (daveb).
 */
void
isetmark(void)
{
	curwp->w_markp = curwp->w_dotp;
	curwp->w_marko = curwp->w_doto;
	curwp->w_markline = curwp->w_dotline;
}

/*
 * Set the mark in the current window
 * to the value of dot. A message is written to
 * the echo line.  (ewprintf knows about macros)
 */
/* ARGSUSED */
int
setmark(int f, int n)
{
	isetmark();
	ewprintf("Mark set");
	return (TRUE);
}

/* Clear the mark, if set. */
/* ARGSUSED */
int
clearmark(int f, int n)
{
	if (!curwp->w_markp)
		return (FALSE);

	curwp->w_markp = NULL;
	curwp->w_marko = 0;
	curwp->w_markline = 0;

	return (TRUE);
}

/*
 * Swap the values of "dot" and "mark" in
 * the current window. This is pretty easy, because
 * all of the hard work gets done by the standard routine
 * that moves the mark about. The only possible
 * error is "no mark".
 */
/* ARGSUSED */
int
swapmark(int f, int n)
{
	struct line  *odotp;
	int odoto, odotline;

	if (curwp->w_markp == NULL) {
		dobeep();
		ewprintf("No mark in this window");
		return (FALSE);
	}
	odotp = curwp->w_dotp;
	odoto = curwp->w_doto;
	odotline = curwp->w_dotline;
	curwp->w_dotp = curwp->w_markp;
	curwp->w_doto = curwp->w_marko;
	curwp->w_dotline = curwp->w_markline;
	curwp->w_markp = odotp;
	curwp->w_marko = odoto;
	curwp->w_markline = odotline;
	curwp->w_rflag |= WFMOVE;
	return (TRUE);
}

/*
 * Go to a specific line, mostly for
 * looking up errors in C programs, which give the
 * error a line number. If an argument is present, then
 * it is the line number, else prompt for a line number
 * to use.
 */
/* ARGSUSED */
int
gotoline(int f, int n)
{
	char   buf[32], *bufp;
	const char *err;

	if (!(f & FFARG)) {
		if ((bufp = eread("Goto line: ", buf, sizeof(buf),
		    EFNUL | EFNEW | EFCR)) == NULL)
			return (ABORT);
		if (bufp[0] == '\0')
			return (ABORT);
		n = (int)strtonum(buf, INT_MIN, INT_MAX, &err);
		if (err) {
			dobeep();
			ewprintf("Line number %s", err);
			return (FALSE);
		}
	}
	return(setlineno(n));
}

/*
 * Set the line number and switch to it.
 */
int
setlineno(int n)
{
	struct line  *clp;

	if (n >= 0) {
		if (n == 0)
			n++;
		curwp->w_dotline = n;
		clp = lforw(curbp->b_headp);	/* "clp" is first line */
		while (--n > 0) {
			if (lforw(clp) == curbp->b_headp) {
				curwp->w_dotline = curwp->w_bufp->b_lines;
				break;
			}
			clp = lforw(clp);
		}
	} else {
		curwp->w_dotline = curwp->w_bufp->b_lines + n;
		clp = lback(curbp->b_headp);	/* "clp" is last line */
		while (n < 0) {
			if (lback(clp) == curbp->b_headp) {
				curwp->w_dotline = 1;
				break;
			}
			clp = lback(clp);
			n++;
		}
	}
	curwp->w_dotp = clp;
	curwp->w_doto = 0;
	curwp->w_rflag |= WFMOVE;
	return (TRUE);
}
@


1.46
log
@whitespace
@
text
@d1 1
a1 1
/*	$OpenBSD: basic.c,v 1.45 2015/03/24 22:34:39 florian Exp $	*/
d31 3
d78 3
@


1.45
log
@When exiting the loop early don't forget to clean up.

This fixes a segfault reported by and tracked down by Kaspars
Bankovskis kaspars at bankovskis dot net, thanks!
OK bcallah@@
@
text
@d1 1
a1 1
/*	$OpenBSD: basic.c,v 1.44 2015/03/19 21:22:15 bcallah Exp $	*/
d136 1
a136 1
	
@


1.44
log
@Clean up the includes in mg.
This does the following:
Moves all POSIX headers from sysdef.h into the individual .c files so that
each file now only includes what it needs. All headers are properly sorted.
Moves the remainder of sysdef.h to other files (mostly def.h) and deletes
sysdef.h now that it's no longer contains anything.
Tweak a comment that references sysdef.h so that it no longer does that.
ok florian@@
@
text
@d1 1
a1 1
/*	$OpenBSD: basic.c,v 1.43 2014/11/16 04:16:41 guenther Exp $	*/
d381 1
a381 1
                        return (TRUE);
d385 1
@


1.43
log
@Stop using <sys/param.h>; replace MAXPATHLEN with PATH_MAX, stop using MAX(),
and pull in <limits.h> for *_MAX constants.

inspired on a diff from Kamil Rytarowski (n54 (at) gmx.com)
ok bcallah@@
@
text
@d1 1
a1 1
/*	$OpenBSD: basic.c,v 1.42 2014/03/20 07:47:29 lum Exp $	*/
a13 1
#include "def.h"
d15 1
d18 5
@


1.42
log
@Add some missing dobeeps.
ok florian@@
@
text
@d1 1
a1 1
/*	$OpenBSD: basic.c,v 1.41 2013/05/31 18:19:19 florian Exp $	*/
d17 1
@


1.41
log
@Also inform the user about beginning / end of buffer in previous-line
and next-line.
ok lum@@
@
text
@d1 1
a1 1
/*	$OpenBSD: basic.c,v 1.40 2013/05/31 18:03:43 lum Exp $	*/
d419 1
d486 1
d525 1
@


1.40
log
@Make the system bell toggleable via 'audible-bell', and if switched
off, make available an alternative 'visible-bell'.

ok florian@@ jasper@@ Feedback Sunil Nimmagadda.
@
text
@d1 1
a1 1
/*	$OpenBSD: basic.c,v 1.39 2013/03/25 11:41:44 florian Exp $	*/
d165 5
a169 1
	if ((dlp = curwp->w_dotp) == curbp->b_headp)
d171 1
d183 4
d217 7
d227 4
@


1.39
log
@Display the window's column number in mode line not the
column number of the active window.
OK jasper@@
@
text
@d1 1
a1 1
/*	$OpenBSD: basic.c,v 1.38 2012/10/12 21:13:46 jasper Exp $	*/
d46 2
a47 1
				if (!(f & FFRAND))
d49 1
d90 2
a91 1
				if (!(f & FFRAND))
d93 1
d290 1
a290 1
			ttbeep();
d339 1
a339 1
		ttbeep();
@


1.38
log
@- implement "revert-buffer", which reverts the current buffer to what's on disk
- split gotoline() into the argument handling part and the part that actually
  goes to the specified line number so it can be re-used by revertbuffer()

input/ok florian@@ haesbaert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: basic.c,v 1.37 2012/06/18 09:26:03 lum Exp $	*/
d222 1
a222 1
	curgoal = getcolpos();		/* Get the position. */
@


1.37
log
@When using M-> Place cursor at the bottom of the window (minus 3
lines) like emacs, instead of middle of page.
@
text
@d1 1
a1 1
/*	$OpenBSD: basic.c,v 1.36 2012/06/08 21:21:57 lum Exp $	*/
a487 1
	struct line  *clp;
d503 11
@


1.36
log
@From an email to tech@@:

Bit difficult to explain this one. If you have a file open that is 3
or 4 times longer than the length of the viewable window and are at
the bottom of the buffer then scroll up to the top using M-v, your
cursor should remain at the bottom left of the window once you reach
the top of the buffer.

mg behaves like this since the last couple of scrolling diffs I've
committed. However, and as an example, if you start with the window
viewing the top of a buffer and press C-v twice, then C-p four times
then M-v twice to scroll back to the top, you will find your cursor is
NOT at the bottom left of the window. tut tut. This diff makes the
cursor stay at the bottom left, like emacs.
@
text
@d1 1
a1 1
/*	$OpenBSD: basic.c,v 1.35 2012/06/08 05:10:50 lum Exp $	*/
d118 3
a120 3
 * Go to the end of the buffer.
 * Setting WFFULL is conservative, but
 * almost always the case.
d125 2
d131 11
@


1.35
log
@Fix bug where line-number counter would go a bit hay-wire when paging
up with only 1 line of the buffer visible.
@
text
@d1 1
a1 1
/*	$OpenBSD: basic.c,v 1.34 2012/06/01 11:22:06 lum Exp $	*/
d337 2
@


1.34
log
@While scrolling, show a message and beep when you reach either end of
a buffer.
@
text
@d1 1
a1 1
/*	$OpenBSD: basic.c,v 1.33 2012/05/31 10:55:53 lum Exp $	*/
d312 1
a312 1
			n = 1;			/* window is tiny.	 */
@


1.33
log
@Currently, mg's cursor jumps from top to bottom of the screen as you
scroll upwards, make the cursor behave like emacs and stay at bottom
of window. Tested by mikeb@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: basic.c,v 1.32 2012/05/30 06:13:32 lum Exp $	*/
d272 3
a274 1
		if ((lp = lforw(lp)) == curbp->b_headp)
d276 1
d320 4
@


1.32
log
@Reverse part of v1.131.  The end of buffer can still be reached so I
shouldn't have taken out the second check. Hopefully fix unpredicable
scrolling behaviour seen by mikeb@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: basic.c,v 1.31 2012/05/25 15:14:38 lum Exp $	*/
d304 1
a304 1
	struct line  *lp;
d312 3
a314 1
	lp = curwp->w_linep;
d320 1
d325 3
d329 1
a329 1
	while (curwp->w_dotp != curwp->w_linep) {
@


1.31
log
@When paging down a buffer (C-v) stop earlier before having the last
line as the top line in the window. This emulates emacs behaviour.
@
text
@d1 1
a1 1
/*	$OpenBSD: basic.c,v 1.30 2009/06/04 02:23:37 kjell Exp $	*/
d279 1
a279 1
	for (n = curwp->w_ntrows; n--; lp = lforw(lp))
@


1.30
log
@Rename w_flag to w_rflag. This is not a general purpose
flag: it is for redisplay options only. I need an additional all-purpose
flag, so renaming removes the desire to wrongly overload the existing one.

Turdshine. No functional chage.
@
text
@d1 1
a1 1
/*	$OpenBSD: basic.c,v 1.29 2008/06/10 23:23:52 kjell Exp $	*/
d269 1
d271 4
a274 3
	while (n-- && lforw(lp) != curbp->b_headp) {
		lp = lforw(lp);
	}
d277 1
d279 1
a279 1
	for (n = curwp->w_ntrows; n-- && lp != curbp->b_headp; lp = lforw(lp))
d282 1
@


1.29
log
@Add a clear-mark function.
Use it to clear the region it is copied (M-w), or yanked (C-w).
This matches xemacs behavior, is not horribly different from gnu
emacs, and way less wrong than the current behavior.
Noticed by Han Boetes. ok otto@@
@
text
@d1 1
a1 1
/*	$OpenBSD: basic.c,v 1.28 2006/12/20 21:21:09 kjell Exp $	*/
d52 1
a52 1
			curwp->w_flag |= WFMOVE;
d94 1
a94 1
			curwp->w_flag |= WFMOVE;
d112 1
a112 1
	curwp->w_flag |= WFFULL;
d129 1
a129 1
	curwp->w_flag |= WFFULL;
d160 1
a160 1
			curwp->w_flag |= WFMOVE;
d165 1
a165 1
	curwp->w_flag |= WFMOVE;
d197 1
a197 1
	curwp->w_flag |= WFMOVE;
d274 1
a274 1
	curwp->w_flag |= WFFULL;
d313 1
a313 1
	curwp->w_flag |= WFFULL;
d441 1
a441 1
	curwp->w_flag |= WFMOVE;
d498 1
a498 1
	curwp->w_flag |= WFMOVE;
@


1.28
log
@Get rid of CVMVAS define. Originally to change pgforw/back parameter
from pages to lines. We don't use it.
@
text
@d1 1
a1 1
/*	$OpenBSD: basic.c,v 1.27 2006/11/18 20:36:50 kjell Exp $	*/
d396 15
@


1.27
log
@Due to a thinko on my part, (and a badly named structure member),
line numbers were horribly broken with pgup, pgdn.
From peter de wachter, via debian bug#391827
@
text
@d1 1
a1 1
/*	$OpenBSD: basic.c,v 1.26 2006/07/25 08:27:09 kjell Exp $	*/
a268 4
#ifdef	CVMVAS
	else					/* Convert from pages	 */
		n *= curwp->w_ntrows;		/* to lines.		 */
#endif
a307 4
#ifdef	CVMVAS
	else					/* Convert from pages	 */
		n *= curwp->w_ntrows;		/* to lines.		 */
#endif
@


1.26
log
@Add bfirstlp(), blastlp() macros, returning the first and last lines
of a buffer respectively. Removes an ugly construction than necessitated
"go to first line"-type comments throughout the code.
No binary change
@
text
@d1 1
a1 1
/*	$OpenBSD: basic.c,v 1.25 2006/07/25 08:22:32 kjell Exp $	*/
a275 1
		curwp->w_dotline++;
d283 5
a287 1
	curwp->w_dotp = curwp->w_linep;
a318 1
		curwp->w_dotline--;
d326 5
a330 1
	curwp->w_dotp = curwp->w_linep;
@


1.25
log
@Rename the header line of a buffer to b_headp, from the remarkably
unintuitive b_linep. No binary change.
@
text
@d1 1
a1 1
/*	$OpenBSD: basic.c,v 1.24 2006/06/01 09:45:05 kjell Exp $	*/
d110 1
a110 1
	curwp->w_dotp = lforw(curbp->b_headp);
d126 1
a126 1
	curwp->w_dotp = lback(curbp->b_headp);
@


1.24
log
@Fix message on empty goto-line. While here, lose a strlen and KNF.
@
text
@d1 1
a1 1
/*	$OpenBSD: basic.c,v 1.23 2006/06/01 09:00:50 kjell Exp $	*/
d45 1
a45 1
			if ((lp = lback(curwp->w_dotp)) == curbp->b_linep) {
d86 1
a86 1
			if (curwp->w_dotp == curbp->b_linep) {
d110 1
a110 1
	curwp->w_dotp = lforw(curbp->b_linep);
d126 1
a126 1
	curwp->w_dotp = lback(curbp->b_linep);
d148 1
a148 1
	if ((dlp = curwp->w_dotp) == curbp->b_linep)
d157 1
a157 1
		if (dlp == curbp->b_linep) {
d191 1
a191 1
	while (n-- && lback(dlp) != curbp->b_linep) {
d274 1
a274 1
	while (n-- && lforw(lp) != curbp->b_linep) {
d281 1
a281 1
	for (n = curwp->w_ntrows; n-- && lp != curbp->b_linep; lp = lforw(lp))
d314 1
a314 1
	while (n-- && lback(lp) != curbp->b_linep) {
d321 1
a321 1
	for (n = curwp->w_ntrows; n-- && lp != curbp->b_linep; lp = lforw(lp))
d463 1
a463 1
		clp = lforw(curbp->b_linep);	/* "clp" is first line */
d465 1
a465 1
			if (lforw(clp) == curbp->b_linep) {
d473 1
a473 1
		clp = lback(curbp->b_linep);	/* "clp" is last line */
d475 1
a475 1
			if (lback(clp) == curbp->b_linep) {
@


1.23
log
@Display line number in the mg statusbar.  Yes, it seems like a fugly
way to do it, but all the clever and pretty ways utterly failed.
Basic use seems fine. We'll turdshine the special cases later.

If it bothers you, use M-x line-number-mode, or put same in your ~/.mg
file to disable.

ok cloder, jason
@
text
@d1 1
a1 1
/*	$OpenBSD: basic.c,v 1.22 2006/05/28 23:30:16 kjell Exp $	*/
d224 2
d241 1
a241 4
			char tmp[5];

			snprintf(tmp, sizeof(tmp), "\\%o", c);
			col += strlen(tmp);
d450 2
@


1.22
log
@Make Window Flags more mnemonic (and less dumb); i.e.
WFHARD -> WFFULL (Redraw full window)
WFFORCE -> WFFRAME (Reframe window).
No binary change
@
text
@d1 1
a1 1
/*	$OpenBSD: basic.c,v 1.21 2005/11/18 20:56:52 deraadt Exp $	*/
d53 1
d93 1
d113 1
d128 1
d148 2
d155 1
a155 2
	dlp = curwp->w_dotp;
	while (dlp != curbp->b_linep && n--)
d157 5
a161 6
	curwp->w_flag |= WFMOVE;
	if (dlp == curbp->b_linep) {	/* ^N at end of buffer creates lines
					 * (like gnu) */
		if (!(curbp->b_flag & BFCHG)) {	/* first change */
			curbp->b_flag |= BFCHG;
			curwp->w_flag |= WFMODE;
d163 1
a163 12
		curwp->w_doto = 0;
		while (n-- >= 0) {
			if ((dlp = lalloc(0)) == NULL)
				return (FALSE);
			dlp->l_fp = curbp->b_linep;
			dlp->l_bp = lback(dlp->l_fp);
			dlp->l_bp->l_fp = dlp->l_fp->l_bp = dlp;
		}
		curwp->w_dotp = lback(curbp->b_linep);
	} else {
		curwp->w_dotp = dlp;
		curwp->w_doto = getgoal(dlp);
d165 4
d191 1
a191 1
	while (n-- && lback(dlp) != curbp->b_linep)
d193 2
d275 1
a275 1
	while (n-- && lforw(lp) != curbp->b_linep)
d277 2
d315 1
a315 1
	while (n-- && lback(lp) != curbp->b_linep)
d317 2
d385 1
d414 1
a414 1
	int    odoto;
d422 1
d425 1
d428 1
d445 2
a446 2
	char   buf[32], *bufp, *tmp;
	long   nl;
d452 3
a454 3
		nl = strtol(bufp, &tmp, 10);
		if (bufp[0] == '\0' || *tmp != '\0') {
			ewprintf("Invalid number");
a456 5
		if (nl >= INT_MAX || nl <= INT_MIN) {
			ewprintf("Out of range");
			return (FALSE);
		}
		n = (int)nl;
d459 3
d464 2
a465 1
			if (lforw(clp) == curbp->b_linep)
d467 1
d471 1
d474 2
a475 1
			if (lback(clp) == curbp->b_linep)
d477 1
@


1.21
log
@greedy use of typedef struct was making code harder to read; ok kjell cloder
@
text
@d1 1
a1 1
/*	$OpenBSD: basic.c,v 1.20 2005/08/09 00:53:48 kjell Exp $	*/
d101 1
a101 1
 * buffer. Setting WFHARD is conservative,
d110 1
a110 1
	curwp->w_flag |= WFHARD;
d116 1
a116 1
 * Setting WFHARD is conservative, but
d125 1
a125 1
	curwp->w_flag |= WFHARD;
d279 1
a279 1
	curwp->w_flag |= WFHARD;
d317 1
a317 1
	curwp->w_flag |= WFHARD;
@


1.20
log
@Clean up eread handling in mg. (basically, fallout from the 'enter often
means abort' behaviour added during the hackathon). Eliminates
redundant ereply function, fixes miscellaneous cores when aborting,
and move a number of assumed pathnames into the prompt text, since
they are used there anyway. All changes consistent with emacs behavior

ok beck@@ many, many moons ago.
@
text
@d1 1
a1 1
/*	$OpenBSD: basic.c,v 1.19 2005/06/14 18:14:40 kjell Exp $	*/
d39 1
a39 1
	LINE   *lp;
d140 1
a140 1
	LINE  *dlp;
d186 1
a186 1
	LINE   *dlp;
d222 1
a222 1
getgoal(LINE *dlp)
d263 1
a263 1
	LINE  *lp;
d301 1
a301 1
	LINE  *lp;
d360 1
a360 1
	MGWIN *wp;
d409 1
a409 1
	LINE  *odotp;
d437 1
a437 1
	LINE  *clp;
@


1.19
log
@Add explicit public domain notices to all public domain files.
ok millert@@, deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: basic.c,v 1.18 2005/04/03 02:09:28 db Exp $	*/
d442 2
a443 1
		if ((bufp = ereply("Goto line: ", buf, sizeof(buf))) == NULL)
a444 3
		else if (bufp[0] == '\0')
			return (FALSE);

@


1.18
log
@This is a no binary change which does:

- spelling, punctuation fixes
- variable declaration lineup
- use parentheses for return and sizeof
- K&R function declarations -> ANSI
- other minor code beautification

ok henning@@
@
text
@d1 3
a3 1
/*	$OpenBSD: basic.c,v 1.17 2005/03/10 16:58:57 deraadt Exp $	*/
@


1.17
log
@spacing
@
text
@d1 1
a1 1
/*	$OpenBSD: basic.c,v 1.16 2004/07/22 01:25:24 vincent Exp $	*/
d40 1
a40 1
		return forwchar(f, -n);
d54 1
a54 1
	return TRUE;
a77 1

d79 1
a79 1
		return backchar(f, -n);
d87 1
a87 1
				return FALSE;
d94 1
a94 1
	return TRUE;
a104 1

d109 1
a109 1
	return TRUE;
a119 1

d124 1
a124 1
	return TRUE;
d141 1
a141 1
		return backline(f | FFRAND, -n);
d146 1
a146 1
		return TRUE;
d160 1
a160 1
				return FALSE;
d170 1
a170 1
	return TRUE;
d187 1
a187 1
		return forwline(f | FFRAND, -n);
d197 1
a197 1
	return TRUE;
d240 1
a240 1
			snprintf(tmp, sizeof tmp, "\\%o", c);
d268 1
a268 1
		return backpage(f | FFRAND, -n);
d281 1
a281 1
			return TRUE;
d284 1
a284 1
	return TRUE;
d306 1
a306 1
		return forwpage(f | FFRAND, -n);
d319 1
a319 1
			return TRUE;
d322 1
a322 1
	return TRUE;
d337 1
a337 1
	return TRUE;
d348 1
a348 1
	return TRUE;
d362 1
a362 1
		return FALSE;
d369 1
a369 1
	return TRUE;
a390 1

d393 1
a393 1
	return TRUE;
d412 1
a412 1
		return FALSE;
d421 1
a421 1
	return TRUE;
d441 1
a441 1
			return ABORT;
d443 1
a443 1
			return FALSE;
d448 1
a448 1
			return FALSE;
d452 1
a452 1
			return FALSE;
d475 1
a475 1
	return TRUE;
@


1.16
log
@stage 1 of the infinite minibuffer work - add support for on the fly
buffer reallocation in veread().  This commit only changes the API.
All the buffers have exactly the same bounds as before for now.

tested by a couple of my very helpful testers!
@
text
@d1 1
a1 1
/*	$OpenBSD: basic.c,v 1.15 2003/09/19 21:20:47 deraadt Exp $	*/
d211 1
a211 1
	curgoal = getcolpos();		/* Get the position.     */
@


1.15
log
@do not += snprintf; andrushock@@korovino.net
@
text
@d1 1
a1 1
/*	$OpenBSD: basic.c,v 1.14 2003/05/16 19:28:59 vincent Exp $	*/
d440 1
a440 2
	int    s;
	char   buf[32], *tmp;
d444 4
a447 2
		if ((s = ereply("Goto line: ", buf, sizeof(buf))) != TRUE)
			return s;
d449 2
a450 2
		nl = strtol(buf, &tmp, 10);
		if (buf[0] == '\0' || *tmp != '\0') {
@


1.14
log
@fix the goal calculation routine so moving up and down moves to the right
column.

ok jason
@
text
@d1 1
a1 1
/*	$OpenBSD: basic.c,v 1.13 2002/03/11 13:08:51 vincent Exp $	*/
d242 3
a244 2
			col += snprintf(tmp, sizeof tmp, "\\%o",
			    c);
@


1.13
log
@ remove errno=0 assignments, we don't need these with Hakan's code
@
text
@d1 1
a1 1
/*	$OpenBSD: basic.c,v 1.12 2002/03/11 13:02:56 vincent Exp $	*/
d14 1
a14 1
void setgoal(void);
d145 1
a145 1
	if ((lastflag & CFCPCN) == 0)	/* Fix goal.		 */
d191 1
a191 1
	if ((lastflag & CFCPCN) == 0)	/* Fix goal.		 */
d211 1
a211 2

	curgoal = getcolpos() - 1;	/* Get the position.	 */
d225 4
a228 10
	int    c;
	int    col;
	int    newcol;
	int    dbo;

	col = 0;
	dbo = 0;
	while (dbo != llength(dlp)) {
		c = lgetc(dlp, dbo);
		newcol = col;
d233 13
a245 6
			)
			newcol |= 0x07;
		else if (ISCTRL(c) != FALSE)
			++newcol;
		++newcol;
		if (newcol > curgoal)
a246 2
		col = newcol;
		++dbo;
d248 1
a248 1
	return (dbo);
a379 1

@


1.12
log
@  * Move to ANSI function definitions.
  * Add a whole lot of consts where I thought it made sense

   no ok, but no objections either...
@
text
@d1 1
a1 1
/*	$OpenBSD: basic.c,v 1.11 2002/03/10 13:22:56 ho Exp $	*/
d449 1
a449 1
		errno = 0;
@


1.11
log
@Better long vs int. millert@@ ok.
@
text
@d1 1
a1 1
/*	$OpenBSD: basic.c,v 1.10 2002/02/16 21:27:49 millert Exp $	*/
d21 1
a21 2
gotobol(f, n)
	int f, n;
d35 1
a35 2
backchar(f, n)
	int	n;
d62 1
a62 2
gotoeol(f, n)
	int f, n;
d76 1
a76 2
forwchar(f, n)
	int f, n;
d104 1
a104 2
gotobob(f, n)
	int f, n;
d120 1
a120 2
gotoeob(f, n)
	int f, n;
d139 1
a139 2
forwline(f, n)
	int f, n;
d185 1
a185 2
backline(f, n)
	int	f, n;
d209 1
a209 1
setgoal()
d224 1
a224 2
getgoal(dlp)
	LINE  *dlp;
d263 1
a263 2
forwpage(f, n)
	int    f, n;
d301 1
a301 2
backpage(f, n)
	int    f, n;
d334 1
a334 2
forw1page(f, n)
	int f, n;
a335 1

d345 1
a345 2
back1page(f, n)
	int f, n;
a346 1

d360 1
a360 2
pagenext(f, n)
	int    f, n;
d380 1
a380 1
isetmark()
d394 1
a394 2
setmark(f, n)
	int f, n;
d411 1
a411 2
swapmark(f, n)
	int    f, n;
d439 1
a439 2
gotoline(f, n)
	int    f, n;
@


1.10
log
@Part one of userland __P removal.  Done with a simple regexp with some minor hand editing to make comments line up correctly.  Another pass is forthcoming that handles the cases that could not be done automatically.
@
text
@d1 1
a1 1
/*	$OpenBSD: basic.c,v 1.9 2002/02/14 22:50:43 vincent Exp $	*/
d462 2
a463 1
	char   buf[32];
a465 2
		char *tmp;
		
d469 1
a469 1
		n = strtol(buf, &tmp, 10);
d474 1
a474 2
		if ((errno == ERANGE && (n == LONG_MAX || n == LONG_MIN)) ||
		    (n > INT_MAX || n < INT_MIN)) {
d478 1
@


1.9
log
@ use strtol instead of atoi to get range checking, etc
@
text
@d1 1
a1 1
/*	$OpenBSD: basic.c,v 1.8 2002/02/13 22:36:58 vincent Exp $	*/
d14 1
a14 1
void setgoal __P((void));
@


1.8
log
@ Make mg malloc the l_text element instead of reallocating whole LINE
 structures all the time.
@
text
@d1 1
a1 1
/*	$OpenBSD: basic.c,v 1.7 2002/02/08 21:21:11 deraadt Exp $	*/
d465 2
d469 11
a479 1
		n = atoi(buf);
@


1.7
log
@more gosmacs
@
text
@d1 1
a1 1
/*	$OpenBSD: basic.c,v 1.6 2001/05/23 22:20:34 art Exp $	*/
d169 1
a169 1
			if ((dlp = lallocx(0)) == NULL)
@


1.6
log
@remove VOID. We're way beyond the point where this could build with an
ancient compiler.
@
text
@d1 1
a1 1
/*	$OpenBSD: basic.c,v 1.5 2001/02/12 21:51:55 millert Exp $	*/
d344 1
a344 2
#ifdef GOSMACS
void
d354 1
d357 1
a357 1
void
d367 1
a368 1
#endif
@


1.5
log
@goto-line 0 should go to the beginning of the file, not the end;
smart@@monkey.org
@
text
@d1 1
a1 1
/*	$OpenBSD: basic.c,v 1.4 2001/01/29 01:58:06 niklas Exp $	*/
d14 1
a14 1
VOID setgoal __P((void));
d112 1
a112 1
	(VOID) setmark(f, n);
d129 1
a129 1
	(VOID) setmark(f, n);
d216 1
a216 1
VOID
d345 1
a345 1
VOID
d357 1
a357 1
VOID
d385 2
a386 2
	(VOID) nextwind(f, n);
	(VOID) forwpage(f, n);
d395 1
a395 1
VOID
@


1.4
log
@$OpenBSD$
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d469 2
a470 2
	if (n > 0) {
		clp = lforw(curbp->b_linep);	/* "clp" is first line	 */
d477 1
a477 1
		clp = lback(curbp->b_linep);	/* clp is last line */
@


1.3
log
@The start of KNF + -Wall.  The code has been run through indent but
needs hand fixup.  I stopped at keymap.c...
@
text
@d1 2
@


1.2
log
@change WINDOW -> MGWIN to avoid curses type conflict
convert to terminfo in tty*.c
add support for some keypad function keys (arrows, pgup, pgdown)
@
text
@d10 1
a10 1
#include	"def.h"
d12 1
a12 1
VOID	setgoal();
d17 2
a18 1
/*ARGSUSED*/
d20 1
d22 1
a22 1
	curwp->w_doto  = 0;
d32 2
a33 1
/*ARGSUSED*/
d35 1
a35 1
register int n;
d37 1
a37 1
	register LINE	*lp;
d39 2
a40 1
	if (n < 0) return forwchar(f, -n);
d43 1
a43 1
			if ((lp=lback(curwp->w_dotp)) == curbp->b_linep) {
d48 2
a49 2
			curwp->w_dotp  = lp;
			curwp->w_doto  = llength(lp);
d60 2
a61 1
/*ARGSUSED*/
d63 1
d65 1
a65 1
	curwp->w_doto  = llength(curwp->w_dotp);
d75 2
a76 1
/*ARGSUSED*/
d78 1
a78 1
register int n;
d80 3
a82 1
	if (n < 0) return backchar(f, -n);
d85 1
a85 1
			curwp->w_dotp  = lforw(curwp->w_dotp);
d92 1
a92 1
			curwp->w_doto  = 0;
d105 1
d107 1
d109 4
a112 3
	(VOID) setmark(f, n) ;
	curwp->w_dotp  = lforw(curbp->b_linep);
	curwp->w_doto  = 0;
d122 1
d124 1
d126 4
a129 3
	(VOID) setmark(f, n) ;
	curwp->w_dotp  = lback(curbp->b_linep);
	curwp->w_doto  = llength(curwp->w_dotp);
d141 2
a142 1
/*ARGSUSED*/
d144 1
d146 1
a146 1
	register LINE	*dlp;
d149 2
a150 2
		return backline(f|FFRAND, -n);
	if ((lastflag&CFCPCN) == 0)		/* Fix goal.		*/
d153 2
a154 1
	if (n == 0) return TRUE;
d156 1
a156 1
	while (dlp!=curbp->b_linep && n--)
d159 3
a161 2
	if(dlp==curbp->b_linep) {	/* ^N at end of buffer creates lines (like gnu) */
		if(!(curbp->b_flag&BFCHG)) {	/* first change */
d166 3
a168 2
		while(n-- >= 0) {
			if((dlp = lallocx(0)) == NULL) return FALSE;
d175 2
a176 2
		curwp->w_dotp  = dlp;
		curwp->w_doto  = getgoal(dlp);
d188 2
a189 1
/*ARGSUSED*/
d191 1
d193 1
a193 1
	register LINE	*dlp;
d195 3
a197 2
	if (n < 0) return forwline(f|FFRAND, -n);
	if ((lastflag&CFCPCN) == 0)		/* Fix goal.		*/
d201 1
a201 1
	while (n-- && lback(dlp)!=curbp->b_linep)
d203 2
a204 2
	curwp->w_dotp  = dlp;
	curwp->w_doto  = getgoal(dlp);
d210 3
a212 5
 * Set the current goal column,
 * which is saved in the external variable "curgoal",
 * to the current cursor column. The column is never off
 * the edge of the screen; it's more like display then
 * show position.
d215 2
a216 1
setgoal() {
d218 2
a219 2
	curgoal = getcolpos() - 1;		/* Get the position.	*/
/* we can now display past end of display, don't chop! */
d229 8
a236 5
getgoal(dlp) register LINE *dlp; {
	register int	c;
	register int	col;
	register int	newcol;
	register int	dbo;
d245 1
a245 1
				&& !(curbp->b_flag & BFNOTAB)
d248 1
a248 1
		    newcol |= 0x07;
d268 2
a269 1
/*ARGSUSED*/
d271 1
a271 1
register int n;
d273 1
a273 1
	register LINE	*lp;
d276 3
a278 3
		n = curwp->w_ntrows - 2;	/* Default scroll.	*/
		if (n <= 0)			/* Forget the overlap	*/
			n = 1;			/* if tiny window.	*/
d280 1
a280 1
		return backpage(f|FFRAND, -n);
d282 2
a283 2
	else					/* Convert from pages	*/
		n *= curwp->w_ntrows;		/* to lines.		*/
d286 1
a286 1
	while (n-- && lforw(lp)!=curbp->b_linep)
d291 5
a295 4
	for(n = curwp->w_ntrows; n-- && lp!=curbp->b_linep; lp = lforw(lp))
		if(lp==curwp->w_dotp) return TRUE;
	curwp->w_dotp  = curwp->w_linep;
	curwp->w_doto  = 0;
d307 2
a308 1
/*ARGSUSED*/
d310 1
a310 1
register int n;
d312 1
a312 1
	register LINE	*lp;
d315 3
a317 3
		n = curwp->w_ntrows - 2;	/* Default scroll.	*/
		if (n <= 0)			/* Don't blow up if the */
			n = 1;			/* window is tiny.	*/
d319 1
a319 1
		return forwpage(f|FFRAND, -n);
d321 2
a322 2
	else					/* Convert from pages	*/
		n *= curwp->w_ntrows;		/* to lines.		*/
d325 1
a325 1
	while (n-- && lback(lp)!=curbp->b_linep)
d330 3
a332 2
	for(n = curwp->w_ntrows; n-- && lp!=curbp->b_linep; lp = lforw(lp))
		if(lp==curwp->w_dotp) return TRUE;
d338 3
a340 2
/* These functions are provided for compatibility with Gosling's Emacs.
 *    They are used to scroll the display up (or down) one line at a time.
a341 1

d343 1
d345 1
a345 1
int f, n;
d347 3
a349 2
	if (!(f & FFARG))  {
        	n = 1;
d352 1
a352 1
	forwpage(f|FFRAND, n);
d355 1
d357 1
a357 1
int f, n;
d359 1
d361 1
a361 1
        	n = 1;
d364 1
a364 1
	backpage(f|FFRAND, n);
d372 1
d374 1
d376 1
a376 1
	register MGWIN *wp;
d396 1
d406 2
a407 1
/*ARGSUSED*/
d409 1
d411 1
d424 2
a425 1
/*ARGSUSED*/
d427 1
d429 2
a430 2
	register LINE	*odotp;
	register int	odoto;
d438 2
a439 2
	curwp->w_dotp  = curwp->w_markp;
	curwp->w_doto  = curwp->w_marko;
d453 2
a454 1
/*ARGSUSED*/
d456 1
a456 1
register int n;
d458 3
a460 3
	register LINE	*clp;
	register int	s;
	char		buf[32];
d463 1
a463 1
		if ((s=ereply("Goto line: ", buf, sizeof(buf))) != TRUE)
a466 1

d468 1
a468 1
		clp = lforw(curbp->b_linep);	/* "clp" is first line	*/
d470 2
a471 1
			if (lforw(clp) == curbp->b_linep) break;
d477 2
a478 1
			if (lback(clp) == curbp->b_linep) break;
@


1.1
log
@initial import of mg2a
@
text
@d341 1
a341 1
	register WINDOW *wp;
@

