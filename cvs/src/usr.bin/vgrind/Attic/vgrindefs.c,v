head	1.11;
access;
symbols
	OPENBSD_4_8:1.10.0.4
	OPENBSD_4_8_BASE:1.10
	OPENBSD_4_7:1.10.0.2
	OPENBSD_4_7_BASE:1.10
	OPENBSD_4_6:1.9.0.20
	OPENBSD_4_6_BASE:1.9
	OPENBSD_4_5:1.9.0.16
	OPENBSD_4_5_BASE:1.9
	OPENBSD_4_4:1.9.0.14
	OPENBSD_4_4_BASE:1.9
	OPENBSD_4_3:1.9.0.12
	OPENBSD_4_3_BASE:1.9
	OPENBSD_4_2:1.9.0.10
	OPENBSD_4_2_BASE:1.9
	OPENBSD_4_1:1.9.0.8
	OPENBSD_4_1_BASE:1.9
	OPENBSD_4_0:1.9.0.6
	OPENBSD_4_0_BASE:1.9
	OPENBSD_3_9:1.9.0.4
	OPENBSD_3_9_BASE:1.9
	OPENBSD_3_8:1.9.0.2
	OPENBSD_3_8_BASE:1.9
	OPENBSD_3_7:1.8.0.8
	OPENBSD_3_7_BASE:1.8
	OPENBSD_3_6:1.8.0.6
	OPENBSD_3_6_BASE:1.8
	OPENBSD_3_5:1.8.0.4
	OPENBSD_3_5_BASE:1.8
	OPENBSD_3_4:1.8.0.2
	OPENBSD_3_4_BASE:1.8
	OPENBSD_3_3:1.6.0.2
	OPENBSD_3_3_BASE:1.6
	OPENBSD_3_2:1.3.0.4
	OPENBSD_3_2_BASE:1.3
	OPENBSD_3_1:1.3.0.2
	OPENBSD_3_1_BASE:1.3
	OPENBSD_3_0:1.2.0.22
	OPENBSD_3_0_BASE:1.2
	OPENBSD_2_9_BASE:1.2
	OPENBSD_2_9:1.2.0.20
	OPENBSD_2_8:1.2.0.18
	OPENBSD_2_8_BASE:1.2
	OPENBSD_2_7:1.2.0.16
	OPENBSD_2_7_BASE:1.2
	OPENBSD_2_6:1.2.0.14
	OPENBSD_2_6_BASE:1.2
	OPENBSD_2_5:1.2.0.12
	OPENBSD_2_5_BASE:1.2
	OPENBSD_2_4:1.2.0.10
	OPENBSD_2_4_BASE:1.2
	OPENBSD_2_3:1.2.0.8
	OPENBSD_2_3_BASE:1.2
	OPENBSD_2_2:1.2.0.6
	OPENBSD_2_2_BASE:1.2
	OPENBSD_2_1:1.2.0.4
	OPENBSD_2_1_BASE:1.2
	OPENBSD_2_0:1.2.0.2
	OPENBSD_2_0_BASE:1.2
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.11
date	2010.10.18.20.03.00;	author deraadt;	state dead;
branches;
next	1.10;

1.10
date	2009.10.27.23.59.47;	author deraadt;	state Exp;
branches;
next	1.9;

1.9
date	2005.04.13.02.05.18;	author deraadt;	state Exp;
branches;
next	1.8;

1.8
date	2003.06.03.02.56.21;	author millert;	state Exp;
branches;
next	1.7;

1.7
date	2003.04.26.03.35.15;	author deraadt;	state Exp;
branches;
next	1.6;

1.6
date	2003.02.19.07.38.50;	author deraadt;	state Exp;
branches;
next	1.5;

1.5
date	2003.02.19.07.33.34;	author deraadt;	state Exp;
branches;
next	1.4;

1.4
date	2003.02.19.07.32.36;	author deraadt;	state Exp;
branches;
next	1.3;

1.3
date	2001.11.19.19.02.17;	author mpech;	state Exp;
branches;
next	1.2;

1.2
date	96.06.26.05.42.32;	author deraadt;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.46.33;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.46.33;	author deraadt;	state Exp;
branches;
next	;


desc
@@


1.11
log
@vgrind goes to the attic
@
text
@/*	$OpenBSD: vgrindefs.c,v 1.10 2009/10/27 23:59:47 deraadt Exp $	*/
/*	$NetBSD: vgrindefs.c,v 1.5 1994/12/20 12:05:29 cgd Exp $	*/

/*
 * Copyright (c) 1980, 1993
 *	The Regents of the University of California.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */

#define	BUFSIZ	1024
#define MAXHOP	32	/* max number of tc= indirections */

#include <stdlib.h>
#include <string.h>
#include <ctype.h>
/*
 * grindcap - routines for dealing with the language definitions data base
 *	(code stolen almost totally from termcap)
 *
 * BUG:		Should use a "last" pointer in tbuf, so that searching
 *		for capabilities alphabetically would not be a n**2/2
 *		process when large numbers of capabilities are given.
 * Note:	If we add a last pointer now we will screw up the
 *		tc capability. We really should compile termcap.
 *
 * Essentially all the work here is scanning and decoding escapes
 * in string capabilities.  We don't use stdio because the editor
 * doesn't, and because living w/o it is not hard.
 */

static	char *tbuf;
static	char *filename;
static	int hopcount;	/* detect infinite loops in termcap, init 0 */
static	char *tskip();
static	char *tdecode();
char	*tgetstr();

/*
 * Get an entry for terminal name in buffer bp,
 * from the termcap file.  Parse is very rudimentary;
 * we just notice escaped newlines.
 */
tgetent(char *bp, char *name, char *file)
{
	char ibuf[BUFSIZ], *cp, *cp2;
	int i = 0, cnt = 0, c;
	int tf;

	tbuf = bp;
	tf = 0;
	filename = file;
	tf = open(filename, 0);
	if (tf < 0)
		return (-1);
	for (;;) {
		cp = bp;
		for (;;) {
			if (i == cnt) {
				cnt = read(tf, ibuf, BUFSIZ);
				if (cnt <= 0) {
					close(tf);
					return (0);
				}
				i = 0;
			}
			c = ibuf[i++];
			if (c == '\n') {
				if (cp > bp && cp[-1] == '\\'){
					cp--;
					continue;
				}
				break;
			}
			if (cp >= bp+BUFSIZ) {
				write(STDERR_FILENO, "Vgrind entry too long\n", 23);
				break;
			} else
				*cp++ = c;
		}
		*cp = 0;

		/*
		 * The real work for the match.
		 */
		if (tnamatch(name)) {
			close(tf);
			return(tnchktc());
		}
	}
}

/*
 * tnchktc: check the last entry, see if it's tc=xxx. If so,
 * recursively find xxx and append that entry (minus the names)
 * to take the place of the tc=xxx entry. This allows termcap
 * entries to say "like an HP2621 but doesn't turn on the labels".
 * Note that this works because of the left to right scan.
 */
tnchktc(void)
{
	char *p, *q;
	char tcname[16];	/* name of similar terminal */
	char tcbuf[BUFSIZ];
	char *holdtbuf = tbuf;
	int l;

	p = tbuf + strlen(tbuf) - 2;	/* before the last colon */
	while (*--p != ':')
		if (p<tbuf) {
			write(STDERR_FILENO, "Bad vgrind entry\n", 18);
			return (0);
		}
	p++;
	/* p now points to beginning of last field */
	if (p[0] != 't' || p[1] != 'c')
		return(1);
	strlcpy(tcname, p+3, sizeof tcname);
	q = tcname;
	while (q && *q != ':')
		q++;
	*q = 0;
	if (++hopcount > MAXHOP) {
		write(STDERR_FILENO, "Infinite tc= loop\n", 18);
		return (0);
	}
	if (tgetent(tcbuf, tcname, filename) != 1)
		return(0);
	for (q=tcbuf; *q != ':'; q++)
		;
	l = p - holdtbuf + strlen(q);
	if (l > BUFSIZ) {
		write(STDERR_FILENO, "Vgrind entry too long\n", 23);
		q[BUFSIZ - (p-tbuf)] = 0;
	}
	strlcpy(p, q+1, l);
	tbuf = holdtbuf;
	return(1);
}

/*
 * Tnamatch deals with name matching.  The first field of the termcap
 * entry is a sequence of names separated by |'s, so we compare
 * against each such name.  The normal : terminator after the last
 * name (before the first field) stops us.
 */
tnamatch(char *np)
{
	char *Np, *Bp;

	Bp = tbuf;
	if (*Bp == '#')
		return(0);
	for (;;) {
		for (Np = np; *Np && *Bp == *Np; Bp++, Np++)
			continue;
		if (*Np == 0 && (*Bp == '|' || *Bp == ':' || *Bp == 0))
			return (1);
		while (*Bp && *Bp != ':' && *Bp != '|')
			Bp++;
		if (*Bp == 0 || *Bp == ':')
			return (0);
		Bp++;
	}
}

/*
 * Skip to the next field.  Notice that this is very dumb, not
 * knowing about \: escapes or any such.  If necessary, :'s can be put
 * into the termcap file in octal.
 */
static char *
tskip(char *bp)
{

	while (*bp && *bp != ':')
		bp++;
	if (*bp == ':')
		bp++;
	return (bp);
}

/*
 * Return the (numeric) option id.
 * Numeric options look like
 *	li#80
 * i.e. the option string is separated from the numeric value by
 * a # character.  If the option is not found we return -1.
 * Note that we handle octal numbers beginning with 0.
 */
tgetnum(char *id)
{
	int i, base;
	char *bp = tbuf;

	for (;;) {
		bp = tskip(bp);
		if (*bp == 0)
			return (-1);
		if (*bp++ != id[0] || *bp == 0 || *bp++ != id[1])
			continue;
		if (*bp == '@@')
			return(-1);
		if (*bp != '#')
			continue;
		bp++;
		base = 10;
		if (*bp == '0')
			base = 8;
		i = 0;
		while (isdigit(*bp))
			i *= base, i += *bp++ - '0';
		return (i);
	}
}

/*
 * Handle a flag option.
 * Flag options are given "naked", i.e. followed by a : or the end
 * of the buffer.  Return 1 if we find the option, or 0 if it is
 * not given.
 */
tgetflag(char *id)
{
	char *bp = tbuf;

	for (;;) {
		bp = tskip(bp);
		if (!*bp)
			return (0);
		if (*bp++ == id[0] && *bp != 0 && *bp++ == id[1]) {
			if (!*bp || *bp == ':')
				return (1);
			else if (*bp == '@@')
				return(0);
		}
	}
}

/*
 * Get a string valued option.
 * These are given as
 *	cl=^Z
 * Much decoding is done on the strings, and the strings are
 * placed in area, which is a ref parameter which is updated.
 * No checking on area overflow.
 */
char *
tgetstr(char *id, char **area)
{
	char *bp = tbuf;

	for (;;) {
		bp = tskip(bp);
		if (!*bp)
			return (0);
		if (*bp++ != id[0] || *bp == 0 || *bp++ != id[1])
			continue;
		if (*bp == '@@')
			return(0);
		if (*bp != '=')
			continue;
		bp++;
		return (tdecode(bp, area));
	}
}

/*
 * Tdecode does the grunt work to decode the
 * string capability escapes.
 */
static char *
tdecode(char *str, char **area)
{
	char *cp;
	int c;
	int i;

	cp = *area;
	while (c = *str++) {
	    if (c == ':' && *(cp-1) != '\\')
		break;
	    *cp++ = c;
	}
	*cp++ = 0;
	str = *area;
	*area = cp;
	return (str);
}
@


1.10
log
@rcsid[] and sccsid[] and copyright[] are essentially unmaintained (and
unmaintainable).  these days, people use source.  these id's do not provide
any benefit, and do hurt the small install media
(the 33,000 line diff is essentially mechanical)
ok with the idea millert, ok dms
@
text
@d1 1
a1 1
/*	$OpenBSD: vgrindefs.c,v 1.9 2005/04/13 02:05:18 deraadt Exp $	*/
@


1.9
log
@use STDERR_FILENO
@
text
@d1 1
a1 1
/*	$OpenBSD: vgrindefs.c,v 1.8 2003/06/03 02:56:21 millert Exp $	*/
a31 7

#ifndef lint
#if 0
static char sccsid[] = "@@(#)vgrindefs.c	8.1 (Berkeley) 6/6/93";
#endif
static char rcsid[] = "$OpenBSD: vgrindefs.c,v 1.8 2003/06/03 02:56:21 millert Exp $";
#endif /* not lint */
@


1.8
log
@Remove the advertising clause in the UCB license which Berkeley
rescinded 22 July 1999.  Proofed by myself and Theo.
@
text
@d1 1
a1 1
/*	$OpenBSD: vgrindefs.c,v 1.7 2003/04/26 03:35:15 deraadt Exp $	*/
d37 1
a37 1
static char rcsid[] = "$OpenBSD: vgrindefs.c,v 1.7 2003/04/26 03:35:15 deraadt Exp $";
d105 1
a105 1
				write(2,"Vgrind entry too long\n", 23);
d140 1
a140 1
			write(2, "Bad vgrind entry\n", 18);
d153 1
a153 1
		write(2, "Infinite tc= loop\n", 18);
d162 1
a162 1
		write(2, "Vgrind entry too long\n", 23);
@


1.7
log
@string cleaning
@
text
@d1 1
a1 1
/*	$OpenBSD: vgrindefs.c,v 1.6 2003/02/19 07:38:50 deraadt Exp $	*/
d16 1
a16 5
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
d37 1
a37 1
static char rcsid[] = "$OpenBSD: vgrindefs.c,v 1.6 2003/02/19 07:38:50 deraadt Exp $";
@


1.6
log
@ansi
@
text
@d1 1
a1 1
/*	$OpenBSD: vgrindefs.c,v 1.5 2003/02/19 07:33:34 deraadt Exp $	*/
d41 1
a41 1
static char rcsid[] = "$OpenBSD: vgrindefs.c,v 1.5 2003/02/19 07:33:34 deraadt Exp $";
d169 1
a169 1
	strcpy(p, q+1);
@


1.5
log
@one strcpy -> strlcpy
@
text
@d1 1
a1 1
/*	$OpenBSD: vgrindefs.c,v 1.4 2003/02/19 07:32:36 deraadt Exp $	*/
d41 1
a41 1
static char rcsid[] = "$OpenBSD: vgrindefs.c,v 1.4 2003/02/19 07:32:36 deraadt Exp $";
d77 1
a77 2
tgetent(bp, name, file)
	char *bp, *name, *file;
d79 2
a80 5
	char *cp;
	int c;
	int i = 0, cnt = 0;
	char ibuf[BUFSIZ];
	char *cp2;
d133 1
a133 1
tnchktc()
d180 1
a180 2
tnamatch(np)
	char *np;
d206 1
a206 2
tskip(bp)
	char *bp;
d224 1
a224 2
tgetnum(id)
	char *id;
d256 1
a256 2
tgetflag(id)
	char *id;
d282 1
a282 2
tgetstr(id, area)
	char *id, **area;
d306 1
a306 3
tdecode(str, area)
	char *str;
	char **area;
@


1.4
log
@make this work on sparc64, some borrowed from netbsd; raj@@cerias.purdue.edu
@
text
@d1 1
a1 1
/*	$OpenBSD: vgrindefs.c,v 1.3 2001/11/19 19:02:17 mpech Exp $	*/
d41 1
a41 1
static char rcsid[] = "$OpenBSD: vgrindefs.c,v 1.3 2001/11/19 19:02:17 mpech Exp $";
d155 1
a155 1
	strcpy(tcname,p+3);
@


1.3
log
@kill more registers

millert@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: vgrindefs.c,v 1.2 1996/06/26 05:42:32 deraadt Exp $	*/
d41 1
a41 1
static char rcsid[] = "$OpenBSD: vgrindefs.c,v 1.2 1996/06/26 05:42:32 deraadt Exp $";
d311 1
a311 1
 * Tdecode does the grung work to decode the
@


1.2
log
@rcsid
@
text
@d1 1
a1 1
/*	$OpenBSD: vgrindefs.c,v 1.5 1994/12/20 12:05:29 cgd Exp $	*/
d41 1
a41 1
static char rcsid[] = "$OpenBSD: vgrindefs.c,v 1.5 1994/12/20 12:05:29 cgd Exp $";
d80 3
a82 3
	register char *cp;
	register int c;
	register int i = 0, cnt = 0;
d139 1
a139 1
	register char *p, *q;
d187 1
a187 1
	register char *Np, *Bp;
d212 1
a212 1
	register char *bp;
d233 2
a234 2
	register int i, base;
	register char *bp = tbuf;
d266 1
a266 1
	register char *bp = tbuf;
d293 1
a293 1
	register char *bp = tbuf;
d316 1
a316 1
	register char *str;
d319 2
a320 2
	register char *cp;
	register int c;
@


1.1
log
@Initial revision
@
text
@d1 1
d41 1
a41 1
static char rcsid[] = "$NetBSD: vgrindefs.c,v 1.5 1994/12/20 12:05:29 cgd Exp $";
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@
