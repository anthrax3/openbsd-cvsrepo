head	1.30;
access;
symbols
	OPENBSD_6_2:1.30.0.4
	OPENBSD_6_2_BASE:1.30
	OPENBSD_6_1:1.28.0.16
	OPENBSD_6_1_BASE:1.28
	OPENBSD_6_0:1.28.0.12
	OPENBSD_6_0_BASE:1.28
	OPENBSD_5_9:1.28.0.8
	OPENBSD_5_9_BASE:1.28
	OPENBSD_5_8:1.28.0.10
	OPENBSD_5_8_BASE:1.28
	OPENBSD_5_7:1.28.0.2
	OPENBSD_5_7_BASE:1.28
	OPENBSD_5_6:1.28.0.6
	OPENBSD_5_6_BASE:1.28
	OPENBSD_5_5:1.28.0.4
	OPENBSD_5_5_BASE:1.28
	OPENBSD_5_4:1.27.0.10
	OPENBSD_5_4_BASE:1.27
	OPENBSD_5_3:1.27.0.8
	OPENBSD_5_3_BASE:1.27
	OPENBSD_5_2:1.27.0.6
	OPENBSD_5_2_BASE:1.27
	OPENBSD_5_1_BASE:1.27
	OPENBSD_5_1:1.27.0.4
	OPENBSD_5_0:1.27.0.2
	OPENBSD_5_0_BASE:1.27
	OPENBSD_4_9:1.23.0.6
	OPENBSD_4_9_BASE:1.23
	OPENBSD_4_8:1.23.0.4
	OPENBSD_4_8_BASE:1.23
	OPENBSD_4_7:1.23.0.2
	OPENBSD_4_7_BASE:1.23
	OPENBSD_4_6:1.22.0.6
	OPENBSD_4_6_BASE:1.22
	OPENBSD_4_5:1.22.0.2
	OPENBSD_4_5_BASE:1.22
	OPENBSD_4_4:1.21.0.10
	OPENBSD_4_4_BASE:1.21
	OPENBSD_4_3:1.21.0.8
	OPENBSD_4_3_BASE:1.21
	OPENBSD_4_2:1.21.0.6
	OPENBSD_4_2_BASE:1.21
	OPENBSD_4_1:1.21.0.4
	OPENBSD_4_1_BASE:1.21
	OPENBSD_4_0:1.21.0.2
	OPENBSD_4_0_BASE:1.21
	OPENBSD_3_9:1.20.0.2
	OPENBSD_3_9_BASE:1.20
	OPENBSD_3_8:1.18.0.2
	OPENBSD_3_8_BASE:1.18
	OPENBSD_3_7:1.16.0.2
	OPENBSD_3_7_BASE:1.16
	OPENBSD_3_6:1.14.0.4
	OPENBSD_3_6_BASE:1.14
	OPENBSD_3_5:1.14.0.2
	OPENBSD_3_5_BASE:1.14;
locks; strict;
comment	@ * @;


1.30
date	2017.07.19.12.50.33;	author espie;	state Exp;
branches;
next	1.29;
commitid	JSAFUy3u4ukEoD6z;

1.29
date	2017.07.02.23.19.07;	author deraadt;	state Exp;
branches;
next	1.28;
commitid	qIELr34YIaJyUfVT;

1.28
date	2013.09.19.16.12.01;	author otto;	state Exp;
branches;
next	1.27;

1.27
date	2011.08.03.08.48.19;	author otto;	state Exp;
branches;
next	1.26;

1.26
date	2011.06.03.06.10.33;	author otto;	state Exp;
branches;
next	1.25;

1.25
date	2011.06.01.07.18.23;	author otto;	state Exp;
branches;
next	1.24;

1.24
date	2011.03.07.08.11.15;	author otto;	state Exp;
branches;
next	1.23;

1.23
date	2009.10.27.23.59.36;	author deraadt;	state Exp;
branches;
next	1.22;

1.22
date	2008.12.15.19.46.29;	author otto;	state Exp;
branches;
next	1.21;

1.21
date	2006.03.18.20.44.43;	author otto;	state Exp;
branches;
next	1.20;

1.20
date	2006.01.24.19.38.44;	author otto;	state Exp;
branches;
next	1.19;

1.19
date	2005.12.03.18.23.47;	author deraadt;	state Exp;
branches;
next	1.18;

1.18
date	2005.04.13.06.36.03;	author otto;	state Exp;
branches;
next	1.17;

1.17
date	2005.03.28.17.43.28;	author deraadt;	state Exp;
branches;
next	1.16;

1.16
date	2004.12.02.19.30.05;	author otto;	state Exp;
branches;
next	1.15;

1.15
date	2004.10.19.07.36.51;	author otto;	state Exp;
branches;
next	1.14;

1.14
date	2003.12.02.09.00.07;	author otto;	state Exp;
branches;
next	1.13;

1.13
date	2003.11.17.11.20.13;	author otto;	state Exp;
branches;
next	1.12;

1.12
date	2003.11.11.19.49.02;	author otto;	state Exp;
branches;
next	1.11;

1.11
date	2003.11.11.09.15.36;	author otto;	state Exp;
branches;
next	1.10;

1.10
date	2003.11.09.19.27.27;	author otto;	state Exp;
branches;
next	1.9;

1.9
date	2003.10.18.20.35.36;	author otto;	state Exp;
branches;
next	1.8;

1.8
date	2003.10.18.19.57.10;	author otto;	state Exp;
branches;
next	1.7;

1.7
date	2003.09.30.18.46.11;	author otto;	state Exp;
branches;
next	1.6;

1.6
date	2003.09.29.03.24.27;	author otto;	state Exp;
branches;
next	1.5;

1.5
date	2003.09.28.07.57.57;	author otto;	state Exp;
branches;
next	1.4;

1.4
date	2003.09.26.19.00.38;	author deraadt;	state Exp;
branches;
next	1.3;

1.3
date	2003.09.26.07.04.25;	author deraadt;	state Exp;
branches;
next	1.2;

1.2
date	2003.09.26.07.02.52;	author deraadt;	state Exp;
branches;
next	1.1;

1.1
date	2003.09.25.19.32.44;	author otto;	state Exp;
branches;
next	;


desc
@@


1.30
log
@more depends gc / yacc rules overhaul

okay millert@@
@
text
@%{
/*      $OpenBSD: scan.l,v 1.29 2017/07/02 23:19:07 deraadt Exp $	*/

/*
 * Copyright (c) 2003, Otto Moerbeek <otto@@drijf.net>
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */

#include <err.h>
#include <histedit.h>
#include <signal.h>
#include <string.h>
#include <unistd.h>

#include "extern.h"
#include "pathnames.h"
#include "bc.h"

int		lineno;
bool		interactive;

HistEvent	 he;
EditLine	*el;
History		*hist;

static char	*strbuf = NULL;
static size_t	strbuf_sz = 1;
static bool	dot_seen;
static int	use_el;
static volatile sig_atomic_t skipchars;

static void	init_strbuf(void);
static void	add_str(const char *);

static int	 bc_yyinput(char *, int);

#undef YY_INPUT
#define YY_INPUT(buf,retval,max) \
	(retval = bc_yyinput(buf, max))

%}

%option always-interactive

DIGIT		[0-9A-F]
ALPHA		[a-z_]
ALPHANUM	[a-z_0-9]

%x		comment string number

%%

"/*"		BEGIN(comment);
<comment>{
	"*/"	BEGIN(INITIAL);
	\n	lineno++;
	\*	;
	[^*\n]+	;
	<<EOF>>	fatal("end of file in comment");
}

\"		BEGIN(string); init_strbuf();
<string>{
	[^"\n\\\[\]]+	add_str(yytext);
	\[	add_str("\\[");
	\]	add_str("\\]");
	\\	add_str("\\\\");
	\n	add_str("\n"); lineno++;
	\"	BEGIN(INITIAL); yylval.str = strbuf; return STRING;
	<<EOF>>	fatal("end of file in string");
}

{DIGIT}+	{
			BEGIN(number);
			dot_seen = false;
			init_strbuf();
			add_str(yytext);
		}
\.		{
			BEGIN(number);
			dot_seen = true;
			init_strbuf();
			add_str(".");
		}
<number>{
	{DIGIT}+	add_str(yytext);
	\.	{
			if (dot_seen) {
				BEGIN(INITIAL);
				yylval.str = strbuf;
				unput('.');
				return NUMBER;
			} else {
				dot_seen = true;
				add_str(".");
			}
		}
	\\\n[ \t]*	lineno++;
	[^0-9A-F\.]	{
			BEGIN(INITIAL);
			unput(yytext[0]);
			if (strcmp(strbuf, ".") == 0)
				return DOT;
			else {
				yylval.str = strbuf;
				return NUMBER;
			}
		}
}

"auto"		return AUTO;
"break"		return BREAK;
"continue"	return CONTINUE;
"define"	return DEFINE;
"else"		return ELSE;
"ibase"		return IBASE;
"if"		return IF;
"last"		return DOT;
"for"		return FOR;
"length"	return LENGTH;
"obase"		return OBASE;
"print"		return PRINT;
"quit"		return QUIT;
"return"	return RETURN;
"scale"		return SCALE;
"sqrt"		return SQRT;
"while"		return WHILE;

"^"		return EXPONENT;
"*"		return MULTIPLY;
"/"		return DIVIDE;
"%"		return REMAINDER;

"!"		return BOOL_NOT;
"&&"		return BOOL_AND;
"||"		return BOOL_OR;

"+"		return PLUS;
"-"		return MINUS;

"++"		return INCR;
"--"		return DECR;

"="		yylval.str = ""; return ASSIGN_OP;
"+="		yylval.str = "+"; return ASSIGN_OP;
"-="		yylval.str = "-"; return ASSIGN_OP;
"*="		yylval.str = "*"; return ASSIGN_OP;
"/="		yylval.str = "/"; return ASSIGN_OP;
"%="		yylval.str = "%"; return ASSIGN_OP;
"^="		yylval.str = "^"; return ASSIGN_OP;

"=="		return EQUALS;
"<="		return LESS_EQ;
">="		return GREATER_EQ;
"!="		return UNEQUALS;
"<"		return LESS;
">"		return GREATER;

","		return COMMA;
";"		return SEMICOLON;

"("		return LPAR;
")"		return RPAR;

"["		return LBRACKET;
"]"		return RBRACKET;

"{"		return LBRACE;
"}"		return RBRACE;

{ALPHA}{ALPHANUM}* {
			/* alloc an extra byte for the type marker */
			char *p = malloc(yyleng + 2);
			if (p == NULL)
				err(1, NULL);
			strlcpy(p, yytext, yyleng + 1);
			yylval.astr = p;
			return LETTER;
		}

\\\n		lineno++;
\n		lineno++; return NEWLINE;

#[^\n]*		;
[ \t]		;
<<EOF>>		return QUIT;
.		yyerror("illegal character");

%%

static void
init_strbuf(void)
{
	if (strbuf == NULL) {
		strbuf = malloc(strbuf_sz);
		if (strbuf == NULL)
			err(1, NULL);
	}
	strbuf[0] = '\0';
}

static void
add_str(const char *str)
{
	size_t arglen;

	arglen = strlen(str);

	if (strlen(strbuf) + arglen + 1 > strbuf_sz) {
		size_t newsize;
		char *p;

		newsize = strbuf_sz + arglen + 1;
		p = realloc(strbuf, newsize);
		if (p == NULL) {
			free(strbuf);
			err(1, NULL);
		}
		strbuf_sz = newsize;
		strbuf = p;
	}
	strlcat(strbuf, str, strbuf_sz);
}

/* ARGSUSED */
void
abort_line(int sig)
{
	static const char str1[] = "[\n]P\n";
	static const char str2[] = "[^C\n]P\n";
	int save_errno;
	const LineInfo *info;

	save_errno = errno;
	if (use_el) {
		write(STDOUT_FILENO, str2, sizeof(str2) - 1);
		info = el_line(el);
		skipchars = info->lastchar - info->buffer;
	} else
		write(STDOUT_FILENO, str1, sizeof(str1) - 1);
	errno = save_errno;
}

/*
 * Avoid the echo of ^D by the default code of editline and take
 * into account skipchars to make ^D work when the cursor is at start of
 * line after a ^C.
 */
unsigned char
bc_eof(EditLine *e, int ch)
{
	const struct lineinfo *info = el_line(e);

	if (info->buffer + skipchars == info->cursor &&
	    info->cursor == info->lastchar)
		return (CC_EOF);
	else
		return (CC_ERROR);
}

int
yywrap(void)
{
	static int state;
	static YY_BUFFER_STATE buf;

	if (fileindex == 0 && sargc > 0 && strcmp(sargv[0], _PATH_LIBB) == 0) {
		filename = sargv[fileindex++];
		yyin = fopen(filename, "r");
		lineno = 1;
		if (yyin == NULL)
			err(1, "cannot open %s", filename);
		return (0);
	}
	if (state == 0 && cmdexpr[0] != '\0') {
		buf = yy_scan_string(cmdexpr);
		state++;
		lineno = 1;
		filename = "command line";
		return (0);
	} else if (state == 1) {
		yy_delete_buffer(buf);
		free(cmdexpr);
		state++;
	}
	if (yyin != NULL && yyin != stdin)
		fclose(yyin);
	if (fileindex < sargc) {
		filename = sargv[fileindex++];
		yyin = fopen(filename, "r");
		lineno = 1;
		if (yyin == NULL)
			err(1, "cannot open %s", filename);
		return (0);
	} else if (fileindex == sargc) {
		fileindex++;
		yyin = stdin;
		if (interactive) {
			signal(SIGINT, abort_line);
			signal(SIGTSTP, tstpcont);
		}
		lineno = 1;
		filename = "stdin";
		return (0);
	}
	return (1);
}

static int
bc_yyinput(char *buf, int maxlen)
{
	int num;

	if (el != NULL)
		el_get(el, EL_EDITMODE, &use_el);

	if (yyin == stdin && interactive && use_el) {
		const char *bp;
		sigset_t oset, nset;

		if ((bp = el_gets(el, &num)) == NULL || num == 0)
			return (0);
		sigemptyset(&nset);
		sigaddset(&nset, SIGINT);
		sigprocmask(SIG_BLOCK, &nset, &oset);
		if (skipchars < num) {
			bp += skipchars;
			num -= skipchars;
		}
		skipchars = 0;
		sigprocmask(SIG_SETMASK, &oset, NULL);
		if (num > maxlen) {
			el_push(el, (char *)(void *)bp + maxlen);
			num = maxlen;
		}
		memcpy(buf, bp, num);
		history(hist, &he, H_ENTER, bp);
		el_get(el, EL_EDITMODE, &use_el);
	} else {
		int c = '*';
		for (num = 0; num < maxlen &&
		    (c = getc(yyin)) != EOF && c != '\n'; ++num)
			buf[num] = (char) c;
		if (c == '\n')
			buf[num++] = (char) c;
		if (c == EOF && ferror(yyin))
			YY_FATAL_ERROR( "input in flex scanner failed" );
	}
	return (num);
}


@


1.29
log
@whitespace
@
text
@d2 1
a2 1
/*      $OpenBSD: scan.l,v 1.28 2013/09/19 16:12:01 otto Exp $	*/
d28 1
a28 1
#include "y.tab.h"
@


1.28
log
@separate termios.h out from scan.l, both have an ECHO define. Noted by
Joris Giovannangeli.
@
text
@d2 1
a2 1
/*      $OpenBSD: scan.l,v 1.27 2011/08/03 08:48:19 otto Exp $	*/
d327 1
a327 1
		
@


1.27
log
@save/restore tty state on SIGTSTP/SIGCONT. ok deraadt@@ nicm@@
@
text
@d2 1
a2 1
/*      $OpenBSD: scan.l,v 1.26 2011/06/03 06:10:33 otto Exp $	*/
a22 1
#include <stdbool.h>
a23 1
#include <termios.h>
a41 1
struct termios ttysaved, ttyedit;
a251 39
	errno = save_errno;
}

int
settty(struct termios *t)
{
	int ret;

	while ((ret = tcsetattr(0, TCSADRAIN,  t) == -1) && errno == EINTR)
		continue;
	return ret;
}

int
gettty(struct termios *t)
{
	int ret;

	while ((ret = tcgetattr(0, t) == -1) && errno == EINTR)
		continue;
	return ret;
}

/* ARGSUSED */
void
tstpcont(int sig)
{
	int save_errno = errno;

	if (sig == SIGTSTP) {
		signal(SIGCONT, tstpcont);
		gettty(&ttyedit);
		settty(&ttysaved);		
	} else {
		signal(SIGTSTP, tstpcont);
		settty(&ttyedit);		
	}
	signal(sig, SIG_DFL);
	kill(0, sig);
@


1.26
log
@Make ^D behave: dont't echo it and make it work if the cursor is at
start of line after a ^C;  ok okan@@ deraadt@@
@
text
@d2 1
a2 1
/*      $OpenBSD: scan.l,v 1.25 2011/06/01 07:18:23 otto Exp $	*/
d25 1
d44 1
d258 39
d351 1
a351 1
		if (interactive)
d353 2
@


1.25
log
@- avoid YY_FLUSH_BUFFER: it is not signal safe and it does not work as intended
after the introduction of editline
- honour editline edit off mode
@
text
@d2 1
a2 1
/*      $OpenBSD: scan.l,v 1.24 2011/03/07 08:11:15 otto Exp $	*/
d254 17
@


1.24
log
@add editline support; from freebsd. ok deraadt@@
@
text
@d2 1
a2 1
/*      $OpenBSD: scan.l,v 1.24 2011/03/07 08:09:25 otto Exp $	*/
d41 2
d241 2
a242 1
	static const char str[] = "[\n]P\n";
d244 1
d247 6
a252 2
	YY_FLUSH_BUFFER;	/* XXX signal race? */
	write(STDOUT_FILENO, str, sizeof(str) - 1);
d306 5
a310 1
	if (yyin == stdin && interactive) {
d312 1
d316 9
d331 1
@


1.23
log
@rcsid[] and sccsid[] and copyright[] are essentially unmaintained (and
unmaintainable).  these days, people use source.  these id's do not provide
any benefit, and do hurt the small install media
(the 33,000 line diff is essentially mechanical)
ok with the idea millert, ok dms
@
text
@d2 1
a2 1
/*      $OpenBSD: scan.l,v 1.22 2008/12/15 19:46:29 otto Exp $	*/
d21 1
d34 4
d45 6
d293 29
@


1.22
log
@turns out gcc is not smart enough to avoid the local array in const
char msg[] = "string literal" if you do not declare it static.
shaves off a few bytes
@
text
@d2 1
a2 1
/*      $OpenBSD: scan.l,v 1.21 2006/03/18 20:44:43 otto Exp $	*/
a18 4

#ifndef lint
static const char rcsid[] = "$OpenBSD: scan.l,v 1.21 2006/03/18 20:44:43 otto Exp $";
#endif /* not lint */
@


1.21
log
@Interchange roles: bc becomes parent, dc child. This leads to saner
tty handling (try bc | grep foo followed by ^C, as noted by deraadt@@).
To make it all work, bc now waits for dc to exit after giving it a
quit command.  ok deraadt@@ jaredy@@
@
text
@d2 1
a2 1
/*      $OpenBSD: scan.l,v 1.20 2006/01/24 19:38:44 otto Exp $	*/
d21 1
a21 1
static const char rcsid[] = "$OpenBSD: scan.l,v 1.20 2006/01/24 19:38:44 otto Exp $";
d232 1
a232 1
	const char str[] = "[\n]P\n";
@


1.20
log
@fclose file stream before opening a new one.
@
text
@d2 1
a2 1
/*      $OpenBSD: scan.l,v 1.19 2005/12/03 18:23:47 deraadt Exp $	*/
d21 1
a21 1
static const char rcsid[] = "$OpenBSD: scan.l,v 1.19 2005/12/03 18:23:47 deraadt Exp $";
d35 1
a39 1
static volatile sig_atomic_t	interactive = 0;
d235 4
a238 6
	if (interactive) {
		save_errno = errno;
		YY_FLUSH_BUFFER;	/* XXX signal race? */
		write(STDOUT_FILENO, str, sizeof(str) - 1);
		errno = save_errno;
	}
d278 2
a279 1
		interactive = isatty(fileno(yyin));
@


1.19
log
@ARGSUSED signal handler
@
text
@d2 1
a2 1
/*      $OpenBSD: scan.l,v 1.18 2005/04/13 06:36:03 otto Exp $	*/
d21 1
a21 1
static const char rcsid[] = "$OpenBSD: scan.l,v 1.18 2005/04/13 06:36:03 otto Exp $";
d268 2
@


1.18
log
@Always use lex in interactive mode. Makes bc running as a co-process
behave. Very, very little performance loss. Spotted by and ok fschg@@
@
text
@d2 1
a2 1
/*      $OpenBSD: scan.l,v 1.17 2005/03/28 17:43:28 deraadt Exp $	*/
d21 1
a21 1
static const char rcsid[] = "$OpenBSD: scan.l,v 1.17 2005/03/28 17:43:28 deraadt Exp $";
d228 1
@


1.17
log
@mark potential signal race so we fix it later, ok otto
@
text
@d2 1
a2 1
/*      $OpenBSD: scan.l,v 1.16 2004/12/02 19:30:05 otto Exp $	*/
d21 1
a21 1
static const char rcsid[] = "$OpenBSD: scan.l,v 1.16 2004/12/02 19:30:05 otto Exp $";
d28 1
d45 2
@


1.16
log
@Fix signal races for isatty(3) (calls ioctl(2)) and printf(3);
save/restore errno. YY_FLUSH_BUFFER might still be a problem.
Spotted by and ok deraadt@@
@
text
@d2 1
a2 1
/*      $OpenBSD: scan.l,v 1.15 2004/10/19 07:36:51 otto Exp $	*/
d21 1
a21 1
static const char rcsid[] = "$OpenBSD: scan.l,v 1.15 2004/10/19 07:36:51 otto Exp $";
d233 1
a233 1
		YY_FLUSH_BUFFER;
@


1.15
log
@Implement -e expression, for command line expression evaluation.
ok deraadt@@
@
text
@d2 1
a2 1
/*      $OpenBSD: scan.l,v 1.14 2003/12/02 09:00:07 otto Exp $	*/
d21 1
a21 1
static const char rcsid[] = "$OpenBSD: scan.l,v 1.14 2003/12/02 09:00:07 otto Exp $";
d25 1
d38 1
d228 5
a232 1
	if (isatty(fileno(yyin))) {
d234 2
a235 1
		printf("[\n]P\n");
d274 1
@


1.14
log
@o Introduce long variable names, a non-portable extension.
o Make main program target left recursive. Reduces parse stack usage, making
  it possible to compile programs > 10000 lines.
@
text
@d2 1
a2 1
/*      $OpenBSD: scan.l,v 1.13 2003/11/17 11:20:13 otto Exp $	*/
d21 1
a21 1
static const char rcsid[] = "$OpenBSD: scan.l,v 1.13 2003/11/17 11:20:13 otto Exp $";
d29 1
d231 43
@


1.13
log
@Implement non-portable extensions:
o boolean operators !, && and ||.
o allow relational operators to appear in any expression, not just
  conditional expressions.
@
text
@d2 1
a2 1
/*      $OpenBSD: scan.l,v 1.12 2003/11/11 19:49:02 otto Exp $	*/
d21 1
a21 1
static const char rcsid[] = "$OpenBSD: scan.l,v 1.12 2003/11/11 19:49:02 otto Exp $";
d43 3
d168 9
a176 1
[a-z]		yylval.str = yytext; return LETTER;
d183 1
d206 1
a206 1
	if (strlen(strbuf) + arglen + 1> strbuf_sz) {
@


1.12
log
@Some syntactic sugar (all non-portable extensions):
- a line comment, starting with #
- opening brace of define statement may be on next line
- return expression, equivalent to return (expression)
@
text
@d2 1
a2 1
/*      $OpenBSD: scan.l,v 1.11 2003/11/11 09:15:36 otto Exp $	*/
d21 1
a21 1
static const char rcsid[] = "$OpenBSD: scan.l,v 1.11 2003/11/11 09:15:36 otto Exp $";
d127 4
@


1.11
log
@Implement `print' statement, a non-portable extension.
@
text
@d2 1
a2 1
/*      $OpenBSD: scan.l,v 1.10 2003/11/09 19:27:27 otto Exp $	*/
d21 1
a21 1
static const char rcsid[] = "$OpenBSD: scan.l,v 1.10 2003/11/09 19:27:27 otto Exp $";
d166 1
@


1.10
log
@Introduce `last' as a synonym for `.' and document them.
@
text
@d2 1
a2 1
/*      $OpenBSD: scan.l,v 1.9 2003/10/18 20:35:36 otto Exp $	*/
d21 1
a21 1
static const char rcsid[] = "$OpenBSD: scan.l,v 1.9 2003/10/18 20:35:36 otto Exp $";
d116 1
@


1.9
log
@err(1, "cannot allocate mem") -> err(1, NULL)
@
text
@d2 1
a2 1
/*      $OpenBSD: scan.l,v 1.8 2003/10/18 19:57:10 otto Exp $	*/
d21 1
a21 1
static const char rcsid[] = "$OpenBSD: scan.l,v 1.8 2003/10/18 19:57:10 otto Exp $";
d112 1
@


1.8
log
@o Fix assignment operators (+=, -=, ... )
o Implement "continue" in loops. If continue is not used, generated code is
  still "classic" dc(1) compatible. If continue is used, you'll need a dc(1)
  that implements the J and M operators.
@
text
@d2 1
a2 1
/*      $OpenBSD: scan.l,v 1.7 2003/09/30 18:46:11 otto Exp $	*/
d21 1
a21 1
static const char rcsid[] = "$OpenBSD: scan.l,v 1.7 2003/09/30 18:46:11 otto Exp $";
d175 1
a175 1
			err(1, "cannot allocate string buffer");
d195 1
a195 1
			err(1, "cannot realloc string buffer");
@


1.7
log
@Make sure strings and error messages sent to dc(1) properly escape [, ] and \.
@
text
@d2 1
a2 1
/*      $OpenBSD: scan.l,v 1.6 2003/09/29 03:24:27 otto Exp $	*/
d21 1
a21 1
static const char rcsid[] = "$OpenBSD: scan.l,v 1.6 2003/09/29 03:24:27 otto Exp $";
d107 1
d109 1
@


1.6
log
@Implement (undocumented) dot shorthand, which was missing.
Spotted by millert@@.
@
text
@d2 1
a2 1
/*      $OpenBSD: scan.l,v 1.5 2003/09/28 07:57:57 otto Exp $	*/
d21 1
a21 1
static const char rcsid[] = "$OpenBSD: scan.l,v 1.5 2003/09/28 07:57:57 otto Exp $";
d58 4
a61 1
	[^"\n]+	add_str(yytext);
@


1.5
log
@Better error hanndling:
- skip current line on syntax error
- detect EOF in strings and comments
- report correct line number in above case
- more consistent warning and errors

ok henning@@
@
text
@d2 1
a2 1
/*      $OpenBSD: scan.l,v 1.4 2003/09/26 19:00:38 deraadt Exp $	*/
d21 1
a21 1
static const char rcsid[] = "$OpenBSD: scan.l,v 1.4 2003/09/26 19:00:38 deraadt Exp $";
d91 4
a94 5
			if (strcmp(strbuf, ".") == 0) {
				yyerror("syntax error");
				BEGIN(INITIAL);
				REJECT;
			}
a95 1
				BEGIN(INITIAL);
a96 1
				unput(yytext[0]);
@


1.4
log
@spacing
@
text
@d2 1
a2 1
/*      $OpenBSD: scan.l,v 1.3 2003/09/26 07:04:25 deraadt Exp $	*/
d21 1
a21 1
static const char rcsid[] = "$OpenBSD: scan.l,v 1.3 2003/09/26 07:04:25 deraadt Exp $";
d53 1
d61 1
d92 1
a92 2
				warnx("unexpected ascii char 0x%x at line %d",
				    yytext[0], lineno);
d163 1
a163 1
.		warnx("unexpected character %c at line %d", yytext[0], lineno);
@


1.3
log
@spacing
@
text
@d2 1
a2 1
/*      $OpenBSD: scan.l,v 1.2 2003/09/26 07:02:52 deraadt Exp $	*/
d21 1
a21 1
static const char rcsid[] = "$OpenBSD: scan.l,v 1.2 2003/09/26 07:02:52 deraadt Exp $";
d129 1
a129 1
"="		yylval.str = "";  return ASSIGN_OP;
@


1.2
log
@spacing
@
text
@d2 1
a2 1
/*      $OpenBSD: scan.l,v 1.1 2003/09/25 19:32:44 otto Exp $	*/
d21 1
a21 1
static const char rcsid[] = "$OpenBSD: scan.l,v 1.1 2003/09/25 19:32:44 otto Exp $";
d186 1
a186 1
		char * p;
@


1.1
log
@A new, BSD licensed implementation of bc(1).

ok deraadt@@
@
text
@d2 1
a2 1
/*      $OpenBSD$	*/
d21 1
a21 1
static const char rcsid[] = "$OpenBSD$";
d33 1
a33 1
static char 	*strbuf = NULL;
d105 1
a105 1
"break" 	return BREAK;
@

