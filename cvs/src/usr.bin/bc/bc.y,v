head	1.51;
access;
symbols
	OPENBSD_6_1:1.50.0.4
	OPENBSD_6_1_BASE:1.50
	OPENBSD_6_0:1.49.0.4
	OPENBSD_6_0_BASE:1.49
	OPENBSD_5_9:1.49.0.2
	OPENBSD_5_9_BASE:1.49
	OPENBSD_5_8:1.47.0.6
	OPENBSD_5_8_BASE:1.47
	OPENBSD_5_7:1.47.0.2
	OPENBSD_5_7_BASE:1.47
	OPENBSD_5_6:1.44.0.6
	OPENBSD_5_6_BASE:1.44
	OPENBSD_5_5:1.44.0.4
	OPENBSD_5_5_BASE:1.44
	OPENBSD_5_4:1.41.0.6
	OPENBSD_5_4_BASE:1.41
	OPENBSD_5_3:1.41.0.4
	OPENBSD_5_3_BASE:1.41
	OPENBSD_5_2:1.41.0.2
	OPENBSD_5_2_BASE:1.41
	OPENBSD_5_1_BASE:1.40
	OPENBSD_5_1:1.40.0.2
	OPENBSD_5_0:1.39.0.2
	OPENBSD_5_0_BASE:1.39
	OPENBSD_4_9:1.33.0.6
	OPENBSD_4_9_BASE:1.33
	OPENBSD_4_8:1.33.0.4
	OPENBSD_4_8_BASE:1.33
	OPENBSD_4_7:1.33.0.2
	OPENBSD_4_7_BASE:1.33
	OPENBSD_4_6:1.32.0.16
	OPENBSD_4_6_BASE:1.32
	OPENBSD_4_5:1.32.0.12
	OPENBSD_4_5_BASE:1.32
	OPENBSD_4_4:1.32.0.10
	OPENBSD_4_4_BASE:1.32
	OPENBSD_4_3:1.32.0.8
	OPENBSD_4_3_BASE:1.32
	OPENBSD_4_2:1.32.0.6
	OPENBSD_4_2_BASE:1.32
	OPENBSD_4_1:1.32.0.4
	OPENBSD_4_1_BASE:1.32
	OPENBSD_4_0:1.32.0.2
	OPENBSD_4_0_BASE:1.32
	OPENBSD_3_9:1.27.0.2
	OPENBSD_3_9_BASE:1.27
	OPENBSD_3_8:1.26.0.2
	OPENBSD_3_8_BASE:1.26
	OPENBSD_3_7:1.25.0.2
	OPENBSD_3_7_BASE:1.25
	OPENBSD_3_6:1.23.0.4
	OPENBSD_3_6_BASE:1.23
	OPENBSD_3_5:1.23.0.2
	OPENBSD_3_5_BASE:1.23;
locks; strict;
comment	@ * @;


1.51
date	2017.07.02.23.19.07;	author deraadt;	state Exp;
branches;
next	1.50;
commitid	qIELr34YIaJyUfVT;

1.50
date	2017.02.23.06.41.46;	author otto;	state Exp;
branches;
next	1.49;
commitid	6hGZXftb1u1XXhvP;

1.49
date	2015.11.23.09.58.55;	author otto;	state Exp;
branches;
next	1.48;
commitid	IK9gbEjU6p3nnj1D;

1.48
date	2015.10.10.19.28.54;	author deraadt;	state Exp;
branches;
next	1.47;
commitid	U920W7iXGRn2x9qj;

1.47
date	2014.11.26.18.34.51;	author millert;	state Exp;
branches;
next	1.46;
commitid	9QOFSShUOtA0kQLF;

1.46
date	2014.10.14.15.35.18;	author deraadt;	state Exp;
branches;
next	1.45;
commitid	njBzguV7ZWuBbLtj;

1.45
date	2014.10.08.04.13.33;	author deraadt;	state Exp;
branches;
next	1.44;
commitid	3pFtRGdP8NqCr9e7;

1.44
date	2013.11.20.21.33.54;	author deraadt;	state Exp;
branches;
next	1.43;

1.43
date	2013.11.12.13.54.51;	author deraadt;	state Exp;
branches;
next	1.42;

1.42
date	2013.09.19.16.12.01;	author otto;	state Exp;
branches;
next	1.41;

1.41
date	2012.03.08.08.20.08;	author otto;	state Exp;
branches;
next	1.40;

1.40
date	2011.10.06.14.37.56;	author otto;	state Exp;
branches;
next	1.39;

1.39
date	2011.08.03.08.48.19;	author otto;	state Exp;
branches;
next	1.38;

1.38
date	2011.07.08.23.29.46;	author tedu;	state Exp;
branches;
next	1.37;

1.37
date	2011.06.03.06.52.37;	author deraadt;	state Exp;
branches;
next	1.36;

1.36
date	2011.06.03.06.10.31;	author otto;	state Exp;
branches;
next	1.35;

1.35
date	2011.06.01.07.18.23;	author otto;	state Exp;
branches;
next	1.34;

1.34
date	2011.03.07.08.11.15;	author otto;	state Exp;
branches;
next	1.33;

1.33
date	2009.10.27.23.59.36;	author deraadt;	state Exp;
branches;
next	1.32;

1.32
date	2006.05.18.05.49.53;	author otto;	state Exp;
branches;
next	1.31;

1.31
date	2006.04.20.20.00.46;	author deraadt;	state Exp;
branches;
next	1.30;

1.30
date	2006.03.31.09.57.26;	author otto;	state Exp;
branches;
next	1.29;

1.29
date	2006.03.18.21.05.50;	author otto;	state Exp;
branches;
next	1.28;

1.28
date	2006.03.18.20.44.43;	author otto;	state Exp;
branches;
next	1.27;

1.27
date	2005.09.18.19.29.41;	author otto;	state Exp;
branches;
next	1.26;

1.26
date	2005.05.23.06.44.58;	author otto;	state Exp;
branches;
next	1.25;

1.25
date	2005.03.17.16.59.31;	author otto;	state Exp;
branches;
next	1.24;

1.24
date	2004.10.19.07.36.51;	author otto;	state Exp;
branches;
next	1.23;

1.23
date	2004.02.18.07.43.58;	author otto;	state Exp;
branches;
next	1.22;

1.22
date	2004.01.13.08.43.23;	author otto;	state Exp;
branches;
next	1.21;

1.21
date	2003.12.19.19.24.22;	author otto;	state Exp;
branches;
next	1.20;

1.20
date	2003.12.02.09.00.07;	author otto;	state Exp;
branches;
next	1.19;

1.19
date	2003.11.17.11.20.13;	author otto;	state Exp;
branches;
next	1.18;

1.18
date	2003.11.13.19.42.21;	author otto;	state Exp;
branches;
next	1.17;

1.17
date	2003.11.13.19.05.32;	author otto;	state Exp;
branches;
next	1.16;

1.16
date	2003.11.11.19.49.02;	author otto;	state Exp;
branches;
next	1.15;

1.15
date	2003.11.11.09.15.36;	author otto;	state Exp;
branches;
next	1.14;

1.14
date	2003.10.22.12.24.41;	author otto;	state Exp;
branches;
next	1.13;

1.13
date	2003.10.19.19.21.48;	author otto;	state Exp;
branches;
next	1.12;

1.12
date	2003.10.18.20.35.36;	author otto;	state Exp;
branches;
next	1.11;

1.11
date	2003.10.18.19.57.10;	author otto;	state Exp;
branches;
next	1.10;

1.10
date	2003.09.30.18.46.11;	author otto;	state Exp;
branches;
next	1.9;

1.9
date	2003.09.29.03.24.27;	author otto;	state Exp;
branches;
next	1.8;

1.8
date	2003.09.28.07.57.57;	author otto;	state Exp;
branches;
next	1.7;

1.7
date	2003.09.28.07.45.55;	author otto;	state Exp;
branches;
next	1.6;

1.6
date	2003.09.26.19.26.16;	author deraadt;	state Exp;
branches;
next	1.5;

1.5
date	2003.09.26.19.06.46;	author deraadt;	state Exp;
branches;
next	1.4;

1.4
date	2003.09.26.19.05.56;	author deraadt;	state Exp;
branches;
next	1.3;

1.3
date	2003.09.26.19.00.38;	author deraadt;	state Exp;
branches;
next	1.2;

1.2
date	2003.09.26.07.23.06;	author otto;	state Exp;
branches;
next	1.1;

1.1
date	2003.09.25.19.32.44;	author otto;	state Exp;
branches;
next	;


desc
@@


1.51
log
@whitespace
@
text
@%{
/*	$OpenBSD: bc.y,v 1.50 2017/02/23 06:41:46 otto Exp $	*/

/*
 * Copyright (c) 2003, Otto Moerbeek <otto@@drijf.net>
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */

/*
 * This implementation of bc(1) uses concepts from the original 4.4
 * BSD bc(1). The code itself is a complete rewrite, based on the
 * Posix defined bc(1) grammar. Other differences include type safe
 * usage of pointers to build the tree of emitted code, typed yacc
 * rule values, dynamic allocation of all data structures and a
 * completely rewritten lexical analyzer using lex(1).
 *
 * Some effort has been made to make sure that the generated code is
 * the same as the code generated by the older version, to provide
 * easy regression testing.
 */

#include <sys/types.h>
#include <sys/wait.h>

#include <ctype.h>
#include <err.h>
#include <errno.h>
#include <histedit.h>
#include <limits.h>
#include <search.h>
#include <signal.h>
#include <stdarg.h>
#include <string.h>
#include <unistd.h>

#include "extern.h"
#include "pathnames.h"

#define END_NODE	((ssize_t) -1)
#define CONST_STRING	((ssize_t) -2)
#define ALLOC_STRING	((ssize_t) -3)

struct tree {
	ssize_t			index;
	union {
		char		*astr;
		const char	*cstr;
	} u;
};

int			yyparse(void);
int			yywrap(void);

int			fileindex;
int			sargc;
char			**sargv;
char			*filename;
char			*cmdexpr;

static void		grow(void);
static ssize_t		cs(const char *);
static ssize_t		as(const char *);
static ssize_t		node(ssize_t, ...);
static void		emit(ssize_t, int);
static void		emit_macro(int, ssize_t);
static void		free_tree(void);
static ssize_t		numnode(int);
static ssize_t		lookup(char *, size_t, char);
static ssize_t		letter_node(char *);
static ssize_t		array_node(char *);
static ssize_t		function_node(char *);

static void		add_par(ssize_t);
static void		add_local(ssize_t);
static void		warning(const char *);
static void		init(void);
static __dead void	usage(void);
static char		*escape(const char *);

static ssize_t		instr_sz = 0;
static struct tree	*instructions = NULL;
static ssize_t		current = 0;
static int		macro_char = '0';
static int		reset_macro_char = '0';
static int		nesting = 0;
static int		breakstack[16];
static int		breaksp = 0;
static ssize_t		prologue;
static ssize_t		epilogue;
static bool		st_has_continue;
static char		str_table[UCHAR_MAX][2];
static bool		do_fork = true;
static u_short		var_count;
static pid_t		dc;

extern char *__progname;

#define BREAKSTACK_SZ	(sizeof(breakstack)/sizeof(breakstack[0]))

/* These values are 4.4BSD bc compatible */
#define FUNC_CHAR	0x01
#define ARRAY_CHAR	0xa1

/* Skip '\0', [, \ and ] */
#define ENCODE(c)	((c) < '[' ? (c) : (c) + 3);
#define VAR_BASE	(256-4)
#define MAX_VARIABLES	(VAR_BASE * VAR_BASE)

%}

%start program

%union {
	ssize_t		node;
	struct lvalue	lvalue;
	const char	*str;
	char		*astr;
}

%token COMMA SEMICOLON LPAR RPAR LBRACE RBRACE LBRACKET RBRACKET DOT
%token NEWLINE
%token <astr> LETTER
%token <str> NUMBER STRING
%token DEFINE BREAK QUIT LENGTH
%token RETURN FOR IF WHILE SQRT
%token SCALE IBASE OBASE AUTO
%token CONTINUE ELSE PRINT

%left BOOL_OR
%left BOOL_AND
%nonassoc BOOL_NOT
%nonassoc EQUALS LESS_EQ GREATER_EQ UNEQUALS LESS GREATER
%right <str> ASSIGN_OP
%left PLUS MINUS
%left MULTIPLY DIVIDE REMAINDER
%right EXPONENT
%nonassoc UMINUS
%nonassoc INCR DECR

%type <lvalue>	named_expression
%type <node>	argument_list
%type <node>	alloc_macro
%type <node>	expression
%type <node>	function
%type <node>	function_header
%type <node>	input_item
%type <node>	opt_argument_list
%type <node>	opt_expression
%type <node>	opt_relational_expression
%type <node>	opt_statement
%type <node>	print_expression
%type <node>	print_expression_list
%type <node>	relational_expression
%type <node>	return_expression
%type <node>	semicolon_list
%type <node>	statement
%type <node>	statement_list

%%

program		: /* empty */
		| program input_item
		;

input_item	: semicolon_list NEWLINE
			{
				emit($1, 0);
				macro_char = reset_macro_char;
				putchar('\n');
				free_tree();
				st_has_continue = false;
			}
		| function
			{
				putchar('\n');
				free_tree();
				st_has_continue = false;
			}
		| error NEWLINE
			{
				yyerrok;
			}
		| error QUIT
			{
				yyerrok;
			}
		;

semicolon_list	: /* empty */
			{
				$$ = cs("");
			}
		| statement
		| semicolon_list SEMICOLON statement
			{
				$$ = node($1, $3, END_NODE);
			}
		| semicolon_list SEMICOLON
		;

statement_list	: /* empty */
			{
				$$ = cs("");
			}
		| statement
		| statement_list NEWLINE
		| statement_list NEWLINE statement
			{
				$$ = node($1, $3, END_NODE);
			}
		| statement_list SEMICOLON
		| statement_list SEMICOLON statement
			{
				$$ = node($1, $3, END_NODE);
			}
		;


opt_statement	: /* empty */
			{
				$$ = cs("");
			}
		| statement
		;

statement	: expression
			{
				$$ = node($1, cs("ps."), END_NODE);
			}
		| named_expression ASSIGN_OP expression
			{
				if ($2[0] == '\0')
					$$ = node($3, cs($2), $1.store,
					    END_NODE);
				else
					$$ = node($1.load, $3, cs($2), $1.store,
					    END_NODE);
			}
		| STRING
			{
				$$ = node(cs("["), as($1),
				    cs("]P"), END_NODE);
			}
		| BREAK
			{
				if (breaksp == 0) {
					warning("break not in for or while");
					YYERROR;
				} else {
					$$ = node(
					    numnode(nesting -
						breakstack[breaksp-1]),
					    cs("Q"), END_NODE);
				}
			}
		| CONTINUE
			{
				if (breaksp == 0) {
					warning("continue not in for or while");
					YYERROR;
				} else {
					st_has_continue = true;
					$$ = node(numnode(nesting -
					    breakstack[breaksp-1] - 1),
					    cs("J"), END_NODE);
				}
			}
		| QUIT
			{
				sigset_t mask;

				putchar('q');
				fflush(stdout);
				if (dc) {
					sigprocmask(SIG_BLOCK, NULL, &mask);
					sigsuspend(&mask);
				} else
					exit(0);
			}
		| RETURN return_expression
			{
				if (nesting == 0) {
					warning("return must be in a function");
					YYERROR;
				}
				$$ = $2;
			}
		| FOR LPAR alloc_macro opt_expression SEMICOLON
		     opt_relational_expression SEMICOLON
		     opt_expression RPAR opt_statement pop_nesting
			{
				ssize_t n;

				if (st_has_continue)
					n = node($10, cs("M"), $8, cs("s."),
					    $6, $3, END_NODE);
				else
					n = node($10, $8, cs("s."), $6, $3,
					    END_NODE);

				emit_macro($3, n);
				$$ = node($4, cs("s."), $6, $3, cs(" "),
				    END_NODE);
			}
		| IF LPAR alloc_macro pop_nesting relational_expression RPAR
		      opt_statement
			{
				emit_macro($3, $7);
				$$ = node($5, $3, cs(" "), END_NODE);
			}
		| IF LPAR alloc_macro pop_nesting relational_expression RPAR
		      opt_statement ELSE alloc_macro pop_nesting opt_statement
			{
				emit_macro($3, $7);
				emit_macro($9, $11);
				$$ = node($5, $3, cs("e"), $9, cs(" "),
				    END_NODE);
			}
		| WHILE LPAR alloc_macro relational_expression RPAR
		      opt_statement pop_nesting
			{
				ssize_t n;

				if (st_has_continue)
					n = node($6, cs("M"), $4, $3, END_NODE);
				else
					n = node($6, $4, $3, END_NODE);
				emit_macro($3, n);
				$$ = node($4, $3, cs(" "), END_NODE);
			}
		| LBRACE statement_list RBRACE
			{
				$$ = $2;
			}
		| PRINT print_expression_list
			{
				$$ = $2;
			}
		;

alloc_macro	: /* empty */
			{
				$$ = cs(str_table[macro_char]);
				macro_char++;
				/* Do not use [, \ and ] */
				if (macro_char == '[')
					macro_char += 3;
				/* skip letters */
				else if (macro_char == 'a')
					macro_char = '{';
				else if (macro_char == ARRAY_CHAR)
					macro_char += 26;
				else if (macro_char == 255)
					fatal("program too big");
				if (breaksp == BREAKSTACK_SZ)
					fatal("nesting too deep");
				breakstack[breaksp++] = nesting++;
			}
		;

pop_nesting	: /* empty */
			{
				breaksp--;
			}
		;

function	: function_header opt_parameter_list RPAR opt_newline
		  LBRACE NEWLINE opt_auto_define_list
		  statement_list RBRACE
			{
				int n = node(prologue, $8, epilogue,
				    cs("0"), numnode(nesting),
				    cs("Q"), END_NODE);
				emit_macro($1, n);
				reset_macro_char = macro_char;
				nesting = 0;
				breaksp = 0;
			}
		;

function_header : DEFINE LETTER LPAR
			{
				$$ = function_node($2);
				free($2);
				prologue = cs("");
				epilogue = cs("");
				nesting = 1;
				breaksp = 0;
				breakstack[breaksp] = 0;
			}
		;

opt_newline	: /* empty */
		| NEWLINE
		;

opt_parameter_list
		: /* empty */
		| parameter_list
		;


parameter_list	: LETTER
			{
				add_par(letter_node($1));
				free($1);
			}
		| LETTER LBRACKET RBRACKET
			{
				add_par(array_node($1));
				free($1);
			}
		| parameter_list COMMA LETTER
			{
				add_par(letter_node($3));
				free($3);
			}
		| parameter_list COMMA LETTER LBRACKET RBRACKET
			{
				add_par(array_node($3));
				free($3);
			}
		;



opt_auto_define_list
		: /* empty */
		| AUTO define_list NEWLINE
		| AUTO define_list SEMICOLON
		;


define_list	: LETTER
			{
				add_local(letter_node($1));
				free($1);
			}
		| LETTER LBRACKET RBRACKET
			{
				add_local(array_node($1));
				free($1);
			}
		| define_list COMMA LETTER
			{
				add_local(letter_node($3));
				free($3);
			}
		| define_list COMMA LETTER LBRACKET RBRACKET
			{
				add_local(array_node($3));
				free($3);
			}
		;


opt_argument_list
		: /* empty */
			{
				$$ = cs("");
			}
		| argument_list
		;


argument_list	: expression
		| argument_list COMMA expression
			{
				$$ = node($1, $3, END_NODE);
			}
		| argument_list COMMA LETTER LBRACKET RBRACKET
			{
				$$ = node($1, cs("l"), array_node($3),
				    END_NODE);
				free($3);
			}
		;

opt_relational_expression
		: /* empty */
			{
				$$ = cs(" 0 0=");
			}
		| relational_expression
		;

relational_expression
		: expression EQUALS expression
			{
				$$ = node($1, $3, cs("="), END_NODE);
			}
		| expression UNEQUALS expression
			{
				$$ = node($1, $3, cs("!="), END_NODE);
			}
		| expression LESS expression
			{
				$$ = node($1, $3, cs(">"), END_NODE);
			}
		| expression LESS_EQ expression
			{
				$$ = node($1, $3, cs("!<"), END_NODE);
			}
		| expression GREATER expression
			{
				$$ = node($1, $3, cs("<"), END_NODE);
			}
		| expression GREATER_EQ expression
			{
				$$ = node($1, $3, cs("!>"), END_NODE);
			}
		| expression
			{
				$$ = node($1, cs(" 0!="), END_NODE);
			}
		;


return_expression
		: /* empty */
			{
				$$ = node(cs("0"), epilogue,
				    numnode(nesting), cs("Q"), END_NODE);
			}
		| expression
			{
				$$ = node($1, epilogue,
				    numnode(nesting), cs("Q"), END_NODE);
			}
		| LPAR RPAR
			{
				$$ = node(cs("0"), epilogue,
				    numnode(nesting), cs("Q"), END_NODE);
			}
		;


opt_expression : /* empty */
			{
				$$ = cs(" 0");
			}
		| expression
		;

expression	: named_expression
			{
				$$ = node($1.load, END_NODE);
			}
		| DOT	{
				$$ = node(cs("l."), END_NODE);
			}
		| NUMBER
			{
				$$ = node(cs(" "), as($1), END_NODE);
			}
		| LPAR expression RPAR
			{
				$$ = $2;
			}
		| LETTER LPAR opt_argument_list RPAR
			{
				$$ = node($3, cs("l"),
				    function_node($1), cs("x"),
				    END_NODE);
				free($1);
			}
		| MINUS expression %prec UMINUS
			{
				$$ = node(cs(" 0"), $2, cs("-"),
				    END_NODE);
			}
		| expression PLUS expression
			{
				$$ = node($1, $3, cs("+"), END_NODE);
			}
		| expression MINUS expression
			{
				$$ = node($1, $3, cs("-"), END_NODE);
			}
		| expression MULTIPLY expression
			{
				$$ = node($1, $3, cs("*"), END_NODE);
			}
		| expression DIVIDE expression
			{
				$$ = node($1, $3, cs("/"), END_NODE);
			}
		| expression REMAINDER expression
			{
				$$ = node($1, $3, cs("%"), END_NODE);
			}
		| expression EXPONENT expression
			{
				$$ = node($1, $3, cs("^"), END_NODE);
			}
		| INCR named_expression
			{
				$$ = node($2.load, cs("1+d"), $2.store,
				    END_NODE);
			}
		| DECR named_expression
			{
				$$ = node($2.load, cs("1-d"),
				    $2.store, END_NODE);
			}
		| named_expression INCR
			{
				$$ = node($1.load, cs("d1+"),
				    $1.store, END_NODE);
			}
		| named_expression DECR
			{
				$$ = node($1.load, cs("d1-"),
				    $1.store, END_NODE);
			}
		| named_expression ASSIGN_OP expression
			{
				if ($2[0] == '\0')
					$$ = node($3, cs($2), cs("d"), $1.store,
					    END_NODE);
				else
					$$ = node($1.load, $3, cs($2), cs("d"),
					    $1.store, END_NODE);
			}
		| LENGTH LPAR expression RPAR
			{
				$$ = node($3, cs("Z"), END_NODE);
			}
		| SQRT LPAR expression RPAR
			{
				$$ = node($3, cs("v"), END_NODE);
			}
		| SCALE LPAR expression RPAR
			{
				$$ = node($3, cs("X"), END_NODE);
			}
		| BOOL_NOT expression
			{
				$$ = node($2, cs("N"), END_NODE);
			}
		| expression BOOL_AND alloc_macro pop_nesting expression
			{
				ssize_t n = node(cs("R"), $5, END_NODE);
				emit_macro($3, n);
				$$ = node($1, cs("d0!="), $3, END_NODE);
			}
		| expression BOOL_OR alloc_macro pop_nesting expression
			{
				ssize_t n = node(cs("R"), $5, END_NODE);
				emit_macro($3, n);
				$$ = node($1, cs("d0="), $3, END_NODE);
			}
		| expression EQUALS expression
			{
				$$ = node($1, $3, cs("G"), END_NODE);
			}
		| expression UNEQUALS expression
			{
				$$ = node($1, $3, cs("GN"), END_NODE);
			}
		| expression LESS expression
			{
				$$ = node($3, $1, cs("("), END_NODE);
			}
		| expression LESS_EQ expression
			{
				$$ = node($3, $1, cs("{"), END_NODE);
			}
		| expression GREATER expression
			{
				$$ = node($1, $3, cs("("), END_NODE);
			}
		| expression GREATER_EQ expression
			{
				$$ = node($1, $3, cs("{"), END_NODE);
			}
		;

named_expression
		: LETTER
			{
				$$.load = node(cs("l"), letter_node($1),
				    END_NODE);
				$$.store = node(cs("s"), letter_node($1),
				    END_NODE);
				free($1);
			}
		| LETTER LBRACKET expression RBRACKET
			{
				$$.load = node($3, cs(";"),
				    array_node($1), END_NODE);
				$$.store = node($3, cs(":"),
				    array_node($1), END_NODE);
				free($1);
			}
		| SCALE
			{
				$$.load = cs("K");
				$$.store = cs("k");
			}
		| IBASE
			{
				$$.load = cs("I");
				$$.store = cs("i");
			}
		| OBASE
			{
				$$.load = cs("O");
				$$.store = cs("o");
			}
		;

print_expression_list
		: print_expression
		| print_expression_list COMMA print_expression
			{
				$$ = node($1, $3, END_NODE);
			}

print_expression
		: expression
			{
				$$ = node($1, cs("ds.n"), END_NODE);
			}
		| STRING
			{
				char *p = escape($1);
				$$ = node(cs("["), as(p), cs("]n"), END_NODE);
				free(p);
			}
%%


static void
grow(void)
{
	struct tree	*p;
	size_t		newsize;

	if (current == instr_sz) {
		newsize = instr_sz * 2 + 1;
		p = reallocarray(instructions, newsize, sizeof(*p));
		if (p == NULL) {
			free(instructions);
			err(1, NULL);
		}
		instructions = p;
		instr_sz = newsize;
	}
}

static ssize_t
cs(const char *str)
{
	grow();
	instructions[current].index = CONST_STRING;
	instructions[current].u.cstr = str;
	return current++;
}

static ssize_t
as(const char *str)
{
	grow();
	instructions[current].index = ALLOC_STRING;
	instructions[current].u.astr = strdup(str);
	if (instructions[current].u.astr == NULL)
		err(1, NULL);
	return current++;
}

static ssize_t
node(ssize_t arg, ...)
{
	va_list		ap;
	ssize_t		ret;

	va_start(ap, arg);

	ret = current;
	grow();
	instructions[current++].index = arg;

	do {
		arg = va_arg(ap, ssize_t);
		grow();
		instructions[current++].index = arg;
	} while (arg != END_NODE);

	va_end(ap);
	return ret;
}

static void
emit(ssize_t i, int level)
{
	if (level > 1000)
		errx(1, "internal error: tree level > 1000");
	if (instructions[i].index >= 0) {
		while (instructions[i].index != END_NODE &&
		    instructions[i].index != i)  {
			emit(instructions[i].index, level + 1);
			i++;
		}
	} else if (instructions[i].index != END_NODE)
		fputs(instructions[i].u.cstr, stdout);
}

static void
emit_macro(int node, ssize_t code)
{
	putchar('[');
	emit(code, 0);
	printf("]s%s\n", instructions[node].u.cstr);
	nesting--;
}

static void
free_tree(void)
{
	ssize_t i;

	for (i = 0; i < current; i++)
		if (instructions[i].index == ALLOC_STRING)
			free(instructions[i].u.astr);
	current = 0;
}

static ssize_t
numnode(int num)
{
	const char *p;

	if (num < 10)
		p = str_table['0' + num];
	else if (num < 16)
		p = str_table['A' - 10 + num];
	else
		errx(1, "internal error: break num > 15");
	return node(cs(" "), cs(p), END_NODE);
}


static ssize_t
lookup(char * str, size_t len, char type)
{
	ENTRY	entry, *found;
	u_short	num;
	u_char	*p;

	/* The scanner allocated an extra byte already */
	if (str[len-1] != type) {
		str[len] = type;
		str[len+1] = '\0';
	}
	entry.key = str;
	found = hsearch(entry, FIND);
	if (found == NULL) {
		if (var_count == MAX_VARIABLES)
			errx(1, "too many variables");
		p = malloc(4);
		if (p == NULL)
			err(1, NULL);
		num = var_count++;
		p[0] = 255;
		p[1] = ENCODE(num / VAR_BASE + 1);
		p[2] = ENCODE(num % VAR_BASE + 1);
		p[3] = '\0';

		entry.data = (char *)p;
		entry.key = strdup(str);
		if (entry.key == NULL)
			err(1, NULL);
		found = hsearch(entry, ENTER);
		if (found == NULL)
			err(1, NULL);
	}
	return cs(found->data);
}

static ssize_t
letter_node(char *str)
{
	size_t len;

	len = strlen(str);
	if (len == 1 && str[0] != '_')
		return cs(str_table[(int)str[0]]);
	else
		return lookup(str, len, 'L');
}

static ssize_t
array_node(char *str)
{
	size_t len;

	len = strlen(str);
	if (len == 1 && str[0] != '_')
		return cs(str_table[(int)str[0] - 'a' + ARRAY_CHAR]);
	else
		return lookup(str, len, 'A');
}

static ssize_t
function_node(char *str)
{
	size_t len;

	len = strlen(str);
	if (len == 1 && str[0] != '_')
		return cs(str_table[(int)str[0] - 'a' + FUNC_CHAR]);
	else
		return lookup(str, len, 'F');
}

static void
add_par(ssize_t n)
{
	prologue = node(cs("S"), n, prologue, END_NODE);
	epilogue = node(epilogue, cs("L"), n, cs("s."), END_NODE);
}

static void
add_local(ssize_t n)
{
	prologue = node(cs("0S"), n, prologue, END_NODE);
	epilogue = node(epilogue, cs("L"), n, cs("s."), END_NODE);
}

void
yyerror(char *s)
{
	char	*str, *p;
	int	n;

	if (yyin != NULL && feof(yyin))
		n = asprintf(&str, "%s: %s:%d: %s: unexpected EOF",
		    __progname, filename, lineno, s);
	else if (yytext[0] == '\n')
		n = asprintf(&str,
		    "%s: %s:%d: %s: newline unexpected",
		    __progname, filename, lineno, s);
	else if (isspace((unsigned char)yytext[0]) ||
	    !isprint((unsigned char)yytext[0]))
		n = asprintf(&str,
		    "%s: %s:%d: %s: ascii char 0x%02x unexpected",
		    __progname, filename, lineno, s, yytext[0] & 0xff);
	else
		n = asprintf(&str, "%s: %s:%d: %s: %s unexpected",
		    __progname, filename, lineno, s, yytext);
	if (n == -1)
		err(1, NULL);

	fputs("c[", stdout);
	for (p = str; *p != '\0'; p++) {
		if (*p == '[' || *p == ']' || *p =='\\')
			putchar('\\');
		putchar(*p);
	}
	fputs("]ec\n", stdout);
	free(str);
}

void
fatal(const char *s)
{
	errx(1, "%s:%d: %s", filename, lineno, s);
}

static void
warning(const char *s)
{
	warnx("%s:%d: %s", filename, lineno, s);
}

static void
init(void)
{
	int i;

	for (i = 0; i < UCHAR_MAX; i++) {
		str_table[i][0] = i;
		str_table[i][1] = '\0';
	}
	if (hcreate(1 << 16) == 0)
		err(1, NULL);
}


static __dead void
usage(void)
{
	fprintf(stderr, "usage: %s [-cl] [-e expression] [file ...]\n",
	    __progname);
	exit(1);
}

static char *
escape(const char *str)
{
	char *ret, *p;

	ret = malloc(strlen(str) + 1);
	if (ret == NULL)
		err(1, NULL);

	p = ret;
	while (*str != '\0') {
		/*
		 * We get _escaped_ strings here. Single backslashes are
		 * already converted to double backslashes
		 */
		if (*str == '\\') {
			if (*++str == '\\') {
				switch (*++str) {
				case 'a':
					*p++ = '\a';
					break;
				case 'b':
					*p++ = '\b';
					break;
				case 'f':
					*p++ = '\f';
					break;
				case 'n':
					*p++ = '\n';
					break;
				case 'q':
					*p++ = '"';
					break;
				case 'r':
					*p++ = '\r';
					break;
				case 't':
					*p++ = '\t';
					break;
				case '\\':
					*p++ = '\\';
					break;
				}
				str++;
			} else {
				*p++ = '\\';
				*p++ = *str++;
			}
		} else
			*p++ = *str++;
	}
	*p = '\0';
	return ret;
}

/* ARGSUSED */
static void
sigchld(int signo)
{
	pid_t pid;
	int status, save_errno = errno;

	for (;;) {
		pid = waitpid(dc, &status, WCONTINUED | WNOHANG);
		if (pid == -1) {
			if (errno == EINTR)
				continue;
			_exit(0);
		} else if (pid == 0)
			break;
		if (WIFEXITED(status) || WIFSIGNALED(status))
			_exit(0);
		else
			break;
	}
	errno = save_errno;
}

static const char *
dummy_prompt(void)
{

        return ("");
}

int
main(int argc, char *argv[])
{
	int	i, ch;
	int	p[2];
	char	*q;

	if (pledge("stdio rpath proc tty", NULL) == -1)
		err(1, "pledge");

	init();
	setvbuf(stdout, NULL, _IOLBF, 0);

	sargv = reallocarray(NULL, argc, sizeof(char *));
	if (sargv == NULL)
		err(1, NULL);

	if ((cmdexpr = strdup("")) == NULL)
		err(1, NULL);
	/* The d debug option is 4.4 BSD bc(1) compatible */
	while ((ch = getopt(argc, argv, "cde:l")) != -1) {
		switch (ch) {
		case 'c':
		case 'd':
			do_fork = false;
			break;
		case 'e':
			q = cmdexpr;
			if (asprintf(&cmdexpr, "%s%s\n", cmdexpr, optarg) == -1)
				err(1, NULL);
			free(q);
			break;
		case 'l':
			sargv[sargc++] = _PATH_LIBB;
			break;
		default:
			usage();
		}
	}

	argc -= optind;
	argv += optind;

	interactive = isatty(STDIN_FILENO) && isatty(STDOUT_FILENO) &&
	    isatty(STDERR_FILENO);
	for (i = 0; i < argc; i++)
		sargv[sargc++] = argv[i];

	if (do_fork) {
		if (pipe(p) == -1)
			err(1, "cannot create pipe");
		dc = fork();
		if (dc == -1)
			err(1, "cannot fork");
		else if (dc != 0) {
			signal(SIGCHLD, sigchld);
			close(STDOUT_FILENO);
			dup(p[1]);
			close(p[0]);
			close(p[1]);
		} else {
			char *dc_argv[] = { "dc", "-x", NULL };
			extern int dc_main(int, char **);

			if (pledge("stdio", NULL) == -1)
				err(1, "pledge");

			close(STDIN_FILENO);
			dup(p[0]);
			close(p[0]);
			close(p[1]);

			exit (dc_main(2, dc_argv));
		}
	}
	if (interactive) {
		gettty(&ttysaved);
		el = el_init("bc", stdin, stderr, stderr);
		hist = history_init();
		history(hist, &he, H_SETSIZE, 100);
		el_set(el, EL_HIST, history, hist);
		el_set(el, EL_EDITOR, "emacs");
		el_set(el, EL_SIGNAL, 0);
		el_set(el, EL_PROMPT, dummy_prompt);
		el_set(el, EL_ADDFN, "bc_eof", "", bc_eof);
		el_set(el, EL_BIND, "^D", "bc_eof", NULL);
		el_source(el, NULL);
	}

	if (pledge("stdio rpath tty", NULL) == -1)
		err(1, "pledge");

	yywrap();
	return yyparse();
}
@


1.50
log
@- write parse errors to stderr, prompted by Martijn Dekker
- we're only interactive if stdout en stderr are a tty as well as stdin
@
text
@d2 1
a2 1
/*	$OpenBSD: bc.y,v 1.49 2015/11/23 09:58:55 otto Exp $	*/
d1166 1
a1166 1
			
@


1.49
log
@- fix printing of non-ascii chars in error message
- solve a couple of problems found by Michael McConville using
afl: printing of null nodes, and generating cyclic "trees". These
can only happen on invalid input, afaik.
ok benno@@
@
text
@d2 1
a2 1
/*	$OpenBSD: bc.y,v 1.48 2015/10/10 19:28:54 deraadt Exp $	*/
d972 1
a972 1
	fputs("]pc\n", stdout);
d1138 2
a1139 1
	interactive = isatty(STDIN_FILENO);
@


1.48
log
@Rather than invoking fork/execve of dc(1) on a pipe, compile in the dc(1)
code directly and use it as a subfunction.  This refactoring allows use of
pledge "stdio rpath proc tty" in the main bc(1) process before fork, pledge
"stdio rpath tty" after fork, and fully reduced to "stdio" in the dc(1)
child.

This requires two recent to the kernel code (allowing sigsuspend(),
and kill() self as pid 0).
ok otto
@
text
@d2 1
a2 1
/*	$OpenBSD: bc.y,v 1.47 2014/11/26 18:34:51 millert Exp $	*/
d75 1
a75 1
static void		emit(ssize_t);
d178 1
a178 1
				emit($1);
d806 1
a806 1
emit(ssize_t i)
d808 9
a816 4
	if (instructions[i].index >= 0)
		while (instructions[i].index != END_NODE)
			emit(instructions[i++].index);
	else
d824 1
a824 1
	emit(code);
d959 1
a959 1
		    __progname, filename, lineno, s, yytext[0]);
@


1.47
log
@Prefer setvbuf() to setlinebuf() for portability; ok deraadt@@
@
text
@d2 1
a2 1
/*	$OpenBSD: bc.y,v 1.46 2014/10/14 15:35:18 deraadt Exp $	*/
d1097 3
d1150 6
d1160 2
a1161 2
			execl(_PATH_DC, "dc", "-x", (char *)NULL);
			err(1, "cannot find dc");
d1177 4
@


1.46
log
@obvious use of reallocarray()
@
text
@d2 1
a2 1
/*	$OpenBSD: bc.y,v 1.45 2014/10/08 04:13:33 deraadt Exp $	*/
d1098 1
a1098 1
	setlinebuf(stdout);
@


1.45
log
@reallocarray() to detect integer overflow; ok doug
@
text
@d2 1
a2 1
/*	$OpenBSD: bc.y,v 1.44 2013/11/20 21:33:54 deraadt Exp $	*/
d753 1
a753 1
		p = realloc(instructions, newsize * sizeof(*p));
@


1.44
log
@unsigned char casts for ctype.h macros, when dealing with the
yytext buffer
ok benno
@
text
@d2 1
a2 1
/*	$OpenBSD: bc.y,v 1.43 2013/11/12 13:54:51 deraadt Exp $	*/
d1100 1
a1100 1
	sargv = malloc(argc * sizeof(char *));
@


1.43
log
@simpler prototype repairs
@
text
@d2 1
a2 1
/*	$OpenBSD: bc.y,v 1.42 2013/09/19 16:12:01 otto Exp $	*/
d950 2
a951 1
	else if (isspace(yytext[0]) || !isprint(yytext[0]))
@


1.42
log
@separate termios.h out from scan.l, both have an ECHO define. Noted by
Joris Giovannangeli.
@
text
@d2 1
a2 1
/*	$OpenBSD: bc.y,v 1.41 2012/03/08 08:20:08 otto Exp $	*/
d1060 1
a1060 1
void
@


1.41
log
@allow editline in -d mode; from AIDA Shinra
@
text
@d2 1
a2 1
/*	$OpenBSD: bc.y,v 1.40 2011/10/06 14:37:56 otto Exp $	*/
a43 1
#include <stdbool.h>
a44 1
#include <termios.h>
@


1.40
log
@Better error message on unexpected newline; noted by and ok deraadt@@
@
text
@d2 1
a2 1
/*	$OpenBSD: bc.y,v 1.39 2011/08/03 08:48:19 otto Exp $	*/
a1146 13
			if (interactive) {
				gettty(&ttysaved);
				el = el_init("bc", stdin, stderr, stderr);
				hist = history_init();
				history(hist, &he, H_SETSIZE, 100);
				el_set(el, EL_HIST, history, hist);
				el_set(el, EL_EDITOR, "emacs");
				el_set(el, EL_SIGNAL, 0);
				el_set(el, EL_PROMPT, dummy_prompt);
				el_set(el, EL_ADDFN, "bc_eof", "", bc_eof);
				el_set(el, EL_BIND, "^D", "bc_eof", NULL);
				el_source(el, NULL);
			}
d1155 13
@


1.39
log
@save/restore tty state on SIGTSTP/SIGCONT. ok deraadt@@ nicm@@
@
text
@d2 1
a2 1
/*	$OpenBSD: bc.y,v 1.38 2011/07/08 23:29:46 tedu Exp $	*/
d947 4
@


1.38
log
@el_set with EL_BIND needs sentinel NULL.  with help from nicm
@
text
@d2 1
a2 1
/*	$OpenBSD: bc.y,v 1.37 2011/06/03 06:52:37 deraadt Exp $	*/
d46 1
d1065 1
a1065 1
		pid = waitpid(dc, &status, WCONTINUED);
d1070 2
a1071 1
		}
d1144 1
@


1.37
log
@protect errno from damage in the signal handler
ok otto
@
text
@d2 1
a2 1
/*	$OpenBSD: bc.y,v 1.36 2011/06/03 06:10:31 otto Exp $	*/
d1150 1
a1150 1
				el_set(el, EL_BIND, "^D", "bc_eof");
@


1.36
log
@Make ^D behave: dont't echo it and make it work if the cursor is at
start of line after a ^C;  ok okan@@ deraadt@@
@
text
@d2 1
a2 1
/*	$OpenBSD: bc.y,v 1.35 2011/06/01 07:18:23 otto Exp $	*/
d1061 1
a1061 1
	int status;
d1075 1
@


1.35
log
@- avoid YY_FLUSH_BUFFER: it is not signal safe and it does not work as intended
after the introduction of editline
- honour editline edit off mode
@
text
@d2 1
a2 1
/*	$OpenBSD: bc.y,v 1.34 2011/03/07 08:11:15 otto Exp $	*/
d1148 2
@


1.34
log
@add editline support; from freebsd. ok deraadt@@
@
text
@d2 1
a2 1
/*	$OpenBSD: bc.y,v 1.34 2011/03/07 08:09:25 otto Exp $	*/
d1146 1
a1146 1
				el_set(el, EL_SIGNAL, 1);
@


1.33
log
@rcsid[] and sccsid[] and copyright[] are essentially unmaintained (and
unmaintainable).  these days, people use source.  these id's do not provide
any benefit, and do hurt the small install media
(the 33,000 line diff is essentially mechanical)
ok with the idea millert, ok dms
@
text
@d2 1
a2 1
/*	$OpenBSD: bc.y,v 1.32 2006/05/18 05:49:53 otto Exp $	*/
d39 1
d1077 7
d1140 10
@


1.32
log
@Avoid segv when a syntax error occurs while reading from command line.
found by jmc@@
@
text
@d2 1
a2 1
/*	$OpenBSD: bc.y,v 1.31 2006/04/20 20:00:46 deraadt Exp $	*/
a31 4

#ifndef lint
static const char rcsid[] = "$OpenBSD: bc.y,v 1.31 2006/04/20 20:00:46 deraadt Exp $";
#endif /* not lint */
@


1.31
log
@unused variable
@
text
@d2 1
a2 1
/*	$OpenBSD: bc.y,v 1.30 2006/03/31 09:57:26 otto Exp $	*/
d34 1
a34 1
static const char rcsid[] = "$OpenBSD: bc.y,v 1.30 2006/03/31 09:57:26 otto Exp $";
d947 1
a947 1
	if (feof(yyin))
@


1.30
log
@Better useage string. From Alexey Dobriyan.
@
text
@d2 1
a2 1
/*	$OpenBSD: bc.y,v 1.29 2006/03/18 21:05:50 otto Exp $	*/
d34 1
a34 1
static const char rcsid[] = "$OpenBSD: bc.y,v 1.29 2006/03/18 21:05:50 otto Exp $";
d1083 1
a1083 1
	int	i, ch, ret;
@


1.29
log
@Forgotten part in previous commit; having multiple source trees is a
dangerous hobbby.
@
text
@d2 1
a2 1
/*	$OpenBSD: bc.y,v 1.28 2006/03/18 20:44:43 otto Exp $	*/
d34 1
a34 1
static const char rcsid[] = "$OpenBSD: bc.y,v 1.28 2006/03/18 20:44:43 otto Exp $";
d999 1
a999 1
	fprintf(stderr, "%s: usage: [-cl] [-e expression] [file ...]\n",
@


1.28
log
@Interchange roles: bc becomes parent, dc child. This leads to saner
tty handling (try bc | grep foo followed by ^C, as noted by deraadt@@).
To make it all work, bc now waits for dc to exit after giving it a
quit command.  ok deraadt@@ jaredy@@
@
text
@d2 1
a2 1
/*	$OpenBSD: bc.y,v 1.27 2005/09/18 19:29:41 otto Exp $	*/
d34 1
a34 1
static const char rcsid[] = "$OpenBSD: bc.y,v 1.27 2005/09/18 19:29:41 otto Exp $";
d289 5
a293 2
				sigprocmask(SIG_BLOCK, NULL, &mask);
				sigsuspend(&mask);
@


1.27
log
@Do not check pointer for NULL, but check for return value of asprintf(),
like the man page says.
@
text
@d2 1
a2 1
/*	$OpenBSD: bc.y,v 1.26 2005/05/23 06:44:58 otto Exp $	*/
d34 1
a34 1
static const char rcsid[] = "$OpenBSD: bc.y,v 1.26 2005/05/23 06:44:58 otto Exp $";
d37 3
d42 1
d109 1
d285 2
d289 2
a290 1
				exit(0);
d1056 21
d1117 1
d1124 2
a1125 2
		ret = fork();
		if (ret == -1)
d1127 2
a1128 1
		else if (ret == 0) {
a1141 1
	signal(SIGINT, abort_line);
@


1.26
log
@Fix some pedantic signed vs unsigned warnings. From Michael Knudsen, 10x
@
text
@d2 1
a2 1
/*	$OpenBSD: bc.y,v 1.25 2005/03/17 16:59:31 otto Exp $	*/
d34 1
a34 1
static const char rcsid[] = "$OpenBSD: bc.y,v 1.25 2005/03/17 16:59:31 otto Exp $";
d934 1
d937 1
a937 1
		asprintf(&str, "%s: %s:%d: %s: unexpected EOF",
d940 2
a941 1
		asprintf(&str, "%s: %s:%d: %s: ascii char 0x%02x unexpected",
d944 1
a944 1
		asprintf(&str, "%s: %s:%d: %s: %s unexpected",
d946 1
a946 1
	if (str == NULL)
@


1.25
log
@Fix eof without newline handling. spotted by and ok deraadt@@
@
text
@d2 1
a2 1
/*	$OpenBSD: bc.y,v 1.24 2004/10/19 07:36:51 otto Exp $	*/
d34 1
a34 1
static const char rcsid[] = "$OpenBSD: bc.y,v 1.24 2004/10/19 07:36:51 otto Exp $";
d91 1
a91 1
static size_t		instr_sz = 0;
d742 1
a742 1
	int		newsize;
d820 1
a820 1
	size_t i;
@


1.24
log
@Implement -e expression, for command line expression evaluation.
ok deraadt@@
@
text
@d2 1
a2 1
/*	$OpenBSD: bc.y,v 1.23 2004/02/18 07:43:58 otto Exp $	*/
d34 1
a34 1
static const char rcsid[] = "$OpenBSD: bc.y,v 1.23 2004/02/18 07:43:58 otto Exp $";
d193 4
d935 5
a939 2
	if (isspace(yytext[0]) || !isprint(yytext[0]))
		asprintf(&str, "%s: %s:%d: %s: ascii char 0x%x unexpected",
@


1.23
log
@Rewrite argv processing to not alter argv[] and optind while in the
getopt() loop.
ok deraadt@@
@
text
@d2 1
a2 1
/*	$OpenBSD: bc.y,v 1.22 2004/01/13 08:43:23 otto Exp $	*/
d34 1
a34 1
static const char rcsid[] = "$OpenBSD: bc.y,v 1.22 2004/01/13 08:43:23 otto Exp $";
d65 6
a102 4
static int		fileindex;
static int		sargc;
static char		**sargv;
static char		*filename;
a925 20
int
yywrap(void)
{
	if (fileindex < sargc) {
		filename = sargv[fileindex++];
		yyin = fopen(filename, "r");
		lineno = 1;
		if (yyin == NULL)
			err(1, "cannot open %s", filename);
		return 0;
	} else if (fileindex == sargc) {
		fileindex++;
		yyin = stdin;
		lineno = 1;
		filename = "stdin";
		return 0;
	}
	return 1;
}

d979 2
a980 1
	fprintf(stderr, "%s: usage: [-cl] [file ...]\n", __progname);
d1044 1
d1053 4
a1056 2
	/* The d debug option is 4.4 BSD dc(1) compatible */
	while ((ch = getopt(argc, argv, "cdl")) != -1) {
d1061 6
@


1.22
log
@Missing cast. From deraadt@@
@
text
@d2 1
a2 1
/*	$OpenBSD: bc.y,v 1.21 2003/12/19 19:24:22 otto Exp $	*/
d34 1
a34 1
static const char rcsid[] = "$OpenBSD: bc.y,v 1.21 2003/12/19 19:24:22 otto Exp $";
d97 1
d927 2
a928 2
	if (optind < sargc) {
		filename = sargv[optind++];
d934 2
a935 2
	} else if (optind == sargc) {
		optind++;
d1059 1
a1059 1
	int	ch, ret;
d1065 4
d1077 1
a1077 2
			argv[1] = _PATH_LIBB;
			optind = 1;
d1084 5
a1088 2
	sargc = argc;
	sargv = argv;
@


1.21
log
@Pass SIGINT to dc process.
@
text
@d2 1
a2 1
/*	$OpenBSD: bc.y,v 1.20 2003/12/02 09:00:07 otto Exp $	*/
d34 1
a34 1
static const char rcsid[] = "$OpenBSD: bc.y,v 1.20 2003/12/02 09:00:07 otto Exp $";
d862 1
a862 1
		entry.data = p;
@


1.20
log
@o Introduce long variable names, a non-portable extension.
o Make main program target left recursive. Reduces parse stack usage, making
  it possible to compile programs > 10000 lines.
@
text
@d2 1
a2 1
/*	$OpenBSD: bc.y,v 1.19 2003/11/17 11:20:13 otto Exp $	*/
d34 1
a34 1
static const char rcsid[] = "$OpenBSD: bc.y,v 1.19 2003/11/17 11:20:13 otto Exp $";
a1094 1
			signal(SIGINT, SIG_IGN);
@


1.19
log
@Implement non-portable extensions:
o boolean operators !, && and ||.
o allow relational operators to appear in any expression, not just
  conditional expressions.
@
text
@d2 1
a2 1
/*	$OpenBSD: bc.y,v 1.18 2003/11/13 19:42:21 otto Exp $	*/
d34 1
a34 1
static const char rcsid[] = "$OpenBSD: bc.y,v 1.18 2003/11/13 19:42:21 otto Exp $";
d40 1
d73 5
d101 1
d107 1
a107 1
/* These values are 4.4BSD dc compatible */
d111 4
a114 3
#define LETTER_NODE(str)	(cs(str_table[(int)str[0]]))
#define ARRAY_NODE(str)		(cs(str_table[(int)str[0] - 'a' + ARRAY_CHAR]))
#define FUNCTION_NODE(str)	(cs(str_table[(int)str[0] - 'a' + FUNC_CHAR]))
d124 1
d129 2
a130 1
%token <str> LETTER NUMBER STRING
d169 1
a169 6
			{
				putchar('q');
				fflush(stdout);
				exit(0);
			}
		| input_item program
d350 1
a350 1
				else if (macro_char == 256)
d380 2
a381 1
				$$ = FUNCTION_NODE($2);
d402 2
a403 1
				add_par(LETTER_NODE($1));
d407 2
a408 1
				add_par(ARRAY_NODE($1));
d412 2
a413 1
				add_par(LETTER_NODE($3));
d417 2
a418 1
				add_par(ARRAY_NODE($3));
d433 2
a434 1
				add_local(LETTER_NODE($1));
d438 2
a439 1
				add_local(ARRAY_NODE($1));
d443 2
a444 1
				add_local(LETTER_NODE($3));
d448 2
a449 1
				add_local(ARRAY_NODE($3));
d470 1
a470 1
				$$ = node($1, cs("l"), ARRAY_NODE($3),
d472 1
d560 1
a560 1
				    FUNCTION_NODE($1), cs("x"),
d562 1
d679 1
a679 1
				$$.load = node(cs("l"), LETTER_NODE($1),
d681 1
a681 1
				$$.store = node(cs("s"), LETTER_NODE($1),
d683 1
d688 1
a688 1
				    ARRAY_NODE($1), END_NODE);
d690 2
a691 1
				    ARRAY_NODE($1), END_NODE);
d831 1
a831 1
		err(1, "internal error: break num > 15");
d835 74
d988 2
d1100 1
a1100 1
			execl(_PATH_DC, "dc", "-", (char *)NULL);
@


1.18
log
@When using print, do not leave garbage on the dc stack.
@
text
@d2 1
a2 1
/*	$OpenBSD: bc.y,v 1.17 2003/11/13 19:05:32 otto Exp $	*/
d34 1
a34 1
static const char rcsid[] = "$OpenBSD: bc.y,v 1.17 2003/11/13 19:05:32 otto Exp $";
d126 3
d470 1
a470 5
		: expression
			{
				$$ = node($1, cs(" 0!="), END_NODE);
			}
		| expression EQUALS expression
d494 4
d617 40
@


1.17
log
@Exponentiation operatator ^ is right associative.
@
text
@d2 1
a2 1
/*	$OpenBSD: bc.y,v 1.16 2003/11/11 19:49:02 otto Exp $	*/
d34 1
a34 1
static const char rcsid[] = "$OpenBSD: bc.y,v 1.16 2003/11/11 19:49:02 otto Exp $";
d659 1
a659 1
				$$ = node($1, cs("dds.n"), END_NODE);
d664 1
a664 2
				$$ = node(cs("["), as(p), cs("]dn"),
				    END_NODE);
@


1.16
log
@Some syntactic sugar (all non-portable extensions):
- a line comment, starting with #
- opening brace of define statement may be on next line
- return expression, equivalent to return (expression)
@
text
@d2 1
a2 1
/*	$OpenBSD: bc.y,v 1.15 2003/11/11 09:15:36 otto Exp $	*/
d34 1
a34 1
static const char rcsid[] = "$OpenBSD: bc.y,v 1.15 2003/11/11 09:15:36 otto Exp $";
d130 1
a130 1
%left EXPONENT
@


1.15
log
@Implement `print' statement, a non-portable extension.
@
text
@d2 1
a2 1
/*	$OpenBSD: bc.y,v 1.14 2003/10/22 12:24:41 otto Exp $	*/
d34 1
a34 1
static const char rcsid[] = "$OpenBSD: bc.y,v 1.14 2003/10/22 12:24:41 otto Exp $";
d269 1
a269 1
		| RETURN
d275 1
a275 10
				$$ = node(cs("0"), epilogue,
				    numnode(nesting), cs("Q"), END_NODE);
			}
		| RETURN LPAR return_expression RPAR
			{
				if (nesting == 0) {
					warning("return must be in a function");
					YYERROR;
				}
				$$ = $3;
d356 1
a356 1
function	: function_header opt_parameter_list RPAR
d360 1
a360 1
				int n = node(prologue, $7, epilogue,
d381 4
d507 5
@


1.14
log
@Implement if ... else statement. If you do not use 'else', code generated
is still classic dc(1) compatible. If you do use 'else', you'll need a dc(1)
that implements the new extended comparison operators like '=xey'.
@
text
@d2 1
a2 1
/*	$OpenBSD: bc.y,v 1.13 2003/10/19 19:21:48 otto Exp $	*/
d34 1
a34 1
static const char rcsid[] = "$OpenBSD: bc.y,v 1.13 2003/10/19 19:21:48 otto Exp $";
d77 1
d124 1
a124 1
%token CONTINUE ELSE
d145 2
d333 4
d648 20
d864 54
@


1.13
log
@Allow the expressions in for (E ; E ; E ) to be empty.
@
text
@d2 1
a2 1
/*	$OpenBSD: bc.y,v 1.12 2003/10/18 20:35:36 otto Exp $	*/
d34 1
a34 1
static const char rcsid[] = "$OpenBSD: bc.y,v 1.12 2003/10/18 20:35:36 otto Exp $";
d305 8
@


1.12
log
@err(1, "cannot allocate mem") -> err(1, NULL)
@
text
@d2 1
a2 1
/*	$OpenBSD: bc.y,v 1.11 2003/10/18 19:57:10 otto Exp $	*/
d34 1
a34 1
static const char rcsid[] = "$OpenBSD: bc.y,v 1.11 2003/10/18 19:57:10 otto Exp $";
d141 2
d283 3
a285 3
		| FOR LPAR alloc_macro expression SEMICOLON
		     relational_expression SEMICOLON
		     expression RPAR opt_statement pop_nesting
d448 7
d501 7
@


1.11
log
@o Fix assignment operators (+=, -=, ... )
o Implement "continue" in loops. If continue is not used, generated code is
  still "classic" dc(1) compatible. If continue is used, you'll need a dc(1)
  that implements the J and M operators.
@
text
@d2 1
a2 1
/*	$OpenBSD: bc.y,v 1.10 2003/09/30 18:46:11 otto Exp $	*/
d34 1
a34 1
static const char rcsid[] = "$OpenBSD: bc.y,v 1.10 2003/09/30 18:46:11 otto Exp $";
d631 1
a631 1
			err(1, "cannot realloc instruction buffer");
d654 1
a654 1
		err(1, "cannot allocate string");
d770 1
a770 1
		err(1, "cannot allocate string");
@


1.10
log
@Make sure strings and error messages sent to dc(1) properly escape [, ] and \.
@
text
@d2 1
a2 1
/*	$OpenBSD: bc.y,v 1.9 2003/09/29 03:24:27 otto Exp $	*/
d34 1
a34 1
static const char rcsid[] = "$OpenBSD: bc.y,v 1.9 2003/09/29 03:24:27 otto Exp $";
d88 1
d123 1
d165 1
d171 1
d222 6
a227 1
				$$ = node($3, cs($2), $1.store, END_NODE);
d246 12
d285 9
a293 2
				int n = node($10, $8, cs("s."), $6, $3,
				    END_NODE);
d307 6
a312 1
				int n = node($6, $4, $3, END_NODE);
d340 2
d346 1
d371 1
d565 6
a570 2
				$$ = node($3, cs($2), cs("d"),
				    $1.store, END_NODE);
@


1.9
log
@Implement (undocumented) dot shorthand, which was missing.
Spotted by millert@@.
@
text
@d2 1
a2 1
/*	$OpenBSD: bc.y,v 1.8 2003/09/28 07:57:57 otto Exp $	*/
d34 1
a34 1
static const char rcsid[] = "$OpenBSD: bc.y,v 1.8 2003/09/28 07:57:57 otto Exp $";
d720 5
a724 3
	if (isspace(*yytext) || !isprint(*yytext))
		printf("c[%s: %s:%d: %s: ascii char 0x%x unexpected]pc\n",
		    __progname, filename, lineno, s, *yytext);
d726 1
a726 1
		printf("c[%s: %s:%d: %s: %s unexpected]pc\n",
d728 11
@


1.8
log
@Better error hanndling:
- skip current line on syntax error
- detect EOF in strings and comments
- report correct line number in above case
- more consistent warning and errors

ok henning@@
@
text
@d2 1
a2 1
/*	$OpenBSD: bc.y,v 1.7 2003/09/28 07:45:55 otto Exp $	*/
d34 1
a34 1
static const char rcsid[] = "$OpenBSD: bc.y,v 1.7 2003/09/28 07:45:55 otto Exp $";
d116 2
a117 2
%token COMMA SEMICOLON LPAR RPAR LBRACE RBRACE LBRACKET RBRACKET
%token ENDOFFILE NEWLINE
d459 3
@


1.7
log
@Fix function return types. Unbreaks sparc64 compilation. Spotted by
sturm@@.

ok deraadt@@ sturm@@ henning@@
@
text
@d2 1
a2 1
/*	$OpenBSD: bc.y,v 1.6 2003/09/26 19:26:16 deraadt Exp $	*/
d34 1
a34 1
static const char rcsid[] = "$OpenBSD: bc.y,v 1.6 2003/09/26 19:26:16 deraadt Exp $";
a62 1
void			yyerror(char *);
a73 1
static void		fatal(const char *);
d169 1
a169 1
		| error
d171 1
d246 1
a246 1
					warnx("return must be in a function");
d255 1
a255 1
					warnx("return must be in a function");
a696 1
	lineno = 1;
d700 1
d707 1
d718 2
a719 2
		printf("c[%s:%d: %s: ascii char 0x%x unexpected]pc\n",
		    filename, lineno, s, *yytext);
d721 2
a722 2
		printf("c[%s:%d: %s: %s unexpected]pc\n",
		    filename, lineno, s, yytext);
d725 1
a725 1
static void
@


1.6
log
@minor tweaks as i fail to find real bugs
@
text
@d2 1
a2 1
/*	$OpenBSD: bc.y,v 1.5 2003/09/26 19:06:46 deraadt Exp $	*/
d34 1
a34 1
static const char rcsid[] = "$OpenBSD: bc.y,v 1.5 2003/09/26 19:06:46 deraadt Exp $";
d82 1
a82 1
static size_t		current = 0;
d595 1
a595 1
static int
d604 1
a604 1
static int
@


1.5
log
@incorrect indent
@
text
@d2 1
a2 1
/*	$OpenBSD: bc.y,v 1.4 2003/09/26 19:05:56 deraadt Exp $	*/
d34 1
a34 1
static const char rcsid[] = "$OpenBSD: bc.y,v 1.4 2003/09/26 19:05:56 deraadt Exp $";
d705 1
a705 2
	}
	else if (optind == sargc) {
d796 1
a796 2
		}
		else {
@


1.4
log
@make usage match man page
@
text
@d2 1
a2 1
/*	$OpenBSD: bc.y,v 1.3 2003/09/26 19:00:38 deraadt Exp $	*/
d34 1
a34 1
static const char rcsid[] = "$OpenBSD: bc.y,v 1.3 2003/09/26 19:00:38 deraadt Exp $";
d779 1
a779 1
		usage();
@


1.3
log
@spacing
@
text
@d2 1
a2 1
/*	$OpenBSD: bc.y,v 1.2 2003/09/26 07:23:06 otto Exp $	*/
d34 1
a34 1
static const char rcsid[] = "$OpenBSD: bc.y,v 1.2 2003/09/26 07:23:06 otto Exp $";
d753 1
a753 1
	fprintf(stderr, "%s: usage: [-c] [-l] [file ...]\n", __progname);
@


1.2
log
@Check strdup() return value, as pointed out by deraadt@@
@
text
@d2 1
a2 1
/*	$OpenBSD: bc.y,v 1.1 2003/09/25 19:32:44 otto Exp $	*/
d34 1
a34 1
static const char rcsid[] = "$OpenBSD: bc.y,v 1.1 2003/09/25 19:32:44 otto Exp $";
d406 1
a406 1
					  END_NODE);
@


1.1
log
@A new, BSD licensed implementation of bc(1).

ok deraadt@@
@
text
@d2 1
a2 1
/*	$OpenBSD$	*/
d34 1
a34 1
static const char rcsid[] = "$OpenBSD$";
d610 2
@

