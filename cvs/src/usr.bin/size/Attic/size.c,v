head	1.21;
access;
symbols
	OPENBSD_3_4:1.19.0.2
	OPENBSD_3_4_BASE:1.19
	OPENBSD_3_3:1.14.0.6
	OPENBSD_3_3_BASE:1.14
	OPENBSD_3_2:1.14.0.4
	OPENBSD_3_2_BASE:1.14
	OPENBSD_3_1:1.14.0.2
	OPENBSD_3_1_BASE:1.14
	OPENBSD_3_0:1.13.0.2
	OPENBSD_3_0_BASE:1.13
	OPENBSD_2_9_BASE:1.11
	OPENBSD_2_9:1.11.0.8
	OPENBSD_2_8:1.11.0.6
	OPENBSD_2_8_BASE:1.11
	OPENBSD_2_7:1.11.0.4
	OPENBSD_2_7_BASE:1.11
	OPENBSD_2_6:1.11.0.2
	OPENBSD_2_6_BASE:1.11
	OPENBSD_2_5:1.10.0.4
	OPENBSD_2_5_BASE:1.10
	OPENBSD_2_4:1.10.0.2
	OPENBSD_2_4_BASE:1.10
	OPENBSD_2_3:1.8.0.4
	OPENBSD_2_3_BASE:1.8
	OPENBSD_2_2:1.8.0.2
	OPENBSD_2_2_BASE:1.8
	OPENBSD_2_1:1.6.0.2
	OPENBSD_2_1_BASE:1.6
	OPENBSD_2_0:1.4.0.2
	OPENBSD_2_0_BASE:1.4
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.21
date	2004.01.05.01.27.22;	author mickey;	state dead;
branches;
next	1.20;

1.20
date	2003.09.30.19.00.14;	author mickey;	state Exp;
branches;
next	1.19;

1.19
date	2003.06.10.22.20.51;	author deraadt;	state Exp;
branches;
next	1.18;

1.18
date	2003.06.03.02.56.16;	author millert;	state Exp;
branches;
next	1.17;

1.17
date	2003.04.15.15.54.07;	author deraadt;	state Exp;
branches;
next	1.16;

1.16
date	2003.04.08.00.53.55;	author deraadt;	state Exp;
branches;
next	1.15;

1.15
date	2003.03.30.20.47.15;	author deraadt;	state Exp;
branches;
next	1.14;

1.14
date	2002.02.16.21.27.52;	author millert;	state Exp;
branches;
next	1.13;

1.13
date	2001.07.18.17.17.39;	author pvalchev;	state Exp;
branches;
next	1.12;

1.12
date	2001.05.31.16.26.59;	author smart;	state Exp;
branches;
next	1.11;

1.11
date	99.05.10.16.14.07;	author espie;	state Exp;
branches;
next	1.10;

1.10
date	98.05.11.20.20.55;	author niklas;	state Exp;
branches;
next	1.9;

1.9
date	98.05.11.07.40.31;	author niklas;	state Exp;
branches;
next	1.8;

1.8
date	97.09.11.11.21.52;	author deraadt;	state Exp;
branches;
next	1.7;

1.7
date	97.08.23.01.59.21;	author mickey;	state Exp;
branches;
next	1.6;

1.6
date	97.01.28.07.12.27;	author deraadt;	state Exp;
branches;
next	1.5;

1.5
date	97.01.15.23.43.13;	author millert;	state Exp;
branches;
next	1.4;

1.4
date	96.09.03.11.16.47;	author deraadt;	state Exp;
branches;
next	1.3;

1.3
date	96.06.26.05.39.18;	author deraadt;	state Exp;
branches;
next	1.2;

1.2
date	96.01.15.20.12.16;	author deraadt;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.46.07;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.46.07;	author deraadt;	state Exp;
branches;
next	;


desc
@@


1.21
log
@nm digs elf and merges w/ size; millert@@ ok
@
text
@/*	$OpenBSD: size.c,v 1.20 2003/09/30 19:00:14 mickey Exp $	*/
/*	$NetBSD: size.c,v 1.7 1996/01/14 23:07:12 pk Exp $	*/

/*
 * Copyright (c) 1988, 1993
 *	The Regents of the University of California.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */

#ifndef lint
static const char copyright[] =
"@@(#) Copyright (c) 1988, 1993\n\
	The Regents of the University of California.  All rights reserved.\n";
#endif /* not lint */

#ifndef lint
#if 0
static char sccsid[] = "@@(#)size.c	8.2 (Berkeley) 12/9/93";
#endif
static const char rcsid[] = "$OpenBSD: size.c,v 1.20 2003/09/30 19:00:14 mickey Exp $";
#endif /* not lint */

#include <sys/param.h>
#include <sys/file.h>
#include <elf_abi.h>
#include <a.out.h>
#include <ar.h>
#include <ranlib.h>
#include <unistd.h>
#include <stdlib.h>
#include <stdio.h>
#include <string.h>
#include <ctype.h>
#include <err.h>
#include "byte.c"

#ifdef MID_MACHINE_OVERRIDE
#undef MID_MACHINE
#define MID_MACHINE MID_MACHINE_OVERRIDE
#endif

#define	STRTABMAG	"//"

union hdr {
	struct exec aout;
	Elf_Ehdr elf;
};

unsigned long total_text, total_data, total_bss, total_total;
int non_object_warning, print_totals;

int	process_file(int, char *);
int	show_archive(int, char *, FILE *);
int	show_file(int, int, char *, FILE *, off_t, union hdr *);
void	usage(void);

int
main(int argc, char *argv[])
{
	int ch, eval;

	while ((ch = getopt(argc, argv, "wt")) != -1)
		switch(ch) {
		case 'w':
			non_object_warning = 1;
			break;
		case 't':
			print_totals = 1;
			break;
		case '?':
		default:
			usage();
		}
	argc -= optind;
	argv += optind;

	eval = 0;
	if (*argv)
		do {
			eval |= process_file(argc, *argv);
		} while (*++argv);
	else
		eval |= process_file(1, "a.out");

	if (print_totals)
		(void)printf("\n%lu\t%lu\t%lu\t%lu\t%lx\tTOTAL\n",
		    total_text, total_data, total_bss,
		    total_total, total_total);
	exit(eval);
}

/*
 * process_file()
 *	show symbols in the file given as an argument.  Accepts archive and
 *	object files as input.
 */
int
process_file(int count, char *fname)
{
	union hdr exec_head;
	FILE *fp;
	int retval;
	char magic[SARMAG];

	if (!(fp = fopen(fname, "r"))) {
		warnx("cannot read %s", fname);
		return(1);
	}

	/*
	 * first check whether this is an object file - read a object
	 * header, and skip back to the beginning
	 */
	if (fread((char *)&exec_head, sizeof(exec_head), (size_t)1, fp) != 1) {
		warnx("%s: bad format", fname);
		(void)fclose(fp);
		return(1);
	}
	rewind(fp);

	/* this could be an archive */
	if (!IS_ELF(exec_head.elf) && N_BADMAG(exec_head.aout)) {
		if (fread(magic, sizeof(magic), (size_t)1, fp) != 1 ||
		    strncmp(magic, ARMAG, SARMAG)) {
			warnx("%s: not object file or archive", fname);
			(void)fclose(fp);
			return(1);
		}
		retval = show_archive(count, fname, fp);
	} else
		retval = show_file(count, 1, fname, fp, 0, &exec_head);
	(void)fclose(fp);
	return(retval);
}

/*
 * show_archive()
 *	show symbols in the given archive file
 */
int
show_archive(int count, char *fname, FILE *fp)
{
	struct ar_hdr ar_head;
	union hdr exec_head;
	int i, rval;
	off_t last_ar_off, foff;
	char *p, *name, *strtab;
	int baselen, namelen;

	baselen = strlen(fname) + 3;
	namelen = sizeof(ar_head.ar_name);
	if ((name = malloc(baselen + namelen)) == NULL)
		err(1, NULL);

	rval = 0;
	strtab = NULL;

	/* while there are more entries in the archive */
	while (fread((char *)&ar_head, sizeof(ar_head), (size_t)1, fp) == 1) {
		/* bad archive entry - stop processing this archive */
		if (strncmp(ar_head.ar_fmag, ARFMAG, sizeof(ar_head.ar_fmag))) {
			warnx("%s: bad format archive header", fname);
			free(name);
			free(strtab);
			return(1);
		}

		/* remember start position of current archive object */
		last_ar_off = ftello(fp);

		/* skip ranlib entries */
		if (!strncmp(ar_head.ar_name, RANLIBMAG, sizeof(RANLIBMAG) - 1))
			goto skip;

		/* load the Sys5 long names table */
		if (!strncmp(ar_head.ar_name, STRTABMAG,
		    sizeof(STRTABMAG) - 1)) {

			i = atol(ar_head.ar_size);
			if ((strtab = malloc(i)) == NULL) {
				warn("%s: strtab", name);
				free(name);
				return(1);
			}

			if (fread(strtab, i, (size_t)1, fp) != 1) {
				warnx("%s: premature EOF", name);
				free(strtab);
				free(name);
				return(1);
			}

			for (p = strtab; i--; p++)
				if (*p == '\n')
					*p = '\0';
			goto skip;
		}

		/*
		 * construct a name of the form "archive.a:obj.o:" for the
		 * current archive entry if the object name is to be printed
		 * on each output line
		 */
		p = name;
		if (count > 1) {
			snprintf(name, baselen - 1, "%s:", fname);
			p += strlen(name);
		}

		if (strtab && ar_head.ar_name[0] == '/') {
			int len;

			i = atol(&ar_head.ar_name[1]);
			len = strlen(&strtab[i]);
			if (len > namelen) {
				p -= (long)name;
				if ((name = realloc(name, baselen+len)) == NULL)
					err(1, NULL);
				namelen = len;
				p += (long)name;
			}
			strlcpy(p, &strtab[i], len);
			p += len;
		} else
#ifdef AR_EFMT1
		/*
		 * BSD 4.4 extended AR format: #1/<namelen>, with name as the
		 * first <namelen> bytes of the file
		 */
		if ((ar_head.ar_name[0] == '#') &&
		    (ar_head.ar_name[1] == '1') &&
		    (ar_head.ar_name[2] == '/') && 
		    (isdigit(ar_head.ar_name[3]))) {
			int len = atoi(&ar_head.ar_name[3]);

			if (len > namelen) {
				p -= (long)name;
				if ((name = realloc(name, baselen+len)) == NULL)
					err(1, NULL);
				namelen = len;
				p += (long)name;
			}
			if (fread(p, len, 1, fp) != 1) {
				warnx("%s: premature EOF", name);
				free(name);
				return(1);
			}
			p += len;
		} else
#endif
		for (i = 0; i < sizeof(ar_head.ar_name); ++i)
			if (ar_head.ar_name[i] && ar_head.ar_name[i] != ' ')
				*p++ = ar_head.ar_name[i];
		*p = '\0';
		if (p[-1] == '/')
			*--p = '\0';

		foff = ftello(fp);

		/* get and check current object's header */
		if (fread((char *)&exec_head, sizeof(exec_head),
		    (size_t)1, fp) != 1) {
			warnx("%s: premature EOF", name);
			free(name);
			return(1);
		}

		rval |= show_file(2, non_object_warning, name, fp, foff, &exec_head);
		/*
		 * skip to next archive object - it starts at the next
	 	 * even byte boundary
		 */
#define even(x) (((x) + 1) & ~1)
skip:		if (fseeko(fp, last_ar_off + even(atol(ar_head.ar_size)),
		    SEEK_SET)) {
			warn("%s", fname);
			free(name);
			return(1);
		}
	}
	free(name);
	return(rval);
}

int
show_file(int count, int warn_fmt, char *name, FILE *fp, off_t foff, union hdr *head)
{
	static int first = 1;
	Elf_Shdr *shdr;
	u_long text, data, bss, total;
	int i;

	if (IS_ELF(head->elf) &&
	    head->elf.e_ident[EI_CLASS] == ELF_TARG_CLASS &&
	    head->elf.e_ident[EI_DATA] == ELF_TARG_DATA &&
	    head->elf.e_ident[EI_VERSION] == ELF_TARG_VER &&
	    head->elf.e_machine == ELF_TARG_MACH &&
	    head->elf.e_version == ELF_TARG_VER) {

		if ((shdr = malloc(head->elf.e_shentsize *
		    head->elf.e_shnum)) == NULL) {
			warn("%s: malloc shdr", name);
			return (1);
		}

		if (fseeko(fp, foff + head->elf.e_shoff, SEEK_SET)) {
			warn("%s: fseeko", name);
			free(shdr);
			return (1);
		}

		if (fread(shdr, head->elf.e_shentsize, head->elf.e_shnum,
		    fp) != head->elf.e_shnum) {
			warnx("%s: premature EOF", name);
			free(shdr);
			return(1);
		}

		text = data = bss = 0;
		for (i = 0; i < head->elf.e_shnum; i++) {
			if (!(shdr[i].sh_flags & SHF_ALLOC))
				;
			else if (shdr[i].sh_flags & SHF_EXECINSTR ||
			    !(shdr[i].sh_flags & SHF_WRITE))
				text += shdr[i].sh_size;
			else if (shdr[i].sh_type == SHT_NOBITS)
				bss += shdr[i].sh_size;
			else
				data += shdr[i].sh_size;
		}
		free(shdr);

	} else if (BAD_OBJECT(head->aout)) {
		if (warn_fmt)
			warnx("%s: bad format", name);
		return (1);
	} else {
		fix_header_order(&head->aout);

		text = head->aout.a_text;
		data = head->aout.a_data;
		bss = head->aout.a_bss;
	}

	if (first) {
		first = 0;
		(void)printf("text\tdata\tbss\tdec\thex\n");
	}

	total = text + data + bss;
	(void)printf("%lu\t%lu\t%lu\t%lu\t%lx", text, data, bss, total, total);
	if (count > 1)
		(void)printf("\t%s", name);

	total_text += text;
	total_data += data;
	total_bss += bss;
	total_total += total;

	(void)printf("\n");
	return (0);
}

void
usage(void)
{
	(void)fprintf(stderr, "usage: size [-tw] [file ...]\n");
	exit(1);
}
@


1.20
log
@parse elf now; help from millert
@
text
@d1 1
a1 1
/*	$OpenBSD: size.c,v 1.19 2003/06/10 22:20:51 deraadt Exp $	*/
d43 1
a43 1
static const char rcsid[] = "$OpenBSD: size.c,v 1.19 2003/06/10 22:20:51 deraadt Exp $";
@


1.19
log
@mostly ansi cleanup; pval ok
@
text
@d1 1
a1 1
/*	$OpenBSD: size.c,v 1.18 2003/06/03 02:56:16 millert Exp $	*/
d34 1
a34 1
static char copyright[] =
d43 1
a43 1
static char rcsid[] = "$OpenBSD: size.c,v 1.18 2003/06/03 02:56:16 millert Exp $";
d48 1
d65 7
d73 1
a73 2
int ignore_bad_archive_entries = 1;
int print_totals = 0;
d77 1
a77 1
int	show_objfile(int, char *, FILE *);
d88 1
a88 1
			ignore_bad_archive_entries = 0;
d123 1
a123 1
	struct exec exec_head;
d145 1
a145 1
	if (N_BADMAG(exec_head)) {
d154 1
a154 1
		retval = show_objfile(count, fname, fp);
d167 1
a167 1
	struct exec exec_head;
d169 2
a170 2
	long last_ar_off;
	char *p, *name;
d179 1
d186 2
a187 1
			(void)free(name);
d192 1
a192 1
		last_ar_off = ftell(fp);
d198 24
d232 16
d268 1
a268 1
				(void)free(name);
d277 5
a281 1
		*p++ = '\0';
d287 1
a287 1
			(void)free(name);
d291 1
a291 11
		if (BAD_OBJECT(exec_head)) {
			if (!ignore_bad_archive_entries) {
				warnx("%s: bad format", name);
				rval = 1;
			}
		} else {
			(void)fseek(fp, (long)-sizeof(exec_head),
			    SEEK_CUR);
			rval |= show_objfile(2, name, fp);
		}

d297 1
a297 1
skip:		if (fseek(fp, last_ar_off + even(atol(ar_head.ar_size)),
d300 1
a300 1
			(void)free(name);
d304 1
a304 1
	(void)free(name);
d309 1
a309 1
show_objfile(int count, char *name, FILE *fp)
d312 22
a333 2
	struct exec head;
	u_long total;
d335 20
a354 4
	if (fread((char *)&head, sizeof(head), (size_t)1, fp) != 1) {
		warnx("%s: cannot read header", name);
		return(1);
	}
d356 10
a365 3
	if (BAD_OBJECT(head)) {
		warnx("%s: bad format", name);
		return(1);
a367 2
	fix_header_order(&head);

d372 3
a374 3
	total = head.a_text + head.a_data + head.a_bss;
	(void)printf("%lu\t%lu\t%lu\t%lu\t%lx", (unsigned long)head.a_text, 
	    (unsigned long)head.a_data, (unsigned long)head.a_bss, total, total);
d378 3
a380 3
	total_text += head.a_text;
	total_data += head.a_data;
	total_bss += head.a_bss;
@


1.18
log
@Remove the advertising clause in the UCB license which Berkeley
rescinded 22 July 1999.  Proofed by myself and Theo.
@
text
@d1 1
a1 1
/*	$OpenBSD: size.c,v 1.17 2003/04/15 15:54:07 deraadt Exp $	*/
d43 1
a43 1
static char rcsid[] = "$OpenBSD: size.c,v 1.17 2003/04/15 15:54:07 deraadt Exp $";
d74 1
a74 3
main(argc, argv)
	int argc;
	char *argv[];
d114 1
a114 3
process_file(count, fname)
	int count;
	char *fname;
d157 1
a157 4
show_archive(count, fname, fp)
	int count;
	char *fname;
	FILE *fp;
d266 1
a266 4
show_objfile(count, name, fp)
	int count;
	char *name;
	FILE *fp;
d304 1
a304 1
usage()
@


1.17
log
@kill a += snprintf
@
text
@d1 1
a1 1
/*	$OpenBSD: size.c,v 1.16 2003/04/08 00:53:55 deraadt Exp $	*/
d16 1
a16 5
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
d43 1
a43 1
static char rcsid[] = "$OpenBSD: size.c,v 1.16 2003/04/08 00:53:55 deraadt Exp $";
@


1.16
log
@snprintf; ok tdeval
@
text
@d1 1
a1 1
/*	$OpenBSD: size.c,v 1.15 2003/03/30 20:47:15 deraadt Exp $	*/
d47 1
a47 1
static char rcsid[] = "$OpenBSD: size.c,v 1.15 2003/03/30 20:47:15 deraadt Exp $";
d206 4
a209 2
		if (count > 1)
			p += snprintf(name, baselen - 1, "%s:", fname);
@


1.15
log
@knf
@
text
@d1 1
a1 1
/*	$OpenBSD: size.c,v 1.14 2002/02/16 21:27:52 millert Exp $	*/
d47 1
a47 1
static char rcsid[] = "$OpenBSD: size.c,v 1.14 2002/02/16 21:27:52 millert Exp $";
d207 1
a207 1
			p += sprintf(p, "%s:", fname);
@


1.14
log
@Part one of userland __P removal.  Done with a simple regexp with some minor hand editing to make comments line up correctly.  Another pass is forthcoming that handles the cases that could not be done automatically.
@
text
@d1 1
a1 1
/*	$OpenBSD: size.c,v 1.13 2001/07/18 17:17:39 pvalchev Exp $	*/
d47 1
a47 1
static char rcsid[] = "$OpenBSD: size.c,v 1.13 2001/07/18 17:17:39 pvalchev Exp $";
d213 5
a217 4
		if (		(ar_head.ar_name[0] == '#') &&
				(ar_head.ar_name[1] == '1') &&
				(ar_head.ar_name[2] == '/') && 
				(isdigit(ar_head.ar_name[3]))) {
a218 1
			int len = atoi(&ar_head.ar_name[3]);
@


1.13
log
@-Wall cleanup
@
text
@d1 1
a1 1
/*	$OpenBSD: size.c,v 1.12 2001/05/31 16:26:59 smart Exp $	*/
d47 1
a47 1
static char rcsid[] = "$OpenBSD: size.c,v 1.12 2001/05/31 16:26:59 smart Exp $";
d72 4
a75 4
int	process_file __P((int, char *));
int	show_archive __P((int, char *, FILE *));
int	show_objfile __P((int, char *, FILE *));
void	usage __P((void));
@


1.12
log
@- remove emalloc() and erealloc() wrapper functions that are only used once
- standard function prototypes
- replace an fprintf(stderr,...) with a warnx()

Shrinks source by 25 lines and executable by 43 bytes on i386.  deraadt@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: size.c,v 1.11 1999/05/10 16:14:07 espie Exp $	*/
d47 1
a47 1
static char rcsid[] = "$OpenBSD: size.c,v 1.11 1999/05/10 16:14:07 espie Exp $";
d301 2
a302 2
	(void)printf("%lu\t%lu\t%lu\t%lu\t%lx", head.a_text, head.a_data,
	    head.a_bss, total, total);
@


1.11
log
@Fixes endianess problems with old a.out tools. This makes building
some cross toolchains possible.

This also changes some utilities's behavior slightly:
- nm, strip, size now handle any a.out format they know about.
- ranlib complains if it detects mixed archives (several object
formats for different boxes).

In the presence of mixed objects, you still have file, ranlib or ld
to prevent you from getting too confused...
@
text
@d1 1
a1 1
/*	$OpenBSD: size.c,v 1.10 1998/05/11 20:20:55 niklas Exp $	*/
d47 1
a47 1
static char rcsid[] = "$OpenBSD: size.c,v 1.10 1998/05/11 20:20:55 niklas Exp $";
a74 3
int	show_object __P((int, char *, FILE *));
void	*emalloc __P((size_t));
void	*erealloc __P((void *, size_t));
d179 2
a180 1
	name = emalloc(baselen + namelen);
d221 2
a222 1
				name = (char *)erealloc(name, baselen+len);
d227 1
a227 2
				(void)fprintf(stderr,
				    "nm: %s: premature EOF.\n", name);
d229 1
a229 1
				return 1;
a312 23
}

void *
emalloc(size)
	size_t size;
{
	char *p;

	/* NOSTRICT */
	if ((p = malloc(size)))
		return(p);
	err(1, NULL);
}

void *
erealloc(p, size)
	void   *p;
	size_t size;
{
	/* NOSTRICT */
	if ((p = realloc(p, size)))
		return(p);
	err(1, NULL);
@


1.10
log
@work on files linked with -Z too
@
text
@d1 1
a1 1
/*	$OpenBSD: size.c,v 1.9 1998/05/11 07:40:31 niklas Exp $	*/
d47 1
a47 1
static char rcsid[] = "$OpenBSD: size.c,v 1.9 1998/05/11 07:40:31 niklas Exp $";
d61 1
d249 1
a249 1
		if (N_BADMAG(exec_head)) {
a253 5
		} else if (N_GETMID(exec_head) != MID_MACHINE) {
			if (!ignore_bad_archive_entries) {
				warnx("%s: wrong architecture", name);
				rval = 1;
			}
d291 1
a291 1
	if (N_BADMAG(head)) {
d296 1
a296 4
	if (N_GETMID(head) && N_GETMID(head) != MID_MACHINE) {
		warnx("%s: wrong architecture", name);
		return(1);
	}
@


1.9
log
@Support building for cross purposes
@
text
@d1 1
a1 1
/*	$OpenBSD: size.c,v 1.8 1997/09/11 11:21:52 deraadt Exp $	*/
d47 1
a47 1
static char rcsid[] = "$OpenBSD: size.c,v 1.8 1997/09/11 11:21:52 deraadt Exp $";
d300 1
a300 1
	if (N_GETMID(head) != MID_MACHINE) {
@


1.8
log
@cleanup -Wall
@
text
@d1 1
a1 1
/*	$OpenBSD: size.c,v 1.7 1997/08/23 01:59:21 mickey Exp $	*/
d47 1
a47 1
static char rcsid[] = "$OpenBSD: size.c,v 1.7 1997/08/23 01:59:21 mickey Exp $";
d61 5
@


1.7
log
@sync usage() to man
@
text
@d1 1
a1 1
/*	$OpenBSD: size.c,v 1.6 1997/01/28 07:12:27 deraadt Exp $	*/
d47 1
a47 1
static char rcsid[] = "$OpenBSD: size.c,v 1.6 1997/01/28 07:12:27 deraadt Exp $";
d58 2
d68 1
d326 1
a326 1
	if (p = malloc(size))
d337 1
a337 1
	if (p = realloc(p, size))
@


1.6
log
@for total use -t; tsarna@@endicor.com
@
text
@d1 1
a1 1
/*	$OpenBSD: size.c,v 1.5 1997/01/15 23:43:13 millert Exp $	*/
d47 1
a47 1
static char rcsid[] = "$OpenBSD: size.c,v 1.5 1997/01/15 23:43:13 millert Exp $";
d342 1
a342 1
	(void)fprintf(stderr, "usage: size [-w] [file ...]\n");
@


1.5
log
@getopt(3) returns -1 when out of args, not EOF, whee!
@
text
@d1 1
a1 1
/*	$OpenBSD: size.c,v 1.4 1996/09/03 11:16:47 deraadt Exp $	*/
d47 1
a47 1
static char rcsid[] = "$OpenBSD: size.c,v 1.4 1996/09/03 11:16:47 deraadt Exp $";
d60 1
d62 1
d78 1
a78 1
	while ((ch = getopt(argc, argv, "w")) != -1)
d83 3
d100 5
d122 1
a122 1
    
d306 6
@


1.4
log
@detect wrong architecture
@
text
@d1 1
a1 1
/*	$OpenBSD: size.c,v 1.3 1996/06/26 05:39:18 deraadt Exp $	*/
d47 1
a47 1
static char rcsid[] = "$OpenBSD: size.c,v 1.3 1996/06/26 05:39:18 deraadt Exp $";
d76 1
a76 1
	while ((ch = getopt(argc, argv, "w")) != EOF)
@


1.3
log
@rcsid
@
text
@d1 1
a1 1
/*	$OpenBSD: size.c,v 1.7 1996/01/14 23:07:12 pk Exp $	*/
d47 1
a47 1
static char rcsid[] = "$OpenBSD: size.c,v 1.7 1996/01/14 23:07:12 pk Exp $";
d235 5
d279 5
@


1.2
log
@from netbsd; Add capability to read archives (from Thomas Eberhardt; PR#497)
@
text
@d1 1
d47 1
a47 1
static char rcsid[] = "$NetBSD: size.c,v 1.7 1996/01/14 23:07:12 pk Exp $";
@


1.1
log
@Initial revision
@
text
@d1 1
a1 1
/*	$NetBSD: size.c,v 1.6 1994/12/21 08:07:21 jtc Exp $	*/
d46 1
a46 1
static char rcsid[] = "$NetBSD: size.c,v 1.6 1994/12/21 08:07:21 jtc Exp $";
d52 2
d59 7
a65 1
int	show __P((int, char *));
d75 1
a75 1
	while ((ch = getopt(argc, argv, "")) != EOF)
d77 3
d90 1
a90 1
			eval |= show(argc, *argv);
d93 1
a93 1
		eval |= show(1, "a.out");
d97 50
d148 110
a257 1
show(count, name)
d260 1
a264 1
	int fd;
d266 8
a273 8
	if ((fd = open(name, O_RDONLY, 0)) < 0) {
		warn("%s", name);
		return (1);
	}
	if (read(fd, &head, sizeof(head)) != sizeof(head) || N_BADMAG(head)) {
		(void)close(fd);
		warnx("%s: not in a.out format", name);
		return (1);
a274 1
	(void)close(fd);
d289 23
d315 1
a315 1
	(void)fprintf(stderr, "usage: size [file ...]\n");
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@
