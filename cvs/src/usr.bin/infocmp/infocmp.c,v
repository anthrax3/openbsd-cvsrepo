head	1.23;
access;
symbols
	OPENBSD_6_0:1.22.0.4
	OPENBSD_6_0_BASE:1.22
	OPENBSD_5_9:1.22.0.2
	OPENBSD_5_9_BASE:1.22
	OPENBSD_5_8:1.20.0.26
	OPENBSD_5_8_BASE:1.20
	OPENBSD_5_7:1.20.0.18
	OPENBSD_5_7_BASE:1.20
	OPENBSD_5_6:1.20.0.22
	OPENBSD_5_6_BASE:1.20
	OPENBSD_5_5:1.20.0.20
	OPENBSD_5_5_BASE:1.20
	OPENBSD_5_4:1.20.0.16
	OPENBSD_5_4_BASE:1.20
	OPENBSD_5_3:1.20.0.14
	OPENBSD_5_3_BASE:1.20
	OPENBSD_5_2:1.20.0.12
	OPENBSD_5_2_BASE:1.20
	OPENBSD_5_1_BASE:1.20
	OPENBSD_5_1:1.20.0.10
	OPENBSD_5_0:1.20.0.8
	OPENBSD_5_0_BASE:1.20
	OPENBSD_4_9:1.20.0.6
	OPENBSD_4_9_BASE:1.20
	OPENBSD_4_8:1.20.0.4
	OPENBSD_4_8_BASE:1.20
	OPENBSD_4_7:1.20.0.2
	OPENBSD_4_7_BASE:1.20
	OPENBSD_4_6:1.19.0.12
	OPENBSD_4_6_BASE:1.19
	OPENBSD_4_5:1.19.0.8
	OPENBSD_4_5_BASE:1.19
	OPENBSD_4_4:1.19.0.6
	OPENBSD_4_4_BASE:1.19
	OPENBSD_4_3:1.19.0.4
	OPENBSD_4_3_BASE:1.19
	OPENBSD_4_2:1.19.0.2
	OPENBSD_4_2_BASE:1.19
	OPENBSD_4_1:1.18.0.2
	OPENBSD_4_1_BASE:1.18
	OPENBSD_4_0:1.17.0.14
	OPENBSD_4_0_BASE:1.17
	OPENBSD_3_9:1.17.0.12
	OPENBSD_3_9_BASE:1.17
	OPENBSD_3_8:1.17.0.10
	OPENBSD_3_8_BASE:1.17
	OPENBSD_3_7:1.17.0.8
	OPENBSD_3_7_BASE:1.17
	OPENBSD_3_6:1.17.0.6
	OPENBSD_3_6_BASE:1.17
	OPENBSD_3_5:1.17.0.4
	OPENBSD_3_5_BASE:1.17
	OPENBSD_3_4:1.17.0.2
	OPENBSD_3_4_BASE:1.17
	OPENBSD_3_3:1.15.0.6
	OPENBSD_3_3_BASE:1.15
	OPENBSD_3_2:1.15.0.4
	OPENBSD_3_2_BASE:1.15
	OPENBSD_3_1:1.15.0.2
	OPENBSD_3_1_BASE:1.15
	OPENBSD_3_0:1.13.0.4
	OPENBSD_3_0_BASE:1.13
	OPENBSD_2_9_BASE:1.13
	OPENBSD_2_9:1.13.0.2
	OPENBSD_2_8:1.11.0.2
	OPENBSD_2_8_BASE:1.11
	OPENBSD_2_7:1.10.0.2
	OPENBSD_2_7_BASE:1.10
	OPENBSD_2_6:1.5.0.2
	OPENBSD_2_6_BASE:1.5
	OPENBSD_2_5:1.3.0.2
	OPENBSD_2_5_BASE:1.3;
locks; strict;
comment	@ * @;


1.23
date	2016.08.03.16.32.08;	author krw;	state Exp;
branches;
next	1.22;
commitid	Fnr2x4U8CSE4G0QI;

1.22
date	2015.11.11.02.52.46;	author deraadt;	state Exp;
branches;
next	1.21;
commitid	6fvHpVQjE6wYuHzb;

1.21
date	2015.10.10.15.08.49;	author deraadt;	state Exp;
branches;
next	1.20;
commitid	rw5IcnPnOqO1ihoe;

1.20
date	2010.01.12.23.22.13;	author nicm;	state Exp;
branches;
next	1.19;

1.19
date	2007.06.02.01.29.12;	author pvalchev;	state Exp;
branches;
next	1.18;

1.18
date	2006.12.06.04.59.58;	author ray;	state Exp;
branches;
next	1.17;

1.17
date	2003.04.08.19.08.58;	author deraadt;	state Exp;
branches;
next	1.16;

1.16
date	2003.04.06.18.41.03;	author deraadt;	state Exp;
branches;
next	1.15;

1.15
date	2001.11.19.19.02.14;	author mpech;	state Exp;
branches;
next	1.14;

1.14
date	2001.10.24.13.06.36;	author mpech;	state Exp;
branches;
next	1.13;

1.13
date	2001.02.28.22.58.52;	author millert;	state Exp;
branches;
next	1.12;

1.12
date	2001.01.22.18.02.18;	author millert;	state Exp;
branches;
next	1.11;

1.11
date	2000.10.08.22.47.12;	author millert;	state Exp;
branches;
next	1.10;

1.10
date	2000.03.26.16.45.04;	author millert;	state Exp;
branches;
next	1.9;

1.9
date	2000.03.13.23.53.41;	author millert;	state Exp;
branches;
next	1.8;

1.8
date	2000.01.16.01.35.19;	author millert;	state Exp;
branches;
next	1.7;

1.7
date	99.12.06.02.14.34;	author millert;	state Exp;
branches;
next	1.6;

1.6
date	99.11.28.17.51.54;	author millert;	state Exp;
branches;
next	1.5;

1.5
date	99.06.27.08.17.46;	author millert;	state Exp;
branches;
next	1.4;

1.4
date	99.05.08.20.30.44;	author millert;	state Exp;
branches;
next	1.3;

1.3
date	99.03.11.21.08.07;	author millert;	state Exp;
branches;
next	1.2;

1.2
date	99.03.02.06.23.56;	author millert;	state Exp;
branches;
next	1.1;

1.1
date	99.01.22.04.51.31;	author millert;	state Exp;
branches;
next	;


desc
@@


1.23
log
@strnames[i][0] == 'k' && strnames[i][0] == 'f' should be
strnames[i][0] == 'k' && strnames[i][1] == 'f'.

Spotted by the Echelon team with AppChecker static analyzer.

millert@@ naddy@@ and ncurses 6.0 all agree.
@
text
@/*	$OpenBSD: infocmp.c,v 1.22 2015/11/11 02:52:46 deraadt Exp $	*/

/****************************************************************************
 * Copyright (c) 1998-2007,2008 Free Software Foundation, Inc.              *
 *                                                                          *
 * Permission is hereby granted, free of charge, to any person obtaining a  *
 * copy of this software and associated documentation files (the            *
 * "Software"), to deal in the Software without restriction, including      *
 * without limitation the rights to use, copy, modify, merge, publish,      *
 * distribute, distribute with modifications, sublicense, and/or sell       *
 * copies of the Software, and to permit persons to whom the Software is    *
 * furnished to do so, subject to the following conditions:                 *
 *                                                                          *
 * The above copyright notice and this permission notice shall be included  *
 * in all copies or substantial portions of the Software.                   *
 *                                                                          *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS  *
 * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF               *
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.   *
 * IN NO EVENT SHALL THE ABOVE COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,   *
 * DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR    *
 * OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR    *
 * THE USE OR OTHER DEALINGS IN THE SOFTWARE.                               *
 *                                                                          *
 * Except as contained in this notice, the name(s) of the above copyright   *
 * holders shall not be used in advertising or otherwise to promote the     *
 * sale, use or other dealings in this Software without prior written       *
 * authorization.                                                           *
 ****************************************************************************/

/****************************************************************************
 *  Author: Zeyd M. Ben-Halim <zmbenhal@@netcom.com> 1992,1995               *
 *     and: Eric S. Raymond <esr@@snark.thyrsus.com>                         *
 *     and: Thomas E. Dickey                        1996-on                 *
 ****************************************************************************/

/*
 *	infocmp.c -- decompile an entry, or compare two entries
 *		written by Eric S. Raymond
 *		and Thomas E Dickey
 */

#include <progs.priv.h>

#include <dump_entry.h>

MODULE_ID("$Id: infocmp.c,v 1.22 2015/11/11 02:52:46 deraadt Exp $")

#define L_CURL "{"
#define R_CURL "}"

#define MAX_STRING	1024	/* maximum formatted string */

const char *_nc_progname = "infocmp";

typedef char path[PATH_MAX];

/***************************************************************************
 *
 * The following control variables, together with the contents of the
 * terminfo entries, completely determine the actions of the program.
 *
 ***************************************************************************/

static ENTRY *entries;		/* terminfo entries */
static int termcount;		/* count of terminal entries */

static bool limited = TRUE;	/* "-r" option is not set */
static bool quiet = FALSE;
static bool literal = FALSE;
static const char *bool_sep = ":";
static const char *s_absent = "NULL";
static const char *s_cancel = "NULL";
static const char *tversion;	/* terminfo version selected */
static int itrace;		/* trace flag for debugging */
static int mwidth = 60;
static int numbers = 0;		/* format "%'char'" to/from "%{number}" */
static int outform = F_TERMINFO;	/* output format */
static int sortmode;		/* sort_mode */

/* main comparison mode */
static int compare;
#define C_DEFAULT	0	/* don't force comparison mode */
#define C_DIFFERENCE	1	/* list differences between two terminals */
#define C_COMMON	2	/* list common capabilities */
#define C_NAND		3	/* list capabilities in neither terminal */
#define C_USEALL	4	/* generate relative use-form entry */
static bool ignorepads;		/* ignore pad prefixes when diffing */

#if NO_LEAKS
#undef ExitProgram
static void ExitProgram(int code) GCC_NORETURN;
/* prototype is to get gcc to accept the noreturn attribute */
static void
ExitProgram(int code)
{
    while (termcount-- > 0)
	_nc_free_termtype(&entries[termcount].tterm);
    _nc_leaks_dump_entry();
    free(entries);
    _nc_free_tic(code);
}
#endif

static char *
canonical_name(char *ptr, char *buf, size_t bufl)
/* extract the terminal type's primary name */
{
    char *bp;

    (void) strlcpy(buf, ptr, bufl);
    if ((bp = strchr(buf, '|')) != 0)
	*bp = '\0';

    return (buf);
}

/***************************************************************************
 *
 * Predicates for dump function
 *
 ***************************************************************************/

static int
capcmp(PredIdx idx, const char *s, const char *t)
/* capability comparison function */
{
    if (!VALID_STRING(s) && !VALID_STRING(t))
	return (s != t);
    else if (!VALID_STRING(s) || !VALID_STRING(t))
	return (1);

    if ((idx == acs_chars_index) || !ignorepads)
	return (strcmp(s, t));
    else
	return (_nc_capcmp(s, t));
}

static int
use_predicate(unsigned type, PredIdx idx)
/* predicate function to use for use decompilation */
{
    ENTRY *ep;

    switch (type) {
    case BOOLEAN:
	{
	    int is_set = FALSE;

	    /*
	     * This assumes that multiple use entries are supposed
	     * to contribute the logical or of their boolean capabilities.
	     * This is true if we take the semantics of multiple uses to
	     * be 'each capability gets the first non-default value found
	     * in the sequence of use entries'.
	     *
	     * Note that cancelled or absent booleans are stored as FALSE,
	     * unlike numbers and strings, whose cancelled/absent state is
	     * recorded in the terminfo database.
	     */
	    for (ep = &entries[1]; ep < entries + termcount; ep++)
		if (ep->tterm.Booleans[idx] == TRUE) {
		    is_set = entries[0].tterm.Booleans[idx];
		    break;
		}
	    if (is_set != entries[0].tterm.Booleans[idx])
		return (!is_set);
	    else
		return (FAIL);
	}

    case NUMBER:
	{
	    int value = ABSENT_NUMERIC;

	    /*
	     * We take the semantics of multiple uses to be 'each
	     * capability gets the first non-default value found
	     * in the sequence of use entries'.
	     */
	    for (ep = &entries[1]; ep < entries + termcount; ep++)
		if (VALID_NUMERIC(ep->tterm.Numbers[idx])) {
		    value = ep->tterm.Numbers[idx];
		    break;
		}

	    if (value != entries[0].tterm.Numbers[idx])
		return (value != ABSENT_NUMERIC);
	    else
		return (FAIL);
	}

    case STRING:
	{
	    char *termstr, *usestr = ABSENT_STRING;

	    termstr = entries[0].tterm.Strings[idx];

	    /*
	     * We take the semantics of multiple uses to be 'each
	     * capability gets the first non-default value found
	     * in the sequence of use entries'.
	     */
	    for (ep = &entries[1]; ep < entries + termcount; ep++)
		if (ep->tterm.Strings[idx]) {
		    usestr = ep->tterm.Strings[idx];
		    break;
		}

	    if (usestr == ABSENT_STRING && termstr == ABSENT_STRING)
		return (FAIL);
	    else if (!usestr || !termstr || capcmp(idx, usestr, termstr))
		return (TRUE);
	    else
		return (FAIL);
	}
    }

    return (FALSE);		/* pacify compiler */
}

static bool
useeq(ENTRY * e1, ENTRY * e2)
/* are the use references in two entries equivalent? */
{
    unsigned i, j;

    if (e1->nuses != e2->nuses)
	return (FALSE);

    /* Ugh...this is quadratic again */
    for (i = 0; i < e1->nuses; i++) {
	bool foundmatch = FALSE;

	/* search second entry for given use reference */
	for (j = 0; j < e2->nuses; j++)
	    if (!strcmp(e1->uses[i].name, e2->uses[j].name)) {
		foundmatch = TRUE;
		break;
	    }

	if (!foundmatch)
	    return (FALSE);
    }

    return (TRUE);
}

static bool
entryeq(TERMTYPE *t1, TERMTYPE *t2)
/* are two entries equivalent? */
{
    unsigned i;

    for (i = 0; i < NUM_BOOLEANS(t1); i++)
	if (t1->Booleans[i] != t2->Booleans[i])
	    return (FALSE);

    for (i = 0; i < NUM_NUMBERS(t1); i++)
	if (t1->Numbers[i] != t2->Numbers[i])
	    return (FALSE);

    for (i = 0; i < NUM_STRINGS(t1); i++)
	if (capcmp((PredIdx) i, t1->Strings[i], t2->Strings[i]))
	    return (FALSE);

    return (TRUE);
}

#define TIC_EXPAND(result) _nc_tic_expand(result, outform==F_TERMINFO, numbers)

static void
print_uses(ENTRY * ep, FILE *fp)
/* print an entry's use references */
{
    unsigned i;

    if (!ep->nuses)
	fputs("NULL", fp);
    else
	for (i = 0; i < ep->nuses; i++) {
	    fputs(ep->uses[i].name, fp);
	    if (i < ep->nuses - 1)
		fputs(" ", fp);
	}
}

static const char *
dump_boolean(int val)
/* display the value of a boolean capability */
{
    switch (val) {
    case ABSENT_BOOLEAN:
	return (s_absent);
    case CANCELLED_BOOLEAN:
	return (s_cancel);
    case FALSE:
	return ("F");
    case TRUE:
	return ("T");
    default:
	return ("?");
    }
}

static void
dump_numeric(int val, char *buf, size_t bufl)
/* display the value of a boolean capability */
{
    switch (val) {
    case ABSENT_NUMERIC:
	strlcpy(buf, s_absent, bufl);
	break;
    case CANCELLED_NUMERIC:
	strlcpy(buf, s_cancel, bufl);
	break;
    default:
	snprintf(buf, bufl, "%d", val);
	break;
    }
}

static void
dump_string(char *val, char *buf, size_t bufl)
/* display the value of a string capability */
{
    if (val == ABSENT_STRING)
	strlcpy(buf, s_absent, bufl);
    else if (val == CANCELLED_STRING)
	strlcpy(buf, s_cancel, bufl);
    else {
	snprintf(buf, bufl, "'%.*s'", MAX_STRING - 3, TIC_EXPAND(val));
    }
}

static void
compare_predicate(PredType type, PredIdx idx, const char *name)
/* predicate function to use for entry difference reports */
{
    ENTRY *e1 = &entries[0];
    ENTRY *e2 = &entries[1];
    char buf1[MAX_STRING], buf2[MAX_STRING];
    int b1, b2;
    int n1, n2;
    char *s1, *s2;

    switch (type) {
    case CMP_BOOLEAN:
	b1 = e1->tterm.Booleans[idx];
	b2 = e2->tterm.Booleans[idx];
	switch (compare) {
	case C_DIFFERENCE:
	    if (!(b1 == ABSENT_BOOLEAN && b2 == ABSENT_BOOLEAN) && b1 != b2)
		(void) printf("\t%s: %s%s%s.\n",
			      name,
			      dump_boolean(b1),
			      bool_sep,
			      dump_boolean(b2));
	    break;

	case C_COMMON:
	    if (b1 == b2 && b1 != ABSENT_BOOLEAN)
		(void) printf("\t%s= %s.\n", name, dump_boolean(b1));
	    break;

	case C_NAND:
	    if (b1 == ABSENT_BOOLEAN && b2 == ABSENT_BOOLEAN)
		(void) printf("\t!%s.\n", name);
	    break;
	}
	break;

    case CMP_NUMBER:
	n1 = e1->tterm.Numbers[idx];
	n2 = e2->tterm.Numbers[idx];
	dump_numeric(n1, buf1, sizeof buf1);
	dump_numeric(n2, buf2, sizeof buf2);
	switch (compare) {
	case C_DIFFERENCE:
	    if (!((n1 == ABSENT_NUMERIC && n2 == ABSENT_NUMERIC)) && n1 != n2)
		(void) printf("\t%s: %s, %s.\n", name, buf1, buf2);
	    break;

	case C_COMMON:
	    if (n1 != ABSENT_NUMERIC && n2 != ABSENT_NUMERIC && n1 == n2)
		(void) printf("\t%s= %s.\n", name, buf1);
	    break;

	case C_NAND:
	    if (n1 == ABSENT_NUMERIC && n2 == ABSENT_NUMERIC)
		(void) printf("\t!%s.\n", name);
	    break;
	}
	break;

    case CMP_STRING:
	s1 = e1->tterm.Strings[idx];
	s2 = e2->tterm.Strings[idx];
	switch (compare) {
	case C_DIFFERENCE:
	    if (capcmp(idx, s1, s2)) {
		dump_string(s1, buf1, sizeof buf1);
		dump_string(s2, buf2, sizeof buf2);
		if (strcmp(buf1, buf2))
		    (void) printf("\t%s: %s, %s.\n", name, buf1, buf2);
	    }
	    break;

	case C_COMMON:
	    if (s1 && s2 && !capcmp(idx, s1, s2))
		(void) printf("\t%s= '%s'.\n", name, TIC_EXPAND(s1));
	    break;

	case C_NAND:
	    if (!s1 && !s2)
		(void) printf("\t!%s.\n", name);
	    break;
	}
	break;

    case CMP_USE:
	/* unlike the other modes, this compares *all* use entries */
	switch (compare) {
	case C_DIFFERENCE:
	    if (!useeq(e1, e2)) {
		(void) fputs("\tuse: ", stdout);
		print_uses(e1, stdout);
		fputs(", ", stdout);
		print_uses(e2, stdout);
		fputs(".\n", stdout);
	    }
	    break;

	case C_COMMON:
	    if (e1->nuses && e2->nuses && useeq(e1, e2)) {
		(void) fputs("\tuse: ", stdout);
		print_uses(e1, stdout);
		fputs(".\n", stdout);
	    }
	    break;

	case C_NAND:
	    if (!e1->nuses && !e2->nuses)
		(void) printf("\t!use.\n");
	    break;
	}
    }
}

/***************************************************************************
 *
 * Init string analysis
 *
 ***************************************************************************/

typedef struct {
    const char *from;
    const char *to;
} assoc;

static const assoc std_caps[] =
{
    /* these are specified by X.364 and iBCS2 */
    {"\033c", "RIS"},		/* full reset */
    {"\0337", "SC"},		/* save cursor */
    {"\0338", "RC"},		/* restore cursor */
    {"\033[r", "RSR"},		/* not an X.364 mnemonic */
    {"\033[m", "SGR0"},		/* not an X.364 mnemonic */
    {"\033[2J", "ED2"},		/* clear page */

    /* this group is specified by ISO 2022 */
    {"\033(0", "ISO DEC G0"},	/* enable DEC graphics for G0 */
    {"\033(A", "ISO UK G0"},	/* enable UK chars for G0 */
    {"\033(B", "ISO US G0"},	/* enable US chars for G0 */
    {"\033)0", "ISO DEC G1"},	/* enable DEC graphics for G1 */
    {"\033)A", "ISO UK G1"},	/* enable UK chars for G1 */
    {"\033)B", "ISO US G1"},	/* enable US chars for G1 */

    /* these are DEC private controls widely supported by emulators */
    {"\033=", "DECPAM"},	/* application keypad mode */
    {"\033>", "DECPNM"},	/* normal keypad mode */
    {"\033<", "DECANSI"},	/* enter ANSI mode */
    {"\033[!p", "DECSTR"},	/* soft reset */
    {"\033 F", "S7C1T"},	/* 7-bit controls */

    {(char *) 0, (char *) 0}
};

static const assoc std_modes[] =
/* ECMA \E[ ... [hl] modes recognized by many emulators */
{
    {"2", "AM"},		/* keyboard action mode */
    {"4", "IRM"},		/* insert/replace mode */
    {"12", "SRM"},		/* send/receive mode */
    {"20", "LNM"},		/* linefeed mode */
    {(char *) 0, (char *) 0}
};

static const assoc private_modes[] =
/* DEC \E[ ... [hl] modes recognized by many emulators */
{
    {"1", "CKM"},		/* application cursor keys */
    {"2", "ANM"},		/* set VT52 mode */
    {"3", "COLM"},		/* 132-column mode */
    {"4", "SCLM"},		/* smooth scroll */
    {"5", "SCNM"},		/* reverse video mode */
    {"6", "OM"},		/* origin mode */
    {"7", "AWM"},		/* wraparound mode */
    {"8", "ARM"},		/* auto-repeat mode */
    {(char *) 0, (char *) 0}
};

static const assoc ecma_highlights[] =
/* recognize ECMA attribute sequences */
{
    {"0", "NORMAL"},		/* normal */
    {"1", "+BOLD"},		/* bold on */
    {"2", "+DIM"},		/* dim on */
    {"3", "+ITALIC"},		/* italic on */
    {"4", "+UNDERLINE"},	/* underline on */
    {"5", "+BLINK"},		/* blink on */
    {"6", "+FASTBLINK"},	/* fastblink on */
    {"7", "+REVERSE"},		/* reverse on */
    {"8", "+INVISIBLE"},	/* invisible on */
    {"9", "+DELETED"},		/* deleted on */
    {"10", "MAIN-FONT"},	/* select primary font */
    {"11", "ALT-FONT-1"},	/* select alternate font 1 */
    {"12", "ALT-FONT-2"},	/* select alternate font 2 */
    {"13", "ALT-FONT-3"},	/* select alternate font 3 */
    {"14", "ALT-FONT-4"},	/* select alternate font 4 */
    {"15", "ALT-FONT-5"},	/* select alternate font 5 */
    {"16", "ALT-FONT-6"},	/* select alternate font 6 */
    {"17", "ALT-FONT-7"},	/* select alternate font 7 */
    {"18", "ALT-FONT-1"},	/* select alternate font 1 */
    {"19", "ALT-FONT-1"},	/* select alternate font 1 */
    {"20", "FRAKTUR"},		/* Fraktur font */
    {"21", "DOUBLEUNDER"},	/* double underline */
    {"22", "-DIM"},		/* dim off */
    {"23", "-ITALIC"},		/* italic off */
    {"24", "-UNDERLINE"},	/* underline off */
    {"25", "-BLINK"},		/* blink off */
    {"26", "-FASTBLINK"},	/* fastblink off */
    {"27", "-REVERSE"},		/* reverse off */
    {"28", "-INVISIBLE"},	/* invisible off */
    {"29", "-DELETED"},		/* deleted off */
    {(char *) 0, (char *) 0}
};

static int
skip_csi(const char *cap)
{
    int result = 0;
    if (cap[0] == '\033' && cap[1] == '[')
	result = 2;
    else if (UChar(cap[0]) == 0233)
	result = 1;
    return result;
}

static bool
same_param(const char *table, const char *param, unsigned length)
{
    bool result = FALSE;
    if (strncmp(table, param, length) == 0) {
	result = !isdigit(UChar(param[length]));
    }
    return result;
}

static char *
lookup_params(const assoc * table, char *dst, char *src, size_t dstlen)
{
    char *result = 0;
    const char *ep = strtok(src, ";");

    if (ep != 0) {
	const assoc *ap;

	do {
	    bool found = FALSE;

	    for (ap = table; ap->from; ap++) {
		size_t tlen = strlen(ap->from);

		if (same_param(ap->from, ep, tlen)) {
		    (void) strlcat(dst, ap->to, dstlen);
		    found = TRUE;
		    break;
		}
	    }

	    if (!found)
		(void) strlcat(dst, ep, dstlen);
	    (void) strlcat(dst, ";", dstlen);
	} while
	    ((ep = strtok((char *) 0, ";")));

	if (dst[0] != '\0' && dst[strlen(dst) - 1] == ';')
	    dst[strlen(dst) - 1] = '\0';

	result = dst;
    }
    return result;
}

static void
analyze_string(const char *name, const char *cap, TERMTYPE *tp)
{
    char buf2[MAX_TERMINFO_LENGTH];
    const char *sp;
    const assoc *ap;
    int tp_lines = tp->Numbers[2];

    if (cap == ABSENT_STRING || cap == CANCELLED_STRING)
	return;
    (void) printf("%s: ", name);

    for (sp = cap; *sp; sp++) {
	int i;
	int csi;
	size_t len = 0;
	size_t next;
	const char *expansion = 0;
	char buf3[MAX_TERMINFO_LENGTH];

	/* first, check other capabilities in this entry */
	for (i = 0; i < STRCOUNT; i++) {
	    char *cp = tp->Strings[i];

	    /* don't use soft-key capabilities */
	    if (strnames[i][0] == 'k' && strnames[i][1] == 'f')
		continue;

	    if (cp != ABSENT_STRING && cp != CANCELLED_STRING && cp[0] && cp
		!= cap) {
		len = strlen(cp);
		(void) strncpy(buf2, sp, len);
		buf2[len] = '\0';

		if (_nc_capcmp(cp, buf2))
		    continue;

#define ISRS(s)	(!strncmp((s), "is", 2) || !strncmp((s), "rs", 2))
		/*
		 * Theoretically we just passed the test for translation
		 * (equality once the padding is stripped).  However, there
		 * are a few more hoops that need to be jumped so that
		 * identical pairs of initialization and reset strings
		 * don't just refer to each other.
		 */
		if (ISRS(name) || ISRS(strnames[i]))
		    if (cap < cp)
			continue;
#undef ISRS

		expansion = strnames[i];
		break;
	    }
	}

	/* now check the standard capabilities */
	if (!expansion) {
	    csi = skip_csi(sp);
	    for (ap = std_caps; ap->from; ap++) {
		size_t adj = (size_t) (csi ? 2 : 0);

		len = strlen(ap->from);
		if (csi && skip_csi(ap->from) != csi)
		    continue;
		if (len > adj
		    && strncmp(ap->from + adj, sp + csi, len - adj) == 0) {
		    expansion = ap->to;
		    len -= adj;
		    len += (size_t) csi;
		    break;
		}
	    }
	}

	/* now check for standard-mode sequences */
	if (!expansion
	    && (csi = skip_csi(sp)) != 0
	    && (len = strspn(sp + csi, "0123456789;"))
	    && (len < sizeof(buf3))
	    && (next = (size_t) csi + len)
	    && ((sp[next] == 'h') || (sp[next] == 'l'))) {

	    (void) strlcpy(buf2, (sp[next] == 'h') ? "ECMA+" : "ECMA-",
		sizeof buf2);
	    (void) strncpy(buf3, sp + csi, len);
	    buf3[len] = '\0';
	    len += (size_t) csi + 1;

	    expansion = lookup_params(std_modes, buf2, buf3, sizeof buf2);
	}

	/* now check for private-mode sequences */
	if (!expansion
	    && (csi = skip_csi(sp)) != 0
	    && sp[csi] == '?'
	    && (len = strspn(sp + csi + 1, "0123456789;"))
	    && (len < sizeof(buf3))
	    && (next = (size_t) csi + 1 + len)
	    && ((sp[next] == 'h') || (sp[next] == 'l'))) {

	    (void) strlcpy(buf2, (sp[next] == 'h') ? "DEC+" : "DEC-",
		sizeof buf2);
	    (void) strncpy(buf3, sp + csi + 1, len);
	    buf3[len] = '\0';
	    len += (size_t) csi + 2;

	    expansion = lookup_params(private_modes, buf2, buf3, sizeof buf2);
	}

	/* now check for ECMA highlight sequences */
	if (!expansion
	    && (csi = skip_csi(sp)) != 0
	    && (len = strspn(sp + csi, "0123456789;")) != 0
	    && (len < sizeof(buf3))
	    && (next = (size_t) csi + len)
	    && sp[next] == 'm') {

	    (void) strlcpy(buf2, "SGR:", sizeof buf2);
	    (void) strncpy(buf3, sp + csi, len);
	    buf3[len] = '\0';
	    len += (size_t) csi + 1;

	    expansion = lookup_params(ecma_highlights, buf2, buf3, sizeof buf2);
	}

	if (!expansion
	    && (csi = skip_csi(sp)) != 0
	    && sp[csi] == 'm') {
	    len = (size_t) csi + 1;
	    (void) strlcpy(buf2, "SGR:", sizeof buf2);
	    strlcat(buf2, ecma_highlights[0].to, sizeof buf2);
	    expansion = buf2;
	}

	/* now check for scroll region reset */
	if (!expansion
	    && (csi = skip_csi(sp)) != 0) {
	    if (sp[csi] == 'r') {
		expansion = "RSR";
		len = 1;
	    } else {
		(void) snprintf(buf2, sizeof buf2, "1;%dr", tp_lines);
		len = strlen(buf2);
		if (strncmp(buf2, sp + csi, len) == 0)
		    expansion = "RSR";
	    }
	    len += (size_t) csi;
	}

	/* now check for home-down */
	if (!expansion
	    && (csi = skip_csi(sp)) != 0) {
	    (void) snprintf(buf2, sizeof buf2, "%d;1H", tp_lines);
	    len = strlen(buf2);
	    if (strncmp(buf2, sp + csi, len) == 0) {
		expansion = "LL";
	    } else {
		(void) snprintf(buf2, sizeof buf2, "%dH", tp_lines);
		len = strlen(buf2);
		if (strncmp(buf2, sp + csi, len) == 0) {
		    expansion = "LL";
		}
	    }
	    len += (size_t) csi;
	}

	/* now look at the expansion we got, if any */
	if (expansion) {
	    printf("{%s}", expansion);
	    sp += len - 1;
	} else {
	    /* couldn't match anything */
	    buf2[0] = *sp;
	    buf2[1] = '\0';
	    fputs(TIC_EXPAND(buf2), stdout);
	}
    }
    putchar('\n');
}

/***************************************************************************
 *
 * File comparison
 *
 ***************************************************************************/

static void
file_comparison(int argc, char *argv[])
{
#define MAXCOMPARE	2
    /* someday we may allow comparisons on more files */
    int filecount = 0;
    ENTRY *heads[MAXCOMPARE];
    ENTRY *qp, *rp;
    int i, n;

    memset(heads, 0, sizeof(heads));
    dump_init((char *) 0, F_LITERAL, S_TERMINFO, 0, itrace, FALSE);

    for (n = 0; n < argc && n < MAXCOMPARE; n++) {
	if (freopen(argv[n], "r", stdin) == 0)
	    _nc_err_abort("Can't open %s", argv[n]);

	_nc_head = _nc_tail = 0;

	/* parse entries out of the source file */
	_nc_set_source(argv[n]);
	_nc_read_entry_source(stdin, NULL, TRUE, literal, NULLHOOK);

	if (itrace)
	    (void) fprintf(stderr, "Resolving file %d...\n", n - 0);

	/* maybe do use resolution */
	if (!_nc_resolve_uses2(!limited, literal)) {
	    (void) fprintf(stderr,
			   "There are unresolved use entries in %s:\n",
			   argv[n]);
	    for_entry_list(qp) {
		if (qp->nuses) {
		    (void) fputs(qp->tterm.term_names, stderr);
		    (void) fputc('\n', stderr);
		}
	    }
	    ExitProgram(EXIT_FAILURE);
	}

	heads[filecount] = _nc_head;
	filecount++;
    }

    /* OK, all entries are in core.  Ready to do the comparison */
    if (itrace)
	(void) fprintf(stderr, "Entries are now in core...\n");

    /* The entry-matching loop. Sigh, this is intrinsically quadratic. */
    for (qp = heads[0]; qp; qp = qp->next) {
	for (rp = heads[1]; rp; rp = rp->next)
	    if (_nc_entry_match(qp->tterm.term_names, rp->tterm.term_names)) {
		if (qp->ncrosslinks < MAX_CROSSLINKS)
		    qp->crosslinks[qp->ncrosslinks] = rp;
		qp->ncrosslinks++;

		if (rp->ncrosslinks < MAX_CROSSLINKS)
		    rp->crosslinks[rp->ncrosslinks] = qp;
		rp->ncrosslinks++;
	    }
    }

    /* now we have two circular lists with crosslinks */
    if (itrace)
	(void) fprintf(stderr, "Name matches are done...\n");

    for (qp = heads[0]; qp; qp = qp->next) {
	if (qp->ncrosslinks > 1) {
	    (void) fprintf(stderr,
			   "%s in file 1 (%s) has %d matches in file 2 (%s):\n",
			   _nc_first_name(qp->tterm.term_names),
			   argv[0],
			   qp->ncrosslinks,
			   argv[1]);
	    for (i = 0; i < qp->ncrosslinks; i++)
		(void) fprintf(stderr,
			       "\t%s\n",
			       _nc_first_name((qp->crosslinks[i])->tterm.term_names));
	}
    }

    for (rp = heads[1]; rp; rp = rp->next) {
	if (rp->ncrosslinks > 1) {
	    (void) fprintf(stderr,
			   "%s in file 2 (%s) has %d matches in file 1 (%s):\n",
			   _nc_first_name(rp->tterm.term_names),
			   argv[1],
			   rp->ncrosslinks,
			   argv[0]);
	    for (i = 0; i < rp->ncrosslinks; i++)
		(void) fprintf(stderr,
			       "\t%s\n",
			       _nc_first_name((rp->crosslinks[i])->tterm.term_names));
	}
    }

    (void) printf("In file 1 (%s) only:\n", argv[0]);
    for (qp = heads[0]; qp; qp = qp->next)
	if (qp->ncrosslinks == 0)
	    (void) printf("\t%s\n",
			  _nc_first_name(qp->tterm.term_names));

    (void) printf("In file 2 (%s) only:\n", argv[1]);
    for (rp = heads[1]; rp; rp = rp->next)
	if (rp->ncrosslinks == 0)
	    (void) printf("\t%s\n",
			  _nc_first_name(rp->tterm.term_names));

    (void) printf("The following entries are equivalent:\n");
    for (qp = heads[0]; qp; qp = qp->next) {
	rp = qp->crosslinks[0];

	if (qp->ncrosslinks == 1) {
	    rp = qp->crosslinks[0];

	    repair_acsc(&qp->tterm);
	    repair_acsc(&rp->tterm);
#if NCURSES_XNAMES
	    _nc_align_termtype(&qp->tterm, &rp->tterm);
#endif
	    if (entryeq(&qp->tterm, &rp->tterm) && useeq(qp, rp)) {
		char name1[NAMESIZE], name2[NAMESIZE];

		(void) canonical_name(qp->tterm.term_names, name1, sizeof name1);
		(void) canonical_name(rp->tterm.term_names, name2, sizeof name2);

		(void) printf("%s = %s\n", name1, name2);
	    }
	}
    }

    (void) printf("Differing entries:\n");
    termcount = 2;
    for (qp = heads[0]; qp; qp = qp->next) {

	if (qp->ncrosslinks == 1) {
	    rp = qp->crosslinks[0];
#if NCURSES_XNAMES
	    /* sorry - we have to do this on each pass */
	    _nc_align_termtype(&qp->tterm, &rp->tterm);
#endif
	    if (!(entryeq(&qp->tterm, &rp->tterm) && useeq(qp, rp))) {
		char name1[NAMESIZE], name2[NAMESIZE];

		entries[0] = *qp;
		entries[1] = *rp;

		(void) canonical_name(qp->tterm.term_names, name1, sizeof name1);
		(void) canonical_name(rp->tterm.term_names, name2, sizeof name2);

		switch (compare) {
		case C_DIFFERENCE:
		    if (itrace)
			(void) fprintf(stderr,
				       "%s: dumping differences\n",
				       _nc_progname);
		    (void) printf("comparing %s to %s.\n", name1, name2);
		    compare_entry(compare_predicate, &entries->tterm, quiet);
		    break;

		case C_COMMON:
		    if (itrace)
			(void) fprintf(stderr,
				       "%s: dumping common capabilities\n",
				       _nc_progname);
		    (void) printf("comparing %s to %s.\n", name1, name2);
		    compare_entry(compare_predicate, &entries->tterm, quiet);
		    break;

		case C_NAND:
		    if (itrace)
			(void) fprintf(stderr,
				       "%s: dumping differences\n",
				       _nc_progname);
		    (void) printf("comparing %s to %s.\n", name1, name2);
		    compare_entry(compare_predicate, &entries->tterm, quiet);
		    break;

		}
	    }
	}
    }
}

static void
usage(void)
{
    static const char *tbl[] =
    {
	"Usage: infocmp [options] [-A directory] [-B directory] [termname...]"
	,""
	,"Options:"
	,"  -1    print single-column"
	,"  -C    use termcap-names"
	,"  -F    compare terminfo-files"
	,"  -I    use terminfo-names"
	,"  -L    use long names"
	,"  -R subset (see manpage)"
	,"  -T    eliminate size limits (test)"
	,"  -U    eliminate post-processing of entries"
	,"  -V    print version"
#if NCURSES_XNAMES
	,"  -a    with -F, list commented-out caps"
#endif
	,"  -c    list common capabilities"
	,"  -d    list different capabilities"
	,"  -e    format output for C initializer"
	,"  -E    format output as C tables"
	,"  -f    with -1, format complex strings"
	,"  -G    format %{number} to %'char'"
	,"  -g    format %'char' to %{number}"
	,"  -i    analyze initialization/reset"
	,"  -l    output terminfo names"
	,"  -n    list capabilities in neither"
	,"  -p    ignore padding specifiers"
	,"  -q    brief listing, removes headers"
	,"  -r    with -C, output in termcap form"
	,"  -r    with -F, resolve use-references"
	,"  -s [d|i|l|c] sort fields"
#if NCURSES_XNAMES
	,"  -t    suppress commented-out capabilities"
#endif
	,"  -u    produce source with 'use='"
	,"  -v number  (verbose)"
	,"  -w number  (width)"
#if NCURSES_XNAMES
	,"  -x    treat unknown capabilities as user-defined"
#endif
    };
    const size_t first = 3;
    const size_t last = SIZEOF(tbl);
    const size_t left = (last - first + 1) / 2 + first;
    size_t n;

    for (n = 0; n < left; n++) {
	size_t m = (n < first) ? last : n + left - first;
	if (m < last)
	    fprintf(stderr, "%-40.40s%s\n", tbl[n], tbl[m]);
	else
	    fprintf(stderr, "%s\n", tbl[n]);
    }
    ExitProgram(EXIT_FAILURE);
}

static char *
any_initializer(const char *fmt, const char *type)
{
    static char *initializer;
    static size_t len;
    char *s;

    if (initializer == 0) {
	len = strlen(entries->tterm.term_names) + strlen(type) + strlen(fmt);
	initializer = (char *) malloc(len);
    }

    (void) strlcpy(initializer, entries->tterm.term_names, len);
    for (s = initializer; *s != 0 && *s != '|'; s++) {
	if (!isalnum(UChar(*s)))
	    *s = '_';
    }
    *s = 0;
    (void) snprintf(s, len - (s - initializer), fmt, type);
    return initializer;
}

static char *
name_initializer(const char *type)
{
    return any_initializer("_%s_data", type);
}

static char *
string_variable(const char *type)
{
    return any_initializer("_s_%s", type);
}

/* dump C initializers for the terminal type */
static void
dump_initializers(TERMTYPE *term)
{
    unsigned n;
    const char *str = 0;

    printf("\nstatic char %s[] = \"%s\";\n\n",
	   name_initializer("alias"), entries->tterm.term_names);

    for_each_string(n, term) {
	char buf[MAX_STRING], *sp, *tp;

	if (VALID_STRING(term->Strings[n])) {
	    tp = buf;
	    *tp++ = '"';
	    for (sp = term->Strings[n];
		 *sp != 0 && (tp - buf) < MAX_STRING - 6;
		 sp++) {
		if (isascii(UChar(*sp))
		    && isprint(UChar(*sp))
		    && *sp != '\\'
		    && *sp != '"')
		    *tp++ = *sp;
		else {
		    (void) snprintf(tp, buf + sizeof buf - tp, "\\%03o",
			UChar(*sp));
		    tp += strlen(tp);
		}
	    }
	    *tp++ = '"';
	    *tp = '\0';
	    (void) printf("static char %-20s[] = %s;\n",
			  string_variable(ExtStrname(term, n, strnames)), buf);
	}
    }
    printf("\n");

    (void) printf("static char %s[] = %s\n", name_initializer("bool"), L_CURL);

    for_each_boolean(n, term) {
	switch ((int) (term->Booleans[n])) {
	case TRUE:
	    str = "TRUE";
	    break;

	case FALSE:
	    str = "FALSE";
	    break;

	case ABSENT_BOOLEAN:
	    str = "ABSENT_BOOLEAN";
	    break;

	case CANCELLED_BOOLEAN:
	    str = "CANCELLED_BOOLEAN";
	    break;
	}
	(void) printf("\t/* %3u: %-8s */\t%s,\n",
		      n, ExtBoolname(term, n, boolnames), str);
    }
    (void) printf("%s;\n", R_CURL);

    (void) printf("static short %s[] = %s\n", name_initializer("number"), L_CURL);

    for_each_number(n, term) {
	char buf[BUFSIZ];
	switch (term->Numbers[n]) {
	case ABSENT_NUMERIC:
	    str = "ABSENT_NUMERIC";
	    break;
	case CANCELLED_NUMERIC:
	    str = "CANCELLED_NUMERIC";
	    break;
	default:
	    snprintf(buf, sizeof buf, "%d", term->Numbers[n]);
	    str = buf;
	    break;
	}
	(void) printf("\t/* %3u: %-8s */\t%s,\n", n,
		      ExtNumname(term, n, numnames), str);
    }
    (void) printf("%s;\n", R_CURL);

    (void) printf("static char * %s[] = %s\n", name_initializer("string"), L_CURL);

    for_each_string(n, term) {

	if (term->Strings[n] == ABSENT_STRING)
	    str = "ABSENT_STRING";
	else if (term->Strings[n] == CANCELLED_STRING)
	    str = "CANCELLED_STRING";
	else {
	    str = string_variable(ExtStrname(term, n, strnames));
	}
	(void) printf("\t/* %3u: %-8s */\t%s,\n", n,
		      ExtStrname(term, n, strnames), str);
    }
    (void) printf("%s;\n", R_CURL);

#if NCURSES_XNAMES
    if ((NUM_BOOLEANS(term) != BOOLCOUNT)
	|| (NUM_NUMBERS(term) != NUMCOUNT)
	|| (NUM_STRINGS(term) != STRCOUNT)) {
	(void) printf("static char * %s[] = %s\n",
		      name_initializer("string_ext"), L_CURL);
	for (n = BOOLCOUNT; n < NUM_BOOLEANS(term); ++n) {
	    (void) printf("\t/* %3u: bool */\t\"%s\",\n",
			  n, ExtBoolname(term, n, boolnames));
	}
	for (n = NUMCOUNT; n < NUM_NUMBERS(term); ++n) {
	    (void) printf("\t/* %3u: num */\t\"%s\",\n",
			  n, ExtNumname(term, n, numnames));
	}
	for (n = STRCOUNT; n < NUM_STRINGS(term); ++n) {
	    (void) printf("\t/* %3u: str */\t\"%s\",\n",
			  n, ExtStrname(term, n, strnames));
	}
	(void) printf("%s;\n", R_CURL);
    }
#endif
}

/* dump C initializers for the terminal type */
static void
dump_termtype(TERMTYPE *term)
{
    (void) printf("\t%s\n\t\t%s,\n", L_CURL, name_initializer("alias"));
    (void) printf("\t\t(char *)0,\t/* pointer to string table */\n");

    (void) printf("\t\t%s,\n", name_initializer("bool"));
    (void) printf("\t\t%s,\n", name_initializer("number"));

    (void) printf("\t\t%s,\n", name_initializer("string"));

#if NCURSES_XNAMES
    (void) printf("#if NCURSES_XNAMES\n");
    (void) printf("\t\t(char *)0,\t/* pointer to extended string table */\n");
    (void) printf("\t\t%s,\t/* ...corresponding names */\n",
		  ((NUM_BOOLEANS(term) != BOOLCOUNT)
		   || (NUM_NUMBERS(term) != NUMCOUNT)
		   || (NUM_STRINGS(term) != STRCOUNT))
		  ? name_initializer("string_ext")
		  : "(char **)0");

    (void) printf("\t\t%d,\t\t/* count total Booleans */\n", NUM_BOOLEANS(term));
    (void) printf("\t\t%d,\t\t/* count total Numbers */\n", NUM_NUMBERS(term));
    (void) printf("\t\t%d,\t\t/* count total Strings */\n", NUM_STRINGS(term));

    (void) printf("\t\t%d,\t\t/* count extensions to Booleans */\n",
		  NUM_BOOLEANS(term) - BOOLCOUNT);
    (void) printf("\t\t%d,\t\t/* count extensions to Numbers */\n",
		  NUM_NUMBERS(term) - NUMCOUNT);
    (void) printf("\t\t%d,\t\t/* count extensions to Strings */\n",
		  NUM_STRINGS(term) - STRCOUNT);

    (void) printf("#endif /* NCURSES_XNAMES */\n");
#else
    (void) term;
#endif /* NCURSES_XNAMES */
    (void) printf("\t%s\n", R_CURL);
}

static int
optarg_to_number(void)
{
    char *temp = 0;
    long value = strtol(optarg, &temp, 0);

    if (temp == 0 || temp == optarg || *temp != 0) {
	fprintf(stderr, "Expected a number, not \"%s\"\n", optarg);
	ExitProgram(EXIT_FAILURE);
    }
    return (int) value;
}

static char *
terminal_env(void)
{
    char *terminal;

    if ((terminal = getenv("TERM")) == 0) {
	(void) fprintf(stderr,
		       "%s: environment variable TERM not set\n",
		       _nc_progname);
	exit(EXIT_FAILURE);
    }
    return terminal;
}

/***************************************************************************
 *
 * Main sequence
 *
 ***************************************************************************/

int
main(int argc, char *argv[])
{
    /* Avoid "local data >32k" error with mwcc */
    /* Also avoid overflowing smaller stacks on systems like AmigaOS */
    path *tfile = 0;
    char **tname = 0;
    int maxterms;

    char **myargv;

    char *firstdir, *restdir;
    int c, i, len;
    bool formatted = FALSE;
    bool filecompare = FALSE;
    int initdump = 0;
    bool init_analyze = FALSE;
    bool suppress_untranslatable = FALSE;

    if (pledge("stdio rpath", NULL) == -1) {
	perror("pledge");
	exit(1);
    }

    /* where is the terminfo database location going to default to? */
    restdir = firstdir = 0;

#if NCURSES_XNAMES
    use_extended_names(FALSE);
#endif

    _nc_progname = _nc_rootname(argv[0]);

    /* make sure we have enough space to add two terminal entries */
    myargv = typeCalloc(char *, (size_t) (argc + 3));
    memcpy(myargv, argv, (sizeof(char *) * (size_t) argc));
    argv = myargv;

    while ((c = getopt(argc,
		       argv,
		       "1A:aB:CcdEeFfGgIiLlnpqR:rs:TtUuVv:w:x")) != -1) {
	switch (c) {
	case '1':
	    mwidth = 0;
	    break;

	case 'A':
	    firstdir = optarg;
	    break;

#if NCURSES_XNAMES
	case 'a':
	    _nc_disable_period = TRUE;
	    use_extended_names(TRUE);
	    break;
#endif
	case 'B':
	    restdir = optarg;
	    break;

	case 'C':
	    outform = F_TERMCAP;
	    tversion = "BSD";
	    if (sortmode == S_DEFAULT)
		sortmode = S_TERMCAP;
	    break;

	case 'c':
	    compare = C_COMMON;
	    break;

	case 'd':
	    compare = C_DIFFERENCE;
	    break;

	case 'E':
	    initdump |= 2;
	    break;

	case 'e':
	    initdump |= 1;
	    break;

	case 'F':
	    filecompare = TRUE;
	    break;

	case 'f':
	    formatted = TRUE;
	    break;

	case 'G':
	    numbers = 1;
	    break;

	case 'g':
	    numbers = -1;
	    break;

	case 'I':
	    outform = F_TERMINFO;
	    if (sortmode == S_DEFAULT)
		sortmode = S_VARIABLE;
	    tversion = 0;
	    break;

	case 'i':
	    init_analyze = TRUE;
	    break;

	case 'L':
	    outform = F_VARIABLE;
	    if (sortmode == S_DEFAULT)
		sortmode = S_VARIABLE;
	    break;

	case 'l':
	    outform = F_TERMINFO;
	    break;

	case 'n':
	    compare = C_NAND;
	    break;

	case 'p':
	    ignorepads = TRUE;
	    break;

	case 'q':
	    quiet = TRUE;
	    s_absent = "-";
	    s_cancel = "@@";
	    bool_sep = ", ";
	    break;

	case 'R':
	    tversion = optarg;
	    break;

	case 'r':
	    tversion = 0;
	    break;

	case 's':
	    if (*optarg == 'd')
		sortmode = S_NOSORT;
	    else if (*optarg == 'i')
		sortmode = S_TERMINFO;
	    else if (*optarg == 'l')
		sortmode = S_VARIABLE;
	    else if (*optarg == 'c')
		sortmode = S_TERMCAP;
	    else {
		(void) fprintf(stderr,
			       "%s: unknown sort mode\n",
			       _nc_progname);
		ExitProgram(EXIT_FAILURE);
	    }
	    break;

	case 'T':
	    limited = FALSE;
	    break;

#if NCURSES_XNAMES
	case 't':
	    _nc_disable_period = FALSE;
	    suppress_untranslatable = TRUE;
	    break;
#endif

	case 'U':
	    literal = TRUE;
	    break;

	case 'u':
	    compare = C_USEALL;
	    break;

	case 'V':
	    puts(curses_version());
	    ExitProgram(EXIT_SUCCESS);

	case 'v':
	    itrace = optarg_to_number();
	    set_trace_level(itrace);
	    break;

	case 'w':
	    mwidth = optarg_to_number();
	    break;

#if NCURSES_XNAMES
	case 'x':
	    use_extended_names(TRUE);
	    break;
#endif

	default:
	    usage();
	}
    }

    maxterms = (argc + 2 - optind);
    tfile = typeMalloc(path, maxterms);
    tname = typeCalloc(char *, maxterms);
    entries = typeCalloc(ENTRY, maxterms);

    if (tfile == 0
	|| tname == 0
	|| entries == 0) {
	fprintf(stderr, "%s: not enough memory\n", _nc_progname);
	ExitProgram(EXIT_FAILURE);
    }

    /* by default, sort by terminfo name */
    if (sortmode == S_DEFAULT)
	sortmode = S_TERMINFO;

    /* set up for display */
    dump_init(tversion, outform, sortmode, mwidth, itrace, formatted);

    /* make sure we have at least one terminal name to work with */
    if (optind >= argc)
	argv[argc++] = terminal_env();

    /* if user is after a comparison, make sure we have two entries */
    if (compare != C_DEFAULT && optind >= argc - 1)
	argv[argc++] = terminal_env();

    /* exactly two terminal names with no options means do -d */
    if (argc - optind == 2 && compare == C_DEFAULT)
	compare = C_DIFFERENCE;

    if (!filecompare) {
	/* grab the entries */
	termcount = 0;
	for (; optind < argc; optind++) {
	    const char *directory = termcount ? restdir : firstdir;
	    int status;

	    tname[termcount] = argv[optind];

	    if (directory) {
#if USE_DATABASE
#if MIXEDCASE_FILENAMES
#define LEAF_FMT "%c"
#else
#define LEAF_FMT "%02x"
#endif
		(void) snprintf(tfile[termcount], sizeof (path),
		    	       "%s/" LEAF_FMT "/%s", directory,
			       UChar(*argv[optind]), argv[optind]);
		if (itrace)
		    (void) fprintf(stderr,
				   "%s: reading entry %s from file %s\n",
				   _nc_progname,
				   argv[optind], tfile[termcount]);

		status = _nc_read_file_entry(tfile[termcount],
					     &entries[termcount].tterm);		
#else
		(void) fprintf(stderr, "%s: terminfo files not supported\n",
			       _nc_progname);
		ExitProgram(EXIT_FAILURE);
#endif
	    } else {
		if (itrace)
		    (void) fprintf(stderr,
				   "%s: reading entry %s from database\n",
				   _nc_progname,
				   tname[termcount]);

		status = _nc_read_entry(tname[termcount],
					tfile[termcount],
					&entries[termcount].tterm);
		directory = TERMINFO;	/* for error message */
	    }

	    if (status <= 0) {
		(void) fprintf(stderr,
			       "%s: couldn't open terminfo file %s.\n",
			       _nc_progname,
			       tfile[termcount]);
		ExitProgram(EXIT_FAILURE);
	    }
	    repair_acsc(&entries[termcount].tterm);
	    termcount++;
	}

#if NCURSES_XNAMES
	if (termcount > 1)
	    _nc_align_termtype(&entries[0].tterm, &entries[1].tterm);
#endif

	/* dump as C initializer for the terminal type */
	if (initdump) {
	    if (initdump & 1)
		dump_termtype(&entries[0].tterm);
	    if (initdump & 2)
		dump_initializers(&entries[0].tterm);
	}

	/* analyze the init strings */
	else if (init_analyze) {
#undef CUR
#define CUR	entries[0].tterm.
	    analyze_string("is1", init_1string, &entries[0].tterm);
	    analyze_string("is2", init_2string, &entries[0].tterm);
	    analyze_string("is3", init_3string, &entries[0].tterm);
	    analyze_string("rs1", reset_1string, &entries[0].tterm);
	    analyze_string("rs2", reset_2string, &entries[0].tterm);
	    analyze_string("rs3", reset_3string, &entries[0].tterm);
	    analyze_string("smcup", enter_ca_mode, &entries[0].tterm);
	    analyze_string("rmcup", exit_ca_mode, &entries[0].tterm);
#undef CUR
	} else {

	    /*
	     * Here's where the real work gets done
	     */
	    switch (compare) {
	    case C_DEFAULT:
		if (itrace)
		    (void) fprintf(stderr,
				   "%s: about to dump %s\n",
				   _nc_progname,
				   tname[0]);
		(void) printf("#\tReconstructed via infocmp from file: %s\n",
			      tfile[0]);
		dump_entry(&entries[0].tterm,
			   suppress_untranslatable,
			   limited,
			   numbers,
			   NULL);
		len = show_entry();
		if (itrace)
		    (void) fprintf(stderr, "%s: length %d\n", _nc_progname, len);
		break;

	    case C_DIFFERENCE:
		if (itrace)
		    (void) fprintf(stderr, "%s: dumping differences\n", _nc_progname);
		(void) printf("comparing %s to %s.\n", tname[0], tname[1]);
		compare_entry(compare_predicate, &entries->tterm, quiet);
		break;

	    case C_COMMON:
		if (itrace)
		    (void) fprintf(stderr,
				   "%s: dumping common capabilities\n",
				   _nc_progname);
		(void) printf("comparing %s to %s.\n", tname[0], tname[1]);
		compare_entry(compare_predicate, &entries->tterm, quiet);
		break;

	    case C_NAND:
		if (itrace)
		    (void) fprintf(stderr,
				   "%s: dumping differences\n",
				   _nc_progname);
		(void) printf("comparing %s to %s.\n", tname[0], tname[1]);
		compare_entry(compare_predicate, &entries->tterm, quiet);
		break;

	    case C_USEALL:
		if (itrace)
		    (void) fprintf(stderr, "%s: dumping use entry\n", _nc_progname);
		dump_entry(&entries[0].tterm,
			   suppress_untranslatable,
			   limited,
			   numbers,
			   use_predicate);
		for (i = 1; i < termcount; i++)
		    dump_uses(tname[i], !(outform == F_TERMCAP
					  || outform == F_TCONVERR));
		len = show_entry();
		if (itrace)
		    (void) fprintf(stderr, "%s: length %d\n", _nc_progname, len);
		break;
	    }
	}
    } else if (compare == C_USEALL)
	(void) fprintf(stderr, "Sorry, -u doesn't work with -F\n");
    else if (compare == C_DEFAULT)
	(void) fprintf(stderr, "Use `tic -[CI] <file>' for this.\n");
    else if (argc - optind != 2)
	(void) fprintf(stderr,
		       "File comparison needs exactly two file arguments.\n");
    else
	file_comparison(argc - optind, argv + optind);

#if NO_LEAKS
    free(myargv);
    free(tfile);
    free(tname);
#endif
    ExitProgram(EXIT_SUCCESS);
}

/* infocmp.c ends here */
@


1.22
log
@exit() after perror() for pledge failure.  Perhaps this got introduced
as a test idiom, either when pledge was young or during the transition
to strings.... dunno
@
text
@d1 1
a1 1
/*	$OpenBSD: infocmp.c,v 1.21 2015/10/10 15:08:49 deraadt Exp $	*/
d47 1
a47 1
MODULE_ID("$Id: infocmp.c,v 1.21 2015/10/10 15:08:49 deraadt Exp $")
d631 1
a631 1
	    if (strnames[i][0] == 'k' && strnames[i][0] == 'f')
@


1.21
log
@pledge "stdio rpath" seems to work; ok doug
@
text
@d1 1
a1 1
/*	$OpenBSD: infocmp.c,v 1.20 2010/01/12 23:22:13 nicm Exp $	*/
d47 1
a47 1
MODULE_ID("$Id: infocmp.c,v 1.20 2010/01/12 23:22:13 nicm Exp $")
d1285 1
a1285 1
    if (pledge("stdio rpath", NULL) == -1)
d1287 2
@


1.20
log
@Update to ncurses 5.7, with local changes reapplied.

This is around eight years worth of changes (previously we were around ncurses
5.2), too many to list - many bug fixes and also a few new functions.

A major bump for libcurses, libpanel, libform and libmenu.

ok deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: infocmp.c,v 1.16 2003/04/06 18:41:03 deraadt Exp $	*/
d47 1
a47 1
MODULE_ID("$Id: infocmp.c,v 1.103 2008/08/16 22:04:56 tom Exp $")
d1284 3
@


1.19
log
@safer snprintf construct with more paranoid length calculation
ok millert
@
text
@d1 1
a1 1
/*	$OpenBSD: infocmp.c,v 1.18 2006/12/06 04:59:58 ray Exp $	*/
d4 1
a4 1
 * Copyright (c) 1998,1999,2000 Free Software Foundation, Inc.              *
d34 1
d40 1
a44 1
#include <term_entry.h>
d47 1
a47 1
MODULE_ID("$From: infocmp.c,v 1.60 2001/02/24 22:03:12 tom Exp $")
a51 1
#define MAXTERMS	32	/* max # terminal arguments we can handle */
d65 1
a65 2
static char *tname[MAXTERMS];	/* terminal type names */
static ENTRY entries[MAXTERMS];	/* terminfo entries */
d70 1
d92 2
d95 1
a95 4
ExitProgram(int code) GCC_NORETURN;
/* prototype is to get gcc to accept the noreturn attribute */
     static void
       ExitProgram(int code)
d100 2
a101 1
    _nc_free_and_exit(code);
d125 1
a125 1
capcmp(int idx, const char *s, const char *t)
d140 1
a140 1
use_predicate(int type, int idx)
d226 1
a226 1
    int i, j;
d250 1
a250 1
entryeq(TERMTYPE * t1, TERMTYPE * t2)
d253 1
a253 1
    int i;
d264 1
a264 1
	if (capcmp(i, t1->Strings[i], t2->Strings[i]))
d273 1
a273 1
print_uses(ENTRY * ep, FILE * fp)
d276 1
a276 1
    int i;
d337 1
a337 1
compare_predicate(int type, int idx, const char *name)
d479 1
a479 1
    /* these are DEC private modes widely supported by emulators */
d483 2
d489 10
d549 57
d607 1
a607 1
analyze_string(const char *name, const char *cap, TERMTYPE * tp)
a608 1
    char buf[MAX_TERMINFO_LENGTH];
d610 1
a610 1
    const char *sp, *ep;
d612 1
a617 1
    buf[0] = '\0';
d620 1
d622 1
d624 1
d662 2
a663 1
	if (!expansion)
d665 2
d668 4
a671 2

		if (strncmp(ap->from, sp, len) == 0) {
d673 2
d678 18
d699 6
a704 4
	    && sp[0] == '\033' && sp[1] == '[' && sp[2] == '?'
	    && (len = strspn(sp + 3, "0123456789;"))
	    && ((sp[3 + len] == 'h') || (sp[3 + len] == 'l'))) {
	    char buf3[MAX_TERMINFO_LENGTH];
d706 1
a706 1
	    (void) strlcpy(buf2, (sp[3 + len] == 'h') ? "DEC+" : "DEC-",
d708 1
a708 2
	    (void) strncpy(buf3, sp + 3, len);
	    len += 4;
d710 1
d712 1
a712 22
	    ep = strtok(buf3, ";");
	    do {
		bool found = FALSE;

		for (ap = private_modes; ap->from; ap++) {
		    size_t tlen = strlen(ap->from);

		    if (strncmp(ap->from, ep, tlen) == 0) {
			(void) strlcat(buf2, ap->to, sizeof buf2);
			found = TRUE;
			break;
		    }
		}

		if (!found)
		    (void) strlcat(buf2, ep, sizeof buf2);
		(void) strlcat(buf2, ";", sizeof buf2);
	    } while
		((ep = strtok((char *) 0, ";")));
	    if (buf2[0] != '\0' && buf2[strlen(buf2) - 1] == ';')
		    buf2[strlen(buf2) - 1] = '\0';
	    expansion = buf2;
d717 5
a721 4
	    && sp[0] == '\033' && sp[1] == '['
	    && (len = strspn(sp + 2, "0123456789;"))
	    && sp[2 + len] == 'm') {
	    char buf3[MAX_TERMINFO_LENGTH];
d724 1
a724 2
	    (void) strncpy(buf3, sp + 2, len);
	    len += 3;
d726 1
d728 2
a729 13
	    ep = strtok(buf3, ";");
	    do {
		bool found = FALSE;

		for (ap = ecma_highlights; ap->from; ap++) {
		    size_t tlen = strlen(ap->from);

		    if (strncmp(ap->from, ep, tlen) == 0) {
			(void) strlcat(buf2, ap->to, sizeof buf2);
			found = TRUE;
			break;
		    }
		}
d731 6
a736 8
		if (!found)
		    (void) strlcat(buf2, ep, sizeof buf2);
		(void) strlcat(buf2, ";", sizeof buf2);
	    } while
		((ep = strtok((char *) 0, ";")));

	    if (buf2[0] != '\0' && buf2[strlen(buf2) - 1] == ';')
		    buf2[strlen(buf2) - 1] = '\0';
d739 1
d741 3
a743 4
	if (!expansion) {
	    (void) snprintf(buf2, sizeof buf2, "\033[1;%dr", tp->Numbers[2]);
	    len = strlen(buf2);
	    if (strncmp(buf2, sp, len) == 0)
d745 8
d756 3
a758 2
	if (!expansion) {
	    (void) snprintf(buf2, sizeof buf2, "\033[%d;1H", tp->Numbers[2]);
d760 1
a760 1
	    if (strncmp(buf2, sp, len) == 0)
d762 8
d774 1
a774 2
	    (void) snprintf(buf + strlen(buf), sizeof buf - strlen(buf),
		"{%s}", expansion);
a775 1
	    continue;
d780 1
a780 1
	    (void) strlcat(buf, TIC_EXPAND(buf2), sizeof buf);
d783 1
a783 1
    (void) printf("%s\n", buf);
d802 1
d813 1
a813 1
	_nc_read_entry_source(stdin, NULL, TRUE, FALSE, NULLHOOK);
d819 1
a819 1
	if (!_nc_resolve_uses(!limited)) {
d829 1
a829 1
	    exit(EXIT_FAILURE);
d946 2
a947 1
				       "infocmp: dumping differences\n");
d955 2
a956 1
				       "infocmp: dumping common capabilities\n");
d964 2
a965 1
				       "infocmp: dumping differences\n");
d991 1
d1011 3
d1017 3
d1033 1
a1033 1
    exit(EXIT_FAILURE);
d1037 1
a1037 1
name_initializer(const char *type)
d1044 1
a1044 1
	len = strlen(entries->tterm.term_names) + 20;
d1048 1
a1048 1
    (void) snprintf(initializer, len, "%s_data_%s", type, entries->tterm.term_names);
d1050 1
a1050 1
	if (!isalnum(CharOf(*s)))
d1054 1
d1058 12
d1072 1
a1072 1
dump_initializers(TERMTYPE * term)
d1074 1
a1074 1
    int n;
d1076 31
a1106 1
    int size;
d1128 1
a1128 1
	(void) printf("\t/* %3d: %-8s */\t%s,\n",
d1149 1
a1149 1
	(void) printf("\t/* %3d: %-8s */\t%s,\n", n,
a1153 4
    size = sizeof(TERMTYPE)
	+ (NUM_BOOLEANS(term) * sizeof(term->Booleans[0]))
	+ (NUM_NUMBERS(term) * sizeof(term->Numbers[0]));

a1156 1
	char buf[MAX_STRING], *sp, *tp;
d1163 1
a1163 19
	    tp = buf;
	    *tp++ = '"';
	    for (sp = term->Strings[n];
		 *sp != 0 && (tp - buf) < MAX_STRING - 6;
		 sp++) {
		if (isascii(CharOf(*sp))
		    && isprint(CharOf(*sp))
		    && *sp != '\\'
		    && *sp != '"')
		    *tp++ = *sp;
		else {
		    (void) snprintf(tp, buf + sizeof buf - tp, "\\%03o", CharOf(*sp));
		    tp += strlen(tp);
		}
	    }
	    *tp++ = '"';
	    *tp = '\0';
	    size += (strlen(term->Strings[n]) + 1);
	    str = buf;
d1165 5
d1171 16
a1186 5
	if (n == STRCOUNT) {
	    (void) printf("%s;\n", R_CURL);

	    (void) printf("static char * %s[] = %s\n",
			  name_initializer("string_ext"), L_CURL);
d1188 2
a1190 4
	(void) printf("\t/* %3d: %-8s */\t%s,\n", n,
		      ExtStrname(term, n, strnames), str);
    }
    (void) printf("%s;\n", R_CURL);
d1195 1
a1195 1
dump_termtype(TERMTYPE * term)
d1197 1
a1197 1
    (void) printf("\t%s\n\t\t\"%s\",\n", L_CURL, term->term_names);
d1209 3
a1211 1
		  (NUM_STRINGS(term) != STRCOUNT)
d1227 2
d1241 14
d1257 1
a1257 1
    return (int) value;
a1268 1
    char *terminal, *firstdir, *restdir;
d1271 7
a1277 2
    size_t tlen = sizeof(path) * MAXTERMS;
    path *tfile = (path *) malloc(tlen);
d1283 1
a1283 6

    if ((terminal = getenv("TERM")) == 0) {
	(void) fprintf(stderr,
		       "infocmp: environment variable TERM not set\n");
	return EXIT_FAILURE;
    }
d1288 14
a1301 1
    while ((c = getopt(argc, argv, "adeEcCfFGgIinlLpqrR:s:uv:Vw:A:B:1T")) != -1)
d1303 8
d1317 15
a1335 4
	case 'e':
	    initdump |= 1;
	    break;

d1340 2
a1341 2
	case 'c':
	    compare = C_COMMON;
d1344 2
a1345 5
	case 'C':
	    outform = F_TERMCAP;
	    tversion = "BSD";
	    if (sortmode == S_DEFAULT)
		sortmode = S_TERMCAP;
a1359 4
	case 'F':
	    filecompare = TRUE;
	    break;

a1370 4
	case 'l':
	    outform = F_TERMINFO;
	    break;

d1377 4
d1396 4
a1401 5
	    limited = FALSE;
	    break;

	case 'R':
	    tversion = optarg;
d1415 3
a1417 2
			       "infocmp: unknown sort mode\n");
		return EXIT_FAILURE;
d1421 15
d1440 4
a1448 4
	case 'V':
	    puts(curses_version());
	    ExitProgram(EXIT_SUCCESS);

d1453 3
a1455 10
	case 'A':
	    firstdir = optarg;
	    break;

	case 'B':
	    restdir = optarg;
	    break;

	case '1':
	    mwidth = 0;
d1457 1
a1458 3
	case 'T':
	    limited = FALSE;
	    break;
d1462 13
d1485 1
a1485 1
	argv[argc++] = terminal;
d1489 1
a1489 1
	argv[argc++] = terminal;
d1499 2
a1500 7
	    if (termcount >= MAXTERMS) {
		(void) fprintf(stderr,
			       "infocmp: too many terminal type arguments\n");
		return EXIT_FAILURE;
	    } else {
		const char *directory = termcount ? restdir : firstdir;
		int status;
d1502 1
a1502 1
		tname[termcount] = argv[optind];
d1504 35
a1538 10
		if (directory) {
		    (void) snprintf(tfile[termcount],
				    tlen - termcount,
				   "%s/%c/%s",
				   directory,
				   *argv[optind], argv[optind]);
		    if (itrace)
			(void) fprintf(stderr,
				       "infocmp: reading entry %s from file %s\n",
				       argv[optind], tfile[termcount]);
d1540 6
a1545 22
		    status = _nc_read_file_entry(tfile[termcount],
						 &entries[termcount].tterm);
		} else {
		    if (itrace)
			(void) fprintf(stderr,
				       "infocmp: reading entry %s from system directories %s\n",
				       argv[optind], tname[termcount]);

		    status = _nc_read_entry(tname[termcount],
					    tfile[termcount],
					    &entries[termcount].tterm);
		    directory = TERMINFO;	/* for error message */
		}

		if (status <= 0) {
		    (void) fprintf(stderr,
				   "infocmp: couldn't open terminfo file %s.\n",
				   tfile[termcount]);
		    return EXIT_FAILURE;
		}
		repair_acsc(&entries[termcount].tterm);
		termcount++;
d1547 2
a1561 1
	    ExitProgram(EXIT_SUCCESS);
d1565 1
a1565 1
	if (init_analyze) {
d1577 1
a1577 2
	    ExitProgram(EXIT_SUCCESS);
	}
d1579 21
a1599 16
	/*
	 * Here's where the real work gets done
	 */
	switch (compare) {
	case C_DEFAULT:
	    if (itrace)
		(void) fprintf(stderr,
			       "infocmp: about to dump %s\n",
			       tname[0]);
	    (void) printf("#\tReconstructed via infocmp from file: %s\n",
			  tfile[0]);
	    len = dump_entry(&entries[0].tterm, limited, numbers, NULL);
	    putchar('\n');
	    if (itrace)
		(void) fprintf(stderr, "infocmp: length %d\n", len);
	    break;
d1601 6
a1606 6
	case C_DIFFERENCE:
	    if (itrace)
		(void) fprintf(stderr, "infocmp: dumping differences\n");
	    (void) printf("comparing %s to %s.\n", tname[0], tname[1]);
	    compare_entry(compare_predicate, &entries->tterm, quiet);
	    break;
d1608 8
a1615 7
	case C_COMMON:
	    if (itrace)
		(void) fprintf(stderr,
			       "infocmp: dumping common capabilities\n");
	    (void) printf("comparing %s to %s.\n", tname[0], tname[1]);
	    compare_entry(compare_predicate, &entries->tterm, quiet);
	    break;
d1617 8
a1624 7
	case C_NAND:
	    if (itrace)
		(void) fprintf(stderr,
			       "infocmp: dumping differences\n");
	    (void) printf("comparing %s to %s.\n", tname[0], tname[1]);
	    compare_entry(compare_predicate, &entries->tterm, quiet);
	    break;
d1626 16
a1641 11
	case C_USEALL:
	    if (itrace)
		(void) fprintf(stderr, "infocmp: dumping use entry\n");
	    len = dump_entry(&entries[0].tterm, limited, numbers, use_predicate);
	    for (i = 1; i < termcount; i++)
		len += dump_uses(tname[i], !(outform == F_TERMCAP || outform
					     == F_TCONVERR));
	    putchar('\n');
	    if (itrace)
		(void) fprintf(stderr, "infocmp: length %d\n", len);
	    break;
d1653 5
@


1.18
log
@Don't access buf[strlen(buf) - 1] for zero-length strings.

OK jaredy@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: infocmp.c,v 1.17 2003/04/08 19:08:58 deraadt Exp $	*/
d1046 1
a1046 1
		    tp += 4;
@


1.17
log
@string cleanup; ok tdeval
@
text
@d1 1
a1 1
/*	$OpenBSD: infocmp.c,v 1.16 2003/04/06 18:41:03 deraadt Exp $	*/
d633 2
a634 1
	    buf2[strlen(buf2) - 1] = '\0';
d670 2
a671 1
	    buf2[strlen(buf2) - 1] = '\0';
@


1.16
log
@string fixes; ok millert krw
@
text
@d1 1
a1 1
/*	$OpenBSD: infocmp.c,v 1.15 2001/11/19 19:02:14 mpech Exp $	*/
d690 2
a691 1
	    (void) sprintf(buf + strlen(buf), "{%s}", expansion);
d1043 1
a1043 1
		    (void) sprintf(tp, "\\%03o", CharOf(*sp));
d1127 2
a1128 1
    path *tfile = (path *) malloc(sizeof(path) * MAXTERMS);
d1322 3
a1324 1
		    (void) sprintf(tfile[termcount], "%s/%c/%s",
@


1.15
log
@kill more registers

millert@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: infocmp.c,v 1.14 2001/10/24 13:06:36 mpech Exp $	*/
d106 1
a106 1
canonical_name(char *ptr, char *buf)
d111 1
a111 1
    (void) strcpy(buf, ptr);
d307 1
a307 1
dump_numeric(int val, char *buf)
d312 1
a312 1
	strcpy(buf, s_absent);
d315 1
a315 1
	strcpy(buf, s_cancel);
d318 1
a318 1
	sprintf(buf, "%d", val);
d324 1
a324 1
dump_string(char *val, char *buf)
d328 1
a328 1
	strcpy(buf, s_absent);
d330 1
a330 1
	strcpy(buf, s_cancel);
d332 1
a332 1
	sprintf(buf, "'%.*s'", MAX_STRING - 3, TIC_EXPAND(val));
d376 2
a377 2
	dump_numeric(n1, buf1);
	dump_numeric(n2, buf2);
d402 2
a403 2
		dump_string(s1, buf1);
		dump_string(s2, buf2);
d608 2
a609 1
	    (void) strcpy(buf2, (sp[3 + len] == 'h') ? "DEC+" : "DEC-");
d622 1
a622 1
			(void) strcat(buf2, ap->to);
d629 2
a630 2
		    (void) strcat(buf2, ep);
		(void) strcat(buf2, ";");
d644 1
a644 1
	    (void) strcpy(buf2, "SGR:");
d657 1
a657 1
			(void) strcat(buf2, ap->to);
d664 2
a665 2
		    (void) strcat(buf2, ep);
		(void) strcat(buf2, ";");
d674 1
a674 1
	    (void) sprintf(buf2, "\033[1;%dr", tp->Numbers[2]);
d682 1
a682 1
	    (void) sprintf(buf2, "\033[%d;1H", tp->Numbers[2]);
d697 1
a697 1
	    (void) strcat(buf, TIC_EXPAND(buf2));
d831 2
a832 2
		(void) canonical_name(qp->tterm.term_names, name1);
		(void) canonical_name(rp->tterm.term_names, name2);
d855 2
a856 2
		(void) canonical_name(qp->tterm.term_names, name1);
		(void) canonical_name(rp->tterm.term_names, name2);
d946 1
d949 4
a952 2
    if (initializer == 0)
	initializer = (char *) malloc(strlen(entries->tterm.term_names) + 20);
d954 1
a954 1
    (void) sprintf(initializer, "%s_data_%s", type, entries->tterm.term_names);
d1008 1
a1008 1
	    sprintf(buf, "%d", term->Numbers[n]);
@


1.14
log
@getopt(3) returns -1 when out of args, not EOF.

millert@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: infocmp.c,v 1.13 2001/02/28 22:58:52 millert Exp $	*/
d340 2
a341 2
    register ENTRY *e1 = &entries[0];
    register ENTRY *e2 = &entries[1];
@


1.13
log
@ncurses-5.2-20010224
@
text
@d1 1
a1 1
/*	$OpenBSD: infocmp.c,v 1.12 2001/01/22 18:02:18 millert Exp $	*/
d1138 1
a1138 1
    while ((c = getopt(argc, argv, "adeEcCfFGgIinlLpqrR:s:uv:Vw:A:B:1T")) != EOF)
@


1.12
log
@Update to ncurses-5.2-20010114
@
text
@d1 1
a1 1
/*	$OpenBSD: infocmp.c,v 1.11 2000/10/08 22:47:12 millert Exp $	*/
d46 1
a46 1
MODULE_ID("$From: infocmp.c,v 1.59 2000/11/05 00:22:07 tom Exp $")
a714 1
    ENTRY *tails[MAXCOMPARE];
a747 1
	tails[filecount] = _nc_tail;
@


1.11
log
@update to ncurses-5.1-20001007
@
text
@d1 1
a1 1
/*	$OpenBSD: infocmp.c,v 1.10 2000/03/26 16:45:04 millert Exp $	*/
d46 1
a46 1
MODULE_ID("$From: infocmp.c,v 1.57 2000/10/01 01:26:25 tom Exp $")
d954 1
a954 1
	if (!isalnum(*s))
d1034 4
a1037 1
		if (isascii(*sp) && isprint(*sp) && *sp != '\\' && *sp != '"')
d1040 1
a1040 1
		    (void) sprintf(tp, "\\%03o", *sp & 0xff);
@


1.10
log
@Update to ncurses-5.0-20000325
@
text
@d1 1
a1 1
/*	$OpenBSD: infocmp.c,v 1.9 2000/03/13 23:53:41 millert Exp $	*/
d46 1
a46 1
MODULE_ID("$From: infocmp.c,v 1.54 2000/03/19 02:56:14 tom Exp $")
d78 1
a78 1
static int outform = F_TERMINFO;/* output format */
d95 2
a96 2
static void
ExitProgram(int code)
d355 4
a358 4
		    name,
		    dump_boolean(b1),
		    bool_sep,
		    dump_boolean(b2));
d737 2
a738 2
		"There are unresolved use entries in %s:\n",
		argv[n]);
d778 5
a782 5
		"%s in file 1 (%s) has %d matches in file 2 (%s):\n",
		_nc_first_name(qp->tterm.term_names),
		argv[0],
		qp->ncrosslinks,
		argv[1]);
d785 2
a786 2
		    "\t%s\n",
		    _nc_first_name((qp->crosslinks[i])->tterm.term_names));
d793 5
a797 5
		"%s in file 2 (%s) has %d matches in file 1 (%s):\n",
		_nc_first_name(rp->tterm.term_names),
		argv[1],
		rp->ncrosslinks,
		argv[0]);
d800 2
a801 2
		    "\t%s\n",
		    _nc_first_name((rp->crosslinks[i])->tterm.term_names));
d809 1
a809 1
		_nc_first_name(qp->tterm.term_names));
d815 1
a815 1
		_nc_first_name(rp->tterm.term_names));
d863 1
a863 1
			    "infocmp: dumping differences\n");
d871 1
a871 1
			    "infocmp: dumping common capabilities\n");
d879 1
a879 1
			    "infocmp: dumping differences\n");
d929 1
a929 1
    const size_t last = sizeof(tbl) / sizeof(tbl[0]);
d990 1
a990 1
	    n, ExtBoolname(term, n, boolnames), str);
d1010 2
a1011 2
	(void) printf("\t/* %3d: %-8s */\t%s,\n", n, ExtNumname(term, n,
		numnames), str);
d1032 2
a1033 2
		*sp != 0 && (tp - buf) < MAX_STRING - 6;
		sp++) {
d1051 1
a1051 1
		name_initializer("string_ext"), L_CURL);
d1054 2
a1055 2
	(void) printf("\t/* %3d: %-8s */\t%s,\n", n, ExtStrname(term, n,
		strnames), str);
d1076 3
a1078 3
	(NUM_STRINGS(term) != STRCOUNT)
	? name_initializer("string_ext")
	: "(char **)0");
d1085 1
a1085 1
	NUM_BOOLEANS(term) - BOOLCOUNT);
d1087 1
a1087 1
	NUM_NUMBERS(term) - NUMCOUNT);
d1089 1
a1089 1
	NUM_STRINGS(term) - STRCOUNT);
d1096 13
d1130 1
a1130 1
	    "infocmp: environment variable TERM not set\n");
d1240 1
a1240 1
		    "infocmp: unknown sort mode\n");
d1250 1
a1250 1
	    itrace = atoi(optarg);
d1255 1
a1255 2
	    (void) fputs(NCURSES_VERSION, stdout);
	    putchar('\n');
d1259 1
a1259 1
	    mwidth = atoi(optarg);
d1306 1
a1306 1
		    "infocmp: too many terminal type arguments\n");
d1316 2
a1317 2
			directory,
			*argv[optind], argv[optind]);
d1320 2
a1321 2
			    "infocmp: reading entry %s from file %s\n",
			    argv[optind], tfile[termcount]);
d1324 1
a1324 1
			&entries[termcount].tterm);
d1328 2
a1329 2
			    "infocmp: reading entry %s from system directories %s\n",
			    argv[optind], tname[termcount]);
d1332 2
a1333 2
			tfile[termcount],
			&entries[termcount].tterm);
d1339 2
a1340 2
			"infocmp: couldn't open terminfo file %s.\n",
			tfile[termcount]);
d1385 2
a1386 2
		    "infocmp: about to dump %s\n",
		    tname[0]);
d1388 1
a1388 1
		tfile[0]);
d1405 1
a1405 1
		    "infocmp: dumping common capabilities\n");
d1413 1
a1413 1
		    "infocmp: dumping differences\n");
d1424 1
a1424 1
			== F_TCONVERR));
d1436 1
a1436 1
	    "File comparison needs exactly two file arguments.\n");
@


1.9
log
@update to ncurses-5.0-20000311
@
text
@d1 1
a1 1
/*	$OpenBSD: infocmp.c,v 1.8 2000/01/16 01:35:19 millert Exp $	*/
d46 1
a46 1
MODULE_ID("$From: infocmp.c,v 1.52 2000/03/12 02:34:09 tom Exp $")
d71 3
a73 3
static char *bool_sep = ":";
static char *s_absent = "NULL";
static char *s_cancel = "NULL";
d288 1
a288 1
static char *
d906 3
d1124 1
a1124 1
    while ((c = getopt(argc, argv, "deEcCfFGgIinlLpqrR:s:uv:Vw:A:B:1T")) != EOF)
d1126 6
@


1.8
log
@Update to ncurses-5.0-20000115:
+ additional fixes for non-bce terminals (handling of delete_character)
to work when assume_default_colors() is not specified.
+ modify warning message from _nc_parse_entry() regarding extended
capability names to print only if tic/infocmp/toe have the -v flag
set, and not at all in ordinary user applications.  Otherwise, this
warning would be shown for screen's extended capabilities in programs
that use the termcap interface.
+ modify use of _nc_tracing from programs such as tic so their debug
level is not in the same range as values set by trace() function.
+ small panel header cleanup (patch by Juergen Pfeifer).
@
text
@d1 1
a1 1
/*	$OpenBSD: infocmp.c,v 1.7 1999/12/06 02:14:34 millert Exp $	*/
d4 1
a4 1
 * Copyright (c) 1998-2000 Free Software Foundation, Inc.                   *
d46 1
a46 1
MODULE_ID("$From: infocmp.c,v 1.48 2000/01/15 22:46:12 tom Exp $")
d52 1
d66 1
a66 1
static TERMTYPE term[MAXTERMS];	/* terminfo entries */
d69 5
d75 2
d78 1
a78 1
static int outform = F_TERMINFO;	/* output format */
a79 2
static int itrace;		/* trace flag for debugging */
static int mwidth = 60;
d99 1
a99 1
	_nc_free_termtype(&term[termcount]);
d112 1
a112 1
    if ((bp = strchr(buf, '|')) != (char *) NULL)
d125 1
a125 1
capcmp(const char *s, const char *t)
d129 1
a129 1
	return (0);
d133 3
a135 1
    if (ignorepads)
a136 2
    else
	return (strcmp(s, t));
d143 1
a143 1
    TERMTYPE *tp;
d146 2
a147 1
    case BOOLEAN:{
d156 4
d161 3
a163 3
	    for (tp = &term[1]; tp < term + termcount; tp++)
		if (tp->Booleans[idx]) {
		    is_set = TRUE;
d166 1
a166 1
	    if (is_set != term->Booleans[idx])
d172 2
a173 1
    case NUMBER:{
d181 3
a183 3
	    for (tp = &term[1]; tp < term + termcount; tp++)
		if (tp->Numbers[idx] >= 0) {
		    value = tp->Numbers[idx];
d187 1
a187 1
	    if (value != term->Numbers[idx])
d193 2
a194 1
    case STRING:{
d197 1
a197 1
	    termstr = term->Strings[idx];
d204 3
a206 3
	    for (tp = &term[1]; tp < term + termcount; tp++)
		if (tp->Strings[idx]) {
		    usestr = tp->Strings[idx];
d212 1
a212 1
	    else if (!usestr || !termstr || capcmp(usestr, termstr))
d223 27
d251 1
a251 1
/* are two terminal types equal */
d264 1
a264 1
	if (capcmp(t1->Strings[i], t2->Strings[i]))
d273 64
d340 5
a344 2
    register TERMTYPE *t1 = &term[0];
    register TERMTYPE *t2 = &term[1];
d348 3
a350 1
    case BOOLEAN:
d353 2
a354 2
	    if (t1->Booleans[idx] != t2->Booleans[idx])
		(void) printf("\t%s: %c:%c.\n",
d356 3
a358 2
		    t1->Booleans[idx] ? 'T' : 'F',
		    t2->Booleans[idx] ? 'T' : 'F');
d362 2
a363 2
	    if (t1->Booleans[idx] && t2->Booleans[idx])
		(void) printf("\t%s= T.\n", name);
d367 1
a367 1
	    if (!t1->Booleans[idx] && !t2->Booleans[idx])
d373 5
a377 1
    case NUMBER:
d380 2
a381 3
	    if (t1->Numbers[idx] != t2->Numbers[idx])
		(void) printf("\t%s: %d:%d.\n",
		    name, t1->Numbers[idx], t2->Numbers[idx]);
d385 2
a386 3
	    if (t1->Numbers[idx] != -1 && t2->Numbers[idx] != -1
		&& t1->Numbers[idx] == t2->Numbers[idx])
		(void) printf("\t%s= %d.\n", name, t1->Numbers[idx]);
d390 1
a390 1
	    if (t1->Numbers[idx] == -1 && t2->Numbers[idx] == -1)
d396 3
a398 3
    case STRING:
	s1 = t1->Strings[idx];
	s2 = t2->Strings[idx];
d401 3
a403 19
	    if (capcmp(s1, s2)) {
		char buf1[BUFSIZ], buf2[BUFSIZ];

		if (s1 == (char *) NULL)
		    (void) strcpy(buf1, "NULL");
		else {
		    (void) strcpy(buf1, "'");
		    (void) strcat(buf1, TIC_EXPAND(s1));
		    (void) strcat(buf1, "'");
		}

		if (s2 == (char *) NULL)
		    (void) strcpy(buf2, "NULL");
		else {
		    (void) strcpy(buf2, "'");
		    (void) strcat(buf2, TIC_EXPAND(s2));
		    (void) strcat(buf2, "'");
		}

d405 1
a405 2
		    (void) printf("\t%s: %s, %s.\n",
			name, buf1, buf2);
d410 1
a410 1
	    if (s1 && s2 && !capcmp(s1, s2))
d420 27
a447 1

d631 1
a631 1
		((ep = strtok((char *) NULL, ";")));
d666 1
a666 1
		((ep = strtok((char *) NULL, ";")));
d719 1
a719 1
    dump_init((char *) NULL, F_LITERAL, S_TERMINFO, 0, itrace, FALSE);
d722 1
a722 1
	if (freopen(argv[n], "r", stdin) == NULL)
d725 1
a725 1
	_nc_head = _nc_tail = (ENTRY *) NULL;
d734 2
a735 2
	/* do use resolution */
	if (!_nc_resolve_uses()) {
d739 1
a739 1
	    for_entry_list(qp)
d741 3
a743 2
		(void) fputs(qp->tterm.term_names, stderr);
		(void) fputc('\n', stderr);
d757 1
a757 6
    /*
     * The entry-matching loop.  We're not using the use[]
     * slots any more (they got zeroed out by resolve_uses) so
     * we stash each entry's matches in the other file there.
     * Sigh, this is intrinsically quadratic.
     */
d761 7
a767 13
		/*
		 * This is why the uses structure parent element is
		 * (void *) -- so we can have either (char *) for
		 * names or entry structure pointers in them and still
		 * be type-safe.
		 */
		if (qp->nuses < MAX_USES)
		    qp->uses[qp->nuses].parent = (void *) rp;
		qp->nuses++;

		if (rp->nuses < MAX_USES)
		    rp->uses[rp->nuses].parent = (void *) qp;
		rp->nuses++;
d775 2
a776 2
    for (qp = heads[0]; qp; qp = qp->next)
	if (qp->nuses > 1) {
d781 1
a781 1
		qp->nuses,
d783 1
a783 1
	    for (i = 0; i < qp->nuses; i++)
d786 1
a786 1
		    _nc_first_name(((ENTRY *) qp->uses[i].parent)->tterm.term_names));
d788 4
a791 2
    for (rp = heads[1]; rp; rp = rp->next)
	if (rp->nuses > 1) {
d796 1
a796 1
		rp->nuses,
d798 1
a798 1
	    for (i = 0; i < rp->nuses; i++)
d801 1
a801 1
		    _nc_first_name(((ENTRY *) rp->uses[i].parent)->tterm.term_names));
d803 1
d807 1
a807 1
	if (qp->nuses == 0)
d813 1
a813 1
	if (rp->nuses == 0)
d819 4
a822 1
	rp = (ENTRY *) qp->uses[0].parent;
d824 7
a830 2
	if (qp->nuses == 1 && entryeq(&qp->tterm, &rp->tterm)) {
	    char name1[NAMESIZE], name2[NAMESIZE];
d832 2
a833 2
	    (void) canonical_name(qp->tterm.term_names, name1);
	    (void) canonical_name(rp->tterm.term_names, name2);
d835 2
a836 1
	    (void) printf("%s = %s\n", name1, name2);
a842 1
	rp = (ENTRY *) qp->uses[0].parent;
d844 2
d847 1
a847 1
	if (termcount > 1)
d850 2
a851 2
	if (qp->nuses == 1 && !entryeq(&qp->tterm, &rp->tterm)) {
	    char name1[NAMESIZE], name2[NAMESIZE];
d853 2
a854 2
	    term[0] = qp->tterm;
	    term[1] = rp->tterm;
d856 2
a857 2
	    (void) canonical_name(qp->tterm.term_names, name1);
	    (void) canonical_name(rp->tterm.term_names, name2);
d859 8
a866 7
	    switch (compare) {
	    case C_DIFFERENCE:
		if (itrace)
		    (void) fprintf(stderr, "infocmp: dumping differences\n");
		(void) printf("comparing %s to %s.\n", name1, name2);
		compare_entry(compare_predicate, term);
		break;
d868 7
a874 7
	    case C_COMMON:
		if (itrace)
		    (void) fprintf(stderr,
			"infocmp: dumping common capabilities\n");
		(void) printf("comparing %s to %s.\n", name1, name2);
		compare_entry(compare_predicate, term);
		break;
d876 7
a882 7
	    case C_NAND:
		if (itrace)
		    (void) fprintf(stderr,
			"infocmp: dumping differences\n");
		(void) printf("comparing %s to %s.\n", name1, name2);
		compare_entry(compare_predicate, term);
		break;
d884 1
d917 1
d919 1
d947 1
a947 1
	initializer = malloc(strlen(term->term_names) + 20);
d949 1
a949 1
    (void) sprintf(initializer, "%s_data_%s", type, term->term_names);
d960 1
a960 1
dump_initializers(void)
d1019 1
a1019 1
	char buf[BUFSIZ], *sp, *tp;
d1028 3
a1030 1
	    for (sp = term->Strings[n]; *sp; sp++) {
d1059 1
a1059 1
dump_termtype(void)
d1105 1
a1105 1
    path *tfile = malloc(sizeof(path) * MAXTERMS);
a1110 1
    bool limited = TRUE;
d1112 1
a1112 1
    if ((terminal = getenv("TERM")) == NULL) {
d1121 1
a1121 1
    while ((c = getopt(argc, argv, "deEcCfFGgIinlLprR:s:uv:Vw:A:B:1T")) != EOF)
d1191 7
d1303 1
a1303 1
			&term[termcount]);
d1312 1
a1312 1
			&term[termcount]);
d1322 1
d1329 1
a1329 1
	    _nc_align_termtype(&term[0], &term[1]);
d1335 1
a1335 1
		dump_termtype();
d1337 1
a1337 1
		dump_initializers();
d1344 9
a1352 9
#define CUR	term[0].
	    analyze_string("is1", init_1string, &term[0]);
	    analyze_string("is2", init_2string, &term[0]);
	    analyze_string("is3", init_3string, &term[0]);
	    analyze_string("rs1", reset_1string, &term[0]);
	    analyze_string("rs2", reset_2string, &term[0]);
	    analyze_string("rs3", reset_3string, &term[0]);
	    analyze_string("smcup", enter_ca_mode, &term[0]);
	    analyze_string("rmcup", exit_ca_mode, &term[0]);
d1368 1
a1368 1
	    len = dump_entry(&term[0], limited, numbers, NULL);
d1378 1
a1378 1
	    compare_entry(compare_predicate, term);
d1386 1
a1386 1
	    compare_entry(compare_predicate, term);
d1394 1
a1394 1
	    compare_entry(compare_predicate, term);
d1400 1
a1400 1
	    len = dump_entry(&term[0], limited, numbers, use_predicate);
@


1.7
log
@update to ncurses-5.0-19991204
@
text
@d1 1
a1 1
/*	$OpenBSD: infocmp.c,v 1.6 1999/11/28 17:51:54 millert Exp $	*/
d4 1
a4 1
 * Copyright (c) 1998,1999 Free Software Foundation, Inc.                   *
a35 1

d46 1
a46 1
MODULE_ID("$From: infocmp.c,v 1.47 1999/12/05 01:13:01 tom Exp $")
d55 1
a55 1
typedef char	path[PATH_MAX];
d70 1
a70 1
static int outform = F_TERMINFO; /* output format */
d86 5
a90 2
static void ExitProgram(int code) GCC_NORETURN;
static void ExitProgram(int code)
d92 4
a95 4
	while (termcount-- > 0)
		_nc_free_termtype(&term[termcount]);
	_nc_leaks_dump_entry();
	_nc_free_and_exit(code);
d99 2
a100 1
static char *canonical_name(char *ptr, char *buf)
d103 1
a103 1
    char	*bp;
d106 1
a106 1
    if ((bp = strchr(buf, '|')) != (char *)NULL)
d109 1
a109 1
    return(buf);
d118 2
a119 1
static int capcmp(const char *s, const char *t)
d123 1
a123 1
	return(0);
d125 1
a125 1
	return(1);
d128 1
a128 1
	return(_nc_capcmp(s, t));
d130 1
a130 1
	return(strcmp(s, t));
d133 2
a134 1
static int use_predicate(int type, int idx)
d137 1
a137 1
	TERMTYPE *tp;
d139 3
a141 4
	switch(type)
	{
	case BOOLEAN: {
		int is_set = FALSE;
d143 11
a153 16
		/*
		 * This assumes that multiple use entries are supposed
		 * to contribute the logical or of their boolean capabilities.
		 * This is true if we take the semantics of multiple uses to
		 * be 'each capability gets the first non-default value found
		 * in the sequence of use entries'.
		 */
		for (tp = &term[1]; tp < term + termcount; tp++)
			if (tp->Booleans[idx]) {
				is_set = TRUE;
				break;
			}
			if (is_set != term->Booleans[idx])
				return(!is_set);
			else
				return(FAIL);
d155 5
d161 2
a162 2
	case NUMBER: {
		int	value = ABSENT_NUMERIC;
d164 9
a172 15
		/*
		 * We take the semantics of multiple uses to be 'each
		 * capability gets the first non-default value found
		 * in the sequence of use entries'.
		 */
		for (tp = &term[1]; tp < term + termcount; tp++)
			if (tp->Numbers[idx] >= 0) {
				value = tp->Numbers[idx];
				break;
			}

		if (value != term->Numbers[idx])
			return(value != ABSENT_NUMERIC);
		else
			return(FAIL);
d175 8
a182 2
	case STRING: {
		char *termstr, *usestr = ABSENT_STRING;
d184 1
a184 1
		termstr = term->Strings[idx];
d186 17
a202 19
		/*
		 * We take the semantics of multiple uses to be 'each
		 * capability gets the first non-default value found
		 * in the sequence of use entries'.
		 */
		for (tp = &term[1]; tp < term + termcount; tp++)
			if (tp->Strings[idx])
			{
				usestr = tp->Strings[idx];
				break;
			}

		if (usestr == ABSENT_STRING && termstr == ABSENT_STRING)
			return(FAIL);
		else if (!usestr || !termstr || capcmp(usestr, termstr))
			return(TRUE);
		else
			return(FAIL);
	    }
d204 1
d206 1
a206 1
	return(FALSE);	/* pacify compiler */
d209 2
a210 1
static bool entryeq(TERMTYPE *t1, TERMTYPE *t2)
d213 1
a213 1
    int	i;
d217 1
a217 1
	    return(FALSE);
d221 1
a221 1
	    return(FALSE);
d225 1
a225 1
	    return(FALSE);
d227 1
a227 1
    return(TRUE);
d232 2
a233 1
static void compare_predicate(int type, int idx, const char *name)
d236 26
a261 16
	register TERMTYPE *t1 = &term[0];
	register TERMTYPE *t2 = &term[1];
	char *s1, *s2;

	switch(type)
	{
	case BOOLEAN:
		switch(compare)
		{
		case C_DIFFERENCE:
			if (t1->Booleans[idx] != t2->Booleans[idx])
			(void) printf("\t%s: %c:%c.\n",
					  name,
					  t1->Booleans[idx] ? 'T' : 'F',
					  t2->Booleans[idx] ? 'T' : 'F');
			break;
d263 7
a269 4
		case C_COMMON:
			if (t1->Booleans[idx] && t2->Booleans[idx])
			(void) printf("\t%s= T.\n", name);
			break;
d271 5
a275 6
		case C_NAND:
			if (!t1->Booleans[idx] && !t2->Booleans[idx])
			(void) printf("\t!%s.\n", name);
			break;
		}
		break;
d277 6
a282 8
	case NUMBER:
		switch(compare)
		{
		case C_DIFFERENCE:
			if (t1->Numbers[idx] != t2->Numbers[idx])
			(void) printf("\t%s: %d:%d.\n",
					  name, t1->Numbers[idx], t2->Numbers[idx]);
			break;
d284 15
a298 5
		case C_COMMON:
			if (t1->Numbers[idx]!=-1 && t2->Numbers[idx]!=-1
				&& t1->Numbers[idx] == t2->Numbers[idx])
			(void) printf("\t%s= %d.\n", name, t1->Numbers[idx]);
			break;
d300 6
a305 4
		case C_NAND:
			if (t1->Numbers[idx]==-1 && t2->Numbers[idx] == -1)
			(void) printf("\t!%s.\n", name);
			break;
a306 1
	break;
d308 5
a312 33
	case STRING:
		s1 = t1->Strings[idx];
		s2 = t2->Strings[idx];
		switch(compare)
		{
		case C_DIFFERENCE:
			if (capcmp(s1, s2))
			{
				char	buf1[BUFSIZ], buf2[BUFSIZ];

				if (s1 == (char *)NULL)
					(void) strcpy(buf1, "NULL");
				else
				{
					(void) strcpy(buf1, "'");
					(void) strcat(buf1, TIC_EXPAND(s1));
					(void) strcat(buf1, "'");
				}

				if (s2 == (char *)NULL)
					(void) strcpy(buf2, "NULL");
				else
				{
					(void) strcpy(buf2, "'");
					(void) strcat(buf2, TIC_EXPAND(s2));
					(void) strcat(buf2, "'");
				}

				if (strcmp(buf1, buf2))
					(void) printf("\t%s: %s, %s.\n",
						      name, buf1, buf2);
			}
			break;
d314 4
a317 4
		case C_COMMON:
			if (s1 && s2 && !capcmp(s1, s2))
				(void) printf("\t%s= '%s'.\n", name, TIC_EXPAND(s1));
			break;
d319 4
a322 6
		case C_NAND:
			if (!s1 && !s2)
				(void) printf("\t!%s.\n", name);
			break;
		}
		break;
d324 2
d335 4
a338 1
typedef struct {const char *from; const char *to;} assoc;
d343 6
a348 6
    {"\033c",	"RIS"},		/* full reset */
    {"\0337",	"SC"},		/* save cursor */
    {"\0338",	"RC"},		/* restore cursor */
    {"\033[r",	"RSR"},		/* not an X.364 mnemonic */
    {"\033[m",	"SGR0"},	/* not an X.364 mnemonic */
    {"\033[2J",	"ED2"},		/* clear page */
d351 6
a356 6
    {"\033(0",	"ISO DEC G0"},	/* enable DEC graphics for G0 */
    {"\033(A",	"ISO UK G0"},	/* enable UK chars for G0 */
    {"\033(B",	"ISO US G0"},	/* enable US chars for G0 */
    {"\033)0",	"ISO DEC G1"},	/* enable DEC graphics for G1 */
    {"\033)A",	"ISO UK G1"},	/* enable UK chars for G1 */
    {"\033)B",	"ISO US G1"},	/* enable US chars for G1 */
d359 3
a361 3
    {"\033=",	"DECPAM"},	/* application keypad mode */
    {"\033>",	"DECPNM"},	/* normal keypad mode */
    {"\033<",	"DECANSI"},	/* enter ANSI mode */
d363 1
a363 1
    { (char *)0, (char *)0}
d369 9
a377 9
    {"1",	"CKM"},		/* application cursor keys */
    {"2",	"ANM"},		/* set VT52 mode */
    {"3",	"COLM"},	/* 132-column mode */
    {"4",	"SCLM"},	/* smooth scroll */
    {"5",	"SCNM"},	/* reverse video mode */
    {"6",	"OM"},		/* origin mode */
    {"7",	"AWM"},		/* wraparound mode */
    {"8",	"ARM"},		/* auto-repeat mode */
    {(char *)0, (char *)0}
d383 31
a413 31
    {"0",	"NORMAL"},	/* normal */
    {"1",	"+BOLD"},	/* bold on */
    {"2",	"+DIM"},	/* dim on */
    {"3",	"+ITALIC"},	/* italic on */
    {"4",	"+UNDERLINE"},	/* underline on */
    {"5",	"+BLINK"},	/* blink on */
    {"6",	"+FASTBLINK"},	/* fastblink on */
    {"7",	"+REVERSE"},	/* reverse on */
    {"8",	"+INVISIBLE"},	/* invisible on */
    {"9",	"+DELETED"},	/* deleted on */
    {"10",	"MAIN-FONT"},	/* select primary font */
    {"11",	"ALT-FONT-1"},	/* select alternate font 1 */
    {"12",	"ALT-FONT-2"},	/* select alternate font 2 */
    {"13",	"ALT-FONT-3"},	/* select alternate font 3 */
    {"14",	"ALT-FONT-4"},	/* select alternate font 4 */
    {"15",	"ALT-FONT-5"},	/* select alternate font 5 */
    {"16",	"ALT-FONT-6"},	/* select alternate font 6 */
    {"17",	"ALT-FONT-7"},	/* select alternate font 7 */
    {"18",	"ALT-FONT-1"},	/* select alternate font 1 */
    {"19",	"ALT-FONT-1"},	/* select alternate font 1 */
    {"20",	"FRAKTUR"},	/* Fraktur font */
    {"21",	"DOUBLEUNDER"},	/* double underline */
    {"22",	"-DIM"},	/* dim off */
    {"23",	"-ITALIC"},	/* italic off */
    {"24",	"-UNDERLINE"},	/* underline off */
    {"25",	"-BLINK"},	/* blink off */
    {"26",	"-FASTBLINK"},	/* fastblink off */
    {"27",	"-REVERSE"},	/* reverse off */
    {"28",	"-INVISIBLE"},	/* invisible off */
    {"29",	"-DELETED"},	/* deleted off */
    {(char *)0, (char *)0}
d416 2
a417 1
static void analyze_string(const char *name, const char *cap, TERMTYPE *tp)
d419 4
a422 4
    char	buf[MAX_TERMINFO_LENGTH];
    char	buf2[MAX_TERMINFO_LENGTH];
    const char	*sp, *ep;
    const assoc	*ap;
d429 3
a431 4
    for (sp = cap; *sp; sp++)
    {
	int	i;
	size_t	len = 0;
d435 2
a436 3
	for (i = 0; i < STRCOUNT; i++)
	{
	    char	*cp = tp->Strings[i];
d442 2
a443 3

	    if (cp != ABSENT_STRING && cp != CANCELLED_STRING && cp[0] && cp != cap)
	    {
d471 1
a471 2
	    for (ap = std_caps; ap->from; ap++)
	    {
d474 1
a474 2
		if (strncmp(ap->from, sp, len) == 0)
		{
d482 4
a485 5
		    && sp[0] == '\033' && sp[1] == '[' && sp[2] == '?'
		    && (len = strspn(sp + 3, "0123456789;"))
		    && ((sp[3 + len] == 'h') || (sp[3 + len] == 'l')))
	{
	    char	buf3[MAX_TERMINFO_LENGTH];
d494 4
a497 1
		   bool	found = FALSE;
d499 12
a510 17
		   for (ap = private_modes; ap->from; ap++)
		   {
		       size_t tlen = strlen(ap->from);

		       if (strncmp(ap->from, ep, tlen) == 0)
		       {
			   (void) strcat(buf2, ap->to);
			   found = TRUE;
			   break;
		       }
		   }

		   if (!found)
		       (void) strcat(buf2, ep);
		   (void) strcat(buf2, ";");
	       } while
		   ((ep = strtok((char *)NULL, ";")));
d517 4
a520 5
		    && sp[0] == '\033' && sp[1] == '['
		    && (len = strspn(sp + 2, "0123456789;"))
		    && sp[2 + len] == 'm')
	{
	    char	buf3[MAX_TERMINFO_LENGTH];
d529 11
a539 1
		   bool	found = FALSE;
d541 5
a545 17
		   for (ap = ecma_highlights; ap->from; ap++)
		   {
		       size_t tlen = strlen(ap->from);

		       if (strncmp(ap->from, ep, tlen) == 0)
		       {
			   (void) strcat(buf2, ap->to);
			   found = TRUE;
			   break;
		       }
		   }

		   if (!found)
		       (void) strcat(buf2, ep);
		   (void) strcat(buf2, ";");
	       } while
		   ((ep = strtok((char *)NULL, ";")));
d551 1
a551 2
	if (!expansion)
	{
d559 1
a559 2
	if (!expansion)
	{
d563 1
a563 1
		    expansion = "LL";
d567 1
a567 2
	if (expansion)
	{
d571 1
a571 3
	}
	else
	{
d587 2
a588 1
static void file_comparison(int argc, char *argv[])
d592 5
a596 5
    int	filecount = 0;
    ENTRY	*heads[MAXCOMPARE];
    ENTRY	*tails[MAXCOMPARE];
    ENTRY	*qp, *rp;
    int		i, n;
d598 1
a598 1
    dump_init((char *)NULL, F_LITERAL, S_TERMINFO, 0, itrace, FALSE);
d600 1
a600 2
    for (n = 0; n < argc && n < MAXCOMPARE; n++)
    {
d604 1
a604 1
	_nc_head = _nc_tail = (ENTRY *)NULL;
d611 1
a611 1
	    (void) fprintf(stderr, "Resolving file %d...\n", n-0);
d614 1
a614 2
	if (!_nc_resolve_uses())
	{
d616 2
a617 2
			   "There are unresolved use entries in %s:\n",
			   argv[n]);
d619 4
a622 5
		if (qp->nuses)
		{
		    (void) fputs(qp->tterm.term_names, stderr);
		    (void) fputc('\n', stderr);
		}
d641 1
a641 2
    for (qp = heads[0]; qp; qp = qp->next)
    {
d643 1
a643 2
	    if (_nc_entry_match(qp->tterm.term_names, rp->tterm.term_names))
	    {
d651 1
a651 1
		    qp->uses[qp->nuses].parent = (void *)rp;
d655 1
a655 1
		    rp->uses[rp->nuses].parent = (void *)qp;
d665 1
a665 2
	if (qp->nuses > 1)
	{
d667 5
a671 5
			   "%s in file 1 (%s) has %d matches in file 2 (%s):\n",
			   _nc_first_name(qp->tterm.term_names),
			   argv[0],
			   qp->nuses,
			   argv[1]);
d674 2
a675 2
			       "\t%s\n",
			       _nc_first_name(((ENTRY *)qp->uses[i].parent)->tterm.term_names));
d678 1
a678 2
	if (rp->nuses > 1)
	{
d680 5
a684 5
			   "%s in file 2 (%s) has %d matches in file 1 (%s):\n",
			   _nc_first_name(rp->tterm.term_names),
			   argv[1],
			   rp->nuses,
			   argv[0]);
d687 2
a688 2
			       "\t%s\n",
			       _nc_first_name(((ENTRY *)rp->uses[i].parent)->tterm.term_names));
d695 1
a695 1
			  _nc_first_name(qp->tterm.term_names));
d701 1
a701 1
			  _nc_first_name(rp->tterm.term_names));
d704 2
a705 3
    for (qp = heads[0]; qp; qp = qp->next)
    {
	rp = (ENTRY *)qp->uses[0].parent;
d707 1
a707 2
	if (qp->nuses == 1 && entryeq(&qp->tterm, &rp->tterm))
	{
d719 2
a720 3
    for (qp = heads[0]; qp; qp = qp->next)
    {
	rp = (ENTRY *)qp->uses[0].parent;
d726 1
a726 2
	if (qp->nuses == 1 && !entryeq(&qp->tterm, &rp->tterm))
	{
d735 1
a735 2
	    switch (compare)
	    {
d738 1
a738 1
		    (void)fprintf(stderr, "infocmp: dumping differences\n");
d746 1
a746 1
				   "infocmp: dumping common capabilities\n");
d754 1
a754 1
				   "infocmp: dumping differences\n");
d764 2
a765 1
static void usage(void)
d767 43
a809 42
	static const char *tbl[] = {
	     "Usage: infocmp [options] [-A directory] [-B directory] [termname...]"
	    ,""
	    ,"Options:"
	    ,"  -1    print single-column"
	    ,"  -C    use termcap-names"
	    ,"  -F    compare terminfo-files"
	    ,"  -I    use terminfo-names"
	    ,"  -L    use long names"
	    ,"  -R subset (see manpage)"
	    ,"  -T    eliminate size limits (test)"
	    ,"  -V    print version"
	    ,"  -c    list common capabilities"
	    ,"  -d    list different capabilities"
	    ,"  -e    format output for C initializer"
	    ,"  -E    format output as C tables"
	    ,"  -f    with -1, format complex strings"
	    ,"  -G    format %{number} to %'char'"
	    ,"  -g    format %'char' to %{number}"
	    ,"  -i    analyze initialization/reset"
	    ,"  -l    output terminfo names"
	    ,"  -n    list capabilities in neither"
	    ,"  -p    ignore padding specifiers"
	    ,"  -r    with -C, output in termcap form"
	    ,"  -s [d|i|l|c] sort fields"
	    ,"  -u    produce source with 'use='"
	    ,"  -v number  (verbose)"
	    ,"  -w number  (width)"
	};
	const size_t first = 3;
	const size_t last = sizeof(tbl)/sizeof(tbl[0]);
	const size_t left = (last - first + 1) / 2 + first;
	size_t n;

	for (n = 0; n < left; n++) {
		size_t m = (n < first) ? last : n + left - first;
		if (m < last)
			fprintf(stderr, "%-40.40s%s\n", tbl[n], tbl[m]);
		else
			fprintf(stderr, "%s\n", tbl[n]);
	}
	exit(EXIT_FAILURE);
d812 2
a813 1
static char * name_initializer(const char *type)
d822 1
a822 2
    for (s = initializer; *s != 0 && *s != '|'; s++)
    {
d831 2
a832 1
static void dump_initializers(void)
d834 1
a834 1
    int	n;
d836 1
a836 1
    int	size;
d840 2
a841 4
    for_each_boolean(n,term)
    {
	switch((int)(term->Booleans[n]))
	{
d859 1
a859 1
		      n, ExtBoolname(term,n,boolnames), str);
d865 3
a867 5
    for_each_number(n,term)
    {
	char	buf[BUFSIZ];
	switch (term->Numbers[n])
	{
d879 2
a880 1
	(void) printf("\t/* %3d: %-8s */\t%s,\n", n, ExtNumname(term,n,numnames), str);
d890 2
a891 3
    for_each_string(n,term)
    {
	char	buf[BUFSIZ], *sp, *tp;
d897 1
a897 2
	else
	{
d900 2
a901 3
	    for (sp = term->Strings[n]; *sp; sp++)
	    {
		if (isascii(*sp) && isprint(*sp) && *sp !='\\' && *sp != '"')
d903 1
a903 2
		else
		{
d914 1
a914 2
	if (n == STRCOUNT)
	{
d917 2
a918 1
	    (void) printf("static char * %s[] = %s\n", name_initializer("string_ext"), L_CURL);
d921 2
a922 1
	(void) printf("\t/* %3d: %-8s */\t%s,\n", n, ExtStrname(term,n,strnames), str);
d928 2
a929 1
static void dump_termtype(void)
d944 2
a945 2
	    ? name_initializer("string_ext")
	    : "(char **)0");
d948 2
a949 2
    (void) printf("\t\t%d,\t\t/* count total Numbers */\n",  NUM_NUMBERS(term));
    (void) printf("\t\t%d,\t\t/* count total Strings */\n",  NUM_STRINGS(term));
d951 6
a956 3
    (void) printf("\t\t%d,\t\t/* count extensions to Booleans */\n", NUM_BOOLEANS(term) - BOOLCOUNT);
    (void) printf("\t\t%d,\t\t/* count extensions to Numbers */\n",  NUM_NUMBERS(term) - NUMCOUNT);
    (void) printf("\t\t%d,\t\t/* count extensions to Strings */\n",  NUM_STRINGS(term) - STRCOUNT);
d969 2
a970 1
int main(int argc, char *argv[])
d972 16
a987 10
	char *terminal, *firstdir, *restdir;
	/* Avoid "local data >32k" error with mwcc */
	/* Also avoid overflowing smaller stacks on systems like AmigaOS */
	path *tfile = malloc(sizeof(path)*MAXTERMS);
	int c, i, len;
	bool formatted = FALSE;
	bool filecompare = FALSE;
	int initdump = 0;
	bool init_analyze = FALSE;
	bool limited = TRUE;
d989 8
a996 6
	if ((terminal = getenv("TERM")) == NULL)
	{
		(void) fprintf(stderr,
			"infocmp: environment variable TERM not set\n");
		return EXIT_FAILURE;
	}
d998 3
a1000 2
	/* where is the terminfo database location going to default to? */
	restdir = firstdir = 0;
d1002 3
a1004 6
	while ((c = getopt(argc, argv, "deEcCfFGgIinlLprR:s:uv:Vw:A:B:1T")) != EOF)
		switch (c)
		{
		case 'd':
			compare = C_DIFFERENCE;
			break;
d1006 3
a1008 3
		case 'e':
			initdump |= 1;
			break;
d1010 6
a1015 3
		case 'E':
			initdump |= 2;
			break;
d1017 3
a1019 3
		case 'c':
			compare = C_COMMON;
			break;
d1021 3
a1023 6
		case 'C':
			outform = F_TERMCAP;
			tversion = "BSD";
			if (sortmode == S_DEFAULT)
			    sortmode = S_TERMCAP;
			break;
d1025 3
a1027 3
		case 'f':
			formatted = TRUE;
			break;
d1029 3
a1031 3
		case 'G':
			numbers = 1;
			break;
d1033 6
a1038 3
		case 'g':
			numbers = -1;
			break;
d1040 3
a1042 3
		case 'F':
			filecompare = TRUE;
			break;
d1044 3
a1046 6
		case 'I':
			outform = F_TERMINFO;
			if (sortmode == S_DEFAULT)
			    sortmode = S_VARIABLE;
			tversion = 0;
			break;
d1048 5
a1052 3
		case 'i':
			init_analyze = TRUE;
			break;
d1054 3
a1056 3
		case 'l':
			outform = F_TERMINFO;
			break;
d1058 3
a1060 5
		case 'L':
			outform = F_VARIABLE;
			if (sortmode == S_DEFAULT)
			    sortmode = S_VARIABLE;
			break;
d1062 4
a1065 3
		case 'n':
			compare = C_NAND;
			break;
d1067 3
a1069 3
		case 'p':
			ignorepads = TRUE;
			break;
d1071 15
a1085 4
		case 'r':
			tversion = 0;
			limited = FALSE;
			break;
d1087 3
a1089 3
		case 'R':
			tversion = optarg;
			break;
d1091 4
a1094 16
		case 's':
			if (*optarg == 'd')
				sortmode = S_NOSORT;
			else if (*optarg == 'i')
				sortmode = S_TERMINFO;
			else if (*optarg == 'l')
				sortmode = S_VARIABLE;
			else if (*optarg == 'c')
				sortmode = S_TERMCAP;
			else
			{
				(void) fprintf(stderr,
					       "infocmp: unknown sort mode\n");
				return EXIT_FAILURE;
			}
			break;
d1096 4
a1099 3
		case 'u':
			compare = C_USEALL;
			break;
d1101 3
a1103 4
		case 'v':
			itrace = atoi(optarg);
			_nc_tracing = (1 << itrace) - 1;
			break;
d1105 3
a1107 4
		case 'V':
			(void) fputs(NCURSES_VERSION, stdout);
			putchar('\n');
			ExitProgram(EXIT_SUCCESS);
d1109 3
a1111 3
		case 'w':
			mwidth = atoi(optarg);
			break;
d1113 3
a1115 3
		case 'A':
			firstdir = optarg;
			break;
d1117 6
a1122 3
		case 'B':
			restdir = optarg;
			break;
d1124 3
a1126 3
		case '1':
			mwidth = 0;
			break;
d1128 2
a1129 6
		case 'T':
			limited = FALSE;
			break;
		default:
			usage();
		}
d1131 3
a1133 3
	/* by default, sort by terminfo name */
	if (sortmode == S_DEFAULT)
		sortmode = S_TERMINFO;
d1135 3
a1137 2
	/* set up for display */
	dump_init(tversion, outform, sortmode, mwidth, itrace, formatted);
d1139 3
a1141 40
	/* make sure we have at least one terminal name to work with */
	if (optind >= argc)
		argv[argc++] = terminal;

	/* if user is after a comparison, make sure we have two entries */
	if (compare != C_DEFAULT && optind >= argc - 1)
		argv[argc++] = terminal;

	/* exactly two terminal names with no options means do -d */
	if (argc - optind == 2 && compare == C_DEFAULT)
		compare = C_DIFFERENCE;

	if (!filecompare)
	{
	    /* grab the entries */
	    termcount = 0;
	    for (; optind < argc; optind++)
	    {
		if (termcount >= MAXTERMS)
		{
		    (void) fprintf(stderr,
			   "infocmp: too many terminal type arguments\n");
		    return EXIT_FAILURE;
		}
		else
		{
		    const char	*directory = termcount ? restdir : firstdir;
		    int		status;

		    tname[termcount] = argv[optind];

		    if (directory)
		    {
			(void) sprintf(tfile[termcount], "%s/%c/%s",
				       directory,
				       *argv[optind], argv[optind]);
			if (itrace)
			    (void) fprintf(stderr,
					   "infocmp: reading entry %s from file %s\n",
					   argv[optind], tfile[termcount]);
d1143 22
a1164 15
			status = _nc_read_file_entry(tfile[termcount],
						     &term[termcount]);
		    }
		    else
		    {
			if (itrace)
			    (void) fprintf(stderr,
					   "infocmp: reading entry %s from system directories %s\n",
					   argv[optind], tname[termcount]);

			status = _nc_read_entry(tname[termcount],
						tfile[termcount],
						&term[termcount]);
			directory = TERMINFO;	/* for error message */
		    }
d1166 4
a1169 2
		    if (status <= 0)
		    {
d1171 14
a1184 5
				       "infocmp: couldn't open terminfo file %s.\n",
				       tfile[termcount]);
			return EXIT_FAILURE;
		    }
		    termcount++;
d1186 1
d1188 1
d1191 2
a1192 2
	    if (termcount > 1)
		_nc_align_termtype(&term[0], &term[1]);
d1195 8
a1202 9
	    /* dump as C initializer for the terminal type */
	    if (initdump)
	    {
		if (initdump & 1)
		    dump_termtype();
		if (initdump & 2)
		    dump_initializers();
		ExitProgram(EXIT_SUCCESS);
	    }
d1204 2
a1205 3
	    /* analyze the init strings */
	    if (init_analyze)
	    {
d1208 8
a1215 8
		analyze_string("is1", init_1string, &term[0]);
		analyze_string("is2", init_2string, &term[0]);
		analyze_string("is3", init_3string, &term[0]);
		analyze_string("rs1", reset_1string, &term[0]);
		analyze_string("rs2", reset_2string, &term[0]);
		analyze_string("rs3", reset_3string, &term[0]);
		analyze_string("smcup", enter_ca_mode, &term[0]);
		analyze_string("rmcup", exit_ca_mode, &term[0]);
d1217 2
a1218 2
		ExitProgram(EXIT_SUCCESS);
	    }
d1220 16
a1235 17
	    /*
	     * Here's where the real work gets done
	     */
	    switch (compare)
	    {
	    case C_DEFAULT:
		if (itrace)
		    (void) fprintf(stderr,
				   "infocmp: about to dump %s\n",
				   tname[0]);
		(void) printf("#\tReconstructed via infocmp from file: %s\n",
			      tfile[0]);
		len = dump_entry(&term[0], limited, numbers, NULL);
		putchar('\n');
		if (itrace)
		    (void)fprintf(stderr, "infocmp: length %d\n", len);
		break;
d1237 6
a1242 6
	    case C_DIFFERENCE:
		if (itrace)
		    (void)fprintf(stderr, "infocmp: dumping differences\n");
		(void) printf("comparing %s to %s.\n", tname[0], tname[1]);
		compare_entry(compare_predicate, term);
		break;
d1244 7
a1250 7
	    case C_COMMON:
		if (itrace)
		    (void) fprintf(stderr,
				   "infocmp: dumping common capabilities\n");
		(void) printf("comparing %s to %s.\n", tname[0], tname[1]);
		compare_entry(compare_predicate, term);
		break;
d1252 7
a1258 7
	    case C_NAND:
		if (itrace)
		    (void) fprintf(stderr,
				   "infocmp: dumping differences\n");
		(void) printf("comparing %s to %s.\n", tname[0], tname[1]);
		compare_entry(compare_predicate, term);
		break;
d1260 11
a1270 11
	    case C_USEALL:
		if (itrace)
		    (void) fprintf(stderr, "infocmp: dumping use entry\n");
		len = dump_entry(&term[0], limited, numbers, use_predicate);
		for (i = 1; i < termcount; i++)
		    len += dump_uses(tname[i], !(outform==F_TERMCAP || outform==F_TCONVERR));
		putchar('\n');
		if (itrace)
		    (void)fprintf(stderr, "infocmp: length %d\n", len);
		break;
	    }
d1272 9
a1280 9
	else if (compare == C_USEALL)
	    (void) fprintf(stderr, "Sorry, -u doesn't work with -F\n");
	else if (compare == C_DEFAULT)
	    (void) fprintf(stderr, "Use `tic -[CI] <file>' for this.\n");
	else if (argc - optind != 2)
	    (void) fprintf(stderr,
		"File comparison needs exactly two file arguments.\n");
	else
	    file_comparison(argc-optind, argv+optind);
d1282 1
a1282 1
	ExitProgram(EXIT_SUCCESS);
@


1.6
log
@update to ncurses-5.0-19991127
@
text
@d1 1
a1 1
/*	$OpenBSD: infocmp.c,v 1.5 1999/06/27 08:17:46 millert Exp $	*/
d47 1
a47 1
MODULE_ID("$From: infocmp.c,v 1.45 1999/11/27 23:59:57 tom Exp $")
d71 1
a71 1
static int outform;		/* output format */
@


1.5
log
@ncurses-5.0-990626
@
text
@d1 1
a1 1
/*	$OpenBSD: infocmp.c,v 1.4 1999/05/08 20:30:44 millert Exp $	*/
d47 1
a47 1
MODULE_ID("$From: infocmp.c,v 1.44 1999/06/16 00:39:48 tom Exp $")
d860 1
a860 1
    (void) printf("static bool %s[] = %s\n", name_initializer("bool"), L_CURL);
@


1.4
log
@ncurses-4.2-990424
@
text
@d1 1
a1 1
/*	$OpenBSD: infocmp.c,v 1.3 1999/03/11 21:08:07 millert Exp $	*/
d47 1
a47 1
MODULE_ID("$From: infocmp.c,v 1.42 1999/04/03 23:18:23 tom Exp $")
d805 2
a806 1
	    ,"  -e    format output as C initializer"
d835 152
d1002 1
a1002 1
	bool initdump = FALSE;
d1016 1
a1016 1
	while ((c = getopt(argc, argv, "decCfFGgIinlLprR:s:uv:Vw:A:B:1T")) != EOF)
d1024 5
a1028 1
			initdump = TRUE;
d1233 4
a1236 94
		int	n;
		const char *str = 0;
		int	size;

		(void) printf("\t%s\n\t\t\"%s\",\n",
			      L_CURL, term->term_names);
		(void) printf("\t\t(char *)0,\n");

		(void) printf("\t\t%s /* BOOLEANS */\n", L_CURL);
		for_each_boolean(n,term)
		{
		    switch((int)(term->Booleans[n]))
		    {
		    case TRUE:
			str = "TRUE";
			break;

		    case FALSE:
			str = "FALSE";
			break;

		    case ABSENT_BOOLEAN:
			str = "ABSENT_BOOLEAN";
			break;

		    case CANCELLED_BOOLEAN:
			str = "CANCELLED_BOOLEAN";
			break;
		    }
		    (void) printf("\t\t/* %s */\t%s%s,\n",
				  ExtBoolname(term,n,boolnames), str,
				  n == NUM_BOOLEANS(term)-1 ? R_CURL : "");
		}

		(void) printf("\t\t%s /* NUMERICS */\n", L_CURL);
		for_each_number(n,term)
		{
		    char	buf[BUFSIZ];
		    switch (term->Numbers[n])
		    {
		    case ABSENT_NUMERIC:
			str = "ABSENT_NUMERIC";
			break;
		    case CANCELLED_NUMERIC:
			str = "CANCELLED_NUMERIC";
			break;
		    default:
			sprintf(buf, "%d", term->Numbers[n]);
			str = buf;
			break;
		    }
		    (void) printf("\t\t/* %s */\t%s%s,\n",
			numnames[n], str,
			n == NUM_NUMBERS(term)-1 ? R_CURL : "");
		}

		size = sizeof(TERMTYPE)
		    + (NUM_BOOLEANS(term) * sizeof(term->Booleans[0]))
		    + (NUM_NUMBERS(term) * sizeof(term->Numbers[0]));

		(void) printf("\t\t%s /* STRINGS */\n", L_CURL);
		for_each_string(n,term)
		{
		    char	buf[BUFSIZ], *sp, *tp;

		    if (term->Strings[n] == ABSENT_STRING)
			str = "ABSENT_STRING";
		    else if (term->Strings[n] == CANCELLED_STRING)
			str = "CANCELLED_STRING";
		    else
		    {
			tp = buf;
			*tp++ = '"';
			for (sp = term->Strings[n]; *sp; sp++)
			{
			    if (isascii(*sp) && isprint(*sp) && *sp !='\\' && *sp != '"')
				*tp++ = *sp;
			    else
			    {
				(void) sprintf(tp, "\\%03o", *sp & 0xff);
				tp += 4;
			    }
			}
			*tp++ = '"';
			*tp = '\0';
			size += (strlen(term->Strings[n]) + 1);
			str = buf;
		    }
		    (void) printf("\t\t/* %s */\t%s%s%s\n",
		    	strnames[n], str,
			n == NUM_STRINGS(term)-1 ? R_CURL : "",
			n == NUM_STRINGS(term)-1 ? ""     : ",");
		}
		(void) printf("\t%s /* size = %d */\n", R_CURL, size);
@


1.3
log
@Add -G flag; ncurses-4.2-990306
@
text
@d1 1
a1 1
/*	$OpenBSD: infocmp.c,v 1.2 1999/03/02 06:23:56 millert Exp $	*/
d47 1
a47 1
MODULE_ID("$From: infocmp.c,v 1.41 1999/03/07 00:52:02 tom Exp $")
d91 1
a91 1
		_nc_free_termtype(&term[termcount], FALSE);
@


1.2
log
@ncurses-4.2-990301
@
text
@d1 1
a1 1
/*	$OpenBSD: infocmp.c,v 1.1 1999/01/22 04:51:31 millert Exp $	*/
d47 1
a47 1
MODULE_ID("$From: infocmp.c,v 1.40 1999/03/01 00:40:17 tom Exp $")
d70 1
a70 1
static bool numbers = TRUE;	/* format "%'char'" to "%{number}" */
d807 1
d863 1
a863 1
	while ((c = getopt(argc, argv, "decCfFgIinlLprR:s:uv:Vw:A:B:1T")) != EOF)
d889 4
d894 1
a894 1
			numbers = FALSE;
@


1.1
log
@infocmp from ncurses-4.2-990116.  Needs current libcurses to be useful
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d4 1
a4 1
 * Copyright (c) 1998 Free Software Foundation, Inc.                        *
d47 1
a47 1
MODULE_ID("$From: infocmp.c,v 1.38 1998/10/17 21:32:36 tom Exp $")
d211 1
a211 1
    for (i = 0; i < BOOLCOUNT; i++)
d215 1
a215 1
    for (i = 0; i < NUMCOUNT; i++)
d219 1
a219 1
    for (i = 0; i < STRCOUNT; i++)
d745 4
d753 2
a754 2
	    memcpy(&term[0], &qp->tterm, sizeof(TERMTYPE));
	    memcpy(&term[1], &rp->tterm, sizeof(TERMTYPE));
d765 1
a765 1
		compare_entry(compare_predicate);
d773 1
a773 1
		compare_entry(compare_predicate);
d781 1
a781 1
		compare_entry(compare_predicate);
d1063 5
d1080 1
a1080 1
		for (n = 0; n < BOOLCOUNT; n++)
d1101 2
a1102 2
				  boolnames[n], str,
				  n == BOOLCOUNT-1 ? R_CURL : "");
d1106 1
a1106 1
		for (n = 0; n < NUMCOUNT; n++)
d1124 1
a1124 1
			n == NUMCOUNT-1 ? R_CURL : "");
d1128 2
a1129 2
		    + (BOOLCOUNT * sizeof(term->Booleans[0]))
		    + (NUMCOUNT * sizeof(term->Numbers[0]));
d1132 1
a1132 1
		for (n = 0; n < STRCOUNT; n++)
d1161 2
a1162 2
			n == STRCOUNT-1 ? R_CURL : "",
			n == STRCOUNT-1 ? ""     : ",");
d1207 1
a1207 1
		compare_entry(compare_predicate);
d1215 1
a1215 1
		compare_entry(compare_predicate);
d1223 1
a1223 1
		compare_entry(compare_predicate);
@

