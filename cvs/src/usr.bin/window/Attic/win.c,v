head	1.8;
access;
symbols
	OPENBSD_4_5:1.7.0.24
	OPENBSD_4_5_BASE:1.7
	OPENBSD_4_4:1.7.0.22
	OPENBSD_4_4_BASE:1.7
	OPENBSD_4_3:1.7.0.20
	OPENBSD_4_3_BASE:1.7
	OPENBSD_4_2:1.7.0.18
	OPENBSD_4_2_BASE:1.7
	OPENBSD_4_1:1.7.0.16
	OPENBSD_4_1_BASE:1.7
	OPENBSD_4_0:1.7.0.14
	OPENBSD_4_0_BASE:1.7
	OPENBSD_3_9:1.7.0.12
	OPENBSD_3_9_BASE:1.7
	OPENBSD_3_8:1.7.0.10
	OPENBSD_3_8_BASE:1.7
	OPENBSD_3_7:1.7.0.8
	OPENBSD_3_7_BASE:1.7
	OPENBSD_3_6:1.7.0.6
	OPENBSD_3_6_BASE:1.7
	OPENBSD_3_5:1.7.0.4
	OPENBSD_3_5_BASE:1.7
	OPENBSD_3_4:1.7.0.2
	OPENBSD_3_4_BASE:1.7
	OPENBSD_3_3:1.6.0.6
	OPENBSD_3_3_BASE:1.6
	OPENBSD_3_2:1.6.0.4
	OPENBSD_3_2_BASE:1.6
	OPENBSD_3_1:1.6.0.2
	OPENBSD_3_1_BASE:1.6
	OPENBSD_3_0:1.5.0.20
	OPENBSD_3_0_BASE:1.5
	OPENBSD_2_9_BASE:1.5
	OPENBSD_2_9:1.5.0.18
	OPENBSD_2_8:1.5.0.16
	OPENBSD_2_8_BASE:1.5
	OPENBSD_2_7:1.5.0.14
	OPENBSD_2_7_BASE:1.5
	OPENBSD_2_6:1.5.0.12
	OPENBSD_2_6_BASE:1.5
	OPENBSD_2_5:1.5.0.10
	OPENBSD_2_5_BASE:1.5
	OPENBSD_2_4:1.5.0.8
	OPENBSD_2_4_BASE:1.5
	OPENBSD_2_3:1.5.0.6
	OPENBSD_2_3_BASE:1.5
	OPENBSD_2_2:1.5.0.4
	OPENBSD_2_2_BASE:1.5
	OPENBSD_2_1:1.5.0.2
	OPENBSD_2_1_BASE:1.5
	OPENBSD_2_0:1.4.0.2
	OPENBSD_2_0_BASE:1.4
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.8
date	2009.06.01.16.57.27;	author deraadt;	state dead;
branches;
next	1.7;

1.7
date	2003.06.03.02.56.23;	author millert;	state Exp;
branches;
next	1.6;

1.6
date	2001.11.19.19.02.18;	author mpech;	state Exp;
branches;
next	1.5;

1.5
date	97.02.25.00.04.32;	author downsj;	state Exp;
branches;
next	1.4;

1.4
date	96.06.26.05.43.32;	author deraadt;	state Exp;
branches;
next	1.3;

1.3
date	96.02.23.14.10.44;	author niklas;	state Exp;
branches;
next	1.2;

1.2
date	95.12.26.18.00.27;	author deraadt;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.46.57;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.46.57;	author deraadt;	state Exp;
branches;
next	;


desc
@@


1.8
log
@RIP; ok millert
@
text
@/*	$OpenBSD: win.c,v 1.7 2003/06/03 02:56:23 millert Exp $	*/
/*	$NetBSD: win.c,v 1.8 1996/02/08 21:07:57 mycroft Exp $	*/

/*
 * Copyright (c) 1983, 1993
 *	The Regents of the University of California.  All rights reserved.
 *
 * This code is derived from software contributed to Berkeley by
 * Edward Wang at The University of California, Berkeley.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */

#ifndef lint
#if 0
static char sccsid[] = "@@(#)win.c	8.1 (Berkeley) 6/6/93";
#else
static char rcsid[] = "$OpenBSD: win.c,v 1.7 2003/06/03 02:56:23 millert Exp $";
#endif
#endif /* not lint */

#include "defs.h"
#include "char.h"
#include <string.h>

/*
 * Higher level routines for dealing with windows.
 *
 * There are two types of windows: user window, and information window.
 * User windows are the ones with a pty and shell.  Information windows
 * are for displaying error messages, and other information.
 *
 * The windows are doubly linked in overlapping order and divided into
 * two groups: foreground and normal.  Information
 * windows are always foreground.  User windows can be either.
 * Addwin() adds a window to the list at the top of one of the two groups.
 * Deletewin() deletes a window.  Front() moves a window to the front
 * of its group.  Wwopen(), wwadd(), and wwdelete() should never be called
 * directly.
 */

/*
 * Open a user window.
 */
struct ww *
openwin(id, row, col, nrow, ncol, nline, label, type, uflags, shf, sh)
char *label;
char *shf, **sh;
{
	struct ww *w;

	if (id < 0 && (id = findid()) < 0)
		return 0;
	if (row + nrow <= 0 || row > wwnrow - 1
	    || col + ncol <= 0 || col > wwncol - 1) {
		error("Illegal window position.");
		return 0;
	}
	w = wwopen(type, 0, nrow, ncol, row, col, nline);
	if (w == 0) {
		error("Can't open window: %s.", wwerror());
		return 0;
	}
	w->ww_id = id;
	window[id] = w;
	CLR(w->ww_uflags, WWU_ALLFLAGS);
	SET(w->ww_uflags, uflags);
	w->ww_alt = w->ww_w;
	if (label != 0 && setlabel(w, label) < 0)
		error("No memory for label.");
	wwcursor(w, 1);
	/*
	 * We have to do this little maneuver to make sure
	 * addwin() puts w at the top, so we don't waste an
	 * insert and delete operation.
	 */
	setselwin((struct ww *)0);
	addwin(w, 0);
	setselwin(w);
	if (wwspawn(w, shf, sh) < 0) {
		error("Can't execute %s: %s.", shf, wwerror());
		closewin(w);
		return 0;
	}
	return w;
}

findid()
{
	int i;

	for (i = 0; i < NWINDOW && window[i] != 0; i++)
		;
	if (i >= NWINDOW) {
		error("Too many windows.");
		return -1;
	}
	return i;
}

struct ww *
findselwin()
{
	struct ww *w, *s = 0;
	int i;

	for (i = 0; i < NWINDOW; i++)
		if ((w = window[i]) != 0 && w != selwin &&
		    (s == 0 ||
		     !isfg(w) && (w->ww_order < s->ww_order || isfg(s))))
			s = w;
	return s;
}

/*
 * Close a user window.  Close all if w == 0.
 */
closewin(w)
struct ww *w;
{
	char didit = 0;
	int i;

	if (w != 0) {
		closewin1(w);
		didit++;
	} else
		for (i = 0; i < NWINDOW; i++) {
			if ((w = window[i]) == 0)
				continue;
			closewin1(w);
			didit++;
		}
	if (didit) {
		if (selwin == 0)
			if (lastselwin != 0) {
				setselwin(lastselwin);
				lastselwin = 0;
			} else if (w = findselwin())
				setselwin(w);
		if (lastselwin == 0 && selwin)
			if (w = findselwin())
				lastselwin = w;
		reframe();
	}
}

/*
 * Open an information (display) window.
 */
struct ww *
openiwin(nrow, label)
char *label;
{
	struct ww *w;

	if ((w = wwopen(WWT_INTERNAL, 0, nrow, wwncol, 2, 0, 0)) == 0)
		return 0;
	SET(w->ww_wflags, WWW_MAPNL | WWW_NOINTR | WWW_NOUPDATE | WWW_UNCTRL);
	SET(w->ww_uflags, WWU_HASFRAME | WWU_CENTER);
	w->ww_id = -1;
	(void) setlabel(w, label);
	addwin(w, 1);
	reframe();
	return w;
}

/*
 * Close an information window.
 */
closeiwin(w)
struct ww *w;
{
	closewin1(w);
	reframe();
}

closewin1(w)
struct ww *w;
{
	if (w == selwin)
		selwin = 0;
	if (w == lastselwin)
		lastselwin = 0;
	if (w->ww_id >= 0 && w->ww_id < NWINDOW)
		window[w->ww_id] = 0;
	if (w->ww_label)
		str_free(w->ww_label);
	deletewin(w);
	wwclose(w);
}

/*
 * Move the window to the top of its group.
 * Don't do it if already fully visible.
 * Wwvisible() doesn't work for tinted windows.
 * But anything to make it faster.
 * Always reframe() if doreframe is true.
 */
front(w, doreframe)
struct ww *w;
char doreframe;
{
	if (w->ww_back != (isfg(w) ? framewin : fgwin) && !wwvisible(w)) {
		deletewin(w);
		addwin(w, isfg(w));
		doreframe = 1;
	}
	if (doreframe)
		reframe();
}

/*
 * Add a window at the top of normal windows or foreground windows.
 * For normal windows, we put it behind the current window.
 */
addwin(w, fg)
struct ww *w;
char fg;
{
	if (fg) {
		wwadd(w, framewin);
		if (fgwin == framewin)
			fgwin = w;
	} else
		wwadd(w, selwin != 0 && selwin != w && !isfg(selwin)
				? selwin : fgwin);
}

/*
 * Delete a window.
 */
deletewin(w)
struct ww *w;
{
	if (fgwin == w)
		fgwin = w->ww_back;
	wwdelete(w);
}

reframe()
{
	struct ww *w;

	wwunframe(framewin);
	for (w = wwhead.ww_back; w != &wwhead; w = w->ww_back)
		if (ISSET(w->ww_uflags, WWU_HASFRAME)) {
			wwframe(w, framewin);
			labelwin(w);
		}
}

labelwin(w)
struct ww *w;
{
	int mode = w == selwin ? WWM_REV : 0;

	if (!ISSET(w->ww_uflags, WWU_HASFRAME))
		return;
	if (w->ww_id >= 0) {
		char buf[2];

		buf[0] = w->ww_id + '1';
		buf[1] = 0;
		wwlabel(w, framewin, 1, buf, mode);
	}
	if (w->ww_label) {
		int col;

		if (ISSET(w->ww_uflags, WWU_CENTER)) {
			col = (w->ww_w.nc - strlen(w->ww_label)) / 2;
			col = MAX(3, col);
		} else
			col = 3;
		wwlabel(w, framewin, col, w->ww_label, mode);
	}
}

stopwin(w)
	struct ww *w;
{
	if (w->ww_pty >= 0 && w->ww_type == WWT_PTY && wwstoptty(w->ww_pty) < 0)
		error("Can't stop output: %s.", wwerror());
	else
		SET(w->ww_pflags, WWP_STOPPED);
}

startwin(w)
	struct ww *w;
{
	if (w->ww_pty >= 0 && w->ww_type == WWT_PTY && wwstarttty(w->ww_pty) < 0)
		error("Can't start output: %s.", wwerror());
	else
		CLR(w->ww_pflags, WWP_STOPPED);
}

sizewin(w, nrow, ncol)
struct ww *w;
{
	struct ww *back = w->ww_back;

	w->ww_alt.nr = w->ww_w.nr;
	w->ww_alt.nc = w->ww_w.nc;
	wwdelete(w);
	if (wwsize(w, nrow, ncol) < 0)
		error("Can't resize window: %s.", wwerror());
	wwadd(w, back);
	reframe();
}

waitnl(w)
struct ww *w;
{
	(void) waitnl1(w, "[Type any key to continue]");
}

more(w, always)
struct ww *w;
char always;
{
	int c;
	int uc = ISSET(w->ww_wflags, WWW_UNCTRL);

	if (!always && w->ww_cur.r < w->ww_w.b - 2)
		return 0;
	c = waitnl1(w, "[Type escape to abort, any other key to continue]");
	CLR(w->ww_wflags, WWW_UNCTRL);
	wwputs("\033E", w);
	SET(w->ww_wflags, uc);
	return c == ctrl('[') ? 2 : 1;
}

waitnl1(w, prompt)
struct ww *w;
char *prompt;
{
	int uc = ISSET(w->ww_wflags, WWW_UNCTRL);

	CLR(w->ww_wflags, WWW_UNCTRL);
	front(w, 0);
	wwprintf(w, "\033Y%c%c\033sA%s\033rA ",
		w->ww_w.nr - 1 + ' ', ' ', prompt);	/* print on last line */
	wwcurtowin(w);
	while (wwpeekc() < 0)
		wwiomux();
	SET(w->ww_wflags, uc);
	return wwgetc();
}
@


1.7
log
@Remove the advertising clause in the UCB license which Berkeley
rescinded 22 July 1999.  Proofed by myself and Theo.
@
text
@d1 1
a1 1
/*	$OpenBSD: win.c,v 1.6 2001/11/19 19:02:18 mpech Exp $	*/
d40 1
a40 1
static char rcsid[] = "$OpenBSD: win.c,v 1.6 2001/11/19 19:02:18 mpech Exp $";
@


1.6
log
@kill more registers

millert@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: win.c,v 1.5 1997/02/25 00:04:32 downsj Exp $	*/
d19 1
a19 5
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
d40 1
a40 1
static char rcsid[] = "$OpenBSD: win.c,v 1.5 1997/02/25 00:04:32 downsj Exp $";
@


1.5
log
@Reimport NetBSD version w/ Todd's changes, new rcsids, and the beginings of
some source cleaning by me.

This undoes Theo's wait() changes which broke the old version.
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d44 1
a44 1
static char rcsid[] = "$OpenBSD$";
d76 1
a76 1
	register struct ww *w;
d116 1
a116 1
	register i;
d130 2
a131 2
	register struct ww *w, *s = 0;
	register i;
d145 1
a145 1
register struct ww *w;
d148 1
a148 1
	register i;
d181 1
a181 1
	register struct ww *w;
d205 1
a205 1
register struct ww *w;
d227 1
a227 1
register struct ww *w;
d244 1
a244 1
register struct ww *w;
d260 1
a260 1
register struct ww *w;
d269 1
a269 1
	register struct ww *w;
d280 1
a280 1
register struct ww *w;
d306 1
a306 1
	register struct ww *w;
d315 1
a315 1
	register struct ww *w;
d324 1
a324 1
register struct ww *w;
d344 1
a344 1
register struct ww *w;
d360 1
a360 1
register struct ww *w;
@


1.4
log
@rcsid
@
text
@d1 1
a1 1
/*	$OpenBSD: win.c,v 1.8 1996/02/08 21:07:57 mycroft Exp $	*/
d44 1
a44 1
static char rcsid[] = "$OpenBSD: win.c,v 1.8 1996/02/08 21:07:57 mycroft Exp $";
@


1.3
log
@Minor cleanup for 8-bit cleanliness.  From der Mouse, PR 1322.
Eliminate the use of char variables for holding booleans.
Compress struct ww somewhat.
Make ww_index and related variables explicitly unsigned.
@
text
@d1 1
d44 1
a44 1
static char rcsid[] = "$NetBSD: win.c,v 1.8 1996/02/08 21:07:57 mycroft Exp $";
@


1.2
log
@from netbsd:
Use POSIX signals.  Always set FNONBLOCK on the tty.
Eliminate the use of SIGIO, and some other cleanup.
We don't need non-blocking mode without SIGIO.
@
text
@d1 1
a1 1
/*	$NetBSD: win.c,v 1.6 1995/12/21 10:46:01 mycroft Exp $	*/
d43 1
a43 1
static char rcsid[] = "$NetBSD: win.c,v 1.6 1995/12/21 10:46:01 mycroft Exp $";
d71 1
a71 1
openwin(id, row, col, nrow, ncol, nline, label, haspty, hasframe, shf, sh)
a72 1
char haspty, hasframe;
d84 1
a84 1
	w = wwopen(haspty ? WWT_PTY : WWT_SOCKET, 0, nrow, ncol, row, col, nline);
d91 2
a92 1
	w->ww_hasframe = hasframe;
d184 2
a185 5
	w->ww_mapnl = 1;
	w->ww_hasframe = 1;
	w->ww_nointr = 1;
	w->ww_noupdate = 1;
	w->ww_unctrl = 1;
a186 1
	w->ww_center = 1;
d272 1
a272 1
		if (w->ww_hasframe) {
d283 1
a283 1
	if (!w->ww_hasframe)
d295 1
a295 1
		if (w->ww_center) {
d310 1
a310 1
		w->ww_stopped = 1;
d319 1
a319 1
		w->ww_stopped = 0;
d347 1
a347 1
	char uc = w->ww_unctrl;
d352 1
a352 1
	w->ww_unctrl = 0;
d354 1
a354 1
	w->ww_unctrl = uc;
d362 1
a362 1
	char uc = w->ww_unctrl;
d364 1
a364 1
	w->ww_unctrl = 0;
d371 1
a371 1
	w->ww_unctrl = uc;
@


1.1
log
@Initial revision
@
text
@d1 1
a1 1
/*	$NetBSD: win.c,v 1.5 1995/09/29 00:44:08 cgd Exp $	*/
d43 1
a43 1
static char rcsid[] = "$NetBSD: win.c,v 1.5 1995/09/29 00:44:08 cgd Exp $";
d85 1
a85 1
	w = wwopen(haspty ? WWO_PTY : WWO_SOCKET, nrow, ncol, row, col, nline);
d182 1
a182 1
	if ((w = wwopen(0, nrow, wwncol, 2, 0, 0)) == 0)
d311 1
a311 1
	if (w->ww_pty >= 0 && w->ww_ispty && wwstoptty(w->ww_pty) < 0)
d320 1
a320 1
	if (w->ww_pty >= 0 && w->ww_ispty && wwstarttty(w->ww_pty) < 0)
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@
