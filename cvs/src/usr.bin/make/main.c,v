head	1.122;
access;
symbols
	OPENBSD_6_1:1.121.0.4
	OPENBSD_6_1_BASE:1.121
	OPENBSD_6_0:1.119.0.4
	OPENBSD_6_0_BASE:1.119
	OPENBSD_5_9:1.119.0.2
	OPENBSD_5_9_BASE:1.119
	OPENBSD_5_8:1.110.0.6
	OPENBSD_5_8_BASE:1.110
	OPENBSD_5_7:1.110.0.2
	OPENBSD_5_7_BASE:1.110
	OPENBSD_5_6:1.104.0.4
	OPENBSD_5_6_BASE:1.104
	OPENBSD_5_5:1.102.0.4
	OPENBSD_5_5_BASE:1.102
	OPENBSD_5_4:1.101.0.2
	OPENBSD_5_4_BASE:1.101
	OPENBSD_5_3:1.100.0.2
	OPENBSD_5_3_BASE:1.100
	OPENBSD_5_2:1.95.0.10
	OPENBSD_5_2_BASE:1.95
	OPENBSD_5_1_BASE:1.95
	OPENBSD_5_1:1.95.0.8
	OPENBSD_5_0:1.95.0.6
	OPENBSD_5_0_BASE:1.95
	OPENBSD_4_9:1.95.0.4
	OPENBSD_4_9_BASE:1.95
	OPENBSD_4_8:1.95.0.2
	OPENBSD_4_8_BASE:1.95
	OPENBSD_4_7:1.93.0.2
	OPENBSD_4_7_BASE:1.93
	OPENBSD_4_6:1.92.0.6
	OPENBSD_4_6_BASE:1.92
	OPENBSD_4_5:1.92.0.2
	OPENBSD_4_5_BASE:1.92
	OPENBSD_4_4:1.91.0.4
	OPENBSD_4_4_BASE:1.91
	OPENBSD_4_3:1.91.0.2
	OPENBSD_4_3_BASE:1.91
	OPENBSD_4_2:1.76.0.2
	OPENBSD_4_2_BASE:1.76
	OPENBSD_4_1:1.69.0.2
	OPENBSD_4_1_BASE:1.69
	OPENBSD_4_0:1.68.0.2
	OPENBSD_4_0_BASE:1.68
	OPENBSD_3_9:1.67.0.2
	OPENBSD_3_9_BASE:1.67
	OPENBSD_3_8:1.66.0.4
	OPENBSD_3_8_BASE:1.66
	OPENBSD_3_7:1.66.0.2
	OPENBSD_3_7_BASE:1.66
	OPENBSD_3_6:1.65.0.2
	OPENBSD_3_6_BASE:1.65
	OPENBSD_3_5:1.63.0.2
	OPENBSD_3_5_BASE:1.63
	OPENBSD_3_4:1.62.0.2
	OPENBSD_3_4_BASE:1.62
	OPENBSD_3_3:1.59.0.2
	OPENBSD_3_3_BASE:1.59
	OPENBSD_3_2:1.57.0.4
	OPENBSD_3_2_BASE:1.57
	OPENBSD_3_1:1.57.0.2
	OPENBSD_3_1_BASE:1.57
	OPENBSD_3_0:1.53.0.2
	OPENBSD_3_0_BASE:1.53
	OPENBSD_2_9_BASE:1.45
	OPENBSD_2_9:1.45.0.2
	OPENBSD_2_8:1.44.0.2
	OPENBSD_2_8_BASE:1.44
	OPENBSD_2_7:1.30.0.2
	OPENBSD_2_7_BASE:1.30
	OPENBSD_2_6:1.15.0.4
	OPENBSD_2_6_BASE:1.15
	OPENBSD_2_5:1.15.0.2
	OPENBSD_2_5_BASE:1.15
	OPENBSD_2_4:1.13.0.4
	OPENBSD_2_4_BASE:1.13
	OPENBSD_2_3:1.13.0.2
	OPENBSD_2_3_BASE:1.13
	OPENBSD_2_2:1.12.0.4
	OPENBSD_2_2_BASE:1.12
	OPENBSD_2_1:1.12.0.2
	OPENBSD_2_1_BASE:1.12
	OPENBSD_2_0:1.8.0.2
	OPENBSD_2_0_BASE:1.8
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.122
date	2017.04.20.03.04.11;	author dlg;	state Exp;
branches;
next	1.121;
commitid	meXbEPQhPjAATGev;

1.121
date	2016.10.21.16.12.38;	author espie;	state Exp;
branches;
next	1.120;
commitid	aLVdeKrJ0t5upS3l;

1.120
date	2016.10.12.00.31.06;	author tb;	state Exp;
branches;
next	1.119;
commitid	e1s1NuvBU4xq3vx2;

1.119
date	2016.01.04.10.59.23;	author tb;	state Exp;
branches;
next	1.118;
commitid	4ZJlmiXAuHnZl769;

1.118
date	2015.12.29.19.04.46;	author gsoares;	state Exp;
branches;
next	1.117;
commitid	k2UzU75zoPNqkN7K;

1.117
date	2015.11.29.09.17.12;	author espie;	state Exp;
branches;
next	1.116;
commitid	ksdjFFnlF9CNScbW;

1.116
date	2015.11.15.06.19.22;	author daniel;	state Exp;
branches;
next	1.115;
commitid	NHRgVVfv00xsvnmo;

1.115
date	2015.10.14.13.50.22;	author espie;	state Exp;
branches;
next	1.114;
commitid	N2KJxs0d4DGFAkuD;

1.114
date	2015.10.09.01.37.08;	author deraadt;	state Exp;
branches;
next	1.113;
commitid	sbrB3Q5CNxcwZpfU;

1.113
date	2015.10.08.14.49.27;	author deraadt;	state Exp;
branches;
next	1.112;
commitid	rhK3gYgxcVgZBoH0;

1.112
date	2015.10.07.14.16.09;	author deraadt;	state Exp;
branches;
next	1.111;
commitid	KDDCu7RFPPBIkRR6;

1.111
date	2015.10.07.14.14.30;	author deraadt;	state Exp;
branches;
next	1.110;
commitid	qWGXLNMdIBALeDBk;

1.110
date	2015.02.07.18.52.35;	author jmc;	state Exp;
branches;
next	1.109;
commitid	Bkm1wQVSbBzgfBy8;

1.109
date	2015.02.07.13.32.12;	author espie;	state Exp;
branches;
next	1.108;
commitid	VKPxmjga4qw7xwrH;

1.108
date	2015.01.23.22.35.57;	author espie;	state Exp;
branches;
next	1.107;
commitid	WtGGWUPWONvkhNGN;

1.107
date	2015.01.23.13.18.40;	author espie;	state Exp;
branches;
next	1.106;
commitid	iXa5WmoY9RgeqDsn;

1.106
date	2015.01.16.15.36.30;	author deraadt;	state Exp;
branches;
next	1.105;
commitid	UtvDri2GsrO6f1f5;

1.105
date	2015.01.16.15.17.34;	author deraadt;	state Exp;
branches;
next	1.104;
commitid	nNyTyhUIvXvLNlLY;

1.104
date	2014.07.15.23.07.19;	author deraadt;	state Exp;
branches;
next	1.103;
commitid	nDEgowbNlRRDUtxK;

1.103
date	2014.05.15.19.40.42;	author chl;	state Exp;
branches;
next	1.102;

1.102
date	2013.11.24.12.36.13;	author espie;	state Exp;
branches;
next	1.101;

1.101
date	2013.07.07.09.41.08;	author espie;	state Exp;
branches;
next	1.100;

1.100
date	2012.10.18.17.54.43;	author espie;	state Exp;
branches;
next	1.99;

1.99
date	2012.10.09.19.47.09;	author espie;	state Exp;
branches;
next	1.98;

1.98
date	2012.10.06.09.32.40;	author espie;	state Exp;
branches;
next	1.97;

1.97
date	2012.10.02.10.29.31;	author espie;	state Exp;
branches;
next	1.96;

1.96
date	2012.09.21.07.55.20;	author espie;	state Exp;
branches;
next	1.95;

1.95
date	2010.07.19.19.46.44;	author espie;	state Exp;
branches;
next	1.94;

1.94
date	2010.07.15.10.41.11;	author espie;	state Exp;
branches;
next	1.93;

1.93
date	2010.02.03.20.45.44;	author miod;	state Exp;
branches;
next	1.92;

1.92
date	2008.11.04.07.22.35;	author espie;	state Exp;
branches;
next	1.91;

1.91
date	2008.01.10.20.34.03;	author espie;	state Exp;
branches;
next	1.90;

1.90
date	2007.11.28.09.40.08;	author espie;	state Exp;
branches;
next	1.89;

1.89
date	2007.11.17.09.49.53;	author espie;	state Exp;
branches;
next	1.88;

1.88
date	2007.11.03.11.44.30;	author espie;	state Exp;
branches;
next	1.87;

1.87
date	2007.11.02.17.27.24;	author espie;	state Exp;
branches;
next	1.86;

1.86
date	2007.10.24.13.19.24;	author espie;	state Exp;
branches;
next	1.85;

1.85
date	2007.09.23.09.44.39;	author espie;	state Exp;
branches;
next	1.84;

1.84
date	2007.09.18.07.45.25;	author espie;	state Exp;
branches;
next	1.83;

1.83
date	2007.09.17.12.42.09;	author espie;	state Exp;
branches;
next	1.82;

1.82
date	2007.09.17.12.01.17;	author espie;	state Exp;
branches;
next	1.81;

1.81
date	2007.09.17.11.11.30;	author espie;	state Exp;
branches;
next	1.80;

1.80
date	2007.09.17.09.28.36;	author espie;	state Exp;
branches;
next	1.79;

1.79
date	2007.09.16.12.30.35;	author espie;	state Exp;
branches;
next	1.78;

1.78
date	2007.09.16.10.14.26;	author espie;	state Exp;
branches;
next	1.77;

1.77
date	2007.09.16.09.46.14;	author espie;	state Exp;
branches;
next	1.76;

1.76
date	2007.07.30.09.51.53;	author espie;	state Exp;
branches;
next	1.75;

1.75
date	2007.07.30.09.39.18;	author espie;	state Exp;
branches;
next	1.74;

1.74
date	2007.07.24.18.58.48;	author espie;	state Exp;
branches;
next	1.73;

1.73
date	2007.07.24.18.56.15;	author espie;	state Exp;
branches;
next	1.72;

1.72
date	2007.07.24.18.52.47;	author espie;	state Exp;
branches;
next	1.71;

1.71
date	2007.07.21.14.41.07;	author espie;	state Exp;
branches;
next	1.70;

1.70
date	2007.07.08.17.44.20;	author espie;	state Exp;
branches;
next	1.69;

1.69
date	2006.09.26.18.20.50;	author mk;	state Exp;
branches;
next	1.68;

1.68
date	2006.05.06.10.52.34;	author espie;	state Exp;
branches;
next	1.67;

1.67
date	2006.02.26.18.06.15;	author jmc;	state Exp;
branches;
next	1.66;

1.66
date	2005.02.17.02.37.21;	author jolan;	state Exp;
branches;
next	1.65;

1.65
date	2004.04.21.13.17.49;	author jmc;	state Exp;
branches;
next	1.64;

1.64
date	2004.04.07.13.11.36;	author espie;	state Exp;
branches;
next	1.63;

1.63
date	2004.01.30.17.37.37;	author espie;	state Exp;
branches;
next	1.62;

1.62
date	2003.06.03.02.56.11;	author millert;	state Exp;
branches;
next	1.61;

1.61
date	2003.04.21.23.14.06;	author millert;	state Exp;
branches;
next	1.60;

1.60
date	2003.04.06.22.47.14;	author espie;	state Exp;
branches;
next	1.59;

1.59
date	2002.12.30.22.12.38;	author millert;	state Exp;
branches;
next	1.58;

1.58
date	2002.12.30.02.29.24;	author millert;	state Exp;
branches;
next	1.57;

1.57
date	2002.03.02.00.23.14;	author espie;	state Exp;
branches;
next	1.56;

1.56
date	2001.11.11.12.35.02;	author espie;	state Exp;
branches;
next	1.55;

1.55
date	2001.11.11.06.02.06;	author deraadt;	state Exp;
branches;
next	1.54;

1.54
date	2001.11.11.01.19.23;	author espie;	state Exp;
branches;
next	1.53;

1.53
date	2001.06.05.11.59.11;	author espie;	state Exp;
branches;
next	1.52;

1.52
date	2001.06.03.16.33.48;	author espie;	state Exp;
branches;
next	1.51;

1.51
date	2001.05.31.13.38.48;	author espie;	state Exp;
branches;
next	1.50;

1.50
date	2001.05.29.17.00.54;	author espie;	state Exp;
branches;
next	1.49;

1.49
date	2001.05.29.12.53.41;	author espie;	state Exp;
branches;
next	1.48;

1.48
date	2001.05.23.12.34.46;	author espie;	state Exp;
branches;
next	1.47;

1.47
date	2001.05.07.22.57.19;	author espie;	state Exp;
branches;
next	1.46;

1.46
date	2001.05.03.13.41.07;	author espie;	state Exp;
branches;
next	1.45;

1.45
date	2000.11.24.14.36.34;	author espie;	state Exp;
branches;
next	1.44;

1.44
date	2000.10.13.08.29.20;	author espie;	state Exp;
branches;
next	1.43;

1.43
date	2000.09.14.13.46.45;	author espie;	state Exp;
branches;
next	1.42;

1.42
date	2000.09.14.13.43.31;	author espie;	state Exp;
branches;
next	1.41;

1.41
date	2000.09.14.13.32.07;	author espie;	state Exp;
branches;
next	1.40;

1.40
date	2000.07.31.21.01.40;	author espie;	state Exp;
branches;
next	1.39;

1.39
date	2000.07.18.20.17.20;	author espie;	state Exp;
branches;
next	1.38;

1.38
date	2000.07.01.00.21.22;	author espie;	state Exp;
branches;
next	1.37;

1.37
date	2000.06.23.16.39.45;	author espie;	state Exp;
branches;
next	1.36;

1.36
date	2000.06.23.16.23.26;	author espie;	state Exp;
branches;
next	1.35;

1.35
date	2000.06.23.16.15.49;	author espie;	state Exp;
branches;
next	1.34;

1.34
date	2000.06.17.14.40.29;	author espie;	state Exp;
branches;
next	1.33;

1.33
date	2000.06.17.14.38.18;	author espie;	state Exp;
branches;
next	1.32;

1.32
date	2000.06.10.01.41.05;	author espie;	state Exp;
branches;
next	1.31;

1.31
date	2000.06.10.01.32.23;	author espie;	state Exp;
branches;
next	1.30;

1.30
date	2000.04.03.02.58.46;	author espie;	state Exp;
branches;
next	1.29;

1.29
date	2000.03.26.16.21.32;	author espie;	state Exp;
branches;
next	1.28;

1.28
date	2000.02.02.13.47.47;	author espie;	state Exp;
branches;
next	1.27;

1.27
date	99.12.19.00.04.25;	author espie;	state Exp;
branches;
next	1.26;

1.26
date	99.12.18.21.58.07;	author espie;	state Exp;
branches;
next	1.25;

1.25
date	99.12.18.21.53.32;	author espie;	state Exp;
branches;
next	1.24;

1.24
date	99.12.18.02.11.27;	author espie;	state Exp;
branches;
next	1.23;

1.23
date	99.12.16.17.27.18;	author espie;	state Exp;
branches;
next	1.22;

1.22
date	99.12.16.17.02.45;	author espie;	state Exp;
branches;
next	1.21;

1.21
date	99.12.16.16.41.41;	author espie;	state Exp;
branches;
next	1.20;

1.20
date	99.12.09.18.20.06;	author espie;	state Exp;
branches;
next	1.19;

1.19
date	99.12.06.22.28.44;	author espie;	state Exp;
branches;
next	1.18;

1.18
date	99.12.06.22.24.31;	author espie;	state Exp;
branches;
next	1.17;

1.17
date	99.12.06.22.20.34;	author espie;	state Exp;
branches;
next	1.16;

1.16
date	99.11.10.14.11.49;	author espie;	state Exp;
branches;
next	1.15;

1.15
date	99.01.09.16.45.02;	author espie;	state Exp;
branches;
next	1.14;

1.14
date	98.12.05.00.06.28;	author espie;	state Exp;
branches;
next	1.13;

1.13
date	98.01.28.12.41.50;	author niklas;	state Exp;
branches;
next	1.12;

1.12
date	97.04.01.07.28.13;	author millert;	state Exp;
branches;
next	1.11;

1.11
date	97.01.27.05.24.09;	author briggs;	state Exp;
branches;
next	1.10;

1.10
date	97.01.15.23.42.51;	author millert;	state Exp;
branches;
next	1.9;

1.9
date	96.11.30.21.08.59;	author millert;	state Exp;
branches;
next	1.8;

1.8
date	96.09.02.16.04.13;	author briggs;	state Exp;
branches;
next	1.7;

1.7
date	96.04.21.23.43.21;	author deraadt;	state Exp;
branches;
next	1.6;

1.6
date	96.03.27.19.32.36;	author niklas;	state Exp;
branches;
next	1.5;

1.5
date	96.02.23.18.32.56;	author niklas;	state Exp;
branches;
next	1.4;

1.4
date	96.02.22.22.24.49;	author niklas;	state Exp;
branches;
next	1.3;

1.3
date	96.01.03.09.50.47;	author deraadt;	state Exp;
branches;
next	1.2;

1.2
date	95.12.14.03.23.33;	author deraadt;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.45.42;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.45.42;	author deraadt;	state Exp;
branches;
next	;


desc
@@


1.122
log
@use strtonum instead of strtoll to parse the argument to -j

ok deraadt@@ benno@@
@
text
@/*	$OpenBSD: main.c,v 1.121 2016/10/21 16:12:38 espie Exp $ */
/*	$NetBSD: main.c,v 1.34 1997/03/24 20:56:36 gwr Exp $	*/

/*
 * Copyright (c) 1988, 1989, 1990, 1993
 *	The Regents of the University of California.  All rights reserved.
 * Copyright (c) 1989 by Berkeley Softworks
 * All rights reserved.
 *
 * This code is derived from software contributed to Berkeley by
 * Adam de Boor.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */

#include <sys/param.h>	/* MACHINE MACHINE_ARCH */
#include <sys/types.h>
#include <sys/stat.h>
#include <sys/utsname.h>
#include <err.h>
#include <errno.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include "config.h"
#include "defines.h"
#include "var.h"
#include "lowparse.h"
#include "parse.h"
#include "parsevar.h"
#include "dir.h"
#include "direxpand.h"
#include "error.h"
#include "pathnames.h"
#include "init.h"
#include "job.h"
#include "compat.h"
#include "targ.h"
#include "suff.h"
#include "str.h"
#include "main.h"
#include "lst.h"
#include "memory.h"
#include "make.h"
#include "dump.h"

#define MAKEFLAGS	".MAKEFLAGS"

static LIST		to_create; 	/* Targets to be made */
Lst create = &to_create;
bool 		allPrecious;	/* .PRECIOUS given on line by itself */

static bool		noBuiltins;	/* -r flag */
static LIST		makefiles;	/* ordered list of makefiles to read */
static LIST		varstoprint;	/* list of variables to print */
int			maxJobs;	/* -j argument */
bool 		compatMake;	/* -B argument */
static bool		forceJobs = false;
int 		debug;		/* -d flag */
bool 		noExecute;	/* -n flag */
bool 		keepgoing;	/* -k flag */
bool 		queryFlag;	/* -q flag */
bool 		touchFlag;	/* -t flag */
bool 		ignoreErrors;	/* -i flag */
bool 		beSilent;	/* -s flag */
bool		dumpData;	/* -p flag */

struct dirs {
	char *current;
	char *object;
};

static void MainParseArgs(int, char **);
static void add_dirpath(Lst, const char *);
static void usage(void);
static void posixParseOptLetter(int);
static void record_option(int, const char *);

static char *figure_out_MACHINE(void);
static char *figure_out_MACHINE_ARCH(void);
static char *figure_out_MACHINE_CPU(void);

static char *chdir_verify_path(const char *, struct dirs *);
static char *figure_out_CURDIR(void);
static void setup_CURDIR_OBJDIR(struct dirs *);

static void setup_VPATH(void);

static void read_all_make_rules(bool, bool, Lst, struct dirs *);
static void read_makefile_list(Lst, struct dirs *);
static bool ReadMakefile(void *, void *);

static void
record_option(int c, const char *arg)
{
    	char opt[3];

	opt[0] = '-';
	opt[1] = c;
	opt[2] = '\0';
	Var_Append(MAKEFLAGS, opt);
	if (arg != NULL)
		Var_Append(MAKEFLAGS, arg);
}

static void
posixParseOptLetter(int c)
{
	switch(c) {
	case 'B':
		compatMake = true;
		return;	/* XXX don't pass to submakes. */
	case 'S':
		keepgoing = false;
		break;
	case 'e':
		Var_setCheckEnvFirst(true);
		break;
	case 'i':
		ignoreErrors = true;
		break;
	case 'k':
		keepgoing = true;
		break;
	case 'n':
		noExecute = true;
		break;
	case 'p':
		dumpData = true;
		break;
	case 'q':
		queryFlag = true;
		/* Kind of nonsensical, wot? */
		break;
	case 'r':
		noBuiltins = true;
		break;
	case 's':
		beSilent = true;
		break;
	case 't':
		touchFlag = true;
		break;
	default:
	case '?':
		usage();
	}
	record_option(c, NULL);
}

/*-
 * MainParseArgs --
 *	Parse a given argument vector. Called from main() and from
 *	Main_ParseArgLine() when the .MAKEFLAGS target is used.
 *
 *	XXX: Deal with command line overriding .MAKEFLAGS in makefile
 *
 * Side Effects:
 *	Various global and local flags will be set depending on the flags
 *	given
 */
static void
MainParseArgs(int argc, char **argv)
{
	int c, optend;

#define OPTFLAGS "BC:D:I:SV:d:ef:ij:km:npqrst"
#define OPTLETTERS "BSiknpqrst"

	if (pledge("stdio rpath wpath cpath fattr proc exec", NULL) == -1)
		err(2, "pledge");

	optind = 1;	/* since we're called more than once */
	optreset = 1;
	optend = 0;
	while (optind < argc) {
		if (!optend && argv[optind][0] == '-') {
			if (argv[optind][1] == '\0')
				optind++;	/* ignore "-" */
			else if (argv[optind][1] == '-' &&
			    argv[optind][2] == '\0') {
				optind++;	/* ignore "--" */
				optend++;	/* "--" denotes end of flags */
			}
		}
		c = optend ? -1 : getopt(argc, argv, OPTFLAGS);
		switch (c) {
		case 'C':
			break;
		case 'D':
			Var_Set(optarg, "1");
			record_option(c, optarg);
			break;
		case 'I':
			Parse_AddIncludeDir(optarg);
			record_option(c, optarg);
			break;
		case 'V':
			Lst_AtEnd(&varstoprint, optarg);
			record_option(c, optarg);
			break;
		case 'd': {
			char *modules = optarg;

			for (; *modules; ++modules)
				switch (*modules) {
				case 'A':
					debug = ~0;
					break;
				case 'a':
					debug |= DEBUG_ARCH;
					break;
				case 'c':
					debug |= DEBUG_COND;
					break;
				case 'd':
					debug |= DEBUG_DIR;
					break;
				case 'D':
					debug |= DEBUG_DOUBLE;
					break;
				case 'e':
					debug |= DEBUG_EXPENSIVE;
					break;
				case 'f':
					debug |= DEBUG_FOR;
					break;
				case 'g':
					if (modules[1] == '1') {
						debug |= DEBUG_GRAPH1;
						++modules;
					}
					else if (modules[1] == '2') {
						debug |= DEBUG_GRAPH2;
						++modules;
					}
					break;
				case 'h':
					debug |= DEBUG_HELDJOBS;
					break;
				case 'j':
					debug |= DEBUG_JOB | DEBUG_KILL;
					break;
				case 'J':
					/* ignore */
					break;
				case 'k':
					debug |= DEBUG_KILL;
					break;
				case 'l':
					debug |= DEBUG_LOUD;
					break;
				case 'm':
					debug |= DEBUG_MAKE;
					break;
				case 'n':
					debug |= DEBUG_NAME_MATCHING;
					break;
				case 'p':
					debug |= DEBUG_PARALLEL;
					break;
				case 'q':
					debug |= DEBUG_QUICKDEATH;
					break;
				case 's':
					debug |= DEBUG_SUFF;
					break;
				case 't':
					debug |= DEBUG_TARG;
					break;
				case 'T':
					debug |= DEBUG_TARGGROUP;
					break;
				case 'v':
					debug |= DEBUG_VAR;
					break;
				default:
					(void)fprintf(stderr,
				"make: illegal argument to -d option -- %c\n",
					    *modules);
					usage();
				}
			record_option(c, optarg);
			break;
		}
		case 'f':
			Lst_AtEnd(&makefiles, optarg);
			break;
		case 'j': {
			const char *errstr;

			forceJobs = true;
			maxJobs = strtonum(optarg, 1, INT_MAX, &errstr);
			if (errstr != NULL) {
				fprintf(stderr,
				    "make: illegal argument to -j option"
				    " -- %s -- %s\n", optarg, errstr);
				usage();
			}
			record_option(c, optarg);
			break;
		}
		case 'm':
			Dir_AddDir(systemIncludePath, optarg);
			record_option(c, optarg);
			break;
		case -1:
			/* Check for variable assignments and targets. */
			if (argv[optind] != NULL &&
			    !Parse_CmdlineVar(argv[optind])) {
				if (!*argv[optind])
					Punt("illegal (null) argument.");
				Lst_AtEnd(create, estrdup(argv[optind]));
			}
			optind++;	/* skip over non-option */
			break;
		default:
			posixParseOptLetter(c);
		}
	}
}

static void
MainParseChdir(int argc, char **argv)
{
	int c, optend, oldopterr;

	optind = 1;	/* since we're called more than once */
	optreset = 1;
	optend = 0;
	oldopterr = opterr;
	opterr = 0;
	while (optind < argc) {
		if (!optend && argv[optind][0] == '-') {
			if (argv[optind][1] == '\0')
				optind++;	/* ignore "-" */
			else if (argv[optind][1] == '-' &&
			    argv[optind][2] == '\0') {
				optind++;	/* ignore "--" */
				optend++;	/* "--" denotes end of flags */
			}
		}
		c = optend ? -1 : getopt(argc, argv, OPTFLAGS);
		switch (c) {
		case 'C':
			if (chdir(optarg) == -1)
				err(2, "chdir(%s)", optarg);
			break;
		case -1:
			optind++;	/* skip over non-option */
			break;
		default:
			break;
		}
	}
	opterr = oldopterr;
}

/*-
 * Main_ParseArgLine --
 *	Used by the parse module when a .MFLAGS or .MAKEFLAGS target
 *	is encountered and by main() when reading the .MAKEFLAGS envariable.
 *	Takes a line of arguments and breaks it into its
 *	component words and passes those words and the number of them to the
 *	MainParseArgs function.
 *	The line should have all its leading whitespace removed.
 *
 * Side Effects:
 *	Only those that come from the various arguments.
 */
void
Main_ParseArgLine(const char *line) 	/* Line to fracture */
{
	char **argv;			/* Manufactured argument vector */
	int argc;			/* Number of arguments in argv */
	char *args;			/* Space used by the args */
	char *buf;
	char *argv0;
	const char *s;
	size_t len;


	if (line == NULL)
		return;
	for (; *line == ' '; ++line)
		continue;
	if (!*line)
		return;

	/* POSIX rule: MAKEFLAGS can hold a set of option letters without
	 * any blanks or dashes. */
	for (s = line;; s++) {
		if (*s == '\0') {
			while (line != s)
				posixParseOptLetter(*line++);
			return;
		}
		if (strchr(OPTLETTERS, *s) == NULL)
			break;
	}
	argv0 = Var_Value(".MAKE");
	len = strlen(line) + strlen(argv0) + 2;
	buf = emalloc(len);
	(void)snprintf(buf, len, "%s %s", argv0, line);

	argv = brk_string(buf, &argc, &args);
	free(buf);
	MainParseArgs(argc, argv);

	free(args);
	free(argv);
}

/* Add a :-separated path to a Lst of directories.  */
static void
add_dirpath(Lst l, const char *n)
{
	const char *start;
	const char *cp;

	for (start = n;;) {
		for (cp = start; *cp != '\0' && *cp != ':';)
			cp++;
		Dir_AddDiri(l, start, cp);
		if (*cp == '\0')
			break;
		else
			start= cp+1;
	}
}

/*
 * Get the name of this type of MACHINE from utsname so we can share an
 * executable for similar machines. (i.e. m68k: amiga hp300, mac68k, sun3, ...)
 *
 * Note that MACHINE, MACHINE_ARCH and MACHINE_CPU are decided at
 * run-time.
 */
static char *
figure_out_MACHINE()
{
	char *r = getenv("MACHINE");
	if (r == NULL) {
		static struct utsname utsname;

		if (uname(&utsname) == -1)
			err(2, "uname");
		r = utsname.machine;
	}
	return r;
}

static char *
figure_out_MACHINE_ARCH()
{
	char *r = getenv("MACHINE_ARCH");
	if (r == NULL) {
#ifndef MACHINE_ARCH
		r = "unknown";	/* XXX: no uname -p yet */
#else
		r = MACHINE_ARCH;
#endif
	}
	return r;
}
static char *
figure_out_MACHINE_CPU()
{
	char *r = getenv("MACHINE_CPU");
	if (r == NULL) {
#if !defined(MACHINE_CPU) && ! defined(MACHINE_ARCH)
		r = "unknown";	/* XXX: no uname -p yet */
#else
#if defined(MACHINE_CPU)
		r = MACHINE_CPU;
#else
		r = MACHINE_ARCH;
#endif
#endif
	}
	return r;
}

static char *
figure_out_CURDIR()
{
	char *dir, *cwd;
	struct stat sa, sb;

	/* curdir is cwd... */
	cwd = dogetcwd();
	if (cwd == NULL)
		err(2, "%s", strerror(errno));

	if (stat(cwd, &sa) == -1)
		err(2, "%s: %s", cwd, strerror(errno));

	/* ...but we can use the alias $PWD if we can prove it is the same
	 * directory */
	if ((dir = getenv("PWD")) != NULL) {
		if (stat(dir, &sb) == 0 && sa.st_ino == sb.st_ino &&
		    sa.st_dev == sb.st_dev) {
		    	free(cwd);
			return estrdup(dir);
		}
	}

	return cwd;
}

static char *
chdir_verify_path(const char *path, struct dirs *d)
{
	if (chdir(path) == 0) {
		if (path[0] != '/')
			return Str_concat(d->current, path, '/');
		else
			return estrdup(path);
	}
	return NULL;
}

static void
setup_CURDIR_OBJDIR(struct dirs *d)
{
	char *path;

	d->current = figure_out_CURDIR();
	/*
	 * If the MAKEOBJDIR (or by default, the _PATH_OBJDIR) directory
	 * exists, change into it and build there.  
	 *
	 * Once things are initted,
	 * have to add the original directory to the search path,
	 * and modify the paths for the Makefiles appropriately.  The
	 * current directory is also placed as a variable for make scripts.
	 */
	if ((path = getenv("MAKEOBJDIR")) == NULL) {
		path = _PATH_OBJDIR;
	} 
	d->object = chdir_verify_path(path, d);
	if (d->object == NULL)
		d->object = d->current;
}

/*
 * if the VPATH variable is defined, add its contents to the search path.
 * Uses the same format as the PATH env variable, i.e.,
 * <directory>:<directory>:<directory>...
 */
static void
setup_VPATH()
{
	if (Var_Value("VPATH") != NULL) {
		char *vpath;

		vpath = Var_Subst("${VPATH}", NULL, false);
		add_dirpath(defaultPath, vpath);
		(void)free(vpath);
	}
}

static void
read_makefile_list(Lst mk, struct dirs *d)
{
	LstNode ln;
	ln = Lst_Find(mk, ReadMakefile, d);
	if (ln != NULL)
		Fatal("make: cannot open %s.", (char *)Lst_Datum(ln));
}

static void
read_all_make_rules(bool noBuiltins, bool read_depend,
    Lst makefiles, struct dirs *d)
{
	/*
	 * Read in the built-in rules first, followed by the specified
	 * makefile(s), or the default Makefile or makefile, in that order.
	 */
	if (!noBuiltins) {
		LIST sysMkPath; 		/* Path of sys.mk */

		Lst_Init(&sysMkPath);
		Dir_Expand(_PATH_DEFSYSMK, systemIncludePath, &sysMkPath);
		if (Lst_IsEmpty(&sysMkPath))
			Fatal("make: no system rules (%s).", _PATH_DEFSYSMK);

		read_makefile_list(&sysMkPath, d);
	}

	if (!Lst_IsEmpty(makefiles)) {
		read_makefile_list(makefiles, d);
	} else if (!ReadMakefile("makefile", d))
		(void)ReadMakefile("Makefile", d);

	/* read a .depend file, if it exists, and we're not building depend */

	if (read_depend)
		(void)ReadMakefile(".depend", d);
	Parse_End();
}


int main(int, char **);
/*-
 * main --
 *	The main function, for obvious reasons. Initializes variables
 *	and a few modules, then parses the arguments give it in the
 *	environment and on the command line. Reads the system makefile
 *	followed by either Makefile, makefile or the file given by the
 *	-f argument. Sets the .MAKEFLAGS PMake variable based on all the
 *	flags it has received by then uses either the Make or the Compat
 *	module to create the initial list of targets.
 *
 * Results:
 *	If -q was given, exits -1 if anything was out-of-date. Else it exits
 *	0.
 *
 * Side Effects:
 *	The program exits when done. Targets are created. etc. etc. etc.
 */
int
main(int argc, char **argv)
{
	static LIST targs;	/* target nodes to create */
	bool outOfDate = true;	/* false if all targets up to date */
	char *machine = figure_out_MACHINE();
	char *machine_arch = figure_out_MACHINE_ARCH();
	char *machine_cpu = figure_out_MACHINE_CPU();
	const char *syspath = _PATH_DEFSYSPATH;
	char *p;
	static struct dirs d;
	bool read_depend = true;/* false if we don't want to read .depend */

	MainParseChdir(argc, argv);
	setup_CURDIR_OBJDIR(&d);

	esetenv("PWD", d.object);
	unsetenv("CDPATH");

	Static_Lst_Init(create);
	Static_Lst_Init(&makefiles);
	Static_Lst_Init(&varstoprint);
	Static_Lst_Init(&targs);

	beSilent = false;		/* Print commands as executed */
	ignoreErrors = false;		/* Pay attention to non-zero returns */
	noExecute = false;		/* Execute all commands */
	keepgoing = false;		/* Stop on error */
	allPrecious = false;		/* Remove targets when interrupted */
	queryFlag = false;		/* This is not just a check-run */
	noBuiltins = false;		/* Read the built-in rules */
	touchFlag = false;		/* Actually update targets */
	debug = 0;			/* No debug verbosity, please. */

	maxJobs = DEFMAXJOBS;
	compatMake = false;		/* No compat mode */


	/*
	 * Initialize all external modules.
	 */
	Init();

	if (d.object != d.current)
		Dir_AddDir(defaultPath, d.current);
	Var_Set(".CURDIR", d.current);
	Var_Set(".OBJDIR", d.object);
	Parse_setcurdir(d.current);
	Targ_setdirs(d.current, d.object);

	/*
	 * Initialize various variables.
	 *	MAKE also gets this name, for compatibility
	 *	.MAKEFLAGS gets set to the empty string just in case.
	 *	MFLAGS also gets initialized empty, for compatibility.
	 */
	Var_Set("MAKE", argv[0]);
	Var_Set(".MAKE", argv[0]);
	Var_Set(MAKEFLAGS, "");
	Var_Set("MFLAGS", "");
	Var_Set("MACHINE", machine);
	Var_Set("MACHINE_ARCH", machine_arch);
	Var_Set("MACHINE_CPU", machine_cpu);

	/*
	 * First snag any flags out of the MAKEFLAGS environment variable.
	 */
	Main_ParseArgLine(getenv("MAKEFLAGS"));
	
	basedirectory = getenv("MAKEBASEDIRECTORY");
	if (basedirectory == NULL)
		setenv("MAKEBASEDIRECTORY", d.current, 0);

	MainParseArgs(argc, argv);

	/*
	 * Be compatible if user did not specify -j
	 */
	if (!forceJobs)
		compatMake = true;

	/* And set up everything for sub-makes */
	Var_AddCmdline(MAKEFLAGS);


	/*
	 * Set up the .TARGETS variable to contain the list of targets to be
	 * created. If none specified, make the variable empty -- the parser
	 * will fill the thing in with the default or .MAIN target.
	 */
	if (!Lst_IsEmpty(create)) {
		LstNode ln;

		for (ln = Lst_First(create); ln != NULL; ln = Lst_Adv(ln)) {
			char *name = Lst_Datum(ln);

			if (strcmp(name, "depend") == 0)
				read_depend = false;

			Var_Append(".TARGETS", name);
		}
	} else
		Var_Set(".TARGETS", "");


	/*
	 * If no user-supplied system path was given (through the -m option)
	 * add the directories from the DEFSYSPATH (more than one may be given
	 * as dir1:...:dirn) to the system include path.
	 */
	if (Lst_IsEmpty(systemIncludePath))
	    add_dirpath(systemIncludePath, syspath);

	read_all_make_rules(noBuiltins, read_depend, &makefiles, &d);

	Var_Append("MFLAGS", Var_Value(MAKEFLAGS));

	/* Install all the flags into the MAKEFLAGS env variable. */
	if (((p = Var_Value(MAKEFLAGS)) != NULL) && *p)
		esetenv("MAKEFLAGS", p);

	setup_VPATH();

	process_suffixes_after_makefile_is_read();

	if (dumpData) {
		dump_data();
		exit(0);
	}

	/* Print the initial graph, if the user requested it.  */
	if (DEBUG(GRAPH1))
		dump_data();

	/* Print the values of any variables requested by the user.  */
	if (!Lst_IsEmpty(&varstoprint)) {
		LstNode ln;

		for (ln = Lst_First(&varstoprint); ln != NULL;
		    ln = Lst_Adv(ln)) {
			char *value = Var_Value(Lst_Datum(ln));

			printf("%s\n", value ? value : "");
		}
	} else {
		/* Have now read the entire graph and need to make a list
		 * of targets to create. If none was given on the command
		 * line, we consult the parsing module to find the main
		 * target(s) to create.  */
		if (Lst_IsEmpty(create))
			Parse_MainName(&targs);
		else
			Targ_FindList(&targs, create);

		Job_Init(maxJobs);
		/* If the user has defined a .BEGIN target, execute the commands
		 * attached to it.  */
		if (!queryFlag)
			Job_Begin();
		if (compatMake)
			/* Compat_Init will take care of creating all the
			 * targets as well as initializing the module.  */
			Compat_Run(&targs);
		else {
			/* Traverse the graph, checking on all the targets.  */
			outOfDate = Make_Run(&targs);
		}
	}

	/* print the graph now it's been processed if the user requested it */
	if (DEBUG(GRAPH2))
		post_mortem();

	if (queryFlag && outOfDate)
		return 1;
	else
		return 0;
}

/*-
 * ReadMakefile  --
 *	Open and parse the given makefile.
 *
 * Results:
 *	true if ok. false if couldn't open file.
 *
 * Side Effects:
 *	lots
 */
static bool
ReadMakefile(void *p, void *q)
{
	const char *fname = p;	/* makefile to read */
	struct dirs *d = q;
	FILE *stream;
	char *name;

	if (!strcmp(fname, "-")) {
		Var_Set("MAKEFILE", "");
		Parse_File(estrdup("(stdin)"), stdin);
	} else {
		if ((stream = fopen(fname, "r")) != NULL)
			goto found;
		/* if we've chdir'd, rebuild the path name */
		if (d->current != d->object && *fname != '/') {
			char *path;

			path = Str_concat(d->current, fname, '/');
			if ((stream = fopen(path, "r")) == NULL)
				free(path);
			else {
				fname = path;
				goto found;
			}
		}
		/* look in -I and system include directories. */
		name = Dir_FindFile(fname, userIncludePath);
		if (!name)
			name = Dir_FindFile(fname, systemIncludePath);
		if (!name || !(stream = fopen(name, "r")))
			return false;
		fname = name;
		/*
		 * set the MAKEFILE variable desired by System V fans -- the
		 * placement of the setting here means it gets set to the last
		 * makefile specified, as it is set by SysV make.
		 */
found:		Var_Set("MAKEFILE", fname);
		Parse_File(fname, stream);
	}
	return true;
}


/*
 * usage --
 *	exit with usage message
 */
static void
usage()
{
	(void)fprintf(stderr,
"usage: make [-BeiknpqrSst] [-C directory] [-D variable] [-d flags] [-f mk]\n\
	    [-I directory] [-j max_processes] [-m directory] [-V variable]\n\
	    [NAME=value] [target ...]\n");
	exit(2);
}


@


1.121
log
@small obvious cleanups:
- remove a lot of unnecessary casts
- zap extra param that's no longer needed
- add proper prototype and make function static

okay natano@@
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.120 2016/10/12 00:31:06 tb Exp $ */
d313 1
a313 1
		   char *endptr;
d316 2
a317 2
			maxJobs = strtol(optarg, &endptr, 0);
			if (endptr == optarg) {
d319 2
a320 2
					"make: illegal argument to -j option -- %s -- not a number\n",
					optarg);
@


1.120
log
@make -t uses the "fattr" syscall utimes(2) for its touch(1) built-in.
Thus, add "fattr" to the list of pledge promises.

ok millert, deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.119 2016/01/04 10:59:23 tb Exp $ */
d108 1
a108 1
static void setup_CURDIR_OBJDIR(struct dirs *, const char *);
d547 1
a547 1
setup_CURDIR_OBJDIR(struct dirs *d, const char *machine)
d659 1
a659 1
	setup_CURDIR_OBJDIR(&d, machine);
d739 1
a739 1
			char *name = (char *)Lst_Datum(ln);
d785 1
a785 1
			char *value = Var_Value((char *)Lst_Datum(ln));
@


1.119
log
@Use err(3) instead of various handrolled combinations of perror(3) and
fprintf(stderr, ...) with strerror(3) and exit(3).  Make sure the exit
status is 2 if an error occurred.  Prompted by gsoares@@'s and jsg@@'s
audit of exit statuses after failure of pledge(2).

ok gsoares@@
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.118 2015/12/29 19:04:46 gsoares Exp $ */
d193 1
a193 1
	if (pledge("stdio rpath wpath cpath proc exec", NULL) == -1)
@


1.118
log
@fix exit status on pledge(2) failure.

OK tb@@ jsg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.117 2015/11/29 09:17:12 espie Exp $ */
d370 1
a370 1
				err(1, "chdir(%s)", optarg);
d469 2
a470 4
		if (uname(&utsname) == -1) {
			perror("make: uname");
			exit(2);
		}
d515 2
a516 4
	if (cwd == NULL) {
		(void)fprintf(stderr, "make: %s.\n", strerror(errno));
		exit(2);
	}
d518 2
a519 4
	if (stat(cwd, &sa) == -1) {
		(void)fprintf(stderr, "make: %s: %s.\n", cwd, strerror(errno));
		exit(2);
	}
@


1.117
log
@fix duplicate targets in target list for good: split previous groupling fix
in two. Catch 22: we have to dedup targets very early so that commands get
attached correctly, but we can't figure out the grouplings heuristics until
we have all commands...

ok millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.116 2015/11/15 06:19:22 daniel Exp $ */
d194 1
a194 1
		err(1, "pledge");
@


1.116
log
@unifdef MAKE_BOOTSTRAP now that Makefile.boot is gone.

ok espie@@
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.115 2015/10/14 13:50:22 espie Exp $ */
d629 1
@


1.115
log
@make sure we use stdbool.h
Mostly diff by Daniel Dickman, who told me to commit in his stead,
as he's tied up at work.
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.114 2015/10/09 01:37:08 deraadt Exp $ */
a40 1
#ifndef MAKE_BOOTSTRAP
a41 1
#endif
a466 1
#ifndef MAKE_BOOTSTRAP
a473 3
#else
		r = MACHINE;
#endif
@


1.114
log
@Change all tame callers to namechange to pledge(2).
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.113 2015/10/08 14:49:27 deraadt Exp $ */
d116 1
a116 1
static int ReadMakefile(void *, void *);
@


1.113
log
@tame "stdio rpath wpath cpath proc exec".  make is a shell, and appears
to only need these operations.  Take note that "exec" is a 2-day old
tame request, so do get a new kernel before you update or risk getting
trapped.
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.112 2015/10/07 14:16:09 deraadt Exp $ */
d195 2
a196 2
	if (tame("stdio rpath wpath cpath proc exec", NULL) == -1)
		err(1, "tame");
@


1.112
log
@Oops, not quite ready for tame() here.  People need time to update
their kernels, before it starts using the new "exec" primitive.
HINT: everyone, update your kernels, tame is coming to make really soon.
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.110 2015/02/07 18:52:35 jmc Exp $ */
d194 3
@


1.111
log
@*** empty log message ***
@
text
@a194 3
	if (tame("stdio rpath wpath cpath proc exec", NULL) == -1)
		err(1, "tame");

@


1.110
log
@sync usage(); ok espie
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.109 2015/02/07 13:32:12 espie Exp $ */
d194 3
@


1.109
log
@add support for the popular -C option, in the least intrusive way possible:
parse thru parameters for -C upfront, and then we can setup CURDIR/OBJDIR
so as not to disturb anything else.

okay millert@@, "makes sense" guenther@@
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.108 2015/01/23 22:35:57 espie Exp $ */
d895 2
a896 2
"usage: make [-BeiknPqrSst] [-C dir] [-D variable] [-d flags] [-f makefile]\n\
	    [-I directory] [-j max_jobs] [-m directory] [-V variable]\n\
@


1.108
log
@a wee little bit more cleanup (more const and remove noise from CDIAGFLAGS...
-pedantic kind of requires -std=c99 here to avoid LL warnings)
okay miod@@, millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.107 2015/01/23 13:18:40 espie Exp $ */
d44 1
d192 1
a192 1
#define OPTFLAGS "BD:I:SV:d:ef:ij:km:npqrst"
d210 2
d343 1
d345 34
d666 1
d895 1
a895 1
"usage: make [-BeiknPqrSst] [-D variable] [-d flags] [-f makefile]\n\
@


1.107
log
@remove a bunch of dangerous casts (useless casts from void * to something
else, in some cases by adding extra temporary variables.
IMO, it's much better practice to do

void *a;
int *p = a;
*p = 42;

rather than
void *a;
*(int *)a = 42;

okay miod@@... to be revisited for some possible const additions later.
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.106 2015/01/16 15:36:30 deraadt Exp $ */
d806 1
a806 1
	char *fname = p;	/* makefile to read */
@


1.106
log
@switch to <limits.h>; ok millert
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.105 2015/01/16 15:17:34 deraadt Exp $ */
d806 2
a807 2
	char *fname = (char *)p;	/* makefile to read */
	struct dirs *d = (struct dirs *)q;
@


1.105
log
@The make code has "bootstrap", to allow it to be brought up on other
systems.  Rarely used & tested -- perhaps once a decade. Perhaps not
even once this decade?  Anyways,
    #define PATH_MAX (MAXPATHLEN+1)
is quite wrong.  Delete the chunk, assuming any system this is ported
to has PATH_MAX.
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.104 2014/07/15 23:07:19 deraadt Exp $ */
d38 1
a38 1
#include <sys/param.h>
@


1.104
log
@remove support for the non-standard BSDmakefile, which make tries to
open first.  a handful of strange ports will cope soon.
ok espie
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.103 2014/05/15 19:40:42 chl Exp $ */
a69 9

#ifndef PATH_MAX
# ifdef MAXPATHLEN
#  define PATH_MAX (MAXPATHLEN+1)
# else
#  define PATH_MAX	1024
# endif
#endif

@


1.103
log
@remove unused variable

ok espie@@
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.102 2013/11/24 12:36:13 espie Exp $ */
d581 1
a581 2
	 * makefile(s), or the default BSDmakefile, Makefile or
	 * makefile, in that order.
d596 2
a597 3
	} else if (!ReadMakefile("BSDmakefile", d))
		if (!ReadMakefile("makefile", d))
			(void)ReadMakefile("Makefile", d);
@


1.102
log
@simplify determination of OBJDIR to what we actually use.
(prevents some race conditions by just chdir()'ing into the right objdir)
problem noticed by theo
okay'd by general apathy...
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.101 2013/07/07 09:41:08 espie Exp $ */
d529 1
a529 1
	char *path, *prefix;
@


1.101
log
@old option -P bites the dust. It's not been doing anything for years.
It used to control pipes for parallel output, but the new model means
pipes are no longer used at all.
Its mere presence confuses some people.
tested thru a few builds and bulk to not impact anything.
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.100 2012/10/18 17:54:43 espie Exp $ */
a116 1
static char *concat_verify(const char *, const char *, char, struct dirs *);
d517 5
a521 13
	struct stat sb;

	if (stat(path, &sb) == 0 && S_ISDIR(sb.st_mode)) {
		if (chdir(path)) {
			(void)fprintf(stderr, "make warning: %s: %s.\n",
			      path, strerror(errno));
			return NULL;
		} else {
			if (path[0] != '/')
				return Str_concat(d->current, path, '/');
			else
				return estrdup(path);
		}
a522 1

a525 9
static char *
concat_verify(const char *p1, const char *p2, char c, struct dirs *d)
{
	char *tmp = Str_concat(p1, p2, c);
	char *result = chdir_verify_path(tmp, d);
	free(tmp);
	return result;
}

a531 1
	d->object = NULL;
d534 1
a534 5
	 * exists, change into it and build there.  (If a .${MACHINE} suffix
	 * exists, use that directory instead).
	 * Otherwise check MAKEOBJDIRPREFIX`cwd` (or by default,
	 * _PATH_OBJDIRPREFIX`cwd`) and build there if it exists.
	 * If all fails, use the current directory to build.
d541 1
a541 5
	if ((prefix = getenv("MAKEOBJDIRPREFIX")) != NULL) {
		d->object = concat_verify(prefix, d->current, 0, d);
	} else if ((path = getenv("MAKEOBJDIR")) != NULL) {
		d->object = chdir_verify_path(path, d);
	} else {
d543 2
a544 7
		prefix = _PATH_OBJDIRPREFIX;
		d->object = concat_verify(path, machine, '.', d);
		if (!d->object)
			d->object=chdir_verify_path(path, d);
		if (!d->object)
			d->object = concat_verify(prefix, d->current, 0, d);
	}
@


1.100
log
@numerous error message fixes:
- do ^C checking differently: don't record sent signals, but when jobs
die, recheck whether we received/have pending a INT/QUIT/TERM/HUP signal.
Then don't display our process group "normally", instead group together
everything dying by signal/shell dying by signal (just give the target
names).

- make certain we always handle signals before dying from "other conditions"
- have the parser messages look more like normal messages
- remove double error messages from some parser errors
- make sure unclosed variables ARE errors when some modifiers are present

- keep track of the base directory we're run from, so that submakes can
get shortened directories...
- make sure the whole error message including silent command fits into a
reasonable length.

okay millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.99 2012/10/09 19:47:09 espie Exp $ */
a146 2
	case 'P':
		break;	/* old option */
d201 2
a202 2
#define OPTFLAGS "BD:I:PSV:d:ef:ij:km:npqrst"
#define OPTLETTERS "BPSiknpqrst"
@


1.99
log
@recognize new debug options for double commands, heldjobs, target group
construction
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.98 2012/10/06 09:32:40 espie Exp $ */
d127 2
a128 1
static void record_option(int c, const char *arg)
d130 1
a130 1
    char opt[3];
d728 4
@


1.98
log
@- extra juice for debugging signal passing.  Note when we can't pass the
signal because the process already bought it (pgroups will do that to you)
(lots of discussion with Todd on that one)
- tweak error handling some more to make it less verbose when just one job
is running...
- show signal name in case of signal interrupts.
- zap OP_LIB, move that stuff to the location where we warn when we meet
that bug.

okay millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.97 2012/10/02 10:29:31 espie Exp $ */
d249 3
d268 3
d300 3
@


1.97
log
@more changes, discussed and tested by various people.
- put back some job control, turns out it's necessary when we don't run a
shell.
- zap old #ifdef CLEANUP code... probably doesn't even compile.
- kill most of the OP_LIB code. Just keep a wee little bit for compatibility
(deprecated .LIBS and .INCLUDES, warns for weird dependencies instead of
erroring out).
- much improved debugging and -p output: sort variables, targets, rules,
output stuff in a nicer format mimicing input.
- better error message when no command is found, explain where the target comes from.
- sort final error list by file.
- show system files in errors as <bsd.prog.mk>
- reincorporate random delay, that was dropped
- optimize siginfo output by not regenerating the whole string each time.
- finish zapping old LocationInfo field that's no longer used.
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.96 2012/09/21 07:55:20 espie Exp $ */
d266 1
a266 1
					debug |= DEBUG_JOB;
d270 3
@


1.96
log
@major overhaul of the way make handle jobs, inspired by dpb:
instead of forking a "job" per target, and having that job further fork
separate commands, have make maintain a list of jobs, indexed by pid
of currently running commands, and handle process termination
continuation-style.  This has lots of benefits:
- make is responsible for most printing, so we no longer need pipes nor
job control: make -j jobs see the tty.
- no more special-casing for jobs that don't really execute anything.
- unify code for make -jn and make -B, including signal handlers and
job waiting.  So make -n, make -q, +cmd now run commands in the same
way in all cases.
- unified more accurate error-reporting, as make knows precisely which
command failed. Commands are tagged with their lines, and we display failing
commands in silent mode.
- fine-grained "expensive" command handling (recursion limiter). Do it
per-command instead of per-target.

Moreover, signal response is now simpler, as we just block the signals
in a small critical sections, test for events, and sigpause (thanks a lot
to guenther@@ and millert@@), so running make is now almost always paused
without any busy-waiting.

Thanks to everyone who tested and gave input.
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.95 2010/07/19 19:46:44 espie Exp $ */
a570 11
#ifdef CLEANUP
static void
free_CURDIR_OBJDIR(struct dirs *d)
{
	if (d->object != d->current)
		free(d->object);
	free(d->current);
}
#endif


a614 3
#ifdef CLEANUP
		Lst_Destroy(&sysMkPath, (SimpleProc)free);
#endif
d719 1
a719 2
	 * Be compatible if user did not specify -j and did not explicitly
	 * turn compatibility on
d721 1
a721 1
	if (!compatMake && !forceJobs)
a767 4
	/* Print the initial graph, if the user requested it.  */
	if (DEBUG(GRAPH1))
		Targ_PrintGraph(1);

d772 5
a811 7
#ifdef CLEANUP
	Lst_Destroy(&targs, NOFREE);
	Lst_Destroy(&varstoprint, NOFREE);
	Lst_Destroy(&makefiles, NOFREE);
	Lst_Destroy(create, (SimpleProc)free);
#endif

d814 1
a814 1
		Targ_PrintGraph(2);
a815 4
#ifdef CLEANUP
	free_CURDIR_OBJDIR(&d);
	End();
#endif
@


1.95
log
@Correct $OpenBSD$ stuff
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.94 2010/07/15 10:41:11 espie Exp $ */
d52 1
d69 1
d99 1
a114 1
static void no_fd_limits(void);
a126 1

d163 3
d202 2
a203 2
#define OPTFLAGS "BD:I:PSV:d:ef:ij:km:nqrst"
#define OPTLETTERS "BPSiknqrst"
d249 3
d269 1
a269 1
					debug |= DEBUG_JOBBANNER;
d283 3
a472 14
/* get rid of resource limit on file descriptors */
static void
no_fd_limits()
{
#ifdef RLIMIT_NOFILE
	struct rlimit rl;
	if (getrlimit(RLIMIT_NOFILE, &rl) != -1 &&
	    rl.rlim_cur != rl.rlim_max) {
		rl.rlim_cur = rl.rlim_max;
		(void)setrlimit(RLIMIT_NOFILE, &rl);
	}
#endif
}

a674 1
	no_fd_limits();
d708 1
d787 4
d811 5
a820 8
			/* Initialize job module before traversing the graph,
			 * now that any .BEGIN and .END targets have been
			 * read. This is done only if the -q flag wasn't given
			 * (to prevent the .BEGIN from being executed should
			 * it exist).  */
			if (!queryFlag)
				Job_Init(maxJobs);

@


1.94
log
@whitespace
@
text
@d1 1
a1 2
/*	$OpenPackages$ */
/*	$OpenBSD$ */
@


1.93
log
@Add a new default variable in Makefile context, MACHINE_CPU. Its value is
decided at compile-time and is either MACHINE_CPU from <machine/param.h> if
it is defined, or the same value as MACHINE_ARCH otherwise.
This will be used to allow ports with suffixes to their canonical MACHINE_ARCH
to provide this canonical name as MACHINE_CPU, and in turn to let Makefiles
do TRT.
ok kettenis@@
@
text
@d2 1
a2 1
/*	$OpenBSD: main.c,v 1.92 2008/11/04 07:22:35 espie Exp $ */
d643 1
a643 1
	
@


1.92
log
@changes to get target equivalence to work better.
- add new file to create lists of equivalent targets (siblings)
- use that for sequential mode to have much better VPATH support
- separate checking commands from reporting error, for later.
- zap DieHorribly accordingly
- renumber existing flags
- signal_running_jobs() is simpler than pass_signal_to_jobs()
- new debug option -dn for name matching.

Similar code to handle parallel make is still missing.

thanks to Mark, Miod, Theo, Otto, Todd for tests and/or comments.
@
text
@d2 1
a2 1
/*	$OpenBSD$ */
d112 1
d410 1
a410 1
 * Note that both MACHINE and MACHINE_ARCH are decided at
d446 17
d674 1
d728 1
@


1.91
log
@fix stupid typo in grouping, make PWD work correctly again.
Found out by Christian Ehrhardt.
@
text
@d2 1
a2 1
/*	$OpenBSD: main.c,v 1.90 2007/11/28 09:40:08 espie Exp $ */
d269 3
@


1.90
log
@debug scaffolding: allows the insertion of a random delay before firing up
jobs in parallel mode.
@
text
@d2 1
a2 1
/*	$OpenBSD$ */
d479 1
a479 1
		    sa.st_dev == sb.st_dev)
d482 1
@


1.89
log
@read only .depend if !make(depend)

On the basis that:
- .depend is a bsd extension anyways, changing its semantics doesn't
affect posix compliance.
- it may allow regenerating broken .depend files without needing to
remove them.

approved by miod@@, millert@@, deraadt@@.
@
text
@d270 3
@


1.88
log
@token is a confusing name, rename to banner
@
text
@d121 1
a121 1
static void read_all_make_rules(bool, Lst, struct dirs *);
d589 2
a590 1
read_all_make_rules(bool noBuiltins, Lst makefiles, struct dirs *d)
d617 4
a620 2
	/* Always read a .depend file, if it exists. */
	(void)ReadMakefile(".depend", d);
d652 1
d732 3
d749 1
a749 1
	read_all_make_rules(noBuiltins, &makefiles, &d);
@


1.87
log
@Work done at p2k7.


This is a really big step towards getting parallel make to work.


Note that this is not yet complete. There are still a few `details' to
fix before this works 100%.  Specifically: sequential make (compat) and
parallel make don't use the same engine, and the parallel engine still
has a few limitations. For instance, some known issues:
- parallel make does not deal with .phony targets correctly all the time.
- some errors are deadly in parallel make mode.
- parallel make NEEDS way more sturdy correspondance of file system paths
and target names, since it often needs to match dependencies to targets
before the corresponding files exist.
- some local variables like $* get set in a bogus way in some cases.
- suffix handling has issues, especially related to the NULL suffix.
So, if you find stuff that does NOT yet work with parallel make, don't go
blindly try to fix the Makefile. It's very likely you might have stumbled
into a make bug. (unless you really, really, understand Makefiles, DON'T
GO CHANGING THEM YET).



Tested by lots of people, thanks go to miod@@, and robert@@ among other people.

Quick summary of what this does:

- remove `saving commands' extension (it's not really usable, nor used)
- move compat job runner and parallel interrupt handling into engine.c
- tweak the code so that both compat and parallel mode use the same job runner
and the same interrupt handling. Remove the other one.
- optimize job runner so that, in parallel mode, the last command does not
fork if we can avoid it (as it's already running in a sub shell).
- scrape all the code that dealt with creating shell scripts from commands.
- scrape all the code that dealt with recognizing special sequences in
command output to print/not print output.
- fix the parallel job pipe to not keep around file descriptors that are not
needed.
- replace the parallel job buffering with a nicer one, that deals with
non-blocking descriptors to try to agregate as much output from one job in
one go (greed) to unconfuse the users.
- create two pipes per job, so that stdout and stderr stay separate.
- make job token printing a debug option.
- always use the parallel job-runner to `execute' commands, even if we just
print them out.
- store list of errors encountered during parallel make running, and print them
on exit, so that we know what went wrong.
- add a dirty hack to targ.c to deal with paths produced by gccmakedep.
@
text
@d262 1
a262 1
					debug |= DEBUG_JOBTOKEN;
@


1.86
log
@fix logic of command line/ MAKEFLAGS parsing.
Forces make to see the -j4 in MAKEFLAGS and to actually pass it to submakes
@
text
@d261 3
d684 1
@


1.85
log
@kill local/jobs distinction. Correctly this time...
@
text
@d90 1
a196 1
	int forceJobs = 0;
a320 6
	/*
	 * Be compatible if user did not specify -j and did not explicitly
	 * turn compatibility on
	 */
	if (!compatMake && !forceJobs)
		compatMake = true;
d701 7
@


1.84
log
@revert maxLocal removal, there's something fishy going on.
@
text
@d2 1
a2 1
/*	$OpenBSD: main.c,v 1.83 2007/09/17 12:42:09 espie Exp $ */
a77 3
#ifndef DEFMAXLOCAL
#define DEFMAXLOCAL DEFMAXJOBS
#endif	/* DEFMAXLOCAL */
a88 1
static int		maxLocal;	/* -L argument */
a298 1
			maxLocal = maxJobs;
d674 1
a674 2
	maxLocal = DEFMAXLOCAL; 	/* Set default local max concurrency */
	maxJobs = maxLocal;
d783 2
a784 5
			if (!queryFlag) {
				if (maxLocal == -1)
					maxLocal = maxJobs;
				Job_Init(maxJobs, maxLocal);
			}
@


1.83
log
@rewrite of the basic suffix/target parsing: use hash for suffixes.

Store special targets in target hash, and use them for the parsing.

Use OP_DUMMY flag to mark targets that don't really exist yet, such
as interrupt and default nodes.

Also, .PATHxxx is special in suffixes.

Small tweaks to compat.c, so that run_commands does more stuff after
the fork() (and thus no need to free things).

Remove distinction between local and global jobs.
@
text
@d2 1
a2 1
/*	$OpenBSD: main.c,v 1.70 2007/07/08 17:44:20 espie Exp $ */
d78 4
d92 1
d303 1
d679 2
a680 1
	maxJobs = DEFMAXJOBS; 	/* Set default local max concurrency */
d790 3
a792 1
				Job_Init(maxJobs);
@


1.82
log
@make usePipes the default, zap undocumented -P.
@
text
@d2 1
a2 1
/*	$OpenBSD: main.c,v 1.81 2007/09/17 11:11:30 espie Exp $ */
a77 4
#ifndef DEFMAXLOCAL
#define DEFMAXLOCAL DEFMAXJOBS
#endif	/* DEFMAXLOCAL */

a81 1
GNode			*DEFAULT;	/* .DEFAULT node */
a87 1
static int		maxLocal;	/* -L argument */
a297 1
			maxLocal = maxJobs;
d673 1
a673 2
	maxLocal = DEFMAXLOCAL; 	/* Set default local max concurrency */
	maxJobs = maxLocal;
a710 2
	DEFAULT = NULL;

d746 1
a746 3
	/* Now that all search paths have been read for suffixes et al, it's
	 * time to add the default search path to their lists...  */
	Suff_DoPaths();
d783 1
a783 3
				if (maxLocal == -1)
					maxLocal = maxJobs;
				Job_Init(maxJobs, maxLocal);
@


1.81
log
@parseIncPath -> userIncludePath and assorted renames
@
text
@d2 1
a2 1
/*	$OpenBSD: main.c,v 1.80 2007/09/17 09:28:36 espie Exp $ */
a99 1
bool 		usePipes;	/* !-P flag */
d150 1
a150 2
		usePipes = false;
		break;
a677 1
	usePipes = true;		/* Catch child output in pipes */
@


1.80
log
@kill extra spaces at end of line
@
text
@d2 1
a2 1
/*	$OpenBSD: main.c,v 1.79 2007/09/16 12:30:35 espie Exp $ */
d311 1
a311 1
			Dir_AddDir(sysIncPath, optarg);
d611 1
a611 1
		Dir_Expand(_PATH_DEFSYSMK, sysIncPath, &sysMkPath);
d746 2
a747 2
	if (Lst_IsEmpty(sysIncPath))
	    add_dirpath(sysIncPath, syspath);
d866 1
a866 1
		name = Dir_FindFile(fname, parseIncPath);
d868 1
a868 1
			name = Dir_FindFile(fname, sysIncPath);
@


1.79
log
@rename dirSearchPath -> defaultPath, and openDirectories -> knownDirectories
@
text
@d2 1
a2 1
/*	$OpenBSD: main.c,v 1.78 2007/09/16 10:14:26 espie Exp $ */
d411 1
a411 1
 * Get the name of this type of MACHINE from utsname so we can share an 
d483 1
a483 1
	/* ...but we can use the alias $PWD if we can prove it is the same 
d771 1
a771 1
		for (ln = Lst_First(&varstoprint); ln != NULL; 
d778 3
a780 3
		/* Have now read the entire graph and need to make a list 
		 * of targets to create. If none was given on the command 
		 * line, we consult the parsing module to find the main 
d788 1
a788 1
			/* Compat_Init will take care of creating all the 
d792 4
a795 4
			/* Initialize job module before traversing the graph, 
			 * now that any .BEGIN and .END targets have been 
			 * read. This is done only if the -q flag wasn't given 
			 * (to prevent the .BEGIN from being executed should 
@


1.78
log
@cut up dir.c into dir.c/direxpand.c as there is very little interface between
two modules that do different things.
@
text
@d2 1
a2 1
/*	$OpenBSD: main.c,v 1.77 2007/09/16 09:46:14 espie Exp $ */
d585 1
a585 1
		add_dirpath(dirSearchPath, vpath);
d694 1
a694 1
		Dir_AddDir(dirSearchPath, d.current);
@


1.77
log
@remove dead code: #define RECHECK is always on
@
text
@d2 1
a2 1
/*	$OpenBSD: main.c,v 1.70 2007/07/08 17:44:20 espie Exp $ */
d56 1
@


1.76
log
@everywhere except in Var_Parse, we always add/append variables to the
VAR_GLOBAL context, so make it the common case: rename the basic functions
to Var_Set_with_ctxt/Var_Append_with_ctxt, define Var_Set and Var_Append
as macros that specify VAR_GLOBAL, and use these.

okay miod@@
@
text
@@


1.75
log
@clean-up. Basically:
- remove globals curdir and objdir, stuff them into a structure, and pass
it around to the relevant functions.
- cut up most of main code into functions:
figure_out_MACHINE/ARCH, figure_out_CURDIR, setup_CURDIR_OBJDIR, setup_VPATH,
no_fd_limits, read_makefile_list, read_all_make_rules...
- simplify the code used to figure out curdir/objdir.

No semantic changes.

okay miod@@
@
text
@d137 1
a137 1
	Var_Append(MAKEFLAGS, opt, VAR_GLOBAL);
d139 1
a139 1
		Var_Append(MAKEFLAGS, arg, VAR_GLOBAL);
d223 1
a223 1
			Var_Set(optarg, "1", VAR_GLOBAL);
d694 2
a695 2
	Var_Set(".CURDIR", d.current, VAR_GLOBAL);
	Var_Set(".OBJDIR", d.object, VAR_GLOBAL);
d703 6
a708 6
	Var_Set("MAKE", argv[0], VAR_GLOBAL);
	Var_Set(".MAKE", argv[0], VAR_GLOBAL);
	Var_Set(MAKEFLAGS, "", VAR_GLOBAL);
	Var_Set("MFLAGS", "", VAR_GLOBAL);
	Var_Set("MACHINE", machine, VAR_GLOBAL);
	Var_Set("MACHINE_ARCH", machine_arch, VAR_GLOBAL);
d734 1
a734 1
			Var_Append(".TARGETS", name, VAR_GLOBAL);
d737 1
a737 1
		Var_Set(".TARGETS", "", VAR_GLOBAL);
d750 1
a750 1
	Var_Append("MFLAGS", Var_Value(MAKEFLAGS), VAR_GLOBAL);
d847 1
a847 1
		Var_Set("MAKEFILE", "", VAR_GLOBAL);
d876 1
a876 1
found:		Var_Set("MAKEFILE", fname, VAR_GLOBAL);
@


1.74
log
@simplify computations in the var module: instead of advancing a char *
and keeping track of a length, we just advance the char *, and ditch
the length. We can still get the length at the end of the top-level
functions to satisfy existing interfaces.

Much simpler code, less error-prone.

Okay millert@@
@
text
@d103 25
a127 10
static void		MainParseArgs(int, char **);
static char *		chdir_verify_path(const char *);
static int		ReadMakefile(void *, void *);
static void		add_dirpath(Lst, const char *);
static void		usage(void);
static void		posixParseOptLetter(int);
static void		record_option(int, const char *);

static char *curdir;			/* startup directory */
static char *objdir;			/* where we chdir'ed to */
d134 6
a139 6
    opt[0] = '-';
    opt[1] = c;
    opt[2] = '\0';
    Var_Append(MAKEFLAGS, opt, VAR_GLOBAL);
    if (arg != NULL)
    	Var_Append(MAKEFLAGS, arg, VAR_GLOBAL);
d391 3
a393 2
char *
chdir_verify_path(const char *path)
d395 2
a396 1
    struct stat sb;
d398 8
a405 10
    if (stat(path, &sb) == 0 && S_ISDIR(sb.st_mode)) {
	if (chdir(path)) {
	    (void)fprintf(stderr, "make warning: %s: %s.\n",
		  path, strerror(errno));
	    return NULL;
	} else {
	    if (path[0] != '/')
	    	return Str_concat(curdir, path, '/');
	    else
		return estrdup(path);
a406 3
    }

    return NULL;
d409 9
a417 4

/* Add a :-separated path to a Lst of directories.  */
static void
add_dirpath(Lst l, const char *n)
d419 4
a422 2
    const char *start;
    const char *cp;
d424 10
a433 9
    for (start = n;;) {
	for (cp = start; *cp != '\0' && *cp != ':';)
	    cp++;
	Dir_AddDiri(l, start, cp);
	if (*cp == '\0')
	    break;
	else
	    start= cp+1;
    }
d436 2
a437 20
int main(int, char **);
/*-
 * main --
 *	The main function, for obvious reasons. Initializes variables
 *	and a few modules, then parses the arguments give it in the
 *	environment and on the command line. Reads the system makefile
 *	followed by either Makefile, makefile or the file given by the
 *	-f argument. Sets the .MAKEFLAGS PMake variable based on all the
 *	flags it has received by then uses either the Make or the Compat
 *	module to create the initial list of targets.
 *
 * Results:
 *	If -q was given, exits -1 if anything was out-of-date. Else it exits
 *	0.
 *
 * Side Effects:
 *	The program exits when done. Targets are created. etc. etc. etc.
 */
int
main(int argc, char **argv)
d439 10
a448 8
	static LIST targs;	/* target nodes to create */
	bool outOfDate = true;	/* false if all targets up to date */
	struct stat sb, sa;
	char *p, *path, *pathp, *pwd;
	char *mdpath;
	char *machine = getenv("MACHINE");
	char *machine_arch = getenv("MACHINE_ARCH");
	const char *syspath = _PATH_DEFSYSPATH;
d450 4
d455 5
a459 10
	/*
	 * get rid of resource limit on file descriptors
	 */
	{
		struct rlimit rl;
		if (getrlimit(RLIMIT_NOFILE, &rl) != -1 &&
		    rl.rlim_cur != rl.rlim_max) {
			rl.rlim_cur = rl.rlim_max;
			(void)setrlimit(RLIMIT_NOFILE, &rl);
		}
d462 11
a472 6
	/*
	 * Find where we are and take care of PWD for the automounter...
	 * All this code is so that we know where we are when we start up
	 * on a different machine with pmake.
	 */
	if ((curdir = dogetcwd()) == NULL) {
d477 3
a479 4
	if (stat(curdir, &sa) == -1) {
	    (void)fprintf(stderr, "make: %s: %s.\n",
			  curdir, strerror(errno));
	    exit(2);
d482 7
a488 6
	if ((pwd = getenv("PWD")) != NULL) {
	    if (stat(pwd, &sb) == 0 && sa.st_ino == sb.st_ino &&
		sa.st_dev == sb.st_dev) {
		    free(curdir);
		    curdir = estrdup(pwd);
	    }
d491 7
a497 11
	/*
	 * Get the name of this type of MACHINE from utsname
	 * so we can share an executable for similar machines.
	 * (i.e. m68k: amiga hp300, mac68k, sun3, ...)
	 *
	 * Note that both MACHINE and MACHINE_ARCH are decided at
	 * run-time.
	 */
	if (!machine) {
#ifndef MAKE_BOOTSTRAP
	    static struct utsname utsname;
d499 11
a509 8
	    if (uname(&utsname) == -1) {
		    perror("make: uname");
		    exit(2);
	    }
	    machine = utsname.machine;
#else
	    machine = MACHINE;
#endif
d512 16
a527 7
	if (!machine_arch) {
#ifndef MACHINE_ARCH
	    machine_arch = "unknown";	/* XXX: no uname -p yet */
#else
	    machine_arch = MACHINE_ARCH;
#endif
	}
d529 2
d544 42
a585 16
	mdpath = NULL;
	if (!(pathp = getenv("MAKEOBJDIRPREFIX"))) {
		if (!(path = getenv("MAKEOBJDIR"))) {
			path = _PATH_OBJDIR;
			pathp = _PATH_OBJDIRPREFIX;
			mdpath = Str_concat(path, machine, '.');
			if (!(objdir = chdir_verify_path(mdpath)))
				if (!(objdir=chdir_verify_path(path))) {
					free(mdpath);
					mdpath = Str_concat(pathp, curdir, 0);
					if (!(objdir=chdir_verify_path(mdpath)))
						objdir = curdir;
				}
		}
		else if (!(objdir = chdir_verify_path(path)))
			objdir = curdir;
d587 31
a617 4
	else {
		mdpath = Str_concat(pathp, curdir, 0);
		if (!(objdir = chdir_verify_path(mdpath)))
			objdir = curdir;
a618 1
	free(mdpath);
d620 44
a663 1
	esetenv("PWD", objdir);
d692 4
a695 4
	if (objdir != curdir)
		Dir_AddDir(dirSearchPath, curdir);
	Var_Set(".CURDIR", curdir, VAR_GLOBAL);
	Var_Set(".OBJDIR", objdir, VAR_GLOBAL);
d748 1
a748 30
	/*
	 * Read in the built-in rules first, followed by the specified
	 * makefile(s), or the default BSDmakefile, Makefile or
	 * makefile, in that order.
	 */
	if (!noBuiltins) {
		LstNode ln;
		LIST sysMkPath; 		/* Path of sys.mk */

		Lst_Init(&sysMkPath);
		Dir_Expand(_PATH_DEFSYSMK, sysIncPath, &sysMkPath);
		if (Lst_IsEmpty(&sysMkPath))
			Fatal("make: no system rules (%s).", _PATH_DEFSYSMK);
		ln = Lst_Find(&sysMkPath, ReadMakefile, NULL);
		if (ln != NULL)
			Fatal("make: cannot open %s.", (char *)Lst_Datum(ln));
#ifdef CLEANUP
		Lst_Destroy(&sysMkPath, (SimpleProc)free);
#endif
	}

	if (!Lst_IsEmpty(&makefiles)) {
		LstNode ln;

		ln = Lst_Find(&makefiles, ReadMakefile, NULL);
		if (ln != NULL)
			Fatal("make: cannot open %s.", (char *)Lst_Datum(ln));
	} else if (!ReadMakefile("BSDmakefile", NULL))
		if (!ReadMakefile("makefile", NULL))
			(void)ReadMakefile("Makefile", NULL);
d750 1
a750 5
	/* Always read a .depend file, if it exists. */
	(void)ReadMakefile(".depend", NULL);

	Var_Append("MFLAGS", Var_Value(MAKEFLAGS),
	    VAR_GLOBAL);
d756 1
a756 13
	/*
	 * For compatibility, look at the directories in the VPATH variable
	 * and add them to the search path, if the variable is defined. The
	 * variable's value is in the same format as the PATH envariable, i.e.
	 * <directory>:<directory>:<directory>...
	 */
	if (Var_Value("VPATH") != NULL) {
	    char *vpath;

	    vpath = Var_Subst("${VPATH}", NULL, false);
	    add_dirpath(dirSearchPath, vpath);
	    (void)free(vpath);
	}
d768 1
a768 1
	    LstNode ln;
d770 3
a772 2
	    for (ln = Lst_First(&varstoprint); ln != NULL; ln = Lst_Adv(ln)) {
		    char *value = Var_Value((char *)Lst_Datum(ln));
d774 2
a775 2
		    printf("%s\n", value ? value : "");
	    }
d777 27
a803 21
	    /* Have now read the entire graph and need to make a list of targets
	     * to create. If none was given on the command line, we consult the
	     * parsing module to find the main target(s) to create.  */
	    if (Lst_IsEmpty(create))
		Parse_MainName(&targs);
	    else
		Targ_FindList(&targs, create);

	    if (compatMake)
		/* Compat_Init will take care of creating all the targets as
		 * well as initializing the module.  */
	    	Compat_Run(&targs);
	    else {
		/* Initialize job module before traversing the graph, now that
		 * any .BEGIN and .END targets have been read.	This is done
		 * only if the -q flag wasn't given (to prevent the .BEGIN from
		 * being executed should it exist).  */
		if (!queryFlag) {
			if (maxLocal == -1)
				maxLocal = maxJobs;
			Job_Init(maxJobs, maxLocal);
a804 4

		/* Traverse the graph, checking on all the targets.  */
		outOfDate = Make_Run(&targs);
	    }
d819 1
a819 3
	if (objdir != curdir)
	    free(objdir);
	free(curdir);
d839 1
a839 1
ReadMakefile(void *p, void *q UNUSED)
d842 1
d853 1
a853 1
		if (curdir != objdir && *fname != '/') {
d856 1
a856 1
			path = Str_concat(curdir, fname, '/');
d858 1
a858 1
			    free(path);
d860 2
a861 2
			    fname = path;
			    goto found;
@


1.73
log
@move the code that grabs a value in Var_Parse in its own function,
get_expanded_value.

Extend the code a bit to be much more thorough in case of a recursive
expansion: shows exactly the cycle of variable names involved.

okay millert@@
@
text
@@


1.72
log
@change Var_ParseSkip API to increment the position instead of returning a
length, simplifies code.

(warns a bit, symptom of some further issues to fix).

okay millert@@
@
text
@@


1.71
log
@even though gcc doesn't reuse the utsname space, it could. Ensure MACHINE
stays defined.
@
text
@@


1.70
log
@A set of big related changes. okay millert@@, tested further by kettenis@@
and matthieu@@

This all revolves around putting ALL global variables into one single big
hash, and using flags. This removes some impossible to understand stuff,
like old varfind, and allows for some nice stuff.
- each time we reference a global variable, we create it, possibly as a dummy
variable.
- each time we go to the environment, we remember it, thus we no longer go
back to it.

Lists of dependant changes:
- isolate changes to oldVars and checkEnvFirst.
- remove VAR_CMD and VAR_GLOBAL contexts. The only distinction is in parsevar.
Split Parse_DoVar into Parse_DoVar and Parse_CmdlineVar
- rework var modules around obtain_global_var, observe flags in various
functions like Var_Value and Var_Seti.
- Var_Seti/Var_Appendi are almost the same code, use that internally.
- add magic to handle the very special SHELL variable.
- introduce Var_Definedi for the cases where we don't want the actual
value, to simplify tests.
- add keyword .poison, parse it and set global flags accordingly.
- do poison_checks where needed.
- document poison.
- in for loops, set variable temporarily, so that Var_SubstVar will also
substitute it in varmodifiers expressions.
@
text
@d2 1
a2 1
/*	$OpenBSD: main.c,v 1.69 2006/09/26 18:20:50 mk Exp $ */
d493 1
a493 1
	    struct utsname utsname;
@


1.69
log
@It seems pointless to assign a variable the atoi() return value after
the strtol() error checking block for the strtol() assignment for the
same variable.

ok brad mglocker
@
text
@d2 1
a2 1
/*	$OpenBSD: main.c,v 1.68 2006/05/06 10:52:34 espie Exp $ */
a101 2
bool 		oldVars;	/* variable substitution style */
bool 		checkEnvFirst;	/* -e flag */
d141 1
a141 1
		checkEnvFirst = true;
d301 1
a301 1
			    !Parse_DoVar(argv[optind], VAR_CMD)) {
a318 2

	oldVars = true;
@


1.68
log
@do not bother defining End if !CLEANUP, reminded by lint.
@
text
@d2 1
a2 1
/*	$OpenBSD: main.c,v 1.67 2006/02/26 18:06:15 jmc Exp $ */
a291 1
			maxJobs = atoi(optarg);
@


1.67
log
@consistent error message; from ray lai
ok deraadt
@
text
@d2 1
a2 1
/*	$OpenBSD: main.c,v 1.66 2005/02/17 02:37:21 jolan Exp $ */
d756 1
@


1.66
log
@alyte spelling-in-comment fixes
@
text
@d2 1
a2 1
/*	$OpenBSD: main.c,v 1.65 2004/04/21 13:17:49 jmc Exp $ */
d271 1
a271 1
				"make: illegal argument to d option -- %c\n",
@


1.65
log
@- correct SYNOPSIS
- add missing options to usage() and slight sync
- point people to psd doc
@
text
@d2 1
a2 1
/*	$OpenBSD: main.c,v 1.64 2004/04/07 13:11:36 espie Exp $ */
d528 1
a528 1
	 * and modify the paths for the Makefiles apropriately.  The
@


1.64
log
@ISO function declarations, trim a few comments, rename a few variables to
more explicit/more consistent names.

okay otto@@
@
text
@d2 1
a2 1
/*	$OpenBSD: main.c,v 1.63 2004/01/30 17:37:37 espie Exp $ */
d825 1
a825 1
"usage: make [-Beiknqrst] [-D variable] [-d flags] [-f makefile ]\n\
d827 1
a827 1
	    [variable=value] [target ...]\n");
@


1.63
log
@a collection of flags is an int.
noticed by tedu.
@
text
@d2 1
a2 1
/*	$OpenBSD: main.c,v 1.62 2003/06/03 02:56:11 millert Exp $ */
d106 1
a106 1
static char *		chdir_verify_path(char *);
d117 1
a117 3
static void record_option(c, arg)
    int 	c;
    const char 	*arg;
d130 1
a130 2
posixParseOptLetter(c)
    int c;
d186 1
a186 3
MainParseArgs(argc, argv)
	int argc;
	char **argv;
d339 1
a339 2
Main_ParseArgLine(line)
	const char *line;			/* Line to fracture */
d382 1
a382 2
chdir_verify_path(path)
    char *path;
d405 1
a405 3
add_dirpath(l, n)
    Lst 	l;
    const char	*n;
d440 1
a440 3
main(argc, argv)
	int argc;
	char **argv;
d774 1
a774 3
ReadMakefile(p, q)
	void * p;
	void * q		UNUSED;
d776 1
a776 1
	char *fname = p;		/* makefile to read */
@


1.62
log
@Remove the advertising clause in the UCB license which Berkeley
rescinded 22 July 1999.  Proofed by myself and Theo.
@
text
@d2 1
a2 1
/*	$OpenBSD: main.c,v 1.61 2003/04/21 23:14:06 millert Exp $ */
d94 1
a94 1
bool 		debug;		/* -d flag */
@


1.61
log
@Stop parsing arguments when we hit "--".
@
text
@d2 1
a2 1
/*	$OpenBSD: main.c,v 1.60 2003/04/06 22:47:14 espie Exp $ */
d22 1
a22 5
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
@


1.60
log
@get rid of some strcpy/sprintf.
ok krw@@, matthieu@@, deraadt@@
@
text
@d2 1
a2 1
/*	$OpenBSD: main.c,v 1.59 2002/12/30 22:12:38 millert Exp $ */
d197 1
a197 3
	extern int optind;
	extern char *optarg;
	int c;
d205 1
d207 11
a217 1
		switch (c = getopt(argc, argv, OPTFLAGS)) {
d316 1
a316 2
				if (strcmp(argv[optind], "-") != 0)
					Lst_AtEnd(create, estrdup(argv[optind]));
@


1.59
log
@Don't pass a NULL arg to Parse_DoVar which can happen if user specifies
"make --".

Check for "-", not "--" when deciding whether or not to pass something
to Lst_AtEnd() (I misunderstood what the old code was trying to do).
This fixes, e.g. ports/graphics/tiff
@
text
@d2 1
a2 1
/*	$OpenBSD: main.c,v 1.58 2002/12/30 02:29:24 millert Exp $ */
d349 1
d371 3
a373 2
	buf = emalloc(strlen(line) + strlen(argv0) + 2);
	(void)sprintf(buf, "%s %s", argv0, line);
@


1.58
log
@Avoid setting optind to 0 since in GNU getopt() that means the same
as optreset in BSD getopt.  This actually simplifies things a bit.
espie@@ OK
@
text
@d2 1
a2 1
/*	$OpenBSD: main.c,v 1.57 2002/03/02 00:23:14 espie Exp $ */
d303 2
a304 1
			if (!Parse_DoVar(argv[optind], VAR_CMD)) {
d307 1
a307 1
				if (strcmp(argv[optind], "--") != 0)
@


1.57
log
@kill #ifdef REMOTE stuff that only obfuscates issues.
ok millert@@, miod@@
@
text
@d2 1
a2 1
/*	$OpenBSD: main.c,v 1.56 2001/11/11 12:35:02 espie Exp $ */
d202 3
d206 3
a208 4
# define OPTFLAGS "BD:I:PSV:d:ef:ij:km:nqrst"
# define OPTLETTERS "BPSiknqrst"
rearg:	while ((c = getopt(argc, argv, OPTFLAGS)) != -1) {
		switch (c) {
d301 10
a323 19

	/*
	 * See if the rest of the arguments are variable assignments and
	 * perform them if so. Else take them to be targets and stuff them
	 * on the end of the "create" list.
	 */
	for (argv += optind, argc -= optind; *argv; ++argv, --argc)
		if (!Parse_DoVar(*argv, VAR_CMD)) {
			if (!**argv)
				Punt("illegal (null) argument.");
			if (**argv == '-') {
				if ((*argv)[1])
					optind = 0;	/* -flag... */
				else
					optind = 1;	/* - */
				goto rearg;
			}
			Lst_AtEnd(create, estrdup(*argv));
		}
@


1.56
log
@Fixed version... don't see how this could work on i386, since it didn't
initialize create in main.c.
@
text
@d2 1
a2 1
/*	$OpenBSD: main.c,v 1.55 2001/11/11 06:02:06 deraadt Exp $ */
a202 3
#ifdef REMOTE
# define OPTFLAGS "BD:I:L:PSV:d:ef:ij:km:nqrst"
#else
a203 1
#endif
a218 15
#ifdef REMOTE
		case 'L': {
		   char *endptr;

			maxLocal = strtol(optarg, &endptr, 0);
			if (endptr == optarg) {
				fprintf(stderr,
					"make: illegal argument to -L option -- %s -- not a number\n",
					optarg);
				usage();
			}
			record_option(c, optend);
			break;
		}
#endif
a290 1
#ifndef REMOTE
a291 1
#endif
a585 3
#ifdef REMOTE
	maxJobs = DEFMAXJOBS;		/* Set default max concurrency */
#else
a586 1
#endif
@


1.55
log
@undo changes that crash on (at least) the alpha
@
text
@d2 1
a2 1
/*	$OpenBSD: main.c,v 1.53 2001/06/05 11:59:11 espie Exp $ */
d474 1
a474 1
	LIST targs;			/* target nodes to create */
d590 4
a593 4
	Lst_Init(create);
	Lst_Init(&makefiles);
	Lst_Init(&varstoprint);
	Lst_Init(&targs);
@


1.54
log
@Redo LstInit as a macro: smaller and faster code in all cases, zeroing two
pointers is simpler than calling a function.
Recognize purely static lst headers, which don't really need any
initialization.
ok miod@@
@
text
@d590 4
a593 4
	Static_Lst_Init(create);
	Static_Lst_Init(&makefiles);
	Static_Lst_Init(&varstoprint);
	Static_Lst_Init(&targs);
@


1.53
log
@Use Str_concat instead of fixed buffers and snprintf in building paths.
Replace MAXPATHLEN with PATH_MAX (synch with op-make).
ok naddy@@
@
text
@d2 1
a2 1
/*	$OpenBSD: main.c,v 1.51 2001/05/31 13:38:48 espie Exp $ */
d590 4
a593 4
	Lst_Init(create);
	Lst_Init(&makefiles);
	Lst_Init(&varstoprint);
	Lst_Init(&targs);
@


1.52
log
@Make sure targs get initialized.
Don't bother cleaning it up for speed
@
text
@d73 8
d110 1
a110 1
static char *		chdir_verify_path(char *, char *);
d409 1
a409 1
chdir_verify_path(path, obpath)
a410 1
    char *obpath;
d420 2
a421 4
	    if (path[0] != '/') {
		(void)snprintf(obpath, MAXPATHLEN, "%s/%s", curdir, path);
		return obpath;
	    }
d423 1
a423 1
		return path;
d478 1
a478 3
	char mdpath[MAXPATHLEN + 1];
	char obpath[MAXPATHLEN + 1];
	char cdpath[MAXPATHLEN + 1];
d501 1
a501 2
	curdir = cdpath;
	if (getcwd(curdir, MAXPATHLEN) == NULL) {
d514 4
a517 2
		sa.st_dev == sb.st_dev && strlen(pwd) <= MAXPATHLEN)
		(void)strcpy(curdir, pwd);
d563 1
d568 6
a573 8
			(void)snprintf(mdpath, MAXPATHLEN, "%s.%s",
					path, machine);
			if (!(objdir = chdir_verify_path(mdpath, obpath)))
				if (!(objdir=chdir_verify_path(path, obpath))) {
					(void)snprintf(mdpath, MAXPATHLEN,
							"%s%s", pathp, curdir);
					if (!(objdir=chdir_verify_path(mdpath,
								       obpath)))
d577 1
a577 1
		else if (!(objdir = chdir_verify_path(path, obpath)))
d581 2
a582 2
		(void)snprintf(mdpath, MAXPATHLEN, "%s%s", pathp, curdir);
		if (!(objdir = chdir_verify_path(mdpath, obpath)))
d585 1
d788 5
d816 1
a816 1
	char *name, path[MAXPATHLEN + 1];
d826 8
a833 5
			(void)snprintf(path, sizeof path, "%s/%s", curdir, 
			    fname);
			if ((stream = fopen(path, "r")) != NULL) {
				fname = estrdup(path);
				goto found;
@


1.51
log
@Simple guard against overflow. Better code to appear.
@
text
@d2 1
a2 1
/*	$OpenBSD: main.c,v 1.50 2001/05/29 17:00:54 espie Exp $ */
d589 2
a747 1
	    Lst_Init(&targs);
d773 1
d778 1
@


1.50
log
@Protect against copying a too long PWD.
This is temporary, this code needs better fixes.
@
text
@d2 1
a2 1
/*	$OpenBSD: main.c,v 1.49 2001/05/29 12:53:41 espie Exp $ */
d814 2
a815 1
			(void)sprintf(path, "%s/%s", curdir, fname);
@


1.49
log
@Take includes out of lst.h, re-add what's needed to separate files.
Removes remaining lint stuff from lst.lib.
@
text
@d2 1
a2 1
/*	$OpenBSD: main.c,v 1.48 2001/05/23 12:34:46 espie Exp $ */
d512 1
a512 1
		sa.st_dev == sb.st_dev)
@


1.48
log
@Mostly clean-up:
- cut up those huge include files into separate interfaces for all modules.
Put the interface documentation there, and not with the implementation.
- light-weight includes for needed concrete types (lst_t.h, timestamp_t.h).
- cut out some more logically separate parts: cmd_exec, varname, parsevar,
timestamp.
- put all error handling functions together, so that we will be able to
clean them up.
- more systematic naming: functioni  to handle interval, function to handle
string.
- put the init/end code apart to minimize coupling.
- kill weird types like ReturnStatus and Boolean. Use standard bool (with a
fallback for non-iso systems)
- better interface documentation for lots of subsystems.

As a result, make compilation goes somewhat faster (5%, even considering
the largish BSD copyrights to read). The corresponding preprocessed
source goes down from 1,5M to 1M.

A few minor code changes as well: Parse_DoVar is no longer destructive.
Parse_IsVar functionality is folded into Parse_DoVar (as it knows what an
assignment is), a few more interval handling functions. Avoid calling
XXX_End when they do nothing, just #define XXX_End   to nothing.

Parse_DoVar is slightly more general: it will handle compound assignments
as long as they make sense, e.g., VAR +!= cmd
will work.  As a side effect, VAR++=value now triggers an error
(two + in assignment).
- this stuff doesn't occur in portable Makefiles.
- writing VAR++ = value or VAR+ +=value  disambiguates it.
- this is a good thing, it uncovered a bug in bsd.port.mk.

Tested by naddy@@. Okayed millert@@. I'll handle the fallback if there is
any. This went through a full make build anyways, including isakmpd
(without mickey's custom binutils, as he didn't see fit to share it with me).
@
text
@d2 1
a2 1
/*	$OpenBSD: main.c,v 1.15 1999/01/09 16:45:02 espie Exp $ */
d43 1
d51 1
@


1.47
log
@avoid closing the same file twice. parse module assumes ownership of
file handles it's passed to.

(this is apparently harmless on BSDs, but is still a bug).
@
text
@d2 1
a2 1
/*	$OpenBSD: main.c,v 1.46 2001/05/03 13:41:07 espie Exp $ */
a42 27
/*-
 * main.c --
 *	The main file for this entire program. Exit routines etc
 *	reside here.
 *
 * Utility functions defined in this file:
 *	Main_ParseArgLine	Takes a line of arguments, breaks them and
 *				treats them as if they were given when first
 *				invoked. Used by the parse module to implement
 *				the .MFLAGS target.
 *
 *	Error			Print a tagged error message. The global
 *				MAKE variable must have been defined. This
 *				takes a format string and two optional
 *				arguments for it.
 *
 *	Fatal			Print an error message and exit. Also takes
 *				a format string and two arguments.
 *
 *	Punt			Aborts all jobs and exits with a message. Also
 *				takes a format string and two arguments.
 *
 *	Finish			Finish things up by printing the number of
 *				errors which occured, as passed to it, and
 *				exiting.
 */

a43 4
#include <sys/time.h>
#include <sys/param.h>
#include <sys/resource.h>
#include <sys/signal.h>
a47 1
#include <sys/wait.h>
a48 2
#include <fcntl.h>
#include <stddef.h>
d50 7
a56 9
#include <stdlib.h>
#include <time.h>
#ifdef __STDC__
#include <stdarg.h>
#else
#include <varargs.h>
#endif
#include "make.h"
#include "ohash.h"
d58 3
d62 8
a69 19
#include "pathnames.h"
#include "stats.h"

#ifndef lint
UNUSED
static char copyright[] =
"@@(#) Copyright (c) 1988, 1989, 1990, 1993\n\
	The Regents of the University of California.  All rights reserved.\n";
#endif /* not lint */

#ifndef lint
#if 0
static char sccsid[] = "@@(#)main.c	8.3 (Berkeley) 3/19/94";
#else
UNUSED
static char rcsid[] = "$OpenBSD: main.c,v 1.46 2001/05/03 13:41:07 espie Exp $";
#endif
#endif /* not lint */

d77 2
a78 2
LIST			create; 	/* Targets to be made */
TIMESTAMP		now;		/* Time at start of make */
d80 1
a80 1
Boolean 		allPrecious;	/* .PRECIOUS given on line by itself */
d82 1
a82 1
static Boolean		noBuiltins;	/* -r flag */
d84 1
a84 2
static Boolean		printVars;	/* print value of one or more vars */
static LIST		variables;	/* list of variables to print */
d87 11
a97 12
Boolean 		compatMake;	/* -B argument */
Boolean 		debug;		/* -d flag */
Boolean 		noExecute;	/* -n flag */
Boolean 		keepgoing;	/* -k flag */
Boolean 		queryFlag;	/* -q flag */
Boolean 		touchFlag;	/* -t flag */
Boolean 		usePipes;	/* !-P flag */
Boolean 		ignoreErrors;	/* -i flag */
Boolean 		beSilent;	/* -s flag */
Boolean 		oldVars;	/* variable substitution style */
Boolean 		checkEnvFirst;	/* -e flag */
static Boolean		jobsRunning;	/* TRUE if the jobs might be running */
d105 1
d111 14
d131 2
a132 2
		compatMake = TRUE;
		break;
d134 1
a134 2
		usePipes = FALSE;
		Var_Append(MAKEFLAGS, "-P", VAR_GLOBAL);
d137 1
a137 2
		keepgoing = FALSE;
		Var_Append(MAKEFLAGS, "-S", VAR_GLOBAL);
d140 1
a140 2
		checkEnvFirst = TRUE;
		Var_Append(MAKEFLAGS, "-e", VAR_GLOBAL);
d143 1
a143 2
		ignoreErrors = TRUE;
		Var_Append(MAKEFLAGS, "-i", VAR_GLOBAL);
d146 1
a146 2
		keepgoing = TRUE;
		Var_Append(MAKEFLAGS, "-k", VAR_GLOBAL);
d149 1
a149 2
		noExecute = TRUE;
		Var_Append(MAKEFLAGS, "-n", VAR_GLOBAL);
d152 1
a152 1
		queryFlag = TRUE;
a153 1
		Var_Append(MAKEFLAGS, "-q", VAR_GLOBAL);
d156 1
a156 2
		noBuiltins = TRUE;
		Var_Append(MAKEFLAGS, "-r", VAR_GLOBAL);
d159 1
a159 2
		beSilent = TRUE;
		Var_Append(MAKEFLAGS, "-s", VAR_GLOBAL);
d162 1
a162 2
		touchFlag = TRUE;
		Var_Append(MAKEFLAGS, "-t", VAR_GLOBAL);
d168 1
d203 1
a203 2
			Var_Append(MAKEFLAGS, "-D", VAR_GLOBAL);
			Var_Append(MAKEFLAGS, optarg, VAR_GLOBAL);
d207 1
a207 2
			Var_Append(MAKEFLAGS, "-I", VAR_GLOBAL);
			Var_Append(MAKEFLAGS, optarg, VAR_GLOBAL);
d210 2
a211 4
			printVars = TRUE;
			Lst_AtEnd(&variables, optarg);
			Var_Append(MAKEFLAGS, "-V", VAR_GLOBAL);
			Var_Append(MAKEFLAGS, optarg, VAR_GLOBAL);
d224 1
a224 2
			Var_Append(MAKEFLAGS, "-L", VAR_GLOBAL);
			Var_Append(MAKEFLAGS, optarg, VAR_GLOBAL);
d282 1
a282 2
			Var_Append(MAKEFLAGS, "-d", VAR_GLOBAL);
			Var_Append(MAKEFLAGS, optarg, VAR_GLOBAL);
d291 1
a291 1
			forceJobs = TRUE;
d303 1
a303 2
			Var_Append(MAKEFLAGS, "-j", VAR_GLOBAL);
			Var_Append(MAKEFLAGS, optarg, VAR_GLOBAL);
d307 2
a308 3
			Dir_AddDir(&sysIncPath, optarg, NULL);
			Var_Append(MAKEFLAGS, "-m", VAR_GLOBAL);
			Var_Append(MAKEFLAGS, optarg, VAR_GLOBAL);
d317 1
a317 1
	 * turned compatibility on
d320 1
a320 1
		compatMake = TRUE;
d322 1
a322 1
	oldVars = TRUE;
d330 1
a330 6
		if (Parse_IsVar(*argv)) {
			char *var = estrdup(*argv);

			Parse_DoVar(var, VAR_CMD);
			free(var);
		} else {
d340 1
a340 1
			Lst_AtEnd(&create, estrdup(*argv));
d358 1
a358 1
	char *line;			/* Line to fracture */
d365 1
a365 1
	char *s;
d436 1
a436 1
	Dir_AddDir(l, start, cp);
d468 1
a468 1
	Boolean outOfDate = TRUE;	/* FALSE if all targets up to date */
d476 1
a476 7
					/* avoid faults on read-only strings */
	static char syspath[] = _PATH_DEFSYSPATH;

	set_out_of_date(now);
#ifdef HAS_STATS
	Init_Stats();
#endif
d584 1
a584 1
	Lst_Init(&create);
d586 10
a595 11
	printVars = FALSE;
	Lst_Init(&variables);
	beSilent = FALSE;		/* Print commands as executed */
	ignoreErrors = FALSE;		/* Pay attention to non-zero returns */
	noExecute = FALSE;		/* Execute all commands */
	keepgoing = FALSE;		/* Stop on error */
	allPrecious = FALSE;		/* Remove targets when interrupted */
	queryFlag = FALSE;		/* This is not just a check-run */
	noBuiltins = FALSE;		/* Read the built-in rules */
	touchFlag = FALSE;		/* Actually update targets */
	usePipes = TRUE;		/* Catch child output in pipes */
a596 1
	jobsRunning = FALSE;
d604 1
a604 1
	compatMake = FALSE;		/* No compat mode */
d608 1
a608 3
	 * Initialize the parsing, directory and variable modules to prepare
	 * for the reading of inclusion paths and variable settings on the
	 * command line
d610 2
a611 6
	Dir_Init();		/* Initialize directory structures so -I flags
				 * can be processed correctly */
	Parse_Init();		/* Need to initialize the paths of #include
				 * directories */
	Var_Init();		/* As well as the lists of variables for
				 * parsing arguments */
d613 1
a613 1
		Dir_AddDir(&dirSearchPath, curdir, NULL);
a640 8
	/*
	 * Initialize archive, target and suffix modules in preparation for
	 * parsing the makefile(s)
	 */
	Arch_Init();
	Targ_Init();
	Suff_Init();

a641 1
	grab(now);
d648 1
a648 1
	if (!Lst_IsEmpty(&create)) {
d651 1
a651 1
		for (ln = Lst_First(&create); ln != NULL; ln = Lst_Adv(ln)) {
d665 2
a666 2
	if (Lst_IsEmpty(&sysIncPath))
	    add_dirpath(&sysIncPath, syspath);
d670 2
a671 2
	 * makefile, if it was (makefile != (char *)NULL), or the default
	 * Makefile and makefile, in that order, if it wasn't.
d678 1
a678 1
		Dir_Expand(_PATH_DEFSYSMK, &sysIncPath, &sysMkPath);
d699 1
d718 2
a719 2
	    vpath = Var_Subst("${VPATH}", NULL, FALSE);
	    add_dirpath(&dirSearchPath, vpath);
d732 2
a733 2
	if (printVars) {
		LstNode ln;
d735 2
a736 2
		for (ln = Lst_First(&variables); ln != NULL; ln = Lst_Adv(ln)) {
			char *value = Var_Value((char *)Lst_Datum(ln));
d738 8
a745 11
			printf("%s\n", value ? value : "");
		}
	}

	/* Have now read the entire graph and need to make a list of targets
	 * to create. If none was given on the command line, we consult the
	 * parsing module to find the main target(s) to create.  */
	Lst_Init(&targs);
	if (!Lst_IsEmpty(&create))
		Targ_FindList(&targs, &create);
	else
d747 2
d750 5
a754 1
	if (!compatMake && !printVars) {
a762 1
			jobsRunning = TRUE;
d767 1
a767 4
	} else if (!printVars) {
		/* Compat_Init will take care of creating all the targets as
		 * well as initializing the module.  */
		Compat_Run(&targs);
d771 1
a771 1
	Lst_Destroy(&variables, NOFREE);
d773 1
a773 1
	Lst_Destroy(&create, (SimpleProc)free);
a778 8
	Suff_End();
	Targ_End();
	Arch_End();
	Var_End();
	Parse_End();
	Dir_End();
	Job_End();

d790 1
a790 1
 *	TRUE if ok. FALSE if couldn't open file.
d795 1
a795 1
static Boolean
a800 1
	extern LIST parseIncPath;
d819 1
a819 1
		name = Dir_FindFile(fname, &parseIncPath);
d821 1
a821 1
			name = Dir_FindFile(fname, &sysIncPath);
d823 1
a823 1
			return FALSE;
d833 1
a833 263
	return TRUE;
}

/*-
 * Cmd_Exec --
 *	Execute the command in cmd, and return the output of that command
 *	in a string.
 *
 * Results:
 *	A string containing the output of the command, or the empty string
 *	If err is not NULL, it contains the reason for the command failure
 *
 * Side Effects:
 *	The string must be freed by the caller.
 */
char *
Cmd_Exec(cmd, err)
    const char *cmd;
    char **err;
{
    char	*args[4];	/* Args for invoking the shell */
    int 	fds[2]; 	/* Pipe streams */
    int 	cpid;		/* Child PID */
    int 	pid;		/* PID from wait() */
    char	*res;		/* result */
    int 	status; 	/* command exit status */
    BUFFER	buf;		/* buffer to store the result */
    char	*cp;
    ssize_t	cc;
    size_t	length;


    *err = NULL;

    /*
     * Set up arguments for shell
     */
    args[0] = "sh";
    args[1] = "-c";
    args[2] = (char *)cmd;
    args[3] = NULL;

    /*
     * Open a pipe for fetching its output
     */
    if (pipe(fds) == -1) {
	*err = "Couldn't create pipe for \"%s\"";
	goto bad;
    }

    /*
     * Fork
     */
    switch (cpid = vfork()) {
    case 0:
	/*
	 * Close input side of pipe
	 */
	(void)close(fds[0]);

	/*
	 * Duplicate the output stream to the shell's output, then
	 * shut the extra thing down. Note we don't fetch the error
	 * stream...why not? Why?
	 */
	(void)dup2(fds[1], 1);
	if (fds[1] != 1)
	    (void)close(fds[1]);

	(void)execv("/bin/sh", args);
	_exit(1);
	/*NOTREACHED*/

    case -1:
	*err = "Couldn't exec \"%s\"";
	goto bad;

    default:
	/*
	 * No need for the writing half
	 */
	(void)close(fds[1]);

	Buf_Init(&buf, MAKE_BSIZE);

	do {
	    char   result[BUFSIZ];
	    cc = read(fds[0], result, sizeof(result));
	    if (cc > 0)
		Buf_AddChars(&buf, cc, result);
	}
	while (cc > 0 || (cc == -1 && errno == EINTR));

	/*
	 * Close the input side of the pipe.
	 */
	(void)close(fds[0]);

	/*
	 * Wait for the process to exit.
	 */
	while ((pid = wait(&status)) != cpid && pid >= 0)
	    continue;

	if (cc == -1)
	    *err = "Couldn't read shell's output for \"%s\"";

	if (status)
	    *err = "\"%s\" returned non-zero status";

	length = Buf_Size(&buf);
	res = Buf_Retrieve(&buf);

	/* The result is null terminated, Convert newlines to spaces and
	 * install in the variable.  */
	cp = res + length - 1;

	if (*cp == '\n')
	    /* A final newline is just stripped.  */
	    *cp-- = '\0';

	while (cp >= res) {
	    if (*cp == '\n')
		*cp = ' ';
	    cp--;
	}
	break;
    }
    return res;
bad:
    return estrdup("");
}

/*-
 * Error --
 *	Print an error message given its format.
 */
/* VARARGS */
void
#ifdef __STDC__
Error(char *fmt, ...)
#else
Error(va_alist)
	va_dcl
#endif
{
	va_list ap;
#ifdef __STDC__
	va_start(ap, fmt);
#else
	char *fmt;

	va_start(ap);
	fmt = va_arg(ap, char *);
#endif
	(void)vfprintf(stderr, fmt, ap);
	va_end(ap);
	(void)fprintf(stderr, "\n");
}

/*-
 * Fatal --
 *	Produce a Fatal error message. If jobs are running, waits for them
 *	to finish.
 *
 * Side Effects:
 *	The program exits
 */
/* VARARGS */
void
#ifdef __STDC__
Fatal(char *fmt, ...)
#else
Fatal(va_alist)
	va_dcl
#endif
{
	va_list ap;
#ifdef __STDC__
	va_start(ap, fmt);
#else
	char *fmt;

	va_start(ap);
	fmt = va_arg(ap, char *);
#endif
	if (jobsRunning)
		Job_Wait();

	(void)vfprintf(stderr, fmt, ap);
	va_end(ap);
	(void)fprintf(stderr, "\n");

	if (DEBUG(GRAPH2))
		Targ_PrintGraph(2);
	exit(2);		/* Not 1 so -q can distinguish error */
}

/*
 * Punt --
 *	Major exception once jobs are being created. Kills all jobs, prints
 *	a message and exits.
 *
 * Side Effects:
 *	All children are killed indiscriminately and the program Lib_Exits
 */
/* VARARGS */
void
#ifdef __STDC__
Punt(char *fmt, ...)
#else
Punt(va_alist)
	va_dcl
#endif
{
	va_list ap;
#ifdef __STDC__
	va_start(ap, fmt);
#else
	char *fmt;

	va_start(ap);
	fmt = va_arg(ap, char *);
#endif

	(void)fprintf(stderr, "make: ");
	(void)vfprintf(stderr, fmt, ap);
	va_end(ap);
	(void)fprintf(stderr, "\n");

	DieHorribly();
}

/*-
 * DieHorribly --
 *	Exit without giving a message.
 *
 * Side Effects:
 *	A big one...
 */
void
DieHorribly()
{
	if (jobsRunning)
		Job_AbortAll();
	if (DEBUG(GRAPH2))
		Targ_PrintGraph(2);
	exit(2);		/* Not 1, so -q can distinguish error */
}

/*
 * Finish --
 *	Called when aborting due to errors in child shell to signal
 *	abnormal exit.
 *
 * Side Effects:
 *	The program exits
 */
void
Finish(errors)
	int errors;	/* number of errors encountered in Make_Make */
{
	Fatal("%d error%s", errors, errors == 1 ? "" : "s");
a851 6
void
PrintAddr(a)
    void *a;
{
    printf("%lx ", (unsigned long)a);
}
@


1.46
log
@Synch with my current work.
Numerous changes:
- generate can build several tables
- style cleanup
- statistics code
- use variable names throughout (struct Name)
- recursive variables everywhere
- faster parser (pass buffer along instead of allocating multiple copies)
- correct parser. Handles comments everywhere, and ; correctly
- more string intervals
- simplified dir.c, less recursion.
- extended for loops
- sinclude()
- finished removing extra junk from Lst_*
- handles ${@@D} and friends in a simpler way
- cleaned up and modular VarModifiers handling.
- recognizes some gnu Makefile usages and errors out about them.

Additionally, some extra functionality is defined by FEATURES. The set of
functionalities is currently hardcoded to OpenBSD defaults, but this may
include support for some NetBSD extensions, like ODE modifiers.

Backed by miod@@ and millert@@, who finally got sick of my endless patches...
@
text
@d2 1
a2 1
/*	$OpenBSD: main.c,v 1.15 1999/01/09 16:45:02 espie Exp $ */
d110 1
a110 1
static char rcsid[] = "$OpenBSD: main.c,v 1.15 1999/01/09 16:45:02 espie Exp $";
a916 1
		(void)fclose(stream);
@


1.45
log
@Change the time stamp interface to use an abstract datatype.
Define two possible interfaces: the classic one,
and the new one (used where available) that depends on timespec.

Better granularity, make is now able to distinguish between files that
were built during the same second.
@
text
@d1 2
a2 1
/*	$OpenBSD: main.c,v 1.44 2000/10/13 08:29:20 espie Exp $	*/
d96 1
d110 1
a110 1
static char rcsid[] = "$OpenBSD: main.c,v 1.44 2000/10/13 08:29:20 espie Exp $";
d115 2
a116 2
#ifndef	DEFMAXLOCAL
#define	DEFMAXLOCAL DEFMAXJOBS
d119 1
a119 1
#define	MAKEFLAGS	".MAKEFLAGS"
d121 1
a121 1
LIST			create;		/* Targets to be made */
d124 1
a124 1
Boolean			allPrecious;	/* .PRECIOUS given on line by itself */
d132 11
a142 11
Boolean			compatMake;	/* -B argument */
Boolean			debug;		/* -d flag */
Boolean			noExecute;	/* -n flag */
Boolean			keepgoing;	/* -k flag */
Boolean			queryFlag;	/* -q flag */
Boolean			touchFlag;	/* -t flag */
Boolean			usePipes;	/* !-P flag */
Boolean			ignoreErrors;	/* -i flag */
Boolean			beSilent;	/* -s flag */
Boolean			oldVars;	/* variable substitution style */
Boolean			checkEnvFirst;	/* -e flag */
d145 6
a150 7
static void		MainParseArgs __P((int, char **));
char *			chdir_verify_path __P((char *, char *));
static int		ReadMakefile __P((void *, void *));
static void		add_dirpath __P((Lst, const char *));
static void		usage __P((void));
static void 		posixParseOptLetter __P((char));
int 			main __P((int, char **));
d155 1
d158 1
a158 1
    char c;
a217 3
 * Results:
 *	None
 *
d239 2
a240 2
rearg:	while((c = getopt(argc, argv, OPTFLAGS)) != -1) {
		switch(c) {
d306 3
d388 1
a388 1
					optind = 0;     /* -flag... */
d390 1
a390 1
					optind = 1;     /* - */
d399 1
a399 1
 *  	Used by the parse module when a .MFLAGS or .MAKEFLAGS target
d402 1
a402 1
 * 	component words and passes those words and the number of them to the
a405 3
 * Results:
 *	None
 *
d420 1
d432 1
a432 1
			while (line != s) 
d435 1
a435 1
	    	}
d439 1
a439 1
	argv0 = Var_Value(".MAKE", VAR_GLOBAL);
d443 1
a443 1
	argv = brk_string(buf, &argc, TRUE, &args);
d453 2
a454 2
	char *path;
	char *obpath;
d456 1
a456 1
	struct stat sb;
d458 12
a469 15
	if (stat(path, &sb) == 0 && S_ISDIR(sb.st_mode)) {
		if (chdir(path)) {
			(void)fprintf(stderr, "make warning: %s: %s.\n",
				      path, strerror(errno));
			return 0;
		}
		else {
			if (path[0] != '/') {
				(void) snprintf(obpath, MAXPATHLEN, "%s/%s",
						curdir, path);
				return obpath;
			}
			else
				return path;
		}
d471 1
d473 1
a473 1
	return 0;
d476 1
d481 1
a481 1
    const char 	*n;
d497 1
a497 1

d520 2
a521 2
	LIST targs;	/* target nodes to create -- passed to Make_Init */
	Boolean outOfDate = TRUE; 	/* FALSE if all targets up to date */
d527 1
a527 1
    	char *machine = getenv("MACHINE");
d533 4
d546 1
a546 1
			(void) setrlimit(RLIMIT_NOFILE, &rl);
d570 1
a570 1
		(void) strcpy(curdir, pwd);
d620 1
a620 1
			(void) snprintf(mdpath, MAXPATHLEN, "%s.%s",
d624 1
a624 1
					(void) snprintf(mdpath, MAXPATHLEN,
d635 1
a635 1
		(void) snprintf(mdpath, MAXPATHLEN, "%s%s", pathp, curdir);
d659 1
a659 1
	maxLocal = DEFMAXLOCAL;		/* Set default local max concurrency */
d698 1
a698 3
	 * First snag any flags out of the MAKE environment variable.
	 * (Note this is *not* MAKEFLAGS since /bin/make uses that and it's
	 * in a different format).
a699 1
#ifdef POSIX
a700 3
#else
	Main_ParseArgLine(getenv("MAKE"));
#endif
d704 1
a704 1
#ifdef POSIX
d706 1
a706 1
#endif
d746 1
a746 1
	 * makefile, if it was (makefile != (char *) NULL), or the default
d751 1
a751 1
		LIST sysMkPath;		/* Path of sys.mk */
d777 2
a778 1
	Var_Append("MFLAGS", Var_Value(MAKEFLAGS, VAR_GLOBAL), VAR_GLOBAL);
d780 2
a781 3
	/* Install all the flags into the MAKE envariable. */
	if (((p = Var_Value(MAKEFLAGS, VAR_GLOBAL)) != NULL) && *p)
#ifdef POSIX
a782 3
#else
		esetenv("MAKE", p);
#endif
d790 2
a791 8
	if (Var_Exists("VPATH", VAR_CMD)) {
		char *vpath;
		/*
		 * GCC stores string constants in read-only memory, but
		 * Var_Subst will want to write this thing, so store it
		 * in an array
		 */
		static char VPATH[] = "${VPATH}";
d793 3
a795 3
		vpath = Var_Subst(VPATH, (SymTable *)VAR_CMD, FALSE);
		add_dirpath(&dirSearchPath, vpath);
		(void)free(vpath);
d798 2
a799 4
	/*
	 * Now that all search paths have been read for suffixes et al, it's
	 * time to add the default search path to their lists...
	 */
d802 1
a802 1
	/* print the initial graph, if the user requested it */
d806 1
a806 1
	/* print the values of any variables requested by the user */
d811 1
a811 2
			char *value = Var_Value((char *)Lst_Datum(ln),
					  VAR_GLOBAL);
d817 1
a817 2
	/*
	 * Have now read the entire graph and need to make a list of targets
d819 1
a819 2
	 * parsing module to find the main target(s) to create.
	 */
d827 2
a828 3
		/*
		 * Initialize job module before traversing the graph, now that
		 * any .BEGIN and .END targets have been read.  This is done
d830 1
a830 2
		 * being executed should it exist).
		 */
d838 1
a838 1
		/* Traverse the graph, checking on all the targets */
d841 2
a842 4
		/*
		 * Compat_Init will take care of creating all the targets as
		 * well as initializing the module.
		 */
d856 1
a856 1
        Targ_End();
d864 1
a864 1
		return(1);
d866 1
a866 1
		return(0);
d881 2
a882 2
	void *p; 
	void *q;
d890 1
a891 1
		Var_Set("MAKEFILE", "", VAR_GLOBAL);
d908 1
a908 1
			return(FALSE);
d919 1
a919 1
	return(TRUE);
d936 1
a936 1
    char *cmd;
d939 4
a942 4
    char	*args[4];   	/* Args for invoking the shell */
    int 	fds[2];	    	/* Pipe streams */
    int 	cpid;	    	/* Child PID */
    int 	pid;	    	/* PID from wait() */
d944 1
a944 1
    int		status;		/* command exit status */
d948 1
a948 1
    size_t 	length;
d958 1
a958 1
    args[2] = cmd;
d977 1
a977 1
	(void) close(fds[0]);
d984 3
a986 2
	(void) dup2(fds[1], 1);
	(void) close(fds[1]);
d988 1
a988 1
	(void) execv("/bin/sh", args);
d1000 1
a1000 1
	(void) close(fds[1]);
d1015 1
a1015 1
	(void) close(fds[0]);
d1020 1
a1020 1
	while(((pid = wait(&status)) != cpid) && (pid >= 0))
a1022 3
	res = Buf_Retrieve(&buf);
	length = Buf_Size(&buf);

d1029 5
a1033 5
	/*
	 * Null-terminate the result, convert newlines to spaces and
	 * install it in the variable.
	 */
	res[length] = '\0';
d1036 2
a1037 4
	if (*cp == '\n') {
	    /*
	     * A final newline is just stripped
	     */
d1039 1
a1039 1
	}
d1041 1
a1041 1
	    if (*cp == '\n') {
a1042 1
	    }
d1049 1
a1049 3
    res = emalloc(1);
    *res = '\0';
    return res;
a1054 6
 *
 * Results:
 *	None.
 *
 * Side Effects:
 *	The message is printed.
a1076 1
	(void)fflush(stderr);
a1083 3
 * Results:
 *	None
 *
a1110 1
	(void)fflush(stderr);
a1121 3
 * Results:
 *	None
 *
a1147 1
	(void)fflush(stderr);
a1155 3
 * Results:
 *	None
 *
a1173 3
 * Results:
 *	None
 *
d1184 1
d1194 2
a1195 2
            [-I directory] [-j max_jobs] [-m directory] [-V variable]\n\
            [variable=value] [target ...]\n");
d1204 1
a1204 1
    printf("%lx ", (unsigned long) a);
@


1.44
log
@esetenv: does a setenv and bails out if error.
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.43 2000/09/14 13:46:45 espie Exp $	*/
d108 1
a108 1
static char rcsid[] = "$OpenBSD: main.c,v 1.43 2000/09/14 13:46:45 espie Exp $";
d120 1
a120 1
time_t			now = OUT_OF_DATE;/* Time at start of make */
d533 1
d720 1
a720 1
	(void)time(&now);
@


1.43
log
@Replace the old hash used to hold file names within a directory with
open hashing.

An interesting optimization is that the open hashing interface is more
fine-grained, hence we can compute the correct hash value at the start
of Dir_FindFile, and reuse it for each hash structure into which we look
(the effect is measurable on large directories along with objdir/VPATH).

Remove a few unnecessary Lst_Open/Lst_Close that serve no purpose except
obfuscating the code.

The interface to dir.h changes slightly, hence tedious includes changes...
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.42 2000/09/14 13:43:31 espie Exp $	*/
d108 1
a108 1
static char rcsid[] = "$OpenBSD: main.c,v 1.42 2000/09/14 13:43:31 espie Exp $";
d636 1
a636 1
	setenv("PWD", objdir, 1);
d784 1
a784 1
		setenv("MAKEFLAGS", p, 1);
d786 1
a786 1
		setenv("MAKE", p, 1);
@


1.42
log
@- new DirReadDir internal function, that just reads a directory from
the disk or from a cache.
- use it in Dir_AddDir, and directly to set up dot.
- change Dir_AddDir to use string intervals, as this simplifies
dependend functions.
- set up an open-hashing cache for opened directory names.
- add_dirpath() function in main, to simplify code.
- simplify cleaning-up directories, as Dir_ClearPath is overkill.
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.41 2000/09/14 13:32:07 espie Exp $	*/
d81 1
d91 1
a91 1
#include "hash.h"
d108 1
a108 1
static char rcsid[] = "$OpenBSD: main.c,v 1.41 2000/09/14 13:32:07 espie Exp $";
@


1.41
log
@Some systematic clean-up.
- UNUSED macro that expands to __attribute__((unused)) for gcc
- move rcsid around so that they can be tagged UNUSED.
- activate -Wunused.
- use UNUSED instead of kludgy junk for function arguments.
- add extern to all extern prototypes.
- update comments in lst.h.
- clean up var.c a little bit, constifying arguments, updating comments...
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.40 2000/07/31 21:01:40 espie Exp $	*/
d107 1
a107 1
static char rcsid[] = "$OpenBSD: main.c,v 1.38 2000/07/01 00:21:22 espie Exp $";
d145 1
d351 1
a351 1
			Dir_AddDir(&sysIncPath, optarg);
d477 20
a528 1
	char *cp = NULL, *start;
d675 1
a675 1
		Dir_AddDir(&dirSearchPath, curdir);
d742 2
a743 12
	if (Lst_IsEmpty(&sysIncPath)) {
		for (start = syspath; *start != '\0'; start = cp) {
			for (cp = start; *cp != '\0' && *cp != ':'; cp++)
				continue;
			if (*cp == '\0') {
				Dir_AddDir(&sysIncPath, start);
			} else {
				*cp++ = '\0';
				Dir_AddDir(&sysIncPath, start);
			}
		}
	}
d795 1
a795 1
		char *vpath, *path, *cp, savec;
d804 2
a805 14
		path = vpath;
		do {
			/* skip to end of directory */
			for (cp = path; *cp != ':' && *cp != '\0'; cp++)
				continue;
			/* Save terminator character so know when to stop */
			savec = *cp;
			*cp = '\0';
			/* Add directory to search path */
			Dir_AddDir(&dirSearchPath, path);
			*cp = savec;
			path = cp + 1;
		} while (savec == ':');
		free(vpath);
@


1.40
log
@POSIX rules: pass variables set on the command line to submakes through
MAKEFLAGS
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.39 2000/07/18 20:17:20 espie Exp $	*/
a41 14
#ifndef lint
static char copyright[] =
"@@(#) Copyright (c) 1988, 1989, 1990, 1993\n\
	The Regents of the University of California.  All rights reserved.\n";
#endif /* not lint */

#ifndef lint
#if 0
static char sccsid[] = "@@(#)main.c	8.3 (Berkeley) 3/19/94";
#else
static char rcsid[] = "$OpenBSD: main.c,v 1.39 2000/07/18 20:17:20 espie Exp $";
#endif
#endif /* not lint */

d94 17
@


1.39
log
@Handle MAKEFLAGS variation mandated by POSIX.

Code to pass variable definitions to submakes through make flags.
Not activated yet, need to fix src/ first.
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.38 2000/07/01 00:21:22 espie Exp $	*/
d52 1
a52 1
static char rcsid[] = "$OpenBSD: main.c,v 1.38 2000/07/01 00:21:22 espie Exp $";
d682 1
a682 1
#ifdef NotYet
@


1.38
log
@Forgot to import one estrdup from my trunk.

Ensure make prints sane error messages when obj/ exists.
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.37 2000/06/23 16:39:45 espie Exp $	*/
d52 1
a52 1
static char rcsid[] = "$OpenBSD: main.c,v 1.37 2000/06/23 16:39:45 espie Exp $";
d143 1
d149 55
d234 1
a252 3
		case 'B':
			compatMake = TRUE;
			break;
a268 8
		case 'P':
			usePipes = FALSE;
			Var_Append(MAKEFLAGS, "-P", VAR_GLOBAL);
			break;
		case 'S':
			keepgoing = FALSE;
			Var_Append(MAKEFLAGS, "-S", VAR_GLOBAL);
			break;
a323 4
		case 'e':
			checkEnvFirst = TRUE;
			Var_Append(MAKEFLAGS, "-e", VAR_GLOBAL);
			break;
a326 4
		case 'i':
			ignoreErrors = TRUE;
			Var_Append(MAKEFLAGS, "-i", VAR_GLOBAL);
			break;
a345 4
		case 'k':
			keepgoing = TRUE;
			Var_Append(MAKEFLAGS, "-k", VAR_GLOBAL);
			break;
a350 21
		case 'n':
			noExecute = TRUE;
			Var_Append(MAKEFLAGS, "-n", VAR_GLOBAL);
			break;
		case 'q':
			queryFlag = TRUE;
			/* Kind of nonsensical, wot? */
			Var_Append(MAKEFLAGS, "-q", VAR_GLOBAL);
			break;
		case 'r':
			noBuiltins = TRUE;
			Var_Append(MAKEFLAGS, "-r", VAR_GLOBAL);
			break;
		case 's':
			beSilent = TRUE;
			Var_Append(MAKEFLAGS, "-s", VAR_GLOBAL);
			break;
		case 't':
			touchFlag = TRUE;
			Var_Append(MAKEFLAGS, "-t", VAR_GLOBAL);
			break;
d352 1
a352 2
		case '?':
			usage();
d413 2
a414 1
	char *argv0 = Var_Value(".MAKE", VAR_GLOBAL);
d423 12
d682 3
@


1.37
log
@This patch is worth a lot, speed-wise.

This does introduce a proper stack of IFiles to handle included files:
instead of having the current file be a special case, it's also an IFile.

The corresponding code is slightly unobfuscated, removing the error-prone
ParseEOF function, freeing the filename systematically (thus, main.c needs
to strdup stdin), and merging both include functions lookup into one.

The speed gain comes from changing the IFile structure to merge with
fgetln seamlessly.

The low-level parse code is mostly moved to a new file, lowparse.c, to
make things easier to read (see next patch as well).

Accordingly, util.c gains a fgetln.

Note the interaction between Parse_File, Dir_FindFile, and ReadMakefile in
main.c. This patch closes a subtle memory hole (only the Makefile names,
so rather small).

Reviewed by miod@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.36 2000/06/23 16:23:26 espie Exp $	*/
d52 1
a52 1
static char rcsid[] = "$OpenBSD: main.c,v 1.36 2000/06/23 16:23:26 espie Exp $";
d889 1
a889 1
				fname = path;
@


1.36
log
@This patch separates local contexts from global contexts for good.
Apart from a few casts, VAR_GLOBAL and friends are separate
data structures, so we use a small array for local variables.

We also junk allVars, since TargFreeGN can release local nodes,
and var.c has explicit lists for its variables already.

Reviewed millert@@ and miod@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.35 2000/06/23 16:15:49 espie Exp $	*/
d52 1
a52 1
static char rcsid[] = "$OpenBSD: main.c,v 1.35 2000/06/23 16:15:49 espie Exp $";
d880 1
a880 1
		Parse_File("(stdin)", stdin);
@


1.35
log
@Trivial consequences of the previous list changes:

- audit code for Lst_Datum, it's never applied to an empty pointer,
so check can be removed -> turn into a macro,
- Lst_First, Lst_Last can become macro as well
- specialized version of Lst_Succ (Lst_Adv) to use in loops where it cannot
fail,
- Lst_Open can no longer fail. Trim down corresponding code.

Reviewed millert@@, miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.34 2000/06/17 14:40:29 espie Exp $	*/
d52 1
a52 1
static char rcsid[] = "$OpenBSD: main.c,v 1.34 2000/06/17 14:40:29 espie Exp $";
d762 1
a762 1
		vpath = Var_Subst(VPATH, VAR_CMD, FALSE);
@


1.34
log
@A few assorted changes, to remove more dynamic lists.
- in Dir_Expand, path is a misnomer. Use a temp variable instead...
Reformat code for readability.
- Change Parse_MainName/Targ_FindList so that they fill arguments instead
of allocating new lists.
- nuke Targ_FindList(TG_NOCREATE), as this is never used.

- close a small memory hole (forgot to free sysMkPath if CLEANUP).

Reviewed by millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.33 2000/06/17 14:38:18 espie Exp $	*/
d52 1
a52 1
static char rcsid[] = "$OpenBSD: main.c,v 1.33 2000/06/17 14:38:18 espie Exp $";
d677 1
a677 2
		for (ln = Lst_First(&create); ln != NULL;
		    ln = Lst_Succ(ln)) {
d793 1
a793 2
		for (ln = Lst_First(&variables); ln != NULL;
		    ln = Lst_Succ(ln)) {
@


1.33
log
@This patch introduces a distinction between
Lst_Init (constructor) and Lst_New (allocation + construction)
Lst_Destroy (destructor) and Lst_Delete (deallocation + destruction),
and uses that to turn most dynamic allocation of lists (Lst pointers)
into static structures (LIST).

Most of this is mundane, except for allGNs in targ.c, where the code must
be checked to verify that Targ_Init is called soon enough.

Lst_New is a temporary addition. All lists will soon be static.

Reviewed by millert@@, like the previous patch.
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.32 2000/06/10 01:41:05 espie Exp $	*/
d52 1
a52 1
static char rcsid[] = "$OpenBSD: main.c,v 1.32 2000/06/10 01:41:05 espie Exp $";
d471 1
a471 1
	Lst targs;	/* target nodes to create -- passed to Make_Init */
d721 3
d808 3
a810 2
	if (Lst_IsEmpty(&create))
		targs = Parse_MainName();
d812 1
a812 1
		targs = Targ_FindList(&create, TARG_CREATE);
d829 1
a829 1
		outOfDate = Make_Run(targs);
d835 1
a835 1
		Compat_Run(targs);
d838 1
a838 1
	Lst_Delete(targs, NOFREE);
@


1.32
log
@Clean-up patch: use `void *' instead of old-fashioned ClientData/Address.
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.31 2000/06/10 01:32:23 espie Exp $	*/
d52 1
a52 1
static char rcsid[] = "$OpenBSD: main.c,v 1.31 2000/06/10 01:32:23 espie Exp $";
d115 1
a115 1
Lst			create;		/* Targets to be made */
d121 1
a121 1
static Lst		makefiles;	/* ordered list of makefiles to read */
d123 1
a123 1
static Lst		variables;	/* list of variables to print */
d192 1
a192 1
			Lst_AtEnd(variables, optarg);
d283 1
a283 1
			Lst_AtEnd(makefiles, optarg);
d313 1
a313 1
			Dir_AddDir(sysIncPath, optarg);
d374 1
a374 1
			Lst_AtEnd(create, estrdup(*argv));
a479 1
	Lst sysMkPath;			/* Path of sys.mk */
d590 2
a591 2
	create = Lst_Init();
	makefiles = Lst_Init();
d593 1
a593 1
	variables = Lst_Init();
d627 1
a627 1
		Dir_AddDir(dirSearchPath, curdir);
d674 1
a674 1
	if (!Lst_IsEmpty(create)) {
d677 1
a677 1
		for (ln = Lst_First(create); ln != NULL;
d692 1
a692 1
	if (Lst_IsEmpty(sysIncPath)) {
d697 1
a697 1
				Dir_AddDir(sysIncPath, start);
d700 1
a700 1
				Dir_AddDir(sysIncPath, start);
d712 1
d714 3
a716 3
		sysMkPath = Lst_Init();
		Dir_Expand (_PATH_DEFSYSMK, sysIncPath, sysMkPath);
		if (Lst_IsEmpty(sysMkPath))
d718 1
a718 1
		ln = Lst_Find(sysMkPath, ReadMakefile, NULL);
d723 1
a723 1
	if (!Lst_IsEmpty(makefiles)) {
d726 1
a726 1
		ln = Lst_Find(makefiles, ReadMakefile, NULL);
d770 1
a770 1
			Dir_AddDir(dirSearchPath, path);
d791 1
a791 1
		for (ln = Lst_First(variables); ln != NULL;
d805 1
a805 1
	if (Lst_IsEmpty(create))
d808 1
a808 1
		targs = Targ_FindList(create, TARG_CREATE);
d834 4
a837 4
	Lst_Destroy(targs, NOFREE);
	Lst_Destroy(variables, NOFREE);
	Lst_Destroy(makefiles, NOFREE);
	Lst_Destroy(create, (SimpleProc)free);
d873 1
a873 1
	extern Lst parseIncPath;
d892 1
a892 1
		name = Dir_FindFile(fname, parseIncPath);
d894 1
a894 1
			name = Dir_FindFile(fname, sysIncPath);
@


1.31
log
@Thus, Lst_ForEach no longer needs returning a status.
In fact, it can become a macro based on Lst_ForEachFrom.
This also introduces Lst_Every, as a shortcut for the very common case where
Lst_ForEach does not need any user data.

Finally,  make consistent use of a few function typedefs, instead of having
explicit void (*)(Lst)  arguments all over the place.
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.30 2000/04/03 02:58:46 espie Exp $	*/
d52 1
a52 1
static char rcsid[] = "$OpenBSD: main.c,v 1.30 2000/04/03 02:58:46 espie Exp $";
d141 1
a141 1
static int		ReadMakefile __P((ClientData, ClientData));
d192 1
a192 1
			Lst_AtEnd(variables, (ClientData)optarg);
d283 1
a283 1
			Lst_AtEnd(makefiles, (ClientData)optarg);
d374 1
a374 1
			Lst_AtEnd(create, (ClientData)estrdup(*argv));
d774 1
a774 1
		(void)free((Address)vpath);
d869 2
a870 1
	ClientData p, q;
d1217 1
a1217 1
    ClientData a;
@


1.30
log
@Junk CDPATH from the environment.
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.29 2000/03/26 16:21:32 espie Exp $	*/
d52 1
a52 1
static char rcsid[] = "$OpenBSD: main.c,v 1.29 2000/03/26 16:21:32 espie Exp $";
d837 1
a837 1
	Lst_Destroy(create, (void (*) __P((ClientData))) free);
d1214 2
a1215 2
int
PrintAddr(a, b)
a1216 1
    ClientData b;
a1218 1
    return b ? 0 : 0;
@


1.29
log
@Remove idiotic, braindead casts T* -> void*
They serve no purpose, except hiding potential bugs.

In particular, remove (ClientData) cast from macro, showing potentially
troublesome use of Hashes to store time_t.
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.28 2000/02/02 13:47:47 espie Exp $	*/
d52 1
a52 1
static char rcsid[] = "$OpenBSD: main.c,v 1.28 2000/02/02 13:47:47 espie Exp $";
d589 1
d657 1
@


1.28
log
@Bug-fix: make should behave sensibly when presented with negative times...

- let *_MTime return booleans, as that's what they're used for, the time_t
is set as a side effect.

- use OUT_OF_DATE for a date starting point, set it at the origin of time.
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.27 1999/12/19 00:04:25 espie Exp $	*/
d52 1
a52 1
static char rcsid[] = "$OpenBSD: main.c,v 1.27 1999/12/19 00:04:25 espie Exp $";
d716 1
a716 1
		ln = Lst_Find(sysMkPath, ReadMakefile, (ClientData)NULL);
d724 1
a724 1
		ln = Lst_Find(makefiles, ReadMakefile, (ClientData)NULL);
@


1.27
log
@Rearrange Lst_Find interface to conform better with other functions.
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.26 1999/12/18 21:58:07 espie Exp $	*/
d52 1
a52 1
static char rcsid[] = "$OpenBSD: main.c,v 1.26 1999/12/18 21:58:07 espie Exp $";
d116 1
a116 1
time_t			now;		/* Time at start of make */
@


1.26
log
@Nothing ever checks ReturnStatus on Lst_Insert, Lst_Append, Lst_AtFront,
Lst_AtEnd, Lst_Concat, Lst_Remove, Lst_Replace.

Don't bother returning one.
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.25 1999/12/18 21:53:32 espie Exp $	*/
d52 1
a52 1
static char rcsid[] = "$OpenBSD: main.c,v 1.25 1999/12/18 21:53:32 espie Exp $";
d716 1
a716 1
		ln = Lst_Find(sysMkPath, (ClientData)NULL, ReadMakefile);
d724 1
a724 1
		ln = Lst_Find(makefiles, (ClientData)NULL, ReadMakefile);
@


1.25
log
@NIL, NILGNODE, etc, are only glorified NULL.
Get rid of them.

Get rid of list.h, nothing uses it anyway.
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.24 1999/12/18 02:11:27 espie Exp $	*/
d52 1
a52 1
static char rcsid[] = "$OpenBSD: main.c,v 1.24 1999/12/18 02:11:27 espie Exp $";
d192 1
a192 1
			(void)Lst_AtEnd(variables, (ClientData)optarg);
d283 1
a283 1
			(void)Lst_AtEnd(makefiles, (ClientData)optarg);
d374 1
a374 1
			(void)Lst_AtEnd(create, (ClientData)estrdup(*argv));
@


1.24
log
@make does not use circular lists, get rid of the extra weight.
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.23 1999/12/16 17:27:18 espie Exp $	*/
d52 1
a52 1
static char rcsid[] = "$OpenBSD: main.c,v 1.23 1999/12/16 17:27:18 espie Exp $";
d665 1
a665 1
	DEFAULT = NILGNODE;
d676 1
a676 1
		for (ln = Lst_First(create); ln != NILLNODE;
d717 1
a717 1
		if (ln != NILLNODE)
d725 1
a725 1
		if (ln != NILLNODE)
d789 1
a789 1
		for (ln = Lst_First(variables); ln != NILLNODE;
@


1.23
log
@Var_Subst is actually two distinct functions folded into one:
split the function specific to for.c out, and give them more sensible
arguments at the same time.

This makes .for loop handling more efficient, as we have some heuristic
to evaluate the size of the buffer needed...
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.22 1999/12/16 17:02:45 espie Exp $	*/
d52 1
a52 1
static char rcsid[] = "$OpenBSD: main.c,v 1.22 1999/12/16 17:02:45 espie Exp $";
d590 2
a591 2
	create = Lst_Init(FALSE);
	makefiles = Lst_Init(FALSE);
d593 1
a593 1
	variables = Lst_Init(FALSE);
d712 1
a712 1
		sysMkPath = Lst_Init (FALSE);
@


1.22
log
@Allocate buffers as static data structures.
This cuts down quite a lot of malloc, since in actual use,
buffer usage is mostly static.
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.21 1999/12/16 16:41:41 espie Exp $	*/
d52 1
a52 1
static char rcsid[] = "$OpenBSD: main.c,v 1.21 1999/12/16 16:41:41 espie Exp $";
d758 1
a758 1
		vpath = Var_Subst(NULL, VPATH, VAR_CMD, FALSE);
@


1.21
log
@Split Buf_GetAll into Buf_Retrieve/Buf_Size.
(idiotic to retrieve size every time when it's used half the time)
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.20 1999/12/09 18:20:06 espie Exp $	*/
d52 1
a52 1
static char rcsid[] = "$OpenBSD: main.c,v 1.20 1999/12/09 18:20:06 espie Exp $";
d930 1
a930 1
    Buffer	buf;		/* buffer to store the result */
d986 1
a986 1
	buf = Buf_Init(MAKE_BSIZE);
d992 1
a992 1
		Buf_AddChars(buf, cc, result);
d1007 2
a1008 3
	res = Buf_Retrieve(buf);
	length = Buf_Size(buf);
	Buf_Destroy(buf, FALSE);
@


1.20
log
@Split some allocation/error handling functions out of main.c
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.19 1999/12/06 22:28:44 espie Exp $	*/
d52 1
a52 1
static char rcsid[] = "$OpenBSD: main.c,v 1.19 1999/12/06 22:28:44 espie Exp $";
d1007 2
a1008 1
	res = Buf_GetAll(buf, &length);
@


1.19
log
@Extra parameter no longer needed, ditch.
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.18 1999/12/06 22:24:31 espie Exp $	*/
d52 1
a52 1
static char rcsid[] = "$OpenBSD: main.c,v 1.18 1999/12/06 22:24:31 espie Exp $";
a1194 75
}

/*
 * emalloc --
 *	malloc, but die on error.
 */
void *
emalloc(len)
	size_t len;
{
	void *p;

	if ((p = malloc(len)) == NULL)
		enomem();
	return(p);
}

/*
 * estrdup --
 *	strdup, but die on error.
 */
char *
estrdup(str)
	const char *str;
{
	char *p;

	if ((p = strdup(str)) == NULL)
		enomem();
	return(p);
}

/*
 * erealloc --
 *	realloc, but die on error.
 */
void *
erealloc(ptr, size)
	void *ptr;
	size_t size;
{
	if ((ptr = realloc(ptr, size)) == NULL)
		enomem();
	return(ptr);
}

/*
 * enomem --
 *	die when out of memory.
 */
void
enomem()
{
	(void)fprintf(stderr, "make: %s.\n", strerror(errno));
	exit(2);
}

/*
 * enunlink --
 *	Remove a file carefully, avoiding directories.
 */
int
eunlink(file)
	const char *file;
{
	struct stat st;

	if (lstat(file, &st) == -1)
		return -1;

	if (S_ISDIR(st.st_mode)) {
		errno = EISDIR;
		return -1;
	}
	return unlink(file);
@


1.18
log
@Clean up buffers interface somewhat:

- buf.c deals exclusively with chars. Be explicit about it, and remove
extraneous dumb casts to char (can hide real type errors).
- buffer sizes are size_t. Note that bp->left can never become NULL.
- Buf_GetAll is happy with a NULL pointer for the size, remove unneeded
extra pointers.
- Propagate size_t to all places where buffer functions are used.
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.17 1999/12/06 22:20:34 espie Exp $	*/
d52 1
a52 1
static char rcsid[] = "$OpenBSD: main.c,v 1.17 1999/12/06 22:20:34 espie Exp $";
d400 2
a401 2
	char *buf, *p1;
	char *argv0 = Var_Value(".MAKE", VAR_GLOBAL, &p1);
a411 1
	efree(p1);
d474 1
a474 1
	char *p, *p1, *path, *pathp, *pwd;
d733 1
a733 2
	Var_Append("MFLAGS", Var_Value(MAKEFLAGS, VAR_GLOBAL, &p1), VAR_GLOBAL);
	efree(p1);
d736 1
a736 1
	if (((p = Var_Value(MAKEFLAGS, VAR_GLOBAL, &p1)) != NULL) && *p)
a741 1
	efree(p1);
d792 1
a792 1
					  VAR_GLOBAL, &p1);
a794 1
			efree(p1);
@


1.17
log
@Fix handling of
VAR!=

specifically, properly distinguish between bad commands and empty results.
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.16 1999/11/10 14:11:49 espie Exp $	*/
d52 1
a52 1
static char rcsid[] = "$OpenBSD: main.c,v 1.16 1999/11/10 14:11:49 espie Exp $";
d937 1
a937 1
    int 	length;
d990 1
a990 1
	buf = Buf_Init (MAKE_BSIZE);
d996 1
a996 1
		Buf_AddBytes(buf, cc, (Byte *) result);
d1011 2
a1012 2
	res = (char *)Buf_GetAll (buf, &length);
	Buf_Destroy (buf, FALSE);
@


1.16
log
@Turn on strict-prototypes, add missing prototypes.
Move main prototype to main.c, as this is not used
from any other file.

Close open bug.
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.15 1999/01/09 16:45:02 espie Exp $	*/
d52 1
a52 1
static char rcsid[] = "$OpenBSD: main.c,v 1.15 1999/01/09 16:45:02 espie Exp $";
d936 2
a937 1
    int		cc;
d1011 1
a1011 1
	res = (char *)Buf_GetAll (buf, &cc);
d1014 1
a1014 1
	if (cc == 0)
d1024 2
a1025 2
	res[cc] = '\0';
	cp = &res[cc] - 1;
@


1.15
log
@close PR 685.

Slightly trimmed down version of fix by assar@@sics.se
(strtol failure is usually simpler to test, and error messages should
identify the program that produces them)
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.14 1998/12/05 00:06:28 espie Exp $	*/
d52 1
a52 1
static char rcsid[] = "$OpenBSD: main.c,v 1.14 1998/12/05 00:06:28 espie Exp $";
d143 1
@


1.14
log
@Modifications from netbsd:
- don't interfere with MACHINE/MACHINE_ARCH defines for bootstrap
- type clean-up, time_t, and printing `unknown' ints
- fix TARGET/MEMBER bug in archive rules
- memmove...
- cleaner Error handler.
- reentrant brk_string
- .MAKE env variable
- preliminary scaffolding for .NOPATH

Other improvements:
- efree
- shellneed streamlined
- display Stop in .CURDIR after an error.
- document most features and misfeatures.
- add a few OpenBSD notes to the tutorial.
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.12 1997/04/01 07:28:13 millert Exp $	*/
d52 1
a52 1
static char rcsid[] = "$OpenBSD: main.c,v 1.12 1997/04/01 07:28:13 millert Exp $";
d199 10
a208 2
		case 'L':
			maxLocal = atoi(optarg);
d212 1
d288 3
a290 1
		case 'j':
d292 7
d306 1
@


1.13
log
@Use BSDmakefile in favour of [mM]akefile if existent.  Good for
cases where you want BSDmake specific facilities not messing up other
implementations of make
@
text
@d97 1
d379 3
d390 6
a395 1
	argv = brk_string(line, &argc, TRUE);
d397 3
a606 1
        str_init();
d619 1
d715 1
a715 2
	if (p1)
	    free(p1);
d724 1
a724 2
	if (p1)
	    free(p1);
d778 1
a778 2
			if (p1)
				free(p1);
a827 1
	str_end();
d831 1
@


1.12
log
@Sync with NetBSD (mostly by christos initial substitution/regexp from Der Mouse)

- fix the variable substitution code in make [PR/2748]
      1. change s/a/b/ so that it substitutes the first occurance of the
         pattern on each word, not only the first word.
      2. add flag '1' to the variable substitution so that the substitutions
         get performed only once.

  ***THIS IS AN INCOMPATIBLE CHANGE!***

  Unfortunately there was no way to make things consistent without
  modifying the current behavior. Fortunately none of our Makefiles
  depended on this.

            OLD:

                VAR      = aa1 aa2 aa3 aa4

                S/a/b/   = ba1 aa2 aa3 aa4
                S/a/b/g  = bb1 bb2 bb3 bb4

            NEW:
                VAR      = aa1 aa2 aa3 aa4

                S/a/b/   = ba1 ba2 ba3 ba4
                S/a/b/1  = ba1 aa2 aa3 aa4
                S/a/b/g  = bb1 bb2 bb3 bb4
                S/a/b/1g = bb1 aa2 aa3 aa4
- add regexp variable substitution via 'C/foo/bar/' [PR/2752]
- add variable quoting via the ${VAR:Q} modifier. This is useful when running
  recursive invocations of make(1):

        make VAR=${VAR:Q}

  will always work... (This may prove useful in the kernel builds...) [PR/2981]
- BSD did not traditionally have <sys/cdefs.h>; use BSD4_4 instead and include
  <sys/param.h> to grab it.
- Don't compile the regex code if MAKE_BOOTSTRAP (from gwr)
- Use explicit .c.o rule in Makefile.boot so that the bootstrap process works.
- Use only integral types in procedure arguments. [buf.c buf.h]
- Include <stdlib.h> to get getenv() prototype on SVR4
- if __STDC__ -> ifdef __STDC__ to appease SVR4
- Define const and volatile for non __STDC__
- Implement snprintf() and vsnprintf() for non BSD4_4 systems.
- Make $MACHINE_ARCH settable from the environment.
- Fix .USE directive problems: (reported by cgd)
    1. ${.*} variables did not get expanded in dependencies.
    2. expanded ${.*} variables in .USE dependencies can cause tree
       restructuring; handle it.
    3. in compat mode, expand .USE before evaluating the list of targets,
       instead of doing .USE expansions on demand, because they can cause
       tree restructuring.
- Add a .MADE directive to indicated that the children of a target are
  up-to-date, even when they are not. This is to simulate our current
  make install behavior with proper dependencies.
- Fix problems in the RE substitution error handling.
- Locate all the children of a node marked as MADE.
- Do not compile-in ${MACHINE} (as per NetBSD PR#3386)
- Disable globbing for targets/dependencies when POSIX is defined.
- Fix globbing so that patterns that don't have a matching number of [] or {}
  don't get expanded. (before the [ case got expanded to nothing!) This is
  disabled.
- Make sure that the children of nodes that are marked .MADE, are marked
  UPTODATE and their timestamps are consistent.
- Don't disable wildcards completely; they are used by other Makefiles.
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.11 1997/01/27 05:24:09 briggs Exp $	*/
d52 1
a52 1
static char rcsid[] = "$OpenBSD: main.c,v 1.11 1997/01/27 05:24:09 briggs Exp $";
d696 3
a698 2
	} else if (!ReadMakefile("makefile", NULL))
		(void)ReadMakefile("Makefile", NULL);
@


1.11
log
@Set MACHINE_ARCH only if it's not already in the environment.  Update
comment accordingly.  Patch from Dale Rahn.
@
text
@d1 2
a2 2
/*	$OpenBSD: main.c,v 1.10 1997/01/15 23:42:51 millert Exp $	*/
/*	$NetBSD: main.c,v 1.31 1996/11/06 17:59:12 christos Exp $	*/
d52 1
a52 1
static char rcsid[] = "$OpenBSD: main.c,v 1.10 1997/01/15 23:42:51 millert Exp $";
d89 1
a89 1
#ifndef MACHINE
d96 2
a97 1
#if __STDC__
d448 1
d495 2
a496 3
	 * Note that both MACHINE and MACHINE_ARCH can be overridden
	 * by environment variables.  MACHINE through the getenv()
	 * above and MACHINE_ARCH, below.
d498 2
a499 2
    	if (!machine) {
#ifndef MACHINE
d512 8
d611 1
a611 5
#ifdef MACHINE_ARCH
	if (NULL == getenv("MACHINE_ARCH")) {
		Var_Set("MACHINE_ARCH", MACHINE_ARCH, VAR_GLOBAL);
	}
#endif
d1029 1
a1029 1
#if __STDC__
d1037 1
a1037 1
#if __STDC__
d1064 1
a1064 1
#if __STDC__
d1072 1
a1072 1
#if __STDC__
d1106 1
a1106 1
#if __STDC__
d1114 1
a1114 1
#if __STDC__
@


1.10
log
@getopt(3) returns -1 when out of args, not EOF, whee!
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.9 1996/11/30 21:08:59 millert Exp $	*/
d52 1
a52 1
static char rcsid[] = "$OpenBSD: main.c,v 1.9 1996/11/30 21:08:59 millert Exp $";
d493 3
a495 2
	 * Note that while MACHINE is decided at run-time,
	 * MACHINE_ARCH is always known at compile time.
d603 3
a605 1
	Var_Set("MACHINE_ARCH", MACHINE_ARCH, VAR_GLOBAL);
@


1.9
log
@Sync with NetBSD:
- Merge in FreeBSD and Lite2 changes.
- Fix bug where a non-archive target with a .a suffix would always
  be considered to be out of date, since it does not have a TOC.
- Fix NetBSD PR #2930: declare missing variable.
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.8 1996/09/02 16:04:13 briggs Exp $	*/
d52 1
a52 1
static char rcsid[] = "$OpenBSD: main.c,v 1.8 1996/09/02 16:04:13 briggs Exp $";
d175 1
a175 1
rearg:	while((c = getopt(argc, argv, OPTFLAGS)) != EOF) {
@


1.8
log
@Sync up with NetBSD:
(christos)
	Fix bug reported by Greg Hudson where leaf (source only) nodes were
	referenced only by their basename and not by their full pathname. This
	breaks when .PATH or MAKEOBJDIR are used. There might be Makefiles
	around that try to work around this bug by prepending ${.CURDIR} to
	the sources, and they should be found and fixed. Also a lot of the gunk
	in suff.c that was attempting to work around the same problem could be
	removed.
(christos)
	- Move -D flags from Makefile to config.h and explain what they do. Add
	  -Wall -Wno-unused to CFLAGS. Add new define SYSVVARSUB to enable SysV
	  style variable substitutions and enable them.
	- Add SunOS style command substitutions via SUNSHCMD
	- Fix core dump with '{variable = value'
(christos)
	Fix bug where make will always exit with 0, even when one or more
	parallel jobs failed. (Only affects parallel make code)
(christos)
	Protect __P from being multiply defined (for systems that already
	define it)
(christos) Add strdup() since ultrix is missing it.
	From Larry Schwimmer <rosebud@@cyclone.Stanford.EDU>
(christos) Add estrdup(), a checked version of strdup and use it.
(christos) Recognize SVR4 style long filename entries in archives.
(thorpej) Tidy up some RCS ids a bit.
@
text
@d1 2
a2 2
/*	$OpenBSD: main.c,v 1.7 1996/04/21 23:43:21 deraadt Exp $	*/
/*	$NetBSD: main.c,v 1.30 1996/08/13 16:42:08 christos Exp $	*/
d5 2
a6 2
 * Copyright (c) 1988, 1989, 1990 The Regents of the University of California.
 * Copyright (c) 1988, 1989 by Adam de Boor
d43 3
a45 3
char copyright[] =
"@@(#) Copyright (c) 1989 The Regents of the University of California.\n\
 All rights reserved.\n";
d50 1
a50 2
static char sccsid[] = "@@(#)main.c	5.25 (Berkeley) 4/1/91";
static char rcsid[] = "$NetBSD: main.c,v 1.26 1996/03/11 13:45:33 christos Exp $";
d52 1
a52 1
static char rcsid[] = "$OpenBSD: main.c,v 1.7 1996/04/21 23:43:21 deraadt Exp $";
d89 1
d91 1
d120 2
d137 4
a140 2
static Boolean		ReadMakefile();
static void		usage();
d171 1
a171 1
# define OPTFLAGS "BD:I:L:PSd:ef:ij:km:nqrst"
d173 1
a173 1
# define OPTFLAGS "BD:I:PSd:ef:ij:km:nqrst"
d187 6
d338 1
a338 1
			char *var = strdup(*argv);
d389 28
d442 1
a442 1
	char *p, *p1, *path, *pwd, *getenv(), *getwd();
a445 1
	struct utsname utsname;
d484 1
a484 1
		sa.st_dev == sb.st_dev) 
d498 2
d511 9
a519 3
	 * if the MAKEOBJDIR (or by default, the _PATH_OBJDIR) directory
	 * exists, change into it and build there.  Once things are
	 * initted, have to add the original directory to the search path,
d523 16
a538 12
	if (!(path = getenv("MAKEOBJDIR"))) {
		path = _PATH_OBJDIR;
		(void) sprintf(mdpath, "%s.%s", path, machine);
	}
	else
		(void) strncpy(mdpath, path, MAXPATHLEN + 1);
	
	if (stat(mdpath, &sb) == 0 && S_ISDIR(sb.st_mode)) {

		if (chdir(mdpath)) {
			(void)fprintf(stderr, "make warning: %s: %s.\n",
				      mdpath, strerror(errno));
a539 9
		}
		else {
			if (mdpath[0] != '/') {
				(void) sprintf(obpath, "%s/%s", curdir, mdpath);
				objdir = obpath;
			}
			else
				objdir = mdpath;
		}
d542 2
a543 18
		if (stat(path, &sb) == 0 && S_ISDIR(sb.st_mode)) {

			if (chdir(path)) {
				(void)fprintf(stderr, "make warning: %s: %s.\n",
					      path, strerror(errno));
				objdir = curdir;
			}
			else {
				if (path[0] != '/') {
					(void) sprintf(obpath, "%s/%s", curdir,
						       path);
					objdir = obpath;
				}
				else
					objdir = obpath;
			}
		}
		else
d551 2
d572 1
a572 1
    
d615 1
a615 1
    
d654 1
a654 1
			for (cp = start; *cp != '\0' && *cp != ':'; cp++) 
d688 2
a689 2
	} else if (!ReadMakefile("makefile"))
		(void)ReadMakefile("Makefile");
d691 1
a691 1
	(void)ReadMakefile(".depend");
d749 15
d774 1
a774 1
	if (!compatMake) {
d790 1
a790 1
	} else
d796 2
a797 1
    
d799 1
d832 2
a833 2
ReadMakefile(fname)
	char *fname;		/* makefile to read */
d835 1
d936 1
a936 1
	
d950 1
a950 1
	
d956 1
a956 1
	    if (cc > 0) 
d975 1
a975 1
	if (cc == 0) 
d1091 1
a1091 1
 *	None 
d1147 1
a1147 1
 *	abnormal exit. 
d1150 1
a1150 1
 *	None 
d1178 1
a1178 1
 * emalloc --
d1245 3
a1247 2
"usage: make [-eiknqrst] [-D variable] [-d flags] [-f makefile ]\n\
            [-I directory] [-j max_jobs] [-m directory] [variable=value]\n");
@


1.7
log
@sync to netbsd 960418
@
text
@d1 2
a2 2
/*	$OpenBSD: main.c,v 1.6 1996/03/27 19:32:36 niklas Exp $	*/
/*	$NetBSD: main.c,v 1.28 1996/03/31 21:30:05 christos Exp $	*/
d53 1
a53 1
static char rcsid[] = "$OpenBSD: main.c,v 1.6 1996/03/27 19:32:36 niklas Exp $";
d91 1
d341 1
a341 1
			(void)Lst_AtEnd(create, (ClientData)strdup(*argv));
d829 136
d1128 15
@


1.6
log
@From NetBSD: merge of 960317
@
text
@d1 2
a2 2
/*	$OpenBSD$	*/
/*	$NetBSD: main.c,v 1.26 1996/03/11 13:45:33 christos Exp $	*/
d53 1
a53 1
static char rcsid[] = "$OpenBSD$";
d984 1
a984 1
char *
d988 1
a988 1
	char *p;
d990 1
a990 1
	if ((p = (char *) malloc(len)) == NULL)
d993 14
@


1.5
log
@Implement an -m option used for replacing /usr/share/mk with a
custom search path, like $DESTDIR/usr/share/mk
@
text
@d1 2
a2 1
/*	$NetBSD: main.c,v 1.24 1996/02/04 22:20:49 christos Exp $	*/
d51 1
d53 1
a53 1
static char rcsid[] = "$NetBSD: main.c,v 1.24 1996/02/04 22:20:49 christos Exp $";
a90 1
#include <sys/resource.h>
d458 1
d464 3
@


1.4
log
@From NetBSD:
Support SVR4 style archives.
Fix pr/1421 (from Matthew Green) and pr/1997 (from Jeff Thieleke).
In ParseDoInclude(), make a temporary copy of the current file name
while searching for ""-type include files, since the current file name
might not be a writeable string.
@
text
@d164 1
a164 1
# define OPTFLAGS "BD:I:L:PSd:ef:ij:knqrst"
d166 1
a166 1
# define OPTFLAGS "BD:I:PSd:ef:ij:knqrst"
d277 5
d407 4
d613 19
d633 3
a635 3
	 * Read in the built-in rules first, followed by the specified makefile,
	 * if it was (makefile != (char *) NULL), or the default Makefile and
	 * makefile, in that order, if it wasn't.
d637 11
a647 2
	 if (!noBuiltins && !ReadMakefile(_PATH_DEFSYSMK))
		Fatal("make: no system rules (%s).", _PATH_DEFSYSMK);
d785 1
a785 1
	extern Lst parseIncPath, sysIncPath;
d1030 1
a1030 1
            [-I directory] [-j max_jobs] [variable=value]\n");
@


1.3
log
@Parse_DoVar() trashes string, so pass it a strdup()'d copy of *argv...
then kvm_getargv will show a nice unhacked argument list
@
text
@d1 1
a1 1
/*	$NetBSD: main.c,v 1.23 1995/11/22 17:40:14 christos Exp $	*/
d51 1
a51 1
static char rcsid[] = "$NetBSD: main.c,v 1.23 1995/11/22 17:40:14 christos Exp $";
d106 1
a106 1
#endif	DEFMAXLOCAL
@


1.2
log
@from christos@@netbsd:
Minor:
    - ${.PREFIX} should never contain a full pathname
    - Fixed gcc -Wall warnings
Major:
    - compatMake is now FALSE. This means that we are now running in
      full pmake mode:
          * rules on dependency lines can be executed in parallel and or
            out of sequence:

            foo: bar baz

            can fire the rule for baz before the rule for bar is fired.
            To enforce bar to be fired before baz, another rule needs to be
            added. [bar: baz]
          * adjacent shell commands in a target are now executed by a single
            invocation of the shell, not one invocation of the shell per line
      (compatMake can be turned off using the -B flag)
    - The -j flag now works... I.e. make -j 4 will fork up to four jobs in
      parallel when it can. The target name is printed before each burst
      of output caused by the target execution as '--- target ---', when j > 1
    - I have changed all the Makefiles so that they work with make -j N, and
      I have tested the whole netbsd by:
          'make -j 4 cleandir; make -j 4 depend; make -j 4; make -j 4 install'
    - I have not compiled or tested this version of make with -DREMOTE.
- Turn compat mode on by default. It gets turned off when the -j without
  the -B flag is specified. [Thus you can use -j 1 to turn it off].
- Fix malloc -> emalloc as Gordon noted.
Updates for POSIX/SVR4 compiling:
arch.c:          Don't require ranlib stuff. Not everybody has it.
dir.c:           SunOS-4 != Solaris; change #ifdef sun to #if sun && !__svr4__
job.c, compat.c: Don't use 'union wait', use int and the W*() macros.
main.c:          Check for uname() == -1; some unames return > 0...
util.c, job.c:   Add signal() with BSD semantics for svr4, don't use bsd
                 sigmask and friends.

from cgd@@netbsd:
pull in make.h.  (PAlloc() now uses emalloc(), which is prototyped in
make.h.  If the prototype is not in scope on the Alpha, I see lots
of "cast to pointer from integer of different size" warnings.)
@
text
@d319 6
a324 3
		if (Parse_IsVar(*argv))
			Parse_DoVar(*argv, VAR_CMD);
		else {
@


1.1
log
@Initial revision
@
text
@d1 1
a1 1
/*	$NetBSD: main.c,v 1.20 1995/09/27 18:42:21 jtc Exp $	*/
d51 1
a51 1
static char rcsid[] = "$NetBSD: main.c,v 1.20 1995/09/27 18:42:21 jtc Exp $";
d86 1
d89 1
a91 1
#include <signal.h>
d117 1
a117 1
int			maxJobs;	/* -J argument */
d160 1
d163 1
a163 1
#ifdef notyet
d166 1
a166 1
# define OPTFLAGS "D:I:d:ef:ij:knqrst"
a179 1
#ifdef notyet
d183 1
d189 1
a197 1
#endif
d265 1
d267 3
d304 7
d400 13
d445 1
a445 1
	    if (uname(&utsname)) {
d520 2
a522 3
	maxLocal = DEFMAXLOCAL;		/* Set default local max concurrency */
#ifdef notyet
	compatMake = FALSE;		/* No compat mode */
d524 1
a524 1
	compatMake = TRUE;		/* No compat mode */
d526 1
a685 4
/*
 * this was original amMake -- want to allow parallelism, so put this
 * back in, eventually.
 */
d959 20
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@
