head	1.9;
access;
symbols
	OPENBSD_6_2:1.9.0.16
	OPENBSD_6_2_BASE:1.9
	OPENBSD_6_1:1.9.0.14
	OPENBSD_6_1_BASE:1.9
	OPENBSD_6_0:1.9.0.10
	OPENBSD_6_0_BASE:1.9
	OPENBSD_5_9:1.9.0.6
	OPENBSD_5_9_BASE:1.9
	OPENBSD_5_8:1.9.0.8
	OPENBSD_5_8_BASE:1.9
	OPENBSD_5_7:1.9.0.2
	OPENBSD_5_7_BASE:1.9
	OPENBSD_5_6:1.9.0.4
	OPENBSD_5_6_BASE:1.9
	OPENBSD_5_5:1.6.0.18
	OPENBSD_5_5_BASE:1.6
	OPENBSD_5_4:1.6.0.14
	OPENBSD_5_4_BASE:1.6
	OPENBSD_5_3:1.6.0.12
	OPENBSD_5_3_BASE:1.6
	OPENBSD_5_2:1.6.0.10
	OPENBSD_5_2_BASE:1.6
	OPENBSD_5_1_BASE:1.6
	OPENBSD_5_1:1.6.0.8
	OPENBSD_5_0:1.6.0.6
	OPENBSD_5_0_BASE:1.6
	OPENBSD_4_9:1.6.0.4
	OPENBSD_4_9_BASE:1.6
	OPENBSD_4_8:1.6.0.2
	OPENBSD_4_8_BASE:1.6
	OPENBSD_4_7:1.4.0.8
	OPENBSD_4_7_BASE:1.4
	OPENBSD_4_6:1.4.0.10
	OPENBSD_4_6_BASE:1.4
	OPENBSD_4_5:1.4.0.6
	OPENBSD_4_5_BASE:1.4
	OPENBSD_4_4:1.4.0.4
	OPENBSD_4_4_BASE:1.4
	OPENBSD_4_3:1.4.0.2
	OPENBSD_4_3_BASE:1.4
	OPENBSD_4_2:1.1.0.26
	OPENBSD_4_2_BASE:1.1
	OPENBSD_4_1:1.1.0.24
	OPENBSD_4_1_BASE:1.1
	OPENBSD_4_0:1.1.0.22
	OPENBSD_4_0_BASE:1.1
	OPENBSD_3_9:1.1.0.20
	OPENBSD_3_9_BASE:1.1
	OPENBSD_3_8:1.1.0.18
	OPENBSD_3_8_BASE:1.1
	OPENBSD_3_7:1.1.0.16
	OPENBSD_3_7_BASE:1.1
	OPENBSD_3_6:1.1.0.14
	OPENBSD_3_6_BASE:1.1
	OPENBSD_3_5:1.1.0.12
	OPENBSD_3_5_BASE:1.1
	OPENBSD_3_4:1.1.0.10
	OPENBSD_3_4_BASE:1.1
	OPENBSD_3_3:1.1.0.8
	OPENBSD_3_3_BASE:1.1
	OPENBSD_3_2:1.1.0.6
	OPENBSD_3_2_BASE:1.1
	OPENBSD_3_1:1.1.0.4
	OPENBSD_3_1_BASE:1.1
	OPENBSD_3_0:1.1.0.2
	OPENBSD_3_0_BASE:1.1;
locks; strict;
comment	@ * @;


1.9
date	2014.05.18.08.08.50;	author espie;	state Exp;
branches;
next	1.8;

1.8
date	2014.05.12.19.11.19;	author espie;	state Exp;
branches;
next	1.7;

1.7
date	2014.04.22.08.26.31;	author espie;	state Exp;
branches;
next	1.6;

1.6
date	2010.07.19.19.46.44;	author espie;	state Exp;
branches;
next	1.5;

1.5
date	2010.07.19.19.30.37;	author espie;	state Exp;
branches;
next	1.4;

1.4
date	2007.12.01.15.14.34;	author espie;	state Exp;
branches;
next	1.3;

1.3
date	2007.09.17.10.12.35;	author espie;	state Exp;
branches;
next	1.2;

1.2
date	2007.09.17.09.44.20;	author espie;	state Exp;
branches;
next	1.1;

1.1
date	2001.06.12.22.44.21;	author espie;	state Exp;
branches;
next	;


desc
@@


1.9
log
@a bit more reallocarray (and kill ecalloc, which isn't used)
okay chl@@
@
text
@#ifndef GARRAY_H
#define GARRAY_H

/* $OpenBSD: garray.h,v 1.8 2014/05/12 19:11:19 espie Exp $ */
/* Growable array implementation */

/*
 * Copyright (c) 2001 Marc Espie.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE OPENBSD PROJECT AND CONTRIBUTORS
 * ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
 * A PARTICULAR PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE OPENBSD
 * PROJECT OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

struct growableArray {
	GNode 	     **a;	/* Only used for gnodes right now */
	unsigned int size;	/* Total max size */
	unsigned int n;		/* Current number of members */
};

#define AppendList2Array(l1, l2)				\
do {								\
    	LstNode ln;						\
	for (ln = Lst_First((l1)); ln != NULL; ln = Lst_Adv(ln))\
		Array_AtEnd((l2), Lst_Datum(ln));		\
} while (0)

#ifdef STATS_GROW
#define MAY_INCREASE_STATS	STAT_GROWARRAY++
#else
#define MAY_INCREASE_STATS
#endif

#define Array_AtEnd(l, gn) 				\
do { 							\
	if ((l)->n >= (l)->size) { 			\
		(l)->size *= 2; 			\
		(l)->a = ereallocarray((l)->a, 		\
		    (l)->size, sizeof(struct GNode *)); \
		MAY_INCREASE_STATS;			\
	} 						\
	(l)->a[(l)->n++] = (gn); 			\
} while (0)

#define Array_Push(l, gn)	Array_AtEnd(l, gn)

#define Array_Pop(l) \
	((l)->n > 0 ?  (l)->a[--(l)->n] : NULL)

#define Array_PushNew(l, gn) \
do {						\
	unsigned int i;				\
	for (i = 0; i < (l)->n; i++)		\
		if ((l)->a[i] == (gn))		\
		    break;			\
	if (i == (l)->n)			\
		Array_Push(l, gn);		\
} while (0)

#define Array_Find(l, func, v)			\
do {						\
	unsigned int i;				\
	for (i = 0; i < (l)->n; i++)		\
		if ((func)((l)->a[i], (v)) == 0)\
		    break;			\
} while (0)

#define Array_FindP(l, func, v)				\
do {							\
	unsigned int i;					\
	for (i = 0; i < (l)->n; i++)			\
		if ((func)(&((l)->a[i]), (v)) == 0)	\
		    break;				\
} while (0)

#define Array_ForEach(l, func, v)		\
do {						\
	unsigned int i;				\
	for (i = 0; i < (l)->n; i++)		\
		(func)((l)->a[i], (v));		\
} while (0)

#define Array_Every(l, func)			\
do {						\
	unsigned int i;				\
	for (i = 0; i < (l)->n; i++)		\
		(func)((l)->a[i]);		\
} while (0)

#define Array_Init(l, sz)				\
do {							\
	(l)->size = (sz);				\
	(l)->n = 0;					\
	(l)->a = ereallocarray(NULL, (l)->size, sizeof(GNode *));	\
} while (0)

#define Array_Reset(l)		\
do {				\
	(l)->n = 0;		\
} while (0)

#define Array_IsEmpty(l)	((l)->n == 0)

#endif
@


1.8
log
@adjust to ohash being in libutil now, and to the interface changes.
fix potential integer overflows in memory allocation (mostly for pedagogical
purposes, these are unlikely to overflow in practice)
move the rest of lst.lib stuff into its own directory.
@
text
@d4 1
a4 1
/* $OpenBSD: garray.h,v 1.7 2014/04/22 08:26:31 espie Exp $ */
d111 1
a111 1
	(l)->a = emalloc(sizeof(GNode *) * (l)->size);	\
@


1.7
log
@effectively use emult_realloc, okay guenther@@
@
text
@d4 1
a4 1
/* $OpenBSD: garray.h,v 1.6 2010/07/19 19:46:44 espie Exp $ */
d55 1
a55 1
		(l)->a = emult_realloc((l)->a, 		\
@


1.6
log
@Correct $OpenBSD$ stuff
@
text
@d4 1
a4 1
/* $OpenBSD: garray.h,v 1.5 2010/07/19 19:30:37 espie Exp $ */
d55 2
a56 2
		(l)->a = erealloc((l)->a, 		\
		    sizeof(struct GNode *) * (l)->size);\
@


1.5
log
@two small changes:
- allow variables in SysV modifiers, as requested by matthieu@@
(since recursive variables are an extension, this just extends the
extension)
- variation on :Q  called :QL (quote list), which does quote every character
EXCEPT for whitespace. e.g.,

toto:
	@@for i in ${VAR:QL} ...
@
text
@d4 1
a4 2
/* $OpenPackages$ */
/* $OpenBSD$ */
@


1.4
log
@I was sure I had committed this already, grrrr.
Anyways, switch to a growable array for job to do.
Allows us to randomize it.
fix manpage.
do not add delay if just one job to run.
@
text
@@


1.3
log
@reindent garray.h, add new function, to be used later
@
text
@d5 1
a5 1
/* $OpenBSD: garray.h,v 1.1 2001/06/12 22:44:21 espie Exp $ */
d61 15
@


1.2
log
@zap more spaces at end of line
@
text
@d52 9
a60 8
#define Array_AtEnd(l, gn) 						    \
do { 									    \
	if ((l)->n >= (l)->size) { 					    \
	    (l)->size *= 2; 					    	    \
	    (l)->a = erealloc((l)->a, sizeof(struct GNode *) * (l)->size);  \
	    MAY_INCREASE_STATS;						    \
	} 								    \
	(l)->a[(l)->n++] = (gn); 					    \
d69 8
@


1.1
log
@Replace the most used static lists in make by persistent growable arrays.
5% speed increase on a make build.
ok miod@@
@
text
@d5 1
a5 1
/* $OpenBSD$ */
d45 1
a45 1
		
@

