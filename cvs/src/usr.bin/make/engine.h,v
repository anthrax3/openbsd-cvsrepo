head	1.13;
access;
symbols
	OPENBSD_6_1_BASE:1.13
	OPENBSD_6_0:1.13.0.16
	OPENBSD_6_0_BASE:1.13
	OPENBSD_5_9:1.13.0.12
	OPENBSD_5_9_BASE:1.13
	OPENBSD_5_8:1.13.0.14
	OPENBSD_5_8_BASE:1.13
	OPENBSD_5_7:1.13.0.6
	OPENBSD_5_7_BASE:1.13
	OPENBSD_5_6:1.13.0.10
	OPENBSD_5_6_BASE:1.13
	OPENBSD_5_5:1.13.0.8
	OPENBSD_5_5_BASE:1.13
	OPENBSD_5_4:1.13.0.4
	OPENBSD_5_4_BASE:1.13
	OPENBSD_5_3:1.13.0.2
	OPENBSD_5_3_BASE:1.13
	OPENBSD_5_2:1.9.0.10
	OPENBSD_5_2_BASE:1.9
	OPENBSD_5_1_BASE:1.9
	OPENBSD_5_1:1.9.0.8
	OPENBSD_5_0:1.9.0.6
	OPENBSD_5_0_BASE:1.9
	OPENBSD_4_9:1.9.0.4
	OPENBSD_4_9_BASE:1.9
	OPENBSD_4_8:1.9.0.2
	OPENBSD_4_8_BASE:1.9
	OPENBSD_4_7:1.8.0.2
	OPENBSD_4_7_BASE:1.8
	OPENBSD_4_6:1.8.0.4
	OPENBSD_4_6_BASE:1.8
	OPENBSD_4_5:1.6.0.2
	OPENBSD_4_5_BASE:1.6
	OPENBSD_4_4:1.5.0.4
	OPENBSD_4_4_BASE:1.5
	OPENBSD_4_3:1.5.0.2
	OPENBSD_4_3_BASE:1.5;
locks; strict;
comment	@ * @;


1.13
date	2012.12.07.15.08.03;	author espie;	state Exp;
branches;
next	1.12;

1.12
date	2012.10.18.17.54.43;	author espie;	state Exp;
branches;
next	1.11;

1.11
date	2012.10.06.09.32.40;	author espie;	state Exp;
branches;
next	1.10;

1.10
date	2012.09.21.07.55.20;	author espie;	state Exp;
branches;
next	1.9;

1.9
date	2010.07.19.19.30.37;	author espie;	state Exp;
branches;
next	1.8;

1.8
date	2009.05.10.11.07.37;	author espie;	state Exp;
branches;
next	1.7;

1.7
date	2009.04.26.09.25.49;	author espie;	state Exp;
branches;
next	1.6;

1.6
date	2008.11.04.07.22.35;	author espie;	state Exp;
branches;
next	1.5;

1.5
date	2008.01.29.22.23.10;	author espie;	state Exp;
branches;
next	1.4;

1.4
date	2007.11.03.14.05.39;	author espie;	state Exp;
branches;
next	1.3;

1.3
date	2007.11.02.17.27.24;	author espie;	state Exp;
branches;
next	1.2;

1.2
date	2007.09.17.09.28.36;	author espie;	state Exp;
branches;
next	1.1;

1.1
date	2007.09.16.10.39.07;	author espie;	state Exp;
branches;
next	;


desc
@@


1.13
log
@document engine interface, remove internal function from visible interface
@
text
@#ifndef ENGINE_H
#define ENGINE_H
/*	$OpenBSD: engine.h,v 1.12 2012/10/18 17:54:43 espie Exp $	*/

/*
 * Copyright (c) 1988, 1989, 1990 The Regents of the University of California.
 * Copyright (c) 1988, 1989 by Adam de Boor
 * Copyright (c) 1989 by Berkeley Softworks
 * All rights reserved.
 *
 * This code is derived from software contributed to Berkeley by
 * Adam de Boor.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 *	from: @@(#)job.h 8.1 (Berkeley) 6/6/93
 */

/* ok = node_find_valid_commands(node);
 *	verify the integrity of a node's commands, pulling stuff off
 * 	.DEFAULT and other places if necessary.
 */
extern bool node_find_valid_commands(GNode *);

/* node_failure(gn); 
 *	indicate we don't know how to make gn.
 *	may continue with -k or if node was optional.
 */
extern void node_failure(GNode *);

/* Job_Touch(node);
 *	touch the path corresponding to a node or update the corresponding
 *	archive object.
 */
extern void Job_Touch(GNode *);

/* Make_TimeStamp(parent, child);
 *	ensure parent is at least as recent as child.
 */
extern void Make_TimeStamp(GNode *, GNode *);

/* Make_HandleUse(user_node, usee_node);
 *	let user_node inherit the commands from usee_node
 */
extern void Make_HandleUse(GNode *, GNode *);

/* old = Make_OODate(node);
 *	check if a given node is out-of-date.
 */
extern bool Make_OODate(GNode *);

/* Make_DoAllVar(node);
 *	fill all dynamic variables for a node.
 */
extern void Make_DoAllVar(GNode *);

/* status = run_gnode(gn):
 *	fully run all commands of a node for compat mode.
 */
extern int run_gnode(GNode *);

/*-
 * Job Table definitions.
 *
 * Each job has several things associated with it:
 *	1) The process id of the child shell
 *	2) The graph node describing the target being made by this job
 *	3) State associated to latest command run
 *	5) A word of flags which determine how the module handles errors,
 *	   echoing, etc. for the job
 *
 * The job "table" is kept as a linked Lst in 'jobs', with the number of
 * active jobs maintained in the 'nJobs' variable. At no time will this
 * exceed the value of 'maxJobs', initialized by the Job_Init function.
 *
 * When a job is finished, the Make_Update function is called on each of the
 * parents of the node which was just remade. This takes care of the upward
 * traversal of the dependency graph.
 */
struct Job_ {
	struct Job_ 	*next;		/* singly linked list */
	pid_t		pid;		/* Current command process id */
	Location	*location;
	int		exit_type;	/* last child exit or signal */
#define JOB_EXIT_OKAY 0
#define JOB_EXIT_BAD 1
#define JOB_SIGNALED 2
	int 		code;		/* exit status or signal code */
	LstNode		next_cmd;	/* Next command to run */
	char		*cmd;		/* Last command run */
	GNode		*node;	    	/* Target of this job */
	unsigned short	flags;
#define JOB_SILENT	0x001	/* Command was silent */
#define JOB_IS_EXPENSIVE 0x002
#define JOB_LOST	0x004	/* sent signal to non-existing pid ? */
#define JOB_ERRCHECK	0x008	/* command wants errcheck */
};

/* Continuation-style running commands for the parallel engine */

/* job_attach_node(job, node):
 *	attach a job to an allocated node, to be able to run commands
 */
extern void job_attach_node(Job *, GNode *);

/* finished = job_run_next(job):
 *	run next command for a job attached to a node.
 *	return true when job is finished.
 */
extern bool job_run_next(Job *);

/* job_handle_status(job, waitstatus):
 *	process a wait return value corresponding to a job, display
 *	messages and set job status accordingly.
 */
extern void job_handle_status(Job *, int);

#endif
@


1.12
log
@numerous error message fixes:
- do ^C checking differently: don't record sent signals, but when jobs
die, recheck whether we received/have pending a INT/QUIT/TERM/HUP signal.
Then don't display our process group "normally", instead group together
everything dying by signal/shell dying by signal (just give the target
names).

- make certain we always handle signals before dying from "other conditions"
- have the parser messages look more like normal messages
- remove double error messages from some parser errors
- make sure unclosed variables ARE errors when some modifiers are present

- keep track of the base directory we're run from, so that submakes can
get shortened directories...
- make sure the whole error message including silent command fits into a
reasonable length.

okay millert@@
@
text
@d3 1
a3 1
/*	$OpenBSD: engine.h,v 1.11 2012/10/06 09:32:40 espie Exp $	*/
d46 5
d52 1
d58 1
d63 1
d73 1
d79 3
a83 2
extern void run_command(const char *, bool);

d121 11
d134 4
a137 1
extern void job_attach_node(Job *, GNode *);
@


1.11
log
@- extra juice for debugging signal passing.  Note when we can't pass the
signal because the process already bought it (pgroups will do that to you)
(lots of discussion with Todd on that one)
- tweak error handling some more to make it less verbose when just one job
is running...
- show signal name in case of signal interrupts.
- zap OP_LIB, move that stuff to the location where we warn when we meet
that bug.

okay millert@@
@
text
@d3 1
a3 1
/*	$OpenBSD: engine.h,v 1.10 2012/09/21 07:55:20 espie Exp $	*/
a99 1
	int 		sent_signal;
@


1.10
log
@major overhaul of the way make handle jobs, inspired by dpb:
instead of forking a "job" per target, and having that job further fork
separate commands, have make maintain a list of jobs, indexed by pid
of currently running commands, and handle process termination
continuation-style.  This has lots of benefits:
- make is responsible for most printing, so we no longer need pipes nor
job control: make -j jobs see the tty.
- no more special-casing for jobs that don't really execute anything.
- unify code for make -jn and make -B, including signal handlers and
job waiting.  So make -n, make -q, +cmd now run commands in the same
way in all cases.
- unified more accurate error-reporting, as make knows precisely which
command failed. Commands are tagged with their lines, and we display failing
commands in silent mode.
- fine-grained "expensive" command handling (recursion limiter). Do it
per-command instead of per-target.

Moreover, signal response is now simpler, as we just block the signals
in a small critical sections, test for events, and sigpause (thanks a lot
to guenther@@ and millert@@), so running make is now almost always paused
without any busy-waiting.

Thanks to everyone who tested and gave input.
@
text
@d3 1
a3 1
/*	$OpenBSD: engine.h,v 1.9 2010/07/19 19:30:37 espie Exp $	*/
d100 1
d108 1
a109 1
#define JOB_MINE	0x010	/* XXX special job run by compat */
@


1.9
log
@two small changes:
- allow variables in SysV modifiers, as requested by matthieu@@
(since recursive variables are an extension, this just extends the
extension)
- variation on :Q  called :QL (quote list), which does quote every character
EXCEPT for whitespace. e.g.,

toto:
	@@for i in ${VAR:QL} ...
@
text
@d3 1
a3 1
/*	$OpenBSD$	*/
d41 1
a41 1
/* ok = Job_CheckCommands(node);
d45 2
a46 2
extern bool Job_CheckCommands(GNode *);
extern void job_failure(GNode *, void (*abortProc)(char *, ...));
a68 1
extern volatile sig_atomic_t got_signal;
d70 3
a72 3
extern volatile sig_atomic_t got_SIGINT, got_SIGHUP, got_SIGQUIT,
    got_SIGTERM, got_SIGTSTP, got_SIGTTOU, got_SIGTTIN, got_SIGWINCH,
    got_SIGCONT;
d74 38
a111 4
extern void SigHandler(int);
extern int run_gnode(GNode *);
extern void run_gnode_parallel(GNode *);
extern void expand_commands(GNode *);
d113 2
a114 3
extern void setup_engine(int);
typedef void (*psighandler)(int);
extern void setup_all_signals(psighandler, psighandler);
@


1.8
log
@simplify job handling a great deal: we don't care when jobs get
stopped/continued, as we won't try to start new jobs when other stuff
is stopped.

Redo signal handling so that most stuff can be done directly in the handler.
This requires blocking/unblocking signals while creating new jobs, and creating
a small list that only contains job's pids.

Switch to pgrps for jobs, since that works.

Add a clamping heuristic that avoids starting new jobs while an expensive job
is running (expensive meaning "very likely to be a recursive make run"). This
idea is mostly from Theo, through the implementation is mine.
@
text
@@


1.7
log
@move code around a bit, extract code from run_prepared_gnode
into a run_gnode_parallel. That simplifies the control flow of that routine
a bit, to allow for more tweaks in the parallel case.

okay kettenis@@, otto@@
@
text
@d72 2
a73 1
    got_SIGTERM, got_SIGTSTP, got_SIGTTOU, got_SIGTTIN, got_SIGWINCH;
d80 3
a82 1
extern void setup_engine(void);
@


1.6
log
@changes to get target equivalence to work better.
- add new file to create lists of equivalent targets (siblings)
- use that for sequential mode to have much better VPATH support
- separate checking commands from reporting error, for later.
- zap DieHorribly accordingly
- renumber existing flags
- signal_running_jobs() is simpler than pass_signal_to_jobs()
- new debug option -dn for name matching.

Similar code to handle parallel make is still missing.

thanks to Mark, Miod, Theo, Otto, Todd for tests and/or comments.
@
text
@d76 1
a76 1
extern int run_prepared_gnode(GNode *, int);
@


1.5
log
@A few changes:
- expand commands earlier, so that we can eventually scan them to take
smarter decisions.
- clean up the select() mask code and rename variables to sensible things.
- quite a few minor renames for readability
- erecalloc
- clean up wait status handling, do not try to rebuild wait status, but
instead parse it early and deal with the parsed code.

tested by lots of people, thanks guys!
@
text
@d41 1
a41 1
/* ok = Job_CheckCommands(node, abort);
d45 2
a46 1
extern bool Job_CheckCommands(GNode *, void (*abortProc)(char *, ...));
@


1.4
log
@simplify: Job_CheckCommands deals with silent and ignerr now, so there's
no need to duplicate that info at the job level since we can just use
the gn->type.
@
text
@d74 3
a76 1
extern int run_gnode(GNode *, int);
@


1.3
log
@Work done at p2k7.


This is a really big step towards getting parallel make to work.


Note that this is not yet complete. There are still a few `details' to
fix before this works 100%.  Specifically: sequential make (compat) and
parallel make don't use the same engine, and the parallel engine still
has a few limitations. For instance, some known issues:
- parallel make does not deal with .phony targets correctly all the time.
- some errors are deadly in parallel make mode.
- parallel make NEEDS way more sturdy correspondance of file system paths
and target names, since it often needs to match dependencies to targets
before the corresponding files exist.
- some local variables like $* get set in a bogus way in some cases.
- suffix handling has issues, especially related to the NULL suffix.
So, if you find stuff that does NOT yet work with parallel make, don't go
blindly try to fix the Makefile. It's very likely you might have stumbled
into a make bug. (unless you really, really, understand Makefiles, DON'T
GO CHANGING THEM YET).



Tested by lots of people, thanks go to miod@@, and robert@@ among other people.

Quick summary of what this does:

- remove `saving commands' extension (it's not really usable, nor used)
- move compat job runner and parallel interrupt handling into engine.c
- tweak the code so that both compat and parallel mode use the same job runner
and the same interrupt handling. Remove the other one.
- optimize job runner so that, in parallel mode, the last command does not
fork if we can avoid it (as it's already running in a sub shell).
- scrape all the code that dealt with creating shell scripts from commands.
- scrape all the code that dealt with recognizing special sequences in
command output to print/not print output.
- fix the parallel job pipe to not keep around file descriptors that are not
needed.
- replace the parallel job buffering with a nicer one, that deals with
non-blocking descriptors to try to agregate as much output from one job in
one go (greed) to unconfuse the users.
- create two pipes per job, so that stdout and stderr stay separate.
- make job token printing a debug option.
- always use the parallel job-runner to `execute' commands, even if we just
print them out.
- store list of errors encountered during parallel make running, and print them
on exit, so that we know what went wrong.
- add a dirty hack to targ.c to deal with paths produced by gccmakedep.
@
text
@d46 1
a46 1
/* Job_Touch(node, besilent);
d50 1
a50 1
extern void Job_Touch(GNode *, bool);
@


1.2
log
@kill extra spaces at end of line
@
text
@d3 1
a3 1
/*	$OpenBSD: engine.h,v 1.1 2007/09/16 10:39:07 espie Exp $	*/
d68 10
@


1.1
log
@first step towards sanity: take the functions common to parallel/not parallel
make outside of make.c and job.c, and create an engine.c file to hold them.
@
text
@d3 1
a3 1
/*	$OpenBSD: job.h,v 1.15 2004/04/07 13:11:36 espie Exp $	*/
d43 1
a43 1
 * 	.DEFAULT and other places if necessary. 
@

