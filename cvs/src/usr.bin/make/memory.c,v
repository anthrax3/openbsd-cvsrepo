head	1.11;
access;
symbols
	OPENBSD_6_2:1.11.0.12
	OPENBSD_6_2_BASE:1.11
	OPENBSD_6_1:1.11.0.14
	OPENBSD_6_1_BASE:1.11
	OPENBSD_6_0:1.11.0.10
	OPENBSD_6_0_BASE:1.11
	OPENBSD_5_9:1.11.0.6
	OPENBSD_5_9_BASE:1.11
	OPENBSD_5_8:1.11.0.8
	OPENBSD_5_8_BASE:1.11
	OPENBSD_5_7:1.11.0.2
	OPENBSD_5_7_BASE:1.11
	OPENBSD_5_6:1.11.0.4
	OPENBSD_5_6_BASE:1.11
	OPENBSD_5_5:1.9.0.6
	OPENBSD_5_5_BASE:1.9
	OPENBSD_5_4:1.9.0.2
	OPENBSD_5_4_BASE:1.9
	OPENBSD_5_3:1.8.0.12
	OPENBSD_5_3_BASE:1.8
	OPENBSD_5_2:1.8.0.10
	OPENBSD_5_2_BASE:1.8
	OPENBSD_5_1_BASE:1.8
	OPENBSD_5_1:1.8.0.8
	OPENBSD_5_0:1.8.0.6
	OPENBSD_5_0_BASE:1.8
	OPENBSD_4_9:1.8.0.4
	OPENBSD_4_9_BASE:1.8
	OPENBSD_4_8:1.8.0.2
	OPENBSD_4_8_BASE:1.8
	OPENBSD_4_7:1.6.0.6
	OPENBSD_4_7_BASE:1.6
	OPENBSD_4_6:1.6.0.8
	OPENBSD_4_6_BASE:1.6
	OPENBSD_4_5:1.6.0.4
	OPENBSD_4_5_BASE:1.6
	OPENBSD_4_4:1.6.0.2
	OPENBSD_4_4_BASE:1.6
	OPENBSD_4_3:1.5.0.2
	OPENBSD_4_3_BASE:1.5
	OPENBSD_4_2:1.3.0.14
	OPENBSD_4_2_BASE:1.3
	OPENBSD_4_1:1.3.0.12
	OPENBSD_4_1_BASE:1.3
	OPENBSD_4_0:1.3.0.10
	OPENBSD_4_0_BASE:1.3
	OPENBSD_3_9:1.3.0.8
	OPENBSD_3_9_BASE:1.3
	OPENBSD_3_8:1.3.0.6
	OPENBSD_3_8_BASE:1.3
	OPENBSD_3_7:1.3.0.4
	OPENBSD_3_7_BASE:1.3
	OPENBSD_3_6:1.3.0.2
	OPENBSD_3_6_BASE:1.3
	OPENBSD_3_5:1.2.0.4
	OPENBSD_3_5_BASE:1.2
	OPENBSD_3_4:1.2.0.2
	OPENBSD_3_4_BASE:1.2
	OPENBSD_3_3:1.1.0.8
	OPENBSD_3_3_BASE:1.1
	OPENBSD_3_2:1.1.0.6
	OPENBSD_3_2_BASE:1.1
	OPENBSD_3_1:1.1.0.4
	OPENBSD_3_1_BASE:1.1
	OPENBSD_3_0:1.1.0.2
	OPENBSD_3_0_BASE:1.1;
locks; strict;
comment	@ * @;


1.11
date	2014.05.18.08.08.50;	author espie;	state Exp;
branches;
next	1.10;

1.10
date	2014.05.12.19.11.19;	author espie;	state Exp;
branches;
next	1.9;

1.9
date	2013.04.23.14.32.53;	author espie;	state Exp;
branches;
next	1.8;

1.8
date	2010.07.19.19.46.44;	author espie;	state Exp;
branches;
next	1.7;

1.7
date	2010.07.19.19.30.37;	author espie;	state Exp;
branches;
next	1.6;

1.6
date	2008.03.24.18.03.53;	author espie;	state Exp;
branches;
next	1.5;

1.5
date	2008.01.29.22.23.10;	author espie;	state Exp;
branches;
next	1.4;

1.4
date	2007.09.16.10.43.53;	author espie;	state Exp;
branches;
next	1.3;

1.3
date	2004.04.07.13.11.36;	author espie;	state Exp;
branches;
next	1.2;

1.2
date	2003.06.03.02.56.12;	author millert;	state Exp;
branches;
next	1.1;

1.1
date	2001.05.23.12.34.47;	author espie;	state Exp;
branches;
next	;


desc
@@


1.11
log
@a bit more reallocarray (and kill ecalloc, which isn't used)
okay chl@@
@
text
@/* $OpenBSD: memory.c,v 1.10 2014/05/12 19:11:19 espie Exp $ */

/*
 * Copyright (c) 1988, 1989, 1990, 1993
 *	The Regents of the University of California.  All rights reserved.
 * Copyright (c) 1989 by Berkeley Softworks
 * All rights reserved.
 *
 * This code is derived from software contributed to Berkeley by
 * Adam de Boor.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */

#include <sys/types.h>
#include <sys/stat.h>
#include <errno.h>
#include <stddef.h>
#include <stdint.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <ohash.h>
#include "defines.h"
#include "memory.h"

static void enomem(size_t);
static void enocmem(size_t, size_t);

/*
 * emalloc --
 *	malloc, but die on error.
 */
void *
emalloc(size_t size)
{
	void *p;

	if ((p = malloc(size)) == NULL)
		enomem(size);
	return p;
}

/*
 * estrdup --
 *	strdup, but die on error.
 */
char *
estrdup(const char *str)
{
	char *p;
	size_t size;

	size = strlen(str) + 1;

	p = emalloc(size);
	memcpy(p, str, size);
	return p;
}

/*
 * erealloc --
 *	realloc, but die on error.
 */
void *
erealloc(void *ptr, size_t size)
{
	if ((ptr = realloc(ptr, size)) == NULL)
		enomem(size);
	return ptr;
}

void *
ereallocarray(void *ptr, size_t s1, size_t s2)
{
	if ((ptr = reallocarray(ptr, s1, s2)) == NULL)
		enocmem(s1, s2);
	return ptr;
}

/* Support routines for hash tables.  */
void *
hash_calloc(size_t n, size_t s, void *u UNUSED)
{
	void *p;

	if ((p = calloc(n, s)) == NULL)
		enocmem(n, s);
	return p;
}

void
hash_free(void *p, void *u UNUSED)
{
	free(p);
}

void *
element_alloc(size_t s, void *u UNUSED)
{
	return emalloc(s);
}



/*
 * enomem --
 *	die when out of memory.
 */
void
enomem(size_t size)
{
	fprintf(stderr, "make: %s (%zu)\n", strerror(errno), size);
	exit(2);
}

void
enocmem(size_t sz1, size_t sz2)
{
	fprintf(stderr, "make: %s (%zu * %zu)\n", strerror(errno), sz1, sz2);
	exit(2);
}
/*
 * esetenv --
 *	change environment, die on error.
 */
void
esetenv(const char *name, const char *value)
{
	if (setenv(name, value, 1) == 0)
	    return;

	fprintf(stderr, "make: setenv failed (%s)\n", strerror(errno));
	exit(2);
}


/*
 * enunlink --
 *	Remove a file carefully, avoiding directories.
 */
int
eunlink(const char *file)
{
	struct stat st;

	if (lstat(file, &st) == -1)
		return -1;

	if (S_ISDIR(st.st_mode)) {
		errno = EISDIR;
		return -1;
	}
	return unlink(file);
}

void
free_hash(struct ohash *h)
{
	void *e;
	unsigned int i;

	for (e = ohash_first(h, &i); e != NULL; e = ohash_next(h, &i))
		free(e);
	ohash_delete(h);
}

@


1.10
log
@adjust to ohash being in libutil now, and to the interface changes.
fix potential integer overflows in memory allocation (mostly for pedagogical
purposes, these are unlikely to overflow in practice)
move the rest of lst.lib stuff into its own directory.
@
text
@d1 1
a1 1
/* $OpenBSD: memory.c,v 1.9 2013/04/23 14:32:53 espie Exp $ */
a96 10
ecalloc(size_t s1, size_t s2)
{
	void *p;

	if ((p = calloc(s1, s2)) == NULL)
		enocmem(s1, s2);
	return p;
}

void *
d108 5
a112 1
	return ecalloc(n, s);
@


1.9
log
@remove TIMESTAMP abstraction layer, prodded by theo.
while there, clean up includes.
use strtoll for ar timestamps (pretty much unused in reality, more
standard conforming than anything)

use idea from Todd to adapt to time_t being 32 bits OR 64 bits
(pedantically correct: INT_MIN would work just fine up to 1910 or so...)

okay millert@@, gone thru a make build.
@
text
@d1 1
a1 1
/* $OpenBSD: memory.c,v 1.8 2010/07/19 19:46:44 espie Exp $ */
d107 1
a107 1
emult_realloc(void *ptr, size_t s1, size_t s2)
d109 1
a109 8
	size_t size;

	if (s1 && SIZE_MAX / s1 < s2) {
		errno = ENOMEM;
		enocmem(s1, s2);
	}
	size = s1 * s2;
	if ((ptr = realloc(ptr, size)) == NULL)
d116 1
a116 1
hash_alloc(size_t s, void *u UNUSED)
d118 1
a118 1
	return ecalloc(s, 1);
d122 1
a122 1
hash_free(void *p, size_t s UNUSED, void *u UNUSED)
@


1.8
log
@Correct $OpenBSD$ stuff
@
text
@d1 1
a1 1
/* $OpenBSD: memory.c,v 1.7 2010/07/19 19:30:37 espie Exp $ */
d40 2
a45 2
#include <stddef.h>
#include <stdint.h>
@


1.7
log
@two small changes:
- allow variables in SysV modifiers, as requested by matthieu@@
(since recursive variables are an extension, this just extends the
extension)
- variation on :Q  called :QL (quote list), which does quote every character
EXCEPT for whitespace. e.g.,

toto:
	@@for i in ${VAR:QL} ...
@
text
@d1 1
a1 2
/* $OpenPackages$ */
/* $OpenBSD$ */
@


1.6
log
@bye, bye recalloc. Bad interface for various reasons.
discussed with deraadt@@ and otto@@ and millert@@
@
text
@@


1.5
log
@A few changes:
- expand commands earlier, so that we can eventually scan them to take
smarter decisions.
- clean up the select() mask code and rename variables to sensible things.
- quite a few minor renames for readability
- erecalloc
- clean up wait status handling, do not try to rebuild wait status, but
instead parse it early and deal with the parsed code.

tested by lots of people, thanks guys!
@
text
@d108 1
a108 1
erecalloc(void *ptr, size_t s1, size_t s2)
d110 8
a117 1
	if ((ptr = recalloc(ptr, s1, s2)) == NULL)
@


1.4
log
@move free_ohash  function so that we can reuse it.
@
text
@d2 1
a2 1
/* $OpenBSD: memory.c,v 1.3 2004/04/07 13:11:36 espie Exp $ */
d52 1
d103 1
a103 1
		enomem(s1 * s2);
d107 8
d143 1
a143 1
	fprintf(stderr, "make: %s (%lu)\n", strerror(errno), (u_long)size);
d147 6
@


1.3
log
@ISO function declarations, trim a few comments, rename a few variables to
more explicit/more consistent names.

okay otto@@
@
text
@d2 1
a2 1
/* $OpenBSD: memory.c,v 1.2 2003/06/03 02:56:12 millert Exp $ */
d45 3
d170 11
@


1.2
log
@Remove the advertising clause in the UCB license which Berkeley
rescinded 22 July 1999.  Proofed by myself and Theo.
@
text
@d2 1
a2 1
/* $OpenBSD: memory.c,v 1.1 2001/05/23 12:34:47 espie Exp $ */
d55 1
a55 2
emalloc(len)
	size_t len;
d59 2
a60 2
	if ((p = malloc(len)) == NULL)
		enomem(len);
d69 1
a69 2
estrdup(str)
	const char *str;
d86 1
a86 3
erealloc(ptr, size)
	void *ptr;
	size_t size;
d94 1
a94 3
ecalloc(s1, s2)
	size_t s1;
	size_t s2;
d105 1
a105 3
hash_alloc(s, u)
	size_t s;
	void *u 	UNUSED;
d111 1
a111 4
hash_free(p, s, u)
	void *p;
	size_t s	UNUSED;
	void *u 	UNUSED;
d117 1
a117 3
element_alloc(s, u)
	size_t s;
	void *u 	UNUSED;
d129 1
a129 2
enomem(size)
	size_t size;
d140 1
a140 3
esetenv(name, value)
	const char *name;
	const char *value;
d155 1
a155 2
eunlink(file)
	const char *file;
@


1.1
log
@Mostly clean-up:
- cut up those huge include files into separate interfaces for all modules.
Put the interface documentation there, and not with the implementation.
- light-weight includes for needed concrete types (lst_t.h, timestamp_t.h).
- cut out some more logically separate parts: cmd_exec, varname, parsevar,
timestamp.
- put all error handling functions together, so that we will be able to
clean them up.
- more systematic naming: functioni  to handle interval, function to handle
string.
- put the init/end code apart to minimize coupling.
- kill weird types like ReturnStatus and Boolean. Use standard bool (with a
fallback for non-iso systems)
- better interface documentation for lots of subsystems.

As a result, make compilation goes somewhat faster (5%, even considering
the largish BSD copyrights to read). The corresponding preprocessed
source goes down from 1,5M to 1M.

A few minor code changes as well: Parse_DoVar is no longer destructive.
Parse_IsVar functionality is folded into Parse_DoVar (as it knows what an
assignment is), a few more interval handling functions. Avoid calling
XXX_End when they do nothing, just #define XXX_End   to nothing.

Parse_DoVar is slightly more general: it will handle compound assignments
as long as they make sense, e.g., VAR +!= cmd
will work.  As a side effect, VAR++=value now triggers an error
(two + in assignment).
- this stuff doesn't occur in portable Makefiles.
- writing VAR++ = value or VAR+ +=value  disambiguates it.
- this is a good thing, it uncovered a bug in bsd.port.mk.

Tested by naddy@@. Okayed millert@@. I'll handle the fallback if there is
any. This went through a full make build anyways, including isakmpd
(without mickey's custom binutils, as he didn't see fit to share it with me).
@
text
@d2 1
a2 1
/* $OpenBSD$ */
d21 1
a21 5
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
@

