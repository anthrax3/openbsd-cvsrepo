head	1.68;
access;
symbols
	OPENBSD_6_1:1.68.0.2
	OPENBSD_6_1_BASE:1.68
	OPENBSD_6_0:1.67.0.8
	OPENBSD_6_0_BASE:1.67
	OPENBSD_5_9:1.67.0.4
	OPENBSD_5_9_BASE:1.67
	OPENBSD_5_8:1.67.0.6
	OPENBSD_5_8_BASE:1.67
	OPENBSD_5_7:1.67.0.2
	OPENBSD_5_7_BASE:1.67
	OPENBSD_5_6:1.64.0.4
	OPENBSD_5_6_BASE:1.64
	OPENBSD_5_5:1.63.0.6
	OPENBSD_5_5_BASE:1.63
	OPENBSD_5_4:1.63.0.2
	OPENBSD_5_4_BASE:1.63
	OPENBSD_5_3:1.61.0.2
	OPENBSD_5_3_BASE:1.61
	OPENBSD_5_2:1.59.0.10
	OPENBSD_5_2_BASE:1.59
	OPENBSD_5_1_BASE:1.59
	OPENBSD_5_1:1.59.0.8
	OPENBSD_5_0:1.59.0.6
	OPENBSD_5_0_BASE:1.59
	OPENBSD_4_9:1.59.0.4
	OPENBSD_4_9_BASE:1.59
	OPENBSD_4_8:1.59.0.2
	OPENBSD_4_8_BASE:1.59
	OPENBSD_4_7:1.57.0.2
	OPENBSD_4_7_BASE:1.57
	OPENBSD_4_6:1.56.0.6
	OPENBSD_4_6_BASE:1.56
	OPENBSD_4_5:1.56.0.2
	OPENBSD_4_5_BASE:1.56
	OPENBSD_4_4:1.55.0.4
	OPENBSD_4_4_BASE:1.55
	OPENBSD_4_3:1.55.0.2
	OPENBSD_4_3_BASE:1.55
	OPENBSD_4_2:1.46.0.2
	OPENBSD_4_2_BASE:1.46
	OPENBSD_4_1:1.45.0.2
	OPENBSD_4_1_BASE:1.45
	OPENBSD_4_0:1.44.0.4
	OPENBSD_4_0_BASE:1.44
	OPENBSD_3_9:1.44.0.2
	OPENBSD_3_9_BASE:1.44
	OPENBSD_3_8:1.43.0.2
	OPENBSD_3_8_BASE:1.43
	OPENBSD_3_7:1.42.0.4
	OPENBSD_3_7_BASE:1.42
	OPENBSD_3_6:1.42.0.2
	OPENBSD_3_6_BASE:1.42
	OPENBSD_3_5:1.40.0.4
	OPENBSD_3_5_BASE:1.40
	OPENBSD_3_4:1.40.0.2
	OPENBSD_3_4_BASE:1.40
	OPENBSD_3_3:1.38.0.4
	OPENBSD_3_3_BASE:1.38
	OPENBSD_3_2:1.38.0.2
	OPENBSD_3_2_BASE:1.38
	OPENBSD_3_1:1.37.0.2
	OPENBSD_3_1_BASE:1.37
	OPENBSD_3_0:1.34.0.2
	OPENBSD_3_0_BASE:1.34
	OPENBSD_2_9_BASE:1.30
	OPENBSD_2_9:1.30.0.2
	OPENBSD_2_8:1.27.0.2
	OPENBSD_2_8_BASE:1.27
	OPENBSD_2_7:1.17.0.2
	OPENBSD_2_7_BASE:1.17
	OPENBSD_2_6:1.9.0.2
	OPENBSD_2_6_BASE:1.9
	OPENBSD_2_5:1.8.0.2
	OPENBSD_2_5_BASE:1.8
	OPENBSD_2_4:1.7.0.8
	OPENBSD_2_4_BASE:1.7
	OPENBSD_2_3:1.7.0.6
	OPENBSD_2_3_BASE:1.7
	OPENBSD_2_2:1.7.0.4
	OPENBSD_2_2_BASE:1.7
	OPENBSD_2_1:1.7.0.2
	OPENBSD_2_1_BASE:1.7
	OPENBSD_2_0:1.5.0.2
	OPENBSD_2_0_BASE:1.5
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.68
date	2016.10.21.16.12.38;	author espie;	state Exp;
branches;
next	1.67;
commitid	aLVdeKrJ0t5upS3l;

1.67
date	2015.01.23.22.35.57;	author espie;	state Exp;
branches;
next	1.66;
commitid	WtGGWUPWONvkhNGN;

1.66
date	2015.01.23.13.18.40;	author espie;	state Exp;
branches;
next	1.65;
commitid	iXa5WmoY9RgeqDsn;

1.65
date	2015.01.16.15.36.29;	author deraadt;	state Exp;
branches;
next	1.64;
commitid	UtvDri2GsrO6f1f5;

1.64
date	2014.05.12.19.11.19;	author espie;	state Exp;
branches;
next	1.63;

1.63
date	2013.05.22.12.14.08;	author espie;	state Exp;
branches;
next	1.62;

1.62
date	2013.04.23.14.32.53;	author espie;	state Exp;
branches;
next	1.61;

1.61
date	2012.12.07.07.15.31;	author espie;	state Exp;
branches;
next	1.60;

1.60
date	2012.10.02.10.29.30;	author espie;	state Exp;
branches;
next	1.59;

1.59
date	2010.07.19.19.46.44;	author espie;	state Exp;
branches;
next	1.58;

1.58
date	2010.07.19.19.30.37;	author espie;	state Exp;
branches;
next	1.57;

1.57
date	2009.08.16.09.53.43;	author espie;	state Exp;
branches;
next	1.56;

1.56
date	2008.11.04.07.22.35;	author espie;	state Exp;
branches;
next	1.55;

1.55
date	2007.09.17.12.17.27;	author espie;	state Exp;
branches;
next	1.54;

1.54
date	2007.09.17.12.04.29;	author espie;	state Exp;
branches;
next	1.53;

1.53
date	2007.09.17.09.28.36;	author espie;	state Exp;
branches;
next	1.52;

1.52
date	2007.09.16.14.29.33;	author espie;	state Exp;
branches;
next	1.51;

1.51
date	2007.09.16.12.30.35;	author espie;	state Exp;
branches;
next	1.50;

1.50
date	2007.09.16.12.19.15;	author espie;	state Exp;
branches;
next	1.49;

1.49
date	2007.09.16.12.09.36;	author espie;	state Exp;
branches;
next	1.48;

1.48
date	2007.09.16.10.43.53;	author espie;	state Exp;
branches;
next	1.47;

1.47
date	2007.09.16.10.14.26;	author espie;	state Exp;
branches;
next	1.46;

1.46
date	2007.07.24.21.09.07;	author espie;	state Exp;
branches;
next	1.45;

1.45
date	2007.01.18.17.49.51;	author espie;	state Exp;
branches;
next	1.44;

1.44
date	2006.01.20.23.10.19;	author espie;	state Exp;
branches;
next	1.43;

1.43
date	2005.06.26.15.19.12;	author mickey;	state Exp;
branches;
next	1.42;

1.42
date	2004.06.22.19.58.20;	author espie;	state Exp;
branches;
next	1.41;

1.41
date	2004.04.07.13.11.35;	author espie;	state Exp;
branches;
next	1.40;

1.40
date	2003.06.03.02.56.11;	author millert;	state Exp;
branches;
next	1.39;

1.39
date	2003.04.21.23.10.52;	author espie;	state Exp;
branches;
next	1.38;

1.38
date	2002.05.27.03.14.21;	author deraadt;	state Exp;
branches;
next	1.37;

1.37
date	2001.11.11.12.35.02;	author espie;	state Exp;
branches;
next	1.36;

1.36
date	2001.11.11.06.02.06;	author deraadt;	state Exp;
branches;
next	1.35;

1.35
date	2001.11.11.01.19.23;	author espie;	state Exp;
branches;
next	1.34;

1.34
date	2001.05.29.12.53.39;	author espie;	state Exp;
branches;
next	1.33;

1.33
date	2001.05.27.08.34.10;	author espie;	state Exp;
branches;
next	1.32;

1.32
date	2001.05.23.12.34.42;	author espie;	state Exp;
branches;
next	1.31;

1.31
date	2001.05.03.13.41.03;	author espie;	state Exp;
branches;
next	1.30;

1.30
date	2001.03.02.16.57.26;	author espie;	state Exp;
branches;
next	1.29;

1.29
date	2000.11.24.14.36.33;	author espie;	state Exp;
branches;
next	1.28;

1.28
date	2000.11.24.14.27.19;	author espie;	state Exp;
branches;
next	1.27;

1.27
date	2000.09.14.13.52.41;	author espie;	state Exp;
branches;
next	1.26;

1.26
date	2000.09.14.13.46.44;	author espie;	state Exp;
branches;
next	1.25;

1.25
date	2000.09.14.13.43.30;	author espie;	state Exp;
branches;
next	1.24;

1.24
date	2000.09.14.13.32.06;	author espie;	state Exp;
branches;
next	1.23;

1.23
date	2000.06.23.16.41.52;	author espie;	state Exp;
branches;
next	1.22;

1.22
date	2000.06.23.16.15.49;	author espie;	state Exp;
branches;
next	1.21;

1.21
date	2000.06.17.14.40.27;	author espie;	state Exp;
branches;
next	1.20;

1.20
date	2000.06.17.14.38.14;	author espie;	state Exp;
branches;
next	1.19;

1.19
date	2000.06.10.01.41.05;	author espie;	state Exp;
branches;
next	1.18;

1.18
date	2000.06.10.01.32.22;	author espie;	state Exp;
branches;
next	1.17;

1.17
date	2000.03.26.16.21.32;	author espie;	state Exp;
branches;
next	1.16;

1.16
date	2000.02.02.13.47.47;	author espie;	state Exp;
branches;
next	1.15;

1.15
date	2000.01.25.20.52.15;	author espie;	state Exp;
branches;
next	1.14;

1.14
date	99.12.19.00.04.25;	author espie;	state Exp;
branches;
next	1.13;

1.13
date	99.12.18.21.58.07;	author espie;	state Exp;
branches;
next	1.12;

1.12
date	99.12.18.21.56.07;	author espie;	state Exp;
branches;
next	1.11;

1.11
date	99.12.18.21.53.32;	author espie;	state Exp;
branches;
next	1.10;

1.10
date	99.12.18.02.11.26;	author espie;	state Exp;
branches;
next	1.9;

1.9
date	99.10.05.22.06.23;	author espie;	state Exp;
branches;
next	1.8;

1.8
date	98.12.05.00.06.27;	author espie;	state Exp;
branches;
next	1.7;

1.7
date	97.04.01.07.28.11;	author millert;	state Exp;
branches;
next	1.6;

1.6
date	96.11.30.21.08.53;	author millert;	state Exp;
branches;
next	1.5;

1.5
date	96.09.02.16.04.09;	author briggs;	state Exp;
branches;
next	1.4;

1.4
date	96.06.26.05.36.29;	author deraadt;	state Exp;
branches;
next	1.3;

1.3
date	96.02.22.22.24.46;	author niklas;	state Exp;
branches;
next	1.2;

1.2
date	95.12.14.03.23.29;	author deraadt;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.45.41;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.45.41;	author deraadt;	state Exp;
branches;
next	;


desc
@@


1.68
log
@small obvious cleanups:
- remove a lot of unnecessary casts
- zap extra param that's no longer needed
- add proper prototype and make function static

okay natano@@
@
text
@/*	$OpenBSD: dir.c,v 1.67 2015/01/23 22:35:57 espie Exp $ */
/*	$NetBSD: dir.c,v 1.14 1997/03/29 16:51:26 christos Exp $	*/

/*
 * Copyright (c) 1999 Marc Espie.
 *
 * Extensive code changes for the OpenBSD project.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE OPENBSD PROJECT AND CONTRIBUTORS
 * ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
 * A PARTICULAR PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE OPENBSD
 * PROJECT OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
/*
 * Copyright (c) 1988, 1989, 1990 The Regents of the University of California.
 * Copyright (c) 1988, 1989 by Adam de Boor
 * Copyright (c) 1989 by Berkeley Softworks
 * All rights reserved.
 *
 * This code is derived from software contributed to Berkeley by
 * Adam de Boor.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */

#include <sys/stat.h>
#include <dirent.h>
#include <limits.h>
#include <stddef.h>
#include <stdint.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <ohash.h>
#include "config.h"
#include "defines.h"
#include "dir.h"
#include "lst.h"
#include "memory.h"
#include "buf.h"
#include "gnode.h"
#include "arch.h"
#include "targ.h"
#include "error.h"
#include "str.h"
#include "timestamp.h"


/*	A search path consists of a Lst of PathEntry structures. A Path
 *	structure has in it the name of the directory and a hash table of all
 *	the files in the directory. This is used to cut down on the number of
 *	system calls necessary to find implicit dependents and their like.
 *	Since these searches are made before any actions are taken, we need not
 *	worry about the directory changing due to creation commands. If this
 *	hampers the style of some makefiles, they must be changed.
 *
 *	A list of all previously-read directories is kept in the
 *	knownDirectories cache.
 *
 *	The need for the caching of whole directories is brought about by
 *	the multi-level transformation code in suff.c, which tends to search
 *	for far more files than regular make does. In the initial
 *	implementation, the amount of time spent performing "stat" calls was
 *	truly astronomical. The problem with hashing at the start is,
 *	of course, that pmake doesn't then detect changes to these directories
 *	during the course of the make. Three possibilities suggest themselves:
 *
 *	    1) just use stat to test for a file's existence. As mentioned
 *	       above, this is very inefficient due to the number of checks
 *	       engendered by the multi-level transformation code.
 *	    2) use readdir() and company to search the directories, keeping
 *	       them open between checks. I have tried this and while it
 *	       didn't slow down the process too much, it could severely
 *	       affect the amount of parallelism available as each directory
 *	       open would take another file descriptor out of play for
 *	       handling I/O for another job. Given that it is only recently
 *	       that UNIX OS's have taken to allowing more than 20 or 32
 *	       file descriptors for a process, this doesn't seem acceptable
 *	       to me.
 *	    3) record the mtime of the directory in the PathEntry structure and
 *	       verify the directory hasn't changed since the contents were
 *	       hashed. This will catch the creation or deletion of files,
 *	       but not the updating of files. However, since it is the
 *	       creation and deletion that is the problem, this could be
 *	       a good thing to do. Unfortunately, if the directory (say ".")
 *	       were fairly large and changed fairly frequently, the constant
 *	       rehashing could seriously degrade performance. It might be
 *	       good in such cases to keep track of the number of rehashes
 *	       and if the number goes over a (small) limit, resort to using
 *	       stat in its place.
 *
 *	An additional thing to consider is that pmake is used primarily
 *	to create C programs and until recently pcc-based compilers refused
 *	to allow you to specify where the resulting object file should be
 *	placed. This forced all objects to be created in the current
 *	directory. This isn't meant as a full excuse, just an explanation of
 *	some of the reasons for the caching used here.
 *
 *	One more note: the location of a target's file is only performed
 *	on the downward traversal of the graph and then only for terminal
 *	nodes in the graph. This could be construed as wrong in some cases,
 *	but prevents inadvertent modification of files when the "installed"
 *	directory for a file is provided in the search path.
 *
 *	Another data structure maintained by this module is an mtime
 *	cache used when the searching of cached directories fails to find
 *	a file. In the past, Dir_FindFile would simply perform an access()
 *	call in such a case to determine if the file could be found using
 *	just the name given. When this hit, however, all that was gained
 *	was the knowledge that the file existed. Given that an access() is
 *	essentially a stat() without the copyout() call, and that the same
 *	filesystem overhead would have to be incurred in Dir_MTime, it made
 *	sense to replace the access() with a stat() and record the mtime
 *	in a cache for when Dir_MTime was actually called.  */


/* several data structures exist to handle caching of directory stuff.
 *
 * There is a global hash of directory names (knownDirectories), and each
 * read directory is kept there as one PathEntry instance. Such a structure
 * only contains the file names.
 *
 * There is a global hash of timestamps (modification times), so care must
 * be taken of giving the right file names to that structure.
 *
 * XXX A set of similar structure should exist at the Target level to properly
 * take care of VPATH issues.
 */


/* each directory is cached into a PathEntry structure. */
struct PathEntry {
	int refCount;		/* ref-counted, can participate to
				 * several paths */
	struct ohash files;	/* hash of name of files in the directory */
	char name[1];		/* directory name */
};

/* PathEntry kept on knownDirectories */
static struct ohash_info dir_info = {
	offsetof(struct PathEntry, name), NULL, hash_calloc, hash_free,
	element_alloc
};

static struct ohash   knownDirectories;	/* cache all open directories */


/* file names kept in a path entry */
static struct ohash_info file_info = {
	0, NULL, hash_calloc, hash_free, element_alloc
};


/* Global structure used to cache mtimes.  XXX We don't cache an mtime
 * before a caller actually looks up for the given time, because of the
 * possibility a caller might update the file and invalidate the cache
 * entry, and we don't look up in this cache except as a last resort.
 */
struct file_stamp {
	struct timespec mtime;		/* time stamp... */
	char name[1];			/* ...for that file.  */
};

static struct ohash mtimes;


static struct ohash_info stamp_info = {
	offsetof(struct file_stamp, name), NULL, hash_calloc, hash_free,
	element_alloc
};



static LIST   theDefaultPath;		/* main search path */
Lst	      defaultPath= &theDefaultPath;
struct PathEntry *dot; 			/* contents of current directory */



/* add_file(path, name): add a file name to a path hash structure. */
static void add_file(struct PathEntry *, const char *);
/* n = find_file_hashi(p, name, end, hv): retrieve name in a path hash
 * 	structure. */
static char *find_file_hashi(struct PathEntry *, const char *, const char *,
    uint32_t);

/* stamp = find_stampi(name, end): look for (name, end) in the global
 *	cache. */
static struct file_stamp *find_stampi(const char *, const char *);
/* record_stamp(name, timestamp): record timestamp for name in the global
 * 	cache. */
static void record_stamp(const char *, struct timespec);

static bool read_directory(struct PathEntry *);
/* p = DirReaddiri(name, end): read an actual directory, caching results
 * 	as we go.  */
static struct PathEntry *create_PathEntry(const char *, const char *);
/* Debugging: show a dir name in a path. */
static void DirPrintDir(void *);

/***
 *** timestamp handling
 ***/

static void
record_stamp(const char *file, struct timespec t)
{
	unsigned int slot;
	const char *end = NULL;
	struct file_stamp *n;

	slot = ohash_qlookupi(&mtimes, file, &end);
	n = ohash_find(&mtimes, slot);
	if (n)
		n->mtime = t;
	else {
		n = ohash_create_entry(&stamp_info, file, &end);
		n->mtime = t;
		ohash_insert(&mtimes, slot, n);
	}
}

static struct file_stamp *
find_stampi(const char *file, const char *efile)
{
	return ohash_find(&mtimes, ohash_qlookupi(&mtimes, file, &efile));
}

/***
 *** PathEntry handling
 ***/

static void
add_file(struct PathEntry *p, const char *file)
{
	unsigned int	slot;
	const char	*end = NULL;
	char		*n;
	struct ohash 	*h = &p->files;

	slot = ohash_qlookupi(h, file, &end);
	n = ohash_find(h, slot);
	if (n == NULL) {
		n = ohash_create_entry(&file_info, file, &end);
		ohash_insert(h, slot, n);
	}
}

static char *
find_file_hashi(struct PathEntry *p, const char *file, const char *efile,
    uint32_t hv)
{
	struct ohash 	*h = &p->files;

	return ohash_find(h, ohash_lookup_interval(h, file, efile, hv));
}

static bool
read_directory(struct PathEntry *p)
{
	DIR *d;
	struct dirent *dp;

	if (DEBUG(DIR)) {
		printf("Caching %s...", p->name);
		fflush(stdout);
	}

	if ((d = opendir(p->name)) == NULL)
		return false;

	ohash_init(&p->files, 4, &file_info);

	while ((dp = readdir(d)) != NULL) {
		if (dp->d_name[0] == '.' &&
		    (dp->d_name[1] == '\0' ||
		    (dp->d_name[1] == '.' && dp->d_name[2] == '\0')))
			continue;
		add_file(p, dp->d_name);
	}
	(void)closedir(d);
	if (DEBUG(DIR))
		printf("done\n");
	return true;
}

/* Read a directory, either from the disk, or from the cache.  */
static struct PathEntry *
create_PathEntry(const char *name, const char *ename)
{
	struct PathEntry *p;
	unsigned int slot;

	slot = ohash_qlookupi(&knownDirectories, name, &ename);
	p = ohash_find(&knownDirectories, slot);

	if (p == NULL) {
		p = ohash_create_entry(&dir_info, name, &ename);
		p->refCount = 0;
		if (!read_directory(p)) {
			free(p);
			return NULL;
		}
		ohash_insert(&knownDirectories, slot, p);
	}
	p->refCount++;
	return p;
}

char *
PathEntry_name(struct PathEntry *p)
{
	return p->name;
}

/* Side Effects: cache the current directory */
void
Dir_Init(void)
{
	char *dotname = ".";

	Static_Lst_Init(defaultPath);
	ohash_init(&knownDirectories, 4, &dir_info);
	ohash_init(&mtimes, 4, &stamp_info);


	dot = create_PathEntry(dotname, dotname+1);

	if (!dot)
		Fatal("Can't access current directory");
}

/*-
 *-----------------------------------------------------------------------
 * Dir_MatchFilesi --
 *	Given a pattern and a PathEntry structure, see if any files
 *	match the pattern and add their names to the 'expansions' list if
 *	any do. This is incomplete -- it doesn't take care of patterns like
 *	src / *src / *.c properly (just *.c on any of the directories), but it
 *	will do for now.
 *-----------------------------------------------------------------------
 */
void
Dir_MatchFilesi(const char *word, const char *eword, struct PathEntry *p,
    Lst expansions)
{
	unsigned int search; 	/* Index into the directory's table */
	const char *entry; 	/* Current entry in the table */

	for (entry = ohash_first(&p->files, &search); entry != NULL;
	     entry = ohash_next(&p->files, &search)) {
		/* See if the file matches the given pattern. We follow the UNIX
		 * convention that dot files will only be found if the pattern
		 * begins with a dot (the hashing scheme doesn't hash . or ..,
		 * so they won't match `.*'.  */
		if (*word != '.' && *entry == '.')
			continue;
		if (Str_Matchi(entry, strchr(entry, '\0'), word, eword))
			Lst_AtEnd(expansions,
			    p == dot  ? estrdup(entry) :
			    Str_concat(p->name, entry, '/'));
	}
}

/*-
 * Side Effects:
 *	If the file is found in a directory which is not on the path
 *	already (either 'name' is absolute or it is a relative path
 *	[ dir1/.../dirn/file ] which exists below one of the directories
 *	already on the search path), its directory is added to the end
 *	of the path on the assumption that there will be more files in
 *	that directory later on.
 */
char *
Dir_FindFileComplexi(const char *name, const char *ename, Lst path,
    bool checkCurdirFirst)
{
	struct PathEntry *p;	/* current path member */
	char *p1;	/* pointer into p->name */
	const char *p2;	/* pointer into name */
	LstNode ln;	/* a list element */
	char *file;	/* the current filename to check */
	char *temp;	/* index into file */
	const char *basename;
	bool hasSlash;
	struct stat stb;/* Buffer for stat, if necessary */
	struct file_stamp *entry;
			/* Entry for mtimes table */
	uint32_t hv;	/* hash value for last component in file name */
	char *q;	/* Str_dupi(name, ename) */

	/* Find the final component of the name and note whether name has a
	 * slash in it */
	basename = Str_rchri(name, ename, '/');
	if (basename) {
		hasSlash = true;
		basename++;
	} else {
		hasSlash = false;
		basename = name;
	}

	hv = ohash_interval(basename, &ename);

	if (DEBUG(DIR))
		printf("Searching for %s...", name);
	/* Unless checkCurDirFirst is false, we always look for
	 * the file in the current directory before anywhere else
	 * and we always return exactly what the caller specified. */
	if (checkCurdirFirst &&
	    (!hasSlash || (basename - name == 2 && *name == '.')) &&
	    find_file_hashi(dot, basename, ename, hv) != NULL) {
		if (DEBUG(DIR))
			printf("in '.'\n");
		return Str_dupi(name, ename);
	}

	/* Then, we look through all the directories on path, seeking one
	 * containing the final component of name and whose final
	 * component(s) match name's initial component(s).
	 * If found, we concatenate the directory name and the
	 * final component and return the resulting string.  */
	for (ln = Lst_First(path); ln != NULL; ln = Lst_Adv(ln)) {
		p = Lst_Datum(ln);
		if (DEBUG(DIR))
			printf("%s...", p->name);
		if (find_file_hashi(p, basename, ename, hv) != NULL) {
			if (DEBUG(DIR))
				printf("here...");
			if (hasSlash) {
				/* If the name had a slash, its initial
				 * components and p's final components must
				 * match. This is false if a mismatch is
				 * encountered before all of the initial
				 * components have been checked (p2 > name at
				 * the end of the loop), or we matched only
				 * part of one of the components of p along
				 * with all the rest of them (*p1 != '/').  */
				p1 = p->name + strlen(p->name) - 1;
				p2 = basename - 2;
				while (p2 >= name && p1 >= p->name &&
				    *p1 == *p2) {
					p1--;
					p2--;
				}
				if (p2 >= name ||
				    (p1 >= p->name && *p1 != '/')) {
					if (DEBUG(DIR))
						printf("component mismatch -- continuing...");
					continue;
				}
			}
			file = Str_concati(p->name, strchr(p->name, '\0'), basename,
			    ename, '/');
			if (DEBUG(DIR))
				printf("returning %s\n", file);
			return file;
		} else if (hasSlash) {
			/* If the file has a leading path component and that
			 * component exactly matches the entire name of the
			 * current search directory, we assume the file
			 * doesn't exist and return NULL.  */
			for (p1 = p->name, p2 = name; *p1 && *p1 == *p2;
			    p1++, p2++)
				continue;
			if (*p1 == '\0' && p2 == basename - 1) {
				if (DEBUG(DIR))
					printf("has to be here but isn't -- returning NULL\n");
				return NULL;
			}
		}
	}

	/* We didn't find the file on any existing member of the path.
	 * If the name doesn't contain a slash, end of story.
	 * If it does contain a slash, however, it could be in a subdirectory
	 * of one of the members of the search path. (eg., for path=/usr/include
	 * and name=sys/types.h, the above search fails to turn up types.h
	 * in /usr/include, even though /usr/include/sys/types.h exists).
	 *
	 * We only perform this look-up for non-absolute file names.
	 *
	 * Whenever we score a hit, we assume there will be more matches from
	 * that directory, and append all but the last component of the
	 * resulting name onto the search path. */
	if (!hasSlash) {
		if (DEBUG(DIR))
			printf("failed.\n");
		return NULL;
	}

	if (*name != '/') {
		bool checkedDot = false;

		if (DEBUG(DIR))
			printf("failed. Trying subdirectories...");
		for (ln = Lst_First(path); ln != NULL; ln = Lst_Adv(ln)) {
			p = Lst_Datum(ln);
			if (p != dot)
				file = Str_concati(p->name,
				    strchr(p->name, '\0'), name, ename, '/');
			else {
				/* Checking in dot -- DON'T put a leading
				* ./ on the thing.  */
				file = Str_dupi(name, ename);
				checkedDot = true;
			}
			if (DEBUG(DIR))
				printf("checking %s...", file);

			if (stat(file, &stb) == 0) {
				struct timespec mtime;

				ts_set_from_stat(stb, mtime);
				if (DEBUG(DIR))
					printf("got it.\n");

				/* We've found another directory to search.
				 * We know there is a slash in 'file'. We
				 * call Dir_AddDiri to add the new directory
				 * onto the existing search path. Once that's
				 * done, we return the file name, knowing that
				 * should a file in this directory ever be
				 * referenced again in such a manner, we will
				 * find it without having to do numerous
				 * access calls.  */
				temp = strrchr(file, '/');
				Dir_AddDiri(path, file, temp);

				/* Save the modification time so if it's
				* needed, we don't have to fetch it again.  */
				if (DEBUG(DIR))
					printf("Caching %s for %s\n",
					    time_to_string(&mtime), file);
				record_stamp(file, mtime);
				return file;
			} else
				free(file);
		}

		if (DEBUG(DIR))
			printf("failed. ");

		if (checkedDot) {
			/* Already checked by the given name, since . was in
			 * the path, so no point in proceeding...  */
			if (DEBUG(DIR))
				printf("Checked . already, returning NULL\n");
			return NULL;
		}
	}

	/* Didn't find it that way, either. Last resort: look for the file
	 * in the global mtime cache, then on the disk.
	 * If this doesn't succeed, we finally return a NULL pointer.
	 *
	 * We cannot add this directory onto the search path because
	 * of this amusing case:
	 * $(INSTALLDIR)/$(FILE): $(FILE)
	 *
	 * $(FILE) exists in $(INSTALLDIR) but not in the current one.
	 * When searching for $(FILE), we will find it in $(INSTALLDIR)
	 * b/c we added it here. This is not good...  */
	q = Str_dupi(name, ename);
	if (DEBUG(DIR))
		printf("Looking for \"%s\"...", q);

	entry = find_stampi(name, ename);
	if (entry != NULL) {
		if (DEBUG(DIR))
			printf("got it (in mtime cache)\n");
		return q;
	} else if (stat(q, &stb) == 0) {
		struct timespec mtime;

		ts_set_from_stat(stb, mtime);
		if (DEBUG(DIR))
			printf("Caching %s for %s\n", time_to_string(&mtime), 
			    q);
		record_stamp(q, mtime);
		return q;
	} else {
	    if (DEBUG(DIR))
		    printf("failed. Returning NULL\n");
	    free(q);
	    return NULL;
	}
}

void
Dir_AddDiri(Lst path, const char *name, const char *ename)
{
	struct PathEntry	*p;

	p = create_PathEntry(name, ename);
	if (p == NULL)
		return;
	if (p->refCount == 1)
		Lst_AtEnd(path, p);
	else if (!Lst_AddNew(path, p))
		return;
}

void *
Dir_CopyDir(void *p)
{
	struct PathEntry *q = p;
	q->refCount++;
	return p;
}

void
Dir_Destroy(void *pp)
{
	struct PathEntry *p = pp;

	if (--p->refCount == 0) {
		ohash_remove(&knownDirectories,
		    ohash_qlookup(&knownDirectories, p->name));
		free_hash(&p->files);
		free(p);
	}
}

/*-
 *-----------------------------------------------------------------------
 * Dir_Concat --
 *	Concatenate two paths, adding the second to the end of the first.
 *	Makes sure to avoid duplicates.
 *
 * Side Effects:
 *	Reference counts for added dirs are upped.
 *-----------------------------------------------------------------------
 */
void
Dir_Concat(Lst path1, Lst path2)
{
	LstNode	ln;
	struct PathEntry *p;

	for (ln = Lst_First(path2); ln != NULL; ln = Lst_Adv(ln)) {
		p = Lst_Datum(ln);
		if (Lst_AddNew(path1, p))
			p->refCount++;
	}
}

static void
DirPrintDir(void *p)
{
	const struct PathEntry *q = p;
	printf("%s ", q->name);
}

void
Dir_PrintPath(Lst path)
{
	Lst_Every(path, DirPrintDir);
}

struct timespec
Dir_MTime(GNode *gn)
{
	char *fullName;
	struct stat stb;
	struct file_stamp *entry;
	unsigned int slot;
	struct timespec	  mtime;

	if (gn->type & OP_PHONY)
		return gn->mtime;

	if (gn->type & OP_ARCHV)
		return Arch_MTime(gn);

	if (gn->path == NULL) {
		fullName = Dir_FindFile(gn->name, defaultPath);
		if (fullName == NULL)
			fullName = estrdup(gn->name);
	} else
		fullName = gn->path;

	slot = ohash_qlookup(&mtimes, fullName);
	entry = ohash_find(&mtimes, slot);
	if (entry != NULL) {
		/* Only do this once -- the second time folks are checking to
		 * see if the file was actually updated, so we need to
		 * actually go to the file system.	*/
		if (DEBUG(DIR))
			printf("Using cached time %s for %s\n",
			    time_to_string(&entry->mtime), fullName);
		mtime = entry->mtime;
		free(entry);
		ohash_remove(&mtimes, slot);
	} else if (stat(fullName, &stb) == 0)
		ts_set_from_stat(stb, mtime);
	else {
		if (gn->type & OP_MEMBER) {
			if (fullName != gn->path)
				free(fullName);
			return Arch_MemMTime(gn);
		} else
			ts_set_out_of_date(mtime);
	}
	if (fullName && gn->path == NULL)
		gn->path = fullName;

	gn->mtime = mtime;
	return gn->mtime;
}

@


1.67
log
@a wee little bit more cleanup (more const and remove noise from CDIAGFLAGS...
-pedantic kind of requires -std=c99 here to avoid LL warnings)
okay miod@@, millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: dir.c,v 1.66 2015/01/23 13:18:40 espie Exp $ */
d462 1
a462 1
		p = (struct PathEntry *)Lst_Datum(ln);
d536 1
a536 1
			p = (struct PathEntry *)Lst_Datum(ln);
d680 1
a680 1
		p = (struct PathEntry *)Lst_Datum(ln);
@


1.66
log
@remove a bunch of dangerous casts (useless casts from void * to something
else, in some cases by adding extra temporary variables.
IMO, it's much better practice to do

void *a;
int *p = a;
*p = 42;

rather than
void *a;
*(int *)a = 42;

okay miod@@... to be revisited for some possible const additions later.
@
text
@d1 1
a1 1
/*	$OpenBSD: dir.c,v 1.65 2015/01/16 15:36:29 deraadt Exp $ */
d689 1
a689 1
	struct PathEntry *q = p;
@


1.65
log
@switch to <limits.h>; ok millert
@
text
@d1 1
a1 1
/*	$OpenBSD: dir.c,v 1.64 2014/05/12 19:11:19 espie Exp $ */
d645 2
a646 1
	((struct PathEntry *)p)->refCount++;
d653 1
a653 1
	struct PathEntry *p = (struct PathEntry *)pp;
d689 2
a690 1
	printf("%s ", ((struct PathEntry *)p)->name);
@


1.64
log
@adjust to ohash being in libutil now, and to the interface changes.
fix potential integer overflows in memory allocation (mostly for pedagogical
purposes, these are unlikely to overflow in practice)
move the rest of lst.lib stuff into its own directory.
@
text
@d1 1
a1 1
/*	$OpenBSD: dir.c,v 1.63 2013/05/22 12:14:08 espie Exp $ */
a63 1
#include <sys/param.h>
@


1.63
log
@as checked through thorough tests, youngest->mtime == ctime, so ditch
the extra field.

remove some extra abstraction layer: use clock_gettime directly
instead of ts_set_from_now (what is "now" anyways)

time_to_string takes param by pointer

rename "now" into starttime (more accurate term)

randomize queue uses arc4random_uniform (prompted by deraadt@@)

display debug timestamp with ns too (it's debug, so it doesn't really
matter whichever way it's done, as long as it's done)

okay millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: dir.c,v 1.62 2013/04/23 14:32:53 espie Exp $ */
d180 1
a180 1
	offsetof(struct PathEntry, name), NULL, hash_alloc, hash_free,
d189 1
a189 1
	0, NULL, hash_alloc, hash_free, element_alloc
d207 1
a207 1
	offsetof(struct file_stamp, name), NULL, hash_alloc, hash_free,
@


1.62
log
@remove TIMESTAMP abstraction layer, prodded by theo.
while there, clean up includes.
use strtoll for ar timestamps (pretty much unused in reality, more
standard conforming than anything)

use idea from Todd to adapt to time_t being 32 bits OR 64 bits
(pedantically correct: INT_MIN would work just fine up to 1910 or so...)

okay millert@@, gone thru a make build.
@
text
@d1 1
a1 1
/*	$OpenBSD: dir.c,v 1.61 2012/12/07 07:15:31 espie Exp $ */
d573 1
a573 1
					    time_to_string(mtime), file);
d617 2
a618 1
			printf("Caching %s for %s\n", time_to_string(mtime), q);
d728 1
a728 1
			    time_to_string(entry->mtime), fullName);
@


1.61
log
@gc dead code
@
text
@d1 1
a1 1
/*	$OpenBSD: dir.c,v 1.60 2012/10/02 10:29:30 espie Exp $ */
d69 1
a70 1
#include <stdint.h>
d73 1
a75 1
#include "ohash.h"
d199 1
a199 1
	TIMESTAMP mtime;		/* time stamp... */
d231 1
a231 1
static void record_stamp(const char *, TIMESTAMP);
d245 1
a245 1
record_stamp(const char *file, TIMESTAMP t)
d551 1
a551 1
				TIMESTAMP mtime;
d613 1
a613 1
		TIMESTAMP mtime;
d697 1
a697 1
TIMESTAMP
d704 1
a704 1
	TIMESTAMP	  mtime;
@


1.60
log
@more changes, discussed and tested by various people.
- put back some job control, turns out it's necessary when we don't run a
shell.
- zap old #ifdef CLEANUP code... probably doesn't even compile.
- kill most of the OP_LIB code. Just keep a wee little bit for compatibility
(deprecated .LIBS and .INCLUDES, warns for weird dependencies instead of
erroring out).
- much improved debugging and -p output: sort variables, targets, rules,
output stuff in a nicer format mimicing input.
- better error message when no command is found, explain where the target comes from.
- sort final error list by file.
- show system files in errors as <bsd.prog.mk>
- reincorporate random delay, that was dropped
- optimize siginfo output by not regenerating the whole string each time.
- finish zapping old LocationInfo field that's no longer used.
@
text
@d1 1
a1 1
/*	$OpenBSD: dir.c,v 1.59 2010/07/19 19:46:44 espie Exp $ */
a646 31
}

/*-
 *-----------------------------------------------------------------------
 * Dir_MakeFlags --
 *	Make a string by taking all the directories in the given search
 *	path and preceding them by the given flag. Used by the suffix
 *	module to create variables for compilers based on suffix search
 *	paths.
 *
 * Results:
 *	The string mentioned above. Note that there is no space between
 *	the given flag and each directory. The empty string is returned if
 *	Things don't go well.
 *-----------------------------------------------------------------------
 */
char *
Dir_MakeFlags(const char *flag, Lst path)
{
	LstNode	  ln;
	BUFFER	  buf;

	Buf_Init(&buf, 0);

	for (ln = Lst_First(path); ln != NULL; ln = Lst_Adv(ln)) {
		Buf_AddString(&buf, flag);
		Buf_AddString(&buf, ((struct PathEntry *)Lst_Datum(ln))->name);
		Buf_AddSpace(&buf);
	}

	return Buf_Retrieve(&buf);
@


1.59
log
@Correct $OpenBSD$ stuff
@
text
@d1 1
a1 1
/*	$OpenBSD: dir.c,v 1.58 2010/07/19 19:30:37 espie Exp $ */
a370 19

#ifdef CLEANUP
void
Dir_End(void)
{
	struct PathEntry *p;
	unsigned int i;

	dot->refCount--;
	Dir_Destroy(dot);
	Lst_Destroy(defaultPath, Dir_Destroy);
	for (p = ohash_first(&knownDirectories, &i); p != NULL;
	    p = ohash_next(&knownDirectories, &i))
		Dir_Destroy(p);
	ohash_delete(&knownDirectories);
	free_hash(&mtimes);
}
#endif

@


1.58
log
@two small changes:
- allow variables in SysV modifiers, as requested by matthieu@@
(since recursive variables are an extension, this just extends the
extension)
- variation on :Q  called :QL (quote list), which does quote every character
EXCEPT for whitespace. e.g.,

toto:
	@@for i in ${VAR:QL} ...
@
text
@d1 1
a1 2
/*	$OpenPackages$ */
/*	$OpenBSD$ */
@


1.57
log
@modify timestamp handling to grab current time instead of relying on a
stale timestamp.

all those diffs sent to people ages ago, who didn't answer, except for
Theo, who said he ran it with no issues, so let's get this in...
@
text
@@


1.56
log
@changes to get target equivalence to work better.
- add new file to create lists of equivalent targets (siblings)
- use that for sequential mode to have much better VPATH support
- separate checking commands from reporting error, for later.
- zap DieHorribly accordingly
- renumber existing flags
- signal_running_jobs() is simpler than pass_signal_to_jobs()
- new debug option -dn for name matching.

Similar code to handle parallel make is still missing.

thanks to Mark, Miod, Theo, Otto, Todd for tests and/or comments.
@
text
@d757 3
@


1.55
log
@reorg the directory code a bit.

Instead of readDir, explicitly create PathEntry, and increment the refcount
in there, which is simpler.
@
text
@d2 1
a2 1
/*	$OpenBSD: dir.c,v 1.53 2007/09/17 09:28:36 espie Exp $ */
d348 6
@


1.54
log
@better variable name
@
text
@d83 1
d89 1
a89 7
struct PathEntry {
	int 	  refCount;	/* Number of paths with this directory */
	struct ohash   files;	/* Hash table of files in directory */
	char	  name[1];	/* Name of directory */
};

/*	A search path consists of a Lst of PathEntry structures. A PathEntry
a155 2
static LIST   theDefaultPath;		/* main search path */
Lst	      defaultPath= &theDefaultPath;
d157 21
a177 1
struct PathEntry	  *dot; 	/* contents of current directory */
d179 4
a182 3
struct file_stamp {
	TIMESTAMP mtime;		/* time stamp... */
	char name[1];			/* ...for that file.  */
d187 7
d199 5
a206 4
/* There are three distinct hash structures:
 * - to collate files's last modification times (global mtimes)
 * - to collate file names (in each PathEntry structure)
 * - to collate known directories (global knownDirectories).  */
d209 8
a216 1
	element_alloc };
a217 2
static struct ohash_info file_info = {
	0, NULL, hash_alloc, hash_free, element_alloc };
a218 3
static struct ohash_info dir_info = {
	offsetof(struct PathEntry, name), NULL,
	hash_alloc, hash_free, element_alloc };
d234 1
d237 1
a237 1
static struct PathEntry *DirReaddiri(const char *, const char *);
d241 4
d269 4
d298 51
d361 1
a361 1
	dot = DirReaddiri(dotname, dotname+1);
a364 4

	/* We always need to have dot around, so we increment its reference
	 * count to make sure it won't be destroyed.  */
	dot->refCount++;
d385 1
a401 3
	bool isDot;		/* Is the directory "." ? */

	isDot = p->name[0] == '.' && p->name[1] == '\0';
d413 1
a413 1
			    isDot ? estrdup(entry) :
d506 2
a507 2
			file = Str_concati(p->name, strchr(p->name, '\0'), 
			    basename, ename, '/');
a641 55
/* Read a directory, either from the disk, or from the cache.  */
static struct PathEntry *
DirReaddiri(const char *name, const char *ename)
{
	struct PathEntry *p;
	DIR *d;
	struct dirent *dp;
	unsigned int slot;

	slot = ohash_qlookupi(&knownDirectories, name, &ename);
	p = ohash_find(&knownDirectories, slot);

	if (p != NULL)
		return p;

	p = ohash_create_entry(&dir_info, name, &ename);
	p->refCount = 0;
	ohash_init(&p->files, 4, &file_info);

	if (DEBUG(DIR)) {
		printf("Caching %s...", p->name);
		fflush(stdout);
	}

	if ((d = opendir(p->name)) == NULL)
		return NULL;

	while ((dp = readdir(d)) != NULL) {
		if (dp->d_name[0] == '.' &&
		    (dp->d_name[1] == '\0' ||
			(dp->d_name[1] == '.' && dp->d_name[2] == '\0')))
			continue;
		add_file(p, dp->d_name);
	}
	(void)closedir(d);
	if (DEBUG(DIR))
		printf("done\n");

	ohash_insert(&knownDirectories, slot, p);
	return p;
}

/*-
 *-----------------------------------------------------------------------
 * Dir_AddDiri --
 *	Add the given name to the end of the given path. The order of
 *	the arguments is backwards so ParseDoDependency can do a
 *	Lst_ForEach of its list of paths...
 *
 * Side Effects:
 *	A structure is added to the list and the directory is
 *	read and hashed.
 *-----------------------------------------------------------------------
 */

d647 1
a647 1
	p = DirReaddiri(name, ename);
d650 1
a650 1
	if (p->refCount == 0)
a653 1
	p->refCount++;
a655 13
/*-
 *-----------------------------------------------------------------------
 * Dir_CopyDir --
 *	Callback function for duplicating a search path via Lst_Duplicate.
 *	Ups the reference count for the directory.
 *
 * Results:
 *	Returns the PathEntry it was given.
 *
 * Side Effects:
 *	The refCount of the path is incremented.
 *-----------------------------------------------------------------------
 */
a693 11
/*-
 *-----------------------------------------------------------------------
 * Dir_Destroy --
 *	Nuke a directory descriptor, if possible. Callback procedure
 *	for the suffixes module when destroying a search path.
 *
 * Side Effects:
 *	If no other path references this directory (refCount == 0),
 *	the PathEntry and all its data are freed.
 *-----------------------------------------------------------------------
 */
d721 1
a721 1
	struct PathEntry	*p;
@


1.53
log
@kill extra spaces at end of line
@
text
@d2 1
a2 1
/*	$OpenBSD: dir.c,v 1.52 2007/09/16 14:29:33 espie Exp $ */
d359 1
a359 1
	const char *cp;	/* index of first slash, if any */
d369 2
a370 2
	cp = Str_rchri(name, ename, '/');
	if (cp) {
d372 1
a372 1
		cp++;
d375 1
a375 1
		cp = name;
d378 1
a378 1
	hv = ohash_interval(cp, &ename);
d386 2
a387 2
	    (!hasSlash || (cp - name == 2 && *name == '.')) &&
	    find_file_hashi(dot, cp, ename, hv) != NULL) {
d402 1
a402 1
		if (find_file_hashi(p, cp, ename, hv) != NULL) {
d415 1
a415 1
				p2 = cp - 2;
d428 2
a429 2
			file = Str_concati(p->name, strchr(p->name, '\0'), cp,
			    ename, '/');
d441 1
a441 1
			if (*p1 == '\0' && p2 == cp - 1) {
@


1.52
log
@remove old debug code nothing uses
@
text
@d2 1
a2 1
/*	$OpenBSD: dir.c,v 1.51 2007/09/16 12:30:35 espie Exp $ */
d178 1
a178 1
static struct ohash mtimes;  
d185 2
a186 2
static struct ohash_info stamp_info = { 
	offsetof(struct file_stamp, name), NULL, hash_alloc, hash_free, 
d189 1
a189 1
static struct ohash_info file_info = { 
d192 2
a193 2
static struct ohash_info dir_info = { 
	offsetof(struct PathEntry, name), NULL, 
d200 1
a200 1
static char *find_file_hashi(struct PathEntry *, const char *, const char *, 
d257 1
a257 1
find_file_hashi(struct PathEntry *p, const char *file, const char *efile, 
d282 1
a282 1
	/* We always need to have dot around, so we increment its reference 
d316 1
a316 1
Dir_MatchFilesi(const char *word, const char *eword, struct PathEntry *p, 
d334 2
a335 2
			Lst_AtEnd(expansions, 
			    isDot ? estrdup(entry) : 
d347 1
a347 1
 *	that directory later on. 
d350 1
a350 1
Dir_FindFileComplexi(const char *name, const char *ename, Lst path, 
d362 1
a362 1
	struct file_stamp *entry; 
d382 2
a383 2
	/* Unless checkCurDirFirst is false, we always look for 
	 * the file in the current directory before anywhere else 
d385 1
a385 1
	if (checkCurdirFirst && 
d393 1
a393 1
	/* Then, we look through all the directories on path, seeking one 
d395 2
a396 2
	 * component(s) match name's initial component(s). 
	 * If found, we concatenate the directory name and the 
d406 7
a412 7
				/* If the name had a slash, its initial 
				 * components and p's final components must 
				 * match. This is false if a mismatch is 
				 * encountered before all of the initial 
				 * components have been checked (p2 > name at 
				 * the end of the loop), or we matched only 
				 * part of one of the components of p along 
d416 1
a416 1
				while (p2 >= name && p1 >= p->name && 
d421 1
a421 1
				if (p2 >= name || 
d428 1
a428 1
			file = Str_concati(p->name, strchr(p->name, '\0'), cp, 
d434 3
a436 3
			/* If the file has a leading path component and that 
			 * component exactly matches the entire name of the 
			 * current search directory, we assume the file 
d438 1
a438 1
			for (p1 = p->name, p2 = name; *p1 && *p1 == *p2; 
d451 3
a453 3
	 * If it does contain a slash, however, it could be in a subdirectory 
	 * of one of the members of the search path. (eg., for path=/usr/include 
	 * and name=sys/types.h, the above search fails to turn up types.h 
d459 1
a459 1
	 * that directory, and append all but the last component of the 
d475 1
a475 1
				file = Str_concati(p->name, 
d478 1
a478 1
				/* Checking in dot -- DON'T put a leading 
d493 8
a500 8
				/* We've found another directory to search. 
				 * We know there is a slash in 'file'. We 
				 * call Dir_AddDiri to add the new directory 
				 * onto the existing search path. Once that's 
				 * done, we return the file name, knowing that 
				 * should a file in this directory ever be 
				 * referenced again in such a manner, we will 
				 * find it without having to do numerous 
d505 1
a505 1
				/* Save the modification time so if it's 
d508 1
a508 1
					printf("Caching %s for %s\n", 
d520 1
a520 1
			/* Already checked by the given name, since . was in 
d592 2
a593 2
		if (dp->d_name[0] == '.' && 
		    (dp->d_name[1] == '\0' || 
d702 1
a702 1
		ohash_remove(&knownDirectories, 
d767 1
a767 1
		 * see if the file was actually updated, so we need to 
@


1.51
log
@rename dirSearchPath -> defaultPath, and openDirectories -> knownDirectories
@
text
@d2 1
a2 1
/*	$OpenBSD: dir.c,v 1.50 2007/09/16 12:19:15 espie Exp $ */
a89 4
#ifdef DEBUG_DIRECTORY_CACHE
	int 	  hits; 	/* the number of times a file in this
				 * directory has been found */
#endif
a163 9
#ifdef DEBUG_DIRECTORY_CACHE
/* Variables for gathering statistics on the efficiency of the hashing
 * mechanism.  */
static int    hits,			/* Found in directory cache */
	      misses,			/* Sad, but not evil misses */
	      nearmisses,		/* Found under search path */
	      bigmisses;		/* Sought by itself */
#endif

a389 4
#ifdef DEBUG_DIRECTORY_CACHE
		hits++;
		dot->hits++;
#endif
a431 4
#ifdef DEBUG_DIRECTORY_CACHE
			p->hits++;
			hits++;
#endif
a463 3
#ifdef DEBUG_DIRECTORY_CACHE
		misses++;
#endif
a510 3
#ifdef DEBUG_DIRECTORY_CACHE
				nearmisses++;
#endif
a542 3
#ifdef DEBUG_DIRECTORY_CACHE
	bigmisses++;
#endif
a579 3
#ifdef DEBUG_DIRECTORY_CACHE
	p->hits = 0;
#endif
a730 19

#ifdef DEBUG_DIRECTORY_CACHE
void
Dir_PrintDirectories(void)
{
	struct PathEntry		*p;
	unsigned int	i;

	printf("#*** Directory Cache:\n");
	printf("# Stats: %d hits %d misses %d near misses %d losers (%d%%)\n",
	      hits, misses, nearmisses, bigmisses,
	      (hits+bigmisses+nearmisses ?
	       hits * 100 / (hits + bigmisses + nearmisses) : 0));
	printf("# %-20s referenced\thits\n", "directory");
	for (p = ohash_first(&knownDirectories, &i); p != NULL;
	    p = ohash_next(&knownDirectories, &i))
		printf("# %-20s %10d\t%4d\n", p->name, p->refCount, p->hits);
}
#endif
@


1.50
log
@rename Path to less misleading PathEntry. Get rid of typedef.
@
text
@d2 1
a2 1
/*	$OpenBSD: dir.c,v 1.49 2007/09/16 12:09:36 espie Exp $ */
d107 1
a107 1
 *	openDirectories cache.
d165 2
a166 2
static LIST   thedirSearchPath;		/* main search path */
Lst	      dirSearchPath= &thedirSearchPath;
d184 1
a184 1
static struct ohash   openDirectories;	/* cache all open directories */
d197 1
a197 1
 * - to collate known directories (global openDirectories).  */
d285 2
a286 2
	Static_Lst_Init(dirSearchPath);
	ohash_init(&openDirectories, 4, &dir_info);
d309 3
a311 3
	Lst_Destroy(dirSearchPath, Dir_Destroy);
	for (p = ohash_first(&openDirectories, &i); p != NULL;
	    p = ohash_next(&openDirectories, &i))
d313 1
a313 1
	ohash_delete(&openDirectories);
d603 2
a604 2
	slot = ohash_qlookupi(&openDirectories, name, &ename);
	p = ohash_find(&openDirectories, slot);
d635 1
a635 1
	ohash_insert(&openDirectories, slot, p);
d735 2
a736 2
		ohash_remove(&openDirectories, 
		    ohash_qlookup(&openDirectories, p->name));
d778 2
a779 2
	for (p = ohash_first(&openDirectories, &i); p != NULL;
	    p = ohash_next(&openDirectories, &i))
d809 1
a809 1
		fullName = Dir_FindFile(gn->name, dirSearchPath);
@


1.49
log
@rename Targ_FmtTime into time_to_string and move it, as it's not related
to target nodes at all (reduces modules inter-dependencies)
@
text
@d2 1
a2 1
/*	$OpenBSD: dir.c,v 1.48 2007/09/16 10:43:53 espie Exp $ */
d88 1
a88 1
typedef struct Path_ {
d96 1
a96 1
} Path;
d98 5
a102 5
/*	A search path consists of a Lst of Path structures. A Path structure
 *	has in it the name of the directory and a hash table of all the files
 *	in the directory. This is used to cut down on the number of system
 *	calls necessary to find implicit dependents and their like. Since
 *	these searches are made before any actions are taken, we need not
d129 1
a129 1
 *	    3) record the mtime of the directory in the Path structure and
d177 1
a177 1
Path	  *dot; 			/* contents of current directory */
d196 1
a196 1
 * - to collate file names (in each Path structure)
d206 2
a207 1
	offsetof(Path, name), NULL, hash_alloc, hash_free, element_alloc };
d210 1
a210 1
static void add_file(Path *, const char *);
d213 2
a214 1
static char *find_file_hashi(Path *, const char *, const char *, uint32_t);
d225 1
a225 1
static Path *DirReaddiri(const char *, const char *);
d254 1
a254 1
add_file(Path *p, const char *file)
d270 2
a271 1
find_file_hashi(Path *p, const char *file, const char *efile, uint32_t hv)
d304 1
a304 1
	struct Path *p;
d321 1
a321 1
 *	Given a pattern and a Path structure, see if any files
d329 2
a330 1
Dir_MatchFilesi(const char *word, const char *eword, Path *p, Lst expansions)
d366 1
a366 1
	Path *p;	/* current path member */
d416 1
a416 1
		p = (Path *)Lst_Datum(ln);
d497 1
a497 1
			p = (Path *)Lst_Datum(ln);
d595 1
a595 1
static Path *
d598 1
a598 1
	Path *p;
d655 1
a655 1
	Path	*p;
d674 1
a674 1
 *	Returns the Path it was given.
d683 1
a683 1
	((Path *)p)->refCount++;
d711 1
a711 1
		Buf_AddString(&buf, ((Path *)Lst_Datum(ln))->name);
d726 1
a726 1
 *	the Path and all its data are freed.
d732 1
a732 1
	Path *p = (Path *)pp;
d756 1
a756 1
	Path	*p;
d759 1
a759 1
		p = (Path *)Lst_Datum(ln);
d769 1
a769 1
	Path		*p;
d787 1
a787 1
	printf("%s ", ((Path *)p)->name);
@


1.48
log
@move free_ohash  function so that we can reuse it.
@
text
@d2 1
a2 1
/*	$OpenBSD: dir.c,v 1.47 2007/09/16 10:14:26 espie Exp $ */
a82 1
#include "targ.h"
d529 1
a529 1
					    Targ_FmtTime(mtime), file);
d579 1
a579 1
			printf("Caching %s for %s\n", Targ_FmtTime(mtime), q);
d819 1
a819 1
			    Targ_FmtTime(entry->mtime), fullName);
@


1.47
log
@cut up dir.c into dir.c/direxpand.c as there is very little interface between
two modules that do different things.
@
text
@d2 1
a2 1
/*	$OpenBSD: dir.c,v 1.46 2007/07/24 21:09:07 espie Exp $ */
a221 3
/* free_hash(o): free a ohash structure, where each element can be free'd. */
static void free_hash(struct ohash *);

a273 11
}

static void
free_hash(struct ohash *h)
{
	void *e;
	unsigned int i;

	for (e = ohash_first(h, &i); e != NULL; e = ohash_next(h, &i))
		free(e);
	ohash_delete(h);
@


1.46
log
@reindent (no binary change)
@
text
@d2 1
a2 1
/*	$OpenBSD: dir.c,v 1.45 2007/01/18 17:49:51 espie Exp $ */
d178 1
a178 1
static Path	  *dot; 		/* contents of current directory */
a227 12
/* Handles wildcard expansion on a given directory. */
static void DirMatchFilesi(const char *, const char *, Path *, Lst);
/* Handles simple wildcard expansion on a path. */
static void PathMatchFilesi(const char *, const char *, Lst, Lst);
/* Handles wildcards expansion except for curly braces. */
static void DirExpandWildi(const char *, const char *, Lst, Lst);
#define DirExpandWild(s, l1, l2) DirExpandWildi(s, strchr(s, '\0'), l1, l2)
/* Handles wildcard expansion including curly braces. */
static void DirExpandCurlyi(const char *, const char *, Lst, Lst);

/* Debugging: show each word in an expansion list. */
static void DirPrintWord(void *);
a329 40

/* XXX: This code is not 100% correct ([^]] fails) */
bool
Dir_HasWildcardsi(const char *name, const char *ename)
{
	const char *cp;
	bool wild = false;
	unsigned long brace = 0, bracket = 0;

	for (cp = name; cp != ename; cp++) {
		switch (*cp) {
		case '{':
			brace++;
			wild = true;
			break;
		case '}':
			if (brace == 0)
				return false;
			brace--;
			break;
		case '[':
			bracket++;
			wild = true;
			break;
		case ']':
			if (bracket == 0)
				return false;
			bracket--;
			break;
		case '?':
		case '*':
			wild = true;
			break;
		default:
			break;
		}
	}
	return wild && bracket == 0 && brace == 0;
}

d332 1
a332 1
 * DirMatchFilesi --
d340 2
a341 2
static void
DirMatchFilesi(const char *word, const char *eword, Path *p, Lst expansions)
a362 219

/*-
 *-----------------------------------------------------------------------
 * PathMatchFilesi --
 *	Traverse directories in the path, calling DirMatchFiles for each.
 *	NOTE: This doesn't handle patterns in directories.
 *-----------------------------------------------------------------------
 */
static void
PathMatchFilesi(const char *word, const char *eword, Lst path, Lst expansions)
{
	LstNode	ln;		/* Current node */

	for (ln = Lst_First(path); ln != NULL; ln = Lst_Adv(ln))
		DirMatchFilesi(word, eword, (Path *)Lst_Datum(ln), expansions);
}

static void
DirPrintWord(void *word)
{
	printf("%s ", (char *)word);
}

/*-
 *-----------------------------------------------------------------------
 * DirExpandWildi:
 *	Expand all wild cards in a fully qualified name, except for
 *	curly braces.
 * Side-effect:
 *	Will hash any directory in which a file is found, and add it to
 *	the path, on the assumption that future lookups will find files
 *	there as well.
 *-----------------------------------------------------------------------
 */
static void
DirExpandWildi(const char *word, const char *eword, Lst path, Lst expansions)
{
	const char	*cp;
	const char	*slash; 	/* keep track of first slash before wildcard */

	slash = memchr(word, '/', eword - word);
	if (slash == NULL) {
		/* First the files in dot.  */
		DirMatchFilesi(word, eword, dot, expansions);

		/* Then the files in every other directory on the path.  */
		PathMatchFilesi(word, eword, path, expansions);
		return;
	}
	/* The thing has a directory component -- find the first wildcard
	 * in the string.  */
	slash = word;
	for (cp = word; cp != eword; cp++) {
		if (*cp == '/')
			slash = cp;
		if (*cp == '?' || *cp == '[' || *cp == '*') {

			if (slash != word) {
				char	*dirpath;

				/* If the glob isn't in the first component, 
				 * try and find all the components up to 
				 * the one with a wildcard.  */
				dirpath = Dir_FindFilei(word, slash+1, path);
				/* dirpath is null if we can't find the 
				 * leading component 
				 * XXX: Dir_FindFile won't find internal 
				 * components.  i.e. if the path contains 
				 * ../Etc/Object and we're looking for Etc, 
				 * it won't be found. */
				if (dirpath != NULL) {
					char *dp;
					LIST temp;

					dp = strchr(dirpath, '\0');
					while (dp > dirpath && dp[-1] == '/')
						dp--;

					Lst_Init(&temp);
					Dir_AddDiri(&temp, dirpath, dp);
					PathMatchFilesi(slash+1, eword, &temp, 
					    expansions);
					Lst_Destroy(&temp, NOFREE);
				}
			} else
				/* Start the search from the local directory. */
				PathMatchFilesi(word, eword, path, expansions);
			return;
		}
	}
	/* Return the file -- this should never happen.  */
	PathMatchFilesi(word, eword, path, expansions);
}

/*-
 *-----------------------------------------------------------------------
 * DirExpandCurly --
 *	Expand curly braces like the C shell, and other wildcards as per
 *	Str_Match.
 *	XXX: if curly expansion yields a result with
 *	no wildcards, the result is placed on the list WITHOUT CHECKING
 *	FOR ITS EXISTENCE.
 *-----------------------------------------------------------------------
 */
static void
DirExpandCurlyi(const char *word, const char *eword, Lst path, Lst expansions)
{
	const char *cp2;/* Pointer for checking for wildcards in
			 * expansion before calling Dir_Expand */
	LIST curled; 	/* Queue of words to expand */
	char *toexpand;	/* Current word to expand */
	bool dowild; 	/* Wildcard left after curlies ? */

	/* Determine once and for all if there is something else going on */
	dowild = false;
	for (cp2 = word; cp2 != eword; cp2++)
		if (*cp2 == '*' || *cp2 == '?' || *cp2 == '[') {
			dowild = true;
			break;
		}

	/* Prime queue with copy of initial word */
	Lst_Init(&curled);
	Lst_EnQueue(&curled, Str_dupi(word, eword));
	while ((toexpand = (char *)Lst_DeQueue(&curled)) != NULL) {
		const char *brace;
		const char *start;
				/* Start of current chunk of brace clause */
		const char *end;/* Character after the closing brace */
		int bracelevel; /* Keep track of nested braces. If we hit
				 * the right brace with bracelevel == 0,
				 * this is the end of the clause. */
		size_t endLen;  /* The length of the ending non-curlied 
				 * part of the current expansion */

		/* End case: no curly left to expand */
		brace = strchr(toexpand, '{');
		if (brace == NULL) {
			if (dowild) {
				DirExpandWild(toexpand, path, expansions);
				free(toexpand);
			} else
				Lst_AtEnd(expansions, toexpand);
			continue;
		} 

		start = brace+1;

		/* Find the end of the brace clause first, being wary of 
		 * nested brace clauses.  */
		for (end = start, bracelevel = 0;; end++) {
			if (*end == '{')
				bracelevel++;
			else if (*end == '\0') {
				Error("Unterminated {} clause \"%s\"", start);
				return;
			} else if (*end == '}' && bracelevel-- == 0)
				break;
		}
		end++;
		endLen = strlen(end);

		for (;;) {
			char *file;	/* To hold current expansion */
			const char *cp;	/* Current position in brace clause */
		    
			/* Find the end of the current expansion */
			for (bracelevel = 0, cp = start; 
			    bracelevel != 0 || (*cp != '}' && *cp != ','); 
			    cp++) {
				if (*cp == '{')
					bracelevel++;
				else if (*cp == '}')
					bracelevel--;
			}

			/* Build the current combination and enqueue it.  */
			file = emalloc((brace - toexpand) + (cp - start) + 
			    endLen + 1);
			if (brace != toexpand)
				memcpy(file, toexpand, brace-toexpand);
			if (cp != start)
				memcpy(file+(brace-toexpand), start, cp-start);
			memcpy(file+(brace-toexpand)+(cp-start), end, 
			    endLen + 1);
			Lst_EnQueue(&curled, file);
			if (*cp == '}')
				break;
			start = cp+1;
		}
		free(toexpand);
	}
}

/* Side effects:
 * 	Dir_Expandi will hash directories that were not yet visited */
void
Dir_Expandi(const char *word, const char *eword, Lst path, Lst expansions)
{
	const char	*cp;

	if (DEBUG(DIR)) {
		char *s = Str_dupi(word, eword);
		printf("expanding \"%s\"...", s);
		free(s);
	}

	cp = memchr(word, '{', eword - word);
	if (cp)
		DirExpandCurlyi(word, eword, path, expansions);
	else
		DirExpandWildi(word, eword, path, expansions);

	if (DEBUG(DIR)) {
		Lst_Every(expansions, DirPrintWord);
		fputc('\n', stdout);
	}
}

@


1.45
log
@* add an extra argument to the dir lookup functions to say whether we
should look in the current directory.
* refactor include files treatment to have a separate function to look
for an include.
* use both pieces to make sure system includes do not get looked up
in the current directory unless everything else fails.

This is != from the netbsd solution to the same problem, which stuffs
`magic' entries into filepaths to say whether dot should be looked at
first or last.

feature requested by matthieu@@.
okay matthieu@@
@
text
@d2 1
a2 1
/*	$OpenBSD: dir.c,v 1.44 2006/01/20 23:10:19 espie Exp $ */
d90 1
a90 1
    int 	  refCount;	/* Number of paths with this directory */
d92 1
a92 1
    int 	  hits; 	/* the number of times a file in this
d95 2
a96 2
    struct ohash   files;	/* Hash table of files in directory */
    char	  name[1];	/* Name of directory */
d199 3
a201 2
static struct ohash_info stamp_info = { offsetof(struct file_stamp, name),
    NULL, hash_alloc, hash_free, element_alloc };
d203 2
a204 2
static struct ohash_info file_info = { 0,
    NULL, hash_alloc, hash_free, element_alloc };
d206 2
a207 2
static struct ohash_info dir_info = { offsetof(Path, name),
    NULL, hash_alloc, hash_free, element_alloc };
d246 13
a258 13
    unsigned int	slot;
    const char		*end = NULL;
    struct file_stamp	*n;

    slot = ohash_qlookupi(&mtimes, file, &end);
    n = ohash_find(&mtimes, slot);
    if (n)
	n->mtime = t;
    else {
	n = ohash_create_entry(&stamp_info, file, &end);
	n->mtime = t;
	ohash_insert(&mtimes, slot, n);
    }
d264 1
a264 1
    return ohash_find(&mtimes, ohash_qlookupi(&mtimes, file, &efile));
d270 11
a280 11
    unsigned int	slot;
    const char		*end = NULL;
    char		*n;
    struct ohash 	*h = &p->files;

    slot = ohash_qlookupi(h, file, &end);
    n = ohash_find(h, slot);
    if (n == NULL) {
	n = ohash_create_entry(&file_info, file, &end);
	ohash_insert(h, slot, n);
    }
d286 1
a286 1
    struct ohash 	*h = &p->files;
d288 1
a288 1
    return ohash_find(h, ohash_lookup_interval(h, file, efile, hv));
d294 2
a295 2
    void		*e;
    unsigned int	i;
d297 3
a299 3
    for (e = ohash_first(h, &i); e != NULL; e = ohash_next(h, &i))
	free(e);
    ohash_delete(h);
d307 1
a307 1
    char *dotname = ".";
d309 3
a311 3
    Static_Lst_Init(dirSearchPath);
    ohash_init(&openDirectories, 4, &dir_info);
    ohash_init(&mtimes, 4, &stamp_info);
d314 1
a314 1
    dot = DirReaddiri(dotname, dotname+1);
d316 2
a317 2
    if (!dot)
    	Fatal("Can't access current directory");
d319 3
a321 3
    /* We always need to have dot around, so we increment its reference count
     * to make sure it won't be destroyed.  */
    dot->refCount++;
d328 2
a329 2
    struct Path *p;
    unsigned int i;
d331 8
a338 8
    dot->refCount--;
    Dir_Destroy(dot);
    Lst_Destroy(dirSearchPath, Dir_Destroy);
    for (p = ohash_first(&openDirectories, &i); p != NULL;
	p = ohash_next(&openDirectories, &i))
	    Dir_Destroy(p);
    ohash_delete(&openDirectories);
    free_hash(&mtimes);
d347 31
a377 30
    const char		*cp;
    bool		wild = false;
    unsigned long	brace = 0, bracket = 0;

    for (cp = name; cp != ename; cp++) {
	switch (*cp) {
	case '{':
	    brace++;
	    wild = true;
	    break;
	case '}':
	    if (brace == 0)
		return false;
	    brace--;
	    break;
	case '[':
	    bracket++;
	    wild = true;
	    break;
	case ']':
	    if (bracket == 0)
		return false;
	    bracket--;
	    break;
	case '?':
	case '*':
	    wild = true;
	    break;
	default:
	    break;
d379 1
a379 2
    }
    return wild && bracket == 0 && brace == 0;
d395 19
a413 18
    unsigned int	search; 	/* Index into the directory's table */
    const char		*entry; 	/* Current entry in the table */
    bool		isDot;		/* Is the directory "." ? */

    isDot = p->name[0] == '.' && p->name[1] == '\0';

    for (entry = ohash_first(&p->files, &search); entry != NULL;
	 entry = ohash_next(&p->files, &search)) {
	/* See if the file matches the given pattern. We follow the UNIX
	 * convention that dot files will only be found if the pattern
	 * begins with a dot (the hashing scheme doesn't hash . or ..,
	 * so they won't match `.*'.  */
	if (*word != '.' && *entry == '.')
	    continue;
	if (Str_Matchi(entry, strchr(entry, '\0'), word, eword))
	    Lst_AtEnd(expansions,
		isDot ? estrdup(entry) : Str_concat(p->name, entry, '/'));
    }
d426 1
a426 1
    LstNode	ln;		/* Current node */
d428 2
a429 2
    for (ln = Lst_First(path); ln != NULL; ln = Lst_Adv(ln))
	DirMatchFilesi(word, eword, (Path *)Lst_Datum(ln), expansions);
d435 1
a435 1
    printf("%s ", (char *)word);
d452 2
a453 2
    const char	*cp;
    const char	*slash; 	/* keep track of first slash before wildcard */
d455 4
a458 4
    slash = memchr(word, '/', eword - word);
    if (slash == NULL) {
	/* First the files in dot.  */
	DirMatchFilesi(word, eword, dot, expansions);
d460 43
a502 34
	/* Then the files in every other directory on the path.  */
	PathMatchFilesi(word, eword, path, expansions);
	return;
    }
    /* The thing has a directory component -- find the first wildcard
     * in the string.  */
    slash = word;
    for (cp = word; cp != eword; cp++) {
	if (*cp == '/')
	    slash = cp;
	if (*cp == '?' || *cp == '[' || *cp == '*') {

	    if (slash != word) {
		char	*dirpath;

		/* If the glob isn't in the first component, try and find
		 * all the components up to the one with a wildcard.  */
		dirpath = Dir_FindFilei(word, slash+1, path);
		/* dirpath is null if we can't find the leading component
		 * XXX: Dir_FindFile won't find internal components.
		 * i.e. if the path contains ../Etc/Object and we're
		 * looking for Etc, it won't be found. */
		if (dirpath != NULL) {
		    char *dp;
		    LIST temp;

		    dp = strchr(dirpath, '\0');
		    while (dp > dirpath && dp[-1] == '/')
		    	dp--;

		    Lst_Init(&temp);
		    Dir_AddDiri(&temp, dirpath, dp);
		    PathMatchFilesi(slash+1, eword, &temp, expansions);
		    Lst_Destroy(&temp, NOFREE);
a503 4
	    } else
		/* Start the search from the local directory.  */
		PathMatchFilesi(word, eword, path, expansions);
	    return;
d505 2
a506 3
    }
    /* Return the file -- this should never happen.  */
    PathMatchFilesi(word, eword, path, expansions);
d522 23
a544 23
    const char	*cp2;		/* Pointer for checking for wildcards in
				 * expansion before calling Dir_Expand */
    LIST	curled; 	/* Queue of words to expand */
    char	*toexpand;	/* Current word to expand */
    bool	dowild; 	/* Wildcard left after curlies ? */

    /* Determine once and for all if there is something else going on */
    dowild = false;
    for (cp2 = word; cp2 != eword; cp2++)
	if (*cp2 == '*' || *cp2 == '?' || *cp2 == '[') {
		dowild = true;
		break;
	}

    /* Prime queue with copy of initial word */
    Lst_Init(&curled);
    Lst_EnQueue(&curled, Str_dupi(word, eword));
    while ((toexpand = (char *)Lst_DeQueue(&curled)) != NULL) {
	const char	*brace;
	const char	*start; /* Start of current chunk of brace clause */
	const char	*end;	/* Character after the closing brace */
	int		bracelevel;
				/* Keep track of nested braces. If we hit
d547 1
a547 2
	size_t		endLen;
				/* The length of the ending non-curlied 
d550 55
a604 5
	/* End case: no curly left to expand */
	brace = strchr(toexpand, '{');
	if (brace == NULL) {
	    if (dowild) {
		DirExpandWild(toexpand, path, expansions);
a605 17
	    } else
		Lst_AtEnd(expansions, toexpand);
	    continue;
	} 

	start = brace+1;

	/* Find the end of the brace clause first, being wary of nested brace
	 * clauses.  */
	for (end = start, bracelevel = 0;; end++) {
	    if (*end == '{')
		bracelevel++;
	    else if (*end == '\0') {
		Error("Unterminated {} clause \"%s\"", start);
		return;
	    } else if (*end == '}' && bracelevel-- == 0)
		break;
a606 30
	end++;
	endLen = strlen(end);

	for (;;) {
	    char	*file;	/* To hold current expansion */
	    const char	*cp;	/* Current position in brace clause */
	
	    /* Find the end of the current expansion */
	    for (bracelevel = 0, cp = start; 
	    	bracelevel != 0 || (*cp != '}' && *cp != ','); cp++) {
		if (*cp == '{')
		    bracelevel++;
		else if (*cp == '}')
		    bracelevel--;
	    }

	    /* Build the current combination and enqueue it.  */
	    file = emalloc((brace - toexpand) + (cp - start) + endLen + 1);
	    if (brace != toexpand)
	    	memcpy(file, toexpand, brace-toexpand);
	    if (cp != start)
	    	memcpy(file+(brace-toexpand), start, cp-start);
	    memcpy(file+(brace-toexpand)+(cp-start), end, endLen + 1);
	    Lst_EnQueue(&curled, file);
	    if (*cp == '}')
	    	break;
	    start = cp+1;
	}
	free(toexpand);
    }
d614 7
a620 1
    const char	*cp;
d622 10
a631 16
    if (DEBUG(DIR)) {
    	char *s = Str_dupi(word, eword);
	printf("expanding \"%s\"...", s);
	free(s);
    }

    cp = memchr(word, '{', eword - word);
    if (cp)
	DirExpandCurlyi(word, eword, path, expansions);
    else
	DirExpandWildi(word, eword, path, expansions);

    if (DEBUG(DIR)) {
	Lst_Every(expansions, DirPrintWord);
	fputc('\n', stdout);
    }
d648 26
a673 41
    Path		*p;	/* current path member */
    char		*p1;	/* pointer into p->name */
    const char		*p2;	/* pointer into name */
    LstNode		ln;	/* a list element */
    char		*file;	/* the current filename to check */
    char		*temp;	/* index into file */
    const char		*cp;	/* index of first slash, if any */
    bool		hasSlash;
    struct stat 	stb;	/* Buffer for stat, if necessary */
    struct file_stamp	*entry; /* Entry for mtimes table */
    uint32_t		hv;	/* hash value for last component in file name */
    char		*q;	/* Str_dupi(name, ename) */

    /* Find the final component of the name and note whether name has a
     * slash in it */
    cp = Str_rchri(name, ename, '/');
    if (cp) {
	hasSlash = true;
	cp++;
    } else {
	hasSlash = false;
	cp = name;
    }

    hv = ohash_interval(cp, &ename);

    if (DEBUG(DIR))
	printf("Searching for %s...", name);
    /* Unless checkCurDirFirst is false, we always look for 
     * the file in the current directory before anywhere else 
     * and we always return exactly what the caller specified. */
    if (checkCurdirFirst && (!hasSlash || (cp - name == 2 && *name == '.')) &&
	find_file_hashi(dot, cp, ename, hv) != NULL) {
	    if (DEBUG(DIR))
		printf("in '.'\n");
#ifdef DEBUG_DIRECTORY_CACHE
	    hits++;
	    dot->hits++;
#endif
	    return Str_dupi(name, ename);
    }
a674 7
    /* Then, we look through all the directories on path, seeking one 
     * containing the final component of name and whose final
     * component(s) match name's initial component(s). 
     * If found, we concatenate the directory name and the 
     * final component and return the resulting string.  */
    for (ln = Lst_First(path); ln != NULL; ln = Lst_Adv(ln)) {
	p = (Path *)Lst_Datum(ln);
d676 9
a684 26
	    printf("%s...", p->name);
	if (find_file_hashi(p, cp, ename, hv) != NULL) {
	    if (DEBUG(DIR))
		printf("here...");
	    if (hasSlash) {
		/* If the name had a slash, its initial components and p's
		 * final components must match. This is false if a mismatch
		 * is encountered before all of the initial components
		 * have been checked (p2 > name at the end of the loop), or
		 * we matched only part of one of the components of p
		 * along with all the rest of them (*p1 != '/').  */
		p1 = p->name + strlen(p->name) - 1;
		p2 = cp - 2;
		while (p2 >= name && p1 >= p->name && *p1 == *p2) {
		    p1--;
		    p2--;
		}
		if (p2 >= name || (p1 >= p->name && *p1 != '/')) {
		    if (DEBUG(DIR))
			printf("component mismatch -- continuing...");
		    continue;
		}
	    }
	    file = Str_concati(p->name, strchr(p->name, '\0'), cp, ename, '/');
	    if (DEBUG(DIR))
		printf("returning %s\n", file);
d686 2
a687 2
	    p->hits++;
	    hits++;
d689 1
a689 12
	    return file;
	} else if (hasSlash) {
	    /* If the file has a leading path component and that component
	     * exactly matches the entire name of the current search
	     * directory, we assume the file doesn't exist and return NULL.  */
	    for (p1 = p->name, p2 = name; *p1 && *p1 == *p2; p1++, p2++)
		continue;
	    if (*p1 == '\0' && p2 == cp - 1) {
		if (DEBUG(DIR))
		    printf("has to be here but isn't -- returning NULL\n");
		return NULL;
	    }
a690 1
    }
d692 39
a730 15
    /* We didn't find the file on any existing member of the path.
     * If the name doesn't contain a slash, end of story.
     * If it does contain a slash, however, it could be in a subdirectory 
     * of one of the members of the search path. (eg., for path=/usr/include 
     * and name=sys/types.h, the above search fails to turn up types.h 
     * in /usr/include, even though /usr/include/sys/types.h exists).
     *
     * We only perform this look-up for non-absolute file names.
     *
     * Whenever we score a hit, we assume there will be more matches from
     * that directory, and append all but the last component of the 
     * resulting name onto the search path. */
    if (!hasSlash) {
	if (DEBUG(DIR))
	    printf("failed.\n");
d732 2
a733 1
	misses++;
d735 16
a750 22
	return NULL;
    }

    if (*name != '/') {
	bool checkedDot = false;

	if (DEBUG(DIR))
	    printf("failed. Trying subdirectories...");
	for (ln = Lst_First(path); ln != NULL; ln = Lst_Adv(ln)) {
	    p = (Path *)Lst_Datum(ln);
	    if (p != dot)
		file = Str_concati(p->name, strchr(p->name, '\0'), name, ename, '/');
	    else {
		/* Checking in dot -- DON'T put a leading ./ on the thing.  */
		file = Str_dupi(name, ename);
		checkedDot = true;
	    }
	    if (DEBUG(DIR))
		printf("checking %s...", file);

	    if (stat(file, &stb) == 0) {
		TIMESTAMP mtime;
d752 13
a764 1
		ts_set_from_stat(stb, mtime);
d766 6
a771 1
		    printf("got it.\n");
d773 2
a774 9
		/* We've found another directory to search. We know there
		 * is a slash in 'file'. We call Dir_AddDiri to add the
		 * new directory onto the existing search path. Once 
		 * that's done, we return the file name, knowing that 
		 * should a file in this directory ever be referenced again 
		 * in such a manner, we will find it without having to do 
		 * numerous access calls.  */
		temp = strrchr(file, '/');
		Dir_AddDiri(path, file, temp);
a775 2
		/* Save the modification time so if it's needed, we don't have
		 * to fetch it again.  */
d777 40
a816 3
		    printf("Caching %s for %s\n", Targ_FmtTime(mtime),
			    file);
		record_stamp(file, mtime);
d818 1
a818 1
		nearmisses++;
d820 4
a823 4
		return file;
	    } else
		free(file);
	}
d825 2
a826 2
	if (DEBUG(DIR))
	    printf("failed. ");
d828 7
a834 6
	if (checkedDot) {
	    /* Already checked by the given name, since . was in the path,
	     * so no point in proceeding...  */
	    if (DEBUG(DIR))
		printf("Checked . already, returning NULL\n");
	    return NULL;
a835 1
    }
d837 14
a850 14
    /* Didn't find it that way, either. Last resort: look for the file
     * in the global mtime cache, then on the disk.
     * If this doesn't succeed, we finally return a NULL pointer.
     *
     * We cannot add this directory onto the search path because
     * of this amusing case:
     * $(INSTALLDIR)/$(FILE): $(FILE)
     *
     * $(FILE) exists in $(INSTALLDIR) but not in the current one.
     * When searching for $(FILE), we will find it in $(INSTALLDIR)
     * b/c we added it here. This is not good...  */
    q = Str_dupi(name, ename);
    if (DEBUG(DIR))
	printf("Looking for \"%s\"...", q);
d853 1
a853 1
    bigmisses++;
d855 7
a861 7
    entry = find_stampi(name, ename);
    if (entry != NULL) {
	if (DEBUG(DIR))
	    printf("got it (in mtime cache)\n");
	return q;
    } else if (stat(q, &stb) == 0) {
	TIMESTAMP mtime;
d863 11
a873 12
	ts_set_from_stat(stb, mtime);
	if (DEBUG(DIR))
	    printf("Caching %s for %s\n", Targ_FmtTime(mtime),
		    q);
	record_stamp(q, mtime);
	return q;
    } else {
	if (DEBUG(DIR))
	    printf("failed. Returning NULL\n");
	free(q);
	return NULL;
    }
d880 4
a883 4
    Path		*p;	/* pointer to new Path structure */
    DIR 		*d;	/* for reading directory */
    struct dirent	*dp;	/* entry in directory */
    unsigned int	slot;
d885 2
a886 2
    slot = ohash_qlookupi(&openDirectories, name, &ename);
    p = ohash_find(&openDirectories, slot);
d888 2
a889 2
    if (p != NULL)
	return p;
d891 1
a891 1
    p = ohash_create_entry(&dir_info, name, &ename);
d893 1
a893 1
    p->hits = 0;
d895 2
a896 2
    p->refCount = 0;
    ohash_init(&p->files, 4, &file_info);
d898 7
a904 18
    if (DEBUG(DIR)) {
	printf("Caching %s...", p->name);
	fflush(stdout);
    }

    if ((d = opendir(p->name)) == NULL)
	return NULL;

    while ((dp = readdir(d)) != NULL) {
	if (dp->d_name[0] == '.' && 
	    (dp->d_name[1] == '\0' || 
	    	(dp->d_name[1] == '.' && dp->d_name[2] == '\0')))
		continue;
	add_file(p, dp->d_name);
    }
    (void)closedir(d);
    if (DEBUG(DIR))
	printf("done\n");
d906 13
a918 2
    ohash_insert(&openDirectories, slot, p);
    return p;
d937 1
a937 1
    Path	*p;	/* pointer to new Path structure */
d939 8
a946 8
    p = DirReaddiri(name, ename);
    if (p == NULL)
	return;
    if (p->refCount == 0)
	Lst_AtEnd(path, p);
    else if (!Lst_AddNew(path, p))
	return;
    p->refCount++;
d965 2
a966 2
    ((Path *)p)->refCount++;
    return p;
d986 2
a987 2
    LstNode	  ln;	  /* the node of the current directory */
    BUFFER	  buf;
d989 1
a989 1
    Buf_Init(&buf, 0);
d991 5
a995 5
    for (ln = Lst_First(path); ln != NULL; ln = Lst_Adv(ln)) {
	    Buf_AddString(&buf, flag);
	    Buf_AddString(&buf, ((Path *)Lst_Datum(ln))->name);
	    Buf_AddSpace(&buf);
    }
d997 1
a997 1
    return Buf_Retrieve(&buf);
d1014 1
a1014 1
    Path	*p = (Path *)pp;
d1016 6
a1021 5
    if (--p->refCount == 0) {
	ohash_remove(&openDirectories, ohash_qlookup(&openDirectories, p->name));
	free_hash(&p->files);
	free(p);
    }
d1037 2
a1038 2
    LstNode	ln;
    Path	*p;
d1040 5
a1044 5
    for (ln = Lst_First(path2); ln != NULL; ln = Lst_Adv(ln)) {
	p = (Path *)Lst_Datum(ln);
	if (Lst_AddNew(path1, p))
	    p->refCount++;
    }
d1051 2
a1052 2
    Path		*p;
    unsigned int	i;
d1054 2
a1055 2
    printf("#*** Directory Cache:\n");
    printf("# Stats: %d hits %d misses %d near misses %d losers (%d%%)\n",
d1059 4
a1062 4
    printf("# %-20s referenced\thits\n", "directory");
    for (p = ohash_first(&openDirectories, &i); p != NULL;
	p = ohash_next(&openDirectories, &i))
	    printf("# %-20s %10d\t%4d\n", p->name, p->refCount, p->hits);
d1069 1
a1069 1
    printf("%s ", ((Path *)p)->name);
d1075 1
a1075 1
    Lst_Every(path, DirPrintDir);
d1081 13
a1093 36
    char	  *fullName;  /* the full pathname of name */
    struct stat   stb;	      /* buffer for finding the mod time */
    struct file_stamp
		  *entry;
    unsigned int  slot;
    TIMESTAMP	  mtime;

    if (gn->type & OP_ARCHV)
	return Arch_MTime(gn);

    if (gn->path == NULL) {
	fullName = Dir_FindFile(gn->name, dirSearchPath);
	if (fullName == NULL)
	    fullName = estrdup(gn->name);
    } else
	fullName = gn->path;

    slot = ohash_qlookup(&mtimes, fullName);
    entry = ohash_find(&mtimes, slot);
    if (entry != NULL) {
	/* Only do this once -- the second time folks are checking to
	 * see if the file was actually updated, so we need to actually go
	 * to the file system.	*/
	if (DEBUG(DIR))
	    printf("Using cached time %s for %s\n",
		    Targ_FmtTime(entry->mtime), fullName);
	mtime = entry->mtime;
	free(entry);
	ohash_remove(&mtimes, slot);
    } else if (stat(fullName, &stb) == 0)
	ts_set_from_stat(stb, mtime);
    else {
	if (gn->type & OP_MEMBER) {
	    if (fullName != gn->path)
		free(fullName);
	    return Arch_MemMTime(gn);
d1095 26
a1120 4
	    ts_set_out_of_date(mtime);
    }
    if (fullName && gn->path == NULL)
	gn->path = fullName;
d1122 2
a1123 2
    gn->mtime = mtime;
    return gn->mtime;
@


1.44
log
@use stdint.h where appropriate. okay millert@@
@
text
@d2 1
a2 1
/*	$OpenBSD: dir.c,v 1.43 2005/06/26 15:19:12 mickey Exp $ */
d637 2
a638 1
Dir_FindFilei(const char *name, const char *ename, Lst path)
d668 4
a671 4
    /* No matter what, we always look for the file in the current directory
     * before anywhere else and we always return exactly what the caller 
     * specified. */
    if ((!hasSlash || (cp - name == 2 && *name == '.')) &&
@


1.43
log
@fail if cwd is not available; pr4265; espie@@ ok
@
text
@d2 1
a2 1
/*	$OpenBSD: dir.c,v 1.42 2004/06/22 19:58:20 espie Exp $ */
a65 1
#include <sys/types.h>
d71 1
d212 1
a212 1
static char *find_file_hashi(Path *, const char *, const char *, u_int32_t);
d283 1
a283 1
find_file_hashi(Path *p, const char *file, const char *efile, u_int32_t hv)
d649 1
a649 1
    u_int32_t		hv;	/* hash value for last component in file name */
@


1.42
log
@why should . and .. be the first two entries of any dir ?
Let code be portable.
okay millert@@
@
text
@d2 1
a2 1
/*	$OpenBSD: dir.c,v 1.41 2004/04/07 13:11:35 espie Exp $ */
d316 1
a316 1
    	Error("Can't access current directory");
@


1.41
log
@ISO function declarations, trim a few comments, rename a few variables to
more explicit/more consistent names.

okay otto@@
@
text
@d2 1
a2 1
/*	$OpenBSD: dir.c,v 1.40 2003/06/03 02:56:11 millert Exp $ */
a883 3
    /* Skip the first two entries -- these will *always* be . and ..  */
    (void)readdir(d);
    (void)readdir(d);
d886 4
a889 7
#if defined(sun) && defined(d_ino) /* d_ino is a sunos4 #define for d_fileno */
	/* The sun directory library doesn't check for a 0 inode
	 * (0-inode slots just take up space), so we have to do
	 * it ourselves.  */
	if (dp->d_fileno == 0)
	    continue;
#endif /* sun && d_ino */
@


1.40
log
@Remove the advertising clause in the UCB license which Berkeley
rescinded 22 July 1999.  Proofed by myself and Theo.
@
text
@d2 1
a2 1
/*	$OpenBSD: dir.c,v 1.39 2003/04/21 23:10:52 espie Exp $ */
d243 1
a243 3
record_stamp(file, t)
    const char		*file;
    TIMESTAMP		t;
d261 1
a261 3
find_stampi(file, end)
    const char	*file;
    const char	*end;
d263 1
a263 1
    return ohash_find(&mtimes, ohash_qlookupi(&mtimes, file, &end));
d267 1
a267 3
add_file(p, file)
    Path		*p;
    const char		*file;
d283 1
a283 5
find_file_hashi(p, file, e, hv)
    Path		*p;
    const char		*file;
    const char		*e;
    u_int32_t		hv;
d287 1
a287 1
    return ohash_find(h, ohash_lookup_interval(h, file, e, hv));
d291 1
a291 2
free_hash(h)
    struct ohash 	*h;
d304 1
a304 1
Dir_Init()
d325 1
a325 1
Dir_End()
d344 1
a344 3
Dir_HasWildcardsi(name, end)
    const char		*name;
    const char 		*end;
d350 1
a350 1
    for (cp = name; cp != end; cp++) {
d392 1
a392 5
DirMatchFilesi(pattern, end, p, expansions)
    const char		*pattern;	/* Pattern to look for */
    const char		*end;		/* End of pattern */
    Path		*p;		/* Directory to search */
    Lst 		expansions;	/* Place to store the results */
d406 1
a406 1
	if (*pattern != '.' && *entry == '.')
d408 1
a408 1
	if (Str_Matchi(entry, strchr(entry, '\0'), pattern, end))
d422 1
a422 5
PathMatchFilesi(word, end, path, expansions)
    const char	*word;		/* Word to expand */
    const char  *end;		/* End of word */
    Lst 	path;		/* Path on which to look */
    Lst 	expansions;	/* Place to store the result */
d427 1
a427 1
	DirMatchFilesi(word, end, (Path *)Lst_Datum(ln), expansions);
d431 1
a431 2
DirPrintWord(word)
    void	*word;
d448 1
a448 6
DirExpandWildi(word, end, path, expansions)
    const char	*word;		/* the word to expand */
    const char  *end;		/* end of word */
    Lst 	path;		/* the list of directories in which to find
				 * the resulting files */
    Lst 	expansions;	/* the list on which to place the results */
d453 1
a453 1
    slash = memchr(word, '/', end - word);
d456 1
a456 1
	DirMatchFilesi(word, end, dot, expansions);
d459 1
a459 1
	PathMatchFilesi(word, end, path, expansions);
d465 1
a465 1
    for (cp = word; cp != end; cp++) {
d490 1
a490 1
		    PathMatchFilesi(slash+1, end, &temp, expansions);
d495 1
a495 1
		PathMatchFilesi(word, end, path, expansions);
d500 1
a500 1
    PathMatchFilesi(word, end, path, expansions);
d514 1
a514 5
DirExpandCurlyi(word, endw, path, expansions)
    const char	*word;		/* Entire word to expand */
    const char  *endw;		/* End of word */
    Lst 	path;		/* Search path to use */
    Lst 	expansions;	/* Place to store the expansions */
d524 1
a524 1
    for (cp2 = word; cp2 != endw; cp2++)
d532 1
a532 1
    Lst_EnQueue(&curled, Str_dupi(word, endw));
d604 1
a604 6
Dir_Expandi(word, end, path, expansions)
    const char	*word;		/* the word to expand */
    const char  *end;		/* end of word */
    Lst 	path;		/* the list of directories in which to find
				 * the resulting files */
    Lst 	expansions;	/* the list on which to place the results */
d609 1
a609 1
    	char *s = Str_dupi(word, end);
d614 1
a614 1
    cp = memchr(word, '{', end - word);
d616 1
a616 1
	DirExpandCurlyi(word, end, path, expansions);
d618 1
a618 1
	DirExpandWildi(word, end, path, expansions);
d637 1
a637 4
Dir_FindFilei(name, end, path)
    const char		*name;
    const char		*end;
    Lst 		path;
d650 1
a650 1
    char		*q;	/* Str_dupi(name, end) */
d654 1
a654 1
    cp = Str_rchri(name, end, '/');
d663 1
a663 1
    hv = ohash_interval(cp, &end);
d671 1
a671 1
	find_file_hashi(dot, cp, end, hv) != NULL) {
d678 1
a678 1
	    return Str_dupi(name, end);
d690 1
a690 1
	if (find_file_hashi(p, cp, end, hv) != NULL) {
d712 1
a712 1
	    file = Str_concati(p->name, strchr(p->name, '\0'), cp, end, '/');
d763 1
a763 1
		file = Str_concati(p->name, strchr(p->name, '\0'), name, end, '/');
d766 1
a766 1
		file = Str_dupi(name, end);
d826 1
a826 1
    q = Str_dupi(name, end);
d833 1
a833 1
    entry = find_stampi(name, end);
d857 1
a857 3
DirReaddiri(name, end)
    const char		*name;
    const char		*end;
d864 1
a864 1
    slot = ohash_qlookupi(&openDirectories, name, &end);
d870 1
a870 1
    p = ohash_create_entry(&dir_info, name, &end);
d920 1
a920 4
Dir_AddDiri(path, name, end)
    Lst 	path;	/* the path to which the directory should be added */
    const char	*name;	/* the name of the directory to add */
    const char	*end;
d924 1
a924 1
    p = DirReaddiri(name, end);
d948 1
a948 2
Dir_CopyDir(p)
    void *p;
d969 1
a969 3
Dir_MakeFlags(flag, path)
    const char	  *flag;  /* flag which should precede each directory */
    Lst 	  path;   /* list of directories */
d997 1
a997 2
Dir_Destroy(pp)
    void	*pp;		/* The directory descriptor to nuke */
d1019 1
a1019 3
Dir_Concat(path1, path2)
    Lst 	path1;		/* Dest */
    Lst 	path2;		/* Source */
d1033 1
a1033 1
Dir_PrintDirectories()
d1051 1
a1051 2
DirPrintDir(p)
    void	*p;
d1057 1
a1057 2
Dir_PrintPath(path)
    Lst path;
d1063 1
a1063 3
Dir_MTime(gn)
    GNode	  *gn;	      /* the file whose modification time is
			       * desired */
@


1.39
log
@build expanded brace with more explicit bound checking.
okay millert@@
@
text
@d2 1
a2 1
/*	$OpenBSD: dir.c,v 1.38 2002/05/27 03:14:21 deraadt Exp $ */
d48 1
a48 5
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
@


1.38
log
@unsigned vs unsigned int
@
text
@d2 1
a2 1
/*	$OpenBSD: dir.c,v 1.37 2001/11/11 12:35:02 espie Exp $ */
d576 3
a578 3
	size_t		otherLen;
				/* The length of the non-curlied part of
				 * the current expansion */
d605 1
a605 1
	otherLen = brace - toexpand + strlen(end);
d621 1
a621 1
	    file = emalloc(otherLen + cp - start + 1);
d626 1
a626 1
	    strcpy(file+(brace-toexpand)+(cp-start), end);
@


1.37
log
@Fixed version... don't see how this could work on i386, since it didn't
initialize create in main.c.
@
text
@d2 1
a2 1
/*	$OpenBSD: dir.c,v 1.36 2001/11/11 06:02:06 deraadt Exp $ */
d251 1
a251 1
    unsigned		slot;
d279 1
a279 1
    unsigned		slot;
d309 1
a309 1
    unsigned		i;
@


1.36
log
@undo changes that crash on (at least) the alpha
@
text
@d2 1
a2 1
/*	$OpenBSD: dir.c,v 1.34 2001/05/29 12:53:39 espie Exp $ */
d323 1
a323 1
    Lst_Init(dirSearchPath);
@


1.35
log
@Redo LstInit as a macro: smaller and faster code in all cases, zeroing two
pointers is simpler than calling a function.
Recognize purely static lst headers, which don't really need any
initialization.
ok miod@@
@
text
@d323 1
a323 1
    Static_Lst_Init(dirSearchPath);
@


1.34
log
@Take includes out of lst.h, re-add what's needed to separate files.
Removes remaining lint stuff from lst.lib.
@
text
@d2 1
a2 1
/*	$OpenBSD: dir.c,v 1.33 2001/05/27 08:34:10 espie Exp $ */
d323 1
a323 1
    Lst_Init(dirSearchPath);
@


1.33
log
@Fix DirExpandCurlyi. Noticed by ho@@. Okay miod@@.
@
text
@d2 1
a2 1
/*	$OpenBSD: dir.c,v 1.32 2001/05/23 12:34:42 espie Exp $ */
d69 1
d73 1
d76 1
d609 1
a609 1
	    const char	*cp;
@


1.32
log
@Mostly clean-up:
- cut up those huge include files into separate interfaces for all modules.
Put the interface documentation there, and not with the implementation.
- light-weight includes for needed concrete types (lst_t.h, timestamp_t.h).
- cut out some more logically separate parts: cmd_exec, varname, parsevar,
timestamp.
- put all error handling functions together, so that we will be able to
clean them up.
- more systematic naming: functioni  to handle interval, function to handle
string.
- put the init/end code apart to minimize coupling.
- kill weird types like ReturnStatus and Boolean. Use standard bool (with a
fallback for non-iso systems)
- better interface documentation for lots of subsystems.

As a result, make compilation goes somewhat faster (5%, even considering
the largish BSD copyrights to read). The corresponding preprocessed
source goes down from 1,5M to 1M.

A few minor code changes as well: Parse_DoVar is no longer destructive.
Parse_IsVar functionality is folded into Parse_DoVar (as it knows what an
assignment is), a few more interval handling functions. Avoid calling
XXX_End when they do nothing, just #define XXX_End   to nothing.

Parse_DoVar is slightly more general: it will handle compound assignments
as long as they make sense, e.g., VAR +!= cmd
will work.  As a side effect, VAR++=value now triggers an error
(two + in assignment).
- this stuff doesn't occur in portable Makefiles.
- writing VAR++ = value or VAR+ +=value  disambiguates it.
- this is a good thing, it uncovered a bug in bsd.port.mk.

Tested by naddy@@. Okayed millert@@. I'll handle the fallback if there is
any. This went through a full make build anyways, including isakmpd
(without mickey's custom binutils, as he didn't see fit to share it with me).
@
text
@d2 1
a2 1
/*	$OpenBSD$ */
a572 1
	const char	*cp;	/* Current position in brace clause */
d585 2
a586 1
	}
d604 1
a604 1
	for (cp = start; cp < end; cp++) {
d606 5
a610 4

		/* Find the end of the current expansion */
	    bracelevel = 0;
	    while (*cp != ',') {
d613 2
a614 3
		else if (*cp == '}' && bracelevel-- <= 0)
		    break;
		cp++;
d616 1
d620 1
a620 1
		memcpy(file, toexpand, brace-word);
d622 1
a622 1
		memcpy(file+(brace-toexpand), start, cp-start);
d625 3
d629 1
@


1.31
log
@Synch with my current work.
Numerous changes:
- generate can build several tables
- style cleanup
- statistics code
- use variable names throughout (struct Name)
- recursive variables everywhere
- faster parser (pass buffer along instead of allocating multiple copies)
- correct parser. Handles comments everywhere, and ; correctly
- more string intervals
- simplified dir.c, less recursion.
- extended for loops
- sinclude()
- finished removing extra junk from Lst_*
- handles ${@@D} and friends in a simpler way
- cleaned up and modular VarModifiers handling.
- recognizes some gnu Makefile usages and errors out about them.

Additionally, some extra functionality is defined by FEATURES. The set of
functionalities is currently hardcoded to OpenBSD defaults, but this may
include support for some NetBSD extensions, like ODE modifiers.

Backed by miod@@ and millert@@, who finally got sick of my endless patches...
@
text
@d69 3
a71 42
/*-
 * dir.c --
 *	Directory searching using wildcards and/or normal names...
 *	Used both for source wildcarding in the Makefile and for finding
 *	implicit sources.
 *
 * The interface for this module is:
 *	Dir_Init	    Initialize the module.
 *
 *	Dir_End 	    Cleanup the module.
 *
 *	Dir_HasWildcards    Returns TRUE if the name given it needs to
 *			    be wildcard-expanded.
 *
 *	Dir_Expand	    Given a pattern and a path, return a Lst of names
 *			    which match the pattern on the search path.
 *
 *	Dir_FindFile	    Searches for a file on a given search path.
 *			    If it exists, the entire path is returned.
 *			    Otherwise NULL is returned.
 *
 *	Dir_MTime	    Return the modification time of a node. The file
 *			    is searched for along the default search path.
 *			    The path and mtime fields of the node are filled
 *			    in.
 *
 *	Dir_AddDir	    Add a directory to a search path.
 *
 *	Dir_MakeFlags	    Given a search path and a command flag, create
 *			    a string with each of the directories in the path
 *			    preceded by the command flag and all of them
 *			    separated by a space.
 *
 *	Dir_Destroy	    Destroy an element of a search path. Frees up all
 *			    things that can be freed for the element as long
 *			    as the element is no longer referenced by any other
 *			    search path.
 *
 * For debugging:
 *	Dir_PrintDirectories	Print stats about the directory cache.
 */

d74 3
a76 4
#include <sys/types.h>
#include <dirent.h>
#include <sys/stat.h>
#include "make.h"
d79 16
a94 7

#ifndef lint
#if 0
static char sccsid[] = "@@(#)dir.c	8.2 (Berkeley) 1/2/94";
#else
UNUSED
static char rcsid[] = "$OpenBSD: dir.c,v 1.9 1999/10/05 22:06:23 espie Exp $";
d96 3
a98 1
#endif /* not lint */
d167 2
a168 1
LIST	      dirSearchPath;		/* main search path */
d170 1
d177 1
d188 6
a193 9
static struct ohash mtimes;  /* Results of doing a last-resort stat in
			     * Dir_FindFile -- if we have to go to the
			     * system to find the file, we might as well
			     * have its mtime on record. XXX: If this is done
			     * way early, there's a chance other rules will
			     * have already updated the file, in which case
			     * we'll update it again. Generally, there won't
			     * be two rules to update a single file, so this
			     * should be ok, but... */
d209 1
a209 1
static void record_stamp(const char *, TIMESTAMP);
d211 6
a216 1
static char *find_file_hash(Path *, const char *, const char *, u_int32_t);
d218 5
d225 12
d238 1
a238 4

static Path *DirReaddir(const char *, const char *);
static void DirMatchFiles(const char *, Path *, Lst);
static void PathMatchFiles(const char *, Lst, Lst);
d240 1
a241 2
static void DirExpandWild(const char *, Lst, Lst);
static void DirExpandCurly(const char *, Lst, Lst);
d290 1
a290 1
find_file_hash(p, file, e, hv)
d313 2
a314 9
/*-
 *-----------------------------------------------------------------------
 * Dir_Init --
 *	initialize things for this module
 *
 * Side Effects:
 *	cache the current directory
 *-----------------------------------------------------------------------
 */
d318 3
a320 1
    Lst_Init(&dirSearchPath);
d324 2
a325 1
    dot = DirReaddir(".", NULL);
d335 1
a335 6
/*-
 *-----------------------------------------------------------------------
 * Dir_End --
 *	cleanup things for this module
 *-----------------------------------------------------------------------
 */
a338 1
#ifdef CLEANUP
d344 1
a344 1
    Lst_Destroy(&dirSearchPath, Dir_Destroy);
d350 1
a351 1
}
d353 6
a358 11
/*-
 *-----------------------------------------------------------------------
 * Dir_HasWildcards  --
 *	see if the given name has any wildcard characters in it
 *	be careful not to expand unmatching brackets or braces.
 *	XXX: This code is not 100% correct. ([^]] fails etc.)
 *-----------------------------------------------------------------------
 */
Boolean
Dir_HasWildcards(name)
    const char		*name;	/* name to check */
d361 1
a361 1
    Boolean		wild = FALSE;
d364 1
a364 1
    for (cp = name; *cp != '\0'; cp++) {
d368 1
a368 1
	    wild = TRUE;
d372 1
a372 1
		return FALSE;
d377 1
a377 1
	    wild = TRUE;
d381 1
a381 1
		return FALSE;
d386 1
a386 1
	    wild = TRUE;
d397 1
a397 1
 * DirMatchFiles --
a402 3
 *
 * Side Effects:
 *	The directory will be fully hashed when this is done.
d406 1
a406 1
DirMatchFiles(pattern, p, expansions)
d408 1
d414 1
a414 1
    Boolean		isDot;		/* Is the directory "." ? */
d426 1
a426 1
	if (Str_Match(entry, pattern))
d428 1
a428 1
		isDot ? estrdup(entry) : str_concat(p->name, entry, '/'));
d434 1
a434 1
 * PathMatchFiles --
d440 1
a440 1
PathMatchFiles(word, path, expansions)
d442 1
d449 1
a449 1
	DirMatchFiles(word, (Path *)Lst_Datum(ln), expansions);
a451 7
/*-
 *-----------------------------------------------------------------------
 * DirPrintWord --
 *	Print a word in the list of expansions. Callback for Dir_Expand
 *	when DEBUG(DIR), via Lst_ForEach.
 *-----------------------------------------------------------------------
 */
d461 1
a461 1
 * DirExpandWild:
d464 4
d471 1
a471 1
DirExpandWild(word, path, expansions)
d473 1
d481 1
a481 1
    slash = strchr(word, '/');
d484 1
a484 1
	DirMatchFiles(word, dot, expansions);
d487 1
a487 1
	PathMatchFiles(word, path, expansions);
d493 1
a493 1
    for (cp = word; *cp; cp++) {
d509 1
a509 1
		    char *dp = &dirpath[strlen(dirpath) - 1];
d512 4
a515 2
		    if (*dp == '/')
			*dp = '\0';
d517 2
a518 2
		    Dir_AddDir(&temp, dirpath, NULL);
		    PathMatchFiles(slash+1, &temp, expansions);
d523 1
a523 1
		PathMatchFiles(word, path, expansions);
d528 1
a528 1
    PathMatchFiles(word, path, expansions);
d536 1
a536 1
 *	Note the special behavior: if curly expansion yields a result with
d542 1
a542 1
DirExpandCurly(word, path, expansions)
d544 1
d552 1
a552 1
    Boolean	dowild; 	/* Wildcard left after curlies ? */
d555 2
a556 2
    dowild = FALSE;
    for (cp2 = word; *cp2 != '\0'; cp2++)
d558 1
a558 1
		dowild = TRUE;
d564 1
a564 1
    Lst_EnQueue(&curled, estrdup(word));
d628 2
a629 14
/*-
 *-----------------------------------------------------------------------
 * Dir_Expand  --
 *	Expand the given word into a list of words by globbing it looking
 *	in the directories on the given search path.
 *
 * Results:
 *	A list of words consisting of the files which exist along the search
 *	path matching the given pattern.
 *
 * Side Effects:
 *	Directories may be opened.
 *-----------------------------------------------------------------------
 */
d631 1
a631 1
Dir_Expand(word, path, expansions)
d633 1
d640 5
a644 2
    if (DEBUG(DIR))
	printf("expanding \"%s\"...", word);
d646 1
a646 1
    cp = strchr(word, '{');
d648 1
a648 1
	DirExpandCurly(word, path, expansions);
d650 1
a650 1
	DirExpandWild(word, path, expansions);
d658 1
a659 8
 *-----------------------------------------------------------------------
 * Dir_FindFilei  --
 *	Find the file with the given name along the given search path.
 *
 * Results:
 *	The path to the file or NULL. This path is guaranteed to be in a
 *	different part of memory than name and so may be safely free'd.
 *
d666 1
a666 2
 *	that directory later on. Sometimes this is true. Sometimes not.
 *-----------------------------------------------------------------------
d670 3
a672 3
    const char		*name;	/* the file to find */
    const char		*end;	/* end of file name */
    Lst 		path;	/* List of directories to search */
d674 1
a679 1
    Path		*p;	/* current path member */
d681 1
a681 1
    Boolean		hasSlash;
d684 2
a685 2
    u_int32_t		hv;
    char		*q;	/* Copy of name, end */
d687 3
a689 3
    /* Find the final component of the name and note whether it has a
     * slash in it (the name, I mean).	*/
    cp = lastchar(name, end, '/');
d691 1
a691 1
	hasSlash = TRUE;
d694 1
a694 1
	hasSlash = FALSE;
d703 2
a704 3
     * before anywhere else and we *do not* add the ./ to it if it exists.
     * This is so there are no conflicts between what the user specifies
     * (fish.c) and what pmake finds (./fish.c).  */
d706 1
a706 1
	find_file_hash(dot, cp, end, hv) != NULL) {
d709 1
d712 2
a713 1
	    return interval_dup(name, end);
d716 5
a720 6
    /* We look through all the directories on the path seeking one which
     * contains the final component of the given name and whose final
     * component(s) match the name's initial component(s). If such a beast
     * is found, we concatenate the directory name and the final component
     * and return the resulting string. If we don't find any such thing,
     * we go on to phase two...  */
d725 1
a725 1
	if (find_file_hash(p, cp, end, hv) != NULL) {
d747 1
a747 1
	    file = str_concati(p->name, cp, end, '/');
d750 1
d753 1
d769 12
a780 10
    /* We didn't find the file on any existing members of the directory.
     * If the name doesn't contain a slash, that means it doesn't exist.
     * If it *does* contain a slash, however, there is still hope: it
     * could be in a subdirectory of one of the members of the search
     * path. (eg. /usr/include and sys/types.h. The above search would
     * fail to turn up types.h in /usr/include, but it *is* in
     * /usr/include/sys/types.h) If we find such a beast, we assume there
     * will be more (what else can we assume?) and add all but the last
     * component of the resulting name onto the search path (at the
     * end). This phase is only performed if the file is *not* absolute.  */
d784 1
d786 1
d791 1
a791 1
	Boolean checkedDot = FALSE;
d798 1
a798 1
		file = str_concati(p->name, name, end, '/');
d801 2
a802 2
		file = interval_dup(name, end);
		checkedDot = TRUE;
d810 1
a810 1
		grab_stat(stb, mtime);
d814 7
a820 7
		/* We've found another directory to search. We know there's
		 * a slash in 'file' because we put one there. We call
		 * Dir_AddDir to add this new directory onto the existing
		 * search path. Once that's done, we return the file name,
		 * knowing that should a file in this directory ever be
		 * referenced again in such a manner, we will find it
		 * without having to do numerous access calls. Hurrah!	*/
d822 1
a822 1
		Dir_AddDir(path, file, temp);
d830 1
d832 1
d850 3
a852 7
    /* Didn't find it that way, either. Sigh. Phase 3. Add its directory
     * onto the search path in any case, just in case, then look for the
     * thing in the hash table. If we find it, grand. We return a new
     * copy of the name. Otherwise we sadly return a NULL pointer. Sigh.
     * Note that if the directory holding the file doesn't exist, this will
     * do an extra search of the final directory on the path. Unless something
     * weird happens, this search won't succeed and life will be groovy.
d854 1
a854 1
     * Sigh. We cannot add the directory onto the search path because
d861 1
a861 16
#ifdef notdef
    Dir_AddDir(path, name, cp-1);

    bigmisses += 1;
    ln = Lst_Last(path);
    if (ln == NULL)
	return NULL;
    else
	p = (Path *)Lst_Datum(ln);

    if (find_file_hash(p, cp, e, hv) != NULL)
	return estrdup(name);
    else
	return NULL;
#else /* !notdef */
    q = interval_dup(name, end);
d865 1
d867 1
d876 1
a876 1
	grab_stat(stb, mtime);
a887 67
#endif /* notdef */
}

/*-
 *-----------------------------------------------------------------------
 * Dir_MTime  --
 *	Find the modification time of the file described by gn along the
 *	search path dirSearchPath.
 *
 * Results:
 *	The modification time or OUT_OF_DATE if it doesn't exist
 *
 * Side Effects:
 *	The modification time is placed in the node's mtime slot.
 *	If the node didn't have a path entry before, and Dir_FindFile
 *	found one for it, the full name is placed in the path slot.
 *-----------------------------------------------------------------------
 */
TIMESTAMP
Dir_MTime(gn)
    GNode	  *gn;	      /* the file whose modification time is
			       * desired */
{
    char	  *fullName;  /* the full pathname of name */
    struct stat   stb;	      /* buffer for finding the mod time */
    struct file_stamp
		  *entry;
    unsigned int  slot;
    TIMESTAMP	  mtime;

    if (gn->type & OP_ARCHV)
	return Arch_MTime(gn);

    if (gn->path == NULL) {
	fullName = Dir_FindFile(gn->name, &dirSearchPath);
	if (fullName == NULL)
	    fullName = estrdup(gn->name);
    } else
	fullName = gn->path;

    slot = ohash_qlookup(&mtimes, fullName);
    entry = ohash_find(&mtimes, slot);
    if (entry != NULL) {
	/* Only do this once -- the second time folks are checking to
	 * see if the file was actually updated, so we need to actually go
	 * to the file system.	*/
	if (DEBUG(DIR))
	    printf("Using cached time %s for %s\n",
		    Targ_FmtTime(entry->mtime), fullName);
	mtime = entry->mtime;
	free(entry);
	ohash_remove(&mtimes, slot);
    } else if (stat(fullName, &stb) == 0)
	grab_stat(stb, mtime);
    else {
	if (gn->type & OP_MEMBER) {
	    if (fullName != gn->path)
		free(fullName);
	    return Arch_MemMTime(gn);
	} else
	    set_out_of_date(mtime);
    }
    if (fullName && gn->path == NULL)
	gn->path = fullName;

    gn->mtime = mtime;
    return gn->mtime;
d892 1
a892 1
DirReaddir(name, end)
d908 1
d910 1
d945 1
a945 1
 * Dir_AddDir --
d957 1
a957 1
Dir_AddDir(path, name, end)
d964 1
a964 1
    p = DirReaddir(name, end);
d969 1
a969 1
    else if (Lst_AddNew(path, p) == FAILURE)
d1072 1
a1072 1
	if (Lst_AddNew(path1, p) == SUCCESS)
d1077 1
a1077 1
/********** DEBUG INFO **********/
d1094 1
d1110 46
a1155 16
#ifndef USE_TIMESPEC
#include <sys/types.h>
#include <utime.h>
#endif
int
set_times(f)
    const char *f;
{
#ifdef USE_TIMESPEC
    struct timeval tv[2];

    TIMESPEC_TO_TIMEVAL(&tv[0], &now);
    TIMESPEC_TO_TIMEVAL(&tv[1], &now);
    return utimes(f, tv);
#else
    struct utimbuf times;
d1157 2
a1158 3
    times.actime = times.modtime = now;
    return utime(f, &times);
#endif
d1160 1
@


1.30
log
@Use the ohash_* that's now in libc.
@
text
@d1 2
a2 1
/*	$OpenBSD: dir.c,v 1.29 2000/11/24 14:36:33 espie Exp $	*/
d6 26
d76 1
a76 1
 *	Dir_Init  	    Initialize the module.
d78 1
a78 1
 *	Dir_End  	    Cleanup the module.
d81 1
a81 1
 *	    	  	    be wildcard-expanded.
d84 1
a84 1
 *	    	  	    which match the pattern on the search path.
d87 2
a88 2
 *	    	  	    If it exists, the entire path is returned.
 *	    	  	    Otherwise NULL is returned.
d90 4
a93 4
 *	Dir_MTime 	    Return TRUE if node exists. The file
 *	    	  	    is searched for along the default search path.
 *	    	  	    The path and mtime fields of the node are filled
 *	    	  	    in.
d98 3
a100 3
 *	    	  	    a string with each of the directories in the path
 *	    	  	    preceded by the command flag and all of them
 *	    	  	    separated by a space.
d103 3
a105 4
 *	    	  	    things that can be freed for the element as long
 *	    	  	    as the element is no longer referenced by any other
 *	    	  	    search path.
 *	Dir_ClearPath	    Resets a search path to the empty list.
d125 1
a125 1
static char rcsid[] = "$OpenBSD: dir.c,v 1.29 2000/11/24 14:36:33 espie Exp $";
d129 1
a129 2
/*
 *	A search path consists of a Lst of Path structures. A Path structure
d194 1
a194 2
 *	in a cache for when Dir_MTime was actually called.
 */
d196 1
a196 1
LIST          dirSearchPath;	/* main search path */
d198 6
a203 1
static struct ohash   openDirectories;	/* cache all open directories */
d205 1
a205 10
/*
 * Variables for gathering statistics on the efficiency of the hashing
 * mechanism.
 */
static int    hits,	      /* Found in directory cache */
	      misses,	      /* Sad, but not evil misses */
	      nearmisses,     /* Found under search path */
	      bigmisses;      /* Sought by itself */

static Path    	  *dot;	    /* contents of current directory */
d212 2
d224 1
d232 1
a232 1
static struct ohash_info file_info = { 0, 
d235 1
a235 1
static struct ohash_info dir_info = { offsetof(Path, name), 
d238 15
a252 12
static void record_stamp __P((const char *, TIMESTAMP));
static void add_file __P((Path *, const char *));
static char *find_file_hash __P((Path *, const char *, const char *, u_int32_t));
static struct file_stamp *find_stamp __P((const char *));
static void free_hash __P((struct ohash *));

static Path *DirReaddir __P((const char *, const char *));
static void DirMatchFiles __P((char *, Path *, Lst));
static void DirExpandCurly __P((char *, char *, Lst, Lst));
static void DirExpandInt __P((char *, Lst, Lst));
static void DirPrintWord __P((void *));
static void DirPrintDir __P((void *));
d256 2
a257 2
    const char 		*file;
    TIMESTAMP 		t;
d259 3
a261 3
    unsigned 		slot;
    const char 		*end = NULL;
    struct file_stamp 	*n;
d273 1
a273 1
		
d275 3
a277 2
find_stamp(file)
    const char 		*file;
d279 1
a279 1
    return ohash_find(&mtimes, ohash_qlookup(&mtimes, file));
d284 2
a285 2
    Path 		*p;
    const char 		*file;
d287 4
a290 4
    unsigned 		slot;
    const char 		*end = NULL;
    char 		*n;
    struct ohash	*h = &p->files;
d299 1
a299 1
		
d303 2
a304 2
    const char 		*file;
    const char 		*e;
d316 2
a317 2
    void 		*e;
    unsigned 		i;
a328 3
 * Results:
 *	none
 *
d330 1
a330 1
 *	some directories may be opened.
d342 3
d346 1
a346 1
     * to make sure it's not destroyed.  */
a353 6
 *
 * Results:
 *	none
 *
 * Side Effects:
 *	none
d367 1
a367 1
    	p = ohash_next(&openDirectories, &i))
d383 2
a384 2
Dir_HasWildcards (name)
    const char          *name;	/* name to check */
d386 2
a387 2
    const char 		*cp;
    Boolean 		wild = FALSE;
d390 1
a390 1
    for (cp = name; *cp != '\0' ; cp++) {
d398 1
a398 1
	    	return FALSE;
d407 1
a407 1
	    	return FALSE;
d424 1
a424 1
 * 	Given a pattern and a Path structure, see if any files
d431 1
a431 2
 *	File names are added to the expansions lst. The directory will be
 *	fully hashed when this is done.
d435 8
a442 8
DirMatchFiles (pattern, p, expansions)
    char	  *pattern;   	/* Pattern to look for */
    Path	  *p;         	/* Directory to search */
    Lst	    	  expansions;	/* Place to store the results */
{
    unsigned int  search;   	/* Index into the directory's table */
    char          *entry; 	/* Current entry in the table */
    Boolean 	  isDot;    	/* TRUE if the directory being searched is . */
d444 1
a444 1
    isDot = (*p->name == '.' && p->name[1] == '\0');
d448 1
a448 1
	/* See if the file matches the given pattern. Note we follow the UNIX
d450 4
a453 4
	 * begins with a dot (note also that as a side effect of the hashing
	 * scheme, .* won't match . or .. since they aren't hashed).  */
	if (*pattern != '.' && * entry == '.')
		continue;
d456 1
a456 2
			    (isDot ? estrdup(entry) :
			     str_concat(p->name, entry, '/')));
d462 3
a464 12
 * DirExpandCurly --
 *	Expand curly braces like the C shell. Does this recursively.
 *	Note the special case: if after the piece of the curly brace is
 *	done there are no wildcard characters in the result, the result is
 *	placed on the list WITHOUT CHECKING FOR ITS EXISTENCE.
 *
 * Results:
 *	None.
 *
 * Side Effects:
 *	The given list is filled with the expansions...
 *
d468 6
a473 18
DirExpandCurly(word, brace, path, expansions)
    char    	  *word;    	/* Entire word to expand */
    char    	  *brace;   	/* First curly brace in it */
    Lst	    	  path;	    	/* Search path to use */
    Lst	    	  expansions;	/* Place to store the expansions */
{
    char    	  *end;	    	/* Character after the closing brace */
    char    	  *cp;	    	/* Current position in brace clause */
    char    	  *start;   	/* Start of current piece of brace clause */
    int	    	  bracelevel;	/* Number of braces we've seen. If we see a
				 * right brace when this is 0, we've hit the
				 * end of the clause. */
    char    	  *file;    	/* Current expansion */
    int	    	  otherLen; 	/* The length of the other pieces of the
				 * expansion (chars before and after the
				 * clause in 'word') */
    char    	  *cp2;	    	/* Pointer for checking for wildcards in
				 * expansion before calling Dir_Expand */
d475 3
a477 1
    start = brace+1;
d479 12
a490 71
    /*
     * Find the end of the brace clause first, being wary of nested brace
     * clauses.
     */
    for (end = start, bracelevel = 0; *end != '\0'; end++) {
	if (*end == '{') {
	    bracelevel++;
	} else if ((*end == '}') && (bracelevel-- == 0)) {
	    break;
	}
    }
    if (*end == '\0') {
	Error("Unterminated {} clause \"%s\"", start);
	return;
    } else {
	end++;
    }
    otherLen = brace - word + strlen(end);

    for (cp = start; cp < end; cp++) {
	/*
	 * Find the end of this piece of the clause.
	 */
	bracelevel = 0;
	while (*cp != ',') {
	    if (*cp == '{') {
		bracelevel++;
	    } else if ((*cp == '}') && (bracelevel-- <= 0)) {
		break;
	    }
	    cp++;
	}
	/*
	 * Allocate room for the combination and install the three pieces.
	 */
	file = emalloc(otherLen + cp - start + 1);
	if (brace != word) {
	    strncpy(file, word, brace-word);
	}
	if (cp != start) {
	    strncpy(&file[brace-word], start, cp-start);
	}
	strcpy(&file[(brace-word)+(cp-start)], end);

	/*
	 * See if the result has any wildcards in it. If we find one, call
	 * Dir_Expand right away, telling it to place the result on our list
	 * of expansions.
	 */
	for (cp2 = file; *cp2 != '\0'; cp2++) {
	    switch(*cp2) {
	    case '*':
	    case '?':
	    case '{':
	    case '[':
		Dir_Expand(file, path, expansions);
		goto next;
	    }
	}
	if (*cp2 == '\0') {
	    /*
	     * Hit the end w/o finding any wildcards, so stick the expansion
	     * on the end of the list.
	     */
	    Lst_AtEnd(expansions, file);
	} else {
	next:
	    free(file);
	}
	start = cp+1;
    }
a492 1

d495 3
a497 8
 * DirExpandInt --
 *	Internal expand routine. Passes through the directories in the
 *	path one by one, calling DirMatchFiles for each. NOTE: This still
 *	doesn't handle patterns in directories...
 *
 * Side Effects:
 *	Things are added to the expansions list.
 *
d501 13
a513 7
DirExpandInt(word, path, expansions)
    char    	  *word;    	/* Word to expand */
    Lst	    	  path;	    	/* Path on which to look */
    Lst	    	  expansions;	/* Place to store the result */
{
    LstNode 	  ln;	    	/* Current node */
    Path	  *p;	    	/* Directory in the node */
d515 38
a552 4
    Lst_Open(path);
    while ((ln = Lst_Next(path)) != NULL) {
	p = (Path *)Lst_Datum(ln);
	DirMatchFiles(word, p, expansions);
d554 2
a555 1
    Lst_Close(path);
d560 6
a565 3
 * DirPrintWord --
 *	Print a word in the list of expansions, followed by a space. 
 *	Callback for Dir_Expand when DEBUG(DIR), via Lst_ForEach.
d569 4
a572 2
DirPrintWord(word)
    void *word;
d574 78
a651 1
    printf("%s ", (char *)word);
d665 1
a665 1
 *	Directories may be opened. Who knows?
d669 5
a673 5
Dir_Expand (word, path, expansions)
    char    *word;      /* the word to expand */
    Lst     path;   	/* the list of directories in which to find
			 * the resulting files */
    Lst	    expansions;	/* the list on which to place the results */
d675 1
a675 1
    char    	  *cp;
d677 1
a677 1
    if (DEBUG(DIR)) {
a678 1
    }
d681 4
a684 61
    if (cp) {
	DirExpandCurly(word, cp, path, expansions);
    } else {
	cp = strchr(word, '/');
	if (cp) {
	    /*
	     * The thing has a directory component -- find the first wildcard
	     * in the string.
	     */
	    for (cp = word; *cp; cp++) {
		if (*cp == '?' || *cp == '[' || *cp == '*' || *cp == '{') {
		    break;
		}
	    }
	    if (*cp == '{') {
		/* This one will be fun.  */
		DirExpandCurly(word, cp, path, expansions);
		return;
	    } else if (*cp != '\0') {
		/* Back up to the start of the component.  */
		char  *dirpath;

		while (cp > word && *cp != '/')
		    cp--;
		if (cp != word) {
		    char sc;
		    /*
		     * If the glob isn't in the first component, try and find
		     * all the components up to the one with a wildcard.
		     */
		    sc = cp[1];
		    cp[1] = '\0';
		    dirpath = Dir_FindFile(word, path);
		    cp[1] = sc;
		    /*
		     * dirpath is null if can't find the leading component
		     * XXX: Dir_FindFile won't find internal components.
		     * i.e. if the path contains ../Etc/Object and we're
		     * looking for Etc, it won't be found. Ah well.
		     * Probably not important.
		     */
		    if (dirpath != NULL) {
		    	LIST temp;

			char *dp = &dirpath[strlen(dirpath) - 1];
			if (*dp == '/')
			    *dp = '\0';
			Lst_Init(&temp);
			Dir_AddDir(&temp, dirpath, NULL);
			DirExpandInt(cp+1, &temp, expansions);
			Lst_Destroy(&temp, NOFREE);
		    }
		} else
		    /* Start the search from the local directory.  */
		    DirExpandInt(word, path, expansions);
	    } else
		/* Return the file -- this should never happen.  */
		DirExpandInt(word, path, expansions);
	} else {
	    /* First the files in dot.  */
	    DirMatchFiles(word, dot, expansions);
a685 4
	    /* Then the files in every other directory on the path.  */
	    DirExpandInt(word, path, expansions);
	}
    }
d694 1
a694 1
 * Dir_FindFile  --
d711 21
a731 22
Dir_FindFile(name, path)
    char    	  *name;    /* the file to find */
    Lst           path;	    /* the Lst of directories to search */
{
    register char *p1;	    /* pointer into p->name */
    register char *p2;	    /* pointer into name */
    LstNode       ln;	    /* a list element */
    register char *file;    /* the current filename to check */
    register Path *p;	    /* current path member */
    register char *cp;	    /* index of first slash, if any */
    Boolean	  hasSlash; /* true if 'name' contains a / */
    struct stat	  stb;	    /* Buffer for stat, if necessary */
    struct file_stamp
    		  *entry;   /* Entry for mtimes table */
    const char	  *e;
    u_int32_t	  hv;

    /*
     * Find the final component of the name and note whether it has a
     * slash in it (the name, I mean)
     */
    cp = strrchr(name, '/');
d734 1
a734 1
	cp += 1;
d740 1
a740 2
    e = NULL;
    hv = ohash_interval(cp, &e);
d742 1
a742 1
    if (DEBUG(DIR)) {
d744 1
a744 3
    }
    /*
     * No matter what, we always look for the file in the current directory
d747 1
a747 2
     * (fish.c) and what pmake finds (./fish.c).
     */
d749 1
a749 1
	find_file_hash(dot, cp, e, hv) != NULL) {
d752 3
a754 3
	    hits += 1;
	    dot->hits += 1;
	    return (estrdup (name));
d757 1
a757 2
    /*
     * We look through all the directories on the path seeking one which
d762 1
a762 2
     * we go on to phase two...
     */
d767 1
a767 1
	if (find_file_hash(p, cp, e, hv) != NULL) {
d771 1
a771 2
		/*
		 * If the name had a slash, its initial components and p's
d776 2
a777 3
		 * along with all the rest of them (*p1 != '/').
		 */
		p1 = p->name + strlen (p->name) - 1;
d780 2
a781 1
		    p1 -= 1; p2 -= 1;
d789 1
a789 1
	    file = str_concat(p->name, cp, '/');
d792 2
a793 2
	    p->hits += 1;
	    hits += 1;
d799 1
a799 1
	    for (p1 = p->name, p2 = name; *p1 && *p1 == *p2; p1++, p2++) {
a800 1
	    }
d803 1
a803 1
		    printf("must be here but isn't -- returing NULL\n");
d822 1
a822 1
	misses += 1;
d827 1
a827 1
	Boolean	checkedDot = FALSE;
a830 1
	Lst_Open(path);
d834 1
a834 1
		file = str_concat(p->name, name, '/');
d837 1
a837 1
		file = estrdup(name);
d844 1
a844 1
	    	TIMESTAMP mtime;
d851 1
a851 1
		 * a slash in 'file' because we put one there. We call 
d853 2
a854 2
		 * search path. Once that's done, we return the file name, 
		 * knowing that should a file in this directory ever be 
d856 3
a858 3
		 * without having to do numerous access calls. Hurrah!  */
		cp = strrchr(file, '/');
		Dir_AddDir(path, file, cp);
d866 1
a866 1
		nearmisses += 1;
d874 1
d910 1
a910 1
	return estrdup (name);
d914 1
d916 1
a916 1
	printf("Looking for \"%s\"...", name);
d918 2
a919 2
    bigmisses += 1;
    entry = find_stamp(name);
d923 3
a925 3
	return estrdup(name);
    } else if (stat(name, &stb) == 0) {
    	TIMESTAMP mtime;
d930 3
a932 3
		    name);
	record_stamp(name, mtime);
	return estrdup(name);
d936 1
d959 1
a959 1
    GNode         *gn;	      /* the file whose modification time is
d962 2
a963 2
    char          *fullName;  /* the full pathname of name */
    struct stat	  stb;	      /* buffer for finding the mod time */
d965 1
a965 1
    	          *entry;
d971 1
d984 1
a984 1
	 * to the file system.  */
d992 1
a992 1
    	grab_stat(stb, mtime);
d1011 2
a1012 2
    const char 		*name;
    const char 		*end;
d1014 4
a1017 4
    Path          	*p;	/* pointer to new Path structure */
    DIR     	  	*d;	/* for reading directory */
    struct dirent 	*dp;	/* entry in directory */
    unsigned int      	slot;
d1035 2
a1036 2
    if ((d = opendir(p->name)) == NULL) 
    	return NULL;
d1071 1
d1074 1
a1074 2
    Lst		path;	/* the path to which the directory should be
			 * added */
d1082 1
a1082 1
    	return;
d1084 3
a1086 5
    	Lst_AtEnd(path, p);
    else if (Lst_Member(path, p) != NULL)
    	return;
    else
    	Lst_AtEnd(path, p);
a1100 1
 *
d1107 1
a1107 2
    ((Path *)p)->refCount += 1;

a1122 3
 *
 * Side Effects:
 *	None
d1127 2
a1128 2
    char	  *flag;  /* flag which should precede each directory */
    Lst	    	  path;	  /* list of directories */
a1149 3
 * Results:
 *	None.
 *
a1152 1
 *
d1156 2
a1157 2
Dir_Destroy (pp)
    void *pp;	    /* The directory descriptor to nuke */
d1159 1
a1159 1
    Path    	  *p = (Path *) pp;
d1162 1
a1162 1
    	ohash_remove(&openDirectories, ohash_qlookup(&openDirectories, p->name));
a1169 24
 * Dir_ClearPath --
 *	Clear out all elements of the given search path. This is different
 *	from destroying the list, notice.
 *
 * Results:
 *	None.
 *
 * Side Effects:
 *	The path is set to the empty list.
 *
 *-----------------------------------------------------------------------
 */
void
Dir_ClearPath(path)
    Lst	    path; 	/* Path to clear */
{
    Path    *p;
    while ((p = (Path *)Lst_DeQueue(path)) != NULL)
	Dir_Destroy(p);
}


/*-
 *-----------------------------------------------------------------------
a1173 3
 * Results:
 *	None
 *
a1175 1
 *
d1180 2
a1181 2
    Lst	    path1;  	/* Dest */
    Lst	    path2;  	/* Source */
d1183 2
a1184 2
    LstNode ln;
    Path    *p;
d1188 2
a1189 4
	if (Lst_Member(path1, p) == NULL) {
	    p->refCount += 1;
	    Lst_AtEnd(path1, p);
	}
d1197 2
a1198 2
    Path	*p;
    unsigned int i;
d1200 2
a1201 2
    printf ("#*** Directory Cache:\n");
    printf ("# Stats: %d hits %d misses %d near misses %d losers (%d%%)\n",
d1205 1
a1205 1
    printf ("# %-20s referenced\thits\n", "directory");
d1207 1
a1207 1
    	p = ohash_next(&openDirectories, &i))
d1211 1
a1211 1
static void 
d1213 1
a1213 1
    void *p;
d1220 1
a1220 1
    Lst	path;
@


1.29
log
@Change the time stamp interface to use an abstract datatype.
Define two possible interfaces: the classic one,
and the new one (used where available) that depends on timespec.

Better granularity, make is now able to distinguish between files that
were built during the same second.
@
text
@d1 1
a1 1
/*	$OpenBSD: dir.c,v 1.28 2000/11/24 14:27:19 espie Exp $	*/
d99 1
a99 1
static char rcsid[] = "$OpenBSD: dir.c,v 1.28 2000/11/24 14:27:19 espie Exp $";
d174 1
a174 1
static struct hash   openDirectories;	/* cache all open directories */
d192 1
a192 1
static struct hash mtimes;  /* Results of doing a last-resort stat in
d206 1
a206 1
static struct hash_info stamp_info = { offsetof(struct file_stamp, name),
d209 1
a209 1
static struct hash_info file_info = { 0, 
d212 1
a212 1
static struct hash_info dir_info = { offsetof(Path, name), 
d219 1
a219 1
static void free_hash __P((struct hash *));
d237 2
a238 2
    slot = hash_qlookupi(&mtimes, file, &end);
    n = hash_find(&mtimes, slot);
d242 1
a242 1
	n = hash_create_entry(&stamp_info, file, &end);
d244 1
a244 1
	hash_insert(&mtimes, slot, n);
d252 1
a252 1
    return hash_find(&mtimes, hash_qlookup(&mtimes, file));
d263 1
a263 1
    struct hash		*h = &p->files;
d265 2
a266 2
    slot = hash_qlookupi(h, file, &end);
    n = hash_find(h, slot);
d268 2
a269 2
	n = hash_create_entry(&file_info, file, &end);
	hash_insert(h, slot, n);
d280 1
a280 1
    struct hash 	*h = &p->files;
d282 1
a282 1
    return hash_find(h, hash_lookup_interval(h, file, e, hv));
d287 1
a287 1
    struct hash 	*h;
d292 1
a292 1
    for (e = hash_first(h, &i); e != NULL; e = hash_next(h, &i))
d294 1
a294 1
    hash_delete(h);
d313 2
a314 2
    hash_init(&openDirectories, 4, &dir_info);
    hash_init(&mtimes, 4, &stamp_info);
d345 2
a346 2
    for (p = hash_first(&openDirectories, &i); p != NULL;
    	p = hash_next(&openDirectories, &i))
d348 1
a348 1
    hash_delete(&openDirectories);
d426 2
a427 2
    for (entry = hash_first(&p->files, &search); entry != NULL;
	 entry = hash_next(&p->files, &search)) {
d746 1
a746 1
    hv = hash_interval(cp, &e);
d989 2
a990 2
    slot = hash_qlookup(&mtimes, fullName);
    entry = hash_find(&mtimes, slot);
d1000 1
a1000 1
	hash_remove(&mtimes, slot);
d1029 2
a1030 2
    slot = hash_qlookupi(&openDirectories, name, &end);
    p = hash_find(&openDirectories, slot);
d1035 1
a1035 1
    p = hash_create_entry(&dir_info, name, &end);
d1038 1
a1038 1
    hash_init(&p->files, 4, &file_info);
d1065 1
a1065 1
    hash_insert(&openDirectories, slot, p);
d1183 1
a1183 1
    	hash_remove(&openDirectories, hash_qlookup(&openDirectories, p->name));
d1257 2
a1258 2
    for (p = hash_first(&openDirectories, &i); p != NULL;
    	p = hash_next(&openDirectories, &i))
@


1.28
log
@Clean-ups:
* Buf_Destroy can be a macro
* X_ instead of _X for struct names, to avoid infringing on the system's
namespace.
* better wildcard detection heuristics
* fix #ifdef CLEANUP code
* a few comments
@
text
@d1 1
a1 1
/*	$OpenBSD: dir.c,v 1.27 2000/09/14 13:52:41 espie Exp $	*/
d99 1
a99 1
static char rcsid[] = "$OpenBSD: dir.c,v 1.27 2000/09/14 13:52:41 espie Exp $";
d877 1
a877 1
		    printf("Caching %s for %s\n", Targ_FmtTime(stb.st_mtime),
d941 1
a941 1
	    printf("Caching %s for %s\n", Targ_FmtTime(stb.st_mtime),
d1007 1
a1007 1
	    return Arch_MemMTime (gn);
d1274 22
@


1.27
log
@Introduce a few macros to handle timestamps in an abstract way.

Replace the time stamp hash in dir.c with an open hashing structure.

In doing so, remove some nasty casts, simplify code a bit:
Dir_MTime can return a modification time, since make does not make
a distinction between out-of-date and non-existent files.
@
text
@d1 1
a1 1
/*	$OpenBSD: dir.c,v 1.26 2000/09/14 13:46:44 espie Exp $	*/
d99 1
a99 1
static char rcsid[] = "$OpenBSD: dir.c,v 1.26 2000/09/14 13:46:44 espie Exp $";
d349 1
a349 1
    Hash_DeleteTable(&mtimes);
a358 9
 *	I really don't think that make(1) should be expanding
 *	patterns, because then you have to set a mechanism for
 *	escaping the expansion!
 *
 * Results:
 *	returns TRUE if the word should be expanded, FALSE otherwise
 *
 * Side Effects:
 *	none
d363 1
a363 1
    char          *name;	/* name to check */
d365 3
a367 2
    register char *cp;
    int wild = 0, brace = 0, bracket = 0;
d369 2
a370 2
    for (cp = name; *cp; cp++) {
	switch(*cp) {
d373 1
a373 1
	    wild = 1;
d376 2
d382 1
a382 1
	    wild = 1;
d385 2
d391 1
a391 1
	    wild = 1;
d397 1
a397 1
    return (wild && bracket == 0 && brace == 0);
@


1.26
log
@Replace the old hash used to hold file names within a directory with
open hashing.

An interesting optimization is that the open hashing interface is more
fine-grained, hence we can compute the correct hash value at the start
of Dir_FindFile, and reuse it for each hash structure into which we look
(the effect is measurable on large directories along with objdir/VPATH).

Remove a few unnecessary Lst_Open/Lst_Close that serve no purpose except
obfuscating the code.

The interface to dir.h changes slightly, hence tedious includes changes...
@
text
@d1 1
a1 1
/*	$OpenBSD: dir.c,v 1.25 2000/09/14 13:43:30 espie Exp $	*/
a90 1
#include "hash.h"
d99 1
a99 1
static char rcsid[] = "$OpenBSD: dir.c,v 1.25 2000/09/14 13:43:30 espie Exp $";
d186 7
a192 1
static Hash_Table mtimes;   /* Results of doing a last-resort stat in
d202 7
d215 1
d218 1
d229 27
d314 1
a314 1
    Hash_InitTable(&mtimes, 0);
d731 2
a734 1
    Hash_Entry	  *entry;
d862 3
d883 1
a883 4
		entry = Hash_CreateEntry(&mtimes, (char *) file,
					 (Boolean *)NULL);
		/* XXX */
		Hash_SetValue(entry, (void *)((long)stb.st_mtime));
d935 2
a936 2
    entry = Hash_FindEntry(&mtimes, name);
    if (entry != (Hash_Entry *)NULL) {
d941 3
a943 1
	entry = Hash_CreateEntry(&mtimes, name, (Boolean *)NULL);
d947 1
a947 2
	/* XXX */
	Hash_SetValue(entry, (void *)(long)stb.st_mtime);
d964 1
a964 1
 *	TRUE if file exists.
d972 1
a972 1
Boolean
d979 4
a982 2
    Hash_Entry	  *entry;
    Boolean 	  exists;
d986 1
a986 1
    else if (gn->path == NULL)
d988 3
a990 1
    else
d993 4
a996 8
    if (fullName == (char *)NULL) {
	fullName = estrdup(gn->name);
    }

    entry = Hash_FindEntry(&mtimes, fullName);
    if (entry != (Hash_Entry *)NULL) {
	/*
	 * Only do this once -- the second time folks are checking to
d998 2
a999 3
	 * to the file system.
	 */
	if (DEBUG(DIR)) {
d1001 7
a1007 12
		    Targ_FmtTime((time_t)(long)Hash_GetValue(entry)), fullName);
	}
	stb.st_mtime = (time_t)(long)Hash_GetValue(entry);
	Hash_DeleteEntry(&mtimes, entry);
	exists = TRUE;
    } else if (stat (fullName, &stb) == 0) {
    	/* XXX forces make to differentiate between the epoch and
	 * non-existent files by kludging the timestamp slightly. */
    	if (stb.st_mtime == OUT_OF_DATE)
		stb.st_mtime++;
	exists = TRUE;
    } else {
d1012 2
a1013 4
	} else {
	    stb.st_mtime = OUT_OF_DATE;
	    exists = FALSE;
	}
d1015 1
a1015 1
    if (fullName && gn->path == (char *)NULL) {
a1016 1
    }
d1018 2
a1019 2
    gn->mtime = stb.st_mtime;
    return exists;
@


1.25
log
@- new DirReadDir internal function, that just reads a directory from
the disk or from a cache.
- use it in Dir_AddDir, and directly to set up dot.
- change Dir_AddDir to use string intervals, as this simplifies
dependend functions.
- set up an open-hashing cache for opened directory names.
- add_dirpath() function in main, to simplify code.
- simplify cleaning-up directories, as Dir_ClearPath is overkill.
@
text
@d1 1
a1 1
/*	$OpenBSD: dir.c,v 1.24 2000/09/14 13:32:06 espie Exp $	*/
d100 1
a100 1
static char rcsid[] = "$OpenBSD: dir.c,v 1.24 2000/09/14 13:32:06 espie Exp $";
d197 3
d203 4
d208 1
a208 1
static int DirMatchFiles __P((char *, Path *, Lst));
d214 42
a371 3
 * Results:
 *	Always returns 0
 *
d377 1
a377 1
static int
d383 2
a384 2
    Hash_Search	  search;   	/* Index into the directory's table */
    Hash_Entry	  *entry;   	/* Current entry in the table */
d389 3
a391 6
    for (entry = Hash_EnumFirst(&p->files, &search);
	 entry != (Hash_Entry *)NULL;
	 entry = Hash_EnumNext(&search))
    {
	/*
	 * See if the file matches the given pattern. Note we follow the UNIX
d394 4
a397 6
	 * scheme, .* won't match . or .. since they aren't hashed).
	 */
	if (Str_Match(entry->name, pattern) &&
	    ((entry->name[0] != '.') ||
	     (pattern[0] == '.')))
	{
d399 2
a400 3
			    (isDot ? estrdup(entry->name) :
			     str_concat(p->name, entry->name, '/')));
	}
a401 1
    return (0);
a522 3
 * Results:
 *	None.
 *
d678 1
a678 1
Dir_FindFile (name, path)
d690 3
a692 1
    Hash_Entry	  *entry;   /* Entry for mtimes table */
d698 1
a698 1
    cp = strrchr (name, '/');
d707 3
d720 2
a721 2
	(Hash_FindEntry (&dot->files, cp) != (Hash_Entry *)NULL)) {
	    if (DEBUG(DIR)) {
a722 1
	    }
a727 2
    Lst_Open(path);

d736 1
a736 1
    while ((ln = Lst_Next (path)) != NULL) {
d738 1
a738 1
	if (DEBUG(DIR)) {
d740 2
a741 3
	}
	if (Hash_FindEntry (&p->files, cp) != (Hash_Entry *)NULL) {
	    if (DEBUG(DIR)) {
a742 1
	    }
d758 1
a758 1
		    if (DEBUG(DIR)) {
a759 1
		    }
d764 1
a764 1
	    if (DEBUG(DIR)) {
a765 2
	    }
	    Lst_Close (path);
d768 1
a768 1
	    return (file);
d770 1
a770 2
	    /*
	     * If the file has a leading path component and that component
d772 1
a772 2
	     * directory, we assume the file doesn't exist and return NULL.
	     */
d777 1
a777 1
		if (DEBUG(DIR)) {
d779 1
a779 3
		}
		Lst_Close (path);
		return ((char *) NULL);
d784 1
a784 2
    /*
     * We didn't find the file on any existing members of the directory.
d793 1
a793 2
     * end). This phase is only performed if the file is *not* absolute.
     */
d795 1
a795 1
	if (DEBUG(DIR)) {
a796 1
	}
d798 1
a798 1
	return ((char *) NULL);
d804 1
a804 1
	if (DEBUG(DIR)) {
a805 1
	}
d807 1
a807 1
	while ((ln = Lst_Next (path)) != NULL) {
d809 1
a809 1
	    if (p != dot) {
d811 2
a812 4
	    } else {
		/*
		 * Checking in dot -- DON'T put a leading ./ on the thing.
		 */
d816 1
a816 1
	    if (DEBUG(DIR)) {
a817 1
	    }
d819 2
a820 3

	    if (stat (file, &stb) == 0) {
		if (DEBUG(DIR)) {
a821 1
		}
d823 7
a829 12
		Lst_Close (path);

		/*
		 * We've found another directory to search. We know there's
		 * a slash in 'file' because we put one there. We nuke it after
		 * finding it and call Dir_AddDir to add this new directory
		 * onto the existing search path. Once that's done, we restore
		 * the slash and triumphantly return the file name, knowing
		 * that should a file in this directory every be referenced
		 * again in such a manner, we will find it without having to do
		 * numerous numbers of access calls. Hurrah!
		 */
d833 3
a835 5
		/*
		 * Save the modification time so if it's needed, we don't have
		 * to fetch it again.
		 */
		if (DEBUG(DIR)) {
a837 1
		}
d843 3
a845 4
		return (file);
	    } else {
		free (file);
	    }
d848 1
a848 1
	if (DEBUG(DIR)) {
a849 3
	}
	Lst_Close (path);

d851 3
a853 5
	    /*
	     * Already checked by the given name, since . was in the path,
	     * so no point in proceeding...
	     */
	    if (DEBUG(DIR)) {
d855 1
a855 2
	    }
	    return(NULL);
d859 1
a859 2
    /*
     * Didn't find it that way, either. Sigh. Phase 3. Add its directory
d873 1
a873 2
     * b/c we added it here. This is not good...
     */
d884 4
a887 5
    if (Hash_FindEntry (&p->files, cp) != (Hash_Entry *)NULL) {
	return (estrdup (name));
    } else {
	return ((char *) NULL);
    }
d889 1
a889 1
    if (DEBUG(DIR)) {
a890 1
    }
d895 1
a895 1
	if (DEBUG(DIR)) {
d897 2
a898 3
	}
	return(estrdup(name));
    } else if (stat (name, &stb) == 0) {
d900 1
a900 1
	if (DEBUG(DIR)) {
a902 1
	}
d905 1
a905 1
	return (estrdup (name));
d907 1
a907 1
	if (DEBUG(DIR)) {
d909 1
a909 2
	}
	return ((char *)NULL);
d1008 1
a1008 1
    Hash_InitTable(&p->files, -1);
d1029 1
a1029 1
	(void)Hash_CreateEntry(&p->files, dp->d_name, (Boolean *)NULL);
d1154 1
a1154 1
	Hash_DeleteTable (&p->files);
@


1.24
log
@Some systematic clean-up.
- UNUSED macro that expands to __attribute__((unused)) for gcc
- move rcsid around so that they can be tagged UNUSED.
- activate -Wunused.
- use UNUSED instead of kludgy junk for function arguments.
- add extern to all extern prototypes.
- update comments in lst.h.
- clean up var.c a little bit, constifying arguments, updating comments...
@
text
@d1 1
a1 1
/*	$OpenBSD: dir.c,v 1.23 2000/06/23 16:41:52 espie Exp $	*/
d85 1
d92 1
d100 1
a100 1
static char rcsid[] = "$OpenBSD: dir.c,v 1.23 2000/06/23 16:41:52 espie Exp $";
d114 1
a114 2
 *	openDirectories Lst. This list is checked first before a directory
 *	is opened.
d175 1
a175 1
static LIST   openDirectories;	/* the list of all open directories */
d197 2
d200 1
a200 1
static int DirFindName __P((void *, void *));
d223 1
a223 1
    Lst_Init(&openDirectories);
d226 1
a226 8
    /*
     * Since the Path structure is placed on both openDirectories and
     * the path we give Dir_AddDir (which in this case is openDirectories),
     * we need to remove "." from openDirectories and what better time to
     * do it than when we have to fetch the thing anyway?
     */
    Dir_AddDir(&openDirectories, ".");
    dot = (Path *)Lst_DeQueue(&openDirectories);
d228 3
a230 5
    /*
     * We always need to have dot around, so we increment its reference count
     * to make sure it's not destroyed.
     */
    dot->refCount += 1;
d249 4
a252 1
    dot->refCount -= 1;
d254 5
a258 4
    Dir_ClearPath(&dirSearchPath);
    Lst_Destroy(&dirSearchPath, NOFREE);
    Dir_ClearPath(&openDirectories);
    Lst_Destroy(&openDirectories, NOFREE);
a264 22
 * DirFindName --
 *	See if the Path structure describes the same directory as the
 *	given one by comparing their names. Called from Dir_AddDir via
 *	Lst_Find when searching the list of open directories.
 *
 * Results:
 *	0 if it is the same. Non-zero otherwise
 *
 * Side Effects:
 *	None
 *-----------------------------------------------------------------------
 */
static int
DirFindName (p, dname)
    void *p;	      /* Current name */
    void *dname;      /* Desired name */
{
    return strcmp(((Path *)p)->name, (char *)dname);
}

/*-
 *-----------------------------------------------------------------------
d599 1
a599 1
			Dir_AddDir(&temp, dirpath);
d815 2
a816 4
		cp = strrchr (file, '/');
		*cp = '\0';
		Dir_AddDir (path, file);
		*cp = '/';
d872 1
a872 3
    cp[-1] = '\0';
    Dir_AddDir (path, name);
    cp[-1] = '/';
d990 51
a1047 3
 * Results:
 *	none
 *
d1054 5
a1058 4
Dir_AddDir (path, name)
    Lst           path;	      /* the path to which the directory should be
			       * added */
    char          *name;      /* the name of the directory to add */
d1060 1
a1060 4
    LstNode       ln;	      /* node in case Path structure is found */
    register Path *p;	      /* pointer to new Path structure */
    DIR     	  *d;	      /* for reading directory */
    register struct dirent *dp; /* entry in directory */
d1062 10
a1071 47
    ln = Lst_Find(&openDirectories, DirFindName, name);
    if (ln != NULL) {
	p = (Path *)Lst_Datum(ln);
	if (Lst_Member(path, p) == NULL) {
	    p->refCount += 1;
	    Lst_AtEnd(path, p);
	}
    } else {
	if (DEBUG(DIR)) {
	    printf("Caching %s...", name);
	    fflush(stdout);
	}

	if ((d = opendir (name)) != (DIR *) NULL) {
	    p = (Path *) emalloc (sizeof (Path));
	    p->name = estrdup (name);
	    p->hits = 0;
	    p->refCount = 1;
	    Hash_InitTable (&p->files, -1);

	    /*
	     * Skip the first two entries -- these will *always* be . and ..
	     */
	    (void)readdir(d);
	    (void)readdir(d);

	    while ((dp = readdir (d)) != (struct dirent *) NULL) {
#if defined(sun) && defined(d_ino) /* d_ino is a sunos4 #define for d_fileno */
		/*
		 * The sun directory library doesn't check for a 0 inode
		 * (0-inode slots just take up space), so we have to do
		 * it ourselves.
		 */
		if (dp->d_fileno == 0) {
		    continue;
		}
#endif /* sun && d_ino */
		(void)Hash_CreateEntry(&p->files, dp->d_name, (Boolean *)NULL);
	    }
	    (void) closedir (d);
	    Lst_AtEnd(&openDirectories, p);
	    Lst_AtEnd(path, p);
	}
	if (DEBUG(DIR)) {
	    printf("done\n");
	}
    }
a1152 7
    p->refCount -= 1;

    if (p->refCount == 0) {
	LstNode	ln;

	ln = Lst_Member(&openDirectories, p);
	Lst_Remove(&openDirectories, ln);
d1154 2
a1156 1
	free(p->name);
a1219 1
    LstNode	ln;
d1221 1
d1229 3
a1231 6
    Lst_Open(&openDirectories);
    while ((ln = Lst_Next(&openDirectories)) != NULL) {
	p = (Path *)Lst_Datum(ln);
	printf("# %-20s %10d\t%4d\n", p->name, p->refCount, p->hits);
    }
    Lst_Close(&openDirectories);
@


1.23
log
@This patch replaces str_concat with a slightly unobfuscated version.

In particular, Dir_MakeFlags is abusing str_concat, and works much better
with buffers.
@
text
@d1 1
a1 1
/*	$OpenBSD: dir.c,v 1.22 2000/06/23 16:15:49 espie Exp $	*/
a41 8
#ifndef lint
#if 0
static char sccsid[] = "@@(#)dir.c	8.2 (Berkeley) 1/2/94";
#else
static char rcsid[] = "$OpenBSD: dir.c,v 1.22 2000/06/23 16:15:49 espie Exp $";
#endif
#endif /* not lint */

d92 9
@


1.22
log
@Trivial consequences of the previous list changes:

- audit code for Lst_Datum, it's never applied to an empty pointer,
so check can be removed -> turn into a macro,
- Lst_First, Lst_Last can become macro as well
- specialized version of Lst_Succ (Lst_Adv) to use in loops where it cannot
fail,
- Lst_Open can no longer fail. Trim down corresponding code.

Reviewed millert@@, miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: dir.c,v 1.21 2000/06/17 14:40:27 espie Exp $	*/
d46 1
a46 1
static char rcsid[] = "$OpenBSD: dir.c,v 1.21 2000/06/17 14:40:27 espie Exp $";
d382 1
a382 2
			     str_concat(p->name, entry->name,
					STR_ADDSLASH)));
d751 1
a751 1
	    file = str_concat (p->name, cp, STR_ADDSLASH);
d808 1
a808 1
		file = str_concat (p->name, name, STR_ADDSLASH);
a1136 2
    char	  *str;	  /* the string which will be returned */
    char	  *tstr;  /* the current directory preceded by 'flag' */
d1138 1
a1138 1
    Path	  *p;	  /* the structure describing the current directory */
d1140 1
a1140 1
    str = estrdup("");
d1142 4
a1145 5
    Lst_Open(path);
    while ((ln = Lst_Next(path)) != NULL) {
	p = (Path *)Lst_Datum(ln);
	tstr = str_concat(flag, p->name, 0);
	str = str_concat(str, tstr, STR_ADDSPACE | STR_DOFREE);
a1146 1
    Lst_Close(path);
d1148 1
a1148 1
    return str;
@


1.21
log
@A few assorted changes, to remove more dynamic lists.
- in Dir_Expand, path is a misnomer. Use a temp variable instead...
Reformat code for readability.
- Change Parse_MainName/Targ_FindList so that they fill arguments instead
of allocating new lists.
- nuke Targ_FindList(TG_NOCREATE), as this is never used.

- close a small memory hole (forgot to free sysMkPath if CLEANUP).

Reviewed by millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: dir.c,v 1.20 2000/06/17 14:38:14 espie Exp $	*/
d46 1
a46 1
static char rcsid[] = "$OpenBSD: dir.c,v 1.20 2000/06/17 14:38:14 espie Exp $";
d525 4
a528 6
    if (Lst_Open(path) == SUCCESS) {
	while ((ln = Lst_Next(path)) != NULL) {
	    p = (Path *)Lst_Datum(ln);
	    DirMatchFiles(word, p, expansions);
	}
	Lst_Close(path);
d530 1
d712 1
a712 7
    if (Lst_Open (path) == FAILURE) {
	if (DEBUG(DIR)) {
	    printf("couldn't open path, file not found\n");
	}
	misses += 1;
	return ((char *) NULL);
    }
d723 1
a723 1
	p = (Path *) Lst_Datum (ln);
d805 1
a805 1
	(void) Lst_Open (path);
d807 1
a807 1
	    p = (Path *) Lst_Datum (ln);
d903 5
a907 6
    ln = Lst_Last (path);
    if (ln == NULL) {
	return ((char *) NULL);
    } else {
	p = (Path *) Lst_Datum (ln);
    }
d1046 1
a1046 1
	p = (Path *)Lst_Datum (ln);
d1134 1
a1134 1
Dir_MakeFlags (flag, path)
d1143 1
a1143 1
    str = estrdup ("");
d1145 5
a1149 7
    if (Lst_Open (path) == SUCCESS) {
	while ((ln = Lst_Next (path)) != NULL) {
	    p = (Path *) Lst_Datum (ln);
	    tstr = str_concat (flag, p->name, 0);
	    str = str_concat (str, tstr, STR_ADDSPACE | STR_DOFREE);
	}
	Lst_Close (path);
d1151 1
d1153 1
a1153 1
    return (str);
d1236 1
a1236 1
    for (ln = Lst_First(path2); ln != NULL; ln = Lst_Succ(ln)) {
d1258 4
a1261 6
    if (Lst_Open(&openDirectories) == SUCCESS) {
	while ((ln = Lst_Next(&openDirectories)) != NULL) {
	    p = (Path *) Lst_Datum (ln);
	    printf ("# %-20s %10d\t%4d\n", p->name, p->refCount, p->hits);
	}
	Lst_Close(&openDirectories);
d1263 1
@


1.20
log
@This patch introduces a distinction between
Lst_Init (constructor) and Lst_New (allocation + construction)
Lst_Destroy (destructor) and Lst_Delete (deallocation + destruction),
and uses that to turn most dynamic allocation of lists (Lst pointers)
into static structures (LIST).

Most of this is mundane, except for allGNs in targ.c, where the code must
be checked to verify that Targ_Init is called soon enough.

Lst_New is a temporary addition. All lists will soon be static.

Reviewed by millert@@, like the previous patch.
@
text
@d1 1
a1 1
/*	$OpenBSD: dir.c,v 1.19 2000/06/10 01:41:05 espie Exp $	*/
d46 1
a46 1
static char rcsid[] = "$OpenBSD: dir.c,v 1.19 2000/06/10 01:41:05 espie Exp $";
d591 1
a591 3
		/*
		 * This one will be fun.
		 */
d595 1
a595 3
		/*
		 * Back up to the start of the component
		 */
d598 1
a598 1
		while (cp > word && *cp != '/') {
a599 1
		}
d617 3
a619 1
		    if (dirpath != (char *)NULL) {
d623 4
a626 4
			path = Lst_New();
			Dir_AddDir(path, dirpath);
			DirExpandInt(cp+1, path, expansions);
			Lst_Delete(path, NOFREE);
d628 2
a629 4
		} else {
		    /*
		     * Start the search from the local directory
		     */
d631 2
a632 5
		}
	    } else {
		/*
		 * Return the file -- this should never happen.
		 */
a633 1
	    }
d635 1
a635 3
	    /*
	     * First the files in dot
	     */
d638 1
a638 3
	    /*
	     * Then the files in every other directory on the path.
	     */
@


1.19
log
@Clean-up patch: use `void *' instead of old-fashioned ClientData/Address.
@
text
@d1 1
a1 1
/*	$OpenBSD: dir.c,v 1.18 2000/06/10 01:32:22 espie Exp $	*/
d46 1
a46 1
static char rcsid[] = "$OpenBSD: dir.c,v 1.18 2000/06/10 01:32:22 espie Exp $";
d171 1
a171 1
Lst          dirSearchPath;	/* main search path */
d173 1
a173 1
static Lst   openDirectories;	/* the list of all open directories */
d216 1
a216 1
Dir_Init ()
d218 2
a219 2
    dirSearchPath = Lst_Init();
    openDirectories = Lst_Init();
d228 2
a229 2
    Dir_AddDir (openDirectories, ".");
    dot = (Path *) Lst_DeQueue (openDirectories);
d256 4
a259 4
    Dir_ClearPath(dirSearchPath);
    Lst_Destroy(dirSearchPath, NOFREE);
    Dir_ClearPath(openDirectories);
    Lst_Destroy(openDirectories, NOFREE);
d626 1
a626 1
			path = Lst_Init();
d629 1
a629 1
			Lst_Destroy(path, NOFREE);
d981 1
a981 1
Dir_MTime (gn)
d990 5
a994 5
    if (gn->type & OP_ARCHV) {
	return Arch_MTime (gn);
    } else if (gn->path == (char *)NULL) {
	fullName = Dir_FindFile (gn->name, dirSearchPath);
    } else {
a995 1
    }
d1065 1
a1065 1
    ln = Lst_Find(openDirectories, DirFindName, name);
d1105 1
a1105 1
	    Lst_AtEnd(openDirectories, p);
d1203 2
a1204 2
	ln = Lst_Member(openDirectories, p);
	Lst_Remove(openDirectories, ln);
d1280 2
a1281 2
    if (Lst_Open (openDirectories) == SUCCESS) {
	while ((ln = Lst_Next (openDirectories)) != NULL) {
d1285 1
a1285 1
	Lst_Close (openDirectories);
@


1.18
log
@Thus, Lst_ForEach no longer needs returning a status.
In fact, it can become a macro based on Lst_ForEachFrom.
This also introduces Lst_Every, as a shortcut for the very common case where
Lst_ForEach does not need any user data.

Finally,  make consistent use of a few function typedefs, instead of having
explicit void (*)(Lst)  arguments all over the place.
@
text
@d1 1
a1 1
/*	$OpenBSD: dir.c,v 1.17 2000/03/26 16:21:32 espie Exp $	*/
d46 1
a46 1
static char rcsid[] = "$OpenBSD: dir.c,v 1.17 2000/03/26 16:21:32 espie Exp $";
d196 1
a196 1
static int DirFindName __P((ClientData, ClientData));
d200 2
a201 2
static void DirPrintWord __P((ClientData));
static void DirPrintDir __P((ClientData));
d280 2
a281 2
    ClientData    p;	      /* Current name */
    ClientData	  dname;      /* Desired name */
d283 1
a283 1
    return (strcmp (((Path *)p)->name, (char *) dname));
d543 1
a543 1
    ClientData  word;
d875 1
a875 1
		Hash_SetValue(entry, (ClientData)((long)stb.st_mtime));
d954 1
a954 1
	Hash_SetValue(entry, (ClientData)(long)stb.st_mtime);
d1129 1
a1129 1
ClientData
d1131 1
a1131 1
    ClientData p;
d1133 1
a1133 1
    ((Path *) p)->refCount += 1;
d1196 1
a1196 1
    ClientData 	  pp;	    /* The directory descriptor to nuke */
d1208 2
a1209 2
	free((Address)p->name);
	free((Address)p);
d1290 3
a1292 2
static void DirPrintDir(p)
    ClientData	p;
@


1.17
log
@Remove idiotic, braindead casts T* -> void*
They serve no purpose, except hiding potential bugs.

In particular, remove (ClientData) cast from macro, showing potentially
troublesome use of Hashes to store time_t.
@
text
@d1 1
a1 1
/*	$OpenBSD: dir.c,v 1.16 2000/02/02 13:47:47 espie Exp $	*/
d46 1
a46 1
static char rcsid[] = "$OpenBSD: dir.c,v 1.16 2000/02/02 13:47:47 espie Exp $";
d200 2
a201 2
static int DirPrintWord __P((ClientData, ClientData));
static int DirPrintDir __P((ClientData, ClientData));
d537 2
a538 9
 *	Print a word in the list of expansions. Callback for Dir_Expand
 *	when DEBUG(DIR), via Lst_ForEach.
 *
 * Results:
 *	=== 0
 *
 * Side Effects:
 *	The passed word is printed, followed by a space.
 *
d541 2
a542 2
static int
DirPrintWord(word, dummy)
a543 1
    ClientData  dummy;
d545 1
a545 3
    printf("%s ", (char *) word);

    return(dummy ? 0 : 0);
d656 1
a656 1
	Lst_ForEach(expansions, DirPrintWord, NULL);
d1290 1
a1290 1
static int DirPrintDir (p, dummy)
a1291 1
    ClientData	dummy;
d1293 1
a1293 2
    printf ("%s ", ((Path *) p)->name);
    return (dummy ? 0 : 0);
d1297 1
a1297 1
Dir_PrintPath (path)
d1300 1
a1300 1
    Lst_ForEach(path, DirPrintDir, NULL);
@


1.16
log
@Bug-fix: make should behave sensibly when presented with negative times...

- let *_MTime return booleans, as that's what they're used for, the time_t
is set as a side effect.

- use OUT_OF_DATE for a date starting point, set it at the origin of time.
@
text
@d1 1
a1 1
/*	$OpenBSD: dir.c,v 1.15 2000/01/25 20:52:15 espie Exp $	*/
d46 1
a46 1
static char rcsid[] = "$OpenBSD: dir.c,v 1.15 2000/01/25 20:52:15 espie Exp $";
d255 1
a255 1
    Dir_Destroy((ClientData) dot);
d666 1
a666 1
	Lst_ForEach(expansions, DirPrintWord, (ClientData) 0);
d884 2
a885 1
		Hash_SetValue(entry, (long)stb.st_mtime);
d963 2
a964 1
	Hash_SetValue(entry, (long)stb.st_mtime);
d1076 1
a1076 1
    ln = Lst_Find(openDirectories, DirFindName, (ClientData)name);
d1079 1
a1079 1
	if (Lst_Member(path, (ClientData)p) == NULL) {
d1081 1
a1081 1
	    Lst_AtEnd(path, (ClientData)p);
d1116 2
a1117 2
	    Lst_AtEnd(openDirectories, (ClientData)p);
	    Lst_AtEnd(path, (ClientData)p);
d1145 1
a1145 1
    return ((ClientData)p);
d1214 1
a1214 1
	ln = Lst_Member (openDirectories, (ClientData)p);
d1243 1
a1243 1
	Dir_Destroy((ClientData)p);
d1271 1
a1271 1
	if (Lst_Member(path1, (ClientData)p) == NULL) {
d1273 1
a1273 1
	    Lst_AtEnd(path1, (ClientData)p);
d1312 1
a1312 1
    Lst_ForEach (path, DirPrintDir, (ClientData)0);
@


1.15
log
@Kludge to fix timestamp bug.
@
text
@d1 1
a1 1
/*	$OpenBSD: dir.c,v 1.14 1999/12/19 00:04:25 espie Exp $	*/
d46 1
a46 1
static char rcsid[] = "$OpenBSD: dir.c,v 1.14 1999/12/19 00:04:25 espie Exp $";
d71 1
a71 1
 *	Dir_MTime 	    Return the modification time of a node. The file
d980 1
a980 1
 *	The modification time or 0 if it doesn't exist
d988 1
a988 1
int
d996 1
d1023 1
d1027 3
a1029 2
    	if (stb.st_mtime == 0)
		stb.st_mtime = 1;
d1036 2
a1037 1
	    stb.st_mtime = 0;
d1045 1
a1045 1
    return (gn->mtime);
@


1.14
log
@Rearrange Lst_Find interface to conform better with other functions.
@
text
@d1 1
a1 1
/*	$OpenBSD: dir.c,v 1.13 1999/12/18 21:58:07 espie Exp $	*/
d46 1
a46 1
static char rcsid[] = "$OpenBSD: dir.c,v 1.13 1999/12/18 21:58:07 espie Exp $";
d1022 6
a1027 1
    } else if (stat (fullName, &stb) < 0) {
@


1.13
log
@Nothing ever checks ReturnStatus on Lst_Insert, Lst_Append, Lst_AtFront,
Lst_AtEnd, Lst_Concat, Lst_Remove, Lst_Replace.

Don't bother returning one.
@
text
@d1 1
a1 1
/*	$OpenBSD: dir.c,v 1.12 1999/12/18 21:56:07 espie Exp $	*/
d46 1
a46 1
static char rcsid[] = "$OpenBSD: dir.c,v 1.12 1999/12/18 21:56:07 espie Exp $";
d1065 1
a1065 1
    ln = Lst_Find (openDirectories, (ClientData)name, DirFindName);
@


1.12
log
@Lst_DeQueue already checks for empty lists.
@
text
@d1 1
a1 1
/*	$OpenBSD: dir.c,v 1.11 1999/12/18 21:53:32 espie Exp $	*/
d46 1
a46 1
static char rcsid[] = "$OpenBSD: dir.c,v 1.11 1999/12/18 21:53:32 espie Exp $";
d380 1
a380 1
	    (void)Lst_AtEnd(expansions,
d491 1
a491 1
	    (void)Lst_AtEnd(expansions, file);
d1070 1
a1070 1
	    (void)Lst_AtEnd (path, (ClientData)p);
d1105 2
a1106 2
	    (void)Lst_AtEnd (openDirectories, (ClientData)p);
	    (void)Lst_AtEnd (path, (ClientData)p);
d1204 1
a1204 1
	(void) Lst_Remove (openDirectories, ln);
d1262 1
a1262 1
	    (void)Lst_AtEnd(path1, (ClientData)p);
@


1.11
log
@NIL, NILGNODE, etc, are only glorified NULL.
Get rid of them.

Get rid of list.h, nothing uses it anyway.
@
text
@d1 1
a1 1
/*	$OpenBSD: dir.c,v 1.10 1999/12/18 02:11:26 espie Exp $	*/
d46 1
a46 1
static char rcsid[] = "$OpenBSD: dir.c,v 1.10 1999/12/18 02:11:26 espie Exp $";
d1231 2
a1232 4
    while (!Lst_IsEmpty(path)) {
	p = (Path *)Lst_DeQueue(path);
	Dir_Destroy((ClientData) p);
    }
@


1.10
log
@make does not use circular lists, get rid of the extra weight.
@
text
@d1 1
a1 1
/*	$OpenBSD: dir.c,v 1.9 1999/10/05 22:06:23 espie Exp $	*/
d46 1
a46 1
static char rcsid[] = "$OpenBSD: dir.c,v 1.9 1999/10/05 22:06:23 espie Exp $";
d526 1
a526 1
	while ((ln = Lst_Next(path)) != NILLNODE) {
d752 1
a752 1
    while ((ln = Lst_Next (path)) != NILLNODE) {
d836 1
a836 1
	while ((ln = Lst_Next (path)) != NILLNODE) {
d933 1
a933 1
    if (ln == NILLNODE) {
d1066 1
a1066 1
    if (ln != NILLNODE) {
d1068 1
a1068 1
	if (Lst_Member(path, (ClientData)p) == NILLNODE) {
d1167 1
a1167 1
	while ((ln = Lst_Next (path)) != NILLNODE) {
d1260 1
a1260 1
    for (ln = Lst_First(path2); ln != NILLNODE; ln = Lst_Succ(ln)) {
d1262 1
a1262 1
	if (Lst_Member(path1, (ClientData)p) == NILLNODE) {
d1283 1
a1283 1
	while ((ln = Lst_Next (openDirectories)) != NILLNODE) {
@


1.9
log
@Efficiency patch from NetBSD:
make spends time freeing data structures right before exiting.
So don't bother.
Keep the code inside #ifdef, so that it's still there if someone
ever wants to use make code inside a library.
@
text
@d1 1
a1 1
/*	$OpenBSD: dir.c,v 1.8 1998/12/05 00:06:27 espie Exp $	*/
d46 1
a46 1
static char rcsid[] = "$OpenBSD: dir.c,v 1.8 1998/12/05 00:06:27 espie Exp $";
d218 2
a219 2
    dirSearchPath = Lst_Init (FALSE);
    openDirectories = Lst_Init (FALSE);
d636 1
a636 1
			path = Lst_Init(FALSE);
@


1.8
log
@Modifications from netbsd:
- don't interfere with MACHINE/MACHINE_ARCH defines for bootstrap
- type clean-up, time_t, and printing `unknown' ints
- fix TARGET/MEMBER bug in archive rules
- memmove...
- cleaner Error handler.
- reentrant brk_string
- .MAKE env variable
- preliminary scaffolding for .NOPATH

Other improvements:
- efree
- shellneed streamlined
- display Stop in .CURDIR after an error.
- document most features and misfeatures.
- add a few OpenBSD notes to the tutorial.
@
text
@d1 1
a1 1
/*	$OpenBSD: dir.c,v 1.6 1996/11/30 21:08:53 millert Exp $	*/
d46 1
a46 1
static char rcsid[] = "$OpenBSD: dir.c,v 1.6 1996/11/30 21:08:53 millert Exp $";
d253 1
d261 1
@


1.7
log
@Sync with NetBSD (mostly by christos initial substitution/regexp from Der Mouse)

- fix the variable substitution code in make [PR/2748]
      1. change s/a/b/ so that it substitutes the first occurance of the
         pattern on each word, not only the first word.
      2. add flag '1' to the variable substitution so that the substitutions
         get performed only once.

  ***THIS IS AN INCOMPATIBLE CHANGE!***

  Unfortunately there was no way to make things consistent without
  modifying the current behavior. Fortunately none of our Makefiles
  depended on this.

            OLD:

                VAR      = aa1 aa2 aa3 aa4

                S/a/b/   = ba1 aa2 aa3 aa4
                S/a/b/g  = bb1 bb2 bb3 bb4

            NEW:
                VAR      = aa1 aa2 aa3 aa4

                S/a/b/   = ba1 ba2 ba3 ba4
                S/a/b/1  = ba1 aa2 aa3 aa4
                S/a/b/g  = bb1 bb2 bb3 bb4
                S/a/b/1g = bb1 aa2 aa3 aa4
- add regexp variable substitution via 'C/foo/bar/' [PR/2752]
- add variable quoting via the ${VAR:Q} modifier. This is useful when running
  recursive invocations of make(1):

        make VAR=${VAR:Q}

  will always work... (This may prove useful in the kernel builds...) [PR/2981]
- BSD did not traditionally have <sys/cdefs.h>; use BSD4_4 instead and include
  <sys/param.h> to grab it.
- Don't compile the regex code if MAKE_BOOTSTRAP (from gwr)
- Use explicit .c.o rule in Makefile.boot so that the bootstrap process works.
- Use only integral types in procedure arguments. [buf.c buf.h]
- Include <stdlib.h> to get getenv() prototype on SVR4
- if __STDC__ -> ifdef __STDC__ to appease SVR4
- Define const and volatile for non __STDC__
- Implement snprintf() and vsnprintf() for non BSD4_4 systems.
- Make $MACHINE_ARCH settable from the environment.
- Fix .USE directive problems: (reported by cgd)
    1. ${.*} variables did not get expanded in dependencies.
    2. expanded ${.*} variables in .USE dependencies can cause tree
       restructuring; handle it.
    3. in compat mode, expand .USE before evaluating the list of targets,
       instead of doing .USE expansions on demand, because they can cause
       tree restructuring.
- Add a .MADE directive to indicated that the children of a target are
  up-to-date, even when they are not. This is to simulate our current
  make install behavior with proper dependencies.
- Fix problems in the RE substitution error handling.
- Locate all the children of a node marked as MADE.
- Do not compile-in ${MACHINE} (as per NetBSD PR#3386)
- Disable globbing for targets/dependencies when POSIX is defined.
- Fix globbing so that patterns that don't have a matching number of [] or {}
  don't get expanded. (before the [ case got expanded to nothing!) This is
  disabled.
- Make sure that the children of nodes that are marked .MADE, are marked
  UPTODATE and their timestamps are consistent.
- Don't disable wildcards completely; they are used by other Makefiles.
@
text
@@


1.6
log
@Sync with NetBSD:
- Merge in FreeBSD and Lite2 changes.
- Fix bug where a non-archive target with a .a suffix would always
  be considered to be out of date, since it does not have a TOC.
- Fix NetBSD PR #2930: declare missing variable.
@
text
@d1 2
a2 2
/*	$OpenBSD: dir.c,v 1.5 1996/09/02 16:04:09 briggs Exp $	*/
/*	$NetBSD: dir.c,v 1.12 1996/11/06 17:59:04 christos Exp $	*/
d46 1
a46 1
static char rcsid[] = "$OpenBSD: dir.c,v 1.5 1996/09/02 16:04:09 briggs Exp $";
d288 5
d306 1
d311 6
d318 6
d326 4
a329 1
	    return (TRUE);
d332 1
a332 1
    return (FALSE);
@


1.5
log
@Sync up with NetBSD:
(christos)
	Fix bug reported by Greg Hudson where leaf (source only) nodes were
	referenced only by their basename and not by their full pathname. This
	breaks when .PATH or MAKEOBJDIR are used. There might be Makefiles
	around that try to work around this bug by prepending ${.CURDIR} to
	the sources, and they should be found and fixed. Also a lot of the gunk
	in suff.c that was attempting to work around the same problem could be
	removed.
(christos)
	- Move -D flags from Makefile to config.h and explain what they do. Add
	  -Wall -Wno-unused to CFLAGS. Add new define SYSVVARSUB to enable SysV
	  style variable substitutions and enable them.
	- Add SunOS style command substitutions via SUNSHCMD
	- Fix core dump with '{variable = value'
(christos)
	Fix bug where make will always exit with 0, even when one or more
	parallel jobs failed. (Only affects parallel make code)
(christos)
	Protect __P from being multiply defined (for systems that already
	define it)
(christos) Add strdup() since ultrix is missing it.
	From Larry Schwimmer <rosebud@@cyclone.Stanford.EDU>
(christos) Add estrdup(), a checked version of strdup and use it.
(christos) Recognize SVR4 style long filename entries in archives.
(thorpej) Tidy up some RCS ids a bit.
@
text
@d1 2
a2 2
/*	$OpenBSD: dir.c,v 1.4 1996/06/26 05:36:29 deraadt Exp $	*/
/*	$NetBSD: dir.c,v 1.11 1996/08/13 16:42:02 christos Exp $	*/
d44 1
a44 1
static char sccsid[] = "@@(#)dir.c	5.6 (Berkeley) 12/28/90";
d46 1
a46 1
static char rcsid[] = "$OpenBSD: dir.c,v 1.4 1996/06/26 05:36:29 deraadt Exp $";
d221 1
a221 1
    
d301 1
a301 1
    
d337 1
a337 1
    Hash_Search	  search;   	/* Index into the directory's table */	
d340 1
a340 1
    
d342 1
a342 1
    
d561 1
a561 1
    
d635 1
a635 1
    
d680 1
a680 1
    
d693 1
a693 1
    
d712 1
a712 1
    
d720 1
a720 1
    
d785 1
a785 1
    
d805 1
a805 1
    
d808 1
a808 1
	
d827 2
a828 2
	    
		
d833 1
a833 1
		
d835 1
a835 1
		
d850 1
a850 1
		
d868 1
a868 1
	
d885 1
a885 1
    
d907 1
a907 1
    
d915 1
a915 1
    
d925 1
a925 1
    
d955 1
a955 1
 * 
d973 1
a973 1
    
d981 1
a981 1
    
d1011 1
a1011 1
    
d1027 1
a1027 1
 *	A structure is added to the list and the directory is 
d1041 1
a1041 1
    
d1054 1
a1054 1
	
d1061 1
a1061 1
	    
d1067 1
a1067 1
	    
d1140 1
a1140 1
    
d1142 1
a1142 1
    
d1151 1
a1151 1
    
d1213 1
a1213 1
	    
d1252 1
a1252 1
    
d1271 1
a1271 1
{ 
@


1.4
log
@rcsid
@
text
@d1 2
a2 2
/*	$OpenBSD: dir.c,v 1.10 1996/02/04 22:20:38 christos Exp $	*/
/*	$NetBSD: dir.c,v 1.10 1996/02/04 22:20:38 christos Exp $	*/
d46 1
a46 1
static char rcsid[] = "$OpenBSD: dir.c,v 1.10 1996/02/04 22:20:38 christos Exp $";
d358 1
a358 1
			    (isDot ? strdup(entry->name) :
d710 1
a710 1
	    return (strdup (name));
d821 1
a821 1
		file = strdup(name);
d917 1
a917 1
	return (strdup (name));
d932 1
a932 1
	return(strdup(name));
d940 1
a940 1
	return (strdup (name));
d983 1
a983 1
	fullName = strdup(gn->name);
d1057 1
a1057 1
	    p->name = strdup (name);
d1141 1
a1141 1
    str = strdup ("");
@


1.3
log
@From NetBSD:
Support SVR4 style archives.
Fix pr/1421 (from Matthew Green) and pr/1997 (from Jeff Thieleke).
In ParseDoInclude(), make a temporary copy of the current file name
while searching for ""-type include files, since the current file name
might not be a writeable string.
@
text
@d1 1
d46 1
a46 1
static char rcsid[] = "$NetBSD: dir.c,v 1.10 1996/02/04 22:20:38 christos Exp $";
@


1.2
log
@from christos@@netbsd:
Minor:
    - ${.PREFIX} should never contain a full pathname
    - Fixed gcc -Wall warnings
Major:
    - compatMake is now FALSE. This means that we are now running in
      full pmake mode:
          * rules on dependency lines can be executed in parallel and or
            out of sequence:

            foo: bar baz

            can fire the rule for baz before the rule for bar is fired.
            To enforce bar to be fired before baz, another rule needs to be
            added. [bar: baz]
          * adjacent shell commands in a target are now executed by a single
            invocation of the shell, not one invocation of the shell per line
      (compatMake can be turned off using the -B flag)
    - The -j flag now works... I.e. make -j 4 will fork up to four jobs in
      parallel when it can. The target name is printed before each burst
      of output caused by the target execution as '--- target ---', when j > 1
    - I have changed all the Makefiles so that they work with make -j N, and
      I have tested the whole netbsd by:
          'make -j 4 cleandir; make -j 4 depend; make -j 4; make -j 4 install'
    - I have not compiled or tested this version of make with -DREMOTE.
- Turn compat mode on by default. It gets turned off when the -j without
  the -B flag is specified. [Thus you can use -j 1 to turn it off].
- Fix malloc -> emalloc as Gordon noted.
Updates for POSIX/SVR4 compiling:
arch.c:          Don't require ranlib stuff. Not everybody has it.
dir.c:           SunOS-4 != Solaris; change #ifdef sun to #if sun && !__svr4__
job.c, compat.c: Don't use 'union wait', use int and the W*() macros.
main.c:          Check for uname() == -1; some unames return > 0...
util.c, job.c:   Add signal() with BSD semantics for svr4, don't use bsd
                 sigmask and friends.

from cgd@@netbsd:
pull in make.h.  (PAlloc() now uses emalloc(), which is prototyped in
make.h.  If the prototype is not in scope on the Alpha, I see lots
of "cast to pointer from integer of different size" warnings.)
@
text
@d1 1
a1 1
/*	$NetBSD: dir.c,v 1.9 1995/11/22 17:40:05 christos Exp $	*/
d45 1
a45 1
static char rcsid[] = "$NetBSD: dir.c,v 1.9 1995/11/22 17:40:05 christos Exp $";
d1068 1
a1068 1
#if defined(sun) && !defined(__svr4__)
d1077 1
a1077 1
#endif /* sun && !__svr4__ */
@


1.1
log
@Initial revision
@
text
@d1 1
a1 1
/*	$NetBSD: dir.c,v 1.8 1995/06/14 15:19:07 christos Exp $	*/
d45 1
a45 1
static char rcsid[] = "$NetBSD: dir.c,v 1.8 1995/06/14 15:19:07 christos Exp $";
d1068 1
a1068 1
#ifdef sun
d1077 1
a1077 1
#endif /* sun */
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@
