head	1.101;
access;
symbols
	OPENBSD_6_1:1.101.0.4
	OPENBSD_6_1_BASE:1.101
	OPENBSD_6_0:1.99.0.4
	OPENBSD_6_0_BASE:1.99
	OPENBSD_5_9:1.99.0.2
	OPENBSD_5_9_BASE:1.99
	OPENBSD_5_8:1.98.0.8
	OPENBSD_5_8_BASE:1.98
	OPENBSD_5_7:1.98.0.2
	OPENBSD_5_7_BASE:1.98
	OPENBSD_5_6:1.98.0.4
	OPENBSD_5_6_BASE:1.98
	OPENBSD_5_5:1.97.0.4
	OPENBSD_5_5_BASE:1.97
	OPENBSD_5_4:1.94.0.2
	OPENBSD_5_4_BASE:1.94
	OPENBSD_5_3:1.93.0.2
	OPENBSD_5_3_BASE:1.93
	OPENBSD_5_2:1.89.0.2
	OPENBSD_5_2_BASE:1.89
	OPENBSD_5_1_BASE:1.88
	OPENBSD_5_1:1.88.0.4
	OPENBSD_5_0:1.88.0.2
	OPENBSD_5_0_BASE:1.88
	OPENBSD_4_9:1.87.0.4
	OPENBSD_4_9_BASE:1.87
	OPENBSD_4_8:1.87.0.2
	OPENBSD_4_8_BASE:1.87
	OPENBSD_4_7:1.85.0.2
	OPENBSD_4_7_BASE:1.85
	OPENBSD_4_6:1.85.0.4
	OPENBSD_4_6_BASE:1.85
	OPENBSD_4_5:1.84.0.2
	OPENBSD_4_5_BASE:1.84
	OPENBSD_4_4:1.83.0.4
	OPENBSD_4_4_BASE:1.83
	OPENBSD_4_3:1.83.0.2
	OPENBSD_4_3_BASE:1.83
	OPENBSD_4_2:1.74.0.2
	OPENBSD_4_2_BASE:1.74
	OPENBSD_4_1:1.61.0.2
	OPENBSD_4_1_BASE:1.61
	OPENBSD_4_0:1.60.0.4
	OPENBSD_4_0_BASE:1.60
	OPENBSD_3_9:1.60.0.2
	OPENBSD_3_9_BASE:1.60
	OPENBSD_3_8:1.59.0.6
	OPENBSD_3_8_BASE:1.59
	OPENBSD_3_7:1.59.0.4
	OPENBSD_3_7_BASE:1.59
	OPENBSD_3_6:1.59.0.2
	OPENBSD_3_6_BASE:1.59
	OPENBSD_3_5:1.58.0.2
	OPENBSD_3_5_BASE:1.58
	OPENBSD_3_4:1.57.0.2
	OPENBSD_3_4_BASE:1.57
	OPENBSD_3_3:1.56.0.4
	OPENBSD_3_3_BASE:1.56
	OPENBSD_3_2:1.56.0.2
	OPENBSD_3_2_BASE:1.56
	OPENBSD_3_1:1.55.0.4
	OPENBSD_3_1_BASE:1.55
	OPENBSD_3_0:1.55.0.2
	OPENBSD_3_0_BASE:1.55
	OPENBSD_2_9_BASE:1.52
	OPENBSD_2_9:1.52.0.2
	OPENBSD_2_8:1.49.0.2
	OPENBSD_2_8_BASE:1.49
	OPENBSD_2_7:1.30.0.2
	OPENBSD_2_7_BASE:1.30
	OPENBSD_2_6:1.12.0.2
	OPENBSD_2_6_BASE:1.12
	OPENBSD_2_5:1.10.0.2
	OPENBSD_2_5_BASE:1.10
	OPENBSD_2_4:1.9.0.2
	OPENBSD_2_4_BASE:1.9
	OPENBSD_2_3:1.8.0.2
	OPENBSD_2_3_BASE:1.8
	OPENBSD_2_2:1.6.0.4
	OPENBSD_2_2_BASE:1.6
	OPENBSD_2_1:1.6.0.2
	OPENBSD_2_1_BASE:1.6
	OPENBSD_2_0:1.4.0.2
	OPENBSD_2_0_BASE:1.4
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.101
date	2016.10.23.14.54.14;	author espie;	state Exp;
branches;
next	1.100;
commitid	wPoE1FuixzUwl6nK;

1.100
date	2016.10.14.09.27.21;	author natano;	state Exp;
branches;
next	1.99;
commitid	xK9iXmhQ2bSDSVMb;

1.99
date	2015.09.27.16.58.16;	author guenther;	state Exp;
branches;
next	1.98;
commitid	aJ83imcowNDDIDkP;

1.98
date	2014.05.12.19.11.19;	author espie;	state Exp;
branches;
next	1.97;

1.97
date	2014.01.29.23.53.20;	author espie;	state Exp;
branches;
next	1.96;

1.96
date	2014.01.06.12.15.40;	author espie;	state Exp;
branches;
next	1.95;

1.95
date	2014.01.06.12.08.18;	author espie;	state Exp;
branches;
next	1.94;

1.94
date	2013.04.23.14.32.53;	author espie;	state Exp;
branches;
next	1.93;

1.93
date	2013.02.15.18.34.25;	author espie;	state Exp;
branches;
next	1.92;

1.92
date	2012.10.09.19.39.59;	author espie;	state Exp;
branches;
next	1.91;

1.91
date	2012.10.02.10.29.31;	author espie;	state Exp;
branches;
next	1.90;

1.90
date	2012.08.25.08.12.56;	author espie;	state Exp;
branches;
next	1.89;

1.89
date	2012.03.22.13.47.12;	author espie;	state Exp;
branches;
next	1.88;

1.88
date	2011.06.20.19.05.33;	author espie;	state Exp;
branches;
next	1.87;

1.87
date	2010.07.19.19.46.44;	author espie;	state Exp;
branches;
next	1.86;

1.86
date	2010.04.25.13.59.53;	author espie;	state Exp;
branches;
next	1.85;

1.85
date	2009.05.13.10.47.54;	author espie;	state Exp;
branches;
next	1.84;

1.84
date	2008.11.09.12.34.47;	author tobias;	state Exp;
branches;
next	1.83;

1.83
date	2007.11.17.16.39.45;	author espie;	state Exp;
branches;
next	1.82;

1.82
date	2007.11.04.09.31.57;	author espie;	state Exp;
branches;
next	1.81;

1.81
date	2007.11.03.15.42.10;	author deraadt;	state Exp;
branches;
next	1.80;

1.80
date	2007.09.17.10.39.33;	author espie;	state Exp;
branches;
next	1.79;

1.79
date	2007.09.17.09.45.37;	author espie;	state Exp;
branches;
next	1.78;

1.78
date	2007.09.17.09.44.20;	author espie;	state Exp;
branches;
next	1.77;

1.77
date	2007.09.17.09.28.36;	author espie;	state Exp;
branches;
next	1.76;

1.76
date	2007.09.16.12.01.11;	author espie;	state Exp;
branches;
next	1.75;

1.75
date	2007.09.16.09.46.14;	author espie;	state Exp;
branches;
next	1.74;

1.74
date	2007.07.30.10.03.11;	author espie;	state Exp;
branches;
next	1.73;

1.73
date	2007.07.30.09.51.53;	author espie;	state Exp;
branches;
next	1.72;

1.72
date	2007.07.30.09.47.21;	author espie;	state Exp;
branches;
next	1.71;

1.71
date	2007.07.24.19.00.17;	author espie;	state Exp;
branches;
next	1.70;

1.70
date	2007.07.24.18.58.48;	author espie;	state Exp;
branches;
next	1.69;

1.69
date	2007.07.24.18.56.15;	author espie;	state Exp;
branches;
next	1.68;

1.68
date	2007.07.24.18.52.47;	author espie;	state Exp;
branches;
next	1.67;

1.67
date	2007.07.22.17.56.50;	author espie;	state Exp;
branches;
next	1.66;

1.66
date	2007.07.20.12.32.45;	author espie;	state Exp;
branches;
next	1.65;

1.65
date	2007.07.20.12.18.47;	author espie;	state Exp;
branches;
next	1.64;

1.64
date	2007.07.08.17.53.15;	author espie;	state Exp;
branches;
next	1.63;

1.63
date	2007.07.08.17.49.55;	author espie;	state Exp;
branches;
next	1.62;

1.62
date	2007.07.08.17.44.20;	author espie;	state Exp;
branches;
next	1.61;

1.61
date	2007.01.02.13.21.31;	author espie;	state Exp;
branches;
next	1.60;

1.60
date	2006.01.20.23.10.19;	author espie;	state Exp;
branches;
next	1.59;

1.59
date	2004.04.07.13.11.36;	author espie;	state Exp;
branches;
next	1.58;

1.58
date	2003.10.07.18.33.08;	author fgsch;	state Exp;
branches;
next	1.57;

1.57
date	2003.06.03.02.56.12;	author millert;	state Exp;
branches;
next	1.56;

1.56
date	2002.06.05.18.45.39;	author espie;	state Exp;
branches;
next	1.55;

1.55
date	2001.05.23.12.34.51;	author espie;	state Exp;
branches;
next	1.54;

1.54
date	2001.05.15.13.31.03;	author espie;	state Exp;
branches;
next	1.53;

1.53
date	2001.05.03.13.41.13;	author espie;	state Exp;
branches;
next	1.52;

1.52
date	2001.03.02.16.57.26;	author espie;	state Exp;
branches;
next	1.51;

1.51
date	2000.12.07.00.15.43;	author espie;	state Exp;
branches;
next	1.50;

1.50
date	2000.11.24.14.29.56;	author espie;	state Exp;
branches;
next	1.49;

1.49
date	2000.10.13.08.29.21;	author espie;	state Exp;
branches;
next	1.48;

1.48
date	2000.09.14.13.32.08;	author espie;	state Exp;
branches;
next	1.47;

1.47
date	2000.08.21.10.44.21;	author espie;	state Exp;
branches;
next	1.46;

1.46
date	2000.07.18.20.17.20;	author espie;	state Exp;
branches;
next	1.45;

1.45
date	2000.07.17.23.29.35;	author espie;	state Exp;
branches;
next	1.44;

1.44
date	2000.07.17.23.26.50;	author espie;	state Exp;
branches;
next	1.43;

1.43
date	2000.07.17.23.09.06;	author espie;	state Exp;
branches;
next	1.42;

1.42
date	2000.07.17.23.06.32;	author espie;	state Exp;
branches;
next	1.41;

1.41
date	2000.07.17.23.01.20;	author espie;	state Exp;
branches;
next	1.40;

1.40
date	2000.07.17.22.57.37;	author espie;	state Exp;
branches;
next	1.39;

1.39
date	2000.07.17.22.55.12;	author espie;	state Exp;
branches;
next	1.38;

1.38
date	2000.06.23.16.27.29;	author espie;	state Exp;
branches;
next	1.37;

1.37
date	2000.06.23.16.23.26;	author espie;	state Exp;
branches;
next	1.36;

1.36
date	2000.06.23.16.21.44;	author espie;	state Exp;
branches;
next	1.35;

1.35
date	2000.06.23.16.20.01;	author espie;	state Exp;
branches;
next	1.34;

1.34
date	2000.06.23.16.18.09;	author espie;	state Exp;
branches;
next	1.33;

1.33
date	2000.06.17.14.38.20;	author espie;	state Exp;
branches;
next	1.32;

1.32
date	2000.06.10.01.41.06;	author espie;	state Exp;
branches;
next	1.31;

1.31
date	2000.06.10.01.32.23;	author espie;	state Exp;
branches;
next	1.30;

1.30
date	2000.03.26.16.21.33;	author espie;	state Exp;
branches;
next	1.29;

1.29
date	2000.01.08.09.45.16;	author espie;	state Exp;
branches;
next	1.28;

1.28
date	99.12.19.00.04.25;	author espie;	state Exp;
branches;
next	1.27;

1.27
date	99.12.18.21.58.08;	author espie;	state Exp;
branches;
next	1.26;

1.26
date	99.12.18.21.53.33;	author espie;	state Exp;
branches;
next	1.25;

1.25
date	99.12.18.02.11.27;	author espie;	state Exp;
branches;
next	1.24;

1.24
date	99.12.16.17.27.18;	author espie;	state Exp;
branches;
next	1.23;

1.23
date	99.12.16.17.02.45;	author espie;	state Exp;
branches;
next	1.22;

1.22
date	99.12.16.16.52.11;	author espie;	state Exp;
branches;
next	1.21;

1.21
date	99.12.16.16.41.42;	author espie;	state Exp;
branches;
next	1.20;

1.20
date	99.12.16.16.27.13;	author espie;	state Exp;
branches;
next	1.19;

1.19
date	99.12.09.18.18.24;	author espie;	state Exp;
branches;
next	1.18;

1.18
date	99.12.06.22.28.44;	author espie;	state Exp;
branches;
next	1.17;

1.17
date	99.12.06.22.27.37;	author espie;	state Exp;
branches;
next	1.16;

1.16
date	99.12.06.22.24.32;	author espie;	state Exp;
branches;
next	1.15;

1.15
date	99.11.11.11.35.17;	author espie;	state Exp;
branches;
next	1.14;

1.14
date	99.11.10.14.11.49;	author espie;	state Exp;
branches;
next	1.13;

1.13
date	99.11.06.14.34.42;	author espie;	state Exp;
branches;
next	1.12;

1.12
date	99.09.28.21.57.04;	author espie;	state Exp;
branches;
next	1.11;

1.11
date	99.09.25.14.44.00;	author espie;	state Exp;
branches;
next	1.10;

1.10
date	98.12.05.00.06.29;	author espie;	state Exp;
branches;
next	1.9;

1.9
date	98.07.23.18.49.05;	author deraadt;	state Exp;
branches;
next	1.8;

1.8
date	98.03.30.06.59.39;	author deraadt;	state Exp;
branches;
next	1.7;

1.7
date	97.12.18.21.50.45;	author deraadt;	state Exp;
branches;
next	1.6;

1.6
date	97.04.01.07.28.28;	author millert;	state Exp;
branches;
next	1.5;

1.5
date	96.11.30.21.09.07;	author millert;	state Exp;
branches;
next	1.4;

1.4
date	96.09.02.16.04.22;	author briggs;	state Exp;
branches;
next	1.3;

1.3
date	96.06.26.05.36.39;	author deraadt;	state Exp;
branches;
next	1.2;

1.2
date	95.12.14.03.23.41;	author deraadt;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.45.43;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.45.43;	author deraadt;	state Exp;
branches;
next	;


desc
@@


1.101
log
@add !!=
feedback and okay millert@@
@
text
@/*	$OpenBSD: var.c,v 1.100 2016/10/14 09:27:21 natano Exp $	*/
/*	$NetBSD: var.c,v 1.18 1997/03/18 19:24:46 christos Exp $	*/

/*
 * Copyright (c) 1999,2000,2007 Marc Espie.
 *
 * Extensive code modifications for the OpenBSD project.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE OPENBSD PROJECT AND CONTRIBUTORS
 * ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
 * A PARTICULAR PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE OPENBSD
 * PROJECT OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
/*
 * Copyright (c) 1988, 1989, 1990, 1993
 *	The Regents of the University of California.  All rights reserved.
 * Copyright (c) 1989 by Berkeley Softworks
 * All rights reserved.
 *
 * This code is derived from software contributed to Berkeley by
 * Adam de Boor.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */

#include <assert.h>
#include <stddef.h>
#include <stdint.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <ohash.h>

#include "config.h"
#include "defines.h"
#include "buf.h"
#include "cmd_exec.h"
#include "stats.h"
#include "pathnames.h"
#include "varmodifiers.h"
#include "var.h"
#include "varname.h"
#include "error.h"
#include "str.h"
#include "var_int.h"
#include "memory.h"
#include "symtable.h"
#include "gnode.h"
#include "dump.h"
#include "lowparse.h"

/*
 * This is a harmless return value for Var_Parse that can be used by Var_Subst
 * to determine if there was an error in parsing -- easier than returning
 * a flag, as things outside this module don't give a hoot.
 */
char	var_Error[] = "";

GNode *current_node = NULL;
/*
 * Similar to var_Error, but returned when the 'err' flag for Var_Parse is
 * set false. Why not just use a constant? Well, gcc likes to condense
 * identical string instances...
 */
static char	varNoError[] = "";
bool		errorIsOkay;
static bool	checkEnvFirst;	/* true if environment should be searched for
				 * variables before the global context */

void
Var_setCheckEnvFirst(bool yes)
{
	checkEnvFirst = yes;
}

/*
 * The rules for variable look-up are complicated.
 *
 * - Dynamic variables like $@@ and $* are special. They always pertain to
 * a given variable.  In this implementation of make, it is an error to
 * try to affect them manually. They are stored in a local symtable directly
 * inside the gnode.
 *
 * Global variables can be obtained:
 * - from the command line
 * - from the environment
 * - from the Makefile proper.
 * All of these are stored in a hash global_variables.
 *
 * Variables set on the command line override Makefile contents, are
 * passed to submakes (see Var_AddCmdLine), and are also exported to the
 * environment.
 *
 * Without -e (!checkEnvFirst), make will see variables set in the
 * Makefile, and default to the environment otherwise.
 *
 * With -e (checkEnvFirst), make will see the environment first, and that
 * will override anything that's set in the Makefile (but not set on
 * the command line).
 *
 * The SHELL variable is very special: it is never obtained from the
 * environment, and never passed to the environment.
 */

/* definitions pertaining to dynamic variables */

/* full names of dynamic variables */
static char *varnames[] = {
	TARGET,
	PREFIX,
	ARCHIVE,
	MEMBER,
	IMPSRC,
	OODATE,
	ALLSRC,
	FTARGET,
	DTARGET,
	FPREFIX,
	DPREFIX,
	FARCHIVE,
	DARCHIVE,
	FMEMBER,
	DMEMBER,
	FIMPSRC,
	DIMPSRC
};

static bool xtlist[] = {
	false,	/* GLOBAL_INDEX */
	true,	/* $@@ */
	false,	/* $* */
	false,	/* $! */
	true,	/* $% */
	true,	/* $< */
	false,	/* $? */
	false,	/* $> */
	true,	/* ${@@F} */
	true,	/* ${@@D} */
	false,	/* ${*F} */
	false,	/* ${*D} */
	false,	/* ${!F} */
	false,	/* ${!D} */
	true,	/* ${%F} */
	true,	/* ${%D} */
	true,	/* ${<F} */
	true,	/* ${<D} */
};

/* so that we can access tlist[-1] */
static bool *tlist = xtlist+1;

/* hashed names of dynamic variables */
#include    "varhashconsts.h"

/* extended indices for System V stuff */
#define FTARGET_INDEX	7
#define DTARGET_INDEX	8
#define FPREFIX_INDEX	9
#define DPREFIX_INDEX	10
#define FARCHIVE_INDEX	11
#define DARCHIVE_INDEX	12
#define FMEMBER_INDEX	13
#define DMEMBER_INDEX	14
#define FIMPSRC_INDEX	15
#define DIMPSRC_INDEX	16

#define GLOBAL_INDEX	-1

#define EXTENDED2SIMPLE(i)	(((i)-LOCAL_SIZE)/2)
#define IS_EXTENDED_F(i)	((i)%2 == 1)


static struct ohash global_variables;


typedef struct Var_ {
	BUFFER val;		/* the variable value */
	unsigned int flags;	/* miscellaneous status flags */
#define VAR_IN_USE	1	/* Variable's value currently being used. */
				/* (Used to avoid recursion) */
#define VAR_DUMMY	2	/* Variable is currently just a name */
				/* In particular: BUFFER is invalid */
#define VAR_FROM_CMD	4	/* Special source: command line */
#define VAR_FROM_ENV	8	/* Special source: environment */
#define VAR_SEEN_ENV	16	/* No need to go look up environment again */
#define VAR_SHELL	32	/* Magic behavior */

#define POISONS (POISON_NORMAL | POISON_EMPTY | POISON_NOT_DEFINED)
				/* Defined in var.h */
	char name[1];		/* the variable's name */
}  Var;


static struct ohash_info var_info = {
	offsetof(Var, name),
	NULL,
	hash_calloc, hash_free, element_alloc
};

static int classify_var(const char *, const char **, uint32_t *);
static Var *find_global_var(const char *, const char *, uint32_t);
static Var *find_global_var_without_env(const char *, const char *, uint32_t);
static void fill_from_env(Var *);
static Var *create_var(const char *, const char *);
static void var_set_initial_value(Var *, const char *);
static void var_set_value(Var *, const char *);
#define var_get_value(v)	((v)->flags & VAR_EXEC_LATER ? \
	var_exec_cmd(v) : \
	Buf_Retrieve(&((v)->val)))
static char *var_exec_cmd(Var *);
static void var_append_value(Var *, const char *);
static void poison_check(Var *);
static void var_set_append(const char *, const char *, const char *, int, bool);
static void set_magic_shell_variable(void);

static void delete_var(Var *);
static void print_var(Var *);


static const char *find_rparen(const char *);
static const char *find_ket(const char *);
typedef const char * (*find_t)(const char *);
static find_t find_pos(int);
static void push_used(Var *);
static void pop_used(Var *);
static char *get_expanded_value(const char *, const char *, int, uint32_t,
    SymTable *, bool, bool *);
static bool parse_base_variable_name(const char **, struct Name *, SymTable *);



/* Variable lookup function: return idx for dynamic variable, or
 * GLOBAL_INDEX if name is not dynamic. Set up *pk for further use.
 */
static int
classify_var(const char *name, const char **enamePtr, uint32_t *pk)
{
	size_t len;

	*pk = ohash_interval(name, enamePtr);
	len = *enamePtr - name;
	    /* substitute short version for long local name */
	switch (*pk % MAGICSLOTS1) {	/* MAGICSLOTS should be the    */
	case K_LONGALLSRC % MAGICSLOTS1:/* smallest constant yielding  */
					/* distinct case values	   */
		if (*pk == K_LONGALLSRC && len == strlen(LONGALLSRC) &&
		    strncmp(name, LONGALLSRC, len) == 0)
			return ALLSRC_INDEX;
		break;
	case K_LONGARCHIVE % MAGICSLOTS1:
		if (*pk == K_LONGARCHIVE && len == strlen(LONGARCHIVE) &&
		    strncmp(name, LONGARCHIVE, len) == 0)
			return ARCHIVE_INDEX;
		break;
	case K_LONGIMPSRC % MAGICSLOTS1:
		if (*pk == K_LONGIMPSRC && len == strlen(LONGIMPSRC) &&
		    strncmp(name, LONGIMPSRC, len) == 0)
			return IMPSRC_INDEX;
		break;
	case K_LONGMEMBER % MAGICSLOTS1:
		if (*pk == K_LONGMEMBER && len == strlen(LONGMEMBER) &&
		    strncmp(name, LONGMEMBER, len) == 0)
			return MEMBER_INDEX;
		break;
	case K_LONGOODATE % MAGICSLOTS1:
		if (*pk == K_LONGOODATE && len == strlen(LONGOODATE) &&
		    strncmp(name, LONGOODATE, len) == 0)
			return OODATE_INDEX;
		break;
	case K_LONGPREFIX % MAGICSLOTS1:
		if (*pk == K_LONGPREFIX && len == strlen(LONGPREFIX) &&
		    strncmp(name, LONGPREFIX, len) == 0)
			return PREFIX_INDEX;
		break;
	case K_LONGTARGET % MAGICSLOTS1:
		if (*pk == K_LONGTARGET && len == strlen(LONGTARGET) &&
		    strncmp(name, LONGTARGET, len) == 0)
			return TARGET_INDEX;
		break;
	case K_TARGET % MAGICSLOTS1:
		if (name[0] == TARGET[0] && len == 1)
			return TARGET_INDEX;
		break;
	case K_OODATE % MAGICSLOTS1:
		if (name[0] == OODATE[0] && len == 1)
			return OODATE_INDEX;
		break;
	case K_ALLSRC % MAGICSLOTS1:
		if (name[0] == ALLSRC[0] && len == 1)
			return ALLSRC_INDEX;
		break;
	case K_IMPSRC % MAGICSLOTS1:
		if (name[0] == IMPSRC[0] && len == 1)
			return IMPSRC_INDEX;
		break;
	case K_PREFIX % MAGICSLOTS1:
		if (name[0] == PREFIX[0] && len == 1)
			return PREFIX_INDEX;
		break;
	case K_ARCHIVE % MAGICSLOTS1:
		if (name[0] == ARCHIVE[0] && len == 1)
			return ARCHIVE_INDEX;
		break;
	case K_MEMBER % MAGICSLOTS1:
		if (name[0] == MEMBER[0] && len == 1)
			return MEMBER_INDEX;
		break;
	case K_FTARGET % MAGICSLOTS1:
		if (name[0] == FTARGET[0] && name[1] == FTARGET[1] && len == 2)
			return FTARGET_INDEX;
		break;
	case K_DTARGET % MAGICSLOTS1:
		if (name[0] == DTARGET[0] && name[1] == DTARGET[1] && len == 2)
			return DTARGET_INDEX;
		break;
	case K_FPREFIX % MAGICSLOTS1:
		if (name[0] == FPREFIX[0] && name[1] == FPREFIX[1] && len == 2)
			return FPREFIX_INDEX;
		break;
	case K_DPREFIX % MAGICSLOTS1:
		if (name[0] == DPREFIX[0] && name[1] == DPREFIX[1] && len == 2)
			return DPREFIX_INDEX;
		break;
	case K_FARCHIVE % MAGICSLOTS1:
		if (name[0] == FARCHIVE[0] && name[1] == FARCHIVE[1] &&
		    len == 2)
			return FARCHIVE_INDEX;
		break;
	case K_DARCHIVE % MAGICSLOTS1:
		if (name[0] == DARCHIVE[0] && name[1] == DARCHIVE[1] &&
		    len == 2)
			return DARCHIVE_INDEX;
		break;
	case K_FMEMBER % MAGICSLOTS1:
		if (name[0] == FMEMBER[0] && name[1] == FMEMBER[1] && len == 2)
			return FMEMBER_INDEX;
		break;
	case K_DMEMBER % MAGICSLOTS1:
		if (name[0] == DMEMBER[0] && name[1] == DMEMBER[1] && len == 2)
			return DMEMBER_INDEX;
		break;
	case K_FIMPSRC % MAGICSLOTS1:
		if (name[0] == FIMPSRC[0] && name[1] == FIMPSRC[1] && len == 2)
			return FIMPSRC_INDEX;
		break;
	case K_DIMPSRC % MAGICSLOTS1:
		if (name[0] == DIMPSRC[0] && name[1] == DIMPSRC[1] && len == 2)
			return DIMPSRC_INDEX;
		break;
	default:
		break;
	}
	return GLOBAL_INDEX;
}


/***
 ***	Internal handling of variables.
 ***/


/* Create a new variable, does not initialize anything except the name.
 * in particular, buffer is invalid, and flag value is invalid. Accordingly,
 * must either:
 * - set flags to VAR_DUMMY
 * - set flags to !VAR_DUMMY, and initialize buffer, for instance with
 * var_set_initial_value().
 */
static Var *
create_var(const char *name, const char *ename)
{
	return ohash_create_entry(&var_info, name, &ename);
}

/* Initial version of var_set_value(), to be called after create_var().
 */
static void
var_set_initial_value(Var *v, const char *val)
{
	size_t len;

	len = strlen(val);
	Buf_Init(&(v->val), len+1);
	Buf_AddChars(&(v->val), len, val);
}

/* Normal version of var_set_value(), to be called after variable is fully
 * initialized.
 */
static void
var_set_value(Var *v, const char *val)
{
	if ((v->flags & VAR_DUMMY) == 0) {
		Buf_Reset(&(v->val));
		Buf_AddString(&(v->val), val);
	} else {
		var_set_initial_value(v, val);
		v->flags &= ~VAR_DUMMY;
	}
}

/* Add to a variable, insert a separating space if the variable was already
 * defined.
 */
static void
var_append_value(Var *v, const char *val)
{
	if ((v->flags & VAR_DUMMY) == 0) {
		Buf_AddSpace(&(v->val));
		Buf_AddString(&(v->val), val);
	} else {
		var_set_initial_value(v, val);
		v->flags &= ~VAR_DUMMY;
	}
}


/* Delete a variable and all the space associated with it.
 */
static void
delete_var(Var *v)
{
	if ((v->flags & VAR_DUMMY) == 0)
		Buf_Destroy(&(v->val));
	free(v);
}




/***
 ***	Dynamic variable handling.
 ***/



/* create empty symtable.
 * XXX: to save space, dynamic variables may be NULL pointers.
 */
void
SymTable_Init(SymTable *ctxt)
{
	static SymTable sym_template;
	memcpy(ctxt, &sym_template, sizeof(*ctxt));
}

/***
 ***	Global variable handling.
 ***/

/* Create a new global var if necessary, and set it up correctly.
 * Do not take environment into account.
 */
static Var *
find_global_var_without_env(const char *name, const char *ename, uint32_t k)
{
	unsigned int slot;
	Var *v;

	slot = ohash_lookup_interval(&global_variables, name, ename, k);
	v = ohash_find(&global_variables, slot);
	if (v == NULL) {
		v = create_var(name, ename);
		v->flags = VAR_DUMMY;
		ohash_insert(&global_variables, slot, v);
	}
	return v;
}

/* Helper for find_global_var(): grab environment value if needed.
 */
static void
fill_from_env(Var *v)
{
	char	*env;

	env = getenv(v->name);
	if (env == NULL)
		v->flags |= VAR_SEEN_ENV;
	else {
		var_set_value(v, env);
		v->flags |= VAR_FROM_ENV | VAR_SEEN_ENV;
	}

#ifdef STATS_VAR_LOOKUP
	STAT_VAR_FROM_ENV++;
#endif
}

/* Find global var, and obtain its value from the environment if needed.
 */
static Var *
find_global_var(const char *name, const char *ename, uint32_t k)
{
	Var *v;

	v = find_global_var_without_env(name, ename, k);

	if ((v->flags & VAR_SEEN_ENV) == 0)
		if ((checkEnvFirst && (v->flags & VAR_FROM_CMD) == 0) ||
		    (v->flags & VAR_DUMMY) != 0)
			fill_from_env(v);

	return v;
}

/* mark variable with special flags, in a given setup.
 */
void
Var_Mark(const char *name, const char *ename, unsigned int type)
{
	Var   *v;
	uint32_t	k;
	int		idx;
	idx = classify_var(name, &ename, &k);

	if (idx != GLOBAL_INDEX) {
		Parse_Error(PARSE_FATAL,
		    "Trying to poison dynamic variable $%s",
		    varnames[idx]);
		return;
	}

	v = find_global_var(name, ename, k);
	v->flags |= type;
	/* POISON_NORMAL is not lazy: if the variable already exists in
	 * the Makefile, then it's a mistake.
	 */
	if (v->flags & POISON_NORMAL) {
		if (v->flags & VAR_DUMMY)
			return;
		if (v->flags & VAR_FROM_ENV)
			return;
		Parse_Error(PARSE_FATAL,
		    "Poisoned variable %s is already set\n", v->name);
	}
}

/* Check if there's any reason not to use the variable in this context.
 */
static void
poison_check(Var *v)
{
	if (v->flags & POISON_NORMAL) {
		Parse_Error(PARSE_FATAL,
		    "Poisoned variable %s has been referenced\n", v->name);
		return;
	}
	if (v->flags & VAR_DUMMY) {
		Parse_Error(PARSE_FATAL,
		    "Poisoned variable %s is not defined\n", v->name);
		return;
	}
	if (v->flags & POISON_EMPTY)
		if (strcmp(var_get_value(v), "") == 0)
			Parse_Error(PARSE_FATAL,
			    "Poisoned variable %s is empty\n", v->name);
}

/* Delete global variable.
 */
void
Var_Deletei(const char *name, const char *ename)
{
	Var *v;
	uint32_t k;
	unsigned int slot;
	int idx;

	idx = classify_var(name, &ename, &k);
	if (idx != GLOBAL_INDEX) {
		Parse_Error(PARSE_FATAL,
		    "Trying to delete dynamic variable $%s", varnames[idx]);
		return;
	}
	slot = ohash_lookup_interval(&global_variables, name, ename, k);
	v = ohash_find(&global_variables, slot);

	if (v == NULL)
		return;

	if (checkEnvFirst && (v->flags & VAR_FROM_ENV))
		return;

	if (v->flags & VAR_FROM_CMD)
		return;

	ohash_remove(&global_variables, slot);
	delete_var(v);
}

/* Set or add a global variable, in VAR_CMD or VAR_GLOBAL context.
 */
static void
var_set_append(const char *name, const char *ename, const char *val, int ctxt,
    bool append)
{
	Var *v;
	uint32_t k;
	int idx;

	idx = classify_var(name, &ename, &k);
	if (idx != GLOBAL_INDEX) {
		Parse_Error(PARSE_FATAL, "Trying to %s dynamic variable $%s",
		    append ? "append to" : "set", varnames[idx]);
		return;
	}

	v = find_global_var(name, ename, k);
	if (v->flags & POISON_NORMAL)
		Parse_Error(PARSE_FATAL, "Trying to %s poisoned variable %s\n",
		    append ? "append to" : "set", v->name);
	/* so can we write to it ? */
	if (ctxt == VAR_CMD) {	/* always for command line */
		(append ? var_append_value : var_set_value)(v, val);
		v->flags |= VAR_FROM_CMD;
		if ((v->flags & VAR_SHELL) == 0) {
			/* Any variables given on the command line are
			 * automatically exported to the environment,
			 * except for SHELL (as per POSIX standard).
			 */
			esetenv(v->name, val);
		}
		if (DEBUG(VAR))
			printf("command:%s = %s\n", v->name, var_get_value(v));
	} else if ((v->flags & VAR_FROM_CMD) == 0 &&
	     (!checkEnvFirst || (v->flags & VAR_FROM_ENV) == 0)) {
		(append ? var_append_value : var_set_value)(v, val);
		if (DEBUG(VAR))
			printf("global:%s = %s\n", v->name, var_get_value(v));
	} else if (DEBUG(VAR))
		printf("overridden:%s = %s\n", v->name, var_get_value(v));
}

void
Var_Seti_with_ctxt(const char *name, const char *ename, const char *val,
    int ctxt)
{
	var_set_append(name, ename, val, ctxt, false);
}

void
Var_Appendi_with_ctxt(const char *name, const char *ename, const char *val,
    int ctxt)
{
	var_set_append(name, ename, val, ctxt, true);
}

static char *
var_exec_cmd(Var *v)
{
	char *arg = Buf_Retrieve(&(v->val));
	char *err;
	char *res1;
	res1 = Cmd_Exec(arg, &err);
	if (err)
		Parse_Error(PARSE_WARNING, err, arg);
	var_set_value(v, res1);
	free(res1);
	v->flags &= ~VAR_EXEC_LATER;
	return Buf_Retrieve(&(v->val));
}

/* XXX different semantics for Var_Valuei() and Var_Definedi():
 * references to poisoned value variables will error out in Var_Valuei(),
 * but not in Var_Definedi(), so the following construct works:
 *	.poison BINDIR
 *	BINDIR ?= /usr/bin
 */
char *
Var_Valuei(const char *name, const char *ename)
{
	Var *v;
	uint32_t k;
	int idx;

	idx = classify_var(name, &ename, &k);
	if (idx != GLOBAL_INDEX) {
		Parse_Error(PARSE_FATAL,
		    "Trying to get value of dynamic variable $%s",
			varnames[idx]);
		return NULL;
	}
	v = find_global_var(name, ename, k);
	if (v->flags & POISONS)
		poison_check(v);
	if ((v->flags & VAR_DUMMY) == 0)
		return var_get_value(v);
	else
		return NULL;
}

bool
Var_Definedi(const char *name, const char *ename)
{
	Var *v;
	uint32_t k;
	int idx;

	idx = classify_var(name, &ename, &k);
	/* We don't bother writing an error message for dynamic variables,
	 * these will be caught when getting set later, usually.
	 */
	if (idx == GLOBAL_INDEX) {
		v = find_global_var(name, ename, k);
		if (v->flags & POISON_NORMAL)
			poison_check(v);
		if ((v->flags & VAR_DUMMY) == 0)
			return true;
	}
	return false;
}


/***
 ***	Substitution functions, handling both global and dynamic variables.
 ***/


/* All the scanning functions needed to account for all the forms of
 * variable names that exist:
 *	$A, ${AB}, $(ABC), ${A:mod}, $(A:mod)
 */

static const char *
find_rparen(const char *p)
{
	while (*p != '$' && *p != '\0' && *p != ')' && *p != ':')
		p++;
	return p;
}

static const char *
find_ket(const char *p)
{
	while (*p != '$' && *p != '\0' && *p != '}' && *p != ':')
		p++;
	return p;
}

/* Figure out what kind of name we're looking for from a start character.
 */
static find_t
find_pos(int c)
{
	switch(c) {
	case '(':
		return find_rparen;
	case '{':
		return find_ket;
	default:
		Parse_Error(PARSE_FATAL,
		    "Wrong character in variable spec %c (can't happen)", c);
		return find_rparen;
	}
}

static bool
parse_base_variable_name(const char **pstr, struct Name *name, SymTable *ctxt)
{
	const char *str = *pstr;
	const char *tstr;
	bool has_modifier = false;

	switch(str[1]) {
	case '(':
	case '{':
		/* Find eventual modifiers in the variable */
		tstr = VarName_Get(str+2, name, ctxt, false, find_pos(str[1]));
		if (*tstr == '\0')
			 Parse_Error(PARSE_FATAL, "Unterminated variable spec in %s", *pstr);
		else if (*tstr == ':')
			has_modifier = true;
		else
			tstr++;
		break;
	default:
		name->s = str+1;
		name->e = str+2;
		name->tofree = false;
		tstr = str + 2;
		break;
	}
	*pstr = tstr;
	return has_modifier;
}

bool
Var_ParseSkip(const char **pstr, SymTable *ctxt)
{
	const char *str = *pstr;
	struct Name name;
	bool result;
	bool has_modifier;
	const char *tstr = str;

	if (str[1] == 0) {
		*pstr = str+1;
		return false;
	}
	has_modifier = parse_base_variable_name(&tstr, &name, ctxt);
	VarName_Free(&name);
	result = true;
	if (has_modifier) {
		bool freePtr = false;
		char *s = VarModifiers_Apply(NULL, NULL, ctxt, true, &freePtr, 
		    &tstr, str[1]);
		if (s == var_Error)
			result = false;
		if (freePtr)
			free(s);
	}
	*pstr = tstr;
	return result;
}

/* As of now, Var_ParseBuffer is just a wrapper around Var_Parse. For
 * speed, it may be better to revisit the implementation to do things
 * directly. */
bool
Var_ParseBuffer(Buffer buf, const char *str, SymTable *ctxt, bool err,
    size_t *lengthPtr)
{
	char *result;
	bool freeIt;

	result = Var_Parse(str, ctxt, err, lengthPtr, &freeIt);
	if (result == var_Error)
		return false;

	Buf_AddString(buf, result);
	if (freeIt)
		free(result);
	return true;
}

/* Helper function for Var_Parse: still recursive, but we tag what variables
 * we expand for better error messages.
 */
#define MAX_DEPTH 350
static Var *call_trace[MAX_DEPTH];
static int current_depth = 0;

static void
push_used(Var *v)
{
	if (v->flags & VAR_IN_USE) {
		int i;
		fprintf(stderr, "Problem with variable expansion chain: ");
		for (i = 0;
		    i < (current_depth > MAX_DEPTH ? MAX_DEPTH : current_depth);
		    i++)
			fprintf(stderr, "%s -> ", call_trace[i]->name);
		fprintf(stderr, "%s\n", v->name);
		Fatal("\tVariable %s is recursive.", v->name);
		/*NOTREACHED*/
	}

	v->flags |= VAR_IN_USE;
	if (current_depth < MAX_DEPTH)
		call_trace[current_depth] = v;
	current_depth++;
}

static void
pop_used(Var *v)
{
	v->flags &= ~VAR_IN_USE;
	current_depth--;
}

static char *
get_expanded_value(const char *name, const char *ename, int idx, uint32_t k,
    SymTable *ctxt, bool err, bool *freePtr)
{
	char *val;

	/* Before doing any modification, we have to make sure the
	 * value has been fully expanded. If it looks like recursion
	 * might be necessary (there's a dollar sign somewhere in
	 * the variable's value) we just call Var_Subst to do any
	 * other substitutions that are necessary. Note that the
	 * value returned by Var_Subst will have been dynamically
	 * allocated, so it will need freeing when we return.
	 */
	if (idx == GLOBAL_INDEX) {
		Var *v = find_global_var(name, ename, k);

		if (v == NULL)
			return NULL;

		if ((v->flags & POISONS) != 0)
			poison_check(v);
		if ((v->flags & VAR_DUMMY) != 0)
			return NULL;

		val = var_get_value(v);
		if (strchr(val, '$') != NULL) {
			push_used(v);
			val = Var_Subst(val, ctxt, err);
			pop_used(v);
			*freePtr = true;
		}
	} else {
		if (ctxt != NULL) {
			if (idx < LOCAL_SIZE)
				val = ctxt->locals[idx];
			else
				val = ctxt->locals[EXTENDED2SIMPLE(idx)];
		} else
			val = NULL;
		if (val == NULL)
			return NULL;

		if (idx >= LOCAL_SIZE) {
			if (IS_EXTENDED_F(idx))
				val = Var_GetTail(val);
			else
				val = Var_GetHead(val);
			*freePtr = true;
		}
	}
	return val;
}

#define ERRMSG1 "Using $< in a non-suffix rule context is a GNUmake idiom "
#define ERRMSG2  "Using undefined dynamic variable $%s "
static void
bad_dynamic_variable(int idx)
{
	Location origin;

	Parse_FillLocation(&origin);
	if (idx >= LOCAL_SIZE)
		idx = EXTENDED2SIMPLE(idx);
	switch(idx) {
	case IMPSRC_INDEX:
		if (origin.fname)
			Fatal(ERRMSG1  "(%s:%lu)", 
			    origin.fname, origin.lineno);
		else if (current_node)
			Fatal(ERRMSG1 "(prereq of %s)", current_node->name);
		else
			Fatal(ERRMSG1 "(?)");
		break;
	default:
		if (origin.fname)
			Error(ERRMSG2 "(%s:%lu)", varnames[idx], 
			    origin.fname, origin.lineno);
		else if (current_node)
			Error(ERRMSG2 "(prereq of %s)", varnames[idx], 
			    current_node->name);
		else 
			Error(ERRMSG2 "(?)", varnames[idx]);
		break;
    	}
}

char *
Var_Parse(const char *str,	/* The string to parse */
    SymTable *ctxt,		/* The context for the variable */
    bool err,			/* true if undefined variables are an error */
    size_t *lengthPtr,		/* OUT: The length of the specification */
    bool *freePtr)		/* OUT: true if caller should free result */
{
	const char *tstr;
	struct Name name;
	char *val;
	uint32_t k;
	int idx;
	bool has_modifier;

	*freePtr = false;

	tstr = str;

	if (str[1] == 0) {
		*lengthPtr = 1;
		*freePtr = false;
		return err ? var_Error : varNoError;
	}

	has_modifier = parse_base_variable_name(&tstr, &name, ctxt);

	idx = classify_var(name.s, &name.e, &k);
	val = get_expanded_value(name.s, name.e, idx, k, ctxt, err, freePtr);
	if (has_modifier) {
		val = VarModifiers_Apply(val, &name, ctxt, err, freePtr,
		    &tstr, str[1]);
	}
	if (val == NULL) {
		val = err ? var_Error : varNoError;
		/* If it comes from a dynamic source, and it doesn't have
		 * a context, copy the spec instead.
		 * Specifically, this make allows constructs like:
		 * 	target.o: $*.c
		 * Absence of a context means "parsing". But these can't
		 * be expanded during parsing, to be consistent with the
		 * way .SUFFIXES work.
		 * .SUFFIXES may be added/reset/removed during parsing,
		 * but in the end, the final list is what's considered for
		 * handling targets.  So those dynamic variables must be
		 * handled lazily too.
		 */
		if (idx != GLOBAL_INDEX) {
			if (ctxt == NULL) {
				*freePtr = true;
				val = Str_dupi(str, tstr);
			} else {
				bad_dynamic_variable(idx);
			}
		}
	}
	VarName_Free(&name);
	*lengthPtr = tstr - str;
	return val;
}


char *
Var_Subst(const char *str,	/* the string in which to substitute */
    SymTable *ctxt,		/* the context wherein to find variables */
    bool undefErr)		/* true if undefineds are an error */
{
	BUFFER buf;		/* Buffer for forming things */
	static bool errorReported;

	Buf_Init(&buf, MAKE_BSIZE);
	errorReported = false;

	for (;;) {
		char *val;	/* Value to substitute for a variable */
		size_t length;	/* Length of the variable invocation */
		bool doFree;	/* Set true if val should be freed */
		const char *cp;

		/* copy uninteresting stuff */
		for (cp = str; *str != '\0' && *str != '$'; str++)
			;
		Buf_Addi(&buf, cp, str);
		if (*str == '\0')
			break;
		if (str[1] == '$') {
			/* A $ may be escaped with another $. */
			Buf_AddChar(&buf, '$');
			str += 2;
			continue;
		}
		val = Var_Parse(str, ctxt, undefErr, &length, &doFree);
		/* When we come down here, val should either point to the
		 * value of this variable, suitably modified, or be NULL.
		 * Length should be the total length of the potential
		 * variable invocation (from $ to end character...) */
		if (val == var_Error || val == varNoError) {
			/* If errors are not an issue, skip over the variable
			 * and continue with the substitution. Otherwise, store
			 * the dollar sign and advance str so we continue with
			 * the string...  */
			if (errorIsOkay)
				str += length;
			else if (undefErr) {
				/* If variable is undefined, complain and
				 * skip the variable name. The complaint
				 * will stop us from doing anything when
				 * the file is parsed.  */
				if (!errorReported)
					Parse_Error(PARSE_FATAL,
					     "Undefined variable \"%.*s\"",
					     (int)length, str);
				str += length;
				errorReported = true;
			} else {
				Buf_AddChar(&buf, *str);
				str++;
			}
		} else {
			/* We've now got a variable structure to store in.
			 * But first, advance the string pointer.  */
			str += length;

			/* Copy all the characters from the variable value
			 * straight into the new string.  */
			Buf_AddString(&buf, val);
			if (doFree)
				free(val);
		}
	}
	return  Buf_Retrieve(&buf);
}

/* Very quick version of the variable scanner that just looks for target
 * variables, and never ever errors out
 */
bool
Var_Check_for_target(const char *str)
{
	bool seen_target = false;

	for (;;) {
		const char *tstr;
		uint32_t k;
		int idx;
		bool has_modifier;
		struct Name name;

		/* skip over uninteresting stuff */
		for (; *str != '\0' && *str != '$'; str++)
			;
		if (*str == '\0')
			break;
		if (str[1] == '$') {
			/* A $ may be escaped with another $. */
			str += 2;
			continue;
		}

		tstr = str;

		has_modifier = parse_base_variable_name(&tstr, &name, NULL);
		idx = classify_var(name.s, &name.e, &k);
		if (has_modifier) {
			bool doFree = false;
			char *val = VarModifiers_Apply(NULL, NULL, NULL, false, 
			    &doFree, &tstr, str[1]);
			if (doFree)
				free(val);
		}
		if (tlist[idx])
			seen_target = true;
		VarName_Free(&name);
		str = tstr;
	}
	return seen_target;
}

static BUFFER subst_buffer;

/* we would like to subst on intervals, but it's complicated, so we cheat
 * by storing the interval in a static buffer.
 */
char *
Var_Substi(const char *str, const char *estr, SymTable *ctxt, bool undefErr)
{
	/* delimited string: no need to copy */
	if (estr == NULL || *estr == '\0')
		return Var_Subst(str, ctxt, undefErr);

	Buf_Reset(&subst_buffer);
	Buf_Addi(&subst_buffer, str, estr);
	return Var_Subst(Buf_Retrieve(&subst_buffer), ctxt, undefErr);
}

/***
 ***	Supplementary support for .for loops.
 ***/



struct LoopVar
{
	Var old;	/* keep old variable value (before the loop) */
	Var *me;	/* the variable we're dealing with */
};


struct LoopVar *
Var_NewLoopVar(const char *name, const char *ename)
{
	struct LoopVar *l;
	uint32_t k;

	l = emalloc(sizeof(struct LoopVar));

	/* we obtain a new variable quickly, make a snapshot of its old
	 * value, and make sure the environment cannot touch us.
	 */
	/* XXX: should we avoid dynamic variables ? */
	k = ohash_interval(name, &ename);

	l->me = find_global_var_without_env(name, ename, k);
	l->old = *(l->me);
	l->me->flags = VAR_SEEN_ENV | VAR_DUMMY;
	return l;
}

char *
Var_LoopVarName(struct LoopVar *v)
{
	return v->me->name;
}

void
Var_DeleteLoopVar(struct LoopVar *l)
{
	if ((l->me->flags & VAR_DUMMY) == 0)
		Buf_Destroy(&(l->me->val));
	*(l->me) = l->old;
	free(l);
}

void
Var_SubstVar(Buffer buf,	/* To store result */
    const char *str,		/* The string in which to substitute */
    struct LoopVar *l,		/* Handle */
    const char *val)		/* Its value */
{
	const char *var = l->me->name;

	var_set_value(l->me, val);

	for (;;) {
		const char *start;
		/* Copy uninteresting stuff */
		for (start = str; *str != '\0' && *str != '$'; str++)
			;
		Buf_Addi(buf, start, str);

		start = str;
		if (*str++ == '\0')
			break;
		str++;
		/* and escaped dollars */
		if (start[1] == '$') {
			Buf_Addi(buf, start, start+2);
			continue;
		}
		/* Simple variable, if it's not us, copy.  */
		if (start[1] != '(' && start[1] != '{') {
			if (start[1] != *var || var[1] != '\0') {
				Buf_AddChars(buf, 2, start);
				continue;
		    }
		} else {
			const char *p;
			char paren = start[1];


			/* Find the end of the variable specification.  */
			p = find_pos(paren)(str);
			/* A variable inside the variable. We don't know how to
			 * expand the external variable at this point, so we
			 * try  again with the nested variable.	*/
			if (*p == '$') {
				Buf_Addi(buf, start, p);
				str = p;
				continue;
			}

			if (strncmp(var, str, p - str) != 0 ||
				var[p - str] != '\0') {
				/* Not the variable we want to expand.	*/
				Buf_Addi(buf, start, p);
				str = p;
				continue;
			}
			if (*p == ':') {
				bool doFree;	/* should val be freed ? */
				char *newval;
				struct Name name;

				doFree = false;
				name.s = var;
				name.e = var + (p-str);

				/* val won't be freed since !doFree, but
				 * VarModifiers_Apply doesn't know that,
				 * hence the cast. */
				newval = VarModifiers_Apply((char *)val,
				    &name, NULL, false, &doFree, &p, paren);
				Buf_AddString(buf, newval);
				if (doFree)
					free(newval);
				str = p;
				continue;
			} else
				str = p+1;
		}
		Buf_AddString(buf, val);
	}
}

/***
 ***	Odds and ends
 ***/

static void
set_magic_shell_variable()
{
	const char *name = "SHELL";
	const char *ename = NULL;
	uint32_t k;
	Var *v;

	k = ohash_interval(name, &ename);
	v = find_global_var_without_env(name, ename, k);
	var_set_value(v, _PATH_BSHELL);
	/* XXX the environment shall never affect it */
	v->flags = VAR_SHELL | VAR_SEEN_ENV;
}

/*
 * Var_Init
 *	Initialize the module
 */
void
Var_Init(void)
{
	ohash_init(&global_variables, 10, &var_info);
	set_magic_shell_variable();


	errorIsOkay = true;
	Var_setCheckEnvFirst(false);

	VarModifiers_Init();
	Buf_Init(&subst_buffer, MAKE_BSIZE);
}


static const char *interpret(int);

static const char *
interpret(int f)
{
	if (f & VAR_DUMMY)
		return "(D)";
	return "";
}


static void
print_var(Var *v)
{
	printf("%-16s%s = %s\n", v->name, interpret(v->flags),
	    (v->flags & VAR_DUMMY) == 0 ? var_get_value(v) : "(none)");
}


void
Var_Dump(void)
{
	Var **t;

	unsigned int i;
	const char *banner;
	bool first = true;

	t = sort_ohash_by_name(&global_variables);
/* somewhat dirty, but does the trick */

#define LOOP(mask, value, do_stuff) \
	for (i = 0; t[i] != NULL; i++) \
		if ((t[i]->flags & (mask)) == (value)) { \
			if (banner) { \
				if (first) \
					first = false; \
				else \
					putchar('\n'); \
				fputs(banner, stdout); \
				banner = NULL; \
			} \
		    do_stuff; \
		}

	banner = "#variables from command line:\n";
	LOOP(VAR_FROM_CMD | VAR_DUMMY, VAR_FROM_CMD, print_var(t[i]));

	banner = "#global variables:\n";
	LOOP(VAR_FROM_ENV| VAR_FROM_CMD | VAR_DUMMY, 0, print_var(t[i]));

	banner = "#variables from env:\n";
	LOOP(VAR_FROM_ENV|VAR_DUMMY, VAR_FROM_ENV, print_var(t[i]));

	banner = "#variable name seen, but not defined:";
	LOOP(VAR_DUMMY|POISONS, VAR_DUMMY, printf(" %s", t[i]->name));

#undef LOOP

	printf("\n\n");

	for (i = 0; t[i] != NULL; i++)
		switch(t[i]->flags & POISONS) {
		case POISON_NORMAL:
			printf(".poison %s\n", t[i]->name);
			break;
		case POISON_EMPTY:
			printf(".poison empty(%s)\n", t[i]->name);
			break;
		case POISON_NOT_DEFINED:
			printf(".poison !defined(%s)\n", t[i]->name);
			break;
		default:
			break;
		}
	free(t);
	printf("\n");
}

static const char *quotable = " \t\n\\'\"";

/* POSIX says that variable assignments passed on the command line should be
 * propagated to sub makes through MAKEFLAGS.
 */
void
Var_AddCmdline(const char *name)
{
	Var *v;
	unsigned int i;
	BUFFER buf;
	char *s;

	Buf_Init(&buf, MAKE_BSIZE);

	for (v = ohash_first(&global_variables, &i); v != NULL;
	    v = ohash_next(&global_variables, &i)) {
		/* This is not as expensive as it looks: this function is
		 * called before parsing Makefiles, so there are just a
		 * few non cmdling variables in there.
		 */
		if (!(v->flags & VAR_FROM_CMD)) {
			continue;
		}
		/* We assume variable names don't need quoting */
		Buf_AddString(&buf, v->name);
		Buf_AddChar(&buf, '=');
		for (s = var_get_value(v); *s != '\0'; s++) {
			if (strchr(quotable, *s))
				Buf_AddChar(&buf, '\\');
			Buf_AddChar(&buf, *s);
		}
		Buf_AddSpace(&buf);
	}
	Var_Append(name, Buf_Retrieve(&buf));
	Buf_Destroy(&buf);
}
@


1.100
log
@Implement the ${<D} and ${<F} variables, as documented in the manual.
They are equivalent to ${<:H} and ${<:T} repectively, however the former
variants are more portable, as they are understood by GNU, FreeBSD and
NetBSD make too.

absence of those variables reported by Dario Niedermann <dnied at tiscali.it>
ok millert espie
@
text
@d1 1
a1 1
/*	$OpenBSD: var.c,v 1.99 2015/09/27 16:58:16 guenther Exp $	*/
d75 1
d245 4
a248 1
#define var_get_value(v)	Buf_Retrieve(&((v)->val))
d545 1
a545 1
/* mark variable as poisoned, in a given setup.
d548 1
a548 1
Var_MarkPoisoned(const char *name, const char *ename, unsigned int type)
d685 15
@


1.99
log
@Mark all the error printing functions as printf-like; fix two format
mismatches this revealed

ok espie@@
@
text
@d1 1
a1 1
/*	$OpenBSD: var.c,v 1.98 2014/05/12 19:11:19 espie Exp $	*/
d150 1
a152 1
	IMPSRC,
d160 3
a162 1
	DMEMBER
d171 1
a173 1
	true,	/* $< */
d182 2
d201 2
d374 9
a382 1
		    return DMEMBER_INDEX;
@


1.98
log
@adjust to ohash being in libutil now, and to the interface changes.
fix potential integer overflows in memory allocation (mostly for pedagogical
purposes, these are unlikely to overflow in practice)
move the rest of lst.lib stuff into its own directory.
@
text
@d1 1
a1 1
/*	$OpenBSD: var.c,v 1.97 2014/01/29 23:53:20 espie Exp $	*/
d758 1
a758 1
		    "Wrong character in variable spec %c (can't happen)");
d1074 1
a1074 1
					     length, str);
@


1.97
log
@I'm a bit dyslexic. Found out by Jan Klemkow. Thanks.
@
text
@d1 1
a1 1
/*	$OpenBSD: var.c,v 1.96 2014/01/06 12:15:40 espie Exp $	*/
d228 1
a228 1
	hash_alloc, hash_free, element_alloc
@


1.96
log
@this actually requires a comment. I would never have figured it out if
it wasn't for the arm error.
@
text
@d1 1
a1 1
/*	$OpenBSD: var.c,v 1.95 2014/01/06 12:08:18 espie Exp $	*/
d945 1
a945 1
			    origin.lineno, origin.fname);
d954 1
a954 1
			    origin.lineno, origin.fname);
@


1.95
log
@fix error messages, avoid dereferencing null pointers.
- the code becomes too indented, pull it into a separate function
- add an extra hint, the current_gnode.
- specifically, variables may be expanded during
target: prereq  solving in Suff_FindDeps, this is after parsing,
not during command execution, and the only actual indication with have is
that we're resolving a prereq of.

(this ought to fix mk35, and partially solve mk34)
@
text
@d1 1
a1 1
/*	$OpenBSD: var.c,v 1.94 2013/04/23 14:32:53 espie Exp $	*/
d998 12
a1009 1
		/* Dynamic source */
a1010 1
			/* can't be expanded for now: copy the spec instead. */
@


1.94
log
@remove TIMESTAMP abstraction layer, prodded by theo.
while there, clean up includes.
use strtoll for ar timestamps (pretty much unused in reality, more
standard conforming than anything)

use idea from Todd to adapt to time_t being 32 bits OR 64 bits
(pedantically correct: INT_MIN would work just fine up to 1910 or so...)

okay millert@@, gone thru a make build.
@
text
@d1 1
a1 1
/*	$OpenBSD: var.c,v 1.93 2013/02/15 18:34:25 espie Exp $	*/
d96 1
d931 33
d1005 1
a1005 18
				Location origin;

				Parse_FillLocation(&origin);
				if (idx >= LOCAL_SIZE)
					idx = EXTENDED2SIMPLE(idx);
				switch(idx) {
				case IMPSRC_INDEX:
					Fatal(
"Using $< in a non-suffix rule context is a GNUmake idiom (line %lu of %s)",
					    origin.lineno, origin.fname);
					break;
				default:
					Error(
"Using undefined dynamic variable $%s (line %lu of %s)",
					    varnames[idx], origin.lineno, 
					    origin.fname);
					break;
				}
@


1.93
log
@turns out if a line ends with a $, the var module will run off the cliff
while expanding it.
shows up very prominently with MALLOC_OPTIONS=S

Problem found by jasper@@

okay'd by jasper@@ and kind-of duh'd by miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: var.c,v 1.92 2012/10/09 19:39:59 espie Exp $	*/
d66 1
a67 1
#include <stdint.h>
d70 1
a75 1
#include "ohash.h"
@


1.92
log
@new interface: look in command lines for variables that indicate a list of
targets is actually separate targets.
@
text
@d1 1
a1 1
/*	$OpenBSD: var.c,v 1.91 2012/10/02 10:29:31 espie Exp $	*/
d801 4
d947 6
@


1.91
log
@more changes, discussed and tested by various people.
- put back some job control, turns out it's necessary when we don't run a
shell.
- zap old #ifdef CLEANUP code... probably doesn't even compile.
- kill most of the OP_LIB code. Just keep a wee little bit for compatibility
(deprecated .LIBS and .INCLUDES, warns for weird dependencies instead of
erroring out).
- much improved debugging and -p output: sort variables, targets, rules,
output stuff in a nicer format mimicing input.
- better error message when no command is found, explain where the target comes from.
- sort final error list by file.
- show system files in errors as <bsd.prog.mk>
- reincorporate random delay, that was dropped
- optimize siginfo output by not regenerating the whole string each time.
- finish zapping old LocationInfo field that's no longer used.
@
text
@d1 1
a1 1
/*	$OpenBSD: var.c,v 1.90 2012/08/25 08:12:56 espie Exp $	*/
d162 22
d1057 45
@


1.90
log
@- make wrong variable specs (unterminated) parse errors.
- add info to be able to pinpoint parse errors at runtime.
- let job runners abort when a parse error happens while expanding a variable
during execution
- fix an infinite loop when compiling without FEATURE_RECVARS.

okay millert@@, krw@@
the very few errors found out by this (less than 10 over src/X/ports)
fixed trivially beforehand, as requested by deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: var.c,v 1.89 2012/03/22 13:47:12 espie Exp $	*/
d86 2
a443 14
/* free symtable.
 */
#ifdef CLEANUP
void
SymTable_Destroy(SymTable *ctxt)
{
	int i;

	for (i = 0; i < LOCAL_SIZE; i++)
		if (ctxt->locals[i] != NULL)
			delete_var(ctxt->locals[i]);
}
#endif

d939 1
a939 2
			/* somehow, this should have been expanded already. */
				GNode *n;
d941 1
a941 3
				/* XXX */
				n = (GNode *)(((char *)ctxt) -
				    offsetof(GNode, context));
d948 1
a948 1
					    n->origin.lineno, n->origin.fname);
d953 2
a954 2
					    varnames[idx], n->origin.lineno, 
					    n->origin.fname);
a1220 13
#ifdef CLEANUP
void
Var_End(void)
{
	Var *v;
	unsigned int i;

	for (v = ohash_first(&global_variables, &i); v != NULL;
	    v = ohash_next(&global_variables, &i))
		delete_var(v);
}
#endif

d1239 1
d1243 2
a1244 1
	Var *v;
d1246 28
d1275 2
a1276 1
	printf("#*** Global Variables:\n");
d1278 20
a1297 3
	for (v = ohash_first(&global_variables, &i); v != NULL;
	    v = ohash_next(&global_variables, &i))
		print_var(v);
@


1.89
log
@minor cleanup: error messages include lineno and fileno together, so
recognize that and create a struct Location_ for it.

mostly from Jonathan Calmels, a few nits from me.

okay otto@@
@
text
@d1 1
a1 1
/*	$OpenBSD: var.c,v 1.88 2011/06/20 19:05:33 espie Exp $	*/
d764 3
a766 1
		if (*tstr == ':')
d768 1
a768 1
		else if (*tstr != '\0') {
a769 1
		}
@


1.88
log
@fix a segfault found by jasper@@
ok miod@@, otto@@, jasper@@
@
text
@d1 1
a1 1
/*	$OpenBSD: var.c,v 1.87 2010/07/19 19:46:44 espie Exp $	*/
d962 1
a962 1
					    n->lineno, n->fname);
d967 2
a968 1
					    varnames[idx], n->lineno, n->fname);
@


1.87
log
@Correct $OpenBSD$ stuff
@
text
@d1 1
a1 1
/*	$OpenBSD: var.c,v 1.86 2010/04/25 13:59:53 espie Exp $	*/
d793 5
a797 3
	if (has_modifier)
		 if (VarModifiers_Apply(NULL, NULL, ctxt, true, NULL, &tstr,
		    str[1]) == var_Error)
d799 3
@


1.86
log
@pure whitespace cleanup
@
text
@d1 1
a1 2
/*	$OpenPackages$ */
/*	$OpenBSD$	*/
@


1.85
log
@fix loopvar debug prints. Issue reported by naddy@@
@
text
@d858 1
a858 1
get_expanded_value(const char *name, const char *ename, int idx, uint32_t k, 
@


1.84
log
@typo fixed (overriden -> overridden)

ok espie, jmc
@
text
@d2 1
a2 1
/*	$OpenBSD: var.c,v 1.83 2007/11/17 16:39:45 espie Exp $	*/
d1094 6
@


1.83
log
@simplify dynamic variable handling a great deal:
first remove all usage of Varq_Append by building the string directly.
then replace `common' handling with specialized handling for dynamic
strings (since they no longer need a buffer). Finally, identify the place
where the variable value needs to be copied because it's going to be free'd
or erased soon, and finally, use simple char* pointers.

Shaves about 80 bytes off every gnode structure, and kills quite a few
unnecessary malloc()s as well.
@
text
@d2 1
a2 1
/*	$OpenBSD$	*/
d642 1
a642 1
		printf("overriden:%s = %s\n", v->name, var_get_value(v));
@


1.82
log
@prevent gcc from complaining
@
text
@a207 1
static Var *find_any_var(const char *, const char *, SymTable *, int, uint32_t);
a216 1
static void varq_set_append(int, const char *, GNode *, bool);
d230 2
a231 1
static char *get_expanded_value(Var *, int, SymTable *, bool, bool *);
a456 53
/* set or append to dynamic variable.
 */
static void
varq_set_append(int idx, const char *val, GNode *gn, bool append)
{
	Var *v = gn->context.locals[idx];

	if (v == NULL) {
		v = create_var(varnames[idx], NULL);
#ifdef STATS_VAR_LOOKUP
		STAT_VAR_CREATION++;
#endif
		if (val != NULL)
			var_set_initial_value(v, val);
		else
			Buf_Init(&(v->val), 1);
		v->flags = 0;
		gn->context.locals[idx] = v;
	} else {
		if (append)
			Buf_AddSpace(&(v->val));
		else
			Buf_Reset(&(v->val));
		Buf_AddString(&(v->val), val);
	}
	if (DEBUG(VAR))
		printf("%s:%s = %s\n", gn->name, varnames[idx],
		    var_get_value(v));
}

void
Varq_Set(int idx, const char *val, GNode *gn)
{
	varq_set_append(idx, val, gn, false);
}

void
Varq_Append(int idx, const char *val, GNode *gn)
{
	varq_set_append(idx, val, gn, true);
}

char *
Varq_Value(int idx, GNode *gn)
{
	Var *v = gn->context.locals[idx];

	if (v == NULL)
		return NULL;
	else
		return var_get_value(v);
}

a714 20
/* XXX contrary to find_global_var(), find_any_var() can return NULL pointers.
 */
static Var *
find_any_var(const char *name, const char *ename, SymTable *ctxt,
    int idx, uint32_t k)
{
	/* Handle local variables first */
	if (idx != GLOBAL_INDEX) {
		if (ctxt != NULL) {
			if (idx < LOCAL_SIZE)
				return ctxt->locals[idx];
			else
				return ctxt->locals[EXTENDED2SIMPLE(idx)];
		} else
			return NULL;
	} else {
		return find_global_var(name, ename, k);
	}
}

d858 2
a859 1
get_expanded_value(Var *v, int idx, SymTable *ctxt, bool err, bool *freePtr)
a862 8
	if (v == NULL)
		return NULL;

	if ((v->flags & POISONS) != 0)
		poison_check(v);
	if ((v->flags & VAR_DUMMY) != 0)
		return NULL;

a870 1
	val = var_get_value(v);
d872 11
d889 18
a906 6
	} else if (idx >= LOCAL_SIZE) {
		if (IS_EXTENDED_F(idx))
			val = Var_GetTail(val);
		else
			val = Var_GetHead(val);
		*freePtr = true;
a918 1
	Var *v;
d932 1
a932 2
	v = find_any_var(name.s, name.e, ctxt, idx, k);
	val = get_expanded_value(v, idx, ctxt, err, freePtr);
@


1.81
log
@fix some lint FALLTHROUGH
@
text
@d2 1
a2 1
/*	$OpenBSD: var.c,v 1.80 2007/09/17 10:39:33 espie Exp $	*/
d563 4
a566 4
	if ((v->flags & VAR_SEEN_ENV) == 0 &&
	    (checkEnvFirst  && (v->flags & VAR_FROM_CMD) == 0 ||
		(v->flags & VAR_DUMMY) != 0))
		    fill_from_env(v);
@


1.80
log
@more blank space removal
@
text
@d2 1
a2 1
/*	$OpenBSD: var.c,v 1.79 2007/09/17 09:45:37 espie Exp $	*/
d1020 1
@


1.79
log
@more zap spaces
@
text
@d2 1
a2 1
/*	$OpenBSD: var.c,v 1.78 2007/09/17 09:44:20 espie Exp $	*/
d440 1
a440 1
	static SymTable sym_template;	
d642 1
a642 1
	
d864 1
a864 1
	
d1151 1
a1151 1
	l->old = *(l->me);			
d1222 1
a1222 1
				char *newval;	
@


1.78
log
@zap more spaces at end of line
@
text
@d2 1
a2 1
/*	$OpenBSD: var.c,v 1.77 2007/09/17 09:28:36 espie Exp $	*/
d194 1
a194 1
				
@


1.77
log
@kill extra spaces at end of line
@
text
@d2 1
a2 1
/*	$OpenBSD: var.c,v 1.76 2007/09/16 12:01:11 espie Exp $	*/
d101 1
a101 1
bool		errorIsOkay;	
@


1.76
log
@remove warnings
@
text
@d2 1
a2 1
/*	$OpenBSD: var.c,v 1.75 2007/09/16 09:46:14 espie Exp $	*/
d700 1
a700 1
Var_Seti_with_ctxt(const char *name, const char *ename, const char *val, 
d707 1
a707 1
Var_Appendi_with_ctxt(const char *name, const char *ename, const char *val, 
d827 1
a827 1
static bool 
d903 1
a903 1
static void 
d909 2
a910 2
		for (i = 0; 
		    i < (current_depth > MAX_DEPTH ? MAX_DEPTH : current_depth); 
d1108 2
a1109 2
/* we would like to subst on intervals, but it's complicated, so we cheat 
 * by storing the interval in a static buffer. 
d1232 1
a1232 1
				newval = VarModifiers_Apply((char *)val, 
@


1.75
log
@remove dead code: #define RECHECK is always on
@
text
@d2 1
a2 1
/*	$OpenBSD: var.c,v 1.71 2007/07/24 19:00:17 espie Exp $	*/
a858 1
	Var *v;
@


1.74
log
@introduce a Var_Substi to substitute on intervals.
Since we don't really know how to change Var_Subst and dependent functions,
we cheat, and copy the string to a buffer instead.

Clean-up the parser a bit: reorganize the include files lookup function:
introduce a resolve_include_filename function that figures out the full name
of the file, introduce a handle_include_file that does all the include file
handling, and rename the functions into handle_xxx_include, so that we
can remove most comments.

Rename ParseIsCond into handle_bsd_command, cut most of its code into
constituent functions.

Semantic changes:
- follow the rules that, if an optional construct does not parse correctly,
then it's not a real extension, and give the normal parser a chance to figure
it out. If the syntax checks out, semantic errors ARE real errors.
- allow variables to not be defined in include file names, no reason not to.

okay miod@@
@
text
@@


1.73
log
@everywhere except in Var_Parse, we always add/append variables to the
VAR_GLOBAL context, so make it the common case: rename the basic functions
to Var_Set_with_ctxt/Var_Append_with_ctxt, define Var_Set and Var_Append
as macros that specify VAR_GLOBAL, and use these.

okay miod@@
@
text
@d1107 16
d1281 1
@


1.72
log
@now that it's clean enough, one can extract some common code from
Var_Parse and Var_ParseSkip (the code that figures out the variable name
up to eventual modifiers).

okay miod@@
@
text
@d700 2
a701 1
Var_Seti(const char *name, const char *ename, const char *val, int ctxt)
d707 2
a708 1
Var_Appendi(const char *name, const char *ename, const char *val, int ctxt)
d859 1
d1346 1
a1346 1
	Var_Append(name, Buf_Retrieve(&buf), VAR_GLOBAL);
@


1.71
log
@zap unused variable
@
text
@d2 1
a2 1
/*	$OpenBSD: var.c,v 1.70 2007/07/24 18:58:48 espie Exp $	*/
d233 1
d825 2
a826 2
bool
Var_ParseSkip(const char **pstr, SymTable *ctxt)
d828 1
a829 3
	const char *str = *pstr;
	struct Name name;
	bool result;
d836 1
a836 2
		tstr = VarName_Get(str+2, &name, ctxt, false, find_pos(str[1]));
		VarName_Free(&name);
d844 3
d850 15
d981 1
a981 1
	bool has_modifier = false;
d985 3
a987 17
	switch(str[1]) {
	case '(':
	case '{':
		/* Find eventual modifiers in the variable */
		tstr = VarName_Get(str+2, &name, ctxt, false, find_pos(str[1]));
		if (*tstr == ':')
			has_modifier = true;
		else if (*tstr != '\0')
			tstr++;
		break;
	default:
		name.s = str+1;
		name.e = str+2;
		name.tofree = false;
		tstr = str + 2;
		break;
	}
@


1.70
log
@simplify computations in the var module: instead of advancing a char *
and keeping track of a length, we just advance the char *, and ditch
the length. We can still get the length at the end of the top-level
functions to satisfy existing interfaces.

Much simpler code, less error-prone.

Okay millert@@
@
text
@d2 1
a2 1
/*	$OpenBSD: var.c,v 1.64 2007/07/08 17:53:15 espie Exp $	*/
a827 1
	Var *v;
@


1.69
log
@move the code that grabs a value in Var_Parse in its own function,
get_expanded_value.

Extend the code a bit to be much more thorough in case of a recursive
expansion: shows exactly the cycle of variable names involved.

okay millert@@
@
text
@a828 1
	char paren;
a829 2
	const char *start;
	size_t length;
d832 1
d834 3
a836 13
	v = NULL;
	start = str;
	str++;

	if (*str != '(' && *str != '{') {
		name.tofree = false;
		tstr = str + 1;
		length = 2;
		paren = '\0';
	} else {
		paren = *str;
		str++;

d838 1
a838 1
		tstr = VarName_Get(str, &name, ctxt, false, find_pos(paren));
d840 9
a848 3
		length = tstr - start;
		if (*tstr != 0)
			length++;
a849 1

d851 3
a853 3
	if (*tstr == ':' && paren != '\0')
		 if (VarModifiers_Apply(NULL, NULL, ctxt, true, NULL, tstr,
		    paren, &length) == var_Error)
d855 1
a855 1
	*pstr += length;
d960 2
a961 3
	const char *tstr;	/* Pointer into str */
	Var *v;			/* Variable in invocation */
	char paren;		/* Parenthesis or brace or nothing */
d963 1
a963 2
	const char *start;
	char *val;		/* Variable value  */
d966 1
a968 1
	start = str++;
d970 13
a982 7
	val = NULL;
	v = NULL;
	idx = GLOBAL_INDEX;

	if (*str != '(' && *str != '{') {
		name.s = str;
		name.e = str+1;
d984 2
a985 12
		tstr = str + 1;
		*lengthPtr = 2;
		paren = '\0';
	} else {
		paren = *str;
		str++;

		/* Find eventual modifiers in the variable */
		tstr = VarName_Get(str, &name, ctxt, false, find_pos(paren));
		*lengthPtr = tstr - start;
		if (*tstr != '\0')
			(*lengthPtr)++;
d991 1
a991 1
	if (*tstr == ':' && paren != '\0')
d993 2
a994 1
		    tstr, paren, lengthPtr);
d1002 1
a1002 1
				val = Str_dupi(start, start+ *lengthPtr);
d1027 1
a1201 1
				size_t length;	/* Length of variable name */
a1205 1
				length = p - str + 1;
d1213 2
a1214 2
				newval = VarModifiers_Apply((char *)val, &name,
				    NULL, false, &doFree, p, paren, &length);
d1218 1
a1218 1
				str += length;
@


1.68
log
@change Var_ParseSkip API to increment the position instead of returning a
length, simplifies code.

(warns a bit, symptom of some further issues to fix).

okay millert@@
@
text
@d230 3
d886 74
d1003 1
a1003 32
	if (v != NULL && (v->flags & POISONS) != 0)
		poison_check(v);
	if (v != NULL && (v->flags & VAR_DUMMY) == 0) {
		if (v->flags & VAR_IN_USE)
			Fatal("Variable %s is recursive.", v->name);
			/*NOTREACHED*/
		else
			v->flags |= VAR_IN_USE;

		/* Before doing any modification, we have to make sure the
		 * value has been fully expanded. If it looks like recursion
		 * might be necessary (there's a dollar sign somewhere in
		 * the variable's value) we just call Var_Subst to do any
		 * other substitutions that are necessary. Note that the
		 * value returned by Var_Subst will have been dynamically
		 * allocated, so it will need freeing when we return.
		 */
		val = var_get_value(v);
		if (idx == GLOBAL_INDEX) {
			if (strchr(val, '$') != NULL) {
				val = Var_Subst(val, ctxt, err);
				*freePtr = true;
			}
		} else if (idx >= LOCAL_SIZE) {
			if (IS_EXTENDED_F(idx))
				val = Var_GetTail(val);
			else
				val = Var_GetHead(val);
			*freePtr = true;
		}
		v->flags &= ~VAR_IN_USE;
	}
@


1.67
log
@make sure loop variables use their own buffers.
(causes .for loops to give weird results very infrequently, memory handling
was slightly wrong, but not enough to break things thoroughly).
noticed by naddy@@
@
text
@d821 2
a822 2
size_t
Var_ParseSkip(const char *str, SymTable *ctxt, bool *result)
d824 4
a827 3
	const char *tstr;	/* Pointer into str */
	Var *v;			/* Variable in invocation */
	char paren;		/* Parenthesis or brace or nothing */
d831 1
d854 1
a854 2
	if (result != NULL)
		*result = true;
d858 3
a860 3
			if (result != NULL)
				*result = false;
	return length;
@


1.66
log
@big clean-up patch:
- rename a few functions in var.c to names that make more sense.
- introduce Var_Deletei because it makes more sense.
- rewrite .for loops to use a local LoopVar construct to avoid looking up more
stuff.
- reformat var.c to near K&R
- rewrite most comments in var.c

shown to a few people. millert@@ gave me his okay since it passes through
ports correctly.
@
text
@d1097 1
a1097 1
	l->me->flags |= VAR_SEEN_ENV;
d1104 2
@


1.65
log
@reorder stuff in var.c so that the next patch is more readable.
@
text
@d101 3
a103 3
bool 		errorIsOkay;	
static bool 	checkEnvFirst;	/* true if environment should be searched for
			         * variables before the global context */
d112 26
a137 15
 * Variable values are obtained from four different contexts:
 *	1) the process environment. The process environment itself
 *	   may not be changed, but these variables may be modified,
 *	   unless make is invoked with -e, in which case those variables
 *	   are unmodifiable and supersede the global context.
 *	2) the global context. Variables set in the Makefile are located in
 *	    the global context. It is the penultimate context searched when
 *	    substituting.
 *	3) the command-line context. All variables set on the command line
 *	   are placed in this context. They are UNALTERABLE once placed here.
 *	4) the local context. Each target has associated with it a context
 *	   list. On this list are located the structures describing such
 *	   local variables as $(@@) and $(*)
 * The four contexts are searched in the reverse order from which they are
 * listed.
d140 3
d144 16
a159 16
    TARGET,
    PREFIX,
    ARCHIVE,
    MEMBER,
    OODATE,
    ALLSRC,
    IMPSRC,
    FTARGET,
    DTARGET,
    FPREFIX,
    DPREFIX,
    FARCHIVE,
    DARCHIVE,
    FMEMBER,
    DMEMBER
    };
d161 1
a161 1
/* retrieve the hashed values  for well-known variables.  */
d174 2
d179 1
d182 1
d184 2
a185 2
    BUFFER	  val;		/* its value */
    unsigned int  flags;	/* miscellaneous status flags */
d187 8
a194 6
				/* Used to avoid recursion */
#define VAR_DUMMY	2	/* Placeholder: already looked up */
#define VAR_FROM_CMD	4	/* From the command line */
#define VAR_FROM_ENV	8	/* Read from environment */
#define VAR_SEEN_ENV	16	/* Already seen environment */
#define VAR_SHELL	32	/* magic, see posix */
d196 2
a197 1
    char	  name[1];	/* the variable's name */
d203 6
a208 4
    NULL, hash_alloc, hash_free, element_alloc };
static int quick_lookup(const char *, const char **, uint32_t *);
#define VarValue(v)	Buf_Retrieve(&((v)->val))
static Var *varfind(const char *, const char *, SymTable *, int, uint32_t);
d210 1
a210 4
static void VarDelete(Var *);
static void VarPrintVar(Var *);

static Var *obtain_global_var(const char *, const char *, uint32_t);
d213 5
a218 3
static void var_init_string(Var *, const char *);
static void var_set_string(Var *, const char *);
static void var_append_string(Var *, const char *);
d221 5
a225 2
static void poison_check(Var *);
static const char *find_0(const char *);
d231 5
d237 1
a237 1
quick_lookup(const char *name, const char **enamePtr, uint32_t *pk)
d239 1
a239 1
    size_t len;
d241 106
a346 104
    *pk = ohash_interval(name, enamePtr);
    len = *enamePtr - name;
	/* substitute short version for long local name */
    switch (*pk % MAGICSLOTS1) { 	    /* MAGICSLOTS should be the    */
    case K_LONGALLSRC % MAGICSLOTS1:	    /* smallest constant yielding  */
					    /* distinct case values	   */
	if (*pk == K_LONGALLSRC && len == strlen(LONGALLSRC) && 
	    strncmp(name, LONGALLSRC, len) == 0)
	    return ALLSRC_INDEX;
	break;
    case K_LONGARCHIVE % MAGICSLOTS1:
	if (*pk == K_LONGARCHIVE && len == strlen(LONGARCHIVE) &&
	    strncmp(name, LONGARCHIVE, len) == 0)
	    return ARCHIVE_INDEX;
	break;
    case K_LONGIMPSRC % MAGICSLOTS1:
	if (*pk == K_LONGIMPSRC && len == strlen(LONGIMPSRC) &&
	    strncmp(name, LONGIMPSRC, len) == 0)
	    return IMPSRC_INDEX;
	break;
    case K_LONGMEMBER % MAGICSLOTS1:
	if (*pk == K_LONGMEMBER && len == strlen(LONGMEMBER) &&
	    strncmp(name, LONGMEMBER, len) == 0)
	    return MEMBER_INDEX;
	break;
    case K_LONGOODATE % MAGICSLOTS1:
	if (*pk == K_LONGOODATE && len == strlen(LONGOODATE) &&
	    strncmp(name, LONGOODATE, len) == 0)
	    return OODATE_INDEX;
	break;
    case K_LONGPREFIX % MAGICSLOTS1:
	if (*pk == K_LONGPREFIX && len == strlen(LONGPREFIX) &&
	    strncmp(name, LONGPREFIX, len) == 0)
	    return PREFIX_INDEX;
	break;
    case K_LONGTARGET % MAGICSLOTS1:
	if (*pk == K_LONGTARGET && len == strlen(LONGTARGET) &&
	    strncmp(name, LONGTARGET, len) == 0)
	    return TARGET_INDEX;
	break;
    case K_TARGET % MAGICSLOTS1:
	if (name[0] == TARGET[0] && len == 1)
	    return TARGET_INDEX;
	break;
    case K_OODATE % MAGICSLOTS1:
	if (name[0] == OODATE[0] && len == 1)
	    return OODATE_INDEX;
	break;
    case K_ALLSRC % MAGICSLOTS1:
	if (name[0] == ALLSRC[0] && len == 1)
	    return ALLSRC_INDEX;
	break;
    case K_IMPSRC % MAGICSLOTS1:
	if (name[0] == IMPSRC[0] && len == 1)
	    return IMPSRC_INDEX;
	break;
    case K_PREFIX % MAGICSLOTS1:
	if (name[0] == PREFIX[0] && len == 1)
	    return PREFIX_INDEX;
	break;
    case K_ARCHIVE % MAGICSLOTS1:
	if (name[0] == ARCHIVE[0] && len == 1)
	    return ARCHIVE_INDEX;
	break;
    case K_MEMBER % MAGICSLOTS1:
	if (name[0] == MEMBER[0] && len == 1)
	    return MEMBER_INDEX;
	break;
    case K_FTARGET % MAGICSLOTS1:
    	if (name[0] == FTARGET[0] && name[1] == FTARGET[1] && len == 2)
	    return FTARGET_INDEX;
	break;
    case K_DTARGET % MAGICSLOTS1:
    	if (name[0] == DTARGET[0] && name[1] == DTARGET[1] && len == 2)
	    return DTARGET_INDEX;
	break;
    case K_FPREFIX % MAGICSLOTS1:
    	if (name[0] == FPREFIX[0] && name[1] == FPREFIX[1] && len == 2)
	    return FPREFIX_INDEX;
	break;
    case K_DPREFIX % MAGICSLOTS1:
    	if (name[0] == DPREFIX[0] && name[1] == DPREFIX[1] && len == 2)
	    return DPREFIX_INDEX;
	break;
    case K_FARCHIVE % MAGICSLOTS1:
    	if (name[0] == FARCHIVE[0] && name[1] == FARCHIVE[1] && len == 2)
	    return FARCHIVE_INDEX;
	break;
    case K_DARCHIVE % MAGICSLOTS1:
    	if (name[0] == DARCHIVE[0] && name[1] == DARCHIVE[1] && len == 2)
	    return DARCHIVE_INDEX;
	break;
    case K_FMEMBER % MAGICSLOTS1:
    	if (name[0] == FMEMBER[0] && name[1] == FMEMBER[1] && len == 2)
	    return FMEMBER_INDEX;
	break;
    case K_DMEMBER % MAGICSLOTS1:
    	if (name[0] == DMEMBER[0] && name[1] == DMEMBER[1] && len == 2)
	    return DMEMBER_INDEX;
	break;
    default:
	break;
    }
    return -1;
d349 13
d365 1
a365 1
    return ohash_create_entry(&var_info, name, &ename);
d368 2
a369 1
/* Set the initial value a var should have */
d371 1
a371 1
var_init_string(Var *v, const char *val)
d373 1
a373 1
    size_t len;
d375 3
a377 3
    len = strlen(val);
    Buf_Init(&(v->val), len+1);
    Buf_AddChars(&(v->val), len, val);
d380 3
d384 1
a384 1
var_set_string(Var *v, const char *val)
d386 7
a392 7
    if ((v->flags & VAR_DUMMY) == 0) {
	Buf_Reset(&(v->val));
	Buf_AddString(&(v->val), val);
    } else {
    	var_init_string(v, val);
	v->flags &= ~VAR_DUMMY;
    }
d395 3
d399 1
a399 1
var_append_string(Var *v, const char *val)
d401 11
a411 14
    if ((v->flags & VAR_DUMMY) == 0) {
    	Buf_AddSpace(&(v->val));
	Buf_AddString(&(v->val), val);
    } else {
    	var_init_string(v, val);
	v->flags &= ~VAR_DUMMY;
    }
}

/*-
 *-----------------------------------------------------------------------
 * VarDelete  --
 *	Delete a variable and all the space associated with it.
 *-----------------------------------------------------------------------
d414 1
a414 1
VarDelete(Var *v)
d416 3
a418 3
    if ((v->flags & VAR_DUMMY) == 0)
	Buf_Destroy(&(v->val));
    free(v);
d423 10
d436 2
a437 2
    static SymTable sym_template;	
    memcpy(ctxt, &sym_template, sizeof(*ctxt));
d440 2
d446 1
a446 1
    int i;
d448 3
a450 3
    for (i = 0; i < LOCAL_SIZE; i++)
	if (ctxt->locals[i] != NULL)
	    VarDelete(ctxt->locals[i]);
d454 2
d459 1
a459 1
    Var *v = gn->context.locals[idx];
d461 2
a462 2
    if (v == NULL) {
	v = create_var(varnames[idx], NULL);
d464 1
a464 1
	STAT_VAR_CREATION++;
d466 16
a481 15
	if (val != NULL)
	    var_init_string(v, val);
	else
	    Buf_Init(&(v->val), 1);
	v->flags = 0;
	gn->context.locals[idx] = v;
    } else {
    	if (append)
		Buf_AddSpace(&(v->val));
	else
		Buf_Reset(&(v->val));
	Buf_AddString(&(v->val), val);
    }
    if (DEBUG(VAR))
	printf("%s:%s = %s\n", gn->name, varnames[idx], VarValue(v));
d487 1
a487 1
    varq_set_append(idx, val, gn, false);
d493 1
a493 1
    varq_set_append(idx, val, gn, true);
d499 1
a499 1
    Var *v = gn->context.locals[idx];
d501 4
a504 4
    if (v == NULL)
    	return NULL;
    else
	return VarValue(v);
d507 7
d515 1
a515 1
obtain_global_var(const char *name, const char *ename, uint32_t k)
d530 2
d535 1
a535 1
    char	*env;
d537 7
a543 7
    env = getenv(v->name);
    if (env == NULL)
	v->flags |= VAR_SEEN_ENV;
    else {
    	var_set_string(v, env);
	v->flags |= VAR_FROM_ENV | VAR_SEEN_ENV;
    }
d546 1
a546 1
    STAT_VAR_FROM_ENV++;
d550 2
d555 1
a555 1
    Var 		*v;
d557 1
a557 1
    v = obtain_global_var(name, ename, k);
d559 4
a562 4
    if ((v->flags & VAR_SEEN_ENV) == 0 &&
    	(checkEnvFirst  && (v->flags & VAR_FROM_CMD) == 0 || 
	    (v->flags & VAR_DUMMY) != 0))
		fill_from_env(v);
d564 1
a564 1
    return v;
d567 2
a568 1

d575 1
a575 1
	idx = quick_lookup(name, &ename, &k);
d577 2
a578 2
	if (idx != -1) {
		Parse_Error(PARSE_FATAL, 
d586 3
d599 2
d605 1
a605 1
		Parse_Error(PARSE_FATAL, 
d615 2
a616 2
		if (strcmp(VarValue(v), "") == 0)
			Parse_Error(PARSE_FATAL, 
d620 2
d623 1
a623 1
Var_Delete(const char *name)
d625 2
a626 2
	Var 	*v;
	uint32_t 	k;
d628 1
a628 2
	const char 	*ename = NULL;
	int		idx;
d630 6
a635 7

	if (DEBUG(VAR))
		printf("delete %s\n", name);

	idx = quick_lookup(name, &ename, &k);
	if (idx != -1)
		Parse_Error(PARSE_FATAL, "Trying to delete dynamic variable");
d641 1
d649 1
a649 1
	VarDelete(v);
d652 2
d658 3
a660 3
	Var   *v;
	uint32_t	k;
	int		idx;
d662 2
a663 2
	idx = quick_lookup(name, &ename, &k);
	if (idx != -1) {
d674 2
a675 2
	if (ctxt == VAR_CMD) { 	/* always for command line */
		(append ? var_append_string : var_set_string)(v, val);
d678 1
a678 1
			/* Any variables given on the command line are 
d680 1
a680 1
			 * except for SHELL (as per POSIX standard).  
d683 1
a683 1
	    	}
d685 1
a685 1
			printf("command:%s = %s\n", v->name, VarValue(v));
d688 1
a688 1
		(append ? var_append_string : var_set_string)(v, val);
d690 1
a690 1
			printf("global:%s = %s\n", v->name, VarValue(v));
d692 1
a692 1
			printf("overriden:%s = %s\n", v->name, VarValue(v));
d707 6
d716 3
a718 3
	Var 	   *v;
	uint32_t		k;
	int 		idx;
d720 6
a725 7
	idx = quick_lookup(name, &ename, &k);
	if (idx == -1) {
		v = find_global_var(name, ename, k);
		if (v->flags & POISONS)
		    poison_check(v);
		if ((v->flags & VAR_DUMMY) == 0)
			return VarValue(v);
d727 7
a733 2

	return NULL;
d739 3
a741 3
	Var 	   	*v;
	uint32_t	k;
	int 		idx;
d743 5
a747 2
	idx = quick_lookup(name, &ename, &k);
	if (idx == -1) {
d750 1
a750 1
		    poison_check(v);
a753 1

d757 8
d766 1
a766 1
varfind(const char *name, const char *ename, SymTable *ctxt, 
d769 12
a780 12
    /* Handle local variables first */
    if (idx != -1) {
    	if (ctxt != NULL) {
		if (idx < LOCAL_SIZE)
		    return ctxt->locals[idx];
		else
		    return ctxt->locals[EXTENDED2SIMPLE(idx)];
	} else
		return NULL;
    } else {
    	return find_global_var(name, ename, k);
    }
d783 4
a786 7
static const char *
find_0(const char *p)
{
	while (*p != '$' && *p != '\0' && *p != ':')
		p++;
	return p;
}
d804 2
d810 1
a810 3
	case '\0':
		return find_0;
	case ')':
d812 1
a812 1
	case '}':
d815 3
a817 1
		return 0;
d824 9
a832 19
    const char	*tstr;		/* Pointer into str */
    Var 	*v;		/* Variable in invocation */
    char	endc;		/* Ending character when variable in parens
				 * or braces */
    const char	*start;
    size_t	length;
    struct Name name;

    v = NULL;
    start = str;
    str++;

    if (*str != '(' && *str != '{') {
	name.tofree = false;
	tstr = str + 1;
	length = 2;
	endc = '\0';
    } else {
	endc = *str == '(' ? ')' : '}';
d835 25
a859 16
	/* Find eventual modifiers in the variable */
	tstr = VarName_Get(str, &name, ctxt, false, find_pos(endc));
	VarName_Free(&name);
	length = tstr - start;
	if (*tstr != 0)
	    length++;
    }

    if (result != NULL)
	*result = true;
    if (*tstr == ':' && endc != '\0')
	 if (VarModifiers_Apply(NULL, NULL, ctxt, true, NULL, tstr, endc,
	    &length) == var_Error)
		if (result != NULL)
		    *result = false;
    return length;
d866 1
a866 1
Var_ParseBuffer(Buffer buf, const char *str, SymTable *ctxt, bool err, 
d869 2
a870 2
    char	*result;
    bool	freeIt;
d872 8
a879 8
    result = Var_Parse(str, ctxt, err, lengthPtr, &freeIt);
    if (result == var_Error)
	return false;

    Buf_AddString(buf, result);
    if (freeIt)
	free(result);
    return true;
d883 4
a886 4
Var_Parse(const char *str, 	/* The string to parse */
    SymTable *ctxt, 		/* The context for the variable */
    bool err, 			/* true if undefined variables are an error */
    size_t *lengthPtr, 		/* OUT: The length of the specification */
d889 33
a921 27
    const char	*tstr;		/* Pointer into str */
    Var 	*v;		/* Variable in invocation */
    char	endc;		/* Ending character when variable in parens
				 * or braces */
    struct Name	name;
    const char	*start;
    char	*val;		/* Variable value  */
    uint32_t	k;
    int 	idx;

    *freePtr = false;
    start = str++;

    val = NULL;
    v = NULL;
    idx = -1;

    if (*str != '(' && *str != '{') {
    	name.s = str;
	name.e = str+1;
	name.tofree = false;
	tstr = str + 1;
	*lengthPtr = 2;
	endc = '\0';
    } else {
	endc = *str == '(' ? ')' : '}';
	str++;
d923 10
a932 17
	/* Find eventual modifiers in the variable */
	tstr = VarName_Get(str, &name, ctxt, false, find_pos(endc));
	*lengthPtr = tstr - start;
	if (*tstr != '\0')
		(*lengthPtr)++;
    }

    idx = quick_lookup(name.s, &name.e, &k);
    v = varfind(name.s, name.e, ctxt, idx, k);
    if (v != NULL && (v->flags & POISONS) != 0)
    	poison_check(v);
    if (v != NULL && (v->flags & VAR_DUMMY) == 0) {
	if (v->flags & VAR_IN_USE)
	    Fatal("Variable %s is recursive.", v->name);
	    /*NOTREACHED*/
	else
	    v->flags |= VAR_IN_USE;
d934 55
a988 48
	/* Before doing any modification, we have to make sure the value
	 * has been fully expanded. If it looks like recursion might be
	 * necessary (there's a dollar sign somewhere in the variable's value)
	 * we just call Var_Subst to do any other substitutions that are
	 * necessary. Note that the value returned by Var_Subst will have
	 * been dynamically-allocated, so it will need freeing when we
	 * return.  */
	val = VarValue(v);
	if (idx == -1) {
	    if (strchr(val, '$') != NULL) {
		val = Var_Subst(val, ctxt, err);
		*freePtr = true;
	    }
	} else if (idx >= LOCAL_SIZE) {
	    if (IS_EXTENDED_F(idx))
		val = Var_GetTail(val);
	    else
		val = Var_GetHead(val);
	    *freePtr = true;
	}
	v->flags &= ~VAR_IN_USE;
    }
    if (*tstr == ':' && endc != '\0')
	val = VarModifiers_Apply(val, &name, ctxt, err, freePtr, tstr, endc,
	    lengthPtr);
    if (val == NULL) {
	val = err ? var_Error : varNoError;
	/* Dynamic source */
	if (idx != -1) {
	    /* can't be expanded for now: copy the var spec instead. */
	    if (ctxt == NULL) {
		*freePtr = true;
		val = Str_dupi(start, start+ *lengthPtr);
	    } else {
	    /* somehow, this should have been expanded already. */
		GNode *n;

		n = (GNode *)(((char *)ctxt) - offsetof(GNode, context));
		if (idx >= LOCAL_SIZE)
			idx = EXTENDED2SIMPLE(idx);
		switch(idx) {
		case IMPSRC_INDEX:
		    Fatal("Using $< in a non-suffix rule context is a GNUmake idiom (line %lu of %s)",
			n->lineno, n->fname);
		default:
		    Error("Using undefined dynamic variable $%s (line %lu of %s)", 
			varnames[idx], n->lineno, n->fname);
		    break;
a989 1
	    }
d991 2
a992 3
    }
    VarName_Free(&name);
    return val;
d995 1
d997 2
a998 2
Var_Subst(const char *str, 	/* the string in which to substitute */
    SymTable *ctxt, 		/* the context wherein to find variables */
d1001 62
a1062 61
    BUFFER	  buf;		/* Buffer for forming things */
    static bool errorReported;  /* Set true if an error has already
				 * been reported to prevent a plethora
				 * of messages when recursing */

    Buf_Init(&buf, MAKE_BSIZE);
    errorReported = false;

    for (;;) {
	char		*val;	/* Value to substitute for a variable */
	size_t		length; /* Length of the variable invocation */
	bool 	doFree; 	/* Set true if val should be freed */
	const char *cp;

	/* copy uninteresting stuff */
	for (cp = str; *str != '\0' && *str != '$'; str++)
	    ;
	Buf_Addi(&buf, cp, str);
	if (*str == '\0')
	    break;
	if (str[1] == '$') {
	    /* A dollar sign may be escaped with another dollar sign.  */
	    Buf_AddChar(&buf, '$');
	    str += 2;
	    continue;
	}
	val = Var_Parse(str, ctxt, undefErr, &length, &doFree);
	/* When we come down here, val should either point to the
	 * value of this variable, suitably modified, or be NULL.
	 * Length should be the total length of the potential
	 * variable invocation (from $ to end character...) */
	if (val == var_Error || val == varNoError) {
	    /* If performing old-time variable substitution, skip over
	     * the variable and continue with the substitution. Otherwise,
	     * store the dollar sign and advance str so we continue with
	     * the string...  */
	    if (errorIsOkay)
		str += length;
	    else if (undefErr) {
		/* If variable is undefined, complain and skip the
		 * variable. The complaint will stop us from doing anything
		 * when the file is parsed.  */
		if (!errorReported)
		    Parse_Error(PARSE_FATAL,
				 "Undefined variable \"%.*s\"",length,str);
		str += length;
		errorReported = true;
	    } else {
		Buf_AddChar(&buf, *str);
		str++;
	    }
	} else {
	    /* We've now got a variable structure to store in. But first,
	     * advance the string pointer.  */
	    str += length;

	    /* Copy all the characters from the variable value straight
	     * into the new string.  */
	    Buf_AddString(&buf, val);
	    if (doFree)
		free(val);
d1064 42
a1105 2
    }
    return  Buf_Retrieve(&buf);
d1109 3
a1111 3
Var_SubstVar(Buffer buf, 	/* To store result */
    const char *str, 		/* The string in which to substitute */
    const char *var, 		/* Named variable */
d1114 1
a1114 10
    /* we save the old value and affect the new value temporarily */
    Var old;
    const char *ename = NULL;
    uint32_t k;
    Var *me;
    k = ohash_interval(var, &ename);
    me = obtain_global_var(var, ename, k);
    old = *me;			
    var_init_string(me, val);
    me->flags = VAR_SEEN_ENV;
d1116 1
a1116 1
    assert(*var != '\0');
d1118 72
a1189 25
    for (;;) {
	const char *start;
	/* Copy uninteresting stuff */
	for (start = str; *str != '\0' && *str != '$'; str++)
	    ;
	Buf_Addi(buf, start, str);

	start = str;
	if (*str++ == '\0')
	    break;
	str++;
	/* and escaped dollars */
	if (start[1] == '$') {
	    Buf_Addi(buf, start, start+2);
	    continue;
	}
	/* Simple variable, if it's not us, copy.  */
	if (start[1] != '(' && start[1] != '{') {
	    if (start[1] != *var || var[1] != '\0') {
		Buf_AddChars(buf, 2, start);
		continue;
	    }
	} else {
	    const char *p;
	    char endc;
d1191 3
a1193 52
	    if (start[1] == '(')
		endc = ')';
	    else
		endc = '}';

	    /* Find the end of the variable specification.  */
	    p = str;
	    while (*p != '\0' && *p != ':' && *p != endc && *p != '$')
		p++;
	    /* A variable inside the variable.	We don't know how to
	     * expand the external variable at this point, so we try
	     * again with the nested variable.	*/
	    if (*p == '$') {
		Buf_Addi(buf, start, p);
		str = p;
		continue;
	    }

	    if (strncmp(var, str, p - str) != 0 ||
		var[p - str] != '\0') {
		/* Not the variable we want to expand.	*/
		Buf_Addi(buf, start, p);
		str = p;
		continue;
	    }
	    if (*p == ':') {
		size_t	length; 	/* Length of the variable invocation */
		bool doFree; 	/* Set true if val should be freed */
		char	*newval;	/* Value substituted for a variable */
		struct Name name;

		length = p - str + 1;
		doFree = false;
		name.s = var;
		name.e = var + (p-str);

		/* val won't be freed since doFree == false, but
		 * VarModifiers_Apply doesn't know that, hence the cast. */
		newval = VarModifiers_Apply((char *)val, &name, NULL, false,
		    &doFree, p, endc, &length);
		Buf_AddString(buf, newval);
		if (doFree)
		    free(newval);
		str += length;
		continue;
	    } else
		str = p+1;
	}
	Buf_AddString(buf, val);
    }
    *me = old;
}
d1198 14
a1211 16
    const char *name = "SHELL";
    const char *ename = NULL;
    uint32_t k;
    Var *v;
    k = ohash_interval(name, &ename);
    v = create_var(name, ename);
    ohash_insert(&global_variables, 
    	ohash_lookup_interval(&global_variables, name, ename, k), v);
	/* the environment shall not affect it */
    v->flags = VAR_SHELL | VAR_SEEN_ENV;
    var_init_string(v, _PATH_BSHELL);
}

/*-
 *-----------------------------------------------------------------------
 * Var_Init --
a1212 4
 *
 * Side Effects:
 *	The CTXT_CMD and CTXT_GLOBAL contexts are initialized
 *-----------------------------------------------------------------------
d1217 2
a1218 2
    ohash_init(&global_variables, 10, &var_info);
    set_magic_shell_variable();
d1221 2
a1222 2
    errorIsOkay = true;
    Var_setCheckEnvFirst(false);
d1224 1
a1224 1
    VarModifiers_Init();
d1232 2
a1233 2
    Var *v;
    unsigned int i;
d1235 3
a1237 3
    for (v = ohash_first(&global_variables, &i); v != NULL;
	v = ohash_next(&global_variables, &i))
	    VarDelete(v);
d1246 3
a1248 3
    if (f & VAR_DUMMY)
	return "(D)";
    return "";
a1251 1
/****************** PRINT DEBUGGING INFO *****************/
d1253 1
a1253 1
VarPrintVar(Var *v)
d1255 2
a1256 2
    printf("%-16s%s = %s\n", v->name, interpret(v->flags),
	(v->flags & VAR_DUMMY) == 0 ? VarValue(v) : "(none)");
d1262 2
a1263 2
    Var *v;
    unsigned int i;
d1265 1
a1265 5
    printf("#*** Global Variables:\n");

    for (v = ohash_first(&global_variables, &i); v != NULL;
	v = ohash_next(&global_variables, &i))
	VarPrintVar(v);
d1267 3
d1274 1
a1274 1
/* In POSIX mode, variable assignments passed on the command line are
d1280 13
a1292 9
    Var *v;
    unsigned int i;
    BUFFER buf;
    char *s;

    Buf_Init(&buf, MAKE_BSIZE);

    for (v = ohash_first(&global_variables, &i); v != NULL;
	v = ohash_next(&global_variables, &i)) {
d1299 1
a1299 1
		for (s = VarValue(v); *s != '\0'; s++) {
d1305 3
a1307 3
    }
    Var_Append(name, Buf_Retrieve(&buf), VAR_GLOBAL);
    Buf_Destroy(&buf);
@


1.64
log
@rename variable to errorIsOkay. What does oldVars mean anyway ?
@
text
@d2 1
a2 1
/*	$OpenBSD: var.c,v 1.63 2007/07/08 17:49:55 espie Exp $	*/
a87 13
/* extended indices for System V stuff */
#define FTARGET_INDEX	7
#define DTARGET_INDEX	8
#define FPREFIX_INDEX	9
#define DPREFIX_INDEX	10
#define FARCHIVE_INDEX	11
#define DARCHIVE_INDEX	12
#define FMEMBER_INDEX	13
#define DMEMBER_INDEX	14

#define EXTENDED2SIMPLE(i)	(((i)-LOCAL_SIZE)/2)
#define IS_EXTENDED_F(i)	((i)%2 == 1)

a128 2
static struct ohash global_variables;

d147 17
a205 22
/* retrieve the hashed values  for well-known variables.  */
#include    "varhashconsts.h"

void
SymTable_Init(SymTable *ctxt)
{
    static SymTable sym_template;	
    memcpy(ctxt, &sym_template, sizeof(*ctxt));
}

#ifdef CLEANUP
void
SymTable_Destroy(SymTable *ctxt)
{
    int i;

    for (i = 0; i < LOCAL_SIZE; i++)
	if (ctxt->locals[i] != NULL)
	    VarDelete(ctxt->locals[i]);
}
#endif

d317 76
d444 1
a444 1
create_var(const char *name, const char *ename)
d446 2
a447 2
    return ohash_create_entry(&var_info, name, &ename);
}
d449 8
a456 33
/* Set the initial value a var should have */
static void
var_init_string(Var *v, const char *val)
{
    size_t len;

    len = strlen(val);
    Buf_Init(&(v->val), len+1);
    Buf_AddChars(&(v->val), len, val);
}

static void
var_set_string(Var *v, const char *val)
{
    if ((v->flags & VAR_DUMMY) == 0) {
	Buf_Reset(&(v->val));
	Buf_AddString(&(v->val), val);
    } else {
    	var_init_string(v, val);
	v->flags &= ~VAR_DUMMY;
    }
}

static void
var_append_string(Var *v, const char *val)
{
    if ((v->flags & VAR_DUMMY) == 0) {
    	Buf_AddSpace(&(v->val));
	Buf_AddString(&(v->val), val);
    } else {
    	var_init_string(v, val);
	v->flags &= ~VAR_DUMMY;
    }
d478 17
a494 1
obtain_global_var(const char *name, const char *ename, uint32_t k)
d496 11
a506 2
	unsigned int slot;
	Var *v;
d508 9
a516 6
	slot = ohash_lookup_interval(&global_variables, name, ename, k);
	v = ohash_find(&global_variables, slot);
	if (v == NULL) {
		v = create_var(name, ename);
		v->flags = VAR_DUMMY;
		ohash_insert(&global_variables, slot, v);
a517 1
	return v;
a538 49
static Var *
find_global_var(const char *name, const char *ename, uint32_t k)
{
    Var 		*v;

    v = obtain_global_var(name, ename, k);

    if ((v->flags & VAR_SEEN_ENV) == 0 &&
    	(checkEnvFirst  && (v->flags & VAR_FROM_CMD) == 0 || 
	    (v->flags & VAR_DUMMY) != 0))
		fill_from_env(v);

    return v;
}

static Var *
varfind(const char *name, const char *ename, SymTable *ctxt, 
    int idx, uint32_t k)
{
    /* Handle local variables first */
    if (idx != -1) {
    	if (ctxt != NULL) {
		if (idx < LOCAL_SIZE)
		    return ctxt->locals[idx];
		else
		    return ctxt->locals[EXTENDED2SIMPLE(idx)];
	} else
		return NULL;
    } else {
    	return find_global_var(name, ename, k);
    }
}

/*-
 *-----------------------------------------------------------------------
 * VarDelete  --
 *	Delete a variable and all the space associated with it.
 *-----------------------------------------------------------------------
 */
static void
VarDelete(Var *v)
{
    if ((v->flags & VAR_DUMMY) == 0)
	Buf_Destroy(&(v->val));
    free(v);
}



a622 27
void
Var_MarkPoisoned(const char *name, const char *ename, unsigned int type)
{
	Var   *v;
	uint32_t	k;
	int		idx;
	idx = quick_lookup(name, &ename, &k);

	if (idx != -1) {
		Parse_Error(PARSE_FATAL, 
		    "Trying to poison dynamic variable $%s",
		    varnames[idx]);
		return;
	}

	v = find_global_var(name, ename, k);
	v->flags |= type;
	if (v->flags & POISON_NORMAL) {
		if (v->flags & VAR_DUMMY)
			return;
		if (v->flags & VAR_FROM_ENV)
			return;
		Parse_Error(PARSE_FATAL,
		    "Poisoned variable %s is already set\n", v->name);
	}
}

d659 18
@


1.63
log
@missed part: add check to avoid poison checking inexistent local vars,
and do for loops for real.
@
text
@d2 1
a2 1
/*	$OpenBSD: var.c,v 1.62 2007/07/08 17:44:20 espie Exp $	*/
d114 1
a114 1
bool 		oldVars;	/* variable substitution style */
d930 1
a930 1
	    if (oldVars)
d1090 1
a1090 1
    oldVars = true;
@


1.62
log
@A set of big related changes. okay millert@@, tested further by kettenis@@
and matthieu@@

This all revolves around putting ALL global variables into one single big
hash, and using flags. This removes some impossible to understand stuff,
like old varfind, and allows for some nice stuff.
- each time we reference a global variable, we create it, possibly as a dummy
variable.
- each time we go to the environment, we remember it, thus we no longer go
back to it.

Lists of dependant changes:
- isolate changes to oldVars and checkEnvFirst.
- remove VAR_CMD and VAR_GLOBAL contexts. The only distinction is in parsevar.
Split Parse_DoVar into Parse_DoVar and Parse_CmdlineVar
- rework var modules around obtain_global_var, observe flags in various
functions like Var_Value and Var_Seti.
- Var_Seti/Var_Appendi are almost the same code, use that internally.
- add magic to handle the very special SHELL variable.
- introduce Var_Definedi for the cases where we don't want the actual
value, to simplify tests.
- add keyword .poison, parse it and set global flags accordingly.
- do poison_checks where needed.
- document poison.
- in for loops, set variable temporarily, so that Var_SubstVar will also
substitute it in varmodifiers expressions.
@
text
@d2 1
a2 1
/*	$OpenBSD: var.c,v 1.61 2007/01/02 13:21:31 espie Exp $	*/
d824 1
a824 1
    if (v->flags & POISONS)
d966 10
d1055 1
@


1.61
log
@VarDelete is no longer used by list functions, so let it do type-checking
correctly.
@
text
@d2 1
a2 1
/*	$OpenBSD: var.c,v 1.60 2006/01/20 23:10:19 espie Exp $	*/
d6 1
a6 1
 * Copyright (c) 1999,2000 Marc Espie.
d77 1
d114 9
a140 4
GSymT		*VAR_GLOBAL;	/* variables from the makefile */
GSymT		*VAR_CMD;	/* variables defined on the command-line */

static SymTable *CTXT_GLOBAL, *CTXT_CMD;
d142 1
a162 3
#define FIND_MINE	0x1   /* look in CTXT_CMD and CTXT_GLOBAL */
#define FIND_ENV	0x2   /* look in the environment */

d166 8
a173 5
#define VAR_IN_USE	1	/* Variable's value currently being used.
				 * Used to avoid recursion */
#define VAR_READ_ONLY	2	/* Environment variable not modifiable */
#define VAR_FROM_ENV	4	/* Var was read from env */
#define VAR_DUMMY	8	/* Var does not exist, actually */
d183 2
a184 3
static Var *varfind(const char *, const char *, SymTable *, int, int, uint32_t);
static Var *VarFindi(const char *, const char *, SymTable *, int);
static Var *VarAdd(const char *, const char *, uint32_t, const char *, GSymT *);
d187 3
a189 3
static const char *context_name(GSymT *);
static Var *new_var(const char *, const char *, const char *);
static Var *getvar(GSymT *, const char *, const char *, uint32_t);
d191 1
a191 1
static Var *var_from_env(const char *, const char *, uint32_t);
d193 5
a197 1

d337 2
a338 2
void
Varq_Set(int idx, const char *val, GNode *gn)
a339 3
    /* We only look for a variable in the given context since anything set
     * here will override anything in a lower context, so there's not much
     * point in searching them all just to save a bit of memory...  */
d343 8
a350 1
	v = new_var(varnames[idx], NULL, val);
d354 4
a357 1
	Buf_Reset(&(v->val));
a358 1

d361 7
a367 1
	printf("%s:%s = %s\n", gn->name, varnames[idx], val);
d373 1
a373 12
    Var *v = gn->context.locals[idx];

    if (v == NULL) {
	v = new_var(varnames[idx], NULL, val);
	v->flags = 0;
	gn->context.locals[idx] = v;
    } else {
	Buf_AddSpace(&(v->val));
	Buf_AddString(&(v->val), val);
    }
    if (DEBUG(VAR))
	printf("%s:%s = %s\n", gn->name, varnames[idx], VarValue(v));
a386 15
static const char *
context_name(GSymT *ctxt)
{
    if (ctxt == VAR_GLOBAL)
	return "Global";
    if (ctxt == VAR_CMD)
	return "Command";
    return "Error";
}

/* We separate var creation proper from setting of initial value:
 * VAR_DUMMY corresponds to `lazy' setup, e.g., always create global
 * variable at first lookup, and then fill it up when value is wanted.
 * This avoids looking through the environment several times.
 */
d404 2
a405 2
static Var *
new_var(const char *name, const char *ename, const char *val)
d407 8
a414 1
    Var 	*v;
d416 10
a425 10
    v = create_var(name, ename);
#ifdef STATS_VAR_LOOKUP
    STAT_VAR_CREATION++;
#endif
    if (val != NULL)
	var_init_string(v, val);
    else
	Buf_Init(&(v->val), 1);

    return v;
d428 2
a429 2
static Var *
var_from_env(const char *name, const char *ename, uint32_t k)
a431 1
    Var 	*v;
a432 3
    /* getenv requires a null-terminated name, so we create the var
     * structure first.  */
    v = create_var(name, ename);
d435 1
a435 1
	v->flags = VAR_DUMMY;
d437 2
a438 5
	var_init_string(v, env);
	if (checkEnvFirst)
	    v->flags = VAR_READ_ONLY | VAR_FROM_ENV;
	else
	    v->flags = VAR_FROM_ENV;
d444 1
d446 14
a459 2
    ohash_insert(VAR_GLOBAL, ohash_lookup_interval(VAR_GLOBAL, name, ename, k), v);
    return v;
d462 2
a463 2
static Var *
getvar(GSymT *ctxt, const char *name, const char *ename, uint32_t k)
d465 14
a478 1
    return ohash_find(ctxt, ohash_lookup_interval(ctxt, name, ename, k));
a480 12
/*-
 *-----------------------------------------------------------------------
 * VarFindi --
 *	Find the given variable in the given context and any other contexts
 *	indicated.  if end is NULL, name is a string, otherwise, only
 *	the interval name - end  is concerned.
 *
 * Results:
 *	A pointer to the structure describing the desired variable or
 *	NULL if the variable does not exist.
 *-----------------------------------------------------------------------
 */
d482 1
a482 7
VarFindi(const char	*name,	/* name to find */
    const char		*ename,	/* end of name */
    SymTable		*ctxt,	/* context in which to find it */
    int 		flags)	/* FIND_MINE set means to look in the
				 * CTXT_GLOBAL and CTXT_CMD contexts also.
				 * FIND_ENV set means to look in the
				 * environment */
d484 3
a486 2
    uint32_t		k;
    int 		idx;
d488 4
a491 3
#ifdef STATS_VAR_LOOKUP
    STAT_VAR_FIND++;
#endif
d493 1
a493 2
    idx = quick_lookup(name, &ename, &k);
    return varfind(name, ename, ctxt, flags, idx, k);
d497 1
a497 1
varfind(const char *name, const char *ename, SymTable *ctxt, int flags, 
a499 2
    Var 		*v;

d502 1
a502 1
    	if (ctxt != NULL && ctxt != CTXT_CMD && ctxt != CTXT_GLOBAL) {
d508 3
a510 1
	    return NULL;
a511 75
    /* First look for the variable in the given context. If it's not there,
       look for it in CTXT_CMD, CTXT_GLOBAL and the environment,
       depending on the FIND_* flags in 'flags' */
    if (ctxt == CTXT_CMD || ctxt == CTXT_GLOBAL)
	v = getvar((GSymT *)ctxt, name, ename, k);
    else
    	v = NULL;

    if (v == NULL)
	switch (flags) {
	case 0:
	    break;
	case FIND_MINE:
	    if (ctxt != CTXT_CMD)
		v = getvar(VAR_CMD, name, ename, k);
	    if (v == NULL && ctxt != CTXT_GLOBAL)
		v = getvar(VAR_GLOBAL, name, ename, k);
	    break;
	case FIND_ENV:
	    v = var_from_env(name, ename, k);
	    break;
	case FIND_ENV | FIND_MINE:
	    if (ctxt != CTXT_CMD)
		v = getvar(VAR_CMD, name, ename, k);
	    if (v == NULL) {
		if (ctxt != CTXT_GLOBAL)
		    v = getvar(VAR_GLOBAL, name, ename, k);
		if (v == NULL)
		    v = var_from_env(name, ename, k);
		else if (checkEnvFirst && (v->flags & VAR_FROM_ENV) == 0) {
		    char *env;

		    env = getenv(v->name);
		    if (env != NULL) {
			Buf_Reset(&(v->val));
			Buf_AddString(&(v->val), env);
		    }
		    /* XXX even if no such env variable, fake it, to avoid
		     * further lookup */
		    v->flags |= VAR_FROM_ENV;
		}
	    }
	    break;
	}
    return v;
}

/*-
 *-----------------------------------------------------------------------
 * VarAdd  --
 *	Add a new variable of name name and value val to the given context
 *
 * Results:
 *	The added variable.
 *
 * Side Effects:
 *	The new variable is placed in the given context.
 *	The name and val arguments are duplicated so they may
 *	safely be freed.
 *-----------------------------------------------------------------------
 */
static Var *
VarAdd(const char *name, const char *ename, uint32_t k, const char *val, 
    GSymT *ctxt)
{
    Var   *v;

    v = new_var(name, ename, val);

    v->flags = 0;

    ohash_insert(ctxt, ohash_lookup_interval(ctxt, name, ename, k), v);
    if (DEBUG(VAR))
	printf("%s:%s = %s\n", context_name(ctxt), v->name, val);
    return v;
d533 20
a552 6
    Var 	*v;
    uint32_t 	k;
    unsigned int slot;
    const char 	*ename = NULL;
    int		idx;

d554 2
a555 2
    if (DEBUG(VAR))
	printf("delete %s\n", name);
d557 1
a557 7
    idx = quick_lookup(name, &ename, &k);
    if (idx != -1)
    	Parse_Error(PARSE_FATAL, "Trying to delete dynamic variable");
    slot = ohash_lookup_interval(VAR_GLOBAL, name, ename, k);
    v = ohash_find(VAR_GLOBAL, slot);
    if (v != NULL && (v->flags & VAR_READ_ONLY) == 0) {
	ohash_remove(VAR_GLOBAL, slot);
a558 1
    }
d561 3
a563 7
/* 	The variable is searched for only in its context before being
 *	created in that context. I.e. if the context is CTXT_GLOBAL,
 *	only CTXT_GLOBAL is searched. Likewise if it is CTXT_CMD, only
 *	CTXT_CMD is searched.
 */
void
Var_Seti(const char *name, const char *ename, const char *val, GSymT *ctxt)
d565 3
a567 3
    Var   *v;
    uint32_t	k;
    int		idx;
d569 6
a574 20
    idx = quick_lookup(name, &ename, &k);
    if (idx != -1)
    	Parse_Error(PARSE_FATAL, "Trying to set dynamic variable $%s",
	    varnames[idx]);

    /* We only look for a variable in the given context since anything set
     * here will override anything in a lower context, so there's not much
     * point in searching them all just to save a bit of memory...  */
    v = varfind(name, ename, (SymTable *)ctxt, 0, idx, k);
    if (v == NULL)
	v = VarAdd(name, ename, k, val, ctxt);
    else {
	if ((v->flags & VAR_READ_ONLY) == 0) {
	    if ((v->flags & VAR_DUMMY) == 0) {
		Buf_Reset(&(v->val));
		Buf_AddString(&(v->val), val);
	    } else {
		var_init_string(v, val);
		v->flags &= ~VAR_DUMMY;
	    }
d576 24
a599 8
	}
    }
    if (DEBUG(VAR))
	printf("%s:%s = %s\n", context_name(ctxt), v->name, val);
    /* Any variables given on the command line are automatically exported
     * to the environment (as per POSIX standard).  */
    if (ctxt == VAR_CMD)
	esetenv(v->name, val);
d603 1
a603 1
Var_Appendi(const char *name, const char *ename, const char *val, GSymT *ctxt)
d605 2
a606 3
    Var   *v;
    uint32_t	k;
    int		idx;
d608 5
a612 1
    assert(ctxt == VAR_GLOBAL || ctxt == VAR_CMD);
d614 7
a620 4
    idx = quick_lookup(name, &ename, &k);
    if (idx != -1)
    	Parse_Error(PARSE_FATAL, "Trying to append to dynamic variable $%s",
	    varnames[idx]);
d622 6
a627 1
    v = varfind(name, ename, (SymTable *)ctxt, FIND_ENV, idx, k);
d629 9
a637 7
    if ((v->flags & VAR_READ_ONLY) == 0) {
	if ((v->flags & VAR_DUMMY) == 0) {
	    Buf_AddSpace(&(v->val));
	    Buf_AddString(&(v->val), val);
	} else {
	    var_init_string(v, val);
	    v->flags &= ~VAR_DUMMY;
a638 4

    }
    if (DEBUG(VAR))
	printf("%s:%s = %s\n", context_name(ctxt), v->name, VarValue(v));
d644 12
a655 1
    Var 	   *v;
a656 4
    v = VarFindi(name, ename, NULL, FIND_ENV | FIND_MINE);
    if (v != NULL && (v->flags & VAR_DUMMY) == 0)
	return VarValue(v);
    else
d660 19
d823 3
a825 1
    v = varfind(name.s, name.e, ctxt, FIND_ENV | FIND_MINE, idx, k);
d863 1
a863 1
	    if (ctxt == NULL || ctxt == CTXT_GLOBAL || ctxt == CTXT_CMD) {
d1047 16
d1075 2
a1076 1
    static GSymT global_vars, cmd_vars;
d1078 3
a1080 6
    VAR_GLOBAL = &global_vars;
    VAR_CMD = &cmd_vars;
    ohash_init(VAR_GLOBAL, 10, &var_info);
    ohash_init(VAR_CMD, 5, &var_info);
    CTXT_GLOBAL = (SymTable *)VAR_GLOBAL;
    CTXT_CMD = (SymTable *)VAR_CMD;
d1093 2
a1094 5
    for (v = ohash_first(VAR_GLOBAL, &i); v != NULL;
	v = ohash_next(VAR_GLOBAL, &i))
	    VarDelete(v);
    for (v = ohash_first(VAR_CMD, &i); v != NULL;
	v = ohash_next(VAR_CMD, &i))
d1126 2
a1127 2
    for (v = ohash_first(VAR_GLOBAL, &i); v != NULL;
	v = ohash_next(VAR_GLOBAL, &i))
a1129 4
    printf("#*** Command-line Variables:\n");

    for (v = ohash_first(VAR_CMD, &i); v != NULL; v = ohash_next(VAR_CMD, &i))
	VarPrintVar(v);
d1147 5
a1151 2
    for (v = ohash_first(VAR_CMD, &i); v != NULL;
	v = ohash_next(VAR_CMD, &i)) {
@


1.60
log
@use stdint.h where appropriate. okay millert@@
@
text
@d2 1
a2 1
/*	$OpenBSD: var.c,v 1.59 2004/04/07 13:11:36 espie Exp $	*/
d179 1
a179 1
static void VarDelete(void *);
d591 1
a591 1
VarDelete(void *vp)
a592 2
    Var *v = (Var *)vp;

@


1.59
log
@ISO function declarations, trim a few comments, rename a few variables to
more explicit/more consistent names.

okay otto@@
@
text
@d2 1
a2 1
/*	$OpenBSD: var.c,v 1.58 2003/10/07 18:33:08 fgsch Exp $	*/
a64 1
#include <sys/types.h>
d68 1
d174 1
a174 1
static int quick_lookup(const char *, const char **, u_int32_t *);
d176 1
a176 1
static Var *varfind(const char *, const char *, SymTable *, int, int, u_int32_t);
d178 1
a178 1
static Var *VarAdd(const char *, const char *, u_int32_t, const char *, GSymT *);
d183 1
a183 1
static Var *getvar(GSymT *, const char *, const char *, u_int32_t);
d185 1
a185 1
static Var *var_from_env(const char *, const char *, u_int32_t);
d217 1
a217 1
quick_lookup(const char *name, const char **enamePtr, u_int32_t *pk)
d426 1
a426 1
var_from_env(const char *name, const char *ename, u_int32_t k)
d454 1
a454 1
getvar(GSymT *ctxt, const char *name, const char *ename, u_int32_t k)
d480 1
a480 1
    u_int32_t		k;
d493 1
a493 1
    int idx, u_int32_t k)
d569 1
a569 1
VarAdd(const char *name, const char *ename, u_int32_t k, const char *val, 
d606 1
a606 1
    u_int32_t 	k;
d635 1
a635 1
    u_int32_t	k;
d673 1
a673 1
    u_int32_t	k;
d826 1
a826 1
    u_int32_t	k;
@


1.58
log
@- check if result is valid before using it.
- correctly set *freePtr, not freePtr.
input and ok espie@@.
@
text
@d2 1
a2 1
/*	$OpenBSD: var.c,v 1.57 2003/06/03 02:56:12 millert Exp $	*/
d198 1
a198 2
SymTable_Init(ctxt)
    SymTable	*ctxt;
d206 1
a206 2
SymTable_Destroy(ctxt)
    SymTable	*ctxt;
d217 1
a217 4
quick_lookup(name, end, pk)
    const char *name;
    const char **end;
    u_int32_t *pk;
d221 2
a222 2
    *pk = ohash_interval(name, end);
    len = *end - name;
d328 1
a328 4
Varq_Set(idx, val, gn)
    int 	idx;
    const char	*val;
    GNode	*gn;
d349 1
a349 4
Varq_Append(idx, val, gn)
    int 	idx;
    const char	*val;
    GNode	*gn;
d366 1
a366 3
Varq_Value(idx, gn)
    int 	idx;
    GNode	*gn;
d377 1
a377 2
context_name(ctxt)
    GSymT *ctxt;
d392 1
a392 3
create_var(name, end)
    const char	*name;
    const char	*end;
d394 1
a394 1
    return ohash_create_entry(&var_info, name, &end);
d399 1
a399 3
var_init_string(v, val)
    Var *v;
    const char *val;
d409 1
a409 4
new_var(name, end, val)
    const char	*name;
    const char	*end;
    const char	*val;
d413 1
a413 1
    v = create_var(name, end);
d426 1
a426 4
var_from_env(name, end, k)
    const char	*name;
    const char *end;
    u_int32_t	k;
d433 1
a433 1
    v = create_var(name, end);
d449 1
a449 1
    ohash_insert(VAR_GLOBAL, ohash_lookup_interval(VAR_GLOBAL, name, end, k), v);
d454 1
a454 5
getvar(ctxt, name, end, k)
    GSymT	*ctxt;
    const char	*name;
    const char	*end;
    u_int32_t	k;
d456 1
a456 1
    return ohash_find(ctxt, ohash_lookup_interval(ctxt, name, end, k));
d472 4
a475 5
VarFindi(name, end, ctxt, flags)
    const char		*name;	/* name to find */
    const char		*end;	/* end of name */
    SymTable		*ctxt;	/* context in which to find it */
    int 		flags;	/* FIND_MINE set means to look in the
d487 2
a488 2
    idx = quick_lookup(name, &end, &k);
    return varfind(name, end, ctxt, flags, idx, k);
d492 2
a493 7
varfind(name, end, ctxt, flags, idx, k)
    const char		*name;
    const char		*end;
    SymTable		*ctxt;
    int 		flags;
    int 		idx;
    u_int32_t		k;
d511 1
a511 1
	v = getvar((GSymT *)ctxt, name, end, k);
d521 1
a521 1
		v = getvar(VAR_CMD, name, end, k);
d523 1
a523 1
		v = getvar(VAR_GLOBAL, name, end, k);
d526 1
a526 1
	    v = var_from_env(name, end, k);
d530 1
a530 1
		v = getvar(VAR_CMD, name, end, k);
d533 1
a533 1
		    v = getvar(VAR_GLOBAL, name, end, k);
d535 1
a535 1
		    v = var_from_env(name, end, k);
d569 2
a570 6
VarAdd(name, end, k, val, ctxt)
    const char	*name;	/* name of variable to add */
    const char	*end;
    u_int32_t 	k;
    const char	*val;	/* value to set it to */
    GSymT	*ctxt;	/* context in which to set it */
d574 1
a574 1
    v = new_var(name, end, val);
d578 1
a578 1
    ohash_insert(ctxt, ohash_lookup_interval(ctxt, name, end, k), v);
d591 1
a591 2
VarDelete(vp)
    void *vp;
d603 1
a603 2
Var_Delete(name)
    const char	  *name;
d608 1
a608 1
    const char 	*end = NULL;
d615 1
a615 1
    idx = quick_lookup(name, &end, &k);
d618 1
a618 1
    slot = ohash_lookup_interval(VAR_GLOBAL, name, end, k);
d632 1
a632 5
Var_Seti(name, end, val, ctxt)
    const char	*name;	/* name of variable to set */
    const char	*end;
    const char	*val;	/* value to give to the variable */
    GSymT	*ctxt;	/* context in which to set it */
d638 1
a638 1
    idx = quick_lookup(name, &end, &k);
d646 1
a646 1
    v = varfind(name, end, (SymTable *)ctxt, 0, idx, k);
d648 1
a648 1
	v = VarAdd(name, end, k, val, ctxt);
d670 1
a670 5
Var_Appendi(name, end, val, ctxt)
    const char	*name;	/* Name of variable to modify */
    const char	*end;
    const char	*val;	/* String to append to it */
    GSymT	*ctxt;	/* Context in which this should occur */
d678 1
a678 1
    idx = quick_lookup(name, &end, &k);
d683 1
a683 1
    v = varfind(name, end, (SymTable *)ctxt, FIND_ENV, idx, k);
d700 1
a700 3
Var_Valuei(name, end)
    const char	*name;	/* name to find */
    const char	*end;
d704 1
a704 1
    v = VarFindi(name, end, NULL, FIND_ENV | FIND_MINE);
d712 1
a712 2
find_0(p)
	const char *p;
d720 1
a720 2
find_rparen(p)
	const char *p;
d728 1
a728 2
find_ket(p)
	const char *p;
d736 1
a736 2
find_pos(c)
	int c;
d751 1
a751 4
Var_ParseSkip(str, ctxt, result)
    const char	*str;
    SymTable	*ctxt;
    bool *result;
d796 2
a797 6
Var_ParseBuffer(buf, str, ctxt, err, lengthPtr)
    Buffer	buf;
    const char	*str;
    SymTable	*ctxt;
    bool	err;
    size_t	*lengthPtr;
d813 5
a817 6
Var_Parse(str, ctxt, err, lengthPtr, freePtr)
    const char	*str;		/* The string to parse */
    SymTable	*ctxt;		/* The context for the variable */
    bool	err;		/* true if undefined variables are an error */
    size_t	*lengthPtr;	/* OUT: The length of the specification */
    bool	*freePtr;	/* OUT: true if caller should free result */
d920 8
a927 9
Var_Subst(str, ctxt, undefErr)
    const char	  *str; 	    /* the string in which to substitute */
    SymTable	  *ctxt;	    /* the context wherein to find variables */
    bool	  undefErr;	    /* true if undefineds are an error */
{
    BUFFER	  buf;		    /* Buffer for forming things */
    static bool errorReported;   /* Set true if an error has already
				     * been reported to prevent a plethora
				     * of messages when recursing */
d933 2
a934 2
	char		*val;		/* Value to substitute for a variable */
	size_t		length; 	/* Length of the variable invocation */
d991 4
a994 5
Var_SubstVar(buf, str, var, val)
    Buffer	buf;
    const char	*str;		/* The string in which to substitute */
    const char	*var;		/* Named variable */
    const char	*val;		/* Its value */
d1087 1
a1087 1
Var_Init()
d1104 1
a1104 1
Var_End()
d1121 1
a1121 2
interpret(f)
    int f;
d1131 1
a1131 2
VarPrintVar(v)
    Var    *v;
d1138 1
a1138 1
Var_Dump()
d1161 1
a1161 2
Var_AddCmdline(name)
	const char *name;
@


1.57
log
@Remove the advertising clause in the UCB license which Berkeley
rescinded 22 July 1999.  Proofed by myself and Theo.
@
text
@d2 1
a2 1
/*	$OpenBSD: var.c,v 1.56 2002/06/05 18:45:39 espie Exp $	*/
d844 2
a845 1
		*result = false;
@


1.56
log
@tweak quick_lookup for a faster path.
okay millert@@
@
text
@d2 1
a2 1
/*	$OpenBSD: var.c,v 1.55 2001/05/23 12:34:51 espie Exp $	*/
d48 1
a48 5
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
@


1.55
log
@Mostly clean-up:
- cut up those huge include files into separate interfaces for all modules.
Put the interface documentation there, and not with the implementation.
- light-weight includes for needed concrete types (lst_t.h, timestamp_t.h).
- cut out some more logically separate parts: cmd_exec, varname, parsevar,
timestamp.
- put all error handling functions together, so that we will be able to
clean them up.
- more systematic naming: functioni  to handle interval, function to handle
string.
- put the init/end code apart to minimize coupling.
- kill weird types like ReturnStatus and Boolean. Use standard bool (with a
fallback for non-iso systems)
- better interface documentation for lots of subsystems.

As a result, make compilation goes somewhat faster (5%, even considering
the largish BSD copyrights to read). The corresponding preprocessed
source goes down from 1,5M to 1M.

A few minor code changes as well: Parse_DoVar is no longer destructive.
Parse_IsVar functionality is folded into Parse_DoVar (as it knows what an
assignment is), a few more interval handling functions. Avoid calling
XXX_End when they do nothing, just #define XXX_End   to nothing.

Parse_DoVar is slightly more general: it will handle compound assignments
as long as they make sense, e.g., VAR +!= cmd
will work.  As a side effect, VAR++=value now triggers an error
(two + in assignment).
- this stuff doesn't occur in portable Makefiles.
- writing VAR++ = value or VAR+ +=value  disambiguates it.
- this is a good thing, it uncovered a bug in bsd.port.mk.

Tested by naddy@@. Okayed millert@@. I'll handle the fallback if there is
any. This went through a full make build anyways, including isakmpd
(without mickey's custom binutils, as he didn't see fit to share it with me).
@
text
@d2 1
a2 1
/*	$OpenBSD: var.c,v 1.12 1999/09/28 21:57:04 espie Exp $	*/
d236 2
a237 2
	if (*pk == K_LONGALLSRC && strncmp(name, LONGALLSRC, len) == 0 &&
	    len == strlen(LONGALLSRC))
d241 2
a242 2
	if (*pk == K_LONGARCHIVE && strncmp(name, LONGARCHIVE, len) == 0 &&
	    len == strlen(LONGARCHIVE))
d246 2
a247 2
	if (*pk == K_LONGIMPSRC && strncmp(name, LONGIMPSRC, len) == 0 &&
	    len == strlen(LONGIMPSRC))
d251 2
a252 2
	if (*pk == K_LONGMEMBER && strncmp(name, LONGMEMBER, len) == 0 &&
	    len == strlen(LONGMEMBER))
d256 2
a257 2
	if (*pk == K_LONGOODATE && strncmp(name, LONGOODATE, len) == 0 &&
	    len == strlen(LONGOODATE))
d261 2
a262 2
	if (*pk == K_LONGPREFIX && strncmp(name, LONGPREFIX, len) == 0 &&
	    len == strlen(LONGPREFIX))
d266 2
a267 2
	if (*pk == K_LONGTARGET && strncmp(name, LONGTARGET, len) == 0 &&
	    len == strlen(LONGTARGET))
@


1.54
log
@Don't go beyond end of string.
Handles unterminated variables, and fixes regression test #10
@
text
@d2 1
a2 1
/*	$OpenBSD: var.c,v 1.53 2001/05/03 13:41:13 espie Exp $	*/
d69 31
a99 65
/*-
 * var.c --
 *	Variable-handling functions
 *
 * Basic interface:
 *	Var_Set 	    Set the value of a variable in the given
 *			    context. The variable is created if it doesn't
 *			    yet exist. The value and variable name need not
 *			    be preserved.
 *
 *	Var_Append	    Append more characters to an existing variable
 *			    in the given context. The variable needn't
 *			    exist already -- it will be created if it doesn't.
 *			    A space is placed between the old value and the
 *			    new one.
 *
 *	Var_Value	    Return the value of a variable in a context or
 *			    NULL if the variable is undefined.
 *
 *	Var_Delete	    Delete a variable in a context.
 *
 *	Var_Init	    Initialize this module.
 *
 * Fast interface:
 *	Varq_Set, Varq_Append, Varq_Value:
 *			    Use index form of local variables
 *
 * Higher level functions:
 *	Var_Subst	    Substitute variables in a string using
 *			    the given context as the top-most one. If the
 *			    third argument is non-zero, Parse_Error is
 *			    called if any variables are undefined.
 *
 *	Var_SubstVar	    Substitute a named variable in a string using
 *			    the given context as the top-most one,
 *			    accumulating the result into a user-supplied
 *			    buffer.
 *
 *	Var_Parse	    Parse a variable expansion from a string and
 *			    return the result and the number of characters
 *			    consumed.
 *
 * Debugging:
 *	Var_Dump	    Print out all global variables.
 */

#include    <assert.h>
#include    <ctype.h>
#include    <stdlib.h>
#include    <stddef.h>
#include    <string.h>
#include    "make.h"
#include    "buf.h"
#include    "stats.h"
#include    "ohash.h"
#include    "varmodifiers.h"

#ifndef lint
#if 0
static char sccsid[] = "@@(#)var.c	8.3 (Berkeley) 3/19/94";
#else
UNUSED
static char rcsid[] = "$OpenBSD: var.c,v 1.53 2001/05/03 13:41:13 espie Exp $";
#endif
#endif /* not lint */
d101 2
d181 1
a181 1
static Var *VarFind_interval(const char *, const char *, SymTable *, int);
a200 51
/* Parse a variable name for embedded $, to handle recursive variables */
const char *
Var_Name_Get(start, name, ctxt, err, cont)
	const char 	*start;	/* start of variable spec */
	struct Name 	*name;  /* result, might be a copy or not */
	SymTable 	*ctxt;	/* context in which to expand */
	Boolean		err;	/* whether to error out for undefined sub */
	const char *(*cont)(const char *);
				/* hook: find the next interesting character */
{
	const char *p;
	size_t len;

	p = cont(start);
	/* If we don't want recursive variables, we skip over '$' */
	if (!FEATURES(FEATURE_RECVARS)) {
		while (*p == '$')
		    p = cont(p);
	}
	if (*p != '$') {
		name->s = start;
		name->e = p;
		name->tofree = FALSE;
		return p;
	} else {
		BUFFER buf;
		Buf_Init(&buf, MAKE_BSIZE);
		for (;;) {
			Buf_AddInterval(&buf, start, p);
			if (*p != '$') {
				name->s = (const char *)Buf_Retrieve(&buf);
				name->e = name->s + Buf_Size(&buf);
				name->tofree = TRUE;
				return p;
			}
			start = p;
			Var_ParseBuffer(&buf, start, ctxt, err, &len);
			start += len;
			p = cont(start);
		}
	}
}

void
Var_Name_Free(name)
	struct Name *name;
{
	if (name->tofree)
		free((char *)name->s);
}

d493 1
a493 1
 * VarFind_interval --
d504 1
a504 1
VarFind_interval(name, end, ctxt, flags)
a644 9
/*-
 *-----------------------------------------------------------------------
 * Var_Delete --
 *	Remove a global variable.
 *
 * Side Effects:
 *	The Var structure is removed and freed.
 *-----------------------------------------------------------------------
 */
d670 1
a670 11
/*-
 *-----------------------------------------------------------------------
 * Var_Set --
 *	Set the variable name to the value val in the given context.
 *
 * Side Effects:
 *	If the variable doesn't yet exist, a new record is created for it.
 *	Else the old value is freed and the new one stuck in its place
 *
 * Notes:
 *	The variable is searched for only in its context before being
a673 1
 *-----------------------------------------------------------------------
d676 1
a676 1
Var_Set_interval(name, end, val, ctxt)
a716 12
/*-
 *-----------------------------------------------------------------------
 * Var_Append --
 *	The variable of the given name has the given value appended to it in
 *	the given context.
 *
 * Side Effects:
 *	If the variable doesn't exist, it is created. Else the strings
 *	are concatenated (with a space in between).
 *
 *-----------------------------------------------------------------------
 */
d718 1
a718 1
Var_Append_interval(name, end, val, ctxt)
a750 9
/*-
 *-----------------------------------------------------------------------
 * Var_Value --
 *	Return the value of a global named variable
 *
 * Results:
 *	The value if the variable exists, NULL if it doesn't
 *-----------------------------------------------------------------------
 */
d752 1
a752 1
Var_Value_interval(name, end)
d758 1
a758 1
    v = VarFind_interval(name, end, NULL, FIND_ENV | FIND_MINE);
a807 9
/*-
 *-----------------------------------------------------------------------
 * Var_ParseSkip --
 *	Do whatever is needed to skip over a var specification.  Since the
 *	result is not needed at this point, some shortcuts may be taken.
 *
 * Return value: the amount to skip
 *-----------------------------------------------------------------------
 */
d812 1
a812 1
    ReturnStatus *result;
d827 1
a827 1
	name.tofree = FALSE;
d836 2
a837 2
	tstr = Var_Name_Get(str, &name, ctxt, FALSE, find_pos(endc));
	Var_Name_Free(&name);
d839 2
a840 3
	/* Terminated correctly */
	if (*tstr != '\0')
		length++;
d844 1
a844 1
	*result = SUCCESS;
d846 1
a846 1
	 if (VarModifiers_Apply(NULL, NULL, ctxt, TRUE, NULL, tstr, endc,
d848 1
a848 1
		*result = FAILURE;
d852 4
a855 16
/*-
 *-----------------------------------------------------------------------
 * Var_ParseBuffer --
 *	Given the start of a variable invocation, extract the variable
 *	name and find its value, then modify it according to the
 *	specification, and add the result to the buffer.
 *
 * Results:
 *	FAILURE for invalid specifications.
 *
 * Side-effects:
 *	The length of the specification is placed in *lengthPtr
 *	(for invalid specifications, this is just 2...?).
 *-----------------------------------------------------------------------
 */
ReturnStatus
d860 1
a860 1
    Boolean	err;
d864 1
a864 1
    Boolean	freeIt;
d868 1
a868 1
	return FAILURE;
d873 1
a873 1
    return SUCCESS;
a875 16
/*-
 *-----------------------------------------------------------------------
 * Var_Parse --
 *	Given the start of a variable invocation, extract the variable
 *	name and find its value, then modify it according to the
 *	specification.
 *
 * Results:
 *	The (possibly-modified) value of the variable or var_Error if the
 *	specification is invalid. The length of the specification is
 *	placed in *lengthPtr (for invalid specifications, this is just
 *	2...?).
 *	A Boolean in *freePtr telling whether the returned string should
 *	be freed by the caller.
 *-----------------------------------------------------------------------
 */
d880 1
a880 1
    Boolean	err;		/* TRUE if undefined variables are an error */
d882 1
a882 1
    Boolean	*freePtr;	/* OUT: TRUE if caller should free result */
d894 1
a894 1
    *freePtr = FALSE;
d904 1
a904 1
	name.tofree = FALSE;
d913 1
a913 1
	tstr = Var_Name_Get(str, &name, ctxt, FALSE, find_pos(endc));
d939 1
a939 1
		*freePtr = TRUE;
d946 1
a946 1
	    *freePtr = TRUE;
d959 2
a960 2
		*freePtr = TRUE;
		val = interval_dup(start, start+ *lengthPtr);
d980 1
a980 1
    Var_Name_Free(&name);
a983 14
/*-
 *-----------------------------------------------------------------------
 * Var_Subst  --
 *	Substitute for all variables in a string in a context
 *	If undefErr is TRUE, Parse_Error will be called when an undefined
 *	variable is encountered.
 *
 * Results:
 *	The resulting string.
 *
 * Side Effects:
 *	The new string must be freed by the caller
 *-----------------------------------------------------------------------
 */
d988 1
a988 1
    Boolean	  undefErr;	    /* TRUE if undefineds are an error */
d991 1
a991 1
    static Boolean errorReported;   /* Set true if an error has already
d996 1
a996 1
    errorReported = FALSE;
d1001 1
a1001 1
	Boolean 	doFree; 	/* Set true if val should be freed */
d1007 1
a1007 1
	Buf_AddInterval(&buf, cp, str);
d1036 1
a1036 1
		errorReported = TRUE;
a1055 8
/*-
 *-----------------------------------------------------------------------
 * Var_SubstVar  --
 *	Substitute for one variable in the given string in the given context
 *	If undefErr is TRUE, Parse_Error will be called when an undefined
 *	variable is encountered. Add the substituted string to buffer.
 *-----------------------------------------------------------------------
 */
d1071 1
a1071 1
	Buf_AddInterval(buf, start, str);
d1079 1
a1079 1
	    Buf_AddInterval(buf, start, start+2);
d1105 1
a1105 1
		Buf_AddInterval(buf, start, p);
d1113 1
a1113 1
		Buf_AddInterval(buf, start, p);
d1119 1
a1119 1
		Boolean doFree; 	/* Set true if val should be freed */
d1124 1
a1124 1
		doFree = FALSE;
d1128 1
a1128 1
		/* val won't be freed since doFree == FALSE, but
d1130 1
a1130 1
		newval = VarModifiers_Apply((char *)val, &name, NULL, FALSE,
d1169 1
a1172 1
#ifdef CLEANUP
d1182 1
a1183 1
}
a1205 6
/*-
 *-----------------------------------------------------------------------
 * Var_Dump --
 *	print all variables
 *-----------------------------------------------------------------------
 */
@


1.53
log
@Synch with my current work.
Numerous changes:
- generate can build several tables
- style cleanup
- statistics code
- use variable names throughout (struct Name)
- recursive variables everywhere
- faster parser (pass buffer along instead of allocating multiple copies)
- correct parser. Handles comments everywhere, and ; correctly
- more string intervals
- simplified dir.c, less recursion.
- extended for loops
- sinclude()
- finished removing extra junk from Lst_*
- handles ${@@D} and friends in a simpler way
- cleaned up and modular VarModifiers handling.
- recognizes some gnu Makefile usages and errors out about them.

Additionally, some extra functionality is defined by FEATURES. The set of
functionalities is currently hardcoded to OpenBSD defaults, but this may
include support for some NetBSD extensions, like ODE modifiers.

Backed by miod@@ and millert@@, who finally got sick of my endless patches...
@
text
@d2 1
a2 1
/*	$OpenBSD: var.c,v 1.12 1999/09/28 21:57:04 espie Exp $	*/
d131 1
a131 1
static char rcsid[] = "$OpenBSD: var.c,v 1.12 1999/09/28 21:57:04 espie Exp $";
d971 4
a974 1
	length = tstr+1 - start;
d1076 3
a1078 1
	*lengthPtr = tstr+1 - start;
@


1.52
log
@Use the ohash_* that's now in libc.
@
text
@d1 2
a2 1
/*	$OpenBSD: var.c,v 1.51 2000/12/07 00:15:43 espie Exp $	*/
d6 1
a6 1
 * Copyright (c) 1999 Marc Espie.
a30 1

d73 5
a77 5
 * Interface:
 *	Var_Set	  	    Set the value of a variable in the given
 *	    	  	    context. The variable is created if it doesn't
 *	    	  	    yet exist. The value and variable name need not
 *	    	  	    be preserved.
d80 7
a86 24
 *	    	  	    in the given context. The variable needn't
 *	    	  	    exist already -- it will be created if it doesn't.
 *	    	  	    A space is placed between the old value and the
 *	    	  	    new one.
 *
 *	Var_Exists	    See if a variable exists.
 *
 *	Var_Value 	    Return the value of a variable in a context or
 *	    	  	    NULL if the variable is undefined.
 *
 *	Var_Subst 	    Substitute named variable, or all variables if
 *			    NULL in a string using
 *	    	  	    the given context as the top-most one. If the
 *	    	  	    third argument is non-zero, Parse_Error is
 *	    	  	    called if any variables are undefined.
 *
 *	Var_SubstVar 	    Substitute a named variable in a string using
 *	    	  	    the given context as the top-most one,
 *	    	  	    accumulating the result into a user-supplied
 *	    	  	    buffer.
 *
 *	Var_Parse 	    Parse a variable expansion from a string and
 *	    	  	    return the result and the number of characters
 *	    	  	    consumed.
d90 20
a109 1
 *	Var_Init  	    Initialize this module.
d112 1
a112 4
 *	Var_Dump  	    Print out all variables defined in the given
 *	    	  	    context.
 *
 * XXX: There's a lot of duplication in these functions.
d115 1
a116 4
#ifndef MAKE_BOOTSTRAP
#include    <sys/types.h>
#include    <regex.h>
#endif
d119 1
d122 1
a123 1
#include    "hashconsts.h"
d131 1
a131 1
static char rcsid[] = "$OpenBSD: var.c,v 1.51 2000/12/07 00:15:43 espie Exp $";
a134 10
static SymTable *CTXT_GLOBAL, *CTXT_CMD, *CTXT_ENV;

static char *varnames[] = {
    TARGET,
    OODATE,
    ALLSRC,
    IMPSRC,
    PREFIX,
    ARCHIVE,
    MEMBER };
d141 1
a141 1
char 	var_Error[] = "";
d151 5
a155 4
 * Internally, variables are contained in four different contexts.
 *	1) the environment. They may not be changed. If an environment
 *	    variable is appended-to, the result is placed in the global
 *	    context.
d169 22
a190 1
static GSymT	*VAR_ENV;	/* variables read from env */
d193 1
a193 1
#define FIND_ENV  	0x2   /* look in the environment */
d196 8
a203 9
    BUFFER	  val;	    	/* its value */
    int	    	  flags;    	/* miscellaneous status flags */
#define VAR_IN_USE	1   	    /* Variable's value currently being used.
				     * Used to avoid recursion */
#define VAR_JUNK  	4   	    /* Variable is a junk variable that
				     * should be destroyed when done with
				     * it. Used by Var_Parse for undefined,
				     * modified variables */
    char          name[1];	/* the variable's name */
d206 3
a208 2
static struct ohash_info var_info = { 
	offsetof(Var, name), 
d210 1
a210 1
static int quick_lookup __P((const char *, const char **, u_int32_t *));
d212 71
a282 10
static Var *varfind __P((const char *, const char *, SymTable *, int, int, u_int32_t));
static Var *VarFind_interval __P((const char *, const char *, SymTable *, int));
#define VarFind(n, ctxt, flags)	VarFind_interval(n, NULL, ctxt, flags)
static Var *VarAdd __P((const char *, const char *, GSymT *));
static void VarDelete __P((void *));
static void VarPrintVar __P((void *));
static const char *context_name __P((GSymT *));
static Var *new_var __P((const char *, const char *));
static Var *getvar __P((GSymT *, const char *, const char *, u_int32_t));
static Var *var_name_with_dollar __P((char *, char **, SymTable *, Boolean, char));
d288 1
a288 1
    static SymTable sym_template;
d292 1
d303 1
d316 3
a318 3
    switch (*pk % MAGICSLOTS) {		    /* MAGICSLOTS should be the    */
    case K_LONGALLSRC % MAGICSLOTS:	    /* smallest constant yielding  */
					    /* distinct case values        */
d323 1
a323 1
    case K_LONGARCHIVE % MAGICSLOTS:
d328 1
a328 1
    case K_LONGIMPSRC % MAGICSLOTS:
d333 1
a333 1
    case K_LONGMEMBER % MAGICSLOTS:
d338 1
a338 1
    case K_LONGOODATE % MAGICSLOTS:
d343 1
a343 1
    case K_LONGPREFIX % MAGICSLOTS:
d348 1
a348 1
    case K_LONGTARGET % MAGICSLOTS:
d353 1
a353 1
    case K_TARGET % MAGICSLOTS:
d357 1
a357 1
    case K_OODATE % MAGICSLOTS:
d361 1
a361 1
    case K_ALLSRC % MAGICSLOTS:
d365 1
a365 1
    case K_IMPSRC % MAGICSLOTS:
d369 1
a369 1
    case K_PREFIX % MAGICSLOTS:
d373 1
a373 1
    case K_ARCHIVE % MAGICSLOTS:
d377 1
a377 1
    case K_MEMBER % MAGICSLOTS:
d381 32
d419 1
a419 1
void 
d422 2
a423 2
    const char 	*val;
    GNode 	*gn;
d431 1
a431 1
    	v = new_var(varnames[idx], val);
d437 1
d443 1
a443 1
void 
d445 1
a445 1
    int		idx;
d449 1
a449 1
    Var 	*v = gn->context.locals[idx];
d452 1
a452 1
    	v = new_var(varnames[idx], val);
d465 1
a465 1
    int		idx;
d470 2
a471 2
    if (v != NULL)
    	return VarValue(v);
d473 12
a484 1
    	return NULL;
d487 9
a495 4
Boolean
Varq_Exists(idx, gn)
    int		idx;
    GNode	*gn;
d497 1
a497 1
    return gn->context.locals[idx] != NULL;
d500 12
d513 5
a517 3
static const char *
context_name(ctxt)
    GSymT *ctxt;
d519 8
a526 4
    if (ctxt == VAR_GLOBAL)
    	return "Global";
    else if (ctxt == VAR_CMD)
    	return "Command";
d528 3
a530 1
    	return "Environment";
d532 1
a532 2
    
/* Create a variable, to pass to VarAdd.  */
d534 4
a537 3
new_var(name, val)
    const char *name;
    const char *val;
d539 2
a540 2
    Var *v;
    const char *end = NULL;
d542 13
a554 1
    v = ohash_create_entry(&var_info, name, &end);
d556 3
a558 6
    if (val != NULL) {
    	size_t len = strlen(val);
	Buf_Init(&(v->val), len+1);
	Buf_AddChars(&(v->val), len, val);
    } else
    	Buf_Init(&(v->val), 1);
d560 1
d567 1
a567 1
    const char 	*name;
d579 1
a579 1
 *      the interval name - end  is concerned.
a583 3
 *
 * Side Effects:
 *	Caches env variables in the VAR_ENV context.
d588 1
a588 1
    const char          *name;	/* name to find */
d590 2
a591 2
    SymTable          	*ctxt;	/* context in which to find it */
    int             	flags;	/* FIND_MINE set means to look in the
d596 1
d598 4
a601 1
    u_int32_t		k;
d612 2
a613 2
    int			flags;
    int			idx;
d616 1
a616 1
    Var			*v;
d618 16
a633 6
    /*
     * First look for the variable in the given context. If it's not there,
     * look for it in VAR_CMD, VAR_GLOBAL and the environment, in that order,
     * depending on the FIND_* flags in 'flags'
     */
    if (ctxt == NULL)
a634 36
    else if (ctxt == CTXT_GLOBAL || ctxt == CTXT_CMD || ctxt == CTXT_ENV)
	v = getvar((GSymT *)ctxt, name, end, k);
    else {
    	if (idx == -1)
	    v = NULL;
	else
	    v = ctxt->locals[idx];
    }
    if (v != NULL)
    	return v;
	    
    if ((flags & FIND_MINE) && ctxt != CTXT_CMD)
	v = getvar(VAR_CMD, name, end, k);
    if (v != NULL)
    	return v;

    if (!checkEnvFirst && (flags & FIND_MINE) && ctxt != CTXT_GLOBAL)
	v = getvar(VAR_GLOBAL, name, end, k);
    if (v != NULL)
    	return v;

    if ((flags & FIND_ENV)) {
	char *env;
	char *n;

    	v = getvar(VAR_ENV, name, end, k);
	if (v != NULL)
	    return v;

	/* getenv requires a null-terminated name */
	n = interval_dup(name, end);
	env = getenv(n);
	free(n);
	if (env != NULL)
	    return VarAdd(name, env, VAR_ENV);
    }
d636 36
a671 2
    if (checkEnvFirst && (flags & FIND_MINE) && ctxt != CTXT_GLOBAL) 
	v = getvar(VAR_GLOBAL, name, end, k);
d681 1
a681 1
 *	The added variable
d690 1
a690 1
VarAdd(name, val, ctxt)
d692 2
d697 1
a697 4
    Var   	*v;
    const char 	*end = NULL;
    int 	idx;
    u_int32_t 	k;
d699 1
a699 1
    v = new_var(name, val);
d703 3
a705 7
    idx = quick_lookup(name, &end, &k);

    if (idx != -1)
    	Parse_Error(PARSE_FATAL, "Trying to set dynamic variable %s",
	    v->name);
    else
	ohash_insert(ctxt, ohash_lookup_interval(ctxt, name, end, k), v);
a708 1

d717 1
a717 1
    void 	*vp;
d719 1
a719 1
    Var 	*v = (Var *) vp;
d721 2
a722 1
    Buf_Destroy(&(v->val));
d731 1
a731 1
 *	Remove a variable from a context.
d738 2
a739 3
Var_Delete(name, ctxt)
    const char	*name;
    GSymT	*ctxt;
d743 1
d745 2
d749 1
a749 3
	printf("%s:delete %s\n", context_name(ctxt), name);
    (void)quick_lookup(name, &end, &k);
    v = ohash_remove(ctxt, ohash_lookup_interval(ctxt, name, end, k));
d751 7
a757 1
    if (v != NULL)
d759 1
d773 3
a775 5
 *	created in that context. I.e. if the context is VAR_GLOBAL,
 *	only VAR_GLOBAL->context is searched. Likewise if it is VAR_CMD, only
 *	VAR_CMD->context is searched. This is done to avoid the literally
 *	thousands of unnecessary strcmp's that used to be done to
 *	set, say, $(@@) or $(<).
d779 1
a779 1
Var_Set(name, val, ctxt)
d781 1
d783 1
a783 1
    GSymT       *ctxt;	/* context in which to set it */
d786 7
d794 1
a794 2
    /*
     * We only look for a variable in the given context since anything set
d796 2
a797 3
     * point in searching them all just to save a bit of memory...
     */
    v = VarFind(name, (SymTable *)ctxt, 0);
d799 1
a799 1
	(void)VarAdd(name, val, ctxt);
d801 10
a810 2
	Buf_Reset(&(v->val));
	Buf_AddString(&(v->val), val);
d813 5
a817 12
	printf("%s:%s = %s\n", context_name(ctxt), name, val);
    /*
     * Any variables given on the command line are automatically exported
     * to the environment (as per POSIX standard).  
     * We put them into the env cache directly.
     * (Note that additions to VAR_CMD occur very early, so VAR_ENV is
     * actually empty at this point).
     */
    if (ctxt == VAR_CMD) {
	esetenv(name, val);
	(void)VarAdd(name, val, VAR_ENV);
    }
a829 7
 * Notes:
 *	Only if the variable is being sought in the global context is the
 *	environment searched.
 *	XXX: Knows its calling circumstances in that if called with ctxt
 *	an actual target, it will only search that context since only
 *	a local variable could be being appended to. This is actually
 *	a big win and must be tolerated.
d833 1
a833 1
Var_Append(name, val, ctxt)
d835 1
d839 10
a848 1
    Var   	*v;
d850 10
a859 1
    v = VarFind(name, (SymTable *)ctxt, (ctxt == VAR_GLOBAL) ? FIND_ENV : 0);
a860 5
    if (v == NULL) {
	v = VarAdd(name, val, ctxt);
    } else {
	Buf_AddSpace(&(v->val));
	Buf_AddString(&(v->val), val);
d863 1
a863 1
	printf("%s:%s = %s\n", context_name(ctxt), name, VarValue(v));
d868 2
a869 2
 * Var_Exists --
 *	See if the given variable exists.
d872 1
a872 1
 *	TRUE if it does, FALSE if it doesn't
d875 17
a891 4
Boolean
Var_Exists(name, ctxt)
    const char	*name;    	/* Variable to find */
    GSymT	*ctxt;    	/* Context in which to start search */
d893 13
a905 1
    Var		*v;
d907 8
a914 1
    v = VarFind(name, (SymTable *)ctxt, FIND_MINE|FIND_ENV);
d916 14
a929 4
    if (v == NULL)
	return FALSE;
    else
	return TRUE;
d934 3
a936 2
 * Var_Value --
 *	Return the value of the named variable in the given context
d938 1
a938 2
 * Results:
 *	The value if the variable exists, NULL if it doesn't
d941 5
a945 4
char *
Var_Value(name, ctxt)
    const char	*name;	/* name to find */
    GSymT	*ctxt;	/* context in which to search for it */
d947 7
a953 1
    Var		*v;
d955 26
a980 5
    v = VarFind(name, (SymTable *)ctxt, FIND_ENV | FIND_MINE);
    if (v != NULL) 
	return VarValue(v);
    else
	return NULL;
d983 1
a983 1
/*
d985 11
a995 6
 * v = var_name_with_dollar(str, &pos, ctxt, err, endc)
 *   handle variable name that contains a dollar
 *   str points to the first letter of the variable name,
 *   &pos to the current position in the name (first dollar at invocation,
 *   end of name specification at return).
 *   returns the corresponding variable.
d998 10
a1007 15
static Var *
var_name_with_dollar(str, pos, ctxt, err, endc)
    char 	*str;		/* First dollar in variable name */
    char 	**pos;		/* Current position in variable spec */
    SymTable   	*ctxt;    	/* The context for the variable */
    Boolean 	err;    	/* TRUE if undefined variables are an error */
    char	endc;		/* End character for spec */
{
    BUFFER 	buf;		/* Store the variable name */
    size_t 	sublen;		/* Deal with recursive expansions */
    Boolean 	subfree;		
    char 	*n; 		/* Sub name */
    Var 	*v;

    Buf_Init(&buf, MAKE_BSIZE);
d1009 8
a1016 18
    for (;;) {
	Buf_AddInterval(&buf, str, *pos);
	n = Var_Parse(*pos, ctxt, err, &sublen, &subfree);
	if (n != NULL)
	    Buf_AddString(&buf, n);
	if (subfree)
	    free(n);
	*pos += sublen;
	str = *pos;
	for (; **pos != '$'; (*pos)++) {
	    if (**pos == '\0' || **pos == endc || **pos == ':') {
	    	Buf_AddInterval(&buf, str, *pos);
		v = VarFind(Buf_Retrieve(&buf), ctxt, FIND_ENV | FIND_MINE);
		Buf_Destroy(&buf);
		return v;
	    }
	}
    }
d1037 3
a1039 3
    char    	*str;	    	/* The string to parse */
    SymTable   	*ctxt;    	/* The context for the variable */
    Boolean 	err;    	/* TRUE if undefined variables are an error */
d1041 1
a1041 1
    Boolean 	*freePtr; 	/* OUT: TRUE if caller should free result */
d1043 3
a1045 3
    char  	*tstr;    	/* Pointer into str */
    Var	    	*v;	    	/* Variable in invocation */
    char   	endc;    	/* Ending character when variable in parens
d1047 2
a1048 1
    char    	*start;
d1051 1
a1051 1
    int		idx;
d1058 1
a1058 1
    idx = 0;
d1061 4
a1064 1
    	tstr = str + 1;
d1069 1
a1069 1
    	str++;
d1072 1
a1072 11
	for (tstr = str; *tstr != ':'; tstr++) {
	    if (*tstr == '$') {
	    	v = var_name_with_dollar(str, &tstr, ctxt, err, endc);
	    	if (*tstr == '\0' || *tstr == endc)
		    endc = '\0';
		break;
	    } else if (*tstr == '\0' || *tstr == endc) {
	    	endc = '\0';
		break;
	    }
	}
d1076 3
a1078 40
    if (v == NULL) {
	idx = quick_lookup(str, &tstr, &k);
	v = varfind(str, tstr, ctxt, FIND_ENV | FIND_MINE, idx, k);
    }
    if (v == NULL) {
    	/* Find out about D and F forms of local variables. */
    	if (idx == -1 && tstr == str+2 && (str[1] == 'D' || str[1] == 'F')) {
	    switch (*str) {
	    case '@@':
	    	idx = TARGET_INDEX;
		break;
	    case '!':
	    	idx = ARCHIVE_INDEX;
		break;
	    case '*':
	    	idx = PREFIX_INDEX;
		break;
	    case '%':
	    	idx = MEMBER_INDEX;
		break;
	    default:
	    	break;
	    }
	    /* This is a DF form, check if we can expand it now.  */
	    if (idx != -1 && ctxt != NULL && ctxt != CTXT_GLOBAL) {
	    	v = varfind(str, str+1, ctxt, 0, idx, 0);
		/* No need for nested expansion or anything, as we're
		 * the only one who sets these things and we sure don't
		 * do nested invocations in them...  */
		if (v != NULL) {
		    val = VarValue(v);
		    if (str[1] == 'D')
			val = Var_GetHead(val);
		    else
			val = Var_GetTail(val);
		    *freePtr = TRUE;
		}
	    }
	}
    } else {
d1084 1
d1093 10
a1102 2
	if (strchr(val, '$') != NULL) {
	    val = Var_Subst(val, ctxt, err);
a1104 1

d1107 2
a1108 2
    if (endc != '\0')
	val = VarModifiers_Apply(val, ctxt, err, freePtr, tstr+1, endc, 
d1111 25
a1135 7
    	/* Dynamic source that can't be expanded for now: copy the var
	 * specification instead.  */
    	if (idx != -1 && (ctxt == NULL || ctxt == CTXT_GLOBAL)) {
	    *freePtr = TRUE;
	    val = interval_dup(start, start+ *lengthPtr);
	} else 
	    val = err ? var_Error : varNoError;
d1137 1
a1137 1

d1152 1
a1152 1
 *	None. The old string must be freed by the caller
d1157 3
a1159 3
    char 	  *str;	    	    /* the string in which to substitute */
    SymTable      *ctxt;	    /* the context wherein to find variables */
    Boolean 	  undefErr; 	    /* TRUE if undefineds are an error */
d1161 1
a1161 1
    BUFFER 	  buf;	    	    /* Buffer for forming things */
d1171 2
a1172 2
	size_t		length;		/* Length of the variable invocation */
	Boolean		doFree;		/* Set true if val should be freed */
d1197 1
a1197 1
	    if (oldVars) {
d1199 1
a1199 1
	    } else if (undefErr) {
d1203 1
a1203 1
		if (!errorReported) {
a1205 1
		}
d1210 1
a1210 1
		str += 1;
d1232 1
a1232 1
 *	variable is encountered. Returns the string with substitutions.
d1235 4
a1238 3
char *
Var_SubstVar(str, var, val, estimate)
    const char	*str;	        /* The string in which to substitute */
a1240 1
    size_t	estimate;	/* Size estimate for the result buffer */
a1241 1
    BUFFER	buf;		/* Where to store the result */
d1243 2
a1244 1
    Buf_Init(&buf, estimate);
d1250 1
a1250 1
	Buf_AddInterval(&buf, start, str);
d1258 1
a1258 1
	    Buf_AddInterval(&buf, start, start+2);
d1264 1
a1264 1
		Buf_AddChars(&buf, 2, start);
d1273 1
a1273 1
	    else 
d1280 3
a1282 3
	    /* A variable inside the variable.  We don't know how to
	     * expand the external variable at this point, so we try 
	     * again with the nested variable.  */
d1284 1
a1284 1
		Buf_AddInterval(&buf, start, p);
d1291 2
a1292 2
		/* Not the variable we want to expand.  */
		Buf_AddInterval(&buf, start, p);
d1295 1
a1295 1
	    } 
d1297 2
a1298 2
		size_t	length;		/* Length of the variable invocation */
		Boolean	doFree;		/* Set true if val should be freed */
d1300 1
d1302 1
a1302 1
	    	length = p - str + 1;
d1304 2
d1309 3
a1311 3
		newval = VarModifiers_Apply((char *)val, NULL, FALSE, 
		    &doFree, p+1, endc, &length);
		Buf_AddString(&buf, newval);
d1317 1
a1317 1
	    	str = p+1;
d1319 1
a1319 1
	Buf_AddString(&buf, val);
a1320 1
    return Buf_Retrieve(&buf);
d1329 1
a1329 1
 *	The VAR_CMD and VAR_GLOBAL contexts are created
d1335 1
a1335 1
    static GSymT global_vars, cmd_vars, env_vars;
a1338 1
    VAR_ENV = &env_vars;
a1340 1
    ohash_init(VAR_ENV, 5, &var_info);
d1343 2
a1344 1
    CTXT_ENV = (SymTable *)VAR_ENV;
d1355 1
a1355 1
    for (v = ohash_first(VAR_GLOBAL, &i); v != NULL; 
d1358 1
a1358 1
    for (v = ohash_first(VAR_CMD, &i); v != NULL; 
a1360 3
    for (v = ohash_first(VAR_ENV, &i); v != NULL; 
	v = ohash_next(VAR_ENV, &i))
	    VarDelete(v);
d1364 11
d1378 2
a1379 2
VarPrintVar(vp)
    void *vp;
d1381 2
a1382 3
    Var    *v = (Var *)vp;

    printf("%-16s = %s\n", v->name, VarValue(v));
d1388 1
a1388 1
 *	print all variables in a context
d1392 1
a1392 2
Var_Dump(ctxt)
   GSymT	*ctxt;
d1394 4
a1397 2
	Var *v;
	unsigned int i;
d1399 3
a1401 4
	for (v = ohash_first(ctxt, &i); v != NULL; 
	    v = ohash_next(ctxt, &i))
		VarPrintVar(v);
}
d1403 1
d1405 3
a1407 1
#ifdef POSIX
d1425 2
a1426 2
    for (v = ohash_first(VAR_CMD, &i); v != NULL; 
    	v = ohash_next(VAR_CMD, &i)) {
a1439 1
#endif
@


1.51
log
@Forgot to copy end of name in nested variable names, so that
${BC_${A}} worked but not ${${A}_BC}.
Noticed by fries@@
@
text
@d1 1
a1 1
/*	$OpenBSD: var.c,v 1.50 2000/11/24 14:29:56 espie Exp $	*/
d134 1
a134 1
static char rcsid[] = "$OpenBSD: var.c,v 1.50 2000/11/24 14:29:56 espie Exp $";
d198 1
a198 1
static struct hash_info var_info = { 
d241 1
a241 1
    *pk = hash_interval(name, end);
d401 1
a401 1
    v = hash_create_entry(&var_info, name, &end);
d420 1
a420 1
    return hash_find(ctxt, hash_lookup_interval(ctxt, name, end, k));
d550 1
a550 1
	hash_insert(ctxt, hash_lookup_interval(ctxt, name, end, k), v);
d594 1
a594 1
    v = hash_remove(ctxt, hash_lookup_interval(ctxt, name, end, k));
d1122 3
a1124 3
    hash_init(VAR_GLOBAL, 10, &var_info);
    hash_init(VAR_CMD, 5, &var_info);
    hash_init(VAR_ENV, 5, &var_info);
d1138 2
a1139 2
    for (v = hash_first(VAR_GLOBAL, &i); v != NULL; 
	v = hash_next(VAR_GLOBAL, &i))
d1141 2
a1142 2
    for (v = hash_first(VAR_CMD, &i); v != NULL; 
	v = hash_next(VAR_CMD, &i))
d1144 2
a1145 2
    for (v = hash_first(VAR_ENV, &i); v != NULL; 
	v = hash_next(VAR_ENV, &i))
d1174 2
a1175 2
	for (v = hash_first(ctxt, &i); v != NULL; 
	    v = hash_next(ctxt, &i))
d1198 2
a1199 2
    for (v = hash_first(VAR_CMD, &i); v != NULL; 
    	v = hash_next(VAR_CMD, &i)) {
@


1.50
log
@Take advantage of VarModifiers_Apply, which can parse a variable spec
and expand it directly, without needing a variable context.

Use it in Var_SubstVar, so that .for loops values don't need to be entered
into any context nor looked up.

This speeds up .for loops some, and avoids nasty variable capture
side-effects.

Ok'd millert@@, miod@@, naddy@@   (naddy spotted a problem with the first
version of that change).
@
text
@d1 1
a1 1
/*	$OpenBSD: var.c,v 1.49 2000/10/13 08:29:21 espie Exp $	*/
d134 1
a134 1
static char rcsid[] = "$OpenBSD: var.c,v 1.49 2000/10/13 08:29:21 espie Exp $";
d776 1
@


1.49
log
@esetenv: does a setenv and bails out if error.
@
text
@d1 1
a1 1
/*	$OpenBSD: var.c,v 1.48 2000/09/14 13:32:08 espie Exp $	*/
d96 5
d134 1
a134 1
static char rcsid[] = "$OpenBSD: var.c,v 1.48 2000/09/14 13:32:08 espie Exp $";
d1015 1
a1015 4
 *	variable is encountered.
 *
 * Side Effects:
 *	Append the result to the buffer
d1018 3
a1020 4
void
Var_SubstVar(buf, str, var, ctxt)
    Buffer	buf;		/* Where to store the result */
    char	*str;	        /* The string in which to substitute */
d1022 2
a1023 1
    GSymT	*ctxt;		/* The context wherein to find variables */
d1025 1
a1025 3
    char	*val;		/* Value substituted for a variable */
    size_t	length;		/* Length of the variable invocation */
    Boolean	doFree;		/* Set true if val should be freed */
d1027 1
d1029 3
a1031 3
	const char *cp;
	/* copy uninteresting stuff */
	for (cp = str; *str != '\0' && *str != '$'; str++)
d1033 4
a1036 2
	Buf_AddInterval(buf, cp, str);
	if (*str == '\0')
d1038 4
a1041 3
	if (str[1] == '$') {
	    Buf_AddString(buf, "$$");
	    str += 2;
d1044 4
a1047 4
	if (str[1] != '(' && str[1] != '{') {
	    if (str[1] != *var || var[1] != '\0') {
		Buf_AddChars(buf, 2, str);
		str += 2;
d1051 1
a1051 1
	    char *p;
d1054 1
a1054 1
	    if (str[1] == '(')
d1056 1
a1056 1
	    else if (str[1] == '{')
d1060 1
a1060 1
	    p = str+2;
d1067 1
a1067 1
		Buf_AddInterval(buf, str, p);
d1072 2
a1073 2
	    if (strncmp(var, str + 2, p - str - 2) != 0 ||
		var[p - str - 2] != '\0') {
d1075 1
a1075 1
		Buf_AddInterval(buf, str, p);
d1079 19
d1099 1
a1099 11
	/* okay, so we've found the variable we want to expand.  */
	val = Var_Parse(str, (SymTable *)ctxt, FALSE, &length, &doFree);
	/* We've now got a variable structure to store in. But first,
	 * advance the string pointer.  */
	str += length;

	/* Copy all the characters from the variable value straight
	 * into the new string.  */
	Buf_AddString(buf, val);
	if (doFree)
	    free(val);
d1101 1
@


1.48
log
@Some systematic clean-up.
- UNUSED macro that expands to __attribute__((unused)) for gcc
- move rcsid around so that they can be tagged UNUSED.
- activate -Wunused.
- use UNUSED instead of kludgy junk for function arguments.
- add extern to all extern prototypes.
- update comments in lst.h.
- clean up var.c a little bit, constifying arguments, updating comments...
@
text
@d1 1
a1 1
/*	$OpenBSD: var.c,v 1.47 2000/08/21 10:44:21 espie Exp $	*/
d129 1
a129 1
static char rcsid[] = "$OpenBSD: var.c,v 1.45 2000/07/17 23:29:35 espie Exp $";
d643 1
a643 1
	setenv(name, val, 1);
@


1.47
log
@Var_Append needs to set v for DEBUG(VAR) to work.
Obvious fix.
Problem reported by Gregory Steuck, thanks a lot !
@
text
@d1 1
a1 1
/*	$OpenBSD: var.c,v 1.46 2000/07/18 20:17:20 espie Exp $	*/
a68 8
#ifndef lint
#if 0
static char sccsid[] = "@@(#)var.c	8.3 (Berkeley) 3/19/94";
#else
static char rcsid[] = "$OpenBSD: var.c,v 1.46 2000/07/18 20:17:20 espie Exp $";
#endif
#endif /* not lint */

d124 9
d313 1
a313 1
    char 	*val;
a327 1

d336 1
a336 1
    char	*val;
d339 1
a339 1
    Var *v = gn->context.locals[idx];
d519 1
a519 1
 *	The new variable is placed at the front of the given context
d541 1
a541 1
    if (idx != -1) {
d544 1
a544 1
    } else
a553 6
 *
 * Results:
 *	None
 *
 * Side Effects:
 *	None
d558 1
a558 1
    void *vp;
d560 2
a561 1
    Var *v = (Var *) vp;
a572 3
 * Results:
 *	None.
 *
a574 1
 *
d579 2
a580 2
    char    	  *name;
    GSymT	  *ctxt;
d582 3
a584 3
    Var *v;
    u_int32_t k;
    const char *end = NULL;
a599 3
 * Results:
 *	None.
 *
d615 2
a616 2
    char	*name;	/* name of variable to set */
    char	*val;	/* value to give to the variable */
d619 1
a619 1
    register Var   *v;
a631 1

a653 3
 * Results:
 *	None
 *
d669 2
a670 2
    char	*name;	/* Name of variable to modify */
    char	*val;	/* String to append to it */
d673 1
a673 1
    register Var   *v;
a681 2


a693 4
 *
 * Side Effects:
 *	None.
 *
d698 1
a698 1
    char	*name;    	/* Variable to find */
d701 1
a701 1
    Var	    	  *v;
a717 3
 *
 * Side Effects:
 *	None
d722 1
a722 1
    char	*name;	/* name to find */
d725 1
a725 1
    Var            *v;
d746 2
a747 2
    char *str;			/* First dollar in variable name */
    char **pos;			/* Current position in variable spec */
d752 5
a756 5
    BUFFER buf;			/* Store the variable name */
    size_t sublen;		/* Deal with recursive expansions */
    Boolean subfree;		
    char *n; 			/* Sub name */
    Var *v;
d760 1
a760 1
    while (1) {
@


1.46
log
@Handle MAKEFLAGS variation mandated by POSIX.

Code to pass variable definitions to submakes through make flags.
Not activated yet, need to fix src/ first.
@
text
@d1 1
a1 1
/*	$OpenBSD: var.c,v 1.45 2000/07/17 23:29:35 espie Exp $	*/
d73 1
a73 1
static char rcsid[] = "$OpenBSD: var.c,v 1.45 2000/07/17 23:29:35 espie Exp $";
d694 1
a694 1
	(void)VarAdd(name, val, ctxt);
@


1.45
log
@parse embedded variable specs, e.g., ${VAR_${SUB}}

- need braces, as we don't want to change what $$A means,
- this assumes this kind of construct is very infrequent, thus
this does NOT copy the variable name needlessly.
- the expansion code is in a separate function for clarity.

Reviewed by miod@@, as previous patches.
@
text
@d1 1
a1 1
/*	$OpenBSD: var.c,v 1.44 2000/07/17 23:26:50 espie Exp $	*/
d73 1
a73 1
static char rcsid[] = "$OpenBSD: var.c,v 1.44 2000/07/17 23:26:50 espie Exp $";
d1189 35
@


1.44
log
@- let VarModifiers_Apply accept NULL string gracefully,
- simplify Var_Parse: use varfind, then leverage on the result
to recognize `special case' dynamic parsing.

VarModifiers_Apply need to be called on NULL strings, to be able to parse
modifiers applied to non-existent variables.

(Alternately, we could call VarModifiers_Apply on a dummy string, but
this is less efficient).
@
text
@d1 1
a1 1
/*	$OpenBSD: var.c,v 1.43 2000/07/17 23:09:06 espie Exp $	*/
d73 1
a73 1
static char rcsid[] = "$OpenBSD: var.c,v 1.43 2000/07/17 23:09:06 espie Exp $";
d206 1
d759 45
d841 2
d853 7
a859 2
	for (tstr = str; *tstr != ':'; tstr++)
	    if (*tstr == '\0' || *tstr == endc) {
d863 1
d867 4
a870 2
    idx = quick_lookup(str, &tstr, &k);
    v = varfind(str, tstr, ctxt, FIND_ENV | FIND_MINE, idx, k);
@


1.43
log
@Major unobfuscation: split var modifiers handling to a separate file.
This does finally make var handling somewhat readable.
@
text
@d1 1
a1 1
/*	$OpenBSD: var.c,v 1.42 2000/07/17 23:06:32 espie Exp $	*/
d73 1
a73 1
static char rcsid[] = "$OpenBSD: var.c,v 1.42 2000/07/17 23:06:32 espie Exp $";
a771 4
 *
 * Side Effects:
 *	None.
 *
d776 9
a784 10
    char    	  *str;	    	/* The string to parse */
    SymTable   	  *ctxt;    	/* The context for the variable */
    Boolean 	    err;    	/* TRUE if undefined variables are an error */
    size_t	    *lengthPtr;	/* OUT: The length of the specification */
    Boolean 	    *freePtr; 	/* OUT: TRUE if caller should free result */
{
    char   	    *tstr;    	/* Pointer into str */
    Var	    	    *v;	    	/* Variable in invocation */
    Boolean 	    haveModifier;/* TRUE if have modifiers for the variable */
    char   	    endc;    	/* Ending character when variable in parens
d786 4
a789 5
    char    	    *start;
    Boolean 	    dynamic;	/* TRUE if the variable is local and we're
				 * expanding it in a non-local context. This
				 * is done to support dynamic sources. The
				 * result is just the invocation, unaltered */
d792 1
a792 2
    dynamic = FALSE;
    start = str;
d794 6
a799 38
    if (str[1] != '(' && str[1] != '{') {
	/*
	 * If it's not bounded by braces of some sort, life is much simpler.
	 * We just need to check for the first character and return the
	 * value if it exists.
	 */
	v = VarFind_interval(str+1, str+2, ctxt, FIND_ENV | FIND_MINE);
	if (v == NULL) {
	    *lengthPtr = 2;

	    if (ctxt == CTXT_CMD || ctxt == CTXT_GLOBAL || ctxt == NULL) {
		/*
		 * If substituting a local variable in a non-local context,
		 * assume it's for dynamic source stuff. We have to handle
		 * this specially and return the longhand for the variable
		 * with the dollar sign escaped so it makes it back to the
		 * caller. Only four of the local variables are treated
		 * specially as they are the only four that will be set
		 * when dynamic sources are expanded.
		 */
		switch (str[1]) {
		    case '@@':
			return "$(.TARGET)";
		    case '%':
			return "$(.ARCHIVE)";
		    case '*':
			return "$(.PREFIX)";
		    case '!':
			return "$(.MEMBER)";
		}
	    }
	    /* Error.  */
	    return err ? var_Error : varNoError;
	} else {
	    haveModifier = FALSE;
	    tstr = &str[1];
	    endc = str[1];
	}
d801 2
a802 18
	endc = str[1] == '(' ? ')' : '}';

	/* Skip to the end character or a colon, whichever comes first.  */
	for (tstr = str + 2; *tstr != '\0' && *tstr != endc && *tstr != ':';)
	     tstr++;
	if (*tstr == ':')
	    haveModifier = TRUE;
	else if (*tstr != '\0')
	    haveModifier = FALSE;
	else {
	    /*
	     * If we never did find the end character, return NULL
	     * right now, setting the length to be the distance to
	     * the end of the string, since that's what make does.
	     */
	    *lengthPtr = tstr - str;
	    return var_Error;
	}
d804 5
a808 41
	v = VarFind_interval(str + 2, tstr, ctxt, FIND_ENV | FIND_MINE);
	if (v == NULL && ctxt != CTXT_CMD && ctxt != CTXT_GLOBAL && 
	    ctxt != NULL &&
	    (tstr-str) == 4 && (str[3] == 'F' || str[3] == 'D'))
	{
	    /*
	     * Check for bogus D and F forms of local variables since we're
	     * in a local context and the name is the right length.
	     */
	    switch (str[2]) {
		case '@@':
		case '%':
		case '*':
		case '!':
		case '>':
		case '<':
		{
		    char    *val;

		    /* Well, it's local -- go look for it.  */
		    v = VarFind_interval(str+2, str+3, ctxt, 0);

		    if (v != NULL) {
			/* No need for nested expansion or anything, as we're
			 * the only one who sets these things and we sure don't
			 * but nested invocations in them...  */
			val = VarValue(v);

			if (str[3] == 'D')
			    val = Var_GetHead(val);
			else
			    val = Var_GetTail(val);
			/* Resulting string is dynamically allocated, so
			 * tell caller to free it.  */
			*freePtr = TRUE;
			*lengthPtr = tstr-start+1;
			*tstr = endc;
			return val;
		    }
		    break;
		}
d810 2
a811 1
	}
d813 20
a832 34
	if (v == NULL) {
	    if ((tstr-str == 3 ||
		 (tstr-str == 4 && (str[3] == 'F' ||
					 str[3] == 'D'))) &&
		(ctxt == CTXT_CMD || ctxt == CTXT_GLOBAL || ctxt == NULL))
	    {
		/* If substituting a local variable in a non-local context,
		 * assume it's for dynamic source stuff. We have to handle
		 * this specially and return the longhand for the variable
		 * with the dollar sign escaped so it makes it back to the
		 * caller. Only four of the local variables are treated
		 * specially as they are the only four that will be set
		 * when dynamic sources are expanded.  */
		switch (str[2]) {
		    case '@@':
		    case '%':
		    case '*':
		    case '!':
			dynamic = TRUE;
			break;
		}
	    } else if (tstr-str > 4 && str[2] == '.' &&
		       isupper((unsigned char) str[3]) &&
		       (ctxt == CTXT_CMD || ctxt == CTXT_GLOBAL || ctxt == NULL))
	    {
		int	len;

		len = (tstr-str) - 3;
		if ((strncmp(str+2, ".TARGET", len) == 0) ||
		    (strncmp(str+2, ".ARCHIVE", len) == 0) ||
		    (strncmp(str+2, ".PREFIX", len) == 0) ||
		    (strncmp(str+2, ".MEMBER", len) == 0)) {
		    dynamic = TRUE;
		}
d834 12
a845 11

	    if (!haveModifier) {
		/* No modifiers -- have specification length so we can return
		 * now.  */
		*lengthPtr = tstr - start + 1;
		*tstr = endc;
		if (dynamic) {
		    char *n; 
		    n = emalloc(*lengthPtr + 1);
		    strncpy(n, start, *lengthPtr);
		    n[*lengthPtr] = '\0';
d847 1
a847 8
		    return n;
		} else
		    return err ? var_Error : varNoError;
	    } else {
		/* Still need to get to the end of the variable specification,
		 * so kludge up a Var structure for the modifications */
		v = new_var(str+1, NULL);	/* junk has name, for error reports */
		v->flags = VAR_JUNK;
d850 20
d871 2
a872 24

    if (v->flags & VAR_IN_USE)
	Fatal("Variable %s is recursive.", v->name);
	/*NOTREACHED*/
    else
	v->flags |= VAR_IN_USE;
    /* Before doing any modification, we have to make sure the value
     * has been fully expanded. If it looks like recursion might be
     * necessary (there's a dollar sign somewhere in the variable's value)
     * we just call Var_Subst to do any other substitutions that are
     * necessary. Note that the value returned by Var_Subst will have
     * been dynamically-allocated, so it will need freeing when we
     * return.  */
    str = VarValue(v);
    if (strchr(str, '$') != NULL) {
	str = Var_Subst(str, ctxt, err);
	*freePtr = TRUE;
    }

    v->flags &= ~VAR_IN_USE;

    *lengthPtr = tstr - start + 1;
    if (str != NULL && haveModifier)
    	str = VarModifiers_Apply(str, ctxt, err, freePtr, tstr+1, endc, 
d874 4
a877 13

    if (v->flags & VAR_JUNK) {
	/* Perform any free'ing needed and set *freePtr to FALSE so the caller
	 * doesn't try to free a static pointer.  */
	if (*freePtr)
	    free(str);
	*freePtr = FALSE;
	Buf_Destroy(&(v->val));
	free(v);
	if (dynamic) {
	    str = emalloc(*lengthPtr + 1);
	    strncpy(str, start, *lengthPtr);
	    str[*lengthPtr] = '\0';
d879 3
a881 3
	} else {
	    str = err ? var_Error : varNoError;
	}
d883 2
a884 1
    return str;
@


1.42
log
@separate modifiers handling from Var_Parse into a separate
VarModifiers_apply function.

for env lookup, create variable structure first, so that we can get away
without terminating the variable name in main Var_Parse.
@
text
@d1 1
a1 1
/*	$OpenBSD: var.c,v 1.41 2000/07/17 23:01:20 espie Exp $	*/
d73 1
a73 1
static char rcsid[] = "$OpenBSD: var.c,v 1.41 2000/07/17 23:01:20 espie Exp $";
d130 1
a191 25
/* Var*Pattern flags */
#define VAR_SUB_GLOBAL	0x01	/* Apply substitution globally */
#define VAR_SUB_ONE	0x02	/* Apply substitution to one word */
#define VAR_SUB_MATCHED	0x04	/* There was a match */
#define VAR_MATCH_START	0x08	/* Match at start of word */
#define VAR_MATCH_END	0x10	/* Match at end of word */

typedef struct {
    char    	  *lhs;	    /* String to match */
    size_t    	  leftLen;  /* Length of string */
    char    	  *rhs;	    /* Replacement string (w/ &'s removed) */
    size_t    	  rightLen; /* Length of replacement */
    int	    	  flags;
} VarPattern;

#ifndef MAKE_BOOTSTRAP
typedef struct {
    regex_t	  re;
    int		  nsub;
    regmatch_t	 *matches;
    char	 *replace;
    int		  flags;
} VarREPattern;
#endif

a196 1
static int VarCmp __P((void *, void *));
a201 20
static Boolean VarHead __P((const char *, Boolean, Buffer, void *));
static Boolean VarTail __P((const char *, Boolean, Buffer, void *));
static Boolean VarSuffix __P((const char *, Boolean, Buffer, void *));
static Boolean VarRoot __P((const char *, Boolean, Buffer, void *));
static Boolean VarMatch __P((const char *, Boolean, Buffer, void *));
#ifdef SYSVVARSUB
static Boolean VarSYSVMatch __P((const char *, Boolean, Buffer, void *));
#endif
static Boolean VarNoMatch __P((const char *, Boolean, Buffer, void *));
#ifndef MAKE_BOOTSTRAP
static void VarREError __P((int, regex_t *, const char *));
static Boolean VarRESubstitute __P((const char *, Boolean, Buffer, void *));
#endif
static Boolean VarSubstitute __P((const char *, Boolean, Buffer, void *));
static char *VarGetPattern __P((SymTable *, int, char **, int, int *, size_t *,
				VarPattern *));
static char *VarQuote __P((const char *));
static char *VarModify __P((const char *, Boolean (*)(const char *, Boolean, Buffer, void *), void *));
char *VarModifiers_Apply __P((char *, SymTable *, Boolean, 
	Boolean *, char *, char, size_t *));
a202 2
static Boolean VarUppercase __P((const char *, Boolean, Buffer, void *));
static Boolean VarLowercase __P((const char *, Boolean, Buffer, void *));
a759 801
 * VarUppercase --
 *	Place the Upper cased word in the given buffer.
 *
 * Results:
 *	TRUE if characters were added to the buffer (a space needs to be
 *	added to the buffer before the next word).
 *
 * Side Effects:
 *	The word is added to the buffer.
 *
 *-----------------------------------------------------------------------
 */
static Boolean
VarUppercase(word, addSpace, buf, dummy)
    const char    *word;    	/* Word to Upper Case */
    Boolean 	  addSpace; 	/* True if need to add a space to the buffer
				 * before sticking in the head */
    Buffer  	  buf;	    	/* Buffer in which to store it */
    void *dummy;
{
    size_t len = strlen(word);

    if (addSpace)
	Buf_AddSpace(buf);
    while (len--)
    	Buf_AddChar(buf, toupper(*word++));
    return TRUE;
}

/*-
 *-----------------------------------------------------------------------
 * VarLowercase --
 *	Place the Lower cased word in the given buffer.
 *
 * Results:
 *	TRUE if characters were added to the buffer (a space needs to be
 *	added to the buffer before the next word).
 *
 * Side Effects:
 *	The word is added to the buffer.
 *
 *-----------------------------------------------------------------------
 */
static Boolean
VarLowercase(word, addSpace, buf, dummy)
    const char    *word;    	/* Word to Lower Case */
    Boolean 	  addSpace; 	/* True if need to add a space to the buffer
				 * before sticking in the head */
    Buffer  	  buf;	    	/* Buffer in which to store it */
    void *dummy;
{
    size_t len = strlen(word);

    if (addSpace)
	Buf_AddSpace(buf);
    while (len--)
    	Buf_AddChar(buf, tolower(*word++));
    return TRUE;
}

/*-
 *-----------------------------------------------------------------------
 * VarHead --
 *	Remove the tail of the given word and place the result in the given
 *	buffer.
 *
 * Results:
 *	TRUE if characters were added to the buffer (a space needs to be
 *	added to the buffer before the next word).
 *
 * Side Effects:
 *	The trimmed word is added to the buffer.
 *
 *-----------------------------------------------------------------------
 */
static Boolean
VarHead(word, addSpace, buf, dummy)
    const char    *word;    	/* Word to trim */
    Boolean 	  addSpace; 	/* True if need to add a space to the buffer
				 * before sticking in the head */
    Buffer  	  buf;	    	/* Buffer in which to store it */
    void 	  *dummy;
{
    const char 	  *slash;

    slash = strrchr(word, '/');
    if (slash != NULL) {
	if (addSpace)
	    Buf_AddSpace(buf);
	Buf_AddInterval(buf, word, slash);
	return TRUE;
    } else {
	/* If no directory part, give . (q.v. the POSIX standard) */
	if (addSpace)
	    Buf_AddString(buf, " .");
	else
	    Buf_AddChar(buf, '.');
    }
    return(dummy ? TRUE : TRUE);
}

/*-
 *-----------------------------------------------------------------------
 * VarTail --
 *	Remove the head of the given word and place the result in the given
 *	buffer.
 *
 * Results:
 *	TRUE if characters were added to the buffer (a space needs to be
 *	added to the buffer before the next word).
 *
 * Side Effects:
 *	The trimmed word is added to the buffer.
 *
 *-----------------------------------------------------------------------
 */
static Boolean
VarTail(word, addSpace, buf, dummy)
    const char    *word;    	/* Word to trim */
    Boolean 	  addSpace; 	/* TRUE if need to stick a space in the
				 * buffer before adding the tail */
    Buffer  	  buf;	    	/* Buffer in which to store it */
    void 	  *dummy;
{
    const char *slash;

    if (addSpace) 
	Buf_AddSpace(buf);
    slash = strrchr(word, '/');
    if (slash != NULL)
	Buf_AddString(buf, slash+1);
    else
	Buf_AddString(buf, word);
    return (dummy ? TRUE : TRUE);
}

/*-
 *-----------------------------------------------------------------------
 * VarSuffix --
 *	Place the suffix of the given word in the given buffer.
 *
 * Results:
 *	TRUE if characters were added to the buffer (a space needs to be
 *	added to the buffer before the next word).
 *
 * Side Effects:
 *	The suffix from the word is placed in the buffer.
 *
 *-----------------------------------------------------------------------
 */
static Boolean
VarSuffix(word, addSpace, buf, dummy)
    const char    *word;    	/* Word to trim */
    Boolean 	  addSpace; 	/* TRUE if need to add a space before placing
				 * the suffix in the buffer */
    Buffer  	  buf;	    	/* Buffer in which to store it */
    void 	  *dummy;
{
    const char *dot;

    dot = strrchr(word, '.');
    if (dot != NULL) {
	if (addSpace)
	    Buf_AddSpace(buf);
	Buf_AddString(buf, dot+1);
	addSpace = TRUE;
    }
    return (dummy ? addSpace : addSpace);
}

/*-
 *-----------------------------------------------------------------------
 * VarRoot --
 *	Remove the suffix of the given word and place the result in the
 *	buffer.
 *
 * Results:
 *	TRUE if characters were added to the buffer (a space needs to be
 *	added to the buffer before the next word).
 *
 * Side Effects:
 *	The trimmed word is added to the buffer.
 *
 *-----------------------------------------------------------------------
 */
static Boolean
VarRoot(word, addSpace, buf, dummy)
    const char 	  *word;    	/* Word to trim */
    Boolean 	  addSpace; 	/* TRUE if need to add a space to the buffer
				 * before placing the root in it */
    Buffer  	  buf;	    	/* Buffer in which to store it */
    void 	  *dummy;
{
    const char *dot;

    if (addSpace)
	Buf_AddSpace(buf);

    dot = strrchr(word, '.');
    if (dot != NULL)
	Buf_AddInterval(buf, word, dot);
    else
	Buf_AddString(buf, word);
    return (dummy ? TRUE : TRUE);
}

/*-
 *-----------------------------------------------------------------------
 * VarMatch --
 *	Place the word in the buffer if it matches the given pattern.
 *	Callback function for VarModify to implement the :M modifier.
 *
 * Results:
 *	TRUE if a space should be placed in the buffer before the next
 *	word.
 *
 * Side Effects:
 *	The word may be copied to the buffer.
 *
 *-----------------------------------------------------------------------
 */
static Boolean
VarMatch(word, addSpace, buf, pattern)
    const char    *word;    	/* Word to examine */
    Boolean 	  addSpace; 	/* TRUE if need to add a space to the
				 * buffer before adding the word, if it
				 * matches */
    Buffer  	  buf;	    	/* Buffer in which to store it */
    void 	  *pattern; 	/* Pattern the word must match */
{
    if (Str_Match(word, (char *) pattern)) {
	if (addSpace)
	    Buf_AddSpace(buf);
	addSpace = TRUE;
	Buf_AddString(buf, word);
    }
    return addSpace;
}

#ifdef SYSVVARSUB
/*-
 *-----------------------------------------------------------------------
 * VarSYSVMatch --
 *	Place the word in the buffer if it matches the given pattern.
 *	Callback function for VarModify to implement the System V %
 *	modifiers.
 *
 * Results:
 *	TRUE if a space should be placed in the buffer before the next
 *	word.
 *
 * Side Effects:
 *	The word may be copied to the buffer.
 *
 *-----------------------------------------------------------------------
 */
static Boolean
VarSYSVMatch(word, addSpace, buf, patp)
    const char    *word;    	/* Word to examine */
    Boolean 	  addSpace; 	/* TRUE if need to add a space to the
				 * buffer before adding the word, if it
				 * matches */
    Buffer  	  buf;	    	/* Buffer in which to store it */
    void 	  *patp; 	/* Pattern the word must match */
{
    size_t 	  len;
    const char    *ptr;
    VarPattern 	  *pat = (VarPattern *) patp;

    if (*word) {
	    if (addSpace)
		Buf_AddSpace(buf);

	    addSpace = TRUE;

	    if ((ptr = Str_SYSVMatch(word, pat->lhs, &len)) != NULL)
		Str_SYSVSubst(buf, pat->rhs, ptr, len);
	    else
		Buf_AddString(buf, word);
    }
    return addSpace;
}
#endif


/*-
 *-----------------------------------------------------------------------
 * VarNoMatch --
 *	Place the word in the buffer if it doesn't match the given pattern.
 *	Callback function for VarModify to implement the :N modifier.
 *
 * Results:
 *	TRUE if a space should be placed in the buffer before the next
 *	word.
 *
 * Side Effects:
 *	The word may be copied to the buffer.
 *
 *-----------------------------------------------------------------------
 */
static Boolean
VarNoMatch(word, addSpace, buf, pattern)
    const char    *word;    	/* Word to examine */
    Boolean 	  addSpace; 	/* TRUE if need to add a space to the
				 * buffer before adding the word, if it
				 * matches */
    Buffer  	  buf;	    	/* Buffer in which to store it */
    void 	  *pattern; 	/* Pattern the word must match */
{
    if (!Str_Match(word, (char *) pattern)) {
	if (addSpace)
	    Buf_AddSpace(buf);
	addSpace = TRUE;
	Buf_AddString(buf, word);
    }
    return(addSpace);
}


/*-
 *-----------------------------------------------------------------------
 * VarSubstitute --
 *	Perform a string-substitution on the given word, placing the
 *	result in the passed buffer.
 *
 * Results:
 *	TRUE if a space is needed before more characters are added.
 *
 * Side Effects:
 *	None.
 *
 *-----------------------------------------------------------------------
 */
static Boolean
VarSubstitute(word, addSpace, buf, patternp)
    const char 	  	*word;	    /* Word to modify */
    Boolean 	  	addSpace;   /* True if space should be added before
				     * other characters */
    Buffer  	  	buf;	    /* Buffer for result */
    void 		*patternp;  /* Pattern for substitution */
{
    size_t  		wordLen;    /* Length of word */
    const char 	*cp;	    	    /* General pointer */
    VarPattern	*pattern = (VarPattern *) patternp;

    wordLen = strlen(word);
    if ((pattern->flags & (VAR_SUB_ONE|VAR_SUB_MATCHED)) !=
	(VAR_SUB_ONE|VAR_SUB_MATCHED)) {
	/*
	 * Still substituting -- break it down into simple anchored cases
	 * and if none of them fits, perform the general substitution case.
	 */
	if ((pattern->flags & VAR_MATCH_START) &&
	    (strncmp(word, pattern->lhs, pattern->leftLen) == 0)) {
		/*
		 * Anchored at start and beginning of word matches pattern
		 */
		if ((pattern->flags & VAR_MATCH_END) &&
		    (wordLen == pattern->leftLen)) {
			/*
			 * Also anchored at end and matches to the end (word
			 * is same length as pattern) add space and rhs only
			 * if rhs is non-null.
			 */
			if (pattern->rightLen != 0) {
			    if (addSpace)
				Buf_AddSpace(buf);
			    addSpace = TRUE;
			    Buf_AddChars(buf, pattern->rightLen, pattern->rhs);
			}
			pattern->flags |= VAR_SUB_MATCHED;
		} else if (pattern->flags & VAR_MATCH_END) {
		    /*
		     * Doesn't match to end -- copy word wholesale
		     */
		    goto nosub;
		} else {
		    /*
		     * Matches at start but need to copy in trailing characters
		     */
		    if ((pattern->rightLen + wordLen - pattern->leftLen) != 0){
			if (addSpace)
			    Buf_AddSpace(buf);
			addSpace = TRUE;
		    }
		    Buf_AddChars(buf, pattern->rightLen, pattern->rhs);
		    Buf_AddChars(buf, wordLen - pattern->leftLen,
				 word + pattern->leftLen);
		    pattern->flags |= VAR_SUB_MATCHED;
		}
	} else if (pattern->flags & VAR_MATCH_START) {
	    /*
	     * Had to match at start of word and didn't -- copy whole word.
	     */
	    goto nosub;
	} else if (pattern->flags & VAR_MATCH_END) {
	    /*
	     * Anchored at end, Find only place match could occur (leftLen
	     * characters from the end of the word) and see if it does. Note
	     * that because the $ will be left at the end of the lhs, we have
	     * to use strncmp.
	     */
	    cp = word + (wordLen - pattern->leftLen);
	    if ((cp >= word) &&
		(strncmp(cp, pattern->lhs, pattern->leftLen) == 0)) {
		/*
		 * Match found. If we will place characters in the buffer,
		 * add a space before hand as indicated by addSpace, then
		 * stuff in the initial, unmatched part of the word followed
		 * by the right-hand-side.
		 */
		if (((cp - word) + pattern->rightLen) != 0) {
		    if (addSpace)
			Buf_AddSpace(buf);
		    addSpace = TRUE;
		}
		Buf_AddInterval(buf, word, cp);
		Buf_AddChars(buf, pattern->rightLen, pattern->rhs);
		pattern->flags |= VAR_SUB_MATCHED;
	    } else {
		/*
		 * Had to match at end and didn't. Copy entire word.
		 */
		goto nosub;
	    }
	} else {
	    /*
	     * Pattern is unanchored: search for the pattern in the word using
	     * String_FindSubstring, copying unmatched portions and the
	     * right-hand-side for each match found, handling non-global
	     * substitutions correctly, etc. When the loop is done, any
	     * remaining part of the word (word and wordLen are adjusted
	     * accordingly through the loop) is copied straight into the
	     * buffer.
	     * addSpace is set FALSE as soon as a space is added to the
	     * buffer.
	     */
	    register Boolean done;
	    size_t origSize;

	    done = FALSE;
	    origSize = Buf_Size(buf);
	    while (!done) {
		cp = strstr(word, pattern->lhs);
		if (cp != (char *)NULL) {
		    if (addSpace && (((cp - word) + pattern->rightLen) != 0)){
			Buf_AddSpace(buf);
			addSpace = FALSE;
		    }
		    Buf_AddInterval(buf, word, cp);
		    Buf_AddChars(buf, pattern->rightLen, pattern->rhs);
		    wordLen -= (cp - word) + pattern->leftLen;
		    word = cp + pattern->leftLen;
		    if (wordLen == 0 || (pattern->flags & VAR_SUB_GLOBAL) == 0){
			done = TRUE;
		    }
		    pattern->flags |= VAR_SUB_MATCHED;
		} else {
		    done = TRUE;
		}
	    }
	    if (wordLen != 0) {
		if (addSpace)
		    Buf_AddSpace(buf);
		Buf_AddChars(buf, wordLen, word);
	    }
	    /*
	     * If added characters to the buffer, need to add a space
	     * before we add any more. If we didn't add any, just return
	     * the previous value of addSpace.
	     */
	    return (Buf_Size(buf) != origSize || addSpace);
	}
	return (addSpace);
    }
 nosub:
    if (addSpace)
	Buf_AddSpace(buf);
    Buf_AddChars(buf, wordLen, word);
    return(TRUE);
}

#ifndef MAKE_BOOTSTRAP
/*-
 *-----------------------------------------------------------------------
 * VarREError --
 *	Print the error caused by a regcomp or regexec call.
 *
 * Results:
 *	None.
 *
 * Side Effects:
 *	An error gets printed.
 *
 *-----------------------------------------------------------------------
 */
static void
VarREError(err, pat, str)
    int err;
    regex_t *pat;
    const char *str;
{
    char *errbuf;
    int errlen;

    errlen = regerror(err, pat, 0, 0);
    errbuf = emalloc(errlen);
    regerror(err, pat, errbuf, errlen);
    Error("%s: %s", str, errbuf);
    free(errbuf);
}

/*-
 *-----------------------------------------------------------------------
 * VarRESubstitute --
 *	Perform a regex substitution on the given word, placing the
 *	result in the passed buffer.
 *
 * Results:
 *	TRUE if a space is needed before more characters are added.
 *
 * Side Effects:
 *	None.
 *
 *-----------------------------------------------------------------------
 */
static Boolean
VarRESubstitute(word, addSpace, buf, patternp)
    const char *word;
    Boolean addSpace;
    Buffer buf;
    void *patternp;
{
    VarREPattern *pat;
    int xrv;
    const char *wp;
    char *rp;
    int added;

#define MAYBE_ADD_SPACE()		\
	if (addSpace && !added)		\
	    Buf_AddSpace(buf);		\
	added = 1

    added = 0;
    wp = word;
    pat = patternp;

    if ((pat->flags & (VAR_SUB_ONE|VAR_SUB_MATCHED)) ==
	(VAR_SUB_ONE|VAR_SUB_MATCHED))
	xrv = REG_NOMATCH;
    else {
    tryagain:
	xrv = regexec(&pat->re, wp, pat->nsub, pat->matches, 0);
    }

    switch (xrv) {
    case 0:
	pat->flags |= VAR_SUB_MATCHED;
	if (pat->matches[0].rm_so > 0) {
	    MAYBE_ADD_SPACE();
	    Buf_AddChars(buf, pat->matches[0].rm_so, wp);
	}

	for (rp = pat->replace; *rp; rp++) {
	    if ((*rp == '\\') && ((rp[1] == '&') || (rp[1] == '\\'))) {
		MAYBE_ADD_SPACE();
		Buf_AddChar(buf, rp[1]);
		rp++;
	    }
	    else if ((*rp == '&') || ((*rp == '\\') && isdigit(rp[1]))) {
		int n;
		const char *subbuf;
		int sublen;
		char errstr[3];

		if (*rp == '&') {
		    n = 0;
		    errstr[0] = '&';
		    errstr[1] = '\0';
		} else {
		    n = rp[1] - '0';
		    errstr[0] = '\\';
		    errstr[1] = rp[1];
		    errstr[2] = '\0';
		    rp++;
		}

		if (n > pat->nsub) {
		    Error("No subexpression %s", &errstr[0]);
		    subbuf = "";
		    sublen = 0;
		} else if ((pat->matches[n].rm_so == -1) &&
			   (pat->matches[n].rm_eo == -1)) {
		    Error("No match for subexpression %s", &errstr[0]);
		    subbuf = "";
		    sublen = 0;
	        } else {
		    subbuf = wp + pat->matches[n].rm_so;
		    sublen = pat->matches[n].rm_eo - pat->matches[n].rm_so;
		}

		if (sublen > 0) {
		    MAYBE_ADD_SPACE();
		    Buf_AddChars(buf, sublen, subbuf);
		}
	    } else {
		MAYBE_ADD_SPACE();
		Buf_AddChar(buf, *rp);
	    }
	}
	wp += pat->matches[0].rm_eo;
	if (pat->flags & VAR_SUB_GLOBAL)
	    goto tryagain;
	if (*wp) {
	    MAYBE_ADD_SPACE();
	    Buf_AddChars(buf, strlen(wp), wp);
	}
	break;
    default:
	VarREError(xrv, &pat->re, "Unexpected regex error");
       /* fall through */
    case REG_NOMATCH:
	if (*wp) {
	    MAYBE_ADD_SPACE();
	    Buf_AddChars(buf, strlen(wp), wp);
	}
	break;
    }
    return(addSpace||added);
}
#endif

/*-
 *-----------------------------------------------------------------------
 * VarModify --
 *	Modify each of the words of the passed string using the given
 *	function. Used to implement all modifiers.
 *
 * Results:
 *	A string of all the words modified appropriately.
 *
 *-----------------------------------------------------------------------
 */
static char *
VarModify (str, modProc, datum)
    const char    	  *str;	    /* String whose words should be trimmed */
				    /* Function to use to modify them */
    Boolean    	  (*modProc) __P((const char *, Boolean, Buffer, void *));
    void          *datum;    	    /* Datum to pass it */
{
    BUFFER  	  buf;	    	    /* Buffer for the new string */
    Boolean 	  addSpace; 	    /* TRUE if need to add a space to the
				     * buffer before adding the trimmed
				     * word */
    char 	  **av;		    /* word list */
    char 	  *as;		    /* word list memory */
    int ac, i;

    Buf_Init(&buf, 0);
    addSpace = FALSE;

    av = brk_string(str, &ac, FALSE, &as);

    for (i = 0; i < ac; i++)
	addSpace = (*modProc)(av[i], addSpace, &buf, datum);

    free(as);
    free(av);
    return Buf_Retrieve(&buf);
}

/*-
 *-----------------------------------------------------------------------
 * VarGetPattern --
 *	Pass through the tstr looking for 1) escaped delimiters,
 *	'$'s and backslashes (place the escaped character in
 *	uninterpreted) and 2) unescaped $'s that aren't before
 *	the delimiter (expand the variable substitution).
 *	Return the expanded string or NULL if the delimiter was missing
 *	If pattern is specified, handle escaped ampersands, and replace
 *	unescaped ampersands with the lhs of the pattern.
 *
 * Results:
 *	A string of all the words modified appropriately.
 *	If length is specified, return the string length of the buffer
 *	If flags is specified and the last character of the pattern is a
 *	$ set the VAR_MATCH_END bit of flags.
 *
 * Side Effects:
 *	None.
 *-----------------------------------------------------------------------
 */
static char *
VarGetPattern(ctxt, err, tstr, delim, flags, length, pattern)
    SymTable *ctxt;
    int err;
    char **tstr;
    int delim;
    int *flags;
    size_t *length;
    VarPattern *pattern;
{
    char *cp;
    BUFFER buf;
    size_t junk;

    Buf_Init(&buf, 0);
    if (length == NULL)
	length = &junk;

#define IS_A_MATCH(cp, delim) \
    ((cp[0] == '\\') && ((cp[1] == delim) ||  \
     (cp[1] == '\\') || (cp[1] == '$') || (pattern && (cp[1] == '&'))))

    /*
     * Skim through until the matching delimiter is found;
     * pick up variable substitutions on the way. Also allow
     * backslashes to quote the delimiter, $, and \, but don't
     * touch other backslashes.
     */
    for (cp = *tstr; *cp && (*cp != delim); cp++) {
	if (IS_A_MATCH(cp, delim)) {
	    Buf_AddChar(&buf, cp[1]);
	    cp++;
	} else if (*cp == '$') {
	    if (cp[1] == delim) {
		if (flags == NULL)
		    Buf_AddChar(&buf, *cp);
		else
		    /*
		     * Unescaped $ at end of pattern => anchor
		     * pattern at end.
		     */
		    *flags |= VAR_MATCH_END;
	    }
	    else {
		char   *cp2;
		size_t     len;
		Boolean freeIt;

		/*
		 * If unescaped dollar sign not before the
		 * delimiter, assume it's a variable
		 * substitution and recurse.
		 */
		cp2 = Var_Parse(cp, ctxt, err, &len, &freeIt);
		Buf_AddString(&buf, cp2);
		if (freeIt)
		    free(cp2);
		cp += len - 1;
	    }
	}
	else if (pattern && *cp == '&')
	    Buf_AddChars(&buf, pattern->leftLen, pattern->lhs);
	else
	    Buf_AddChar(&buf, *cp);
    }

    if (*cp != delim) {
	*tstr = cp;
	*length = 0;
	return NULL;
    }
    else {
	*tstr = ++cp;
	*length = Buf_Size(&buf);
	return Buf_Retrieve(&buf);
    }
}

/*-
 *-----------------------------------------------------------------------
 * VarQuote --
 *	Quote shell meta-characters in the string
 *
 * Results:
 *	The quoted string
 *
 *-----------------------------------------------------------------------
 */
static char *
VarQuote(str)
	const char *str;
{

    BUFFER  	  buf;
    /* This should cover most shells :-( */
    static char meta[] = "\n \t'`\";&<>()|*?{}[]\\$!#^~";

    Buf_Init(&buf, MAKE_BSIZE);
    for (; *str; str++) {
	if (strchr(meta, *str) != NULL)
	    Buf_AddChar(&buf, '\\');
	Buf_AddChar(&buf, *str);
    }
    return Buf_Retrieve(&buf);
}

/*-
 *-----------------------------------------------------------------------
a1006 343
char *
VarModifiers_Apply(str, ctxt, err, freePtr, start, endc, lengthPtr)
    char 	*str;
    SymTable	*ctxt;
    Boolean	err;
    Boolean	*freePtr;
    char	*start;
    char 	endc;
    size_t	*lengthPtr;
{
    char 	*tstr; 
    char	delim;
    char	*cp;

    tstr = start;

    /*
     * Now we need to apply any modifiers the user wants applied.
     * These are:
     *  	  :M<pattern>	words which match the given <pattern>.
     *  	  	    	<pattern> is of the standard file
     *  	  	    	wildcarding form.
     *  	  :S<d><pat1><d><pat2><d>[g]
     *  	  	    	Substitute <pat2> for <pat1> in the value
     *  	  :C<d><pat1><d><pat2><d>[g]
     *  	  	    	Substitute <pat2> for regex <pat1> in the value
     *  	  :H	    	Substitute the head of each word
     *  	  :T	    	Substitute the tail of each word
     *  	  :E	    	Substitute the extension (minus '.') of
     *  	  	    	each word
     *  	  :R	    	Substitute the root of each word
     *  	  	    	(pathname minus the suffix).
     *	    	  :lhs=rhs  	Like :S, but the rhs goes to the end of
     *	    	    	    	the invocation.
     */
    while (*tstr != endc) {
	char	*newStr;    /* New value to return */
	char	termc;	    /* Character which terminated scan */

	if (DEBUG(VAR))
	    printf("Applying :%c to \"%s\"\n", *tstr, str);
	switch (*tstr) {
	    case 'N':
	    case 'M':
	    {
		for (cp = tstr + 1;
		     *cp != '\0' && *cp != ':' && *cp != endc;
		     cp++) {
		    if (*cp == '\\' && (cp[1] == ':' || cp[1] == endc)){
			cp++;
		    }
		}
		termc = *cp;
		*cp = '\0';
		if (*tstr == 'M')
		    newStr = VarModify(str, VarMatch, tstr+1);
		else
		    newStr = VarModify(str, VarNoMatch, tstr+1);
		break;
	    }
	    case 'S':
	    {
		VarPattern 	    pattern;

		pattern.flags = 0;
		delim = tstr[1];
		tstr += 2;

		/* If pattern begins with '^', it is anchored to the
		 * start of the word -- skip over it and flag pattern.  */
		if (*tstr == '^') {
		    pattern.flags |= VAR_MATCH_START;
		    tstr++;
		}

		cp = tstr;
		if ((pattern.lhs = VarGetPattern(ctxt, err, &cp, delim,
		    &pattern.flags, &pattern.leftLen, NULL)) == NULL)
		    goto cleanup;

		if ((pattern.rhs = VarGetPattern(ctxt, err, &cp, delim,
		    NULL, &pattern.rightLen, &pattern)) == NULL)
		    goto cleanup;

		/* Check for global substitution. If 'g' after the final
		 * delimiter, substitution is global and is marked that
		 * way.  */
		for (;; cp++) {
		    switch (*cp) {
		    case 'g':
			pattern.flags |= VAR_SUB_GLOBAL;
			continue;
		    case '1':
			pattern.flags |= VAR_SUB_ONE;
			continue;
		    }
		    break;
		}

		termc = *cp;
		newStr = VarModify(str, VarSubstitute, &pattern);

		/* Free the two strings.  */
		free(pattern.lhs);
		free(pattern.rhs);
		break;
	    }
#ifndef MAKE_BOOTSTRAP
	    case 'C':
	    {
		VarREPattern    pattern;
		char           *re;
		int             error;

		pattern.flags = 0;
		delim = tstr[1];
		tstr += 2;

		cp = tstr;

		if ((re = VarGetPattern(ctxt, err, &cp, delim, NULL,
		    NULL, NULL)) == NULL)
		    goto cleanup;

		if ((pattern.replace = VarGetPattern(ctxt, err, &cp,
		    delim, NULL, NULL, NULL)) == NULL) {
		    free(re);
		    goto cleanup;
		}

		for (;; cp++) {
		    switch (*cp) {
		    case 'g':
			pattern.flags |= VAR_SUB_GLOBAL;
			continue;
		    case '1':
			pattern.flags |= VAR_SUB_ONE;
			continue;
		    }
		    break;
		}

		termc = *cp;

		error = regcomp(&pattern.re, re, REG_EXTENDED);
		free(re);
		if (error) {
		    *lengthPtr = cp - start + 1;
		    VarREError(error, &pattern.re, "RE substitution error");
		    free(pattern.replace);
		    return var_Error;
		}

		pattern.nsub = pattern.re.re_nsub + 1;
		if (pattern.nsub < 1)
		    pattern.nsub = 1;
		if (pattern.nsub > 10)
		    pattern.nsub = 10;
		pattern.matches = emalloc(pattern.nsub *
					  sizeof(regmatch_t));
		newStr = VarModify(str, VarRESubstitute, &pattern);
		regfree(&pattern.re);
		free(pattern.replace);
		free(pattern.matches);
		break;
	    }
#endif
	    case 'Q':
		if (tstr[1] == endc || tstr[1] == ':') {
		    newStr = VarQuote(str);
		    cp = tstr + 1;
		    termc = *cp;
		    break;
		}
		/*FALLTHRU*/
	    case 'T':
		if (tstr[1] == endc || tstr[1] == ':') {
		    newStr = VarModify(str, VarTail, NULL);
		    cp = tstr + 1;
		    termc = *cp;
		    break;
		}
		/*FALLTHRU*/
	    case 'H':
		if (tstr[1] == endc || tstr[1] == ':') {
		    newStr = VarModify(str, VarHead, NULL);
		    cp = tstr + 1;
		    termc = *cp;
		    break;
		}
		/*FALLTHRU*/
	    case 'E':
		if (tstr[1] == endc || tstr[1] == ':') {
		    newStr = VarModify(str, VarSuffix, NULL);
		    cp = tstr + 1;
		    termc = *cp;
		    break;
		}
		/*FALLTHRU*/
	    case 'R':
		if (tstr[1] == endc || tstr[1] == ':') {
		    newStr = VarModify(str, VarRoot, NULL);
		    cp = tstr + 1;
		    termc = *cp;
		    break;
		}
		/*FALLTHRU*/
	    case 'U':
		if (tstr[1] == endc || tstr[1] == ':') {
		    newStr = VarModify(str, VarUppercase, NULL);
		    cp = tstr + 1;
		    termc = *cp;
		    break;
		}
		/*FALLTHRU*/
	    case 'L':
		if (tstr[1] == endc || tstr[1] == ':') {
		    newStr = VarModify(str, VarLowercase, NULL);
		    cp = tstr + 1;
		    termc = *cp;
		    break;
		}
		/*FALLTHRU*/
#ifdef SUNSHCMD
	    case 's':
		if (tstr[1] == 'h' && (tstr[2] == endc || tstr[2] == ':')) {
		    char *err;
		    newStr = Cmd_Exec(str, &err);
		    if (err)
			Error(err, str);
		    cp = tstr + 2;
		    termc = *cp;
		    break;
		}
		/*FALLTHRU*/
#endif
	    default:
	    {
#ifdef SYSVVARSUB
		/* This can either be a bogus modifier or a System-V
		 * substitution command.  */
		VarPattern      pattern;
		Boolean         eqFound;
		int           	cnt;	/* Used to count brace pairs when 
					 * variable in in parens or braces */
		char		startc;

		if (endc == ')') 
		    startc = '(';
		else
		    startc = '{';

		pattern.flags = 0;
		eqFound = FALSE;
		/* First we make a pass through the string trying
		 * to verify it is a SYSV-make-style translation:
		 * it must be: <string1>=<string2>) */
		cp = tstr;
		cnt = 1;
		while (*cp != '\0' && cnt) {
		    if (*cp == '=') {
			eqFound = TRUE;
			/* continue looking for endc */
		    }
		    else if (*cp == endc)
			cnt--;
		    else if (*cp == startc)
			cnt++;
		    if (cnt)
			cp++;
		}
		if (*cp == endc && eqFound) {

		    /* Now we break this sucker into the lhs and
		     * rhs. We must null terminate them of course.  */
		    for (cp = tstr; *cp != '='; cp++)
			continue;
		    pattern.lhs = tstr;
		    pattern.leftLen = cp - tstr;
		    *cp++ = '\0';

		    pattern.rhs = cp;
		    cnt = 1;
		    while (cnt) {
			if (*cp == endc)
			    cnt--;
			else if (*cp == startc)
			    cnt++;
			if (cnt)
			    cp++;
		    }
		    pattern.rightLen = cp - pattern.rhs;
		    *cp = '\0';

		    /* SYSV modifications happen through the whole
		     * string. Note the pattern is anchored at the end.  */
		    newStr = VarModify(str, VarSYSVMatch, &pattern);

		    /* Restore the nulled characters */
		    pattern.lhs[pattern.leftLen] = '=';
		    pattern.rhs[pattern.rightLen] = endc;
		    termc = endc;
		} else
#endif
		{
		    Error ("Unknown modifier '%c'\n", *tstr);
		    for (cp = tstr+1;
			 *cp != ':' && *cp != endc && *cp != '\0';)
			 cp++;
		    termc = *cp;
		    newStr = var_Error;
		}
	    }
	}
	if (DEBUG(VAR))
	    printf("Result is \"%s\"\n", newStr);

	if (*freePtr)
	    free(str);
	str = newStr;
	if (str != var_Error)
	    *freePtr = TRUE;
	else
	    *freePtr = FALSE;
	if (termc == '\0')
	    Error("Unclosed variable specification");
	else if (termc == ':')
	    *cp++ = termc;
	else
	    *cp = termc;
	tstr = cp;
    }
    *lengthPtr += tstr - start+1;
    return str;

cleanup:
    *lengthPtr += cp - start +1;
    if (*freePtr)
	free(str);
    Error("Unclosed substitution for (%c missing)", delim);
    return var_Error;
}

a1176 43
}

/*-
 *-----------------------------------------------------------------------
 * Var_GetTail --
 *	Return the tail from each of a list of words. Used to set the
 *	System V local variables.
 *
 * Results:
 *	The resulting string.
 *
 * Side Effects:
 *	None.
 *
 *-----------------------------------------------------------------------
 */
char *
Var_GetTail(file)
    char    	*file;	    /* Filename to modify */
{
    return VarModify(file, VarTail, NULL);
}

/*-
 *-----------------------------------------------------------------------
 * Var_GetHead --
 *	Find the leading components of a (list of) filename(s).
 *	XXX: VarHead does not replace foo by ., as (sun) System V make
 *	does.
 *
 * Results:
 *	The leading components.
 *
 * Side Effects:
 *	None.
 *
 *-----------------------------------------------------------------------
 */
char *
Var_GetHead(file)
    char    	*file;	    /* Filename to manipulate */
{
    return VarModify(file, VarHead, NULL);
@


1.41
log
@This does replace Str_Match with a better routine, which handles negated
intervals, and \\ in intervals.

Accordingly, var.c no longer needs to copy the :Marg to replace \: with :

We don't use fnmatch(3) because of various optimizations which are harder
to achieve in a generic setting.

Also add regression suite for the Str_Match function.
@
text
@d1 1
a1 1
/*	$OpenBSD: var.c,v 1.40 2000/07/17 22:57:37 espie Exp $	*/
d73 1
a73 1
static char rcsid[] = "$OpenBSD: var.c,v 1.40 2000/07/17 22:57:37 espie Exp $";
d245 2
d537 1
d543 5
a547 1
	if ((env = getenv(name)) != NULL)
d1634 1
a1634 1
    register char   *tstr;    	/* Pointer into str */
a1635 2
    char	    *cp;	/* Secondary pointer into str (place marker
				 * for tstr) */
d1637 1
a1637 1
    register char   endc;    	/* Ending character when variable in parens
a1638 4
    register char   startc=0;	/* Starting character when variable in parens
				 * or braces */
    int             cnt;	/* Used to count brace pairs when variable in
				 * in parens or braces */
a1639 1
    char    	     delim;
d1671 1
a1671 1
			return("$(.TARGET)");
d1673 1
a1673 1
			return("$(.ARCHIVE)");
d1675 1
a1675 1
			return("$(.PREFIX)");
d1677 1
a1677 1
			return("$(.MEMBER)");
d1680 2
a1681 4
	    /*
	     * Error
	     */
	    return (err ? var_Error : varNoError);
d1688 1
a1688 2
	startc = str[1];
	endc = startc == '(' ? ')' : '}';
d1690 4
a1693 10
	/*
	 * Skip to the end character or a colon, whichever comes first.
	 */
	for (tstr = str + 2;
	     *tstr != '\0' && *tstr != endc && *tstr != ':';
	     tstr++)
	{
	    continue;
	}
	if (*tstr == ':') {
d1695 1
a1695 1
	} else if (*tstr != '\0') {
d1697 1
a1697 1
	} else {
d1704 1
a1704 1
	    return (var_Error);
a1705 1
	*tstr = '\0';
d1716 1
a1716 1
	    switch(str[2]) {
d1730 1
a1730 2
			/*
			 * No need for nested expansion or anything, as we're
d1732 1
a1732 2
			 * but nested invocations in them...
			 */
d1735 6
a1740 9
			if (str[3] == 'D') {
			    val = VarModify(val, VarHead, NULL);
			} else {
			    val = VarModify(val, VarTail, NULL);
			}
			/*
			 * Resulting string is dynamically allocated, so
			 * tell caller to free it.
			 */
d1744 1
a1744 1
			return(val);
d1753 2
a1754 2
		 ((tstr-str == 4 && (str[3] == 'F' ||
					 str[3] == 'D')))) &&
d1757 1
a1757 2
		/*
		 * If substituting a local variable in a non-local context,
d1763 1
a1763 2
		 * when dynamic sources are expanded.
		 */
d1772 1
a1772 1
	    } else if (((tstr-str) > 4) && (str[2] == '.') &&
d1782 1
a1782 2
		    (strncmp(str+2, ".MEMBER", len) == 0))
		{
d1788 2
a1789 4
		/*
		 * No modifiers -- have specification length so we can return
		 * now.
		 */
d1793 4
a1796 3
		    str = emalloc(*lengthPtr + 1);
		    strncpy(str, start, *lengthPtr);
		    str[*lengthPtr] = '\0';
d1798 3
a1800 4
		    return(str);
		} else {
		    return (err ? var_Error : varNoError);
		}
d1802 2
a1803 4
		/*
		 * Still need to get to the end of the variable specification,
		 * so kludge up a Var structure for the modifications
		 */
d1810 1
a1810 1
    if (v->flags & VAR_IN_USE) {
d1813 1
a1813 1
    } else {
d1815 1
a1815 3
    }
    /*
     * Before doing any modification, we have to make sure the value
d1821 1
a1821 2
     * return.
     */
d1823 1
a1823 1
    if (strchr (str, '$') != (char *)NULL) {
d1830 41
d1890 39
a1928 8
    if ((str != (char *)NULL) && haveModifier) {
	/*
	 * Skip initial colon while putting it back.
	 */
	*tstr++ = ':';
	while (*tstr != endc) {
	    char	*newStr;    /* New value to return */
	    char	termc;	    /* Character which terminated scan */
d1930 20
a1949 13
	    if (DEBUG(VAR)) {
		printf("Applying :%c to \"%s\"\n", *tstr, str);
	    }
	    switch (*tstr) {
		case 'N':
		case 'M':
		{
		    for (cp = tstr + 1;
			 *cp != '\0' && *cp != ':' && *cp != endc;
			 cp++) {
			if (*cp == '\\' && (cp[1] == ':' || cp[1] == endc)){
			    cp++;
			}
a1950 6
		    termc = *cp;
		    *cp = '\0';
		    if (*tstr == 'M')
			newStr = VarModify(str, VarMatch, tstr+1);
		    else
			newStr = VarModify(str, VarNoMatch, tstr+1);
a1952 3
		case 'S':
		{
		    VarPattern 	    pattern;
d1954 24
a1977 3
		    pattern.flags = 0;
		    delim = tstr[1];
		    tstr += 2;
d1979 14
a1992 7
		    /*
		     * If pattern begins with '^', it is anchored to the
		     * start of the word -- skip over it and flag pattern.
		     */
		    if (*tstr == '^') {
			pattern.flags |= VAR_MATCH_START;
			tstr += 1;
d1994 2
d1997 1
a1997 8
		    cp = tstr;
		    if ((pattern.lhs = VarGetPattern(ctxt, err, &cp, delim,
			&pattern.flags, &pattern.leftLen, NULL)) == NULL)
			goto cleanup;

		    if ((pattern.rhs = VarGetPattern(ctxt, err, &cp, delim,
			NULL, &pattern.rightLen, &pattern)) == NULL)
			goto cleanup;
d1999 8
a2006 16
		    /*
		     * Check for global substitution. If 'g' after the final
		     * delimiter, substitution is global and is marked that
		     * way.
		     */
		    for (;; cp++) {
			switch (*cp) {
			case 'g':
			    pattern.flags |= VAR_SUB_GLOBAL;
			    continue;
			case '1':
			    pattern.flags |= VAR_SUB_ONE;
			    continue;
			}
			break;
		    }
d2008 58
a2066 7
		    newStr = VarModify(str, VarSubstitute, &pattern);

		    /*
		     * Free the two strings.
		     */
		    free(pattern.lhs);
		    free(pattern.rhs);
d2069 5
a2073 35
#ifndef MAKE_BOOTSTRAP
		case 'C':
		{
		    VarREPattern    pattern;
		    char           *re;
		    int             error;

		    pattern.flags = 0;
		    delim = tstr[1];
		    tstr += 2;

		    cp = tstr;

		    if ((re = VarGetPattern(ctxt, err, &cp, delim, NULL,
			NULL, NULL)) == NULL)
			goto cleanup;

		    if ((pattern.replace = VarGetPattern(ctxt, err, &cp,
			delim, NULL, NULL, NULL)) == NULL) {
			free(re);
			goto cleanup;
		    }

		    for (;; cp++) {
			switch (*cp) {
			case 'g':
			    pattern.flags |= VAR_SUB_GLOBAL;
			    continue;
			case '1':
			    pattern.flags |= VAR_SUB_ONE;
			    continue;
			}
			break;
		    }

a2074 21

		    error = regcomp(&pattern.re, re, REG_EXTENDED);
		    free(re);
		    if (error) {
			*lengthPtr = cp - start + 1;
			VarREError(error, &pattern.re, "RE substitution error");
			free(pattern.replace);
			return (var_Error);
		    }

		    pattern.nsub = pattern.re.re_nsub + 1;
		    if (pattern.nsub < 1)
			pattern.nsub = 1;
		    if (pattern.nsub > 10)
			pattern.nsub = 10;
		    pattern.matches = emalloc(pattern.nsub *
					      sizeof(regmatch_t));
		    newStr = VarModify(str, VarRESubstitute, &pattern);
		    regfree(&pattern.re);
		    free(pattern.replace);
		    free(pattern.matches);
d2077 1
a2077 57
#endif
		case 'Q':
		    if (tstr[1] == endc || tstr[1] == ':') {
			newStr = VarQuote (str);
			cp = tstr + 1;
			termc = *cp;
			break;
		    }
		    /*FALLTHRU*/
		case 'T':
		    if (tstr[1] == endc || tstr[1] == ':') {
			newStr = VarModify(str, VarTail, NULL);
			cp = tstr + 1;
			termc = *cp;
			break;
		    }
		    /*FALLTHRU*/
		case 'H':
		    if (tstr[1] == endc || tstr[1] == ':') {
			newStr = VarModify(str, VarHead, NULL);
			cp = tstr + 1;
			termc = *cp;
			break;
		    }
		    /*FALLTHRU*/
		case 'E':
		    if (tstr[1] == endc || tstr[1] == ':') {
			newStr = VarModify(str, VarSuffix, NULL);
			cp = tstr + 1;
			termc = *cp;
			break;
		    }
		    /*FALLTHRU*/
		case 'R':
		    if (tstr[1] == endc || tstr[1] == ':') {
			newStr = VarModify(str, VarRoot, NULL);
			cp = tstr + 1;
			termc = *cp;
			break;
		    }
		    /*FALLTHRU*/
		case 'U':
		    if (tstr[1] == endc || tstr[1] == ':') {
			newStr = VarModify(str, VarUppercase, NULL);
			cp = tstr + 1;
			termc = *cp;
			break;
		    }
		    /*FALLTHRU*/
		case 'L':
		    if (tstr[1] == endc || tstr[1] == ':') {
			newStr = VarModify(str, VarLowercase, NULL);
			cp = tstr + 1;
			termc = *cp;
			break;
		    }
		    /*FALLTHRU*/
d2079 11
a2089 11
		case 's':
		    if (tstr[1] == 'h' && (tstr[2] == endc || tstr[2] == ':')) {
			char *err;
			newStr = Cmd_Exec (str, &err);
			if (err)
			    Error (err, str);
			cp = tstr + 2;
			termc = *cp;
			break;
		    }
		    /*FALLTHRU*/
d2091 2
a2092 2
		default:
		{
d2094 41
a2134 6
		    /*
		     * This can either be a bogus modifier or a System-V
		     * substitution command.
		     */
		    VarPattern      pattern;
		    Boolean         eqFound;
d2136 1
a2136 8
		    pattern.flags = 0;
		    eqFound = FALSE;
		    /*
		     * First we make a pass through the string trying
		     * to verify it is a SYSV-make-style translation:
		     * it must be: <string1>=<string2>)
		     */
		    cp = tstr;
d2138 2
a2139 6
		    while (*cp != '\0' && cnt) {
			if (*cp == '=') {
			    eqFound = TRUE;
			    /* continue looking for endc */
			}
			else if (*cp == endc)
d2146 2
a2147 30
		    if (*cp == endc && eqFound) {

			/*
			 * Now we break this sucker into the lhs and
			 * rhs. We must null terminate them of course.
			 */
			for (cp = tstr; *cp != '='; cp++)
			    continue;
			pattern.lhs = tstr;
			pattern.leftLen = cp - tstr;
			*cp++ = '\0';

			pattern.rhs = cp;
			cnt = 1;
			while (cnt) {
			    if (*cp == endc)
				cnt--;
			    else if (*cp == startc)
				cnt++;
			    if (cnt)
				cp++;
			}
			pattern.rightLen = cp - pattern.rhs;
			*cp = '\0';

			/*
			 * SYSV modifications happen through the whole
			 * string. Note the pattern is anchored at the end.
			 */
			newStr = VarModify(str, VarSYSVMatch, &pattern);
d2149 9
a2157 7
			/*
			 * Restore the nulled characters
			 */
			pattern.lhs[pattern.leftLen] = '=';
			pattern.rhs[pattern.rightLen] = endc;
			termc = endc;
		    } else
d2159 7
a2165 9
		    {
			Error ("Unknown modifier '%c'\n", *tstr);
			for (cp = tstr+1;
			     *cp != ':' && *cp != endc && *cp != '\0';
			     cp++)
				 continue;
			termc = *cp;
			newStr = var_Error;
		    }
a2167 21
	    if (DEBUG(VAR)) {
		printf("Result is \"%s\"\n", newStr);
	    }

	    if (*freePtr) {
		free (str);
	    }
	    str = newStr;
	    if (str != var_Error) {
		*freePtr = TRUE;
	    } else {
		*freePtr = FALSE;
	    }
	    if (termc == '\0') {
		Error("Unclosed variable specification for %s", v->name);
	    } else if (termc == ':') {
		*cp++ = termc;
	    } else {
		*cp = termc;
	    }
	    tstr = cp;
d2169 2
a2170 5
	*lengthPtr = tstr - start + 1;
    } else {
	*lengthPtr = tstr - start + 1;
	*tstr = endc;
    }
d2172 1
a2172 6
    if (v->flags & VAR_JUNK) {
	/*
	 * Perform any free'ing needed and set *freePtr to FALSE so the caller
	 * doesn't try to free a static pointer.
	 */
	if (*freePtr) {
d2174 2
a2175 8
	}
	*freePtr = FALSE;
	Buf_Destroy(&(v->val));
	free(v);
	if (dynamic) {
	    str = emalloc(*lengthPtr + 1);
	    strncpy(str, start, *lengthPtr);
	    str[*lengthPtr] = '\0';
d2177 9
a2185 3
	} else {
	    str = err ? var_Error : varNoError;
	}
d2187 2
a2188 1
    return (str);
d2191 1
a2191 1
    *lengthPtr = cp - start + 1;
d2194 2
a2195 3
    Error("Unclosed substitution for %s (%c missing)",
	  v->name, delim);
    return (var_Error);
@


1.40
log
@Constify a few functions, propagated from VarModify.
Replace a few int -> size_t

Reviewed by miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: var.c,v 1.39 2000/07/17 22:55:12 espie Exp $	*/
d73 1
a73 1
static char rcsid[] = "$OpenBSD: var.c,v 1.39 2000/07/17 22:55:12 espie Exp $";
a1889 5
		    char    *pattern;
		    char    *cp2;
		    Boolean copy;

		    copy = FALSE;
d1892 1
a1892 2
			 cp++)
		    {
a1893 1
			    copy = TRUE;
d1899 4
a1902 31
		    if (copy) {
			/*
			 * Need to compress the \:'s out of the pattern, so
			 * allocate enough room to hold the uncompressed
			 * pattern (note that cp started at tstr+1, so
			 * cp - tstr takes the null byte into account) and
			 * compress the pattern into the space.
			 */
			pattern = emalloc(cp - tstr);
			for (cp2 = pattern, cp = tstr + 1;
			     *cp != '\0';
			     cp++, cp2++)
			{
			    if ((*cp == '\\') &&
				(cp[1] == ':' || cp[1] == endc)) {
				    cp++;
			    }
			    *cp2 = *cp;
			}
			*cp2 = '\0';
		    } else {
			pattern = &tstr[1];
		    }
		    if (*tstr == 'M' || *tstr == 'm') {
			newStr = VarModify(str, VarMatch, pattern);
		    } else {
			newStr = VarModify(str, VarNoMatch, pattern);
		    }
		    if (copy) {
			free(pattern);
		    }
@


1.39
log
@- recognize that FIND_CMD and FIND_GLOBAL are always used together,
- introduce VarFind_interval function. This avoids having to copy variable
names in VarParse,
- expose internals of VarFind* function (not used yet, but this will avoid
multiple lookups in VarParse),
- constify a few functions.

Reviewed by miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: var.c,v 1.38 2000/06/23 16:27:29 espie Exp $	*/
d73 1
a73 1
static char rcsid[] = "$OpenBSD: var.c,v 1.38 2000/06/23 16:27:29 espie Exp $";
d227 5
a231 5
static Boolean VarHead __P((char *, Boolean, Buffer, void *));
static Boolean VarTail __P((char *, Boolean, Buffer, void *));
static Boolean VarSuffix __P((char *, Boolean, Buffer, void *));
static Boolean VarRoot __P((char *, Boolean, Buffer, void *));
static Boolean VarMatch __P((char *, Boolean, Buffer, void *));
d233 1
a233 1
static Boolean VarSYSVMatch __P((char *, Boolean, Buffer, void *));
d235 1
a235 1
static Boolean VarNoMatch __P((char *, Boolean, Buffer, void *));
d238 1
a238 1
static Boolean VarRESubstitute __P((char *, Boolean, Buffer, void *));
d240 1
a240 1
static Boolean VarSubstitute __P((char *, Boolean, Buffer, void *));
d243 2
a244 2
static char *VarQuote __P((char *));
static char *VarModify __P((char *, Boolean (*)(char *, Boolean, Buffer, void *), void *));
d246 2
a247 2
static Boolean VarUppercase __P((char *, Boolean, Buffer, void *));
static Boolean VarLowercase __P((char *, Boolean, Buffer, void *));
d813 2
a814 2
VarUppercase (word, addSpace, buf, dummy)
    char    	  *word;    	/* Word to Upper Case */
d826 1
a826 1
    return (TRUE);
d844 2
a845 2
VarLowercase (word, addSpace, buf, dummy)
    char    	  *word;    	/* Word to Lower Case */
d857 1
a857 1
    return (TRUE);
d877 1
a877 1
    char    	  *word;    	/* Word to trim */
d883 1
a883 1
    register char *slash;
d890 1
a890 1
	return (TRUE);
d918 1
a918 1
    char    	  *word;    	/* Word to trim */
d924 1
a924 1
    register char *slash;
d952 1
a952 1
    char    	  *word;    	/* Word to trim */
d958 1
a958 1
    char *dot;
d987 1
a987 1
    char    	  *word;    	/* Word to trim */
d993 1
a993 1
    char *dot;
d1023 1
a1023 1
    char    	  *word;    	/* Word to examine */
d1036 1
a1036 1
    return(addSpace);
d1058 1
a1058 1
    char    	  *word;    	/* Word to examine */
d1065 2
a1066 2
    int len;
    char *ptr;
d1080 1
a1080 1
    return(addSpace);
d1102 1
a1102 1
    char    	  *word;    	/* Word to examine */
d1135 1
a1135 1
    char    	  	*word;	    /* Word to modify */
d1141 2
a1142 2
    register size_t  	wordLen;    /* Length of word */
    register char 	*cp;	    /* General pointer */
d1328 1
a1328 1
    char *word;
d1335 1
a1335 1
    char *wp;
d1372 1
a1372 1
		char *subbuf;
a1441 3
 * Side Effects:
 *	None.
 *
d1446 1
a1446 1
    char    	  *str;	    	    /* String whose words should be trimmed */
d1448 1
a1448 1
    Boolean    	  (*modProc) __P((char *, Boolean, Buffer, void *));
d1455 2
a1456 2
    char **av;			    /* word list */
    char *as;			    /* word list memory */
a1578 3
 * Side Effects:
 *	None.
 *
d1583 1
a1583 1
	char *str;
@


1.38
log
@This is the speed-up patch, which doubles make speed (almost).

Use the open hashing functions for global contexts instead of List in
var.c.

All the preliminary work to trim down local contexts means that we don't
suffer from the heavy initialization work that a hash table entails.

There is some make kludgery to:
- build the hashing functions as a library,
- recreate hashconsts.h, even if make depend was not invoked.

One point of the hashing scheme written was to separate the computation
of the hash function, and the hash lookup itself. This is very convenient
for make, because of those pesky special variables. hashconsts.h is there
to pre-hash the correct values, which replaces a few expensive string
comparisons with quick hash value comparisons, followed by one expensive
string comparison. The modulus MAGICSLOTS chosen in the Makefile is
ad-hoc: it is small enough to write a small switch without collision,
and will need changing if the hash function changes...

The function quick_lookup is the most important:
it either returns an index, for a local variable, or it does compute a
hashing value, and returns -1.

Another somewhat controversial decision is the use of string intervals.
This avoids either copying a string, or twiddling with a byte for cases
such as ${VAR}.

Finally, the variable name is stored within the variable itself. Since
a given variable name never changes, this makes sense. All that was needed
was a hash library with support for this.  Note that the hashing table
holds only a variable pointer AND the corresponding hashing value, WITHOUT
a modulo hashtablesize. Two reasons:
- hash resizes can be done faster, without having to recompute hashing values.
- locality of access. The hash table fits into memory without problem. Once
a candidate slot is found, we check the complete hashing value. Probability
of a collision is very small (32 bits...). So bringing up the whole
variable in memory at once is good: the name will almost always match, in
which case we want the variable value as well, so it makes sense to put
them together.

The ohash functions implement open hashing, as described in Knuth, but with
a variable table size.  Choosing powers of 2 sizes does not yield more
collisions, but it makes the hashing scheme much simpler. The thresholds at
which to expand/shrink the tables seem to work well in practice. The
default sizes were chosen such that the tables hardly ever shrink or expand
anyways (though I've tried with smaller/larger sizes to verify that the
shrinking/expanding worked correctly): larger Makefiles hold roughly
500/600 variables, which fits without trouble into a 1024-sized variable.

Disregard #ifdef STATS_HASH, this is some internal scaffolding I'm using
to measure make performance.

The only known issue with open-hashing is that deletions cannot create
empty slots, but do leave slots marked as `occupied once' so that lookup
works.  We use a well-known optimization which records those pseudo-empty
slots while looking up values. If the value is not found, the pseudo-empty
slot is returned to be filled. If the value is found, it is swapped with
the pseudo-empty slot. This is an improvement in both cases, since this
shortens the length of lookup chains, eventually pushing the pseudo-empty
slots to the end.

Reviewed by millert@@ and miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: var.c,v 1.37 2000/06/23 16:23:26 espie Exp $	*/
d73 1
a73 1
static char rcsid[] = "$OpenBSD: var.c,v 1.37 2000/06/23 16:23:26 espie Exp $";
d176 2
a177 3
#define FIND_CMD	0x1   /* look in VAR_CMD when searching */
#define FIND_GLOBAL	0x2   /* look in VAR_GLOBAL as well */
#define FIND_ENV  	0x4   /* look in the environment also */
d222 4
a225 2
static Var *VarFind __P((char *, SymTable *, int));
static Var *VarAdd __P((char *, char *, GSymT *));
d249 2
a250 2
static Var *new_var __P((char *, char *));
static Var *getvar __P((GSymT *, char *, const char *, u_int32_t));
d434 2
a435 2
    char *name;
    char *val;
d455 1
a455 1
    char 	*name;
d464 1
a464 1
 * VarFind --
d466 2
a467 1
 *	indicated.
d478 3
a480 2
VarFind(name, ctxt, flags)
    char           	*name;	/* name to find */
d482 2
a483 4
    int             	flags;	/* FIND_GLOBAL set means to look in the
				 * VAR_GLOBAL context as well.
				 * FIND_CMD set means to look in the VAR_CMD
				 * context also.
d485 1
a485 1
				 * environment/VAR_ENV context.  */
a486 2
    Var		  	*v;
    const char		*end = NULL;
d491 13
d523 1
a523 1
    if ((flags & FIND_CMD) && ctxt != CTXT_CMD)
d528 1
a528 1
    if (!checkEnvFirst && (flags & FIND_GLOBAL) && ctxt != CTXT_GLOBAL)
d544 1
a544 1
    if (checkEnvFirst && (flags & FIND_GLOBAL) && ctxt != CTXT_GLOBAL) 
d565 2
a566 2
    char	*name;	/* name of variable to add */
    char	*val;	/* value to set it to */
d764 1
a764 1
    v = VarFind(name, (SymTable *)ctxt, FIND_CMD|FIND_GLOBAL|FIND_ENV);
d791 1
a791 1
    v = VarFind(name, (SymTable *)ctxt, FIND_ENV | FIND_GLOBAL | FIND_CMD);
d1661 1
a1661 6
	char	  name[2];

	name[0] = str[1];
	name[1] = '\0';

	v = VarFind (name, ctxt, FIND_ENV | FIND_GLOBAL | FIND_CMD);
d1723 1
a1723 1
	v = VarFind (str + 2, ctxt, FIND_ENV | FIND_GLOBAL | FIND_CMD);
a1739 1
		    char    vname[2];
d1742 2
a1743 6
		    /*
		     * Well, it's local -- go look for it.
		     */
		    vname[0] = str[2];
		    vname[1] = '\0';
		    v = VarFind(vname, ctxt, 0);
@


1.37
log
@This patch separates local contexts from global contexts for good.
Apart from a few casts, VAR_GLOBAL and friends are separate
data structures, so we use a small array for local variables.

We also junk allVars, since TargFreeGN can release local nodes,
and var.c has explicit lists for its variables already.

Reviewed millert@@ and miod@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: var.c,v 1.36 2000/06/23 16:21:44 espie Exp $	*/
d73 1
a73 1
static char rcsid[] = "$OpenBSD: var.c,v 1.36 2000/06/23 16:21:44 espie Exp $";
d128 2
a132 1
/* `Quick' index variants.  */
a180 1
    char          *name;	/* the variable's name */
d189 1
d217 4
d247 1
a247 1
static char *context_name __P((GSymT *));
d249 1
a249 1
static Var *getvar __P((Lst, char *));
d270 81
d358 3
d418 1
a418 1
static char *
d437 1
d439 1
a439 3
    v = (Var *)emalloc(sizeof(Var));

    v->name = estrdup(name);
d451 6
a456 10
/*-
 *-----------------------------------------------------------------------
 * VarCmp  --
 *	See if the given variable matches the named one. Used by getvar.
 *-----------------------------------------------------------------------
 */
static int
VarCmp(v, name)
    void *v;		/* VAR structure to compare */
    void *name;		/* name to look for */
d458 1
a458 15
    return strcmp((char *)name, ((Var *)v)->name);
}

static Var *
getvar(l, n)
    Lst 	l;
    char 	*n;
{
    LstNode ln;

    ln = Lst_Find(l, VarCmp, n);
    if (ln != NULL)
    	return (Var *)Lst_Datum(ln);
    else
    	return NULL;
d487 5
a492 35
	/*
	 * If the variable name begins with a '.', it could very well be one of
	 * the local ones.  We check the name against all the local variables
	 * and substitute the short version in for 'name' if it matches one of
	 * them.
	 */
	if (*name == '.' && isupper((unsigned char) name[1]))
		switch (name[1]) {
		case 'A':
			if (!strcmp(name, ".ALLSRC"))
				name = ALLSRC;
			if (!strcmp(name, ".ARCHIVE"))
				name = ARCHIVE;
			break;
		case 'I':
			if (!strcmp(name, ".IMPSRC"))
				name = IMPSRC;
			break;
		case 'M':
			if (!strcmp(name, ".MEMBER"))
				name = MEMBER;
			break;
		case 'O':
			if (!strcmp(name, ".OODATE"))
				name = OODATE;
			break;
		case 'P':
			if (!strcmp(name, ".PREFIX"))
				name = PREFIX;
			break;
		case 'T':
			if (!strcmp(name, ".TARGET"))
				name = TARGET;
			break;
		}
d501 1
a501 1
	v = getvar((Lst)ctxt, name);
d503 4
a506 27
    	v = NULL;
    	if (name[1] == '\0')
	    switch(name[0]) {
	    	case '@@':
		    v = ctxt->locals[TARGET_INDEX];
		    break;
		case '?':
		    v = ctxt->locals[OODATE_INDEX];
		    break;
		case '>':
		    v = ctxt->locals[ALLSRC_INDEX];
		    break;
		case '<':
		    v = ctxt->locals[IMPSRC_INDEX];
		    break;
		case '*':
		    v = ctxt->locals[PREFIX_INDEX];
		    break;
		case '!':
		    v = ctxt->locals[ARCHIVE_INDEX];
		    break;
		case '%':
		    v = ctxt->locals[MEMBER_INDEX];
		    break;
		default:
		    break;
		}
d512 1
a512 1
	v = getvar(VAR_CMD, name);
d517 1
a517 1
	v = getvar(VAR_GLOBAL, name);
d524 1
a524 1
    	v = getvar(VAR_ENV, name);
d533 1
a533 1
	v = getvar(VAR_GLOBAL, name);
d557 4
a560 1
    Var   *v;
d566 7
a572 1
    Lst_AtFront(ctxt, v);
a593 1
    free(v->name);
d618 3
a620 1
    LstNode 	  ln;
d624 2
d627 1
a627 6
    ln = Lst_Find(ctxt, VarCmp, name);
    if (ln != NULL) {
	register Var 	  *v;

	v = (Var *)Lst_Datum(ln);
	Lst_Remove(ctxt, ln);
a628 1
    }
d666 1
a666 1
    if (v == NULL) {
d668 1
a668 1
    } else {
d2497 3
a2499 3
    Lst_Init(VAR_GLOBAL);
    Lst_Init(VAR_CMD);
    Lst_Init(VAR_ENV);
d2510 12
a2521 3
    Lst_Destroy(VAR_GLOBAL, VarDelete);
    Lst_Destroy(VAR_CMD, VarDelete);
    Lst_Destroy(VAR_END, VarDelete);
d2546 6
a2551 1
    Lst_Every(ctxt, VarPrintVar);
@


1.36
log
@In various places, VAR_CMD is used to actually mean `no real context',
since lookup will start with VAR_CMD in any case.
This fixes VarFind and Var_Parse to handle ctxt == NULL correctly, and
replace those confusing VAR_CMD with proper NULL pointers.

This patch also handles three small details:
- .CURDIR is necessarily set in VAR_GLOBAL,
- suffix handling for archives copies two hard-coded variables, for
which it can use a quick path,
- typos in TargFreeGN.

Reviewed millert@@, miod@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: var.c,v 1.35 2000/06/23 16:20:01 espie Exp $	*/
d73 1
a73 1
static char rcsid[] = "$OpenBSD: var.c,v 1.35 2000/06/23 16:20:01 espie Exp $";
d129 3
a131 3
/* `Quick' index variants.  For now, these are stubs which call the `real'
 * slow function.
 */
a140 34
void 
Varq_Set(idx, val, gn)
    int 	idx;
    char 	*val;
    GNode 	*gn;
{
    Var_Set(varnames[idx], val, &gn->context);
}

void 
Varq_Append(idx, val, gn)
    int		idx;
    char	*val;
    GNode	*gn;
{
    Var_Append(varnames[idx], val, &gn->context);
}

char *
Varq_Value(idx, gn)
    int		idx;
    GNode	*gn;
{
    return Var_Value(varnames[idx], &gn->context);
}

Boolean
Varq_Exists(idx, gn)
    int		idx;
    GNode	*gn;
{
    return Var_Exists(varnames[idx], &gn->context);
}

d171 3
a173 5
SymTable	*VAR_GLOBAL;	/* variables from the makefile */
SymTable	*VAR_CMD;	/* variables defined on the command-line */
static SymTable	*VAR_ENV;	/* variables read from env */

static LIST	allVars;      /* List of all variables */
d179 1
a179 1
typedef struct Var {
d219 1
a219 1
static Var *VarAdd __P((char *, char *, SymTable *));
d240 87
a326 3
static Boolean VarUppercase __P((char *word, Boolean addSpace, Buffer buf, void *dummy));
static Boolean VarLowercase __P((char *word, Boolean addSpace, Buffer buf, void *dummy));
static char *context_name __P((SymTable *));
d331 1
a331 1
    SymTable *ctxt;
a332 4
    GNode *g;

    /* specific handling for GLOBAL, CMD, ENV contexts, which are not
       owned by a GNode */
d335 1
a335 1
    if (ctxt == VAR_CMD)
d337 1
a337 1
    if (ctxt == VAR_ENV)
a338 2
    g = (GNode *)((char *)ctxt - offsetof(GNode, context));
    return g->name;
d341 22
d366 1
a366 8
 *	See if the given variable matches the named one. Called from
 *	Lst_Find when searching for a variable of a given name.
 *
 * Results:
 *	0 if they match. non-zero otherwise.
 *
 * Side Effects:
 *	none
d377 14
a415 1
    LstNode         	var;
d458 52
a509 4
    if (ctxt != NULL)
	var = Lst_Find(ctxt, VarCmp, name);
    else
    	var = NULL;
d511 3
a513 10
    if ((var == NULL) && (flags & FIND_CMD) && (ctxt != VAR_CMD))
	var = Lst_Find(VAR_CMD, VarCmp, name);
    if (!checkEnvFirst && (var == NULL) && (flags & FIND_GLOBAL) &&
	(ctxt != VAR_GLOBAL)) {
	var = Lst_Find(VAR_GLOBAL, VarCmp, name);
    }
    if ((var == NULL) && (flags & FIND_ENV)) {
    	var = Lst_Find(VAR_ENV, VarCmp, name);
	if (var == NULL) {
	    char *env;
d515 3
a517 11
	    if ((env = getenv(name)) != NULL)
	    	return VarAdd(name, env, VAR_ENV);
	}
    }
    if (var == NULL && checkEnvFirst && (flags & FIND_GLOBAL) &&
		   (ctxt != VAR_GLOBAL)) 
	    var = Lst_Find(VAR_GLOBAL, VarCmp, name);
    if (var == NULL)
	return NULL;
    else 
	return (Var *)Lst_Datum(var);
d536 3
a538 3
    char           *name;	/* name of variable to add */
    char           *val;	/* value to set it to */
    SymTable       *ctxt;	/* context in which to set it */
d540 1
a540 2
    register Var   *v;
    int	    	  len;
d542 1
a542 7
    v = (Var *) emalloc(sizeof(Var));

    v->name = estrdup(name);

    len = val ? strlen(val) : 0;
    Buf_Init(&(v->val), len+1);
    Buf_AddChars(&(v->val), len, val);
a546 4
    Lst_AtEnd(&allVars, v);
    if (DEBUG(VAR)) {
	printf("%s:%s = %s\n", context_name(ctxt), name, val);
    }
d591 1
a591 1
    SymTable	  *ctxt;
d595 1
a595 1
    if (DEBUG(VAR)) {
d597 1
a597 1
    }
a603 2
	ln = Lst_Member(&allVars, v);
	Lst_Remove(&allVars, ln);
d631 3
a633 3
    char           *name;	/* name of variable to set */
    char           *val;	/* value to give to the variable */
    SymTable       *ctxt;	/* context in which to set it */
d642 1
a642 1
    v = VarFind(name, ctxt, 0);
a648 3
	if (DEBUG(VAR)) {
	    printf("%s:%s = %s\n", context_name(ctxt), name, val);
	}
d650 2
d689 3
a691 3
    char           *name;	/* Name of variable to modify */
    char           *val;	/* String to append to it */
    SymTable       *ctxt;	/* Context in which this should occur */
d695 1
a695 1
    v = VarFind(name, ctxt, (ctxt == VAR_GLOBAL) ? FIND_ENV : 0);
a702 3
	if (DEBUG(VAR)) {
	    printf("%s:%s = %s\n", context_name(ctxt), name, VarValue(v));
	}
d705 2
d724 2
a725 2
    char	  *name;    	/* Variable to find */
    SymTable	  *ctxt;    	/* Context in which to start search */
d729 1
a729 1
    v = VarFind(name, ctxt, FIND_CMD|FIND_GLOBAL|FIND_ENV);
d751 2
a752 2
    char           *name;	/* name to find */
    SymTable       *ctxt;	/* context in which to search for it */
d756 1
a756 1
    v = VarFind(name, ctxt, FIND_ENV | FIND_GLOBAL | FIND_CMD);
d1635 1
a1635 1
	    if (ctxt == VAR_CMD || ctxt == VAR_GLOBAL || ctxt == NULL) {
d1694 1
a1694 1
	if (v == NULL && ctxt != VAR_CMD && ctxt != VAR_GLOBAL &&
d1751 1
a1751 1
		(ctxt == VAR_CMD || ctxt == VAR_GLOBAL || ctxt == NULL))
d1772 1
a1772 1
		       (ctxt == VAR_CMD || ctxt == VAR_GLOBAL || ctxt == NULL))
d1807 1
a1807 3
		v = (Var *) emalloc(sizeof(Var));
		v->name = &str[1];
		Buf_Init(&(v->val), 1);
d2345 1
a2345 1
    SymTable	*ctxt;		/* The context wherein to find variables */
d2401 1
a2401 1
	val = Var_Parse(str, ctxt, FALSE, &length, &doFree);
d2469 1
a2469 1
    static SymTable global_vars, cmd_vars, env_vars;
d2477 3
a2479 2
    Lst_Init(&allVars);

d2486 5
a2490 1
    Lst_Destroy(&allVars, VarDelete);
d2512 1
a2512 1
    SymTable          *ctxt;
d2516 1
@


1.35
log
@Once those special variable are taken care of, other Var functions can take
the GNode's context directly.  We rename that special Lst to `SymTable *'
in prevision of things to come.

Along the line, we lose the special GNodes affected to VAR_CMD, VAR_GLOBAL,
VAR_ENV, which become simple Lsts... This is not a problem, except when
getting to a context's name for debugging (handled very nicely by
offsetof).

Again, this is a preparatory patch, which does not gain anything except
for cleaning up issues...

Reviewed by millert@@ and miod@@, like the previous patch
@
text
@d1 1
a1 1
/*	$OpenBSD: var.c,v 1.34 2000/06/23 16:18:09 espie Exp $	*/
d73 1
a73 1
static char rcsid[] = "$OpenBSD: var.c,v 1.34 2000/06/23 16:18:09 espie Exp $";
d388 4
a391 1
    var = Lst_Find(ctxt, VarCmp, name);
d1547 1
a1547 1
	    if ((ctxt == VAR_CMD) || (ctxt == VAR_GLOBAL)) {
d1606 3
a1608 2
	if ((v == NULL) && (ctxt != VAR_CMD) && (ctxt != VAR_GLOBAL) &&
	    ((tstr-str) == 4) && (str[3] == 'F' || str[3] == 'D'))
d1660 2
a1661 2
	    if ((((tstr-str) == 3) ||
		 ((((tstr-str) == 4) && (str[3] == 'F' ||
d1663 1
a1663 1
		((ctxt == VAR_CMD) || (ctxt == VAR_GLOBAL)))
d1684 1
a1684 1
		       ((ctxt == VAR_CMD) || (ctxt == VAR_GLOBAL)))
@


1.34
log
@Start of variable fixes and speed-ups.

This patch may seem a bit non-sensical at first. It simply introduces some
new interface. Specifically, recognizes that some variable names
(.TARGET/$@@, .OODATE/$?, .ALLSRC/$>, .IMPSRC/$<, .PREFIX/$*, .ARCHIVE/$!,
.MEMBER/$%) are `special' (the actual variables which are local to a
target, e.g. GNode).

Currently, The Varq functions (for Varquick access) are only stubs to the
normal functions.

This fixes a very important detail before proceeding to turn variable lists
into hash tables: if every GNode holds a hash table, initialization times
for those will be very costly. But generic GNodes only hold those seven
special variables... which can be stored directly into a small array;
the only general cases are the environment, the command line and
global variables.
@
text
@d1 1
a1 1
/*	$OpenBSD: var.c,v 1.33 2000/06/17 14:38:20 espie Exp $	*/
d73 1
a73 1
static char rcsid[] = "$OpenBSD: var.c,v 1.33 2000/06/17 14:38:20 espie Exp $";
d125 1
d147 1
a147 1
    Var_Set(varnames[idx], val, gn);
d156 1
a156 1
    Var_Append(varnames[idx], val, gn);
d164 1
a164 1
    return Var_Value(varnames[idx], gn);
d172 1
a172 1
    return Var_Exists(varnames[idx], gn);
d205 3
a207 3
GNode		*VAR_GLOBAL;	/* variables from the makefile */
GNode		*VAR_CMD;	/* variables defined on the command-line */
static GNode	*VAR_ENV;	/* variables read from env */
d254 2
a255 2
static Var *VarFind __P((char *, GNode *, int));
static Var *VarAdd __P((char *, char *, GNode *));
d271 1
a271 1
static char *VarGetPattern __P((GNode *, int, char **, int, int *, size_t *,
d278 1
d280 19
d335 1
a335 1
VarFind (name, ctxt, flags)
d337 1
a337 1
    GNode          	*ctxt;	/* context in which to find it */
d388 1
a388 1
    var = Lst_Find(&ctxt->context, VarCmp, name);
d391 1
a391 1
	var = Lst_Find(&VAR_CMD->context, VarCmp, name);
d394 1
a394 1
	var = Lst_Find(&VAR_GLOBAL->context, VarCmp, name);
d397 1
a397 1
    	var = Lst_Find(&VAR_ENV->context, VarCmp, name);
d407 1
a407 1
	    var = Lst_Find(&VAR_GLOBAL->context, VarCmp, name);
d432 1
a432 1
    GNode          *ctxt;	/* context in which to set it */
d437 1
a437 1
    v = (Var *) emalloc (sizeof (Var));
d439 1
a439 1
    v->name = estrdup (name);
d447 1
a447 1
    Lst_AtFront(&ctxt->context, v);
d450 1
a450 1
	printf("%s:%s = %s\n", ctxt->name, name, val);
d496 1
a496 1
    GNode	  *ctxt;
d501 1
a501 1
	printf("%s:delete %s\n", ctxt->name, name);
d503 1
a503 1
    ln = Lst_Find(&ctxt->context, VarCmp, name);
d508 1
a508 1
	Lst_Remove(&ctxt->context, ln);
d537 1
a537 1
Var_Set (name, val, ctxt)
d540 1
a540 1
    GNode          *ctxt;	/* context in which to set it */
d549 1
a549 1
    v = VarFind (name, ctxt, 0);
d557 1
a557 1
	    printf("%s:%s = %s\n", ctxt->name, name, val);
d596 1
a596 1
Var_Append (name, val, ctxt)
d599 1
a599 1
    GNode          *ctxt;	/* Context in which this should occur */
d603 1
a603 1
    v = VarFind (name, ctxt, (ctxt == VAR_GLOBAL) ? FIND_ENV : 0);
d612 1
a612 1
	    printf("%s:%s = %s\n", ctxt->name, name, VarValue(v));
d634 1
a634 1
    GNode	  *ctxt;    	/* Context in which to start search */
d661 1
a661 1
    GNode          *ctxt;	/* context in which to search for it */
d1372 1
a1372 1
    GNode *ctxt;
d1500 1
a1500 1
Var_Parse (str, ctxt, err, lengthPtr, freePtr)
d1502 1
a1502 1
    GNode   	  *ctxt;    	/* The context for the variable */
d2169 1
a2169 1
    GNode         *ctxt;	    /* the context wherein to find variables */
d2255 1
a2255 1
    GNode	*ctxt;		/* The context wherein to find variables */
d2379 8
a2386 3
    VAR_GLOBAL = Targ_NewGN("Global");
    VAR_CMD = Targ_NewGN("Command");
    VAR_ENV = Targ_NewGN("Environment");
d2416 2
a2417 2
Var_Dump (ctxt)
    GNode          *ctxt;
d2419 1
a2419 1
    Lst_Every(&ctxt->context, VarPrintVar);
@


1.33
log
@This patch introduces a distinction between
Lst_Init (constructor) and Lst_New (allocation + construction)
Lst_Destroy (destructor) and Lst_Delete (deallocation + destruction),
and uses that to turn most dynamic allocation of lists (Lst pointers)
into static structures (LIST).

Most of this is mundane, except for allGNs in targ.c, where the code must
be checked to verify that Targ_Init is called soon enough.

Lst_New is a temporary addition. All lists will soon be static.

Reviewed by millert@@, like the previous patch.
@
text
@d1 1
a1 1
/*	$OpenBSD: var.c,v 1.32 2000/06/10 01:41:06 espie Exp $	*/
d73 1
a73 1
static char rcsid[] = "$OpenBSD: var.c,v 1.32 2000/06/10 01:41:06 espie Exp $";
d127 46
@


1.32
log
@Clean-up patch: use `void *' instead of old-fashioned ClientData/Address.
@
text
@d1 1
a1 1
/*	$OpenBSD: var.c,v 1.31 2000/06/10 01:32:23 espie Exp $	*/
d73 1
a73 1
static char rcsid[] = "$OpenBSD: var.c,v 1.31 2000/06/10 01:32:23 espie Exp $";
d162 1
a162 1
static Lst	allVars;      /* List of all variables */
d321 1
a321 1
    var = Lst_Find(ctxt->context, VarCmp, name);
d324 1
a324 1
	var = Lst_Find(VAR_CMD->context, VarCmp, name);
d327 1
a327 1
	var = Lst_Find(VAR_GLOBAL->context, VarCmp, name);
d330 1
a330 1
    	var = Lst_Find(VAR_ENV->context, VarCmp, name);
d340 1
a340 1
	    var = Lst_Find(VAR_GLOBAL->context, VarCmp, name);
d380 2
a381 2
    Lst_AtFront(ctxt->context, v);
    Lst_AtEnd(allVars, v);
d436 1
a436 1
    ln = Lst_Find(ctxt->context, VarCmp, name);
d441 3
a443 3
	Lst_Remove(ctxt->context, ln);
	ln = Lst_Member(allVars, v);
	Lst_Remove(allVars, ln);
a2304 3
 * Results:
 *	None
 *
d2310 1
a2310 1
Var_Init ()
d2315 1
a2315 1
    allVars = Lst_Init();
d2321 1
a2321 1
Var_End ()
d2323 1
a2323 1
    Lst_Destroy(allVars, VarDelete);
d2347 1
a2347 1
    Lst_Every(ctxt->context, VarPrintVar);
@


1.31
log
@Thus, Lst_ForEach no longer needs returning a status.
In fact, it can become a macro based on Lst_ForEachFrom.
This also introduces Lst_Every, as a shortcut for the very common case where
Lst_ForEach does not need any user data.

Finally,  make consistent use of a few function typedefs, instead of having
explicit void (*)(Lst)  arguments all over the place.
@
text
@d1 1
a1 1
/*	$OpenBSD: var.c,v 1.30 2000/03/26 16:21:33 espie Exp $	*/
d73 1
a73 1
static char rcsid[] = "$OpenBSD: var.c,v 1.30 2000/03/26 16:21:33 espie Exp $";
d206 1
a206 1
static int VarCmp __P((ClientData, ClientData));
d209 6
a214 6
static void VarDelete __P((ClientData));
static Boolean VarHead __P((char *, Boolean, Buffer, ClientData));
static Boolean VarTail __P((char *, Boolean, Buffer, ClientData));
static Boolean VarSuffix __P((char *, Boolean, Buffer, ClientData));
static Boolean VarRoot __P((char *, Boolean, Buffer, ClientData));
static Boolean VarMatch __P((char *, Boolean, Buffer, ClientData));
d216 1
a216 1
static Boolean VarSYSVMatch __P((char *, Boolean, Buffer, ClientData));
d218 1
a218 1
static Boolean VarNoMatch __P((char *, Boolean, Buffer, ClientData));
d221 1
a221 1
static Boolean VarRESubstitute __P((char *, Boolean, Buffer, ClientData));
d223 1
a223 1
static Boolean VarSubstitute __P((char *, Boolean, Buffer, ClientData));
d227 4
a230 6
static char *VarModify __P((char *, Boolean (*)(char *, Boolean, Buffer,
						ClientData),
			    ClientData));
static void VarPrintVar __P((ClientData));
static Boolean VarUppercase __P((char *word, Boolean addSpace, Buffer buf, ClientData dummy));
static Boolean VarLowercase __P((char *word, Boolean addSpace, Buffer buf, ClientData dummy));
d246 3
a248 3
VarCmp (v, name)
    ClientData     v;		/* VAR structure to compare */
    ClientData     name;	/* name to look for */
d250 1
a250 1
    return (strcmp ((char *) name, ((Var *) v)->name));
d403 1
a403 1
    ClientData vp;
d625 1
a625 1
    ClientData	  dummy;
d656 1
a656 1
    ClientData	  dummy;
d683 1
a683 1
VarHead (word, addSpace, buf, dummy)
d688 1
a688 1
    ClientData	  dummy;
d724 1
a724 1
VarTail (word, addSpace, buf, dummy)
d729 1
a729 1
    ClientData	  dummy;
d758 1
a758 1
VarSuffix (word, addSpace, buf, dummy)
d763 1
a763 1
    ClientData	  dummy;
d793 1
a793 1
VarRoot (word, addSpace, buf, dummy)
d798 1
a798 1
    ClientData	  dummy;
d829 1
a829 1
VarMatch (word, addSpace, buf, pattern)
d835 1
a835 1
    ClientData    pattern; 	/* Pattern the word must match */
d864 1
a864 1
VarSYSVMatch (word, addSpace, buf, patp)
d870 1
a870 1
    ClientData 	  patp; 	/* Pattern the word must match */
d908 1
a908 1
VarNoMatch (word, addSpace, buf, pattern)
d914 1
a914 1
    ClientData    pattern; 	/* Pattern the word must match */
d941 1
a941 1
VarSubstitute (word, addSpace, buf, patternp)
d946 1
a946 1
    ClientData	        patternp;   /* Pattern for substitution */
d1138 1
a1138 1
    ClientData patternp;
d1258 2
a1259 2
    Boolean    	  (*modProc) __P((char *, Boolean, Buffer, ClientData));
    ClientData	  datum;    	    /* Datum to pass it */
d2333 1
a2333 1
    ClientData vp;
@


1.30
log
@Remove idiotic, braindead casts T* -> void*
They serve no purpose, except hiding potential bugs.

In particular, remove (ClientData) cast from macro, showing potentially
troublesome use of Hashes to store time_t.
@
text
@d1 1
a1 1
/*	$OpenBSD: var.c,v 1.29 2000/01/08 09:45:16 espie Exp $	*/
d73 1
a73 1
static char rcsid[] = "$OpenBSD: var.c,v 1.29 2000/01/08 09:45:16 espie Exp $";
d230 1
a230 1
static int VarPrintVar __P((ClientData, ClientData));
d2333 2
a2334 2
static int
VarPrintVar(vp, dummy)
a2335 1
    ClientData dummy;
d2337 2
a2338 1
    Var    *v = (Var *) vp;
a2339 1
    return (dummy ? 0 : 0);
d2352 1
a2352 1
    Lst_ForEach(ctxt->context, VarPrintVar, NULL);
@


1.29
log
@Finish changing all Var_Parse arguments to size_t. Thanks to millert@@
for reminding me.
@
text
@d1 1
a1 1
/*	$OpenBSD: var.c,v 1.28 1999/12/19 00:04:25 espie Exp $	*/
d73 1
a73 1
static char rcsid[] = "$OpenBSD: var.c,v 1.28 1999/12/19 00:04:25 espie Exp $";
d323 1
a323 1
    var = Lst_Find(ctxt->context, VarCmp, (ClientData)name);
d326 1
a326 1
	var = Lst_Find(VAR_CMD->context, VarCmp, (ClientData)name);
d329 1
a329 1
	var = Lst_Find(VAR_GLOBAL->context, VarCmp, (ClientData)name);
d332 1
a332 1
    	var = Lst_Find(VAR_ENV->context, VarCmp, (ClientData)name);
d342 1
a342 1
	    var = Lst_Find(VAR_GLOBAL->context, VarCmp, (ClientData)name);
d382 2
a383 2
    Lst_AtFront(ctxt->context, (ClientData)v);
    Lst_AtEnd(allVars, (ClientData)v);
d438 1
a438 1
    ln = Lst_Find(ctxt->context, VarCmp, (ClientData)name);
d446 1
a446 1
	VarDelete((ClientData) v);
d1572 1
a1572 1
			    val = VarModify(val, VarHead, (ClientData)0);
d1574 1
a1574 1
			    val = VarModify(val, VarTail, (ClientData)0);
d1756 1
a1756 1
			newStr = VarModify(str, VarMatch, (ClientData)pattern);
d1758 1
a1758 2
			newStr = VarModify(str, VarNoMatch,
					   (ClientData)pattern);
d1809 1
a1809 2
		    newStr = VarModify(str, VarSubstitute,
				       (ClientData)&pattern);
d1871 1
a1871 2
		    newStr = VarModify(str, VarRESubstitute,
				       (ClientData) &pattern);
d1888 1
a1888 1
			newStr = VarModify (str, VarTail, (ClientData)0);
d1896 1
a1896 1
			newStr = VarModify (str, VarHead, (ClientData)0);
d1904 1
a1904 1
			newStr = VarModify (str, VarSuffix, (ClientData)0);
d1912 1
a1912 1
			newStr = VarModify (str, VarRoot, (ClientData)0);
d1920 1
a1920 1
			newStr = VarModify (str, VarUppercase, (ClientData)0);
d1928 1
a1928 1
			newStr = VarModify (str, VarLowercase, (ClientData)0);
d2007 1
a2007 2
			newStr = VarModify(str, VarSYSVMatch,
					   (ClientData)&pattern);
d2277 1
a2277 1
    return(VarModify(file, VarTail, (ClientData)0));
d2299 1
a2299 1
    return(VarModify(file, VarHead, (ClientData)0));
d2353 1
a2353 1
    Lst_ForEach (ctxt->context, VarPrintVar, (ClientData) 0);
@


1.28
log
@Rearrange Lst_Find interface to conform better with other functions.
@
text
@d1 1
a1 1
/*	$OpenBSD: var.c,v 1.27 1999/12/18 21:58:08 espie Exp $	*/
d73 1
a73 1
static char rcsid[] = "$OpenBSD: var.c,v 1.27 1999/12/18 21:58:08 espie Exp $";
d1317 1
a1317 1
    int junk;
d1350 1
a1350 1
		int     len;
d1439 1
a1439 1
    int	    	    *lengthPtr;	/* OUT: The length of the specification */
@


1.27
log
@Nothing ever checks ReturnStatus on Lst_Insert, Lst_Append, Lst_AtFront,
Lst_AtEnd, Lst_Concat, Lst_Remove, Lst_Replace.

Don't bother returning one.
@
text
@d1 1
a1 1
/*	$OpenBSD: var.c,v 1.26 1999/12/18 21:53:33 espie Exp $	*/
d73 1
a73 1
static char rcsid[] = "$OpenBSD: var.c,v 1.26 1999/12/18 21:53:33 espie Exp $";
d323 1
a323 1
    var = Lst_Find(ctxt->context, (ClientData)name, VarCmp);
d326 1
a326 1
	var = Lst_Find (VAR_CMD->context, (ClientData)name, VarCmp);
d329 1
a329 1
	var = Lst_Find (VAR_GLOBAL->context, (ClientData)name, VarCmp);
d332 1
a332 1
    	var = Lst_Find(VAR_ENV->context, (ClientData)name, VarCmp);
d342 1
a342 1
	    var = Lst_Find(VAR_GLOBAL->context, (ClientData)name, VarCmp);
d438 1
a438 1
    ln = Lst_Find(ctxt->context, (ClientData)name, VarCmp);
@


1.26
log
@NIL, NILGNODE, etc, are only glorified NULL.
Get rid of them.

Get rid of list.h, nothing uses it anyway.
@
text
@d1 1
a1 1
/*	$OpenBSD: var.c,v 1.25 1999/12/18 02:11:27 espie Exp $	*/
d73 1
a73 1
static char rcsid[] = "$OpenBSD: var.c,v 1.25 1999/12/18 02:11:27 espie Exp $";
d382 2
a383 2
    (void) Lst_AtFront (ctxt->context, (ClientData)v);
    (void) Lst_AtEnd (allVars, (ClientData) v);
@


1.25
log
@make does not use circular lists, get rid of the extra weight.
@
text
@d1 1
a1 1
/*	$OpenBSD: var.c,v 1.24 1999/12/16 17:27:18 espie Exp $	*/
d73 1
a73 1
static char rcsid[] = "$OpenBSD: var.c,v 1.24 1999/12/16 17:27:18 espie Exp $";
d263 1
a263 1
 *	NIL if the variable does not exist.
d325 1
a325 1
    if ((var == NILLNODE) && (flags & FIND_CMD) && (ctxt != VAR_CMD))
d327 1
a327 1
    if (!checkEnvFirst && (var == NILLNODE) && (flags & FIND_GLOBAL) &&
d331 1
a331 1
    if ((var == NILLNODE) && (flags & FIND_ENV)) {
d333 1
a333 1
	if (var == NILLNODE) {
d340 1
a340 1
    if (var == NILLNODE && checkEnvFirst && (flags & FIND_GLOBAL) &&
d343 2
a344 2
    if (var == NILLNODE)
	return ((Var *) NIL);
d346 1
a346 1
	return ((Var *) Lst_Datum (var));
d439 1
a439 1
    if (ln != NILLNODE) {
d485 1
a485 1
    if (v == (Var *) NIL) {
d540 1
a540 1
    if (v == (Var *) NIL) {
d575 1
a575 1
    if (v == (Var *)NIL)
d601 1
a601 1
    if (v != (Var *)NIL) 
d1476 1
a1476 1
	if (v == (Var *)NIL) {
d1538 1
a1538 1
	if ((v == (Var *)NIL) && (ctxt != VAR_CMD) && (ctxt != VAR_GLOBAL) &&
d1563 1
a1563 1
		    if (v != (Var *)NIL) {
d1590 1
a1590 1
	if (v == (Var *)NIL) {
@


1.24
log
@Var_Subst is actually two distinct functions folded into one:
split the function specific to for.c out, and give them more sensible
arguments at the same time.

This makes .for loop handling more efficient, as we have some heuristic
to evaluate the size of the buffer needed...
@
text
@d1 1
a1 1
/*	$OpenBSD: var.c,v 1.23 1999/12/16 17:02:45 espie Exp $	*/
d73 1
a73 1
static char rcsid[] = "$OpenBSD: var.c,v 1.23 1999/12/16 17:02:45 espie Exp $";
d2324 1
a2324 1
    allVars = Lst_Init(FALSE);
@


1.23
log
@Allocate buffers as static data structures.
This cuts down quite a lot of malloc, since in actual use,
buffer usage is mostly static.
@
text
@d1 1
a1 1
/*	$OpenBSD: var.c,v 1.22 1999/12/16 16:52:11 espie Exp $	*/
d73 1
a73 1
static char rcsid[] = "$OpenBSD: var.c,v 1.22 1999/12/16 16:52:11 espie Exp $";
d1675 1
a1675 1
	str = Var_Subst(NULL, str, ctxt, err);
d2094 1
a2094 1
 *	Substitute for all variables in the given string in the given context
d2106 1
a2106 2
Var_Subst (var, str, ctxt, undefErr)
    char	  *var;		    /* Named variable || NULL for all */
d2111 1
a2111 4
    BUFFER  	  buf;	    	    /* Buffer for forming things */
    char    	  *val;		    /* Value to substitute for a variable */
    int	    	  length;   	    /* Length of the variable invocation */
    Boolean 	  doFree;   	    /* Set true if val should be freed */
d2119 58
a2176 16
    while (*str) {
	if (var == NULL && (*str == '$') && (str[1] == '$')) {
	    /*
	     * A dollar sign may be escaped either with another dollar sign.
	     * In such a case, we skip over the escape character and store the
	     * dollar sign into the buffer directly.
	     */
	    str++;
	    Buf_AddChar(&buf, *str);
	    str++;
	} else if (*str != '$') {
	    /*
	     * Skip as many characters as possible -- either to the end of
	     * the string or to the next dollar sign (variable invocation).
	     */
	    char  *cp;
d2178 39
a2216 1
	    for (cp = str++; *str != '$' && *str != '\0'; str++)
d2218 1
a2218 1
	    Buf_AddInterval(&buf, cp, str);
d2220 2
a2221 15
	    if (var != NULL) {
		int expand;
		for (;;) {
		    if (str[1] != '(' && str[1] != '{') {
			if (str[1] != *var || var[1] != '\0') {
			    Buf_AddChars(&buf, 2, str);
			    str += 2;
			    expand = FALSE;
			}
			else
			    expand = TRUE;
			break;
		    }
		    else {
			char *p;
d2223 16
a2238 37
			/*
			 * Scan up to the end of the variable name.
			 */
			for (p = &str[2]; *p &&
			     *p != ':' && *p != ')' && *p != '}'; p++)
			    if (*p == '$')
				break;
			/*
			 * A variable inside the variable. We cannot expand
			 * the external variable yet, so we try again with
			 * the nested one
			 */
			if (*p == '$') {
			    Buf_AddInterval(&buf, str, p);
			    str = p;
			    continue;
			}

			if (strncmp(var, str + 2, p - str - 2) != 0 ||
			    var[p - str - 2] != '\0') {
			    /*
			     * Not the variable we want to expand, scan
			     * until the next variable
			     */
			    for (;*p != '$' && *p != '\0'; p++)
				continue;
			    Buf_AddInterval(&buf, str, p);
			    str = p;
			    expand = FALSE;
			}
			else
			    expand = TRUE;
			break;
		    }
		}
		if (!expand)
		    continue;
d2241 7
a2247 48
	    val = Var_Parse (str, ctxt, undefErr, &length, &doFree);

	    /*
	     * When we come down here, val should either point to the
	     * value of this variable, suitably modified, or be NULL.
	     * Length should be the total length of the potential
	     * variable invocation (from $ to end character...)
	     */
	    if (val == var_Error || val == varNoError) {
		/*
		 * If performing old-time variable substitution, skip over
		 * the variable and continue with the substitution. Otherwise,
		 * store the dollar sign and advance str so we continue with
		 * the string...
		 */
		if (oldVars) {
		    str += length;
		} else if (undefErr) {
		    /*
		     * If variable is undefined, complain and skip the
		     * variable. The complaint will stop us from doing anything
		     * when the file is parsed.
		     */
		    if (!errorReported) {
			Parse_Error (PARSE_FATAL,
				     "Undefined variable \"%.*s\"",length,str);
		    }
		    str += length;
		    errorReported = TRUE;
		} else {
		    Buf_AddChar(&buf, *str);
		    str += 1;
		}
	    } else {
		/*
		 * We've now got a variable structure to store in. But first,
		 * advance the string pointer.
		 */
		str += length;

		/*
		 * Copy all the characters from the variable value straight
		 * into the new string.
		 */
		Buf_AddString(&buf, val);
		if (doFree)
		    free(val);
	    }
d2249 11
a2260 2

    return Buf_Retrieve(&buf);
@


1.22
log
@Remove unneeded extraneous zeros at the end of buffers.

Actually, one of these needs to be there, because of two bugs in cond.c
@
text
@d1 1
a1 1
/*	$OpenBSD: var.c,v 1.21 1999/12/16 16:41:42 espie Exp $	*/
d73 1
a73 1
static char rcsid[] = "$OpenBSD: var.c,v 1.21 1999/12/16 16:41:42 espie Exp $";
d170 1
a170 1
    Buffer	  val;	    	/* its value */
d205 1
d377 2
a378 2
    v->val = Buf_Init(len+1);
    Buf_AddChars(v->val, len, val);
d409 2
a410 2
    Buf_Destroy(v->val, TRUE);
    free((Address) v);
d488 2
a489 2
	Buf_Reset(v->val);
	Buf_AddString(v->val, val);
d543 2
a544 2
	Buf_AddSpace(v->val);
	Buf_AddString(v->val, val);
d547 1
a547 2
	    printf("%s:%s = %s\n", ctxt->name, name,
		   Buf_Retrieve(v->val));
d601 2
a602 2
    if (v != NULL) 
	return Buf_Retrieve(v->val);
d1263 1
a1263 1
    Buffer  	  buf;	    	    /* Buffer for the new string */
d1271 1
a1271 1
    buf = Buf_Init(0);
d1277 1
a1277 1
	addSpace = (*modProc)(av[i], addSpace, buf, datum);
d1281 1
a1281 3
    str = Buf_Retrieve(buf);
    Buf_Destroy(buf, FALSE);
    return (str);
d1316 1
a1316 1
    Buffer buf = Buf_Init(0);
d1318 2
d1335 1
a1335 1
	    Buf_AddChar(buf, cp[1]);
d1340 1
a1340 1
		    Buf_AddChar(buf, *cp);
d1359 1
a1359 1
		Buf_AddString(buf, cp2);
d1366 1
a1366 1
	    Buf_AddChars(buf, pattern->leftLen, pattern->lhs);
d1368 1
a1368 1
	    Buf_AddChar(buf, *cp);
d1378 2
a1379 4
	cp = Buf_Retrieve(buf);
	*length = Buf_Size(buf);
	Buf_Destroy(buf, FALSE);
	return cp;
d1401 1
a1401 1
    Buffer  	  buf;
d1405 1
a1405 1
    buf = Buf_Init(MAKE_BSIZE);
d1408 2
a1409 2
	    Buf_AddChar(buf, '\\');
	Buf_AddChar(buf, *str);
d1411 1
a1411 3
    str = Buf_Retrieve(buf);
    Buf_Destroy(buf, FALSE);
    return str;
d1569 1
a1569 1
			val = Buf_Retrieve(v->val);
d1652 1
a1652 1
		v->val = Buf_Init(1);
d1673 1
a1673 1
    str = Buf_Retrieve(v->val);
d2069 2
a2070 2
	Buf_Destroy(v->val, TRUE);
	free((Address)v);
d2112 1
a2112 1
    Buffer  	  buf;	    	    /* Buffer for forming things */
d2120 1
a2120 1
    buf = Buf_Init(MAKE_BSIZE);
d2131 1
a2131 1
	    Buf_AddChar(buf, *str);
d2142 1
a2142 1
	    Buf_AddInterval(buf, cp, str);
d2149 1
a2149 1
			    Buf_AddChars(buf, 2, str);
d2173 1
a2173 1
			    Buf_AddInterval(buf, str, p);
d2186 1
a2186 1
			    Buf_AddInterval(buf, str, p);
d2229 1
a2229 1
		    Buf_AddChar(buf, *str);
d2243 3
a2245 4
		Buf_AddString(buf, val);
		if (doFree) {
		    free ((Address)val);
		}
d2250 1
a2250 3
    str = Buf_Retrieve(buf);
    Buf_Destroy(buf, FALSE);
    return (str);
d2328 1
a2328 1
VarPrintVar (vp, dummy)
d2333 1
a2333 1
    printf ("%-16s = %s\n", v->name, Buf_Retrieve(v->val));
@


1.21
log
@Split Buf_GetAll into Buf_Retrieve/Buf_Size.
(idiotic to retrieve size every time when it's used half the time)
@
text
@d1 1
a1 1
/*	$OpenBSD: var.c,v 1.20 1999/12/16 16:27:13 espie Exp $	*/
d73 1
a73 1
static char rcsid[] = "$OpenBSD: var.c,v 1.20 1999/12/16 16:27:13 espie Exp $";
a1280 1
    Buf_AddChar(buf, '\0');
a1370 2
    Buf_AddChar(buf, '\0');

a1379 1
	*length -= 1;	/* Don't count the NULL */
a1412 1
    Buf_AddChar(buf, '\0');
a2254 1
    Buf_AddChar(buf, '\0');
@


1.20
log
@Start cleaning up buf.c in earnest.

- Buf_Discard is only used to remove all the bytes in a buffer,
replace with Buf_Reset,
- buffer values are not read unless accessed first through Buf_GetAll,
no need to null-terminate it at every point.
- Buf_Expand need not check if the expansion is needed. That's Buf_AddChar
and Buf_AddChars responsability (otherwise, Buf_AddChar checks twice)
- Buf_Overflow only handles overflow. Adding the character is done in
every case anyway.
@
text
@d1 1
a1 1
/*	$OpenBSD: var.c,v 1.19 1999/12/09 18:18:24 espie Exp $	*/
d73 1
a73 1
static char rcsid[] = "$OpenBSD: var.c,v 1.19 1999/12/09 18:18:24 espie Exp $";
d547 1
a547 1
		   Buf_GetAll(v->val, NULL));
d600 4
a603 5
    v = VarFind (name, ctxt, FIND_ENV | FIND_GLOBAL | FIND_CMD);
    if (v != (Var *) NIL) {
	char *p = Buf_GetAll(v->val, NULL);
	return p;
    } else
d1282 1
a1282 1
    str = Buf_GetAll(buf, NULL);
d1381 2
a1382 1
	cp = Buf_GetAll(buf, length);
d1418 1
a1418 1
    str = Buf_GetAll(buf, NULL);
d1578 1
a1578 1
			val = Buf_GetAll(v->val, NULL);
d1682 1
a1682 1
    str = Buf_GetAll(v->val, NULL);
d2261 1
a2261 1
    str = Buf_GetAll(buf, NULL);
d2346 1
a2346 1
    printf ("%-16s = %s\n", v->name, Buf_GetAll(v->val, NULL));
@


1.19
log
@Introduce `common usage' buf patterns and use them.
@
text
@d1 1
a1 1
/*	$OpenBSD: var.c,v 1.18 1999/12/06 22:28:44 espie Exp $	*/
d73 1
a73 1
static char rcsid[] = "$OpenBSD: var.c,v 1.18 1999/12/06 22:28:44 espie Exp $";
d487 1
a487 1
	Buf_Discard(v->val, Buf_Size(v->val));
@


1.18
log
@Extra parameter no longer needed, ditch.
@
text
@d1 1
a1 1
/*	$OpenBSD: var.c,v 1.17 1999/12/06 22:27:37 espie Exp $	*/
d73 1
a73 1
static char rcsid[] = "$OpenBSD: var.c,v 1.17 1999/12/06 22:27:37 espie Exp $";
d488 1
a488 1
	Buf_AddChars(v->val, strlen(val), val);
d542 2
a543 2
	Buf_AddChar(v->val, ' ');
	Buf_AddChars(v->val, strlen(val), val);
d632 3
a634 5
    if (addSpace) {
	Buf_AddChar(buf, ' ');
    }

    while (len--) {
a635 1
    }
d663 3
a665 5
    if (addSpace) {
	Buf_AddChar(buf, ' ');
    }

    while (len--) {
a666 1
    }
d695 5
a699 8
    slash = strrchr (word, '/');
    if (slash != (char *)NULL) {
	if (addSpace) {
	    Buf_AddChar(buf, ' ');
	}
	*slash = '\0';
	Buf_AddChars(buf, strlen(word), word);
	*slash = '/';
d702 4
a705 6
	/*
	 * If no directory part, give . (q.v. the POSIX standard)
	 */
	if (addSpace) {
	    Buf_AddChars(buf, 2, " .");
	} else {
a706 1
	}
d736 7
a742 12
    if (addSpace) {
	Buf_AddChar(buf, ' ');
    }

    slash = strrchr (word, '/');
    if (slash != (char *)NULL) {
	*slash++ = '\0';
	Buf_AddChars(buf, strlen(slash), slash);
	slash[-1] = '/';
    } else {
	Buf_AddChars(buf, strlen(word), word);
    }
d768 1
a768 1
    register char *dot;
d770 5
a774 8
    dot = strrchr (word, '.');
    if (dot != (char *)NULL) {
	if (addSpace) {
	    Buf_AddChar(buf, ' ');
	}
	*dot++ = '\0';
	Buf_AddChars(buf, strlen(dot), dot);
	dot[-1] = '.';
d803 1
a803 1
    register char *dot;
d805 2
a806 3
    if (addSpace) {
	Buf_AddChar(buf, ' ');
    }
d808 5
a812 8
    dot = strrchr (word, '.');
    if (dot != (char *)NULL) {
	*dot = '\0';
	Buf_AddChars(buf, strlen(word), word);
	*dot = '.';
    } else {
	Buf_AddChars(buf, strlen(word), word);
    }
d841 2
a842 3
	if (addSpace) {
	    Buf_AddChar(buf, ' ');
	}
d844 1
a844 1
	Buf_AddChars(buf, strlen(word), word);
d881 1
a881 1
		Buf_AddChar(buf, ' ');
d888 1
a888 1
		Buf_AddChars(buf, strlen(word), word);
d920 2
a921 3
	if (addSpace) {
	    Buf_AddChar(buf, ' ');
	}
d923 1
a923 1
	Buf_AddChars(buf, strlen(word), word);
d975 2
a976 3
			    if (addSpace) {
				Buf_AddChar(buf, ' ');
			    }
d991 2
a992 3
			if (addSpace) {
			    Buf_AddChar(buf, ' ');
			}
d1022 2
a1023 3
		    if (addSpace) {
			Buf_AddChar(buf, ' ');
		    }
d1026 1
a1026 1
		Buf_AddChars(buf, cp - word, word);
d1056 1
a1056 1
			Buf_AddChar(buf, ' ');
d1059 1
a1059 1
		    Buf_AddChars(buf, cp-word, word);
d1072 2
a1073 3
		if (addSpace) {
		    Buf_AddChar(buf, ' ');
		}
d1086 2
a1087 3
    if (addSpace) {
	Buf_AddChar(buf, ' ');
    }
d1151 1
a1151 1
	    Buf_AddChar(buf, ' ');	\
d1361 1
a1361 1
		Buf_AddChars(buf, strlen(cp2), cp2);
d2151 1
a2151 1
	    Buf_AddChars(buf, str - cp, cp);
d2182 1
a2182 1
			    Buf_AddChars(buf, p - str, str);
d2195 1
a2195 1
			    Buf_AddChars(buf, p - str, str);
d2252 1
a2252 1
		Buf_AddChars(buf, strlen(val), val);
@


1.17
log
@Instead of retrieving var values from the environment again and again,
it is much better to keep them in the global context, marked read-only.

This also makes the next simplification possible, since var values need no
longer be free'd by client code.

(reviewed by ho@@, like other patches)
@
text
@d1 1
a1 1
/*	$OpenBSD: var.c,v 1.16 1999/12/06 22:24:32 espie Exp $	*/
d73 1
a73 1
static char rcsid[] = "$OpenBSD: var.c,v 1.16 1999/12/06 22:24:32 espie Exp $";
d594 1
a594 1
Var_Value (name, ctxt, frp)
a596 1
    char	   **frp;
a600 1
    *frp = NULL;
@


1.16
log
@Clean up buffers interface somewhat:

- buf.c deals exclusively with chars. Be explicit about it, and remove
extraneous dumb casts to char (can hide real type errors).
- buffer sizes are size_t. Note that bp->left can never become NULL.
- Buf_GetAll is happy with a NULL pointer for the size, remove unneeded
extra pointers.
- Propagate size_t to all places where buffer functions are used.
@
text
@d1 1
a1 1
/*	$OpenBSD: var.c,v 1.15 1999/11/11 11:35:17 espie Exp $	*/
d5 27
d73 1
a73 1
static char rcsid[] = "$OpenBSD: var.c,v 1.15 1999/11/11 11:35:17 espie Exp $";
d158 3
a160 2
GNode          *VAR_GLOBAL;   /* variables from the makefile */
GNode          *VAR_CMD;      /* variables defined on the command-line */
a173 1
#define VAR_FROM_ENV	2   	    /* Variable comes from the environment */
d207 1
a207 1
static void VarAdd __P((char *, char *, GNode *));
d265 1
a265 1
 *	None
d277 1
a277 1
				 * environment */
d322 1
a322 1
    var = Lst_Find (ctxt->context, (ClientData)name, VarCmp);
d324 1
a324 1
    if ((var == NILLNODE) && (flags & FIND_CMD) && (ctxt != VAR_CMD)) {
a325 1
    }
d327 1
a327 2
	(ctxt != VAR_GLOBAL))
    {
d331 6
a336 26
	char *env;

	if ((env = getenv (name)) != NULL) {
	    size_t  	len;

	    v = (Var *) emalloc(sizeof(Var));
	    v->name = estrdup(name);

	    len = strlen(env);

	    v->val = Buf_Init(len);
	    Buf_AddChars(v->val, len, env);

	    v->flags = VAR_FROM_ENV;
	    return (v);
	} else if (checkEnvFirst && (flags & FIND_GLOBAL) &&
		   (ctxt != VAR_GLOBAL))
	{
	    var = Lst_Find (VAR_GLOBAL->context, (ClientData)name, VarCmp);
	    if (var == NILLNODE) {
		return ((Var *) NIL);
	    } else {
		return ((Var *)Lst_Datum(var));
	    }
	} else {
	    return((Var *)NIL);
d338 5
a342 1
    } else if (var == NILLNODE) {
d344 1
a344 1
    } else {
a345 1
    }
d354 1
a354 1
 *	None
d362 2
a363 2
static void
VarAdd (name, val, ctxt)
d386 1
d485 1
a485 1
	VarAdd (name, val, ctxt);
d496 4
a499 1
     * to the environment (as per POSIX standard)
d503 1
d540 1
a540 1
	VarAdd (name, val, ctxt);
a549 10
	if (v->flags & VAR_FROM_ENV) {
	    /*
	     * If the original variable came from the environment, we
	     * have to install it in the global context (we could place
	     * it in the environment, but then we should provide a way to
	     * export other variables...)
	     */
	    v->flags &= ~VAR_FROM_ENV;
	    Lst_AtFront(ctxt->context, (ClientData)v);
	}
d575 4
a578 8
    if (v == (Var *)NIL) {
	return(FALSE);
    } else if (v->flags & VAR_FROM_ENV) {
	free(v->name);
	Buf_Destroy(v->val, TRUE);
	free((char *)v);
    }
    return(TRUE);
a604 5
	if (v->flags & VAR_FROM_ENV) {
	    Buf_Destroy(v->val, FALSE);
	    free((Address) v);
	    *frp = p;
	}
d606 2
a607 3
    } else {
	return ((char *) NULL);
    }
d2102 1
a2102 15
    if (v->flags & VAR_FROM_ENV) {
	Boolean	  destroy = FALSE;

	if (str != Buf_GetAll(v->val, NULL)) {
	    destroy = TRUE;
	} else {
	    /*
	     * Returning the value unmodified, so tell the caller to free
	     * the thing.
	     */
	    *freePtr = TRUE;
	}
	Buf_Destroy(v->val, destroy);
	free((Address)v);
    } else if (v->flags & VAR_JUNK) {
d2357 3
a2359 2
    VAR_GLOBAL = Targ_NewGN ("Global");
    VAR_CMD = Targ_NewGN ("Command");
@


1.15
log
@Kill Str_FindSubString, it's strstr.
@
text
@d1 1
a1 1
/*	$OpenBSD: var.c,v 1.14 1999/11/10 14:11:49 espie Exp $	*/
d46 1
a46 1
static char rcsid[] = "$OpenBSD: var.c,v 1.14 1999/11/10 14:11:49 espie Exp $";
d162 1
a162 1
    int	    	  leftLen;  /* Length of string */
d164 1
a164 1
    int	    	  rightLen; /* Length of replacement */
d196 1
a196 1
static char *VarGetPattern __P((GNode *, int, char **, int, int *, int *,
d309 1
a309 1
	    int	  	len;
d317 1
a317 1
	    Buf_AddBytes(v->val, len, (Byte *)env);
d369 1
a369 1
    Buf_AddBytes(v->val, len, (Byte *)val);
d479 1
a479 1
	Buf_AddBytes(v->val, strlen(val), (Byte *)val);
d529 2
a530 2
	Buf_AddByte(v->val, (Byte)' ');
	Buf_AddBytes(v->val, strlen(val), (Byte *)val);
d534 1
a534 1
		   (char *) Buf_GetAll(v->val, (int *)NULL));
d605 1
a605 1
	char *p = ((char *)Buf_GetAll(v->val, (int *)NULL));
d642 1
a642 1
	Buf_AddByte (buf, (Byte)' ');
d646 1
a646 1
    	Buf_AddByte (buf, toupper(*word++));
d676 1
a676 1
	Buf_AddByte (buf, (Byte)' ');
d680 1
a680 1
    	Buf_AddByte (buf, tolower(*word++));
d713 1
a713 1
	    Buf_AddByte (buf, (Byte)' ');
d716 1
a716 1
	Buf_AddBytes (buf, strlen (word), (Byte *)word);
d724 1
a724 1
	    Buf_AddBytes(buf, 2, (Byte *)" .");
d726 1
a726 1
	    Buf_AddByte(buf, (Byte)'.');
d758 1
a758 1
	Buf_AddByte (buf, (Byte)' ');
d764 1
a764 1
	Buf_AddBytes (buf, strlen(slash), (Byte *)slash);
d767 1
a767 1
	Buf_AddBytes (buf, strlen(word), (Byte *)word);
d799 1
a799 1
	    Buf_AddByte (buf, (Byte)' ');
d802 1
a802 1
	Buf_AddBytes (buf, strlen (dot), (Byte *)dot);
d835 1
a835 1
	Buf_AddByte (buf, (Byte)' ');
d841 1
a841 1
	Buf_AddBytes (buf, strlen (word), (Byte *)word);
d844 1
a844 1
	Buf_AddBytes (buf, strlen(word), (Byte *)word);
d875 1
a875 1
	    Buf_AddByte(buf, (Byte)' ');
d878 1
a878 1
	Buf_AddBytes(buf, strlen(word), (Byte *)word);
d915 1
a915 1
		Buf_AddByte(buf, (Byte)' ');
d922 1
a922 1
		Buf_AddBytes(buf, strlen(word), (Byte *) word);
d955 1
a955 1
	    Buf_AddByte(buf, (Byte)' ');
d958 1
a958 1
	Buf_AddBytes(buf, strlen(word), (Byte *)word);
d986 1
a986 1
    register int  	wordLen;    /* Length of word */
d1011 1
a1011 1
				Buf_AddByte(buf, (Byte)' ');
d1014 1
a1014 2
			    Buf_AddBytes(buf, pattern->rightLen,
					 (Byte *)pattern->rhs);
d1028 1
a1028 1
			    Buf_AddByte(buf, (Byte)' ');
d1032 3
a1034 3
		    Buf_AddBytes(buf, pattern->rightLen, (Byte *)pattern->rhs);
		    Buf_AddBytes(buf, wordLen - pattern->leftLen,
				 (Byte *)(word + pattern->leftLen));
d1060 1
a1060 1
			Buf_AddByte(buf, (Byte)' ');
d1064 2
a1065 2
		Buf_AddBytes(buf, cp - word, (Byte *)word);
		Buf_AddBytes(buf, pattern->rightLen, (Byte *)pattern->rhs);
d1086 1
a1086 1
	    int origSize;
d1094 1
a1094 1
			Buf_AddByte(buf, (Byte)' ');
d1097 2
a1098 2
		    Buf_AddBytes(buf, cp-word, (Byte *)word);
		    Buf_AddBytes(buf, pattern->rightLen, (Byte *)pattern->rhs);
d1111 1
a1111 1
		    Buf_AddByte(buf, (Byte)' ');
d1113 1
a1113 1
		Buf_AddBytes(buf, wordLen, (Byte *)word);
d1120 1
a1120 1
	    return ((Buf_Size(buf) != origSize) || addSpace);
d1126 1
a1126 1
	Buf_AddByte(buf, (Byte)' ');
d1128 1
a1128 1
    Buf_AddBytes(buf, wordLen, (Byte *)word);
d1191 1
a1191 1
	    Buf_AddByte(buf, ' ');	\
d1211 1
a1211 1
	    Buf_AddBytes(buf, pat->matches[0].rm_so, wp);
d1217 1
a1217 1
		Buf_AddByte(buf,rp[1]);
d1254 1
a1254 1
		    Buf_AddBytes(buf, sublen, subbuf);
d1258 1
a1258 1
		Buf_AddByte(buf, *rp);
d1266 1
a1266 1
	    Buf_AddBytes(buf, strlen(wp), wp);
d1275 1
a1275 1
	    Buf_AddBytes(buf,strlen(wp),wp);
d1312 1
a1312 1
    buf = Buf_Init (0);
d1322 3
a1324 3
    Buf_AddByte (buf, '\0');
    str = (char *)Buf_GetAll (buf, (int *)NULL);
    Buf_Destroy (buf, FALSE);
d1356 1
a1356 1
    int *length;
d1377 1
a1377 1
	    Buf_AddByte(buf, (Byte) cp[1]);
d1382 1
a1382 1
		    Buf_AddByte(buf, (Byte) *cp);
d1401 1
a1401 1
		Buf_AddBytes(buf, strlen(cp2), (Byte *) cp2);
d1408 1
a1408 1
	    Buf_AddBytes(buf, pattern->leftLen, (Byte *)pattern->lhs);
d1410 1
a1410 1
	    Buf_AddByte(buf, (Byte) *cp);
d1413 1
a1413 1
    Buf_AddByte(buf, (Byte) '\0');
d1422 1
a1422 1
	cp = (char *) Buf_GetAll(buf, length);
d1451 1
a1451 1
    buf = Buf_Init (MAKE_BSIZE);
d1454 2
a1455 2
	    Buf_AddByte(buf, (Byte)'\\');
	Buf_AddByte(buf, (Byte)*str);
d1457 3
a1459 3
    Buf_AddByte(buf, (Byte) '\0');
    str = (char *)Buf_GetAll (buf, (int *)NULL);
    Buf_Destroy (buf, FALSE);
d1618 1
a1618 1
			val = (char *)Buf_GetAll(v->val, (int *)NULL);
d1722 1
a1722 1
    str = (char *)Buf_GetAll(v->val, (int *)NULL);
d2112 1
a2112 1
	if (str != (char *)Buf_GetAll(v->val, (int *)NULL)) {
d2183 1
a2183 1
    buf = Buf_Init (MAKE_BSIZE);
d2194 1
a2194 1
	    Buf_AddByte(buf, (Byte)*str);
d2205 1
a2205 1
	    Buf_AddBytes(buf, str - cp, (Byte *)cp);
d2212 1
a2212 1
			    Buf_AddBytes(buf, 2, (Byte *) str);
d2236 1
a2236 1
			    Buf_AddBytes(buf, p - str, (Byte *) str);
d2249 1
a2249 1
			    Buf_AddBytes(buf, p - str, (Byte *) str);
d2292 1
a2292 1
		    Buf_AddByte (buf, (Byte)*str);
d2306 1
a2306 1
		Buf_AddBytes (buf, strlen (val), (Byte *)val);
d2314 3
a2316 3
    Buf_AddByte (buf, '\0');
    str = (char *)Buf_GetAll (buf, (int *)NULL);
    Buf_Destroy (buf, FALSE);
d2399 1
a2399 1
    printf ("%-16s = %s\n", v->name, (char *) Buf_GetAll(v->val, (int *)NULL));
@


1.14
log
@Turn on strict-prototypes, add missing prototypes.
Move main prototype to main.c, as this is not used
from any other file.

Close open bug.
@
text
@d1 1
a1 1
/*	$OpenBSD: var.c,v 1.13 1999/11/06 14:34:42 espie Exp $	*/
d46 1
a46 1
static char rcsid[] = "$OpenBSD: var.c,v 1.13 1999/11/06 14:34:42 espie Exp $";
d1092 1
a1092 1
		cp = Str_FindSubstring(word, pattern->lhs);
@


1.13
log
@Bug-fix: when expanding a specific variable v in $A,
check that v is PRECISELY A.

Other BSDs, take notice.
@
text
@d1 1
a1 1
/*	$OpenBSD: var.c,v 1.12 1999/09/28 21:57:04 espie Exp $	*/
d46 1
a46 1
static char rcsid[] = "$OpenBSD: var.c,v 1.12 1999/09/28 21:57:04 espie Exp $";
d203 2
@


1.12
log
@Fix
.if defined(VAR) && ${VAR:m}

cond.c has special code (set err to 0) to tell VarParse it shouldn't care
if the variable is not defined.

But this was not completely added, namely the path that deals with
modifiers was blissfully unaware of that.
@
text
@d1 1
a1 1
/*	$OpenBSD: var.c,v 1.11 1999/09/25 14:44:00 espie Exp $	*/
d46 1
a46 1
static char rcsid[] = "$OpenBSD: var.c,v 1.11 1999/09/25 14:44:00 espie Exp $";
d2210 1
a2210 1
			if (str[1] != *var) {
@


1.11
log
@Add :L/:U modificators (lowercase/uppercase)
To use to get ports building more user-friendly.
@
text
@d1 1
a1 1
/*	$OpenBSD: var.c,v 1.10 1998/12/05 00:06:29 espie Exp $	*/
d46 1
a46 1
static char rcsid[] = "$OpenBSD: var.c,v 1.10 1998/12/05 00:06:29 espie Exp $";
d2139 1
a2139 1
	    str = var_Error;
@


1.10
log
@Modifications from netbsd:
- don't interfere with MACHINE/MACHINE_ARCH defines for bootstrap
- type clean-up, time_t, and printing `unknown' ints
- fix TARGET/MEMBER bug in archive rules
- memmove...
- cleaner Error handler.
- reentrant brk_string
- .MAKE env variable
- preliminary scaffolding for .NOPATH

Other improvements:
- efree
- shellneed streamlined
- display Stop in .CURDIR after an error.
- document most features and misfeatures.
- add a few OpenBSD notes to the tutorial.
@
text
@d1 1
a1 1
/*	$OpenBSD: var.c,v 1.8 1998/03/30 06:59:39 deraadt Exp $	*/
d46 1
a46 1
static char rcsid[] = "$OpenBSD: var.c,v 1.8 1998/03/30 06:59:39 deraadt Exp $";
d617 68
d1964 16
@


1.9
log
@portable bootstrap thing; lidl@@eng.us.uu.net
@
text
@d1239 2
a1240 1
    char **av;			    /* word list [first word does not count] */
d1246 1
a1246 1
    av = brk_string(str, &ac, FALSE);
d1248 1
a1248 1
    for (i = 1; i < ac; i++)
d1251 2
d1267 1
a1267 1
 *	If pattern is specified, handle escaped ampersants, and replace
@


1.8
log
@Y2K fixes from Andreas.Gunnarsson@@emw.ericsson.se; culled from various places
@
text
@d1 1
a1 1
/*	$OpenBSD: var.c,v 1.7 1997/12/18 21:50:45 deraadt Exp $	*/
d46 1
a46 1
static char rcsid[] = "$OpenBSD: var.c,v 1.7 1997/12/18 21:50:45 deraadt Exp $";
d94 1
@


1.7
log
@for the test following test case, do not output FOOBAR=bar (should be FOOBAR=)
problem reported by mark@@thuvia.demon.co.uk

FOO=
FOOBAR=$(FOO:=bar)
@
text
@d1 1
a1 1
/*	$OpenBSD: var.c,v 1.6 1997/04/01 07:28:28 millert Exp $	*/
d46 1
a46 1
static char rcsid[] = "$OpenBSD: var.c,v 1.6 1997/04/01 07:28:28 millert Exp $";
a1152 1
		char zsub;
@


1.6
log
@Sync with NetBSD (mostly by christos initial substitution/regexp from Der Mouse)

- fix the variable substitution code in make [PR/2748]
      1. change s/a/b/ so that it substitutes the first occurance of the
         pattern on each word, not only the first word.
      2. add flag '1' to the variable substitution so that the substitutions
         get performed only once.

  ***THIS IS AN INCOMPATIBLE CHANGE!***

  Unfortunately there was no way to make things consistent without
  modifying the current behavior. Fortunately none of our Makefiles
  depended on this.

            OLD:

                VAR      = aa1 aa2 aa3 aa4

                S/a/b/   = ba1 aa2 aa3 aa4
                S/a/b/g  = bb1 bb2 bb3 bb4

            NEW:
                VAR      = aa1 aa2 aa3 aa4

                S/a/b/   = ba1 ba2 ba3 ba4
                S/a/b/1  = ba1 aa2 aa3 aa4
                S/a/b/g  = bb1 bb2 bb3 bb4
                S/a/b/1g = bb1 aa2 aa3 aa4
- add regexp variable substitution via 'C/foo/bar/' [PR/2752]
- add variable quoting via the ${VAR:Q} modifier. This is useful when running
  recursive invocations of make(1):

        make VAR=${VAR:Q}

  will always work... (This may prove useful in the kernel builds...) [PR/2981]
- BSD did not traditionally have <sys/cdefs.h>; use BSD4_4 instead and include
  <sys/param.h> to grab it.
- Don't compile the regex code if MAKE_BOOTSTRAP (from gwr)
- Use explicit .c.o rule in Makefile.boot so that the bootstrap process works.
- Use only integral types in procedure arguments. [buf.c buf.h]
- Include <stdlib.h> to get getenv() prototype on SVR4
- if __STDC__ -> ifdef __STDC__ to appease SVR4
- Define const and volatile for non __STDC__
- Implement snprintf() and vsnprintf() for non BSD4_4 systems.
- Make $MACHINE_ARCH settable from the environment.
- Fix .USE directive problems: (reported by cgd)
    1. ${.*} variables did not get expanded in dependencies.
    2. expanded ${.*} variables in .USE dependencies can cause tree
       restructuring; handle it.
    3. in compat mode, expand .USE before evaluating the list of targets,
       instead of doing .USE expansions on demand, because they can cause
       tree restructuring.
- Add a .MADE directive to indicated that the children of a target are
  up-to-date, even when they are not. This is to simulate our current
  make install behavior with proper dependencies.
- Fix problems in the RE substitution error handling.
- Locate all the children of a node marked as MADE.
- Do not compile-in ${MACHINE} (as per NetBSD PR#3386)
- Disable globbing for targets/dependencies when POSIX is defined.
- Fix globbing so that patterns that don't have a matching number of [] or {}
  don't get expanded. (before the [ case got expanded to nothing!) This is
  disabled.
- Make sure that the children of nodes that are marked .MADE, are marked
  UPTODATE and their timestamps are consistent.
- Don't disable wildcards completely; they are used by other Makefiles.
@
text
@d1 1
a1 1
/*	$OpenBSD: var.c,v 1.5 1996/11/30 21:09:07 millert Exp $	*/
d46 1
a46 1
static char rcsid[] = "$OpenBSD: var.c,v 1.5 1996/11/30 21:09:07 millert Exp $";
d842 11
a852 10
    if (addSpace)
	Buf_AddByte(buf, (Byte)' ');

    addSpace = TRUE;

    if ((ptr = Str_SYSVMatch(word, pat->lhs, &len)) != NULL)
	Str_SYSVSubst(buf, pat->rhs, ptr, len);
    else
	Buf_AddBytes(buf, strlen(word), (Byte *) word);

@


1.5
log
@Sync with NetBSD:
- Merge in FreeBSD and Lite2 changes.
- Fix bug where a non-archive target with a .a suffix would always
  be considered to be out of date, since it does not have a TOC.
- Fix NetBSD PR #2930: declare missing variable.
@
text
@d1 2
a2 2
/*	$OpenBSD: var.c,v 1.4 1996/09/02 16:04:22 briggs Exp $	*/
/*	$NetBSD: var.c,v 1.15 1996/11/06 17:59:29 christos Exp $	*/
d46 1
a46 1
static char rcsid[] = "$OpenBSD: var.c,v 1.4 1996/09/02 16:04:22 briggs Exp $";
d93 4
d152 7
a164 3
#define VAR_SUB_GLOBAL	1   /* Apply substitution globally */
#define VAR_MATCH_START	2   /* Match at start of word */
#define VAR_MATCH_END	4   /* Match at end of word */
d167 10
d190 4
d195 3
d919 2
a920 1
    if (1) { /* substitute in each word of the variable */
d922 1
a922 1
	 * Break substitution down into simple anchored cases
d945 1
d964 1
d995 1
d1033 1
a1050 4
	/*
	 * Common code for anchored substitutions:
	 * addSpace was set TRUE if characters were added to the buffer.
	 */
d1061 152
d1257 135
d1420 1
a1420 1
    register char   *cp;    	/* Secondary pointer into str (place marker
d1430 1
d1665 2
a1744 2
		    register char   delim;
		    Buffer  	    buf;    	/* Buffer for patterns */
d1749 1
d1759 8
a1766 1
		    buf = Buf_Init(0);
d1769 3
a1771 5
		     * Pass through the lhs looking for 1) escaped delimiters,
		     * '$'s and backslashes (place the escaped character in
		     * uninterpreted) and 2) unescaped $'s that aren't before
		     * the delimiter (expand the variable substitution).
		     * The result is left in the Buffer buf.
d1773 8
a1780 34
		    for (cp = tstr; *cp != '\0' && *cp != delim; cp++) {
			if ((*cp == '\\') &&
			    ((cp[1] == delim) ||
			     (cp[1] == '$') ||
			     (cp[1] == '\\')))
			{
			    Buf_AddByte(buf, (Byte)cp[1]);
			    cp++;
			} else if (*cp == '$') {
			    if (cp[1] != delim) {
				/*
				 * If unescaped dollar sign not before the
				 * delimiter, assume it's a variable
				 * substitution and recurse.
				 */
				char	    *cp2;
				int	    len;
				Boolean	    freeIt;

				cp2 = Var_Parse(cp, ctxt, err, &len, &freeIt);
				Buf_AddBytes(buf, strlen(cp2), (Byte *)cp2);
				if (freeIt) {
				    free(cp2);
				}
				cp += len - 1;
			    } else {
				/*
				 * Unescaped $ at end of pattern => anchor
				 * pattern at end.
				 */
				pattern.flags |= VAR_MATCH_END;
			    }
			} else {
			    Buf_AddByte(buf, (Byte)*cp);
d1782 1
d1785 3
a1787 1
		    Buf_AddByte(buf, (Byte)'\0');
d1790 1
a1790 2
		     * If lhs didn't end with the delimiter, complain and
		     * return NULL
d1792 14
a1805 10
		    if (*cp != delim) {
			*lengthPtr = cp - start + 1;
			if (*freePtr) {
			    free(str);
			}
			Buf_Destroy(buf, TRUE);
			Error("Unclosed substitution for %s (%c missing)",
			      v->name, delim);
			return (var_Error);
		    }
d1807 1
a1807 10
		    /*
		     * Fetch pattern and destroy buffer, but preserve the data
		     * in it, since that's our lhs. Note that Buf_GetAll
		     * will return the actual number of bytes, which includes
		     * the null byte, so we have to decrement the length by
		     * one.
		     */
		    pattern.lhs = (char *)Buf_GetAll(buf, &pattern.leftLen);
		    pattern.leftLen--;
		    Buf_Destroy(buf, FALSE);
d1809 9
a1817 8
		    /*
		     * Now comes the replacement string. Three things need to
		     * be done here: 1) need to compress escaped delimiters and
		     * ampersands and 2) need to replace unescaped ampersands
		     * with the l.h.s. (since this isn't regexp, we can do
		     * it right here) and 3) expand any variable substitutions.
		     */
		    buf = Buf_Init(0);
d1819 8
a1826 26
		    tstr = cp + 1;
		    for (cp = tstr; *cp != '\0' && *cp != delim; cp++) {
			if ((*cp == '\\') &&
			    ((cp[1] == delim) ||
			     (cp[1] == '&') ||
			     (cp[1] == '\\') ||
			     (cp[1] == '$')))
			{
			    Buf_AddByte(buf, (Byte)cp[1]);
			    cp++;
			} else if ((*cp == '$') && (cp[1] != delim)) {
			    char    *cp2;
			    int	    len;
			    Boolean freeIt;

			    cp2 = Var_Parse(cp, ctxt, err, &len, &freeIt);
			    Buf_AddBytes(buf, strlen(cp2), (Byte *)cp2);
			    cp += len - 1;
			    if (freeIt) {
				free(cp2);
			    }
			} else if (*cp == '&') {
			    Buf_AddBytes(buf, pattern.leftLen,
					 (Byte *)pattern.lhs);
			} else {
			    Buf_AddByte(buf, (Byte)*cp);
d1828 1
d1831 1
a1831 1
		    Buf_AddByte(buf, (Byte)'\0');
d1833 3
a1835 4
		    /*
		     * If didn't end in delimiter character, complain
		     */
		    if (*cp != delim) {
d1837 2
a1838 6
			if (*freePtr) {
			    free(str);
			}
			Buf_Destroy(buf, TRUE);
			Error("Unclosed substitution for %s (%c missing)",
			      v->name, delim);
d1842 12
a1853 23
		    pattern.rhs = (char *)Buf_GetAll(buf, &pattern.rightLen);
		    pattern.rightLen--;
		    Buf_Destroy(buf, FALSE);

		    /*
		     * Check for global substitution. If 'g' after the final
		     * delimiter, substitution is global and is marked that
		     * way.
		     */
		    cp++;
		    if (*cp == 'g') {
			pattern.flags |= VAR_SUB_GLOBAL;
			cp++;
		    }

		    termc = *cp;
		    newStr = VarModify(str, VarSubstitute,
				       (ClientData)&pattern);
		    /*
		     * Free the two strings.
		     */
		    free(pattern.lhs);
		    free(pattern.rhs);
d1856 9
d2055 8
@


1.4
log
@Sync up with NetBSD:
(christos)
	Fix bug reported by Greg Hudson where leaf (source only) nodes were
	referenced only by their basename and not by their full pathname. This
	breaks when .PATH or MAKEOBJDIR are used. There might be Makefiles
	around that try to work around this bug by prepending ${.CURDIR} to
	the sources, and they should be found and fixed. Also a lot of the gunk
	in suff.c that was attempting to work around the same problem could be
	removed.
(christos)
	- Move -D flags from Makefile to config.h and explain what they do. Add
	  -Wall -Wno-unused to CFLAGS. Add new define SYSVVARSUB to enable SysV
	  style variable substitutions and enable them.
	- Add SunOS style command substitutions via SUNSHCMD
	- Fix core dump with '{variable = value'
(christos)
	Fix bug where make will always exit with 0, even when one or more
	parallel jobs failed. (Only affects parallel make code)
(christos)
	Protect __P from being multiply defined (for systems that already
	define it)
(christos) Add strdup() since ultrix is missing it.
	From Larry Schwimmer <rosebud@@cyclone.Stanford.EDU>
(christos) Add estrdup(), a checked version of strdup and use it.
(christos) Recognize SVR4 style long filename entries in archives.
(thorpej) Tidy up some RCS ids a bit.
@
text
@d1 2
a2 2
/*	$OpenBSD: var.c,v 1.3 1996/06/26 05:36:39 deraadt Exp $	*/
/*	$NetBSD: var.c,v 1.14 1996/08/13 16:42:25 christos Exp $	*/
d5 2
a6 2
 * Copyright (c) 1988, 1989, 1990 The Regents of the University of California.
 * Copyright (c) 1988, 1989 by Adam de Boor
d44 1
a44 1
static char sccsid[] = "@@(#)var.c	5.7 (Berkeley) 6/1/90";
d46 1
a46 1
static char rcsid[] = "$OpenBSD: var.c,v 1.3 1996/06/26 05:36:39 deraadt Exp $";
a156 1
#define VAR_NO_SUB	8   /* Substitution is non-global and already done */
d282 1
a282 1
	    
d287 1
a287 1
	    
d290 1
a290 1
	    
d758 1
a758 1
 *	
d794 1
a794 1
 *	
d837 1
a837 1
 *	
d894 1
a894 1
    if ((pattern->flags & VAR_NO_SUB) == 0) {
d896 1
a896 1
	 * Still substituting -- break it down into simple anchored cases
d978 1
a978 1
	     * subsititutions correctly, etc. When the loop is done, any
d1001 1
a1001 4
		    if (wordLen == 0) {
			done = TRUE;
		    }
		    if ((pattern->flags & VAR_SUB_GLOBAL) == 0) {
a1002 1
			pattern->flags |= VAR_NO_SUB;
d1022 2
a1023 4
	 * Common code for anchored substitutions: if performed a substitution
	 * and it's not supposed to be global, mark the pattern as requiring
	 * no more substitutions. addSpace was set TRUE if characters were
	 * added to the buffer.
a1024 3
	if ((pattern->flags & VAR_SUB_GLOBAL) == 0) {
	    pattern->flags |= VAR_NO_SUB;
	}
d1070 1
a1070 1
    
d1121 1
a1121 1
    
d1125 1
a1125 1
    
d1140 1
a1140 1
	    
d1198 1
a1198 1
 	
d1224 1
a1224 1
		    
d1232 1
a1232 1
			
d1251 1
a1251 1
			    
d1280 1
a1280 1
		
d1290 1
a1290 1
	    
d1340 1
a1340 1
    
d1342 1
a1342 1
    
d1368 1
a1368 1
	    
d1445 1
a1445 1
		    
d1471 1
a1471 1
				
d1491 1
a1491 1
		    
d1526 1
a1526 1
		    
d1557 1
a1557 1
		    
d1651 1
a1651 1
		    
d1674 1
a1674 1
			
d1684 1
a1684 1
			
d1697 1
a1697 1
			
d1717 1
a1717 1
			     cp++) 
d1727 1
a1727 1
	    
d1751 1
a1751 1
    
d1754 1
a1754 1
	
d1861 1
a1861 1
			for (p = &str[2]; *p && 
d1863 1
a1863 1
			    if (*p == '$') 
d1875 2
a1876 2
				
			if (strncmp(var, str + 2, p - str - 2) != 0 || 
d1882 1
a1882 1
			    for (;*p != '$' && *p != '\0'; p++) 
d1896 1
a1896 1
			
d1936 1
a1936 1
		
d1948 1
a1948 1
	
d2007 1
a2007 1
 *	The VAR_CMD and VAR_GLOBAL contexts are created 
d2025 1
a2025 1
	
@


1.3
log
@rcsid
@
text
@d1 2
a2 2
/*	$OpenBSD: var.c,v 1.12 1995/11/02 23:55:12 christos Exp $	*/
/*	$NetBSD: var.c,v 1.12 1995/11/02 23:55:12 christos Exp $	*/
d46 1
a46 1
static char rcsid[] = "$OpenBSD: var.c,v 1.12 1995/11/02 23:55:12 christos Exp $";
d169 1
d171 1
d285 1
a285 1
	    v->name = strdup(name);
d338 1
a338 1
    v->name = strdup (name);
d788 1
a788 2


d830 1
d1639 16
a1654 1
		default: {
d1721 3
a1723 1
		    } else {
@


1.2
log
@from christos@@netbsd:
Minor:
    - ${.PREFIX} should never contain a full pathname
    - Fixed gcc -Wall warnings
Major:
    - compatMake is now FALSE. This means that we are now running in
      full pmake mode:
          * rules on dependency lines can be executed in parallel and or
            out of sequence:

            foo: bar baz

            can fire the rule for baz before the rule for bar is fired.
            To enforce bar to be fired before baz, another rule needs to be
            added. [bar: baz]
          * adjacent shell commands in a target are now executed by a single
            invocation of the shell, not one invocation of the shell per line
      (compatMake can be turned off using the -B flag)
    - The -j flag now works... I.e. make -j 4 will fork up to four jobs in
      parallel when it can. The target name is printed before each burst
      of output caused by the target execution as '--- target ---', when j > 1
    - I have changed all the Makefiles so that they work with make -j N, and
      I have tested the whole netbsd by:
          'make -j 4 cleandir; make -j 4 depend; make -j 4; make -j 4 install'
    - I have not compiled or tested this version of make with -DREMOTE.
- Turn compat mode on by default. It gets turned off when the -j without
  the -B flag is specified. [Thus you can use -j 1 to turn it off].
- Fix malloc -> emalloc as Gordon noted.
Updates for POSIX/SVR4 compiling:
arch.c:          Don't require ranlib stuff. Not everybody has it.
dir.c:           SunOS-4 != Solaris; change #ifdef sun to #if sun && !__svr4__
job.c, compat.c: Don't use 'union wait', use int and the W*() macros.
main.c:          Check for uname() == -1; some unames return > 0...
util.c, job.c:   Add signal() with BSD semantics for svr4, don't use bsd
                 sigmask and friends.

from cgd@@netbsd:
pull in make.h.  (PAlloc() now uses emalloc(), which is prototyped in
make.h.  If the prototype is not in scope on the Alpha, I see lots
of "cast to pointer from integer of different size" warnings.)
@
text
@d1 1
d46 1
a46 1
static char rcsid[] = "$NetBSD: var.c,v 1.12 1995/11/02 23:55:12 christos Exp $";
@


1.1
log
@Initial revision
@
text
@d1 1
a1 1
/*	$NetBSD: var.c,v 1.11 1995/06/14 15:20:13 christos Exp $	*/
d45 1
a45 1
static char rcsid[] = "$NetBSD: var.c,v 1.11 1995/06/14 15:20:13 christos Exp $";
d1119 1
a1119 1
    register char   startc;	/* Starting character when variable in parens
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@
