head	1.27;
access;
symbols
	OPENBSD_6_2:1.27.0.12
	OPENBSD_6_2_BASE:1.27
	OPENBSD_6_1:1.27.0.10
	OPENBSD_6_1_BASE:1.27
	OPENBSD_6_0:1.27.0.6
	OPENBSD_6_0_BASE:1.27
	OPENBSD_5_9:1.27.0.2
	OPENBSD_5_9_BASE:1.27
	OPENBSD_5_8:1.27.0.4
	OPENBSD_5_8_BASE:1.27
	OPENBSD_5_7:1.25.0.6
	OPENBSD_5_7_BASE:1.25
	OPENBSD_5_6:1.25.0.10
	OPENBSD_5_6_BASE:1.25
	OPENBSD_5_5:1.25.0.8
	OPENBSD_5_5_BASE:1.25
	OPENBSD_5_4:1.25.0.4
	OPENBSD_5_4_BASE:1.25
	OPENBSD_5_3:1.25.0.2
	OPENBSD_5_3_BASE:1.25
	OPENBSD_5_2:1.23.0.10
	OPENBSD_5_2_BASE:1.23
	OPENBSD_5_1_BASE:1.23
	OPENBSD_5_1:1.23.0.8
	OPENBSD_5_0:1.23.0.6
	OPENBSD_5_0_BASE:1.23
	OPENBSD_4_9:1.23.0.4
	OPENBSD_4_9_BASE:1.23
	OPENBSD_4_8:1.23.0.2
	OPENBSD_4_8_BASE:1.23
	OPENBSD_4_7:1.21.0.10
	OPENBSD_4_7_BASE:1.21
	OPENBSD_4_6:1.21.0.12
	OPENBSD_4_6_BASE:1.21
	OPENBSD_4_5:1.21.0.8
	OPENBSD_4_5_BASE:1.21
	OPENBSD_4_4:1.21.0.6
	OPENBSD_4_4_BASE:1.21
	OPENBSD_4_3:1.21.0.4
	OPENBSD_4_3_BASE:1.21
	OPENBSD_4_2:1.21.0.2
	OPENBSD_4_2_BASE:1.21
	OPENBSD_4_1:1.20.0.12
	OPENBSD_4_1_BASE:1.20
	OPENBSD_4_0:1.20.0.10
	OPENBSD_4_0_BASE:1.20
	OPENBSD_3_9:1.20.0.8
	OPENBSD_3_9_BASE:1.20
	OPENBSD_3_8:1.20.0.6
	OPENBSD_3_8_BASE:1.20
	OPENBSD_3_7:1.20.0.4
	OPENBSD_3_7_BASE:1.20
	OPENBSD_3_6:1.20.0.2
	OPENBSD_3_6_BASE:1.20
	OPENBSD_3_5:1.19.0.4
	OPENBSD_3_5_BASE:1.19
	OPENBSD_3_4:1.19.0.2
	OPENBSD_3_4_BASE:1.19
	OPENBSD_3_3:1.18.0.8
	OPENBSD_3_3_BASE:1.18
	OPENBSD_3_2:1.18.0.6
	OPENBSD_3_2_BASE:1.18
	OPENBSD_3_1:1.18.0.4
	OPENBSD_3_1_BASE:1.18
	OPENBSD_3_0:1.18.0.2
	OPENBSD_3_0_BASE:1.18
	OPENBSD_2_9_BASE:1.14
	OPENBSD_2_9:1.14.0.2
	OPENBSD_2_8:1.13.0.2
	OPENBSD_2_8_BASE:1.13
	OPENBSD_2_7:1.12.0.2
	OPENBSD_2_7_BASE:1.12
	OPENBSD_2_6:1.7.0.2
	OPENBSD_2_6_BASE:1.7
	OPENBSD_2_5:1.6.0.2
	OPENBSD_2_5_BASE:1.6
	OPENBSD_2_4:1.5.0.8
	OPENBSD_2_4_BASE:1.5
	OPENBSD_2_3:1.5.0.6
	OPENBSD_2_3_BASE:1.5
	OPENBSD_2_2:1.5.0.4
	OPENBSD_2_2_BASE:1.5
	OPENBSD_2_1:1.5.0.2
	OPENBSD_2_1_BASE:1.5
	OPENBSD_2_0:1.3.0.2
	OPENBSD_2_0_BASE:1.3
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.27
date	2015.04.29.00.42.12;	author millert;	state Exp;
branches;
next	1.26;
commitid	rDNsSHXSfKlK5CgH;

1.26
date	2015.04.25.15.33.47;	author espie;	state Exp;
branches;
next	1.25;
commitid	oV5HQakan0ERHahj;

1.25
date	2012.11.07.14.18.41;	author espie;	state Exp;
branches;
next	1.24;

1.24
date	2012.09.21.07.55.20;	author espie;	state Exp;
branches;
next	1.23;

1.23
date	2010.07.19.19.46.43;	author espie;	state Exp;
branches;
next	1.22;

1.22
date	2010.07.19.19.30.37;	author espie;	state Exp;
branches;
next	1.21;

1.21
date	2007.07.24.21.09.07;	author espie;	state Exp;
branches;
next	1.20;

1.20
date	2004.04.07.13.11.35;	author espie;	state Exp;
branches;
next	1.19;

1.19
date	2003.06.03.02.56.11;	author millert;	state Exp;
branches;
next	1.18;

1.18
date	2001.05.30.00.43.00;	author deraadt;	state Exp;
branches;
next	1.17;

1.17
date	2001.05.29.12.17.03;	author espie;	state Exp;
branches;
next	1.16;

1.16
date	2001.05.23.12.34.40;	author espie;	state Exp;
branches;
next	1.15;

1.15
date	2001.05.03.13.41.01;	author espie;	state Exp;
branches;
next	1.14;

1.14
date	2000.11.24.14.27.19;	author espie;	state Exp;
branches;
next	1.13;

1.13
date	2000.09.14.13.32.05;	author espie;	state Exp;
branches;
next	1.12;

1.12
date	99.12.16.17.02.45;	author espie;	state Exp;
branches;
next	1.11;

1.11
date	99.12.16.16.46.38;	author espie;	state Exp;
branches;
next	1.10;

1.10
date	99.12.16.16.41.41;	author espie;	state Exp;
branches;
next	1.9;

1.9
date	99.12.16.16.27.12;	author espie;	state Exp;
branches;
next	1.8;

1.8
date	99.12.06.22.24.31;	author espie;	state Exp;
branches;
next	1.7;

1.7
date	99.10.05.21.59.00;	author espie;	state Exp;
branches;
next	1.6;

1.6
date	98.12.05.00.06.27;	author espie;	state Exp;
branches;
next	1.5;

1.5
date	97.04.01.07.28.05;	author millert;	state Exp;
branches;
next	1.4;

1.4
date	96.11.30.21.08.50;	author millert;	state Exp;
branches;
next	1.3;

1.3
date	96.06.26.05.36.25;	author deraadt;	state Exp;
branches;
next	1.2;

1.2
date	96.04.21.23.43.17;	author deraadt;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.45.41;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.45.41;	author deraadt;	state Exp;
branches;
next	;


desc
@@


1.27
log
@Add missing #include <stdint.h> for SIZE_MAX
@
text
@/*	$OpenBSD: buf.c,v 1.26 2015/04/25 15:33:47 espie Exp $	*/
/*	$NetBSD: buf.c,v 1.9 1996/12/31 17:53:21 christos Exp $ */

/*
 * Copyright (c) 1999 Marc Espie.
 *
 * Extensive code changes for the OpenBSD project.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE OPENBSD PROJECT AND CONTRIBUTORS
 * ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
 * A PARTICULAR PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE OPENBSD
 * PROJECT OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
/*
 * Copyright (c) 1988, 1989, 1990 The Regents of the University of California.
 * Copyright (c) 1988, 1989 by Adam de Boor
 * Copyright (c) 1989 by Berkeley Softworks
 * All rights reserved.
 *
 * This code is derived from software contributed to Berkeley by
 * Adam de Boor.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */

/*-
 * buf.c --
 *	Functions for automatically expanded buffers.
 */

#include <ctype.h>
#include <limits.h>
#include <stddef.h>
#include <stdint.h>
#include <stdlib.h>
#include <string.h>
#include <stdio.h>
#include <stdarg.h>
#include "config.h"
#include "defines.h"
#include "buf.h"
#include "stats.h"
#include "memory.h"

#ifdef STATS_BUF
#define DO_STAT_BUF(bp, nb)					\
	STAT_BUFS_EXPANSION++;			\
	if ((bp)->endPtr - (bp)->buffer == 1)			\
		STAT_WEIRD_INEFFICIENT++;
#else
#define DO_STAT_BUF(a, b)
#endif

static void
fatal_overflow()
{
	fprintf(stderr, "buffer size overflow\n");
	exit(2);
}

/* BufExpand(bp, nb)
 *	Expand buffer bp to hold upto nb additional
 *	chars.	Makes sure there's room for an extra '\0' char at
 *	the end of the buffer to terminate the string.	*/
#define BufExpand(bp,nb)				\
do {							\
	size_t   occupied = (bp)->inPtr - (bp)->buffer;	\
	size_t   size = (bp)->endPtr - (bp)->buffer;	\
	DO_STAT_BUF(bp, nb);				\
							\
	do {						\
		if (size <= SIZE_MAX/2) {		\
			size *= 2 ;			\
		} else {				\
			fatal_overflow();		\
		}					\
	} while (size - occupied < (nb)+1+BUF_MARGIN);	\
	(bp)->buffer = (bp)->inPtr = (bp)->endPtr = 	\
		erealloc((bp)->buffer, size);		\
	(bp)->inPtr += occupied;			\
	(bp)->endPtr += size;				\
} while (0);

#define BUF_DEF_SIZE	256	/* Default buffer size */
#define BUF_MARGIN	256	/* Make sure we are comfortable */

/* the hard case for Buf_AddChar: buffer must be expanded to accommodate
 * one more char.  */
void
BufOverflow(Buffer bp)
{
	BufExpand(bp, 1);
}


void
Buf_AddChars(Buffer bp, size_t numBytes, const char *bytesPtr)
{

	if ((size_t)(bp->endPtr - bp->inPtr) < numBytes+1)
		BufExpand(bp, numBytes);

	memcpy(bp->inPtr, bytesPtr, numBytes);
	bp->inPtr += numBytes;
}

void
Buf_printf(Buffer bp, const char *fmt, ...)
{
	va_list va;
	int n;
	va_start(va, fmt);
	n = vsnprintf(bp->inPtr, bp->endPtr - bp->inPtr, fmt, va);
	va_end(va);
	if (n > bp->endPtr - bp->inPtr) {
		va_list vb;
		BufExpand(bp, n);
		va_start(vb, fmt);
		(void)vsnprintf(bp->inPtr, bp->endPtr - bp->inPtr, fmt, vb);
		va_end(vb);
	}
	bp->inPtr += n;
}

void
Buf_Init(Buffer bp, size_t size)
{
#ifdef STATS_BUF
	STAT_TOTAL_BUFS++;
	if (size == 0)
		STAT_DEFAULT_BUFS++;
	if (size == 1)
		STAT_WEIRD_BUFS++;
#endif
	if (size == 0)
		size = BUF_DEF_SIZE;
	bp->inPtr = bp->endPtr = bp->buffer = emalloc(size);
	bp->endPtr += size;
}
@


1.26
log
@add check for overflow while doubling (very unlikely in practice, but still
better style code). Problem noticed by deraadt@@ in m4.

okay doug@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: buf.c,v 1.25 2012/11/07 14:18:41 espie Exp $	*/
d72 1
@


1.25
log
@say goodbye to killing trailing spaces.
this was yet another weirdness in our make that isn't shared by
other makes, and that isn't part of any standard.
This means end-of-line spaces in variables ARE significant (spaces
around the equal sign still aren't).

okay sthen@@, "sounds fine" deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: buf.c,v 1.24 2012/09/21 07:55:20 espie Exp $	*/
d70 1
d72 1
d91 7
d109 5
a113 1
		size *= 2 ;				\
@


1.24
log
@major overhaul of the way make handle jobs, inspired by dpb:
instead of forking a "job" per target, and having that job further fork
separate commands, have make maintain a list of jobs, indexed by pid
of currently running commands, and handle process termination
continuation-style.  This has lots of benefits:
- make is responsible for most printing, so we no longer need pipes nor
job control: make -j jobs see the tty.
- no more special-casing for jobs that don't really execute anything.
- unify code for make -jn and make -B, including signal handlers and
job waiting.  So make -n, make -q, +cmd now run commands in the same
way in all cases.
- unified more accurate error-reporting, as make knows precisely which
command failed. Commands are tagged with their lines, and we display failing
commands in silent mode.
- fine-grained "expensive" command handling (recursion limiter). Do it
per-command instead of per-target.

Moreover, signal response is now simpler, as we just block the signals
in a small critical sections, test for events, and sigpause (thanks a lot
to guenther@@ and millert@@), so running make is now almost always paused
without any busy-waiting.

Thanks to everyone who tested and gave input.
@
text
@d1 1
a1 1
/*	$OpenBSD: buf.c,v 1.23 2010/07/19 19:46:43 espie Exp $	*/
a162 10
}

void
Buf_KillTrailingSpaces(Buffer bp)
{
	while (bp->inPtr > bp->buffer + 1 && isspace(bp->inPtr[-1])) {
		if (bp->inPtr[-2] == '\\')
		    break;
		bp->inPtr--;
	}
@


1.23
log
@Correct $OpenBSD$ stuff
@
text
@d1 1
a1 1
/*	$OpenBSD: buf.c,v 1.22 2010/07/19 19:30:37 espie Exp $	*/
d72 2
d131 17
@


1.22
log
@two small changes:
- allow variables in SysV modifiers, as requested by matthieu@@
(since recursive variables are an extension, this just extends the
extension)
- variation on :Q  called :QL (quote list), which does quote every character
EXCEPT for whitespace. e.g.,

toto:
	@@for i in ${VAR:QL} ...
@
text
@d1 1
a1 2
/*	$OpenPackages$ */
/*	$OpenBSD$	*/
@


1.21
log
@reindent (no binary change)
@
text
@d2 1
a2 1
/*	$OpenBSD: buf.c,v 1.20 2004/04/07 13:11:35 espie Exp $	*/
@


1.20
log
@ISO function declarations, trim a few comments, rename a few variables to
more explicit/more consistent names.

okay otto@@
@
text
@d2 1
a2 1
/*	$OpenBSD: buf.c,v 1.19 2003/06/03 02:56:11 millert Exp $	*/
d94 3
a96 3
    size_t   occupied = (bp)->inPtr - (bp)->buffer;	\
    size_t   size = (bp)->endPtr - (bp)->buffer;	\
    DO_STAT_BUF(bp, nb);				\
d98 7
a104 7
    do {						\
	size *= 2 ;					\
    } while (size - occupied < (nb)+1+BUF_MARGIN);	\
    (bp)->buffer = (bp)->inPtr = (bp)->endPtr = 	\
	erealloc((bp)->buffer, size);			\
    (bp)->inPtr += occupied;				\
    (bp)->endPtr += size;				\
d115 1
a115 1
    BufExpand(bp, 1);
d123 2
a124 2
    if ((size_t)(bp->endPtr - bp->inPtr) < numBytes+1)
	BufExpand(bp, numBytes);
d126 2
a127 2
    memcpy(bp->inPtr, bytesPtr, numBytes);
    bp->inPtr += numBytes;
d135 5
a139 5
    STAT_TOTAL_BUFS++;
    if (size == 0)
	STAT_DEFAULT_BUFS++;
    if (size == 1)
	STAT_WEIRD_BUFS++;
d141 4
a144 4
    if (size == 0)
	size = BUF_DEF_SIZE;
    bp->inPtr = bp->endPtr = bp->buffer = emalloc(size);
    bp->endPtr += size;
d150 5
a154 5
    while (bp->inPtr > bp->buffer + 1 && isspace(bp->inPtr[-1])) {
	if (bp->inPtr[-2] == '\\')
	    break;
	bp->inPtr--;
    }
@


1.19
log
@Remove the advertising clause in the UCB license which Berkeley
rescinded 22 July 1999.  Proofed by myself and Theo.
@
text
@d2 1
a2 1
/*	$OpenBSD: buf.c,v 1.18 2001/05/30 00:43:00 deraadt Exp $	*/
d67 1
a67 1
 *	Functions for automatically-expanded buffers.
d113 1
a113 2
BufOverflow(bp)
    Buffer bp;
d120 1
a120 4
Buf_AddChars(bp, numBytes, bytesPtr)
    Buffer	bp;
    size_t	numBytes;
    const char	*bytesPtr;
d132 1
a132 3
Buf_Init(bp, size)
    Buffer bp;
    size_t    size;
d148 1
a148 2
Buf_KillTrailingSpaces(bp)
    Buffer bp;
@


1.18
log
@-Wall cleanup, mostly useless otherwise
@
text
@d2 1
a2 1
/*	$OpenBSD: buf.c,v 1.17 2001/05/29 12:17:03 espie Exp $	*/
d48 1
a48 5
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
@


1.17
log
@Blech! gcc is a stupid program. Compiling with -fno-builtin shows lots
of missing function declarations.
@
text
@d2 1
a2 1
/*	$OpenBSD: buf.c,v 1.16 2001/05/23 12:34:40 espie Exp $	*/
d131 1
a131 1
    if (bp->endPtr - bp->inPtr < numBytes+1)
@


1.16
log
@Mostly clean-up:
- cut up those huge include files into separate interfaces for all modules.
Put the interface documentation there, and not with the implementation.
- light-weight includes for needed concrete types (lst_t.h, timestamp_t.h).
- cut out some more logically separate parts: cmd_exec, varname, parsevar,
timestamp.
- put all error handling functions together, so that we will be able to
clean them up.
- more systematic naming: functioni  to handle interval, function to handle
string.
- put the init/end code apart to minimize coupling.
- kill weird types like ReturnStatus and Boolean. Use standard bool (with a
fallback for non-iso systems)
- better interface documentation for lots of subsystems.

As a result, make compilation goes somewhat faster (5%, even considering
the largish BSD copyrights to read). The corresponding preprocessed
source goes down from 1,5M to 1M.

A few minor code changes as well: Parse_DoVar is no longer destructive.
Parse_IsVar functionality is folded into Parse_DoVar (as it knows what an
assignment is), a few more interval handling functions. Avoid calling
XXX_End when they do nothing, just #define XXX_End   to nothing.

Parse_DoVar is slightly more general: it will handle compound assignments
as long as they make sense, e.g., VAR +!= cmd
will work.  As a side effect, VAR++=value now triggers an error
(two + in assignment).
- this stuff doesn't occur in portable Makefiles.
- writing VAR++ = value or VAR+ +=value  disambiguates it.
- this is a good thing, it uncovered a bug in bsd.port.mk.

Tested by naddy@@. Okayed millert@@. I'll handle the fallback if there is
any. This went through a full make build anyways, including isakmpd
(without mickey's custom binutils, as he didn't see fit to share it with me).
@
text
@d2 1
a2 1
/*	$OpenBSD: buf.c,v 1.7 1999/10/05 21:59:00 espie Exp $	*/
d76 1
@


1.15
log
@Synch with my current work.
Numerous changes:
- generate can build several tables
- style cleanup
- statistics code
- use variable names throughout (struct Name)
- recursive variables everywhere
- faster parser (pass buffer along instead of allocating multiple copies)
- correct parser. Handles comments everywhere, and ; correctly
- more string intervals
- simplified dir.c, less recursion.
- extended for loops
- sinclude()
- finished removing extra junk from Lst_*
- handles ${@@D} and friends in a simpler way
- cleaned up and modular VarModifiers handling.
- recognizes some gnu Makefile usages and errors out about them.

Additionally, some extra functionality is defined by FEATURES. The set of
functionalities is currently hardcoded to OpenBSD defaults, but this may
include support for some NetBSD extensions, like ODE modifiers.

Backed by miod@@ and millert@@, who finally got sick of my endless patches...
@
text
@d74 7
a80 14
#include    "sprite.h"
#include    "make.h"
#include    "buf.h"
#include    "stats.h"

#ifndef lint
#if 0
static char sccsid[] = "@@(#)buf.c	8.1 (Berkeley) 6/6/93";
#else
UNUSED
static char rcsid[] = "$OpenBSD: buf.c,v 1.7 1999/10/05 21:59:00 espie Exp $";
#endif
#endif /* not lint */

d91 2
a92 2
/* BufExpand --
 *	Expand the given buffer to hold the given number of additional
d113 1
a113 1
/* Buf_AddChar hard case: buffer must be expanded to accommodate
d140 2
a141 2
    Buffer bp;		/* New Buffer to initialize */
    size_t    size;	/* Initial size for the buffer */
@


1.14
log
@Clean-ups:
* Buf_Destroy can be a macro
* X_ instead of _X for struct names, to avoid infringing on the system's
namespace.
* better wildcard detection heuristics
* fix #ifdef CLEANUP code
* a few comments
@
text
@d1 3
a3 2
/*	$OpenBSD: buf.c,v 1.13 2000/09/14 13:32:05 espie Exp $	*/
/*	$NetBSD: buf.c,v 1.9 1996/12/31 17:53:21 christos Exp $	*/
d8 1
a8 1
 * Extensive code modifications for the OpenBSD project.
a30 1

d77 1
d84 1
a84 1
static char rcsid[] = "$OpenBSD: buf.c,v 1.13 2000/09/14 13:32:05 espie Exp $";
d88 10
d99 4
a102 4
 * 	Expand the given buffer to hold the given number of additional
 *	chars.  Makes sure there's room for an extra '\0' char at 
 *	the end of the buffer to terminate the string.  */
#define BufExpand(bp,nb) 				\
d106 1
d108 2
a109 2
    do { 						\
	size *= 2 ; 					\
d112 1
a112 1
	erealloc((bp)->buffer, size); 			\
d117 1
a117 1
#define BUF_DEF_SIZE	256 	/* Default buffer size */
d120 1
a120 1
/* Buf_AddChar hard case: buffer must be expanded to accommodate 
d129 1
d132 1
a132 1
    Buffer 	bp;
d134 1
a134 1
    const char 	*bytesPtr;
d144 1
d147 2
a148 2
    Buffer 	bp;	/* New Buffer */
    size_t    	size;	/* Initial size for the buffer */
d150 7
d164 2
a165 3
Buf_ReplaceLastChar(buf, byte)
    Buffer 	buf;	/* buffer to augment */
    char 	byte;	/* byte to be written */
d167 5
a171 4
    if (buf->inPtr == buf->buffer)
        Buf_AddChar(buf, byte);
    else
        *(buf->inPtr - 1) = byte;
@


1.13
log
@Some systematic clean-up.
- UNUSED macro that expands to __attribute__((unused)) for gcc
- move rcsid around so that they can be tagged UNUSED.
- activate -Wunused.
- use UNUSED instead of kludgy junk for function arguments.
- add extern to all extern prototypes.
- update comments in lst.h.
- clean up var.c a little bit, constifying arguments, updating comments...
@
text
@d1 1
a1 1
/*	$OpenBSD: buf.c,v 1.12 1999/12/16 17:02:45 espie Exp $	*/
d83 1
a83 1
static char rcsid[] = "$OpenBSD: buf.c,v 1.12 1999/12/16 17:02:45 espie Exp $";
d136 1
a136 1
    if (size == 0) {
a137 1
    }
a139 7
}

void
Buf_Destroy(buf)
    Buffer  buf;  	/* Buffer to destroy */
{
    free(buf->buffer);
@


1.12
log
@Allocate buffers as static data structures.
This cuts down quite a lot of malloc, since in actual use,
buffer usage is mostly static.
@
text
@d1 1
a1 1
/*	$OpenBSD: buf.c,v 1.11 1999/12/16 16:46:38 espie Exp $	*/
a68 8
#ifndef lint
#if 0
static char sccsid[] = "@@(#)buf.c	8.1 (Berkeley) 6/6/93";
#else
static char rcsid[] = "$OpenBSD: buf.c,v 1.11 1999/12/16 16:46:38 espie Exp $";
#endif
#endif /* not lint */

d77 9
@


1.11
log
@Remove redundant fields from struct Buffer.
@
text
@d1 1
a1 1
/*	$OpenBSD: buf.c,v 1.10 1999/12/16 16:41:41 espie Exp $	*/
d73 1
a73 1
static char rcsid[] = "$OpenBSD: buf.c,v 1.10 1999/12/16 16:41:41 espie Exp $";
d130 3
a132 2
Buffer
Buf_Init(size)
a134 4
    Buffer 	bp;	/* New Buffer */

    bp = (Buffer)emalloc(sizeof(*bp));

a139 2

    return (bp);
d143 1
a143 1
Buf_Destroy(buf, freeData)
a144 1
    Boolean freeData;	/* TRUE if the data should be destroyed as well */
d146 1
a146 5

    if (freeData) {
	free(buf->buffer);
    }
    free ((char *)buf);
@


1.10
log
@Split Buf_GetAll into Buf_Retrieve/Buf_Size.
(idiotic to retrieve size every time when it's used half the time)
@
text
@d1 1
a1 1
/*	$OpenBSD: buf.c,v 1.9 1999/12/16 16:27:12 espie Exp $	*/
d73 1
a73 1
static char rcsid[] = "$OpenBSD: buf.c,v 1.9 1999/12/16 16:27:12 espie Exp $";
d86 1
a86 6
#ifndef max
#define max(a,b)  ((a) > (b) ? (a) : (b))
#endif

/*
 * BufExpand --
d88 15
a102 19
 *	chars.
 *	Makes sure there's room for an extra NULL char at the end of the
 *	buffer in case it holds a string.
 */
#define BufExpand(bp,nb) 					\
do {								\
    char  *newBuf; 						\
    size_t   newSize = (bp)->size; 				\
								\
    do { 							\
	newSize *= 2 ; 						\
	(bp)->left = newSize - ((bp)->inPtr - (bp)->buffer); 	\
    } while ((bp)->left < (nb)+1+BUF_MARGIN);			\
    newBuf = erealloc((bp)->buffer, newSize); 		\
    (bp)->inPtr = newBuf + ((bp)->inPtr - (bp)->buffer); 	\
    (bp)->outPtr = newBuf + ((bp)->outPtr - (bp)->buffer); 	\
    (bp)->buffer = newBuf; 					\
    (bp)->size = newSize; 					\
} while (0)
d115 1
a115 11

/*-
 *-----------------------------------------------------------------------
 * Buf_AddChars --
 *	Add a number of chars to the buffer.
 *
 * Side Effects:
 *	Guess what?
 *
 *-----------------------------------------------------------------------
 */
d123 1
a123 1
    if (bp->left < numBytes+1)
a127 1
    bp->left -= numBytes;
a128 15

/*-
 *-----------------------------------------------------------------------
 * Buf_Reset -
 *	Throw away all chars in a buffer.
 *
 * Side Effects:
 *	The chars are discarded.
 *
 *-----------------------------------------------------------------------
 */
void
Buf_Reset(bp)
    Buffer 	bp;
{
a129 19
    bp->inPtr = bp->outPtr = bp->buffer;
    bp->left = bp->size;
}

/*-
 *-----------------------------------------------------------------------
 * Buf_Init --
 *	Initialize a buffer. If no initial size is given, a reasonable
 *	default is used.
 *
 * Results:
 *	A buffer to be given to other functions in this library.
 *
 * Side Effects:
 *	The buffer is created, the space allocated and pointers
 *	initialized.
 *
 *-----------------------------------------------------------------------
 */
d141 2
a142 3
    bp->left = bp->size = size;
    bp->buffer = emalloc(size);
    bp->inPtr = bp->outPtr = bp->buffer;
d146 1
a146 11

/*-
 *-----------------------------------------------------------------------
 * Buf_Destroy --
 *	Nuke a buffer and all its resources.
 *
 * Side Effects:
 *	The buffer is freed.
 *
 *-----------------------------------------------------------------------
 */
d158 1
a158 12

/*-
 *-----------------------------------------------------------------------
 * Buf_ReplaceLastChar --
 *     Replace the last char in a buffer.
 *
 * Side Effects:
 *     If the buffer was empty intially, then a new byte will be added.
 *     Otherwise, the last byte is overwritten.
 *
 *-----------------------------------------------------------------------
 */
d164 1
a164 1
    if (buf->inPtr == buf->outPtr)
@


1.9
log
@Start cleaning up buf.c in earnest.

- Buf_Discard is only used to remove all the bytes in a buffer,
replace with Buf_Reset,
- buffer values are not read unless accessed first through Buf_GetAll,
no need to null-terminate it at every point.
- Buf_Expand need not check if the expansion is needed. That's Buf_AddChar
and Buf_AddChars responsability (otherwise, Buf_AddChar checks twice)
- Buf_Overflow only handles overflow. Adding the character is done in
every case anyway.
@
text
@d1 1
a1 1
/*	$OpenBSD: buf.c,v 1.8 1999/12/06 22:24:31 espie Exp $	*/
d73 1
a73 1
static char rcsid[] = "$OpenBSD: buf.c,v 1.8 1999/12/06 22:24:31 espie Exp $";
a151 24
 * Buf_GetAll --
 *	Get all the available data at once.
 *
 * Results:
 *	A pointer to the data and the number of chars available.
 *
 *-----------------------------------------------------------------------
 */
char *
Buf_GetAll(bp, numBytesPtr)
    Buffer 	bp;
    size_t	*numBytesPtr;
{

    if (numBytesPtr != NULL) {
	*numBytesPtr = bp->inPtr - bp->outPtr;
    }

    *bp->inPtr = 0;
    return (bp->outPtr);
}

/*-
 *-----------------------------------------------------------------------
a166 18
}

/*-
 *-----------------------------------------------------------------------
 * Buf_Size --
 *	Returns the number of chars in the given buffer. Doesn't include
 *	the null-terminating char.
 *
 * Results:
 *	The number of chars.
 *
 *-----------------------------------------------------------------------
 */
int
Buf_Size(buf)
    Buffer  buf;
{
    return (buf->inPtr - buf->outPtr);
@


1.8
log
@Clean up buffers interface somewhat:

- buf.c deals exclusively with chars. Be explicit about it, and remove
extraneous dumb casts to char (can hide real type errors).
- buffer sizes are size_t. Note that bp->left can never become NULL.
- Buf_GetAll is happy with a NULL pointer for the size, remove unneeded
extra pointers.
- Propagate size_t to all places where buffer functions are used.
@
text
@d1 1
a1 1
/*	$OpenBSD: buf.c,v 1.7 1999/10/05 21:59:00 espie Exp $	*/
d73 1
a73 1
static char rcsid[] = "$OpenBSD: buf.c,v 1.7 1999/10/05 21:59:00 espie Exp $";
d97 15
a111 15
#define BufExpand(bp,nb) 						\
 	if (bp->left < (nb)+1) {					\
	    char  *newBuf; 						\
	    size_t   newSize = (bp)->size; 				\
									\
	    do { 							\
		newSize *= 2 ; 						\
		(bp)->left = newSize - ((bp)->inPtr - (bp)->buffer); 	\
	    } while ((bp)->left < (nb)+1+BUF_MARGIN);			\
	    newBuf = erealloc((bp)->buffer, newSize); 		\
	    (bp)->inPtr = newBuf + ((bp)->inPtr - (bp)->buffer); 	\
	    (bp)->outPtr = newBuf + ((bp)->outPtr - (bp)->buffer); 	\
	    (bp)->buffer = newBuf; 					\
	    (bp)->size = newSize; 					\
	}
d116 2
a117 10
/*-
 *-----------------------------------------------------------------------
 * Buf_OvAddChar --
 *	Add a single char to the buffer.  
 *
 * Side Effects:
 *	The buffer may be expanded.
 *
 *-----------------------------------------------------------------------
 */
d119 2
a120 3
Buf_OvAddChar(bp, byte)
    Buffer 	bp;
    char	byte;
a122 8

    *bp->inPtr++ = byte;
    bp->left--;

    /*
     * Null-terminate
     */
    *bp->inPtr = 0;
d142 2
a143 1
    BufExpand(bp, numBytes);
a147 5

    /*
     * Null-terminate
     */
    *bp->inPtr = 0;
d170 1
d176 2
a177 2
 * Buf_Discard --
 *	Throw away chars in a buffer.
d185 1
a185 1
Buf_Discard(bp, numBytes)
a186 1
    size_t	numBytes;
d189 2
a190 7
    if (bp->inPtr - bp->outPtr <= numBytes) {
	bp->inPtr = bp->outPtr = bp->buffer;
	bp->left = bp->size;
	*bp->inPtr = 0;
    } else {
	bp->outPtr += numBytes;
    }
d205 1
a205 1
Buf_Size (buf)
a239 1
    *bp->inPtr = 0;
@


1.7
log
@Kill unused functions Buf_UngetByte, Buf_UngetBytes, Buf_GetByte, Buf_GetBytes.
Replace the buffer reallocation mechanism with something much more
efficient.

Originally from NetBSD. Tweaks to the allocator to first loop finding the
correct size, then reallocate; change the heuristic to double the size
until we're over what's needed by some fixed amount.
@
text
@d1 1
a1 1
/*	$OpenBSD: buf.c,v 1.6 1998/12/05 00:06:27 espie Exp $	*/
d5 27
d73 1
a73 1
static char rcsid[] = "$OpenBSD: buf.c,v 1.6 1998/12/05 00:06:27 espie Exp $";
d93 2
a94 2
 *	bytes.
 *	Makes sure there's room for an extra NULL byte at the end of the
d99 2
a100 2
	    Byte  *newBuf; 						\
	    int   newSize = (bp)->size; 				\
d106 1
a106 1
	    newBuf = (Byte *) erealloc((bp)->buffer, newSize); 		\
d118 2
a119 5
 * Buf_OvAddByte --
 *	Add a single byte to the buffer.  left is zero or negative.
 *
 * Results:
 *	None.
d127 3
a129 3
Buf_OvAddByte (bp, byte)
    register Buffer bp;
    int    byte;
d131 1
a131 3
    int nbytes = 1;
    bp->left = 0;
    BufExpand (bp, nbytes);
d144 2
a145 5
 * Buf_AddBytes --
 *	Add a number of bytes to the buffer.
 *
 * Results:
 *	None.
d153 4
a156 4
Buf_AddBytes (bp, numBytes, bytesPtr)
    register Buffer bp;
    int	    numBytes;
    const Byte *bytesPtr;
d159 1
a159 1
    BufExpand (bp, numBytes);
d161 1
a161 1
    memcpy (bp->inPtr, bytesPtr, numBytes);
d177 1
a177 4
 *	A pointer to the data and the number of bytes available.
 *
 * Side Effects:
 *	None.
d181 4
a184 4
Byte *
Buf_GetAll (bp, numBytesPtr)
    register Buffer bp;
    int	    *numBytesPtr;
d187 1
a187 1
    if (numBytesPtr != (int *)NULL) {
d197 1
a197 4
 *	Throw away bytes in a buffer.
 *
 * Results:
 *	None.
d200 1
a200 1
 *	The bytes are discarded.
d205 3
a207 3
Buf_Discard (bp, numBytes)
    register Buffer bp;
    int	    numBytes;
d222 2
a223 2
 *	Returns the number of bytes in the given buffer. Doesn't include
 *	the null-terminating byte.
d226 1
a226 4
 *	The number of bytes.
 *
 * Side Effects:
 *	None.
d253 2
a254 2
Buf_Init (size)
    int	    size; 	/* Initial size for the buffer */
d256 1
a256 1
    Buffer bp;	  	/* New Buffer */
d260 1
a260 1
    if (size <= 0) {
d264 1
a264 1
    bp->buffer = (Byte *)emalloc(size);
a275 3
 * Results:
 *	None.
 *
d282 1
a282 1
Buf_Destroy (buf, freeData)
d288 1
a288 1
	free ((char *)buf->buffer);
d295 2
a296 5
 * Buf_ReplaceLastByte --
 *     Replace the last byte in a buffer.
 *
 * Results:
 *     None.
d305 3
a307 3
Buf_ReplaceLastByte (buf, byte)
    Buffer buf;	/* buffer to augment */
    int byte;	/* byte to be written */
d310 1
a310 1
        Buf_AddByte(buf, byte);
@


1.6
log
@Modifications from netbsd:
- don't interfere with MACHINE/MACHINE_ARCH defines for bootstrap
- type clean-up, time_t, and printing `unknown' ints
- fix TARGET/MEMBER bug in archive rules
- memmove...
- cleaner Error handler.
- reentrant brk_string
- .MAKE env variable
- preliminary scaffolding for .NOPATH

Other improvements:
- efree
- shellneed streamlined
- display Stop in .CURDIR after an error.
- document most features and misfeatures.
- add a few OpenBSD notes to the tutorial.
@
text
@d1 1
a1 1
/*	$OpenBSD: buf.c,v 1.4 1996/11/30 21:08:50 millert Exp $	*/
d46 1
a46 1
static char rcsid[] = "$OpenBSD: buf.c,v 1.4 1996/11/30 21:08:50 millert Exp $";
d70 14
a83 10
#define BufExpand(bp,nb) \
 	if (bp->left < (nb)+1) {\
	    int newSize = (bp)->size + max((nb)+1,BUF_ADD_INC); \
	    Byte  *newBuf = (Byte *) erealloc((bp)->buffer, newSize); \
	    \
	    (bp)->inPtr = newBuf + ((bp)->inPtr - (bp)->buffer); \
	    (bp)->outPtr = newBuf + ((bp)->outPtr - (bp)->buffer);\
	    (bp)->buffer = newBuf;\
	    (bp)->size = newSize;\
	    (bp)->left = newSize - ((bp)->inPtr - (bp)->buffer);\
d87 1
a87 2
#define BUF_ADD_INC	256 	/* Expansion increment when Adding */
#define BUF_UNGET_INC	16  	/* Expansion increment when Ungetting */
a149 162
}

/*-
 *-----------------------------------------------------------------------
 * Buf_UngetByte --
 *	Place the byte back at the beginning of the buffer.
 *
 * Results:
 *	SUCCESS if the byte was added ok. FAILURE if not.
 *
 * Side Effects:
 *	The byte is stuffed in the buffer and outPtr is decremented.
 *
 *-----------------------------------------------------------------------
 */
void
Buf_UngetByte (bp, byte)
    register Buffer bp;
    int    byte;
{

    if (bp->outPtr != bp->buffer) {
	bp->outPtr--;
	*bp->outPtr = byte;
    } else if (bp->outPtr == bp->inPtr) {
	*bp->inPtr = byte;
	bp->inPtr++;
	bp->left--;
	*bp->inPtr = 0;
    } else {
	/*
	 * Yech. have to expand the buffer to stuff this thing in.
	 * We use a different expansion constant because people don't
	 * usually push back many bytes when they're doing it a byte at
	 * a time...
	 */
	int 	  numBytes = bp->inPtr - bp->outPtr;
	Byte	  *newBuf;

	newBuf = (Byte *)emalloc(bp->size + BUF_UNGET_INC);
	memcpy ((char *)(newBuf+BUF_UNGET_INC), (char *)bp->outPtr, numBytes+1);
	bp->outPtr = newBuf + BUF_UNGET_INC;
	bp->inPtr = bp->outPtr + numBytes;
	free ((char *)bp->buffer);
	bp->buffer = newBuf;
	bp->size += BUF_UNGET_INC;
	bp->left = bp->size - (bp->inPtr - bp->buffer);
	bp->outPtr -= 1;
	*bp->outPtr = byte;
    }
}

/*-
 *-----------------------------------------------------------------------
 * Buf_UngetBytes --
 *	Push back a series of bytes at the beginning of the buffer.
 *
 * Results:
 *	None.
 *
 * Side Effects:
 *	outPtr is decremented and the bytes copied into the buffer.
 *
 *-----------------------------------------------------------------------
 */
void
Buf_UngetBytes (bp, numBytes, bytesPtr)
    register Buffer bp;
    int	    numBytes;
    Byte    *bytesPtr;
{

    if (bp->outPtr - bp->buffer >= numBytes) {
	bp->outPtr -= numBytes;
	memcpy (bp->outPtr, bytesPtr, numBytes);
    } else if (bp->outPtr == bp->inPtr) {
	Buf_AddBytes (bp, numBytes, bytesPtr);
    } else {
	int 	  curNumBytes = bp->inPtr - bp->outPtr;
	Byte	  *newBuf;
	int 	  newBytes = max(numBytes,BUF_UNGET_INC);

	newBuf = (Byte *)emalloc (bp->size + newBytes);
	memcpy((char *)(newBuf+newBytes), (char *)bp->outPtr, curNumBytes+1);
	bp->outPtr = newBuf + newBytes;
	bp->inPtr = bp->outPtr + curNumBytes;
	free ((char *)bp->buffer);
	bp->buffer = newBuf;
	bp->size += newBytes;
	bp->left = bp->size - (bp->inPtr - bp->buffer);
	bp->outPtr -= numBytes;
	memcpy ((char *)bp->outPtr, (char *)bytesPtr, numBytes);
    }
}

/*-
 *-----------------------------------------------------------------------
 * Buf_GetByte --
 *	Return the next byte from the buffer. Actually returns an integer.
 *
 * Results:
 *	Returns BUF_ERROR if there's no byte in the buffer, or the byte
 *	itself if there is one.
 *
 * Side Effects:
 *	outPtr is incremented and both outPtr and inPtr will be reset if
 *	the buffer is emptied.
 *
 *-----------------------------------------------------------------------
 */
int
Buf_GetByte (bp)
    register Buffer bp;
{
    int	    res;

    if (bp->inPtr == bp->outPtr) {
	return (BUF_ERROR);
    } else {
	res = (int) *bp->outPtr;
	bp->outPtr += 1;
	if (bp->outPtr == bp->inPtr) {
	    bp->outPtr = bp->inPtr = bp->buffer;
	    bp->left = bp->size;
	    *bp->inPtr = 0;
	}
	return (res);
    }
}

/*-
 *-----------------------------------------------------------------------
 * Buf_GetBytes --
 *	Extract a number of bytes from the buffer.
 *
 * Results:
 *	The number of bytes gotten.
 *
 * Side Effects:
 *	The passed array is overwritten.
 *
 *-----------------------------------------------------------------------
 */
int
Buf_GetBytes (bp, numBytes, bytesPtr)
    register Buffer bp;
    int	    numBytes;
    Byte    *bytesPtr;
{

    if (bp->inPtr - bp->outPtr < numBytes) {
	numBytes = bp->inPtr - bp->outPtr;
    }
    memcpy (bytesPtr, bp->outPtr, numBytes);
    bp->outPtr += numBytes;

    if (bp->outPtr == bp->inPtr) {
	bp->outPtr = bp->inPtr = bp->buffer;
	bp->left = bp->size;
	*bp->inPtr = 0;
    }
    return (numBytes);
@


1.5
log
@Sync with NetBSD (mostly by christos initial substitution/regexp from Der Mouse)

- fix the variable substitution code in make [PR/2748]
      1. change s/a/b/ so that it substitutes the first occurance of the
         pattern on each word, not only the first word.
      2. add flag '1' to the variable substitution so that the substitutions
         get performed only once.

  ***THIS IS AN INCOMPATIBLE CHANGE!***

  Unfortunately there was no way to make things consistent without
  modifying the current behavior. Fortunately none of our Makefiles
  depended on this.

            OLD:

                VAR      = aa1 aa2 aa3 aa4

                S/a/b/   = ba1 aa2 aa3 aa4
                S/a/b/g  = bb1 bb2 bb3 bb4

            NEW:
                VAR      = aa1 aa2 aa3 aa4

                S/a/b/   = ba1 ba2 ba3 ba4
                S/a/b/1  = ba1 aa2 aa3 aa4
                S/a/b/g  = bb1 bb2 bb3 bb4
                S/a/b/1g = bb1 aa2 aa3 aa4
- add regexp variable substitution via 'C/foo/bar/' [PR/2752]
- add variable quoting via the ${VAR:Q} modifier. This is useful when running
  recursive invocations of make(1):

        make VAR=${VAR:Q}

  will always work... (This may prove useful in the kernel builds...) [PR/2981]
- BSD did not traditionally have <sys/cdefs.h>; use BSD4_4 instead and include
  <sys/param.h> to grab it.
- Don't compile the regex code if MAKE_BOOTSTRAP (from gwr)
- Use explicit .c.o rule in Makefile.boot so that the bootstrap process works.
- Use only integral types in procedure arguments. [buf.c buf.h]
- Include <stdlib.h> to get getenv() prototype on SVR4
- if __STDC__ -> ifdef __STDC__ to appease SVR4
- Define const and volatile for non __STDC__
- Implement snprintf() and vsnprintf() for non BSD4_4 systems.
- Make $MACHINE_ARCH settable from the environment.
- Fix .USE directive problems: (reported by cgd)
    1. ${.*} variables did not get expanded in dependencies.
    2. expanded ${.*} variables in .USE dependencies can cause tree
       restructuring; handle it.
    3. in compat mode, expand .USE before evaluating the list of targets,
       instead of doing .USE expansions on demand, because they can cause
       tree restructuring.
- Add a .MADE directive to indicated that the children of a target are
  up-to-date, even when they are not. This is to simulate our current
  make install behavior with proper dependencies.
- Fix problems in the RE substitution error handling.
- Locate all the children of a node marked as MADE.
- Do not compile-in ${MACHINE} (as per NetBSD PR#3386)
- Disable globbing for targets/dependencies when POSIX is defined.
- Fix globbing so that patterns that don't have a matching number of [] or {}
  don't get expanded. (before the [ case got expanded to nothing!) This is
  disabled.
- Make sure that the children of nodes that are marked .MADE, are marked
  UPTODATE and their timestamps are consistent.
- Don't disable wildcards completely; they are used by other Makefiles.
@
text
@@


1.4
log
@Sync with NetBSD:
- Merge in FreeBSD and Lite2 changes.
- Fix bug where a non-archive target with a .a suffix would always
  be considered to be out of date, since it does not have a TOC.
- Fix NetBSD PR #2930: declare missing variable.
@
text
@d1 2
a2 2
/*	$OpenBSD: buf.c,v 1.3 1996/06/26 05:36:25 deraadt Exp $	*/
/*	$NetBSD: buf.c,v 1.8 1996/11/06 17:59:00 christos Exp $	*/
d46 1
a46 1
static char rcsid[] = "$OpenBSD: buf.c,v 1.3 1996/06/26 05:36:25 deraadt Exp $";
d462 1
a462 1
    Byte byte;	/* byte to be written */
@


1.3
log
@rcsid
@
text
@d1 2
a2 2
/*	$OpenBSD: buf.c,v 1.7 1996/03/29 02:17:13 jtc Exp $	*/
/*	$NetBSD: buf.c,v 1.7 1996/03/29 02:17:13 jtc Exp $	*/
d44 1
a44 1
static char sccsid[] = "@@(#)buf.c	5.5 (Berkeley) 12/28/90";
d46 1
a46 1
static char rcsid[] = "$OpenBSD: buf.c,v 1.7 1996/03/29 02:17:13 jtc Exp $";
d134 1
a134 1
    Byte    *bytesPtr;
d296 1
a296 1
    
d333 1
a333 1
    
d346 1
a346 1
 *	The bytes are discarded. 
d438 1
a438 1
    
d443 25
@


1.2
log
@sync to netbsd 960418
@
text
@d1 1
d46 1
a46 1
static char rcsid[] = "$NetBSD: buf.c,v 1.7 1996/03/29 02:17:13 jtc Exp $";
@


1.1
log
@Initial revision
@
text
@d1 1
a1 1
/*	$NetBSD: buf.c,v 1.6 1995/06/14 15:18:51 christos Exp $	*/
d45 1
a45 1
static char rcsid[] = "$NetBSD: buf.c,v 1.6 1995/06/14 15:18:51 christos Exp $";
d72 1
a72 1
	    Byte  *newBuf = (Byte *) realloc((bp)->buffer, newSize); \
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@
